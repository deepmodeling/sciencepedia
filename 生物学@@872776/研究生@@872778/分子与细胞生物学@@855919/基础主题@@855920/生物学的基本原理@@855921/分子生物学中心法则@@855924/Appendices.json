{"hands_on_practices": [{"introduction": "中心法则的基石在于遗传信息能够以极高的保真度代代相传。然而，DNA复制过程并非绝对完美，它受到聚合酶引入错误和细胞修复机制校正之间的动态平衡的制约。这项练习将引导你运用概率论的基本原理，来量化评估在一个细胞周期中，由于复制错误和修复失败而产生的预期突变数量，从而让你对宏基因组尺度上的突变率有一个具体的认识。[@problem_id:2965554]", "problem": "一个真核细胞在每次细胞分裂时会复制一个包含 $3.2 \\times 10^{9}$ 个核苷酸位置的线性基因组。在每个位置，脱氧核糖核酸（DNA）聚合酶以边际概率 $\\epsilon_{\\text{pol}} = 10^{-5}$ 错误地掺入一个核苷酸。在3'末端发生错配事件的条件下，外切核酸酶校对机制会尝试移除该错配；校对未能纠正错配的条件概率为 $\\epsilon_{\\text{proof}} = 10^{-2}$。在复制后错配持续存在的条件下，错配修复（MMR）系统会尝试纠正它；错配修复失败的条件概率为 $\\epsilon_{\\text{MMR}} = 10^{-1}$。假设不同位置上的错误事件是独立的，并且在存在错配的情况下，校正失败事件是条件独立的。只有当发生错配并且两个校正系统在下一次复制周期之前都未能纠正时，碱基替换才会成为一个固定突变。\n\n在分子生物学中心法则的框架内（其中高保真复制维持了从DNA到DNA的信息流），请仅使用上述定义以及概率和期望的第一性原理，推导在 $3.2 \\times 10^{9}$ 个位置上每次细胞分裂由复制引起的碱基替换的期望数量的表达式。然后，使用给定的参数值对该期望进行数值计算。将每次分裂的最终替换数报告为一个精确的数字（不要四舍五入，不带单位）。\n\n最后，根据您的结果和关于具有完整校对和错配修复功能的正常人类体细胞中复制保真度的既有定性知识，用文字简要评估您计算出的数值在生物学上是否合理，并定性地证明您的推理（您的定性评估不会影响数值答案的要求）。", "solution": "该问题要求推导并计算在一个复制周期后基因组中成为固定突变的碱基替换的期望数量。这个数量是由DNA聚合酶引入错误与随后由两个主要修复系统（校对和错配修复）进行校正的相互作用决定的。解决方案的基础在于概率论，特别是对一系列相关事件概率的计算，以及期望线性性的应用。\n\n设 $N$ 为基因组中核苷酸位置的总数，给定为 $N = 3.2 \\times 10^{9}$。\n在一个单一位置上，一个碱基替换成为固定突变当且仅当发生了一系列三个事件：初始的错配、校对失败以及随后的错配修复失败。我们必须计算这个复合事件的概率。\n\n让我们为单个核苷酸位置定义事件：\n- $M$：DNA聚合酶错误掺入一个核苷酸的事件。其概率给定为 $P(M) = \\epsilon_{\\text{pol}} = 10^{-5}$。\n- $F_P$：外切核酸酶校对机制未能纠正错配的事件。这是一个条件事件，依赖于错配的发生。问题给出的条件概率为 $P(F_P | M) = \\epsilon_{\\text{proof}} = 10^{-2}$。\n- $F_{MMR}$：错配修复（MMR）系统未能纠正错配的事件。该事件的条件是错配在复制和校对后仍然存在，即条件为事件 $M \\cap F_P$。问题给出的条件概率为 $P(F_{MMR} | M \\cap F_P) = \\epsilon_{\\text{MMR}} = 10^{-1}$。\n\n单个固定替换的概率，我们记为 $\\mu$，是这三个事件交集的概率：$\\mu = P(M \\cap F_P \\cap F_{MMR})$。使用概率的链式法则，我们可以将 $\\mu$ 表示如下：\n$$ \\mu = P(M) \\times P(F_P | M) \\times P(F_{MMR} | M \\cap F_P) $$\n问题陈述提供了右侧所有必需的概率。代入给定的符号参数：\n$$ \\mu = \\epsilon_{\\text{pol}} \\cdot \\epsilon_{\\text{proof}} \\cdot \\epsilon_{\\text{MMR}} $$\n这个表达式代表了在一次细胞分裂中，任何单个核苷酸位置出现固定突变的概率。\n\n现在，我们必须找出在整个包含 $N$ 个位置的基因组中这类突变的总期望数量。设 $X$ 是一个随机变量，代表每次细胞分裂的替换总数。我们可以定义 $N$ 个指示随机变量 $X_1, X_2, \\dots, X_N$，其中如果位置 $i$ 发生固定替换，则 $X_i = 1$，否则 $X_i = 0$。$X_i = 1$ 的概率正是我们上面计算的 $\\mu$。\n替换的总数是这些指示变量的和：$X = \\sum_{i=1}^{N} X_i$。\n\n根据期望的线性性，随机变量之和的期望值等于它们各自期望值的和：\n$$ E[X] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i] $$\n一个指示变量 $X_i$ 的期望等于它所指示事件的概率：$E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = P(X_i=1) = \\mu$。\n由于假设所有位置的突变概率 $\\mu$ 都相同，所以这个和可以简化为：\n$$ E[X] = \\sum_{i=1}^{N} \\mu = N \\cdot \\mu $$\n因此，期望替换数的最终表达式为：\n$$ E[X] = N \\cdot \\epsilon_{\\text{pol}} \\cdot \\epsilon_{\\text{proof}} \\cdot \\epsilon_{\\text{MMR}} $$\n我们现在使用给定的参数值进行数值计算：\n$N = 3.2 \\times 10^{9}$\n$\\epsilon_{\\text{pol}} = 10^{-5}$\n$\\epsilon_{\\text{proof}} = 10^{-2}$\n$\\epsilon_{\\text{MMR}} = 10^{-1}$\n\n首先，我们计算单位点突变概率 $\\mu$：\n$$ \\mu = (10^{-5}) \\times (10^{-2}) \\times (10^{-1}) = 10^{-5-2-1} = 10^{-8} $$\n这是每个位点、每次复制的突变率。\n\n接下来，我们计算替换的总期望数量 $E[X]$：\n$$ E[X] = (3.2 \\times 10^{9}) \\times (10^{-8}) = 3.2 \\times 10^{9-8} = 3.2 \\times 10^{1} = 32 $$\n因此，每次细胞分裂由复制引起的碱基替换的期望数量是 $32$。\n\n最后，我们评估这个结果的生物学合理性。计算得出的总体突变率 $\\mu = 10^{-8}$ 突变/碱基对/复制周期是一个教科书级别的值，与人类及其他哺乳动物生殖系突变率的测量值高度一致。对于一个大小为 $3.2 \\times 10^{9}$ 碱基对的基因组，由此产生的 $32$ 个新突变的期望值也完全在已确立的生物学估计范围之内。关于人类新发突变（这些突变通过细胞分裂累积）的经验研究报告，每一代会出现几十个新突变。因此，单轮基因组复制产生 $32$ 个突变的期望值在科学上是一个合理且可信的数量级。它正确地量化了一个过程的结果，即大量核苷酸以极高但非完美的保真度进行复制。中心法则关于从DNA到DNA信息保存的信条是以高保真度维持的，但这个计算表明它并非绝对。", "answer": "$$\n\\boxed{32}\n$$", "id": "2965554"}, {"introduction": "将基因蓝图转化为功能性分子是一个极其耗能的生物化学过程，构成了细胞主要的能量支出之一。本练习将基因表达的宏伟过程分解为转录和翻译中的基本生化步骤，并为其定价。通过精确计算合成单个mRNA分子和蛋白质所需的高能磷酸键总数，你将对实现中心法则所需付出的生物能量代价有一个定量的深刻理解。[@problem_id:2842316]", "problem": "一轮基因表达合成一个长度为 $3000$ 个核苷酸的信使核糖核酸 (mRNA) 和一个长度为 $1000$ 个氨基酸的蛋白质。仅使用中心法则和大分子酶学的基本定义，根据以下反映了公认生化步骤的明确假设，从第一性原理推导出这一轮基因表达所消耗的高能磷酸等价物的总数精确表达式：\n\n- 由氨酰-tRNA合成酶催化的转运核糖核酸 (tRNA) 的氨酰化（装载）过程消耗三磷酸腺苷 (ATP) 生成单磷酸腺苷 (AMP) 和无机焦磷酸 (PPi)，这对应于每个氨基酸装载消耗 $2$ 个高能磷酸等价物。\n- 核糖体上的翻译延伸过程在每个延伸循环中消耗三磷酸鸟苷 (GTP)：每个形成的肽键需要 $1$ 个 GTP 用于氨酰-tRNA 的递送和 $1$ 个 GTP 用于移位，总计每个肽键消耗 $2$ 个 GTP。每个水解为二磷酸鸟苷 (GDP) 的 GTP 计为 $1$ 个高能磷酸等价物。\n- RNA聚合酶的转录过程每形成一个磷酸二酯键消耗一个核苷三磷酸 (NTP)。对于一个长度为 $m$ 个核苷酸的 RNA，有 $m-1$ 个这样的键；对于每个键，进入的 NTP 裂解为核苷单磷酸 (NMP) 和 PPi 会断裂一个磷酸酐键，随后 PPi 水解为两个无机磷酸盐会断裂第二个高能键。因此，每形成一个磷酸二酯键计为消耗 $2$ 个高能磷酸等价物。\n- 忽略起始、终止、校对、质量控制、mRNA加工（如加帽和多聚腺苷酸化）、降解、核糖体组装以及任何其他未明确列出的额外开销。\n\n计算从一个长度为 $3000$ 个核苷酸的 mRNA 合成一个长度为 $1000$ 个氨基酸的蛋白质所消耗的高能磷酸等价物的总数。以高能磷酸等价物的精确整数形式报告您的最终结果（无单位）。不需要四舍五入，也不允许使用百分比表示法。", "solution": "问题陈述经过验证，被认为是科学上合理的、问题明确的、客观的。它提供了一套清晰、明确的假设和足够的数据，可以从分子生物学和生物化学的第一性原理推导出一个唯一的、精确的解。该问题简化为基于所提供的转录和翻译的生物能量成本的直接计算。我们开始进行推导。\n\n消耗的高能磷酸等价物总数（我们记为 $E_{total}$）是转录（$E_{transcription}$）和翻译（$E_{translation}$）过程中消耗能量的总和。\n$$E_{total} = E_{transcription} + E_{translation}$$\n\n首先，我们计算转录的能量成本。\n合成一个长度为 $m$ 个核苷酸的信使核糖核酸 (mRNA) 分子需要形成 $m-1$ 个磷酸二酯键。问题规定 mRNA 的长度为 $m = 3000$ 个核苷酸。因此，形成的磷酸二酯键数量为 $3000 - 1 = 2999$。\n根据所提供的假设，每形成一个磷酸二酯键消耗 $2$ 个高能磷酸等价物。这包括将一个核苷三磷酸 (NTP) 裂解为一个核苷单磷酸 (NMP) 和无机焦磷酸 (PPi)，以及随后 PPi 的水解。\n因此，转录的总能量成本为：\n$$E_{transcription} = (m-1) \\times 2$$\n代入值 $m=3000$：\n$$E_{transcription} = (3000 - 1) \\times 2 = 2999 \\times 2 = 5998$$\n\n接下来，我们计算翻译的能量成本 $E_{translation}$。在给定的约束条件下，这个过程包括两个不同的能量成本：转运RNA (tRNA) 分子的装载（氨酰化），以及核糖体上多肽链的延伸。\n$$E_{translation} = E_{aminoacylation} + E_{elongation}$$\n\n氨酰化的成本 $E_{aminoacylation}$ 是将每个氨基酸连接到其相应 tRNA 上所需的能量。待合成的蛋白质长度为 $n = 1000$ 个氨基酸。这 $1000$ 个氨基酸中的每一个都必须被“装载”或激活。问题指出，装载一个 tRNA 分子消耗 ATP，生成 AMP 和 PPi，这相当于水解两个磷酸酐键，即每个氨基酸消耗 $2$ 个高能磷酸等价物。\n氨酰化的总成本为：\n$$E_{aminoacylation} = n \\times 2$$\n代入值 $n=1000$：\n$$E_{aminoacylation} = 1000 \\times 2 = 2000$$\n\n延伸的成本 $E_{elongation}$ 与肽键的形成有关。一个长度为 $n$ 个氨基酸的蛋白质包含 $n-1$ 个肽键。对于一个 $1000$ 个氨基酸的蛋白质，这就是 $1000 - 1 = 999$ 个肽键。\n问题指出，每个延伸循环（形成一个肽键）消耗 $2$ 个 GTP 分子。一个 GTP 用于将氨酰-tRNA 递送到核糖体的 A 位，第二个 GTP 用于核糖体沿 mRNA 的移位。每个水解为 GDP 的 GTP 计为 $1$ 个高能磷酸等价物。因此，形成一个肽键的成本是 $2$ 个高能磷酸等价物。\n延伸的总成本为：\n$$E_{elongation} = (n-1) \\times 2$$\n代入值 $n=1000$：\n$$E_{elongation} = (1000 - 1) \\times 2 = 999 \\times 2 = 1998$$\n\n最后，我们将这些单独的成本相加，以求得这一轮基因表达的总能量消耗。\n$$E_{total} = E_{transcription} + E_{aminoacylation} + E_{elongation}$$\n$$E_{total} = 5998 + 2000 + 1998$$\n$$E_{total} = 7998 + 1998 = 9996$$\n\n或者，我们可以从符号表达式构建一个通用公式：\n$$E_{total} = 2(m-1) + 2n + 2(n-1)$$\n$$E_{total} = 2m - 2 + 2n + 2n - 2$$\n$$E_{total} = 2m + 4n - 4$$\n代入给定值 $m=3000$ 和 $n=1000$：\n$$E_{total} = 2(3000) + 4(1000) - 4$$\n$$E_{total} = 6000 + 4000 - 4$$\n$$E_{total} = 10000 - 4 = 9996$$\n两种方法得出相同的结果。消耗的高能磷酸等价物总数为 $9996$。", "answer": "$$\\boxed{9996}$$", "id": "2842316"}, {"introduction": "现代分子生物学已经从被动观察转向主动设计，而中心法则的原理则是基因工程和合成生物学的核心指导。由于密码子的简并性，同一条氨基酸序列可以由无数种不同的mRNA序列编码，这为优化基因表达提供了巨大的设计空间。这项高级实践挑战你解决一个在合成生物学中普遍存在的双目标优化问题：如何选择同义密码子，以同时最大化翻译延伸效率（由tRNA适应指数，即tAI，衡量）并最小化影响翻译起始的mRNA局部折叠能量，从而找到表达效果的最佳平衡点。[@problem_id:2782535]", "problem": "设计并实现一个完整的、可运行的程序。针对一组受分子生物学中心法则启发而设计的固定小型编码问题，该程序通过枚举同义密码子的选择，来识别帕累托最优序列集。这些序列能同时最大化转运核糖核酸（tRNA）适应性指数，并最小化起始密码子附近的信使核糖核酸（mRNA）局部折叠自由能。您的程序必须基于经过充分检验的生物学模型和热力学，从第一性原理计算目标值，并仅返回每个测试用例的目标对的帕累托前沿，而非序列本身。\n\n背景和定义：\n- 中心法则指出，脱氧核糖核酸（DNA）被转录为 RNA，再被翻译为蛋白质。翻译效率既取决于密码子使用情况（影响 tRNA 适应性指数），也取决于起始密码子附近的局部 mRNA 二级结构（影响翻译起始）。\n- 编码序列的 tRNA 适应性指数（tAI）被建模为密码子特异性权重的几何平均数。给定编码序列中出现的每个密码子 $c$ 的权重 $w(c) \\in (0,1]$，以及一个由 $n$ 个密码子组成的编码序列，序列级别的指数为：\n$$ \\mathrm{tAI} = \\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n}. $$\n- 起始密码子附近的局部 mRNA 折叠自由能通过一个非交叉二级结构模型来近似计算，该模型具有最小发夹环长度约束和碱基对特异性能量。评估窗口由给定的 $5^{\\prime}$ 非翻译区（UTR）序列与从起始密码子开始的蛋白质编码序列拼接而成。该窗口的最小自由能（MFE）是在所有允许的非交叉碱基配对中，各配对能量之和的最小值。允许的碱基对及其能量（单位：千卡/摩尔）如下：\n    - 腺嘌呤-胸腺嘧啶（A–T）或胸腺嘧啶-腺嘌呤（T–A）：-2.1\n    - 鸟嘌呤-胞嘧啶（G–C）或胞嘧啶-鸟嘌呤（C–G）：-3.4\n    - 鸟嘌呤-胸腺嘧啶摆动配对（G–T）或胸腺嘧啶-鸟嘌呤（T–G）：-0.9\n一对核苷酸 $(i,j)$（窗口中核苷酸索引从 $1$ 到 $L$），仅当该配对被允许且满足 $j - i - 1 \\ge m$ 时才能形成，其中 $m = 3$ 是最小发夹环长度。对于子串索引 $i \\le j$，最小自由能 $E(i,j)$ 的动态规划递推式为：\n$$\nE(i,j) = \\min\\Big(\nE(i+1,j),\\,\nE(i,j-1),\\,\nE(i+1,j-1) + \\epsilon(x_i,x_j),\\,\n\\min_{k=i}^{j-1} \\big(E(i,k) + E(k+1,j)\\big)\n\\Big),\n$$\n对于 $i \\ge j$，有 $E(i,j)=0$。其中，如果 $(x_i,x_j)$ 是允许的配对，则 $\\epsilon(x_i,x_j)$ 为其配对能量，否则为 $+\\infty$；如果 $j-i-1  m$，则该配对同样不被允许。整个窗口的最小自由能为 $E(1,L)$。\n\n双目标优化：\n- 目标 1：最大化 $\\mathrm{tAI}$。\n- 目标 2：最小化从上述最小自由能模型获得的 $\\Delta G$（千卡/摩尔）。\n- 帕累托支配：如果 $\\mathrm{tAI}_A \\ge \\mathrm{tAI}_B$ 且 $\\Delta G_A \\le \\Delta G_B$，并且至少有一个不等式是严格的，则序列 $A$ 支配序列 $B$。帕累托前沿是未被任何其他序列支配的序列集合。\n\n密码子权重和同义密码子集：\n- 对任何测试用例中可能出现的密码子，使用以下密码子权重 $w(c)$（无量纲）：\n    - 起始密码子：ATG $\\mapsto 0.60$。\n    - 赖氨酸（K）：AAA $\\mapsto 0.20$，AAG $\\mapsto 0.70$。\n    - 天冬酰胺（N）：AAC $\\mapsto 0.65$，AAT $\\mapsto 0.35$。\n    - 丙氨酸（A）：GCT $\\mapsto 0.35$，GCC $\\mapsto 0.80$，GCA $\\mapsto 0.30$，GCG $\\mapsto 0.90$。\n    - 甘氨酸（G）：GGT $\\mapsto 0.40$，GGC $\\mapsto 0.85$，GGA $\\mapsto 0.25$，GGG $\\mapsto 0.30$。\n    - 亮氨酸（L）：TTA $\\mapsto 0.10$，TTG $\\mapsto 0.25$，CTT $\\mapsto 0.30$，CTC $\\mapsto 0.55$，CTA $\\mapsto 0.15$，CTG $\\mapsto 0.95$。\n    - 精氨酸（R）：CGT $\\mapsto 0.45$，CGC $\\mapsto 0.90$，CGA $\\mapsto 0.20$，CGG $\\mapsto 0.35$，AGA $\\mapsto 0.10$，AGG $\\mapsto 0.05$。\n    - 异亮氨酸（I）：ATT $\\mapsto 0.50$，ATC $\\mapsto 0.85$，ATA $\\mapsto 0.10$。\n- 每个氨基酸的同义密码子是上述列出的标准有义密码子。蛋氨酸（M）固定为 ATG。\n\n评估窗口和序列构建：\n- 对每个测试用例，构建编码序列，其由 ATG 和给定氨基酸序列中每个氨基酸的一个密码子依次组成。$5^{\\prime}$ 非翻译区已提供，并在每个测试用例中固定不变。\n- 折叠窗口是完整的 $5^{\\prime}$ 非翻译区与完整的编码序列（测试用例指定的所有密码子）的拼接。使用上述动态规划模型，最小发夹环长度 $m=3$ 及指定的碱基对能量。\n- 计算 $\\mathrm{tAI}$ 时，使用编码序列中所有密码子（包括起始密码子 ATG）的几何平均数。\n\n测试套件：\n为以下三个测试用例提供结果。\n- 用例 1（理想路径，搜索空间小）：\n    - $5^{\\prime}$ UTR: \"AAAGGAGGACCC\"\n    - 氨基酸序列：[\"M\",\"K\",\"N\"]\n- 用例 2（中等搜索空间，含四重简并氨基酸）：\n    - $5^{\\prime}$ UTR: \"CCGAGGAGTAAG\"\n    - 氨基酸序列：[\"M\",\"A\",\"G\"]\n- 用例 3（较大搜索空间和更强的密码子偏好性差异）：\n    - $5^{\\prime}$ UTR: \"TTTGGAGGTTAA\"\n    - 氨基酸序列：[\"M\",\"L\",\"R\",\"I\"]\n\n所需输出和格式：\n- 对每个测试用例，枚举所有与氨基酸序列一致的同义密码子组合，并使用上述支配定义识别目标对 $(\\mathrm{tAI}, \\Delta G)$ 的帕累托前沿。\n- 对每个测试用例，收集非支配的目标对，移除重复的相同对，并按 $\\mathrm{tAI}$ 降序、再按 $\\Delta G$ 升序进行排序。\n- 将 $\\mathrm{tAI}$（无量纲）和 $\\Delta G$（千卡/摩尔）均四舍五入到三位小数。报告 $\\Delta G$ 值时使用浮点数，不带单位；单位已指定为千卡/摩尔。\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果是一个包含双元素列表 $[\\mathrm{tAI}, \\Delta G]$ 的列表。例如，一个有效的输出格式是 \"[[[0.612,-12.3],[...]],[[...]],[[...]]]\"。输出字符串中不得包含任何空格。此问题不涉及角度或其他单位。\n\n约束和假设：\n- 仅使用具有指定最小环路长度 $m=3$ 的非交叉二级结构。\n- 严格按照给定的密码子权重、允许的碱基对及其能量进行计算。\n- 仅使用指定的序列和氨基酸集合。所有序列均使用包含胸腺嘧啶（T）的 DNA 字母表；在本模型中，将 A-T 配对视为 RNA 中腺嘌呤-尿嘧啶配对的近似。\n\n您的任务是将其实现为一个完整的程序，计算所有三个测试用例的帕累托前沿，并按要求的确切格式打印为单行。程序不应读取用户输入，也不应访问任何外部文件。", "solution": "该问题要求设计并实现一种算法，以解决合成生物学中的一个双目标优化问题。目标是找到一组蛋白质编码序列，这些序列在两个相互冲突的目标之间达到最佳权衡：一是最大化翻译效率，通过 tRNA 适应性指数（$\\mathrm{tAI}$）量化；二是最大化翻译起始位点的可及性，通过最小化局部信使 RNA（mRNA）结构的折叠自由能（$\\Delta G$）来量化。这类问题的解不是单一的最优序列，而是一个被称为帕累托前沿的非支配解集。\n\n算法方法分为四个主要阶段：候选序列的组合枚举、对每个候选序列的两个目标函数进行评估、识别帕累托最优集，以及最终格式化结果。\n\n首先，系统地生成所有可能编码序列的搜索空间。对于给定的氨基酸序列，每个氨基酸（除了固定的蛋氨酸起始密码子）都可由一组同义密码子编码。候选序列的总集合是序列中每个氨基酸的同义密码子集的笛卡尔积。对于一个由 $N$ 个氨基酸组成的蛋白质，若第 $i$ 个氨基酸有 $d_i$ 个同义密码子，则需要评估的序列总数为 $\\prod_{i=1}^{N} d_i$。鉴于测试用例中氨基酸序列的长度较小，这种穷举枚举在计算上是可行的。\n\n其次，对每个生成的候选序列评估其两个目标函数。\n\n第一个目标，tRNA 适应性指数（$\\mathrm{tAI}$），模拟了翻译延伸的效率。它被定义为构成编码序列的密码子 $c_i$ 的相对适应性值或权重 $w(c_i)$ 的几何平均数。对于一个由 $n$ 个密码子组成的序列，$\\mathrm{tAI}$ 计算如下：\n$$\n\\mathrm{tAI} = \\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n}\n$$\n其中每个 $w(c_i)$ 是问题陈述中提供的预定义、密码子特异性权重。该指标体现了整体翻译速度受限于序列中每个密码子对应的 tRNA 分子可用性的原理。\n\n第二个目标是局部 mRNA 二级结构的最小自由能（$\\Delta G$）。更低（更负）的 $\\Delta G$ 表示结构更稳定，这可能阻碍核糖体结合和翻译起始。因此，目标是最小化 $\\Delta G$，这对应于寻找不太稳定的结构。$\\Delta G$ 的计算窗口包含 $5'$ 非翻译区（UTR）及随后的整个编码序列。能量是使用基于非交叉二级结构简化热力学模型的动态规划算法确定的。对于从核苷酸 $i$ 到 $j$ 的子序列，其最小自由能 $E(i,j)$ 由以下递推式给出：\n$$\nE(i,j) = \\min\\Big(\nE(i+1,j),\\,\nE(i,j-1),\\,\nE(i+1,j-1) + \\epsilon(x_i,x_j),\\,\n\\min_{k=i}^{j-1} \\big(E(i,k) + E(k+1,j)\\big)\n\\Big)\n$$\n在这里，$E(i+1,j)$ 和 $E(i,j-1)$ 分别代表位置 $i$ 或 $j$ 的核苷酸未配对的情况。项 $E(i+1,j-1) + \\epsilon(x_i,x_j)$ 对应于核苷酸 $x_i$ 和 $x_j$ 形成碱基对的情况，其中 $\\epsilon(x_i,x_j)$ 是该碱基对的能量贡献。仅当形成的发夹环长度至少为 $m=3$（即 $j-i-1 \\ge m$）时，才考虑此项。最后一项 $\\min_{k=i}^{j-1} \\big(E(i,k) + E(k+1,j)\\big)$ 考虑了分叉情况，即 $i..j$ 子序列上的结构由两个独立的、相邻的子结构形成。基本情况是对于任何 $i \\ge j$ 的子序列，$E(i,j) = 0$。通过填充一个二维表可以高效地求解此递推式，确保在计算较大子序列之前，已经计算了较小子序列的值。一个从序列末尾向后迭代起始索引 $i$、并向前迭代结束索引 $j$ 的循环结构保证了这种依赖顺序。对于长度为 $L$ 的序列，最终的 MFE 由 $E(1,L)$ 给出（或在 0-基索引中为 $E(0, L-1)$）。\n\n第三，在为每个候选序列计算出目标对 $(\\mathrm{tAI}, \\Delta G)$ 后，识别帕累托前沿。如果一个序列 $A$ 的目标为 $(\\mathrm{tAI}_A, \\Delta G_A)$，另一个序列 $B$ 的目标为 $(\\mathrm{tAI}_B, \\Delta G_B)$，并且满足 $\\mathrm{tAI}_A \\ge \\mathrm{tAI}_B$ 和 $\\Delta G_A \\le \\Delta G_B$，且至少有一个不等式为严格不等，则称序列 $A$ 支配序列 $B$。帕累托前沿由集合中所有不被任何其他序列支配的序列组成。一种算法会遍历每个候选解，并将其与所有其他解进行比较。只有当一个解没有被其他任何解支配时，才将其加入帕累托前沿。\n\n最后，对每个测试用例得到的非支配目标对集合进行处理以备输出。移除重复的对，并将唯一的对按 $\\mathrm{tAI}$ 降序、然后按 $\\Delta G$ 升序进行排序。两个目标值都四舍五入到三位小数，并将所有测试用例的结果按指定格式编译成一个单一的、无空格的、逗号分隔的字符串。整体实现将这些步骤封装到一个独立的程序中，该程序处理预定义的测试用例并生成所需的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import gmean\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the bi-objective optimization problem for gene design across three test cases.\n    \"\"\"\n    \n    # ------------------- DATA DEFINITIONS -------------------\n    CODON_DATA = {\n        'M': [('ATG', 0.60)],\n        'K': [('AAA', 0.20), ('AAG', 0.70)],\n        'N': [('AAC', 0.65), ('AAT', 0.35)],\n        'A': [('GCT', 0.35), ('GCC', 0.80), ('GCA', 0.30), ('GCG', 0.90)],\n        'G': [('GGT', 0.40), ('GGC', 0.85), ('GGA', 0.25), ('GGG', 0.30)],\n        'L': [\n            ('TTA', 0.10), ('TTG', 0.25), ('CTT', 0.30), \n            ('CTC', 0.55), ('CTA', 0.15), ('CTG', 0.95)\n        ],\n        'R': [\n            ('CGT', 0.45), ('CGC', 0.90), ('CGA', 0.20), \n            ('CGG', 0.35), ('AGA', 0.10), ('AGG', 0.05)\n        ],\n        'I': [('ATT', 0.50), ('ATC', 0.85), ('ATA', 0.10)],\n    }\n\n    ENERGY_PARAMS = {\n        ('A', 'T'): -2.1, ('T', 'A'): -2.1,\n        ('G', 'C'): -3.4, ('C', 'G'): -3.4,\n        ('G', 'T'): -0.9, ('T', 'G'): -0.9,\n    }\n    \n    MIN_LOOP_LENGTH = 3\n\n    TEST_CASES = [\n        {\"utr\": \"AAAGGAGGACCC\", \"aa_seq\": [\"M\", \"K\", \"N\"]},\n        {\"utr\": \"CCGAGGAGTAAG\", \"aa_seq\": [\"M\", \"A\", \"G\"]},\n        {\"utr\": \"TTTGGAGGTTAA\", \"aa_seq\": [\"M\", \"L\", \"R\", \"I\"]},\n    ]\n\n    # ------------------- HELPER FUNCTIONS -------------------\n\n    def calculate_mfe(seq):\n        \"\"\"\n        Calculates the Minimum Free Energy (MFE) for a given RNA sequence\n        using the specified dynamic programming model.\n        \"\"\"\n        L = len(seq)\n        dp = np.zeros((L, L), dtype=float)\n\n        for i in range(L - 1, -1, -1):\n            for j in range(i + 1, L):\n                # Case 1  2: i or j is unpaired\n                unpaired_i = dp[i + 1, j]\n                unpaired_j = dp[i, j - 1]\n\n                # Case 3: i and j form a base pair\n                pair_term = 0.0\n                if j - i - 1 >= MIN_LOOP_LENGTH:\n                    pair = (seq[i], seq[j])\n                    if pair in ENERGY_PARAMS:\n                        pair_term = ENERGY_PARAMS[pair] + dp[i + 1, j - 1]\n                \n                # Case 4: Bifurcation\n                bifurcation_term = 0.0\n                for k in range(i, j):\n                    bifurcation_term = min(bifurcation_term, dp[i, k] + dp[k + 1, j])\n\n                dp[i, j] = min(unpaired_i, unpaired_j, pair_term, bifurcation_term)\n                \n        return dp[0, L - 1]\n\n    def find_pareto_front(points):\n        \"\"\"\n        Identifies the Pareto front from a set of (tAI, dG) points.\n        Objective: maximize tAI, minimize dG.\n        \"\"\"\n        pareto_front = []\n        for i, p1 in enumerate(points):\n            is_dominated = False\n            for j, p2 in enumerate(points):\n                if i == j:\n                    continue\n                # Check if p2 dominates p1\n                if (p2[0] >= p1[0] and p2[1] = p1[1]) and \\\n                   (p2[0] > p1[0] or p2[1]  p1[1]):\n                    is_dominated = True\n                    break\n            if not is_dominated:\n                pareto_front.append(p1)\n        return pareto_front\n\n    # ------------------- MAIN LOGIC -------------------\n\n    all_results = []\n    for case in TEST_CASES:\n        utr = case[\"utr\"]\n        aa_seq = case[\"aa_seq\"]\n        \n        # 1. Generate all candidate sequences and their codon weights\n        codon_options = [CODON_DATA[aa] for aa in aa_seq]\n        candidate_codon_sets = list(itertools.product(*codon_options))\n        \n        evaluated_points = []\n        for codon_set in candidate_codon_sets:\n            coding_seq = \"\".join([c[0] for c in codon_set])\n            weights = [c[1] for c in codon_set]\n            \n            # 2. Evaluate objectives for each candidate\n            full_seq = utr + coding_seq\n            \n            # Objective 1: tAI\n            tai = gmean(weights)\n            \n            # Objective 2: MFE (dG)\n            dg = calculate_mfe(full_seq)\n\n            evaluated_points.append((tai, dg))\n            \n        # 3. Find Pareto front\n        pareto_front = find_pareto_front(evaluated_points)\n        \n        # 4. Process for output: remove duplicates, sort, and round\n        unique_front = sorted(list(set(pareto_front)), key=lambda p: (-p[0], p[1]))\n        \n        rounded_front = [[round(p[0], 3), round(p[1], 3)] for p in unique_front]\n        all_results.append(rounded_front)\n        \n    # 5. Format final output string\n    case_strings = []\n    for case_res in all_results:\n        pair_strings = [f\"[{t},{g}]\" for t, g in case_res]\n        case_strings.append(f\"[{','.join(pair_strings)}]\")\n    \n    final_output = f\"[[{','.join(case_strings)}]]\"\n    print(final_output)\n\nsolve()\n```", "id": "2782535"}]}