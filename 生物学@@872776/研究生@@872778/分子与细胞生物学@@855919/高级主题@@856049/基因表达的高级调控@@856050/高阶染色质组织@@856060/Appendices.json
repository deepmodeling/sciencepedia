{"hands_on_practices": [{"introduction": "高等染色质组织的核心原则之一是基因组的三维折叠将远距离的调控元件（如增强子）带到其靶基因启动子附近，从而调控基因表达。聚合物物理模型为我们理解这种空间接近性提供了定量框架。本练习 [@problem_id:2947750] 将引导你应用分形小球模型中的一个基本标度律，来定量预测当增强子与启动子之间的基因组距离发生变化时，基因表达水平的折叠变化。这个练习旨在强化对“结构（染色质构象）决定功能（基因调控）”这一核心概念的理解。", "problem": "一个基因被一个增强子激活，该增强子通过三维染色质折叠与其启动子接触。在高通量染色体构象捕获 (Hi-C) 技术中，经验观察到的、在分形球状体区域内相距基因组距离 $s$ 的两个基因座之间的接触概率遵循标度律 $P(s)=C\\,s^{-\\alpha}$，其中 $C$ 是一个与 $s$ 无关的常数，$\\alpha$ 是表征该聚合物状态的标度指数。假设在感兴趣的长度尺度范围内，该聚合物处于分形球状体区域，其标度指数为 $\\alpha=1$。转录激活水平 $E(s)$ 与一个协同的接触依赖项成正比，即 $E(s)\\propto \\left[P(s)\\right]^{n}$，其中 $n$ 是一个捕获多价或协同激活需求的希尔系数。\n\n一个增强子从基因组分离距离 $s_{1}=50\\,\\text{kb}$ 处被重新定位到 $s_{2}=500\\,\\text{kb}$ 处。仅使用所述的标度律和比例关系，推导表达的倍数变化，其定义为无量纲比率 $F=\\dfrac{E(s_{2})}{E(s_{1})}$，并将其表示为以 $n$ 为变量的闭式解析表达式。将最终答案以一个无单位的简化表达式形式报告。", "solution": "首先将对该问题进行严格验证，以确定其科学和逻辑上的完整性。\n\n问题陈述中给出的已知条件如下：\n$1$. 相距基因组距离 $s$ 的两个基因座之间的接触概率由标度律 $P(s)=C\\,s^{-\\alpha}$ 给出。\n$2$. 系统处于分形球状体区域，其标度指数被指定为 $\\alpha=1$。\n$3$. 转录激活水平 $E(s)$ 与一个包含接触概率的协同项成正比：$E(s)\\propto \\left[P(s)\\right]^{n}$，其中 $n$ 是一个希尔系数。\n$4$. 一个增强子从初始基因组分离距离 $s_{1}=50\\,\\text{kb}$ 移动到最终分离距离 $s_{2}=500\\,\\text{kb}$。\n$5$. 目标是推导表达的倍数变化，定义为比率 $F=\\dfrac{E(s_{2})}{E(s_{1})}$。\n\n现在，我们评估该问题的有效性。所呈现的模型是分子生物学和聚合物物理学中用于描述染色质组织的一个标准且简化的表示。标度律 $P(s) \\propto s^{-1}$ 是分形球状体的特征标志，这是一种无纽结的聚合物构象，允许紧密堆积同时保持可及性，这与特定长度尺度内染色质组织的实验观察结果一致。使用类希尔方程来模拟协同生物激活是系统生物学中一种常见且被接受的方法。给定的参数和值 ($s_{1}=50\\,\\text{kb}$，$s_{2}=500\\,\\text{kb}$) 对于增强子-启动子距离是物理上现实的。该问题是自洽的、有科学依据的且适定的，没有内部矛盾或模糊之处。因此，该问题被认为是有效的，并将推导其解。\n\n转录激活水平 $E(s)$ 与 $[P(s)]^n$ 成正比。通过引入一个比例常数（我们称之为 $k_{E}$），可以将其表示为一个方程：\n$$E(s) = k_{E} [P(s)]^n$$\n接触概率 $P(s)$ 由标度律给出：\n$$P(s) = C s^{-\\alpha}$$\n问题指出，在感兴趣的分形球状体区域，标度指数为 $\\alpha = 1$。代入此值，接触概率变为：\n$$P(s) = C s^{-1}$$\n现在，我们将 $P(s)$ 的这个表达式代入激活水平 $E(s)$ 的方程中：\n$$E(s) = k_{E} [C s^{-1}]^n = k_{E} C^n s^{-n}$$\n$E(s)$ 的表达式表明，激活水平随基因组距离按 $s^{-n}$ 的关系进行标度。\n\n我们需要求出倍数变化 $F$，其定义为在新位置 $s_{2}$ 的表达水平与在原位置 $s_{1}$ 的表达水平之比：\n$$F = \\frac{E(s_{2})}{E(s_{1})}$$\n使用推导出的 $E(s)$ 表达式，我们可以写出 $E(s_{1})$ 和 $E(s_{2})$ 的项：\n$$E(s_{1}) = k_{E} C^n s_{1}^{-n}$$\n$$E(s_{2}) = k_{E} C^n s_{2}^{-n}$$\n现在，我们构建比率 $F$：\n$$F = \\frac{k_{E} C^n s_{2}^{-n}}{k_{E} C^n s_{1}^{-n}}$$\n常数 $k_{E}$ 和 $C^n$ 与 $s$ 无关，因此在分子和分母中被约去：\n$$F = \\frac{s_{2}^{-n}}{s_{1}^{-n}}$$\n使用指数的性质，这可以被重写为：\n$$F = \\left(\\frac{s_{2}}{s_{1}}\\right)^{-n} = \\left(\\frac{s_{1}}{s_{2}}\\right)^{n}$$\n问题提供了基因组分离距离的具体数值：$s_{1} = 50\\,\\text{kb}$ 和 $s_{2} = 500\\,\\text{kb}$。我们将这些值代入 $F$ 的表达式中。单位千碱基（$\\text{kb}$）在分子和分母中是相同的，将会被约去：\n$$\\frac{s_{1}}{s_{2}} = \\frac{50\\,\\text{kb}}{500\\,\\text{kb}} = \\frac{50}{500} = \\frac{1}{10}$$\n将此比率代回 $F$ 的方程中：\n$$F = \\left(\\frac{1}{10}\\right)^{n}$$\n这就是以希尔系数 $n$ 表示的倍数变化的闭式解析表达式。一个更紧凑的表示是：\n$$F = 10^{-n}$$\n这个结果表明，对于一个遵循这些标度律的系统，将一个增强子移动到距离其靶启动子远10倍的位置，会导致基因表达量下降 $10^n$ 倍。", "answer": "$$\\boxed{10^{-n}}$$", "id": "2947750"}, {"introduction": "经典的环挤压模型为拓扑关联结构域（TAD）的形成提供了强大的机制解释。在该模型中，cohesin复合体沿着染色质挤压出环，直到被CTCF等边界元件阻挡。这个过程定义了基因组中的绝缘邻域，对维持正常的基因调控至关重要。本实践 [@problem_id:2947808] 要求你亲手编写一个程序，从基本原理出发，构建一个简化的计算模型，以模拟边界元件的缺失如何导致异位增强子-启动子接触并改变基因活性。通过这个练习，你将深入理解环挤压模型的内在逻辑以及边界在基因组功能中的关键作用。", "problem": "实现一个简化的、基于第一性原理的环挤出预测模型，用于预测边界元件删除后的增强子-启动子通讯。目标是使用一个基于高分子物理学和屏障渗透性的接触重加权框架，计算由边界删除所导致的异位增强子-启动子接触引起的启动子活性预测倍数变化。程序必须为每个指定的测试用例计算一个无量纲的启动子活性倍数变化，该变化定义为删除后活性与删除前活性的比率，并在单行中报告所有结果。\n\n模型规范：\n1. 基线基因组接触权重：对于位于位置 $x_i$ 和 $x_j$（单位：碱基对）的两个基因座，定义基因组距离 $d = |x_i - x_j|$。基线接触权重为\n$$\nW(d) = \\frac{1}{1 + \\left(\\frac{d}{\\lambda}\\right)^{\\alpha}},\n$$\n其中 $\\lambda$ 是一个长度尺度（单位：碱基对），$\\alpha$ 是一个高分子标度指数。\n\n2. 作为独立穿越事件的边界衰减：假设有一组边界元件，由 $k$ 索引，其基因组位置为 $b_k$（单位：碱基对），渗透性为 $s_k \\in [0,1]$。对于一对位于 $x_i$ 和 $x_j$ 的基因座，定义衰减因子\n$$\nA(x_i, x_j; \\{(b_k, s_k)\\}) = \\prod_{k: \\min(x_i,x_j) < b_k < \\max(x_i,x_j)} s_k,\n$$\n即，严格位于两个基因座之间的所有边界的渗透性的乘积。在删除后状态下，通过将指定删除集 $D$ 中所有索引 $k$ 的 $s_k$ 设置为1来模拟边界删除，而在删除前状态下保持 $s_k$ 不变。\n\n3. 通过增强子接触重加权计算启动子活性：设一个启动子位于位置 $p$（单位：碱基对），增强子是一个由数对 $(e_m, w_m)$ 组成的列表，其中 $e_m$ 是增强子位置（单位：碱基对），$w_m$ 是一个非负的增强子权重（无量纲）。预测的启动子活性为\n$$\nS = \\sum_{m} w_m \\, W(|e_m - p|) \\, A(e_m, p; \\{(b_k, s_k)\\}).\n$$\n\n4. 启动子活性的倍数变化：设 $S_{\\mathrm{before}}$ 是使用删除前渗透性计算的启动子活性，而 $S_{\\mathrm{after}}$ 是在为所有 $k \\in D$ 设置 $s_k = 1$ 后计算的启动子活性。每个测试用例所需的输出是无量纲的倍数变化\n$$\nF = \\frac{S_{\\mathrm{after}}}{S_{\\mathrm{before}}}.\n$$\n\n常量：\n- 使用高分子标度指数 $\\alpha = 1.5$。\n- 使用长度尺度 $\\lambda = 20000$ 碱基对。\n\n单位与数值要求：\n- 所有基因组位置和 $\\lambda$ 的单位均为碱基对。\n- 增强子权重 $w_m$ 是无量纲的。\n- 倍数变化 $F$ 是无量纲的，必须以浮点小数形式报告。\n- 此问题中不涉及角度。\n- 不要用百分号表示任何结果。\n\n程序中每个测试用例的输入规范（不提供外部输入；程序必须嵌入测试套件）：\n- 一个区域长度 $L$（单位：碱基对），模型不直接使用，但为完整性而提供。\n- 一个启动子位置 $p$（单位：碱基对）。\n- 一个增强子列表 $[(e_m, w_m)]$，其中 $e_m$ 的单位是碱基对，$w_m$ 是无量纲的。\n- 一个边界列表 $[(b_k, s_k)]$，其中 $b_k$ 的单位是碱基对，$s_k \\in [0,1]$ 是无量纲的渗透性。\n- 一个删除集 $D$，包含边界列表中在删除后状态下被删除的元素的索引（从零开始）。\n\n要实现的测试套件：\n- 通用参数：$\\alpha = 1.5$，$\\lambda = 20000$ 碱基对。\n\n- 测试用例 1 (异位接触去屏蔽的正常路径)：\n  - $L = 200000$ 碱基对\n  - $p = 120000$ 碱基对\n  - 增强子：$[(80000, 1.0), (150000, 0.6)]$\n  - 边界：$[(100000, 0.1), (130000, 0.05)]$\n  - 删除的：$[1]$\n\n- 测试用例 2 (强边界移除暴露远端增强子)：\n  - $L = 200000$ 碱基对\n  - $p = 50000$ 碱基对\n  - 增强子：$[(10000, 0.5), (90000, 1.2)]$\n  - 边界：$[(70000, 0.02), (40000, 0.2)]$\n  - 删除的：$[0]$\n\n- 测试用例 3 (无边界；删除无效果)：\n  - $L = 100000$ 碱基对\n  - $p = 50000$ 碱基对\n  - 增强子：$[(20000, 1.0), (80000, 1.0)]$\n  - 边界：$[]$\n  - 删除的：$[]$\n\n- 测试用例 4 (通过删除解除完全绝缘；确保来自近端增强子的非零基线活性)：\n  - $L = 150000$ 碱基对\n  - $p = 60000$ 碱基对\n  - 增强子：$[(58000, 0.3), (110000, 1.0)]$\n  - 边界：$[(80000, 0.0)]$\n  - 删除的：$[0]$\n\n程序输出格式：\n- 使用上述定义为每个测试用例计算倍数变化 $F$。\n- 生成单行输出，其中包含结果，形式为逗号分隔的浮点数列表，四舍五入到六位小数，并用方括号括起来，例如 $[f_1,f_2,f_3,f_4]$，其中每个 $f_i$ 对应于测试用例 $i$ 的倍数变化。", "solution": "该问题要求实现一个计算模型，以预测基因组边界元件删除后启动子活性的变化。该模型基于高分子物理学的第一性原理，具体来说是一个环挤出框架，其中增强子根据其空间邻近性影响启动子的活性，而这种邻近性又受到距离和中间边界元件的调控。目标是计算启动子活性的倍数变化，定义为边界删除后其活性与删除前其活性的比率。\n\n解决方案是通过系统地应用所提供的数学定义来构建的。让我们首先将模型的各个组成部分形式化。\n\n$1$. 基线接触权重：位于位置 $x_i$ 和 $x_j$、基因组距离为 $d = |x_i - x_j|$ 的两个基因组基因座之间的固有接触概率由函数 $W(d)$ 给出。该函数表示在染色质的高分子模型中，接触频率随距离的衰减。其定义为：\n$$\nW(d) = \\frac{1}{1 + \\left(\\frac{d}{\\lambda}\\right)^{\\alpha}}\n$$\n在这里，$\\lambda$ 是一个特征长度尺度，设置为 $20000$ 碱基对，$\\alpha$ 是一个高分子标度指数，设置为 $1.5$。这些常数决定了接触衰减曲线的形状。\n\n$2$. 边界衰减因子：边界元件，例如由 CTCF 蛋白结合的那些，被建模为阻碍环挤出过程的概率性屏障。位于一对基因座 $(x_i, x_j)$ 之间的边界的集体效应由衰减因子 $A$ 量化。它是所有位置为 $b_k$ 且严格位于 $x_i$ 和 $x_j$ 之间的边界 $k$ 的渗透性 $s_k \\in [0, 1]$ 的乘积。渗透性 $s_k=0$ 代表完全屏障，而 $s_k=1$ 代表完全可渗透的元件（无屏障效应）。\n$$\nA(x_i, x_j; \\{(b_k, s_k)\\}) = \\prod_{k: \\min(x_i, x_j) < b_k < \\max(x_i, x_j)} s_k\n$$\n如果在 $x_i$ 和 $x_j$ 之间没有边界，则会出现空积，其定义为 $1$。边界的删除通过将其渗透性 $s_k$ 设置为 $1$ 来建模。\n\n$3$. 总启动子活性：位于位置 $p$ 的启动子的活性由一组增强子的累积影响决定。每个位于位置 $e_m$、具有内在强度 $w_m$ 的增强子 $m$ 都对启动子的活性有贡献。此贡献是增强子强度 $w_m$、基线接触权重 $W(|e_m - p|)$ 和特定增强子-启动子对的衰减因子 $A(e_m, p)$ 的乘积。总启动子活性 $S$ 是对所有增强子的这些贡献的总和：\n$$\nS = \\sum_{m} w_m \\, W(|e_m - p|) \\, A(e_m, p; \\{(b_k, s_k)\\})\n$$\n\n$4$. 倍数变化计算：要计算的主要量是倍数变化 $F$。这个无量纲比率量化了删除特定边界集 $D$ 的影响。设 $S_{\\mathrm{before}}$ 是使用原始边界渗透性集计算的启动子活性。设 $S_{\\mathrm{after}}$ 是在修改渗透性后计算的活性，使得对于每个边界索引 $k \\in D$，渗透性 $s_k$ 都设置为 1。那么，倍数变化 $F$ 为：\n$$\nF = \\frac{S_{\\mathrm{after}}}{S_{\\mathrm{before}}}\n$$\n$F > 1$ 的值表示删除导致了启动子活性的增加，这通常是由于形成了新的或“异位”的、先前被阻断的增强子-启动子接触。$F = 1$ 的值表示没有变化。\n\n每个测试用例的计算过程如下：\n首先，我们定义一个函数，使用常量 $\\alpha=1.5$ 和 $\\lambda=20000$，为给定的启动子、增强子列表和边界列表计算总启动子活性 $S$。该函数遍历每个增强子，计算依赖于距离的权重 $W(d)$ 和边界衰减 $A$，计算该增强子的贡献，并将这些贡献求和。\n\n其次，对于每个测试用例，我们通过使用初始提供的边界列表调用此活性计算函数来计算 $S_{\\mathrm{before}}$。\n\n第三，我们为删除后状态构建一个新的边界列表。这是原始列表的副本，其中在指定的删除集 $D$ 中的每个索引为 $k$ 的边界的渗透性 $s_k$ 被替换为 1.0。\n\n第四，我们通过使用这个新的、修改过的边界列表调用活性计算函数来计算 $S_{\\mathrm{after}}$。\n\n最后，我们计算比率 $F = S_{\\mathrm{after}} / S_{\\mathrm{before}}$ 以获得所需的倍数变化。对所有指定的测试用例重复此过程。对于不存在边界的情况，$S_{\\mathrm{after}}$ 将等于 $S_{\\mathrm{before}}$，从而正确地得出 1.0 的倍数变化。对于 $S_{\\mathrm{before}}$ 为零的情况，已通过问题设计来处理，该设计确保了至少一个未被完全绝缘边界与启动子隔开的近端增强子提供非零的基线活性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of predicting enhancer-promoter communication changes\n    upon boundary deletion using a simplified loop-extrusion model.\n    \"\"\"\n\n    # Model constants\n    ALPHA = 1.5\n    LAMBDA = 20000.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path with ectopic contact unmasking)\n        {\n            \"L\": 200000,\n            \"p\": 120000,\n            \"enhancers\": [(80000, 1.0), (150000, 0.6)],\n            \"boundaries\": [(100000, 0.1), (130000, 0.05)],\n            \"deleted\": [1],\n        },\n        # Test case 2 (strong boundary removal exposing a distal enhancer)\n        {\n            \"L\": 200000,\n            \"p\": 50000,\n            \"enhancers\": [(10000, 0.5), (90000, 1.2)],\n            \"boundaries\": [(70000, 0.02), (40000, 0.2)],\n            \"deleted\": [0],\n        },\n        # Test case 3 (no boundaries; deletion has no effect)\n        {\n            \"L\": 100000,\n            \"p\": 50000,\n            \"enhancers\": [(20000, 1.0), (80000, 1.0)],\n            \"boundaries\": [],\n            \"deleted\": [],\n        },\n        # Test case 4 (complete insulation lifted by deletion)\n        {\n            \"L\": 150000,\n            \"p\": 60000,\n            \"enhancers\": [(58000, 0.3), (110000, 1.0)],\n            \"boundaries\": [(80000, 0.0)],\n            \"deleted\": [0],\n        },\n    ]\n\n    def baseline_contact_weight(d, lam, alpha):\n        \"\"\"Calculates W(d), the baseline contact weight.\"\"\"\n        return 1.0 / (1.0 + (d / lam) ** alpha)\n\n    def compute_activity(p_pos, enhancers, boundaries, lam, alpha):\n        \"\"\"\n        Computes the total promoter activity S based on enhancer contacts,\n        modulated by distance and boundary elements.\n        \"\"\"\n        total_activity = 0.0\n        for e_pos, e_weight in enhancers:\n            # 1. Calculate genomic distance and baseline contact weight\n            d = abs(e_pos - p_pos)\n            w_d = baseline_contact_weight(d, lam, alpha)\n\n            # 2. Calculate boundary attenuation factor\n            attenuation = 1.0\n            locus_min = min(p_pos, e_pos)\n            locus_max = max(p_pos, e_pos)\n            for b_pos, b_perm in boundaries:\n                if locus_min  b_pos  locus_max:\n                    attenuation *= b_perm\n            \n            # 3. Sum up the contribution for this enhancer\n            total_activity += e_weight * w_d * attenuation\n            \n        return total_activity\n\n    results = []\n    for case in test_cases:\n        p_pos = case[\"p\"]\n        enhancers = case[\"enhancers\"]\n        boundaries_before = case[\"boundaries\"]\n        deleted_indices = case[\"deleted\"]\n\n        # Calculate pre-deletion promoter activity\n        s_before = compute_activity(p_pos, enhancers, boundaries_before, LAMBDA, ALPHA)\n\n        # Create the post-deletion boundary list by setting permeabilities to 1.0\n        boundaries_after = [list(b) for b in boundaries_before]\n        for idx in deleted_indices:\n            if 0 = idx  len(boundaries_after):\n                boundaries_after[idx][1] = 1.0\n\n        # Calculate post-deletion promoter activity\n        s_after = compute_activity(p_pos, enhancers, boundaries_after, LAMBDA, ALPHA)\n\n        # Calculate fold-change, handling potential division by zero\n        if s_before == 0.0:\n            # If S_before is 0 and S_after is also 0, change is 1-fold.\n            # If S_before is 0 and S_after > 0, change is infinite.\n            # The problem context implies S_before will be non-zero.\n            fold_change = float('inf') if s_after > 0 else 1.0\n        else:\n            fold_change = s_after / s_before\n        \n        results.append(fold_change)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2947808"}, {"introduction": "建立生物学模型来预测染色质结构（如CTCF介导的环）是一项核心任务，但同样重要的是要能够严格地评估这些模型的预测能力。我们通常使用ChIP-seq信号强度和CTCF基序方向等特征来预测环的位置，然后与Hi-C等实验得出的“金标准”进行比较。本实践 [@problem_id:2947804] 让你扮演计算生物学家的角色，通过编写代码来实现一个精确率-召回率（Precision-Recall）评估框架。你将使用该框架来量化比较两种不同 loop 预测模型的性能，从而深刻理解模型评估在验证生物学假设中的重要性。", "problem": "你有一项简化的评估任务，该任务基于高阶染色质组织：利用染色质免疫沉淀测序 (ChIP-seq) 的峰值强度和CTCF基序方向来预测CCCTC结合因子 (CTCF) 介导的环，并根据高通量染色体构象捕获 (Hi-C) 中观察到的环来评估预测结果。目标是构建一个精确率-召回率评估体系，并以一种数学上严谨、可普遍实现的方式来量化模型性能。\n\n请使用以下基于经过充分检验的生物学观察和数学定义的基础：\n- 在Hi-C中观察到的环锚定点处，具有收敛基序方向的CTCF结合位点显著富集。\n- 精确率定义为 $ \\mathrm{Precision} = \\dfrac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}} $，召回率定义为 $ \\mathrm{Recall} = \\dfrac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}} $，其中 $ \\mathrm{TP} $ 表示真阳性，$ \\mathrm{FP} $ 表示假阳性，$ \\mathrm{FN} $ 表示假阴性。\n- 精确率-召回率 (PR) 曲线是通过改变标量预测分数的决策阈值，并在每个阈值下重新计算精确率和召回率而生成的。\n- 平均精确率 (AP) 是通过对召回率增量进行右黎曼和计算得出的：如果 $ (\\mathrm{R}_i, \\mathrm{P}_i) $ 是在按分数阈值降序排列的单调递增的召回率水平上的召回率和精确率值，则\n$$\n\\mathrm{AP} \\;=\\; \\sum_{i=1}^{m} \\left( \\mathrm{R}_i - \\mathrm{R}_{i-1} \\right)\\, \\mathrm{P}_i \\quad \\text{with} \\quad \\mathrm{R}_0 = 0,\n$$\n该公式在不进行插值的情况下对阶梯状PR曲线进行积分。\n- 在给定阈值下的F1分数定义为 $ \\mathrm{F1} = \\dfrac{2 \\,\\mathrm{Precision}\\,\\mathrm{Recall}}{\\mathrm{Precision} + \\mathrm{Recall}} $（当 $ \\mathrm{Precision} + \\mathrm{Recall}  0 $ 时），否则为 $ 0 $。\n\n你必须评估两个用于候选环的预测模型。每个候选环由同一条染色体上的一个左侧CTCF位点和一个右侧CTCF位点组成，其中左侧位点的基因组坐标小于右侧位点。对于每个候选环，你会获得以下信息：\n- 左侧和右侧ChIP-seq峰值强度，单位任意，表示为 $ I_L $ 和 $ I_R $（非负实数）。\n- 左侧位点和右侧位点的基序方向，每个均属于集合 $ \\{+, -\\} $。此处，$ + $ 表示基序指向基因组坐标增加的方向，$ - $ 表示基序指向基因组坐标减少的方向。\n- 一个二元基准真相标签 $ y \\in \\{0, 1\\} $，指示该配对是否为在Hi-C中观察到的真环（$ y = 1 $）或不是（$ y = 0 $）。\n\n按如下方式定义两个模型：\n- 模型A（仅强度）：分数 $ s = I_L \\times I_R $。\n- 模型B（方向感知）：如果基序对是收敛的（左侧方向为 $ + $ 且右侧方向为 $ - $），则定义 $ o = 1 $，否则 $ o = 0 $；分数为 $ s' = o \\times (I_L \\times I_R) $。\n\n对于给定的模型和阈值 $ \\tau $，如果候选环的模型分数大于或等于 $ \\tau $，则预测 $ \\hat{y} = 1 $，否则预测 $ \\hat{y} = 0 $。通过在候选集所产生的所有不同分数阈值上进行评估来构建PR曲线。计算：\n- 如上定义的 $ \\mathrm{AP} $。\n- 所有阈值中的 $ \\max\\{\\mathrm{F1}\\} $。\n\n边界情况必须按如下方式处理：\n- 如果阳性样本数 $ N_{\\mathrm{pos}} = \\sum y $ 为 $ 0 $，则设 $ \\mathrm{AP} = 0 $ 且 $ \\max\\{\\mathrm{F1}\\} = 0 $。\n- 如果在某个阈值下 $ \\mathrm{TP} + \\mathrm{FP} = 0 $，则定义该阈值处的 $ \\mathrm{Precision} = 0 $。\n\n你的任务是实现一个程序，为以下每个测试用例计算两个模型的 $ \\mathrm{AP} $ 和 $ \\max\\{\\mathrm{F1}\\} $。所有数值输出必须四舍五入到小数点后 $ 4 $ 位。\n\n测试套件（每个条目是一个元组 $ (I_L, I_R, \\text{left\\_orientation}, \\text{right\\_orientation}, y) $）：\n\n- 用例 1（混合阳性和阴性样本；同时存在收敛和非收敛类型）：\n  - $ (120, 100, '+', '-', 1) $\n  - $ (80, 90, '+', '-', 1) $\n  - $ (30, 40, '+', '-', 0) $\n  - $ (200, 50, '-', '+', 0) $\n  - $ (75, 65, '+', '+', 0) $\n  - $ (150, 160, '+', '-', 1) $\n  - $ (20, 15, '-', '+', 0) $\n  - $ (95, 110, '+', '-', 1) $\n  - $ (60, 55, '-', '-', 0) $\n  - $ (130, 20, '+', '-', 0) $\n  - $ (10, 200, '+', '-', 0) $\n  - $ (180, 170, '+', '-', 1) $\n\n- 用例 2（无阳性样本）：\n  - $ (50, 50, '+', '-', 0) $\n  - $ (30, 30, '+', '-', 0) $\n  - $ (80, 20, '-', '+', 0) $\n  - $ (10, 100, '+', '-', 0) $\n  - $ (5, 5, '-', '-', 0) $\n\n- 用例 3（预期方向感知模型会有显著帮助）：\n  - $ (70, 65, '+', '-', 1) $\n  - $ (90, 85, '+', '-', 1) $\n  - $ (50, 60, '+', '-', 1) $\n  - $ (300, 300, '-', '+', 0) $\n  - $ (250, 200, '-', '+', 0) $\n  - $ (200, 210, '+', '+', 0) $\n  - $ (180, 190, '-', '-', 0) $\n  - $ (95, 30, '+', '-', 0) $\n\n程序要求：\n- 严格按照规定实现评分规则和评估流程。\n- 对于每个用例，计算并返回四个数字：模型A的 $ \\mathrm{AP} $、模型B的 $ \\mathrm{AP} $、模型A的 $ \\max\\{\\mathrm{F1}\\} $，以及模型B的 $ \\max\\{\\mathrm{F1}\\} $；每个数字都四舍五入到小数点后 $ 4 $ 位。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按用例 $ 1 $、$ 2 $ 和 $ 3 $ 的顺序排列如下：\n  - $ [ \\mathrm{AP}_A^{(1)}, \\mathrm{AP}_B^{(1)}, \\max\\{\\mathrm{F1}\\}_A^{(1)}, \\max\\{\\mathrm{F1}\\}_B^{(1)}, \\mathrm{AP}_A^{(2)}, \\mathrm{AP}_B^{(2)}, \\max\\{\\mathrm{F1}\\}_A^{(2)}, \\max\\{\\mathrm{F1}\\}_B^{(2)}, \\mathrm{AP}_A^{(3)}, \\mathrm{AP}_B^{(3)}, \\max\\{\\mathrm{F1}\\}_A^{(3)}, \\max\\{\\mathrm{F1}\\}_B^{(3)} ] $.\n\n不涉及物理单位或角度。所有最终数值输出必须是四舍五入到小数点后 $ 4 $ 位的小数。程序必须是自包含的，并且不需要用户输入。", "solution": "该问题要求实现并评估两种用于预测由CCCTC结合因子（CTCF）介导的染色质环的计算模型。评估必须使用精确率-召回率框架进行，最终计算出每个模型在多个测试用例中的平均精确率（$AP$）和最大F1分数（$\\max\\{F1\\}$）。\n\n该问题在科学上根植于3D基因组组织的原理。已有研究证实，染色质中的远程相互作用（即环）通常由CTCF结合位点锚定。控制此过程的一个关键特征是这些结合位点内CTCF基序的方向。所谓的“收敛规则”假定，环主要在CTCF基序相互朝向的位点之间形成。所提供的模型捕捉了一个基本的科学假设：模型A仅依赖于CTCF结合的强度（由ChIP-seq强度 $I_L$ 和 $I_R$ 作为代理），而模型B则整合了收敛规则，以检验这一额外的生物学信息是否能提高预测准确性。\n\n评估指标是机器学习和生物信息学中的标准指标。精确率 $\\mathrm{Precision} = \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$ 衡量阳性预测的准确性，而召回率 $\\mathrm{Recall} = \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}$ 衡量模型识别所有真阳性实例的能力。在这里，$\\mathrm{TP}$、$\\mathrm{FP}$ 和 $\\mathrm{FN}$ 分别代表真阳性、假阳性和假阴性。精确率-召回率（PR）曲线展示了在一系列分数阈值下这两个指标之间的权衡。\n\n平均精确率（$AP$）为PR曲线提供了一个单值摘要。指定的公式，\n$$\n\\mathrm{AP} = \\sum_{i=1}^{m} \\left( \\mathrm{R}_i - \\mathrm{R}_{i-1} \\right)\\, \\mathrm{P}_i \\quad \\text{with} \\quad \\mathrm{R}_0 = 0,\n$$\n将 $AP$ 定义为非插值、阶梯状PR曲线下的面积，通过对召回率增量进行右黎曼和计算得出。点 $(\\mathrm{R}_i, \\mathrm{P}_i)$ 对应于递减分数阈值下的精确率和召回率值。\n\nF1分数 $ \\mathrm{F1} = \\frac{2 \\cdot \\mathrm{Precision} \\cdot \\mathrm{Recall}}{\\mathrm{Precision} + \\mathrm{Recall}} $ 是精确率和召回率的调和平均数。最大F1分数 $\\max\\{\\mathrm{F1}\\}$ 确定了平衡精确率和召回率的最佳阈值。\n\n解决此问题的算法方法如下：\n\n1.  **模型评分**：对于给定测试用例中的每个候选环，计算两个模型的分数。\n    -   模型A分数：$s = I_L \\times I_R$。此分数与两个锚定位点的ChIP-seq峰值强度的乘积成正比。\n    -   模型B分数：$s' = o \\times (I_L \\times I_R)$。此处，如果左侧基序方向为“+”（正向）且右侧为“-”（反向），形成收敛对，则方向因子 $o$ 为 $1$。否则，$o=0$。该模型将所有非收敛对的分数置为零，直接实现了收敛规则。\n\n2.  **指标计算**：对于每个模型，使用专用函数计算 $AP$ 和 $\\max\\{\\mathrm{F1}\\}$。\n    -   **输入**：一个分数列表和对应的二元基准真相标签列表（$y \\in \\{0, 1\\}$）。\n    -   **边界情况**：第一步是检查阳性实例总数 $N_{\\mathrm{pos}} = \\sum y_i$ 是否为零。如果是，则 $AP$ 和 $\\max\\{\\mathrm{F1}\\}$ 均定义为 $0$，计算终止。\n    -   **排序**：通过按分数降序对候选环进行排序。为处理分数相同的情况，使用稳定排序，其中分数相同的项再按其标签降序排列（真阳性，$y=1$，排在假阴性，$y=0$，之前）。这个标准流程创建了一个明确的排名。这可以通过对元组 `(score, label)` 进行排序来实现。\n    -   **迭代评估**：算法遍历已排序的候选列表。在每个排名 $k$ 处：根据第k个候选者的标签更新真阳性（$\\mathrm{TP}$）和假阳性（$\\mathrm{FP}$）的计数。计算精确率和召回率：$\\mathrm{P}_k = \\mathrm{TP} / (\\mathrm{TP} + \\mathrm{FP})$ 和 $\\mathrm{R}_k = \\mathrm{TP} / N_{\\mathrm{pos}}$。问题规定如果 $\\mathrm{TP}+\\mathrm{FP}=0$，则 $\\mathrm{P}=0$。计算F1分数，并更新运行中的最大值 $\\max\\{\\mathrm{F1}\\}$。根据黎曼和定义更新 $AP$。只有当遇到真阳性时（这会导致召回率增加），才向 $AP$ 添加增量。增加的面积是 $\\mathrm{P}_k \\times (\\mathrm{R}_k - \\mathrm{R}_{\\text{prev}})$，其中 $\\mathrm{R}_{\\text{prev}}$ 是处理当前真阳性之前的召回率值。\n\n3.  **最终输出**：对每个测试用例的每个模型执行此过程。收集每个用例产生的四个值（$AP_A, AP_B, \\max\\{F1\\}_A, \\max\\{F1\\}_B$）。最终输出是一个包含所有用例的这些值的单行逗号分隔列表，每个数值都格式化为小数点后4位。这个全面的过程为这两个生物学模型提供了一个严谨且可复现的评估。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the chromatin loop prediction evaluation problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        [\n            (120, 100, '+', '-', 1), (80, 90, '+', '-', 1), (30, 40, '+', '-', 0),\n            (200, 50, '-', '+', 0), (75, 65, '+', '+', 0), (150, 160, '+', '-', 1),\n            (20, 15, '-', '+', 0), (95, 110, '+', '-', 1), (60, 55, '-', '-', 0),\n            (130, 20, '+', '-', 0), (10, 200, '+', '-', 0), (180, 170, '+', '-', 1)\n        ],\n        # Case 2\n        [\n            (50, 50, '+', '-', 0), (30, 30, '+', '-', 0), (80, 20, '-', '+', 0),\n            (10, 100, '+', '-', 0), (5, 5, '-', '-', 0)\n        ],\n        # Case 3\n        [\n            (70, 65, '+', '-', 1), (90, 85, '+', '-', 1), (50, 60, '+', '-', 1),\n            (300, 300, '-', '+', 0), (250, 200, '-', '+', 0),\n            (200, 210, '+', '+', 0), (180, 190, '-', '-', 0), (95, 30, '+', '-', 0)\n        ]\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # Unpack data for the current case\n        candidates = np.array(case_data, dtype=object)\n        intensities_L = candidates[:, 0].astype(float)\n        intensities_R = candidates[:, 1].astype(float)\n        orientations_L = candidates[:, 2]\n        orientations_R = candidates[:, 3]\n        labels = candidates[:, 4].astype(int)\n\n        # Model A scoring\n        scores_A = intensities_L * intensities_R\n\n        # Model B scoring\n        is_convergent = (orientations_L == '+')  (orientations_R == '-')\n        scores_B = is_convergent.astype(int) * (intensities_L * intensities_R)\n\n        # Evaluate Model A\n        ap_A, max_f1_A = compute_metrics(scores_A, labels)\n        \n        # Evaluate Model B\n        ap_B, max_f1_B = compute_metrics(scores_B, labels)\n\n        # Append results in specified order\n        results.extend([ap_A, ap_B, max_f1_A, max_f1_B])\n\n    # Format the final output string\n    formatted_results = [\"{:.4f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_metrics(scores, labels):\n    \"\"\"\n    Computes Average Precision (AP) and max F1-score.\n    \"\"\"\n    n_pos = np.sum(labels)\n    if n_pos == 0:\n        return 0.0, 0.0\n\n    # Combine scores and labels, then sort\n    # Sort by score (desc), then by label (desc) for tie-breaking\n    pairs = sorted(zip(scores, labels), key=lambda x: (x[0], x[1]), reverse=True)\n    \n    tp = 0\n    fp = 0\n    ap = 0.0\n    max_f1 = 0.0\n    last_recall = 0.0\n    \n    for i, (score, label) in enumerate(pairs):\n        if label == 1:\n            tp += 1\n        else:\n            fp += 1\n        \n        # Current precision and recall\n        # Per problem: if TP + FP = 0, Precision = 0. Here, TP+FP = i+1 >= 1.\n        precision = tp / (tp + fp)\n        recall = tp / n_pos\n\n        # Calculate F1 score\n        if precision + recall > 0:\n            f1 = 2 * precision * recall / (precision + recall)\n        else:\n            f1 = 0.0\n        \n        if f1 > max_f1:\n            max_f1 = f1\n\n        # Update AP using right Riemann sum definition\n        if label == 1:\n            ap += precision * (recall - last_recall)\n            last_recall = recall\n            \n    return ap, max_f1\n\nsolve()\n```", "id": "2947804"}]}