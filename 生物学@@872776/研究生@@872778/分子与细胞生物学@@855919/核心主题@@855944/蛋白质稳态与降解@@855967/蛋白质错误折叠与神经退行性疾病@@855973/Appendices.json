{"hands_on_practices": [{"introduction": "淀粉样蛋白纤维的形成是许多神经退行性疾病的标志，其生长动力学是理解疾病进展的关键。本练习将引导你运用基本的质量作用动力学原理，来量化一个核心过程：纤维的延长。通过计算纤维的生长速度和聚合物质倍增所需的时间，你将把抽象的速率常数与可观察的宏观现象联系起来[@problem_id:2960941]。", "problem": "一种淀粉样蛋白在恒定温度下的缓冲、混合均匀的溶液中进行延伸限制的纤维生长，其条件是在感兴趣的时间尺度内，成核、断裂和次级过程可以忽略不计。每条线性纤维有两个具有生长能力的末端。在这些条件下，标准的质量作用动力学适用于每个纤维末端：单体添加到末端的速率与游离单体浓度成正比，比例常数为延伸速率常数。每添加一个单体，纤维质量增加一个单体当量，纤维长度增加一个固定的每个并入单体的轴向增量。\n\n给定：\n- 延伸速率常数 $k_{+} = 2.30 \\times 10^{5}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$。\n- 游离单体浓度由一个大的储存库维持在大约恒定的 $m = 9.50 \\times 10^{-6}\\ \\mathrm{M}$。\n- 每个并入单体的轴向增量 $a = 0.475\\ \\mathrm{nm}$。\n- 初始纤维数量浓度（纤维的摩尔浓度）$P_{0} = 1.20 \\times 10^{-9}\\ \\mathrm{M}$。\n- 纤维中的初始聚集体质量浓度（以单体当量计）$M_{0} = 1.30 \\times 10^{-6}\\ \\mathrm{M}$。\n\n假设所有纤维的两端都具有生长能力，纤维的数量浓度保持不变（没有新纤维形成，也没有发生断裂），并且在所考虑的时间窗口内，单体浓度 $m$ 实际上保持恒定。\n\n仅使用质量作用动力的第一性原理和上述定义，推导表达式并计算：\n1) 每条纤维的端到端长度生长速度 $v$，考虑两端的并入。将最终数值以 nm s$^{-1}$ 表示，并四舍五入到三位有效数字。\n2) 仅通过延伸，纤维质量浓度从 $M_{0}$ 增加一倍到 $2 M_{0}$ 所需的时间 $t_{d}$。将最终数值以 s 表示，并四舍五入到三位有效数字。\n\n将您的最终数值结果以行矩阵 $\\begin{pmatrix} v  t_{d} \\end{pmatrix}$ 的形式给出（按此顺序）。不要在矩阵中包含单位。", "solution": "我们从纤维末端延伸的质量作用动力学开始。根据定义，在单个纤维末端，单体添加速率为 $k_{+} m$，其中 $k_{+}$ 是双分子延伸速率常数，$m$ 是游离单体浓度。对于具有两个生长能力末端的线性纤维，每条纤维的总单体添加速率为\n$$\nr_{\\text{mono,fibril}} = 2\\,k_{+}\\,m.\n$$\n每个并入的单体使纤维前进一个轴向增量 $a$，因此每条纤维的端到端长度生长速度为\n$$\nv = a \\times r_{\\text{mono,fibril}} = 2\\,a\\,k_{+}\\,m.\n$$\n代入给定值可得\n$$\nk_{+} m = \\left(2.30 \\times 10^{5}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}\\right)\\left(9.50 \\times 10^{-6}\\ \\mathrm{M}\\right) = 2.185\\ \\mathrm{s}^{-1},\n$$\n所以\n$$\nv = 2 \\times 0.475\\ \\mathrm{nm} \\times 2.185\\ \\mathrm{s}^{-1} = 2.07575\\ \\mathrm{nm}\\ \\mathrm{s}^{-1}.\n$$\n四舍五入到三位有效数字，得到\n$$\nv = 2.08\\ \\mathrm{nm}\\ \\mathrm{s}^{-1}.\n$$\n\n接下来，我们计算仅通过延伸使聚集体质量浓度加倍所需的时间。设 $M(t)$ 表示纤维质量浓度（以单体当量计）。每单位体积的总单体并入速率是末端浓度与每个末端并入速率的乘积。纤维末端的浓度是 $2 P_{0}$，因为每条纤维贡献两个末端，且纤维数量浓度为 $P_{0}$。因此，\n$$\n\\frac{dM}{dt} = 2\\,P_{0}\\,k_{+}\\,m.\n$$\n在这些假设下，$P_{0}$ 和 $m$ 是常数，所以等式右侧是常数。以 $M(0) = M_{0}$ 进行积分，得到\n$$\nM(t) = M_{0} + \\left(2\\,P_{0}\\,k_{+}\\,m\\right)t.\n$$\n加倍时间 $t_{d}$ 满足 $M(t_{d}) = 2 M_{0}$：\n$$\nM_{0} + \\left(2\\,P_{0}\\,k_{+}\\,m\\right)t_{d} = 2 M_{0} \\;\\;\\Rightarrow\\;\\; t_{d} = \\frac{M_{0}}{2\\,P_{0}\\,k_{+}\\,m}.\n$$\n代入数值，\n$$\n2\\,P_{0}\\,k_{+}\\,m = 2 \\times \\left(1.20 \\times 10^{-9}\\ \\mathrm{M}\\right) \\times \\left(2.185\\ \\mathrm{s}^{-1}\\right) = 5.244 \\times 10^{-9}\\ \\mathrm{M}\\ \\mathrm{s}^{-1},\n$$\n所以\n$$\nt_{d} = \\frac{1.30 \\times 10^{-6}\\ \\mathrm{M}}{5.244 \\times 10^{-9}\\ \\mathrm{M}\\ \\mathrm{s}^{-1}} = 2.48092 \\times 10^{2}\\ \\mathrm{s}.\n$$\n四舍五入到三位有效数字，得到\n$$\nt_{d} = 248\\ \\mathrm{s}.\n$$\n\n因此，所要求的结果是 $v = 2.08\\ \\mathrm{nm}\\ \\mathrm{s}^{-1}$ 和 $t_{d} = 248\\ \\mathrm{s}$。按要求，最终答案以行矩阵的形式 $\\begin{pmatrix} v  t_{d} \\end{pmatrix}$ 给出，不带单位。", "answer": "$$\\boxed{\\begin{pmatrix}2.08  248\\end{pmatrix}}$$", "id": "2960941"}, {"introduction": "在细胞的复杂环境中，蛋白质稳态网络（proteostasis network）持续监控并处理错误折叠的蛋白质。本练习将视角从体外系统转向细胞内部，通过构建一个包含分子伴侣的动力学模型，来模拟细胞的质量控制机制。你将探索当细胞的分子伴侣能力因压力而下降时，错误折叠蛋白质的稳态水平会如何变化，从而将分子动力学与细胞应激反应联系起来[@problem_id:2960883]。", "problem": "神经元中的单个客户蛋白可能会错误折叠成一种无功能状态。令 $M$ 表示错误折叠物质的浓度，$E$ 表示游离分子伴侣的浓度，$EM$ 表示分子伴侣-错误折叠复合物的浓度。错误折叠的蛋白质通过持续的合成和应激诱导的错误折叠，以恒定的速率 $s$ 产生。该系统遵循质量作用动力学，具有以下基元步骤和参数：\n- 结合：$M + E \\xrightleftharpoons[k_{\\mathrm{off}}]{k_{\\mathrm{on}}} EM$，其中 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 分别是二级和一级速率常数。\n- 重折叠：$EM \\xrightarrow{k_{\\mathrm{ref}}} \\text{天然态} + E$，其中 $k_{\\mathrm{ref}}$ 是一级速率常数。\n- 降解：$M \\xrightarrow{k_{\\mathrm{deg}}} \\varnothing$，其中 $k_{\\mathrm{deg}}$ 是一级速率常数。\n- 分子伴侣守恒：$E_{\\mathrm{T}} = E + EM$。\n\n假设对复合物 $EM$ 使用准稳态近似（QSSA），并对 $M$ 使用稳态。同时假设总客户蛋白池 $P_{\\mathrm{tot}}$ 是缓冲的，并且在所考虑的时间尺度上有效恒定，因此错误折叠分数 $f$ 与 $M$ 成正比，关系为 $f = M/P_{\\mathrm{tot}}$。因此，在分子伴侣容量受到扰动后，稳态错误折叠分数的倍数变化等于相应稳态错误折叠浓度的比值。\n\n考虑以下基线参数值：\n- $s = 0.50$ $\\mathrm{\\mu M \\cdot h^{-1}}$，\n- $k_{\\mathrm{deg}} = 0.20$ $\\mathrm{h^{-1}}$，\n- $k_{\\mathrm{on}} = 2.0$ $\\mathrm{\\mu M^{-1} \\cdot h^{-1}}$，\n- $k_{\\mathrm{off}} = 1.0$ $\\mathrm{h^{-1}}$，\n- $k_{\\mathrm{ref}} = 3.0$ $\\mathrm{h^{-1}}$，\n- $E_{\\mathrm{T}} = 1.0$ $\\mathrm{\\mu M}$。\n\n一种与疾病相关的应激使可用的分子伴侣容量减半至 $E_{\\mathrm{T}}' = E_{\\mathrm{T}}/2$，而不改变动力学速率常数 $k_{\\mathrm{on}}$、$k_{\\mathrm{off}}$、$k_{\\mathrm{ref}}$，或来源和降解参数 $s$ 和 $k_{\\mathrm{deg}}$。\n\n从上述给出的质量作用常微分方程和守恒定律出发，在QSSA下推导出 $M$ 的稳态方程，求解基线稳态 $M_{\\ast}$ 和将 $E_{\\mathrm{T}}$ 减半后的扰动稳态 $M_{\\ast}'$，然后计算由 $M_{\\ast}'/M_{\\ast}$ 给出的错误折叠分数的倍数变化。将最终比率四舍五入至四位有效数字。以纯数字（无量纲）形式表示你的答案。", "solution": "所提出的问题是生物化学动力学中的一个标准练习，其定义明确、科学上合理且内部一致。我们将系统地进行求解。\n\n首先，我们通过写出错误折叠蛋白 $M$ 和分子伴侣-错误折叠蛋白复合物 $EM$ 浓度的常微分方程（ODE）来形式化系统动力学，这些方程基于指定基元步骤的质量作用定律。游离分子伴侣的浓度用 $E$ 表示。\n\n$M$ 的变化率由下式给出：\n$$ \\frac{dM}{dt} = s - k_{\\mathrm{deg}}M - k_{\\mathrm{on}}ME + k_{\\mathrm{off}}EM $$\n复合物 $EM$ 的变化率是：\n$$ \\frac{d[EM]}{dt} = k_{\\mathrm{on}}ME - k_{\\mathrm{off}}EM - k_{\\mathrm{ref}}EM $$\n\n问题要求对复合物 $EM$ 应用准稳态近似（QSSA）。该近似假设中间复合物 $EM$ 的浓度会迅速适应 $M$ 和 $E$ 浓度的变化，因此其变化率实际上为零：$\\frac{d[EM]}{dt} \\approx 0$。\n$$ 0 = k_{\\mathrm{on}}ME - (k_{\\mathrm{off}} + k_{\\mathrm{ref}})EM $$\n由此，我们可以用 $M$ 和 $E$ 来表示复合物 $EM$ 的浓度：\n$$ EM = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{off}} + k_{\\mathrm{ref}}} ME $$\n为了方便，可以定义一个复合参数，类似于米氏常数，$K_{\\mathrm{M}}$：\n$$ K_{\\mathrm{M}} = \\frac{k_{\\mathrm{off}} + k_{\\mathrm{ref}}}{k_{\\mathrm{on}}} $$\n因此，QSSA关系简化为：\n$$ EM = \\frac{M}{K_{\\mathrm{M}}}E $$\n\n接下来，我们使用总分子伴侣浓度的守恒定律，$E_{\\mathrm{T}}$：\n$$ E_{\\mathrm{T}} = E + EM $$\n代入QSSA中得到的 $EM$ 表达式：\n$$ E_{\\mathrm{T}} = E + \\frac{M}{K_{\\mathrm{M}}}E = E \\left(1 + \\frac{M}{K_{\\mathrm{M}}}\\right) $$\n我们现在可以解出游离分子伴侣浓度 $E$ 关于 $M$ 和总分子伴侣浓度 $E_{\\mathrm{T}}$ 的表达式：\n$$ E = \\frac{E_{\\mathrm{T}}}{1 + M/K_{\\mathrm{M}}} = \\frac{E_{\\mathrm{T}}K_{\\mathrm{M}}}{M + K_{\\mathrm{M}}} $$\n将此式代回 $EM$ 的表达式，我们得到 $EM$ 作为 $M$ 和 $E_{\\mathrm{T}}$ 的函数：\n$$ EM = \\frac{M}{K_{\\mathrm{M}}} \\left( \\frac{E_{\\mathrm{T}}K_{\\mathrm{M}}}{M + K_{\\mathrm{M}}} \\right) = \\frac{E_{\\mathrm{T}}M}{M + K_{\\mathrm{M}}} $$\n这个表达式描述了一个饱和结合过程，这是酶动力学的特征。\n\n现在，我们对错误折叠蛋白 $M$ 施加稳态条件，记为 $M_{\\ast}$。在稳态时，$\\frac{dM}{dt} = 0$：\n$$ 0 = s - k_{\\mathrm{deg}}M_{\\ast} - k_{\\mathrm{on}}M_{\\ast}E_{\\ast} + k_{\\mathrm{off}}EM_{\\ast} $$\n项 $-k_{\\mathrm{on}}M_{\\ast}E_{\\ast} + k_{\\mathrm{off}}EM_{\\ast}$ 代表了 $M$ 进入分子伴侣结合途径的净通量。根据 $EM$ 的QSSA，我们有 $k_{\\mathrm{on}}M_{\\ast}E_{\\ast} - k_{\\mathrm{off}}EM_{\\ast} = k_{\\mathrm{ref}}EM_{\\ast}$。因此，$M$ 的稳态方程简化为：\n$$ s = k_{\\mathrm{deg}}M_{\\ast} + k_{\\mathrm{ref}}EM_{\\ast} $$\n该方程表示了生产速率 ($s$) 与降解总清除速率 ($k_{\\mathrm{deg}}M_{\\ast}$) 和分子伴侣介导的重折叠总清除速率 ($k_{\\mathrm{ref}}EM_{\\ast}$) 之间的平衡。\n\n代入 $EM_{\\ast}$ 关于 $M_{\\ast}$ 和 $E_{\\mathrm{T}}$ 的表达式：\n$$ s = k_{\\mathrm{deg}}M_{\\ast} + \\frac{k_{\\mathrm{ref}}E_{\\mathrm{T}}M_{\\ast}}{M_{\\ast} + K_{\\mathrm{M}}} $$\n为了求解 $M_{\\ast}$，我们将其整理成一个多项式方程。两边乘以 $(M_{\\ast} + K_{\\mathrm{M}})$：\n$$ s(M_{\\ast} + K_{\\mathrm{M}}) = k_{\\mathrm{deg}}M_{\\ast}(M_{\\ast} + K_{\\mathrm{M}}) + k_{\\mathrm{ref}}E_{\\mathrm{T}}M_{\\ast} $$\n$$ sM_{\\ast} + sK_{\\mathrm{M}} = k_{\\mathrm{deg}}M_{\\ast}^2 + k_{\\mathrm{deg}}K_{\\mathrm{M}}M_{\\ast} + k_{\\mathrm{ref}}E_{\\mathrm{T}}M_{\\ast} $$\n整理各项，得到一个关于 $M_{\\ast}$ 的二次方程：\n$$ k_{\\mathrm{deg}}M_{\\ast}^2 + (k_{\\mathrm{deg}}K_{\\mathrm{M}} + k_{\\mathrm{ref}}E_{\\mathrm{T}} - s)M_{\\ast} - sK_{\\mathrm{M}} = 0 $$\n这是QSSA条件下 $M$ 的通用稳态方程。设该二次方程为 $aM_{\\ast}^2 + bM_{\\ast} + c = 0$，其中：\n$a = k_{\\mathrm{deg}}$\n$b = k_{\\mathrm{deg}}K_{\\mathrm{M}} + k_{\\mathrm{ref}}E_{\\mathrm{T}} - s$\n$c = -sK_{\\mathrm{M}}$\n\n$M_{\\ast}$ 的物理上有意义的解必须是正的。鉴于 $a > 0$ 和 $c < 0$，二次公式会产生一个正根和一个负根。我们取正根：\n$$ M_{\\ast} = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} $$\n\n我们现在计算数值。首先是复合常数 $K_{\\mathrm{M}}$：\n$$ K_{\\mathrm{M}} = \\frac{k_{\\mathrm{off}} + k_{\\mathrm{ref}}}{k_{\\mathrm{on}}} = \\frac{1.0 \\ \\mathrm{h^{-1}} + 3.0 \\ \\mathrm{h^{-1}}}{2.0 \\ \\mathrm{\\mu M^{-1} \\cdot h^{-1}}} = \\frac{4.0}{2.0} \\ \\mathrm{\\mu M} = 2.0 \\ \\mathrm{\\mu M} $$\n\n对于基线条件，$E_{\\mathrm{T}} = 1.0 \\ \\mathrm{\\mu M}$。二次方程的系数为：\n$a = k_{\\mathrm{deg}} = 0.20$\n$b = k_{\\mathrm{deg}}K_{\\mathrm{M}} + k_{\\mathrm{ref}}E_{\\mathrm{T}} - s = (0.20)(2.0) + (3.0)(1.0) - 0.50 = 0.40 + 3.0 - 0.50 = 2.9$\n$c = -sK_{\\mathrm{M}} = -(0.50)(2.0) = -1.0$\n\n求解基线稳态浓度 $M_{\\ast}$：\n$$ M_{\\ast} = \\frac{-2.9 + \\sqrt{2.9^2 - 4(0.20)(-1.0)}}{2(0.20)} = \\frac{-2.9 + \\sqrt{8.41 + 0.8}}{0.4} = \\frac{-2.9 + \\sqrt{9.21}}{0.4} \\approx 0.336995 \\ \\mathrm{\\mu M} $$\n\n对于扰动条件，分子伴侣容量减半：$E_{\\mathrm{T}}' = E_{\\mathrm{T}}/2 = 0.5 \\ \\mathrm{\\mu M}$。系数 $a$ 和 $c$ 保持不变。新的系数 $b'$ 依赖于 $E_{\\mathrm{T}}$，为：\n$b' = k_{\\mathrm{deg}}K_{\\mathrm{M}} + k_{\\mathrm{ref}}E_{\\mathrm{T}}' - s = (0.20)(2.0) + (3.0)(0.5) - 0.50 = 0.40 + 1.5 - 0.50 = 1.4$\n\n求解新的稳态浓度 $M_{\\ast}'$：\n$$ M_{\\ast}' = \\frac{-1.4 + \\sqrt{1.4^2 - 4(0.20)(-1.0)}}{2(0.20)} = \\frac{-1.4 + \\sqrt{1.96 + 0.8}}{0.4} = \\frac{-1.4 + \\sqrt{2.76}}{0.4} \\approx 0.653312 \\ \\mathrm{\\mu M} $$\n\n错误折叠分数的倍数变化由稳态浓度之比 $M_{\\ast}'/M_{\\ast}$ 给出。\n$$ \\frac{M_{\\ast}'}{M_{\\ast}} = \\frac{0.653312}{0.336995} \\approx 1.938634 $$\n将结果四舍五入至四位有效数字，得到 $1.939$。", "answer": "$$\n\\boxed{1.939}\n$$", "id": "2960883"}, {"introduction": "神经退行性疾病中的病理蛋白不仅仅在单个细胞内累积，还会在大脑的神经网络中进行“传染性”扩散。这个计算实践将你置于计算神经科学家的角色，使用网络扩散模型来模拟这种跨神经元的传播。通过将模型预测与类似于布拉克分期（Braak staging）的经验数据进行拟合与验证，你将亲身体验如何运用前沿的计算方法来检验关于疾病进展的系统级假说[@problem_id:2960901]。", "problem": "您将构建并验证一个网络扩散模型，用于模拟错误折叠蛋白质病理在脑连接组上的传播，并将其与类似于Braak分期的区域性有序分期标签进行拟合。该实现必须是完全确定性的，并且只能在下面提供的参数集上运行。所有量均为无量纲。最终程序必须生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。\n\n基于第一性原理的背景和建模假设：\n- 错误折叠的蛋白质种类（例如，tau蛋白或α-突触核蛋白）可以沿解剖连接跨神经元传播。一个经过充分检验的唯象近似是在网络上的线性扩散，这与图上的Fick定律和质量守恒定律一致。\n- 脑连接组是一个对称的非负加权邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其中 $A_{ij} = A_{ji} \\geq 0$ 且 $A_{ii} = 0$。\n- 设 $D$ 为对角度矩阵，其元素为 $D_{ii} = \\sum_{j=1}^{n} A_{ij}$。定义对称归一化图拉普拉斯算子 $L = I - D^{-1/2} A D^{-1/2}$，其中 $I$ 是大小为 $n \\times n$ 的单位矩阵。\n- 设初始播种向量为 $x_0 \\in \\mathbb{R}^n$，对于播种区域，$(x_0)_i = 1$，否则 $(x_0)_i = 0$。\n- 经过一个非负扩散尺度参数 $\\beta \\geq 0$ 后的病理场是热核作用于初始种子的结果：$x(\\beta) = \\exp(-\\beta L) x_0$，其中 $\\exp(\\cdot)$ 表示矩阵指数。\n- 有序分期标签 $b \\in \\{1,2,\\dots,B\\}^n$ 编码了相对受累顺序（值越小表示越早）。通过 $y_i = B + 1 - b_i$ 定义目标 $y \\in \\mathbb{R}^n$，使得较大的 $y_i$ 表示较早的受累。使用 $x(\\beta)$ 和 $y$ 之间的Spearman秩相关系数作为拟合优度度量，因为它对单调变换具有不变性，并且适用于有序数据。如果Spearman相关性因方差为零（例如，所有值都相等）而在某个子集上未定义，则按惯例将其相关性设置为 $0$。\n\n交叉验证和超参数选择：\n- 使用$K$-折交叉验证，其中第$k$个测试折（对于 $k \\in \\{0,1,\\dots,K-1\\}$）包含所有满足 $i \\bmod K = k$ 的索引 $i \\in \\{0,1,\\dots,n-1\\}$。训练集是其补集。\n- 对于给定的非负 $\\beta$ 值的候选网格 $\\mathcal{G}$，对每个 $\\beta \\in \\mathcal{G}$ 和每个折，计算仅限于该折训练索引的 $x(\\beta)$ 和 $y$ 之间的Spearman相关性。将所有折的训练相关性取平均，以获得该 $\\beta$ 的交叉验证训练得分。\n- 选择使各折的平均训练Spearman相关性最大化的 $\\beta^\\star \\in \\mathcal{G}$。通过选择最小的 $\\beta$ 来解决平局问题。\n- 使用选定的 $\\beta^\\star$，计算每个测试折上的Spearman相关性，并报告这些测试相关性的平均值作为交叉验证性能。\n\n每个测试用例的所需输出：\n- 对于下面的每个测试用例，输出两个浮点数：选定的 $\\beta^\\star$ 和各折的平均测试Spearman相关性，每个数值四舍五入到六位小数。\n- 将所有测试用例的输出按测试用例的顺序汇总到一个列表中，格式化为单行：例如，$[\\beta^\\star_1,\\rho_1,\\beta^\\star_2,\\rho_2,\\dots]$，不含空格。\n\n测试套件：\n- 测试用例1（路径图，单一种子在一端，单调分期）：\n  - 大小 $n = 6$。\n  - 邻接矩阵 $A$，边权重为 $1$：\n    - 第1行：$[0,1,0,0,0,0]$，\n    - 第2行：$[1,0,1,0,0,0]$，\n    - 第3行：$[0,1,0,1,0,0]$，\n    - 第4行：$[0,0,1,0,1,0]$，\n    - 第5行：$[0,0,0,1,0,1]$，\n    - 第6行：$[0,0,0,0,1,0]$。\n  - 种子索引 $S_0 = \\{0\\}$，所以 $x_0 = [1,0,0,0,0,0]^T$。\n  - 分期 $b = [1,2,3,4,5,6]$，所以 $B = 6$ 且 $y = [6,5,4,3,2,1]$。\n  - 折数 $K = 3$。\n  - 候选网格 $\\mathcal{G} = \\{0.05, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0\\}$。\n\n- 测试用例2（两个不相连的三角形，一个三角形中有单一种子，另一个三角形中有晚期标签）：\n  - 大小 $n = 6$。\n  - 邻接矩阵 $A$：\n    - 第1-3行构成一个单位权重的团：第1-3行限制在第1-3列等于 $[[0,1,1],[1,0,1],[1,1,0]]$；第4-6行限制在第4-6列等于 $[[0,1,1],[1,0,1],[1,1,0]]$；所有跨块条目均为 $0$。\n  - 种子索引 $S_0 = \\{1\\}$，所以 $x_0 = [0,1,0,0,0,0]^T$。\n  - 分期 $b = [2,1,3,6,6,6]$，所以 $B = 6$ 且 $y = [5,6,4,1,1,1]$。\n  - 折数 $K = 3$。\n  - 候选网格 $\\mathcal{G} = \\{0.05, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0\\}$。\n\n- 测试用例3（星形图，中心种子，异构叶节点分期以避免简并）：\n  - 大小 $n = 6$。\n  - 邻接矩阵 $A$，节点 $1$ 与节点 $2$–$6$ 连接，权重为 $1$，叶节点之间无边：\n    - 第1行：$[0,1,1,1,1,1]$，\n    - 第2行：$[1,0,0,0,0,0]$，\n    - 第3行：$[1,0,0,0,0,0]$，\n    - 第4行：$[1,0,0,0,0,0]$，\n    - 第5行：$[1,0,0,0,0,0]$，\n    - 第6行：$[1,0,0,0,0,0]$。\n  - 种子索引 $S_0 = \\{0\\}$，所以 $x_0 = [1,0,0,0,0,0]^T$。\n  - 分期 $b = [1,2,3,2,3,2]$，所以 $B = 3$ 且 $y = [3,2,1,2,1,2]$。\n  - 折数 $K = 3$。\n  - 候选网格 $\\mathcal{G} = \\{0.05, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0\\}$。\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含一个按测试用例顺序排列、用方括号括起来的逗号分隔列表：$[\\beta^\\star_1,\\rho_1,\\beta^\\star_2,\\rho_2,\\beta^\\star_3,\\rho_3]$，其中每个数字都四舍五入到六位小数。", "solution": "所呈现的问题是计算生物学中一个适定且科学上合理的练习，特别是在神经退行性疾病病理学建模方面。它要求实现和验证一个网络扩散模型。我们的任务是从一个离散的候选集 $\\mathcal{G}$ 中确定一个最优的扩散尺度参数 $\\beta^\\star$，并使用 $K$-折交叉验证来评估模型的性能。我现在将逐步描述解决此问题的步骤。\n\n首先，我们必须形式化数学模型。大脑的解剖网络由一个对称邻接矩阵 $A$ 表示，其中 $A_{ij} \\ge 0$ 是区域 $i$ 和区域 $j$ 之间的连接强度。错误折叠蛋白质的传播受此图上的线性扩散方程控制。病理浓度向量 $x$ 的演化由图热方程描述。\n\n与拉普拉斯算子对应的算子的离散形式是图拉普拉斯算子。我们使用对称归一化图拉普拉斯算子，定义为：\n$$L = I - D^{-1/2} A D^{-1/2}$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵，$D$ 是对角度矩阵，其元素为 $D_{ii} = \\sum_{j} A_{ij}$。项 $D^{-1/2}$ 表示 $D$ 对角线元素的逐元素平方根倒数。只要没有区域是完全断开的（即所有度都非零），这个公式就是有效的，所有提供的测试用例都满足这个条件。\n\n系统的初始状态由一个种子向量 $x_0$ 给出，其中对于初始受影响的区域，$(x_0)_i = 1$，否则为 $0$。图热方程的解描述了在稍后的“时间”或更准确地说，在扩散尺度 $\\beta \\ge 0$ 时的病理浓度。该解由拉普拉斯算子的矩阵指数作用于初始状态给出：\n$$x(\\beta) = \\exp(-\\beta L) x_0$$\n该方程模拟了初始病理 $x_0$ 如何在尺度 $\\beta$ 上通过网络扩散。\n\n为了评估模型的预测，我们将预测的病理向量 $x(\\beta)$ 与经验分期数据进行比较。提供的有序分期标签 $b$（其中较小的值表示病理受累的较早阶段）被转换为定量目标向量 $y$。转换公式为 $y_i = B + 1 - b_i$，其中 $B = \\max(b_i)$。这种转换确保了 $y$ 中较高的值对应于较早的疾病受累，这与浓度 $x_i(\\beta)$ 较高的区域受影响更早的预期相符。\n\n拟合优度通过模型输出 $x(\\beta)$ 和目标向量 $y$ 之间的Spearman秩相关系数 $\\rho_s$ 来量化。这种非参数度量适用于有序数据，因为它对数据的任何单调重缩放都不变，仅评估其秩的对应关系。按照规定，如果对于给定的数据子集（例如，由于其中一个向量的方差为零），相关性未定义，则其值取为 $0$。\n\n任务的核心是找到最优参数 $\\beta^\\star$ 并使用 $K$-折交叉验证评估模型的泛化能力。其过程展开如下：\n\n1.  **数据划分**：将 $n$ 个脑部分区为 $K$ 个不相交的折。第 $k$ 个测试折包含所有满足 $i \\pmod K = k$ 的索引 $i$。折 $k$ 的训练集是其测试集的补集。\n\n2.  **超参数优化**：我们遍历每个候选值 $\\beta \\in \\mathcal{G}$。对于每个 $\\beta$：\n    a.  计算病理向量 $x(\\beta) = \\exp(-\\beta L) x_0$。此计算对每个 $\\beta$ 值执行一次。矩阵指数 $\\exp(-\\beta L)$ 使用稳健的数值库函数计算。\n    b.  对于 $K$ 个折中的每一个，我们计算与该折的*训练*索引相对应的 $x(\\beta)$ 和 $y$ 的分量之间的Spearman相关性。\n    c.  $\\beta$ 的交叉验证训练得分是这 $K$ 个训练相关性的平均值。\n\n3.  **最优参数选择**：最优参数 $\\beta^\\star$ 是 $\\mathcal{G}$ 中产生最大交叉验证训练分数的那个值。任何平局都通过选择最小的 $\\beta$ 值来解决。\n\n4.  **性能评估**：使用选定的 $\\beta^\\star$，我们在留出的测试数据上评估模型的预测性能。\n    a.  使用病理向量 $x(\\beta^\\star)$。\n    b.  对于 $K$ 个折中的每一个，我们计算与该折的*测试*索引相对应的 $x(\\beta^\\star)$ 和 $y$ 的分量之间的Spearman相关性。\n    c.  最终报告的性能指标 $\\rho$ 是这 $K$ 个测试相关性的平均值。\n\n这整个过程是确定性的，并将应用于提供的每个测试用例。每个用例的最终输出包括一对值 $(\\beta^\\star, \\rho)$，然后将它们汇总到一个格式化的列表中。\n\n该实现将依赖于 `numpy` 库进行矩阵运算，并依赖 `scipy` 库的专门函数，即用于矩阵指数的 `scipy.linalg.expm` 和用于相关系数的 `scipy.stats.spearmanr`。将注意处理 `spearmanr` 对常数值输入返回 `NaN` 的情况，按照问题规范将结果设置为 $0$。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\nfrom scipy.stats import spearmanr\n\ndef process_case(A, seed_indices, b, K, G):\n    \"\"\"\n    Solves for one test case of the network diffusion model.\n\n    Args:\n        A (np.ndarray): Adjacency matrix of the graph.\n        seed_indices (set): Set of indices for the seed regions.\n        b (np.ndarray): Ordinal staging labels.\n        K (int): Number of folds for cross-validation.\n        G (list): Grid of candidate beta values.\n\n    Returns:\n        tuple: A tuple containing the optimal beta (beta_star) and the mean\n               test Spearman correlation.\n    \"\"\"\n    n = A.shape[0]\n\n    # --- 1. Model Setup ---\n    # Initial pathology vector x_0\n    x0 = np.zeros(n)\n    for i in seed_indices:\n        x0[i] = 1.0\n\n    # Target vector y\n    B = np.max(b)\n    y = B + 1 - b\n\n    # Symmetric normalized graph Laplacian L\n    D = np.diag(np.sum(A, axis=1))\n    # Check for isolated nodes to prevent division by zero.\n    # The problem cases do not have isolated nodes.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        D_inv_sqrt = np.diag(1.0 / np.sqrt(np.diag(D)))\n    # Replace inf which results from 1/0 with 0\n    D_inv_sqrt[np.isinf(D_inv_sqrt)] = 0.0\n    L = np.identity(n) - D_inv_sqrt @ A @ D_inv_sqrt\n\n    # Fold indices\n    all_indices = np.arange(n)\n    fold_indices = [all_indices[all_indices % K == k] for k in range(K)]\n\n    # --- 2. Cross-validation to select beta_star ---\n    mean_train_rhos = {}\n    for beta in G:\n        # Calculate pathology vector x(beta)\n        x_beta = expm(-beta * L) @ x0\n\n        fold_train_rhos = []\n        for k in range(K):\n            test_idx = fold_indices[k]\n            train_idx = np.setdiff1d(all_indices, test_idx)\n            \n            x_train = x_beta[train_idx]\n            y_train = y[train_idx]\n            \n            # Spearman correlation on training set\n            if len(x_train)  2 or np.var(x_train) == 0 or np.var(y_train) == 0:\n                rho = 0.0\n            else:\n                rho, _ = spearmanr(x_train, y_train)\n                if np.isnan(rho):\n                    rho = 0.0\n            fold_train_rhos.append(rho)\n        \n        mean_train_rhos[beta] = np.mean(fold_train_rhos)\n\n    # Select beta_star\n    # Find the max correlation. In case of a tie, the smallest beta is chosen\n    # because the G list is sorted and we iterate through it.\n    best_train_rho = -np.inf\n    beta_star = -1.0\n    for beta in G: \n        if mean_train_rhos[beta] > best_train_rho:\n            best_train_rho = mean_train_rhos[beta]\n            beta_star = beta\n\n    # --- 3. Evaluate on test sets using beta_star ---\n    x_beta_star = expm(-beta_star * L) @ x0\n    \n    test_rhos = []\n    for k in range(K):\n        test_idx = fold_indices[k]\n        \n        x_test = x_beta_star[test_idx]\n        y_test = y[test_idx]\n        \n        # Spearman correlation on test set\n        if len(x_test)  2 or np.var(x_test) == 0 or np.var(y_test) == 0:\n            rho = 0.0\n        else:\n            rho, _ = spearmanr(x_test, y_test)\n            if np.isnan(rho):\n                rho = 0.0\n        test_rhos.append(rho)\n        \n    mean_test_rho = np.mean(test_rhos)\n\n    return beta_star, mean_test_rho\n\n\ndef solve():\n    # Define test cases\n    G_common = [0.05, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0]\n    K_common = 3\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1],\n                [0, 0, 0, 0, 1, 0]\n            ], dtype=float),\n            \"seed_indices\": {0},\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n            \"K\": K_common,\n            \"G\": G_common\n        },\n        # Test Case 2\n        {\n            \"A\": np.array([\n                [0, 1, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [1, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 1],\n                [0, 0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 1, 0]\n            ], dtype=float),\n            \"seed_indices\": {1},\n            \"b\": np.array([2, 1, 3, 6, 6, 6]),\n            \"K\": K_common,\n            \"G\": G_common\n        },\n        # Test Case 3\n        {\n            \"A\": np.array([\n                [0, 1, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0]\n            ], dtype=float),\n            \"seed_indices\": {0},\n            \"b\": np.array([1, 2, 3, 2, 3, 2]),\n            \"K\": K_common,\n            \"G\": G_common\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        beta_star, mean_test_rho = process_case(**case)\n        results.append(f\"{beta_star:.6f}\")\n        results.append(f\"{mean_test_rho:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2960901"}]}