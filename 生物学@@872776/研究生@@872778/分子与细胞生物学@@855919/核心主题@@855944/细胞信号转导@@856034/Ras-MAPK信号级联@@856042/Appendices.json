{"hands_on_practices": [{"introduction": "Ras-MAPK 信号级联以其将连续变化的输入信号转换为类似开关的全或无输出而闻名。本练习旨在探究这一特性背后的基本机制，即零阶超敏性 (zero-order ultrasensitivity)。通过推导共价修饰循环的 Goldbeter-Koshland 方程，你将理解相互拮抗的酶（如 MEK 和 DUSPs）的饱和如何能够产生极其陡峭的响应曲线，这是构成复杂细胞决策的关键模块 [@problem_id:2961613]。", "problem": "在一个模拟细胞外信号调节激酶 (ERK) 活化的共价修饰循环中，细胞外信号调节激酶的激酶 (MEK) 催化 ERK 磷酸化为其活性的双磷酸化形式，而双特异性磷酸酶 (DUSPs) 则催化其去磷酸化回到非活性形式。设守恒的 ERK 总浓度为 $S_{T}$，并定义无量纲的活性分数为 $R \\equiv [\\mathrm{ERK}^{\\ast}]/S_{T}$，其中 $R \\in [0,1]$。在对酶-底物复合物采用准稳态近似，并假设每种酶都遵循米氏动力学的情况下，正向和反向速率分别为：\n$$\nv_{1}(R) \\;=\\; \\frac{V_{1}\\,(1 - R)}{K_{1} + 1 - R}\n\\quad\\text{和}\\quad\nv_{2}(R) \\;=\\; \\frac{V_{2}\\,R}{K_{2} + R},\n$$\n其中 $V_{1} \\equiv k_{\\mathrm{cat},1} E_{1,T}$ 和 $V_{2} \\equiv k_{\\mathrm{cat},2} E_{2,T}$ 分别是 MEK 和 DUSPs 的最大速率，而 $K_{1} \\equiv K_{m,1}/S_{T}$ 和 $K_{2} \\equiv K_{m,2}/S_{T}$ 是无量纲的米氏参数。仅从质量守恒、常微分方程 $dR/dt \\,=\\, v_{1}(R) - v_{2}(R)$ 以及上述 $v_{1}$ 和 $v_{2}$ 的准稳态理由出发，推导满足 $v_{1}(R^{\\ast}) = v_{2}(R^{\\ast})$ 和 $0 \\le R^{\\ast} \\le 1$ 的精确闭式稳态解 $R^{\\ast}$。您的最终表达式必须是一个以 $V_{1}$、$V_{2}$、$K_{1}$ 和 $K_{2}$ 表示的单一代数公式，并明确选择正确的二次方程分支，以使 $R^{\\ast}$ 对于所有允许的参数都是生物学上可接受的 ($0 \\le R^{\\ast} \\le 1$)。请勿引入任何进一步的近似。\n\n然后，利用 MEK 对 ERK 的磷酸化和双特异性磷酸酶 (DUSPs) 对其的去磷酸化的生物化学特征，陈述在何种参数体系下（根据 $K_{1}$、$K_{2}$ 相对于 $1$ 的量级以及 $V_{1}$ 相对于 $V_{2}$ 的大小），稳态输入-输出关系 $R^{\\ast}(V_{1},V_{2},K_{1},K_{2})$ 预期会表现出0级超敏性，并从第一性原理证明您的陈述。您报告的最终数值或解析答案必须是您推导出的 $R^{\\ast}$ 的单一闭式表达式，不带单位。不需要四舍五入。", "solution": "该问题要求推导活性 ERK 的稳态分数（表示为 $R^{\\ast}$），并分析导致超敏性的参数体系。验证证实了该问题是适定的，并且在科学上基于酶动力学和细胞信号传导的原理。\n\n首先，我们推导稳态活性分数 $R^{\\ast}$ 的表达式。稳态由磷酸化速率 $v_{1}$ 等于去磷酸化速率 $v_{2}$ 的条件定义。\n给定的速率方程为：\n$$ v_{1}(R) = \\frac{V_{1}\\,(1 - R)}{K_{1} + 1 - R} $$\n$$ v_{2}(R) = \\frac{V_{2}\\,R}{K_{2} + R} $$\n在稳态时，$R = R^{\\ast}$ 且 $v_{1}(R^{\\ast}) = v_{2}(R^{\\ast})$。\n$$ \\frac{V_{1}\\,(1 - R^{\\ast})}{K_{1} + 1 - R^{\\ast}} = \\frac{V_{2}\\,R^{\\ast}}{K_{2} + R^{\\ast}} $$\n为了求解 $R^{\\ast}$，我们进行交叉相乘以消除分母：\n$$ V_{1}(1 - R^{\\ast})(K_{2} + R^{\\ast}) = V_{2}R^{\\ast}(K_{1} + 1 - R^{\\ast}) $$\n展开方程两边：\n$$ V_{1}(K_{2} + R^{\\ast} - K_{2}R^{\\ast} - (R^{\\ast})^2) = V_{2}(K_{1}R^{\\ast} + R^{\\ast} - (R^{\\ast})^2) $$\n$$ V_{1}K_{2} + V_{1}(1 - K_{2})R^{\\ast} - V_{1}(R^{\\ast})^2 = V_{2}(1 + K_{1})R^{\\ast} - V_{2}(R^{\\ast})^2 $$\n将此方程重新排列成标准的二次方程形式 $a(R^{\\ast})^2 + bR^{\\ast} + c = 0$：\n$$ (V_{2} - V_{1})(R^{\\ast})^2 + [V_{1}(1 - K_{2}) - V_{2}(1 + K_{1})]R^{\\ast} + V_{1}K_{2} = 0 $$\n二次方程的系数为：\n$$ a = V_{2} - V_{1} $$\n$$ b = V_{1}(1 - K_{2}) - V_{2}(1 + K_{1}) = V_{1} - V_{1}K_{2} - V_{2} - V_{2}K_{1} $$\n$$ c = V_{1}K_{2} $$\n$R^{\\ast}$ 的解由二次公式给出：\n$$ R^{\\ast} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n我们必须选择物理上可接受的根，该根对于所有有效的非负参数值 ($V_1, V_2, K_1, K_2 > 0$) 都必须满足 $0 \\leq R^{\\ast} \\leq 1$。我们可以通过检验极限情况来确定正确的符号。\n考虑激酶活性为零的情况，$V_{1} \\to 0$。我们预期底物完全失活，因此 $R^{\\ast} \\to 0$。在此极限下，系数变为 $a \\to V_2$，$b \\to -V_2(1+K_1)$，且 $c \\to 0$。二次方程简化为 $V_{2}(R^{\\ast})^2 - V_{2}(1+K_{1})R^{\\ast} = 0$，其解为 $R^{\\ast}=0$ 和 $R^{\\ast}=1+K_1$。由于 $K_1>0$，唯一可接受的解是 $R^{\\ast}=0$。二次公式给出 $R^{\\ast} \\to \\frac{V_2(1+K_1) \\pm \\sqrt{V_2^2(1+K_1)^2}}{2V_2} = \\frac{1+K_1 \\pm (1+K_1)}{2}$。取负号得到 $0$，而取正号得到 $1+K_1$。因此，我们必须选择负号。\n\n考虑磷酸酶活性为零的情况，$V_{2} \\to 0$。我们预期底物完全活化，因此 $R^{\\ast} \\to 1$。在此极限下，系数变为 $a \\to -V_1$，$b \\to V_1(1-K_2)$，且 $c \\to V_1K_2$。方程变为 $-V_1(R^{\\ast})^2 + V_1(1-K_2)R^{\\ast} + V_1K_2 = 0$，简化为 $(R^{\\ast})^2 - (1-K_2)R^{\\ast} - K_2 = 0$。这可以因式分解为 $(R^{\\ast}-1)(R^{\\ast}+K_2)=0$，解为 $R^{\\ast}=1$ 和 $R^{\\ast}=-K_2$。唯一可接受的解是 $R^{\\ast}=1$。二次公式给出 $R^{\\ast} \\to \\frac{-V_1(1-K_2) \\pm \\sqrt{V_1^2(1-K_2)^2 - 4(-V_1)(V_1K_2)}}{2(-V_1)} = \\frac{-(1-K_2) \\pm \\sqrt{(1-K_2)^2+4K_2}}{-2} = \\frac{-(1-K_2) \\pm \\sqrt{(1+K_2)^2}}{-2} = \\frac{-(1-K_2) \\pm (1+K_2)}{-2}$。取负号得到 $\\frac{-1+K_2-1-K_2}{-2} = 1$，而取正号得到 $\\frac{-1+K_2+1+K_2}{-2} = -K_2$。同样，我们必须选择负号。\n\n因此，唯一的、生物学上可接受的稳态解是：\n$$ R^{\\ast} = \\frac{-b - \\sqrt{b^2 - 4ac}}{2a} $$\n代入 $a$、$b$ 和 $c$ 的表达式：\n$$ R^{\\ast} = \\frac{V_{2}(1+K_{1}) - V_{1}(1-K_{2}) - \\sqrt{\\left(V_{1}(1-K_{2}) - V_{2}(1+K_{1})\\right)^2 - 4(V_{2}-V_{1})V_{1}K_{2}}}{2(V_{2}-V_{1})} $$\n这个精确的闭式表达式对所有允许的参数值都有效。\n\n接下来，我们讨论0级超敏性的条件。当酶在其饱和的，即零级动力学区域内运作时，会出现这种现象。\n激酶 MEK 作用于非活性 ERK，其无量纲浓度为 $1-R$。当其底物浓度远大于其米氏常数时，即 $S_{T}(1-R) \\gg K_{m,1}$，MEK 达到饱和。用无量纲的术语表示，即 $1-R \\gg K_1$。\n磷酸酶 DUSP 作用于活性 ERK，其无量纲浓度为 $R$。当 $S_{T}R \\gg K_{m,2}$ 时，DUSP 达到饱和，用无量纲的术语表示，即 $R \\gg K_2$。\n为了使两种酶同时饱和，系统必须满足 $K_1 \\ll 1-R$ 和 $K_2 \\ll R$。这只有在 $R$ 不接近 $0$ 或 $1$ 时才可能实现，这反过来要求无量纲的米氏参数相对于 $1$ 要小得多：\n$$ K_{1} \\ll 1 \\quad \\text{和} \\quad K_{2} \\ll 1 $$\n在这些条件下，速率定律在 $R$ 的一个相当大的范围内近似为零级动力学。\n当 $1-R \\gg K_1$ 时，正向速率 $v_1(R) = \\frac{V_1(1-R)}{K_1+1-R} \\approx \\frac{V_1(1-R)}{1-R} = V_1$。\n当 $R \\gg K_2$ 时，反向速率 $v_2(R) = \\frac{V_2 R}{K_2+R} \\approx \\frac{V_2 R}{R} = V_2$。\n在稳态下，$v_1 \\approx v_2$，这意味着 $V_1 \\approx V_2$。这确定了系统响应最敏感的区域。\n如果 $V_1 < V_2$，净去磷酸化速率很高，将系统驱动到一个 $R^{\\ast}$ 非常小的状态。在这种“关闭”状态下，DUSP 不再饱和 ($R^{\\ast} \\sim K_2$)，但 MEK 仍然饱和。速率在较低的 $R^{\\ast}$ 值处达到平衡。\n如果 $V_1 > V_2$，净磷酸化速率很高，将系统驱动到一个 $R^{\\ast}$ 接近 $1$ 的状态。在这种“开启”状态下，MEK 不再饱和 ($(1-R^{\\ast}) \\sim K_1$)，但 DUSP 饱和。速率在较高的 $R^{\\ast}$ 值处达到平衡。\n在“关闭”状态 ($R^{\\ast} \\approx 0$) 和“开启”状态 ($R^{\\ast} \\approx 1$) 之间的转换发生在一个非常窄的刺激（例如，$V_1$）范围内，该范围以点 $V_1 = V_2$ 为中心。这种尖锐的、开关般的转换是零级超敏性的标志。\n总之，0级超敏性的参数体系特征如下：\n1.  $K_1 \\ll 1$ 和 $K_2 \\ll 1$：两种酶都有可能被它们各自的底物饱和，因为它们的米氏常数远小于总底物浓度 $S_T$。\n2.  $V_1$ 与 $V_2$ 相当：开关行为集中在最大酶促能力达到平衡的点附近。", "answer": "$$\\boxed{\\frac{V_{2}(1+K_{1}) - V_{1}(1-K_{2}) - \\sqrt{\\left(V_{1}(1-K_{2}) - V_{2}(1+K_{1})\\right)^2 - 4V_{1}K_{2}(V_{2}-V_{1})}}{2(V_{2}-V_{1})}}$$", "id": "2961613"}, {"introduction": "在超敏性的概念之上，许多生物系统利用反馈回路来产生更复杂的行为，例如细胞记忆。本练习将挑战你分析一个包含从 ERK 到 RAF 的正反馈回路的 MAPK 级联模型。通过系统性分析，你将发现产生双稳态——即存在两个稳定状态（如“开”与“关”）——所需的条件，并学习细胞如何利用此特性来做出不可逆的命运决定 [@problem_id:2961630]。", "problem": "给定一个简化的、无量纲的 RAF–MEK–ERK 信号级联动力学模型，该模型具有从细胞外信号调节激酶 (ERK) 到快速加速纤维肉瘤 (RAF) 的正反馈。该模型将丝裂原活化蛋白激酶/细胞外信号调节激酶 (MEK/ERK) 的激活聚合成一个超敏模块，并通过 ERK 增强的 RAF 激活来捕捉正反馈。状态变量是活性分数 $R \\in [0,1]$ (RAF) 和 $E \\in [0,1]$ (ERK)。常微分方程 (ODEs) 如下：\n$$\n\\frac{dR}{dt} = k_{R,\\mathrm{on}} \\left(\\alpha + \\beta \\, H_n(E;K)\\right)\\,(1 - R) - k_{R,\\mathrm{off}}\\,R,\n$$\n$$\n\\frac{dE}{dt} = k_{E,\\mathrm{on}} \\, H_m(R;J)\\,(1 - E) - k_{E,\\mathrm{off}}\\,E,\n$$\n其中 $H_n(x;K)$ 是一个希尔激活函数，定义为\n$$\nH_n(x;K) = \\frac{x^n}{K^n + x^n},\n$$\n其希尔系数为 $n \\ge 1$，半饱和常数为 $K \\in (0,1]$。类似地，$H_m(R;J)$ 的希尔系数为 $m \\ge 1$，半饱和常数为 $J \\in (0,1]$。所有变量和参数都是无量纲的。参数包括：\n- $k_{R,\\mathrm{on}} > 0$, $k_{R,\\mathrm{off}} > 0$: RAF 激活和失活速率常数。\n- $k_{E,\\mathrm{on}} > 0$, $k_{E,\\mathrm{off}} > 0$: ERK 激活和失活速率常数。\n- $\\alpha \\in [0,1]$: 基础 Ras 驱动的 RAF 输入。\n- $\\beta \\ge 0$: ERK 到 RAF 的正反馈强度。\n- $n \\ge 1$, $m \\ge 1$: ERK 到 RAF 和 RAF 到 ERK 模块的希尔系数。\n- $K \\in (0,1]$, $J \\in (0,1]$: 希尔函数的半饱和常数。\n\n你的任务是：\n1) 从第一性原理和生化反应动力学的核心定义出发，推导出一个计算准则，以确定系统是否表现出双稳态（即在 $(R,E) \\in [0,1]^2$ 中存在两个渐近稳定不动点，它们之间至少由一个不稳定不动点分隔）。你可以使用基于图形零斜线的不动点映射方法，或通过平衡点处的雅可比矩阵特征值进行线性稳定性分析，但你必须从给定的常微分方程和不动点的稳定性定义开始。\n\n2) 设计一个算法步骤，对于给定的参数集，计算 $[0,1]^2$ 中的所有不动点，并使用你的准则将每个不动点分类为稳定或不稳定。该步骤应具有鲁棒性，且不依赖于外部文件或用户输入。不允许提供关于数值方法的提示；你的方法必须从模型的数学结构中推导出来。\n\n3) 将你的步骤在一个程序中实现，对于以下测试套件中的每个参数集，该程序返回渐近稳定不动点的整数数量：\n- 测试 A (无反馈，预期为单稳态): \n  $\\alpha = 0.05$, $\\beta = 0.0$, $n = 4$, $m = 4$, $K = 0.4$, $J = 0.3$, $k_{R,\\mathrm{on}} = 5.0$, $k_{R,\\mathrm{off}} = 1.0$, $k_{E,\\mathrm{on}} = 5.0$, $k_{E,\\mathrm{off}} = 1.0$。\n- 测试 B (弱反馈且无超敏性，预期为单稳态):\n  $\\alpha = 0.05$, $\\beta = 0.2$, $n = 1$, $m = 1$, $K = 0.5$, $J = 0.5$, $k_{R,\\mathrm{on}} = 5.0$, $k_{R,\\mathrm{off}} = 1.0$, $k_{E,\\mathrm{on}} = 5.0$, $k_{E,\\mathrm{off}} = 1.0$。\n- 测试 C (强反馈且有超敏性，预期为双稳态):\n  $\\alpha = 0.01$, $\\beta = 1.2$, $n = 6$, $m = 6$, $K = 0.3$, $J = 0.2$, $k_{R,\\mathrm{on}} = 8.0$, $k_{R,\\mathrm{off}} = 1.0$, $k_{E,\\mathrm{on}} = 8.0$, $k_{E,\\mathrm{off}} = 1.0$。\n- 测试 D (与测试 C 相同但失活作用强，预期为单稳态):\n  $\\alpha = 0.01$, $\\beta = 1.2$, $n = 6$, $m = 6$, $K = 0.3$, $J = 0.2$, $k_{R,\\mathrm{on}} = 8.0$, $k_{R,\\mathrm{off}} = 4.0$, $k_{E,\\mathrm{on}} = 8.0$, $k_{E,\\mathrm{off}} = 4.0$。\n- 测试 E (高基础输入，预期为高状态下的单稳态):\n  $\\alpha = 0.6$, $\\beta = 0.8$, $n = 2$, $m = 2$, $K = 0.8$, $J = 0.8$, $k_{R,\\mathrm{on}} = 5.0$, $k_{R,\\mathrm{off}} = 1.0$, $k_{E,\\mathrm{on}} = 5.0$, $k_{E,\\mathrm{off}} = 1.0$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，例如 $[x_A,x_B,x_C,x_D,x_E]$，其中每个 $x_\\cdot$ 是对应测试用例的稳定不动点数量的整数。由于所有量都是无量纲的，因此不需要单位。\n\n注意：该程序必须是一个完整、可运行的实现，仅根据常微分方程的定义和基本微积分执行不动点搜索和稳定性分类，不使用任何外部数据或用户交互。鲁棒数值技术的使用必须直接源于数学结构，而非预先指定的求解公式。在整个过程中确保科学真实性和内部一致性。角度单位在此处不适用，输出中也不需要百分比。", "solution": "问题陈述已经过严格审查并确定有效。它在科学上基于生化反应动力学和动力系统的原理，其提法恰当、客观，并为严谨的求解提供了完整的信息集。因此，我们可以着手进行推导和计算分析。\n\n该问题要求一个双稳态判据和一个算法步骤，用于寻找并分类给定的二维常微分方程 (ODEs) 系统的所有不动点：\n$$\n\\frac{dR}{dt} = F_R(R, E) = k_{R,\\mathrm{on}} \\left(\\alpha + \\beta \\, H_n(E;K)\\right)\\,(1 - R) - k_{R,\\mathrm{off}}\\,R\n$$\n$$\n\\frac{dE}{dt} = F_E(R, E) = k_{E,\\mathrm{on}} \\, H_m(R;J)\\,(1 - E) - k_{E,\\mathrm{off}}\\,E\n$$\n其中 $R, E \\in [0,1]^2$。对于此系统，方块 $[0,1]^2$ 是一个不变集，因为其边界上的向量场指向域内或与其相切。\n\n**1. 双稳态计算判据的推导**\n\n系统的一个不动点，或称平衡点，是所有状态变量变化率为零的状态 $(R^*, E^*)$。在数学上，这由条件 $\\frac{dR}{dt} = 0$ 和 $\\frac{dE}{dt} = 0$ 定义。\n\n将导数设为零，得到一个由两个代数方程组成的系统，其解即为不动点：\n$$\nk_{R,\\mathrm{on}} \\left(\\alpha + \\beta \\, H_n(E^*;K)\\right)\\,(1 - R^*) - k_{R,\\mathrm{off}}\\,R^* = 0 \\quad (1)\n$$\n$$\nk_{E,\\mathrm{on}} \\, H_m(R^*;J)\\,(1 - E^*) - k_{E,\\mathrm{off}}\\,E^* = 0 \\quad (2)\n$$\n\n这些方程定义了系统的零斜线。$R$-零斜线是 $\\frac{dR}{dt}=0$ 的曲线，$E$-零斜线是 $\\frac{dE}{dt}=0$ 的曲线。不动点是这两条零斜线在 $(R, E)$ 相空间中的交点。\n\n从方程 (1)，我们可以将 $R^*$ 表示为 $E^*$ 的函数：\n$$\nR^* = N_R(E^*) = \\frac{k_{R,\\mathrm{on}} \\left(\\alpha + \\beta \\, H_n(E^*;K)\\right)}{k_{R,\\mathrm{on}} \\left(\\alpha + \\beta \\, H_n(E^*;K)\\right) + k_{R,\\mathrm{off}}}\n$$\n从方程 (2)，我们可以将 $E^*$ 表示为 $R^*$ 的函数：\n$$\nE^* = N_E(R^*) = \\frac{k_{E,\\mathrm{on}} \\, H_m(R^*;J)}{k_{E,\\mathrm{on}} \\, H_m(R^*;J) + k_{E,\\mathrm{off}}}\n$$\n将 $R^* = N_R(E^*)$ 代入第二个表达式，得到一个只含单一变量 $E^*$ 的方程：\n$$\nE^* = N_E(N_R(E^*))\n$$\n函数 $g(E) = N_E(N_R(E)) - E = 0$ 在区间 $[0,1]$ 内的根提供了所有不动点的 $E$ 坐标。对于每个根 $E^*$，相应的 $R$ 坐标通过 $R^* = N_R(E^*)$ 求得。\n\n不动点 $(R^*, E^*)$ 的稳定性是通过在该点附近对系统进行线性化来确定的。我们考虑一个微小扰动 $\\mathbf{u} = [R-R^*, E-E^*]^T$。扰动的动力学由在不动点处计算的雅可比矩阵 $\\mathbf{J}$ 控制：$\\frac{d\\mathbf{u}}{dt} = \\mathbf{J} \\mathbf{u}$，其中\n$$\n\\mathbf{J} =\n\\begin{pmatrix}\n\\frac{\\partial F_R}{\\partial R} & \\frac{\\partial F_R}{\\partial E} \\\\\n\\frac{\\partial F_E}{\\partial R} & \\frac{\\partial F_E}{\\partial E}\n\\end{pmatrix}_{(R^*, E^*)}\n$$\n当且仅当 $\\mathbf{J}$ 的所有特征值都具有负实部时，不动点是渐近稳定的。对于一个 $2 \\times 2$ 矩阵，Routh-Hurwitz 稳定性判据提供了充要条件：\n1.  $\\mathrm{Tr}(\\mathbf{J}) = \\frac{\\partial F_R}{\\partial R} + \\frac{\\partial F_E}{\\partial E} < 0$\n2.  $\\det(\\mathbf{J}) = \\frac{\\partial F_R}{\\partial R} \\frac{\\partial F_E}{\\partial E} - \\frac{\\partial F_R}{\\partial E} \\frac{\\partial F_E}{\\partial R} > 0$\n\n让我们计算雅可比矩阵的元素。\n$\\frac{\\partial F_R}{\\partial R} = -k_{R,\\mathrm{on}} (\\alpha + \\beta H_n(E;K)) - k_{R,\\mathrm{off}}$。利用方程 (1)，在不动点处可简化为 $J_{11} = -\\frac{k_{R,\\mathrm{off}}}{1-R^*}$。\n$\\frac{\\partial F_E}{\\partial E} = -k_{E,\\mathrm{on}} H_m(R;J) - k_{E,\\mathrm{off}}$。利用方程 (2)，可简化为 $J_{22} = -\\frac{k_{E,\\mathrm{off}}}{1-E^*}$。\n由于所有参数均为正，且不动点必须位于 $[0,1)^2$ 内（当 $k_{R,\\mathrm{off}}=0$ 或 $k_{E,\\mathrm{off}}=0$ 时，才可能存在 $R=1$ 或 $E=1$ 的不动点），$J_{11}$ 和 $J_{22}$ 都是严格为负的。因此，$\\mathrm{Tr}(\\mathbf{J}) = J_{11} + J_{22}$ 总是为负。\n\n因此，任何不动点的稳定性完全由雅可比矩阵行列式的符号决定：\n-   若 $\\det(\\mathbf{J}) > 0$，不动点是渐近稳定的。\n-   若 $\\det(\\mathbf{J}) < 0$，不动点是不稳定的（由于 $\\mathrm{Tr}(\\mathbf{J}) < 0$，它是一个鞍点）。\n\n非对角项为：\n$J_{12} = \\frac{\\partial F_R}{\\partial E} = k_{R,\\mathrm{on}} \\beta (1-R^*) \\frac{d H_n(E;K)}{dE} \\Big|_{E=E^*}$\n$J_{21} = \\frac{\\partial F_E}{\\partial R} = k_{E,\\mathrm{on}}(1-E^*) \\frac{d H_m(R;J)}{dR} \\Big|_{R=R^*}$\n其中希尔函数的导数为 $\\frac{dH_p(x;C)}{dx} = \\frac{p C^p x^{p-1}}{(C^p+x^p)^2} \\ge 0$。\n$J_{11}J_{22}$ 项总是正的。$J_{12}J_{21}$ 项代表正反馈回路的强度，是非负的。当正反馈项足够强，以至于克服了自阻尼的对角项，使得 $\\det(\\mathbf{J})$ 为负时，就会出现不稳定性。\n\n**双稳态的计算判据：** 如果存在至少两个不同的不动点 $(R_1^*, E_1^*)$ 和 $(R_2^*, E_2^*)$，其雅可比矩阵行列式 $\\det(\\mathbf{J})$ 均为正，则系统是双稳态的。这意味着它们之间至少由一个 $\\det(\\mathbf{J}) < 0$ 的不稳定不动点分隔。\n\n**2. 算法步骤**\n\n上述推导自然地引出了以下鲁棒的计算步骤：\n1.  **定义函数**：实现零斜线函数 $R = N_R(E)$ 和 $E = N_E(R)$，以及用于求根的复合函数 $g(E) = N_E(N_R(E)) - E$。\n2.  **寻找不动点**：\n    a. 在区间 $[0,1]$ 上为 $E$ 创建一个精细、均匀的网格点。\n    b. 在每个网格点上计算 $g(E)$ 的值。识别出所有 $g(E)$ 变号的相邻点对，这表明在该子区间内存在一个根。\n    c. 对于每个这样的子区间，使用数值求根算法（例如 Brent 方法）来找到精确的根 $E^*$。\n    d. 对于每个根 $E^*$，使用 $R^*=N_R(E^*)$ 计算相应的 $R^*$。收集所有唯一的不动点 $(R^*, E^*)$。\n3.  **分类不動點**：\n    a. 对于每个找到的不动点 $(R^*, E^*)$，计算雅可比矩阵 $\\mathbf{J}$ 的四个元素。\n    b. 计算行列式 $\\det(\\mathbf{J}) = J_{11}J_{22} - J_{12}J_{21}$。\n    c. 如果 $\\det(\\mathbf{J}) > 0$，将该不动点分类为稳定。\n4.  **统计稳定点数量**：将被分类为稳定的不动点数量相加。这个整数是给定参数集的最终结果。\n\n以下程序实现了此步骤，以求解所提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code that follows the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef count_stable_fixed_points(alpha, beta, n, m, K, J, k_R_on, k_R_off, k_E_on, k_E_off):\n    \"\"\"\n    Calculates the number of stable fixed points for the given parameter set.\n\n    The algorithm is based on finding the roots of a composite function representing\n    the fixed-point condition and then classifying each fixed point using linear\n    stability analysis via the Jacobian matrix.\n    \"\"\"\n\n    # 1. Define helper functions based on the model equations.\n    def H(x, h_coeff, h_sat):\n        \"\"\"Numerically stable Hill function.\"\"\"\n        if x == 0.0:\n            return 0.0\n        # For large exponents, this could be unstable, but test cases are fine.\n        x_n = x**h_coeff\n        K_n = h_sat**h_coeff\n        return x_n / (K_n + x_n)\n\n    # R-nullcline: R = N_R(E)\n    def N_R(E):\n        \"\"\"Calculates R at equilibrium for a given E.\"\"\"\n        S_E = alpha + beta * H(E, n, K)\n        return (k_R_on * S_E) / (k_R_on * S_E + k_R_off)\n\n    # E-nullcline: E = N_E(R)\n    def N_E(R):\n        \"\"\"Calculates E at equilibrium for a given R.\"\"\"\n        H_R = H(R, m, J)\n        return (k_E_on * H_R) / (k_E_on * H_R + k_E_off)\n\n    # 2. Define the function g(E) = N_E(N_R(E)) - E for root-finding.\n    def g(E):\n        \"\"\"The function whose roots are the E-coordinates of the fixed points.\"\"\"\n        if E < 0.0 or E > 1.0:\n            return 1e12  # Out of bounds\n        return N_E(N_R(E)) - E\n\n    # 3. Find all roots of g(E) = 0 in [0, 1].\n    fixed_points = []\n    num_grid_points = 10000\n    E_grid = np.linspace(0.0, 1.0, num_grid_points)\n    \n    # Scan for roots within intervals by checking for sign changes.\n    for i in range(num_grid_points - 1):\n        e1, e2 = E_grid[i], E_grid[i+1]\n        try:\n            # Check for sign change\n            if g(e1) * g(e2) < 0:\n                E_root = brentq(g, e1, e2)\n                R_root = N_R(E_root)\n\n                # Ensure the point is physically valid and unique.\n                if 0.0 <= R_root <= 1.0 and 0.0 <= E_root <= 1.0:\n                    is_new = all(not np.isclose(E_root, fp[1], atol=1e-8) for fp in fixed_points)\n                    if is_new:\n                        fixed_points.append((R_root, E_root))\n        except (ValueError, RuntimeError):\n            # brentq might fail if g doesn't change sign or is ill-behaved. Ignore.\n            continue\n    \n    # 4. Classify each fixed point using the Jacobian determinant.\n    stable_fp_count = 0\n    for R_star, E_star in fixed_points:\n        # A fixed point at the boundary R=1 or E=1 is not possible for k > 0.\n        # This check is for numerical robustness.\n        if np.isclose(R_star, 1.0) or np.isclose(E_star, 1.0):\n            continue\n\n        # Derivative of the Hill function\n        def dH_dx(x, h_coeff, h_sat):\n            if x == 0.0:\n                if h_coeff > 1: return 0.0\n                if h_coeff == 1: return 1.0 / h_sat\n                return np.inf  # Not expected for n, m >= 1\n            \n            x_h_minus_1 = x**(h_coeff - 1)\n            x_h = x_h_minus_1 * x\n            K_h = h_sat**h_coeff\n            return h_coeff * K_h * x_h_minus_1 / ((K_h + x_h)**2)\n\n        # Jacobian elements evaluated at the fixed point (R*, E*)\n        J11 = -k_R_off / (1.0 - R_star)\n        \n        dH_dE = dH_dx(E_star, n, K)\n        J12 = k_R_on * beta * (1.0 - R_star) * dH_dE\n        \n        dH_dR = dH_dx(R_star, m, J)\n        J21 = k_E_on * (1.0 - E_star) * dH_dR\n\n        J22 = -k_E_off / (1.0 - E_star)\n\n        # As proven, Tr(J) is always negative. Stability depends on det(J).\n        if (J11 * J22 - J12 * J21) > 0:\n            stable_fp_count += 1\n            \n    return stable_fp_count\n\ndef solve():\n    \"\"\"Main function to solve the problem for all specified test cases.\"\"\"\n    \n    test_cases = [\n        # Test A: no feedback, monostability expected\n        {'alpha': 0.05, 'beta': 0.0, 'n': 4, 'm': 4, 'K': 0.4, 'J': 0.3,\n         'k_R_on': 5.0, 'k_R_off': 1.0, 'k_E_on': 5.0, 'k_E_off': 1.0},\n        # Test B: weak feedback, no ultrasensitivity, monostability expected\n        {'alpha': 0.05, 'beta': 0.2, 'n': 1, 'm': 1, 'K': 0.5, 'J': 0.5,\n         'k_R_on': 5.0, 'k_R_off': 1.0, 'k_E_on': 5.0, 'k_E_off': 1.0},\n        # Test C: strong feedback, ultrasensitivity, bistability expected\n        {'alpha': 0.01, 'beta': 1.2, 'n': 6, 'm': 6, 'K': 0.3, 'J': 0.2,\n         'k_R_on': 8.0, 'k_R_off': 1.0, 'k_E_on': 8.0, 'k_E_off': 1.0},\n        # Test D: strong deactivation, monostability expected\n        {'alpha': 0.01, 'beta': 1.2, 'n': 6, 'm': 6, 'K': 0.3, 'J': 0.2,\n         'k_R_on': 8.0, 'k_R_off': 4.0, 'k_E_on': 8.0, 'k_E_off': 4.0},\n        # Test E: high basal input, monostability expected\n        {'alpha': 0.6, 'beta': 0.8, 'n': 2, 'm': 2, 'K': 0.8, 'J': 0.8,\n         'k_R_on': 5.0, 'k_R_off': 1.0, 'k_E_on': 5.0, 'k_E_off': 1.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        count = count_stable_fixed_points(**params)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "2961630"}, {"introduction": "理论模型虽然强大，但只有与实验数据相结合才能充分体现其价值。最后的这个实践练习通过分析剂量-响应数据集，将理论与实验联系起来，这是细胞生物学和药理学中的一项常见任务。你将把一个定量模型与 ERK 磷酸化水平的测量数据进行拟合，从而提取关键参数，如半数有效浓度 ($EC_{50}$)，并评估参数估计的不确定性，进而掌握解读实验结果的一项关键技能 [@problem_id:2961642]。", "problem": "您正在研究表皮生长因子（EGF）激活的Ras-丝裂原活化蛋白激酶（Ras-MAPK）信号级联，通过测量稳态下磷酸化的细胞外信号调节激酶（ERK）的分数随细胞外配体浓度的变化。假设以下常规用于受体介导的协同激活信号传导的基础理论：(i) 受体-配体结合遵循质量作用定律，(ii) 稳态下的信号输出是被占据或激活的受体分数及其下游协同步骤的单调函数，以及 (iii) 不同剂量下的测量噪声是独立同分布的、方差恒定的高斯噪声。在这些假设下，一个与活化的Ras分数及随后的ERK磷酸化相符的协同激活模型，使用一个具有四个参数的饱和、单调且协同的函数，将配体浓度 $c$ 映射到响应 $y(c)$：基础响应 $B$（无量纲分数）、最大响应 $T$（无量纲分数）、半最大效应浓度 $EC_{50}$（单位为nM）和希尔系数 $n$（无量纲，$n>0$）。参数 $EC_{50}$ 定义为响应值介于 $B$ 和 $T$ 中间点时的浓度 $c$。在高斯噪声下的非线性回归意味着参数的最大似然估计会最小化残差平方和。\n\n任务：对于下方的每个数据集，使用非线性最小二乘法，将一个与要点(i)–(iii)一致且参数为 $(B,T,EC_{50},n)$ 的协同激活模型拟合到所提供的剂量-响应数据。然后，利用参数估计的渐近正态近似，从估计的参数协方差中计算 $EC_{50}$ 的双侧 $0.95$ 置信区间（使用自由度等于数据点数减去参数个数的学生t分布分位数）。最终结果必须以纳摩尔（nM）为单位报告。\n\n数据集（每个响应都是稳态下磷酸化的ERK分数，无量纲）：\n\n- 数据集A（EGF在典型上皮细胞系中；具有广泛覆盖的“理想情况”）\n  - 浓度（nM）：$0$, $0.1$, $0.3$, $1$, $3$, $10$, $30$。\n  - 响应（无量纲）：$0.050$, $0.077$, $0.130$, $0.328$, $0.605$, $0.843$, $0.911$。\n\n- 数据集B（在Ras依赖性背景下的神经生长因子样协同机制）\n  - 浓度（nM）：$0$, $0.01$, $0.03$, $0.1$, $0.3$, $1$, $3$, $10$。\n  - 响应（无量纲）：$0.020$, $0.0208$, $0.0272$, $0.096$, $0.380$, $0.694$, $0.739$, $0.743$。\n\n- 数据集C（剂量敏感性较浅的突变体；在测试范围内未完全饱和）\n  - 浓度（nM）：$0$, $1$, $3$, $10$, $30$, $100$。\n  - 响应（无量纲）：$0.100$, $0.157$, $0.203$, $0.295$, $0.382$, $0.484$。\n\n- 数据集D（接近零的基础响应；更宽的动态范围和更高的 $EC_{50}$）\n  - 浓度（nM）：$0$, $5$, $10$, $30$, $50$, $100$, $300$。\n  - 响应（无量纲）：$0.000$, $0.033$, $0.086$, $0.314$, $0.503$, $0.743$, $0.930$。\n\n拟合的要求和约束：\n- 使用一个四参数协同激活模型，其参数为 $(B,T,EC_{50},n)$，满足 $0 \\le B \\le T \\le 1$，$EC_{50} > 0$（单位为nM），以及 $n \\in (0,5]$。\n- 使用非线性最小二乘法同时估计所有四个参数。\n- 使用基于雅可比矩阵的参数估计的渐近协方差来计算 $EC_{50}$ 的标准误，并使用自由度为 $N-4$（其中 $N$ 是数据集中的数据点数）的学生t分位数构建双侧 $0.95$ 置信区间。\n- 将 $EC_{50}$ 及其置信区间界限以nM为单位表示为浮点数。\n- 将所有报告的数值输出四舍五入到4位有效数字。\n\n测试套件和预期输出：\n- 程序必须将所有四个数据集A–D作为一个固定的测试套件进行处理。\n- 对每个数据集，计算并返回一个包含估计的 $EC_{50}$（单位为nM）及其双侧 $0.95$ 置信区间的下界和上界（单位为nM）的三元组，每个值都四舍五入到4位有效数字。\n- 您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表，每个数据集的三元组都包含在自己的方括号中，并按 $[A,B,C,D]$ 的顺序排列。例如，格式必须严格如下：$[[a\\_1,a\\_2,a\\_3],[b\\_1,b\\_2,b\\_3],[c\\_1,c\\_2,c\\_3],[d\\_1,d\\_2,d\\_3]]$，其中每个 $a\\_i$、$b\\_i$、$c\\_i$、$d\\_i$ 是一个以nM为单位、四舍五入到4位有效数字的浮点数。不得打印任何额外文本。", "solution": "我们使用第一性原理，将Ras-丝裂原活化蛋白激酶（Ras-MAPK）级联的生物学机制与一个协同剂量-响应模型联系起来。受体-配体相互作用受质量作用定律支配：已占据受体的分数随配体浓度 $c$ 单调增加。Ras-MAPK中的下游招募和激活步骤可以表现出协同性，从而有效地产生一个通过带有指数 $n$ 的S型变换依赖于 $c$ 的响应。在稳态下，与这些原理一致的一个最小且广泛使用的映射是一个饱和的、单调的函数，其参数包括基础活性 $B$、最大活性 $T$、半最大浓度 $EC_{50}$ 和控制表观协同性的希尔系数 $n$。半最大效应浓度 $EC_{50}$ 由响应值恰好在 $B$ 和 $T$ 中间点的条件定义。\n\n从统计学的角度来看，假设在不同浓度下的噪声是独立同分布的、方差恒定的高斯噪声；那么，参数的最大似然估计会使残差平方和最小化。因此，非线性最小二乘法是一种合适的估计方法。设模型表示为\n$$\ny(c; \\theta) \\equiv B + (T - B)\\,\\frac{c^{n}}{EC_{50}^{n} + c^{n}},\n$$\n参数向量为 $\\theta = (B, T, EC_{50}, n)$。约束条件 $0 \\le B \\le T \\le 1$、$EC_{50} > 0$ 和 $n \\in (0,5]$ 强制了生物学现实性（响应是分数，浓度是正数，协同性是有限的正数）。\n\n给定数据 $\\{(c_i, y_i)\\}_{i=1}^{N}$，非线性最小二乘估计器求解\n$$\n\\hat{\\theta} = \\arg\\min_{\\theta} \\sum_{i=1}^{N} \\left[y_i - y(c_i;\\theta)\\right]^2.\n$$\n在标准的正则性条件下，$\\hat{\\theta}$ 是渐近正态的，其协方差可以通过观测到的Fisher信息的逆来近似。Gauss–Newton近似法得出\n$$\n\\widehat{\\mathrm{Cov}}(\\hat{\\theta}) \\approx s^2 \\left(J^\\top J\\right)^{-1},\n$$\n其中 $J$ 是雅可比矩阵，其元素为\n$$\nJ_{i,k} = \\frac{\\partial y(c_i;\\theta)}{\\partial \\theta_k}\\Bigg|_{\\theta=\\hat{\\theta}},\n$$\n并且 $s^2$ 是残差方差估计量\n$$\ns^2 = \\frac{1}{N - p} \\sum_{i=1}^{N} \\left[y_i - y(c_i;\\hat{\\theta})\\right]^2,\n$$\n其中 $p=4$ 是参数的数量。许多非线性最小二乘法的软件实现，包括信赖域反射算法，会计算 $\\left(J^\\top J\\right)^{-1}$ 的估计值，并用 $s^2$ 对其进行缩放，以生成参数协方差矩阵的估计。\n\n要计算 $EC_{50}$ 的双侧 $0.95$ 置信区间，需从协方差矩阵中提取 $EC_{50}$ 分量的方差估计 $\\widehat{\\mathrm{Var}}(\\widehat{EC_{50}})$，即对应的对角线元素。标准误为\n$$\n\\mathrm{SE}(\\widehat{EC_{50}}) = \\sqrt{\\widehat{\\mathrm{Var}}(\\widehat{EC_{50}})}.\n$$\n当自由度为 $\\nu = N - p$ 时，置信水平为 $0.95$ 的双侧置信区间为\n$$\n\\widehat{EC_{50}} \\pm t_{1 - \\alpha/2,\\,\\nu}\\ \\mathrm{SE}(\\widehat{EC_{50}}),\n$$\n其中 $\\alpha = 1 - 0.95 = 0.05$，而 $t_{1 - \\alpha/2,\\,\\nu}$ 是自由度为 $\\nu$ 的学生t分布的 $(1 - \\alpha/2)$ 分位数。\n\n每个数据集的算法计划：\n1. 组装浓度 $c_i$（单位为nM）和响应 $y_i$（无量纲）的向量。\n2. 通过带有边界约束 $0 \\le B \\le 1$、$0 \\le T \\le 1$、$EC_{50} \\in (0, \\infty)$ 和 $n \\in (0,5]$ 的非线性最小二乘法拟合四参数模型 $y(c;\\theta)$。一个有效的初始化是：$B$ 为观测到的最小响应，$T$ 为观测到的最大响应，$EC_{50}$ 为正浓度的中位数，$n$ 为 $1$。\n3. 获取基于雅可比矩阵的参数协方差矩阵，并计算 $\\widehat{EC_{50}}$ 的标准误。\n4. 在自由度为 $\\nu = N - 4$ 的情况下，计算 $t_{1 - 0.025,\\,\\nu}$ 并构建 $EC_{50}$ 的双侧 $0.95$ 置信区间。\n5. 将点估计和区间界限以nM为单位表示，并将每个值四舍五入到4位有效数字。\n6. 按 $[A,B,C,D]$ 的顺序，使用格式 $[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3],[d_1,d_2,d_3]]$ 输出单行结果，其中对每个数据集，三元组为 $[\\widehat{EC_{50}}, \\mathrm{CI}_{\\mathrm{low}}, \\mathrm{CI}_{\\mathrm{high}}]$。\n\n所提供的数据集涵盖了对Ras-MAPK信号推断至关重要的互补机制：具有良好动态范围的典型S型响应、具有亚纳摩尔级灵敏度的高度协同机制、挑战模型可辨识性的斜率平缓且不完全饱和的情况，以及跨越两个数量级浓度的近零基础响应机制。带有边界约束的非线性回归和渐近协方差计算共同产生了具有科学意义的 $EC_{50}$ 估计值及其置信区间，所有单位均为纳摩尔，适用于比较不同条件下的信号传导灵敏度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.stats import t as student_t\n\ndef hill_response(c, B, T, EC50, n):\n    # Cooperative activation model, c in nM, responses unitless\n    # Ensure safe power for zero concentration: c**n is 0 when c=0 and n>0\n    return B + (T - B) * (np.power(c, n)) / (np.power(EC50, n) + np.power(c, n))\n\ndef fit_hill_and_ci(c, y):\n    c = np.asarray(c, dtype=float)\n    y = np.asarray(y, dtype=float)\n\n    # Initial guesses\n    B0 = float(np.clip(np.min(y), 0.0, 1.0))\n    T0 = float(np.clip(np.max(y), 0.0, 1.0))\n    # Avoid EC50 initialization at 0 due to zero concentrations; use median of positive concentrations\n    positive_c = c[c > 0]\n    EC500 = float(np.median(positive_c)) if positive_c.size > 0 else 1.0\n    n0 = 1.0\n\n    p0 = [B0, T0, EC500, n0]\n\n    # Bounds: 0 = B = 1, 0 = T = 1, EC50 in (1e-12, 1e9], n in (1e-6, 5]\n    # Also enforce B = T by using independent bounds and relying on optimizer; data typically ensure B<=T.\n    lower_bounds = [0.0, 0.0, 1e-12, 1e-6]\n    upper_bounds = [1.0, 1.0, 1e9, 5.0]\n\n    # Fit\n    popt, pcov = curve_fit(\n        hill_response, c, y,\n        p0=p0, bounds=(lower_bounds, upper_bounds),\n        method='trf', max_nfev=10000\n    )\n\n    # Degrees of freedom\n    N = y.size\n    p = 4\n    dof = max(N - p, 1)\n\n    # curve_fit with absolute_sigma=False scales pcov by reduced chi^2 internally,\n    # but we will keep it as provided (already scaled) for standard errors.\n    # Extract standard error for EC50\n    se = np.sqrt(np.diag(pcov))\n    se_ec50 = float(se[2])\n\n    ec50_hat = float(popt[2])\n\n    # Two-sided 95% CI using Student t\n    alpha = 0.05\n    tcrit = float(student_t.ppf(1 - alpha/2.0, dof))\n    ci_low = ec50_hat - tcrit * se_ec50\n    ci_high = ec50_hat + tcrit * se_ec50\n\n    # Enforce positivity for CI bounds (biologically EC50 > 0)\n    ci_low = max(ci_low, 0.0)\n\n    return ec50_hat, ci_low, ci_high\n\ndef round_sig(x, sig=4):\n    if x == 0 or not np.isfinite(x):\n        return \"0\"\n    # Use general format with specified significant digits\n    return f\"{x:.{sig}g}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Dataset A\n    c_A = np.array([0.0, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0], dtype=float)\n    y_A = np.array([0.050, 0.077, 0.130, 0.328, 0.605, 0.843, 0.911], dtype=float)\n\n    # Dataset B\n    c_B = np.array([0.0, 0.01, 0.03, 0.1, 0.3, 1.0, 3.0, 10.0], dtype=float)\n    y_B = np.array([0.020, 0.0208, 0.0272, 0.096, 0.380, 0.694, 0.739, 0.743], dtype=float)\n\n    # Dataset C\n    c_C = np.array([0.0, 1.0, 3.0, 10.0, 30.0, 100.0], dtype=float)\n    y_C = np.array([0.100, 0.157, 0.203, 0.295, 0.382, 0.484], dtype=float)\n\n    # Dataset D\n    c_D = np.array([0.0, 5.0, 10.0, 30.0, 50.0, 100.0, 300.0], dtype=float)\n    y_D = np.array([0.000, 0.033, 0.086, 0.314, 0.503, 0.743, 0.930], dtype=float)\n\n    test_cases = [\n        (c_A, y_A),\n        (c_B, y_B),\n        (c_C, y_C),\n        (c_D, y_D),\n    ]\n\n    results = []\n    for c, y in test_cases:\n        ec50_hat, ci_low, ci_high = fit_hill_and_ci(c, y)\n        # Round to 4 significant figures as strings\n        results.append([round_sig(ec50_hat, 4), round_sig(ci_low, 4), round_sig(ci_high, 4)])\n\n    # Final print statement in the exact required format.\n    # Ensure single-line, nested list with comma-separated values.\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(map(str, triple)) + \"]\" for triple in results) + \"]\"\n    print(formatted)\n\nsolve()\n```", "id": "2961642"}]}