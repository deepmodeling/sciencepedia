{"hands_on_practices": [{"introduction": "经典钙黏蛋白的黏附功能关键取决于其胞外域能否形成刚性的杆状构象。这种刚性是通过钙离子 ($Ca^{2+}$) 与EC结构域之间连接区域的结合来维持的。本练习旨在通过一项定量计算，让您基于化学平衡的基本原理，计算在包含 $Ca^{2+}$ 螯合剂的生物学相关场景中，这些关键钙离子结合位点的占据分数，从而为您奠定坚实的理论基础 ([@problem_id:2936361])。", "problem": "经典钙粘蛋白需要在相邻的细胞外钙粘蛋白 (EC) 重复序列之间的保守连接区位点结合细胞外钙离子 ($\\mathrm{Ca}^{2+}$)，以形成刚性的、具有粘附能力的构象。考虑一个 EC1–EC2 连接区，其上有三个不同的 $\\mathrm{Ca}^{2+}$ 结合位点，每个位点都遵循质量作用定律并独立结合。$\\mathrm{Ca}^{2+}$ 在这三个位点上的解离常数分别为 $K_{d,1} = 0.3\\,\\mathrm{mM}$、$K_{d,2} = 0.8\\,\\mathrm{mM}$ 和 $K_{d,3} = 1.5\\,\\mathrm{mM}$。一个细胞浸泡在一种缓冲细胞外溶液中，该溶液含有总钙浓度 $C_T = 2.0\\,\\mathrm{mM}$ 和螯合剂乙二醇-双(β-氨基乙基醚)-N,N,N',N'-四乙酸 (EGTA)，其总浓度为 $E_T = 1.5\\,\\mathrm{mM}$。在实验条件下，$\\mathrm{Ca}^{2+}$–EGTA 复合物的解离常数为 $K_{d,\\mathrm{EGTA}} = 2.0 \\times 10^{-4}\\,\\mathrm{mM}$。钙粘蛋白的浓度足够低，其对 $\\mathrm{Ca}^{2+}$ 的结合不会可测量地消耗游离 $\\mathrm{Ca}^{2+}$ 库。\n\n从 $\\mathrm{Ca}^{2+}$–EGTA 平衡的质量作用定律和质量守恒，以及配体与单个位点结合的解离常数定义出发，确定在平衡状态下三个 EC 连接区位点中被 $\\mathrm{Ca}^{2+}$ 占据的比例 $f$。最终答案以无单位小数表示，并四舍五入到四位有效数字。", "solution": "目标是计算在平衡状态下三个 EC 连接区位点中被 $\\mathrm{Ca}^{2+}$ 占据的无单位比例 $f$。计算分两个阶段进行：(i) 使用质量作用定律和质量守恒，确定在存在乙二醇-双(β-氨基乙基醚)-N,N,N',N'-四乙酸 (EGTA) 的情况下的游离钙浓度 $[\\mathrm{Ca}^{2+}]_{\\mathrm{free}}$；(ii) 使用解离常数的定义，计算每个独立位点的占据比例，然后对三个位点进行平均。\n\n阶段 (i)：从 $\\mathrm{Ca}^{2+}$–EGTA 平衡中求游离钙。\n- 令 $c = [\\mathrm{Ca}^{2+}]_{\\mathrm{free}}$，$e = [\\mathrm{EGTA}]_{\\mathrm{free}}$，以及 $x = [\\mathrm{CaEGTA}]$。\n- 对于 $1{:}1$ 复合物，质量作用定律给出 $K_{d,\\mathrm{EGTA}} = \\dfrac{c\\,e}{x}$。\n- 质量守恒给出 $C_T = c + x$ 和 $E_T = e + x$，其中 $C_T$ 和 $E_T$ 分别是总钙浓度和总 EGTA 浓度。\n\n使用 $e = E_T - x$ 和 $x = C_T - c$ 消去 $e$：\n$$\nK_{d,\\mathrm{EGTA}} = \\frac{c\\,(E_T - x)}{x} = \\frac{c\\,[E_T - (C_T - c)]}{C_T - c} = \\frac{c\\,(E_T - C_T + c)}{C_T - c}.\n$$\n重新整理得到一个关于 $c$ 的二次方程：\n$$\nK_{d,\\mathrm{EGTA}}(C_T - c) = c\\,(E_T - C_T + c)\n\\;\\Longrightarrow\\;\nc^2 + c\\,(K_{d,\\mathrm{EGTA}} + E_T - C_T) - C_T K_{d,\\mathrm{EGTA}} = 0.\n$$\n当 $C_T = 2.0\\,\\mathrm{mM}$，$E_T = 1.5\\,\\mathrm{mM}$ 且 $K_{d,\\mathrm{EGTA}} = 2.0 \\times 10^{-4}\\,\\mathrm{mM}$ 时，物理上相关的（正）根是\n$$\nc = \\frac{ -\\big(K_{d,\\mathrm{EGTA}} + E_T - C_T\\big) + \\sqrt{\\big(K_{d,\\mathrm{EGTA}} + E_T - C_T\\big)^2 + 4 C_T K_{d,\\mathrm{EGTA}}} }{2}.\n$$\n数值计算如下：\n$$\nK_{d,\\mathrm{EGTA}} + E_T - C_T = 2.0\\times 10^{-4} - 0.5 = -0.4998,\n$$\n$$\n\\sqrt{(-0.4998)^2 + 4(2.0)(2.0\\times 10^{-4})} = \\sqrt{0.25140004} \\approx 0.501398085,\n$$\n所以\n$$\nc \\approx \\frac{0.4998 + 0.501398085}{2} \\approx 0.5005990425\\ \\text{mM}.\n$$\n\n阶段 (ii)：独立位点的占据比例。\n对于单个结合位点 $R + \\mathrm{Ca}^{2+} \\rightleftharpoons R\\mathrm{Ca}$，其解离常数为 $K_{d,i} = \\dfrac{[R][\\mathrm{Ca}^{2+}]}{[R\\mathrm{Ca}]}$，则其占据比例为\n$$\n\\theta_i \\equiv \\frac{[R\\mathrm{Ca}]}{[R] + [R\\mathrm{Ca}]} = \\frac{[\\mathrm{Ca}^{2+}]_{\\mathrm{free}}}{[\\mathrm{Ca}^{2+}]_{\\mathrm{free}} + K_{d,i}}.\n$$\n使用 $[\\mathrm{Ca}^{2+}]_{\\mathrm{free}} = c \\approx 0.5005990425\\,\\mathrm{mM}$：\n- 对于 $K_{d,1} = 0.3\\,\\mathrm{mM}$，\n$$\n\\theta_1 = \\frac{0.5005990425}{0.5005990425 + 0.3} = \\frac{0.5005990425}{0.8005990425} \\approx 0.625280563.\n$$\n- 对于 $K_{d,2} = 0.8\\,\\mathrm{mM}$，\n$$\n\\theta_2 = \\frac{0.5005990425}{0.5005990425 + 0.8} = \\frac{0.5005990425}{1.3005990425} \\approx 0.384898845.\n$$\n- 对于 $K_{d,3} = 1.5\\,\\mathrm{mM}$，\n$$\n\\theta_3 = \\frac{0.5005990425}{0.5005990425 + 1.5} = \\frac{0.5005990425}{2.0005990425} \\approx 0.250224495.\n$$\n\n三个位点中被占据的比例 $f$ 是这些独立位点的平均占据率：\n$$\nf = \\frac{\\theta_1 + \\theta_2 + \\theta_3}{3} \\approx \\frac{0.625280563 + 0.384898845 + 0.250224495}{3} \\approx 0.4201346343.\n$$\n\n四舍五入到四位有效数字，该无单位比例为 $0.4201$。", "answer": "$$\\boxed{0.4201}$$", "id": "2936361"}, {"introduction": "黏附连接是动态的力敏结构，持续承受着由动蛋白肌球蛋白细胞骨架产生的拉伸力。理解单个钙黏蛋白反式二聚体 (`trans` bond) 如何响应力，是理解组织力学的核心。本练习将深入单分子生物物理学的核心，应用经典的贝尔-埃文斯 (Bell-Evans) 模型来预测在特定拉伸载荷下，单个钙黏蛋白分子键的寿命会如何变化 ([@problem_id:2936405])。", "problem": "一个位于相对细胞间的上皮钙粘蛋白（E-cadherin）单反式键被置于恒定的拉伸力钳下。使用过渡态理论将解离过程建模为越过单个热激活能垒的逃逸过程，其中解离速率 $k_{\\mathrm{off}}$ 满足 $k_{\\mathrm{off}} \\propto \\exp\\!\\big(-\\Delta G^{\\ddagger}/(k_B T)\\big)$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。在零力时，能垒为 $\\Delta G^{\\ddagger}_0$，解离速率为 $k_0$。在与反应坐标对齐的恒定力 $F$ 作用下，能垒因机械功 $W=F x_b$ 而降低，其中 $x_b$ 是从结合态最小值到过渡态沿拉动坐标的投影距离。\n\n从这些前提出发，并根据泊松（无记忆）解离过程的平均寿命定义，推导出力依赖的平均寿命 $\\tau(F)$ 的表达式，该表达式应以 $k_0$、$F$、$x_b$、$k_B$ 和 $T$ 表示。然后，对于一个钙粘蛋白键，在零力解离速率 $k_0 = 0.020~\\mathrm{s}^{-1}$、能垒投影距离 $x_b = 0.50~\\mathrm{nm}$、力 $F = 25~\\mathrm{pN}$ 和温度 $T = 310~\\mathrm{K}$ 的条件下，对 $\\tau(F)$ 进行数值计算。使用玻尔兹曼常数 $k_B = 1.380649 \\times 10^{-23}~\\mathrm{J\\,K^{-1}}$。最终寿命以秒为单位表示，并将答案四舍五入到三位有效数字。", "solution": "力依赖的解离速率 $k_{\\mathrm{off}}(F)$ 已知与 $\\exp(-\\Delta G^{\\ddagger}(F)/(k_B T))$ 成正比，其中 $\\Delta G^{\\ddagger}(F)$ 是力依赖的活化能垒。设比例常数为 $A$。因此，\n$$k_{\\mathrm{off}}(F) = A \\exp\\left(-\\frac{\\Delta G^{\\ddagger}(F)}{k_B T}\\right)$$\n在零力（$F=0$）时，能垒为 $\\Delta G^{\\ddagger}(0) = \\Delta G^{\\ddagger}_0$，解离速率为 $k_0$。\n$$k_0 = A \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_0}{k_B T}\\right)$$\n由此，我们可以确定指前因子 $A = k_0 \\exp(\\Delta G^{\\ddagger}_0/(k_B T))$。\n\n在施加的拉伸力 $F$ 作用下，能垒降低的量等于将系统从结合态移动到过渡态所做的机械功。该功被给出为 $W = F x_b$。因此，新的力依赖能垒为：\n$$\\Delta G^{\\ddagger}(F) = \\Delta G^{\\ddagger}_0 - F x_b$$\n将此代入 $k_{\\mathrm{off}}(F)$ 的一般表达式中：\n$$k_{\\mathrm{off}}(F) = A \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_0 - F x_b}{k_B T}\\right)$$\n$$k_{\\mathrm{off}}(F) = A \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_0}{k_B T}\\right) \\exp\\left(\\frac{F x_b}{k_B T}\\right)$$\n认识到项 $A \\exp(-\\Delta G^{\\ddagger}_0 / (k_B T))$ 正是零力解离速率 $k_0$，我们得到贝尔模型方程：\n$$k_{\\mathrm{off}}(F) = k_0 \\exp\\left(\\frac{F x_b}{k_B T}\\right)$$\n问题指出解离是一个泊松过程。对于由恒定速率 $k$ 描述的无记忆过程，事件在时间 $t$ 之前未发生的概率是 $P(t) = \\exp(-kt)$。平均寿命 $\\tau$ 是寿命的期望值，由积分 $\\int_0^\\infty t (k \\exp(-kt)) dt = 1/k$ 给出。\n因此，平均寿命 $\\tau(F)$ 是力依赖解离速率 $k_{\\mathrm{off}}(F)$ 的倒数：\n$$\\tau(F) = \\frac{1}{k_{\\mathrm{off}}(F)}$$\n代入 $k_{\\mathrm{off}}(F)$ 的表达式，我们得到力依赖平均寿命的最终解析表达式：\n$$\\tau(F) = \\frac{1}{k_0} \\exp\\left(-\\frac{F x_b}{k_B T}\\right)$$\n推导到此结束。\n\n现在，我们必须使用所提供的数据对此表达式进行数值计算。为保持一致性，参数必须采用国际单位制基本单位。\n- $k_0 = 0.020~\\mathrm{s}^{-1}$\n- $F = 25~\\mathrm{pN} = 25 \\times 10^{-12}~\\mathrm{N}$\n- $x_b = 0.50~\\mathrm{nm} = 0.50 \\times 10^{-9}~\\mathrm{m}$\n- $T = 310~\\mathrm{K}$\n- $k_B = 1.380649 \\times 10^{-23}~\\mathrm{J\\,K^{-1}}$\n\n首先，我们计算无量纲指数 $\\frac{F x_b}{k_B T}$ 的值。\n分子中的机械功项是：\n$$F x_b = (25 \\times 10^{-12}~\\mathrm{N}) \\times (0.50 \\times 10^{-9}~\\mathrm{m}) = 1.25 \\times 10^{-20}~\\mathrm{N \\cdot m} = 1.25 \\times 10^{-20}~\\mathrm{J}$$\n分母中的热能项是：\n$$k_B T = (1.380649 \\times 10^{-23}~\\mathrm{J\\,K^{-1}}) \\times (310~\\mathrm{K}) \\approx 4.2799919 \\times 10^{-21}~\\mathrm{J}$$\n该比值为：\n$$\\frac{F x_b}{k_B T} \\approx \\frac{1.25 \\times 10^{-20}~\\mathrm{J}}{4.2799919 \\times 10^{-21}~\\mathrm{J}} \\approx 2.920565$$\n现在我们可以计算平均寿命 $\\tau(F)$：\n$$\\tau(F) = \\frac{1}{0.020~\\mathrm{s}^{-1}} \\exp(-2.920565) = 50~\\mathrm{s} \\times \\exp(-2.920565)$$\n$$\\exp(-2.920565) \\approx 0.053901$$\n$$\\tau(F) \\approx 50~\\mathrm{s} \\times 0.053901 \\approx 2.69505~\\mathrm{s}$$\n问题要求答案四舍五入到三位有效数字。\n$$\\tau(F) \\approx 2.70~\\mathrm{s}$$", "answer": "$$\\boxed{2.70}$$", "id": "2936405"}, {"introduction": "细胞的集体行为源于分子层面的相互作用。单个黏附连接上的张力如何转化为大规模的组织重塑，例如在发育过程中至关重要的细胞邻里交换？这项高级计算练习引入了顶点模型 (vertex model)——理论生物物理学中的一个强大框架——来模拟连接线张力和细胞面积弹性之间的相互作用如何驱动拓扑上的T1转换，从而搭建起从分子力到组织形态发生的桥梁 ([@problem_id:2936395])。", "problem": "您的任务是形式化一个最小顶点模型，用以表示由钙黏蛋白介导的连接线张力和细胞面积弹性主导的黏附连接力学，并预测哪些指定界面会发生拓扑变化。在上皮组织中，黏附连接处的上皮钙黏蛋白（E-cadherin）与肌动球蛋白皮层耦合，这可以通过一个线张力参数以粗粒化的方式进行建模。在顶点模型中，一个由顶点构成的细胞网络的能量被写为连接线张力项和细胞面积弹性项的总和。在本问题中，您将实现一个共享单个连接界面的、简化的但力学上一致的双细胞系统，并评估增加该界面上的张力是否足以驱动拓扑边塌陷，而拓扑边塌陷是邻居交换（即所谓的T1转变）的前兆。目标是将以下基本依据编码成一个可运行的程序，并在一个预定义的测试套件上进行计算。\n\n基本定义与假设：\n- 该系统包含两个共享一个单一笔直界面（“中央界面”）的多边形细胞，该界面由两个可移动顶点表示。两个固定的“侧向锚点”代表来自周围组织的力学约束。整个系统是平面的。\n- 总机械能为\n$$\nE = \\sum_{e \\in \\mathcal{E}} \\Lambda_e \\, L_e \\;+\\; \\sum_{i \\in \\mathcal{C}} \\frac{K}{2}\\,\\big(A_i - A_i^{(0)}\\big)^2,\n$$\n其中 $e$ 索引带有线张力 $\\Lambda_e$ 和长度 $L_e$ 的边，而 $i$ 索引面积为 $A_i$、目标面积为 $A_i^{(0)}$、面积弹性为 $K$ 的细胞。\n- 唯一可移动的自由度是形成共享界面的两个顶点；所有其他顶点都是固定的。目标面积 $A_i^{(0)}$ 被设定为 $t=0$ 时的初始面积。\n- 拓扑变化预测的操作性定义如下：在相对于两个可移动顶点最小化 $E$ 后，如果共享界面的优化后长度小于或等于一个小的阈值 $\\ell_{\\min}$，则预测该界面会塌陷，并预期发生T1邻居交换；否则，预测不会塌陷。您必须在无量纲单位下使用 $\\ell_{\\min} = 10^{-3}$。\n\n需要实现的几何形状和参数：\n- 固定的锚点顶点为 $L=(-1,0)$ 和 $R=(1,0)$。\n- 两个可移动顶点初始放置在 $v_1=(0,-0.2)$ 和 $v_2=(0,0.2)$，形成初始长度为 $L_{\\mathrm{central}}(0)=0.4$ 的共享“中央”界面。\n- 两个细胞以逆时针顶点顺序定义：\n  - 左细胞：多边形 $[L, v_1, v_2]$。\n  - 右细胞：多边形 $[R, v_2, v_1]$。\n- 边集 $\\mathcal{E}$ 包含以下无向边：中央界面 $(v_1,v_2)$ 和四条“侧向”边 $(v_1,L)$, $(v_2,L)$, $(v_1,R)$, $(v_2,R)$。在最小化过程中，固定的锚点不移动。\n- 非中央边上的线张力是统一的：边 $(v_1,L)$, $(v_2,L)$, $(v_1,R)$, $(v_2,R)$ 的线张力为 $\\Lambda_{\\mathrm{other}}$。中央界面的线张力为 $\\Lambda_{\\mathrm{central}}$，它可以高于 $\\Lambda_{\\mathrm{other}}$ 以编码该特定界面上的连接张力增加。\n- 目标面积 $A_i^{(0)}$ 被设定为每个细胞在 $t=0$ 时的初始面积，即 $A_{\\mathrm{left}}^{(0)}=A_{\\mathrm{left}}(0)$ 和 $A_{\\mathrm{right}}^{(0)}=A_{\\mathrm{right}}(0)$。\n\n需要实现的最小化协议：\n- 使用带回溯线搜索的梯度下降法，相对于 $v_1$ 和 $v_2$ 的坐标来最小化 $E$，并保持 $L$ 和 $R$ 固定。梯度必须从第一性原理计算：\n  - 对于一条张力为 $\\Lambda_e$、长度为 $L_e=\\|\\mathbf{x}_j-\\mathbf{x}_i\\|$ 的边 $e=(i,j)$，其在 $\\mathbf{x}_i$ 处对梯度的贡献为 $-\\Lambda_e\\,(\\mathbf{x}_j-\\mathbf{x}_i)/L_e$，在 $\\mathbf{x}_j$ 处为 $+\\Lambda_e\\,(\\mathbf{x}_j-\\mathbf{x}_i)/L_e$。\n  - 对于一个具有逆时针顶点 $[\\mathbf{x}_0,\\dots,\\mathbf{x}_{n-1}]$ 的多边形细胞，其有向面积为 $A=\\frac{1}{2}\\sum_{k} (x_k y_{k+1} - x_{k+1} y_k)$，其中索引模 $n$。面积 $A$ 相对于顶点 $\\mathbf{x}_k=(x_k,y_k)$ 的梯度为 $\\nabla_{\\mathbf{x}_k} A = \\frac{1}{2}\\,(y_{k+1}-y_{k-1},\\,x_{k-1}-x_{k+1})$。在每个顶点处，细胞的面积弹性对梯度的贡献为 $K\\,(A-A^{(0)})\\,\\nabla A$。\n- 当梯度范数降至 $10^{-8}$ 以下或达到最大迭代次数 $5000$ 次时终止。使用参数 $c=10^{-4}$ 的Armijo型条件和回溯因子 $1/2$，初始步长为 $0.1$。\n\n测试套件：\n对于每个测试用例，给定 $(K,\\Lambda_{\\mathrm{other}},\\Lambda_{\\mathrm{central}})$。按照上述规定初始化几何形状和 $A_i^{(0)}$，最小化 $E$，计算优化后的中央长度 $L_{\\mathrm{central}}^{\\ast}$，并输出一个布尔值，指示 $L_{\\mathrm{central}}^{\\ast} \\le \\ell_{\\min}$ 是否成立。\n\n使用以下五个测试用例：\n- 用例 1：$K=10.0$，$\\Lambda_{\\mathrm{other}}=0.1$，$\\Lambda_{\\mathrm{central}}=0.5$。\n- 用例 2：$K=10.0$，$\\Lambda_{\\mathrm{other}}=0.05$，$\\Lambda_{\\mathrm{central}}=10.0$。\n- 用例 3：$K=100.0$，$\\Lambda_{\\mathrm{other}}=0.1$，$\\Lambda_{\\mathrm{central}}=5.0$。\n- 用例 4：$K=5.0$，$\\Lambda_{\\mathrm{other}}=0.1$，$\\Lambda_{\\mathrm{central}}=1.5$。\n- 用例 5（强面积约束的边缘情况）：$K=1000.0$，$\\Lambda_{\\mathrm{other}}=0.1$，$\\Lambda_{\\mathrm{central}}=50.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与测试用例的顺序相同，例如，“[True,False,True,False,True]”。", "solution": "### 求解推导与算法\n\n任务是通过最小化总能量 $E$ 来找到双细胞系统的平衡构型，最小化是相对于可移动顶点 $v_1 = (x_1, y_1)$ 和 $v_2 = (x_2, y_2)$ 的坐标进行的。系统的状态可以由一个向量 $\\mathbf{X} = [x_1, y_1, x_2, y_2]^T$ 表示。\n\n**1. 初始状态与目标面积**\n\n固定的顶点是 $L=(-1,0)$ 和 $R=(1,0)$。可移动顶点的初始位置是 $v_1(0)=(0,-0.2)$ 和 $v_2(0)=(0,0.2)$。目标面积 $A_i^{(0)}$ 是根据这些初始位置，使用多边形面积的鞋带公式 $A = \\frac{1}{2}\\sum_{k=0}^{n-1} (x_k y_{k+1} - x_{k+1} y_k)$（其中顶点按逆时针顺序排列）计算得出。\n\n- **左细胞**顶点： $[L, v_1(0), v_2(0)] = [(-1,0), (0,-0.2), (0,0.2)]$。\n  $$A_{\\mathrm{left}}^{(0)} = \\frac{1}{2} \\left| (-1)(-0.2) - (0)(0) + (0)(0.2) - (-0.2)(0) + (0)(0) - (0.2)(-1) \\right| = 0.2$$\n- **右细胞**顶点： $[R, v_2(0), v_1(0)] = [(1,0), (0,0.2), (0,-0.2)]$。\n  $$A_{\\mathrm{right}}^{(0)} = \\frac{1}{2} \\left| (1)(0.2) - (0)(0) + (0)(-0.2) - (0.2)(0) + (0)(0) - (-0.2)(1) \\right| = 0.2$$\n由于对称性，$A_{\\mathrm{left}}^{(0)} = A_{\\mathrm{right}}^{(0)} = 0.2$。\n\n**2. 能量与梯度计算**\n\n总梯度 $\\nabla_{\\mathbf{X}} E$ 是来自张力项和面积项的梯度之和。\n\n- **张力项：** 连接顶点 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$、张力为 $\\Lambda_e$ 的边的势能为 $E_e = \\Lambda_e \\|\\mathbf{x}_j - \\mathbf{x}_i\\|$。相对于 $\\mathbf{x}_i$ 的梯度为 $\\nabla_{\\mathbf{x}_i} E_e = \\Lambda_e \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{\\|\\mathbf{x}_j - \\mathbf{x}_i\\|}$。这与提供的公式相符。总张力梯度是连接到某个可移动顶点的所有边的梯度之和。\n\n- **面积项：** 细胞 $i$ 的势能为 $E_{A_i} = \\frac{K}{2}(A_i - A_i^{(0)})^2$。相对于顶点 $\\mathbf{x}_k$ 的梯度为 $\\nabla_{\\mathbf{x}_k} E_{A_i} = K(A_i - A_i^{(0)}) \\nabla_{\\mathbf{x}_k} A_i$。\n  面积本身的梯度 $\\nabla_{\\mathbf{x}_k} A_i$ 由指定的公式 $\\frac{1}{2}(y_{k+1}-y_{k-1}, x_{k-1}-x_{k+1})$ 给出。我们将此应用于每个可移动顶点的两个细胞。\n\n  - **对于左细胞** $[L, v_1, v_2]$ ($p_0=L, p_1=v_1, p_2=v_2$):\n    - $\\nabla_{v_1} A_{\\mathrm{left}} = \\frac{1}{2}(y_2 - y_L, x_L - x_2) = \\frac{1}{2}(y_2, -1 - x_2)$\n    - $\\nabla_{v_2} A_{\\mathrm{left}} = \\frac{1}{2}(y_L - y_1, x_1 - x_L) = \\frac{1}{2}(-y_1, x_1 + 1)$\n  - **对于右细胞** $[R, v_2, v_1]$ ($q_0=R, q_1=v_2, q_2=v_1$):\n    - $\\nabla_{v_1} A_{\\mathrm{right}} = \\frac{1}{2}(y_R - y_2, x_2 - x_R) = \\frac{1}{2}(-y_2, x_2 - 1)$\n    - $\\nabla_{v_2} A_{\\mathrm{right}} = \\frac{1}{2}(y_1 - y_R, x_R - x_1) = \\frac{1}{2}(y_1, 1 - x_1)$\n\n总梯度 $\\nabla_{\\mathbf{X}} E$ 是一个4维向量，由对 $v_1=(x_1, y_1)$ 和 $v_2=(x_2, y_2)$ 的梯度贡献组成。\n\n**3. 最小化算法：带回溯线搜索的梯度下降**\n\n算法流程如下：\n1. 初始化 $\\mathbf{X}^{(0)} = [0, -0.2, 0, 0.2]$。\n2. 对于迭代 $k=0, 1, \\dots, N_{\\max}-1$：\n   a. 计算当前能量 $E^{(k)}$ 和梯度 $\\mathbf{g}^{(k)} = \\nabla_{\\mathbf{X}} E(\\mathbf{X}^{(k)})$。\n   b. 检查收敛性：如果 $\\|\\mathbf{g}^{(k)}\\| < 10^{-8}$，则终止。\n   c. **回溯线搜索：**\n      i. 初始化步长 $\\alpha = \\alpha_0 = 0.1$。\n      ii. 当 $E(\\mathbf{X}^{(k)} - \\alpha \\mathbf{g}^{(k)}) > E^{(k)} - c \\alpha \\|\\mathbf{g}^{(k)}\\|^2$ 时：\n         - 减小步长：$\\alpha \\leftarrow \\rho \\alpha$，其中 $\\rho=0.5$。\n      iii. 接受步长 $\\alpha$。\n   d. 更新状态：$\\mathbf{X}^{(k+1)} = \\mathbf{X}^{(k)} - \\alpha \\mathbf{g}^{(k)}$。\n3. 终止后，计算中央界面的最终长度，$L_{\\mathrm{central}}^{\\ast} = \\|\\mathbf{v}_2^{\\ast} - \\mathbf{v}_1^{\\ast}\\|$。\n4. 如果 $L_{\\mathrm{central}}^{\\ast} \\le 10^{-3}$，则预测为 `True`，否则为 `False`。对每个测试用例重复此过程。\n\n以下是实现此算法的Python代码：\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (10.0, 0.1, 0.5),    # Case 1\n        (10.0, 0.05, 10.0),   # Case 2\n        (100.0, 0.1, 5.0),    # Case 3\n        (5.0, 0.1, 1.5),      # Case 4\n        (1000.0, 0.1, 50.0),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        K, L_other, L_central = case\n        result = run_minimization(K, L_other, L_central)\n        results.append(result)\n    \n    # This function is not called to print, but demonstrates the expected output\n    # print(f\"[{','.join(map(str, results))}]\")\n    return f\"[{','.join(map(str, results))}]\"\n\ndef run_minimization(K, L_other, L_central):\n    \"\"\"\n    Performs energy minimization for a single set of parameters.\n    \n    Args:\n        K (float): Area elasticity modulus.\n        L_other (float): Line tension for lateral edges.\n        L_central (float): Line tension for the central interface.\n        \n    Returns:\n        bool: True if the central interface is predicted to collapse, False otherwise.\n    \"\"\"\n    # Fixed and initial vertex positions\n    L_pos = np.array([-1.0, 0.0])\n    R_pos = np.array([1.0, 0.0])\n    v1_init = np.array([0.0, -0.2])\n    v2_init = np.array([0.0, 0.2])\n    \n    # State vector X = [v1_x, v1_y, v2_x, v2_y]\n    X = np.concatenate([v1_init, v2_init])\n    \n    # Calculate initial areas to set as target areas A^(0)\n    A0_left = 0.5 * (-v1_init[1] + v1_init[0]*v2_init[1] - v1_init[1]*v2_init[0] + v2_init[1])\n    A0_right = 0.5 * (v2_init[1] + v2_init[0]*v1_init[1] - v2_init[1]*v1_init[0] - v1_init[1])\n\n    # Minimization parameters\n    max_iter = 5000\n    grad_norm_thresh = 1e-8\n    l_min = 1e-3\n    \n    # Backtracking line search parameters\n    alpha_init = 0.1\n    c_armijo = 1e-4\n    backtrack_factor = 0.5\n\n    for _ in range(max_iter):\n        energy, grad = calculate_energy_and_gradient(X, K, L_other, L_central, A0_left, A0_right, L_pos, R_pos)\n        \n        grad_norm = np.linalg.norm(grad)\n        if grad_norm  grad_norm_thresh:\n            break\n        \n        # Backtracking line search\n        alpha = alpha_init\n        while True:\n            X_new = X - alpha * grad\n            new_energy, _ = calculate_energy_and_gradient(X_new, K, L_other, L_central, A0_left, A0_right, L_pos, R_pos)\n            \n            # Armijo condition\n            if new_energy = energy - c_armijo * alpha * grad_norm**2:\n                break\n            \n            alpha *= backtrack_factor\n            if alpha  1e-15:  # Prevent infinite loop if step size becomes too small\n                break\n\n        X = X - alpha * grad\n\n    v1_final = X[0:2]\n    v2_final = X[2:4]\n    final_central_length = np.linalg.norm(v2_final - v1_final)\n    \n    return final_central_length = l_min\n\ndef calculate_energy_and_gradient(X, K, L_other, L_central, A0_left, A0_right, L_pos, R_pos):\n    \"\"\"\n    Calculates the total energy and its gradient for a given state.\n    \"\"\"\n    v1 = X[0:2]\n    v2 = X[2:4]\n    \n    # --- Energy Calculation ---\n    \n    # Area calculation using Shoelace formula for CCW vertices\n    A_left = 0.5 * (-v1[1] + v1[0]*v2[1] - v1[1]*v2[0] + v2[1])\n    A_right = 0.5 * (v2[1] + v2[0]*v1[1] - v2[1]*v1[0] - v1[1])\n    \n    E_area = (K / 2) * ((A_left - A0_left)**2 + (A_right - A0_right)**2)\n    \n    # Length calculation (add epsilon for numerical stability if needed, though unlikely here)\n    eps = 1e-12\n    vec_v1_v2 = v2 - v1\n    len_v1_v2 = np.linalg.norm(vec_v1_v2) + eps\n    \n    vec_v1_L = L_pos - v1\n    len_v1_L = np.linalg.norm(vec_v1_L) + eps\n    vec_v1_R = R_pos - v1\n    len_v1_R = np.linalg.norm(vec_v1_R) + eps\n    \n    vec_v2_L = L_pos - v2\n    len_v2_L = np.linalg.norm(vec_v2_L) + eps\n    vec_v2_R = R_pos - v2\n    len_v2_R = np.linalg.norm(vec_v2_R) + eps\n    \n    E_tension = L_central * len_v1_v2 + L_other * (len_v1_L + len_v1_R + len_v2_L + len_v2_R)\n    \n    total_energy = E_area + E_tension\n    \n    # --- Gradient Calculation ---\n    \n    # Gradient of area terms\n    dA_left_dv1 = 0.5 * np.array([v2[1], -1.0 - v2[0]])\n    dA_left_dv2 = 0.5 * np.array([-v1[1], v1[0] + 1.0])\n    \n    dA_right_dv1 = 0.5 * np.array([-v2[1], v2[0] - 1.0])\n    dA_right_dv2 = 0.5 * np.array([v1[1], 1.0 - v1[0]])\n    \n    term_A_left = K * (A_left - A0_left)\n    term_A_right = K * (A_right - A0_right)\n    \n    grad_v1_area = term_A_left * dA_left_dv1 + term_A_right * dA_right_dv1\n    grad_v2_area = term_A_left * dA_left_dv2 + term_A_right * dA_right_dv2\n    \n    # Gradient of tension terms\n    grad_v1_tension = (L_central * (-vec_v1_v2) / len_v1_v2 + \n                       L_other * (-vec_v1_L) / len_v1_L + \n                       L_other * (-vec_v1_R) / len_v1_R)\n                       \n    grad_v2_tension = (L_central * (vec_v1_v2) / len_v1_v2 +\n                       L_other * (-vec_v2_L) / len_v2_L + \n                       L_other * (-vec_v2_R) / len_v2_R)\n\n    grad = np.concatenate([grad_v1_area + grad_v1_tension,\n                           grad_v2_area + grad_v2_tension])\n                           \n    return total_energy, grad\n```", "answer": "[False,True,True,False,True]", "id": "2936395"}]}