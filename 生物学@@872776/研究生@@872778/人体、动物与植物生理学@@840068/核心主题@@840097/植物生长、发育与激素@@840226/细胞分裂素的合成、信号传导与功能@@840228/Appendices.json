{"hands_on_practices": [{"introduction": "植物的发育在很大程度上依赖于细胞分裂素等激素的精确浓度，而这一浓度是合成与分解代谢动态平衡的结果。简单的数学模型可以为我们提供强有力的洞见，揭示影响这些过程的基因突变如何相互作用，从而决定最终的激素水平及植物表型。本练习 [@problem_id:2560880] 将指导您建立并求解一个基本的稳态模型，以预测合成和降解途径中突变组合的表型结果。", "problem": "细胞分裂素是由腺嘌呤衍生的植物激素，主要由异戊烯基转移酶 (IPT) 合成，并被细胞分裂素氧化酶/脱氢酶 (CKX) 不可逆地降解。在一个细胞分裂素浓度近似均匀的组织中，我们假设一个最小化的、充分混合的动力学模型。在该模型中，细胞分裂素通过依赖于IPT的途径以一个有效的恒定速率产生，并通过依赖于CKX的降解以及其他一级消耗途径（如结合、运输和生长稀释）被移除。在这些假设下，细胞分裂素浓度随时间的变化可以通过质量平衡来描述，其中产生和移除贡献了相反的通量。根据定义，在稳态下，净积累为零。\n\n考虑四种基因型：野生型、导致生物合成能力降低的 ipt 功能缺失型、导致酶促降解减弱的 ckx 功能缺失型，以及 ipt;ckx 双突变体。设野生型的参数为：产生速率 $B_0$，以及一级移除速率常数，其中 $k_{d0}$ 对应于依赖CKX的降解，$k_{o0}$ 对应于所有其他移除过程。假设在一致的任意单位和时间单位下，以下数值成立：$B_0 = 1$，$k_{d0} = 1$，$k_{o0} = 1$。ipt 功能缺失突变将产生速率降低至 $\\alpha B_0$，其中 $\\alpha = 0.25$，而移除参数保持不变。ckx 功能缺失突变将依赖CKX的降解速率常数降低至 $\\beta k_{d0}$，其中 $\\beta = 0.25$，而产生速率和其他移除参数保持不变。在 ipt;ckx 双突变体中，两种修饰同时且独立地起作用。\n\n仅使用这些前提、稳态的定义以及一级动力学的含义，推断不同基因型中稳态细胞分裂素的相对水平，然后利用以下广泛观察到的定性关系将其映射到表型：较高的细胞分裂素水平促进地上部分生组织活动、地上部分分枝和延迟的叶片衰老，并抑制主根伸长，从而降低根冠比；较低的细胞分裂素水平则产生相反的效果。\n\n哪个选项最准确地预测了 ipt;ckx 双突变体相对于野生型以及相对于每个单突变体的表型？\n\nA. 双突变体部分抑制了 ipt 的表型，但与野生型相比，其细胞分裂素水平仍然较低：相对于野生型，地上部分分枝和叶片扩张减少，但相对于 ipt 有所改善；相对于野生型，根系生长和根冠比增加，但增加程度小于 ipt；叶片衰老早于野生型，但晚于 ipt。\n\nB. 双突变体模拟了 ckx 功能缺失型的细胞分裂素过量积累：地上部分分枝强烈增加，主根生长受抑制，根冠比下降，衰老延迟程度超过野生型和 ipt。\n\nC. 由于完全的通量缓冲，双突变体与野生型基本无法区分：地上部分和根部性状以及衰老时间与野生型一致。\n\nD. 双突变体比 ipt 单突变体更严重：地上部分分生组织活动和分枝进一步减少，根系生长和根冠比进一步增加，衰老时间早于 ipt，因为阻断降解移除了一个必要的再循环步骤，从而放大了生物合成的缺陷。", "solution": "首先将验证问题陈述的科学性和逻辑完整性。\n\n### 步骤1：提取已知条件\n- 提出了一个细胞分裂素浓度 $[C]$ 的动力学模型，该模型由质量平衡方程 $\\frac{d[C]}{dt} = \\text{产生} - \\text{移除}$ 控制。\n- 产生是一个速率为 $B$ 的零级过程。\n- 移除是一个一级过程，包含两个部分：速率常数为 $k_d$ 的依赖CKX的降解，以及速率常数为 $k_o$ 的其他过程（结合、运输、稀释）。总移除速率为 $(k_d + k_o)[C]$。\n- 在稳态下，$\\frac{d[C]}{dt} = 0$。\n- 考虑了四种基因型：野生型 (WT)、`ipt` 功能缺失型 (`ipt`)、`ckx` 功能缺失型 (`ckx`)，以及 `ipt;ckx` 双突变体。\n- 野生型参数定义为：$B_{WT} = B_0 = 1$，$k_{d,WT} = k_{d0} = 1$，$k_{o,WT} = k_{o0} = 1$（在一致的任意单位下）。\n- `ipt` 突变降低了产生速率：$B_{ipt} = \\alpha B_0$，其中 $\\alpha = 0.25$。移除参数不变。\n- `ckx` 突变降低了依赖CKX的降解速率常数：$k_{d,ckx} = \\beta k_{d0}$，其中 $\\beta = 0.25$。产生速率和其他移除参数不变。\n- `ipt;ckx` 双突变体独立地结合了两种效应：$B_{ipt;ckx} = \\alpha B_0$ 且 $k_{d,ipt;ckx} = \\beta k_{d0}$。\n- 表型关联：较高的细胞分裂素水平导致地上部分生长/分枝增加和衰老延迟，但抑制根系生长并降低根冠比。较低的细胞分裂素水平产生相反的效果。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题描述了一个简化的、但标准且广为接受的用于激素稳态的常微分方程模型。IPT和CKX分别作为细胞分裂素生物合成和分解代谢的主要酶，其作用是符合事实的。动力学假设（零级产生，一级衰减）是系统生物学中用于模拟此类途径的常见简化方法。该问题是自洽的，提供了计算每种基因型唯一稳态浓度的所有必要参数。语言精确客观。该问题具有科学依据，提法恰当，没有矛盾或含糊之处。\n\n### 步骤3：结论与行动\n问题陈述有效。将推导一个定量的解。\n\n### 稳态细胞分裂素水平的推导\n\n细胞分裂素浓度 $[C]$ 随时间的变化由以下微分方程给出：\n$$ \\frac{d[C]}{dt} = B - (k_d + k_o)[C] $$\n在稳态下，净变化率为零，即 $\\frac{d[C]}{dt} = 0$。因此，产生通量必须等于移除通量：\n$$ B = (k_d + k_o)[C]_{ss} $$\n求解稳态细胞分裂素浓度 $[C]_{ss}$，得到：\n$$ [C]_{ss} = \\frac{B}{k_d + k_o} $$\n现在我们将此公式应用于四种指定的基因型，并使用所提供的参数。\n\n**1. 野生型 (WT):**\n$B = B_0 = 1$\n$k_d = k_{d0} = 1$\n$k_o = k_{o0} = 1$\n$$ [C]_{WT} = \\frac{B_0}{k_{d0} + k_{o0}} = \\frac{1}{1 + 1} = 0.5 $$\n\n**2. `ipt` 功能缺失突变体 (`ipt`):**\n$B = \\alpha B_0 = 0.25 \\times 1 = 0.25$\n$k_d = k_{d0} = 1$\n$k_o = k_{o0} = 1$\n$$ [C]_{ipt} = \\frac{\\alpha B_0}{k_{d0} + k_{o0}} = \\frac{0.25}{1 + 1} = \\frac{0.25}{2} = 0.125 $$\n\n**3. `ckx` 功能缺失突变体 (`ckx`):**\n$B = B_0 = 1$\n$k_d = \\beta k_{d0} = 0.25 \\times 1 = 0.25$\n$k_o = k_{o0} = 1$\n$$ [C]_{ckx} = \\frac{B_0}{\\beta k_{d0} + k_{o0}} = \\frac{1}{0.25 + 1} = \\frac{1}{1.25} = 0.8 $$\n\n**4. `ipt;ckx` 双突变体 (`ipt;ckx`):**\n$B = \\alpha B_0 = 0.25 \\times 1 = 0.25$\n$k_d = \\beta k_{d0} = 0.25 \\times 1 = 0.25$\n$k_o = k_{o0} = 1$\n$$ [C]_{ipt;ckx} = \\frac{\\alpha B_0}{\\beta k_{d0} + k_{o0}} = \\frac{0.25}{0.25 + 1} = \\frac{0.25}{1.25} = \\frac{1}{5} = 0.2 $$\n\n### 比较与表型解释\n\n计算出的稳态细胞分裂素浓度排序如下：\n$$ [C]_{ipt} (0.125)  [C]_{ipt;ckx} (0.2)  [C]_{WT} (0.5)  [C]_{ckx} (0.8) $$\n这个排序可以直接预测相对的表型。\n`ipt;ckx` 双突变体的细胞分裂素水平 ($0.2$)：\n- **低于野生型** ($0.5$)。因此，相对于野生型，它应表现出细胞分裂素缺乏的表型（例如，地上部分分枝减少，根系生长增强，衰老提前）。\n- **高于 `ipt` 单突变体** ($0.125$)。这意味着 `ckx` 突变部分地挽救或抑制了 `ipt` 突变体严重的细胞分裂素缺乏。双突变体的表型严重程度应低于 `ipt` 单突变体。\n\n因此，`ipt;ckx` 双突变体的表型介于 `ipt` 单突变体和野生型之间。它不会过量积累细胞分裂素，也不会将浓度完美地缓冲至野生型水平。\n\n### 选项评估\n\n**A. 双突变体部分抑制了 ipt 的表型，但与野生型相比，其细胞分裂素水平仍然较低：相对于野生型，地上部分分枝和叶片扩张减少，但相对于 ipt 有所改善；相对于野生型，根系生长和根冠比增加，但增加程度小于 ipt；叶片衰老早于野生型，但晚于 ipt。**\n这个陈述是我们定量结果的精确定性描述，即 $[C]_{ipt}  [C]_{ipt;ckx}  [C]_{WT}$。双突变体部分抑制了 `ipt` 表型，但没有将其恢复到野生型水平。**正确**。\n\n**B. 双突变体模拟了 ckx 功能缺失型的细胞分裂素过量积累：地上部分分枝强烈增加，主根生长受抑制，根冠比下降，衰老延迟程度超过野生型和 ipt。**\n这将要求 $[C]_{ipt;ckx}$ 很高，可能大于 $[C]_{WT}$。我们的计算显示 $[C]_{ipt;ckx} = 0.2$，这显著低于 $[C]_{WT} = 0.5$ 和 $[C]_{ckx} = 0.8$。双突变体是细胞分裂素缺乏型，而不是过量积累型。**错误**。\n\n**C. 由于完全的通量缓冲，双突变体与野生型基本无法区分：地上部分和根部性状以及衰老时间与野生型一致。**\n这将要求 $[C]_{ipt;ckx} \\approx [C]_{WT}$。我们的计算得出 $[C]_{ipt;ckx} = 0.2$ 和 $[C]_{WT} = 0.5$，两者差异很大。只有当非CKX降解途径可以忽略不计时（即 $k_{o0} = 0$），才会发生完全缓冲，此时浓度比将为 $(\\alpha/\\beta) = (0.25/0.25) = 1$。具有常数 $k_{o0}$ 的并行降解途径的存在阻止了这种完美的抵消。**错误**。\n\n**D. 双突变体比 ipt 单突变体更严重：地上部分分生组织活动和分枝进一步减少，根系生长和根冠比进一步增加，衰老时间早于 ipt，因为阻断降解移除了一个必要的再循环步骤，从而放大了生物合成的缺陷。**\n这意味着 $[C]_{ipt;ckx}  [C]_{ipt}$。我们的计算显示了相反的结果：$[C]_{ipt;ckx} = 0.2 > [C]_{ipt} = 0.125$。双突变体的表型没有单 `ipt` 突变体严重。此外，问题明确指出依赖CKX的降解是不可逆的，因此关于“再循环步骤”的推理与前提相矛盾。**错误**。", "answer": "$$\\boxed{A}$$", "id": "2560880"}, {"introduction": "在建立了关于激素稳态的理论模型后，我们将转向经验数据的分析。细胞分裂素的一个关键功能是延缓叶片衰老，这可以通过测量叶绿素的降解速率来量化。这个动手实践 [@problem_id:2560886] 将带您将一级动力学衰减模型拟合到模拟的实验数据上，这项任务展示了定量生物学中的一项基本技能：如何从带噪声的时间序列测量中提取有意义的生物学参数（如衰减速率），并用其检验一个假设。", "problem": "您将获得在对照条件下和细胞分裂素处理下，离体叶片中叶绿素含量的配对时间序列测量数据。众所周知，细胞分裂素能延缓叶片衰老；一个常见的第一性原理建模假设是，离体叶片中的叶绿素降解动力学遵循一级衰减。在一级动力学下，时间 $t$（单位为天）时的叶绿素含量 $C(t)$ 遵循模型 $C(t) = C_0 e^{-k t}$，其中 $C_0$ 是初始叶绿素含量，$k$（单位为 $\\text{day}^{-1}$）是衰减常数。测量值受到具有已知标准差的独立高斯噪声的影响，因此当标准差用作权重时，通过加权非线性最小二乘法可以最大化该模型下的对数似然。\n\n您的任务是实现一个程序，对于每个测试用例，通过最小化模型 $C(t) = C_0 e^{-k t}$ 下的加权残差平方和，分别为对照组和经细胞分裂素处理的叶片拟合 $C_0$ 和 $k$，然后使用分数变化来量化处理如何改变衰减常数 $k$\n$$\n\\Delta = \\frac{k_{\\text{treat}} - k_{\\text{control}}}{k_{\\text{control}}}.\n$$\n以小数（无单位）形式报告 $\\Delta$。在目标函数中使用提供的高斯测量噪声标准差。在拟合中强制执行约束条件 $C_0 > 0$ 和 $k \\ge 0$。\n\n对于每个测试用例，请遵循以下步骤：\n- 在独立高斯噪声假设下，通过加权非线性最小二乘法分别为对照组和处理组数据集拟合 $C_0$ 和 $k$。\n- 按上述定义计算 $\\Delta$。\n- 将每个测试用例最终报告的 $\\Delta$ 值四舍五入到 $6$ 位小数。\n\n所有时间值的单位均为天。衰减常数 $k$ 的单位为 $\\text{day}^{-1}$。分数变化 $\\Delta$ 是无单位的，必须以小数形式返回。\n\n测试套件（三个案例）：\n- 案例 A（正常路径，中等噪声，同方差）：\n  - 时间 $t$：$[0,2,4,6,8,10]$\n  - 对照组观测叶绿素 $C_{\\text{ctrl}}$：$[1.52,0.954,0.635,0.392,0.262,0.175]$\n  - 对照组测量标准差 $\\sigma_{\\text{ctrl}}$：$[0.02,0.02,0.02,0.02,0.02,0.02]$\n  - 处理组观测叶绿素 $C_{\\text{treat}}$：$[1.49,1.186,0.923,0.741,0.569,0.446]$\n  - 处理组测量标准差 $\\sigma_{\\text{treat}}$：$[0.02,0.02,0.02,0.02,0.02,0.02]$\n- 案例 B（边界情况，近乎完美的数据，动力学相等）：\n  - 时间 $t$：$[0,5,10,15,20,25,30]$\n  - 对照组观测叶绿素 $C_{\\text{ctrl}}$：$[2.0,1.5576016,1.213061319,0.944733106,0.735758882,0.573009592,0.44626032]$\n  - 对照组测量标准差 $\\sigma_{\\text{ctrl}}$：$[10^{-6},10^{-6},10^{-6},10^{-6},10^{-6},10^{-6},10^{-6}]$\n  - 处理组观测叶绿素 $C_{\\text{treat}}$：$[2.0,1.5576016,1.213061319,0.944733106,0.735758882,0.573009592,0.44626032]$\n  - 处理组测量标准差 $\\sigma_{\\text{treat}}$：$[10^{-6},10^{-6},10^{-6},10^{-6},10^{-6},10^{-6},10^{-6}]$\n- 案例 C（边缘情况，快速衰减，异方差噪声）：\n  - 时间 $t$：$[0,1,2,3,4]$\n  - 对照组观测叶绿素 $C_{\\text{ctrl}}$：$[1.01,0.597,0.382,0.215,0.147]$\n  - 对照组测量标准差 $\\sigma_{\\text{ctrl}}$：$[0.01,0.02,0.03,0.04,0.05]$\n  - 处理组观测叶绿素 $C_{\\text{treat}}$：$[1.00,0.745,0.538,0.414,0.311]$\n  - 处理组测量标准差 $\\sigma_{\\text{treat}}$：$[0.01,0.02,0.03,0.04,0.05]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 A、案例 B 和案例 C 的 $\\Delta$ 值，按此顺序排列，形式为用方括号括起来的逗号分隔列表，每个值都四舍五入到 $6$ 位小数（例如 $[\\Delta_A,\\Delta_B,\\Delta_C]$）。", "solution": "该问题要求分析离体叶片中叶绿素降解的数据，该过程通过一级动力学建模。叶绿素含量 $C$ 和时间 $t$ 之间的关系由指数衰减模型给出：\n$$ C(t) = C_0 e^{-k t} $$\n此处，$C_0$ 表示时间 $t=0$ 时的初始叶绿素含量，$k$ 是一级衰减常数，单位为 $\\text{day}^{-1}$。提供的数据包含一个对照组和一个用细胞分裂素处理的组的时间序列测量值，细胞分裂素是一种已知的可延缓衰老从而减缓叶绿素降解的植物激素。测量值受具有指定标准差 $\\sigma_i$ 的独立高斯噪声的影响。\n\n任务是为对照组和处理组数据集估计参数 $C_0$ 和 $k$。这一估计需要通过最小化加权残差平方和来执行，这等同于为具有独立高斯误差的数据最大化对数似然函数。对于一组 $N$ 个数据点 $(t_i, C^{\\text{obs}}_i, \\sigma_i)$，要最小化的目标函数是卡方统计量 $\\chi^2$：\n$$ \\chi^2(C_0, k) = \\sum_{i=1}^{N} \\left( \\frac{C^{\\text{obs}}_i - C(t_i; C_0, k)}{\\sigma_i} \\right)^2 = \\sum_{i=1}^{N} \\left( \\frac{C^{\\text{obs}}_i - C_0 e^{-k t_i}}{\\sigma_i} \\right)^2 $$\n这是一个加权非线性最小二乘拟合问题。拟合过程必须遵守模型的物理约束，具体来说，初始浓度 $C_0$ 必须为正 ($C_0 > 0$)，衰减常数 $k$ 必须为非负 ($k \\ge 0$)。\n\n在估计了对照组 ($k_{\\text{control}}$) 和处理组 ($k_{\\text{treat}}$) 条件下的衰减常数后，细胞分裂素处理的效果将通过分数变化 $\\Delta$ 来量化：\n$$ \\Delta = \\frac{k_{\\text{treat}} - k_{\\text{control}}}{k_{\\text{control}}} $$\n$\\Delta$ 的负值表示处理减慢了衰减速率，这是细胞分裂素预期的生理效应。每个测试用例最终计算出的 $\\Delta$ 值必须四舍五入到 $6$ 位小数。\n\n获取每个测试用例解的计算步骤如下：\n\n1.  分离出对照组的数据：时间点 $t_i$、观测到的叶绿素含量 $C^{\\text{obs}}_{\\text{ctrl}, i}$ 和标准差 $\\sigma_{\\text{ctrl}, i}$。\n2.  对对照组数据进行模型 $C(t) = C_0 e^{-k t}$ 的加权非线性最小二乘拟合。这通过找到最小化目标函数 $\\chi^2_{\\text{control}}$ 的参数 $(C_{0, \\text{control}}, k_{\\text{control}})$ 来实现。在此优化过程中强制执行约束条件 $C_0 > 0$ 和 $k \\ge 0$。为此，SciPy 库中的 `scipy.optimize.curve_fit` 函数是理想的选择。它需要模型函数、自变量 ($t$) 和因变量 ($C^{\\text{obs}}$) 数据，以及测量标准差 ($\\sigma$)，并将其用作最小二乘最小化中的权重。约束通过其 `bounds` 参数施加。\n3.  对处理组数据（$t_i$、$C^{\\text{obs}}_{\\text{treat}, i}$、$\\sigma_{\\text{treat}, i}$）重复拟合过程，通过最小化 $\\chi^2_{\\text{treat}}$ 找到最优参数 $(C_{0, \\text{treat}}, k_{\\text{treat}})$。\n4.  一旦确定了衰减常数 $k_{\\text{control}}$ 和 $k_{\\text{treat}}$，使用指定公式计算分数变化 $\\Delta$。\n5.  将此过程独立应用于提供的三个测试用例中的每一个。收集所得的 $\\Delta$ 值并按要求格式呈现。数值实现将使用 `numpy` 进行数组操作，并使用 `scipy.optimize.curve_fit` 作为核心拟合算法。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Solves for the fractional change in decay constant k for three test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path, moderate noise, homoscedastic)\n        {\n            \"t\": [0, 2, 4, 6, 8, 10],\n            \"C_ctrl\": [1.52, 0.954, 0.635, 0.392, 0.262, 0.175],\n            \"sigma_ctrl\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n            \"C_treat\": [1.49, 1.186, 0.923, 0.741, 0.569, 0.446],\n            \"sigma_treat\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n        },\n        # Case B (boundary, nearly perfect data, equal kinetics)\n        {\n            \"t\": [0, 5, 10, 15, 20, 25, 30],\n            \"C_ctrl\": [2.0, 1.5576016, 1.213061319, 0.944733106, 0.735758882, 0.573009592, 0.44626032],\n            \"sigma_ctrl\": [1e-6] * 7,\n            \"C_treat\": [2.0, 1.5576016, 1.213061319, 0.944733106, 0.735758882, 0.573009592, 0.44626032],\n            \"sigma_treat\": [1e-6] * 7,\n        },\n        # Case C (edge, fast decay, heteroscedastic noise)\n        {\n            \"t\": [0, 1, 2, 3, 4],\n            \"C_ctrl\": [1.01, 0.597, 0.382, 0.215, 0.147],\n            \"sigma_ctrl\": [0.01, 0.02, 0.03, 0.04, 0.05],\n            \"C_treat\": [1.00, 0.745, 0.538, 0.414, 0.311],\n            \"sigma_treat\": [0.01, 0.02, 0.03, 0.04, 0.05],\n        }\n    ]\n\n    results = []\n\n    def model(t, C0, k):\n        \"\"\"First-order decay model.\"\"\"\n        return C0 * np.exp(-k * t)\n\n    def get_decay_constant(t, C_obs, sigma_obs):\n        \"\"\"\n        Fits the first-order decay model to data using weighted non-linear least squares.\n        Returns the fitted decay constant k.\n        \"\"\"\n        # Convert to numpy arrays for scipy\n        t_np = np.array(t)\n        C_obs_np = np.array(C_obs)\n        sigma_obs_np = np.array(sigma_obs)\n        \n        # Define bounds for parameters: C0 > 0, k >= 0.\n        # curve_fit's lower bound is inclusive, so C0>=0 is implemented.\n        # This is acceptable as C0=0 is a valid physical limit.\n        bounds = ([0, 0], [np.inf, np.inf])\n        \n        # Initial guess for parameters [C0, k]\n        # A simple initial guess can improve convergence robustness.\n        # C0 is roughly the first data point.\n        # k can be estimated from the first and last points, ensuring it's non-negative.\n        k_guess = 0.1\n        if len(t_np) > 1 and C_obs_np[0] > C_obs_np[-1] and C_obs_np[-1] > 0:\n            dt = t_np[-1] - t_np[0]\n            if dt > 0:\n                k_guess = np.log(C_obs_np[0] / C_obs_np[-1]) / dt\n\n        p0 = [C_obs_np[0], k_guess]\n\n        # Perform the fit\n        params, _ = curve_fit(\n            f=model,\n            xdata=t_np,\n            ydata=C_obs_np,\n            p0=p0,\n            sigma=sigma_obs_np,\n            bounds=bounds,\n            absolute_sigma=True,\n            method='trf' # Trust Region Reflective, good for bounds\n        )\n        \n        return params[1] # Return the fitted k\n\n    for case in test_cases:\n        k_control = get_decay_constant(case[\"t\"], case[\"C_ctrl\"], case[\"sigma_ctrl\"])\n        k_treat = get_decay_constant(case[\"t\"], case[\"C_treat\"], case[\"sigma_treat\"])\n\n        if k_control == 0:\n            # If control decay is zero, fractional change is undefined or infinite\n            # unless treated decay is also zero. This case is not expected\n            # with the given data but handle defensively.\n            delta = 0.0 if k_treat == 0 else np.inf\n        else:\n            delta = (k_treat - k_control) / k_control\n        \n        results.append(round(delta, 6))\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2560886"}, {"introduction": "最后，我们从对宏观生理现象的建模，深入到信号通路本身的动态过程。要理解细胞如何随时间响应细胞分裂素信号，就需要对从受体激活到基因表达的整个事件链进行建模。这个高级练习 [@problem_id:2560945] 要求您为经典的细胞分裂素信号级联反应构建一个常微分方程(ODE)系统，并进行结构可辨识性分析，这引入了系统生物学中的一个关键概念：在尝试将模型与真实数据拟合之前，首先确定模型参数是否原则上可以从可行的实验中估计出来。", "problem": "您需要形式化一个细胞分裂素信号传导的最小常微分方程（ODE）模型，该模型需捕获四个典型步骤：受体激活、拟南芥组氨酸磷酸转移蛋白（AHP）穿梭、B型拟南芥响应调节因子（ARR）激活和A型ARR诱导。从质量作用动力学和分子生物学中心法则的基本原理出发，定义一个具有以下状态变量和输入的动力学系统：受体活性分数 $R_p(t)$、磷酸化AHP $H_p(t)$、活化的B型ARR $B_p(t)$ 和A型ARR产物 $A(t)$，由分段恒定的细胞分裂素输入浓度 $u(t)$ 驱动。假设总池 $R_{\\text{tot}}$、$H_{\\text{tot}}$ 和 $B_{\\text{tot}}$ 固定，并在适当情况下采用线性一级失活和降解过程。\n\n模型必须使用以下与质量作用一致的最小相互作用来构建：\n\n- 细胞分裂素-受体激活：$R_p$ 随 $u(t)$ 增加，并通过一级失活减少。\n- AHP磷酸化：$H_p$ 通过从 $R_p$ 转移而增加，并通过一级去磷酸化减少。\n- B型ARR激活：$B_p$ 通过与 $H_p$ 相互作用而增加，并通过一级失活减少。\n- A型ARR诱导：$A$ 随 $B_p$ 线性增加（作为一个有效的转录-翻译集总步骤），并通过一级降解减少。\n\n使用这些原理编写一个形式如下的ODE系统\n$$\n\\frac{dR_p}{dt} = f_1\\big(R_p, u(t); \\theta\\big),\\quad\n\\frac{dH_p}{dt} = f_2\\big(R_p, H_p; \\theta\\big),\\quad\n\\frac{dB_p}{dt} = f_3\\big(H_p, B_p; \\theta\\big),\\quad\n\\frac{dA}{dt} = f_4\\big(B_p, A; \\theta\\big),\n$$\n其中参数向量为\n$$\n\\theta = \\big(k_{\\text{on}},\\, k_{\\text{off}},\\, k_1,\\, k_2,\\, k_3,\\, k_4,\\, k_{\\text{tx}},\\, k_{\\text{deg}}\\big).\n$$\n\n将总池和初始条件设为已知常数：\n- $R_{\\text{tot}} = 100\\,\\text{nM}$，$H_{\\text{tot}} = 200\\,\\text{nM}$，$B_{\\text{tot}} = 100\\,\\text{nM}$。\n- 初始条件：$R_p(0)=0$，$H_p(0)=0$，$B_p(0)=0$，$A(0)=0$。\n- 单位：时间为分钟（min），浓度为纳摩尔（nM）。\n\n在模拟中使用以下具体参数值：\n- $k_{\\text{on}} = 1\\times 10^{-3}\\,\\text{nM}^{-1}\\,\\text{min}^{-1}$，\n- $k_{\\text{off}} = 2\\times 10^{-2}\\,\\text{min}^{-1}$，\n- $k_1 = 2\\times 10^{-2}\\,\\text{nM}^{-1}\\,\\text{min}^{-1}$，\n- $k_2 = 1\\times 10^{-1}\\,\\text{min}^{-1}$，\n- $k_3 = 2\\times 10^{-2}\\,\\text{nM}^{-1}\\,\\text{min}^{-1}$，\n- $k_4 = 5\\times 10^{-2}\\,\\text{min}^{-1}$，\n- $k_{\\text{tx}} = 5\\times 10^{-1}\\,\\text{min}^{-1}$，\n- $k_{\\text{deg}} = 2\\times 10^{-2}\\,\\text{min}^{-1}$。\n\n您的程序必须：\n\n- 使用上述原理实现ODE系统，具体如下\n$$\n\\frac{dR_p}{dt} = k_{\\text{on}}\\,u(t)\\,\\big(R_{\\text{tot}} - R_p\\big) - k_{\\text{off}}\\,R_p,\n$$\n$$\n\\frac{dH_p}{dt} = k_1\\,R_p\\,\\big(H_{\\text{tot}} - H_p\\big) - k_2\\,H_p,\n$$\n$$\n\\frac{dB_p}{dt} = k_3\\,H_p\\,\\big(B_{\\text{tot}} - B_p\\big) - k_4\\,B_p,\n$$\n$$\n\\frac{dA}{dt} = k_{\\text{tx}}\\,B_p - k_{\\text{deg}}\\,A.\n$$\n\n- 对于可观测量，考虑两种测量配置：仅 $A(t)$，或同时测量 $A(t)$ 和 $B_p(t)$。当两者都测量时，堆叠观测向量必须构建为串联形式 $[A(t_1),\\dots,A(t_N), B_p(t_1),\\dots,B_p(t_N)]$。\n\n- 对于可识别性分析，通过中心有限差分法计算堆叠观测向量相对于 $\\theta$ 在指定采样时间的局部灵敏度矩阵 $S$，使用一个小的相对步长 $\\epsilon$（使用 $\\epsilon = 10^{-6}$）。构建一个单位方差的费雪信息矩阵（FIM），$F = S^\\top S$。\n\n- 通过奇异值分解（SVD）计算 $S$ 的数值秩来评估局部可识别性。此外，使用对 $S$ 的列主元QR分解来确定一组可识别的参数；如果一个参数对应的列在与基于SVD的秩决策一致的数值容差下被选为线性无关，则将该参数分类为可识别。\n\n- 对每个测试用例，报告 $S$ 的整数秩和一个长度为8的布尔值列表，该列表指示在该测试用例下 $\\theta$ 中的哪些参数是可识别的。\n\n测试套件规范（每个用例定义输入 $u(t)=u_0$、采样网格和可观测量集合）：\n\n- 用例1（理想路径，中等时长，单个可观测量）：$u_0 = 50\\,\\text{nM}$；采样时间 $t = 0, 5, 10, \\dots, 60\\,\\text{min}$；可观测量集合：仅 $A(t)$。\n- 用例2（理想路径，中等时长，双可观测量）：$u_0 = 50\\,\\text{nM}$；采样时间 $t = 0, 5, 10, \\dots, 60\\,\\text{min}$；可观测量集合：同时测量 $A(t)$ 和 $B_p(t)$。\n- 用例3（边界条件，零输入）：$u_0 = 0\\,\\text{nM}$；采样时间 $t = 0, 5, 10, \\dots, 60\\,\\text{min}$；可观测量集合：仅 $A(t)$。\n- 用例4（边缘情况，强调早期瞬态，双可观测量）：$u_0 = 50\\,\\text{nM}$；采样时间 $t = 0, 0.5, 1.0, \\dots, 5.0\\,\\text{min}$；可观测量集合：同时测量 $A(t)$ 和 $B_p(t)$。\n\n角度单位不适用。浓度和时间已在上方指定；最终答案是无量纲的布尔值和整数，因此输出中无需进行单位转换。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，本身是一个双元素列表 $[r, L]$，其中 $r$ 是整数秩，$L$ 是一个长度为8的布尔值列表，表示按 $\\big(k_{\\text{on}},\\, k_{\\text{off}},\\, k_1,\\, k_2,\\, k_3,\\, k_4,\\, k_{\\text{tx}},\\, k_{\\text{deg}}\\big)$ 顺序排列的参数的可识别性。例如：\n\"[ [r1,[b1,b2,b3,b4,b5,b6,b7,b8]],[r2,[...]], [r3,[...]], [r4,[...]] ]\"", "solution": "用户提供了一个定义明确的计算系统生物学问题。任务是针对一个给定的细胞分裂素信号传导常微分方程（ODE）模型，执行局部结构可识别性分析。该分析将在四种不同的实验情景（测试用例）下进行。\n\n### 步骤1：问题验证\n\n问题陈述已经过严格审查，并被确定为有效。\n\n- **已知条件**：\n    - **状态变量**：$R_p(t)$, $H_p(t)$, $B_p(t)$, $A(t)$。\n    - **输入**：分段恒定的细胞分裂素浓度 $u(t)$。\n    - **总池**：$R_{\\text{tot}} = 100\\,\\text{nM}$，$H_{\\text{tot}} = 200\\,\\text{nM}$，$B_{\\text{tot}} = 100\\,\\text{nM}$。\n    - **初始条件**：$R_p(0)=0$, $H_p(0)=0$, $B_p(0)=0$, $A(0)=0$。\n    - **ODE系统**：\n        $$ \\frac{dR_p}{dt} = k_{\\text{on}}\\,u(t)\\,\\big(R_{\\text{tot}} - R_p\\big) - k_{\\text{off}}\\,R_p $$\n        $$ \\frac{dH_p}{dt} = k_1\\,R_p\\,\\big(H_{\\text{tot}} - H_p\\big) - k_2\\,H_p $$\n        $$ \\frac{dB_p}{dt} = k_3\\,H_p\\,\\big(B_{\\text{tot}} - B_p\\big) - k_4\\,B_p $$\n        $$ \\frac{dA}{dt} = k_{\\text{tx}}\\,B_p - k_{\\text{deg}}\\,A $$\n    - **参数向量**：$\\theta = \\big(k_{\\text{on}},\\, k_{\\text{off}},\\, k_1,\\, k_2,\\, k_3,\\, k_4,\\, k_{\\text{tx}},\\, k_{\\text{deg}}\\big)$。\n    - **参数值**：\n        $k_{\\text{on}} = 1\\times 10^{-3}\\,\\text{nM}^{-1}\\,\\text{min}^{-1}$, $k_{\\text{off}} = 2\\times 10^{-2}\\,\\text{min}^{-1}$,\n        $k_1 = 2\\times 10^{-2}\\,\\text{nM}^{-1}\\,\\text{min}^{-1}$, $k_2 = 1\\times 10^{-1}\\,\\text{min}^{-1}$,\n        $k_3 = 2\\times 10^{-2}\\,\\text{nM}^{-1}\\,\\text{min}^{-1}$, $k_4 = 5\\times 10^{-2}\\,\\text{min}^{-1}$,\n        $k_{\\text{tx}} = 5\\times 10^{-1}\\,\\text{min}^{-1}$, $k_{\\text{deg}} = 2\\times 10^{-2}\\,\\text{min}^{-1}$。\n    - **分析方法**：\n        - 通过中心有限差分法计算的局部灵敏度矩阵 $S$，相对步长 $\\epsilon = 10^{-6}$。\n        - 费雪信息矩阵 $F = S^\\top S$。\n        - 通过 $S$ 的秩（使用SVD）进行可识别性评估，并通过列主元QR分解确定可识别参数集。\n    - **测试用例**：四个用例，指定了输入 $u_0$、采样时间以及可观测量（$A(t)$ 或 $A(t)$ 与 $B_p(t)$ 两者）。\n\n- **验证结论**：\n    - **科学依据充分**：该模型基于已建立的质量作用动力学原理，并代表了植物细胞信号传导中的一个典型通路。它在科学上是合理的。\n    - **适定性良好**：该问题提供了一个具有指定初始条件的一阶ODE系统和一个定义明确的计算任务（灵敏度分析）。存在唯一解，且分析程序是标准的。\n    - **客观且完整**：所有术语都经过数学定义。所有必需的参数、条件和程序均已提供。该问题是自包含的，没有歧义。\n    - **其他标准**：该问题不是微不足道的、不切实际的或不适定的。方程的量纲一致性已经得到验证。\n\n该问题被认为是有效的。我们可以继续进行求解。\n\n### 步骤2：求解方法\n\n问题的核心是为每个测试用例计算局部灵敏度矩阵 $S$，并分析其性质以确定参数的可识别性。灵敏度矩阵包含了模型输出相对于模型参数的偏导数，这些偏导数在标称参数值处进行评估。一个条目 $S_{ij}$ 由 $\\partial y_i / \\partial \\theta_j$ 给出，其中 $y_i$ 是第i个观测值，$\\theta_j$ 是第j个参数。\n\n1.  **ODE积分**：将使用适当的求解器对四个ODE组成的系统进行数值求解。鉴于生化动力学由于反应时间尺度的变化可能存在刚性问题，`scipy.integrate.solve_ivp`中可用的`BDF`（向后微分公式）方法是一个稳健的选择。这将封装在一个函数中，该函数为给定的参数集、输入和时间点模拟模型。\n\n2.  **灵敏度矩阵构建**：问题要求使用中心有限差分法来近似导数。对于每个参数 $\\theta_j$，我们使用扰动后的参数向量 $\\theta_{\\text{fwd}} = \\theta + \\delta_j$ 和 $\\theta_{\\text{bwd}} = \\theta - \\delta_j$ 来模拟模型，其中 $\\delta_j$ 是一个在第j个位置有一个小值而在其他位置为零的向量。步长将是 $\\Delta \\theta_j = \\epsilon \\cdot \\theta_j$，其中 $\\epsilon = 10^{-6}$。然后，灵敏度矩阵的第j列计算如下：\n    $$ S_{:,j} \\approx \\frac{y(\\theta_{\\text{fwd}}) - y(\\theta_{\\text{bwd}})}{2 \\Delta \\theta_j} $$\n    观测向量 $y$ 是指定可观测测量时间序列的串联（例如，$[A(t_1), ..., A(t_N), B_p(t_1), ..., B_p(t_N)]$）。\n\n3.  **可识别性分析**：\n    - **秩的确定**：灵敏度矩阵 $S$ 的数值秩决定了可识别参数（或可识别组合）的数量。满列秩（秩 = 参数数量，即8）表明所有参数都是局部可识别的。秩将使用 `numpy.linalg.matrix_rank` 计算，该方法采用基于奇异值分解（SVD）的方法。\n    - **可识别子集**：将使用列主元QR分解（`scipy.linalg.qr` 带 `pivoting=True` 参数）来确定一组特定的可识别参数。该算法对 $S$ 的列进行置换，将最线性无关的列移到前面。置换中前 `r` 列（其中 `r` 是秩）的索引对应于一组可识别的参数。将构造一个布尔列表来表示该集合。\n\n4.  **处理特殊情况 (u=0)**：对于测试用例3，输入 $u(t) = 0$。由于所有初始状态变量均为零，且系统没有外部输入驱动，因此无论参数值如何，所有状态变量将始终保持为零。因此，输出对任何参数都不敏感。灵敏度矩阵 $S$ 将是一个零矩阵，其秩为0，并且没有参数是可识别的。这种情况可以直接处理，无需数值计算。\n\n此过程将系统地应用于问题中定义的四个测试用例中的每一个，以生成最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import qr\nimport json\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem by analyzing the four specified test cases.\n    \"\"\"\n    # Define constants and nominal parameters as specified in the problem statement.\n    R_tot = 100.0  # nM\n    H_tot = 200.0  # nM\n    B_tot = 100.0  # nM\n\n    # Parameter vector theta\n    theta_nominal = np.array([\n        1.0e-3,  # k_on (nM^-1 min^-1)\n        2.0e-2,  # k_off (min^-1)\n        2.0e-2,  # k_1 (nM^-1 min^-1)\n        1.0e-1,  # k_2 (min^-1)\n        2.0e-2,  # k_3 (nM^-1 min^-1)\n        5.0e-2,  # k_4 (min^-1)\n        5.0e-1,  # k_tx (min^-1)\n        2.0e-2,  # k_deg (min^-1)\n    ])\n\n    # Initial conditions\n    initial_conditions = np.array([0.0, 0.0, 0.0, 0.0])  # [R_p, H_p, B_p, A]\n\n    # Relative step for finite differences\n    epsilon = 1.0e-6\n\n    def ode_system(t, y, u, theta):\n        \"\"\"\n        Defines the system of ordinary differential equations for cytokinin signaling.\n        State vector y: [R_p, H_p, B_p, A]\n        \"\"\"\n        R_p, H_p, B_p, A = y\n        k_on, k_off, k_1, k_2, k_3, k_4, k_tx, k_deg = theta\n\n        dR_p_dt = k_on * u * (R_tot - R_p) - k_off * R_p\n        dH_p_dt = k_1 * R_p * (H_tot - H_p) - k_2 * H_p\n        dB_p_dt = k_3 * H_p * (B_tot - B_p) - k_4 * B_p\n        dA_dt = k_tx * B_p - k_deg * A\n\n        return [dR_p_dt, dH_p_dt, dB_p_dt, dA_dt]\n\n    def simulate(theta, u0, t_eval, observables):\n        \"\"\"\n        Solves the ODE system for a given parameter set and returns specified observables.\n        \"\"\"\n        fun = lambda t, y: ode_system(t, y, u0, theta)\n\n        sol = solve_ivp(\n            fun,\n            (t_eval[0], t_eval[-1]),\n            initial_conditions,\n            t_eval=t_eval,\n            method='BDF',\n            atol=1e-9,  # Tighter tolerance for accurate finite differences\n            rtol=1e-9\n        )\n\n        _, _, Bp_sol, A_sol = sol.y\n\n        output_vec = []\n        if 'A' in observables:\n            output_vec.append(A_sol)\n        if 'Bp' in observables:\n            output_vec.append(Bp_sol)\n\n        return np.concatenate(output_vec)\n\n    def analyze_case(u0, t_eval, observables):\n        \"\"\"\n        Performs sensitivity analysis for a single experimental case.\n        \"\"\"\n        num_params = len(theta_nominal)\n\n        # Handle the trivial case where zero input leads to zero output\n        if u0 == 0.0:\n            rank = 0\n            is_identifiable = [False] * num_params\n            return [rank, is_identifiable]\n\n        y_nominal = simulate(theta_nominal, u0, t_eval, observables)\n        num_observations = len(y_nominal)\n        S = np.zeros((num_observations, num_params))\n\n        # Calculate sensitivity matrix S using central finite differences\n        for j in range(num_params):\n            param_val = theta_nominal[j]\n            delta = epsilon * param_val if param_val != 0 else epsilon\n\n            theta_fwd = theta_nominal.copy()\n            theta_fwd[j] += delta\n            y_fwd = simulate(theta_fwd, u0, t_eval, observables)\n\n            theta_bwd = theta_nominal.copy()\n            theta_bwd[j] -= delta\n            y_bwd = simulate(theta_bwd, u0, t_eval, observables)\n\n            S[:, j] = (y_fwd - y_bwd) / (2 * delta)\n\n        # Determine numerical rank using SVD\n        rank = np.linalg.matrix_rank(S)\n\n        # Find an identifiable subset using column-pivoted QR decomposition\n        _, _, p = qr(S, pivoting=True)\n        identifiable_indices = p[:rank]\n\n        is_identifiable = [False] * num_params\n        for idx in identifiable_indices:\n            is_identifiable[idx] = True\n\n        return [rank, is_identifiable]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: u0=50, t=[0,60], obs=[A]\n        (50.0, np.linspace(0, 60, 13), ['A']),\n        # Case 2: u0=50, t=[0,60], obs=[A, Bp]\n        (50.0, np.linspace(0, 60, 13), ['A', 'Bp']),\n        # Case 3: u0=0, t=[0,60], obs=[A]\n        (0.0, np.linspace(0, 60, 13), ['A']),\n        # Case 4: u0=50, t=[0,5], obs=[A, Bp]\n        (50.0, np.linspace(0, 5, 11), ['A', 'Bp']),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = analyze_case(*case_params)\n        results.append(result)\n\n    # Format the final output string as a list of lists, similar to a JSON array.\n    # This ensures a single-line, well-structured output as requested.\n    print(json.dumps(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2560945"}]}