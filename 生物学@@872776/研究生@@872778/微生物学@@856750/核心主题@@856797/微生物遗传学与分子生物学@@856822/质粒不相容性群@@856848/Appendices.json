{"hands_on_practices": [{"introduction": "理解质粒如何调节其自身数量是微生物学的基础。本练习探讨了一种基于 iteron 的拷贝数控制的确定性模型，其中复制受到质粒总浓度的负调控。通过推导稳态拷贝数，您将为细胞如何维持特定质粒类型的“承载能力”以及这如何构成不相容性的基础建立一个定量的直觉 [@problem_id:2522959]。", "problem": "在基于重复子（iteron）的质粒拷贝数控制中，随着携带重复子的质粒总数增加，复制起始会因配对（“手铐效应”）和起始子的滴定而被抑制。考虑一个充分混合的单个细菌细胞，其以比生长速率 $\\mu$ 进行指数生长，因此任何不进行复制的胞内物质都会以与其丰度成正比的速率被稀释，稀释系数为 $\\mu$。基于标准的种群平衡推理和重复子控制现象学，给出以下模型假设：\n\n1. 对于拷贝数为 $n(t)$ 的单一质粒种类，每个质粒都以一个时间均一的速率独立地尝试复制起始，该速率随重复子位点总数的增加而降低。我们用每个质粒的起始速率 $k/(1+\\alpha n)$ 来对此进行建模，其中 $k0$ 是基础起始常数，$\\alpha0$ 量化了重复子耦合导致的起始抑制强度。\n2. 每次成功的起始都会瞬时产生一个额外的质粒拷贝。\n3. 速率为 $\\mu$ 的指数细胞生长导致质粒被稀释，这在拷贝数平衡中被确定性地建模为一阶损失项 $\\mu n(t)$。\n4. 参数满足 $k\\mu$ 和 $\\alpha0$，以确保存在正稳态。\n\nA部分。从这些假设出发，且不假定任何预先推导的拷贝数公式，写出 $n(t)$ 的质量平衡方程，并推导单一质粒种类的唯一正稳态拷贝数 $n^{\\ast}$。\n\nB部分。现在引入第二种质粒，其具有相同的重复子序列、相同的动力学参数 $k$、$\\alpha$ 和相同的细胞生长速率 $\\mu$。令 $n_{1}(t)$ 和 $n_{2}(t)$ 表示它们的拷贝数。由于重复子相同且存在交叉相互作用，每种质粒的起始抑制取决于重复子的总丰度。在与上述相同的假设下，但增加了交叉抑制，推导耦合的质量平衡方程，并确定稳态如何变化。特别地，用总拷贝数 $N(t)=n_{1}(t)+n_{2}(t)$ 来描述稳态条件，并在 $n_{1}=n_{2}$ 的对称分支上，确定每种质粒的稳态拷贝数 $n_{\\mathrm{sym}}^{\\ast}$。\n\n将你的最终答案表示为一个两元素行向量，其中包含单一质粒的稳态 $n^{\\ast}$ 和两种相同质粒共存时的对称分支下每种质粒的稳态 $n_{\\mathrm{sym}}^{\\ast}$。不需要进行数值计算。请用 $k$、$\\alpha$ 和 $\\mu$ 以闭式解析表达式的形式给出答案。不要包含单位。如果你选择提供任何数值近似，也请提供精确表达式；本题不需要四舍五入说明。", "solution": "所述问题在科学上是合理的、适定的，并包含足够的信息以获得唯一的解析解。它描述了一个基于重复子的质粒拷贝数控制的标准确定性模型，这是分子微生物学中的一个基本课题。我们将开始推导。\n\nA部分：单一质粒种类\n\n质粒拷贝数 $n(t)$ 的动力学由一个质量平衡方程控制。$n(t)$ 的变化率，记作 $\\frac{dn}{dt}$，是质粒复制总速率与因稀释导致的质粒损失总速率之差。\n\n1. 生成项：$n$ 个质粒中的每一个都以速率 $\\frac{k}{1+\\alpha n}$ 起始复制。由于每次成功的起始事件都会产生一个新的质粒，因此总生成速率是质粒数量与每个质粒起始速率的乘积。\n$$\n\\text{复制速率} = n \\left( \\frac{k}{1+\\alpha n} \\right) = \\frac{kn}{1+\\alpha n}\n$$\n\n2. 损失项：细胞以比生长速率 $\\mu$ 指数生长。这导致胞内质粒浓度的稀释，该过程被建模为一阶损失过程。总损失速率与拷贝数 $n$ 成正比。\n$$\n\\text{稀释速率} = \\mu n\n$$\n\n3. 因此，完整的质量平衡方程为：\n$$\n\\frac{dn}{dt} = \\frac{kn}{1+\\alpha n} - \\mu n\n$$\n为了找到稳态拷贝数 $n^{\\ast}$，我们将变化率设为零，即 $\\frac{dn}{dt} = 0$。\n$$\n\\frac{kn^{\\ast}}{1+\\alpha n^{\\ast}} - \\mu n^{\\ast} = 0\n$$\n该方程可以因式分解为：\n$$\nn^{\\ast} \\left( \\frac{k}{1+\\alpha n^{\\ast}} - \\mu \\right) = 0\n$$\n该方程有两个解。第一个是平凡解 $n^{\\ast} = 0$，对应于质粒的消失。第二个非平凡解是通过将括号中的项设为零来找到的。这对应于我们寻求的正稳态。\n$$\n\\frac{k}{1+\\alpha n^{\\ast}} - \\mu = 0\n$$\n问题陈述了 $k > \\mu$ 和 $\\alpha > 0$，这保证了正的 $n^{\\ast}$ 的存在。我们现在求解 $n^{\\ast}$：\n$$\n\\frac{k}{1+\\alpha n^{\\ast}} = \\mu\n$$\n$$\nk = \\mu(1+\\alpha n^{\\ast})\n$$\n$$\nk = \\mu + \\mu \\alpha n^{\\ast}\n$$\n$$\nk - \\mu = \\mu \\alpha n^{\\ast}\n$$\n单一质粒种类的唯一正稳态拷贝数为：\n$$\nn^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\n\nB部分：两种共存的质粒\n\n我们现在引入第二种质粒，其拷贝数为 $n_{2}(t)$，具有相同的重复子序列和动力学参数 $k$ 和 $\\alpha$。细胞生长速率 $\\mu$ 保持不变。关键的修改是每种质粒的复制起始都受到携带重复子的质粒*总数* $N(t) = n_{1}(t) + n_{2}(t)$ 的抑制。\n\n1. 耦合的质量平衡方程遵循与A部分相同的逻辑构建。对于质粒种类1，其生成速率取决于自身的拷贝数 $n_{1}$ 和总拷贝数 $N = n_{1}+n_{2}$。稀释速率仍为 $\\mu n_{1}$。\n$$\n\\frac{dn_{1}}{dt} = n_{1} \\left( \\frac{k}{1+\\alpha(n_{1}+n_{2})} \\right) - \\mu n_{1}\n$$\n根据对称性，质粒种类2的方程为：\n$$\n\\frac{dn_{2}}{dt} = n_{2} \\left( \\frac{k}{1+\\alpha(n_{1}+n_{2})} \\right) - \\mu n_{2}\n$$\n\n2. 为了用总拷贝数 $N(t)$ 来描述稳态，我们通过将两个独立的速率方程相加来推导 $\\frac{dN}{dt}$ 的方程：\n$$\n\\frac{dN}{dt} = \\frac{dn_{1}}{dt} + \\frac{dn_{2}}{dt} = \\left[ n_{1} \\frac{k}{1+\\alpha N} - \\mu n_{1} \\right] + \\left[ n_{2} \\frac{k}{1+\\alpha N} - \\mu n_{2} \\right]\n$$\n对各项进行因式分解，我们得到：\n$$\n\\frac{dN}{dt} = (n_{1}+n_{2}) \\frac{k}{1+\\alpha N} - \\mu (n_{1}+n_{2})\n$$\n代入 $N = n_{1}+n_{2}$：\n$$\n\\frac{dN}{dt} = N \\frac{k}{1+\\alpha N} - \\mu N\n$$\n这个关于总拷贝数 $N(t)$ 的方程在数学上与A部分中推导的单一质粒拷贝数 $n(t)$ 的方程是相同的。因此，总稳态拷贝数 $N^{\\ast} = n_{1}^{\\ast} + n_{2}^{\\ast}$ 必然与单一质粒的稳态拷贝数 $n^{\\ast}$ 相同。\n$$\nN^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\n这个结果表明，对于共享相同基于重复子的复制控制系统的质粒，其总承载能力由参数 $k$、$\\alpha$ 和 $\\mu$ 决定。\n\n3. 问题要求在对称分支（其中 $n_{1} = n_{2} = n_{\\mathrm{sym}}^{\\ast}$）上每种质粒的稳态拷贝数。在这个对称稳态下，总拷贝数为 $N^{\\ast} = n_{\\mathrm{sym}}^{\\ast} + n_{\\mathrm{sym}}^{\\ast} = 2n_{\\mathrm{sym}}^{\\ast}$。\n我们将其与 $N^{\\ast}$ 的表达式相等：\n$$\n2n_{\\mathrm{sym}}^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\n求解对称分支下每种质粒的稳态 $n_{\\mathrm{sym}}^{\\ast}$：\n$$\nn_{\\mathrm{sym}}^{\\ast} = \\frac{1}{2} \\left( \\frac{k-\\mu}{\\mu \\alpha} \\right) = \\frac{k-\\mu}{2\\mu \\alpha}\n$$\n因此，当两种相同的质粒共存时，它们会对等地共享总的可用拷贝数，每种质粒维持的拷贝数是单一质粒单独存在时所能达到的一半。这就是此类质粒的质粒不相容性的数学基础。\n\n最终答案是包含 $n^{\\ast}$ 和 $n_{\\mathrm{sym}}^{\\ast}$ 的两元素行向量。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{k-\\mu}{\\mu \\alpha}  \\frac{k-\\mu}{2\\mu \\alpha} \\end{pmatrix}}\n$$", "id": "2522959"}, {"introduction": "虽然确定性模型提供了很好的初步近似，但细胞内质粒的最终命运是一个随机过程。本练习要求您实现一个生灭模型（一种连续时间马尔可夫链），以模拟两种不相容质粒之间的竞争。通过计算一种质粒的灭绝概率，您将直接体会到质粒不相容性的概率本质，并理解随机波动如何导致一种质粒从细胞谱系中丢失 [@problem_id:2522995]。", "problem": "你需要为一个连续时间马尔可夫链建立形式化模型，该模型描述了两种共存于同一细胞内的质粒。这两种质粒共享一个复制控制机制，从而表现出质粒不相容群特有的交叉抑制特性。该过程模拟了单个细胞内两种质粒类型（由 $i \\in \\{1,2\\}$ 索引）的拷贝数随机波动。你的程序必须针对指定的参数和初始拷贝数，计算质粒 $1$ 在质粒 $2$ 绝迹之前先绝迹（其拷贝数首次达到 $0$）的概率。所有概率必须以小数形式报告，并精确到六位小数。\n\n你的公式应基于以下基本生物学定义和经过充分检验的、适用于质粒不相容性的建模假设：复制中的共享负反馈响应总拷贝数，以及由于降解或细胞分裂时的分配而发生的随机丢失。将这些假设编码为一个有限状态空间上的连续时间生灭过程。\n\n1. 状态空间：\n   - 状态为 $(n_1,n_2)$，其中 $n_1 \\in \\mathbb{Z}_{\\ge 0}$ 和 $n_2 \\in \\mathbb{Z}_{\\ge 0}$ 受 $n_1 + n_2 \\le K$ 约束，其中 $K$ 是一个限制总拷贝数的固定容量参数。\n   - 为了“哪个质粒先丢失”这一事件的目的，边界状态 $(0,n_2)$（其中 $n_2  0$）和 $(n_1,0)$（其中 $n_1  0$）是吸收态，定义如下。状态 $(0,0)$ 不是测试套件中的有效初始状态。\n\n2. 转移和速率：\n   - 质粒 $i$ 的复制（出生）使 $n_i$ 增加 $1$，其速率为\n     $$ b_i(n_1,n_2) \\;=\\; \\alpha_i\\, n_i \\,\\max\\!\\Big(0,\\; 1 - \\frac{n_1+n_2}{K} \\Big), $$\n     其中 $\\alpha_i$ 是内在的单位拷贝复制尝试速率，$\\max(0,\\cdot)$ 因子基于总拷贝数强制执行共享负反馈。只有在 $n_1+n_2  K$ 的状态下才能进行复制。\n   - 质粒 $i$ 的丢失（死亡）使 $n_i$ 减少 $1$，其速率为\n     $$ d_i(n_1,n_2) \\;=\\; \\delta_i\\, n_i, $$\n     其中 $\\delta_i$ 是代表降解和分配噪声的单位拷贝丢失速率。\n   - 不发生其他转移。\n\n3. 关注事件和绝迹概率：\n   - 定义 $T_1$ 为马尔可夫链到达集合 $\\{(0,n_2): n_2 \\ge 0\\}$ 的首达时间，定义 $T_2$ 为到达集合 $\\{(n_1,0): n_1 \\ge 0\\}$ 的首达时间。\n   - 对于任何初始状态 $(n_1,n_2)$（其中 $n_10$ 且 $n_20$），定义\n     $$ h(n_1,n_2) \\;=\\; \\mathbb{P}\\big( T_1  T_2 \\,\\big|\\, (n_1(0),n_2(0))=(n_1,n_2) \\big), $$\n     即质粒 $1$ 在质粒 $2$ 之前绝迹的概率。\n   - 边界条件是：\n     $$ h(0,n_2) \\;=\\; 1 \\quad \\text{对于 } n_20, \\qquad h(n_1,0) \\;=\\; 0 \\quad \\text{对于 } n_10. $$\n\n4. 计算任务：\n   - 将上述问题表述为一个从连续时间马尔可夫链的首步分析推导出的线性系统，并在指定参数下求解有限状态空间上的 $h(n_1,n_2)$。\n   - 你的程序必须为下面测试套件中的每个参数集计算 $h(n_1,n_2)$，并生成一行输出，其中包含所有结果，形式为用方括号括起来的逗号分隔列表，每个值精确到六位小数。\n\n5. 测试套件：\n   使用以下参数集，其中 $K$ 是容量，$\\alpha_1$ 和 $\\alpha_2$ 是复制参数，$\\delta_1$ 和 $\\delta_2$ 是丢失参数，$(n_1,n_2)$ 是初始状态。所有数值均应解释为无量纲的速率或计数：\n   - 测试 $1$：$K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(2,2)$。\n   - 测试 $2$：$K=10$, $\\alpha_1=1.2$, $\\alpha_2=0.8$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(2,2)$。\n   - 测试 $3$：$K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(0,5)$。\n   - 测试 $4$：$K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(5,0)$。\n   - 测试 $5$：$K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(7,1)$。\n\n6. 最终输出格式：\n   - 你的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表，结果顺序与上述测试相同，例如\n     $$ [x_1,x_2,x_3,x_4,x_5] $$\n     其中每个 $x_i$ 是一个精确到六位小数的十进制数。不要打印任何其他文本。\n\n你的推导必须从连续时间马尔可夫链和首步分析的核心定义出发，并基于共享复制控制依赖于总拷贝数的生物学假设。你不能直接使用目标快捷公式；必须从生成元表征或首步分解推导出确定 $h(n_1,n_2)$ 的线性方程组。此问题不涉及物理单位或角度。所有概率必须以小数形式报告，并精确到六位小数，而不是百分比。", "solution": "该问题要求计算两种共存质粒类型中一种的绝迹概率，这是质粒不相容性研究中的一个核心场景。该系统被建模为有限二维状态空间上的一个连续时间马尔可夫链 (CTMC)。需要计算的量是 $h(n_1, n_2)$，即给定初始拷贝数 $(n_1, n_2)$，质粒类型1在质粒类型2之前绝迹的概率。这是一个标准的首达hitting概率问题。\n\n系统的状态由非负整数对 $(n_1, n_2)$ 给出，表示两种质粒类型的拷贝数。状态空间受总拷贝数容量 $K$ 的约束，因此 $\\mathcal{S} = \\{(n_1, n_2) \\in \\mathbb{Z}_{\\ge 0} \\times \\mathbb{Z}_{\\ge 0} \\mid n_1 + n_2 \\le K\\}$。该状态空间可以划分为与问题相关的三个不相交的集合：\n1. 内部状态或瞬时状态集合 $\\mathcal{S}_T = \\{(n_1, n_2) \\in \\mathcal{S} \\mid n_1  0, n_2  0\\}$。这些状态的所需概率是我们必须求解的未知数。\n2. 质粒1绝迹的目标吸收边界 $\\mathcal{B}_1 = \\{(0, n_2) \\in \\mathcal{S} \\mid n_2  0\\}$。\n3. 质粒2绝迹的竞争吸收边界 $\\mathcal{B}_2 = \\{(n_1, 0) \\in \\mathcal{S} \\mid n_1  0\\}$。\n\n概率函数 $h(n_1, n_2) = \\mathbb{P}(T_1  T_2 \\mid (n_1(0), n_2(0))=(n_1, n_2))$（其中 $T_i$ 是首次到达 $n_i=0$ 集合的时间）必须满足问题定义中指定的边界条件：\n- 对于目标边界上的任何状态，如果 $(n_1, n_2) \\in \\mathcal{B}_1$，则 $h(n_1, n_2) = 1$。这是因为质粒1已经绝迹。\n- 对于竞争边界上的任何状态，如果 $(n_1, n_2) \\in \\mathcal{B}_2$，则 $h(n_1, n_2) = 0$。这是因为质粒2先绝迹（或同时绝迹，对于CTMC来说，其概率为零，但无论如何，$T_1  T_2$ 事件没有发生）。\n\n对于任何内部状态 $(n_1, n_2) \\in \\mathcal{S}_T$，值 $h(n_1, n_2)$ 由一组通过首步分析推导出的线性方程控制。对于CTMC，任何有界调和函数（hitting概率即是）必须对所有瞬时状态 $x$ 满足 $(\\mathcal{L}h)(x)=0$，其中 $\\mathcal{L}$ 是过程的生成元。生成元在状态 $x$ 对函数 $f$ 的作用定义为 $(\\mathcal{L}f)(x) = \\sum_{y \\ne x} q_{x \\to y} (f(y) - f(x))$，其中 $q_{x \\to y}$ 是从状态 $x$ 到状态 $y$ 的转移速率。\n\n从任意状态 $(n_1, n_2)$ 指定的转移速率如下：\n- 质粒1的复制：以速率 $b_1(n_1, n_2) = \\alpha_1 n_1 \\max(0, 1 - \\frac{n_1+n_2}{K})$ 转移到 $(n_1+1, n_2)$。\n- 质粒2的复制：以速率 $b_2(n_1, n_2) = \\alpha_2 n_2 \\max(0, 1 - \\frac{n_1+n_2}{K})$ 转移到 $(n_1, n_2+1)$。\n- 质粒1的丢失：以速率 $d_1(n_1, n_2) = \\delta_1 n_1$ 转移到 $(n_1-1, n_2)$。\n- 质粒2的丢失：以速率 $d_2(n_1, n_2) = \\delta_2 n_2$ 转移到 $(n_1, n_2-1)$。\n\n对 $(n_1, n_2) \\in \\mathcal{S}_T$ 设定 $(\\mathcal{L}h)(n_1, n_2) = 0$ 可得以下方程：\n$$ b_1(n_1, n_2) [h(n_1+1, n_2) - h(n_1, n_2)] + b_2(n_1, n_2) [h(n_1, n_2+1) - h(n_1, n_2)] $$\n$$ + d_1(n_1, n_2) [h(n_1-1, n_2) - h(n_1, n_2)] + d_2(n_1, n_2) [h(n_1, n_2-1) - h(n_1, n_2)] = 0 $$\n\n该方程将状态 $(n_1, n_2)$ 的未知概率与其四个邻近状态的概率联系起来。我们可以通过组合涉及 $h(n_1, n_2)$ 的项来重新整理此方程：\n$$ Q(n_1, n_2) h(n_1, n_2) - b_1(n_1, n_2) h(n_1+1, n_2) - b_2(n_1, n_2) h(n_1, n_2+1) - d_1(n_1, n_2) h(n_1-1, n_2) - d_2(n_1, n_2) h(n_1, n_2-1) = 0 $$\n其中 $Q(n_1, n_2) = b_1(n_1, n_2) + b_2(n_1, n_2) + d_1(n_1, n_2) + d_2(n_1, n_2)$ 是离开状态 $(n_1, n_2)$ 的总速率。\n\n这为每个内部状态 $(n_1, n_2) \\in \\mathcal{S}_T$ 提供了一个线性方程。此类状态的数量为 $|\\mathcal{S}_T| = \\sum_{s=2}^{K} (s-1) = \\frac{(K-1)K}{2}$。对于 $K=10$，我们有 $45$ 个未知概率，从而得到一个 $45 \\times 45$ 的线性方程组。\n\n我们将此系统表述为矩阵形式 $Ax = b$。向量 $x$ 包含所有 $(n_1, n_2) \\in \\mathcal{S}_T$ 的未知概率 $h(n_1, n_2)$。构建过程如下：\n1. 建立一个索引方案，将每个状态 $(n_1, n_2) \\in \\mathcal{S}_T$ 映射到一个唯一的索引 $k \\in \\{0, 1, \\dots, |\\mathcal{S}_T|-1\\}$。\n2. 对于每个索引为 $k$ 的状态 $(n_1, n_2)$，我们构建矩阵 $A$ 的第 $k$ 行和向量 $b$ 的第 $k$ 个元素。\n3. 对角元素 $A_{kk}$ 设置为总离开速率 $Q(n_1, n_2)$。\n4. 非对角元素 $A_{kj}$ 设置为从状态 $k$ 到状态 $j$ 的转移速率的负值，前提是状态 $j$ 也是一个内部状态。\n5. 如果转移导致一个边界状态，则使用其已知的 $h$ 值。对于从 $(n_1, n_2)$ 到 $(n_1-1, n_2)$ 且 $n_1-1=0$ 的转移，我们有 $h(0, n_2)=1$。项 $d_1(1, n_2)h(0, n_2) = d_1(1, n_2) = \\delta_1$ 被移到右侧，成为对元素 $b_k$ 的贡献。对于到边界 $\\mathcal{B}_2$ 上 $h=0$ 的状态的转移，对右侧的贡献为零。\n\n具体来说，对于每个索引为 $k$ 的内部状态 $(n_1, n_2)$，其对应的方程是：\n$$ A_{kk}x_k + \\sum_{j \\ne k, j \\in \\text{indices of } \\mathcal{S}_T} A_{kj}x_j = b_k. $$\n$A_{kk} = Q(n_1, n_2)$。\n对于索引为 $j$ 的邻居 $(n'_1, n'_2)$，$A_{kj} = -q_{(n_1, n_2) \\to (n'_1, n'_2)}$。\n向量 $b_k$ 是对于所有边界邻居 $(n''_1, n''_2)$ 的项 $q_{(n_1, n_2) \\to (n''_1, n''_2)} h(n''_1, n''_2)$ 的总和。在我们的例子中，这意味着如果 $n_1=1$，则 $b_k = \\delta_1$，否则 $b_k=0$，因为只有到 $\\mathcal{B}_1$ 的转移有贡献。\n\n得到的线性系统 $Ax=b$ 通过数值方法求解。解向量 $x$ 提供了所有内部起始状态所需的概率。对于初始状态在边界上的测试用例，概率直接给出为 $1$ 或 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the calculation for different parameter sets\n    and collects the results.\n    \"\"\"\n\n    test_cases = [\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (2, 2)},\n        {'K': 10, 'alpha1': 1.2, 'alpha2': 0.8, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (2, 2)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (0, 5)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (5, 0)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (7, 1)},\n    ]\n\n    # Cache solutions for parameter sets to avoid re-computation\n    # Key is a tuple of parameters (K, alpha1, alpha2, delta1, delta2)\n    # Value is the dictionary of h(n1, n2) values\n    h_solutions_cache = {}\n    \n    results = []\n\n    for case in test_cases:\n        K = case['K']\n        alpha1 = case['alpha1']\n        alpha2 = case['alpha2']\n        delta1 = case['delta1']\n        delta2 = case['delta2']\n        n1_init, n2_init = case['initial_n']\n\n        # Handle boundary cases directly\n        if n1_init == 0:\n            results.append(1.0)\n            continue\n        if n2_init == 0:\n            results.append(0.0)\n            continue\n            \n        param_key = (K, alpha1, alpha2, delta1, delta2)\n\n        if param_key not in h_solutions_cache:\n            h_solutions_cache[param_key] = compute_extinction_probabilities(K, alpha1, alpha2, delta1, delta2)\n\n        h_solution = h_solutions_cache[param_key]\n        result = h_solution.get((n1_init, n2_init))\n        if result is not None:\n            results.append(result)\n        else:\n            # Should not happen for valid interior states\n            raise ValueError(f\"Solution for state {(n1_init, n2_init)} not found.\")\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\ndef compute_extinction_probabilities(K, alpha1, alpha2, delta1, delta2):\n    \"\"\"\n    Formulates and solves the linear system for h(n1, n2).\n    \n    Returns:\n        A dictionary mapping interior states (n1, n2) to their\n        extinction probabilities h(n1, n2).\n    \"\"\"\n    \n    # 1. Map interior states (n1>0, n2>0, n1+n2=K) to indices\n    state_to_idx = {}\n    idx_to_state = []\n    idx = 0\n    # Total copy number s = n1 + n2\n    for s in range(2, K + 1):\n        # n1 runs from 1 to s-1, ensuring n1>0 and n2=s-n1>0\n        for n1 in range(1, s):\n            n2 = s - n1\n            state = (n1, n2)\n            state_to_idx[state] = idx\n            idx_to_state.append(state)\n            idx += 1\n    \n    num_interior_states = len(idx_to_state)\n    \n    # 2. Build the linear system Ax = b\n    A = np.zeros((num_interior_states, num_interior_states))\n    b = np.zeros(num_interior_states)\n    \n    for k in range(num_interior_states):\n        n1, n2 = idx_to_state[k]\n        \n        # Calculate transition rates from state (n1, n2)\n        total_n = n1 + n2\n        rep_factor = max(0, 1 - total_n / K)\n        \n        b1_rate = alpha1 * n1 * rep_factor\n        b2_rate = alpha2 * n2 * rep_factor\n        d1_rate = delta1 * n1\n        d2_rate = delta2 * n2\n        \n        total_q = b1_rate + b2_rate + d1_rate + d2_rate\n        A[k, k] = total_q\n        \n        # Transitions to neighboring states\n        \n        # a) Replication of plasmid 1: (n1+1, n2)\n        # This is only possible if total_n  K\n        if total_n  K:\n            neighbor_state = (n1 + 1, n2)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -b1_rate\n        \n        # b) Replication of plasmid 2: (n1, n2+1)\n        # This is only possible if total_n  K\n        if total_n  K:\n            neighbor_state = (n1, n2 + 1)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -b2_rate\n            \n        # c) Loss of plasmid 1: (n1-1, n2)\n        if n1 - 1 > 0:\n            # Neighbor is an interior state\n            neighbor_state = (n1 - 1, n2)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -d1_rate\n        else:\n            # Neighbor is on the boundary {n1=0}, where h=1\n            b[k] += d1_rate * 1.0\n            \n        # d) Loss of plasmid 2: (n1, n2-1)\n        if n2 - 1 > 0:\n            # Neighbor is an interior state\n            neighbor_state = (n1, n2 - 1)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -d2_rate\n        else:\n            # Neighbor is on the boundary {n2=0}, where h=0\n            b[k] += d2_rate * 0.0\n\n    # 3. Solve the linear system Ax = b\n    h_vector = np.linalg.solve(A, b)\n    \n    # 4. Create a dictionary of solutions\n    h_solutions = {idx_to_state[i]: h_vector[i] for i in range(num_interior_states)}\n    \n    return h_solutions\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2522995"}, {"introduction": "在现代基因组学中，我们常常需要直接从DNA序列预测质粒的特性，例如其不相容性组。这个问题将指导您构建一个朴素贝叶斯分类器，这是一个用于分类任务的强大概率工具。您将学习如何整合不同的生物学特征——在此案例中为 Rep 蛋白相似性和 iteron 基序的存在与否——来对质粒的 Inc 组进行原则性的、数据驱动的预测，这是计算微生物学中的一项核心技能 [@problem_id:2522962]。", "problem": "要求您形式化一个基于原则的贝叶斯分类器，用于质粒不相容性（Inc）群的分配。该分类器整合了从质粒中提取的两个具有生物学动机的特征：（i）复制起始蛋白（Rep）序列相似性和（ii）迭代子基序的存在与否。在细菌质粒生物学中，Inc 群是根据操作定义的一组质粒，由于共享复制控制系统，它们无法稳定地共存于同一个细胞中；这些系统通常涉及 Rep 蛋白和迭代子重复序列。您的任务是实现一个分类器，对于每个测试用例，给定一个标量 Rep 相似性得分和一个二元迭代子基序指示符，计算其在一组固定的 Inc 群上的后验概率。\n\n使用以下基本基础：\n- 贝叶斯定理：对于离散类别变量 $G$ 和观测特征 $X$，后验概率为\n$$\nP(G=g \\mid X) \\;=\\; \\frac{P(X \\mid G=g)\\,P(G=g)}{\\sum_{h} P(X \\mid G=h)\\,P(G=h)}\n$$\n- 条件独立性假设：以 $G$ 为条件，各特征是独立的。\n- Beta 分布用于 $[0,1]$ 上的相似性得分，伯努利分布用于二元基序存在与否，这两种分布都广泛用于为此类数据类型建模。\n\n模型设定：\n- 设类别变量 $G$ 在有序集合 $\\{ \\text{IncF}, \\text{IncI}, \\text{IncP}, \\text{IncQ} \\}$ 中取值。\n- 设观测特征向量为 $(s, m)$，其中 $s \\in [0,1]$ 是 Rep 相似性得分（无单位分数），$m \\in \\{0,1\\}$ 指示迭代子基序的存在（$m=1$）或不存在（$m=0$）。\n- 假设以下生成模型：\n  - 类别的先验概率：$P(G=g) = \\pi\\_g$。\n  - 相似性得分的似然：$s \\mid (G=g) \\sim \\mathrm{Beta}(\\alpha\\_g, \\beta\\_g)$，其概率密度为\n    $$\n    f\\_g(s) \\;=\\; \\frac{s^{\\alpha\\_g-1} (1-s)^{\\beta\\_g-1}}{B(\\alpha\\_g,\\beta\\_g)}\n    $$\n    其中 $B(\\cdot,\\cdot)$ 是贝塔函数。\n  - 基序指示符的似然：$m \\mid (G=g) \\sim \\mathrm{Bernoulli}(\\rho\\_g)$，其概率质量函数为\n    $$\n    p\\_g(m) \\;=\\; \\rho\\_g^{\\,m}\\,(1-\\rho\\_g)^{\\,1-m}\n    $$\n  - 条件独立性：$P(s,m \\mid G=g) = f\\_g(s)\\,p\\_g(m)$。\n- 因此，对于给定的 $(s,m)$，每个群组 $g$ 的后验概率为\n$$\nP(G=g \\mid s,m) \\;=\\; \\frac{\\pi\\_g \\, f\\_g(s) \\, p\\_g(m)}{\\sum_{h \\in \\{\\text{IncF},\\text{IncI},\\text{IncP},\\text{IncQ}\\}} \\pi\\_h \\, f\\_h(s) \\, p\\_h(m)}\n$$\n\n使用以下固定的参数值，严格按照群组顺序 $\\{\\text{IncF},\\text{IncI},\\text{IncP},\\text{IncQ}\\}$：\n- 先验概率 $\\pi$：$\\pi = [0.35,\\, 0.25,\\, 0.25,\\, 0.15]$。\n- Beta 参数 $(\\alpha, \\beta)$：\n  - IncF: $(\\alpha, \\beta) = (22, 4)$,\n  - IncI: $(\\alpha, \\beta) = (12, 6)$,\n  - IncP: $(\\alpha, \\beta) = (6, 12)$,\n  - IncQ: $(\\alpha, \\beta) = (3, 3)$。\n- 伯努利参数 $\\rho$（基序存在概率）：\n  - IncF: $\\rho = 0.9$,\n  - IncI: $\\rho = 0.6$,\n  - IncP: $\\rho = 0.2$,\n  - IncQ: $\\rho = 0.5$。\n\n数值稳定性要求：\n- 在计算 $s$、$1-s$、$\\rho$ 和 $1-\\rho$ 的对数时，在取对数之前，将每个参数裁剪到闭区间 $[\\varepsilon, 1-\\varepsilon]$ 内，其中 $\\varepsilon = 10^{-12}$。\n- 可以接受使用 log-sum-exp 技巧在对数空间中计算后验概率。\n\n您的程序必须实现一个分类器，对于每个测试用例 $(s,m)$，返回后验概率向量\n$$\n\\left[P(G=\\text{IncF} \\mid s,m),\\, P(G=\\text{IncI} \\mid s,m),\\, P(G=\\text{IncP} \\mid s,m),\\, P(G=\\text{IncQ} \\mid s,m)\\right].\n$$\n\n测试集：\n严格按照以下顺序计算六个用例的后验概率，其中每个 $s$ 是无单位的，每个 $m$ 是 $\\{0,1\\}$ 中的整数：\n1. $(s,m) = (0.92, 1)$,\n2. $(s,m) = (0.78, 0)$,\n3. $(s,m) = (0.30, 1)$,\n4. $(s,m) = (0.55, 0)$,\n5. $(s,m) = (1.00, 0)$,\n6. $(s,m) = (0.00, 1)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由六个后验概率向量组成的列表，每个测试用例一个，并按指定的群组顺序排列。每个后验概率向量必须是包含四个浮点数的列表，小数点后精确到六位。总输出必须是一个列表的列表，行内任何地方都没有空格。例如，包含两个用例的输出应如下所示\n$$\n[[0.100000,0.200000,0.300000,0.400000],[0.250000,0.250000,0.250000,0.250000]].\n$$\n- 对于此问题，您必须生成\n$$\n\\left[\\text{post}(0.92,1),\\,\\text{post}(0.78,0),\\,\\text{post}(0.30,1),\\,\\text{post}(0.55,0),\\,\\text{post}(1.00,0),\\,\\text{post}(0.00,1)\\right]\n$$\n其中每个 $\\text{post}(s,m)$ 都按规定进行四舍五入，并严格按照上述顺序排列。", "solution": "该问题要求制定并实现一个朴素贝叶斯分类器，以确定一组质粒不相容性（Inc）群上的后验概率分布。给定两个特征：一个复制起始蛋白（Rep）相似性得分 $s$ 和一个指示迭代子基序是否存在的二元指示符 $m$。\n\n该问题已经过验证，被认为是科学上合理、定义明确且客观的。它展示了贝叶斯统计推断在计算生物学问题中的一个标准应用。所有必需的参数和定义都已提供，任务是直接实现指定的模型。\n\n分类器的核心是贝叶斯定理，它将一个类别（Inc 群 $g$）的后验概率与该类别的先验概率以及给定该类别下观测到数据的似然联系起来。类别变量 $G$ 可以从集合 $\\{\\text{IncF}, \\text{IncI}, \\text{IncP}, \\text{IncQ}\\}$ 中取四个值之一。观测到的特征是向量 $X = (s,m)$，其中 $s \\in [0,1]$ 是相似性得分，$m \\in \\{0,1\\}$ 是基序指示符。\n\n一个群组 $g$ 的后验概率由以下公式给出：\n$$\nP(G=g \\mid s,m) = \\frac{P(s,m \\mid G=g) P(G=g)}{\\sum_{h} P(s,m \\mid G=h) P(G=h)}\n$$\n问题指定了一个条件独立性（朴素贝叶斯）假设，意味着在给定群组 $G$ 的条件下，特征 $s$ 和 $m$ 是独立的。因此，似然项可以分解为：\n$$\nP(s,m \\mid G=g) = P(s \\mid G=g) P(m \\mid G=g)\n$$\n模型各组成部分定义如下：\n1.  **先验概率**：一个质粒属于 Inc 群 $g$ 的先验概率表示为 $P(G=g) = \\pi_g$。\n2.  **相似性得分的似然**：得分 $s$，以群组 $g$ 为条件，由 Beta 分布建模，$s \\mid (G=g) \\sim \\mathrm{Beta}(\\alpha_g, \\beta_g)$。其概率密度函数（PDF）为 $f_g(s)$：\n    $$\n    f_g(s) = P(s \\mid G=g) = \\frac{s^{\\alpha_g-1} (1-s)^{\\beta_g-1}}{B(\\alpha_g,\\beta_g)}\n    $$\n    其中 $B(\\alpha_g, \\beta_g)$ 是贝塔函数。\n3.  **基序指示符的似然**：基序指示符 $m$，以群组 $g$ 为条件，由伯努利分布建模，$m \\mid (G=g) \\sim \\mathrm{Bernoulli}(\\rho_g)$。其概率质量函数（PMF）为 $p_g(m)$：\n    $$\n    p_g(m) = P(m \\mid G=g) = \\rho_g^m (1-\\rho_g)^{1-m}\n    $$\n将这些代入后验概率公式，得到：\n$$\nP(G=g \\mid s,m) = \\frac{\\pi_g f_g(s) p_g(m)}{\\sum_{h} \\pi_h f_h(s) p_h(m)}\n$$\n直接计算此表达式可能会因乘以较小的概率值而导致数值下溢。一种更稳定的方法是在对数空间中进行运算。群组 $g$ 的未归一化的对数后验概率，或称对数联合概率，是：\n$$\n\\log J(g; s,m) = \\log\\left(\\pi_g f_g(s) p_g(m)\\right) = \\log(\\pi_g) + \\log(f_g(s)) + \\log(p_g(m))\n$$\n展开对数似然项：\n$$\n\\log(f_g(s)) = (\\alpha_g-1)\\log(s) + (\\beta_g-1)\\log(1-s) - \\log B(\\alpha_g, \\beta_g)\n$$\n$$\n\\log(p_g(m)) = m\\log(\\rho_g) + (1-m)\\log(1-\\rho_g)\n$$\n问题规定了在计算定义域边界（例如 $s=0$ 或 $s=1$）的对数时需要满足的数值稳定性要求。任何对数 $\\log(x)$ 的参数 $x$ 都必须首先被裁剪到区间 $[\\varepsilon, 1-\\varepsilon]$ 内，其中 $\\varepsilon = 10^{-12}$。此过程适用于参数 $s$、$1-s$、$\\rho_g$ 和 $1-\\rho_g$。$\\log B(\\alpha_g, \\beta_g)$ 项可以使用对数伽马函数进行稳健计算，因为 $\\log B(\\alpha, \\beta) = \\log\\Gamma(\\alpha) + \\log\\Gamma(\\beta) - \\log\\Gamma(\\alpha+\\beta)$，这个函数在科学计算库中通常以 `betaln` 的形式提供。\n\n在为所有群组 $g$ 计算了对数联合概率向量 $\\mathbf{L} = [\\log J(g; s,m)]$ 之后，我们将其转换回一个归一化的后验概率分布。为避免指数运算过程中的上溢和下溢，采用了 log-sum-exp 技巧。设 $L_{\\max} = \\max_g(\\mathbf{L})$。群组 $g$ 的后验概率为：\n$$\nP(G=g \\mid s,m) = \\frac{\\exp(\\log J(g; s,m))}{\\sum_h \\exp(\\log J(h; s,m))} = \\frac{\\exp(\\log J(g; s,m) - L_{\\max})}{\\sum_h \\exp(\\log J(h; s,m) - L_{\\max})}\n$$\n这种计算对于浮点精度问题是稳健的。\n\n对于每个测试用例 $(s,m)$，计算算法如下：\n1.  定义先验概率 $\\boldsymbol{\\pi}$、Beta 参数 $\\boldsymbol{\\alpha}$ 和 $\\boldsymbol{\\beta}$，以及伯努利参数 $\\boldsymbol{\\rho}$ 的参数向量。\n2.  计算对数先验概率向量：$\\log(\\boldsymbol{\\pi})$。\n3.  计算相似性得分 $s$ 的对数似然向量。这包括在取对数之前将 $s$ 和 $1-s$ 裁剪到 $[\\varepsilon, 1-\\varepsilon]$，并使用 Beta 分布的对数概率密度函数公式。\n4.  计算基序指示符 $m$ 的对数似然向量。这使用伯努利分布的对数概率质量函数公式。参数 $\\boldsymbol{\\rho}$ 和 $1-\\boldsymbol{\\rho}$ 也被裁剪，尽管对于给定的值这没有影响。\n5.  将对数先验概率和两个对数似然向量相加，得到对数联合向量 $\\mathbf{L}$。\n6.  使用 log-sum-exp 过程对 $\\mathbf{L}$ 进行归一化，以获得最终的后验概率向量。\n7.  根据指定的输出要求格式化结果向量。", "answer": "```python\nimport numpy as np\nfrom scipy.special import betaln\n\ndef solve():\n    \"\"\"\n    Implements a Bayesian classifier for plasmid incompatibility group assignment.\n    \"\"\"\n    # Fixed parameters in the order {IncF, IncI, IncP, IncQ}\n    PIS = np.array([0.35, 0.25, 0.25, 0.15])\n    ALPHAS = np.array([22, 12, 6, 3])\n    BETAS = np.array([4, 6, 12, 3])\n    RHOS = np.array([0.9, 0.6, 0.2, 0.5])\n    \n    # Numerical stability constant\n    EPSILON = 1e-12\n\n    # Test cases: (s, m)\n    test_cases = [\n        (0.92, 1),\n        (0.78, 0),\n        (0.30, 1),\n        (0.55, 0),\n        (1.00, 0),\n        (0.00, 1),\n    ]\n\n    # Pre-compute log priors and log beta function values\n    log_priors = np.log(PIS)\n    log_beta_funcs = betaln(ALPHAS, BETAS)\n    \n    # Pre-clip rho values as per the problem statement\n    clipped_rhos = np.clip(RHOS, EPSILON, 1.0 - EPSILON)\n    clipped_one_minus_rhos = np.clip(1.0 - RHOS, EPSILON, 1.0 - EPSILON)\n    log_rhos = np.log(clipped_rhos)\n    log_one_minus_rhos = np.log(clipped_one_minus_rhos)\n\n    results_as_strings = []\n    for s, m in test_cases:\n        # Clip similarity score arguments for log as specified\n        s_clipped = np.clip(s, EPSILON, 1.0 - EPSILON)\n        one_minus_s_clipped = np.clip(1.0 - s, EPSILON, 1.0 - EPSILON)\n        \n        # Calculate log-likelihood for the Beta distribution\n        log_s = np.log(s_clipped)\n        log_one_minus_s = np.log(one_minus_s_clipped)\n        log_likelihood_beta = (ALPHAS - 1) * log_s + (BETAS - 1) * log_one_minus_s - log_beta_funcs\n        \n        # Calculate log-likelihood for the Bernoulli distribution\n        log_likelihood_bern = m * log_rhos + (1 - m) * log_one_minus_rhos\n        \n        # Calculate unnormalized log-posterior (log-joint)\n        log_joint = log_priors + log_likelihood_beta + log_likelihood_bern\n        \n        # Normalize using the log-sum-exp trick for numerical stability\n        log_joint_max = np.max(log_joint)\n        scaled_joint = np.exp(log_joint - log_joint_max)\n        posterior = scaled_joint / np.sum(scaled_joint)\n        \n        # Format the posterior vector as a string\n        formatted_posterior = [f\"{p:.6f}\" for p in posterior]\n        results_as_strings.append(f\"[{','.join(formatted_posterior)}]\")\n\n    # Print the final result in the exact required format\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2522962"}]}