{"hands_on_practices": [{"introduction": "将基因组中的基因分为核心基因、附加基因（壳基因和云基因）是泛基因组分析的第一步。此分类通常基于基因在群体样本中的出现频率，但这只是一个经验性估计。本练习旨在通过一个实际计算，帮助您从简单的频率分类过渡到更严谨的贝叶斯统计推断，从而在考虑不确定性的情况下预测基因的真实群体频率[@problem_id:2476544]。", "problem": "对一个细菌物种的$50$个基因组进行了采样，针对一个感兴趣的基因，得到了一个二元的有-无矩阵。观察到该基因存在于$50$个基因组中的$44$个。在该研究中，基因根据其在基因组中的出现频率分类如下：如果在$100\\%$的基因组中存在，则为严格核心基因（strict core）；如果在至少$95\\%$的基因组中存在，则为软核心基因（soft core）；如果在至少$15\\%$但少于$95\\%$的基因组中存在，则为壳基因（shell）；如果在少于$15\\%$的基因组中存在，则为云基因（cloud）。假设使用以下建模框架：每个基因组中基因的存在性是一个伯努利（Bernoulli）随机变量，其未知的群体频率为$p$，给定$p$的情况下，这些基因组是可交换且独立的，且$p$的先验分布为$\\operatorname{Beta}(1,1)$。\n\n仅使用上述定义，确定在样本量为$50$时该基因的类别。然后，假设样本量翻倍至$100$个基因组，而经验频率与当前样本频率保持相同。使用相同的阈值，确定在这个翻倍的样本下该基因的类别。\n\n最后，在伯努利-贝塔（Bernoulli–Beta）模型下，计算后验预测中该基因将存在于（$100$个基因组中）的预期基因组数量，并将此数值作为你的最终答案。将你的答案四舍五入到四位有效数字。", "solution": "在尝试解答之前，将对问题进行验证。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 初始样本量：$N_1 = 50$ 个基因组。\n- 含有该基因的基因组数量：$k_1 = 44$。\n- 基于存在频率 $f$ 的基因分类定义：\n    - 严格核心基因：$f = 100\\%$。\n    - 软核心基因：$f \\ge 95\\%$。\n    - 壳基因：$15\\% \\le f  95\\%$。\n    - 云基因：$f  15\\%$。\n- 建模框架：\n    - 基因组中基因的存在性是一个参数为 $p$ 的伯努利（Bernoulli）随机变量。\n    - 给定 $p$ 时，基因组是独立同分布的试验。\n    - $p$ 的先验分布是 $\\operatorname{Beta}(1, 1)$。\n- 情况2：\n    - 新样本量：$N_2 = 100$ 个基因组。\n    - 经验频率与第一个样本相同。\n- 最终任务：\n    - 基于初始样本数据（$N_1=50$, $k_1=44$），计算在一个新的 $100$ 个基因组样本中，含有该基因的后验预测期望数量。\n    - 将最终答案四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。泛基因组（pangenome）概念，及其将基因分为核心（core）、壳（shell）和云（cloud）的分类法，是现代微生物基因组学的一个基本范式。使用伯努利-贝塔（Bernoulli-Beta）共轭模型来表示基因频率的不确定性，是生物信息学中一种标准且恰当的统计方法。该问题提法明确，提供了获得唯一解所需的所有必要定义、数据和约束。语言客观而精确。该问题不违反任何基本原则，不基于错误的前提，也不包含任何矛盾或歧义。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将提供解答。\n\n**解答**\n\n该问题包含三个部分。前两部分涉及根据基因在样本中的经验频率对其进行分类。第三部分要求使用贝叶斯方法计算后验预测期望值。\n\n**第一部分：样本量为 $N_1 = 50$ 时的基因类别**\n\n给定一个 $N_1 = 50$ 个基因组的样本，观察到该基因存在于其中的 $k_1 = 44$ 个。该基因的经验频率，记为 $f_1$，是携带该基因的基因组数量与采样的总基因组数量之比。\n$$f_1 = \\frac{k_1}{N_1} = \\frac{44}{50} = 0.88$$\n为了与给定的阈值进行比较，我们将频率表示为百分比：$0.88 \\times 100\\% = 88\\%$。根据定义：\n- 严格核心基因：要求 $100\\%$ 存在。\n- 软核心基因：要求在至少 $95\\%$ 的基因组中存在。\n- 壳基因：要求在至少 $15\\%$ 但少于 $95\\%$ 的基因组中存在。\n- 云基因：要求在少于 $15\\%$ 的基因组中存在。\n\n观察到的频率 $88\\%$ 满足条件 $15\\% \\le 88\\%  95\\%$。因此，基于这 $50$ 个基因组的样本，该基因被归类为**壳基因**（shell）类别。\n\n**第二部分：样本量为 $N_2 = 100$ 时的基因类别**\n\n问题指出，对于新的样本量 $N_2 = 100$，经验频率与第一个样本保持相同。因此，$f_2 = f_1 = 0.88$，即 $88\\%$。在这个假设的样本中，含有该基因的基因组数量将是 $k_2 = f_2 \\times N_2 = 0.88 \\times 100 = 88$。基因的分类完全基于此频率。由于频率不变，分类也保持不变。条件 $15\\% \\le 88\\%  95\\%$ 仍然满足。因此，对于样本量为 $100$ 且经验频率相同的情况，该基因仍然被归类为**壳基因**（shell）类别。\n\n**第三部分：后验预测期望数量**\n\n问题的这一部分需要应用贝叶斯模型。基因的未知群体频率 $p$ 被视为一个随机变量。\n模型如下：\n- $p$ 的先验分布被指定为参数为 $\\alpha_0 = 1$ 和 $\\beta_0 = 1$ 的贝塔（Beta）分布：\n  $$p \\sim \\operatorname{Beta}(\\alpha_0, \\beta_0) = \\operatorname{Beta}(1, 1)$$\n  这是一个在区间 $[0, 1]$ 上的均匀分布，表示对 $p$ 的最大先验不确定性。\n- 观测数据包括在 $N_1 = 50$ 次独立伯努利试验中的 $k_1 = 44$ 次“成功”（基因存在）。给定 $p$ 时，数据的似然与 $p^{k_1}(1-p)^{N_1-k_1}$ 成正比。\n\n贝塔分布是伯努利/二项分布似然的共轭先验。因此，在观测到数据后，$p$ 的后验分布也是一个贝塔分布。后验分布的参数 $\\alpha'$ 和 $\\beta'$ 更新如下：\n$$\\alpha' = \\alpha_0 + k_1 = 1 + 44 = 45$$\n$$\\beta' = \\beta_0 + (N_1 - k_1) = 1 + (50 - 44) = 1 + 6 = 7$$\n所以，基因频率 $p$ 的后验分布是：\n$$p | (k_1=44, N_1=50) \\sim \\operatorname{Beta}(45, 7)$$\n\n我们被要求计算在一个新的 $M = 100$ 个基因组样本中，基因将会存在的后验预测期望数量。设 $Y$ 是表示这个数量的随机变量。$Y$ 的期望值 $E[Y]$ 由新样本量 $M$ 乘以 $p$ 的后验期望值给出。\n\n服从贝塔分布 $\\operatorname{Beta}(\\alpha, \\beta)$ 的随机变量的期望值为 $E[p] = \\frac{\\alpha}{\\alpha + \\beta}$。\n对于我们的后验分布 $\\operatorname{Beta}(45, 7)$，$p$ 的后验均值为：\n$$E[p | \\text{data}] = \\frac{\\alpha'}{\\alpha' + \\beta'} = \\frac{45}{45 + 7} = \\frac{45}{52}$$\n这个值，约等于 $0.8654$，代表了我们对群体中该基因真实频率的更新信念。\n\n现在，我们可以计算在一个大小为 $M=100$ 的新样本中，含有该基因的后验预测期望数量：\n$$E[Y | \\text{data}] = M \\times E[p | \\text{data}] = 100 \\times \\frac{45}{52}$$\n$$E[Y | \\text{data}] = \\frac{4500}{52} = \\frac{1125}{13} \\approx 86.5384615...$$\n问题要求将答案四舍五入到四位有效数字。前四位有效数字是 $8, 6, 5, 3$。第五位数字是 $8$，所以我们将第三位小数向上取整。\n$$E[Y | \\text{data}] \\approx 86.54$$\n\n这是最终答案。", "answer": "$$\n\\boxed{86.54}\n$$", "id": "2476544"}, {"introduction": "为何某些基因会成为附加基因而非核心基因？一个关键的演化机制是基因在世代间的随机丢失。本练习构建了一个理论模型，用于分析一个中性附加基因在经过传播瓶颈和随后的遗传漂变后丢失的概率[@problem_id:2476507]。通过推导这一过程的数学表达式，您将深入理解塑造细菌泛基因组多样性的随机演化力量。", "problem": "细菌泛基因组中的一个兼性附加基因在宿主内适应性方面是中性的。在一个供体宿主中，该基因的宿主内等位基因频率（携带该基因的细胞比例）为 $p \\in [0,1]$。向新宿主的传播通过一个大小为 $b \\in \\mathbb{N}$ 的严重瓶颈发生，该过程被模型化为独立地抽取 $b$ 个细菌细胞且无重置效应（即，每次抽取都来自一个大的供体种群，因此 $b$ 个创始者中携带者的数量服从参数为 $p$ 的二项分布）。定植后，宿主内生态控制在 $t \\in \\mathbb{N}$ 个离散世代内施加强烈的中性漂变。假设采用以下宿主内中性漂变模型：\n- 每个创始细菌谱系在各世代间独立演化，没有水平基因转移或会在谱系内产生或删除附加基因的突变。\n- 在每一代中，一个在世代开始时现存的谱系以概率 $s \\in (0,1)$ 存续到下一代（即，至少有一个后代），并以概率 $1-s$ 灭绝，此过程在谱系间和世代间是独立的。\n- 当且仅当至少有一个最初携带基因的创始谱系在第 $t$ 代有至少一个存活的后代时，该基因才在第 $t$ 代的宿主中存在。\n\n在这些假设下，推导在第 $t$ 代时，受体宿主中附加基因不存在的概率的闭式解析表达式，该表达式是关于 $p$、$b$、$s$ 和 $t$ 的函数。将最终答案表示为单个简化表达式。无需进行数值四舍五入。", "solution": "首先将对问题陈述进行严格验证。\n\n**步骤 1：提取已知条件**\n- 供体宿主中一个中性附加基因的等位基因频率为 $p \\in [0,1]$。\n- 发生一个大小为 $b \\in \\mathbb{N}$ 的传播瓶颈。\n- 携带基因的创始细胞数量服从参数为 $b$ 和 $p$ 的二项分布。\n- 宿主内演化涉及 $t \\in \\mathbb{N}$ 个离散世代的中性漂变。\n- 在每一代中，一个现存谱系以概率 $s \\in (0,1)$ 存续，以概率 $1-s$ 灭绝。\n- 谱系存续在谱系间和世代间是独立的。\n- 谱系内没有水平基因转移或从头基因获得/丢失。\n- 当且仅当至少有一个最初携带基因的创始谱系在第 $t$ 代有存活后代时，该基因才在第 $t$ 代存在。\n- 目标是求出在第 $t$ 代时附加基因**不存在**的概率。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学依据**：该模型是理论群体遗传学和微生物生态学中的一个成熟构念。它将一个二项抽样过程（模拟传播瓶颈）与一个离散时间分支过程（模拟由中性漂变导致的谱系灭绝）相结合。这些是模拟此类现象的标准且科学上合理的工具。\n- **适定性**：该问题是适定的。参数（$p, b, s, t$）定义清晰，随机过程被完全指定，问题要求一个单一、可计算的概率。预期存在一个唯一、稳定且有意义的解。\n- **客观性**：语言技术性强、精确，没有主观或含糊的陈述。\n- **完整性和一致性**：问题是自洽的。它提供了所有必要的参数和模型规则。关于抽样是“无重置效应”但模型化为二项分布的陈述并不矛盾；这是一个标准的澄清，用于说明从一个足够大的种群中抽取少量样本 $b$ 时，可以假设每次抽取的概率 $p$ 不变。\n\n**步骤 3：结论与行动**\n问题被判定为**有效**。这是一个数学推导问题，下面将提供详细的解答。\n\n**解答**\n\n我们要计算在第 $t$ 代时，受体宿主中附加基因不存在的概率。这等同于所有 $b$ 个创始谱系最终都未能对第 $t$ 代的种群贡献该基因。由于每个创始谱系是独立演化的，我们可以先计算单个创始谱系未能贡献基因的概率，然后将该概率提升到 $b$ 次方。\n\n考虑一个从供体种群中随机抽取的创始细胞。\n- 该细胞携带附加基因的概率是 $p$。\n- 该细胞不携带附加基因的概率是 $1-p$。\n\n现在，考虑一个谱系的存续。一个谱系在单代内存续的概率是 $s$。由于各代之间的存续是独立的，一个谱系存续 $t$ 代的概率是 $s^t$。\n因此，一个谱系在 $t$ 代内灭绝的概率是 $1 - s^t$。\n\n一个创始谱系**未能**对第 $t$ 代的种群贡献该基因，可能发生以下两种互斥情况之一：\n1.  创始细胞本身就不携带该基因。这种情况发生的概率是 $1-p$。\n2.  创始细胞携带该基因（概率为 $p$），但其谱系在 $t$ 代内灭绝了（概率为 $1-s^t$）。这种情况发生的复合概率是 $p \\times (1 - s^t)$。\n\n因此，一个随机抽取的创始谱系未能对第 $t$ 代种群贡献基因的总概率是这两种情况的概率之和：\n$$ P(\\text{单个谱系未贡献}) = (1-p) + p(1-s^t) $$\n简化这个表达式：\n$$ P(\\text{单个谱系未贡献}) = 1 - p + p - ps^t = 1 - ps^t $$\n\n由于传播瓶颈包含 $b$ 个独立抽取的创始细胞，且它们的谱系独立演化，所以所有 $b$ 个谱系都未能贡献基因的概率是单个谱系未能贡献基因概率的 $b$ 次方：\n$$ P(\\text{基因在第 t 代不存在}) = (P(\\text{单个谱系未贡献}))^b = (1 - ps^t)^b $$\n这是最终的闭式解析表达式。", "answer": "$$\n\\boxed{(1 - ps^t)^b}\n$$", "id": "2476507"}, {"introduction": "除了中性漂变，自然选择是塑造附加基因频率的另一个关键驱动力。本练习将带您从理论转向实际数据分析，学习如何从时间序列的基因流行度数据中量化作用于附加基因的选择压力。您将通过实施一个广义线性模型（GLM）来估计选择系数 $s$，这是微生物群体遗传学和演化生物学中一项核心的定量技能[@problem_id:2476519]。", "problem": "给定描述了在多个时间点宿主群体中单个附加基因流行率的时间序列数据。对于每个时间点，您会观察到在抽样的总宿主数量中携带该基因的宿主数量。假设宿主群体数量庞大且混合均匀，并且在抽样期间，该基因在所有宿主中的净选择可以由一个恒定的选择系数（记为 $s$）来近似。在此假设和确定性选择模型下，基因在宿主中的流行率 $p(t)$ 满足常微分方程 $dp/dt = s\\,p(t)\\,(1 - p(t))$，其解意味着在 log-odds 尺度上存在线性关系：$\\mathrm{logit}(p(t)) = \\alpha + s\\,t$，其中 $\\alpha$ 是一个未知的截距，用于捕捉初始的 log-odds。在每个时间 $t_i$ 的抽样模型是 $Y_i \\sim \\mathrm{Binomial}(n_i, p(t_i))$，且各时间点的观测值相互独立。\n\n您的任务是编写一个程序，为每个提供的测试用例，在具有 logit 链接的二项广义线性模型（Binomial GLM）下，通过最大似然估计（MLE）来估计选择系数 $s$，其中 $\\mathrm{logit}(p(t)) = \\alpha + s\\,t$。基于在 MLE 处的观测 Fisher 信息，计算 $s$ 的双侧 Wald 置信区间。置信区间的上下限必须按 $s \\pm z \\cdot \\mathrm{SE}(s)$ 计算，其中 $z$ 等于标准正态分布的 $0.975$ 分位数，$\\mathrm{SE}(s)$ 通过对在 MLE 处评估的观测信息矩阵的逆矩阵的 $(2,2)$ 元素的平方根获得。您必须使用用于二项 GLM 的迭代重加权最小二乘（IRLS）算法来数值实现该估计。所有量都必须按单位时间 $t$ 报告。\n\n使用以下包含三个用例的测试套件。在每个用例中，$t$ 是时间点向量，$n$ 是每个时间点抽样的总宿主向量，$y$ 是每个时间点观测到的携带者向量。所有整数和时间值都是精确的。\n\n- 用例 A（增长，流行率中度上升）：\n  - $t = [0,2,4,6,8]$\n  - $n = [200,200,200,200,200]$\n  - $y = [20,34,54,80,110]$\n\n- 用例 B（从高流行率下降）：\n  - $t = [0,1,2,3,4,5]$\n  - $n = [150,150,150,150,150,150]$\n  - $y = [120,113,106,98,89,80]$\n\n- 用例 C（在低流行率下的近中性变化）：\n  - $t = [0,5,10,15,20]$\n  - $n = [500,500,500,500,500]$\n  - $y = [25,28,30,33,36]$\n\n您必须使用的科学和统计基础：\n- 在有效选择下，宿主间附加基因的流行率根据 $dp/dt = s\\,p\\,(1-p)$ 进行确定性变化，意味着 $\\mathrm{logit}(p(t)) = \\alpha + s\\,t$。\n- 每个时间的抽样遵循二项分布模型 $Y_i \\sim \\mathrm{Binomial}(n_i, p_i)$，其中 $p_i = \\mathrm{logit}^{-1}(\\alpha + s\\,t_i)$。\n- 具有 logit 链接的二项 GLM 通过 IRLS 进行估计，收敛时的观测信息矩阵等于 $X^\\top W X$，其中 $X$ 是列为 $[1, t]$ 的设计矩阵，$W$ 是对角元素为 $n_i\\,\\hat{p}_i\\,(1-\\hat{p}_i)$ 的对角矩阵。\n\n算法要求：\n- 实现 IRLS 来估计 $(\\alpha, s)$，通过迭代求解 $(X^\\top W X)\\,\\beta = X^\\top W z$，其中 $\\beta = (\\alpha, s)^\\top$，工作响应为 $z = \\eta + (y - n\\,\\hat{p})/(n\\,\\hat{p}(1-\\hat{p}))$，其中 $\\eta = X\\beta$ 且 $\\hat{p} = \\mathrm{logit}^{-1}(\\eta)$。\n- 收敛时，计算 $\\hat{\\beta}$ 的协方差矩阵为 $(X^\\top W X)^{-1}$，并使用 $z = 1.959963984540054$ 报告 $\\hat{s}$ 及其 Wald 区间。\n- 为保证数值稳定性，在迭代过程中通过裁剪到 $[\\varepsilon, 1-\\varepsilon]$（其中 $\\varepsilon$ 是一个小数）来确保每个 $\\hat{p}_i$ 远离 $0$ 和 $1$，并在权重计算中使用相同的裁剪方法以避免除以零。\n\n输出规格：\n- 对于每个用例，输出三元组 $[\\hat{s}, \\mathrm{lower}, \\mathrm{upper}]$，其中 $\\mathrm{lower}$ 和 $\\mathrm{upper}$ 是 $s$ 的双侧 Wald $95$ 百分位置信界限。\n- 将所有三个数字四舍五入到 $6$ 位小数，使用十进制形式（而不是分数，也不带百分号）。\n- 您的程序应生成单行输出，包含所有用例的结果，形式为逗号分隔的列表的列表，不含空格，格式为：$[[\\hat{s}_A,\\mathrm{lower}_A,\\mathrm{upper}_A],[\\hat{s}_B,\\mathrm{lower}_B,\\mathrm{upper}_B],[\\hat{s}_C,\\mathrm{lower}_C,\\mathrm{upper}_C]]$。", "solution": "所述问题已经过验证。\n\n**第 1 步：提取已知信息**\n- **基因流行率动态模型：** 流行率 $p(t)$ 遵循常微分方程 $dp/dt = s\\,p(t)\\,(1 - p(t))$。\n- **线性化模型：** 该常微分方程的解意味着在 log-odds 尺度上存在线性关系：$\\mathrm{logit}(p(t)) = \\alpha + s\\,t$，其中 $\\alpha$ 是截距，$s$ 是选择系数。\n- **抽样模型：** 在时间 $t_i$ 从大小为 $n_i$ 的样本中观测到的基因携带者数量 $Y_i$ 遵循二项分布：$Y_i \\sim \\mathrm{Binomial}(n_i, p(t_i))$，且不同时间点的观测是独立的。\n- **估计框架：** 参数 $(\\alpha, s)$ 将在具有 logit 链接函数的二项广义线性模型（GLM）下，通过最大似然估计（MLE）进行估计。\n- **数值算法：** MLE 必须使用迭代重加权最小二乘（IRLS）算法求得。\n- **IRLS 更新方程：**\n    - 参数向量 $\\beta = (\\alpha, s)^\\top$ 通过求解 $(X^\\top W X)\\,\\beta = X^\\top W z$ 进行更新。\n    - 设计矩阵 $X$ 的列为 $[1, t]$。\n    - 工作响应为 $z = \\eta + (y - n\\,\\hat{p})/(n\\,\\hat{p}(1-\\hat{p}))$。\n    - 线性预测变量为 $\\eta = X\\beta$。\n    - 拟合概率为 $\\hat{p} = \\mathrm{logit}^{-1}(\\eta)$。\n    - 权重矩阵 $W$ 是一个对角矩阵，其元素为 $n_i\\,\\hat{p}_i\\,(1-\\hat{p}_i)$。\n- **置信区间：** $s$ 的双侧 Wald 置信区间将按 $s \\pm z \\cdot \\mathrm{SE}(s)$ 计算。\n    - 分位数 $z$ 指定为 $1.959963984540054$。\n    - 标准误 $\\mathrm{SE}(s)$ 源自于在 MLE 处评估的观测 Fisher 信息矩阵 $I(\\hat{\\beta}) = X^\\top W X$ 的逆。具体来说，$\\mathrm{SE}(s)$ 是 $(I(\\hat{\\beta}))^{-1}$ 的 $(2,2)$ 元素的平方根。\n- **数值稳定性：** 拟合概率 $\\hat{p}_i$ 必须被裁剪到 $[\\varepsilon, 1-\\varepsilon]$ 以防止出现 $0$ 或 $1$ 的值。\n- **测试用例：**\n    - 用例 A: $t = [0,2,4,6,8]$, $n = [200,200,200,200,200]$, $y = [20,34,54,80,110]$。\n    - 用例 B: $t = [0,1,2,3,4,5]$, $n = [150,150,150,150,150,150]$, $y = [120,113,106,98,89,80]$。\n    - 用例 C: $t = [0,5,10,15,20]$, $n = [500,500,500,500,500]$, $y = [25,28,30,33,36]$。\n- **输出规格：** 对于每个用例，报告一个列表 $[\\hat{s}, \\mathrm{lower}, \\mathrm{upper}]$，四舍五入到 6 位小数。最终输出是包含这些列表的单个列表行。\n\n**第 2 步：使用提取的已知信息进行验证**\n- **科学依据：** 该问题牢固地植根于群体遗传学和现代统计方法。用于基因频率在选择下变化的逻辑斯谛模型是该领域的一个基石。使用具有 logit 链接函数的二项 GLM（逻辑斯谛回归）是分析此类二元结果数据（基因存在/缺失）作为连续预测变量（时间）函数的标准、正确的统计方法。\n- **定义明确：** 该问题提供了完整的规范。它定义了模型、数据结构、估计算法（IRLS）、计算置信区间的方法（基于观测 Fisher 信息的 Wald 区间），以及测试用例所需的所有常数和数据。预期会有一个唯一且稳定的解。\n- **客观性：** 该问题的陈述具有数学和统计上的精确性，没有任何主观或模棱两可的语言。\n\n该问题没有表现出验证标准中列出的任何缺陷。它是科学合理的、定义明确的、客观的、完整的且并非无足轻重。\n\n**第 3 步：结论与行动**\n该问题有效。将提供完整的解决方案。\n\n**解题推导**\n\n目标是根据基因流行率的时间序列数据估计选择系数 $s$。问题指定了一个具有 logit 链接函数的二项广义线性模型（GLM）。\n\n模型定义如下：\n1.  **系统性部分：** 在时间 $t_i$ 的第 $i$ 个观测的线性预测变量 $\\eta_i$ 由 $\\eta_i = \\alpha + s \\cdot t_i$ 给出。在矩阵表示法中，对于整个数据集，$\\boldsymbol{\\eta} = X\\beta$，其中 $\\beta = [\\alpha, s]^\\top$ 是参数向量，$X$ 是设计矩阵。设计矩阵有 $N$ 行（对应 $N$ 个时间点）和 $2$ 列。第一列是全为 1 的向量（对应截距 $\\alpha$），第二列是时间点向量 $\\mathbf{t}$。\n    $$\n    X = \\begin{pmatrix} 1  t_1 \\\\ 1  t_2 \\\\ \\vdots  \\vdots \\\\ 1  t_N \\end{pmatrix}, \\quad \\beta = \\begin{pmatrix} \\alpha \\\\ s \\end{pmatrix}\n    $$\n2.  **链接函数：** 线性预测变量 $\\eta_i$ 通过 logit 链接函数与期望流行率 $p_i$ 相关联：$\\eta_i = \\mathrm{logit}(p_i) = \\ln\\left(\\frac{p_i}{1-p_i}\\right)$。逆链接函数给出概率：$p_i = \\mathrm{logit}^{-1}(\\eta_i) = \\frac{e^{\\eta_i}}{1+e^{\\eta_i}} = \\frac{1}{1+e^{-\\eta_i}}$。\n3.  **随机性部分：** 观测到的计数 $y_i$ 假定遵循二项分布，$y_i \\sim \\mathrm{Binomial}(n_i, p_i)$，其中 $n_i$ 是在时间 $t_i$ 的样本量。\n\n参数 $\\beta$ 通过最大化对数似然函数来估计。对于 GLM，这可以通过使用迭代重加权最小二乘（IRLS）算法高效完成。IRLS 等价于用于寻找得分函数根的 Newton-Raphson 方法。\n\nIRLS 算法的步骤如下：\n1.  **初始化：** 为参数向量 $\\beta^{(0)}$ 选择一个初始估计。一个常见的选择是 $\\beta^{(0)} = \\mathbf{0}$。\n2.  **迭代：** 对于迭代 $k=0, 1, 2, \\dots$ 直到收敛：\n    a.  计算当前的线性预测变量：$\\boldsymbol{\\eta}^{(k)} = X \\beta^{(k)}$。\n    b.  计算当前的拟合概率（均值）：$\\mathbf{\\hat{p}}^{(k)} = (1 + \\exp(-\\boldsymbol{\\eta}^{(k)}))^{-1}$。为保证数值稳定性，这些概率被裁剪到一个小区间 $[\\varepsilon, 1-\\varepsilon]$ 内。\n    c.  计算对角权重矩阵 $W^{(k)}$。对角元素为 $W_{ii}^{(k)} = n_i \\hat{p}_i^{(k)} (1-\\hat{p}_i^{(k)})$。这是二项响应的方差 $n_i p_i (1-p_i)$，在当前估计 $\\hat{p}_i^{(k)}$ 处计算。\n    d.  计算工作响应向量 $\\mathbf{z}^{(k)}$。其元素为 $z_i^{(k)} = \\eta_i^{(k)} + \\frac{y_i - n_i \\hat{p}_i^{(k)}}{n_i \\hat{p}_i^{(k)} (1-\\hat{p}_i^{(k)})}$。这可以看作是链接函数在当前均值附近的一阶泰勒展开。\n    e.  通过解决加权最小二乘问题来更新参数估计：\n        $$\n        \\beta^{(k+1)} = (X^\\top W^{(k)} X)^{-1} X^\\top W^{(k)} \\mathbf{z}^{(k)}\n        $$\n3.  **收敛：** 当参数向量的变化，例如 $||\\beta^{(k+1)} - \\beta^{(k)}||_2$，小于预定义的容差时，迭代停止。\n\n收敛后，最终估计为 $\\hat{\\beta} = [\\hat{\\alpha}, \\hat{s}]^\\top$。此估计量的渐近协方差矩阵通过在 MLE 处评估的观测 Fisher 信息矩阵的逆来估计：\n$$\n\\mathrm{Cov}(\\hat{\\beta}) = I(\\hat{\\beta})^{-1} = (X^\\top \\hat{W} X)^{-1}\n$$\n其中 $\\hat{W}$ 是收敛时的最终权重矩阵。\n\n选择系数估计的标准误 $\\mathrm{SE}(\\hat{s})$ 是此协方差矩阵的第二个对角元素（即 $(2,2)$ 元素）的平方根：\n$$\n\\mathrm{SE}(\\hat{s}) = \\sqrt{[\\mathrm{Cov}(\\hat{\\beta})]_{2,2}}\n$$\n最后，为 $s$ 构建一个 $(1-\\gamma) \\times 100\\%$ 的双侧 Wald 置信区间：\n$$\n\\hat{s} \\pm z_{1-\\gamma/2} \\cdot \\mathrm{SE}(\\hat{s})\n$$\n对于 $95\\%$ 置信区间，$\\gamma = 0.05$，且 $z_{0.975} \\approx 1.96$。问题提供了精确值 $z = 1.959963984540054$。\n\n实现此算法的 Python 代码如下：\n```python\nimport numpy as np\n\ndef solve_case(t, n, y):\n    \"\"\"\n    Estimates the selection coefficient (s) and its confidence interval using IRLS\n    for a Binomial GLM with a logit link.\n\n    Args:\n        t (np.ndarray): Vector of time points.\n        n (np.ndarray): Vector of total hosts sampled at each time.\n        y (np.ndarray): Vector of observed carriers at each time.\n\n    Returns:\n        tuple: A tuple containing the estimated selection coefficient (s_hat),\n               the lower confidence bound, and the upper confidence bound.\n    \"\"\"\n    # Constants for the algorithm\n    Z_SCORE = 1.959963984540054\n    EPSILON = 1e-8  # For numerical stability\n    TOLERANCE = 1e-9 # Convergence criterion\n    MAX_ITER = 50\n\n    # 1. Construct the design matrix X\n    X = np.stack([np.ones_like(t), t], axis=1)\n\n    # 2. Initialize the parameter vector beta = [alpha, s]\n    beta = np.zeros(X.shape[1])\n\n    # 3. Implement the Iteratively Reweighted Least Squares (IRLS) algorithm\n    for i in range(MAX_ITER):\n        # Calculate linear predictor eta\n        eta = X @ beta\n\n        # Calculate fitted probabilities p_hat using the inverse logit function\n        p_hat = 1.0 / (1.0 + np.exp(-eta))\n        p_hat = np.clip(p_hat, EPSILON, 1.0 - EPSILON)\n\n        # Calculate the diagonal of the weight matrix W\n        w_diag = n * p_hat * (1.0 - p_hat)\n\n        # Calculate the working response z\n        z = eta + (y - n * p_hat) / w_diag\n        \n        # Store old beta for convergence check\n        beta_old = beta\n\n        # Update beta by solving the weighted least squares step\n        X_T_W = X.T * w_diag\n        X_T_W_X = X_T_W @ X\n        X_T_W_z = X_T_W @ z\n        \n        # Solve the linear system for the new beta\n        beta = np.linalg.solve(X_T_W_X, X_T_W_z)\n\n        # Check for convergence\n        if np.linalg.norm(beta - beta_old)  TOLERANCE:\n            break\n            \n    # 4. Extract the MLE for s\n    s_hat = beta[1]\n\n    # 5. Calculate the Wald confidence interval\n    eta = X @ beta\n    p_hat = np.clip(1.0 / (1.0 + np.exp(-eta)), EPSILON, 1.0 - EPSILON)\n    w_diag = n * p_hat * (1.0 - p_hat)\n    \n    # Observed Fisher Information Matrix: I = X.T * W * X\n    info_matrix = X.T @ (np.diag(w_diag) @ X)\n\n    # Covariance matrix is the inverse of the information matrix\n    try:\n        cov_matrix = np.linalg.inv(info_matrix)\n    except np.linalg.LinAlgError:\n        return (np.nan, np.nan, np.nan)\n\n    # Standard error of s is the square root of the (2,2) element of the covariance matrix\n    se_s = np.sqrt(cov_matrix[1, 1])\n\n    # Calculate confidence interval limits\n    margin_of_error = Z_SCORE * se_s\n    lower_bound = s_hat - margin_of_error\n    upper_bound = s_hat + margin_of_error\n\n    return s_hat, lower_bound, upper_bound\n```", "answer": "[[0.298565,0.25554,0.341591],[-0.11306,-0.147926,-0.078194],[0.019183,-0.00392,0.042286]]", "id": "2476519"}]}