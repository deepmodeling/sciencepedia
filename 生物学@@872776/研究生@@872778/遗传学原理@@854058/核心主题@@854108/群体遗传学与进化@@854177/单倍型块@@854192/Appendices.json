{"hands_on_practices": [{"introduction": "要理解单倍型块，我们首先需要识别破坏这些块的历史重组事件。四配子检验（four-gamete test）是群体遗传学中的一个经典工具，在无限位点突变模型下，它为历史重组提供了明确的信号。该练习 ([@problem_id:2820834]) 提供了应用此检验分析定相单倍型数据的直接实践，为解读遗传变异奠定了基础技能。", "problem": "一个基因组区域包含$4$个有序的单核苷酸多态性（SNPs），记为$S_1, S_2, S_3, S_4$。在无限位点模型下，假设没有复发性突变、没有基因转换且随机交配，您获得了$6$条抽样染色体在这些SNPs上的定相单倍型，其等位基因按$(S_1,S_2,S_3,S_4)$的顺序编码为$0$和$1$：\n- $H_1 = (0,0,0,0)$\n- $H_2 = (0,1,0,0)$\n- $H_3 = (1,0,0,0)$\n- $H_4 = (1,1,0,0)$\n- $H_5 = (0,0,1,0)$\n- $H_6 = (0,1,1,1)$\n\n对每对相邻的SNP对$(S_1,S_2)$、$(S_2,S_3)$和$(S_3,S_4)$应用四配子检验。在此，重组断点定义为相邻标记之间的SNP间区间内存在至少一次历史重组事件。请确定，在模型假设下，为与观察到的定相单倍型保持一致，必须包含重组断点的SNP间区间的最小集合。\n\n仅报告相邻SNP之间不同重组断点的最小数量。只提供数字，无需四舍五入。", "solution": "所述问题具有科学依据，表述清晰且客观。它基于群体遗传学的基本原理，特别是用于检测重组的无限位点模型和四配子检验。所有必要的数据和定义均已提供，问题没有歧义或矛盾。这是一个有效且可解的问题。\n\n要应用的核心原理是四配子检验。在无限位点模型下，每个突变都发生在染色体上的一个唯一位置且永不复原，一组非重组序列的谱系历史可以用一个单一的完美系统发育（一棵树）来表示。对于任意两个双等位基因的单核苷酸多态性（SNPs），其等位基因记为$0$和$1$，存在四种可能的双位点单倍型（配子）：$(0,0)$、$(0,1)$、$(1,0)$和$(1,1)$。如果这两个SNP位点之间没有发生重组，那么一个样本中最多只能出现这四种配子中的三种。第四种配子的出现只能通过历史重组事件来解释，该事件将来自不同祖先背景的等位基因组合在一起。因此，观察到两个位点之间的所有四种配子，是推断它们之间的区间内至少发生过一次重组事件的充分证据。\n\n我们已知$4$个有序的SNP，$S_1, S_2, S_3, S_4$，以及$6$个定相单倍型：\n$H_1 = (0,0,0,0)$\n$H_2 = (0,1,0,0)$\n$H_3 = (1,0,0,0)$\n$H_4 = (1,1,0,0)$\n$H_5 = (0,0,1,0)$\n$H_6 = (0,1,1,1)$\n\n我们将对$3$个相邻的SNP间区间中的每一个应用四配子检验。\n\n1.  $S_1$与$S_2$之间的区间：\n    我们从给定的$6$个完整单倍型中提取$(S_1, S_2)$对的双位点单倍型：\n    - 来自 $H_1$: $(0,0)$\n    - 来自 $H_2$: $(0,1)$\n    - 来自 $H_3$: $(1,0)$\n    - 来自 $H_4$: $(1,1)$\n    - 来自 $H_5$: $(0,0)$\n    - 来自 $H_6$: $(0,1)$\n    观察到的独特双位点单倍型集合是$\\{(0,0), (0,1), (1,0), (1,1)\\}$。由于所有四种可能的配子都存在，我们必须断定在$S_1$和$S_2$之间的区间内至少发生了一次历史重组事件。该区间必须包含一个重组断点。\n\n2.  $S_2$与$S_3$之间的区间：\n    我们提取$(S_2, S_3)$对的双位点单倍型：\n    - 来自 $H_1$: $(0,0)$\n    - 来自 $H_2$: $(1,0)$\n    - 来自 $H_3$: $(0,0)$\n    - 来自 $H_4$: $(1,0)$\n    - 来自 $H_5$: $(0,1)$\n    - 来自 $H_6$: $(1,1)$\n    观察到的独特双位点单倍型集合是$\\{(0,0), (1,0), (0,1), (1,1)\\}$。同样，所有四种可能的配子都存在。因此，我们必须推断在$S_2$和$S_3$之间的区间内至少发生了一次重组事件。该区间也必须包含一个重组断点。\n\n3.  $S_3$与$S_4$之间的区间：\n    我们提取$(S_3, S_4)$对的双位点单倍型：\n    - 来自 $H_1$: $(0,0)$\n    - 来自 $H_2$: $(0,0)$\n    - 来自 $H_3$: $(0,0)$\n    - 来自 $H_4$: $(0,0)$\n    - 来自 $H_5$: $(1,0)$\n    - 来自 $H_6$: $(1,1)$\n    观察到的独特双位点单倍型集合是$\\{(0,0), (1,0), (1,1)\\}$。在这种情况下，四种可能的配子中只有三种存在。配子$(0,1)$在样本中未被观察到。第四种配子的缺失意味着数据与$S_3$和$S_4$位点之间没有重组的历史是一致的。因此，四配子检验没有为该区间内的重组断点提供证据，也不要求其存在。\n\n基于此系统性分析，为与数据保持一致而必须包含重组断点的SNP间区间的最小集合，包括$S_1$和$S_2$之间的区间，以及$S_2$和$S_3$之间的区间。\n\n因此，相邻SNP之间不同重组断点的最小数量是$2$。", "answer": "$$\\boxed{2}$$", "id": "2820834"}, {"introduction": "在实际研究中，我们通常从不定相的基因型数据开始，而不是已知的单倍型。我们可以利用家系结构（如父母-子代三人组）中的孟德尔遗传定律来解析基因型的相位，并重建传递给后代的单倍型。这个练习 ([@problem_id:2820870]) 演示了如何利用家系三人组的遗传数据来推断亲本单倍型，这个过程被称为“定相”（phasing），并将这项实用技能与基于明确遗传模式定义单倍型块的概念直接联系起来。", "problem": "一个已进行基因分型的三口之家由两个亲本和一个子代组成，他们在一个染色体上从左到右排列的三个相邻的双等位基因单核苷酸多态性（SNP）标记（记为 $S_1$、$S_2$ 和 $S_3$）上进行了分型。每个 SNP 的等位基因编码为 $0$ 和 $1$。假设没有基因分型错误、没有新生突变，并遵循孟德尔分离定律。观测到的未定相二倍体基因型如下：\n- 母亲：$S_1 = 0/1$，$S_2 = 0/1$，$S_3 = 0/1$。\n- 父亲：$S_1 = 0/0$，$S_2 = 1/1$，$S_3 = 0/1$。\n- 子代：$S_1 = 0/1$，$S_2 = 0/1$，$S_3 = 0/1$。\n\n仅使用孟德尔遗传和 SNP 的顺序，在可以从该三口之家中确定的情况下重建亲本的单倍型，并推断出最简约的单倍型区块结构。对于本问题，将单倍型区块定义为这样一个 SNP 的最大连续集合：对于该集合，可以在不援引产生子代的减数分裂过程中该区块内的任何重组事件的情况下，明确地确定此三口之家中的亲本单倍型。\n\n以单个整数形式报告与数据一致的此类单倍型区块的最小数量。无需四舍五入。最终答案以不带单位的整数形式表示。", "solution": "问题要求为一个三口之家在三个相邻的 SNP 标记 $S_1$、$S_2$ 和 $S_3$ 上重建亲本单倍型，并随后确定与所提供基因型数据一致的单倍型区块的最小数量。单倍型区块被定义为这样一个 SNP 的最大连续集合：对于该集合，假设区块内没有重组，可以明确地确定此三口之家的亲本单倍型。\n\n提供的未定相二倍体基因型如下：\n- 母亲 (M)：$S_1 = 0/1$，$S_2 = 0/1$，$S_3 = 0/1$。\n- 父亲 (F)：$S_1 = 0/0$，$S_2 = 1/1$，$S_3 = 0/1$。\n- 子代 (O)：$S_1 = 0/1$，$S_2 = 0/1$，$S_3 = 0/1$。\n\n假设是：无基因分型错误、无新生突变和遵循孟德尔分离定律。\n\n首先，我们验证问题陈述。\n第 1 步：提取已知条件。\n- 家庭结构：母亲、父亲、子代。\n- 标记：三个有序、相邻的双等位基因 SNP ($S_1, S_2, S_3$)，等位基因为 $\\{0, 1\\}$。\n- 母亲基因型：($S_1: 0/1, S_2: 0/1, S_3: 0/1$)。\n- 父亲基因型：($S_1: 0/0, S_2: 1/1, S_3: 0/1$)。\n- 子代基因型：($S_1: 0/1, S_2: 0/1, S_3: 0/1$)。\n- 约束条件：无基因分型错误、无新生突变、遵循孟德尔分离定律。\n- 单倍型区块的定义：“一个 SNP 的最大连续集合，对于该集合，可以在不援引产生子代的减数分裂过程中该区块内的任何重组事件的情况下，明确地确定此三口之家中的亲本单倍型。”\n- 目标：报告此类单倍型区块的最小数量。\n\n第 2 步：使用提取的已知条件进行验证。\n该问题在科学上基于孟德尔遗传学原理，这是生物学中的一个基本概念。数据和术语在群体遗传学和基因组学中是标准的。问题是良定的，提供了足够的信息和一个基于精确定义的明确目标。语言客观且无歧义。该问题不违反任何指定的无效标准；这是一个标准的、可解决的遗传学难题。\n\n第 3 步：结论与行动。\n问题有效。我们继续求解。\n\n设一个单倍型由对应于 SNP $S_1, S_2, S_3$ 的有序等位基因三元组 $(a_1, a_2, a_3)$ 表示。\n\n1.  **确定父本单倍型。**\n父亲的基因型为 $S_1(0/0)$，$S_2(1/1)$，$S_3(0/1)$。由于他在 $S_1$ 和 $S_2$ 上是纯合的，他拥有的任何单倍型在 $S_1$ 处必须是 $0$，在 $S_2$ 处必须是 $1$。由于他在 $S_3$ 上是杂合的，他的两个单倍型必须在该位点上不同。因此，父亲的两条染色体单倍型被明确确定为 $(0, 1, 0)$ 和 $(0, 1, 1)$。我们将其表示为 $F: (0, 1, 0) / (0, 1, 1)$。跨越所有三个标记的相位是已知的。\n\n2.  **确定传递的等位基因。**\n子代的基因型是来自母亲的一个单倍型和来自父親的一个单倍型的组合。\n- 在 $S_1$ 处，父亲是 $0/0$，子代是 $0/1$。父亲必定传递了一个 $0$ 等位基因。为了让子代是 $0/1$，母亲必定传递了一个 $1$ 等位基因。\n- 在 $S_2$ 处，父亲是 $1/1$，子代是 $0/1$。父亲必定传递了一个 $1$ 等位基因。为了让子代是 $0/1$，母亲必定传递了一个 $0$ 等位基因。\n- 在 $S_3$ 处，父母双方都是 $0/1$，子代也是 $0/1$。我们无法明确确定等位基因的亲本来源。可能是父亲传递了 $0$ 而母亲传递了 $1$，也可能是父亲传递了 $1$ 而母亲传递了 $0$。\n\n3.  **推断亲本相位和单倍型区块。**\n我们现在应用单倍型区块的定义，该定义要求对一个连续的 SNP 集合的亲本单倍型进行明确的分配。\n\n**SNP 集合 $\\{S_1, S_2\\}$ 的分析：**\n- **父亲在 $\\{S_1, S_2\\}$ 上的单倍型**：他的基因型是 $S_1(0/0), S_2(1/1)$。他在此区域上的单倍型必须是 $(0, 1)$ 和 $(0, 1)$。这个相位是明确确定的。\n- **母亲在 $\\{S_1, S_2\\}$ 上的单倍型**：她的基因型是 $S_1(0/1), S_2(0/1)$。从第 2 步我们推断出，她传递给子代的单倍型包含等位基因 $(1, 0)$，对应于 $(S_1, S_2)$。由于她在两个位点上都是杂合的，她未传递的另一个单倍型必须是 $(0, 1)$，以解释那些未传递下去的等位基因。因此，母亲在此区域的单倍型被明确确定为 $(1, 0) / (0, 1)$。\n\n由于对 $\\{S_1, S_2\\}$ 这个连续集合，双亲的单倍型都可以被明确地分配，所以这个集合符合成为区块一部分的标准。\n\n**SNP 集合 $\\{S_1, S_2, S_3\\}$ 的分析：**\n要成为一个单一区块，母本和父本的单倍型必须在所有三个标记上都能被明确分配。\n- **父亲在 $\\{S_1, S_2, S_3\\}$ 上的单倍型**：如第 1 步所确定的，它们明确地是 $(0, 1, 0) / (0, 1, 1)$。\n- **母亲在 $\\{S_1, S_2, S_3\\}$ 上的单倍型**：我们知道她在 $\\{S_1, S_2\\}$ 上的单倍型是 $(1, 0)$ 和 $(0, 1)$。她在 $S_3$ 上的基因型是 $0/1$。这导致了她完整单倍型的两种可能性：\n    - 可能性 A：$(1, 0, 0) / (0, 1, 1)$\n    - 可能性 B：$(1, 0, 1) / (0, 1, 0)$\n\n为了区分这些可能性，我们检查整个遗传事件，假设没有重组。\n- 如果母亲的相位是可能性 A，她可以传递 $(1, 0, 0)$。为了使子代的基因型为 $(0/1, 0/1, 0/1)$，父亲必须传递 $(0, 1, 1)$。这与父亲的单倍型一致。\n- 如果母亲的相位是可能性 B，她可以传递 $(1, 0, 1)$。为了使子代的基因型为 $(0/1, 0/1, 0/1)$，父亲必须传递 $(0, 1, 0)$。这也与父亲的单倍型一致。\n\n由于两种可能性（A 和 B）都为子代的基因型提供了有效的、非重组的解释，我们无法根据三口之家的数据来区分它们。因此，母亲在集合 $\\{S_1, S_2, S_3\\}$ 上的单倍型无法被明确分配。\n这意味着集合 $\\{S_1, S_2, S_3\\}$ 不是一个单一的单倍型区块。这也意味着集合 $\\{S_2, S_3\\}$ 不是一个区块，因为 $S_2$ 和 $S_3$ 之间的母本相位模糊性是问题的根源。\n\n4.  **确定区块的最小数量。**\n我们已经确定 $\\{S_1, S_2\\}$ 符合一个区块的条件，并且是最大的，因为更大的集合 $\\{S_1, S_2, S_3\\}$ 不符合条件。这定义了第一个区块。所有标记的集合是 $\\{S_1, S_2, S_3\\}$。第一个区块 $B_1 = \\{S_1, S_2\\}$ 覆盖了前两个标记。剩下的标记 $\\{S_3\\}$ 必须形成自己的区块 $B_2 = \\{S_3\\}$。单个 SNP 自然地形成一个单倍型区块，因为它的“单倍型”（等位基因）由基因型给出。\n\n因此，该区域被划分为两个连续的单倍型区块：$\\{S_1, S_2\\}$ 和 $\\{S_3\\}$。这是一个划分为 $2$ 个区块的方案。另一种划分方式是 $\\{S_1\\}$、$\\{S_2\\}$、$\\{S_3\\}$，即 $3$ 个区块。问题要求的是区块的最小数量。由于划分为单个区块是不可能的，所以区块的最小数量是 $2$。\n\n与数据一致的单倍型区块的最小数量是 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "2820870"}, {"introduction": "除了简单的规则外，现代遗传学需要定量方法来定义单倍型块。连锁不平衡（Linkage Disequilibrium, LD）的度量，例如归一化系数 $D'$，量化了等位基因之间的非随机关联，而自助法（bootstrap）等统计方法则用于评估这些度量的置信度。本练习 ([@problem_id:2820833]) 将指导您完成计算 $D'$、使用自助法估计其统计不确定性，并应用既定标准（Gabriel标准）对SNP对是否处于强连锁不平衡状态进行分类的完整计算流程，这反映了当代基因组学中用于定义和分析单倍型块的严谨、数据驱动的方法。", "problem": "给定位于候选单倍型块内的双等位基因单核苷酸多态性 (SNPs) 对的定相单倍型计数数据。对于每个 SNP 对，您必须计算标准化连锁不平衡度量 $D'$ 的非参数自举置信区间，然后根据 Gabriel 标准判断该 SNP 对是否处于强连锁不平衡状态。您的程序必须从核心定义和广泛接受的程序开始，实现以下内容：\n\n- 考虑两个双等位基因 SNP，其等位基因为 $A/a$ 和 $B/b$。设观测到的定相单倍型计数为有序四元组 $\\left[n_{AB}, n_{Ab}, n_{aB}, n_{ab}\\right]$，其中每个 $n_{\\cdot}$ 是一个非负整数计数，染色体总数为 $N = n_{AB} + n_{Ab} + n_{aB} + n_{ab}$。将单倍型频率定义为 $f_{AB} = n_{AB}/N$、$f_{Ab} = n_{Ab}/N$、$f_{aB} = n_{aB}/N$ 和 $f_{ab} = n_{ab}/N$，它们满足 $f_{AB} + f_{Ab} + f_{aB} + f_{ab} = 1$。\n- 定义等位基因频率 $p_A = f_{AB} + f_{Ab}$ 和 $p_B = f_{AB} + f_{aB}$。连锁不平衡系数为 $D = f_{AB} - p_A p_B$。\n- 标准化不平衡 $D'$ 定义为 $D$ 的绝对值除以其在给定观测等位基因频率下的理论最大值，即\n  $$\n  D' = \\begin{cases}\n  \\dfrac{|D|}{\\min\\left(p_A\\left(1-p_B\\right),\\left(1-p_A\\right)p_B\\right)}  \\text{if } D \\ge 0, \\\\\n  \\dfrac{|D|}{\\min\\left(p_A p_B,\\left(1-p_A\\right)\\left(1-p_B\\right)\\right)}  \\text{if } D  0,\n  \\end{cases}\n  $$\n  按照约定，如果分母为 $0$，则 $D'$ 定义为 $0$。根据定义，$D'$ 位于闭区间 $[0,1]$ 内。\n- 为量化抽样不确定性，对染色体使用非参数自举：从包含根据 $\\left[n_{AB}, n_{Ab}, n_{aB}, n_{ab}\\right]$ 重复的四种单倍型的多重集中，有放回地重抽样 $N$ 个单倍型，在重抽样数据上重新计算 $D'$，并将此过程重复 $R$ 次自举复制，以获得自举样本 $\\{D'_1, D'_2, \\dots, D'_R\\}$。使用百分位数法构建名义覆盖率为 $1-\\alpha$ 的双侧置信区间，其下限取自举样本 $D'$ 值的经验 $\\alpha/2$ 分位数，上限取经验 $1-\\alpha/2$ 分位数。\n- 对所得区间应用 Gabriel 强连锁不平衡标准：如果 $D'$ 的置信上限严格大于 $0.98$ 且置信下限严格大于 $0.7$，则该 SNP 对被分类为强连锁不平衡。\n\n实现规则和要求使用的常数：\n- 为自举过程使用固定的伪随机数生成器种子 $s = 1729$，以确保结果的确定性。\n- 使用 $R = 5000$ 次自举重复和 $1-\\alpha = 0.95$ 的双侧名义覆盖率（即 $\\alpha = 0.05$，因此百分位分位数位于 $0.025$ 和 $0.975$）。\n- 所有报告的 $D'$ 值和置信界限均表示为小数点后精确到三位的小数。请勿使用百分号。\n\n测试套件：\n- 您必须计算以下五个测试用例的结果，每个用例由单倍型计数四元组 $\\left[n_{AB}, n_{Ab}, n_{aB}, n_ {ab}\\right]$ 指定：\n  1. 用例 $\\mathrm{A}$: $\\left[40, 0, 0, 60\\right]$。\n  2. 用例 $\\mathrm{B}$: $\\left[35, 5, 5, 55\\right]$。\n  3. 用例 $\\mathrm{C}$: $\\left[25, 25, 25, 25\\right]$。\n  4. 用例 $\\mathrm{D}$: $\\left[9, 1, 1, 89\\right]$。\n  5. 用例 $\\mathrm{E}$: $\\left[49, 1, 1, 49\\right]$。\n\n输出规范：\n- 对于每个用例，根据观测计数计算点估计 $D'$，在 $\\alpha/2 = 0.025$ 和 $1-\\alpha/2 = 0.975$ 处的自举下限和上限，以及根据 Gabriel 标准的布尔决策。\n- 您的程序应生成单行输出，其中包含一个长度为 $5$ 的列表，每个元素按 $\\mathrm{A}$ 到 $\\mathrm{E}$ 的顺序对应一个用例。每个元素本身必须是一个形式为 $\\left[\\text{Dprime}, \\text{Lower}, \\text{Upper}, \\text{Strong}\\right]$ 的列表，其中 $\\text{Dprime}$、$\\text{Lower}$ 和 $\\text{Upper}$ 是精确到三位小数的小数，而 $\\text{Strong}$ 是一个布尔值。例如，两个假设用例的语法有效输出将类似于 $\\left[\\left[0.832, 0.701, 0.994, \\mathrm{True}\\right], \\left[0.412, 0.205, 0.673, \\mathrm{False}\\right]\\right]$。您的程序必须按给定顺序，输出包含所有五个指定用例结果的这样一行内容。", "solution": "所提出的问题要求实现一个统计程序，以评估单核苷酸多态性 (SNPs) 对之间的连锁不平衡 (LD)。该问题在科学上是有效的、定义明确的，并为获得唯一的、可复现的解决方案提供了所有必要的定义和参数。所描述的方法——计算标准化连锁不平衡系数 $D'$、使用非参数自举法估计置信区间，以及应用 Gabriel 标准——都是群体遗传学领域的标准且成熟的方法。我将以严谨的方式进行求解。\n\n解决方案的结构如下。首先，我们定义一个函数，根据给定的四个单倍型计数集计算标准化连锁不平衡 $D'$ 的点估计。其次，我们实现非参数自举程序以生成 $D'$ 值的经验分布。第三，我们使用此分布构建基于百分位数的置信区间。最后，我们将指定的 Gabriel 标准应用于该区间，以确定是否存在强连锁不平衡 (strong LD)。然后将这整个过程应用于所提供的五个测试用例中的每一个。\n\n**1. 数学公式**\n\n设两个双等位基因位点（等位基因为 $A/a$，$B/b$）的观测定相单倍型计数由向量 $\\mathbf{n} = [n_{AB}, n_{Ab}, n_{aB}, n_{ab}]$ 给出。抽样的染色体总数为 $N = \\sum_i n_i = n_{AB} + n_{Ab} + n_{aB} + n_{ab}$。\n\n四种单倍型的频率估计如下：\n$$\nf_{AB} = \\frac{n_{AB}}{N}, \\quad f_{Ab} = \\frac{n_{Ab}}{N}, \\quad f_{aB} = \\frac{n_{aB}}{N}, \\quad f_{ab} = \\frac{n_{ab}}{N}\n$$\n由此，第一个位点上等位基因 $A$ 和第二个位点上等位基因 $B$ 的等位基因频率为：\n$$\np_A = f_{AB} + f_{Ab}\n$$\n$$\np_B = f_{AB} + f_{aB}\n$$\n连锁不平衡系数 $D$ 衡量观测单倍型频率 $f_{AB}$ 与连锁平衡下预期频率 $p_A p_B$ 之间的偏差：\n$$\nD = f_{AB} - p_A p_B\n$$\n$D$ 的值受等位基因频率的限制。为了创建一个标准化度量，$D$ 通过其可能的最大绝对值 $D_{max}$ 进行归一化，得到 $D'$。$D_{max}$ 的值取决于 $D$ 的符号：\n$$\nD_{max} = \\begin{cases}\n\\min(p_A(1-p_B), (1-p_A)p_B)  \\text{if } D \\ge 0, \\\\\n\\min(p_A p_B, (1-p_A)(1-p_B))  \\text{if } D  0.\n\\end{cases}\n$$\n然后，标准化连锁不平衡 $D'$ 定义为：\n$$\nD' = \\frac{|D|}{D_{max}}\n$$\n按照约定，如果 $D_{max} = 0$，则 $D'$ 定义为 $0$。根据定义，$D' \\in [0, 1]$。\n\n**2. 统计分析的算法实现**\n\n一个我们可称之为 `compute_d_prime` 的主函数，被设计用来执行这些计算。为了保证稳健性和效率，该函数使用 `NumPy` 实现以支持向量化操作，使其能够同时处理一批单倍型计数向量。这对于自举程序尤其有利。\n\n**2.1. 点估计计算**\n对于每个测试用例，我们首先使用 `compute_d_prime` 函数直接从提供的单倍型计数 $[n_{AB}, n_{Ab}, n_{aB}, n_{ab}]$ 计算 $D'$ 的点估计。\n\n**2.2. 非参数自举**\n为量化 $D'$ 点估计的不确定性，我们采用非参数自举。过程如下：\n- 将 $N$ 个观测染色体集合视为一个经验分布。抽取每个单倍型的概率由其观测频率给出，即 $\\mathbf{p} = [f_{AB}, f_{Ab}, f_{aB}, f_{ab}]$。\n- 通过从该经验分布中有放回地抽取 $N$ 条染色体来生成一个自举样本。这在计算上等同于从一个参数为 $N$ 和概率向量为 $\\mathbf{p}$ 的多项分布中抽取一个大小为 $N$ 的样本。\n- 对于每个计数的自举样本，我们重新计算 $D'$ 值。\n- 此过程重复 $R = 5000$ 次，产生一个 $D'$ 值的自举分布：$\\{D'_1, D'_2, \\dots, D'_R\\}$。\n- 为确保可复现性，伪随机数生成器使用指定值 $s = 1729$ 作为种子。\n\n所有 $R$ 个自举样本的生成是通过使用 `numpy.random.default_rng().multinomial(N, p, size=R)` 在一次高效的操作中完成的。随后对所有 $R$ 个重复样本的 $D'$ 计算则以完全向量化的方式执行。\n\n**2.3. 置信区间构建**\n百分位数法用于构建 $D'$ 的 $1 - \\alpha = 0.95$ 置信区间。置信区间的下限和上限分别是排序后的 $D'$ 值自举分布的经验 $\\alpha/2 = 0.025$ 和 $1 - \\alpha/2 = 0.975$ 分位数。这些分位数可通过 `numpy.quantile` 高效计算。\n\n**2.4. Gabriel 强连锁不平衡标准**\n最后，将计算出的置信区间 $[L, U]$ 与 Gabriel 标准进行评估。如果同时满足以下两个条件，则一个 SNP 对被分类为处于强连锁不平衡 (strong LD)：\n- 置信下限 $L  0.7$。\n- 置信上限 $U  0.98$。\n这将得到一个布尔决策（`True` 或 `False`）。\n\n**3. 输出生成**\n最终输出通过遍历五个测试用例来构建。对于每个用例，计算 $D'$ 的点估计、置信区间的下限和上限，以及强连锁不平衡 (strong LD) 的布尔决策。这四个值被格式化为一个列表，其中浮点数表示为精确到三位小数的字符串。然后将所有五个用例的列表聚合成一个单一列表，并严格按照指定格式作为连续的一行文本打印。使用格式化字符串（Python 中的 f-string）可确保数值结果的精确表示。", "answer": "```python\nimport numpy as np\n\ndef compute_d_prime(counts: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the normalized linkage disequilibrium D' in a vectorized manner.\n\n    Args:\n        counts: An ndarray of shape (k, 4) or (4,) containing haplotype counts\n                [n_AB, n_Ab, n_aB, n_ab].\n\n    Returns:\n        A scalar or an ndarray of shape (k,) with the D' values.\n    \"\"\"\n    is_scalar = counts.ndim == 1\n    if is_scalar:\n        counts = counts.reshape(1, 4)\n\n    # Initialize result array\n    d_prime_results = np.zeros(counts.shape[0])\n\n    # Calculate total counts and identify valid rows (N  0)\n    total_counts = np.sum(counts, axis=1, keepdims=True)\n    valid_mask = (total_counts  0).flatten()\n\n    if not np.any(valid_mask):\n        return d_prime_results[0] if is_scalar else d_prime_results\n    \n    # Perform calculations only on rows with data\n    valid_counts = counts[valid_mask]\n    valid_N = total_counts[valid_mask]\n    \n    freqs = valid_counts / valid_N\n    \n    p_A = freqs[:, 0] + freqs[:, 1]\n    p_B = freqs[:, 0] + freqs[:, 2]\n    \n    D = freqs[:, 0] - p_A * p_B\n    \n    # Calculate D_max based on the sign of D\n    d_max_pos = np.minimum(p_A * (1 - p_B), (1 - p_A) * p_B)\n    d_max_neg = np.minimum(p_A * p_B, (1 - p_A) * (1 - p_B))\n    d_max = np.where(D = 0, d_max_pos, d_max_neg)\n\n    # Calculate D' avoiding division by zero\n    valid_d_primes = np.zeros_like(D)\n    # Use a small tolerance for floating point comparison to zero\n    nonzero_d_max_mask = d_max  1e-12\n    valid_d_primes[nonzero_d_max_mask] = np.abs(D[nonzero_d_max_mask]) / d_max[nonzero_d_max_mask]\n    \n    d_prime_results[valid_mask] = valid_d_primes\n    \n    return d_prime_results[0] if is_scalar else d_prime_results\n\ndef process_case(counts: np.ndarray, R: int, alpha: float, rng: np.random.Generator) - str:\n    \"\"\"\n    Processes a single case: computes D', bootstrap CI, and Gabriel criteria.\n\n    Args:\n        counts: A 1D numpy array of 4 haplotype counts.\n        R: Number of bootstrap replicates.\n        alpha: Significance level for the confidence interval.\n        rng: A numpy random number generator instance.\n\n    Returns:\n        A formatted string representing the results for the case.\n    \"\"\"\n    # 1. Point estimate of D'\n    point_d_prime = compute_d_prime(counts)\n    \n    # 2. Bootstrap procedure\n    N = np.sum(counts)\n    if N == 0:\n        return f\"[{0.0:.3f}, {0.0:.3f}, {0.0:.3f}, False]\"\n\n    haplotype_probs = counts / N\n    \n    # Generate R bootstrap samples of counts\n    bootstrap_counts = rng.multinomial(N, haplotype_probs, size=R)\n    \n    # 3. Calculate D' for all bootstrap replicates\n    bootstrap_d_primes = compute_d_prime(bootstrap_counts)\n    \n    # 4. Construct percentile confidence interval\n    lower_quantile = alpha / 2\n    upper_quantile = 1 - alpha / 2\n    lower_bound, upper_bound = np.quantile(bootstrap_d_primes, [lower_quantile, upper_quantile])\n\n    # 5. Apply Gabriel criteria\n    is_strong_ld = (lower_bound  0.7) and (upper_bound  0.98)\n    \n    # 6. Format output string\n    return f\"[{point_d_prime:.3f}, {lower_bound:.3f}, {upper_bound:.3f}, {is_strong_ld}]\"\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the final output.\n    \"\"\"\n    # Define problem constants and test cases\n    SEED = 1729\n    R_REPLICATES = 5000\n    ALPHA = 0.05\n    test_cases = [\n        np.array([40, 0, 0, 60]),   # Case A\n        np.array([35, 5, 5, 55]),   # Case B\n        np.array([25, 25, 25, 25]), # Case C\n        np.array([9, 1, 1, 89]),    # Case D\n        np.array([49, 1, 1, 49]),   # Case E\n    ]\n    \n    # Initialize the random number generator\n    rng = np.random.default_rng(seed=SEED)\n\n    results_as_strings = []\n    for counts in test_cases:\n        result_str = process_case(counts, R_REPLICATES, ALPHA, rng)\n        results_as_strings.append(result_str)\n        \n    # Print the final output in the specified single-line format\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2820833"}]}