{"hands_on_practices": [{"introduction": "我们如何才能在细胞群体中定量测量逆转录转座子跳跃这一罕见事件？这项练习旨在挑战你设计一个遗传报告系统。你的目标是设计一个巧妙的结构，利用选择性标记来特异性地分离出那些成功完成了包括转录和剪接在内的完整逆转录转座事件的细胞。这是实验遗传学中的一项基本技能，它能让你将分子机制的理论知识应用于实际的实验设计中。[@problem_id:2846686]", "problem": "您正在设计一种基于细胞的报告系统，用于在哺乳动物细胞中使用新霉素磷酸转移酶基因 (Neo) 和 Geneticin (G418) 筛选来量化长散在核元件-1 (LINE-1) 的逆转录转座。请从基本原理出发：中心法则（DNA转录为前信使RNA，内含子被剪接体利用有方向性的5'供体和3'受体位点移除，成熟的信使RNA被翻译），以及LINE-1的靶标引物逆转录 (TPRT) 机制，在该机制中，聚腺苷酸化的LINE-1 RNA模板在染色体切口处被逆转录并作为互补DNA插入。一个有效的设计必须确保只有在满足两个条件时才会出现G418抗性菌落：(i) 报告基因盒序列首先在LINE-1 RNA的背景下被转录并正确剪接，以及 (ii) 该剪接后的序列被复制成DNA并通过TPRT整合。您将选择最严谨的设计和理由来实现这种特异性。\n\n以下哪个选项最能满足这些要求，并正确解释了为什么G418抗性特异性地报告了成功的TPRT和剪接？\n\nA. 将一个猿猴病毒40 (SV40) 启动子–Neo–多聚腺苷酸化信号盒以相对于LINE-1转录的反义方向插入LINE-1的3'非翻译区。用一个相对于Neo是反义（因此其5'供体/3'受体在Neo的转录方向上是反向的）但相对于LINE-1转录本是正义的合成内含子来中断Neo。供体质粒不能表达功能性Neo，因为反义内含子在Neo的转录方向上不被剪接体识别，导致编码序列被破坏。然而，当LINE-1前信使RNA生成时，内含子以正义方向出现并被剪接出去；剪接后的LINE-1 RNA随后通过TPRT被逆转录和整合，产生一个带有无内含子、含启动子的Neo基因的基因组拷贝，从而赋予稳定的G418抗性。\n\nB. 将一个SV40启动子–Neo–多聚腺苷酸化信号盒以与LINE-1反义的方向放置，并在Neo内部带有一个正义方向的内含子。因为内含子相对于Neo是正义方向的，所以在源自供体质粒的转录本中会发生剪接，从而允许功能性Neo的基础表达，因此产生G418抗性；因此，抗性菌落的任何增加都必须反映TPRT的增强。\n\nC. 将一个被正义方向内含子中断的无启动子Neo，以相对于LINE-1的正义方向插入LINE-1的3'非翻译区。只有在逆转录转座之后，宿主基因组的启动子才会驱动Neo的表达，并且内含子的移除是有保证的，因为内含子相对于Neo是正义方向的。因此，G418抗性特异性地标记了TPRT。\n\nD. 将一个SV40启动子–Neo–多聚腺苷酸化信号盒以相对于LINE-1的正义方向放置，并省略任何内含子以避免剪接复杂性。因为Neo存在于LINE-1信使RNA上，所以只有当该RNA作为逆转录的模板时，翻译才会产生Neo蛋白；因此，G418抗性必须报告TPRT事件。", "solution": "我们从与此遗传报告基因设计相关的基本原理开始。\n\n1. 转录和剪接具有方向依赖性。前信使RNA剪接要求内含子5'端的剪接供体和3'端的受体以相对于转录方向的正确方向呈现。如果一个内含子以反向（反义）方向相对于转录本放置，其保守的5'和3'剪接信号会反向出现（例如，经典的GT–AG在转录链上变为CT–AC），不被剪接体识别，因此该内含子不会被移除。\n\n2. 通过靶标引物逆转录 (TPRT) 进行的LINE-1逆转录转座需要一个聚腺苷酸化的LINE-1信使RNA。LINE-1核糖核蛋白在基因组DNA中引入一个单链切口，将信使RNA的poly(A)尾巴退火到富含T的目标序列上，并利用该RNA作为逆转录的模板，生成随后被整合的互补DNA。任何携带在LINE-1信使RNA内的序列都将被复制到新的互补DNA插入片段中，关键的是，只有存在于已加工的信使RNA（即剪接后）中的序列才会被传播。\n\n3. 使用Geneticin (G418) 进行筛选需要一个功能性新霉素磷酸转移酶开放阅读框在细胞核内经过多次细胞倍增的表达，这意味着稳定的基因组表达。因此，为了将G418抗性与TPRT联系起来，设计必须阻止功能性Neo从供体质粒以及任何绕过RNA中间体的DNA事件（例如，质粒的直接整合）中表达，同时只允许从由剪接过的LINE-1信使RNA产生并整合到基因组中的无内含子Neo拷贝进行表达。\n\n评估每个选项：\n\n选项 A：\n- 设计：SV40启动子–Neo–poly(A)信号盒以相对于LINE-1转录的反义方向插入LINE-1的3'非翻译区。内含子相对于Neo是反义的，但相对于LINE-1是正义的。\n- 机制：源自供体质粒上SV40启动子的转录本遇到反义方向的内含子；由于5'供体/3'受体信号是反向的，剪接体无法移除该内含子。该内含子中断了Neo的编码序列，翻译后不产生功能性酶；因此，供体质粒不能赋予G418抗性。相比之下，LINE-1前信使RNA以相反（互补）的方向包含该信号盒序列；在那里，同一个内含子以正义方向出现并被有效剪接掉。加工后的LINE-1信使RNA，现在携带一个无内含子的Neo序列，作为TPRT的模板。整合后，产生的基因组拷贝包含一个无内含子的Neo基因，其自身带有SV40启动子和多聚腺苷酸化信号，从而能够稳定地转录和翻译Neo，并赋予稳定的G418抗性。供体质粒的直接DNA整合不会移除内含子，因此不会产生抗性，从而保留了对RNA介导的TPRT途径的特异性。这一逻辑满足了两个必要条件：在LINE-1 RNA中正确剪接以及通过TPRT进行复制/整合。\n- 结论：正确。\n\n选项 B：\n- 设计：信号盒与LINE-1反义，但内含子相对于Neo是正义的。\n- 机制：由供体质粒上SV40启动子驱动的转录本将在Neo内部遇到一个正义方向的内含子，剪接体将移除该内含子，直接从质粒产生无内含子的功能性Neo信使RNA。这会在没有任何LINE-1转录、在LINE-1背景下剪接或TPRT要求的情况下产生G418抗性。因此，抗性对TPRT不具特异性，并违反了阻止供体质粒表达的要求。\n- 结论：不正确。\n\n选项 C：\n- 设计：一个带有正义方向内含子的无启动子Neo以相对于LINE-1的正义方向放置。\n- 机制：逆转录转座后，基因组拷贝将携带一个无启动子的Neo；其表达将依赖于偶然整合到宿主启动子下游。即使TPRT发生且内含子在LINE-1信使RNA中被移除，许多真实的逆转录转座事件也会因为未能捕获启动子而无法被记分。反之，来自非TPRT事件（例如，供体质粒随机整合到转录单元中）的启动子捕获表达可能会产生G418抗性，尽管没有发生LINE-1 RNA的加工和TPRT。因此，抗性不是TPRT加剪接的特异性读出信号。\n- 结论：不正确。\n\n选项 D：\n- 设计：信号盒相对于LINE-1是正义的，并且完全没有内含子。\n- 机制：没有内含子，供体质粒上的SV40启动子会立即驱动功能性Neo的表达，导致G418抗性，而这与任何LINE-1活动无关。此外，将Neo蛋白的产生等同于TPRT在概念上是不正确的：从信使RNA翻译并不意味着该RNA被逆转录和整合了。这违反了将抗性严格与通过TPRT发生的RNA到DNA的转变以及剪接的发生联系起来的要求。\n- 结论：不正确。\n\n因此，只有选项A提供了一种设计，通过方向依赖性剪接以及包含专用的启动子和多聚腺苷酸化信号，确保G418抗性仅在报告基因序列（i）在LINE-1转录本中被正确剪接，并且（ii）通过TPRT被捕获到基因组中时才会出现，同时防止了来自供体DNA的虚假表达。", "answer": "$$\\boxed{A}$$", "id": "2846686"}, {"introduction": "逆转录转座是由一组专门的蛋白质精心策划的。这项练习要求你像分子生物学家一样思考，通过一个假設的实验来剖析$L1$（Long Interspersed Nuclear Element-1）关键蛋白$ORF1p$和$ORF2p$的独特功能。你将探索“顺式偏好”的概念，以及像$Alu$这样的非自主SINEs（Short Interspersed Nuclear Elements）如何“寄生”于$L1$的转座机制，揭示塑造我们基因组的复杂相互作用。[@problem_id:2846740]", "problem": "一个人类细胞系含有内源性的长散在核元件-1（LINE-1，缩写为 L1）反转录转座子和 Alu 短散在核元件（SINEs）。每个活性的 L1 编码开放阅读框1蛋白（ORF1p），一种RNA结合三聚体分子伴侣，以及开放阅读框2蛋白（ORF2p），一种核酸内切酶和反转录酶。Alu 元件不编码蛋白质，但带有一个聚腺苷酸尾。非长末端重复反转录转座子的反转录转座通过靶标引物反转录（TPRT）进行，其中核酸内切酶在基因组DNA中造成一个切口，反转录酶直接在靶位点以RNA为模板合成互补DNA（cDNA）。关于 L1 的一个得到充分支持的观察结果是，其蛋白质对编码它们的RNA表现出强烈的顺式偏好性，形成一个核糖核蛋白（RNP）颗粒，该颗粒被转运到细胞核以执行TPRT。\n\n你设计细胞，使其从一个异源启动子表达 ORF2p，而不共表达 L1 RNA 或 ORF1p，同时使用针对 L1 报告RNA和 Alu 报告RNA的标准报告基因检测来测量反转录转座。在一个平行的条件下，你使用小干扰RNA敲低内源性 ORF1p，同时维持 ORF2p 的过表达。假设中心法则（DNA $\\rightarrow$ RNA $\\rightarrow$ 蛋白质）、RNP需要作为分子伴侣将RNA模板带入细胞核的要求、L1 蛋白对其编码RNA的顺式偏好性，以及 ORF2p 在核酸内切酶介导的切口和反转录中的酶促作用是有效的起始原则。\n\n哪个选项最能合理解释为什么仅过表达 ORF2p 能够动员SINEs但不能有效动员新的 L1 拷贝，并且最准确地预测了在持续过表达 ORF2p 的情况下敲低 ORF1p 时报告基因检测和基因组稳定性的定性结果？\n\nA. ORF2p 以反式作用提供酶学功能（核酸内切酶和反转录酶）并识别聚腺苷酸尾，允许 Alu SINE RNA 寄生于 ORF2p 以进行 TPRT 而无需 ORF1p，而高效的 L1 反转录转座需要一个依赖于 ORF1p 的 L1 RNP 来作为 L1 RNA 的分子伴侣并保护它，以及执行顺式偏好性。因此，仅过表达 ORF2p 会增加 SINE 报告基因的动员，但不会增加 L1 报告基因的动员；在敲低 ORF1p 后，L1 报告基因活性进一步降低，SINE 报告基因活性保持升高或增加，由细胞mRNA形成的加工假基因数量上升，并且由于未受约束的 ORF2p 核酸内切酶活性，双链DNA断裂增加。\n\nB. ORF2p 对于所有反转录转座都是足够的；ORF1p 对于 L1 和 Alu 都是可有可无的。因此，过表达 ORF2p 会增加 L1 和 SINE 报告基因的动员，而敲低 ORF1p 对任一报告基因或基因组稳定性都没有影响。\n\nC. 因为 Alu SINEs 是缺少 5' 端帽的RNA聚合酶III转录本，ORF2p 不能将它们用作模板，但它可以有效地作用于带帽的 L1 RNA 而无需 ORF1p。因此，过表达 ORF2p 会增加 L1 报告基因的动员而不是 SINEs；在敲低 ORF1p 后，L1 报告基因活性不变，DNA损伤最小。\n\nD. ORF1p 主要作用是作为SINE寄生的抑制剂；因此，仅过表达 ORF2p 通常未能动员 SINEs，而 L1 拷贝可以在没有 ORF1p 的情况下动员。在过表达 ORF2p 的情况下敲低 ORF1p 会增加 L1 和 SINE 报告基因的动员，并通过减少 RNP 拥挤来减少 DNA 损伤。\n\nE. 在缺少 ORF1p 的情况下，ORF2p 缺乏核酸内切酶活性，因此仅有 ORF2p 时 L1 和 SINEs 都不能动员；在敲低 ORF1p 后，两种报告基因活性都降低，但DNA损伤仍然增加，因为 ORF2p 在染色质上积累。", "solution": "题目陈述已经过验证，被认为是合理的。它具有科学依据，提问得当，并包含足够的信息，可以根据所提供的关于反转录转座子的分子遗传学原理得出逻辑结论。\n\n问题要求对一个实验观察结果进行合理解释，并根据已建立的 LINE-1 (L1) 和 Alu SINE 反转录转座原则，对后续实验结果进行预测。让我们根据提供的已知条件来分析这个系统。\n\n**基本原则：**\n1.  **L1 反转录转座：** 一个活性的 L1 元件产生一个双顺反子RNA，该RNA被翻译成开放阅读框1蛋白 (ORF1p) 和开放阅读框2蛋白 (ORF2p)。\n2.  **顺式偏好性：** ORF1p 和 ORF2p 优先结合到编码它们的同一个 L1 RNA 分子上，形成一个核糖核蛋白 (RNP) 颗粒。\n3.  **ORF1p 功能：** ORF1p 是一种RNA结合分子伴侣，对于包裹、稳定 RNP 内的长 L1 RNA 并作为其分子伴侣至关重要。\n4.  **ORF2p 功能：** ORF2p 拥有反转录转座所需的酶活性：一种核酸内切酶，用于在靶基因组DNA上造成切口，以及一种反转录酶，用于从RNA模板合成cDNA。这个过程被称为靶标引物反转录 (TPRT)。\n5.  **SINE 反转录转座：** Alu SINEs 是非自主性元件。它们不编码任何蛋白质。它们被转录成带有聚腺苷酸尾的RNA，并且必须“寄生”于 L1 机制（特别是 ORF2p 以及可能还有 ORF1p）才能被反转录转座。\n\n**实验条件分析：**\n\n**条件1：仅过表达 ORF2p**\n在此设置中，ORF2p 从一个异源启动子表达，这意味着其mRNA不是一个全长的 L1 转录本。因此，顺式偏好性的自然机制被颠覆了。细胞中充满了未与 L1 RNA 或 ORF1p 预先结合的“游离”ORF2p。\n\n*   **L1 报告基因动员：** 为了使一个 L1 报告RNA能够被高效地反转录转座，它必须形成一个稳定的 RNP。这需要 ORF1p（作为分子伴侣）和 ORF2p。由于 ORF1p 没有被过表达，L1 报告基因必须搜寻低水平的内源性 ORF1p。此外，过表达的 ORF2p 是以*反式*作用提供的，由于 L1 机制强烈的顺式偏好性，这是一种形成 L1 RNP 的低效方式。缺乏足够的 ORF1p 分子伴侣使得长的、脆弱的 L1 RNA 易于降解，并阻止了能够进行核输入和TPRT的功能性RNP的形成。因此，预计 L1 报告基因的动员将是极其低效的。\n*   **Alu SINE 报告基因动员：** Alu RNA是带有聚腺苷酸尾的短非编码RNA。这些元件可以寄生于以*反式*作用提供的大量游离 ORF2p。公认 ORF2p 可以结合到聚腺苷酸化的RNA上。游离的 ORF2p 可以结合到一个 Alu RNA 上，将其转运（或在细胞核中与之相遇），并使用 Alu RNA 作为模板执行 TPRT。与长的 L1 RNA 相比，这个过程对基于 ORF1p 的 RNP 没有同样严格的要求，这使得仅 ORF2p 就能动员 SINEs。\n\n这一分析合理解释了问题中所述的观察结果：仅过表达 ORF2p 可以动员 SINEs，但不能有效动员新的 L1 拷贝。\n\n**条件2：过表达 ORF2p 并敲低内源性 ORF1p**\n在这里，关键的 ORF1p 分子伴侣的水平被进一步降低。\n\n*   **L1 报告基因动员：** 由于缺乏共表达的 ORF1p 和顺式偏好性的破坏，动员本已低效。敲低剩余的内源性 ORF1p 将使 L1 报告RNA更加缺乏其必需的分子伴侣，使得功能性RNP的形成几乎不可能。因此，L1 报告基因活性应该会进一步降低。\n*   **Alu SINE 报告基因动员：** 由于 SINE 的动员主要依赖于寄生游离的 ORF2p，而对 ORF1p 的依赖性较小，因此这项活动应保持在较高水平。一些证据表明，ORF1p 可能与 SINE RNA 竞争结合 ORF2p；如果是这样，去除 ORF1p 甚至可能增加 SINE 的动员。因此，预计 SINE 活性将保持高水平或潜在增加。\n*   **基因组稳定性：** ORF1p 不仅是一个分子伴侣，也是 RNP 的一个关键组分，被认为可以调节和靶向 ORF2p 的强大酶活性。在没有足够 ORF1p 的情况下，大量过量的“裸露的”ORF2p 未被束缚且不受调控。其核酸内切酶活性可导致广泛的、脱靶的DNA切口和双链断裂（DSBs），从而导致显著的基因组不稳定性。此外，其反转录酶可以滥捕获其他细胞内的聚腺苷酸化RNA（即细胞基因的mRNA），将它们反转录，并将产生的cDNA插回基因组，形成加工假基因。这是基因组损伤的另一个主要来源。\n\n**选项评估：**\n\n**A.** 该选项指出 ORF2p 以*反式*作用，识别聚腺苷酸尾，并在不需要 ORF1p 的情况下动员 Alu SINEs。它正确地将此与需要依赖 ORF1p 的 L1 RNP 进行分子伴侣和顺式偏好性的高效 L1 反转录转座进行对比。然后，它正确地预测，在敲低 ORF1p 后，L1 活性将降低，SINE 活性将保持升高或增加，加工假基因的形成将增多，并且由于未受约束的 ORF2p 核酸内切酶活性，DNA损伤（DSBs）将增加。这与上面的详细分析完全一致。\n**结论：正确**\n\n**B.** 该选项声称 ORF1p 对于 L1 和 Alu 的反转录转座都是可有可无的。这在根本上是错误的。正如问题所给条件中陈述的，ORF1p 的分子伴侣功能对于长 L1 RNA 的完整性和加工至关重要。因此，其关于敲低 ORF1p 没有影响的预测也是错误的。\n**结论：错误**\n\n**C.** 该选项错误地声称 ORF2p 不能使用 Alu SINE RNA 作为模板，因为它们缺少一个 5' 端帽。ORF2p 的识别主要由 3' 聚腺苷酸尾介导，而不是 5' 端帽。该选项直接与问题中 SINEs *可以*被动员的观察结果相矛盾。它还错误地声称 L1 可以在没有 ORF1p 的情况下高效动员，并且DNA损伤将是最小的。\n**结论：错误**\n\n**D.** 该选项错误地将 ORF1p 的主要作用描述为 SINE 寄生的抑制剂，而其已知的主要作用是作为 L1 RNA 的分子伴侣。然后，它通过声称仅 ORF2p 未能动员 SINEs 来与问题的前提相矛盾。其关于敲低 ORF1p 会增加 L1 动员的预测是不合逻辑的，因为它移除了一个必需的组分。声称 DNA 损伤会减少的说法与不受调控的 ORF2p 的预期结果相反。\n**结论：错误**\n\n**E.** 该选项做出了一个强烈且通常不正确的声明，即在没有 ORF1p 的情况下 ORF2p 缺乏核酸内切酶活性。如果这是真的，仅过表达 ORF2p 将不能通过 TPRT 动员 SINEs，这与问题的前提相矛盾。其对DNA损伤的解释也是矛盾的：如果 ORF2p 在没有 ORF1p 的情况下是酶学上无活性的，那么它仅仅在染色质上的积累不应引起切口或断裂。\n**结论：错误**\n\n基于这一严谨的分析，选项A是唯一为观察到的现象和实验的预测结果提供了科学合理且完整解释的选项。", "answer": "$$\\boxed{A}$$", "id": "2846740"}, {"introduction": "随着全基因组测序技术的出现，我们现在可以在大规模尺度上发现逆转录转座子插入。这项实践练习将让你扮演生物信息学家的角色。你将实施一个计算流程，从短读长测序数据中识别新的$L1$和$Alu$插入，并应用一系列过滤器，在复杂的基因组背景中区分真实信号与假象。[@problem_id:2846706]", "problem": "您的任务是形式化一个计算识别流程，用于从短读长全基因组测序（WGS）数据中，利用分裂读（split-read）和不一致配对（discordant-pair）证据，识别长散在核元件-1（L1）和Alu短散在核元件（SINEs）的非参考插入，并实施明确的过滤器以减少重复区域的假阳性。该流程必须表示为一个确定性决策函数，该函数在给定一个由一组特征概括的候选位点时，输出L1、Alu或reject（拒绝）中的一个标签。其设计必须从遗传学和测序的第一性原理出发进行论证，但其实现本身应遵循下文定义的精确、可复现的规则集。\n\n基础背景与可观察信号：\n- 中心法则和基因组结构意味着逆转座子插入通过在参考序列和插入元件序列之间创建新的连接点来改变参考基因组。跨越此类连接点的Illumina双末端短读长会产生分裂读比对和不一致读对信号。\n- 非长末端重复序列（non-LTR）逆转座子插入，包括长散在核元件-1（LINE-1，缩写为L1）和Alu，通常以多聚腺嘌呤尾巴和由靶标引物逆转录（target-primed reverse transcription）在插入位点引起的短靶位重复为特征。\n- 在重复区域，比对模糊性会增加虚假信号；稳健的过滤器必须考虑比对质量、重复背景和信号的一致性。\n\n根据每个候选位点的以下变量定义决策规则：\n- 分裂读计数：$s_L$, $s_R$（左、右断点）。\n- 不一致配对计数：$d_L$, $d_R$（左、右集群）。\n- 分裂读的中位比对质量：$m_L$, $m_R$。\n- 一个$1{,}000$碱基对窗口内的局部重复或低可比对性分数：$r$，表示为$[0,1]$范围内的实数。\n- 与同一家族最近的已注释参考转座元件的距离（以碱基对为单位）：$p$，必须以碱基对（bp）为单位处理。\n- 来自读对布局的方向一致性标志：$o \\in \\{\\text{True}, \\text{False}\\}$。\n- 从软剪切（soft-clipped）共有序列估计的多聚腺嘌呤尾巴长度：$a$（以碱基对为单位）。\n- 靶位重复长度估计：$t$（以碱基对为单位）。\n- 分裂剪切（split-clip）比对到元件共有序列的支持度：$c_{L1}$（L1共有序列），$c_{Alu}$（Alu共有序列）。\n- 断点一致性偏差：$b$（绝对偏差，以碱基对为单位），表示推断的左、右断点间距与靶位重复长度之间的绝对差值。\n\n定义流程如下：\n1) 证据聚合：\n   - 计算支持分数 $S = s_L + s_R + 0.5 \\times (d_L + d_R)$。要求 $S \\ge T$，其中 $T = 4$。\n2) 分裂读两侧要求：\n   - 或者 $s_L \\ge 1$ 且 $s_R \\ge 1$，或者，如果至少一侧的分裂读为零，则要求 $d_L + d_R \\ge 6$。\n3) 比对质量过滤：\n   - 对于任何 $s_\\cdot > 0$ 的一侧，要求相应的中位比对质量 $m_\\cdot \\ge 20$。如果 $s_\\cdot = 0$，则忽略相应的 $m_\\cdot$。\n4) 重复内容过滤：\n   - 要求 $r \\le 0.6$。\n5) 与参考元件的邻近度过滤：\n   - 要求 $p \\ge 100$ 碱基对。\n6) 方向一致性过滤：\n   - 要求 $o = \\text{True}$。\n7) 多聚腺嘌呤尾巴过滤：\n   - 要求 $a \\ge 8$。\n8) 断点一致性过滤：\n   - 要求 $b \\le 10$ 碱基对。\n9) 通用靶位重复范围：\n   - 要求 $t \\in [4,25]$ 碱基对。\n10) 使用分裂剪切比对支持度进行家族分配：\n    - 如果 $c_{L1} - c_{Alu} \\ge 2$，则分配临时家族 $F = \\text{L1}$。\n    - 否则，如果 $c_{Alu} - c_{L1} \\ge 2$，则分配临时家族 $F = \\text{Alu}$。\n    - 否则，拒绝。\n11) 家族特异性检查：\n    - 如果 $F = \\text{L1}$，额外要求 $a \\ge 12$ 且 $t \\in [5,25]$ 碱基对。\n    - 如果 $F = \\text{Alu}$，额外要求 $a \\ge 8$ 且 $t \\in [7,25]$ 碱基对。\n如果一个候选位点通过所有适用的过滤器，则输出其分配的家族；否则，输出reject。\n\n实现一个程序，将此精确流程应用于以下候选位点测试集。每个测试用例以有序元组 $(s_L,s_R,d_L,d_R,m_L,m_R,r,p,o,a,t,c_{L1},c_{Alu},b)$ 的形式提供，其中距离以碱基对为单位，$r$无单位。布尔值$o$写作$\\text{True}$或$\\text{False}$。\n\n- 测试用例 1：$(3,2,2,1,60,55,0.2,500,\\text{True},22,12,6,1,3)$\n- 测试用例 2：$(2,2,1,1,45,40,0.3,400,\\text{True},11,14,1,5,2)$\n- 测试用例 3：$(1,1,4,0,30,25,0.5,120,\\text{True},8,8,0,3,0)$\n- 测试用例 4：$(3,2,2,2,50,50,0.75,600,\\text{True},20,10,4,1,3)$\n- 测试用例 5：$(0,2,5,4,0,35,0.4,1000,\\text{True},13,10,3,0,4)$\n- 测试用例 6：$(2,2,2,1,40,37,0.25,50,\\text{True},10,12,0,3,1)$\n- 测试用例 7：$(2,2,2,2,50,50,0.2,300,\\text{True},15,9,2,2,1)$\n- 测试用例 8：$(2,2,2,2,45,45,0.2,400,\\text{False},18,10,4,0,2)$\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，每个元素为精确字符串L1、Alu或reject之一，不带引号。例如：“[L1,Alu,reject]”。", "solution": "问题陈述经审阅后被认定有效。它提出了一个定义明确、有科学依据的计算任务，该任务属于生物信息学领域，是定量生物学和计算机科学的一个子学科。该问题是自洽的，其参数是现实的，决策逻辑是确定性的且没有矛盾。因此，我们可以着手进行形式化的求解。\n\n目标是构建一个计算流程，将候选基因组位点分类为长散在核元件-1（L1）或Alu元件的插入，或将其作为假象拒绝。该流程形式化了解析来自短读长全基因组测序（WGS）数据信号的过程。所提供的规则是用于移动元件插入发现的实践算法的一个简化但具有代表性的模型。流程中每一步的理由都植根于分子遗传学和测序技术的原理。\n\n一个候选插入由一个包含$14$个特征的向量定义：$(s_L,s_R,d_L,d_R,m_L,m_R,r,p,o,a,t,c_{L1},c_{Alu},b)$。我们将应用一系列过滤器。在任何一步失败都会导致该候选位点被拒绝。\n\n**1. 证据聚合过滤器**\n插入的主要证据来自“分裂读”（split reads）和“不一致读对”（discordant read pairs）。一个分裂读的一部分比对到参考基因组，另一部分比对到插入的元件或未比对上（软剪切）。一个不一致读对具有异常的方向或插入大小，表明读对之间存在结构性改变。\n总支持分数定义为 $S = s_L + s_R + 0.5 \\times (d_L + d_R)$。变量 $s_L$ 和 $s_R$ 分别是支持左、右断点的分裂读计数。变量 $d_L$ 和 $d_R$ 是不一致读对的计数。不一致配对的权重为$0.5$，因为它们被认为是比分裂读精度较低的证据。候选位点必须具有最低的聚合支持分数：\n$$\nS \\ge T \\quad \\text{其中} \\quad T=4\n$$\n这个初始过滤器移除了证据不足、无法与背景噪声可靠区分的位点。\n\n**2. 断点确认过滤器**\n一个插入事件有两个断点。理想情况下，两者都由分裂读支持。规则是：\n$$\n(s_L \\ge 1 \\text{ 且 } s_R \\ge 1) \\quad \\text{或} \\quad (d_L + d_R \\ge 6)\n$$\n如果分裂读没有覆盖插入位点的两侧，则需要比平均水平更多的不一致读对来弥补。这处理了一侧断点位于难以进行唯一读长比对区域的情况。\n\n**3. 比对质量过滤器**\n读长比对的模糊性是假阳性的主要来源。比对质量（$MQ$）是比对错误的PHRED标度概率。该过滤器要求分裂读比对具有高置信度：\n$$\n\\text{若 } s_L > 0, \\text{ 则 } m_L \\ge 20 \\quad \\text{且} \\quad \\text{若 } s_R > 0, \\text{ 则 } m_R \\ge 20\n$$\n其中 $m_L$ 和 $m_R$ 是中位比对质量。阈值$20$对应$1\\%$的比对错误概率，是结构变异分析的标准最低要求。\n\n**4. 重复背景过滤器**\n具有高重复密度的基因组区域会导致系统性的读长错误比对。我们过滤掉位于此类问题区域的候选位点：\n$$\nr \\le 0.6\n$$\n这里，$r$是候选位点周围$1,000$个碱基对窗口内被注释为重复或可比对性低的区域的比例。\n\n**5. 邻近度过滤器**\n靠近参考基因组中现有转座元件的信号可能是假象。为避免这种情况，候选位点必须与同一家族的已知元件保持足够的距离：\n$$\np \\ge 100 \\text{ bp}\n$$\n其中$p$是到最近的已注释参考元件的距离。\n\n**6. 读对方向过滤器**\n一个典型的逆转座子插入会在双末端测序数据中产生一个特征性信号（例如，正向-反向方向下插入片段大小增加）。该过滤器要求存在这种预期的信号：\n$$\no = \\text{True}\n$$\n这有助于将真正的插入与其他结构变异（如倒位或易位）区分开来。\n\n**7. 多聚腺嘌呤尾巴过滤器**\n介导L1和Alu插入的靶标引物逆转录（TPRT）机制会在新元件的$3'$端产生一个多聚A尾巴。足够长的多聚A尾巴的存在是真实逆转座事件的有力证据。\n$$\na \\ge 8 \\text{ bp}\n$$\n其中$a$是估计的多聚A尾巴的长度。\n\n**8. 断点一致性过滤器**\n一个简单插入的左、右断点应该是连续的，仅由靶位重复序列隔开。不精确的比对可能会产生微小的间隙或重叠。大的差异表明可能是一个更复杂的事件或假象。\n$$\nb \\le 10 \\text{ bp}\n$$\n其中$b$是推断的断点间距与TSD长度之间的绝对偏差。\n\n**9. 靶位重复（TSD）过滤器**\nTPRT在插入位点处创建了一个短的基因组序列重复，称为TSD。TSD的长度是一个标志性特征。\n$$\nt \\in [4, 25] \\text{ bp}\n$$\n其中$t$是估计的TSD长度。\n\n**10. 家族分配逻辑**\n如果一个候选位点通过了所有前面的过滤器，则通过比较比对到L1与Alu共有序列的分裂读剪切片段的支持度来确定其家族。\n- 如果 $c_{L1} - c_{Alu} \\ge 2$，临时家族为 $F = \\text{L1}$。\n- 如果 $c_{Alu} - c_{L1} \\ge 2$，临时家族为 $F = \\text{Alu}$。\n- 否则，证据不明确，候选位点被拒绝。\n\n**11. 家族特异性过滤器**\n最后，检查更严格的、家族特异性的生化属性。\n- 如果 $F = \\text{L1}$，我们要求更长的多聚A尾巴和特定的TSD范围：$a \\ge 12$ 且 $t \\in [5, 25]$。\n- 如果 $F = \\text{Alu}$，要求略有不同：$a \\ge 8$ 且 $t \\in [7, 25]$。\n\n一个候选位点只有在通过所有通用过滤器及其各自的家族特异性过滤器后，才会被接受并标记为‘L1’或‘Alu’。否则，它将被标记为‘reject’。\n\n**示例演练：测试用例2**\n输入：$(s_L,s_R,d_L,d_R,m_L,m_R,r,p,o,a,t,c_{L1},c_{Alu},b) = (2,2,1,1,45,40,0.3,400,\\text{True},11,14,1,5,2)$。\n1. 支持度 $S = 2+2+0.5 \\times(1+1) = 5$。$5 \\ge 4$。通过。\n2. 两侧：$s_L=2 \\ge 1$ 且 $s_R=2 \\ge 1$。通过。\n3. MQ: $m_L=45 \\ge 20$, $m_R=40 \\ge 20$。通过。\n4. 重复性：$r=0.3 \\le 0.6$。通过。\n5. 邻近度：$p=400 \\ge 100$。通过。\n6. 方向：$o=\\text{True}$。通过。\n7. Poly-A: $a=11 \\ge 8$。通过。\n8. 一致性：$b=2 \\le 10$。通过。\n9. TSD: $t=14 \\in [4,25]$。通过。\n10. 家族：$c_{Alu} - c_{L1} = 5-1 = 4$。$4 \\ge 2$。临时家族 $F = \\text{Alu}$。\n11. 家族特异性 (Alu):\n    - $a=11 \\ge 8$。通过。\n    - $t=14 \\in [7,25]$。通过。\n所有过滤器均通过。结果是 **Alu**。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Applies a deterministic decision function to classify candidate retrotransposon\n    insertions based on a set of genomic and sequencing features.\n    \"\"\"\n\n    # Test cases as tuples of (s_L, s_R, d_L, d_R, m_L, m_R, r, p, o, a, t, c_L1, c_Alu, b)\n    test_cases = [\n        (3, 2, 2, 1, 60, 55, 0.2, 500, True, 22, 12, 6, 1, 3),   # TC1\n        (2, 2, 1, 1, 45, 40, 0.3, 400, True, 11, 14, 1, 5, 2),   # TC2\n        (1, 1, 4, 0, 30, 25, 0.5, 120, True, 8, 8, 0, 3, 0),     # TC3\n        (3, 2, 2, 2, 50, 50, 0.75, 600, True, 20, 10, 4, 1, 3), # TC4\n        (0, 2, 5, 4, 0, 35, 0.4, 1000, True, 13, 10, 3, 0, 4),   # TC5\n        (2, 2, 2, 1, 40, 37, 0.25, 50, True, 10, 12, 0, 3, 1),   # TC6\n        (2, 2, 2, 2, 50, 50, 0.2, 300, True, 15, 9, 2, 2, 1),   # TC7\n        (2, 2, 2, 2, 45, 45, 0.2, 400, False, 18, 10, 4, 0, 2), # TC8\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_locus(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef classify_locus(s_L, s_R, d_L, d_R, m_L, m_R, r, p, o, a, t, c_L1, c_Alu, b):\n    \"\"\"\n    Implements the full classification pipeline for a single candidate locus.\n    \n    Args:\n        s_L, s_R: split-read counts\n        d_L, d_R: discordant-pair counts\n        m_L, m_R: median mapping qualities of split reads\n        r: local repetitive fraction\n        p: proximity to nearest reference TE\n        o: orientation consistency flag\n        a: poly-adenine tail length estimate\n        t: target site duplication length estimate\n        c_L1, c_Alu: split-clip alignment support for L1/Alu\n        b: breakpoint coherence deviation\n\n    Returns:\n        'L1', 'Alu', or 'reject'\n    \"\"\"\n    \n    # 1) Evidence aggregation\n    T = 4\n    S = s_L + s_R + 0.5 * (d_L + d_R)\n    if S  T:\n        return 'reject'\n\n    # 2) Split-read side requirement\n    if not ((s_L >= 1 and s_R >= 1) or (d_L + d_R >= 6)):\n        return 'reject'\n\n    # 3) Mapping quality filter\n    if (s_L > 0 and m_L  20) or (s_R > 0 and m_R  20):\n        return 'reject'\n\n    # 4) Repeat content filter\n    if r > 0.6:\n        return 'reject'\n\n    # 5) Proximity to reference elements\n    if p  100:\n        return 'reject'\n\n    # 6) Orientation consistency\n    if not o:\n        return 'reject'\n\n    # 7) Poly-adenine tail\n    if a  8:\n        return 'reject'\n        \n    # 8) Breakpoint coherence\n    if b > 10:\n        return 'reject'\n\n    # 9) General target site duplication range\n    if not (4 = t = 25):\n        return 'reject'\n\n    # 10) Family assignment using split-clip alignment support\n    provisional_family = None\n    if c_L1 - c_Alu >= 2:\n        provisional_family = 'L1'\n    elif c_Alu - c_L1 >= 2:\n        provisional_family = 'Alu'\n    else:\n        return 'reject'\n\n    # 11) Family-specific checks\n    if provisional_family == 'L1':\n        if a >= 12 and 5 = t = 25:\n            return 'L1'\n        else:\n            return 'reject'\n    elif provisional_family == 'Alu':\n        if a >= 8 and 7 = t = 25:\n            return 'Alu'\n        else:\n            return 'reject'\n            \n    # This part should not be reached given the logic, but as a fallback.\n    return 'reject'\n\nsolve()\n```", "id": "2846706"}]}