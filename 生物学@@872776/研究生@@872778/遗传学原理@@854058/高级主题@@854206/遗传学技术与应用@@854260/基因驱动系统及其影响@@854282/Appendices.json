{"hands_on_practices": [{"introduction": "基因驱动对种群的抑制效应源于其在群体中散播适应性成本。遗传负荷是衡量有害等位基因导致种群平均适合度降低的经典指标。这项练习 ([@problem_id:2813416]) 将运用群体遗传学的基本原理，通过推导一个携带适应性成本的基因驱动等位基因所造成的遗传负荷，来量化这一核心效应。", "problem": "考虑一个大型随机交配种群，其中一个归巢基因驱动等位基因 $D$ 与一个野生型等位基因 $W$ 共同分离。假设在合子阶段符合Hardy–Weinberg平衡（HWE），并且生存力选择作用于合子与成体阶段之间。设各基因型的相对生存力（适合度）为 $w_{WW}=1$、$w_{DW}=1-hs$ 和 $w_{DD}=1-s$，其中 $s \\in [0,1]$ 是针对纯合驱动基因型的选择系数，$h \\in [0,1]$ 是杂合子中适合度代价的显性系数。假设在合子阶段，驱动等位基因 $D$ 的频率为 $p \\in [0,1]$。\n\n仅使用HWE基因型频率、生存力选择下的平均适合度以及遗传负荷的定义，推导在频率为 $p$ 时由驱动基因施加的遗传负荷的闭式表达式。将遗传负荷定义为 $L = 1 - \\overline{w}/w_{\\max}$，其中 $\\overline{w}$ 是生存力选择后的平均适合度，$w_{\\max}$ 是种群中存在的最大基因型适合度。\n\n请以 $p$、$h$ 和 $s$ 的单一简化解析表达式形式提供最终答案。不需要进行数值计算或四舍五入。", "solution": "必须首先对问题陈述进行严格验证。\n\n第1步：提取已知条件。\n已知条件如下：\n- 一个大型随机交配种群。\n- 两个等位基因：一个归巢基因驱动等位基因 $D$ 和一个野生型等位基因 $W$。\n- 假设在合子阶段符合Hardy–Weinberg平衡（HWE）。\n- 生存力选择作用于合子与成体阶段之间。\n- 各基因型的相对生存力（适合度）：$w_{WW}=1$、$w_{DW}=1-hs$ 和 $w_{DD}=1-s$。\n- 选择系数 $s$ 的范围是 $s \\in [0,1]$。\n- 显性系数 $h$ 的范围是 $h \\in [0,1]$。\n- 在合子阶段，驱动等位基因 $D$ 的频率为 $p \\in [0,1]$。\n- 遗传负荷的定义是 $L = 1 - \\overline{w}/w_{\\max}$，其中 $\\overline{w}$ 是生存力选择后的平均适合度，$w_{\\max}$ 是种群中存在的最大基因型适合度。\n\n第2步：使用提取的已知条件进行验证。\n该问题具有科学依据，采用了群体遗传学中标准的、成熟的模型，即Hardy-Weinberg平衡和生存力选择。适合度结构和遗传负荷的概念是该领域的基础。该问题提法明确，提供了推导唯一解析解所需的所有必要定义、变量和约束条件（$p, h, s \\in [0,1]$）。其语言客观而精确。该问题不违反任何无效性标准；它并非不合理、不完整、矛盾、不现实或过于简单。\n\n第3步：结论与行动。\n问题被判定为有效。将推导解答。\n\n推导从第一性原理开始。假设种群在合子阶段处于Hardy–Weinberg平衡。已知等位基因 $D$ 的频率是 $p$，则野生型等位基因 $W$ 的频率是 $1-p$。因此，合子阶段的基因型频率为：\n- $WW$ 的频率：$f(WW) = (1-p)^2$\n- $DW$ 的频率：$f(DW) = 2p(1-p)$\n- $DD$ 的频率：$f(DD) = p^2$\n\n种群的平均适合度 $\\overline{w}$ 是各种基因型适合度的加权平均值，权重为这些基因型的HWE频率。平均适合度的公式为：\n$$\n\\overline{w} = f(WW)w_{WW} + f(DW)w_{DW} + f(DD)w_{DD}\n$$\n代入给定的频率和适合度值：\n$$\n\\overline{w} = (1-p)^2(1) + 2p(1-p)(1-hs) + p^2(1-s)\n$$\n为简化此表达式，我们展开各项：\n$$\n\\overline{w} = (1 - 2p + p^2) + (2p - 2p^2)(1-hs) + (p^2 - p^2s)\n$$\n通过认识到 $(1-p)^2 + 2p(1-p) + p^2 = ((1-p)+p)^2 = 1^2 = 1$，可以更有效地对各项进行重组。我们可以分离出包含选择系数 $s$ 的项：\n$$\n\\overline{w} = \\left[(1-p)^2 + 2p(1-p) + p^2\\right] - 2p(1-p)hs - p^2s\n$$\n这可以简化为：\n$$\n\\overline{w} = 1 - 2p(1-p)hs - p^2s\n$$\n接下来，我们必须确定最大适合度 $w_{\\max}$。这被定义为种群中存在的最大基因型适合度。各适合度为 $w_{WW}=1$、$w_{DW}=1-hs$ 和 $w_{DD}=1-s$。鉴于约束条件 $s \\in [0,1]$ 和 $h \\in [0,1]$，乘积 $s$ 和 $hs$ 是非负的。因此，$1-hs \\le 1$ 且 $1-s \\le 1$。所以最大适合度是野生型纯合子的适合度：\n$$\nw_{\\max} = w_{WW} = 1\n$$\n现在我们可以使用遗传负荷 $L$ 的定义来计算它：\n$$\nL = 1 - \\frac{\\overline{w}}{w_{\\max}}\n$$\n代入 $\\overline{w}$ 和 $w_{\\max}$ 的表达式：\n$$\nL = 1 - \\frac{1 - 2p(1-p)hs - p^2s}{1}\n$$\n$$\nL = 1 - (1 - 2p(1-p)hs - p^2s)\n$$\n$$\nL = 1 - 1 + 2p(1-p)hs + p^2s\n$$\n这就得出了遗传负荷的表达式：\n$$\nL = 2p(1-p)hs + p^2s\n$$\n为了得到一个简化的闭式表达式，我们可以提取公因子 $p$ 和 $s$：\n$$\nL = ps[2(1-p)h + p]\n$$\n这个最终表达式表示了由频率为 $p$ 的驱动等位基因所施加的遗传负荷，它是选择系数 $s$ 和显性系数 $h$ 的函数。", "answer": "$$\n\\boxed{ps(2h(1-p) + p)}\n$$", "id": "2813416"}, {"introduction": "抗性演化是基因驱动技术面临的最大障碍之一，它可能导致驱动系统失效。当驱动系统切割野生型等位基因时，细胞的修复机制（如非同源末端连接）可能产生新的等位基因，其中一些可以抵抗未来的切割。这项练习 ([@problem_id:2813497]) 建立了一个模型，探讨了不同类型抗性等位基因（功能性与非功能性）之间的演化竞争，这对于预测驱动系统最终是成功抑制种群，还是被演化出的抗性所挫败至关重要。", "problem": "考虑将一个归巢基因驱动释放到一个大的随机交配种群中，通过破坏一个单倍体足量靶基因来抑制其生育能力。在携带一个驱动等位基因和一个野生型等位基因的杂合子中，记野生型等位基因在生殖系中被切割的概率为 $c \\in (0,1]$。在切割发生的情况下，同源指导修复 (HDR) 以概率 $h \\in [0,1)$ 发生，将野生型等位基因转化为驱动等位基因；而非同源末端连接 (NHEJ) 以概率 $1-h$ 发生，产生一个抗性等位基因。在 NHEJ 的结果中，一部分比例为 $p \\in (0,1)$ 的是框内突变，这些突变恢复了靶基因的功能并产生了一个功能性抗性等位基因 $r_1$；而另一部分比例为 $1-p$ 的是移码突变或其他破坏性突变，这些突变产生了一个非功能性抗性等位基因 $r_2$。$r_1$ 和 $r_2$ 等位基因都完全抵抗驱动核酸内切酶的进一步切割。\n\n假设世代是离散且不重叠的，在生存力选择之前，基因型按哈迪-温伯格平衡形成。设 $r_1$ 携带者的相对生存-生育适应度为 $w_1$，$r_2$ 携带者的相对生存-生育适应度为 $w_2$，两者均是相对于设为1的野生型而言。并假设当 $r_1$ 和 $r_2$ 稀有时，它们几乎只出现在与非抗性等位基因形成的杂合子中，因此 $w_1$ 和 $w_2$ 统一地适用于它们的携带者。在抗性稀有时，忽略抗性纯合子和连锁不平衡。将新形成的抗性等位基因的供给视为仅源于驱动/野生型杂合子中的切割修复事件，并注意，任何对 $r_1$ 和 $r_2$ 产生过程共通的因素都不会差异性地偏好其中一种类型。\n\n在这些条件下，功能性抗性与非功能性抗性的相对适应度存在一个明确的阈值，该阈值决定了出现的抗性库是倾向于保护靶基因功能（从而阻断抑制，并有效地将基因驱动转变为一种修饰结果），还是倾向于破坏靶基因功能（从而促进抑制）。定义临界相对适应度比率\n$$\nF^{\\ast} \\equiv \\frac{w_1}{w_2},\n$$\n在此比率下，经过一代的产生和选择后，所有抗性等位基因中 $r_1$ 的期望比例不发生变化。当 $w_1/w_2 > F^{\\ast}$ 时，功能性抗性 $r_1$ 在抗性等位基因中的比例增加并阻断抑制；当 $w_1/w_2  F^{\\ast}$ 时，非功能性抗性 $r_2$ 的比例增加并促进抑制。\n\n仅用 $p$ 的符号形式推导出 $F^{\\ast}$。将最终答案表示为单个简化的符号表达式。不需要进行数值近似。", "solution": "问题要求解临界相对适应度比率 $F^{\\ast} \\equiv \\frac{w_1}{w_2}$，该比率决定了在一个受基因驱动影响的种群中，随着抗性的出现，是功能性抗性等位基因 ($r_1$) 还是非功能性抗性等位基因 ($r_2$) 将占主导地位。该阈值被定义为所有抗性等位基因中 $r_1$ 的期望比例不发生变化的点。\n\n让我们分析当两种抗性等位基因 $r_1$ 和 $r_2$ 稀有时它们的动态。问题指明，新的抗性等位基因仅由驱动/野生型 ($D/W$) 杂合子中的基因驱动活动产生。\n\n新抗性等位基因的产生是通过切割后进行非同源末端连接 (NHEJ) 的过程发生的。让我们将种群中每代野生型等位基因被靶向转化的速率表示为 $R_{conv}$。该速率与 $D/W$ 杂合子的数量、切割概率 $c$ 以及 NHEJ 的概率 $1-h$ 成正比。\n问题陈述，一部分比例为 $p$ 的 NHEJ 事件产生功能性抗性等位基因 $r_1$，一部分比例为 $1-p$ 的事件产生非功能性抗性等位基因 $r_2$。\n\n因此，等位基因 $r_1$ 的从头产生速率（突变率）为 $\\mu_1 = R_{conv} \\cdot p$。\n等位基因 $r_2$ 的从头产生速率为 $\\mu_2 = R_{conv} \\cdot (1-p)$。\n因此，产生速率之比为：\n$$\n\\frac{\\mu_1}{\\mu_2} = \\frac{R_{conv} \\cdot p}{R_{conv} \\cdot (1-p)} = \\frac{p}{1-p}\n$$\n问题陈述“任何对 $r_1$ 和 $r_2$ 产生过程共通的因素都不会差异性地偏好其中一种类型”，这证明了关注由 $p$ 决定的相对速率是合理的。\n\n这些新产生的等位基因以及任何预先存在的抗性等位基因，随后都会受到选择。$r_1$ 携带者的相对生存-生育适应度为 $w_1$，$r_2$ 携带者的为 $w_2$。\n\n哪种等位基因类型会主导新兴的抗性库，这个问题取决于哪种类型从稀有状态开始具有更高的有效增长率。在基因驱动文献中，一个针对此场景的常用（尽管简化了的）模型，考虑的是“适应性等位基因”引入种群的有效速率。该速率被认为是一个等位基因的从头产生速率与其适应度的乘积。这个量代表了每一代中，新的、经选择加权的等位基因副本在种群中出现的速率。\n\n$r_1$ 的有效引入速率可以写为：\n$$\n\\text{Rate}_{eff}(r_1) \\propto \\mu_1 w_1\n$$\n而 $r_2$ 的有效引入速率为：\n$$\n\\text{Rate}_{eff}(r_2) \\propto \\mu_2 w_2\n$$\n临界阈值 $F^{\\ast}$ 代表了两种等位基因都没有优势的条件；也就是说，它们的有效引入速率相等。\n$$\n\\mu_1 w_1 = \\mu_2 w_2\n$$\n我们可以重排这个方程来求解比率 $\\frac{w_1}{w_2}$：\n$$\n\\frac{w_1}{w_2} = \\frac{\\mu_2}{\\mu_1}\n$$\n代入我们之前找到的产生速率之比：\n$$\n\\frac{w_1}{w_2} = \\frac{1-p}{p}\n$$\n根据定义，临界相对适应度比率为 $F^{\\ast} \\equiv \\frac{w_1}{w_2}$。因此，我们推导出了 $F^{\\ast}$ 的表达式。\n$$\nF^{\\ast} = \\frac{1-p}{p}\n$$\n让我们根据问题中描述的条件来验证这个阈值。如果 $\\frac{w_1}{w_2} > F^{\\ast}$，则 $\\frac{w_1}{w_2} > \\frac{1-p}{p}$，这意味着 $p w_1 > (1-p) w_2$，因此 $\\mu_1 w_1 > \\mu_2 w_2$。在这种情况下，功能性抗性等位基因 $r_1$ 的有效引入速率大于非功能性等位基因 $r_2$，因此预计 $r_1$ 在抗性库中的比例会增加。这与问题陈述一致。相反，如果 $\\frac{w_1}{w_2}  F^{\\ast}$，$r_2$ 将更占优势。因此，在此模型框架下，推导出的表达式是正确的。", "answer": "$$\\boxed{\\frac{1-p}{p}}$$", "id": "2813497"}, {"introduction": "理论模型与实验研究之间需要一座桥梁。模型中的参数，如切割效率 $c$ 和修复路径概率 $h$，并非抽象符号，而是必须通过实验数据来测量的生物学现实。这项计算练习 ([@problem_id:2813409]) 模拟了研究人员的核心任务：利用来自笼养实验的时间序列数据，通过统计推断来估计这些关键参数。这是评估和优化基因驱动构件、将理论付诸实践的关键一步。", "problem": "你的任务是构建一个完整、可运行的程序，该程序使用基于似然的原则性方法，在一个简化的基因驱动模型中，根据一个封闭的、随机交配种群（笼养实验）中等位基因计数的时间序列数据来推断剪切和修复参数。该系统在单个基因座上涉及三个等位基因：野生型（$W$）、驱动型（$D$）和抗性型（$R$）。驱动等位基因基于成簇规律间隔短回文重复序列（CRISPR）机制。野生型等位基因的转换可能通过剪切后修复发生，通过同源定向修复（HDR）导致驱动型转换，或通过非同源末端连接（NHEJ）导致抗性。\n\n使用的基本原理：\n- 孟德尔分离和随机交配。\n- 随机交配下合子形成时的哈代-温伯格比例。\n- 大种群中确定性的等位基因频率递归。\n- 观测等位基因计数的多项式采样噪声。\n- 定义：设 $c \\in [0,1]$ 表示 $W D$ 杂合子中野生型等位基因的剪切概率。在发生剪切的条件下，设 $h \\in [0,1]$ 表示修复通过同源定向修复（HDR）产生驱动等位基因的概率。修复以概率 $(1-h)$ 通过非同源末端连接（NHEJ）产生抗性等位基因。\n\n模型假设和推导要求：\n- 设离散世代 $t$ 的成体等位基因频率向量为 $\\mathbf{f}_t = (w_t, d_t, r_t)$，其中 $w_t + d_t + r_t = 1$。\n- 假设随机交配导致配子发生前符合哈代-温伯格基因型频率，即 $W W$ 为 $w_t^2$，$D D$ 为 $d_t^2$，$R R$ 为 $r_t^2$，以及杂合子 $W D$、$W R$ 和 $D R$ 分别为 $2 w_t d_t$、$2 w_t r_t$ 和 $2 d_t r_t$。\n- 假设 CRISPR 核酸酶仅存在于携带驱动等位基因 $D$ 的基因型中。剪切和修复仅在配子发生期间影响 $W D$ 杂合子中与驱动等位基因配对的野生型等位基因 $W$。具体来说，在 $W D$ 中：\n  - $D$ 等位基因完整地传递给配子。\n  - $W$ 等位基因以概率 $c$ 被剪切；如果被剪切，它以概率 $h$ 变为 $D$（HDR），或以概率 $(1-h)$ 变为 $R$（NHEJ）。如果未被剪切（概率为 $(1-c)$），它保持为 $W$。\n- 在 $W R$、$D R$、$W W$、$D D$ 或 $R R$ 中，除了标准的孟德尔分离外，不发生转换。\n- 设 $\\mathbf{g}_t = (g_{W,t}, g_{D,t}, g_{R,t})$ 为世代 $t$ 通过对上述规则所隐含的各基因型类别贡献求和而产生的配子等位基因频率。下一代的成体等位基因频率满足 $\\mathbf{f}_{t+1} = \\mathbf{g}_t$（无选择，无迁移）。\n- 观测：在每个世代 $t \\in \\{0,1,2,\\dots,T\\}$，从成体种群中抽取一个包含 $M_t$ 条染色体（等位基因）的样本，产生观测计数 $\\mathbf{X}_t = (X_{W,t}, X_{D,t}, X_{R,t})$，其中 $X_{W,t} + X_{D,t} + X_{R,t} = M_t$。假设 $\\mathbf{X}_t \\sim \\text{Multinomial}(M_t, \\mathbf{f}_t)$，且在不同时间 $t$ 之间独立。\n\n似然框架：\n- 对于一个候选参数对 $(c,h)$ 和一个已知的初始等位基因频率 $\\mathbf{f}_0$，该模型通过递归确定性地生成 $\\mathbf{f}_1, \\dots, \\mathbf{f}_T$。在多项式采样下，对数似然（不含与 $(c,h)$ 无关的加性常数）为\n$$\n\\ell(c,h) \\propto \\sum_{t=0}^{T} \\sum_{a \\in \\{W,D,R\\}} X_{a,t} \\log f_{a,t}(c,h),\n$$\n其中 $f_{a,t}(c,h)$ 是在参数 $(c,h)$ 下，模型预测的在时间 $t$ 时等位基因 $a$ 的频率。\n- 你必须在计算中稳健地处理零值；当 $X_{a,t} = 0$ 时，即使 $f_{a,t} = 0$，该项的贡献也为 $0$。在数值上，将模型概率裁剪到一个小的 $\\varepsilon$ 值（例如 $\\varepsilon = 10^{-12}$）以避免 $\\log(0)$，这既保留了 $X_{a,t} = 0$ 时的正确极限，又惩罚了那些为观测到的非零计数预测零概率的参数值。\n\n编程任务：\n- 根据上述生物学规则，从一个已知的初始 $\\mathbf{f}_0$ 开始，实现从 $\\mathbf{f}_t$ 到 $\\mathbf{f}_{t+1}$ 的确定性递归。\n- 在闭合单位正方形内对 $(c,h)$ 进行网格搜索（为避免数值问题，不包括精确的 $0$ 和 $1$），分辨率需足以在研究生水平的精度上识别最大似然估计。对于 $c$ 和 $h$，在 $[0.001, 0.999]$ 范围内至少使用 $0.01$ 的步长。对于每个网格点，使用观测计数和模型预测的频率计算对数似然（不含加性常数）。\n- 对于测试套件中的每个数据集，报告最大似然估计值 $\\hat{c}$ 和 $\\hat{h}$ 以及最大化的对数似然值。将所有三个报告值四舍五入到三位小数。\n\n测试套件：\n提供一个程序来解决以下三个数据集。在所有情况下，将初始成体等位基因频率 $\\mathbf{f}_0$ 视为来自创始混合种群的已知值；或者，等价地，你可以将其取为 $t=0$ 时的归一化计数。\n\n- 数据集 A（中度驱动，混合修复）：\n  - 时间点 $t = 0,1,2$，其中 $M_t = 200$。\n  - 按世代划分的观测等位基因计数 $(W,D,R)$：\n    - $t=0$: $[180, 20, 0]$\n    - $t=1$: $[165, 29, 6]$\n    - $t=2$: $[147, 40, 13]$\n\n- 数据集 B（近乎无剪切，HDR主导的修复）：\n  - 时间点 $t = 0,1,2$，其中 $M_t = 200$。\n  - 按世代划分的观测等位基因计数 $(W,D,R)$：\n    - $t=0$: $[100, 100, 0]$\n    - $t=1$: $[98, 102, 0]$\n    - $t=2$: $[95, 104, 1]$\n\n- 数据集 C（高剪切，NHEJ主导的修复产生抗性）：\n  - 时间点 $t = 0,1,2$，其中 $M_t = 200$。\n  - 按世代划分的观测等位基因计数 $(W,D,R)$：\n    - $t=0$: $[190, 10, 0]$\n    - $t=1$: $[181, 12, 7]$\n    - $t=2$: $[171, 14, 15]$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个数据集的结果本身是一个包含三个浮点数的列表 $[\\hat{c}, \\hat{h}, \\widehat{\\ell}]$，四舍五入到三位小数。例如：\n  - 输出格式：$[[\\hat{c}_A,\\hat{h}_A,\\widehat{\\ell}_A],[\\hat{c}_B,\\hat{h}_B,\\widehat{\\ell}_B],[\\hat{c}_C,\\hat{h}_C,\\widehat{\\ell}_C]]$\n- 没有物理单位或角度需要报告。所有值都是无量纲的。将任何比例或概率表示为小数（而非百分比）。", "solution": "该问题已经过验证，被认为是有效的。它提出了一个在统计群体遗传学领域中适定且有科学依据的问题。所有必要组成部分——生物模型、统计框架和经验数据——都已清晰且无矛盾地提供。任务是推断一个标准基因驱动模型的参数，这是计算生物学中一个非平凡但标准的练习。\n\n解决方案首先推导等位基因频率动态的确定性模型，然后为观测到的计数数据构建对数似然函数，最后详细说明用于寻找参数最大似然估计的网格搜索过程。\n\n该系统涉及三个等位基因：野生型（$W$）、驱动型（$D$）和抗性型（$R$）。设世代 $t$ 的等位基因频率为 $\\mathbf{f}_t = (w_t, d_t, r_t)$，其中 $w_t+d_t+r_t = 1$。在随机交配的情况下，世代 $t$ 开始时的合子基因型频率由哈代-温伯格比例给出：$WW$ 为 $w_t^2$，$DD$ 为 $d_t^2$，$RR$ 为 $r_t^2$，$WD$ 为 $2w_td_t$，$WR$ 为 $2w_tr_t$，$DR$ 为 $2d_tr_t$。\n\n模型的核心是在配子发生期间仅在 $WD$ 杂合子中发生的基因转换过程。在这些个体（频率为 $2w_td_t$）中，$D$ 等位基因正常传递。然而，$W$ 等位基因以概率 $c$ 被剪切。如果被剪切，它通过同源定向修复（HDR）以概率 $h$ 修复为 $D$ 等位基因，或通过非同源末端连接（NHEJ）以概率 $(1-h)$ 修复为 $R$ 等位基因。如果未被剪切（概率为 $1-c$），它保持为 $W$ 等位基因。所有其他基因型都经历标准的孟德尔分离。\n\n为了推导下一代的等位基因频率 $\\mathbf{f}_{t+1} = (w_{t+1}, d_{t+1}, r_{t+1})$，我们将来自每个亲代基因型类别的对配子库的贡献按其频率加权求和。\n\n$W$ 配子的频率 $w_{t+1}$ 由以下贡献组成：\n- $WW$ 基因型（频率 $w_t^2$）：贡献 $w_t^2$。\n- $WR$ 基因型（频率 $2w_tr_t$）：贡献 $\\frac{1}{2}(2w_tr_t) = w_tr_t$。\n- $WD$ 基因型（频率 $2w_td_t$）：$W$ 等位基因以 $(1-c)$ 的概率传递下去。这个子库的大小为 $w_td_t$。因此，贡献为 $w_td_t(1-c)$。\n将这些相加得到：\n$$w_{t+1} = w_t^2 + w_tr_t + w_td_t(1-c) = w_t(w_t+r_t+d_t) - w_t d_t c = w_t(1-cd_t)$$\n\n$D$ 配子的频率 $d_{t+1}$ 由以下贡献组成：\n- $DD$ 基因型（频率 $d_t^2$）：贡献 $d_t^2$。\n- $DR$ 基因型（频率 $2d_tr_t$）：贡献 $\\frac{1}{2}(2d_tr_t) = d_tr_t$。\n- $WD$ 基因型（频率 $2w_td_t$）：$D$ 等位基因被传递下去（贡献 $w_td_t$），并且 $W$ 等位基因以概率 $ch$ 转换为 $D$（贡献 $w_td_tch$）。\n将这些相加得到：\n$$d_{t+1} = d_t^2 + d_tr_t + w_td_t + w_td_tch = d_t(d_t+r_t+w_t) + w_td_tch = d_t(1+chw_t)$$\n\n$R$ 配子的频率 $r_{t+1}$ 由以下贡献组成：\n- $RR$ 基因型（频率 $r_t^2$）：贡献 $r_t^2$。\n- $WR$ 基因型（频率 $2w_tr_t$）：贡献 $\\frac{1}{2}(2w_tr_t) = w_tr_t$。\n- $DR$ 基因型（频率 $2d_tr_t$）：贡献 $\\frac{1}{2}(2d_tr_t) = d_tr_t$。\n- $WD$ 基因型（频率 $2w_td_t$）：$W$ 等位基因以概率 $c(1-h)$ 转换为 $R$。贡献为：$w_td_tc(1-h)$。\n将这些相加得到：\n$$r_{t+1} = r_t^2 + w_tr_t + d_tr_t + w_td_tc(1-h) = r_t(r_t+w_t+d_t) + w_td_tc(1-h) = r_t + c(1-h)w_td_t$$\n\n因此，系统的状态通过以下确定性递归进行演化：\n$$ \\mathbf{f}_{t+1} = \\left( w_t(1-cd_t), \\quad d_t(1+chw_t), \\quad r_t + c(1-h)w_td_t \\right) $$\n\n观测数据由每个世代 $t$ 从大小为 $M_t$ 的样本中得到的等位基因计数 $\\mathbf{X}_t = (X_{W,t}, X_{D,t}, X_{R,t})$ 组成。这些计数被建模为从多项式分布中的抽样：$\\mathbf{X}_t \\sim \\text{Multinomial}(M_t, \\mathbf{f}_t(c,h))$，其中 $\\mathbf{f}_t(c,h)$ 是由给定参数对 $(c,h)$ 的递归所预测的在世代 $t$ 的等位基因频率向量。初始频率 $\\mathbf{f}_0$ 取自 $t=0$ 时的观测计数。\n\n给定完整计数时间序列，参数 $(c,h)$ 的对数似然是每一代对数似然的总和：\n$$ \\ell(c,h) = \\sum_{t=0}^{T} \\log P(\\mathbf{X}_t | \\mathbf{f}_t(c,h)) $$\n忽略不依赖于参数的常数项，这与以下表达式成正比：\n$$ \\ell(c,h) \\propto \\sum_{t=0}^{T} \\sum_{a \\in \\{W,D,R\\}} X_{a,t} \\log f_{a,t}(c,h) $$\n为避免当预测频率 $f_{a,t}(c,h)$ 对于非零计数 $X_{a,t}$ 为零时出现 $\\log(0)$ 的数值问题，预测频率被裁剪到一个小的正值 $\\varepsilon = 10^{-12}$。这正确地对与观测结果不一致的参数值施加了巨大的惩罚。\n\n为了找到最大似然估计 $(\\hat{c}, \\hat{h})$，我们在参数空间上进行网格搜索。问题指定了 $c$ 和 $h$ 在区间 $[0.001, 0.999]$ 上，步长为 $0.01$ 的网格。对于该网格上的每一对 $(c,h)$，为每个数据集执行以下过程：\n1. 从 $t=0$ 的计数数据初始化等位基因频率 $\\mathbf{f}_0$。\n2. 使用递归方程计算理论频率轨迹 $\\mathbf{f}_1, \\dots, \\mathbf{f}_T$。\n3. 通过对所有时间点 $t=0, \\dots, T$ 的贡献求和，计算总对数似然 $\\ell(c,h)$。\n4. 在整个网格中产生最高对数似然值的配对 $(\\hat{c}, \\hat{h})$ 被保留为最大似然估计，连同其对应的对数似然值 $\\widehat{\\ell}$。\n此过程对所提供的三个数据集实施。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the maximum likelihood estimates of gene drive parameters\n    for three datasets using a grid search.\n    \"\"\"\n    \n    # Epsilon for numerical stability to avoid log(0)\n    EPSILON = 1e-12\n\n    def get_next_gen_freqs(f_t, c, h):\n        \"\"\"\n        Calculates the allele frequencies for the next generation based on the\n        deterministic model.\n\n        Args:\n            f_t (tuple): A tuple (w, d, r) of allele frequencies at generation t.\n            c (float): The cleavage probability.\n            h (float): The HDR probability, conditional on cleavage.\n\n        Returns:\n            tuple: A tuple (w_tp1, d_tp1, r_tp1) of allele frequencies at generation t+1.\n        \"\"\"\n        w_t, d_t, r_t = f_t\n        \n        # Recursion equations derived from the model\n        w_tp1 = w_t * (1.0 - c * d_t)\n        d_tp1 = d_t * (1.0 + c * h * w_t)\n        r_tp1 = r_t + c * (1.0 - h) * w_t * d_t\n        \n        # Renormalize to ensure sum is exactly 1, correcting for potential floating point error\n        total = w_tp1 + d_tp1 + r_tp1\n        if total == 0:\n            return (0.0, 0.0, 0.0)\n        return (w_tp1 / total, d_tp1 / total, r_tp1 / total)\n\n    def calculate_log_likelihood(counts_data, c, h):\n        \"\"\"\n        Calculates the log-likelihood of the observed count data for a given \n        set of parameters (c, h).\n\n        Args:\n            counts_data (list): A list of tuples, where each tuple contains the \n                                observed allele counts (X_W, X_D, X_R) for a generation.\n            c (float): The cleavage probability.\n            h (float): The HDR probability, conditional on cleavage.\n\n        Returns:\n            float: The calculated log-likelihood value.\n        \"\"\"\n        log_likelihood = 0.0\n        \n        # Initial frequencies are derived from the first time point's counts\n        M0 = sum(counts_data[0])\n        if M0 == 0:\n            return -np.inf # Cannot start from no observations\n        f_t = (counts_data[0][0] / M0, counts_data[0][1] / M0, counts_data[0][2] / M0)\n\n        for t, counts in enumerate(counts_data):\n            # For t > 0, evolve frequencies from previous generation\n            if t > 0:\n                f_t = get_next_gen_freqs(f_t, c, h)\n\n            f_W, f_D, f_R = f_t\n            X_W, X_D, X_R = counts\n            \n            # Clip predicted frequencies to avoid log(0) and re-normalize\n            f_W_clipped = max(f_W, EPSILON)\n            f_D_clipped = max(f_D, EPSILON)\n            f_R_clipped = max(f_R, EPSILON)\n            \n            norm_factor = f_W_clipped + f_D_clipped + f_R_clipped\n            f_W_final = f_W_clipped / norm_factor\n            f_D_final = f_D_clipped / norm_factor\n            f_R_final = f_R_clipped / norm_factor\n            \n            # Sum the log-likelihood contributions for this time point\n            log_likelihood += X_W * np.log(f_W_final) + X_D * np.log(f_D_final) + X_R * np.log(f_R_final)\n            \n        return log_likelihood\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"A\": [\n            (180, 20, 0),\n            (165, 29, 6),\n            (147, 40, 13)\n        ],\n        \"B\": [\n            (100, 100, 0),\n            (98, 102, 0),\n            (95, 104, 1)\n        ],\n        \"C\": [\n            (190, 10, 0),\n            (181, 12, 7),\n            (171, 14, 15)\n        ]\n    }\n\n    results = []\n\n    # Define grid for parameters c and h as specified\n    c_grid = np.arange(0.001, 1.0, 0.01)\n    h_grid = np.arange(0.001, 1.0, 0.01)\n\n    # An ordered list of keys to ensure consistent output order\n    case_ids = sorted(test_cases.keys())\n\n    for case_id in case_ids:\n        counts_data = test_cases[case_id]\n        \n        max_log_likelihood = -np.inf\n        best_c = None\n        best_h = None\n        \n        # Perform grid search\n        for c in c_grid:\n            for h in h_grid:\n                current_log_likelihood = calculate_log_likelihood(counts_data, c, h)\n                \n                if current_log_likelihood > max_log_likelihood:\n                    max_log_likelihood = current_log_likelihood\n                    best_c = c\n                    best_h = h\n        \n        # Store results rounded to three decimal places\n        result = [round(best_c, 3), round(best_h, 3), round(max_log_likelihood, 3)]\n        results.append(result)\n\n    # Format the final output string exactly as required\n    output_parts = []\n    for res in results:\n        # Format each list of results: [c,h,l]\n        output_parts.append(f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\")\n    \n    # Join the formatted lists and enclose in brackets\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2813409"}]}