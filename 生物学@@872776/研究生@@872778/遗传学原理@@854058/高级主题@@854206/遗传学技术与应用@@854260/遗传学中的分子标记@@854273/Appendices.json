{"hands_on_practices": [{"introduction": "哈代-温伯格平衡（Hardy-Weinberg Equilibrium, HWE）是群体遗传学中的一个基本零假设模型。在分析任何群体遗传数据时，检验是否偏离HWE是至关重要的第一步，这不仅能揭示群体中可能存在的选择、非随机交配等生物学过程，还能帮助识别如无效等位基因等技术性问题。本练习将通过一个经典的卡方检验，让你亲手实践如何从观测的基因型数据出发，评估一个群体是否处于平衡状态。[@problem_id:2831149]", "problem": "在一个大小为 $N=200$ 的随机抽样群体中，对一个双等位基因的单核苷酸多态性 (SNP) 标记进行了基因分型。观察到的基因型计数为：$AA=92$，$Aa=96$，以及 $aa=12$。使用哈迪-温伯格原理作为零假设模型（随机交配、无选择、无迁移、无突变、大群体），从观测数据中推导出等位基因频率，计算在哈迪-温伯格平衡下的预期基因型计数，然后计算检验哈迪-温伯格平衡的卡方统计量。假设双等位基因标记的自由度为常规值，其中等位基因频率从样本中估计。将您的卡方统计量四舍五入至 $4$ 位有效数字。以纯数字形式表达您的最终答案，不带单位。用一句话评论，像无效等位基因这样的技术因素或像选择这样的生物学因素是否与观察到的任何偏差方向一致，但不要将此评论包含在您的最终数值答案中。", "solution": "该问题定义明确，并基于群体遗传学的基本原理。它要求应用哈迪-温伯格原理和卡方拟合优度检验。该问题是有效的，并将推导出一个解决方案。\n\n首先，我们必须验证所提供的数据。总样本量为 $N=200$。观察到的基因型计数为 $n_{AA}=92$、$n_{Aa}=96$ 和 $n_{aa}=12$。这些计数的总和必须等于总样本量：$92 + 96 + 12 = 200$。数据内部一致。\n\n第一步是从观察到的基因型计数中计算两个等位基因 $A$ 和 $a$ 的频率。设 $p$ 为等位基因 $A$ 的频率，$q$ 为等位基因 $a$ 的频率。样本中等位基因的总数为 $2N$，即 $2 \\times 200 = 400$。\n\n等位基因 $A$ 的频率，记为 $p$，计算如下：\n$$p = \\frac{2 \\times (\\text{count of } AA) + 1 \\times (\\text{count of } Aa)}{2N}$$\n代入观察到的计数：\n$$p = \\frac{2 \\times 92 + 96}{2 \\times 200} = \\frac{184 + 96}{400} = \\frac{280}{400} = 0.7$$\n\n等位基因 $a$ 的频率，记为 $q$，计算方法类似：\n$$q = \\frac{2 \\times (\\text{count of } aa) + 1 \\times (\\text{count of } Aa)}{2N}$$\n代入观察到的计数：\n$$q = \\frac{2 \\times 12 + 96}{2 \\times 200} = \\frac{24 + 96}{400} = \\frac{120}{400} = 0.3$$\n作为必要的检查，等位基因频率的总和必须为 1：$p + q = 0.7 + 0.3 = 1.0$。计算正确。\n\n接下来，在哈迪-温伯格平衡 (HWE) 的零假设下，预期的基因型频率由 $p^2$ (对于 $AA$)、$2pq$ (对于 $Aa$) 和 $q^2$ (对于 $aa$) 给出。我们使用估计的等位基因频率 ($p=0.7$ 和 $q=0.3$) 来计算大小为 $N=200$ 的样本的预期计数。\n\n基因型 $AA$ 的预期计数 $E_{AA}$ 是：\n$$E_{AA} = N \\times p^2 = 200 \\times (0.7)^2 = 200 \\times 0.49 = 98$$\n\n基因型 $Aa$ 的预期计数 $E_{Aa}$ 是：\n$$E_{Aa} = N \\times 2pq = 200 \\times 2 \\times 0.7 \\times 0.3 = 200 \\times 0.42 = 84$$\n\n基因型 $aa$ 的预期计数 $E_{aa}$ 是：\n$$E_{aa} = N \\times q^2 = 200 \\times (0.3)^2 = 200 \\times 0.09 = 18$$\n作为检查，预期计数的总和必须等于总样本量：$E_{AA} + E_{Aa} + E_{aa} = 98 + 84 + 18 = 200$。这是正确的。\n\n现在，我们计算卡方 ($\\chi^2$) 统计量，以检验观察到的 ($O$) 和预期的 ($E$) 计数之间的拟合优度。公式为：\n$$\\chi^2 = \\sum \\frac{(O - E)^2}{E}$$\n将此公式应用于我们的数据：\n$$\\chi^2 = \\frac{(O_{AA} - E_{AA})^2}{E_{AA}} + \\frac{(O_{Aa} - E_{Aa})^2}{E_{Aa}} + \\frac{(O_{aa} - E_{aa})^2}{E_{aa}}$$\n代入观察到的 ($O_{AA}=92$，$O_{Aa}=96$，$O_{aa}=12$) 和预期的 ($E_{AA}=98$，$E_{Aa}=84$，$E_{aa}=18$) 计数：\n$$\\chi^2 = \\frac{(92 - 98)^2}{98} + \\frac{(96 - 84)^2}{84} + \\frac{(12 - 18)^2}{18}$$\n$$\\chi^2 = \\frac{(-6)^2}{98} + \\frac{(12)^2}{84} + \\frac{(-6)^2}{18}$$\n$$\\chi^2 = \\frac{36}{98} + \\frac{144}{84} + \\frac{36}{18}$$\n进行除法运算：\n$$\\chi^2 \\approx 0.3673469... + 1.7142857... + 2.0$$\n$$\\chi^2 \\approx 4.0816326...$$\n问题要求结果四舍五入至 $4$ 位有效数字。\n$$\\chi^2 \\approx 4.082$$\n此检验的自由度 ($df$) 计算为基因型类别数减 1，再减去从数据中估计的独立等位基因频率的数量。对于一个双等位基因座，有 $3$ 个基因型类别。我们估计了一个独立参数 ($p$，因为 $q=1-p$)，因此自由度为 $df = 3 - 1 - 1 = 1$。\n\n最后，我们评论一下偏差。观察到的杂合子计数 ($96$) 大于预期值 ($84$)，而两个纯合子类别的观察计数 ($92$ 和 $12$) 均小于预期值 ($98$ 和 $18$)。观察到的杂合子过剩和纯合子不足与平衡选择（杂合子优势）等生物学因素一致，而与无效等位基因等技术性假象不一致，因为后者通常会导致表观的杂合子不足。", "answer": "$$\n\\boxed{4.082}\n$$", "id": "2831149"}, {"introduction": "在理解基因组结构时，确定基因在染色体上的相对位置和距离是核心任务之一。三点测交是遗传学中用于构建连锁图谱的经典方法，它巧妙地利用了重组事件的频率来推断基因顺序和基因间的距离。通过分析测交后代的基因型数据，本练习将引导你重现这一经典过程，从原始数据中推断出基因顺序，计算重组率，并进一步量化遗传干涉效应。[@problem_id:2831208]", "problem": "一个植物作图群体由位于同一条染色体上的三个共显性单核苷酸多态性（SNP）标记构建，分别表示为 $A$、$B$ 和 $C$。一个连锁相为 $A B C / a b c$ 的双杂合亲本与一个纯合隐性亲本 $a b c / a b c$ 进行测交。在三个 SNP 位点上，对 $N$ 个测交后代（每个对应于双杂合亲本产生的一个配子）的基因型进行了评分。总样本量为 $N = 2000$。观察到的单倍型计数如下：$A B C$: $670$；$a b c$: $660$；$A b c$: $102$；$a B C$: $108$；$A B c$: $210$；$a b C$: $220$；$A b C$: $15$；$a B c$: $15$。\n\n仅使用三点测交中连锁和重组的基本定义：一个区间的重组率等于该区间重组染色单体的比例；两个最常见的后代类型确定了非重组单倍型；两个最不常见的后代类型确定了双交换类型；并且，在没有干涉的情况下，双交换的期望频率等于两个区间重组率的乘积。根据第一性原理，推断基因顺序，然后计算干涉。仅报告干涉值，以一个小数表示。将您的答案四舍五入至四位有效数字。", "solution": "首先必须对问题陈述进行严格验证。\n\n步骤 1：提取已知条件。\n- 标记：三个共显性单核苷酸多态性（SNP）标记，$A$、$B$ 和 $C$。\n- 染色体位置：所有三个标记都在同一条染色体上。\n- 亲本基因型：一个连锁相为 $A B C / a b c$ 的双杂合亲本与一个纯合隐性亲本 $a b c / a b c$ 杂交。\n- 杂交类型：测交。\n- 样本量：后代总数，$N = 2000$。\n- 观察到的后代（单倍型）计数：\n  - $A B C$: $670$\n  - $a b c$: $660$\n  - $A b c$: $102$\n  - $a B C$: $108$\n  - $A B c$: $210$\n  - $a b C$: $220$\n  - $A b C$: $15$\n  - $a B c$: $15$\n- 要求方法：使用三点测交分析的第一性原理推断基因顺序并计算干涉。\n\n步骤 2：使用提取的已知条件进行验证。\n该问题具有科学依据，描述了一个标准的三点测交，这是经典遗传学中用于基因作图的基本程序。该问题提法明确；它提供了一个完整的数据集（$N = 670 + 660 + 102 + 108 + 210 + 220 + 15 + 15 = 2000$）和一个清晰、客观的任务。数据是一致且生物学上合理的。没有违反任何科学原理。问题设置不完整、不矛盾、不模糊。\n\n步骤 3：结论与行动。\n问题有效。将推导解答。\n\n按要求从第一性原理进行分析。这是一个三点测交，后代的表型直接揭示了杂合亲本产生的配子单倍型。\n\n首先，我们必须确定亲本（非重组，NCO）和双交换（DCO）配子类型。根据连锁原理，亲本类型最常见，双交换类型最不常见。\n- 亲本 (NCO) 类型：$A B C$（计数 $670$）和 $a b c$（计数 $660$）。它们的高频率证实了亲本的连锁相是 $A B C / a b c$。NCO 总计数 = $670 + 660 = 1330$。\n- 双交换 (DCO) 类型：$A b C$（计数 $15$）和 $a B c$（计数 $15$）。DCO 总计数 = $15 + 15 = 30$。\n\n其次，我们确定基因顺序。双交换事件会转换相对于非重组亲本排列的中间等位基因。我们将亲本单倍型与双交换单倍型进行比较。\n- 亲本单倍型：$A \\ B \\ C$\n- 双交换单倍型：$A \\ b \\ C$\n比较这两者，基因 $A$ 和 $C$ 的等位基因与亲本构型相同，而基因 $B$ 的等位基因则反转了。因此，中间的基因是 $B$。正确的基因顺序是 $A-B-C$。\n\n第三，我们计算由确定的基因顺序定义的两个区间的重组率（$RF$）：区间 1（$A-B$）和区间 2（$B-C$）。一个区间的重组率是该区间内所有单交换与所有双交换之和，再除以后代总数。\n\n剩下的四种类型是单交换（SCO）配子。\n- 区间 1（$A-B$）的单交换：这些是 $A$ 和 $B$ 之间发生交换，但 $B$ 和 $C$ 之间没有发生交换的后代。它们是 $A b c$（计数 $102$）和 $a B C$（计数 $108$）。SCO$_1$ 总计数 = $102 + 108 = 210$。\n- 区间 2（$B-C$）的单交换：这些是 $B$ 和 $C$ 之间发生交换，但 $A$ 和 $B$ 之间没有发生交换的后代。它们是 $A B c$（计数 $210$）和 $a b C$（计数 $220$）。SCO$_2$ 总计数 = $210 + 220 = 430$。\n\n现在，我们计算每个区间的重组率。\n- $RF_{A-B}$：该区间的重组后代数是 SCO$_1$ 和 DCO 计数的总和。\n$$RF_{A-B} = \\frac{(\\text{Count of } A b c + \\text{Count of } a B C) + (\\text{Count of } A b C + \\text{Count of } a B c)}{N}$$\n$$RF_{A-B} = \\frac{(102 + 108) + (15 + 15)}{2000} = \\frac{210 + 30}{2000} = \\frac{240}{2000} = 0.12$$\n\n- $RF_{B-C}$：该区间的重组后代数是 SCO$_2$ 和 DCO 计数的总和。\n$$RF_{B-C} = \\frac{(\\text{Count of } A B c + \\text{Count of } a b C) + (\\text{Count of } A b C + \\text{Count of } a B c)}{N}$$\n$$RF_{B-C} = \\frac{(210 + 220) + (15 + 15)}{2000} = \\frac{430 + 30}{2000} = \\frac{460}{2000} = 0.23$$\n\n第四，我们计算干涉（$I$）。干涉量化了一个区域的交换抑制相邻区域发生交换的程度。它由并发系数（$C$）计算得出，其中 $I = 1 - C$。\n\n并发系数（$C$）是观察到的双交换频率与预期的双交换频率之比。\n- 观察到的 DCO 频率：\n$$\\text{Observed DCO freq.} = \\frac{\\text{Total DCO count}}{N} = \\frac{30}{2000} = 0.015$$\n- 预期的 DCO 频率：这是两个相邻区间的各自重组率的乘积，假设交换事件是独立的。\n$$\\text{Expected DCO freq.} = RF_{A-B} \\times RF_{B-C} = 0.12 \\times 0.23 = 0.0276$$\n\n现在，我们计算并发系数 $C$。\n$$C = \\frac{\\text{Observed DCO freq.}}{\\text{Expected DCO freq.}} = \\frac{0.015}{0.0276}$$\n\n最后，我们计算干涉 $I$。\n$$I = 1 - C = 1 - \\frac{0.015}{0.0276} \\approx 1 - 0.54347826...$$\n$$I \\approx 0.456521739...$$\n问题要求答案四舍五入到四位有效数字。\n$$I \\approx 0.4565$$\n这个正干涉值表明，在 $A-B$ 区间发生的一次交换将同时在 $B-C$ 区间发生交换的概率降低到预期值的大约 $54.3\\%$。", "answer": "$$\\boxed{0.4565}$$", "id": "2831208"}, {"introduction": "真实的遗传数据往往并非完美，技术性假象（artifact）是分析中常见的挑战，其中无效等位基因（null allele）就是微卫星分型中一个典型的问题。如果忽略无效等位基因的存在，会直接导致错误的等位基因频率估计和哈代-温伯格偏离的误判。本练习将介绍一种处理此类“缺失数据”问题的强大统计方法——期望最大化（Expectation-Maximization, EM）算法，指导你如何建立一个包含无效等位基因的统计模型，并使用EM算法迭代求解出更准确的等位基因频率。[@problem_id:2831184]", "problem": "考虑一个用于微卫星基因分型的共显性位点，其中两个可见等位基因（表示为 $A$ 和 $B$）在一个随机交配的二倍体群体中分离，并且可能存在第三个不可观测的扩增失败（无效）等位基因，表示为 $N$。设种群等位基因频率分别为 $p_A$、$p_B$ 和 $\\nu$，满足约束条件 $p_A + p_B + \\nu = 1$ 以及 $p_A, p_B, \\nu \\ge 0$。假设哈迪-温伯格平衡（HWE）和个体独立。不可观测的真实基因型类别及其预期的HWE频率如下：\n- 频率为 $p_A^2$ 的 $AA$，\n- 频率为 $2 p_A p_B$ 的 $AB$，\n- 频率为 $p_B^2$ 的 $BB$，\n- 频率为 $2 p_A \\nu$ 的 $AN$，\n- 频率为 $2 p_B \\nu$ 的 $BN$，\n- 频率为 $\\nu^2$ 的 $NN$。\n\n在微卫星分析中，无效等位基因 $N$ 不会扩增。因此，观测模型为：真实的 $AA$ 和 $AN$ 都表现为表观纯合子 $AA$；真实的 $AB$ 表现为 $AB$；真实的 $BB$ 和 $BN$ 都表现为表观纯合子 $BB$；真实的 $NN$ 产生未扩增（缺失）的观测值。设表观 $AA$ 的观测计数为 $O_{AA}$， $AB$ 的为 $O_{AB}$，表观 $BB$ 的为 $O_{BB}$，缺失的为 $O_{\\varnothing}$，总数为 $n = O_{AA} + O_{AB} + O_{BB} + O_{\\varnothing}$。\n\n任务：\n1) 仅从上述HWE假设和观测模型出发，写出以潜在真实基因型计数以及参数 $p_A$、$p_B$ 和 $\\nu$ 表示的完全数据对数似然。然后，使用拉格朗日乘子强制约束 $p_A + p_B + \\nu = 1$，推导当潜在基因型计数被给定观测数据和当前参数值下的条件期望替代时，$p_A$、$p_B$ 和 $\\nu$ 的最大似然更新形式。\n2) 根据第一性原理，构建期望最大化（EM）算法，该算法交替执行：\n   - E步（期望步）：计算 $O_{AA}$ 在真实 $AA$ 和 $AN$ 之间的期望分配，以及 $O_{BB}$ 在真实 $BB$ 和 $BN$ 之间的期望分配，以及\n   - M步（最大化步）：根据期望的等位基因计数更新 $p_A$、$p_B$ 和 $\\nu$，\n直至收敛。清晰地陈述E步的分配公式和M步的更新公式。当参数向量变化的欧几里得范数低于一个小的容差时，可宣告收敛。\n3) 将此EM算法实现为一个程序，对下面的每个测试用例，计算最大似然估计值 $\\widehat{p}_A$、$\\widehat{p}_B$ 和 $\\widehat{\\nu}$，每个值四舍五入到 $6$ 位小数。不涉及物理单位。所有最终数值输出均以小数形式表示。\n\n测试集（每个测试用例是一个四元组 $(O_{AA}, O_{AB}, O_{BB}, O_{\\varnothing})$）：\n- 用例 $1$：$(300, 450, 247, 3)$。\n- 用例 $2$：$(40, 60, 40, 0)$。\n- 用例 $3$：$(225, 150, 105, 20)$。\n- 用例 $4$：$(8, 90, 900, 2)$。\n- 用例 $5$：$(4, 4, 2, 0)$。\n- 用例 $6$：$(0, 0, 0, 50)$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的类JSON格式的列表的列表，其中每个内部列表为对应测试用例的 $[\\widehat{p}_A, \\widehat{p}_B, \\widehat{\\nu}]$，每个值四舍五入到 $6$ 位小数。例如，一个包含两个用例的输出应如下所示：$[[0.500000,0.450000,0.050000],[0.300000,0.600000,0.100000]]$。\n- 该程序不得读取任何输入，也不得打印任何其他内容。", "solution": "所述问题具有科学依据，定义明确，客观且自成体系。它描述了群体遗传学中的一个标准情景，涉及在存在无效等位基因的情况下估计等位基因频率，这是期望最大化（EM）算法的一个经典应用。该问题是有效的，并将提供解决方案。\n\n目标是根据观测到的表型计数 $O_{AA}$、$O_{AB}$、$O_{BB}$ 和 $O_{\\varnothing}$，找到等位基因频率 $p_A$、$p_B$ 和无效等位基因频率 $\\nu$ 的最大似然估计（MLE）。这是一个带有缺失数据的统计推断问题，因为表观纯合子（$AA$ 和 $BB$）的真实基因型没有被直接观测到。EM算法是解决此问题的合适方法。\n\n推导和算法构建按要求分三个阶段进行。\n\n任务1：最大似然更新形式的推导\n设完全数据为未观测到的（潜在的）真实基因型计数：$N_{AA}$、$N_{AB}$、$N_{BB}$、$N_{AN}$、$N_{BN}$ 和 $N_{NN}$。总样本量为 $n = N_{AA} + N_{AB} + N_{BB} + N_{AN} + N_{BN} + N_{NN}$。\n在哈迪-温伯格平衡（HWE）的假设下，观测到一组特定真实基因型计数的概率服从多项分布。完全数据对数似然函数 $\\log L_c$ 可以用参数 $p_A, p_B, \\nu$ 表示为：\n$$ \\log L_c(p_A, p_B, \\nu) = C + N_{AA}\\log((p_A)^2) + N_{AB}\\log(2p_A p_B) + N_{BB}\\log((p_B)^2) + N_{AN}\\log(2p_A \\nu) + N_{BN}\\log(2p_B \\nu) + N_{NN}\\log(\\nu^2) $$\n其中 $C$ 是一个不依赖于参数的常数。\n通过根据参数重新排列各项，我们可以简化此表达式：\n$$ \\log L_c \\propto (2N_{AA} + N_{AB} + N_{AN})\\log(p_A) + (N_{AB} + 2N_{BB} + N_{BN})\\log(p_B) + (N_{AN} + N_{BN} + 2N_{NN})\\log(\\nu) $$\n括号中的项是样本中等位基因 $A$、$B$ 和 $N$ 的总计数。令其为 $C_A, C_B, C_N$：\n$C_A = 2N_{AA} + N_{AB} + N_{AN}$\n$C_B = N_{AB} + 2N_{BB} + N_{BN}$\n$C_N = N_{AN} + N_{BN} + 2N_{NN}$\n这些等位基因计数之和为 $C_A + C_B + C_N = 2n$。对数似然是这三个等位基因的多项分布的对数似然：\n$$ \\log L_c \\propto C_A\\log(p_A) + C_B\\log(p_B) + C_N\\log(\\nu) $$\n为了找到最大似然估计，我们必须在约束条件 $p_A + p_B + \\nu = 1$ 下最大化此函数。我们使用一个拉格朗日乘子 $\\lambda$。拉格朗日函数 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(p_A, p_B, \\nu, \\lambda) = C_A\\log(p_A) + C_B\\log(p_B) + C_N\\log(\\nu) - \\lambda(p_A + p_B + \\nu - 1) $$\n对 $p_A, p_B, \\nu$ 求偏导数并令其为零，得到：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial p_A} = \\frac{C_A}{p_A} - \\lambda = 0 \\implies p_A = \\frac{C_A}{\\lambda} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial p_B} = \\frac{C_B}{p_B} - \\lambda = 0 \\implies p_B = \\frac{C_B}{\\lambda} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\nu} = \\frac{C_N}{\\nu} - \\lambda = 0 \\implies \\nu = \\frac{C_N}{\\lambda} $$\n将这些相加并使用约束条件 $p_A + p_B + \\nu = 1$：\n$$ \\frac{C_A}{\\lambda} + \\frac{C_B}{\\lambda} + \\frac{C_N}{\\lambda} = 1 \\implies \\frac{C_A + C_B + C_N}{\\lambda} = 1 \\implies \\lambda = C_A + C_B + C_N = 2n $$\n因此，如果完全数据已知，最大似然估计（MLE）将是：\n$$ \\widehat{p}_A = \\frac{C_A}{2n}, \\quad \\widehat{p}_B = \\frac{C_B}{2n}, \\quad \\widehat{\\nu} = \\frac{C_N}{2n} $$\n在EM算法框架中，M步涉及最大化完全数据对数似然的期望。这等同于使用上述公式，但将潜在计数（$N_{AA}$、$N_{AN}$ 等）替换为给定观测数据和当前参数估计值下的条件期望。设 $\\theta^{(t)} = (p_A^{(t)}, p_B^{(t)}, \\nu^{(t)})$ 为第 $t$ 次迭代时的参数估计值。M步的更新公式为：\n$$ p_A^{(t+1)} = \\frac{E[C_A | O, \\theta^{(t)}]}{2n}, \\quad p_B^{(t+1)} = \\frac{E[C_B | O, \\theta^{(t)}]}{2n}, \\quad \\nu^{(t+1)} = \\frac{E[C_N | O, \\theta^{(t)}]}{2n} $$\n其中 $O = (O_{AA}, O_{AB}, O_{BB}, O_{\\varnothing})$ 代表观测计数。\n\n任务2：期望最大化（EM）算法的构建\nEM算法在期望（E）步和最大化（M）步之间交替进行。对于此问题，我们需要形式化潜变量的期望和参数的更新。\n\n初始化：从参数的初始猜测值 $\\theta^{(0)} = (p_A^{(0)}, p_B^{(0)}, \\nu^{(0)})$ 开始。一个合理的方法是根据观测到的表型估计频率，初步忽略模糊性：$p_A^{(0)} = (2O_{AA} + O_{AB}) / (2n')$，$p_B^{(0)} = (O_{AB} + 2O_{BB}) / (2n')$，其中 $n' = O_{AA} + O_{AB} + O_{BB}$。给 $\\nu^{(0)}$ 赋一个小的正值 $\\epsilon$，并重新缩放 $p_A^{(0)}, p_B^{(0)}$。一个更简单的方法是假设所有计数共同构成总共 $2n$ 个等位基因：$p_A^{(0)} \\propto 2O_{AA}+O_{AB}$，$p_B^{(0)} \\propto O_{AB}+2O_{BB}$，$\\nu^{(0)} \\propto 2O_{\\varnothing}$，然后归一化使其和为1。\n\nE步：在第 $t$ 次迭代时，我们计算给定观测数据 $O$ 和当前参数估计值 $\\theta^{(t)}$ 下，真实基因型计数的条件期望。\n计数 $O_{AB}$ 和 $O_{\\varnothing}$ 是明确的：\n$E[N_{AB} | O, \\theta^{(t)}] = O_{AB}$\n$E[N_{NN} | O, \\theta^{(t)}] = O_{\\varnothing}$\n对于模糊的计数 $O_{AA}$，我们将其划分为真实的 $AA$ 和真实的 $AN$ 基因型。一个个体具有表观 $AA$ 表型的概率是 $P(\\text{观测 } AA) = P(\\text{真实 } AA) + P(\\text{真实 } AN) = (p_A^{(t)})^2 + 2p_A^{(t)}\\nu^{(t)}$。\n根据贝叶斯法则，给定一个表观 $AA$ 观测值，其为某一真实基因型的条件概率是：\n$$ P(\\text{真实 } AA | \\text{观测 } AA) = \\frac{P(\\text{真实 } AA)}{P(\\text{观测 } AA)} = \\frac{(p_A^{(t)})^2}{(p_A^{(t)})^2 + 2p_A^{(t)}\\nu^{(t)}} = \\frac{p_A^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} $$\n$$ P(\\text{真实 } AN | \\text{观测 } AA) = \\frac{P(\\text{真实 } AN)}{P(\\text{观测 } AA)} = \\frac{2p_A^{(t)}\\nu^{(t)}}{(p_A^{(t)})^2 + 2p_A^{(t)}\\nu^{(t)}} = \\frac{2\\nu^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} $$\n那么，期望计数为：\n$E[N_{AA} | O, \\theta^{(t)}] = O_{AA} \\left( \\frac{p_A^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} \\right)$\n$E[N_{AN} | O, \\theta^{(t)}] = O_{AA} \\left( \\frac{2\\nu^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} \\right)$\n对于模糊的计数 $O_{BB}$ 也类似：\n$E[N_{BB} | O, \\theta^{(t)}] = O_{BB} \\left( \\frac{p_B^{(t)}}{p_B^{(t)} + 2\\nu^{(t)}} \\right)$\n$E[N_{BN} | O, \\theta^{(t)}] = O_{BB} \\left( \\frac{2\\nu^{(t)}}{p_B^{(t)} + 2\\nu^{(t)}} \\right)$\n这些期望是在分母非零的假设下计算的。如果分母为零，为了使似然为有限值，相应的观测计数也必须为零，从而使得期望计数为零。\n\nM步：我们使用E步得到的期望基因型计数来计算期望的等位基因计数 $E[C_A]$、$E[C_B]$ 和 $E[C_N]$。\n$E[C_A] = 2 E[N_{AA}] + E[N_{AB}] + E[N_{AN}]$\n$E[C_B] = E[N_{AB}] + 2 E[N_{BB}] + E[N_{BN}]$\n$E[C_N] = E[N_{AN}] + E[N_{BN}] + 2 E[N_{NN}]$\n使用任务1中推导的等位基因计数公式更新参数估计值：\n$$ p_A^{(t+1)} = \\frac{E[C_A]}{2n} $$\n$$ p_B^{(t+1)} = \\frac{E[C_B]}{2n} $$\n$$ \\nu^{(t+1)} = \\frac{E[C_N]}{2n} $$\n这些新的估计值保证其和为1，构成了 $\\theta^{(t+1)}$。\n\n收敛：E步和M步被迭代执行，直到参数估计值收敛。当参数向量的变化小于指定的容差 $\\epsilon$ 时，宣告收敛。该条件通常基于欧几里得范数：$\\sqrt{(p_A^{(t+1)} - p_A^{(t)})^2 + (p_B^{(t+1)} - p_B^{(t)})^2 + (\\nu^{(t+1)} - \\nu^{(t)})^2}  \\epsilon$。\n\n任务3：实现\n上述EM算法用Python实现。该实现对每个测试用例取四个观测计数，初始化参数，并迭代E步和M步直到满足收敛准则。然后报告最终的估计参数 $\\widehat{p}_A, \\widehat{p}_B, \\widehat{\\nu}$。", "answer": "```python\nimport numpy as np\n\ndef em_for_null_allele(O_AA, O_AB, O_BB, O_null, tol=1e-9, max_iter=5000):\n    \"\"\"\n    Computes MLE for allele frequencies p_A, p_B, and null nu using the EM algorithm.\n\n    Args:\n        O_AA (int): Observed count of apparent AA homozygotes.\n        O_AB (int): Observed count of AB heterozygotes.\n        O_BB (int): Observed count of apparent BB homozygotes.\n        O_null (int): Observed count of null/non-amplified samples.\n        tol (float): Convergence tolerance.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        list: A list containing the estimated frequencies [p_A, p_B, nu].\n    \"\"\"\n    n = O_AA + O_AB + O_BB + O_null\n    if n == 0:\n        return [0.0, 0.0, 0.0]\n\n    # Initial parameter estimates\n    # Based on simple allele counting from observed phenotypes, then normalized.\n    p_A_est = (2 * O_AA + O_AB)\n    p_B_est = (O_AB + 2 * O_BB)\n    nu_est = (2 * O_null)\n    total_count = p_A_est + p_B_est + nu_est\n\n    if total_count == 0:\n        # If all counts are zero, distribute probability uniformly.\n        p_A, p_B, nu = 1/3, 1/3, 1/3\n    else:\n        p_A = p_A_est / total_count\n        p_B = p_B_est / total_count\n        nu = nu_est / total_count\n\n    for i in range(max_iter):\n        p_A_old, p_B_old, nu_old = p_A, p_B, nu\n\n        # --- E-step: Compute expected counts of latent true genotypes ---\n        \n        # Denominators for conditional probabilities\n        # (p_A^2 + 2*p_A*nu) = p_A * (p_A + 2*nu)\n        # P(true AA | obs AA) = p_A / (p_A + 2*nu)\n        # P(true AN | obs AA) = 2*nu / (p_A + 2*nu)\n        den_A = p_A_old + 2 * nu_old\n        den_B = p_B_old + 2 * nu_old\n        \n        # Expected counts of true genotypes\n        # Handling the case where denominator is 0 (e.g. p_A=0 and nu=0).\n        # In this case, O_AA must also be 0, so the product is 0.\n        E_N_AA = (O_AA * p_A_old / den_A) if den_A > 0 else 0.0\n        E_N_AN = (O_AA * 2 * nu_old / den_A) if den_A > 0 else 0.0\n        \n        E_N_BB = (O_BB * p_B_old / den_B) if den_B > 0 else 0.0\n        E_N_BN = (O_BB * 2 * nu_old / den_B) if den_B > 0 else 0.0\n        \n        # Unambiguous counts\n        E_N_AB = float(O_AB)\n        E_N_NN = float(O_null)\n\n        # --- M-step: Update parameter estimates based on expected counts ---\n        \n        # Expected allele counts\n        E_C_A = 2 * E_N_AA + E_N_AB + E_N_AN\n        E_C_B = E_N_AB + 2 * E_N_BB + E_N_BN\n        E_C_N = E_N_AN + E_N_BN + 2 * E_N_NN\n        \n        total_alleles = 2.0 * n\n        \n        p_A = E_C_A / total_alleles\n        p_B = E_C_B / total_alleles\n        nu = E_C_N / total_alleles\n\n        # Check for convergence\n        change = np.sqrt((p_A - p_A_old)**2 + (p_B - p_B_old)**2 + (nu - nu_old)**2)\n        if change  tol:\n            break\n            \n    return [p_A, p_B, nu]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (300, 450, 247, 3),    # Case 1\n        (40, 60, 40, 0),      # Case 2\n        (225, 150, 105, 20),  # Case 3\n        (8, 90, 900, 2),      # Case 4\n        (4, 4, 2, 0),         # Case 5\n        (0, 0, 0, 50)         # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        O_AA, O_AB, O_BB, O_null = case\n        estimates = em_for_null_allele(O_AA, O_AB, O_BB, O_null)\n        results.append(estimates)\n\n    # Format the final output string as specified.\n    output_str = \",\".join(\n        [f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results]\n    )\n    \n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2831184"}]}