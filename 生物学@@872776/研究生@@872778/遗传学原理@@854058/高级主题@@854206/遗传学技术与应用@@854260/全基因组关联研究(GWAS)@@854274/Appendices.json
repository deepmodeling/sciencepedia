{"hands_on_practices": [{"introduction": "全基因组关联研究（GWAS）同时检验数百万个假设，这带来了巨大的统计学挑战。本练习将介绍多重检验问题，并让您应用 Bonferroni 校正这一控制假阳性的基本技术。理解这一计算是正确解读曼哈顿图的第一步，也是领会为何全基因组显著性标准如此严苛的关键 ([@problem_id:1494362])。", "problem": "一个遗传学家团队正在进行一项全基因组关联研究（GWAS），以识别与一种新发现的复杂疾病相关的遗传标记。GWAS涉及扫描许多个体的基因组，以确定是否有任何特定的遗传变异在患有该疾病的人群中比在对照组中更常见。本研究中分析的遗传变异是单核苷酸多态性（SNPs）。\n\n在这项具体研究中，研究人员正在同时测试 $m = 1,000,000$ 个独立的SNPs，以寻找它们与该疾病的统计关联。通常，对于单个统计检验，显著性的p值阈值（alpha水平）设定为 $\\alpha = 0.05$。然而，进行如此大量的检验会显著增加纯粹由偶然性导致至少一个“假阳性”结果（I型错误）的概率。\n\n为了应对这个多重检验问题，研究团队决定控制总体错误率（FWER），其定义为在所有进行的检验中犯下一次或多次I型错误的概率。他们的目标是将FWER保持在0.05或以下。为实现这一目标，他们将对其显著性阈值应用Bonferroni校正。\n\n给定待检验的独立SNPs数量和期望的FWER，计算单个SNP必须满足的、经过Bonferroni校正的新的p值阈值，才能被认为是统计显著的。请用科学记数法表示您的答案。", "solution": "根据Bonferroni程序，总体错误率满足Bonferroni不等式：\n$$\n\\text{FWER} \\leq \\sum_{i=1}^{m} \\alpha_{i}.\n$$\n如果 $m$ 个检验中的每一个都以相同的单次检验显著性水平 $\\alpha^{*}$ 进行，那么\n$$\n\\text{FWER} \\leq m \\alpha^{*}.\n$$\n为了将FWER控制在期望的水平 $\\alpha$，选择 $\\alpha^{*}$ 使得\n$$\nm \\alpha^{*} \\leq \\alpha \\quad \\Rightarrow \\quad \\alpha^{*} = \\frac{\\alpha}{m}.\n$$\n当 $\\alpha = 0.05$ 且 $m = 1{,}000{,}000 = 10^{6}$ 时，我们将 $0.05 = 5 \\times 10^{-2}$ 并计算\n$$\n\\alpha^{*} = \\frac{5 \\times 10^{-2}}{10^{6}} = 5 \\times 10^{-2-6} = 5 \\times 10^{-8}.\n$$\n因此，经过Bonferroni校正的p值阈值是 $5 \\times 10^{-8}$。", "answer": "$$\\boxed{5 \\times 10^{-8}}$$", "id": "1494362"}, {"introduction": "除了统计学调整，GWAS 的有效性还取决于严谨的实验设计。这个思想实验呈现了一个因实验设计缺陷而非真实生物学原理，而产生数千个看似显著结果的场景。通过诊断这种大规模混杂效应的来源，您将锻炼识别和预防“批次效应”所必需的批判性思维能力，这是高通量基因组学中最常见和危险的陷阱之一 ([@problem_id:1494331])。", "problem": "一个大型研究联盟正在进行一项全基因组关联研究（GWAS），以识别与“空气-代谢综合征”（Aero-Metabolic Syndrome, AMS）相关的遗传变异，AMS是一种复杂的呼吸系统疾病。该研究设计包括从一个专业呼吸科诊所网络招募的`10,000`名病例，以及从一个普通人群健康登记库中选择的`10,000`名对照。为了有效管理大样本量，基因分型过程被分开了。所有`10,000`名病例的DNA样本在一个中心实验室使用“BioArray v2.0”平台进行处理和基因分型，检测了数百万个单核苷酸多态性（SNPs）。与此同时，所有`10,000`名对照的DNA样本在另一个设施使用“GenoChip v3.5”平台进行处理和基因分型。\n\n在合并了两个平台的数据并进行标准质量控制后，对每个SNP进行了统计关联检验。分析揭示了一个惊人的结果：遍布每条染色体的数以万计的SNP显示出与AMS有统计学显著的关联，这远远超出了复杂疾病GWAS的典型发现。\n\n下列哪个选项为这种全基因组范围内显著关联过多的现象提供了最合理的解释？\n\nA. 群体分层：病例组和对照组来自具有系统性不同遗传背景的群体，这些与遗传背景相关的等位基因频率差异被误解为疾病关联。\n\nB. 多基因结构：AMS是一种高度多基因的疾病，其遗传风险确实由遍布整个基因组的数以万计的常见变异的累积微小效应决定。\n\nC. 选择偏倚：从专业诊所招募病例导致队列中患者病情更严重，富集了大量在普通人群对照中未发现的罕见、高影响力的变异。\n\nD. 系统性基因分型偏倚：两种不同的基因分型平台在等位基因测量上存在微小、一致且平台特异性的不准确性，由于这些不准确性与病例-对照标签完全相关，从而产生了广泛的假阳性信号。\n\nE. 隐性亲缘关系：病例组在不知情的情况下包含了大量近亲个体，这违反了样本独立性的统计假设，并夸大了家族内部共享位点的关联信号。", "solution": "我们将每个SNP的关联检验形式化为等位基因卡方检验或病例状态对基因型的逻辑回归。设 $Y \\in \\{0,1\\}$ 表示病例状态，$G \\in \\{0,1,2\\}$ 表示编码后的基因型，并对每个SNP考虑逻辑模型 $\\ln\\left(\\frac{\\Pr(Y=1 \\mid G)}{\\Pr(Y=0 \\mid G)}\\right) = \\alpha + \\beta_{G} G$ 中的原假设 $H_{0}: \\beta_{G} = 0$。在正确的模型设定且无混杂因素的情况下，得分或沃尔德检验统计量在 $H_{0}$ 下服从渐近$\\chi^{2}_{1}$分布，因此在原假设下，除了复杂疾病中少数几个真实的关联外，全基因组的$p$值应近似服从均匀分布。\n\n观察到的模式是全基因组范围内显著关联过多，遍布每条染色体，有数万个SNP达到显著性水平。这种普遍的膨胀表明存在一个系统性的、影响绝大多数SNP的、对原假设的偏离。我们通过将其与检验行为联系起来，来审视每个选项。\n\n选项B（多基因结构）：在一个高度多基因的性状中，许多变异具有微小的真实效应。在一个严格的全基因组阈值 $\\alpha_{GW}$（例如 $\\alpha_{GW} \\approx 5 \\times 10^{-8}$）下检测到一个SNP的功效取决于关联检验的非中心参数 $\\Lambda$。对于一个加性检验，一个标准的近似给出 $\\Lambda \\approx N_{\\text{eff}} \\cdot 2 p (1 - p) \\cdot (\\ln \\theta)^{2}$，其中 $p$ 是次要等位基因频率，$\\theta$ 是每个等位基因的比值比，$N_{\\text{eff}}$ 是病例和对照计数的有效样本量函数。对于具有较小 $\\ln \\theta$ 的现实复杂性状，即使有大的 $N_{\\text{eff}}$，在 $\\alpha_{GW}$ 下的功效也有限。因此，仅凭多基因性并不能在这种样本量下产生数以万计的全基因组显著命中；它会产生一个可通过LD得分回归或多基因评分等方法检测到的多基因信号，而不是普遍的单SNP显著性。\n\n选项C（偏向严重性的选择偏倚）：招募更严重的病例可能会富集罕见的、高影响力的变异。基因芯片主要针对常见变异；罕见的、效应严重的等位基因通常标记得不好。此外，这种富集不会在整个基因组的常见SNP上造成一致的等位基因频率差异；它不会在常见变异上产生广泛的假阳性。\n\n选项E（隐性亲缘关系）：亲缘关系违反了独立性假设，如果未建模，会影响方差估计并夸大检验统计量。然而，这种膨胀通常取决于共享模式，并且并非在所有SNP上都一致；在实践中，它会产生一个适度的、全基因组范围的膨胀因子和有时出现的局部信号，而不是遍布所有染色体的数万个显著关联。此外，亲缘关系会降低有效样本量，这通常会减少而不是大规模增加使用正确标准误后的全基因组显著命中数。\n\n选项A（群体分层）：病例和对照之间系统性的遗传背景差异会因人口历史而非疾病，在全基因组范围内引起等位基因频率差异，从而夸大关联统计量。如果不进行校正，这很可能造成广泛的显著性。然而，标准的GWAS流程包括对遗传背景主成分的校正，这通常能减轻大部分的分层效应。虽然A可以解释广泛的膨胀，但本研究设计提供了一个更直接、更强的混杂来源。\n\n选项D（来自不同平台的系统性基因分型偏倚）：在这里，基因分型平台与表型完全混杂：所有病例使用BioArray v2.0，所有对照使用GenoChip v3.5。设 $B \\in \\{0,1\\}$ 表示平台，其中病例为$B=1$，对照为$B=0$。设真实的加性基因型为$G$，但测量到的基因型为 $\\tilde{G} = G + \\epsilon_{B}$，其中由于差异性检出、差异性缺失或探针化学性质，导致 $E[\\epsilon_{1}] \\neq E[\\epsilon_{0}]$ 或误差分布因平台而异。病例和对照之间测量到的平均基因型差异的期望值为\n$$\nE[\\tilde{G} \\mid Y=1] - E[\\tilde{G} \\mid Y=0] = \\underbrace{E[G \\mid Y=1] - E[G \\mid Y=0]}_{\\Delta \\text{ (真实效应)}} + \\underbrace{E[\\epsilon_{1}] - E[\\epsilon_{0}]}_{\\delta \\text{ (平台偏倚)}}.\n$$\n在大多数SNP的原假设下，$\\Delta = 0$，但只要存在平台特异性的检出偏倚，$\\delta \\neq 0$。因为$B$与$Y$完全共线，所以无法在关联模型中对$B$进行校正；遗漏变量偏倚会将平台引起的差异归因于基因型系数，从而产生伪关联。等位基因卡方检验的检验统计量近似为\n$$\nT \\approx \\frac{\\left(\\hat{p}_{\\text{case}} - \\hat{p}_{\\text{control}}\\right)^{2}}{\\hat{V}},\n$$\n其中 $\\hat{p}_{\\text{case}}$ 和 $\\hat{p}_{\\text{control}}$ 是观察到的等位基因频率，$\\hat{V}$ 是原假设下的估计方差。如果由于平台偏倚，许多SNP的 $\\hat{p}_{\\text{case}} - \\hat{p}_{\\text{control}} \\approx \\delta$，那么$T$将在全基因组范围内被夸大。与减弱关联的随机非差异性测量误差不同，这是一种与结果状态相关的差异性错分，它会同时在许多SNP上使结果偏离原假设，这与观察到的遍布所有染色体的数万个显著命中的模式完全匹配。\n\n鉴于所有病例和对照都在不同设施使用不同平台进行基因分型的具体设计细节，与病例-对照状态完全相关的系统性平台特异性基因分型偏倚是解释全基因组显著关联过多的最合理和最直接的原因。\n\n因此，正确选项是D。", "answer": "$$\\boxed{D}$$", "id": "1494331"}, {"introduction": "GWAS 的一个主要目标是实现遗传预测。这个高级练习将指导您完成一个完整的模拟流程，以构建和评估多基因风险评分（PRS），这是一种总结个体对某一性状的遗传易感性的强大工具。通过模拟数据、进行模拟 GWAS，然后构建 PRS，您将获得整个工作流程的实践经验，并探索 SNP 纳入阈值的选择如何影响预测准确性 ([@problem_id:2394707])。", "problem": "您的任务是在一个模拟的全基因组关联研究 (GWAS) 环境中构建一个多基因风险评分 (PRS)，并评估其作为单核苷酸多态性 (SNP) 纳入阈值的函数的预测准确性。目标是为几种参数配置定义、计算并报告预测相关性的平方。\n\n定义和设置：\n\n- 全基因组关联研究 (GWAS) 检查遗传变异与性状之间的关联。考虑 $m$ 个单核苷酸多态性 (SNP)，每个都有一个次要等位基因频率 (MAF)。对于每个 SNP $j \\in \\{1,\\ldots,m\\}$，个体的基因型被编码为次要等位基因的计数，取值为 $\\{0,1,2\\}$。\n- 对于每个 SNP $j$，其 MAF $p_j$ 从区间 $[0.05, 0.5]$ 上的连续均匀分布中独立抽取。在 Hardy–Weinberg 平衡的条件下，将每个基因型条目模拟为来自 $\\mathrm{Binomial}(2, p_j)$ 的独立抽样。\n- 将样本分为一个大小为 $n_{\\text{train}}$ 的训练队列和一个大小为 $n_{\\text{test}}$ 的测试队列。设 $\\mathbf{G}_{\\text{train}} \\in \\mathbb{R}^{n_{\\text{train}} \\times m}$ 和 $\\mathbf{G}_{\\text{test}} \\in \\mathbb{R}^{n_{\\text{test}} \\times m}$ 为相应的基因型矩阵。\n- 使用训练队列的统计数据对 SNP 列进行标准化：对于每个 SNP $j$，计算 $\\mathbf{G}_{\\text{train}}$ 中第 $j$ 列的训练均值 $\\mu_j$ 和标准差 $\\sigma_j$。通过以下方式定义标准化矩阵 $\\mathbf{X}_{\\text{train}}$ 和 $\\mathbf{X}_{\\text{test}}$：\n  $$X_{\\text{train}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j}  \\text{若 } \\sigma_j  0,\\\\\n  0  \\text{若 } \\sigma_j = 0,\n  \\end{cases}\n  \\qquad\n  X_{\\text{test}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}  \\text{若 } \\sigma_j  0,\\\\\n  0  \\text{若 } \\sigma_j = 0.\n  \\end{cases}$$\n  如果 $\\sigma_j = 0$，则在两个队列中都将该标准化列视为恒为 $0$。\n- 从 $\\{1,\\ldots,m\\}$ 中无放回地均匀选择 $k$ 个因果 SNP 索引；定义真实效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$，使得对于非因果的 $j$，$\\beta^{\\star}_j = 0$，且原始因果效应独立地从 $\\mathcal{N}(0,1)$ 中抽取。\n- 设窄义遗传力为 $h^2 \\in [0,1]$。缩放原始效应向量以使训练集中的遗传方差等于 $h^2$，方法如下。计算训练集中的遗传成分 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$，其方差为 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$，并设置\n  $$\\boldsymbol{\\beta}^{\\star} = \\begin{cases}\n  \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\dfrac{h^2}{v_g}}  \\text{若 } v_g  0,\\\\\n  \\mathbf{0}  \\text{若 } v_g = 0.\n  \\end{cases}$$\n  定义环境噪声方差为 $\\sigma_e^2 = 1 - h^2$。\n- 在两个队列中生成表型：\n  $$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}),$$\n  $$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}).$$\n- 通过拟合一个带截距的线性模型，在训练队列中对每个 SNP $j$ 进行单变量关联分析，并设 $p_j$ 为原假设“SNP $j$ 的斜率为 $0$”的双侧p值。等价地，如果 $r_j$ 表示 $\\mathbf{X}_{\\text{train}}$ 的第 $j$ 列与 $\\mathbf{y}_{\\text{train}}$ 之间的 Pearson 相关性，自由度为 $\\nu = n_{\\text{train}} - 2$，定义 t-统计量\n  $$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu},$$\n  和双侧p值\n  $$p_j = 2 \\, \\mathbb{P}\\left(T_{\\nu} \\ge |t_j|\\right),$$\n  其中 $T_{\\nu}$ 是一个具有 $\\nu$ 个自由度的 Student t分布随机变量。如果 SNP $j$ 在训练集中的方差为零或 $\\mathbf{y}_{\\text{train}}$ 的方差为零，则设置 $p_j = 1$。\n- 对于给定的阈值 $p_T \\in (0,1]$，定义纳入的 SNP 集合 $S(p_T) = \\{j \\in \\{1,\\ldots,m\\} \\mid p_j \\le p_T\\}$。设 $\\hat{\\beta}_j$ 是在训练队列中为 SNP $j$ 估计的单变量普通最小二乘斜率（带截距）。定义阈值为 $p_T$ 时的测试集 PRS 为\n  $$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j].$$\n  如果 $S(p_T)$ 为空，则定义 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 为零向量。\n- 定义预测准确性为测试队列上的决定系数，\n  $$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2,$$\n  其中 $\\mathrm{Corr}$ 表示 Pearson 相关性。如果 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 或 $\\mathbf{y}_{\\text{test}}$ 在测试队列中的方差为零，则设置 $R^2(p_T) = 0$。\n\n任务：\n\n- 对于下面测试套件中的每个参数集，使用提供的随机种子执行上述模拟和分析。对于每个指定的阈值列表，按给定顺序计算每个 $p_T$ 的 $R^2(p_T)$。\n- 报告每个 $R^2(p_T)$ 值，四舍五入到 $6$ 位小数。\n\n测试套件：\n\n- 情况A：seed $= 42$, $n_{\\text{train}} = 1500$, $n_{\\text{test}} = 1000$, $m = 3000$, $k = 150$, $h^2 = 0.5$, 阈值 $= \\left[10^{-8}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 5 \\times 10^{-1}, 1\\right]$。\n- 情况B：seed $= 7$, $n_{\\text{train}} = 300$, $n_{\\text{test}} = 300$, $m = 1500$, $k = 50$, $h^2 = 0.5$, 阈值 $= \\left[10^{-20}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 情况C：seed $= 2023$, $n_{\\text{train}} = 800$, $n_{\\text{test}} = 800$, $m = 2000$, $k = 0$, $h^2 = 0.0$, 阈值 $= \\left[10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 情况D：seed $= 99$, $n_{\\text{train}} = 1200$, $n_{\\text{test}} = 800$, $m = 2500$, $k = 100$, $h^2 = 0.8$, 阈值 $= \\left[10^{-8}, 10^{-6}, 10^{-4}, 10^{-2}, 1\\right]$。\n\n边缘情况约定：\n\n- 如果任何 SNP 列在训练队列中的方差为零，则在两个队列中都将其标准化值设为零，其估计效应 $\\hat{\\beta}_j$ 设为 $0$，其 $p_j$ 设为 $1$。\n- 如果训练表型方差为零，则将所有 $\\hat{\\beta}_j$ 设为 $0$，所有 $p_j$ 设为 $1$。\n- 如果测试 PRS 或测试表型的方差为零，则对于该阈值，将 $R^2(p_T)$ 设为 $0$。\n\n最终输出规格：\n\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，不含空格，格式如下：\n  - 对于每种情况，按给定顺序输出其阈值对应的列表 $\\left[R^2(p_{T,1}), R^2(p_{T,2}), \\ldots \\right]$，每个条目四舍五入到 $6$ 位小数。\n  - 将四种情况按 A、B、C、D 的顺序汇总成一个单一列表，形成一个嵌套列表。例如：$\\left[[r_{A,1},r_{A,2}], [r_{B,1},r_{B,2}], [r_{C,1},r_{C,2}], [r_{D,1},r_{D,2}]\\right]$。", "solution": "所呈现的问题是一个全面且有效的统计遗传学模拟研究，具体涉及全基因组关联研究 (GWAS) 和多基因风险评分 (PRS)。任务是实现指定的模拟流程，该流程在科学上基于复杂性状的标准多基因模型，并评估所得 PRS 的预测准确性。所有参数和程序都定义明确，使得问题客观且在算法上易于处理。我将首先详细解释该方法，然后进行实现。\n\n整个过程可以分解为几个逻辑阶段：数据模拟、关联分析、PRS 构建和评估。\n\n首先，我们为两个不同的队列模拟遗传和表型数据：一个大小为 $n_{\\text{train}}$ 的训练队列和一个大小为 $n_{\\text{test}}$ 的测试队列。我们考虑一个包含 $m$ 个单核苷酸多态性 (SNP) 的基因组。对于每个 SNP $j$，其次要等位基因频率 (MAF)，表示为 $p_j$，从均匀分布 $\\mathrm{Uniform}(0.05, 0.5)$ 中抽取。在 Hardy–Weinberg 平衡的假设下，每个个体在 SNP $j$ 处的基因型（即次要等位基因的计数）是从二项分布 $\\mathrm{Binomial}(2, p_j)$ 中进行的独立随机抽样。这个过程生成了原始基因型矩阵 $\\mathbf{G}_{\\text{train}}$ 和 $\\mathbf{G}_{\\text{test}}$。\n\n原始基因型计数通常不直接用于分析，而是进行标准化处理。对于每个 SNP $j$，我们仅使用训练数据计算其均值 $\\mu_j$ 和标准差 $\\sigma_j$。然后，这些统计数据用于标准化两个队列的基因型矩阵：\n$$X_{\\text{train}}[i,j] = \\frac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j} \\quad \\text{和} \\quad X_{\\text{test}}[i,j] = \\frac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}$$\n一个关键的边缘情况是当一个 SNP 在训练队列中的方差为零时 ($\\sigma_j = 0$)。在这种情况下，该 SNP 不提供信息，其标准化值在两个队列中都设置为 $0$。\n\n接下来，我们通过为性状定义一个遗传结构来建立我们模拟的基准真相。我们从 $m$ 个 SNP 中随机选择 $k$ 个作为“因果”SNP。真实遗传效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$ 仅在这些因果 SNP 处有非零项。这 $k$ 个 SNP 的初始原始效应是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的。然后对这些原始效应 $\\boldsymbol{\\beta}_{\\text{raw}}$ 进行缩放，以满足指定的窄义遗传力 $h^2$。遗传力代表了可归因于遗传方差的表型方差比例。我们计算训练集中的遗传成分为 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$ 及其方差 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$。最终的、经过缩放的效应向量为：\n$$\\boldsymbol{\\beta}^{\\star} = \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\frac{h^2}{v_g}}$$\n这种缩放确保了训练数据中真实遗传成分的方差 $\\mathrm{Var}(\\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star})$ 恰好为 $h^2$。如果 $v_g=0$，则 $\\boldsymbol{\\beta}^{\\star}$ 是零向量。总表型方差被归一化为 $1$，因此环境噪声的方差为 $\\sigma_e^2 = 1 - h^2$。然后使用线性模型为两个队列生成表型：\n$$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\text{其中} \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n$$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\text{其中} \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n\n有了模拟的训练数据 $(\\mathbf{X}_{\\text{train}}, \\mathbf{y}_{\\text{train}})$，我们进行 GWAS。对于每个 SNP $j$，我们检验其与表型无关联的原假设。这是通过拟合一个单变量线性模型来完成的。关联强度由一个 t-统计量来量化。设 $r_j$ 为第 $j$ 个 SNP 向量 $\\mathbf{X}_{\\text{train}}[:,j]$ 与表型向量 $\\mathbf{y}_{\\text{train}}$ 之间的 Pearson 相关性。t-统计量为：\n$$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu}$$\n其中 $\\nu = n_{\\text{train}} - 2$ 是自由度。然后从 Student t-分布计算双侧 p值 $p_j$：$p_j = 2 \\, \\mathbb{P}(T_{\\nu} \\ge |t_j|)$，其中 $T_{\\nu}$ 是一个服从自由度为 $\\nu$ 的 t-分布的随机变量。同时，我们为每个 SNP 估计单变量普通最小二乘 (OLS) 效应大小 $\\hat{\\beta}_j$。对于一个标准化的预测变量，这个斜率可以被高效地计算出来。\n\n下一步是为测试集构建 PRS。基于一个指定的 p值阈值 $p_T$，我们构建一个包含的 SNP 集合 $S(p_T) = \\{j \\mid p_j \\le p_T\\}$。PRS 是测试队列中标准化基因型的加权和，权重是来自训练 GWAS 的估计效应大小 $\\hat{\\beta}_j$：\n$$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j]$$\n如果没有 SNP 满足阈值，则 $S(p_T)$ 为空，PRS 是一个零向量。\n\n最后，我们评估 PRS 的预测准确性。这是通过决定系数 $R^2$ 来衡量的，即测试队列中预测的 PRS 与实际表型之间的 Pearson 相关性的平方：\n$$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2$$\n如果 PRS 或测试表型的方差为零，则相关性未定义，此时 $R^2(p_T)$ 设置为 $0$。\n\n该算法将为测试套件中提供的每个参数集系统地执行这整个流程。为提高效率，将使用 `numpy` 进行向量化计算，特别是在 GWAS 摘要统计和 PRS 计算方面。每个案例的随机种子确保了随机模拟的可复现性。最终输出将是计算出的 $R^2(p_T)$ 值，并按要求进行四舍五入和格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t as student_t\n\ndef run_simulation(seed, n_train, n_test, m, k, h2, thresholds):\n    \"\"\"\n    Performs a single GWAS/PRS simulation run for a given set of parameters.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # 1. Simulate MAFs and Genotypes\n    mafs = rng.uniform(0.05, 0.5, size=m)\n    g_train = rng.binomial(2, mafs, size=(n_train, m))\n    g_test = rng.binomial(2, mafs, size=(n_test, m))\n    \n    # 2. Standardize Genotypes\n    mu_train = np.mean(g_train, axis=0)\n    sigma_train = np.std(g_train, axis=0)\n    \n    std_is_zero = (sigma_train == 0)\n    \n    x_train = np.zeros_like(g_train, dtype=float)\n    x_test = np.zeros_like(g_test, dtype=float)\n    \n    non_zero_std_indices = ~std_is_zero\n    \n    # Use np.divide with where clause to avoid runtime warnings\n    if np.any(non_zero_std_indices):\n        x_train[:, non_zero_std_indices] = np.divide(\n            g_train[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n        x_test[:, non_zero_std_indices] = np.divide(\n            g_test[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n\n    # 3. Simulate True Effects and Scale by Heritability\n    beta_raw = np.zeros(m)\n    if k  0:\n        causal_indices = rng.choice(m, size=k, replace=False)\n        beta_raw[causal_indices] = rng.normal(0, 1, size=k)\n    \n    g_train_component = x_train @ beta_raw\n    v_g = np.var(g_train_component)\n    \n    beta_star = np.zeros(m)\n    if v_g  0 and h2  0:\n        scaling_factor = np.sqrt(h2 / v_g)\n        beta_star = beta_raw * scaling_factor\n    \n    # 4. Simulate Phenotypes\n    sigma_e2 = 1.0 - h2\n    sigma_e = np.sqrt(sigma_e2) if sigma_e2  0 else 0.0\n    \n    y_train = x_train @ beta_star + rng.normal(0, sigma_e, size=n_train)\n    y_test = x_test @ beta_star + rng.normal(0, sigma_e, size=n_test)\n    \n    # 5. Perform GWAS in Training Cohort\n    hat_betas = np.zeros(m)\n    p_values = np.ones(m)\n    \n    y_train_var = np.var(y_train, ddof=1)\n    if y_train_var == 0:\n        # If y_train has no variance, all betas are 0 and p-values are 1.\n        # This is handled by hat_betas and p_values being pre-initialized.\n        pass\n    else:\n        y_train_c = y_train - np.mean(y_train)\n        \n        # OLS slope estimates (beta_hat)\n        sum_x_sq = np.sum(x_train**2, axis=0)\n        valid_snps_for_beta = (sum_x_sq  0)\n        \n        if np.any(valid_snps_for_beta):\n            hat_betas[valid_snps_for_beta] = (x_train[:, valid_snps_for_beta].T @ y_train_c) / sum_x_sq[valid_snps_for_beta]\n        \n        # Pearson correlations (r)\n        # r = beta_hat * (std_x / std_y)\n        std_x_train_sample = np.std(x_train, axis=0, ddof=1)\n        std_y_train_sample = np.sqrt(y_train_var)\n        \n        correlations = np.zeros(m)\n        valid_snps_for_corr = (std_x_train_sample  0)\n        if np.any(valid_snps_for_corr):\n            correlations[valid_snps_for_corr] = hat_betas[valid_snps_for_corr] * (std_x_train_sample[valid_snps_for_corr] / std_y_train_sample)\n\n        # Handle perfect correlation case to avoid division by zero in t-statistic\n        correlations = np.clip(correlations, -1.0 + 1e-15, 1.0 - 1e-15)\n\n        # t-statistics and p-values\n        df = n_train - 2\n        if df  0:\n            t_stats = (correlations / np.sqrt(1 - correlations**2)) * np.sqrt(df)\n            p_values = 2 * student_t.sf(np.abs(t_stats), df)\n            \n            # SNPs with zero variance in training must have p-value of 1\n            p_values[std_is_zero] = 1.0\n\n    # 6. Calculate PRS and R^2 for each threshold\n    r2_results = []\n    y_test_var = np.var(y_test)\n    \n    for p_t in thresholds:\n        included_snps_mask = (p_values = p_t)\n        \n        if not np.any(included_snps_mask) or y_test_var == 0:\n            r2_results.append(0.0)\n            continue\n        \n        hat_betas_selected = hat_betas[included_snps_mask]\n        x_test_selected = x_test[:, included_snps_mask]\n        \n        prs_test = x_test_selected @ hat_betas_selected\n        \n        prs_var = np.var(prs_test)\n        \n        if prs_var == 0:\n            r2_results.append(0.0)\n            continue\n            \n        corr_matrix = np.corrcoef(prs_test, y_test)\n        corr = corr_matrix[0, 1]\n        \n        r2 = corr**2\n        r2_results.append(np.round(r2, 6))\n        \n    return r2_results\n\n\ndef solve():\n    test_cases = [\n        {'seed': 42, 'n_train': 1500, 'n_test': 1000, 'm': 3000, 'k': 150, 'h2': 0.5, 'thresholds': [1e-8, 1e-5, 1e-3, 1e-2, 1e-1, 5e-1, 1]},\n        {'seed': 7, 'n_train': 300, 'n_test': 300, 'm': 1500, 'k': 50, 'h2': 0.5, 'thresholds': [1e-20, 1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 2023, 'n_train': 800, 'n_test': 800, 'm': 2000, 'k': 0, 'h2': 0.0, 'thresholds': [1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 99, 'n_train': 1200, 'n_test': 800, 'm': 2500, 'k': 100, 'h2': 0.8, 'thresholds': [1e-8, 1e-6, 1e-4, 1e-2, 1]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_simulation(\n            seed=case['seed'],\n            n_train=case['n_train'],\n            n_test=case['n_test'],\n            m=case['m'],\n            k=case['k'],\n            h2=case['h2'],\n            thresholds=case['thresholds']\n        )\n        all_results.append(results)\n    \n    # Format the final output string exactly as required\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2394707"}]}