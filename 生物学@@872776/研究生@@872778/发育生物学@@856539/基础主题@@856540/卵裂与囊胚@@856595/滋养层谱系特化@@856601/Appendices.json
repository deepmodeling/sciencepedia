{"hands_on_practices": [{"introduction": "第一个练习深入探讨了Hippo-YAP信号通路的核心机制，该通路如同一个由细胞位置控制的基本开关。我们将使用一个简化的数学模型——常微分方程（ODE）——来描述YAP蛋白进出细胞核的动态过程。通过求解其稳态条件，你将定量地看到空间信息（内部 vs. 外部）如何被转化为截然不同的分子状态，为胚胎中第一个细胞命运决定奠定基础。[@problem_id:2686350]", "problem": "在植入前小鼠胚胎中，外部细胞保留顶端结构域并表现出较低的Hippo通路活性，而内部细胞则失去顶端结构域并表现出较高的Hippo通路活性。当Hippo通路失活时，Yes相关蛋白 (YAP) 的核定位受到促进；而当Hippo通路激活时，其核定位受到抑制。考虑一个描述YAP核内浓度的常微分方程 (ODE)，该浓度记为 $Y_{n}$ (单位任意)，并用Hippo活性变量 $H \\in \\{0,1\\}$ 表示：\n$$\n\\frac{dY_{n}}{dt} = k_{\\mathrm{in}} \\left(1 - H \\right) - k_{\\mathrm{out}} Y_{n}.\n$$\n此处，$k_{\\mathrm{in}}$ (任意单位/分钟) 是一个受Hippo抑制的核输入项，$k_{\\mathrm{out}}$ (每分钟) 是一个一级核输出项。在生物学上，$H=1$ 对应内部细胞（因失去顶端结构域而具有高Hippo活性），而 $H=0$ 对应外部细胞（因具有完整的顶端结构域而具有低Hippo活性）。假设系统达到由 $\\frac{dY_{n}}{dt} = 0$ 定义的稳态，并使用参数值 $k_{\\mathrm{in}} = 1.2$ (任意单位/分钟) 和 $k_{\\mathrm{out}} = 0.3$ (每分钟)。\n\n通过应用稳态条件，从控制ODE中推导出稳态核YAP水平 $Y_{n}^{\\ast}$ 作为 $H$ 的函数，然后为两种细胞状态——内部 ($H=1$) 和外部 ($H=0$)——计算 $Y_{n}^{\\ast}$ 的值。用任意单位表示您的最终数值答案。按（内部，外部）的顺序以数对的形式报告您的答案。", "solution": "在尝试任何解答之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 控制常微分方程 (ODE)：$\\frac{dY_{n}}{dt} = k_{\\mathrm{in}} \\left(1 - H \\right) - k_{\\mathrm{out}} Y_{n}$\n- $Y_{n}$：YAP的核内浓度（任意单位）\n- $H$：Hippo活性变量，$H \\in \\{0,1\\}$\n- $k_{\\mathrm{in}}$：受Hippo抑制的核输入速率常数，$k_{\\mathrm{in}} = 1.2$ (任意单位/分钟)\n- $k_{\\mathrm{out}}$：一级核输出速率常数，$k_{\\mathrm{out}} = 0.3$ (每分钟)\n- $H$的生物学对应关系：$H=1$ 对应内部细胞，$H=0$ 对应外部细胞。\n- 稳态条件：$\\frac{dY_{n}}{dt} = 0$。\n- 目标：推导稳态核YAP水平 $Y_{n}^{\\ast}$ 作为 $H$ 的函数，然后计算当 $H=1$ 和 $H=0$ 时 $Y_{n}^{\\ast}$ 的值。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题提出了一个简化但标准的数学模型，用于描述受上游信号通路 (Hippo) 调控的蛋白质核-质穿梭。这是定量生物学和系统生物学中的一种常用方法。其生物学前提是正确的。\n- **良态问题：** 该问题提供了一个清晰的ODE、所有必需的参数以及一个可以推导出唯一解的特定条件（稳態）。问题没有歧义。\n- **客观性：** 语言是形式化和定量的，没有主观内容。\n- **缺陷分析：**\n  - 该问题在科学上是合理的，并且可以形式化。\n  - 它是完整的且内部一致的。单位是协调的：$k_{\\mathrm{in}}$ 的单位是浓度/时间，而 $k_{\\mathrm{out}} Y_{n}$ 的单位也是浓度/时间，因为 $k_{\\mathrm{out}}$ 的单位是时间的倒数，$Y_{n}$ 的单位是浓度。\n  - 在简化模型的背景下，该设置在物理上是合理的。\n  - 对于每个指定的 $H$ 值，都存在一个唯一的稳定解。\n\n**步骤3：结论与行动**\n问题被判定为 **有效**。将提供解答。\n\n分析始于所给出的描述核YAP浓度 $Y_n$ 变化率的常微分方程：\n$$\n\\frac{dY_{n}}{dt} = k_{\\mathrm{in}} \\left(1 - H \\right) - k_{\\mathrm{out}} Y_{n}\n$$\n问题要求找到稳态浓度，记为 $Y_{n}^{\\ast}$。根据定义，当一个系统的状态变量随时间没有净变化时，该系统处于稳态。对于变量 $Y_{n}$，这个条件表示为：\n$$\n\\frac{dY_{n}}{dt} = 0\n$$\n将此条件应用于控制ODE，我们用其稳态值 $Y_{n}^{\\ast}$ 替换 $Y_{n}$：\n$$\n0 = k_{\\mathrm{in}} \\left(1 - H \\right) - k_{\\mathrm{out}} Y_{n}^{\\ast}\n$$\n这是一个关于 $Y_{n}^{\\ast}$ 的代数方程。为了推导出 $Y_{n}^{\\ast}$ 作为Hippo活性变量 $H$ 的函数的表达式，我们重新整理方程：\n$$\nk_{\\mathrm{out}} Y_{n}^{\\ast} = k_{\\mathrm{in}} \\left(1 - H \\right)\n$$\n通过除以 $k_{\\mathrm{out}}$ (非零) 来求解 $Y_{n}^{\\ast}$，得到通用的稳态解：\n$$\nY_{n}^{\\ast}(H) = \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{out}}} \\left(1 - H \\right)\n$$\n这个表达式给出了对于任何给定的 $H$ 值时的稳态核YAP浓度。我们现在的任务是为两种指定的细胞状态计算这个表达式的值。\n\n情况1：内部细胞\n对于内部细胞，Hippo通路高度活跃，对应于 $H=1$。将 $H=1$ 代入通用稳态解：\n$$\nY_{n, \\text{inside}}^{\\ast} = Y_{n}^{\\ast}(1) = \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{out}}} \\left(1 - 1 \\right) = \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{out}}} \\left(0 \\right) = 0\n$$\n因此，内部细胞中的稳态核YAP浓度为 $0$ 任意单位。\n\n情况2：外部细胞\n对于外部细胞，Hippo通路活性较低，对应于 $H=0$。将 $H=0$ 代入通用稳态解：\n$$\nY_{n, \\text{outside}}^{\\ast} = Y_{n}^{\\ast}(0) = \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{out}}} \\left(1 - 0 \\right) = \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{out}}}\n$$\n现在，我们代入所给的参数数值 $k_{\\mathrm{in}} = 1.2$ 任意单位/分钟 和 $k_{\\mathrm{out}} = 0.3$ 每分钟：\n$$\nY_{n, \\text{outside}}^{\\ast} = \\frac{1.2}{0.3} = 4\n$$\n因此，外部细胞中的稳态核YAP浓度为 $4$ 任意单位。\n\n最终答案需按（内部，外部）的顺序以数对的形式报告。\n- 内部细胞稳态YAP ($Y_{n, \\text{inside}}^{\\ast}$): $0$\n- 外部细胞稳态YAP ($Y_{n, \\text{outside}}^{\\ast}$): $4$\n\n该有序数对是 ($0$, $4$)。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0  4 \\end{pmatrix}}\n$$", "id": "2686350"}, {"introduction": "在上游YAP信号的基础上，本练习将探讨下游的基因调控网络（GRN）如何解读这一信号以建立稳定的细胞命运。我们将使用布尔网络模型——一种理解遗传回路逻辑的强大工具——来表示CDX2和OCT4等关键转录因子之间的相互作用。通过编程实现该模型，你将能够识别网络的稳定状态（即“吸引子”），它们分别对应于滋养外胚层（TE）和内细胞团（ICM）谱系，并探究基因扰动如何改变细胞的命运图景。[@problem_id:2686330]", "problem": "给定一个同步布尔基因调控网络，该网络模拟滋养层谱系的形成，其节点集为 $\\{\\mathrm{CDX2},\\mathrm{ELF5},\\mathrm{EOMES},\\mathrm{OCT4}\\}$。每个节点具有一个布尔状态 $x \\in \\{0,1\\}$，代表其在离散时间步 $t \\in \\mathbb{Z}_{\\ge 0}$ 的转录状态。全局网络状态是一个向量 $\\mathbf{x}(t) = \\big(x_{\\mathrm{CDX2}}(t), x_{\\mathrm{ELF5}}(t), x_{\\mathrm{EOMES}}(t), x_{\\mathrm{OCT4}}(t)\\big) \\in \\{0,1\\}^{4}$。同步更新映射 $\\mathbf{F}:\\{0,1\\}^{4}\\to \\{0,1\\}^{4}$ 由源自基因调控核心原则的布尔函数定义：多能性程序与滋养层程序之间的相互抑制，以及滋养层转录因子之间的协同自维持。使用标准逻辑连接词 $\\lor$ (OR)，$\\land$ (AND) 和 $\\neg$ (NOT)，更新函数为：\n$$\n\\begin{aligned}\nf_{\\mathrm{CDX2}}(\\mathbf{x}) = \\big(x_{\\mathrm{ELF5}} \\lor x_{\\mathrm{EOMES}} \\lor x_{\\mathrm{CDX2}}\\big) \\land \\neg x_{\\mathrm{OCT4}},\\\\\nf_{\\mathrm{ELF5}}(\\mathbf{x}) = \\big(x_{\\mathrm{CDX2}} \\lor x_{\\mathrm{EOMES}} \\lor x_{\\mathrm{ELF5}}\\big) \\land \\neg x_{\\mathrm{OCT4}},\\\\\nf_{\\mathrm{EOMES}}(\\mathbf{x}) = \\big(x_{\\mathrm{CDX2}} \\lor x_{\\mathrm{ELF5}} \\lor x_{\\mathrm{EOMES}}\\big) \\land \\neg x_{\\mathrm{OCT4}},\\\\\nf_{\\mathrm{OCT4}}(\\mathbf{x}) = \\neg \\big(x_{\\mathrm{CDX2}} \\lor x_{\\mathrm{ELF5}} \\lor x_{\\mathrm{EOMES}}\\big).\n\\end{aligned}\n$$\n同步更新规则为 $\\mathbf{x}(t+1) = \\mathbf{F}\\big(\\mathbf{x}(t)\\big)$。稳定吸引子（不动点）是满足 $\\mathbf{F}(\\mathbf{x}^{\\ast}) = \\mathbf{x}^{\\ast}$ 的任意状态 $\\mathbf{x}^{\\ast} \\in \\{0,1\\}^{4}$。在某些情况下，特定节点在所有时间内被钳制（外部强制）到固定值；在数学上，将子集 $\\mathcal{C} \\subseteq \\{\\mathrm{CDX2},\\mathrm{ELF5},\\mathrm{EOMES},\\mathrm{OCT4}\\}$ 钳制到指定值，定义了一个受约束的更新 $\\tilde{\\mathbf{F}}$，该更新首先计算 $\\mathbf{F}$，然后对于所有 $i \\in \\mathcal{C}$，将 $x_i$ 覆盖为其钳制值。钳制稳定吸引子是 $\\tilde{\\mathbf{F}}$ 的不动点。\n\n为任意状态 $\\mathbf{x}$ 定义表型分类如下：\n- 类滋养层细胞 (TE-like)：若 $\\big(x_{\\mathrm{CDX2}} + x_{\\mathrm{ELF5}} + x_{\\mathrm{EOMES}}\\big) \\ge 2$ 且 $x_{\\mathrm{OCT4}} = 0$。\n- 类内细胞团 (ICM-like)：若 $x_{\\mathrm{CDX2}} = x_{\\mathrm{ELF5}} = x_{\\mathrm{EOMES}} = 0$ 且 $x_{\\mathrm{OCT4}} = 1$。\n- 否则，分类为其他。\n\n对于任意状态 $\\mathbf{x} = \\big(x_{\\mathrm{CDX2}}, x_{\\mathrm{ELF5}}, x_{\\mathrm{EOMES}}, x_{\\mathrm{OCT4}}\\big)$，定义一个整数编码\n$$\nv(\\mathbf{x}) \\;=\\; 8\\,x_{\\mathrm{CDX2}} \\;+\\; 4\\,x_{\\mathrm{ELF5}} \\;+\\; 2\\,x_{\\mathrm{EOMES}} \\;+\\; 1\\,x_{\\mathrm{OCT4}}.\n$$\n这将每个布尔状态映射到 $\\{0,1,\\dots,15\\}$ 中的一个唯一整数。\n\n任务：编写一个程序，对于以下每个钳制测试用例，枚举指定同步动态下的所有稳定吸引子（不动点），对每个吸引子进行分类，并按要求的格式输出结果。\n\n测试套件（每个用例指定一个钳制集 $\\mathcal{C}$ 及其强制值）：\n- 用例 A（野生型）：无钳制，$\\mathcal{C} = \\varnothing$。\n- 用例 B（OCT4 强制开启）：钳制 $x_{\\mathrm{OCT4}} \\equiv 1$。\n- 用例 C（OCT4 敲除）：钳制 $x_{\\mathrm{OCT4}} \\equiv 0$。\n- 用例 D（ELF5 敲除）：钳制 $x_{\\mathrm{ELF5}} \\equiv 0$。\n\n对于每个用例，程序必须：\n- 枚举所有 $\\mathbf{x} \\in \\{0,1\\}^{4}$，应用相应的受约束更新 $\\tilde{\\mathbf{F}}$，并收集所有不动点。\n- 对于每个不动点，计算其 $v(\\mathbf{x})$ 并分配一个类别代码 $c(\\mathbf{x}) \\in \\{-1,0,1\\}$，其中 1 表示 TE-like，0 表示 ICM-like，-1 表示其他。\n- 按 $v(\\mathbf{x})$ 的升序对吸引子进行排序。\n\n最终输出格式：\n- 程序应产生单行输出，包含一个方括号括起来的逗号分隔列表。列表中应按 A、B、C、D 的顺序为每个测试用例包含一个元素。每个元素本身必须是该用例的 $[v(\\mathbf{x}), c(\\mathbf{x})]$ 对的列表，并按 $v(\\mathbf{x})$ 排序。例如，一个有效的总输出具有以下形式：\n$[[[v_1,c_1],[v_2,c_2]],[[v_3,c_3]],[[v_4,c_4]],[[v_5,c_5],[v_6,c_6]]]$。\n输出是无量纲整数；不涉及物理单位。不涉及角度。不使用百分比。\n\n您的程序必须是一个完整的、可运行的脚本，它能产生完全符合上述格式的一行输出，不含任何额外文本。", "solution": "问题陈述经过了严格验证，被认为是科学上合理、定义明确且客观的。它描述了系统生物学中的一个经典问题：在同步布尔网络中分析不动点，这是模拟基因调控网络的标准形式化方法。网络动态、钳制条件、状态分类和计算任务都以数学精度进行了定义，没有矛盾或歧义。其生物学前提，即多能性因子（如 $\\mathrm{OCT4}$）和滋养外胚层因子（如 $\\mathrm{CDX2}$, $\\mathrm{ELF5}$, $\\mathrm{EOMES}$）之间的相互拮抗，是对发育生物学中既定原则的有效（尽管简化了的）表述。因此，有必要提供一个完整的解决方案。\n\n问题的核心是在几种外部钳制条件下，识别一个离散动力系统的所有稳定吸引子，特别是不动点。一个更新映射为 $\\tilde{\\mathbf{F}}$ 的系统的不动点 $\\mathbf{x}^{\\ast}$ 是一个满足条件 $\\mathbf{x}^{\\ast} = \\tilde{\\mathbf{F}}(\\mathbf{x}^{\\ast})$ 的状态。状态空间是有限的，包含 $2^4 = 16$ 个可能的状态，这允许通过穷举法获得完整解。\n\n状态向量为 $\\mathbf{x} = (x_{\\mathrm{CDX2}}, x_{\\mathrm{ELF5}}, x_{\\mathrm{EOMES}}, x_{\\mathrm{OCT4}})$，其中每个分量 $x_i \\in \\{0, 1\\}$。同步更新映射 $\\mathbf{F}(\\mathbf{x}) = (f_{\\mathrm{CDX2}}(\\mathbf{x}), f_{\\mathrm{ELF5}}(\\mathbf{x}), f_{\\mathrm{EOMES}}(\\mathbf{x}), f_{\\mathrm{OCT4}}(\\mathbf{x}))$ 由以下布尔函数定义：\n$$\n\\begin{aligned}\nf_{\\mathrm{CDX2}}(\\mathbf{x}) = T(\\mathbf{x}) \\land \\neg x_{\\mathrm{OCT4}} \\\\\nf_{\\mathrm{ELF5}}(\\mathbf{x}) = T(\\mathbf{x}) \\land \\neg x_{\\mathrm{OCT4}} \\\\\nf_{\\mathrm{EOMES}}(\\mathbf{x}) = T(\\mathbf{x}) \\land \\neg x_{\\mathrm{OCT4}} \\\\\nf_{\\mathrm{OCT4}}(\\mathbf{x}) = \\neg T(\\mathbf{x})\n\\end{aligned}\n$$\n其中 $T(\\mathbf{x}) = x_{\\mathrm{CDX2}} \\lor x_{\\mathrm{ELF5}} \\lor x_{\\mathrm{EOMES}}$ 是一个辅助函数，代表指定滋养层的转录因子的集体活动。\n\n计算策略如下：\n1. 遍历每个可能的状态 $\\mathbf{x} \\in \\{0, 1\\}^4$。\n2. 对于每个状态和每种钳制情景，计算下一个状态 $\\mathbf{y} = \\mathbf{F}(\\mathbf{x})$。\n3. 对 $\\mathbf{y}$ 应用适当的钳制条件以获得受约束的下一个状态 $\\mathbf{x}' = \\tilde{\\mathbf{F}}(\\mathbf{x})$。\n4. 如果 $\\mathbf{x}' = \\mathbf{x}$，那么 $\\mathbf{x}$ 是该情景下的一个不动点。\n5. 对于每个已识别的不动点，计算其整数编码 $v(\\mathbf{x}) = 8x_{\\mathrm{CDX2}} + 4x_{\\mathrm{ELF5}} + 2x_{\\mathrm{EOMES}} + 1x_{\\mathrm{OCT4}}$ 及其表型分类代码 $c(\\mathbf{x})$。\n6. 为每个用例收集结果并按指定进行排序。\n\n表型分类函数 $c(\\mathbf{x})$ 定义如下：\n$$\nc(\\mathbf{x}) = \\begin{cases} \n1  \\text{若 } (x_{\\mathrm{CDX2}} + x_{\\mathrm{ELF5}} + x_{\\mathrm{EOMES}}) \\ge 2 \\text{ 且 } x_{\\mathrm{OCT4}} = 0 \\quad (\\text{TE-like}) \\\\\n0  \\text{若 } x_{\\mathrm{CDX2}} = x_{\\mathrm{ELF5}} = x_{\\mathrm{EOMES}} = 0 \\text{ 且 } x_{\\mathrm{OCT4}} = 1 \\quad (\\text{ICM-like}) \\\\\n-1  \\text{否则} \\end{cases}\n$$\n\n我们现在系统地分析每个测试用例。\n\n**用例 A：野生型（无钳制）**\n在此情况下，受约束的更新映射 $\\tilde{\\mathbf{F}}$ 与不受约束的映射 $\\mathbf{F}$ 相同。我们寻找满足 $\\mathbf{x}^{\\ast} = \\mathbf{F}(\\mathbf{x}^{\\ast})$ 的状态 $\\mathbf{x}^{\\ast}$。\n通过遍历所有 16 个状态，我们找到两个不动点：\n1. $\\mathbf{x}^{\\ast}_1 = (0, 0, 0, 1)$。此时，$T=0$。$\\mathbf{F}(\\mathbf{x}^{\\ast}_1) = (0 \\land \\neg 1, 0 \\land \\neg 1, 0 \\land \\neg 1, \\neg 0) = (0, 0, 0, 1)$。这是一个不动点。\n   - $v(\\mathbf{x}^{\\ast}_1) = 1$。\n   - 分类：$x_{\\mathrm{CDX2}} + x_{\\mathrm{ELF5}} + x_{\\mathrm{EOMES}} = 0$ 且 $x_{\\mathrm{OCT4}}=1$。这是类内细胞团 (ICM-like)，因此 $c(\\mathbf{x}^{\\ast}_1)=0$。\n2. $\\mathbf{x}^{\\ast}_2 = (1, 1, 1, 0)$。此时，$T=1$。$\\mathbf{F}(\\mathbf{x}^{\\ast}_2) = (1 \\land \\neg 0, 1 \\land \\neg 0, 1 \\land \\neg 0, \\neg 1) = (1, 1, 1, 0)$。这是一个不动点。\n   - $v(\\mathbf{x}^{\\ast}_2) = 8+4+2 = 14$。\n   - 分类：$x_{\\mathrm{CDX2}} + x_{\\mathrm{ELF5}} + x_{\\mathrm{EOMES}} = 3 \\ge 2$ 且 $x_{\\mathrm{OCT4}}=0$。这是类滋养层细胞 (TE-like)，因此 $c(\\mathbf{x}^{\\ast}_2)=1$。\n用例 A 的排序结果：$[[1, 0], [14, 1]]$。\n\n**用例 B：OCT4 强制开启（钳制 $x_{\\mathrm{OCT4}} \\equiv 1$）**\n如果一个状态 $\\mathbf{x}^{\\ast}$ 等于计算 $\\mathbf{F}(\\mathbf{x}^{\\ast})$ 后将 $\\mathrm{OCT4}$ 分量强制为 1 的结果，则它是一个不动点。该状态本身必须有 $x_{\\mathrm{OCT4}} = 1$ 才能成为不动点。\n令 $\\mathbf{x}^{\\ast} = (x_{\\mathrm{CDX2}}, x_{\\mathrm{ELF5}}, x_{\\mathrm{EOMES}}, 1)$。$\\mathbf{y} = \\mathbf{F}(\\mathbf{x}^{\\ast})$，且 $\\mathbf{x}'$ 是将 $\\mathbf{y}$ 的 $y_4$ 设为 1 后的结果。我们需要 $\\mathbf{x}^{\\ast} = \\mathbf{x}'$。\n对于任何 $x_{\\mathrm{OCT4}} = 1$ 的状态 $\\mathbf{x}$，前三个分量的更新函数为 $f(\\mathbf{x}) = T(\\mathbf{x}) \\land \\neg 1 = 0$。因此，对于任何此类状态，$\\mathbf{F}(\\mathbf{x})$ 的前三个分量将为 0。所以，唯一可能的不动点必须是 $(0, 0, 0, 1)$ 的形式。我们检查这个状态：\n1. $\\mathbf{x}^{\\ast} = (0, 0, 0, 1)$。与用例 A 中一样，$\\mathbf{F}(0, 0, 0, 1) = (0, 0, 0, 1)$。将第四个分量覆盖为 1 不会改变结果。因此，$\\tilde{\\mathbf{F}}(0, 0, 0, 1) = (0, 0, 0, 1)$。它是一个不动点。\n   - $v(\\mathbf{x}^{\\ast}) = 1$。\n   - 分类是类内细胞团 (ICM-like)，$c(\\mathbf{x}^{\\ast})=0$。\n用例 B 的结果：$[[1, 0]]$。\n\n**用例 C：OCT4 敲除（钳制 $x_{\\mathrm{OCT4}} \\equiv 0$）**\n在这里，我们在每次更新后将 $x_{\\mathrm{OCT4}}$ 钳制为 0。不动点 $\\mathbf{x}^{\\ast}$ 必须有 $x_{\\mathrm{OCT4}} = 0$。\n1. 检查 $\\mathbf{x}^{\\ast} = (0, 0, 0, 0)$。此时 $T=0$。$\\mathbf{F}(0, 0, 0, 0) = (0 \\land \\neg 0, ..., \\neg 0) = (0, 0, 0, 1)$。将 $x_{\\mathrm{OCT4}}$ 钳制为 0 得到 $(0, 0, 0, 0)$，即原始状态。它是一个不动点。\n   - $v(\\mathbf{x}^{\\ast}) = 0$。\n   - 分类：滋养层因子之和为 0，且 $x_{\\mathrm{OCT4}}=0$。这既不符合 TE-like 也不符合 ICM-like 的标准。它是“其他”，所以 $c(\\mathbf{x}^{\\ast})=-1$。\n2. 检查 $\\mathbf{x}^{\\ast} = (1, 1, 1, 0)$。此时 $T=1$。$\\mathbf{F}(1, 1, 1, 0) = (1 \\land \\neg 0, ..., \\neg 1) = (1, 1, 1, 0)$。将 $x_{\\mathrm{OCT4}}$ 钳制为 0 不会改变结果。它是一个不动点。\n   - $v(\\mathbf{x}^{\\ast}) = 14$。\n   - 分类是 TE-like，$c(\\mathbf{x}^{\\ast})=1$。\n用例 C 的排序结果：$[[0, -1], [14, 1]]$。\n\n**用例 D：ELF5 敲除（钳制 $x_{\\mathrm{ELF5}} \\equiv 0$）**\n我们在每次更新后将 $x_{\\mathrm{ELF5}}$ 钳制为 0。不动点 $\\mathbf{x}^{\\ast}$ 必须有 $x_{\\mathrm{ELF5}} = 0$。\n1. 检查 $\\mathbf{x}^{\\ast} = (0, 0, 0, 1)$。此时 $T=0$。$\\mathbf{F}(0, 0, 0, 1) = (0, 0, 0, 1)$。将 $x_{\\mathrm{ELF5}}$ 钳制为 0 不会改变结果。它是一个不动点。\n   - $v(\\mathbf{x}^{\\ast}) = 1$。\n   - 分类是类内细胞团 (ICM-like)，$c(\\mathbf{x}^{\\ast})=0$。\n2. 检查其他 $x_{\\mathrm{ELF5}}=0$ 的状态。考虑 $\\mathbf{x}^{\\ast} = (1, 0, 1, 0)$。此时 $T = 1 \\lor 0 \\lor 1 = 1$。$\\mathbf{F}(\\mathbf{x}^{\\ast}) = (1 \\land \\neg 0, 1 \\land \\neg 0, 1 \\land \\neg 0, \\neg 1) = (1, 1, 1, 0)$。将 $x_{\\mathrm{ELF5}}$ 钳制为 0 得到 $(1, 0, 1, 0)$，即原始状态。它是一个不动点。\n   - $v(\\mathbf{x}^{\\ast}) = 8(1) + 4(0) + 2(1) + 1(0) = 10$。\n   - 分类：$x_{\\mathrm{CDX2}} + x_{\\mathrm{ELF5}} + x_{\\mathrm{EOMES}} = 1+0+1 = 2$。因为 $2 \\ge 2$ 且 $x_{\\mathrm{OCT4}}=0$，这是 TE-like。所以 $c(\\mathbf{x}^{\\ast})=1$。\n用例 D 的排序结果：$[[1, 0], [10, 1]]$。\n\n下面的程序将实现这种穷举搜索并重现这些发现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Boolean network problem by enumerating all states and finding\n    fixed points under different clamping conditions.\n    \"\"\"\n\n    # Test cases: (clamp_idx, clamp_val) or None for wild-type\n    # Node order: CDX2, ELF5, EOMES, OCT4\n    # Indices:    0,    1,    2,     3\n    test_cases = {\n        'A': None,                     # Case A: wild-type\n        'B': {'idx': 3, 'val': 1},     # Case B: OCT4 forced ON\n        'C': {'idx': 3, 'val': 0},     # Case C: OCT4 knockout\n        'D': {'idx': 1, 'val': 0},     # Case D: ELF5 knockout\n    }\n\n    # The order of execution must be A, B, C, D\n    case_order = ['A', 'B', 'C', 'D']\n    \n    all_results = []\n\n    # Number of nodes\n    n_nodes = 4\n    # Total number of states = 2^n_nodes\n    n_states = 1  n_nodes\n\n    for case_key in case_order:\n        clamp_info = test_cases[case_key]\n        fixed_points = []\n        \n        # Iterate through all 2^4 = 16 possible states\n        for i in range(n_states):\n            # The state vector x is represented as a list of integers (0 or 1)\n            # The order is [x_CDX2, x_ELF5, x_EOMES, x_OCT4]\n            # This corresponds to binary representation of i, padded with zeros\n            state_bin = format(i, f'0{n_nodes}b')\n            x = [int(bit) for bit in state_bin]\n            \n            # Unpack state variables for clarity\n            x_cdx2, x_elf5, x_eomes, x_oct4 = x\n            \n            # --- 1. Compute the next state using the unconstrained update map F ---\n            # T = x_CDX2 OR x_ELF5 OR x_EOMES\n            T = bool(x_cdx2 or x_elf5 or x_eomes)\n            \n            # not_oct4 = NOT x_OCT4\n            not_oct4 = not bool(x_oct4)\n            \n            # Update functions\n            f_cdx2 = T and not_oct4\n            f_elf5 = T and not_oct4\n            f_eomes = T and not_oct4\n            f_oct4 = not T\n            \n            next_x_unclamped = [int(f_cdx2), int(f_elf5), int(f_eomes), int(f_oct4)]\n            \n            # --- 2. Apply clamping to get the constrained next state ---\n            next_x_clamped = list(next_x_unclamped)\n            if clamp_info is not None:\n                clamp_idx = clamp_info['idx']\n                clamp_val = clamp_info['val']\n                next_x_clamped[clamp_idx] = clamp_val\n            \n            # --- 3. Check for fixed point condition ---\n            if next_x_clamped == x:\n                # This state x is a fixed point for the current case.\n                \n                # --- 4. Compute integer encoding v(x) ---\n                v_x = 8 * x_cdx2 + 4 * x_elf5 + 2 * x_eomes + 1 * x_oct4\n                \n                # --- 5. Compute phenotype classification c(x) ---\n                troph_sum = x_cdx2 + x_elf5 + x_eomes\n                c_x = -1 # Default to 'other'\n                if troph_sum >= 2 and x_oct4 == 0:\n                    c_x = 1  # TE-like\n                elif troph_sum == 0 and x_oct4 == 1:\n                    c_x = 0  # ICM-like\n\n                fixed_points.append([v_x, c_x])\n\n        # Sort the collected fixed points by their integer encoding v(x)\n        fixed_points.sort(key=lambda p: p[0])\n        all_results.append(fixed_points)\n\n    # Format the final output string as specified\n    # The map(str, ...) converts each inner list to its string representation\n    # e.g., [[1, 0], [14, 1]] becomes \"[[1, 0], [14, 1]]\"\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    \n    # Python's default str() adds spaces. The required format has none.\n    # A simple replace ensures strict formatting.\n    output_str = output_str.replace(\" \", \"\")\n\n    print(output_str)\n\nsolve()\n```", "id": "2686330"}, {"introduction": "真实的生物过程具有内在的随机性；例如，细胞间的极性水平可能存在显著差异。最后一个实践练习将挑战你评估TE/ICM命运决定系统在这种随机性面前的稳健性。你将建立一个整合了确定性位置线索与细胞极性随机变化的定量模型，用以计算细胞命运错误指定的概率。通过进行敏感性分析，你将揭示关键生物学参数（如信号强度和噪声水平）如何影响胚胎发育的可靠性。[@problem_id:2686297]", "problem": "给定一个用于描述植入前发育过程中滋养外胚层 (TE) 与内细胞团 (ICM) 细胞命运决定的最小化、有充分依据的量化模型。该模型整合了位置性 Hippo 信号通路和顶-基底极性遗传的作用。该模型将两个广为接受的生物学原理形式化：(i) 位置线索调节 Hippo 通路激活，从而抑制核内 Yes 相关蛋白 (YAP) 以促进 ICM 命运；(ii) 细胞分裂时，极性以有限方差随机遗传，强极性会促进 TE 命运。所有变量均为无量纲。\n\n基本依据和定义：\n- 细胞占据两种位置状态之一，外部或内部，编码为 $S \\in \\{0,1\\}$，其中 $S=0$ 表示外部，$S=1$ 表示内部。\n- 核内 YAP 活性 $Y$ 根据公式 $Y = Y_b + w_A A - w_H H$ 整合了极性 $A$ 和 Hippo 激活 $H$，$Y_b$ 是基线水平，$w_A$ 量化了极性对 YAP 的贡献，$w_H$ 量化了 Hippo 的抑制作用。\n- 极性 $A$ 在细胞分裂时以正态变异性随机遗传：以位置 $S$ 为条件，$A \\sim \\mathcal{N}(\\mu_S,\\sigma^2)$，外部细胞的均值为 $\\mu_0$，内部细胞的均值为 $\\mu_1$。方差 $\\sigma^2$ 模拟了极性遗传的方差。\n- 位置性 Hippo 激活为 $H = \\lambda_p \\cdot S$，其中 $\\lambda_p$ 是位置性 Hippo 激活强度（内部更强）。\n- 当且仅当 $Y  \\theta$ 时，细胞分化为 TE，否则分化为 ICM。\n- 当 TE/ICM 决定与位置不匹配时，发生错误指定：外部细胞应为 TE，内部细胞应为 ICM。\n\n使用以下固定的、具有生物学合理性的常数：\n- $Y_b = 0.3$, $w_A = 1.0$, $w_H = 1.0$, $\\theta = 1.0$。\n- $\\mu_0 = 1.2$ (外部极性均值), $\\mu_1 = 0.8$ (内部极性均值)。\n- 外部细胞的比例为 $f_{\\mathrm{out}} = 0.5$。\n\n任务：\n1. 从第一性原理出发，推导外部细胞和内部细胞的错误指定概率表达式，该表达式用 $(\\lambda_p,\\sigma^2)$ 及上述常数表示。假设 $A$ 呈正态分布，且 $Y$ 是 $A$ 和 $H$ 的仿射函数。请仔细处理 $\\sigma^2 = 0$ 的极限情况。\n2. 使用您推导的表达式，计算下面测试套件中每个参数对 $(\\lambda_p,\\sigma^2)$ 的总错误指定率（以小数形式表示）。总错误指定率是外部和内部错误指定率的加权和，权重分别为 $f_{\\mathrm{out}}$ 和 $1-f_{\\mathrm{out}}$。\n3. 对测试套件进行敏感性分析，并找出产生最低总错误指定率的参数对的索引（从零开始）。如果出现完全相同的情况，选择最小的索引。\n\n参数对 $(\\lambda_p,\\sigma^2)$ 的测试套件：\n- 案例 $0$：$(0.0, 0.0)$\n- 案例 $1$：$(0.0, 0.01)$\n- 案例 $2$：$(0.5, 0.01)$\n- 案例 $3$：$(1.0, 0.01)$\n- 案例 $4$：$(1.0, 0.5)$\n- 案例 $5$：$(3.0, 0.01)$\n- 案例 $6$：$(3.0, 1.0)$\n\n输出规格：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。\n- 该列表必须按上述顺序包含每个案例的总错误指定率（每个值精确到 $6$ 位小数），最后是具有最低总错误指定率的参数对的整数索引（从零开始）。\n- 示例格式（仅为说明）：$[0.123456,0.234567,0.345678,2]$。", "solution": "问题陈述提供了一个细胞命运指定的量化模型，该模型具有科学依据、问题定义良好、客观且内部一致。它没有违反任何无效标准。因此，有必要给出合理的解决方案。\n\n主要任务是推导外部和内部位置细胞的错误指定概率，然后使用这些概率计算几组参数的总错误指定率。\n\n首先，我们确定核内 YAP 活性 $Y$ 的统计特性。$Y$ 由仿射变换 $Y = Y_b + w_A A - w_H H$ 给出。极性 $A$ 是一个随机变量，在位置 $S$ 的条件下服从正态分布，$A \\sim \\mathcal{N}(\\mu_S, \\sigma^2)$。由于 $Y$ 是正态分布变量 $A$ 的仿射函数，因此 $Y$ 本身也必定服从正态分布。\n\n我们来推导外部细胞（$S=0$）的错误指定概率。\n对于外部细胞，位置为 $S=0$，因此 Hippo 激活项为 $H = \\lambda_p S = 0$。YAP 活性为 $Y_{S=0} = Y_b + w_A A$。极性 $A$ 从分布 $\\mathcal{N}(\\mu_0, \\sigma^2)$ 中抽取。$Y_{S=0}$ 的均值和方差为：\n$$E[Y_{S=0}] = E[Y_b + w_A A] = Y_b + w_A E[A] = Y_b + w_A \\mu_0$$\n$$Var(Y_{S=0}) = Var(Y_b + w_A A) = w_A^2 Var(A) = w_A^2 \\sigma^2$$\n因此，对于外部细胞，$Y_{S=0} \\sim \\mathcal{N}(Y_b + w_A \\mu_0, w_A^2 \\sigma^2)$。\n外部细胞预期会成为滋养外胚层 (TE)，这在 $Y  \\theta$ 时发生。如果细胞成为内细胞团 (ICM)，即事件 $Y_{S=0} \\le \\theta$，则发生错误指定。我们用 $P_{\\text{mis},0}$ 表示该事件的概率，它是在 $\\theta$ 处求值的 $Y_{S=0}$ 的累积分布函数 (CDF)。设 $\\Phi(z)$ 为标准正态分布 $\\mathcal{N}(0,1)$ 的累积分布函数。对于非零方差 ($\\sigma^2  0$)，此概率为：\n$$P_{\\text{mis},0} = P(Y_{S=0} \\le \\theta) = \\Phi\\left(\\frac{\\theta - E[Y_{S=0}]}{\\sqrt{Var(Y_{S=0})}}\\right) = \\Phi\\left(\\frac{\\theta - Y_b - w_A \\mu_0}{w_A \\sigma}\\right)$$\n在 $\\sigma^2 = 0$ 的极限情况下，极性是确定性的，$A = \\mu_0$。YAP 活性变为一个固定值 $Y_{S=0} = Y_b + w_A \\mu_0$。错误指定的概率是一个阶跃函数：\n$$P_{\\text{mis},0} = \\begin{cases} 1  \\text{if } Y_b + w_A \\mu_0 \\le \\theta \\\\ 0  \\text{if } Y_b + w_A \\mu_0  \\theta \\end{cases}$$\n\n接下来，我们推导内部细胞（$S=1$）的错误指定概率。\n对于内部细胞，$S=1$，因此 $H = \\lambda_p S = \\lambda_p$。YAP 活性为 $Y_{S=1} = Y_b + w_A A - w_H \\lambda_p$。极性 $A$ 从分布 $\\mathcal{N}(\\mu_1, \\sigma^2)$ 中抽取。$Y_{S=1}$ 的均值和方差为：\n$$E[Y_{S=1}] = E[Y_b + w_A A - w_H \\lambda_p] = Y_b + w_A \\mu_1 - w_H \\lambda_p$$\n$$Var(Y_{S=1}) = Var(Y_b + w_A A - w_H \\lambda_p) = w_A^2 Var(A) = w_A^2 \\sigma^2$$\n因此，对于内部细胞，$Y_{S=1} \\sim \\mathcal{N}(Y_b + w_A \\mu_1 - w_H \\lambda_p, w_A^2 \\sigma^2)$。\n内部细胞预期会成为 ICM ($Y \\le \\theta$)。如果它成为 TE，即事件 $Y_{S=1}  \\theta$，则发生错误指定。该事件的概率 $P_{\\text{mis},1}$ 由生存函数给出。对于 $\\sigma^2  0$：\n$$P_{\\text{mis},1} = P(Y_{S=1}  \\theta) = 1 - P(Y_{S=1} \\le \\theta) = 1 - \\Phi\\left(\\frac{\\theta - E[Y_{S=1}]}{\\sqrt{Var(Y_{S=1})}}\\right)$$\n使用恒等式 $1 - \\Phi(z) = \\Phi(-z)$，我们可以简化此表达式：\n$$P_{\\text{mis},1} = \\Phi\\left(-\\frac{\\theta - (Y_b + w_A \\mu_1 - w_H \\lambda_p)}{w_A \\sigma}\\right) = \\Phi\\left(\\frac{Y_b + w_A \\mu_1 - w_H \\lambda_p - \\theta}{w_A \\sigma}\\right)$$\n在 $\\sigma^2 = 0$ 的确定性情况下，$A = \\mu_1$，且 $Y_{S=1} = Y_b + w_A \\mu_1 - w_H \\lambda_p$。概率同样是一个阶跃函数：\n$$P_{\\text{mis},1} = \\begin{cases} 1  \\text{if } Y_b + w_A \\mu_1 - w_H \\lambda_p  \\theta \\\\ 0  \\text{if } Y_b + w_A \\mu_1 - w_H \\lambda_p \\le \\theta \\end{cases}$$\n\n总错误指定率 $R_{\\text{total}}$ 是单个错误指定概率的加权平均值，权重由外部和内部细胞的比例给出：\n$$R_{\\text{total}} = f_{\\mathrm{out}} P_{\\text{mis},0} + (1 - f_{\\mathrm{out}}) P_{\\text{mis},1}$$\n使用给定的常数 $f_{\\mathrm{out}} = 0.5$，可简化为：\n$$R_{\\text{total}} = 0.5 (P_{\\text{mis},0} + P_{\\text{mis},1})$$\n\n这些推导出的表达式将被实现，用以计算测试套件中每个参数对 $(\\lambda_p, \\sigma^2)$ 的总错误指定率。然后将识别出产生最低错误率的参数对。\n我们使用提供的常数：$Y_b=0.3$，$w_A=1.0$，$w_H=1.0$，$\\theta=1.0$，$\\mu_0=1.2$，$\\mu_1=0.8$。\n$\\Phi$ 函数的参数为：\n对于 $P_{\\text{mis},0}$：$\\frac{1.0 - 0.3 - 1.0 \\cdot 1.2}{1.0 \\cdot \\sigma} = \\frac{-0.5}{\\sigma}$。\n对于 $P_{\\text{mis},1}$：$\\frac{0.3 + 1.0 \\cdot 0.8 - 1.0 \\cdot \\lambda_p - 1.0}{1.0 \\cdot \\sigma} = \\frac{0.1 - \\lambda_p}{\\sigma}$。\n确定性条件为：\n对于 $P_{\\text{mis},0}=1$: $0.3 + 1.0 \\cdot 1.2 \\le 1.0 \\implies 1.5 \\le 1.0$，此为假。因此当 $\\sigma=0$ 时，$P_{\\text{mis},0}=0$。\n对于 $P_{\\text{mis},1}=1$: $0.3 + 1.0 \\cdot 0.8 - 1.0 \\cdot \\lambda_p  1.0 \\implies 0.1  \\lambda_p$。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Calculates the total mis-specification rate for trophectoderm (TE) vs.\n    inner cell mass (ICM) fate decisions based on a given quantitative model.\n    \"\"\"\n    \n    # Define the fixed, biologically plausible constants\n    Y_b = 0.3      # Baseline YAP activity\n    w_A = 1.0      # Contribution of polarity to YAP\n    w_H = 1.0      # Repression by Hippo\n    theta = 1.0    # Threshold for TE commitment (Y > theta)\n    mu_0 = 1.2     # Mean polarity for outside cells\n    mu_1 = 0.8     # Mean polarity for inside cells\n    f_out = 0.5    # Fraction of outside cells\n\n    # Test suite of parameter pairs (lambda_p, sigma^2)\n    test_cases = [\n        (0.0, 0.0),   # Case 0\n        (0.0, 0.01),  # Case 1\n        (0.5, 0.01),  # Case 2\n        (1.0, 0.01),  # Case 3\n        (1.0, 0.5),   # Case 4\n        (3.0, 0.01),  # Case 5\n        (3.0, 1.0)    # Case 6\n    ]\n\n    rates = []\n    for lambda_p, sigma_sq in test_cases:\n        # --- Mis-specification probability for outside cells (S=0) ---\n        # Correct fate is TE (Y > theta), mis-specification is ICM (Y = theta)\n        mu_Y_out = Y_b + w_A * mu_0  # Since S=0, H=0\n        \n        if sigma_sq == 0.0:\n            # Deterministic case: polarity A is fixed at its mean\n            p_mis_out = 1.0 if mu_Y_out = theta else 0.0\n        else:\n            # Stochastic case: polarity A is normally distributed\n            sigma = np.sqrt(sigma_sq)\n            std_dev_Y = w_A * sigma\n            # Probability P(Y_out = theta)\n            p_mis_out = norm.cdf((theta - mu_Y_out) / std_dev_Y)\n\n        # --- Mis-specification probability for inside cells (S=1) ---\n        # Correct fate is ICM (Y = theta), mis-specification is TE (Y > theta)\n        mu_Y_in = Y_b + w_A * mu_1 - w_H * lambda_p  # Since S=1, H=lambda_p\n        \n        if sigma_sq == 0.0:\n            # Deterministic case\n            p_mis_in = 1.0 if mu_Y_in > theta else 0.0\n        else:\n            # Stochastic case\n            sigma = np.sqrt(sigma_sq)\n            std_dev_Y = w_A * sigma\n            # Probability P(Y_in > theta) = 1 - P(Y_in = theta)\n            p_mis_in = 1.0 - norm.cdf((theta - mu_Y_in) / std_dev_Y)\n\n        # --- Total mis-specification rate ---\n        total_rate = f_out * p_mis_out + (1.0 - f_out) * p_mis_in\n        rates.append(total_rate)\n\n    # Find the index of the parameter pair with the lowest rate.\n    # np.argmin() returns the index of the first occurrence in case of a tie.\n    min_rate_index = np.argmin(rates)\n\n    # Format the results according to the specification\n    formatted_rates = [f\"{rate:.6f}\" for rate in rates]\n    output_str = f\"[{','.join(formatted_rates)},{min_rate_index}]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "2686297"}]}