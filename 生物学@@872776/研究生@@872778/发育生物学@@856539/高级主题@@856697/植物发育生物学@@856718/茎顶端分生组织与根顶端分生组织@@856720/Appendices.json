{"hands_on_practices": [{"introduction": "发育模式的形成通常依赖于形态发生素梯度。这种梯度的空间范围并非任意，而是由信号扩散和清除之间相互作用决定的一个可量化属性。在本练习 ([@problem_id:2671773]) 中，您将从一个标准的反应-扩散模型中推导出特征长度尺度，从而具体衡量一个信号分子（如RGF肽）在根尖分生组织内能有效传播的距离。", "problem": "在拟南芥 (Arabidopsis) 的根尖分生组织中，根分生组织生长因子 (Root Meristem Growth Factor, RGF) 肽由静止中心 (Quiescent Center, QC) 分泌，并扩散到周围组织中，在此过程中会发生扩散和一级清除（例如，受体介导的摄取或降解）。考虑一个从静止中心 (QC) 中心开始测量的一维径向坐标 $x$。令 $c(x,t)$ 表示 RGF 的浓度。对此过程的一个标准且经过充分检验的描述由带有线性清除项的菲克第二定律 (Fick’s second law) 给出，\n$$\n\\frac{\\partial c}{\\partial t} \\;=\\; D\\,\\frac{\\partial^2 c}{\\partial x^2} \\;-\\; \\lambda\\,c \\;+\\; S(x),\n$$\n其中 $D$ 是扩散系数，$\\lambda$ 是一级清除速率常数，$S(x)$ 代表在 $x=0$ 附近的局部分泌。远离源区域（即，对于 QC 外部的 $x0$），稳态浓度分布遵循\n$$\n0 \\;=\\; D\\,\\frac{d^2 c}{dx^2} \\;-\\; \\lambda\\,c.\n$$\n从这个稳态平衡方程出发，在不预设任何目标公式的情况下，推导出决定源外 $c(x)$ 空间衰减的特征扩散长度尺度 $\\,\\ell\\,$。然后，使用您推导出的表达式，计算当 $D = 20\\,\\mu\\mathrm{m}^2/\\mathrm{s}$ 和 $\\lambda = 0.01\\,\\mathrm{s}^{-1}$ 时的 $\\,\\ell\\,$ 值。将您最终的 $\\,\\ell\\,$ 数值答案以微米为单位表示，并四舍五入到四位有效数字。为了在您的推理中进行生物学解释，您可以取 QC 的直径为 $d_{\\mathrm{QC}} = 20\\,\\mu\\mathrm{m}$，并评论 $\\,\\ell\\,$ 与 $d_{\\mathrm{QC}}$ 相比是更大还是更小，但请注意，只有 $\\,\\ell\\,$ 的数值将被作为最终答案评分。", "solution": "问题陈述已经过验证。", "answer": "$$\\boxed{44.72}$$", "id": "2671773"}, {"introduction": "分生组织并非均一的细胞集合，而是一个由不同功能区域组成的、相互作用的细胞群体动态系统。本练习 ([@problem_id:2671831]) 引入了区室模型，以形式化的方式描述茎尖分生组织内的群体动态。通过将中央区、周边区和髓区之间的细胞流模拟为一级转化系统，您将能预测维持分生组织持久结构的稳定细胞分布。", "problem": "在茎端分生组织（Shoot Apical Meristem, SAM）中，细胞群体在空间上分为中央区、周边区和髓肋分生组织。设这些区域中随时间变化的细胞数量分别用 $C(t)$、$P(t)$ 和 $R(t)$ 表示。在所考虑的时间尺度上，假设分生组织细胞总数 $N$ 是守恒的，并且区域间的细胞重新分布是由具有恒定人均速率的连续时间一阶转换驱动的。具体来说，对于每个不同区域的有序对 $(i,j) \\in \\{(C,P),(C,R),(P,C),(P,R),(R,C),(R,P)\\}$，设 $k_{ij} \\ge 0$ 表示从区域 $i$ 到区域 $j$ 的人均转换速率。假设对于所有这些对都有 $k_{ij}  0$，因此该链是各态遍历的。\n\n仅使用细胞数量守恒和一阶动力学，完成以下任务。\n\n1. 为区域层面的动力学构建一个最小状态转换模型，并写出描述 $C(t)$、$P(t)$ 和 $R(t)$ 的常微分方程组 (ODEs)。\n2. 在上述假设和 $N = C(t) + P(t) + R(t)$ 为常数的条件下，定义稳态比例 $f_C = C^{\\ast}/N$，$f_P = P^{\\ast}/N$ 和 $f_R = R^{\\ast}/N$，其中 $(C^{\\ast},P^{\\ast},R^{\\ast})$ 满足稳态条件。推导出用六个速率常数 $k_{CP}$、$k_{CR}$、$k_{PC}$、$k_{PR}$、$k_{RC}$ 和 $k_{RP}$ 表示的 $f_C$ 的闭式表达式。\n\n你的最终答案必须是一个用速率常数表示的 $f_C$ 的单一闭式代数表达式。不需要进行数值计算，且最终答案中不应包含单位。", "solution": "首先将对问题陈述进行严格的验证。\n\n### 步骤 1：提取已知条件\n问题陈述中明确给出的已知条件如下：\n-   中央区、周边区和髓肋分生组织的细胞群体分别用 $C(t)$、$P(t)$ 和 $R(t)$ 表示。\n-   分生组织细胞总数 $N = C(t) + P(t) + R(t)$ 是守恒的，并且随时间保持不变。\n-   动力学由连续时间的一阶转换建模。\n-   从区域 $i$ 到区域 $j$ 的人均转换速率是一个常数，用 $k_{ij}$ 表示，其中 $(i,j) \\in \\{(C,P), (C,R), (P,C), (P,R), (R,C), (R,P)\\}$。\n-   所有速率常数均为正值：$k_{ij}  0$。\n-   稳态细胞比例定义为 $f_C = C^{\\ast}/N$、$f_P = P^{\\ast}/N$ 和 $f_R = R^{\\ast}/N$，其中 $(C^{\\ast}, P^{\\ast}, R^{\\ast})$ 代表稳态细胞数量。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题的有效性进行评估：\n-   **科学依据**：该问题使用具有一阶动力学的区室模型来描述细胞群体动力学。这是数学生物学和系统生物学中用于模拟不同群体之间相互作用的标准且成熟的方法。其生物学背景，即茎端分生组织的结构，是发育生物学中的一个有效研究课题。该模型是一种简化，但在科学上是合理的。\n-   **适定性**：该问题要求推导一个常微分方程组及其稳态解。一阶动力学的假设导致一个线性常微分方程组。所有 $k_{ij}  0$ 的条件确保了底层的马尔可夫链是各态遍历的，这保证了唯一、非平凡且稳定的稳态解的存在。因此，该问题在数学上是适定的。\n-   **客观性**：该问题使用精确的数学语言陈述，没有歧义或主观论断。\n\n该问题不违反任何无效标准。它是一个科学上合理、适定、客观且可形式化的问题，与其陈述的主题直接相关。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供解答。\n\n### 解答推导\n\n**第一部分：状态转换模型和常微分方程组**\n\n细胞群体的动力学由三个区域之间的通量平衡决定。对于每个区域，其细胞数量的变化率等于从其他区域流入的速率之和减去流出到其他区域的速率之和。根据一阶动力学原理，从区域 $i$ 到区域 $j$ 的通量由人均速率 $k_{ij}$ 与源区域 $i(t)$ 中的细胞数量的乘积给出。\n\n常微分方程组 (ODEs) 构建如下：\n\n对于中央区 $C(t)$：\n流入来自周边区 $P(t)$（速率为 $k_{PC}P(t)$）和髓肋分生组织 $R(t)$（速率为 $k_{RC}R(t)$）。\n流出到周边区（速率为 $k_{CP}C(t)$）和髓肋分生组织（速率为 $k_{CR}C(t)$）。\n因此，$C(t)$ 的微分方程为：\n$$ \\frac{dC}{dt} = k_{PC}P(t) + k_{RC}R(t) - (k_{CP} + k_{CR})C(t) $$\n\n对于周边区 $P(t)$：\n流入来自 $C(t)$（速率为 $k_{CP}C(t)$）和 $R(t)$（速率为 $k_{RP}R(t)$）。\n流出到 $C(t)$（速率为 $k_{PC}P(t)$）和 $R(t)$（速率为 $k_{PR}P(t)$）。\n因此，$P(t)$ 的微分方程为：\n$$ \\frac{dP}{dt} = k_{CP}C(t) + k_{RP}R(t) - (k_{PC} + k_{PR})P(t) $$\n\n对于髓肋分生组织 $R(t)$：\n流入来自 $C(t)$（速率为 $k_{CR}C(t)$）和 $P(t)$（速率为 $k_{PR}P(t)$）。\n流出到 $C(t)$（速率为 $k_{RC}R(t)$）和 $P(t)$（速率为 $k_{RP}R(t)$）。\n因此，$R(t)$ 的微分方程为：\n$$ \\frac{dR}{dt} = k_{CR}C(t) + k_{PR}P(t) - (k_{RC} + k_{RP})R(t) $$\n\n我们通过将三个常微分方程相加来验证细胞总数 $N = C(t) + P(t) + R(t)$ 是守恒的：\n$$ \\frac{dN}{dt} = \\frac{dC}{dt} + \\frac{dP}{dt} + \\frac{dR}{dt} = 0 $$\n右侧所有项的总和确实为零，证实了 $N$ 的守恒性。\n\n**第二部分：稳态比例 $f_C$**\n\n在稳态时，细胞数量是恒定的，因此时间导数为零：$\\frac{dC}{dt} = 0$，$\\frac{dP}{dt} = 0$，$\\frac{dR}{dt} = 0$。设稳态细胞数量为 $C^{\\ast}$、$P^{\\ast}$ 和 $R^{\\ast}$。常微分方程组变成一个线性代数方程组：\n$$ (1) \\quad k_{PC}P^{\\ast} + k_{RC}R^{\\ast} - (k_{CP} + k_{CR})C^{\\ast} = 0 $$\n$$ (2) \\quad k_{CP}C^{\\ast} + k_{RP}R^{\\ast} - (k_{PC} + k_{PR})P^{\\ast} = 0 $$\n$$ (3) \\quad k_{CR}C^{\\ast} + k_{PR}P^{\\ast} - (k_{RC} + k_{RP})R^{\\ast} = 0 $$\n\n我们通过除以细胞总数 $N$ 将其转换为比例，使用 $f_C = C^{\\ast}/N$，$f_P = P^{\\ast}/N$ 和 $f_R = R^{\\ast}/N$。该方程组变为：\n$$ (1') \\quad k_{PC}f_P + k_{RC}f_R - (k_{CP} + k_{CR})f_C = 0 $$\n$$ (2') \\quad k_{CP}f_C + k_{RP}f_R - (k_{PC} + k_{PR})f_P = 0 $$\n$$ (3') \\quad k_{CR}f_C + k_{PR}f_P - (k_{RC} + k_{RP})f_R = 0 $$\n这三个方程是线性相关的。我们使用其中任意两个，以及守恒方程：\n$$ (4') \\quad f_C + f_P + f_R = 1 $$\n\n我们的目标是用 $f_C$ 来表示 $f_P$ 和 $f_R$。我们重新整理方程 $(1')$ 和 $(3')$：\n$$ k_{PC}f_P + k_{RC}f_R = (k_{CP} + k_{CR})f_C $$\n$$ k_{PR}f_P - (k_{RC} + k_{RP})f_R = -k_{CR}f_C $$\n这是一个关于 $f_P$ 和 $f_R$ 的 $2 \\times 2$ 线性方程组。我们使用克莱姆法则求解。系数矩阵的行列式为：\n$$ \\Delta = \\det \\begin{pmatrix} k_{PC}  k_{RC} \\\\ k_{PR}  -(k_{RC}+k_{RP}) \\end{pmatrix} = -k_{PC}(k_{RC}+k_{RP}) - k_{PR}k_{RC} = -(k_{PC}k_{RC} + k_{PC}k_{RP} + k_{PR}k_{RC}) $$\n让我们定义 $\\mathcal{T}_C = k_{PC}k_{RC} + k_{PC}k_{RP} + k_{PR}k_{RC}$。那么 $\\Delta = -\\mathcal{T}_C$。\n\n求解 $f_P$：\n$$ f_P = \\frac{1}{\\Delta} \\det \\begin{pmatrix} (k_{CP} + k_{CR})f_C  k_{RC} \\\\ -k_{CR}f_C  -(k_{RC}+k_{RP}) \\end{pmatrix} = \\frac{f_C}{\\Delta} [-(k_{CP} + k_{CR})(k_{RC}+k_{RP}) + k_{CR}k_{RC}] $$\n$$ f_P = -\\frac{f_C}{\\Delta} [k_{CP}k_{RC} + k_{CP}k_{RP} + k_{CR}k_{RC} + k_{CR}k_{RP} - k_{CR}k_{RC}] = -\\frac{f_C}{\\Delta} [k_{CP}k_{RC} + k_{CP}k_{RP} + k_{CR}k_{RP}] $$\n设 $\\mathcal{T}_P = k_{CP}k_{RC} + k_{CP}k_{RP} + k_{CR}k_{RP}$。那么 $f_P = -\\frac{f_C \\mathcal{T}_P}{\\Delta} = f_C \\frac{\\mathcal{T}_P}{\\mathcal{T}_C}$。\n\n求解 $f_R$：\n$$ f_R = \\frac{1}{\\Delta} \\det \\begin{pmatrix} k_{PC}  (k_{CP} + k_{CR})f_C \\\\ k_{PR}  -k_{CR}f_C \\end{pmatrix} = \\frac{f_C}{\\Delta} [-k_{PC}k_{CR} - k_{PR}(k_{CP} + k_{CR})] $$\n$$ f_R = -\\frac{f_C}{\\Delta} [k_{PC}k_{CR} + k_{PR}k_{CP} + k_{PR}k_{CR}] $$\n设 $\\mathcal{T}_R = k_{PC}k_{CR} + k_{PR}k_{CP} + k_{PR}k_{CR}$。那么 $f_R = -\\frac{f_C \\mathcal{T}_R}{\\Delta} = f_C \\frac{\\mathcal{T}_R}{\\mathcal{T}_C}$。\n\n现在，将 $f_P$ 和 $f_R$ 的这些表达式代入守恒方程 $(4')$：\n$$ f_C + f_C \\frac{\\mathcal{T}_P}{\\mathcal{T}_C} + f_C \\frac{\\mathcal{T}_R}{\\mathcal{T}_C} = 1 $$\n提出因子 $f_C$：\n$$ f_C \\left( 1 + \\frac{\\mathcal{T}_P}{\\mathcal{T}_C} + \\frac{\\mathcal{T}_R}{\\mathcal{T}_C} \\right) = 1 $$\n$$ f_C \\left( \\frac{\\mathcal{T}_C + \\mathcal{T}_P + \\mathcal{T}_R}{\\mathcal{T}_C} \\right) = 1 $$\n求解 $f_C$ 得到所需的表达式：\n$$ f_C = \\frac{\\mathcal{T}_C}{\\mathcal{T}_C + \\mathcal{T}_P + \\mathcal{T}_R} $$\n代入 $\\mathcal{T}_C$、$\\mathcal{T}_P$ 和 $\\mathcal{T}_R$ 的完整表达式：\n分子是 $\\mathcal{T}_C = k_{PC}k_{RC} + k_{PC}k_{RP} + k_{PR}k_{RC}$。\n分母是总和 $\\mathcal{T}_C + \\mathcal{T}_P + \\mathcal{T}_R$：\n$$ (k_{PC}k_{RC} + k_{PC}k_{RP} + k_{PR}k_{RC}) + (k_{CP}k_{RC} + k_{CP}k_{RP} + k_{CR}k_{RP}) + (k_{PC}k_{CR} + k_{PR}k_{CP} + k_{PR}k_{CR}) $$\n$f_C$ 的完整表达式即为这个比值。", "answer": "$$\n\\boxed{\\frac{k_{PC}k_{RC} + k_{PC}k_{RP} + k_{PR}k_{RC}}{k_{PC}k_{RC} + k_{PC}k_{RP} + k_{PR}k_{RC} + k_{CP}k_{RC} + k_{CP}k_{RP} + k_{CR}k_{RP} + k_{PC}k_{CR} + k_{CP}k_{PR} + k_{CR}k_{PR}}}\n$$", "id": "2671831"}, {"introduction": "叶序，即叶和花的规则排列，是生物自组织的一个经典范例。为了理解这种复杂模式是如何产生的，我们可以构建计算模型来模拟其潜在的分子和细胞相互作用。在这个高级练习 ([@problem_id:2671825]) 中，您将从第一性原理出发，构建并实现一个生长素耗竭模型，探索生长素的积累、扩散以及来自旧原基的抑制场如何相互作用，从而动态地决定新器官的精确定位。", "problem": "你需要构建并模拟一个第一性原理的、离散时间、离散空间的生长素耗尽模型，该模型应用于位于茎顶分生组织（SAM; Shoot Apical Meristem）侧翼的一圈表皮细胞。你的目标是确定，在来自较老原基的抑制随时间衰减后，局部生长素浓度超过一个固定阈值时，新的原基何时何地会启动。最终输出必须由程序进行数值计算，并以要求的格式精确报告。\n\n用于推导离散更新规则的建模基础和约束条件：\n- 空间域和变量：\n  - 考虑一个由 $N$ 个细胞组成的环，索引为 $i \\in \\{0,1,\\dots,N-1\\}$，具有周期性边界条件，因此索引以 $N$ 为模进行环绕。\n  - 设 $a_i(t)$ 表示在离散时间 $t \\in \\mathbb{N}$ 时细胞 $i$ 中的生长素浓度，以任意单位（a.u.）表示。\n- 每个时间步的基本质量平衡结构：\n  - 相邻交换是守恒的，并且线性依赖于最近邻的浓度差，因此净相邻交换是一个系数为 $D$ 的离散扩散（最近邻拉普拉斯算子），其贡献为 $D \\cdot (a_{i-1}(t) - 2 a_i(t) + a_{i+1}(t))$。\n  - 每个时间步中，每个细胞都有一个均匀的向内输入通量 $I_0$，同时有一个线性清除项 $-\\lambda \\, a_i(t)$ 与之抗衡，其中 $\\lambda$ 是每步的清除率。$I_0$ 和 $\\lambda$ 都是非负的。\n  - 已有的原基施加一个抑制场，该场同时减少局部输入并增加局部有效清除。设细胞 $i$ 在时间 $t$ 的抑制场为 $S_i(t) \\ge 0$。输入项按 $S_i(t)$ 的线性因子减少，并在零输入处进行校正；清除项则按 $S_i(t)$ 线性增加。具体来说，输入项为 $\\max\\{ I_0 \\cdot (1 - \\alpha \\, S_i(t)), 0 \\}$，其中敏感度为 $\\alpha \\ge 0$；由抑制引起的额外清除项为 $-\\beta \\, S_i(t) \\, a_i(t)$，其中 $\\beta \\ge 0$。\n- 来自现有原基的抑制场：\n  - 维护一个原基集合 $\\mathcal{P}(t)$，其中每个原基 $p \\in \\mathcal{P}(t)$ 有一个位置索引 $j_p \\in \\{0,1,\\dots,N-1\\}$ 和一个年龄 $\\tau_p(t) \\in \\mathbb{N}$（以时间步为单位）。\n  - 细胞 $i$ 和原基 $p$ 之间沿环的距离是最小环绕索引距离 $d(i,j_p) = \\min\\{|i - j_p|, N - |i - j_p|\\}$。\n  - 单个原基贡献的场是在索引空间中的一个高斯核，其年龄呈指数衰减，所有原基的贡献相加得到总的场：\n    $$S_i(t) \\;=\\; \\sum_{p \\in \\mathcal{P}(t)} A_0 \\, \\exp\\!\\Big(-\\frac{\\tau_p(t)}{\\tau}\\Big)\\, \\exp\\!\\Big(-\\frac{d(i,j_p)^2}{2 \\sigma^2}\\Big),$$\n    其中基线振幅 $A_0 \\ge 0$，年龄衰减常数 $\\tau  0$，空间宽度参数 $\\sigma  0$（单位为细胞数）。\n- 离散时间更新和约束：\n  - 推导一个与上述质量平衡分量一致的单步显式更新规则。你的更新必须是以下形式：\n    $$a_i(t+1) \\;=\\; a_i(t) \\;+\\; \\text{扩散}(i,t) \\;+\\; \\text{输入}(i,t) \\;-\\; \\text{清除}(i,t) \\;-\\; \\text{抑制汇}(i,t),$$\n    其中各项分量由上述约束指定，并且在显式组合后必须简化为 $a_i(t+1) = a_i(t) + D \\cdot (a_{i-1}(t) - 2 a_i(t) + a_{i+1}(t)) + \\max\\{ I_0 \\cdot (1 - \\alpha \\, S_i(t)), 0 \\} - \\lambda \\, a_i(t) - \\beta \\, S_i(t) \\, a_i(t)$。如果需要，通过在零处截断来强制生长素的非负性。\n- 每个时间步的原基起始规则：\n  - 一个细胞 $i$ 在时间 $t$ 启动一个新原基，当且仅当以下所有条件都成立：\n    1) $a_i(t)$ 严格超过一个固定阈值 $\\theta$（即 $a_i(t)  \\theta$），\n    2) $i$ 是相对于其在环上直接相邻细胞的严格局部最大值，即 $a_i(t)  a_{i-1}(t)$ 且 $a_i(t)  a_{i+1}(t)$，\n    3) $i$ 与 $\\mathcal{P}(t)$ 中的每个原基的距离至少为整数排斥半径 $r$，即对于所有 $p \\in \\mathcal{P}(t)$ 都有 $d(i,j_p) \\ge r$。\n  - 当多个候选者在同一时间步满足这些条件，并且它们彼此之间的距离小于排斥半径 $r$ 时，通过按 $a_i(t)$ 降序的方式选择一个最大兼容子集，贪婪地接受一个候选者，前提是它与该步中所有已接受的候选者保持至少 $r$ 的距离。若 $a_i(t)$ 出现平局，则优先选择较小的索引。\n  - 对于每个在索引 $i$ 处被接受的起始事件，在位置 $i$ 向 $\\mathcal{P}(t)$ 添加一个年龄为 $0$ 的新原基，并立即在该索引处应用分数生长素重置 $a_i(t) \\leftarrow \\rho \\, a_i(t)$（其中 $0 \\le \\rho  1$），以模拟起始时的快速局部耗尽。然后，在进入时间 $t+1$ 时，所有原基的年龄增加一。\n\n实现、模拟时限和输出规格：\n- 所有模拟使用无量纲时间步 $t \\in \\{0,1,\\dots,T-1\\}$，其中 $T$ 根据每个测试用例指定。所有与生长素相关的量均以任意单位（a.u.）表示。距离和 $\\sigma$ 的单位为细胞数。索引必须是整数。\n- 初始化：除非另有说明，将 $a_i(0)$ 统一初始化为给定的标量 $a_{\\text{init}}$。使用提供的原基索引及其对应的初始年龄列表来初始化 $\\mathcal{P}(0)$。\n- 你的程序必须为每个测试用例在指定的步数内模拟系统，并记录每个测试用例中新原基启动的索引（整数）列表，按其启动时间的先后顺序排列；如果在同一时间步有多个原基启动，则在应用上述贪婪选择规则后，按索引升序排列。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应一个测试用例的已启动索引列表，该列表本身也用方括号括起来，元素之间用逗号分隔，不含空格。例如，一个包含三个测试用例的有效输出形如 \"[[1,5],[3],[]]\"；如果某个测试用例没有发生起始事件，则打印一个空列表 \"[]\"。你的程序必须只打印这一行。\n\n测试套件：\n模拟以下四组参数。对于所有情况，报告新启动原基的索引列表（整数），按上述定义的时间顺序排列。\n\n- 情况 A（正常情况，预期有新原基产生）：\n  - $N = 60$, $T = 80$, $D = 0.2$, $I_0 = 0.06$, $\\lambda = 0.05$, $\\alpha = 0.8$, $\\beta = 0.2$, $A_0 = 1.0$, $\\tau = 20.0$, $\\sigma = 4.0$, $\\theta = 0.95$, $r = 5$, $\\rho = 0.2$, $a_{\\text{init}} = 0.1$。\n  - 初始原基：索引 $[0, 22, 44]$，对应的初始年龄为 $[40, 25, 10]$。\n- 情况 B（边界阈值等于稳态输入/清除比；预期无起始事件，因为 $a_i(t)$ 接近但不会超过稳态水平）：\n  - 与情况 A 相同，除了 $\\theta = 1.2$ 和 $T = 200$。\n  - 注意：远离抑制区域的输入/清除稳态水平为 $I_0 / \\lambda = 1.2$。\n- 情况 C（强而广泛的抑制在全球范围内抑制了输入；预期无起始事件）：\n  - $N = 60$, $T = 120$, $D = 0.2$, $I_0 = 0.06$, $\\lambda = 0.05$, $\\alpha = 1.0$, $\\beta = 0.3$, $A_0 = 1.0$, $\\tau = 200.0$, $\\sigma = 12.0$, $\\theta = 0.8$, $r = 5$, $\\rho = 0.2$, $a_{\\text{init}} = 0.1$。\n  - 初始原基：索引 $[0, 20, 40]$，对应的初始年龄为 $[0, 0, 0]$。\n- 情况 D（排斥半径覆盖了整个小环；由于几何限制，不可能有起始事件）：\n  - $N = 6$, $T = 100$, $D = 0.2$, $I_0 = 0.06$, $\\lambda = 0.05$, $\\alpha = 0.8$, $\\beta = 0.2$, $A_0 = 1.0$, $\\tau = 20.0$, $\\sigma = 2.0$, $\\theta = 0.6$, $r = 3$, $\\rho = 0.2$, $a_{\\text{init}} = 0.1$。\n  - 初始原基：索引 $[0, 3]$，对应的初始年龄为 $[10, 10]$。\n\n不使用角度单位。所有报告的结果都是整数（索引）和整数列表。不涉及百分比。\n\n你的程序必须实现上述规则，并精确生成一行输出：一个包含四个按测试用例排列的起始索引列表的单一括号列表，整行没有任何空格。", "solution": "所呈现的问题是要求构建并模拟一个离散时间、离散空间的数学模型，用于描述植物茎顶分生组织（SAM）中原基（如叶或花）形成的叶序现象。该模型基于植物激素生长素的动力学。在着手解决之前，需要对问题陈述进行严格的验证。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n该系统由以下部分定义：\n- **域**：一个由 $N$ 个细胞组成的环，索引为 $i \\in \\{0, 1, \\dots, N-1\\}$，具有周期性边界。\n- **状态变量**：细胞 $i$ 在时间步 $t$ 的生长素浓度 $a_i(t)$。\n- **更新规则**：生长素浓度的变化由显式前向欧拉离散化给出：\n$$a_i(t+1) = a_i(t) + \\Delta a_i(t),$$\n其中总变化量 $\\Delta a_i(t)$ 是几个项的总和：\n$$ \\Delta a_i(t) = \\underbrace{D (a_{i-1}(t) - 2 a_i(t) + a_{i+1}(t))}_{\\text{扩散}} + \\underbrace{\\max\\{ I_0 (1 - \\alpha S_i(t)), 0 \\}}_{\\text{抑制性输入}} \\underbrace{- \\lambda a_i(t)}_{\\text{清除}} \\underbrace{- \\beta S_i(t) a_i(t)}_{\\text{抑制汇}}。 $$\n- **非负性**：如果计算出的 $a_i(t+1)$ 值为负，则将其截断为 $0$。\n- **抑制场**：细胞 $i$ 处的场 $S_i(t)$ 是集合 $\\mathcal{P}(t)$ 中所有现有原基 $p$ 贡献的总和：\n$$ S_i(t) = \\sum_{p \\in \\mathcal{P}(t)} A_0 \\exp\\Big(-\\frac{\\tau_p(t)}{\\tau}\\Big) \\exp\\Big(-\\frac{d(i,j_p)^2}{2 \\sigma^2}\\Big), $$\n其中 $j_p$ 是原基 $p$ 的位置，$\\tau_p(t)$ 是其年龄。距离 $d(i, j_p)$ 是环上最短的环绕距离：$d(i,j_p) = \\min\\{|i - j_p|, N - |i - j_p|\\}$。\n- **参数**：$N, T, D, I_0, \\lambda, \\alpha, \\beta, A_0, \\tau, \\sigma, \\theta, r, \\rho, a_{\\text{init}}$。\n- **初始条件**：对于所有 $i$，$a_i(0) = a_{\\text{init}}$。初始原基集合 $\\mathcal{P}(0)$ 及其位置和年龄均已给出。\n- **原基起始条件**：当且仅当以下条件成立时，细胞 $i$ 在时间 $t$ 形成一个新原基：\n    1. $a_i(t)  \\theta$ (阈值)。\n    2. $a_i(t)  a_{i-1}(t)$ 且 $a_i(t)  a_{i+1}(t)$ (局部最大值)。\n    3. 对于所有 $p \\in \\mathcal{P}(t)$，$d(i, j_p) \\ge r$ (排斥半径)。\n- **多重起始的冲突解决**：如果多个细胞满足标准，则按 $a_i(t)$ 降序（主键）和索引 $i$ 升序（平局决胜）排序。一个贪婪选择过程从此列表中接受候选者，确保每个新的起始位点与*同一时间步内*所有先前接受的位点至少相距 $r$。\n- **起始后事件**：对于每个在索引 $i$ 处的新原基：\n    1. 将其以年龄 $0$ 添加到原基集合中。\n    2. 局部生长素被重置：$a_i(t) \\leftarrow \\rho \\, a_i(t)$。此重置值用于计算下一个时间步 $a_j(t+1)$。\n- **时间演化**：在每个时间步结束时，所有原基的年龄增加 $1$。\n- **输出**：一个列表的列表，其中每个内部列表包含给定测试用例中新启动原基的索引，按时间顺序排列，然后按索引排列。\n\n**步骤2：使用提取的给定条件进行验证**\n\n根据既定的验证标准对问题进行评估：\n- **科学依据**：该模型是一种反应扩散系统，这是理论生物学中解释模式形成的经典而强大的框架。具体的机制——生长素的运输、积累以及来自现有结构的抑制——是公认的叶序理论的核心。数学表述（离散拉普拉斯算子、指数衰减、高斯核）是标准且恰当的。该问题具有科学合理性。\n- **良构性**：该问题是确定性的。所有参数、初始条件和演化规则都得到了明确的规定。处理多个同时起始事件的程序，包括排序和贪婪选择，确保了唯一的结果。该系统是良构的。\n- **客观性**：问题陈述使用精确、客观和数学化的语言编写。没有主观或基于意见的元素。\n- **完整性和一致性**：为每个测试用例提供了所有必要的参数和初始条件。规则内部一致。一个时间步内的操作顺序是合乎逻辑的：基于当前状态检查起始，解决冲突，更新状态（生长素重置和原基列表），然后计算下一个状态。\n- **可行性**：该模型是一个直接的数值模拟。选择扩散系数 $D=0.2$，有效时间步长 $\\Delta t=1$，空间步长 $\\Delta x=1$，满足显式扩散格式的 Courant-Friedrichs-Lewy (CFL) 条件（$D \\Delta t / (\\Delta x)^2 \\le 0.5$），这表明数值是稳定的。测试用例设计良好，旨在探测模型行为的不同区域。\n\n**步骤3：结论与行动**\n\n此问题是**有效的**。它是一个定义明确、科学相关且在数值上易于处理的计算发育生物学问题。因此，我将着手构建解决方案。\n\n### 解法推导与实现策略\n\n解决方案需要根据指定的规则实现一个离散时间模拟。实现的核心将是一个从 $t=0$ 到 $T-1$ 的时间迭代循环。在每个时间步内，必须精确地按规定顺序执行以下操作。\n\n**算法大纲：**\n\n1.  **初始化**：\n    - 初始化一个大小为 $N$ 的生长素浓度数组 `a`，其值为 $a_{\\text{init}}$。\n    - 根据给定的初始位置和年龄，初始化原基列表 `primordia`。每个原基将存储为一个元组 `(position, age)`。\n    - 初始化一个空列表 `all_new_primordia_indices`，用于收集结果。\n\n2.  **时间步循环**（$t$ 从 $0$ 到 $T-1$）：\n    a.  **计算抑制场 $S(t)$**：\n        - 创建一个大小为 $N$ 的零数组 `S`。\n        - 对于当前 `primordia` 列表中的每个原基 $(j_p, \\tau_p)$：\n            - 计算与年龄相关的振幅：$A_p = A_0 \\exp(-\\tau_p / \\tau)$。\n            - 对于每个细胞 $i \\in \\{0, \\dots, N-1\\}$：\n                - 计算周期性距离 $d(i, j_p)$。\n                - 将贡献加到抑制场中：$S[i] \\leftarrow S[i] + A_p \\exp(-d(i, j_p)^2 / (2\\sigma^2))$。\n\n    b.  **识别起始候选者**：\n        - 创建一个空列表 `candidates`。\n        - 对于每个细胞 $i \\in \\{0, \\dots, N-1\\}$：\n            - 检查三个起始条件：\n                i.  $a_i(t)  \\theta$。\n                ii. $a_i(t)  a_{i-1}(t)$ 且 $a_i(t)  a_{i+1}(t)$（使用周期性索引）。\n                iii. 对于所有原基 $(j_p, \\tau_p)$，$d(i, j_p) \\ge r$。\n            - 如果所有条件都满足，将元组 `(a[i], i)` 添加到 `candidates` 中。\n\n    c.  **选择新原基（贪婪选择）**：\n        - 按生长素浓度降序、索引升序（作为决胜局）对 `candidates` 进行排序。\n        - 创建一个空列表 `new_primordia_this_step`，用于存储当前时间步启动的原基索引。\n        - 遍历排序后的 `candidates`：对于每个候选者 $(a_{\\text{cand}}, i_{\\text{cand}})$：\n            - 检查 $i_{\\text{cand}}$ 与 `new_primordia_this_step` 中所有已存在的索引是否至少相距 $r$。\n            - 如果兼容，则将 $i_{\\text{cand}}$ 添加到 `new_primordia_this_step` 中。\n        - 按索引升序对 `new_primordia_this_step` 进行排序，并将其元素追加到 `all_new_primordia_indices` 中。\n\n    d.  **为下一时间步更新状态**：\n        - 创建当前生长素数组 `a` 的一个副本，称之为 `a_update`，用于计算。这保留了原始的 `a(t)` 用于更新规则的计算，同时允许局部重置。\n        - 对于 `new_primordia_this_step` 中的每个新启动的原基索引 $i$：\n            - 应用生长素重置：$a_{\\text{update}}[i] \\leftarrow \\rho \\cdot a_{\\text{update}}[i]$。\n        - 为时间 $t+1$ 创建一个新的原基列表 `next_primordia`。\n        - 将新形成的原基（年龄为 $0$）添加到 `next_primordia` 中。\n        - 将 `primordia` 列表中的所有现有原基添加到 `next_primordia` 中，并将其年龄增加 $1$。\n        - 用 `next_primordia` 替换旧的 `primordia` 列表。\n\n    e.  **计算 $t+1$ 的生长素浓度**：\n        - 创建一个大小为 $N$ 的新数组 `a_next`。\n        - 对于每个细胞 $i \\in \\{0, \\dots, N-1\\}$：\n            - 使用 `a_update` 中的值计算离散拉普拉斯算子（扩散项）。\n            - 使用 `a_update` 和场 `S` 中的值计算输入、清除和抑制汇项。\n            - 根据更新规则将所有项相加，得到 $a_{\\text{next}}[i]$。\n        - 应用非负性约束：$a \\leftarrow \\max(a_{\\text{next}}, 0)$。\n\n3.  **最终处理**：\n    - 循环完成后，返回 `all_new_primordia_indices`。\n\n该算法将使用 Python 的 `numpy` 库实现，以进行高效的数组操作，这对模拟的性能至关重要。最终程序将封装此逻辑，并将其应用于四个提供的测试用例，按要求格式化输出字符串。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, T, D, I0, lambda_, alpha, beta, A0, tau, sigma, theta, r, rho, a_init, initial_primordia_spec):\n    \"\"\"\n    Simulates the auxin-depletion model for one test case.\n    \"\"\"\n    # Initialize state variables\n    a = np.full(N, a_init, dtype=float)\n    primordia = [(pos, age) for pos, age in initial_primordia_spec]\n    all_new_primordia_indices = []\n\n    # Pre-calculate indices for periodic boundary conditions\n    indices = np.arange(N)\n    indices_prev = np.roll(indices, 1)\n    indices_next = np.roll(indices, -1)\n    \n    # Main simulation loop\n    for t in range(T):\n        # 1. Calculate Inhibition Field S(t)\n        S = np.zeros(N, dtype=float)\n        if primordia:\n            for p_pos, p_age in primordia:\n                age_decay = np.exp(-p_age / tau)\n                amp = A0 * age_decay\n                \n                # Calculate distances for all cells to the current primordium\n                abs_diff = np.abs(indices - p_pos)\n                distances = np.minimum(abs_diff, N - abs_diff)\n                \n                # Add Gaussian contribution to the inhibition field\n                S += amp * np.exp(-distances**2 / (2 * sigma**2))\n\n        # 2. Identify Initiation Candidates\n        candidates = []\n        for i in range(N):\n            # Condition 1: Threshold\n            if a[i] = theta:\n                continue\n\n            # Condition 2: Local Maximum\n            if not (a[i]  a[indices_prev[i]] and a[i]  a[indices_next[i]]):\n                continue\n            \n            # Condition 3: Exclusion Radius\n            is_excluded = False\n            if primordia:\n                for p_pos, _ in primordia:\n                    dist = min(abs(i - p_pos), N - abs(i - p_pos))\n                    if dist  r:\n                        is_excluded = True\n                        break\n            if is_excluded:\n                continue\n\n            candidates.append((a[i], i))\n\n        # 3. Select New Primordia (Greedy Selection)\n        new_primordia_this_step = []\n        if candidates:\n            # Sort by descending auxin, ascending index\n            candidates.sort(key=lambda x: (-x[0], x[1]))\n            \n            for _, cand_idx in candidates:\n                is_compatible = True\n                for accepted_idx in new_primordia_this_step:\n                    dist = min(abs(cand_idx - accepted_idx), N - abs(cand_idx - accepted_idx))\n                    if dist  r:\n                        is_compatible = False\n                        break\n                if is_compatible:\n                    new_primordia_this_step.append(cand_idx)\n\n        # Record new primordia if any\n        if new_primordia_this_step:\n            new_primordia_this_step.sort()\n            all_new_primordia_indices.extend(new_primordia_this_step)\n\n        # 4. Prepare for State Update\n        a_update = a.copy()\n\n        # Apply auxin reset for new primordia\n        if new_primordia_this_step:\n            for i in new_primordia_this_step:\n                a_update[i] *= rho\n        \n        # Update primordia list for the next step (t+1)\n        next_primordia = []\n        # Add new primordia with age 0\n        for i in new_primordia_this_step:\n            next_primordia.append((i, 0))\n        # Increment age of existing primordia\n        for p_pos, p_age in primordia:\n            next_primordia.append((p_pos, p_age + 1))\n        primordia = next_primordia\n\n        # 5. Compute Auxin Concentrations for t+1\n        # Get neighbor values from the (potentially reset) a_update array\n        a_prev_vals = a_update[indices_prev]\n        a_next_vals = a_update[indices_next]\n        \n        # Vectorized calculation of the update rule\n        diffusion = D * (a_prev_vals - 2 * a_update + a_next_vals)\n        import_term = np.maximum(0, I0 * (1 - alpha * S))\n        clearance = lambda_ * a_update\n        inhibitory_sink = beta * S * a_update\n        \n        a_next = a_update + diffusion + import_term - clearance - inhibitory_sink\n        \n        # Apply non-negativity constraint and update state\n        a = np.maximum(0, a_next)\n\n    return all_new_primordia_indices\n\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'N': 60, 'T': 80, 'D': 0.2, 'I0': 0.06, 'lambda_': 0.05, 'alpha': 0.8, 'beta': 0.2, 'A0': 1.0, 'tau': 20.0, 'sigma': 4.0, 'theta': 0.95, 'r': 5, 'rho': 0.2, 'a_init': 0.1, 'initial_primordia_spec': [(0, 40), (22, 25), (44, 10)]},\n        # Case B\n        {'N': 60, 'T': 200, 'D': 0.2, 'I0': 0.06, 'lambda_': 0.05, 'alpha': 0.8, 'beta': 0.2, 'A0': 1.0, 'tau': 20.0, 'sigma': 4.0, 'theta': 1.2, 'r': 5, 'rho': 0.2, 'a_init': 0.1, 'initial_primordia_spec': [(0, 40), (22, 25), (44, 10)]},\n        # Case C\n        {'N': 60, 'T': 120, 'D': 0.2, 'I0': 0.06, 'lambda_': 0.05, 'alpha': 1.0, 'beta': 0.3, 'A0': 1.0, 'tau': 200.0, 'sigma': 12.0, 'theta': 0.8, 'r': 5, 'rho': 0.2, 'a_init': 0.1, 'initial_primordia_spec': [(0, 0), (20, 0), (40, 0)]},\n        # Case D\n        {'N': 6, 'T': 100, 'D': 0.2, 'I0': 0.06, 'lambda_': 0.05, 'alpha': 0.8, 'beta': 0.2, 'A0': 1.0, 'tau': 20.0, 'sigma': 2.0, 'theta': 0.6, 'r': 3, 'rho': 0.2, 'a_init': 0.1, 'initial_primordia_spec': [(0, 10), (3, 10)]},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        results.append(str(result).replace(\" \", \"\"))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2671825"}]}