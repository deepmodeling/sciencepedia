{"hands_on_practices": [{"introduction": "在任何单细胞转录组学分析中，第一步也是最关键的一步是质量控制（QC）。这个练习将指导你实施一套标准的QC指标，这些指标是评估细胞活力和数据可靠性的关键代理。通过计算和筛选总UMI计数、检测到的基因数量和线粒体基因比例，你将学会如何过滤掉低质量的细胞，这是确保后续谱系和命运分析准确性的基础。[@problem_id:2672354]", "problem": "您的任务是在单细胞水平上对单细胞核糖核酸测序 (scRNA-seq) 的计数数据实施质量控制，以支持谱系和命运分析。您的论证应基于两个基本原则：(i) 分子生物学的中心法则，即信使核糖核酸 (mRNA) 的丰度反映了基因表达；以及 (ii) scRNA-seq 中唯一分子标识符 (UMI) 的设计，UMI 用于对捕获的转录本分子进行计数，从而为每个细胞的每个基因生成非负整数计数。对于每个细胞，您将获得一个针对一组固定基因的非负整数计数向量，以及线粒体基因的索引。质量控制依赖于以下基于成熟实践的定义：总UMI计数、检测到的基因数量、线粒体分数和零值分数。这些指标是细胞活力、复杂性和潜在应激的代理指标，这些因素可能会对谱系和命运重建产生偏倚。\n\n给定一个计数向量 $\\mathbf{x} = (x_1, x_2, \\dots, x_N)$（其中 $x_i \\in \\mathbb{Z}_{\\ge 0}$），一个线粒体基因索引集合 $\\mathcal{M} \\subseteq \\{1,2,\\dots,N\\}$，以及阈值 $c_{\\min}$、$c_{\\max}$、$g_{\\min}$、$f_{\\mathrm{mt},\\max}$、$f_{0,\\max}$ 和 $k_{\\min}$，定义如下：\n- 总UMI计数 $T = \\sum_{i=1}^{N} x_i$。\n- 检测到的基因数量 $G = \\left|\\{ i \\in \\{1,\\dots,N\\} : x_i \\ge k_{\\min} \\}\\right|$。\n- 线粒体分数 $f_{\\mathrm{mt}} = \\begin{cases} \\dfrac{\\sum_{i \\in \\mathcal{M}} x_i}{T},  & \\text{if } T > 0 \\\\ 0,  & \\text{if } T = 0 \\end{cases}$。\n- 零值分数 $f_0 = \\dfrac{\\left|\\{ i \\in \\{1,\\dots,N\\} : x_i = 0 \\}\\right|}{N}$。\n\n一个细胞当且仅当同时满足以下所有条件时，才通过质量控制：\n- $c_{\\min} \\le T \\le c_{\\max}$，\n- $G \\ge g_{\\min}$，\n- $f_{\\mathrm{mt}} \\le f_{\\mathrm{mt},\\max}$，\n- $f_0 \\le f_{0,\\max}$。\n\n所有分数量必须以小数形式表示。为了报告，请将 $f_{\\mathrm{mt}}$ 和 $f_0$ 四舍五入到小数点后四位。\n\n您的程序必须为每个测试用例计算元组 $[T, G, f_{\\mathrm{mt}}, f_0, P]$，其中 $P$ 是一个布尔值，指示细胞是否通过上述定义的质量控制。请严格按照所述使用包含性不等式。如果 $T = 0$，根据上述定义使用 $f_{\\mathrm{mt}} = 0$，并根据相同的规则评估通过/失败。\n\n测试套件：\n使用以下五个测试用例。每个用例提供 $(\\mathbf{x}, \\mathcal{M}, c_{\\min}, c_{\\max}, g_{\\min}, f_{\\mathrm{mt},\\max}, f_{0,\\max}, k_{\\min})$。在输入向量中，$\\mathcal{M}$ 的基因索引约定是基于0的，但请将其一致地解释为 $\\mathbf{x}$ 内的位置。\n\n1. 用例A（正常路径）：\n   - $\\mathbf{x} = [2, 3, 4, 5, 6, 0, 0, 1, 2, 3]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n2. 用例B（在 $c_{\\min}$ 和 $f_{\\mathrm{mt},\\max}$ 处的边界包含性）：\n   - $\\mathbf{x} = [2, 2, 8, 4, 4, 0, 0, 0, 0, 0]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n3. 用例C（因线粒体分数过高而失败）：\n   - $\\mathbf{x} = [10, 0, 4, 4, 4, 4, 0, 2, 1, 1]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n4. 用例D（未检测到分子的边缘情况）：\n   - $\\mathbf{x} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n5. 用例E（在 $c_{\\max}$ 和 $f_{\\mathrm{mt},\\max}$ 处的边界包含性）：\n   - $\\mathbf{x} = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个含五个元素的列表，每个元素对应一个测试用例（按A到E的顺序）。每个元素必须是列表 $[T, G, f_{\\mathrm{mt}}, f_0, P]$，其中 $f_{\\mathrm{mt}}$ 和 $f_0$ 是四舍五入到小数点后四位的小数，$P$ 是一个布尔值。整个输出必须作为单行的Python风格列表打印，例如：\n[[T_A,G_A,fmt_A,f0_A,P_A],[T_B,G_B,fmt_B,f0_B,P_B],...]", "solution": "所提出的问题是一个定义明确且计算上易于处理的任务，是单细胞转录组学数据分析的基础。它在科学上植根于分子生物学和生物信息学质量控制的既定原则。所提供的定义是精确的，约束条件是明确的。因此，该问题是有效的，我们着手进行严谨的求解。\n\n目标是实现一种算法，根据单个细胞的信使核糖核酸 (mRNA) 表达谱对其进行质量控制，这些表达谱通过唯一分子标识符 (UMI) 进行量化。对于每个细胞，我们给定一个计数向量 $\\mathbf{x} = (x_1, x_2, \\dots, x_N)$，其中 $x_i \\in \\mathbb{Z}_{\\ge 0}$ 是基因 $i$ 的UMI计数。我们必须计算四个质量指标，并用它们来确定一个细胞是否通过一组预定义的阈值。\n\n这些指标定义如下：\n1.  总UMI计数, $T$：该指标反映了从一个细胞中捕获的mRNA分子总数。它是细胞大小和测序文库质量的代理指标。极低的 $T$ 值可能表示细胞死亡或捕获失败，而极高的 $T$ 值可能表示一个多细胞体（两个或多个细胞被当作一个捕获）。它计算为所有基因计数的总和：\n    $$T = \\sum_{i=1}^{N} x_i$$\n2.  检测到的基因数量, $G$：该指标代表细胞的转录复杂性。较高的 $G$ 值表明细胞的转录更活跃、更复杂。如果一个基因的计数 $x_i$ 至少为 $k_{\\min}$，我们将其定义为“已检测到”。对于本问题，$k_{\\min} = 1$。该指标是检测到的基因集合的基数：\n    $$G = \\left|\\{ i \\in \\{1,\\dots,N\\} : x_i \\ge k_{\\min} \\}\\right|$$\n3.  线粒体分数, $f_{\\mathrm{mt}}$：这是映射到线粒体基因的总UMI的比例。升高的 $f_{\\mathrm{mt}}$ 是细胞应激或凋亡的常见指标，因为应激细胞的细胞质mRNA往往受损，而线粒体转录本相对丰富。给定一组线粒体基因索引 $\\mathcal{M}$，其计算方式如下：\n    $$f_{\\mathrm{mt}} = \\begin{cases} \\dfrac{\\sum_{i \\in \\mathcal{M}} x_i}{T},  & \\text{if } T > 0 \\\\ 0,  & \\text{if } T = 0 \\end{cases}$$\n4.  零值分数, $f_0$：该指标是观测到计数为零的基因的比例。虽然scRNA-seq数据本身具有稀疏性，但极高的零值分数，特别是与低 $T$ 和 $G$ 值并存时，可能表明细胞质量不佳。其计算方式如下：\n    $$f_0 = \\dfrac{\\left|\\{ i \\in \\{1,\\dots,N\\} : x_i = 0 \\}\\right|}{N}$$\n    其中 $N$ 是向量 $\\mathbf{x}$ 中基因的总数。\n\n一个细胞被认为通过质量控制（用布尔值 $P=\\text{True}$ 表示），当且仅当以下四个条件同时满足：\n-   $c_{\\min} \\le T \\le c_{\\max}$\n-   $G \\ge g_{\\min}$\n-   $f_{\\mathrm{mt}} \\le f_{\\mathrm{mt},\\max}$\n-   $f_0 \\le f_{0,\\max}$\n\n现在，我们将此程序应用于五个指定的测试用例中的每一个。对于所有用例，基因总数为 $N=10$，基因检测的阈值为 $k_{\\min}=1$。$\\mathcal{M}$ 中的索引是基于0的。\n\n用例 A：\n-   $\\mathbf{x} = [2, 3, 4, 5, 6, 0, 0, 1, 2, 3]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   阈值：$c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n-   $T = 2+3+4+5+6+0+0+1+2+3 = 26$。\n-   $G = |\\{i | x_i \\ge 1\\}| = 8$。\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 2+3 = 5$。\n-   $f_{\\mathrm{mt}} = 5 / 26 \\approx 0.192307...$。\n-   $f_0 = 2 / 10 = 0.2$。\n-   条件检查：\n    1. $20 \\le 26 \\le 1000 \\implies \\text{True}$。\n    2. $8 \\ge 5 \\implies \\text{True}$。\n    3. $0.1923... \\le 0.2 \\implies \\text{True}$。\n    4. $0.2 \\le 0.6 \\implies \\text{True}$。\n-   所有条件都通过。$P = \\text{True}$。\n-   结果：$[26, 8, 0.1923, 0.2000, \\text{True}]$。\n\n用例 B：\n-   $\\mathbf{x} = [2, 2, 8, 4, 4, 0, 0, 0, 0, 0]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   阈值：$c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n-   $T = 2+2+8+4+4 = 20$。\n-   $G = |\\{i | x_i \\ge 1\\}| = 5$。\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 2+2 = 4$。\n-   $f_{\\mathrm{mt}} = 4 / 20 = 0.2$。\n-   $f_0 = 5 / 10 = 0.5$。\n-   条件检查：\n    1. $20 \\le 20 \\le 1000 \\implies \\text{True}$。\n    2. $5 \\ge 5 \\implies \\text{True}$。\n    3. $0.2 \\le 0.2 \\implies \\text{True}$。\n    4. $0.5 \\le 0.6 \\implies \\text{True}$。\n-   所有条件都通过。$P = \\text{True}$。\n-   结果：$[20, 5, 0.2000, 0.5000, \\text{True}]$。\n\n用例 C：\n-   $\\mathbf{x} = [10, 0, 4, 4, 4, 4, 0, 2, 1, 1]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   阈值：$c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n-   $T = 10+0+4+4+4+4+0+2+1+1 = 30$。\n-   $G = |\\{i | x_i \\ge 1\\}| = 8$。\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 10+0 = 10$。\n-   $f_{\\mathrm{mt}} = 10 / 30 \\approx 0.333333...$。\n-   $f_0 = 2 / 10 = 0.2$。\n-   条件检查：\n    1. $20 \\le 30 \\le 1000 \\implies \\text{True}$。\n    2. $8 \\ge 5 \\implies \\text{True}$。\n    3. $0.3333... \\le 0.2 \\implies \\text{False}$。\n    4. $0.2 \\le 0.6 \\implies \\text{True}$。\n-   一个条件未通过。$P = \\text{False}$。\n-   结果：$[30, 8, 0.3333, 0.2000, \\text{False}]$。\n\n用例 D：\n-   $\\mathbf{x} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   阈值：$c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n-   $T = 0$。\n-   $G = |\\{i | x_i \\ge 1\\}| = 0$。\n-   $f_{\\mathrm{mt}} = 0$ (根据定义，因为 $T=0$)。\n-   $f_0 = 10 / 10 = 1.0$。\n-   条件检查：\n    1. $20 \\le 0 \\le 1000 \\implies \\text{False}$。\n    2. $0 \\ge 5 \\implies \\text{False}$。\n    3. $0 \\le 0.2 \\implies \\text{True}$。\n    4. $1.0 \\le 0.6 \\implies \\text{False}$。\n-   多个条件未通过。$P = \\text{False}$。\n-   结果：$[0, 0, 0.0000, 1.0000, \\text{False}]$。\n\n用例 E：\n-   $\\mathbf{x} = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   阈值：$c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n-   $T = 10 \\times 100 = 1000$。\n-   $G = |\\{i | x_i \\ge 1\\}| = 10$。\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 100+100 = 200$。\n-   $f_{\\mathrm{mt}} = 200 / 1000 = 0.2$。\n-   $f_0 = 0 / 10 = 0.0$。\n-   条件检查：\n    1. $20 \\le 1000 \\le 1000 \\implies \\text{True}$。\n    2. $10 \\ge 5 \\implies \\text{True}$。\n    3. $0.2 \\le 0.2 \\implies \\text{True}$。\n    4. $0.0 \\le 0.6 \\implies \\text{True}$。\n-   所有条件都通过。$P = \\text{True}$。\n-   结果：$[1000, 10, 0.2000, 0.0000, \\text{True}]$。\n\n实现将精确地遵循此逻辑，确保正确处理数据类型和浮点数比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the scRNA-seq quality control problem for a given suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        ([2, 3, 4, 5, 6, 0, 0, 1, 2, 3], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case B (boundary inclusivity at c_min and fmt_max)\n        ([2, 2, 8, 4, 4, 0, 0, 0, 0, 0], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case C (failure due to elevated mitochondrial fraction)\n        ([10, 0, 4, 4, 4, 4, 0, 2, 1, 1], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case D (edge case with no detected molecules)\n        ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case E (boundary inclusivity at c_max and fmt_max)\n        ([100, 100, 100, 100, 100, 100, 100, 100, 100, 100], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1)\n    ]\n\n    def process_cell(x_list, M_set, c_min, c_max, g_min, fmt_max, f0_max, k_min):\n        \"\"\"\n        Processes a single cell's count vector to determine its quality metrics and pass/fail status.\n        \"\"\"\n        # Convert inputs to NumPy arrays for efficient computation.\n        x = np.array(x_list, dtype=np.int64)\n        N = len(x)\n\n        # 1. Total UMI count (T)\n        T = np.sum(x)\n\n        # 2. Number of detected genes (G)\n        G = np.sum(x >= k_min)\n\n        # 3. Mitochondrial fraction (f_mt)\n        # Handle the T=0 case as per problem definition.\n        if T > 0:\n            mt_counts = np.sum(x[list(M_set)])\n            f_mt = mt_counts / T\n        else:\n            f_mt = 0.0\n\n        # 4. Zero fraction (f_0)\n        # N will be > 0 based on problem constraints (non-empty x vector)\n        f_0 = np.sum(x == 0) / N\n\n        # 5. Quality control decision (P)\n        pass_T = (c_min = T = c_max)\n        pass_G = (G >= g_min)\n        pass_fmt = (f_mt = fmt_max)\n        pass_f0 = (f_0 = f0_max)\n        P = all([pass_T, pass_G, pass_fmt, pass_f0])\n\n        # For reporting, round fractional quantities to four decimal places.\n        rounded_f_mt = round(f_mt, 4)\n        rounded_f_0 = round(f_0, 4)\n        \n        # In Python, round(0.2, 4) is 0.2, not 0.2000. The desired output\n        # format is Python's default representation, so `round` is sufficient.\n\n        return [int(T), int(G), rounded_f_mt, rounded_f_0, P]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        x_val, M_val, c_min_val, c_max_val, g_min_val, fmt_max_val, f0_max_val, k_min_val = case\n        \n        # Process the cell and store the result\n        result = process_cell(x_val, M_val, c_min_val, c_max_val, g_min_val, fmt_max_val, f0_max_val, k_min_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() of a list produces the required \"[item1, item2, ...]\" format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2672354"}, {"introduction": "在通过质量控制获得高质量的细胞后，下一步是识别那些在定义细胞状态和谱系方面信息最丰富的基因。这个练习将引导你从头开始实现一个经典的高变基因（HVG）选择算法，通过对均值-方差关系进行建模来标准化基因的变异性。掌握这项技术对于降维、聚类以及准确重建发育轨迹至关重要，因为它能帮助我们从数万个基因中聚焦于驱动生物学差异的核心基因集。[@problem_id:2672352]", "problem": "您的任务是为单细胞核糖核酸测序（scRNA-seq）数据形式化并实现一种基于原则、基于模型的筛选高可变基因（HVGs）的方法，该方法需适用于发育生物学中的谱系和命运分析。您的推理必须基于基本原则：分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、导致计数数据过度离散的转录爆发的随机性，以及经过充分检验的用于测序数据的计数模型，如泊松分布和负二项分布。您的解决方案必须从这些原则推导出算法，而不依赖于任何现成的公式。\n\n从以下这些广为接受的基础出发：\n- 在基于液滴的scRNA-seq中，细胞 $i$ 中基因 $g$ 观测到的唯一分子标识符计数（记为 $Y_{gi}$）源于一个抽样过程，其均值与细胞特异性的文库大小 $L_i$ 和基因特异性的表达水平 $\\theta_g$ 成比例。在泊松抽样模型下，$\\operatorname{Var}(Y_{gi}) \\approx \\mathbb{E}[Y_{gi}]$；在负二项模型下，对于离散度 $\\phi_g \\ge 0$，有 $\\operatorname{Var}(Y_{gi}) \\approx \\mathbb{E}[Y_{gi}] + \\phi_g \\mathbb{E}[Y_{gi}]^2$。\n- 为了在具有异质性文库大小的细胞间比较基因，计数应通过一个按细胞计算的因子进行归一化。\n- 由于抽样噪声和生物学变异，表达的方差随均值增加而增加；因此，一个公平的HVG定义需要移除均值-方差依赖关系，以突显那些变异性超出预期的基因。\n\n从第一性原理出发，定义并实现以下HVG统计量：\n1. 对于一个包含 $G$ 个基因和 $C$ 个细胞的计数矩阵，计算每个细胞的文库大小 $L_i = \\sum_{g=1}^{G} Y_{gi}$。\n2. 执行“每万计数”归一化：对于每个 $L_i  0$ 的细胞 $i$，计算 $U_{gi} = \\dfrac{10000 \\cdot Y_{gi}}{L_i}$。如果任何 $L_i = 0$，则为此归一化目的定义 $L_i \\leftarrow 1$，以避免除以零。\n3. 应用方差稳定对数变换：$Z_{gi} = \\log\\!\\big(1 + U_{gi}\\big)$，其中 $\\log$ 表示以 $e$ 为底的自然对数。\n4. 对每个基因 $g$，计算其经验均值 $m_g = \\dfrac{1}{C} \\sum_{i=1}^{C} Z_{gi}$ 和经验无偏方差 $v_g = \\dfrac{1}{C-1} \\sum_{i=1}^{C} \\big(Z_{gi} - m_g\\big)^2$。\n5. 对所有基因的方差关于均值的关系拟合一个全局普通最小二乘线性趋势：$v_g \\approx a + b \\, m_g$。通过最小化 $\\sum_{g=1}^{G} \\big(v_g - (a + b m_g)\\big)^2$ 来估计 $a$ 和 $b$。推导出闭式解 $b = \\dfrac{\\operatorname{Cov}(m,v)}{\\operatorname{Var}(m)}$ 和 $a = \\bar{v} - b \\, \\bar{m}$，其中 $\\bar{m}$ 和 $\\bar{v}$ 是所有基因的均值，$\\operatorname{Cov}$ 和 $\\operatorname{Var}$ 是所有基因的协方差和方差。如果 $\\operatorname{Var}(m) = 0$，则定义 $b \\leftarrow 0$ 和 $a \\leftarrow \\bar{v}$。\n6. 对每个基因 $g$，计算其残差 $e_g = v_g - (a + b m_g)$ 和均方误差 $\\mathrm{MSE} = \\dfrac{1}{G-2} \\sum_{g=1}^{G} e_g^2$（对于 $G \\ge 3$ 有效）。如果 $\\mathrm{MSE} = 0$，则将所有基因的标准化残差定义为 $0$。\n7. 当 $\\mathrm{MSE}  0$ 时，定义标准化残差 $z_g = \\dfrac{e_g}{\\sqrt{\\mathrm{MSE}}}$。HVG的排序分数即为 $z_g$。越高的 $z_g$ 表示变异性越超出拟合的预期。\n8. 为选择前 $K$ 个HVG，按 $z_g$ 降序对基因进行排序。若 $z_g$ 出现平局，则按基因索引（从零开始）升序打破平局。如果 $K  G$，则按该顺序返回所有 $G$ 个基因。\n\n您的任务是实现一个程序，将此流程应用于以下测试套件。每个测试用例提供一个计数矩阵和一个选择参数 $K$。基因索引是从零开始的。下面所有数值条目均为原始计数 $Y_{gi}$。\n\n测试用例 1（正常路径，异质文库大小）：\n- 包含 $G = 5$ 个基因和 $C = 6$ 个细胞的矩阵：\n  - 基因 0: $[10, 10, 10, 10, 10, 10]$\n  - 基因 1: $[1, 2, 3, 4, 5, 6]$\n  - 基因 2: $[0, 10, 0, 20, 0, 30]$\n  - 基因 3: $[0, 0, 1, 0, 0, 0]$\n  - 基因 4: $[5, 5, 8, 6, 5, 4]$\n- 选择前 $K = 2$ 个HVG。\n\n测试用例 2（边界情况：存在零方差基因和全零基因）：\n- 包含 $G = 3$ 个基因和 $C = 4$ 个细胞的矩阵：\n  - 基因 0: $[0, 0, 0, 0]$\n  - 基因 1: $[0, 5, 0, 10]$\n  - 基因 2: $[3, 3, 3, 3]$\n- 选择前 $K = 1$ 个HVG。\n\n测试用例 3（边缘情况：存在相同基因以检验平局打破规则）：\n- 包含 $G = 4$ 个基因和 $C = 3$ 个细胞的矩阵：\n  - 基因 0: $[1, 0, 1]$\n  - 基因 1: $[1, 0, 1]$\n  - 基因 2: $[0, 2, 4]$\n  - 基因 3: $[0, 0, 0]$\n- 选择前 $K = 2$ 个HVG。\n\n测试用例 4（边缘情况：请求的HVG数量多于可用数量）：\n- 包含 $G = 4$ 个基因和 $C = 4$ 个细胞的矩阵：\n  - 基因 0: $[1, 2, 1, 2]$\n  - 基因 1: $[5, 5, 5, 5]$\n  - 基因 2: $[0, 0, 10, 0]$\n  - 基因 3: $[3, 0, 0, 0]$\n- 选择前 $K = 5$ 个HVG。\n\n您的程序必须严格按照上述定义实现该流程，并生成一行输出，其中包含按顺序排列的各测试用例的所选基因索引列表。输出格式必须为 \"[[i0,i1,...],[j0,j1,...],...]\" 形式的单行字符串，不含空格，其中每个内部列表包含该测试用例按规定的HVG排序规则排序后的从零开始的基因索引。不涉及物理单位。不涉及角度。任何地方都不得使用百分比。确保所有计算都严格遵循上述定义，包括使用自然对数和分母为 $C-1$ 的无偏方差。", "solution": "该问题要求形式化并实现一种统计方法，用于从单细胞核糖核酸测序（scRNA-seq）计数数据中识别高可变基因（HVG）。该方法必须源于分子生物学和统计学的基本原则。\n\n识别具有生物学意义的基因表达异质性的核心挑战在于，如何将其与技术噪声及其他混淆因素区分开来。基因的表达是一个随机过程。如前所述，中心法则描述了遗传信息从脱氧核糖核酸（DNA）到核糖核酸（RNA）再到蛋白质的流动过程。转录，即从DNA模板合成RNA的过程，是以随机爆发的形式发生的。这种内在的随机性，加上来自反转录、扩增和测序过程的技术噪声，导致观测到的计数数据（$Y_{gi}$）具有高度可变性。\n\n测序数据中的一个关键观察是，基因表达的方差强烈依赖于其平均表达水平。这种均值-方差关系是计数分布（如泊松分布，其中 $\\operatorname{Var}(Y) = \\mathbb{E}[Y]$；以及负二项分布，其中 $\\operatorname{Var}(Y) = \\mathbb{E}[Y] + \\phi \\mathbb{E}[Y]^2$）的一个基本属性。此外，基于液滴的scRNA-seq实验产生的细胞具有不同的文库大小（$L_i$），即在单个细胞中检测到的分子总数。在细胞 $i$ 中，一个基因的观测计数值 $Y_{gi}$ 与其内在表达水平 $\\theta_g$ 和该细胞的文库大小 $L_i$ 均成正比。为了有意义地比较不同细胞间的基因表达，必须消除这种文库大小效应。\n\n所规定的算法系统地解决了这些挑战，详述如下。\n\n1.  **文库大小计算**：\n    第一步是量化每个细胞的总测序深度。细胞 $i$ 的文库大小（记为 $L_i$）是该细胞内所有基因的计数总和：\n    $$ L_i = \\sum_{g=1}^{G} Y_{gi} $$\n    其中 $Y_{gi}$ 是基因 $g$ 在细胞 $i$ 中的原始计数，$G$ 是基因总数，$C$ 是细胞总数。\n\n2.  **“每万计数”式归一化**：\n    为了使基因表达值在具有不同文库大小的细胞间具有可比性，我们对原始计数进行归一化。问题指定了“每万计数”归一化。归一化后的表达值 $U_{gi}$ 是为每个基因 $g$ 在每个细胞 $i$ 中计算的：\n    $$ U_{gi} = \\frac{10000 \\cdot Y_{gi}}{L_i} $$\n    这种缩放将计数转换到一个共同的尺度，概念上代表了如果文库大小恰好为10000时，该基因会被观测到的分子数。问题正确地指出，如果一个文库大小 $L_i$ 为0，应将其设为1以防止除以零，这导致该细胞中所有基因的 $U_{gi}$ 均为0。\n\n3.  **方差稳定变换**：\n    即使在归一化之后，$U_{gi}$ 的方差仍然依赖于其均值。为减轻此问题，应用了方差稳定变换。问题指定了对数变换，这对于类计数数据是常见的：\n    $$ Z_{gi} = \\log(1 + U_{gi}) $$\n    加1是为了防止对零取对数。这种变换压缩了数据范围，并使方差在更大程度上独立于均值，尽管通常仍会残留一定的趋势。\n\n4.  **经验均值和方差估计**：\n    变换之后，我们量化每个基因在所有 $C$ 个细胞中的表达水平和变异性。对于每个基因 $g$，我们计算其经验均值 $m_g$ 和其经验无偏样本方差 $v_g$：\n    $$ m_g = \\frac{1}{C} \\sum_{i=1}^{C} Z_{gi} $$\n    $$ v_g = \\frac{1}{C-1} \\sum_{i=1}^{C} (Z_{gi} - m_g)^2 $$\n    对方差使用分母 $C-1$ 提供了对总体方差的无偏估计。\n\n5.  **均值-方差趋势建模**：\n    该方法的核心是对方差 $v_g$ 和均值 $m_g$ 之间存在的残余关系进行建模。这一趋势代表了在给定平均表达水平下，基因的预期方差水平。通过对这一趋势拟合模型，我们可以识别出方差显著超过此预期的基因。问题指定了一个普通最小二乘（OLS）线性模型：\n    $$ v_g \\approx a + b \\, m_g $$\n    参数 $a$ 和 $b$ 通过最小化所有基因的残差平方和 $\\sum_{g=1}^{G} (v_g - (a + b m_g))^2$ 来估计。OLS估计量的闭式解为：\n    $$ b = \\frac{\\operatorname{Cov}(m,v)}{\\operatorname{Var}(m)} \\quad \\text{以及} \\quad a = \\bar{v} - b \\, \\bar{m} $$\n    这里，$\\bar{m}$ 和 $\\bar{v}$ 分别是 $m_g$ 和 $v_g$ 在所有基因中的均值，而 $\\operatorname{Var}(m)$ 和 $\\operatorname{Cov}(m,v)$ 是对所有基因的 $(m_g, v_g)$ 对集合计算的方差和协方差。具体来说，$\\operatorname{Var}(m) = \\frac{1}{G}\\sum_{g=1}^{G}(m_g - \\bar{m})^2$ 且 $\\operatorname{Cov}(m,v) = \\frac{1}{G}\\sum_{g=1}^{G}(m_g - \\bar{m})(v_g - \\bar{v})$。如果 $\\operatorname{Var}(m) = 0$（当所有基因具有相同的平均表达 $m_g$ 时发生），则斜率 $b$ 未定义；问题规定在这种情况下设 $b \\leftarrow 0$ 和 $a \\leftarrow \\bar{v}$。\n\n6.  **计算标准化残差**：\n    一个基因与其预期趋势的偏离由其残差 $e_g$ 捕获：\n    $$ e_g = v_g - (a + b m_g) $$\n    一个大的正残差表明一个基因比其表达水平所预期的更具变异性。为了使这些残差在不同数据集间具有可比性，需要对它们进行标准化。这需要一个对回归中误差方差的估计。均方误差（MSE）提供了这一点：\n    $$ \\mathrm{MSE} = \\frac{1}{G-2} \\sum_{g=1}^{G} e_g^2 $$\n    使用分母 $G-2$ 是因为从数据中估计了两个参数（$a$ 和 $b$），这是为获得误差方差的无偏估计所做的标准调整（假设 $G \\ge 3$）。标准化残差 $z_g$（作为最终的HVG分数）则为：\n    $$ z_g = \\frac{e_g}{\\sqrt{\\mathrm{MSE}}} $$\n    如果 $\\mathrm{MSE} = 0$，则所有残差均为0，因此所有 $z_g$ 都定义为0。\n\n7.  **排序与选择**：\n    最后一步是选择前 $K$ 个HVG。基因按照其标准化残差分数 $z_g$ 的降序排列。越高的 $z_g$ 表明其具有生物学意义的变异性的证据越强。问题规定 $z_g$ 的平局必须通过选择具有较小（升序）的从零开始的索引来解决。如果请求的基因数 $K$ 大于总基因数 $G$，则返回所有按其排序顺序排列的基因。\n\n这一基于原则的流程提供了一种稳健且可解释的scRNA-seq分析特征选择方法，它植根于计数数据的统计模型，旨在将生物信号从技术噪声中分离出来。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the HVG selection pipeline on all test cases.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [10, 10, 10, 10, 10, 10],\n                [1, 2, 3, 4, 5, 6],\n                [0, 10, 0, 20, 0, 30],\n                [0, 0, 1, 0, 0, 0],\n                [5, 5, 8, 6, 5, 4]\n            ]),\n            2\n        ),\n        (\n            np.array([\n                [0, 0, 0, 0],\n                [0, 5, 0, 10],\n                [3, 3, 3, 3]\n            ]),\n            1\n        ),\n        (\n            np.array([\n                [1, 0, 1],\n                [1, 0, 1],\n                [0, 2, 4],\n                [0, 0, 0]\n            ]),\n            2\n        ),\n        (\n            np.array([\n                [1, 2, 1, 2],\n                [5, 5, 5, 5],\n                [0, 0, 10, 0],\n                [3, 0, 0, 0]\n            ]),\n            5\n        )\n    ]\n\n    results = []\n    for Y, K in test_cases:\n        selected_indices = find_hvgs(Y, K)\n        results.append(selected_indices)\n\n    # Format the final output string exactly as specified.\n    print(f\"[{','.join([str(res) for res in results])}]\".replace(\" \", \"\"))\n\ndef find_hvgs(Y, K):\n    \"\"\"\n    Implements the highly variable gene (HVG) selection pipeline.\n\n    Args:\n        Y (np.ndarray): A Gx C count matrix (G genes, C cells).\n        K (int): The number of top HVGs to select.\n\n    Returns:\n        list: A list of the top K gene indices, sorted by HVG score.\n    \"\"\"\n    if Y.shape[0] == 0 or Y.shape[1] == 0:\n        return []\n\n    G, C = Y.shape\n\n    # Step 1: Compute per-cell library size\n    L = Y.sum(axis=0, dtype=np.float64)\n\n    # Step 2: Perform counts-per-ten-thousand normalization\n    # Handle L_i = 0 case\n    L[L == 0] = 1\n    # Use broadcasting for normalization\n    U = (10000.0 * Y) / L[np.newaxis, :]\n\n    # Step 3: Apply a variance-stabilizing log-transform\n    Z = np.log1p(U)\n\n    # Step 4: Compute empirical mean and unbiased variance for each gene\n    # The problem implies C > 1, so ddof=1 is safe.\n    if C = 1:\n        # Cannot compute variance, return empty list or handle as per a more\n        # complete specification. For this problem, C > 1 is guaranteed by tests.\n        return list(range(G))[:K]\n        \n    m = Z.mean(axis=1)\n    v = Z.var(axis=1, ddof=1)\n\n    # Step 5: Fit a global OLS linear trend\n    if G == 0:\n        return []\n\n    m_bar = m.mean()\n    v_bar = v.mean()\n\n    # Use population variance (ddof=0) for the 'm' vector as per standard OLS derivation.\n    m_var = m.var(ddof=0)\n\n    if m_var == 0:\n        b = 0.0\n        a = v_bar\n    else:\n        # Use population covariance (ddof=0). np.cov returns a 2x2 matrix.\n        cov_mv = np.cov(m, v, ddof=0)[0, 1]\n        b = cov_mv / m_var\n        a = v_bar - b * m_bar\n    \n    # Step 6  7: Compute standardized residuals\n    e = v - (a + b * m)\n    # The problem implies G >= 3 for MSE calculation.\n    if G  3:\n        # The z-score calculation is not well-defined.\n        # Fallback to sorting by raw residual if needed. For this problem, we follow spec.\n        z = e # Use raw residual if G  3, no standardization possible\n    else:\n        mse_sum_sq = np.sum(e**2)\n        mse = mse_sum_sq / (G - 2)\n        \n        if mse == 0:\n            z = np.zeros(G)\n        else:\n            z = e / np.sqrt(mse)\n\n    # Step 8: Select top K HVGs\n    gene_indices = np.arange(G)\n\n    # Sort by descending z-score, breaking ties with ascending gene index.\n    # We can create a list of tuples (z_score, gene_index) and sort.\n    # The key (-z, idx) implements the desired sorting order.\n    sorted_genes = sorted(zip(z, gene_indices), key=lambda x: (-x[0], x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [idx for score, idx in sorted_genes]\n\n    # Return the top K, or all G if K > G.\n    return sorted_indices[:K]\n\nsolve()\n```", "id": "2672352"}, {"introduction": "单细胞分析的最终目标之一是建立能够解释和预测细胞行为的数学模型。这项高级练习将理论与实践相结合，指导你根据生物物理学的基本原理——包括质量作用定律和统计热力学——构建一个模型。你将学习如何利用单细胞数据中配体和受体的表达水平，来量化细胞间通讯如何影响细胞的二元命运决定，从而将描述性的数据分析提升到机理性的理解层面。[@problem_id:2672375]", "problem": "您正在建模，基于单细胞RNA测序 (scRNA-seq) 数据测量的细胞间通讯如何影响发育中组织内的二元命运决定。从以下基本原则出发：(i) 分子生物学中心法则，该法则意味着在稳态条件下，预期的蛋白质产出率可以近似为与信使核糖核酸 (mRNA) 丰度成正比；(ii) 平衡状态下具有可逆质量作用动力学的基本配体-受体结合；以及 (iii) 两种命运之间的两态热力学选择，其概率遵循玻尔兹曼分布，能量差与上游信号呈线性关系。基于这些原则，推导出一个最小化的、可检验的模型，该模型将源自scRNA-seq的配体和受体水平映射到单个受体细胞选择命运-$1$而非命运-$0$的无量纲概率。该模型必须按照以下方式构建，不得使用此处规定之外的任何外部信息：\n\n1) 利用稳态中心法则所蕴含的比例关系，将平均配体mRNA丰度映射到估计的胞外配体浓度。具体来说，对于每种配体 $a$，设估计浓度为 $S_a = \\alpha_a \\cdot \\bar{m}_a$，其中 $\\bar{m}_a$ 是每个发送细胞的平均mRNA计数，$\\alpha_a$ 是一个给定的比例常数，单位为纳摩尔/计数 (nM/count)。单位：$S_a$ 必须以纳摩尔 (nM) 为单位。\n\n2) 对于每个具有平衡解离常数 $K_{d,a}$ (单位为nM) 的配体-受体对 $a$，根据质量作用定律从可逆结合中推导出平衡时处于结合态的受体分数。然后，通过用一个与受体mRNA丰度成正比的受体容量参数 $r_a$ 来缩放该占有率，定义一个有效的通路信号贡献：$r_a = \\beta_a \\cdot R_a$，其中 $R_a$ 是受体mRNA计数，$\\beta_a$ 是一个给定的比例常数 (无量纲/计数)。允许每个通路的贡献通过给定的符号 $s_a \\in \\{+1,-1\\}$ 成为激活或抑制。\n\n3) 假设用于命运选择的净决策变量（一个线性预测器）是基线项、带符号的通路贡献以及一个细胞内源性转录因子贡献的总和。具体来说，将通路项相加，并包含一个乘以转录因子水平的标量系数。\n\n4) 从固定有效温度下命运选择的两态热力学论证出发，推导出从决策变量到命运-$1$概率的映射，该概率是位于开区间 $(0,1)$ 内的一个无量纲数。\n\n您的程序必须实现上述推导并计算以下五个测试案例中每个案例的命运-$1$概率。所有数值输入如下所示；请勿引入任何额外的参数。所有浓度均以纳摩尔 (nM) 表示，所有最终概率均表示为小数点后保留六位的小数。本问题不涉及角度。最终的程序输出必须是包含在方括号中的单行逗号分隔列表。\n\n测试套件（每个案例提供数组和标量；所有数字均明确给出）：\n\n- 案例A（典型的混合信号）：\n  - 发送细胞的平均配体mRNA：$\\bar{m} = [\\,50,\\,30\\,]$\n  - 配体到浓度的比例：$\\alpha = [\\,0.2,\\,0.1\\,]$ (nM/count)\n  - 解离常数：$K_d = [\\,5,\\,2\\,]$ (nM)\n  - 受体细胞中的受体mRNA：$R = [\\,100,\\,80\\,]$\n  - 受体容量比例：$\\beta = [\\,0.01,\\,0.01\\,]$ (无量纲/计数)\n  - 通路符号：$s = [\\,+1,\\,-1\\,]$\n  - 基线：$b_0 = 0$\n  - 转录因子水平：$T = 0$\n  - 转录因子系数：$\\gamma = 0.5$\n\n- 案例B（无配体；内源性偏好主导）：\n  - $\\bar{m} = [\\,0\\,]$\n  - $\\alpha = [\\,0.5\\,]$ (nM/count)\n  - $K_d = [\\,1\\,]$ (nM)\n  - $R = [\\,50\\,]$\n  - $\\beta = [\\,0.02\\,]$ (无量纲/计数)\n  - $s = [\\,+1\\,]$\n  - $b_0 = -1$\n  - $T = 1$\n  - $\\gamma = 2$\n\n- 案例C（饱和的激活配体）：\n  - $\\bar{m} = [\\,1000\\,]$\n  - $\\alpha = [\\,1.0\\,]$ (nM/count)\n  - $K_d = [\\,1\\,]$ (nM)\n  - $R = [\\,200\\,]$\n  - $\\beta = [\\,0.02\\,]$ (无量纲/计数)\n  - $s = [\\,+1\\,]$\n  - $b_0 = -2$\n  - $T = 0$\n  - $\\gamma = 1$\n\n- 案例D（强抑制主导）：\n  - $\\bar{m} = [\\,20,\\,60\\,]$\n  - $\\alpha = [\\,0.3,\\,0.3\\,]$ (nM/count)\n  - $K_d = [\\,3,\\,6\\,]$ (nM)\n  - $R = [\\,60,\\,120\\,]$\n  - $\\beta = [\\,0.02,\\,0.015\\,]$ (无量纲/计数)\n  - $s = [\\,+1,\\,-1\\,]$\n  - $b_0 = -0.5$\n  - $T = 0$\n  - $\\gamma = 0$\n\n- 案例E（平衡的输入，边界概率）：\n  - $\\bar{m} = [\\,10,\\,10\\,]$\n  - $\\alpha = [\\,1,\\,1\\,]$ (nM/count)\n  - $K_d = [\\,10,\\,10\\,]$ (nM)\n  - $R = [\\,100,\\,100\\,]$\n  - $\\beta = [\\,0.01,\\,0.01\\,]$ (无量纲/计数)\n  - $s = [\\,+1,\\,-1\\,]$\n  - $b_0 = 0$\n  - $T = 0$\n  - $\\gamma = 0$\n\n计算和输出要求：\n\n- 对于每个案例，计算以纳摩尔为单位的 $S_a = \\alpha_a \\cdot \\bar{m}_a$。\n- 根据平衡时的可逆结合，使用质量作用结果计算每个 $a$ 的结合分数，并用 $r_a = \\beta_a \\cdot R_a$ 和符号 $s_a$ 对其进行缩放，然后与基线项和转录因子项求和，形成一个单一的线性预测器。然后使用两态热力学论证将此预测器映射到命运-$1$的无量纲概率。\n- 将每个概率四舍五入到小数点后六位，并输出单行：一个用方括号括起来的逗号分隔列表，顺序为 $[\\,\\text{案例A},\\,\\text{案例B},\\,\\text{案例C},\\,\\text{案例D},\\,\\text{案例E}\\,]$。", "solution": "该问题要求基于分子生物学和统计热力学的基本原理，推导并实现一个用于二元细胞命运决定的最小化模型。该模型必须将单细胞转录组学数据（配体和受体mRNA计数）映射到命运概率。问题陈述具有科学依据，表述清晰，并包含了获得唯一解所需的所有必要信息。我们开始进行推导。\n\n推导过程遵循指定的四个步骤。\n\n步骤1：配体浓度估计\n问题假设，在稳态下，配体 $S_a$ 的胞外浓度与发送细胞群体中该配体的平均mRNA丰度 $\\bar{m}_a$ 成正比。比例常数为 $\\alpha_a$。\n$$ S_a = \\alpha_a \\cdot \\bar{m}_a $$\n单位是一致的：$\\alpha_a$ 的单位是 (nM/count)，$\\bar{m}_a$ 的单位是计数，得出 $S_a$ 的单位是纳摩尔 (nM)，这在化学上是正确的。\n\n步骤2：来自配体-受体结合的通路信号贡献\n配体 $L$ 和游离受体 $R_{free}$ 之间相互作用形成结合复合物 $LR_{bound}$ 的过程由可逆反应 $L + R_{free} \\rightleftharpoons LR_{bound}$ 描述。根据平衡状态下的质量作用定律，给定配体-受体对 $a$ 的解离常数 $K_{d,a}$ 定义为：\n$$ K_{d,a} = \\frac{[L_a][R_{free,a}]}{[LR_{bound,a}]} $$\n此处，$[L_a]$ 是配体浓度，我们已将其建模为 $S_a$。结合受体的分数 $\\theta_a$ 是结合受体浓度与总受体浓度 $[R_{tot,a}] = [R_{free,a}] + [LR_{bound,a}]$ 的比值。通过重排平衡方程以求解 $[R_{free,a}]$ 并代入总受体表达式，我们推导出经典的Hill-Langmuir方程来表示受体占有率：\n$$ [R_{tot,a}] = \\frac{K_{d,a}[LR_{bound,a}]}{S_a} + [LR_{bound,a}] = [LR_{bound,a}] \\left( \\frac{K_{d,a}}{S_a} + 1 \\right) $$\n$$ \\theta_a = \\frac{[LR_{bound,a}]}{[R_{tot,a}]} = \\frac{S_a}{K_{d,a} + S_a} $$\n这个分数 $\\theta_a$ 是一个无量纲量，表示受体激活的程度。问题陈述，通路 $a$ 的有效信号贡献（我们表示为 $C_a$）是该占有率乘以一个受体容量参数 $r_a = \\beta_a \\cdot R_a$ 和一个表示激活或抑制的符号 $s_a \\in \\{+1, -1\\}$。参数 $r_a$ 本身与受体mRNA计数 $R_a$ 成正比，比例常数为 $\\beta_a$。因此，通路 $a$ 的贡献是：\n$$ C_a = s_a \\cdot r_a \\cdot \\theta_a = s_a \\cdot (\\beta_a \\cdot R_a) \\cdot \\left( \\frac{S_a}{K_{d,a} + S_a} \\right) $$\n\n步骤3：净决策变量\n净决策变量（表示为 $X$）是一个整合所有上游信号的线性预测器。它被定义为一个基线偏置 $b_0$、所有配体-受体通路的贡献以及一个由转录因子水平 $T$ 和系数 $\\gamma$ 代表的细胞内源状态项的总和。\n$$ X = b_0 + \\sum_a C_a + \\gamma \\cdot T $$\n代入 $C_a$ 和 $S_a$ 的表达式，我们得到决策变量的完整形式：\n$$ X = b_0 + \\sum_a \\left[ s_a \\cdot (\\beta_a \\cdot R_a) \\cdot \\left( \\frac{\\alpha_a \\cdot \\bar{m}_a}{K_{d,a} + \\alpha_a \\cdot \\bar{m}_a} \\right) \\right] + \\gamma \\cdot T $$\n\n步骤4：映射到命运概率\n最后一步是将决策变量 $X$ 映射到选择命运-$1$的概率，表示为 $P(1)$。问题指定了一个两态热力学论证。设两种命运，命运-$0$和命运-$1$，具有有效自由能 $E_0$ 和 $E_1$。根据统计力学，占据一个状态的概率与其玻尔兹曼因子 $e^{-E/k_B T_{eff}}$ 成正比，其中 $k_B T_{eff}$ 是有效热能。因此，命运-$1$的概率是：\n$$ P(1) = \\frac{e^{-E_1/k_B T_{eff}}}{e^{-E_0/k_B T_{eff}} + e^{-E_1/k_B T_{eff}}} = \\frac{1}{1 + e^{(E_1 - E_0)/k_B T_{eff}}} $$\n问题陈述能量差 $\\Delta E = E_1 - E_0$ 与上游信号呈线性关系。在此类模型中，最直接和标准的解释是将无量纲的能量差 $-\\Delta E/k_B T_{eff}$ 等同于线性预测器 $X$。这种等同是常见的，并构成了逻辑回归模型的基础。\n$$ -\\frac{E_1 - E_0}{k_B T_{eff}} \\equiv X $$\n一个正的 $X$ 对应于 $E_1  E_0$，使得命运-$1$在能量上更有利，从而增加 $P(1)$。这与激活信号 ($s_a=+1$) 增加 $X$ 相一致。概率 $P(1)$ 随后由标准的逻辑 (sigmoid) 函数给出：\n$$ P(1) = \\frac{1}{1 + e^{-X}} $$\n该函数将实值决策变量 $X$ 正确地映射到所需的开区间 $(0, 1)$。\n\n我们现在将这个完整的模型应用于所提供的测试案例。\n\n案例A：$\\bar{m} = [50, 30]$, $\\alpha = [0.2, 0.1]$, $K_d = [5, 2]$, $R = [100, 80]$, $\\beta = [0.01, 0.01]$, $s = [+1, -1]$, $b_0 = 0$, $T = 0$, $\\gamma = 0.5$。\n$S_1 = 0.2 \\cdot 50 = 10$。 $S_2 = 0.1 \\cdot 30 = 3$。\n$C_1 = +1 \\cdot (0.01 \\cdot 100) \\cdot \\frac{10}{5+10} = 1 \\cdot \\frac{10}{15} \\approx 0.666667$。\n$C_2 = -1 \\cdot (0.01 \\cdot 80) \\cdot \\frac{3}{2+3} = -0.8 \\cdot \\frac{3}{5} = -0.48$。\n$X = 0 + 0.666667 - 0.48 + 0 = 0.186667$。\n$P(1) = \\frac{1}{1 + e^{-0.186667}} \\approx 0.546520$。\n\n案例B：$\\bar{m} = [0]$, $\\alpha = [0.5]$, $K_d = [1]$, $R = [50]$, $\\beta = [0.02]$, $s = [+1]$, $b_0 = -1$, $T = 1$, $\\gamma = 2$。\n$S_1 = 0.5 \\cdot 0 = 0$。\n$C_1 = +1 \\cdot (0.02 \\cdot 50) \\cdot \\frac{0}{1+0} = 0$。\n$X = -1 + 0 + (2 \\cdot 1) = 1$。\n$P(1) = \\frac{1}{1 + e^{-1}} \\approx 0.731059$。\n\n案例C：$\\bar{m} = [1000]$, $\\alpha = [1.0]$, $K_d = [1]$, $R = [200]$, $\\beta = [0.02]$, $s = [+1]$, $b_0 = -2$, $T = 0$, $\\gamma = 1$。\n$S_1 = 1.0 \\cdot 1000 = 1000$。\n$C_1 = +1 \\cdot (0.02 \\cdot 200) \\cdot \\frac{1000}{1+1000} = 4 \\cdot \\frac{1000}{1001} \\approx 3.996004$。\n$X = -2 + 3.996004 + 0 = 1.996004$。\n$P(1) = \\frac{1}{1 + e^{-1.996004}} \\approx 0.880387$。\n\n案例D：$\\bar{m} = [20, 60]$, $\\alpha = [0.3, 0.3]$, $K_d = [3, 6]$, $R = [60, 120]$, $\\beta = [0.02, 0.015]$, $s = [+1, -1]$, $b_0 = -0.5$, $T = 0$, $\\gamma = 0$。\n$S_1 = 0.3 \\cdot 20 = 6$。 $S_2 = 0.3 \\cdot 60 = 18$。\n$C_1 = +1 \\cdot (0.02 \\cdot 60) \\cdot \\frac{6}{3+6} = 1.2 \\cdot \\frac{6}{9} = 0.8$。\n$C_2 = -1 \\cdot (0.015 \\cdot 120) \\cdot \\frac{18}{6+18} = -1.8 \\cdot \\frac{18}{24} = -1.35$。\n$X = -0.5 + 0.8 - 1.35 + 0 = -1.05$。\n$P(1) = \\frac{1}{1 + e^{-(-1.05)}} = \\frac{1}{1 + e^{1.05}} \\approx 0.259223$。\n\n案例E：$\\bar{m} = [10, 10]$, $\\alpha = [1, 1]$, $K_d = [10, 10]$, $R = [100, 100]$, $\\beta = [0.01, 0.01]$, $s = [+1, -1]$, $b_0 = 0$, $T = 0$, $\\gamma = 0$。\n$S_1 = 1 \\cdot 10 = 10$。 $S_2 = 1 \\cdot 10 = 10$。\n$C_1 = +1 \\cdot (0.01 \\cdot 100) \\cdot \\frac{10}{10+10} = 1 \\cdot 0.5 = 0.5$。\n$C_2 = -1 \\cdot (0.01 \\cdot 100) \\cdot \\frac{10}{10+10} = -1 \\cdot 0.5 = -0.5$。\n$X = 0 + 0.5 - 0.5 + 0 = 0$。\n$P(1) = \\frac{1}{1 + e^{-0}} = \\frac{1}{1+1} = 0.500000$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes cell fate probabilities based on a biophysical model\n    for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: typical mixed signaling\n        {\n            \"m_bar\": [50, 30], \"alpha\": [0.2, 0.1], \"Kd\": [5, 2], \n            \"R\": [100, 80], \"beta\": [0.01, 0.01], \"s\": [1, -1],\n            \"b0\": 0, \"T\": 0, \"gamma\": 0.5\n        },\n        # Case B: no ligand; intrinsic bias dominates\n        {\n            \"m_bar\": [0], \"alpha\": [0.5], \"Kd\": [1],\n            \"R\": [50], \"beta\": [0.02], \"s\": [1],\n            \"b0\": -1, \"T\": 1, \"gamma\": 2\n        },\n        # Case C: saturating activating ligand\n        {\n            \"m_bar\": [1000], \"alpha\": [1.0], \"Kd\": [1],\n            \"R\": [200], \"beta\": [0.02], \"s\": [1],\n            \"b0\": -2, \"T\": 0, \"gamma\": 1\n        },\n        # Case D: strong inhibition dominates\n        {\n            \"m_bar\": [20, 60], \"alpha\": [0.3, 0.3], \"Kd\": [3, 6],\n            \"R\": [60, 120], \"beta\": [0.02, 0.015], \"s\": [1, -1],\n            \"b0\": -0.5, \"T\": 0, \"gamma\": 0\n        },\n        # Case E: balanced inputs, boundary probability\n        {\n            \"m_bar\": [10, 10], \"alpha\": [1, 1], \"Kd\": [10, 10],\n            \"R\": [100, 100], \"beta\": [0.01, 0.01], \"s\": [1, -1],\n            \"b0\": 0, \"T\": 0, \"gamma\": 0\n        }\n    ]\n\n    def calculate_fate_probability(m_bar, alpha, Kd, R, beta, s, b0, T, gamma):\n        \"\"\"\n        Calculates the probability of fate-1 for a single cell based on the derived model.\n        \n        Args:\n            m_bar (list): Mean ligand mRNA per sender.\n            alpha (list): Ligand-to-concentration proportionality.\n            Kd (list): Dissociation constants.\n            R (list): Receptor mRNA in receiver.\n            beta (list): Receptor capacity proportionality.\n            s (list): Pathway signs (+1 or -1).\n            b0 (float): Baseline term.\n            T (float): Transcription factor level.\n            gamma (float): Transcription factor coefficient.\n            \n        Returns:\n            float: The probability of fate-1.\n        \"\"\"\n        # Convert list inputs to numpy arrays for vectorized calculations.\n        m_bar_np = np.asarray(m_bar)\n        alpha_np = np.asarray(alpha)\n        Kd_np = np.asarray(Kd)\n        R_np = np.asarray(R)\n        beta_np = np.asarray(beta)\n        s_np = np.asarray(s)\n\n        # Step 1: Calculate ligand concentrations (S_a)\n        S_a = alpha_np * m_bar_np\n\n        # Step 2: Calculate pathway signal contributions (C_a)\n        # Receptor occupancy fraction (theta_a)\n        # Add a small epsilon to the denominator to prevent division by zero in the\n        # theoretical case where S_a=0 and Kd_np=0, although Kd > 0 in this problem.\n        theta_a = S_a / (Kd_np + S_a)\n        \n        # Receptor capacity (r_a)\n        r_a = beta_np * R_np\n        \n        # Total contribution from all pathways\n        pathway_contributions = s_np * r_a * theta_a\n\n        # Step 3: Calculate the net decision variable (X)\n        X = b0 + np.sum(pathway_contributions) + gamma * T\n        \n        # Step 4: Map the decision variable to a probability using the logistic function\n        probability = 1.0 / (1.0 + np.exp(-X))\n        \n        return probability\n\n    results = []\n    for case in test_cases:\n        prob = calculate_fate_probability(**case)\n        # Round to six digits after the decimal point and format as string.\n        results.append(f\"{prob:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2672375"}]}