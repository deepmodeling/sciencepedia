{"hands_on_practices": [{"introduction": "空间转录组学实验设计的第一个基本问题是：如何确保每个空间位置都获得一个唯一的标识符？本练习将指导您完成一个基于概率论的基础计算，以确定空间条形码所需的复杂性（即长度），从而最大程度地降低因条形码“碰撞”（即两个或多个位置被分配了相同的条形码）而导致数据混淆的风险。这项实践练习 [@problem_id:2673506] 强调了设计大规模条形码文库以匹配实验通量的核心原则。", "problem": "在一项空间转录组学分析中，微珠被随机沉积在组织切片上，以原位捕获信使核糖核酸 (mRNA) 分子。每个微珠携带一个长度为 $L$ 个核苷酸的脱氧核糖核酸 (DNA) 空间条形码，该条形码从四核苷酸字母表中抽取，因此可能的条形码总数为 $4^L$。假设 $n = 10^6$ 个微珠从 $4^L$ 种可能性中被独立且均匀地分配了条形码。如果两个或多个微珠共享相同的条形码，就会发生碰撞，这将混淆空间位置与基因表达之间的映射。\n\n仅使用独立均匀抽样的组合学和概率论基本原理（例如，计数论证、针对并集的布尔不等式），确定最小的整数 $L$，使得 $n$ 个微珠中至少发生一次碰撞的概率严格小于 $\\varepsilon = 10^{-6}$。请提供满足此要求的最小整数 $L$。除了确定这个最小整数之外，不需要进行其他舍入。", "solution": "该问题要求确定空间转录组学分析中最小的整数条形码长度，记为 $L$。条件是 $n$ 个微珠中至少发生一次碰撞的概率必须严格小于指定的阈值 $\\varepsilon$。\n\n我们首先将问题陈述中提供的参数形式化。\n微珠数量为 $n = 10^6$。\n条形码由 4 个核苷酸的字母表构成。\n长度为 $L$ 的可能唯一条形码总数为 $N = 4^L$。\n至少发生一次碰撞的概率（我们记为 $P_c$）必须满足不等式 $P_c  \\varepsilon$，其中 $\\varepsilon = 10^{-6}$。\n将条形码分配给微珠是一个独立均匀的随机过程。这种情况是一个经典的组合问题，通常被称为“生日问题”。\n\n直接计算 $P_c$ 很困难。更易于处理的方法是首先计算其互补事件的概率 $P_{nc}$，即没有碰撞的概率。无碰撞的结果意味着 $n$ 个微珠中的每一个都收到了一个唯一的条形码。\n\n将条形码有放回地分配给 $n$ 个微珠的总方式数为 $N^n$，因为 $n$ 个微珠中的每一个都可以被分配 $N$ 个可能的条形码中的任何一个。\n为 $n$ 个微珠中的每一个分配一个唯一条形码的方式数，是 $N$ 个项目中取 $n$ 个的排列数，由 $P(N, n) = \\frac{N!}{(N-n)!}$ 给出。\n\n没有碰撞的精确概率是这两个量的比值：\n$$ P_{nc} = \\frac{P(N, n)}{N^n} = \\frac{N(N-1)\\cdots(N-n+1)}{N^n} = \\prod_{k=0}^{n-1} \\left(1 - \\frac{k}{N}\\right) $$\n至少发生一次碰撞的概率是 $P_c = 1 - P_{nc}$。问题的要求是 $1 - P_{nc}  \\varepsilon$。\n\n正如问题所建议的，我们可以使用基本原理，如布尔不等式（也称为并集上界），来建立一个更简单、充分的条件。设 $E_{ij}$ 为微珠 $i$ 和微珠 $j$ 被分配相同条形码的事件，对于任何配对 $i  j$。由于分配是均匀和独立的，此事件的概率为 $P(E_{ij}) = \\frac{1}{N}$。\n\n至少发生一次碰撞的事件 $C$ 是所有此类成对碰撞事件的并集：$C = \\bigcup_{1 \\le i  j \\le n} E_{ij}$。不同的微珠对的数量是 $\\binom{n}{2} = \\frac{n(n-1)}{2}$。\n\n应用布尔不等式：\n$$ P_c = P(C) \\le \\sum_{1 \\le i  j \\le n} P(E_{ij}) = \\binom{n}{2} \\cdot \\frac{1}{N} = \\frac{n(n-1)}{2N} $$\n这个不等式提供了碰撞概率的一个上界。为确保 $P_c  \\varepsilon$，只需要求这个上界小于 $\\varepsilon$ 即可：\n$$ \\frac{n(n-1)}{2N}  \\varepsilon $$\n当 $N$ 远大于 $n$ 时，这个近似非常精确，而这个条件必须成立才能保持碰撞概率较低。\n\n我们现在对这个不等式求解 $L$。我们代入 $N = 4^L$：\n$$ \\frac{n(n-1)}{2 \\cdot 4^L}  \\varepsilon $$\n重新整理不等式以求解 $4^L$：\n$$ 4^L > \\frac{n(n-1)}{2\\varepsilon} $$\n我们代入给定的数值，$n = 10^6$ 和 $\\varepsilon = 10^{-6}$：\n$$ 4^L > \\frac{10^6(10^6 - 1)}{2 \\times 10^{-6}} $$\n鉴于 $n = 10^6$ 很大，$n-1$ 这一项约等于 $n$。使用这个近似简化了计算，而不会影响最终的整数结果：\n$$ 4^L > \\frac{(10^6)^2}{2 \\times 10^{-6}} = \\frac{10^{12}}{2 \\times 10^{-6}} = 0.5 \\times 10^{18} = 5 \\times 10^{17} $$\n为了找到整数 $L$，我们对不等式两边取以 10 为底的对数：\n$$ \\log_{10}(4^L) > \\log_{10}(5 \\times 10^{17}) $$\n$$ L \\log_{10}(4) > \\log_{10}(5) + \\log_{10}(10^{17}) $$\n使用对数性质 $\\log_{10}(4) = 2 \\log_{10}(2)$ 和 $\\log_{10}(5) = \\log_{10}(10/2) = 1 - \\log_{10}(2)$：\n$$ L \\cdot (2 \\log_{10}(2)) > (1 - \\log_{10}(2)) + 17 $$\n$$ L \\cdot (2 \\log_{10}(2)) > 18 - \\log_{10}(2) $$\n求解 $L$：\n$$ L > \\frac{18 - \\log_{10}(2)}{2 \\log_{10}(2)} = \\frac{18}{2 \\log_{10}(2)} - \\frac{\\log_{10}(2)}{2 \\log_{10}(2)} = \\frac{9}{\\log_{10}(2)} - \\frac{1}{2} $$\n使用数值 $\\log_{10}(2) \\approx 0.30103$：\n$$ L > \\frac{9}{0.30103} - 0.5 $$\n$$ L > 29.89735 - 0.5 = 29.39735 $$\n由于 $L$ 必须是整数，严格满足此不等式的最小整数值 $L$ 是 $30$。因此，需要至少 30 个核苷酸的条形码长度才能满足指定的低碰撞概率要求。", "answer": "$$\\boxed{30}$$", "id": "2673506"}, {"introduction": "获得原始测序数据后，下一个关键步骤是将其转化为结构化的基因表达矩阵。这项编码实践 [@problem_id:2673484] 模拟了从原始测序读段到计数矩阵的完整生物信息学流程，包括解析读段结构、校正条形码错误以及使用唯一分子标识符（UMI）去除PCR扩增副本。完成此练习将使您对支撑大多数空间转录组学分析的计算工作流程获得深刻的动手理解。", "problem": "您的任务是为配对末端空间转录组测序读数（reads）实现一个完整且逻辑一致的解复用和计数流程，该流程仿照 10x Genomics Visium 文库结构。目标是通过解析读数结构、在汉明距离阈值下将空间条形码校正至白名单、通过基因-标签字典将读数分配给基因，以及在指定的编辑距离内使用唯一分子标识符邻接性合并聚合酶链式反应（PCR）重复，从而恢复出一个“点-基因”维度的唯一分子标识符（UMI）计数矩阵。\n\n基本原理：\n- 分子生物学中心法则：脱氧核糖核酸（DNA）转录为核糖核酸（RNA），后者被测序；通过使用唯一分子标识符对读数进行去重来推断分子数量，以近似原始分子。\n- 条形码编码与解复用：空间条形码用于识别捕获位置（点），唯一分子标识符用于区分原始分子和扩增重复。\n- 汉明距离：对于等长字符串，汉明距离计算位置上的错配数量，是测序中单核苷酸替换错误的合适误差模型。\n\n定义和要求的行为：\n- 令 $L_b$ 表示包含在读数1（Read 1）中的空间条形码长度，$L_u$ 表示唯一分子标识符长度，令 $L_g$ 表示包含在读数2（Read 2）起始处的基因标签长度。\n- 读数1结构：前 $L_b$ 个核苷酸是空间条形码 $s$，紧接着的 $L_u$ 个核苷酸构成唯一分子标识符 $u$。读数1的其余部分是锚定序列（例如，poly-dT），在本问题中被忽略。\n- 读数2结构：前 $L_g$ 个核苷酸是基因识别标签 $g$（一个在给定字典中唯一识别一个基因的短序列），其后是互补脱氧核糖核酸（cDNA）插入片段，在本问题中被忽略。\n- 等长字符串 $x$ 和 $y$ 之间的汉明距离为 $$d_H(x,y) = \\sum_{i=1}^{|x|} \\mathbf{1}[x_i \\ne y_i],$$ 其中 $\\mathbf{1}[\\cdot]$ 是指示函数， $|x|$ 是字符串长度。\n- 空间条形码校正：给定一个空间条形码白名单集合 $W$，一个原始条形码 $s$ 被校正为与 $s$ 具有最小汉明距离的唯一元素 $w^\\star \\in W$，当且仅当 $\\min_{w \\in W} d_H(s,w) \\le t_b$ 且存在唯一的最小值点；否则，该读数被丢弃。这里 $t_b$ 是一个非负整数阈值。\n- 基因分配：给定一个基因标签字典 $T: \\text{gene} \\mapsto \\text{tag}$，其中标签长度均为 $L_g$，带有标签 $g$ 的读数被分配给唯一的基因 $k^\\star$，该基因的标签与 $g$ 具有最小汉明距离，当且仅当 $\\min_{k \\in \\text{genes}} d_H(g,T(k)) \\le t_g$ 且存在唯一的最小值点；否则，该读数被丢弃。这里 $t_g$ 是一个非负整数阈值。\n- 分组：经过校正和分配后，读数按（点，基因）对进行分组。在每个组内，通过一个由 $d_u$ 参数化的贪婪邻接规则来执行唯一分子标识符的合并：\n  - 令 $C(v)$ 表示组内观察到的唯一分子标识符序列 $v$ 的计数。将未分配的唯一分子标识符集合 $U$ 初始化为组内所有不同的唯一分子标识符序列。将聚类计数初始化为 $0$。\n  - 当 $U$ 非空时，从 $U$ 中选择一个具有最大 $C(\\ell)$ 的领导者（leader）$\\ell$（若计数相同，则选择字典序最小的 $\\ell$）。形成一个聚类，该聚类由 $\\ell$ 以及所有满足 $d_H(\\ell,w) \\le d_u$ 和 $C(w) \\le C(\\ell)$ 的 $w \\in U$ 组成。从 $U$ 中移除已聚类的元素，并将聚类计数加 $1$。\n  - 聚类计数即为该（点，基因）对的去重后分子计数。请注意，当 $d_u = 0$ 时，只有相同的唯一分子标识符序列会合并；当 $d_u \\ge 1$ 时，因测序错误产生的邻近序列可以合并到更丰富的领导者中。\n- 计数矩阵规范：令 $S$ 为空间条形码的白名单，G 为基因标识符集合（$T$ 的键）。输出的计数矩阵维度为 $|S| \\times |G|$，并为 $S$ 中的所有点（即使没有读数映射到）和 $G$ 中的所有基因填充。行按 $S$ 的字典序排序，列按 $G$ 的字典序排序。矩阵第 $i$ 行第 $j$ 列的条目是对应（$\\text{spot}_i$, $\\text{gene}_j$）的去重后唯一分子标识符计数。\n\n实现要求：\n- 完全按照规定实现上述解复用和计数流程，使用汉明距离、带有唯一性和阈值 $t_b$ 及 $t_g$ 的最近邻校正和分配方法，以及带有参数 $d_u$ 和指定的领导者选择及平局打破规则的贪婪唯一分子标识符邻接合并方法。\n- 任何读数1长度小于 $L_b + L_u$ 或读数2长度小于 $L_g$ 的读数都必须被丢弃。\n- 所有阈值 $t_b$、$t_g$ 和 $d_u$ 均为非负整数。\n\n测试套件：\n实现您的程序以运行以下三个测试用例，每个用例由 $(L_b, L_u, L_g, t_b, t_g, d_u)$、一个白名单 $W$、一个基因-标签字典 $T$ 以及一个配对末端读数列表定义，其中每个读数是一个字符串元组 $(\\text{R1}, \\text{R2})$。\n\n- 测试用例1（通用情况，包含校正、允许错配的基因分配和唯一分子标识符邻接）：\n  - 参数: $L_b = 4$, $L_u = 3$, $L_g = 4$, $t_b = 1$, $t_g = 1$, $d_u = 1$。\n  - 白名单 $W$: [\"ACGT\", \"TGCA\", \"GGGG\"]。\n  - 基因标签 $T$: {\"G1\": \"AAAA\", \"G2\": \"CCCC\", \"G3\": \"TTTT\"}。\n  - 配对末端读数：\n    - (\"ACGTAAATT\", \"AAAAAA\")\n    - (\"ACGTAAATT\", \"AAAACC\")\n    - (\"ACGTAATTT\", \"AAAAAA\")\n    - (\"ACGTAACTT\", \"AAAAAA\")\n    - (\"TGTAGGGTT\", \"CCCCGG\")\n    - (\"TGTAGGATT\", \"CCCCAA\")\n    - (\"GGGGTTTTT\", \"TTTTCC\")\n    - (\"GGGGTTACT\", \"TTTCAA\")\n- 测试用例2（条形码平局模糊性、严格的基因分配和带距离的唯一分子标识符合并）：\n  - 参数: $L_b = 4$, $L_u = 2$, $L_g = 3$, $t_b = 1$, $t_g = 0$, $d_u = 1$。\n  - 白名单 $W$: [\"AAAA\", \"AAAT\", \"TTTT\"]。\n  - 基因标签 $T$: {\"X\": \"ATG\", \"Y\": \"CAT\"}。\n  - 配对末端读数：\n    - (\"AAAGCCTT\", \"ATGAAA\")    [条形码模糊：丢弃]\n    - (\"AAAACCTT\", \"ATGCCC\")\n    - (\"AAAACGTT\", \"ATGCCC\")\n    - (\"AAATTTTT\", \"CATGGG\")\n    - (\"AAATTTAA\", \"CATCCC\")\n    - (\"TTTTGGTT\", \"CAGAAA\")    [未识别的基因标签：丢弃]\n- 测试用例3（无校正、精确基因匹配和仅精确唯一分子标识符去重）：\n  - 参数: $L_b = 2$, $L_u = 1$, $L_g = 2$, $t_b = 0$, $t_g = 0$, $d_u = 0$。\n  - 白名单 $W$: [\"AC\", \"GT\"]。\n  - 基因标签 $T$: {\"A\": \"AA\", \"C\": \"CC\"}。\n  - 配对末端读数：\n    - (\"ACATT\", \"AAGG\")\n    - (\"ACATT\", \"AATC\")\n    - (\"ACTTT\", \"AAGG\")\n    - (\"GTGTT\", \"CCGG\")\n    - (\"GAGTT\", \"AAGG\")         [条形码不在白名单中且无校正：丢弃]\n\n最终输出规范：\n- 对于每个测试用例，计算“点-基因”计数矩阵，其行按白名单 $W$ 的字典序排序，列按 $T$ 中基因标识符的字典序排序。\n- 将每个矩阵按行主序（按顺序遍历点，在每个点内按顺序遍历基因）扁平化为一个整数列表。\n- 您的程序应生成单行输出，其中包含三个测试用例的扁平化列表连接而成的单一逗号分隔列表，并用方括号括起来，例如，“[a,b,c,...]”。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上植根于分子生物学和生物信息学的原理，特别涉及空间转录组学数据分析。该问题定义明确，所有参数、算法和边界条件都得到了清晰的定义，包括错误校正、平局打破规则和数据结构的明确规定。语言客观、正式。因此，将提供一个解决方案。\n\n要求的任务是构建一个计算流程，处理来自空间转录组学实验的配对末端测序读数，该实验仿照 10x Genomics Visium 平台，以生成一个空间分辨的基因表达计数矩阵。该过程涉及几个离散的顺序步骤：读数解析、空间条形码错误校正、基因分配和唯一分子标识符（UMI）去重。\n\n首先，必须实现一个函数来计算两个等长字符串 $x$ 和 $y$ 之间的汉明距离 $d_H(x,y)$。它定义为相应位置上字符不同的位置数量：\n$$d_H(x,y) = \\sum_{i=1}^{|x|} \\mathbf{1}[x_i \\ne y_i]$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。该指标是后续错误校正步骤的基础。\n\n主流程对每个配对末端读数 $(\\text{R1}, \\text{R2})$ 按以下步骤进行：\n\n1.  **解析与初始过滤**：首先检查每个读数对的长度是否足够。如果读数1（R1）的长度小于 $L_b + L_u$ 或读数2（R2）的长度小于 $L_g$，则丢弃该读数。其中 $L_b$ 是空间条形码长度，$L_u$ 是UMI长度，$L_g$ 是基因标签长度。如果长度足够，则从R1的前 $L_b$ 个碱基中提取原始空间条形码 $s$，从R1随后的 $L_u$ 个碱基中提取UMI $u$，并从R2的前 $L_g$ 个碱基中提取基因标签 $g$。\n\n2.  **空间条形码校正**：将原始条形码 $s$ 与给定的有效空间条形码白名单 $W$ 进行比较。一个校正后的条形码 $w^\\star \\in W$ 被识别，当且仅当它是白名单中唯一一个与 $s$ 的汉明距离最小的条形码，并且这个最小距离不超过给定的阈值 $t_b$。形式上，如果 $\\min_{w \\in W} d_H(s,w) = d_H(s, w^\\star) \\le t_b$ 并且对于所有 $w' \\in W$ 且 $w' \\ne w^\\star$，$d_H(s, w') > d_H(s, w^\\star)$，则接受 $w^\\star$。如果不存在这样唯一的 $w^\\star$，则丢弃该读数。\n\n3.  **基因分配**：对原始基因标签 $g$ 执行类似的最近邻搜索。将其与所提供的基因-标签字典 $T$ 中的所有标签进行比较。如果某个基因 $k^\\star$ 对应的标签 $T(k^\\star)$ 是唯一一个与 $g$ 的汉明距离最小的标签，并且该距离不大于阈值 $t_g$，则将该基因 $k^\\star$ 分配给该读数。形式上，如果 $\\min_{k \\in \\text{genes}} d_H(g, T(k)) = d_H(g, T(k^\\star)) \\le t_g$ 并且对于所有其他基因 $k' \\ne k^\\star$，$d_H(g, T(k')) > d_H(g, T(k^\\star))$，则进行分配。如果不满足这些条件，则丢弃该读数。\n\n4.  **分组**：成功通过条形码校正和基因分配步骤的读数，将根据其校正后的空间条形码（点）和分配的基因组成的元组，即 $(w^\\star, k^\\star)$，进行分组。收集与每个组相关的所有UMI，用于最后的去重步骤。\n\n5.  **UMI 去重**：在每个 $(w^\\star, k^\\star)$ 组内，我们必须合并那些可能源自同一初始分子但在聚合酶链式反应（PCR）扩增或测序过程中产生错误的UMI。这通过一个由编辑距离阈值 $d_u$ 参数化的贪婪邻接算法来完成。\n    - 首先，对于给定的组，统计每个不同UMI序列 $v$ 的计数 $C(v)$。\n    - 初始化唯一UMI的集合 $U$。\n    - 算法迭代地构建聚类。在每次迭代中，从剩余的未分配UMI集合 $U$ 中选择一个“领导者”（leader）UMI $\\ell$。领导者被选为具有最高计数 $C(\\ell)$ 的UMI。任何计数相同的情况，通过选择字典序最小的UMI字符串来打破平局。\n    - 围绕 $\\ell$ 形成一个聚类，包含 $\\ell$ 本身以及 $U$ 中所有满足两个条件的其他UMI $w$：它们与领导者的汉明距离在阈值之内，$d_H(\\ell, w) \\le d_u$，并且它们的计数小于或等于领导者的计数，$C(w) \\le C(\\ell)$。\n    - 从 $U$ 中移除新形成的聚类中的所有UMI。\n    - 这个过程重复进行，直到 $U$ 为空。形成的总聚类数即为该 $(w^\\star, k^\\star)$ 对的最终去重后分子计数。如果 $d_u = 0$，此过程简化为计算唯一UMI序列的数量。\n\n6.  **计数矩阵构建**：最后，构建一个大小为 $|S| \\times |G|$ 的计数矩阵，其中 $S$ 是所有白名单空间条形码的集合，$G$ 是来自字典 $T$ 的所有基因标识符的集合。行对应于按字典序排列的空间条形码，列对应于按字典序排列的基因标识符。矩阵中的每个条目 $(i, j)$ 都填充了相应 $(\\text{spot}_i, \\text{gene}_j)$ 对的去重后UMI计数。如果某一对没有关联的读数，其计数为 $0$。然后，将所得矩阵按行主序扁平化为一维列表，作为最终输出。此过程应用于所有测试用例，并将最终的扁平化列表连接起来。", "answer": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to run the spatial transcriptomics pipeline on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"params\": (4, 3, 4, 1, 1, 1),\n            \"whitelist\": [\"ACGT\", \"TGCA\", \"GGGG\"],\n            \"gene_tags\": {\"G1\": \"AAAA\", \"G2\": \"CCCC\", \"G3\": \"TTTT\"},\n            \"reads\": [\n                (\"ACGTAAATT\", \"AAAAAA\"), (\"ACGTAAATT\", \"AAAACC\"), (\"ACGTAATTT\", \"AAAAAA\"),\n                (\"ACGTAACTT\", \"AAAAAA\"), (\"TGTAGGGTT\", \"CCCCGG\"), (\"TGTAGGATT\", \"CCCCAA\"),\n                (\"GGGGTTTTT\", \"TTTTCC\"), (\"GGGGTTACT\", \"TTTCAA\"),\n            ]\n        },\n        {\n            \"params\": (4, 2, 3, 1, 0, 1),\n            \"whitelist\": [\"AAAA\", \"AAAT\", \"TTTT\"],\n            \"gene_tags\": {\"X\": \"ATG\", \"Y\": \"CAT\"},\n            \"reads\": [\n                (\"AAAGCCTT\", \"ATGAAA\"), (\"AAAACCTT\", \"ATGCCC\"), (\"AAAACGTT\", \"ATGCCC\"),\n                (\"AAATTTTT\", \"CATGGG\"), (\"AAATTTAA\", \"CATCCC\"), (\"TTTTGGTT\", \"CAGAAA\"),\n            ]\n        },\n        {\n            \"params\": (2, 1, 2, 0, 0, 0),\n            \"whitelist\": [\"AC\", \"GT\"],\n            \"gene_tags\": {\"A\": \"AA\", \"C\": \"CC\"},\n            \"reads\": [\n                (\"ACATT\", \"AAGG\"), (\"ACATT\", \"AATC\"), (\"ACTTT\", \"AAGG\"),\n                (\"GTGTT\", \"CCGG\"), (\"GAGTT\", \"AAGG\"),\n            ]\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        result_matrix = process_reads(\n            case[\"params\"], case[\"whitelist\"], case[\"gene_tags\"], case[\"reads\"]\n        )\n        final_results.extend(result_matrix.flatten())\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef hamming_distance(s1, s2):\n    \"\"\"Calculates the Hamming distance between two strings of equal length.\"\"\"\n    if len(s1) != len(s2):\n        raise ValueError(\"Strings must be of equal length.\")\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\ndef find_best_match(raw_seq, valid_seqs, threshold):\n    \"\"\"Finds the unique best match for a sequence from a list within a threshold.\"\"\"\n    min_dist = float('inf')\n    best_matches = []\n\n    for valid_seq in valid_seqs:\n        dist = hamming_distance(raw_seq, valid_seq)\n        if dist  min_dist:\n            min_dist = dist\n            best_matches = [valid_seq]\n        elif dist == min_dist:\n            best_matches.append(valid_seq)\n\n    if min_dist = threshold and len(best_matches) == 1:\n        return best_matches[0]\n    return None\n    \ndef process_reads(params, whitelist, gene_tags, reads):\n    \"\"\"\n    Processes a single test case of spatial transcriptomics reads.\n    \n    Args:\n        params (tuple): (L_b, L_u, L_g, t_b, t_g, d_u)\n        whitelist (list): A list of valid spatial barcode sequences.\n        gene_tags (dict): A dictionary mapping gene names to tag sequences.\n        reads (list of tuples): A list of (R1, R2) read pairs.\n\n    Returns:\n        numpy.ndarray: The final spot-by-gene count matrix.\n    \"\"\"\n    L_b, L_u, L_g, t_b, t_g, d_u = params\n    \n    # Invert gene_tags for efficient lookup\n    tag_to_gene = {v: k for k, v in gene_tags.items()}\n\n    # Group valid reads by (spot, gene)\n    grouped_umis = {}\n\n    for r1, r2 in reads:\n        # 1. Parsing and Initial Filtering\n        if len(r1)  L_b + L_u or len(r2)  L_g:\n            continue\n        \n        raw_barcode = r1[:L_b]\n        umi = r1[L_b : L_b + L_u]\n        raw_gene_tag = r2[:L_g]\n\n        # 2. Spatial Barcode Correction\n        corrected_barcode = find_best_match(raw_barcode, whitelist, t_b)\n        if corrected_barcode is None:\n            continue\n        \n        # 3. Gene Assignment\n        matched_tag = find_best_match(raw_gene_tag, list(tag_to_gene.keys()), t_g)\n        if matched_tag is None:\n            continue\n        assigned_gene = tag_to_gene[matched_tag]\n        \n        # 4. Grouping\n        key = (corrected_barcode, assigned_gene)\n        if key not in grouped_umis:\n            grouped_umis[key] = []\n        grouped_umis[key].append(umi)\n\n    # Prepare for matrix construction\n    sorted_spots = sorted(whitelist)\n    sorted_genes = sorted(gene_tags.keys())\n    spot_to_idx = {spot: i for i, spot in enumerate(sorted_spots)}\n    gene_to_idx = {gene: i for i, gene in enumerate(sorted_genes)}\n    \n    count_matrix = np.zeros((len(sorted_spots), len(sorted_genes)), dtype=int)\n\n    # 5. UMI Deduplication\n    for (spot, gene), umis in grouped_umis.items():\n        umi_counts = Counter(umis)\n        unassigned_umis = set(umi_counts.keys())\n        cluster_count = 0\n\n        while unassigned_umis:\n            # Select leader: max count, then lexicographically smallest\n            leader = sorted(\n                unassigned_umis,\n                key=lambda u: (-umi_counts[u], u)\n            )[0]\n            \n            cluster = {leader}\n            \n            # Form cluster\n            for other_umi in list(unassigned_umis):\n                if other_umi == leader:\n                    continue\n                if (hamming_distance(leader, other_umi) = d_u and\n                        umi_counts[other_umi] = umi_counts[leader]):\n                    cluster.add(other_umi)\n            \n            unassigned_umis -= cluster\n            cluster_count += 1\n        \n        # 6. Count Matrix Assembly\n        row_idx = spot_to_idx[spot]\n        col_idx = gene_to_idx[gene]\n        count_matrix[row_idx, col_idx] = cluster_count\n        \n    return count_matrix\n\nsolve()\n```", "id": "2673484"}, {"introduction": "在生成初始计数矩阵后，分析人员面临的下一个挑战是通过处理实验假象来确保数据质量。本练习 [@problem_id:2673461] 旨在解决一个普遍存在的问题：环境RNA污染，即来自裂解细胞的背景转录本掩盖了真实的细胞表达信号。您将推导并实现一个强大的统计模型，使用期望最大化（EM）算法来解构混合信号，并估算每个空间位置的污染水平。", "problem": "您的任务是为空间转录组学中的环境核糖核酸（RNA）污染问题，构建并实现一个基于特定原则的估计程序。该问题被构建为一个点特异性表达谱和一个全局环境表达谱之间的凸混合模型。其核心科学基础应始于分子生物学的中心法则（脱氧核糖核酸 $\\rightarrow$ 核糖核酸 $\\rightarrow$ 蛋白质），其中测得的信使RNA可近似基因表达。此外，还有一个经验事实是，在基于液滴或磁珠的分析方法中，唯一分子标识符（UMI）计数可以通过一个抽样模型得到很好的近似，该模型假设单个分子被独立捕获和计数。其原位特性源于空间分辨的捕获点，每个点都有其自身的生物学表达谱，并受到环境转录本一定程度的污染。\n\n数学模型：\n- 设有 $G$ 个基因，索引为 $g \\in \\{1,\\dots,G\\}$，以及一个空间点，索引为 $s$。对于此点，用 $y_{g}$ 表示基因 $g$ 的观测UMI计数，用 $m = \\sum_{g=1}^{G} y_{g}$ 表示该点的总UMI计数。\n- 令 $t_{g}$ 为该点在所有基因上的真实细胞表达谱，满足 $\\sum_{g=1}^{G} t_{g} = 1$ 且 $t_{g} \\ge 0$。\n- 令 $a_{g}$ 为全局环境表达谱，满足 $\\sum_{g=1}^{G} a_{g} = 1$ 且 $a_{g} \\ge 0$。\n- 令 $w \\in [0,1]$ 为该点的未知环境混合权重，代表来自环境RNA的分子比例。\n- 观测模型假设分子捕获是独立的，并且每个点内的分子池是充分混合的。在这些假设下，观测到的UMI计数向量服从多项分布，其试验次数为 $m$，类别概率为 $p_{g} = (1-w) t_{g} + w a_{g}$（对于 $g \\in \\{1,\\dots,G\\}$）。\n\n您的任务：\n1. 基于这些基础，推导一个期望最大化（EM）算法，用以在给定观测计数 $y_{g}$、环境表达谱 $a_{g}$ 和指定的点特异性表达谱 $t_{g}$ 的情况下，估计单个点的环境混合权重 $w$。您不能假设可以使用任何预先推导出的更新步骤公式；必须从一个潜变量模型的完全数据似然函数开始推导，在该模型中，每个分子被分配到环境来源或点特异性来源之一。对 $w$ 使用均匀贝塔先验 $\\mathrm{Beta}(\\alpha,\\beta)$，其中 $\\alpha = 1$ 且 $\\beta = 1$（即，除似然函数外没有正则化），并将EM算法初始化为 $w^{(0)} = 0.5$。您的算法必须迭代直至 $w$ 的绝对变化小于 $\\varepsilon = 10^{-12}$，或达到 $10{,}000$ 次迭代的上限。\n2. 在一个程序中实现您的EM估计器，该程序处理一组固定的测试点集。每个测试用例提供 $G$、一个固定的环境表达谱 $a_{g}$、一个点特异性表达谱 $t_{g}$ 和一个观测计数向量 $y_{g}$。对于每个测试用例，您的程序必须输出估计的环境混合权重 $\\widehat{w}$，格式为浮点数。\n\n测试集：\n- 使用 $G = 5$ 个基因。对所有用例使用相同的环境表达谱：\n  - $a = [0.05, 0.10, 0.20, 0.25, 0.40]$。\n- 用例 1 (典型混合):\n  - $t = [0.30, 0.25, 0.20, 0.15, 0.10]$,\n  - $m = 1000$,\n  - 观测计数 $y = [250, 220, 200, 170, 160]$。\n- 用例 2 (无环境污染):\n  - $t = [0.10, 0.10, 0.20, 0.25, 0.35]$,\n  - $m = 800$,\n  - 观测计数 $y = [80, 80, 160, 200, 280]$。\n- 用例 3 (纯环境):\n  - $t = [0.25, 0.25, 0.20, 0.20, 0.10]$,\n  - $m = 600$,\n  - 观测计数 $y = [30, 60, 120, 150, 240]$。\n- 用例 4 (当 $t=a$ 时的不可识别边界情况):\n  - $t = [0.05, 0.10, 0.20, 0.25, 0.40]$,\n  - $m = 500$,\n  - 观测计数 $y = [25, 50, 100, 125, 200]$。\n  - 在此情况下，由于 $t=a$，似然函数仅依赖于 $p_{g} = a_{g}$ 且对于 $w$ 是平坦的；EM算法的不动点应等于其初始值，即 $0.5$。\n\n角度单位不适用。不使用物理单位。所有比例必须以小数表示。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[0.2,0.0,1.0,0.5]”）。具体来说，请按顺序输出用例1到4的四个估计混合权重 $\\widehat{w}$，每个权重四舍五入到六位小数，并以完全符合Python列表字面量的格式（即“[x1,x2,x3,x4]”）放在一个列表中。", "solution": "所提出的问题是有效的、有科学依据且适定的。它描述了计算生物学中的一个标准问题——使用经典统计方法对混合信号进行解卷积。我们将着手推导所需的期望最大化（EM）算法。\n\n目标是，在给定观测到的唯一分子标识符（UMI）计数 $\\mathbf{y} = (y_1, \\dots, y_G)$、真实细胞表达谱 $\\mathbf{t} = (t_1, \\dots, t_G)$ 和全局环境表达谱 $\\mathbf{a} = (a_1, \\dots, a_G)$ 的条件下，找到环境混合权重 $w$ 的最大后验（MAP）估计。观测计数的模型是一个多项分布，试验次数为 $m = \\sum_{g=1}^G y_g$，混合概率为 $p_g = (1-w)t_g + w a_g$。我们给定 $w$ 的一个均匀贝塔先验 $p(w) = \\mathrm{Beta}(w | \\alpha=1, \\beta=1)$，它在 $w \\in [0,1]$ 上是一个常数函数。因此，MAP估计等价于在该区间内受约束的最大似然估计（MLE）。\n\nEM算法是一种在含有潜变量的模型中寻找MLE或MAP估计的迭代过程。直接最大化观测数据的对数似然函数 $\\mathcal{L}(w|\\mathbf{y}) = \\sum_{g=1}^G y_g \\log((1-w)t_g + w a_g)$ 在代数上是困难的。因此，我们引入潜变量来简化问题。\n\n**1. 潜变量公式和完全数据似然函数**\n\n让我们定义一组潜变量，用以指示每个观测分子的来源。对于每个基因 $g$，观测计数 $y_g$ 是来自真实细胞来源的分子数和来自环境来源的分子数之和。令 $c_g$ 为来自细胞来源的基因 $g$ 的分子数， $d_g$ 为来自环境来源的分子数，使得 $y_g = c_g + d_g$。所有这些计数的集合 $\\mathbf{c}=(c_1, \\dots, c_G)$ 和 $\\mathbf{d}=(d_1, \\dots, d_G)$ 构成了我们的潜数据。完全数据是 $(\\mathbf{y}, \\mathbf{c}, \\mathbf{d})$，这是冗余的；$(\\mathbf{c}, \\mathbf{d})$ 的知识决定了 $\\mathbf{y}$。\n\n来自细胞来源的分子总数为 $C = \\sum_{g=1}^G c_g$，来自环境来源的分子总数为 $D = \\sum_{g=1}^G d_g$。分子总数为 $m = C+D$。从 $m$ 个分子中选择 $D$ 个来自环境来源的事件服从参数为 $w$ 的二项概率。完全数据似然函数，表示给定参数 $w$ 时潜变量计数的联合概率，是基于此建立的。有 $C$ 个分子来自真实表达谱和 $D$ 个分子来自环境的概率正比于 $(1-w)^C w^D$。这些分子在基因间的分布分别服从概率为 $\\mathbf{t}$ 和 $\\mathbf{a}$ 的多项分布。\n\n完全数据对数似然函数，仅考虑依赖于 $w$ 的项，为：\n$$\n\\log L(w | \\mathbf{c}, \\mathbf{d}) = \\left(\\sum_g c_g\\right) \\log(1-w) + \\left(\\sum_g d_g\\right) \\log(w) + \\text{constant}\n$$\n$$\n\\log L(w | C, D) = C \\log(1-w) + D \\log(w) + \\text{constant}\n$$\n问题指定了 $w$ 的一个 $\\mathrm{Beta}(\\alpha=1, \\beta=1)$ 先验。对数先验是 $\\log p(w) = (\\alpha-1)\\log w + (\\beta-1)\\log(1-w) - \\log B(\\alpha, \\beta)$。对于 $\\alpha=1, \\beta=1$，此值为 $\\log p(w) = 0$。因此，完全数据对数后验与完全数据对数似然成正比。\n\n**2. EM算法的推导**\n\nEM算法迭代两个步骤：期望（E-step）和最大化（M-step）。\n\n**E-步：**\n在E-步中，我们计算完全数据对数似然函数在给定观测数据 $\\mathbf{y}$ 和参数的当前估计值 $w^{(k)}$ 条件下的期望。这等价于计算充分统计量（即总潜变量计数 $C$ 和 $D$）的期望。\n$$\nQ(w | w^{(k)}) = E_{\\mathbf{c},\\mathbf{d} | \\mathbf{y}, w^{(k)}}[\\log L(w | \\mathbf{c}, \\mathbf{d})]\n$$\n令 $D^{(k+1)} = E[D | \\mathbf{y}, w^{(k)}]$ 且 $C^{(k+1)} = E[C | \\mathbf{y}, w^{(k)}]$。那么目标函数变为：\n$$\nQ(w | w^{(k)}) = C^{(k+1)} \\log(1-w) + D^{(k+1)} \\log(w) + \\text{constant}\n$$\n为了找到 $D^{(k+1)}$，我们将每个基因的期望潜变量计数相加：$D^{(k+1)} = \\sum_{g=1}^G E[d_g | \\mathbf{y}, w^{(k)}]$。期望 $E[d_g | \\mathbf{y}, w^{(k)}]$ 是对基因 $g$ 的 $y_g$ 个分子中每一个分子的期望求和。对于观测到的一个基因类型为 $g$ 的单分子，其来自环境来源的后验概率由 Bayes' 定理给出：\n$$\nP(\\text{source=ambient} | \\text{gene}=g, w^{(k)}) = \\frac{P(\\text{gene}=g | \\text{source=ambient}) P(\\text{source=ambient} | w^{(k)})}{P(\\text{gene}=g | w^{(k)})}\n$$\n各项为：\n- $P(\\text{gene}=g | \\text{source=ambient}) = a_g$\n- $P(\\text{source=ambient} | w^{(k)}) = w^{(k)}$\n- $P(\\text{gene}=g | w^{(k)}) = P(\\text{gene}=g, \\text{ambient}) + P(\\text{gene}=g, \\text{cellular})$\n  $= P(g|\\text{amb})P(\\text{amb}) + P(g|\\text{cell})P(\\text{cell}) = a_g w^{(k)} + t_g (1-w^{(k)}) = p_g^{(k)}$\n\n因此，后验概率为 $\\frac{w^{(k)} a_g}{p_g^{(k)}}$。由于我们有 $y_g$ 个这样的分子，根据期望的线性性质，基因 $g$ 的期望环境分子数为：\n$$\nd_g^{(k+1)} \\equiv E[d_g | \\mathbf{y}, w^{(k)}] = y_g \\cdot \\frac{w^{(k)} a_g}{(1-w^{(k)})t_g + w^{(k)} a_g}\n$$\n环境分子的总期望数是所有基因的总和：\n$$\nD^{(k+1)} = \\sum_{g=1}^G d_g^{(k+1)} = \\sum_{g=1}^G y_g \\frac{w^{(k)} a_g}{(1-w^{(k)})t_g + w^{(k)} a_g}\n$$\n另外，由于 $C+D=m$，我们有 $C^{(k+1)} = m - D^{(k+1)}$。\n\n**M-步：**\n在M-步中，我们找到使E-步得到的期望对数后验最大化的 $w$ 值。在均匀先验下，这等同于最大化期望对数似然函数 $Q(w|w^{(k)})$。\n$$\nw^{(k+1)} = \\arg\\max_{w \\in [0,1]} \\left( C^{(k+1)} \\log(1-w) + D^{(k+1)} \\log(w) \\right)\n$$\n对 $w$ 求导并令其为零：\n$$\n\\frac{\\partial Q}{\\partial w} = -\\frac{C^{(k+1)}}{1-w} + \\frac{D^{(k+1)}}{w} = 0\n$$\n$$\nD^{(k+1)}(1-w) = C^{(k+1)}w \\implies D^{(k+1)} = (C^{(k+1)} + D^{(k+1)})w = m w\n$$\n这给出了 $w$ 的更新规则：\n$$\nw^{(k+1)} = \\frac{D^{(k+1)}}{m}\n$$\n注意，如果我们使用通用的 $\\mathrm{Beta}(\\alpha, \\beta)$ 先验，M-步将最大化 $(D^{(k+1)} + \\alpha - 1)\\log w + (C^{(k+1)} + \\beta - 1)\\log(1-w)$，从而得到更新规则 $w^{(k+1)} = \\frac{D^{(k+1)} + \\alpha - 1}{m + \\alpha + \\beta - 2}$。对于我们的情况，即 $\\alpha=1, \\beta=1$，该规则简化为MLE更新规则。\n\n**算法总结：**\n1.  初始化 $w^{(0)} = 0.5$。\n2.  对于 $k=0, 1, \\dots$，最多迭代 $10,000$ 次：\n    a.  计算期望的总环境计数 $D^{(k+1)} = \\sum_{g=1}^G y_g \\frac{w^{(k)} a_g}{(1-w^{(k)})t_g + w^{(k)} a_g}$。\n    b.  更新权重 $w^{(k+1)} = \\frac{D^{(k+1)}}{m}$。\n    c.  检查收敛性：如果 $|w^{(k+1)} - w^{(k)}|  10^{-12}$，则终止。\n3.  最终估计值为 $\\widehat{w} = w^{(k+1)}$。\n\n现在将实现此算法以解决给定的测试用例。", "answer": "```python\nimport numpy as np\n\ndef em_estimator(y: np.ndarray, t: np.ndarray, a: np.ndarray, m: int) -> float:\n    \"\"\"\n    Estimates the ambient mixture weight 'w' using an EM algorithm.\n\n    Args:\n        y: Observed UMI counts for G genes.\n        t: Spot's true cellular expression profile.\n        a: Global ambient expression profile.\n        m: Total UMI count in the spot.\n\n    Returns:\n        The estimated ambient mixture weight w_hat.\n    \"\"\"\n    w = 0.5\n    eps = 1e-12\n    max_iter = 10000\n\n    # In the non-identifiable case where t = a, the likelihood is flat w.r.t w.\n    # The EM update rule becomes w_new = w_old, so the algorithm converges\n    # immediately to the initial value. We can return it directly.\n    if np.allclose(t, a):\n        return 0.5\n\n    for _ in range(max_iter):\n        w_old = w\n\n        # E-step: Calculate the expected number of ambient molecules.\n        # The denominator is the mixture probability for each gene.\n        # It is guaranteed to be positive since all t_g and a_g are positive\n        # for w in [0, 1] in the given test cases.\n        p_g = (1.0 - w) * t + w * a\n        \n        # Posterior probability that a molecule of gene g is from ambient source.\n        # We multiply by y_g to get the expected count for that gene.\n        expected_ambient_counts = y * (w * a / p_g)\n        \n        # Sum over all genes to get total expected ambient counts.\n        total_expected_ambient = np.sum(expected_ambient_counts)\n\n        # M-step: Update w.\n        # With a Beta(1,1) prior (uniform), the MAP estimate is the MLE.\n        w = total_expected_ambient / m\n        \n        # Ensure w stays within the valid range [0, 1] due to potential floating point inaccuracies.\n        w = max(0.0, min(1.0, w))\n\n        # Check for convergence.\n        if np.abs(w - w_old)  eps:\n            break\n            \n    return w\n\ndef solve():\n    \"\"\"\n    Runs the EM estimator on the provided test suite and prints the results.\n    \"\"\"\n    # G = 5, but not explicitly needed as arrays are used.\n    # Ambient profile is constant for all cases.\n    a = np.array([0.05, 0.10, 0.20, 0.25, 0.40])\n    \n    test_cases = [\n        # Case 1 (typical mixture)\n        {'t': np.array([0.30, 0.25, 0.20, 0.15, 0.10]),\n         'y': np.array([250, 220, 200, 170, 160]),\n         'm': 1000},\n        # Case 2 (no ambient contamination)\n        {'t': np.array([0.10, 0.10, 0.20, 0.25, 0.35]),\n         'y': np.array([80, 80, 160, 200, 280]),\n         'm': 800},\n        # Case 3 (pure ambient)\n        {'t': np.array([0.25, 0.25, 0.20, 0.20, 0.10]),\n         'y': np.array([30, 60, 120, 150, 240]),\n         'm': 600},\n        # Case 4 (non-identifiable edge case where t = a)\n        {'t': np.array([0.05, 0.10, 0.20, 0.25, 0.40]),\n         'y': np.array([25, 50, 100, 125, 200]),\n         'm': 500}\n    ]\n    \n    results = []\n    for case in test_cases:\n        w_hat = em_estimator(case['y'], case['t'], a, case['m'])\n        # Round the result to six decimal places as required.\n        results.append(round(w_hat, 6))\n        \n    # Format the output as a Python list literal string.\n    # map(str, ...) on the rounded floats will produce the desired format\n    # (e.g., 0.0 instead of 0.000000).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2673461"}]}