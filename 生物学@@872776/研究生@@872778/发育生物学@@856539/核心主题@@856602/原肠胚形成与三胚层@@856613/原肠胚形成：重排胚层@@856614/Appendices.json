{"hands_on_practices": [{"introduction": "现代成像技术，如粒子图像测速法（PIV），使我们能够以前所未有的细节观察原肠胚形成过程中的细胞运动。这个动手实践将指导您如何将这些原始的速度场数据转化为基本的力学量，例如应变率和剪切率。通过运用连续介质力学的框架，您将学会识别组织中的汇聚和延伸区域，并将这些宏观形变与细胞层面的重排事件关联起来。[@problem_id:2640076]", "problem": "给定在原肠胚形成过程中的汇聚延伸期间，通过粒子图像测速（PIV）获得的二维欧拉组织速度场。将组织建模为平面连续介质，其速度场为 $\\mathbf{v}(x,y) = (u(x,y), v(x,y))$。运动变形率张量（对称应变率张量）定义为\n$$\n\\mathbf{D} = \\frac{1}{2}\\left(\\nabla \\mathbf{v} + \\nabla \\mathbf{v}^{\\mathsf{T}}\\right),\n$$\n其中\n$$\n\\nabla \\mathbf{v} =\n\\begin{bmatrix}\n\\frac{\\partial u}{\\partial x}  \\frac{\\partial u}{\\partial y}\\\\\n\\frac{\\partial v}{\\partial x}  \\frac{\\partial v}{\\partial y}\n\\end{bmatrix}.\n$$\n定义散度 $\\delta = \\mathrm{tr}(\\mathbf{D}) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}$ 和偏张量 $\\mathbf{D}' = \\mathbf{D} - \\frac{1}{2}\\delta\\,\\mathbf{I}$，其中 $\\mathbf{I}$ 是二维单位张量。通过第二不变量定义标量剪切率大小\n$$\n\\dot{\\gamma} = \\sqrt{2\\,\\mathbf{D}':\\mathbf{D}'},\n$$\n其中 $:$ 表示双点积。使用这些不变量，通过两个阈值将每个网格点分类到不同区域：一个无量纲比率 $\\rho  0$ 和一个噪声基底 $\\varepsilon \\ge 0$，\n- 如果 $\\dot{\\gamma} \\ge \\rho\\,|\\delta|$ 且 $\\dot{\\gamma} \\ge \\varepsilon$，则为剪切主导，\n- 如果 $\\delta \\le -\\varepsilon$ 且 $|\\delta|  \\rho\\,\\dot{\\gamma}$，则为压缩主导，\n- 否则为两者皆非。\n\n假设速度分量 $u$ 和 $v$ 在一个均匀矩形网格上提供，沿 $x$ 和 $y$ 方向的间距分别为 $\\Delta x$ 和 $\\Delta y$。使用二阶中心差分计算内部点，使用一阶单侧差分计算边界点，以近似偏导数。一个细胞嵌入事件列表以点坐标 $(x_e, y_e)$ 的形式提供，其坐标系与速度场相同；通过最近邻分配将这些事件与最近的网格节点的分类关联起来。\n\n您的程序必须为每个测试用例计算：\n- 位于剪切主导区域的嵌入事件的比例，\n- 位于压缩主导区域的嵌入事件的比例。\n\n比例是无量纲的，并且必须四舍五入到三位小数进行报告。\n\n您可以假设的基本原理：\n- 在介观尺度上，经历原肠胚形成的上皮组织可以被视为连续介质；速度梯度 $\\mathbf{D}$ 的对称部分捕捉了瞬时组织应变率。\n- 粒子图像测速（PIV）产生一个欧拉速度场 $\\mathbf{v}(x,y)$。\n- 有限差分在均匀网格上一致地近似空间导数。\n\n不涉及角度单位。速度场单位为微米/分钟，网格坐标单位为微米，应变率不变量单位为/分钟。所要求的输出比例是无量纲的。\n\n测试套件：\n对于所有用例，使用一个方形网格，其中 $N_x = 21$，$N_y = 21$，$x \\in \\{-10,-9,\\dots,10\\}$ 微米，$y \\in \\{-10,-9,\\dots,10\\}$ 微米，$\\Delta x = 1$ 微米，$\\Delta y = 1$ 微米。对于每个用例，按规定构造 $u(x,y)$ 和 $v(x,y)$。\n\n- 测试用例 1（汇聚延伸，保持面积的拉伸剪切）：\n  - 参数 $a = 0.1$ /分钟。\n  - 速度场: $u(x,y) = -a\\,x$, $v(x,y) = a\\,y$。\n  - 阈值: $\\rho = 1.0$, $\\varepsilon = 10^{-6}$ /分钟。\n  - 嵌入事件（微米）: $\\{(0,0), (1,0), (-1,0), (0,1), (2,-1), (-2,1)\\}$。\n\n- 测试用例 2（各向同性压缩）：\n  - 参数 $k = 0.05$ /分钟。\n  - 速度场: $u(x,y) = -k\\,x$, $v(x,y) = -k\\,y$。\n  - 阈值: $\\rho = 1.0$, $\\varepsilon = 10^{-6}$ /分钟。\n  - 嵌入事件（微米）: $\\{(5,5), (-5,-5), (3,-7), (0,0), (9,-2)\\}$。\n\n- 测试用例 3（简单剪切）：\n  - 参数 $s = 0.08$ /分钟。\n  - 速度场: $u(x,y) = s\\,y$, $v(x,y) = 0$。\n  - 阈值: $\\rho = 2.0$, $\\varepsilon = 0.01$ /分钟。\n  - 嵌入事件（微米）: $\\{(-6,0), (0,5), (7,-3), (2,2)\\}$。\n\n- 测试用例 4（各向同性扩张，既非剪切也非压缩的边界情况）：\n  - 参数 $k = 0.06$ /分钟。\n  - 速度场: $u(x,y) = k\\,x$, $v(x,y) = k\\,y$。\n  - 阈值: $\\rho = 1.0$, $\\varepsilon = 10^{-6}$ /分钟。\n  - 嵌入事件（微米）: $\\{(0,0), (8,8)\\}$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表形式的结果，该列表用方括号括起来，每个测试用例贡献一个 $[\\text{fraction\\_shear}, \\text{fraction\\_compression}]$ 顺序的双元素列表，每个分数都四舍五入到三位小数。例如，两个用例的有效输出将类似于 $[[0.500,0.250],[1.000,0.000]]$。", "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上基于连续介质力学和发育生物学，在数学上是适定的，并以客观、明确的语言呈现。为获得唯一解所需的所有必要数据、模型和边界条件均已提供。我们可以继续。\n\n基本任务是根据生物组织的速度场 $\\mathbf{v}(x,y) = (u(x,y), v(x,y))$ 对其变形状态进行分类，该组织被建模为二维连续介质。然后，该分类用于分析特定生物事件（即细胞嵌入）的环境。\n\n解决方法包括以下步骤：\n1.  建立一个离散的计算网格来表示连续域。问题指定了一个 $N_x=21 \\times N_y=21$ 点的均匀网格，其中 $x \\in \\{-10, -9, \\dots, 10\\}$ 和 $y \\in \\{-10, -9, \\dots, 10\\}$，对应的网格间距为 $\\Delta x = 1$ 微米和 $\\Delta y = 1$ 微米。\n2.  将每个测试用例的解析速度场 $(u(x,y), v(x,y))$ 采样到此网格上。\n3.  在每个网格点计算速度梯度张量 $\\nabla \\mathbf{v}$。问题指定了一种数值微分方案：内部点使用二阶中心差分，边界点使用一阶单侧差分。该方案可以方便地使用 `numpy.gradient` 函数并附带 `edge_order=1` 参数来实现。梯度的分量为：\n    $$\n    \\nabla \\mathbf{v} =\n    \\begin{bmatrix}\n    \\frac{\\partial u}{\\partial x}  \\frac{\\partial u}{\\partial y}\\\\\n    \\frac{\\partial v}{\\partial x}  \\frac{\\partial v}{\\partial y}\n    \\end{bmatrix}\n    $$\n4.  从速度梯度中，我们计算两个关键的运动不变量：散度 $\\delta$ 和标量剪切率大小 $\\dot{\\gamma}$。\n    - 散度 $\\delta$ 是变形率张量 $\\mathbf{D} = \\frac{1}{2}(\\nabla \\mathbf{v} + \\nabla \\mathbf{v}^{\\mathsf{T}})$ 的迹，可简化为速度梯度本身的迹：\n      $$\n      \\delta = \\mathrm{tr}(\\mathbf{D}) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}\n      $$\n      这个标量衡量了局部面积变化率（$\\delta > 0$ 表示扩张，$\\delta  0$ 表示压缩）。\n    - 标量剪切率大小 $\\dot{\\gamma}$ 是根据偏变形率张量 $\\mathbf{D}' = \\mathbf{D} - \\frac{1}{2}\\delta\\,\\mathbf{I}$ 的第二不变量定义的。其定义为 $\\dot{\\gamma} = \\sqrt{2\\,\\mathbf{D}':\\mathbf{D}'}$，其中 $:$ 表示双点积。直接计算可以得到一个更方便的用速度导数表示的公式：\n      $$\n      \\dot{\\gamma} = \\sqrt{\\left(\\frac{\\partial u}{\\partial x} - \\frac{\\partial v}{\\partial y}\\right)^2 + \\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right)^2}\n      $$\n      这个标量衡量了在恒定面积下形状变化（剪切）的速率大小。\n5.  使用计算出的 $\\delta$ 和 $\\dot{\\gamma}$ 场以及给定的阈值 $\\rho$ 和 $\\varepsilon$，将每个网格点分类到三个区域之一：\n    - 剪切主导：如果 $\\dot{\\gamma} \\ge \\rho\\,|\\delta|$ 且 $\\dot{\\gamma} \\ge \\varepsilon$。\n    - 压缩主导：如果 $\\delta \\le -\\varepsilon$ 且 $|\\delta| > \\rho\\,\\dot{\\gamma}$。\n    - 否则，分类为‘两者皆非’。\n    因此，为整个域生成了一个分类图。\n6.  将给定的位于坐标 $(x_e, y_e)$ 的细胞嵌入事件与分类区域相关联。这是通过最近邻分配完成的。对于位于 $(x_e, y_e)$ 的事件，找到最近的网格节点，并将该节点的分类分配给该事件。由于网格节点和事件位置都以整数坐标给出，因此位于 $(x_e, y_e)$ 的事件恰好与相同坐标的网格节点重合。坐标对 $(x,y)$ 的网格索引 $(i,j)$ 由以下映射确定：\n    $$\n    i = x - x_{\\min} = x + 10\n    $$\n    $$\n    j = y - y_{\\min} = y + 10\n    $$\n7.  最后，对于每个测试用例，我们计算落入剪切主导区域（$N_{shear}$）和压缩主导区域（$N_{compression}$）的事件数量。然后按如下方式计算所需的分数：\n    $$\n    f_{shear} = \\frac{N_{shear}}{N_{total}}, \\quad f_{compression} = \\frac{N_{compression}}{N_{total}}\n    $$\n    其中 $N_{total}$ 是嵌入事件的总数。根据要求，这些分数四舍五入到三位小数。此过程系统地应用于所有提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tissue mechanics problem by computing deformation invariants,\n    classifying grid points, and analyzing intercalation event locations.\n    \"\"\"\n\n    # Grid definition, constant for all test cases\n    Nx, Ny = 21, 21\n    x_min, x_max = -10, 10\n    y_min, y_max = -10, 10\n    dx, dy = 1.0, 1.0\n\n    x_coords = np.arange(x_min, x_max + 1, dx)\n    y_coords = np.arange(y_min, y_max + 1, dy)\n    \n    # Using 'ij' indexing so that the first axis of arrays corresponds to x\n    # and the second to y.\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n    test_cases = [\n        {\n            \"name\": \"Test Case 1 (Convergent Extension)\",\n            \"params\": {\"a\": 0.1},\n            \"u_func\": lambda x, y, p: -p[\"a\"] * x,\n            \"v_func\": lambda x, y, p: p[\"a\"] * y,\n            \"rho\": 1.0,\n            \"epsilon\": 1e-6,\n            \"events\": [(0, 0), (1, 0), (-1, 0), (0, 1), (2, -1), (-2, 1)],\n        },\n        {\n            \"name\": \"Test Case 2 (Isotropic Compression)\",\n            \"params\": {\"k\": 0.05},\n            \"u_func\": lambda x, y, p: -p[\"k\"] * x,\n            \"v_func\": lambda x, y, p: -p[\"k\"] * y,\n            \"rho\": 1.0,\n            \"epsilon\": 1e-6,\n            \"events\": [(5, 5), (-5, -5), (3, -7), (0, 0), (9, -2)],\n        },\n        {\n            \"name\": \"Test Case 3 (Simple Shear)\",\n            \"params\": {\"s\": 0.08},\n            \"u_func\": lambda x, y, p: p[\"s\"] * y,\n            \"v_func\": lambda x, y, p: 0 * x, # Keep it as a 2D array\n            \"rho\": 2.0,\n            \"epsilon\": 0.01,\n            \"events\": [(-6, 0), (0, 5), (7, -3), (2, 2)],\n        },\n        {\n            \"name\": \"Test Case 4 (Isotropic Expansion)\",\n            \"params\": {\"k\": 0.06},\n            \"u_func\": lambda x, y, p: p[\"k\"] * x,\n            \"v_func\": lambda x, y, p: p[\"k\"] * y,\n            \"rho\": 1.0,\n            \"epsilon\": 1e-6,\n            \"events\": [(0, 0), (8, 8)],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        params = case[\"params\"]\n        rho = case[\"rho\"]\n        epsilon = case[\"epsilon\"]\n        events = case[\"events\"]\n\n        # 1. Generate velocity fields on the grid\n        u = case[\"u_func\"](xx, yy, params)\n        v = case[\"v_func\"](xx, yy, params)\n\n        # 2. Compute partial derivatives using specified finite difference rules\n        # np.gradient with edge_order=1 uses 2nd-order central differences in the\n        # interior and 1st-order one-sided differences at the boundaries.\n        # The return order is [derivative_along_axis_0, derivative_along_axis_1, ...].\n        # Due to `indexing='ij'`, axis 0 is x and axis 1 is y.\n        dudx, dudy = np.gradient(u, dx, dy, edge_order=1)\n        dvdx, dvdy = np.gradient(v, dx, dy, edge_order=1)\n\n        # 3. Calculate kinematic invariants: divergence (delta) and shear rate (gamma_dot)\n        delta = dudx + dvdy\n        gamma_dot = np.sqrt((dudx - dvdy)**2 + (dudy + dvdx)**2)\n\n        # 4. Classify each grid point\n        is_shear_dominated = (gamma_dot >= rho * np.abs(delta))  (gamma_dot >= epsilon)\n        is_compression_dominated = (delta = -epsilon)  (np.abs(delta) > rho * gamma_dot)\n\n        # 5. Correlate intercalation events with grid classifications\n        shear_event_count = 0\n        compression_event_count = 0\n        total_events = len(events)\n        \n        if total_events == 0:\n            results.append([0.0, 0.0])\n            continue\n\n        for xe, ye in events:\n            # Map event coordinates to grid indices.\n            # Grid runs from -10 to 10, so index i corresponds to x = i - 10.\n            # Thus, for a given coordinate x, the index is i = x + 10.\n            # Event coordinates are integers, so they fall exactly on grid nodes.\n            ix = int(round(xe - x_min))\n            iy = int(round(ye - y_min))\n\n            if is_shear_dominated[ix, iy]:\n                shear_event_count += 1\n            elif is_compression_dominated[ix, iy]:\n                compression_event_count += 1\n        \n        # 6. Calculate fractions\n        frac_shear = shear_event_count / total_events\n        frac_compression = compression_event_count / total_events\n        \n        results.append([frac_shear, frac_compression])\n\n    # 7. Format final output string\n    formatted_results = [f\"[{r[0]:.3f},{r[1]:.3f}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2640076"}, {"introduction": "在量化了组织流动之后，我们转而探究维持组织完整性的内在力量。本练习将引导您应用“差异粘附假说”（Differential Adhesion Hypothesis），建立一个简洁而深刻的模型，将特定分子（E-cadherin）的密度与一个宏观物理性质——组织表面张力——联系起来。通过这个练习，您将理解表面张力如何在胚胎外包等形态发生运动中扮演关键角色，并学会如何从分子层面的变化预测组织行为的改变。[@problem_id:2640043]", "problem": "在一个经历原肠胚形成过程中外包运动的脊椎动物胚胎中，胚盘作为一个内聚的上皮片层在卵黄细胞上铺展开来。内聚力由上皮钙粘蛋白（E-cadherin）介导，而涌现出的有效组织表面张力（用 $\\Gamma$ 表示）是一种抵抗组织边界面积扩张和曲率变化的集体属性。考虑一个基于差异性粘附假说（Differential Adhesion Hypothesis, DAH）的最小化、力学上一致的描述，其中单位面积上功能性E-cadherin键的密度 $\\rho_{\\text{cad}}$ 被视为控制内聚力的主要微观变量。题目告知，对于小扰动以及固定的细胞骨架收缩性和几何形状，组织层面的表面张力与钙粘蛋白键的密度成线性比例关系，即 $\\Gamma$ 与 $\\rho_{\\text{cad}}$ 成正比。胚盘被近似为一个具有恒定曲率的薄片，因此对铺展的毛细阻力由 Young–Laplace 关系描述，其压降为 $\\Delta P = \\Gamma \\kappa$，其中 $\\kappa$ 是平均曲率。\n\n一项实验操作将功能性 E-cadherin 键的密度降低到其基线值的一半，而不改变其几何形状或主动的伸出牵引力。设 $\\rho_{\\text{cad},0}$ 和 $\\Gamma_{0}$ 分别表示钙粘蛋白键密度和表面张力的基线值，$\\rho_{\\text{cad},1}$ 和 $\\Gamma_{1}$ 表示操作后的值。仅使用上述基本假设和关系，计算新的表面张力 $\\Gamma_{1}$（用 $\\Gamma_{0}$ 表示）。然后，根据在固定 $\\kappa$ 下 $\\Delta P$ 变化的符号，定性预测对铺展的净阻力是增加还是减少。最终答案只需报告用 $\\Gamma_{0}$ 表示 $\\Gamma_{1}$ 的符号表达式。无需四舍五入。最终答案中不应包含单位。", "solution": "首先将验证问题陈述的正确性和可解性。\n\n从问题陈述中提取的已知条件如下：\n1.  组织表面张力 $\\Gamma$ 与 E-cadherin 键的密度 $\\rho_{\\text{cad}}$ 成线性比例关系。这表述为 $\\Gamma$ 与 $\\rho_{\\text{cad}}$ 成正比，可写作 $\\Gamma \\propto \\rho_{\\text{cad}}$。\n2.  对铺展的毛细阻力由 Young–Laplace 关系描述，$\\Delta P = \\Gamma \\kappa$，其中 $\\Delta P$ 是压降，$\\kappa$ 是平均曲率。\n3.  一项实验操作将功能性 E-cadherin 键的密度降低到其基线值的一半。\n4.  基线值表示为 $\\rho_{\\text{cad},0}$ 和 $\\Gamma_{0}$。\n5.  操作后的值表示为 $\\rho_{\\text{cad},1}$ 和 $\\Gamma_{1}$。\n6.  该操作意味着关系式 $\\rho_{\\text{cad},1} = \\frac{1}{2} \\rho_{\\text{cad},0}$。\n7.  在比较过程中，假定几何形状（以及因此的平均曲率 $\\kappa$）和主动伸出牵引力是固定的。\n\n该问题具有科学依据，借鉴了差异性粘附假说和像 Young-Laplace 方程这样的标准生物物理组织力学模型。E-cadherin 介导的内聚力和组织表面张力的概念是发育生物学的核心。该问题提法明确，提供了一个清晰的数学关系和一个特定的扰动，可以从中推导出唯一的答案。语言客观，设置内部一致。计算所需的所有信息均已提供。因此，该问题是有效的，可以构建一个解决方案。\n\n问题的核心在于所陈述的组织表面张力 $\\Gamma$ 与功能性 E-cadherin 键密度 $\\rho_{\\text{cad}}$ 之间的线性正比关系。这种关系可以数学地表示为：\n$$\n\\Gamma = k \\cdot \\rho_{\\text{cad}}\n$$\n其中 $k$ 是一个比例常数。根据问题陈述，这个常数 $k$ 包含了其他生物力学参数，如细胞骨架收缩性和键的性质，这些参数被假定为固定的。\n\n我们可以为基线（初始）状态和操作后（最终）状态写出这个关系式。\n对于基线状态，用下标 $0$ 表示：\n$$\n\\Gamma_{0} = k \\cdot \\rho_{\\text{cad},0}\n$$\n对于操作后状态，用下标 $1$ 表示：\n$$\n\\Gamma_{1} = k \\cdot \\rho_{\\text{cad},1}\n$$\n问题陈述指出，实验操作将 E-cadherin 键密度降低到其基线值的一半。这提供了以下关系：\n$$\n\\rho_{\\text{cad},1} = \\frac{1}{2} \\rho_{\\text{cad},0}\n$$\n我们现在可以将 $\\rho_{\\text{cad},1}$ 的这个表达式代入 $\\Gamma_{1}$ 的方程中：\n$$\n\\Gamma_{1} = k \\cdot \\left(\\frac{1}{2} \\rho_{\\text{cad},0}\\right)\n$$\n通过重新排列各项，我们得到：\n$$\n\\Gamma_{1} = \\frac{1}{2} \\left(k \\cdot \\rho_{\\text{cad},0}\\right)\n$$\n我们认出括号中的项 $k \\cdot \\rho_{\\text{cad},0}$ 是基线表面张力 $\\Gamma_{0}$ 的表达式。因此，我们可以将 $\\Gamma_{0}$ 代入方程中：\n$$\n\\Gamma_{1} = \\frac{1}{2} \\Gamma_{0}\n$$\n这个结果表明，新的表面张力 $\\Gamma_{1}$ 是原始表面张力 $\\Gamma_{0}$ 的一半。\n\n问题的第二部分要求预测对铺展的净阻力的变化。该阻力与来自 Young-Laplace 关系的压降 $\\Delta P$ 相关，$\\Delta P = \\Gamma \\kappa$。由于曲率 $\\kappa$ 被声明为固定的，$\\Delta P$ 的变化仅由 $\\Gamma$ 的变化决定。\n新的压降是 $\\Delta P_{1} = \\Gamma_{1} \\kappa$。代入我们关于 $\\Gamma_{1}$ 的结果：\n$$\n\\Delta P_{1} = \\left(\\frac{1}{2} \\Gamma_{0}\\right) \\kappa = \\frac{1}{2} (\\Gamma_{0} \\kappa)\n$$\n由于原始压降为 $\\Delta P_{0} = \\Gamma_{0} \\kappa$，我们发现 $\\Delta P_{1} = \\frac{1}{2} \\Delta P_{0}$。压降的变化是负的（$\\Delta P_1  \\Delta P_0$）。由于 $\\Delta P$ 代表对铺展的毛细阻力，$\\Delta P$ 的减少意味着净阻力的减少。因此，在 E-cadherin 减少后，组织铺展受到的阻力较小。\n\n按照要求，最终答案仅为用 $\\Gamma_{0}$ 表示 $\\Gamma_{1}$ 的符号表达式。", "answer": "$$\n\\boxed{\\frac{1}{2} \\Gamma_{0}}\n$$", "id": "2640043"}, {"introduction": "掌握了分析组织运动和理解其分子基础的方法后，最后一步是构建能够预测形态发生的计算模型。本练习将指导您建立一个上皮凹陷的力学模型，并运用全局敏感性分析这一强大工具，来判断顶端张力（apical tension）和细胞弹性（cell elasticity）等生物物理参数中，哪一个对最终的凹陷深度影响最大。这项技能对于设计能够有效检验模型并揭示关键生物调控因子的实验至关重要。[@problem_id:2640039]", "problem": "你的任务是编写一个完整的、可运行的程序，对原肠胚形成过程中上皮内陷深度的一个极简、基于力学的模型进行全局敏感性分析。内陷深度（记为 $D$）被建模为单位长度顶端张力（记为 $T_a$）和细胞整体弹性（杨氏模量，记为 $E$）的确定性函数。目标是在指定独立不确定性范围内，计算 $T_a$ 和 $E$ 的一阶和全效应 Sobol 敏感性指数，然后为每个测试用例确定哪个参数应被更精确地测量（即具有较大全效应指数的参数）。\n\n从以下基本原则出发：\n- 弹性响应缩放：准静态载荷下的变形与驱动应力或张力与刚度的比值成比例。在上皮组织中，顶端收缩张力 $T_a$ 与整体刚度 $E$ 相互作用，从而确定一个特征变形长度。\n- 小应变下的胡克式线弹性行为和饱和的几何响应意味着，内陷深度是变形长度与特征几何长度的无量纲比值的单调递增饱和函数。\n- 使用 Sobol 指数的全局敏感性分析，在假设输入独立的前提下，将输出方差分解为来自每个输入及其相互作用的贡献。\n\n模型定义：\n- 设内陷深度由下式给出\n$$\nD(T_a, E) \\;=\\; L_{\\max}\\left(1 - \\exp\\!\\left[-\\,k\\,\\frac{\\left(T_a/E\\right)}{L_c}\\right]\\right),\n$$\n其中 $L_{\\max}$ 是深度的几何上限，$L_c$ 是一个特征长度尺度，$k$ 是一个无量纲的几何因子。指数的参数是无量纲的，因为 $\\left(T_a/E\\right)$ 的单位是长度，并且它被 $L_c$ 归一化。\n\n单位与换算：\n- $T_a$ 以纳牛顿每微米 $\\left(\\mathrm{nN}/\\mu\\mathrm{m}\\right)$ 表示，$E$ 以千帕斯卡 $\\left(\\mathrm{kPa}\\right)$ 表示，$L_{\\max}$ 和 $L_c$ 以微米 $\\left(\\mu\\mathrm{m}\\right)$ 表示。你的程序在计算 $D$ 之前必须将单位转换为国际单位制（SI）：\n    - $1\\,\\mathrm{nN}/\\mu\\mathrm{m} = 10^{-3}\\,\\mathrm{N/m}$，\n    - $1\\,\\mathrm{kPa} = 10^{3}\\,\\mathrm{Pa}$，\n    - $1\\,\\mu\\mathrm{m} = 10^{-6}\\,\\mathrm{m}$。\n- 尽管 $D$ 的单位是长度，但你不需要报告 $D$ 的值。Sobol 指数是无量纲的，只需要报告这些指数。\n\n每个测试用例需计算的 Sobol 指数：\n- 输入 $X_i \\in \\{T_a, E\\}$ 的一阶 Sobol 指数：\n$$\nS_i \\;=\\; \\frac{\\mathrm{Var}_{X_i}\\left(\\,\\mathbb{E}\\left[D \\mid X_i\\right]\\right)}{\\mathrm{Var}(D)}.\n$$\n- 输入 $X_i$ 的全效应 Sobol 指数：\n$$\nS_{T_i} \\;=\\; 1 - \\frac{\\mathrm{Var}_{X_{\\sim i}}\\left(\\,\\mathbb{E}\\left[D \\mid X_{\\sim i}\\right]\\right)}{\\mathrm{Var}(D)}.\n$$\n\n需要实现的蒙特卡洛估计器 (Saltelli–Sobol pick-freeze法)：\n- 为 $(T_a, E)$ 生成两个大小为 $N \\times 2$ 的独立样本矩阵 $A$ 和 $B$，每个输入在其指定范围内进行独立均匀采样。通过将 $A$ 的第 $i$ 列替换为 $B$ 的第 $i$ 列来构造 $A_{B}^{(i)}$。\n- 令 $f(\\cdot) = D(\\cdot)$，并定义 $f_A = f(A)$、$f_B = f(B)$ 和 $f_{A_{B}^{(i)}} = f(A_{B}^{(i)})$。\n- 使用以下无偏估计量：\n$$\n\\mathrm{Var}(D) \\approx \\widehat{V} \\;=\\; \\mathrm{Var}\\left(\\{f_A\\} \\cup \\{f_B\\}\\right),\n$$\n$$\nS_i \\approx \\widehat{S}_i \\;=\\; \\frac{\\frac{1}{N}\\sum_{j=1}^{N} f_B^{(j)}\\left(f_{A_{B}^{(i)}}^{(j)} - f_A^{(j)}\\right)}{\\widehat{V}},\n$$\n$$\nS_{T_i} \\approx \\widehat{S}_{T_i} \\;=\\; \\frac{\\frac{1}{2N}\\sum_{j=1}^{N}\\left(f_A^{(j)} - f_{A_{B}^{(i)}}^{(j)}\\right)^2}{\\widehat{V}}.\n$$\n\n优先级规则：\n- 对于每个测试用例，优先考虑具有较大全效应指数的参数。如果 $\\left|\\widehat{S}_{T_{T_a}} - \\widehat{S}_{T_{E}}\\right| \\le 10^{-6}$，则输出一个表示平局的代码。\n\n随机性、样本大小和舍入：\n- 使用固定的伪随机种子，其值为 $12345$。\n- 每个测试用例使用 $N = 40000$ 个蒙特卡洛样本。\n- 报告所有 Sobol 指数，保留三位小数。将优先级报告为整数代码：$1$ 代表 $T_a$，$2$ 代表 $E$，$0$ 代表根据上述规则的平局。\n\n所有测试共享的常量：\n- $L_{\\max} = 25\\,\\mu\\mathrm{m}$，\n- $L_c = 5\\,\\mu\\mathrm{m}$，\n- $k = 2$ (无量纲)。\n\n测试套件（每个输入均为独立均匀分布）：\n- 案例 $1$（理想路径）：$T_a \\sim \\mathcal{U}\\left([0.2,\\,0.8]\\,\\mathrm{nN}/\\mu\\mathrm{m}\\right)$，$E \\sim \\mathcal{U}\\left([0.5,\\,2.0]\\,\\mathrm{kPa}\\right)$。\n- 案例 $2$（窄范围，近线性区域）：$T_a \\sim \\mathcal{U}\\left([0.45,\\,0.55]\\,\\mathrm{nN}/\\mu\\mathrm{m}\\right)$，$E \\sim \\mathcal{U}\\left([1.0,\\,1.1]\\,\\mathrm{kPa}\\right)$。\n- 案例 $3$（弹性主导的不确定性）：$T_a \\sim \\mathcal{U}\\left([0.3,\\,0.5]\\,\\mathrm{nN}/\\mu\\mathrm{m}\\right)$，$E \\sim \\mathcal{U}\\left([0.2,\\,3.0]\\,\\mathrm{kPa}\\right)$。\n- 案例 $4$（张力主导的不确定性）：$T_a \\sim \\mathcal{U}\\left([0.1,\\,1.5]\\,\\mathrm{nN}/\\mu\\mathrm{m}\\right)$，$E \\sim \\mathcal{U}\\left([1.0,\\,1.2]\\,\\mathrm{kPa}\\right)$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含所有测试用例的汇总结果，形式为方括号内由逗号分隔的列表。对于每个测试用例，按以下顺序输出五个值：$\\widehat{S}_{T_a}$、$\\widehat{S}_{E}$、$\\widehat{S}_{T_{T_a}}$、$\\widehat{S}_{T_{E}}$、优先级代码。将这些每个用例的结果连接成一个单一的扁平列表。例如，一个包含两个假设案例的输出可能看起来像 $[0.123,0.877,0.200,0.900,2,0.400,0.600,0.450,0.700,2]$。所有 Sobol 指数必须四舍五入到三位小数，优先级代码必须是指定的整数。不应打印任何额外文本。", "solution": "所提供的问题陈述已经过严格验证，并被确定为有效。它具有科学依据、问题良构、客观，并包含获得唯一且可验证解所需的所有信息。其基础模型是一个复杂的生物物理过程为了计算练习目的而进行的合理简化，并且所用的敏感性分析方法是标准方法。\n\n目标是对上皮内陷深度 $D$ 的确定性模型进行全局敏感性分析，该模型是顶端张力 $T_a$ 和细胞整体弹性 $E$ 的函数。此分析旨在量化每个输入参数对模型输出 $D$ 方差的贡献。该分析将使用 Sobol 指数进行，这些指数是通过基于 Saltelli-Sobol “pick-freeze”方案的蒙特卡洛模拟来计算的。\n\n内陷深度 $D$ 的模型由下式给出：\n$$\nD(T_a, E) = L_{\\max}\\left(1 - \\exp\\left[-k \\frac{(T_a/E)}{L_c}\\right]\\right)\n$$\n提供的常量为 $L_{\\max} = 25\\,\\mu\\mathrm{m}$、$L_c = 5\\,\\mu\\mathrm{m}$ 以及无量綱因子 $k = 2$。\n\n关键的第一步是通过将所有参数转换为国际单位制（SI）来确保量纲一致性。输入参数以混合单位给出：$T_a$ 的单位是 $\\mathrm{nN}/\\mu\\mathrm{m}$， $E$ 的单位是 $\\mathrm{kPa}$，长度单位是 $\\mu\\mathrm{m}$。指定的换算关系如下：\n-   $1\\,\\mathrm{nN}/\\mu\\mathrm{m} = 10^{-3}\\,\\mathrm{N/m}$\n-   $1\\,\\mathrm{kPa} = 10^{3}\\,\\mathrm{Pa} = 10^{3}\\,\\mathrm{N/m^2}$\n-   $1\\,\\mu\\mathrm{m} = 10^{-6}\\,\\mathrm{m}$\n\n指数函数的参数必须是无量纲的。我们来分析比率 $T_a/E$。当转换为国际单位制时，其单位是 $(\\mathrm{N/m}) / (\\mathrm{N/m^2}) = \\mathrm{m}$，这是一个长度单位，与问题陈述一致。设输入的数值为 $T_a^{\\text{val}}$ (单位 $\\mathrm{nN}/\\mu\\mathrm{m}$)、$E^{\\text{val}}$ (单位 $\\mathrm{kPa}$) 和 $L_c^{\\text{val}}$ (单位 $\\mu\\mathrm{m}$)。在国际单位制中，指数项为：\n$$\n-k \\frac{(T_a^{\\text{val}} \\times 10^{-3}\\,\\mathrm{N/m}) / (E^{\\text{val}} \\times 10^{3}\\,\\mathrm{N/m^2})}{L_c^{\\text{val}} \\times 10^{-6}\\,\\mathrm{m}} = -k \\frac{T_a^{\\text{val}}}{E^{\\text{val}} \\cdot L_c^{\\text{val}}} \\frac{10^{-3} / 10^3}{10^{-6}} = -k \\frac{T_a^{\\text{val}}}{E^{\\text{val}} \\cdot L_c^{\\text{val}}} \\frac{10^{-6}}{10^{-6}} = -k \\frac{T_a^{\\text{val}}}{E^{\\text{val}} \\cdot L_c^{\\text{val}}}\n$$\n这表明，如果我们使用 $T_a$ (单位 $\\mathrm{nN}/\\mu\\mathrm{m}$)、$E$ (单位 $\\mathrm{kPa}$) 和 $L_c$ (单位 $\\mu\\mathrm{m}$) 的数值，换算因子会恰好抵消。因此，模型评估可以直接使用输入数值。如果将 $L_{\\max}$ 转换为米 ($L_{\\max} \\times 10^{-6}$)，则输出 $D$ 的单位将是米。\n\n敏感性分析使用 Saltelli-Sobol 方法。对于两个输入因子 $T_a$ 和 $E$，我们生成两个独立的样本矩阵 $A$ 和 $B$，每个矩阵的大小为 $N \\times 2$。列对应于 $T_a$ 和 $E$，每一行都是来自联合输入空间的一个样本。根据问题描述，$N=40000$，并且输入是独立的，在其指定范围内均匀分布。\n根据 $A$ 和 $B$，我们构造另外两个矩阵 $A_{B}^{(1)}$ 和 $A_{B}^{(2)}$。\n-   $A_{B}^{(1)}$ 是通过取矩阵 $A$ 并将其第一列（$T_a$ 的列）替换为矩阵 $B$ 的第一列来创建的。\n-   $A_{B}^{(2)}$ 是通过取矩阵 $A$ 并将其第二列（$E$ 的列）替换为矩阵 $B$ 的第二列来创建的。\n\n令 $f(\\cdot) = D(\\cdot)$。我们对这四个矩阵的每一行进行模型评估，以获得四个输出值向量：$f_A = f(A)$、$f_B = f(B)$、$f_{A_{B}^{(1)}} = f(A_B^{(1)})$ 和 $f_{A_{B}^{(2)}} = f(A_B^{(2)})$。\n\nSobol 指数使用所提供的以下特定公式进行估计。输出的总方差 $\\mathrm{Var}(D)$ 由 $\\widehat{V}$ 估计：\n$$\n\\widehat{V} = \\mathrm{Var}\\left(\\{f_A\\} \\cup \\{f_B\\}\\right)\n$$\n这是 $2N$ 个模型输出合并集的方差。\n\n输入 $X_i$（其中 $i=1$ 对应 $T_a$，$i=2$ 对应 $E$）的一阶 Sobol 指数 $S_i$ 由下式估计：\n$$\n\\widehat{S}_i = \\frac{\\frac{1}{N}\\sum_{j=1}^{N} f_B^{(j)}\\left(f_{A_{B}^{(i)}}^{(j)} - f_A^{(j)}\\right)}{\\widehat{V}}\n$$\n\n输入 $X_i$ 的全效应 Sobol 指数 $S_{T_i}$ 由下式估计：\n$$\n\\widehat{S}_{T_i} = \\frac{\\frac{1}{2N}\\sum_{j=1}^{N}\\left(f_A^{(j)} - f_{A_{B}^{(i)}}^{(j)}\\right)^2}{\\widehat{V}}\n$$\n\n最后，对于每个测试用例，根据计算出的全效应指数 $\\widehat{S}_{T_{T_a}}$ 和 $\\widehat{S}_{T_{E}}$ 进行优先级排序。具有较大全效应指数的参数被优先考虑进行更精确的测量。分配一个优先级代码：$1$ 代表 $T_a$，$2$ 代表 $E$，$0$ 代表平局。如果 $|\\widehat{S}_{T_{T_a}} - \\widehat{S}_{T_{E}}| \\le 10^{-6}$，则判定为平局。\n\n以下 Python 程序实现了这个完整的过程。程序使用种子 $12345$ 初始化一个伪随机数生成器，并为所有测试用例顺序使用，以确保结果的确定性和可复现性。该程序为四个指定的测试用例中的每一个计算四个 Sobol 指数（$\\widehat{S}_{T_a}, \\widehat{S}_{E}, \\widehat{S}_{T_{T_a}}, \\widehat{S}_{T_E}$）和优先级代码，将指数四舍五入到三位小数，并将输出格式化为单个扁平列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Sobol sensitivity analysis for all test cases.\n    \"\"\"\n    \n    # Global constants for the model and analysis\n    L_MAX = 25.0  # um\n    L_C = 5.0     # um\n    K = 2.0       # dimensionless\n    N = 40000     # number of samples\n    SEED = 12345\n    TIE_TOLERANCE = 1e-6\n\n    # Test cases defined as tuples of (Ta_range, E_range)\n    # Ta_range: [min, max] in nN/um\n    # E_range: [min, max] in kPa\n    test_cases = [\n        # Case 1 (happy path)\n        ([0.2, 0.8], [0.5, 2.0]),\n        # Case 2 (narrow ranges, near-linear regime)\n        ([0.45, 0.55], [1.0, 1.1]),\n        # Case 3 (elasticity-dominated uncertainty)\n        ([0.3, 0.5], [0.2, 3.0]),\n        # Case 4 (tension-dominated uncertainty)\n        ([0.1, 1.5], [1.0, 1.2]),\n    ]\n    \n    # Initialize a single random number generator for all tests\n    rng = np.random.default_rng(SEED)\n    \n    # --- Model Definition ---\n    def model(Ta, E):\n        \"\"\"\n        Calculates the invagination depth D.\n        The exponential argument simplifies due to unit cancellations,\n        allowing direct use of numerical values in specified units.\n        L_max is used to scale the output, but its units don't affect the\n        dimensionless Sobol indices.\n        \"\"\"\n        arg = -K * Ta / (E * L_C)\n        return (L_MAX) * (1.0 - np.exp(arg))\n\n    # --- Sobol Analysis Function ---\n    def calculate_sobol_indices(ta_range, e_range):\n        \"\"\"\n        Performs Sobol analysis for a single test case.\n        \"\"\"\n        # Generate sample matrices A and B\n        # Matrix A\n        ta_A = rng.uniform(ta_range[0], ta_range[1], size=N)\n        e_A = rng.uniform(e_range[0], e_range[1], size=N)\n        A = np.vstack([ta_A, e_A]).T\n        \n        # Matrix B\n        ta_B = rng.uniform(ta_range[0], ta_range[1], size=N)\n        e_B = rng.uniform(e_range[0], e_range[1], size=N)\n        B = np.vstack([ta_B, e_B]).T\n        \n        # Construct resampled matrices (pick-freeze)\n        A_B_1 = np.copy(A)\n        A_B_1[:, 0] = B[:, 0]  # Column 0 (Ta) from B\n        \n        A_B_2 = np.copy(A)\n        A_B_2[:, 1] = B[:, 1]  # Column 1 (E) from B\n        \n        # Evaluate model for all samples\n        f_A = model(A[:, 0], A[:, 1])\n        f_B = model(B[:, 0], B[:, 1])\n        f_AB1 = model(A_B_1[:, 0], A_B_1[:, 1])\n        f_AB2 = model(A_B_2[:, 0], A_B_2[:, 1])\n        \n        # Estimate total variance (V_hat)\n        # Using variance of the combined sample set of size 2N\n        V_hat = np.var(np.concatenate([f_A, f_B]))\n        \n        # Handle cases where variance is zero to avoid division by zero\n        if V_hat == 0:\n            return 0.0, 0.0, 0.0, 0.0, 0\n\n        # Estimate First-Order Indices (S1, S2)\n        # S1 for Ta, S2 for E\n        S1_num = np.mean(f_B * (f_AB1 - f_A))\n        S1 = S1_num / V_hat\n        \n        S2_num = np.mean(f_B * (f_AB2 - f_A))\n        S2 = S2_num / V_hat\n\n        # Estimate Total-Effect Indices (ST1, ST2)\n        # ST1 for Ta, ST2 for E\n        ST1_num = np.mean((f_A - f_AB1)**2) / 2.0\n        ST1 = ST1_num / V_hat\n        \n        ST2_num = np.mean((f_A - f_AB2)**2) / 2.0\n        ST2 = ST2_num / V_hat\n        \n        # Determine priority\n        if abs(ST1 - ST2) = TIE_TOLERANCE:\n            priority = 0\n        elif ST1 > ST2:\n            priority = 1\n        else:\n            priority = 2\n            \n        return S1, S2, ST1, ST2, priority\n\n    # --- Main Loop ---\n    all_results = []\n    for case in test_cases:\n        ta_range, e_range = case\n        S_Ta, S_E, ST_Ta, ST_E, priority = calculate_sobol_indices(ta_range, e_range)\n        \n        all_results.append(f\"{S_Ta:.3f}\")\n        all_results.append(f\"{S_E:.3f}\")\n        all_results.append(f\"{ST_Ta:.3f}\")\n        all_results.append(f\"{ST_E:.3f}\")\n        all_results.append(str(priority))\n\n    # Print the final output in the required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2640039"}]}