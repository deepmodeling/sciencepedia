{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本章节提供了一系列动手练习，旨在加深您对分子结合分析的理解。我们从一个基础但至关重要的步骤开始：数据转换。在实际的生化实验中，原始的结合数据通常以每毫克总蛋白结合的配体量（例如 $\\mathrm{pmol/mg}$）来表示，而斯卡查德图等分析方法则要求使用摩尔比（每摩尔大分子结合的配体摩尔数，$r$）。这个练习将指导您如何利用大分子的分子量和其在样品中的质量分数，在这些不同的数据表示之间进行精确转换，这是确保数据分析正确性的前提。[@problem_id:2544762]", "problem": "一位研究人员希望将放射性配体结合数据绘制在Scatchard图上，该图使用分数占据表示法，即每摩尔大分子结合的配体摩尔数（记为 $r$）。一个含有目标受体的膜制备物，在每个游离配体浓度下，产生一个直接测量的结合读数，记为 $B$，单位为每毫克总蛋白结合的皮摩尔配体（$\\mathrm{pmol}/\\mathrm{mg}$ 总蛋白）。已知该受体以相同亚基组成的同源四聚体形式存在，每个亚基的分子量为 $100\\,\\mathrm{kDa}$；因此，功能性大分子的分子量为 $M = 400\\,\\mathrm{kDa}$。对该制备物的定量蛋白质组学分析表明，受体占总蛋白质量的 $0.020\\,\\%$，即受体质量分数为 $p = 2.0 \\times 10^{-4}$（无量纲）。一支测定管中含有体积为 $V = 0.10\\,\\mathrm{mL}$ 的膜悬浮液，其总蛋白浓度为 $C_{\\mathrm{prot}} = 2.0\\,\\mathrm{mg/mL}$。在某个给定的游离配体浓度下，测得的结合值为 $B = 0.25\\,\\mathrm{pmol/mg}$ 总蛋白。\n\n仅从以下核心定义出发：(i) $B$ 是结合的配体摩尔数与总蛋白质量的比值，(ii) $r$ 是结合的配体摩尔数与大分子（受体）摩尔数的比值，并使用 $\\mathrm{pmol}$ 与 $\\mathrm{mol}$、$\\mathrm{mg}$ 与 $\\mathrm{g}$ 之间的标准单位换算以及以 $\\mathrm{g/mol}$ 为单位的分子量，以下哪个选项正确给出了该数据点的 $r$ 值，并正确描述了其对测定体积和蛋白浓度的依赖性（或缺乏依赖性）？\n\nA. 每个大分子 $r = 0.50$；$r$ 与测定体积 $V$ 和总蛋白浓度 $C_{\\mathrm{prot}}$ 无关。\n\nB. 每个大分子 $r = 0.125$；$r$ 与测定体积 $V$ 和总蛋白浓度 $C_{\\mathrm{prot}}$ 无关。\n\nC. 每个大分子 $r = 5.0 \\times 10^{-4}$；$r$ 依赖于测定体积 $V$。\n\nD. 由于 $B$ 是按质量而非按测定管归一化的，因此在不知道 $V$ 和 $C_{\\mathrm{prot}}$ 的情况下，无法从给定信息中计算出 $r$。", "solution": "首先将对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n提供了以下量和定义：\n-   分数占据记为 $r$，定义为每摩尔大分子结合的配体摩尔数。\n-   测量的结合读数记为 $B$，定义为每质量总蛋白结合的配体摩尔数。\n-   特定数据点的测量结合值为 $B = 0.25\\,\\mathrm{pmol/mg}$ 总蛋白。\n-   受体是相同亚基组成的同源四聚体。\n-   一个亚基的分子量为 $100\\,\\mathrm{kDa}$。\n-   功能性大分子（同源四聚体）的分子量为 $M = 400\\,\\mathrm{kDa}$。\n-   受体在总蛋白中的质量分数为 $p = 0.020\\,\\% = 2.0 \\times 10^{-4}$（无量纲）。\n-   测定体积为 $V = 0.10\\,\\mathrm{mL}$。\n-   测定中的总蛋白浓度为 $C_{\\mathrm{prot}} = 2.0\\,\\mathrm{mg/mL}$。\n\n定义明确表述为：\n-   (i) $B = \\frac{\\text{结合的配体摩尔数}}{\\text{总蛋白质量}}$\n-   (ii) $r = \\frac{\\text{结合的配体摩尔数}}{\\text{大分子的摩尔数}}$\n\n### 步骤 2：使用提取的已知条件进行验证\n评估问题的有效性。\n1.  **科学基础**：该问题基于配体结合测定和数据表示（Scatchard分析）的标准生物化学原理。所有概念，如分数占据、分子量、蛋白质浓度和质量分数，都是标准的且定义明确。这些数值在物理上是合理的。\n2.  **适定性**：该问题要求计算一个特定的、已定义的量（$r$）并分析其依赖关系。所提供的数据似乎足以获得唯一解。\n3.  **客观性**：该问题以精确的、定量的术语陈述，没有主观性或模糊性。\n4.  **完整性与一致性**：该问题提供了将量 $B$ 转换为量 $r$ 所需的所有必要信息。大分子的分子量（$M = 400\\,\\mathrm{kDa}$）与其作为 $100\\,\\mathrm{kDa}$ 亚基的同源四聚体的组成（$4 \\times 100\\,\\mathrm{kDa} = 400\\,\\mathrm{kDa}$）是一致的。没有内部矛盾。包含 $V$ 和 $C_{\\mathrm{prot}}$ 可能是为了测试对内含性质与外延性质的理解，但这并不会使问题不完整或过约束。\n\n### 步骤 3：结论与行动\n问题陈述在科学上是合理的、适定的且内部一致。因此，它被判定为**有效**。我们继续进行求解。\n\n目标是找到 $r$ 和 $B$ 之间的关系。设 $n_{L}$ 为结合配体的摩尔数，$m_{\\text{总蛋白}}$ 为总蛋白的质量，$n_{\\text{受体}}$ 为受体大分子的摩尔数。\n\n根据给定的定义：\n$$B = \\frac{n_{L}}{m_{\\text{总蛋白}}}$$\n$$r = \\frac{n_{L}}{n_{\\text{受体}}}$$\n\n我们可以从第一个方程中将 $n_{L}$ 表示为 $n_{L} = B \\cdot m_{\\text{总蛋白}}$，并将其代入第二个方程：\n$$r = \\frac{B \\cdot m_{\\text{总蛋白}}}{n_{\\text{受体}}}$$\n这个表达式表明 $r$ 与 $B$ 成正比，转换因子是总蛋白质量与受体摩尔数的比值，$\\frac{m_{\\text{总蛋白}}}{n_{\\text{受体}}}$。我们现在必须计算这个比值。\n\n在包含总蛋白质量 $m_{\\text{总蛋白}}$ 的样品中，受体的质量 $m_{\\text{受体}}$ 由受体质量分数 $p$ 给出：\n$$m_{\\text{受体}} = p \\cdot m_{\\text{总蛋白}}$$\n受体的摩尔数 $n_{\\text{受体}}$ 与其质量 $m_{\\text{受体}}$ 通过其摩尔质量 $M$ 相关联：\n$$n_{\\text{受体}} = \\frac{m_{\\text{受体}}}{M} = \\frac{p \\cdot m_{\\text{总蛋白}}}{M}$$\n现在，我们将 $n_{\\text{受体}}$ 的这个表达式代回到我们的 $r$ 方程中：\n$$r = \\frac{B \\cdot m_{\\text{总蛋白}}}{\\left(\\frac{p \\cdot m_{\\text{总蛋白}}}{M}\\right)}$$\n项 $m_{\\text{总蛋白}}$，代表一个假设样品中总蛋白的任意质量，被消掉了：\n$$r = B \\cdot \\frac{M}{p}$$\n这个推导出的关系具有根本的重要性。它表明，分数占据 $r$ 可以仅使用受体的分子量 $M$ 和其质量分数 $p$ 从特异性结合 $B$ 计算得出。结果与实验中使用的物质的量无关，因此与测定体积 $V$ 和总蛋白浓度 $C_{\\mathrm{prot}}$ 无关。这些是特定实验实例的参数，而 $B$、$r$、$M$ 和 $p$ 是系统的内含性质或常数。\n\n我们现在使用提供的数据计算 $r$ 的值。保持单位一致性至关重要。\n-   $B = 0.25\\,\\mathrm{pmol} \\cdot \\mathrm{mg}^{-1} = 0.25 \\times 10^{-12}\\,\\mathrm{mol} \\cdot (10^{-3}\\,\\mathrm{g})^{-1} = 0.25 \\times 10^{-9}\\,\\mathrm{mol} \\cdot \\mathrm{g}^{-1}$\n-   $M = 400\\,\\mathrm{kDa} = 400 \\times 10^3\\,\\mathrm{g} \\cdot \\mathrm{mol}^{-1} = 4.0 \\times 10^5\\,\\mathrm{g} \\cdot \\mathrm{mol}^{-1}$\n-   $p = 2.0 \\times 10^{-4}$ (无量纲，表示 $\\mathrm{g}_{\\text{受体}}/\\mathrm{g}_{\\text{总蛋白}}$)\n\n将这些值代入推导出的公式：\n$$r = (0.25 \\times 10^{-9}\\,\\mathrm{mol}_{\\text{配体}} \\cdot \\mathrm{g}_{\\text{蛋白}}^{-1}) \\cdot \\frac{4.0 \\times 10^5\\,\\mathrm{g}_{\\text{受体}} \\cdot \\mathrm{mol}_{\\text{受体}}^{-1}}{2.0 \\times 10^{-4}\\,\\mathrm{g}_{\\text{受体}} \\cdot \\mathrm{g}_{\\text{蛋白}}^{-1}}$$\n单位组合为 $(\\mathrm{mol}_{\\text{配体}}/\\mathrm{g}_{\\text{蛋白}}) \\cdot (\\mathrm{g}_{\\text{受体}}/\\mathrm{mol}_{\\text{受体}}) \\cdot (\\mathrm{g}_{\\text{蛋白}}/\\mathrm{g}_{\\text{受体}}) = \\mathrm{mol}_{\\text{配体}}/\\mathrm{mol}_{\\text{受体}}$，这是 $r$ 的正确单位。\n\n进行数值计算：\n$$r = \\frac{0.25 \\times 10^{-9} \\times 4.0 \\times 10^5}{2.0 \\times 10^{-4}} = \\frac{1.0 \\times 10^{-4}}{2.0 \\times 10^{-4}} = \\frac{1}{2} = 0.50$$\n因此，$r = 0.50$ 每摩尔大分子结合的配体摩尔数。\n\n为了验证，我们可以使用额外信息（$V$ 和 $C_{\\mathrm{prot}}$）来计算反应管中的绝对量。\n-   总蛋白质量: $m_{\\text{总蛋白,总量}} = C_{\\mathrm{prot}} \\cdot V = (2.0\\,\\mathrm{mg/mL}) \\cdot (0.10\\,\\mathrm{mL}) = 0.20\\,\\mathrm{mg}$。\n-   结合配体的摩尔数: $n_{L} = B \\cdot m_{\\text{总蛋白,总量}} = (0.25\\,\\mathrm{pmol/mg}) \\cdot (0.20\\,\\mathrm{mg}) = 0.050\\,\\mathrm{pmol}$。\n-   受体质量: $m_{\\text{受体}} = p \\cdot m_{\\text{总蛋白,总量}} = (2.0 \\times 10^{-4}) \\cdot (0.20\\,\\mathrm{mg}) = 4.0 \\times 10^{-5}\\,\\mathrm{mg}$。\n-   受体摩尔数: $n_{\\text{受体}} = \\frac{m_{\\text{受体}}}{M}$。我们需要 $M$ 的单位为 $\\mathrm{mg/pmol}$。\n    $M = 4.0 \\times 10^5\\,\\mathrm{g/mol} = 4.0 \\times 10^5\\,\\frac{\\mathrm{g}}{\\mathrm{mol}} \\times \\frac{10^3\\,\\mathrm{mg}}{1\\,\\mathrm{g}} \\times \\frac{1\\,\\mathrm{mol}}{10^{12}\\,\\mathrm{pmol}} = 4.0 \\times 10^{-4}\\,\\mathrm{mg/pmol}$。\n    $n_{\\text{受体}} = \\frac{4.0 \\times 10^{-5}\\,\\mathrm{mg}}{4.0 \\times 10^{-4}\\,\\mathrm{mg/pmol}} = 0.10\\,\\mathrm{pmol}$。\n-   最后，计算 $r$: $r = \\frac{n_{L}}{n_{\\text{受体}}} = \\frac{0.050\\,\\mathrm{pmol}}{0.10\\,\\mathrm{pmol}} = 0.50$。\n这证实了结果，并明确表明，虽然可以使用 $V$ 和 $C_{\\mathrm{prot}}$，但它们并非必需。\n\n现在我们评估给定的选项。\n\n**A. 每个大分子 $r = 0.50$；$r$ 与测定体积 $V$ 和总蛋白浓度 $C_{\\mathrm{prot}}$ 无关。**\n我们的计算得出 $r = 0.50$。我们对公式 $r = B \\cdot M/p$ 的推导证明了 $r$ 与 $V$ 和 $C_{\\mathrm{prot}}$ 无关，因为这些是特定样品的性质，而不是两种归一化结合度量之间转换所需的基本性质。\n结论：**正确**。\n\n**B. 每个大分子 $r = 0.125$；$r$ 与测定体积 $V$ 和总蛋白浓度 $C_{\\mathrm{prot}}$ 无关。**\n数值 $r=0.125$ 是不正确的。如果错误地使用亚基分子量（$100\\,\\mathrm{kDa}$）而不是大分子分子量（$400\\,\\mathrm{kDa}$），就会得到这个值，因为 $0.50 / 4 = 0.125$。然而，问题定义 $r$ 是相对于大分子的。\n结论：**不正确**。\n\n**C. 每个大分子 $r = 5.0 \\times 10^{-4}$；$r$ 依赖于测定体积 $V$。**\n数值不正确。此外，如推导所示，$r$ 依赖于 $V$ 的说法是错误的。\n结论：**不正确**。\n\n**D. 由于 $B$ 是按质量而非按测定管归一化的，因此在不知道 $V$ 和 $C_{\\mathrm{prot}}$ 的情况下，无法从给定信息中计算出 $r$。**\n这个陈述是错误的。从 $B$（按总蛋白质量归一化）到 $r$（按受体摩尔数归一化）的转换只需要受体的分子量及其质量分数，而不需要试管中的绝对量。推导 $r = B \\cdot M/p$ 证明了用给定信息进行计算是可能的，并且 $V$ 和 $C_{\\mathrm{prot}}$ 是多余的。\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2544762"}, {"introduction": "掌握了数据单位的转换后，下一步是应用斯卡查德图法来提取关键的生物物理参数。这个练习是一个核心实践，它将引导您完成从原始结合数据到最终确定解离常数（$K_d$）和最大结合容量（$B_{\\max}$）的全过程。您将需要手动构建斯卡查德图，执行线性回归分析，并从拟合的直线斜率和截距中计算出 $K_d$ 和 $B_{\\max}$。通过这个练习，您不仅能熟练掌握斯卡查德分析的机械步骤，还能深入理解该方法背后的数学原理和假设。[@problem_id:2544802]", "problem": "配体 $L$ 可逆地与受体 $R$ 上的一类独立位点结合，在平衡状态下形成复合物 $RL$，$R + L \\rightleftharpoons RL$。根据质量作用定律，平衡解离常数定义为 $K_{d} = \\dfrac{[R][L]}{[RL]}$。总结合位点浓度为 $B_{\\max}$ (单位：fmol/mg蛋白质)，平衡时的特异性结合配体为 $B = [RL]$ (单位：fmol/mg蛋白质)。游离配体浓度为 $F = [L]$ (单位：nM)。您将使用 Scatchard 表示法，根据特异性结合数据来估计 $K_{d}$ 和 $B_{\\max}$，并量化其统计不确定性。\n\n任务：\n1) 从上述 $K_{d}$ 的定义和位点守恒 $B_{\\max} = [R] + [RL]$ 出发，通过代数推导出一个线性关系。该关系中的变量可以由测得的 $B$ 和 $F$ 构建，并且适用于普通最小二乘 (OLS) 线性回归分析。\n\n2) 使用以下数据集，构建相应的 Scatchard 图，进行 OLS 线性回归以获得最佳拟合的斜率和截距，然后用这些回归系数表示 $K_{d}$ 和 $B_{\\max}$。\n\n3) 使用自由度为 $n-2$ (其中 $n$ 是数据点数) 的学生t分布，计算斜率和截距的 $95\\%$ 置信区间。然后，使用一阶误差传播 (delta方法) 获得 $K_{d}$ 和 $B_{\\max}$ 的近似 $95\\%$ 置信区间。\n\n数据 (放射性配体与膜受体的平衡特异性结合)：\n- 数据点 $1$：$F = 1\\,\\text{nM}$，$B = 16.9\\,\\text{fmol}\\,\\text{mg}^{-1}$\n- 数据点 $2$：$F = 2\\,\\text{nM}$，$B = 28.2\\,\\text{fmol}\\,\\text{mg}^{-1}$\n- 数据点 $3$：$F = 4\\,\\text{nM}$，$B = 44.7\\,\\text{fmol}\\,\\text{mg}^{-1}$\n- 数据点 $4$：$F = 8\\,\\text{nM}$，$B = 61.2\\,\\text{fmol}\\,\\text{mg}^{-1}$\n- 数据点 $5$：$F = 16\\,\\text{nM}$，$B = 76.5\\,\\text{fmol}\\,\\text{mg}^{-1}$\n\n假设用于回归的响应变量误差相等且独立，并使用未加权 OLS。请明确指出您所使用的回归响应变量和预测变量。以纳摩尔 (nM) 为单位报告 $K_{d}$ 的最终数值估计，并将答案四舍五入到三位有效数字。\n\n注：对于区间估计，请使用直线 OLS 拟合的常规公式，并通过一阶泰勒展开 (delta方法) 来近似变换后参数的置信区间。所有置信区间的端点均以小数表示 (不含百分号)。您可以报告 $B_{\\max}$ (单位：fmol/mg蛋白质) 的值，但您最终只需提供 $K_{d}$ 的最佳拟合值 (单位：nM)，并四舍五入到三位有效数字。", "solution": "所提出的问题在科学上是合理的、自洽的且表述清晰。它描述了一个标准的单一位点可逆配体结合模型，这是定量生物化学的基石。定义、数据和任务都清晰且逻辑一致，可以通过既定的代数运算和统计分析方法获得唯一解。因此，该问题被认为是有效的，下面提供了完整的解答。\n\n该问题需要分三部分进行分析：首先，推导 Scatchard 方程；其次，使用普通最小二乘 (OLS) 线性回归从提供的数据中估计结合参数 $K_d$ 和 $B_{\\max}$；第三，计算这些估计值的统计不确定性。\n\n第1部分：Scatchard 方程的推导\n\n分析始于单一位点结合平衡的基本定义：\n根据质量作用定律，平衡解离常数 $K_d$ 为：\n$$K_{d} = \\frac{[R][L]}{[RL]}$$\n总受体结合位点的守恒关系 $B_{\\max}$ 为：\n$$B_{\\max} = [R] + [RL]$$\n问题将可观测量定义为特异性结合配体浓度 $B = [RL]$ 和游离配体浓度 $F = [L]$。将这些代入定义中可得：\n$$K_{d} = \\frac{[R]F}{B}$$\n$$B_{\\max} = [R] + B$$\n从第二个方程中，我们用总位点和结合位点来表示游离受体的浓度 $[R]$：\n$$[R] = B_{\\max} - B$$\n将 $[R]$ 的这个表达式代入 $K_d$ 的方程中：\n$$K_{d} = \\frac{(B_{\\max} - B)F}{B}$$\n为了获得适用于 OLS 回归的线性关系，我们对该方程进行重排。标准的 Scatchard 表示法是绘制结合配体与游离配体之比 $B/F$ 对结合配体浓度 $B$ 的图。\n$$K_{d} B = (B_{\\max} - B)F$$\n$$K_{d} B = B_{\\max} F - B F$$\n所有项同时除以 $F$ 和 $K_d$ 可得：\n$$\\frac{B}{F} = \\frac{B_{\\max}}{K_{d}} - \\frac{B}{K_{d}}$$\n该方程是线性形式 $y = c + mx$，其中：\n-   响应（因）变量：$y = \\frac{B}{F}$\n-   预测（自）变量：$x = B$\n-   斜率：$m = -\\frac{1}{K_{d}}$\n-   y轴截距：$c = \\frac{B_{\\max}}{K_{d}}$\n\n根据数据线性拟合的斜率 $m$ 和截距 $c$，可以确定生物物理参数：\n$$K_d = -\\frac{1}{m}$$\n$$B_{\\max} = c \\cdot K_d = c \\cdot \\left(-\\frac{1}{m}\\right) = -\\frac{c}{m}$$\n图中 x 轴的截距（此时 $B/F = 0$）对应于 $B = -c/m = B_{\\max}$，这与配体饱和时的预期相符。\n\n第2部分：OLS 回归和参数估计\n\n我们首先将给定的数据 $(F_i, B_i)$ 转换为回归变量 $(x_i, y_i) = (B_i, B_i/F_i)$。数据点数量为 $n=5$。\n\n-   数据点 $1$：$x_1 = 16.9$, $y_1 = 16.9/1 = 16.9$\n-   数据点 $2$：$x_2 = 28.2$, $y_2 = 28.2/2 = 14.1$\n-   数据点 $3$：$x_3 = 44.7$, $y_3 = 44.7/4 = 11.175$\n-   数据点 $4$：$x_4 = 61.2$, $y_4 = 61.2/8 = 7.65$\n-   数据点 $5$：$x_5 = 76.5$, $y_5 = 76.5/16 = 4.78125$\n\n斜率 ($m$) 和截距 ($c$) 的 OLS 估计值是使用以下总和计算的：\n$\\sum x_i = 227.5$\n$\\sum y_i = 54.60625$\n$\\sum x_i^2 = 12676.63$\n$\\sum x_i y_i = 2016.698125$\n平均值为 $\\bar{x} = 45.5$ 和 $\\bar{y} = 10.92125$。\n\n平方和为：\n$$S_{xx} = \\sum_{i=1}^{n} (x_i - \\bar{x})^2 = \\sum x_i^2 - n\\bar{x}^2 = 12676.63 - 5(45.5)^2 = 2325.38$$\n$$S_{xy} = \\sum_{i=1}^{n} (x_i - \\bar{x})(y_i - \\bar{y}) = \\sum x_i y_i - n\\bar{x}\\bar{y} = 2016.698125 - 5(45.5)(10.92125) = -467.88625$$\n估计的斜率 $m$ 为：\n$$m = \\frac{S_{xy}}{S_{xx}} = \\frac{-467.88625}{2325.38} \\approx -0.201206$$\n估计的截距 $c$ 为：\n$$c = \\bar{y} - m\\bar{x} = 10.92125 - (-0.201206)(45.5) \\approx 20.07612$$\n使用这些回归系数，我们找到 $K_d$ 和 $B_{\\max}$ 的最佳拟合估计值：\n$$K_d = -\\frac{1}{m} = -\\frac{1}{-0.201206} \\approx 4.97003 \\, \\text{nM}$$\n$$B_{\\max} = -\\frac{c}{m} = -\\frac{20.07612}{-0.201206} \\approx 99.7789 \\, \\text{fmol}\\,\\text{mg}^{-1}$$\n\n第3部分：置信区间估计\n\n回归的自由度为 $df = n-2 = 5-2 = 3$。对于 $95\\%$ 的置信区间，来自学生t分布的双尾临界值为 $t_{\\alpha/2, df} = t_{0.025, 3} \\approx 3.182$。\n\n首先，我们计算残差平方和 ($SSR$) 和回归标准误 ($S_E$)：\n$S_{yy} = \\sum (y_i - \\bar{y})^2 = \\sum y_i^2 - n\\bar{y}^2 = 690.68355 - 5(10.92125)^2 \\approx 94.3148$\n$SSR = S_{yy} - m S_{xy} = 94.3148 - (-0.201206)(-467.88625) \\approx 0.17957$\n$S_E^2 = \\frac{SSR}{n-2} = \\frac{0.17957}{3} \\approx 0.059857$\n\n斜率 ($s_m$) 和截距 ($s_c$) 的标准误为：\n$$s_m^2 = \\frac{S_E^2}{S_{xx}} = \\frac{0.059857}{2325.38} \\approx 2.574 \\times 10^{-5} \\implies s_m \\approx 0.005074$$\n$$s_c^2 = S_E^2 \\left(\\frac{1}{n} + \\frac{\\bar{x}^2}{S_{xx}}\\right) = 0.059857 \\left(\\frac{1}{5} + \\frac{45.5^2}{2325.38}\\right) \\approx 0.06528 \\implies s_c \\approx 0.2555$$\n$m$ 和 $c$ 的 $95\\%$ 置信区间为：\n$m \\pm t_{0.025,3} \\cdot s_m = -0.2012 \\pm 3.182(0.005074) \\Rightarrow [-0.2173, -0.1851]$\n$c \\pm t_{0.025,3} \\cdot s_c = 20.076 \\pm 3.182(0.2555) \\Rightarrow [19.263, 20.889]$\n\n为了找到 $K_d = -1/m$ 的置信区间，我们使用一阶误差传播 (delta方法)。$K_d$ 的方差近似为：\n$$s_{K_d}^2 \\approx \\left(\\frac{dK_d}{dm}\\right)^2 s_m^2 = \\left(\\frac{1}{m^2}\\right)^2 s_m^2 = \\frac{s_m^2}{m^4}$$\n$K_d$ 的标准误为：\n$$s_{K_d} = \\frac{s_m}{m^2} = \\frac{0.005074}{(-0.201206)^2} \\approx 0.1253$$\n$K_d$ 的近似 $95\\%$ 置信区间为：\n$$K_d \\pm t_{0.025,3} \\cdot s_{K_d} = 4.970 \\pm 3.182(0.1253) \\approx 4.970 \\pm 0.399$$\n这得到区间 $[4.571, 5.369]$。\n\n问题要求以纳摩尔为单位给出 $K_d$ 的最佳拟合数值估计，并四舍五入到三位有效数字。\n$$K_d \\approx 4.97003 \\, \\text{nM}$$\n四舍五入到三位有效数字得到 $4.97$。", "answer": "$$\n\\boxed{4.97}\n$$", "id": "2544802"}, {"introduction": "虽然斯卡查德图在历史上非常重要，但现代分析已经认识到其固有的统计学缺陷，特别是在误差传播方面。这个高级练习将引导您超越传统的线性回归，进入计算生物物理学的领域，使用非参数自助法（bootstrap resampling）来更稳健地评估 $K_d$ 估计的不确定性。您将通过编写一个程序来模拟结合数据，并比较经典方法（delta方法）和自助法得到的置信区间。这项练习旨在揭示斯卡查德变换如何扭曲实验误差，并展示现代计算统计方法在提供更可靠参数估计方面的强大能力。[@problem_id:2544775]", "problem": "考虑一个处于平衡状态的单位点配体-受体结合系统，其中游离配体浓度用 $c$ 表示，总受体位点浓度用 $B_{\\max}$ 表示，结合配体浓度用 $r$ 表示。解离常数由质量作用定律定义为 $K_d = \\dfrac{[L][R]}{[LR]}$，其中 $[L]$ 是游离配体，$[R]$ 是游离受体，$[LR]$ 是配体-受体复合物。从这些基本原理出发，可以推导出单位点结合等温线和 Scatchard 表示法。Scatchard 分析绘制 $r/c$ 对 $r$ 的图，并使用普通最小二乘法来获得一条直线，其斜率与 $K_d$ 相关。本问题的主要目标是使用两种方法来量化通过 Scatchard 方法得到的 $K_d$ 估计值的不确定性：非参数 bootstrap 重采样和通过 delta 方法获得的渐近正态近似。\n\n编写一个完整的程序，对下面的测试套件中的每个参数集执行以下步骤。\n\n- 从质量作用定律和解离常数的定义出发，推导出用 $B_{\\max}$、$K_d$ 和 $c$ 表示的单位点结合等温线。然后，推导出将单位点系统的 $r/c$ 与 $r$ 联系起来的线性 Scatchard 表示法。\n- 使用推导结果实现一个模拟器，在指定的配体浓度 $c$ 下生成 $r$ 的合成测量值。对于给定的 $(B_{\\max}, K_d)$ 和每个浓度 $c_i$，计算由等温线预测的无噪声结合量 $r_i$。然后，通过添加独立的、零均值的、具有指定标准差（绝对单位）的高斯噪声来生成 $m$ 个独立的重复观测值，并将每个带噪声的观测值裁剪到物理上有意义的区间 $\\left[0, B_{\\max}\\right]$ 内。对每个 $c_i$ 处的 $m$ 个重复值取平均，以获得用于拟合的最终测量值 $r_i$。为了可复现性，请使用固定的随机种子 $12345$。所有浓度都以纳摩尔为单位，但所有要求的输出都是无量纲的，并且必须在不带单位的情况下打印。\n- 根据平均测量值 $(c_i, r_i)$，构建 Scatchard 数据对 $(x_i, y_i)$，其中 $x_i = r_i$ 且 $y_i = r_i / c_i$。通过非加权普通最小二乘法拟合线性模型 $y = \\alpha + s x$，以获得斜率估计值 $s$ 及其标准误差。仅使用最小二乘法的性质和基础概率论来实现此步骤。\n- 通过单位点的 Scatchard 关系，将斜率估计值映射到解离常数估计值，并通过应用于斜率的 delta 方法推导出 $K_d$ 估计值的渐近标准误差。使用正态分位数 $z_{0.975} = 1.96$ 构建 $K_d$ 的双侧 $95\\%$ 渐近正态置信区间。\n- 在 Scatchard 数据集上实现非参数 bootstrap，方法是对配对点 $(x_i, y_i)$ 的索引集进行总共 $B$ 次有放回的重采样，每次都如上所述重新拟合直线并将斜率映射到 $K_d$。丢弃导致非负斜率或退化拟合（$x$ 的方差为零）的重采样样本，因为此类结果与单位点 Scatchard 解释不兼容。从有效的 bootstrap 重复样本中，使用经验性的 $2.5$ 和 $97.5$ 百分位数计算百分位数 $95\\%$ 置信区间，并计算 bootstrap $K_d$ 分布的样本偏度，该偏度定义为三阶中心矩除以标准差的立方。\n- 对于每个测试用例，计算并报告以下三个无量纲量： \n    - $K_d$ 的 bootstrap 百分位数区间宽度与渐近正态区间宽度的比率，\n    - bootstrap $K_d$ 分布的样本偏度，\n    - 由于非负斜率或退化而被丢弃的 bootstrap 重采样样本的比例。\n\n程序必须使用以下常量和约定：\n- 使用固定的随机种子 $12345$ 生成所有随机噪声。\n- 每个浓度使用 $m = 3$ 个重复样本。\n- 使用 $B = 5000$ 次 bootstrap 重采样。\n- 构建渐近区间时使用双侧正态分位数 $z_{0.975} = 1.96$。\n- 如果在丢弃无效重采样样本后，剩余的有效 bootstrap 重复样本少于 $100$ 个，则将 bootstrap 区间宽度和偏度定义为非数值 (not-a-number)，并进行相应的传播。\n\n测试套件：\n- 案例 1 (通用)：$B_{\\max} = 100$, $K_d = 30$, 浓度 $c$ (纳摩尔) 为 $\\{1, 2, 5, 10, 20, 30, 50, 75, 100, 150, 200, 300\\}$, 高斯噪声标准差 $\\sigma = 5$ (单位与 $r$ 相同)。\n- 案例 2 (边界，更高噪声)：$B_{\\max} = 100$, $K_d = 30$, 浓度与案例 1 相同, 高斯噪声标准差 $\\sigma = 12$。\n- 案例 3 (边缘，更少数据点，更低噪声)：$B_{\\max} = 100$, $K_d = 10$, 浓度 $c$ (纳摩尔) 为 $\\{5, 10, 20, 50, 200\\}$, 高斯噪声标准差 $\\sigma = 2$。\n\n所有报告的输出都是无量纲的。您的程序应生成单行输出，其中包含三个案例的结果，格式为方括号括起来的逗号分隔列表，每个案例贡献一个按上述顺序排列的三元素列表。例如，输出必须看起来像 $[ [r_1, s_1, f_1], [r_2, s_2, f_2], [r_3, s_3, f_3] ]$，其中 $r_i$ 是 bootstrap 与正态区间宽度的比率，$s_i$ 是 bootstrap 偏度，$f_i$ 是案例 $i$ 的无效 bootstrap 比例。", "solution": "问题陈述是有效的。它在科学上基于化学平衡和质量作用定律的原理，在统计学上是合理的，涉及普通最小二乘法、delta 方法和 bootstrap 重采样等标准技术。该问题是适定的，所有必要的参数和条件都已指定，并且在计算上是可行的。它在定量生物物理数据分析领域提出了一个相关且非平凡的挑战。\n\n我们首先推导必要的理论关系。\n\n该系统是一个单位点配体-受体结合平衡：$L + R \\rightleftharpoons LR$。\n\n解离常数 $K_d$ 由质量作用定律定义：\n$$K_d = \\frac{[L][R]}{[LR]}$$\n其中 $[L]$, $[R]$ 和 $[LR]$ 分别是游离配体、游离受体和配体-受体复合物的平衡浓度。\n\n我们有以下给定的符号：\n- 游离配体浓度，$[L] = c$。\n- 结合配体浓度，等同于配体-受体复合物的浓度，$[LR] = r$。\n- 总受体位点浓度，$B_{\\max}$。\n\n总受体浓度是游离受体和结合受体之和：\n$$B_{\\max} = [R] + [LR]$$\n由此，我们可以将游离受体浓度表示为：\n$$[R] = B_{\\max} - r$$\n\n将这些定义代入 $K_d$ 的表达式中：\n$$K_d = \\frac{c(B_{\\max} - r)}{r}$$\n\n为了推导出单位点结合等温线，我们求解此方程以得到 $r$：\n$$K_d \\cdot r = c(B_{\\max} - r)$$\n$$K_d \\cdot r = c \\cdot B_{\\max} - c \\cdot r$$\n$$r(K_d + c) = c \\cdot B_{\\max}$$\n$$r = \\frac{B_{\\max} \\cdot c}{K_d + c}$$\n这个方程就是结合等温线，它描述了结合配体浓度 $r$ 作为游离配体浓度 $c$ 的函数。\n\n为了推导出 Scatchard 表示法，我们将方程 $K_d \\cdot r = c \\cdot B_{\\max} - c \\cdot r$ 重排成线性形式。我们用 $c$ 除以方程两边：\n$$K_d \\frac{r}{c} = B_{\\max} - r$$\n重排以求解比率 $r/c$：\n$$\\frac{r}{c} = \\frac{B_{\\max}}{K_d} - \\frac{1}{K_d}r$$\n这个方程是线性形式 $y = \\alpha + sx$，其中：\n- 因变量是 $y = r/c$。\n- 自变量是 $x = r$。\n- y轴截距是 $\\alpha = B_{\\max}/K_d$。\n- 斜率是 $s = -1/K_d$。\n\n因此，$r/c$ 对 $r$ 的 Scatchard 图应产生一条直线。通过使用非加权普通最小二乘法 (OLS) 拟合这条线，我们可以估计斜率 $s$，并由此估计解离常数 $K_d$。\n\n对于一组数据点 $(x_i, y_i)$，斜率的 OLS 估计值 $\\hat{s}$ 由下式给出：\n$$\\hat{s} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^n (x_i - \\bar{x})^2}$$\n其中 $n$ 是数据点的数量，$\\bar{x}$ 和 $\\bar{y}$ 是样本均值。斜率估计值的标准误差 $SE(\\hat{s})$ 是：\n$$SE(\\hat{s}) = \\sqrt{\\frac{\\hat{\\sigma}_\\epsilon^2}{\\sum_{i=1}^n (x_i - \\bar{x})^2}}$$\n其中 $\\hat{\\sigma}_\\epsilon^2$ 是残差的估计方差：\n$$\\hat{\\sigma}_\\epsilon^2 = \\frac{1}{n-2} \\sum_{i=1}^n (y_i - (\\hat{\\alpha} + \\hat{s}x_i))^2$$\n截距估计值为 $\\hat{\\alpha} = \\bar{y} - \\hat{s}\\bar{x}$。\n\n根据估计的斜率 $\\hat{s}$，解离常数估计为：\n$$\\hat{K}_d = -\\frac{1}{\\hat{s}}$$\n为了求出 $\\hat{K}_d$ 的不确定性，我们使用 delta 方法。对于函数 $g(s) = -1/s$，$\\hat{K}_d = g(\\hat{s})$ 的方差近似为：\n$$Var(\\hat{K}_d) \\approx [g'(\\hat{s})]^2 Var(\\hat{s})$$\n导数为 $g'(s) = 1/s^2$。因此：\n$$Var(\\hat{K}_d) \\approx \\left(\\frac{1}{\\hat{s}^2}\\right)^2 Var(\\hat{s}) = \\frac{Var(\\hat{s})}{\\hat{s}^4}$$\n$\\hat{K}_d$ 的标准误差是方差的平方根：\n$$SE(\\hat{K}_d) \\approx \\frac{SE(\\hat{s})}{\\hat{s}^2}$$\n然后，一个双侧 $95\\%$ 的 $K_d$ 渐近正态置信区间可以构建为 $\\hat{K}_d \\pm z_{0.975} \\cdot SE(\\hat{K}_d)$，其中 $z_{0.975} = 1.96$。\n\n对于非参数 bootstrap，我们对成对数据点 $(x_i, y_i)$ 的集合进行 $B$ 次有放回的重采样。对于每个 bootstrap 样本，我们计算斜率估计值 $\\hat{s}^*$ 和相应的 $\\hat{K}_d^* = -1/\\hat{s}^*$。无效的样本（即那些产生 $\\hat{s}^* \\ge 0$ 或退化拟合的样本）将被丢弃。剩余有效 $\\hat{K}_d^*$ 值的 `2.5` 和 `97.5` 百分位数构成了 $95\\%$ bootstrap 百分位置信区间。\n\n$\\hat{K}_d^*$ 的 bootstrap 分布的样本偏度使用矩量法计算。对于一组 $N_{valid}$ 个有效的 bootstrap 估计值 $\\{\\hat{K}_{d,j}^*\\}_{j=1}^{N_{valid}}$：\n$$\\text{Skewness} = \\frac{\\frac{1}{N_{valid}} \\sum_{j=1}^{N_{valid}} (\\hat{K}_{d,j}^* - \\bar{K}_d^*)^3}{\\left(\\frac{1}{N_{valid}} \\sum_{j=1}^{N_{valid}} (\\hat{K}_{d,j}^* - \\bar{K}_d^*)^2\\right)^{3/2}}$$\n其中 $\\bar{K}_d^*$ 是有效 bootstrap 估计值的均值。\n\n程序将为每个测试用例执行这些步骤。它将首先根据结合等温线和指定的噪声模型模拟含噪声的数据。然后，它将执行 Scatchard 分析，使用渐近和 bootstrap 两种方法计算所需的统计量，最后计算指定的输出指标：bootstrap 与渐近置信区间宽度的比率、bootstrap 偏度以及被丢弃的 bootstrap 样本的比例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    M_REPLICATES = 3\n    B_BOOTSTRAP = 5000\n    Z_VAL = 1.96\n    RANDOM_SEED = 12345\n    MIN_VALID_BOOTSTRAPS = 100\n\n    test_cases = [\n        {\n            \"B_max\": 100.0, \"K_d\": 30.0,\n            \"concentrations\": np.array([1, 2, 5, 10, 20, 30, 50, 75, 100, 150, 200, 300], dtype=float),\n            \"noise_std\": 5.0\n        },\n        {\n            \"B_max\": 100.0, \"K_d\": 30.0,\n            \"concentrations\": np.array([1, 2, 5, 10, 20, 30, 50, 75, 100, 150, 200, 300], dtype=float),\n            \"noise_std\": 12.0\n        },\n        {\n            \"B_max\": 100.0, \"K_d\": 10.0,\n            \"concentrations\": np.array([5, 10, 20, 50, 200], dtype=float),\n            \"noise_std\": 2.0\n        }\n    ]\n\n    rng = np.random.default_rng(RANDOM_SEED)\n    results = []\n\n    for case in test_cases:\n        # Step 1: Simulate experimental data\n        B_max = case[\"B_max\"]\n        K_d_true = case[\"K_d\"]\n        c_values = case[\"concentrations\"]\n        noise_std = case[\"noise_std\"]\n\n        r_measured = []\n        for c in c_values:\n            r_true = (B_max * c) / (K_d_true + c)\n            noise = rng.normal(loc=0.0, scale=noise_std, size=M_REPLICATES)\n            noisy_replicates = r_true + noise\n            clipped_replicates = np.clip(noisy_replicates, 0, B_max)\n            r_measured.append(np.mean(clipped_replicates))\n        r_measured = np.array(r_measured)\n\n        # Step 2: Construct Scatchard data and perform OLS\n        x_data = r_measured\n        y_data = r_measured / c_values\n\n        def fit_ols(x, y):\n            n = len(x)\n            if n = 2:\n                return np.nan, np.nan\n\n            x_mean, y_mean = np.mean(x), np.mean(y)\n            S_xx = np.sum((x - x_mean)**2)\n            S_xy = np.sum((x - x_mean) * (y - y_mean))\n            \n            if S_xx == 0:\n                return np.nan, np.nan\n            \n            s_hat = S_xy / S_xx\n            alpha_hat = y_mean - s_hat * x_mean\n            \n            y_pred = alpha_hat + s_hat * x\n            residuals = y - y_pred\n            rss = np.sum(residuals**2)\n            \n            sigma_e_sq = rss / (n - 2)\n            var_s_hat = sigma_e_sq / S_xx\n            se_s_hat = np.sqrt(var_s_hat)\n            \n            return s_hat, se_s_hat\n\n        s_hat, se_s_hat = fit_ols(x_data, y_data)\n        \n        # Step 3: Asymptotic Normal Approximation\n        if s_hat >= 0 or np.isnan(s_hat):\n             # The primary fit is invalid, can't proceed\n            asymptotic_width = np.nan\n        else:\n            k_d_hat = -1.0 / s_hat\n            se_k_d_hat = se_s_hat / (s_hat**2)\n            asymptotic_ci_half_width = Z_VAL * se_k_d_hat\n            asymptotic_width = 2.0 * asymptotic_ci_half_width\n\n        # Step 4: Nonparametric Bootstrap\n        k_d_bootstrap_dist = []\n        discarded_count = 0\n        n_points = len(x_data)\n\n        for _ in range(B_BOOTSTRAP):\n            indices = rng.choice(n_points, size=n_points, replace=True)\n            x_boot = x_data[indices]\n            y_boot = y_data[indices]\n\n            # Check for degenerate resample (zero variance in x)\n            if np.var(x_boot) == 0:\n                discarded_count += 1\n                continue\n\n            s_boot, _ = fit_ols(x_boot, y_boot)\n\n            # Check for non-negative slope or failed fit\n            if np.isnan(s_boot) or s_boot >= 0:\n                discarded_count += 1\n                continue\n\n            k_d_boot = -1.0 / s_boot\n            k_d_bootstrap_dist.append(k_d_boot)\n\n        k_d_bootstrap_dist = np.array(k_d_bootstrap_dist)\n        valid_count = len(k_d_bootstrap_dist)\n        \n        # Calculate bootstrap statistics if enough valid samples exist\n        if valid_count  MIN_VALID_BOOTSTRAPS:\n            bootstrap_width = np.nan\n            bootstrap_skewness = np.nan\n        else:\n            # Percentile CI\n            ci_lower, ci_upper = np.percentile(k_d_bootstrap_dist, [2.5, 97.5])\n            bootstrap_width = ci_upper - ci_lower\n\n            # Sample Skewness\n            mean_k = np.mean(k_d_bootstrap_dist)\n            std_k = np.std(k_d_bootstrap_dist) # ddof=0 is default\n\n            if std_k == 0:\n                 bootstrap_skewness = 0.0\n            else:\n                 m3 = np.mean((k_d_bootstrap_dist - mean_k)**3)\n                 bootstrap_skewness = m3 / (std_k**3)\n\n        # Step 5: Compute final output metrics\n        if np.isnan(bootstrap_width) or np.isnan(asymptotic_width) or asymptotic_width == 0:\n            width_ratio = np.nan\n        else:\n            width_ratio = bootstrap_width / asymptotic_width\n\n        fraction_discarded = discarded_count / B_BOOTSTRAP\n        \n        results.append([width_ratio, bootstrap_skewness, fraction_discarded])\n\n    # Final print statement in the exact required format.\n    # Using repr to get high-precision output, then formatting as required.\n    formatted_results = []\n    for res in results:\n        formatted_results.append(f\"[{', '.join(map(repr, res))}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2544775"}]}