{"hands_on_practices": [{"introduction": "这个基础练习将引导你完成一个完整的假设检验流程。我们将使用符号检验，这是一种简单直观的非参数方法，来从头计算p值。通过这个练习[@problem_id:1963412]，你将巩固假设检验的核心逻辑，即在零假设成立的条件下，观察到的结果或更极端结果出现的概率。", "problem": "一位材料科学家开发了一种旨在提高热稳定性的新型聚合物共混物。工业中使用的标准聚合物具有公认的50摄氏度的熔点中位数。该科学家声称她的新共混物的熔点中位数大于50摄氏度。为检验这一说法，随机抽取了12个新共混物的样本，并测量了它们各自的熔点。结果显示，9个样本的熔点高于50摄氏度，其余3个样本的熔点低于50摄氏度。没有样本的熔点恰好为50摄氏度。\n\n使用符号检验，计算用于评估该科学家说法的假设检验的p值。将最终答案四舍五入至四位有效数字。", "solution": "我们使用符号检验来检验关于中位数的说法。设 $M$ 表示真实的熔点中位数。假设为\n$$\nH_{0}: M = 50 \\quad \\text{versus} \\quad H_{1}: M > 50.\n$$\n在 $H_{0}$ 下，每个观测值高于或低于50的概率是相等的（假设没有相同值），因此“正号”的数量 $X$（高于50的观测值）服从二项分布：\n$$\nX \\sim \\text{Binomial}(n,p) \\quad \\text{with} \\quad n=12,\\ p=\\frac{1}{2}.\n$$\n样本中12个观测值里产生了 $x=9$ 个正号。对于单侧备择假设 $H_{1}: M>50$，p值是右尾概率\n$$\n\\text{p-value} = \\Pr(X \\geq 9 \\mid H_{0}) = \\sum_{k=9}^{12} \\binom{12}{k} \\left(\\frac{1}{2}\\right)^{12}.\n$$\n计算二项式系数之和：\n$$\n\\binom{12}{9} + \\binom{12}{10} + \\binom{12}{11} + \\binom{12}{12} = 220 + 66 + 12 + 1 = 299.\n$$\n因此，\n$$\n\\text{p-value} = \\frac{299}{2^{12}} = \\frac{299}{4096}.\n$$\n转换为小数并四舍五入至四位有效数字，得到\n$$\n\\frac{299}{4096} \\approx 0.072998046875 \\approx 0.07300 \\text{ (four significant figures).}\n$$", "answer": "$$\\boxed{0.07300}$$", "id": "1963412"}, {"introduction": "在系统生物学中，我们经常处理分类数据，例如判断一个蛋白质是否属于某个功能类别。这个练习[@problem_id:1438416]要求你批判性地思考常用统计检验（如卡方检验）背后的假设，并理解为什么在处理小样本数据时，费雪精确检验是更合适的选择。掌握如何根据数据特性选择正确的统计工具是至关重要的技能。", "problem": "在一个旨在理解蛋白质信号网络的系统生物学实验中，一名研究人员进行了一项蛋白质组范围的分析。目标是研究蛋白质被磷酸化与其本身是激酶之间是否存在非随机关联。根据实验数据，研究人员整理出以下观察结果：\n\n- 在一个由5个被鉴定为已磷酸化的蛋白质样本中，有3个是已知的激酶。\n- 在另一个由100个被鉴定为未磷酸化的蛋白质样本中，有10个是已知的激酶。\n\n研究人员希望进行一项统计检验，以确定在磷酸化和非磷酸化组之间，激酶的比例是否存在显著差异。一位同事建议，对于此分析，费雪精确检验（Fisher's Exact Test）比更常见的皮尔逊卡方检验（Pearson's chi-squared test）更合适。\n\n在这一特定情境下，以下哪个陈述为选择费雪精确检验而非卡方检验提供了最准确的统计学理由？\n\nA. 总样本量（$N=105$）很大，这会导致卡方统计量被人为地夸大，而费雪精确检验是为较小的总样本量设计的。\n\nB. 为了使卡方检验有效，数据必须假设服从正态分布，而这个假设在这里被违反了。费雪精确检验是一种不需要此假设的非参数替代方法。\n\nC. 卡方检验是一种近似方法，其有效性取决于每个类别中的期望频数足够大。在此数据集中，原假设下至少有一个期望频数太小，使得该近似不可靠。\n\nD. 磷酸化组中的观测计数（3和2）都是奇数，这是一种已知的情况，其中连续的卡方分布不能很好地近似数据的离散性。\n\nE. 应该使用费雪精确检验，因为它提供了一种关联强度的度量（比值比），而卡方检验只提供一个p值。", "solution": "我们想要检验在磷酸化和非磷酸化组中，激酶的比例是否相同。设行代表磷酸化状态 $P$ 和 $\\bar{P}$，列代表激酶状态 $K$ 和 $\\bar{K}$。观测到的计数为\n$$\nO_{PK}=3,\\quad O_{P\\bar{K}}=2,\\quad O_{\\bar{P}K}=10,\\quad O_{\\bar{P}\\bar{K}}=90.\n$$\n行总计为 $n_{P}=5$ 和 $n_{\\bar{P}}=100$，列总计为 $m_{K}=13$ 和 $m_{\\bar{K}}=92$，总计为 $N=105$。\n\n在原假设（即两个组的激酶比例相等）下，$2\\times 2$ 表中的期望计数由以下公式给出\n$$\nE_{ij}=\\frac{(\\text{row total}_{i})(\\text{column total}_{j})}{N}.\n$$\n因此，\n$$\nE_{PK}=\\frac{n_{P}m_{K}}{N}=\\frac{5\\cdot 13}{105}=\\frac{13}{21},\\quad\nE_{P\\bar{K}}=\\frac{n_{P}m_{\\bar{K}}}{N}=\\frac{5\\cdot 92}{105}=\\frac{92}{21},\n$$\n$$\nE_{\\bar{P}K}=\\frac{n_{\\bar{P}}m_{K}}{N}=\\frac{100\\cdot 13}{105}=\\frac{260}{21},\\quad\nE_{\\bar{P}\\bar{K}}=\\frac{n_{\\bar{P}}m_{\\bar{K}}}{N}=\\frac{100\\cdot 92}{105}=\\frac{1840}{21}.\n$$\n\n皮尔逊卡方近似有效性的一个标准条件是所有期望计数都足够大（通常要求每个 $E_{ij}\\geq 5$）。由于 $E_{PK} = 13/21 \\approx 0.62$ 且 $E_{P\\bar{K}} = 92/21 \\approx 4.38$，所以至少有两个期望计数小于5。这违反了卡方近似方法可靠性所需的大样本条件。\n\n相比之下，费雪精确检验以固定的边际为条件，并提供一个精确的p值，而不需要大的期望计数。因此，在这种情况下，它更受青睐。\n\n评估各个选项：\n- A 是不正确的：问题不在于 $N$ 很大，选择费雪检验不是因为总样本量 $N$ 小，而是因为某些期望计数很小。\n- B 是不正确的：卡方检验不要求数据服从正态分布；它依赖于对单元格计数的大样本近似。\n- C 是正确的：当期望频数很小时，卡方近似可能不可靠，而这种情况在这里发生了。\n- D 是不正确的：观测计数的奇偶性是无关紧要的。\n- E 是误导性的：两种方法都可以报告比值比；这不是选择费雪检验的主要原因。\n\n因此，最准确的理由是，由于此数据集中存在较小的期望频数，卡方近似不可靠，所以更倾向于使用费雪精确检验。", "answer": "$$\\boxed{C}$$", "id": "1438416"}, {"introduction": "现代系统生物学研究（如蛋白质组学或基因组学）通常涉及同时进行数千次假设检验，这带来了多重比较的挑战。这个计算练习[@problem_id:2399004]将向你介绍Benjamini-Hochberg程序，这是一种控制伪发现率（FDR）的强大方法。通过动手实现这一关键算法，你将学会如何在大规模数据分析中有效地区分出真正的生物学信号。", "problem": "给定一个受磷酸化蛋白质组学研究启发的多重检验场景。考虑与一组p值和目标错误发现率（FDR）水平相关的一系列零假设。对于 $m$ 个检验，水平为 $q \\in (0,1)$ 的 Benjamini-Hochberg (BH) 程序定义如下。令 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(m)}$ 表示排序后的p值。定义\n$$\nk^{\\star} = \\max\\left\\{k \\in \\{1,\\dots,m\\} : p_{(k)} \\le \\frac{k}{m} q \\right\\},\n$$\n约定空集上的最大值产生 $k^{\\star}=0$。BH 程序恰好拒绝具有 $k^{\\star}$ 个最小p值的 $k^{\\star}$ 个假设。定义决策阈值\n$$\n\\tau = \\begin{cases}\n\\frac{k^{\\star}}{m} q,  \\text{if } k^{\\star} \\ge 1,\\\\\n0,  \\text{if } k^{\\star} = 0.\n\\end{cases}\n$$\n您的任务是实现这个精确的决策规则，并为下面的每个测试用例计算并报告有序对 $(k^{\\star}, \\tau)$。\n\n该测试套件包含五个用例，旨在探究正确性、边界行为、相同值处理和可扩展性。在每个用例中，p值都应被视为闭区间 $[0,1]$ 内的给定实数，并且必须严格按照上述 BH 定义进行应用。\n\n测试用例：\n- 用例 A (小型，含边界值): $m=5$，p值为 $[0.0,\\,0.2,\\,0.5,\\,1.0,\\,0.8]$，且 $q=0.1$。\n- 用例 B (无拒绝): $m=4$，p值为 $[0.2,\\,0.4,\\,0.6,\\,0.8]$，且 $q=0.01$。\n- 用例 C (小p值中存在相同值): $m=5$，p值为 $[0.0005,\\,0.0005,\\,0.001,\\,0.01,\\,0.02]$，且 $q=0.05$。\n- 用例 D (在 $m=15000$ 时的确定性大规模混合): 按如下方式构造备择p值和零p值的确定性混合。令 $m_{\\mathrm{alt}}=1500$ 且 $m_{\\mathrm{null}}=13500$，因此 $m_{\\mathrm{alt}}+m_{\\mathrm{null}}=15000$。定义备择集 $\\{p^{(\\mathrm{A})}_i\\}_{i=1}^{m_{\\mathrm{alt}}}$ 为 $p^{(\\mathrm{A})}_i = \\left(\\frac{i - 0.5}{1500}\\right)^2$，其中 $i=1,2,\\dots,1500$。定义零集 $\\{p^{(\\mathrm{N})}_j\\}_{j=1}^{m_{\\mathrm{null}}}$ 为 $p^{(\\mathrm{N})}_j = \\frac{j - 0.5}{13500}$，其中 $j=1,2,\\dots,13500$。这 $15000$ 个p值的完整集合是这两个集合的多重集并集，顺序任意。使用 $q=0.01$。\n- 用例 E (在决策边界上相等): $m=10$，p值为 $[0.5,\\,0.99,\\,0.6,\\,0.04,\\,0.001,\\,0.95,\\,0.8,\\,0.61,\\,0.9,\\,0.07]$，且 $q=0.2$。\n\n最终输出格式：\n- 按 A、B、C、D、E 的顺序为每个用例计算 $k^{\\star}$ 和 $\\tau$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[k^{\\star}_{\\mathrm{A}}, \\tau_{\\mathrm{A}}, k^{\\star}_{\\mathrm{B}}, \\tau_{\\mathrm{B}}, k^{\\star}_{\\mathrm{C}}, \\tau_{\\mathrm{C}}, k^{\\star}_{\\mathrm{D}}, \\tau_{\\mathrm{D}}, k^{\\star}_{\\mathrm{E}}, \\tau_{\\mathrm{E}}]$。$k^{\\star}$ 条目必须是整数，每个 $\\tau$ 必须使用标准四舍五入到小数点后 $12$ 位。不涉及物理单位；所有量均为无量纲实数。", "solution": "在尝试解决方案之前，必须首先对问题陈述进行严格验证。\n\n**步骤1：提取给定信息**\n以下是逐字提供的数据和定义：\n- 与一组p值和目标错误发现率（FDR）水平 $q \\in (0,1)$ 相关的一系列零假设。\n- 定义了用于 $m$ 个检验的、水平为 $q$ 的 Benjamini-Hochberg (BH) 程序。\n- $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(m)}$ 表示排序后的p值。\n- 拒绝的数量是 $k^{\\star} = \\max\\left\\{k \\in \\{1,\\dots,m\\} : p_{(k)} \\le \\frac{k}{m} q \\right\\}$。\n- 一项约定指出，空集上的最大值产生 $k^{\\star}=0$。\n- BH 程序拒绝与 $k^{\\star}$ 个最小p值相对应的假设。\n- 决策阈值定义为 $\\tau = \\begin{cases} \\frac{k^{\\star}}{m} q,  \\text{if } k^{\\star} \\ge 1,\\\\ 0,  \\text{if } k^{\\star} = 0. \\end{cases}$\n- 任务是为五个测试用例计算并报告有序对 $(k^{\\star}, \\tau)$。\n- 用例 A: $m=5$，p值为 $[0.0,\\,0.2,\\,0.5,\\,1.0,\\,0.8]$，且 $q=0.1$。\n- 用例 B: $m=4$，p值为 $[0.2,\\,0.4,\\,0.6,\\,0.8]$，且 $q=0.01$。\n- 用例 C: $m=5$，p值为 $[0.0005,\\,0.0005,\\,0.001,\\,0.01,\\,0.02]$，且 $q=0.05$。\n- 用例 D: $m=15000$。由 $m_{\\mathrm{alt}}=1500$ 个备择p值（定义为 $p^{(\\mathrm{A})}_i = \\left(\\frac{i - 0.5}{1500}\\right)^2$，其中 $i=1,2,\\dots,1500$）和 $m_{\\mathrm{null}}=13500$ 个零p值（定义为 $p^{(\\mathrm{N})}_j = \\frac{j - 0.5}{13500}$，其中 $j=1,2,\\dots,13500$）构成的确定性混合。完整集合是这两个集合的并集。FDR水平为 $q=0.01$。\n- 用例 E: $m=10$，p值为 $[0.5,\\,0.99,\\,0.6,\\,0.04,\\,0.001,\\,0.95,\\,0.8,\\,0.61,\\,0.9,\\,0.07]$，且 $q=0.2$。\n- 最终输出必须是包含 $[k^{\\star}_{\\mathrm{A}}, \\tau_{\\mathrm{A}}, k^{\\star}_{\\mathrm{B}}, \\tau_{\\mathrm{B}}, k^{\\star}_{\\mathrm{C}}, \\tau_{\\mathrm{C}}, k^{\\star}_{\\mathrm{D}}, \\tau_{\\mathrm{D}}, k^{\\star}_{\\mathrm{E}}, \\tau_{\\mathrm{E}}]$ 的单行，其中 $k^{\\star}$ 为整数，$\\tau$ 四舍五入到小数点后12位。\n\n**步骤2：使用提取的给定信息进行验证**\n根据所需标准对问题进行评估：\n- **科学依据**：该问题基于 Benjamini-Hochberg 程序，这是控制多重假设检验中错误发现率的统计方法的基石。这是一种标准且经过严格建立的技术，其在磷酸化蛋白质组学研究中的应用是一个典型例子。该问题在事实上是合理的。\n- **定义明确**：$k^{\\star}$ 和 $\\tau$ 的定义是精确且在数学上无歧义的。对于任何有效的p值输入集和参数 $q$，该程序保证了唯一的结果。\n- **客观性**：该问题使用精确的数学定义和数值数据来表述。它不含主观、推测性或基于意见的陈述。\n- **完整性和一致性**：每个测试用例的所有必要参数（$m$、p值、$q$）都已明确提供。定义是自洽的。\n- **现实性和可行性**：p值是有效的（在 $[0,1]$ 区间内），并且计算任务使用标准数值库是可行的。\n- 该问题已完全指定，并且属于计算生物学领域，特别是在假设检验框架内。\n\n**步骤3：结论和行动**\n该问题是有效的。它是一个基于已建立的统计理论、定义明确的计算练习。现在将构建一个完整的解决方案。\n\n问题的核心是实现 Benjamini-Hochberg (BH) 程序。对于每个测试用例，我们都给定了 $m$ 个p值和目标错误发现率 (FDR) $q$。$(k^{\\star}, \\tau)$ 的计算通过一个清晰的算法进行。\n\n首先，必须将给定的 $m$ 个p值集合 $\\{p_1, p_2, \\dots, p_m\\}$ 按非降序排序，以产生排序后的p值 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(m)}$。\n\n其次，我们确定 $k^{\\star}$，它是集合 $\\{1, 2, \\dots, m\\}$ 中满足 BH 条件的最大索引 $k$：\n$$\np_{(k)} \\le \\frac{k}{m} q\n$$\n如果不存在这样的 $k$，则根据问题的明确约定，$k^{\\star}$ 取为 $0$。一种直接的计算策略是，对从 $1$ 到 $m$ 的每个 $k$ 检查此条件，并找出使其成立的最大 $k$。\n\n第三，一旦找到 $k^{\\star}$，就计算决策阈值 $\\tau$。如果 $k^{\\star} \\ge 1$，$\\tau$ 是此索引处的 BH 边界值：$\\tau = \\frac{k^{\\star}}{m} q$。如果没有假设被拒绝，即 $k^{\\star} = 0$，则阈值就是 $\\tau = 0$。\n\n此程序应用于每个测试用例。\n\n用例 A: $m=5$，p值为 $[0.0, 0.2, 0.5, 1.0, 0.8]$，且 $q=0.1$。\n排序后的p值是 $p_{(1)}=0.0$，$p_{(2)}=0.2$，$p_{(3)}=0.5$，$p_{(4)}=0.8$，$p_{(5)}=1.0$。\n为 $k \\in \\{1, 2, 3, 4, 5\\}$ 计算 BH 阈值 $\\frac{k}{m}q$：$[0.02, 0.04, 0.06, 0.08, 0.1]$。\n- 对于 $k=1$：$p_{(1)} = 0.0 \\le 0.02$。条件满足。\n- 对于 $k=2$：$p_{(2)} = 0.2 \\not\\le 0.04$。条件不满足。\n- 对于 $k > 2$ 的后续检查也将失败，因为在此区域 $p_{(k)}$ 的增长速度快于线性阈值。\n条件成立的最大且唯一的 $k$ 是 $k=1$。因此，$k^{\\star}=1$。\n相应的阈值是 $\\tau = \\frac{1}{5}(0.1) = 0.02$。\n\n用例 B: $m=4$，p值为 $[0.2, 0.4, 0.6, 0.8]$，且 $q=0.01$。\np值已经排序。$p_{(1)}=0.2$，$p_{(2)}=0.4$，$p_{(3)}=0.6$，$p_{(4)}=0.8$。\nBH 阈值是 $[0.0025, 0.005, 0.0075, 0.01]$。\n比较显示，对于每个 $k \\in \\{1, 2, 3, 4\\}$，都有 $p_{(k)} > \\frac{k}{m}q$。\n满足条件的 $k$ 的集合是空的。根据约定，$k^{\\star}=0$。\n因此，阈值为 $\\tau = 0$。\n\n用例 C: $m=5$，p值为 $[0.0005, 0.0005, 0.001, 0.01, 0.02]$，且 $q=0.05$。\np值已经排序。\nBH 阈值是 $[0.01, 0.02, 0.03, 0.04, 0.05]$。\n- 对于 $k=1$：$p_{(1)}=0.0005 \\le 0.01$。\n- 对于 $k=2$：$p_{(2)}=0.0005 \\le 0.02$。\n- 对于 $k=3$：$p_{(3)}=0.001 \\le 0.03$。\n- 对于 $k=4$：$p_{(4)}=0.01 \\le 0.04$。\n- 对于 $k=5$：$p_{(5)}=0.02 \\le 0.05$。\n对于所有从 $1$ 到 $5$ 的 $k$，条件都满足。其中最大的 $k$ 是 $5$。\n因此，$k^{\\star}=5$。阈值是 $\\tau = \\frac{5}{5}(0.05) = 0.05$。\n\n用例 D: $m=15000$ 且 $q=0.01$。\np值是通过两个集合的并集生成的：一个备择集，包含 $m_{\\mathrm{alt}}=1500$ 个值，$p^{(\\mathrm{A})}_i = \\left(\\frac{i - 0.5}{1500}\\right)^2$；以及一个零集，包含 $m_{\\mathrm{null}}=13500$ 个值，$p^{(\\mathrm{N})}_j = \\frac{j - 0.5}{13500}$。\n鉴于检验数量巨大（$m=15000$），手动计算不切实际。解决方案需要一种计算方法：\n1. 生成 1500 个备择p值和 13500 个零p值。\n2. 将它们合并成一个包含 15000 个p值的数组。\n3. 对该数组进行排序以获得 $p_{(1)}, \\dots, p_{(15000)}$。\n4. 为 $k=1, \\dots, 15000$ 创建一个 BH 阈值数组 $\\frac{k}{15000}(0.01)$。\n5. 找到所有满足 $p_{(k)} \\le \\frac{k}{15000}(0.01)$ 的索引 $k$，并选择其中最大的 $k$ 作为 $k^{\\star}$。\n6. 基于此 $k^{\\star}$ 计算 $\\tau$。\n最终答案中的实现将执行这些步骤。\n\n用例 E: $m=10$，p值为 $[0.5, 0.99, 0.6, 0.04, 0.001, 0.95, 0.8, 0.61, 0.9, 0.07]$，且 $q=0.2$。\n排序后的p值是 $p_{(1)}=0.001, p_{(2)}=0.04, p_{(3)}=0.07, p_{(4)}=0.5, p_{(5)}=0.6, p_{(6)}=0.61, p_{(7)}=0.8, p_{(8)}=0.9, p_{(9)}=0.95, p_{(10)}=0.99$。\nBH 阈值 $\\frac{k}{10}(0.2)$ 是 $[0.02, 0.04, 0.06, 0.08, 0.1, 0.12, 0.14, 0.16, 0.18, 0.2]$。\n- 对于 $k=1$：$p_{(1)}=0.001 \\le 0.02$。满足。\n- 对于 $k=2$：$p_{(2)}=0.04 \\le 0.04$。满足。等式由非严格不等式处理。\n- 对于 $k=3$：$p_{(3)}=0.07 \\not\\le 0.06$。不满足。\n条件成立的最大 $k$ 是 $k=2$。\n因此，$k^{\\star}=2$。阈值是 $\\tau = \\frac{2}{10}(0.2) = 0.04$。\n\n最终的程序将系统地将此逻辑应用于所有用例，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Benjamini-Hochberg procedure parameters (k*, tau)\n    for a suite of test cases.\n    \"\"\"\n\n    def benjamini_hochberg(p_values: list[float] | np.ndarray, q: float) - tuple[int, float]:\n        \"\"\"\n        Applies the Benjamini-Hochberg procedure to a set of p-values.\n\n        Args:\n            p_values: A list or numpy array of p-values.\n            q: The target False Discovery Rate (FDR) level.\n\n        Returns:\n            A tuple (k_star, tau) where k_star is the number of rejected hypotheses\n            and tau is the decision threshold.\n        \"\"\"\n        p_values_arr = np.array(p_values)\n        m = len(p_values_arr)\n\n        if m == 0:\n            return 0, 0.0\n\n        # 1. Sort the p-values in non-decreasing order.\n        p_sorted = np.sort(p_values_arr)\n\n        # 2. Find k_star.\n        k = np.arange(1, m + 1)\n        thresholds = (k / m) * q\n\n        # Find all indices where the BH condition p_(k) = (k/m)*q is met.\n        # np.where returns indices where the condition is true.\n        # Python arrays are 0-indexed, so p_sorted[i] corresponds to p_(i+1).\n        satisfying_indices = np.where(p_sorted = thresholds)[0]\n\n        if satisfying_indices.size == 0:\n            # The maximum over an empty set is defined as 0.\n            k_star = 0\n        else:\n            # The largest k is found from the last index that satisfied the condition.\n            # Convert 0-based index to 1-based k.\n            k_star = satisfying_indices[-1] + 1\n        \n        # 3. Calculate tau based on k_star.\n        if k_star > 0:\n            tau = (k_star / m) * q\n        else:\n            tau = 0.0\n            \n        return k_star, tau\n\n    # Define test cases from the problem statement\n    test_cases_params = [\n        # Case A\n        {'p_values': [0.0, 0.2, 0.5, 1.0, 0.8], 'q': 0.1},\n        # Case B\n        {'p_values': [0.2, 0.4, 0.6, 0.8], 'q': 0.01},\n        # Case C\n        {'p_values': [0.0005, 0.0005, 0.001, 0.01, 0.02], 'q': 0.05},\n        # Case D\n        {'p_values': None, 'q': 0.01}, # p-values to be generated\n        # Case E\n        {'p_values': [0.5, 0.99, 0.6, 0.04, 0.001, 0.95, 0.8, 0.61, 0.9, 0.07], 'q': 0.2},\n    ]\n\n    # Generate p-values for Case D\n    m_alt = 1500\n    m_null = 13500\n    i = np.arange(1, m_alt + 1)\n    j = np.arange(1, m_null + 1)\n    p_alt = ((i - 0.5) / m_alt)**2\n    p_null = (j - 0.5) / m_null\n    p_D = np.concatenate((p_alt, p_null))\n    test_cases_params[3]['p_values'] = p_D\n\n    results = []\n    for case in test_cases_params:\n        k_star, tau = benjamini_hochberg(case['p_values'], case['q'])\n        results.append(str(k_star))\n        # Format tau to 12 decimal places as specified.\n        results.append(f\"{tau:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2399004"}]}