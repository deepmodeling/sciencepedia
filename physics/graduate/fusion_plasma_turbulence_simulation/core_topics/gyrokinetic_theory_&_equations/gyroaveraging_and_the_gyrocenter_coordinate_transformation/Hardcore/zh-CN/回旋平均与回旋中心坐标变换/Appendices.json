{
    "hands_on_practices": [
        {
            "introduction": "为了在回旋中心坐标系中正确地建立动理学理论，我们必须首先理解相空间体积元如何在该坐标系下进行变换。这项基础练习将引导您计算从粒子坐标 $(\\mathbf{r}, \\mathbf{v})$ 到回旋中心坐标 $(\\mathbf{X}, v_{\\parallel}, \\mu, \\theta)$ 变换的雅可比行列式。掌握这一推导对于正确写出回旋动理学 Vlasov 方程并确保其守恒性质至关重要 。",
            "id": "4191156",
            "problem": "考虑一个单组分离子等离子体，处于一个均匀、不随时变的磁场 $\\mathbf{B}(\\mathbf{r}) = B\\,\\mathbf{b}$ 中，其中 $B$ 是大小恒定的磁场强度，$\\mathbf{b}$ 是单位矢量。采用回旋中心坐标 $(\\mathbf{X}, v_{\\parallel}, \\mu, \\theta)$，其由以下几个部分定义：回旋中心位置 $\\mathbf{X}$，平行速度 $v_{\\parallel} \\equiv \\mathbf{v}\\cdot\\mathbf{b}$，磁矩 $\\mu \\equiv \\frac{m\\,v_{\\perp}^{2}}{2\\,B}$（其中 $v_{\\perp}$ 是粒子速度垂直于 $\\mathbf{b}$ 的分量的大小），以及回旋相位 $\\theta$（它参数化了 $\\mathbf{v}_{\\perp}$ 在与 $\\mathbf{b}$ 正交的平面内的方向）。设 $(\\widehat{\\mathbf{e}}_{1},\\widehat{\\mathbf{e}}_{2},\\mathbf{b})$ 为一个标准正交标架，其中 $(\\widehat{\\mathbf{e}}_{1},\\widehat{\\mathbf{e}}_{2})$ 张成垂直于 $\\mathbf{b}$ 的平面。粒子的位置和速度表示为\n$$\n\\mathbf{r} \\;=\\; \\mathbf{X} + \\boldsymbol{\\rho}, \\qquad \\mathbf{v} \\;=\\; v_{\\parallel}\\,\\mathbf{b} + v_{\\perp}\\,\\big(\\cos\\theta\\,\\widehat{\\mathbf{e}}_{1} + \\sin\\theta\\,\\widehat{\\mathbf{e}}_{2}\\big),\n$$\n其中拉莫尔半径矢量 $\\boldsymbol{\\rho}$ 由 $|\\boldsymbol{\\rho}| = v_{\\perp}/\\Omega$ 定义，$\\Omega$ 是回旋频率。你可以假设 $\\boldsymbol{\\rho}$ 依赖于 $(\\mu,\\theta)$ 但不依赖于 $\\mathbf{X}$。\n\n从以上定义以及坐标变换和体积元的基本性质出发，计算六维相空间体积元 $d^{3}\\mathbf{r}\\,d^{3}\\mathbf{v}$ 到 $d^{3}\\mathbf{X}\\,d v_{\\parallel}\\,d\\mu\\,d\\theta$ 的变换，并求出雅可比行列式 $\\mathcal{J}_{gc}$，使得\n$$\nd^{3}\\mathbf{r}\\,d^{3}\\mathbf{v} \\;=\\; \\mathcal{J}_{gc}\\;d^{3}\\mathbf{X}\\,d v_{\\parallel}\\,d\\mu\\,d\\theta\\,.\n$$\n将 $\\mathcal{J}_{gc}$ 表示为关于 $B$ 和 $m$ 的闭式解析表达式。无需进行数值计算，也无需四舍五入。请将最终答案以单个表达式的形式给出。",
            "solution": "该问题要求计算从粒子相空间坐标 $(\\mathbf{r}, \\mathbf{v})$ 到回旋中心坐标 $(\\mathbf{X}, v_{\\parallel}, \\mu, \\theta)$ 变换的雅可比行列式 $\\mathcal{J}_{gc}$。两个坐标系中体积元之间的关系由下式给出：\n$$\nd^{3}\\mathbf{r}\\,d^{3}\\mathbf{v} = \\mathcal{J}_{gc}\\;d^{3}\\mathbf{X}\\,d v_{\\parallel}\\,d\\mu\\,d\\theta\n$$\n其中 $\\mathcal{J}_{gc}$ 是坐标变换的雅可比矩阵行列式的绝对值。设粒子坐标表示为 $q_p = (r_1, r_2, r_3, v_1, v_2, v_3)$，回旋中心坐标表示为 $q_{gc} = (X_1, X_2, X_3, v_{\\parallel}, \\mu, \\theta)$。雅可比行列式为 $\\det\\left(\\frac{\\partial q_p}{\\partial q_{gc}}\\right)$。\n\n从回旋中心坐标到粒子坐标的变换由下式给出：\n$$\n\\mathbf{r} = \\mathbf{X} + \\boldsymbol{\\rho}(\\mu, \\theta)\n$$\n$$\n\\mathbf{v} = v_{\\parallel}\\mathbf{b} + \\mathbf{v}_{\\perp}(\\mu, \\theta)\n$$\n问题陈述 $\\boldsymbol{\\rho}$ 依赖于 $(\\mu, \\theta)$ 但不依赖于 $\\mathbf{X}$。从速度矢量 $\\mathbf{v}$ 的定义可以清楚地看出，$\\mathbf{v}$ 依赖于 $(v_{\\parallel}, \\mu, \\theta)$ 但不依赖于 $\\mathbf{X}$。磁场 $\\mathbf{B} = B\\mathbf{b}$ 是均匀的，因此 $B$ 和 $\\mathbf{b}$ 是常数。\n\n变换 $(\\mathbf{X}, v_{\\parallel}, \\mu, \\theta) \\to (\\mathbf{r}, \\mathbf{v})$ 的雅可比矩阵 $J$ 是一个 $6 \\times 6$ 矩阵，可以写成分块形式：\n$$\nJ = \\frac{\\partial(\\mathbf{r}, \\mathbf{v})}{\\partial(\\mathbf{X}, v_{\\parallel}, \\mu, \\theta)} = \\begin{pmatrix}\n\\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{X}}  \\frac{\\partial \\mathbf{r}}{\\partial v_{\\parallel}}  \\frac{\\partial \\mathbf{r}}{\\partial \\mu}  \\frac{\\partial \\mathbf{r}}{\\partial \\theta} \\\\\n\\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{X}}  \\frac{\\partial \\mathbf{v}}{\\partial v_{\\parallel}}  \\frac{\\partial \\mathbf{v}}{\\partial \\mu}  \\frac{\\partial \\mathbf{v}}{\\partial \\theta}\n\\end{pmatrix}\n$$\n让我们计算这些分块。左上角的分块是 $\\mathbf{r} = \\mathbf{X} + \\boldsymbol{\\rho}$ 对 $\\mathbf{X}$ 的导数。由于 $\\boldsymbol{\\rho}$ 不依赖于 $\\mathbf{X}$，这是一个 $3 \\times 3$ 的单位矩阵：\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{X}} = \\mathbf{I}_{3}\n$$\n左下角的分块是 $\\mathbf{v}$ 对 $\\mathbf{X}$ 的导数。由于 $\\mathbf{v}$ 不依赖于 $\\mathbf{X}$，这是一个 $3 \\times 3$ 的零矩阵：\n$$\n\\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{X}} = \\mathbf{0}_{3}\n$$\n将这些代入雅可比矩阵 $J$，我们得到一个分块上三角矩阵：\n$$\nJ = \\begin{pmatrix}\n\\mathbf{I}_{3}  \\frac{\\partial \\mathbf{r}}{\\partial (v_{\\parallel}, \\mu, \\theta)} \\\\\n\\mathbf{0}_{3}  \\frac{\\partial \\mathbf{v}}{\\partial (v_{\\parallel}, \\mu, \\theta)}\n\\end{pmatrix}\n$$\n分块三角矩阵的行列式是其对角线上分块的行列式的乘积。\n$$\n\\det(J) = \\det(\\mathbf{I}_{3}) \\cdot \\det\\left(\\frac{\\partial \\mathbf{v}}{\\partial (v_{\\parallel}, \\mu, \\theta)}\\right) = \\det\\left(\\frac{\\partial \\mathbf{v}}{\\partial (v_{\\parallel}, \\mu, \\theta)}\\right)\n$$\n相空间变换的雅可比行列式 $\\mathcal{J}_{gc}$ 是该行列式的绝对值：\n$$\n\\mathcal{J}_{gc} = \\left|\\det\\left(\\frac{\\partial \\mathbf{v}}{\\partial (v_{\\parallel}, \\mu, \\theta)}\\right)\\right|\n$$\n这意味着我们只需要考虑速度空间中的变换。让我们选择一个方便的笛卡尔坐标系，其中 $\\mathbf{b}$ 与 $z$ 轴对齐，即 $\\mathbf{b} = \\widehat{\\mathbf{z}}$。那么标准正交标架就是 $(\\widehat{\\mathbf{e}}_{1}, \\widehat{\\mathbf{e}}_{2}, \\mathbf{b})=(\\widehat{\\mathbf{x}}, \\widehat{\\mathbf{y}}, \\widehat{\\mathbf{z}})$。粒子速度分量 $(v_x, v_y, v_z)$ 与回旋中心速度坐标 $(v_{\\parallel}, \\mu, \\theta)$ 的关系如下：\n$v_z = \\mathbf{v} \\cdot \\mathbf{b} = v_{\\parallel}$。\n垂直速度矢量为 $\\mathbf{v}_{\\perp} = v_x \\widehat{\\mathbf{x}} + v_y \\widehat{\\mathbf{y}}$。其大小为 $v_{\\perp} = \\sqrt{v_x^2 + v_y^2}$。磁矩为 $\\mu = \\frac{m v_{\\perp}^2}{2B}$，这意味着 $v_{\\perp} = \\sqrt{\\frac{2B\\mu}{m}}$。\n根据问题陈述，$\\mathbf{v} = v_{\\parallel}\\,\\mathbf{b} + v_{\\perp}\\,\\big(\\cos\\theta\\,\\widehat{\\mathbf{e}}_{1} + \\sin\\theta\\,\\widehat{\\mathbf{e}}_{2}\\big)$，这给出了速度分量：\n$$\nv_x = v_{\\perp} \\cos\\theta = \\sqrt{\\frac{2B\\mu}{m}} \\cos\\theta\n$$\n$$\nv_y = v_{\\perp} \\sin\\theta = \\sqrt{\\frac{2B\\mu}{m}} \\sin\\theta\n$$\n$$\nv_z = v_{\\parallel}\n$$\n我们需要计算矩阵 $J_v = \\frac{\\partial(v_x, v_y, v_z)}{\\partial(v_{\\parallel}, \\mu, \\theta)}$ 的行列式：\n$$\nJ_v = \\begin{pmatrix}\n\\frac{\\partial v_x}{\\partial v_{\\parallel}}  \\frac{\\partial v_x}{\\partial \\mu}  \\frac{\\partial v_x}{\\partial \\theta} \\\\\n\\frac{\\partial v_y}{\\partial v_{\\parallel}}  \\frac{\\partial v_y}{\\partial \\mu}  \\frac{\\partial v_y}{\\partial \\theta} \\\\\n\\frac{\\partial v_z}{\\partial v_{\\parallel}}  \\frac{\\partial v_z}{\\partial \\mu}  \\frac{\\partial v_z}{\\partial \\theta}\n\\end{pmatrix}\n$$\n让我们计算这些偏导数：\n对 $v_{\\parallel}$ 的导数：\n$$\n\\frac{\\partial v_x}{\\partial v_{\\parallel}} = 0, \\quad \\frac{\\partial v_y}{\\partial v_{\\parallel}} = 0, \\quad \\frac{\\partial v_z}{\\partial v_{\\parallel}} = 1\n$$\n对 $\\mu$ 的导数：\n$$\n\\frac{\\partial v_x}{\\partial \\mu} = \\cos\\theta \\frac{\\partial}{\\partial \\mu}\\left(\\sqrt{\\frac{2B}{m}}\\mu^{1/2}\\right) = \\cos\\theta \\sqrt{\\frac{2B}{m}} \\frac{1}{2}\\mu^{-1/2} = \\cos\\theta \\sqrt{\\frac{B}{2m\\mu}}\n$$\n代入 $v_{\\perp} = \\sqrt{2B\\mu/m}$，我们得到 $\\sqrt{B/(2m\\mu)} = B/(m v_{\\perp})$。所以，$\\frac{\\partial v_x}{\\partial \\mu} = \\frac{B}{mv_{\\perp}}\\cos\\theta$。\n$$\n\\frac{\\partial v_y}{\\partial \\mu} = \\sin\\theta \\frac{\\partial}{\\partial \\mu}\\left(\\sqrt{\\frac{2B\\mu}{m}}\\right) = \\frac{B}{mv_{\\perp}}\\sin\\theta\n$$\n$$\n\\frac{\\partial v_z}{\\partial \\mu} = 0\n$$\n对 $\\theta$ 的导数：\n$$\n\\frac{\\partial v_x}{\\partial \\theta} = \\sqrt{\\frac{2B\\mu}{m}} (-\\sin\\theta) = -v_{\\perp} \\sin\\theta\n$$\n$$\n\\frac{\\partial v_y}{\\partial \\theta} = \\sqrt{\\frac{2B\\mu}{m}} (\\cos\\theta) = v_{\\perp} \\cos\\theta\n$$\n$$\n\\frac{\\partial v_z}{\\partial \\theta} = 0\n$$\n组合成矩阵 $J_v$：\n$$\nJ_v = \\begin{pmatrix}\n0  \\frac{B}{mv_{\\perp}}\\cos\\theta  -v_{\\perp}\\sin\\theta \\\\\n0  \\frac{B}{mv_{\\perp}}\\sin\\theta  v_{\\perp}\\cos\\theta \\\\\n1  0  0\n\\end{pmatrix}\n$$\n我们沿第一列进行余子式展开来计算行列式：\n$$\n\\det(J_v) = 1 \\cdot \\det\\begin{pmatrix}\n\\frac{B}{mv_{\\perp}}\\cos\\theta  -v_{\\perp}\\sin\\theta \\\\\n\\frac{B}{mv_{\\perp}}\\sin\\theta  v_{\\perp}\\cos\\theta\n\\end{pmatrix} - 0 + 0\n$$\n$$\n\\det(J_v) = \\left(\\frac{B}{mv_{\\perp}}\\cos\\theta\\right)(v_{\\perp}\\cos\\theta) - (-v_{\\perp}\\sin\\theta)\\left(\\frac{B}{mv_{\\perp}}\\sin\\theta\\right)\n$$\n$$\n\\det(J_v) = \\frac{B}{m}\\cos^2\\theta + \\frac{B}{m}\\sin^2\\theta = \\frac{B}{m}(\\cos^2\\theta + \\sin^2\\theta) = \\frac{B}{m}\n$$\n雅可比行列式 $\\mathcal{J}_{gc}$ 是该行列式的绝对值。由于磁场大小 $B$ 和离子质量 $m$ 都是正量，我们有：\n$$\n\\mathcal{J}_{gc} = \\left|\\frac{B}{m}\\right| = \\frac{B}{m}\n$$\n这个结果与粒子的状态无关，对于给定磁场中的给定物种是一个常数。\n因此，相空间体积元的变换为：\n$$\nd^{3}\\mathbf{r}\\,d^{3}\\mathbf{v} = \\frac{B}{m}\\;d^{3}\\mathbf{X}\\,d v_{\\parallel}\\,d\\mu\\,d\\theta\n$$",
            "answer": "$$\\boxed{\\frac{B}{m}}$$"
        },
        {
            "introduction": "在建立了坐标系之后，我们可以开始探索其中的粒子动力学。这项实践深入研究了由 $\\mathbf{E}\\times\\mathbf{B}$ 漂移主导的回旋中心运动的数值模拟，并揭示了计算物理学中的一个关键挑战：守恒律的保持。通过对一个傅里叶形式的势，比较一种朴素的离散回旋平均与一种精确的解析方法，您将发现看似微小的数值误差如何破坏能量守恒，并学会如何实施一个尊重系统底层哈密顿结构的修正方案 。",
            "id": "4191154",
            "problem": "考虑一个在沿 $z$ 轴方向的均匀磁场中的非相对论性离子，以及一个垂直于磁场平面的静电标量势。我们在归一化的回旋动理学单位下进行计算，其中电荷 $q$、磁场大小 $B$ 和光速标度 $c/B$ 均设为 $1$，因此所有量都是无量纲的。离子的运动在回旋中心坐标中描述，其位置 $\\mathbf{R}(t)$ 在平面内，并具有一个由磁矩决定的恒定拉莫尔半径 $\\rho$。回旋角 $\\theta$ 参数化了拉莫尔圆上的瞬时位置，回旋平均势由以下积分定义：\n$$\n\\overline{\\Phi}(\\mathbf{R}) \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\Phi\\big(\\mathbf{R} + \\rho\\,\\mathbf{e}_{\\theta}\\big)\\,d\\theta,\n$$\n其中 $\\mathbf{e}_{\\theta} = (\\cos\\theta,\\sin\\theta)$，$\\Phi(\\mathbf{x})$ 是静电势。垂直平面内的回旋中心动力学由 $\\mathbf{E}\\times\\mathbf{B}$ 漂移主导：\n$$\n\\frac{d\\mathbf{R}}{dt} = \\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}(\\mathbf{R}) = \\big(-\\partial_y \\overline{\\Phi}(\\mathbf{R}), \\,\\partial_x \\overline{\\Phi}(\\mathbf{R})\\big).\n$$\n\n从洛伦兹力定律和上述回旋平均势的定义出发，需要完成以下任务：\n\n1.  使用第一性原理，解释为什么对于一个不随时间变化的静电势 $\\Phi(\\mathbf{x})$（以及恒定的 $\\rho$），精确回旋中心哈密顿量 $H(\\mathbf{R}) = \\overline{\\Phi}(\\mathbf{R})$ 会沿着 $\\mathbf{E}\\times\\mathbf{B}$ 漂移的轨迹守恒。然后，论述一个用于回旋平均的有限点数 $N$ 的离散求积近似\n$$\n\\overline{\\Phi}_N(\\mathbf{R}) \\equiv \\frac{1}{N}\\sum_{m=0}^{N-1} \\Phi\\big(\\mathbf{R} + \\rho\\,\\mathbf{e}_{\\theta_m}\\big), \\quad \\theta_m = \\frac{2\\pi m}{N},\n$$\n在动力学方程中使用时，\n$$\n\\frac{d\\mathbf{R}}{dt} = \\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}_N(\\mathbf{R}),\n$$\n如何导致沿近似轨迹 $\\mathbf{R}_N(t)$ 计算的真实能量 $H(\\mathbf{R}) = \\overline{\\Phi}(\\mathbf{R})$ 发生漂移。\n\n2.  考虑一个由两个傅里叶模式构成的势，\n$$\n\\Phi(\\mathbf{x}) = A_1 \\cos(\\mathbf{k}_1\\cdot \\mathbf{x}) + A_2 \\cos(\\mathbf{k}_2\\cdot \\mathbf{x}),\n$$\n其振幅 $A_1$ 和 $A_2$ 固定，波矢 $\\mathbf{k}_1$ 和 $\\mathbf{k}_2$ 非共线。从基本定义出发，推导此类势的精确连续回旋平均 $\\overline{\\Phi}(\\mathbf{R})$ 及其梯度 $\\nabla \\overline{\\Phi}(\\mathbf{R})$。然后，提出一种修正方案，通过用傅里叶模式的精确连续回旋平均替代离散求积来恢复守恒性。你的修正方案必须在算法上可实现，并且应该通过计算 $\\nabla \\overline{\\Phi}(\\mathbf{R})$ 来实现，而不依赖于对回旋角的离散采样。\n\n3.  使用四阶龙格-库塔时间积分器对 $\\mathbf{E}\\times\\mathbf{B}$ 漂移常微分方程进行积分，实现回旋中心位置 $\\mathbf{R}(t)$ 的时变模拟，并包含两种变体：\n    -   方案 A（有限回旋角分辨率）：使用通过对 $N$ 个离散环点 $\\mathbf{R} + \\rho\\,\\mathbf{e}_{\\theta_m}$ 上的 $\\nabla \\Phi$ 求平均计算出的 $\\nabla \\overline{\\Phi}_N(\\mathbf{R})$。\n    -   方案 B（修正方案）：使用为傅里叶模式推导出的精确 $\\nabla \\overline{\\Phi}(\\mathbf{R})$。\n\n对于这两种方案，都使用在数值计算得到的终点上计算的精确连续回旋平均 $\\overline{\\Phi}$ 来计算真实能量漂移\n$$\n\\Delta H = \\left| \\overline{\\Phi}(\\mathbf{R}(T)) - \\overline{\\Phi}(\\mathbf{R}(0)) \\right|\n$$\n其中 $T$ 是总积分时间。\n\n在归一化的回旋动理学单位中使用以下科学上一致的参数值：\n-   拉莫尔半径：$\\rho = 0.35$。\n-   势振幅：$A_1 = 0.8$, $A_2 = 0.5$。\n-   波矢：$\\mathbf{k}_1 = (1.0,\\,0.8)$, $\\mathbf{k}_2 = (-0.6,\\,1.3)$。\n-   初始回旋中心位置：$\\mathbf{R}(0) = (0.37,\\,0.21)$。\n-   时间步长：$\\Delta t = 0.002$。\n-   时间步数：$N_t = 5000$，因此 $T = N_t\\,\\Delta t$。\n\n在所选的归一化单位中，所有量都是无量纲的。\n\n测试套件规范：\n-   情况 1（边界情况）：$N=1$ 个角度，方案 A（有限分辨率）。\n-   情况 2（理想路径）：$N=4$ 个角度，方案 A。\n-   情况 3（高分辨率）：$N=16$ 个角度，方案 A。\n-   情况 4（修正方案）：向代码提供 $N=4$ 个角度，但必须使用方案 B（即忽略离散的 $N$ 并应用基于精确连续回旋平均的梯度）。\n\n对于每种情况，计算如上定义的浮点数 $\\Delta H$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4]\"），顺序与列出的四种情况一致。每个结果必须表示为无量纲浮点数。",
            "solution": "### 基于原理的解决方案设计\n\n该解决方案分为三个部分，从基本原理到解析推导，最终到数值实现。\n\n**1. 回旋中心动力学的守恒性质**\n\n回旋中心运动是哈密顿系统的一个例子。对于精确动力学，哈密顿量就是回旋平均势本身，$H(\\mathbf{R}) = \\overline{\\Phi}(\\mathbf{R})$。哈密顿系统的一个基本性质是哈密顿量沿轨迹守恒。我们可以通过计算 $H$ 的全时间导数来明确证明这一点：\n$$\n\\frac{dH}{dt} = \\frac{d\\overline{\\Phi}(\\mathbf{R}(t))}{dt} = \\nabla\\overline{\\Phi}(\\mathbf{R}) \\cdot \\frac{d\\mathbf{R}}{dt}\n$$\n代入运动方程 $\\frac{d\\mathbf{R}}{dt} = \\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}(\\mathbf{R})$：\n$$\n\\frac{dH}{dt} = \\nabla\\overline{\\Phi} \\cdot (\\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi})\n$$\n这个表达式是形如 $\\mathbf{v} \\cdot (\\mathbf{u} \\times \\mathbf{v})$ 的标量三重积。对于任何向量 $\\mathbf{u}$ 和 $\\mathbf{v}$，这样的乘积恒等于零，因为根据定义，所得向量 $(\\mathbf{u} \\times \\mathbf{v})$ 与 $\\mathbf{v}$ 正交。因此，$\\frac{dH}{dt}=0$，真实的回旋中心能量是守恒的。\n\n当动力学使用离散的 $N$ 点求积近似进行回旋平均时，运动方程变为：\n$$\n\\frac{d\\mathbf{R}_N}{dt} = \\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}_N(\\mathbf{R}_N)\n$$\n其中 $\\mathbf{R}_N(t)$ 表示近似轨迹。*该*系统的守恒量是近似哈密顿量 $\\overline{\\Phi}_N(\\mathbf{R}_N)$。然而，具有物理意义的能量是真实哈密顿量 $H = \\overline{\\Phi}(\\mathbf{R})$。真实能量沿着近似轨迹的变化率为：\n$$\n\\frac{dH}{dt}\\bigg|_{\\mathbf{R}=\\mathbf{R}_N} = \\nabla\\overline{\\Phi}(\\mathbf{R}_N) \\cdot \\frac{d\\mathbf{R}_N}{dt} = \\nabla\\overline{\\Phi}(\\mathbf{R}_N) \\cdot \\big(\\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}_N(\\mathbf{R}_N)\\big)\n$$\n通常情况下，求积误差确保了 $\\nabla\\overline{\\Phi}(\\mathbf{R}_N) \\neq \\nabla \\overline{\\Phi}_N(\\mathbf{R}_N)$。这两个梯度向量不相同，因此速度向量 $\\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}_N$ 不保证垂直于真实力矢量 $-\\nabla\\overline{\\Phi}$。它们的点积通常不为零，导致真实能量 $H$ 出现伪漂移。这种数值赝象破坏了模拟的物理保真度。\n\n**2. 解析回旋平均及修正方案**\n\n对于可以表示为傅里叶模式之和的势，回旋平均积分可以解析地进行，从而消除求积误差。让我们考虑单个模式 $\\Phi_j(\\mathbf{x}) = A_j \\cos(\\mathbf{k}_j\\cdot \\mathbf{x})$。其回旋平均为：\n$$\n\\overline{\\Phi}_j(\\mathbf{R}) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} A_j \\cos\\big(\\mathbf{k}_j\\cdot (\\mathbf{R} + \\rho\\,\\mathbf{e}_{\\theta})\\big)\\,d\\theta\n$$\n展开余弦函数的参数：$\\mathbf{k}_j\\cdot \\mathbf{R} + \\rho (\\mathbf{k}_j \\cdot \\mathbf{e}_{\\theta}) = \\mathbf{k}_j\\cdot \\mathbf{R} + \\rho k_j \\cos(\\theta - \\alpha_j)$，其中 $k_j = |\\mathbf{k}_j|$，$\\alpha_j$ 是 $\\mathbf{k}_j$ 的角度。使用余弦和角公式并在 $\\theta \\in [0, 2\\pi]$ 上积分：\n$$\n\\overline{\\Phi}_j(\\mathbf{R}) = \\frac{A_j}{2\\pi}\\int_{0}^{2\\pi} \\Big[ \\cos(\\mathbf{k}_j\\cdot \\mathbf{R}) \\cos(\\rho k_j \\cos(\\theta-\\alpha_j)) - \\sin(\\mathbf{k}_j\\cdot \\mathbf{R}) \\sin(\\rho k_j \\cos(\\theta-\\alpha_j)) \\Big]\\,d\\theta\n$$\n由于对称性，含有 $\\sin(\\rho k_j \\cos(\\theta-\\alpha_j))$ 的项积分为零。第一项的积分涉及第一类零阶贝塞尔函数 $J_0(z)$ 的积分表示，$J_0(z) = \\frac{1}{2\\pi}\\int_0^{2\\pi} \\cos(z\\cos\\theta)\\,d\\theta$。相移 $\\alpha_j$ 不会改变在一个完整周期上的积分值。这得到：\n$$\n\\overline{\\Phi}_j(\\mathbf{R}) = A_j \\cos(\\mathbf{k}_j\\cdot \\mathbf{R}) J_0(\\rho k_j)\n$$\n根据线性性质，对于给定的势 $\\Phi(\\mathbf{x}) = A_1 \\cos(\\mathbf{k}_1\\cdot \\mathbf{x}) + A_2 \\cos(\\mathbf{k}_2\\cdot \\mathbf{x})$，精确的回旋平均势为：\n$$\n\\overline{\\Phi}(\\mathbf{R}) = A_1 J_0(\\rho k_1) \\cos(\\mathbf{k}_1\\cdot \\mathbf{R}) + A_2 J_0(\\rho k_2) \\cos(\\mathbf{k}_2\\cdot \\mathbf{R})\n$$\n运动方程所需的梯度通过对 $\\mathbf{R}$ 微分得到：\n$$\n\\nabla \\overline{\\Phi}(\\mathbf{R}) = -A_1 J_0(\\rho k_1) \\mathbf{k}_1 \\sin(\\mathbf{k}_1\\cdot \\mathbf{R}) - A_2 J_0(\\rho k_2) \\mathbf{k}_2 \\sin(\\mathbf{k}_2\\cdot \\mathbf{R})\n$$\n**修正方案**（方案 B）在于使用这个精确的解析表达式 $\\nabla \\overline{\\Phi}(\\mathbf{R})$ 来计算每个时间步的回旋中心速度。这恢复了精确动力学的哈密顿结构，从而确保真实数值能量在时间积分器误差范围内守恒。\n\n**3. 算法实现**\n\n该模拟通过使用四阶龙格-库塔(RK4)方法数值积分常微分方程 $\\frac{d\\mathbf{R}}{dt} = \\mathbf{v}(\\mathbf{R})$ 来演化回旋中心位置 $\\mathbf{R}(t)$。实现的核心是定义速度矢量 $\\mathbf{v}(\\mathbf{R}) = \\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}(\\mathbf{R})$ 的函数。我们为该函数实现了两种方案。\n\n- **方案 A（离散方法）：** 梯度 $\\nabla \\overline{\\Phi}(\\mathbf{R})$ 通过对回旋环上 $N$ 个离散点的裸势梯度 $\\nabla\\Phi$ 进行平均来近似：\n$$\n\\nabla \\overline{\\Phi}_N(\\mathbf{R}) = \\frac{1}{N}\\sum_{m=0}^{N-1} \\nabla\\Phi(\\mathbf{R} + \\rho\\,\\mathbf{e}_{\\theta_m}), \\quad \\text{其中 } \\theta_m = \\frac{2\\pi m}{N}\n$$\n然后速度为 $\\mathbf{v}_N(\\mathbf{R}) = \\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}_N(\\mathbf{R})$。\n\n- **方案 B（修正方案）：** 速度使用上面推导的精确解析梯度计算：$\\mathbf{v}(\\mathbf{R}) = \\hat{\\mathbf{z}}\\times \\nabla \\overline{\\Phi}(\\mathbf{R})$。\n\n对于这两种方案，初始位置为 $\\mathbf{R}(0)=(0.37, 0.21)$。系统以时间步长 $\\Delta t=0.002$ 演化 $N_t=5000$ 步。获得最终位置 $\\mathbf{R}(T)$ 后，能量漂移计算为 $\\Delta H = |\\overline{\\Phi}(\\mathbf{R}(T)) - \\overline{\\Phi}(\\mathbf{R}(0))|$，其中 $\\overline{\\Phi}$ 是精确的解析回旋平均势。这确保了对每种方法如何保守真实物理能量的一致且公平的比较。我们预期对于方案 A，$\\Delta H$ 会随着 $N$ 的增加而减小，而对于方案 B，$\\Delta H$ 将接近时间积分器的误差（非常小）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Solves the gyrocenter dynamics problem by simulating trajectories\n    and computing energy drift for different gyroaveraging schemes.\n    \"\"\"\n    # Define physical and simulation parameters from the problem statement.\n    RHO = 0.35\n    A1 = 0.8\n    A2 = 0.5\n    K1 = np.array([1.0, 0.8])\n    K2 = np.array([-0.6, 1.3])\n    R0 = np.array([0.37, 0.21])\n    DT = 0.002\n    NT = 5000\n\n    # Pre-calculate magnitudes and Bessel function factors for efficiency.\n    K1_MAG = np.linalg.norm(K1)\n    K2_MAG = np.linalg.norm(K2)\n    J0_K1_FACTOR = j0(RHO * K1_MAG)\n    J0_K2_FACTOR = j0(RHO * K2_MAG)\n\n    def grad_potential(x):\n        \"\"\"Computes the gradient of the bare potential Phi at position x.\"\"\"\n        term1 = -A1 * K1 * np.sin(np.dot(K1, x))\n        term2 = -A2 * K2 * np.sin(np.dot(K2, x))\n        return term1 + term2\n\n    def gyro_avg_potential_exact(R):\n        \"\"\"Computes the exact continuous gyroaveraged potential at R.\"\"\"\n        term1 = A1 * J0_K1_FACTOR * np.cos(np.dot(K1, R))\n        term2 = A2 * J0_K2_FACTOR * np.cos(np.dot(K2, R))\n        return term1 + term2\n\n    def grad_gyro_avg_potential_exact(R):\n        \"\"\"Computes the gradient of the exact continuous gyroaveraged potential at R.\"\"\"\n        term1 = -A1 * J0_K1_FACTOR * K1 * np.sin(np.dot(K1, R))\n        term2 = -A2 * J0_K2_FACTOR * K2 * np.sin(np.dot(K2, R))\n        return term1 + term2\n\n    def get_velocity(grad_phi_bar_vector):\n        \"\"\"Computes E x B velocity from the gradient of the gyroaveraged potential.\"\"\"\n        # dR/dt = z_hat x grad(Phi_bar) = (-d(Phi_bar)/dy, d(Phi_bar)/dx)\n        gx, gy = grad_phi_bar_vector\n        return np.array([-gy, gx])\n\n    def rk4_step(rhs_func, y, dt):\n        \"\"\"Performs a single step of the 4th-order Runge-Kutta method.\"\"\"\n        k1 = rhs_func(y)\n        k2 = rhs_func(y + dt / 2.0 * k1)\n        k3 = rhs_func(y + dt / 2.0 * k2)\n        k4 = rhs_func(y + dt * k3)\n        return y + dt / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def run_simulation(variant, N):\n        \"\"\"\n        Runs a full time-dependent simulation for a given variant and N.\n        \n        Args:\n            variant (str): 'A' for discrete average, 'B' for exact analytical.\n            N (int): Number of points for discrete gyroaverage (Variant A).\n\n        Returns:\n            float: The absolute energy drift |H(T) - H(0)|.\n        \"\"\"\n        R = np.copy(R0)\n\n        if variant == 'A':\n            # Variant A: Discrete quadrature for the gradient of the gyroaveraged potential.\n            thetas = np.linspace(0, 2 * np.pi, N, endpoint=False)\n            e_thetas = np.array([np.cos(thetas), np.sin(thetas)]).T\n            \n            def grad_phi_bar_func(current_R):\n                grad_sum = np.zeros(2)\n                for i in range(N):\n                    particle_pos = current_R + RHO * e_thetas[i]\n                    grad_sum += grad_potential(particle_pos)\n                return grad_sum / N\n        elif variant == 'B':\n            # Variant B: Exact analytical gradient.\n            def grad_phi_bar_func(current_R):\n                return grad_gyro_avg_potential_exact(current_R)\n        else:\n            raise ValueError(\"Invalid variant specified.\")\n\n        def velocity_rhs(current_R):\n            \"\"\"The right-hand side of the ODE, dR/dt.\"\"\"\n            grad_phi_bar = grad_phi_bar_func(current_R)\n            return get_velocity(grad_phi_bar)\n\n        # Time integration loop.\n        for _ in range(NT):\n            R = rk4_step(velocity_rhs, R, DT)\n\n        # Calculate energy drift using the exact Hamiltonian.\n        H0 = gyro_avg_potential_exact(R0)\n        Hf = gyro_avg_potential_exact(R)\n        delta_H = np.abs(Hf - H0)\n        \n        return delta_H\n\n    # Define and run the test suite from the problem statement.\n    test_cases = [\n        {'variant': 'A', 'N': 1},  # Case 1\n        {'variant': 'A', 'N': 4},  # Case 2\n        {'variant': 'A', 'N': 16}, # Case 3\n        {'variant': 'B', 'N': 4},  # Case 4 (N is a dummy parameter here)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case['variant'], case['N'])\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "回旋动理学理论描述的是等离子体的集体行为，这不仅需要对回旋相位进行平均，还需要对速度分布进行平均。本练习聚焦于计算关键的回旋平均因子 $\\Gamma_0(b)$，它代表了对回旋算符平方的麦克斯韦平均。您将比较使用高斯-拉盖尔求积法进行直接数值积分与使用高效的解析公式这两种方法的计算成本和准确性，从而揭示在设计大规模等离子体模拟时所面临的一个核心权衡 。",
            "id": "4191145",
            "problem": "您的任务是构建一个程序，对于一组指定的参数，量化在线性回旋动理学响应中获得回旋平均因子（由函数 $\\Gamma_0(b)$ 表示）的两种方法之间的计算权衡。其背景是聚变等离子体中从粒子坐标到回旋中心坐标的变换，以及相关的对快速回旋运动的回旋平均。您的程序必须实现 (i) 对磁矩的直接速度空间积分和 (ii) $\\Gamma_0(b)$ 的解析麦克斯韦平均公式，并利用这两种方法来确定通过数值积分达到预设精度所需的最小求积阶数。\n\n该目标是纯粹以数学术语来表述的。回旋平均因子 $\\Gamma_0(b)$ 是在对涨落场进行回旋相平均后，将零阶贝塞尔函数的平方对垂直动能上的麦克斯韦分布进行平均而得到的。从以下基本定义开始：\n\n- 磁矩定义为 $\\mu = \\frac{m v_\\perp^2}{2 B}$，其中 $m$ 是粒子质量，$v_\\perp$ 是垂直速度大小，$B$ 是磁场强度。\n- 回旋频率为 $\\Omega = \\frac{q B}{m}$，其中 $q$ 是粒子电荷。\n- 拉莫尔半径为 $\\rho = \\frac{v_\\perp}{\\Omega}$，因此 $\\rho^2 = \\frac{v_\\perp^2}{\\Omega^2}$。\n- 无量纲垂直能量变量为 $x = \\frac{m v_\\perp^2}{2 T}$，其中 $T$ 是温度，所以 $v_\\perp^2 = \\frac{2 T x}{m}$，且垂直麦克斯韦权重正比于 $e^{-x}$。\n- 定义热拉莫尔半径的平方为 $\\rho_{\\mathrm{th}}^2 = \\frac{T m}{q^2 B^2}$，以及无量纲参数 $b = k_\\perp^2 \\rho_{\\mathrm{th}}^2$，其中 $k_\\perp$ 是垂直波数的大小。\n\n利用这些定义，将贝塞尔函数的自变量表示为 $k_\\perp \\rho = \\sqrt{2 b x}$，回旋平均核的平方的麦克斯韦平均就简化为以下形式的积分\n$$\n\\Gamma_0(b) = \\int_0^\\infty e^{-x} \\left[J_0\\!\\left(\\sqrt{2 b x}\\right)\\right]^2 \\,\\mathrm{d}x,\n$$\n其中 $J_0$ 是第一类零阶贝塞尔函数。这个积分形式是您进行数值计算的目标。\n\n另外，存在一个 $\\Gamma_0(b)$ 的解析麦克斯韦平均公式，该公式由经过充分检验的贝塞尔积分恒等式和生成函数得到，其中涉及第一类修正贝塞尔函数 $I_0$。\n\n您的程序必须实现以下功能：\n\n1. 使用适应半无限区间 $[0,\\infty)$ 上权重 $e^{-x}$ 的高斯求积法，特别是高斯-拉盖尔求积法，对 $\\Gamma_0(b)$ 进行数值计算。对于一个整数求积阶数 $N$，其节点为 $\\{x_i\\}_{i=1}^N$，权重为 $\\{w_i\\}_{i=1}^N$（对应于权重 $e^{-x}$），近似计算为\n   $$\n   \\Gamma_0^{\\mathrm{num}}(b;N) \\approx \\sum_{i=1}^N w_i \\left[J_0\\!\\left(\\sqrt{2 b x_i}\\right)\\right]^2.\n   $$\n   您的程序必须从一个预定义的候选集中自适应地选择最小的 $N$，通过将 $\\Gamma_0^{\\mathrm{num}}(b;N)$ 与解析麦克斯韦平均值进行比较，以满足指定的容差。\n\n2. 使用闭式麦克斯韦平均进行解析计算 $\\Gamma_0^{\\mathrm{ana}}(b)$。\n\n3. 对比两种方法，量化其计算权衡，即数值方法达到相对于解析值的给定绝对误差容差所需的最小求积节点数 $N$。将 $N$ 解释为一个成本代理，它计算数值方法中特殊函数 $J_0$ 的求值次数，而解析方法仅需要对修正贝塞尔函数 $I_0$ 进行一次求值。\n\n程序要求：\n\n- 实现这两种方法，并为每个测试用例，从候选集 $\\{1,2,4,8,16,32,64,128,256\\}$ 中确定最小的求积阶数 $N$，使得\n  $$\n  \\left|\\Gamma_0^{\\mathrm{num}}(b;N) - \\Gamma_0^{\\mathrm{ana}}(b)\\right| \\leq \\varepsilon,\n  $$\n  其中绝对误差容差为 $\\varepsilon = 10^{-11}$。\n- 如果对于给定的 $b$，候选集中的所有 $N$ 均不满足容差，则使用该集合中最大的 $N$。\n- 仅使用无量纲量；不需要物理单位。\n- 数值角度变量仅在 $J_0$ 中隐式出现，不需要显式的角度单位。\n\n测试套件：\n\n为以下用于探测不同区间的无量纲 $b$ 测试值评估上述过程：\n- $b = 0$ (边界情况),\n- $b = 10^{-6}$ (小 $b$),\n- $b = 10^{-1}$ (中等 $b$),\n- $b = 1$ (量级为1),\n- $b = 10$ (大 $b$),\n- $b = 50$ (非常大的 $b$).\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含每个测试用例所需的最小求积阶数，顺序与上面列出的相同，形式为方括号内以逗号分隔的整数列表。例如，输出应如下所示：\n$$\n[\\text{N}_0,\\text{N}_1,\\text{N}_2,\\text{N}_3,\\text{N}_4,\\text{N}_5],\n$$\n其中 $\\text{N}_i$ 是第 $i$ 个 $b$ 测试值所需的最小求积阶数。",
            "solution": "问题的核心是比较评估回旋平均因子 $\\Gamma_0(b)$ 的两种方法，这是线性回旋动理学理论中的一个基本量。该因子解释了对磁场中带电粒子的快速回旋运动上的涨落场进行的平均。参数 $b = k_\\perp^2 \\rho_{\\mathrm{th}}^2$ 是一个无量纲量，衡量的是以热拉莫尔半径 $\\rho_{\\mathrm{th}}$ 归一化的垂直波数 $k_\\perp$ 的平方。问题要求找出数值方法与解析解在指定精度下匹配所需的最小计算成本（以求积阶数 $N$ 为代表）。\n\n起点是 $\\Gamma_0(b)$ 的形式化定义，即零阶贝塞尔函数 $J_0$ 的平方在一个无量纲垂直能量变量 $x$ 上的麦克斯韦加权平均，表示为一个积分：\n$$\n\\Gamma_0(b) = \\int_0^\\infty e^{-x} \\left[J_0\\!\\left(\\sqrt{2 b x}\\right)\\right]^2 \\,\\mathrm{d}x\n$$\n该积分源于将涉及 $J_0(k_\\perp \\rho)$ 的回旋相平均势在麦克斯韦速度分布上进行平均。\n\n程序为 $\\Gamma_0(b)$ 实现了两种不同的评估策略：\n\n1.  **解析评估**：$\\Gamma_0(b)$ 的积分有一个已知的闭式解，可作为我们的高精度基准。这是贝塞尔函数积分理论中的一个标准结果，由下式给出：\n    $$\n    \\Gamma_0^{\\mathrm{ana}}(b) = e^{-b} I_0(b)\n    $$\n    此处，$I_0$ 是第一类零阶修正贝塞尔函数。该公式提供了一个计算效率高且非常精确的值，可用于与数值方法进行比较。对于 $b=0$ 的特殊情况（对应无限长波长），我们有 $\\Gamma_0^{\\mathrm{ana}}(0) = e^0 I_0(0) = 1 \\times 1 = 1$，这与预期相符，因为粒子没有经历任何波的空间变化。该实现使用 `scipy.special.i0` 函数计算 $I_0(b)$，使用 `numpy.exp` 计算 $e^{-b}$。\n\n2.  **数值积分**：问题指定使用高斯-拉盖尔求积法来评估该积分。对于 $\\int_0^\\infty e^{-x} f(x) \\,\\mathrm{d}x$ 形式的积分，此方法是自然且最高效的选择。一个 $N$ 阶高斯-拉盖尔求积将该积分近似为一个加权和：\n    $$\n    \\Gamma_0^{\\mathrm{num}}(b;N) = \\sum_{i=1}^N w_i \\left[J_0\\!\\left(\\sqrt{2 b x_i}\\right)\\right]^2\n    $$\n    此处，$\\{x_i\\}_{i=1}^N$ 是拉盖尔多项式 $L_N(x)$ 的根，而 $\\{w_i\\}_{i=1}^N$ 是相应的求积权重。对于光滑的被积函数（本例即是如此），该方法以指数速度收敛。此方法的计算成本与 $N$ 成正比，因为它需要对 $J_0$ 函数进行 $N$ 次求值。在我们的实现中，节点 $x_i$ 和权重 $w_i$ 是使用 `scipy.special.roots_laguerre(N)` 计算的，而贝塞尔函数 $J_0$ 是使用 `scipy.special.j0` 进行评估的。\n\n该程序的主要目标是确定精度与计算成本之间的权衡。对于测试套件 $\\{0, 10^{-6}, 10^{-1}, 1, 10, 50\\}$ 中给定的每个 $b$ 值，算法按以下步骤进行：\n首先，计算参考值 $\\Gamma_0^{\\mathrm{ana}}(b)$。然后，程序按升序遍历求积阶数候选集 $N \\in \\{1,2,4,8,16,32,64,128,256\\}$。对于每个 $N$，它计算 $\\Gamma_0^{\\mathrm{num}}(b;N)$ 并计算绝对误差 $\\left|\\Gamma_0^{\\mathrm{num}}(b;N) - \\Gamma_0^{\\mathrm{ana}}(b)\\right|$。使得此误差小于或等于指定容差 $\\varepsilon = 10^{-11}$ 的第一个 $N$ 值被确定为最小所需阶数。这个 $N$ 代表了在该特定 $b$ 值下达到所需精度所需的贝塞尔函数求值的最小次数。如果集合中没有任何 $N$ 满足容差，则按照问题说明选择最大阶数 $256$。对所有 $b$ 值重复此过程，并将得到的最小阶数列表 $[N_0, N_1, ...]$ 格式化为最终输出。所需 $N$ 随 $b$ 的变化行为是符合物理预期的：随着 $b$ 增加，贝塞尔函数的自变量 $\\sqrt{2bx}$ 增大，使得被积函数振荡性更强，因此需要更高的求积阶数 $N$ 才能精确解析。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import i0, j0, roots_laguerre\n\ndef solve():\n    \"\"\"\n    Calculates the minimum Gauss-Laguerre quadrature order N to evaluate\n    the gyroaveraging factor Gamma_0(b) to a specified precision for a set\n    of b values.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases_b = [0.0, 1e-6, 0.1, 1.0, 10.0, 50.0]\n    \n    # Define the set of candidate quadrature orders.\n    N_candidates = [1, 2, 4, 8, 16, 32, 64, 128, 256]\n    \n    # Define the absolute error tolerance.\n    epsilon = 1.0e-11\n    \n    # Store the results.\n    min_N_results = []\n    \n    # --- Helper functions for Gamma_0(b) ---\n\n    def gamma_0_analytic(b):\n        \"\"\"\n        Computes Gamma_0(b) using the analytic formula: e^(-b) * I_0(b).\n        \n        Args:\n            b (float): The dimensionless parameter k_perp^2 * rho_th^2.\n            \n        Returns:\n            float: The value of Gamma_0(b).\n        \"\"\"\n        # Ensure b is a float for numpy functions.\n        b_float = float(b)\n        # The modified Bessel function I_0(b) is computed via scipy.special.i0\n        return np.exp(-b_float) * i0(b_float)\n\n    def gamma_0_numerical(b, N):\n        \"\"\"\n        Computes Gamma_0(b) using N-point Gauss-Laguerre quadrature.\n        \n        Args:\n            b (float): The dimensionless parameter.\n            N (int): The quadrature order.\n            \n        Returns:\n            float: The numerical approximation of Gamma_0(b).\n        \"\"\"\n        # Handle the trivial case b=0.\n        # J0(0) = 1, and the sum of Gauss-Laguerre weights is 1.\n        if b == 0.0:\n            return 1.0\n            \n        # Get the N-point Gauss-Laguerre nodes (x_i) and weights (w_i).\n        # We use alpha=0 for the standard Laguerre weight function exp(-x).\n        x_nodes, w_nodes = roots_laguerre(N)\n        \n        # Evaluate the integrand J0(sqrt(2*b*x_i))^2 at the nodes.\n        # The argument of J0 is sqrt(2*b*x).\n        b_float = float(b)\n        arg = np.sqrt(2.0 * b_float * x_nodes)\n        integrand_values = j0(arg)**2\n        \n        # Compute the sum of w_i * f(x_i) to approximate the integral.\n        return np.sum(w_nodes * integrand_values)\n\n    # --- Main Loop to find minimum N for each b ---\n\n    for b_val in test_cases_b:\n        # Calculate the high-precision reference value using the analytic formula.\n        analytic_val = gamma_0_analytic(b_val)\n        \n        # Initialize the result for this b_val to the largest N,\n        # as per the problem's requirement if tolerance is not met.\n        min_N_found = N_candidates[-1]\n        \n        # Iterate through candidate orders N to find the minimum required.\n        for N in N_candidates:\n            # Compute the numerical approximation.\n            numeric_val = gamma_0_numerical(b_val, N)\n            \n            # Calculate the absolute error.\n            error = np.abs(numeric_val - analytic_val)\n            \n            # Check if the error meets the tolerance.\n            if error = epsilon:\n                # If it does, this is the minimal N so far. Store it and break.\n                min_N_found = N\n                break\n                \n        min_N_results.append(min_N_found)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, min_N_results))}]\")\n\nsolve()\n```"
        }
    ]
}