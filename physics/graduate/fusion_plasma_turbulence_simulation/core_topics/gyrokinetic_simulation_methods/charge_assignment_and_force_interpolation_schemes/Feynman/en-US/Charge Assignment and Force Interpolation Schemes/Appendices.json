{
    "hands_on_practices": [
        {
            "introduction": "A fundamental check for any Particle-In-Cell (PIC) simulation is that it conserves charge globally; the numerical representation must not artificially create or destroy charge. This exercise connects this crucial physical principle to a mathematical property of the particle shape functions known as the \"partition of unity.\" You will first prove analytically that this property guarantees the total charge deposited on the grid exactly equals the total particle charge, and then verify it numerically, even exploring what goes wrong when the property is deliberately broken .",
            "id": "4183292",
            "problem": "Consider a uniform, periodic, Cartesian grid used in a Particle-In-Cell (PIC) method for fusion plasma turbulence simulation. Let the spatial domain be two-dimensional with lengths $L_x$ and $L_y$, discretized into $N_x$ and $N_y$ equally spaced nodes, respectively. The grid spacings are $h_x = L_x / N_x$ and $h_y = L_y / N_y$. A collection of $N_p$ point particles with charges $\\{q_i\\}_{i=1}^{N_p}$ and positions $\\{\\mathbf{x}_i\\}_{i=1}^{N_p}$, where $\\mathbf{x}_i = (x_i,y_i)$, is to be deposited onto the grid as a charge density field $\\rho_{j,k}$ at node indices $(j,k)$.\n\nThe PIC charge assignment uses a dimensionwise separable shape function $W(\\xi)$ with compact support and the exact partition-of-unity property, defined by the requirement that for any real $\\xi$, the infinite sum over integers satisfies $\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$. The two-dimensional shape is the product $S(\\mathbf{x}) = W(x/h_x) W(y/h_y)$ evaluated on dimensionless coordinates. The charge deposition rule is\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right),\n$$\nwith periodic boundary conditions so that all node indices are interpreted modulo $N_x$ and $N_y$. The physical units for charge are Coulombs (C), and the charge density has units of Coulombs per square meter (C/m$^2$).\n\nTask A (proof): Starting from the conservation of charge in its integral form and the above discrete deposition definition, derive from first principles that the total charge deposited on the grid,\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y,\n$$\nis exactly equal to the total particle charge $Q_{\\text{part}} = \\sum_{i=1}^{N_p} q_i$ at every time step, provided $W(\\xi)$ satisfies the exact partition-of-unity and the periodic wrap is implemented correctly. Explain why this prevents net-charge drift in the discrete system.\n\nTask B (numerical verification): Implement the one-dimensional shapes used in practice that satisfy the exact partition-of-unity and have compact support:\n- Nearest-Grid-Point (NGP), also known as the order-$0$ B-spline.\n- Cloud-In-Cell (CIC), also known as the order-$1$ B-spline.\n- Triangular-Shaped Cloud (TSC), also known as the order-$2$ B-spline with three-point support.\n\nUse these to build the two-dimensional separable shape $S(\\mathbf{x})$ and verify numerically that $Q_{\\text{grid}} - Q_{\\text{part}}$ is zero to machine precision for random particle sets. Also construct a deliberately broken variant of the CIC shape by multiplying all one-dimensional weights by a constant factor $\\alpha \\neq 1$ (creating a violation of the partition-of-unity) and empirically demonstrate the resulting net-charge drift.\n\nAll calculations must be in the International System of Units (SI). Report the numerical discrepancies in Coulombs (C). Angles are not used. Your program must produce a single line of output containing the results of all test cases as a comma-separated list enclosed in square brackets. Each element must be a floating-point number representing the absolute value of $Q_{\\text{grid}} - Q_{\\text{part}}$ in Coulombs (C).\n\nUse the following test suite to ensure coverage and reproducibility. For each test, particle positions are sampled uniformly in the domain unless otherwise specified, and random numbers use the given seed:\n\n- Test $1$ (happy path, CIC): $L_x = 1.0$ (m), $L_y = 0.5$ (m), $N_x = 64$, $N_y = 32$, $N_p = 1000$, random seed $42$, particle charges sampled from a normal distribution with zero mean and standard deviation $1.0 \\times 10^{-19}$ (C).\n- Test $2$ (boundary condition stress, NGP): $L_x = 1.0$ (m), $L_y = 1.0$ (m), $N_x = 4$, $N_y = 4$, $N_p = 10$, fixed positions clustered near the upper-right boundary at $(x_i,y_i) \\approx (L_x - \\varepsilon, L_y - \\varepsilon)$ with $\\varepsilon = 10^{-12}$ (m), random seed $7$ for charges from a normal distribution with zero mean and standard deviation $5.0 \\times 10^{-20}$ (C).\n- Test $3$ (higher-order shape, TSC): $L_x = 0.64$ (m), $L_y = 0.64$ (m), $N_x = 32$, $N_y = 32$, $N_p = 5000$, random seed $123$, particle charges sampled from a normal distribution with zero mean and standard deviation $2.0 \\times 10^{-19}$ (C).\n- Test $4$ (edge case, zero particles, CIC): $L_x = 1.0$ (m), $L_y = 1.0$ (m), $N_x = 16$, $N_y = 16$, $N_p = 0$, no randomization.\n- Test $5$ (broken partition, scaled CIC): $L_x = 1.0$ (m), $L_y = 1.0$ (m), $N_x = 32$, $N_y = 32$, $N_p = 1000$, random seed $99$ for positions, all particle charges set to $1.0 \\times 10^{-19}$ (C), and the CIC weights in each dimension multiplied by $\\alpha = 1.01$ before forming the separable two-dimensional weights.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]\"), where $r_m$ is the absolute discrepancy $|Q_{\\text{grid}} - Q_{\\text{part}}|$ in Coulombs (C) for Test $m$.",
            "solution": "The problem asks for an analytical proof of charge conservation in a Particle-In-Cell (PIC) charge deposition scheme and a numerical verification of this property.\n\n### Task A: Proof of Charge Conservation\n\nThe objective is to prove that the total charge deposited on the grid, $Q_{\\text{grid}}$, is identical to the total charge of the particles, $Q_{\\text{part}}$, under the given scheme.\n\nThe total particle charge is defined as the sum of all individual particle charges:\n$$\nQ_{\\text{part}} = \\sum_{i=1}^{N_p} q_i\n$$\n\nThe total charge on the grid is defined as the sum of the charge density at each grid node multiplied by the area element $h_x h_y$ corresponding to that node:\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y\n$$\n\nThe charge density $\\rho_{j,k}$ at grid node $(j,k)$ is given by the deposition rule:\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\nwhere $W(\\xi)$ is the one-dimensional shape function.\n\nWe begin the proof by substituting the definition of $\\rho_{j,k}$ into the expression for $Q_{\\text{grid}}$:\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\left[ \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right] h_x h_y\n$$\n\nThe area element $h_x h_y$ cancels out:\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\n\nSince all sums are finite, we can interchange the order of summation without altering the result. We move the summation over particles to the outside:\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right]\n$$\n\nThe two-dimensional shape function is separable, which allows us to factor the double summation over grid indices $(j,k)$ into a product of two independent one-dimensional summations:\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\left( \\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\right) \\left( \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right) \\right]\n$$\n\nNow, we must evaluate the sums in the parentheses. Let us focus on the sum over $j$. Let $\\xi_i = x_i/h_x$ be the normalized position of particle $i$. The sum is $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$. The problem states that the domain is periodic and that the shape function $W(\\xi)$ has compact support and satisfies the partition-of-unity property, $\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$ for any real $\\xi$.\n\nDue to the compact support of $W$, for any given $\\xi_i$, the term $W(\\xi_i - j)$ is non-zero only for a small, finite number of integer indices $j$ near $\\xi_i$. The periodicity of the grid implies that any contribution from a particle that would mathematically fall on a grid node index outside the range $[0, N_x-1]$ is wrapped back into this range. For instance, a contribution to node $j = N_x$ is mapped to node $0$, and a contribution to $j = -1$ is mapped to $N_x-1$. This \"aliasing\" effect means that the finite sum over the periodic grid, $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$, is exactly equivalent to the infinite sum over all integers, $\\sum_{n \\in \\mathbb{Z}} W(\\xi_i - n)$.\n\nTherefore, by the partition-of-unity property:\n$$\n\\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{x_i}{h_x} - n\\right) = 1\n$$\nBy the same reasoning for the $y$-dimension:\n$$\n\\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{y_i}{h_y} - n\\right) = 1\n$$\n\nSubstituting these results back into our expression for $Q_{\\text{grid}}$:\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ (1) \\cdot (1) \\right] = \\sum_{i=1}^{N_p} q_i\n$$\n\nThis final expression is precisely the definition of the total particle charge, $Q_{\\text{part}}$. Thus, we have proven that $Q_{\\text{grid}} = Q_{\\text{part}}$.\n\nThis property, known as global charge conservation, is a fundamental requirement for a stable PIC simulation. If total charge were not conserved by the discrete algorithm ($Q_{\\text{grid}} \\neq Q_{\\text{part}}$), it would imply that the numerical scheme itself is a source or sink of charge. According to Gauss's law for electricity, $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$, a net charge density acts as a source for the electric field. The artificial creation or destruction of charge would generate spurious, non-physical electric fields, which in turn would exert incorrect forces on the particles, leading to a rapid accumulation of error and numerical instability. This phenomenon is termed net-charge drift. The use of a shape function satisfying the partition-of-unity property guarantees that this drift does not occur at the level of charge deposition.\n\n### Task B: Numerical Verification and Algorithmic Design\n\nTo verify this principle numerically, we implement the charge deposition for various shape functions, which are based on B-splines. The one-dimensional shape function $W(\\xi)$ relates a particle's continuous position to weights on discrete grid nodes. The argument $\\xi$ is the normalized distance from the particle to a grid node. The 2D shape function is the product of two 1D functions: $S(x/h_x-j, y/h_y-k) = W(x/h_x-j) W(y/h_y-k)$.\n\nThe shapes used are:\n1.  **Nearest-Grid-Point (NGP, order-0 B-spline):** $W_0(\\xi) = 1$ for $|\\xi| \\le 0.5$ and $0$ otherwise. This is a rectangular or \"top-hat\" function. It has a support width of $1$ grid cell. A particle's entire charge is deposited onto the single nearest grid node.\n2.  **Cloud-In-Cell (CIC, order-1 B-spline):** $W_1(\\xi) = 1 - |\\xi|$ for $|\\xi| \\le 1$ and $0$ otherwise. This is a triangular function with a support width of $2$ grid cells. a 2D particle deposits its charge onto the $4$ grid nodes forming the cell that contains it.\n3.  **Triangular-Shaped Cloud (TSC, order-2 B-spline):** $W_2(\\xi)$ is a quadratic spline with a support of $3$ grid cells.\n    $$\n    W_2(\\xi) = \\begin{cases} \\frac{3}{4} - \\xi^2 & \\text{if } |\\xi| \\le \\frac{1}{2} \\\\ \\frac{1}{2} (\\frac{3}{2} - |\\xi|)^2 & \\text{if } \\frac{1}{2} < |\\xi| \\le \\frac{3}{2} \\\\ 0 & \\text{otherwise} \\end{cases}\n    $$\n    A 2D particle following this scheme deposits its charge onto a $3 \\times 3$ block of $9$ grid nodes.\n\nThe numerical algorithm proceeds as follows:\n1.  Initialize a 2D array `rho_grid` of size $(N_x, N_y)$ to all zeros.\n2.  For each particle $i$ with charge $q_i$ and position $(x_i, y_i)$:\n    a. Calculate its normalized position $(\\tilde{x}_i, \\tilde{y}_i) = (x_i/h_x, y_i/h_y)$.\n    b. Based on the chosen shape function (NGP, CIC, or TSC), identify the set of affected grid node indices in each dimension, $(j_1, j_2, ...)$ and $(k_1, k_2, ...)$. These indices must be wrapped periodically using the modulo operator (e.g., $j \\pmod{N_x}$).\n    c. For each affected index $j_m$, calculate the corresponding 1D weight $w_{x,m} = W(\\tilde{x}_i - j_m)$. Similarly, calculate weights $w_{y,n}$ for each affected index $k_n$.\n    d. For each pair of affected indices $(j_m, k_n)$, update the charge density on the grid:\n       $$\n       \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} \\gets \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} + \\frac{q_i}{h_x h_y} \\cdot w_{x,m} \\cdot w_{y,n}\n       $$\n3.  After iterating through all particles, calculate the total grid charge $Q_{\\text{grid}} = h_x h_y \\sum_{j,k} \\rho_{j,k}$.\n4.  Compute the discrepancy $|Q_{\\text{grid}} - Q_{\\text{part}}|$.\n\nFor Test 5, a \"broken\" scheme is used where the 1D weights derived from the CIC shape function are multiplied by a factor $\\alpha = 1.01$. This explicitly violates the partition-of-unity, as the sum of weights for a single particle will be $\\alpha^2$ instead of $1$. The implementation will demonstrate the resulting non-zero charge discrepancy, confirming the theoretical link between partition-of-unity and charge conservation. The numerical implementation performs these steps for the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PIC charge deposition problem, including analytical proof and numerical verification.\n    \"\"\"\n    test_cases = [\n        # Test 1 (happy path, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 0.5, 'Nx': 64, 'Ny': 32, 'Np': 1000,\n         'seed': 42, 'charge_dist': ('normal', 0, 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 2 (boundary condition stress, NGP)\n        {'shape': 'NGP', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 4, 'Ny': 4, 'Np': 10,\n         'seed': 7, 'charge_dist': ('normal', 0, 5.0e-20),\n         'pos_dist': ('clustered', 1e-12), 'alpha': 1.0},\n        # Test 3 (higher-order shape, TSC)\n        {'shape': 'TSC', 'Lx': 0.64, 'Ly': 0.64, 'Nx': 32, 'Ny': 32, 'Np': 5000,\n         'seed': 123, 'charge_dist': ('normal', 0, 2.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 4 (edge case, zero particles, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16, 'Np': 0,\n         'seed': None, 'charge_dist': None, 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 5 (broken partition, scaled CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 32, 'Ny': 32, 'Np': 1000,\n         'seed': 99, 'charge_dist': ('fixed', 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.01}\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Unpack parameters\n        shape = params['shape']\n        Lx, Ly = params['Lx'], params['Ly']\n        Nx, Ny = params['Nx'], params['Ny']\n        Np = params['Np']\n        seed = params['seed']\n        charge_dist = params['charge_dist']\n        pos_dist = params['pos_dist']\n        alpha = params['alpha']\n\n        hx, hy = Lx / Nx, Ly / Ny\n        \n        # Handle zero particle case\n        if Np == 0:\n            results.append(0.0)\n            continue\n\n        rng = np.random.default_rng(seed)\n\n        # Generate particle charges\n        if charge_dist[0] == 'normal':\n            mean, std_dev = charge_dist[1], charge_dist[2]\n            charges = rng.normal(mean, std_dev, Np)\n        elif charge_dist[0] == 'fixed':\n            charges = np.full(Np, charge_dist[1], dtype=np.float64)\n        \n        q_total_particles = np.sum(charges)\n\n        # Generate particle positions\n        if pos_dist == 'uniform':\n            positions = rng.uniform(low=[0.0, 0.0], high=[Lx, Ly], size=(Np, 2))\n        elif pos_dist[0] == 'clustered':\n            epsilon = pos_dist[1]\n            # In Test 2, use the same seed for reproducibility of positions\n            pos_rng = np.random.default_rng(seed) if shape == 'NGP' else rng\n            positions = pos_rng.uniform(low=[Lx - 2 * epsilon, Ly - 2 * epsilon],\n                                        high=[Lx - epsilon, Ly - epsilon],\n                                        size=(Np, 2))\n\n        # Initialize charge density grid\n        rho_grid = np.zeros((Nx, Ny), dtype=np.float64)\n\n        # Deposit charges\n        for i in range(Np):\n            q_i = charges[i]\n            x_i, y_i = positions[i]\n            \n            x_norm = x_i / hx\n            y_norm = y_i / hy\n            \n            # 1D weights and indices calculation\n            if shape == 'NGP':\n                # x-dimension\n                jx = int(np.floor(x_norm + 0.5))\n                wx = [1.0]\n                jx_indices = [jx]\n                \n                # y-dimension\n                ky = int(np.floor(y_norm + 0.5))\n                wy = [1.0]\n                ky_indices = [ky]\n\n            elif shape == 'CIC':\n                # x-dimension\n                jx0 = int(np.floor(x_norm))\n                dx = x_norm - jx0\n                wx = [alpha * (1.0 - dx), alpha * dx]\n                jx_indices = [jx0, jx0 + 1]\n\n                # y-dimension\n                ky0 = int(np.floor(y_norm))\n                dy = y_norm - ky0\n                wy = [alpha * (1.0 - dy), alpha * dy]\n                ky_indices = [ky0, ky0 + 1]\n                \n            elif shape == 'TSC':\n                # x-dimension\n                jxc = int(np.floor(x_norm + 0.5))\n                dx = x_norm - jxc\n                wx = [0.5 * (0.5 - dx)**2, 0.75 - dx**2, 0.5 * (0.5 + dx)**2]\n                jx_indices = [jxc - 1, jxc, jxc + 1]\n\n                # y-dimension\n                kyc = int(np.floor(y_norm + 0.5))\n                dy = y_norm - kyc\n                wy = [0.5 * (0.5 - dy)**2, 0.75 - dy**2, 0.5 * (0.5 + dy)**2]\n                ky_indices = [kyc - 1, kyc, kyc + 1]\n\n            # 2D deposition with periodic boundary conditions\n            for idx_x, j in enumerate(jx_indices):\n                for idx_y, k in enumerate(ky_indices):\n                    # Using scatter-add logic here\n                    # Indices must be wrapped\n                    j_wrapped = j % Nx\n                    k_wrapped = k % Ny\n                    weight_2d = wx[idx_x] * wy[idx_y]\n                    rho_grid[j_wrapped, k_wrapped] += q_i * weight_2d\n\n        # Correct units for rho_grid\n        rho_grid /= (hx * hy)\n        \n        # Calculate total grid charge\n        q_total_grid = np.sum(rho_grid) * hx * hy\n        \n        discrepancy = np.abs(q_total_grid - q_total_particles)\n        results.append(discrepancy)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While charge is conserved globally, momentum conservation is more subtle, as the grid-mediated interaction between particles does not perfectly obey Newton's third law. This can lead to a spurious net force on the system, causing unphysical heating or momentum drift. This practice demonstrates how the smoothness of the shape function, controlled by its order $m$, directly impacts momentum conservation, with higher-order shapes systematically reducing this error and improving the physical fidelity of the simulation .",
            "id": "4183324",
            "problem": "In a one-dimensional, electrostatic, periodic domain, two particles interact via a mesh-based field solver as in a Particle-In-Cell (PIC) method. The goal is to quantify the spurious total momentum error induced by the charge assignment and force interpolation between particles and the grid when using different particle shape orders, and to demonstrate the reduction of this momentum error with increasing shape order. Work in dimensionless units: domain length $L=1$, vacuum permittivity $\\epsilon_0=1$, and particle charges $q_1=+1$, $q_2=-1$. No physical unit conversion is required.\n\nFundamental base and definitions:\n- The electrostatic field satisfies the Poisson equation in one spatial dimension, $\\partial_x E(x) = \\rho(x)/\\varepsilon_0$ and $E(x) = -\\partial_x \\phi(x)$, with periodic boundary conditions on $[0,L)$.\n- The discrete mesh consists of $N_g$ uniformly spaced grid nodes at positions $x_j = j \\Delta x$ for integers $j \\in \\{0,1,\\dots,N_g-1\\}$, with $\\Delta x = L/N_g$.\n- The mesh-based field solver constructs a grid charge density $\\rho_j$ by assigning the particle charges to nearby nodes using a particle shape function of order $m \\in \\{0,1,2,3\\}$, and solves the Poisson equation in Fourier space to obtain the grid electric field $E_j$. The field at a particle position is then obtained by interpolating $E_j$ back to the particle using the same order-$m$ shape function.\n\nRequirements for the computational method:\n- Use a standard uniform discrete Fourier transform to solve the Poisson equation spectrally with periodic boundary conditions. In Fourier space, enforce zero mean potential by setting the zero wavenumber mode to zero. Compute the electric field by spectral differentiation.\n- Use the same particle shape order $m$ for both charge assignment (particle-to-grid) and force interpolation (grid-to-particle). The considered orders are $m=0$ (nearest-grid-point), $m=1$ (cloud-in-cell), $m=2$ (triangular-shaped-cloud), and $m=3$ (piecewise-cubic-spline). Each is a compactly supported, normalized one-dimensional shape with support over $m+1$ grid cells.\n- Implement periodic boundary conditions for both deposition and interpolation.\n\nDefinition of the diagnostic:\n- Let $F_i = q_i E(x_i)$ be the force on particle $i \\in \\{1,2\\}$ from the interpolated electric field at its position $x_i$. In the continuous, exact two-body electrostatic interaction in a periodic domain with zero net charge, Newton’s third law implies that the total internal force $\\sum_i F_i$ is exactly zero for all times, and thus the total momentum is conserved.\n- Define the dimensionless spurious momentum error for a single configuration as\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta},\n$$\nwhere $\\delta$ is a small positive regularization constant to avoid division by zero in pathological cases, for example $\\delta = 10^{-16}$.\n\nTask:\n- For each specified test case, compute the dimensionless spurious momentum error $\\varepsilon_m$ using the above method.\n- All computations must be carried out in dimensionless units as specified.\n\nTest suite:\nCompute $\\varepsilon_m$ for the following six test cases. Each test case is a tuple $(N_g, m, x_1, x_2)$ with $L=1$, $q_1=+1$, $q_2=-1$, and positions in the periodic interval $[0,1)$.\n1. $(N_g=32, m=0, x_1=0.23, x_2=0.77)$\n2. $(N_g=32, m=1, x_1=0.23, x_2=0.77)$\n3. $(N_g=32, m=2, x_1=0.23, x_2=0.77)$\n4. $(N_g=32, m=3, x_1=0.23, x_2=0.77)$\n5. $(N_g=32, m=3, x_1=0.98, x_2=0.12)$\n6. $(N_g=64, m=3, x_1=0.401, x_2=0.409)$\n\nExpected behavior to be revealed by the results:\n- For fixed mesh resolution $N_g=32$ and fixed particle positions $(x_1,x_2)=(0.23,0.77)$, the sequence of errors for $m=0,1,2,3$ should show a decreasing trend, indicating improved discrete momentum conservation with higher-order shapes.\n- The configuration with particles near the periodic boundary $(x_1=0.98, x_2=0.12)$ should also yield a small error for higher-order shapes if periodic wrapping in deposition and interpolation is implemented correctly.\n- The close-pair configuration at $N_g=64$ and $m=3$ should test the robustness when $|x_2-x_1|$ is small.\n\nFinal output format:\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, for example\n$[r_1,r_2,r_3,r_4,r_5,r_6]$,\nwhere each $r_k$ is the floating-point value of $\\varepsilon_m$ for the $k$-th test case, in dimensionless units.",
            "solution": "The user-provided problem is valid. It is a well-posed, scientifically grounded computational physics problem that investigates a fundamental numerical property of the Particle-In-Cell (PIC) method. All required data and definitions are provided, and the task is objective and verifiable.\n\nThe problem asks for the computation of the spurious total momentum error in a one-dimensional electrostatic PIC simulation with two particles. This error arises because the granular nature of the computational mesh breaks the continuous translational symmetry of the physical laws. In a continuous system, the interaction force between two particles, $\\vec{F}_{12}$, is equal and opposite to the force $\\vec{F}_{21}$, i.e., $\\vec{F}_{12} + \\vec{F}_{21} = 0$, which is Newton's third law. This guarantees conservation of the total momentum of the two-particle system.\n\nIn a PIC simulation, particles do not interact directly. Instead, they interact via a grid-discretized field. The process involves three steps:\n$1$. **Charge Deposition**: Each particle's charge is \"smeared\" onto a few nearby grid nodes.\n$2$. **Field Solve**: The electrostatic field is calculated on the grid nodes from the deposited charge density.\n$3$. **Force Interpolation**: The field is interpolated from the grid nodes back to the particle positions to calculate the force.\n\nThis grid-mediated interaction does not, in general, satisfy Newton's third law for the particles. The force on particle $1$, $F_1$, is derived from the field created by particle $2$'s charge as it is represented on the grid, and vice versa. Due to the discretization, the force $F_1$ is not exactly equal and opposite to $F_2$, leading to a non-zero total force $F_1 + F_2 \\neq 0$ and a violation of momentum conservation. The magnitude of this violation, quantified by the error metric $\\varepsilon_m$, depends critically on the smoothness of the functions used for charge deposition and force interpolation. These functions are known as particle shape functions.\n\nHigher-order shape functions provide a smoother representation of the particle on the grid, reducing the unphysical dependencies of the force on the particle's position relative to the grid nodes. This leads to better conservation properties. The problem requires a demonstration of this principle by computing $\\varepsilon_m$ for shape functions of increasing order $m \\in \\{0, 1, 2, 3\\}$.\n\nThe computational procedure to calculate the error $\\varepsilon_m$ for a given test case $(N_g, m, x_1, x_2)$ is as follows:\n\n**1. System Setup**\nThe simulation domain is of length $L=1$ with periodic boundary conditions. The grid consists of $N_g$ nodes at positions $x_j = j \\Delta x$ for $j \\in \\{0, 1, \\dots, N_g-1\\}$, where the grid spacing is $\\Delta x = L/N_g = 1/N_g$. Two particles are present with charges $q_1=+1$ and $q_2=-1$ at positions $x_1$ and $x_2$, respectively. The vacuum permittivity is $\\varepsilon_0=1$.\n\n**2. Particle Shape Functions**\nThe interaction between particles and the grid is mediated by a basis spline (B-spline) shape function of order $p=m+1$, denoted as $S_m(u)$, where $u=(x_p - x_j)/\\Delta x$ is the normalized distance from a particle at $x_p$ to a grid node at $x_j$. The function $S_m(u)$ is non-zero over a finite support. We implement the B-splines $B_{m+1}(u)$ for shape orders $m=0, 1, 2, 3$:\n-   Order $m=0$ (NGP, $B_1$): $S_0(u) = 1$ for $|u| \\le 1/2$ and $0$ otherwise.\n-   Order $m=1$ (CIC, $B_2$): $S_1(u) = 1 - |u|$ for $|u| \\le 1$ and $0$ otherwise.\n-   Order $m=2$ (TSC, $B_3$): $S_2(u) = \\begin{cases} 3/4 - u^2 & |u| \\le 1/2 \\\\ 1/2(3/2 - |u|)^2 & 1/2 < |u| \\le 3/2 \\\\ 0 & |u| > 3/2 \\end{cases}$.\n-   Order $m=3$ (PCS, $B_4$): $S_3(u) = \\begin{cases} 1/6(3|u|^3 - 6u^2 + 4) & |u| \\le 1 \\\\ 1/6(2 - |u|)^3 & 1 < |u| \\le 2 \\\\ 0 & |u| > 2 \\end{cases}$.\n\n**3. Charge Deposition**\nA grid array for charge density, $\\rho_j$, is initialized to zero. For each particle $p \\in \\{1, 2\\}$ with charge $q_p$ at position $x_p$, we deposit its charge onto the grid.\nFirst, we find all grid nodes $j$ that are within the support of the shape function centered at $x_p$. For each such node, we compute a weight $W_{p,j} = S_m((x_p/\\Delta x) - j)$. The charge density at node $j$ is updated by adding the particle's contribution: $\\rho_j \\leftarrow \\rho_j + q_p W_{p,j} / \\Delta x$. The division by cell volume $\\Delta x$ correctly scales the deposited charge to a charge density. The node indices $j$ are handled periodically, i.e., computed modulo $N_g$.\n\n**4. Spectral Field Solve**\nThe Poisson equation in one dimension is $\\partial_x E = \\rho(x)/\\varepsilon_0$. We solve this equation on the grid using the Discrete Fourier Transform (DFT).\n-   First, we compute the DFT of the grid charge density: $\\hat{\\rho}_k = \\mathcal{F}\\{\\rho_j\\}$.\n-   In Fourier space, the spatial derivative $\\partial_x$ becomes multiplication by $i k$, where $k$ is the wavenumber. The equation becomes $i k \\hat{E}_k = \\hat{\\rho}_k/\\varepsilon_0$.\n-   The wavenumbers corresponding to the DFT are given by $k_n = 2\\pi n / L$ for $n \\in \\{-N_g/2, \\dots, N_g/2-1\\}$.\n-   The grid electric field in Fourier space is then $\\hat{E}_k = \\frac{\\hat{\\rho}_k}{i k \\varepsilon_0} = -i \\frac{\\hat{\\rho}_k}{k \\varepsilon_0}$ for $k \\ne 0$.\n-   For the $k=0$ mode (DC component), the net charge $\\sum q_p=0$ ensures that $\\hat{\\rho}_{k=0}=0$. The expression for $\\hat{E}_{k=0}$ is indeterminate. We set $\\hat{E}_{k=0}=0$, which corresponds to zero average electric field, consistent with periodic boundary conditions and zero net charge. This also enforces the zero mean potential condition.\n-   Finally, the electric field on the grid, $E_j$, is obtained by computing the inverse DFT of $\\hat{E}_k$: $E_j = \\mathcal{F}^{-1}\\{\\hat{E}_k\\}$.\n\n**5. Force Interpolation**\nThe electric field at each particle's position, $E(x_p)$, is found by interpolating the grid electric field $E_j$ using the same shape function $S_m$. The interpolated field is a weighted sum: $E(x_p) = \\sum_j E_j W_{p,j}$, where the weights $W_{p,j}$ are identical to those used in the charge deposition step for particle $p$. This symmetry between deposition and interpolation is crucial for momentum-conserving properties. The force on each particle is then $F_p = q_p E(x_p)$.\n\n**6. Error Calculation**\nWith the forces $F_1$ and $F_2$ computed, the dimensionless spurious momentum error is calculated using the provided formula:\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta}\n$$\nwith the regularization constant $\\delta=10^{-16}$. This procedure is repeated for each of the six test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef b_spline(u_abs, m):\n    \"\"\"\n    Computes the value of the B-spline of order m+1 (degree m) at a given\n    absolute normalized distance u_abs = |u|.\n    These are the standard PIC particle shape functions Sm.\n    \"\"\"\n    if m == 0:  # NGP, B-spline order 1\n        return 1.0 if u_abs  0.5 else 0.0\n    elif m == 1:  # CIC, B-spline order 2\n        return 1.0 - u_abs if u_abs  1.0 else 0.0\n    elif m == 2:  # TSC, B-spline order 3\n        if u_abs = 0.5:\n            return 0.75 - u_abs**2\n        elif u_abs = 1.5:\n            return 0.5 * (1.5 - u_abs)**2\n        else:\n            return 0.0\n    elif m == 3:  # PCS, B-spline order 4\n        if u_abs = 1.0:\n            return (1.0/6.0) * (4.0 - 6.0*u_abs**2 + 3.0*u_abs**3)\n        elif u_abs = 2.0:\n            return (1.0/6.0) * (2.0 - u_abs)**3\n        else:\n            return 0.0\n    else:\n        raise ValueError(\"Shape order m must be 0, 1, 2, or 3.\")\n\ndef get_weights(x_p, m, Ng, dx):\n    \"\"\"\n    Calculates the weights and indices for depositing charge or interpolating fields.\n    \"\"\"\n    u_p = x_p / dx\n    support_half_width = (m + 1) / 2.0\n    \n    j_min = int(np.ceil(u_p - support_half_width))\n    j_max = int(np.floor(u_p + support_half_width))\n    \n    indices = []\n    weights = []\n    \n    for j in range(j_min, j_max + 1):\n        u_abs = abs(u_p - j)\n        weight = b_spline(u_abs, m)\n        if weight > 0:\n            indices.append(j % Ng)\n            weights.append(weight)\n            \n    return np.array(indices), np.array(weights)\n\ndef calculate_error(Ng, m, x1, x2):\n    \"\"\"\n    Performs the PIC-style calculation to find the momentum conservation error.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    q1, q2 = 1.0, -1.0\n    epsilon_0 = 1.0\n    delta = 1e-16\n    dx = L / Ng\n\n    # 1. Charge Deposition (Particle-To-Grid)\n    rho_grid = np.zeros(Ng)\n    particles = [(q1, x1), (q2, x2)]\n    \n    # Store weights for later use in interpolation\n    p1_indices, p1_weights = get_weights(particles[0][1], m, Ng, dx)\n    p2_indices, p2_weights = get_weights(particles[1][1], m, Ng, dx)\n\n    # Deposit charge for particle 1\n    rho_grid[p1_indices] += particles[0][0] * p1_weights / dx\n    \n    # Deposit charge for particle 2\n    rho_grid[p2_indices] += particles[1][0] * p2_weights / dx\n\n    # 2. Field Solve (Grid)\n    # DFT of charge density\n    rho_hat = np.fft.fft(rho_grid)\n    \n    # Wavenumbers\n    k = 2 * np.pi * np.fft.fftfreq(Ng, d=dx)\n    \n    # Solve for E-field in Fourier space: E_hat = -i * rho_hat / (epsilon_0 * k)\n    E_hat = np.zeros_like(rho_hat, dtype=complex)\n    nonzero_k_mask = k != 0\n    E_hat[nonzero_k_mask] = -1j * rho_hat[nonzero_k_mask] / (epsilon_0 * k[nonzero_k_mask])\n    \n    # Inverse DFT to get E-field on grid\n    E_grid = np.real(np.fft.ifft(E_hat))\n\n    # 3. Force Interpolation (Grid-To-Particle)\n    # Interpolate E-field at particle 1 and calculate force\n    E1 = np.sum(E_grid[p1_indices] * p1_weights)\n    F1 = q1 * E1\n    \n    # Interpolate E-field at particle 2 and calculate force\n    E2 = np.sum(E_grid[p2_indices] * p2_weights)\n    F2 = q2 * E2\n\n    # 4. Calculate Spurious Momentum Error\n    error = np.abs(F1 + F2) / (np.abs(F1) + np.abs(F2) + delta)\n    \n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 0, 0.23, 0.77),\n        (32, 1, 0.23, 0.77),\n        (32, 2, 0.23, 0.77),\n        (32, 3, 0.23, 0.77),\n        (32, 3, 0.98, 0.12),\n        (64, 3, 0.401, 0.409),\n    ]\n\n    results = []\n    for case in test_cases:\n        Ng, m, x1, x2 = case\n        result = calculate_error(Ng, m, x1, x2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The convenient translational symmetry of periodic systems is absent in realistic plasma devices, which have material walls typically modeled with Dirichlet boundary conditions. This exercise explores how the broken symmetry near a boundary generates a significant, unphysical self-force on a particle. You will derive this force from first principles and, importantly, construct a local correction scheme to remove it, a vital technique for accurate modeling of bounded plasmas .",
            "id": "4183305",
            "problem": "A single-species, one-dimensional, electrostatic particle–mesh model is considered to study how boundary-induced asymmetry generates a nonzero self-force on a single particle, and how to derive a local correction that restores symmetry in the field interpolation. The computational domain is the interval $[0,L]$ with uniform mesh spacing $\\Delta x = L/N$, mesh nodes indexed by $i \\in \\{0,1,\\dots,N\\}$, and Dirichlet boundary conditions $\\phi_0 = \\phi_N = 0$ on the electrostatic potential. All quantities are expressed in dimensionless units, with permittivity scaled to unity.\n\nFundamental base and discrete model:\n- Start from electrostatics with Poisson’s equation $- \\nabla^2 \\phi = \\rho$ and the Lorentz force $F = q E$, where $E = -\\nabla \\phi$. In one dimension with a second-order finite-difference scheme on the nodes, the interior discrete Poisson equation for $i \\in \\{1,\\dots,N-1\\}$ is\n$$\n\\frac{-\\phi_{i+1} + 2 \\phi_i - \\phi_{i-1}}{\\Delta x^2} = \\rho_i,\n$$\nwhich can be written in matrix form $A \\phi = \\rho \\, \\Delta x^2$ for the vector of interior unknowns $\\phi = (\\phi_1,\\dots,\\phi_{N-1})^\\top$ with the tri-diagonal matrix $A$ having $2$ on the diagonal and $-1$ on the first sub- and super-diagonals.\n\n- The electric field at interior nodes is defined by the centered difference $E_i = -(\\phi_{i+1}-\\phi_{i-1})/(2 \\Delta x)$ for $i \\in \\{1,\\dots,N-1\\}$, where the boundary node potentials $\\phi_0$ and $\\phi_N$ are known.\n\n- A single macro-particle of charge $q$ at position $x \\in (0,L)$ is represented on the mesh by a discrete shape vector $S(x) \\in \\mathbb{R}^{N-1}$ of Cloud-In-Cell (CIC) type that maps to interior nodes only. For an interior cell indexed by $i \\in \\{1,\\dots,N-2\\}$, with $x \\in [i \\Delta x, (i+1)\\Delta x)$ and $\\xi=(x-i \\Delta x)/\\Delta x \\in [0,1)$, the weights are $S_i(x)=1-\\xi$ and $S_{i+1}(x)=\\xi$; all other entries are zero. Near the left boundary in the first cell $i=0$, CIC support partially lies outside the domain; truncation and renormalization assign the entire charge to the interior node $i=1$: $S_1(x)=1$, all others zero. Near the right boundary in the last cell $i=N-1$, truncation and renormalization assign the entire charge to $i=N-1$: $S_{N-1}(x)=1$. This truncation is the boundary-induced asymmetry.\n\n- The particle-to-grid charge mapping is $\\rho = (q/\\Delta x) S(x)$, so that $A \\phi = \\rho \\Delta x^2 = q \\, \\Delta x \\, S(x)$. The grid electric field vector $E \\in \\mathbb{R}^{N-1}$ is obtained from $\\phi$ using the centered difference definition. Field interpolation back to the particle uses the same shape $S(x)$: $E_p(x) = S(x)^\\top E$, yielding the particle force $F(x) = q \\, E_p(x)$.\n\nTargets:\n1) Using the above model, justify from first principles why the truncation near boundaries breaks translational invariance and leads to a nonzero numerical self-force $F(x)$ even for a single particle, by expressing $F(x)$ in the quadratic form $F(x) = q^2 S(x)^\\top K S(x)$ for a discrete operator $K$ that depends on the mesh and boundary conditions.\n\n2) Derive a local correction $\\delta E(x)$, depending only on the particle’s position $x$ and the mesh, which must be added to the interpolated field at the particle to cancel the numerical self-force generated by the asymmetric truncation, i.e., ensuring that the corrected self-force vanishes for a solitary particle: $F_{\\mathrm{corr}}(x) = q \\, (E_p(x) + \\delta E(x)) = 0$. Express $\\delta E(x)$ in terms of the same discrete operators used for $E_p(x)$, so that it can be computed locally per particle and per time step in a simulation.\n\nNumerical specification to be implemented:\n- Use $L=1$ and $N=32$.\n- Use a single particle with $q=1$ and positions $x$ given by the test suite below.\n- Compute the uncorrected self-force $F(x)$ as described.\n- Compute the corrected self-force $F_{\\mathrm{corr}}(x)$ by applying the derived local correction $\\delta E(x)$.\n\nTest suite:\n- Evaluate at the following positions (dimensionless, in the interval $(0,1)$): $x \\in \\{0.001,\\; 0.02,\\; 0.5,\\; 0.98,\\; 0.999\\}$.\n\nRequired output:\n- Your program should produce a single line of output containing ten comma-separated floating-point numbers enclosed in square brackets, in the following order: for each $x$ in the test suite, output first the uncorrected $F(x)$ and then the corrected $F_{\\mathrm{corr}}(x)$, concatenated across all five test cases. The final format must be exactly\n\"[F(x1),F_corr(x1),F(x2),F_corr(x2),F(x3),F_corr(x3),F(x4),F_corr(x4),F(x5),F_corr(x5)]\".\n\nAll computations are dimensionless as stated; no physical units are required, and no angles or percentages are involved.",
            "solution": "The problem requires an analysis of the numerical self-force in a one-dimensional electrostatic particle-mesh model and the derivation of a local correction to restore force-freeness for a single particle. The analysis will proceed in two parts, followed by a description of the numerical implementation.\n\n### Part 1: Derivation and Justification of the Numerical Self-Force\n\nThe self-force on a single particle with charge $q$ at position $x$ is given by $F(x) = q E_p(x)$, where $E_p(x)$ is the electric field generated by the particle itself, interpolated back to its own position. We will derive an expression for $F(x)$ by tracing the computational cycle of the particle-mesh method.\n\n1.  **Particle-to-Grid Charge Assignment**: The particle's charge $q$ is distributed onto the interior grid nodes $\\{1, \\dots, N-1\\}$ using the specified Cloud-In-Cell (CIC) shape vector $S(x) \\in \\mathbb{R}^{N-1}$. The charge density vector $\\rho \\in \\mathbb{R}^{N-1}$ on the interior grid nodes is given by\n    $$ \\rho = \\frac{q}{\\Delta x} S(x) $$\n    where $\\Delta x = L/N$ is the mesh spacing.\n\n2.  **Solving for Electrostatic Potential**: The potential vector $\\phi = (\\phi_1, \\dots, \\phi_{N-1})^\\top$ on the interior nodes is found by solving the discrete Poisson equation, $A \\phi = \\rho \\Delta x^2$, where $A$ is the $(N-1) \\times (N-1)$ matrix representing the second-order finite-difference approximation to the negative Laplacian, $-\\frac{d^2}{dx^2}$.\n    $$ A = \\begin{pmatrix} 2  -1  0  \\dots \\\\ -1  2  -1  \\\\ 0  \\ddots  \\ddots  \\ddots \\\\   -1  2  -1 \\\\ \\dots   0  -1  2 \\end{pmatrix} $$\n    The matrix $A$ is symmetric and invertible. The solution for the potential is:\n    $$ \\phi = A^{-1} (\\rho \\Delta x^2) = A^{-1} \\left( \\left(\\frac{q}{\\Delta x} S(x)\\right) \\Delta x^2 \\right) = q \\Delta x A^{-1} S(x) $$\n\n3.  **Calculating the Grid Electric Field**: The electric field vector $E = (E_1, \\dots, E_{N-1})^\\top$ at the interior nodes is calculated using a centered finite difference on the potential, $E_i = -(\\phi_{i+1}-\\phi_{i-1})/(2\\Delta x)$. This can be expressed in matrix form as $E = C \\phi$, where $C$ is the $(N-1) \\times (N-1)$ anti-symmetric matrix operator:\n    $$ C = \\frac{1}{2 \\Delta x} \\begin{pmatrix}\n    0  -1  0  \\dots  0 \\\\\n    1  0  -1   0 \\\\\n    0  1  0  \\ddots  \\vdots \\\\\n    \\vdots   \\ddots  \\ddots  -1 \\\\\n    0  \\dots  0  1  0\n    \\end{pmatrix} $$\n    Substituting the expression for $\\phi$:\n    $$ E = C (q \\Delta x A^{-1} S(x)) = q \\Delta x C A^{-1} S(x) $$\n\n4.  **Grid-to-Particle Field Interpolation**: The electric field is interpolated from the grid back to the particle's position $x$ using the same shape vector $S(x)$:\n    $$ E_p(x) = S(x)^\\top E = S(x)^\\top \\left( q \\Delta x C A^{-1} S(x) \\right) = q \\Delta x S(x)^\\top C A^{-1} S(x) $$\n\n5.  **Calculating the Force**: Finally, the self-force is $F(x) = q E_p(x)$:\n    $$ F(x) = q^2 \\Delta x S(x)^\\top C A^{-1} S(x) $$\n    This is the required quadratic form $F(x) = q^2 S(x)^\\top K S(x)$, with the discrete operator $K = \\Delta x C A^{-1}$.\n\n**Justification for Nonzero Self-Force**:\nIn a continuous, infinite, and translationally invariant system, the net force exerted by a particle on itself is strictly zero, a consequence of symmetry (or Newton's third law applied to interactions between infinitesimal parts of the charge). A numerical scheme should ideally preserve this property. The described scheme fails to do so, leading to a non-zero self-force, due to the breaking of translational symmetry.\n\nThe symmetry is broken in two ways:\na) **Boundary Conditions**: The imposition of Dirichlet boundary conditions $\\phi_0 = \\phi_N = 0$ is equivalent to placing image charges outside the domain $[0,L]$. The particle interacts with its own images, resulting in a force that pushes it away from the boundaries. The matrix $A^{-1}$, which is the discrete Green's function for the potential, is not translationally invariant due to these boundary conditions.\nb) **Shape Function Truncation**: The definition of the shape vector $S(x)$ is not translationally invariant. While in the interior of the domain, $S(x)$ smoothly translates as $x$ changes, this pattern is broken near the boundaries. For $x \\in [0, \\Delta x)$, the shape function is abruptly truncated and renormalized to be $S_1(x)=1$, which is a constant and highly asymmetric mapping. A similar truncation occurs near $x=L$. This asymmetric deposition of charge onto the grid creates an artificial dipole or higher-order multipole moment in the charge distribution, which then results in a non-zero electric field at the particle's location and thus a spurious self-force. The quadratic form $S(x)^\\top (C A^{-1}) S(x)$ is generally non-zero because the operator $C A^{-1}$ lacks the necessary symmetry and the vector $S(x)$ is not symmetric in the boundary regions.\n\n### Part 2: Derivation of the Local Correction\n\nThe goal is to find a local correction $\\delta E(x)$ to be added to the interpolated electric field at the particle's position, such that the corrected self-force is zero. The corrected force is defined as:\n$$ F_{\\mathrm{corr}}(x) = q (E_p(x) + \\delta E(x)) $$\nFor a single particle, we require this force to vanish:\n$$ q (E_p(x) + \\delta E(x)) = 0 $$\nThis immediately implies that the correction must be the negative of the interpolated self-field:\n$$ \\delta E(x) = -E_p(x) $$\nUsing the expression for $E_p(x)$ derived in Part 1:\n$$ \\delta E(x) = -q \\Delta x S(x)^\\top C A^{-1} S(x) $$\nThis correction is \"local\" as it depends only on the particle's own charge $q$ and position $x$ (which determines $S(x)$), and not on the properties of any other particles in the system. In a simulation, this term would be calculated for each particle and added to the total field interpolated at its position, effectively subtracting the unphysical self-force while retaining the physical forces from other particles.\n\nBy construction, applying this correction to the self-force calculation yields:\n$$ F_{\\mathrm{corr}}(x) = q (E_p(x) + (-E_p(x))) = q(E_p(x) - E_p(x)) = 0 $$\nTherefore, the corrected self-force for a solitary particle is identically zero, up to numerical floating-point precision.\n\n### Numerical Implementation\n\nThe program will implement the derived formulae.\n1.  Set parameters $L=1$, $N=32$, $q=1$, and $\\Delta x = L/N$.\n2.  Construct the $(N-1) \\times (N-1)$ matrices $A$ and $C$ as defined above.\n3.  Pre-compute the inverse matrix $A^{-1}$.\n4.  For each test position $x$:\n    a. Determine the cell index $i = \\lfloor x / \\Delta x \\rfloor$ and compute the shape vector $S(x) \\in \\mathbb{R}^{N-1}$ according to the specified rules for interior and boundary cells.\n    b. Calculate the uncorrected self-force $F(x) = q^2 \\Delta x S(x)^\\top C A^{-1} S(x)$.\n    c. Calculate the corrected self-force $F_{\\mathrm{corr}}(x)$. Based on our derivation, this is simply $F(x) - F(x)$, which should evaluate to a value very close to zero. We will compute it as $q(E_p(x) - E_p(x))$ to verify the process numerically.\n5.  Collect and print the results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the uncorrected and corrected numerical self-force on a single particle\n    in a 1D electrostatic particle-mesh model.\n    \"\"\"\n    # Numerical specification from the problem\n    L = 1.0\n    N = 32\n    q = 1.0\n    dx = L / N\n    \n    # The problem considers interior grid points i in {1, ..., N-1}.\n    # This corresponds to N-1 points, so matrices will be (N-1)x(N-1).\n    num_interior_nodes = N - 1\n    \n    # Construct the discrete Poisson matrix A\n    # A is a tridiagonal matrix with 2 on the main diagonal and -1 on the\n    # first sub- and super-diagonals.\n    A = np.diag(2 * np.ones(num_interior_nodes)) - \\\n        np.diag(np.ones(num_interior_nodes - 1), k=1) - \\\n        np.diag(np.ones(num_interior_nodes - 1), k=-1)\n    \n    # Pre-compute the inverse of A\n    A_inv = np.linalg.inv(A)\n    \n    # Construct the discrete gradient matrix C\n    # C maps potential phi to electric field E. E_i = - (phi_{i+1} - phi_{i-1}) / (2*dx)\n    # This results in an anti-symmetric matrix.\n    C = (1.0 / (2.0 * dx)) * \\\n        (np.diag(np.ones(num_interior_nodes - 1), k=-1) - \\\n         np.diag(np.ones(num_interior_nodes - 1), k=1))\n\n    # Test suite of particle positions\n    # Note: problem statement uses (0,1) interval.\n    # The implementation handles x in [0,1) due to floor function.\n    test_cases = [0.001, 0.02, 0.5, 0.98, 0.999]\n    \n    results = []\n\n    for x in test_cases:\n        # 1. Compute the shape vector S(x)\n        S = np.zeros(num_interior_nodes)\n        \n        # Determine cell index i for x in [i*dx, (i+1)*dx)\n        if x >= L: x = L - 1e-9 # handle x=L edge case not covered by problem\n        i = int(np.floor(x / dx))\n        \n        # The problem defines vector components for S_i where i in {1..N-1}.\n        # In 0-based numpy arrays, S_i corresponds to index i-1.\n        \n        if i == 0:\n            # Left boundary cell: charge assigned to node 1\n            # S_1 = 1 --> S[0] = 1\n            S[0] = 1.0\n        elif i == N - 1:\n            # Right boundary cell: charge assigned to node N-1\n            # S_{N-1} = 1 --> S[N-2] = 1\n            S[N - 2] = 1.0\n        elif 1 = i = N - 2:\n            # Interior cell: CIC scheme\n            # For x in [i*dx, (i+1)*dx), weights go to nodes i and i+1.\n            xi = (x - i * dx) / dx\n            # S_i = 1-xi  --> S[i-1]\n            S[i - 1] = 1.0 - xi\n            # S_{i+1} = xi --> S[i]\n            S[i] = xi\n        else:\n            # This case should not be reached with the given test_cases\n            raise ValueError(f\"Position x={x} results in invalid cell index i={i}\")\n\n        # 2. Calculate the interpolated self-field Ep(x)\n        # Ep(x) = q * dx * S^T @ C @ A_inv @ S\n        S_T = S.reshape(1, num_interior_nodes) # Ensure S is a row vector for transpose\n        \n        # The expression S.T @ M @ S for 1D array S is equivalent to S @ M @ S\n        # Numpy handles this dimensionality promotion automatically.\n        Ep = q * dx * S @ C @ A_inv @ S\n\n        # 3. Calculate uncorrected self-force F(x) = q * Ep(x)\n        F_uncorrected = q * Ep\n\n        # 4. Calculate corrected self-force F_corr(x)\n        # The local correction to the field is delta_E = -Ep\n        # F_corr = q * (Ep + delta_E) = q * (Ep - Ep)\n        \n        # We compute this explicitly to show the numerical result.\n        delta_E = -Ep\n        F_corr = q * (Ep + delta_E)\n        \n        results.append(F_uncorrected)\n        results.append(F_corr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}