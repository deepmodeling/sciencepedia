{
    "hands_on_practices": [
        {
            "introduction": "粒子-网格 (Particle-In-Cell, PIC) 模拟的第一步是将代表连续点电荷的狄拉克 $\\delta$ 函数场投影到离散的计算网格上。这个练习将引导你从第一性原理推导电荷分配的形式，并让你亲手计算广泛使用的“云中云”(Cloud-In-Cell, CIC) 方案下单个粒子如何在二维网格上分配其电荷。掌握这一基本技能是理解和构建任何 PIC 代码的基础。",
            "id": "4183274",
            "problem": "在一次聚变等离子体湍流模拟的先进质点网格 (PIC) 离散化中，微观电荷密度由一串 Dirac delta 分布之和表示，$\\rho(\\mathbf{x}) = \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p})$，其中$q_{p}$和$\\mathbf{x}_{p}$分别是粒子$p$的电荷和位置。在一个二维空间、间距为$\\Delta x$和$\\Delta y$的均匀笛卡尔网格上，与位于$\\mathbf{x}_{g}$位置的网格节点相关的节点电荷密度$\\rho_{g}$，是通过将$\\rho(\\mathbf{x})$投影到一个平移不变的节点基函数$N_{g}(\\mathbf{x}) = N(\\mathbf{x} - \\mathbf{x}_{g})$上，然后进行集中质量归一化来定义的：$\\rho_{g} := A^{-1} \\int_{\\Omega} \\rho(\\mathbf{x}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}$，其中$A := \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x}$。请仅使用上述定义以及 Dirac delta 分布的性质和$N_{g}$的平移不变性，推导出$\\rho_{g}$的函数形式，该形式用一个在节点-粒子位移上求值的形函数表示。\n\n然后，特化为 Cloud-In-Cell (CIC) 方法中对$N(\\mathbf{x})$的选择，它被构造为保持电荷守恒的一维线性帽函数的张量积。设一维参考帽函数定义为$N_{1\\mathrm{D}}(x) = \\max\\{0,\\,1 - |x|/\\Delta x\\}$，对$y$也类似，因此$N(\\mathbf{x}) = N_{1\\mathrm{D}}(x) \\, N_{1\\mathrm{D}}(y)$。考虑一个电荷为$q_{p}$的单个粒子，位于其左下角节点在$(x_{i}, y_{j})$的单元格内，其位置为$x_{p} = x_{i} + a \\,\\Delta x$和$y_{p} = y_{j} + b \\,\\Delta y$，其中$0 \\leq a \\leq 1$和$0 \\leq b \\leq 1$。在 CIC 方法下，计算此粒子对离散节点电荷密度$\\rho_{i,j}$的贡献。\n\n请用$q_{p}$、$\\Delta x$、$\\Delta y$、$a$和$b$将你的最终答案表示为一个单一的闭式解析表达式。最终结果以库仑/平方米为单位给出。",
            "solution": "我们从电荷的微观表示开始，$\\rho(\\mathbf{x}) = \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p})$，这是连续空间中点电荷的标准模型。离散节点值$\\rho_{g}$是通过将此场投影到节点基函数$N_{g}(\\mathbf{x}) = N(\\mathbf{x} - \\mathbf{x}_{g})$上，并通过基函数积分进行归一化以产生密度来定义的：\n$$\n\\rho_{g} := A^{-1} \\int_{\\Omega} \\rho(\\mathbf{x}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}, \\quad A := \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x}.\n$$\n将微观形式代入投影中得到\n$$\n\\rho_{g} = A^{-1} \\int_{\\Omega} \\left( \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p}) \\right) N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}.\n$$\n根据积分和求和的线性性质，以及 Dirac delta 分布的筛选性质，我们得到\n$$\n\\rho_{g} = A^{-1} \\sum_{p} q_{p} \\int_{\\Omega} \\delta(\\mathbf{x} - \\mathbf{x}_{p}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}\n= A^{-1} \\sum_{p} q_{p} \\, N_{g}(\\mathbf{x}_{p}).\n$$\n利用节点基函数的平移不变性，$N_{g}(\\mathbf{x}_{p}) = N(\\mathbf{x}_{p} - \\mathbf{x}_{g})$，我们可以写出\n$$\n\\rho_{g} = \\sum_{p} q_{p} \\, S(\\mathbf{x}_{g} - \\mathbf{x}_{p}),\n$$\n其中形函数$S(\\mathbf{u})$定义为$S(\\mathbf{u}) := A^{-1} N(-\\mathbf{u})$。对于偶函数形式的基函数$N(\\mathbf{x})$，例如 Cloud-In-Cell 的选择，$N(-\\mathbf{u}) = N(\\mathbf{u})$，因此$S(\\mathbf{u}) = A^{-1} N(\\mathbf{u})$。这种构造产生了一致的电荷分配，其中相同的形函数也出现在力的反向插值中，当使用相同的$S$将场插值回粒子时，确保了动量守恒。\n\n我们现在特化为二维的 Cloud-In-Cell (CIC) 节点基函数。一维线性帽函数是\n$$\nN_{1\\mathrm{D}}(x) = \\max\\{0,\\, 1 - |x|/\\Delta x \\},\n$$\n二维节点基函数是其张量积\n$$\nN(\\mathbf{x}) = N_{1\\mathrm{D}}(x) \\, N_{1\\mathrm{D}}(y).\n$$\n$N$在其支撑域上的积分是一维积分的乘积。在一维中，\n$$\n\\int_{-\\Delta x}^{\\Delta x} N_{1\\mathrm{D}}(x) \\, dx = \\int_{-\\Delta x}^{\\Delta x} \\left( 1 - \\frac{|x|}{\\Delta x} \\right) dx = \\Delta x.\n$$\n类似地，在$y$方向，\n$$\n\\int_{-\\Delta y}^{\\Delta y} N_{1\\mathrm{D}}(y) \\, dy = \\Delta y.\n$$\n因此，\n$$\nA = \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x} = \\left( \\int N_{1\\mathrm{D}}(x) \\, dx \\right) \\left( \\int N_{1\\mathrm{D}}(y) \\, dy \\right) = \\Delta x \\, \\Delta y.\n$$\n因此，CIC 形函数为\n$$\nS(\\mathbf{u}) = \\frac{1}{\\Delta x \\, \\Delta y} \\, N(\\mathbf{u}) = \\frac{1}{\\Delta x \\, \\Delta y} \\, N_{1\\mathrm{D}}(u_{x}) \\, N_{1\\mathrm{D}}(u_{y}).\n$$\n\n现在考虑一个电荷为$q_{p}$的单个粒子，位于其左下角节点在$(x_{i}, y_{j})$的单元格内，其位置为$x_{p} = x_{i} + a \\,\\Delta x$，$y_{p} = y_{j} + b \\,\\Delta y$，其中$0 \\leq a \\leq 1$和$0 \\leq b \\leq 1$。我们要求解左下角节点的节点电荷密度，即$\\rho_{i,j}$，根据分配规则，它等于\n$$\n\\rho_{i,j} = q_{p} \\, S(\\mathbf{x}_{i,j} - \\mathbf{x}_{p}) = q_{p} \\, \\frac{1}{\\Delta x \\, \\Delta y} \\, N_{1\\mathrm{D}}(x_{i} - x_{p}) \\, N_{1\\mathrm{D}}(y_{j} - y_{p}).\n$$\n因为$x_{i} - x_{p} = - a \\,\\Delta x$和$y_{j} - y_{p} = - b \\,\\Delta y$，并且$N_{1\\mathrm{D}}$取决于绝对值，\n$$\nN_{1\\mathrm{D}}(x_{i} - x_{p}) = 1 - \\frac{|x_{i} - x_{p}|}{\\Delta x} = 1 - \\frac{a \\,\\Delta x}{\\Delta x} = 1 - a,\n$$\n$$\nN_{1\\mathrm{D}}(y_{j} - y_{p}) = 1 - \\frac{|y_{j} - y_{p}|}{\\Delta y} = 1 - \\frac{b \\,\\Delta y}{\\Delta y} = 1 - b.\n$$\n将这些代入$\\rho_{i,j}$的表达式中，得到\n$$\n\\rho_{i,j} = q_{p} \\, \\frac{1}{\\Delta x \\, \\Delta y} \\, (1 - a) \\, (1 - b).\n$$\n这是一个用$q_{p}$、$\\Delta x$、$\\Delta y$、$a$和$b$表示的闭式解析表达式，单位是库仑/平方米，符合要求。值得注意的是，单元格的其他三个节点获得的权重分别为$a(1 - b)/(\\Delta x \\Delta y)$、$(1 - a)b/(\\Delta x \\Delta y)$和$ab/(\\Delta x \\Delta y)$，这些权重与$(1 - a)(1 - b)/(\\Delta x \\Delta y)$的总和为$1/(\\Delta x \\Delta y)$，这确保了沉积的节点电荷之和等于粒子电荷在单元格面积上的平均密度。",
            "answer": "$$\\boxed{\\frac{q_{p}}{\\Delta x \\,\\Delta y}\\,(1 - a)\\,(1 - b)}$$"
        },
        {
            "introduction": "在学会如何将粒子电荷分配到网格上之后，下一个关键问题是确保这个离散化过程不会人为地产生或消灭电荷。这项练习将理论证明与数值验证相结合，揭示了形函数所具有的“单位分解”($\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$) 特性是如何保证全局电荷守恒的。通过完成这个练习，你将深刻理解为何这一特性对于防止模拟中出现非物理的电荷漂移至关重要。",
            "id": "4183292",
            "problem": "考虑一个用于聚变等离子体湍流模拟的粒子模拟 (PIC) 方法中的均匀、周期性的笛卡尔网格。设空间域为二维，长度为 $L_x$ 和 $L_y$，分别离散为 $N_x$ 和 $N_y$ 个等间距节点。网格间距为 $h_x = L_x / N_x$ 和 $h_y = L_y / N_y$。一个包含 $N_p$ 个点粒子的集合，其电荷为 $\\{q_i\\}_{i=1}^{N_p}$，位置为 $\\{\\mathbf{x}_i\\}_{i=1}^{N_p}$，其中 $\\mathbf{x}_i = (x_i,y_i)$，将被沉积到网格上，形成位于节点索引 $(j,k)$ 处的电荷密度场 $\\rho_{j,k}$。\n\nPIC 电荷分配使用一个维度可分离的、具有紧支集和精确单位分解性质的形状函数 $W(\\xi)$，其定义要求为：对于任意实数 $\\xi$，对整数的无穷求和满足 $\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$。二维形状是在无量纲坐标上求值的乘积 $S(\\mathbf{x}) = W(x/h_x) W(y/h_y)$。电荷沉积规则为\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right),\n$$\n采用周期性边界条件，因此所有节点索引都解释为对 $N_x$ 和 $N_y$ 取模。电荷的物理单位是库仑 (C)，电荷密度的单位是库仑/平方米 (C/m$^2$)。\n\n任务A (证明)：从电荷守恒的积分形式和上述离散沉积定义出发，根据第一性原理推导，沉积在网格上的总电荷\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y,\n$$\n在每个时间步上，都精确等于总粒子电荷 $Q_{\\text{part}} = \\sum_{i=1}^{N_p} q_i$，前提是 $W(\\xi)$ 满足精确的单位分解性质且周期性环绕已正确实现。解释为什么这能防止离散系统中的净电荷漂移。\n\n任务B (数值验证)：实现实践中使用的、满足精确单位分解性质并具有紧支集的一维形状函数：\n- 最近邻网格点法 (NGP)，也称为0阶B样条。\n- 云中粒子法 (CIC)，也称为1阶B样条。\n- 三角形云法 (TSC)，也称为具有三点支撑的2阶B样条。\n\n使用这些形状函数构建二维可分离形状 $S(\\mathbf{x})$，并对随机粒子集进行数值验证，证明 $Q_{\\text{grid}} - Q_{\\text{part}}$ 在机器精度内为零。此外，通过将所有一维权重乘以一个常数因子 $\\alpha \\neq 1$ (从而违反单位分解性质)，构建一个特意破坏的 CIC 形状变体，并凭经验证明由此产生的净电荷漂移。\n\n所有计算必须使用国际单位制 (SI)。以库仑 (C) 为单位报告数值差异。不使用角度。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表包含所有测试用例的结果。每个元素必须是一个浮点数，表示 $Q_{\\text{grid}} - Q_{\\text{part}}$ 的绝对值，单位为库仑 (C)。\n\n使用以下测试套件以确保覆盖率和可复现性。对于每个测试，除非另有说明，粒子位置在域内均匀采样，并且随机数使用给定的种子：\n\n- 测试1 (正常情况, CIC): $L_x = 1.0$ (米), $L_y = 0.5$ (米), $N_x = 64$, $N_y = 32$, $N_p = 1000$, 随机种子 $42$, 粒子电荷从均值为零、标准差为 $1.0 \\times 10^{-19}$ (C) 的正态分布中采样。\n- 测试2 (边界条件压力测试, NGP): $L_x = 1.0$ (米), $L_y = 1.0$ (米), $N_x = 4$, $N_y = 4$, $N_p = 10$, 粒子位置固定在右上边界附近，$(x_i,y_i) \\approx (L_x - \\varepsilon, L_y - \\varepsilon)$，其中 $\\varepsilon = 10^{-12}$ (米)，电荷使用随机种子 $7$ 从均值为零、标准差为 $5.0 \\times 10^{-20}$ (C) 的正态分布中采样。\n- 测试3 (高阶形状, TSC): $L_x = 0.64$ (米), $L_y = 0.64$ (米), $N_x = 32$, $N_y = 32$, $N_p = 5000$, 随机种子 $123$, 粒子电荷从均值为零、标准差为 $2.0 \\times 10^{-19}$ (C) 的正态分布中采样。\n- 测试4 (边界情况, 零粒子, CIC): $L_x = 1.0$ (米), $L_y = 1.0$ (米), $N_x = 16$, $N_y = 16$, $N_p = 0$, 无随机化。\n- 测试5 (破坏的单位分解, 缩放的CIC): $L_x = 1.0$ (米), $L_y = 1.0$ (米), $N_x = 32$, $N_y = 32$, $N_p = 1000$, 位置使用随机种子 $99$, 所有粒子电荷设为 $1.0 \\times 10^{-19}$ (C)，并且在形成可分离的二维权重之前，每个维度中的CIC权重都乘以 $\\alpha = 1.01$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果 (例如, \"[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]\")，其中 $r_m$ 是测试 $m$ 的绝对差异 $|Q_{\\text{grid}} - Q_{\\text{part}}|$，单位为库仑 (C)。",
            "solution": "该问题要求对粒子模拟 (PIC) 电荷沉积方案中的电荷守恒进行分析证明，并对此属性进行数值验证。\n\n### 任务A：电荷守恒证明\n\n目标是证明在给定方案下，沉积在网格上的总电荷 $Q_{\\text{grid}}$ 与粒子的总电荷 $Q_{\\text{part}}$ 完全相同。\n\n总粒子电荷定义为所有单个粒子电荷的总和：\n$$\nQ_{\\text{part}} = \\sum_{i=1}^{N_p} q_i\n$$\n\n网格上的总电荷定义为每个网格节点上的电荷密度乘以该节点对应的面积元 $h_x h_y$ 的总和：\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y\n$$\n\n网格节点 $(j,k)$ 处的电荷密度 $\\rho_{j,k}$ 由沉积规则给出：\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\n其中 $W(\\xi)$ 是一维形状函数。\n\n我们通过将 $\\rho_{j,k}$ 的定义代入 $Q_{\\text{grid}}$ 的表达式来开始证明：\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\left[ \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right] h_x h_y\n$$\n\n面积元 $h_x h_y$ 被消去：\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\n\n由于所有求和都是有限的，我们可以交换求和顺序而不改变结果。我们将对粒子的求和移到最外层：\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right]\n$$\n\n二维形状函数是可分离的，这使我们能够将对网格索引 $(j,k)$ 的双重求和分解为两个独立的一维求和的乘积：\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\left( \\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\right) \\left( \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right) \\right]\n$$\n\n现在，我们必须计算括号中的和。让我们关注对 $j$ 的求和。令 $\\xi_i = x_i/h_x$ 为粒子 $i$ 的归一化位置。该和为 $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$。问题指出，域是周期性的，并且形状函数 $W(\\xi)$ 具有紧支集并满足单位分解性质，即对于任意实数 $\\xi$，$\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$。\n\n由于 $W$ 的紧支集特性，对于任意给定的 $\\xi_i$，项 $W(\\xi_i - j)$ 仅在 $\\xi_i$ 附近的少数几个有限整数索引 $j$ 上非零。网格的周期性意味着，任何在数学上会落在 $[0, N_x-1]$ 范围之外的网格节点索引上的粒子贡献都会被环绕回这个范围内。例如，对节点 $j = N_x$ 的贡献会映射到节点 $0$，对 $j = -1$ 的贡献会映射到 $N_x-1$。这种“混叠”效应意味着，对周期性网格的有限求和 $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$ 精确等价于对所有整数的无限求和 $\\sum_{n \\in \\mathbb{Z}} W(\\xi_i - n)$。\n\n因此，根据单位分解性质：\n$$\n\\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{x_i}{h_x} - n\\right) = 1\n$$\n根据对 $y$ 维度的相同推理：\n$$\n\\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{y_i}{h_y} - n\\right) = 1\n$$\n\n将这些结果代回我们对 $Q_{\\text{grid}}$ 的表达式中：\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ (1) \\cdot (1) \\right] = \\sum_{i=1}^{N_p} q_i\n$$\n\n这个最终表达式正是总粒子电荷 $Q_{\\text{part}}$ 的定义。因此，我们证明了 $Q_{\\text{grid}} = Q_{\\text{part}}$。\n\n此性质，即全局电荷守恒，是稳定PIC模拟的一项基本要求。如果离散算法不守恒总电荷 ($Q_{\\text{grid}} \\neq Q_{\\text{part}}$)，则意味着数值方案本身就是电荷的源或汇。根据电学中的高斯定律 $\\nabla \\cdot \\mathbf{E} = \\rho / \\epsilon_0$，净电荷密度是电场的源。人为地产生或销毁电荷会产生虚假的、非物理的电场，这反过来会对粒子施加不正确的力，导致误差迅速累积和数值不稳定性。这种现象被称为净电荷漂移。使用满足单位分解性质的形状函数可以保证在电荷沉积层面上不会发生这种漂移。\n\n### 任务B：数值验证与算法设计\n\n为了对该原理进行数值验证，我们为各种基于B样条的形状函数实现了电荷沉积。一维形状函数 $W(\\xi)$ 将粒子的连续位置与离散网格节点上的权重联系起来。参数 $\\xi$ 是从粒子到网格节点的归一化距离。二维形状函数是两个一维函数的乘积：$S(x/h_x-j, y/h_y-k) = W(x/h_x-j) W(y/h_y-k)$。\n\n所使用的形状函数有：\n1.  **最近邻网格点法 (NGP, 0阶B样条):** 当 $|\\xi| \\le 0.5$ 时，$W_0(\\xi) = 1$，否则为 $0$。这是一个矩形或“顶帽”函数。它的支撑宽度为 $1$ 个网格单元。粒子的全部电荷被沉积到单个最近的网格节点上。\n2.  **云中粒子法 (CIC, 1阶B样条):** 当 $|\\xi| \\le 1$ 时，$W_1(\\xi) = 1 - |\\xi|$，否则为 $0$。这是一个三角形函数，支撑宽度为 $2$ 个网格单元。一个二维粒子将其电荷沉积到包含它的单元格的 $4$ 个网格节点上。\n3.  **三角形云法 (TSC, 2阶B样条):** $W_2(\\xi)$ 是一个二次样条，支撑宽度为 $3$ 个网格单元。\n    $$\n    W_2(\\xi) = \\begin{cases} \\frac{3}{4} - \\xi^2  \\text{若 } |\\xi| \\le \\frac{1}{2} \\\\ \\frac{1}{2} (\\frac{3}{2} - |\\xi|)^2  \\text{若 } \\frac{1}{2}  |\\xi| \\le \\frac{3}{2} \\\\ 0  \\text{其他情况} \\end{cases}\n    $$\n    一个遵循此方案的二维粒子将其电荷沉积到一个 $3 \\times 3$ 的 $9$ 个网格节点块上。\n\n数值算法按以下步骤进行：\n1.  初始化一个大小为 $(N_x, N_y)$ 的二维数组 `rho_grid`，所有元素为零。\n2.  对于每个电荷为 $q_i$、位置为 $(x_i, y_i)$ 的粒子 $i$：\n    a. 计算其归一化位置 $(\\tilde{x}_i, \\tilde{y}_i) = (x_i/h_x, y_i/h_y)$。\n    b. 根据所选的形状函数 (NGP, CIC, 或 TSC)，确定每个维度中受影响的网格节点索引集 $(j_1, j_2, ...)$ 和 $(k_1, k_2, ...)$。这些索引必须使用模运算符进行周期性环绕 (例如, $j \\pmod{N_x}$)。\n    c. 对于每个受影响的索引 $j_m$，计算相应的一维权重 $w_{x,m} = W(\\tilde{x}_i - j_m)$。类似地，为每个受影响的索引 $k_n$ 计算权重 $w_{y,n}$。\n    d. 对于每对受影响的索引 $(j_m, k_n)$，更新网格上的电荷密度：\n       $$\n       \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} \\gets \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} + \\frac{q_i}{h_x h_y} \\cdot w_{x,m} \\cdot w_{y,n}\n       $$\n3.  遍历所有粒子后，计算总网格电荷 $Q_{\\text{grid}} = h_x h_y \\sum_{j,k} \\rho_{j,k}$。\n4.  计算差异 $|Q_{\\text{grid}} - Q_{\\text{part}}|$。\n\n对于测试5，使用一个“破坏的”方案，其中从 CIC 形状函数导出的一维权重乘以一个因子 $\\alpha = 1.01$。这明确违反了单位分解性质，因为单个粒子的权重之和将是 $\\alpha^2$ 而不是 $1$。该实现将展示由此产生的非零电荷差异，从而证实单位分解性质与电荷守恒之间的理论联系。数值实现对指定的测试用例执行这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PIC charge deposition problem, including analytical proof and numerical verification.\n    \"\"\"\n    test_cases = [\n        # Test 1 (happy path, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 0.5, 'Nx': 64, 'Ny': 32, 'Np': 1000,\n         'seed': 42, 'charge_dist': ('normal', 0, 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 2 (boundary condition stress, NGP)\n        {'shape': 'NGP', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 4, 'Ny': 4, 'Np': 10,\n         'seed': 7, 'charge_dist': ('normal', 0, 5.0e-20),\n         'pos_dist': ('clustered', 1e-12), 'alpha': 1.0},\n        # Test 3 (higher-order shape, TSC)\n        {'shape': 'TSC', 'Lx': 0.64, 'Ly': 0.64, 'Nx': 32, 'Ny': 32, 'Np': 5000,\n         'seed': 123, 'charge_dist': ('normal', 0, 2.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 4 (edge case, zero particles, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16, 'Np': 0,\n         'seed': None, 'charge_dist': None, 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 5 (broken partition, scaled CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 32, 'Ny': 32, 'Np': 1000,\n         'seed': 99, 'charge_dist': ('fixed', 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.01}\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Unpack parameters\n        shape = params['shape']\n        Lx, Ly = params['Lx'], params['Ly']\n        Nx, Ny = params['Nx'], params['Ny']\n        Np = params['Np']\n        seed = params['seed']\n        charge_dist = params['charge_dist']\n        pos_dist = params['pos_dist']\n        alpha = params['alpha']\n\n        hx, hy = Lx / Nx, Ly / Ny\n        \n        # Handle zero particle case\n        if Np == 0:\n            results.append(0.0)\n            continue\n\n        rng = np.random.default_rng(seed)\n\n        # Generate particle charges\n        if charge_dist[0] == 'normal':\n            mean, std_dev = charge_dist[1], charge_dist[2]\n            charges = rng.normal(mean, std_dev, Np)\n        elif charge_dist[0] == 'fixed':\n            charges = np.full(Np, charge_dist[1], dtype=np.float64)\n        \n        q_total_particles = np.sum(charges)\n\n        # Generate particle positions\n        if pos_dist == 'uniform':\n            positions = rng.uniform(low=[0.0, 0.0], high=[Lx, Ly], size=(Np, 2))\n        elif pos_dist[0] == 'clustered':\n            epsilon = pos_dist[1]\n            # In Test 2, use the same seed for reproducibility of positions\n            pos_rng = np.random.default_rng(seed) if shape == 'NGP' else rng\n            positions = pos_rng.uniform(low=[Lx - 2 * epsilon, Ly - 2 * epsilon],\n                                        high=[Lx - epsilon, Ly - epsilon],\n                                        size=(Np, 2))\n\n        # Initialize charge density grid\n        rho_grid = np.zeros((Nx, Ny), dtype=np.float64)\n\n        # Deposit charges\n        for i in range(Np):\n            q_i = charges[i]\n            x_i, y_i = positions[i]\n            \n            x_norm = x_i / hx\n            y_norm = y_i / hy\n            \n            # 1D weights and indices calculation\n            if shape == 'NGP':\n                # x-dimension\n                jx = int(np.floor(x_norm + 0.5))\n                wx = [1.0]\n                jx_indices = [jx]\n                \n                # y-dimension\n                ky = int(np.floor(y_norm + 0.5))\n                wy = [1.0]\n                ky_indices = [ky]\n\n            elif shape == 'CIC':\n                # x-dimension\n                jx0 = int(np.floor(x_norm))\n                dx = x_norm - jx0\n                wx = [alpha * (1.0 - dx), alpha * dx]\n                jx_indices = [jx0, jx0 + 1]\n\n                # y-dimension\n                ky0 = int(np.floor(y_norm))\n                dy = y_norm - ky0\n                wy = [alpha * (1.0 - dy), alpha * dy]\n                ky_indices = [ky0, ky0 + 1]\n                \n            elif shape == 'TSC':\n                # x-dimension\n                jxc = int(np.floor(x_norm + 0.5))\n                dx = x_norm - jxc\n                wx = [0.5 * (0.5 - dx)**2, 0.75 - dx**2, 0.5 * (0.5 + dx)**2]\n                jx_indices = [jxc - 1, jxc, jxc + 1]\n\n                # y-dimension\n                kyc = int(np.floor(y_norm + 0.5))\n                dy = y_norm - kyc\n                wy = [0.5 * (0.5 - dy)**2, 0.75 - dy**2, 0.5 * (0.5 + dy)**2]\n                ky_indices = [kyc - 1, kyc, kyc + 1]\n\n            # 2D deposition with periodic boundary conditions\n            for idx_x, j in enumerate(jx_indices):\n                for idx_y, k in enumerate(ky_indices):\n                    # Using scatter-add logic here\n                    # Indices must be wrapped\n                    j_wrapped = j % Nx\n                    k_wrapped = k % Ny\n                    weight_2d = wx[idx_x] * wy[idx_y]\n                    rho_grid[j_wrapped, k_wrapped] += q_i * weight_2d\n\n        # Correct units for rho_grid\n        rho_grid /= (hx * hy)\n        \n        # Calculate total grid charge\n        q_total_grid = np.sum(rho_grid) * hx * hy\n        \n        discrepancy = np.abs(q_total_grid - q_total_particles)\n        results.append(discrepancy)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在 PIC 方法中，粒子间的相互作用力是通过网格来传递的，这个过程可能不完全满足牛顿第三定律，从而导致系统总动量不守恒。这个计算练习将让你直面这一数值伪影，通过量化不同阶数形函数（从最简单的 NGP 到更平滑的样条函数）对双粒子系统动量守恒的影响。通过这个实践，你将发现插值方案的平滑度与模拟物理的精确性之间的直接联系，这是开发高保真度代码的核心洞见。",
            "id": "4183324",
            "problem": "在一个一维静电周期性域中，两个粒子通过一个基于网格的场求解器相互作用，如同在粒子模拟（Particle-In-Cell, PIC）方法中一样。目标是量化在使用不同阶数的粒子形状函数时，粒子与网格之间的电荷分配和力插值所引起的虚假总动量误差，并展示随着形状函数阶数的增加，该动量误差会减小。计算在无量纲单位下进行：域长度 $L=1$，真空介电常数 $\\epsilon_0=1$，粒子电荷 $q_1=+1$，$q_2=-1$。无需进行物理单位转换。\n\n基本原理和定义：\n- 静电场满足一维空间中的泊松方程 $\\partial_x E(x) = \\rho(x)/\\epsilon_0$ 和 $E(x) = -\\partial_x \\phi(x)$，在 $[0,L)$ 上具有周期性边界条件。\n- 离散网格由 $N_g$ 个均匀分布的网格节点组成，节点位置为 $x_j = j \\Delta x$（整数 $j \\in \\{0,1,\\dots,N_g-1\\}$），其中 $\\Delta x = L/N_g$。\n- 基于网格的场求解器通过使用一个阶数为 $m \\in \\{0,1,2,3\\}$ 的粒子形状函数，将粒子电荷分配到附近节点来构建网格电荷密度 $\\rho_j$，并在傅里叶空间中求解泊松方程以获得网格电场 $E_j$。然后使用相同阶数 $m$ 的形状函数将 $E_j$ 插值回粒子位置，从而获得粒子位置处的场。\n\n计算方法要求：\n- 使用标准的均匀离散傅里叶变换，以谱方法求解具有周期性边界条件的泊松方程。在傅里叶空间中，通过将零波数模式设置为零来强制零平均势。通过谱微分计算电场。\n- 对电荷分配（粒子到网格）和力插值（网格到粒子）使用相同的粒子形状函数阶数 $m$。所考虑的阶数为 $m=0$（最近网格点法）、$m=1$（云中元法）、$m=2$（三角形云法）和 $m=3$（分段三次样条）。每个形状函数都是紧支撑、归一化的一维形状，其支撑范围覆盖 $m+1$ 个网格单元。\n- 对电荷沉积和插值均实现周期性边界条件。\n\n诊断量定义：\n- 设 $F_i = q_i E(x_i)$ 为粒子 $i \\in \\{1,2\\}$ 在其位置 $x_i$ 处受到的来自插值电场的力。在一个净电荷为零的周期性域中，对于连续、精确的双体静电相互作用，Newton 第三定律意味着总内力 $\\sum_i F_i$ 在任何时候都精确为零，因此总动量守恒。\n- 将单个构型的无量纲虚假动量误差定义为\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta},\n$$\n其中 $\\delta$ 是一个小的正常数正则化常量，以避免在病态情况下出现除以零的情况，例如 $\\delta = 10^{-16}$。\n\n任务：\n- 对每个指定的测试案例，使用上述方法计算无量纲虚假动量误差 $\\varepsilon_m$。\n- 所有计算必须按规定使用无量纲单位进行。\n\n测试套件：\n为以下六个测试案例计算 $\\varepsilon_m$。每个测试案例都是一个元组 $(N_g, m, x_1, x_2)$，其中 $L=1$, $q_1=+1$, $q_2=-1$，并且位置在周期性区间 $[0,1)$ 内。\n1. $(N_g=\\;32, m=\\;0, x_1=\\;0.23, x_2=\\;0.77)$\n2. $(N_g=\\;32, m=\\;1, x_1=\\;0.23, x_2=\\;0.77)$\n3. $(N_g=\\;32, m=\\;2, x_1=\\;0.23, x_2=\\;0.77)$\n4. $(N_g=\\;32, m=\\;3, x_1=\\;0.23, x_2=\\;0.77)$\n5. $(N_g=\\;32, m=\\;3, x_1=\\;0.98, x_2=\\;0.12)$\n6. $(N_g=\\;64, m=\\;3, x_1=\\;0.401, x_2=\\;0.409)$\n\n结果应揭示的预期行为：\n- 对于固定的网格分辨率 $N_g=\\;32$ 和固定的粒子位置 $(x_1,x_2)=(0.23,0.77)$，当 $m=\\;0,1,2,3$ 时，误差序列应呈下降趋势，表明使用更高阶的形状函数改善了离散动量守恒。\n- 如果电荷沉积和插值中的周期性包裹被正确实现，粒子靠近周期性边界 $(x_1=\\;0.98, x_2=\\;0.12)$ 的构型对于高阶形状函数也应产生较小的误差。\n- 在 $N_g=\\;64$ 和 $m=\\;3$ 时的近粒子对构型应测试当 $|x_2-x_1|$ 很小时的鲁棒性。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含六个结果，格式为方括号内用逗号分隔的列表，例如\n`[r_1,r_2,r_3,r_4,r_5,r_6]`，\n其中每个 $r_k$ 是第 $k$ 个测试案例的 $\\varepsilon_m$ 的浮点数值，以无量纲单位表示。",
            "solution": "用户提供的问题是有效的。这是一个适定、有科学依据的计算物理问题，旨在研究粒子模拟（Particle-In-Cell, PIC）方法的一个基本数值特性。所有需要的数据和定义都已提供，任务是客观且可验证的。\n\n该问题要求计算一个含两个粒子的一维静电PIC模拟中的虚假总动量误差。这个误差的产生是因为计算网格的颗粒性破坏了物理定律的连续平移对称性。在连续系统中，两个粒子之间的相互作用力 $\\vec{F}_{12}$ 与力 $\\vec{F}_{21}$ 大小相等、方向相反，即 $\\vec{F}_{12} + \\vec{F}_{21} = 0$，这就是 Newton 第三定律。这保证了双粒子系统的总动量守恒。\n\n在PIC模拟中，粒子不直接相互作用。相反，它们通过网格离散化的场相互作用。该过程包括三个步骤：\n$1$. **电荷沉积**：每个粒子的电荷被“涂抹”到附近的几个网格节点上。\n$2$. **场求解**：根据沉积的电荷密度计算网格节点上的静电场。\n$3$. **力插值**：将场从网格节点插值回粒子位置以计算作用力。\n\n这种由网格介导的相互作用通常不满足针对粒子的 Newton 第三定律。粒子1受到的力 $F_1$ 来自于粒子2的电荷在网格上表示所产生的场，反之亦然。由于离散化，力 $F_1$ 并不与 $F_2$ 精确地大小相等、方向相反，导致总力不为零 $F_1 + F_2 \\neq 0$，从而违反了动量守恒。这种违反的程度由误差度量 $\\varepsilon_m$ 量化，它关键地取决于用于电荷沉积和力插值的函数的光滑度。这些函数被称为粒子形状函数。\n\n更高阶的形状函数在网格上提供了更光滑的粒子表示，从而减少了力对粒子相对于网格节点位置的非物理性依赖。这带来了更好的守恒性质。该问题要求通过计算阶数递增 $m \\in \\{0, 1, 2, 3\\}$ 的形状函数的 $\\varepsilon_m$ 来展示这一原理。\n\n对于一个给定的测试案例 $(N_g, m, x_1, x_2)$，计算误差 $\\varepsilon_m$ 的计算步骤如下：\n\n**1. 系统设置**\n模拟域的长度为 $L=1$，具有周期性边界条件。网格由 $N_g$ 个节点组成，位置为 $x_j = j \\Delta x$，其中 $j \\in \\{0, 1, \\dots, N_g-1\\}$，网格间距为 $\\Delta x = L/N_g = 1/N_g$。存在两个粒子，电荷分别为 $q_1=+1$ 和 $q_2=-1$，位置分别为 $x_1$ 和 $x_2$。真空介电常数为 $\\epsilon_0=1$。\n\n**2. 粒子形状函数**\n粒子与网格之间的相互作用由一个阶数为 $p=m+1$ 的基样条（B-spline）形状函数 $S_m(u)$ 介导，其中 $u=(x_p - x_j)/\\Delta x$ 是从位于 $x_p$ 的粒子到位于 $x_j$ 的网格节点的归一化距离。函数 $S_m(u)$ 在一个有限的支撑域上非零。我们为形状函数阶数 $m=0, 1, 2, 3$ 实现B样条 $B_{m+1}(u)$：\n-   阶数 $m=0$ (NGP, $B_1$)：当 $|u| \\le 1/2$ 时 $S_0(u) = 1$，否则为 $0$。\n-   阶数 $m=1$ (CIC, $B_2$)：当 $|u| \\le 1$ 时 $S_1(u) = 1 - |u|$，否则为 $0$。\n-   阶数 $m=2$ (TSC, $B_3$)：$S_2(u) = \\begin{cases} 3/4 - u^2  \\text{若 } |u| \\le 1/2 \\\\ 1/2(3/2 - |u|)^2  \\text{若 } 1/2  |u| \\le 3/2 \\\\ 0  \\text{其他情况} \\end{cases}$。\n-   阶数 $m=3$ (PCS, $B_4$)：$S_3(u) = \\begin{cases} 1/6(3|u|^3 - 6u^2 + 4)  \\text{若 } |u| \\le 1 \\\\ 1/6(2 - |u|)^3  \\text{若 } 1  |u| \\le 2 \\\\ 0  \\text{其他情况} \\end{cases}$。\n\n**3. 电荷沉积**\n用于电荷密度的网格数组 $\\rho_j$ 初始化为零。对于每个电荷为 $q_p$、位置为 $x_p$ 的粒子 $p \\in \\{1, 2\\}$，我们将其电荷沉积到网格上。\n首先，我们找到所有位于以 $x_p$ 为中心的形状函数支撑域内的网格节点 $j$。对每个这样的节点，我们计算一个权重 $W_{p,j} = S_m((x_p/\\Delta x) - j)$。节点 $j$ 处的电荷密度通过加上粒子的贡献来更新：$\\rho_j \\leftarrow \\rho_j + q_p W_{p,j} / \\Delta x$。除以单元体积 $\\Delta x$ 将沉积的电荷正确地缩放为电荷密度。节点索引 $j$ 进行周期性处理，即对 $N_g$ 取模。\n\n**4. 谱方法场求解**\n一维泊松方程为 $\\partial_x E = \\rho(x)/\\epsilon_0$。我们使用离散傅里叶变换（DFT）在网格上求解该方程。\n-   首先，我们计算网格电荷密度的DFT：$\\hat{\\rho}_k = \\mathcal{F}\\{\\rho_j\\}$。\n-   在傅里叶空间中，空间导数 $\\partial_x$ 变为乘以 $i k$，其中 $k$ 是波数。方程变为 $i k \\hat{E}_k = \\hat{\\rho}_k/\\epsilon_0$。\n-   与DFT对应的波数由 $k_n = 2\\pi n / L$ 给出，其中 $n \\in \\{-N_g/2, \\dots, N_g/2-1\\}$。\n-   那么傅里叶空间中的网格电场为 $\\hat{E}_k = \\frac{\\hat{\\rho}_k}{i k \\epsilon_0} = -i \\frac{\\hat{\\rho}_k}{k \\epsilon_0}$（对于 $k \\ne 0$）。\n-   对于 $k=0$ 模式（直流分量），净电荷 $\\sum q_p=0$ 确保了 $\\hat{\\rho}_{k=0}=0$。$\\hat{E}_{k=0}$ 的表达式是不确定的。我们设置 $\\hat{E}_{k=0}=0$，这对应于零平均电场，与周期性边界条件和零净电荷一致。这也强制执行了零平均势条件。\n-   最后，通过计算 $\\hat{E}_k$ 的逆DFT得到网格上的电场 $E_j$：$E_j = \\mathcal{F}^{-1}\\{\\hat{E}_k\\}$。\n\n**5. 力插值**\n通过使用相同的形状函数 $S_m$ 插值网格电场 $E_j$，来找到每个粒子位置处的电场 $E(x_p)$。插值场是一个加权和：$E(x_p) = \\sum_j E_j W_{p,j}$，其中的权重 $W_{p,j}$ 与粒子 $p$ 的电荷沉积步骤中使用的权重相同。沉积和插值之间的这种对称性对于动量守恒性质至关重要。那么每个粒子受到的力为 $F_p = q_p E(x_p)$。\n\n**6. 误差计算**\n计算出力 $F_1$ 和 $F_2$ 后，使用提供的公式计算无量纲虚假动量误差：\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta}\n$$\n正则化常数为 $\\delta=10^{-16}$。对六个测试案例中的每一个重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef b_spline(u_abs, m):\n    \"\"\"\n    Computes the value of the B-spline of order m+1 (degree m) at a given\n    absolute normalized distance u_abs = |u|.\n    These are the standard PIC particle shape functions Sm.\n    \"\"\"\n    if m == 0:  # NGP, B-spline order 1\n        return 1.0 if u_abs = 0.5 else 0.0\n    elif m == 1:  # CIC, B-spline order 2\n        return 1.0 - u_abs if u_abs = 1.0 else 0.0\n    elif m == 2:  # TSC, B-spline order 3\n        if u_abs = 0.5:\n            return 0.75 - u_abs**2\n        elif u_abs = 1.5:\n            return 0.5 * (1.5 - u_abs)**2\n        else:\n            return 0.0\n    elif m == 3:  # PCS, B-spline order 4\n        if u_abs = 1.0:\n            return (1.0/6.0) * (4.0 - 6.0*u_abs**2 + 3.0*u_abs**3)\n        elif u_abs = 2.0:\n            return (1.0/6.0) * (2.0 - u_abs)**3\n        else:\n            return 0.0\n    else:\n        raise ValueError(\"Shape order m must be 0, 1, 2, or 3.\")\n\ndef get_weights(x_p, m, Ng, dx):\n    \"\"\"\n    Calculates the weights and indices for depositing charge or interpolating fields.\n    \"\"\"\n    u_p = x_p / dx\n    support_half_width = (m + 1) / 2.0\n    \n    j_min = int(np.ceil(u_p - support_half_width))\n    j_max = int(np.floor(u_p + support_half_width))\n    \n    indices = []\n    weights = []\n    \n    for j in range(j_min, j_max + 1):\n        u_abs = abs(u_p - j)\n        weight = b_spline(u_abs, m)\n        if weight > 0:\n            indices.append(j % Ng)\n            weights.append(weight)\n            \n    return np.array(indices), np.array(weights)\n\ndef calculate_error(Ng, m, x1, x2):\n    \"\"\"\n    Performs the PIC-style calculation to find the momentum conservation error.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    q1, q2 = 1.0, -1.0\n    epsilon_0 = 1.0\n    delta = 1e-16\n    dx = L / Ng\n\n    # 1. Charge Deposition (Particle-To-Grid)\n    rho_grid = np.zeros(Ng)\n    particles = [(q1, x1), (q2, x2)]\n    \n    # Store weights for later use in interpolation\n    p1_indices, p1_weights = get_weights(particles[0][1], m, Ng, dx)\n    p2_indices, p2_weights = get_weights(particles[1][1], m, Ng, dx)\n\n    # Deposit charge for particle 1\n    np.add.at(rho_grid, p1_indices, particles[0][0] * p1_weights / dx)\n    \n    # Deposit charge for particle 2\n    np.add.at(rho_grid, p2_indices, particles[1][0] * p2_weights / dx)\n\n    # 2. Field Solve (Grid)\n    # DFT of charge density\n    rho_hat = np.fft.fft(rho_grid)\n    \n    # Wavenumbers\n    k = 2 * np.pi * np.fft.fftfreq(Ng, d=dx)\n    \n    # Solve for E-field in Fourier space: E_hat = -i * rho_hat / (epsilon_0 * k)\n    E_hat = np.zeros_like(rho_hat, dtype=complex)\n    nonzero_k_mask = k != 0\n    E_hat[nonzero_k_mask] = -1j * rho_hat[nonzero_k_mask] / (epsilon_0 * k[nonzero_k_mask])\n    \n    # Inverse DFT to get E-field on grid\n    E_grid = np.real(np.fft.ifft(E_hat))\n\n    # 3. Force Interpolation (Grid-To-Particle)\n    # Interpolate E-field at particle 1 and calculate force\n    E1 = np.sum(E_grid[p1_indices] * p1_weights)\n    F1 = q1 * E1\n    \n    # Interpolate E-field at particle 2 and calculate force\n    E2 = np.sum(E_grid[p2_indices] * p2_weights)\n    F2 = q2 * E2\n\n    # 4. Calculate Spurious Momentum Error\n    error = np.abs(F1 + F2) / (np.abs(F1) + np.abs(F2) + delta)\n    \n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 0, 0.23, 0.77),\n        (32, 1, 0.23, 0.77),\n        (32, 2, 0.23, 0.77),\n        (32, 3, 0.23, 0.77),\n        (32, 3, 0.98, 0.12),\n        (64, 3, 0.401, 0.409),\n    ]\n\n    results = []\n    for case in test_cases:\n        Ng, m, x1, x2 = case\n        result = calculate_error(Ng, m, x1, x2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}