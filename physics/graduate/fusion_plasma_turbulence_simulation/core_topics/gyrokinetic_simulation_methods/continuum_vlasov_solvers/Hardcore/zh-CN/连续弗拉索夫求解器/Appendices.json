{
    "hands_on_practices": [
        {
            "introduction": "在连续介质（欧拉）Vlasov求解器中，一个核心的挑战是确保数值解始终遵守分布函数$f$的物理约束，即非负性（$f \\ge 0$）。尽管高阶插值方案（如三次样条或Catmull-Rom插值）在半拉格朗日方法中因其高精度而备受青睐，但它们在陡峭梯度附近容易产生非物理的负值（下冲）。本实践将指导您构建一个测试问题来挑战正定性，并实现一个“正定性保持限制器”，它能在保持高阶方案准确性的同时，智能地修正负值，从而确保解的物理真实性。",
            "id": "4184958",
            "problem": "考虑一个物种在均匀电场作用下具有恒定加速度的一维速度空间形式的 Vlasov 方程，在空间均匀的设定下，该方程简化为速度空间中的线性平流方程，即 $ \\partial_t f + a \\, \\partial_v f = 0 $，其中 $ f(v,t) $ 是分布函数，$ v $ 是速度变量，$ a $ 是 $ v $ 空间中的恒定平流速度。在连续介质（欧拉）框架下，沿特征线的半拉格朗日更新被广泛用于避免严格的时间步长约束，但在特征线追踪过程中，当 $ f(v,t) $ 具有陡峭梯度或间断点时，高阶多项式插值可能会引入负值下冲。这种对非负性的违反在分布函数中是非物理的，必须通过限制器来控制，这些限制器在保持正性的同时力求保留精度。\n\n您的任务是构建一个科学合理的测试，用于在强 $ v $ 空间平流条件下挑战正性，并以算法方式评估一个保正限制器。该测试定义在一个周期性速度域 $ v \\in [v_{\\min}, v_{\\max}) $ 上，其中 $ v_{\\min} = -6 $，$ v_{\\max} = 6 $，并由一个包含 $ N = 256 $ 个点的均匀网格解析，网格间距为 $ \\Delta v = (v_{\\max} - v_{\\min})/N $。初始条件是一个复合的、严格非负的分布，旨在具有陡峭特征：\n- 一个振幅为 $ A_1 = 1 $、中心在 $ v_c = 0 $、半宽为 $ w = 1 $ 的方帽分量，即当 $ |v - v_c| \\le w $ 时 $ f_{\\text{hat}}(v) = A_1 $，否则 $ f_{\\text{hat}}(v) = 0 $。\n- 一个窄高斯凸起 $ f_{\\text{bump}}(v) = A_2 \\exp\\!\\big(-\\tfrac{(v - v_b)^2}{2 \\sigma_b^2}\\big) $，其中 $ A_2 = 0.5 $，$ v_b = 2.7 $，$ \\sigma_b = 0.06 $。\n完整的初始条件为 $ f_0(v) = f_{\\text{hat}}(v) + f_{\\text{bump}}(v) $，该函数除了在 $ v = \\pm 1 $ 的方帽边缘处外是连续的。\n\n使用半拉格朗日特征线更新来计算单个时间步 $ \\Delta t $：一步之后的精确解是平移后的函数 $ f(v, \\Delta t) = f_0(v - a \\Delta t) $。通过将 $ f^n $ 插值到特征足，实现两种将 $ f_0 $ 映射到网格节点上的 $ f^{n+1} $ 的数值更新变体：\n- 用于 $ f_{\\text{HO}}(v_i) $ 的高阶三次（四点）Catmull–Rom 插值，它在陡峭特征处可能会上冲并产生 $ f_{\\text{HO}}(v_i)  0 $ 的情况。\n- 用于 $ f_{\\text{LO}}(v_i) $ 的低阶线性插值，它在相邻网格值之间是单调的，并且只要两个端点都非负，就能保持非负性。\n\n设计并评估一个保正限制器，该限制器构建为高阶和低阶更新之间的凸组合，以确保 $ f(v_i) \\ge \\varepsilon $（其中 $ \\varepsilon = 10^{-14} $），同时与 $ f_{\\text{HO}} $ 的偏差最小。也就是说，对于每个网格点，仅在需要强制非负性时，在 $ [0,1] $ 中选择一个凸权重来混合 $ f_{\\text{HO}} $ 和 $ f_{\\text{LO}} $。评估必须量化：\n- 最小值 $ \\min_i f^{n+1}_i $，\n- 绝对质量误差 $ \\big|\\sum_i f^{n+1}_i \\Delta v - \\sum_i f^n_i \\Delta v \\big| $，\n- 相对 $ L^1 $ 误差 $ \\frac{\\sum_i | f^{n+1}_i - f_{\\text{exact}}(v_i) | \\Delta v}{\\sum_i | f_{\\text{exact}}(v_i) | \\Delta v} $，\n其中 $ f_{\\text{exact}}(v) = f_0(v - a \\Delta t) $。所有量均为无量纲。\n\n在单个程序中实现上述内容，对以下测试套件中的每个测试用例执行一个时间步：\n- 用例 $ 1 $ (接近稳定性边界的理想情况)：$ a = 5 $，选择 $ \\Delta t $ 使特征位移等于 $ 0.9 \\, \\Delta v $，即 $ a \\Delta t = 0.9 \\, \\Delta v $。\n- 用例 $ 2 $ (跨越多个单元的强平流)：$ a = 5 $，选择 $ \\Delta t $ 使位移等于 $ 3.7 \\, \\Delta v $，即 $ a \\Delta t = 3.7 \\, \\Delta v $。\n- 用例 $ 3 $ (具有显著回卷的极强平流)：$ a = 17 $，选择 $ \\Delta t $ 使位移等于 $ 15.3 \\, \\Delta v $，即 $ a \\Delta t = 15.3 \\, \\Delta v $。\n\n对于每个用例，计算上述三个指标，分别用于无限制的高阶更新和保正的更新。您的程序应生成单行输出，其中包含所有聚合结果，形式为方括号括起来的逗号分隔列表，顺序如下：\n$ [ \\min_{\\text{no}}, \\min_{\\text{lim}}, \\text{massErr}_{\\text{no}}, \\text{massErr}_{\\text{lim}}, L^1_{\\text{no}}, L^1_{\\text{lim}}, \\ldots ] $\n为三个用例顺序串联的结果。所有输出必须是无单位的浮点数，使用上面定义的无量纲归一化。",
            "solution": "问题陈述已经过严格审查，并被确定为**有效**。它提出了一个适定的、具有科学依据的数值实验，与计算等离子体物理领域直接相关，特别是关于连续介质 Vlasov 求解器。所有参数、方法和评估标准都定义得足够精确，从而能够得出唯一且可验证的解。\n\n问题的核心是求解速度空间中的一维线性平流方程，\n$$\n\\partial_t f + a \\, \\partial_v f = 0\n$$\n其中 $f(v, t)$ 是粒子分布函数，$v$ 是速度，$t$ 是时间，$a$ 是恒定加速度。该方程描述了空间均匀等离子体在均匀电场下的演化。该域在速度上是周期性的，$v \\in [v_{\\min}, v_{\\max})$。\n\n此方程的精确解可以通过特征线法找到。特征曲线是 $(v,t)$ 平面中的线，由 $\\frac{dv}{dt} = a$ 定义，积分后得到 $v(t) = v_0 + at$。沿着这些特征线，分布函数是恒定的：$f(v(t), t) = f(v_0, 0)$。因此，在时间 $\\Delta t$ 的精确解是初始剖面 $f_0(v)$ 的简单刚性平移：\n$$\nf(v, \\Delta t) = f_0(v - a \\Delta t)\n$$\n\n数值任务涉及在均匀网格 $v_i = v_{\\min} + i \\Delta v$（其中 $i=0, \\dots, N-1$ 且 $\\Delta v = (v_{\\max} - v_{\\min})/N$）上实现一个半拉格朗日方案。在每个时间步，通过从每个网格点 $v_i$ 沿特征线向后追溯一个时间步 $\\Delta t$ 来计算网格上的新值 $f_i^{n+1}$。新值是前一时刻的分布函数 $f^n$ 在特征足 $v_i - a \\Delta t$ 处的值。\n$$\nf_i^{n+1} = f^n(v_i - a \\Delta t)\n$$\n由于特征足 $v_p = v_i - a \\Delta t$ 通常不与网格点重合，其值必须通过对已知的网格值 $\\{f_j^n\\}$ 进行插值来获得。周期性边界条件通过将任何落在 $[v_{\\min}, v_{\\max})$ 之外的特征足的坐标映射回域内来处理。\n\n我们将实现并比较两种插值方案：\n1.  **低阶（LO）线性插值**：对于网格节点 $v_j$ 和 $v_{j+1}$ 之间的一个点 $v_p$，其值为加权平均：$f_{\\text{LO}}(v_p) = (1-\\alpha)f_j + \\alpha f_{j+1}$，其中 $\\alpha = (v_p - v_j)/\\Delta v$。如果原始数据点 $f_j$ 和 $f_{j+1}$ 是非负的，那么由于 $\\alpha \\in [0,1]$，该方案固有地保持正性。\n2.  **高阶（HO）Catmull–Rom 插值**：这是一种四点三次插值方案，提供更高的精度，但不能保证单调性。它可能在陡峭梯度附近引入伪振荡（上冲和下冲），可能导致 $f$ 出现非物理的负值。对于位于 $v_j$ 和 $v_{j+1}$ 之间、小数距离为 $\\alpha$ 的点 $v_p$，插值由以下多项式给出：\n    $$\n    f_{\\text{HO}}(v_p) = c_3 \\alpha^3 + c_2 \\alpha^2 + c_1 \\alpha + c_0\n    $$\n    其中系数是四个网格值 $f_{j-1}, f_j, f_{j+1}, f_{j+2}$ 的函数：\n    $c_0 = f_j$，$c_1 = \\frac{1}{2}(-f_{j-1} + f_{j+1})$，$c_2 = f_{j-1} - \\frac{5}{2}f_j + 2f_{j+1} - \\frac{1}{2}f_{j+2}$，以及 $c_3 = -\\frac{1}{2}f_{j-1} + \\frac{3}{2}f_j - \\frac{3}{2}f_{j+1} + \\frac{1}{2}f_{j+2}$。\n\n为了纠正高阶方案对非负性的违反，设计了一个保正限制器。该限制器将新解 $f_{\\text{lim}}$ 构建为高阶解 $f_{\\text{HO}}$ 和低阶解 $f_{\\text{LO}}$ 的凸组合。目标是在每个网格点 $v_i$ 处强制 $f_{\\text{lim}, i} \\ge \\varepsilon$，其中 $\\varepsilon = 10^{-14}$ 是一个小的正数下限，同时与更精确的 $f_{\\text{HO}, i}$ 偏差最小。\n\n限制器在每个网格点 $v_i$ 的算法逻辑如下：\n1.  计算 $f_{\\text{HO}, i}$ 和 $f_{\\text{LO}, i}$。\n2.  如果 $f_{\\text{HO}, i} \\ge \\varepsilon$，则无需修正。我们保留高阶结果：$f_{\\text{lim}, i} = f_{\\text{HO}, i}$。\n3.  如果 $f_{\\text{HO}, i}  \\varepsilon$，则需要修正。我们必须在 $f_{\\text{LO}, i}$ 和 $f_{\\text{HO}, i}$ 之间的线段上找到一个值，该值满足正性约束且最接近 $f_{\\text{HO}, i}$。\n    - 如果 $f_{\\text{LO}, i} \\ge \\varepsilon$，则存在一系列有效的凸组合。满足约束的最小修正将限制值精确设置为下限：$f_{\\text{lim}, i} = \\varepsilon$。这对应于找到所需的 $f_{\\text{LO}}$ 的最小混合量，以将负的 $f_{\\text{HO}}$ 值提升至 $\\varepsilon$。\n    - 如果 $f_{\\text{LO}, i}  \\varepsilon$，那么即使是“安全”的低阶方案也未能达到阈值。在这种情况下，$f_{\\text{HO}, i}$ 和 $f_{\\text{LO}, i}$ 的任何凸组合都不能大于或等于 $\\varepsilon$（假设 $f_{\\text{HO}, i} \\le f_{\\text{LO}, i}$ 或者 $f_{HO}$ 代表一个下冲）。最合理的操作是接受单调的低阶结果作为备用方案：$f_{\\text{lim}, i} = f_{\\text{LO}, i}$。\n\n此过程定义了最终的限制解 $f_{\\text{lim}}$。无限制的高阶方案和限制方案的性能将使用三个指标进行评估，这些指标是在从初始条件 $f_0(v)$ 开始执行单个时间步后计算的：\n1.  **最小值**：$\\min_i f_i^{n+1}$。这直接测试保正属性。\n2.  **绝对质量误差**：$|\\sum_i f_i^{n+1} \\Delta v - \\sum_i f_i^n \\Delta v|$。精确平流是保质的（$\\int f dv$），因此该指标量化了数值方案的守恒性。\n3.  **相对 $L^1$ 误差**：$\\frac{\\sum_i |f_i^{n+1} - f_{\\text{exact}}(v_i)| \\Delta v}{\\sum_i |f_{\\text{exact}}(v_i)| \\Delta v}$。这衡量了数值解相对于已知精确解 $f_{\\text{exact}}(v) = f_0(v - a \\Delta t)$ 的精度。\n\n以下程序为三个指定的测试用例实现了这整个过程，计算并报告每个用例的六个要求量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a positivity-preserving limiter for a semi-Lagrangian\n    Vlasov solver in 1D velocity space.\n    \"\"\"\n\n    # --- Problem Constants and Grid Setup ---\n    V_MIN = -6.0\n    V_MAX = 6.0\n    N = 256\n    EPSILON = 1e-14\n    DV = (V_MAX - V_MIN) / N\n    V_GRID = np.linspace(V_MIN, V_MAX, N, endpoint=False)\n\n    def initial_condition(v: np.ndarray) - np.ndarray:\n        \"\"\"Computes the initial distribution function f_0(v).\"\"\"\n        # Top-hat component\n        A1 = 1.0\n        vc = 0.0\n        w = 1.0\n        f_hat = np.where(np.abs(v - vc) = w, A1, 0.0)\n\n        # Gaussian bump component\n        A2 = 0.5\n        vb = 2.7\n        sigma_b = 0.06\n        f_bump = A2 * np.exp(-(v - vb)**2 / (2 * sigma_b**2))\n\n        return f_hat + f_bump\n\n    def linear_interp_advect(f_n: np.ndarray, shift_val: float) - np.ndarray:\n        \"\"\"Advects f_n using semi-Lagrangian scheme with linear interpolation.\"\"\"\n        feet_v = V_GRID - shift_val\n        # Normalize coordinates to grid index units and handle periodicity\n        feet_s = ((feet_v - V_MIN) / DV) % N\n        \n        j0 = np.floor(feet_s).astype(int)\n        alpha = feet_s - j0\n        j1 = (j0 + 1) % N\n        \n        f_next = (1.0 - alpha) * f_n[j0] + alpha * f_n[j1]\n        return f_next\n\n    def catmull_rom_interp_advect(f_n: np.ndarray, shift_val: float) - np.ndarray:\n        \"\"\"Advects f_n using semi-Lagrangian scheme with Catmull-Rom interpolation.\"\"\"\n        feet_v = V_GRID - shift_val\n        # Normalize coordinates to grid index units and handle periodicity\n        feet_s = ((feet_v - V_MIN) / DV) % N\n\n        j1 = np.floor(feet_s).astype(int)\n        alpha = feet_s - j1\n\n        # Get the 4 required points with periodic boundaries\n        j0 = (j1 - 1 + N) % N\n        j2 = (j1 + 1) % N\n        j3 = (j1 + 2) % N\n\n        p0, p1, p2, p3 = f_n[j0], f_n[j1], f_n[j2], f_n[j3]\n\n        # Catmull-Rom polynomial evaluation\n        alpha2 = alpha * alpha\n        alpha3 = alpha2 * alpha\n        \n        c0 = p1\n        c1 = 0.5 * (-p0 + p2)\n        c2 = p0 - 2.5 * p1 + 2.0 * p2 - 0.5 * p3\n        c3 = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3\n        \n        f_next = c3*alpha3 + c2*alpha2 + c1*alpha + c0\n        return f_next\n        \n    def apply_positivity_limiter(f_ho: np.ndarray, f_lo: np.ndarray) - np.ndarray:\n        \"\"\"Applies a positivity-preserving limiter to the high-order solution.\"\"\"\n        f_lim = np.copy(f_ho)\n        \n        # Identify points where the high-order solution violates positivity\n        needs_limiting = f_ho  EPSILON\n        \n        if np.any(needs_limiting):\n            # For points needing a fix, check the low-order solution\n            f_lo_at_limited_pts = f_lo[needs_limiting]\n            \n            # If f_lo is also below threshold, fallback to f_lo.\n            # Otherwise, blend just enough to reach the epsilon floor.\n            limiter_values = np.where(f_lo_at_limited_pts  EPSILON, f_lo_at_limited_pts, EPSILON)\n            f_lim[needs_limiting] = limiter_values\n\n        return f_lim\n\n    # --- Test Case Execution ---\n    test_cases = [\n        (5.0, 0.9),    # Case 1\n        (5.0, 3.7),    # Case 2\n        (17.0, 15.3),  # Case 3\n    ]\n\n    results = []\n\n    # Initial condition and its mass\n    f0 = initial_condition(V_GRID)\n    mass0 = np.sum(f0) * DV\n\n    for a, shift_in_dv in test_cases:\n        shift_val = shift_in_dv * DV\n\n        # Calculate exact solution at t=dt for error comparison\n        f_exact = initial_condition(V_GRID - shift_val)\n        l1_norm_exact = np.sum(np.abs(f_exact)) * DV\n        # Prevent division by zero if f_exact is identically zero\n        if l1_norm_exact == 0:\n            l1_norm_exact = 1.0\n\n        # 1. High-order (unlimited) solution\n        f_ho = catmull_rom_interp_advect(f0, shift_val)\n\n        # 2. Low-order solution (for the limiter)\n        f_lo = linear_interp_advect(f0, shift_val)\n\n        # 3. Limited solution\n        f_lim = apply_positivity_limiter(f_ho, f_lo)\n        \n        # --- Metrics for High-Order (no limiter) Solution ---\n        min_ho = np.min(f_ho)\n        mass_ho = np.sum(f_ho) * DV\n        mass_err_ho = np.abs(mass_ho - mass0)\n        l1_err_ho = np.sum(np.abs(f_ho - f_exact)) * DV / l1_norm_exact\n\n        # --- Metrics for Limited Solution ---\n        min_lim = np.min(f_lim)\n        mass_lim = np.sum(f_lim) * DV\n        mass_err_lim = np.abs(mass_lim - mass0)\n        l1_err_lim = np.sum(np.abs(f_lim - f_exact)) * DV / l1_norm_exact\n        \n        results.extend([min_ho, min_lim, mass_err_ho, mass_err_lim, l1_err_ho, l1_err_lim])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{x:.12f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们将Vlasov方程与泊松方程耦合以包含自洽电场时，问题从线性平流演变为非线性动力学。在广泛使用的伪谱方法中，这种非线性项（例如$E \\frac{\\partial f}{\\partial v}$）的计算会引入一种称为“混淆”（aliasing）的数值伪影，可能导致高波数模式的非物理能量堆积，破坏解的稳定性和准确性。本实践将引导您构建一个Vlasov-Poisson模拟，用于隔离和评估混淆效应，并比较不同的滤波策略（如“三分之二规则”和指数滤波器）在抑制这些伪影方面的有效性。",
            "id": "4184892",
            "problem": "考虑无碰撞一维 Vlasov–Poisson 系统，其形式为无量纲，具有周期性空间域和足够大的速度区间，从而可以忽略边界效应。分布函数 $f(x,v,t)$ 的演化遵循\n$$\n\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} + E(x,t) \\frac{\\partial f}{\\partial v} = 0,\n$$\n电场 $E(x,t)$ 服从泊松方程\n$$\n\\frac{\\partial E}{\\partial x} = \\rho(x,t) - 1,\n$$\n其中电荷密度 $ \\rho(x,t) $ 由下式给出\n$$\n\\rho(x,t) = \\int_{-\\infty}^{\\infty} f(x,v,t) \\, dv,\n$$\n且背景密度归一化为 $1$。空间域为 $x \\in [0,2\\pi)$，采用周期性边界条件；速度域被截断为 $v \\in [-V,V]$，其中 $V$ 足够大，使得 $f(x,v,t)$ 在 $v=\\pm V$ 附近可以忽略不计。\n\n在一个连续介质 (Eulerian) Vlasov 求解器中，如果使用伪谱法在空间坐标上计算非线性项，那么物理空间中一个随空间变化的场与另一个随空间变化的量之间的逐点乘积，等效于它们傅里叶变换的卷积。当数值表示被截断为有限的傅里叶模集时，这种卷积会产生超出最大可分辨波数的傅里叶分量，这些分量会混叠回可分辨的频带内。这种混叠现象可能表现为高波数模式下非物理的能量堆积，并可能破坏不变量的守恒性，例如总质量\n$$\nM(t) = \\int_0^{2\\pi} \\int_{-V}^{V} f(x,v,t) \\, dv \\, dx,\n$$\n以及 $L^2$ 范数的平方\n$$\n\\|f(t)\\|_2^2 = \\int_0^{2\\pi} \\int_{-V}^{V} f(x,v,t)^2 \\, dv \\, dx.\n$$\n\n您的任务是构建一个数值测试，以分离出由混叠引起的空间谱能量堆积，并评估旨在减轻混叠同时保持守恒性和谱保真度的滤波策略。请遵循以下要求：\n\n1. 从上述 Vlasov–Poisson 方程推导计算方法，不使用任何外部简化公式。空间导数和卷积必须使用空间坐标 $x$ 上的快速傅里叶变换 (FFT) 处理，对线性项采用 Fourier–Galerkin 方法。非线性项 $E(x,t) \\frac{\\partial f}{\\partial v}$ 必须在物理空间中形成，并在适用时进行适当的谱处理以控制混叠。\n\n2. 将初始条件定义为速度上的 Maxwellian 分布，并带有小振幅空间调制：\n$$\nf(x,v,0) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{v^2}{2}\\right) \\left[ 1 + a \\cos(k_0 x) + b \\cos(k_1 x) \\right],\n$$\n其中 $a$ 和 $b$ 是无量纲小振幅。根据网格大小选择 $k_0$ 和 $k_1$，以在已分辨谱的高频部分激发相互作用。在连续介质极限下，Maxwellian 分布的振幅保证在 $t=0$ 时 $\\int f \\, dv = 1$ 达到机器精度。\n\n3. 使用傅里叶方法从 $ \\rho(x,t) = \\int f \\, dv $ 计算 $E(x,t)$：在空间傅里叶级数中，对于非零 $k$，设置 $E_k = -i \\rho_k / k$，对于 $k=0$，设置 $E_{k=0}=0$，其中 $k$ 表示傅里叶波数，$i$ 是虚数单位。然后变换回物理空间得到 $E(x,t)$。\n\n4. 使用源自 Vlasov 方程的显式方法对 $f$ 进行时间推进。您必须计算：\n- 空间导数 $\\frac{\\partial f}{\\partial x}$，使用 $x$ 上的 FFT。\n- 速度导数 $\\frac{\\partial f}{\\partial v}$，在截断区间上使用一致的有限差分格式，网格间距为 $\\Delta v$。\n\n5. 实现并比较以下三种处理混叠的策略：\n- 策略 A (无)：不进行反混叠处理。在物理空间中将 $E(x,t)$ 与 $\\frac{\\partial f}{\\partial v}$ 相乘，然后继续。\n- 策略 B (三分之二)：对两个因子和更新后的 $f$ 应用 $x$ 上的三分之二去混叠规则。具体来说，在形成乘积之前，将 $E(x,t)$ 和 $\\frac{\\partial f}{\\partial v}(x,v,t)$ 的空间傅里叶系数投影到频带 $|k| \\leq \\frac{2}{3} k_{\\max}$ 上，其中 $k_{\\max}$ 是最大可分辨波数。更新 $f$ 后，同样在 $x$ 上对 $f$ 进行投影以强制执行带宽限制。\n- 策略 C (指数)：对 $E(x,t)$、$\\frac{\\partial f}{\\partial v}(x,v,t)$ 的傅里叶系数以及更新后的 $f$ 应用一个 $x$ 上的平滑指数谱滤波器，形式为\n$$\n\\phi(k) = \\exp\\left( -\\alpha \\left( \\frac{|k|}{k_{\\max}} \\right)^p \\right),\n$$\n其中固定的正数 $\\alpha$ 和偶数整数 $p$ 仅强力衰减最高波数。\n\n6. 量化混叠引起的能量堆积和守恒误差。对于每种策略，在固定的时间步数内计算：\n- 最终时间 $T$ 时的相对质量误差 $(M(T)-M(0))/M(0)$。\n- 相对 $L^2$ 范数平方误差 $(\\|f(T)\\|_2^2 - \\|f(0)\\|_2^2)/\\|f(0)\\|_2^2$。\n- 已分辨波数的上四分位数区间内所含空间谱能量分数的改变，定义为\n$$\n\\Delta \\eta = \\eta(T) - \\eta(0), \\quad \\eta(t) = \\frac{\\sum_{|k| \\geq 0.75 k_{\\max}} \\left( \\int_{-V}^{V} | \\hat{f}(k,v,t) |^2 \\, dv \\right)}{\\sum_{|k| \\leq k_{\\max}} \\left( \\int_{-V}^{V} | \\hat{f}(k,v,t) |^2 \\, dv \\right)},\n$$\n其中 $\\hat{f}(k,v,t)$ 表示 $f(x,v,t)$ 的空间傅里叶变换。\n\n7. 在无量纲单位下进行计算。您必须指定并使用域长度 $L=2\\pi$，选择的 $V$ 要使 $f$ 在速度边界处可以忽略，选择的时间步长 $\\Delta t$ 要与线性平流项所隐含的平流 Courant–Friedrichs–Lewy (CFL) 条件一致。\n\n8. 为确保测试能分离出混叠效应，根据空间网格大小选择 $k_0$ 和 $k_1$，以便在每种情况下激发接近最大可分辨的模式。使用以下参数值的测试套件：\n- 情况 1 (通用)：$N_x=32$，$N_v=64$，$V=6$，$a=0.05$，$b=0.04$，策略 A (\"none\")，$\\Delta t$ 设置为 $0.1 \\Delta x / V$ 和 $0.1 \\Delta v / \\|E(x,0)\\|_{\\infty}$ 的最小值，步数 $N_t=300$。\n- 情况 2 (三分之二滤波)：与情况 1 相同，但使用策略 B (\"two_thirds\")。\n- 情况 3 (指数滤波)：与情况 1 相同，但使用策略 C (\"exp\")，参数为 $\\alpha=36$，$p=36$。\n- 情况 4 (粗糙边界)：$N_x=16$，$N_v=64$，$V=6$，$a=0.05$，$b=0.04$，策略 A (\"none\")，$\\Delta t$ 如上， $N_t=300$。\n- 情况 5 (高分辨率)：$N_x=128$，$N_v=64$，$V=6$，$a=0.05$，$b=0.04$，策略 A (\"none\")，$\\Delta t$ 如上，$N_t=300$。\n\n在每种情况下，定义 $k_0 = \\lfloor N_x / 4 \\rfloor$ 和 $k_1 = \\lfloor N_x / 3 \\rfloor$，以便初始调制将谱内容注入到高频带。\n\n您的程序应生成单行输出，其中包含所有五个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个包含三个浮点数的列表，形式为 $[m\\_err, l2\\_err, \\Delta \\eta]$，顺序如上所述。例如，包含两个假设用例的输出行将如下所示： \"[[0.0,0.0,0.0],[0.001,-0.002,0.05]]\"。",
            "solution": "该问题要求基于一维 Vlasov-Poisson 系统构建一个数值模拟，以研究伪谱欧拉求解器中的混叠效应。我们将比较三种处理非线性项的策略：不进行反混叠处理、三分之二去混叠规则以及平滑指数谱滤波器。\n\nVlasov-Poisson 系统由以下方程给出：\n$$\n\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} + E(x,t) \\frac{\\partial f}{\\partial v} = 0\n$$\n$$\n\\frac{\\partial E}{\\partial x} = \\rho(x,t) - 1, \\quad \\text{其中} \\quad \\rho(x,t) = \\int_{-\\infty}^{\\infty} f(x,v,t) \\, dv\n$$\n空间域为 $x \\in [0, 2\\pi)$，采用周期性边界条件，速度域被截断为 $v \\in [-V, V]$。\n\n我们首先对相空间进行离散化。空间域被离散为 $N_x$ 个网格点 $x_j = j \\Delta x$，$j = 0, \\dots, N_x-1$，网格间距为 $\\Delta x = 2\\pi/N_x$。速度域被离散为 $N_v$ 个网格点 $v_l = -V + l \\Delta v$，$l = 0, \\dots, N_v-1$，其中 $\\Delta v = 2V/(N_v-1)$（使用包含端点的网格），或采用类似约定。这里我们使用 `numpy.linspace`，其结果为 $\\Delta v = 2V / (N_v-1)$。分布函数在此网格上表示为 $f_{j,l}(t) \\approx f(x_j, v_l, t)$。\n\nVlasov 方程使用显式前向欧拉格式进行时间推进：\n$$\nf^{n+1}_{j,l} = f^n_{j,l} + \\Delta t \\left( -v_l \\left(\\frac{\\partial f}{\\partial x}\\right)^n_{j,l} - E^n_j \\left(\\frac{\\partial f}{\\partial v}\\right)^n_{j,l} \\right)\n$$\n其中 $\\Delta t$ 是时间步长，上标 $n$ 表示时间层 $t_n = n \\Delta t$。\n\n右侧各项的计算如下：\n\n空间平流项 $v \\frac{\\partial f}{\\partial x}$ 通过谱方法处理。对于每个速度切片 $v_l$，我们计算 $f(x, v_l, t)$ 的空间傅里叶变换，记为 $\\hat{f}(k, v_l, t)$。空间导数的傅里叶变换则为 $i k \\hat{f}(k, v_l, t)$，其中 $k$ 是整数波数。然后通过傅里叶逆变换得到物理空间中的 $\\frac{\\partial f}{\\partial x}$。这对应于为线性项指定的 Fourier-Galerkin 方法。\n\n速度平流项 $E \\frac{\\partial f}{\\partial v}$ 是导致混叠的非线性项。它通过几个步骤计算：\n1.  **电场计算**：电场 $E(x,t)$ 由分布函数 $f(x,v,t)$ 确定。\n    - 通过对速度进行数值积分来计算电荷密度：$\\rho(x_j, t) = \\sum_{l=0}^{N_v-1} f(x_j, v_l, t) \\Delta v$。\n    - 在傅里叶空间中求解泊松方程 $\\frac{\\partial E}{\\partial x} = \\rho - 1$。设 $\\hat{\\rho}(k,t)$ 是 $\\rho(x,t)$ 的空间傅里叶变换。方程变为 $i k \\hat{E}(k,t) = \\hat{\\rho}(k,t) - \\hat{1}(k,t)$。由于 $\\hat{1}(k,t)$ 仅在 $k=0$ 时非零，我们有对于 $k \\neq 0$：\n      $$\n      \\hat{E}(k,t) = \\frac{\\hat{\\rho}(k,t)}{ik} = -i \\frac{\\hat{\\rho}(k,t)}{k}\n      $$\n      为满足电荷中性，总电荷扰动 $\\int (\\rho-1) dx$ 为零，这意味着 $\\hat{\\rho}(k=0) - N_x = 0$。这保证了相容性。电场的 $k=0$ 模 $\\hat{E}(k=0,t)$ 设置为 $0$，对应于零平均电场。\n    - 通过对 $\\hat{E}(k,t)$ 进行傅里叶逆变换，恢复物理空间中的场 $E(x,t)$。\n\n2.  **速度导数**：速度导数 $\\frac{\\partial f}{\\partial v}$ 使用有限差分格式计算。我们对内部点使用二阶精确的中心差分，在边界 $v = \\pm V$ 处使用一阶精确的单边差分：\n    $$\n    \\left(\\frac{\\partial f}{\\partial v}\\right)_{j,l} =\n    \\begin{cases}\n    (f_{j,1} - f_{j,0}) / \\Delta v  \\text{若 } l=0 \\\\\n    (f_{j,l+1} - f_{j,l-1}) / (2 \\Delta v)  \\text{若 } 0  l  N_v-1 \\\\\n    (f_{j,N_v-1} - f_{j,N_v-2}) / \\Delta v  \\text{若 } l=N_v-1\n    \\end{cases}\n    $$\n\n3.  **非线性乘积与混叠控制**：形成乘积 $E(x,t) \\frac{\\partial f}{\\partial v}(x,v,t)$。混叠在此处发生，控制策略也在此处应用。\n    - **策略 A (无)**：在物理空间中直接计算乘积：$(E \\frac{\\partial f}{\\partial v})_{j,l} = E_j (\\frac{\\partial f}{\\partial v})_{j,l}$。\n    - **策略 B (三分之二规则)**：为防止混叠，在相乘前对两个因子 $E(x,t)$ 和 $\\frac{\\partial f}{\\partial v}(x,v,t)$ 的傅里叶谱进行截断。设 $k_{\\max} = N_x/2$ 为最大可表示波数的幅值。傅里叶系数 $\\hat{E}(k)$ 和 $\\widehat{\\frac{\\partial f}{\\partial v}}(k,v_l)$ 对于所有波数 $|k|  \\lfloor \\frac{2}{3} k_{\\max} \\rfloor = \\lfloor N_x/3 \\rfloor$ 都被设置为零。然后将滤波后的场变换回物理空间，并计算它们的乘积。在整个时间步更新之后，新的分布函数 $f^{n+1}$ 也在傅里叶空间中用相同的截断规则进行滤波。\n    - **策略 C (指数滤波器)**：不使用锐截止，而是在傅里叶空间中对 $E$、$\\frac{\\partial f}{\\partial v}$ 以及更新后的 $f^{n+1}$ 的系数应用一个平滑的指数滤波器。该滤波器的形式为 $\\phi(k) = \\exp\\left( -\\alpha \\left( \\frac{|k|}{k_{\\max}} \\right)^p \\right)$，其中 $\\alpha$ 和 $p$ 是控制滤波器强度和陡峭度的参数。这会衰减高波数模式，同时对低波数模式的影响最小。\n\n初始条件设置为：\n$$\nf(x,v,0) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{v^2}{2}\\right) \\left[ 1 + a \\cos(k_0 x) + b \\cos(k_1 x) \\right]\n$$\n其中 $k_0 = \\lfloor N_x / 4 \\rfloor$ 和 $k_1 = \\lfloor N_x / 3 \\rfloor$。选择这些波数旨在产生非线性相互作用，生成模式 $k_0+k_1$，其波数高于 Nyquist 频率 $k_{Nyq} = N_x/2$，从而直接激发混叠。\n\n时间步长 $\\Delta t$ 基于 $t=0$ 时空间和平流速度的 Courant-Friedrichs-Lewy (CFL) 条件固定：\n$$\n\\Delta t = \\min \\left( 0.1 \\frac{\\Delta x}{V}, 0.1 \\frac{\\Delta v}{\\|E(x,0)\\|_{\\infty}} \\right)\n$$\n其中 $\\|E(x,0)\\|_{\\infty}$ 是初始电场的最大绝对值。\n\n为了量化每种策略的性能，我们计算三个指标：\n1.  **相对质量误差**：$\\frac{M(T)-M(0)}{M(0)}$，其中 $M(t) = \\iint f \\, dx dv$。\n2.  **相对 $L^2$ 范数平方误差**：$\\frac{\\|f(T)\\|_2^2 - \\|f(0)\\|_2^2}{\\|f(0)\\|_2^2}$，其中 $\\|f(t)\\|_2^2 = \\iint f^2 \\, dx dv$。虽然质量是 Vlasov 方程的严格不变量，但 $L^2$ 范数也是守恒的，这在连续介质极限下是所谓的 Liouville 定理的一个性质。\n3.  **高波数能量堆积**：$\\Delta \\eta = \\eta(T) - \\eta(0)$，其中 $\\eta(t)$ 是上四分位数波数范围内的谱能量分数，定义为：\n    $$\n    \\eta(t) = \\frac{\\sum_{|k| \\geq 0.75 k_{\\max}} \\left( \\int | \\hat{f}(k,v,t) |^2 \\, dv \\right)}{\\sum_{\\text{all }k} \\left( \\int | \\hat{f}(k,v,t) |^2 \\, dv \\right)}\n    $$\n这些诊断量在初始时间 $t=0$ 和最终时间 $t=T=N_t \\Delta t$ 进行计算。这些积分的数值计算通过在离散网格上进行简单求和来完成，并用网格单元大小 $\\Delta x \\Delta v$ 进行加权。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(Nx, Nv, V_max, a, b, strategy, strategy_params, Nt):\n    \"\"\"\n    Runs a 1D-1V Vlasov-Poisson simulation for a given set of parameters.\n    \"\"\"\n    # 1. Discretization and Grids\n    L = 2 * np.pi\n    x = np.linspace(0, L, Nx, endpoint=False)\n    v = np.linspace(-V_max, V_max, Nv)\n    dx = x[1] - x[0]\n    dv = v[1] - v[0]\n\n    # Wavenumbers for spatial Fourier transforms\n    k_int = np.fft.fftfreq(Nx, d=1.0/Nx)\n    k_phys = np.fft.fftfreq(Nx, d=dx) * 2 * np.pi\n    k_phys[0] = 1e-12 # Avoid division by zero, though handled later\n    kmax = Nx / 2\n\n    k0 = int(np.floor(Nx / 4))\n    k1 = int(np.floor(Nx / 3))\n\n    # 2. Initial Condition\n    xx, vv = np.meshgrid(x, v, indexing='ij')\n    f0 = (1.0 / np.sqrt(2 * np.pi) * np.exp(-vv**2 / 2.0) *\n          (1.0 + a * np.cos(k0 * xx) + b * np.cos(k1 * xx)))\n    f = f0.copy()\n\n    # 3. Time Step Calculation from CFL conditions\n    rho0 = np.sum(f0, axis=1) * dv\n    rho_hat0 = np.fft.fft(rho0 - 1.0)\n    E_hat0 = np.zeros_like(rho_hat0, dtype=complex)\n    k_nonzero_mask = k_int != 0\n    E_hat0[k_nonzero_mask] = -1j * rho_hat0[k_nonzero_mask] / k_int[k_nonzero_mask]\n    E0 = np.fft.ifft(E_hat0).real\n    Emax0 = np.max(np.abs(E0)) if np.max(np.abs(E0))  0 else 1.0\n\n    dt = min(0.1 * dx / V_max, 0.1 * dv / Emax0)\n\n    # 4. Initial Diagnostics\n    def calculate_eta(f_dist, k_vec, k_max, delta_v):\n        f_hat = np.fft.fft(f_dist, axis=0)\n        f_hat_power_v_int = np.sum(np.abs(f_hat)**2, axis=1) * delta_v\n        \n        # Denominator is total power\n        total_power = np.sum(f_hat_power_v_int)\n        if total_power == 0:\n            return 0.0\n\n        # Numerator is power in upper quartile of wavenumbers\n        upper_quartile_mask = np.abs(k_vec) = 0.75 * k_max\n        upper_quartile_power = np.sum(f_hat_power_v_int[upper_quartile_mask])\n        \n        return upper_quartile_power / total_power\n\n    M0 = np.sum(f0) * dx * dv\n    L2_0 = np.sum(f0**2) * dx * dv\n    eta0 = calculate_eta(f0, k_int, kmax, dv)\n\n    # 5. Setup for Aliasing Strategies\n    filter_k = None\n    k_trunc = 0\n    if strategy == 'two_thirds':\n        k_trunc = int(np.floor(Nx / 3))\n    elif strategy == 'exp':\n        alpha = strategy_params['alpha']\n        p = strategy_params['p']\n        filter_k = np.exp(-alpha * (np.abs(k_int) / kmax)**p)\n    \n    # helper for v-derivative\n    def get_dfdv(f_dist, delta_v):\n        dfdv = np.zeros_like(f_dist)\n        dfdv[:, 1:-1] = (f_dist[:, 2:] - f_dist[:, :-2]) / (2 * delta_v)\n        dfdv[:, 0] = (f_dist[:, 1] - f_dist[:, 0]) / delta_v\n        dfdv[:, -1] = (f_dist[:, -1] - f_dist[:, -2]) / delta_v\n        return dfdv\n\n    # 6. Time Evolution Loop\n    for _ in range(Nt):\n        # Calculate spatial advection term: -v * df/dx\n        f_hat = np.fft.fft(f, axis=0)\n        dfdx_hat = 1j * k_int[:, np.newaxis] * f_hat\n        dfdx = np.fft.ifft(dfdx_hat, axis=0)\n        advection_term = -v[np.newaxis, :] * dfdx\n\n        # Calculate velocity advection term: -E * df/dv\n        rho = np.sum(f, axis=1) * dv\n        rho_hat = np.fft.fft(rho - 1.0)\n        E_hat = np.zeros_like(rho_hat, dtype=complex)\n        E_hat[k_nonzero_mask] = -1j * rho_hat[k_nonzero_mask] / k_int[k_nonzero_mask]\n        \n        dfdv = get_dfdv(f, dv)\n\n        if strategy == 'none':\n            E_phys = np.fft.ifft(E_hat)\n            nonlinear_term = -E_phys[:, np.newaxis] * dfdv\n        else: # Strategies with filtering\n            dfdv_hat = np.fft.fft(dfdv, axis=0)\n            if strategy == 'two_thirds':\n                mask = np.abs(k_int)  k_trunc\n                E_hat[mask] = 0\n                dfdv_hat[mask, :] = 0\n            elif strategy == 'exp':\n                E_hat *= filter_k\n                dfdv_hat *= filter_k[:, np.newaxis]\n\n            E_phys_filt = np.fft.ifft(E_hat)\n            dfdv_filt = np.fft.ifft(dfdv_hat, axis=0)\n            nonlinear_term = -E_phys_filt[:, np.newaxis] * dfdv_filt\n\n        # Update f using Forward Euler\n        f_new = f + dt * (advection_term + nonlinear_term)\n        f = f_new.real\n        \n        # Post-step filtering for strategies B and C\n        if strategy == 'two_thirds':\n            f_hat_new = np.fft.fft(f, axis=0)\n            mask = np.abs(k_int)  k_trunc\n            f_hat_new[mask, :] = 0\n            f = np.fft.ifft(f_hat_new, axis=0).real\n        elif strategy == 'exp':\n            f_hat_new = np.fft.fft(f, axis=0)\n            f_hat_new *= filter_k[:, np.newaxis]\n            f = np.fft.ifft(f_hat_new, axis=0).real\n\n    # 7. Final Diagnostics and Error Calculation\n    M_T = np.sum(f) * dx * dv\n    L2_T = np.sum(f**2) * dx * dv\n    eta_T = calculate_eta(f, k_int, kmax, dv)\n\n    m_err = (M_T - M0) / M0\n    l2_err = (L2_T - L2_0) / L2_0\n    delta_eta = eta_T - eta0\n\n    return [m_err, l2_err, delta_eta]\n\ndef solve():\n    test_cases = [\n        # Case 1: (Nx=32, Nv=64, V=6, a=0.05, b=0.04, \"none\", {}, 300)\n        {'Nx': 32, 'Nv': 64, 'V_max': 6, 'a': 0.05, 'b': 0.04,\n         'strategy': 'none', 'strategy_params': {}, 'Nt': 300},\n        # Case 2: (Nx=32, Strategy=\"two_thirds\")\n        {'Nx': 32, 'Nv': 64, 'V_max': 6, 'a': 0.05, 'b': 0.04,\n         'strategy': 'two_thirds', 'strategy_params': {}, 'Nt': 300},\n        # Case 3: (Nx=32, Strategy=\"exp\")\n        {'Nx': 32, 'Nv': 64, 'V_max': 6, 'a': 0.05, 'b': 0.04,\n         'strategy': 'exp', 'strategy_params': {'alpha': 36, 'p': 36}, 'Nt': 300},\n        # Case 4: (Nx=16, Strategy=\"none\")\n        {'Nx': 16, 'Nv': 64, 'V_max': 6, 'a': 0.05, 'b': 0.04,\n         'strategy': 'none', 'strategy_params': {}, 'Nt': 300},\n        # Case 5: (Nx=128, Strategy=\"none\")\n        {'Nx': 128, 'Nv': 64, 'V_max': 6, 'a': 0.05, 'b': 0.04,\n         'strategy': 'none', 'strategy_params': {}, 'Nt': 300},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        results.append(result)\n\n    # Format output as specified: [[r1,r2,r3],[...],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了将Vlasov求解器应用于像托卡马克这样的真实聚变装置，必须从简单的笛卡尔坐标系过渡到更复杂的曲线坐标系。然而，这种过渡引入了新的复杂性：必须正确处理坐标变换的度规因子（Jacobian），否则会导致严重的数值误差。本实践旨在通过设计一个“坐标不变性”测试来解决这一关键问题，您将比较同一个物理问题在笛卡尔坐标系和场向曲线坐标系下的解，从而亲手验证正确处理度规项对于构建稳健、几何无关的求解器至关重要。",
            "id": "4185000",
            "problem": "要求您设计并实现一个坐标不变性测试，通过在笛卡尔坐标系和一个简单的场向曲线坐标系中比较相同的物理平流问题，来分离出连续介质（欧拉）Vlasov求解器中由度规引发的误差。目标是证明，对于无碰撞Vlasov动力学背后的不可压缩哈密顿流，在广义坐标系下的正确守恒格式会保持均匀分布函数，而忽略度规因子的实现会产生虚假的残差。您的程序必须计算并报告几个测试案例的标量诊断值。\n\n从以下基本原理出发：\n- 在相空间域上，对于具有流场 $\\boldsymbol{a}$ 的被动分布函数 $f$，无碰撞Vlasov方程是守恒输运方程 $\\partial f / \\partial t + \\nabla \\cdot (\\boldsymbol{a} f) = 0$，其中对于不可压缩哈密顿流，有 $\\nabla \\cdot \\boldsymbol{a} = 0$。\n- 在广义曲线坐标 $u^i$ 中，一个物理矢量场的散度，其逆变分量为 $a^i$，雅可比行列式为 $J$（将 $u^i$ 空间体积映射到物理体积），由下式给出：$\\nabla \\cdot \\boldsymbol{a} = \\dfrac{1}{J} \\partial_i (J a^i)$。\n\n考虑一个二维构型空间中的类似问题，该问题可以在不引入自洽场的情况下分离出度规效应。设 $(x,y)$ 表示笛卡尔坐标，$(\\xi,\\eta)$ 表示场向坐标，它们通过以下光滑、严格单调的映射相连接：\n$$\nx(\\xi,\\eta) = \\xi,\\qquad y(\\xi,\\eta) = h(\\xi)\\,\\eta,\n$$\n其中\n$$\nh(\\xi) = 1 + \\alpha \\cos\\left(\\dfrac{2\\pi}{L_x}\\,\\xi\\right),\\qquad 0 \\le \\alpha  1,\\quad L_x  0.\n$$\n假设在两个方向上都采用周期性边界条件，$\\xi \\in [0,L_x)$ 和 $\\eta \\in [0,L_y)$。此映射的雅可比行列式（度规体积因子）为 $J(\\xi,\\eta) = h(\\xi)$。设物理平流速度在笛卡尔坐标系中是均匀且恒定的，\n$$\n\\boldsymbol{U} = (U_x, U_y),\n$$\n因此物理流是不可压缩的，$\\nabla \\cdot \\boldsymbol{U} = 0$。对于一个均匀的初始分布 $f_0$，当散度被正确表述时，精确的右端残差 $R = -\\nabla \\cdot (\\boldsymbol{U} f_0)$ 在任何坐标系中都必须恒等于零。\n\n在大小为 $N_x \\times N_y$ 的均匀网格上，使用具有周期性边界条件的二阶中心有限差分法，定义 $(\\xi,\\eta)$ 空间中的三个离散残差场：\n- $R_{\\mathrm{cart}}$：在笛卡尔坐标系中，在相同的均匀计算网格（直接解释为 $(x,y)$）上为常数通量 $\\boldsymbol{U} f_0$ 计算的残差。\n- $R_{\\mathrm{curv,correct}}$：在曲线坐标系中，使用带有正确度规因子和逆变分量的守恒散度计算的残差，\n$$\nR_{\\mathrm{curv,correct}}(\\xi,\\eta) = -\\dfrac{1}{J(\\xi,\\eta)}\\left[ \\partial_\\xi\\left(J(\\xi,\\eta)\\,a^\\xi(\\xi,\\eta)\\,f_0\\right) + \\partial_\\eta\\left(J(\\xi,\\eta)\\,a^\\eta(\\xi,\\eta)\\,f_0\\right) \\right].\n$$\n此处 $\\boldsymbol{a} = (a^\\xi,a^\\eta)$ 是 $\\boldsymbol{U}$ 在由上述映射定义的 $(\\xi,\\eta)$ 基中的逆变分量。\n- $R_{\\mathrm{curv,naive}}$：在曲线坐标系中，通过忽略度规因子的朴素散度计算的残差，\n$$\nR_{\\mathrm{curv,naive}}(\\xi,\\eta) = -\\left[\\partial_\\xi a^\\xi(\\xi,\\eta) + \\partial_\\eta a^\\eta(\\xi,\\eta)\\right] f_0.\n$$\n\n分离度规引发误差的测试方法是，在相同的物理设置下，比较 $R_{\\mathrm{curv,naive}}$ 的均方根（RMS）幅值与 $R_{\\mathrm{cart}}$ 和 $R_{\\mathrm{curv,correct}}$ 的零值。在具有非平凡度规变化或非零 $U_x$ 的情况下，$R_{\\mathrm{curv,naive}}$ 的非零RMS值表明存在纯粹由度规引发的误差。这一比较证明了在用曲线坐标编写的连续介质（欧拉）Vlasov求解器中，使用雅可比行列式加权的散度的必要性。\n\n您的任务：\n1. 推导恒定笛卡尔速度 $\\boldsymbol{U}$ 在上述映射导出的 $(\\xi,\\eta)$ 坐标基中的逆变分量 $a^\\xi(\\xi,\\eta)$ 和 $a^\\eta(\\xi,\\eta)$。\n2. 在均匀计算网格 $(\\xi_i,\\eta_j)$（其中 $i=0,\\dots,N_x-1$，$j=0,\\dots,N_y-1$，网格间距为 $\\Delta \\xi = L_x/N_x$ 和 $\\Delta \\eta = L_y/N_y$）上，实现具有周期性边界条件的 $\\partial_\\xi$ 和 $\\partial_\\eta$ 的二阶中心有限差分近似。\n3. 对于每个测试案例，计算网格上 $R_{\\mathrm{curv,naive}}$ 的RMS值，其定义为\n$$\n\\mathrm{RMS}(R) = \\left( \\dfrac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} R(\\xi_i,\\eta_j)^2 \\right)^{1/2}.\n$$\n不失一般性，可以取 $f_0 = 1$。\n\n测试套件：\n为以下参数集 $(\\alpha, N_x, N_y, U_x, U_y, L_x, L_y)$ 提供结果：\n- 案例 A（正常情况）：$(0.3, 64, 64, 1.0, 0.5, 2\\pi, 2\\pi)$。\n- 案例 B（边界情况，无度规变化）：$(0.0, 32, 32, 1.0, 0.0, 2\\pi, 2\\pi)$。\n- 案例 C（边缘情况，流场与 $\\eta$ 对齐，因此 $U_x = 0$）：$(0.3, 48, 96, 0.0, 1.0, 2\\pi, 2\\pi)$。\n- 案例 D（边缘情况，各向异性网格和强度规变化）：$(0.5, 16, 128, 1.0, 0.0, 2\\pi, 2\\pi)$。\n- 案例 E（更高分辨率）：$(0.3, 128, 128, 1.0, 0.5, 2\\pi, 2\\pi)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试案例对应一个浮点数，按上述顺序表示每个案例的 $\\mathrm{RMS}(R_{\\mathrm{curv,naive}})$ 值，例如，\"[0.123,0.0,0.0,0.456,0.078]\"。所有量都是无量纲的；不需要物理单位。如果存在角度，则以弧度为单位。不得使用百分比。",
            "solution": "该问题要求设计并实现一个坐标不变性测试，用于在连续介质Vlasov求解器中进行。此测试旨在分离和量化因在曲线坐标系中忽略度规张量分量而产生的数值误差。任务的核心是为一个简单的不可压缩流场计算一个标量诊断值，即“朴素”计算残差的均方根（RMS）值。\n\n分析过程分为三个主要步骤：\n1.  推导平流速度在指定曲线坐标系中的逆变分量。\n2.  详细说明使用有限差分计算残差场的数值算法。\n3.  计算所提供测试案例的RMS诊断值。\n\n### 1. 逆变速度分量的推导\n\n给定从曲线坐标系 $(\\xi, \\eta)$ 到笛卡尔坐标系 $(x,y)$ 的变换：\n$$\nx(\\xi,\\eta) = \\xi\n$$\n$$\ny(\\xi,\\eta) = h(\\xi)\\,\\eta\n$$\n其中 $h(\\xi) = 1 + \\alpha \\cos\\left(\\frac{2\\pi}{L_x}\\xi\\right)$。\n\n笛卡尔速度分量 $(U_x, U_y) = (\\dot{x}, \\dot{y})$ 通过链式法则与曲线坐标的时间导数 $(\\dot{\\xi}, \\dot{\\eta})$ 相关联：\n$$\n\\begin{pmatrix} \\dot{x} \\\\ \\dot{y} \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} \\begin{pmatrix} \\dot{\\xi} \\\\ \\dot{\\eta} \\end{pmatrix}\n$$\n根据定义，速度矢量的逆变分量为 $a^\\xi = \\dot{\\xi}$ 和 $a^\\eta = \\dot{\\eta}$。上式中的矩阵是变换的雅可比矩阵 $\\mathbf{J}_{map}$。我们必须计算其分量：\n$$\n\\frac{\\partial x}{\\partial \\xi} = 1\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = 0\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{dh}{d\\xi}\\eta = h'(\\xi)\\eta\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = h(\\xi)\n$$\n将这些代入矩阵方程：\n$$\n\\begin{pmatrix} U_x \\\\ U_y \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ h'(\\xi)\\eta  h(\\xi) \\end{pmatrix} \\begin{pmatrix} a^\\xi \\\\ a^\\eta \\end{pmatrix}\n$$\n为了求出逆变分量 $(a^\\xi, a^\\eta)$，我们对雅可比矩阵求逆：\n$$\n\\mathbf{J}_{map}^{-1} = \\frac{1}{\\det(\\mathbf{J}_{map})} \\begin{pmatrix} h(\\xi)  0 \\\\ -h'(\\xi)\\eta  1 \\end{pmatrix} = \\frac{1}{h(\\xi)} \\begin{pmatrix} h(\\xi)  0 \\\\ -h'(\\xi)\\eta  1 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ -\\frac{h'(\\xi)\\eta}{h(\\xi)}  \\frac{1}{h(\\xi)} \\end{pmatrix}\n$$\n注意，行列式 $\\det(\\mathbf{J}_{map}) = h(\\xi)$ 就是问题描述中给出的坐标变换的雅可比行列式 $J$。\n\n现在，我们求解逆变分量：\n$$\n\\begin{pmatrix} a^\\xi \\\\ a^\\eta \\end{pmatrix} = \\mathbf{J}_{map}^{-1} \\begin{pmatrix} U_x \\\\ U_y \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ -\\frac{h'(\\xi)\\eta}{h(\\xi)}  \\frac{1}{h(\\xi)} \\end{pmatrix} \\begin{pmatrix} U_x \\\\ U_y \\end{pmatrix}\n$$\n该矩阵乘法得出了逆变速度分量的显式表达式：\n$$\na^\\xi(\\xi, \\eta) = U_x\n$$\n$$\na^\\eta(\\xi, \\eta) = -\\frac{h'(\\xi)\\eta}{h(\\xi)}U_x + \\frac{1}{h(\\xi)}U_y = \\frac{U_y - U_x h'(\\xi)\\eta}{h(\\xi)}\n$$\n其中 $h'(\\xi) = \\frac{dh}{d\\xi} = -\\alpha \\frac{2\\pi}{L_x} \\sin\\left(\\frac{2\\pi}{L_x}\\xi\\right)$。这些表达式对于计算残差至关重要。\n\n### 2. 离散化与残差计算\n\n问题要求计算忽略了度规因子的“朴素”残差。对于均匀分布 $f_0=1$，其表达式为：\n$$\nR_{\\mathrm{curv,naive}}(\\xi,\\eta) = -\\left(\\frac{\\partial a^\\xi}{\\partial \\xi} + \\frac{\\partial a^\\eta}{\\partial \\eta}\\right)\n$$\n我们在一个均匀的计算网格 $(\\xi_i, \\eta_j)$ 上计算该值，其中 $\\xi_i = i \\Delta\\xi$（$i=0,\\dots,N_x-1$），$\\eta_j = j \\Delta\\eta$（$j=0,\\dots,N_y-1$），网格间距为 $\\Delta\\xi = L_x/N_x$ 和 $\\Delta\\eta = L_y/N_y$。\n\n偏导数使用具有周期性边界条件的二阶中心有限差分进行近似。对于一个通用的网格函数 $F_{i,j} = F(\\xi_i, \\eta_j)$：\n$$\n\\left(\\frac{\\partial F}{\\partial \\xi}\\right)_{i,j} \\approx \\frac{F_{i+1,j} - F_{i-1,j}}{2\\Delta\\xi}\n$$\n$$\n\\left(\\frac{\\partial F}{\\partial \\eta}\\right)_{i,j} \\approx \\frac{F_{i,j+1} - F_{i,j-1}}{2\\Delta\\eta}\n$$\n周期性意味着 $F_{N_x, j} = F_{0, j}$，$F_{-1, j} = F_{N_x-1, j}$，对于 $j$ 索引也类似。\n\n让我们将这些算子应用于我们的逆变分量 $a^\\xi$ 和 $a^\\eta$。\n首先，对于 $\\partial a^\\xi / \\partial \\xi$：\n由于 $a^\\xi(\\xi, \\eta) = U_x$ 是一个常数，它对任何变量的导数在解析上都为零。中心差分算子也精确地得到零：\n$$\n\\frac{\\partial a^\\xi}{\\partial \\xi} \\approx \\frac{U_x - U_x}{2\\Delta\\xi} = 0\n$$\n其次，对于 $\\partial a^\\eta / \\partial \\eta$：\n分量 $a^\\eta$ 是 $\\eta$ 的线性函数。中心差分算子对于次数不超过2的多项式是精确的，因此在这里也是精确的。\n$$\n\\left(\\frac{\\partial a^\\eta}{\\partial \\eta}\\right)_{i,j} \\approx \\frac{a^\\eta(\\xi_i, \\eta_{j+1}) - a^\\eta(\\xi_i, \\eta_{j-1})}{2\\Delta\\eta} = \\frac{1}{2\\Delta\\eta} \\left[ \\frac{U_y - U_x h'(\\xi_i)\\eta_{j+1}}{h(\\xi_i)} - \\frac{U_y - U_x h'(\\xi_i)\\eta_{j-1}}{h(\\xi_i)} \\right]\n$$\n$$\n= \\frac{-U_x h'(\\xi_i)}{2\\Delta\\eta h(\\xi_i)} (\\eta_{j+1} - \\eta_{j-1}) = \\frac{-U_x h'(\\xi_i)}{2\\Delta\\eta h(\\xi_i)} (2\\Delta\\eta) = -\\frac{U_x h'(\\xi_i)}{h(\\xi_i)}\n$$\n数值导数与解析导数 $\\frac{\\partial}{\\partial \\eta} \\left(\\frac{U_y}{h(\\xi)} - \\frac{U_x h'(\\xi) \\eta}{h(\\xi)}\\right) = -\\frac{U_x h'(\\xi)}{h(\\xi)}$ 相同。\n\n结合这些结果，每个网格点上的数值计算残差为：\n$$\nR_{\\mathrm{curv,naive}}(\\xi_i, \\eta_j) = -\\left(0 - \\frac{U_x h'(\\xi_i)}{h(\\xi_i)}\\right) = \\frac{U_x h'(\\xi_i)}{h(\\xi_i)}\n$$\n该表达式表明，残差与 $\\eta$ 无关，并且当且仅当 $U_x \\neq 0$ 且 $h'(\\xi_i) \\neq 0$ 时非零。后者在 $\\alpha \\neq 0$ 且 $\\sin\\left(\\frac{2\\pi}{L_x}\\xi_i\\right) \\neq 0$ 时成立。这个残差是忽略散度算子内部的度规雅可比行列式 $J=h(\\xi)$ 的直接后果，从而证实了问题的假设。\n\n### 3. RMS诊断值计算\n\n最后的任务是计算整个网格上残差场的RMS值：\n$$\n\\mathrm{RMS}(R_{\\mathrm{curv,naive}}) = \\left( \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left(R_{\\mathrm{curv,naive}}(\\xi_i, \\eta_j)\\right)^2 \\right)^{1/2}\n$$\n由于残差 $R_{\\mathrm{curv,naive}}(\\xi_i, \\eta_j)$ 仅取决于索引 $i$，我们可以简化双重求和：\n$$\n\\mathrm{RMS}(R_{\\mathrm{curv,naive}}) = \\left( \\frac{1}{N_x N_y} \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} \\left(\\frac{U_x h'(\\xi_i)}{h(\\xi_i)}\\right)^2 \\right)^{1/2} = \\left( \\frac{N_y}{N_x N_y} \\sum_{i=0}^{N_x-1} \\left(\\frac{U_x h'(\\xi_i)}{h(\\xi_i)}\\right)^2 \\right)^{1/2}\n$$\n$$\n\\mathrm{RMS}(R_{\\mathrm{curv,naive}}) = \\left( \\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left(\\frac{U_x h'(\\xi_i)}{h(\\xi_i)}\\right)^2 \\right)^{1/2}\n$$\n对每个测试案例实现这个最终表达式。尽管我们已经证明其可以简化为此解析形式，但实现过程将按照要求遵循数值微分步骤。代码在二维网格上计算残差值数组 `R_naive`，然后直接计算其 RMS 值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coordinate-invariance test problem for continuum Vlasov solvers.\n    \n    This function calculates the RMS of a naively computed residual for several\n    test cases to demonstrate metric-induced errors in a curvilinear \n    coordinate system.\n    \"\"\"\n\n    test_cases = [\n        # Case A: (alpha, Nx, Ny, Ux, Uy, Lx, Ly) - Happy path\n        (0.3, 64, 64, 1.0, 0.5, 2 * np.pi, 2 * np.pi),\n        # Case B: alpha=0, no metric variation\n        (0.0, 32, 32, 1.0, 0.0, 2 * np.pi, 2 * np.pi),\n        # Case C: Ux=0, flow aligned with eta-coordinate\n        (0.3, 48, 96, 0.0, 1.0, 2 * np.pi, 2 * np.pi),\n        # Case D: Anisotropic grid, strong metric variation\n        (0.5, 16, 128, 1.0, 0.0, 2 * np.pi, 2 * np.pi),\n        # Case E: Refined resolution of Case A\n        (0.3, 128, 128, 1.0, 0.5, 2 * np.pi, 2 * np.pi),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        alpha, Nx, Ny, Ux, Uy, Lx, Ly = case\n        \n        f0 = 1.0\n\n        # 1. Set up the computational grid in (xi, eta) space.\n        # Grid points are cell centers for a finite volume interpretation,\n        # but the problem implies a node-based grid up to L_x, L_y (exclusive).\n        #linspace endpoint=False creates an array of N points from start to stop-step.\n        xi_1d = np.linspace(0, Lx, Nx, endpoint=False)\n        eta_1d = np.linspace(0, Ly, Ny, endpoint=False)\n        xi_grid, eta_grid = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n        # Grid spacings\n        D_xi = Lx / Nx\n        D_eta = Ly / Ny\n\n        # 2. Calculate metric-related functions h(xi) and h'(xi).\n        # These are functions of xi only, but we broadcast them to the full grid size.\n        k = (2 * np.pi) / Lx\n        h_grid = 1.0 + alpha * np.cos(k * xi_grid)\n        h_prime_grid = -alpha * k * np.sin(k * xi_grid)\n\n        # 3. Derive the contravariant components of the velocity field.\n        # These components, a^xi and a^eta, are defined on the (xi, eta) grid.\n        # a_xi is constant.\n        a_xi_grid = Ux * np.ones_like(xi_grid)\n        \n        # a_eta depends on xi and eta.\n        # To avoid division by zero if h_grid should ever be zero (prevented by alpha  1).\n        with np.errstate(divide='raise', invalid='raise'):\n             a_eta_grid = (Uy - Ux * h_prime_grid * eta_grid) / h_grid\n\n        # 4. Compute partial derivatives using 2nd-order centered differences\n        # with periodic boundary conditions.\n        # np.roll provides an efficient way to implement periodic shifts.\n        # axis=1 corresponds to xi (columns), axis=0 corresponds to eta (rows in numpy default).\n        # However, meshgrid with indexing='ij' makes axis=0 correspond to xi and axis=1 to eta.\n        \n        # d(a_xi)/d_xi\n        d_xi_a_xi = (np.roll(a_xi_grid, -1, axis=0) - np.roll(a_xi_grid, 1, axis=0)) / (2 * D_xi)\n        \n        # d(a_eta)/d_eta\n        d_eta_a_eta = (np.roll(a_eta_grid, -1, axis=1) - np.roll(a_eta_grid, 1, axis=1)) / (2 * D_eta)\n\n        # 5. Compute the naive residual field, R_curv_naive.\n        # R_naive = - (d(a^xi)/d_xi + d(a^eta)/d_eta) * f0\n        R_naive = -(d_xi_a_xi + d_eta_a_eta) * f0\n\n        # 6. Calculate the Root-Mean-Square (RMS) of the residual field.\n        rms_val = np.sqrt(np.mean(R_naive**2))\n        results.append(rms_val)\n\n    # Format the final output string as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}