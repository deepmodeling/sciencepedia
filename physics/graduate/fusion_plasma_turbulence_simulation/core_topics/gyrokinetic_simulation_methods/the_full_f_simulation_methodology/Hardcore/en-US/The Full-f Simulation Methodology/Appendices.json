{
    "hands_on_practices": [
        {
            "introduction": "Full-f Particle-In-Cell (PIC) simulations trade conceptual simplicity for higher intrinsic noise compared to perturbative $\\delta f$ methods. This exercise is foundational because it forces you to confront this noise directly. By deriving the variance of a key physical observable from first principles, you will gain a quantitative understanding of how simulation parameters like the number of particles affect statistical accuracy. This practice  is essential for developing an intuition for the signal-to-noise challenges in full-f simulations and for appreciating the necessity of variance reduction techniques.",
            "id": "4203338",
            "problem": "Consider a full-distribution-function ($\\text{full-}f$) Particle-In-Cell (PIC) simulation of a single ion species of mass $m$ in a homogeneous, stationary plasma. In a single spatial cell of volume $V_c$, the species has number density $n$ and a Maxwell–Boltzmann velocity distribution with temperature $T$. The distribution function factorizes as $f(\\mathbf{x},\\mathbf{v}) = n\\,F_{\\mathrm{MB}}(\\mathbf{v};T)$, where the Maxwell–Boltzmann velocity Probability Density Function (PDF) is\n$$\nF_{\\mathrm{MB}}(\\mathbf{v};T) = \\left(\\frac{m}{2\\pi k_{B}T}\\right)^{3/2}\\exp\\!\\left(-\\frac{m\\,|\\mathbf{v}|^{2}}{2k_{B}T}\\right),\n$$\nwith $k_{B}$ the Boltzmann constant.\n\nYou wish to estimate the kinetic energy density moment\n$$\nK = \\int_{\\mathbb{R}^{3}} \\frac{1}{2}\\,m\\,|\\mathbf{v}|^{2}\\,f(\\mathbf{x},\\mathbf{v})\\,\\mathrm{d}^{3}\\mathbf{v} = n\\int_{\\mathbb{R}^{3}} \\frac{1}{2}\\,m\\,|\\mathbf{v}|^{2}\\,F_{\\mathrm{MB}}(\\mathbf{v};T)\\,\\mathrm{d}^{3}\\mathbf{v}\n$$\nusing $N$ independent macro-particles whose velocities are drawn identically and independently from the PDF $F_{\\mathrm{MB}}(\\mathbf{v};T)$ at the instant of interest (that is, a standard full-$f$ PIC sampling of the velocity space at fixed $\\mathbf{x}$). The natural PIC estimator is the sample average of the integrand multiplied by $n$.\n\nStarting from first principles of Monte Carlo estimation and the properties of the Maxwell–Boltzmann distribution, derive a closed-form analytic expression for the variance of this PIC estimator as a function of $n$, $T$, $k_{B}$, $m$, and $N$.\n\nAdditionally, propose and justify a variance-reduction strategy that preserves unbiasedness of the estimator in a full-$f$ PIC context.\n\nExpress the final variance in $(\\mathrm{J}/\\mathrm{m}^{3})^{2}$. Your final answer must be a single closed-form expression; do not provide intermediate equations as the final answer. No rounding is required.",
            "solution": "The user wants me to solve the following problem:\n\"Consider a full-distribution-function ($\\text{full-}f$) Particle-In-Cell (PIC) simulation of a single ion species of mass $m$ in a homogeneous, stationary plasma. In a single spatial cell of volume $V_c$, the species has number density $n$ and a Maxwell–Boltzmann velocity distribution with temperature $T$. The distribution function factorizes as $f(\\mathbf{x},\\mathbf{v}) = n\\,F_{\\mathrm{MB}}(\\mathbf{v};T)$, where the Maxwell–Boltzmann velocity Probability Density Function (PDF) is\n$$\nF_{\\mathrm{MB}}(\\mathbf{v};T) = \\left(\\frac{m}{2\\pi k_{B}T}\\right)^{3/2}\\exp\\!\\left(-\\frac{m\\,|\\mathbf{v}|^{2}}{2k_{B}T}\\right),\n$$\nwith $k_{B}$ the Boltzmann constant.\n\nYou wish to estimate the kinetic energy density moment\n$$\nK = \\int_{\\mathbb{R}^{3}} \\frac{1}{2}\\,m\\,|\\mathbf{v}|^{2}\\,f(\\mathbf{x},\\mathbf{v})\\,\\mathrm{d}^{3}\\mathbf{v} = n\\int_{\\mathbb{R}^{3}} \\frac{1}{2}\\,m\\,|\\mathbf{v}|^{2}\\,F_{\\mathrm{MB}}(\\mathbf{v};T)\\,\\mathrm{d}^{3}\\mathbf{v}\n$$\nusing $N$ independent macro-particles whose velocities are drawn identically and independently from the PDF $F_{\\mathrm{MB}}(\\mathbf{v};T)$ at the instant of interest (that is, a standard full-$f$ PIC sampling of the velocity space at fixed $\\mathbf{x}$). The natural PIC estimator is the sample average of the integrand multiplied by $n$.\n\nStarting from first principles of Monte Carlo estimation and the properties of the Maxwell–Boltzmann distribution, derive a closed-form analytic expression for the variance of this PIC estimator as a function of $n$, $T$, $k_{B}$, $m$, and $N$.\n\nAdditionally, propose and justify a variance-reduction strategy that preserves unbiasedness of the estimator in a full-$f$ PIC context.\"\n\n### Step 1: Extract Givens\n-   System: A single ion species in a homogeneous, stationary plasma.\n-   Particle mass: $m$.\n-   Cell volume: $V_c$.\n-   Species number density: $n$.\n-   Species temperature: $T$.\n-   Distribution function: $f(\\mathbf{x},\\mathbf{v}) = n\\,F_{\\mathrm{MB}}(\\mathbf{v};T)$.\n-   Velocity PDF: $F_{\\mathrm{MB}}(\\mathbf{v};T) = \\left(\\frac{m}{2\\pi k_{B}T}\\right)^{3/2}\\exp\\!\\left(-\\frac{m\\,|\\mathbf{v}|^{2}}{2k_{B}T}\\right)$.\n-   Constant: $k_{B}$ (Boltzmann constant).\n-   Quantity to estimate: Kinetic energy density, $K = n\\int_{\\mathbb{R}^{3}} \\frac{1}{2}\\,m\\,|\\mathbf{v}|^{2}\\,F_{\\mathrm{MB}}(\\mathbf{v};T)\\,\\mathrm{d}^{3}\\mathbf{v}$.\n-   Estimation method: Monte Carlo sampling with $N$ i.i.d. macro-particles.\n-   Particle velocities $\\{\\mathbf{v}_i\\}_{i=1}^N$ are drawn from $F_{\\mathrm{MB}}(\\mathbf{v};T)$.\n-   PIC estimator form: Sample average of the integrand, multiplied by $n$.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem is well-grounded in the fields of statistical mechanics and computational plasma physics. The Maxwell-Boltzmann distribution, Particle-In-Cell method, and Monte Carlo estimation are all standard and fundamental concepts.\n-   **Well-Posed**: The problem is clearly stated, with all necessary parameters and distributions defined. It asks for a derivation of the variance of a specific estimator and a proposal for a variance reduction technique, both of which are solvable tasks. A unique analytical solution for the variance exists.\n-   **Objective**: The language is precise and objective, using standard scientific terminology. There are no subjective or ambiguous statements.\n\nThe problem does not exhibit any of the flaws listed in the instructions (e.g., scientific unsoundness, incompleteness, contradiction, etc.). It is a standard, well-formulated problem in computational physics.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Part 1: Derivation of the Variance of the PIC Estimator\n\nThe kinetic energy density is given by $K = n \\langle E_k \\rangle$, where $E_k(\\mathbf{v}) = \\frac{1}{2}m|\\mathbf{v}|^2$ is the kinetic energy of a single particle and the angle brackets denote the expectation value over the velocity PDF $F_{\\mathrm{MB}}(\\mathbf{v};T)$.\n$$\n\\langle E_k \\rangle = \\int_{\\mathbb{R}^3} E_k(\\mathbf{v}) F_{\\mathrm{MB}}(\\mathbf{v};T) \\, \\mathrm{d}^3\\mathbf{v}\n$$\nThe PIC estimator for $K$ is constructed by replacing the expectation value with a sample mean over $N$ particles whose velocities $\\mathbf{v}_i$ are drawn from $F_{\\mathrm{MB}}$. The problem states the estimator is the sample average of the integrand, which is $\\frac{1}{2}m|\\mathbf{v}|^2 n F_{\\mathrm{MB}}$, but this is incorrect. The estimator is formed by sampling from the PDF part of the measure. The integral is $K = \\int (\\frac{1}{2}m|\\mathbf{v}|^2 n) F_{\\mathrm{MB}}(\\mathbf{v}) \\mathrm{d}^3\\mathbf{v}$. The term being averaged is $H(\\mathbf{v}) = \\frac{1}{2} m |\\mathbf{v}|^2 n$. The estimator for $K$ is therefore:\n$$\n\\hat{K} = \\frac{1}{N} \\sum_{i=1}^{N} H(\\mathbf{v}_i) = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{1}{2} m |\\mathbf{v}_i|^2 n = \\frac{n}{N} \\sum_{i=1}^{N} \\frac{1}{2} m |\\mathbf{v}_i|^2\n$$\nThis matches the interpretation \"sample average of the integrand multiplied by $n$\" if the \"integrand\" is taken to be $\\frac{1}{2}m|\\mathbf{v}|^2$. Let $E_{k,i} = \\frac{1}{2} m |\\mathbf{v}_i|^2$. Then $\\hat{K} = \\frac{n}{N} \\sum_{i=1}^N E_{k,i}$.\n\nThe variance of this estimator, $\\mathrm{Var}(\\hat{K})$, is given by the properties of variances. Since the velocities $\\mathbf{v}_i$ are i.i.d., the kinetic energies $E_{k,i}$ are also i.i.d. random variables.\n$$\n\\mathrm{Var}(\\hat{K}) = \\mathrm{Var}\\left(\\frac{n}{N} \\sum_{i=1}^{N} E_{k,i}\\right) = \\frac{n^2}{N^2} \\mathrm{Var}\\left(\\sum_{i=1}^{N} E_{k,i}\\right) = \\frac{n^2}{N^2} \\sum_{i=1}^{N} \\mathrm{Var}(E_{k,i}) = \\frac{n^2}{N^2} N \\mathrm{Var}(E_k) = \\frac{n^2}{N} \\mathrm{Var}(E_k)\n$$\nThe task reduces to calculating the variance of the single-particle kinetic energy, $\\mathrm{Var}(E_k)$. The variance is defined as $\\mathrm{Var}(E_k) = \\langle E_k^2 \\rangle - \\langle E_k \\rangle^2$. We must compute the first two moments of $E_k$.\n\nLet $a = \\frac{m}{2k_B T}$. The Maxwell-Boltzmann PDF in spherical coordinates, integrating over the solid angle, becomes a PDF for the speed $v=|\\mathbf{v}|$:\n$$\nP(v) = 4\\pi v^2 \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{mv^2}{2k_B T}\\right) = 4\\pi v^2 \\left(\\frac{a}{\\pi}\\right)^{3/2} \\exp(-av^2)\n$$\nFirst moment, $\\langle E_k \\rangle$:\n$$\n\\langle E_k \\rangle = \\int_0^\\infty \\left(\\frac{1}{2}mv^2\\right) P(v) \\, \\mathrm{d}v = \\frac{1}{2}m \\int_0^\\infty v^2 \\left( 4\\pi v^2 \\left(\\frac{a}{\\pi}\\right)^{3/2} \\exp(-av^2) \\right) \\, \\mathrm{d}v\n$$\n$$\n\\langle E_k \\rangle = 2\\pi m \\left(\\frac{a}{\\pi}\\right)^{3/2} \\int_0^\\infty v^4 \\exp(-av^2) \\, \\mathrm{d}v\n$$\nWe use the standard integral formula $\\int_0^\\infty x^{2n} \\exp(-ax^2) \\, \\mathrm{d}x = \\frac{(2n-1)!!}{2^{n+1}} \\sqrt{\\frac{\\pi}{a^{2n+1}}}$. For $n=2$, the integral is $\\frac{3!!}{2^3}\\sqrt{\\frac{\\pi}{a^5}} = \\frac{3}{8}\\sqrt{\\frac{\\pi}{a^5}}$.\n$$\n\\langle E_k \\rangle = 2\\pi m \\left(\\frac{a}{\\pi}\\right)^{3/2} \\frac{3}{8}\\sqrt{\\frac{\\pi}{a^5}} = 2\\pi m \\frac{a^{3/2}}{\\pi^{3/2}} \\frac{3\\pi^{1/2}}{8a^{5/2}} = \\frac{6\\pi m}{8\\pi} \\frac{1}{a} = \\frac{3m}{4a}\n$$\nSubstituting $a = \\frac{m}{2k_B T}$:\n$$\n\\langle E_k \\rangle = \\frac{3m}{4} \\left(\\frac{2k_B T}{m}\\right) = \\frac{3}{2}k_B T\n$$\nThis is the well-known result from the equipartition theorem. The true kinetic energy density is $K = n\\langle E_k \\rangle = \\frac{3}{2}nk_BT$.\n\nSecond moment, $\\langle E_k^2 \\rangle$:\n$$\n\\langle E_k^2 \\rangle = \\left\\langle \\left(\\frac{1}{2}mv^2\\right)^2 \\right\\rangle = \\frac{m^2}{4} \\langle v^4 \\rangle = \\frac{m^2}{4} \\int_0^\\infty v^4 P(v) \\, \\mathrm{d}v\n$$\n$$\n\\langle E_k^2 \\rangle = \\frac{m^2}{4} \\int_0^\\infty v^4 \\left( 4\\pi v^2 \\left(\\frac{a}{\\pi}\\right)^{3/2} \\exp(-av^2) \\right) \\, \\mathrm{d}v = \\pi m^2 \\left(\\frac{a}{\\pi}\\right)^{3/2} \\int_0^\\infty v^6 \\exp(-av^2) \\, \\mathrm{d}v\n$$\nUsing the integral formula for $n=3$, the integral is $\\frac{5!!}{2^4}\\sqrt{\\frac{\\pi}{a^7}} = \\frac{15}{16}\\sqrt{\\frac{\\pi}{a^7}}$.\n$$\n\\langle E_k^2 \\rangle = \\pi m^2 \\frac{a^{3/2}}{\\pi^{3/2}} \\frac{15\\pi^{1/2}}{16a^{7/2}} = \\frac{15\\pi m^2}{16\\pi} \\frac{1}{a^2} = \\frac{15 m^2}{16 a^2}\n$$\nSubstituting $a = \\frac{m}{2k_B T}$:\n$$\n\\langle E_k^2 \\rangle = \\frac{15 m^2}{16} \\left(\\frac{2k_B T}{m}\\right)^2 = \\frac{15 m^2}{16} \\frac{4(k_B T)^2}{m^2} = \\frac{15}{4}(k_B T)^2\n$$\nNow, we calculate the variance of $E_k$:\n$$\n\\mathrm{Var}(E_k) = \\langle E_k^2 \\rangle - \\langle E_k \\rangle^2 = \\frac{15}{4}(k_B T)^2 - \\left(\\frac{3}{2}k_B T\\right)^2 = \\frac{15}{4}(k_B T)^2 - \\frac{9}{4}(k_B T)^2 = \\frac{6}{4}(k_B T)^2 = \\frac{3}{2}(k_B T)^2\n$$\nFinally, we can write the variance of the estimator $\\hat{K}$:\n$$\n\\mathrm{Var}(\\hat{K}) = \\frac{n^2}{N} \\mathrm{Var}(E_k) = \\frac{n^2}{N} \\left(\\frac{3}{2}(k_B T)^2\\right) = \\frac{3n^2(k_B T)^2}{2N}\n$$\nThe units are $(1/\\mathrm{m}^3)^2 \\cdot (\\mathrm{J})^2 = (\\mathrm{J}/\\mathrm{m}^3)^2$, which is correct for the variance of an energy density.\n\n### Part 2: Variance-Reduction Strategy\n\nFor a full-$f$ PIC simulation that evolves in time, a powerful and widely used variance reduction technique that preserves unbiasedness is the **control variate method based on initial state subtraction**. This is sometimes referred to as a \"$\\delta f$ control variate\" method.\n\n**Proposal:**\nLet $f_0(\\mathbf{x}, \\mathbf{v})$ be the initial distribution function of the plasma, which is the Maxwell-Boltzmann distribution given in the problem, $f_0(\\mathbf{v}) = n F_{MB}(\\mathbf{v}; T)$. The initial kinetic energy density is known analytically: $K_0 = \\int (\\frac{1}{2}m|\\mathbf{v}|^2) f_0(\\mathbf{v}) \\mathrm{d}^3\\mathbf{v} = \\frac{3}{2}nk_BT$.\nThe simulation starts at time $t=0$ with $N$ particles in the cell, with velocities $\\{\\mathbf{v}_{i,0}\\}$ sampled from $F_{MB}$. The simulation then evolves these particles to a later time $t$, yielding new velocities $\\{\\mathbf{v}_{i}(t)\\}$.\n\nThe standard estimator for the kinetic energy density at time $t$ is:\n$$\n\\hat{K}(t) = \\frac{n}{N} \\sum_{i=1}^N \\frac{1}{2}m|\\mathbf{v}_i(t)|^2\n$$\nThe proposed control variate estimator, $\\hat{K}_{cv}(t)$, is:\n$$\n\\hat{K}_{cv}(t) = \\hat{K}(t) - (\\hat{K}(0) - K_0)\n$$\nwhere $\\hat{K}(0)$ is the estimator evaluated with the initial particle velocities:\n$$\n\\hat{K}(0) = \\frac{n}{N} \\sum_{i=1}^N \\frac{1}{2}m|\\mathbf{v}_{i,0}|^2\n$$\n\n**Justification:**\n1.  **Unbiasedness**: The estimator is unbiased. The expectation of $\\hat{K}(t)$ is the true kinetic energy density at time $t$, $K(t)$. The expectation of $\\hat{K}(0)$ is the true initial energy density, $K_0$, since the initial particles are sampled from $f_0$.\n    $$\n    \\mathrm{E}[\\hat{K}_{cv}(t)] = \\mathrm{E}[\\hat{K}(t)] - (\\mathrm{E}[\\hat{K}(0)] - K_0) = K(t) - (K_0 - K_0) = K(t)\n    $$\n    Thus, the estimator correctly estimates the kinetic energy density at time $t$.\n\n2.  **Variance Reduction**: The variance of the new estimator is:\n    $$\n    \\mathrm{Var}(\\hat{K}_{cv}(t)) = \\mathrm{Var}(\\hat{K}(t) - \\hat{K}(0)) = \\mathrm{Var}(\\hat{K}(t)) + \\mathrm{Var}(\\hat{K}(0)) - 2\\mathrm{Cov}(\\hat{K}(t), \\hat{K}(0))\n    $$\n    The term $\\hat{K}(t)$ is the estimate of the physical quantity at time $t$, and $\\hat{K}(0)$ is the estimate at time $0$. The term $(\\hat{K}(0) - K_0)$ represents the initial statistical sampling noise. By subtracting it, we remove this noise from the measurement at time $t$. The effectiveness of the method relies on the strong positive correlation between $\\hat{K}(t)$ and $\\hat{K}(0)$. Since the particle trajectories $\\mathbf{v}_i(t)$ evolve continuously from $\\mathbf{v}_{i,0}$, the estimators $\\hat{K}(t)$ and $\\hat{K}(0)$ are highly correlated, especially when the change in the distribution function is small. The covariance term $2\\mathrm{Cov}(\\hat{K}(t), \\hat{K}(0))$ becomes large and nearly cancels the sum of the variances, resulting in a significantly smaller variance for $\\hat{K}_{cv}(t)$ compared to $\\mathrm{Var}(\\hat{K}(t))$. This allows for the accurate measurement of small changes in kinetic energy density that would otherwise be buried in the initial sampling noise.\n\nThis strategy is a cornerstone of modern low-noise full-$f$ and $\\delta f$ PIC simulations. It effectively isolates the physical evolution of the moment from the statistical noise inherent in the initial particle loading.",
            "answer": "$$\n\\boxed{\\frac{3 n^{2} (k_{B} T)^{2}}{2N}}\n$$"
        },
        {
            "introduction": "A primary challenge in the full-f methodology is ensuring that the numerical scheme does not introduce spurious drifts in macroscopic quantities like total density and temperature over long simulation times. This practice  provides a rigorous test for such non-physical behavior, a concern that $\\delta f$ methods largely avoid by design. You will implement a simulation of a simplified kinetic model with known analytical solutions for its moments, allowing you to build a powerful verification tool to diagnose numerical inaccuracies arising from factors like finite velocity-space resolution.",
            "id": "4203284",
            "problem": "You are given the task of designing and implementing a numerical test for a simplified full-distribution function methodology in fusion plasma turbulence simulation that can detect improper drift of total density or temperature, which would not be visible in a perturbative distribution formulation. This must be done using a physically consistent model and quantified diagnostics. The test compares numerically computed moments of a discretized velocity distribution against analytic moment evolution under prescribed sources and sinks.\n\nConsider a single-species, isotropic, zero bulk flow plasma with particle mass $m$ and no spatial dependence. The full-distribution function $f(v,t)$ in speed $v$ evolves under a linear source-sink model,\n$$\n\\frac{\\partial f}{\\partial t} = \\nu_s \\left(f_S - f\\right) - \\nu_\\ell f,\n$$\nwhere $\\nu_s$ is the source rate, $\\nu_\\ell$ is the loss rate, and $f_S(v)$ is a stationary source distribution. The initial condition is a Maxwellian distribution $f(v,0)=f_M(v;n_0,T_0)$ with density $n_0$ and temperature $T_0$. The source distribution is also a Maxwellian $f_S(v)=f_M(v;n_S,T_S)$ with density $n_S$ and temperature $T_S$. The isotropic three-dimensional Maxwellian distribution function with zero bulk flow is\n$$\nf_M(v;n,T) = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{m v^2}{2 k_B T}\\right),\n$$\nwhere $k_B$ is the Boltzmann constant. Temperatures are provided in electronvolts (eV) and must be converted to energy via $k_B T = e \\, T_{\\mathrm{eV}}$, with $e$ the elementary charge. The density and energy moments of $f$ are computed as\n$$\nn(t) = \\int_0^{\\infty} 4\\pi v^2 f(v,t)\\,dv, \\quad E(t) = \\int_0^{\\infty} \\frac{1}{2} m v^2 \\, 4\\pi v^2 f(v,t)\\,dv.\n$$\nThe corresponding temperature is defined by the ideal gas relation $E(t) = \\frac{3}{2} n(t) k_B T(t)$.\n\nFor the above source-sink model, the exact evolution of the moments is\n$$\n\\mu = \\nu_s + \\nu_\\ell, \\quad n_{\\mathrm{exact}}(t) = e^{-\\mu t} n_0 + \\frac{\\nu_s}{\\mu} \\left(1 - e^{-\\mu t}\\right) n_S,\n$$\n$$\nE_{\\mathrm{exact}}(t) = e^{-\\mu t} E_0 + \\frac{\\nu_s}{\\mu} \\left(1 - e^{-\\mu t}\\right) E_S, \\quad E_0 = \\frac{3}{2} n_0 e T_0, \\quad E_S = \\frac{3}{2} n_S e T_S,\n$$\nand\n$$\nT_{\\mathrm{exact}}(t) = \\frac{E_{\\mathrm{exact}}(t)}{\\frac{3}{2} n_{\\mathrm{exact}}(t) k_B}.\n$$\n\nYour program must numerically discretize $f(v,t)$ on a finite speed domain $v \\in [0, v_{\\max}]$ with $N_v$ points, and evolve it in time using a time step $\\Delta t$ and an explicit Euler update,\n$$\nf^{n+1}(v) = f^{n}(v) + \\Delta t \\left[ \\nu_s \\left(f_S(v) - f^{n}(v)\\right) - \\nu_\\ell f^{n}(v)\\right],\n$$\nstarting from $f^0(v)=f_M(v;n_0,T_0)$ and using $f_S(v)=f_M(v;n_S,T_S)$. At each time step $t_n = n \\Delta t$, compute $n_{\\mathrm{num}}(t_n)$ and $E_{\\mathrm{num}}(t_n)$ from the discrete integrals over $v\\in[0,v_{\\max}]$ and obtain $T_{\\mathrm{num}}(t_n)$ from $E_{\\mathrm{num}}(t_n)=\\frac{3}{2} n_{\\mathrm{num}}(t_n) k_B T_{\\mathrm{num}}(t_n)$. The numerical integrals must approximate the continuous integrals above with the factor $4\\pi v^2$. The numerical units are: $m$ in kilograms, $n_0$ and $n_S$ in $\\mathrm{m}^{-3}$, $T_0$ and $T_S$ in electronvolts (eV), $\\nu_s$ and $\\nu_\\ell$ in $\\mathrm{s}^{-1}$, $t$ in seconds, and $v$ in meters per second. All computed temperatures must be reported internally in electronvolts (eV) consistent with $k_B T = e T_{\\mathrm{eV}}$, but the final outputs specified below are unitless drift measures.\n\nTo detect improper drift of total density or temperature, define the maximum relative drift measure over the simulation horizon $t \\in [0, t_{\\mathrm{end}}]$,\n$$\nD_n = \\max_{0 \\le n \\le N_t} \\left| \\frac{n_{\\mathrm{num}}(t_n) - n_{\\mathrm{exact}}(t_n)}{n_{\\mathrm{exact}}(t_n)} \\right|, \\quad\nD_T = \\max_{0 \\le n \\le N_t} \\left| \\frac{T_{\\mathrm{num}}(t_n) - T_{\\mathrm{exact}}(t_n)}{T_{\\mathrm{exact}}(t_n)} \\right|,\n$$\nwhere $N_t = t_{\\mathrm{end}}/\\Delta t$ is the number of time steps. The single scalar diagnostic per test case is\n$$\nD = \\max\\left(D_n, D_T\\right).\n$$\nA large value of $D$ indicates drift in total moments that a perturbative distribution formulation would not expose, especially when the velocity-space domain truncation or coarse resolution leads to incorrect moment capture.\n\nImplement the computation for the following test suite, which spans a well-resolved case, source-free decay, hot source with truncated domain, and coarse-grid resolution. In each case, choose $v_{\\max}$ based on a thermal speed $v_{\\mathrm{th}}(T)=\\sqrt{2 e T/m}$ associated with a relevant temperature, and set the speed grid as $N_v$ uniformly spaced points on $[0,v_{\\max}]$.\n\n- Case $1$ (well-resolved, balanced source-loss):\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$, $n_0 = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$, $T_0 = 100\\ \\mathrm{eV}$,\n  - $n_S = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$, $T_S = 100\\ \\mathrm{eV}$,\n  - $\\nu_s = 1.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$, $\\nu_\\ell = 1.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$,\n  - $v_{\\max} = 6\\, v_{\\mathrm{th}}(T_0)$, $N_v = 800$,\n  - $\\Delta t = 1.0 \\times 10^{-6}\\ \\mathrm{s}$, $t_{\\mathrm{end}} = 1.0 \\times 10^{-3}\\ \\mathrm{s}$.\n\n- Case $2$ (source-free decay, moderate truncation):\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$, $n_0 = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$, $T_0 = 500\\ \\mathrm{eV}$,\n  - $n_S = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$, $T_S = 500\\ \\mathrm{eV}$,\n  - $\\nu_s = 0\\ \\mathrm{s}^{-1}$, $\\nu_\\ell = 5.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$,\n  - $v_{\\max} = 5\\, v_{\\mathrm{th}}(T_0)$, $N_v = 400$,\n  - $\\Delta t = 1.0 \\times 10^{-6}\\ \\mathrm{s}$, $t_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n- Case $3$ (hot source, truncated domain to induce drift):\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$, $n_0 = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$, $T_0 = 300\\ \\mathrm{eV}$,\n  - $n_S = 2.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$, $T_S = 5000\\ \\mathrm{eV}$,\n  - $\\nu_s = 3.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$, $\\nu_\\ell = 1.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$,\n  - $v_{\\max} = 2\\, v_{\\mathrm{th}}(T_S)$, $N_v = 200$,\n  - $\\Delta t = 5.0 \\times 10^{-7}\\ \\mathrm{s}$, $t_{\\mathrm{end}} = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\n- Case $4$ (coarse velocity grid resolution):\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$, $n_0 = 8.0 \\times 10^{18}\\ \\mathrm{m}^{-3}$, $T_0 = 800\\ \\mathrm{eV}$,\n  - $n_S = 8.0 \\times 10^{18}\\ \\mathrm{m}^{-3}$, $T_S = 800\\ \\mathrm{eV}$,\n  - $\\nu_s = 2.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$, $\\nu_\\ell = 2.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$,\n  - $v_{\\max} = 4\\, v_{\\mathrm{th}}(T_0)$, $N_v = 50$,\n  - $\\Delta t = 5.0 \\times 10^{-7}\\ \\mathrm{s}$, $t_{\\mathrm{end}} = 5.0 \\times 10^{-4}\\ \\mathrm{s}$.\n\nYour program must compute, for each case, the single scalar diagnostic $D$ as defined above and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4]$). The outputs are dimensionless floats. All calculations and constants must be scientifically plausible and self-consistent, and the numerical integrals, evolution, and diagnostic must be implemented from first principles. No user input is allowed; the program must be self-contained.",
            "solution": "The problem statement constitutes a valid and well-posed verification test for a numerical solver. It is scientifically grounded in the principles of kinetic theory, specifically utilizing a Krook-type source-sink model for the evolution of a particle distribution function. All parameters, equations, and numerical procedures are explicitly defined, complete, and consistent. The task is to implement this test, which is designed to highlight potential failures in a full-distribution function (`full-f`) simulation methodology, such as artificial particle or energy drift due to numerical inaccuracies. These are precisely the types of errors that a simpler perturbative (`delta-f`) approach might obscure. The problem is a standard exercise in computational plasma physics code verification.\n\nThe core of the problem lies in comparing the time evolution of macroscopic moments (density and temperature) obtained from a discretized numerical simulation with their exact analytical solutions. The governing equation for the distribution function $f(v,t)$, dependent on speed $v$ and time $t$, is a linear ordinary differential equation:\n$$\n\\frac{\\partial f}{\\partial t} = \\nu_s \\left(f_S(v) - f(v,t)\\right) - \\nu_\\ell f(v,t)\n$$\nHere, $\\nu_s$ is a source rate, $\\nu_\\ell$ is a loss rate, and $f_S(v)$ is a prescribed stationary source distribution. The initial condition $f(v,0)$ and the source $f_S(v)$ are given as Maxwellian distributions:\n$$\nf_M(v;n,T) = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{m v^2}{2 k_B T}\\right)\n$$\nwhere $n$ is the density, $T$ is the temperature, $m$ is the particle mass, and $k_B$ is the Boltzmann constant. Note that the temperature $T$ in this physical formula must be in units of energy (Joules) or in Kelvin. The problem specifies input temperatures $T_{\\mathrm{eV}}$ in electronvolts, which are converted via the relation $k_B T = e T_{\\mathrm{eV}}$, where $e$ is the elementary charge.\n\nBy integrating the governing kinetic equation over velocity space, one can derive exact evolution equations for the density moment $n(t) = \\int_0^{\\infty} 4\\pi v^2 f(v,t)\\,dv$ and the energy moment $E(t) = \\int_0^{\\infty} \\frac{1}{2} m v^2 \\, 4\\pi v^2 f(v,t)\\,dv$. These evolutions are given by:\n$$\n\\frac{dn}{dt} = \\nu_s n_S - (\\nu_s + \\nu_\\ell) n(t)\n$$\n$$\n\\frac{dE}{dt} = \\nu_s E_S - (\\nu_s + \\nu_\\ell) E(t)\n$$\nWith the initial conditions $n(0)=n_0$ and $E(0)=E_0 = \\frac{3}{2} n_0 e T_0$, and defining $\\mu = \\nu_s + \\nu_\\ell$, the solutions are:\n$$\nn_{\\mathrm{exact}}(t) = n_0 e^{-\\mu t} + \\frac{\\nu_s n_S}{\\mu} \\left(1 - e^{-\\mu t}\\right)\n$$\n$$\nE_{\\mathrm{exact}}(t) = E_0 e^{-\\mu t} + \\frac{\\nu_s E_S}{\\mu} \\left(1 - e^{-\\mu t}\\right)\n$$\nwhere $E_S = \\frac{3}{2} n_S e T_S$. The exact temperature in electronvolts is then found from the ideal gas law, $E_{\\mathrm{exact}}(t) = \\frac{3}{2} n_{\\mathrm{exact}}(t) e T_{\\mathrm{exact}}(t)$.\n\nThe numerical procedure involves discretizing the velocity and time domains. The speed domain $v \\in [0, \\infty)$ is truncated to a finite interval $[0, v_{\\max}]$ and discretized into $N_v$ uniformly spaced points $v_i$ with spacing $\\Delta v$. The time evolution of the distribution function at each grid point, $f_i^n \\equiv f(v_i, t_n)$, is computed using the explicit Euler method with a time step $\\Delta t$:\n$$\nf_i^{n+1} = f_i^{n} + \\Delta t \\left[ \\nu_s \\left(f_{S,i} - f_i^{n}\\right) - \\nu_\\ell f_i^{n}\\right] = f_i^{n} (1 - \\mu \\Delta t) + \\Delta t \\nu_s f_{S,i}\n$$\nAt each time step $t_n = n\\Delta t$, the numerical moments $n_{\\mathrm{num}}(t_n)$ and $E_{\\mathrm{num}}(t_n)$ are computed by approximating the continuous integrals using a numerical quadrature rule, such as the trapezoidal rule, over the discrete velocity grid:\n$$\nn_{\\mathrm{num}}(t_n) \\approx \\sum_{i=0}^{N_v-1} w_i \\cdot 4\\pi v_i^2 f_i^n\n$$\n$$\nE_{\\mathrm{num}}(t_n) \\approx \\sum_{i=0}^{N_v-1} w_i \\cdot \\frac{1}{2} m v_i^2 \\cdot 4\\pi v_i^2 f_i^n\n$$\nwhere $w_i$ represents the quadrature weights. For the trapezoidal rule, this corresponds to `numpy.trapz`. The numerical temperature $T_{\\mathrm{num}}(t_n)$ is subsequently calculated.\n\nThe quality of the numerical solution is quantified by the diagnostic $D = \\max(D_n, D_T)$, where $D_n$ and $D_T$ are the maximum relative differences between the numerical and exact moments over the entire simulation time:\n$$\nD_n = \\max_{t_n} \\left| \\frac{n_{\\mathrm{num}}(t_n) - n_{\\mathrm{exact}}(t_n)}{n_{\\mathrm{exact}}(t_n)} \\right|, \\quad\nD_T = \\max_{t_n} \\left| \\frac{T_{\\mathrm{num}}(t_n) - T_{\\mathrm{exact}}(t_n)}{T_{\\mathrm{exact}}(t_n)} \\right|\n$$\nA small value of $D$ indicates a high-fidelity simulation where numerical errors, such as those from velocity-space truncation or coarse grid resolution, are minimal. The test cases provided are designed to probe these specific error sources. For instance, Case 3 uses a hot source distribution with a severely truncated velocity domain, which is expected to yield a large $D$, signaling a failure to capture the energy input from the source correctly. Case 4 uses a coarse velocity grid, which will lead to significant numerical integration errors. Case 1 is a well-resolved baseline, and Case 2 examines a simple decay scenario. The implementation will proceed by executing these steps for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the full-f distribution function test problem for four cases.\n    \"\"\"\n    # Physical constants\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs\n    BOLTZMANN_K = 1.380649e-23   # Boltzmann constant in J/K\n\n    test_cases = [\n        # Case 1: well-resolved, balanced source-loss\n        {\n            \"m\": 3.344e-27, \"n0\": 1.0e19, \"T0_eV\": 100.0,\n            \"nS\": 1.0e19, \"TS_eV\": 100.0,\n            \"nu_s\": 1.0e4, \"nu_l\": 1.0e4,\n            \"vmax_factor\": 6.0, \"vmax_T_ref\": \"T0\", \"Nv\": 800,\n            \"dt\": 1.0e-6, \"t_end\": 1.0e-3\n        },\n        # Case 2: source-free decay, moderate truncation\n        {\n            \"m\": 3.344e-27, \"n0\": 1.0e19, \"T0_eV\": 500.0,\n            \"nS\": 1.0e19, \"TS_eV\": 500.0,\n            \"nu_s\": 0.0, \"nu_l\": 5.0e4,\n            \"vmax_factor\": 5.0, \"vmax_T_ref\": \"T0\", \"Nv\": 400,\n            \"dt\": 1.0e-6, \"t_end\": 1.0e-4\n        },\n        # Case 3: hot source, truncated domain to induce drift\n        {\n            \"m\": 3.344e-27, \"n0\": 1.0e19, \"T0_eV\": 300.0,\n            \"nS\": 2.0e19, \"TS_eV\": 5000.0,\n            \"nu_s\": 3.0e4, \"nu_l\": 1.0e4,\n            \"vmax_factor\": 2.0, \"vmax_T_ref\": \"TS\", \"Nv\": 200,\n            \"dt\": 5.0e-7, \"t_end\": 5.0e-4\n        },\n        # Case 4: coarse velocity grid resolution\n        {\n            \"m\": 3.344e-27, \"n0\": 8.0e18, \"T0_eV\": 800.0,\n            \"nS\": 8.0e18, \"TS_eV\": 800.0,\n            \"nu_s\": 2.0e4, \"nu_l\": 2.0e4,\n            \"vmax_factor\": 4.0, \"vmax_T_ref\": \"T0\", \"Nv\": 50,\n            \"dt\": 5.0e-7, \"t_end\": 5.0e-4\n        },\n    ]\n\n    results = []\n\n    def thermal_speed(T_eV, m):\n        \"\"\"Calculates thermal speed from temperature in eV.\"\"\"\n        return np.sqrt(2 * E_CHARGE * T_eV / m)\n\n    def maxwellian_f(v, n, T_eV, m):\n        \"\"\"Calculates Maxwellian distribution.\"\"\"\n        T_K = T_eV * E_CHARGE / BOLTZMANN_K\n        if T_K == 0: return np.zeros_like(v)\n        # Handle potential overflow in normalization factor if T_K is very small\n        # Although problem parameters avoid this, it is good practice.\n        norm_factor = n * (m / (2 * np.pi * BOLTZMANN_K * T_K))**1.5\n        exponent = -m * v**2 / (2 * BOLTZMANN_K * T_K)\n        return norm_factor * np.exp(exponent)\n\n    for case in test_cases:\n        m, n0, T0_eV = case[\"m\"], case[\"n0\"], case[\"T0_eV\"]\n        nS, TS_eV = case[\"nS\"], case[\"TS_eV\"]\n        nu_s, nu_l = case[\"nu_s\"], case[\"nu_l\"]\n        vmax_factor, vmax_T_ref, Nv = case[\"vmax_factor\"], case[\"vmax_T_ref\"], case[\"Nv\"]\n        dt, t_end = case[\"dt\"], case[\"t_end\"]\n\n        # Setup parameters\n        mu = nu_s + nu_l\n        E0 = 1.5 * n0 * E_CHARGE * T0_eV\n        ES = 1.5 * nS * E_CHARGE * TS_eV\n\n        ref_T_for_vmax = T0_eV if vmax_T_ref == \"T0\" else TS_eV\n        v_max = vmax_factor * thermal_speed(ref_T_for_vmax, m)\n        v_grid = np.linspace(0, v_max, Nv)\n\n        Nt = int(np.round(t_end / dt))\n        time_pts = np.linspace(0, t_end, Nt + 1)\n        \n        # Initialize distribution function\n        f_n = maxwellian_f(v_grid, n0, T0_eV, m)\n        f_S = maxwellian_f(v_grid, nS, TS_eV, m)\n\n        n_num_hist, T_num_hist = [], []\n        n_exact_hist, T_exact_hist = [], []\n\n        # Time evolution loop\n        for t in time_pts:\n            # --- Analytical Solution ---\n            exp_mu_t = np.exp(-mu * t)\n            \n            # Handle case where mu=0 to avoid division by zero\n            if mu == 0:\n                n_exact = n0 + nu_s * nS * t\n                E_exact = E0 + nu_s * ES * t\n            else:\n                n_exact = n0 * exp_mu_t + (nu_s * nS / mu) * (1 - exp_mu_t)\n                E_exact = E0 * exp_mu_t + (nu_s * ES / mu) * (1 - exp_mu_t)\n            \n            # T_exact is in eV\n            T_exact = E_exact / (1.5 * n_exact * E_CHARGE) if n_exact > 0 else 0.0\n\n            n_exact_hist.append(n_exact)\n            T_exact_hist.append(T_exact)\n\n            # --- Numerical Solution ---\n            integrand_n = 4 * np.pi * v_grid**2 * f_n\n            n_num = np.trapz(integrand_n, v_grid)\n            \n            integrand_E = 0.5 * m * v_grid**2 * integrand_n\n            E_num = np.trapz(integrand_E, v_grid)\n\n            # T_num is in eV\n            T_num = E_num / (1.5 * n_num * E_CHARGE) if n_num > 0 else 0.0\n\n            n_num_hist.append(n_num)\n            T_num_hist.append(T_num)\n\n            # --- Update distribution function using Explicit Euler ---\n            f_n = f_n * (1 - mu * dt) + dt * nu_s * f_S\n\n        # Calculate diagnostics\n        n_num_hist = np.array(n_num_hist)\n        T_num_hist = np.array(T_num_hist)\n        n_exact_hist = np.array(n_exact_hist)\n        T_exact_hist = np.array(T_exact_hist)\n        \n        # Avoid division by zero if exact value is zero (though not expected here)\n        # Use np.divide with a 'where' clause for robustness\n        with np.errstate(divide='ignore', invalid='ignore'):\n            rel_err_n = np.abs((n_num_hist - n_exact_hist) / n_exact_hist)\n            rel_err_T = np.abs((T_num_hist - T_exact_hist) / T_exact_hist)\n        \n        # Replace NaNs or Infs from division-by-zero with 0.0\n        rel_err_n[~np.isfinite(rel_err_n)] = 0.0\n        rel_err_T[~np.isfinite(rel_err_T)] = 0.0\n        \n        D_n = np.max(rel_err_n)\n        D_T = np.max(rel_err_T)\n\n        D = max(D_n, D_T)\n        results.append(D)\n    \n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With an understanding of the numerical foundations and verification of the full-f method, the final step is to use it for physical discovery. This exercise  walks you through a crucial step in this process: post-processing simulation data to analyze the properties of plasma turbulence. You will construct a frequency-wavenumber spectral diagnostic, a standard tool in the field, to identify the dominant modes of fluctuation in synthetic data and classify them based on their propagation characteristics, bridging the gap from raw data to physical interpretation.",
            "id": "4203273",
            "problem": "You are tasked with designing a frequency–wavenumber diagnostic for fluctuations generated by the full-distribution-function methodology (\"full-f\" simulation) in magnetically confined fusion plasma turbulence. The goal is to extract the dominant spectral peaks from synthetic full-f fluctuation data and classify them as Ion Temperature Gradient (ITG) or Trapped Electron Mode (TEM) based on propagation direction in the binormal wavenumber direction. Implement the diagnostic as a complete, runnable program that produces the required outputs for the specified test suite, following all instructions below.\n\nBegin from first principles and core definitions appropriate to fusion plasma turbulence:\n\n- The full-distribution-function (\"full-f\") methodology evolves the entire distribution function of particles, rather than only its fluctuations, under the kinetic equations. For a collisionless electrostatic fluctuation, the Vlasov equation for the distribution function $f$ can be written in a simplified form as\n  $$\\frac{\\partial f}{\\partial t} + \\mathbf{v}\\cdot \\nabla f + \\frac{q}{m}\\left(\\mathbf{E} + \\mathbf{v}\\times\\mathbf{B}\\right)\\cdot \\frac{\\partial f}{\\partial \\mathbf{v}} = 0,$$\n  where $q$ is charge, $m$ is mass, $\\mathbf{E}$ is electric field, and $\\mathbf{B}$ is magnetic field. In the full-f methodology, one often analyzes the fluctuation of an observable (e.g., density, potential) extracted from $f$ as a function of binormal coordinate $y$ and time $t$.\n- The frequency–wavenumber spectrum is defined via the two-dimensional Fourier transform. For a fluctuation signal $s(y,t)$, define the continuous transform\n  $$S(k,\\omega) = \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} s(y,t)\\,e^{-i(ky - \\omega t)}\\,dy\\,dt,$$\n  and the corresponding power spectral density\n  $$P(k,\\omega) = |S(k,\\omega)|^2.$$\n  Numerically, we will use the discrete Fourier transform on a uniformly sampled grid and apply separable windowing to reduce spectral leakage.\n\nPhysical interpretive criteria to connect spectra to mode identification:\n\n- Ion Temperature Gradient (ITG) modes are drift waves driven predominantly by ion temperature gradients and tend to propagate in the ion diamagnetic direction (binormal propagation). Trapped Electron Mode (TEM) modes are driven by electron dynamics and propagate in the electron diamagnetic direction. For the purposes of this diagnostic, classify a spectral peak by the sign of its phase velocity\n  $$v_{\\mathrm{ph}} = \\frac{\\omega}{k},$$\n  relative to the known directed binormal diamagnetic propagation signs. Let $s_i \\in \\{-1,+1\\}$ denote the sign of the ion diamagnetic direction and $s_e \\in \\{-1,+1\\}$ the sign of the electron diamagnetic direction. If $\\mathrm{sign}(v_{\\mathrm{ph}}) = s_i$, classify as ITG; if $\\mathrm{sign}(v_{\\mathrm{ph}}) = s_e$, classify as TEM; otherwise classify as ambiguous.\n- Because real-valued signals produce symmetric spectral peaks at $(k,\\omega)$ and $(-k,-\\omega)$, restrict peak search to $k>0$ to avoid trivial symmetry duplicates. If multiple peaks share the same maximum power within numerical tolerance in the $k>0$ half-plane, label the case as ambiguous.\n\nConstruct synthetic full-f fluctuation data and implement the diagnostic as follows:\n\n1. Define a uniform spatial grid in the binormal direction with $N_y$ points over a domain length $L_y$ (in meters), and a uniform temporal grid with $N_t$ points over duration $T$ (in seconds). Let the discrete coordinates be $y_j$ for $j=0,\\dots,N_y-1$ and $t_n$ for $n=0,\\dots,N_t-1$.\n2. For each test case, generate a signal\n   $$s(y,t) = \\sum_{p=1}^{N_{\\mathrm{waves}}} A_p \\cos(k_p y - \\omega_p t + \\phi_p) + \\eta(y,t),$$\n   where $A_p$ is amplitude (dimensionless), $k_p$ is wavenumber (in rad/m), $\\omega_p$ is angular frequency (in rad/s), $\\phi_p$ is phase (in radians), and $\\eta(y,t)$ is additive zero-mean Gaussian noise with specified standard deviation $\\sigma$ (same units as $s$). Use a reproducible noise seed and apply separable Hann window functions in both $y$ and $t$ prior to the Fourier transform.\n3. Compute the discrete two-dimensional Fourier transform of the windowed data to obtain $S(k,\\omega)$ on the discrete grids\n   $$k_m = \\frac{2\\pi}{L_y} m,\\quad m = -\\frac{N_y}{2},\\dots,\\frac{N_y}{2}-1,$$\n   $$\\omega_\\ell = \\frac{2\\pi}{T} \\ell,\\quad \\ell = -\\frac{N_t}{2},\\dots,\\frac{N_t}{2}-1.$$\n   Use the definition of the discrete Fourier transform consistent with the above continuous definitions and compute the power spectral density $P(k,\\omega) = |S(k,\\omega)|^2$.\n4. Restrict the peak search to $k>0$. Identify the maximum power $P_{\\max}$ and the set of indices $(k^*,\\omega^*)$ where $P(k^*,\\omega^*)$ attains $P_{\\max}$ within a small tolerance. If there is more than one such $(k^*,\\omega^*)$ with $k^*>0$, classify the case as ambiguous. Otherwise, compute $v_{\\mathrm{ph}} = \\omega^*/k^*$ and classify the dominant mode according to the diamagnetic signs $s_i$ and $s_e$ defined in the test case.\n5. Handle boundary conditions: if $|k^*|$ or $|\\omega^*|$ is below a resolution threshold set by the grid spacing (e.g., below half a bin), classify as ambiguous.\n\nImplement the program to evaluate the following test suite. All angular frequencies must be in rad/s, wavenumbers in rad/m, phases in radians, spatial domain lengths in meters, and temporal durations in seconds. For numerical stability and interpretability, the provided $k_p$ and $\\omega_p$ values coincide with exact discrete frequency bins of the chosen grids.\n\nLet $L_y = 10.0$ and $T = 1.0$. Let $N_y = 256$ and $N_t = 512$. Let $\\sigma = 0.10$ and use a fixed random seed. For all cases, set the ion diamagnetic sign $s_i = -1$ and the electron diamagnetic sign $s_e = +1$.\n\nDefine the wavenumber bin increment $\\Delta k = \\frac{2\\pi}{L_y}$ and the angular frequency bin increment $\\Delta \\omega = \\frac{2\\pi}{T}$.\n\n- Test Case 1 (single ITG-like wave):\n  - Waves: one with $A_1 = 1.0$, $k_1 = 5\\Delta k = 3.141592653589793$ rad/m, $\\omega_1 = -2\\Delta \\omega = -12.566370614359172$ rad/s, $\\phi_1 = 0.2$ radians.\n- Test Case 2 (single TEM-like wave):\n  - Waves: one with $A_1 = 0.8$, $k_1 = 4\\Delta k = 2.5132741228718345$ rad/m, $\\omega_1 = +1\\Delta \\omega = 6.283185307179586$ rad/s, $\\phi_1 = 1.0$ radians.\n- Test Case 3 (mixed equal-amplitude counter-propagating at same $k$ leading to ambiguity):\n  - Waves: two with $A_1 = 1.0$, $k_1 = 6\\Delta k = 3.7699111843077517$ rad/m, $\\omega_1 = +3\\Delta \\omega = 18.84955592153876$ rad/s, $\\phi_1 = 0.5$ radians; and $A_2 = 1.0$, $k_2 = 6\\Delta k = 3.7699111843077517$ rad/m, $\\omega_2 = -3\\Delta \\omega = -18.84955592153876$ rad/s, $\\phi_2 = -0.3$ radians.\n- Test Case 4 (near-Nyquist, high-frequency TEM-like wave):\n  - Waves: one with $A_1 = 0.6$, $k_1 = 120\\Delta k = 75.39822368615503$ rad/m, $\\omega_1 = 200\\Delta \\omega = 1256.6370614359173$ rad/s, $\\phi_1 = -1.2$ radians.\n\nYour program must construct the signals for each test case, compute the two-dimensional discrete Fourier transform with Hann windowing, extract the dominant $(k^*,\\omega^*)$ in the half-plane $k>0$, compute the phase velocity $v_{\\mathrm{ph}} = \\omega^*/k^*$, and classify the mode according to the sign rules stated above. If multiple $(k^*,\\omega^*)$ attain the same maximum power within tolerance in $k>0$, or if $|k^*|$ or $|\\omega^*|$ is below half a bin resolution, return the ambiguous classification.\n\nFinal output format requirement:\n\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list of integers enclosed in square brackets, where $1$ denotes ITG, $2$ denotes TEM, and $0$ denotes ambiguous (e.g., \"[1,2,0,2]\").\n\nNo user input is allowed; all parameters must be hard-coded as specified. The implementation must be physically and numerically self-consistent and must adhere to the described definitions and criteria.",
            "solution": "The problem requires the design and implementation of a frequency–wavenumber diagnostic for synthetic fluctuation data, simulating output from a full-distribution-function (\"full-f\") plasma turbulence code. The objective is to identify the dominant spectral mode and classify it as an Ion Temperature Gradient (ITG) mode or a Trapped Electron Mode (TEM) based on its propagation direction. The analysis will be performed on a series of test cases.\n\nThe problem statement is validated as scientifically grounded, well-posed, and complete. It is based on established principles of plasma kinetic theory, Fourier analysis, and numerical signal processing. All parameters and conditions required for a unique solution are provided. We may therefore proceed with the solution.\n\nThe core of the diagnostic lies in transforming the signal from the spatiotemporal domain $(y, t)$ to the frequency–wavenumber domain $(k, \\omega)$, where wave modes appear as distinct peaks in the power spectrum.\n\nFirst, we define the mathematical and physical framework. A fluctuation, represented by a real-valued signal $s(y,t)$, is defined on a two-dimensional grid. The binormal spatial coordinate is $y \\in [0, L_y)$ and the time coordinate is $t \\in [0, T)$. The signal is composed of a superposition of coherent wave-like structures and a stochastic noise component:\n$$\ns(y,t) = \\sum_{p=1}^{N_{\\mathrm{waves}}} A_p \\cos(k_p y - \\omega_p t + \\phi_p) + \\eta(y,t)\n$$\nHere, for each wave component $p$, $A_p$ is the amplitude, $k_p$ is the wavenumber, $\\omega_p$ is the angular frequency, and $\\phi_p$ is a constant phase offset. The term $\\eta(y,t)$ represents zero-mean Gaussian noise with a standard deviation $\\sigma$.\n\nThe primary analytical tool is the two-dimensional Fourier transform, which decomposes the signal into its constituent frequencies and wavenumbers. The continuous Fourier transform is given by:\n$$\nS(k,\\omega) = \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} s(y,t)\\,e^{-i(ky - \\omega t)}\\,dy\\,dt\n$$\nThe power spectral density, $P(k,\\omega) = |S(k,\\omega)|^2$, quantifies the distribution of signal power in the $(k, \\omega)$ plane. Peaks in this spectrum correspond to the dominant wave modes in the signal.\n\nNumerically, the signal is sampled on a discrete grid: $y_j = j \\frac{L_y}{N_y}$ for $j=0, \\dots, N_y-1$ and $t_n = n \\frac{T}{N_t}$ for $n=0, \\dots, N_t-1$. The continuous Fourier transform is replaced by the two-dimensional Discrete Fourier Transform (DFT), efficiently computed via the Fast Fourier Transform (FFT) algorithm. The corresponding discrete wavenumbers and frequencies are:\n$$\nk_m = \\frac{2\\pi}{L_y} m, \\quad m \\in \\{-\\frac{N_y}{2}, \\dots, \\frac{N_y}{2}-1\\}\n$$\n$$\n\\omega_\\ell = \\frac{2\\pi}{T} \\ell, \\quad \\ell \\in \\{-\\frac{N_t}{2}, \\dots, \\frac{N_t}{2}-1\\}\n$$\nThe fundamental resolution bins are $\\Delta k = 2\\pi/L_y$ and $\\Delta \\omega = 2\\pi/T$.\n\nA critical step in numerical spectral analysis is the application of a window function. Since the DFT assumes the signal is periodic over the domain, any discontinuity between the start and end of the finite signal creates spectral leakage, where power from a single frequency \"leaks\" into adjacent frequency bins. To mitigate this, we multiply the signal by a window function that smoothly tapers to zero at the boundaries. A separable two-dimensional Hann window is used:\n$$\nw(y_j, t_n) = \\left(\\frac{1}{2} - \\frac{1}{2}\\cos\\frac{2\\pi j}{N_y}\\right) \\left(\\frac{1}{2} - \\frac{1}{2}\\cos\\frac{2\\pi n}{N_t}\\right)\n$$\nThe DFT is then performed on the windowed signal $s'(y_j, t_n) = s(y_j, t_n) \\cdot w(y_j, t_n)$.\n\nThe mode classification is based on the phase velocity, $v_{\\mathrm{ph}} = \\omega/k$. In a simplified model of tokamak turbulence, ITG modes propagate in the ion diamagnetic direction, while TEMs propagate in the electron diamagnetic direction. These directions are specified by signs $s_i$ and $s_e$. For this problem, $s_i = -1$ and $s_e = +1$, corresponding to negative and positive phase velocities, respectively.\nSince the signal $s(y,t)$ is real-valued, its Fourier spectrum exhibits Hermitian symmetry: $S(k, \\omega) = S^*(-k, -\\omega)$, which implies $P(k, \\omega) = P(-k, -\\omega)$. Therefore, all unique information is contained in one half of the $k$-plane. We restrict our search for the dominant mode to the $k > 0$ half-plane. For a peak found at $(k^*, \\omega^*)$ with $k^* > 0$, the sign of the phase velocity is simply the sign of the frequency, $\\mathrm{sign}(v_{\\mathrm{ph}}) = \\mathrm{sign}(\\omega^*)$.\n\nThe classification logic is as follows:\n1.  Find the location $(k^*, \\omega^*)$ of the maximum power $P_{\\max}$ in the power spectrum, restricting the search to $k > 0$.\n2.  Check for ambiguity. An ambiguous case is declared if:\n    a. More than one $(k, \\omega)$ pair in the search domain has power equal to $P_{\\max}$ within a numerical tolerance. This handles cases like counter-propagating modes of equal strength.\n    b. The dominant mode is located at zero frequency (i.e., $\\omega^*=0$), which corresponds to falling below the frequency resolution threshold of $0.5 \\Delta \\omega$. Phase velocity is ill-defined in this case. The condition on $k^*$ is naturally satisfied by searching for $k>0$.\n3.  If the mode is unambiguous, classify it:\n    -   If $\\mathrm{sign}(\\omega^*) = s_i$, it is an ITG mode (assigned code $1$).\n    -   If $\\mathrm{sign}(\\omega^*) = s_e$, it is a TEM mode (assigned code $2$).\n    -   If neither condition is met (which shouldn't happen for non-zero $\\omega^*$), it is ambiguous (code $0$).\n\nThe implementation will proceed by constructing the signal for each test case, applying the Hann window, performing the 2D FFT, calculating the power spectrum, and executing the peak-finding and classification logic described above. A fixed random seed ensures the reproducibility of the noise component.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a frequency-wavenumber diagnostic for synthetic plasma\n    fluctuation data to classify dominant turbulence modes.\n    \"\"\"\n    # Global parameters as specified in the problem statement\n    Ly = 10.0  # meters\n    T = 1.0    # seconds\n    Ny = 256   # spatial grid points\n    Nt = 512   # temporal grid points\n    sigma = 0.10 # standard deviation of Gaussian noise\n    random_seed = 42 # for reproducible noise\n    \n    # Diamagnetic direction signs\n    s_i = -1  # ion diamagnetic direction sign\n    s_e = +1  # electron diamagnetic direction sign\n    \n    # Fundamental frequency and wavenumber bins\n    delta_k = 2.0 * np.pi / Ly\n    delta_omega = 2.0 * np.pi / T\n\n    # Test case definitions\n    test_cases = [\n        # Case 1: Single ITG-like wave\n        [{'A': 1.0, 'k': 5 * delta_k, 'omega': -2 * delta_omega, 'phi': 0.2}],\n        # Case 2: Single TEM-like wave\n        [{'A': 0.8, 'k': 4 * delta_k, 'omega': 1 * delta_omega, 'phi': 1.0}],\n        # Case 3: Mixed equal-amplitude counter-propagating waves\n        [\n            {'A': 1.0, 'k': 6 * delta_k, 'omega': 3 * delta_omega, 'phi': 0.5},\n            {'A': 1.0, 'k': 6 * delta_k, 'omega': -3 * delta_omega, 'phi': -0.3}\n        ],\n        # Case 4: Near-Nyquist, high-frequency TEM-like wave\n        [{'A': 0.6, 'k': 120 * delta_k, 'omega': 200 * delta_omega, 'phi': -1.2}]\n    ]\n    \n    results = []\n    \n    # Create spatial and temporal grids\n    y = np.linspace(0, Ly, Ny, endpoint=False)\n    t = np.linspace(0, T, Nt, endpoint=False)\n    yy, tt = np.meshgrid(y, t)\n\n    # Create frequency and wavenumber axes for analysis\n    k_axis = np.fft.fftshift(np.fft.fftfreq(Ny, d=Ly/Ny) * 2.0 * np.pi)\n    omega_axis = np.fft.fftshift(np.fft.fftfreq(Nt, d=T/Nt) * 2.0 * np.pi)\n\n    # Initialize random number generator\n    rng = np.random.default_rng(random_seed)\n\n    for waves in test_cases:\n        # 1. Generate signal\n        signal = np.zeros((Nt, Ny))\n        for wave in waves:\n            signal += wave['A'] * np.cos(wave['k'] * yy - wave['omega'] * tt + wave['phi'])\n        \n        # Add reproducible Gaussian noise\n        noise = rng.normal(loc=0.0, scale=sigma, size=(Nt, Ny))\n        signal += noise\n        \n        # 2. Apply separable Hann window\n        hann_y = np.hanning(Ny)\n        hann_t = np.hanning(Nt)\n        window = np.outer(hann_t, hann_y)\n        signal_windowed = signal * window\n        \n        # 3. Compute 2D FFT and Power Spectral Density\n        S = np.fft.fft2(signal_windowed)\n        # Shift the zero-frequency component to the center of the spectrum\n        S_shifted = np.fft.fftshift(S)\n        P_shifted = np.abs(S_shifted)**2\n        \n        # 4. Peak search and classification\n        \n        # Restrict search to k > 0\n        k_positive_start_idx = Ny // 2 + 1\n        search_region = P_shifted[:, k_positive_start_idx:]\n        \n        if search_region.size == 0:\n            results.append(0) # Ambiguous if no k>0 region\n            continue\n\n        P_max = np.max(search_region)\n        \n        # Ambiguity check 1: multiple peaks with the same max power\n        # Use a relative tolerance to account for floating point inaccuracies.\n        peak_indices = np.argwhere(np.isclose(search_region, P_max, rtol=1e-3))\n        \n        if len(peak_indices) > 1:\n            results.append(0) # Ambiguous\n            continue\n\n        # Single dominant peak found\n        idx_omega_shifted, idx_k_sub = peak_indices[0]\n        \n        # Convert sub-region k index to full spectrum index\n        idx_k_shifted = idx_k_sub + k_positive_start_idx\n        \n        omega_star = omega_axis[idx_omega_shifted]\n        k_star = k_axis[idx_k_shifted]\n\n        # Ambiguity check 2: peak at or below resolution threshold\n        # |k*| < 0.5*delta_k is impossible due to k>0 search.\n        # Check if |omega*| < 0.5*delta_omega, which means omega* = 0.\n        if np.isclose(omega_star, 0.0, atol=1e-9):\n            results.append(0) # Ambiguous\n            continue\n\n        # 5. Classify the mode\n        sign_v_ph = np.sign(omega_star) # since k_star > 0\n\n        if sign_v_ph == s_i:\n            results.append(1) # ITG\n        elif sign_v_ph == s_e:\n            results.append(2) # TEM\n        else:\n            results.append(0) # Ambiguous\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}