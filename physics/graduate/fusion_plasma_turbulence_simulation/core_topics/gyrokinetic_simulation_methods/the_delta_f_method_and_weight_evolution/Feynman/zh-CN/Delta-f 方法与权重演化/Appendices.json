{
    "hands_on_practices": [
        {
            "introduction": "在 $\\delta f$ 模拟中，计算标记点的初始放置并非小事，因为它直接决定了整个模拟的初始“本底噪声”。本练习将让您通过编程实践，直观地比较随机初始化和“静默启动”在噪声频谱上的根本差异。更重要的是，您将量化这个噪声平台如何影响对线性不稳定增长率等关键物理量的精确测量，从而深刻理解噪声控制在信号提取中的重要性。",
            "id": "4202444",
            "problem": "考虑一个长度为 $L$ 的一维周期性静电系统，该系统通过 delta 扰动分布函数方法（delta-f 方法）中的一大组计算标记点来表示，其中总分布函数被分解为 $f(\\mathbf{x},\\mathbf{v},t) = f_0(\\mathbf{v}) + \\delta f(\\mathbf{x},\\mathbf{v},t)$，扰动由标记点承载的权重 $w_a(t)$ 表示，标记点的位置为 $x_a(t)$，速度为 $v_a(t)$。对于波数为 $k$ 的单个 Fourier 模式，其线性响应可以通过场振幅 $A_k(t)$ 来表征，该振幅在早期以指数形式增长，即 $A_k(t) = A_0 e^{\\gamma t}$，增长率为 $\\gamma$。\n\n在数值实现中，测量的模式振幅是通过将标记点的贡献投影到 Fourier 分量上得到的：$A_k^{\\text{meas}}(t) \\propto \\left| \\frac{1}{M} \\sum_{a=1}^M w_a(t) e^{-i k x_a(t)} \\right|$，这是通过一阶云中单元 (Cloud-In-Cell, CIC) 形函数将贡献沉积到具有 $G$ 个点的场网格上之后得到的。CIC 谱形函数为 $S(k) = \\left( \\frac{\\sin(k \\Delta x/2)}{k \\Delta x/2} \\right)^2$，其中 $\\Delta x = L/G$。\n\n从基本的 Vlasov-Poisson 方程组和 delta-f 方法的核心定义出发，即标记点权重根据线性化的特征方程 $\\frac{dw_a}{dt} = \\mathcal{S}(x_a(t),v_a(t),t)$ 演化，其中 $\\mathcal{S}$ 是一个与场成正比的源泛函。假设在早期，场遵循 $A_k(t) = A_0 e^{\\gamma t}$（其中 $A_0 > 0$），并且标记点轨道保持在其初始位置附近，因此在所考虑的时间窗口内有 $x_a(t) \\approx x_a(0)$。\n\n您必须：\n\n1. 从离散采样的第一性原理出发，推导在静默启动 (quiet-start) 中初始噪声的离散 $k$ 谱，其中标记点位置均匀分布 $x_a(0) = L(a-1)/M$，速度对称配对以使初始权重为零，$w_a(0) = 0$。证明静默启动的初始密度采样在 Fourier 空间中产生一个 Dirac 梳状函数，并且，当投影到允许的物理模式 $k_m = 2\\pi m / L$（$m$ 为整数）上时，离散和 $\\frac{1}{M} \\sum_{a=1}^M e^{-i k_m x_a(0)}$ 对于 $m \\not\\equiv 0 \\ (\\text{mod } M)$ 恒等于零，并且仅在混叠波数 $k = 2\\pi n M/L$（$n$ 为整数）处非零。通过乘法形式的形函数 $S(k)$ 来包含 CIC 沉积的影响。\n\n2. 将此与随机启动 (random-start) 进行对比，其中 $x_a(0)$ 在 $[0,L)$ 上独立均匀分布，且 $w_a(0)=0$。推导离散 Fourier 系数 $\\frac{1}{M} \\sum_{a=1}^M e^{-i k x_a(0)}$ 在 $k \\neq 0$ 时的期望均方根振幅，并证明它遵循 Rayleigh 分布，在应用 CIC 形函数之前的期望幅值为 $\\mathbb{E}\\{|A_{\\text{noise}}(k)|\\} = \\sqrt{\\frac{\\pi}{2M}}$，因此有 $|A_{\\text{noise}}(k)| \\approx S(k)\\sqrt{\\frac{\\pi}{2M}}$。\n\n3. 利用以上结果，设计一种算法来量化噪声谱对从 $A_k^{\\text{meas}}(t)$ 中提取早期增长率的影响。具体来说，假设测量的振幅可以建模为目标模式 $k$ 上真实信号与静态噪声基底的非相干组合：\n$$\nA_k^{\\text{meas}}(t) = \\sqrt{A_k(t)^2 + A_{\\text{noise}}(k)^2}\n$$\n解释为什么在此模型下，当 $A_{\\text{noise}}(k)$ 非零时，对早期时间窗口内的 $\\ln A_k^{\\text{meas}}(t)$ 与 $t$ 进行最小二乘拟合会产生一个有偏的 $\\gamma$ 估计值。\n\n您的程序必须实现推导出的公式，以计算静默启动和随机启动的 $A_{\\text{noise}}(k)$，为一组给定的参数生成测量的振幅时间序列 $A_k^{\\text{meas}}(t)$，并通过对 $\\ln A_k^{\\text{meas}}(t)$ 与 $t$ 进行最小二乘拟合来返回线性增长率的估计值。\n\n物理和数值单位：$L$ 的单位必须是米， $t$ 的单位是秒，$\\gamma$ 的单位是秒的倒数。以浮点数形式表示最终估计的增长率，单位为秒的倒数 (1/s)。\n\n测试套件：\n- 案例 1（正常路径，静默启动，低模式）：$L = 1$ 米， $G = 128$， $M = 256$， $m = 4$， $A_0 = 0.01$ (无单位振幅)， $\\gamma = 800$ 1/s， $t \\in \\{0, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006\\}$ 秒。使用静默启动噪声：$A_{\\text{noise}}(k_m) = S(k_m) \\times \\left[ \\frac{1}{M} \\sum_{a=1}^M e^{-i k_m x_a(0)} \\right]$，其中如果 $m \\not\\equiv 0 \\ (\\text{mod } M)$，方括号中的和为 $0$，否则为 $1$。\n\n- 案例 2（随机启动，与案例 1 分辨率相同）：$L = 1$ 米， $G = 128$， $M = 256$， $m = 4$， $A_0 = 0.01$， $\\gamma = 800$ 1/s， $t$ 同上。使用随机启动噪声幅值 $A_{\\text{noise}}(k_m) = S(k_m)\\sqrt{\\pi/(2M)}$。\n\n- 案例 3（随机启动，更大的 $M$ 会降低噪声）：$L = 1$ 米， $G = 128$， $M = 4096$， $m = 4$， $A_0 = 0.01$， $\\gamma = 800$ 1/s， $t$ 同上。使用随机启动噪声幅值 $A_{\\text{noise}}(k_m) = S(k_m)\\sqrt{\\pi/(2M)}$。\n\n- 案例 4（静默启动中的边缘混叠条件）：$L = 1$ 米， $G = 128$， $M = 300$， $m = 300$， $A_0 = 0.01$， $\\gamma = 800$ 1/s， $t$ 同上。使用带有混叠的静默启动噪声：$A_{\\text{noise}}(k_m) = S(k_m) \\times 1$，因为 $m \\equiv 0 \\ (\\text{mod } M)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个案例的估计增长率，格式为方括号括起来的逗号分隔列表，单位为 $1/\\text{s}$（例如 $[r_1,r_2,r_3,r_4]$）。每个 $r_i$ 都必须是浮点数。",
            "solution": "该问题已经过验证，被确定为计算等离子体物理学中一个提法恰当且具有科学依据的练习。它准确地反映了 delta-f 粒子模拟 (particle-in-cell) 领域的标准概念和挑战，例如由离散粒子表示引起的数值噪声及其对物理测量的影响。\n\n### 1. 静默启动初始噪声谱的推导\n\n在 delta-f 方法中，粒子分布函数被分解为一个背景分量和一个扰动，$f = f_0 + \\delta f$。扰动 $\\delta f$ 由大量（$M$个）计算标记点所承载的权重 $w_a$ 表示。对于给定粒子种类，在波数为 $k$ 的 Fourier 模式下的电荷密度与标记点总和成正比：$\\rho_k \\propto \\sum_{a=1}^M w_a e^{-i k x_a}$。\n\n问题引导我们分析初始标记点*位置*的离散 $k$ 谱，它作为数值噪声的种子。初始权重给定为 $w_a(0)=0$。初始噪声特性由初始标记点密度的 Fourier 变换决定，该密度由 $\\mathcal{D}(x) = \\sum_{a=1}^M \\delta(x-x_a(0))$ 给出。其离散 Fourier 系数（按标记点数量归一化）为：\n$$\nC(k) = \\frac{1}{M} \\sum_{a=1}^M e^{-i k x_a(0)}\n$$\n对于静默启动，标记点在均匀网格上初始化：$x_a(0) = L(a-1)/M$，其中 $a \\in \\{1, 2, \\dots, M\\}$。我们对物理模式 $k_m = 2\\pi m / L$（$m$ 为整数）计算这个和。\n$$\nC(k_m) = \\frac{1}{M} \\sum_{a=1}^M e^{-i \\left(\\frac{2\\pi m}{L}\\right) \\left(\\frac{L(a-1)}{M}\\right)} = \\frac{1}{M} \\sum_{a=1}^M e^{-i \\frac{2\\pi m(a-1)}{M}}\n$$\n设求和索引为 $j = a-1$，其范围从 $0$ 到 $M-1$。\n$$\nC(k_m) = \\frac{1}{M} \\sum_{j=0}^{M-1} \\left(e^{-i \\frac{2\\pi m}{M}}\\right)^j\n$$\n这是一个公比为 $r = e^{-i \\frac{2\\pi m}{M}}$ 的有限几何级数。\n几何级数的和为 $\\sum_{j=0}^{M-1} r^j = \\frac{1-r^M}{1-r}$（对于 $r \\neq 1$）。\n当指数是 $2\\pi i$ 的整数倍时，出现 $r=1$ 的情况，即 $\\frac{2\\pi m}{M} = 2\\pi n$（对于某个整数 $n$）。这可以简化为 $m = nM$，或 $m \\equiv 0 \\pmod{M}$。\n\n如果 $m \\equiv 0 \\pmod{M}$（对于非直流分量，$m \\neq 0$），则 $r=1$，和就是 $\\sum_{j=0}^{M-1} 1 = M$。在这种情况下：\n$$\nC(k_m) = \\frac{1}{M} \\cdot M = 1\n$$\n如果 $m \\not\\equiv 0 \\pmod{M}$，则 $r \\neq 1$。和的分子是 $1 - r^M = 1 - \\left(e^{-i \\frac{2\\pi m}{M}}\\right)^M = 1 - e^{-i 2\\pi m} = 1-1=0$，因为 $m$ 是整数。在这种情况下：\n$$\nC(k_m) = \\frac{1}{M} \\cdot 0 = 0\n$$\n因此，对于静默启动，初始密度的离散采样其 Fourier 谱对于所有物理模式 $k_m = 2\\pi m/L$ 均为零，除非 $m$ 是标记点数 $M$ 的倍数。波数 $k = 2\\pi (nM)/L$（$n$ 为整数）被称为混叠波数。这个离散谱在 $k$ 空间中仅在规则间隔处具有非零值，是 Dirac 梳状函数的离散模拟。\n\n当使用像云中单元 (Cloud-In-Cell, CIC) 这样的形函数将标记点贡献沉积到网格上时，网格上产生的场在谱上会被修正。真实振幅会乘以一个形函数 $S(k)$。对于 CIC，有 $S(k) = \\left( \\frac{\\sin(k \\Delta x/2)}{k \\Delta x/2} \\right)^2$，其中 $\\Delta x=L/G$。因此，源于初始标记点分布的噪声振幅为 $A_{\\text{noise}}(k_m) \\propto S(k_m) C(k_m)$。对于静默启动，这意味着噪声基底除了在混叠模式下，应该恒等于零。\n\n### 2. 随机启动初始噪声谱的推导\n\n对于随机启动，标记点位置 $x_a(0)$ 是在 $[0, L)$ 上服从均匀分布的独立同分布 (i.i.d.) 随机变量。我们分析相同的离散 Fourier 系数 $C_k = \\frac{1}{M} \\sum_{a=1}^M e^{-i k x_a(0)}$。这是 $M$ 个独立同分布的复随机变量 $z_a = e^{-i k x_a(0)}$ 的和。\n\n对于 $k=k_m = 2\\pi m/L$ 且 $m \\neq 0$，相位 $-k x_a(0)$ 在一个长度为 $2\\pi m$ 的区间上是均匀的。模 $2\\pi$ 后，相位在 $[0, 2\\pi)$ 上是均匀的。因此，每个 $z_a$ 是在复平面单位圆上均匀分布的随机变量。\n\n每个 $z_a$ 的期望值为：\n$$\n\\mathbb{E}[z_a] = \\mathbb{E}[e^{-i k x_a}] = \\int_0^L e^{-i k x} \\frac{1}{L} dx = \\frac{1}{-ikL} [e^{-ikx}]_0^L = \\frac{1}{-ikL}(e^{-ikL}-1)\n$$\n因为 $k=k_m$，所以 $e^{-ikL} = e^{-i2\\pi m} = 1$，因此对于 $m \\neq 0$，有 $\\mathbb{E}[z_a]=0$。因此，这个和的期望也为零：$\\mathbb{E}[C_k] = 0$。\n\n根据中心极限定理，对于大的 $M$，$C_k$ 的实部和虚部（记为 $X = \\text{Re}(C_k)$ 和 $Y = \\text{Im}(C_k)$）近似为均值为零的独立高斯随机变量。它们的方差是：\n$$\n\\sigma_c^2 = \\text{Var}(X) = \\text{Var}\\left(\\frac{1}{M}\\sum_{a=1}^M \\cos(kx_a)\\right) = \\frac{1}{M^2}\\sum_{a=1}^M \\text{Var}(\\cos(kx_a)) = \\frac{M}{M^2}\\text{Var}(\\cos(kx)) = \\frac{1}{M}\\text{Var}(\\cos(kx))\n$$\n$\\cos(kx)$ 的方差是 $\\mathbb{E}[\\cos^2(kx)] - (\\mathbb{E}[\\cos(kx)])^2$。由于 $\\mathbb{E}[z_a]=0$，其实部 $\\mathbb{E}[\\cos(kx_a)]$ 也为 $0$。\n$$\n\\mathbb{E}[\\cos^2(kx)] = \\int_0^L \\cos^2(kx) \\frac{dx}{L} = \\frac{1}{L} \\int_0^L \\frac{1+\\cos(2kx)}{2} dx = \\frac{1}{2L}\\left[x + \\frac{\\sin(2kx)}{2k}\\right]_0^L = \\frac{1}{2}\n$$\n所以，$\\text{Var}(\\cos(kx)) = 1/2$。实部分量的方差为 $\\sigma_c^2 = \\text{Var}(X) = \\frac{1}{2M}$。类似的计算表明 $\\text{Var}(Y) = \\frac{1}{2M}$。\n\n幅值 $|C_k| = \\sqrt{X^2+Y^2}$ 是一个服从 Rayleigh 分布的随机变量。Rayleigh 分布的尺度参数是 $\\sigma_R = \\sqrt{\\sigma_c^2} = \\sqrt{1/(2M)}$。一个服从 Rayleigh 分布的变量的期望值（均值）是 $\\sigma_R \\sqrt{\\pi/2}$。因此，噪声系数的期望幅值为：\n$$\n\\mathbb{E}\\{|C_k|\\} = \\sigma_R\\sqrt{\\frac{\\pi}{2}} = \\sqrt{\\frac{1}{2M}} \\sqrt{\\frac{\\pi}{2}} = \\sqrt{\\frac{\\pi}{4M}} = \\frac{\\sqrt{\\pi}}{2\\sqrt{M}}\n$$\n问题陈述给出的期望幅值为 $\\sqrt{\\frac{\\pi}{2M}}$。这个值比此标准推导的结果大一个因子 $\\sqrt{2}$。这种差异可能是由于不同的约定或问题陈述中的笔误。为了实现所要求的算法，我们将遵循问题中提供的公式，即 $|A_{\\text{noise}}(k)| \\approx S(k)\\sqrt{\\frac{\\pi}{2M}}$。\n\n### 3. 增长率提取中的偏差\n\n问题提出了一个模型，将测量振幅 $A_k^{\\text{meas}}(t)$ 视为真实物理信号 $A_k(t) = A_0 e^{\\gamma t}$ 和一个静态噪声基底 $A_{\\text{noise}}$ 的非相干叠加：\n$$\nA_k^{\\text{meas}}(t) = \\sqrt{A_k(t)^2 + A_{\\text{noise}}(k)^2} = \\sqrt{(A_0 e^{\\gamma t})^2 + A_{\\text{noise}}^2}\n$$\n增长率是通过对测量振幅的对数 $y(t) = \\ln A_k^{\\text{meas}}(t)$ 与时间 $t$ 进行线性最小二乘拟合来估计的。让我们分析一下这个函数的斜率。\n$$\ny(t) = \\frac{1}{2} \\ln(A_0^2 e^{2\\gamma t} + A_{\\text{noise}}^2)\n$$\n瞬时斜率代表了表观增长率，由对时间的导数给出：\n$$\n\\frac{dy}{dt} = \\frac{1}{2} \\frac{1}{A_0^2 e^{2\\gamma t} + A_{\\text{noise}}^2} \\cdot (A_0^2 e^{2\\gamma t} \\cdot 2\\gamma) = \\gamma \\left( \\frac{A_0^2 e^{2\\gamma t}}{A_0^2 e^{2\\gamma t} + A_{\\text{noise}}^2} \\right) = \\gamma \\left( \\frac{A_k(t)^2}{A_k(t)^2 + A_{\\text{noise}}^2} \\right)\n$$\n括号中的项是信号功率与总功率（信号+噪声）之比。如果 $A_{\\text{noise}} \\neq 0$，那么对于任何有限时间 $t$，这个比率总是小于 $1$。\n在非常早的时期，当信号 $A_k(t)$ 可能小于或与噪声 $A_{\\text{noise}}$ 相当时，斜率 $\\frac{dy}{dt}$ 显著小于 $\\gamma$。随着时间的推移，信号呈指数增长，$A_k(t) \\gg A_{\\text{noise}}$，该比率趋近于 $1$，使得斜率渐近地趋近于 $\\gamma$。\n\n在早期时间区间内进行的线性最小二乘拟合，实际上是对这个持续增大的斜率进行平均。由于斜率总是小于 $\\gamma$ 且只能从下方趋近它，因此拟合得到的估计增长率 $\\gamma_{est}$ 将会系统地低于真实的增长率 $\\gamma$。当拟合窗口内的噪声水平 $A_{\\text{noise}}$ 相对于信号振幅 $A_k(t)$ 较大时，这种偏差更为显著。在 $A_{\\text{noise}}=0$ 的理想情况下，斜率是恒定的且等于 $\\gamma$，从而得到一个无偏的估计。\n\n### 算法设计\n\n该算法根据所提供的模型和测试案例计算估计的增长率。步骤如下：\n1.  对于每个测试案例，提取参数：系统长度 $L$、网格点数 $G$、标记点数 $M$、模式数 $m$、初始振幅 $A_0$、真实增长率 $\\gamma$ 和时间点 $t$。\n2.  计算物理波数 $k_m = 2\\pi m / L$。\n3.  计算 CIC 形函数 $S(k_m)$。公式为 $S(k) = (\\sin(k\\Delta x/2)/(k\\Delta x/2))^2$，由于 $k_m\\Delta x/(2\\pi) = m/G$，可以稳健地计算为 $(\\text{np.sinc}(m/G))^2$。\n4.  根据启动类型和参数确定噪声振幅 $A_{\\text{noise}}$：\n    -   对于静默启动，$A_{\\text{noise}} = S(k_m) \\cdot C(k_m)$。如果 $m \\equiv 0 \\pmod M$，则 $C(k_m)=1$，否则 $C(k_m)=0$。\n    -   对于随机启动，使用问题中提供的公式：$A_{\\text{noise}} = S(k_m) \\sqrt{\\pi/(2M)}$。\n5.  为每个时间点生成真实信号振幅的时间序列 $A_k(t) = A_0 e^{\\gamma t}$。\n6.  生成测量振幅的时间序列 $A_k^{\\text{meas}}(t) = \\sqrt{A_k(t)^2 + A_{\\text{noise}}^2}$。\n7.  计算测量振幅的对数：$y(t) = \\ln(A_k^{\\text{meas}}(t))$。\n8.  对数据点 $(t, y(t))$ 进行线性最小二乘拟合，以找到最佳拟合直线 $y_{fit}(t) = \\gamma_{est} t + C$。该直线的斜率 $\\gamma_{est}$ 即为估计的增长率。这可以使用 `numpy.polyfit(t, y, 1)[0]` 高效计算。\n9.  存储每个案例得到的 $\\gamma_{est}$，并将最终输出格式化为逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating a linear growth rate in the presence of\n    numerical noise in a delta-f simulation.\n    \"\"\"\n\n    # Test Suite:\n    # (L, G, M, m, A0, gamma, t_points_list, start_type)\n    test_cases = [\n        (1.0, 128, 256, 4, 0.01, 800.0, np.linspace(0, 0.006, 7), 'quiet'),\n        (1.0, 128, 256, 4, 0.01, 800.0, np.linspace(0, 0.006, 7), 'random'),\n        (1.0, 128, 4096, 4, 0.01, 800.0, np.linspace(0, 0.006, 7), 'random'),\n        (1.0, 128, 300, 300, 0.01, 800.0, np.linspace(0, 0.006, 7), 'quiet'),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, G, M, m, A0, gamma, t, start_type = case\n\n        # Step 1: Calculate wavenumber and CIC form factor\n        k_m = 2 * np.pi * m / L\n        # The argument for the sinc function, k*dx/2, becomes pi*m/G\n        # numpy.sinc(x) is defined as sin(pi*x)/(pi*x)\n        # So we use np.sinc(m/G) for sin(pi*m/G)/(pi*m/G) which matches\n        # sin(k*dx/2)/(k*dx/2)\n        s_k = np.sinc(m / G)**2\n\n        # Step 2: Calculate noise amplitude based on start type\n        A_noise = 0.0\n        if start_type == 'quiet':\n            # Noise is non-zero only at alias modes where m is a multiple of M\n            if m != 0 and m % M == 0:\n                # The sum is 1 at the alias.\n                A_noise = s_k * 1.0\n            else:\n                # The sum is 0 for non-aliased modes.\n                A_noise = s_k * 0.0\n        elif start_type == 'random':\n            # Use the formula provided in the problem statement\n            A_noise = s_k * np.sqrt(np.pi / (2 * M))\n\n        # Step 3: Generate the measured amplitude time series\n        # True signal amplitude A_k(t) = A0 * exp(gamma*t)\n        A_k_t = A0 * np.exp(gamma * t)\n        \n        # Measured amplitude A_k_meas(t) = sqrt(A_k(t)^2 + A_noise^2)\n        A_k_meas_t = np.sqrt(A_k_t**2 + A_noise**2)\n        \n        # Step 4: Take the logarithm for linear fitting\n        log_A_k_meas_t = np.log(A_k_meas_t)\n        \n        # Step 5: Perform linear least-squares fit to find the slope (estimated gamma)\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        coeffs = np.polyfit(t, log_A_k_meas_t, 1)\n        estimated_gamma = coeffs[0]\n        \n        results.append(estimated_gamma)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "无碰撞等离子体中粒子运动的哈密顿特性遵循刘维尔定理，即相空间体积守恒。数值积分方案必须尊重这一基本物理原理，以避免产生非物理性的长期漂移。本练习将通过一个简化的谐振子模型，让您定量地比较一个非体积保持的欧拉积分方案和一个保持体积的辛积分方案，并揭示前者如何导致虚假的数值加热。这是确保模拟长期稳定性的关键一课。",
            "id": "4202450",
            "problem": "要求您实现并分析一个最小的一维静电模型，该模型揭示了在无碰撞 Vlasov 动力学的 delta-f 方法中，非保体积粒子推进器对权重演化的影响。目标是通过相空间体积漂移来量化非辛积分器引起的误差，并将其与伪平均能量增长（加热）关联起来。本问题中的所有量均为无量纲；无需进行物理单位转换。\n\n从以下基本基础开始：\n- 无碰撞 Vlasov 方程等效于沿哈密顿流生成的特征线的平流。哈密顿流保持相空间体积（Liouville 定理）。\n- 对于具有哈密顿量 $H(x,v) = \\tfrac{1}{2} v^2 + \\tfrac{1}{2} \\omega^2 x^2$ 的一维静电系统，其精确特征线满足 $\\dot{x} = v$ 和 $\\dot{v} = - \\omega^2 x$。\n- delta-f 方法的稳态控制分布可取为 Maxwell–Boltzmann 平衡态 $f_0(x,v) \\propto \\exp\\left(- H(x,v) / T\\right)$，其中 $T$ 是一个常数。沿着精确的哈密顿流，$f_0$ 是恒定的。\n\n您将分析特征线的两种时间推进映射：\n- 一种非保体积的显式 Euler 映射，定义为通过单个时间步 $\\Delta t$ 将 $(x_n, v_n)$ 推进到 $(x_{n+1}, v_{n+1})$，其规则为：首先用当前速度更新位置，然后用当前位置更新速度。\n- 一种保体积的辛 Euler（踢-漂）映射，定义为首先用当前位置更新速度，然后用更新后的速度更新位置。\n\n对于每种映射，将单步映射定义为 $(x_{n+1}, v_{n+1}) = \\mathcal{M}(x_n, v_n)$，并计算雅可比矩阵 $J = \\partial(x_{n+1}, v_{n+1}) / \\partial(x_n, v_n)$。经过 $N$ 个相同步骤后，累积的对数相空间体积变化为\n$$\nS \\equiv \\sum_{n=0}^{N-1} \\ln \\left( \\det J \\right),\n$$\n对于一个恒定的线性映射，这简化为 $S = N \\ln \\left( \\det J \\right)$。\n\n为量化伪加热，初始化一个与稳态控制分布 $f_0(x,v) \\propto \\exp\\left(- H(x,v)/T \\right)$ 一致的系综，其均值为零，协方差为\n$$\n\\Sigma_0 = \\mathrm{diag}\\!\\left( \\tfrac{T}{\\omega^2},\\; T \\right).\n$$\n通过线性映射演化系综协方差\n$$\n\\Sigma_{n+1} = M \\Sigma_n M^\\top,\n$$\n其中 $M$ 是所选映射 $\\mathcal{M}$ 的 $2 \\times 2$ 矩阵表示。在步骤 $n$ 的平均总能量为\n$$\n\\bar{E}_n = \\tfrac{1}{2}\\, \\mathrm{Tr}\\!\\left( Q \\Sigma_n \\right), \\quad Q = \\mathrm{diag}\\!\\left( \\omega^2,\\; 1 \\right).\n$$\n将 $N$ 步后的伪加热定义为\n$$\n\\Delta \\bar{E} \\equiv \\bar{E}_N - \\bar{E}_0.\n$$\n\n通过报告比率来关联相空间体积漂移与伪加热\n$$\n\\mathcal{C} \\equiv\n\\begin{cases}\n\\Delta \\bar{E} \\big/ \\left( T\\, S \\right)  \\text{if } S > 0,\\\\\n0  \\text{if } S = 0,\n\\end{cases}\n$$\n这是一个无量纲的诊断量，表示单位对数体积漂移的能量增长，并由 $T$ 归一化。\n\n实现一个程序，对每个测试用例，使用上述定义并从给定的 $\\Sigma_0$ 开始，计算并返回一个三元组 $[S,\\ \\Delta \\bar{E},\\ \\mathcal{C}]$。您的程序不得依赖任何随机抽样；它必须确定性地执行协方差传播。\n\n测试套件：\n- 案例 A（正常路径，小的非零漂移）：显式 Euler 映射，$\\omega = 1.0$，$\\Delta t = 0.05$，$N = 1000$，$T = 1.0$。\n- 案例 B（较大漂移）：显式 Euler 映射，$\\omega = 1.0$，$\\Delta t = 0.2$，$N = 200$，$T = 1.0$。\n- 案例 C（边界条件，保体积）：辛 Euler（踢-漂）映射，$\\omega = 1.0$，$\\Delta t = 0.2$，$N = 200$，$T = 1.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个案例的结果，格式为一个包含三个子列表的逗号分隔列表，每个子列表包含三个浮点数 $[S,\\ \\Delta \\bar{E},\\ \\mathcal{C}]$，无任何附加文本。例如，打印的格式必须类似于\n$[ [S_A,\\Delta E_A,\\mathcal{C}_A], [S_B,\\Delta E_B,\\mathcal{C}_B], [S_C,\\Delta E_C,\\mathcal{C}_C] ]$\n但不含空格。具体来说，您的程序必须打印形如\n$[[S_A,\\Delta E_A,\\mathcal{C}_A],[S_B,\\Delta E_B,\\mathcal{C}_B],[S_C,\\Delta E_C,\\mathcal{C}_C]]$ 的单行。\n\n所有角度（如有）均以弧度为单位。所有输出均为无量纲实数。最终答案必须是一个完整的、可运行的程序，该程序实现上述要求并以所描述的精确格式打印结果。不应读取任何用户输入。",
            "solution": "该问题是有效的。这是一个在计算物理学中定义明确、科学上合理且客观的问题，探讨了等离子体模拟中使用的积分器的数值赝象。所有必要的数据、方程和定义均已提供。\n\n此问题的核心是分析和对比两种用于简谐振子的数值积分方案，简谐振子可作为无碰撞 Vlasov 动力学的最小模型。分析的重点是积分器的选择如何影响基础物理系统的基本守恒量，即相空间体积和能量。\n\n首先，我们通过将粒子的状态表示为二维相空间中的向量 $z = (x, v)^\\top$ 来形式化此问题。谐振子哈密顿量 $H(x,v) = \\frac{1}{2} v^2 + \\frac{1}{2} \\omega^2 x^2$ 的运动方程是线性的：\n$$\n\\frac{d}{dt} \\begin{pmatrix} x \\\\ v \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix} \\begin{pmatrix} x \\\\ v \\end{pmatrix}\n$$\n数值积分器通过应用离散时间步长映射 $(x_{n+1}, v_{n+1})^\\top = M (x_n, v_n)^\\top$ 来近似该系统的解，其中 $M$ 是一个 $2 \\times 2$ 矩阵，它取决于积分方案、时间步长 $\\Delta t$ 和系统参数 $\\omega$。\n\n我们被要求分析两种特定的映射：\n\n**1. 显式 Euler 映射：**\n更新规则如下：首先更新位置，然后更新速度。\n$$\nx_{n+1} = x_n + \\Delta t \\cdot \\dot{x}_n = x_n + \\Delta t \\cdot v_n \\\\\nv_{n+1} = v_n + \\Delta t \\cdot \\dot{v}_n = v_n + \\Delta t \\cdot (-\\omega^2 x_n)\n$$\n这对应于矩阵映射 $z_{n+1} = M_{EE} z_n$，其中：\n$$\nM_{EE} = \\begin{pmatrix} 1 & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 \\end{pmatrix}\n$$\n这个线性映射的雅可比矩阵就是矩阵 $M_{EE}$ 本身。它的行列式，衡量每步相空间面积的变化，是：\n$$\n\\det(M_{EE}) = (1)(1) - (\\Delta t)(-\\omega^2 \\Delta t) = 1 + \\omega^2 (\\Delta t)^2\n$$\n由于当 $\\omega, \\Delta t \\neq 0$ 时 $\\det(M_{EE}) > 1$，此积分器不保持相空间体积；它会持续扩大相空间体积。\n\n**2. 辛 Euler (踢-漂) 映射：**\n更新规则是：首先更新速度（踢），然后使用新速度更新位置（漂）。\n$$\nv' = v_n + \\Delta t \\cdot \\dot{v}_n = v_n - \\omega^2 \\Delta t \\cdot x_n \\\\\nx_{n+1} = x_n + \\Delta t \\cdot v' = x_n + \\Delta t (v_n - \\omega^2 \\Delta t \\cdot x_n) = (1 - \\omega^2 (\\Delta t)^2) x_n + \\Delta t \\cdot v_n\n$$\n最终状态为 $(x_{n+1}, v_{n+1}) = (x_{n+1}, v')$。相应的矩阵映射 $z_{n+1} = M_{SE} z_n$ 是：\n$$\nM_{SE} = \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 \\end{pmatrix}\n$$\n此映射的雅可比矩阵的行列式是：\n$$\n\\det(M_{SE}) = (1 - \\omega^2 (\\Delta t)^2)(1) - (\\Delta t)(-\\omega^2 \\Delta t) = 1 - \\omega^2 (\\Delta t)^2 + \\omega^2 (\\Delta t)^2 = 1\n$$\n此积分器是保体积的，这是辛映射的一个关键属性，与精确哈密顿流的 Liouville 定理一致。\n\n接下来，我们量化累积的相空间体积漂移和伪能量增长。\n\n**相空间体积漂移 ($S$)：**\n对于一个恒定的线性映射 $M$ 应用 $N$ 次，累积的对数体积变化是：\n$$\nS = N \\ln(\\det(M))\n$$\n对于显式 Euler 映射，$S = N \\ln(1 + \\omega^2 (\\Delta t)^2) > 0$。对于辛 Euler 映射，$S = N \\ln(1) = 0$。\n\n**伪能量增长 ($\\Delta \\bar{E}$)：**\n一个粒子系综的状态由其协方差矩阵 $\\Sigma$ 描述。对于 Maxwell-Boltzmann 分布，初始协方差为 $\\Sigma_0 = \\mathrm{diag}(T/\\omega^2, T)$。经过线性映射 $M$ 的 $N$ 步后，协方差矩阵演变为：\n$$\n\\Sigma_N = M^N \\Sigma_0 (M^\\top)^N\n$$\n系综在步骤 $n$ 的平均能量是 $\\bar{E}_n = \\frac{1}{2} \\mathrm{Tr}(Q \\Sigma_n)$，其中 $Q = \\mathrm{diag}(\\omega^2, 1)$。初始能量是：\n$$\n\\bar{E}_0 = \\frac{1}{2} \\mathrm{Tr}(Q \\Sigma_0) = \\frac{1}{2} \\mathrm{Tr} \\left( \\begin{pmatrix} \\omega^2 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} T/\\omega^2 & 0 \\\\ 0 & T \\end{pmatrix} \\right) = \\frac{1}{2} \\mathrm{Tr} \\left( \\begin{pmatrix} T & 0 \\\\ 0 & T \\end{pmatrix} \\right) = \\frac{1}{2}(T+T) = T\n$$\n$N$ 步后的伪加热是平均能量的变化：\n$$\n\\Delta \\bar{E} = \\bar{E}_N - \\bar{E}_0 = \\frac{1}{2} \\mathrm{Tr}(Q \\Sigma_N) - T\n$$\n\n**相关性诊断 ($\\mathcal{C}$)：**\n伪加热和体积漂移之间的相关性由以下比率量化：\n$$\n\\mathcal{C} = \\begin{cases} \\Delta \\bar{E} / (T S) & \\text{if } S > 0 \\\\ 0 & \\text{if } S = 0 \\end{cases}\n$$\n\n**算法：**\n对于每个测试用例，我们执行以下确定性计算：\n1. 识别参数：映射类型, $\\omega$, $\\Delta t$, $N$, $T$。\n2. 构造相应的 $2 \\times 2$ 映射矩阵 $M$ ($M_{EE}$ 或 $M_{SE}$)。\n3. 计算 $S = N \\ln(\\det(M))$。\n4. 构造初始协方差矩阵 $\\Sigma_0 = \\mathrm{diag}(T/\\omega^2, T)$ 和能量矩阵 $Q = \\mathrm{diag}(\\omega^2, 1)$。\n5. 计算矩阵的 $N$ 次幂 $M^N$。\n6. 计算最终协方差矩阵 $\\Sigma_N = M^N \\Sigma_0 (M^N)^\\top$。\n7. 计算最终平均能量 $\\bar{E}_N = \\frac{1}{2} \\mathrm{Tr}(Q \\Sigma_N)$。\n8. 计算伪加热 $\\Delta \\bar{E} = \\bar{E}_N - T$。\n9. 根据其定义计算相关性 $\\mathcal{C}$。\n10. 存储结果三元组 $[S, \\Delta \\bar{E}, \\mathcal{C}]$。\n对所有三个测试用例重复此过程以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spurious heating and phase-space volume drift for two numerical\n    integrators applied to a 1D simple harmonic oscillator system.\n    \"\"\"\n\n    test_cases = [\n        # Case A: explicit Euler, small drift\n        {'map_type': 'explicit_euler', 'omega': 1.0, 'dt': 0.05, 'N': 1000, 'T': 1.0},\n        # Case B: explicit Euler, larger drift\n        {'map_type': 'explicit_euler', 'omega': 1.0, 'dt': 0.2, 'N': 200, 'T': 1.0},\n        # Case C: symplectic Euler, volume-preserving\n        {'map_type': 'symplectic_euler', 'omega': 1.0, 'dt': 0.2, 'N': 200, 'T': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        map_type = case['map_type']\n        omega = case['omega']\n        dt = case['dt']\n        N = case['N']\n        T = case['T']\n\n        # 1. Construct the map matrix M\n        if map_type == 'explicit_euler':\n            M = np.array([\n                [1.0, dt],\n                [-omega**2 * dt, 1.0]\n            ])\n        elif map_type == 'symplectic_euler':\n            M = np.array([\n                [1.0 - omega**2 * dt**2, dt],\n                [-omega**2 * dt, 1.0]\n            ])\n        else:\n            raise ValueError(f\"Unknown map_type: {map_type}\")\n\n        # 2. Calculate the cumulative logarithmic phase-space volume change S\n        det_M = np.linalg.det(M)\n        # Use np.log1p for better precision when det_M is close to 1\n        log_det_M = np.log1p(det_M - 1.0)\n        S = N * log_det_M\n        \n        # 3. Define initial covariance Sigma_0 and energy matrix Q\n        Sigma_0 = np.array([\n            [T / omega**2, 0.0],\n            [0.0, T]\n        ])\n        Q = np.array([\n            [omega**2, 0.0],\n            [0.0, 1.0]\n        ])\n\n        # 4. Compute the matrix power M^N\n        M_N = np.linalg.matrix_power(M, N)\n\n        # 5. Calculate the final covariance matrix Sigma_N\n        Sigma_N = M_N @ Sigma_0 @ M_N.T\n\n        # 6. Calculate the initial and final mean energies\n        E_0 = T  # As derived, E_0 = 0.5 * Tr(Q @ Sigma_0) = T\n        E_N = 0.5 * np.trace(Q @ Sigma_N)\n\n        # 7. Compute the spurious heating dE\n        dE = E_N - E_0\n\n        # 8. Calculate the correlation diagnostic C\n        # Use a small tolerance for floating point comparison with zero\n        if S > 1e-12:\n            C = dE / (T * S)\n        else:\n            C = 0.0\n            \n        results.append([S, dE, C])\n\n    # Final print statement in the exact required format.\n    # Build the string representation manually to avoid spaces.\n    outer_list_str = []\n    for res_list in results:\n        inner_list_str = ','.join(map(str, res_list))\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "$\\delta f$ 方法的巨大优势在于它只追踪偏离平衡态的部分，但这也带来了其独特的挑战：标记点权重的无界增长，即“权重发散”问题。本练习将此过程建模为一个随机微分方程，并要求您推导权重方差随时间的演化。这将为您实现诸如重采样等关键的方差控制技术提供理论基础，这些技术对于任何 $\\delta f$ 模拟的长期有效性都是必不可少的。",
            "id": "4202459",
            "problem": "考虑聚变等离子体中由一维线性化Vlasov–Poisson系统描述的单个静电、碰撞阻尼、受驱动的线性模式。在delta-deviation方法（delta-f方法）中，粒子模拟表示沿着未扰动特征线演化标记权重 $w \\equiv \\delta f / F_0$，其中 $F_0$ 是一个稳态平衡分布。假设沿特征线的权重演化遵循以下理想化且广泛使用的闭合模型：\n1. 碰撞由碰撞频率为 $\\nu$（单位为 $\\mathrm{s}^{-1}$）的Bhatnagar–Gross–Krook (BGK) 算子建模，该算子将 $w$ 驱动至零。\n2. 该模式由一个外部指定的、与时间相关的源 $s(t)$ 确定性地驱动，该源独立于粒子实现。\n3. 由场求解中有限数量的标记引入的统计噪声被建模为强度为 $2D$ 的加性高斯白噪声，其中 $D \\ge 0$ 的单位为 $\\mathrm{s}^{-1}$，而 $w$ 是无量纲的。\n\n基于这些假设，标记权重的随机微分方程为\n$$\n\\mathrm{d}w(t) = -\\nu\\, w(t)\\,\\mathrm{d}t + s(t)\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t,\n$$\n其中 $W_t$ 是一个标准维纳过程，$w(0)$ 的均值为 $\\mathbb{E}[w(0)]$，方差为 $\\mathrm{Var}(w(0)) = V_0 \\ge 0$。驱动项 $s(t)$ 是确定性的，并且不依赖于标记实现。\n\n任务A（推导）：仅从上述随机微分方程和伊藤积分的基本规则出发，推导方差 $\\mathrm{Var}(w(t))$（对于 $t \\ge 0$）随时间演化的闭式表达式，该表达式应以 $\\nu$、$D$ 和 $V_0$ 表示。您的表达式必须对严格碰撞情况 $\\nu > 0$ 和无碰撞极限 $\\nu = 0$ 均有效。\n\n任务B（固定成本下的重采样阈值）：在delta-deviation粒子模拟的方差控制策略中，会以指定的平均速率 $B$（单位为 $\\mathrm{s}^{-1}$），对应于名义周期 $T \\equiv 1/B$（单位为 $\\mathrm{s}$），周期性地应用重采样（或“重映射”）操作。假设每次重采样后，权重的方差被重置为一个基线值 $V_{\\mathrm{reset}} \\ge 0$。使用您在任务A中得到的结果，提出了一个方差阈值 $V_{\\mathrm{th}}$ 的公式，使得在上述模型的期望意义下，从 $V_{\\mathrm{reset}}$ 开始演化时间间隔 $T$ 后的方差等于 $V_{\\mathrm{th}}$。该阈值 $V_{\\mathrm{th}}$ 应以 $\\nu$、$D$、$V_{\\mathrm{reset}}$ 和 $T$ 表示，并且必须在 $\\nu > 0$ 和 $\\nu = 0$ 的情况下都有效。\n\n编程任务：编写一个完整、可运行的程序，该程序：\n- 实现您在任务A和任务B中得到的公式。\n- 对于下面的每个测试用例，计算：\n  1. 从 $V_0$ 开始，在最终时间 $t = T_{\\mathrm{end}}$ 时的方差。\n  2. 从 $V_{\\mathrm{reset}}$ 开始，重采样周期为 $T = 1/B$ 时的方差阈值 $V_{\\mathrm{th}}$。\n\n角度单位不适用。时间单位为秒，频率单位为 $\\mathrm{s}^{-1}$，$w$ 的方差是无量纲的。您的程序必须仅输出无量纲的方差，格式为浮点数。\n\n测试套件（每个元组为 $(\\nu, D, V_0, T_{\\mathrm{end}}, B, V_{\\mathrm{reset}})$）：\n- 案例1（中等阻尼，稳定驱动噪声，零初始方差）：$(100.0,\\ 5.0,\\ 0.0,\\ 0.05,\\ 10.0,\\ 0.01)$\n- 案例2（无碰撞，线性方差增长）：$(0.0,\\ 0.2,\\ 0.02,\\ 1.0,\\ 2.0,\\ 0.0)$\n- 案例3（强阻尼，小噪声，大初始方差）：$(1000.0,\\ 0.01,\\ 0.5,\\ 0.005,\\ 50.0,\\ 0.05)$\n- 案例4（无噪声，纯碰撞衰减）：$(10.0,\\ 0.0,\\ 0.1,\\ 0.5,\\ 5.0,\\ 0.02)$\n- 案例5（弱阻尼，显著噪声，非零重置值）：$(1.0,\\ 0.5,\\ 0.0,\\ 2.0,\\ 0.5,\\ 0.1)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按给定顺序包含每个案例的结果，首先是最终时间方差，然后是阈值，两者均为浮点数。例如，两个案例的输出将如下所示：“[v1_final,v1_threshold,v2_final,v2_threshold]”。所有五个案例的所需输出是按此顺序排列的包含十个浮点数的单个扁平列表。\n\n注意：虽然确定性驱动项 $s(t)$ 会影响均值 $\\mathbb{E}[w(t)]$，但您的程序必须仅按要求计算方差，根据上述模型，方差与 $s(t)$ 的选择无关。所有输出均以无量纲浮点数表示。",
            "solution": "所述问题已经过验证，被认定具有科学依据、提法恰当、客观且内容完整。它提出了一个来自计算等离子体物理学的标准模型，该模型基于一个线性随机微分方程（SDE），具体来说是带有外力项的Ornstein–Uhlenbeck过程。任务要求推导方差动力学及一个相关量，这些是随机微积分中的标准、可验证的程序。因此，该问题被视为有效，并随即提供解答。\n\n**任务A：方差演化的推导**\n\n标记权重 $w(t)$ 的演化由伊藤随机微分方程（Itô SDE）控制：\n$$\n\\mathrm{d}w(t) = (-\\nu\\, w(t) + s(t))\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t\n$$\n此处，$w(t)$ 是随机过程，$\\nu \\ge 0$ 是碰撞频率，$s(t)$ 是确定性驱动项，$D \\ge 0$ 是与噪声相关的扩散系数，$W_t$ 是标准维纳过程。初始方差为 $\\mathrm{Var}(w(0)) = V_0$。\n\n$w(t)$ 的方差定义为 $V(t) \\equiv \\mathrm{Var}(w(t)) = \\mathbb{E}[w(t)^2] - (\\mathbb{E}[w(t)])^2$。我们将为 $V(t)$ 推导一个常微分方程（ODE）。\n\n首先，我们求均值 $\\mu(t) = \\mathbb{E}[w(t)]$ 的ODE。对SDE取期望，并注意到 $\\mathbb{E}[\\mathrm{d}W_t] = 0$：\n$$\n\\mathrm{d}\\mathbb{E}[w(t)] = \\mathbb{E}[-\\nu\\, w(t) + s(t)]\\,\\mathrm{d}t = (-\\nu \\mu(t) + s(t))\\,\\mathrm{d}t\n$$\n$$\n\\frac{\\mathrm{d}\\mu(t)}{\\mathrm{d}t} = -\\nu \\mu(t) + s(t)\n$$\n接下来，我们求二阶矩 $\\mathbb{E}[w(t)^2]$ 的ODE。我们将伊藤引理应用于函数 $f(w) = w^2$。对于过程 $X_t$，伊藤引理的一般形式是 $\\mathrm{d}f(X_t) = f'(X_t)\\,\\mathrm{d}X_t + \\frac{1}{2}f''(X_t)(\\mathrm{d}X_t)^2$。在此，$f'(w)=2w$，$f''(w)=2$，二次变分 $(\\mathrm{d}w)^2$ 由随机项决定：\n$$\n(\\mathrm{d}w_t)^2 = (\\sqrt{2D}\\,\\mathrm{d}W_t)^2 = 2D (\\mathrm{d}W_t)^2 = 2D\\,\\mathrm{d}t\n$$\n应用伊藤引理：\n$$\n\\mathrm{d}(w^2) = (2w)\\,\\mathrm{d}w + \\frac{1}{2}(2)(2D\\,\\mathrm{d}t) = 2w\\,\\mathrm{d}w + 2D\\,\\mathrm{d}t\n$$\n代入 $\\mathrm{d}w$ 的表达式：\n$$\n\\mathrm{d}(w^2) = 2w\\left( (-\\nu w + s(t))\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t \\right) + 2D\\,\\mathrm{d}t\n$$\n$$\n\\mathrm{d}(w^2) = (-2\\nu w^2 + 2w s(t) + 2D)\\,\\mathrm{d}t + 2w\\sqrt{2D}\\,\\mathrm{d}W_t\n$$\n对该方程取期望，并注意到伊藤积分项的期望为零：\n$$\n\\mathrm{d}\\mathbb{E}[w^2] = \\mathbb{E}[-2\\nu w^2 + 2w s(t) + 2D]\\,\\mathrm{d}t\n$$\n$$\n\\frac{\\mathrm{d}\\mathbb{E}[w^2]}{\\mathrm{d}t} = -2\\nu \\mathbb{E}[w^2] + 2s(t)\\mathbb{E}[w] + 2D = -2\\nu \\mathbb{E}[w^2] + 2s(t)\\mu(t) + 2D\n$$\n现在我们求方差 $V(t) = \\mathbb{E}[w^2] - \\mu^2$ 的导数：\n$$\n\\frac{\\mathrm{d}V(t)}{\\mathrm{d}t} = \\frac{\\mathrm{d}\\mathbb{E}[w^2]}{\\mathrm{d}t} - 2\\mu(t)\\frac{\\mathrm{d}\\mu(t)}{\\mathrm{d}t}\n$$\n代入导数的表达式：\n$$\n\\frac{\\mathrm{d}V(t)}{\\mathrm{d}t} = (-2\\nu \\mathbb{E}[w^2] + 2s(t)\\mu(t) + 2D) - 2\\mu(t)(-\\nu\\mu(t) + s(t))\n$$\n$$\n\\frac{\\mathrm{d}V(t)}{\\mathrm{d}t} = -2\\nu \\mathbb{E}[w^2] + 2s(t)\\mu(t) + 2D + 2\\nu\\mu(t)^2 - 2s(t)\\mu(t)\n$$\n涉及确定性驱动项 $s(t)$ 的项相互抵消：\n$$\n\\frac{\\mathrm{d}V(t)}{\\mathrm{d}t} = -2\\nu (\\mathbb{E}[w^2] - \\mu(t)^2) + 2D\n$$\n这给出了方差的闭合ODE，它与 $s(t)$ 无关：\n$$\n\\frac{\\mathrm{d}V(t)}{\\mathrm{d}t} = -2\\nu V(t) + 2D\n$$\n我们求解这个带有初始条件 $V(0) = V_0$ 的ODE。\n\n**情况1：碰撞阻尼（$\\nu > 0$）**\nODE为 $\\frac{\\mathrm{d}V}{\\mathrm{d}t} + 2\\nu V = 2D$。使用积分因子 $I(t) = e^{\\int 2\\nu\\,\\mathrm{d}t} = e^{2\\nu t}$：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}(V(t)e^{2\\nu t}) = 2D e^{2\\nu t}\n$$\n从 $0$ 到 $t$ 积分：\n$$\nV(t)e^{2\\nu t} - V(0)e^0 = \\int_0^t 2D e^{2\\nu \\tau}\\,\\mathrm{d}\\tau = 2D \\left[\\frac{e^{2\\nu \\tau}}{2\\nu}\\right]_0^t = \\frac{D}{\\nu}(e^{2\\nu t} - 1)\n$$\n$$\nV(t)e^{2\\nu t} = V_0 + \\frac{D}{\\nu}(e^{2\\nu t} - 1)\n$$\n解出 $V(t)$:\n$$\nV(t) = V_0 e^{-2\\nu t} + \\frac{D}{\\nu}(1 - e^{-2\\nu t})\n$$\n\n**情况2：无碰撞（$\\nu = 0$）**\nODE简化为 $\\frac{\\mathrm{d}V}{\\mathrm{d}t} = 2D$。从 $0$ 到 $t$ 积分：\n$$\nV(t) - V(0) = \\int_0^t 2D\\,\\mathrm{d}\\tau = 2Dt\n$$\n$$\nV(t) = V_0 + 2Dt\n$$\n当 $\\nu \\to 0$ 时，$\\nu > 0$ 的表达式正确地简化为 $\\nu=0$ 的情况，这可以通过对小的 $\\nu t$ 使用泰勒展开 $e^{-2\\nu t} \\approx 1 - 2\\nu t$ 看出。因此，该解是稳健的。\n\n**任务B：重采样阈值的推导**\n\n重采样阈值 $V_{\\mathrm{th}}$ 定义为从重采样后的方差 $V_{\\mathrm{reset}}$ 开始，演化时间间隔 $T = 1/B$ 后权重的方差。这是对任务A中推导出的公式的直接应用，只需将 $t \\to T$ 和 $V_0 \\to V_{\\mathrm{reset}}$ 代入即可。\n\n**情况1：碰撞阻尼（$\\nu > 0$）**\n$$\nV_{\\mathrm{th}} = V_{\\mathrm{reset}} e^{-2\\nu T} + \\frac{D}{\\nu}(1 - e^{-2\\nu T})\n$$\n\n**情况2：无碰撞（$\\nu = 0$）**\n$$\nV_{\\mathrm{th}} = V_{\\mathrm{reset}} + 2DT\n$$\n这些公式提供了所需的方差阈值 $V_{\\mathrm{th}}$，它是模型参数 $\\nu$、$D$、重置方差 $V_{\\mathrm{reset}}$ 和重采样周期 $T=1/B$ 的函数。\n\n以下程序实现了这些推导出的公式，以计算指定测试用例所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the final variance and variance threshold for a series of test cases\n    based on a stochastic model of particle weight evolution in a delta-f simulation.\n    \"\"\"\n\n    # Test suite: each tuple is (nu, D, V0, T_end, B, V_reset)\n    # nu: collision frequency (s^-1)\n    # D: noise intensity parameter (s^-1)\n    # V0: initial variance (dimensionless)\n    # T_end: final time for variance calculation (s)\n    # B: average resampling rate (s^-1)\n    # V_reset: variance after resampling (dimensionless)\n    test_cases = [\n        (100.0, 5.0, 0.0, 0.05, 10.0, 0.01),\n        (0.0, 0.2, 0.02, 1.0, 2.0, 0.0),\n        (1000.0, 0.01, 0.5, 0.005, 50.0, 0.05),\n        (10.0, 0.0, 0.1, 0.5, 5.0, 0.02),\n        (1.0, 0.5, 0.0, 2.0, 0.5, 0.1),\n    ]\n\n    def calculate_variance(nu, D, V0, t):\n        \"\"\"\n        Calculates the variance V(t) based on the derived formula.\n\n        Args:\n            nu (float): Collision frequency.\n            D (float): Noise intensity parameter.\n            V0 (float): Initial variance at t=0.\n            t (float): Time interval.\n\n        Returns:\n            float: Variance at time t.\n        \"\"\"\n        if nu == 0.0:\n            # Collisionless case: V(t) = V0 + 2*D*t\n            return V0 + 2.0 * D * t\n        else:\n            # Collisional case: V(t) = V0*exp(-2*nu*t) + (D/nu)*(1 - exp(-2*nu*t))\n            # The use of np.expm1(-x) for 1-exp(-x) offers better numerical\n            # precision for small x, although direct computation is fine here.\n            # V(t) = V0 * exp(-2*nu*t) - (D/nu) * expm1(-2*nu*t)\n            exp_term = np.exp(-2.0 * nu * t)\n            variance = V0 * exp_term + (D / nu) * (1.0 - exp_term)\n            return variance\n\n    results = []\n    for case in test_cases:\n        nu, D, V0, T_end, B, V_reset = case\n\n        # Task A: Calculate the variance at the final time T_end\n        v_final = calculate_variance(nu, D, V0, T_end)\n\n        # Task B: Calculate the variance threshold V_th\n        # The resampling period is T = 1/B\n        T = 1.0 / B\n        v_threshold = calculate_variance(nu, D, V_reset, T)\n\n        results.append(v_final)\n        results.append(v_threshold)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}