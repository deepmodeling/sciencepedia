{
    "hands_on_practices": [
        {
            "introduction": "理论的价值最终体现在实践中。本练习旨在通过编写代码来验证结构保持格式的优越性。您将亲手实现并对比一个保持结构的积分器（隐式中点法）和一个不保持结构的积分器（前向欧拉法），直观地观察它们在处理哈密顿系统和守恒律时的巨大差异。通过构建一个简单的回归测试套件，您将巩固对数值方法如何影响仿真结果物理真实性的理解。",
            "id": "4191850",
            "problem": "您的任务是编写一个完整的程序，为与聚变等离子体湍流模拟相关的无量纲简化模型实现不变量回归测试。目标是量化隐式和保结构时间积分格式如何影响不变量的守恒性，并展示此类测试对方法和容差选择的敏感性。您必须为一个小型测试套件输出通过或失败的布尔值决策。所有数学运算都必须按无量纲处理。\n\n您可以使用的基本理论是：\n\n- 单模线性系统的哈密顿力学：对于具有哈密顿量 $H(q,p)=\\tfrac{1}{2}p^2+\\tfrac{1}{2}\\omega^2 q^2$ 的正则对 $(q,p)$，其哈密顿方程为 $\\dot{q}=+\\partial H/\\partial p=p$ 和 $\\dot{p}=-\\partial H/\\partial q=-\\omega^2 q$。其精确不变量是总能量 $E=\\tfrac{1}{2}p^2+\\tfrac{1}{2}\\omega^2 q^2$。\n- 一维周期性电荷密度 $\\rho(x,t)$ 在长度为 $L$ 的区域上以恒定速度 $v$ 运动的连续性方程：$\\partial_t \\rho + \\partial_x (v \\rho) = 0$。其精确不变量是总电荷 $Q(t)=\\int_0^L \\rho(x,t)\\,\\mathrm{d}x$，对于周期性边界，它满足 $\\mathrm{d}Q/\\mathrm{d}t=0$。\n- 隐式中点法，对于 $\\dot{y}=f(y)$ 定义如下：给定时间步长 $\\Delta t$，找到 $y_{n+1}$ 使得 $y_{n+1}=y_n+\\Delta t\\, f\\!\\left(\\tfrac{1}{2}(y_n+y_{n+1})\\right)$。此方法对于正则哈密顿系统是辛的，并且在一致的空间离散化下，对于线性问题能保持二次不变量。\n- 在具有 $N$ 个点和间距 $\\Delta x=L/N$ 的均匀周期性网格上的标准中心有限差分空间导数，定义为 $(\\partial_x \\rho)_i \\approx (\\rho_{i+1}-\\rho_{i-1})/(2\\Delta x)$，索引采用周期性环绕。这种离散导数在 $\\ell^2$ 内积下是斜对称的，并且其列和为零，这意味着与隐式中点时间步进结合使用时，离散总电荷在求解器容差范围内是精确守恒的。\n\n您的程序必须实现两个子系统及其不变量测试：\n\n1) 线性哈密顿振子的能量守恒。考虑系统 $\\dot{q}=p$, $\\dot{p}=-\\omega^2 q$，初始条件为 $q(0)=q_0$, $p(0)=p_0$。实现两种时间步进方法，以大小为 $\\Delta t$ 的均匀步长进行 $N_{\\text{steps}}$ 次步进：\n- 一种保结构的隐式中点法。\n- 一种非保结构的前向欧拉法。\n定义 $N_{\\text{steps}}$ 步后的能量不变量误差为相对误差 $\\varepsilon_E = \\lvert E_{N_{\\text{steps}}}-E_0\\rvert/\\lvert E_0\\rvert$，其中 $E_n=\\tfrac{1}{2}p_n^2+\\tfrac{1}{2}\\omega^2 q_n^2$。如果 $\\varepsilon_E \\le \\text{tol}$，则测试通过，否则失败。\n\n2) 线性平流中的电荷守恒。考虑在长度为 $L$ 的周期性区域上的 $\\partial_t \\rho + v \\partial_x \\rho = 0$，该区域在具有 $N$ 个点和间距 $\\Delta x=L/N$ 的均匀网格上离散化，初始条件为 $\\rho(x,0)=1+0.1\\sin(2\\pi x/L)$。实现两种方法，以大小为 $\\Delta t$ 的均匀步长进行 $N_{\\text{steps}}$ 次步进：\n- 将保结构的隐式中点法应用于采用中心有限差分导数的线方法半离散化。\n- 一种用于周期性平流的带线性插值的非守恒半拉格朗日方法。\n定义总电荷为 $Q_n=\\sum_{i=0}^{N-1} \\rho_i^{(n)} \\Delta x$。定义 $N_{\\text{steps}}$ 步后的电荷不变量误差为相对误差 $\\varepsilon_Q = \\lvert Q_{N_{\\text{steps}}}-Q_0\\rvert/\\lvert Q_0\\rvert$。如果 $\\varepsilon_Q \\le \\text{tol}$，则测试通过，否则失败。\n\n您必须实现以上内容并运行以下测试套件。对于每种情况，您必须输出一个布尔值，当且仅当相应的不变量误差不超过给定容差时，该值为通过（true）。\n\n以下所有量均为无量纲，因此不需要物理单位。\n\n测试套件：\n- 案例1（能量，守恒）：参数 $(omega,Delta t,N_{\\text{steps}},q_0,p_0,\\text{tol})=(1.7, 0.2, 200, 1.0, 0.0, 1 \\times 10^{-10})$，使用隐式中点法。\n- 案例2（能量，非守恒）：参数 $(omega,Delta t,N_{\\text{steps}},q_0,p_0,\\text{tol})=(1.7, 0.2, 200, 1.0, 0.0, 1 \\times 10^{-3})$，使用前向欧拉法。\n- 案例3（电荷，守恒）：参数 $(N,L,v,Delta t,N_{\\text{steps}},\\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1 \\times 10^{-12})$，使用带中心有限差分的隐式中点法。\n- 案例4（电荷，非守恒，严格容差）：参数 $(N,L,v,Delta t,N_{\\text{steps}},\\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1 \\times 10^{-6})$，使用半拉格朗日线性插值法。\n- 案例5（电荷，非守恒，宽松容差）：参数 $(N,L,v,Delta t,N_{\\text{steps}},\\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1 \\times 10^{-1})$，使用半拉格朗日线性插值法。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试套件一致。例如，输出必须具有 \"[result1,result2,result3,result4,result5]\" 的形式，其中每个结果都是您编程语言标准打印约定中的布尔字面量。\n\n您的实现必须是自包含的，并且不得要求任何输入。您实现的数值算法必须对于所提供的参数是正确且鲁棒的。唯一可接受的输出是如上指定的布尔结果，不带任何附加文本或格式。",
            "solution": "该问题要求为两个基本物理系统实现并验证数值时间积分格式，重点关注物理不变量的守恒性。这项任务是模拟代码开发中的一项标准程序，尤其是在聚变等离子体物理学等领域，因为在这些领域中，长时间的稳定性和保真度至关重要。我们将处理两个子系统：一个简单的谐振子，它模拟一个线性哈密顿系统中的单模；以及线性平流方程，它模拟输运过程。对于每个系统，我们将比较一个保结构积分器和一个非保结构积分器。\n\n对问题陈述的验证证实了其在科学上是合理的、适定的，并包含了继续求解所需的所有必要信息。所有模型、数值方法和参数都是标准的且定义清晰。\n\n首先，我们考虑单模线性哈密顿系统，即一个简单的谐振子。系统的状态由正则坐标对 $(q, p)$ 描述。哈密顿量 $H$ 是系统的总能量，由 $H(q,p) = \\frac{1}{2}p^2 + \\frac{1}{2}\\omega^2 q^2$ 给出，其中 $\\omega$ 是角频率。动力学由哈密顿方程支配：\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = p $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q $$\n在精确解中，哈密顿量 $H$ 是一个运动常数，即一个不变量。我们将测试两种数值方法在守恒该能量方面的能力。设状态向量为 $\\mathbf{y} = [q, p]^T$。该系统可以写成一个线性常微分方程 (ODE)：$\\dot{\\mathbf{y}} = A \\mathbf{y}$，其中矩阵 $A$ 为\n$$ A = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix} $$\n初始条件为 $\\mathbf{y}(0) = [q_0, p_0]^T$。时间步长 $n$ 处的数值解记为 $\\mathbf{y}_n = [q_n, p_n]^T$。步长 $n$ 处的能量为 $E_n = \\frac{1}{2}p_n^2 + \\frac{1}{2}\\omega^2 q_n^2$。测试评估相对误差 $\\varepsilon_E = |E_{N_{\\text{steps}}} - E_0| / |E_0|$。\n\n第一种方法是**隐式中点法**。对于一个常微分方程 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$，单步由以下隐式方程给出：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right) $$\n对于我们的线性系统，$f(\\mathbf{y}) = A \\mathbf{y}$，所以方程变为：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t A \\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right) $$\n整理方程以求解 $\\mathbf{y}_{n+1}$，我们得到一个线性系统：\n$$ \\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{y}_{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{y}_n $$\n解由单步更新规则 $\\mathbf{y}_{n+1} = M_{\\text{IM}} \\mathbf{y}_n$ 给出，其中更新矩阵为 $M_{\\text{IM}} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right)$。隐式中点法是一种辛积分器，意味着它能保持哈密顿系统的几何结构。对于像这样的二次哈密顿量，众所周知它能精确地守恒能量，直到浮点精度。因此，对于案例1，我们预期能量误差 $\\varepsilon_E$ 将非常小，远在 $1 \\times 10^{-10}$ 的容差之内。\n\n第二种方法是**前向欧拉法**。这是一种显式的、非保结构的方法。单步由以下公式给出：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f(\\mathbf{y}_n) = (I + \\Delta t A) \\mathbf{y}_n $$\n更新矩阵 $M_{\\text{FE}} = I + \\Delta t A$ 的特征值为 $1 \\pm i\\omega\\Delta t$，它们的模都为 $\\sqrt{1 + (\\omega\\Delta t)^2} > 1$。这意味着数值解是不稳定的，$(q,p)$ 的振幅会随着每一步而增长。因此，能量 $E_n$ 将系统性地增加。对于案例2，当 $\\omega=1.7, \\Delta t=0.2$，且 $N_{\\text{steps}}=200$ 时，我们预期能量会有显著增加，导致误差 $\\varepsilon_E$ 远超 $1 \\times 10^{-3}$ 的容差。\n\n其次，我们考虑一维线性平流方程，描述电荷密度 $\\rho(x,t)$ 以恒定速度 $v$ 在长度为 $L$ 的周期性区域上传播：\n$$ \\frac{\\partial \\rho}{\\partial t} + v \\frac{\\partial \\rho}{\\partial x} = 0 $$\n总电荷 $Q(t) = \\int_0^L \\rho(x,t) \\, \\mathrm{d}x$ 是一个精确不变量。我们在一个由 $N$ 个点 $x_i = i \\Delta x$（其中 $\\Delta x = L/N$）组成的均匀周期性网格上离散化该系统。离散总电荷为 $Q_n = \\sum_{i=0}^{N-1} \\rho_i^{(n)} \\Delta x$，其中 $\\rho_i^{(n)}$ 是在网格点 $i$ 和时间步长 $n$ 的密度。测试评估相对误差 $\\varepsilon_Q = |Q_{N_{\\text{steps}}} - Q_0| / |Q_0|$。初始条件为 $\\rho(x,0)=1+0.1\\sin(2\\pi x/L)$。对于此分布，离散初始电荷恰好是 $Q_0 = L$。\n\n第一种方法结合了**中心有限差分**空间离散化和**隐式中点**时间积分。这是一种线方法。空间导数近似为 $(\\partial_x \\rho)_i \\approx (\\rho_{i+1} - \\rho_{i-1}) / (2\\Delta x)$。这定义了一个微分矩阵 $D$，使得半离散化系统为 $\\frac{d\\vec{\\rho}}{dt} = -vD\\vec{\\rho}$，其中 $\\vec{\\rho}$ 是网格值的向量。矩阵 $D$ 是循环且斜对称的 ($D^T = -D$)，这意味着它的列和为零。应用隐式中点法得到更新 $\\vec{\\rho}_{n+1} = \\left(I + \\frac{v\\Delta t}{2}D\\right)^{-1} \\left(I - \\frac{v\\Delta t}{2}D\\right) \\vec{\\rho}_n$。因为 $D$ 的列和为零，可以从数学上证明，这个更新矩阵精确地保持了 $\\vec{\\rho}$ 的元素之和。因此，离散总电荷 $Q_n$ 在浮点误差范围内是守恒的。对于案例3，我们预期 $\\varepsilon_Q$ 会非常小，能够通过 $1 \\times 10^{-12}$ 的容差。\n\n第二种方法是**带线性插值的半拉格朗日格式**。平流方程的解是一个简单的平移：$\\rho(x_i, t_{n+1}) = \\rho(x_i - v\\Delta t, t_n)$。点 $x'_i = x_i - v\\Delta t$ 是出发点。它通常不落在网格点上。其值通过在时间 $t_n$ 从两个最近的网格点的值进行线性插值来估计。虽然这种方法通常准确且稳定（特别是在大时间步长下），但插值过程不能保证局部或全局守恒。插值后的值之和通常不等于原始值之和。对于案例4，由于容差严格（$1 \\times 10^{-6}$），我们预期小的、非零的守恒误差会在 $400$ 步中累积，导致测试失败。对于案例5，容差放宽到 $1 \\times 10^{-1}$。半拉格朗日格式通常非常精确，所以累积的误差应该远低于这个宽松的阈值，从而导致测试通过。\n\n总之，该测试套件旨在展示数值积分器的关键特性：保结构方法（隐式中点法）能高精度地守恒不变量，而非保结构方法（前向欧拉法）或非严格守恒的方法（半拉格朗日法）则不能。预期的输出结果是 `[True, False, True, False, True]`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a test suite for invariant conservation in numerical schemes\n    for reduced models relevant to fusion plasma simulation.\n    \"\"\"\n\n    def run_oscillator_test(omega, dt, n_steps, q0, p0, tol, method):\n        \"\"\"\n        Runs a test for energy conservation in a linear Hamiltonian oscillator.\n\n        Args:\n            omega (float): Oscillator frequency.\n            dt (float): Time step size.\n            n_steps (int): Number of time steps.\n            q0 (float): Initial position.\n            p0 (float): Initial momentum.\n            tol (float): Tolerance for the relative error test.\n            method (str): 'midpoint' for implicit midpoint or 'euler' for forward Euler.\n\n        Returns:\n            bool: True if the test passes, False otherwise.\n        \"\"\"\n        y = np.array([q0, p0], dtype=np.float64)\n        A = np.array([[0, 1], [-omega**2, 0]], dtype=np.float64)\n\n        def energy(state):\n            q, p = state\n            return 0.5 * p**2 + 0.5 * omega**2 * q**2\n\n        e0 = energy(y)\n        if e0 == 0:\n            # Handle the case of zero initial energy. If final energy is also zero,\n            # error is 0. Otherwise, any non-zero final energy gives infinite relative error.\n            # In this problem, e0 is never zero.\n            y_final = np.copy(y)\n            for _ in range(n_steps):\n                if method == 'midpoint':\n                    # No evolution if start at origin\n                    pass\n                elif method == 'euler':\n                    y_final = (np.eye(2) + dt * A) @ y_final\n            e_final = energy(y_final)\n            return e_final == 0\n        \n        if method == 'midpoint':\n            # y_n+1 = (I - dt/2 * A)^-1 * (I + dt/2 * A) * y_n\n            Id = np.eye(2)\n            M_inv = np.linalg.inv(Id - 0.5 * dt * A)\n            M_add = Id + 0.5 * dt * A\n            update_matrix = M_inv @ M_add\n            for _ in range(n_steps):\n                y = update_matrix @ y\n        elif method == 'euler':\n            # y_n+1 = (I + dt * A) * y_n\n            update_matrix = np.eye(2) + dt * A\n            for _ in range(n_steps):\n                y = update_matrix @ y\n        \n        e_final = energy(y)\n        rel_error = np.abs(e_final - e0) / np.abs(e0)\n        \n        return rel_error = tol\n\n    def run_advection_test(N, L, v, dt, n_steps, tol, method):\n        \"\"\"\n        Runs a test for charge conservation in linear advection.\n\n        Args:\n            N (int): Number of grid points.\n            L (float): Domain length.\n            v (float): Advection velocity.\n            dt (float): Time step size.\n            n_steps (int): Number of time steps.\n            tol (float): Tolerance for the relative error test.\n            method (str): 'midpoint' for implicit midpoint/centered differences\n                          or 'lagrangian' for semi-Lagrangian.\n\n        Returns:\n            bool: True if the test passes, False otherwise.\n        \"\"\"\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False, dtype=np.float64)\n        rho = 1.0 + 0.1 * np.sin(2 * np.pi * x / L)\n        \n        q0 = np.sum(rho) * dx\n        if q0 == 0:\n            rho_final = np.copy(rho)\n            for _ in range(n_steps):\n                if method == 'midpoint':\n                    rho_final = np.zeros_like(rho)\n                elif method == 'lagrangian':\n                    # ... logic for zero initial state\n                    # Not needed for this problem's IC.\n                    pass\n            q_final = np.sum(rho_final) * dx\n            return q_final == 0\n\n        if method == 'midpoint':\n            # d(rho)/dt = -v * D * rho, where D is centered difference matrix\n            # Create the circulant differentiation matrix D\n            D = (np.roll(np.eye(N), -1, axis=1) - np.roll(np.eye(N), 1, axis=1)) / (2 * dx)\n            A_adv = -v * D\n\n            # Implicit midpoint update matrix\n            Id = np.eye(N)\n            M_inv = np.linalg.inv(Id - 0.5 * dt * A_adv)\n            M_add = Id + 0.5 * dt * A_adv\n            update_matrix = M_inv @ M_add\n            \n            for _ in range(n_steps):\n                rho = update_matrix @ rho\n        \n        elif method == 'lagrangian':\n            grid_indices = np.arange(N)\n            # Courant number is uniform, so departure points can be precalculated\n            # relative to grid indices.\n            departure_idx_float = grid_indices - v * dt / dx\n            \n            for _ in range(n_steps):\n                low_indices = np.floor(departure_idx_float).astype(int)\n                weights = departure_idx_float - low_indices\n                \n                # Use modulo arithmetic for periodic boundaries\n                # Python's % operator handles negative numbers correctly for this\n                rho_interp_low = rho[low_indices % N]\n                rho_interp_high = rho[(low_indices + 1) % N]\n                \n                rho = (1 - weights) * rho_interp_low + weights * rho_interp_high\n        \n        q_final = np.sum(rho) * dx\n        rel_error = np.abs(q_final - q0) / np.abs(q0)\n        \n        return rel_error = tol\n    \n    # Test suite definition\n    test_cases = [\n        {'type': 'energy', 'method': 'midpoint', 'params': (1.7, 0.2, 200, 1.0, 0.0, 1e-10)},\n        {'type': 'energy', 'method': 'euler', 'params': (1.7, 0.2, 200, 1.0, 0.0, 1e-3)},\n        {'type': 'charge', 'method': 'midpoint', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-12)},\n        {'type': 'charge', 'method': 'lagrangian', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-6)},\n        {'type': 'charge', 'method': 'lagrangian', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-1)}\n    ]\n    \n    results = []\n    for case in test_cases:\n        if case['type'] == 'energy':\n            omega, dt, n_steps, q0, p0, tol = case['params']\n            result = run_oscillator_test(omega, dt, n_steps, q0, p0, tol, case['method'])\n            results.append(result)\n        elif case['type'] == 'charge':\n            N, L, v, dt, n_steps, tol = case['params']\n            result = run_advection_test(N, L, v, dt, n_steps, tol, case['method'])\n            results.append(result)\n            \n    # Format and print the final output as a single line\n    # Python's str(True) is 'True', as required by problem for boolean literals\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "前面的练习都假设隐式方程能够被精确求解，但这在实际计算中往往难以实现。本练习将理论与隐式方法在高性能模拟中的实际应用联系起来，探讨了迭代求解器（如牛顿法）的有限精度如何破坏能量守恒。您将实现一个能量保持积分器（平均向量场法），量化非精确求解带来的能量漂移，并学习一种强大且实用的后处理技术——基于残差的能量校正——以恢复离散能量守恒，确保在面对实际数值限制时仍能维持仿真的长期保真度。",
            "id": "4191897",
            "problem": "您的任务是评估在与聚变等离子体湍流模拟相关的隐式保结构时间积分格式中，降低牛顿迭代容差对离散能量守恒的影响。使用一个有限维哈密顿模型（该模型编码了无碰撞静电动力学中典型的基本能量和斜对称结构），实现平均向量场（AVF）方法，并量化不精确的隐式求解如何影响守恒性。然后，设计并实现一个基于残差的能量修正方法，将离散能量恢复到指定的精度。\n\n其底层的动力学系统是一个有限维哈密顿常微分方程，状态为 $\\mathbf{u} \\in \\mathbb{R}^n$，具有斜对称结构矩阵 $\\mathbf{J} \\in \\mathbb{R}^{n \\times n}$ 和哈密顿量 $H(\\mathbf{u})$。其演化遵循\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{J} \\nabla H(\\mathbf{u}),\n$$\n其中 $\\mathbf{J}^\\top = -\\mathbf{J}$ 且 $\\nabla H$ 表示关于 $\\mathbf{u}$ 的梯度。哈密顿量取为\n$$\nH(\\mathbf{u}) = \\frac{1}{2}\\,\\mathbf{u}^\\top \\mathbf{K}\\,\\mathbf{u} + \\frac{c}{4}\\,\\|\\mathbf{u}\\|^4,\n$$\n其中 $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵， $c \\ge 0$ 是控制弱非线性的标量。该函数形式反映了一个二次“线性”分量和一个四次“非线性极化”分量，并且是简化的静电回旋动理学或回旋流体模型中自由能的简化替代品。所有量纲均为无量纲。\n\n平均向量场（AVF）方法通过以下隐式方程从 $\\mathbf{u}_n$ 推进到 $\\mathbf{u}_{n+1}$\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\,\\mathbf{J} \\int_0^1 \\nabla H\\!\\left(\\mathbf{u}_n + s(\\mathbf{u}_{n+1} - \\mathbf{u}_n)\\right)\\,ds,\n$$\n只要非线性方程被精确求解，该方法对于任意步长 $\\Delta t$ 都是能量守恒的。对于上述哈密顿量，记 $\\mathbf{a} = \\mathbf{u}_n$ 且 $\\mathbf{d} = \\mathbf{u}_{n+1} - \\mathbf{u}_n$。那么\n$$\n\\nabla H(\\mathbf{u}) = \\mathbf{K}\\mathbf{u} + c\\,\\|\\mathbf{u}\\|^2\\,\\mathbf{u},\n$$\n并且 AVF 线积分具有一个闭式表达式\n$$\n\\int_0^1 \\nabla H(\\mathbf{a} + s\\mathbf{d})\\,ds = \\frac{1}{2}\\,\\mathbf{K}(\\mathbf{a} + \\mathbf{u}_{n+1}) + c\\,\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d}),\n$$\n其中\n$$\n\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d}) =\n(\\mathbf{a}\\cdot\\mathbf{a})\\,\\mathbf{a}\\,+\\,\\frac{1}{2}(\\mathbf{a}\\cdot\\mathbf{a})\\,\\mathbf{d}\\,+\\,(\\mathbf{a}\\cdot\\mathbf{d})\\,\\mathbf{a}\\,+\\,\\frac{2}{3}(\\mathbf{a}\\cdot\\mathbf{d})\\,\\mathbf{d}\\,+\\,\\frac{1}{3}(\\mathbf{d}\\cdot\\mathbf{d})\\,\\mathbf{a}\\,+\\,\\frac{1}{4}(\\mathbf{d}\\cdot\\mathbf{d})\\,\\mathbf{d}.\n$$\n\n该隐式方程的单步残差为\n$$\n\\mathbf{F}(\\mathbf{x};\\mathbf{a}) = \\mathbf{x} - \\mathbf{a} - \\Delta t\\,\\mathbf{J}\\left(\\frac{1}{2}\\,\\mathbf{K}(\\mathbf{a} + \\mathbf{x}) + c\\,\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{x}-\\mathbf{a})\\right),\n$$\n目标为 $\\mathbf{x} = \\mathbf{u}_{n+1}$。牛顿法所需的雅可比矩阵 $\\mathbf{D}\\mathbf{F}(\\mathbf{x};\\mathbf{a})$ 是\n$$\n\\mathbf{D}\\mathbf{F}(\\mathbf{x};\\mathbf{a}) = \\mathbf{I} - \\Delta t\\,\\mathbf{J}\\left(\\frac{1}{2}\\,\\mathbf{K} + c\\,\\mathbf{J}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d})\\right),\n$$\n其中 $\\mathbf{d} = \\mathbf{x} - \\mathbf{a}$ 且 $\\mathbf{J}_{\\mathrm{cubic}}$ 是 $\\mathbf{I}_{\\mathrm{cubic}}$ 关于 $\\mathbf{d}$ 的雅可比矩阵，\n$$\n\\mathbf{J}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d}) = \\frac{1}{2}(\\mathbf{a}\\cdot\\mathbf{a})\\,\\mathbf{I} + \\mathbf{a}\\mathbf{a}^\\top + \\frac{2}{3}\\left(\\mathbf{d}\\mathbf{a}^\\top + (\\mathbf{a}\\cdot\\mathbf{d})\\,\\mathbf{I}\\right) + \\frac{2}{3}\\mathbf{a}\\mathbf{d}^\\top + \\frac{1}{4}\\left((\\mathbf{d}\\cdot\\mathbf{d})\\,\\mathbf{I} + 2\\,\\mathbf{d}\\mathbf{d}^\\top\\right).\n$$\n\n当牛顿法因残差容差 $\\varepsilon_{\\mathrm{Newton}}$ 不够小而提前终止时，得到的 $\\mathbf{u}_{n+1}$ 不再高精度地满足 AVF 方程，离散能量也不再精确守恒。为将能量恢复到指定的精度，引入一个基于能量残差的标量能量修正。将能量残差定义为\n$$\nr_E = H(\\mathbf{u}_{n+1}) - H(\\mathbf{u}_n),\n$$\n并通过将 $\\mathbf{u}_{n+1}$ 乘以一个由下式决定的标量 $\\lambda$ 来进行重缩放，从而获得修正后的状态\n$$\ng(\\lambda) = H(\\lambda\\,\\mathbf{u}_{n+1}) - H(\\mathbf{u}_n) = 0.\n$$\n对于给定的 $H$，记 $A = \\mathbf{u}_{n+1}^\\top \\mathbf{K}\\,\\mathbf{u}_{n+1}$ 和 $B = \\|\\mathbf{u}_{n+1}\\|^4$。那么\n$$\ng(\\lambda) = \\frac{1}{2}\\lambda^2 A + \\frac{c}{4}\\lambda^4 B - H(\\mathbf{u}_n),\\quad g'(\\lambda) = \\lambda A + c\\,\\lambda^3 B.\n$$\n在实践中，从 $\\lambda = 1$ 开始初始化的单个牛顿步，\n$$\n\\lambda \\leftarrow \\lambda - \\frac{g(\\lambda)}{g'(\\lambda)},\n$$\n足以将 $|g(\\lambda)|$ 减小到期望的能量容差 $\\varepsilon_{\\mathrm{energy}}$，因为当隐式残差很小时，$r_E$ 也很小。当启用能量修正时，在下一步中使用这个修正后的状态 $\\mathbf{u}_{n+1}^{\\mathrm{corr}} = \\lambda\\,\\mathbf{u}_{n+1}$。\n\n实现由残差容差 $\\varepsilon_{\\mathrm{Newton}}$ 控制的、使用牛顿法的 AVF 积分器，以及一个目标容差为 $\\varepsilon_{\\mathrm{energy}}$ 的可选能量修正。模拟固定的步数 $N$ 并测量最终时刻的相对能量误差，\n$$\nE_{\\mathrm{rel}} = \\frac{|H(\\mathbf{u}_N) - H(\\mathbf{u}_0)|}{\\max(1,|H(\\mathbf{u}_0)|)}.\n$$\n\n您的程序必须：\n\n- 将 $\\mathbf{J}$ 构建为块对角矩阵，包含 3 个标准的 $2\\times 2$ 辛块，即 $n=6$ 且每个块为 $$\\begin{pmatrix}0  1\\\\ -1  0\\end{pmatrix}$$。\n- 将 $\\mathbf{K}$ 构建为对角矩阵，每个标准对都配对相同的条目：选择频率 $\\omega_1 = 1.0$，$\\omega_2 = 1.5$，$\\omega_3 = 2.0$，并设置 $\\mathbf{K} = \\mathrm{diag}(\\omega_1^2, \\omega_1^2, \\omega_2^2, \\omega_2^2, \\omega_3^2, \\omega_3^2)$。\n- 通过设置 $\\mathbf{u}_0 = \\alpha\\,\\mathbf{v}$ 将 $\\mathbf{u}_0$ 初始化为一个可复现的非平凡状态，其中 $\\alpha = 0.1$，$\\mathbf{v}$ 为固定向量 $\\mathbf{v} = [1, -1, 0.5, -0.5, 0.25, -0.25]^\\top$。\n- 使用 AVF 方法和上述闭式表达式、用于求解隐式步的牛顿法，并可选择在每步应用标量能量重缩放修正，直到能量残差低于 $\\varepsilon_{\\mathrm{energy}}$。\n\n设计测试套件以覆盖问题的不同方面：\n\n- 情况 $\\mathrm{A}$：“理想路径”，牛顿容差很小，$N=500$，$\\Delta t = 0.02$，$c = 0.1$，$\\varepsilon_{\\mathrm{Newton}} = 10^{-10}$，禁用能量修正。\n- 情况 $\\mathrm{B}$：降低牛顿容差，$N=500$，$\\Delta t = 0.02$，$c = 0.1$，$\\varepsilon_{\\mathrm{Newton}} = 10^{-3}$，禁用能量修正。\n- 情况 $\\mathrm{C}$：降低牛顿容差并进行修正，$N=500$，$\\Delta t = 0.02$，$c = 0.1$，$\\varepsilon_{\\mathrm{Newton}} = 10^{-3}$，启用能量修正，$\\varepsilon_{\\mathrm{energy}} = 10^{-10}$。\n- 情况 $\\mathrm{D}$：非常宽松的牛顿容差并进行修正，$N=500$，$\\Delta t = 0.02$，$c = 0.1$，$\\varepsilon_{\\mathrm{Newton}} = 5\\times 10^{-2}$，启用能量修正，$\\varepsilon_{\\mathrm{energy}} = 10^{-10}$。\n- 情况 $\\mathrm{E}$：边界线性情况，$N=500$，$\\Delta t = 0.02$，$c = 0.0$，$\\varepsilon_{\\mathrm{Newton}} = 10^{-3}$，禁用能量修正。\n\n对于每个测试用例，运行两次模拟：一次不进行每步能量修正，另一次进行每步能量修正（使用相同的参数，修正运行时 $\\varepsilon_{\\mathrm{energy}} = 10^{-10}$）。按顺序 $[E_{\\mathrm{rel}}^{\\mathrm{uncorrected}}, E_{\\mathrm{rel}}^{\\mathrm{corrected}}]$ 为每个情况报告两个最终的相对能量误差（浮点数）。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个包含两个浮点数 $[E_{\\mathrm{rel}}^{\\mathrm{uncorrected}}, E_{\\mathrm{rel}}^{\\mathrm{corrected}}]$ 的列表，按情况 $\\mathrm{A}$ 到 $\\mathrm{E}$ 的顺序排列。例如，输出应类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4],[x_5,y_5]]$，其中每个 $x_i,y_i$ 都是浮点数。",
            "solution": "用户提供了一个定义明确的计算问题，该问题属于常微分方程数值方法领域，特别是关注哈密顿系统的几何积分器。对问题陈述的验证证实了其科学上的合理性、自洽性，并且算法描述足够详细，可以进行唯一的实现。用于平均向量场（AVF）积分器的数学公式、其相关的牛顿法非线性残差和雅可比矩阵，以及能量修正程序已经过验证并确认为正确。该问题是实现和分析保结构数值格式的标准练习，这是计算物理和应用数学中的一个重要课题。\n\n解决方案通过开发一个使用 `numpy` 库的 Python 程序来实现指定的数值方法。该程序的结构如下：\n\n首先，定义辅助函数来构建问题特定的矩阵 $\\mathbf{J}$ 和 $\\mathbf{K}$，并计算哈密顿函数 $H(\\mathbf{u})$。矩阵 $\\mathbf{J} \\in \\mathbb{R}^{6 \\times 6}$ 是斜对称和块对角的，由三个 $2 \\times 2$ 的标准辛块组成。矩阵 $\\mathbf{K} \\in \\mathbb{R}^{6 \\times 6}$ 是对称正定和对角的，其条目由指定的频率确定。\n$$\n\\mathbf{J} = \\begin{pmatrix} \\mathbf{J}_2  \\mathbf{0}  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{J}_2  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{0}  \\mathbf{J}_2 \\end{pmatrix}, \\quad \\mathbf{J}_2 = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}\n$$\n$$\n\\mathbf{K} = \\mathrm{diag}(\\omega_1^2, \\omega_1^2, \\omega_2^2, \\omega_2^2, \\omega_3^2, \\omega_3^2)\n$$\n\n其次，实现 AVF 积分器的核心组件。这涉及将提供的三次积分项 $\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d})$ 及其雅可比矩阵 $\\mathbf{J}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d})$ 的解析公式转换为向量和矩阵运算。然后，使用这些函数来构建牛顿法所需的残差函数 $\\mathbf{F}(\\mathbf{x};\\mathbf{a})$ 及其雅可比矩阵 $\\mathbf{D F}(\\mathbf{x};\\mathbf{a})$。一个函数 `avf_step` 封装了牛顿迭代过程，该过程求解隐式方程 $\\mathbf{F}(\\mathbf{u}_{n+1}; \\mathbf{u}_n) = \\mathbf{0}$ 以找到下一时间步的状态 $\\mathbf{u}_{n+1}$。迭代持续进行，直到残差 $\\mathbf{F}$ 的欧几里得范数低于指定的容差 $\\varepsilon_{\\mathrm{Newton}}$ 或达到最大迭代次数。\n\n第三，实现可选的能量修正机制。此过程封装在函数 `energy_correction` 中，它接收一个新计算出的状态 $\\mathbf{u}_{n+1}$，并寻找一个标量修正因子 $\\lambda$，使得重缩放后的状态 $\\lambda \\mathbf{u}_{n+1}$ 与该步开始时的状态 $\\mathbf{u}_n$ 具有完全相同的能量。求根问题 $g(\\lambda) = H(\\lambda \\mathbf{u}_{n+1}) - H(\\mathbf{u}_n) = 0$ 通过对 $\\lambda$ 使用几个牛顿步来求解，从 $\\lambda=1$ 开始，直到能量残差 $|g(\\lambda)|$ 低于目标容差 $\\varepsilon_{\\mathrm{energy}}$。\n\n最后，创建一个主模拟驱动程序 `run_simulation`。它根据问题规范（包括初始条件 $\\mathbf{u}_0$）初始化系统。然后，它迭代指定的步数 $N$，在每一步调用 `avf_step`。根据一个布尔标志，它也可能调用 `energy_correction` 来对每一步的结果进行后处理。在 $N$ 步之后，它计算最终的相对能量误差，$E_{\\mathrm{rel}} = |H(\\mathbf{u}_N) - H(\\mathbf{u}_0)| / \\max(1, |H(\\mathbf{u}_0)|)$。\n\n一个顶层函数 `solve` 协调整个过程。它按照规定定义了五个测试用例 (A-E) 的参数。对于每个用例，它调用 `run_simulation` 两次：一次禁用能量修正，以测量由不精确牛顿求解引起的能量漂移；另一次启用能量修正，以展示其有效性。将得到的成对能量误差收集起来，并格式化为问题描述中为最终输出所要求的精确字符串格式。对问题陈述中的用例定义进行解释，即对于每组物理和数值参数，执行两次模拟（未修正和已修正）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements and tests an Average Vector Field (AVF) integrator for a Hamiltonian system,\n    analyzing the effect of inexact Newton solves and a residual-based energy correction.\n    \"\"\"\n\n    # === Physical System and Helper Functions ===\n\n    def construct_J(n):\n        \"\"\"Constructs the skew-symmetric matrix J.\"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"n must be a multiple of 2\")\n        block = np.array([[0, 1], [-1, 0]], dtype=float)\n        num_blocks = n // 2\n        return np.kron(np.eye(num_blocks), block)\n\n    def construct_K(omegas):\n        \"\"\"Constructs the diagonal matrix K from frequencies.\"\"\"\n        k_vals = []\n        for w in omegas:\n            k_vals.extend([w**2, w**2])\n        return np.diag(k_vals)\n\n    def H(u, K, c):\n        \"\"\"Computes the Hamiltonian H(u).\"\"\"\n        u_norm_sq = u @ u\n        return 0.5 * u @ K @ u + (c / 4.0) * (u_norm_sq**2)\n\n    def I_cubic(a, d):\n        \"\"\"Computes the closed-form cubic integral term.\"\"\"\n        a_dot_a = a @ a\n        a_dot_d = a @ d\n        d_dot_d = d @ d\n        \n        term1 = a_dot_a * a\n        term2 = 0.5 * a_dot_a * d\n        term3 = a_dot_d * a\n        term4 = (2.0 / 3.0) * a_dot_d * d\n        term5 = (1.0 / 3.0) * d_dot_d * a\n        term6 = 0.25 * d_dot_d * d\n        \n        return term1 + term2 + term3 + term4 + term5 + term6\n\n    def J_cubic(a, d):\n        \"\"\"Computes the Jacobian of the cubic integral term w.r.t. d.\"\"\"\n        n = len(a)\n        I = np.identity(n)\n        a_dot_a = a @ a\n        a_dot_d = a @ d\n        d_dot_d = d @ d\n\n        term1 = 0.5 * a_dot_a * I\n        term2 = np.outer(a, a)\n        term3 = (2.0 / 3.0) * (np.outer(d, a) + a_dot_d * I)\n        term4 = (2.0 / 3.0) * np.outer(a, d)\n        term5 = 0.25 * (d_dot_d * I + 2.0 * np.outer(d, d))\n        \n        return term1 + term2 + term3 + term4 + term5\n\n    # === AVF Integrator with Newton's Method ===\n\n    def residual_F(x, a, dt, J, K, c):\n        \"\"\"Computes the residual F(x; a) for the AVF implicit equation.\"\"\"\n        d = x - a\n        integral_val = 0.5 * K @ (a + x)\n        if c != 0.0:\n            integral_val += c * I_cubic(a, d)\n        \n        return x - a - dt * (J @ integral_val)\n\n    def jacobian_DF(x, a, dt, J, K, c):\n        \"\"\"Computes the Jacobian DF(x; a).\"\"\"\n        n = len(a)\n        d = x - a\n        \n        J_integral = 0.5 * K\n        if c != 0.0:\n            J_integral += c * J_cubic(a, d)\n            \n        return np.identity(n) - dt * (J @ J_integral)\n\n    def avf_step(u_n, dt, J, K, c, newton_tol):\n        \"\"\"Performs one time step using the AVF method with Newton solver.\"\"\"\n        a = u_n\n        x = a.copy()  # Initial guess for u_{n+1}\n        \n        max_newton_iter = 20\n        for _ in range(max_newton_iter):\n            res = residual_F(x, a, dt, J, K, c)\n            \n            if np.linalg.norm(res) = newton_tol:\n                break\n                \n            jac = jacobian_DF(x, a, dt, J, K, c)\n            delta_x = np.linalg.solve(jac, -res)\n            x += delta_x\n        \n        return x\n\n    # === Energy Correction ===\n\n    def energy_correction(u_np1, u_n, H_n, K, c, energy_tol):\n        \"\"\"Applies a scalar rescaling to restore energy conservation.\"\"\"\n        if c == 0.0:\n            return u_np1\n\n        A = u_np1 @ K @ u_np1\n        norm_u_sq = u_np1 @ u_np1\n        B = norm_u_sq**2\n        \n        lam = 1.0\n        \n        max_lambda_iter = 5\n        for _ in range(max_lambda_iter):\n            g_lam = 0.5 * lam**2 * A + (c / 4.0) * lam**4 * B - H_n\n            \n            if abs(g_lam) = energy_tol:\n                break\n            \n            gp_lam = lam * A + c * lam**3 * B\n            if abs(gp_lam)  1e-15:\n                break\n            lam -= g_lam / gp_lam\n\n        return lam * u_np1\n\n    # === Main Simulation Loop ===\n\n    def run_simulation(params, correction_enabled):\n        \"\"\"Runs a full simulation for a given set of parameters.\"\"\"\n        N, dt, c, newton_tol, energy_tol = params\n        \n        n = 6\n        omegas = [1.0, 1.5, 2.0]\n        alpha = 0.1\n        v = np.array([1, -1, 0.5, -0.5, 0.25, -0.25])\n        \n        J = construct_J(n)\n        K = construct_K(omegas)\n        u_0 = alpha * v\n        \n        H_0 = H(u_0, K, c)\n        u = u_0.copy()\n        \n        for _ in range(N):\n            u_np1 = avf_step(u, dt, J, K, c, newton_tol)\n            \n            if correction_enabled:\n                H_n = H(u, K, c)\n                u_np1 = energy_correction(u_np1, u, H_n, K, c, energy_tol)\n            \n            u = u_np1\n            \n        H_N = H(u, K, c)\n        \n        denominator = max(1.0, abs(H_0))\n        rel_energy_error = abs(H_N - H_0) / denominator\n        \n        return rel_energy_error\n\n    # === Main Driver: Define and run test cases ===\n    \n    base_params = {\n        'N': 500,\n        'dt': 0.02,\n        'energy_tol': 1e-10\n    }\n    \n    test_cases_defs = [\n        # Case A\n        {'c': 0.1, 'newton_tol': 1e-10},\n        # Case B\n        {'c': 0.1, 'newton_tol': 1e-3},\n        # Case C\n        {'c': 0.1, 'newton_tol': 1e-3},\n        # Case D\n        {'c': 0.1, 'newton_tol': 5e-2},\n        # Case E\n        {'c': 0.0, 'newton_tol': 1e-3}\n    ]\n    \n    results = []\n    for case_def in test_cases_defs:\n        params = (\n            base_params['N'],\n            base_params['dt'],\n            case_def['c'],\n            case_def['newton_tol'],\n            base_params['energy_tol']\n        )\n        \n        E_rel_uncorrected = run_simulation(params, correction_enabled=False)\n        E_rel_corrected = run_simulation(params, correction_enabled=True)\n        \n        results.append([E_rel_uncorrected, E_rel_corrected])\n\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}