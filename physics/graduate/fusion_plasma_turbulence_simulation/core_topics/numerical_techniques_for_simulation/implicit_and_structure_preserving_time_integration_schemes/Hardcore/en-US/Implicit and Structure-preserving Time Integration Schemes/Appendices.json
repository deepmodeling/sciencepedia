{
    "hands_on_practices": [
        {
            "introduction": "A primary motivation for using structure-preserving integrators is their excellent long-term fidelity for oscillatory systems, which are ubiquitous in plasma physics. Symplectic methods achieve this not by eliminating error, but by ensuring the error does not lead to artificial growth or decay. This practice  provides a concrete, analytical look at this phenomenon by having you derive the \"modified frequency\" for a high-order symplectic integrator, revealing how it accurately preserves the phase of an oscillation over long times by introducing a small, predictable frequency shift.",
            "id": "4191896",
            "problem": "Consider a homogeneous, incompressible magnetized plasma described at large scales by ideal magnetohydrodynamics (MHD), with a uniform background magnetic field $\\mathbf{B}_0$ and constant mass density $\\rho_0$. A parallel Fourier mode of a linear Alfvén wave with parallel wavenumber $k_{\\parallel}$ has the exact continuum dispersion $\\omega_A = k_{\\parallel} v_A$, where $v_A = B_0 / \\sqrt{\\mu_0 \\rho_0}$ is the Alfvén speed, $\\mu_0$ is the vacuum permeability, and $B_0 = |\\mathbf{B}_0|$. The complex amplitude $a(t)$ of this mode evolves according to the linear ordinary differential equation (ODE) $\\,\\partial_t a(t) = i \\omega_A a(t)\\,$.\n\nYou discretize time using a single step of size $\\Delta t$ of the two-stage Gauss–Legendre Implicit Runge–Kutta (IRK) method (which is symplectic and order four). Let the one-step amplification factor be $g(\\alpha) = a^{n+1}/a^n$ with $\\alpha = \\omega_A \\Delta t$. Define the modified frequency $\\tilde{\\omega}$ by $g(\\alpha) = \\exp(i \\tilde{\\omega} \\Delta t)$.\n\nStarting from the governing ODE and the definition of the Gauss–Legendre IRK method’s linear stability function, derive an explicit closed-form analytic expression for $\\tilde{\\omega}$ in terms of $\\omega_A$ and $\\Delta t$. Then, using a small-$\\alpha$ expansion, compare this modified frequency with the exact dispersion by identifying the leading-order discrepancy and its dependence on $\\Delta t$, and interpret how symplecticity constrains the form of the error. Express your final answer as the closed-form analytic expression for $\\tilde{\\omega}(\\omega_A,\\Delta t)$. No rounding is required, and no units should be included in the final expression.",
            "solution": "The linear Alfvén wave in a uniform plasma is governed by ideal magnetohydrodynamics and has the exact continuum dispersion relation\n$$\n\\omega_A = k_{\\parallel} v_A,\\qquad v_A = \\frac{B_0}{\\sqrt{\\mu_0 \\rho_0}},\n$$\nwith the complex amplitude $a(t)$ of a single Fourier mode obeying\n$$\n\\frac{d a}{dt} = i \\omega_A a.\n$$\nThis is the linear test equation $y' = \\lambda y$ with $\\lambda = i \\omega_A$. A one-step method applied to this ODE yields $a^{n+1} = R(\\lambda \\Delta t)\\, a^n$, where $R(z)$ is the method’s linear stability function.\n\nFor the two-stage Gauss–Legendre Implicit Runge–Kutta method (order four), the stability function is the diagonal Padé approximant $[2/2]$ to the exponential,\n$$\nR_{2,2}(z) = \\frac{1 + \\frac{z}{2} + \\frac{z^2}{12}}{1 - \\frac{z}{2} + \\frac{z^2}{12}}.\n$$\nThis follows from the general property that the $s$-stage Gauss–Legendre IRK method has stability function equal to the $[s/s]$ Padé approximant to $\\exp(z)$, a well-tested result in geometric numerical integration. Setting $z = i \\alpha$ with $\\alpha = \\omega_A \\Delta t$, the one-step amplification factor is\n$$\ng(\\alpha) = R_{2,2}(i \\alpha) = \\frac{1 + \\frac{i \\alpha}{2} - \\frac{\\alpha^2}{12}}{1 - \\frac{i \\alpha}{2} - \\frac{\\alpha^2}{12}}.\n$$\nBecause the numerator and denominator are complex conjugates for purely imaginary $z$ (coefficients are real and the sign of the odd powers changes), $|g(\\alpha)| = 1$. This is consistent with symplecticity: for linear Hamiltonian systems, symplectic Runge–Kutta methods preserve quadratic invariants and yield unit-modulus amplification for purely oscillatory modes. Therefore $g(\\alpha)$ can be written as a pure rotation,\n$$\ng(\\alpha) = \\exp\\!\\big(i \\phi(\\alpha)\\big),\\qquad \\phi(\\alpha) \\in \\mathbb{R},\n$$\nand the modified frequency is $\\tilde{\\omega} = \\phi(\\alpha)/\\Delta t$.\n\nTo obtain $\\phi(\\alpha)$ explicitly, note that if $g = z/\\overline{z}$ with $z$ a complex number, then $g = \\exp(2 i \\arg z)$. Here,\n$$\nz = 1 + \\frac{i \\alpha}{2} - \\frac{\\alpha^2}{12} = \\Big(1 - \\frac{\\alpha^2}{12}\\Big) + i \\frac{\\alpha}{2}.\n$$\nThus,\n$$\n\\arg z = \\arctan\\!\\left(\\frac{\\frac{\\alpha}{2}}{1 - \\frac{\\alpha^2}{12}}\\right),\n\\quad\\Rightarrow\\quad\n\\phi(\\alpha) = 2\\,\\arctan\\!\\left(\\frac{\\frac{\\alpha}{2}}{1 - \\frac{\\alpha^2}{12}}\\right).\n$$\nTherefore the modified frequency is\n$$\n\\tilde{\\omega}(\\omega_A,\\Delta t) = \\frac{\\phi(\\alpha)}{\\Delta t}\n= \\frac{2}{\\Delta t}\\,\\arctan\\!\\left(\\frac{\\frac{\\omega_A \\Delta t}{2}}{1 - \\frac{(\\omega_A \\Delta t)^2}{12}}\\right).\n$$\n\nTo compare with the exact dispersion, perform a small-$\\alpha$ expansion. Define\n$$\nq(\\alpha) = \\frac{\\frac{\\alpha}{2}}{1 - \\frac{\\alpha^2}{12}}\n= \\frac{\\alpha}{2}\\left(1 + \\frac{\\alpha^2}{12} + \\frac{\\alpha^4}{144} + \\mathcal{O}(\\alpha^6)\\right)\n= \\frac{\\alpha}{2} + \\frac{\\alpha^3}{24} + \\frac{\\alpha^5}{288} + \\mathcal{O}(\\alpha^7).\n$$\nUsing $\\arctan x = x - \\frac{x^3}{3} + \\frac{x^5}{5} + \\mathcal{O}(x^7)$,\n\\begin{align*}\n\\arctan q(\\alpha)\n&= \\left(\\frac{\\alpha}{2} + \\frac{\\alpha^3}{24} + \\frac{\\alpha^5}{288}\\right)\n- \\frac{1}{3}\\left(\\frac{\\alpha^3}{8} + \\frac{\\alpha^5}{32}\\right)\n+ \\frac{1}{5}\\left(\\frac{\\alpha^5}{32}\\right) + \\mathcal{O}(\\alpha^7) \\\\\n&= \\frac{\\alpha}{2} + \\left(\\frac{1}{24} - \\frac{1}{24}\\right)\\alpha^3\n+ \\left(\\frac{1}{288} - \\frac{1}{96} + \\frac{1}{160}\\right)\\alpha^5 + \\mathcal{O}(\\alpha^7) \\\\\n&= \\frac{\\alpha}{2} - \\frac{\\alpha^5}{1440} + \\mathcal{O}(\\alpha^7).\n\\end{align*}\nHence,\n$$\n\\phi(\\alpha) = 2\\,\\arctan q(\\alpha) = \\alpha - \\frac{\\alpha^5}{720} + \\mathcal{O}(\\alpha^7),\n$$\nand therefore\n$$\n\\tilde{\\omega} = \\frac{\\phi(\\alpha)}{\\Delta t}\n= \\omega_A - \\frac{\\omega_A^5\\,\\Delta t^4}{720} + \\mathcal{O}(\\Delta t^6).\n$$\nThe leading discrepancy $\\tilde{\\omega} - \\omega_A$ scales as $\\mathcal{O}(\\Delta t^4)$, consistent with the method’s order four. Symplecticity constrains the error to be purely in the phase (frequency) with no amplitude error, i.e., $|g(\\alpha)|=1$, which is why the discrepancy appears only as a correction to $\\omega_A$ and not in the modulus of $g(\\alpha)$.\n\nThe requested final closed-form analytic expression for the modified frequency is\n$$\n\\tilde{\\omega}(\\omega_A,\\Delta t) = \\frac{2}{\\Delta t}\\,\\arctan\\!\\left(\\frac{\\frac{\\omega_A \\Delta t}{2}}{1 - \\frac{(\\omega_A \\Delta t)^2}{12}}\\right).\n$$",
            "answer": "$$\\boxed{\\frac{2}{\\Delta t}\\,\\arctan\\!\\left(\\frac{\\frac{\\omega_A \\Delta t}{2}}{1 - \\frac{(\\omega_A \\Delta t)^2}{12}}\\right)}$$"
        },
        {
            "introduction": "While the theoretical properties of a numerical scheme are fundamental, their benefits are only realized if the implementation is correct. A crucial skill in computational science is the ability to write verification tests that confirm the code behaves as designed. This coding exercise  tasks you with building a regression test suite to demonstrate the stark difference between structure-preserving and non-preserving schemes in conserving energy and charge. This practice builds not only an intuition for numerical conservation laws but also the practical skill of creating automated checks to ensure the long-term stability and correctness of your simulation code.",
            "id": "4191850",
            "problem": "You are tasked with writing a complete program that implements invariant regression tests for dimensionless reduced models tied to fusion plasma turbulence simulation. The goal is to quantify how implicit and structure-preserving time integration schemes affect conservation of invariants and to demonstrate the sensitivity of such tests to the choice of method and tolerance. You must output pass or fail decisions as booleans for a small test suite. All mathematics must be treated as dimensionless.\n\nThe fundamental base you may use is:\n\n- Hamiltonian mechanics for a single-mode linear system: Hamilton’s equations for a canonical pair $(q,p)$ with Hamiltonian $H(q,p)=\\tfrac{1}{2}p^2+\\tfrac{1}{2}\\omega^2 q^2$, namely $\\dot{q}=+\\partial H/\\partial p=p$ and $\\dot{p}=-\\partial H/\\partial q=-\\omega^2 q$. The exact invariant is the total energy $E=\\tfrac{1}{2}p^2+\\tfrac{1}{2}\\omega^2 q^2$.\n- The continuity equation for a one-dimensional, periodic charge density $\\rho(x,t)$ with constant velocity $v$ on a domain of length $L$: $\\partial_t \\rho + \\partial_x (v \\rho) = 0$. The exact invariant is the total charge $Q(t)=\\int_0^L \\rho(x,t)\\,\\mathrm{d}x$, which satisfies $\\mathrm{d}Q/\\mathrm{d}t=0$ for periodic boundaries.\n- The implicit midpoint method, defined as follows for $\\dot{y}=f(y)$: given a time step $\\Delta t$, find $y_{n+1}$ such that $y_{n+1}=y_n+\\Delta t\\, f\\!\\left(\\tfrac{1}{2}(y_n+y_{n+1})\\right)$. This method is symplectic for canonical Hamiltonian systems and preserves quadratic invariants for linear problems under consistent spatial discretizations.\n- A standard centered finite-difference spatial derivative on a uniform periodic grid with $N$ points and spacing $\\Delta x=L/N$, defined by $(\\partial_x \\rho)_i \\approx (\\rho_{i+1}-\\rho_{i-1})/(2\\Delta x)$ with periodic wrapping of indices. This discrete derivative is skew-symmetric in the $\\ell^2$ inner product and has zero column sum, implying that, combined with implicit midpoint time stepping, the discrete total charge is exactly preserved up to solver tolerance.\n\nYour program must implement two subsystems and their invariant tests:\n\n1) Energy conservation in a linear Hamiltonian oscillator. Consider the system $\\dot{q}=p$, $\\dot{p}=-\\omega^2 q$ with initial condition $q(0)=q_0$, $p(0)=p_0$. Implement two time-stepping methods over $N_{\\text{steps}}$ uniform steps of size $\\Delta t$:\n- A structure-preserving implicit midpoint method.\n- A non-structure-preserving forward Euler method.\nDefine the energy invariant error after $N_{\\text{steps}}$ as the relative error $\\varepsilon_E = \\lvert E_{N_{\\text{steps}}}-E_0\\rvert/\\lvert E_0\\rvert$, where $E_n=\\tfrac{1}{2}p_n^2+\\tfrac{1}{2}\\omega^2 q_n^2$. The test passes if $\\varepsilon_E \\le \\text{tol}$ and fails otherwise.\n\n2) Charge conservation in linear advection. Consider $\\partial_t \\rho + v \\partial_x \\rho = 0$ on a periodic domain of length $L$, discretized on a uniform grid of $N$ points with spacing $\\Delta x=L/N$, and initial condition $\\rho(x,0)=1+0.1\\sin(2\\pi x/L)$. Implement two methods over $N_{\\text{steps}}$ uniform steps of size $\\Delta t$:\n- A structure-preserving implicit midpoint method applied to the method-of-lines semi-discretization with the centered finite-difference derivative.\n- A non-conservative semi-Lagrangian method with linear interpolation for periodic advection.\nDefine the total charge as $Q_n=\\sum_{i=0}^{N-1} \\rho_i^{(n)} \\Delta x$. Define the charge invariant error after $N_{\\text{steps}}$ as the relative error $\\varepsilon_Q = \\lvert Q_{N_{\\text{steps}}}-Q_0\\rvert/\\lvert Q_0\\rvert$. The test passes if $\\varepsilon_Q \\le \\text{tol}$ and fails otherwise.\n\nYou must implement the above and run the following test suite. For each case, you must output a boolean indicating pass (true) if and only if the corresponding invariant error does not exceed the given tolerance.\n\nAll quantities below are dimensionless, so no physical units are required.\n\nTest suite:\n- Case 1 (energy, conserving): parameters $(\\omega, \\Delta t, N_{\\text{steps}}, q_0, p_0, \\text{tol})=(1.7, 0.2, 200, 1.0, 0.0, 1e-10)$, using implicit midpoint.\n- Case 2 (energy, non-conserving): parameters $(\\omega, \\Delta t, N_{\\text{steps}}, q_0, p_0, \\text{tol})=(1.7, 0.2, 200, 1.0, 0.0, 1e-3)$, using forward Euler.\n- Case 3 (charge, conserving): parameters $(N, L, v, \\Delta t, N_{\\text{steps}}, \\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1e-12)$, using implicit midpoint with centered finite differences.\n- Case 4 (charge, non-conservative, tight tolerance): parameters $(N, L, v, \\Delta t, N_{\\text{steps}}, \\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1e-6)$, using semi-Lagrangian linear interpolation.\n- Case 5 (charge, non-conservative, loose tolerance): parameters $(N, L, v, \\Delta t, N_{\\text{steps}}, \\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1e-1)$, using semi-Lagrangian linear interpolation.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite above. For example, the output must have the form \"[result1,result2,result3,result4,result5]\" where each result is a boolean literal in your programming language's standard printing convention.\n\nYour implementation must be self-contained and must not require any input. The numerical algorithms you implement must be correct and robust for the provided parameters. The only acceptable outputs are boolean results as specified above, with no additional text or formatting.",
            "solution": "The problem requires the implementation and validation of numerical time integration schemes for two fundamental physical systems, focusing on the conservation of physical invariants. This task is a standard procedure in the development of simulation codes, particularly in fields like fusion plasma physics where long-time stability and fidelity are paramount. We will address two subsystems: a simple harmonic oscillator, which models a single mode in a linear Hamiltonian system, and the linear advection equation, which models transport. For each, we will compare a structure-preserving integrator with a non-structure-preserving one.\n\nThe validation of the problem statement confirms that it is scientifically sound, well-posed, and contains all necessary information to proceed with a solution. All models, numerical methods, and parameters are standard and clearly defined.\n\nFirst, we consider the single-mode linear Hamiltonian system, a simple harmonic oscillator. The state is described by the canonical coordinate pair $(q, p)$. The Hamiltonian $H$ is the total energy of the system, given by $H(q,p) = \\frac{1}{2}p^2 + \\frac{1}{2}\\omega^2 q^2$, where $\\omega$ is the angular frequency. The dynamics are governed by Hamilton's equations:\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = p $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q $$\nIn the exact solution, the Hamiltonian $H$ is a constant of motion, an invariant. We will test two numerical methods for their ability to conserve this energy. Let the state vector be $\\mathbf{y} = [q, p]^T$. The system can be written as a linear ordinary differential equation (ODE): $\\dot{\\mathbf{y}} = A \\mathbf{y}$, where the matrix $A$ is\n$$ A = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix} $$\nThe initial condition is $\\mathbf{y}(0) = [q_0, p_0]^T$. The numerical solution at time step $n$ is denoted $\\mathbf{y}_n = [q_n, p_n]^T$. The energy at step $n$ is $E_n = \\frac{1}{2}p_n^2 + \\frac{1}{2}\\omega^2 q_n^2$. The test evaluates the relative error $\\varepsilon_E = |E_{N_{\\text{steps}}} - E_0| / |E_0|$.\n\nThe first method is the **implicit midpoint rule**. For an ODE $\\dot{\\mathbf{y}} = f(\\mathbf{y})$, a single step is given by the implicit equation:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right) $$\nFor our linear system, $f(\\mathbf{y}) = A \\mathbf{y}$, so this becomes:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t A \\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right) $$\nRearranging for $\\mathbf{y}_{n+1}$, we obtain a linear system to solve:\n$$ \\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{y}_{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{y}_n $$\nThe solution is given by the single-step update rule $\\mathbf{y}_{n+1} = M_{\\text{IM}} \\mathbf{y}_n$, where the update matrix is $M_{\\text{IM}} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right)$. The implicit midpoint method is a symplectic integrator, meaning it preserves the geometric structure of Hamiltonian systems. For a quadratic Hamiltonian like this one, it is known to conserve the energy exactly, up to floating-point precision. Therefore, for Case 1, we expect the energy error $\\varepsilon_E$ to be very small, well within the tolerance of $1 \\times 10^{-10}$.\n\nThe second method is the **forward Euler method**. This is an explicit, non-structure-preserving method. A single step is given by:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f(\\mathbf{y}_n) = (I + \\Delta t A) \\mathbf{y}_n $$\nThe eigenvalues of the update matrix $M_{\\text{FE}} = I + \\Delta t A$ are $1 \\pm i\\omega\\Delta t$, both of which have a magnitude of $\\sqrt{1 + (\\omega\\Delta t)^2} > 1$. This means the numerical solution is unstable, and the amplitude of $(q,p)$ will grow with each step. Consequently, the energy $E_n$ will systematically increase. For Case 2, with $\\omega=1.7$, $\\Delta t=0.2$, and $N_{\\text{steps}}=200$, we expect a significant increase in energy, causing the error $\\varepsilon_E$ to far exceed the tolerance of $1 \\times 10^{-3}$.\n\nSecond, we consider the one-dimensional linear advection equation for a charge density $\\rho(x,t)$ with a constant velocity $v$ on a periodic domain of length $L$:\n$$ \\frac{\\partial \\rho}{\\partial t} + v \\frac{\\partial \\rho}{\\partial x} = 0 $$\nThe total charge, $Q(t) = \\int_0^L \\rho(x,t) \\, \\mathrm{d}x$, is an exact invariant. We discretize the system on a uniform periodic grid of $N$ points $x_i = i \\Delta x$ where $\\Delta x = L/N$. The discrete total charge is $Q_n = \\sum_{i=0}^{N-1} \\rho_i^{(n)} \\Delta x$, where $\\rho_i^{(n)}$ is the density at grid point $i$ and time step $n$. The test evaluates the relative error $\\varepsilon_Q = |Q_{N_{\\text{steps}}} - Q_0| / |Q_0|$. The initial condition is $\\rho(x,0)=1+0.1\\sin(2\\pi x/L)$. For this profile, the discrete initial charge is exactly $Q_0 = L$.\n\nThe first method combines a **centered finite-difference** spatial discretization with the **implicit midpoint** time integration. This is a method-of-lines approach. The spatial derivative is approximated as $(\\partial_x \\rho)_i \\approx (\\rho_{i+1} - \\rho_{i-1}) / (2\\Delta x)$. This defines a differentiation matrix $D$ such that the semi-discretized system is $\\frac{d\\vec{\\rho}}{dt} = -vD\\vec{\\rho}$, where $\\vec{\\rho}$ is the vector of grid values. The matrix $D$ is circulant and skew-symmetric ($D^T = -D$), which implies that its column sums are zero. Applying the implicit midpoint rule yields the update $\\vec{\\rho}_{n+1} = \\left(I + \\frac{v\\Delta t}{2}D\\right)^{-1} \\left(I - \\frac{v\\Delta t}{2}D\\right) \\vec{\\rho}_n$. Because the column sums of $D$ are zero, it can be mathematically shown that the sum of the elements of $\\vec{\\rho}$ is exactly preserved by this update matrix. Thus, the discrete total charge $Q_n$ is conserved up to floating-point error. For Case 3, we expect $\\varepsilon_Q$ to be very small, passing the tolerance of $1 \\times 10^{-12}$.\n\nThe second method is a **semi-Lagrangian scheme with linear interpolation**. The solution to the advection equation is a simple translation: $\\rho(x_i, t_{n+1}) = \\rho(x_i - v\\Delta t, t_n)$. The point $x'_i = x_i - v\\Delta t$ is the departure point. It generally does not lie on a grid point. Its value is estimated by linearly interpolating from the values at the two nearest grid points at time $t_n$. While often accurate and stable (especially for large time steps), this interpolation process is not guaranteed to be locally or globally conservative. The sum of interpolated values is not, in general, equal to the sum of the original values. For Case 4, with a tight tolerance of $1 \\times 10^{-6}$, we expect the small but non-zero conservation error to accumulate over 400 steps and cause the test to fail. For Case 5, the tolerance is relaxed to $1 \\times 10^{-1}$. Semi-Lagrangian schemes are typically very accurate, so the accumulated error should be well below this generous threshold, leading to a pass.\n\nIn summary, the test suite is designed to demonstrate key properties of numerical integrators: structure-preserving methods (implicit midpoint) conserve invariants to high precision, whereas non-structure-preserving methods (forward Euler) or methods that are not strictly conservative (semi-Lagrangian) do not. The expected outcomes are `[True, False, True, False, True]`.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a test suite for invariant conservation in numerical schemes\n    for reduced models relevant to fusion plasma simulation.\n    \"\"\"\n\n    def run_oscillator_test(omega, dt, n_steps, q0, p0, tol, method):\n        \"\"\"\n        Runs a test for energy conservation in a linear Hamiltonian oscillator.\n\n        Args:\n            omega (float): Oscillator frequency.\n            dt (float): Time step size.\n            n_steps (int): Number of time steps.\n            q0 (float): Initial position.\n            p0 (float): Initial momentum.\n            tol (float): Tolerance for the relative error test.\n            method (str): 'midpoint' for implicit midpoint or 'euler' for forward Euler.\n\n        Returns:\n            bool: True if the test passes, False otherwise.\n        \"\"\"\n        y = np.array([q0, p0], dtype=np.float64)\n        A = np.array([[0, 1], [-omega**2, 0]], dtype=np.float64)\n\n        def energy(state):\n            q, p = state\n            return 0.5 * p**2 + 0.5 * omega**2 * q**2\n\n        e0 = energy(y)\n        if e0 == 0:\n            # Handle the case of zero initial energy. If final energy is also zero,\n            # error is 0. Otherwise, any non-zero final energy gives infinite relative error.\n            # In this problem, e0 is never zero.\n            y_final = np.copy(y)\n            for _ in range(n_steps):\n                if method == 'midpoint':\n                    # No evolution if start at origin\n                    pass\n                elif method == 'euler':\n                    y_final = (np.eye(2) + dt * A) @ y_final\n            e_final = energy(y_final)\n            return e_final == 0\n        \n        if method == 'midpoint':\n            # y_n+1 = (I - dt/2 * A)^-1 * (I + dt/2 * A) * y_n\n            Id = np.eye(2)\n            M_inv = np.linalg.inv(Id - 0.5 * dt * A)\n            M_add = Id + 0.5 * dt * A\n            update_matrix = M_inv @ M_add\n            for _ in range(n_steps):\n                y = update_matrix @ y\n        elif method == 'euler':\n            # y_n+1 = (I + dt * A) * y_n\n            update_matrix = np.eye(2) + dt * A\n            for _ in range(n_steps):\n                y = update_matrix @ y\n        \n        e_final = energy(y)\n        rel_error = np.abs(e_final - e0) / np.abs(e0)\n        \n        return rel_error = tol\n\n    def run_advection_test(N, L, v, dt, n_steps, tol, method):\n        \"\"\"\n        Runs a test for charge conservation in linear advection.\n\n        Args:\n            N (int): Number of grid points.\n            L (float): Domain length.\n            v (float): Advection velocity.\n            dt (float): Time step size.\n            n_steps (int): Number of time steps.\n            tol (float): Tolerance for the relative error test.\n            method (str): 'midpoint' for implicit midpoint/centered differences\n                          or 'lagrangian' for semi-Lagrangian.\n\n        Returns:\n            bool: True if the test passes, False otherwise.\n        \"\"\"\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False, dtype=np.float64)\n        rho = 1.0 + 0.1 * np.sin(2 * np.pi * x / L)\n        \n        q0 = np.sum(rho) * dx\n        if q0 == 0:\n            rho_final = np.copy(rho)\n            for _ in range(n_steps):\n                if method == 'midpoint':\n                    rho_final = np.zeros_like(rho)\n                elif method == 'lagrangian':\n                    # ... logic for zero initial state\n                    # Not needed for this problem's IC.\n                    pass\n            q_final = np.sum(rho_final) * dx\n            return q_final == 0\n\n        if method == 'midpoint':\n            # d(rho)/dt = -v * D * rho, where D is centered difference matrix\n            # Create the circulant differentiation matrix D\n            D = (np.roll(np.eye(N), -1, axis=1) - np.roll(np.eye(N), 1, axis=1)) / (2 * dx)\n            A_adv = -v * D\n\n            # Implicit midpoint update matrix\n            Id = np.eye(N)\n            M_inv = np.linalg.inv(Id - 0.5 * dt * A_adv)\n            M_add = Id + 0.5 * dt * A_adv\n            update_matrix = M_inv @ M_add\n            \n            for _ in range(n_steps):\n                rho = update_matrix @ rho\n        \n        elif method == 'lagrangian':\n            grid_indices = np.arange(N)\n            # Courant number is uniform, so departure points can be precalculated\n            # relative to grid indices.\n            departure_idx_float = grid_indices - v * dt / dx\n            \n            for _ in range(n_steps):\n                low_indices = np.floor(departure_idx_float).astype(int)\n                weights = departure_idx_float - low_indices\n                \n                # Use modulo arithmetic for periodic boundaries\n                # Python's % operator handles negative numbers correctly for this\n                rho_interp_low = rho[low_indices % N]\n                rho_interp_high = rho[(low_indices + 1) % N]\n                \n                rho = (1 - weights) * rho_interp_low + weights * rho_interp_high\n        \n        q_final = np.sum(rho) * dx\n        rel_error = np.abs(q_final - q0) / np.abs(q0)\n        \n        return rel_error = tol\n    \n    # Test suite definition\n    test_cases = [\n        {'type': 'energy', 'method': 'midpoint', 'params': (1.7, 0.2, 200, 1.0, 0.0, 1e-10)},\n        {'type': 'energy', 'method': 'euler', 'params': (1.7, 0.2, 200, 1.0, 0.0, 1e-3)},\n        {'type': 'charge', 'method': 'midpoint', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-12)},\n        {'type': 'charge', 'method': 'lagrangian', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-6)},\n        {'type': 'charge', 'method': 'lagrangian', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-1)}\n    ]\n    \n    results = []\n    for case in test_cases:\n        if case['type'] == 'energy':\n            omega, dt, n_steps, q0, p0, tol = case['params']\n            result = run_oscillator_test(omega, dt, n_steps, q0, p0, tol, case['method'])\n            results.append(result)\n        elif case['type'] == 'charge':\n            N, L, v, dt, n_steps, tol = case['params']\n            result = run_advection_test(N, L, v, dt, n_steps, tol, case['method'])\n            results.append(result)\n            \n    # Format and print the final output as a single line\n    # Python's str(True) is 'True', as required by problem for boolean literals\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "In practical simulations of complex systems like plasma turbulence, preserving physical structure requires a holistic approach to the entire numerical scheme, not just the time integrator. The choice of spatial discretization and its interaction with nonlinear terms is equally critical. In this advanced practice , you will discover how aliasing errors in a Fourier pseudospectral method can break the discrete energy conservation of a symplectic time integrator. By implementing a dealiasing technique to restore energy balance, you will gain hands-on experience with the vital interplay between spatial and temporal discretization in building a truly robust, structure-preserving simulation.",
            "id": "4191868",
            "problem": "Consider the two-dimensional electrostatic Hasegawa–Mima equation on a periodic square domain of side length $2\\pi$ with spatial coordinates $(x,y)$ and time variable $t$, defined by the partial differential equation\n$$\n\\frac{\\partial}{\\partial t}\\left(\\nabla^2 \\phi - \\phi\\right) + J\\!\\left(\\phi,\\nabla^2 \\phi - \\phi\\right) = 0,\n$$\nwhere $\\phi(x,y,t)$ is the electrostatic potential and $J(a,b) \\equiv \\partial_x a\\,\\partial_y b - \\partial_y a\\,\\partial_x b$ is the Jacobian. Define the generalized potential vorticity $q(x,y,t) \\equiv \\nabla^2 \\phi(x,y,t) - \\phi(x,y,t)$ and denote the Fourier transform of a field by a hat, so that $q_{\\mathbf{k}}(t)$ and $\\phi_{\\mathbf{k}}(t)$ are the Fourier coefficients at wavevector $\\mathbf{k} = (k_x,k_y)$. The Fourier-space relation is $q_{\\mathbf{k}}(t) = -\\left(|\\mathbf{k}|^2 + 1\\right)\\,\\phi_{\\mathbf{k}}(t)$, which is invertible for all wavevectors $\\mathbf{k}$.\n\nOn a uniform $N \\times N$ grid with $N$ even, use a Fourier pseudospectral spatial discretization with Fast Fourier Transform (FFT) and its inverse (Fast Fourier Transform (FFT)) to approximate derivatives, and compute the nonlinear Jacobian $J(\\phi,q)$ via products in physical space. The continuous system has a quadratic energy invariant\n$$\nE(t) = \\frac{1}{2}\\int_{[0,2\\pi]^2} \\left(|\\nabla \\phi(x,y,t)|^2 + |\\phi(x,y,t)|^2\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\nwhich, in Fourier variables, can be written as\n$$\nE(t) = \\frac{1}{2}\\sum_{\\mathbf{k}} \\left(|\\mathbf{k}|^2 + 1\\right)\\,|\\phi_{\\mathbf{k}}(t)|^2.\n$$\nIn a discrete setting using non-unitary FFT conventions, ensure that energy is computed with a scaling consistent with the discrete Parseval identity.\n\nTime-advance the semi-discrete system for $q$ using the implicit midpoint method, which is a symplectic one-step scheme: for time step $\\Delta t$, the update from $t^n$ to $t^{n+1}=t^n+\\Delta t$ is defined implicitly by\n$$\nq^{n+1} = q^n - \\Delta t\\; J\\!\\left(\\phi^{\\mathrm{mid}},q^{\\mathrm{mid}}\\right),\n$$\nwhere $q^{\\mathrm{mid}} = \\frac{1}{2}\\left(q^n + q^{n+1}\\right)$ and $\\phi^{\\mathrm{mid}}$ is obtained from $q^{\\mathrm{mid}}$ via $\\phi^{\\mathrm{mid}}_{\\mathbf{k}} = -\\,q^{\\mathrm{mid}}_{\\mathbf{k}}/\\left(|\\mathbf{k}|^2 + 1\\right)$ for all $\\mathbf{k}$. Use a fixed-point iteration at each step to solve the implicit equation for $q^{n+1}$.\n\nWhen computing nonlinear products in physical space with a pseudospectral method, convolution aliasing can destroy the discrete skew-symmetry of the Jacobian operator and cause spurious energy drift even when using a symplectic time integrator. Implement the $2/3$ dealiasing rule as follows: in Fourier space, define a mask that sets to zero all modes with $|k_x| > N/3$ or $|k_y| > N/3$; then, for computing the Jacobian, first project the Fourier coefficients of both $\\phi$ and $q$ onto the masked set, compute derivatives spectrally, form the Jacobian in physical space, and project the resulting Fourier transform of the Jacobian back onto the masked set. For the dealiased runs, also project the initial Fourier coefficients of $q$ onto the masked set. For the non-dealiased runs, perform the same operations without any masking.\n\nInitialize $\\phi(x,y,0)$ with a smooth, nontrivial combination of a few Fourier modes to produce nonlinear interactions, for example:\n$$\n\\phi(x,y,0) = 0.1\\cos(x)\\cos(2y) + 0.1\\sin(2x)\\sin(y) + 0.1\\cos(3x - 2y),\n$$\nand set $q_{\\mathbf{k}}(0) = -\\left(|\\mathbf{k}|^2 + 1\\right)\\,\\phi_{\\mathbf{k}}(0)$.\n\nYour task is to:\n- Implement the Fourier pseudospectral solver described above with the implicit midpoint method for time integration.\n- Quantify aliasing effects on the discrete energy invariant by computing the relative energy drift defined as\n$$\n\\delta_E = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|,\n$$\nwhere $T$ is the final time. All quantities are dimensionless; report $\\delta_E$ as a floating-point decimal number.\n- Implement the $2/3$ dealiasing rule as described and demonstrate that it restores the discrete energy balance to within numerical tolerances for the same time integrator.\n\nUse the following test suite of parameter sets $(N,\\Delta t,T,\\mathrm{dealiased})$:\n- Test $1$: $(64,0.05,1.0,\\mathrm{False})$ as a general case without dealiasing.\n- Test $2$: $(64,0.05,1.0,\\mathrm{True})$ as a general case with dealiasing.\n- Test $3$: $(16,0.05,1.0,\\mathrm{False})$ as a coarse-grid boundary case without dealiasing.\n- Test $4$: $(64,0.10,1.0,\\mathrm{True})$ as a larger time-step case with dealiasing.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests given, for example: $[\\delta_{E,1},\\delta_{E,2},\\delta_{E,3},\\delta_{E,4}]$. The outputs must be floating-point decimal numbers.",
            "solution": "We start from the Hasegawa–Mima equation, which in the electrostatic limit is a two-dimensional nonlinear partial differential equation with Hamiltonian structure. The generalized potential vorticity is $q = \\nabla^2 \\phi - \\phi$, and the evolution equation can be written as\n$$\n\\frac{\\partial q}{\\partial t} + J(\\phi,q) = 0,\n$$\nwhere $J(a,b) = \\partial_x a\\,\\partial_y b - \\partial_y a\\,\\partial_x b$ is bilinear and skew-symmetric in the sense that, for sufficiently smooth periodic functions $a$ and $b$, we have $\\int a\\,J(a,b)\\,\\mathrm{d}x\\,\\mathrm{d}y = 0$ and $\\int b\\,J(a,b)\\,\\mathrm{d}x\\,\\mathrm{d}y = 0$. The Hamiltonian (energy) for this system is\n$$\nE = \\frac{1}{2}\\int \\left(|\\nabla \\phi|^2 + |\\phi|^2\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\nwhich can also be expressed in Fourier variables as\n$$\nE = \\frac{1}{2}\\sum_{\\mathbf{k}} \\left(|\\mathbf{k}|^2 + 1\\right)\\,|\\phi_{\\mathbf{k}}|^2,\n$$\nmaking use of the standard orthogonality of Fourier modes and Parseval's identity. Because $q_{\\mathbf{k}} = -\\left(|\\mathbf{k}|^2 + 1\\right)\\phi_{\\mathbf{k}}$, one may express the energy in terms of $q_{\\mathbf{k}}$ as\n$$\nE = \\frac{1}{2}\\sum_{\\mathbf{k}} \\frac{|q_{\\mathbf{k}}|^2}{|\\mathbf{k}|^2 + 1}.\n$$\n\nDiscretization in space is performed using a Fourier pseudospectral method on an $N \\times N$ grid over a $2\\pi \\times 2\\pi$ periodic domain. Let $x_j = 2\\pi j/N$ and $y_\\ell = 2\\pi \\ell / N$ for $j,\\ell = 0,1,\\ldots,N-1$. The discrete Fourier transform and its inverse (Fast Fourier Transform (FFT) and inverse) are used to transform between physical and spectral spaces. Spectral differentiation is exact for the resolved modes: $\\partial_x \\phi \\leftrightarrow i k_x \\phi_{\\mathbf{k}}$ and $\\partial_y \\phi \\leftrightarrow i k_y \\phi_{\\mathbf{k}}$. The Jacobian $J(\\phi,q)$ is computed by transforming the spectral derivatives to physical space, forming the product $\\partial_x \\phi \\cdot \\partial_y q - \\partial_y \\phi \\cdot \\partial_x q$, and transforming back to spectral space.\n\nAliasing arises because the pointwise product in physical space corresponds to convolution in spectral space, which may produce frequencies beyond the resolved range. Those higher frequencies then \"wrap around\" into the resolved band due to the discrete Fourier transform, resulting in spurious interactions that violate the discrete skew-symmetry of the nonlinear operator. The $2/3$ dealiasing rule avoids these spurious contributions by projecting the fields onto a band-limited subspace before forming products, with a mask that retains only modes satisfying $|k_x| \\le N/3$ and $|k_y| \\le N/3$. In this subspace, the sum of any two resolved wavevectors stays within the representable range, preventing aliasing in the quadratic nonlinearity.\n\nTime integration is performed using the implicit midpoint method, which is symplectic and preserves quadratic invariants for ordinary differential equations of the form $\\dot{z} = S(z)\\nabla H(z)$ where $S(z)$ is skew-symmetric and $H(z)$ is quadratic. In our semi-discrete setting, if the discrete Jacobian operator is skew-adjoint with respect to the discrete inner product induced by the FFT conventions, then the energy computed with consistent scaling is preserved by the midpoint scheme. Specifically, for a finite-dimensional system $\\dot{\\mathbf{q}} = \\mathbf{f}(\\mathbf{q})$ with a quadratic invariant $I(\\mathbf{q}) = \\frac{1}{2}\\mathbf{q}^\\top \\mathbf{A}\\mathbf{q}$ and a flow satisfying $\\mathbf{A}\\mathbf{f}(\\mathbf{q})$ is skew-symmetric in the appropriate inner product, the implicit midpoint update\n$$\n\\mathbf{q}^{n+1} = \\mathbf{q}^n + \\Delta t\\,\\mathbf{f}\\Big(\\frac{\\mathbf{q}^n + \\mathbf{q}^{n+1}}{2}\\Big)\n$$\npreserves $I(\\mathbf{q})$ exactly in arithmetic (up to solver tolerance). In our pseudospectral discretization, aliasing breaks the skew-symmetry property and causes energy drift even under the symplectic scheme; hence dealiasing is crucial.\n\nAlgorithmic steps:\n- Construct integer wavenumbers $k_x$ and $k_y$ arrays using the FFT frequency functions, scaled so that spectral differentiation factors are $i k_x$ and $i k_y$ for a domain of period $2\\pi$, and form two-dimensional arrays $K_x$, $K_y$, and $K^2 = K_x^2 + K_y^2$.\n- Initialize $\\phi(x,y,0)$ as a sum of trigonometric functions with moderate amplitude, compute its Fourier transform $\\phi_{\\mathbf{k}}(0)$, and set $q_{\\mathbf{k}}(0) = -\\left(K^2 + 1\\right)\\phi_{\\mathbf{k}}(0)$.\n- For dealiasing, define the $2/3$ mask $M$ such that $M_{\\mathbf{k}} = 1$ if $|k_x| \\le N/3$ and $|k_y| \\le N/3$, and $M_{\\mathbf{k}} = 0$ otherwise. For dealiased runs, project $q_{\\mathbf{k}}(0)$ to $M \\circ q_{\\mathbf{k}}(0)$; for non-dealiased runs, use the full spectrum.\n- Implement a function to compute $J(\\phi,q)$ that:\n  1. Forms $\\phi_{\\mathbf{k}}$ from $q_{\\mathbf{k}}$ by $\\phi_{\\mathbf{k}} = -q_{\\mathbf{k}}/\\left(K^2+1\\right)$.\n  2. If dealiasing is enabled, projects both $\\phi_{\\mathbf{k}}$ and $q_{\\mathbf{k}}$ with the mask $M$.\n  3. Computes spectral derivatives $iK_x\\phi_{\\mathbf{k}}$, $iK_y\\phi_{\\mathbf{k}}$, $iK_x q_{\\mathbf{k}}$, $iK_y q_{\\mathbf{k}}$.\n  4. Transforms these derivatives to physical space via inverse FFT, forms the product $J$ in physical space, and transforms back via FFT.\n  5. If dealiasing is enabled, projects the resulting Jacobian spectrum with the mask $M$.\n- Implement the implicit midpoint step using fixed-point iteration: starting with an initial guess $q^{n+1,(0)}=q^n$, define $q^{\\mathrm{mid},(m)} = \\frac{1}{2}\\left(q^n + q^{n+1,(m)}\\right)$, compute $J^{(m)} = J\\!\\left(\\phi^{\\mathrm{mid},(m)},q^{\\mathrm{mid},(m)}\\right)$, and update $q^{n+1,(m+1)} = q^n - \\Delta t\\,J^{(m)}$ until convergence in a suitable norm.\n- Compute the discrete energy using the FFT-consistent Parseval scaling. For non-unitary FFT conventions (FFT without normalization and inverse FFT with $1/N^2$), the discrete energy consistent with the continuous expression is\n  $$\n  E_{\\mathrm{disc}} = \\frac{1}{2}\\,\\frac{1}{N^2}\\sum_{\\mathbf{k}} \\left(K^2 + 1\\right)\\,|\\phi_{\\mathbf{k}}|^2,\n  $$\n  which follows from applying Parseval’s identity and approximating the domain integral by the trapezoidal rule on the $N \\times N$ grid.\n- Report the relative energy drift $\\delta_E = \\left|{E(T) - E(0)}\\right|/E(0)$ for each test.\n\nExpected qualitative outcomes:\n- Without dealiasing on a moderate grid (test $1$), aliasing will break discrete skew-symmetry and produce a nonzero $\\delta_E$ at the level of the nonlinear interaction strength and time step.\n- With dealiasing on the same grid and time step (test $2$), the discrete Jacobian regains skew-symmetry with respect to the truncated inner product, and the implicit midpoint method will preserve energy to within solver and roundoff tolerances, resulting in $\\delta_E$ near machine precision.\n- On a coarse grid without dealiasing (test $3$), aliasing is more severe, yielding a larger $\\delta_E$.\n- With a larger time step but dealiasing (test $4$), energy preservation remains good, though fixed-point iteration tolerance and time discretization errors may slightly increase $\\delta_E$ compared to test $2$; it should remain small.\n\nThe final program implements these steps and outputs the four floating-point results in the specified single-line format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_wavenumbers(N):\n    # Integer wavenumbers for 2π-periodic domain; spectral differentiation uses i*k\n    k1d = np.fft.fftfreq(N) * N  # integers: 0,1,...,N/2-1,-N/2,...,-1\n    KX, KY = np.meshgrid(k1d, k1d, indexing='ij')\n    K2 = KX**2 + KY**2\n    return KX, KY, K2\n\ndef initial_phi(x, y):\n    # Smooth initial condition to generate nonlinear interactions\n    return 0.1*np.cos(x)*np.cos(2.0*y) + 0.1*np.sin(2.0*x)*np.sin(y) + 0.1*np.cos(3.0*x - 2.0*y)\n\ndef compute_energy(q_hat, K2, N):\n    # Energy E = 0.5 * (1/N^2) * sum_{k} (K2+1) * |phi_hat|^2, phi_hat = -q_hat/(K2+1)\n    denom = (K2 + 1.0)\n    phi_hat = -q_hat / denom\n    energy = 0.5 * (1.0/(N*N)) * np.sum(denom * (np.abs(phi_hat)**2))\n    return float(np.real(energy))\n\ndef jacobian_hat(q_hat, KX, KY, K2, dealiased, mask):\n    # Build phi_hat from q_hat\n    denom = (K2 + 1.0)\n    phi_hat = -q_hat / denom\n\n    if dealiased:\n        # Project to dealiased subspace\n        phi_hat = phi_hat * mask\n        q_hat = q_hat * mask\n\n    # Spectral derivatives\n    dphix_hat = 1j * KX * phi_hat\n    dphiy_hat = 1j * KY * phi_hat\n    dqdx_hat  = 1j * KX * q_hat\n    dqdy_hat  = 1j * KY * q_hat\n\n    # Transform to physical space\n    dphix = np.fft.ifft2(dphix_hat).real\n    dphiy = np.fft.ifft2(dphiy_hat).real\n    dqdx  = np.fft.ifft2(dqdx_hat).real\n    dqdy  = np.fft.ifft2(dqdy_hat).real\n\n    # Jacobian in physical space\n    J_phys = dphix * dqdy - dphiy * dqdx\n\n    # Back to spectral space\n    J_hat = np.fft.fft2(J_phys)\n\n    if dealiased:\n        J_hat = J_hat * mask\n\n    return J_hat\n\ndef implicit_midpoint(q_hat0, KX, KY, K2, dt, steps, dealiased, mask, tol=1e-12, max_iter=30):\n    q_hat = q_hat0.copy()\n    for _ in range(steps):\n        q_next = q_hat.copy()\n        # Fixed-point iteration\n        for _ in range(max_iter):\n            q_mid = 0.5 * (q_hat + q_next)\n            J_mid = jacobian_hat(q_mid, KX, KY, K2, dealiased, mask)\n            q_new = q_hat - dt * J_mid\n            # Convergence check in L2 spectral norm\n            num = np.linalg.norm(q_new - q_next)\n            den = max(np.linalg.norm(q_new), 1e-15)\n            if num / den  tol:\n                q_next = q_new\n                break\n            q_next = q_new\n        else:\n            # If not converged, accept last iterate\n            pass\n        q_hat = q_next\n    return q_hat\n\ndef run_case(N, dt, T, dealiased):\n    # Build wavenumbers and mask\n    KX, KY, K2 = build_wavenumbers(N)\n    cutoff = N // 3\n    mask = ((np.abs(KX) = cutoff)  (np.abs(KY) = cutoff)).astype(float)\n\n    # Physical grid\n    x = 2.0*np.pi * (np.arange(N) / N)\n    y = 2.0*np.pi * (np.arange(N) / N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial phi and q in spectral space\n    phi0 = initial_phi(X, Y)\n    phi_hat0 = np.fft.fft2(phi0)\n    q_hat0 = -(K2 + 1.0) * phi_hat0\n\n    if dealiased:\n        q_hat0 = q_hat0 * mask\n\n    E0 = compute_energy(q_hat0, K2, N)\n\n    steps = int(np.round(T / dt))\n    q_hatT = implicit_midpoint(q_hat0, KX, KY, K2, dt, steps, dealiased, mask)\n\n    ET = compute_energy(q_hatT, K2, N)\n    drift = abs(ET - E0) / (E0 if E0 != 0.0 else 1.0)\n    return drift\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 0.05, 1.0, False),\n        (64, 0.05, 1.0, True),\n        (16, 0.05, 1.0, False),\n        (64, 0.10, 1.0, True),\n    ]\n\n    results = []\n    for N, dt, T, dealiased in test_cases:\n        # Ensure N is even for FFT symmetry\n        if N % 2 != 0:\n            raise ValueError(\"N must be even.\")\n        result = run_case(N, dt, T, dealiased)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.6e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}