{
    "hands_on_practices": [
        {
            "introduction": "本节将通过一系列动手实践，加深您对半拉格朗日平流方案的理解。这些练习旨在将理论知识转化为实际的编程和分析技能。\n\n第一个实践  将引导您构建一个基础的半拉格朗日平流步骤。您将为一个简单的二维剪切流推导并计算精确的出发点，并使用线性插值来更新标量场。这个练习的核心价值在于，它不仅能让您掌握半拉格朗日方法的核心计算流程，还能通过与精确解的对比，直观地量化由插值引起的数值扩散效应。",
            "id": "3911375",
            "problem": "考虑在坐标为 $\\,x \\in [0,L_x]\\,$ 和 $\\,y \\in [0,L_y]\\,$ 的二维周期性域中，一个被动标量 $\\,\\phi(x,y,t)\\,$ 在恒定剪切流 $\\,\\boldsymbol{u}(x,y) = (S\\,y,\\,0)\\,$ 中的线性平流，其中 $\\,S\\,$ 是一个恒定的剪切率。该标量遵循平流方程 $\\,\\partial_t \\phi + \\boldsymbol{u}\\cdot\\nabla \\phi = 0\\,$。在半拉格朗日方法中，欧拉网格点 $\\,\\boldsymbol{x}_{i,j} = (x_i, y_j)\\,$ 在时间 $\\,t^{n+1} = t^n + \\Delta t\\,$ 的更新值，是通过将特征线在时间上向后追溯到一个满足 $\\,\\boldsymbol{x}_d = \\boldsymbol{x}_{i,j} - \\int_{t^n}^{t^{n+1}} \\boldsymbol{u}(\\boldsymbol{x}(s),s)\\,\\mathrm{d}s\\,$ 的出发点 $\\,\\boldsymbol{x}_d = (x_d, y_d)\\,$，然后对 $\\,\\boldsymbol{x}_d\\,$ 处的 $\\,\\phi^n\\,$ 进行插值得到的。\n\n从基本运动学关系 $\\,\\mathrm{d}\\boldsymbol{x}/\\mathrm{d}t = \\boldsymbol{u}(\\boldsymbol{x},t)\\,$ 出发，使用 $\\,\\boldsymbol{u}(x,y) = (S y, 0)\\,$（其中 $\\,S\\,$ 不随时间变化），推导单个时间步长 $\\,\\Delta t\\,$ 的精确出发点映射。在 $\\,x\\,$ 方向使用带周期性边界条件的分段线性插值，实现一个单步半拉格朗日更新，并量化由插值引起的扩散。\n\n所有量均为无量纲。使用 $\\,L_x = 1\\,$, $\\,L_y = 1\\,$, $\\,S = 1\\,$，一个在 $\\,x\\,$ 方向有 $\\,N_x\\,$ 个点、在 $\\,y\\,$ 方向有 $\\,N_y\\,$ 个点的均匀网格，网格间距为 $\\,\\Delta x = L_x/N_x\\,$ 和 $\\,\\Delta y = L_y/N_y\\,$。在 $\\,t^n\\,$ 时刻将标量场初始化为 $\\,\\phi^n(x,y) = \\sin(2\\pi m x)\\,$，其中 $\\,m\\,$ 为整数波数。对于给定的名义 Courant–Friedrichs–Lewy (CFL) 数 $\\,C\\,$，其定义为 $\\,C = \\max_{(x,y)} \\left( |u_x(x,y)| \\Delta t / \\Delta x \\right) = S\\,y_{\\max}\\,\\Delta t/\\Delta x\\,$，其中 $\\,y_{\\max} = L_y\\,$，设定 $\\,\\Delta t = C\\,\\Delta x/S\\,$。\n\n对于每个指定的 $\\,C\\,$ 值，执行一个半拉格朗日时间步：\n- 计算精确的出发点 $\\,x_d = x_i - S\\,y_j\\,\\Delta t\\,$ 和 $\\,y_d = y_j\\,$。\n- 计算精确的平流场 $\\,\\phi^{\\mathrm{exact}}(x_i,y_j) = \\sin\\!\\big(2\\pi m (x_i - S\\,y_j\\,\\Delta t)\\big)\\,$。\n- 通过对每个固定的 $\\,y_j\\,$，在 $\\,x_d\\,$ 处使用周期性边界条件对 $\\,\\phi^n\\,$ 进行线性插值，计算半拉格朗日场 $\\,\\phi^{\\mathrm{SL}}(x_i,y_j)\\,$。\n- 通过振幅比 $\\,R = \\|\\phi^{\\mathrm{SL}}\\|_2 / \\|\\phi^{\\mathrm{exact}}\\|_2\\,$ 评估插值引起的扩散，其中 $\\,\\|\\cdot\\|_2\\,$ 是网格上的离散二维欧几里得范数。\n- 同时计算最大网格单元出发距离 $\\,D = \\max_{i,j} \\big(|x_i - x_d|/\\Delta x\\big)\\,$，该值衡量以网格单元为单位的最大特征位移。\n\n测试套件和参数：\n- 使用 $\\,N_x = 128\\,$, $\\,N_y = 16\\,$ 和 $\\,m = 5\\,$。\n- 评估四个名义 CFL 数 $\\,C \\in \\{0.8,\\,1.0,\\,3.5,\\,16.0\\}\\,$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来，顺序为 $[R(C{=}0.8),D(C{=}0.8),R(C{=}1.0),D(C{=}1.0),R(C{=}3.5),D(C{=}3.5),R(C{=}16.0),D(C{=}16.0)]$。所有输出均为无量纲浮点数。不需要物理单位，且根据正弦初始条件的构造，角度单位为弧度。结果必须无需任何外部输入即可复现。",
            "solution": "问题陈述经评估为**有效**的。其科学基础在于流体动力学和数值分析的原理，特别是关于平流方程和半拉格朗日格式。该问题是适定的，提供了一套完整且一致的参数、初始条件和数值步骤。所有术语都得到了客观和数学上的定义，从而能够得到一个唯一且可验证的解。\n\n求解过程分为两部分：首先，对基于特征线的出发点映射进行解析推导；其次，设计数值算法来计算半拉格朗日更新并评估指定的度量指标。\n\n**1. 出发点映射的推导**\n\n半拉格朗日方法依赖于追溯流体质点轨迹（即特征线）在时间上的变化。质点的轨迹 $\\boldsymbol{x}(t)$ 由运动学常微分方程（ODE）组决定：\n$$\n\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t} = \\boldsymbol{u}(\\boldsymbol{x}, t)\n$$\n给定二维、不随时间变化的剪切流 $\\boldsymbol{u}(x,y) = (S\\,y, 0)$，其分量形式的ODE为：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = S\\,y\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = 0\n$$\n我们寻求在时间 $t^n$ 的出发点 $\\boldsymbol{x}_d = (x_d, y_d)$，该点在时间 $t^{n+1}$ 到达欧拉网格点 $\\boldsymbol{x}_{i,j} = (x_i, y_j)$。这涉及到将ODE系统在一个时间步长 $\\Delta t = t^{n+1} - t^n$ 内向后积分。\n\n将 $y$ 分量方程从 $t^{n+1}$ 向后积分到 $t^n$：\n$$\n\\int_{y(t^{n+1})}^{y(t^n)} \\mathrm{d}y = \\int_{t^{n+1}}^{t^n} 0\\,\\mathrm{d}t \\implies y(t^n) - y(t^{n+1}) = 0\n$$\n代入到达和出发坐标，我们得到 $y_d - y_j = 0$，即：\n$$\ny_d = y_j\n$$\n这个结果表明特征线是水平直线；在此流场中，流体质点的 $y$ 坐标保持不变。\n\n现在，我们对 $x$ 分量方程进行积分。$x(t^n)$ 的形式解为：\n$$\nx(t^n) = x(t^{n+1}) - \\int_{t^n}^{t^{n+1}} u_x(\\boldsymbol{x}(s))\\,\\mathrm{d}s\n$$\n代入 $u_x = S\\,y$ 以及对于一个到达 $y_j$ 的质点，其特征路径上的 $y(s) = y_j$ 是常数的事实：\n$$\nx_d = x_i - \\int_{t^n}^{t^{n+1}} S\\,y_j\\,\\mathrm{d}s\n$$\n由于 $S$ 和 $y_j$ 相对于积分变量 $s$ 是常数，我们可以将它们从积分中提取出来：\n$$\nx_d = x_i - S\\,y_j \\int_{t^n}^{t^{n+1}} \\mathrm{d}s = x_i - S\\,y_j (t^{n+1} - t^n)\n$$\n使用定义 $\\Delta t = t^{n+1} - t^n$，我们得到出发点的 $x$ 坐标：\n$$\nx_d = x_i - S\\,y_j\\,\\Delta t\n$$\n因此，单个时间步的精确出发点映射为 $(\\,x_d, y_d) = (x_i - S\\,y_j\\,\\Delta t, y_j)$，这证实了问题陈述中提供的表达式。\n\n**2. 数值算法与分析**\n\n半拉格朗日更新表明，平流标量沿特征线守恒，因此 $\\phi(\\boldsymbol{x}_{i,j}, t^{n+1}) = \\phi(\\boldsymbol{x}_d, t^n)$。我们基于此原理实现一个单步更新。\n\n**网格与参数：**\n- 域：$x \\in [0, L_x]$, $y \\in [0, L_y]$，其中 $L_x = 1$, $L_y = 1$。\n- 网格：$N_x = 128$, $N_y = 16$。网格坐标为 $x_i = i \\cdot (L_x/N_x)$（$i=0, \\dots, N_x-1$）和 $y_j = j \\cdot (L_y/N_y)$（$j=0, \\dots, N_y-1$）。\n- 剪切率：$S=1$。\n- 初始条件：$\\phi^n(x,y) = \\sin(2\\pi m x)$，其中波数 $m=5$。该场与 $y$ 无关。\n- 时间步长：$\\Delta t = C\\,\\Delta x/S$，因为用于CFL定义的 $y_{\\max}$ 被取为 $L_y = 1$。在 $S=1$ 的情况下，即为 $\\Delta t = C\\,\\Delta x$。\n\n**精确的平流场：**\n在时间 $t^{n+1}$ 的真实解是在出发点处计算的初始条件：\n$$\n\\phi^{\\mathrm{exact}}(x_i, y_j) = \\phi^n(x_d, y_d) = \\sin(2\\pi m x_d) = \\sin\\big(2\\pi m (x_i - S\\,y_j\\,\\Delta t)\\big)\n$$\n\n**带线性插值的半拉格朗日场：**\n数值解 $\\phi^{\\mathrm{SL}}$ 是通过在出发坐标 $(x_d, y_d)$ 处对已知场 $\\phi^n$ 的值进行插值计算得出的。由于 $\\phi^n$ 仅是 $x$ 的函数，且 $y_d = y_j$，这简化为对每个网格行 $j$，在坐标 $x_d$ 处对函数 $f(x) = \\sin(2\\pi m x)$进行一维插值。\n\n对单个点 $(x_i, y_j)$ 的插值过程如下：\n1.  计算出发点的 $x$ 坐标：$x_d = x_i - S y_j \\Delta t$。\n2.  通过将 $x_d$ 映射到域 $[0, L_x)$ 来应用周期性边界条件：$x'_d = x_d \\pmod{L_x}$。\n3.  将坐标归一化为网格间距单位：$\\xi = x'_d / \\Delta x$。\n4.  确定边界网格索引和插值权重。下索引是 $k_1 = \\lfloor \\xi \\rfloor$。考虑到周期性，上索引是 $k_2 = (k_1 + 1) \\pmod{N_x}$。小数部分是权重 $\\alpha = \\xi - k_1$。\n5.  执行线性插值：\n    $$\n    \\phi^{\\mathrm{SL}}(x_i, y_j) = (1-\\alpha)\\phi^n(x_{k_1}) + \\alpha\\phi^n(x_{k_2})\n    $$\n此过程应用于所有网格点 $(x_i, y_j)$。\n\n**数值误差的量化：**\n线性插值并非完美，会引入数值误差，主要表现为数值扩散（耗散），它会衰减波的振幅。\n-   **振幅比 ($R$)：** 通过数值解和精确解的离散L2范数之比来衡量：\n    $$\n    R = \\frac{\\|\\phi^{\\mathrm{SL}}\\|_2}{\\|\\phi^{\\mathrm{exact}}\\|_2} \\quad \\text{其中} \\quad \\|\\boldsymbol{A}\\|_2 = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} A_{i,j}^2}\n    $$\n    $R  1$ 的值表示存在耗散误差。\n-   **最大出发距离 ($D$)：** 这衡量了一个时间步内以网格单元为单位的最大平流距离。\n    $$\n    D = \\max_{i,j} \\frac{|x_i - x_d|}{\\Delta x} = \\max_{i,j} \\frac{|x_i - (x_i - S y_j \\Delta t)|}{\\Delta x} = \\frac{S \\Delta t}{\\Delta x} \\max_j(y_j)\n    $$\n    代入 $\\Delta t=C\\Delta x/S$ 和 $\\max_j(y_j) = (N_y-1)\\Delta y = (N_y-1)/N_y$，我们得到 $D = C (N_y-1)/N_y$。\n\n对每个CFL数 $C \\in \\{0.8, 1.0, 3.5, 16.0\\}$ 执行该算法，并计算和报告所得的 $(R, D)$ 对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the semi-Lagrangian advection for a sinusoidal scalar field in a\n    2D shear flow, and evaluates numerical diffusion and departure distance.\n    \"\"\"\n    # Define the test cases and parameters from the problem statement.\n    test_cases = [0.8, 1.0, 3.5, 16.0] # Nominal CFL numbers\n    \n    # Physical and numerical parameters\n    Lx = 1.0        # Domain length in x\n    Ly = 1.0        # Domain length in y\n    S = 1.0         # Shear rate\n    Nx = 128        # Number of grid points in x\n    Ny = 16         # Number of grid points in y\n    m = 5           # Wavenumber of initial condition\n\n    # Grid setup\n    dx = Lx / Nx\n    dy = Ly / Ny\n    x = np.arange(Nx) * dx\n    y = np.arange(Ny) * dy\n    xx, yy = np.meshgrid(x, y, indexing='ij') # 'ij' indexing gives shapes compatible for broadcasting\n\n    # Initial condition at time t^n\n    # The field is independent of y, so we only need the 1D profile for interpolation.\n    phi_n_1d = np.sin(2 * np.pi * m * x)\n\n    results = []\n    for C in test_cases:\n        # Calculate time step based on the nominal CFL number\n        dt = C * dx / S\n\n        # 1. Compute exact departure points (xd, yd) for all grid points (xx, yy)\n        # For shear flow u=(S*y, 0), the mapping is (x - S*y*dt, y)\n        xd = xx - S * yy * dt\n        # yd is implicitly yy, which is not needed as the field is y-independent.\n\n        # 2. Compute the exact advected field at t^{n+1}\n        # This is simply the initial condition evaluated at the departure points.\n        phi_exact = np.sin(2 * np.pi * m * xd)\n\n        # 3. Compute the Semi-Lagrangian field at t^{n+1} via interpolation\n        \n        # Map departure x-coordinates to the periodic domain [0, Lx)\n        xd_periodic = xd % Lx\n        \n        # Convert to grid-index units\n        xi = xd_periodic / dx\n        \n        # Find the bounding integer grid indices for linear interpolation\n        k1 = np.floor(xi).astype(int)\n        k2 = (k1 + 1) % Nx  # Handle periodicity at the domain edge\n        \n        # Calculate the interpolation weight (fractional part of the index)\n        alpha = xi - k1\n        \n        # Perform 1D linear interpolation for the entire 2D grid using numpy's\n        # advanced indexing. phi_n_1d is indexed by the 2D arrays k1 and k2.\n        phi_k1_vals = phi_n_1d[k1]\n        phi_k2_vals = phi_n_1d[k2]\n        \n        phi_sl = (1.0 - alpha) * phi_k1_vals + alpha * phi_k2_vals\n\n        # 4. Evaluate the metrics R and D\n\n        # Metric R: Amplitude ratio from discrete L2 norms\n        # np.linalg.norm for a 2D array computes the Frobenius norm, which is the\n        # required discrete L2 norm sqrt(sum of squares).\n        norm_sl = np.linalg.norm(phi_sl)\n        norm_exact = np.linalg.norm(phi_exact)\n        R = norm_sl / norm_exact\n        \n        # Metric D: Maximum grid-cell departure distance in x\n        # |x_i - x_d| = |S*y_j*dt|. We want the maximum over all j, divided by dx.\n        max_departure_physical = np.max(S * yy * dt)\n        D = max_departure_physical / dx\n\n        results.extend([R, D])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本实现后，下一个实践  转向了半拉格朗日方案中的一个关键挑战：在处理急剧梯度时的保单调性。您将使用一个具有不连续边界的“高帽”示踪物，来测试不同阶数插值方案（从最近邻到三次插值）的性能。这项练习旨在揭示高阶格式在提高精度的同时，可能引入非物理振荡（如过冲和下冲）的现象，通过量化这些虚假的下冲幅度，您将对数值模拟中精度与保型性之间的权衡有更深入的认识。",
            "id": "3911345",
            "problem": "要求您设计并实现一个一维半拉格朗日平流测试，以使用方波示踪剂评估单调性，并量化伪负值的振幅与库朗-弗里德里希斯-列维（CFL）数和插值阶数之间的函数关系。您必须使用的基本依据是一维被动示踪剂平流方程和半拉格朗日输运的定义。\n\n场景与基本原理：\n- 考虑一个长度为 $L$ 米的周期性域上的一维被动示踪剂平流方程：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\n其中，$c(x,t)$ 是示踪剂浓度（无量纲），$u$ 是以 $\\mathrm{m/s}$ 为单位的恒定速度，$x$ 是以米为单位的空间坐标，$t$ 是以秒为单位的时间。\n- 半拉格朗日方法基于沿轨迹的物质导数定义，即对于纯平流，示踪剂沿轨迹保持不变：\n$$\n\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0.\n$$\n- 基于此基础，通过在出发点处评估前一时刻的示踪剂，推导如何在网格点 $x_i$ 处将 $c$ 从时间层 $t^n$推进到时间层 $t^{n+1} = t^n + \\Delta t$。您的推导必须从上述方程和核心定义出发，不得使用或假设任何快捷公式。\n\n数值设置：\n- 使用一个包含 $N$ 个点的均匀周期性网格，域长 $L = 1$（米），空间步长 $\\Delta x = L/N$（米），速度 $u = 1$（米/秒），以及一个由库朗-弗里德里希斯-列维数决定的单一时间步长 $\\Delta t$（秒）：\n$$\n\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}.\n$$\n- 初始化一个方波示踪剂 $c(x,0)$，其在区间 $[x_0, x_0+w)$ 上的振幅为 $1$，在其他地方为 $0$。其中 $x_0 = 0.33 L$（米），$w = 0.20 L$（米）。该示踪剂是无量纲的，并且初始值严格在 $[0,1]$ 范围内。\n\n插值与单调性评估：\n- 为评估出发点处的前一时刻示踪剂，实现三种插值阶数：\n  1. 阶数 $p=0$：最近邻插值。\n  2. 阶数 $p=1$：线性插值。\n  3. 阶数 $p=3$：使用四个最近网格值的立方拉格朗日插值。\n- 经过一个半拉格朗日时间步后，计算伪负值的振幅，定义为\n$$\nA_{\\text{under}} = \\max\\left(0, -\\min_i c^{n+1}(x_i)\\right),\n$$\n这衡量了对下界 $0$ 的违反程度。该振幅是无量纲的（与 $c$ 的单位相同）。本问题不涉及角度。\n\n算法要求：\n- 从第一性原理推导并实现半拉格朗日更新：为每个网格点计算出发点，然后使用所选的插值阶数，并遵守周期性边界条件，将前一时刻的示踪剂插值到该点。\n- 确保实现是科学上真实且自洽的。使用足够大的 $N$ 以解析方波和插值效应。\n\n测试套件：\n- 使用 $N = 2048$（整数），$L = 1$（米），$u = 1$（米/秒），以及方波参数 $x_0 = 0.33 L$ 和 $w = 0.20 L$。\n- 对于每个测试用例，通过 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$（秒）从指定的 $\\mathrm{CFL}$ 计算 $\\Delta t$，执行恰好一个半拉格朗日步长，并返回 $A_{\\text{under}}$。\n- 测试套件包含以下 $(p, \\mathrm{CFL})$ 对：\n  1. $(0, 0.75)$,\n  2. $(1, 0.75)$,\n  3. $(3, 0.75)$,\n  4. $(3, 0.25)$,\n  5. $(3, 1.00)$,\n  6. $(3, 2.25)$,\n  7. $(3, 0.00)$,\n  8. $(1, 0.25)$,\n  9. $(0, 0.25)$.\n\n输出规范：\n- 您的程序应生成单行输出，其中包含上述测试用例的九个振幅 $A_{\\text{under}}$，以逗号分隔的列表形式包含在方括号内，顺序与测试套件相同，每个振幅四舍五入到小数点后六位。例如：\n$$\n\\text{[0.000000,0.000000,0.012345,\\dots]}\n$$\n不应打印任何额外文本。",
            "solution": "该问题被验证为有科学依据、适定且客观的。它构成了分析半拉格朗日平流格式性质的标准数值实验。我们将继续进行推导和求解。\n\n### 基于原理的半拉格朗日方法推导\n\n一维被动示踪剂平流方程如下：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0\n$$\n其中 $c(x,t)$ 是示踪剂浓度，$u$ 是恒定速度，$x$ 是空间坐标，$t$ 是时间。左侧的表达式是浓度 $c$ 沿随流体运动的轨迹 $X(t)$ 的物质导数，定义为 $\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x}$。因此，控制方程简化为：\n$$\n\\frac{D c}{D t} = 0\n$$\n该方程表明浓度 $c$ 沿着特征线是恒定的，这些特征线是流体包裹的轨迹。特征线 $X(\\tau)$ 由以下常微分方程描述：\n$$\n\\frac{dX(\\tau)}{d\\tau} = u\n$$\n为了在网格点 $x_i$ 和时间 $t^{n+1} = t^n + \\Delta t$ 处找到浓度 $c^{n+1}(x_i)$，我们从到达点 $(x_i, t^{n+1})$ 沿特征线向后追溯时间，以找到其在先前时间层 $t^n$ 的出发点 $(x_{d,i}, t^n)$。由于 $u$ 是恒定的，从 $t^n$ 到 $t^{n+1}$ 积分轨迹方程是直接的：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dX}{d\\tau} d\\tau = \\int_{t^n}^{t^{n+1}} u d\\tau\n$$\n$$\nX(t^{n+1}) - X(t^n) = u (t^{n+1} - t^n)\n$$\n代入 $X(t^{n+1}) = x_i$ 和出发点 $x_{d,i} = X(t^n)$ 的定义，我们得到：\n$$\nx_i - x_{d,i} = u \\Delta t\n$$\n这给出了出发点的位置：\n$$\nx_{d,i} = x_i - u \\Delta t\n$$\n原理 $\\frac{Dc}{Dt}=0$ 意味着浓度在此路径上是守恒的：\n$$\nc(x_i, t^{n+1}) = c(x_{d,i}, t^n)\n$$\n在数值计算的背景下，$c(x, t^n)$ 仅在离散的网格点 $x_j$ 上已知。出发点 $x_{d,i}$ 通常不会与任何网格点重合。因此，为了找到值 $c(x_{d,i}, t^n)$，我们必须对时间 $t^n$ 的网格数据进行插值。将插值算子表示为 $\\mathcal{I}$，半拉格朗日更新规则为：\n$$\nc_i^{n+1} = \\mathcal{I}[c^n](x_{d,i}) = \\mathcal{I}[c^n](x_i - u \\Delta t)\n$$\n\n### 数值实现\n\n长度为 $L=1$ 的域被离散化为 $N$ 个网格单元，网格间距为 $\\Delta x = L/N$。网格点为 $x_i = i \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。速度为 $u=1$。我们可以用库朗-弗里德里希斯-列维（CFL）数来表示时间步长：$\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$。将这些代入出发点方程：\n$$\nx_{d,i} = x_i - u \\left(\\frac{\\mathrm{CFL} \\cdot \\Delta x}{u}\\right) = i\\Delta x - \\mathrm{CFL} \\cdot \\Delta x = (i - \\mathrm{CFL})\\Delta x\n$$\n这表明，以网格单位衡量的出发点位于无量纲坐标 $\\alpha_i = i - \\mathrm{CFL}$ 处。由于域是周期性的，大小为 $N$ 个网格单元，我们使用此坐标对 $N$ 取模：$\\alpha_{\\text{p},i} = \\alpha_i \\pmod N$。\n\n令 $j = \\lfloor \\alpha_{\\text{p},i} \\rfloor$ 为出发点前最后一个网格点的索引，令 $s = \\alpha_{\\text{p},i} - j$ 为进入区间 $[x_j, x_{j+1})$ 的小数部分距离，其中 $s \\in [0, 1)$。值 $c_i^{n+1}$ 是通过使用索引 $j$ 周围的点模板对值 $c_k^n$ 进行插值获得的。\n\n### 插值格式与单调性\n\n初始条件是一个值在 $[0, 1]$ 范围内的方波函数。如果一个数值格式不引入新的极值，则它是单调的。对于本问题，单调格式将确保 $c_i^{n+1} \\in [0, 1]$，因此负值振幅 $A_{\\text{under}} = \\max(0, -\\min_i c_i^{n+1})$ 将为零。\n\n1.  **阶数 $p=0$（最近邻）**：该值取自最近的网格点。$c_i^{n+1} = c_{j+\\text{round}(s)}^n$。由于这仅从初始数据中选择现有值，因此它是单调的。我们期望 $A_{\\text{under}}=0$。\n\n2.  **阶数 $p=1$（线性插值）**：该值是两个包围网格点的加权平均值。\n    $$\n    c_i^{n+1} = (1-s)c_j^n + s c_{j+1}^n\n    $$\n    作为两个在 $[0, 1]$ 范围内的值的凸组合，结果也在 $[0, 1]$ 范围内。此格式是单调的，我们期望 $A_{\\text{under}}=0$。\n\n3.  **阶数 $p=3$（立方拉格朗日插值）**：我们使用四个最近的网格点，形成一个模板 $\\{j-1, j, j+1, j+2\\}$ 来构造一个三次多项式。所有索引都必须周期性处理，例如，索引 $j-1$ 变为 $(j-1) \\pmod N$。插值后的值为：\n    $$\n    c_i^{n+1} = c_{j-1}^n \\mathcal{L}_{-1}(s) + c_{j}^n \\mathcal{L}_{0}(s) + c_{j+1}^n \\mathcal{L}_{1}(s) + c_{j+2}^n \\mathcal{L}_{2}(s)\n    $$\n    其中 $\\mathcal{L}_k(s)$ 是在对应于 $\\{-1, 0, 1, 2\\}$ 处模板点的归一化局部坐标 $s \\in [0,1)$ 上求值的拉格朗日基多项式：\n    $$\n    \\begin{align*}\n    \\mathcal{L}_{-1}(s) = -\\frac{s(s-1)(s-2)}{6} \\\\\n    \\mathcal{L}_{0}(s) = \\frac{(s+1)(s-1)(s-2)}{2} \\\\\n    \\mathcal{L}_{1}(s) = -\\frac{(s+1)s(s-2)}{2} \\\\\n    \\mathcal{L}_{2}(s) = \\frac{(s+1)s(s-1)}{6}\n    \\end{align*}\n    $$\n    此格式通常不是单调的。基多项式可以取负值，这意味着插值结果不是一个凸组合。这可能导致在陡峭梯度附近出现伪振荡（下冲和过冲），因此对于非整数CFL数，我们可能期望 $A_{\\text{under}} > 0$。对于整数CFL值，出发点与网格点对齐，$s=0$，插值变为精确选择（$c_i^{n+1} = c_{i-\\mathrm{CFL}}^n$），不会产生负值。\n\n该算法的流程是遍历每个测试用例 $(p, \\mathrm{CFL})$，构造初始状态 $c^0$，使用指定的插值计算新状态 $c^1$，然后计算 $A_{\\text{under}}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D semi-Lagrangian advection test for monotonicity.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    N = 2048\n    L = 1.0\n    u = 1.0\n    x0 = 0.33 * L\n    w = 0.20 * L\n    \n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # ------------------\n    # Initial Condition\n    # ------------------\n    c0 = np.zeros(N, dtype=np.float64)\n    # Define the top-hat tracer profile\n    # Use boolean indexing for clarity and efficiency\n    c0[(x >= x0)  (x  (x0 + w))] = 1.0\n    \n    # ------------------\n    # Test Suite\n    # ------------------\n    test_cases = [\n        (0, 0.75),\n        (1, 0.75),\n        (3, 0.75),\n        (3, 0.25),\n        (3, 1.00),\n        (3, 2.25),\n        (3, 0.00),\n        (1, 0.25),\n        (0, 0.25),\n    ]\n    \n    results = []\n    \n    for p, cfl in test_cases:\n        # For CFL=0, there is no change, so no undershoot\n        if cfl == 0.0:\n            results.append(0.0)\n            continue\n            \n        c1 = np.zeros(N, dtype=np.float64)\n\n        for i in range(N):\n            # Calculate departure point in non-dimensional grid coordinates\n            alpha = float(i) - cfl\n            \n            # Apply periodic boundary conditions. Python's % operator handles\n            # negative numbers in a way that is suitable for this (e.g., -0.75 % N = N-0.75).\n            alpha_periodic = alpha % N\n            \n            j = int(np.floor(alpha_periodic))\n            s = alpha_periodic - j\n\n            # Perform interpolation based on order p\n            if p == 0:  # Nearest-neighbor\n                idx = (j + int(round(s))) % N\n                c1[i] = c0[idx]\n            \n            elif p == 1:  # Linear\n                j0 = j\n                j1 = (j + 1) % N\n                c1[i] = (1.0 - s) * c0[j0] + s * c0[j1]\n            \n            elif p == 3:  # Cubic Lagrange\n                # Stencil points are j-1, j, j+1, j+2\n                j_m1 = (j - 1) % N\n                j_0 = j\n                j_1 = (j + 1) % N\n                j_2 = (j + 2) % N\n                \n                # Get the concentrations at the stencil points\n                c_m1 = c0[j_m1]\n                c_0 = c0[j_0]\n                c_1 = c0[j_1]\n                c_2 = c0[j_2]\n                \n                # Evaluate the Lagrange basis polynomials at s\n                l_m1 = -s * (s - 1.0) * (s - 2.0) / 6.0\n                l_0  = (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n                l_1  = -(s + 1.0) * s * (s - 2.0) / 2.0\n                l_2  = (s + 1.0) * s * (s - 1.0) / 6.0\n                \n                c1[i] = l_m1 * c_m1 + l_0 * c_0 + l_1 * c_1 + l_2 * c_2\n        \n        # Calculate amplitude of spurious undershoots\n        min_c1 = np.min(c1)\n        a_under = max(0.0, -min_c1)\n        results.append(a_under)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "最后的实践  将带您进入多维模拟中的一个高级主题：算子分裂误差。在处理复杂的多维平流问题时，将问题分解为一系列一维平流（即维度分裂）是一种常用技巧，但这会引入特有的“分裂误差”。您将以等离子体模拟中常见的刚体旋转流为例，通过编程来量化这种误差，并分析其与标量场混合导数之间的关联。这项练习有助于您理解在设计多维模拟方案时，算法结构本身是如何影响计算精度的，这对于开发高保真度的聚变等离子体湍流代码至关重要。",
            "id": "4199723",
            "problem": "考虑一个由速度场 $\\boldsymbol{u}(x,y,t)$ 控制的二维被动标量平流方程，其坐标为 $x$ 和 $y$，可写为以下一阶偏微分方程 (PDE)：\n$$\n\\frac{\\partial f}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla f = 0,\n$$\n其中 $f(x,y,t)$ 是被平流的标量。在半拉格朗日平流格式中，通过沿特征线回溯到时间 $t$ 的出发点 $(x_d,y_d)$，然后对 $f(x_d,y_d,t)$ 进行采样，来计算时间 $t+\\Delta t$ 时到达点 $(x,y)$ 处的标量 $f$。该方法通过追踪特征线而非执行显式通量更新，避免了欧拉格式的 Courant–Friedrichs–Lewy 约束。\n\n本问题分析了维度分裂方法在旋转流中引入的误差，并量化了在与聚变等离子体湍流模拟相关的刚体旋转测试中的虚假交叉导数效应，其中 ExB 旋转是一种常见的模式。您必须从第一性原理出发进行推导，并实现一个程序来计算在光滑测试函数上由分裂方法产生的误差，然后量化与混合二阶导数（交叉导数）结构对齐的误差分量。\n\n基本原理和设置：\n- 速度场是角速度为 $\\Omega$（单位：弧度/秒）的刚体旋转，由下式给出：\n$$\nu(x,y) = -\\Omega\\,y,\\qquad v(x,y) = \\Omega\\,x.\n$$\n- 对于一个时间步长 $\\Delta t$（单位：秒），将时间 $t+\\Delta t$ 的到达位置 $(x,y)$ 映射到时间 $t$ 的出发位置 $(x_d,y_d)$ 的精确特征流是沿时间向后旋转角度 $\\theta=\\Omega\\,\\Delta t$（单位：弧度）。精确的出发点映射为：\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad\ny_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n- 使用 Lie 分裂（先沿 $x$ 方向平流，再沿 $y$ 方向平流）的维度分裂半拉格朗日方法，通过顺序的一维回溯计算出发点映射：\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega\\,y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v(x^{(1)},y^{(1)})\\,\\Delta t = y - \\Omega\\,x^{(1)}\\,\\Delta t.\n$$\n- 初始条件 $f_0(x,y)$ 是一个旋转的椭圆高斯函数，这是一个光滑的测试剖面，它打破了轴对称性以揭示交叉导数的耦合。通过以下方式定义主轴坐标：\n$$\nx' = x\\cos\\alpha + y\\sin\\alpha,\\qquad y' = -x\\sin\\alpha + y\\cos\\alpha,\n$$\n并设\n$$\nf_0(x,y) = \\exp\\!\\left(-\\left[\\frac{x'^2}{\\sigma_1^2} + \\frac{y'^2}{\\sigma_2^2}\\right]\\right),\n$$\n其中 $\\alpha$ 是旋转角（单位：弧度），$\\sigma_1, \\sigma_2$ 是半轴宽度（与 $x$ 和 $y$ 的长度单位相同）。精确的半拉格朗日更新得到 $f^{\\mathrm{exact}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\right)$，而分裂更新得到 $f^{\\mathrm{split}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}}\\right)$。\n\n误差量化：\n- 定义局部误差场\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y).\n$$\n- 定义在到达网格上的初始条件 $f_0$ 的混合二阶导数（交叉导数）为\n$$\nD_{xy}(x,y) = \\frac{\\partial^2 f_0}{\\partial x\\,\\partial y}(x,y),\n$$\n其在网格上通过周期性中心差分进行数值计算。\n- 计算误差的 $L^2$ 范数\n$$\n\\|E\\|_{2} = \\left(\\int_{\\Omega_D} E(x,y)^2\\,\\mathrm{d}x\\,\\mathrm{d}y\\right)^{1/2},\n$$\n和 $L^\\infty$ 范数 $\\|E\\|_{\\infty} = \\max_{(x,y)\\in\\Omega_D} |E(x,y)|$，其中 $\\Omega_D$ 表示计算域。\n- 通过在网格上的离散内积中将 $E$ 正交投影到 $D_{xy}$ 上来量化虚假的交叉导数效应：\n$$\nC_{xy} = \\frac{\\langle E, D_{xy} \\rangle}{\\langle D_{xy}, D_{xy} \\rangle},\n$$\n其中 $\\langle A,B\\rangle = \\int_{\\Omega_D} A(x,y)\\,B(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$ 通过求和乘以单元面积来近似。与交叉导数结构对齐的误差能量的分数为\n$$\nR = \\frac{|C_{xy}|\\,\\|D_{xy}\\|_{2}}{\\|E\\|_{2}},\n$$\n这是一个无量纲量。\n\n域、单位和数值方法：\n- 使用边长为 $L$（单位：米）的方形周期域，即 $x,y\\in[-L/2,L/2)$，用 $N_x\\times N_y$ 个点进行均匀离散化，间距为 $\\Delta x = L/N_x$，$\\Delta y = L/N_y$。\n- 时间单位为秒，$\\Omega$ 单位为弧度/秒，角度如 $\\theta$ 和 $\\alpha$ 单位为弧度。\n- 所有报告的输出均为无量纲浮点数。在此测试中，标量 $f$ 是无单位的。\n- 初始条件和所有 $f_0(x_d,y_d)$ 的求值都必须通过旋转高斯函数的定义进行解析计算，而不是通过网格插值，以便将分裂误差与插值误差分离开来。\n\n程序行为要求：\n- 实现上述映射和度量。\n- 使用周期性中心差分计算 $D_{xy}$。\n- 对每个测试用例，按顺序计算并返回四个浮点数：$\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$。\n\n测试套件：\n- 设 $N_x=N_y=128$，$L=1$，且 $\\Omega=2\\pi$。\n- 三个测试用例，涵盖不同方面：\n    1. 理想情况：$\\Delta t = 1/64$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    2. 更大的时间步长：$\\Delta t = 1/8$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    3. 对称性边界情况（预期交叉导数投影接近于零）：$\\Delta t = 1/8$，$\\alpha = 0$，$\\sigma_1 = 0.2$，$\\sigma_2 = 0.2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots]$），列表中的条目依次是测试用例1的4个浮点数、测试用例2的4个浮点数、以及测试用例3的4个浮点数；因此，单个列表中总共有12个浮点数。",
            "solution": "我们从被动标量平流 PDE $\\partial_t f + \\boldsymbol{u}\\cdot\\nabla f = 0$ 开始，该方程意味着 $f$ 沿特征线为常数。特征曲线 $(x(t),y(t))$ 满足以下常微分方程 (ODEs)：\n$$\n\\frac{dx}{dt} = u(x,y) = -\\Omega\\,y, \\qquad \\frac{dy}{dt} = v(x,y) = \\Omega\\,x,\n$$\n其中 $\\Omega$ 是旋转的角频率。这些线性常微分方程的解是一个匀速旋转。在一个时间步长 $\\Delta t$ 内，从时间 $t$ 的点 $(x_0,y_0)$ 到时间 $t+\\Delta t$ 的点 $(x_1,y_1)$ 的前向映射为：\n$$\nx_1 = x_0\\cos\\theta - y_0\\sin\\theta,\\qquad y_1 = x_0\\sin\\theta + y_0\\cos\\theta,\\qquad \\theta = \\Omega\\,\\Delta t.\n$$\n半拉格朗日更新需要进行回溯：给定时间 $t+\\Delta t$ 的点 $(x,y)$，找到时间 $t$ 的点 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$，使得 $f(x,y,t+\\Delta t) = f(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}},t)$。对前向旋转求逆可得到精确的出发点映射：\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad y_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n\n维度分裂通过顺序的一维求解来近似二维平流。对于 Lie 分裂（先沿 $x$ 方向移动，再沿 $y$ 方向移动），我们定义算子 $\\mathcal{A} = u(x,y)\\,\\partial_x$ 和 $\\mathcal{B} = v(x,y)\\,\\partial_y$。一个步长内先应用时间为 $\\Delta t$ 的 $x$ 方向平流，然后应用时间为 $\\Delta t$ 的 $y$ 方向平流。相应的半拉格朗日回溯使用：\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v\\big(x^{(1)},y^{(1)}\\big)\\,\\Delta t = y - \\Omega x^{(1)}\\,\\Delta t.\n$$\n对于算子可交换的可分离平流，该映射是精确的，但对于旋转，算子不可交换。Lie 分裂的局部误差可以使用 Baker-Campbell-Hausdorff (BCH) 展开进行分析：对于不可交换的算子 $\\mathcal{A}$ 和 $\\mathcal{B}$，一个步长会引入一个与对易子 $[\\mathcal{A},\\mathcal{B}]$ 成正比的 $O(\\Delta t^2)$ 误差。对于我们的旋转场，其中 $\\mathcal{A} = -\\Omega y\\,\\partial_x$ 和 $\\mathcal{B} = \\Omega x\\,\\partial_y$，将对易子应用于光滑函数 $f$ 可得：\n$$\n[\\mathcal{A},\\mathcal{B}] f = \\mathcal{A}(\\mathcal{B}f) - \\mathcal{B}(\\mathcal{A}f) = \\Omega^2\\left(x\\,\\partial_x f - y\\,\\partial_y f\\right).\n$$\n等价地，对精确和分裂的出发点映射针对小 $\\Delta t$ 进行泰勒展开，可以得到：\n$$\nx_d^{\\mathrm{exact}} = x + \\Omega y\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3),\\qquad\ny_d^{\\mathrm{exact}} = y - \\Omega x\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3),\n$$\n而\n$$\nx_d^{\\mathrm{split}} = x + \\Omega y\\,\\Delta t,\\qquad\ny_d^{\\mathrm{split}} = y - \\Omega x\\,\\Delta t - \\Omega^2 y\\,\\Delta t^2.\n$$\n两式相减得到：\n$$\n\\delta x_d = x_d^{\\mathrm{split}} - x_d^{\\mathrm{exact}} = \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3), \\qquad\n\\delta y_d = y_d^{\\mathrm{split}} - y_d^{\\mathrm{exact}} = -\\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3).\n$$\n于是，标量的领头阶误差为：\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y) \\approx \\partial_x f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta x_d + \\partial_y f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta y_d,\n$$\n该式在 $O(\\Delta t^2)$ 阶上与对易子的结果一致，\n$$\nE(x,y) \\approx \\tfrac{1}{2}\\Omega^2\\,\\Delta t^2\\left(x\\,\\partial_x f_0 - y\\,\\partial_y f_0\\right),\n$$\n在适当接近的点上求值。这表明主要误差是方向导数的不平衡，而不是纯粹的混合导数。然而，对于一个旋转的各向异性高斯函数 $f_0$，其空间结构会将这些不平衡耦合到包含混合导数 $\\partial^2 f_0/(\\partial x\\,\\partial y)$ 的基分量中，从而产生一个可观的到 $D_{xy}$ 上的投影。\n\n为量化这种虚假的交叉导数效应，我们计算：\n1. 误差场 $E(x,y)$，即分裂半拉格朗日更新与精确半拉格朗日更新之差，其中更新是通过在各自的出发点上解析地计算 $f_0$ 来执行的。这将分裂误差与插值误差分离开来。\n2. $E$ 的 $L^2$ 和 $L^\\infty$ 范数，即 $\\|E\\|_2$ 和 $\\|E\\|_\\infty$。\n3. 网格上 $D_{xy}(x,y)$ 的周期性中心差分近似。\n4. 投影系数 $C_{xy} = \\langle E,D_{xy}\\rangle/\\langle D_{xy},D_{xy}\\rangle$ 和分数 $R = |C_{xy}|\\,\\|D_{xy}\\|_2/\\|E\\|_2$。\n\n算法设计：\n- 在 $x,y\\in[-L/2,L/2)$ 上构建一个 $N_x=N_y=128$ 的均匀网格，其中 $L=1$，间距为 $\\Delta x = \\Delta y = L/N_x$。\n- 定义旋转坐标 $x' = x\\cos\\alpha + y\\sin\\alpha$，$y' = -x\\sin\\alpha + y\\cos\\alpha$，以及 $f_0(x,y) = \\exp\\!\\left(-\\left[x'^2/\\sigma_1^2 + y'^2/\\sigma_2^2\\right]\\right)$。\n- 对于每个角速度为 $\\Omega=2\\pi$ 和给定 $\\Delta t$ 的测试用例，计算 $\\theta=\\Omega\\Delta t$（单位：弧度）。\n- 通过上述公式计算精确和分裂的出发点映射，以获得 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ 和 $(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}})$。\n- 在这些出发点上解析地计算 $f_0$，以在到达网格上获得 $f^{\\mathrm{exact}}$ 和 $f^{\\mathrm{split}}$；计算 $E=f^{\\mathrm{split}}-f^{\\mathrm{exact}}$。\n- 通过周期性中心差分计算 $D_{xy}$：\n$$\nD_{xy}(i,j) \\approx \\frac{f_0(i+1,j+1)-f_0(i+1,j-1)-f_0(i-1,j+1)+f_0(i-1,j-1)}{4\\,\\Delta x\\,\\Delta y}.\n$$\n- 对每个测试用例，使用单元面积 $\\Delta x\\,\\Delta y$ 计算离散内积，以获得 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$。\n\n测试套件覆盖范围：\n- 一个小 $\\Delta t$ 的情况（$\\Delta t=1/64$）展示了预期的 $\\|E\\|_2$ 的 $O(\\Delta t^2)$ 标度律和通常较小的 $R$。\n- 一个较大的 $\\Delta t$ 的情况（$\\Delta t=1/8$）放大了分裂误差和交叉导数投影，增加了 $\\|E\\|_\\infty$ 和 $R$。\n- 一个对称性边界情况，其中 $\\alpha=0$ 且 $\\sigma_1=\\sigma_2$，使初始条件具有旋转对称性；尽管 $D_{xy}$ 不恒等于零，但由于对称性，预计投影系数 $C_{xy}$ 和分数 $R$ 会相对较小。\n\n最终程序遵循这些步骤，并对每个测试用例按顺序报告四个浮点数 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$ ，并按要求汇总到一个用方括号括起来的逗号分隔列表中。所有角度都以弧度处理，$\\Omega$ 以弧度/秒为单位，$\\Delta t$ 以秒为单位，输出为无量纲浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotated_gaussian(x, y, sigma1, sigma2, alpha):\n    # Compute rotated coordinates\n    xp = x * np.cos(alpha) + y * np.sin(alpha)\n    yp = -x * np.sin(alpha) + y * np.cos(alpha)\n    return np.exp(-((xp / sigma1) ** 2 + (yp / sigma2) ** 2))\n\ndef exact_departure(x, y, theta):\n    # Backward characteristic for solid-body rotation: inverse of forward rotation\n    xd = x * np.cos(theta) + y * np.sin(theta)\n    yd = -x * np.sin(theta) + y * np.cos(theta)\n    return xd, yd\n\ndef split_departure_lie(x, y, omega, dt):\n    # Lie splitting: first x-advection then y-advection\n    x1 = x + omega * y * dt\n    y1 = y\n    yd = y1 - omega * x1 * dt\n    xd = x1\n    return xd, yd\n\ndef mixed_derivative_periodic(f, dx, dy):\n    # Central mixed derivative with periodic boundary conditions:\n    # Dxy ≈ (f(i+1,j+1) - f(i+1,j-1) - f(i-1,j+1) + f(i-1,j-1)) / (4 dx dy)\n    f_ip_jp = np.roll(np.roll(f, -1, axis=0), -1, axis=1)\n    f_ip_jm = np.roll(np.roll(f, -1, axis=0),  1, axis=1)\n    f_im_jp = np.roll(np.roll(f,  1, axis=0), -1, axis=1)\n    f_im_jm = np.roll(np.roll(f,  1, axis=0),  1, axis=1)\n    dxy = (f_ip_jp - f_ip_jm - f_im_jp + f_im_jm) / (4.0 * dx * dy)\n    return dxy\n\ndef inner_product(a, b, cell_area):\n    return np.sum(a * b) * cell_area\n\ndef l2_norm(a, cell_area):\n    return np.sqrt(np.sum(a * a) * cell_area)\n\ndef linf_norm(a):\n    return float(np.max(np.abs(a)))\n\ndef run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2):\n    # Grid\n    x = (np.arange(nx) - nx/2) * (L / nx)\n    y = (np.arange(ny) - ny/2) * (L / ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    dx = L / nx\n    dy = L / ny\n    cell_area = dx * dy\n\n    # Initial condition\n    f0 = rotated_gaussian(X, Y, sigma1, sigma2, alpha)\n\n    # Exact and split departures\n    theta = omega * dt\n    xd_exact, yd_exact = exact_departure(X, Y, theta)\n    xd_split, yd_split = split_departure_lie(X, Y, omega, dt)\n\n    # Evaluate f0 analytically at departure points\n    f_exact = rotated_gaussian(xd_exact, yd_exact, sigma1, sigma2, alpha)\n    f_split = rotated_gaussian(xd_split, yd_split, sigma1, sigma2, alpha)\n\n    # Error field\n    E = f_split - f_exact\n\n    # Mixed derivative of initial field at arrival grid\n    Dxy = mixed_derivative_periodic(f0, dx, dy)\n\n    # Norms and projections\n    E_l2 = l2_norm(E, cell_area)\n    E_linf = linf_norm(E)\n\n    denom = inner_product(Dxy, Dxy, cell_area)\n    if denom > 1e-15:\n        Cxy = inner_product(E, Dxy, cell_area) / denom\n        Dxy_l2 = l2_norm(Dxy, cell_area)\n        R = (abs(Cxy) * Dxy_l2 / E_l2) if E_l2 > 1e-15 else 0.0\n    else:\n        Cxy = 0.0\n        R = 0.0\n\n    return float(E_l2), float(E_linf), float(Cxy), float(R)\n\ndef solve():\n    # Define constants for all test cases\n    nx = 128\n    ny = 128\n    L = 1.0\n    omega = 2.0 * np.pi  # radians per second\n\n    # Test suite: (dt, alpha, sigma1, sigma2)\n    test_cases = [\n        (1.0/64.0, np.pi/6.0, 0.15, 0.25),  # Happy path\n        (1.0/8.0,  np.pi/6.0, 0.15, 0.25),  # Larger time step\n        (1.0/8.0,  0.0,       0.20, 0.20),  # Symmetry edge case\n    ]\n\n    results = []\n    for dt, alpha, sigma1, sigma2 in test_cases:\n        E_l2, E_linf, Cxy, R = run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2)\n        results.extend([E_l2, E_linf, Cxy, R])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}