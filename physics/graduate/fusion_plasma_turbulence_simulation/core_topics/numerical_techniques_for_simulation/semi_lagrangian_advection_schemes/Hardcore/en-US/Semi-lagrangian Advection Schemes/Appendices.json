{
    "hands_on_practices": [
        {
            "introduction": "A fundamental challenge for any advection scheme is to transport sharp gradients without creating non-physical oscillations. In this exercise , you will investigate the crucial property of monotonicity by implementing a semi-Lagrangian scheme with various interpolation orders. By advecting a discontinuous \"top-hat\" profile, you will directly quantify the spurious undershoots generated by higher-order methods, providing a concrete understanding of the trade-off between formal accuracy and physical realism.",
            "id": "3911345",
            "problem": "You are asked to design and implement a one-dimensional semi-Lagrangian advection test to assess monotonicity using a top-hat tracer, and to quantify the amplitude of spurious undershoots as a function of the Courant–Friedrichs–Lewy (CFL) number and interpolation order. The fundamental base you must use is the one-dimensional passive tracer advection equation and the definition of semi-Lagrangian transport.\n\nScenario and fundamentals:\n- Consider the one-dimensional passive tracer advection equation on a periodic domain of length $L$ in meters:\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\nwhere $c(x,t)$ is the tracer concentration (dimensionless), $u$ is the constant velocity in $\\mathrm{m/s}$, $x$ is the spatial coordinate in meters, and $t$ is time in seconds.\n- The semi-Lagrangian approach is based on the material derivative definition along trajectories, namely that the tracer is constant along trajectories for pure advection:\n$$\n\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0.\n$$\n- From this foundation, derive how to advance $c$ from time level $t^n$ to time level $t^{n+1} = t^n + \\Delta t$ at grid points $x_i$ by evaluating the previous-time tracer at the departure points. Your derivation must start from the above equations and core definitions without using or assuming any shortcut formulas.\n\nNumerical setup:\n- Use a uniform periodic grid with $N$ points, domain length $L = 1$ (meters), spatial step $\\Delta x = L/N$ (meters), velocity $u = 1$ (meters per second), and a single time step $\\Delta t$ (seconds) determined by the Courant–Friedrichs–Lewy number:\n$$\n\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}.\n$$\n- Initialize a top-hat tracer $c(x,0)$ with amplitude $1$ on an interval $[x_0, x_0+w)$ and $0$ elsewhere, with $x_0 = 0.33 L$ (meters) and $w = 0.20 L$ (meters). The tracer is dimensionless and strictly within $[0,1]$ initially.\n\nInterpolation and monotonicity assessment:\n- Implement three interpolation orders for evaluating the previous-time tracer at departure points:\n  1. Order $p=0$: nearest-neighbor interpolation.\n  2. Order $p=1$: linear interpolation.\n  3. Order $p=3$: cubic Lagrange interpolation using the four nearest grid values.\n- After one semi-Lagrangian time step, compute the amplitude of spurious undershoots, defined as\n$$\nA_{\\text{under}} = \\max\\left(0, -\\min_i c^{n+1}(x_i)\\right),\n$$\nwhich measures violations of the lower bound $0$. The amplitude is dimensionless (same unit as $c$). No angles are involved in this problem.\n\nAlgorithmic requirements:\n- Derive and implement the semi-Lagrangian update from first principles: compute the departure point for each grid point, then interpolate the previous-time tracer to that point using the chosen interpolation order, respecting periodic boundary conditions.\n- Ensure that the implementation is scientifically realistic and self-consistent. Use $N$ sufficiently large to resolve the top-hat and interpolation effects.\n\nTest suite:\n- Use $N = 2048$ (integer), $L = 1$ (meters), $u = 1$ (meters per second), and the top-hat parameters $x_0 = 0.33 L$ and $w = 0.20 L$.\n- For each test case, compute $\\Delta t$ from the specified $\\mathrm{CFL}$ via $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$ (seconds), perform exactly one semi-Lagrangian step, and return $A_{\\text{under}}$.\n- The test suite consists of the following ($p$, CFL) pairs:\n  1. (0, 0.75),\n  2. (1, 0.75),\n  3. (3, 0.75),\n  4. (3, 0.25),\n  5. (3, 1.00),\n  6. (3, 2.25),\n  7. (3, 0.00),\n  8. (1, 0.25),\n  9. (0, 0.25).\n\nOutput specification:\n- Your program should produce a single line of output containing the nine amplitudes $A_{\\text{under}}$ for the above test cases as a comma-separated list enclosed in square brackets, in the same order as the test suite, with each amplitude rounded to six decimal places. For example:\n$$\n\\text{[0.000000,0.000000,0.012345,\\dots]}\n$$\nNo additional text should be printed.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It constitutes a standard numerical experiment for analyzing the properties of semi-Lagrangian advection schemes. We shall proceed with the derivation and solution.\n\n### Principle-Based Derivation of the Semi-Lagrangian Method\n\nThe one-dimensional passive tracer advection equation is given as:\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0\n$$\nwhere $c(x,t)$ is the tracer concentration, $u$ is a constant velocity, $x$ is the spatial coordinate, and $t$ is time. The expression on the left is the material derivative of the concentration $c$ along a trajectory $X(t)$ moving with the flow, defined as $\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x}$. The governing equation thus simplifies to:\n$$\n\\frac{D c}{D t} = 0\n$$\nThis equation states that the concentration $c$ is constant along the characteristic curves, which are the trajectories of fluid parcels. The characteristic curve $X(\\tau)$ is described by the ordinary differential equation:\n$$\n\\frac{dX(\\tau)}{d\\tau} = u\n$$\nTo find the concentration $c^{n+1}(x_i)$ at a grid point $x_i$ and time $t^{n+1} = t^n + \\Delta t$, we trace the characteristic curve backward in time from the arrival point $(x_i, t^{n+1})$ to find its departure point $(x_{d,i}, t^n)$ at the previous time level $t^n$. Since $u$ is constant, integrating the trajectory equation from $t^n$ to $t^{n+1}$ is straightforward:\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dX}{d\\tau} d\\tau = \\int_{t^n}^{t^{n+1}} u d\\tau\n$$\n$$\nX(t^{n+1}) - X(t^n) = u (t^{n+1} - t^n)\n$$\nSubstituting $X(t^{n+1}) = x_i$ and the definition of the departure point $x_{d,i} = X(t^n)$, we get:\n$$\nx_i - x_{d,i} = u \\Delta t\n$$\nThis yields the location of the departure point:\n$$\nx_{d,i} = x_i - u \\Delta t\n$$\nThe principle $\\frac{Dc}{Dt}=0$ implies that the concentration is conserved along this path:\n$$\nc(x_i, t^{n+1}) = c(x_{d,i}, t^n)\n$$\nIn a numerical context, $c(x, t^n)$ is only known at discrete grid points $x_j$. The departure point $x_{d,i}$ will, in general, not coincide with any grid point. Therefore, to find the value $c(x_{d,i}, t^n)$, we must interpolate the gridded data from time $t^n$. Denoting the interpolation operator by $\\mathcal{I}$, the semi-Lagrangian update rule is:\n$$\nc_i^{n+1} = \\mathcal{I}[c^n](x_{d,i}) = \\mathcal{I}[c^n](x_i - u \\Delta t)\n$$\n\n### Numerical Implementation\n\nThe domain of length $L=1$ is discretized into $N$ grid cells, with grid spacing $\\Delta x = L/N$. The grid points are $x_i = i \\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$. The velocity is $u=1$. We can express the time step $\\Delta t$ in terms of the Courant–Friedrichs–Lewy (CFL) number: $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$. Substituting these into the departure point equation:\n$$\nx_{d,i} = x_i - u \\left(\\frac{\\mathrm{CFL} \\cdot \\Delta x}{u}\\right) = i\\Delta x - \\mathrm{CFL} \\cdot \\Delta x = (i - \\mathrm{CFL})\\Delta x\n$$\nThis shows that the departure point, measured in grid units, is located at the non-dimensional coordinate $\\alpha_i = i - \\mathrm{CFL}$. Due to the periodic domain of size $N$ grid cells, we use this coordinate modulo $N$: $\\alpha_{\\text{p},i} = \\alpha_i \\pmod N$.\n\nLet $j = \\lfloor \\alpha_{\\text{p},i} \\rfloor$ be the index of the last grid point before the departure point, and let $s = \\alpha_{\\text{p},i} - j$ be the fractional distance into the interval $[x_j, x_{j+1})$, where $s \\in [0, 1)$. The value $c_i^{n+1}$ is obtained by interpolating the values $c_k^n$ using the stencil of points around index $j$.\n\n### Interpolation Schemes and Monotonicity\n\nThe initial condition is a top-hat function with values in $[0, 1]$. A numerical scheme is monotone if it does not introduce new extrema. For this problem, a monotone scheme would ensure that $c_i^{n+1} \\in [0, 1]$, and thus the undershoot amplitude $A_{\\text{under}} = \\max(0, -\\min_i c_i^{n+1})$ would be zero.\n\n1.  **Order $p=0$ (Nearest-Neighbor)**: The value is taken from the nearest grid point. $c_i^{n+1} = c_{j+\\text{round}(s)}^n$. Since this only selects existing values from the initial data, it is monotone. We expect $A_{\\text{under}}=0$.\n\n2.  **Order $p=1$ (Linear Interpolation)**: The value is a weighted average of the two bracketing grid points.\n    $$\n    c_i^{n+1} = (1-s)c_j^n + s c_{j+1}^n\n    $$\n    As a convex combination of two values in $[0, 1]$, the result is also in $[0, 1]$. This scheme is monotone, and we expect $A_{\\text{under}}=0$.\n\n3.  **Order $p=3$ (Cubic Lagrange Interpolation)**: We use the four nearest grid points, forming a stencil $\\{j-1, j, j+1, j+2\\}$ to construct a cubic polynomial. All indices must be handled periodically, e.g., index $j-1$ becomes $(j-1) \\pmod N$. The interpolated value is:\n    $$\n    c_i^{n+1} = c_{j-1}^n \\mathcal{L}_{-1}(s) + c_{j}^n \\mathcal{L}_{0}(s) + c_{j+1}^n \\mathcal{L}_{1}(s) + c_{j+2}^n \\mathcal{L}_{2}(s)\n    $$\n    where $\\mathcal{L}_k(s)$ are the Lagrange basis polynomials evaluated at the normalized local coordinate $s \\in [0,1)$ corresponding to the stencil points at $\\{-1, 0, 1, 2\\}$:\n    $$\n    \\begin{align*}\n    \\mathcal{L}_{-1}(s) = -\\frac{s(s-1)(s-2)}{6} \\\\\n    \\mathcal{L}_{0}(s) = \\frac{(s+1)(s-1)(s-2)}{2} \\\\\n    \\mathcal{L}_{1}(s) = -\\frac{(s+1)s(s-2)}{2} \\\\\n    \\mathcal{L}_{2}(s) = \\frac{(s+1)s(s-1)}{6}\n    \\end{align*}\n    $$\n    This scheme is not generally monotone. The basis polynomials can take on negative values, meaning the interpolated value is not a convex combination. This can lead to spurious oscillations (undershoots and overshoots) near sharp gradients, so we may expect $A_{\\text{under}} > 0$ for non-integer CFL numbers. For integer CFL values, the departure point aligns with a grid point, $s=0$, interpolation becomes exact selection ($c_i^{n+1} = c_{i-\\mathrm{CFL}}^n$), and no undershoots are generated.\n\nThe algorithm proceeds by iterating through each test case $(p, \\mathrm{CFL})$, constructing the initial state $c^0$, computing the new state $c^1$ using the specified interpolation, and then calculating $A_{\\text{under}}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D semi-Lagrangian advection test for monotonicity.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    N = 2048\n    L = 1.0\n    u = 1.0\n    x0 = 0.33 * L\n    w = 0.20 * L\n    \n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # ------------------\n    # Initial Condition\n    # ------------------\n    c0 = np.zeros(N, dtype=np.float64)\n    # Define the top-hat tracer profile\n    # Use boolean indexing for clarity and efficiency\n    c0[(x = x0)  (x  (x0 + w))] = 1.0\n    \n    # ------------------\n    # Test Suite\n    # ------------------\n    test_cases = [\n        (0, 0.75),\n        (1, 0.75),\n        (3, 0.75),\n        (3, 0.25),\n        (3, 1.00),\n        (3, 2.25),\n        (3, 0.00),\n        (1, 0.25),\n        (0, 0.25),\n    ]\n    \n    results = []\n    \n    for p, cfl in test_cases:\n        # For CFL=0, there is no change, so no undershoot\n        if cfl == 0.0:\n            results.append(0.0)\n            continue\n            \n        c1 = np.zeros(N, dtype=np.float64)\n\n        for i in range(N):\n            # Calculate departure point in non-dimensional grid coordinates\n            alpha = float(i) - cfl\n            \n            # Apply periodic boundary conditions. Python's % operator handles\n            # negative numbers in a way that is suitable for this (e.g., -0.75 % N = N-0.75).\n            alpha_periodic = alpha % N\n            \n            j = int(np.floor(alpha_periodic))\n            s = alpha_periodic - j\n\n            # Perform interpolation based on order p\n            if p == 0:  # Nearest-neighbor\n                idx = (j + int(round(s))) % N\n                c1[i] = c0[idx]\n            \n            elif p == 1:  # Linear\n                j0 = j\n                j1 = (j + 1) % N\n                c1[i] = (1.0 - s) * c0[j0] + s * c0[j1]\n            \n            elif p == 3:  # Cubic Lagrange\n                # Stencil points are j-1, j, j+1, j+2\n                j_m1 = (j - 1) % N\n                j_0 = j\n                j_1 = (j + 1) % N\n                j_2 = (j + 2) % N\n                \n                # Get the concentrations at the stencil points\n                c_m1 = c0[j_m1]\n                c_0 = c0[j_0]\n                c_1 = c0[j_1]\n                c_2 = c0[j_2]\n                \n                # Evaluate the Lagrange basis polynomials at s\n                l_m1 = -s * (s - 1.0) * (s - 2.0) / 6.0\n                l_0  = (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n                l_1  = -(s + 1.0) * s * (s - 2.0) / 2.0\n                l_2  = (s + 1.0) * s * (s - 1.0) / 6.0\n                \n                c1[i] = l_m1 * c_m1 + l_0 * c_0 + l_1 * c_1 + l_2 * c_2\n        \n        # Calculate amplitude of spurious undershoots\n        min_c1 = np.min(c1)\n        a_under = max(0.0, -min_c1)\n        results.append(a_under)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While high-order schemes can introduce oscillations, even simpler interpolation methods introduce errors, most commonly as numerical diffusion that damps physical gradients. This hands-on problem  provides a clear-cut scenario to isolate and quantify this dissipative effect in a two-dimensional shear flow. By advecting a smooth sinusoidal profile and comparing against the exact solution, you will measure the amplitude loss due to linear interpolation and explore its dependence on the time step, highlighting the distinction between numerical stability and accuracy.",
            "id": "3911375",
            "problem": "Consider the linear advection of a passive scalar $\\phi(x,y,t)$ in a two-dimensional periodic domain with coordinates $x \\in [0,L_x]$ and $y \\in [0,L_y]$ and constant shear flow $\\boldsymbol{u}(x,y) = (S\\,y, 0)$, where $S$ is a constant shear rate. The scalar obeys the advection equation $\\partial_t \\phi + \\boldsymbol{u}\\cdot\\nabla \\phi = 0$. In a Semi-Lagrangian method, the update at time $t^{n+1} = t^n + \\Delta t$ at an Eulerian grid point $\\boldsymbol{x}_{i,j} = (x_i, y_j)$ is obtained by tracing characteristics backward in time to a departure point $\\boldsymbol{x}_d = (x_d, y_d)$ that satisfies $\\boldsymbol{x}_d = \\boldsymbol{x}_{i,j} - \\int_{t^n}^{t^{n+1}} \\boldsymbol{u}(\\boldsymbol{x}(s),s)\\,\\mathrm{d}s$ and then interpolating $\\phi^n$ at $\\boldsymbol{x}_d$.\n\nStarting from the fundamental kinematic relation $\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t} = \\boldsymbol{u}(\\boldsymbol{x},t)$, and using $\\boldsymbol{u}(x,y) = (S y, 0)$ with $S$ constant in time, derive the exact departure-point mapping for one time step $\\Delta t$. Implement a one-step Semi-Lagrangian update using piecewise-linear interpolation in the $x$-direction with periodic boundary conditions, and quantify interpolation-induced diffusion.\n\nAll quantities are non-dimensional. Use $L_x = 1$, $L_y = 1$, $S = 1$, a uniform grid with $N_x$ points in $x$ and $N_y$ points in $y$, with grid spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. Initialize the scalar field at $t^n$ as $\\phi^n(x,y) = \\sin(2\\pi m x)$ with an integer mode $m$. For a given nominal Courant–Friedrichs–Lewy (CFL) number $C$ defined by $C = \\max_{(x,y)} \\left( |u_x(x,y)| \\Delta t / \\Delta x \\right) = S\\,y_{\\max}\\,\\Delta t/\\Delta x$ with $y_{\\max} = L_y$, set $\\Delta t = C\\,\\Delta x/S$.\n\nFor each specified $C$ value, perform one Semi-Lagrangian time step:\n- Compute the exact departure points $x_d = x_i - S\\,y_j\\,\\Delta t$ and $y_d = y_j$.\n- Compute the exact advected field $\\phi^{\\mathrm{exact}}(x_i,y_j) = \\sin\\!\\big(2\\pi m (x_i - S\\,y_j\\,\\Delta t)\\big)$.\n- Compute the Semi-Lagrangian field $\\phi^{\\mathrm{SL}}(x_i,y_j)$ by linearly interpolating $\\phi^n$ at $x_d$ for each fixed $y_j$ using periodic boundary conditions in $x$.\n- Evaluate the interpolation-induced diffusion by the amplitude ratio $R = \\|\\phi^{\\mathrm{SL}}\\|_2 / \\|\\phi^{\\mathrm{exact}}\\|_2$, where $\\|\\cdot\\|_2$ is the discrete two-dimensional Euclidean norm over the grid.\n- Also compute the maximum grid-cell departure distance $D = \\max_{i,j} \\big(|x_i - x_d|/\\Delta x\\big)$, which measures the largest characteristic displacement in units of grid cells.\n\nTest suite and parameters:\n- Use $N_x = 128$, $N_y = 16$, and $m = 5$.\n- Evaluate four nominal CFL numbers $C \\in \\{0.8, 1.0, 3.5, 16.0\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[R(C{=}0.8),D(C{=}0.8),R(C{=}1.0),D(C{=}1.0),R(C{=}3.5),D(C{=}3.5),R(C{=}16.0),D(C{=}16.0)]$. All outputs are non-dimensional floats. No physical units are required, and angles are in radians by construction of the sinusoidal initial condition. The results must be reproducible without any external input.",
            "solution": "The problem statement is assessed to be **valid**. It is scientifically grounded in the principles of fluid dynamics and numerical analysis, specifically concerning the advection equation and semi-Lagrangian schemes. The problem is well-posed, providing a complete and consistent set of parameters, initial conditions, and numerical procedures. All terms are defined objectively and mathematically, allowing for a unique and verifiable solution.\n\nThe solution proceeds in two parts: first, the analytical derivation of the characteristic-based departure point mapping, and second, the design of the numerical algorithm to compute the semi-Lagrangian update and evaluate the specified metrics.\n\n**1. Derivation of the Departure Point Mapping**\n\nThe semi-Lagrangian method relies on tracing fluid parcel trajectories, or characteristics, backward in time. The trajectory $\\boldsymbol{x}(t)$ of a parcel is governed by the kinematic ordinary differential equation (ODE) system:\n$$\n\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t} = \\boldsymbol{u}(\\boldsymbol{x}, t)\n$$\nGiven the two-dimensional, time-independent shear flow $\\boldsymbol{u}(x,y) = (S\\,y, 0)$, the component-wise ODEs are:\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = S\\,y\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = 0\n$$\nWe seek the departure point $\\boldsymbol{x}_d = (x_d, y_d)$ at time $t^n$ that arrives at the Eulerian grid point $\\boldsymbol{x}_{i,j} = (x_i, y_j)$ at time $t^{n+1}$. This involves integrating the ODE system backward over a single time step $\\Delta t = t^{n+1} - t^n$.\n\nIntegrating the $y$-component equation from $t^{n+1}$ back to $t^n$:\n$$\n\\int_{y(t^{n+1})}^{y(t^n)} \\mathrm{d}y = \\int_{t^{n+1}}^{t^n} 0\\,\\mathrm{d}t \\implies y(t^n) - y(t^{n+1}) = 0\n$$\nSubstituting the arrival and departure coordinates, we have $y_d - y_j = 0$, which gives:\n$$\ny_d = y_j\n$$\nThis result indicates that the characteristics are straight horizontal lines; the $y$-coordinate of a fluid parcel remains constant in this flow.\n\nNow, we integrate the $x$-component equation. The formal solution for $x(t^n)$ is:\n$$\nx(t^n) = x(t^{n+1}) - \\int_{t^n}^{t^{n+1}} u_x(\\boldsymbol{x}(s))\\,\\mathrm{d}s\n$$\nSubstituting $u_x = S\\,y$ and the fact that $y(s) = y_j$ is constant along the characteristic path for a parcel arriving at $y_j$:\n$$\nx_d = x_i - \\int_{t^n}^{t^{n+1}} S\\,y_j\\,\\mathrm{d}s\n$$\nSince $S$ and $y_j$ are constant with respect to the integration variable $s$, we can extract them from the integral:\n$$\nx_d = x_i - S\\,y_j \\int_{t^n}^{t^{n+1}} \\mathrm{d}s = x_i - S\\,y_j (t^{n+1} - t^n)\n$$\nUsing the definition $\\Delta t = t^{n+1} - t^n$, we obtain the departure point's $x$-coordinate:\n$$\nx_d = x_i - S\\,y_j\\,\\Delta t\n$$\nThus, the exact departure-point mapping for a single time step is $(\\,x_d, y_d) = (x_i - S\\,y_j\\,\\Delta t, y_j)$, which confirms the expression provided in the problem statement.\n\n**2. Numerical Algorithm and Analysis**\n\nThe semi-Lagrangian update states that the advected scalar is conserved along characteristics, so $\\phi(\\boldsymbol{x}_{i,j}, t^{n+1}) = \\phi(\\boldsymbol{x}_d, t^n)$. We implement a one-step update based on this principle.\n\n**Grid and Parameters:**\n- Domain: $x \\in [0, L_x]$, $y \\in [0, L_y]$ with $L_x = 1$, $L_y = 1$.\n- Grid: $N_x = 128$, $N_y = 16$. The grid coordinates are $x_i = i \\cdot (L_x/N_x)$ for $i=0, \\dots, N_x-1$, and $y_j = j \\cdot (L_y/N_y)$ for $j=0, \\dots, N_y-1$.\n- Shear rate: $S=1$.\n- Initial condition: $\\phi^n(x,y) = \\sin(2\\pi m x)$ with mode number $m=5$. This field is independent of $y$.\n- Time step: $\\Delta t = C\\,\\Delta x/S$ since $y_{\\max}$ for the CFL definition is taken as $L_y = 1$. With $S=1$, this is $\\Delta t = C\\,\\Delta x$.\n\n**Exact Advected Field:**\nThe true solution at time $t^{n+1}$ is the initial condition evaluated at the departure point:\n$$\n\\phi^{\\mathrm{exact}}(x_i, y_j) = \\phi^n(x_d, y_d) = \\sin(2\\pi m x_d) = \\sin\\big(2\\pi m (x_i - S\\,y_j\\,\\Delta t)\\big)\n$$\n\n**Semi-Lagrangian Field with Linear Interpolation:**\nThe numerical solution, $\\phi^{\\mathrm{SL}}$, is computed by interpolating the values of the known field $\\phi^n$ at the departure coordinates $(x_d, y_d)$. Since $\\phi^n$ is a function of $x$ only, and $y_d = y_j$, this reduces to a one-dimensional interpolation of the function $f(x) = \\sin(2\\pi m x)$ at the coordinate $x_d$ for each grid row $j$.\n\nThe interpolation process for a single point $(x_i, y_j)$ is as follows:\n1.  Compute the departure $x$-coordinate: $x_d = x_i - S y_j \\Delta t$.\n2.  Apply periodic boundary conditions by mapping $x_d$ into the domain $[0, L_x)$: $x'_d = x_d \\pmod{L_x}$.\n3.  Normalize the coordinate to grid-spacing units: $\\xi = x'_d / \\Delta x$.\n4.  Identify the bounding grid indices and the interpolation weight. The lower index is $k_1 = \\lfloor \\xi \\rfloor$. The upper index, accounting for periodicity, is $k_2 = (k_1 + 1) \\pmod{N_x}$. The fractional part is the weight $\\alpha = \\xi - k_1$.\n5.  Perform the linear interpolation:\n    $$\n    \\phi^{\\mathrm{SL}}(x_i, y_j) = (1-\\alpha)\\phi^n(x_{k_1}) + \\alpha\\phi^n(x_{k_2})\n    $$\nThis procedure is applied to all grid points $(x_i, y_j)$.\n\n**Quantification of Numerical Error:**\nLinear interpolation is not perfect and introduces numerical errors, primarily in the form of numerical diffusion (dissipation), which damps the amplitude of waves.\n-   **Amplitude Ratio ($R$):** This is measured by the ratio of the discrete L2-norms of the numerical and exact solutions:\n    $$\n    R = \\frac{\\|\\phi^{\\mathrm{SL}}\\|_2}{\\|\\phi^{\\mathrm{exact}}\\|_2} \\quad \\text{where} \\quad \\|\\boldsymbol{A}\\|_2 = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} A_{i,j}^2}\n    $$\n    A value of $R  1$ indicates dissipative error.\n-   **Maximum Departure Distance ($D$):** This measures the largest advection distance in units of grid cells over one time step.\n    $$\n    D = \\max_{i,j} \\frac{|x_i - x_d|}{\\Delta x} = \\max_{i,j} \\frac{|x_i - (x_i - S y_j \\Delta t)|}{\\Delta x} = \\frac{S \\Delta t}{\\Delta x} \\max_j(y_j)\n    $$\n    Substituting $\\Delta t=C\\Delta x/S$ and $\\max_j(y_j) = (N_y-1)\\Delta y = (N_y-1)/N_y$, we get $D = C (N_y-1)/N_y$.\n\nThe algorithm is executed for each CFL number $C \\in \\{0.8, 1.0, 3.5, 16.0\\}$, and the resulting $(R, D)$ pairs are computed and reported.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the semi-Lagrangian advection for a sinusoidal scalar field in a\n    2D shear flow, and evaluates numerical diffusion and departure distance.\n    \"\"\"\n    # Define the test cases and parameters from the problem statement.\n    test_cases = [0.8, 1.0, 3.5, 16.0] # Nominal CFL numbers\n    \n    # Physical and numerical parameters\n    Lx = 1.0        # Domain length in x\n    Ly = 1.0        # Domain length in y\n    S = 1.0         # Shear rate\n    Nx = 128        # Number of grid points in x\n    Ny = 16         # Number of grid points in y\n    m = 5           # Wavenumber of initial condition\n\n    # Grid setup\n    dx = Lx / Nx\n    dy = Ly / Ny\n    x = np.arange(Nx) * dx\n    y = np.arange(Ny) * dy\n    xx, yy = np.meshgrid(x, y) # 'xy' indexing: xx shape (Ny, Nx), yy shape (Ny, Nx)\n\n    # Initial condition at time t^n\n    # The field is independent of y, so we only need the 1D profile for interpolation.\n    phi_n_1d = np.sin(2 * np.pi * m * x)\n\n    results = []\n    for C in test_cases:\n        # Calculate time step based on the nominal CFL number\n        dt = C * dx / S\n\n        # 1. Compute exact departure points (xd, yd) for all grid points (xx, yy)\n        # For shear flow u=(S*y, 0), the mapping is (x - S*y*dt, y)\n        xd = xx - S * yy * dt\n        # yd is implicitly yy, which is not needed as the field is y-independent.\n\n        # 2. Compute the exact advected field at t^{n+1}\n        # This is simply the initial condition evaluated at the departure points.\n        phi_exact = np.sin(2 * np.pi * m * xd)\n\n        # 3. Compute the Semi-Lagrangian field at t^{n+1} via interpolation\n        \n        # Map departure x-coordinates to the periodic domain [0, Lx)\n        xd_periodic = xd % Lx\n        \n        # Convert to grid-index units\n        xi = xd_periodic / dx\n        \n        # Find the bounding integer grid indices for linear interpolation\n        k1 = np.floor(xi).astype(int)\n        k2 = (k1 + 1) % Nx  # Handle periodicity at the domain edge\n        \n        # Calculate the interpolation weight (fractional part of the index)\n        alpha = xi - k1\n        \n        # Perform 1D linear interpolation for the entire 2D grid using numpy's\n        # advanced indexing. phi_n_1d is indexed by the 2D arrays k1 and k2.\n        phi_k1_vals = phi_n_1d[k1]\n        phi_k2_vals = phi_n_1d[k2]\n        \n        phi_sl = (1.0 - alpha) * phi_k1_vals + alpha * phi_k2_vals\n\n        # 4. Evaluate the metrics R and D\n\n        # Metric R: Amplitude ratio from discrete L2 norms\n        # np.linalg.norm for a 2D array computes the Frobenius norm, which is the\n        # required discrete L2 norm sqrt(sum of squares).\n        norm_sl = np.linalg.norm(phi_sl)\n        norm_exact = np.linalg.norm(phi_exact)\n        R = norm_sl / norm_exact\n        \n        # Metric D: Maximum grid-cell departure distance in x\n        # |x_i - x_d| = |S*y_j*dt|. We want the maximum over all j, divided by dx.\n        max_departure_physical = np.max(S * yy * dt)\n        D = max_departure_physical / dx\n\n        results.extend([R, D])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In multi-dimensional simulations, a common simplification is operator splitting, where advection is handled one dimension at a time. This practice  explores the subtle but significant errors introduced by this approximation, particularly in non-separable flows like the rotational $\\mathbf{E} \\times \\mathbf{B}$ drift common in plasmas. You will implement and compare a dimensionally split scheme against the exact analytical solution for solid-body rotation, allowing you to isolate and quantify the splitting error and understand its structure as a consequence of non-commuting advection operators.",
            "id": "4199723",
            "problem": "Consider the two-dimensional passive-scalar advection equation in the plane with coordinates $x$ and $y$, governed by the velocity field $\\boldsymbol{u}(x,y,t)$, written as the first-order Partial Differential Equation (PDE)\n$$\n\\frac{\\partial f}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla f = 0,\n$$\nwhere $f(x,y,t)$ is the advected scalar. In semi-Lagrangian advection schemes, the scalar $f$ at an arrival point $(x,y)$ and time $t+\\Delta t$ is evaluated by backtracing along characteristics to a departure point $(x_d,y_d)$ at time $t$, and then sampling $f(x_d,y_d,t)$. The method avoids Eulerian Courant–Friedrichs–Lewy constraints by tracing characteristics rather than performing explicit flux updates.\n\nThis problem analyzes the error introduced by dimensional splitting for rotating flows and quantifies spurious cross-derivative effects on a solid-body rotation test relevant to Fusion Plasma Turbulence Simulation, where ExB rotation is a frequent motif. You must derive from first principles and implement a program that computes the error associated with splitting on a smooth test function, and then quantify the component of the error aligned with the mixed second derivative (cross-derivative) structure.\n\nFundamental base and setup:\n- The velocity is a solid-body rotation with angular velocity $\\Omega$ (in radians per second), given by\n$$\nu(x,y) = -\\Omega\\,y,\\qquad v(x,y) = \\Omega\\,x.\n$$\n- For a time step $\\Delta t$ (in seconds), the exact characteristic flow that maps an arrival location $(x,y)$ at time $t+\\Delta t$ to the departure location $(x_d,y_d)$ at time $t$ is a rotation by angle $\\theta=\\Omega\\,\\Delta t$ (in radians) backward in time. The exact departure mapping is\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad\ny_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n- A dimensionally split semi-Lagrangian method, using Lie splitting (first advect along $x$ then along $y$), computes the departure mapping by sequential one-dimensional backtraces:\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega\\,y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v(x^{(1)},y^{(1)})\\,\\Delta t = y - \\Omega\\,x^{(1)}\\,\\Delta t.\n$$\n- The initial condition $f_0(x,y)$ is a rotated elliptical Gaussian, a smooth test profile that breaks axisymmetry to expose cross-derivative couplings. Define the principal-axis coordinates by\n$$\nx' = x\\cos\\alpha + y\\sin\\alpha,\\qquad y' = -x\\sin\\alpha + y\\cos\\alpha,\n$$\nand let\n$$\nf_0(x,y) = \\exp\\!\\left(-\\left[\\frac{x'^2}{\\sigma_1^2} + \\frac{y'^2}{\\sigma_2^2}\\right]\\right),\n$$\nwith $\\alpha$ the rotation angle (in radians), and $\\sigma_1,\\sigma_2$ the semi-axes widths (in the same length units as $x$ and $y$). The exact semi-Lagrangian update yields $f^{\\mathrm{exact}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\right)$, while the split update yields $f^{\\mathrm{split}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}}\\right)$.\n\nError quantification:\n- Define the local error field\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y).\n$$\n- Define the mixed second derivative (cross-derivative) of the initial condition $f_0$ at the arrival grid as\n$$\nD_{xy}(x,y) = \\frac{\\partial^2 f_0}{\\partial x\\,\\partial y}(x,y),\n$$\ncomputed numerically by periodic central differences on the grid.\n- Compute the $L^2$ norm of the error\n$$\n\\|E\\|_{2} = \\left(\\int_{\\Omega_D} E(x,y)^2\\,\\mathrm{d}x\\,\\mathrm{d}y\\right)^{1/2},\n$$\nand the $L^\\infty$ norm $\\|E\\|_{\\infty} = \\max_{(x,y)\\in\\Omega_D} |E(x,y)|$, where $\\Omega_D$ denotes the computational domain.\n- Quantify the spurious cross-derivative effect by the orthogonal projection of $E$ onto $D_{xy}$ in the discrete inner product on the grid:\n$$\nC_{xy} = \\frac{\\langle E, D_{xy} \\rangle}{\\langle D_{xy}, D_{xy} \\rangle},\n$$\nwhere $\\langle A,B\\rangle = \\int_{\\Omega_D} A(x,y)\\,B(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$ is approximated by summation times the cell area. The fraction of the error energy aligned with the cross-derivative structure is\n$$\nR = \\frac{|C_{xy}|\\,\\|D_{xy}\\|_{2}}{\\|E\\|_{2}},\n$$\nwhich is dimensionless.\n\nDomain, units, and numerics:\n- Use a square periodic domain of side length $L$ (in meters), i.e., $x,y\\in[-L/2,L/2)$, discretized uniformly with $N_x\\times N_y$ points and spacings $\\Delta x = L/N_x$, $\\Delta y = L/N_y$.\n- Time is in seconds, $\\Omega$ is in radians per second, and angles such as $\\theta$ and $\\alpha$ are in radians.\n- All reported outputs are dimensionless floats. The scalar $f$ is unitless for this test.\n- The initial condition and all evaluations $f_0(x_d,y_d)$ must be computed analytically from the rotated Gaussian definition, not by grid interpolation, to isolate the splitting error from interpolation error.\n\nRequired program behavior:\n- Implement the above mappings and measures.\n- Use periodic central differences to compute $D_{xy}$.\n- For each test case, compute and return the four floats in the order $\\|E\\|_2$, $\\|E\\|_\\infty$, $C_{xy}$, and $R$.\n\nTest suite:\n- Let $N_x=N_y=128$, $L=1$, and $\\Omega=2\\pi$.\n- Three test cases covering different facets:\n    1. Happy path: $\\Delta t = 1/64$, $\\alpha = \\pi/6$, $\\sigma_1 = 0.15$, $\\sigma_2 = 0.25$.\n    2. Larger time step: $\\Delta t = 1/8$, $\\alpha = \\pi/6$, $\\sigma_1 = 0.15$, $\\sigma_2 = 0.25$.\n    3. Symmetry edge case (near-zero cross-derivative projection expected): $\\Delta t = 1/8$, $\\alpha = 0$, $\\sigma_1 = 0.2$, $\\sigma_2 = 0.2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots]$), where the entries are the $4$ floats for test case $1$, followed by the $4$ floats for test case $2$, followed by the $4$ floats for test case $3$; thus $12$ floats total in a single list.",
            "solution": "We begin from the passive scalar advection PDE $\\partial_t f + \\boldsymbol{u}\\cdot\\nabla f = 0$, which implies that $f$ is constant along characteristics. The characteristic curves $(x(t),y(t))$ satisfy the ordinary differential equations (ODEs)\n$$\n\\frac{dx}{dt} = u(x,y) = -\\Omega\\,y, \\qquad \\frac{dy}{dt} = v(x,y) = \\Omega\\,x,\n$$\nwith $\\Omega$ the angular frequency of rotation. The solution to these linear ODEs is a uniform rotation. Over a time step $\\Delta t$, the forward map from $(x_0,y_0)$ at time $t$ to $(x_1,y_1)$ at time $t+\\Delta t$ is\n$$\nx_1 = x_0\\cos\\theta - y_0\\sin\\theta,\\qquad y_1 = x_0\\sin\\theta + y_0\\cos\\theta,\\qquad \\theta = \\Omega\\,\\Delta t.\n$$\nThe semi-Lagrangian update demands the backtrace: given $(x,y)$ at time $t+\\Delta t$, find $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ at time $t$ so that $f(x,y,t+\\Delta t) = f(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}},t)$. Inverting the forward rotation yields the exact departure mapping\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad y_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n\nDimensional splitting approximates the two-dimensional advection by sequential one-dimensional solves. For Lie splitting (first moving along $x$, then along $y$) we define operators $\\mathcal{A} = u(x,y)\\,\\partial_x$ and $\\mathcal{B} = v(x,y)\\,\\partial_y$. One step applies the $x$-advection for $\\Delta t$ then the $y$-advection for $\\Delta t$. The corresponding semi-Lagrangian backtrace uses\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v\\big(x^{(1)},y^{(1)}\\big)\\,\\Delta t = y - \\Omega x^{(1)}\\,\\Delta t.\n$$\nThis mapping is exact for separable advections with commuting operators, but for rotation the operators do not commute. The Lie splitting local error can be analyzed using the Baker-Campbell-Hausdorff (BCH) expansion: for non-commuting operators $\\mathcal{A}$ and $\\mathcal{B}$, one step introduces an error $O(\\Delta t^2)$ proportional to the commutator $[\\mathcal{A},\\mathcal{B}]$. For our rotation field with $\\mathcal{A} = -\\Omega y\\,\\partial_x$ and $\\mathcal{B} = \\Omega x\\,\\partial_y$, applying the commutator to a smooth $f$ gives\n$$\n[\\mathcal{A},\\mathcal{B}] f = \\mathcal{A}(\\mathcal{B}f) - \\mathcal{B}(\\mathcal{A}f) = \\Omega^2\\left(x\\,\\partial_x f - y\\,\\partial_y f\\right).\n$$\nEquivalently, performing a Taylor expansion of the exact and split departure mappings for small $\\Delta t$ reveals\n$$\nx_d^{\\mathrm{exact}} = x + \\Omega y\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3),\\qquad\ny_d^{\\mathrm{exact}} = y - \\Omega x\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3),\n$$\nwhile\n$$\nx_d^{\\mathrm{split}} = x + \\Omega y\\,\\Delta t,\\qquad\ny_d^{\\mathrm{split}} = y - \\Omega x\\,\\Delta t - \\Omega^2 y\\,\\Delta t^2.\n$$\nSubtracting yields\n$$\n\\delta x_d = x_d^{\\mathrm{split}} - x_d^{\\mathrm{exact}} = \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3), \\qquad\n\\delta y_d = y_d^{\\mathrm{split}} - y_d^{\\mathrm{exact}} = -\\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3).\n$$\nThe leading-order error in the scalar is then\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y) \\approx \\partial_x f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta x_d + \\partial_y f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta y_d,\n$$\nwhich, to $O(\\Delta t^2)$, aligns with the commutator result,\n$$\nE(x,y) \\approx \\tfrac{1}{2}\\Omega^2\\,\\Delta t^2\\left(x\\,\\partial_x f_0 - y\\,\\partial_y f_0\\right),\n$$\nevaluated at appropriately close points. This shows the dominant error is a directional derivative imbalance rather than a pure mixed derivative. However, on a rotated anisotropic Gaussian $f_0$, the spatial structure couples these imbalances into basis components that include the mixed derivative $\\partial^2 f_0/(\\partial x\\,\\partial y)$, leading to a measurable projection onto $D_{xy}$.\n\nTo quantify this spurious cross-derivative effect, we compute:\n1. The error field $E(x,y)$ as the difference between split and exact semi-Lagrangian updates, where updates are performed by evaluating the analytic $f_0$ at the respective departure points. This isolates splitting error from interpolation error.\n2. The $L^2$ and $L^\\infty$ norms of $E$, namely $\\|E\\|_2$ and $\\|E\\|_\\infty$.\n3. The periodic central-difference approximation to $D_{xy}(x,y)$ on the grid.\n4. The projection coefficient $C_{xy} = \\langle E,D_{xy}\\rangle/\\langle D_{xy},D_{xy}\\rangle$, and the fraction $R = |C_{xy}|\\,\\|D_{xy}\\|_2/\\|E\\|_2$.\n\nAlgorithmic design:\n- Construct a uniform grid with $N_x=N_y=128$ over $x,y\\in[-L/2,L/2)$, with $L=1$ and spacings $\\Delta x = \\Delta y = L/N_x$.\n- Define the rotated coordinates $x' = x\\cos\\alpha + y\\sin\\alpha$, $y' = -x\\sin\\alpha + y\\cos\\alpha$, and $f_0(x,y) = \\exp\\!\\left(-\\left[x'^2/\\sigma_1^2 + y'^2/\\sigma_2^2\\right]\\right)$.\n- For each test case with angular speed $\\Omega=2\\pi$ and given $\\Delta t$, compute $\\theta=\\Omega\\Delta t$ (in radians).\n- Compute the exact and split departure mappings via the formulas above to obtain $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ and $(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}})$.\n- Evaluate $f_0$ analytically at these departure points to get $f^{\\mathrm{exact}}$ and $f^{\\mathrm{split}}$ on the arrival grid; compute $E=f^{\\mathrm{split}}-f^{\\mathrm{exact}}$.\n- Compute $D_{xy}$ by periodic central differences:\n$$\nD_{xy}(i,j) \\approx \\frac{f_0(i+1,j+1)-f_0(i+1,j-1)-f_0(i-1,j+1)+f_0(i-1,j-1)}{4\\,\\Delta x\\,\\Delta y}.\n$$\n- Compute the discrete inner products with cell area $\\Delta x\\,\\Delta y$ to obtain $\\|E\\|_2$, $\\|E\\|_\\infty$, $C_{xy}$, and $R$ for each test case.\n\nTest suite coverage:\n- A small $\\Delta t$ case ($\\Delta t=1/64$) demonstrates the expected $O(\\Delta t^2)$ scaling of $\\|E\\|_2$ and typically small $R$.\n- A larger $\\Delta t$ case ($\\Delta t=1/8$) amplifies splitting error and cross-derivative projection, increasing $\\|E\\|_\\infty$ and $R$.\n- A symmetry edge case with $\\alpha=0$ and $\\sigma_1=\\sigma_2$ makes the initial condition rotationally symmetric; although $D_{xy}$ is not identically zero, the projection coefficient $C_{xy}$ and fraction $R$ are expected to be comparatively small due to symmetry.\n\nThe final program follows these steps and reports for each test case the four floats $\\|E\\|_2$, $\\|E\\|_\\infty$, $C_{xy}$, and $R$ in order, aggregated into a single bracketed, comma-separated list as required. All angles are handled in radians, $\\Omega$ is in radians per second, $\\Delta t$ is in seconds, and outputs are unitless floats.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotated_gaussian(x, y, sigma1, sigma2, alpha):\n    # Compute rotated coordinates\n    xp = x * np.cos(alpha) + y * np.sin(alpha)\n    yp = -x * np.sin(alpha) + y * np.cos(alpha)\n    return np.exp(-((xp / sigma1) ** 2 + (yp / sigma2) ** 2))\n\ndef exact_departure(x, y, theta):\n    # Backward characteristic for solid-body rotation: inverse of forward rotation\n    xd = x * np.cos(theta) + y * np.sin(theta)\n    yd = -x * np.sin(theta) + y * np.cos(theta)\n    return xd, yd\n\ndef split_departure_lie(x, y, omega, dt):\n    # Lie splitting: first x-advection then y-advection\n    x1 = x + omega * y * dt\n    y1 = y\n    yd = y1 - omega * x1 * dt\n    xd = x1\n    return xd, yd\n\ndef mixed_derivative_periodic(f, dx, dy):\n    # Central mixed derivative with periodic boundary conditions:\n    # Dxy ≈ (f(i+1,j+1) - f(i+1,j-1) - f(i-1,j+1) + f(i-1,j-1)) / (4 dx dy)\n    f_ip_jp = np.roll(np.roll(f, -1, axis=0), -1, axis=1)\n    f_ip_jm = np.roll(np.roll(f, -1, axis=0),  1, axis=1)\n    f_im_jp = np.roll(np.roll(f,  1, axis=0), -1, axis=1)\n    f_im_jm = np.roll(np.roll(f,  1, axis=0),  1, axis=1)\n    dxy = (f_ip_jp - f_ip_jm - f_im_jp + f_im_jm) / (4.0 * dx * dy)\n    return dxy\n\ndef inner_product(a, b, cell_area):\n    return np.sum(a * b) * cell_area\n\ndef l2_norm(a, cell_area):\n    return np.sqrt(np.sum(a * a) * cell_area)\n\ndef linf_norm(a):\n    return float(np.max(np.abs(a)))\n\ndef run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2):\n    # Grid\n    x = (np.arange(nx) - nx/2) * (L / nx)\n    y = (np.arange(ny) - ny/2) * (L / ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    dx = L / nx\n    dy = L / ny\n    cell_area = dx * dy\n\n    # Initial condition\n    f0 = rotated_gaussian(X, Y, sigma1, sigma2, alpha)\n\n    # Exact and split departures\n    theta = omega * dt\n    xd_exact, yd_exact = exact_departure(X, Y, theta)\n    xd_split, yd_split = split_departure_lie(X, Y, omega, dt)\n\n    # Evaluate f0 analytically at departure points\n    f_exact = rotated_gaussian(xd_exact, yd_exact, sigma1, sigma2, alpha)\n    f_split = rotated_gaussian(xd_split, yd_split, sigma1, sigma2, alpha)\n\n    # Error field\n    E = f_split - f_exact\n\n    # Mixed derivative of initial field at arrival grid\n    Dxy = mixed_derivative_periodic(f0, dx, dy)\n\n    # Norms and projections\n    E_l2 = l2_norm(E, cell_area)\n    E_linf = linf_norm(E)\n\n    denom = inner_product(Dxy, Dxy, cell_area)\n    if denom  0:\n        Cxy = inner_product(E, Dxy, cell_area) / denom\n        Dxy_l2 = l2_norm(Dxy, cell_area)\n        R = (abs(Cxy) * Dxy_l2 / E_l2) if E_l2  0 else 0.0\n    else:\n        Cxy = 0.0\n        R = 0.0\n\n    return float(E_l2), float(E_linf), float(Cxy), float(R)\n\ndef solve():\n    # Define constants for all test cases\n    nx = 128\n    ny = 128\n    L = 1.0\n    omega = 2.0 * np.pi  # radians per second\n\n    # Test suite: (dt, alpha, sigma1, sigma2)\n    test_cases = [\n        (1.0/64.0, np.pi/6.0, 0.15, 0.25),  # Happy path\n        (1.0/8.0,  np.pi/6.0, 0.15, 0.25),  # Larger time step\n        (1.0/8.0,  0.0,       0.20, 0.20),  # Symmetry edge case\n    ]\n\n    results = []\n    for dt, alpha, sigma1, sigma2 in test_cases:\n        E_l2, E_linf, Cxy, R = run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2)\n        results.extend([E_l2, E_linf, Cxy, R])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}