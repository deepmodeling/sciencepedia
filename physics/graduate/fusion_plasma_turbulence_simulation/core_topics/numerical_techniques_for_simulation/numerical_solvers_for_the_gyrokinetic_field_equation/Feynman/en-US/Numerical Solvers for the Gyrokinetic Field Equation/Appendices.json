{
    "hands_on_practices": [
        {
            "introduction": "The gyroaveraging operators are the mathematical heart of the gyrokinetic model, linking the scale of particle gyromotion to the scale of macroscopic fields. This first exercise focuses on the critical task of computing these operators, $\\Gamma_0(b)$ and $\\Gamma_1(b)$, with high fidelity, challenging you to contrast a direct numerical integration with a professionally robust algorithm based on special functions. Mastering this step is fundamental to building any reliable gyrokinetic solver. ",
            "id": "4197698",
            "problem": "You are asked to design and implement a complete, runnable program that computes the gyroaveraging operators used in the gyrokinetic field equation. In gyrokinetic (GK) theory for magnetized plasmas, the gyroaveraging operators arise from the average over the gyroangle of the particle’s Larmor motion. For a dimensionless parameter $b \\ge 0$ (proportional to the squared perpendicular wavenumber times the squared Larmor radius), define the two quantities of interest:\n- $\\,\\Gamma_0(b)$, the zeroth-order gyroaveraging operator,\n- $\\,\\Gamma_1(b)$, the first-order gyroaveraging operator.\n\nYour task is to:\n1. Compute $\\,\\Gamma_0(b)$ and $\\,\\Gamma_1(b)$ using numerically stable algorithms that remain accurate for small $b$ (e.g., $b \\ll 1$), moderate $b$ (e.g., $b \\sim 1$), and large $b$ (e.g., $b \\gg 1$).\n2. Independently compute $\\,\\Gamma_0(b)$ and $\\,\\Gamma_1(b)$ via direct numerical integration over the gyroangle. Use the periodic integral representations over one full gyration (gyroangle in radians):\n   - $$\\Gamma_0(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\, d\\theta,$$\n   - $$\\Gamma_1(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\,\\cos\\theta \\, d\\theta.$$\n   The above integrals must be evaluated numerically, with the angle variable expressed in radians.\n3. Compare the results from the stable algorithms to the direct integral computations by reporting the absolute differences $|\\Gamma_0^{\\text{stable}} - \\Gamma_0^{\\text{integral}}|$ and $|\\Gamma_1^{\\text{stable}} - \\Gamma_1^{\\text{integral}}|$.\n\nDesign your method using the following fundamental base:\n- The gyroangle average arises from the symmetry of circular Larmor motion and is represented mathematically by averaging over the angular coordinate $\\theta$.\n- For periodic, smooth integrands over $[0,2\\pi]$, uniform-grid trapezoidal quadrature is spectrally accurate and can be used as a robust numerical integration method.\n- Stable evaluation across the entire range of $b$ requires careful algorithm selection to avoid overflow/underflow and cancellation; small-$b$ series and exponentially scaled special functions are standard approaches.\n\nFor numerical stability:\n- For small $b$, avoid subtractive cancellation by using low-order series expansions tailored to the limiting behavior of the functions.\n- For moderate and large $b$, use exponentially scaled special functions to suppress overflow due to exponentially large intermediate values.\n- In the numerical integrals, choose a resolution that adapts to $b$ so that sharp peaks for large $b$ are sufficiently resolved.\n\nImplement the computations for the following test suite of $b$ values:\n- $b \\in \\{\\,0.0,\\; 10^{-8},\\; 0.1,\\; 1.0,\\; 10.0,\\; 100.0,\\; 10^{4}\\,\\}$.\n\nFor each test case, your program must produce a six-element list of the form\n$$[\\Gamma_0^{\\text{stable}},\\; \\Gamma_0^{\\text{integral}},\\; \\Gamma_1^{\\text{stable}},\\; \\Gamma_1^{\\text{integral}},\\; |\\Gamma_0^{\\text{stable}} - \\Gamma_0^{\\text{integral}}|,\\; |\\Gamma_1^{\\text{stable}} - \\Gamma_1^{\\text{integral}}|].$$\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[case1_results],[case2_results],...]\"), where each element corresponds to one of the test cases in the order given above.\n- There are no physical dimensional units involved because $b$ is dimensionless, and all angles must be in radians.",
            "solution": "The problem requires the computation and comparison of two gyroaveraging operators, $\\Gamma_0(b)$ and $\\Gamma_1(b)$, for a non-negative dimensionless parameter $b$. The computation must be performed using two distinct methods: a numerically stable algorithm leveraging special functions and direct numerical integration based on the provided integral definitions.\n\nThe integral definitions for the operators are:\n$$\n\\Gamma_0(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\, d\\theta\n$$\n$$\n\\Gamma_1(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\,\\cos\\theta \\, d\\theta\n$$\n\nThese integrals can be related to the modified Bessel functions of the first kind. The integral representation for the modified Bessel function $I_n(z)$ is:\n$$\nI_n(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} e^{z \\cos\\tau} \\cos(n\\tau) d\\tau\n$$\nBy factoring out the term $e^{-b}$ from the integrand of $\\Gamma_0(b)$, we can identify its relationship to $I_0(b)$:\n$$\n\\Gamma_0(b) = e^{-b} \\left( \\frac{1}{2\\pi} \\int_{0}^{2\\pi} e^{b \\cos\\theta} d\\theta \\right) = e^{-b} I_0(b)\n$$\nSimilarly, for $\\Gamma_1(b)$, we identify its relationship to $I_1(b)$:\n$$\n\\Gamma_1(b) = e^{-b} \\left( \\frac{1}{2\\pi} \\int_{0}^{2\\pi} e^{b \\cos\\theta} \\cos\\theta d\\theta \\right) = e^{-b} I_1(b)\n$$\nThese identities form the basis for the numerically stable computational method.\n\n**Method 1: Numerically Stable Algorithm**\n\nDirectly computing $I_n(b)$ and multiplying by $e^{-b}$ is numerically unstable for large $b$. The function $I_n(b)$ grows exponentially, roughly as $e^b/\\sqrt{2\\pi b}$, which for large $b$ will lead to overflow. The subsequent multiplication by the exponentially small factor $e^{-b}$ is a classic recipe for numerical inaccuracy.\n\nA robust solution is to use exponentially scaled modified Bessel functions, which are designed to compute the quantity $e^{-|x|}I_n(x)$ directly. Since the parameter $b$ is non-negative ($b \\ge 0$), these functions are perfectly suited for this problem. Specifically:\n- $\\Gamma_0^{\\text{stable}}(b) = e^{-b}I_0(b)$ is computed using the function `scipy.special.i0e(b)`.\n- $\\Gamma_1^{\\text{stable}}(b) = e^{-b}I_1(b)$ is computed using the function `scipy.special.i1e(b)`.\n\nThese library functions are highly optimized and internally use different algorithms (series expansions for small arguments, asymptotic expansions for large arguments) to ensure accuracy and stability across the entire range of $b$.\n\n**Method 2: Direct Numerical Integration**\n\nThe second method involves the direct numerical evaluation of the defining integrals. Both integrands, $f_0(\\theta) = \\exp(-b(1-\\cos\\theta))$ and $f_1(\\theta) = \\exp(-b(1-\\cos\\theta))\\cos\\theta$, are smooth and $2\\pi$-periodic functions of $\\theta$. For such functions, the trapezoidal rule applied over one period with a uniform grid is known to have spectral accuracy.\n\nThe trapezoidal rule for an integral $\\int_{a}^{b} f(x) dx$ with $N$ uniform intervals simplifies for a periodic function over its period $[0, 2\\pi]$. The integral can be approximated as the step size $h = 2\\pi/N$ times the sum of the function values at the grid points $\\theta_j = j \\cdot h$ for $j=0, 1, \\dots, N-1$.\n$$\n\\int_0^{2\\pi} f(\\theta) d\\theta \\approx \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} f(\\theta_j)\n$$\nApplying this to the definitions of $\\Gamma_0(b)$ and $\\Gamma_1(b)$, which include a prefactor of $1/(2\\pi)$, simplifies the calculation to taking the mean of the integrand values over the grid:\n$$\n\\Gamma_0^{\\text{integral}}(b) \\approx \\frac{1}{N} \\sum_{j=0}^{N-1} \\exp\\big(-b(1-\\cos\\theta_j)\\big)\n$$\n$$\n\\Gamma_1^{\\text{integral}}(b) \\approx \\frac{1}{N} \\sum_{j=0}^{N-1} \\exp\\big(-b(1-\\cos\\theta_j)\\big) \\cos\\theta_j\n$$\nA critical aspect of this method is the choice of $N$. For large $b$, the integrand $\\exp\\big(-b(1-\\cos\\theta)\\big)$ becomes sharply peaked near $\\theta=0$ (and $\\theta=2\\pi$). For small $\\theta$, $1-\\cos\\theta \\approx \\theta^2/2$, so the characteristic width of the peak scales as $\\Delta\\theta \\sim \\sqrt{2/b}$. To resolve this peak accurately, the grid spacing $h=2\\pi/N$ must be significantly smaller than $\\Delta\\theta$, which implies $N$ must scale at least as $\\sqrt{b}$.\n\nBased on this analysis, we adopt an adaptive grid resolution strategy:\n$$\nN(b) = \\max\\left( N_{\\min}, \\lceil c\\sqrt{b} \\rceil \\right)\n$$\nWe choose a minimum resolution of $N_{\\min}=256$ to ensure high accuracy for small $b$, and a scaling factor of $c=100$ to over-resolve the peak for large $b$, ensuring the spectral accuracy of the method. The numerical implementation will use `numpy` for efficient array-based computation.\n\n**Comparison**\nThe results from both methods are compared by calculating the absolute difference for each operator:\n$$\n\\Delta_0 = |\\Gamma_0^{\\text{stable}} - \\Gamma_0^{\\text{integral}}|\n$$\n$$\n\\Delta_1 = |\\Gamma_1^{\\text{stable}} - \\Gamma_1^{\\text{integral}}|\n$$\nThis comparison serves to validate the numerical integration scheme against the high-accuracy special function library.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0e, i1e\nimport math\n\ndef compute_gyro_averages(b: float) -> list[float]:\n    \"\"\"\n    Computes gyroaveraging operators Gamma_0(b) and Gamma_1(b) and compares\n    a stable algorithm with direct numerical integration.\n\n    Args:\n        b: A non-negative dimensionless parameter.\n\n    Returns:\n        A six-element list containing:\n        [Gamma_0_stable, Gamma_0_integral, Gamma_1_stable, Gamma_1_integral,\n         abs_diff_Gamma_0, abs_diff_Gamma_1]\n    \"\"\"\n    # Method 1: Stable algorithm using exponentially scaled Bessel functions\n    # These functions compute e^(-b) * I_0(b) and e^(-b) * I_1(b) respectively.\n    gamma_0_stable = i0e(b)\n    gamma_1_stable = i1e(b)\n\n    # Method 2: Direct numerical integration using the trapezoidal rule\n    # For a smooth, periodic function, this is equivalent to averaging function values.\n    \n    # The case b=0 is trivial and handled separately.\n    # The integrand for Gamma_0 is exp(0) = 1, so the average is 1.\n    # The integrand for Gamma_1 is exp(0)*cos(theta), average is 0.\n    if b == 0.0:\n        gamma_0_integral = 1.0\n        gamma_1_integral = 0.0\n    else:\n        # Determine the number of grid points N adaptively.\n        # For large b, the integrand is sharply peaked, requiring more points.\n        # The peak width scales as 1/sqrt(b), so N should scale as sqrt(b).\n        n_min = 256  # Minimum resolution for high accuracy at small b.\n        c_factor = 100 # Safety factor to ensure the peak is well-resolved.\n        num_points = int(max(n_min, math.ceil(c_factor * math.sqrt(b))))\n        \n        # Create a uniform grid for the gyroangle theta from 0 to 2*pi.\n        # endpoint=False ensures the grid is for a periodic interval [0, 2*pi).\n        theta = np.linspace(0, 2 * np.pi, num_points, endpoint=False)\n        cos_theta = np.cos(theta)\n        \n        # Evaluate the numerically stable form of the integrand.\n        # exp(-b * (1 - cos(theta))) varies between exp(-2b) and 1.\n        integrand_common = np.exp(-b * (1 - cos_theta))\n        \n        # For a periodic function, the integral over a period divided by the period\n        # length is just the mean of the function values on a uniform grid.\n        gamma_0_integral = np.mean(integrand_common)\n        gamma_1_integral = np.mean(integrand_common * cos_theta)\n    \n    # Compare the two methods by computing the absolute differences.\n    diff_gamma_0 = abs(gamma_0_stable - gamma_0_integral)\n    diff_gamma_1 = abs(gamma_1_stable - gamma_1_integral)\n    \n    return [\n        gamma_0_stable, gamma_0_integral,\n        gamma_1_stable, gamma_1_integral,\n        diff_gamma_0, diff_gamma_1\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run the computations for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1e-8,\n        0.1,\n        1.0,\n        10.0,\n        100.0,\n        1e4\n    ]\n\n    all_results = []\n    for b_val in test_cases:\n        case_result = compute_gyro_averages(b_val)\n        all_results.append(case_result)\n\n    # Format the final output string to precisely match the required specification:\n    # \"[[case1_results],[case2_results],...]\" with no extra whitespace.\n    output_parts = []\n    for res_list in all_results:\n        # Format each number with high precision and join into a string like \"[v1,v2,...]\"\n        res_str = '[' + ','.join(f'{val:.15g}' for val in res_list) + ']'\n        output_parts.append(res_str)\n    \n    # Join all case strings and enclose in the final outer brackets.\n    final_output_string = '[' + ','.join(output_parts) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "While calculating the gyroaverage operator at a single point is essential, a practical simulation requires applying it efficiently across the entire spatial domain. This practice leverages the Convolution Theorem, guiding you to implement the gyroaverage operator in Fourier space using the Fast Fourier Transform (FFT). This pseudo-spectral technique is a cornerstone of modern, high-performance gyrokinetic codes and demonstrates how to translate a mathematical convolution into an efficient numerical algorithm. ",
            "id": "4197716",
            "problem": "You are given a two-dimensional periodic domain with lengths $L_x$ and $L_y$, discretized into $N_x \\times N_y$ grid points with uniform spacings $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / N_y$. For each particle species $s$ (consider $s \\in \\{i,e\\}$ corresponding to ions and electrons), let $h_s(x,y)$ denote a dimensionless gyrocenter distribution perturbation already integrated over velocity space. The gyroaverage at fixed guiding center is defined by the uniform average over a circle of radius $\\rho_s$ in the plane perpendicular to the magnetic field. The gyroaveraging kernel in real space is given by $G_{\\rho_s}(\\mathbf{r}) = \\delta(|\\mathbf{r}| - \\rho_s)/(2\\pi \\rho_s)$ and its continuous Fourier transform equals $J_0(k_\\perp \\rho_s)$, where $J_0$ is the Bessel function of the first kind of order zero, and $k_\\perp = \\sqrt{k_x^2 + k_y^2}$ is the magnitude of the perpendicular wavevector.\n\nStarting from the definition of the gyroaverage as a ring integral in real space and the Fourier representation of the ring kernel, derive the discrete spectral assembly of the gyroaveraged operator. The required derivation must begin from fundamental principles: the definition of the gyroaverage, the Jacobi–Anger expansion, and the properties of the Fourier transform. Then, implement a numerical solver that:\n\n- Computes the discrete Fourier transform of $h_s(x,y)$ for each species on the given grid using a fast algorithm.\n- Evaluates $J_0(k_\\perp \\rho_s)$ on the same discrete spectral grid, which is equivalent to computing the discrete Fourier transform of the real-space ring kernel and is more efficient than convolving in real space.\n- Assembles the spectral field operator by summing $J_0(k_\\perp \\rho_s)\\,\\hat{h}_s(k_x,k_y)$ over species.\n- Returns a scalar diagnostic equal to the root-mean-square (RMS) amplitude of the inverse discrete Fourier transform of the assembled spectral operator, which is dimensionless.\n\nUse the following physical parameters and definitions to compute the thermal gyroradius for each species:\n- Electron charge magnitude $e = 1.602176634 \\times 10^{-19}$ (Coulomb).\n- Proton mass $m_p = 1.67262192369 \\times 10^{-27}$ (kilogram).\n- Deuteron mass $m_i = 2 m_p$ (kilogram).\n- Electron mass $m_e = 9.1093837015 \\times 10^{-31}$ (kilogram).\n- Uniform background magnetic field magnitude $B_0$ (Tesla).\n- Species temperature $T_s$ is provided in electronvolts (eV) and converted to Joules by multiplying its value by the elementary charge $e$.\n- Thermal speed $v_{\\mathrm{th},s} = \\sqrt{2 T_s / m_s}$ (meter per second) with $T_s$ in Joules.\n- Cyclotron frequency $\\Omega_s = |q_s| B_0 / m_s$ (radian per second), where $q_i = +e$ and $q_e = -e$.\n- Thermal gyroradius $\\rho_s = v_{\\mathrm{th},s} / \\Omega_s$ (meter).\n\nAdopt the discrete Fourier transform on a periodic grid consistent with the standard fast Fourier transform implementation: the forward transform $\\hat{h}_s(k_{x,m},k_{y,n})$ is computed without normalization, and the inverse transform includes the normalization factor $1/(N_x N_y)$. The discrete spectral grid is defined via $k_{x,m} = 2\\pi m/L_x$ and $k_{y,n} = 2\\pi n/L_y$ with integer indices $m$ and $n$ provided by the discrete frequency arrays.\n\nYour program must implement the above using the test suite specified below, compute the assembled spectral field operator, transform it back to real space, and report the RMS amplitude of the resulting real-space field. The RMS diagnostic is defined as\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{j=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\left( s(x_j,y_l) \\right)^2 },\n$$\nwhere $s(x,y)$ is the inverse discrete Fourier transform of $\\sum_s J_0(k_\\perp \\rho_s)\\,\\hat{h}_s(k_x,k_y)$.\n\nAll outputs are dimensionless, so no physical units are required for the final numbers.\n\nTest Suite:\nFor each case, construct $h_s(x,y)$ on the specified grid using $x_j = j \\Delta x$ for $j=0,\\dots,N_x-1$ and $y_l = l \\Delta y$ for $l=0,\\dots,N_y-1$. The input functions are specified as products of sines or cosines of separable modes with integer mode numbers $m_x$ and $m_y$. Use the following cases:\n\n- Case 1 (happy path, mixed species contributions):\n  - $N_x = 32$, $N_y = 24$, $L_x = 0.3$ (meter), $L_y = 0.25$ (meter), $B_0 = 3.0$ (Tesla), $T_i = 2000$ (electronvolts), $T_e = 1000$ (electronvolts).\n  - $h_i(x,y) = \\cos\\left(2\\pi \\frac{x}{L_x}\\right)\\cos\\left(4\\pi \\frac{y}{L_y}\\right)$.\n  - $h_e(x,y) = 0.25\\,\\sin\\left(2\\pi \\frac{x}{L_x}\\right)\\cos\\left(2\\pi \\frac{y}{L_y}\\right)$.\n\n- Case 2 (boundary condition, zero field):\n  - Same $N_x$, $N_y$, $L_x$, $L_y$ as Case 1, with $B_0 = 3.0$, $T_i = 2000$ (electronvolts), $T_e = 1000$ (electronvolts).\n  - $h_i(x,y) = 0$, $h_e(x,y) = 0$ for all grid points.\n\n- Case 3 (edge case, large ion gyroradius and higher wavenumber content):\n  - $N_x = 48$, $N_y = 48$, $L_x = 0.4$ (meter), $L_y = 0.4$ (meter), $B_0 = 0.5$ (Tesla), $T_i = 15000$ (electronvolts), $T_e = 500$ (electronvolts).\n  - $h_i(x,y) = \\cos\\left(6\\pi \\frac{x}{L_x}\\right)\\cos\\left(6\\pi \\frac{y}{L_y}\\right)$.\n  - $h_e(x,y) = 0$.\n\n- Case 4 (electron small gyroradius limit with overlapping modes):\n  - $N_x = 64$, $N_y = 32$, $L_x = 0.2$ (meter), $L_y = 0.3$ (meter), $B_0 = 5.0$ (Tesla), $T_i = 3000$ (electronvolts), $T_e = 100$ (electronvolts).\n  - $h_i(x,y) = 0.7\\,\\cos\\left(2\\pi \\cdot 3 \\frac{x}{L_x}\\right)\\cos\\left(2\\pi \\cdot 2 \\frac{y}{L_y}\\right)$.\n  - $h_e(x,y) = 0.3\\,\\cos\\left(2\\pi \\cdot 3 \\frac{x}{L_x}\\right)\\cos\\left(2\\pi \\cdot 2 \\frac{y}{L_y}\\right)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the RMS results for the four cases as a comma-separated list enclosed in square brackets, with each float rounded to eight decimal places, for example, \"[r1,r2,r3,r4]\". No additional text should be printed.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of gyrokinetic theory in plasma physics, well-posed with sufficient information for a unique solution, and computationally feasible. All parameters and definitions are standard and consistent.\n\nThe core of the problem is to implement the gyroaverage operator, which is fundamental in gyrokinetics for separating the fast gyromotion of charged particles from the slower guiding-center dynamics. The gyroaverage of a quantity $f(\\mathbf{r})$ is its average over a ring of radius $\\rho_s$ (the gyroradius) centered at a given point, which represents the guiding center position. Mathematically, this is a convolution operation.\n\nThe gyroaverage of a field $h_s(\\mathbf{R})$ at a guiding center position $\\mathbf{R}$ is defined as the average of the field over a circular path traced by the particle:\n$$\n\\langle h_s \\rangle (\\mathbf{R}) = \\frac{1}{2\\pi} \\int_0^{2\\pi} d\\alpha \\, h_s(\\mathbf{R} + \\boldsymbol{\\rho}_s(\\alpha))\n$$\nwhere $\\boldsymbol{\\rho}_s(\\alpha)$ is the gyroradius vector of length $\\rho_s$ at angle $\\alpha$. This can be expressed as a convolution in real space:\n$$\n\\langle h_s \\rangle (\\mathbf{r}) = (h_s * G_{\\rho_s})(\\mathbf{r}) = \\int d^2\\mathbf{r}' \\, h_s(\\mathbf{r}') G_{\\rho_s}(\\mathbf{r} - \\mathbf{r}')\n$$\nThe kernel $G_{\\rho_s}$ represents a uniform distribution on a ring of radius $\\rho_s$, given by:\n$$\nG_{\\rho_s}(\\mathbf{r}) = \\frac{\\delta(|\\mathbf{r}| - \\rho_s)}{2\\pi \\rho_s}\n$$\nwhere $\\delta$ is the Dirac delta function.\n\nWhile this convolution could be performed in real space, it is computationally expensive. The Convolution Theorem states that a convolution in real space becomes a simple multiplication in Fourier space. Let $\\hat{f}(\\mathbf{k}) = \\mathcal{F}[f(\\mathbf{r})]$ denote the Fourier transform. Applying the theorem, we have:\n$$\n\\mathcal{F}[\\langle h_s \\rangle](\\mathbf{k}) = \\mathcal{F}[h_s * G_{\\rho_s}](\\mathbf{k}) = \\hat{h}_s(\\mathbf{k}) \\, \\hat{G}_{\\rho_s}(\\mathbf{k})\n$$\nThe problem is thus reduced to finding the Fourier transform of the ring kernel, $\\hat{G}_{\\rho_s}(\\mathbf{k})$. We derive this from its definition:\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\int_{\\mathbb{R}^2} d^2\\mathbf{r} \\, e^{-i \\mathbf{k} \\cdot \\mathbf{r}} G_{\\rho_s}(\\mathbf{r}) = \\int_{\\mathbb{R}^2} d^2\\mathbf{r} \\, e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\frac{\\delta(|\\mathbf{r}| - \\rho_s)}{2\\pi \\rho_s}\n$$\nTo evaluate this integral, we switch to polar coordinates. Let $\\mathbf{r} = (r \\cos\\theta, r \\sin\\theta)$ and $\\mathbf{k} = (k_\\perp \\cos\\phi, k_\\perp \\sin\\phi)$, where $k_\\perp = \\sqrt{k_x^2 + k_y^2}$. The dot product is $\\mathbf{k} \\cdot \\mathbf{r} = k_\\perp r \\cos(\\theta - \\phi)$, and the area element is $d^2\\mathbf{r} = r \\, dr \\, d\\theta$. The integral becomes:\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\int_0^{2\\pi} d\\theta \\int_0^\\infty dr \\, r \\, e^{-i k_\\perp r \\cos(\\theta - \\phi)} \\frac{\\delta(r - \\rho_s)}{2\\pi \\rho_s}\n$$\nThe Dirac delta function collapses the integral over $r$, fixing $r = \\rho_s$.\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\int_0^{2\\pi} d\\theta \\, \\rho_s \\, e^{-i k_\\perp \\rho_s \\cos(\\theta - \\phi)} \\frac{1}{2\\pi \\rho_s} = \\frac{1}{2\\pi} \\int_0^{2\\pi} d\\theta \\, e^{-i k_\\perp \\rho_s \\cos(\\theta - \\phi)}\n$$\nThe result of this integral is independent of the angle $\\phi$, which we can set to zero by rotating the coordinate system. Letting $\\theta' = \\theta$, we get:\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\frac{1}{2\\pi} \\int_0^{2\\pi} d\\theta' \\, e^{-i k_\\perp \\rho_s \\cos(\\theta')}\n$$\nThis is a standard integral representation of the Bessel function of the first kind of order zero, $J_0(z)$. This can be formally shown using the Jacobi-Anger expansion for a plane wave:\n$$\ne^{iz\\cos\\theta} = \\sum_{n=-\\infty}^{+\\infty} i^n J_n(z) e^{in\\theta}\n$$\nIntegrating both sides from $0$ to $2\\pi$ with respect to $\\theta$:\n$$\n\\int_0^{2\\pi} e^{iz\\cos\\theta} d\\theta = \\sum_{n=-\\infty}^{+\\infty} i^n J_n(z) \\int_0^{2\\pi} e^{in\\theta} d\\theta\n$$\nThe integral $\\int_0^{2\\pi} e^{in\\theta} d\\theta$ equals $2\\pi$ if $n=0$ and $0$ for any non-zero integer $n$. Thus, the infinite sum collapses to a single term for $n=0$:\n$$\n\\int_0^{2\\pi} e^{iz\\cos\\theta} d\\theta = i^0 J_0(z) \\cdot (2\\pi) = 2\\pi J_0(z)\n$$\nTherefore, with $z = -k_\\perp \\rho_s$ and using $J_0(-z) = J_0(z)$, we confirm:\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = J_0(k_\\perp \\rho_s)\n$$\nThe gyroaverage operator in Fourier space is simply multiplication by $J_0(k_\\perp \\rho_s)$.\n\nFor the numerical implementation on a discrete grid, we follow these steps:\n1.  **Parameter Calculation**: First, calculate the thermal gyroradius $\\rho_s$ for each species $s \\in \\{i, e\\}$ using the provided physical constants and parameters. The temperature $T_s$ in electronvolts (eV) is converted to Joules (J) by multiplying by the elementary charge $e$. The thermal velocity is $v_{\\mathrm{th},s} = \\sqrt{2 T_s / m_s}$, the cyclotron frequency is $\\Omega_s = |q_s| B_0 / m_s$, and the gyroradius is $\\rho_s = v_{\\mathrm{th},s} / \\Omega_s$.\n\n2.  **Grid and Field Construction**: A uniform 2D grid of size $N_x \\times N_y$ is constructed with points $(x_j, y_l) = (j \\Delta x, l \\Delta y)$, where $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. The input fields $h_s(x,y)$ are evaluated on this grid.\n\n3.  **Forward Fourier Transform**: The 2D-DFT of each field $h_s(x_j, y_l)$ is computed to obtain the spectral coefficients $\\hat{h}_s(k_{x,m}, k_{y,n})$, using a Fast Fourier Transform (FFT) algorithm. As specified, the forward transform is unnormalized.\n\n4.  **Wavenumber Grid**: A corresponding discrete wavenumber grid is constructed. The wavenumbers are given by $k_{x,m} = 2\\pi m/L_x$ for $m \\in \\{-N_x/2, \\dots, N_x/2-1\\}$ and $k_{y,n} = 2\\pi n/L_y$ for $n \\in \\{-N_y/2, \\dots, N_y/2-1\\}$. For each point $(k_{x,m}, k_{y,n})$ in this grid, the perpendicular wavenumber magnitude $k_\\perp = \\sqrt{k_{x,m}^2 + k_{y,n}^2}$ is calculated.\n\n5.  **Spectral Assembly**: The spectral representation of the gyroaveraged field for each species is $\\hat{\\langle h_s \\rangle}(\\mathbf{k}) = J_0(k_\\perp \\rho_s) \\hat{h}_s(\\mathbf{k})$. The total assembled spectral field $\\hat{s}(\\mathbf{k})$ is the sum over all species:\n    $$\n    \\hat{s}(k_{x,m}, k_{y,n}) = \\sum_s J_0(k_\\perp \\rho_s) \\hat{h}_s(k_{x,m}, k_{y,n})\n    $$\n\n6.  **Inverse Fourier Transform**: The resulting spectral field $\\hat{s}(\\mathbf{k})$ is transformed back to real space using the inverse 2D-DFT to obtain the final field $s(x,y)$. The inverse transform must be normalized by a factor of $1/(N_x N_y)$.\n    $$\n    s(x_j, y_l) = \\frac{1}{N_x N_y} \\sum_{m=0}^{N_x-1} \\sum_{n=0}^{N_y-1} \\hat{s}(k_{x,m}, k_{y,n}) e^{i (k_{x,m} x_j + k_{y,n} y_l)}\n    $$\n\n7.  **Diagnostic Calculation**: Finally, the root-mean-square (RMS) amplitude of the real-space field $s(x,y)$ is computed. Since the inputs are real and the kernel $J_0$ is real and even, $s(x,y)$ will be purely real (up to machine precision). The RMS is calculated as:\n    $$\n    \\mathrm{RMS} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{j=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\left( s(x_j,y_l) \\right)^2 }\n    $$\nThis procedure provides a computationally efficient and accurate method to apply the gyroaverage operator, leveraging the power of the Fast Fourier Transform.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Computes the RMS amplitude of a gyro-averaged field in a plasma\n    for a series of test cases.\n    \"\"\"\n\n    # Physical constants\n    e = 1.602176634e-19  # Elementary charge in Coulomb\n    m_p = 1.67262192369e-27  # Proton mass in kg\n    m_i = 2.0 * m_p         # Deuteron mass in kg\n    m_e = 9.1093837015e-31  # Electron mass in kg\n\n    # Test suite from the problem statement\n    test_cases = [\n        {\n            \"description\": \"Case 1: happy path, mixed species contributions\",\n            \"Nx\": 32, \"Ny\": 24, \"Lx\": 0.3, \"Ly\": 0.25,\n            \"B0\": 3.0, \"Ti\": 2000, \"Te\": 1000,\n            \"hi_func\": lambda x, y, Lx, Ly: np.cos(2 * np.pi * x / Lx) * np.cos(4 * np.pi * y / Ly),\n            \"he_func\": lambda x, y, Lx, Ly: 0.25 * np.sin(2 * np.pi * x / Lx) * np.cos(2 * np.pi * y / Ly)\n        },\n        {\n            \"description\": \"Case 2: boundary condition, zero field\",\n            \"Nx\": 32, \"Ny\": 24, \"Lx\": 0.3, \"Ly\": 0.25,\n            \"B0\": 3.0, \"Ti\": 2000, \"Te\": 1000,\n            \"hi_func\": lambda x, y, Lx, Ly: np.zeros_like(x),\n            \"he_func\": lambda x, y, Lx, Ly: np.zeros_like(x)\n        },\n        {\n            \"description\": \"Case 3: edge case, large ion gyroradius and higher wavenumber\",\n            \"Nx\": 48, \"Ny\": 48, \"Lx\": 0.4, \"Ly\": 0.4,\n            \"B0\": 0.5, \"Ti\": 15000, \"Te\": 500,\n            \"hi_func\": lambda x, y, Lx, Ly: np.cos(6 * np.pi * x / Lx) * np.cos(6 * np.pi * y / Ly),\n            \"he_func\": lambda x, y, Lx, Ly: np.zeros_like(x)\n        },\n        {\n            \"description\": \"Case 4: electron small gyroradius limit with overlapping modes\",\n            \"Nx\": 64, \"Ny\": 32, \"Lx\": 0.2, \"Ly\": 0.3,\n            \"B0\": 5.0, \"Ti\": 3000, \"Te\": 100,\n            \"hi_func\": lambda x, y, Lx, Ly: 0.7 * np.cos(2 * np.pi * 3 * x / Lx) * np.cos(2 * np.pi * 2 * y / Ly),\n            \"he_func\": lambda x, y, Lx, Ly: 0.3 * np.cos(2 * np.pi * 3 * x / Lx) * np.cos(2 * np.pi * 2 * y / Ly)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        Lx, Ly = case[\"Lx\"], case[\"Ly\"]\n        B0, Ti_eV, Te_eV = case[\"B0\"], case[\"Ti\"], case[\"Te\"]\n\n        # Calculate gyroradii for ions and electrons\n        species_params = {\n            'i': {'T_eV': Ti_eV, 'm': m_i, 'q': e},\n            'e': {'T_eV': Te_eV, 'm': m_e, 'q': e}\n        }\n        \n        rho_s = {}\n        for s, params in species_params.items():\n            T_J = params['T_eV'] * e  # Temperature in Joules\n            v_th = np.sqrt(2 * T_J / params['m'])\n            Omega = params['q'] * B0 / params['m']\n            rho_s[s] = v_th / Omega\n\n        # Create computational grid\n        dx, dy = Lx / Nx, Ly / Ny\n        x = np.arange(0, Lx, dx)\n        y = np.arange(0, Ly, dy)\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n\n        # Generate input fields on the grid\n        h_i = case[\"hi_func\"](xx, yy, Lx, Ly)\n        h_e = case[\"he_func\"](xx, yy, Lx, Ly)\n\n        # Compute 2D FFT of input fields\n        h_hat_i = np.fft.fft2(h_i)\n        h_hat_e = np.fft.fft2(h_e)\n\n        # Create wavenumber grid\n        kx = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n        ky = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n        kxx, kyy = np.meshgrid(kx, ky, indexing='ij')\n        k_perp = np.sqrt(kxx**2 + kyy**2)\n\n        # Evaluate gyroaveraging kernel J0(k_perp * rho_s)\n        J0_i = j0(k_perp * rho_s['i'])\n        J0_e = j0(k_perp * rho_s['e'])\n\n        # Assemble the spectral field operator\n        s_hat = J0_i * h_hat_i + J0_e * h_hat_e\n\n        # Transform back to real space\n        s_xy = np.fft.ifft2(s_hat)\n        \n        # The result must be real; take the real part to discard numerical noise\n        s_xy_real = s_xy.real\n\n        # Calculate the RMS diagnostic\n        rms = np.sqrt(np.mean(s_xy_real**2))\n        results.append(rms)\n\n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Accurately modeling magnetic perturbations is crucial in many fusion scenarios, and this begins with respecting the fundamental law that the magnetic field must be divergence-free, $\\nabla \\cdot \\delta\\mathbf{B} = 0$. This exercise introduces the advanced concept of a mimetic, or structure-preserving, discretization on a staggered grid, a sophisticated technique that guarantees this identity is upheld at the discrete level. This practice illustrates how careful numerical design is essential for preventing the growth of non-physical errors in long-time electromagnetic simulations. ",
            "id": "4197736",
            "problem": "You are tasked with implementing and verifying a discrete, mimetic numerical identity that is central to solving the gyrokinetic field equation in fusion plasma turbulence simulations. In the low-frequency gyrokinetic approximation, the perturbed magnetic field is represented in terms of the parallel component of the vector potential. Let $A_{\\parallel}$ denote the parallel component of the vector potential and let $\\hat{\\mathbf{b}}_{0}$ be a constant unit vector aligned with the background magnetic field. The perturbed magnetic field is defined by the curl relation\n$$\n\\delta \\mathbf{B} = \\nabla \\times \\left( A_{\\parallel} \\, \\hat{\\mathbf{b}}_{0} \\right).\n$$\nFor a system where $\\hat{\\mathbf{b}}_{0} = \\hat{\\mathbf{z}}$ is uniform, this reduces to the two-dimensional form\n$$\n\\delta B_x = \\frac{\\partial A_{\\parallel}}{\\partial y}, \\quad \\delta B_y = -\\frac{\\partial A_{\\parallel}}{\\partial x}, \\quad \\delta B_z = 0.\n$$\nA cornerstone identity from classical vector calculus is\n$$\n\\nabla \\cdot (\\nabla \\times \\mathbf{F}) = 0,\n$$\nwhich must be preserved discretely by a well-constructed numerical scheme to avoid non-physical accumulation of divergence errors in $\\mathbf{B}$.\n\nImplement a discrete scheme on a two-dimensional periodic, uniform, staggered (Yee-type) grid that respects this identity. Specifically, use the following grid assignments and operations:\n\n1. Place the scalar field $A_{\\parallel}$ at cell centers indexed by $(i,j)$ where $i = 0,1,\\dots,N_x-1$ and $j = 0,1,\\dots,N_y-1$. Let the domain be $[0,L_x] \\times [0,L_y]$ with uniform spacings $d_x = L_x/N_x$ and $d_y = L_y/N_y$. The cell center coordinates are\n$$\nx_i = \\left(i + \\frac{1}{2}\\right) d_x, \\quad y_j = \\left(j + \\frac{1}{2}\\right) d_y.\n$$\nAll trigonometric functions must use radians.\n\n2. Define averages of $A_{\\parallel}$ on staggered locations:\n$$\nA^{x}_{i+1/2,j} = \\frac{A_{i+1,j} + A_{i,j}}{2}, \\quad A^{y}_{i,j+1/2} = \\frac{A_{i,j+1} + A_{i,j}}{2}.\n$$\n\n3. Define the face-centered magnetic field components using centered differences at the appropriate staggered locations:\n$$\n\\delta B_x\\big|_{i+1/2,j} = \\frac{A^{x}_{i+1/2,j+1} - A^{x}_{i+1/2,j-1}}{2 d_y}, \\quad\n\\delta B_y\\big|_{i,j+1/2} = -\\frac{A^{y}_{i+1,j+1/2} - A^{y}_{i-1,j+1/2}}{2 d_x}.\n$$\nHere, periodic boundary conditions are used for all out-of-range indices, e.g., $A_{N_x,j} \\equiv A_{0,j}$ and $A_{i,N_y} \\equiv A_{i,0}$.\n\n4. Compute the discrete divergence at cell centers using the finite-volume form:\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = \\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x} + \\frac{\\delta B_y\\big|_{i,j+1/2} - \\delta B_y\\big|_{i,j-1/2}}{d_y},\n$$\nwith periodic boundary conditions on indices.\n\nYour program must:\n- Construct $A_{\\parallel}(x_i,y_j)$ for each test case below.\n- Compute $\\delta B_x$, $\\delta B_y$, and then $(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j}$ using the definitions above.\n- Return, for each test case, the single scalar equal to the maximum absolute value of the discrete divergence over all cells:\n$$\n\\max_{i,j} \\left| (\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} \\right|.\n$$\nThis quantity is dimensionless under the normalization implied by the definitions.\n\nAngle unit requirement: all trigonometric functions of spatial coordinates must use radians.\n\nTest Suite:\nProvide results for the following four test cases. In all cases, apply periodic boundary conditions as specified and use IEEE-754 double precision arithmetic.\n\n- Case 1 (smooth, periodic): $N_x = 8$, $N_y = 8$, $L_x = 2\\pi$, $L_y = 2\\pi$, with\n$$\nA_{\\parallel}(x,y) = \\sin(3x) + \\cos(2y).\n$$\n\n- Case 2 (random field, reproducible): $N_x = 64$, $N_y = 64$, $L_x = 1.0$, $L_y = 0.6$. Construct $A_{\\parallel}$ by drawing independent samples from the uniform distribution on $[0,1)$ at cell centers using a fixed random seed $s=1$.\n\n- Case 3 (anisotropic smooth): $N_x = 4$, $N_y = 10$, $L_x = \\pi$, $L_y = 2\\pi$, with\n$$\nA_{\\parallel}(x,y) = \\sin(x)\\sin(y).\n$$\n\n- Case 4 (higher wavenumbers, mixed periods): $N_x = 128$, $N_y = 63$, $L_x = 3.0$, $L_y = 1.3$, with\n$$\nA_{\\parallel}(x,y) = \\cos(13x) + \\sin(9y).\n$$\n\nFinal Output Format:\nYour program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, in the order of the cases above. For example:\n\"[r1,r2,r3,r4]\"\nEach $r_k$ must be a floating-point number (in decimal notation or scientific notation).",
            "solution": "The goal is to realize a discrete version of the identity $\\nabla \\cdot (\\nabla \\times \\mathbf{F}) = 0$ in the context of the gyrokinetic magnetic field representation $\\delta \\mathbf{B} = \\nabla \\times (A_{\\parallel} \\hat{\\mathbf{b}}_{0})$ with uniform background direction $\\hat{\\mathbf{b}}_{0} = \\hat{\\mathbf{z}}$. Under this assumption, the continuous relations yield $\\delta B_x = \\partial_y A_{\\parallel}$ and $\\delta B_y = -\\partial_x A_{\\parallel}$. The continuous divergence then reads\n$$\n\\nabla \\cdot \\delta \\mathbf{B} = \\partial_x \\left(\\partial_y A_{\\parallel}\\right) + \\partial_y \\left(-\\partial_x A_{\\parallel}\\right) = \\partial_x \\partial_y A_{\\parallel} - \\partial_y \\partial_x A_{\\parallel} = 0,\n$$\nusing the commutativity of mixed partial derivatives under smoothness assumptions.\n\nTo preserve this property in discrete form, we select a Yee-type staggered grid that emulates the differential operator complex. The construction is:\n\n1. $A_{\\parallel}$ is stored at cell centers $(i,j)$ with spacings $d_x$ and $d_y$, and periodic boundary conditions on both directions. The trigonometric functions defining $A_{\\parallel}$ use radians, ensuring physical consistency for spatial Fourier modes.\n\n2. Define staggered averages of $A_{\\parallel}$ onto half-integer locations:\n$$\nA^{x}_{i+1/2,j} = \\frac{A_{i+1,j} + A_{i,j}}{2}, \\quad A^{y}_{i,j+1/2} = \\frac{A_{i,j+1} + A_{i,j}}{2}.\n$$\nThese provide consistent approximations of $A_{\\parallel}$ at locations where derivatives with respect to the orthogonal coordinate will be evaluated.\n\n3. Compute face-centered magnetic field components using centered differences orthogonal to the averaging direction:\n$$\n\\delta B_x\\big|_{i+1/2,j} = \\frac{A^{x}_{i+1/2,j+1} - A^{x}_{i+1/2,j-1}}{2 d_y}, \\quad\n\\delta B_y\\big|_{i,j+1/2} = -\\frac{A^{y}_{i+1,j+1/2} - A^{y}_{i-1,j+1/2}}{2 d_x}.\n$$\nPeriodic boundary conditions ensure indices wrap around properly.\n\n4. The discrete divergence is obtained by a finite-volume balance at cell centers:\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = \\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x} + \\frac{\\delta B_y\\big|_{i,j+1/2} - \\delta B_y\\big|_{i,j-1/2}}{d_y}.\n$$\n\nPrinciple-based derivation of the mimetic identity:\nThe chosen scheme is designed so that the discrete divergence of the discrete curl is identically zero for any $A_{\\parallel}$, up to machine round-off. To see this, consider the $x$-contribution:\n$$\n\\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x}\n= \\frac{1}{d_x} \\left[ \\frac{A^{x}_{i+1/2,j+1} - A^{x}_{i+1/2,j-1}}{2 d_y} - \\frac{A^{x}_{i-1/2,j+1} - A^{x}_{i-1/2,j-1}}{2 d_y} \\right]\n= \\frac{1}{2 d_x d_y} \\left[ (A^{x}_{i+1/2,j+1} - A^{x}_{i-1/2,j+1}) - (A^{x}_{i+1/2,j-1} - A^{x}_{i-1/2,j-1}) \\right].\n$$\nNoting that\n$$\nA^{x}_{i+1/2,j} - A^{x}_{i-1/2,j} = \\frac{A_{i+1,j} + A_{i,j}}{2} - \\frac{A_{i,j} + A_{i-1,j}}{2} = \\frac{A_{i+1,j} - A_{i-1,j}}{2},\n$$\nwe can rewrite the $x$-contribution as a centered $y$-derivative of a centered $x$-derivative:\n$$\n\\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x} = \\frac{1}{2 d_y} \\left[ \\frac{A_{i+1,j+1} - A_{i-1,j+1}}{2 d_x} - \\frac{A_{i+1,j-1} - A_{i-1,j-1}}{2 d_x} \\right] = \\partial^{h}_y \\left( \\partial^{h}_x A_{\\parallel} \\right)\\Big|_{i,j},\n$$\nwhere $\\partial^{h}_x$ and $\\partial^{h}_y$ denote the centered discrete derivatives. Similarly, for the $y$-contribution,\n$$\n\\frac{\\delta B_y\\big|_{i,j+1/2} - \\delta B_y\\big|_{i,j-1/2}}{d_y} = -\\partial^{h}_x \\left( \\partial^{h}_y A_{\\parallel} \\right)\\Big|_{i,j}.\n$$\nTherefore,\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = \\partial^{h}_y \\left( \\partial^{h}_x A_{\\parallel} \\right)\\Big|_{i,j} - \\partial^{h}_x \\left( \\partial^{h}_y A_{\\parallel} \\right)\\Big|_{i,j}.\n$$\nOn a uniform grid with periodic boundary conditions, the centered discrete derivatives commute, $\\partial^{h}_y \\partial^{h}_x A_{\\parallel} = \\partial^{h}_x \\partial^{h}_y A_{\\parallel}$, yielding\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = 0,\n$$\nmodulo floating-point round-off. This is the discrete analog of $\\nabla \\cdot (\\nabla \\times \\mathbf{F}) = 0$, achieved through the staggered placement and averaged derivatives that constitute a mimetic scheme.\n\nAlgorithmic steps:\n- Construct the grid and $A_{\\parallel}(x_i,y_j)$.\n- Compute $A^{x}_{i+1/2,j}$ and $A^{y}_{i,j+1/2}$ by periodic averaging.\n- Compute $\\delta B_x$ and $\\delta B_y$ using centered differences on the staggered locations with periodic indexing.\n- Compute the cell-centered discrete divergence using face flux differences.\n- Return the maximum absolute divergence over all cells for each test case.\n\nNumerical expectations:\nDue to floating-point arithmetic, the computed maxima should be on the order of machine precision for double precision (approximately $10^{-16}$ to $10^{-15}$), although small increases can occur due to function evaluations and accumulation in differences. The reported values are dimensionless scalars.\n\nThe program will output the four maxima in the order of the specified test suite as a single line in the format \"[r1,r2,r3,r4]\".",
            "answer": "```python\nimport numpy as np\n\ndef compute_max_abs_divergence(Nx, Ny, Lx, Ly, A_builder):\n    # Grid spacings\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Cell-centered coordinates (radians for any trigonometric A_builder)\n    xi = (np.arange(Nx) + 0.5) * dx\n    yj = (np.arange(Ny) + 0.5) * dy\n\n    # Build A_parallel at cell centers\n    A = A_builder(xi, yj)  # shape (Nx, Ny)\n\n    # Periodic index helpers\n    ip1 = lambda i: (i + 1) % Nx\n    im1 = lambda i: (i - 1) % Nx\n    jp1 = lambda j: (j + 1) % Ny\n    jm1 = lambda j: (j - 1) % Ny\n\n    # Staggered averages: A^x at (i+1/2, j), A^y at (i, j+1/2)\n    A_xavg = 0.5 * (A + A[np.array([ip1(i) for i in range(Nx)]), :])\n    A_yavg = 0.5 * (A + A[:, np.array([jp1(j) for j in range(Ny)])])\n\n    # Compute Bx at (i+1/2, j): centered difference in y\n    Bx = np.empty((Nx, Ny), dtype=np.float64)\n    for i in range(Nx):\n        for j in range(Ny):\n            Bx[i, j] = (A_xavg[i, jp1(j)] - A_xavg[i, jm1(j)]) / (2.0 * dy)\n\n    # Compute By at (i, j+1/2): centered difference in x, with negative sign\n    By = np.empty((Nx, Ny), dtype=np.float64)\n    for i in range(Nx):\n        for j in range(Ny):\n            By[i, j] = -(A_yavg[ip1(i), j] - A_yavg[im1(i), j]) / (2.0 * dx)\n\n    # Compute divergence at cell centers\n    divB = np.empty((Nx, Ny), dtype=np.float64)\n    for i in range(Nx):\n        for j in range(Ny):\n            term_x = (Bx[i, j] - Bx[im1(i), j]) / dx\n            term_y = (By[i, j] - By[i, jm1(j)]) / dy\n            divB[i, j] = term_x + term_y\n\n    # Return maximum absolute divergence\n    return float(np.max(np.abs(divB)))\n\n\ndef solve():\n    # Define A_builder functions for each test case\n    def A_case1(xi, yj):\n        # A(x,y) = sin(3x) + cos(2y), radians\n        X, Y = np.meshgrid(xi, yj, indexing='ij')\n        return np.sin(3.0 * X) + np.cos(2.0 * Y)\n\n    def A_case2(xi, yj):\n        # Random uniform [0,1) at cell centers with fixed seed\n        rng = np.random.default_rng(seed=1)\n        return rng.random((len(xi), len(yj)), dtype=np.float64)\n\n    def A_case3(xi, yj):\n        # A(x,y) = sin(x) sin(y), radians\n        X, Y = np.meshgrid(xi, yj, indexing='ij')\n        return np.sin(X) * np.sin(Y)\n\n    def A_case4(xi, yj):\n        # A(x,y) = cos(13x) + sin(9y), radians\n        X, Y = np.meshgrid(xi, yj, indexing='ij')\n        return np.cos(13.0 * X) + np.sin(9.0 * Y)\n\n    # Test cases: (Nx, Ny, Lx, Ly, A_builder)\n    test_cases = [\n        (8, 8, 2.0 * np.pi, 2.0 * np.pi, A_case1),\n        (64, 64, 1.0, 0.6, A_case2),\n        (4, 10, np.pi, 2.0 * np.pi, A_case3),\n        (128, 63, 3.0, 1.3, A_case4),\n    ]\n\n    results = []\n    for Nx, Ny, Lx, Ly, A_builder in test_cases:\n        max_abs_div = compute_max_abs_divergence(Nx, Ny, Lx, Ly, A_builder)\n        results.append(max_abs_div)\n\n    # Print in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}