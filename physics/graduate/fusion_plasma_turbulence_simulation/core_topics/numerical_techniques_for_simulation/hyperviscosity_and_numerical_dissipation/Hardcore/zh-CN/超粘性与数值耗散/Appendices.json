{
    "hands_on_practices": [
        {
            "introduction": "在数值模拟中，我们用来近似偏微分方程的离散格式并非完美。它们会引入截断误差，而这些误差有时会表现得如同物理项。修正方程分析是一种强大的技术，能揭示这些隐藏的效应。通过本练习 ()，你将通过对一阶迎风格式的分析，亲手推导出其主导误差项，并理解它为何表现为一个有效的数值黏性。",
            "id": "4191613",
            "problem": "在聚变等离子体湍流的磁通管模型中，沿副法线坐标的一维平流通常为了稳定性而采用迎风差分进行离散化，这会引入数值耗散。考虑线性平流偏微分方程 $\\,\\partial_{t} u + c\\,\\partial_{x} u = 0\\,$，其中平流速度 $\\,c>0\\,$ 为常数，该方程在空间步长为 $\\,\\Delta x\\,$、时间步长为 $\\,\\Delta t\\,$ 的均匀网格上进行离散化。针对 $\\,c>0\\,$ 的一阶迎风格式由以下更新式定义\n$$\nu_{j}^{n+1} \\;=\\; u_{j}^{n} \\;-\\; \\lambda \\left( u_{j}^{n} - u_{j-1}^{n} \\right),\n$$\n其中 Courant–Friedrichs–Lewy (CFL) 数 $\\,\\lambda\\,$ 为 $\\,\\lambda = c\\,\\Delta t / \\Delta x\\,$。以控制方程 $\\,\\partial_{t} u + c\\,\\partial_{x} u = 0\\,$ 为基础，通过将格式在 $\\,\\Delta x\\,$ 和 $\\,\\Delta t\\,$ 中一致地展开至二阶泰勒级数，并利用基础方程消去高阶时间导数，来进行修正方程分析。推导形式为\n$$\n\\partial_{t} u + c\\,\\partial_{x} u \\;=\\; \\nu_{\\mathrm{num}}\\,\\partial_{x}^{2} u \\;+\\; \\text{更高阶项}\n$$\n的相应连续修正方程，并提取出主阶有效数值黏性系数 $\\,\\nu_{\\mathrm{num}}\\,$，其形式为用 $\\,c\\,$、$\\,\\Delta x\\,$ 和 $\\,\\lambda\\,$ 表示的封闭解析表达式。提供 $\\,\\nu_{\\mathrm{num}}\\,$ 的最终表达式。无需进行数值计算；给出精确的符号表达式。最终答案必须是答案框内的单个解析表达式，不含单位。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，是适定的、客观的，提出了一个偏微分方程数值分析领域的标准问题。所有用于唯一推导的必要信息均已提供。\n\n任务是推导应用于线性平流方程的一阶迎风格式的主阶有效数值黏性系数 $\\nu_{\\mathrm{num}}$。该分析将通过对离散格式的各项进行泰勒级数展开，以获得该格式实际求解的修正偏微分方程来完成。\n\n控制偏微分方程 (PDE) 是线性平流方程：\n$$\n\\partial_{t} u + c\\,\\partial_{x} u = 0\n$$\n其中 $u$ 是时间 $t$ 和空间 $x$ 的函数，而 $c > 0$ 是一个恒定的平流速度。\n\n一阶迎风有限差分格式由下式给出：\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\lambda \\left( u_{j}^{n} - u_{j-1}^{n} \\right)\n$$\n其中 $u_{j}^{n}$ 表示在空间网格点 $x_j = j\\,\\Delta x$ 和时间 $t_n = n\\,\\Delta t$ 处的数值解。Courant–Friedrichs–Lewy (CFL) 数为 $\\lambda = c\\,\\Delta t / \\Delta x$。\n\n为进行修正方程分析，我们将格式中的每一项在点 $(x_j, t_n)$ 附近展开为泰勒级数。令不带下标或上标的 $u$ 表示 $u(x_j, t_n)$。\n\n项 $u_{j}^{n+1}$ 是在时间上的展开：\n$$\nu_{j}^{n+1} = u(x_j, t_n + \\Delta t) = u + \\Delta t\\,\\partial_{t} u + \\frac{(\\Delta t)^{2}}{2}\\,\\partial_{t}^{2} u + \\frac{(\\Delta t)^{3}}{6}\\,\\partial_{t}^{3} u + O((\\Delta t)^{4})\n$$\n\n项 $u_{j-1}^{n}$ 是在空间上的展开：\n$$\nu_{j-1}^{n} = u(x_j - \\Delta x, t_n) = u - \\Delta x\\,\\partial_{x} u + \\frac{(\\Delta x)^{2}}{2}\\,\\partial_{x}^{2} u - \\frac{(\\Delta x)^{3}}{6}\\,\\partial_{x}^{3} u + O((\\Delta x)^{4})\n$$\n\n现在，我们将这些展开式代入数值格式中：\n$$\n\\left( u + \\Delta t\\,\\partial_{t} u + \\frac{(\\Delta t)^{2}}{2}\\,\\partial_{t}^{2} u + \\dots \\right) = u - \\lambda \\left( u - \\left( u - \\Delta x\\,\\partial_{x} u + \\frac{(\\Delta x)^{2}}{2}\\,\\partial_{x}^{2} u - \\dots \\right) \\right)\n$$\n首先简化右侧：\n$$\nu - \\lambda \\left( \\Delta x\\,\\partial_{x} u - \\frac{(\\Delta x)^{2}}{2}\\,\\partial_{x}^{2} u + \\dots \\right) = u - \\lambda\\,\\Delta x\\,\\partial_{x} u + \\frac{\\lambda\\,(\\Delta x)^{2}}{2}\\,\\partial_{x}^{2} u - \\dots\n$$\n将 CFL 数的定义 $\\lambda = c\\,\\Delta t / \\Delta x$ 代入简化后的右侧：\n$$\nu - \\left(\\frac{c\\,\\Delta t}{\\Delta x}\\right)\\,\\Delta x\\,\\partial_{x} u + \\frac{1}{2}\\left(\\frac{c\\,\\Delta t}{\\Delta x}\\right)\\,(\\Delta x)^{2}\\,\\partial_{x}^{2} u - \\dots = u - c\\,\\Delta t\\,\\partial_{x} u + \\frac{c\\,\\Delta t\\,\\Delta x}{2}\\,\\partial_{x}^{2} u - \\dots\n$$\n现在，令展开后的左侧和右侧相等：\n$$\nu + \\Delta t\\,\\partial_{t} u + \\frac{(\\Delta t)^{2}}{2}\\,\\partial_{t}^{2} u + \\dots = u - c\\,\\Delta t\\,\\partial_{x} u + \\frac{c\\,\\Delta t\\,\\Delta x}{2}\\,\\partial_{x}^{2} u - \\dots\n$$\n我们从两侧消去项 $u$，然后将整个方程除以 $\\Delta t$：\n$$\n\\partial_{t} u + \\frac{\\Delta t}{2}\\,\\partial_{t}^{2} u + \\dots = -c\\,\\partial_{x} u + \\frac{c\\,\\Delta x}{2}\\,\\partial_{x}^{2} u - \\dots\n$$\n重新整理此方程以匹配原始 PDE 加上高阶项的形式，得到截断误差：\n$$\n\\partial_{t} u + c\\,\\partial_{x} u = \\frac{c\\,\\Delta x}{2}\\,\\partial_{x}^{2} u - \\frac{\\Delta t}{2}\\,\\partial_{t}^{2} u + O(\\Delta x^2, \\Delta t^2)\n$$\n这个方程描述了离散格式实际求解的连续 PDE，精确到主阶。为了获得所要求形式的修正方程，我们必须用空间导数来表示高阶时间导数。这可以通过反复使用方程本身来实现。\n\n从方程的主阶部分，我们得到原始 PDE：\n$$\n\\partial_{t} u = -c\\,\\partial_{x} u + O(\\Delta x, \\Delta t)\n$$\n对 $t$ 求导：\n$$\n\\partial_{t}^{2} u = \\partial_{t}(-c\\,\\partial_{x} u + \\dots) = -c\\,\\partial_{t}(\\partial_{x} u) + \\dots = -c\\,\\partial_{x}(\\partial_{t} u) + \\dots\n$$\n现在将 $\\partial_{t} u = -c\\,\\partial_{x} u$ 代回到 $\\partial_{t}^{2} u$ 的表达式中：\n$$\n\\partial_{t}^{2} u = -c\\,\\partial_{x}(-c\\,\\partial_{x} u) + \\dots = c^{2}\\,\\partial_{x}^{2} u + O(\\Delta x, \\Delta t)\n$$\n我们现在将这个 $\\partial_{t}^{2} u$ 的表达式代回到我们的截断方程中：\n$$\n\\partial_{t} u + c\\,\\partial_{x} u = \\frac{c\\,\\Delta x}{2}\\,\\partial_{x}^{2} u - \\frac{\\Delta t}{2}\\left(c^{2}\\,\\partial_{x}^{2} u\\right) + \\text{更高阶项}\n$$\n右侧包含主阶误差项，该项在空间导数上是二阶的，并具有扩散项或黏性项的形式。我们现在可以合并 $\\partial_{x}^{2} u$ 的系数：\n$$\n\\partial_{t} u + c\\,\\partial_{x} u = \\left( \\frac{c\\,\\Delta x}{2} - \\frac{c^2\\,\\Delta t}{2} \\right)\\,\\partial_{x}^{2} u + \\text{H.O.T.}\n$$\n通过将其与目标形式 $\\partial_{t} u + c\\,\\partial_{x} u = \\nu_{\\mathrm{num}}\\,\\partial_{x}^{2} u + \\text{H.O.T.}$ 进行比较，我们可以确定有效数值黏性系数 $\\nu_{\\mathrm{num}}$：\n$$\n\\nu_{\\mathrm{num}} = \\frac{c\\,\\Delta x}{2} - \\frac{c^2\\,\\Delta t}{2}\n$$\n最后一步是根据要求，用 $c$、$\\Delta x$ 和 $\\lambda$ 来表示该系数。我们使用恒等式 $c\\,\\Delta t = \\lambda\\,\\Delta x$：\n$$\n\\nu_{\\mathrm{num}} = \\frac{c\\,\\Delta x}{2} - \\frac{c}{2}(c\\,\\Delta t) = \\frac{c\\,\\Delta x}{2} - \\frac{c}{2}(\\lambda\\,\\Delta x)\n$$\n提取公因式，得到数值黏性的最终表达式：\n$$\n\\nu_{\\mathrm{num}} = \\frac{c\\,\\Delta x}{2} (1 - \\lambda)\n$$\n这个表达式表明，一阶迎风格式的主阶误差是一个耗散项，与网格尺寸 $\\Delta x$ 以及一个取决于 CFL 数的因子 $(1-\\lambda)$ 成正比。该项是使用此格式时观察到的数值耗散的原因。",
            "answer": "$$\n\\boxed{\\frac{c\\,\\Delta x}{2}(1 - \\lambda)}\n$$"
        },
        {
            "introduction": "在理解了数值格式本身可能引入耗散之后，我们转向主动引入的超黏性，这是一种在湍流模拟中用以抑制网格尺度噪声并确保数值稳定性的常用技术。然而，当使用显式时间积分方法处理这些高阶导数项时，会带来一个严峻的挑战：对时间步长的严格限制。本练习 () 将指导你从第一性原理出发，为双拉普拉斯超黏性算子推导这个至关重要的稳定时间步长上限。",
            "id": "4191634",
            "problem": "一个电阻漂移波湍流的一维板模型，其垂直超粘性耗散项使用显式前向欧拉格式进行时间推进。在傅里叶空间中，对于每个波数$k$，$n$阶超粘性算子的本征值为$\\lambda_k = -\\nu_n k^{2n}$，其中$\\nu_n$是超粘性系数。假设所有非超粘性算子的处理方式不会进一步限制时间步长，因此显式时间步长约束完全由超粘性决定。\n\n给定参数如下：\n- 超粘性阶数 $n = 2$ (双拉普拉斯算子)，因此 $\\lambda_k = -\\nu_2 k^{4}$。\n- 超粘性系数 $\\nu_2 = 2.0 \\times 10^{-11}$ $\\mathrm{m}^4/\\mathrm{s}$。\n- 一个间距为 $\\Delta x = \\pi/5000$ $\\mathrm{m}$ 的均匀网格，其最高可分辨波数可近似为奈奎斯特波数 $k_{\\max} = \\pi/\\Delta x$。\n\n从线性微分算子的傅里叶表示和线性标量模显式时间步进的稳定性要求等第一性原理出发，推导由超粘性决定的最大稳定显式时间步长$\\Delta t_{\\max}$。然后使用上述参数对$\\Delta t_{\\max}$进行数值计算。以微秒表示最终的时间步长，并将答案四舍五入到四位有效数字。",
            "solution": "首先根据所需准则对问题陈述进行验证。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n-   物理系统是电阻漂移波湍流的一维板模型。\n-   超粘性耗散项的时间步进格式是显式前向欧拉更新。\n-   $n$阶超粘性算子对每个波数$k$的本征值为$\\lambda_k = -\\nu_n k^{2n}$。\n-   超粘性系数为$\\nu_n$。\n-   时间步长约束完全由超粘性项决定。\n-   超粘性阶数：$n=2$ (双拉普拉斯算子)。\n-   $n=2$时的本征值表达式：$\\lambda_k = -\\nu_2 k^{4}$。\n-   超粘性系数值：$\\nu_2 = 2.0 \\times 10^{-11}$ $\\mathrm{m}^4/\\mathrm{s}$。\n-   网格配置：均匀网格，间距$\\Delta x = \\pi/5000$ $\\mathrm{m}$。\n-   最高可分辨波数：$k_{\\max} = \\pi/\\Delta x$。\n-   目标：推导最大稳定显式时间步长$\\Delta t_{\\max}$，并以微秒为单位进行数值计算，结果四舍五入到四位有效数字。\n\n**步骤2：使用提取的信息进行验证**\n-   **科学依据充分**：该问题在计算物理和数值分析领域有充分的科学依据。超粘性（特别是$n=2$时的双拉普拉斯算子）的使用是湍流模拟中在网格尺度上提供尺度选择性耗散的标准技术。前向欧拉法是一种基本的显式时间步进格式。将此格式应用于线性耗散算子的稳定性分析是一个经典且已被充分理解的问题。本征值$\\lambda_k = -\\nu_n k^{2n}$的形式是算子$(-1)^{n+1}\\nu_n \\nabla^{2n}$的正确傅里叶表示。该问题在科学和数学上都是合理的。\n-   **问题适定**：该问题定义清晰，提供了计算所求量$\\Delta t_{\\max}$所需的所有参数（$\\nu_2$、$\\Delta x$、$n$）和定义（$k_{\\max}$）。其逻辑是自洽的，并能导出一个唯一的解。\n-   **客观性**：语言精确且量化，没有主观或模糊的术语。\n\n**步骤3：结论与行动**\n该问题是有效的。这是一个标准的数值稳定性分析练习，具有科学合理性、适定性和客观性。将提供解答。\n\n### 解题推导\n\n在超粘性算子的作用下，单个傅里叶模的振幅$\\hat{\\phi}_k(t)$的演化由以下线性常微分方程（ODE）描述：\n$$\n\\frac{d\\hat{\\phi}_k}{dt} = \\lambda_k \\hat{\\phi}_k\n$$\n其中$\\lambda_k$是对应于波数$k$的本征值。对于给定的$n=2$阶超粘性项，其本征值为：\n$$\n\\lambda_k = -\\nu_2 k^4\n$$\n\n问题陈述该常微分方程使用显式前向欧拉格式进行时间离散化。设$\\hat{\\phi}_k^j$表示在时间步$j$时傅里叶振幅的值。前向欧拉更新由下式给出：\n$$\n\\frac{\\hat{\\phi}_k^{j+1} - \\hat{\\phi}_k^j}{\\Delta t} = \\lambda_k \\hat{\\phi}_k^j\n$$\n其中$\\Delta t$是时间步长。重新整理此方程可得到$\\hat{\\phi}_k$的更新规则：\n$$\n\\hat{\\phi}_k^{j+1} = \\hat{\\phi}_k^j + \\Delta t (\\lambda_k \\hat{\\phi}_k^j) = (1 + \\lambda_k \\Delta t) \\hat{\\phi}_k^j\n$$\n$G_k = 1 + \\lambda_k \\Delta t$项是模$k$的放大因子。为使数值格式稳定，任何模的放大因子的大小都不能超过1。这可以防止数值解的任何分量无限增长。因此，稳定性条件为：\n$$\n|G_k| \\le 1 \\quad \\forall k\n$$\n代入$G_k$的表达式，我们得到：\n$$\n|1 + \\lambda_k \\Delta t| \\le 1\n$$\n由于超粘性系数$\\nu_2 = 2.0 \\times 10^{-11} \\, \\mathrm{m}^4/\\mathrm{s}$为正，本征值$\\lambda_k = -\\nu_2 k^4$是一个实数且非正。对于前向欧拉格式中的实数非正本征值$\\lambda$，其稳定性条件是一个众所周知的结果。我们可以通过考虑不等式$|1 + \\lambda \\Delta t| \\le 1$来推导它。由于$\\lambda \\Delta t \\le 0$，我们有：\n$$\n-1 \\le 1 + \\lambda_k \\Delta t \\le 1\n$$\n不等式的右边，$1 + \\lambda_k \\Delta t \\le 1$，可简化为$\\lambda_k \\Delta t \\le 0$。鉴于$\\lambda_k \\le 0$和$\\Delta t \\ge 0$，该条件总是满足的。不等式的左边提供了非平凡的约束条件：\n$$\n-1 \\le 1 + \\lambda_k \\Delta t\n$$\n$$\n-2 \\le \\lambda_k \\Delta t\n$$\n$$\n\\Delta t \\le \\frac{-2}{\\lambda_k} = \\frac{2}{-\\lambda_k} = \\frac{2}{|\\lambda_k|}\n$$\n代入$\\lambda_k$的表达式：\n$$\n\\Delta t \\le \\frac{2}{\\nu_2 k^4}\n$$\n这个条件必须对数值网格上解析的所有波数$k$都成立。为确保全局稳定性，必须选择时间步长$\\Delta t$以满足最严格的情况。当分母$\\nu_2 k^4$最大化时，不等式的右侧达到最小值。这发生在最高可表示波数$k_{\\max}$处。因此，最大稳定时间步长$\\Delta t_{\\max}$为：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\nu_2 k_{\\max}^4}\n$$\n问题给出了网格间距$\\Delta x = \\pi/5000 \\, \\mathrm{m}$，并将最大波数定义为奈奎斯特波数，$k_{\\max} = \\pi/\\Delta x$。\n$$\nk_{\\max} = \\frac{\\pi}{\\pi/5000 \\, \\mathrm{m}} = 5000 \\, \\mathrm{m}^{-1}\n$$\n现在我们可以将$\\nu_2$和$k_{\\max}$的数值代入$\\Delta t_{\\max}$的表达式中：\n$$\n\\nu_2 = 2.0 \\times 10^{-11} \\, \\frac{\\mathrm{m}^4}{\\mathrm{s}}\n$$\n$$\nk_{\\max} = 5 \\times 10^3 \\, \\mathrm{m}^{-1}\n$$\n$$\n\\Delta t_{\\max} = \\frac{2}{(2.0 \\times 10^{-11} \\, \\frac{\\mathrm{m}^4}{\\mathrm{s}}) (5 \\times 10^3 \\, \\mathrm{m}^{-1})^4}\n$$\n$$\n\\Delta t_{\\max} = \\frac{2}{(2.0 \\times 10^{-11}) (5^4 \\times (10^3)^4)} \\, \\mathrm{s}\n$$\n$$\n\\Delta t_{\\max} = \\frac{2}{(2.0 \\times 10^{-11}) (625 \\times 10^{12})} \\, \\mathrm{s}\n$$\n$$\n\\Delta t_{\\max} = \\frac{2}{2.0 \\times 625 \\times 10^{(-11+12)}} \\, \\mathrm{s}\n$$\n$$\n\\Delta t_{\\max} = \\frac{2}{1250 \\times 10^1} \\, \\mathrm{s} = \\frac{2}{12500} \\, \\mathrm{s}\n$$\n$$\n\\Delta t_{\\max} = \\frac{1}{6250} \\, \\mathrm{s} = 0.00016 \\, \\mathrm{s}\n$$\n问题要求答案以微秒（$\\mu\\mathrm{s}$）表示。\n$$\n1 \\, \\mathrm{s} = 10^6 \\, \\mu\\mathrm{s}\n$$\n$$\n\\Delta t_{\\max} = 0.00016 \\times 10^6 \\, \\mu\\mathrm{s} = 160 \\, \\mu\\mathrm{s}\n$$\n最后，我们必须将答案四舍五入到四位有效数字。数值160可以写作160.0来明确表示四位有效数字。\n$$\n\\Delta t_{\\max} = 160.0 \\, \\mu\\mathrm{s}\n$$",
            "answer": "$$\n\\boxed{160.0}\n$$"
        },
        {
            "introduction": "我们已经知道如何分析并稳定地实现超黏性项，但如何确保我们的代码实现是完全正确且表现符合物理预期的呢？本练习 () 将引导你从分析推导转向计算验证，设计一套数值测试来检验谱方法超黏性求解器的质量。一个优秀的求解器不仅要稳定，还必须遵守基本的物理原理，例如极值原理和能量耗散，本练习将检验这些关键特性。",
            "id": "4191606",
            "problem": "您的任务是以数学上严谨且算法上可实现的方式，验证在聚变等离子体湍流模拟中使用的超粘性耗散算子在应用于不连续初始条件时，不会产生违反物理界限的吉布斯振荡。考虑一个长度为 $2\\pi$ 的一维周期性域，坐标为 $x \\in [0,2\\pi)$，并定义一个标量场 $u(x,t)$，它由以下偏微分方程（PDE）控制：\n$$\n\\partial_t u(x,t) = - \\nu_p \\left(-\\nabla^2\\right)^p u(x,t),\n$$\n其中 $p \\in \\mathbb{N}$ 是超粘性阶数，$\\nu_p  0$ 是超粘性系数，$\\nabla^2$ 是空间拉普拉斯算子。在周期性域上，超粘性算子在傅里叶空间中是对角化的。如果 $\\hat{u}_k(t)$ 表示模式 $k \\in \\mathbb{Z}$ 的快速傅里叶变换（FFT）系数，则每个傅里叶模式的演化满足：\n$$\n\\partial_t \\hat{u}_k(t) = - \\nu_p |k|^{2p} \\hat{u}_k(t),\n$$\n其精确积分为：\n$$\n\\hat{u}_k(t) = \\hat{u}_k(0)\\,\\exp\\left(-\\nu_p |k|^{2p} t\\right).\n$$\n目标是设计一套数值测试，以确保在平滑阶跃函数时，超粘性阻尼不会产生将解推出物理上有意义的界限之外的吉布斯振荡，并验证预期的耗散性质，包括能量单调衰减和常数场的不变性。\n\n此问题中的所有量均为无量纲量。域是周期性的，长度为 $2\\pi$。初始阶跃函数定义为：\n$$\nu_0(x) = \\begin{cases}\n1,  x \\in [\\pi,2\\pi),\\\\\n0,  x \\in [0,\\pi).\n\\end{cases}\n$$\n您的程序必须：\n- 在 $[0,2\\pi)$ 上的 $N$ 个点的网格上表示场 $u(x,t)$，网格间距为 $\\Delta x = 2\\pi/N$。\n- 通过变换到傅里叶空间，对每个模式应用精确的指数衰减因子 $\\exp\\left(-\\nu_p |k|^{2p} t\\right)$，然后通过逆 FFT 变换回实空间，从而将 $u(x,0)$ 演化到 $u(x,t)$，以获得实空间中的 $u(x,t)$。\n- 实现以下三种类型的测试：\n    1. 阶跃函数扩散的边界保持性：对于阶跃函数初始条件 $u_0(x)$，在演化到时间 $t$ 后，验证 $u(x,t)$ 没有违反物理界限。这表示为条件 $\\min_x u(x,t) \\ge -\\epsilon$ 和 $\\max_x u(x,t) \\le 1 + \\epsilon$，其中 $\\epsilon$ 是一个小的非负容差。如果两个不等式都成立，则测试返回 $True$，否则返回 $False$。\n    2. 能量单调性：将离散能量定义为 $E(t) = \\frac{1}{2} \\sum_{j=0}^{N-1} u(x_j,t)^2 \\,\\Delta x$。检查 $E(t) \\le E(0) + \\epsilon$，其中 $\\epsilon$ 是一个小的容差。如果此不等式成立，则测试返回 $True$，否则返回 $False$。\n    3. 常数场不变性：对于常数初始条件 $u_0(x) \\equiv c$，验证在容差 $\\epsilon$ 内，对于所有 $x$，$u(x,t)$ 保持等于 $c$。该测试计算 $\\max_x |u(x,t)-c|$，如果此最大值小于或等于 $\\epsilon$，则返回 $True$，否则返回 $False$。\n\n使用与在 $[0,2\\pi)$ 上的 $N$ 个网格点上进行标准离散 FFT 一致的傅里叶波数约定，即当 $N$为偶数时，整数波数 $k$ 的排序为 $0,1,2,\\dots,\\frac{N}{2}-1,-\\frac{N}{2},\\dots,-1$，并且模式 $k=0$ 是常数模式。\n\n设计程序以评估以下测试套件，每个测试由 $(N,p,\\nu_p,t,\\epsilon)$ 以及初始条件类型指定。如上所述，所有量均采用无量纲单位。\n\n- 情况 1（正常情况的阶跃函数边界）：$(N,p,\\nu_p,t,\\epsilon) = (1024, 4, 1.0, 10.0, 10^{-6})$，初始条件是阶跃函数 $u_0(x)$。\n- 情况 2（粗网格的阶跃函数边界边缘情况）：$(N,p,\\nu_p,t,\\epsilon) = (256, 8, 1.0, 10.0, 10^{-6})$，初始条件是阶跃函数 $u_0(x)$。\n- 情况 3（边界条件常数不变性）：$(N,p,\\nu_p,t,\\epsilon,c) = (256, 6, 0.3, 3.0, 10^{-12}, 0.3)$，初始条件是常数 $u_0(x) \\equiv c$。\n- 情况 4（能量单调性）：$(N,p,\\nu_p,t,\\epsilon) = (512, 1, 0.8, 1.2, 10^{-12})$，初始条件是阶跃函数 $u_0(x)$。\n\n对于情况 1 和情况 2，报告边界保持性测试结果。对于情况 3，报告常数场不变性结果。对于情况 4，报告能量单调性结果。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序为情况 1、情况 2、情况 3、情况 4（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是以该语言的原生布尔格式表示的布尔值。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、适定且完整的。因此，我们可以着手进行形式化的求解。\n\n该问题要求为超粘性耗散算子设计并实现一个数值验证套件，该算子常用于流体和等离子体湍流的模拟中。其目标是确认该算子的数值实现保留了基本的物理和数学性质，例如边界保持性、能量耗散性和常数态的不变性。所考虑的模型方程是在周期性域 $x \\in [0, 2\\pi)$ 上的一维超粘性偏微分方程（PDE）：\n$$\n\\partial_t u(x,t) = - \\nu_p \\left(-\\nabla^2\\right)^p u(x,t)\n$$\n这里，$u(x,t)$ 是一个标量场，$\\nu_p  0$ 是超粘性系数，$p \\in \\mathbb{N}$ 是超粘性的阶数。\n\n所选的数值方法是谱方法，由于周期性边界条件和空间算子的性质，该方法非常适合此问题。在傅里葉空间中，算子 $(-\\nabla^2)^p$ 变成一个简单的代数乘法。周期域上的函数 $u(x)$ 可以用其傅里葉级数 $u(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{u}_k e^{ikx}$ 来表示。应用空间算子可得：\n$$\n\\left(-\\nabla^2\\right)^p u(x) = \\left(-\\nabla^2\\right)^p \\sum_k \\hat{u}_k e^{ikx} = \\sum_k \\hat{u}_k (k^2)^p e^{ikx} = \\sum_k |k|^{2p} \\hat{u}_k e^{ikx}\n$$\n因此，该偏微分方程转换为每个傅里葉模式系数 $\\hat{u}_k(t)$ 的一组解耦的常微分方程（ODE）：\n$$\n\\frac{d\\hat{u}_k(t)}{dt} = - \\nu_p |k|^{2p} \\hat{u}_k(t)\n$$\n这个常微分方程有一个精确的解析解：\n$$\n\\hat{u}_k(t) = \\hat{u}_k(0) \\exp\\left(-\\nu_p |k|^{2p} t\\right)\n$$\n其中 $\\hat{u}_k(0)$ 是初始条件 $u(x,0)$ 的傅里葉系数。这个在傅里葉空间中的精确解构成了我们数值时间步进算法的基础。\n\n将场 $u(x,0)$ 演化到 $u(x,t)$ 的算法流程如下：\n\n1.  **离散化与初始条件**：将连续域 $[0, 2\\pi)$ 离散化为一个由 $N$ 个点组成的均匀网格 $\\{x_j = j \\Delta x\\}_{j=0}^{N-1}$，其中网格间距为 $\\Delta x = 2\\pi/N$。在这些网格点上评估初始条件（指定的阶跃函数或常数场），以产生离散的初始场 $u(x_j, 0)$。\n\n2.  **正向傅里葉变换**：使用快速傅里葉变换（FFT）将离散初始场 $u(x_j, 0)$ 转换到傅里葉空间，得到离散的傅里葉系数 $\\hat{u}_k(0)$。\n\n3.  **波数数组生成**：必须生成一个相应的整数波数 $k$ 的数组。对于长度为 $2\\pi$ 的域上大小为 $N$ 的离散网格，与标准 FFT 输出顺序相对应的波数由 $k \\in \\{0, 1, \\dots, \\frac{N}{2}-1, -\\frac{N}{2}, \\dots, -1\\}$ 给出（对于偶数 $N$）。\n\n4.  **傅里葉空间中的时间演化**：通过将每个初始系数 $\\hat{u}_k(0)$ 乘以其对应的精确衰减因子 $\\exp(-\\nu_p |k|^{2p} t)$，来计算傅里葉空间中在时间 $t$ 的解 $\\hat{u}_k(t)$。$k=0$ 模式对应于场的空间平均值；由于 $|0|^{2p}=0$，该模式不衰减，这正确地反映了算子保持平均值守恒的性质。\n\n5.  **逆傅里葉变换**：通过对演化后的系数 $\\hat{u}_k(t)$ 应用逆 FFT（IFFT），恢复实空间中在时间 $t$ 的场 $u(x_j, t)$。由于浮点不精确性，IFFT 的结果可能会有一个小的、伪 spurious 的虚部，必须将其舍弃。\n\n遵循此演化过程，我们按规定实现三个验证测试。\n\n**测试1：阶跃函数扩散的边界保持性**\n初始条件是值被限制在 $[0,1]$ 内的阶跃函数 $u_0(x)$。超扩散方程满足极值原理，这意味着它不应产生新的极值。因此，解 $u(x,t)$ 应保持在初始边界 $[0,1]$ 内。数值测试通过检查是否满足 $\\min_x u(x,t) \\ge -\\epsilon$ 和 $\\max_x u(x,t) \\le 1 + \\epsilon$（其中 $\\epsilon$ 是一个小容差）来验证此属性。潜在的过冲或下冲（类吉布斯现象）将表明数值方案未能遵守这一物理原则。\n\n**测试2：能量单调性**\n当 $\\nu_p  0$ 和 $p \\ge 1$ 时，算子 $-\\nu_p(-\\nabla^2)^p$ 是耗散的。这意味着系统的总“能量”，定义为 $E(t) = \\frac{1}{2} \\int_0^{2\\pi} u(x,t)^2 dx$，必须是时间的非增函数，即 $dE/dt \\le 0$。能量的离散对应项是 $E(t) = \\frac{1}{2} \\sum_{j=0}^{N-1} u(x_j,t)^2 \\Delta x$。该测试通过确认 $E(t) \\le E(0) + \\epsilon$ 来验证能量单调性，其中容差 $\\epsilon$ 考虑了潜在的浮点算术误差。违反这一性质将表明存在严重缺陷，例如不稳定的实现。\n\n**测试3：常数场不变性**\n空间常数场 $u(x,t)=c$ 的梯度为零，$\\nabla u = 0$。因此，$\\nabla^2 u = 0$ 且 $(-\\nabla^2)^p u = 0$。于是，时间导数 $\\partial_t u$ 为零，一个常数初始条件必须在所有时间保持不变。在傅里葉空间中，常数场对应于一个非零的 $k=0$ 模式和所有其他模式为零。由于 $k=0$ 的衰减因子为 1，这种不变性被自然地捕捉到。该测试通过检查演化后的场与初始常数之间的最大偏差 $\\max_x |u(x,t) - c|$ 是否保持在严格的容差 $\\epsilon$ 以下，来进行数值验证。这是对代码正确性的一个关键健全性检查，特别是对 $k=0$ 模式的处理。\n\n这套测试为所实现的超粘性方程谱方法求解器提供了全面的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef evolve_field(u0: np.ndarray, p: int, nu_p: float, t: float) - np.ndarray:\n    \"\"\"\n    Evolves a 1D field u(x,0) to u(x,t) using a spectral method for the\n    hyperviscous PDE: ∂_t u = -ν_p * (-∇²)^p u.\n\n    Args:\n        u0: Discrete initial field u(x,0) on a grid of N points.\n        p: Hyperviscosity order.\n        nu_p: Hyperviscosity coefficient.\n        t: Evolution time.\n\n    Returns:\n        The discrete field u(x,t).\n    \"\"\"\n    N = len(u0)\n    \n    # 1. Get wavenumbers k, consistent with domain [0, 2π).\n    # np.fft.fftfreq(N, d=dx) gives frequencies in cycles/unit_length.\n    # Wavenumber k = 2π * frequency.\n    # With dx = 2π/N, k = 2π * np.fft.fftfreq(N, d=2π/N) = N * np.fft.fftfreq(N).\n    # This results in integer wavenumbers [0, 1, ..., N/2-1, -N/2, ..., -1].\n    k = np.fft.fftfreq(N) * N\n\n    # 2. Forward FFT to get initial condition in Fourier space.\n    u0_hat = np.fft.fft(u0)\n\n    # 3. Compute the exact decay factor for each mode.\n    # The term is |k|^(2p), so we take the absolute value of k.\n    decay_factor = np.exp(-nu_p * (np.abs(k)**(2 * p)) * t)\n\n    # 4. Evolve the field in Fourier space.\n    ut_hat = u0_hat * decay_factor\n\n    # 5. Inverse FFT to get the field back in real space.\n    ut = np.fft.ifft(ut_hat)\n\n    # The result should be real; take the real part to discard numerical noise.\n    return ut.real\n\ndef test_bound_respecting(ut: np.ndarray, epsilon: float) - bool:\n    \"\"\"\n    Test 1: Verifies that the solution for a step function from 0 to 1\n    remains within the physical bounds [-ε, 1+ε].\n    \"\"\"\n    min_u = np.min(ut)\n    max_u = np.max(ut)\n    return min_u = -epsilon and max_u = 1.0 + epsilon\n\ndef test_energy_monotonicity(ut: np.ndarray, u0: np.ndarray, delta_x: float, epsilon: float) - bool:\n    \"\"\"\n    Test 2: Verifies that the discrete energy E(t) is less than or\n    equal to the initial energy E(0) within a tolerance.\n    \"\"\"\n    energy_t = 0.5 * np.sum(ut**2) * delta_x\n    energy_0 = 0.5 * np.sum(u0**2) * delta_x\n    return energy_t = energy_0 + epsilon\n\ndef test_constant_invariance(ut: np.ndarray, c: float, epsilon: float) - bool:\n    \"\"\"\n    Test 3: Verifies that a constant initial condition remains constant\n    within a tolerance.\n    \"\"\"\n    max_deviation = np.max(np.abs(ut - c))\n    return max_deviation = epsilon\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path step bounds)\n        {'type': 'bounds', 'params': (1024, 4, 1.0, 10.0, 1e-6)},\n        # Case 2 (edge case coarse grid step bounds)\n        {'type': 'bounds', 'params': (256, 8, 1.0, 10.0, 1e-6)},\n        # Case 3 (boundary condition constant invariance)\n        {'type': 'invariance', 'params': (256, 6, 0.3, 3.0, 1e-12, 0.3)},\n        # Case 4 (energy monotonicity)\n        {'type': 'energy', 'params': (512, 1, 0.8, 1.2, 1e-12)},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        test_type = case['type']\n        \n        if test_type == 'bounds':\n            N, p, nu_p, t, epsilon = case['params']\n            x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n            u0 = np.zeros(N)\n            u0[x = np.pi] = 1.0\n            \n            ut = evolve_field(u0, p, nu_p, t)\n            result = test_bound_respecting(ut, epsilon)\n            results.append(result)\n            \n        elif test_type == 'invariance':\n            N, p, nu_p, t, epsilon, c = case['params']\n            u0 = np.full(N, c)\n            \n            ut = evolve_field(u0, p, nu_p, t)\n            result = test_constant_invariance(ut, c, epsilon)\n            results.append(result)\n            \n        elif test_type == 'energy':\n            N, p, nu_p, t, epsilon = case['params']\n            delta_x = 2 * np.pi / N\n            x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n            u0 = np.zeros(N)\n            u0[x = np.pi] = 1.0\n            \n            ut = evolve_field(u0, p, nu_p, t)\n            result = test_energy_monotonicity(ut, u0, delta_x, epsilon)\n            results.append(result)\n\n    # Format the final output string exactly as required.\n    # Python's `str(bool_value)` produces 'True' or 'False'.\n    output_str = '[' + ','.join(str(r) for r in results) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}