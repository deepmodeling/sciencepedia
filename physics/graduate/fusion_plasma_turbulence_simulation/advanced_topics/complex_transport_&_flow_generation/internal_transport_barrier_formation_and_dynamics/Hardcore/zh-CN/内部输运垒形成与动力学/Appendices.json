{
    "hands_on_practices": [
        {
            "introduction": "要理解并控制内部输运垒，我们首先需要能够从等离子体剖面数据中识别并量化它们。本实践基于一个简化的一维模型，介绍了一套必要的诊断工具。通过实现这些替代性测量方法，您将学习如何确定内部输运垒的存在、宽度和强度，为分析更复杂的模拟和实验数据提供一个定量的基础 。",
            "id": "4192935",
            "problem": "您的任务是为一个简化的、自洽的、一维的、径向局域模型设计内部输运垒 (ITB) 动力学的诊断和代理度量，该模型适用于聚变等离子体湍流模拟。目标是实现一个程序，使用一组最少的、有物理动机且被广泛接受的关系式，来评估是否存在ITB、其位置、强度以及湍流热通量被抑制了多少。所有量均为无量纲。不出现角度。输出中不需要物理单位。\n\n基本基础和假设：\n- 考虑一个托卡马克等离子体，其归一化小半径坐标为 $\\rho \\in [0,1]$。设 $N_\\rho$ 为网格点数，$\\rho$ 在此区间内均匀采样。\n- 离子温度剖面模型为 $T(\\rho) = T_c \\left(1 - \\rho^\\alpha\\right)$，其中 $T_c = 1$ 且 $\\alpha > 0$。此形式能够捕捉朝向边界梯度增大的特性，同时在中心保持有限值。\n- 湍流扩散热通量闭合遵循能量平衡和 Fick 定律：$Q_r(\\rho) \\propto - \\chi(\\rho) \\, \\partial_\\rho T(\\rho)$，其中 $\\chi(\\rho)$ 是湍流扩散系数代理。\n- 类离子温度梯度(ITG)模的线性驱动由一个局域增长率 $\\gamma_{\\mathrm{lin}}(\\rho)$ 建模，该增长率依赖于归一化梯度度量 $R/L_T$。定义 $R/L_T(\\rho) = \\kappa_R \\left| \\partial_\\rho \\ln T(\\rho) \\right|$，其中 $\\kappa_R$ 为正常数，$(R/L_T)_{\\mathrm{crit}}$ 为临界阈值。局域线性增长率为\n$$\n\\gamma_{\\mathrm{lin}}(\\rho) = \\gamma_0 \\, \\max\\!\\left( R/L_T(\\rho) - (R/L_T)_{\\mathrm{crit}}, \\, 0 \\right),\n$$\n其中 $\\gamma_0 > 0$。\n- 背景 $\\mathbf{E}\\times\\mathbf{B}$ 剪切率被建模为一个局域高斯函数，\n$$\n\\gamma_E(\\rho) = \\gamma_{E0} \\exp\\!\\left( -\\frac{(\\rho - \\rho_0)^2}{2\\sigma^2} \\right),\n$$\n其振幅 $\\gamma_{E0} > 0$，中心 $\\rho_0 \\in [0,1]$，宽度 $\\sigma > 0$。\n- 一个受准线性混合长度启发的代理模型假设剪切以加和的方式降低有效增长率。定义有剪切和无剪切时的湍流扩散系数为\n$$\n\\chi_{\\mathrm{turb}}(\\rho) = \\chi_0 \\, \\max\\!\\left( \\gamma_{\\mathrm{lin}}(\\rho) - \\gamma_E(\\rho), \\, 0 \\right), \\quad\n\\chi_{\\mathrm{free}}(\\rho) = \\chi_0 \\, \\gamma_{\\mathrm{lin}}(\\rho),\n$$\n其中 $\\chi_0 > 0$。这体现了湍流（以及 $\\chi$）与被剪切所降低的有效退相关率成比例的原理。\n- 定义局域抑制比\n$$\nr(\\rho) = \n\\begin{cases}\n\\dfrac{\\chi_{\\mathrm{turb}}(\\rho)}{\\chi_{\\mathrm{free}}(\\rho)},  \\gamma_{\\mathrm{lin}}(\\rho) > 0, \\\\\n1,  \\gamma_{\\mathrm{lin}}(\\rho) = 0,\n\\end{cases}\n$$\n因此，当 $\\gamma_{\\mathrm{lin}}(\\rho) > 0$ 时，$r(\\rho) \\in [0,1]$。\n\n需要计算的诊断和代理度量：\n1. 垒的存在性与宽度：\n   - 选择一个阈值 $\\theta_B \\in (0,1)$ 和一个最小宽度 $w_{\\min} \\in (0,1)$。将局域垒条件定义为 $r(\\rho) \\le \\theta_B$ 且 $\\gamma_{\\mathrm{lin}}(\\rho) > 0$。\n   - 找出包含 $\\rho_*$（$\\rho_*$ 是最接近 $\\rho_0$ 的网格点）的连续径向区间，在该区间上局域垒条件成立。设其宽度为 $w_B$（该区间的 $\\rho$ 坐标长度）。如果局域垒条件在 $\\rho_*$ 处不满足，则 $w_B = 0$。\n   - 定义一个布尔诊断量 $\\mathrm{barrier\\_detected}$，如果 $w_B \\ge w_{\\min}$ 则为真，否则为假。\n2. 垒强度指数 (SBI)：\n   - 定义代理指数\n   $$\n   \\mathrm{SBI} = \\max_{\\rho \\in [0,1]} \\left[ \\left(1 - r(\\rho)\\right) \\, \\mathbf{1}_{\\{\\gamma_{\\mathrm{lin}}(\\rho) > 0\\}} \\right],\n   $$\n   其中 $\\mathbf{1}$ 是指示函数。因此 $\\mathrm{SBI} \\in [0,1]$，值越大表示局域抑制越强。\n3. 全局湍流热通量缩减因子：\n   - 使用 $Q_r(\\rho) \\propto -\\chi(\\rho)\\,\\partial_\\rho T(\\rho)$，定义自由和剪切情况下的积分幅值\n   $$\n   I_{\\mathrm{free}} = \\int_0^1 \\left| \\partial_\\rho T(\\rho) \\right| \\, \\chi_{\\mathrm{free}}(\\rho) \\, d\\rho, \\qquad\n   I_{\\mathrm{shear}} = \\int_0^1 \\left| \\partial_\\rho T(\\rho) \\right| \\, \\chi_{\\mathrm{turb}}(\\rho) \\, d\\rho.\n   $$\n   - 定义通量缩减因子\n   $$\n   F_{\\mathrm{red}} = \n   \\begin{cases}\n   \\dfrac{I_{\\mathrm{shear}}}{I_{\\mathrm{free}}},  I_{\\mathrm{free}} > \\varepsilon, \\\\\n   1,  I_{\\mathrm{free}} \\le \\varepsilon,\n   \\end{cases}\n   $$\n   其中有一个小的正则化常数 $\\varepsilon = 10^{-12}$。\n\n数值规格：\n- 在 $\\rho \\in [0,1]$ 上使用包含 $N_\\rho = 1001$ 个点的均匀网格。\n- 在均匀网格上，使用一致的中心有限差分格式数值计算 $\\partial_\\rho T(\\rho)$。\n- 在计算 $\\partial_\\rho \\ln T(\\rho)$ 时，使用 $T$ 的数值导数，并为 $T$ 设置一个保持正性的下限值，即 $T(\\rho) \\leftarrow \\max(T(\\rho), T_{\\min})$，其中 $T_{\\min} = 10^{-12}$，以避免除以零并确保在边界处的稳定性。\n\n测试套件：\n对于每个测试用例，您将获得参数元组 $(\\alpha, \\gamma_0, \\kappa_R, (R/L_T)_{\\mathrm{crit}}, \\gamma_{E0}, \\rho_0, \\sigma, \\chi_0, \\theta_B, w_{\\min})$。使用以下四个测试用例：\n\n- 用例 A (理想情况): $(\\alpha, \\gamma_0, \\kappa_R, (R/L_T)_{\\mathrm{crit}}, \\gamma_{E0}, \\rho_0, \\sigma, \\chi_0, \\theta_B, w_{\\min}) = (3.0, 1.0, 3.0, 4.0, 3.0, 0.7, 0.08, 1.0, 0.3, 0.10)$。\n- 用例 B (接近阈值，无垒): $(3.0, 1.0, 3.0, 4.0, 1.8, 0.7, 0.08, 1.0, 0.3, 0.10)$。\n- 用例 C (强而窄的垒): $(3.0, 1.0, 3.0, 4.0, 7.0, 0.7, 0.05, 1.0, 0.3, 0.05)$。\n- 用例 D (因高阈值而无驱动): $(0.5, 1.0, 3.0, 20.0, 5.0, 0.7, 0.08, 1.0, 0.3, 0.10)$。\n\n要求的程序输出：\n- 对于每个测试用例，计算：\n  - $\\mathrm{barrier\\_detected}$，作为一个布尔值。\n  - $w_B$，作为一个浮点数。\n  - $\\mathrm{SBI}$，作为一个浮点数。\n  - $F_{\\mathrm{red}}$，作为一个浮点数。\n- 将所有四个用例的结果汇总到一个列表中，其中每个元素是对应一个用例的列表 $[\\mathrm{barrier\\_detected}, w_B, \\mathrm{SBI}, F_{\\mathrm{red}}]$，顺序为 A、B、C、D。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[[True,0.12,0.84,0.41],[False,0.0,0.31,0.77],...]\"）。不要包含任何其他文本。\n\n交付内容：\n- 在一个单一、可运行的程序中实现上述完整逻辑，该程序无需用户输入，且仅使用指定的库。确保按规定实现数值稳定性。最终输出格式必须与描述完全一致。",
            "solution": "该问题在科学和数学上是适定的，它完整描述了一个用于模拟聚变等离子体中内部输运垒 (ITB) 动力学的简化模型。所有必需的参数、方程和数值规格均已提供。该问题基于已确立的等离子体物理概念，例如离子温度梯度 (ITG) 驱动的湍流及其被 $\\mathbf{E}\\times\\mathbf{B}$ 速度剪切所抑制的现象。待计算的诊断量是垒属性的基于物理的代理。该问题是客观的、可形式化的，并且在计算上是可解的。因此，我们着手解决。\n\n解决方案的实现首先是对径向域进行离散化，然后对每组参数在该网格上计算所有物理量。核心逻辑被封装在一个函数中，该函数一次处理一个测试用例。\n\n**步骤1：网格和剖面生成**\n\n首先，我们建立一维归一化径向网格 $\\rho$。它是在区间 $[0, 1]$ 上具有 $N_\\rho = 1001$ 个点的均匀网格。网格间距为 $\\Delta\\rho = 1 / (N_\\rho - 1)$。\n离子温度剖面 $T(\\rho)$ 由下式给出：\n$$T(\\rho) = T_c \\left(1 - \\rho^\\alpha\\right)$$\n其中 $T_c=1$。为了在计算对数导数时保持数值稳定性，温度被设定一个最小值下限 $T_{\\min} = 10^{-12}$：\n$$T_{\\mathrm{stable}}(\\rho) = \\max(T(\\rho), T_{\\min})$$\n\n**步骤2：梯度和增长率计算**\n\n温度梯度 $\\partial_\\rho T(\\rho)$ 使用二阶精确的中心有限差分方法对内部点进行数值计算，并在边界处使用二阶单边差分。`numpy.gradient` 可以方便地处理此问题。\n\n归一化的逆温度梯度标长 $R/L_T$ 是驱动湍流的关键参数。其定义为：\n$$R/L_T(\\rho) = \\kappa_R \\left| \\partial_\\rho \\ln T(\\rho) \\right| = \\kappa_R \\left| \\frac{1}{T_{\\mathrm{stable}}(\\rho)} \\frac{\\partial T(\\rho)}{\\partial \\rho} \\right|$$\nITG模的线性增长率 $\\gamma_{\\mathrm{lin}}(\\rho)$ 是用一个临界梯度阈值 $(R/L_T)_{\\mathrm{crit}}$ 建模的。只有当超过此阈值时，湍流才会被激发：\n$$\\gamma_{\\mathrm{lin}}(\\rho) = \\gamma_0 \\, \\max\\!\\left( R/L_T(\\rho) - (R/L_T)_{\\mathrm{crit}}, \\, 0 \\right)$$\n\n**步骤3：剪切率和扩散系数计算**\n\n用于抑制湍流的背景 $\\mathbf{E}\\times\\mathbf{B}$ 剪切率被建模为一个局域高斯剖面：\n$$\\gamma_E(\\rho) = \\gamma_{E0} \\exp\\!\\left( -\\frac{(\\rho - \\rho_0)^2}{2\\sigma^2} \\right)$$\n湍流热扩散系数采用准线性混合长度法则建模，其中剪切率以加和方式减小有效增长率。存在剪切时的扩散系数 $\\chi_{\\mathrm{turb}}(\\rho)$ 和无剪切时的“自由流动”扩散系数 $\\chi_{\\mathrm{free}}(\\rho)$ 由下式给出：\n$$\\chi_{\\mathrm{turb}}(\\rho) = \\chi_0 \\, \\max\\!\\left( \\gamma_{\\mathrm{lin}}(\\rho) - \\gamma_E(\\rho), \\, 0 \\right)$$\n$$\\chi_{\\mathrm{free}}(\\rho) = \\chi_0 \\, \\gamma_{\\mathrm{lin}}(\\rho)$$\n局域抑制比 $r(\\rho)$ 量化了由剪切引起的扩散系数减小程度：\n$$\nr(\\rho) = \n\\begin{cases}\n\\dfrac{\\chi_{\\mathrm{turb}}(\\rho)}{\\chi_{\\mathrm{free}}(\\rho)},  \\gamma_{\\mathrm{lin}}(\\rho) > 0 \\\\\n1,  \\text{其他情况}\n\\end{cases}\n=\n\\begin{cases}\n\\dfrac{\\max(\\gamma_{\\mathrm{lin}}(\\rho) - \\gamma_E(\\rho), 0)}{\\gamma_{\\mathrm{lin}}(\\rho)},  \\gamma_{\\mathrm{lin}}(\\rho) > 0 \\\\\n1,  \\text{其他情况}\n\\end{cases}\n$$\n为避免除以零，该比率的实现需要特别小心。\n\n**步骤4：诊断量计算**\n\n在计算完所有剖面后，我们计算所需的诊断量。\n\n1.  **垒的存在性与宽度 ($w_B$, $\\mathrm{barrier\\_detected}$)**\n    输运垒的局域条件被定义为在湍流本应存在的区域（$\\gamma_{\\mathrm{lin}}(\\rho) > 0$）内存在显著的湍流抑制（$r(\\rho) \\le \\theta_B$）。\n    我们首先确定最接近剪切中心 $\\rho_0$ 的网格点索引 $\\rho_*$。如果该点不满足垒条件，则垒宽 $w_B$ 为 $0$。否则，我们从 $\\rho_*$ 向外搜索，找到满足该条件的最大连续区域。该区域的宽度 $w_B$ 是其径向范围，计算为 $(\\text{结束索引} - \\text{起始索引}) \\times \\Delta\\rho$。如果垒的宽度达到最小阈值，则认为“检测到”垒：$\\mathrm{barrier\\_detected} = (w_B \\ge w_{\\min})$。\n\n2.  **垒强度指数 (SBI)**\n    SBI 是衡量等离子体中任何位置所能达到的最大局域抑制程度的全局度量。其定义为：\n    $$\\mathrm{SBI} = \\max_{\\rho \\in [0,1]} \\left[ \\left(1 - r(\\rho)\\right) \\, \\mathbf{1}_{\\{\\gamma_{\\mathrm{lin}}(\\rho) > 0\\}} \\right]$$\n    其中 $\\mathbf{1}_{\\{\\dots\\}}$ 是指示函数。这是通过在所有 $\\gamma_{\\mathrm{lin}}(\\rho) > 0$ 的网格点上找到 $(1 - r(\\rho))$ 的最大值来计算的。如果该条件从未满足，则该值集合为空或全为零，导致 $\\mathrm{SBI}=0$。\n\n3.  **全局湍流热通量缩减因子 ($F_{\\mathrm{red}}$)**\n    该因子比较有剪切抑制和无剪切抑制情况下的总湍流热输运。积分通量幅值为：\n    $$I_{\\mathrm{free}} = \\int_0^1 \\left| \\partial_\\rho T(\\rho) \\right| \\, \\chi_{\\mathrm{free}}(\\rho) \\, d\\rho$$\n    $$I_{\\mathrm{shear}} = \\int_0^1 \\left| \\partial_\\rho T(\\rho) \\right| \\, \\chi_{\\mathrm{turb}}(\\rho) \\, d\\rho$$\n    这些积分使用梯形法则进行数值计算。缩减因子是它们的比值：\n    $$\n    F_{\\mathrm{red}} = \n    \\begin{cases}\n    \\dfrac{I_{\\mathrm{shear}}}{I_{\\mathrm{free}}},  I_{\\mathrm{free}} > \\varepsilon \\\\\n    1,  I_{\\mathrm{free}} \\le \\varepsilon\n    \\end{cases}\n    $$\n    小常数 $\\varepsilon = 10^{-12}$ 对没有潜在湍流驱动（此时 $I_{\\mathrm{free}}$ 将为零）的情况进行正则化处理。\n\n上述过程将应用于提供的四个测试用例，并将结果汇总成指定的输出格式。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_diagnostics(params):\n    \"\"\"\n    Calculates ITB diagnostics for a given set of model parameters.\n    \"\"\"\n    alpha, gamma_0, kappa_R, R_L_T_crit, gamma_E0, rho_0, sigma, chi_0, theta_B, w_min = params\n    \n    # Numerical and physical constants\n    N_rho = 1001\n    T_min = 1e-12\n    epsilon = 1e-12\n\n    # Step 1: Grid and Profile Generation\n    rho = np.linspace(0, 1, N_rho)\n    delta_rho = rho[1] - rho[0]\n    \n    # Temperature profile (T_c=1)\n    T = 1.0 - rho**alpha\n    T_stable = np.maximum(T, T_min)\n\n    # Step 2: Gradient and Growth Rate Calculation\n    # Numerical derivative of T\n    dT_drho = np.gradient(T, delta_rho)\n    \n    # Logarithmic derivative\n    dlnT_drho = dT_drho / T_stable\n    \n    # Normalized gradient measure\n    R_L_T = kappa_R * np.abs(dlnT_drho)\n    \n    # Linear growth rate\n    gamma_lin = gamma_0 * np.maximum(R_L_T - R_L_T_crit, 0)\n    \n    # Step 3: Shear Rate and Diffusivity Calculation\n    # E-cross-B shearing rate\n    gamma_E = gamma_E0 * np.exp(-(rho - rho_0)**2 / (2 * sigma**2))\n    \n    # Turbulent diffusivities\n    chi_free = chi_0 * gamma_lin\n    chi_turb = chi_0 * np.maximum(gamma_lin - gamma_E, 0)\n    \n    # Local suppression ratio\n    r = np.ones_like(rho)\n    driven_turbulence_mask = gamma_lin > 0\n    # The division is safe because of the mask\n    r[driven_turbulence_mask] = chi_turb[driven_turbulence_mask] / chi_free[driven_turbulence_mask]\n\n    # Step 4: Diagnostic Computation\n    \n    # 1. Barrier Presence and Width\n    local_barrier_condition = (r = theta_B)  driven_turbulence_mask\n    rho_star_idx = np.argmin(np.abs(rho - rho_0))\n    \n    w_B = 0.0\n    if local_barrier_condition[rho_star_idx]:\n        left_idx = rho_star_idx\n        while left_idx > 0 and local_barrier_condition[left_idx - 1]:\n            left_idx -= 1\n        \n        right_idx = rho_star_idx\n        while right_idx  N_rho - 1 and local_barrier_condition[right_idx + 1]:\n            right_idx += 1\n        \n        w_B = (right_idx - left_idx) * delta_rho\n\n    barrier_detected = w_B >= w_min\n\n    # 2. Barrier Strength Index\n    sbi = 0.0\n    if np.any(driven_turbulence_mask):\n        sbi = np.max((1 - r[driven_turbulence_mask]))\n        # Correctly handles the case where gamma_lin > 0 but r=1 everywhere\n        # An alternative calculation that is more robust:\n        sbi_values = (1 - r) * driven_turbulence_mask\n        sbi = np.max(sbi_values)\n\n    # 3. Global Turbulent Heat Flux Reduction Factor\n    integrand_free = np.abs(dT_drho) * chi_free\n    integrand_shear = np.abs(dT_drho) * chi_turb\n    \n    I_free = np.trapz(integrand_free, dx=delta_rho)\n    I_shear = np.trapz(integrand_shear, dx=delta_rho)\n    \n    if I_free > epsilon:\n        F_red = I_shear / I_free\n    else:\n        F_red = 1.0\n\n    return [barrier_detected, w_B, sbi, F_red]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test cases: (alpha, gamma_0, kappa_R, (R/L_T)_crit, gamma_E0, rho_0, sigma, chi_0, theta_B, w_min)\n    test_cases = [\n        # Case A (happy path)\n        (3.0, 1.0, 3.0, 4.0, 3.0, 0.7, 0.08, 1.0, 0.3, 0.10),\n        # Case B (near-threshold, no barrier)\n        (3.0, 1.0, 3.0, 4.0, 1.8, 0.7, 0.08, 1.0, 0.3, 0.10),\n        # Case C (strong, narrow barrier)\n        (3.0, 1.0, 3.0, 4.0, 7.0, 0.7, 0.05, 1.0, 0.3, 0.05),\n        # Case D (no drive, by high threshold)\n        (0.5, 1.0, 3.0, 20.0, 5.0, 0.7, 0.08, 1.0, 0.3, 0.10),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_diagnostics(case)\n        results.append(result)\n    \n    # Format the final output string\n    # Convert Python bools to lowercase 'true'/'false' as per example if necessary,\n    # but standard `str` conversion is 'True'/'False' which is fine.\n    # The example [[True,...],[False,...]] shows standard Python string representation.\n    def format_list(lst):\n        # Convert each item in the inner list to its string representation\n        return '[' + ','.join(map(str, lst)) + ']'\n    \n    output_str = '[' + ','.join(map(format_list, results)) + ']'\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "内部输运垒的形成并非一个简单的“开”或“关”的状态，而是一个由湍流驱动及其抑制之间复杂的非线性相互作用所控制的动态过程。本练习使用一个简化的“捕食者-被捕食者”模型深入探讨了这些动力学，其中温度梯度（“被捕食者”）与湍流（“捕食者”）相互作用。通过在不同加热情景下模拟该模型，您将发现内部输运垒如何形成稳定状态、坍塌或进入持续振荡，从而揭示这些基本反馈回路中出现的丰富行为 。",
            "id": "4056842",
            "problem": "您的任务是实现并分析一个简化的、无量纲的内部输运垒（ITB）模型，该模型捕捉了在局域加热下，归一化温度梯度与湍流强度之间的相互作用。目标是针对加热的局域化和强度进行参数扫描，模拟模型的动态行为，并将结果模式分类为垒形成、坍塌或振荡。您的程序必须是一个完整的、可运行的程序，能够生成指定的输出格式，而无需任何用户输入。\n\n请从以下适用于计算聚变科学与工程的基本原理出发：\n\n- 能量平衡与输运：由 $g(t)$ 表示的归一化温度梯度在加热、线性弛豫和湍流驱动的输运作用下演化。由 $w(t)$ 表示的湍流强度由梯度驱动的不稳定性所驱动，并受到 E 叉 B（E×B）剪切的抑制。\n- 湍流驱动与剪切抑制：湍流增长率通过一个饱和非线性形式依赖于 $g(t)$，而 E×B 剪切去相关率与局域梯度的平方成正比。\n\n您将为一个固定的归一化小半径 $r_b = 0.6$（无量纲）处的单个代表性磁通面实现一个双方程简化模型，该位置代表了输运垒的位置。其控制常微分方程（ODEs）为：\n$$\n\\frac{dg}{dt} = Q \\, L(r_0,\\sigma) - C_g \\, g - \\alpha \\, w \\, g,\n$$\n$$\n\\frac{dw}{dt} = \\beta \\, \\frac{g^2}{1 + s \\, g^2} - C_w \\, w - S_{\\text{shear}} \\, g^2 \\, w,\n$$\n其中 $Q$ 是加热强度，$r_0$ 是加热局域化半径，$\\sigma$ 是加热宽度。局域化因子 $L(r_0,\\sigma)$ 是一个高斯函数：\n$$\nL(r_0,\\sigma) = \\exp\\left(-\\frac{(r_b - r_0)^2}{2 \\sigma^2}\\right).\n$$\n所有量均为无量纲。\n\n使用以下固定的模型参数，这些参数在简化模型中被选择为物理上合理且自洽的：\n- $C_g = 0.3$,\n- $\\alpha = 0.9$,\n- $\\beta = 1.5$,\n- $s = 0.5$,\n- $C_w = 0.4$,\n- $S_{\\text{shear}} = 3.0$,\n- $r_b = 0.6$.\n\n使用初始条件 $g(0) = 0.1$ 和 $w(0) = 0.05$，并将常微分方程从 $t = 0$ 积分到 $t = 500$（无量纲时间），使用足够的分辨率来捕捉瞬态和持续动态过程。\n\n必须根据在模拟时间区间的最后 $20\\%$ 计算的以下标准，对数值时间序列进行模式分类：\n- 在时间序列的最后 $20\\%$ 上计算时间平均梯度 $\\overline{g}$ 和时间平均湍流 $\\overline{w}$。\n- 定义阈值：$g_{\\text{high}} = 0.9$，$g_{\\text{low}} = 0.3$，$w_{\\text{low}} = 0.25$。\n- 垒形成（代码 $1$）：如果 $\\overline{g}  g_{\\text{high}}$ 且 $\\overline{w}  w_{\\text{low}}$。\n- 坍塌（代码 $0$）：如果 $\\overline{g}  g_{\\text{low}}$ 且 $\\overline{w}  w_{\\text{low}}$。\n- 振荡（代码 $2$）：如果以上两种情况均不适用，且后半部分时间序列表现出持续振荡，其特征为：检测到 $g(t)$ 至少有 $5$ 个显著的局域极大值，峰峰值振幅大于 $0.3$，并且具有不可忽略的方差（$g(t)$ 在最后 $50\\%$ 的方差超过 $0.01$，$w(t)$ 亦然）。\n- 如果所有条件均不满足，则分类为坍塌（代码 $0$）。\n\n请注意，这个无量纲简化模型中没有物理单位；所有输出都必须是无单位的整数。\n\n您的程序必须为下面测试组中的每个参数集模拟该模型，并为每个案例输出一个分类代码。该测试组涵盖了多种行为，包括高强度局域加热案例、低强度远距离加热案例、易于振荡的近垒中等强度条件以及宽度效应：\n\n测试组的 $(Q, r_0, \\sigma)$ 值：\n- 案例 $1$：$(2.5, 0.6, 0.05)$，\n- 案例 $2$：$(0.3, 0.1, 0.2)$，\n- 案例 $3$：$(1.2, 0.62, 0.08)$，\n- 案例 $4$：$(1.8, 0.9, 0.05)$，\n- 案例 $5$：$(2.0, 0.6, 0.3)$，\n- 案例 $6$：$(1.0, 0.58, 0.05)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试组相同（例如，“[c1,c2,c3,c4,c5,c6]”），其中每个 $c_i$ 是上述定义的案例 $i$ 的整数分类代码。不应打印任何其他文本。",
            "solution": "所提出的问题是计算物理学领域，特别是在聚变能源科学领域，一个有效且适定的练习。它要求对一个耦合的非线性常微分方程（ODE）组进行数值求解，该方程组构成了一个托卡马克等离子体中内部输运垒（ITB）动力学的简化模型。任务是在各种加热情景下模拟该模型，并对产生的等离子体状态进行分类。\n\n问题的核心在于以下这个由两个无量纲常微分方程组成的系统，它描述了在特定径向位置 $r_b = 0.6$ 处，归一化温度梯度 $g(t)$ 和归一化湍流强度 $w(t)$ 的时间演化：\n$$\n\\frac{dg}{dt} = Q \\, L(r_0,\\sigma) - C_g \\, g - \\alpha \\, w \\, g\n$$\n$$\n\\frac{dw}{dt} = \\beta \\, \\frac{g^2}{1 + s \\, g^2} - C_w \\, w - S_{\\text{shear}} \\, g^2 \\, w\n$$\n该系统是捕食者-猎物模型的经典例子，其中梯度 $g(t)$ 充当“猎物”，而湍流 $w(t)$ 充当“捕食者”。\n\n第一个方程控制温度梯度 $g(t)$。每一项对应一个独特的物理过程：\n- 源项 $Q_h = Q \\, L(r_0,\\sigma)$ 代表施加于等离子体的外部加热。$Q$ 是总加热功率，函数 $L(r_0,\\sigma) = \\exp\\left(-\\frac{(r_b - r_0)^2}{2 \\sigma^2}\\right)$ 模拟了该加热的局域化。接近 $1$ 的 $L$ 值表示加热高度集中在输运垒位置 $r_b$，而接近 $0$ 的值则代表偏轴加热，它不直接在该位置为梯度提供能量。\n- 线性项 $-C_g \\, g$ 代表一个标准的弛豫或阻尼过程，模拟了通过新经典或其他非湍流输运通道的能量损失，其速率与梯度成正比。此处的常数为 $C_g = 0.3$。\n- 非线性项 $-\\alpha \\, w \\, g$ 模拟了热量的湍流输运，这是湍流等离子体中能量损失的主要机制。热通量与湍流强度 $w$ 和梯度 $g$ 的乘积成正比，耦合系数为 $\\alpha = 0.9$。该项显示了湍流如何“捕食”梯度，从而降低梯度。\n\n第二个方程控制湍流强度 $w(t)$：\n- 项 $\\beta \\, \\frac{g^2}{1 + s \\, g^2}$ 代表湍流的驱动。由梯度驱动的不稳定性，如离子温度梯度（ITG）模，是湍流的主要来源。增长率随梯度 $g$ 的增加而增加，但在非常高的梯度下会饱和，这种行为由参数 $\\beta = 1.5$ 和 $s = 0.5$ 的函数形式所捕捉。\n- 线性项 $-C_w \\, w$ 是湍流的一个简单阻尼项，代表耗散湍流能量的机制。常数为 $C_w = 0.4$。\n- 对于 ITB 形成最关键的项是剪切抑制项 $-S_{\\text{shear}} \\, g^2 \\, w$。强温度梯度会产生剪切的E×B等离子体流。这些流会撕裂湍流涡并使其去相关，从而主动抑制湍流。这种抑制是高度非线性的，与 $g^2$ 成正比，并由常数 $S_{\\text{shear}} = 3.0$ 调节。该项代表了“猎物”的防御机制：高梯度可以抑制其自身的“捕食者”。\n\n解决此问题的算法方法包括两个主要阶段：数值积分，然后是用于分类的时间序列分析。\n\n首先，对于每个参数集 $(Q, r_0, \\sigma)$，对常微分方程组进行数值求解。`scipy.integrate.solve_ivp` 函数是完成此任务的合适工具，因为它为初值问题提供了鲁棒且自适应的算法。积分从 $t=0$ 到 $t=500$ 进行，使用指定的初始条件 $g(0) = 0.1$ 和 $w(0) = 0.05$。必须评估足够多的时间点，以解析可能复杂的动态过程，包括快速瞬态和持续振荡。\n\n其次，在获得 $g(t)$ 和 $w(t)$ 的时间序列后，应用分类算法来确定系统的最终状态。分析侧重于模拟的后期部分，以表征其渐近行为，并舍弃初始的瞬态阶段。\n- 使用覆盖模拟时间最后 $20\\%$（从 $t=400$ 到 $t=500$）的分析窗口来计算时间平均梯度 $\\overline{g}$ 和湍流 $\\overline{w}$。\n- 将这些平均值与预定义的阈值进行比较：$g_{\\text{high}} = 0.9$，$g_{\\text{low}} = 0.3$ 和 $w_{\\text{low}} = 0.25$。\n- 如果系统稳定在一种高梯度、低湍流的状态，即 $\\overline{g}  g_{\\text{high}}$ 且 $\\overline{w}  w_{\\text{low}}$，则识别为“垒形成”状态（代码 $1$）。\n- 如果系统处于一种低梯度、低湍流的状态，其中 $\\overline{g}  g_{\\text{low}}$ 且 $\\overline{w}  w_{\\text{low}}$，则识别为“坍塌”状态（代码 $0$）。\n- 如果这些稳态条件均不满足，则检查系统是否存在振荡行为。此检查在模拟的最后 $50\\%$（从 $t=250$ 到 $t=500$）进行。如果以下所有条件都为真，则声明为“振荡”状态（代码 $2$）：\n    1. $g(t)$ 和 $w(t)$ 的方差均不为零（大于 $0.01$），表明存在动态活动。\n    2. $g(t)$ 的时间序列表现出至少 $5$ 个局域极大值，表明是持续的振荡行为，而非简单的过冲。\n    3. $g(t)$ 中振荡的峰峰值振幅是显著的，定义为该窗口内 $g(t)$ 的最大值与最小值之差大于 $0.3$。\n- 如果垒、坍塌或振荡的具体标准均未满足，则该状态默认分类为坍塌（代码 $0$），代表一个通用的低约束模式。\n\n这种系统的模拟和分类程序允许对参数空间进行定量探索，将不同的加热情景映射到独特且具有物理意义的等离子体输运模式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Simulates a reduced internal transport barrier (ITB) model and classifies the\n    resulting regimes for a suite of test cases.\n    \"\"\"\n    \n    # Test suite of (Q, r0, sigma) values\n    test_cases = [\n        (2.5, 0.6, 0.05),  # Case 1\n        (0.3, 0.1, 0.2),   # Case 2\n        (1.2, 0.62, 0.08), # Case 3\n        (1.8, 0.9, 0.05),  # Case 4\n        (2.0, 0.6, 0.3),   # Case 5\n        (1.0, 0.58, 0.05),  # Case 6\n    ]\n\n    results = []\n\n    # Fixed model parameters\n    Cg = 0.3\n    alpha = 0.9\n    beta = 1.5\n    s = 0.5\n    Cw = 0.4\n    S_shear = 3.0\n    rb = 0.6\n\n    # Simulation parameters\n    t_span = [0, 500]\n    t_eval = np.linspace(t_span[0], t_span[1], 10000)\n    initial_conditions = [0.1, 0.05] # [g(0), w(0)]\n\n    for Q, r0, sigma in test_cases:\n        \n        # Calculate the constant heating source term\n        L = np.exp(-((rb - r0)**2) / (2 * sigma**2))\n        Q_h = Q * L\n\n        def itb_model(t, y):\n            \"\"\"Defines the system of ODEs for the ITB model.\"\"\"\n            g, w = y\n            \n            dg_dt = Q_h - Cg * g - alpha * w * g\n            dw_dt = beta * (g**2 / (1 + s * g**2)) - Cw * w - S_shear * g**2 * w\n            \n            return [dg_dt, dw_dt]\n\n        # Numerically integrate the ODEs\n        sol = solve_ivp(\n            itb_model, \n            t_span, \n            initial_conditions,\n            method='RK45', \n            t_eval=t_eval\n        )\n        \n        g_series = sol.y[0]\n        w_series = sol.y[1]\n        \n        # --- Regime Classification ---\n        \n        # Analysis over the last 20% of the time series for steady state\n        last_20_percent_idx = int(len(t_eval) * 0.8)\n        g_last_20 = g_series[last_20_percent_idx:]\n        w_last_20 = w_series[last_20_percent_idx:]\n        \n        g_mean = np.mean(g_last_20)\n        w_mean = np.mean(w_last_20)\n        \n        # Thresholds\n        g_high = 0.9\n        g_low = 0.3\n        w_low = 0.25\n        \n        # Classification logic\n        classification_code = 0 # Default to collapse\n\n        # Check for Barrier formation (code 1)\n        if g_mean > g_high and w_mean  w_low:\n            classification_code = 1\n        # Check for Collapse (code 0)\n        elif g_mean  g_low and w_mean  w_low:\n            classification_code = 0\n        else:\n            # If not a clear steady state, check for Oscillation (code 2)\n            \n            # Analysis over the last 50% of the time series for oscillations\n            last_50_percent_idx = int(len(t_eval) * 0.5)\n            g_last_50 = g_series[last_50_percent_idx:]\n            w_last_50 = w_series[last_50_percent_idx:]\n            \n            # Condition 1: Non-trivial variance\n            g_var_ok = np.var(g_last_50) > 0.01\n            w_var_ok = np.var(w_last_50) > 0.01\n            \n            if g_var_ok and w_var_ok:\n                # Condition 2: At least 5 local maxima in g(t)\n                # A point is a local maximum if it is greater than its neighbors\n                peaks = 0\n                for i in range(1, len(g_last_50) - 1):\n                    if g_last_50[i] > g_last_50[i-1] and g_last_50[i] > g_last_50[i+1]:\n                        peaks += 1\n                \n                num_peaks_ok = (peaks >= 5)\n\n                if num_peaks_ok:\n                    # Condition 3: Significant peak-to-peak amplitude\n                    amplitude = np.max(g_last_50) - np.min(g_last_50)\n                    amplitude_ok = (amplitude > 0.3)\n                    \n                    if amplitude_ok:\n                        classification_code = 2\n                    else: # Not oscillating significantly, default to collapse\n                        classification_code = 0\n                else: # Not enough peaks, default to collapse\n                    classification_code = 0\n            else: # Low variance, default to collapse\n                classification_code = 0\n        \n        results.append(classification_code)\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在局域动力学概念的基础上，这项高级实践将探索等离子体剖面的完整时空演化。您将实现一个一维热输运方程的模拟，该方程包含了剖面“刚性”和剪切抑制等关键物理过程。这将使您能够观察和分析输运“雪崩”——这是湍流等离子体中热量传播方式的基本特征，表现为间歇性的爆发事件——并理解它们是如何受到内部输运垒调控的 。",
            "id": "4192943",
            "problem": "考虑一个磁约束等离子体中内部输运垒动力学的一维、径向局域模型，该模型以无量纲单位表示。设无量纲温度分布为 $T(x,t)$，其中 $x\\in[0,1]$ 表示归一化小半径，$t\\geq 0$ 表示无量纲时间。其动力学由包含扩散输运和源项的局域能量守恒方程决定，具体表示为\n$$\n\\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D(g,x)\\,\\frac{\\partial T}{\\partial x}\\right) + S(x),\n$$\n其中，局域梯度为 $g(x,t) = -\\frac{\\partial T}{\\partial x}$，源项 $S(x)$ 不随时间变化且局域在芯部附近，湍流扩散系数 $D(g,x)$ 具有阈值（剖面刚性）并受剪切抑制，用以模拟雪崩输运和内部输运垒（ITB）的形成。具体来说，\n$$\nD(g,x) = D_{\\mathrm{base}} + \\frac{D_{\\mathrm{aval}}}{1 + \\left(\\frac{\\gamma_E(x)}{\\gamma_0}\\right)^2}\\, H\\!\\left(g - g_c\\right),\n$$\n其中 $D_{\\mathrm{base}}$ 是基线碰撞扩散系数，$D_{\\mathrm{aval}}$ 表征雪崩期间增强的湍流扩散系数，$H(\\cdot)$ 是 Heaviside 函数（当 $z0$ 时 $H(z)=1$，否则 $H(z)=0$），$g_c$ 是临界梯度（刚性阈值），$\\gamma_0$ 是一个参考速率，$\\gamma_E(x)$ 是归一化的 $E\\times B$ 剪切剖面，模型为\n$$\n\\gamma_E(x) = G \\exp\\!\\left(-\\frac{(x-x_b)^2}{w^2}\\right),\n$$\n其中 $G$ 是剪切幅度，$x_b$ 是输运垒中心，$w$ 是剪切宽度。\n\n边界条件是混合的：芯部为 Neumann 条件 $\\left.\\frac{\\partial T}{\\partial x}\\right|_{x=0}=0$，边界为 Dirichlet 条件 $T(1,t)=0$。初始条件为\n$$\nT(x,0) = T_0 \\left(1 - x^n\\right).\n$$\n源项剖面为\n$$\nS(x) = P \\exp\\!\\left(-\\frac{x^2}{\\sigma^2}\\right).\n$$\n\n待编写的程序必须在 $x\\in[0,1]$ 区间上含 $N_x$ 个点的均匀网格上，使用带有面通量的显式守恒有限体积或有限差分格式对上述方程进行离散化。令面通量为 $F_{i+\\frac{1}{2}} = - D_{i+\\frac{1}{2}} \\frac{T_{i+1}-T_i}{\\Delta x}$，其中 $D_{i+\\frac{1}{2}}$ 是面上两侧单元中心 $D$ 值的算术平均值，$\\Delta x$ 是均匀的网格间距。内部单元平均温度值的更新应为\n$$\nT_i^{n+1} = T_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right) + \\Delta t\\, S_i,\n$$\n适用于 $i=1,\\dots,N_x-2$，并在 $i=0$ 和 $i=N_x-1$ 处恰当施加边界条件。$D(g,x)$ 中使用的局域梯度 $g_i$ 应在内部区域使用中心差分计算，在区域两端使用单边或边界相容的近似计算（施加 $g_0=0$ 以满足 $x=0$ 处的 Neumann 边界条件）。\n\n定义全局输运爆发指示因子\n$$\nQ(t) = \\int_0^1 D(g,x)\\,\\left(\\frac{\\partial T}{\\partial x}\\right)^2 \\, dx,\n$$\n并在每个时间步 $n$ 使用面贡献将其离散化为 $Q^n \\approx \\sum_{i=0}^{N_x-2} D_{i+\\frac{1}{2}}^n \\left(\\frac{T_{i+1}^n - T_i^n}{\\Delta x}\\right)^2 \\Delta x$。\n\n雪崩事件应通过对 $Q(t)$ 设置阈值来检测：当 $Q(t)$ 在处于或低于 $Q_{\\mathrm{thr}}$ 之后首次满足 $Q(t)  Q_{\\mathrm{thr}}$ 时，事件开始；当 $Q(t)$ 随后满足 $Q(t) \\le Q_{\\mathrm{thr}}$ 时，事件结束。对于每个检测到的事件，记录：\n- 事件前峰值梯度 $g_{\\mathrm{pre}}$，定义为事件开始前一时间步中 $g(x,t)$ 的最大值。\n- 事件后峰值梯度 $g_{\\mathrm{post}}$，定义为事件结束后一时间步中 $g(x,t)$ 的最大值。\n定义事件的弛豫因子为 $R_{\\mathrm{event}} = \\frac{g_{\\mathrm{post}}}{g_{\\mathrm{pre}}}$。程序必须计算雪崩事件的整数数量 $N_{\\mathrm{aval}}$ 和平均弛豫因子 $\\overline{R}$（定义为所有检测到事件的 $R_{\\mathrm{event}}$ 的算术平均值）。如果未检测到雪崩事件，则按约定设置 $\\overline{R}=1.0$。\n\n为量化平静态期间的有效输运垒位置，定义 $Q(t)\\le Q_{\\mathrm{thr}}$ 的时间为平静态时间集合。在每个平静态时间步，计算最大梯度 $g(x,t)$ 所在的位置 $x^*$ 并存储。程序必须计算时间平均的有效输运垒位置 $\\overline{x}_{\\mathrm{bar}}$，作为所存储 $x^*$ 的算术平均值。如果没有平静态时间（例如，对于所有 $t$ 都有 $Q(t)Q_{\\mathrm{thr}}$），则将 $\\overline{x}_{\\mathrm{bar}}$ 设置为最终时刻最大梯度的位置。\n\n所有量均为无量纲。不出现角度。不出现百分比。程序必须为显式格式使用稳定的时间步长 $\\Delta t$；在提供的测试套件中，$\\Delta t$ 的值已选择得足够小。\n\n您的程序必须实现上述算法并为以下测试套件生成结果。每个测试由 $(N_x, \\Delta t, N_t, D_{\\mathrm{base}}, D_{\\mathrm{aval}}, g_c, \\gamma_0, x_b, G, w, P, \\sigma, T_0, n, Q_{\\mathrm{thr}})$ 定义：\n- 测试 $1$：$N_x=128$，$\\Delta t=10^{-4}$，$N_t=4000$，$D_{\\mathrm{base}}=10^{-3}$，$D_{\\mathrm{aval}}=10^{-2}$，$g_c=0.8$，$\\gamma_0=0.1$，$x_b=0.6$，$G=0.6$，$w=0.07$，$P=1.0$，$\\sigma=0.3$，$T_0=1.0$，$n=2$，$Q_{\\mathrm{thr}}=2\\times 10^{-3}$。\n- 测试 $2$：$N_x=128$，$\\Delta t=10^{-4}$，$N_t=4000$，$D_{\\mathrm{base}}=10^{-3}$，$D_{\\mathrm{aval}}=1.5\\times 10^{-2}$，$g_c=0.75$，$\\gamma_0=0.1$，$x_b=0.55$，$G=0.6$，$w=0.06$，$P=2.0$，$\\sigma=0.25$，$T_0=1.0$，$n=2$，$Q_{\\mathrm{thr}}=4\\times 10^{-3}$。\n- 测试 $3$：$N_x=128$，$\\Delta t=10^{-4}$，$N_t=4000$，$D_{\\mathrm{base}}=10^{-3}$，$D_{\\mathrm{aval}}=10^{-2}$，$g_c=0.9$，$\\gamma_0=0.1$，$x_b=0.6$，$G=3.0$，$w=0.05$，$P=0.6$，$\\sigma=0.3$，$T_0=1.0$，$n=2$，$Q_{\\mathrm{thr}}=2\\times 10^{-3}$。\n\n对于每个测试，程序必须按顺序输出以下三个量：整数 $N_{\\mathrm{aval}}$、四舍五入到六位小数的浮点数 $\\overline{R}$，以及四舍五入到六位小数的浮点数 $\\overline{x}_{\\mathrm{bar}}$。将所有测试的结果聚合到形式为 $[r_1,r_2,\\dots,r_9]$ 的单行输出中，其中九个条目完全按此顺序对应于 $N_{\\mathrm{aval}}^{(1)}, \\overline{R}^{(1)}, \\overline{x}_{\\mathrm{bar}}^{(1)}, N_{\\mathrm{aval}}^{(2)}, \\overline{R}^{(2)}, \\overline{x}_{\\mathrm{bar}}^{(2)}, N_{\\mathrm{aval}}^{(3)}, \\overline{R}^{(3)}, \\overline{x}_{\\mathrm{bar}}^{(3)}$，浮点数按规定四舍五入到六位小数。程序必须且只能打印这一行，不能有其他任何内容。",
            "solution": "所呈现的问题是等离子体物理学中一个适定且有科学依据的计算任务，具体是模拟内部输运垒（ITB）的动力学。它要求对一个一维非线性偏微分方程进行数值求解以获得温度演化，并随后对模拟数据进行分析。该问题被验证为是可靠、完整且无歧义的。\n\n无量纲温度分布 $T(x,t)$ 的控制方程是一个反应扩散方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D(g,x)\\,\\frac{\\partial T}{\\partial x}\\right) + S(x)\n$$\n该方程描述了能量守恒，其中温度的变化率由扩散热通量的散度和局域热源 $S(x)$ 决定。该模型的核心在于非线性扩散系数 $D(g,x)$，它依赖于局域温度梯度 $g = -\\partial T/\\partial x$ 和径向位置 $x$。这种依赖性模拟了湍流输运及其抑制之间的复杂相互作用，这也是 ITB 形成的机制。\n\n扩散系数定义为：\n$$\nD(g,x) = D_{\\mathrm{base}} + \\frac{D_{\\mathrm{aval}}}{1 + \\left(\\frac{\\gamma_E(x)}{\\gamma_0}\\right)^2}\\, H\\!\\left(g - g_c\\right)\n$$\n该公式包含三个关键的物理要素：\n1. 基线碰撞输运 $D_{\\mathrm{base}}$。\n2. 湍流的触发阈值。Heaviside 函数 $H(g-g_c)$ 仅在温度梯度 $g$ 超过临界阈值 $g_c$ 时才激活一个强的湍流输运分量 $D_{\\mathrm{aval}}$。这代表了剖面的“刚性”。\n3. 剪切流对湍流的抑制。涉及 $E\\times B$ 剪切剖面 $\\gamma_E(x)$ 的项会减小湍流输运。这种效应局域在 $x=x_b$ 附近，是形成输运垒的主要机制之一。\n\n数值解是使用有限体积法在均匀空间网格上构建的。\n设区域 $x \\in [0, 1]$ 被离散化为 $N_x$ 个点 $x_i = i \\Delta x$，其中 $i=0, 1, \\dots, N_x-1$，网格间距为 $\\Delta x = 1/(N_x-1)$。在网格点 $x_i$ 和时间步 $n$ 的温度记为 $T_i^n$。\n\n时间演化采用显式前向欧拉格式实现。内部单元 $i$（对于 $i=1, \\dots, N_x-2$）的温度更新方程由下式给出：\n$$\nT_i^{n+1} = T_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right) + \\Delta t\\, S_i\n$$\n其中 $F_{i+\\frac{1}{2}}^n$ 是单元 $i$ 和 $i+1$ 之间界面上的数值热通量：\n$$\nF_{i+\\frac{1}{2}}^n = -D_{i+\\frac{1}{2}}^n \\frac{T_{i+1}^n - T_i^n}{\\Delta x}\n$$\n单元界面上的扩散系数 $D_{i+\\frac{1}{2}}^n$ 计算为单元中心扩散系数的算术平均值，$D_{i+\\frac{1}{2}}^n = \\frac{1}{2}(D_i^n + D_{i+1}^n)$。\n\n边界条件处理如下：\n- 在芯部（$x=0$），Neumann 条件 $\\left.\\frac{\\partial T}{\\partial x}\\right|_{x=0}=0$ 意味着热通量为零。因此第一个单元 $T_0$ 的更新为 $T_0^{n+1} = T_0^n - \\frac{\\Delta t}{\\Delta x} F_{\\frac{1}{2}}^n + \\Delta t S_0$。\n- 在边界（$x=1$），通过在所有时间步设置 $T_{N_x-1}^n = 0$ 来施加 Dirichlet 条件 $T(1,t)=0$。\n\n为了评估依赖于状态的扩散系数 $D$，在每个单元中心计算梯度 $g_i^n = -(\\partial T/\\partial x)_i^n$。对内部点使用二阶中心差分，$g_i^n = -(T_{i+1}^n - T_{i-1}^n)/(2\\Delta x)$。在边界处，问题指定使用与 Neumann 条件一致的 $g_0^n=0$，并在右边界使用一阶单边差分，$g_{N_x-1}^n = -(T_{N_x-1}^n - T_{N_x-2}^n)/\\Delta x$。\n\n分析的核心涉及检测输运“雪崩”，即湍流活动的爆发。这些是通过监测全局输运爆发指示因子 $Q(t)$ 来识别的，其离散形式为：\n$$\nQ^n \\approx \\sum_{i=0}^{N_x-2} D_{i+\\frac{1}{2}}^n \\left(\\frac{T_{i+1}^n - T_i^n}{\\Delta x}\\right)^2 \\Delta x\n$$\n当 $Q^n$ 从下方越过阈值 $Q_{\\mathrm{thr}}$ 时，雪崩事件开始；当它再次回落时，事件结束。对于每个事件，我们记录事件前峰值梯度 $g_{\\mathrm{pre}}$（事件开始前一时间步的最大梯度）和事件后峰值梯度 $g_{\\mathrm{post}}$（事件结束后一时间步的最大梯度）。弛豫因子 $R_{\\mathrm{event}} = g_{\\mathrm{post}}/g_{\\mathrm{pre}}$ 衡量了由雪崩引起的剖面弛豫程度。最终输出是雪崩的总数 $N_{\\mathrm{aval}}$ 和它们的平均弛豫因子 $\\overline{R}$。\n\n在平静态期间（$Q^n \\le Q_{\\mathrm{thr}}$），记录最大温度梯度的位置 $x^*$。该位置对应于输运垒的位置。这些位置的时间平均值 $\\overline{x}_{\\mathrm{bar}}$ 提供了有效输运垒位置的度量。\n\n整个算法流程如下：\n1. 初始化网格、参数和温度剖面 $T(x,0)$。\n2. 预计算不随时间变化的剖面 $S(x)$ 和 $\\gamma_E(x)$。\n3. 在 $t=0$ 时，计算初始梯度 $g$、扩散系数 $D$ 和爆发指示因子 $Q$。初始化分析变量。\n4. 循环 $N_t$ 个时间步：\n    a. 存储当前状态（梯度剖面和爆发状态）用于事件检测。\n    b. 计算热通量 $F_{i+\\frac{1}{2}}^n$。\n    c. 使用有限体积格式和边界条件更新温度剖面 $T^n \\to T^{n+1}$。\n    d. 计算新的梯度 $g^{n+1}$、扩散系数 $D^{n+1}$ 和爆发指示因子 $Q^{n+1}$。\n    e. 比较当前和之前的爆发状态以检测雪崩的开始或结束。如果事件开始，存储 $g_{\\mathrm{pre}}$。如果事件结束，计算并存储 $R_{\\mathrm{event}}$ 并将 $N_{\\mathrm{aval}}$ 加一。\n    f. 如果系统处于平静态，记录当前的输运垒位置 $x^*$。\n5. 模拟结束后，根据收集的数据计算最终指标 $\\overline{R}$ 和 $\\overline{x}_{\\mathrm{bar}}$，并应用针对边缘情况（例如，没有雪崩或没有平静态）的指定约定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n    \"\"\"\n    (Nx, dt, Nt, D_base, D_aval, gc, gamma_0, \n     xb, G, w, P, sigma, T0, n_power, Q_thr) = params\n\n    # 1. Discretization and Initialization\n    x = np.linspace(0, 1, Nx)\n    dx = 1.0 / (Nx - 1)\n    \n    # Initial temperature profile\n    T = T0 * (1 - x**n_power)\n    \n    # Fixed profiles\n    S = P * np.exp(-x**2 / sigma**2)\n    gamma_E = G * np.exp(-(x - xb)**2 / w**2)\n    \n    # Analysis variables\n    N_aval = 0\n    R_events = []\n    x_stars = []\n    g_pre_temp = None\n    \n    # --- Initial State (t=0) ---\n    # Compute gradient g\n    g = np.zeros(Nx)\n    g[1:-1] = -(T[2:] - T[:-2]) / (2 * dx)\n    g[0] = 0.0\n    g[-1] = -(T[-1] - T[-2]) / dx\n    \n    # Compute diffusivity D\n    H = (g > gc).astype(float)\n    D_turb = (D_aval / (1 + (gamma_E / gamma_0)**2)) * H\n    D = D_base + D_turb\n    \n    # Compute Q\n    D_face = (D[:-1] + D[1:]) / 2.0\n    grad_T_face = (T[1:] - T[:-1]) / dx\n    Q = np.sum(D_face * grad_T_face**2 * dx)\n    \n    is_bursting = Q > Q_thr\n    \n    if not is_bursting:\n        x_stars.append(x[np.argmax(g)])\n        \n    # --- Main Time Evolution Loop ---\n    for _ in range(Nt):\n        g_prev = g.copy()\n        is_bursting_prev = is_bursting\n        \n        # --- Update Step ---\n        D_face = (D[:-1] + D[1:]) / 2.0\n        grad_T_face = (T[1:] - T[:-1]) / dx\n        F = -D_face * grad_T_face\n        \n        T_new = T.copy()\n        T_new[1:-1] = T[1:-1] - (dt/dx) * (F[1:] - F[:-1]) + dt * S[1:-1]\n        T_new[0] = T[0] - (dt/dx) * F[0] + dt * S[0]\n        T_new[-1] = 0.0  # Dirichlet BC\n        T = T_new\n        \n        # --- Post-update calculations and analysis ---\n        g = np.zeros(Nx)\n        g[1:-1] = -(T[2:] - T[:-2]) / (2 * dx)\n        g[0] = 0.0\n        g[-1] = -(T[-1] - T[-2]) / dx\n        \n        H = (g > gc).astype(float)\n        D_turb = (D_aval / (1 + (gamma_E / gamma_0)**2)) * H\n        D = D_base + D_turb\n        \n        D_face = (D[:-1] + D[1:]) / 2.0\n        grad_T_face = (T[1:] - T[:-1]) / dx\n        Q = np.sum(D_face * grad_T_face**2 * dx)\n        \n        is_bursting = Q > Q_thr\n        \n        # Check for event transitions\n        if is_bursting and not is_bursting_prev:  # Event start\n            g_pre_temp = np.max(g_prev)\n            \n        if not is_bursting and is_bursting_prev:  # Event end\n            if g_pre_temp is not None:\n                g_post = np.max(g)\n                if g_pre_temp > 1e-12:  # Avoid division by zero\n                    R_event = g_post / g_pre_temp\n                    R_events.append(R_event)\n                N_aval += 1\n                g_pre_temp = None\n                \n        if not is_bursting:\n            x_stars.append(x[np.argmax(g)])\n            \n    # --- Post-processing ---\n    if N_aval == 0:\n        R_mean = 1.0\n    else:\n        R_mean = np.mean(R_events) if R_events else 1.0\n\n    if not x_stars:\n        # Final gradient needs to be computed from the last T state\n        g_final = np.zeros(Nx)\n        g_final[1:-1] = -(T[2:] - T[:-2]) / (2 * dx)\n        g_final[0] = 0.0\n        g_final[-1] = -(T[-1] - T[-2]) / dx\n        x_bar = x[np.argmax(g_final)]\n    else:\n        x_bar = np.mean(x_stars)\n        \n    return N_aval, R_mean, x_bar\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (128, 1e-4, 4000, 1e-3, 1e-2, 0.8, 0.1, 0.6, 0.6, 0.07, 1.0, 0.3, 1.0, 2, 2e-3),\n        (128, 1e-4, 4000, 1e-3, 1.5e-2, 0.75, 0.1, 0.55, 0.6, 0.06, 2.0, 0.25, 1.0, 2, 4e-3),\n        (128, 1e-4, 4000, 1e-3, 1e-2, 0.9, 0.1, 0.6, 3.0, 0.05, 0.6, 0.3, 1.0, 2, 2e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N_aval, R_mean, x_bar = run_simulation(case)\n        results.append(str(N_aval))\n        results.append(f\"{R_mean:.6f}\")\n        results.append(f\"{x_bar:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}