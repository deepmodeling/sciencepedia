{
    "hands_on_practices": [
        {
            "introduction": "在研究间歇性现象时，首要任务是从连续的背景“噪声”中分离出离散的“事件”。本练习将引导您通过一个计算实践来完成这一任务，该实践基于通量阈值，是在分析实验和模拟数据中区分大型间歇性输运事件与连续背景湍流的常用方法。通过完成这项练习 ，您将掌握将原始信号转换为离散事件目录的核心数据处理技能，这是进行任何雪崩统计分析的基础。",
            "id": "4181717",
            "problem": "考虑一个一维全局输运模型，该模型描述了聚变等离子体湍流。在此模型中，系统的能量供应由外部施加的输入功率时间序列来表征，而向外的能量输运则通过一个事件分辨的径向能量通量时间序列来测量。自组织临界性 (Self-Organized Criticality, SOC) 描述了在驱动耗散系统中，间歇性的雪崩状事件如何从阈值动力学和长程相关性中涌现。在此问题中，您将使用一个基于测量通量的阈值和持续时间准则，来区分雪崩输运和连续湍流输运，然后对这些贡献随时间进行积分，以量化每种机制输运了多少输入能量。\n\n您将获得一个确定性的方法，用以构建人工但物理上合理的时间序列。设离散时间网格为 $t_n = n \\Delta t$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，采样间隔 $\\Delta t$ 以秒为单位。输入功率 $P_{\\text{in}}(t)$ 以瓦特为单位，径向能量通量 $q(t)$ 以瓦特为单位，时间 $t$ 以秒为单位。能量是通过功率对时间积分得到的，单位为焦耳。雪崩区间由一个检测阈值和与 SOC 现象学中事件聚合一致的后处理规则定义：\n\n- 定义一个二元指示符 $a_n$：如果 $q(t_n) \\ge T_{\\text{th}}$，则 $a_n = 1$，否则 $a_n = 0$。\n- 识别出 $a_n = 1$ 的连续索引段。这些是初步的雪崩段。\n- 如果相邻初步段之间的时间间隔小于或等于一个不应期间隔 $\\tau_{\\text{gap}}$，则合并它们。合并后，丢弃任何持续时间小于最小雪崩持续时间 $\\tau_{\\min}$ 的段。\n- 最终的雪崩集合 $\\mathcal{A}$ 是所有保留段的并集。补集 $\\mathcal{C}$ 包含所有不在 $\\mathcal{A}$ 中的时间点。\n\n根据第一性原理，一个时间窗口内的输运能量是该窗口内功率的时间积分。计算雪崩区间输运的能量\n$$\nQ_{\\text{av}} = \\int_{\\mathcal{A}} q(t)\\, dt\n$$\n和连续湍流输运的能量\n$$\nQ_{\\text{ct}} = \\int_{\\mathcal{C}} q(t)\\, dt,\n$$\n以及总输入能量\n$$\nE_{\\text{in}} = \\int_{0}^{T_{\\text{end}}} P_{\\text{in}}(t)\\, dt,\n$$\n其中 $T_{\\text{end}} = (N-1)\\Delta t$。使用积分的离散时间近似，即在给定网格上的 Riemann 和。\n\n报告无量纲分数\n$$\nf_{\\text{av}} = \\frac{Q_{\\text{av}}}{E_{\\text{in}}}\n\\quad\\text{和}\\quad\nf_{\\text{ct}} = \\frac{Q_{\\text{ct}}}{E_{\\text{in}}}.\n$$\n这些是能量之比，因此是无单位的。程序必须将每个报告值四舍五入到 $6$ 位小数。\n\n人工数据集构建规则如下。背景通量是一个比例部分和一个小的正弦调制之和：\n$$\nq_{\\text{bg}}(t) = \\beta P_{\\text{in}}(t) + \\gamma \\sin(2\\pi f_{\\text{bg}} t) P_0,\n$$\n其中 $P_0$ 是一个指定的参考功率。雪崩脉冲是叠加在背景之上的确定性三角脉冲：\n$$\nW(t; t_0, w) = \\max\\left(0, 1 - \\frac{|t - t_0|}{w}\\right),\n\\quad\nq_{\\text{pulse}}(t) = \\sum_{i} A_i W(t; t_{0,i}, w_i).\n$$\n总通量为\n$$\nq(t) = q_{\\text{bg}}(t) + q_{\\text{pulse}}(t).\n$$\n\n请精确按照描述实现检测和积分程序，并使用以下测试套件。在所有情况下，时间以秒表示，功率以瓦特表示。分数 $f_{\\text{av}}$ 和 $f_{\\text{ct}}$ 是无单位的小数。\n\n测试用例 $1$ (正常路径中等雪崩):\n- $\\Delta t = 10^{-3}$,\n- $N = 5000$,\n- $P_0 = 1.0 \\times 10^6$,\n- $P_{\\text{in}}(t) = P_0$,\n- $\\beta = 0.70$,\n- $\\gamma = 0.02$,\n- $f_{\\text{bg}} = 1.0$,\n- $t_{0,i} \\in \\{0.5,\\,1.0,\\,2.5,\\,3.0\\}$,\n- 公共宽度 $w_i = 0.05$,\n- 公共振幅 $A_i = 0.30 P_0$,\n- 阈值 $T_{\\text{th}} = 0.90 P_0$,\n- 最小持续时间 $\\tau_{\\min} = 0.020$,\n- 不应期间隔 $\\tau_{\\text{gap}} = 0.010$.\n\n测试用例 $2$ (因阈值过高未检测到雪崩):\n- 与测试用例 $1$ 中相同的 $t_n$、$P_{\\text{in}}(t)$ 和 $q(t)$ 构建方式,\n- 阈值 $T_{\\text{th}} = 1.10 P_0$,\n- 最小持续时间 $\\tau_{\\min} = 0.020$,\n- 不应期间隔 $\\tau_{\\text{gap}} = 0.010$.\n\n测试用例 $3$ (因阈值过低所有时间均计为雪崩):\n- 与测试用例 $1$ 中相同的 $t_n$、$P_{\\text{in}}(t)$ 和 $q(t)$ 构建方式,\n- 阈值 $T_{\\text{th}} = 0.65 P_0$,\n- 最小持续时间 $\\tau_{\\min} = 0.005$,\n- 不应期间隔 $\\tau_{\\text{gap}} = 0.005$.\n\n测试用例 $4$ (可变输入功率和不同的雪崩参数):\n- $\\Delta t = 10^{-3}$,\n- $N = 3000$,\n- $P_0 = 1.0 \\times 10^6$,\n- $P_{\\text{in}}(t) = P_0\\left(1 + 0.10 \\sin(2\\pi f_{\\text{in}} t)\\right)$，其中 $f_{\\text{in}} = 0.5$,\n- $\\beta = 0.60$,\n- $\\gamma = 0.02$,\n- $f_{\\text{bg}} = 3.0$,\n- 雪崩中心 $t_{0,i} \\in \\{0.7,\\,1.5,\\,2.1\\}$,\n- 公共宽度 $w_i = 0.03$,\n- 公共振幅 $A_i = 0.40 P_0$,\n- 阈值 $T_{\\text{th}} = 0.85 P_0$,\n- 最小持续时间 $\\tau_{\\min} = 0.015$,\n- 不应期间隔 $\\tau_{\\text{gap}} = 0.008$.\n\n测试用例 $5$ (脉冲短于最小持续时间，大部分输运计为连续):\n- $\\Delta t = 10^{-3}$,\n- $N = 2000$,\n- $P_0 = 1.0 \\times 10^6$,\n- $P_{\\text{in}}(t) = P_0$,\n- $\\beta = 0.65$,\n- $\\gamma = 0.01$,\n- $f_{\\text{bg}} = 2.0$,\n- 雪崩中心 $t_{0,i} \\in \\{1.0,\\,1.5\\}$,\n- 公共宽度 $w_i = 0.005$,\n- 公共振幅 $A_i = 0.35 P_0$,\n- 阈值 $T_{\\text{th}} = 0.90 P_0$,\n- 最小持续时间 $\\tau_{\\min} = 0.020$,\n- 不应期间隔 $\\tau_{\\text{gap}} = 0.005$.\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，按顺序附加两个值：首先是 $f_{\\text{av}}$，然后是 $f_{\\text{ct}}$。将每个值四舍五入到 $6$ 位小数。例如，如果有 $M$ 个测试用例，最终输出应包含 $2M$ 个数字，格式如 $[x_1,x_2,\\dots,x_{2M}]$。",
            "solution": "该问题提出了一个定义明确的计算任务，其基础是聚变等离子体中的输运物理。它要求实现一个特定的算法来分析能量通量的人工时间序列，并将其划分为来自间歇性“雪崩”事件和连续背景湍流的贡献。这是研究自组织临界性 (Self-Organized Criticality, SOC) 的一种常见范式，在该范式中，系统会自发地发展出长程相关性，并通过标度不变的事件释放能量。该问题是有效的，因为它具有科学依据、客观，并为数据生成和分析提供了完整、自洽的规范。\n\n解决方案首先根据提供的确定性规则构建人工数据，然后应用指定的事件检测和积分算法。每个步骤详述如下。\n\n### 1. 人工数据生成\n\n分析的基础是输入功率 $P_{\\text{in}}(t)$ 和径向能量通量 $q(t)$ 的时间序列。这些数据在离散时间网格 $t_n = n \\Delta t$ 上生成，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n\n- **时间网格**：创建一个一维数组，表示时间点 $t_n$。\n- **输入功率 ($P_{\\text{in}}$)**：输入功率可以是一个恒定值 $P_0$，也可以是一个随时间变化的正弦函数 $P_{\\text{in}}(t) = P_0(1 + 0.10 \\sin(2\\pi f_{\\text{in}} t))$，具体取决于每个测试用例的规定。\n- **背景通量 ($q_{\\text{bg}}$)**：通量的连续分量被建模为 $q_{\\text{bg}}(t) = \\beta P_{\\text{in}}(t) + \\gamma \\sin(2\\pi f_{\\text{bg}} t) P_0$。第一项 $\\beta P_{\\text{in}}(t)$ 代表由输入功率直接驱动的输运，而第二项引入了一个小的、持续的振荡。\n- **雪崩脉冲通量 ($q_{\\text{pulse}}$)**：间歇性输运事件被建模为一系列三角脉冲。每个脉冲由函数 $W(t; t_0, w) = \\max(0, 1 - |t - t_0|/w)$ 定义，该函数创建一个以 $t_0$ 为中心、半宽为 $w$ 的三角形。总脉冲通量是这些单个事件的叠加：$q_{\\text{pulse}}(t) = \\sum_{i} A_i W(t; t_{0,i}, w_i)$。\n- **总通量 ($q$)**：最终的径向通量时间序列是背景分量和脉冲分量的和：$q(t) = q_{\\text{bg}}(t) + q_{\\text{pulse}}(t)$。\n\n### 2. 雪崩检测算法\n\n问题的核心是识别与雪崩对应的时间区间。这是通过一个多步骤过程实现的，该过程旨在捕捉嘈杂、复杂信号中事件检测的本质。\n\n- **步骤 2a：阈值处理**：创建一个二元指示符时间序列 $a_n$。如果在时间 $t_n$ 的通量 $q(t_n)$ 超过指定的阈值 $T_{\\text{th}}$，则初步检测到一次雪崩。\n$$\na_n =\n\\begin{cases}\n1  & \\text{if } q(t_n) \\ge T_{\\text{th}} \\\\\n0  & \\text{if } q(t_n) < T_{\\text{th}}\n\\end{cases}\n$$\n- **步骤 2b：识别初步段**：识别出 $a_n=1$ 的连续块。每个块代表一个初步的雪崩段，由时间网格上的起始索引和结束索引定义。通过找到填充后的二元数组的差分从 $0$ 变为 $1$（起始点）和从 $1$ 变为 $0$（结束点）的索引，可以高效地实现这一步。\n\n- **步骤 2c：合并相邻段**：在 SOC 系统中，一个大的雪崩可能表现为一系列快速连续的小峰值。为了考虑这一点，我们合并由小时间间隔分隔的相邻段。如果一个段的结束与下一个段的开始之间的时间间隔小于或等于用户定义的不应期间隔 $\\tau_{\\text{gap}}$，则这两个段被合并成一个更长的段。重复此过程，直到没有更多段可以合并。\n\n- **步骤 2d：按持续时间筛选**：真正的雪崩事件预计具有一定的持续性。因此，任何总持续时间小于最小雪崩持续时间 $\\tau_{\\min}$ 的合并段都将被丢弃。一个跨越索引 $i$到$j$的段的持续时间计算为 $(j - i) \\Delta t$。\n\n最终的时间区间集合 $\\mathcal{A}$ 是所有通过此筛选过程的段的并集。补集 $\\mathcal{C}$ 包含所有其他时间点。时间数组上的布尔掩码是表示这些集合的有效方式，其中 `True` 表示属于 $\\mathcal{A}$。\n\n### 3. 能量积分和分数计算\n\n将时间序列划分为雪崩 ($\\mathcal{A}$) 和连续湍流 ($\\mathcal{C}$) 区间后，下一步是量化每种机制输运的能量。根据第一性原理，能量是功率的时间积分。我们使用离散网格上的 Riemann 和来近似这些积分。\n\n- **总输入能量 ($E_{\\text{in}}$)**：在整个持续时间内供给系统的总能量是输入功率的积分。\n$$\nE_{\\text{in}} = \\int_{0}^{T_{\\text{end}}} P_{\\text{in}}(t)\\, dt \\approx \\sum_{n=0}^{N-1} P_{\\text{in}}(t_n) \\Delta t\n$$\n- **雪崩输运能量 ($Q_{\\text{av}}$)**：这是通量 $q(t)$ 仅在雪崩区间 $\\mathcal{A}$ 上的积分。\n$$\nQ_{\\text{av}} = \\int_{\\mathcal{A}} q(t)\\, dt \\approx \\sum_{n \\in \\mathcal{A}} q(t_n) \\Delta t\n$$\n- **连续湍流输运能量 ($Q_{\\text{ct}}$)**：这是通量 $q(t)$ 在剩余时间区间 $\\mathcal{C}$ 上的积分。\n$$\nQ_{\\text{ct}} = \\int_{\\mathcal{C}} q(t)\\, dt \\approx \\sum_{n \\in \\mathcal{C}} q(t_n) \\Delta t\n$$\n注意，根据构造，$Q_{\\text{av}} + Q_{\\text{ct}} = \\sum_{n=0}^{N-1} q(t_n) \\Delta t$，即总输运能量。\n\n最后，通过将输运的能量用总输入能量进行归一化，计算出无量纲分数 $f_{\\text{av}}$ 和 $f_{\\text{ct}}$。这些分数代表了每个输运通道所占的能量预算部分。\n\n$$\nf_{\\text{av}} = \\frac{Q_{\\text{av}}}{E_{\\text{in}}} \\quad \\text{和} \\quad f_{\\text{ct}} = \\frac{Q_{\\text{ct}}}{E_{\\text{in}}}\n$$\n\n根据要求，最终值四舍五入到 $6$ 位小数。整个过程被封装在一个函数中，并应用于每个指定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case for avalanche analysis.\n    \n    Generates synthetic data, detects avalanches based on thresholding,\n    merging, and duration filtering, and computes energy transport fractions.\n    \"\"\"\n    # 1. Unpack parameters and generate time grid\n    dt = params['dt']\n    N = params['N']\n    P0 = params['P0']\n    \n    time = np.arange(N) * dt\n    \n    # 2. Generate synthetic time series data\n    # 2a. Input Power P_in(t)\n    if 'fin' in params:\n        P_in = P0 * (1.0 + 0.10 * np.sin(2 * np.pi * params['fin'] * time))\n    else:\n        P_in = np.full(N, P0)\n\n    # 2b. Background flux q_bg(t)\n    q_bg = params['beta'] * P_in + params['gamma'] * np.sin(2 * np.pi * params['fbg'] * time) * P0\n    \n    # 2c. Pulse flux q_pulse(t)\n    q_pulse = np.zeros(N)\n    for t0 in params['t0s']:\n        pulse = 1.0 - np.abs(time - t0) / params['w']\n        pulse = np.maximum(0, pulse)\n        q_pulse += params['A'] * pulse\n\n    # 2d. Total flux q(t)\n    q_total = q_bg + q_pulse\n    \n    # 3. Avalanche Detection Algorithm\n    T_th = params['T_th']\n    tau_gap = params['tau_gap']\n    tau_min = params['tau_min']\n\n    # 3a. Thresholding\n    a = q_total >= T_th\n    \n    # 3b. Identify preliminary segments\n    # Pad with False to correctly identify segments at the start/end\n    padded_a = np.concatenate(([False], a, [False]))\n    diffs = np.diff(padded_a.astype(int))\n    \n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0] - 1\n    \n    if len(starts) == 0:\n        preliminary_segments = []\n    else:\n        preliminary_segments = [[start, end] for start, end in zip(starts, ends)]\n\n    # 3c. Merge adjacent segments\n    if not preliminary_segments:\n        merged_segments = []\n    else:\n        merged_segments = [preliminary_segments[0]]\n        for i in range(1, len(preliminary_segments)):\n            last_end = merged_segments[-1][1]\n            next_start = preliminary_segments[i][0]\n            \n            # Gap duration in seconds\n            gap_duration = (next_start - last_end - 1) * dt\n            \n            if gap_duration = tau_gap:\n                # Merge by extending the end of the last segment\n                merged_segments[-1][1] = preliminary_segments[i][1]\n            else:\n                # Add as a new segment\n                merged_segments.append(preliminary_segments[i])\n\n    # 3d. Filter by minimum duration\n    final_segments = []\n    for start, end in merged_segments:\n        # Duration in seconds\n        duration = (end - start) * dt\n        if duration >= tau_min:\n            final_segments.append([start, end])\n            \n    # 4. Energy Integration\n    # Create a boolean mask representing the avalanche set A\n    is_avalanche = np.full(N, False, dtype=bool)\n    for start, end in final_segments:\n        is_avalanche[start:end+1] = True\n        \n    # Calculate energies using Riemann sums\n    E_in = np.sum(P_in) * dt\n    \n    # Check for E_in == 0 to prevent division by zero, though not expected here\n    if E_in == 0:\n        return 0.0, 0.0\n\n    Q_av = np.sum(q_total[is_avalanche]) * dt\n    Q_ct = np.sum(q_total[~is_avalanche]) * dt\n    \n    # 5. Calculate and round fractions\n    f_av = round(Q_av / E_in, 6)\n    f_ct = round(Q_ct / E_in, 6)\n    \n    return f_av, f_ct\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            'dt': 1e-3, 'N': 5000, 'P0': 1.0e6,\n            'beta': 0.70, 'gamma': 0.02, 'fbg': 1.0,\n            't0s': [0.5, 1.0, 2.5, 3.0], 'w': 0.05, 'A': 0.30e6,\n            'T_th': 0.90e6, 'tau_min': 0.020, 'tau_gap': 0.010\n        },\n        # Test Case 2\n        {\n            'dt': 1e-3, 'N': 5000, 'P0': 1.0e6,\n            'beta': 0.70, 'gamma': 0.02, 'fbg': 1.0,\n            't0s': [0.5, 1.0, 2.5, 3.0], 'w': 0.05, 'A': 0.30e6,\n            'T_th': 1.10e6, 'tau_min': 0.020, 'tau_gap': 0.010\n        },\n        # Test Case 3\n        {\n            'dt': 1e-3, 'N': 5000, 'P0': 1.0e6,\n            'beta': 0.70, 'gamma': 0.02, 'fbg': 1.0,\n            't0s': [0.5, 1.0, 2.5, 3.0], 'w': 0.05, 'A': 0.30e6,\n            'T_th': 0.65e6, 'tau_min': 0.005, 'tau_gap': 0.005\n        },\n        # Test Case 4\n        {\n            'dt': 1e-3, 'N': 3000, 'P0': 1.0e6, 'fin': 0.5,\n            'beta': 0.60, 'gamma': 0.02, 'fbg': 3.0,\n            't0s': [0.7, 1.5, 2.1], 'w': 0.03, 'A': 0.40e6,\n            'T_th': 0.85e6, 'tau_min': 0.015, 'tau_gap': 0.008\n        },\n        # Test Case 5\n        {\n            'dt': 1e-3, 'N': 2000, 'P0': 1.0e6,\n            'beta': 0.65, 'gamma': 0.01, 'fbg': 2.0,\n            't0s': [1.0, 1.5], 'w': 0.005, 'A': 0.35e6,\n            'T_th': 0.90e6, 'tau_min': 0.020, 'tau_gap': 0.005\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f_av, f_ct = process_case(case)\n        results.append(f_av)\n        results.append(f_ct)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在我们学会如何从数据中识别雪崩之后，一个自然的问题是：是什么样的物理机制导致了它们的产生？本练习通过模拟一个简化模型来深入探讨这一问题，在该模型中，产生于不稳定区域的湍流能够以“雪崩”的形式侵入并传播到邻近的稳定区域。求解这个反应-扩散方程  将为您提供一个具体而直观的理解，帮助您认识支撑雪崩现象的非局域输运机制。",
            "id": "4181750",
            "problem": "考虑一个一维径向域，其坐标为 $r \\in [0,L]$，代表磁约束聚变（MCF）装置中的小半径。设 $I(r,t)$ 为局域湍流强度的一个无量纲度量。假设 $I(r,t)$ 在归一化单位下的演化由一个从局域能量平衡推导出的反应扩散方程控制，该方程具有一个空间依赖的线性增长（或阻尼）率 $\\gamma(r)$、一个在 $I_{\\mathrm{sat}}$ 处的非线性饱和以及一个有效的湍流扩散系数 $D$：\n$$\n\\frac{\\partial I(r,t)}{\\partial t} = \\gamma(r)\\, I(r,t)\\left(1 - \\frac{I(r,t)}{I_{\\mathrm{sat}}}\\right) + D\\, \\frac{\\partial^2 I(r,t)}{\\partial r^2}.\n$$\n该形式模拟了聚变等离子体中线性驱动与非线性饱和之间的竞争，捕捉了由空间输运耦合的雪崩的发生与传播。自组织临界（SOC）的观点通过类阈值行为来体现：$\\gamma(r)$ 为负的区域是次临界的，并局域地阻尼湍流，但来自相邻超临界区的有限振幅扰动仍然可以通过扩散耦合瞬时地侵入那些名义上的稳定区。\n\n定义径向变化的增长率 $\\gamma(r)$，使其具有一个超临界核心和一个次临界边缘，并伴有平滑的过渡：\n$$\n\\gamma(r) = \\frac{\\gamma_0 + \\gamma_1}{2} + \\frac{\\gamma_0 - \\gamma_1}{2}\\, \\tanh\\!\\left(\\frac{r_c - r}{\\Delta}\\right),\n$$\n其中 $r_c$ 是过渡中心，$\\Delta$ 控制其径向陡峭度，$\\gamma_0 > 0$（超临界）且 $\\gamma_1  0$（次临界）。在 $r=0$ 和 $r=L$ 处使用齐次 Neumann 边界条件：\n$$\n\\left.\\frac{\\partial I}{\\partial r}\\right|_{r=0} = 0,\\quad \\left.\\frac{\\partial I}{\\partial r}\\right|_{r=L} = 0,\n$$\n并使用一个局域的有限振幅高斯扰动进行初始化，其中心位于过渡区超临界一侧的内部：\n$$\nI(r,0) = A \\exp\\!\\left(-\\frac{(r-r_0)^2}{2\\sigma^2}\\right),\\quad r_0 = r_c - \\delta.\n$$\n\n对于数值模拟，使用 $N$ 个网格点对区域进行均匀离散化，并使用对指定系数稳定的显式格式对系统进行时间推进。单位是无量纲的，区域大小为 $L = 1$。除非在测试组中有所变化，否则在所有情况下使用的参数如下：\n- $L = 1$\n- $N = 256$\n- $\\gamma_0 = 1$\n- $\\gamma_1 = -0.6$\n- $r_c = 0.6$\n- $\\Delta = 0.02$\n- $I_{\\mathrm{sat}} = 1$\n- $\\sigma = 0.015$\n- $\\delta = 0.03$\n- 模拟时程 $T = 0.6$\n- 定义雪崩穿透的阈值 $I_{\\mathrm{th}} = 0.05$\n\n将进入次临界区的雪崩穿透深度定义为在任何模拟时刻，强度超过阈值的点超出 $r_c$ 的最大径向偏移：\n$$\nd_{\\max} = \\max_{t \\in [0,T]} \\left(\\max\\{\\, r - r_c \\mid r \\ge r_c,\\ I(r,t) \\ge I_{\\mathrm{th}} \\,\\}\\right),\n$$\n如果不存在这样的 $r$，则设 $d_{\\max} = 0$。\n\n您的任务是实现这个模拟，并为以下每个测试用例计算 $d_{\\max}$，这些用例改变了扰动振幅 $A$ 和扩散系数 $D$：\n- 用例 1：$A = 0.02$, $D = 0.001$\n- 用例 2：$A = 0.15$, $D = 0.001$\n- 用例 3：$A = 0.15$, $D = 0.005$\n- 用例 4：$A = 0.40$, $D = 0.001$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与上面列出的用例一致，例如 $[d_1,d_2,d_3,d_4]$，其中每个 $d_i$ 是为用例 $i$ 计算出的 $d_{\\max}$。所有物理量都是无量纲的，因此不需要物理单位。通过使用一个显式格式，并选择满足扩散项和反应项稳定性的时间步长，并在更新中强制 $I(r,t)$ 的非负性，来确保科学真实性。",
            "solution": "用户提供了一个有效的科学问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   **控制方程**：\n    $$\n    \\frac{\\partial I(r,t)}{\\partial t} = \\gamma(r)\\, I(r,t)\\left(1 - \\frac{I(r,t)}{I_{\\mathrm{sat}}}\\right) + D\\, \\frac{\\partial^2 I(r,t)}{\\partial r^2}\n    $$\n-   **区域**：$r \\in [0,L]$，其中 $L=1$。\n-   **增长率剖面**：\n    $$\n    \\gamma(r) = \\frac{\\gamma_0 + \\gamma_1}{2} + \\frac{\\gamma_0 - \\gamma_1}{2}\\, \\tanh\\!\\left(\\frac{r_c - r}{\\Delta}\\right)\n    $$\n-   **边界条件 (BCs)**：齐次 Neumann 条件。\n    $$\n    \\left.\\frac{\\partial I}{\\partial r}\\right|_{r=0} = 0,\\quad \\left.\\frac{\\partial I}{\\partial r}\\right|_{r=L} = 0\n    $$\n-   **初始条件 (IC)**：\n    $$\n    I(r,0) = A \\exp\\!\\left(-\\frac{(r-r_0)^2}{2\\sigma^2}\\right),\\quad r_0 = r_c - \\delta\n    $$\n-   **固定参数**：\n    -   区域长度, $L = 1$。\n    -   网格点数, $N = 256$。\n    -   超临界增长率, $\\gamma_0 = 1$。\n    -   次临界阻尼率, $\\gamma_1 = -0.6$。\n    -   过渡中心, $r_c = 0.6$。\n    -   过渡陡峭度, $\\Delta = 0.02$。\n    -   饱和强度, $I_{\\mathrm{sat}} = 1$。\n    -   初始扰动宽度, $\\sigma = 0.015$。\n    -   初始扰动偏移, $\\delta = 0.03$。\n    -   模拟时程, $T = 0.6$。\n    -   穿透阈值, $I_{\\mathrm{th}} = 0.05$。\n-   **待计算量**：雪崩穿透深度, $d_{\\max}$。\n    $$\n    d_{\\max} = \\max_{t \\in [0,T]} \\left(\\max\\{\\, r - r_c \\mid r \\ge r_c,\\ I(r,t) \\ge I_{\\mathrm{th}} \\,\\}\\right)\n    $$\n    若不存在这样的 $r$，则 $d_{\\max} = 0$。\n-   **测试用例**：\n    -   用例 1: $A = 0.02$, $D = 0.001$\n    -   用例 2: $A = 0.15$, $D = 0.001$\n    -   用例 3: $A = 0.15$, $D = 0.005$\n    -   用例 4: $A = 0.40$, $D = 0.001$\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题描述了一个反应扩散方程，这是物理学和其他科学中用于模拟涉及局域增长/衰减和空间输运系统的基本模型。具有 logistic 增长和 Fick 扩散的特定形式是标准的。该设置模拟了聚变等离子体湍流中的雪崩动力学，这是一个公认的研究课题。该模型在科学上是合理的。\n-   **适定性**：该问题指定了一个具有明确初始和边界条件的偏微分方程，构成了一个适定的初边值问题。所有参数和常数都已明确给出。任务是从数值解中计算一个定义清晰的可观测量 $d_{\\max}$。\n-   **客观性**：该问题使用精确的数学和物理语言陈述，没有主观或模糊的术语。\n-   **结论**：不存在科学缺陷、不一致之处或模糊之处。该问题是有效的。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该问题需要对一个一维、非线性的反应扩散型偏微分方程（PDE）进行数值求解。将采用方法线法，首先对空间域进行离散化，将偏微分方程转化为一个耦合常微分方程组（ODEs），然后使用时间步进格式求解。\n\n**1. 空间离散化**\n\n径向域 $r \\in [0, L]$ 被离散化为 $N$ 个均匀分布的网格点，$r_i = i \\cdot \\Delta r$，其中 $i=0, 1, \\dots, N-1$。网格间距为 $\\Delta r = L / (N-1)$。每个网格点上的强度 $I(r_i, t)$ 记为 $I_i(t)$。\n\n空间导数项，即拉普拉斯算子 $\\frac{\\partial^2 I}{\\partial r^2}$，对于内部点（$i=1, \\dots, N-2$）使用二阶中心差分公式进行近似：\n$$\n\\left.\\frac{\\partial^2 I}{\\partial r^2}\\right|_{r_i} \\approx \\frac{I_{i+1}(t) - 2I_i(t) + I_{i-1}(t)}{(\\Delta r)^2}\n$$\n\n齐次 Neumann 边界条件 $\\frac{\\partial I}{\\partial r} = 0$ 通过引入“虚拟点”$I_{-1}$ 和 $I_N$ 来实现。在 $r=0$ 处的条件意味着 $\\frac{I_1-I_{-1}}{2\\Delta r} = 0$，因此 $I_{-1} = I_1$。在 $r=L$ 处的条件意味着 $\\frac{I_N-I_{N-2}}{2\\Delta r} = 0$，因此 $I_N = I_{N-2}$。将这些代入边界点（$i=0$ 和 $i=N-1$）的中心差分公式，得到：\n$$\n\\left.\\frac{\\partial^2 I}{\\partial r^2}\\right|_{r_0} \\approx \\frac{I_1 - 2I_0 + I_{-1}}{(\\Delta r)^2} = \\frac{2(I_1 - I_0)}{(\\Delta r)^2}\n$$\n$$\n\\left.\\frac{\\partial^2 I}{\\partial r^2}\\right|_{r_{N-1}} \\approx \\frac{I_N - 2I_{N-1} + I_{N-2}}{(\\Delta r)^2} = \\frac{2(I_{N-2} - I_{N-1})}{(\\Delta r)^2}\n$$\n\n**2. 时间积分**\n\n空间导数离散化后，PDE 变换为一个包含 $N$ 个耦合 ODE 的系统，形式为 $\\frac{dI_i}{dt} = F_i(I_0, I_1, \\dots, I_{N-1})$。使用一种简单而显式的方法，即前向欧拉格式，进行时间积分。下一个时间步 $t^{n+1} = t^n + \\Delta t$ 的强度由下式给出：\n$$\nI_i^{n+1} = I_i^n + \\Delta t \\left[ \\gamma(r_i) I_i^n \\left(1 - \\frac{I_i^n}{I_{\\mathrm{sat}}}\\right) + D \\left(\\frac{\\partial^2 I}{\\partial r^2}\\right)_i^n \\right]\n$$\n其中 $(\\frac{\\partial^2 I}{\\partial r^2})_i^n$ 是在网格点 $i$ 和时间步 $n$ 处拉普拉斯算子的有限差分近似。\n\n**3. 稳定性条件**\n\n显式格式只是条件稳定的。时间步长 $\\Delta t$ 必须足够小以防止数值不稳定性。对于给定的反应扩散方程，稳定性受扩散项和反应项的双重约束。一个保守的稳定性条件是：\n$$\n\\Delta t \\le \\frac{1}{\\frac{2D}{(\\Delta r)^2} + \\max|\\gamma(r)|}\n$$\n限制性最强的部分是扩散项。扩散部分的 Courant-Friedrichs-Lewy (CFL) 条件是 $\\Delta t \\le \\frac{(\\Delta r)^2}{2D}$。为确保所有模拟的稳定性并考虑到非线性反应项，我们为每种情况选择时间步长 $\\Delta t = C_s \\frac{(\\Delta r)^2}{D}$，安全因子 $C_s  0.5$。这里选择 $C_s=0.45$。\n\n**4. 算法实现**\n\n对于每个测试用例（由一对参数 $A$ 和 $D$ 定义）：\n1.  建立空间网格 $r$ 并预先计算增长率剖面 $\\gamma(r)$。\n2.  根据指定的高斯函数初始化强度剖面 $I(r,0)$。\n3.  根据给定的 $D$ 确定稳定的时间步长 $\\Delta t$。\n4.  将最大穿透深度 $d_{\\max}$ 初始化为 $0$。\n5.  从 $t=0$ 到 $T$ 进行时间迭代。在每一步中：\n    a.  对所有网格点计算反应项和离散化的扩散项。\n    b.  使用前向欧拉法更新强度剖面 $I$。\n    c.  通过将任何 $I_i  0$ 的值设为 $0$ 来强制执行非负性的物理约束。\n    d.  在次临界区（$r_i \\ge r_c$）中，找出强度超过阈值（$I_i \\ge I_{\\mathrm{th}}$）的网格点。\n    e.  如果存在这样的点，找出其中的最大径向坐标 $r_{\\max,t}$，并计算当前的穿透深度 $r_{\\max,t} - r_c$。\n    f.  更新总的最大穿透深度：$d_{\\max} = \\max(d_{\\max}, r_{\\max,t} - r_c)$。\n6.  达到模拟时间 $T$ 后，记录 $d_{\\max}$ 的最终值。\n\n对所有四个测试用例重复此过程，并收集结果，按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        # (A, D)\n        (0.02, 0.001),\n        (0.15, 0.001),\n        (0.15, 0.005),\n        (0.40, 0.001),\n    ]\n\n    results = []\n    for A, D in test_cases:\n        d_max = run_simulation(A, D)\n        results.append(f\"{d_max:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(A, D):\n    \"\"\"\n    Executes the reaction-diffusion simulation for a single set of parameters.\n\n    Args:\n        A (float): Amplitude of the initial Gaussian perturbation.\n        D (float): Diffusion coefficient.\n\n    Returns:\n        float: The calculated maximum penetration depth (d_max).\n    \"\"\"\n    # --- 1. Define Fixed Parameters and Grid ---\n    L = 1.0           # Domain length\n    N = 256           # Number of grid points\n    gamma_0 = 1.0     # Supercritical growth rate\n    gamma_1 = -0.6    # Subcritical damping rate\n    r_c = 0.6         # Transition center\n    Delta = 0.02      # Transition sharpness\n    I_sat = 1.0       # Saturation intensity\n    sigma = 0.015     # Initial perturbation width\n    delta = 0.03      # Initial perturbation offset\n    T = 0.6           # Simulation time horizon\n    I_th = 0.05       # Penetration threshold\n\n    r = np.linspace(0, L, N)\n    dr = L / (N - 1)\n    \n    # --- 2. Initial and Boundary Conditions  Profiles ---\n    \n    # Growth rate profile\n    gamma = (gamma_0 + gamma_1) / 2.0 + (gamma_0 - gamma_1) / 2.0 * np.tanh((r_c - r) / Delta)\n\n    # Initial condition\n    r_0 = r_c - delta\n    I = A * np.exp(-(r - r_0)**2 / (2 * sigma**2))\n\n    # --- 3. Time-stepping and Simulation Loop ---\n\n    # Stable time step based on CFL for diffusion\n    # dt = dr^2 / (2*D). We use a safety factor of 0.45.\n    dt = 0.45 * (dr**2) / D\n    num_steps = int(T / dt)\n\n    d_max = 0.0\n    \n    # Indices corresponding to the subcritical region (r >= r_c)\n    subcritical_indices = np.where(r >= r_c)[0]\n\n    for _ in range(num_steps):\n        # Calculate Laplacian using second-order central difference\n        d2I_dr2 = np.zeros(N)\n        \n        # Interior points\n        d2I_dr2[1:-1] = (I[2:] - 2 * I[1:-1] + I[:-2]) / dr**2\n        \n        # Neumann boundary conditions: dI/dr = 0\n        # at r=0 (i=0): I_-1 = I_1\n        d2I_dr2[0] = 2 * (I[1] - I[0]) / dr**2\n        # at r=L (i=N-1): I_N = I_N-2\n        d2I_dr2[-1] = 2 * (I[-2] - I[-1]) / dr**2\n        \n        # Calculate reaction term\n        reaction_term = gamma * I * (1 - I / I_sat)\n        \n        # Update I using Forward Euler\n        I_new = I + dt * (reaction_term + D * d2I_dr2)\n        \n        # Enforce non-negativity\n        I = np.maximum(0, I_new)\n\n        # --- 4. Calculate Penetration Depth ---\n        if subcritical_indices.size > 0:\n            I_subcritical = I[subcritical_indices]\n            r_subcritical = r[subcritical_indices]\n            \n            # Find points above the threshold in the subcritical region\n            penetrating_mask = I_subcritical >= I_th\n            \n            if np.any(penetrating_mask):\n                # Find the maximum radial position of penetration in this time step\n                max_penetrating_r = np.max(r_subcritical[penetrating_mask])\n                current_d = max_penetrating_r - r_c\n                # Update the overall maximum penetration depth\n                if current_d > d_max:\n                    d_max = current_d\n                    \n    return d_max\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "我们已经识别了事件并对其物理起源进行了建模，现在，我们必须严格检验其统计特性（如尺寸分布）是否真正符合自组织临界性（SOC）的预测。这项高级练习  超越了简单的曲线拟合，引入了贝叶斯模型选择这一强大框架。您将学习如何定量地比较支持无标度幂律模型（SOC 的一个标志）与支持其他竞争模型（如指数或对数正态分布）的证据强度。",
            "id": "4181755",
            "problem": "你的任务是通过比较雪崩事件大小和事件间等待时间的概率模型，来评估聚变等离子体湍流中自组织临界（SOC）的证据。自组织临界（SOC）指的是系统演化到一个临界状态，在该状态下，事件大小和等待时间的分布通常表现出无标度行为。目标是计算雪崩大小和等待时间的竞争模型之间的贝叶斯因子，并将这些结果在多个合成数据集上进行汇总。你的程序必须是一个完整的、可运行的程序，能够产生指定的输出。\n\n从基本原理开始：\n\n- 令 $D = \\{x_i\\}_{i=1}^n$ 表示一个独立观测的数据集，令 $M$ 表示一个带有参数 $\\theta$ 的概率模型。令似然函数为 $p(D \\mid \\theta, M) = \\prod_{i=1}^n p(x_i \\mid \\theta, M)$。\n- 令先验为 $p(\\theta \\mid M)$，边际似然（模型证据）为 $$Z_M = p(D \\mid M) = \\int p(D \\mid \\theta, M)\\, p(\\theta \\mid M)\\, d\\theta.$$\n- 比较模型 $M_1$ 和 $M_2$ 的贝叶斯因子为 $$B_{12} = \\frac{Z_{M_1}}{Z_{M_2}}.$$\n- 对观测使用独立同分布（i.i.d.）的假设，并使用正常先验以确保证据有限。\n\n待比较的模型：\n\n雪崩大小 $s_i \\ge s_{\\min}$：\n\n- 模型 $S_{\\text{PL}}$（幂律，帕累托）：对于 $s \\ge s_{\\min}$，使用概率密度函数（PDF）$$p(s \\mid \\alpha, S_{\\text{PL}}) = (\\alpha - 1)\\, s_{\\min}^{\\alpha - 1}\\, s^{-\\alpha},$$ 其中指数 $\\alpha  1$，下截断值 $s_{\\min}$ 已知。\n- 模型 $S_{\\text{EXP}}$（移位指数）：对于 $s \\ge s_{\\min}$，定义 $x = s - s_{\\min} \\ge 0$，其 PDF 为 $$p(s \\mid \\lambda, S_{\\text{EXP}}) = \\lambda\\, e^{-\\lambda (s - s_{\\min})},$$ 其中 $\\lambda  0$ 是速率。\n- 模型 $S_{\\text{LN}}$（对数正态）：对于 $s  0$，令 $y = \\ln s$，并使用 $$p(s \\mid \\mu, \\sigma^2, S_{\\text{LN}}) = \\frac{1}{s\\, \\sigma\\, \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\ln s - \\mu)^2}{2 \\sigma^2}\\right),$$ 其中对数转换变量的均值为 $\\mu \\in \\mathbb{R}$，方差为 $\\sigma^2  0$。\n\n等待时间 $t_i \\ge t_{\\min}$（单位：秒）：\n\n- 模型 $T_{\\text{PL}}$（幂律，帕累托）：对于 $t \\ge t_{\\min}$，$$p(t \\mid \\alpha_t, T_{\\text{PL}}) = (\\alpha_t - 1)\\, t_{\\min}^{\\alpha_t - 1}\\, t^{-\\alpha_t},$$ 其中 $\\alpha_t  1$ 且 $t_{\\min}$ 已知。\n- 模型 $T_{\\text{EXP}}$（移位指数）：对于 $t \\ge t_{\\min}$，令 $x = t - t_{\\min} \\ge 0$，其 $$p(t \\mid \\lambda_t, T_{\\text{EXP}}) = \\lambda_t\\, e^{-\\lambda_t (t - t_{\\min})},$$ 且 $\\lambda_t  0$。\n\n先验选择：\n\n- 对于帕累托指数，重参数化 $\\theta = \\alpha - 1$ 并使用伽马先验 $$\\theta \\sim \\operatorname{Gamma}(a_0, b_0).$$\n- 对于指数速率 $\\lambda$ 和 $\\lambda_t$，使用伽马先验 $$\\lambda \\sim \\operatorname{Gamma}(a_0, b_0).$$\n- 对于 $y = \\ln s$ 的对数正态参数，使用正态-逆伽马先验 $$\\mu \\mid \\sigma^2 \\sim \\mathcal{N}(\\mu_0, \\sigma^2/\\kappa_0), \\quad \\sigma^2 \\sim \\operatorname{Inv}\\text{-}\\operatorname{Gamma}(\\alpha_0, \\beta_0).$$\n\n任务：\n\n- 对于每个数据集，使用上述先验和独立同分布假设计算每个模型的边际似然，然后计算贝叶斯因子：\n    - 雪崩大小：$B_{S_{\\text{PL}}, S_{\\text{EXP}}}$ 和 $B_{S_{\\text{PL}}, S_{\\text{LN}}}$。\n    - 等待时间：$B_{T_{\\text{PL}}, T_{\\text{EXP}}}$。\n- 贝叶斯因子是无量纲的。等待时间以秒为单位处理；所有大小都是无量纲的归一化雪崩大小。\n\n测试套件：\n\n- 使用以下数据集和参数。\n\n情况 $1$（预期的类SOC重尾）：\n- 雪崩大小 $s$，$s_{\\min} = 1.0$：$[\\, $1.0$, $1.2$, $1.1$, $2.0$, $3.5$, $1.0$, $5.0$, $8.0$, $1.5$, $10.0$, $2.2$, $4.4$ \\,]$。\n- 等待时间 $t$，$t_{\\min} = 1.0 \\times 10^{-4}$ 秒：$[\\, $1.0 \\times 10^{-4}$, $2.0 \\times 10^{-4}$, $1.5 \\times 10^{-4}$, $5.0 \\times 10^{-4}$, $3.0 \\times 10^{-3}$, $1.2 \\times 10^{-4}$, $8.0 \\times 10^{-4}$, $1.0 \\times 10^{-2}$, $2.0 \\times 10^{-4}$, $4.0 \\times 10^{-3}$ \\,]$。\n\n情况 $2$（预期的近指数行为）：\n- 雪崩大小 $s$，$s_{\\min} = 1.0$：$[\\, $1.0$, $1.1$, $1.05$, $1.2$, $1.15$, $1.05$, $1.3$, $1.1$, $1.05$, $1.2$ \\,]$。\n- 等待时间 $t$，$t_{\\min} = 1.0 \\times 10^{-4}$ 秒：$[\\, $1.0 \\times 10^{-4}$, $1.2 \\times 10^{-4}$, $1.1 \\times 10^{-4}$, $1.3 \\times 10^{-4}$, $1.05 \\times 10^{-4}$, $1.4 \\times 10^{-4}$, $1.2 \\times 10^{-4}$, $1.3 \\times 10^{-4}$, $1.1 \\times 10^{-4}$, $1.25 \\times 10^{-4}$ \\,]$。\n\n情况 $3$（边缘情况：小样本量含一个离群值）：\n- 雪崩大小 $s$，$s_{\\min} = 1.0$：$[\\, $1.0$, $1.0$, $1.0$, $4.0$ \\,]$。\n- 等待时间 $t$，$t_{\\min} = 1.0 \\times 10^{-4}$ 秒：$[\\, $1.0 \\times 10^{-4}$, $1.0 \\times 10^{-4}$, $5.0 \\times 10^{-4}$ \\,]$。\n\n超参数（所有情况共享）：\n\n- $\\theta = \\alpha - 1$ 的帕累托伽马先验：$a_0 = 1.5$, $b_0 = 1.0$。\n- 指数速率先验：$a_0 = 1.0$, $b_0 = 1.0$。\n- $y = \\ln s$ 的对数正态正态-逆伽马先验：$\\mu_0 = 0.0$, $\\kappa_0 = 1.0 \\times 10^{-3}$, $\\alpha_0 = 1.0$, $\\beta_0 = 1.0$。\n\n要求输出：\n\n- 对每种情况，计算并返回列表 $[\\, B_{S_{\\text{PL}}, S_{\\text{EXP}}},\\, B_{S_{\\text{PL}}, S_{\\text{LN}}},\\, B_{T_{\\text{PL}}, T_{\\text{EXP}}} \\,]$ 作为浮点数。\n- 将 $3$ 种情况的结果汇总到一个由方括号括起来的逗号分隔列表中，按情况 $1, 2, 3$ 的顺序排列，总共得到 $9$ 个数字： $$[\\, B_{S_{\\text{PL}}, S_{\\text{EXP}}}^{(1)},\\, B_{S_{\\text{PL}}, S_{\\text{LN}}}^{(1)},\\, B_{T_{\\text{PL}}, T_{\\text{EXP}}}^{(1)},\\, B_{S_{\\text{PL}}, S_{\\text{EXP}}}^{(2)},\\, B_{S_{\\text{PL}}, S_{\\text{LN}}}^{(2)},\\, B_{T_{\\text{PL}}, T_{\\text{EXP}}}^{(2)},\\, B_{S_{\\text{PL}}, S_{\\text{EXP}}}^{(3)},\\, B_{S_{\\text{PL}}, S_{\\text{LN}}}^{(3)},\\, B_{T_{\\text{PL}}, T_{\\text{EXP}}}^{(3)} \\,].$$\n- 你的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,\\dots]$）。贝叶斯因子是无量纲的浮点数；不应打印任何其他文本。\n\n注意：评估纯粹是数学和逻辑上的；除了以秒为单位的等待时间外，数值都是无量纲的。角度单位不适用。百分比不适用。确保在计算边际似然时具有数值稳定性。",
            "solution": "该问题要求计算贝叶斯因子，以比较用于雪崩大小和事件间等待时间的几种概率模型，这些是聚变等离子体湍流中自组织临界（SOC）的指标。任务的核心是为每个模型 $M$ 计算边际似然，即模型证据 $Z_M$。给定一个独立同分布（i.i.d.）观测的数据集 $D=\\{x_i\\}_{i=1}^n$，边际似然定义为似然函数在模型参数 $\\theta$ 的先验分布上的积分：\n$$Z_M = p(D \\mid M) = \\int p(D \\mid \\theta, M) p(\\theta \\mid M) d\\theta$$\n其中似然函数为 $p(D \\mid \\theta, M) = \\prod_{i=1}^n p(x_i \\mid \\theta, M)$。该问题为所有模型指定了共轭先验，这使得可以对这些积分进行解析计算。为了数值稳定性，所有计算都将在对数空间中进行。比较模型 $M_1$ 和 $M_2$ 的贝叶斯因子 $B_{12}$ 则计算为 $B_{12} = \\frac{Z_{M_1}}{Z_{M_2}} = \\exp(\\ln Z_{M_1} - \\ln Z_{M_2})$。\n\n我们现在将为每个指定模型推导对数边际似然的解析表达式。\n\n**1. 幂律（帕累托）模型证据**\n\n帕累托模型的概率密度函数（PDF）对于数据 $x \\ge x_{\\min}$ 给出为 $p(x \\mid \\alpha) = (\\alpha - 1) x_{\\min}^{\\alpha - 1} x^{-\\alpha}$，其中 $\\alpha1$。问题指定了一个重参数化 $\\theta = \\alpha - 1  0$。PDF 变为 $p(x \\mid \\theta) = \\theta x_{\\min}^{\\theta} x^{-(\\theta+1)}$。\n\n数据集 $D=\\{x_i\\}_{i=1}^n$ 的似然函数是：\n$$p(D \\mid \\theta) = \\prod_{i=1}^n \\theta x_{\\min}^{\\theta} x_i^{-(\\theta+1)} = \\theta^n x_{\\min}^{n\\theta} \\left(\\prod_{i=1}^n x_i\\right)^{-(\\theta+1)} = \\theta^n \\left(\\prod_{i=1}^n x_i^{-1}\\right) e^{-\\theta \\sum_{i=1}^n \\ln(x_i/x_{\\min})}$$\n在 $\\theta$ 上设置一个 $\\operatorname{Gamma}(a_0, b_0)$ 先验：\n$$p(\\theta) = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\theta^{a_0-1} e^{-b_0 \\theta}$$\n边际似然 $Z_{\\text{PL}}$ 是似然函数与先验乘积在 $\\theta$ 上的积分：\n$$Z_{\\text{PL}} = \\int_0^\\infty \\left( \\theta^n \\left(\\prod_{i=1}^n x_i^{-1}\\right) e^{-\\theta S} \\right) \\left( \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\theta^{a_0-1} e^{-b_0 \\theta} \\right) d\\theta$$\n其中 $S = \\sum_{i=1}^n \\ln(x_i / x_{\\min})$。合并各项得到：\n$$Z_{\\text{PL}} = \\left(\\prod_{i=1}^n x_i^{-1}\\right) \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\int_0^\\infty \\theta^{n+a_0-1} e^{-(S+b_0)\\theta} d\\theta$$\n该积分是 $\\operatorname{Gamma}(n+a_0, S+b_0)$ 分布的非归一化形式，其计算结果为 $\\frac{\\Gamma(n+a_0)}{(S+b_0)^{n+a_0}}$。\n因此，边际似然为：\n$$Z_{\\text{PL}} = \\left(\\prod_{i=1}^n x_i^{-1}\\right) \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\frac{\\Gamma(n+a_0)}{(S+b_0)^{n+a_0}}$$\n在对数空间中，这变为：\n$$\\ln Z_{\\text{PL}} = -\\sum_{i=1}^n \\ln x_i + a_0 \\ln b_0 + \\ln\\Gamma(n+a_0) - \\ln\\Gamma(a_0) - (n+a_0)\\ln(S+b_0)$$\n\n**2. 移位指数模型证据**\n\n移位指数模型的 PDF 为 $p(s \\mid \\lambda) = \\lambda e^{-\\lambda(s-s_{\\min})}$，对于 $s \\ge s_{\\min}$，其中 $\\lambda0$。令 $y_i = s_i - s_{\\min}$。数据集 $D=\\{s_i\\}_{i=1}^n$ 的似然函数是：\n$$p(D \\mid \\lambda) = \\prod_{i=1}^n \\lambda e^{-\\lambda y_i} = \\lambda^n e^{-\\lambda \\sum_{i=1}^n y_i}$$\n在速率 $\\lambda$ 上设置一个 $\\operatorname{Gamma}(a_0, b_0)$ 先验。计算的结构与帕累托情况相同，但数据统计量不同，且似然函数没有前置因子。\n$$Z_{\\text{EXP}} = \\int_0^\\infty (\\lambda^n e^{-\\lambda \\sum y_i}) \\left( \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\lambda^{a_0-1} e^{-b_0 \\lambda} \\right) d\\lambda$$\n$$Z_{\\text{EXP}} = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\int_0^\\infty \\lambda^{n+a_0-1} e^{-(\\sum y_i + b_0)\\lambda} d\\lambda$$\n这计算为：\n$$Z_{\\text{EXP}} = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\frac{\\Gamma(n+a_0)}{(\\sum y_i + b_0)^{n+a_0}}$$\n在对数空间中：\n$$\\ln Z_{\\text{EXP}} = a_0 \\ln b_0 + \\ln\\Gamma(n+a_0) - \\ln\\Gamma(a_0) - (n+a_0) \\ln\\left(\\sum_{i=1}^n (s_i - s_{\\min}) + b_0\\right)$$\n\n**3. 对数正态模型证据**\n\n对数正态模型的 PDF 对于 $s  0$ 给出为 $p(s \\mid \\mu, \\sigma^2) = \\frac{1}{s\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln s - \\mu)^2}{2\\sigma^2}\\right)$。令 $y = \\ln s$。转换后的变量 $y$ 服从正态分布 $y \\sim \\mathcal{N}(\\mu, \\sigma^2)$。数据集 $D_s=\\{s_i\\}_{i=1}^n$ 的似然函数是：\n$$p(D_s \\mid \\mu, \\sigma^2) = \\prod_{i=1}^n \\frac{1}{s_i\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln s_i - \\mu)^2}{2\\sigma^2}\\right) = \\left(\\prod_{i=1}^n s_i^{-1}\\right) p(D_y \\mid \\mu, \\sigma^2)$$\n其中 $D_y = \\{\\ln s_i\\}_{i=1}^n$。\n$(\\mu, \\sigma^2)$ 的先验是正态-逆伽马分布：$\\mu \\mid \\sigma^2 \\sim \\mathcal{N}(\\mu_0, \\sigma^2/\\kappa_0)$ 且 $\\sigma^2 \\sim \\operatorname{Inv-Gamma}(\\alpha_0, \\beta_0)$。这是正态似然函数的共轭先验。对数转换数据 $D_y$ 的边际似然 $p(D_y)$ 具有标准的解析形式。\n\n观测到 $D_y$ 后，正态-逆伽马分布的后验超参数是：\n$$ \\kappa_n = \\kappa_0 + n $$\n$$ \\mu_n = \\frac{\\kappa_0 \\mu_0 + n \\bar{y}}{\\kappa_n} \\quad \\text{where} \\quad \\bar{y} = \\frac{1}{n} \\sum_{i=1}^n y_i $$\n$$ \\alpha_n = \\alpha_0 + \\frac{n}{2} $$\n$$ \\beta_n = \\beta_0 + \\frac{1}{2}\\sum_{i=1}^n (y_i - \\bar{y})^2 + \\frac{n \\kappa_0}{2(n+\\kappa_0)}(\\bar{y} - \\mu_0)^2 $$\n边际似然 $p(D_y)$ 接着由下式给出：\n$$p(D_y) = \\frac{1}{(2\\pi)^{n/2}} \\frac{\\Gamma(\\alpha_n)}{\\Gamma(\\alpha_0)} \\frac{\\beta_0^{\\alpha_0}}{\\beta_n^{\\alpha_n}} \\sqrt{\\frac{\\kappa_0}{\\kappa_n}}$$\n因此，原始数据 $D_s$ 的边际似然为：\n$$Z_{\\text{LN}} = p(D_s) = \\left(\\prod_{i=1}^n s_i^{-1}\\right) p(D_y)$$\n在对数空间中：\n$$\\ln Z_{\\text{LN}} = -\\sum_{i=1}^n \\ln s_i - \\frac{n}{2}\\ln(2\\pi) + \\ln\\Gamma(\\alpha_n) - \\ln\\Gamma(\\alpha_0) + \\alpha_0\\ln\\beta_0 - \\alpha_n\\ln\\beta_n + \\frac{1}{2}(\\ln\\kappa_0 - \\ln\\kappa_n)$$\n这些推导出的对数边际似然将被实现，以计算所提供测试用例所需的贝叶斯因子。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef log_marginal_likelihood_pareto(x, x_min, a0, b0):\n    \"\"\"\n    Computes the log marginal likelihood for a Pareto distribution\n    with a Gamma prior on theta = alpha - 1.\n    \"\"\"\n    n = len(x)\n    \n    # Ensure all data points are above or at the minimum threshold\n    if np.any(x  x_min):\n        raise ValueError(\"All data points must be >= x_min.\")\n\n    log_x = np.log(x)\n    sum_log_x = np.sum(log_x)\n    \n    # S = sum(log(x_i / x_min))\n    S = sum_log_x - n * np.log(x_min)\n\n    # Posterior parameters\n    an = n + a0\n    bn = S + b0\n    \n    # Log marginal likelihood calculation\n    # ln Z_PL = -sum(ln(x_i)) + a0*ln(b0) + gammaln(n+a0) - gammaln(a0) - (n+a0)*ln(S+b0)\n    log_Z = (\n        -sum_log_x\n        + a0 * np.log(b0)\n        + gammaln(an)\n        - gammaln(a0)\n        - an * np.log(bn)\n    )\n    return log_Z\n\ndef log_marginal_likelihood_exponential(x, x_min, a0, b0):\n    \"\"\"\n    Computes the log marginal likelihood for a shifted exponential distribution\n    with a Gamma prior on the rate lambda.\n    \"\"\"\n    n = len(x)\n    \n    # Ensure all data points are above or at the minimum threshold\n    if np.any(x  x_min):\n        raise ValueError(\"All data points must be >= x_min.\")\n\n    y = x - x_min\n    sum_y = np.sum(y)\n    \n    # Posterior parameters\n    an = n + a0\n    bn = sum_y + b0\n\n    # Log marginal likelihood calculation\n    # ln Z_EXP = a0*ln(b0) + gammaln(n+a0) - gammaln(a0) - (n+a0)*ln(sum(y_i)+b0)\n    log_Z = (\n        a0 * np.log(b0)\n        + gammaln(an)\n        - gammaln(a0)\n        - an * np.log(bn)\n    )\n    return log_Z\n\ndef log_marginal_likelihood_lognormal(s, mu0, kappa0, alpha0, beta0):\n    \"\"\"\n    Computes the log marginal likelihood for a lognormal distribution\n    with a Normal-Inverse-Gamma prior on (mu, sigma^2).\n    \"\"\"\n    n = len(s)\n    \n    # Ensure all data points are positive\n    if np.any(s = 0):\n        raise ValueError(\"All data points for lognormal must be > 0.\")\n\n    y = np.log(s)\n    sum_log_s = np.sum(y)\n    \n    # Precompute statistics of log-transformed data\n    y_bar = np.mean(y)\n    sum_sq_diff = np.sum((y - y_bar)**2)\n    \n    # Posterior hyperparameters\n    kappa_n = kappa0 + n\n    alpha_n = alpha0 + n / 2.0\n    beta_n = (\n        beta0 \n        + 0.5 * sum_sq_diff \n        + (n * kappa0 / (2.0 * (kappa0 + n))) * (y_bar - mu0)**2\n    )\n\n    # Log marginal likelihood for the log-transformed data y\n    log_p_D_y = (\n        -n / 2.0 * np.log(2 * np.pi)\n        + gammaln(alpha_n)\n        - gammaln(alpha0)\n        + alpha0 * np.log(beta0)\n        - alpha_n * np.log(beta_n)\n        + 0.5 * (np.log(kappa0) - np.log(kappa_n))\n    )\n    \n    # Total log marginal likelihood including the jacobian term\n    # ln Z_LN = -sum(ln(s_i)) + ln(p(D_y))\n    log_Z = -sum_log_s + log_p_D_y\n    return log_Z\n\ndef solve():\n    # Define the datasets and parameters from the problem statement.\n    test_cases = [\n        {\n            \"sizes\": {\"data\": np.array([1.0, 1.2, 1.1, 2.0, 3.5, 1.0, 5.0, 8.0, 1.5, 10.0, 2.2, 4.4]), \"min\": 1.0},\n            \"times\": {\"data\": np.array([1.0e-4, 2.0e-4, 1.5e-4, 5.0e-4, 3.0e-3, 1.2e-4, 8.0e-4, 1.0e-2, 2.0e-4, 4.0e-3]), \"min\": 1.0e-4},\n        },\n        {\n            \"sizes\": {\"data\": np.array([1.0, 1.1, 1.05, 1.2, 1.15, 1.05, 1.3, 1.1, 1.05, 1.2]), \"min\": 1.0},\n            \"times\": {\"data\": np.array([1.0e-4, 1.2e-4, 1.1e-4, 1.3e-4, 1.05e-4, 1.4e-4, 1.2e-4, 1.3e-4, 1.1e-4, 1.25e-4]), \"min\": 1.0e-4},\n        },\n        {\n            \"sizes\": {\"data\": np.array([1.0, 1.0, 1.0, 4.0]), \"min\": 1.0},\n            \"times\": {\"data\": np.array([1.0e-4, 1.0e-4, 5.0e-4]), \"min\": 1.0e-4},\n        }\n    ]\n\n    # Shared hyperparameters\n    hparams_pareto = {\"a0\": 1.5, \"b0\": 1.0}\n    hparams_exp = {\"a0\": 1.0, \"b0\": 1.0}\n    hparams_ln = {\"mu0\": 0.0, \"kappa0\": 1.0e-3, \"alpha0\": 1.0, \"beta0\": 1.0}\n\n    results = []\n    \n    for case in test_cases:\n        s_data, s_min = case[\"sizes\"][\"data\"], case[\"sizes\"][\"min\"]\n        t_data, t_min = case[\"times\"][\"data\"], case[\"times\"][\"min\"]\n        \n        # Avalanche Sizes\n        log_z_s_pl = log_marginal_likelihood_pareto(s_data, s_min, **hparams_pareto)\n        log_z_s_exp = log_marginal_likelihood_exponential(s_data, s_min, **hparams_exp)\n        log_z_s_ln = log_marginal_likelihood_lognormal(s_data, **hparams_ln)\n        \n        # Bayes Factors for Sizes\n        B_s_pl_exp = np.exp(log_z_s_pl - log_z_s_exp)\n        B_s_pl_ln = np.exp(log_z_s_pl - log_z_s_ln)\n        \n        # Waiting Times\n        log_z_t_pl = log_marginal_likelihood_pareto(t_data, t_min, **hparams_pareto)\n        log_z_t_exp = log_marginal_likelihood_exponential(t_data, t_min, **hparams_exp)\n        \n        # Bayes Factor for Times\n        B_t_pl_exp = np.exp(log_z_t_pl - log_z_t_exp)\n        \n        results.extend([B_s_pl_exp, B_s_pl_ln, B_t_pl_exp])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}