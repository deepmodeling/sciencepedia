{
    "hands_on_practices": [
        {
            "introduction": "The first step in analyzing turbulent data from a numerical simulation is to understand the structure of the wavenumber space itself. This practice grounds our analysis by deriving the fundamental relationship between the discrete physical grid of a simulation and the corresponding discrete set of resolved wavenumbers. By applying the principles of Fourier series on a periodic domain, you will see precisely how the box size and grid resolution quantize the spectral domain, a crucial concept for interpreting any Fourier-based analysis. ",
            "id": "4180922",
            "problem": "Consider a three-dimensional, flux-tube style fusion plasma turbulence simulation domain with Cartesian coordinates $\\{x,y,z\\}$, where $x$ and $y$ are perpendicular to the magnetic field and $z$ is aligned with the magnetic field, so that the parallel wavenumber is $k_{\\parallel} \\equiv k_{z}$. The domain is triply periodic with periods $L_{x}$, $L_{y}$, and $L_{z}$, and the fields are sampled uniformly on grids of sizes $N_{x}$, $N_{y}$, and $N_{z}$ with spacings $\\Delta x$, $\\Delta y$, and $\\Delta z$, respectively, so that $L_{x} = N_{x}\\Delta x$, $L_{y} = N_{y}\\Delta y$, and $L_{z} = N_{z}\\Delta z$. Assume that $N_{x}$, $N_{y}$, and $N_{z}$ are even integers and that the spectral analysis uses a centered indexing convention consistent with the Discrete Fourier Transform, in which integer mode indices span $m_{x} \\in \\{-N_{x}/2,\\ldots,N_{x}/2-1\\}$, $m_{y} \\in \\{-N_{y}/2,\\ldots,N_{y}/2-1\\}$, and $m_{z} \\in \\{-N_{z}/2,\\ldots,N_{z}/2-1\\}$.\n\nStarting from the Fourier series representation of periodic functions on each domain and the quantization of wavenumbers enforced by periodic boundary conditions, and invoking the sampling constraint defined by the Nyquist-Shannon theorem to determine the resolvable discrete set for each direction, derive the compact analytic expression for the resolved wavenumber triplet $\\{k_{x},k_{y},k_{\\parallel}\\}$ as a parametric function of the integer indices and the grid/dimension parameters. Your answer must be expressed solely in terms of $m_{x}$, $m_{y}$, $m_{z}$, $N_{x}$, $N_{y}$, $N_{z}$, $\\Delta x$, $\\Delta y$, and $\\Delta z$, with no numerical substitution. Provide your final expression only, and do not include inequalities or equalities in your final answer.",
            "solution": "The problem requires the derivation of the analytic expression for the resolved wavenumber triplet $\\{k_{x}, k_{y}, k_{\\parallel}\\}$ in a triply periodic domain used for fusion plasma turbulence simulations. The derivation proceeds from the fundamental principles of Fourier series on periodic domains and the constraints imposed by discrete sampling.\n\nA function $f(x, y, z)$ defined on a rectangular domain with side lengths $L_x$, $L_y$, and $L_z$ that is periodic in all three directions can be represented by a three-dimensional Fourier series:\n$$\nf(x, y, z) = \\sum_{m_x, m_y, m_z \\in \\mathbb{Z}} \\hat{f}_{m_x, m_y, m_z} \\exp\\left(i (k_x x + k_y y + k_z z)\\right)\n$$\nwhere $\\hat{f}_{m_x, m_y, m_z}$ are the Fourier coefficients and $\\{k_x, k_y, k_z\\}$ are the components of the wavenumber vector $\\vec{k}$.\n\nThe periodicity conditions are:\n$f(x+L_x, y, z) = f(x, y, z)$\n$f(x, y+L_y, z) = f(x, y, z)$\n$f(x, y, z+L_z) = f(x, y, z)$\n\nApplying the first condition to the general term of the Fourier series yields:\n$$\n\\exp\\left(i (k_x (x+L_x) + k_y y + k_z z)\\right) = \\exp\\left(i (k_x x + k_y y + k_z z)\\right)\n$$\nThis simplifies to:\n$$\n\\exp\\left(i k_x L_x\\right) = 1\n$$\nThis equality holds if and only if the argument of the exponential is an integer multiple of $2\\pi$. Thus, we have the quantization condition for the wavenumber component $k_x$:\n$$\nk_x L_x = 2\\pi m_x\n$$\nwhere $m_x$ is an integer mode index ($m_x \\in \\mathbb{Z}$). This gives the expression for the allowed discrete values of $k_x$:\n$$\nk_x = \\frac{2\\pi m_x}{L_x}\n$$\nBy identical reasoning, the periodicity in the $y$ and $z$ directions leads to quantization of their respective wavenumber components:\n$$\nk_y = \\frac{2\\pi m_y}{L_y}\n$$\n$$\nk_z = \\frac{2\\pi m_z}{L_z}\n$$\nwhere $m_y$ and $m_z$ are also integer mode indices.\n\nThe problem states that the domain is discretized on a uniform grid with $N_x, N_y, N_z$ points and grid spacings $\\Delta x, \\Delta y, \\Delta z$. The total lengths of the domain are related to these grid parameters by:\n$L_x = N_x \\Delta x$\n$L_y = N_y \\Delta y$\n$L_z = N_z \\Delta z$\n\nSubstituting these expressions for the domain lengths into the wavenumber quantization formulas yields the wavenumbers in terms of the grid parameters:\n$$\nk_x = \\frac{2\\pi m_x}{N_x \\Delta x}\n$$\n$$\nk_y = \\frac{2\\pi m_y}{N_y \\Delta y}\n$$\n$$\nk_z = \\frac{2\\pi m_z}{N_z \\Delta z}\n$$\n\nThe problem also specifies that the parallel wavenumber is defined as $k_{\\parallel} \\equiv k_z$. Therefore:\n$$\nk_{\\parallel} = \\frac{2\\pi m_z}{N_z \\Delta z}\n$$\n\nThe range of resolvable wavenumbers is determined by the grid spacing, as stated by the Nyquist-Shannon sampling theorem. For a grid spacing of $\\Delta x$, the highest resolvable wavenumber magnitude is the Nyquist wavenumber, $k_{Ny,x} = \\frac{\\pi}{\\Delta x}$. This implies that the represented wavenumbers must satisfy $|k_x| \\le k_{Ny,x}$. Let's verify this is consistent with the provided integer index range.\n$$\n|k_x| = \\left| \\frac{2\\pi m_x}{N_x \\Delta x} \\right| \\le \\frac{\\pi}{\\Delta x}\n$$\n$$\n\\frac{2\\pi |m_x|}{N_x \\Delta x} \\le \\frac{\\pi}{\\Delta x} \\implies |m_x| \\le \\frac{N_x}{2}\n$$\nThe problem specifies that the integer mode indices $m_x$ belong to the set $\\{-N_x/2, \\dots, N_x/2 - 1\\}$. This asymmetric range for an even number of points $N_x$ is a standard convention for Discrete Fourier Transforms (DFTs), where the basis functions for the modes $m_x = -N_x/2$ and $m_x = N_x/2$ are identical on the grid, so only one is kept to ensure a unique basis. The provided range spans all unique modes from the most negative (the Nyquist mode) up to, but not including, the positive Nyquist mode. The expressions for $k_x$, $k_y$, and $k_z$ as functions of the mode indices $m_x$, $m_y$, and $m_z$ are the fundamental relations derived from periodicity and are independent of the specific range chosen for the DFT indices.\n\nCombining the results, the resolved wavenumber triplet $\\{k_x, k_y, k_{\\parallel}\\}$ is given by:\n$$\n\\left\\{ \\frac{2\\pi m_x}{N_x \\Delta x}, \\frac{2\\pi m_y}{N_y \\Delta y}, \\frac{2\\pi m_z}{N_z \\Delta z} \\right\\}\n$$\nThis expression is solely in terms of the required parameters: the integer indices $\\{m_x, m_y, m_z\\}$ and the grid/dimension parameters $\\{N_x, N_y, N_z, \\Delta x, \\Delta y, \\Delta z\\}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{2\\pi m_{x}}{N_{x} \\Delta x}  \\frac{2\\pi m_{y}}{N_{y} \\Delta y}  \\frac{2\\pi m_{z}}{N_{z} \\Delta z} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "A key challenge in analyzing data from discrete grids is the phenomenon of aliasing, where unresolved high-wavenumber modes masquerade as lower-wavenumber components, contaminating the spectrum. This hands-on exercise will guide you through calculating and observing this effect, demonstrating how a signal component beyond the Nyquist limit folds back into the resolved wavenumber band. Mastering this concept is essential for avoiding misinterpretation of spectral data and for designing simulations with adequate resolution. ",
            "id": "4180895",
            "problem": "You are analyzing one-dimensional turbulent wavenumber spectra that arise in fusion plasma turbulence simulation. Consider a spatially periodic domain of length $L$ sampled uniformly at $N$ grid points with spacing $\\Delta x = L/N$. Let the electrostatic potential field $\\phi(x)$ be synthesized as a finite sum of cosine modes with specified amplitudes in volts. The computed spectrum is obtained by the Discrete Fourier Transform (DFT) (implemented as the Fast Fourier Transform (FFT)). From first principles, the Nyquist-Shannon sampling theorem and the definitions of the DFT imply that sampling replicates the continuous spectrum with period $2\\pi/\\Delta x$, and that any mode with wavenumber magnitude above the Nyquist wavenumber folds into the principal resolved band. Your task is to calculate the aliasing contamination when a synthetic signal contains a mode beyond Nyquist and show how it maps onto lower wavenumbers in the computed spectrum.\n\nFundamental base:\n- Let the sample positions be $x_j = j \\Delta x$ for $j \\in \\{0,1,\\dots,N-1\\}$, and let the DFT wavenumbers be $k_n = \\frac{2\\pi n}{L}$ for integer indices $n$ in the nonnegative branch $n \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$, corresponding to the Real-valued FFT (RFFT) of a real signal.\n- The Nyquist wavenumber is $k_{\\mathrm{Ny}} = \\pi/\\Delta x$.\n- The spectrum computed by the DFT is discrete and band-limited to the principal branch defined by $|k| \\le k_{\\mathrm{Ny}}$.\n- A mode whose true wavenumber exceeds $k_{\\mathrm{Ny}}$ aliases (folds) into the principal branch due to the periodic replication of the spectrum induced by uniform sampling.\n\nDerivation objectives:\n- Starting from the Nyquist-Shannon sampling theorem and the DFT definitions, derive how a pure cosine mode with cycles-per-domain index $m$ maps into the discrete resolved band of indices $n \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ when $m$ exceeds the Nyquist index. Explain why certain pairs of distinct integers yield identical sampled cosines, and thereby identify the resolved index to which a beyond-Nyquist integer mode $m$ will appear in the FFT.\n- Establish the amplitude normalization for the RFFT magnitude such that an input cosine of amplitude $A$ volts produces a spectral amplitude equal to $A$ volts at its resolved wavenumber bin, with special handling for the zero-wavenumber (direct current) bin and, when $N$ is even, the Nyquist bin.\n- Define and compute an aliasing contamination measure as the fraction of the total resolved-band amplitude residing at the alias bin that is caused by the beyond-Nyquist mode. This should be a dimensionless decimal number.\n\nNumerical requirements:\n- Construct synthetic real-valued signals $\\phi(x)$ as sums of cosines $\\phi(x) = \\sum_i A_i \\cos\\!\\big(2\\pi m_i x/L\\big)$, where $A_i$ is in volts and $m_i$ is an integer cycles-per-domain index.\n- Compute the one-sided spectrum using the Real-valued FFT (RFFT), with wavenumbers $k_n = \\frac{2\\pi n}{L}$ in radians per meter (rad/m).\n- Normalize the spectral amplitudes so that the amplitude at a bin corresponding to an input cosine of amplitude $A$ volts equals $A$ volts:\n  - For bins $n$ with $1 \\le n \\le \\lfloor N/2 \\rfloor - 1$, use the factor $2/N$.\n  - For the zero-wavenumber bin $n=0$ and, when $N$ is even, the Nyquist bin $n=N/2$, use the factor $1/N$.\n- Identify the alias bin for each beyond-Nyquist mode using only the principles above (do not use any pre-supplied shortcut formulas), and report both the expected alias bin and the measured spectral peak values.\n\nUnits and outputs:\n- Report wavenumbers in radians per meter (rad/m).\n- Report amplitudes in volts (V).\n- Report contamination as a decimal number.\n- Angles in cosines are in radians.\n- Your program must output, for each test case, a list with six entries:\n  - The expected alias index (integer).\n  - The expected alias wavenumber (float, in rad/m).\n  - The measured global peak index of the spectrum (integer).\n  - The measured global peak wavenumber (float, in rad/m).\n  - The measured amplitude at the alias bin (float, in volts).\n  - The contamination ratio defined as the amplitude at the alias bin divided by the sum of amplitudes across all resolved bins (float, dimensionless).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3}]$). Each result must itself be a list of the six numerical entries defined above.\n\nTest suite:\n- Case $1$ (general mixed signal): $N=64$, $L=1.0$ m, modes $[(A_1,m_1)=(0.5,10),(A_2,m_2)=(1.0,50)]$.\n- Case $2$ (single beyond-Nyquist mode, different $L$): $N=64$, $L=2.0$ m, modes $[(A_1,m_1)=(1.0,60)]$.\n- Case $3$ (just beyond Nyquist with larger $N$): $N=128$, $L=1.0$ m, modes $[(A_1,m_1)=(0.8,65)]$.\n- Case $4$ (aliases to zero wavenumber): $N=64$, $L=1.5$ m, modes $[(A_1,m_1)=(1.2,64)]$.\n\nFinal output format:\n- A single line that is a Python-style list enclosing four inner lists (one per case), each inner list containing the six numerical entries in the order specified above, with no additional text.",
            "solution": "The problem requires an analysis of aliasing in one-dimensional wavenumber spectra, derived from first principles of digital signal processing and then verified numerically. The process involves three main stages: deriving the mapping rule for aliased wavenumbers, establishing the correct normalization for spectral amplitudes obtained via the Real-valued Fast Fourier Transform (RFFT), and applying these principles to compute specific metrics for a set of test cases.\n\n### Part 1: Derivation of the Alias Mapping Rule\n\nThe phenomenon of aliasing arises from the process of sampling a continuous signal. When a signal is sampled at discrete, uniform intervals, high-frequency components can become indistinguishable from low-frequency components. Our goal is to derive the rule that maps a mode's true integer wavenumber index, $m$, to its apparent, or aliased, index, $n_{\\text{alias}}$, in the resolved spectral band.\n\nLet the continuous signal be a pure cosine mode, $\\phi(x) = A \\cos(2\\pi m x/L)$, where $A$ is the amplitude, $L$ is the domain length, and $m$ is the integer number of cycles within the domain. The signal is sampled at $N$ points $x_j = j \\Delta x = j(L/N)$ for $j \\in \\{0, 1, \\dots, N-1\\}$. The sampled signal is:\n$$\n\\phi_j = \\phi(x_j) = A \\cos\\left(\\frac{2\\pi m (jL/N)}{L}\\right) = A \\cos\\left(\\frac{2\\pi m j}{N}\\right)\n$$\nThe Discrete Fourier Transform (DFT) analyzes this sampled signal in terms of a basis of discrete complex exponentials. A key property of these basis functions under sampling is their periodicity with respect to the frequency index. Specifically, for any integer $q$:\n$$\ne^{i 2\\pi (k+qN) j/N} = e^{i 2\\pi k j/N} e^{i 2\\pi q j} = e^{i 2\\pi k j/N} \\cdot 1 = e^{i 2\\pi k j/N}\n$$\nThis implies that frequency indices separated by multiples of $N$ are indistinguishable in the DFT. A mode with index $m$ is thus equivalent to a mode with index $m' = m \\pmod{N}$.\n\nFurthermore, for a real-valued signal, the cosine identity $\\cos(\\theta) = \\cos(-\\theta)$ introduces another equivalence. For the sampled signal:\n$$\n\\cos\\left(\\frac{2\\pi m' j}{N}\\right) = \\cos\\left(-\\frac{2\\pi m' j}{N}\\right) = \\cos\\left(\\frac{2\\pi (N-m') j}{N}\\right)\n$$\nThis shows that a mode with index $m'$ is indistinguishable from a mode with index $N-m'$.\n\nThe Real-valued FFT (RFFT) computes the spectrum over a one-sided band of non-negative indices, from $n=0$ up to the Nyquist index, $n_{\\text{Nyquist}} = \\lfloor N/2 \\rfloor$. Any true mode index $m$ must therefore map to an alias index $n_{\\text{alias}}$ within this range, i.e., $n_{\\text{alias}} \\in \\{0, 1, \\dots, \\lfloor N/2 \\rfloor\\}$.\n\nCombining the equivalences, the mapping rule is determined as follows:\n1.  Find the principal alias of the true index $m$ within the full DFT range $\\{0, 1, \\dots, N-1\\}$. This is given by $m' = m \\pmod{N}$.\n2.  Map this index $m'$ to the one-sided RFFT range $\\{0, 1, \\dots, \\lfloor N/2 \\rfloor\\}$.\n    - If $m' \\le \\lfloor N/2 \\rfloor$, the mode is already in the resolvable band, so $n_{\\text{alias}} = m'$.\n    - If $m'  \\lfloor N/2 \\rfloor$, the mode corresponds to a high-frequency component that folds back. Its indistinguishable counterpart is $N-m'$. Since $m'  N/2$, it follows that $N-m'  N/2$, which is in the resolvable band. Thus, $n_{\\text{alias}} = N - m'$.\n\nThis two-step process provides the expected alias index $n_{\\text{alias}}$ for any integer mode index $m$. The corresponding aliased wavenumber is then $k_{\\text{alias}} = 2\\pi n_{\\text{alias}}/L$.\n\n### Part 2: RFFT Amplitude Normalization\n\nThe problem requires that the computed spectral amplitude of a cosine mode with amplitude $A$ equals $A$. The raw output of an FFT algorithm, however, depends on the number of sample points $N$. We must establish the correct normalization factors.\n\nConsider a signal $\\phi_j = A \\cos(2\\pi m j/N)$ for an integer index $m$ such that $1 \\le m  N/2$. The DFT coefficient $\\hat{\\phi}_n$ is $\\sum_{j=0}^{N-1} \\phi_j e^{-i 2\\pi n j/N}$. Substituting the cosine as complex exponentials:\n$$\n\\hat{\\phi}_n = \\sum_{j=0}^{N-1} \\frac{A}{2} \\left( e^{i 2\\pi mj/N} + e^{-i 2\\pi mj/N} \\right) e^{-i 2\\pi nj/N} = \\frac{A}{2} \\left( \\sum_{j=0}^{N-1} e^{i 2\\pi(m-n)j/N} + \\sum_{j=0}^{N-1} e^{-i 2\\pi(m+n)j/N} \\right)\n$$\nThe geometric sum $\\sum_{j=0}^{N-1} e^{i 2\\pi k j/N}$ equals $N$ if $k$ is an integer multiple of $N$, and $0$ otherwise. For $1 \\le m, n  N/2$, the term $(m-n)$ is a multiple of $N$ only if $m=n$, and $(m+n)$ cannot be a multiple of $N$. Therefore, the DFT yields a non-zero value only at $n=m$: $\\hat{\\phi}_m = A N/2$.\nThe RFFT output corresponds to these DFT coefficients. To recover the physical amplitude $A$, the magnitude of the RFFT output, $|\\hat{\\phi}_m|$, must be scaled by $2/N$.\n\nSpecial cases are the DC ($n=0$) and Nyquist ($n=N/2$, for even $N$) bins.\n- For a DC signal $\\phi_j = A$, $\\hat{\\phi}_0 = \\sum_{j=0}^{N-1} A = AN$. The normalization factor is $1/N$.\n- For a Nyquist signal $\\phi_j = A \\cos(\\pi j)$, $\\hat{\\phi}_{N/2} = \\sum_{j=0}^{N-1} A\\cos(\\pi j)e^{-i\\pi j} = \\sum_{j=0}^{N-1} A(-1)^j(-1)^j = AN$. The normalization factor is also $1/N$.\n\nThis confirms the normalization scheme specified in the problem statement.\n\n### Part 3: Numerical Computation and Output Metrics\n\nThe numerical procedure for each test case is as follows:\n1.  Synthesize the signal $\\phi(x)$ at $N$ discrete points $x_j$ by summing the given cosine modes.\n2.  Compute the one-sided spectrum using `scipy.fft.rfft`.\n3.  Calculate the corresponding wavenumber array $k_n$ using `scipy.fft.rfftfreq`.\n4.  Normalize the absolute values of the RFFT output according to the derived factors ($1/N$ for DC and Nyquist bins, $2/N$ for all others) to obtain the physical amplitude spectrum, which we denote $S(k_n)$.\n\nFrom the problem statement and the principles above, we define the six output metrics for each case:\n1.  **Expected alias index:** The integer index $n_{\\text{alias}}$ calculated for the beyond-Nyquist mode using the derived mapping rule.\n2.  **Expected alias wavenumber:** The wavenumber $k_{\\text{alias}} = 2\\pi n_{\\text{alias}}/L$.\n3.  **Measured global peak index:** The index $n_{\\text{peak}}$ at which the normalized spectrum $S(k_n)$ has its maximum value: $n_{\\text{peak}} = \\arg\\max_{n} S(k_n)$.\n4.  **Measured global peak wavenumber:** The wavenumber $k_{n_{\\text{peak}}}$ corresponding to the measured peak index.\n5.  **Measured amplitude at the alias bin:** The amplitude of the normalized spectrum at the expected alias index, $S(k_{n_{\\text{alias}}})$.\n6.  **Contamination ratio:** The fraction of the total spectral power that resides in the alias bin. This is calculated as the ratio of the amplitude at the alias bin to the sum of all amplitudes across the resolved spectrum: $C = S(k_{n_{\\text{alias}}}) / \\sum_n S(k_n)$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import rfft, rfftfreq\n\ndef solve():\n    \"\"\"\n    Solves the aliasing analysis problem for a given set of test cases.\n    \"\"\"\n    test_cases = [\n        {'N': 64, 'L': 1.0, 'modes': [(0.5, 10), (1.0, 50)]},\n        {'N': 64, 'L': 2.0, 'modes': [(1.0, 60)]},\n        {'N': 128, 'L': 1.0, 'modes': [(0.8, 65)]},\n        {'N': 64, 'L': 1.5, 'modes': [(1.2, 64)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        modes = case['modes']\n\n        # Identify the beyond-Nyquist mode for theoretical prediction.\n        # If multiple exist, the problem setup implies we focus on one.\n        # The test cases only have one beyond-Nyquist mode each.\n        nyquist_index = N // 2\n        beyond_nyquist_mode_m = None\n        for amp, m in modes:\n            if m > nyquist_index:\n                beyond_nyquist_mode_m = m\n                break\n        \n        # 1. Calculate expected alias index and wavenumber\n        if beyond_nyquist_mode_m is not None:\n            m_prime = beyond_nyquist_mode_m % N\n            if m_prime > nyquist_index:\n                expected_alias_index = N - m_prime\n            else:\n                expected_alias_index = m_prime\n        else: # Handle cases with no beyond-Nyquist modes\n            expected_alias_index = -1 # Placeholder, not expected for test suite\n        \n        expected_alias_wavenumber = 2 * np.pi * expected_alias_index / L if expected_alias_index != -1 else 0.0\n\n        # Synthesize the signal\n        x = np.linspace(0, L, N, endpoint=False)\n        phi = np.zeros(N)\n        for amp, m in modes:\n            phi += amp * np.cos(2 * np.pi * m * x / L)\n\n        # Compute and normalize the spectrum\n        spec_raw = rfft(phi)\n        amplitudes = np.abs(spec_raw)\n        \n        # Apply normalization factors\n        if N % 2 == 0:  # N is even\n            # DC component\n            amplitudes[0] /= N\n            # Intermediate frequencies\n            amplitudes[1:-1] *= (2 / N)\n            # Nyquist component\n            amplitudes[-1] /= N\n        else:  # N is odd\n            # DC component\n            amplitudes[0] /= N\n            # All other frequencies\n            amplitudes[1:] *= (2 / N)\n\n        # Compute wavenumbers\n        wavenumbers = rfftfreq(N, d=L/N) * 2 * np.pi\n        \n        # 3. Find measured global peak index and wavenumber\n        measured_peak_index = np.argmax(amplitudes)\n        measured_peak_wavenumber = wavenumbers[measured_peak_index]\n\n        # 5. Get measured amplitude at the predicted alias bin\n        measured_amplitude_at_alias_bin = amplitudes[expected_alias_index] if expected_alias_index != -1 else 0.0\n\n        # 6. Calculate contamination ratio\n        total_amplitude = np.sum(amplitudes)\n        contamination_ratio = measured_amplitude_at_alias_bin / total_amplitude if total_amplitude > 0 else 0.0\n        \n        case_result = [\n            expected_alias_index,\n            expected_alias_wavenumber,\n            measured_peak_index,\n            measured_peak_wavenumber,\n            measured_amplitude_at_alias_bin,\n            contamination_ratio,\n        ]\n        results.append(case_result)\n\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "Wavenumber spectra are not merely static descriptions; they are windows into the dynamics of turbulence, particularly the transfer of energy across scales. This practice moves into the physical interpretation of spectral data by having you construct the cumulative energy flux, $\\Pi(k)$, from the spectral energy transfer function. By analyzing the sign of $\\Pi(k)$, you will learn to diagnose the direction of the turbulent energy cascadeâ€”a cornerstone of modern turbulence theory. ",
            "id": "4180917",
            "problem": "You are given the task of constructing and analyzing the cumulative scale-to-scale energy flux in wavenumber space for a two-dimensional turbulent field representative of fusion plasma turbulence. The analysis must be expressed in terms of the spectral energy transfer function. Assume a two-dimensional Fourier space with integer wavenumber coordinates $(p_x,p_y)$ on a square grid. Let the energy transfer function be denoted $T(\\boldsymbol{p})$, where $\\boldsymbol{p} = (p_x,p_y)$ and $|\\boldsymbol{p}| = \\sqrt{p_x^2 + p_y^2}$. You must construct synthetic, isotropic transfer fields $T(\\boldsymbol{p})$ that are consistent with conservation of energy in spectral space and compute the cumulative energy flux across wavenumber thresholds.\n\nFundamental base:\n- The nonlinear term in the dynamical equations governing turbulent flows conserves total quadratic invariants such as energy in the absence of forcing and dissipation. In spectral space this yields the property that the total energy transfer sums to zero: $$\\sum_{\\boldsymbol{p}} T(\\boldsymbol{p}) = 0.$$\n- The cumulative flux across a wavenumber threshold $k$ is defined as the net energy transferred into all modes with wavenumbers larger than $k$: $$\\Pi(k) = \\sum_{|\\boldsymbol{p}|k} T(\\boldsymbol{p}).$$\n- The sign of $\\Pi(k)$ indicates the cascade direction: if $\\Pi(k)  0$ over an interval of $k$, energy is transferred from lower wavenumbers to higher wavenumbers (forward cascade); if $\\Pi(k)  0$, energy is transferred from higher wavenumbers to lower wavenumbers (inverse cascade).\n\nYour tasks, for each test case below, are:\n- Construct a synthetic, isotropic transfer field $T(\\boldsymbol{p})$ on a square grid of size $N \\times N$ with $p_x, p_y \\in \\{-M, -M+1, \\dots, M-1, M\\}$ where $M = (N-1)/2$, using a smooth radial profile that changes sign across a characteristic radius $r_0$. Enforce spectral energy conservation by adjusting the field so that $\\sum_{\\boldsymbol{p}} T(\\boldsymbol{p}) = 0$.\n- Compute the cumulative flux $\\Pi(k)$ for each specified cutoff $k$ using the definition above.\n- Determine the cascade direction at each $k$ by the sign of $\\Pi(k)$: return a boolean that is $true$ if $\\Pi(k)  0$ (forward cascade) and $false$ otherwise (inverse or no net cascade).\n- Express all numerical outputs as dimensionless floats or booleans. Round floats to $6$ decimal places. No physical units are required for this synthetic analysis.\n\nUse the following test suite. Each test case provides $(N, r_0, w, A, \\{k\\})$, where $N$ is the grid size, $r_0$ is the characteristic radius, $w$ is a smoothness width, $A$ is an amplitude scaling, and $\\{k\\}$ is the list of cutoff radii to evaluate:\n- Test case $1$ (happy path, forward cascade): $(N, r_0, w, A, \\{k\\}) = (33, 6, 2, 1, \\{4,8,12,16,30\\})$. Construct $T(\\boldsymbol{p})$ using a smooth increasing radial function that is negative for $|\\boldsymbol{p}|  r_0$ and positive for $|\\boldsymbol{p}|  r_0$, then enforce $\\sum_{\\boldsymbol{p}} T(\\boldsymbol{p}) = 0$ by subtracting its mean over the grid.\n- Test case $2$ (edge case, inverse cascade): $(N, r_0, w, A, \\{k\\}) = (33, 6, 2, 1, \\{4,8,12,16,30\\})$. Use the same construction as test case $1$, but reverse the sign of $T(\\boldsymbol{p})$ to swap the roles of large and small wavenumbers.\n- Test case $3$ (boundary case, no cascade): $(N, r_0, w, A, \\{k\\}) = (33, 6, 2, 0, \\{4,8,12,16,30\\})$. Set $A = 0$ to produce $T(\\boldsymbol{p}) \\equiv 0$ everywhere, so that $\\Pi(k)$ must be zero for all $k$.\n\nAlgorithmic requirements:\n- The construction of $T(\\boldsymbol{p})$ must be isotropic and smooth in $|\\boldsymbol{p}|$, for example using a hyperbolic tangent profile $f(|\\boldsymbol{p}|) = \\tanh\\left(\\dfrac{|\\boldsymbol{p}| - r_0}{w}\\right)$ scaled by $A$. After construction, enforce spectral energy conservation by subtracting the mean value of $T$ over all grid points so that $\\sum_{\\boldsymbol{p}} T(\\boldsymbol{p}) = 0$.\n- For each cutoff $k$ in the test suite, compute $\\Pi(k)$ according to the definition above by summing $T(\\boldsymbol{p})$ over all grid points with $|\\boldsymbol{p}|  k$.\n\nAnswer specification and output format:\n- For each test case, return a pair of lists: the first list contains the flux values $\\Pi(k)$ for all provided $k$, rounded to $6$ decimal places; the second list contains booleans indicating forward cascade ($\\Pi(k)  0$) at each $k$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, aggregating the results of all provided test cases, with no spaces anywhere in the line. The output must therefore have the form $$\\left[ \\left[ \\left[ \\Pi_1(k_1), \\dots, \\Pi_1(k_m) \\right], \\left[ b_1, \\dots, b_m \\right] \\right], \\left[ \\left[ \\Pi_2(k_1), \\dots, \\Pi_2(k_m) \\right], \\left[ b_1, \\dots, b_m \\right] \\right], \\left[ \\left[ \\Pi_3(k_1), \\dots, \\Pi_3(k_m) \\right], \\left[ b_1, \\dots, b_m \\right] \\right] \\right],$$ where $m$ is the number of cutoffs in each case, and $b_j$ are booleans computed as $b_j = (\\Pi(k_j)  0)$.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of fluid and plasma turbulence, is well-posed with a clear and complete set of instructions, and is stated in objective, formal language. A solution can be constructed following the specified algorithmic requirements.\n\nThe solution involves a numerical implementation of concepts from spectral analysis of turbulence. The core task is to construct a synthetic energy transfer function $T(\\boldsymbol{p})$ in a two-dimensional wavenumber space, enforce a physical conservation law, and then compute a diagnostic quantity, the cumulative energy flux $\\Pi(k)$, to analyze the direction of energy cascade.\n\n### Step 1: Wavenumber Grid Generation\nThe problem is set in a two-dimensional, discrete Fourier (wavenumber) space. The grid is a square of size $N \\times N$. The integer wavenumber coordinates $(p_x, p_y)$ are defined to be centered around zero. For a given grid size $N$, which is specified to be odd, we define $M = (N-1)/2$. The coordinates for both $p_x$ and $p_y$ then range over the integers from $-M$ to $M$: $p_x, p_y \\in \\{-M, -M+1, \\dots, M-1, M\\}$.\n\nFirst, we generate one-dimensional arrays representing the coordinate values for $p_x$ and $p_y$. Using these, we construct two $N \\times N$ matrices, one for the $p_x$ coordinates of each grid point and one for the $p_y$ coordinates. From these coordinate matrices, we compute the matrix of radial wavenumber magnitudes, $|\\boldsymbol{p}|$, for each point $\\boldsymbol{p} = (p_x, p_y)$ on the grid using the Euclidean norm:\n$$\n|\\boldsymbol{p}| = \\sqrt{p_x^2 + p_y^2}\n$$\nThis $|\\boldsymbol{p}|$ matrix is essential for constructing an isotropic field and for applying the wavenumber cutoffs.\n\n### Step 2: Construction of the Synthetic Energy Transfer Field $T(\\boldsymbol{p})$\nThe energy transfer function $T(\\boldsymbol{p})$ describes the net rate of energy transfer into (+) or out of (-) the mode with wavenumber $\\boldsymbol{p}$ due to nonlinear interactions. We are instructed to create a synthetic, isotropic field based on a smooth radial profile.\n\nThe chosen profile is a hyperbolic tangent function, which creates a smooth transition from a negative to a positive value across a characteristic radius $r_0$ with a transition width $w$:\n$$\nT_{raw}(\\boldsymbol{p}) = A \\cdot \\tanh\\left(\\frac{|\\boldsymbol{p}| - r_0}{w}\\right)\n$$\nHere, $A$ is an amplitude scaling factor. This function models a scenario where energy is systematically removed from modes with small wavenumbers ($|\\boldsymbol{p}|  r_0$) and deposited into modes with large wavenumbers ($|\\boldsymbol{p}|  r_0$).\n\nA fundamental property of the nonlinear terms in ideal, unforced, and undissipated turbulent systems is the conservation of total energy. In spectral space, this translates to the condition that the sum of the energy transfer over all modes must be zero:\n$$\n\\sum_{\\boldsymbol{p}} T(\\boldsymbol{p}) = 0\n$$\nOur synthetic field $T_{raw}(\\boldsymbol{p})$ does not generally satisfy this condition. To enforce it, we subtract the mean value of $T_{raw}$ from every point on the grid. Let the total number of grid points be $N_{grid} = N^2$. The mean is $\\bar{T}_{raw} = \\frac{1}{N_{grid}} \\sum_{\\boldsymbol{p}} T_{raw}(\\boldsymbol{p})$. The final, conserved transfer function is:\n$$\nT(\\boldsymbol{p}) = T_{raw}(\\boldsymbol{p}) - \\bar{T}_{raw}\n$$\nThis procedure guarantees that $\\sum_{\\boldsymbol{p}} T(\\boldsymbol{p}) = 0$.\n\n### Step 3: Computation of the Cumulative Energy Flux $\\Pi(k)$\nThe cumulative energy flux $\\Pi(k)$ quantifies the net energy transfer across a spherical shell of radius $k$ in wavenumber space. It is defined as the sum of all energy transfers into modes with wavenumbers larger than $k$:\n$$\n\\Pi(k) = \\sum_{|\\boldsymbol{p}|  k} T(\\boldsymbol{p})\n$$\nTo compute this for a given cutoff $k$, we identify all grid points $(p_x, p_y)$ for which the condition $|\\boldsymbol{p}|  k$ is met. We then sum the values of our conserved field $T(\\boldsymbol{p})$ at these specific grid points. This sum gives the value of $\\Pi(k)$.\n\n### Step 4: Determination of Cascade Direction\nThe sign of $\\Pi(k)$ indicates the dominant direction of the energy cascade across the scale $k$.\n- If $\\Pi(k)  0$, there is a net flux of energy towards higher wavenumbers (smaller spatial scales). This is a **forward cascade**.\n- If $\\Pi(k)  0$, there is a net flux of energy towards lower wavenumbers (larger spatial scales). This is an **inverse cascade**.\n- If $\\Pi(k) = 0$, there is no net flux across the scale $k$.\n\nFor each computed $\\Pi(k)$, we evaluate the boolean condition $\\Pi(k)  0$ to determine if the cascade is forward.\n\n### Step 5: Test Case Implementation\nThe procedure is applied to each test case:\n- **Test Case 1 (Forward Cascade)**: With $A=1$, $r_0=6$, the initial field $T_{raw}(\\boldsymbol{p})$ is negative for $|\\boldsymbol{p}|  6$ and positive for $|\\boldsymbol{p}|  6$. This setup is designed to model a forward energy cascade, so we expect $\\Pi(k)  0$ for the given $k$ values.\n- **Test Case 2 (Inverse Cascade)**: The parameters are identical to Case 1, but the problem requires reversing the sign of the final, conserved transfer function, i.e., $T_{case2}(\\boldsymbol{p}) = -T_{case1}(\\boldsymbol{p})$. This flips the sign of all transfers. Consequently, the cumulative flux will also be negated: $\\Pi_{case2}(k) = -\\Pi_{case1}(k)$. This models an inverse cascade, and we expect $\\Pi(k)  0$.\n- **Test Case 3 (No Cascade)**: With $A=0$, the initial field $T_{raw}(\\boldsymbol{p})$ is identically zero for all $\\boldsymbol{p}$. The mean is zero, and the final field $T(\\boldsymbol{p})$ is also zero everywhere. Therefore, any sum over this field will be zero, resulting in $\\Pi(k) = 0$ for all $k$. This tests the baseline case of no energy transfer.\n\nThe final numerical results for $\\Pi(k)$ are rounded to six decimal places as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes the cumulative scale-to-scale energy flux in \n    wavenumber space for synthetic 2D turbulent fields.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # The parameters are (N, r_0, w, A, k_list).\n    test_case_data = [\n        (33, 6, 2, 1, [4, 8, 12, 16, 30]),  # Test Case 1\n        (33, 6, 2, 1, [4, 8, 12, 16, 30]),  # Test Case 2\n        (33, 6, 2, 0, [4, 8, 12, 16, 30]),  # Test Case 3\n    ]\n\n    all_results = []\n    # Process each test case using its index to apply special rules.\n    for i, case in enumerate(test_case_data):\n        N, r_0, w, A, k_list = case\n\n        # 1. Grid Generation\n        M = (N - 1) // 2\n        p_coords = np.arange(-M, M + 1)\n        p_x, p_y = np.meshgrid(p_coords, p_coords, indexing='xy')\n        p_mag = np.sqrt(p_x**2 + p_y**2)\n\n        # 2. Construct Initial Transfer Field\n        # For A=0 (Case 3), T_raw will correctly be an array of zeros.\n        T_raw = A * np.tanh((p_mag - r_0) / w)\n\n        # 3. Enforce Energy Conservation\n        mean_T = np.mean(T_raw)\n        T_conserved = T_raw - mean_T\n\n        # 4. Handle Case-Specific Logic from the problem description\n        T_final = T_conserved\n        if i == 1:  # Case 2: \"reverse the sign of T(p)\"\n            T_final = -T_conserved\n\n        # 5. Compute Cumulative Flux and Determine Cascade Direction\n        flux_values = []\n        cascade_directions = []\n        for k in k_list:\n            mask = p_mag > k\n            pi_k = np.sum(T_final[mask])\n            flux_values.append(pi_k)\n            cascade_directions.append(pi_k > 0)\n        \n        all_results.append([flux_values, cascade_directions])\n\n    # Final print statement in the exact required format.\n    # The string must be built without spaces, so standard list-to-string conversion\n    # is not suitable.\n    case_strings = []\n    for result_struct in all_results:\n        fluxes, bools = result_struct\n        \n        # Format list of floats to \"[-0.123456,1.234567,...]\"\n        fluxes_str = f\"[{','.join([f'{f:.6f}' for f in fluxes])}]\"\n        \n        # Format list of booleans to \"[false,true,...]\"\n        bools_str = f\"[{','.join([str(b).lower() for b in bools])}]\"\n        \n        # Combine into a single case result string \"[[...],[...]]\"\n        case_str = f\"[{fluxes_str},{bools_str}]\"\n        case_strings.append(case_str)\n        \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}