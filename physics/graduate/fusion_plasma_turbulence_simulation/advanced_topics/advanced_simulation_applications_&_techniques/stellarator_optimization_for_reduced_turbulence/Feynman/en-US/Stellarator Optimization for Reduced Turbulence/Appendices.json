{
    "hands_on_practices": [
        {
            "introduction": "To understand and control turbulence in a stellarator, we must first master the description of how plasma particles and waves move along its complex magnetic field lines. The parallel streaming operator, $v_{\\parallel}\\mathbf{b}\\cdot\\nabla$, is a cornerstone of this description, appearing frequently in advanced kinetic and fluid models. This exercise  offers a foundational, hands-on opportunity to implement the field-line-following coordinate system and compute this crucial term, providing direct insight into the fundamental dynamics that stellarator optimization seeks to control.",
            "id": "4201414",
            "problem": "You are asked to implement the field-line-following coordinate transform in a large-aspect-ratio toroidal geometry and compute the parallel streaming term $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla$ acting on a scalar field along a selected magnetic field line for a given rotational transform profile $\\iota(\\psi)$. The overarching motivation is to quantify a streaming strength metric that can be used in stellarator optimization for reduced turbulence. The program must be a complete, runnable Python script that performs the following tasks for a set of test cases.\n\nFundamental base and definitions: Consider a magnetostatic magnetic field $\\mathbf{B}$ such that $\\nabla\\cdot\\mathbf{B}=0$ and field lines follow the unit vector $\\mathbf{b}=\\mathbf{B}/|\\mathbf{B}|$. In a torus of major radius $R_0$ and circular minor radius $r\\in[0,a]$, define cylindrical angles $(\\theta,\\phi)$, where $\\theta$ is the poloidal angle and $\\phi$ is the toroidal angle. The position mapping is $R(\\theta)=R_0+r\\cos\\theta$ and $Z(\\theta)=r\\sin\\theta$, with $R(\\theta)$ used for the azimuthal scale factor. In the orthogonal coordinates $(r,\\theta,\\phi)$ with scale factors $h_r=1$, $h_\\theta=r$, and $h_\\phi=R(\\theta)$, the gradient operator acting on a scalar $f(r,\\theta,\\phi)$ is\n$$\n\\nabla f=\\frac{\\partial f}{\\partial r}\\,\\mathbf{e}_r+\\frac{1}{r}\\frac{\\partial f}{\\partial \\theta}\\,\\mathbf{e}_\\theta+\\frac{1}{R(\\theta)}\\frac{\\partial f}{\\partial \\phi}\\,\\mathbf{e}_\\phi.\n$$\nAssume a dominant toroidal magnetic field $B_\\phi(\\theta)=B_0\\,\\frac{R_0}{R(\\theta)}$ and a poloidal magnetic field $B_\\theta(\\theta)$ chosen to realize a desired rotational transform $\\iota(\\psi)$ via the field-line relation\n$$\n\\frac{d\\theta}{d\\phi}=\\frac{\\mathbf{B}\\cdot\\nabla\\theta}{\\mathbf{B}\\cdot\\nabla\\phi}=\\iota(\\psi)=\\frac{B_\\theta(\\theta)\\,R(\\theta)}{B_\\phi(\\theta)\\,r},\n$$\nwhich yields $B_\\theta(\\theta)=\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}$. Treat $r$ as a constant along the field line (no radial drift), so $\\psi$ depends only on $r$. Use a dimensionless flux label\n$$\n\\psi=\\left(\\frac{r}{a}\\right)^2.\n$$\nDefine the field-line-following coordinate transform $(\\psi,\\theta,\\phi)\\mapsto(\\psi,\\alpha,\\phi)$ by\n$$\n\\alpha=\\theta-\\iota(\\psi)\\,\\phi,\n$$\nso a field line at fixed $\\psi$ is a curve of constant $\\alpha$ parameterized by $\\phi$.\n\nParallel streaming operator: The operator of interest is $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla$ acting on a dimensionless scalar field $g(\\psi,\\theta,\\phi)$. Along a field line at fixed $\\psi$ and constant $\\alpha$, express the operator in terms of $(\\theta(\\phi),\\phi)$ and the local magnetic field.\n\nScalar field specification: Use a dimensionless scalar field\n$$\ng(\\psi,\\theta,\\phi)=\\sin\\!\\big(m_1\\,\\theta+n_1\\,\\phi\\big)+c_2\\,\\cos\\!\\big(p_2\\,\\theta-q_2\\,\\phi\\big),\n$$\nwith integers $m_1,n_1,p_2,q_2$ and a real amplitude $c_2$. Angles must be in radians.\n\nTask requirements:\n- Implement the coordinate transform $\\alpha=\\theta-\\iota(\\psi)\\,\\phi$ and represent a field line by $\\alpha=\\text{constant}$ and $\\psi=\\text{constant}$.\n- For a given $\\iota(\\psi)$, compute $\\theta(\\phi)=\\alpha+\\iota(\\psi)\\,\\phi$ along the field line for $\\phi\\in[0,2\\pi)$.\n- Compute $R(\\theta)$, $B_\\phi(\\theta)=B_0\\,\\frac{R_0}{R(\\theta)}$, $B_\\theta(\\theta)=\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}$, and $|\\mathbf{B}(\\theta)|=\\sqrt{B_\\phi(\\theta)^2+B_\\theta(\\theta)^2}$.\n- Compute the parallel streaming term $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g$ along the field line and return a streaming strength metric defined as the root-mean-square over one toroidal transit,\n$$\nS_{\\mathrm{RMS}}=\\left(\\frac{1}{2\\pi}\\int_0^{2\\pi}\\big[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g\\big]^2\\,d\\phi\\right)^{1/2}.\n$$\n- Express the final answers in $\\mathrm{s}^{-1}$, rounded to six decimal places.\n\nRotational transform profile: Use a polynomial profile\n$$\n\\iota(\\psi)=\\iota_0+s_1\\,\\psi+s_2\\,\\psi^2,\n$$\nwhere $\\iota_0$, $s_1$, and $s_2$ are real parameters.\n\nTest suite and coverage: Your program must evaluate $S_{\\mathrm{RMS}}$ for the following four test cases, covering a general case, near-axis behavior, high transform, and strong geometry variation. All angles are in radians. All lengths are in meters. Magnetic field is in tesla. Parallel speed is in meters per second. The flux label $\\psi$ is dimensionless as defined above. The scalar field $g$ parameters are dimensionless.\n\n- Test case $1$ (general case):\n    - $R_0=3.0$, $a=0.3$, $r=0.15$, $B_0=3.0$, $v_{\\parallel}=1.0\\times 10^5$, $\\alpha=0.2$,\n    - $\\iota_0=0.4$, $s_1=0.3$, $s_2=0.0$,\n    - $m_1=2$, $n_1=1$, $c_2=0.35$, $p_2=3$, $q_2=2$.\n\n- Test case $2$ (near-axis limit):\n    - $R_0=3.0$, $a=0.3$, $r=1.0\\times 10^{-6}$, $B_0=3.0$, $v_{\\parallel}=1.0\\times 10^5$, $\\alpha=0.0$,\n    - $\\iota_0=0.8$, $s_1=0.0$, $s_2=0.0$,\n    - $m_1=1$, $n_1=3$, $c_2=0.20$, $p_2=4$, $q_2=1$.\n\n- Test case $3$ (high transform with shear and curvature):\n    - $R_0=1.5$, $a=0.5$, $r=0.25$, $B_0=2.5$, $v_{\\parallel}=2.0\\times 10^5$, $\\alpha=1.0$,\n    - $\\iota_0=1.0$, $s_1=-0.5$, $s_2=0.2$,\n    - $m_1=3$, $n_1=2$, $c_2=0.40$, $p_2=1$, $q_2=3$.\n\n- Test case $4$ (strong geometry variation, low transform baseline):\n    - $R_0=4.0$, $a=0.8$, $r=0.4$, $B_0=5.0$, $v_{\\parallel}=0.5\\times 10^5$, $\\alpha=2.0$,\n    - $\\iota_0=0.2$, $s_1=0.6$, $s_2=-0.1$,\n    - $m_1=5$, $n_1=0$, $c_2=0.0$, $p_2=0$, $q_2=0$.\n\nNumerical integration and output:\n- Approximate the integral over $\\phi$ using a uniform discretization of $N=4096$ points in $\\phi\\in[0,2\\pi)$.\n- Your program should produce a single line of output containing the results as a comma-separated list of four floating-point numbers, each rounded to six decimal places and expressed in $\\mathrm{s}^{-1}$, enclosed in square brackets (for example, \"[$x_1,x_2,x_3,x_4$]\").",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded computational task within the field of plasma physics. We will proceed with a full solution. The objective is to compute a streaming strength metric, $S_{\\mathrm{RMS}}$, for a scalar field along a magnetic field line in a simplified toroidal magnetic geometry. This requires deriving the parallel streaming operator and then implementing a numerical procedure to evaluate its root-mean-square (RMS) value.\n\nFirst, we establish the analytical form of the parallel streaming operator, $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla$. In the specified orthogonal coordinate system $(r,\\theta,\\phi)$ with scale factors $h_r=1$, $h_\\theta=r$, and $h_\\phi=R(\\theta)=R_0+r\\cos\\theta$, the gradient of a scalar field $f(r,\\theta,\\phi)$ is given by:\n$$\n\\nabla f = \\frac{\\partial f}{\\partial r}\\,\\mathbf{e}_r + \\frac{1}{r}\\frac{\\partial f}{\\partial \\theta}\\,\\mathbf{e}_\\theta + \\frac{1}{R(\\theta)}\\frac{\\partial f}{\\partial \\phi}\\,\\mathbf{e}_\\phi\n$$\nThe problem defines a magnetostatic field $\\mathbf{B}$ and assumes that field lines lie on surfaces of constant radius $r$. This implies that the radial component of the magnetic field, $B_r$, is zero. Thus, the magnetic field can be written as:\n$$\n\\mathbf{B} = B_\\theta(\\theta)\\,\\mathbf{e}_\\theta + B_\\phi(\\theta)\\,\\mathbf{e}_\\phi\n$$\nThe unit vector along the magnetic field is $\\mathbf{b} = \\mathbf{B}/|\\mathbf{B}|$. The action of the operator $\\mathbf{B}\\cdot\\nabla$ on a scalar field $g(r, \\theta, \\phi)$ is:\n$$\n\\mathbf{B}\\cdot\\nabla g = \\left( B_\\theta\\,\\mathbf{e}_\\theta + B_\\phi\\,\\mathbf{e}_\\phi \\right) \\cdot \\left( \\frac{\\partial g}{\\partial r}\\,\\mathbf{e}_r + \\frac{1}{r}\\frac{\\partial g}{\\partial \\theta}\\,\\mathbf{e}_\\theta + \\frac{1}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi}\\,\\mathbf{e}_\\phi \\right)\n$$\nDue to orthogonality of the basis vectors and $B_r=0$, this simplifies to:\n$$\n\\mathbf{B}\\cdot\\nabla g = \\frac{B_\\theta(\\theta)}{r}\\frac{\\partial g}{\\partial \\theta} + \\frac{B_\\phi(\\theta)}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi}\n$$\nThe partial derivatives are taken with respect to the coordinates $(\\psi, \\theta, \\phi)$ (or equivalently $(r, \\theta, \\phi)$ since $\\psi$ is a function of $r$ only), holding the other coordinates constant. The parallel gradient operator $\\mathbf{b}\\cdot\\nabla g$ is therefore:\n$$\n\\mathbf{b}\\cdot\\nabla g = \\frac{\\mathbf{B}\\cdot\\nabla g}{|\\mathbf{B}|} = \\frac{1}{|\\mathbf{B}(\\theta)|} \\left( \\frac{B_\\theta(\\theta)}{r}\\frac{\\partial g}{\\partial \\theta} + \\frac{B_\\phi(\\theta)}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi} \\right)\n$$\nwhere $|\\mathbf{B}(\\theta)| = \\sqrt{B_\\phi(\\theta)^2 + B_\\theta(\\theta)^2}$.\n\nThe poloidal field $B_\\theta(\\theta)$ is defined via the rotational transform $\\iota(\\psi)$ as $B_\\theta(\\theta)=\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}$. Substituting this into the expression for $\\mathbf{b}\\cdot\\nabla g$:\n$$\n\\mathbf{b}\\cdot\\nabla g = \\frac{1}{|\\mathbf{B}(\\theta)|} \\left( \\frac{1}{r} \\left(\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}\\right) \\frac{\\partial g}{\\partial \\theta} + \\frac{B_\\phi(\\theta)}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi} \\right)\n$$\nThe factor of $r$ cancels, yielding a more convenient form:\n$$\n\\mathbf{b}\\cdot\\nabla g = \\frac{B_\\phi(\\theta)}{R(\\theta)\\,|\\mathbf{B}(\\theta)|} \\left( \\iota(\\psi)\\frac{\\partial g}{\\partial \\theta} + \\frac{\\partial g}{\\partial \\phi} \\right)\n$$\nThis expression is evaluated along a specific magnetic field line. A field line is defined by a constant flux label $\\psi$ (and thus constant $r$) and a constant field-line label $\\alpha = \\theta - \\iota(\\psi)\\phi$. The poloidal angle $\\theta$ varies with the toroidal angle $\\phi$ according to $\\theta(\\phi) = \\alpha + \\iota(\\psi)\\phi$.\n\nThe specified scalar field is $g(\\psi,\\theta,\\phi)=\\sin(m_1\\,\\theta+n_1\\,\\phi)+c_2\\,\\cos(p_2\\,\\theta-q_2\\,\\phi)$. Its partial derivatives are:\n$$\n\\frac{\\partial g}{\\partial \\theta} = m_1 \\cos(m_1\\theta + n_1\\phi) - p_2 c_2 \\sin(p_2\\theta - q_2\\phi)\n$$\n$$\n\\frac{\\partial g}{\\partial \\phi} = n_1 \\cos(m_1\\theta + n_1\\phi) + q_2 c_2 \\sin(p_2\\theta - q_2\\phi)\n$$\n\nThe final metric is the streaming strength $S_{\\mathrm{RMS}}$, defined as the RMS of the parallel streaming term over one toroidal transit ($\\phi \\in [0,2\\pi)$):\n$$\nS_{\\mathrm{RMS}}=\\left(\\frac{1}{2\\pi}\\int_0^{2\\pi}\\big[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g\\big]^2\\,d\\phi\\right)^{1/2}\n$$\nThe integral is approximated numerically using a discrete sum over $N=4096$ points in $\\phi$. Let $\\phi_j = j \\frac{2\\pi}{N}$ for $j = 0, 1, \\dots, N-1$. The integral is then approximated as:\n$$\n\\int_0^{2\\pi} f(\\phi) \\, d\\phi \\approx \\sum_{j=0}^{N-1} f(\\phi_j) \\Delta\\phi = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} f(\\phi_j)\n$$\nTherefore, the RMS metric becomes:\n$$\nS_{\\mathrm{RMS}} \\approx \\left(\\frac{1}{2\\pi} \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} \\left[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g\\right]^2_{\\phi=\\phi_j} \\right)^{1/2} = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g(\\phi_j)\\right]^2 \\right)^{1/2}\n$$\n\nThe computational procedure for each test case is as follows:\n1.  Unpack the physical and geometric parameters: $R_0, a, r, B_0, v_{\\parallel}, \\alpha$, the rotational transform parameters $\\iota_0, s_1, s_2$, and the scalar field parameters $m_1, n_1, c_2, p_2, q_2$.\n2.  Calculate the constant values for the field line:\n    -   $\\psi = (r/a)^2$.\n    -   $\\iota(\\psi) = \\iota_0 + s_1\\psi + s_2\\psi^2$.\n3.  Create a discrete grid of $N=4096$ points for the toroidal angle: $\\phi_j$ for $j=0, \\dots, N-1$.\n4.  For each point $\\phi_j$ on the grid:\n    a.  Compute the poloidal angle on the field line: $\\theta_j = \\alpha + \\iota(\\psi)\\phi_j$.\n    b.  Compute the major radius position: $R(\\theta_j) = R_0 + r \\cos(\\theta_j)$.\n    c.  Compute the magnetic field components: $B_{\\phi,j} = B_0 \\frac{R_0}{R(\\theta_j)}$ and $B_{\\theta,j} = \\iota(\\psi) B_{\\phi,j} \\frac{r}{R(\\theta_j)}$.\n    d.  Compute the magnetic field magnitude: $|\\mathbf{B}_j| = \\sqrt{B_{\\phi,j}^2 + B_{\\theta,j}^2}$.\n    e.  Evaluate the partial derivatives $\\partial g/\\partial\\theta$ and $\\partial g/\\partial\\phi$ at $(\\theta_j, \\phi_j)$.\n    f.  Assemble the parallel gradient: $(\\mathbf{b}\\cdot\\nabla g)_j = \\frac{B_{\\phi,j}}{R(\\theta_j)|\\mathbf{B}_j|} \\left( \\iota(\\psi) \\left(\\frac{\\partial g}{\\partial \\theta}\\right)_j + \\left(\\frac{\\partial g}{\\partial \\phi}\\right)_j \\right)$.\n    g.  Calculate the squared streaming term: $T_j = \\left(v_{\\parallel}(\\mathbf{b}\\cdot\\nabla g)_j\\right)^2$.\n5.  Compute the mean of the squared terms: $\\bar{T} = \\frac{1}{N} \\sum_{j=0}^{N-1} T_j$.\n6.  The final metric is the square root of this mean: $S_{\\mathrm{RMS}} = \\sqrt{\\bar{T}}$.\n7.  The result is then rounded to six decimal places, and its units are $\\mathrm{s}^{-1}$.\n\nThis procedure will be implemented for each of the four specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation for all test cases.\n    \"\"\"\n    \n    # Test cases as provided in the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {'R0': 3.0, 'a': 0.3, 'r': 0.15, 'B0': 3.0, 'v_par': 1.0e5, 'alpha': 0.2,\n         'iota0': 0.4, 's1': 0.3, 's2': 0.0,\n         'm1': 2, 'n1': 1, 'c2': 0.35, 'p2': 3, 'q2': 2},\n        # Test case 2 (near-axis limit)\n        {'R0': 3.0, 'a': 0.3, 'r': 1.0e-6, 'B0': 3.0, 'v_par': 1.0e5, 'alpha': 0.0,\n         'iota0': 0.8, 's1': 0.0, 's2': 0.0,\n         'm1': 1, 'n1': 3, 'c2': 0.20, 'p2': 4, 'q2': 1},\n        # Test case 3 (high transform with shear and curvature)\n        {'R0': 1.5, 'a': 0.5, 'r': 0.25, 'B0': 2.5, 'v_par': 2.0e5, 'alpha': 1.0,\n         'iota0': 1.0, 's1': -0.5, 's2': 0.2,\n         'm1': 3, 'n1': 2, 'c2': 0.40, 'p2': 1, 'q2': 3},\n        # Test case 4 (strong geometry variation, low transform baseline)\n        {'R0': 4.0, 'a': 0.8, 'r': 0.4, 'B0': 5.0, 'v_par': 0.5e5, 'alpha': 2.0,\n         'iota0': 0.2, 's1': 0.6, 's2': -0.1,\n         'm1': 5, 'n1': 0, 'c2': 0.0, 'p2': 0, 'q2': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        s_rms = calculate_streaming_metric(**params)\n        results.append(s_rms)\n\n    # Format the final output string exactly as required.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_streaming_metric(R0, a, r, B0, v_par, alpha, iota0, s1, s2, m1, n1, c2, p2, q2):\n    \"\"\"\n    Calculates the streaming strength metric S_RMS for a single test case.\n    \"\"\"\n    # Number of points for numerical integration\n    N = 4096\n\n    # Calculate constant parameters for the field line\n    psi = (r / a)**2\n    iota = iota0 + s1 * psi + s2 * psi**2\n\n    # Create the grid for the toroidal angle phi\n    phi = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # Calculate poloidal angle theta along the field line\n    theta = alpha + iota * phi\n\n    # Calculate geometric and magnetic field quantities along the field line\n    R_theta = R0 + r * np.cos(theta)\n    B_phi = B0 * R0 / R_theta\n    B_theta = iota * B_phi * r / R_theta\n    B_mag = np.sqrt(B_phi**2 + B_theta**2)\n\n    # Define arguments for the trigonometric functions in g\n    arg1 = m1 * theta + n1 * phi\n    arg2 = p2 * theta - q2 * phi\n\n    # Calculate partial derivatives of the scalar field g\n    # g = sin(arg1) + c2 * cos(arg2)\n    dg_dtheta = m1 * np.cos(arg1) - p2 * c2 * np.sin(arg2)\n    dg_dphi = n1 * np.cos(arg1) + q2 * c2 * np.sin(arg2)\n\n    # Calculate the parallel gradient of g\n    # b_dot_grad_g = (B_phi / (R_theta * B_mag)) * (iota * dg_dtheta + dg_dphi)\n    iota_dg_dtheta_plus_dg_dphi = iota * dg_dtheta + dg_dphi\n    b_dot_grad_g = (B_phi / (R_theta * B_mag)) * iota_dg_dtheta_plus_dg_dphi\n\n    # Calculate the full streaming term\n    streaming_term = v_par * b_dot_grad_g\n\n    # Calculate the RMS value\n    s_rms_squared = np.mean(streaming_term**2)\n    s_rms = np.sqrt(s_rms_squared)\n    \n    return s_rms\n\nsolve()\n```"
        },
        {
            "introduction": "The core principle of stellarator optimization is the deliberate shaping of the magnetic geometry to create a more stable plasma environment. This requires a deep understanding of the interplay between large-scale equilibrium properties and small-scale micro-instabilities. This practice  guides you through a concrete example of this connection, tasking you with quantifying how the pressure-driven Shafranov shift modifies the local magnetic curvature and, in turn, affects the growth rate of Ion Temperature Gradient (ITG) modes, a primary driver of turbulence.",
            "id": "4201407",
            "problem": "You will implement a physically consistent, large-aspect-ratio model to compute the Shafranov shift and its impact on local curvature, and then evaluate the resulting change in the Ion Temperature Gradient (ITG) growth rate for a specified pressure profile. Your program must aggregate results for a defined test suite and output them in a single line.\n\nStart from the fundamental force balance of Magnetohydrodynamics (MHD), namely the static equilibrium condition $ \\nabla p = \\mathbf{j} \\times \\mathbf{B} $, and use a large-aspect-ratio, circular-flux-surface approximation where the dominant magnetic field is toroidal, with magnitude $ B $ treated as constant over the region of interest. In this limit, the outward Shafranov shift $ \\Delta(r) $ scales with the normalized plasma pressure (beta) and the geometric factor $ r^2 / R_0 $, where $ r $ is the minor radius of the flux surface and $ R_0 $ is the major radius. Adopt the following model for the Shafranov shift:\n$$\n\\Delta(r) = \\frac{\\mu_0 \\, p(r)}{B^2} \\, \\frac{r^2}{R_0},\n$$\nwhere $ \\mu_0 $ is the magnetic permeability of free space, $ p(r) $ is the local plasma pressure, and $ B $ is the toroidal magnetic field magnitude.\n\nModel the bad toroidal curvature magnitude as\n$$\n\\kappa_c(r) = \\frac{1}{R_0 + \\Delta(r)},\n$$\nso that an outward Shafranov shift $ \\Delta(r) > 0 $ reduces the curvature magnitude.\n\nUse an Ion Temperature Gradient (ITG) fluid-like surrogate that captures the competition between the ion temperature gradient drive and the curvature drift stabilization. Define the ion thermal speed $ v_{\\mathrm{thi}} $ and ion cyclotron frequency $ \\Omega_i $ by\n$$\nv_{\\mathrm{thi}} = \\sqrt{\\frac{2 \\, T_i}{m_i}}, \\qquad \\Omega_i = \\frac{e \\, B}{m_i},\n$$\nwhere $ T_i $ is the ion temperature (in joules), $ m_i $ is the ion mass, and $ e $ is the elementary charge. The ion thermal Larmor radius $ \\rho_i $ is then\n$$\n\\rho_i = \\frac{v_{\\mathrm{thi}}}{\\Omega_i}.\n$$\nLet the ion temperature gradient diamagnetic frequency be\n$$\n\\omega_*^T = \\frac{k_y \\, T_i}{e \\, B \\, L_{T_i}},\n$$\nwhere $ k_y $ is the binormal wavenumber, and $ L_{T_i} $ is the ion temperature scale length. Use a curvature drift frequency\n$$\n\\omega_D(r) = k_y \\, v_{\\mathrm{thi}} \\, \\rho_i \\, \\kappa_c(r).\n$$\nIncorporate finite Larmor radius (FLR) weakening of the ITG drive with the factor\n$$\nS = \\frac{1}{1 + k_y^2 \\, \\rho_i^2}.\n$$\nDefine the local ITG growth rate as\n$$\n\\gamma(r) = \\max\\!\\left(0,\\; S \\, \\omega_*^T - \\omega_D(r) \\right),\n$$\nand evaluate the change due to the Shafranov shift as\n$$\n\\Delta \\gamma(r) = \\gamma_{\\text{with shift}}(r) - \\gamma_{\\text{without shift}}(r),\n$$\nwhere $ \\gamma_{\\text{without shift}}(r) $ uses $ \\kappa_c(r) = 1 / R_0 $.\n\nAssume a pressure profile of the form\n$$\np(r) = p_0 \\, \\max\\!\\left(0, \\, 1 - \\left(\\frac{r}{a}\\right)^n \\right),\n$$\nwhere $ p_0 $ is the on-axis pressure, $ a $ is the plasma minor radius, and $ n $ is a positive shaping exponent. When $ r \\ge a $, take $ p(r) = 0 $.\n\nYour program must:\n- Convert ion temperature $ T_i $ specified in electronvolts to joules using $ T_i[\\mathrm{J}] = T_i[\\mathrm{eV}] \\times e $, where $ e $ is the elementary charge.\n- Use $ \\mu_0 = 4 \\pi \\times 10^{-7} \\, \\mathrm{N/A^2} $ and $ e = 1.602176634 \\times 10^{-19} \\, \\mathrm{C} $.\n- Compute and return, for each test case, the triplet $ [\\Delta(r), \\kappa_c(r), \\Delta \\gamma(r)] $.\n- Express $ \\Delta(r) $ in meters $(\\mathrm{m})$, $ \\kappa_c(r) $ in inverse meters $(\\mathrm{m}^{-1})$, and $ \\Delta \\gamma(r) $ in inverse seconds $(\\mathrm{s}^{-1})$.\n- Aggregate all test case results into a single line of output containing the concatenated floats in a comma-separated list enclosed in square brackets, in the order $ [\\Delta_1, \\kappa_{c,1}, \\Delta \\gamma_1, \\Delta_2, \\kappa_{c,2}, \\Delta \\gamma_2, \\ldots] $.\n\nImplement the following test suite to ensure coverage of typical and edge-case behavior (all quantities are in SI units unless otherwise noted; temperatures are specified in electronvolts and must be converted to joules):\n- Test case $ 1 $ (baseline, large-aspect-ratio):\n  - $ R_0 = 5.0 $, $ a = 0.5 $, $ r = 0.3 $, $ B = 3.0 $, $ p_0 = 1.0 \\times 10^{5} $, $ n = 2 $, $ L_{T_i} = 0.2 $, $ k_y = 80.0 $, $ T_i = 2000.0 \\, \\mathrm{eV} $, $ m_i = 3.343583719 \\times 10^{-27} $.\n- Test case $ 2 $ (edge of plasma, vanishing pressure):\n  - $ R_0 = 5.0 $, $ a = 0.5 $, $ r = 0.5 $, $ B = 3.0 $, $ p_0 = 1.0 \\times 10^{5} $, $ n = 2 $, $ L_{T_i} = 0.2 $, $ k_y = 80.0 $, $ T_i = 2000.0 \\, \\mathrm{eV} $, $ m_i = 3.343583719 \\times 10^{-27} $.\n- Test case $ 3 $ (binormal wavenumber zero):\n  - $ R_0 = 5.0 $, $ a = 0.5 $, $ r = 0.3 $, $ B = 3.0 $, $ p_0 = 1.0 \\times 10^{5} $, $ n = 2 $, $ L_{T_i} = 0.2 $, $ k_y = 0.0 $, $ T_i = 2000.0 \\, \\mathrm{eV} $, $ m_i = 1.67262192369 \\times 10^{-27} $.\n- Test case $ 4 $ (stronger pressure and steeper gradient):\n  - $ R_0 = 6.0 $, $ a = 0.7 $, $ r = 0.4 $, $ B = 2.5 $, $ p_0 = 2.0 \\times 10^{5} $, $ n = 3 $, $ L_{T_i} = 0.05 $, $ k_y = 120.0 $, $ T_i = 3000.0 \\, \\mathrm{eV} $, $ m_i = 3.343583719 \\times 10^{-27} $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $ [\\text{result}_1, \\text{result}_2, \\text{result}_3] $). The results must be in the order $ [\\Delta_1, \\kappa_{c,1}, \\Delta \\gamma_1, \\Delta_2, \\kappa_{c,2}, \\Delta \\gamma_2, \\Delta_3, \\kappa_{c,3}, \\Delta \\gamma_3, \\Delta_4, \\kappa_{c,4}, \\Delta \\gamma_4] $.",
            "solution": "The user has provided a well-defined physics problem to be solved. An initial validation confirms that the problem is scientifically grounded, self-contained, and quantitatively solvable. It is based on standard, albeit simplified, principles of plasma physics, specifically magnetohydrodynamic (MHD) equilibrium and micro-instability theory. The provided parameters and constants are physically realistic. Therefore, the problem is deemed valid and a full solution will be provided.\n\nThe objective is to compute the effect of the Shafranov shift on the local curvature and the subsequent change in the Ion Temperature Gradient (ITG) mode growth rate. The calculation proceeds through a sequence of causally-linked physical models.\n\n**Step 1: Plasma Pressure Profile**\n\nThe plasma pressure $p(r)$ is a function of the minor radius $r$. It is given by a generalized parabolic profile, where $p_0$ is the on-axis pressure ($r=0$), $a$ is the plasma minor radius, and $n$ is a shaping exponent determining the peakedness of the profile. For any radius $r$ less than $a$, the pressure is:\n$$\np(r) = p_0 \\, \\left( 1 - \\left(\\frac{r}{a}\\right)^n \\right)\n$$\nFor radii at or beyond the plasma edge ($r \\ge a$), the pressure is zero, i.e., $p(r) = 0$.\n\n**Step 2: Shafranov Shift Calculation**\n\nIn a toroidal plasma equilibrium, the outward force from the plasma pressure gradient must be balanced. In the large-aspect-ratio approximation, this leads to an outward shift of the magnetic flux surfaces, known as the Shafranov shift, $\\Delta(r)$. The magnitude of this shift is proportional to the local plasma beta (the ratio of plasma pressure to magnetic pressure). The provided model for the shift is:\n$$\n\\Delta(r) = \\frac{\\mu_0 \\, p(r)}{B^2} \\, \\frac{r^2}{R_0}\n$$\nHere, $\\mu_0$ is the permeability of free space, $B$ is the toroidal magnetic field magnitude, and $R_0$ is the major radius of the magnetic axis. This shift is calculated using the pressure $p(r)$ from Step 1. A non-zero pressure results in a non-zero outward shift, $\\Delta(r) > 0$.\n\n**Step 3: Local Curvature Modification**\n\nThe ITG instability is driven by the combination of a temperature gradient and the curvature of the magnetic field lines. In a simple toroidal model, the \"bad\" curvature (where the field lines are convex, destabilizing the plasma) is concentrated on the low-field (outboard) side. The magnitude of this curvature, $\\kappa_c$, is inversely proportional to the local major radius. The Shafranov shift modifies this effective radius. The curvature magnitude with the shift included is:\n$$\n\\kappa_c(r) = \\frac{1}{R_0 + \\Delta(r)}\n$$\nFor the baseline comparison case without the shift, we simply let $\\Delta(r) = 0$, which gives $\\kappa_{c, \\text{no shift}} = 1/R_0$. Since $\\Delta(r) \\ge 0$, the Shafranov shift always acts to reduce the bad curvature magnitude, $\\kappa_c(r) \\le \\kappa_{c, \\text{no shift}}$.\n\n**Step 4: ITG Growth Rate Model**\n\nThe problem provides a fluid-like surrogate model for the ITG growth rate, $\\gamma(r)$. This model balances the instability drive against stabilizing effects.\n\nFirst, we define prerequisite ion properties. The ion temperature $T_i$ is converted from electronvolts ($eV$) to joules ($J$) via $T_i[\\mathrm{J}] = T_i[\\mathrm{eV}] \\times e$, where $e$ is the elementary charge. The ion thermal velocity and Larmor radius are then:\n$$\nv_{\\mathrm{thi}} = \\sqrt{\\frac{2 \\, T_i}{m_i}}, \\qquad \\rho_i = \\frac{v_{\\mathrm{thi}}}{\\Omega_i} = \\frac{v_{\\mathrm{thi}} m_i}{e B} = \\frac{\\sqrt{2 T_i m_i}}{e B}\n$$\nwhere $m_i$ is the ion mass and $\\Omega_i$ is the ion cyclotron frequency.\n\nThe components of the growth rate are:\n1.  **ITG Drive**: The diamagnetic frequency associated with the ion temperature gradient, $\\omega_*^T$. This term is proportional to the binormal wavenumber $k_y$ and inversely proportional to the temperature gradient scale length $L_{T_i}$.\n    $$\n    \\omega_*^T = \\frac{k_y \\, T_i}{e \\, B \\, L_{T_i}}\n    $$\n2.  **Finite Larmor Radius (FLR) Weakening**: The drive is weakened at smaller spatial scales (larger $k_y$) due to averaging effects over the ion's Larmor orbit. This is captured by the factor $S$:\n    $$\n    S = \\frac{1}{1 + k_y^2 \\, \\rho_i^2}\n    $$\n3.  **Curvature Drift Stabilization**: The magnetic field curvature leads to a drift that is stabilizing. The associated frequency, $\\omega_D$, is proportional to the curvature magnitude $\\kappa_c(r)$.\n    $$\n    \\omega_D(r) = k_y \\, v_{\\mathrm{thi}} \\, \\rho_i \\, \\kappa_c(r) = k_y \\left(\\frac{2 T_i}{e B}\\right) \\kappa_c(r)\n    $$\nThe final growth rate is the difference between the weakened drive and the stabilization, floored at zero since growth rates cannot be negative:\n$$\n\\gamma(r) = \\max\\!\\left(0,\\; S \\, \\omega_*^T - \\omega_D(r) \\right)\n$$\n\n**Step 5: Change in Growth Rate**\n\nThe final quantity to be calculated is the change in the ITG growth rate, $\\Delta\\gamma(r)$, due to the Shafranov shift. This is the difference between the growth rate calculated with the shift and the growth rate calculated without it.\n\n-   $\\gamma_{\\text{with shift}}(r)$ is calculated using $\\omega_D(r)$ with $\\kappa_c(r) = 1/(R_0 + \\Delta(r))$.\n-   $\\gamma_{\\text{without shift}}(r)$ is calculated using $\\omega_D(r)$ with $\\kappa_c(r) = 1/R_0$.\n\nThe change is then:\n$$\n\\Delta \\gamma(r) = \\gamma_{\\text{with shift}}(r) - \\gamma_{\\text{without shift}}(r)\n$$\nSince the Shafranov shift reduces the curvature magnitude $\\kappa_c$, it reduces the stabilizing drift frequency $\\omega_D$. This leads to a less stable plasma according to this local model, and thus we expect $\\Delta\\gamma(r) \\ge 0$.\n\nThe algorithm will systematically compute these quantities for each test case, assemble the triplet $[\\Delta(r), \\kappa_c(r), \\Delta\\gamma(r)]$, and format them into the required output structure.",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation, solution, and final output.\n    \"\"\"\n    # Physical Constants\n    MU_0 = 4 * np.pi * 1e-7  # N/A^2\n    E = 1.602176634e-19      # C\n\n    # Test suite as defined in the problem statement\n    test_cases = [\n        # Test case 1 (baseline, large-aspect-ratio)\n        dict(R0=5.0, a=0.5, r=0.3, B=3.0, p0=1.0e5, n=2, L_Ti=0.2, k_y=80.0, Ti_eV=2000.0, m_i=3.343583719e-27),\n        # Test case 2 (edge of plasma, vanishing pressure)\n        dict(R0=5.0, a=0.5, r=0.5, B=3.0, p0=1.0e5, n=2, L_Ti=0.2, k_y=80.0, Ti_eV=2000.0, m_i=3.343583719e-27),\n        # Test case 3 (binormal wavenumber zero)\n        dict(R0=5.0, a=0.5, r=0.3, B=3.0, p0=1.0e5, n=2, L_Ti=0.2, k_y=0.0, Ti_eV=2000.0, m_i=1.67262192369e-27),\n        # Test case 4 (stronger pressure and steeper gradient)\n        dict(R0=6.0, a=0.7, r=0.4, B=2.5, p0=2.0e5, n=3, L_Ti=0.05, k_y=120.0, Ti_eV=3000.0, m_i=3.343583719e-27),\n    ]\n\n    results_flat = []\n    for params in test_cases:\n        result_triplet = compute_itg_change(params, MU_0, E)\n        results_flat.extend(result_triplet)\n\n    # Format output as a single line, comma-separated list in brackets.\n    output_str = \"[\" + \",\".join(f\"{val:.10f}\" for val in results_flat) + \"]\"\n    print(output_str)\n\ndef compute_itg_change(params, mu_0, e):\n    \"\"\"\n    Computes [Delta(r), kappa_c(r), Delta_gamma(r)] for a single test case.\n    All inputs are in SI units, except Ti_eV in electronvolts.\n    \"\"\"\n    # Unpack parameters for clarity\n    R0, a, r, B, p0, n = params['R0'], params['a'], params['r'], params['B'], params['p0'], params['n']\n    L_Ti, k_y, Ti_eV, m_i = params['L_Ti'], params['k_y'], params['Ti_eV'], params['m_i']\n\n    # Step 1: Plasma Pressure Profile\n    if r >= a:\n        p_r = 0.0\n    else:\n        p_r = p0 * (1.0 - (r / a)**n)\n\n    # Step 2: Shafranov Shift\n    delta_r = (mu_0 * p_r / (B**2)) * (r**2 / R0)\n\n    # Step 3: Local Curvature Modification\n    kappa_c_with_shift = 1.0 / (R0 + delta_r)\n    kappa_c_no_shift = 1.0 / R0\n\n    # Step 4: ITG Growth Rate Model Components\n    Ti_J = Ti_eV * e  # Convert ion temperature to Joules\n\n    # If k_y is zero, all frequencies are zero, so growths and delta_gamma are zero.\n    if k_y == 0.0:\n        return [delta_r, kappa_c_with_shift, 0.0]\n\n    # Diamagnetic frequency\n    omega_star_T = (k_y * Ti_J) / (e * B * L_Ti)\n\n    # FLR weakening factor\n    # rho_i = sqrt(2 * Ti_J * m_i) / (e * B)\n    rho_i_sq = (2 * Ti_J * m_i) / (e**2 * B**2)\n    S = 1.0 / (1.0 + k_y**2 * rho_i_sq)\n\n    # Curvature drift frequencies\n    # omega_D = k_y * (2 * Ti_J) / (e * B) * kappa_c\n    omega_D_coeff = k_y * (2 * Ti_J) / (e * B)\n    omega_D_with_shift = omega_D_coeff * kappa_c_with_shift\n    omega_D_no_shift = omega_D_coeff * kappa_c_no_shift\n\n    # Calculate growth rates using the full formula\n    drive_term = S * omega_star_T\n    gamma_with_shift = max(0, drive_term - omega_D_with_shift)\n    gamma_no_shift = max(0, drive_term - omega_D_no_shift)\n\n    # Step 5: Change in Growth Rate\n    delta_gamma = gamma_with_shift - gamma_no_shift\n    \n    return [delta_r, kappa_c_with_shift, delta_gamma]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "An optimized stellarator design is not only one that confines plasma well but also one that is feasible to build and operate. This inevitably leads to a scenario of competing objectives, where improving physics performance might increase engineering complexity and cost. This final exercise  introduces you to the powerful concept of multi-objective optimization by asking you to construct a Pareto front, helping you navigate the essential trade-offs between reducing a turbulence proxy and managing a proxy for magnet coil complexity.",
            "id": "4201430",
            "problem": "You are given a set of candidate stellarator magnetic equilibria described by dimensionless parameters. The goal is to compute two objective values for each candidate configuration that quantitatively reflect, respectively, a proxy for turbulent transport and a proxy for coil engineering complexity, and then construct the Pareto front for simultaneous minimization of these two objectives. The Pareto front should contain those configurations for which no other configuration achieves both a lower turbulence proxy and a lower coil complexity proxy, with at least one strict improvement. The final answer must be a single line of output containing a comma-separated list of the indices of Pareto-optimal configurations, enclosed in square brackets, in ascending order.\n\nStart from the following fundamental base appropriate to fusion plasma turbulence and coil complexity:\n\n- From gyrokinetic theory, the ion-temperature-gradient drive produces a linear instability characterized by a growth rate that scales with the ion diamagnetic frequency and a measure of unfavorable (bad) curvature. The effect of magnetic shear is stabilizing. Consistent with these properties, use a dimensionless linear growth-rate proxy defined as\n$$\\gamma_{\\mathrm{lin}} = C_{\\mathrm{gb}} \\left(\\frac{a}{L_T}\\right) f_{\\mathrm{curv}}(\\kappa_c,q),$$\nwhere $C_{\\mathrm{gb}}$ is a positive constant, $\\frac{a}{L_T}$ is the normalized temperature gradient, $\\kappa_c$ is a dimensionless bad-curvature amplitude, $q$ is the safety factor, and $f_{\\mathrm{curv}}$ is a dimensionless function that increases with $\\kappa_c$ and decreases with $q$. For this problem, take\n$$f_{\\mathrm{curv}}(\\kappa_c,q) = \\frac{\\kappa_c}{1+q^2}.$$\nDefine a dimensionless shear-stabilization proxy as\n$$\\gamma_{\\mathrm{shear}} = C_{\\mathrm{sh}} \\left| \\hat{s} \\right|,$$\nwhere $C_{\\mathrm{sh}}$ is a positive constant and $\\hat{s}$ is the local magnetic shear. The effective instability level proxy is then\n$$\\gamma_{\\mathrm{eff}} = \\max\\left(0,\\ \\gamma_{\\mathrm{lin}} - \\gamma_{\\mathrm{shear}}\\right).$$\nDefine the turbulence objective to be\n$$J_{\\mathrm{turb}} = \\gamma_{\\mathrm{eff}}.$$\n\n- For coil engineering complexity, use a proxy motivated by bending and twisting energy penalties and coil length. Let $c_{\\mathrm{amp}}$ be a dimensionless curvature amplitude, $t_{\\mathrm{amp}}$ be a dimensionless torsion amplitude, and $L_{\\mathrm{norm}}$ be a dimensionless normalized length. Define\n$$J_{\\mathrm{coil}} = \\alpha\\, c_{\\mathrm{amp}}^2 + \\beta\\, t_{\\mathrm{amp}}^2 + \\lambda\\, L_{\\mathrm{norm}},$$\nwhere $\\alpha$, $\\beta$, and $\\lambda$ are positive weights.\n\nGiven the following constants:\n- $C_{\\mathrm{gb}} = 0.35$,\n- $C_{\\mathrm{sh}} = 0.8$,\n- $\\alpha = 1.0$,\n- $\\beta = 0.6$,\n- $\\lambda = 0.2$,\n\nand the following list of $7$ candidate configurations, each specified by the tuple\n$$(\\kappa_c,\\ \\hat{s},\\ a/L_T,\\ q,\\ c_{\\mathrm{amp}},\\ t_{\\mathrm{amp}},\\ L_{\\mathrm{norm}}),$$\ncompute $J_{\\mathrm{turb}}$ and $J_{\\mathrm{coil}}$ for each, and then identify the indices of the configurations that lie on the Pareto front for the bi-objective minimization of $\\left(J_{\\mathrm{turb}}, J_{\\mathrm{coil}}\\right)$. Use zero-based indexing for configurations.\n\nThe candidate configurations are:\n- Index $0$: $(0.8,\\ 0.6,\\ 3.0,\\ 1.2,\\ 0.35,\\ 0.4,\\ 1.0)$.\n- Index $1$: $(1.4,\\ 0.2,\\ 4.0,\\ 1.0,\\ 0.8,\\ 0.9,\\ 1.4)$.\n- Index $2$: $(0.5,\\ 0.3,\\ 2.0,\\ 1.5,\\ 0.2,\\ 0.25,\\ 0.9)$.\n- Index $3$: $(1.0,\\ 0.4,\\ 3.5,\\ 1.3,\\ 0.5,\\ 0.45,\\ 1.1)$.\n- Index $4$: $(1.0,\\ 0.4,\\ 3.5,\\ 1.3,\\ 0.5,\\ 0.45,\\ 1.1)$.\n- Index $5$: $(0.9,\\ 0.1,\\ 1.8,\\ 0.9,\\ 0.15,\\ 0.15,\\ 0.7)$.\n- Index $6$: $(1.2,\\ 0.532,\\ 3.0,\\ 1.4,\\ 0.4,\\ 0.5,\\ 1.2)$.\n\nYour program must:\n- Compute $J_{\\mathrm{turb}}$ and $J_{\\mathrm{coil}}$ for each candidate using the formulas above.\n- Construct the Pareto front under the rule that configuration $i$ is dominated by configuration $j$ if and only if $J_{\\mathrm{turb}}(j) \\le J_{\\mathrm{turb}}(i)$ and $J_{\\mathrm{coil}}(j) \\le J_{\\mathrm{coil}}(i)$, with at least one of these two inequalities strict. Configurations that are not dominated by any other configuration are Pareto-optimal.\n- Produce a single line of output containing the sorted indices of the Pareto-optimal configurations as a comma-separated list enclosed in square brackets (for example, $[0,2,5]$). No other output is permitted.\n\nAll quantities in this problem are dimensionless, so no physical units are required. The test suite above covers a general case, a boundary case where $J_{\\mathrm{turb}}$ transitions to zero when $\\gamma_{\\mathrm{lin}} = \\gamma_{\\mathrm{shear}}$, and an edge case with duplicate configurations to test tie-handling in dominance.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in simplified, but physically motivated, models of plasma turbulence and magnet coil complexity relevant to stellarator optimization. The problem is mathematically well-posed, providing all necessary data, constants, and unambiguous definitions to compute a unique solution. The language is objective and the requirements are explicit. Therefore, a reasoned solution is provided below.\n\nThe core task is to perform a bi-objective optimization for a set of stellarator configurations. The two objectives to be minimized are a proxy for turbulent transport, $J_{\\mathrm{turb}}$, and a proxy for coil complexity, $J_{\\mathrm{coil}}$. The solution involves calculating these two objectives for each candidate configuration and then identifying the non-dominated set, known as the Pareto front.\n\nFirst, we define the objective functions based on the provided physical models and parameters. The constants are given as $C_{\\mathrm{gb}} = 0.35$, $C_{\\mathrm{sh}} = 0.8$, $\\alpha = 1.0$, $\\beta = 0.6$, and $\\lambda = 0.2$.\n\nThe turbulence objective, $J_{\\mathrm{turb}}$, is derived from a balance between the ion-temperature-gradient (ITG) instability drive and stabilization from magnetic shear. The linear growth rate proxy, $\\gamma_{\\mathrm{lin}}$, is given by:\n$$ \\gamma_{\\mathrm{lin}} = C_{\\mathrm{gb}} \\left(\\frac{a}{L_T}\\right) f_{\\mathrm{curv}}(\\kappa_c,q) $$\nwhere the curvature function is:\n$$ f_{\\mathrm{curv}}(\\kappa_c,q) = \\frac{\\kappa_c}{1+q^2} $$\nThe shear stabilization proxy, $\\gamma_{\\mathrm{shear}}$, is:\n$$ \\gamma_{\\mathrm{shear}} = C_{\\mathrm{sh}} \\left| \\hat{s} \\right| $$\nThe effective instability level, which serves as the turbulence objective, is the difference between these two, floored at zero:\n$$ J_{\\mathrm{turb}} = \\gamma_{\\mathrm{eff}} = \\max\\left(0,\\ \\gamma_{\\mathrm{lin}} - \\gamma_{\\mathrm{shear}}\\right) $$\n\nThe coil complexity objective, $J_{\\mathrm{coil}}$, is a weighted sum of proxies for coil bending energy, twisting energy, and length:\n$$ J_{\\mathrm{coil}} = \\alpha\\, c_{\\mathrm{amp}}^2 + \\beta\\, t_{\\mathrm{amp}}^2 + \\lambda\\, L_{\\mathrm{norm}} $$\n\nFor each of the $7$ candidate configurations, specified by the tuple $(\\kappa_c,\\ \\hat{s},\\ a/L_T,\\ q,\\ c_{\\mathrm{amp}},\\ t_{\\mathrm{amp}},\\ L_{\\mathrm{norm}})$, we compute the objective vector $(J_{\\mathrm{turb}}, J_{\\mathrm{coil}})$.\n\nConfiguration $0$: $(\\kappa_c, \\hat{s}, a/L_T, q, c_{\\mathrm{amp}}, t_{\\mathrm{amp}}, L_{\\mathrm{norm}}) = (0.8, 0.6, 3.0, 1.2, 0.35, 0.4, 1.0)$\n$f_{\\mathrm{curv}} = \\frac{0.8}{1+1.2^2} \\approx 0.3279$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.0 \\times 0.3279 \\approx 0.3443$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.6| = 0.48$.\n$J_{\\mathrm{turb}} = \\max(0, 0.3443 - 0.48) = 0$.\n$J_{\\mathrm{coil}} = 1.0(0.35^2) + 0.6(0.4^2) + 0.2(1.0) = 0.1225 + 0.096 + 0.2 = 0.4185$.\nObjective Vector: $(0.0, 0.4185)$.\n\nConfiguration $1$: $(1.4, 0.2, 4.0, 1.0, 0.8, 0.9, 1.4)$\n$f_{\\mathrm{curv}} = \\frac{1.4}{1+1.0^2} = 0.7$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 4.0 \\times 0.7 = 0.98$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.2| = 0.16$.\n$J_{\\mathrm{turb}} = \\max(0, 0.98 - 0.16) = 0.82$.\n$J_{\\mathrm{coil}} = 1.0(0.8^2) + 0.6(0.9^2) + 0.2(1.4) = 0.64 + 0.486 + 0.28 = 1.406$.\nObjective Vector: $(0.82, 1.406)$.\n\nConfiguration $2$: $(0.5, 0.3, 2.0, 1.5, 0.2, 0.25, 0.9)$\n$f_{\\mathrm{curv}} = \\frac{0.5}{1+1.5^2} \\approx 0.1538$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 2.0 \\times 0.1538 \\approx 0.1077$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.3| = 0.24$.\n$J_{\\mathrm{turb}} = \\max(0, 0.1077 - 0.24) = 0$.\n$J_{\\mathrm{coil}} = 1.0(0.2^2) + 0.6(0.25^2) + 0.2(0.9) = 0.04 + 0.0375 + 0.18 = 0.2575$.\nObjective Vector: $(0.0, 0.2575)$.\n\nConfiguration $3$: $(1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1)$\n$f_{\\mathrm{curv}} = \\frac{1.0}{1+1.3^2} \\approx 0.3717$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.5 \\times 0.3717 \\approx 0.4554$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.4| = 0.32$.\n$J_{\\mathrm{turb}} = \\max(0, 0.4554 - 0.32) \\approx 0.1354$.\n$J_{\\mathrm{coil}} = 1.0(0.5^2) + 0.6(0.45^2) + 0.2(1.1) = 0.25 + 0.1215 + 0.22 = 0.5915$.\nObjective Vector: $(\\approx 0.1354, 0.5915)$.\n\nConfiguration $4$: $(1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1)$\nThis is identical to configuration $3$.\nObjective Vector: $(\\approx 0.1354, 0.5915)$.\n\nConfiguration $5$: $(0.9, 0.1, 1.8, 0.9, 0.15, 0.15, 0.7)$\n$f_{\\mathrm{curv}} = \\frac{0.9}{1+0.9^2} \\approx 0.4972$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 1.8 \\times 0.4972 \\approx 0.3132$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.1| = 0.08$.\n$J_{\\mathrm{turb}} = \\max(0, 0.3132 - 0.08) \\approx 0.2332$.\n$J_{\\mathrm{coil}} = 1.0(0.15^2) + 0.6(0.15^2) + 0.2(0.7) = 0.0225 + 0.0135 + 0.14 = 0.176$.\nObjective Vector: $(\\approx 0.2332, 0.176)$.\n\nConfiguration $6$: $(1.2, 0.532, 3.0, 1.4, 0.4, 0.5, 1.2)$\n$f_{\\mathrm{curv}} = \\frac{1.2}{1+1.4^2} \\approx 0.4054$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.0 \\times 0.4054 \\approx 0.42567$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.532| = 0.4256$.\n$J_{\\mathrm{turb}} = \\max(0, 0.42567 - 0.4256) \\approx 0.0000757$.\n$J_{\\mathrm{coil}} = 1.0(0.4^2) + 0.6(0.5^2) + 0.2(1.2) = 0.16 + 0.15 + 0.24 = 0.55$.\nObjective Vector: $(\\approx 0.0000757, 0.55)$.\n\nThe calculated objective vectors $(J_{\\mathrm{turb}}, J_{\\mathrm{coil}})$ are:\n- Index $0$: $(0.0, 0.4185)$\n- Index $1$: $(0.82, 1.406)$\n- Index $2$: $(0.0, 0.2575)$\n- Index $3$: $(\\approx 0.1354, 0.5915)$\n- Index $4$: $(\\approx 0.1354, 0.5915)$\n- Index $5$: $(\\approx 0.2332, 0.176)$\n- Index $6$: $(\\approx 0.0000757, 0.55)$\n\nNext, we identify the Pareto front. A configuration $i$ is dominated by configuration $j$ if $J_{\\mathrm{turb}}(j) \\le J_{\\mathrm{turb}}(i)$ and $J_{\\mathrm{coil}}(j) \\le J_{\\mathrm{coil}}(i)$, with at least one inequality being strict. Configurations not dominated by any other configuration form the Pareto front.\n\n- Configuration $1$ ($ (0.82, 1.406) $) is dominated by all other configurations as they all have smaller values for both objectives.\n- Configuration $0$ ($ (0.0, 0.4185) $) is dominated by configuration $2$ ($ (0.0, 0.2575) $) because $J_{\\mathrm{turb}}(2) = J_{\\mathrm{turb}}(0)$ and $J_{\\mathrm{coil}}(2) < J_{\\mathrm{coil}}(0)$.\n- Configurations $3$ and $4$ ($ (\\approx 0.1354, 0.5915) $) are dominated by configuration $6$ ($ (\\approx 0.0000757, 0.55) $) because $J_{\\mathrm{turb}}(6) < J_{\\mathrm{turb}}(3,4)$ and $J_{\\mathrm{coil}}(6) < J_{\\mathrm{coil}}(3,4)$. Note that identical configurations do not dominate each other as a strict inequality is required.\n\nThe remaining configurations are $2$, $5$, and $6$. We check them for mutual dominance:\n- Compare $2$ ($ (0.0, 0.2575) $) and $5$ ($ (\\approx 0.2332, 0.176) $): Configuration $2$ has a lower $J_{\\mathrm{turb}}$, but configuration $5$ has a lower $J_{\\mathrm{coil}}$. Neither dominates the other.\n- Compare $2$ ($ (0.0, 0.2575) $) and $6$ ($ (\\approx 0.0000757, 0.55) $): Configuration $2$ has a lower $J_{\\mathrm{turb}}$, but a higher $J_{\\mathrm{coil}}$. Neither dominates the other.\n- Compare $5$ ($ (\\approx 0.2332, 0.176) $) and $6$ ($ (\\approx 0.0000757, 0.55) $): Configuration $6$ has a lower $J_{\\mathrm{turb}}$, but configuration $5$ has a lower $J_{\\mathrm{coil}}$. Neither dominates the other.\n\nThus, configurations with indices $2$, $5$, and $6$ are not dominated by any other configuration. They constitute the Pareto front. The indices, sorted in ascending order, are $2, 5, 6$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes J_turb and J_coil for each candidate configuration, then identifies \n    and returns the indices of the Pareto-optimal configurations.\n    \"\"\"\n    \n    # Define the constants from the problem statement.\n    C_gb = 0.35\n    C_sh = 0.8\n    alpha = 1.0\n    beta = 0.6\n    lambda_ = 0.2\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (kappa_c, s_hat, a_over_LT, q, c_amp, t_amp, L_norm)\n    test_cases = [\n        (0.8, 0.6, 3.0, 1.2, 0.35, 0.4, 1.0),\n        (1.4, 0.2, 4.0, 1.0, 0.8, 0.9, 1.4),\n        (0.5, 0.3, 2.0, 1.5, 0.2, 0.25, 0.9),\n        (1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1),\n        (1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1),\n        (0.9, 0.1, 1.8, 0.9, 0.15, 0.15, 0.7),\n        (1.2, 0.532, 3.0, 1.4, 0.4, 0.5, 1.2),\n    ]\n\n    def calculate_objectives(config):\n        \"\"\"\n        Calculates J_turb and J_coil for a single configuration.\n        \"\"\"\n        kappa_c, s_hat, a_over_LT, q, c_amp, t_amp, L_norm = config\n        \n        # Calculate J_turb\n        f_curv = kappa_c / (1.0 + q**2)\n        gamma_lin = C_gb * a_over_LT * f_curv\n        gamma_shear = C_sh * abs(s_hat)\n        j_turb = max(0.0, gamma_lin - gamma_shear)\n        \n        # Calculate J_coil\n        j_coil = alpha * c_amp**2 + beta * t_amp**2 + lambda_ * L_norm\n        \n        return j_turb, j_coil\n\n    n_configs = len(test_cases)\n    objectives = [calculate_objectives(case) for case in test_cases]\n    \n    pareto_indices = []\n    for i in range(n_configs):\n        is_dominated = False\n        for j in range(n_configs):\n            if i == j:\n                continue\n            \n            i_turb, i_coil = objectives[i]\n            j_turb, j_coil = objectives[j]\n            \n            # Check if configuration j dominates configuration i\n            # This requires j to be better or equal on all objectives...\n            if j_turb <= i_turb and j_coil <= i_coil:\n                # ...and strictly better on at least one objective.\n                if j_turb < i_turb or j_coil < i_coil:\n                    is_dominated = True\n                    break # Found a dominator, no need to check further for i\n        \n        if not is_dominated:\n            pareto_indices.append(i)\n            \n    pareto_indices.sort()\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, pareto_indices))}]\")\n\nsolve()\n```"
        }
    ]
}