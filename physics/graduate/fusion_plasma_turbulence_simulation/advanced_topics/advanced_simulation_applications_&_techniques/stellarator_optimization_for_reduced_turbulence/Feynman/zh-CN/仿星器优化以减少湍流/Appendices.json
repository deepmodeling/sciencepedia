{
    "hands_on_practices": [
        {
            "introduction": "在优化仿星器设计以减少湍流时，首要任务是建立一个连接等离子体几何构型与湍流水平的定量模型。等离子体自身压力 $p(r)$ 导致的向外位移，即沙弗拉诺夫位移（Shafranov shift）$\\Delta(r)$，会改变磁场曲率，而曲率是驱动离子温度梯度（ITG）等微观不稳定性的关键因素。本练习  将引导您亲手实现这一物理过程，计算等离子体压力如何通过改变几何曲率，最终影响一个简化的ITG模增长率。通过这个实践，您将具体理解宏观磁流体（MHD）平衡与微观不稳定性之间的相互作用，这是等离子体约束研究中的一个核心概念。",
            "id": "4201407",
            "problem": "您将实现一个物理上自洽的大环径比模型，以计算 Shafranov 位移及其对局域曲率的影响，然后评估由此导致的离子温度梯度（ITG）不稳定性增长率在指定压强剖面下的变化。您的程序必须汇总已定义的测试套件的结果，并将其输出为单行。\n\n从磁流体力学（MHD）的基本力平衡，即静态平衡条件 $ \\nabla p = \\mathbf{j} \\times \\mathbf{B} $ 出发，并使用大环径比、圆形磁通面近似，其中主导磁场为环向磁场，其强度 $ B $ 在感兴趣的区域内被视作常数。在此极限下，向外的 Shafranov 位移 $ \\Delta(r) $ 与归一化的等离子体压强（贝塔值）以及几何因子 $ r^2 / R_0 $ 成比例，其中 $ r $ 是磁通面的小半径，$ R_0 $ 是大半径。采用以下 Shafranov 位移模型：\n$$\n\\Delta(r) = \\frac{\\mu_0 \\, p(r)}{B^2} \\, \\frac{r^2}{R_0},\n$$\n其中 $ \\mu_0 $ 是自由空间磁导率，$ p(r) $ 是局域等离子体压强，$ B $ 是环向磁场强度。\n\n将坏环向曲率的强度建模为\n$$\n\\kappa_c(r) = \\frac{1}{R_0 + \\Delta(r)},\n$$\n因此，一个向外的 Shafranov 位移 $ \\Delta(r) > 0 $ 会减小曲率强度。\n\n使用一个离子温度梯度（ITG）类流体替代模型，该模型捕捉了离子温度梯度驱动与曲率漂移稳定化之间的竞争。定义离子热速度 $ v_{\\mathrm{thi}} $ 和离子回旋频率 $ \\Omega_i $ 为\n$$\nv_{\\mathrm{thi}} = \\sqrt{\\frac{2 \\, T_i}{m_i}}, \\qquad \\Omega_i = \\frac{e \\, B}{m_i},\n$$\n其中 $ T_i $ 是离子温度（单位为焦耳），$ m_i $ 是离子质量，$ e $ 是元电荷。离子热拉莫尔半径 $ \\rho_i $ 则为\n$$\n\\rho_i = \\frac{v_{\\mathrm{thi}}}{\\Omega_i}.\n$$\n设离子温度梯度逆磁频率为\n$$\n\\omega_*^T = \\frac{k_y \\, T_i}{e \\, B \\, L_{T_i}},\n$$\n其中 $ k_y $ 是副法向波数，$ L_{T_i} $ 是离子温度标长。使用曲率漂移频率\n$$\n\\omega_D(r) = k_y \\, v_{\\mathrm{thi}} \\, \\rho_i \\, \\kappa_c(r).\n$$\n通过因子\n$$\nS = \\frac{1}{1 + k_y^2 \\, \\rho_i^2}\n$$\n引入有限拉莫尔半径（FLR）对 ITG 驱动的削弱效应。\n将局域 ITG 增长率定义为\n$$\n\\gamma(r) = \\max\\!\\left(0,\\; S \\, \\omega_*^T - \\omega_D(r) \\right),\n$$\n并评估由 Shafranov 位移引起的变化\n$$\n\\Delta \\gamma(r) = \\gamma_{\\text{with shift}}(r) - \\gamma_{\\text{without shift}}(r),\n$$\n其中 $ \\gamma_{\\text{without shift}}(r) $ 使用 $ \\kappa_c(r) = 1 / R_0 $。\n\n假设压强剖面形式为\n$$\np(r) = p_0 \\, \\max\\!\\left(0, \\, 1 - \\left(\\frac{r}{a}\\right)^n \\right),\n$$\n其中 $ p_0 $ 是轴上压强，$ a $ 是等离子体小半径，$ n $ 是一个正的剖面指数。当 $ r \\ge a $ 时，取 $ p(r) = 0 $。\n\n您的程序必须：\n- 使用 $ T_i[\\mathrm{J}] = T_i[\\mathrm{eV}] \\times e $ 将以电子伏特为单位指定的离子温度 $ T_i $ 转换为焦耳，其中 $ e $ 是元电荷。\n- 使用 $ \\mu_0 = 4 \\pi \\times 10^{-7} \\, \\mathrm{N/A^2} $ 和 $ e = 1.602176634 \\times 10^{-19} \\, \\mathrm{C} $。\n- 为每个测试用例计算并返回三元组 $ [\\Delta(r), \\kappa_c(r), \\Delta \\gamma(r)] $。\n- 以米（$\\mathrm{m}$）表示 $ \\Delta(r) $，以反米（$\\mathrm{m}^{-1}$）表示 $ \\kappa_c(r) $，以反秒（$\\mathrm{s}^{-1}$）表示 $ \\Delta \\gamma(r) $。\n- 将所有测试用例的结果汇总到单行输出中，该输出包含一个用方括号括起来的逗号分隔浮点数列表，顺序为 $ [\\Delta_1, \\kappa_{c,1}, \\Delta \\gamma_1, \\Delta_2, \\kappa_{c,2}, \\Delta \\gamma_2, \\ldots] $。\n\n实施以下测试套件以确保覆盖典型和边缘情况下的行为（除非另有说明，所有量均使用国际单位制；温度以电子伏特为单位指定，必须转换为焦耳）：\n- 测试用例 1（基准，大环径比）：\n  - $ R_0 = 5.0 $，$ a = 0.5 $，$ r = 0.3 $，$ B = 3.0 $，$ p_0 = 1.0 \\times 10^{5} $，$ n = 2 $，$ L_{T_i} = 0.2 $，$ k_y = 80.0 $，$ T_i = 2000.0 \\, \\mathrm{eV} $，$ m_i = 3.343583719 \\times 10^{-27} $。\n- 测试用例 2（等离子体边缘，压强趋于零）：\n  - $ R_0 = 5.0 $，$ a = 0.5 $，$ r = 0.5 $，$ B = 3.0 $，$ p_0 = 1.0 \\times 10^{5} $，$ n = 2 $，$ L_{T_i} = 0.2 $，$ k_y = 80.0 $，$ T_i = 2000.0 \\, \\mathrm{eV} $，$ m_i = 3.343583719 \\times 10^{-27} $。\n- 测试用例 3（副法向波数为零）：\n  - $ R_0 = 5.0 $，$ a = 0.5 $，$ r = 0.3 $，$ B = 3.0 $，$ p_0 = 1.0 \\times 10^{5} $，$ n = 2 $，$ L_{T_i} = 0.2 $，$ k_y = 0.0 $，$ T_i = 2000.0 \\, \\mathrm{eV} $，$ m_i = 1.67262192369 \\times 10^{-27} $。\n- 测试用例 4（更强的压强和更陡的梯度）：\n  - $ R_0 = 6.0 $，$ a = 0.7 $，$ r = 0.4 $，$ B = 2.5 $，$ p_0 = 2.0 \\times 10^{5} $，$ n = 3 $，$ L_{T_i} = 0.05 $，$ k_y = 120.0 $，$ T_i = 3000.0 \\, \\mathrm{eV} $，$ m_i = 3.343583719 \\times 10^{-27} $。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$ [\\text{result}_1, \\text{result}_2, \\text{result}_3] $）。结果必须按以下顺序排列 $ [\\Delta_1, \\kappa_{c,1}, \\Delta \\gamma_1, \\Delta_2, \\kappa_{c,2}, \\Delta \\gamma_2, \\Delta_3, \\kappa_{c,3}, \\Delta \\gamma_3, \\Delta_4, \\kappa_{c,4}, \\Delta \\gamma_4] $。",
            "solution": "用户提供了一个定义明确的物理问题待解决。初步验证确认该问题在科学上是合理的、自洽的并且可以量化求解。它基于等离子体物理学的标准原理（尽管是简化的），特别是磁流体力学（MHD）平衡和微观不稳定性理论。所提供的参数和常数在物理上是现实的。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n目标是计算 Shafranov 位移对局域曲率的影响，以及由此引起的离子温度梯度（ITG）模增长率的变化。计算过程遵循一系列因果关联的物理模型。\n\n**第 1 步：等离子体压强剖面**\n\n等离子体压强 $p(r)$ 是小半径 $r$ 的函数。它由一个广义抛物线剖面给出，其中 $p_0$ 是轴上压强（$r=0$），$a$ 是等离子体小半径，$n$ 是一个决定剖面尖峰度的剖面指数。对于任何小于 $a$ 的半径 $r$，压强为：\n$$\np(r) = p_0 \\, \\left( 1 - \\left(\\frac{r}{a}\\right)^n \\right)\n$$\n对于在等离子体边缘或之外的半径（$r \\ge a$），压强为零，即 $p(r) = 0$。\n\n**第 2 步：Shafranov 位移计算**\n\n在环状等离子体平衡中，由等离子体压强梯度产生的向外力必须得到平衡。在大环径比近似下，这导致磁通量面向外移动，这种移动被称为 Shafranov 位移，$\\Delta(r)$。该位移的大小与局域等离子体贝塔值（等离子体压强与磁压强之比）成正比。提供的位移模型是：\n$$\n\\Delta(r) = \\frac{\\mu_0 \\, p(r)}{B^2} \\, \\frac{r^2}{R_0}\n$$\n这里，$\\mu_0$ 是自由空间磁导率，$B$ 是环向磁场强度，$R_0$ 是磁轴的大半径。该位移使用第 1 步中的压强 $p(r)$ 计算。非零压强导致非零的向外位移，$\\Delta(r) > 0$。\n\n**第 3 步：局域曲率修正**\n\nITG 不稳定性是由温度梯度和磁力线曲率的组合驱动的。在一个简单的环状模型中，“坏”曲率（磁力线是凸的，对等离子体起非稳定作用）集中在低场（外侧）侧。这种曲率的强度 $\\kappa_c$ 与局域大半径成反比。Shafranov 位移修正了这个有效半径。包含位移后的曲率强度为：\n$$\n\\kappa_c(r) = \\frac{1}{R_0 + \\Delta(r)}\n$$\n对于没有位移的基准比较情况，我们只需令 $\\Delta(r) = 0$，得到 $\\kappa_{c, \\text{no shift}} = 1/R_0$。由于 $\\Delta(r) \\ge 0$，Shafranov 位移总是起到减小坏曲率强度的作用，即 $\\kappa_c(r) \\le \\kappa_{c, \\text{no shift}}$。\n\n**第 4 步：ITG 增长率模型**\n\n该问题提供了一个用于 ITG 增长率 $\\gamma(r)$ 的类流体替代模型。该模型平衡了不稳定性驱动与稳定效应。\n\n首先，我们定义必要的离子特性。离子温度 $T_i$ 通过 $T_i[\\mathrm{J}] = T_i[\\mathrm{eV}] \\times e$ 从电子伏特（$eV$）转换为焦耳（$J$），其中 $e$ 是元电荷。然后，离子热速度和拉莫尔半径为：\n$$\nv_{\\mathrm{thi}} = \\sqrt{\\frac{2 \\, T_i}{m_i}}, \\qquad \\rho_i = \\frac{v_{\\mathrm{thi}}}{\\Omega_i} = \\frac{v_{\\mathrm{thi}} m_i}{e B} = \\frac{\\sqrt{2 T_i m_i}}{e B}\n$$\n其中 $m_i$ 是离子质量，$\\Omega_i$ 是离子回旋频率。\n\n增长率的组成部分是：\n1.  **ITG 驱动**：与离子温度梯度相关的逆磁频率 $\\omega_*^T$。该项与副法向波数 $k_y$ 成正比，与温度梯度标长 $L_{T_i}$ 成反比。\n    $$\n    \\omega_*^T = \\frac{k_y \\, T_i}{e \\, B \\, L_{T_i}}\n    $$\n2.  **有限拉莫尔半径（FLR）削弱**：由于在离子的拉莫尔轨道上的平均效应，驱动在更小的空间尺度（更大的 $k_y$）上被削弱。这由因子 $S$ 捕捉：\n    $$\n    S = \\frac{1}{1 + k_y^2 \\, \\rho_i^2}\n    $$\n3.  **曲率漂移稳定化**：磁场曲率导致一种具有稳定作用的漂移。相关的频率 $\\omega_D$ 与曲率强度 $\\kappa_c(r)$ 成正比。\n    $$\n    \\omega_D(r) = k_y \\, v_{\\mathrm{thi}} \\, \\rho_i \\, \\kappa_c(r) = k_y \\left(\\frac{2 T_i}{e B}\\right) \\kappa_c(r)\n    $$\n最终的增长率是削弱后的驱动与稳定作用之间的差值，且不小于零，因为增长率不能为负：\n$$\n\\gamma(r) = \\max\\!\\left(0,\\; S \\, \\omega_*^T - \\omega_D(r) \\right)\n$$\n\n**第 5 步：增长率的变化**\n\n最终要计算的量是由于 Shafranov 位移引起的 ITG 增长率的变化 $\\Delta\\gamma(r)$。这是用有位移计算的增长率与没有位移计算的增长率之差。\n\n-   $\\gamma_{\\text{with shift}}(r)$ 是使用 $\\omega_D(r)$ 和 $\\kappa_c(r) = 1/(R_0 + \\Delta(r))$ 计算的。\n-   $\\gamma_{\\text{without shift}}(r)$ 是使用 $\\omega_D(r)$ 和 $\\kappa_c(r) = 1/R_0$ 计算的。\n\n变化量则为：\n$$\n\\Delta \\gamma(r) = \\gamma_{\\text{with shift}}(r) - \\gamma_{\\text{without shift}}(r)\n$$\n由于 Shafranov 位移减小了曲率强度 $\\kappa_c$，它也减小了起稳定作用的漂移频率 $\\omega_D$。根据这个局域模型，这会导致等离子体稳定性降低，因此我们预期 $\\Delta\\gamma(r) \\ge 0$。\n\n该算法将为每个测试用例系统地计算这些量，组合成三元组 $[\\Delta(r), \\kappa_c(r), \\Delta\\gamma(r)]$，并将其格式化为所需的输出结构。",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation, solution, and final output.\n    \"\"\"\n    # Physical Constants\n    MU_0 = 4 * np.pi * 1e-7  # N/A^2\n    E = 1.602176634e-19      # C\n\n    # Test suite as defined in the problem statement\n    test_cases = [\n        # Test case 1 (baseline, large-aspect-ratio)\n        dict(R0=5.0, a=0.5, r=0.3, B=3.0, p0=1.0e5, n=2, L_Ti=0.2, k_y=80.0, Ti_eV=2000.0, m_i=3.343583719e-27),\n        # Test case 2 (edge of plasma, vanishing pressure)\n        dict(R0=5.0, a=0.5, r=0.5, B=3.0, p0=1.0e5, n=2, L_Ti=0.2, k_y=80.0, Ti_eV=2000.0, m_i=3.343583719e-27),\n        # Test case 3 (binormal wavenumber zero)\n        dict(R0=5.0, a=0.5, r=0.3, B=3.0, p0=1.0e5, n=2, L_Ti=0.2, k_y=0.0, Ti_eV=2000.0, m_i=1.67262192369e-27),\n        # Test case 4 (stronger pressure and steeper gradient)\n        dict(R0=6.0, a=0.7, r=0.4, B=2.5, p0=2.0e5, n=3, L_Ti=0.05, k_y=120.0, Ti_eV=3000.0, m_i=3.343583719e-27),\n    ]\n\n    results_flat = []\n    for params in test_cases:\n        result_triplet = compute_itg_change(params, MU_0, E)\n        results_flat.extend(result_triplet)\n\n    # Format output as a single line, comma-separated list in brackets.\n    output_str = \"[\" + \",\".join(f\"{val:.10f}\" for val in results_flat) + \"]\"\n    print(output_str)\n\ndef compute_itg_change(params, mu_0, e):\n    \"\"\"\n    Computes [Delta(r), kappa_c(r), Delta_gamma(r)] for a single test case.\n    All inputs are in SI units, except Ti_eV in electronvolts.\n    \"\"\"\n    # Unpack parameters for clarity\n    R0, a, r, B, p0, n = params['R0'], params['a'], params['r'], params['B'], params['p0'], params['n']\n    L_Ti, k_y, Ti_eV, m_i = params['L_Ti'], params['k_y'], params['Ti_eV'], params['m_i']\n\n    # Step 1: Plasma Pressure Profile\n    if r >= a:\n        p_r = 0.0\n    else:\n        p_r = p0 * (1.0 - (r / a)**n)\n\n    # Step 2: Shafranov Shift\n    delta_r = (mu_0 * p_r / (B**2)) * (r**2 / R0)\n\n    # Step 3: Local Curvature Modification\n    kappa_c_with_shift = 1.0 / (R0 + delta_r)\n    kappa_c_no_shift = 1.0 / R0\n\n    # Step 4: ITG Growth Rate Model Components\n    Ti_J = Ti_eV * e  # Convert ion temperature to Joules\n\n    # If k_y is zero, all frequencies are zero, so growths and delta_gamma are zero.\n    if k_y == 0.0:\n        return [delta_r, kappa_c_with_shift, 0.0]\n\n    # Diamagnetic frequency\n    omega_star_T = (k_y * Ti_J) / (e * B * L_Ti)\n\n    # FLR weakening factor\n    # rho_i = sqrt(2 * Ti_J * m_i) / (e * B)\n    rho_i_sq = (2 * Ti_J * m_i) / (e**2 * B**2)\n    S = 1.0 / (1.0 + k_y**2 * rho_i_sq)\n\n    # Curvature drift frequencies\n    # omega_D = k_y * (2 * Ti_J) / (e * B) * kappa_c\n    omega_D_coeff = k_y * (2 * Ti_J) / (e * B)\n    omega_D_with_shift = omega_D_coeff * kappa_c_with_shift\n    omega_D_no_shift = omega_D_coeff * kappa_c_no_shift\n\n    # Calculate growth rates using the full formula\n    drive_term = S * omega_star_T\n    gamma_with_shift = max(0, drive_term - omega_D_with_shift)\n    gamma_no_shift = max(0, drive_term - omega_D_no_shift)\n\n    # Step 5: Change in Growth Rate\n    delta_gamma = gamma_with_shift - gamma_no_shift\n    \n    return [delta_r, kappa_c_with_shift, delta_gamma]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "大规模的仿星器优化设计依赖于基于梯度的算法，以便在巨大的线圈几何参数空间中高效地寻找最优解。因此，精确且高效地计算目标函数对于设计参数的梯度至关重要。虽然有限差分法提供了一种直观的数值近似，但伴随方法（adjoint method）能够以极低的计算成本得到梯度的精确解析形式。本练习  将让您聚焦于这一优化过程的数值核心：您将首先推导一个湍流代理模型（turbulence proxy）的解析梯度，然后将其与数值有限差分计算出的近似梯度进行比较。这项实践通常被称为“梯度检验”（gradient check），是确保优化算法正确性的关键一步，对于开发和调试任何科学计算领域的复杂优化代码都至关重要。",
            "id": "4201435",
            "problem": "您的任务是实现并验证用于仿星器优化以减少湍流的简化湍流代理目标函数的梯度计算。在先进的仿星器设计中，通常通过优化线圈和边界几何形状来改变曲率和剪切分布，从而追求湍流的减少，这些分布会影响漂移波湍流的驱动。在本问题中，您将考虑一个固定极向模数的单一边界形状模，并量化有限差分梯度相对于一个光滑代理模型的伴随法计算的解析梯度的精度。\n\n考虑在极向角域 $\\theta \\in [0,2\\pi)$ 上定义的一个归一化、无量纲的湍流代理目标函数：\n$$\nJ(a) \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} W(\\theta)\\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 \\, d\\theta,\n$$\n其中 $a$ 是边界模振幅，$W(\\theta)$ 是一个表示场线采样的正权重函数，$\\mathrm{sp}(x,\\delta)$ 是由softplus函数定义的光滑正部近似，而 $\\Gamma(\\theta;a)$ 是局域线性增长率驱动的一个光滑代理。softplus函数定义为\n$$\n\\mathrm{sp}(x,\\delta) = \\delta \\ln\\left(1 + e^{x/\\delta}\\right),\n$$\n其中 $\\delta>0$ 控制光滑度。增长率代理模型为\n$$\n\\Gamma(\\theta;a) = C_{\\mathrm{curv}}\\,\\kappa_{\\mathrm{eff}}(\\theta;a) - C_{\\mathrm{shear}}\\,\\hat{s}(\\theta;a) - C_{\\mathrm{stab}},\n$$\n其中 $C_{\\mathrm{curv}}>0$、$C_{\\mathrm{shear}}>0$ 和 $C_{\\mathrm{stab}}>0$ 是无量纲系数，反映了归一化的曲率驱动和剪切稳定化。有效法向曲率和局域磁剪切参数化为\n$$\n\\kappa_{\\mathrm{eff}}(\\theta;a) = \\kappa_0 \\cos(\\theta) + a\\,\\kappa_1 \\cos(m\\theta+\\phi),\n\\quad\n\\hat{s}(\\theta;a) = s_0 + a\\,s_1 \\sin(m\\theta+\\phi),\n$$\n其中 $\\kappa_0>0$、$\\kappa_1>0$、$s_0>0$、$s_1>0$，$m\\in\\mathbb{Z}^+$ 是固定的极向模数，$\\phi$ 是相位偏移。权重函数为\n$$\nW(\\theta) = 1 + w_2 \\cos(2\\theta),\n$$\n其中 $|w_2| < 1$ 以确保其为正。本问题中所有量均为无量纲。这些函数在定义域上是光滑且可积的。\n\n从上述定义和“压力梯度驱动的微观不稳定性会被坏曲率增强，并被磁剪切减弱”这一基本原理出发，通过在积分号下微分并使用链式法则，推导伴随（解析）梯度 $dJ/da$。softplus函数的导数为\n$$\n\\frac{d}{dx}\\mathrm{sp}(x,\\delta) = \\sigma\\!\\left(\\frac{x}{\\delta}\\right),\n\\quad\n\\sigma(z)=\\frac{1}{1+e^{-z}},\n$$\n即逻辑斯谛函数。然后，对于一个固定的基准振幅 $a_0$ 和一组扰动振幅 $h$，量化中心有限差分梯度近似与伴随梯度之间的相对误差。使用中心有限差分\n$$\ng_{\\mathrm{fd}}(h) = \\frac{J(a_0+h)-J(a_0-h)}{2h},\n$$\n和伴随梯度\n$$\ng_{\\mathrm{adj}} = \\frac{dJ}{da}\\bigg|_{a=a_0}.\n$$\n相对误差定义为\n$$\nE(h) = \\frac{\\left|g_{\\mathrm{fd}}(h)-g_{\\mathrm{adj}}\\right|}{\\left|g_{\\mathrm{adj}}\\right|+\\varepsilon},\n$$\n其中 $\\varepsilon>0$ 是一个小的稳定化参数，以避免除以零。\n\n使用以下科学上合理的参数值：\n- 基准振幅：$a_0 = 5\\times 10^{-2}$。\n- 极向模数：$m = 3$。\n- 相位：$\\phi = \\pi/7$。\n- 曲率参数：$\\kappa_0 = 3\\times 10^{-1}$，$\\kappa_1 = 2\\times 10^{-1}$。\n- 剪切参数：$s_0 = 5\\times 10^{-1}$，$s_1 = 2\\times 10^{-1}$。\n- 系数：$C_{\\mathrm{curv}} = 8\\times 10^{-1}$，$C_{\\mathrm{shear}} = 6\\times 10^{-1}$，$C_{\\mathrm{stab}} = 2\\times 10^{-1}$。\n- 权重参数：$w_2 = 1\\times 10^{-1}$。\n- Softplus光滑度：$\\delta = 1\\times 10^{-3}$。\n- 相对误差稳定化参数：$\\varepsilon = 1\\times 10^{-12}$。\n\n使用至少 $N=4096$ 个点，在 $\\theta \\in [0,2\\pi)$ 上通过均匀求积法数值计算定义 $J(a)$ 的积分。完全按照您的推导，通过对推导出的被积函数进行积分来计算伴随梯度。然后，为测试套件中的每个扰动振幅 $h$ 计算中心有限差分近似。\n\n测试套件：\n- 情况 1：$h = 1\\times 10^{-1}$。\n- 情况 2：$h = 1\\times 10^{-2}$。\n- 情况 3：$h = 5\\times 10^{-3}$。\n- 情况 4：$h = 1\\times 10^{-3}$。\n- 情况 5：$h = 1\\times 10^{-4}$。\n- 情况 6：$h = 1\\times 10^{-6}$。\n\n您的程序应生成单行输出，其中包含测试用例的相对误差，形式为逗号分隔的列表，并用方括号括起来，例如 $[E(h_1),E(h_2),\\dots,E(h_6)]$。所有输出必须是无量纲浮点数。数值算法必须是自包含的，不应需要任何外部输入。确保在计算 $\\mathrm{sp}(x,\\delta)$ 和 $\\sigma(z)$ 时，对于大的正或负参数，数值是稳定的。",
            "solution": "该问题定义明确，在等离子体湍流建模和数值优化的方法上具有科学依据，并提供了一套完整且一致的定义和参数。因此，该问题被认为是有效的。任务是推导给定目标函数的解析梯度，然后编写一个程序，将此解析梯度与数值有限差分近似进行比较。\n\n解决方案分为两个阶段：首先，梯度的解析推导；其次，描述计算所需量的数值算法。\n\n**1. 伴随梯度的解析推导**\n\n需要最小化的目标函数是湍流代理 $J(a)$，定义为：\n$$\nJ(a) \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} W(\\theta)\\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 \\, d\\theta\n$$\n这里，$a$ 是优化参数（边界模振幅）。我们寻求计算梯度 $dJ/da$。由于被积函数是参数 $a$ 的连续可微函数，我们可以应用Leibniz积分法则（在积分号下微分）：\n$$\n\\frac{dJ}{da} = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\frac{\\partial}{\\partial a} \\left( W(\\theta)\\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 \\right) \\, d\\theta\n$$\n权重函数 $W(\\theta)$ 与 $a$ 无关。对方括号内的项应用链式法则，得到：\n$$\n\\frac{\\partial}{\\partial a} \\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 = 2 \\cdot \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\cdot \\frac{\\partial}{\\partial a} \\left( \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right)\n$$\n我们再次对softplus函数的导数应用链式法则：\n$$\n\\frac{\\partial}{\\partial a} \\left( \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right) = \\frac{d}{d\\Gamma} \\left( \\mathrm{sp}(\\Gamma, \\delta) \\right) \\cdot \\frac{\\partial \\Gamma(\\theta;a)}{\\partial a}\n$$\n问题陈述中给出了softplus函数对其自变量的导数，即逻辑斯谛S型函数 $\\sigma$：\n$$\n\\frac{d}{d x} \\mathrm{sp}(x, \\delta) = \\sigma\\left(\\frac{x}{\\delta}\\right) \\quad \\text{其中} \\quad \\sigma(z) = \\frac{1}{1+e^{-z}}\n$$\n因此，$\\frac{d}{d\\Gamma} \\mathrm{sp}(\\Gamma, \\delta) = \\sigma(\\Gamma/\\delta)$。\n\n最后一部分是增长率代理 $\\Gamma$ 对 $a$ 的导数。该代理定义为：\n$$\n\\Gamma(\\theta;a) = C_{\\mathrm{curv}}\\,\\kappa_{\\mathrm{eff}}(\\theta;a) - C_{\\mathrm{shear}}\\,\\hat{s}(\\theta;a) - C_{\\mathrm{stab}}\n$$\n其导数为：\n$$\n\\frac{\\partial \\Gamma}{\\partial a} = C_{\\mathrm{curv}}\\frac{\\partial \\kappa_{\\mathrm{eff}}}{\\partial a} - C_{\\mathrm{shear}}\\frac{\\partial \\hat{s}}{\\partial a}\n$$\n有效曲率 $\\kappa_{\\mathrm{eff}}$ 和磁剪切 $\\hat{s}$ 对 $a$ 的依赖关系如下：\n$$\n\\kappa_{\\mathrm{eff}}(\\theta;a) = \\kappa_0 \\cos(\\theta) + a\\,\\kappa_1 \\cos(m\\theta+\\phi)\n$$\n$$\n\\hat{s}(\\theta;a) = s_0 + a\\,s_1 \\sin(m\\theta+\\phi)\n$$\n它们对 $a$ 的偏导数是直接的：\n$$\n\\frac{\\partial \\kappa_{\\mathrm{eff}}}{\\partial a} = \\kappa_1 \\cos(m\\theta+\\phi)\n$$\n$$\n\\frac{\\partial \\hat{s}}{\\partial a} = s_1 \\sin(m\\theta+\\phi)\n$$\n将这些代入 $\\partial \\Gamma / \\partial a$ 的表达式中：\n$$\n\\frac{\\partial \\Gamma(\\theta;a)}{\\partial a} = C_{\\mathrm{curv}}\\,\\kappa_1 \\cos(m\\theta+\\phi) - C_{\\mathrm{shear}}\\,s_1 \\sin(m\\theta+\\phi)\n$$\n将所有部分组合起来，梯度被积函数的完整表达式为：\n$$\n\\frac{\\partial}{\\partial a} \\left( L(\\theta,a) \\right) = W(\\theta) \\cdot 2 \\cdot \\mathrm{sp}(\\Gamma, \\delta) \\cdot \\sigma(\\Gamma/\\delta) \\cdot \\left[ C_{\\mathrm{curv}}\\,\\kappa_1 \\cos(m\\theta+\\phi) - C_{\\mathrm{shear}}\\,s_1 \\sin(m\\theta+\\phi) \\right]\n$$\n其中 $L(\\theta,a)$ 是 $J(a)$ 的被积函数，$\\Gamma$ 在 $(\\theta,a)$ 处求值。因此，在基准振幅 $a_0$ 处求值的伴随梯度是此表达式的积分：\n$$\ng_{\\mathrm{adj}} = \\frac{dJ}{da}\\bigg|_{a=a_0} = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\frac{\\partial}{\\partial a} \\left( L(\\theta,a) \\right) \\bigg|_{a=a_0} d\\theta\n$$\n\n**2. 数值评估**\n\n为了计算所需量，我们使用均匀求积网格将 $\\theta \\in [0, 2\\pi)$ 上的连续积分离散化。使用一组 $N$ 个点 $\\theta_i = i \\cdot (2\\pi/N)$，其中 $i = 0, 1, \\dots, N-1$。对于此区间上的任何周期函数 $f(\\theta)$，积分近似为：\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(\\theta) d\\theta \\approx \\frac{1}{2\\pi} \\sum_{i=0}^{N-1} f(\\theta_i) \\Delta\\theta = \\frac{1}{2\\pi} \\sum_{i=0}^{N-1} f(\\theta_i) \\frac{2\\pi}{N} = \\frac{1}{N} \\sum_{i=0}^{N-1} f(\\theta_i)\n$$\n这等价于取函数在网格点上求值的算术平均值。步骤如下：\n\n1.  **定义常量和网格**：定义所有物理和数值参数（$a_0, m, \\phi, C_{\\mathrm{curv}}$ 等）。创建一个大小为 $N=4096$ 的 $\\theta$ 均匀网格。\n2.  **实现数值稳定函数**：softplus函数 $\\mathrm{sp}(x,\\delta) = \\delta \\ln(1 + e^{x/\\delta})$ 和逻辑斯谛函数 $\\sigma(z) = 1/(1+e^{-z})$ 在处理大的正参数时可能遭遇浮点溢出，或在处理大的负参数时损失精度。必须使用数值稳定的重构形式来实现它们。对于softplus，使用log-sum-exp恒等式 $\\ln(e^A+e^B) = \\max(A,B) + \\ln(1+e^{-|A-B|})$。对于逻辑斯谛函数，当 $z < 0$ 时，使用恒等式 $\\sigma(z) = e^z / (1+e^z)$ 以避免计算大的正数 $-z$ 的 $e^{-z}$。\n3.  **计算伴随梯度 $g_{\\mathrm{adj}}$**：在网格的每个点 $\\theta_i$ 上，使用 $a=a_0$ 计算上述推导的梯度被积函数的解析表达式。这些值的平均值即为 $g_{\\mathrm{adj}}$ 的数值近似。\n4.  **计算有限差分梯度 $g_{\\mathrm{fd}}(h)$**：对于测试套件中的每个扰动大小 $h$，通过数值积分其定义表达式，在 $a_0+h$ 和 $a_0-h$ 处计算目标函数 $J$。然后，计算中心有限差分近似为 $g_{\\mathrm{fd}}(h) = \\frac{J(a_0+h)-J(a_0-h)}{2h}$。\n5.  **计算相对误差 $E(h)$**：对于每个 $h$，使用提供的公式计算有限差分梯度与伴随梯度之间的相对误差：$E(h) = \\frac{\\left|g_{\\mathrm{fd}}(h)-g_{\\mathrm{adj}}\\right|}{\\left|g_{\\mathrm{adj}}\\right|+\\varepsilon}$。小参数 $\\varepsilon$ 确保在梯度接近零时计算的稳定性。\n6.  **输出结果**：收集所有测试用例计算出的相对误差，并以指定格式打印。\n\n这一严谨过程通过可信的数值近似验证了解析推导，这是开发和验证复杂科学模拟与优化代码中一个标准且关键的步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error between central finite-difference and adjoint gradients\n    for a simplified stellarator turbulence proxy objective function.\n    \"\"\"\n\n    # 1. Define problem parameters and constants.\n    # Baseline amplitude\n    a0 = 5e-2\n    # Poloidal mode number\n    m = 3\n    # Phase\n    phi = np.pi / 7\n    # Curvature parameters\n    kappa0 = 3e-1\n    kappa1 = 2e-1\n    # Shear parameters\n    s0 = 5e-1\n    s1 = 2e-1\n    # Coefficients\n    C_curv = 8e-1\n    C_shear = 6e-1\n    C_stab = 2e-1\n    # Weight parameter\n    w2 = 1e-1\n    # Softplus smoothness\n    delta = 1e-3\n    # Stabilization for relative error\n    epsilon = 1e-12\n    # Numerical integration points\n    N_POINTS = 4096\n    \n    # Test suite for finite-difference perturbation amplitudes\n    test_cases_h = [1e-1, 1e-2, 5e-3, 1e-3, 1e-4, 1e-6]\n\n    # 2. Set up the numerical grid for integration.\n    theta_grid = np.linspace(0.0, 2.0 * np.pi, N_POINTS, endpoint=False)\n\n    # 3. Implement numerically stable helper functions.\n    def safe_softplus(x, d):\n        \"\"\"Numerically stable softplus function sp(x,d) = d*log(1+exp(x/d)).\"\"\"\n        # Uses the log-sum-exp trick for stability.\n        # log(1+exp(y)) = log(exp(0)+exp(y)) = max(0,y) + log(exp(-max(0,y)) + exp(y-max(0,y)))\n        y = x / d\n        max_y = np.maximum(0, y)\n        log_exp_sum = max_y + np.log(np.exp(-max_y) + np.exp(y - max_y))\n        return d * log_exp_sum\n\n    def safe_logistic(z):\n        \"\"\"Numerically stable logistic sigmoid function sigma(z) = 1/(1+exp(-z)).\"\"\"\n        result = np.zeros_like(z, dtype=float)\n        # For z >= 0, the standard formula is stable.\n        pos_mask = z >= 0\n        result[pos_mask] = 1.0 / (1.0 + np.exp(-z[pos_mask]))\n        # For z < 0, use sigma(z) = exp(z) / (1 + exp(z)) to avoid overflow in exp(-z).\n        neg_mask = z < 0\n        exp_z_neg = np.exp(z[neg_mask])\n        result[neg_mask] = exp_z_neg / (1.0 + exp_z_neg)\n        return result\n\n    # 4. Implement functions for the physical model.\n    def get_kappa_eff(theta_pts, a):\n        return kappa0 * np.cos(theta_pts) + a * kappa1 * np.cos(m * theta_pts + phi)\n\n    def get_s_hat(theta_pts, a):\n        return s0 + a * s1 * np.sin(m * theta_pts + phi)\n\n    def get_gamma_proxy(theta_pts, a):\n        return (C_curv * get_kappa_eff(theta_pts, a)\n                - C_shear * get_s_hat(theta_pts, a)\n                - C_stab)\n\n    def get_weight(theta_pts):\n        return 1.0 + w2 * np.cos(2.0 * theta_pts)\n\n    # 5. Implement functions for objective function and its gradient.\n    def calculate_J(a):\n        \"\"\"Computes the objective function J(a) via numerical quadrature.\"\"\"\n        gamma = get_gamma_proxy(theta_grid, a)\n        sp_gamma = safe_softplus(gamma, delta)\n        W = get_weight(theta_grid)\n        integrand = W * (sp_gamma**2)\n        # Integral approx: (1/2pi) * sum(f_i * dtheta) = mean(f)\n        return np.mean(integrand)\n\n    def calculate_dJ_da(a):\n        \"\"\"Computes the adjoint gradient dJ/da via numerical quadrature.\"\"\"\n        W = get_weight(theta_grid)\n        gamma = get_gamma_proxy(theta_grid, a)\n        sp_gamma = safe_softplus(gamma, delta)\n        sigma_gamma = safe_logistic(gamma / delta)\n        d_gamma_da = (C_curv * kappa1 * np.cos(m * theta_grid + phi)\n                      - C_shear * s1 * np.sin(m * theta_grid + phi))\n        integrand = W * 2.0 * sp_gamma * sigma_gamma * d_gamma_da\n        return np.mean(integrand)\n\n    # 6. Perform the main computation.\n    # Calculate the analytic (adjoint) gradient once at a = a0.\n    g_adj = calculate_dJ_da(a0)\n\n    results = []\n    for h in test_cases_h:\n        # Calculate the objective function at perturbed points.\n        J_plus_h = calculate_J(a0 + h)\n        J_minus_h = calculate_J(a0 - h)\n        \n        # Compute the central finite-difference gradient.\n        g_fd = (J_plus_h - J_minus_h) / (2.0 * h)\n        \n        # Compute the relative error.\n        relative_error = np.abs(g_fd - g_adj) / (np.abs(g_adj) + epsilon)\n        results.append(relative_error)\n\n    # 7. Print the final results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "仿星器的设计本质上是一个多目标优化问题。例如，我们既希望最小化湍流输运以改善等离子体约束，但这往往会导致磁体线圈的几何形状变得更复杂、建造成本也更高。一个理想的设计方案因此并非一个单一的最优点，而是对多个冲突目标的一种权衡。本练习  将向您介绍帕累托前沿（Pareto front）的概念，它由所有“非支配解”构成；如果不存在任何一个在所有目标上都更优的解，那么当前解就是帕累托最优的。您将为一组候选设计计算湍流和线圈复杂度的代理目标值，并找出构成帕累托前沿的配置。这项实践将使您掌握在复杂科学与工程设计中分析权衡、做出明智决策的核心方法。",
            "id": "4201430",
            "problem": "给定一组候选仿星器磁平衡，由无量纲参数描述。目标是为每个候选位形计算两个目标值，这两个目标值分别定量地反映湍流输运的代理指标和线圈工程复杂度的代理指标，然后为这两个目标的同时最小化构建帕累托前沿 (Pareto front)。帕累托前沿应包含那些不存在任何其他位形能同时在湍流代理和线圈复杂度代理上都更低（且至少有一个是严格更优）的位形。最终答案必须是单行输出，包含一个用方括号括起来、按升序排列的帕累托最优位形的索引列表（以逗号分隔）。\n\n从以下适用于聚变等离子体湍流和线圈复杂度的基本依据开始：\n\n- 根据回旋动理学理论，离子温度梯度驱动会产生一种线性不稳定性，其特征是增长率与离子抗磁频率和不利（坏）曲率的度量成比例。磁剪切的作用是稳定的。与这些特性一致，使用一个无量纲的线性增长率代理，定义为\n$$\\gamma_{\\mathrm{lin}} = C_{\\mathrm{gb}} \\left(\\frac{a}{L_T}\\right) f_{\\mathrm{curv}}(\\kappa_c,q),$$\n其中 $C_{\\mathrm{gb}}$ 是一个正常数，$\\frac{a}{L_T}$ 是归一化温度梯度，$\\kappa_c$ 是一个无量纲的坏曲率幅度，$q$ 是安全因子，$f_{\\mathrm{curv}}$ 是一个随 $\\kappa_c$ 增加、随 $q$ 减小的无量纲函数。对于此问题，取\n$$f_{\\mathrm{curv}}(\\kappa_c,q) = \\frac{\\kappa_c}{1+q^2}.$$\n定义一个无量纲的剪切稳定代理为\n$$\\gamma_{\\mathrm{shear}} = C_{\\mathrm{sh}} \\left| \\hat{s} \\right|,$$\n其中 $C_{\\mathrm{sh}}$ 是一个正常数，$\\hat{s}$ 是局部磁剪切。则有效不稳定性水平代理为\n$$\\gamma_{\\mathrm{eff}} = \\max\\left(0,\\ \\gamma_{\\mathrm{lin}} - \\gamma_{\\mathrm{shear}}\\right).$$\n定义湍流目标为\n$$J_{\\mathrm{turb}} = \\gamma_{\\mathrm{eff}}.$$\n\n- 对于线圈工程复杂度，使用一个受弯曲和扭转能量惩罚以及线圈长度启发的代理。令 $c_{\\mathrm{amp}}$ 为无量纲曲率幅度，$t_{\\mathrm{amp}}$ 为无量纲挠率幅度，$L_{\\mathrm{norm}}$ 为无量纲归一化长度。定义\n$$J_{\\mathrm{coil}} = \\alpha\\, c_{\\mathrm{amp}}^2 + \\beta\\, t_{\\mathrm{amp}}^2 + \\lambda\\, L_{\\mathrm{norm}},$$\n其中 $\\alpha$、$\\beta$ 和 $\\lambda$ 是正常数权重。\n\n给定以下常量：\n- $C_{\\mathrm{gb}} = 0.35$，\n- $C_{\\mathrm{sh}} = 0.8$，\n- $\\alpha = 1.0$，\n- $\\beta = 0.6$，\n- $\\lambda = 0.2$，\n\n以及以下 7 个候选位形列表，每个位形由元组指定\n$$(\\kappa_c,\\ \\hat{s},\\ a/L_T,\\ q,\\ c_{\\mathrm{amp}},\\ t_{\\mathrm{amp}},\\ L_{\\mathrm{norm}}),$$\n计算每个位形的 $J_{\\mathrm{turb}}$ 和 $J_{\\mathrm{coil}}$，然后识别出在 $\\left(J_{\\mathrm{turb}}, J_{\\mathrm{coil}}\\right)$ 双目标最小化问题中位于帕累托前沿上的位形索引。对位形使用从零开始的索引。\n\n候选位形如下：\n- 索引 $0$：$(0.8,\\ 0.6,\\ 3.0,\\ 1.2,\\ 0.35,\\ 0.4,\\ 1.0)$。\n- 索引 $1$：$(1.4,\\ 0.2,\\ 4.0,\\ 1.0,\\ 0.8,\\ 0.9,\\ 1.4)$。\n- 索引 $2$：$(0.5,\\ 0.3,\\ 2.0,\\ 1.5,\\ 0.2,\\ 0.25,\\ 0.9)$。\n- 索引 $3$：$(1.0,\\ 0.4,\\ 3.5,\\ 1.3,\\ 0.5,\\ 0.45,\\ 1.1)$。\n- 索引 $4$：$(1.0,\\ 0.4,\\ 3.5,\\ 1.3,\\ 0.5,\\ 0.45,\\ 1.1)$。\n- 索引 $5$：$(0.9,\\ 0.1,\\ 1.8,\\ 0.9,\\ 0.15,\\ 0.15,\\ 0.7)$。\n- 索引 $6$：$(1.2,\\ 0.532,\\ 3.0,\\ 1.4,\\ 0.4,\\ 0.5,\\ 1.2)$。\n\n你的程序必须：\n- 使用上述公式为每个候选位形计算 $J_{\\mathrm{turb}}$ 和 $J_{\\mathrm{coil}}$。\n- 根据规则构建帕累托前沿：当且仅当 $J_{\\mathrm{turb}}(j) \\le J_{\\mathrm{turb}}(i)$ 且 $J_{\\mathrm{coil}}(j) \\le J_{\\mathrm{coil}}(i)$，并且这两个不等式中至少有一个是严格不等式时，位形 $i$ 被位形 $j$ 支配。不被任何其他位形支配的位形是帕累托最优的。\n- 生成单行输出，包含帕累托最优位形的已排序索引，以逗号分隔并用方括号括起来（例如，$[0,2,5]$）。不允许有其他输出。\n\n此问题中的所有量都是无量纲的，因此不需要物理单位。上述测试套件涵盖了一般情况、当 $\\gamma_{\\mathrm{lin}} = \\gamma_{\\mathrm{shear}}$ 时 $J_{\\mathrm{turb}}$ 过渡到零的边界情况，以及一个包含重复位形以测试支配关系中平局处理的边缘情况。",
            "solution": "经评估，用户提供的问题是有效的。它在科学上基于与仿星器优化相关的等离子体湍流和磁线圈复杂度的简化但有物理动机的模型。该问题在数学上是适定的，提供了计算唯一解所需的所有数据、常数和明确定义。语言客观，要求明确。因此，下面提供一个合理的解答。\n\n核心任务是为一组仿星器位形执行双目标优化。需要最小化的两个目标是湍流输运的代理 $J_{\\mathrm{turb}}$ 和线圈复杂度的代理 $J_{\\mathrm{coil}}$。解决方案包括为每个候选位形计算这两个目标，然后识别出非支配集，即帕累托前沿。\n\n首先，我们根据所提供的物理模型和参数定义目标函数。给定的常数为 $C_{\\mathrm{gb}} = 0.35$，$C_{\\mathrm{sh}} = 0.8$，$\\alpha = 1.0$，$\\beta = 0.6$ 和 $\\lambda = 0.2$。\n\n湍流目标 $J_{\\mathrm{turb}}$ 源于离子温度梯度（ITG）不稳定性驱动与磁剪切稳定作用之间的平衡。线性增长率代理 $\\gamma_{\\mathrm{lin}}$ 由下式给出：\n$$ \\gamma_{\\mathrm{lin}} = C_{\\mathrm{gb}} \\left(\\frac{a}{L_T}\\right) f_{\\mathrm{curv}}(\\kappa_c,q) $$\n其中曲率函数为：\n$$ f_{\\mathrm{curv}}(\\kappa_c,q) = \\frac{\\kappa_c}{1+q^2} $$\n剪切稳定代理 $\\gamma_{\\mathrm{shear}}$ 为：\n$$ \\gamma_{\\mathrm{shear}} = C_{\\mathrm{sh}} \\left| \\hat{s} \\right| $$\n有效不稳定性水平，也即湍流目标，是这两者之差，并以零为下限：\n$$ J_{\\mathrm{turb}} = \\gamma_{\\mathrm{eff}} = \\max\\left(0,\\ \\gamma_{\\mathrm{lin}} - \\gamma_{\\mathrm{shear}}\\right) $$\n\n线圈复杂度目标 $J_{\\mathrm{coil}}$ 是线圈弯曲能量、扭转能量和长度代理的加权和：\n$$ J_{\\mathrm{coil}} = \\alpha\\, c_{\\mathrm{amp}}^2 + \\beta\\, t_{\\mathrm{amp}}^2 + \\lambda\\, L_{\\mathrm{norm}} $$\n\n对于 7 个候选位形中的每一个，由元组 $(\\kappa_c,\\ \\hat{s},\\ a/L_T,\\ q,\\ c_{\\mathrm{amp}},\\ t_{\\mathrm{amp}},\\ L_{\\mathrm{norm}})$ 指定，我们计算目标向量 $(J_{\\mathrm{turb}}, J_{\\mathrm{coil}})$。\n\n位形 $0$：$(\\kappa_c, \\hat{s}, a/L_T, q, c_{\\mathrm{amp}}, t_{\\mathrm{amp}}, L_{\\mathrm{norm}}) = (0.8, 0.6, 3.0, 1.2, 0.35, 0.4, 1.0)$\n$f_{\\mathrm{curv}} = \\frac{0.8}{1+1.2^2} \\approx 0.3279$。 $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.0 \\times 0.3279 \\approx 0.3443$。 $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.6| = 0.48$。\n$J_{\\mathrm{turb}} = \\max(0, 0.3443 - 0.48) = 0$。\n$J_{\\mathrm{coil}} = 1.0(0.35^2) + 0.6(0.4^2) + 0.2(1.0) = 0.1225 + 0.096 + 0.2 = 0.4185$。\n目标向量：$(0.0, 0.4185)$。\n\n位形 $1$：$(1.4, 0.2, 4.0, 1.0, 0.8, 0.9, 1.4)$\n$f_{\\mathrm{curv}} = \\frac{1.4}{1+1.0^2} = 0.7$。 $\\gamma_{\\mathrm{lin}} = 0.35 \\times 4.0 \\times 0.7 = 0.98$。 $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.2| = 0.16$。\n$J_{\\mathrm{turb}} = \\max(0, 0.98 - 0.16) = 0.82$。\n$J_{\\mathrm{coil}} = 1.0(0.8^2) + 0.6(0.9^2) + 0.2(1.4) = 0.64 + 0.486 + 0.28 = 1.406$。\n目标向量：$(0.82, 1.406)$。\n\n位形 $2$：$(0.5, 0.3, 2.0, 1.5, 0.2, 0.25, 0.9)$\n$f_{\\mathrm{curv}} = \\frac{0.5}{1+1.5^2} \\approx 0.1538$。 $\\gamma_{\\mathrm{lin}} = 0.35 \\times 2.0 \\times 0.1538 \\approx 0.1077$。 $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.3| = 0.24$。\n$J_{\\mathrm{turb}} = \\max(0, 0.1077 - 0.24) = 0$。\n$J_{\\mathrm{coil}} = 1.0(0.2^2) + 0.6(0.25^2) + 0.2(0.9) = 0.04 + 0.0375 + 0.18 = 0.2575$。\n目标向量：$(0.0, 0.2575)$。\n\n位形 $3$：$(1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1)$\n$f_{\\mathrm{curv}} = \\frac{1.0}{1+1.3^2} \\approx 0.3717$。 $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.5 \\times 0.3717 \\approx 0.4554$。 $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.4| = 0.32$。\n$J_{\\mathrm{turb}} = \\max(0, 0.4554 - 0.32) \\approx 0.1354$。\n$J_{\\mathrm{coil}} = 1.0(0.5^2) + 0.6(0.45^2) + 0.2(1.1) = 0.25 + 0.1215 + 0.22 = 0.5915$。\n目标向量：$(\\approx 0.1354, 0.5915)$。\n\n位形 $4$：$(1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1)$\n这与位形 3 相同。\n目标向量：$(\\approx 0.1354, 0.5915)$。\n\n位形 $5$：$(0.9, 0.1, 1.8, 0.9, 0.15, 0.15, 0.7)$\n$f_{\\mathrm{curv}} = \\frac{0.9}{1+0.9^2} \\approx 0.4972$。 $\\gamma_{\\mathrm{lin}} = 0.35 \\times 1.8 \\times 0.4972 \\approx 0.3132$。 $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.1| = 0.08$。\n$J_{\\mathrm{turb}} = \\max(0, 0.3132 - 0.08) \\approx 0.2332$。\n$J_{\\mathrm{coil}} = 1.0(0.15^2) + 0.6(0.15^2) + 0.2(0.7) = 0.0225 + 0.0135 + 0.14 = 0.176$。\n目标向量：$(\\approx 0.2332, 0.176)$。\n\n位形 $6$：$(1.2, 0.532, 3.0, 1.4, 0.4, 0.5, 1.2)$\n$f_{\\mathrm{curv}} = \\frac{1.2}{1+1.4^2} \\approx 0.4054$。 $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.0 \\times 0.4054 \\approx 0.42567$。 $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.532| = 0.4256$。\n$J_{\\mathrm{turb}} = \\max(0, 0.42567 - 0.4256) \\approx 0.0000757$。\n$J_{\\mathrm{coil}} = 1.0(0.4^2) + 0.6(0.5^2) + 0.2(1.2) = 0.16 + 0.15 + 0.24 = 0.55$。\n目标向量：$(\\approx 0.0000757, 0.55)$。\n\n计算出的目标向量 $(J_{\\mathrm{turb}}, J_{\\mathrm{coil}})$ 如下：\n- 索引 $0$：$(0.0, 0.4185)$\n- 索引 $1$：$(0.82, 1.406)$\n- 索引 $2$：$(0.0, 0.2575)$\n- 索引 $3$：$(\\approx 0.1354, 0.5915)$\n- 索引 $4$：$(\\approx 0.1354, 0.5915)$\n- 索引 $5$：$(\\approx 0.2332, 0.176)$\n- 索引 $6$：$(\\approx 0.0000757, 0.55)$\n\n接下来，我们识别帕累托前沿。如果 $J_{\\mathrm{turb}}(j) \\le J_{\\mathrm{turb}}(i)$ 且 $J_{\\mathrm{coil}}(j) \\le J_{\\mathrm{coil}}(i)$，并且其中至少一个不等式是严格的，则位形 $i$ 被位形 $j$ 支配。不被任何其他位形支配的位形构成帕累托前沿。\n\n- 位形 $1$ ($ (0.82, 1.406) $) 被所有其他位形支配，因为它们在两个目标上的值都更小。\n- 位形 $0$ ($ (0.0, 0.4185) $) 被位形 $2$ ($ (0.0, 0.2575) $) 支配，因为 $J_{\\mathrm{turb}}(2) = J_{\\mathrm{turb}}(0)$ 且 $J_{\\mathrm{coil}}(2) < J_{\\mathrm{coil}}(0)$。\n- 位形 $3$ 和 $4$ ($ (\\approx 0.1354, 0.5915) $) 被位形 $6$ ($ (\\approx 0.0000757, 0.55) $) 支配，因为 $J_{\\mathrm{turb}}(6) < J_{\\mathrm{turb}}(3,4)$ 且 $J_{\\mathrm{coil}}(6) < J_{\\mathrm{coil}}(3,4)$。注意，相同的位形不会相互支配，因为需要严格不等式。\n\n剩下的位形是 2、5 和 6。我们检查它们之间的相互支配关系：\n- 比较 $2$ ($ (0.0, 0.2575) $) 和 $5$ ($ (\\approx 0.2332, 0.176) $)：位形 2 的 $J_{\\mathrm{turb}}$ 较低，但位形 5 的 $J_{\\mathrm{coil}}$ 较低。两者互不支配。\n- 比较 $2$ ($ (0.0, 0.2575) $) 和 $6$ ($ (\\approx 0.0000757, 0.55) $)：位形 2 的 $J_{\\mathrm{turb}}$ 较低，但 $J_{\\mathrm{coil}}$ 较高。两者互不支配。\n- 比较 $5$ ($ (\\approx 0.2332, 0.176) $) 和 $6$ ($ (\\approx 0.0000757, 0.55) $)：位形 6 的 $J_{\\mathrm{turb}}$ 较低，但位形 5 的 $J_{\\mathrm{coil}}$ 较低。两者互不支配。\n\n因此，索引为 2、5 和 6 的位形不被任何其他位形支配。它们构成了帕累托前沿。这些索引按升序排列为 2、5、6。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes J_turb and J_coil for each candidate configuration, then identifies \n    and returns the indices of the Pareto-optimal configurations.\n    \"\"\"\n    \n    # Define the constants from the problem statement.\n    C_gb = 0.35\n    C_sh = 0.8\n    alpha = 1.0\n    beta = 0.6\n    lambda_ = 0.2\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (kappa_c, s_hat, a_over_LT, q, c_amp, t_amp, L_norm)\n    test_cases = [\n        (0.8, 0.6, 3.0, 1.2, 0.35, 0.4, 1.0),\n        (1.4, 0.2, 4.0, 1.0, 0.8, 0.9, 1.4),\n        (0.5, 0.3, 2.0, 1.5, 0.2, 0.25, 0.9),\n        (1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1),\n        (1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1),\n        (0.9, 0.1, 1.8, 0.9, 0.15, 0.15, 0.7),\n        (1.2, 0.532, 3.0, 1.4, 0.4, 0.5, 1.2),\n    ]\n\n    def calculate_objectives(config):\n        \"\"\"\n        Calculates J_turb and J_coil for a single configuration.\n        \"\"\"\n        kappa_c, s_hat, a_over_LT, q, c_amp, t_amp, L_norm = config\n        \n        # Calculate J_turb\n        f_curv = kappa_c / (1.0 + q**2)\n        gamma_lin = C_gb * a_over_LT * f_curv\n        gamma_shear = C_sh * abs(s_hat)\n        j_turb = max(0.0, gamma_lin - gamma_shear)\n        \n        # Calculate J_coil\n        j_coil = alpha * c_amp**2 + beta * t_amp**2 + lambda_ * L_norm\n        \n        return j_turb, j_coil\n\n    n_configs = len(test_cases)\n    objectives = [calculate_objectives(case) for case in test_cases]\n    \n    pareto_indices = []\n    for i in range(n_configs):\n        is_dominated = False\n        for j in range(n_configs):\n            if i == j:\n                continue\n            \n            i_turb, i_coil = objectives[i]\n            j_turb, j_coil = objectives[j]\n            \n            # Check if configuration j dominates configuration i\n            # This requires j to be better or equal on all objectives...\n            if j_turb <= i_turb and j_coil <= i_coil:\n                # ...and strictly better on at least one objective.\n                if j_turb < i_turb or j_coil < i_coil:\n                    is_dominated = True\n                    break # Found a dominator, no need to check further for i\n        \n        if not is_dominated:\n            if i not in pareto_indices:\n                pareto_indices.append(i)\n            \n    pareto_indices.sort()\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, pareto_indices))}]\")\n\nsolve()\n```"
        }
    ]
}