{
    "hands_on_practices": [
        {
            "introduction": "Before we can optimize a system to reduce turbulence, we must first understand its fundamental drivers. At its core, plasma turbulence is governed by the complex motion of particles, a key component of which is their rapid \"streaming\" along convoluted magnetic field lines. This exercise provides a foundational, hands-on experience in building a computational tool to quantify this effect, offering a direct look at how magnetic geometry, through the rotational transform $\\iota$, shapes the parallel dynamics that underpin turbulent transport .",
            "id": "4201414",
            "problem": "You are asked to implement the field-line-following coordinate transform in a large-aspect-ratio toroidal geometry and compute the parallel streaming term $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla$ acting on a scalar field along a selected magnetic field line for a given rotational transform profile $\\iota(\\psi)$. The overarching motivation is to quantify a streaming strength metric that can be used in stellarator optimization for reduced turbulence. The program must be a complete, runnable Python script that performs the following tasks for a set of test cases.\n\nFundamental base and definitions: Consider a magnetostatic magnetic field $\\mathbf{B}$ such that $\\nabla\\cdot\\mathbf{B}=0$ and field lines follow the unit vector $\\mathbf{b}=\\mathbf{B}/|\\mathbf{B}|$. In a torus of major radius $R_0$ and circular minor radius $r\\in[0,a]$, define cylindrical angles $(\\theta,\\phi)$, where $\\theta$ is the poloidal angle and $\\phi$ is the toroidal angle. The position mapping is $R(\\theta)=R_0+r\\cos\\theta$ and $Z(\\theta)=r\\sin\\theta$, with $R(\\theta)$ used for the azimuthal scale factor. In the orthogonal coordinates $(r,\\theta,\\phi)$ with scale factors $h_r=1$, $h_\\theta=r$, and $h_\\phi=R(\\theta)$, the gradient operator acting on a scalar $f(r,\\theta,\\phi)$ is\n$$\n\\nabla f=\\frac{\\partial f}{\\partial r}\\,\\mathbf{e}_r+\\frac{1}{r}\\frac{\\partial f}{\\partial \\theta}\\,\\mathbf{e}_\\theta+\\frac{1}{R(\\theta)}\\frac{\\partial f}{\\partial \\phi}\\,\\mathbf{e}_\\phi.\n$$\nAssume a dominant toroidal magnetic field $B_\\phi(\\theta)=B_0\\,\\frac{R_0}{R(\\theta)}$ and a poloidal magnetic field $B_\\theta(\\theta)$ chosen to realize a desired rotational transform $\\iota(\\psi)$ via the field-line relation\n$$\n\\frac{d\\theta}{d\\phi}=\\frac{\\mathbf{B}\\cdot\\nabla\\theta}{\\mathbf{B}\\cdot\\nabla\\phi}=\\iota(\\psi)=\\frac{B_\\theta(\\theta)\\,R(\\theta)}{B_\\phi(\\theta)\\,r},\n$$\nwhich yields $B_\\theta(\\theta)=\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}$. Treat $r$ as a constant along the field line (no radial drift), so $\\psi$ depends only on $r$. Use a dimensionless flux label\n$$\n\\psi=\\left(\\frac{r}{a}\\right)^2.\n$$\nDefine the field-line-following coordinate transform $(\\psi,\\theta,\\phi)\\mapsto(\\psi,\\alpha,\\phi)$ by\n$$\n\\alpha=\\theta-\\iota(\\psi)\\,\\phi,\n$$\nso a field line at fixed $\\psi$ is a curve of constant $\\alpha$ parameterized by $\\phi$.\n\nParallel streaming operator: The operator of interest is $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla$ acting on a dimensionless scalar field $g(\\psi,\\theta,\\phi)$. Along a field line at fixed $\\psi$ and constant $\\alpha$, express the operator in terms of $(\\theta(\\phi),\\phi)$ and the local magnetic field.\n\nScalar field specification: Use a dimensionless scalar field\n$$\ng(\\psi,\\theta,\\phi)=\\sin\\!\\big(m_1\\,\\theta+n_1\\,\\phi\\big)+c_2\\,\\cos\\!\\big(p_2\\,\\theta-q_2\\,\\phi\\big),\n$$\nwith integers $m_1,n_1,p_2,q_2$ and a real amplitude $c_2$. Angles must be in radians.\n\nTask requirements:\n- Implement the coordinate transform $\\alpha=\\theta-\\iota(\\psi)\\,\\phi$ and represent a field line by $\\alpha=\\text{constant}$ and $\\psi=\\text{constant}$.\n- For a given $\\iota(\\psi)$, compute $\\theta(\\phi)=\\alpha+\\iota(\\psi)\\,\\phi$ along the field line for $\\phi\\in[0,2\\pi)$.\n- Compute $R(\\theta)$, $B_\\phi(\\theta)=B_0\\,\\frac{R_0}{R(\\theta)}$, $B_\\theta(\\theta)=\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}$, and $|\\mathbf{B}(\\theta)|=\\sqrt{B_\\phi(\\theta)^2+B_\\theta(\\theta)^2}$.\n- Compute the parallel streaming term $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g$ along the field line and return a streaming strength metric defined as the root-mean-square over one toroidal transit,\n$$\nS_{\\mathrm{RMS}}=\\left(\\frac{1}{2\\pi}\\int_0^{2\\pi}\\big[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g\\big]^2\\,d\\phi\\right)^{1/2}.\n$$\n- Express the final answers in $\\mathrm{s}^{-1}$, rounded to six decimal places.\n\nRotational transform profile: Use a polynomial profile\n$$\n\\iota(\\psi)=\\iota_0+s_1\\,\\psi+s_2\\,\\psi^2,\n$$\nwhere $\\iota_0$, $s_1$, and $s_2$ are real parameters.\n\nTest suite and coverage: Your program must evaluate $S_{\\mathrm{RMS}}$ for the following four test cases, covering a general case, near-axis behavior, high transform, and strong geometry variation. All angles are in radians. All lengths are in meters. Magnetic field is in tesla. Parallel speed is in meters per second. The flux label $\\psi$ is dimensionless as defined above. The scalar field $g$ parameters are dimensionless.\n\n- Test case $1$ (general case):\n    - $R_0=3.0$, $a=0.3$, $r=0.15$, $B_0=3.0$, $v_{\\parallel}=1.0\\times 10^5$, $\\alpha=0.2$,\n    - $\\iota_0=0.4$, $s_1=0.3$, $s_2=0.0$,\n    - $m_1=2$, $n_1=1$, $c_2=0.35$, $p_2=3$, $q_2=2$.\n\n- Test case $2$ (near-axis limit):\n    - $R_0=3.0$, $a=0.3$, $r=1.0\\times 10^{-6}$, $B_0=3.0$, $v_{\\parallel}=1.0\\times 10^5$, $\\alpha=0.0$,\n    - $\\iota_0=0.8$, $s_1=0.0$, $s_2=0.0$,\n    - $m_1=1$, $n_1=3$, $c_2=0.20$, $p_2=4$, $q_2=1$.\n\n- Test case $3$ (high transform with shear and curvature):\n    - $R_0=1.5$, $a=0.5$, $r=0.25$, $B_0=2.5$, $v_{\\parallel}=2.0\\times 10^5$, $\\alpha=1.0$,\n    - $\\iota_0=1.0$, $s_1=-0.5$, $s_2=0.2$,\n    - $m_1=3$, $n_1=2$, $c_2=0.40$, $p_2=1$, $q_2=3$.\n\n- Test case $4$ (strong geometry variation, low transform baseline):\n    - $R_0=4.0$, $a=0.8$, $r=0.4$, $B_0=5.0$, $v_{\\parallel}=0.5\\times 10^5$, $\\alpha=2.0$,\n    - $\\iota_0=0.2$, $s_1=0.6$, $s_2=-0.1$,\n    - $m_1=5$, $n_1=0$, $c_2=0.0$, $p_2=0$, $q_2=0$.\n\nNumerical integration and output:\n- Approximate the integral over $\\phi$ using a uniform discretization of $N=4096$ points in $\\phi\\in[0,2\\pi)$.\n- Your program should produce a single line of output containing the results as a comma-separated list of four floating-point numbers, each rounded to six decimal places and expressed in $\\mathrm{s}^{-1}$, enclosed in square brackets (for example, \"[$x_1,x_2,x_3,x_4$]\").",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded computational task within the field of plasma physics. We will proceed with a full solution. The objective is to compute a streaming strength metric, $S_{\\mathrm{RMS}}$, for a scalar field along a magnetic field line in a simplified toroidal magnetic geometry. This requires deriving the parallel streaming operator and then implementing a numerical procedure to evaluate its root-mean-square (RMS) value.\n\nFirst, we establish the analytical form of the parallel streaming operator, $v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla$. In the specified orthogonal coordinate system $(r,\\theta,\\phi)$ with scale factors $h_r=1$, $h_\\theta=r$, and $h_\\phi=R(\\theta)=R_0+r\\cos\\theta$, the gradient of a scalar field $f(r,\\theta,\\phi)$ is given by:\n$$\n\\nabla f = \\frac{\\partial f}{\\partial r}\\,\\mathbf{e}_r + \\frac{1}{r}\\frac{\\partial f}{\\partial \\theta}\\,\\mathbf{e}_\\theta + \\frac{1}{R(\\theta)}\\frac{\\partial f}{\\partial \\phi}\\,\\mathbf{e}_\\phi\n$$\nThe problem defines a magnetostatic field $\\mathbf{B}$ and assumes that field lines lie on surfaces of constant radius $r$. This implies that the radial component of the magnetic field, $B_r$, is zero. Thus, the magnetic field can be written as:\n$$\n\\mathbf{B} = B_\\theta(\\theta)\\,\\mathbf{e}_\\theta + B_\\phi(\\theta)\\,\\mathbf{e}_\\phi\n$$\nThe unit vector along the magnetic field is $\\mathbf{b} = \\mathbf{B}/|\\mathbf{B}|$. The action of the operator $\\mathbf{B}\\cdot\\nabla$ on a scalar field $g(r, \\theta, \\phi)$ is:\n$$\n\\mathbf{B}\\cdot\\nabla g = \\left( B_\\theta\\,\\mathbf{e}_\\theta + B_\\phi\\,\\mathbf{e}_\\phi \\right) \\cdot \\left( \\frac{\\partial g}{\\partial r}\\,\\mathbf{e}_r + \\frac{1}{r}\\frac{\\partial g}{\\partial \\theta}\\,\\mathbf{e}_\\theta + \\frac{1}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi}\\,\\mathbf{e}_\\phi \\right)\n$$\nDue to orthogonality of the basis vectors and $B_r=0$, this simplifies to:\n$$\n\\mathbf{B}\\cdot\\nabla g = \\frac{B_\\theta(\\theta)}{r}\\frac{\\partial g}{\\partial \\theta} + \\frac{B_\\phi(\\theta)}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi}\n$$\nThe partial derivatives are taken with respect to the coordinates $(\\psi, \\theta, \\phi)$ (or equivalently $(r, \\theta, \\phi)$ since $\\psi$ is a function of $r$ only), holding the other coordinates constant. The parallel gradient operator $\\mathbf{b}\\cdot\\nabla g$ is therefore:\n$$\n\\mathbf{b}\\cdot\\nabla g = \\frac{\\mathbf{B}\\cdot\\nabla g}{|\\mathbf{B}|} = \\frac{1}{|\\mathbf{B}(\\theta)|} \\left( \\frac{B_\\theta(\\theta)}{r}\\frac{\\partial g}{\\partial \\theta} + \\frac{B_\\phi(\\theta)}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi} \\right)\n$$\nwhere $|\\mathbf{B}(\\theta)| = \\sqrt{B_\\phi(\\theta)^2 + B_\\theta(\\theta)^2}$.\n\nThe poloidal field $B_\\theta(\\theta)$ is defined via the rotational transform $\\iota(\\psi)$ as $B_\\theta(\\theta)=\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}$. Substituting this into the expression for $\\mathbf{b}\\cdot\\nabla g$:\n$$\n\\mathbf{b}\\cdot\\nabla g = \\frac{1}{|\\mathbf{B}(\\theta)|} \\left( \\frac{1}{r} \\left(\\iota(\\psi)\\,B_\\phi(\\theta)\\,\\frac{r}{R(\\theta)}\\right) \\frac{\\partial g}{\\partial \\theta} + \\frac{B_\\phi(\\theta)}{R(\\theta)}\\frac{\\partial g}{\\partial \\phi} \\right)\n$$\nThe factor of $r$ cancels, yielding a more convenient form:\n$$\n\\mathbf{b}\\cdot\\nabla g = \\frac{B_\\phi(\\theta)}{R(\\theta)\\,|\\mathbf{B}(\\theta)|} \\left( \\iota(\\psi)\\frac{\\partial g}{\\partial \\theta} + \\frac{\\partial g}{\\partial \\phi} \\right)\n$$\nThis expression is evaluated along a specific magnetic field line. A field line is defined by a constant flux label $\\psi$ (and thus constant $r$) and a constant field-line label $\\alpha = \\theta - \\iota(\\psi)\\phi$. The poloidal angle $\\theta$ varies with the toroidal angle $\\phi$ according to $\\theta(\\phi) = \\alpha + \\iota(\\psi)\\phi$.\n\nThe specified scalar field is $g(\\psi,\\theta,\\phi)=\\sin(m_1\\,\\theta+n_1\\,\\phi)+c_2\\,\\cos(p_2\\,\\theta-q_2\\,\\phi)$. Its partial derivatives are:\n$$\n\\frac{\\partial g}{\\partial \\theta} = m_1 \\cos(m_1\\theta + n_1\\phi) - p_2 c_2 \\sin(p_2\\theta - q_2\\phi)\n$$\n$$\n\\frac{\\partial g}{\\partial \\phi} = n_1 \\cos(m_1\\theta + n_1\\phi) + q_2 c_2 \\sin(p_2\\theta - q_2\\phi)\n$$\n\nThe final metric is the streaming strength $S_{\\mathrm{RMS}}$, defined as the RMS of the parallel streaming term over one toroidal transit ($\\phi \\in [0,2\\pi)$):\n$$\nS_{\\mathrm{RMS}}=\\left(\\frac{1}{2\\pi}\\int_0^{2\\pi}\\big[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g\\big]^2\\,d\\phi\\right)^{1/2}\n$$\nThe integral is approximated numerically using a discrete sum over $N=4096$ points in $\\phi$. Let $\\phi_j = j \\frac{2\\pi}{N}$ for $j = 0, 1, \\dots, N-1$. The integral is then approximated as:\n$$\n\\int_0^{2\\pi} f(\\phi) \\, d\\phi \\approx \\sum_{j=0}^{N-1} f(\\phi_j) \\Delta\\phi = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} f(\\phi_j)\n$$\nTherefore, the RMS metric becomes:\n$$\nS_{\\mathrm{RMS}} \\approx \\left(\\frac{1}{2\\pi} \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} \\left[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g\\right]^2_{\\phi=\\phi_j} \\right)^{1/2} = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left[v_{\\parallel}\\,\\mathbf{b}\\cdot\\nabla g(\\phi_j)\\right]^2 \\right)^{1/2}\n$$\n\nThe computational procedure for each test case is as follows:\n1.  Unpack the physical and geometric parameters: $R_0, a, r, B_0, v_{\\parallel}, \\alpha$, the rotational transform parameters $\\iota_0, s_1, s_2$, and the scalar field parameters $m_1, n_1, c_2, p_2, q_2$.\n2.  Calculate the constant values for the field line:\n    -   $\\psi = (r/a)^2$.\n    -   $\\iota(\\psi) = \\iota_0 + s_1\\psi + s_2\\psi^2$.\n3.  Create a discrete grid of $N=4096$ points for the toroidal angle: $\\phi_j$ for $j=0, \\dots, N-1$.\n4.  For each point $\\phi_j$ on the grid:\n    a.  Compute the poloidal angle on the field line: $\\theta_j = \\alpha + \\iota(\\psi)\\phi_j$.\n    b.  Compute the major radius position: $R(\\theta_j) = R_0 + r \\cos(\\theta_j)$.\n    c.  Compute the magnetic field components: $B_{\\phi,j} = B_0 \\frac{R_0}{R(\\theta_j)}$ and $B_{\\theta,j} = \\iota(\\psi) B_{\\phi,j} \\frac{r}{R(\\theta_j)}$.\n    d.  Compute the magnetic field magnitude: $|\\mathbf{B}_j| = \\sqrt{B_{\\phi,j}^2 + B_{\\theta,j}^2}$.\n    e.  Evaluate the partial derivatives $\\partial g/\\partial\\theta$ and $\\partial g/\\partial\\phi$ at $(\\theta_j, \\phi_j)$.\n    f.  Assemble the parallel gradient: $(\\mathbf{b}\\cdot\\nabla g)_j = \\frac{B_{\\phi,j}}{R(\\theta_j)|\\mathbf{B}_j|} \\left( \\iota(\\psi) \\left(\\frac{\\partial g}{\\partial \\theta}\\right)_j + \\left(\\frac{\\partial g}{\\partial \\phi}\\right)_j \\right)$.\n    g.  Calculate the squared streaming term: $T_j = \\left(v_{\\parallel}(\\mathbf{b}\\cdot\\nabla g)_j\\right)^2$.\n5.  Compute the mean of the squared terms: $\\bar{T} = \\frac{1}{N} \\sum_{j=0}^{N-1} T_j$.\n6.  The final metric is the square root of this mean: $S_{\\mathrm{RMS}} = \\sqrt{\\bar{T}}$.\n7.  The result is then rounded to six decimal places, and its units are $\\mathrm{s}^{-1}$.\n\nThis procedure will be implemented for each of the four specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation for all test cases.\n    \"\"\"\n    \n    # Test cases as provided in the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {'R0': 3.0, 'a': 0.3, 'r': 0.15, 'B0': 3.0, 'v_par': 1.0e5, 'alpha': 0.2,\n         'iota0': 0.4, 's1': 0.3, 's2': 0.0,\n         'm1': 2, 'n1': 1, 'c2': 0.35, 'p2': 3, 'q2': 2},\n        # Test case 2 (near-axis limit)\n        {'R0': 3.0, 'a': 0.3, 'r': 1.0e-6, 'B0': 3.0, 'v_par': 1.0e5, 'alpha': 0.0,\n         'iota0': 0.8, 's1': 0.0, 's2': 0.0,\n         'm1': 1, 'n1': 3, 'c2': 0.20, 'p2': 4, 'q2': 1},\n        # Test case 3 (high transform with shear and curvature)\n        {'R0': 1.5, 'a': 0.5, 'r': 0.25, 'B0': 2.5, 'v_par': 2.0e5, 'alpha': 1.0,\n         'iota0': 1.0, 's1': -0.5, 's2': 0.2,\n         'm1': 3, 'n1': 2, 'c2': 0.40, 'p2': 1, 'q2': 3},\n        # Test case 4 (strong geometry variation, low transform baseline)\n        {'R0': 4.0, 'a': 0.8, 'r': 0.4, 'B0': 5.0, 'v_par': 0.5e5, 'alpha': 2.0,\n         'iota0': 0.2, 's1': 0.6, 's2': -0.1,\n         'm1': 5, 'n1': 0, 'c2': 0.0, 'p2': 0, 'q2': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        s_rms = calculate_streaming_metric(**params)\n        results.append(s_rms)\n\n    # Format the final output string exactly as required.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_streaming_metric(R0, a, r, B0, v_par, alpha, iota0, s1, s2, m1, n1, c2, p2, q2):\n    \"\"\"\n    Calculates the streaming strength metric S_RMS for a single test case.\n    \"\"\"\n    # Number of points for numerical integration\n    N = 4096\n\n    # Calculate constant parameters for the field line\n    psi = (r / a)**2\n    iota = iota0 + s1 * psi + s2 * psi**2\n\n    # Create the grid for the toroidal angle phi\n    phi = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # Calculate poloidal angle theta along the field line\n    theta = alpha + iota * phi\n\n    # Calculate geometric and magnetic field quantities along the field line\n    R_theta = R0 + r * np.cos(theta)\n    B_phi = B0 * R0 / R_theta\n    B_theta = iota * B_phi * r / R_theta\n    B_mag = np.sqrt(B_phi**2 + B_theta**2)\n\n    # Define arguments for the trigonometric functions in g\n    arg1 = m1 * theta + n1 * phi\n    arg2 = p2 * theta - q2 * phi\n\n    # Calculate partial derivatives of the scalar field g\n    # g = sin(arg1) + c2 * cos(arg2)\n    dg_dtheta = m1 * np.cos(arg1) - p2 * c2 * np.sin(arg2)\n    dg_dphi = n1 * np.cos(arg1) + q2 * c2 * np.sin(arg2)\n\n    # Calculate the parallel gradient of g\n    # b_dot_grad_g = (B_phi / (R_theta * B_mag)) * (iota * dg_dtheta + dg_dphi)\n    iota_dg_dtheta_plus_dg_dphi = iota * dg_dtheta + dg_dphi\n    b_dot_grad_g = (B_phi / (R_theta * B_mag)) * iota_dg_dtheta_plus_dg_dphi\n\n    # Calculate the full streaming term\n    streaming_term = v_par * b_dot_grad_g\n\n    # Calculate the RMS value\n    s_rms_squared = np.mean(streaming_term**2)\n    s_rms = np.sqrt(s_rms_squared)\n    \n    return s_rms\n\nsolve()\n```"
        },
        {
            "introduction": "Effective optimization hinges on knowing which direction to go. To improve a stellarator's performance, we must calculate how sensitive a turbulence metric is to changes in the device's shape—a task for which gradients are the essential tool. This practice delves into the mechanics of large-scale, gradient-based optimization by comparing a simple numerical finite-difference gradient with a far more efficient and elegant analytic \"adjoint\" gradient. Mastering this technique is crucial for navigating the vast parameter space of stellarator design and is a cornerstone of modern computational physics and engineering .",
            "id": "4201435",
            "problem": "You are tasked with implementing and validating gradient computations for a simplified turbulence-proxy objective used in stellarator optimization for reduced turbulence. In advanced stellarator design, turbulence reduction is often pursued by optimizing coil and boundary geometries to alter curvature and shear distributions, which influence drift-wave turbulence drive. In this problem, you will consider a single boundary shape mode at fixed poloidal mode number and quantify the accuracy of finite-difference gradients relative to an adjoint-computed analytic gradient for a smooth proxy model.\n\nConsider a normalized, dimensionless turbulence proxy objective defined on the poloidal angle domain $\\theta \\in [0,2\\pi)$:\n$$\nJ(a) \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} W(\\theta)\\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 \\, d\\theta,\n$$\nwhere $a$ is the boundary mode amplitude, $W(\\theta)$ is a positive weight function representing field-line sampling, $\\mathrm{sp}(x,\\delta)$ is the smooth approximation to the positive part defined by the softplus function, and $\\Gamma(\\theta;a)$ is a smooth proxy for the local linear growth rate drive. The softplus function is defined by\n$$\n\\mathrm{sp}(x,\\delta) = \\delta \\ln\\left(1 + e^{x/\\delta}\\right),\n$$\nwith $\\delta>0$ controlling smoothness. The growth-rate proxy is modeled as\n$$\n\\Gamma(\\theta;a) = C_{\\mathrm{curv}}\\,\\kappa_{\\mathrm{eff}}(\\theta;a) - C_{\\mathrm{shear}}\\,\\hat{s}(\\theta;a) - C_{\\mathrm{stab}},\n$$\nwhere $C_{\\mathrm{curv}}>0$, $C_{\\mathrm{shear}}>0$, and $C_{\\mathrm{stab}}>0$ are dimensionless coefficients that reflect normalized curvature drive and shear stabilization. The effective normal curvature and local magnetic shear are parameterized as\n$$\n\\kappa_{\\mathrm{eff}}(\\theta;a) = \\kappa_0 \\cos(\\theta) + a\\,\\kappa_1 \\cos(m\\theta+\\phi),\n\\quad\n\\hat{s}(\\theta;a) = s_0 + a\\,s_1 \\sin(m\\theta+\\phi),\n$$\nwhere $\\kappa_0>0$, $\\kappa_1>0$, $s_0>0$, $s_1>0$, $m\\in\\mathbb{Z}^+$ is the fixed poloidal mode number, and $\\phi$ is a phase offset. The weight function is\n$$\nW(\\theta) = 1 + w_2 \\cos(2\\theta),\n$$\nwith $|w_2|<1$ to ensure positivity. All quantities in this problem are dimensionless. The functions are smooth and integrable over the domain.\n\nStarting from the definitions above and fundamental principles that pressure-gradient-driven microinstabilities are enhanced by bad curvature and mitigated by magnetic shear, derive the adjoint (analytic) gradient $dJ/da$ by differentiating under the integral sign and using the chain rule. The derivative of the softplus is\n$$\n\\frac{d}{dx}\\mathrm{sp}(x,\\delta) = \\sigma\\!\\left(\\frac{x}{\\delta}\\right),\n\\quad\n\\sigma(z)=\\frac{1}{1+e^{-z}},\n$$\nthe logistic function. Then quantify the relative error between the central finite-difference gradient approximation and the adjoint gradient for a fixed baseline amplitude $a_0$ and a set of perturbation amplitudes $h$. Use the central finite difference\n$$\ng_{\\mathrm{fd}}(h) = \\frac{J(a_0+h)-J(a_0-h)}{2h},\n$$\nand the adjoint gradient\n$$\ng_{\\mathrm{adj}} = \\frac{dJ}{da}\\bigg|_{a=a_0}.\n$$\nDefine the relative error as\n$$\nE(h) = \\frac{\\left|g_{\\mathrm{fd}}(h)-g_{\\mathrm{adj}}\\right|}{\\left|g_{\\mathrm{adj}}\\right|+\\varepsilon},\n$$\nwith a small stabilization parameter $\\varepsilon>0$ to avoid division by zero.\n\nUse the following scientifically plausible parameter values:\n- Baseline amplitude: $a_0 = 5\\times 10^{-2}$.\n- Poloidal mode number: $m = 3$.\n- Phase: $\\phi = \\pi/7$.\n- Curvature parameters: $\\kappa_0 = 3\\times 10^{-1}$, $\\kappa_1 = 2\\times 10^{-1}$.\n- Shear parameters: $s_0 = 5\\times 10^{-1}$, $s_1 = 2\\times 10^{-1}$.\n- Coefficients: $C_{\\mathrm{curv}} = 8\\times 10^{-1}$, $C_{\\mathrm{shear}} = 6\\times 10^{-1}$, $C_{\\mathrm{stab}} = 2\\times 10^{-1}$.\n- Weight parameter: $w_2 = 1\\times 10^{-1}$.\n- Softplus smoothness: $\\delta = 1\\times 10^{-3}$.\n- Stabilization for relative error: $\\varepsilon = 1\\times 10^{-12}$.\n\nNumerically evaluate the integral defining $J(a)$ with a uniform quadrature over $\\theta \\in [0,2\\pi)$ using at least $N=4096$ points. Compute the adjoint gradient by integrating the derived integrand exactly as specified by your derivation. Then compute the central finite-difference approximation for each perturbation amplitude $h$ in the test suite.\n\nTest suite:\n- Case $1$: $h = 1\\times 10^{-1}$.\n- Case $2$: $h = 1\\times 10^{-2}$.\n- Case $3$: $h = 5\\times 10^{-3}$.\n- Case $4$: $h = 1\\times 10^{-3}$.\n- Case $5$: $h = 1\\times 10^{-4}$.\n- Case $6$: $h = 1\\times 10^{-6}$.\n\nYour program should produce a single line of output containing the relative errors for the test cases as a comma-separated list enclosed in square brackets, for example, $[E(h_1),E(h_2),\\dots,E(h_6)]$. All outputs must be dimensionless floats. The numerical algorithm must be self-contained and should not require any external input. Ensure numerical stability in the evaluation of $\\mathrm{sp}(x,\\delta)$ and $\\sigma(z)$ for large positive or negative arguments.",
            "solution": "The problem is well-posed, scientifically grounded in the methods of plasma turbulence modeling and numerical optimization, and provides a complete and consistent set of definitions and parameters. It is therefore deemed valid. The task is to derive the analytic gradient of a given objective function, and then to write a program to compare this analytic gradient against a numerical finite-difference approximation.\n\nThe solution proceeds in two stages: first, the analytical derivation of the gradient, and second, the description of the numerical algorithm to compute the required quantities.\n\n**1. Analytical Derivation of the Adjoint Gradient**\n\nThe objective function to be minimized is the turbulence proxy, $J(a)$, defined as:\n$$\nJ(a) \\equiv \\frac{1}{2\\pi}\\int_{0}^{2\\pi} W(\\theta)\\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 \\, d\\theta\n$$\nHere, $a$ is the optimization parameter (a boundary mode amplitude). We seek to compute the gradient $dJ/da$. Since the integrand is a continuously differentiable function of the parameter $a$, we can apply the Leibniz integral rule (differentiation under the integral sign):\n$$\n\\frac{dJ}{da} = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\frac{\\partial}{\\partial a} \\left( W(\\theta)\\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 \\right) \\, d\\theta\n$$\nThe weight function $W(\\theta)$ is independent of $a$. Applying the chain rule to the term in the square brackets gives:\n$$\n\\frac{\\partial}{\\partial a} \\left[ \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right]^2 = 2 \\cdot \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\cdot \\frac{\\partial}{\\partial a} \\left( \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right)\n$$\nWe apply the chain rule again to the derivative of the softplus function:\n$$\n\\frac{\\partial}{\\partial a} \\left( \\mathrm{sp}\\left(\\Gamma(\\theta;a), \\delta\\right) \\right) = \\frac{d}{d\\Gamma} \\left( \\mathrm{sp}(\\Gamma, \\delta) \\right) \\cdot \\frac{\\partial \\Gamma(\\theta;a)}{\\partial a}\n$$\nThe problem statement provides the derivative of the softplus function with respect to its argument, which is the logistic sigmoid function, $\\sigma$:\n$$\n\\frac{d}{d x} \\mathrm{sp}(x, \\delta) = \\sigma\\left(\\frac{x}{\\delta}\\right) \\quad \\text{where} \\quad \\sigma(z) = \\frac{1}{1+e^{-z}}\n$$\nThus, $\\frac{d}{d\\Gamma} \\mathrm{sp}(\\Gamma, \\delta) = \\sigma(\\Gamma/\\delta)$.\n\nThe final piece is the derivative of the growth-rate proxy, $\\Gamma$, with respect to $a$. The proxy is defined as:\n$$\n\\Gamma(\\theta;a) = C_{\\mathrm{curv}}\\,\\kappa_{\\mathrm{eff}}(\\theta;a) - C_{\\mathrm{shear}}\\,\\hat{s}(\\theta;a) - C_{\\mathrm{stab}}\n$$\nIts derivative is:\n$$\n\\frac{\\partial \\Gamma}{\\partial a} = C_{\\mathrm{curv}}\\frac{\\partial \\kappa_{\\mathrm{eff}}}{\\partial a} - C_{\\mathrm{shear}}\\frac{\\partial \\hat{s}}{\\partial a}\n$$\nThe dependencies of the effective curvature $\\kappa_{\\mathrm{eff}}$ and magnetic shear $\\hat{s}$ on $a$ are given as:\n$$\n\\kappa_{\\mathrm{eff}}(\\theta;a) = \\kappa_0 \\cos(\\theta) + a\\,\\kappa_1 \\cos(m\\theta+\\phi)\n$$\n$$\n\\hat{s}(\\theta;a) = s_0 + a\\,s_1 \\sin(m\\theta+\\phi)\n$$\nTheir partial derivatives with respect to $a$ are straightforward:\n$$\n\\frac{\\partial \\kappa_{\\mathrm{eff}}}{\\partial a} = \\kappa_1 \\cos(m\\theta+\\phi)\n$$\n$$\n\\frac{\\partial \\hat{s}}{\\partial a} = s_1 \\sin(m\\theta+\\phi)\n$$\nSubstituting these into the expression for $\\partial \\Gamma / \\partial a$:\n$$\n\\frac{\\partial \\Gamma(\\theta;a)}{\\partial a} = C_{\\mathrm{curv}}\\,\\kappa_1 \\cos(m\\theta+\\phi) - C_{\\mathrm{shear}}\\,s_1 \\sin(m\\theta+\\phi)\n$$\nCombining all the pieces, the full expression for the integrand of the gradient is:\n$$\n\\frac{\\partial}{\\partial a} \\left( L(\\theta,a) \\right) = W(\\theta) \\cdot 2 \\cdot \\mathrm{sp}(\\Gamma, \\delta) \\cdot \\sigma(\\Gamma/\\delta) \\cdot \\left[ C_{\\mathrm{curv}}\\,\\kappa_1 \\cos(m\\theta+\\phi) - C_{\\mathrm{shear}}\\,s_1 \\sin(m\\theta+\\phi) \\right]\n$$\nwhere $L(\\theta,a)$ is the integrand of $J(a)$, and $\\Gamma$ is evaluated at $(\\theta,a)$. The adjoint gradient, evaluated at the baseline amplitude $a_0$, is therefore the integral of this expression:\n$$\ng_{\\mathrm{adj}} = \\frac{dJ}{da}\\bigg|_{a=a_0} = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\frac{\\partial}{\\partial a} \\left( L(\\theta,a) \\right) \\bigg|_{a=a_0} d\\theta\n$$\n\n**2. Numerical Evaluation**\n\nTo compute the required quantities, we discretize the continuous integrals over $\\theta \\in [0, 2\\pi)$ using a uniform quadrature grid. A set of $N$ points $\\theta_i = i \\cdot (2\\pi/N)$ for $i = 0, 1, \\dots, N-1$ is used. For any periodic function $f(\\theta)$ on this interval, the integral is approximated by:\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(\\theta) d\\theta \\approx \\frac{1}{2\\pi} \\sum_{i=0}^{N-1} f(\\theta_i) \\Delta\\theta = \\frac{1}{2\\pi} \\sum_{i=0}^{N-1} f(\\theta_i) \\frac{2\\pi}{N} = \\frac{1}{N} \\sum_{i=0}^{N-1} f(\\theta_i)\n$$\nThis is equivalent to taking the arithmetic mean of the function evaluated on the grid points. The procedure is as follows:\n\n1.  **Define Constants and Grid**: All physical and numerical parameters ($a_0, m, \\phi, C_{\\mathrm{curv}}$, etc.) are defined. A uniform grid for $\\theta$ of size $N=4096$ is created.\n2.  **Implement Numerically Stable Functions**: The softplus function, $\\mathrm{sp}(x,\\delta) = \\delta \\ln(1 + e^{x/\\delta})$, and the logistic function, $\\sigma(z) = 1/(1+e^{-z})$, can suffer from floating-point overflow for large positive arguments or loss of precision for large negative arguments. They must be implemented using numerically stable reformulations. For softplus, the log-sum-exp identity, $\\ln(e^A+e^B) = \\max(A,B) + \\ln(1+e^{-|A-B|})$, is used. For the logistic function, for $z < 0$, the identity $\\sigma(z) = e^z / (1+e^z)$ is used to avoid computing $e^{-z}$ for large positive $-z$.\n3.  **Compute Adjoint Gradient, $g_{\\mathrm{adj}}$**: The analytic expression for the gradient integrand derived above is evaluated at each point $\\theta_i$ on the grid with $a=a_0$. The mean of these values yields the numerical approximation of $g_{\\mathrm{adj}}$.\n4.  **Compute Finite-Difference Gradient, $g_{\\mathrm{fd}}(h)$**: For each perturbation size $h$ in the test suite, the objective function $J$ is evaluated at $a_0+h$ and $a_0-h$ by numerically integrating its defining expression. The central finite-difference approximation is then computed as $g_{\\mathrm{fd}}(h) = \\frac{J(a_0+h)-J(a_0-h)}{2h}$.\n5.  **Compute Relative Error, $E(h)$**: For each $h$, the relative error between the finite-difference and adjoint gradients is calculated using the provided formula: $E(h) = \\frac{\\left|g_{\\mathrm{fd}}(h)-g_{\\mathrm{adj}}\\right|}{\\left|g_{\\mathrm{adj}}\\right|+\\varepsilon}$. The small parameter $\\varepsilon$ ensures stability if the gradient is close to zero.\n6.  **Output Results**: The computed relative errors for all test cases are collected and printed in the specified format.\n\nThis rigorous process validates the analytical derivation against a trusted numerical approximation, a standard and critical step in developing and verifying complex scientific simulation and optimization codes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error between central finite-difference and adjoint gradients\n    for a simplified stellarator turbulence proxy objective function.\n    \"\"\"\n\n    # 1. Define problem parameters and constants.\n    # Baseline amplitude\n    a0 = 5e-2\n    # Poloidal mode number\n    m = 3\n    # Phase\n    phi = np.pi / 7\n    # Curvature parameters\n    kappa0 = 3e-1\n    kappa1 = 2e-1\n    # Shear parameters\n    s0 = 5e-1\n    s1 = 2e-1\n    # Coefficients\n    C_curv = 8e-1\n    C_shear = 6e-1\n    C_stab = 2e-1\n    # Weight parameter\n    w2 = 1e-1\n    # Softplus smoothness\n    delta = 1e-3\n    # Stabilization for relative error\n    epsilon = 1e-12\n    # Numerical integration points\n    N_POINTS = 4096\n    \n    # Test suite for finite-difference perturbation amplitudes\n    test_cases_h = [1e-1, 1e-2, 5e-3, 1e-3, 1e-4, 1e-6]\n\n    # 2. Set up the numerical grid for integration.\n    theta_grid = np.linspace(0.0, 2.0 * np.pi, N_POINTS, endpoint=False)\n\n    # 3. Implement numerically stable helper functions.\n    def safe_softplus(x, d):\n        \"\"\"Numerically stable softplus function sp(x,d) = d*log(1+exp(x/d)).\"\"\"\n        # Uses the log-sum-exp trick for stability.\n        # log(1+exp(y)) = log(exp(0)+exp(y)) = max(0,y) + log(exp(-max(0,y)) + exp(y-max(0,y)))\n        y = x / d\n        max_y = np.maximum(0, y)\n        log_exp_sum = max_y + np.log(np.exp(-max_y) + np.exp(y - max_y))\n        return d * log_exp_sum\n\n    def safe_logistic(z):\n        \"\"\"Numerically stable logistic sigmoid function sigma(z) = 1/(1+exp(-z)).\"\"\"\n        result = np.zeros_like(z, dtype=float)\n        # For z >= 0, the standard formula is stable.\n        pos_mask = z >= 0\n        result[pos_mask] = 1.0 / (1.0 + np.exp(-z[pos_mask]))\n        # For z < 0, use sigma(z) = exp(z) / (1 + exp(z)) to avoid overflow in exp(-z).\n        neg_mask = z < 0\n        exp_z_neg = np.exp(z[neg_mask])\n        result[neg_mask] = exp_z_neg / (1.0 + exp_z_neg)\n        return result\n\n    # 4. Implement functions for the physical model.\n    def get_kappa_eff(theta_pts, a):\n        return kappa0 * np.cos(theta_pts) + a * kappa1 * np.cos(m * theta_pts + phi)\n\n    def get_s_hat(theta_pts, a):\n        return s0 + a * s1 * np.sin(m * theta_pts + phi)\n\n    def get_gamma_proxy(theta_pts, a):\n        return (C_curv * get_kappa_eff(theta_pts, a)\n                - C_shear * get_s_hat(theta_pts, a)\n                - C_stab)\n\n    def get_weight(theta_pts):\n        return 1.0 + w2 * np.cos(2.0 * theta_pts)\n\n    # 5. Implement functions for objective function and its gradient.\n    def calculate_J(a):\n        \"\"\"Computes the objective function J(a) via numerical quadrature.\"\"\"\n        gamma = get_gamma_proxy(theta_grid, a)\n        sp_gamma = safe_softplus(gamma, delta)\n        W = get_weight(theta_grid)\n        integrand = W * (sp_gamma**2)\n        # Integral approx: (1/2pi) * sum(f_i * dtheta) = mean(f)\n        return np.mean(integrand)\n\n    def calculate_dJ_da(a):\n        \"\"\"Computes the adjoint gradient dJ/da via numerical quadrature.\"\"\"\n        W = get_weight(theta_grid)\n        gamma = get_gamma_proxy(theta_grid, a)\n        sp_gamma = safe_softplus(gamma, delta)\n        sigma_gamma = safe_logistic(gamma / delta)\n        d_gamma_da = (C_curv * kappa1 * np.cos(m * theta_grid + phi)\n                      - C_shear * s1 * np.sin(m * theta_grid + phi))\n        integrand = W * 2.0 * sp_gamma * sigma_gamma * d_gamma_da\n        return np.mean(integrand)\n\n    # 6. Perform the main computation.\n    # Calculate the analytic (adjoint) gradient once at a = a0.\n    g_adj = calculate_dJ_da(a0)\n\n    results = []\n    for h in test_cases_h:\n        # Calculate the objective function at perturbed points.\n        J_plus_h = calculate_J(a0 + h)\n        J_minus_h = calculate_J(a0 - h)\n        \n        # Compute the central finite-difference gradient.\n        g_fd = (J_plus_h - J_minus_h) / (2.0 * h)\n        \n        # Compute the relative error.\n        relative_error = np.abs(g_fd - g_adj) / (np.abs(g_adj) + epsilon)\n        results.append(relative_error)\n\n    # 7. Print the final results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Stellarator design is a classic engineering balancing act. A configuration that perfectly confines a plasma might require impossibly complex magnetic coils to build. This final practice simulates this real-world challenge of multi-objective optimization. By evaluating a set of candidate designs against competing objectives for both physics performance ($J_{\\mathrm{turb}}$) and engineering feasibility ($J_{\\mathrm{coil}}$), you will learn to identify the \"best possible\" trade-offs—a set of non-dominated solutions known as the Pareto front .",
            "id": "4201430",
            "problem": "You are given a set of candidate stellarator magnetic equilibria described by dimensionless parameters. The goal is to compute two objective values for each candidate configuration that quantitatively reflect, respectively, a proxy for turbulent transport and a proxy for coil engineering complexity, and then construct the Pareto front for simultaneous minimization of these two objectives. The Pareto front should contain those configurations for which no other configuration achieves both a lower turbulence proxy and a lower coil complexity proxy, with at least one strict improvement. The final answer must be a single line of output containing a comma-separated list of the indices of Pareto-optimal configurations, enclosed in square brackets, in ascending order.\n\nStart from the following fundamental base appropriate to fusion plasma turbulence and coil complexity:\n\n- From gyrokinetic theory, the ion-temperature-gradient drive produces a linear instability characterized by a growth rate that scales with the ion diamagnetic frequency and a measure of unfavorable (bad) curvature. The effect of magnetic shear is stabilizing. Consistent with these properties, use a dimensionless linear growth-rate proxy defined as\n$$\\gamma_{\\mathrm{lin}} = C_{\\mathrm{gb}} \\left(\\frac{a}{L_T}\\right) f_{\\mathrm{curv}}(\\kappa_c,q),$$\nwhere $C_{\\mathrm{gb}}$ is a positive constant, $\\frac{a}{L_T}$ is the normalized temperature gradient, $\\kappa_c$ is a dimensionless bad-curvature amplitude, $q$ is the safety factor, and $f_{\\mathrm{curv}}$ is a dimensionless function that increases with $\\kappa_c$ and decreases with $q$. For this problem, take\n$$f_{\\mathrm{curv}}(\\kappa_c,q) = \\frac{\\kappa_c}{1+q^2}.$$\nDefine a dimensionless shear-stabilization proxy as\n$$\\gamma_{\\mathrm{shear}} = C_{\\mathrm{sh}} \\left| \\hat{s} \\right|,$$\nwhere $C_{\\mathrm{sh}}$ is a positive constant and $\\hat{s}$ is the local magnetic shear. The effective instability level proxy is then\n$$\\gamma_{\\mathrm{eff}} = \\max\\left(0,\\ \\gamma_{\\mathrm{lin}} - \\gamma_{\\mathrm{shear}}\\right).$$\nDefine the turbulence objective to be\n$$J_{\\mathrm{turb}} = \\gamma_{\\mathrm{eff}}.$$\n\n- For coil engineering complexity, use a proxy motivated by bending and twisting energy penalties and coil length. Let $c_{\\mathrm{amp}}$ be a dimensionless curvature amplitude, $t_{\\mathrm{amp}}$ be a dimensionless torsion amplitude, and $L_{\\mathrm{norm}}$ be a dimensionless normalized length. Define\n$$J_{\\mathrm{coil}} = \\alpha\\, c_{\\mathrm{amp}}^2 + \\beta\\, t_{\\mathrm{amp}}^2 + \\lambda\\, L_{\\mathrm{norm}},$$\nwhere $\\alpha$, $\\beta$, and $\\lambda$ are positive weights.\n\nGiven the following constants:\n- $C_{\\mathrm{gb}} = 0.35$,\n- $C_{\\mathrm{sh}} = 0.8$,\n- $\\alpha = 1.0$,\n- $\\beta = 0.6$,\n- $\\lambda = 0.2$,\n\nand the following list of $7$ candidate configurations, each specified by the tuple\n$$(\\kappa_c,\\ \\hat{s},\\ a/L_T,\\ q,\\ c_{\\mathrm{amp}},\\ t_{\\mathrm{amp}},\\ L_{\\mathrm{norm}}),$$\ncompute $J_{\\mathrm{turb}}$ and $J_{\\mathrm{coil}}$ for each, and then identify the indices of the configurations that lie on the Pareto front for the bi-objective minimization of $\\left(J_{\\mathrm{turb}}, J_{\\mathrm{coil}}\\right)$. Use zero-based indexing for configurations.\n\nThe candidate configurations are:\n- Index $0$: $(0.8,\\ 0.6,\\ 3.0,\\ 1.2,\\ 0.35,\\ 0.4,\\ 1.0)$.\n- Index $1$: $(1.4,\\ 0.2,\\ 4.0,\\ 1.0,\\ 0.8,\\ 0.9,\\ 1.4)$.\n- Index $2$: $(0.5,\\ 0.3,\\ 2.0,\\ 1.5,\\ 0.2,\\ 0.25,\\ 0.9)$.\n- Index $3$: $(1.0,\\ 0.4,\\ 3.5,\\ 1.3,\\ 0.5,\\ 0.45,\\ 1.1)$.\n- Index $4$: $(1.0,\\ 0.4,\\ 3.5,\\ 1.3,\\ 0.5,\\ 0.45,\\ 1.1)$.\n- Index $5$: $(0.9,\\ 0.1,\\ 1.8,\\ 0.9,\\ 0.15,\\ 0.15,\\ 0.7)$.\n- Index $6$: $(1.2,\\ 0.532,\\ 3.0,\\ 1.4,\\ 0.4,\\ 0.5,\\ 1.2)$.\n\nYour program must:\n- Compute $J_{\\mathrm{turb}}$ and $J_{\\mathrm{coil}}$ for each candidate using the formulas above.\n- Construct the Pareto front under the rule that configuration $i$ is dominated by configuration $j$ if and only if $J_{\\mathrm{turb}}(j) \\le J_{\\mathrm{turb}}(i)$ and $J_{\\mathrm{coil}}(j) \\le J_{\\mathrm{coil}}(i)$, with at least one of these two inequalities strict. Configurations that are not dominated by any other configuration are Pareto-optimal.\n- Produce a single line of output containing the sorted indices of the Pareto-optimal configurations as a comma-separated list enclosed in square brackets (for example, $[0,2,5]$). No other output is permitted.\n\nAll quantities in this problem are dimensionless, so no physical units are required. The test suite above covers a general case, a boundary case where $J_{\\mathrm{turb}}$ transitions to zero when $\\gamma_{\\mathrm{lin}} = \\gamma_{\\mathrm{shear}}$, and an edge case with duplicate configurations to test tie-handling in dominance.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in simplified, but physically motivated, models of plasma turbulence and magnet coil complexity relevant to stellarator optimization. The problem is mathematically well-posed, providing all necessary data, constants, and unambiguous definitions to compute a unique solution. The language is objective and the requirements are explicit. Therefore, a reasoned solution is provided below.\n\nThe core task is to perform a bi-objective optimization for a set of stellarator configurations. The two objectives to be minimized are a proxy for turbulent transport, $J_{\\mathrm{turb}}$, and a proxy for coil complexity, $J_{\\mathrm{coil}}$. The solution involves calculating these two objectives for each candidate configuration and then identifying the non-dominated set, known as the Pareto front.\n\nFirst, we define the objective functions based on the provided physical models and parameters. The constants are given as $C_{\\mathrm{gb}} = 0.35$, $C_{\\mathrm{sh}} = 0.8$, $\\alpha = 1.0$, $\\beta = 0.6$, and $\\lambda = 0.2$.\n\nThe turbulence objective, $J_{\\mathrm{turb}}$, is derived from a balance between the ion-temperature-gradient (ITG) instability drive and stabilization from magnetic shear. The linear growth rate proxy, $\\gamma_{\\mathrm{lin}}$, is given by:\n$$ \\gamma_{\\mathrm{lin}} = C_{\\mathrm{gb}} \\left(\\frac{a}{L_T}\\right) f_{\\mathrm{curv}}(\\kappa_c,q) $$\nwhere the curvature function is:\n$$ f_{\\mathrm{curv}}(\\kappa_c,q) = \\frac{\\kappa_c}{1+q^2} $$\nThe shear stabilization proxy, $\\gamma_{\\mathrm{shear}}$, is:\n$$ \\gamma_{\\mathrm{shear}} = C_{\\mathrm{sh}} \\left| \\hat{s} \\right| $$\nThe effective instability level, which serves as the turbulence objective, is the difference between these two, floored at zero:\n$$ J_{\\mathrm{turb}} = \\gamma_{\\mathrm{eff}} = \\max\\left(0,\\ \\gamma_{\\mathrm{lin}} - \\gamma_{\\mathrm{shear}}\\right) $$\n\nThe coil complexity objective, $J_{\\mathrm{coil}}$, is a weighted sum of proxies for coil bending energy, twisting energy, and length:\n$$ J_{\\mathrm{coil}} = \\alpha\\, c_{\\mathrm{amp}}^2 + \\beta\\, t_{\\mathrm{amp}}^2 + \\lambda\\, L_{\\mathrm{norm}} $$\n\nFor each of the $7$ candidate configurations, specified by the tuple $(\\kappa_c,\\ \\hat{s},\\ a/L_T,\\ q,\\ c_{\\mathrm{amp}},\\ t_{\\mathrm{amp}},\\ L_{\\mathrm{norm}})$, we compute the objective vector $(J_{\\mathrm{turb}}, J_{\\mathrm{coil}})$.\n\nConfiguration $0$: $(\\kappa_c, \\hat{s}, a/L_T, q, c_{\\mathrm{amp}}, t_{\\mathrm{amp}}, L_{\\mathrm{norm}}) = (0.8, 0.6, 3.0, 1.2, 0.35, 0.4, 1.0)$\n$f_{\\mathrm{curv}} = \\frac{0.8}{1+1.2^2} \\approx 0.3279$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.0 \\times 0.3279 \\approx 0.3443$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.6| = 0.48$.\n$J_{\\mathrm{turb}} = \\max(0, 0.3443 - 0.48) = 0$.\n$J_{\\mathrm{coil}} = 1.0(0.35^2) + 0.6(0.4^2) + 0.2(1.0) = 0.1225 + 0.096 + 0.2 = 0.4185$.\nObjective Vector: $(0.0, 0.4185)$.\n\nConfiguration $1$: $(1.4, 0.2, 4.0, 1.0, 0.8, 0.9, 1.4)$\n$f_{\\mathrm{curv}} = \\frac{1.4}{1+1.0^2} = 0.7$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 4.0 \\times 0.7 = 0.98$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.2| = 0.16$.\n$J_{\\mathrm{turb}} = \\max(0, 0.98 - 0.16) = 0.82$.\n$J_{\\mathrm{coil}} = 1.0(0.8^2) + 0.6(0.9^2) + 0.2(1.4) = 0.64 + 0.486 + 0.28 = 1.406$.\nObjective Vector: $(0.82, 1.406)$.\n\nConfiguration $2$: $(0.5, 0.3, 2.0, 1.5, 0.2, 0.25, 0.9)$\n$f_{\\mathrm{curv}} = \\frac{0.5}{1+1.5^2} \\approx 0.1538$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 2.0 \\times 0.1538 \\approx 0.1077$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.3| = 0.24$.\n$J_{\\mathrm{turb}} = \\max(0, 0.1077 - 0.24) = 0$.\n$J_{\\mathrm{coil}} = 1.0(0.2^2) + 0.6(0.25^2) + 0.2(0.9) = 0.04 + 0.0375 + 0.18 = 0.2575$.\nObjective Vector: $(0.0, 0.2575)$.\n\nConfiguration $3$: $(1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1)$\n$f_{\\mathrm{curv}} = \\frac{1.0}{1+1.3^2} \\approx 0.3717$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.5 \\times 0.3717 \\approx 0.4554$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.4| = 0.32$.\n$J_{\\mathrm{turb}} = \\max(0, 0.4554 - 0.32) \\approx 0.1354$.\n$J_{\\mathrm{coil}} = 1.0(0.5^2) + 0.6(0.45^2) + 0.2(1.1) = 0.25 + 0.1215 + 0.22 = 0.5915$.\nObjective Vector: $(\\approx 0.1354, 0.5915)$.\n\nConfiguration $4$: $(1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1)$\nThis is identical to configuration $3$.\nObjective Vector: $(\\approx 0.1354, 0.5915)$.\n\nConfiguration $5$: $(0.9, 0.1, 1.8, 0.9, 0.15, 0.15, 0.7)$\n$f_{\\mathrm{curv}} = \\frac{0.9}{1+0.9^2} \\approx 0.4972$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 1.8 \\times 0.4972 \\approx 0.3132$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.1| = 0.08$.\n$J_{\\mathrm{turb}} = \\max(0, 0.3132 - 0.08) \\approx 0.2332$.\n$J_{\\mathrm{coil}} = 1.0(0.15^2) + 0.6(0.15^2) + 0.2(0.7) = 0.0225 + 0.0135 + 0.14 = 0.176$.\nObjective Vector: $(\\approx 0.2332, 0.176)$.\n\nConfiguration $6$: $(1.2, 0.532, 3.0, 1.4, 0.4, 0.5, 1.2)$\n$f_{\\mathrm{curv}} = \\frac{1.2}{1+1.4^2} \\approx 0.4054$. $\\gamma_{\\mathrm{lin}} = 0.35 \\times 3.0 \\times 0.4054 \\approx 0.42567$. $\\gamma_{\\mathrm{shear}} = 0.8 \\times |0.532| = 0.4256$.\n$J_{\\mathrm{turb}} = \\max(0, 0.42567 - 0.4256) \\approx 0.0000757$.\n$J_{\\mathrm{coil}} = 1.0(0.4^2) + 0.6(0.5^2) + 0.2(1.2) = 0.16 + 0.15 + 0.24 = 0.55$.\nObjective Vector: $(\\approx 0.0000757, 0.55)$.\n\nThe calculated objective vectors $(J_{\\mathrm{turb}}, J_{\\mathrm{coil}})$ are:\n- Index $0$: $(0.0, 0.4185)$\n- Index $1$: $(0.82, 1.406)$\n- Index $2$: $(0.0, 0.2575)$\n- Index $3$: $(\\approx 0.1354, 0.5915)$\n- Index $4$: $(\\approx 0.1354, 0.5915)$\n- Index $5$: $(\\approx 0.2332, 0.176)$\n- Index $6$: $(\\approx 0.0000757, 0.55)$\n\nNext, we identify the Pareto front. A configuration $i$ is dominated by configuration $j$ if $J_{\\mathrm{turb}}(j) \\le J_{\\mathrm{turb}}(i)$ and $J_{\\mathrm{coil}}(j) \\le J_{\\mathrm{coil}}(i)$, with at least one inequality being strict. Configurations not dominated by any other configuration form the Pareto front.\n\n- Configuration $1$ ($ (0.82, 1.406) $) is dominated by all other configurations as they all have smaller values for both objectives.\n- Configuration $0$ ($ (0.0, 0.4185) $) is dominated by configuration $2$ ($ (0.0, 0.2575) $) because $J_{\\mathrm{turb}}(2) = J_{\\mathrm{turb}}(0)$ and $J_{\\mathrm{coil}}(2) < J_{\\mathrm{coil}}(0)$.\n- Configurations $3$ and $4$ ($ (\\approx 0.1354, 0.5915) $) are dominated by configuration $6$ ($ (\\approx 0.0000757, 0.55) $) because $J_{\\mathrm{turb}}(6) < J_{\\mathrm{turb}}(3,4)$ and $J_{\\mathrm{coil}}(6) < J_{\\mathrm{coil}}(3,4)$. Note that identical configurations do not dominate each other as a strict inequality is required.\n\nThe remaining configurations are $2$, $5$, and $6$. We check them for mutual dominance:\n- Compare $2$ ($ (0.0, 0.2575) $) and $5$ ($ (\\approx 0.2332, 0.176) $): Configuration $2$ has a lower $J_{\\mathrm{turb}}$, but configuration $5$ has a lower $J_{\\mathrm{coil}}$. Neither dominates the other.\n- Compare $2$ ($ (0.0, 0.2575) $) and $6$ ($ (\\approx 0.0000757, 0.55) $): Configuration $2$ has a lower $J_{\\mathrm{turb}}$, but a higher $J_{\\mathrm{coil}}$. Neither dominates the other.\n- Compare $5$ ($ (\\approx 0.2332, 0.176) $) and $6$ ($ (\\approx 0.0000757, 0.55) $): Configuration $6$ has a lower $J_{\\mathrm{turb}}$, but configuration $5$ has a lower $J_{\\mathrm{coil}}$. Neither dominates the other.\n\nThus, configurations with indices $2$, $5$, and $6$ are not dominated by any other configuration. They constitute the Pareto front. The indices, sorted in ascending order, are $2, 5, 6$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes J_turb and J_coil for each candidate configuration, then identifies \n    and returns the indices of the Pareto-optimal configurations.\n    \"\"\"\n    \n    # Define the constants from the problem statement.\n    C_gb = 0.35\n    C_sh = 0.8\n    alpha = 1.0\n    beta = 0.6\n    lambda_ = 0.2\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (kappa_c, s_hat, a_over_LT, q, c_amp, t_amp, L_norm)\n    test_cases = [\n        (0.8, 0.6, 3.0, 1.2, 0.35, 0.4, 1.0),\n        (1.4, 0.2, 4.0, 1.0, 0.8, 0.9, 1.4),\n        (0.5, 0.3, 2.0, 1.5, 0.2, 0.25, 0.9),\n        (1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1),\n        (1.0, 0.4, 3.5, 1.3, 0.5, 0.45, 1.1),\n        (0.9, 0.1, 1.8, 0.9, 0.15, 0.15, 0.7),\n        (1.2, 0.532, 3.0, 1.4, 0.4, 0.5, 1.2),\n    ]\n\n    def calculate_objectives(config):\n        \"\"\"\n        Calculates J_turb and J_coil for a single configuration.\n        \"\"\"\n        kappa_c, s_hat, a_over_LT, q, c_amp, t_amp, L_norm = config\n        \n        # Calculate J_turb\n        f_curv = kappa_c / (1.0 + q**2)\n        gamma_lin = C_gb * a_over_LT * f_curv\n        gamma_shear = C_sh * abs(s_hat)\n        j_turb = max(0.0, gamma_lin - gamma_shear)\n        \n        # Calculate J_coil\n        j_coil = alpha * c_amp**2 + beta * t_amp**2 + lambda_ * L_norm\n        \n        return j_turb, j_coil\n\n    n_configs = len(test_cases)\n    objectives = [calculate_objectives(case) for case in test_cases]\n    \n    pareto_indices = []\n    for i in range(n_configs):\n        is_dominated = False\n        for j in range(n_configs):\n            if i == j:\n                continue\n            \n            i_turb, i_coil = objectives[i]\n            j_turb, j_coil = objectives[j]\n            \n            # Check if configuration j dominates configuration i\n            # This requires j to be better or equal on all objectives...\n            if j_turb = i_turb and j_coil = i_coil:\n                # ...and strictly better on at least one objective.\n                if j_turb  i_turb or j_coil  i_coil:\n                    is_dominated = True\n                    break # Found a dominator, no need to check further for i\n        \n        if not is_dominated:\n            pareto_indices.append(i)\n            \n    pareto_indices.sort()\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, pareto_indices))}]\")\n\nsolve()\n```"
        }
    ]
}