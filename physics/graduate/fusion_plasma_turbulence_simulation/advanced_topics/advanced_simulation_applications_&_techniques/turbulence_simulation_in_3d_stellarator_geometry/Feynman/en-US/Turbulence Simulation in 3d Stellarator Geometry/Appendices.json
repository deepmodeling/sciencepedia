{
    "hands_on_practices": [
        {
            "introduction": "In the intricate three-dimensional landscape of a stellarator, analyzing physical quantities requires moving beyond simple spatial averages. This exercise introduces the fundamental concept of the flux-surface average, a procedure weighted by the Jacobian of the magnetic coordinate system, which encodes the complex shaping of the magnetic surfaces. By working through this problem , you will see firsthand how non-axisymmetric geometric features can selectively couple to specific spatial harmonics of a turbulent fluctuation, directly contributing to its mean value—a key mechanism distinguishing stellarator transport from that in axisymmetric tokamaks.",
            "id": "4208541",
            "problem": "In three-dimensional (3D) stellarator geometry, flux-surface averages in Boozer coordinates $(\\psi,\\theta,\\zeta)$ are defined by weighting with the surface Jacobian $J(\\theta,\\zeta) \\equiv \\left[\\nabla \\psi \\cdot (\\nabla \\theta \\times \\nabla \\zeta)\\right]^{-1}$. Consider a simplified, yet physically consistent model of a nonaxisymmetric stellarator surface with a single dominant helical harmonic in the Jacobian,\n$$\nJ(\\theta,\\zeta) = J_0 \\left[1 + \\alpha \\cos\\!\\big(p\\,\\theta - q\\,\\zeta\\big)\\right],\n$$\nwhere $J_0 > 0$ is a constant, $0 < \\alpha < 1$ is a small nonaxisymmetric modulation amplitude (ensuring $J(\\theta,\\zeta) > 0$), and $p,q \\in \\mathbb{Z}^{+}$ encode the field periodicity. Let the scalar field representing a turbulence quantity on the surface be\n$$\nf(\\theta,\\zeta) = f_0 + f_c \\cos\\!\\big(p\\,\\theta - q\\,\\zeta\\big) + f_s \\sin\\!\\big(p\\,\\theta - q\\,\\zeta\\big) + g \\cos\\!\\big(2p\\,\\theta - 2q\\,\\zeta\\big),\n$$\nwith $f_0, f_c, f_s, g$ constants. The flux-surface average is defined by the core geometrical relation\n$$\n\\langle f \\rangle \\equiv \\frac{\\displaystyle \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} f(\\theta,\\zeta)\\, J(\\theta,\\zeta)\\, d\\theta\\, d\\zeta}{\\displaystyle \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} J(\\theta,\\zeta)\\, d\\theta\\, d\\zeta}.\n$$\nAssume periodicity over $\\theta \\in [0,2\\pi]$ and $\\zeta \\in [0,2\\pi]$ and that $p$ and $q$ are nonzero integers so that harmonics are orthogonal on the torus.\n\nCompute the exact closed-form expression for $\\langle f \\rangle$ in terms of $f_0$, $f_c$, $f_s$, $g$, and $\\alpha$ using the above definitions. Then, explain from first principles how nonaxisymmetry (i.e., $\\alpha \\neq 0$) affects the weighting by $J(\\theta,\\zeta)$ and which harmonics of $f$ are retained in $\\langle f \\rangle$ due to this weighting. Your final answer must be a single closed-form analytic expression. No units are required for the final expression.",
            "solution": "The problem asks for the computation of the flux-surface average $\\langle f \\rangle$ of a scalar field $f(\\theta,\\zeta)$ on a nonaxisymmetric stellarator surface.\n\n### Step 1: Problem Validation\n\nFirst, I will validate the provided problem statement.\n\n**Givens:**\n- Boozer coordinates $(\\psi,\\theta,\\zeta)$.\n- Jacobian: $J(\\theta,\\zeta) = J_0 \\left[1 + \\alpha \\cos\\!\\big(p\\,\\theta - q\\,\\zeta\\big)\\right]$, with $J_0 > 0$, $0 < \\alpha < 1$, and $p,q \\in \\mathbb{Z}^{+}$.\n- Scalar field: $f(\\theta,\\zeta) = f_0 + f_c \\cos\\!\\big(p\\,\\theta - q\\,\\zeta\\big) + f_s \\sin\\!\\big(p\\,\\theta - q\\,\\zeta\\big) + g \\cos\\!\\big(2p\\,\\theta - 2q\\,\\zeta\\big)$, with $f_0, f_c, f_s, g$ as constants.\n- Definition of flux-surface average:\n$$\n\\langle f \\rangle \\equiv \\frac{\\displaystyle \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} f(\\theta,\\zeta)\\, J(\\theta,\\zeta)\\, d\\theta\\, d\\zeta}{\\displaystyle \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} J(\\theta,\\zeta)\\, d\\theta\\, d\\zeta}.\n$$\n- Integration domain: $\\theta \\in [0,2\\pi]$ and $\\zeta \\in [0,2\\pi]$.\n- Periodicity assumption: $p$ and $q$ are nonzero integers, ensuring orthogonality of harmonics.\n\n**Validation against Criteria:**\n1.  **Scientifically Grounded:** The problem is based on standard concepts in fusion plasma physics, specifically stellarator magnetohydrodynamic (MHD) equilibrium theory. Boozer coordinates, the Jacobian, and the flux-surface average are fundamental tools. The model for the Jacobian and the scalar field are simplified but physically consistent representations of nonaxisymmetric geometry and turbulent fluctuations. The problem is scientifically sound.\n2.  **Well-Posed:** The problem provides all necessary functions and definitions to perform the calculation. The integrals are well-defined, and the parameters have clear constraints ($p, q \\in \\mathbb{Z}^{+}$) that prevent singularities or undefined results. A unique, stable, and meaningful solution exists.\n3.  **Objective:** The language is precise, mathematical, and free of any subjective or ambiguous terms.\n4.  **No other flaws detected:** The problem is not incomplete, contradictory, unrealistic, ill-posed, trivial, or unverifiable. It is a direct and standard calculation within its scientific domain.\n\n**Verdict:** The problem is valid.\n\n### Step 2: Solution\n\nI will now proceed with computing the flux-surface average $\\langle f \\rangle$. The calculation involves evaluating the integrals in the numerator and the denominator separately. A key mathematical property to be used is the orthogonality of trigonometric functions over the domain $[0, 2\\pi] \\times [0, 2\\pi]$. For any integers $m, n, m', n'$ where $(m, n) \\neq (0,0)$:\n$$\n\\int_0^{2\\pi}\\!\\!\\int_0^{2\\pi} \\cos(m\\theta - n\\zeta) d\\theta d\\zeta = 0\n$$\n$$\n\\int_0^{2\\pi}\\!\\!\\int_0^{2\\pi} \\sin(m\\theta - n\\zeta) d\\theta d\\zeta = 0\n$$\nAnd for $(m,n) \\neq (m',n')$:\n$$\n\\int_0^{2\\pi}\\!\\!\\int_0^{2\\pi} \\cos(m\\theta - n\\zeta)\\cos(m'\\theta-n'\\zeta) d\\theta d\\zeta = 0\n$$\n\n**Denominator Calculation:**\nThe denominator is the integral of the Jacobian over the surface.\n$$\n\\text{Denominator} = \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} J(\\theta,\\zeta)\\, d\\theta\\, d\\zeta = \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} J_0 \\left[1 + \\alpha \\cos\\!\\big(p\\,\\theta - q\\,\\zeta\\big)\\right] d\\theta\\, d\\zeta\n$$\nWe can split the integral:\n$$\n\\text{Denominator} = J_0 \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} 1 \\, d\\theta\\, d\\zeta + J_0 \\alpha \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} \\cos(p\\,\\theta - q\\,\\zeta)\\, d\\theta\\, d\\zeta\n$$\nThe first term evaluates to $J_0 (2\\pi)(2\\pi) = 4\\pi^2 J_0$. The second term is an integral of a cosine over its period. Since $p, q \\in \\mathbb{Z}^{+}$ are nonzero integers, the integral is zero due to orthogonality.\n$$\n\\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} \\cos(p\\,\\theta - q\\,\\zeta)\\, d\\theta\\, d\\zeta = \\int_0^{2\\pi} \\left[ \\frac{\\sin(p\\theta - q\\zeta)}{p} \\right]_0^{2\\pi} d\\zeta = \\int_0^{2\\pi} 0 \\, d\\zeta = 0\n$$\nThus, the denominator is:\n$$\n\\text{Denominator} = 4\\pi^2 J_0\n$$\n\n**Numerator Calculation:**\nThe numerator is the integral of the product $f(\\theta,\\zeta)J(\\theta,\\zeta)$.\n$$\n\\text{Numerator} = \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} f(\\theta,\\zeta)\\, J(\\theta,\\zeta)\\, d\\theta\\, d\\zeta\n$$\nLet's write the product. Let $u = p\\,\\theta - q\\,\\zeta$ for shorthand.\n$$\nf J = J_0 \\left[1 + \\alpha \\cos(u)\\right] \\left[f_0 + f_c \\cos(u) + f_s \\sin(u) + g \\cos(2u)\\right]\n$$\nExpanding the product:\n$$\n\\frac{f J}{J_0} = f_0 + f_c \\cos(u) + f_s \\sin(u) + g \\cos(2u) + \\alpha f_0 \\cos(u) + \\alpha f_c \\cos^2(u) + \\alpha f_s \\sin(u)\\cos(u) + \\alpha g \\cos(u)\\cos(2u)\n$$\nWe must integrate each term over $\\theta \\in [0, 2\\pi]$ and $\\zeta \\in [0, 2\\pi]$. Most terms will integrate to zero due to orthogonality. The only terms that can yield a non-zero result are constants or terms that contain a constant component after trigonometric simplification.\n\\begin{enumerate}\n    \\item $\\int\\int f_0 d\\theta d\\zeta = f_0 (4\\pi^2)$.\n    \\item $\\int\\int f_c \\cos(u) d\\theta d\\zeta = 0$.\n    \\item $\\int\\int f_s \\sin(u) d\\theta d\\zeta = 0$.\n    \\item $\\int\\int g \\cos(2u) d\\theta d\\zeta = 0$.\n    \\item $\\int\\int \\alpha f_0 \\cos(u) d\\theta d\\zeta = 0$.\n    \\item $\\int\\int \\alpha f_c \\cos^2(u) d\\theta d\\zeta$: We use the identity $\\cos^2(u) = \\frac{1}{2}(1 + \\cos(2u))$.\n    $$\n    \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} \\alpha f_c \\left(\\frac{1}{2} + \\frac{1}{2}\\cos(2u)\\right) d\\theta d\\zeta = \\alpha f_c \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} \\frac{1}{2} d\\theta d\\zeta + \\frac{\\alpha f_c}{2} \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} \\cos(2u) d\\theta d\\zeta\n    $$\n    The second integral is zero. The first gives $\\frac{1}{2}\\alpha f_c (4\\pi^2) = 2\\pi^2 \\alpha f_c$.\n    \\item $\\int\\int \\alpha f_s \\sin(u)\\cos(u) d\\theta d\\zeta$: We use $\\sin(u)\\cos(u) = \\frac{1}{2}\\sin(2u)$. The integral $\\int\\int \\frac{1}{2}\\alpha f_s \\sin(2u) d\\theta d\\zeta = 0$.\n    \\item $\\int\\int \\alpha g \\cos(u)\\cos(2u) d\\theta d\\zeta$: We use $\\cos(u)\\cos(2u) = \\frac{1}{2}(\\cos(u) + \\cos(3u))$. Both terms integrate to zero.\n\\end{enumerate}\nSumming the non-zero contributions to the numerator integral:\n$$\n\\text{Numerator} = J_0 \\left[ 4\\pi^2 f_0 + 2\\pi^2 \\alpha f_c \\right] = 4\\pi^2 J_0 \\left( f_0 + \\frac{\\alpha f_c}{2} \\right)\n$$\n\n**Final Result for $\\langle f \\rangle$**\nNow we compute the ratio of the numerator to the denominator:\n$$\n\\langle f \\rangle = \\frac{4\\pi^2 J_0 \\left( f_0 + \\frac{\\alpha f_c}{2} \\right)}{4\\pi^2 J_0} = f_0 + \\frac{\\alpha f_c}{2}\n$$\n\n### Step 3: Explanation of Nonaxisymmetry Effects\n\nThe problem also asks for an explanation of how nonaxisymmetry affects the weighting and which harmonics are retained.\n\nFrom first principles, the flux-surface average $\\langle f \\rangle$ is a weighted average of the function $f$ over the surface, with the Jacobian $J$ acting as the weighting function.\n\nIn the limit of axisymmetry, which corresponds to setting the nonaxisymmetric modulation amplitude $\\alpha=0$, the Jacobian becomes a constant, $J(\\theta,\\zeta) = J_0$. The average simplifies to:\n$$\n\\langle f \\rangle_{\\alpha=0} = \\frac{\\displaystyle \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} f(\\theta,\\zeta)\\, J_0\\, d\\theta\\, d\\zeta}{\\displaystyle \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} J_0\\, d\\theta\\, d\\zeta} = \\frac{1}{4\\pi^2} \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{2\\pi} f(\\theta,\\zeta)\\, d\\theta\\, d\\zeta\n$$\nThis is the simple, unweighted average of $f$ over the toroidal angles. Due to the orthogonality of trigonometric functions, all oscillatory components of $f$ (the terms with $f_c$, $f_s$, and $g$) integrate to zero. Only the constant (or mean) component $f_0$ survives:\n$$\n\\langle f \\rangle_{\\alpha=0} = \\frac{1}{4\\pi^2} \\left[ 4\\pi^2 f_0 + 0 + 0 + 0 \\right] = f_0.\n$$\n\nWhen nonaxisymmetry is present ($\\alpha \\neq 0$), the Jacobian $J(\\theta,\\zeta) = J_0 [1 + \\alpha \\cos(p\\theta - q\\zeta)]$ is no longer uniform. It has a spatial variation that is proportional to $\\cos(p\\theta - q\\zeta)$. This spatially dependent weighting changes the outcome of the averaging process.\n\nThe average now involves the integral of the product $f \\cdot J$. The value of this integral is determined by the \"resonant beating\" between the Fourier harmonics of $f$ and the harmonics of $J$. A non-zero contribution to the average arises only from products of harmonics that create a constant (zero-wavenumber) component.\nThe harmonics of $J$ are a constant ($1$) and a cosine mode $\\cos(p\\theta - q\\zeta)$.\nThe harmonics of $f$ are a constant ($f_0$), a cosine mode $\\cos(p\\theta - q\\zeta)$, a sine mode $\\sin(p\\theta - q\\zeta)$, and a higher-order cosine mode $\\cos(2p\\theta - 2q\\zeta)$.\n\nThe only interactions that produce a non-zero average are:\n1.  The product of the constant part of $f$ ($f_0$) and the constant part of $J$ ($J_0$), giving the $f_0$ term in the final answer.\n2.  The product of the harmonic in $f$ that has the same spatial dependence as the harmonic in $J$. Here, this is the term $f_c \\cos(p\\theta - q\\zeta)$ from $f$ and the term $\\alpha \\cos(p\\theta - q\\zeta)$ from $J$. Their product is $\\alpha f_c \\cos^2(p\\theta - q\\zeta)$. Using the identity $\\cos^2(x) = \\frac{1}{2}(1 + \\cos(2x))$, this product contains a constant component $\\frac{1}{2}\\alpha f_c$. This constant component survives the integration and contributes the term $\\frac{\\alpha f_c}{2}$ to the final average.\n\nThe other harmonics of $f$ are orthogonal to the harmonic variation in $J$.\n- The sine term $f_s \\sin(p\\theta - q\\zeta)$ results in a product $\\alpha f_s \\sin(p\\theta - q\\zeta)\\cos(p\\theta - q\\zeta) \\propto \\sin(2p\\theta - 2q\\zeta)$, which averages to zero.\n- The higher harmonic $g \\cos(2p\\theta - 2q\\zeta)$ results in a product $\\alpha g \\cos(p\\theta - q\\zeta)\\cos(2p\\theta - 2q\\zeta) \\propto \\cos(p\\theta - q\\zeta) + \\cos(3p\\theta - 3q\\zeta)$, which also averages to zero.\n\nIn essence, the nonaxisymmetry of the geometry, encoded in the Jacobian $J$, acts as a selective filter. It allows a specific harmonic of the scalar field $f$—the one whose spatial structure resonates with the geometry's dominant nonaxisymmetric harmonic—to contribute to its own flux-surface average. Harmonics of $f$ that are orthogonal to the geometric variations are averaged away, just as in the axisymmetric case. This mechanism is a fundamental consequence of describing physics in a complex, non-symmetric coordinate system.",
            "answer": "$$\n\\boxed{f_0 + \\frac{\\alpha f_c}{2}}\n$$"
        },
        {
            "introduction": "With the geometric framework established, the next critical step in turbulence simulation is to accurately solve the governing physical equations. This practice  guides you through the process of discretizing a representative one-dimensional model for instabilities along a magnetic field line, a common task in advanced simulation codes. You will implement a finite-volume scheme to transform the differential equation into a matrix eigenvalue problem, allowing you to compute instability growth rates and mode structures. This hands-on exercise emphasizes the essential scientific computing skill of performing a convergence study, which is necessary to ensure your numerical solution is a reliable representation of the physics, particularly when sharp geometric features demand high resolution.",
            "id": "4208543",
            "problem": "Consider a simplified one-dimensional field-line model for linear electrostatic turbulence in three-dimensional stellarator geometry. The parallel coordinate is denoted by $z$, defined on a periodic domain $z \\in [-\\pi,\\pi)$ with radians as the angle unit. The magnetic field strength along a chosen field line is $B(z)$, which may exhibit multiple trapping wells and sharp features. Starting from the drift-kinetic description, the parallel mirror force $- \\mu \\nabla_{\\parallel} B$ and parallel streaming $\\mathrm{d}v_{\\parallel}/\\mathrm{d}t$ lead, under a fluid closure and linearization, to an effective self-adjoint ballooning-type equation for the electrostatic potential eigenfunction $ \\phi(z) $ of the form\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d} z} \\left( A(z) \\frac{\\mathrm{d}\\phi}{\\mathrm{d} z} \\right) + Q(z)\\,\\phi(z) \\;=\\; \\lambda\\,\\phi(z),\n$$\nwhere $A(z)$ represents a geometry-induced parallel stiffness and $Q(z)$ captures curvature and trapping-drive effects. The quantity $\\lambda$ is an eigenvalue that parametrizes the balance between stabilizing parallel dynamics and destabilizing curvature/trapping drive. In this model we consider the following choices motivated by standard ballooning representations in Boozer-like coordinates:\n- $A(z) = 1/B(z)$,\n- $Q(z) = - C \\,\\frac{B_{\\max} - B(z)}{B_0}$,\nwhere $B_{\\max} = \\max_{z} B(z)$ and $B_0$ is a reference magnetic field strength, taken as a constant $B_0 = 1$ in normalized units. A negative $Q(z)$ in regions where $B(z)$ has trapping wells produces a destabilizing contribution. The corresponding linear growth rate $\\gamma$ is defined from the most unstable eigenvalue $\\lambda_{\\min}$ (the smallest eigenvalue of the self-adjoint operator) by\n$$\n\\gamma \\;=\\; \\sqrt{\\max\\{-\\lambda_{\\min},\\,0\\}},\n$$\nin dimensionless normalized units.\n\nYour task is to implement a convergence study in the parallel coordinate $z$ by increasing the resolution $N$ used to discretize the periodic domain and to quantify how resolving trapping wells and sharp features in $B(z)$ affects the linear growth rates $\\gamma$ and the mode structure $\\phi(z)$. Use a conservative finite-volume-like discretization of the operator $\\frac{\\mathrm{d}}{\\mathrm{d} z} \\left( A(z) \\frac{\\mathrm{d}\\phi}{\\mathrm{d} z} \\right)$ with periodic boundary conditions:\n- Let the grid be uniform with $N$ points, spacing $\\Delta z = 2\\pi/N$, and nodes $z_j = -\\pi + j\\,\\Delta z$ for $j=0,\\dots,N-1$.\n- Define $A_{j+\\frac{1}{2}} = \\frac{1}{2}\\left(A_j + A_{j+1}\\right)$ with periodic wrap, and discretize\n$$\n\\left[\\frac{\\mathrm{d}}{\\mathrm{d} z} \\left( A(z) \\frac{\\mathrm{d}\\phi}{\\mathrm{d} z} \\right)\\right]_j \\;\\approx\\; \\frac{1}{\\Delta z} \\left( \\frac{A_{j+\\frac{1}{2}}\\,(\\phi_{j+1}-\\phi_j)}{\\Delta z} - \\frac{A_{j-\\frac{1}{2}}\\,(\\phi_j-\\phi_{j-1})}{\\Delta z} \\right),\n$$\nso that the discrete operator is symmetric when assembled into a matrix with periodic boundary conditions, and add the pointwise $Q_j\\,\\phi_j$ contribution.\n- Solve the discrete eigenvalue problem to obtain $\\lambda_{\\min}$ and its normalized eigenvector $\\phi(z)$ under the inner product corresponding to the $L^2$ norm with weight $\\Delta z$.\n\nPerform the study for the following three magnetic field profiles $B(z)$, each designed to test different resolution requirements:\n1. Smooth single-well case (happy path):\n   - $B(z) = B_0\\,\\left(1 + \\epsilon \\cos z\\right)$ with $B_0 = 1$, $\\epsilon = 0.30$.\n2. Multi-well case with moderate sharpness:\n   - $B(z) = B_0\\,\\left(1 + \\epsilon \\cos z + \\epsilon_2 \\cos(3 z)\\right)$ with $B_0 = 1$, $\\epsilon = 0.30$, $\\epsilon_2 = 0.15$.\n3. High-harmonic sharp-feature case (edge case):\n   - $B(z) = B_0\\,\\left(1 + \\epsilon \\cos(10 z)\\right)$ with $B_0 = 1$, $\\epsilon = 0.20$.\n\nUse a fixed drive parameter $C = 1.0$ in all cases. For each case, compute the most unstable growth rate $\\gamma$ and the corresponding normalized eigenfunction $\\phi(z)$ at three resolutions $N \\in \\{64, 128, 256\\}$. To quantify convergence of the mode structure, compare the eigenfunctions at $N=128$ and $N=256$ by downsampling the higher-resolution eigenfunction onto the $N=128$ grid (which aligns exactly because $256$ is an integer multiple of $128$), aligning the sign by maximizing correlation, and computing the $L^2$ difference\n$$\n\\Delta_{\\phi} \\;=\\; \\left\\| \\phi^{(128)} - \\phi^{(256 \\to 128)} \\right\\|_2,\n$$\nwhere both $\\phi^{(128)}$ and the downsampled $\\phi^{(256 \\to 128)}$ are normalized to unit $L^2$ norm under the discrete inner product with weight $\\Delta z$.\n\nYour program should output, for each magnetic field case, two floating-point numbers:\n- The converged growth rate at the highest resolution, $\\gamma$ at $N=256$ (dimensionless).\n- The mode-structure difference $\\Delta_{\\phi}$ between $N=128$ and $N=256$ (dimensionless).\n\nAggregate the results for all three cases into a single line of output containing a comma-separated list enclosed in square brackets, ordered as $\n[\\gamma_1, \\Delta_{\\phi,1}, \\gamma_2, \\Delta_{\\phi,2}, \\gamma_3, \\Delta_{\\phi,3}]\n$, where the subscript indicates the case number. The final output must be a single line in exactly this format.\n\nTest Suite:\n- Case 1: $B(z) = 1 + 0.30 \\cos z$, $C=1.0$, $N=64,128,256$.\n- Case 2: $B(z) = 1 + 0.30 \\cos z + 0.15 \\cos(3 z)$, $C=1.0$, $N=64,128,256$.\n- Case 3: $B(z) = 1 + 0.20 \\cos(10 z)$, $C=1.0$, $N=64,128,256$.\n\nAll quantities are to be treated as dimensionless in normalized units. Angles are in radians. The final outputs are floats. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order specified above.",
            "solution": "The problem requires the numerical investigation of a one-dimensional, self-adjoint, second-order ordinary differential equation that models electrostatic turbulence in a stellarator geometry. The equation is of the Sturm-Liouville type:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d} z} \\left( A(z) \\frac{\\mathrm{d}\\phi}{\\mathrm{d} z} \\right) + Q(z)\\,\\phi(z) = \\lambda\\,\\phi(z)\n$$\ndefined on a periodic domain $z \\in [-\\pi, \\pi)$. The eigenfunction $\\phi(z)$ represents the electrostatic potential, and the eigenvalue $\\lambda$ is related to the stability of the system. The goal is to find the minimum eigenvalue $\\lambda_{\\min}$ and use it to compute the linear growth rate $\\gamma = \\sqrt{\\max\\{-\\lambda_{\\min}, 0\\}}$. This analysis is performed for different magnetic field profiles $B(z)$ and numerical resolutions $N$.\n\nThe first step is to discretize the differential operator on a uniform grid. Let the domain $[-\\pi, \\pi)$ be divided into $N$ intervals of length $\\Delta z = 2\\pi/N$. The grid points are $z_j = -\\pi + j\\Delta z$ for $j=0, \\dots, N-1$. The eigenfunction $\\phi(z)$ is represented by a vector of its values at these grid points, $\\vec{\\phi} = (\\phi_0, \\phi_1, \\dots, \\phi_{N-1})^T$.\n\nWe employ a conservative finite-volume discretization as specified. The second-order derivative term at grid point $z_j$ is approximated by considering fluxes at the mid-points $z_{j \\pm 1/2}$:\n$$\n\\left[\\frac{\\mathrm{d}}{\\mathrm{d} z} \\left( A(z) \\frac{\\mathrm{d}\\phi}{\\mathrm{d} z} \\right)\\right]_j \\approx \\frac{1}{\\Delta z} \\left( F_{j+1/2} - F_{j-1/2} \\right)\n$$\nwhere the flux $F_{j+1/2}$ is given by\n$$\nF_{j+1/2} = A(z_{j+1/2}) \\frac{\\phi_{j+1} - \\phi_j}{\\Delta z}\n$$\nThe coefficient $A(z)$ at the mid-point $z_{j+1/2}$ is approximated by the arithmetic mean of its values at the neighboring grid points: $A_{j+1/2} = \\frac{1}{2}(A_j + A_{j+1})$. This leads to the discrete form of the operator:\n$$\n\\frac{1}{\\Delta z^2} \\left( A_{j+1/2}(\\phi_{j+1} - \\phi_j) - A_{j-1/2}(\\phi_j - \\phi_{j-1}) \\right) + Q_j\\phi_j = \\lambda\\phi_j\n$$\nThis system of $N$ linear equations can be written as a matrix eigenvalue problem, $M\\vec{\\phi} = \\lambda\\vec{\\phi}$. The matrix $M$ is an $N \\times N$ matrix. By rearranging the terms, we can identify the entries of $M$. For the $j$-th row, we have:\n$$\n\\frac{A_{j-1/2}}{\\Delta z^2}\\phi_{j-1} - \\frac{A_{j+1/2} + A_{j-1/2}}{\\Delta z^2}\\phi_j + \\frac{A_{j+1/2}}{\\Delta z^2}\\phi_{j+1} + Q_j\\phi_j = \\lambda\\phi_j\n$$\nThis defines the matrix $M$ as a tridiagonal matrix with additional corner elements to enforce periodic boundary conditions ($\\phi_{-1} = \\phi_{N-1}$ and $\\phi_N = \\phi_0$). The matrix elements are:\n- Diagonal elements: $M_{j,j} = -\\frac{1}{\\Delta z^2} \\left(A_{j+1/2} + A_{j-1/2}\\right) + Q_j$\n- Off-diagonal elements: $M_{j,j+1} = \\frac{1}{\\Delta z^2} A_{j+1/2}$ and $M_{j,j-1} = \\frac{1}{\\Delta z^2} A_{j-1/2}$.\nThe indices are taken modulo $N$. Since $A_{j,j+1} = M_{j,j+1}$ and $M_{j+1,j} = \\frac{1}{\\Delta z^2} A_{j+1-1/2} = \\frac{1}{\\Delta z^2} A_{j+1/2}$, the matrix $M$ is symmetric.\n\nThe problem is thus reduced to finding the eigenvalues and eigenvectors of a real, symmetric matrix $M$. This can be solved efficiently and accurately using standard numerical libraries, such as `scipy.linalg.eigh`. This routine returns all real eigenvalues and a complete set of orthonormal eigenvectors. We identify the minimum eigenvalue, $\\lambda_{\\min}$, and its corresponding eigenvector, $\\vec{\\phi}_{\\text{raw}}$. The growth rate is then calculated as $\\gamma = \\sqrt{\\max(0, -\\lambda_{\\min})}$.\n\nThe problem requires the eigenfunction to be normalized according to the discrete $L^2$ norm with weight $\\Delta z$, such that $\\sum_{j=0}^{N-1} |\\phi_j|^2 \\Delta z = 1$. The eigenvectors returned by standard solvers are typically normalized to unity Euclidean norm, i.e., $\\sum_{j=0}^{N-1} |\\phi_{j, \\text{raw}}|^2 = 1$. To obtain the correctly normalized eigenfunction, we must rescale the raw eigenvector:\n$$\n\\phi_j = \\frac{\\phi_{j, \\text{raw}}}{\\sqrt{\\Delta z}}\n$$\n\nFor the convergence study, we compare the eigenfunction at resolution $N=128$, denoted $\\phi^{(128)}$, with the one at $N=256$, denoted $\\phi^{(256)}$. To compare them on the same grid, the higher-resolution eigenfunction is downsampled by taking every second point, yielding a vector on the $N=128$ grid: $\\psi_j = \\phi^{(256)}_{2j}$. This downsampled vector $\\vec{\\psi}$ must be re-normalized to have a unit $L^2$ norm on the $N=128$ grid. An important subtlety is that an eigenvector's sign is arbitrary. To ensure a meaningful comparison, we align the sign of the downsampled vector with $\\phi^{(128)}$ by ensuring their discrete inner product is positive. If $\\sum_{j=0}^{127} \\phi^{(128)}_j \\psi_j \\Delta z^{(128)} < 0$, we flip the sign of $\\vec{\\psi}$. Finally, the difference $\\Delta_{\\phi}$ is computed as the $L^2$ norm of the difference between the aligned vectors:\n$$\n\\Delta_{\\phi} = \\sqrt{\\sum_{j=0}^{127} \\left(\\phi^{(128)}_j - \\psi_{\\text{aligned},j}\\right)^2 \\Delta z^{(128)}}\n$$\n\nThe procedure is implemented for three different magnetic field profiles $B(z)$ with a fixed drive parameter $C=1.0$. For each case, we compute the growth rate $\\gamma$ at the highest resolution ($N=256$) and the eigenfunction difference $\\Delta_{\\phi}$ between the $N=128$ and $N=256$ results. The coefficients $A(z) = 1/B(z)$ and $Q(z) = -C(B_{\\max} - B(z))/B_0$ are computed using the exact analytical value of $B_{\\max} = \\max_z B(z)$ for improved accuracy.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to perform the convergence study for the given stellarator\n    turbulence model. It iterates through three magnetic field cases, computes\n    growth rates and eigenfunctions at different resolutions, and quantifies\n    the convergence of the mode structure.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"B_func\": lambda z: 1.0 + 0.30 * np.cos(z),\n            \"B_max\": 1.30,\n            \"C\": 1.0,\n            \"B0\": 1.0,\n        },\n        {\n            \"B_func\": lambda z: 1.0 + 0.30 * np.cos(z) + 0.15 * np.cos(3 * z),\n            \"B_max\": 1.45,\n            \"C\": 1.0,\n            \"B0\": 1.0,\n        },\n        {\n            \"B_func\": lambda z: 1.0 + 0.20 * np.cos(10 * z),\n            \"B_max\": 1.20,\n            \"C\": 1.0,\n            \"B0\": 1.0,\n        },\n    ]\n\n    resolutions = [64, 128, 256]\n    aggregated_results = []\n\n    for case_params in test_cases:\n        # Store results for each resolution (gamma, phi, dz)\n        results_per_res = {}\n\n        for N in resolutions:\n            gamma, phi_norm, dz = compute_eigenmode(case_params, N)\n            results_per_res[N] = {\"gamma\": gamma, \"phi\": phi_norm, \"dz\": dz}\n\n        # 1. Converged growth rate at N=256\n        gamma_converged = results_per_res[256][\"gamma\"]\n\n        # 2. Mode structure difference Delta_phi between N=128 and N=256\n        phi_128 = results_per_res[128][\"phi\"]\n        dz_128 = results_per_res[128][\"dz\"]\n        \n        phi_256 = results_per_res[256][\"phi\"]\n\n        # Downsample phi_256 to the N=128 grid\n        phi_256_to_128 = phi_256[::2]\n\n        # Re-normalize the downsampled eigenfunction on the N=128 grid\n        norm_sq = np.sum(phi_256_to_128**2) * dz_128\n        phi_256_to_128_norm = phi_256_to_128 / np.sqrt(norm_sq)\n\n        # Align sign by ensuring the dot product is positive\n        # The L2 inner product is sum(v1*v2*dz). Since dz is a positive\n        # constant, the sign is determined by sum(v1*v2).\n        dot_product = np.sum(phi_128 * phi_256_to_128_norm)\n        if dot_product < 0:\n            phi_256_to_128_norm *= -1\n\n        # Calculate the L2 difference norm\n        diff_vector = phi_128 - phi_256_to_128_norm\n        delta_phi_sq = np.sum(diff_vector**2) * dz_128\n        delta_phi = np.sqrt(delta_phi_sq)\n\n        aggregated_results.extend([gamma_converged, delta_phi])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, aggregated_results))}]\")\n\n\ndef compute_eigenmode(params, N):\n    \"\"\"\n    Computes the minimum eigenvalue, growth rate, and normalized eigenfunction\n    for a given set of parameters and grid resolution.\n\n    Args:\n        params (dict): A dictionary containing B_func, B_max, C, and B0.\n        N (int): The number of grid points for the discretization.\n\n    Returns:\n        tuple: (gamma, phi_normalized, dz)\n            - gamma (float): The calculated growth rate.\n            - phi_normalized (np.ndarray): The eigenfunction normalized to unit L2 norm.\n            - dz (float): The grid spacing.\n    \"\"\"\n    # 1. Set up the grid\n    dz = 2.0 * np.pi / N\n    # Grid is z_j = -pi + j*dz, for j=0..N-1\n    z = np.linspace(-np.pi, np.pi, N, endpoint=False)\n\n    # 2. Define coefficients A(z) and Q(z)\n    B = params[\"B_func\"](z)\n    A = 1.0 / B\n    Q = -params[\"C\"] * (params[\"B_max\"] - B) / params[\"B0\"]\n\n    # 3. Construct the discretized operator matrix M\n    # A at staggered grid points, A_{j+1/2}\n    A_plus_half = 0.5 * (A + np.roll(A, -1))\n    A_minus_half = np.roll(A_plus_half, 1)\n\n    inv_dz_sq = 1.0 / (dz**2)\n    \n    # Diagonal and off-diagonal elements\n    diag = -(A_plus_half + A_minus_half) * inv_dz_sq + Q\n    upper_diag = A_plus_half * inv_dz_sq\n    lower_diag = A_minus_half * inv_dz_sq\n\n    # Assemble the full matrix M with periodic boundary conditions\n    M = np.diag(diag) + np.diag(upper_diag[:-1], k=1) + np.diag(lower_diag[1:], k=-1)\n    M[0, N - 1] = lower_diag[0]\n    M[N - 1, 0] = upper_diag[N - 1]\n\n    # 4. Solve the eigenvalue problem M*phi = lambda*phi\n    # eigh is used for symmetric matrices; it is faster and more stable.\n    eigenvalues, eigenvectors = eigh(M)\n\n    # 5. Extract results for the most unstable mode (minimum eigenvalue)\n    min_eigenvalue_index = np.argmin(eigenvalues)\n    lambda_min = eigenvalues[min_eigenvalue_index]\n    phi_raw = eigenvectors[:, min_eigenvalue_index]\n\n    # 6. Calculate the growth rate\n    gamma = np.sqrt(max(-lambda_min, 0.0))\n\n    # 7. Normalize the eigenfunction: integral |phi|^2 dz = 1\n    # eigh returns eigenvectors with sum |phi_raw|^2 = 1.\n    # We need sum |phi|^2 * dz = 1, so phi = phi_raw / sqrt(dz).\n    phi_normalized = phi_raw / np.sqrt(dz)\n\n    return gamma, phi_normalized, dz\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A robust numerical simulation must yield predictions that are not overly sensitive to small uncertainties in its inputs. Since the magnetic geometry of a real stellarator is known only to finite precision, it is vital to understand how these uncertainties affect simulation outputs. This exercise  explores this concept by tasking you with analyzing how errors in the field-line mapping phase impact the calculated instability growth rate in a simplified model. Developing an algorithm to quantify this sensitivity provides practical experience in verification and validation, a cornerstone of computational science that helps establish confidence in predictive simulations and highlights the most critical parameters for experimental accuracy.",
            "id": "4208597",
            "problem": "Consider a simplified linear model for the evolution of a scalar fluctuation amplitude $a(s,t)$ along a single magnetic field line in a Three-Dimensional (3D) stellarator, expressed in field-aligned coordinates. The model captures parallel diffusion and a constant instability drive and is given by the linear partial differential equation\n$$\n\\frac{\\partial a}{\\partial t} = \\gamma_d \\, a + \\nu \\, \\frac{\\partial^2 a}{\\partial s^2},\n$$\nwhere $s$ is the parallel coordinate along the field line, $t$ is time, $\\gamma_d$ is a constant drive parameter, and $\\nu$ is a constant parallel diffusion coefficient. All quantities are dimensionless in a standardized normalized system (no physical units are required). The parallel domain is an interval $s \\in [0,L]$ of length $L$, and the boundary condition is a twisted periodic mapping induced by the field-line topology. If the code uses a perturbed geometry input, the boundary phase is shifted. Denote the true mapping phase as $\\Phi_{\\text{true}}$ and the used phase as $\\Phi_{\\text{used}} = \\Phi_{\\text{true}} + \\varepsilon$, where $\\varepsilon$ is the geometry error in radians. The twisted periodic boundary conditions are\n$$\na(L,t) = e^{i \\Phi_{\\text{used}}} \\, a(0,t), \\quad \\frac{\\partial a}{\\partial s}(L,t) = e^{i \\Phi_{\\text{used}}} \\, \\frac{\\partial a}{\\partial s}(0,t).\n$$\nAssume normal-mode solutions of the form $a(s,t) = A \\, e^{\\lambda t} \\, f(s)$, where $f(s)$ satisfies the boundary conditions above. The field-line twist introduces a discrete set of allowed parallel wavenumbers indexed by an integer mode number $n \\in \\mathbb{Z}$, which, together with the perturbation in $\\Phi_{\\text{used}}$, determines the growth rate. The sensitivity of the mode growth rate to the geometry error is to be evaluated with respect to $\\varepsilon$. Additionally, quantify the boundary phase inconsistency induced by using $\\Phi_{\\text{used}}$ rather than $\\Phi_{\\text{true}}$ by measuring the magnitude of the complex phase mismatch applied to a unit amplitude at $s=0$.\n\nYour task is to:\n- Derive, from the fundamental model and boundary conditions above, an algorithm that computes, for a given parameter set $(L,\\gamma_d,\\nu,\\Phi_{\\text{true}},\\varepsilon,n)$, the following three quantities:\n  1. The mode growth rate for the chosen $n$ under the perturbed boundary mapping, as a float.\n  2. The sensitivity of the mode growth rate to the geometry error $\\varepsilon$ (i.e., the derivative of the growth rate with respect to $\\varepsilon$), as a float.\n  3. The boundary phase inconsistency magnitude (with the amplitude at $s=0$ normalized to unity), as a float.\n- Implement the algorithm in a program that evaluates these quantities for the provided test suite and prints them in the specified format.\n\nAngles must be in radians.\n\nTest suite:\n- Case $1$: $L=10.0$, $\\gamma_d=0.3$, $\\nu=0.05$, $\\Phi_{\\text{true}}=0.8$, $\\varepsilon=0.05$, $n=1$ (happy path).\n- Case $2$: $L=12.0$, $\\gamma_d=0.25$, $\\nu=0.08$, $\\Phi_{\\text{true}}=1.2$, $\\varepsilon=0.0$, $n=0$ (boundary condition with zero geometry error).\n- Case $3$: $L=8.0$, $\\gamma_d=0.5$, $\\nu=0.03$, $\\Phi_{\\text{true}}=2.6$, $\\varepsilon=-0.02$, $n=5$ (higher mode number and negative geometry error).\n- Case $4$: $L=2.0$, $\\gamma_d=0.15$, $\\nu=0.1$, $\\Phi_{\\text{true}}=0.5$, $\\varepsilon=0.1$, $n=1$ (short connection length).\n- Case $5$: $L=10.0$, $\\gamma_d=0.4$, $\\nu=0.05$, $\\Phi_{\\text{true}}=1.0$, $\\varepsilon=\\pi$, $n=0$ (maximal phase inconsistency).\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. For each case, output the triple $[\\Gamma, S, P]$ consisting of the growth rate $\\Gamma$, sensitivity $S$, and phase inconsistency magnitude $P$. Aggregate all five cases into a single list, resulting in a string of the form $[[\\Gamma_1,S_1,P_1],[\\Gamma_2,S_2,P_2],\\dots]$ printed exactly once.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded, mathematically well-posed, and free of contradictions or ambiguities. It presents a standard eigenvalue problem in the context of plasma physics, for which a unique solution can be derived. We may therefore proceed with the solution.\n\nThe problem asks for the derivation of an algorithm to compute three quantities related to a linear model for scalar fluctuations in a stellarator geometry. The governing partial differential equation (PDE) is:\n$$\n\\frac{\\partial a}{\\partial t} = \\gamma_d \\, a + \\nu \\, \\frac{\\partial^2 a}{\\partial s^2}\n$$\nwhere $a(s,t)$ is the fluctuation amplitude, $s$ is the parallel coordinate, $t$ is time, $\\gamma_d$ is the instability drive, and $\\nu$ is the parallel diffusion coefficient. The domain is $s \\in [0,L]$ with twisted periodic boundary conditions:\n$$\na(L,t) = e^{i \\Phi_{\\text{used}}} \\, a(0,t), \\quad \\frac{\\partial a}{\\partial s}(L,t) = e^{i \\Phi_{\\text{used}}} \\, \\frac{\\partial a}{\\partial s}(0,t)\n$$\nwhere $\\Phi_{\\text{used}} = \\Phi_{\\text{true}} + \\varepsilon$.\n\nWe assume a normal-mode solution of the form $a(s,t) = A \\, e^{\\lambda t} \\, f(s)$, where $\\lambda$ is the complex growth rate. The real part of $\\lambda$ corresponds to the mode growth rate, which we denote as $\\Gamma$. Substituting this ansatz into the PDE yields an ordinary differential equation (ODE) for the spatial part $f(s)$:\n$$\n\\lambda f(s) = \\gamma_d f(s) + \\nu \\frac{d^2 f}{ds^2}\n$$\nRearranging this gives a standard Helmholtz equation:\n$$\n\\frac{d^2 f}{ds^2} + \\left( \\frac{\\lambda - \\gamma_d}{-\\nu} \\right) f(s) = 0\n$$\n$$\n\\frac{d^2 f}{ds^2} + k^2 f(s) = 0, \\quad \\text{where} \\quad k^2 = \\frac{\\gamma_d - \\lambda}{\\nu}\n$$\nThe general solution to this ODE is $f(s) = C_1 e^{iks} + C_2 e^{-iks}$. However, the boundary conditions are most easily satisfied by eigenfunctions of the form $f(s) = e^{ik_\\parallel s}$, where $k_\\parallel$ is the parallel wavenumber. Applying the first boundary condition to this eigenfunction:\n$$\nf(L) = e^{i\\Phi_{\\text{used}}} f(0)\n$$\n$$\ne^{ik_\\parallel L} = e^{i\\Phi_{\\text{used}}} e^{ik_\\parallel \\cdot 0} = e^{i\\Phi_{\\text{used}}}\n$$\nThis implies that the exponents must be equal modulo $2\\pi i$:\n$$\nik_\\parallel L = i\\Phi_{\\text{used}} + i2\\pi n, \\quad \\text{for} \\quad n \\in \\mathbb{Z}\n$$\nThis quantizes the allowed parallel wavenumbers:\n$$\nk_{\\parallel, n} = \\frac{\\Phi_{\\text{used}} + 2\\pi n}{L}\n$$\nThe index $n$ is the integer mode number specified in the problem. The second boundary condition on the derivative is also satisfied by this choice of $f(s)$ and $k_{\\parallel, n}$.\n\nNow we can determine the growth rate $\\lambda$. Substituting $f(s) = e^{ik_{\\parallel,n}s}$ back into the ODE $f'' + k^2 f = 0$, we find:\n$$\n\\frac{d^2}{ds^2} (e^{ik_{\\parallel,n}s}) = (ik_{\\parallel,n})^2 e^{ik_{\\parallel,n}s} = -k_{\\parallel,n}^2 f(s)\n$$\nComparing this with $f'' = -k^2 f$, we identify $k^2 = k_{\\parallel,n}^2$. Using our definition of $k^2$:\n$$\n\\frac{\\gamma_d - \\lambda_n}{\\nu} = k_{\\parallel,n}^2\n$$\nSolving for $\\lambda_n$, which we equate with the growth rate $\\Gamma_n$, we find our first required quantity.\n\n**1. Mode Growth Rate ($\\Gamma$)**\nThe growth rate for the mode with index $n$ is a function of the geometry error $\\varepsilon$:\n$$\n\\Gamma_n(\\varepsilon) = \\lambda_n = \\gamma_d - \\nu k_{\\parallel, n}^2\n$$\nSubstituting the expression for $k_{\\parallel, n}$ and $\\Phi_{\\text{used}} = \\Phi_{\\text{true}} + \\varepsilon$:\n$$\n\\Gamma_n(\\varepsilon) = \\gamma_d - \\nu \\left( \\frac{\\Phi_{\\text{true}} + \\varepsilon + 2\\pi n}{L} \\right)^2\n$$\n\n**2. Sensitivity to Geometry Error ($S$)**\nThe sensitivity $S_n$ is the derivative of the growth rate with respect to the error $\\varepsilon$:\n$$\nS_n = \\frac{d\\Gamma_n}{d\\varepsilon} = \\frac{d}{d\\varepsilon} \\left[ \\gamma_d - \\nu \\left( \\frac{\\Phi_{\\text{true}} + \\varepsilon + 2\\pi n}{L} \\right)^2 \\right]\n$$\nApplying the chain rule:\n$$\nS_n = 0 - \\frac{\\nu}{L^2} \\cdot 2 (\\Phi_{\\text{true}} + \\varepsilon + 2\\pi n) \\cdot \\frac{d}{d\\varepsilon}(\\Phi_{\\text{true}} + \\varepsilon + 2\\pi n)\n$$\n$$\nS_n = -\\frac{2\\nu}{L^2} (\\Phi_{\\text{true}} + \\varepsilon + 2\\pi n)\n$$\nThis can also be expressed compactly using the wavenumber $k_{\\parallel, n}$:\n$$\nS_n = -\\frac{2\\nu}{L} k_{\\parallel, n}\n$$\n\n**3. Boundary Phase Inconsistency Magnitude ($P$)**\nThis quantity is defined as the magnitude of the complex phase mismatch for a unit amplitude at $s=0$. The model uses a boundary phase factor of $e^{i\\Phi_{\\text{used}}}$, while the true physical connection corresponds to $e^{i\\Phi_{\\text{true}}}$. The mismatch is the difference between these two complex phasors.\n$$\n\\text{Mismatch} = e^{i\\Phi_{\\text{used}}} - e^{i\\Phi_{\\text{true}}}\n$$\nThe required magnitude $P$ is:\n$$\nP = \\left| e^{i\\Phi_{\\text{used}}} - e^{i\\Phi_{\\text{true}}} \\right|\n$$\nSubstituting $\\Phi_{\\text{used}} = \\Phi_{\\text{true}} + \\varepsilon$:\n$$\nP = \\left| e^{i(\\Phi_{\\text{true}} + \\varepsilon)} - e^{i\\Phi_{\\text{true}}} \\right| = \\left| e^{i\\Phi_{\\text{true}}} (e^{i\\varepsilon} - 1) \\right|\n$$\nSince $|e^{i\\Phi_{\\text{true}}}| = 1$, this simplifies to:\n$$\nP = \\left| e^{i\\varepsilon} - 1 \\right|\n$$\nWe can compute this magnitude using Euler's formula, $e^{i\\varepsilon} = \\cos(\\varepsilon) + i\\sin(\\varepsilon)$:\n$$\nP = \\left| (\\cos(\\varepsilon) - 1) + i\\sin(\\varepsilon) \\right|\n$$\n$$\nP^2 = (\\cos(\\varepsilon) - 1)^2 + \\sin^2(\\varepsilon) = \\cos^2(\\varepsilon) - 2\\cos(\\varepsilon) + 1 + \\sin^2(\\varepsilon)\n$$\nUsing the identity $\\cos^2(\\varepsilon) + \\sin^2(\\varepsilon) = 1$:\n$$\nP^2 = 1 - 2\\cos(\\varepsilon) + 1 = 2(1 - \\cos(\\varepsilon))\n$$\nFinally, using the half-angle identity $1 - \\cos(\\varepsilon) = 2\\sin^2(\\varepsilon/2)$:\n$$\nP^2 = 4\\sin^2(\\frac{\\varepsilon}{2})\n$$\nTaking the square root gives the magnitude:\n$$\nP = \\left| 2\\sin(\\frac{\\varepsilon}{2}) \\right|\n$$\nThese three derived expressions form the basis of the algorithm to be implemented.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mode growth rate, sensitivity to geometry error,\n    and boundary phase inconsistency for a set of test cases.\n    \"\"\"\n\n    def calculate_outputs(L, gamma_d, nu, phi_true, epsilon, n):\n        \"\"\"\n        Calculates the three required quantities for a single parameter set.\n        \n        Args:\n            L (float): Length of the parallel domain.\n            gamma_d (float): Constant drive parameter.\n            nu (float): Constant parallel diffusion coefficient.\n            phi_true (float): True boundary mapping phase in radians.\n            epsilon (float): Geometry error in radians.\n            n (int): Integer mode number.\n            \n        Returns:\n            list: A list containing the growth rate, sensitivity, and inconsistency magnitude.\n        \"\"\"\n        # The phase used in the boundary condition, including the error\n        phi_used = phi_true + epsilon\n\n        # 1. Mode Growth Rate (Gamma)\n        # The parallel wavenumber k_parallel is determined by the boundary condition\n        k_parallel_n = (phi_used + 2.0 * np.pi * n) / L\n        # The growth rate is derived from the dispersion relation of the PDE\n        growth_rate = gamma_d - nu * (k_parallel_n ** 2)\n\n        # 2. Sensitivity (S)\n        # The sensitivity is the derivative of the growth rate with respect to epsilon\n        sensitivity = -2.0 * nu / (L**2) * (phi_used + 2.0 * np.pi * n)\n\n        # 3. Boundary Phase Inconsistency Magnitude (P)\n        # This is the magnitude of the difference between the true and used phase factors\n        # P = |exp(i*phi_used) - exp(i*phi_true)| = |exp(i*epsilon) - 1|\n        inconsistency = np.abs(2.0 * np.sin(epsilon / 2.0))\n\n        return [growth_rate, sensitivity, inconsistency]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, gamma_d, nu, Phi_true, epsilon, n)\n        (10.0, 0.3, 0.05, 0.8, 0.05, 1),\n        (12.0, 0.25, 0.08, 1.2, 0.0, 0),\n        (8.0, 0.5, 0.03, 2.6, -0.02, 5),\n        (2.0, 0.15, 0.1, 0.5, 0.1, 1),\n        (10.0, 0.4, 0.05, 1.0, np.pi, 0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        params = case\n        result_triple = calculate_outputs(*params)\n        all_results.append(result_triple)\n\n    # Format the final output string exactly as specified:\n    # [[g1,s1,p1],[g2,s2,p2],...] with no spaces.\n    outer_list_str = []\n    for res_triple in all_results:\n        inner_list_str = f\"[{res_triple[0]},{res_triple[1]},{res_triple[2]}]\"\n        outer_list_str.append(inner_list_str)\n    \n    final_output_string = f\"[{','.join(outer_list_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}