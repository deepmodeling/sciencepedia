{
    "hands_on_practices": [
        {
            "introduction": "Before we can predict turbulence, we must accurately characterize the background plasma state. This first exercise focuses on calculating a key dimensionless parameter, the electron collisionality $\\nu^*$, from fundamental plasma properties. Mastering this calculation is essential as it demonstrates how macroscopic transport behavior is rooted in the microscopic physics of particle collisions .",
            "id": "4208342",
            "problem": "In burning plasma conditions relevant to the International Thermonuclear Experimental Reactor (ITER) and the Demonstration Power Plant (DEMO), the electron banana-branch collisionality is a key dimensionless parameter entering turbulence and transport models. Starting from kinetic theory of Coulomb collisions and large-aspect-ratio tokamak geometry, compute the effective electron collisionality using the definition\n$$\\nu^{*} \\equiv \\frac{\\nu_{e}\\,q\\,R}{\\epsilon^{3/2}\\,v_{Te}},$$\nwhere $\\nu_{e}$ is the electron-ion pitch-angle scattering frequency evaluated at the electron thermal speed $v_{Te}$, $q$ is the safety factor, $R$ is the major radius, and $\\epsilon \\equiv a/R$ is the inverse aspect ratio. Use the following foundational elements:\n\n- The electron thermal speed is $v_{Te} = \\sqrt{\\frac{2 k_{B} T_{e}}{m_{e}}}$.\n- For a fully ionized hydrogenic plasma with effective ion charge $Z_{\\mathrm{eff}}=1$, the thermal electron-ion pitch-angle scattering frequency is\n$$\\nu_{e} = \\frac{4 \\sqrt{2\\pi}\\, n_{e}\\, Z_{\\mathrm{eff}}\\, e^{4}\\, \\ln \\Lambda}{3\\, (4\\pi \\epsilon_{0})^{2}\\, m_{e}^{1/2}\\, (k_{B} T_{e})^{3/2}},$$\nwhere $\\ln \\Lambda$ is the Coulomb logarithm.\n- In the classical regime appropriate here, estimate the Coulomb logarithm from the ratio of the Debye length to the classical distance of closest approach,\n$$\\lambda_{D} = \\sqrt{\\frac{\\epsilon_{0} k_{B} T_{e}}{n_{e} e^{2}}}, \\qquad b_{\\min} = \\frac{e^{2}}{4\\pi \\epsilon_{0} m_{e} v_{Te}^{2}}, \\qquad \\ln \\Lambda = \\ln\\!\\left(\\frac{\\lambda_{D}}{b_{\\min}}\\right).$$\n\nAdopt the ITER-scale parameters $n_{e} = 1 \\times 10^{20}\\,\\mathrm{m}^{-3}$, $T_{e} = 12\\,\\mathrm{keV}$, $q=1.8$, $R=6.2\\,\\mathrm{m}$, $\\epsilon=0.33$, and take fundamental constants $e$, $m_{e}$, $k_{B}$, and $\\epsilon_{0}$ at their standard values. Round your final numerical result for $\\nu^{*}$ to three significant figures and express it as a pure number (dimensionless).",
            "solution": "The problem requires the calculation of the effective electron collisionality, $\\nu^{*}$, for a burning plasma with specified parameters. The calculation is to be performed by assembling the result from a set of provided foundational definitions and formulae from kinetic theory.\n\nThe definition of the effective electron collisionality is given as\n$$\n\\nu^{*} \\equiv \\frac{\\nu_{e}\\,q\\,R}{\\epsilon^{3/2}\\,v_{Te}},\n$$\nwhere $\\nu_{e}$ is the electron-ion pitch-angle scattering frequency, $q$ is the safety factor, $R$ is the major radius, $\\epsilon$ is the inverse aspect ratio, and $v_{Te}$ is the electron thermal speed.\n\nThe provided expressions for $\\nu_{e}$ and $v_{Te}$ are:\n$$\n\\nu_{e} = \\frac{4 \\sqrt{2\\pi}\\, n_{e}\\, Z_{\\mathrm{eff}}\\, e^{4}\\, \\ln \\Lambda}{3\\, (4\\pi \\epsilon_{0})^{2}\\, m_{e}^{1/2}\\, (k_{B} T_{e})^{3/2}}\n$$\n$$\nv_{Te} = \\sqrt{\\frac{2 k_{B} T_{e}}{m_{e}}}\n$$\nWe can first form the ratio $\\nu_{e}/v_{Te}$:\n$$\n\\frac{\\nu_{e}}{v_{Te}} = \\left( \\frac{4 \\sqrt{2\\pi}\\, n_{e}\\, Z_{\\mathrm{eff}}\\, e^{4}\\, \\ln \\Lambda}{3\\, (4\\pi \\epsilon_{0})^{2}\\, m_{e}^{1/2}\\, (k_{B} T_{e})^{3/2}} \\right) \\left( \\sqrt{\\frac{m_{e}}{2 k_{B} T_{e}}} \\right)\n$$\nSimplifying this expression yields:\n$$\n\\frac{\\nu_{e}}{v_{Te}} = \\frac{4 \\sqrt{\\pi}\\, n_{e}\\, Z_{\\mathrm{eff}}\\, e^{4}\\, \\ln \\Lambda}{3\\, (4\\pi \\epsilon_{0})^{2}\\, (k_{B} T_{e})^{2}}\n$$\nSubstituting this back into the definition of $\\nu^{*}$ gives the full expression to be evaluated:\n$$\n\\nu^{*} = \\frac{q\\,R}{\\epsilon^{3/2}} \\left( \\frac{4 \\sqrt{\\pi}\\, n_{e}\\, Z_{\\mathrm{eff}}\\, e^{4}\\, \\ln \\Lambda}{3\\, (4\\pi \\epsilon_{0})^{2}\\, (k_{B} T_{e})^{2}} \\right)\n$$\nThe calculation proceeds by first evaluating the Coulomb logarithm, $\\ln \\Lambda$, and then substituting all parameters into the expression for $\\nu^{*}$.\n\nFirst, we calculate the Coulomb logarithm, $\\ln \\Lambda = \\ln(\\lambda_{D}/b_{\\min})$. The required parameters must be in base SI units.\nThe given electron temperature is $T_{e} = 12\\,\\mathrm{keV}$. The corresponding thermal energy is:\n$$\nk_{B} T_{e} = 12 \\times 10^{3}\\,\\mathrm{eV} \\times \\frac{1.602176634 \\times 10^{-19}\\,\\mathrm{J}}{1\\,\\mathrm{eV}} \\approx 1.92261 \\times 10^{-15}\\,\\mathrm{J}\n$$\nThe other parameters and constants are:\nElectron density, $n_{e} = 1 \\times 10^{20}\\,\\mathrm{m}^{-3}$.\nElementary charge, $e \\approx 1.602177 \\times 10^{-19}\\,\\mathrm{C}$.\nPermittivity of free space, $\\epsilon_{0} \\approx 8.854188 \\times 10^{-12}\\,\\mathrm{F/m}$.\n\nThe Debye length, $\\lambda_{D}$, is:\n$$\n\\lambda_{D} = \\sqrt{\\frac{\\epsilon_{0} k_{B} T_{e}}{n_{e} e^{2}}} = \\sqrt{\\frac{(8.854188 \\times 10^{-12}) \\times (1.92261 \\times 10^{-15})}{(1 \\times 10^{20}) \\times (1.602177 \\times 10^{-19})^{2}}} \\approx 8.1413 \\times 10^{-5}\\,\\mathrm{m}\n$$\nThe classical distance of closest approach, $b_{\\min}$, is defined using the electron thermal speed $v_{Te}$. We can substitute $m_e v_{Te}^2 = 2 k_B T_e$ into its definition:\n$$\nb_{\\min} = \\frac{e^{2}}{4\\pi \\epsilon_{0} m_{e} v_{Te}^{2}} = \\frac{e^{2}}{4\\pi \\epsilon_{0} (2 k_{B} T_{e})} = \\frac{e^{2}}{8\\pi \\epsilon_{0} k_{B} T_{e}}\n$$\n$$\nb_{\\min} = \\frac{(1.602177 \\times 10^{-19})^{2}}{8\\pi (8.854188 \\times 10^{-12}) (1.92261 \\times 10^{-15})} \\approx 5.9984 \\times 10^{-14}\\,\\mathrm{m}\n$$\nNow, we can compute the ratio $\\Lambda$ and the Coulomb logarithm $\\ln \\Lambda$:\n$$\n\\Lambda = \\frac{\\lambda_{D}}{b_{\\min}} = \\frac{8.1413 \\times 10^{-5}\\,\\mathrm{m}}{5.9984 \\times 10^{-14}\\,\\mathrm{m}} \\approx 1.3572 \\times 10^{9}\n$$\n$$\n\\ln \\Lambda = \\ln(1.3572 \\times 10^{9}) \\approx 21.030\n$$\nWith the value of $\\ln \\Lambda$, we can now evaluate $\\nu^{*}$. The remaining parameters are:\nSafety factor, $q = 1.8$.\nMajor radius, $R = 6.2\\,\\mathrm{m}$.\nInverse aspect ratio, $\\epsilon = 0.33$.\nEffective ion charge, $Z_{\\mathrm{eff}} = 1$.\n\nLet's group the terms in the expression for $\\nu^{*}$:\n$$\n\\nu^{*} = \\left(\\frac{q\\,R}{\\epsilon^{3/2}}\\right) \\left(\\frac{4 \\sqrt{\\pi}\\, e^{4}}{3(4\\pi\\epsilon_{0})^{2}}\\right) \\left(\\frac{n_{e}\\, Z_{\\mathrm{eff}} \\ln \\Lambda}{(k_{B} T_{e})^{2}}\\right)\n$$\nWe evaluate each group:\n$$\n\\frac{q\\,R}{\\epsilon^{3/2}} = \\frac{1.8 \\times 6.2}{(0.33)^{3/2}} \\approx \\frac{11.16}{0.18930} \\approx 58.953\n$$\nThe group of fundamental constants is:\n$$\n\\frac{4 \\sqrt{\\pi}\\, e^{4}}{3(4\\pi\\epsilon_{0})^{2}} = \\frac{e^{4}}{12\\pi^{3/2}\\epsilon_{0}^2} \\approx \\frac{(1.602177 \\times 10^{-19})^{4}}{12\\pi^{1.5}(8.854188 \\times 10^{-12})^{2}} \\approx 1.2596 \\times 10^{-55}\\,\\mathrm{J^2 m^2}\n$$\nThe plasma parameter group is:\n$$\n\\frac{n_{e}\\, Z_{\\mathrm{eff}} \\ln \\Lambda}{(k_{B} T_{e})^{2}} = \\frac{(1 \\times 10^{20}) \\times 1 \\times 21.030}{(1.92261 \\times 10^{-15})^{2}} \\approx \\frac{2.1030 \\times 10^{21}}{3.6964 \\times 10^{-30}} \\approx 5.6891 \\times 10^{50}\\,\\mathrm{J^{-2} m^{-3}}\n$$\nCombining these results:\n$$\n\\nu^{*} \\approx (58.953) \\times (1.2596 \\times 10^{-55}\\,\\mathrm{J^2 m^2}) \\times (5.6891 \\times 10^{50}\\,\\mathrm{J^{-2} m^{-3}})\n$$\nNote that the units $\\mathrm{m^2} \\times \\mathrm{m}^{-3} = \\mathrm{m}^{-1}$. The first term has units of length, $\\mathrm{m}$. Therefore the final result is dimensionless, as expected for $\\nu^{*}$.\n$$\n\\nu^{*} \\approx 58.953 \\times (7.166 \\times 10^{-5}) \\approx 0.0042249\n$$\nRounding the final numerical result to three significant figures, we obtain $\\nu^{*} = 0.00422$. Expressed in scientific notation, this is $4.22 \\times 10^{-3}$.",
            "answer": "$$\n\\boxed{4.22 \\times 10^{-3}}\n$$"
        },
        {
            "introduction": "Turbulent transport is fundamentally driven by the growth of small-scale instabilities. This practice bridges the gap between linear gyrokinetic theory and a concrete transport prediction, using a quasilinear model to estimate the ion heat diffusivity $\\chi_i$ from instability growth rates. This exercise provides a hands-on implementation of a core concept in predictive modeling: that the saturation of linear modes gives rise to turbulent fluxes .",
            "id": "4208279",
            "problem": "Consider the task of predicting ion thermal transport in burning plasmas relevant to International Thermonuclear Experimental Reactor (ITER) and Demonstration Power Plant (DEMO) using quasilinear theory grounded in gyrokinetic dynamics. The ion heat flux is modeled by Fick’s law, which states that the flux is proportional to the gradient of the ion temperature. The fundamental base for this problem consists of the following widely accepted principles and definitions:\n- The flux-surface averaged ion heat flux is given by a diffusive closure, where the ion heat flux $Q_{i}$ satisfies $Q_{i} = - n_{i} k_{\\mathrm{B}} \\chi_{i} \\, \\partial T_{i} / \\partial r$, with $n_{i}$ the ion number density, $k_{\\mathrm{B}}$ the Boltzmann constant, $\\chi_{i}$ the ion thermal diffusivity, and $T_{i}$ the ion temperature.\n- In quasilinear mixing-length reasoning, turbulent transport arises from $E \\times B$ advection with a decorrelation time set by the linear growth rate and a perpendicular correlation length set by the mode structure. Using the saturation rule for electrostatic potential fluctuations, the energy-containing amplitude follows $|\\phi_{k}|^{2} \\sim \\gamma / k_{\\perp}^{2}$, where $\\gamma$ is the linear growth rate and $k_{\\perp}^{2} = k_{x}^{2} + k_{y}^{2}$ is the squared perpendicular wavenumber determined by the mode eigenfunction (radial structure via $k_{x}$) and the binormal wavenumber $k_{y}$.\n- The perpendicular Larmor radius of ions is $\\rho_{i} = v_{\\mathrm{th}i}/\\Omega_{i}$, with $v_{\\mathrm{th}i} = \\sqrt{2 k_{\\mathrm{B}} T_{i} / m_{i}}$ the ion thermal speed and $\\Omega_{i} = q_{i} B / m_{i}$ the ion cyclotron frequency. Here $m_{i}$ is the ion mass, $q_{i}$ the ion charge, and $B$ the magnetic field strength.\n\nStarting from these principles, derive the quasilinear estimate of the ion thermal diffusivity $\\chi_{i}(k_{y})$ at fixed $k_{y}$ from first principles, using the saturation rule and the perpendicular scale implied by the eigenfunction to determine how $\\chi_{i}(k_{y})$ depends on $\\gamma$ and $k_{\\perp}$. The derivation must justify the dependence of $\\chi_{i}$ on the growth rate and perpendicular wavenumber without introducing any ad hoc transport coefficients. Incorporate a dimensionless coupling factor $\\alpha_{i}(k_{y})$ in the final expression that accounts for the linear eigenfunction’s cross-phase between the $E \\times B$ velocity and the ion temperature fluctuation, where $0 \\le \\alpha_{i}(k_{y}) \\le 1$.\n\nThen, compute the corresponding ion heat flux $Q_{i}(k_{y})$ at each $k_{y}$ using Fick’s law. Express all final ion heat flux values in watts per square meter (W/m$^{2}$) and round each value to three significant figures.\n\nYour program must implement the following procedure for a specified set of parameters:\n1. Compute $v_{\\mathrm{th}i} = \\sqrt{2 k_{\\mathrm{B}} T_{i} / m_{i}}$.\n2. Compute $\\Omega_{i} = q_{i} B / m_{i}$.\n3. Compute $\\rho_{i} = v_{\\mathrm{th}i} / \\Omega_{i}$.\n4. Convert each dimensionless binormal wavenumber $k_{y} \\rho_{i}$ to physical $k_{y}$ as $k_{y} = (k_{y} \\rho_{i}) / \\rho_{i}$.\n5. Form $k_{\\perp}^{2} = k_{x}^{2} + k_{y}^{2}$ using the given $k_{x}$ from the eigenfunction structure.\n6. Use the derived quasilinear closure to compute $\\chi_{i}(k_{y})$.\n7. Compute $Q_{i}(k_{y}) = - n_{i} k_{\\mathrm{B}} \\chi_{i}(k_{y}) \\, \\partial T_{i} / \\partial r$ for each $k_{y}$.\n8. Produce the outputs in W/m$^{2}$, rounded to three significant figures.\n\nScientific realism constraint: Use deuterium ions with mass $m_{i} = 3.343583719 \\times 10^{-27}$ kg and charge $q_{i} = 1.602176634 \\times 10^{-19}$ C. Use the Boltzmann constant $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ J/K.\n\nTest suite. Implement three distinct scenarios that span typical and edge-case conditions in burning plasmas. For each scenario, evaluate the four $k_{y} \\rho_{i}$ values $[\\,0.2,\\,0.4,\\,0.6,\\,0.8\\,]$.\n\n- Scenario A (ITER-like core, “happy path”):\n  - $n_{i} = 1.0 \\times 10^{20}$ m$^{-3}$, $B = 5.3$ T, $T_{i} = 1.50 \\times 10^{8}$ K, $\\partial T_{i} / \\partial r = -5.00 \\times 10^{6}$ K/m.\n  - Linear growth rates in s$^{-1}$ for $k_{y} \\rho_{i} = [\\,0.2,\\,0.4,\\,0.6,\\,0.8\\,]$: $\\gamma = [\\,1.00 \\times 10^{4},\\,1.80 \\times 10^{4},\\,2.50 \\times 10^{4},\\,2.00 \\times 10^{4}\\,]$.\n  - Radial wavenumbers in m$^{-1}$: $k_{x} = [\\,1.50 \\times 10^{2},\\,2.00 \\times 10^{2},\\,2.50 \\times 10^{2},\\,3.00 \\times 10^{2}\\,]$.\n  - Coupling factors: $\\alpha_{i} = [\\,0.70,\\,0.80,\\,0.85,\\,0.80\\,]$.\n\n- Scenario B (near marginal stability, boundary coverage: includes a nearly stable mode):\n  - $n_{i} = 1.0 \\times 10^{20}$ m$^{-3}$, $B = 5.3$ T, $T_{i} = 1.50 \\times 10^{8}$ K, $\\partial T_{i} / \\partial r = -5.00 \\times 10^{6}$ K/m.\n  - Linear growth rates in s$^{-1}$: $\\gamma = [\\,0.00,\\,3.00 \\times 10^{3},\\,4.00 \\times 10^{3},\\,3.50 \\times 10^{3}\\,]$.\n  - Radial wavenumbers in m$^{-1}$: $k_{x} = [\\,1.50 \\times 10^{2},\\,2.00 \\times 10^{2},\\,2.50 \\times 10^{2},\\,3.00 \\times 10^{2}\\,]$.\n  - Coupling factors: $\\alpha_{i} = [\\,0.60,\\,0.70,\\,0.75,\\,0.70\\,]$.\n\n- Scenario C (eigenfunction with large radial wavenumber, edge case for strong perpendicular decorrelation):\n  - $n_{i} = 1.0 \\times 10^{20}$ m$^{-3}$, $B = 5.3$ T, $T_{i} = 1.50 \\times 10^{8}$ K, $\\partial T_{i} / \\partial r = -5.00 \\times 10^{6}$ K/m.\n  - Linear growth rates in s$^{-1}$: $\\gamma = [\\,1.50 \\times 10^{4},\\,1.60 \\times 10^{4},\\,1.70 \\times 10^{4},\\,1.60 \\times 10^{4}\\,]$.\n  - Radial wavenumbers in m$^{-1}$: $k_{x} = [\\,5.00 \\times 10^{2},\\,6.00 \\times 10^{2},\\,7.00 \\times 10^{2},\\,8.00 \\times 10^{2}\\,]$.\n  - Coupling factors: $\\alpha_{i} = [\\,0.70,\\,0.75,\\,0.80,\\,0.75\\,]$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each scenario’s result is itself a list of the four $Q_{i}(k_{y})$ values in W/m$^{2}$ (rounded to three significant figures) ordered by $k_{y} \\rho_{i} = 0.2, 0.4, 0.6, 0.8$. For example: \"[[scenarioA_k0.2,scenarioA_k0.4,scenarioA_k0.6,scenarioA_k0.8],[scenarioB_k0.2,...],[scenarioC_k0.2,...]]\".",
            "solution": "The problem statement is evaluated as scientifically sound, well-posed, objective, and complete. It is grounded in established principles of plasma physics, specifically gyrokinetic theory and quasilinear transport models. All necessary physical constants, parameters, and boundary conditions are provided to derive a unique, meaningful solution. The problem is therefore deemed valid and a solution will be provided.\n\nThe core of the problem is to first derive the quasilinear estimate for the ion thermal diffusivity, $\\chi_i$, and then use it to compute the ion heat flux, $Q_i$.\n\n**1. Derivation of the Ion Thermal Diffusivity $\\chi_i$**\n\nThe turbulent ion heat flux, $Q_i$, is the flux-surface average of the radial transport of ion thermal energy due to fluctuations. In a statistical sense, it is given by the correlation between the radial component of the fluctuating $E \\times B$ velocity, $\\delta v_{Er}$, and the ion temperature fluctuation, $\\delta T_i$:\n$$\nQ_i = n_i k_B \\langle \\delta v_{Er} \\delta T_i \\rangle\n$$\nwhere $n_i$ is the ion density, $k_B$ is the Boltzmann constant, and the angled brackets denote a spatial or temporal average over the fluctuations. Fick's law of diffusion, given in the problem statement, provides a macroscopic closure for this flux:\n$$\nQ_i = -n_i k_B \\chi_i \\frac{\\partial T_i}{\\partial r}\n$$\nBy comparing these two expressions, we can identify the thermal diffusivity $\\chi_i$ as:\n$$\n\\chi_i = - \\frac{\\langle \\delta v_{Er} \\delta T_i \\rangle}{\\partial T_i / \\partial r}\n$$\nQuasilinear theory provides a method to estimate the fluctuating quantities. The primary mechanism for turbulent transport in a magnetized plasma is the $\\vec{E} \\times \\vec{B}$ drift, where $\\vec{E}$ is the fluctuating electric field. For electrostatic turbulence, $\\delta\\vec{E} = -\\nabla \\delta\\phi$, where $\\delta\\phi$ is the fluctuating electrostatic potential. The radial component of the drift velocity for a single Fourier mode with wavenumber $\\vec{k} = (k_x, k_y)$ is $\\delta v_{Er, k} = -i k_y \\phi_k / B$.\n\nThe problem asks for a derivation based on mixing-length arguments. A central tenet of this approach is that the turbulence saturates when the nonlinear advection rate, $\\omega_{NL}$, becomes comparable to the linear growth rate, $\\gamma$, of the most unstable mode. The nonlinear rate can be estimated as the rate at which turbulent eddies advect structures of their own size, $\\omega_{NL} \\sim k_\\perp v_{E,\\perp}$, where $v_{E,\\perp} \\sim k_y |\\phi_k| / B$ is a characteristic perpendicular velocity and $k_\\perp = \\sqrt{k_x^2 + k_y^2}$ is the characteristic perpendicular wavenumber. The saturation condition $\\gamma_k \\approx \\omega_{NL}$ is thus often modeled as $\\gamma_k \\sim k_\\perp^2 \\chi_k$ where $\\chi_k$ is the diffusivity associated with that mode.\n\nThis directly yields the widely used mixing-length estimate for the turbulent diffusivity:\n$$\n\\chi_i(k_y) \\sim \\frac{\\gamma(k_y)}{k_\\perp^2}\n$$\nThis estimate captures the fundamental physics: transport increases with the instability drive ($\\gamma$) and decreases for smaller spatial structures (larger $k_\\perp$), which are less efficient at large-scale transport. The units are $(\\mathrm{s}^{-1}) / (\\mathrm{m}^{-2}) = \\mathrm{m}^2/\\mathrm{s}$, which is correct for a diffusivity.\n\nThis simple estimate, however, neglects the detailed physics of the phase relationship between the velocity fluctuation $\\delta v_{Er}$ and the temperature fluctuation $\\delta T_i$. The net transport depends critically on this cross-phase. The problem accounts for this by introducing a dimensionless coupling factor, $\\alpha_i(k_y)$, which represents the efficiency of the mode in driving thermal transport. This factor, ranging from $0$ to $1$, encapsulates the complex physics of the linear eigenfunction's structure and phase relationships.\n\nTherefore, the final, more complete quasilinear expression for the ion thermal diffusivity for a mode with binormal wavenumber $k_y$ is:\n$$\n\\chi_i(k_y) = \\alpha_i(k_y) \\frac{\\gamma(k_y)}{k_\\perp^2}\n$$\nwhere $k_\\perp^2 = k_x(k_y)^2 + k_y^2$. The dependence of the radial wavenumber $k_x$ on $k_y$ reflects the fact that the radial structure of the eigenmode is typically a function of its binormal wavenumber.\n\n**2. Computational Procedure**\n\nWith the derived expression for $\\chi_i(k_y)$, we can now follow the computational procedure specified in the problem statement. The steps are executed for each of the three scenarios, and for each of the four given $(k_y \\rho_i)$ values within each scenario.\n\n1.  **Compute Ion Thermal Speed ($v_{\\mathrm{th}i}$)**: Calculate $v_{\\mathrm{th}i} = \\sqrt{2 k_{\\mathrm{B}} T_{i} / m_{i}}$. This is constant for all modes within a single scenario.\n2.  **Compute Ion Cyclotron Frequency ($\\Omega_{i}$)**: Calculate $\\Omega_{i} = q_{i} B / m_{i}$. This is also constant for all modes within a single scenario.\n3.  **Compute Ion Larmor Radius ($\\rho_{i}$)**: Calculate $\\rho_{i} = v_{\\mathrm{th}i} / \\Omega_{i}$. This is also constant within a scenario.\n4.  **Compute Binormal Wavenumber ($k_{y}$)**: For each dimensionless value $(k_{y}\\rho_i)$, calculate the physical wavenumber as $k_{y} = (k_{y}\\rho_i) / \\rho_{i}$.\n5.  **Compute Perpendicular Wavenumber ($k_{\\perp}^2$)**: Using the given $k_x$ value for each mode, calculate $k_{\\perp}^2 = k_{x}^2 + k_{y}^2$.\n6.  **Compute Ion Thermal Diffusivity ($\\chi_{i}(k_{y})$)**: Use the derived formula $\\chi_{i}(k_{y}) = \\alpha_{i}(k_y) \\frac{\\gamma(k_y)}{k_x^2 + k_y^2}$, using the corresponding values of $\\alpha_i$, $\\gamma$, $k_x$, and the calculated $k_y$ for each mode.\n7.  **Compute Ion Heat Flux ($Q_{i}(k_{y})$)**: Calculate the heat flux contribution from each mode using Fick's law: $Q_{i}(k_{y}) = -n_{i} k_{\\mathrm{B}} \\chi_{i}(k_{y}) (\\partial T_{i} / \\partial r)$. The negative sign in the temperature gradient results in a positive (outward) heat flux for positive $\\chi_i$.\n8.  **Format Output**: Each calculated $Q_i(k_y)$ value is rounded to three significant figures and presented in units of W/m$^2$. The final output aggregates the results from all scenarios into a nested list structure.",
            "answer": "```python\nimport numpy as np\nfrom math import log10, floor\n\ndef solve():\n    \"\"\"\n    Solves the plasma turbulence problem by deriving ion heat flux for three scenarios.\n    \"\"\"\n\n    # Scientific Constants\n    M_D = 3.343583719e-27  # Mass of Deuterium (kg)\n    Q_ION = 1.602176634e-19 # Elementary charge (C)\n    K_B = 1.380649e-23      # Boltzmann constant (J/K)\n\n    # Test Scenarios\n    test_scenarios = [\n        {\n            \"name\": \"Scenario A (ITER-like core)\",\n            \"params\": {\n                \"n_i\": 1.0e20,  # Ion density (m^-3)\n                \"B\": 5.3,       # Magnetic field (T)\n                \"T_i\": 1.50e8,  # Ion temperature (K)\n                \"grad_T_i\": -5.00e6, # Ion temperature gradient (K/m)\n            },\n            \"modes\": {\n                \"ky_rho_i\": np.array([0.2, 0.4, 0.6, 0.8]),\n                \"gamma\": np.array([1.00e4, 1.80e4, 2.50e4, 2.00e4]), # Growth rates (s^-1)\n                \"k_x\": np.array([1.50e2, 2.00e2, 2.50e2, 3.00e2]),   # Radial wavenumbers (m^-1)\n                \"alpha_i\": np.array([0.70, 0.80, 0.85, 0.80]),      # Coupling factors\n            }\n        },\n        {\n            \"name\": \"Scenario B (near marginal stability)\",\n            \"params\": {\n                \"n_i\": 1.0e20,\n                \"B\": 5.3,\n                \"T_i\": 1.50e8,\n                \"grad_T_i\": -5.00e6,\n            },\n            \"modes\": {\n                \"ky_rho_i\": np.array([0.2, 0.4, 0.6, 0.8]),\n                \"gamma\": np.array([0.00, 3.00e3, 4.00e3, 3.50e3]),\n                \"k_x\": np.array([1.50e2, 2.00e2, 2.50e2, 3.00e2]),\n                \"alpha_i\": np.array([0.60, 0.70, 0.75, 0.70]),\n            }\n        },\n        {\n            \"name\": \"Scenario C (large radial wavenumber)\",\n            \"params\": {\n                \"n_i\": 1.0e20,\n                \"B\": 5.3,\n                \"T_i\": 1.50e8,\n                \"grad_T_i\": -5.00e6,\n            },\n            \"modes\": {\n                \"ky_rho_i\": np.array([0.2, 0.4, 0.6, 0.8]),\n                \"gamma\": np.array([1.50e4, 1.60e4, 1.70e4, 1.60e4]),\n                \"k_x\": np.array([5.00e2, 6.00e2, 7.00e2, 8.00e2]),\n                \"alpha_i\": np.array([0.70, 0.75, 0.80, 0.75]),\n            }\n        }\n    ]\n\n    def round_to_sf(x, n):\n        \"\"\"Rounds a number x to n significant figures.\"\"\"\n        if x == 0:\n            return 0.0\n        return round(x, n - int(floor(log10(abs(x)))) - 1)\n\n    all_results = []\n\n    for scenario in test_scenarios:\n        params = scenario[\"params\"]\n        modes = scenario[\"modes\"]\n        \n        # Unpack parameters\n        n_i = params[\"n_i\"]\n        B = params[\"B\"]\n        T_i = params[\"T_i\"]\n        grad_T_i = params[\"grad_T_i\"]\n        \n        ky_rho_i_vals = modes[\"ky_rho_i\"]\n        gamma_vals = modes[\"gamma\"]\n        kx_vals = modes[\"k_x\"]\n        alpha_i_vals = modes[\"alpha_i\"]\n\n        # Step 1: Compute ion thermal speed\n        v_thi = np.sqrt(2 * K_B * T_i / M_D)\n        \n        # Step 2: Compute ion cyclotron frequency\n        omega_i = Q_ION * B / M_D\n        \n        # Step 3: Compute ion Larmor radius\n        rho_i = v_thi / omega_i\n        \n        scenario_fluxes = []\n        \n        for i in range(len(ky_rho_i_vals)):\n            # Unpack mode-specific values\n            ky_rho_i = ky_rho_i_vals[i]\n            gamma = gamma_vals[i]\n            k_x = kx_vals[i]\n            alpha_i = alpha_i_vals[i]\n\n            # Handle stable mode case\n            if gamma == 0.0:\n                scenario_fluxes.append(0.0)\n                continue\n\n            # Step 4: Convert dimensionless ky_rho_i to physical k_y\n            k_y = ky_rho_i / rho_i\n            \n            # Step 5: Form k_perp squared\n            k_perp_sq = k_x**2 + k_y**2\n            \n            # Step 6: Compute ion thermal diffusivity chi_i\n            chi_i = alpha_i * gamma / k_perp_sq\n            \n            # Step 7: Compute ion heat flux Q_i\n            Q_i = -n_i * K_B * chi_i * grad_T_i\n\n            # Step 8: Round to three significant figures\n            rounded_Q_i = round_to_sf(Q_i, 3)\n            scenario_fluxes.append(rounded_Q_i)\n        \n        all_results.append(scenario_fluxes)\n\n    # Format the final output string as per requirements\n    outer_list_str = []\n    for res_list in all_results:\n        inner_list_str = f\"[{','.join(map(str, res_list))}]\"\n        outer_list_str.append(inner_list_str)\n    \n    final_output_str = f\"[{','.join(outer_list_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While first-principles models are powerful, their computational cost often necessitates the use of simplified, or 'reduced,' transport models for rapid scenario analysis. This final exercise introduces a modern, data-driven approach to determine the free parameters in such a model. By performing a Bayesian calibration against synthetic experimental data, you will practice the statistical methods used to ensure our predictive tools are well-grounded and quantitatively accurate .",
            "id": "4208356",
            "problem": "Consider a reduced transport model for the ion heat flux in gyro-Bohm normalized units (dimensionless), suitable for burning plasmas in devices such as the Joint European Torus (JET) and the International Thermonuclear Experimental Reactor (ITER). The model predicts the normalized turbulent ion heat flux based on a stiffness parameter and a threshold in the normalized inverse temperature gradient. Let the model be defined by\n$$\nQ_{\\mathrm{model}}(g;\\kappa,g_c) = \\kappa \\max\\left(0, g - g_c\\right),\n$$\nwhere $g$ is the dimensionless normalized inverse ion temperature gradient (for example $R/L_{T_i}$, where $R$ is the major radius and $L_{T_i}$ is the ion temperature scale length), $\\kappa>0$ is the stiffness parameter controlling the slope of the transport above threshold, and $g_c>0$ is the critical gradient threshold. You are given experimental measurements $Q_{\\mathrm{exp},i}$ of the normalized ion heat flux at various values $g_i$ of the gradient, with known and independent Gaussian measurement noise of standard deviation $\\sigma$.\n\nFormulate a Bayesian calibration of $(\\kappa,g_c)$ against the provided data, using:\n- an independent log-normal prior for $\\kappa$ with $\\ln \\kappa \\sim \\mathcal{N}(\\mu_\\kappa,\\sigma_\\kappa^2)$, and\n- an independent normal prior for $g_c \\sim \\mathcal{N}(\\mu_{g_c},\\tau_{g_c}^2)$ truncated to $g_c>0$.\n\nAssume the likelihood is Gaussian with independent errors:\n$$\n\\mathcal{L}\\left(Q_{\\mathrm{exp}} \\mid \\kappa,g_c\\right) = \\prod_{i} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( -\\frac{\\left(Q_{\\mathrm{exp},i} - Q_{\\mathrm{model}}(g_i;\\kappa,g_c)\\right)^2}{2\\sigma^2} \\right).\n$$\nYour task is to derive, from Bayes' theorem and the given model, the form of the posterior distribution $p(\\kappa,g_c \\mid Q_{\\mathrm{exp}})$ up to a normalizing constant, and then compute the posterior means $\\mathbb{E}[\\kappa \\mid Q_{\\mathrm{exp}}]$ and $\\mathbb{E}[g_c \\mid Q_{\\mathrm{exp}}]$ numerically by integrating over a rectangular parameter domain using a uniform grid.\n\nImplement a program that:\n1. For each test case in the test suite provided below, constructs the unnormalized posterior on a uniform grid over $(\\kappa,g_c)$, rescales for numerical stability, and computes the posterior means by numerical quadrature.\n2. Produces a single line of output containing all posterior means for all test cases, in order, as a comma-separated list enclosed in square brackets. The results must be ordered by test case; within each test case, first report $\\mathbb{E}[\\kappa \\mid Q_{\\mathrm{exp}}]$ and then $\\mathbb{E}[g_c \\mid Q_{\\mathrm{exp}}]$. Express all results as decimal floats.\n\nThe test suite consists of four cases representing JET/ITER/DEMO-relevant regimes. All quantities are dimensionless:\n\n- Test case 1 (JET-like, supercritical gradients):\n  - $g = [5.0,\\, 5.5,\\, 6.0,\\, 6.5]$\n  - $Q_{\\mathrm{exp}} = [0.39,\\, 1.04,\\, 1.69,\\, 2.34]$\n  - $\\sigma = 0.15$\n  - Prior parameters: $\\mu_\\kappa = 0.1$, $\\sigma_\\kappa = 0.5$ for $\\ln \\kappa$; $\\mu_{g_c} = 4.5$, $\\tau_{g_c} = 0.4$\n  - Integration domain: $\\kappa \\in [0.1,\\, 3.0]$, $g_c \\in [3.0,\\, 6.0]$\n\n- Test case 2 (ITER-like, near-threshold):\n  - $g = [4.0,\\, 4.2,\\, 4.5,\\, 4.7,\\, 5.0]$\n  - $Q_{\\mathrm{exp}} = [0.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, 0.3]$\n  - $\\sigma = 0.1$\n  - Prior parameters: $\\mu_\\kappa = 0.3$, $\\sigma_\\kappa = 0.4$ for $\\ln \\kappa$; $\\mu_{g_c} = 4.6$, $\\tau_{g_c} = 0.3$\n  - Integration domain: $\\kappa \\in [0.1,\\, 3.0]$, $g_c \\in [3.0,\\, 6.0]$\n\n- Test case 3 (edge case, subcritical gradients):\n  - $g = [3.0,\\, 3.5,\\, 3.8,\\, 4.0]$\n  - $Q_{\\mathrm{exp}} = [0.0,\\, 0.0,\\, 0.0,\\, 0.0]$\n  - $\\sigma = 0.2$\n  - Prior parameters: $\\mu_\\kappa = 0.0$, $\\sigma_\\kappa = 0.6$ for $\\ln \\kappa$; $\\mu_{g_c} = 4.8$, $\\tau_{g_c} = 0.6$\n  - Integration domain: $\\kappa \\in [0.1,\\, 3.0]$, $g_c \\in [3.0,\\, 6.0]$\n\n- Test case 4 (DEMO-like, stiff transport far above threshold):\n  - $g = [6.0,\\, 7.0,\\, 8.0]$\n  - $Q_{\\mathrm{exp}} = [3.0,\\, 5.0,\\, 7.0]$\n  - $\\sigma = 0.2$\n  - Prior parameters: $\\mu_\\kappa = 0.5$, $\\sigma_\\kappa = 0.3$ for $\\ln \\kappa$; $\\mu_{g_c} = 4.6$, $\\tau_{g_c} = 0.4$\n  - Integration domain: $\\kappa \\in [0.1,\\, 3.0]$, $g_c \\in [3.0,\\, 6.0]$\n\nYour program should use a uniform rectangular grid with at least $200 \\times 200$ points spanning each specified parameter domain, compute the posterior means for each test case, and print the results as a single line in the format:\n$$\n[\\text{E}[\\kappa]_1,\\,\\text{E}[g_c]_1,\\,\\text{E}[\\kappa]_2,\\,\\text{E}[g_c]_2,\\,\\text{E}[\\kappa]_3,\\,\\text{E}[g_c]_3,\\,\\text{E}[\\kappa]_4,\\,\\text{E}[g_c]_4].\n$$\nNo physical units are involved since all variables are dimensionless.",
            "solution": "The problem requires the computation of posterior mean values for the parameters $(\\kappa, g_c)$ of a reduced transport model for ion heat flux in fusion plasmas. The estimation is to be performed using Bayesian inference, based on provided experimental data, a model, and specified prior distributions.\n\nFirst, we establish the mathematical form of the unnormalized posterior distribution. According to Bayes' theorem, the posterior $p(\\kappa, g_c \\mid D)$ is proportional to the product of the likelihood $p(D \\mid \\kappa, g_c)$ and the prior $p(\\kappa, g_c)$, where $D$ represents the set of experimental data pairs $(g_i, Q_{\\mathrm{exp},i})$.\n$$\np(\\kappa, g_c \\mid D) \\propto p(D \\mid \\kappa, g_c) p(\\kappa) p(g_c)\n$$\nThe parameters $\\kappa$ and $g_c$ are assumed to have independent priors. For numerical stability, it is advantageous to work with the logarithm of the posterior distribution, which is proportional to the sum of the log-likelihood and the log-priors.\n\nThe transport model is given by $Q_{\\mathrm{model}}(g;\\kappa,g_c) = \\kappa \\max\\left(0, g - g_c\\right)$.\nThe likelihood is a product of independent Gaussians, leading to a log-likelihood (ignoring constant terms irrelevant for parameter estimation):\n$$\n\\ln \\mathcal{L}(\\kappa, g_c) \\propto -\\frac{1}{2\\sigma^2} \\sum_{i} \\left(Q_{\\mathrm{exp},i} - Q_{\\mathrm{model}}(g_i;\\kappa,g_c)\\right)^2 = -\\frac{1}{2\\sigma^2} \\sum_{i} \\left(Q_{\\mathrm{exp},i} - \\kappa \\max(0, g_i - g_c)\\right)^2\n$$\n\nThe prior for the stiffness parameter $\\kappa$ is log-normal, with $\\ln \\kappa \\sim \\mathcal{N}(\\mu_\\kappa, \\sigma_\\kappa^2)$. The probability density function is $p(\\kappa) \\propto \\frac{1}{\\kappa} \\exp\\left(-\\frac{(\\ln\\kappa - \\mu_\\kappa)^2}{2\\sigma_\\kappa^2}\\right)$. The corresponding log-prior is:\n$$\n\\ln p(\\kappa) \\propto -\\ln\\kappa - \\frac{(\\ln\\kappa - \\mu_\\kappa)^2}{2\\sigma_\\kappa^2}\n$$\n\nThe prior for the critical gradient $g_c$ is a normal distribution truncated to $g_c > 0$, $p(g_c) \\propto \\exp\\left(-\\frac{(g_c - \\mu_{g_c})^2}{2\\tau_{g_c}^2}\\right)$ for $g_c > 0$. The normalization constant for the truncation does not depend on $g_c$ and can be absorbed into the posterior's overall normalization constant. The log-prior is simply the argument of the exponential:\n$$\n\\ln p(g_c) \\propto -\\frac{(g_c - \\mu_{g_c})^2}{2\\tau_{g_c}^2}\n$$\n\nCombining these, the unnormalized log-posterior $\\ln \\pi(\\kappa, g_c)$ is:\n$$\n\\ln \\pi(\\kappa, g_c) = -\\frac{1}{2\\sigma^2} \\sum_{i} \\left(Q_{\\mathrm{exp},i} - \\kappa \\max(0, g_i - g_c)\\right)^2 - \\frac{(\\ln\\kappa - \\mu_\\kappa)^2}{2\\sigma_\\kappa^2} - \\ln\\kappa - \\frac{(g_c - \\mu_{g_c})^2}{2\\tau_{g_c}^2}\n$$\n\nTo compute the posterior means $\\mathbb{E}[\\kappa \\mid D]$ and $\\mathbb{E}[g_c \\mid D]$, we must evaluate the following integrals over the specified parameter domain:\n$$\n\\mathbb{E}[\\kappa \\mid D] = \\frac{\\iint \\kappa \\, \\pi(\\kappa,g_c) \\,d\\kappa\\,dg_c}{\\iint \\pi(\\kappa,g_c) \\,d\\kappa\\,dg_c}, \\quad \\mathbb{E}[g_c \\mid D] = \\frac{\\iint g_c \\, \\pi(\\kappa,g_c) \\,d\\kappa\\,dg_c}{\\iint \\pi(\\kappa,g_c) \\,d\\kappa\\,dg_c}\n$$\nThese integrals are approximated numerically using a uniform grid. The specified parameter domain for $(\\kappa, g_c)$ is discretized into a grid of points $(\\kappa_j, g_{c,k})$. The unnormalized posterior $\\pi_{jk} = \\pi(\\kappa_j, g_{c,k})$ is computed at each grid point. For numerical stability, we compute $\\pi_{jk} = \\exp(\\ln \\pi_{jk} - \\max(\\ln \\pi))$ to prevent underflow/overflow. The integrals are then approximated as sums, and the expressions for the posterior means become weighted averages of the grid coordinates, with the posterior values as weights:\n$$\n\\mathbb{E}[\\kappa \\mid D] \\approx \\frac{\\sum_{j,k} \\kappa_j \\pi_{jk}}{\\sum_{j,k} \\pi_{jk}}, \\quad \\mathbb{E}[g_c \\mid D] \\approx \\frac{\\sum_{j,k} g_{c,k} \\pi_{jk}}{\\sum_{j,k} \\pi_{jk}}\n$$\n\nThe implementation will construct a $201 \\times 201$ grid for each test case, evaluate the log-posterior over this grid using vectorized NumPy operations for efficiency, exponentiate to get the unnormalized posterior, and finally compute the weighted averages to find the posterior means for $\\kappa$ and $g_c$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs Bayesian calibration for a plasma transport model and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (JET-like, supercritical gradients)\n        {\n            \"g\": np.array([5.0, 5.5, 6.0, 6.5]),\n            \"Q_exp\": np.array([0.39, 1.04, 1.69, 2.34]),\n            \"sigma\": 0.15,\n            \"mu_kappa\": 0.1, \"sigma_kappa\": 0.5,\n            \"mu_gc\": 4.5, \"tau_gc\": 0.4,\n            \"kappa_range\": (0.1, 3.0), \"gc_range\": (3.0, 6.0)\n        },\n        # Test case 2 (ITER-like, near-threshold)\n        {\n            \"g\": np.array([4.0, 4.2, 4.5, 4.7, 5.0]),\n            \"Q_exp\": np.array([0.0, 0.0, 0.0, 0.0, 0.3]),\n            \"sigma\": 0.1,\n            \"mu_kappa\": 0.3, \"sigma_kappa\": 0.4,\n            \"mu_gc\": 4.6, \"tau_gc\": 0.3,\n            \"kappa_range\": (0.1, 3.0), \"gc_range\": (3.0, 6.0)\n        },\n        # Test case 3 (edge case, subcritical gradients)\n        {\n            \"g\": np.array([3.0, 3.5, 3.8, 4.0]),\n            \"Q_exp\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"sigma\": 0.2,\n            \"mu_kappa\": 0.0, \"sigma_kappa\": 0.6,\n            \"mu_gc\": 4.8, \"tau_gc\": 0.6,\n            \"kappa_range\": (0.1, 3.0), \"gc_range\": (3.0, 6.0)\n        },\n        # Test case 4 (DEMO-like, stiff transport far above threshold)\n        {\n            \"g\": np.array([6.0, 7.0, 8.0]),\n            \"Q_exp\": np.array([3.0, 5.0, 7.0]),\n            \"sigma\": 0.2,\n            \"mu_kappa\": 0.5, \"sigma_kappa\": 0.3,\n            \"mu_gc\": 4.6, \"tau_gc\": 0.4,\n            \"kappa_range\": (0.1, 3.0), \"gc_range\": (3.0, 6.0)\n        }\n    ]\n\n    results = []\n    \n    # Grid resolution\n    N_GRID_POINTS = 201\n\n    for case in test_cases:\n        # Unpack case data\n        g_data = case[\"g\"]\n        Q_exp_data = case[\"Q_exp\"]\n        sigma = case[\"sigma\"]\n        mu_kappa, sigma_kappa = case[\"mu_kappa\"], case[\"sigma_kappa\"]\n        mu_gc, tau_gc = case[\"mu_gc\"], case[\"tau_gc\"]\n        kappa_min, kappa_max = case[\"kappa_range\"]\n        gc_min, gc_max = case[\"gc_range\"]\n\n        # 1. Create the parameter grid\n        kappa_ax = np.linspace(kappa_min, kappa_max, N_GRID_POINTS)\n        gc_ax = np.linspace(gc_min, gc_max, N_GRID_POINTS)\n        kappa_grid, gc_grid = np.meshgrid(kappa_ax, gc_ax, indexing='xy')\n\n        # 2. Calculate the log-likelihood\n        # Reshape data for broadcasting over the grid\n        # g_data_reshaped: (N_data, 1, 1)\n        # Q_exp_reshaped: (N_data, 1, 1)\n        # kappa_grid: (N_gc, N_kappa)\n        # gc_grid: (N_gc, N_kappa)\n        # NumPy's broadcasting rules will handle the shape differences\n        g_data_reshaped = g_data[:, np.newaxis, np.newaxis]\n        Q_exp_reshaped = Q_exp_data[:, np.newaxis, np.newaxis]\n\n        # Calculate Q_model over the grid for all data points\n        # The result Q_model will have shape (N_data, N_gc, N_kappa)\n        Q_model = kappa_grid * np.maximum(0, g_data_reshaped - gc_grid)\n        \n        # Calculate sum of squared residuals over the grid\n        sum_sq_residuals = np.sum((Q_exp_reshaped - Q_model)**2, axis=0)\n        \n        log_likelihood = -sum_sq_residuals / (2 * sigma**2)\n\n        # 3. Calculate log-priors\n        log_prior_kappa = -(np.log(kappa_grid) - mu_kappa)**2 / (2 * sigma_kappa**2) - np.log(kappa_grid)\n        log_prior_gc = -(gc_grid - mu_gc)**2 / (2 * tau_gc**2)\n\n        # 4. Calculate the total unnormalized log-posterior\n        log_posterior = log_likelihood + log_prior_kappa + log_prior_gc\n\n        # 5. Stabilize and compute posterior\n        log_posterior -= np.max(log_posterior)\n        posterior = np.exp(log_posterior)\n        \n        # 6. Compute posterior means via weighted average\n        # The sum of posterior values serves as the normalization constant\n        posterior_sum = np.sum(posterior)\n        \n        if posterior_sum > 0:\n            E_kappa = np.sum(kappa_grid * posterior) / posterior_sum\n            E_gc = np.sum(gc_grid * posterior) / posterior_sum\n        else:\n            # Handle case where posterior is zero everywhere (e.g., due to underflow)\n            E_kappa = np.nan\n            E_gc = np.nan\n\n        results.extend([E_kappa, E_gc])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}