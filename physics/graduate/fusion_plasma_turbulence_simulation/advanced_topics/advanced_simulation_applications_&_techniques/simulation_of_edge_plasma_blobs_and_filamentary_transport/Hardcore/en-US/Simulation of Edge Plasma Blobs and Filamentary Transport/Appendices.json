{
    "hands_on_practices": [
        {
            "introduction": "Before building complex simulations, it is crucial to understand the fundamental assumptions that make the model tractable. The drift-fluid description of plasma blobs is built on the idea of scale separation. This practice guides you through calculating the ion sound gyroradius, $\\rho_s$, a key microscopic length scale, and comparing it to the macroscopic gradient scale, $L_\\perp$. By evaluating the ordering parameter $\\epsilon = \\rho_s/L_\\perp$, you will gain a concrete understanding of when and why the powerful simplification of a 2D drift-fluid model is physically justified .",
            "id": "4200178",
            "problem": "A blob of edge plasma in a toroidal device is modeled under a strong magnetic field, with parameters $B=2\\,\\mathrm{T}$, $n=5\\times 10^{19}\\,\\mathrm{m^{-3}}$, $T_{e}=30\\,\\mathrm{eV}$, and perpendicular gradient scale $L_{\\perp}=2\\,\\mathrm{cm}$. Assume singly ionized deuterium ions with mass $m_{i}$ and charge $q_{i}=+e$; electrons are isothermal with temperature $T_{e}$ and the plasma is quasineutral. The Two-Dimensional (2D) drift-fluid description relies on an ordering small parameter $\\epsilon$ defined by the ratio of a characteristic perpendicular micro-scale to the macroscopic gradient scale.\n\nStarting from the ion equation of motion under the Lorentz force and the isothermal electron momentum balance (neglecting electron inertia), derive expressions for the ion cyclotron frequency and the ion-acoustic speed, and hence obtain the ion sound gyroradius $\\rho_{s}$ defined as the ratio of the ion-acoustic speed to the ion cyclotron frequency. Using these results, construct the ordering parameter $\\epsilon=\\rho_{s}/L_{\\perp}$.\n\nThen, using the given parameters, evaluate the numerical values of $\\rho_{s}$ and $\\epsilon$. Round your numerical answers to four significant figures. Express $\\rho_{s}$ in $\\mathrm{m}$ and $\\epsilon$ as a dimensionless number. Provide your final numerical answers as a row matrix in the order $\\left[\\rho_{s},\\,\\epsilon\\right]$.\n\nFinally, based on first-principles scale separation, discuss whether the 2D drift-fluid description is valid for this edge parameter set and justify your conclusion in terms of the magnitude of $\\epsilon$ and the implied separation of dynamical timescales. Your discussion does not need to include additional numerical calculations beyond those already requested.",
            "solution": "The objective is to compute the ion sound gyroradius $\\rho_{s}$ and the ordering parameter $\\epsilon=\\rho_{s}/L_{\\perp}$ from first principles.\n\nWe begin with the ion equation of motion under the Lorentz force,\n$$\nm_{i}\\,\\frac{d\\boldsymbol{v}_{i}}{dt} = q_{i}\\,\\boldsymbol{v}_{i}\\times \\boldsymbol{B} + q_{i}\\,\\boldsymbol{E} - \\nabla p_{i},\n$$\nand the electron momentum balance neglecting electron inertia,\n$$\n0 = - e\\,n\\,\\boldsymbol{E} - \\nabla p_{e}.\n$$\nFor isothermal electrons with $p_{e} = n k_{B} T_{e}$, the electron balance immediately yields\n$$\n\\boldsymbol{E} = -\\frac{1}{e n}\\,\\nabla p_{e} = -\\frac{k_{B} T_{e}}{e}\\,\\nabla\\ln n.\n$$\nThe ion cyclotron frequency follows from uniform circular motion under the magnetic part of the Lorentz force, projecting along the plane perpendicular to $\\boldsymbol{B}$. Setting $\\boldsymbol{E}=\\boldsymbol{0}$ and neglecting pressure for the gyromotion,\n$$\nm_{i}\\,\\frac{d\\boldsymbol{v}_{\\perp}}{dt} = q_{i}\\,\\boldsymbol{v}_{\\perp}\\times \\boldsymbol{B},\n$$\nwhich gives the cyclotron frequency magnitude\n$$\n\\Omega_{i} = \\frac{q_{i} B}{m_{i}} = \\frac{e B}{m_{i}}.\n$$\n\nThe ion-acoustic speed is obtained from the compressive dynamics along the magnetic field lines by combining the ion continuity and parallel momentum equations with the isothermal electron equation of state. In one dimension for a small-amplitude disturbance and cold ions (neglecting ion pressure), the linearized system becomes\n$$\n\\partial_{t} n_{1} + n_{0}\\,\\partial_{x} u_{i1} = 0, \\qquad m_{i}\\,\\partial_{t} u_{i1} = -\\frac{1}{n_{0}}\\,\\partial_{x} p_{e1},\n$$\nwith $p_{e1} = k_{B} T_{e}\\,n_{1}$ and quasineutrality $n_{e1}\\approx n_{i1}\\equiv n_{1}$. Eliminating $u_{i1}$ yields a wave equation $\\partial_{t}^{2} n_{1} = c_{s}^{2}\\,\\partial_{x}^{2} n_{1}$ with the ion-acoustic speed\n$$\nc_{s} = \\sqrt{\\frac{k_{B} T_{e}}{m_{i}}}.\n$$\nSince $T_{e}$ is specified in electronvolts, we use $k_{B} T_{e} = e\\,T_{e}$, giving\n$$\nc_{s} = \\sqrt{\\frac{e\\,T_{e}}{m_{i}}}.\n$$\n\nBy definition, the ion sound gyroradius is the ratio of the ion-acoustic speed to the ion cyclotron frequency,\n$$\n\\rho_{s} \\equiv \\frac{c_{s}}{\\Omega_{i}} = \\frac{\\sqrt{e\\,T_{e}/m_{i}}}{e B/m_{i}} = \\frac{\\sqrt{m_{i}\\,e\\,T_{e}}}{e\\,B}.\n$$\nThe ordering parameter is\n$$\n\\epsilon = \\frac{\\rho_{s}}{L_{\\perp}}.\n$$\n\nWe now evaluate the numerical values with the given parameters. Let the singly ionized deuterium ion mass be $m_{i} = 2\\,m_{p}$, where $m_{p}$ is the proton mass, and $q_{i}=e$ is the elementary charge. Using the standard values $e = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$, $m_{p} = 1.67262192369\\times 10^{-27}\\,\\mathrm{kg}$, we have\n$$\nm_{i} = 2\\,m_{p} = 3.34524384738\\times 10^{-27}\\,\\mathrm{kg}.\n$$\nWith $T_{e}=30\\,\\mathrm{eV}$, $B=2\\,\\mathrm{T}$, and $L_{\\perp} = 2\\,\\mathrm{cm} = 2.0\\times 10^{-2}\\,\\mathrm{m}$, we compute\n$$\nc_{s} = \\sqrt{\\frac{e T_{e}}{m_{i}}} = \\sqrt{\\frac{1.602176634\\times 10^{-19}\\times 30}{3.34524384738\\times 10^{-27}}} \\approx 3.7902\\times 10^{4}\\,\\mathrm{m/s},\n$$\n$$\n\\Omega_{i} = \\frac{e B}{m_{i}} = \\frac{1.602176634\\times 10^{-19}\\times 2}{3.34524384738\\times 10^{-27}} \\approx 9.5788\\times 10^{7}\\,\\mathrm{rad/s}.\n$$\nTherefore,\n$$\n\\rho_{s} = \\frac{c_{s}}{\\Omega_{i}} \\approx \\frac{3.7902\\times 10^{4}}{9.5788\\times 10^{7}} \\approx 3.957\\times 10^{-4}\\,\\mathrm{m},\n$$\nand\n$$\n\\epsilon = \\frac{\\rho_{s}}{L_{\\perp}} = \\frac{3.957\\times 10^{-4}}{2.0\\times 10^{-2}} \\approx 1.979\\times 10^{-2}.\n$$\nRounded to four significant figures, these are the requested values.\n\nFinally, we discuss the validity of the Two-Dimensional (2D) drift-fluid description. The drift-fluid model is based on an asymptotic expansion in a small parameter that measures the ratio of microscopic gyroradius scales to macroscopic gradient scales, together with a separation of timescales between the slow drift/interchange dynamics and the fast gyromotion. The small parameter here is $\\epsilon = \\rho_{s}/L_{\\perp}$. With $\\epsilon \\approx 1.979\\times 10^{-2}$, we have $\\epsilon \\ll 1$, indicating:\n- Length-scale separation: $\\,\\rho_{s} \\ll L_{\\perp}$, so perpendicular gradients are smooth on the ion sound gyroradius and drift ordering is appropriate.\n- Timescale separation: the characteristic perpendicular advective frequency $\\,\\omega_{\\perp}\\sim c_{s}/L_{\\perp}\\,$ is smaller than the ion cyclotron frequency by the same ratio, $\\,\\omega_{\\perp}/\\Omega_{i} = \\epsilon \\ll 1\\,$, justifying drift reduction and the neglect of gyrophase-resolved dynamics.\n\nUnder these conditions, a 2D drift-fluid description of interchange-like blob motion in the edge is consistent to leading order. Caveats are that parallel dynamics (e.g., sheath losses along field lines), finite collisionality, and electromagnetic effects can become significant depending on connection length, resistivity, and $\\beta$; however, none of these invalidate the 2D electrostatic drift-fluid approximation when the dominant ordering parameter remains small and parallel variations are weak relative to perpendicular ones. Thus, for the given parameter set, the 2D drift-fluid description is valid within its standard asymptotic regime controlled by $\\epsilon\\ll 1$, with the computed $\\epsilon$ providing quantitative justification.",
            "answer": "$$\\boxed{\\begin{pmatrix}3.957 \\times 10^{-4} & 1.979 \\times 10^{-2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "The heart of simulating plasma blob dynamics lies in solving the vorticity evolution equation, which captures how blobs are driven by curvature and how they move. This exercise translates the continuous physics into a working numerical implementation. You will implement a discrete version of the 2D vorticity equation, $\\partial_t \\Omega = \\{\\phi, \\Omega\\} + \\kappa \\partial_y n - \\nu \\Omega$, using finite differences on a periodic grid. This hands-on coding practice will solidify your understanding of how core physical processes like $\\mathbf{E} \\times \\mathbf{B}$ advection and the interchange instability are represented and computed in a simulation code .",
            "id": "4200180",
            "problem": "You are tasked with implementing a two-dimensional discrete computation of the interchange-driven vorticity dynamics for a cold-ion, isothermal-electron blob in a slab geometry. The goal is to compute the time derivative of the vorticity field, denoted by $\\partial_t \\Omega$, on a uniform periodic Cartesian grid using a simplified, yet scientifically consistent, model.\n\nThe physical and mathematical setting is as follows.\n\n- Geometry and normalization: Assume a slab plasma aligned with a uniform magnetic field $\\mathbf{B} = B \\hat{\\mathbf{z}}$ and use electrostatic, drift-reduced, two-dimensional dynamics in the plane perpendicular to $\\mathbf{B}$. All quantities are normalized to Bohm units, that is, lengths to the ion-sound gyroradius $\\rho_s$, time to the inverse ion cyclotron frequency, and potentials to thermal energy $T_e/e$. Therefore, all fields are dimensionless.\n\n- Fields: The simulation fields are the density $n(x,y)$, the electrostatic potential $\\phi(x,y)$, and the vorticity $\\Omega(x,y)$. The vorticity is defined by the polarization closure $\\Omega = \\nabla_\\perp^2 \\phi$, where $\\nabla_\\perp^2 = \\partial_x^2 + \\partial_y^2$ is the perpendicular Laplacian.\n\n- Electron thermodynamics: Electrons are isothermal, and the pressure is $p(x,y) = n(x,y)$ in normalized units.\n\n- Dynamics: The perpendicular fluid velocity is the cross-field (Electric field cross Magnetic field) drift $\\mathbf{v}_E = \\hat{\\mathbf{z}} \\times \\nabla \\phi$. The interchange curvature drive enters through a curvature operator acting on pressure, modeled as $\\mathcal{K}(p) = \\kappa \\,\\partial_y p$, where $\\kappa$ is a constant curvature parameter. A linear viscous damping term $-\\nu \\Omega$ models dissipative sinks.\n\n- Objective: Starting from these foundations, derive the expression for $\\partial_t \\Omega$ in terms of the fields $n$ and $\\phi$, their spatial derivatives, the curvature operator acting on $p$, and damping. Then implement a discrete computation of $\\partial_t \\Omega$ on a uniform periodic grid using second-order centered finite differences for spatial derivatives.\n\n- Discrete operators and boundary conditions:\n  1. Use a rectangular domain of size $L_x \\times L_y$ discretized by $N_x \\times N_y$ points with uniform spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$.\n  2. Implement periodic boundary conditions in both directions for all discrete spatial derivatives.\n  3. Compute gradients using second-order centered differences with periodic wrapping. For a field $f$, define $\\partial_x f$ and $\\partial_y f$ accordingly.\n  4. Compute the perpendicular Laplacian $\\nabla_\\perp^2 f$ using second-order centered differences with periodic wrapping.\n  5. Compute the Poisson bracket (nonlinear advection) $\\{\\phi, \\Omega\\} = \\partial_x \\phi \\, \\partial_y \\Omega - \\partial_y \\phi \\, \\partial_x \\Omega$ using the discrete gradients above.\n\n- Required final quantity: For each test case described below, compute the discrete field $\\partial_t \\Omega(x,y)$ at the initial time and report its domain-wide root mean square (RMS) magnitude, defined as\n  $$\\mathrm{RMS}(\\partial_t \\Omega) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} \\left( \\partial_t \\Omega_{i,j} \\right)^2 }.$$\n\n- Units for the answer: All quantities are dimensionless. Report each RMS as a floating-point number.\n\n- Test suite and parameter specification:\n  Implement the computation for the following four test cases. For each case, construct the fields $n(x,y)$ and $\\phi(x,y)$ on the grid and compute $\\partial_t \\Omega$ and its RMS as specified.\n\n  Common grid parameters for all cases:\n  - Domain sizes: $L_x = 40$, $L_y = 40$.\n  - Grid resolution: $N_x = 64$, $N_y = 64$.\n\n  Case $1$ (general blob with curvature and weak damping):\n  - Curvature parameter: $\\kappa = 0.02$.\n  - Damping parameter: $\\nu = 0.005$.\n  - Blob parameters: $A = 1.0$, $\\sigma = 5.0$, $x_0 = L_x/2$, $y_0 = L_y/2$.\n  - Fields: $\\phi(x,y) = A \\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{\\sigma^2}\\right)$, and $n(x,y) = \\phi(x,y)$.\n\n  Case $2$ (uniform zero fields):\n  - Curvature parameter: $\\kappa = 0.02$.\n  - Damping parameter: $\\nu = 0.005$.\n  - Fields: $\\phi(x,y) = 0$ and $n(x,y) = 0$ everywhere.\n\n  Case $3$ (curvature-only drive with sinusoidal density, no potential):\n  - Curvature parameter: $\\kappa = 0.05$.\n  - Damping parameter: $\\nu = 0.0$.\n  - Fields: $\\phi(x,y) = 0$ everywhere, and $n(x,y) = 1.0 + \\sin\\left(\\frac{2\\pi y}{L_y}\\right)$.\n\n  Case $4$ (general blob with strong damping):\n  - Curvature parameter: $\\kappa = 0.02$.\n  - Damping parameter: $\\nu = 0.5$.\n  - Blob parameters: $A = 1.0$, $\\sigma = 5.0$, $x_0 = L_x/2$, $y_0 = L_y/2$.\n  - Fields: $\\phi(x,y) = A \\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{\\sigma^2}\\right)$, and $n(x,y) = \\phi(x,y)$.\n\n- Final output format: Your program should produce a single line of output containing the four RMS values as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$). Each RMS value must be a floating-point number.\n\nThe problem requires you to begin from the physical and mathematical foundations listed above, derive the discrete expression for $\\partial_t \\Omega$ that accounts for the nonlinear advection by $\\mathbf{v}_E$, the curvature drive $\\mathcal{K}(p)$, and the damping term, and then implement it numerically for the specified test suite. The use of dimensionless units must be maintained throughout, and periodic boundary conditions must be applied in both directions when computing spatial derivatives. The final output must adhere strictly to the specified single-line format, with the results in order for cases $1$ through $4$.",
            "solution": "The problem statement has been validated and is determined to be scientifically grounded, well-posed, and complete. We can therefore proceed with the derivation and solution.\n\nThe objective is to compute the time derivative of the vorticity field, $\\partial_t \\Omega$, for a simplified model of interchange-driven plasma turbulence. The model is defined in a two-dimensional slab geometry perpendicular to a uniform magnetic field $\\mathbf{B}$. All quantities are dimensionless, expressed in Bohm-normalized units.\n\nThe governing equation for the evolution of vorticity, $\\Omega$, in this system can be derived from fundamental plasma fluid equations, but for the scope of this problem, we start from the standard reduced vorticity equation that incorporates the specified physical effects. This equation describes how the vorticity at a point changes in time due to advection, curvature-driven interchange instability, and dissipation.\n\nThe total time derivative of vorticity, also known as the material derivative, is given by:\n$$\n\\frac{d\\Omega}{dt} = \\frac{\\partial \\Omega}{\\partial t} + (\\mathbf{v}_E \\cdot \\nabla) \\Omega\n$$\nHere, $\\frac{\\partial \\Omega}{\\partial t}$ is the local time derivative we aim to compute, and $(\\mathbf{v}_E \\cdot \\nabla) \\Omega$ is the advective derivative, which represents the transport of vorticity by the fluid flow. The fluid velocity is the $\\mathbf{E} \\times \\mathbf{B}$ drift, given in normalized units by $\\mathbf{v}_E = \\hat{\\mathbf{z}} \\times \\nabla \\phi$. Explicitly, with $\\nabla \\phi = (\\partial_x \\phi)\\hat{\\mathbf{x}} + (\\partial_y \\phi)\\hat{\\mathbf{y}}$, the velocity components are $v_x = \\partial_y \\phi$ and $v_y = -\\partial_x \\phi$. The advection term is thus:\n$$\n(\\mathbf{v}_E \\cdot \\nabla) \\Omega = v_x \\frac{\\partial \\Omega}{\\partial x} + v_y \\frac{\\partial \\Omega}{\\partial y} = (\\partial_y \\phi)(\\partial_x \\Omega) - (\\partial_x \\phi)(\\partial_y \\Omega)\n$$\nThe problem defines the Poisson bracket as $\\{\\phi, \\Omega\\} = \\partial_x \\phi \\, \\partial_y \\Omega - \\partial_y \\phi \\, \\partial_x \\Omega$. Comparing these, we find that $(\\mathbf{v}_E \\cdot \\nabla) \\Omega = -\\{\\phi, \\Omega\\}$.\n\nThe vorticity evolution equation balances this material derivative against source and sink terms. The problem specifies two such terms:\n$1$. A source term due to the interchange drive, modeled by a curvature operator $\\mathcal{K}(p)$ acting on the pressure $p$. With $p=n$ (isothermal electrons) and $\\mathcal{K}(p) = \\kappa \\, \\partial_y p$, this term is $\\kappa \\, \\partial_y n$.\n$2$. A sink term representing viscous dissipation, modeled as a linear damping $-\\nu \\Omega$.\n\nCombining these elements, the vorticity evolution equation is:\n$$\n\\frac{d\\Omega}{dt} = \\kappa \\, \\partial_y n - \\nu \\Omega\n$$\nSubstituting the expansion of the material derivative:\n$$\n\\frac{\\partial \\Omega}{\\partial t} + (\\mathbf{v}_E \\cdot \\nabla) \\Omega = \\kappa \\, \\partial_y n - \\nu \\Omega\n$$\nUsing the relation $(\\mathbf{v}_E \\cdot \\nabla) \\Omega = -\\{\\phi, \\Omega\\}$:\n$$\n\\frac{\\partial \\Omega}{\\partial t} - \\{\\phi, \\Omega\\} = \\kappa \\, \\partial_y n - \\nu \\Omega\n$$\nSolving for the local time derivative $\\partial_t \\Omega$ yields the final continuous equation to be implemented:\n$$\n\\partial_t \\Omega = \\{\\phi, \\Omega\\} + \\kappa \\, \\partial_y n - \\nu \\Omega\n$$\nThe vorticity $\\Omega$ itself is not an independent field but is defined via the polarization closure relation $\\Omega = \\nabla_\\perp^2 \\phi$.\n\nNext, we discretize this equation on a uniform Cartesian grid of size $L_x \\times L_y$ with $N_x \\times N_y$ points. The grid spacings are $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. A field $f(x,y)$ is represented by its values $f_{i,j}$ at grid points $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$.\n\nWe use second-order centered finite differences for all spatial derivatives, implementing periodic boundary conditions. For a field $f_{i,j}$:\nThe partial derivative with respect to $x$ is:\n$$\n(\\partial_x f)_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2\\Delta x}\n$$\nThe partial derivative with respect to $y$ is:\n$$\n(\\partial_y f)_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta y}\n$$\nThe perpendicular Laplacian $\\nabla_\\perp^2 = \\partial_x^2 + \\partial_y^2$ is:\n$$\n(\\nabla_\\perp^2 f)_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta x)^2} + \\frac{f_{i,j+1} - 2f_{i,j} + f_{i-1,j}}{(\\Delta y)^2}\n$$\nPeriodicity is enforced by wrapping indices, e.g., $f_{N_x,j} = f_{0,j}$ and $f_{-1,j} = f_{N_x-1,j}$.\n\nThe computational algorithm proceeds as follows:\n$1$. For each test case, define the parameters and construct the discrete initial fields $\\phi_{i,j}$ and $n_{i,j}$ on the $N_x \\times N_y$ grid.\n$2$. Compute the discrete vorticity field $\\Omega_{i,j}$ using the finite-difference Laplacian operator: $\\Omega_{i,j} = (\\nabla_\\perp^2 \\phi)_{i,j}$.\n$3$. Compute the necessary first-order spatial derivatives using the finite-difference gradient operators: $(\\partial_x\\phi)_{i,j}$, $(\\partial_y\\phi)_{i,j}$, $(\\partial_x\\Omega)_{i,j}$, $(\\partial_y\\Omega)_{i,j}$, and $(\\partial_y n)_{i,j}$.\n$4$. Assemble the discrete time derivative of vorticity, $(\\partial_t \\Omega)_{i,j}$, for each grid point $(i,j)$:\n$$\n(\\partial_t \\Omega)_{i,j} = \\left( (\\partial_x \\phi)_{i,j} (\\partial_y \\Omega)_{i,j} - (\\partial_y \\phi)_{i,j} (\\partial_x \\Omega)_{i,j} \\right) + \\kappa (\\partial_y n)_{i,j} - \\nu \\Omega_{i,j}\n$$\n$5$. Calculate the root mean square (RMS) magnitude of the resulting $(\\partial_t \\Omega)_{i,j}$ field over the entire domain:\n$$\n\\mathrm{RMS}(\\partial_t \\Omega) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} \\left( (\\partial_t \\Omega)_{i,j} \\right)^2 }\n$$\nThis procedure is applied to each of the four specified test cases to obtain the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the RMS of the time derivative of vorticity for four test cases\n    based on a simplified model of plasma interchange turbulence.\n    \"\"\"\n\n    # Common grid parameters for all cases\n    Lx, Ly = 40.0, 40.0\n    Nx, Ny = 64, 64\n    dx, dy = Lx / Nx, Ly / Ny\n\n    # Test suite and parameter specification\n    test_cases = [\n        # Case 1: General blob with curvature and weak damping\n        {'kappa': 0.02, 'nu': 0.005, 'case_type': 'gaussian_blob', 'A': 1.0, 'sigma': 5.0},\n        # Case 2: Uniform zero fields\n        {'kappa': 0.02, 'nu': 0.005, 'case_type': 'zero_fields'},\n        # Case 3: Curvature-only drive with sinusoidal density\n        {'kappa': 0.05, 'nu': 0.0, 'case_type': 'sinusoidal_density'},\n        # Case 4: General blob with strong damping\n        {'kappa': 0.02, 'nu': 0.5, 'case_type': 'gaussian_blob', 'A': 1.0, 'sigma': 5.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        # 1. Set up grid\n        x = np.linspace(0, Lx, Nx, endpoint=False)\n        y = np.linspace(0, Ly, Ny, endpoint=False)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        # 2. Define finite difference operators with periodic boundaries\n        def grad_x(f):\n            return (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2 * dx)\n\n        def grad_y(f):\n            return (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2 * dy)\n\n        def laplacian(f):\n            d2f_dx2 = (np.roll(f, -1, axis=0) - 2 * f + np.roll(f, 1, axis=0)) / (dx**2)\n            d2f_dy2 = (np.roll(f, -1, axis=1) - 2 * f + np.roll(f, 1, axis=1)) / (dy**2)\n            return d2f_dx2 + d2f_dy2\n\n        # 3. Construct initial fields n(x,y) and phi(x,y)\n        phi = np.zeros((Nx, Ny))\n        n = np.zeros((Nx, Ny))\n        case_type = params['case_type']\n\n        if case_type == 'gaussian_blob':\n            A = params['A']\n            sigma = params['sigma']\n            x0, y0 = Lx / 2, Ly / 2\n            blob = A * np.exp(-((X - x0)**2 + (Y - y0)**2) / sigma**2)\n            phi = blob\n            n = blob\n        elif case_type == 'zero_fields':\n            # Fields are already initialized to zero\n            pass\n        elif case_type == 'sinusoidal_density':\n            phi = np.zeros((Nx, Ny))\n            n = 1.0 + np.sin(2 * np.pi * Y / Ly)\n\n        # 4. Compute d(Omega)/dt\n        kappa = params['kappa']\n        nu = params['nu']\n\n        # Compute vorticity Omega = laplacian(phi)\n        Omega = laplacian(phi)\n\n        # Compute terms for the Poisson bracket {phi, Omega}\n        dphi_dx = grad_x(phi)\n        dphi_dy = grad_y(phi)\n        dOmega_dx = grad_x(Omega)\n        dOmega_dy = grad_y(Omega)\n        poisson_bracket = dphi_dx * dOmega_dy - dphi_dy * dOmega_dx\n\n        # Compute curvature drive term\n        dn_dy = grad_y(n)\n        curvature_term = kappa * dn_dy\n\n        # Compute damping term\n        damping_term = -nu * Omega\n\n        # Assemble the time derivative of vorticity\n        dOmega_dt = poisson_bracket + curvature_term + damping_term\n\n        # 5. Calculate the domain-wide RMS magnitude\n        rms_val = np.sqrt(np.mean(dOmega_dt**2))\n        results.append(rms_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While 2D models are insightful, real blobs have a finite extent along the magnetic field and interact with material surfaces. This interaction is mediated by sheaths, which impose specific boundary conditions that profoundly affect blob stability and transport. This exercise explores how sheath physics at the ends of a flux tube dictates the allowed parallel structure of plasma fluctuations. By deriving and solving for the quantized parallel wavenumbers, $k_\\parallel$, you will learn how to incorporate realistic sheath boundary conditions into a simulation model, a critical step toward building predictive flux-tube simulations .",
            "id": "4200239",
            "problem": "Consider a simplified flux-tube model for edge plasma blobs and filamentary transport in a magnetically confined fusion device. Let the local orthonormal coordinates be $(x,y,z)$ where $z$ is the coordinate along the magnetic field line, and $y$ is the binormal direction. Assume electrostatic fluctuations with scalar potential $\\phi(y,z)$ and a reduced parallel closure with uniform parallel electrical conductivity $\\sigma_\\parallel$. Impose periodic boundary conditions in $y$ and linearized sheath boundary conditions at the two parallel ends at $z=\\pm L_\\parallel/2$.\n\nFundamental base:\n- Use the parallel current closure from generalized Ohm's law in the resistive limit $E_\\parallel=\\eta\\,j_\\parallel$ with $\\eta=1/\\sigma_\\parallel$ and $E_\\parallel=-\\partial\\phi/\\partial z$, so that\n$$\nj_\\parallel(z)=-\\sigma_\\parallel\\,\\frac{\\partial\\phi}{\\partial z}(z).\n$$\n- Use the linearized Bohm sheath current for isothermal electrons, stating that the net parallel current density entering the sheath is proportional to the electrostatic potential at the sheath entrance,\n$$\nj_s(z=\\pm L_\\parallel/2)=\\pm \\frac{n_0 e^2 c_s}{T_e}\\,\\phi\\big|_{z=\\pm L_\\parallel/2},\n$$\nwhere $n_0$ is the background density, $e$ is the elementary charge, $c_s$ is the ion acoustic speed, and $T_e$ is the electron temperature expressed in joules. If $T_e$ is provided in electron volts, use $T_e[\\mathrm{J}]=e\\,T_e[\\mathrm{eV}]$.\n\nBy equating the parallel current to the sheath current at the ends, derive a Robin boundary condition for $\\phi$ at $z=\\pm L_\\parallel/2$,\n$$\n\\frac{\\partial\\phi}{\\partial z}\\Big|_{z=+L_\\parallel/2}=-\\lambda\\,\\phi\\Big|_{z=+L_\\parallel/2},\\quad\n\\frac{\\partial\\phi}{\\partial z}\\Big|_{z=-L_\\parallel/2}=+\\lambda\\,\\phi\\Big|_{z=-L_\\parallel/2},\n$$\nwith the sheath admittance parameter\n$$\n\\lambda=\\frac{n_0 e^2 c_s}{T_e\\,\\sigma_\\parallel}=\\frac{n_0 e c_s}{T_e[\\mathrm{eV}]\\,\\sigma_\\parallel}.\n$$\n\nAssume separated-variable parallel eigenmodes solving the one-dimensional Helmholtz problem along the field:\n$$\n\\frac{d^2\\phi}{dz^2}+k_\\parallel^2\\,\\phi=0\\quad\\text{for}\\quad z\\in\\left[-\\frac{L_\\parallel}{2},\\,+\\frac{L_\\parallel}{2}\\right]\n$$\nsubject to the above Robin boundary conditions at $z=\\pm L_\\parallel/2$. Show that the allowed parallel wavenumbers $k_\\parallel$ satisfy two transcendental families,\n$$\n\\text{even modes:}\\quad k_\\parallel\\,\\tan\\!\\left(k_\\parallel\\,\\frac{L_\\parallel}{2}\\right)=\\lambda,\n$$\n$$\n\\text{odd modes:}\\quad -k_\\parallel\\,\\cot\\!\\left(k_\\parallel\\,\\frac{L_\\parallel}{2}\\right)=\\lambda.\n$$\nIn the $y$-direction, periodic boundary conditions on a domain of length $L_y$ imply discrete binormal wavenumbers\n$$\nk_y=\\frac{2\\pi m}{L_y},\\quad m\\in\\mathbb{Z}.\n$$\nAlthough $k_y$ does not directly enter the parallel quantization above, implement its periodicity in your program design.\n\nTask:\n- Starting from the fundamental base above, derive the quantization conditions for $k_\\parallel$ and design an algorithm to numerically compute the first $N$ smallest positive allowed $k_\\parallel$ values (in $\\mathrm{m}^{-1}$), obtained by solving the transcendental equations for even and odd families, and then merging and sorting them.\n- Your program must compute these values for each parameter set in the test suite and output a single line containing the aggregated results.\n\nUnits and output requirements:\n- All physical inputs must be treated with standard International System of Units (SI); use $T_e$ in electron volts and convert internally to joules via $T_e[\\mathrm{J}]=e\\,T_e[\\mathrm{eV}]$ with $e$ in coulombs.\n- Express each $k_\\parallel$ in $\\mathrm{m}^{-1}$ as floating-point numbers.\n- The final output format must be one single line: a comma-separated Python-style list of lists of floats, one inner list per test case, enclosed in square brackets. For example: $[\\,[k_1,k_2,\\dots],\\,[\\dots],\\,[\\dots]\\,]$.\n\nTest suite:\nUse the following three scientifically plausible parameter sets to test different regimes of sheath admittance:\n1. Case A (near-Neumann sheath, small $\\lambda$): $L_\\parallel=20\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, $n_0=1.0\\times 10^{19}\\,\\mathrm{m}^{-3}$, $T_e=20\\,\\mathrm{eV}$, $c_s=2.0\\times 10^{4}\\,\\mathrm{m/s}$, $\\sigma_\\parallel=1.0\\times 10^{7}\\,\\mathrm{S/m}$, $N=4$.\n2. Case B (intermediate sheath admittance): $L_\\parallel=20\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, $n_0=1.0\\times 10^{19}\\,\\mathrm{m}^{-3}$, $T_e=20\\,\\mathrm{eV}$, $c_s=2.0\\times 10^{4}\\,\\mathrm{m/s}$, $\\sigma_\\parallel=1.0\\times 10^{4}\\,\\mathrm{S/m}$, $N=4$.\n3. Case C (strong sheath, large $\\lambda$): $L_\\parallel=20\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, $n_0=1.0\\times 10^{19}\\,\\mathrm{m}^{-3}$, $T_e=20\\,\\mathrm{eV}$, $c_s=2.0\\times 10^{4}\\,\\mathrm{m/s}$, $\\sigma_\\parallel=1.0\\times 10^{2}\\,\\mathrm{S/m}$, $N=4$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case's $N$ smallest positive $k_\\parallel$ values (in $\\mathrm{m}^{-1}$) as an inner list, ordered ascending. For example: $[[k_{\\parallel,1},k_{\\parallel,2},k_{\\parallel,3},k_{\\parallel,4}],[\\dots],[\\dots]]$.",
            "solution": "The problem statement has been critically evaluated and is determined to be valid. It is scientifically grounded in a simplified but standard model of plasma-sheath interaction, is well-posed, objective, and self-contained. All necessary parameters and physical laws are provided to formulate and solve the problem.\n\nThe task is to find the first $N$ smallest positive parallel wavenumbers, $k_\\parallel$, that satisfy a set of boundary conditions in a simplified model of plasma transport along a magnetic field line of length $L_\\parallel$. The governing equation for the electrostatic potential $\\phi(z)$ is the one-dimensional Helmholtz equation:\n$$\n\\frac{d^2\\phi}{dz^2} + k_\\parallel^2\\,\\phi = 0, \\quad z \\in \\left[-\\frac{L_\\parallel}{2}, +\\frac{L_\\parallel}{2}\\right]\n$$\nThe problem states that the parallel current, $j_\\parallel = -\\sigma_\\parallel \\frac{\\partial\\phi}{\\partial z}$, must match the current collected by the material sheaths at the ends, $j_s = \\pm \\frac{n_0 e c_s}{T_e[\\mathrm{eV}]} \\phi$, where the $\\pm$ signs correspond to $z=\\pm L_\\parallel/2$. Equating these currents yields Robin boundary conditions:\n$$\n\\frac{\\partial\\phi}{\\partial z}\\Big|_{z=+L_\\parallel/2} = -\\lambda\\,\\phi\\Big|_{z=+L_\\parallel/2}\n$$\n$$\n\\frac{\\partial\\phi}{\\partial z}\\Big|_{z=-L_\\parallel/2} = +\\lambda\\,\\phi\\Big|_{z=-L_\\parallel/2}\n$$\nwith the sheath admittance parameter $\\lambda = \\frac{n_0 e c_s}{T_e[\\mathrm{eV}]\\,\\sigma_\\parallel}$.\n\nTo derive the quantization conditions for $k_\\parallel$, we start with the general solution to the Helmholtz equation, which can be expressed as a superposition of even and odd functions:\n$$\n\\phi(z) = A \\cos(k_\\parallel z) + B \\sin(k_\\parallel z)\n$$\nwhere $A$ and $B$ are constants. The derivative is:\n$$\n\\frac{d\\phi}{dz}(z) = -A k_\\parallel \\sin(k_\\parallel z) + B k_\\parallel \\cos(k_\\parallel z)\n$$\nApplying the two boundary conditions yields a system of two linear equations for $A$ and $B$:\n$1$. At $z = +L_\\parallel/2$:\n$$\n-A k_\\parallel \\sin\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) + B k_\\parallel \\cos\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) = -\\lambda \\left[A \\cos\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) + B \\sin\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right)\\right]\n$$\n$2$. At $z = -L_\\parallel/2$:\n$$\n-A k_\\parallel \\sin\\left(-k_\\parallel \\frac{L_\\parallel}{2}\\right) + B k_\\parallel \\cos\\left(-k_\\parallel \\frac{L_\\parallel}{2}\\right) = \\lambda \\left[A \\cos\\left(-k_\\parallel \\frac{L_\\parallel}{2}\\right) + B \\sin\\left(-k_\\parallel \\frac{L_\\parallel}{2}\\right)\\right]\n$$\nUsing the properties $\\sin(-x) = -\\sin(x)$ and $\\cos(-x) = \\cos(x)$, the second equation simplifies to:\n$$\nA k_\\parallel \\sin\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) + B k_\\parallel \\cos\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) = \\lambda \\left[A \\cos\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) - B \\sin\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right)\\right]\n$$\nThis system can be decoupled by considering even and odd solutions separately.\n\nFor even modes, we have $\\phi(-z) = \\phi(z)$, which requires $B=0$. The solution is $\\phi(z) = A \\cos(k_\\parallel z)$. Substituting $B=0$ into either boundary condition equation (they become identical) gives, for a non-trivial solution ($A \\neq 0$):\n$$\n-A k_\\parallel \\sin\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) = -\\lambda A \\cos\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right)\n$$\n$$\nk_\\parallel \\tan\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) = \\lambda\n$$\nThis is the transcendental equation for the even family of modes.\n\nFor odd modes, we have $\\phi(-z) = -\\phi(z)$, which requires $A=0$. The solution is $\\phi(z) = B \\sin(k_\\parallel z)$. Substituting $A=0$ into either boundary condition equation gives, for a non-trivial solution ($B \\neq 0$):\n$$\nB k_\\parallel \\cos\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) = -\\lambda B \\sin\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right)\n$$\n$$\nk_\\parallel \\cot\\left(k_\\parallel \\frac{L_\\parallel}{2}\\right) = -\\lambda\n$$\nThis is equivalent to $-k_\\parallel \\cot(k_\\parallel \\frac{L_\\parallel}{2}) = \\lambda$, the transcendental equation for the odd family of modes.\n\nThe algorithmic design to find the first $N$ smallest positive $k_\\parallel$ values involves numerically solving these two transcendental equations.\n$1$. For each parameter set, calculate the sheath admittance $\\lambda$ using the provided formula and physical constants.\n$2$. The roots of the transcendental equations can be found by locating the zeros of the functions $f_{\\text{even}}(k_\\parallel) = k_\\parallel \\tan(k_\\parallel L_\\parallel/2) - \\lambda$ and $f_{\\text{odd}}(k_\\parallel) = -k_\\parallel \\cot(k_\\parallel L_\\parallel/2) - \\lambda$.\n$3$. The roots are systematically located by analyzing the behavior of the tangent and cotangent functions.\n   - For even modes, roots of $k_\\parallel \\tan(k_\\parallel L_\\parallel/2) = \\lambda$ (with $\\lambda>0$) exist in the intervals $k_\\parallel \\in [2n\\pi/L_\\parallel, (2n+1)\\pi/L_\\parallel]$ for $n=0, 1, 2, \\dots$.\n   - For odd modes, roots of $-k_\\parallel \\cot(k_\\parallel L_\\parallel/2) = \\lambda$ (with $\\lambda>0$) exist in the intervals $k_\\parallel \\in [(2n-1)\\pi/L_\\parallel, 2n\\pi/L_\\parallel]$ for $n=1, 2, 3, \\dots$.\n$4$. A numerical root-finding algorithm, such as the Brent-Dekker method (`scipy.optimize.brentq`), is ideal for finding a root within a specified bracket where the function changes sign. We bracket each root in the intervals identified above, slightly shrinking them to avoid the singularities at the boundaries.\n$5$. To obtain the first $N$ smallest positivie wavenumbers, we generate a sufficient number of roots from both the even and odd families (e.g., $N$ roots from each family for robustness).\n$6$. The collected roots from both families are merged into a single list.\n$7$. The list is sorted in ascending order.\n$8$. The first $N$ elements of the sorted list are the desired solutions. The procedure is repeated for each test case.\n$9$. The final collection of results, a list of lists, is formatted into the specified string format.\nThe binormal wavenumber $k_y$ does not enter the parallel eigenmode problem and is thus not used in the calculation, as noted in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the first N smallest positive parallel wavenumbers (k_parallel) \n    for edge plasma blobs based on a simplified flux-tube model with \n    Robin boundary conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (near-Neumann sheath, small lambda)\n        {'L_parallel': 20.0, 'n_0': 1.0e19, 'T_e': 20.0, 'c_s': 2.0e4, 'sigma_parallel': 1.0e7, 'N': 4},\n        # Case B (intermediate sheath admittance)\n        {'L_parallel': 20.0, 'n_0': 1.0e19, 'T_e': 20.0, 'c_s': 2.0e4, 'sigma_parallel': 1.0e4, 'N': 4},\n        # Case C (strong sheath, large lambda)\n        {'L_parallel': 20.0, 'n_0': 1.0e19, 'T_e': 20.0, 'c_s': 2.0e4, 'sigma_parallel': 1.0e2, 'N': 4},\n    ]\n\n    # Fundamental constants\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs\n\n    all_results = []\n    \n    for case in test_cases:\n        L_p = case['L_parallel']\n        n_0 = case['n_0']\n        T_e_eV = case['T_e']\n        c_s = case['c_s']\n        sigma_p = case['sigma_parallel']\n        N = case['N']\n\n        # Calculate sheath admittance parameter lambda using the given formula for T_e in eV.\n        # lambda = (n_0 * e * c_s) / (T_e[eV] * sigma_parallel)\n        lambda_param = (n_0 * E_CHARGE * c_s) / (T_e_eV * sigma_p)\n        \n        half_L = L_p / 2.0\n        \n        # Define the transcendental equations to be solved for k_parallel (k)\n        def even_mode_eq(k, lam, hL):\n            # Equation: k * tan(k * hL) - lam = 0\n            if abs(k) < 1e-12:\n                return -lam\n            return k * np.tan(k * hL) - lam\n\n        def odd_mode_eq(k, lam, hL):\n            # Equation: -k * cot(k * hL) - lam = 0, written as -k / tan(k*hL)\n            tan_val = np.tan(k * hL)\n            if abs(tan_val) < 1e-12: # Avoid division by zero at poles of cotangent\n                return np.inf if -k > 0 else -np.inf\n            return -k / tan_val - lam\n\n        # Collect roots from both families\n        even_roots = []\n        odd_roots = []\n        epsilon = 1e-9 # Small value to stay away from singularities\n\n        # Generate enough roots to ensure we get the first N smallest ones after merging\n        num_to_generate = N + 2 \n        \n        # Even modes: roots are in intervals [n*pi/hL, (n+0.5)*pi/hL] for n=0, 1, ...\n        for n in range(num_to_generate):\n            lower_bound = n * np.pi / half_L\n            upper_bound = (n + 0.5) * np.pi / half_L\n            \n            # For lambda_param > 0, the function goes from a negative value to +infinity \n            # in the bracket, guaranteeing a root.\n            try:\n                root = brentq(even_mode_eq, lower_bound, upper_bound - epsilon, args=(lambda_param, half_L))\n                even_roots.append(root)\n            except ValueError:\n                # This may happen if the function doesn't cross zero in the bracket,\n                # which shouldn't occur for lambda_param > 0.\n                pass\n\n        # Odd modes: roots are in intervals [(n-0.5)*pi/hL, n*pi/hL] for n=1, 2, ...\n        for n in range(1, num_to_generate + 1):\n            lower_bound = (n - 0.5) * np.pi / half_L\n            upper_bound = n * np.pi / half_L\n            \n            # The function goes from a negative value to +infinity in the bracket.\n            try:\n                root = brentq(odd_mode_eq, lower_bound + epsilon, upper_bound - epsilon, args=(lambda_param, half_L))\n                odd_roots.append(root)\n            except ValueError:\n                pass\n                \n        # Combine, sort, and take the N smallest positive roots.\n        # The problem asks for the smallest *positive* allowed k_parallel values.\n        all_k = sorted(even_roots + odd_roots)\n        positive_k = [k for k in all_k if k > 1e-12]\n        \n        all_results.append(positive_k[:N])\n\n    # Final print statement in the exact required format.\n    # Format to a string that looks like a Python list of lists, with no spaces.\n    list_of_list_strs = [f\"[{','.join(map(str, sublist))}]\" for sublist in all_results]\n    output_str = f\"[{','.join(list_of_list_strs)}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}