{
    "hands_on_practices": [
        {
            "introduction": "In the limit of strong magnetic shear, the complex two-dimensional eigenproblem of a ballooning mode can be reduced to a simpler one-dimensional problem along a single extended field line. This exercise  guides you through solving a model equation analogous to the quantum harmonic oscillator, which captures the essential physics of the mode structure. By working through this problem, you will develop a first-principles understanding of how the confining effect of magnetic shear leads to a discrete spectrum of modes with definite parity.",
            "id": "4201994",
            "problem": "In the ballooning representation for electrostatic fluctuations in a strongly magnetized plasma, the mode structure along a single magnetic field line is described by a scalar envelope $\\phi(\\theta)$, where $\\theta$ is the extended poloidal angle. In a local, strong-shear limit relevant to fusion plasma turbulence simulation, the perpendicular wavenumber $k_{\\perp}(\\theta)$ grows approximately quadratically with $|\\theta|$ due to magnetic shear, yielding an effective even potential. As a minimal model, consider the one-dimensional Sturm–Liouville eigenproblem for the ballooning envelope,\n$$\n-\\,\\frac{d^{2}\\phi}{d\\theta^{2}} \\;+\\; \\Omega^{2}\\,\\theta^{2}\\,\\phi \\;=\\; \\Lambda\\,\\phi,\n$$\nwith $\\Omega>0$ constant, subject to the boundary condition $\\phi(\\theta)\\to 0$ as $|\\theta|\\to\\infty$. Assume a dimensionless normalization such that $\\theta$, $\\phi$, and $\\Lambda$ are dimensionless.\n\nStarting from the above eigenproblem and the parity properties of even potentials, do the following:\n\n1. Using general properties of second-order self-adjoint operators with even coefficients, justify that all eigenfunctions can be chosen to have definite parity in $\\theta$, and state the two parity classes that can arise.\n\n2. Perform an appropriate non-dimensionalization that reduces the eigenproblem to a canonical form with no free scale in the coefficient of the even potential, and introduce the corresponding dimensionless spectral parameter. State explicitly the rescaling you use.\n\n3. By enforcing square-integrability of $\\phi(\\theta)$ on $\\mathbb{R}$, derive the quantization condition for the dimensionless spectral parameter and thereby obtain the discrete spectrum of $\\Lambda$ in closed form. Your derivation must construct normalizable solutions from first principles and must not assume any pre-known special-function solution.\n\n4. From your construction, determine the parity of the $n$-th eigenfunction (with $n=0,1,2,\\dots$) and explain briefly how the existence of both symmetric and antisymmetric ballooning eigenfunctions follows from the even potential.\n\nProvide the final answer as a single closed-form expression for the discrete eigenvalues $\\Lambda_{n}$ as a function of $\\Omega$ and the integer index $n$. No numerical approximation is required.",
            "solution": "The problem is first validated against the specified criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe givens are:\n*   The governing eigenproblem for the scalar envelope $\\phi(\\theta)$:\n    $$-\\frac{d^{2}\\phi}{d\\theta^{2}} + \\Omega^{2}\\theta^{2}\\phi = \\Lambda\\phi$$\n*   The constant $\\Omega$ is positive: $\\Omega > 0$.\n*   The boundary condition is that the solutions must be physically acceptable, which implies they are square-integrable on $\\mathbb{R}$. This is stated as $\\phi(\\theta) \\to 0$ as $|\\theta| \\to \\infty$.\n*   The variables $\\theta$, $\\phi$, and the spectral parameter $\\Lambda$ are dimensionless.\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientifically Grounded**: The provided equation is mathematically equivalent to the time-independent Schrödinger equation for a quantum harmonic oscillator. This is a cornerstone model in quantum mechanics and is frequently used as a canonical example for Sturm-Liouville problems in mathematical physics. Its application as a simplified model for the ballooning envelope structure in fusion plasma physics is a standard and physically justified approximation in the high-shear limit. The problem is scientifically sound.\n*   **Well-Posed**: The problem is a regular Sturm-Liouville problem posed on the infinite domain $(-\\infty, \\infty)$. The potential $V(\\theta) = \\Omega^2\\theta^2$ is confining, meaning $V(\\theta) \\to \\infty$ as $|\\theta| \\to \\infty$. Such problems are known to possess a discrete spectrum of real eigenvalues and a corresponding complete set of square-integrable eigenfunctions. The problem is well-posed.\n*   **Objective**: The problem is stated in precise mathematical language, free of ambiguity or subjective claims.\n*   **Completeness and Consistency**: The problem provides all necessary information (the differential equation, the domain, the boundary conditions, and the properties of the constant $\\Omega$) to determine the eigenvalue spectrum. There are no contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem is scientifically grounded, well-posed, objective, and self-contained. It is a valid problem. The solution process may proceed.\n\n### Solution\n\nThe solution proceeds by addressing the four parts of the problem statement in order.\n\n**1. Parity of Eigenfunctions**\n\nThe eigenproblem is defined by the linear operator $L = -\\frac{d^2}{d\\theta^2} + \\Omega^2\\theta^2$. The potential term is $V(\\theta) = \\Omega^2\\theta^2$. This potential is an even function of $\\theta$, since $V(-\\theta) = \\Omega^2(-\\theta)^2 = \\Omega^2\\theta^2 = V(\\theta)$. The kinetic term, $-\\frac{d^2}{d\\theta^2}$, is also even with respect to the parity transformation $\\theta \\to -\\theta$. Therefore, the entire operator $L$ is even.\n\nLet $P$ be the parity operator, defined by its action on a function $f(\\theta)$ as $(P f)(\\theta) = f(-\\theta)$. An operator $A$ is even if it commutes with the parity operator, i.e., $[A, P] = AP - PA = 0$. Let's check this for our operator $L$:\n$$ (L(P\\phi))(\\theta) = \\left(-\\frac{d^2}{d\\theta^2} + \\Omega^2\\theta^2\\right)\\phi(-\\theta) $$\nLet $\\eta = -\\theta$, so $\\frac{d}{d\\theta} = -\\frac{d}{d\\eta}$ and $\\frac{d^2}{d\\theta^2} = \\frac{d^2}{d\\eta^2}$.\n$$ (L(P\\phi))(\\theta) = -\\frac{d^2\\phi}{d\\eta^2} + \\Omega^2(-\\eta)^2\\phi(\\eta) = -\\frac{d^2\\phi(\\eta)}{d\\eta^2} + \\Omega^2\\eta^2\\phi(\\eta) = (L\\phi)(\\eta) = (L\\phi)(-\\theta) = (P(L\\phi))(\\theta) $$\nSince $(L(P\\phi))(\\theta) = (P(L\\phi))(\\theta)$ for any function $\\phi$, we have $LP = PL$, so $[L, P] = 0$.\n\nA fundamental theorem of linear algebra (and quantum mechanics) states that if two operators commute, they share a common set of eigenfunctions. The eigenfunctions of the parity operator $P$ are functions with definite parity. If $\\psi$ is an eigenfunction of $P$ with eigenvalue $p$, then $P\\psi = p\\psi$. Applying $P$ again gives $P^2\\psi = p^2\\psi$. But $P^2$ is the identity operator, since $(P(P\\psi))(\\theta) = \\psi(-(-\\theta)) = \\psi(\\theta)$. Thus, $p^2=1$, and the eigenvalues of the parity operator are $p = 1$ and $p = -1$.\n\n*   Eigenvalue $p=1$: $\\phi(-\\theta) = \\phi(\\theta)$. These are **even** functions (symmetric).\n*   Eigenvalue $p=-1$: $\\phi(-\\theta) = -\\phi(\\theta)$. These are **odd** functions (antisymmetric).\n\nSince the eigenfunctions of $L$ can be chosen to be also eigenfunctions of $P$, all eigenfunctions $\\phi(\\theta)$ of the given problem can be classified as having a definite parity. The two parity classes are even and odd.\n\n**2. Non-dimensionalization to Canonical Form**\n\nThe original eigenproblem is $-\\frac{d^2\\phi}{d\\theta^2} + \\Omega^2\\theta^2\\phi = \\Lambda\\phi$. We seek a change of variables $\\theta = \\alpha x$ for some scaling factor $\\alpha$ to simplify the equation. Using the chain rule, $\\frac{d}{d\\theta} = \\frac{1}{\\alpha}\\frac{d}{dx}$ and $\\frac{d^2}{d\\theta^2} = \\frac{1}{\\alpha^2}\\frac{d^2}{dx^2}$. Substituting this into the equation yields:\n$$ -\\frac{1}{\\alpha^2}\\frac{d^2\\phi}{dx^2} + \\Omega^2(\\alpha x)^2 \\phi = \\Lambda \\phi $$\nMultiplying by $\\alpha^2$:\n$$ -\\frac{d^2\\phi}{dx^2} + \\alpha^4\\Omega^2 x^2 \\phi = \\alpha^2\\Lambda \\phi $$\nTo reduce this to a canonical form with no free parameter in the potential term, we choose the coefficient of $x^2$ to be $1$. This requires $\\alpha^4\\Omega^2 = 1$. Since $\\Omega > 0$, we can choose a real $\\alpha > 0$, which gives $\\alpha^2\\Omega = 1$, or $\\alpha = 1/\\sqrt{\\Omega}$.\n\nThe required rescaling is therefore $\\theta = x/\\sqrt{\\Omega}$.\nWith this choice, the eigenproblem becomes:\n$$ -\\frac{d^2\\phi}{dx^2} + x^2 \\phi = \\frac{\\Lambda}{\\Omega} \\phi $$\nThis is the canonical form of the quantum harmonic oscillator equation. The corresponding dimensionless spectral parameter, let's call it $\\lambda$, is given by the relation:\n$$ \\lambda = \\frac{\\Lambda}{\\Omega} $$\n\n**3. Derivation of the Quantization Condition and Spectrum**\n\nWe must find the square-integrable solutions to the rescaled equation:\n$$ -\\frac{d^2\\phi}{dx^2} + x^2 \\phi = \\lambda \\phi $$\nFirst, analyze the asymptotic behavior as $|x| \\to \\infty$. In this limit, the $x^2\\phi$ term dominates the $\\lambda\\phi$ term, and the equation is approximately $\\frac{d^2\\phi}{dx^2} \\approx x^2\\phi$. The solutions with this asymptotic behavior are of the form $\\exp(\\pm x^2/2)$. For the solution to be square-integrable (i.e., $\\phi \\to 0$ as $|x| \\to \\infty$), we must choose the decaying exponential. This motivates the ansatz:\n$$ \\phi(x) = H(x) \\exp\\left(-\\frac{x^2}{2}\\right) $$\nwhere $H(x)$ is a function that grows slower than $\\exp(x^2/2)$. We compute the derivatives of $\\phi(x)$:\n$$ \\frac{d\\phi}{dx} = \\left(\\frac{dH}{dx} - xH\\right) \\exp\\left(-\\frac{x^2}{2}\\right) $$\n$$ \\frac{d^2\\phi}{dx^2} = \\left(\\frac{d^2H}{dx^2} - 2x\\frac{dH}{dx} - H + x^2H\\right) \\exp\\left(-\\frac{x^2}{2}\\right) $$\nSubstituting these into the rescaled differential equation gives:\n$$ -\\left(\\frac{d^2H}{dx^2} - 2x\\frac{dH}{dx} - H + x^2H\\right) + x^2H = \\lambda H $$\nThis simplifies to Hermite's differential equation for $H(x)$:\n$$ \\frac{d^2H}{dx^2} - 2x\\frac{dH}{dx} + (\\lambda-1)H = 0 $$\nWe solve this equation from first principles using a power series expansion for $H(x)$:\n$$ H(x) = \\sum_{k=0}^{\\infty} c_k x^k $$\nThe derivatives are $H'(x) = \\sum_{k=1}^{\\infty} k c_k x^{k-1}$ and $H''(x) = \\sum_{k=2}^{\\infty} k(k-1) c_k x^{k-2}$. Substituting these into Hermite's equation:\n$$ \\sum_{k=2}^{\\infty} k(k-1) c_k x^{k-2} - 2x\\sum_{k=1}^{\\infty} k c_k x^{k-1} + (\\lambda-1)\\sum_{k=0}^{\\infty} c_k x^k = 0 $$\nRe-indexing the first sum with $j=k-2$ (so $k=j+2$):\n$$ \\sum_{j=0}^{\\infty} (j+2)(j+1) c_{j+2} x^j - \\sum_{k=1}^{\\infty} 2k c_k x^k + (\\lambda-1)\\sum_{k=0}^{\\infty} c_k x^k = 0 $$\nFor the coefficient of $x^k$ to be zero for all $k$, we equate the sum of coefficients to zero for each power of $x$. This yields the recurrence relation:\n$$ (k+2)(k+1)c_{k+2} - 2kc_k + (\\lambda-1)c_k = 0 $$\n$$ c_{k+2} = \\frac{2k - (\\lambda-1)}{(k+2)(k+1)} c_k = \\frac{2k+1-\\lambda}{(k+2)(k+1)} c_k $$\nFor large $k$, the ratio of successive coefficients is $c_{k+2}/c_k \\sim 2k/k^2 = 2/k$. This is the same asymptotic ratio as the coefficients of the Taylor series for $\\exp(x^2)$. If the series for $H(x)$ does not terminate, it will grow as $\\exp(x^2)$, and consequently $\\phi(x) = H(x)\\exp(-x^2/2)$ would grow as $\\exp(x^2/2)$, violating the square-integrability condition.\n\nFor the series to terminate, it must be a polynomial. This occurs if the numerator in the recurrence relation becomes zero for some non-negative integer $k$. Let this integer be $n$.\n$$ 2n + 1 - \\lambda = 0 $$\nThis gives the quantization condition for the dimensionless spectral parameter $\\lambda$:\n$$ \\lambda_n = 2n+1, \\quad \\text{for } n = 0, 1, 2, \\ldots $$\nThis condition ensures that $c_{n+2}=0$, and by the recurrence, all higher coefficients $c_{n+4}, c_{n+6}, \\ldots$ are also zero, making $H(x)$ a polynomial of degree $n$.\nRecalling that $\\lambda = \\Lambda/\\Omega$, we find the discrete spectrum of eigenvalues $\\Lambda_n$:\n$$ \\Lambda_n = \\Omega \\lambda_n = \\Omega(2n+1), \\quad n = 0, 1, 2, \\ldots $$\n\n**4. Parity of the $n$-th Eigenfunction**\n\nThe recurrence relation $c_{k+2} = \\frac{2k+1-\\lambda}{(k+2)(k+1)} c_k$ only links coefficients whose indices differ by $2$. This decouples the series into two independent sets: one for even powers of $x$ (starting from $c_0$) and one for odd powers of $x$ (starting from $c_1$).\n*   If we choose $c_1=0$, all odd coefficients vanish ($c_3=c_5=\\ldots=0$). The solution is a series of only even powers. For this series to terminate, the quantization condition $\\lambda_n=2n+1$ must hold for an even integer $n$. The resulting polynomial $H_n(x)$ is an even function, and therefore the eigenfunction $\\phi_n(x) = H_n(x)\\exp(-x^2/2)$ has even parity. This corresponds to $n=0, 2, 4, \\ldots$.\n*   If we choose $c_0=0$, all even coefficients vanish ($c_2=c_4=\\ldots=0$). The solution is a series of only odd powers. For this series to terminate, the condition $\\lambda_n=2n+1$ must hold for an odd integer $n$. The resulting polynomial $H_n(x)$ is an odd function, and the eigenfunction $\\phi_n(x)$ has odd parity. This corresponds to $n=1, 3, 5, \\ldots$.\n\nTherefore, the parity of the $n$-th eigenfunction is $(-1)^n$. The ground state ($n=0$) is even, the first excited state ($n=1$) is odd, the second excited state ($n=2$) is even, and so on.\n\nThe existence of both symmetric (even) and antisymmetric (odd) ballooning eigenfunctions is a direct consequence of the symmetry of the problem. As established in part 1, the governing operator $L$ is invariant under the parity transformation $\\theta \\to -\\theta$ because the effective potential $\\Omega^2\\theta^2$ is an even function. This symmetry guarantees that the eigenfunctions can be sorted into distinct parity classes. Since the domain $\\mathbb{R}$ is also symmetric with respect to the origin, there is no constraint that would eliminate one class of solutions over the other, so both families of solutions must exist.",
            "answer": "$$\\boxed{\\Omega(2n+1)}$$"
        },
        {
            "introduction": "A core feature of the ballooning representation is how it handles the effect of magnetic shear, which causes a secular growth in the radial wavenumber $k_x$ along the parallel coordinate. This coding exercise  tasks you with implementing and validating the \"twist-and-shift\" boundary condition, a cornerstone of modern flux-tube simulations. This practice provides direct, hands-on experience in connecting the continuous physical model of shear to its discrete implementation in a computational grid.",
            "id": "4201936",
            "problem": "Consider the ballooning representation in a sheared slab model for fusion plasma turbulence simulation. In a local field-aligned coordinate system, let the position be decomposed as $x$ (radial), $y$ (binormal), and $z$ (parallel along the magnetic field). The perpendicular plane-wave phase is defined by the scalar product of the perpendicular wavevector with position. Under magnetic shear, the binormal coordinate is linearly deformed along the parallel direction, which induces an evolution of the radial wavenumber as one follows a mode along $z$. Starting from the field-aligned representation assumptions, the perpendicular phase of a mode may be written as $k_x x + k_y y$ at $z=0$, and the sheared slab deformation may be expressed as a linear mapping of $y$ with $z$. Using these foundations, derive the governing relation for the evolution of the radial wavenumber as a function of the parallel coordinate $z$.\n\nThe twist-and-shift boundary condition used in flux-tube simulations enforces a discrete mapping at the parallel boundaries: after traversing a parallel domain length $L_z$, the mode connects to a shifted radial wavenumber index on a uniformly discretized radial-wavenumber grid with spacing $\\Delta k_x$. Formulate the theoretical prediction for this discrete index change based solely on the evolution of the radial wavenumber along the field line and the grid spacing.\n\nYour task is to implement a program that, for each provided test case, performs the following steps:\n\n1. Construct a uniform grid in the parallel coordinate $z \\in [-L_z/2, +L_z/2]$ with $N=2001$ points (inclusive), in meters.\n2. Compute the analytic radial wavenumber $k_x(z)$ on this grid, using the evolution relation derived from the sheared slab ballooning representation, with parameters: initial radial wavenumber $k_{x0}$ in $\\mathrm{m}^{-1}$, binormal wavenumber $k_y$ in $\\mathrm{m}^{-1}$, magnetic shear $\\hat{s}$ in $\\mathrm{m}^{-1}$, and parallel domain length $L_z$ in $\\mathrm{m}$.\n3. Numerically simulate the $k_x(z)$ evolution on the same grid using a stepwise update consistent with the derived ordinary differential equation for $k_x(z)$ with respect to $z$. Use a simple forward Euler stepping in $z$ that accumulates the change in $k_x$ across the grid.\n4. Compute the maximum absolute difference between the analytic and simulated $k_x(z)$ arrays over the entire grid. Express this difference in $\\mathrm{m}^{-1}$.\n5. Compute the predicted discrete twist-and-shift index change $N_{\\text{pred}}$ as the nearest integer to the ratio of the net radial wavenumber change across the domain to the radial-wavenumber grid spacing $\\Delta k_x$. Compute the numerically realized index change $N_{\\text{sim}}$ from the simulated $k_x(z)$ at the two ends of the domain using the same nearest-integer rule. Report the integer difference $N_{\\text{sim}} - N_{\\text{pred}}$.\n\nAll quantities must be handled in International System of Units (SI). In particular, $z$ must be in meters, $k_x$, $k_y$, and $\\Delta k_x$ in $\\mathrm{m}^{-1}$, and $\\hat{s}$ in $\\mathrm{m}^{-1}$. Angles are not used in this problem.\n\nTest Suite:\nUse the following parameter sets, each given as $(k_{x0}, k_y, \\hat{s}, L_z, \\Delta k_x)$ with units $(\\mathrm{m}^{-1}, \\mathrm{m}^{-1}, \\mathrm{m}^{-1}, \\mathrm{m}, \\mathrm{m}^{-1})$:\n- Case A (general case): $(0.0, 2.0, 0.3, 10.0, 0.5)$\n- Case B (zero shear): $(1.0, 2.0, 0.0, 10.0, 0.5)$\n- Case C (zero binormal wavenumber): $(0.5, 0.0, 0.25, 12.0, 0.6)$\n- Case D (negative shear): $(0.0, 3.0, -0.1, 20.0, 0.4)$\n- Case E (non-integer mapping ratio): $(0.2, 1.5, 0.2, 7.0, 0.8)$\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets. Each per-case result must itself be a two-element list of the form $[E_{\\max}, \\Delta N]$, where $E_{\\max}$ is the maximum absolute difference in $\\mathrm{m}^{-1}$ (a float) and $\\Delta N$ is the integer difference $N_{\\text{sim}} - N_{\\text{pred}}$. For example: \"[[Emax_caseA,DeltaN_caseA],[Emax_caseB,DeltaN_caseB],...]\" where each element corresponds in order to the cases listed above.",
            "solution": "The problem statement will be validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Coordinate System**: A local field-aligned system with coordinates $x$ (radial), $y$ (binormal), and $z$ (parallel).\n- **Mode Representation**: A perpendicular plane-wave phase at $z=0$ is given by $k_x x + k_y y$.\n- **Magnetic Shear Model**: The sheared slab model involves a linear deformation of the binormal coordinate $y$ with the parallel coordinate $z$, which in turn causes the radial wavenumber $k_x$ to evolve as a function of $z$.\n- **Boundary Condition**: A twist-and-shift boundary condition is used over a parallel domain of length $L_z$, connecting the mode to a shifted radial wavenumber index on a discrete grid of spacing $\\Delta k_x$.\n- **Simulation Parameters**:\n    - Parallel grid: Uniformly discretized in $z \\in [-L_z/2, +L_z/2]$ with $N=2001$ points.\n    - Initial radial wavenumber at $z=0$: $k_{x0}$ [$\\mathrm{m}^{-1}$].\n    - Binormal wavenumber: $k_y$ [$\\mathrm{m}^{-1}$].\n    - Magnetic shear parameter: $\\hat{s}$ [$\\mathrm{m}^{-1}$].\n    - Parallel domain length: $L_z$ [m].\n    - Radial wavenumber grid spacing: $\\Delta k_x$ [$\\mathrm{m}^{-1}$].\n- **Tasks**:\n    1. Construct the parallel grid for $z$.\n    2. Compute the analytic form of $k_x(z)$.\n    3. Simulate the evolution of $k_x(z)$ using a forward Euler method based on the ODE for $dk_x/dz$.\n    4. Calculate $E_{\\max}$, the maximum absolute difference between the analytic and simulated $k_x(z)$ arrays.\n    5. Calculate the predicted integer index change $N_{\\text{pred}}$ from the analytic result and the simulated change $N_{\\text{sim}}$ from the numerical result, both using a nearest-integer rounding rule. Report the difference $\\Delta N = N_{\\text{sim}} - N_{\\text{pred}}$.\n- **Test Cases**: Five sets of parameters $(k_{x0}, k_y, \\hat{s}, L_z, \\Delta k_x)$ are provided.\n- **Units**: All quantities are specified in SI units.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the required criteria.\n- **Scientifically Grounded**: The problem is based on the well-established ballooning representation used in the theory and simulation of micro-instabilities in magnetically confined fusion plasmas. The sheared slab model is a standard simplified geometry for studying such phenomena. The concepts of field-aligned coordinates, wavenumber evolution due to shear, and twist-and-shift boundary conditions are all standard in the field of gyrokinetic simulation. The problem is scientifically sound.\n- **Well-Posed**: The problem is clearly defined. It asks for a specific derivation, a numerical implementation with all necessary parameters ($k_{x0}$, $k_y$, $\\hat{s}$, $L_z$, $\\Delta k_x$, $N$) and methods (forward Euler) provided, and the calculation of specific, well-defined metrics ($E_{\\max}$, $\\Delta N$). A unique, stable, and meaningful solution exists.\n- **Objective**: The problem is stated in precise, technical language, free of ambiguity, subjectivity, or opinion.\n- **Flaw Checklist**: The problem does not violate any of the specified invalidity criteria. It is formalizable, complete, physically plausible, and requires non-trivial reasoning and implementation. The relationship between the parameters and the physical model is consistent. The term $\\hat{s}$ is given in units of $\\mathrm{m}^{-1}$, which is appropriate for a slab model where it represents the gradient of the magnetic field pitch, $d(B_y/B_z)/dx$.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A complete, reasoned solution will be provided.\n\n### Principle-Based Design and Solution\n\n#### Theoretical Derivation\nThe core of the problem lies in determining the functional form of the radial wavenumber $k_x$ as it varies with the parallel coordinate $z$. This relationship is a direct consequence of adopting a coordinate system that follows the sheared magnetic field lines.\n\nIn a sheared slab model, the magnetic field can be represented as $\\vec{B} \\approx B_0(\\hat{z} + \\hat{s} x \\hat{y})$, where $\\hat{s}$ represents the magnetic shear. A field line is a curve whose tangent is everywhere parallel to $\\vec{B}$. The equation for a field line is $d\\vec{l}/ds \\propto \\vec{B}$, which gives the component relations $dx/B_x = dy/B_y = dz/B_z$. In this model, this implies $dx/0 = dy/(B_0 \\hat{s} x) = dz/B_0$, leading to $dy/dz = \\hat{s} x$.\n\nTo simplify the description of wave-like perturbations, we transform to a field-following coordinate system $(x, y', z)$, where $y'$ is constant along a field line. From $dy/dz = \\hat{s} x$, one can define such a coordinate as $y' = y - \\hat{s} x z$.\n\nLet us consider a single Fourier mode. In the lab frame $(x,y,z)$, its phase is given by $\\alpha(x,y,z)$. A mode that is simple in the field-following frame might be described by a phase $\\alpha = k_{x0} x + k_y y'$, where $k_{x0}$ and $k_y$ are constant wavenumbers. Transforming this phase back to the lab frame coordinates gives:\n$$ \\alpha = k_{x0} x + k_y (y - \\hat{s} x z) = k_{x0} x + k_y y - \\hat{s} k_y z x $$\nRearranging the terms to group the spatial dependencies, we get:\n$$ \\alpha = (k_{x0} - \\hat{s} k_y z) x + k_y y $$\nThis expression has the form $\\alpha = k_x(z) x + k_y y$, where the radial wavenumber $k_x(z)$ explicitly depends on the parallel coordinate $z$. By direct comparison, we find:\n$$ k_x(z) = k_{x0} - \\hat{s} k_y z $$\nA different sign convention is also common in the literature, leading to $k_x(z) = k_{x0} + \\hat{s} k_y z$. This choice depends on conventions for the direction of the magnetic field, plasma current, and the definition of $\\hat{s}$. We shall adopt the convention $k_x(z) = k_{x0} + \\hat{s} k_y z$ for this solution, which is a common choice and yields a positive change in $k_x$ for positive $\\hat{s}$, $k_y$, and $z$. This provides the analytic expression for the radial wavenumber.\n\nFrom this relation, the governing ordinary differential equation (ODE) for $k_x(z)$ is obtained by differentiation with respect to $z$:\n$$ \\frac{d k_x}{dz} = \\frac{d}{dz} (k_{x0} + \\hat{s} k_y z) = \\hat{s} k_y $$\nThis ODE states that the rate of change of the radial wavenumber along the field line is constant, determined by the product of the magnetic shear and the binormal wavenumber.\n\n#### Numerical Analysis and Error Expectation\nThe problem requires simulating the evolution of $k_x(z)$ using the forward Euler method. The update rule for a step $\\Delta z$ is:\n$$ k_x(z_{i+1}) = k_x(z_i) + \\Delta z \\left. \\frac{d k_x}{dz} \\right|_{z_i} $$\nSubstituting our derived ODE:\n$$ k_x(z_{i+1}) = k_x(z_i) + \\Delta z (\\hat{s} k_y) $$\nThis numerical scheme is a simple first-order integrator. Its local truncation error is of order $\\mathcal{O}(\\Delta z^2)$. However, for our specific problem, the second derivative of the analytic solution is zero:\n$$ \\frac{d^2 k_x}{dz^2} = \\frac{d}{dz} (\\hat{s} k_y) = 0 $$\nSince all higher-order derivatives are also zero, the Taylor expansion of $k_x(z)$ is exact to first order. This means the forward Euler method, which is based on a first-order Taylor expansion, will not introduce any truncation error. The numerical integration will exactly reproduce the linear analytic solution, subject only to floating-point representation errors.\n\nTherefore, it is an a priori expectation that the maximum absolute difference $E_{\\max} = \\max_z|k_{x, \\text{analytic}}(z) - k_{x, \\text{sim}}(z)|$ will be zero, or a very small number on the order of machine precision.\n\n#### Twist-and-Shift Index Change\nThe twist-and-shift boundary condition relates the state of the simulation at the two ends of the parallel domain, $z = -L_z/2$ and $z = +L_z/2$. The total change in the radial wavenumber across this domain is a key parameter.\nThe analytic prediction for this change is:\n$$ \\Delta k_{x, \\text{total}} = k_x(+L_z/2) - k_x(-L_z/2) = (k_{x0} + \\hat{s} k_y \\frac{L_z}{2}) - (k_{x0} + \\hat{s} k_y \\frac{-L_z}{2}) = \\hat{s} k_y L_z $$\nThe corresponding discrete index change, $N_{\\text{pred}}$, is the number of grid cells of size $\\Delta k_x$ that this total change spans. The problem specifies using the nearest integer for this value:\n$$ N_{\\text{pred}} = \\text{round}\\left(\\frac{\\Delta k_{x, \\text{total}}}{\\Delta k_x}\\right) = \\text{round}\\left(\\frac{\\hat{s} k_y L_z}{\\Delta k_x}\\right) $$\nThe term \"round\" is interpreted as rounding to the nearest integer, with halves typically rounded to the nearest even integer in standard numerical libraries (`numpy.rint`). The provided test cases do not fall on an exact half-integer, so this ambiguity is not critical.\n\nThe simulated index change, $N_{\\text{sim}}$, is computed identically, but using the values from the numerical simulation at the domain boundaries:\n$$ N_{\\text{sim}} = \\text{round}\\left(\\frac{k_{x, \\text{sim}}(+L_z/2) - k_{x, \\text{sim}}(-L_z/2)}{\\Delta k_x}\\right) $$\nSince we have established that the numerical simulation is expected to be exact, we must conclude that $k_{x, \\text{sim}} \\approx k_{x, \\text{analytic}}$ everywhere. Consequently, $N_{\\text{sim}}$ will be equal to $N_{\\text{pred}}$, and the required output $\\Delta N = N_{\\text{sim}} - N_{\\text{pred}}$ is expected to be $0$ for all test cases.\n\n#### Implementation Strategy\nThe program will execute the following steps for each test case:\n1.  Define the simulation grid $z_i$ from $-L_z/2$ to $+L_z/2$ with $N=2001$ points.\n2.  Calculate the analytic solution array $k_{x, \\text{analytic}}(z_i) = k_{x0} + \\hat{s} k_y z_i$.\n3.  Initialize a simulation array $k_{x, \\text{sim}}$ of the same size. Set the central point (at $z=0$) to $k_{x0}$.\n4.  Iteratively compute the rest of the $k_{x, \\text{sim}}$ array by stepping forward and backward from the center using the forward Euler rule: $k_{x,i+1} = k_{x,i} + \\Delta z (\\hat{s} k_y)$.\n5.  Compute $E_{\\max}$ as the maximum of the absolute difference between the two arrays.\n6.  Compute $\\Delta k_{x, \\text{analytic}} = k_{x, \\text{analytic}}[-1] - k_{x, \\text{analytic}}[0]$ and $\\Delta k_{x, \\text{sim}} = k_{x, \\text{sim}}[-1] - k_{x, \\text{sim}}[0]$.\n7.  Calculate $N_{\\text{pred}}$ and $N_{\\text{sim}}$ using `numpy.rint` and the given $\\Delta k_x$.\n8.  Compute the integer difference $\\Delta N = N_{\\text{sim}} - N_{\\text{pred}}$.\n9.  Store the pair $[E_{\\max}, \\Delta N]$ for the case.\n10. After processing all cases, the final list of results will be formatted into the required string output.\n\nThis constitutes a complete and rigorous plan for solving the posed problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ballooning representation problem for a sheared slab model.\n\n    For each test case, this function:\n    1. Sets up a parallel coordinate grid.\n    2. Computes the analytic evolution of the radial wavenumber k_x(z).\n    3. Simulates the evolution of k_x(z) using a forward Euler method.\n    4. Calculates the maximum absolute difference (E_max) between the two.\n    5. Calculates the predicted and simulated twist-and-shift index changes\n       (N_pred, N_sim) and their difference (Delta_N).\n    6. Formats and prints the results as specified.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (k_x0, k_y, s_hat, L_z, delta_kx) with SI units.\n    test_cases = [\n        (0.0, 2.0, 0.3, 10.0, 0.5),   # Case A (general case)\n        (1.0, 2.0, 0.0, 10.0, 0.5),   # Case B (zero shear)\n        (0.5, 0.0, 0.25, 12.0, 0.6),   # Case C (zero binormal wavenumber)\n        (0.0, 3.0, -0.1, 20.0, 0.4),  # Case D (negative shear)\n        (0.2, 1.5, 0.2, 7.0, 0.8),    # Case E (non-integer mapping ratio)\n    ]\n\n    results = []\n    \n    # Number of grid points in the parallel direction\n    N = 2001\n\n    for case in test_cases:\n        k_x0, k_y, s_hat, L_z, delta_kx = case\n\n        # 1. Construct a uniform grid in the parallel coordinate z.\n        # z is in meters.\n        z = np.linspace(-L_z / 2.0, L_z / 2.0, N, dtype=np.float64)\n        dz = L_z / (N - 1)\n\n        # 2. Compute the analytic radial wavenumber k_x(z).\n        # The evolution relation is derived as k_x(z) = k_x0 + s_hat * k_y * z.\n        kx_analytic = k_x0 + s_hat * k_y * z\n\n        # 3. Numerically simulate the k_x(z) evolution.\n        # The ODE is dk_x/dz = s_hat * k_y.\n        kx_sim = np.zeros(N, dtype=np.float64)\n        \n        # Find the index corresponding to z = 0.\n        center_idx = (N - 1) // 2\n        \n        # Set the initial condition k_x(0) = k_x0.\n        kx_sim[center_idx] = k_x0\n        \n        # Use forward Euler stepping to integrate forward from the center.\n        dkx_dz = s_hat * k_y\n        for i in range(center_idx, N - 1):\n            kx_sim[i + 1] = kx_sim[i] + dz * dkx_dz\n            \n        # Use a consistent backward step to integrate backward from the center.\n        for i in range(center_idx, 0, -1):\n            kx_sim[i - 1] = kx_sim[i] - dz * dkx_dz\n\n        # 4. Compute the maximum absolute difference between analytic and simulated arrays.\n        E_max = np.max(np.abs(kx_analytic - kx_sim))\n\n        # 5. Compute the predicted and simulated discrete index changes.\n        \n        # Calculate the total change in kx across the domain for both methods.\n        delta_kx_total_analytic = kx_analytic[-1] - kx_analytic[0]\n        delta_kx_total_sim = kx_sim[-1] - kx_sim[0]\n\n        # Calculate the index change as the nearest integer to the ratio.\n        # numpy.rint rounds to the nearest integer (ties to nearest even).\n        N_pred = np.rint(delta_kx_total_analytic / delta_kx)\n        N_sim = np.rint(delta_kx_total_sim / delta_kx)\n        \n        # Compute the integer difference.\n        delta_N = int(N_sim - N_pred)\n        \n        results.append([E_max, delta_N])\n\n    # Final print statement in the exact required format.\n    # The problem description's example print statement implies that the\n    # default str() representation of a list (e.g., \"[0.0, 0]\") is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Ultimately, the goal of turbulence simulations is to predict physical observables like instability growth rates and transport fluxes. This final practice  brings together the preceding concepts, challenging you to compute these quantities using a representative instability model and to perform a numerical convergence study. This exercise is invaluable for developing the critical skill of assessing the accuracy and reliability of simulation results, a cornerstone of modern computational science.",
            "id": "4202001",
            "problem": "Consider the Ballooning Representation (BR) in fusion plasma turbulence, where the field-aligned coordinate is the poloidal angle $\\theta$ in radians. In a simplified, yet scientifically grounded local model for a representative ballooning instability, the instantaneous linear growth rate density at fixed perpendicular wavenumbers $(k_x,k_y)$ and at poloidal angle $\\theta$ is modeled as\n$$\nD(\\theta,k_x,k_y) \\equiv \\omega_*\\,k_y + \\kappa \\exp\\!\\left(-\\frac{(\\theta-\\theta_0)^2}{2\\Delta^2}\\right) - \\nu\\,(k_x^2+k_y^2),\n$$\nwhere all quantities are dimensionless and $\\theta$ is expressed in radians. The parameters $\\omega_*$, $\\kappa$, $\\nu$, $\\theta_0$, and $\\Delta$ represent, respectively, the diamagnetic drift drive coefficient, the curvature drive amplitude, the dissipative damping coefficient, the location of peak curvature drive, and its parallel-localization width. In the strong-ballooning limit, the linear growth rate at $(k_x,k_y)$ is approximated by the supremum along the field line,\n$$\n\\gamma(k_x,k_y) \\equiv \\sup_{\\theta\\in[-\\pi,\\pi)} D(\\theta,k_x,k_y).\n$$\nNumerically, this is approximated by sampling $\\theta$ uniformly with $N_\\theta$ points over $[-\\pi,\\pi)$ and replacing the supremum by the discrete maximum.\n\nA dimensionless quasi-linear (QL) flux functional is defined by weighting the unstable spectrum by the net drive, with a prescribed spectral envelope $A(k_x,k_y)$,\n$$\nQ \\equiv \\iint \\mathrm{d}k_x\\,\\mathrm{d}k_y\\; k_y \\,\\max\\!\\left(0,\\gamma(k_x,k_y)\\right) A(k_x,k_y),\n$$\nwhere\n$$\nA(k_x,k_y) = \\exp\\!\\left(-\\frac{k_x^2+k_y^2}{k_0^2}\\right).\n$$\nThe continuous integral is approximated by a uniform Riemann sum using $N_{k_x}$ and $N_{k_y}$ points over the domains $k_x\\in[-K,K]$ and $k_y\\in[0,K]$.\n\nStarting only from the definitions of a supremum, uniform Riemann sums, and the preceding physically motivated local model for $D(\\theta,k_x,k_y)$, implement a program that:\n- Constructs the discrete $\\theta$ grid with $N_\\theta$ points over $[-\\pi,\\pi)$, uniformly spaced.\n- Constructs the discrete $k_x$ grid with $N_{k_x}$ points over $[-K,K]$, uniformly spaced, and the discrete $k_y$ grid with $N_{k_y}$ points over $[0,K]$, uniformly spaced.\n- Computes the discrete approximation to $\\gamma(k_x,k_y)$ by maximizing $D(\\theta,k_x,k_y)$ over the discrete $\\theta$ grid for each $(k_x,k_y)$.\n- Computes $Q$ by the uniform Riemann-sum approximation of the above integral, with measure weights $\\Delta k_x=(2K)/N_{k_x}$ and $\\Delta k_y=K/N_{k_y}$.\n\nTo quantify convergence, define a reference solution by using $N_\\theta^{\\mathrm{ref}}$, $N_{k_x}^{\\mathrm{ref}}$, and $N_{k_y}^{\\mathrm{ref}}$ and repeat the computations of $\\gamma(k_x,k_y)$ and $Q$:\n- For the growth-rate error, compare the coarse-grid $\\gamma(k_x,k_y)$ to the reference $\\gamma^{\\mathrm{ref}}(k_x,k_y)$ evaluated at the same coarse $(k_x,k_y)$ points but using $N_\\theta^{\\mathrm{ref}}$. Use the relative Two-Norm ($L^2$) error\n$$\n\\varepsilon_\\gamma \\equiv \\frac{\\left\\|\\gamma-\\gamma^{\\mathrm{ref}}\\right\\|_{2}}{\\left\\|\\gamma^{\\mathrm{ref}}\\right\\|_{2}},\n$$\nwith the norm taken over the coarse $(k_x,k_y)$ grid.\n- For the flux error, compare the coarse-grid $Q$ to the reference $Q^{\\mathrm{ref}}$ computed using $(N_\\theta^{\\mathrm{ref}},N_{k_x}^{\\mathrm{ref}},N_{k_y}^{\\mathrm{ref}})$ via the relative absolute error\n$$\n\\varepsilon_Q \\equiv \\frac{\\left|Q-Q^{\\mathrm{ref}}\\right|}{\\left|Q^{\\mathrm{ref}}\\right|}.\n$$\n\nAll quantities are dimensionless and angles must be in radians. The parameters for the representative instability are\n- $\\omega_* = 0.7$,\n- $\\kappa = 0.6$,\n- $\\nu = 0.3$,\n- $\\theta_0 = 0.4$,\n- $\\Delta = 0.5$,\n- $k_0 = 0.8$,\n- $K = 2.4$.\nUse the following reference resolution:\n- $N_\\theta^{\\mathrm{ref}} = 1024$,\n- $N_{k_x}^{\\mathrm{ref}} = 64$,\n- $N_{k_y}^{\\mathrm{ref}} = 64$.\n\nYour program must evaluate the error pairs $(\\varepsilon_\\gamma,\\varepsilon_Q)$ for the following test suite of $(N_\\theta,N_{k_x},N_{k_y})$:\n- Case $1$: $(32,16,16)$, a general coarse resolution.\n- Case $2$: $(16,8,8)$, a boundary coarse resolution.\n- Case $3$: $(64,32,8)$, anisotropic resolution with finer $k_x$.\n- Case $4$: $(128,8,32)$, anisotropic resolution with finer $k_y$.\n\nThe final output format must be a single line containing the list of results as a comma-separated Python-style list of lists, where each inner list is $[\\varepsilon_\\gamma,\\varepsilon_Q]$ in this order for one case. For example, the output should look like\n`[[e_{\\gamma,1},e_{Q,1}],[e_{\\gamma,2},e_{Q,2}],[e_{\\gamma,3},e_{Q,3}],[e_{\\gamma,4},e_{Q,4}]]`.",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the context of a simplified model for plasma turbulence, mathematically well-posed, and provides a complete and consistent set of definitions and parameters for a deterministic numerical calculation. No flaws were identified.\n\nThe objective is to compute the numerical convergence errors for a coarse-grid approximation of a growth rate spectrum, $\\gamma(k_x, k_y)$, and a related quasi-linear flux, $Q$, against a high-resolution reference solution. This requires implementing the specified physical model and numerical schemes.\n\nThe solution is developed based on the following principles and algorithmic steps:\n\n**1. Physical and Numerical Model Formulation**\n\nThe core of the problem lies in evaluating two key quantities. First, the instantaneous linear growth rate density is given by the function:\n$$\nD(\\theta,k_x,k_y) \\equiv \\omega_*\\,k_y + \\kappa \\exp\\!\\left(-\\frac{(\\theta-\\theta_0)^2}{2\\Delta^2}\\right) - \\nu\\,(k_x^2+k_y^2)\n$$\nHere, $\\theta$ is the field-aligned coordinate, and $(k_x, k_y)$ are the perpendicular wavenumbers. The parameters $\\omega_* = 0.7$, $\\kappa = 0.6$, $\\nu = 0.3$, $\\theta_0 = 0.4$, and $\\Delta = 0.5$ are dimensionless constants defining the physical character of the instability.\n\nSecond, the linear growth rate $\\gamma(k_x, k_y)$ is found by taking the supremum of $D$ over the periodic domain of the angle $\\theta$:\n$$\n\\gamma(k_x,k_y) \\equiv \\sup_{\\theta\\in[-\\pi,\\pi)} D(\\theta,k_x,k_y)\n$$\nNumerically, this is approximated by finding the maximum value of $D$ over a discrete, uniform grid of $N_\\theta$ points in the interval $[-\\pi, \\pi)$.\n\nThird, a quasi-linear flux functional $Q$ is computed by integrating the positive part of the growth rate over the wavenumber space $(k_x, k_y)$, weighted by $k_y$ and a spectral envelope $A(k_x, k_y)$:\n$$\nQ \\equiv \\iint \\mathrm{d}k_x\\,\\mathrm{d}k_y\\; k_y \\,\\max\\!\\left(0,\\gamma(k_x,k_y)\\right) A(k_x,k_y)\n$$\nThe spectral envelope is a Gaussian function defined as:\n$$\nA(k_x,k_y) = \\exp\\!\\left(-\\frac{k_x^2+k_y^2}{k_0^2}\\right)\n$$\nwith $k_0 = 0.8$. The integration domains are $k_x \\in [-K, K]$ and $k_y \\in [0, K]$, with $K = 2.4$. The continuous integral is approximated by a uniform Riemann sum over a discrete grid.\n\n**2. Algorithmic Design and Implementation**\n\nThe computation is structured into modular functions to ensure clarity and correctness.\n\n**2.1. Grid Generation**\nDiscrete grids are required for $\\theta$, $k_x$, and $k_y$. The problem specifies uniform grids with $N_\\theta$, $N_{k_x}$, and $N_{k_y}$ points, respectively. The step sizes for the wavenumber grids are explicitly given as $\\Delta k_x = (2K)/N_{k_x}$ and $\\Delta k_y = K/N_{k_y}$. This definition is satisfied by generating grids that cover the interval but exclude the endpoint. For an interval $[a, b]$ with $N$ points, the step size is $(b-a)/N$. Thus, the grids are constructed as:\n- **$\\theta$ grid:** $N_\\theta$ points over $[-\\pi, \\pi)$, generated via `np.linspace(-np.pi, np.pi, N_theta, endpoint=False)`.\n- **$k_x$ grid:** $N_{k_x}$ points over $[-K, K)$, generated via `np.linspace(-K, K, N_kx, endpoint=False)`. The corresponding step size matches the specified $\\Delta k_x$.\n- **$k_y$ grid:** $N_{k_y}$ points over $[0, K)$, generated via `np.linspace(0, K, N_ky, endpoint=False)`. The corresponding step size matches the specified $\\Delta k_y$.\n\n**2.2. Computation of $\\gamma(k_x, k_y)$**\nTo compute $\\gamma(k_x, k_y)$ efficiently, we employ `NumPy`'s vectorization and broadcasting capabilities.\n1. The 1D grids for $k_x$ and $k_y$ are expanded into 2D meshgrids, `kx_grid` and `ky_grid`, of shape $(N_{k_x}, N_{k_y})$.\n2. The 1D grid for $\\theta$ is reshaped to $(N_\\theta, 1, 1)$, and the wavenumber grids are reshaped to $(1, N_{k_x}, N_{k_y})$.\n3. The three terms comprising $D(\\theta, k_x, k_y)$ are computed. Broadcasting automatically expands their dimensions, resulting in a 3D array for $D$ of shape $(N_\\theta, N_{k_x}, N_{k_y})$. This single operation evaluates the growth rate density at every point in the $(\\theta, k_x, k_y)$ grid without explicit loops.\n4. The discrete approximation to the supremum is found by taking the maximum along the $\\theta$-axis (axis $0$) of the 3D array $D$. The result is the 2D array $\\gamma(k_x, k_y)$ of shape $(N_{k_x}, N_{k_y})$.\n\n**2.3. Computation of $Q$**\nThe Riemann sum approximation to the integral for $Q$ is:\n$$\nQ \\approx \\sum_{i=0}^{N_{k_x}-1} \\sum_{j=0}^{N_{k_y}-1} k_{y,j} \\,\\max\\!\\left(0,\\gamma(k_{x,i}, k_{y,j})\\right) A(k_{x,i}, k_{y,j}) \\,\\Delta k_x \\Delta k_y\n$$\nThis is implemented by:\n1. Calculating the integrand, $I_{ij} = k_{y,j} \\,\\max(0, \\gamma_{ij}) A_{ij}$, at each point on the $(k_x, k_y)$ grid.\n2. Summing all elements of the resulting 2D integrand array.\n3. Multiplying the total sum by the area element $\\Delta k_x \\Delta k_y$.\n\n**3. Error Analysis and Convergence**\n\nThe core task is to quantify the error between coarse-resolution calculations and a high-resolution reference.\n\n**3.1. Reference Solution**\nA reference solution is first computed using a fine grid defined by $(N_\\theta^{\\mathrm{ref}}, N_{k_x}^{\\mathrm{ref}}, N_{k_y}^{\\mathrm{ref}}) = (1024, 64, 64)$. This yields the reference flux $Q^{\\mathrm{ref}}$.\n\n**3.2. Coarse Solutions and Error Calculation**\nFor each test case $(N_\\theta, N_{k_x}, N_{k_y})$, the coarse-grid flux $Q$ and growth rate spectrum $\\gamma$ are computed. The errors are then calculated as follows:\n\n- **Flux Error $\\varepsilon_Q$:** The relative absolute error is computed directly:\n  $$\n  \\varepsilon_Q = \\frac{\\left|Q - Q^{\\mathrm{ref}}\\right|}{\\left|Q^{\\mathrm{ref}}\\right|}\n  $$\n\n- **Growth Rate Error $\\varepsilon_\\gamma$:** This requires a more specific comparison. The error is the relative $L^2$-norm (or Frobenius norm) of the difference between the coarse-grid $\\gamma$ and a reference $\\gamma^{\\mathrm{ref}}$, where both are evaluated on the *same coarse $(k_x, k_y)$ grid*.\n  $$\n  \\varepsilon_\\gamma = \\frac{\\left\\|\\gamma - \\gamma^{\\mathrm{ref}}\\right\\|_{2}}{\\left\\|\\gamma^{\\mathrm{ref}}\\right\\|_{2}}\n  $$\n  To implement this, two $\\gamma$ spectra are computed on the coarse $(k_x, k_y)$ grid:\n  1. $\\gamma$: using the coarse poloidal resolution $N_\\theta$.\n  2. $\\gamma^{\\mathrm{ref}}$: using the reference poloidal resolution $N_\\theta^{\\mathrm{ref}}$.\n  The $L^2$-norm is then computed using `np.linalg.norm` on the difference between these two 2D arrays.\n\nThis procedure is repeated for all four test cases, and the resulting error pairs $(\\varepsilon_\\gamma, \\varepsilon_Q)$ are collected for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating convergence errors for a plasma turbulence model.\n    \"\"\"\n    \n    # Define physical and numerical parameters from the problem statement.\n    params = {\n        'omega_star': 0.7,\n        'kappa': 0.6,\n        'nu': 0.3,\n        'theta_0': 0.4,\n        'Delta': 0.5,\n        'k0': 0.8,\n        'K': 2.4,\n    }\n\n    # Define reference resolution.\n    ref_resolution = {\n        'N_theta': 1024,\n        'N_kx': 64,\n        'N_ky': 64,\n    }\n\n    # Define the test suite of coarse resolutions.\n    test_cases = [\n        (32, 16, 16),  # Case 1\n        (16, 8, 8),    # Case 2\n        (64, 32, 8),   # Case 3\n        (128, 8, 32),  # Case 4\n    ]\n\n    def compute_gamma(kx_vals, ky_vals, N_theta, p):\n        \"\"\"\n        Computes the growth rate gamma(kx, ky) on a given wavenumber grid.\n        \n        Args:\n            kx_vals (np.ndarray): 1D array of kx grid points.\n            ky_vals (np.ndarray): 1D array of ky grid points.\n            N_theta (int): Number of points for the theta grid.\n            p (dict): Dictionary of physical parameters.\n        \n        Returns:\n            np.ndarray: 2D array of gamma values.\n        \"\"\"\n        # Construct the theta grid.\n        theta_vals = np.linspace(-np.pi, np.pi, N_theta, endpoint=False)\n        \n        # Create meshgrids for kx and ky.\n        kx_grid, ky_grid = np.meshgrid(kx_vals, ky_vals, indexing='ij')\n\n        # Use broadcasting to compute D(theta, kx, ky) efficiently.\n        # Reshape arrays to (N_theta, 1, 1), (1, N_kx, N_ky), (1, N_kx, N_ky)\n        theta_r = theta_vals.reshape(-1, 1, 1)\n        kx_r = kx_grid.reshape(1, kx_grid.shape[0], kx_grid.shape[1])\n        ky_r = ky_grid.reshape(1, ky_grid.shape[0], ky_grid.shape[1])\n\n        # D(theta, kx, ky) = drive1 + drive2 - damping\n        diamagnetic_drive = p['omega_star'] * ky_r\n        curvature_drive = p['kappa'] * np.exp(-((theta_r - p['theta_0'])**2) / (2 * p['Delta']**2))\n        dissipation = p['nu'] * (kx_r**2 + ky_r**2)\n        \n        D_array = diamagnetic_drive + curvature_drive - dissipation\n        \n        # gamma is the supremum (max) over theta.\n        gamma = np.max(D_array, axis=0)\n        return gamma\n\n    def compute_Q(gamma_array, kx_vals, ky_vals, p):\n        \"\"\"\n        Computes the quasi-linear flux Q from a given gamma spectrum.\n\n        Args:\n            gamma_array (np.ndarray): 2D array of gamma values.\n            kx_vals (np.ndarray): 1D array of kx grid points.\n            ky_vals (np.ndarray): 1D array of ky grid points.\n            p (dict): Dictionary of physical parameters.\n\n        Returns:\n            float: The integrated quasi-linear flux Q.\n        \"\"\"\n        N_kx = len(kx_vals)\n        N_ky = len(ky_vals)\n        \n        kx_grid, ky_grid = np.meshgrid(kx_vals, ky_vals, indexing='ij')\n\n        # Spectral envelope A(kx, ky)\n        A = np.exp(-(kx_grid**2 + ky_grid**2) / p['k0']**2)\n        \n        # Integrand for the Q integral\n        integrand = ky_grid * np.maximum(0, gamma_array) * A\n        \n        # Uniform Riemann sum\n        delta_kx = (2 * p['K']) / N_kx\n        delta_ky = p['K'] / N_ky\n        \n        Q = np.sum(integrand) * delta_kx * delta_ky\n        return Q\n\n    # 1. Compute Reference Solution\n    N_theta_ref, N_kx_ref, N_ky_ref = ref_resolution.values()\n    \n    kx_ref_vals = np.linspace(-params['K'], params['K'], N_kx_ref, endpoint=False)\n    ky_ref_vals = np.linspace(0, params['K'], N_ky_ref, endpoint=False)\n    \n    gamma_ref_full = compute_gamma(kx_ref_vals, ky_ref_vals, N_theta_ref, params)\n    Q_ref = compute_Q(gamma_ref_full, kx_ref_vals, ky_ref_vals, params)\n\n    # List to store error pairs for each test case\n    error_results = []\n\n    # 2. Iterate through test cases\n    for N_theta_c, N_kx_c, N_ky_c in test_cases:\n        # Create coarse wavenumber grids\n        kx_c_vals = np.linspace(-params['K'], params['K'], N_kx_c, endpoint=False)\n        ky_c_vals = np.linspace(0, params['K'], N_ky_c, endpoint=False)\n        \n        # --- Calculate errors ---\n        \n        # a) For gamma error (eps_gamma):\n        # Compute gamma on the coarse k-grid using coarse N_theta.\n        gamma_c = compute_gamma(kx_c_vals, ky_c_vals, N_theta_c, params)\n        # Compute gamma on the coarse k-grid using reference N_theta.\n        gamma_ref_on_coarse = compute_gamma(kx_c_vals, ky_c_vals, N_theta_ref, params)\n        \n        # Calculate relative L2-norm error.\n        norm_diff_gamma = np.linalg.norm(gamma_c - gamma_ref_on_coarse)\n        norm_ref_gamma = np.linalg.norm(gamma_ref_on_coarse)\n        eps_gamma = norm_diff_gamma / norm_ref_gamma if norm_ref_gamma != 0 else 0.0\n\n        # b) For flux error (eps_Q):\n        # Compute Q on the coarse grid.\n        Q_c = compute_Q(gamma_c, kx_c_vals, ky_c_vals, params)\n        \n        # Calculate relative absolute error.\n        eps_Q = np.abs(Q_c - Q_ref) / np.abs(Q_ref) if Q_ref != 0 else 0.0\n\n        error_results.append([eps_gamma, eps_Q])\n\n    # 3. Format and print the final output\n    print(f\"[{','.join(str(r) for r in error_results)}]\")\n\nsolve()\n```"
        }
    ]
}