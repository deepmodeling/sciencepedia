{
    "hands_on_practices": [
        {
            "introduction": "在编写代码之前，理解算符的数学结构至关重要。本练习聚焦于各向同性福克-普朗克算符在速度空间原点（$v=0$）附近的行为，朴素的数值格式在此处可能会失效。通过完成这一解析推导，您将深入理解一个行为良好的解所需的正则性条件，这对于开发稳健的数值算法至关重要。",
            "id": "4202994",
            "problem": "考虑均匀磁化聚变等离子体中库仑碰撞的单一种类动力学模型，其中福克-普朗克（FP）碰撞算子仅在速度空间中作用。假设粒子分布函数在速度上是各向同性的，因此它只依赖于速率大小 $v = |\\boldsymbol{v}|$，即 $f = f(v)$。在球速度坐标系中，对于各向同性背景，FP碰撞算子可以写成守恒的径向形式\n$$\nC[f](v) \\;=\\; \\frac{1}{v^{2}} \\frac{d}{dv} \\left[ v^{2}\\left( A(v)\\, f(v) \\;+\\; D(v)\\, \\frac{df}{dv}(v) \\right) \\right],\n$$\n其中 $A(v)$ 是各向同性动力学摩擦系数，$D(v)$ 是各向同性速度空间扩散系数，两者均假定为 $v \\ge 0$ 时 $v$ 的光滑函数。假设在 $v=0$ 附近，以下奇/偶泰勒展开式成立：\n$$\nA(v) \\;=\\; a_{1}\\, v \\;+\\; a_{3}\\, v^{3} \\;+\\; \\mathcal{O}(v^{5}), \n\\qquad\nD(v) \\;=\\; d_{0} \\;+\\; d_{2}\\, v^{2} \\;+\\; \\mathcal{O}(v^{4}),\n$$\n且 $f$ 的各向同性和光滑性意味着一个偶函数展开\n$$\nf(v) \\;=\\; f_{0} \\;+\\; \\frac{f_{2}}{2}\\, v^{2} \\;+\\; \\mathcal{O}(v^{4}),\n$$\n其中常数 $a_{1}$、$a_{3}$、$d_{0}$、$d_{2}$、$f_{0}$ 和 $f_{2}$ 均与 $v$ 无关。仅使用上述正则性以及 $C[f]$ 的守恒结构，推导碰撞算子在原点的有限边界值，\n$$\n\\lim_{v \\to 0} C[f](v),\n$$\n用 $a_{1}$、$d_{0}$、$f_{0}$ 和 $f_{2}$ 表示。\n\n此外，解释为避免 $C[f]$ 中扩散贡献的奇异行为，在 $v=0$ 附近对 $f(v)$ 的最小正则性要求，同时考虑 $v^{-2}$ 前置因子和 $v^{2}$ 测度因子。你的最终数值结果必须是你得到的封闭形式解析表达式。最终答案中不需要单位。如果你引入了所述之外的任何近似，请明确说明理由。将最终答案表示为单个解析表达式。",
            "solution": "首先根据指定程序验证问题陈述。\n\n### 第一步：提取已知条件\n已知条件如下：\n1.  对于各向同性分布函数 $f(v)$ 的福克-普朗克（FP）碰撞算子：\n    $$\n    C[f](v) \\;=\\; \\frac{1}{v^{2}} \\frac{d}{dv} \\left[ v^{2}\\left( A(v)\\, f(v) \\;+\\; D(v)\\, \\frac{df}{dv}(v) \\right) \\right]\n    $$\n2.  速度 $v$ 是速度矢量的大小，$v = |\\boldsymbol{v}|$。\n3.  动力学摩擦系数 $A(v)$、速度空间扩散系数 $D(v)$ 和分布函数 $f(v)$ 在 $v=0$ 附近的泰勒展开：\n    $$\n    A(v) \\;=\\; a_{1}\\, v \\;+\\; a_{3}\\, v^{3} \\;+\\; \\mathcal{O}(v^{5})\n    $$\n    $$\n    D(v) \\;=\\; d_{0} \\;+\\; d_{2}\\, v^{2} \\;+\\; \\mathcal{O}(v^{4})\n    $$\n    $$\n    f(v) \\;=\\; f_{0} \\;+\\; \\frac{f_{2}}{2}\\, v^{2} \\;+\\; \\mathcal{O}(v^{4})\n    $$\n4.  常数 $a_{1}$、$a_{3}$、$d_{0}$、$d_{2}$、$f_{0}$ 和 $f_{2}$ 与 $v$ 无关。\n\n### 第二步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n-   **科学依据充分：** 该问题基于等离子体动力学理论中使用的标准福克-普朗克碰撞算子。守恒形式以及系数在原点附近的行为与已建立的库仑碰撞物理学一致。该问题是在此背景下的标准数学推导。\n-   **适定的：** 该问题提供了所有必要信息，并要求一个具体的、可推导的量。使用泰勒级数展开是分析函数在某点附近行为的标准且定义明确的数学技术。算子的守恒结构暗示了唯一有限极限的存在，这是其适定性的一个关键特征。\n-   **客观的：** 问题使用精确的数学语言和定义进行陈述。没有主观或模棱两可的术语。\n\n该问题不存在任何列出的缺陷：\n1.  它不违反科学原理。\n2.  它与福克-普朗克碰撞算子的主题直接相关。\n3.  它不是不完整或矛盾的。\n4.  对于处于热平衡或近平衡状态的碰撞等离子体，该设置在物理上是合理的。\n5.  它结构良好，能导向唯一的结果。\n6.  它并非微不足道；它需要仔细应用微积分和级数展开。\n7.  结果是数学上可验证的。\n\n### 第三步：结论与行动\n问题有效。将提供完整解答。\n\n为了求出碰撞算子 $C[f](v)$ 在 $v \\to 0$ 时的极限，我们将使用给定的泰勒级数展开来分析其结构。算子由下式给出：\n$$\nC[f](v) \\;=\\; \\frac{1}{v^{2}} \\frac{d}{dv} \\left[ v^{2}\\left( A(v)\\, f(v) \\;+\\; D(v)\\, \\frac{df}{dv}(v) \\right) \\right]\n$$\n让我们将导数内的项定义为速度空间粒子通量 $\\Gamma(v)$：\n$$\n\\Gamma(v) \\;=\\; v^{2}\\left( A(v)\\, f(v) \\;+\\; D(v)\\, \\frac{df}{dv}(v) \\right)\n$$\n然后，碰撞算子可以写成 $C[f](v) = \\frac{1}{v^{2}} \\frac{d\\Gamma(v)}{dv}$。为了评估 $v \\to 0$ 时的极限，我们必须首先找出 $\\Gamma(v)$ 在小 $v$ 时的行为。\n\n我们使用给定的 $A(v)$、$D(v)$ 和 $f(v)$ 的展开式。首先，我们需要 $f(v)$ 的导数：\n$$\nf(v) \\;=\\; f_{0} \\;+\\; \\frac{f_{2}}{2}\\, v^{2} \\;+\\; \\mathcal{O}(v^{4})\n$$\n$$\n\\frac{df}{dv}(v) \\;=\\; f_{2}\\, v \\;+\\; \\mathcal{O}(v^{3})\n$$\n$f(v)$ 的偶函数展开是基于 $f$ 是速度矢量 $\\boldsymbol{v}$ 的各向同性光滑函数的假设的结果，这意味着 $f$ 必须是 $v^2 = \\boldsymbol{v} \\cdot \\boldsymbol{v}$ 的光滑函数。\n\n现在，我们展开 $\\Gamma(v)$ 表达式中括号内的项：\n平流项为：\n$$\nA(v) f(v) = (a_{1}v + a_{3}v^{3} + \\mathcal{O}(v^{5})) \\left( f_{0} + \\frac{f_{2}}{2}v^{2} + \\mathcal{O}(v^{4}) \\right) = a_{1}f_{0}v + \\left(\\frac{a_{1}f_{2}}{2} + a_{3}f_{0}\\right)v^{3} + \\mathcal{O}(v^{5})\n$$\n扩散项为：\n$$\nD(v) \\frac{df}{dv}(v) = (d_{0} + d_{2}v^{2} + \\mathcal{O}(v^{4}))(f_{2}v + \\mathcal{O}(v^{3})) = d_{0}f_{2}v + d_{2}f_{2}v^{3} + \\mathcal{O}(v^{5})\n$$\n将这两项合并得到：\n$$\nA(v)f(v) + D(v)\\frac{df}{dv} = (a_{1}f_{0} + d_{0}f_{2})v + \\left(\\frac{a_{1}f_{2}}{2} + a_{3}f_{0} + d_{2}f_{2}\\right)v^{3} + \\mathcal{O}(v^{5})\n$$\n现在，我们通过乘以 $v^{2}$ 来构建通量 $\\Gamma(v)$：\n$$\n\\Gamma(v) = v^{2} \\left[ (a_{1}f_{0} + d_{0}f_{2})v + \\mathcal{O}(v^{3}) \\right] = (a_{1}f_{0} + d_{0}f_{2})v^{3} + \\mathcal{O}(v^{5})\n$$\n$\\Gamma(v)$ 是 $\\mathcal{O}(v^{3})$ 阶的事实是算子的守恒形式和函数在原点的正则性的直接结果。它确保了通过速度空间原点的粒子通量为零。\n\n接下来，我们对 $\\Gamma(v)$ 关于 $v$ 求导：\n$$\n\\frac{d\\Gamma(v)}{dv} = \\frac{d}{dv} \\left[ (a_{1}f_{0} + d_{0}f_{2})v^{3} + \\mathcal{O}(v^{5}) \\right] = 3(a_{1}f_{0} + d_{0}f_{2})v^{2} + \\mathcal{O}(v^{4})\n$$\n最后，我们将其代回 $C[f](v)$ 的表达式中：\n$$\nC[f](v) = \\frac{1}{v^{2}} \\left[ 3(a_{1}f_{0} + d_{0}f_{2})v^{2} + \\mathcal{O}(v^{4}) \\right] = 3(a_{1}f_{0} + d_{0}f_{2}) + \\mathcal{O}(v^{2})\n$$\n取 $v \\to 0$ 的极限：\n$$\n\\lim_{v \\to 0} C[f](v) = \\lim_{v \\to 0} \\left[ 3(a_{1}f_{0} + d_{0}f_{2}) + \\mathcal{O}(v^{2}) \\right] = 3(a_{1}f_{0} + d_{0}f_{2})\n$$\n\n对于问题的第二部分，我们分析为避免奇异性对 $f(v)$ 的正则性要求。潜在的奇异性来自 $1/v^2$ 前置因子。为了使算子在 $v=0$ 处保持有限，项 $\\frac{d\\Gamma(v)}{dv}$ 在 $v \\to 0$ 时必须至少是 $\\mathcal{O}(v^{2})$ 阶。这意味着通量 $\\Gamma(v)$ 必须至少是 $\\mathcal{O}(v^{3})$ 阶。\n\n我们关注通量中的扩散贡献，$\\Gamma_{D}(v) = v^{2}D(v)\\frac{df}{dv}$。在 $v=0$ 附近，$D(v) \\approx d_{0}$。所以，我们要求 $\\Gamma_{D}(v) \\approx d_{0} v^{2} \\frac{df}{dv}$ 至少为 $\\mathcal{O}(v^{3})$。这意味着：\n$$\nv^{2} \\frac{df}{dv} = \\mathcal{O}(v^{3}) \\implies \\frac{df}{dv} = \\mathcal{O}(v)\n$$\n如果 $\\frac{df}{dv} = \\mathcal{O}(v)$，我们可以将其级数展开写为 $\\frac{df}{dv} = c_{1}v + c_{3}v^{3} + \\dots$，其中 $c_{i}$ 为常数。对此式关于 $v$ 积分得到：\n$$\nf(v) = c_{0} + \\frac{c_{1}}{2}v^{2} + \\frac{c_{3}}{4}v^{4} + \\dots\n$$\n其中 $c_{0}$ 是积分常数。这是一个关于 $v$ 的偶次幂级数。这个结构正是问题陈述中为 $f(v)$ 给出的结构，其中 $f_{0}=c_0$，$f_{2}=c_1$。\n这一要求在物理上源于这样一个假设：分布函数 $f(\\boldsymbol{v})$ 在 $\\boldsymbol{v}=0$ 处是速度矢量 $\\boldsymbol{v}$ 的光滑（无限可微）和各向同性函数。各向同性意味着 $f$ 仅依赖于 $v=|\\boldsymbol{v}|$。在原点的光滑性意味着 $f(\\boldsymbol{v})$ 具有关于 $\\boldsymbol{v}$ 各分量的泰勒级数。对于一个各向同性函数，该级数必须是 $v^2 = v_x^2+v_y^2+v_z^2$ 的函数。因此，$f$ 以标量速率 $v$ 表示的展开式必须只包含 $v$ 的偶次幂。因此，对 $f(v)$ 的最小正则性要求是它必须是 $v$ 的偶函数，并且在 $v=0$ 处至少二阶可微，这确保了 $df/dv = \\mathcal{O}(v)$。\n如果这个条件被违反，例如，如果 $f(v)$ 的首项与 $v$ 成正比（在原点有一个“尖点”），那么当 $v \\to 0$ 时，$df/dv \\sim \\text{const}$，导致 $\\Gamma(v) \\sim v^2$ 和 $C[f](v) \\sim 1/v$，这是奇异的。\n\n因此，碰撞算子的极限值由分布函数展开的零阶和二阶系数，以及摩擦项和扩散项的主阶系数决定。",
            "answer": "$$\\boxed{3(a_{1}f_{0} + d_{0}f_{2})}$$"
        },
        {
            "introduction": "任何物理模型的基石都是其对基本守恒律的遵循。本练习将引导您从理论走向计算，要求您在一个双组分等离子体中数值验证动量守恒。从第一性原理出发实现这一验证测试，有助于培养在动理学方程离散化方面的基本技能，并且是任何碰撞算符代码的关键合理性检查。",
            "id": "4202948",
            "problem": "要求您在一个双组分等离子体中，验证 Fokker-Planck (FP) 碰撞算符的跨物种动量守恒性质，具体方法是在离散化的三维 (3D) 速度空间上构建数值近似，并对几组参数集进行检验，确保物种间的总动量交换在数值精度范围内相等且方向相反。控制动理学方程是包含物种间二元 FP 碰撞算符的 Boltzmann 方程，并且测试必须在不假设超出指定参数值的任何特殊对称性的情况下进行。\n\n请从以下基本概念开始：速度空间中分布函数的定义，碰撞中的质量、动量和能量守恒定律，以及 FP 算符在标准动理学理论中表示为速度空间中摩擦-扩散通量的散度的形式。对于物种 $a$ 和 $b$，其质量分别为 $m_a$ 和 $m_b$，数密度为 $n_a$ 和 $n_b$，平均流速为 $\\mathbf{u}_a$ 和 $\\mathbf{u}_b$，单位粒子的热能为 $\\Theta_a$ 和 $\\Theta_b$（等于玻尔兹曼常数乘以温度），考虑其分布函数 $f_a(\\mathbf{v})$ 和 $f_b(\\mathbf{v})$ 定义为漂移麦克斯韦分布：\n$$\nf_s(\\mathbf{v}) = \\frac{n_s}{\\pi^{3/2} v_{\\mathrm{th},s}^3} \\exp\\!\\left(-\\frac{\\left\\|\\mathbf{v} - \\mathbf{u}_s\\right\\|^2}{v_{\\mathrm{th},s}^2}\\right), \\quad v_{\\mathrm{th},s} = \\sqrt{\\frac{2 \\Theta_s}{m_s}}, \\quad s \\in \\{a,b\\}.\n$$\n使用与 Landau 算符不变量一致的各向同性拖拽-扩散通量来模拟二元 FP 碰撞算符 $C_{ab}[f_a,f_b]$：\n$$\nC_{ab}[f_a,f_b](\\mathbf{v}) = \\nabla_{\\mathbf{v}} \\cdot \\left( \\nu_{ab} \\left[ \\left(\\mathbf{v} - \\mathbf{u}_b \\right) f_a(\\mathbf{v}) + v_{\\mathrm{th},b}^2 \\nabla_{\\mathbf{v}} f_a(\\mathbf{v}) \\right] \\right),\n$$\n对于 $C_{ba}[f_b,f_a]$，其形式类似，只需交换参数并使用碰撞频率 $\\nu_{ba}$。上述形式，在 $\\nu_{ab}$ 和 $\\nu_{ba}$ 之间具有适当的对称性时，被广泛用作一种简化的 FP 算符，它能在麦克斯韦背景下保持碰撞不变量。\n\n您的任务是实现一个数值求解器，该求解器能够：\n- 在速度空间中构建一个均匀的笛卡尔网格，该网格覆盖立方体 $[-v_{\\max}, v_{\\max}]^3$，每个维度有 $N$ 个点，其中\n$$\nv_{\\max} = \\max\\left(\\left\\|\\mathbf{u}_a\\right\\|, \\left\\|\\mathbf{u}_b\\right\\|\\right) + 6 \\cdot \\max\\left(v_{\\mathrm{th},a}, v_{\\mathrm{th},b}\\right).\n$$\n- 在此网格上计算 $f_a(\\mathbf{v})$ 和 $f_b(\\mathbf{v})$。\n- 使用有限差分近似 $\\nabla_{\\mathbf{v}} f_s$，为 $C_{ab}$ 和 $C_{ba}$ 组装通量，并使用有限差分计算散度，通过假设通量在计算域外为零，在速度域的边界上施加有效的零通量边界条件。\n- 数值计算动量交换矢量\n$$\n\\mathbf{R}_{ab} = \\int m_a \\mathbf{v}\\, C_{ab}[f_a,f_b](\\mathbf{v})\\, d^3v, \\quad \\mathbf{R}_{ba} = \\int m_b \\mathbf{v}\\, C_{ba}[f_b,f_a](\\mathbf{v})\\, d^3v,\n$$\n通过网格上的黎曼和进行计算，并检查 $\\mathbf{R}_{ab} + \\mathbf{R}_{ba}$ 是否足够接近零矢量。\n\n使用对称性条件\n$$\n\\nu_{ba} = \\nu_{ab}\\, \\frac{m_a n_a}{m_b n_b},\n$$\n该条件强制了从 FP 算符矩方程中预期的动量守恒性质。所有量必须采用国际单位制 (SI)：质量单位为千克 (kg)，数密度单位为 $\\mathrm{m^{-3}}$，速度单位为 $\\mathrm{m/s}$，碰撞频率单位为 $\\mathrm{s^{-1}}$，单位粒子的热能 $\\Theta_s$ 单位为焦耳 (J)。角度不出现。程序应为每个测试用例报告一个布尔值，指示数值检验是否通过。\n\n为保证数值精度，每个维度至少使用 $N = 31$ 个点，并对 $\\mathbf{R}_{ab} + \\mathbf{R}_{ba}$ 的范数使用 $10^{-2}$ 的相对容差和 $10^{-8}$ 的绝对容差，范数通过除以 $\\|\\mathbf{R}_{ab}\\|$ 和 $\\|\\mathbf{R}_{ba}\\|$ 中的较大值进行归一化，以防止分母接近零。\n\n测试套件。实现以下四个测试用例，在未明确说明的情况下，使用上述对称性条件设置 $\\nu_{ba}$：\n- 情况1（电子-离子，不等流速）：$m_a = 1.67262192369 \\times 10^{-27}$，$n_a = 1.0 \\times 10^{19}$，$\\Theta_a = 2000$ 电子伏特，$\\mathbf{u}_a = (10^4, 0, 0)$；$m_b = 9.1093837015 \\times 10^{-31}$，$n_b = 1.0 \\times 10^{19}$，$\\Theta_b = 2000$ 电子伏特，$\\mathbf{u}_b = (0, 0, 0)$；$\\nu_{ab} = 5.0 \\times 10^{5}$。\n- 情况2（相同物种，相反流速）：$m_a = 1.67262192369 \\times 10^{-27}$，$n_a = 2.0 \\times 10^{19}$，$\\Theta_a = 500$ 电子伏特，$\\mathbf{u}_a = (0, 10^3, 0)$；$m_b = 1.67262192369 \\times 10^{-27}$，$n_b = 2.0 \\times 10^{19}$，$\\Theta_b = 800$ 电子伏特，$\\mathbf{u}_b = (0, -10^3, 0)$；$\\nu_{ab} = 1.0 \\times 10^{4}$ 且 $\\nu_{ba} = \\nu_{ab}$。\n- 情况3（零相对流速）：$m_a = 1.67262192369 \\times 10^{-27}$，$n_a = 1.0 \\times 10^{19}$，$\\Theta_a = 3000$ 电子伏特，$\\mathbf{u}_a = (0, 0, 0)$；$m_b = 9.1093837015 \\times 10^{-31}$，$n_b = 1.0 \\times 10^{19}$，$\\Theta_b = 3000$ 电子伏特，$\\mathbf{u}_b = (0, 0, 0)$；$\\nu_{ab} = 1.0 \\times 10^{6}$。\n- 情况4（弱碰撞，不等密度和流速）：$m_a = 1.67262192369 \\times 10^{-27}$，$n_a = 5.0 \\times 10^{19}$，$\\Theta_a = 400$ 电子伏特，$\\mathbf{u}_a = (2000, 3000, -1000)$；$m_b = 9.1093837015 \\times 10^{-31}$，$n_b = 1.0 \\times 10^{19}$，$\\Theta_b = 1000$ 电子伏特，$\\mathbf{u}_b = (-500, 0, 500)$；$\\nu_{ab} = 1.0$。\n\n电子伏特必须使用 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$ 转换为焦耳，以便 $\\Theta_s$ 以焦耳为单位使用。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{True}, \\text{False}, \\dots]$），结果顺序与上述四个测试用例的顺序完全一致。",
            "solution": "该问题要求对双组分等离子体中一个简化的 Fokker-Planck (FP) 碰撞算符的动量守恒性质进行数值验证。此任务的核心是计算由碰撞引起的总动量变化率，并根据基本物理原理检查其总和是否为零。在一个由两个相互作用的物种 $a$ 和 $b$ 组成的封闭系统中，动量守恒要求物种 $a$ 从 $b$ 获得的动量与物种 $b$ 从 $a$ 获得的动量大小相等、方向相反。这表示为 $\\mathbf{R}_{ab} + \\mathbf{R}_{ba} = \\mathbf{0}$，其中 $\\mathbf{R}_{st}$ 是从物种 $t$ 传递到物种 $s$ 的动量变化率。\n\n问题提供了必要的理论框架。物种由三维速度空间中的分布函数 $f_s(\\mathbf{v})$ 描述，具体为漂移麦克斯韦分布：\n$$\nf_s(\\mathbf{v}) = \\frac{n_s}{\\pi^{3/2} v_{\\mathrm{th},s}^3} \\exp\\!\\left(-\\frac{\\left\\|\\mathbf{v} - \\mathbf{u}_s\\right\\|^2}{v_{\\mathrm{th},s}^2}\\right)\n$$\n其中 $s \\in \\{a,b\\}$，$n_s$ 是数密度，$\\mathbf{u}_s$ 是平均流速，$v_{\\mathrm{th},s} = \\sqrt{2 \\Theta_s / m_s}$ 是与质量 $m_s$ 和单位粒子热能 $\\Theta_s$ 相关的热速度。\n\n相互作用由一个简化的 FP 碰撞算符 $C_{ab}[f_a, f_b]$ 建模，该算符描述了与物种 $b$ 的碰撞对分布函数 $f_a$ 的影响。该算符以散度形式给出，$C_{ab} = \\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}$，其中速度空间中的通量 $\\mathbf{J}_{ab}$ 为：\n$$\n\\mathbf{J}_{ab}(\\mathbf{v}) = \\nu_{ab} \\left[ \\left(\\mathbf{v} - \\mathbf{u}_b \\right) f_a(\\mathbf{v}) + v_{\\mathrm{th},b}^2 \\nabla_{\\mathbf{v}} f_a(\\mathbf{v}) \\right]\n$$\n此形式包含一个与 $(\\mathbf{v} - \\mathbf{u}_b)$ 成正比的拖拽项和一个与 $\\nabla_{\\mathbf{v}} f_a$ 成正比的扩散项。项 $C_{ba}$ 通过交换物种下标进行类似定义。\n\n动量交换率 $\\mathbf{R}_{ab}$ 是碰撞算符的一阶速度矩：\n$$\n\\mathbf{R}_{ab} = \\int m_a \\mathbf{v}\\, C_{ab}[f_a,f_b](\\mathbf{v})\\, d^3v = \\int m_a \\mathbf{v} \\left( \\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}(\\mathbf{v}) \\right) d^3v\n$$\n直接进行数值计算将涉及计算 $f_a$ 的二阶导数（因为 $\\mathbf{J}_{ab}$ 包含 $\\nabla_{\\mathbf{v}} f_a$），这在数值上容易出错。一种在动理学理论中常用、更稳健和优雅的方法是使用分部积分法（或三维中的散度定理）。假设通量 $\\mathbf{J}_{ab}$ 在积分域的边界上为零（这是由问题的设定和麦克斯韦分布的快速衰减所保证的条件），积分会大大简化。对于每个分量 $i \\in \\{x, y, z\\}$：\n$$\n\\int v_i (\\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}) d^3v = - \\int J_{ab,i} d^3v\n$$\n这导出了一个更稳定的动量交换率表达式，仅涉及 $f_a$ 的一阶导数：\n$$\n\\mathbf{R}_{ab} = -m_a \\int \\mathbf{J}_{ab}(\\mathbf{v})\\, d^3v\n$$\n我们的数值实现将采用这种方法。解析上，使用此形式和麦克斯韦分布的性质，可以证明 $\\mathbf{R}_{ab} = -m_a n_a \\nu_{ab}(\\mathbf{u}_a - \\mathbf{u}_b)$。为了使动量守恒，即 $\\mathbf{R}_{ab} + \\mathbf{R}_{ba} = \\mathbf{0}$，我们必须有 $m_a n_a \\nu_{ab} = m_b n_b \\nu_{ba}$，这正是问题中提供的对称性条件 $\\nu_{ba} = \\nu_{ab} (m_a n_a / m_b n_b)$。我们的任务是验证基于此框架的数值实现是否在给定容差内满足此守恒定律。\n\n数值计算步骤如下：\n1. 对于每个测试用例，我们首先确定物种 $a$ 和 $b$ 的物理参数，使用换算关系 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$ 将热能从电子伏特 (eV) 转换为焦耳 (J)。\n2. 构建一个三维笛卡尔速度网格。该网格跨越 $[-v_{\\max}, v_{\\max}]^3$ 范围，每个轴上有 $N=31$ 个点。区域大小 $v_{\\max}$ 的选择要足够大，以包含两个分布函数的主体部分：$v_{\\max} = \\max(\\|\\mathbf{u}_a\\|, \\|\\mathbf{u}_b\\|) + 6 \\cdot \\max(v_{\\mathrm{th},a}, v_{\\mathrm{th},b})$。网格间距为 $dv = 2 v_{\\max} / (N-1)$，积分的体积元为 $d^3v = (dv)^3$。\n3. 在这个三维网格的每个点上计算分布函数 $f_a(\\mathbf{v})$ 和 $f_b(\\mathbf{v})$。\n4. 对于每个物种对 $(a,b)$ 和 $(b,a)$，我们计算各自的动量交换率矢量 $\\mathbf{R}_{ab}$ 和 $\\mathbf{R}_{ba}$。这包括：\n    a. 使用 `numpy.gradient` 提供的二阶中心有限差分格式计算速度空间梯度 $\\nabla_{\\mathbf{v}} f_s$。\n    b. 使用上一步得到的梯度，组装通量矢量（例如 $\\mathbf{J}_{ab}$）的分量。\n    c. 使用黎曼和 ($\\mathbf{R}_{ab} = -m_a \\sum \\mathbf{J}_{ab} \\,d^3v$) 在整个速度域上对通量矢量进行积分，以获得动量交换矢量。\n5. 计算总动量交换 $\\mathbf{R}_{\\text{total}} = \\mathbf{R}_{ab} + \\mathbf{R}_{ba}$。\n6. 执行验证检查。如果总动量交换的范数 $\\|\\mathbf{R}_{\\text{total}}\\|$ 满足条件：$\\|\\mathbf{R}_{\\text{total}}\\| \\le 10^{-8}$ (绝对容差) 或 $\\|\\mathbf{R}_{\\text{total}}\\| / \\max(\\|\\mathbf{R}_{ab}\\|, \\|\\mathbf{R}_{ba}\\|) \\le 10^{-2}$ (相对容差)，则认为该性质得到了数值验证。这种双重条件可以恰当地处理预期交换接近零的情况。\n7. 记录 4 个测试用例中每个用例的布尔结果（True 或 False）。最终输出是这些布尔值的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Fokker-Planck momentum conservation test.\n    \"\"\"\n    \n    # Physical constants\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs, for eV to J conversion\n\n    def calculate_f(n, m, Theta, u, vx, vy, vz):\n        \"\"\"\n        Evaluates the shifted Maxwellian distribution function on the grid.\n        \"\"\"\n        if m == 0 or Theta == 0:\n            return np.zeros_like(vx)\n            \n        v_th = np.sqrt(2 * Theta / m)\n        norm_factor = n / (np.pi**1.5 * v_th**3)\n        v_minus_u_sq = (vx - u[0])**2 + (vy - u[1])**2 + (vz - u[2])**2\n        \n        exponent = -v_minus_u_sq / v_th**2\n        # Use a cutoff for exponent to prevent underflow issues leading to NaNs in gradients\n        f = norm_factor * np.exp(np.maximum(exponent, -100.0))\n        return f\n\n    def calculate_R(mass_A, f_A, dv, vx, vy, vz, params_B, nu_AB):\n        \"\"\"\n        Calculates the momentum exchange vector R_AB using integration by parts.\n        R_AB = -m_A * integral(J_AB d^3v)\n        \"\"\"\n        m_B, n_B, Theta_B, u_B = params_B\n        v_th_B = np.sqrt(2 * Theta_B / m_B) if m_B > 0 and Theta_B > 0 else 0.0\n        \n        # Calculate gradient of f_A using finite differences\n        grad_fA_list = np.gradient(f_A, dv, axis=(0, 1, 2))\n        grad_vx_fA, grad_vy_fA, grad_vz_fA = grad_fA_list[0], grad_fA_list[1], grad_fA_list[2]\n\n        # Assemble the flux vector J_AB\n        # J_AB = nu_AB * [ (v - u_B) * f_A + v_th_B^2 * grad_v(f_A) ]\n        Jx = nu_AB * ((vx - u_B[0]) * f_A + v_th_B**2 * grad_vx_fA)\n        Jy = nu_AB * ((vy - u_B[1]) * f_A + v_th_B**2 * grad_vy_fA)\n        Jz = nu_AB * ((vz - u_B[2]) * f_A + v_th_B**2 * grad_vz_fA)\n        \n        # Integrate flux components over the velocity domain using Riemann sum\n        d3v = dv**3\n        int_Jx = np.sum(Jx) * d3v\n        int_Jy = np.sum(Jy) * d3v\n        int_Jz = np.sum(Jz) * d3v\n        \n        # R_AB = -m_A * integral(J d3v)\n        R_vec = -mass_A * np.array([int_Jx, int_Jy, int_Jz])\n        \n        return R_vec\n\n    # Grid and tolerance parameters\n    N = 31\n    REL_TOL = 1e-2\n    ABS_TOL = 1e-8\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: electron-ion, unequal flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 1.0e19, 'Theta_eV': 2000, 'u': np.array([1e4, 0, 0])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 2000, 'u': np.array([0, 0, 0])},\n            'nu_ab': 5.0e5\n        },\n        # Case 2: identical species, opposite flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 2.0e19, 'Theta_eV': 500, 'u': np.array([0, 1e3, 0])},\n            'b': {'m': 1.67262192369e-27, 'n': 2.0e19, 'Theta_eV': 800, 'u': np.array([0, -1e3, 0])},\n            'nu_ab': 1.0e4\n        },\n        # Case 3: zero relative flow\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 1.0e19, 'Theta_eV': 3000, 'u': np.array([0, 0, 0])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 3000, 'u': np.array([0, 0, 0])},\n            'nu_ab': 1.0e6\n        },\n        # Case 4: weak collisions, unequal densities and flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 5.0e19, 'Theta_eV': 400, 'u': np.array([2000, 3000, -1000])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 1000, 'u': np.array([-500, 0, 500])},\n            'nu_ab': 1.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack and prepare parameters for species a and b\n        m_a, n_a, Theta_a_eV, u_a = case['a']['m'], case['a']['n'], case['a']['Theta_eV'], case['a']['u']\n        m_b, n_b, Theta_b_eV, u_b = case['b']['m'], case['b']['n'], case['b']['Theta_eV'], case['b']['u']\n        \n        Theta_a = Theta_a_eV * E_CHARGE\n        Theta_b = Theta_b_eV * E_CHARGE\n\n        params_a = (m_a, n_a, Theta_a, u_a)\n        params_b = (m_b, n_b, Theta_b, u_b)\n        \n        v_th_a = np.sqrt(2 * Theta_a / m_a)\n        v_th_b = np.sqrt(2 * Theta_b / m_b)\n        \n        nu_ab = case['nu_ab']\n        # Use symmetry condition unless m_b or n_b is zero\n        if m_b * n_b > 0:\n            nu_ba = nu_ab * (m_a * n_a) / (m_b * n_b)\n        else:\n            nu_ba = 0\n\n        # Set up velocity grid\n        v_max = max(np.linalg.norm(u_a), np.linalg.norm(u_b)) + 6 * max(v_th_a, v_th_b)\n        v_coords = np.linspace(-v_max, v_max, N)\n        dv = v_coords[1] - v_coords[0]\n        vx, vy, vz = np.meshgrid(v_coords, v_coords, v_coords, indexing='ij')\n\n        # Evaluate distribution functions on the grid\n        f_a = calculate_f(n_a, m_a, Theta_a, u_a, vx, vy, vz)\n        f_b = calculate_f(n_b, m_b, Theta_b, u_b, vx, vy, vz)\n\n        # Calculate momentum exchange vectors\n        R_ab = calculate_R(m_a, f_a, dv, vx, vy, vz, params_b, nu_ab)\n        R_ba = calculate_R(m_b, f_b, dv, vx, vy, vz, params_a, nu_ba)\n\n        # Check for momentum conservation\n        R_total = R_ab + R_ba\n        norm_total = np.linalg.norm(R_total)\n        norm_ab = np.linalg.norm(R_ab)\n        norm_ba = np.linalg.norm(R_ba)\n\n        denominator = max(norm_ab, norm_ba)\n        \n        # Check if the result is below absolute or relative tolerance\n        if denominator  1e-15: # Effectively zero, use only absolute tolerance\n            check_passed = norm_total = ABS_TOL\n        else:\n            check_passed = (norm_total = ABS_TOL) or (norm_total / denominator = REL_TOL)\n            \n        results.append(check_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的模拟必须处理诸如刚性（stiffness）之类的数值挑战，这会严重限制显式时间步进格式的效率。这个高级练习旨在解决此问题，它将指导您分析刚性问题，并使用 Scharfetter-Gummel 方法实现一个无条件稳定且保持正定性的隐式格式。掌握这项技术对于开发稳健且高效的动理学模拟代码至关重要。",
            "id": "4202992",
            "problem": "考虑在聚变等离子体湍流模拟中，由 Fokker–Planck 碰撞算子描述的单物种、一维速度空间中的碰撞弛豫过程。设 $f(v,t)$ 表示速度分布函数，其中速度 $v$ 的单位为 $\\mathrm{m/s}$，时间 $t$ 的单位为 $\\mathrm{s}$。假设碰撞算子为漂移-扩散类型，其碰撞频率为 $\\nu$（单位 $\\mathrm{s^{-1}}$），热速度为 $v_{\\mathrm{th}}$（单位 $\\mathrm{m/s}$）。该控制方程可以写成守恒形式，即速度空间中带有碰撞通量的连续性方程：\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0,\n$$\n其中通量 $J$ 体现了摩擦（漂移）和扩散两种效应。我们将速度域限制在有限区间 $v \\in [v_{\\min}, v_{\\max}]$ 内，并施加零通量边界条件 $J(v_{\\min},t)=J(v_{\\max},t)=0$，以确保计算域内的粒子数守恒。\n\n从基本原理出发——即上述守恒（连续性）形式以及速度空间中漂移和扩散的物理解释——回答以下任务：\n\n1. 通过分别确定与漂移和扩散过程相关的显式前向欧拉时间步进的稳定性约束，来分析碰撞项的刚性。你的分析必须从守恒形式以及漂移和扩散的定义开始，并推导出一个可操作的稳定性边界。在你的算法实现中，使用此边界定义最大显式时间步 $\\Delta t_{\\mathrm{exp}}$。在推导过程中，不得假设或引用任何非从第一性原理得到的预先推导出的公式。\n\n2. 提出一个无条件稳定的隐式时间步进格式，该格式允许时间步长大于 $\\Delta t_{\\mathrm{exp}}$，同时保持 $f$ 的非负性（正性）和粒子数守恒。在均匀网格上实现连续性方程 $\\partial_t f + \\partial_v J = 0$ 的有限体积离散化。使用 Scharfetter–Gummel (SG) 离散格式在单元交界面上构造数值通量（该格式通过在常系数假设下精确求解每个单元上的稳态一维漂移-扩散平衡来定义），已知该格式在与零通量边界耦合时能保持正性并产生守恒更新。使用后向欧拉方法进行隐式时间离散化。你的格式必须满足：\n   - 正性：如果对所有 $v$ 都有 $f(v,t^n)\\ge 0$，那么对所有 $v$ 都有 $f(v,t^{n+1})\\ge 0$。\n   - 粒子数守恒：在零通量边界条件下，$\\int_{v_{\\min}}^{v_{\\max}} f(v,t)\\,\\mathrm{d}v$ 随时间保持不变。\n\n3. 在一个完整的、可运行的程序中实现上述格式，该程序从 SG 通量构造离散算子矩阵，并从一个正的初始分布 $f_0(v)$ 开始执行一个隐式后向欧拉步。使用以下测试套件。在所有三种情况下，将初始条件定义为一维麦克斯韦分布\n$$\nf_0(v) = \\frac{n}{\\sqrt{\\pi}\\,v_{\\mathrm{th}}}\\,\\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right),\n$$\n其中密度 $n$ 的单位为 $\\mathrm{m^{-3}}$。区域是在 $[v_{\\min}, v_{\\max}]$ 上的均匀网格，包含 $N$ 个网格点，并采用零通量边界。对于每种情况，设置隐式时间步 $\\Delta t = m \\,\\Delta t_{\\mathrm{exp}}$，其中 $m$ 是一个乘数。在一个隐式步之后，评估正性和守恒性。\n\n- 情况 1（理想情况）：\n  - $N = 101$,\n  - $v_{\\min} = -5.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 5.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 5.0\\times 10^{6}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 1.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - 乘数 $m = 5$。\n\n- 情况 2（强刚性）：\n  - $N = 81$,\n  - $v_{\\min} = -7.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 7.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 2.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 7.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - 乘数 $m = 50$。\n\n- 情况 3（边界/粗网格边缘情况）：\n  - $N = 21$,\n  - $v_{\\min} = -4.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 4.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 1.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 8.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - 乘数 $m = 200$。\n\n算法要求：\n- Scharfetter–Gummel 通量必须通过求解每个具有常系数的单元上的稳态一维漂移-扩散平衡的精确解来导出，并使用局部界面速度在每个单元交界面上进行评估。实现必须确保在 $P\\to 0$ 时的相容性，其中 $P$ 表示界面单元的 Péclet 数。\n- 使用均匀网格间距 $\\,\\Delta v = (v_{\\max}-v_{\\min})/(N-1)\\,$。\n- 对于显式稳定性分析，从漂移和扩散约束中推导出 $\\Delta t_{\\mathrm{exp}}$，并取更严格的那个界限。\n\n在每个案例中，执行一个隐式步后，需要在代码中执行的验证任务：\n- 计算一个表示正性的布尔值，定义为 $\\min_i f_i^{n+1} \\ge -\\epsilon \\max_i f_i^{n+1}$，其中 $\\epsilon = 10^{-12}$。\n- 计算一个表示粒子数守恒的布尔值，定义为 $|\\sum_i f_i^{n+1}\\Delta v - \\sum_i f_i^{n}\\Delta v| \\le \\tau \\sum_i f_i^{n}\\Delta v$，其中容差 $\\tau = 10^{-6}$。\n- 计算并报告比率 $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$，以浮点数形式表示。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。该列表必须按顺序包含情况 1、情况 2、然后是情况 3 的结果，每个情况包括正性布尔值、守恒性布尔值和比率 $r$。输出中不应包含任何单位；所有布尔值和比率都是无量纲数。",
            "solution": "该问题被认为是有效的，因为它以动理论和等离子体物理学原理为科学基础，问题适定、客观，并包含获得唯一解所需的所有必要信息。它提出了一个计算物理学中关于 Fokker-Planck 方程数值解的标准问题。\n\n速度分布函数 $f(v, t)$ 的控制方程以守恒形式给出：\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0\n$$\n其中 $J$ 是速度空间中的碰撞通量。对于弛豫到热平衡状态的单物种，Fokker-Planck 碰撞算子可以建模为漂移-扩散形式。驱动分布函数趋向麦克斯韦分布 $f_M \\propto \\exp(-v^2 / v_{\\mathrm{th}}^2)$ 的通量 $J$ 由以下公式给出：\n$$\nJ(v,t) = -\\nu \\left( v f(v,t) + \\frac{v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v} \\right)\n$$\n此处，与 $v f$ 成正比的项是漂移（或摩擦）项，它将粒子拉向 $v=0$；与 $\\partial f / \\partial v$ 成正比的项是扩散项，它使分布展宽。参数包括碰撞频率 $\\nu$ 和热速度 $v_{\\mathrm{th}}$。可以验证，对于麦克斯韦分布，$J=0$，因此它是稳态解。\n\n该问题要求完成三项任务：对显式格式进行稳定性分析，设计并实现一个守恒且保正的隐式格式，以及在一系列测试案例上执行该格式。\n\n### 1. 显式时间步进的稳定性约束\n\n为了分析碰撞算子的刚性，我们使用前向欧拉方法对控制方程进行时间离散，并分别考察漂移项和扩散项所施加的稳定性约束。我们考虑一个间距为 $\\Delta v$ 的均匀速度网格 $v_i$。从时间 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的更新为 $f_i^{n+1} = f_i^n - \\frac{\\Delta t}{\\Delta v} (J_{i+1/2}^n - J_{i-1/2}^n)$。为了保证稳定性，我们要求 $f_i^{n+1}$ 表达式中 $f_j^n$ 的系数满足特定条件，以防止误差放大。\n\n**扩散约束：**\n方程的扩散部分是 $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v} \\left(\\frac{\\nu v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v}\\right)$。对于常数扩散系数 $D = \\frac{\\nu v_{\\mathrm{th}}^2}{2}$，这就是热方程 $\\frac{\\partial f}{\\partial t} = D \\frac{\\partial^2 f}{\\partial v^2}$。在时间上使用标准中心差分空间离散和前向欧拉法，我们得到：\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} = D \\frac{f_{i+1}^n - 2f_i^n + f_{i-1}^n}{(\\Delta v)^2}\n$$\n该格式的稳定性（例如，通过 von Neumann 分析或要求系数为正）已知受以下条件限制：\n$$\n\\Delta t \\le \\frac{(\\Delta v)^2}{2D} \\implies \\Delta t_{\\mathrm{diff}} \\le \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\n$$\n\n**漂移约束：**\n方程的漂移部分是 $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v}(\\nu v f)$。在守恒形式下，$\\frac{\\partial f}{\\partial t} + \\frac{\\partial J_{\\mathrm{drift}}}{\\partial v} = 0$，通量为 $J_{\\mathrm{drift}} = -\\nu v f$。这是一个具有空间依赖速度 $c(v) = -\\nu v$ 的线性平流方程。为保证稳定性，使用一阶迎风格式时，必须满足 Courant-Friedrichs-Lewy (CFL) 条件。对于显式平流格式，CFL 条件为：\n$$\n\\Delta t \\le \\frac{\\Delta v}{\\max |c(v)|}\n$$\n在我们的速度域 $v \\in [v_{\\min}, v_{\\max}]$ 中，最大平流速度为 $|c(v)|_{\\max} = \\nu \\max(|v_{\\min}|, |v_{\\max}|)$。设 $v_{\\mathrm{domain\\_max}} = \\max(|v_{\\min}|, |v_{\\max}|)$。则稳定性约束为：\n$$\n\\Delta t_{\\mathrm{drift}} \\le \\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}\n$$\n\n**最大显式时间步 $\\Delta t_{\\mathrm{exp}}$：**\n对于一个稳定的显式格式，两个条件都必须满足。因此，总的显式时间步受到两者中更严格的一个限制：\n$$\n\\Delta t_{\\mathrm{exp}} = \\min(\\Delta t_{\\mathrm{drift}}, \\Delta t_{\\mathrm{diff}}) = \\min\\left(\\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}, \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\\right)\n$$\n此边界用于定义隐式求解器的时间步。\n\n### 2. 隐式时间步进格式\n\n我们使用有限体积离散化、后向欧拉时间积分和 Scharfetter-Gummel 通量近似来实现一个无条件稳定的隐式格式。\n\n**有限体积离散化：**\n我们在一个包含 $N$ 个点 $v_i$（$i=0, \\dots, N-1$）的均匀网格上进行离散。第 $i$ 个有限体积为 $[v_i - \\Delta v/2, v_i + \\Delta v/2]$，中心在 $v_i$。交界面位于 $v_{i+1/2} = v_i + \\Delta v/2$。在第 $i$ 个单元上对连续性方程进行积分，得到：\n$$\n\\frac{d f_i}{d t} = -\\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta v}\n$$\n在时间上应用后向欧拉离散，得到：\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\n\n**Scharfetter-Gummel 通量：**\nSG 通量是通过求解网格单元 $[v_i, v_{i+1}]$ 上稳态、一维、常系数的漂移-扩散方程 $J = \\text{constant}$ 导出的。需要求解的方程是：\n$$\nJ_{i+1/2} = -\\nu \\left( v_{i+1/2} f(v) + D \\frac{df}{dv} \\right)\n$$\n其中 $D = v_{\\mathrm{th}}^2/2$，而 $v_{i+1/2}$ 是交界面上的速度。这是一个关于 $f(v)$ 的一阶线性常微分方程。用边界条件 $f(v_i)=f_i$ 和 $f(v_{i+1})=f_{i+1}$ 求解它，可以得到以单元边界值 $f_i$ 和 $f_{i+1}$ 表示的通量 $J_{i+1/2}$：\n$$\nJ_{i+1/2} = \\frac{\\nu D}{\\Delta v} \\left[ B(P_{i+1/2}) f_i - B(-P_{i+1/2}) f_{i+1} \\right]\n$$\n此处，$P_{i+1/2}$ 是局部 Péclet 数，它衡量漂移与扩散的比率：\n$$\nP_{i+1/2} = \\frac{v_{i+1/2} \\Delta v}{D} = \\frac{2 v_{i+1/2} \\Delta v}{v_{\\mathrm{th}}^2}\n$$\n而 $B(x) = x / (e^x - 1)$ 是伯努利函数。这种通量表达形式至关重要，因为它能正确地平衡漂移和扩散，并确保正性。\n\n**线性系统及其性质：**\n将 SG 通量代入后向欧拉方程，得到一个关于未知分布 $\\vec{f}^{n+1} = [f_0^{n+1}, \\dots, f_{N-1}^{n+1}]^T$ 的线性系统：\n$$\nM \\vec{f}^{n+1} = \\vec{f}^n\n$$\n矩阵 $M$ 是三对角的。零通量边界条件 $J(v_{\\min})=0$ 和 $J(v_{\\max})=0$ 通过将区域边界上的通量（即 $J_{-1/2}$ 和 $J_{N-1/2}$）设为零来实现。对于 $i,j \\in \\{0, \\dots, N-1\\}$，得到的矩阵元素如下：\n- 对于 $i \\in [1, N-2]$（内部点）：\n  - $M_{i,i-1} = -\\alpha B(P_{i-1/2})$\n  - $M_{i,i} = 1 + \\alpha (B(P_{i+1/2}) + B(-P_{i-1/2}))$\n  - $M_{i,i+1} = -\\alpha B(-P_{i+1/2})$\n- 对于 $i=0$（左边界）：\n  - $M_{0,0} = 1 + \\alpha B(P_{1/2})$\n  - $M_{0,1} = -\\alpha B(-P_{1/2})$\n- 对于 $i=N-1$（右边界）：\n  - $M_{N-1,N-2} = -\\alpha B(P_{N-3/2})$\n  - $M_{N-1,N-1} = 1 + \\alpha B(-P_{N-3/2})$\n其中 $\\alpha = \\frac{\\Delta t \\nu v_{\\mathrm{th}}^2}{2(\\Delta v)^2}$。\n\n**正性与守恒性：**\n伯努利函数 $B(x)$ 始终为正。因此，矩阵 $M$ 的对角线元素为正（$M_{ii}  1$），非对角线元素为非正（$i \\ne j$ 时 $M_{ij} \\le 0$）。此外，可以证明 $M$ 的每一列元素之和恰好为 1。这一性质源于通量的构造，确保了从一个单元流出的通量等于流入相邻单元的通量。因此，$\\sum_i M_{ij} = 1$，这意味着 $M$ 是一个列随机矩阵。\n\n具有这些性质的矩阵是一个 M-矩阵，其逆矩阵 $M^{-1}$ 的所有元素都为非负。因此，如果对所有 $i$ 都有 $f_i^n \\ge 0$，那么 $f_i^{n+1} = (M^{-1}\\vec{f}^n)_i \\ge 0$。该格式是保正的。\n\n粒子数守恒是由有限体积公式和零通量边界条件共同保证的。将离散方程对所有单元 $i=0, \\dots, N-1$ 求和：\n$$\n\\sum_i \\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\sum_i \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\n第二个和是一个伸缩级数：$\\sum_i (J_{i+1/2} - J_{i-1/2}) = J_{N-1/2} - J_{-1/2}$。根据边界条件 $J_{N-1/2}=0$ 和 $J_{-1/2}=0$，这个和为零。这导致 $\\sum_i (f_i^{n+1} - f_i^n) = 0$，即 $\\sum_i f_i^{n+1} \\Delta v = \\sum_i f_i^n \\Delta v$。总粒子数是守恒的。\n\n### 3. 算法实现\n\n该程序实现了上述推导的隐式格式。对于每个测试案例，它首先设置速度网格，计算 $\\Delta t_{\\mathrm{exp}}$ 和隐式时间步 $\\Delta t$，并定义初始的麦克斯韦分布。然后，通过计算每个界面上的 Péclet 数和伯努利函数来构造三对角矩阵 $M$。利用 `scipy.linalg.solve_banded` 高效地求解得到的线性系统。最后，程序对正性和粒子数守恒进行所需的检查，并计算比率 $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef bernoulli(x):\n    \"\"\"\n    Robust implementation of the Bernoulli function B(x) = x / (e^x - 1).\n    Uses a Taylor expansion for small |x| to avoid division by zero and floating point errors.\n    \"\"\"\n    if np.abs(x)  1e-9:\n        # Taylor series for B(x) around x=0: 1 - x/2 + x^2/12 - x^4/720 + ...\n        return 1.0 - x / 2.0 + x**2 / 12.0 - x**4 / 720.0\n    else:\n        return x / (np.exp(x) - 1.0)\n\ndef solve_case(N, v_min, v_max, nu, v_th, n, m):\n    \"\"\"\n    Solves one test case for the Fokker-Planck collision operator.\n    \"\"\"\n    # 1. Grid and Initial Condition\n    v = np.linspace(v_min, v_max, N)\n    delta_v = (v_max - v_min) / (N - 1)\n    \n    f_initial = (n / (np.sqrt(np.pi) * v_th)) * np.exp(-(v**2 / v_th**2))\n\n    # 2. Timestep Calculation (based on explicit stability)\n    v_domain_max = np.max(np.abs([v_min, v_max]))\n    # Stability from drift (CFL condition)\n    dt_drift = delta_v / (nu * v_domain_max)\n    # Stability from diffusion\n    dt_diff = delta_v**2 / (nu * v_th**2)\n    # The more restrictive of the two determines the explicit timestep limit\n    dt_exp = min(dt_drift, dt_diff)\n    \n    # Set the implicit timestep as a multiple of the explicit limit\n    delta_t = m * dt_exp\n\n    # 3. Assemble the Implicit Matrix M for M*f_next = f_initial\n    # Interface velocities (N-1 interfaces)\n    v_interfaces = v[:-1] + delta_v / 2.0\n    \n    # Péclet numbers at interfaces\n    peclet = (2.0 * v_interfaces * delta_v) / (v_th**2)\n    \n    # Constant term alpha\n    D_coeff = v_th**2 / 2.0\n    alpha = (delta_t * nu * D_coeff) / (delta_v**2)\n\n    # Scipy's solve_banded expects the matrix in `ab` format.\n    # For a tridiagonal matrix (l=1, u=1), ab has 3 rows:\n    # ab[0, 1:] = Super-diagonal\n    # ab[1, :]   = Main diagonal\n    # ab[2, :-1] = Sub-diagonal\n    ab = np.zeros((3, N))\n    \n    B_p = np.array([bernoulli(p) for p in peclet])\n    B_neg_p = np.array([bernoulli(-p) for p in peclet])\n    \n    # Main diagonal M_i,i\n    ab[1, 1:-1] = 1.0 + alpha * (B_p[1:] + B_neg_p[:-1])\n    ab[1, 0] = 1.0 + alpha * B_p[0] # Left boundary\n    ab[1, -1] = 1.0 + alpha * B_neg_p[-1] # Right boundary\n\n    # Super-diagonal M_i,i+1\n    ab[0, 1:] = -alpha * B_neg_p\n\n    # Sub-diagonal M_i,i-1\n    ab[2, :-1] = -alpha * B_p\n\n    # 4. Solve the linear system\n    f_next = solve_banded((1, 1), ab, f_initial)\n    \n    # 5. Validation Checks\n    # Positivity check\n    epsilon = 1e-12\n    # Ensure min(f_next) is not negative beyond a small tolerance relative to max(f_next)\n    positivity = bool(np.min(f_next) >= -epsilon * np.max(f_next))\n    \n    # Conservation check\n    tau = 1e-6\n    total_N_initial = np.sum(f_initial) * delta_v\n    total_N_final = np.sum(f_next) * delta_v\n    \n    if np.abs(total_N_initial)  1e-15: # Handle case of zero initial distribution\n        conservation = bool(np.abs(total_N_final - total_N_initial) = tau)\n    else:\n        conservation = bool(np.abs(total_N_final - total_N_initial) = tau * np.abs(total_N_initial))\n    \n    # Ratio of implicit to explicit timestep\n    ratio = delta_t / dt_exp\n    \n    return positivity, conservation, ratio\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\"N\": 101, \"v_min\": -5.0e5, \"v_max\": 5.0e5, \"nu\": 5.0e6, \"v_th\": 1.0e5, \"n\": 1.0e19, \"m\": 5},\n        # Case 2 (strong stiffness)\n        {\"N\": 81, \"v_min\": -7.0e5, \"v_max\": 7.0e5, \"nu\": 2.0e7, \"v_th\": 7.0e4, \"n\": 1.0e19, \"m\": 50},\n        # Case 3 (boundary/coarse-grid edge case)\n        {\"N\": 21, \"v_min\": -4.0e5, \"v_max\": 4.0e5, \"nu\": 1.0e7, \"v_th\": 8.0e4, \"n\": 1.0e19, \"m\": 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        pos, cons, r = solve_case(\n            N=case[\"N\"],\n            v_min=case[\"v_min\"],\n            v_max=case[\"v_max\"],\n            nu=case[\"nu\"],\n            v_th=case[\"v_th\"],\n            n=case[\"n\"],\n            m=case[\"m\"]\n        )\n        results.extend([pos, cons, r])\n\n    # Format the final output string exactly as required\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}