{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of physics is the law of conservation of momentum, which must be rigorously upheld in any valid physical simulation. This first practice provides a direct, hands-on test of this principle within the context of a two-species plasma. You will implement a numerical model to confirm that the Fokker-Planck operator correctly captures the equal and opposite exchange of momentum between interacting particle populations, a fundamental verification step for any multi-species kinetic code.",
            "id": "4202948",
            "problem": "You are asked to verify the cross-species momentum conservation property of the Fokker-Planck (FP) collision operator in a two-species plasma, by constructing a numerical approximation on a discretized three-dimensional (3D) velocity space and checking, for several parameter sets, that the total momentum exchange between species is equal and opposite to numerical precision. The governing kinetic equation is the Boltzmann equation with a binary FP collision operator between species, and the test must be performed without assuming any special symmetry beyond the specified parameter values.\n\nBegin from the following foundational bases: the definition of a distribution function in velocity space, the conservation laws for mass, momentum, and energy in collisions, and the standard kinetic theory form of the FP operator as a divergence in velocity space of a friction-diffusion flux. For species $a$ and $b$, with masses $m_a$ and $m_b$, number densities $n_a$ and $n_b$, mean flows $\\mathbf{u}_a$ and $\\mathbf{u}_b$, and thermal energies per particle $\\Theta_a$ and $\\Theta_b$ (equal to Boltzmann constant times temperature), consider distributions $f_a(\\mathbf{v})$ and $f_b(\\mathbf{v})$ defined as shifted Maxwellians:\n$$\nf_s(\\mathbf{v}) = \\frac{n_s}{\\pi^{3/2} v_{\\mathrm{th},s}^3} \\exp\\!\\left(-\\frac{\\left\\|\\mathbf{v} - \\mathbf{u}_s\\right\\|^2}{v_{\\mathrm{th},s}^2}\\right), \\quad v_{\\mathrm{th},s} = \\sqrt{\\frac{2 \\Theta_s}{m_s}}, \\quad s \\in \\{a,b\\}.\n$$\nModel the binary FP collision operator $C_{ab}[f_a,f_b]$ with an isotropic drag-diffusion flux consistent with the Landau operator invariants:\n$$\nC_{ab}[f_a,f_b](\\mathbf{v}) = \\nabla_{\\mathbf{v}} \\cdot \\left( \\nu_{ab} \\left[ \\left(\\mathbf{v} - \\mathbf{u}_b \\right) f_a(\\mathbf{v}) + v_{\\mathrm{th},b}^2 \\nabla_{\\mathbf{v}} f_a(\\mathbf{v}) \\right] \\right),\n$$\nand analogously for $C_{ba}[f_b,f_a]$ with parameters interchanged and a collision frequency $\\nu_{ba}$. The above form, with appropriate symmetry between $\\nu_{ab}$ and $\\nu_{ba}$, is widely used as a reduced FP operator that preserves collisional invariants for Maxwellian backgrounds.\n\nYour task is to implement a numerical solver that:\n- Constructs a uniform Cartesian grid in velocity space with $N$ points per dimension over a cube $[-v_{\\max}, v_{\\max}]^3$ where\n$$\nv_{\\max} = \\max\\left(\\left\\|\\mathbf{u}_a\\right\\|, \\left\\|\\mathbf{u}_b\\right\\|\\right) + 6 \\cdot \\max\\left(v_{\\mathrm{th},a}, v_{\\mathrm{th},b}\\right).\n$$\n- Evaluates $f_a(\\mathbf{v})$ and $f_b(\\mathbf{v})$ on this grid.\n- Approximates $\\nabla_{\\mathbf{v}} f_s$ by finite differences, assembles the flux for $C_{ab}$ and $C_{ba}$, and computes the divergence by finite differences, imposing an effective zero-flux boundary at the edges of the velocity domain by assuming the flux vanishes outside the computational domain.\n- Numerically computes the momentum exchange vectors\n$$\n\\mathbf{R}_{ab} = \\int m_a \\mathbf{v}\\, C_{ab}[f_a,f_b](\\mathbf{v})\\, d^3v, \\quad \\mathbf{R}_{ba} = \\int m_b \\mathbf{v}\\, C_{ba}[f_b,f_a](\\mathbf{v})\\, d^3v,\n$$\nvia Riemann sums on the grid, and checks whether $\\mathbf{R}_{ab} + \\mathbf{R}_{ba}$ is sufficiently close to the zero vector.\n\nUse the symmetry condition\n$$\n\\nu_{ba} = \\nu_{ab}\\, \\frac{m_a n_a}{m_b n_b},\n$$\nwhich enforces the momentum conservation property expected from the FP operator moment equations. All quantities must be in the International System of Units (SI): masses in kilograms, number densities in $\\mathrm{m}^{-3}$, velocities in $\\mathrm{m/s}$, collision frequencies in $\\mathrm{s}^{-1}$, and thermal energies per particle $\\Theta_s$ in Joules. Angles do not appear. The program should report boolean values, one per test case, indicating whether the numerical check passes.\n\nFor numerical precision, use at least $N = 31$ points per dimension and a relative tolerance of $10^{-2}$ together with an absolute tolerance of $10^{-8}$ on the norm of $\\mathbf{R}_{ab} + \\mathbf{R}_{ba}$, normalized by the larger of $\\|\\mathbf{R}_{ab}\\|$ and $\\|\\mathbf{R}_{ba}\\|$ to guard against near-zero denominators.\n\nTest suite. Implement the following four test cases, using the above symmetry to set $\\nu_{ba}$ wherever not explicitly stated:\n- Case $1$ (electron-ion, unequal flows): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 1.0 \\times 10^{19}$, $\\Theta_a = 2000$ electronvolts, $\\mathbf{u}_a = (10^4, 0, 0)$; $m_b = 9.1093837015 \\times 10^{-31}$, $n_b = 1.0 \\times 10^{19}$, $\\Theta_b = 2000$ electronvolts, $\\mathbf{u}_b = (0, 0, 0)$; $\\nu_{ab} = 5.0 \\times 10^{5}$.\n- Case $2$ (identical species, opposite flows): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 2.0 \\times 10^{19}$, $\\Theta_a = 500$ electronvolts, $\\mathbf{u}_a = (0, 10^3, 0)$; $m_b = 1.67262192369 \\times 10^{-27}$, $n_b = 2.0 \\times 10^{19}$, $\\Theta_b = 800$ electronvolts, $\\mathbf{u}_b = (0, -10^3, 0)$; $\\nu_{ab} = 1.0 \\times 10^{4}$ and $\\nu_{ba} = \\nu_{ab}$.\n- Case $3$ (zero relative flow): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 1.0 \\times 10^{19}$, $\\Theta_a = 3000$ electronvolts, $\\mathbf{u}_a = (0, 0, 0)$; $m_b = 9.1093837015 \\times 10^{-31}$, $n_b = 1.0 \\times 10^{19}$, $\\Theta_b = 3000$ electronvolts, $\\mathbf{u}_b = (0, 0, 0)$; $\\nu_{ab} = 1.0 \\times 10^{6}$.\n- Case $4$ (weak collisions, unequal densities and flows): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 5.0 \\times 10^{19}$, $\\Theta_a = 400$ electronvolts, $\\mathbf{u}_a = (2000, 3000, -1000)$; $m_b = 9.1093837015 \\times 10^{-31}$, $n_b = 1.0 \\times 10^{19}$, $\\Theta_b = 1000$ electronvolts, $\\mathbf{u}_b = (-500, 0, 500)$; $\\nu_{ab} = 1.0$.\n\nElectronvolts must be converted to Joules using $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$ so that $\\Theta_s$ is used in Joules. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[ \\text{True}, \\text{False}, \\dots ]$), in the exact order of the above four cases.",
            "solution": "The problem requires a numerical verification of the momentum conservation property for a simplified Fokker-Planck (FP) collision operator in a two-species plasma. The core of this task is to compute the total rate of momentum change due to collisions and check if it sums to zero, as dictated by fundamental physical principles. Momentum conservation in a closed system of two interacting species, $a$ and $b$, requires that the momentum gained by species $a$ from $b$ is equal and opposite to the momentum gained by species $b$ from $a$. This is expressed as $\\mathbf{R}_{ab} + \\mathbf{R}_{ba} = \\mathbf{0}$, where $\\mathbf{R}_{st}$ is the rate of momentum transfer to species $s$ from species $t$.\n\nThe problem provides the necessary theoretical framework. The species are described by distribution functions $f_s(\\mathbf{v})$ in $3$D velocity space, specifically as shifted Maxwellians:\n$$\nf_s(\\mathbf{v}) = \\frac{n_s}{\\pi^{3/2} v_{\\mathrm{th},s}^3} \\exp\\!\\left(-\\frac{\\left\\|\\mathbf{v} - \\mathbf{u}_s\\right\\|^2}{v_{\\mathrm{th},s}^2}\\right)\n$$\nwhere $s \\in \\{a,b\\}$, $n_s$ is the number density, $\\mathbf{u}_s$ is the mean flow velocity, and $v_{\\mathrm{th},s} = \\sqrt{2 \\Theta_s / m_s}$ is the thermal velocity associated with mass $m_s$ and thermal energy per particle $\\Theta_s$.\n\nThe interaction is modeled by a simplified FP collision operator, $C_{ab}[f_a, f_b]$, which describes the effect of collisions with species $b$ on the distribution function $f_a$. The operator is given in divergence form, $C_{ab} = \\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}$, where the flux $\\mathbf{J}_{ab}$ in velocity space is:\n$$\n\\mathbf{J}_{ab}(\\mathbf{v}) = \\nu_{ab} \\left[ \\left(\\mathbf{v} - \\mathbf{u}_b \\right) f_a(\\mathbf{v}) + v_{\\mathrm{th},b}^2 \\nabla_{\\mathbf{v}} f_a(\\mathbf{v}) \\right]\n$$\nThis form includes a drag term proportional to $(\\mathbf{v} - \\mathbf{u}_b)$ and a diffusion term proportional to $\\nabla_{\\mathbf{v}} f_a$. The term $C_{ba}$ is defined analogously by swapping the species indices.\n\nThe momentum exchange rate, $\\mathbf{R}_{ab}$, is the first velocity moment of the collision operator:\n$$\n\\mathbf{R}_{ab} = \\int m_a \\mathbf{v}\\, C_{ab}[f_a,f_b](\\mathbf{v})\\, d^3v = \\int m_a \\mathbf{v} \\left( \\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}(\\mathbf{v}) \\right) d^3v\n$$\nA direct numerical evaluation would involve computing second derivatives of $f_a$ (since $\\mathbf{J}_{ab}$ contains $\\nabla_{\\mathbf{v}} f_a$), which is numerically prone to error. A more robust and elegant method, common in kinetic theory, is to use integration by parts (or the divergence theorem in $3$D). Assuming the flux $\\mathbf{J}_{ab}$ vanishes at the boundaries of the integration domain (a condition enforced by the problem's setup and the rapid decay of the Maxwellian distributions), the integral simplifies significantly. For each component $i \\in \\{x, y, z\\}$:\n$$\n\\int v_i (\\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}) d^3v = - \\int J_{ab,i} d^3v\n$$\nThis leads to a much more stable expression for the momentum exchange rate, involving only first derivatives of $f_a$:\n$$\n\\mathbf{R}_{ab} = -m_a \\int \\mathbf{J}_{ab}(\\mathbf{v})\\, d^3v\n$$\nThis approach will be used in our numerical implementation. Analytically, using this form and properties of the Maxwellian distribution, one can show that $\\mathbf{R}_{ab} = -m_a n_a \\nu_{ab}(\\mathbf{u}_a - \\mathbf{u}_b)$. For momentum to be conserved, $\\mathbf{R}_{ab} + \\mathbf{R}_{ba} = \\mathbf{0}$, we must have $m_a n_a \\nu_{ab} = m_b n_b \\nu_{ba}$, which is precisely the symmetry condition $\\nu_{ba} = \\nu_{ab} (m_a n_a / m_b n_b)$ provided in the problem. Our task is to verify that a numerical implementation based on this framework satisfies this conservation law to a given tolerance.\n\nThe numerical procedure is as follows:\n$1$. For each test case, we first establish the physical parameters for species $a$ and $b$, converting thermal energies from electronvolts (eV) to Joules using the conversion $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$.\n$2$. A $3$D Cartesian velocity grid is constructed. The grid spans $[-v_{\\max}, v_{\\max}]^3$ with $N=31$ points along each axis. The domain size $v_{\\max}$ is chosen to be sufficiently large to contain the bulk of both distribution functions: $v_{\\max} = \\max(\\|\\mathbf{u}_a\\|, \\|\\mathbf{u}_b\\|) + 6 \\cdot \\max(v_{\\mathrm{th},a}, v_{\\mathrm{th},b})$. The grid spacing is $dv = 2 v_{\\max} / (N-1)$ and the volume element for integration is $d^3v = (dv)^3$.\n$3$. The distribution functions $f_a(\\mathbf{v})$ and $f_b(\\mathbf{v})$ are evaluated at each point on this $3$D grid.\n$4$. For each species pair $(a,b)$ and $(b,a)$, we compute the respective momentum exchange rate vectors $\\mathbf{R}_{ab}$ and $\\mathbf{R}_{ba}$. This involves:\n    a. Calculating the velocity-space gradient $\\nabla_{\\mathbf{v}} f_s$ using a second-order central finite difference scheme, provided by `numpy.gradient`.\n    b. Assembling the components of the flux vector, e.g., $\\mathbf{J}_{ab}$, using the gradients from the previous step.\n    c. Integrating the flux vector over the entire velocity domain using a Riemann sum ($\\mathbf{R}_{ab} = -m_a \\sum \\mathbf{J}_{ab} \\,d^3v$) to obtain the momentum exchange vector.\n$5$. The total momentum exchange $\\mathbf{R}_{\\text{total}} = \\mathbf{R}_{ab} + \\mathbf{R}_{ba}$ is computed.\n$6$. The validation check is performed. The property is considered numerically verified if the norm of the total momentum exchange, $\\|\\mathbf{R}_{\\text{total}}\\|$, satisfies the condition: $\\|\\mathbf{R}_{\\text{total}}\\| \\le 10^{-8}$ (absolute tolerance) OR $\\|\\mathbf{R}_{\\text{total}}\\| / \\max(\\|\\mathbf{R}_{ab}\\|, \\|\\mathbf{R}_{ba}\\|) \\le 10^{-2}$ (relative tolerance). This dual condition appropriately handles cases where the expected exchange is near zero.\n$7$. The boolean result of this check (True or False) is recorded for each of the $4$ test cases. The final output is a list of these boolean values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Fokker-Planck momentum conservation test.\n    \"\"\"\n    \n    # Physical constants\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs, for eV to J conversion\n\n    def calculate_f(n, m, Theta, u, vx, vy, vz):\n        \"\"\"\n        Evaluates the shifted Maxwellian distribution function on the grid.\n        \"\"\"\n        if m <= 0 or Theta <= 0:\n            return np.zeros_like(vx)\n            \n        v_th = np.sqrt(2 * Theta / m)\n        norm_factor = n / (np.pi**1.5 * v_th**3)\n        v_minus_u_sq = (vx - u[0])**2 + (vy - u[1])**2 + (vz - u[2])**2\n        \n        exponent = -v_minus_u_sq / v_th**2\n        # Use a cutoff for exponent to prevent underflow issues leading to NaNs in gradients\n        f = norm_factor * np.exp(np.maximum(exponent, -100.0))\n        return f\n\n    def calculate_R(mass_A, f_A, dv, vx, vy, vz, params_B, nu_AB):\n        \"\"\"\n        Calculates the momentum exchange vector R_AB using integration by parts.\n        R_AB = -m_A * integral(J_AB d^3v)\n        \"\"\"\n        m_B, n_B, Theta_B, u_B = params_B\n        v_th_B = np.sqrt(2 * Theta_B / m_B) if m_B > 0 and Theta_B > 0 else 0.0\n        \n        # Calculate gradient of f_A using finite differences\n        grad_fA_list = np.gradient(f_A, dv, axis=(0, 1, 2))\n        grad_vx_fA, grad_vy_fA, grad_vz_fA = grad_fA_list[0], grad_fA_list[1], grad_fA_list[2]\n\n        # Assemble the flux vector J_AB\n        # J_AB = nu_AB * [ (v - u_B) * f_A + v_th_B^2 * grad_v(f_A) ]\n        Jx = nu_AB * ((vx - u_B[0]) * f_A + v_th_B**2 * grad_vx_fA)\n        Jy = nu_AB * ((vy - u_B[1]) * f_A + v_th_B**2 * grad_vy_fA)\n        Jz = nu_AB * ((vz - u_B[2]) * f_A + v_th_B**2 * grad_vz_fA)\n        \n        # Integrate flux components over the velocity domain using Riemann sum\n        d3v = dv**3\n        int_Jx = np.sum(Jx) * d3v\n        int_Jy = np.sum(Jy) * d3v\n        int_Jz = np.sum(Jz) * d3v\n        \n        # R_AB = -m_A * integral(J d3v)\n        R_vec = -mass_A * np.array([int_Jx, int_Jy, int_Jz])\n        \n        return R_vec\n\n    # Grid and tolerance parameters\n    N = 31\n    REL_TOL = 1e-2\n    ABS_TOL = 1e-8\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: electron-ion, unequal flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 1.0e19, 'Theta_eV': 2000, 'u': np.array([1e4, 0, 0])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 2000, 'u': np.array([0, 0, 0])},\n            'nu_ab': 5.0e5\n        },\n        # Case 2: identical species, opposite flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 2.0e19, 'Theta_eV': 500, 'u': np.array([0, 1e3, 0])},\n            'b': {'m': 1.67262192369e-27, 'n': 2.0e19, 'Theta_eV': 800, 'u': np.array([0, -1e3, 0])},\n            'nu_ab': 1.0e4\n        },\n        # Case 3: zero relative flow\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 1.0e19, 'Theta_eV': 3000, 'u': np.array([0, 0, 0])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 3000, 'u': np.array([0, 0, 0])},\n            'nu_ab': 1.0e6\n        },\n        # Case 4: weak collisions, unequal densities and flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 5.0e19, 'Theta_eV': 400, 'u': np.array([2000, 3000, -1000])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 1000, 'u': np.array([-500, 0, 500])},\n            'nu_ab': 1.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack and prepare parameters for species a and b\n        m_a, n_a, Theta_a_eV, u_a = case['a']['m'], case['a']['n'], case['a']['Theta_eV'], case['a']['u']\n        m_b, n_b, Theta_b_eV, u_b = case['b']['m'], case['b']['n'], case['b']['Theta_eV'], case['b']['u']\n        \n        Theta_a = Theta_a_eV * E_CHARGE\n        Theta_b = Theta_b_eV * E_CHARGE\n\n        params_a = (m_a, n_a, Theta_a, u_a)\n        params_b = (m_b, n_b, Theta_b, u_b)\n        \n        v_th_a = np.sqrt(2 * Theta_a / m_a)\n        v_th_b = np.sqrt(2 * Theta_b / m_b)\n        \n        nu_ab = case['nu_ab']\n        # Use symmetry condition unless m_b or n_b is zero\n        if m_b * n_b > 0:\n            nu_ba = nu_ab * (m_a * n_a) / (m_b * n_b)\n        else:\n            nu_ba = 0\n\n        # Set up velocity grid\n        v_max = max(np.linalg.norm(u_a), np.linalg.norm(u_b)) + 6 * max(v_th_a, v_th_b)\n        v_coords = np.linspace(-v_max, v_max, N)\n        dv = v_coords[1] - v_coords[0]\n        vx, vy, vz = np.meshgrid(v_coords, v_coords, v_coords, indexing='ij')\n\n        # Evaluate distribution functions on the grid\n        f_a = calculate_f(n_a, m_a, Theta_a, u_a, vx, vy, vz)\n        f_b = calculate_f(n_b, m_b, Theta_b, u_b, vx, vy, vz)\n\n        # Calculate momentum exchange vectors\n        R_ab = calculate_R(m_a, f_a, dv, vx, vy, vz, params_b, nu_ab)\n        R_ba = calculate_R(m_b, f_b, dv, vx, vy, vz, params_a, nu_ba)\n\n        # Check for momentum conservation\n        R_total = R_ab + R_ba\n        norm_total = np.linalg.norm(R_total)\n        norm_ab = np.linalg.norm(R_ab)\n        norm_ba = np.linalg.norm(R_ba)\n\n        denominator = max(norm_ab, norm_ba)\n        \n        # Check if the result is below absolute or relative tolerance\n        if denominator < 1e-15: # Effectively zero, use only absolute tolerance\n            check_passed = norm_total <= ABS_TOL\n        else:\n            check_passed = (norm_total <= ABS_TOL) or (norm_total / denominator <= REL_TOL)\n            \n        results.append(check_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While verifying that a simulation respects physical laws is essential, designing a numerical scheme that guarantees these laws are conserved by its very structure is even more powerful. This practice guides you through the development of a finite-volume discretization for the Fokker-Planck operator. By focusing on the flux of particles between discrete velocity-space cells, this method ensures that particle number is perfectly conserved within the simulation domain, a property that holds true regardless of the specific physical parameters.",
            "id": "4202967",
            "problem": "You are to derive and implement a one-dimensional finite-volume discretization in the velocity coordinate that represents the Fokker-Planck collision operator in conservative form and ensures discrete conservation of particle number by imposing vanishing net flux at the velocity-space boundaries. Starting from first principles of conservation in phase space and the definition of drift-diffusion fluxes, construct a scheme on a possibly nonuniform grid that computes a semi-discrete time derivative for the cell-averaged distribution function.\n\nUse the following foundational base of laws and definitions, and nothing else:\n\n- Conservation of probability in velocity space states that the distribution function $f(v,t)$ obeys a conservation law of the form $\\partial f / \\partial t + \\partial J / \\partial v = 0$, where $J$ is a velocity-space flux.\n- For the Fokker-Planck collision operator, the flux $J$ is the sum of drift and diffusion contributions, with coefficients that may depend on $v$: specifically, $J(v,t) = -\\left(A(v)\\,f(v,t) + D(v)\\,\\frac{\\partial f}{\\partial v}(v,t)\\right)$, with $D(v) \\ge 0$.\n- The finite-volume method on a velocity-space partition integrates the conservation law over each control volume (cell) to relate the rate of change of the cell-averaged $f$ to the difference of fluxes through the bounding faces.\n- Discrete particle number conservation requires that the sum over all cells of the rate of change of the cell particle content equals the net flux through the domain boundaries, which must vanish if $J$ is set to zero at the boundaries.\n\nYour task is to:\n\n- Derive from the above base a finite-volume semi-discrete update for $f$ on a grid of cells indexed by $i$, with faces indexed by $j$, such that the discrete sum of particle content changes telescopes to the net boundary flux and vanishes when boundary fluxes are set to zero.\n- Specify a consistent evaluation of face fluxes for general $A(v)$ and $D(v)$, and for nonuniform grids, that makes the scheme conservative. You must not use any external formula other than what follows from the conservation law and the definitions above. You must choose a face representation for $f$ and a face representation for $\\partial f/\\partial v$ that is consistent with the integral finite-volume approach.\n- Implement a program that, given $A(v)$, $D(v)$, a grid, and an initial $f(v)$, computes the semi-discrete time derivative $\\partial f_i/\\partial t$ for each cell $i$ and returns the discrete time rate of change of the total particle number $N(t) = \\int f(v,t)\\,dv$, i.e., $dN/dt$, under zero-flux boundary conditions.\n\nAll variables are dimensionless: velocity $v$ is normalized by a reference thermal speed, time $t$ is normalized by a reference collision time, and the distribution $f$ is normalized such that its integral equals a dimensionless particle number. You must not introduce physical units.\n\nDesign test cases to validate different aspects of the scheme. Use the following test suite, where each case specifies the interval, the number of cells, the coefficient functions, and the initial distribution. In all cases, impose zero-flux boundary conditions by setting $J$ to zero at the domain faces. For each test case, compute the discrete $dN/dt$ resulting from your semi-discrete scheme.\n\n- Case $1$ (uniform grid, linear drift, constant diffusion, Maxwellian-like initial condition):\n  - Domain $v \\in [-5,5]$.\n  - Number of cells $N = 200$.\n  - Coefficients $A(v) = v$, $D(v) = 1$.\n  - Initial distribution $f(v) = \\frac{1}{\\sqrt{\\pi}}\\,\\exp(-v^2)$.\n\n- Case $2$ (nonuniform grid with fine central region, linear drift, constant diffusion, algebraic tail initial condition):\n  - Domain $v \\in [-6,6]$.\n  - Number of cells $N = 121$, constructed by partitioning into three contiguous segments with faces that yield $N_{\\text{left}} = 20$ cells in $[-6,-2]$, $N_{\\text{center}} = 81$ cells in $[-2,2]$, and $N_{\\text{right}} = 20$ cells in $[2,6]$.\n  - Coefficients $A(v) = v$, $D(v) = 1$.\n  - Initial distribution $f(v) = C\\,(1+v^2)^{-1}$, with $C$ chosen such that the discrete integral over the domain equals $1$.\n\n- Case $3$ (uniform grid, nonlinear drift, velocity-dependent diffusion, Gaussian initial condition):\n  - Domain $v \\in [-4,4]$.\n  - Number of cells $N = 64$.\n  - Coefficients $A(v) = v^3$, $D(v) = 1 + 0.5\\,v^2$.\n  - Initial distribution $f(v) = \\frac{1}{\\sqrt{2\\pi}}\\,\\exp\\left(-\\frac{v^2}{2}\\right)$.\n\n- Case $4$ (very coarse uniform grid, oscillatory drift, strictly positive diffusion, Gaussian initial condition):\n  - Domain $v \\in [-3,3]$.\n  - Number of cells $N = 5$.\n  - Coefficients $A(v) = \\sin(v)$, $D(v) = \\exp(-v^2) + 0.1$.\n  - Initial distribution $f(v) = \\exp\\left(-\\frac{v^2}{2}\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$, where each entry is the floating-point value of the computed discrete $dN/dt$ for the corresponding case. For example, the output format must be like $[x_1,x_2,x_3,x_4]$, where each $x_k$ is a float. The expectation for a correct method is that each $x_k$ equals zero within floating-point precision because the finite-volume telescoping guarantee under zero boundary flux must hold independent of the particular choice of $A(v)$, $D(v)$, grid, and $f(v)$.",
            "solution": "The problem requires the derivation and implementation of a one-dimensional finite-volume discretization for the Fokker-Planck collision operator. The scheme must be conservative, meaning it must uphold the conservation of particle number by design, which is tested by computing the total time rate of change of particle number, $dN/dt$, under zero-flux boundary conditions. The result is expected to be zero to within floating-point precision.\n\n### Step 1: Derivation of the Semi-Discrete Finite-Volume Scheme\n\nThe starting point is the one-dimensional conservation law for the distribution function $f(v, t)$ in velocity space:\n$$ \\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0 $$\nwhere $J(v,t)$ is the velocity-space flux. For the Fokker-Planck operator, this flux is given by a drift-diffusion form:\n$$ J(v,t) = -\\left(A(v)\\,f(v,t) + D(v)\\,\\frac{\\partial f}{\\partial v}(v,t)\\right) $$\nHere, $A(v)$ is the drift coefficient and $D(v)$ is the diffusion coefficient, with $D(v) \\ge 0$.\n\nTo formulate a finite-volume scheme, we partition the velocity domain $[v_{\\min}, v_{\\max}]$ into $N$ contiguous cells. Let the cell boundaries (faces) be located at positions $v_{i+1/2}$ for $i=0, 1, \\dots, N$, with $v_{1/2} = v_{\\min}$ and $v_{N+1/2} = v_{\\max}$. The $i$-th cell, for $i=1, \\dots, N$, occupies the interval $[v_{i-1/2}, v_{i+1/2}]$. The width of cell $i$ is $\\Delta v_i = v_{i+1/2} - v_{i-1/2}$. The grid can be non-uniform, so $\\Delta v_i$ may vary with $i$.\n\nWe integrate the conservation law over the $i$-th cell:\n$$ \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial f}{\\partial t} \\, dv + \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial J}{\\partial v} \\, dv = 0 $$\nLet's analyze each term. The first term, assuming smoothness, becomes the time derivative of the total number of particles in the cell:\n$$ \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial f}{\\partial t} \\, dv = \\frac{d}{dt} \\int_{v_{i-1/2}}^{v_{i+1/2}} f(v, t) \\, dv $$\nWe define the cell-averaged distribution function $f_i(t)$ as:\n$$ f_i(t) = \\frac{1}{\\Delta v_i} \\int_{v_{i-1/2}}^{v_{i+1/2}} f(v, t) \\, dv $$\nThus, the first term is $\\frac{d}{dt} (f_i(t) \\Delta v_i)$. Since the grid is static, this simplifies to $\\Delta v_i \\frac{d f_i}{dt}$.\n\nThe second term is integrated using the Fundamental Theorem of Calculus:\n$$ \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial J}{\\partial v} \\, dv = J(v_{i+1/2}, t) - J(v_{i-1/2}, t) $$\nLet $J_{i \\pm 1/2}$ denote the flux at the cell faces $v_{i \\pm 1/2}$. The integrated equation becomes:\n$$ \\Delta v_i \\frac{d f_i}{dt} + J_{i+1/2} - J_{i-1/2} = 0 $$\nRearranging gives the semi-discrete update rule for the cell-averaged distribution function $f_i$:\n$$ \\frac{d f_i}{dt} = -\\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta v_i} $$\nThis equation is the foundation of the finite-volume method. It states that the change in the average density in a cell is determined by the net flux through its boundaries.\n\n### Step 2: Proof of Discrete Particle Conservation\n\nThe total number of particles in the domain, $N(t)$, is the integral of $f(v,t)$ over the entire velocity space. In the discrete representation, it is the sum of particles in all cells:\n$$ N(t) = \\int_{v_{\\min}}^{v_{\\max}} f(v,t) \\, dv \\approx \\sum_{i=1}^{N} f_i(t) \\Delta v_i $$\nThe total rate of change of particle number is:\n$$ \\frac{dN}{dt} = \\frac{d}{dt} \\sum_{i=1}^{N} f_i \\Delta v_i = \\sum_{i=1}^{N} \\Delta v_i \\frac{d f_i}{dt} $$\nSubstituting the semi-discrete update rule:\n$$ \\frac{dN}{dt} = \\sum_{i=1}^{N} \\left( -(J_{i+1/2} - J_{i-1/2}) \\right) $$\nThis is a telescoping sum:\n$$ \\frac{dN}{dt} = -(J_{3/2} - J_{1/2}) - (J_{5/2} - J_{3/2}) - \\dots - (J_{N+1/2} - J_{N-1/2}) $$\n$$ \\frac{dN}{dt} = (J_{1/2} - J_{3/2}) + (J_{3/2} - J_{5/2}) + \\dots + (J_{N-1/2} - J_{N+1/2}) $$\nAll interior fluxes cancel out, leaving only the boundary fluxes:\n$$ \\frac{dN}{dt} = J_{1/2} - J_{N+1/2} $$\nHere, $J_{1/2}$ is the flux at the left boundary $v_{\\min}$ and $J_{N+1/2}$ is the flux at the right boundary $v_{\\max}$. The problem specifies zero-flux boundary conditions, which means $J_{1/2} = 0$ and $J_{N+1/2} = 0$. Therefore, the discrete scheme guarantees that:\n$$ \\frac{dN}{dt} = 0 $$\nThis property of conservation is built into the structure of the finite-volume method and holds irrespective of how the interior fluxes $J_{i+1/2}$ are approximated, as long as the flux leaving cell $i$ is identical to the flux entering cell $i+1$.\n\n### Step 3: Discretization of the Flux\n\nTo implement the scheme, we need a concrete expression for the flux $J_{i+1/2}$ at the face between cell $i$ and cell $i+1$. The flux depends on the values of $f$ and $\\partial f / \\partial v$ at the face. We approximate these using the cell-averaged values $f_i$ and $f_{i+1}$, which we associate with the cell centers $v_i$ and $v_{i+1}$.\n- Grid definitions:\n  - Face positions: $v_{i+1/2}$\n  - Cell centers: $v_i = (v_{i-1/2} + v_{i+1/2}) / 2$\n  - Cell widths: $\\Delta v_i = v_{i+1/2} - v_{i-1/2}$\n- Flux at face $v_{i+1/2}$:\n  $$ J_{i+1/2} = -\\left(A(v_{i+1/2})\\,f_{i+1/2} + D(v_{i+1/2})\\,\\left.\\frac{\\partial f}{\\partial v}\\right|_{i+1/2}\\right) $$\n- Approximations:\n  - The coefficients $A$ and $D$ are evaluated directly at the face: $A_{i+1/2} = A(v_{i+1/2})$ and $D_{i+1/2} = D(v_{i+1/2})$.\n  - The gradient of $f$ is approximated by a central difference between the adjacent cell centers:\n    $$ \\left.\\frac{\\partial f}{\\partial v}\\right|_{i+1/2} \\approx \\frac{f_{i+1} - f_i}{v_{i+1} - v_i} $$\n    For a non-uniform grid, the distance between cell centers is $v_{i+1} - v_i = (v_{i+1/2} + \\Delta v_{i+1}/2) - (v_{i+1/2} - \\Delta v_i/2) = (\\Delta v_i + \\Delta v_{i+1})/2$.\n  - The value of the distribution function at the face, $f_{i+1/2}$, for the advective term must be chosen carefully. A simple, robust, and conservative choice is the first-order upwind scheme. The value is taken from the \"upwind\" cell, i.e., the cell from which the \"flow\" (determined by the sign of $A$) originates.\n    $$ f_{i+1/2} = \\begin{cases} f_i & \\text{if } A_{i+1/2} \\ge 0 \\\\ f_{i+1} & \\text{if } A_{i+1/2} < 0 \\end{cases} $$\nThis completes the specification of the numerical scheme. The implementation will compute $dN/dt$ for the given test cases, which, based on this derivation, should be zero within floating-point tolerance.\n\n### Step 4: Implementation and Test Cases\n\nThe following Python code implements the derived conservative finite-volume scheme. It constructs the grid, defines the coefficient functions, initializes the distribution, calculates the fluxes at all interior faces using the upwind-advection and central-diffusion method described above, computes the semi-discrete time derivative for each cell, and finally sums these changes to find the total rate of change of particle number, $dN/dt$.\n\nThe logic is applied to the four specified test cases, each with different grids, coefficient functions, and initial distributions. The computed $dN/dt$ for each case is collected and printed. As proven, the results should be numerically indistinguishable from zero, demonstrating the particle-conserving nature of the algorithm. For case $2$, special care is taken to construct the non-uniform grid and normalize the initial distribution as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a 1D finite-volume scheme for the Fokker-Planck\n    operator and computes the rate of change of total particle number for\n    several test cases under zero-flux boundary conditions.\n    \"\"\"\n\n    def compute_dndt(domain, num_cells, grid_spec, A_func, D_func, f_func_init, normalize_f=False):\n        \"\"\"\n        Computes the discrete dN/dt for a single test case.\n\n        Args:\n            domain (tuple): (vmin, vmax) for the velocity domain.\n            num_cells (int): Total number of cells, N.\n            grid_spec (dict or None): Specification for non-uniform grid.\n            A_func (callable): Drift coefficient A(v).\n            D_func (callable): Diffusion coefficient D(v).\n            f_func_init (callable): Initial distribution function f(v,0).\n            normalize_f (bool): Flag to normalize the initial discrete distribution.\n\n        Returns:\n            float: The computed discrete dN/dt.\n        \"\"\"\n        vmin, vmax = domain\n\n        # 1. Construct the grid\n        if grid_spec is None:  # Uniform grid\n            v_faces = np.linspace(vmin, vmax, num_cells + 1)\n        else:  # Non-uniform grid for Case 2\n            partitions = grid_spec['partitions']\n            face_arrays = []\n            for i, p in enumerate(partitions):\n                p_vmin, p_vmax, p_ncells = p\n                # To concatenate correctly, don't include the last point,\n                # except for the very last partition.\n                include_last = (i == len(partitions) - 1)\n                num_points = p_ncells + 1 if include_last else p_ncells\n                face_arrays.append(np.linspace(p_vmin, p_vmax, p_ncells + 1)[:num_points])\n            v_faces = np.concatenate(face_arrays)\n        \n        # Cell properties\n        dv = v_faces[1:] - v_faces[:-1]\n        v_centers = 0.5 * (v_faces[1:] + v_faces[:-1])\n\n        # 2. Initialize the distribution function\n        f_vals = f_func_init(v_centers)\n        \n        if normalize_f:\n            total_N = np.sum(f_vals * dv)\n            f_vals /= total_N\n\n        # 3. Compute fluxes at interior faces\n        # Flux array size is N+1, for faces 0 to N.\n        # Boundary fluxes J_0 and J_N are zero.\n        fluxes = np.zeros(num_cells + 1)\n\n        # Loop over interior faces (indices 1 to N-1)\n        for j in range(1, num_cells):\n            # Face j is between cell j-1 (left) and cell j (right)\n            i_left, i_right = j - 1, j\n            \n            v_face = v_faces[j]\n            A_face = A_func(v_face)\n            D_face = D_func(v_face)\n            \n            f_left = f_vals[i_left]\n            f_right = f_vals[i_right]\n            \n            # Distance between adjacent cell centers for gradient calculation\n            dist_centers = v_centers[i_right] - v_centers[i_left]\n            \n            # Avoid division by zero if grid is pathologically coarse\n            if dist_centers == 0:\n                grad_f = 0.0\n            else:\n                 grad_f = (f_right - f_left) / dist_centers\n\n            # Upwind scheme for the advective part of the flux\n            if A_face >= 0:\n                f_face = f_left\n            else:\n                f_face = f_right\n                \n            fluxes[j] = -(A_face * f_face + D_face * grad_f)\n            \n        # 4. Compute df/dt for each cell\n        dfdt = -(fluxes[1:] - fluxes[:-1]) / dv\n\n        # 5. Compute the total dN/dt\n        # As derived, this is sum(dfdt * dv) = J_0 - J_N, which is 0.\n        # We compute it explicitly from dfdt to verify the implementation.\n        dndt = np.sum(dfdt * dv)\n        \n        return dndt\n\n    # --- Test Cases ---\n\n    # Case 1\n    case1_dndt = compute_dndt(\n        domain=(-5.0, 5.0),\n        num_cells=200,\n        grid_spec=None,\n        A_func=lambda v: v,\n        D_func=lambda v: 1.0,\n        f_func_init=lambda v: (1.0 / np.sqrt(np.pi)) * np.exp(-v**2)\n    )\n\n    # Case 2\n    case2_dndt = compute_dndt(\n        domain=(-6.0, 6.0),\n        num_cells=121,\n        grid_spec={\n            'partitions': [\n                (-6.0, -2.0, 20),\n                (-2.0, 2.0, 81),\n                (2.0, 6.0, 20)\n            ]},\n        A_func=lambda v: v,\n        D_func=lambda v: 1.0,\n        f_func_init=lambda v: 1.0 / (1.0 + v**2),\n        normalize_f=True\n    )\n    \n    # Case 3\n    case3_dndt = compute_dndt(\n        domain=(-4.0, 4.0),\n        num_cells=64,\n        grid_spec=None,\n        A_func=lambda v: v**3,\n        D_func=lambda v: 1.0 + 0.5 * v**2,\n        f_func_init=lambda v: (1.0 / np.sqrt(2.0 * np.pi)) * np.exp(-v**2 / 2.0)\n    )\n\n    # Case 4\n    case4_dndt = compute_dndt(\n        domain=(-3.0, 3.0),\n        num_cells=5,\n        grid_spec=None,\n        A_func=lambda v: np.sin(v),\n        D_func=lambda v: np.exp(-v**2) + 0.1,\n        f_func_init=lambda v: np.exp(-v**2 / 2.0)\n    )\n\n    results = [case1_dndt, case2_dndt, case3_dndt, case4_dndt]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A numerically conservative scheme is necessary, but not sufficient, for a practical simulation tool. The Fokker-Planck operator is notoriously 'stiff,' meaning that the vast range of timescales involved in collisional processes can force explicit time-integration schemes to use impractically small time steps to remain stable. This final exercise tackles this critical challenge by introducing an implicit, positivity-preserving solver based on the Scharfetter-Gummel flux discretization, an advanced technique essential for building efficient and robust simulation codes capable of handling realistic plasma parameters.",
            "id": "4202992",
            "problem": "Consider a single-species, one-dimensional velocity-space collisional relaxation in a fusion plasma turbulence simulation, described by the Fokker-Planck collision operator. Let $f(v,t)$ denote the velocity distribution function, with velocity $v$ measured in $\\mathrm{m/s}$ and time $t$ in $\\mathrm{s}$. Assume the collision operator is of drift–diffusion type, with a collision frequency $\\nu$ in $\\mathrm{s^{-1}}$ and a thermal speed $v_{\\mathrm{th}}$ in $\\mathrm{m/s}$. The governing equation can be cast in conservative form as a continuity equation in velocity space with a collisional flux:\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0,\n$$\nwhere the flux $J$ embodies both friction (drift) and diffusion effects. We restrict the velocity domain to a finite interval $v \\in [v_{\\min}, v_{\\max}]$ and impose zero-flux boundary conditions $J(v_{\\min},t)=J(v_{\\max},t)=0$ to ensure number conservation within the computational domain.\n\nStarting from fundamental principles—namely, the conservative (continuity) form above and the physical interpretation of drift and diffusion in velocity space—answer the following tasks:\n\n1. Analyze the stiffness of the collision term by identifying the explicit forward-Euler time-stepping stability constraints associated with the drift and diffusion processes separately. Your analysis must start from the conservative form and the definitions of drift and diffusion, and proceed to a stability bound that can be operationalized. In your algorithmic implementation, use this bound to define a maximum explicit timestep $\\,\\Delta t_{\\mathrm{exp}}\\,$. Do not assume or cite any pre-derived formula not obtained from first principles in your derivation.\n\n2. Propose an unconditionally stable implicit time-stepping scheme that permits timesteps larger than $\\,\\Delta t_{\\mathrm{exp}}\\,$, while preserving non-negativity (positivity) of $f$ and number conservation. Implement a finite-volume discretization of the continuity equation $\\,\\partial_t f + \\partial_v J = 0\\,$ on a uniform mesh. Construct the numerical flux at cell interfaces using the Scharfetter–Gummel (SG) discretization (defined by solving the steady one-dimensional drift–diffusion balance exactly over each cell under constant-coefficient assumption), which is known to preserve positivity and yield conservative updates when coupled with zero-flux boundaries. Time-discretize implicitly with backward Euler. Your scheme must satisfy:\n   - Positivity: if $f(v,t^n)\\ge 0$ for all $v$, then $f(v,t^{n+1})\\ge 0$ for all $v$.\n   - Number conservation: $\\int_{v_{\\min}}^{v_{\\max}} f(v,t)\\,\\mathrm{d}v$ remains constant in time under zero-flux boundary conditions.\n\n3. Implement the above scheme in a complete, runnable program that constructs the discrete operator matrix from the SG flux and performs one implicit backward Euler step from a positive initial distribution $f_0(v)$. Use the following test suite. In all three cases, define the initial condition as the one-dimensional Maxwellian\n$$\nf_0(v) = \\frac{n}{\\sqrt{\\pi}\\,v_{\\mathrm{th}}}\\,\\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right),\n$$\nwith density $n$ measured in $\\mathrm{m^{-3}}$. The domain is uniform with $N$ grid points over $[v_{\\min}, v_{\\max}]$ and zero-flux boundaries. For each case, set the implicit timestep $\\,\\Delta t = m \\,\\Delta t_{\\mathrm{exp}}\\,$ where $m$ is a multiplier. Evaluate positivity and conservation after one implicit step.\n\n- Case 1 (happy path):\n  - $N = 101$,\n  - $v_{\\min} = -5.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 5.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 5.0\\times 10^{6}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 1.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - multiplier $m = 5$.\n\n- Case 2 (strong stiffness):\n  - $N = 81$,\n  - $v_{\\min} = -7.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 7.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 2.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 7.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - multiplier $m = 50$.\n\n- Case 3 (boundary/coarse-grid edge case):\n  - $N = 21$,\n  - $v_{\\min} = -4.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 4.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 1.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 8.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - multiplier $m = 200$.\n\nAlgorithmic requirements:\n- The Scharfetter–Gummel flux must be derived from the exact solution of the steady one-dimensional drift–diffusion balance on each cell with constant coefficients, and evaluated at each cell interface using the local interface velocity. The implementation must ensure consistency at $P\\to 0$ where $P$ denotes the interface cell Péclet number.\n- Use uniform grid spacing $\\,\\Delta v = (v_{\\max}-v_{\\min})/(N-1)\\,$.\n- For the explicit stability analysis, derive $\\,\\Delta t_{\\mathrm{exp}}\\,$ from the drift and diffusion constraints and take the more restrictive bound.\n\nValidation tasks to perform in code for each case after one implicit step:\n- Compute a boolean indicating positivity, defined as $\\min_i f_i^{n+1} \\ge -\\epsilon \\max_i f_i^{n+1}$ with $\\epsilon = 10^{-12}$.\n- Compute a boolean indicating number conservation, defined as $\\left|\\sum_i f_i^{n+1}\\Delta v - \\sum_i f_i^{n}\\Delta v\\right| \\le \\tau \\sum_i f_i^{n}\\Delta v$ with tolerance $\\tau = 10^{-6}$.\n- Compute and report the ratio $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$ as a floating-point number.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). The list must contain, in order, for Case 1 then Case 2 then Case 3, the positivity boolean, the conservation boolean, and the ratio $r$ for each case. No units should be included in the output; all booleans and ratios are dimensionless numbers.",
            "solution": "The governing equation for the velocity distribution function $f(v, t)$ is given in conservative form:\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0\n$$\nwhere $J$ is the collisional flux in velocity space. For a single species relaxing towards a thermal equilibrium, the Fokker-Planck collision operator can be modeled in a drift-diffusion form. The flux $J$ that drives the distribution towards a Maxwellian $f_M \\propto \\exp(-v^2 / v_{\\mathrm{th}}^2)$ is given by:\n$$\nJ(v,t) = -\\nu \\left( v f(v,t) + \\frac{v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v} \\right)\n$$\nHere, the term proportional to $v f$ is a drift (or friction) term, which pulls particles towards $v=0$, and the term proportional to $\\partial f / \\partial v$ is a diffusion term, which spreads the distribution. The parameters are the collision frequency $\\nu$ and the thermal speed $v_{\\mathrm{th}}$. It can be verified that $J=0$ for a Maxwellian distribution, making it the steady-state solution.\n\nThe problem asks for three tasks: a stability analysis of an explicit scheme, the design and implementation of a conservative and positivity-preserving implicit scheme, and the execution of this scheme on a suite of test cases.\n\n### 1. Explicit Time-Stepping Stability Constraints\n\nTo analyze the stiffness of the collision operator, we discretize the governing equation using a forward Euler method in time and examine the stability constraints imposed by the drift and diffusion terms separately. We consider a uniform velocity grid $v_i$ with spacing $\\Delta v$. The update from time $t^n$ to $t^{n+1} = t^n + \\Delta t$ is $f_i^{n+1} = f_i^n - \\frac{\\Delta t}{\\Delta v} (J_{i+1/2}^n - J_{i-1/2}^n)$. For stability, we require that the coefficients of $f_j^n$ in the expression for $f_i^{n+1}$ satisfy certain conditions to prevent amplification of errors.\n\n**Diffusion Constraint:**\nThe diffusion part of the equation is $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v} \\left(\\frac{\\nu v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v}\\right)$. For a constant diffusion coefficient $D = \\frac{\\nu v_{\\mathrm{th}}^2}{2}$, this is the heat equation $\\frac{\\partial f}{\\partial t} = D \\frac{\\partial^2 f}{\\partial v^2}$. Using a standard central difference spatial discretization and forward Euler in time, we have:\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} = D \\frac{f_{i+1}^n - 2f_i^n + f_{i-1}^n}{(\\Delta v)^2}\n$$\nThe stability of this scheme (e.g., from von Neumann analysis or by requiring positivity of coefficients) is known to be bounded by:\n$$\n\\Delta t \\le \\frac{(\\Delta v)^2}{2D} \\implies \\Delta t_{\\mathrm{diff}} \\le \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\n$$\n\n**Drift Constraint:**\nThe drift part of the equation is $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v}(\\nu v f)$. In conservative form, $\\frac{\\partial f}{\\partial t} + \\frac{\\partial J_{\\mathrm{drift}}}{\\partial v} = 0$, with flux $J_{\\mathrm{drift}} = -\\nu v f$. This is a linear advection equation with a space-dependent velocity $c(v) = -\\nu v$. Using a first-order upwind scheme for stability, the Courant-Friedrichs-Lewy (CFL) condition must be satisfied. The CFL condition for an explicit advection scheme is:\n$$\n\\Delta t \\le \\frac{\\Delta v}{\\max |c(v)|}\n$$\nIn our velocity domain $v \\in [v_{\\min}, v_{\\max}]$, the maximum advection speed is $|c(v)|_{\\max} = \\nu \\max(|v_{\\min}|, |v_{\\max}|)$. Let $v_{\\mathrm{domain\\_max}} = \\max(|v_{\\min}|, |v_{\\max}|)$. The stability constraint is then:\n$$\n\\Delta t_{\\mathrm{drift}} \\le \\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}\n$$\n\n**Maximum Explicit Timestep $\\Delta t_{\\mathrm{exp}}$:**\nFor a stable explicit scheme, both conditions must be met. Therefore, the overall explicit timestep is limited by the more restrictive of the two:\n$$\n\\Delta t_{\\mathrm{exp}} = \\min(\\Delta t_{\\mathrm{drift}}, \\Delta t_{\\mathrm{diff}}) = \\min\\left(\\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}, \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\\right)\n$$\nThis bound is used to define the timestep for the implicit solver.\n\n### 2. Implicit Time-Stepping Scheme\n\nWe implement an unconditionally stable implicit scheme using a finite-volume discretization, backward Euler for time integration, and the Scharfetter-Gummel flux approximation.\n\n**Finite-Volume Discretization:**\nWe discretize on a uniform grid with $N$ points $v_i$ for $i=0, \\dots, N-1$. The $i$-th finite volume is $[v_i - \\Delta v/2, v_i + \\Delta v/2]$, centered at $v_i$. The interfaces are at $v_{i+1/2} = v_i + \\Delta v/2$. Integrating the continuity equation over the $i$-th cell gives:\n$$\n\\frac{d f_i}{d t} = -\\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta v}\n$$\nApplying backward Euler discretization in time yields:\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\n\n**Scharfetter-Gummel Flux:**\nThe SG flux is derived by solving the steady-state, one-dimensional drift-diffusion equation $J = \\text{constant}$ across a grid cell $[v_i, v_{i+1}]$, assuming constant coefficients. The equation to solve is:\n$$\nJ_{i+1/2} = -\\nu \\left( v_{i+1/2} f(v) + D \\frac{df}{dv} \\right)\n$$\nwhere $D = v_{\\mathrm{th}}^2/2$, and $v_{i+1/2}$ is the velocity at the interface. This is a first-order linear ODE for $f(v)$. Solving it with boundary conditions $f(v_i)=f_i$ and $f(v_{i+1})=f_{i+1}$ yields the flux $J_{i+1/2}$ in terms of the cell-edge values $f_i$ and $f_{i+1}$:\n$$\nJ_{i+1/2} = \\frac{\\nu D}{\\Delta v} \\left[ B(P_{i+1/2}) f_i - B(-P_{i+1/2}) f_{i+1} \\right]\n$$\nHere, $P_{i+1/2}$ is the local Péclet number, which measures the ratio of drift to diffusion:\n$$\nP_{i+1/2} = \\frac{v_{i+1/2} \\Delta v}{D} = \\frac{2 v_{i+1/2} \\Delta v}{v_{\\mathrm{th}}^2}\n$$\nand $B(x) = x / (e^x - 1)$ is the Bernoulli function. This flux formulation is crucial as it correctly balances drift and diffusion and ensures positivity.\n\n**Linear System and Properties:**\nSubstituting the SG flux into the backward Euler equation results in a linear system for the unknown distribution $\\vec{f}^{n+1} = [f_0^{n+1}, \\dots, f_{N-1}^{n+1}]^T$:\n$$\nM \\vec{f}^{n+1} = \\vec{f}^n\n$$\nThe matrix $M$ is tridiagonal. The zero-flux boundary conditions $J(v_{\\min})=0$ and $J(v_{\\max})=0$ are implemented by setting the fluxes at the domain boundaries to zero, i.e., $J_{-1/2} = 0$ and $J_{N-1/2} = 0$. The resulting matrix entries for $i,j \\in \\{0, \\dots, N-1\\}$ are:\n- For $i \\in [1, N-2]$ (interior points):\n  - $M_{i,i-1} = -\\alpha B(P_{i-1/2})$\n  - $M_{i,i} = 1 + \\alpha (B(P_{i+1/2}) + B(-P_{i-1/2}))$\n  - $M_{i,i+1} = -\\alpha B(-P_{i+1/2})$\n- For $i=0$ (left boundary):\n  - $M_{0,0} = 1 + \\alpha B(P_{1/2})$\n  - $M_{0,1} = -\\alpha B(-P_{1/2})$\n- For $i=N-1$ (right boundary):\n  - $M_{N-1,N-2} = -\\alpha B(P_{N-3/2})$\n  - $M_{N-1,N-1} = 1 + \\alpha B(-P_{N-3/2})$\nwhere $\\alpha = \\frac{\\Delta t \\nu v_{\\mathrm{th}}^2}{2(\\Delta v)^2}$.\n\n**Positivity and Conservation:**\nThe Bernoulli function $B(x)$ is always positive. Consequently, the matrix $M$ has positive diagonal entries ($M_{ii} > 1$) and non-positive off-diagonal entries ($M_{ij} \\le 0$ for $i \\ne j$). This makes it a diagonally dominant L-matrix. A key property of such matrices is that their inverse, $M^{-1}$, will have all non-negative entries. Therefore, if the distribution at the previous step is non-negative ($f_i^n \\ge 0$ for all $i$), the new distribution will also be non-negative: $f_i^{n+1} = (M^{-1}\\vec{f}^n)_i \\ge 0$. The scheme is thus positivity-preserving.\n\nNumber conservation is ensured by the finite-volume formulation with zero-flux boundaries. Summing the discrete equation over all cells $i=0, \\dots, N-1$:\n$$\n\\sum_i \\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\sum_i \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\nThe second sum is a telescoping series: $\\sum_i (J_{i+1/2} - J_{i-1/2}) = J_{N-1/2} - J_{-1/2}$. With boundary conditions $J_{N-1/2}=0$ and $J_{-1/2}=0$, this sum vanishes. This leads to $\\sum_i (f_i^{n+1} - f_i^n) = 0$, which implies $\\sum_i f_i^{n+1} \\Delta v = \\sum_i f_i^n \\Delta v$. The total number of particles is conserved exactly by the discrete scheme.\n\n### 3. Algorithmic Implementation\n\nThe program implements the derived implicit scheme. For each test case, it sets up the velocity grid, calculates $\\Delta t_{\\mathrm{exp}}$ and the implicit $\\Delta t$, and defines the initial Maxwellian distribution. It then constructs the tridiagonal matrix $M$ by computing the Péclet numbers and evaluating the Bernoulli function at each interface. The resulting linear system is efficiently solved using `scipy.linalg.solve_banded`. Finally, it performs the required checks for positivity and number conservation and computes the ratio $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef bernoulli(x):\n    \"\"\"\n    Robust implementation of the Bernoulli function B(x) = x / (e^x - 1).\n    Uses a Taylor expansion for small |x| to avoid division by zero and floating point errors.\n    \"\"\"\n    if np.abs(x) < 1e-9:\n        # Taylor series for B(x) around x=0: 1 - x/2 + x^2/12 - x^4/720 + ...\n        return 1.0 - x / 2.0 + x**2 / 12.0 - x**4 / 720.0\n    else:\n        return x / (np.exp(x) - 1.0)\n\ndef solve_case(N, v_min, v_max, nu, v_th, n, m):\n    \"\"\"\n    Solves one test case for the Fokker-Planck collision operator.\n    \"\"\"\n    # 1. Grid and Initial Condition\n    v = np.linspace(v_min, v_max, N)\n    delta_v = (v_max - v_min) / (N - 1)\n    \n    f_initial = (n / (np.sqrt(np.pi) * v_th)) * np.exp(-(v**2 / v_th**2))\n\n    # 2. Timestep Calculation (based on explicit stability)\n    v_domain_max = np.max(np.abs([v_min, v_max]))\n    # Stability from drift (CFL condition)\n    dt_drift = delta_v / (nu * v_domain_max)\n    # Stability from diffusion\n    dt_diff = delta_v**2 / (nu * v_th**2)\n    # The more restrictive of the two determines the explicit timestep limit\n    dt_exp = min(dt_drift, dt_diff)\n    \n    # Set the implicit timestep as a multiple of the explicit limit\n    delta_t = m * dt_exp\n\n    # 3. Assemble the Implicit Matrix M for M*f_next = f_initial\n    # Interface velocities (N-1 interfaces)\n    v_interfaces = v[:-1] + delta_v / 2.0\n    \n    # Péclet numbers at interfaces\n    peclet = (2.0 * v_interfaces * delta_v) / (v_th**2)\n    \n    # Constant term alpha\n    D_coeff = v_th**2 / 2.0\n    alpha = (delta_t * nu * D_coeff) / (delta_v**2)\n\n    # Scipy's solve_banded expects the matrix in `ab` format.\n    # For a tridiagonal matrix (l=1, u=1), ab has 3 rows:\n    # ab[0, 1:] = Super-diagonal\n    # ab[1, :]   = Main diagonal\n    # ab[2, :-1] = Sub-diagonal\n    ab = np.zeros((3, N))\n    \n    B_p = np.array([bernoulli(p) for p in peclet])\n    B_neg_p = np.array([bernoulli(-p) for p in peclet])\n    \n    # Main diagonal M_i,i\n    ab[1, 1:-1] = 1.0 + alpha * (B_p[1:] + B_neg_p[:-1])\n    ab[1, 0] = 1.0 + alpha * B_p[0] # Left boundary\n    ab[1, -1] = 1.0 + alpha * B_neg_p[-1] # Right boundary\n\n    # Super-diagonal M_i,i+1\n    ab[0, 1:] = -alpha * B_neg_p\n\n    # Sub-diagonal M_i,i-1\n    ab[2, :-1] = -alpha * B_p\n\n    # 4. Solve the linear system\n    f_next = solve_banded((1, 1), ab, f_initial)\n    \n    # 5. Validation Checks\n    # Positivity check\n    epsilon = 1e-12\n    # Ensure min(f_next) is not negative beyond a small tolerance relative to max(f_next)\n    positivity = bool(np.min(f_next) >= -epsilon * np.max(f_next))\n    \n    # Conservation check\n    tau = 1e-6\n    total_N_initial = np.sum(f_initial) * delta_v\n    total_N_final = np.sum(f_next) * delta_v\n    \n    if np.abs(total_N_initial) < 1e-15: # Handle case of zero initial distribution\n        conservation = bool(np.abs(total_N_final - total_N_initial) <= tau)\n    else:\n        conservation = bool(np.abs(total_N_final - total_N_initial) <= tau * np.abs(total_N_initial))\n    \n    # Ratio of implicit to explicit timestep\n    ratio = delta_t / dt_exp\n    \n    return positivity, conservation, ratio\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\"N\": 101, \"v_min\": -5.0e5, \"v_max\": 5.0e5, \"nu\": 5.0e6, \"v_th\": 1.0e5, \"n\": 1.0e19, \"m\": 5},\n        # Case 2 (strong stiffness)\n        {\"N\": 81, \"v_min\": -7.0e5, \"v_max\": 7.0e5, \"nu\": 2.0e7, \"v_th\": 7.0e4, \"n\": 1.0e19, \"m\": 50},\n        # Case 3 (boundary/coarse-grid edge case)\n        {\"N\": 21, \"v_min\": -4.0e5, \"v_max\": 4.0e5, \"nu\": 1.0e7, \"v_th\": 8.0e4, \"n\": 1.0e19, \"m\": 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        pos, cons, r = solve_case(\n            N=case[\"N\"],\n            v_min=case[\"v_min\"],\n            v_max=case[\"v_max\"],\n            nu=case[\"nu\"],\n            v_th=case[\"v_th\"],\n            n=case[\"n\"],\n            m=case[\"m\"]\n        )\n        # Python bools are 'True'/'False'. Format to lowercase 'true'/'false' if needed.\n        # But problem output example does not specify, so default representation is likely fine.\n        results.extend([pos, cons, r])\n\n    # Format the final output string exactly as required\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}