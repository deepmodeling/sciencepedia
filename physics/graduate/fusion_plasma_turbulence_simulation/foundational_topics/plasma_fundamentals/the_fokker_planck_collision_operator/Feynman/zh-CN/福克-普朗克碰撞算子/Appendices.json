{
    "hands_on_practices": [
        {
            "introduction": "任何有效的碰撞算符都必须使麦克斯韦平衡态分布保持不变，这是其基本物理要求。本实践旨在通过数值方法验证福克-普朗克算符的这一“零空间”性质，即对于任何与麦克斯韦分布成正比的扰动 $h$，算符的作用结果应为零（$C[h]=0$）。完成此练习是验证任何动力学模拟代码中碰撞模块正确性的基础健全性检查。",
            "id": "4202978",
            "problem": "考虑一个单种类、静电、均匀的回旋动理学验证问题，其中非绝热分布函数初始化为 $h(\\mathbf{v}) = \\alpha M(\\mathbf{v})$，其中 $M(\\mathbf{v})$ 是一个各向同性的 Maxwellian 分布，$\\alpha$ 是一个常数振幅，$\\mathbf{v}$ 是粒子速度。目标是在回旋动理学背景下，测试作用于与 Maxwellian 分布成比例的微扰的 Fokker-Planck 碰撞算符的零空间性质。在围绕各向同性 Maxwellian 分布的正确线性化中，对于与 Maxwellian 分布成比例的微扰，碰撞必须产生零响应，因为碰撞不变量和平衡结构被该算符保持。\n\n从以下基本依据出发：\n- 动理学方程由 Fokker-Planck 碰撞算符控制，该算符守恒碰撞不变量（质量、动量和能量），并允许 Maxwellian 平衡态。特别地，任何为保持这些不变量而构造的线性化算符，其零空间由 $M$、$\\mathbf{v}M$ 和 $v^{2}M$ 张成。\n- 在回旋动理学形式体系中，分布函数的非绝热部分 $h$ 线性地进入碰撞项；对于均匀、各向同性的平衡态，与 $M(\\mathbf{v})$ 成比例的微扰 $h(\\mathbf{v})$ 位于线性化碰撞算符的零空间中。\n\n为使问题在数值上适定且可测试，用速度空间中的一个各向同性拖拽-扩散算符来近似 Fokker-Planck 碰撞算符，该算符精确地允许 Maxwellian 分布 $M(\\mathbf{v})$ 作为其平稳解。设该种类粒子质量为 $m$，温度为 $T$；定义热速率为 $v_{\\mathrm{th}} = \\sqrt{2T/m}$，单位为 $\\mathrm{m/s}$，其中 $T$ 以焦耳表示。使用算符\n$$\nC[f] = \\nu \\, \\nabla_{\\mathbf{v}} \\cdot \\left( \\mathbf{v} f + \\frac{v_{\\mathrm{th}}^{2}}{2} \\nabla_{\\mathbf{v}} f \\right),\n$$\n其中 $\\nu$ 是一个常数碰撞频率，单位为 $\\mathrm{s}^{-1}$。在球形速度坐标中，对于各向同性情况（$f=f(v)$），该算符简化为\n$$\nC[f](v) = \\nu \\, \\frac{1}{v^{2}}\\frac{\\partial}{\\partial v} \\left[ v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2}\\frac{\\partial f}{\\partial v} \\right) \\right].\n$$\n因为对于 $f=M$，径向散度内的通量为零，所以连续算符满足 $C[M]=0$，并且根据线性性质，对于任意常数 $\\alpha$ 都有 $C[\\alpha M]=0$。\n\n在具有 $N_{v}$ 个均匀间隔点的一维速率网格 $v \\in [0, v_{\\max}]$ 上实现有限差分格式离散化。在内部对 $\\partial f/\\partial v$ 使用二阶精确的模板，并在边界处使用一致的单边模板。在 $v=0$ 处，通过 $\\partial f/\\partial v|_{v=0} = 0$ 施加对称性。构造离散通量\n$$\nS(v) = v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2} \\frac{\\partial f}{\\partial v} \\right),\n$$\n和离散算符\n$$\nC[f](v) \\approx \\nu \\, \\frac{1}{v^{2}} \\frac{\\partial S}{\\partial v}.\n$$\n用各向同性 Maxwellian 分布\n$$\nM(v) = \\frac{n_{0}}{\\left(\\pi v_{\\mathrm{th}}^{2}\\right)^{3/2}} \\exp\\left(-\\frac{v^{2}}{v_{\\mathrm{th}}^{2}}\\right),\n$$\n初始化 $h(v) = \\alpha M(v)$，其中 $n_{0}$ 是平衡密度，单位为 $\\mathrm{m}^{-3}$。计算离散 $C[h]$ 的最大范数，用 $\\nu$ 乘以 $h$ 的最大范数对其进行归一化，并与预设的容差 $\\epsilon$ 进行比较：\n$$\nR = \\frac{\\max_{v} \\left| C[h](v) \\right|}{\\nu \\, \\max_{v} \\left| h(v) \\right|}.\n$$\n如果 $R  \\epsilon$，则验证通过，为每个测试用例产生一个布尔结果。\n\n物理单位必须一致：质量 $m$ 使用千克，温度 $T$ 使用电子伏特，通过 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$ 转换为焦耳，速度使用米/秒，密度 $n_{0}$ 使用 1/立方米，碰撞频率 $\\nu$ 使用 1/秒，以及 $v_{\\max}$ 使用米/秒。在这个各向同性测试中，角度没有显式出现，因此不需要角度单位。\n\n测试套件（每个元组列出 $(m, T_{\\mathrm{eV}}, n_{0}, \\nu, N_{v}, \\lambda, \\alpha, \\epsilon)$，其中 $v_{\\max} = \\lambda \\, v_{\\mathrm{th}}$）：\n- 案例 1（通用正常路径）：$(3.343583719 \\times 10^{-27}\\,\\mathrm{kg}, 2.0 \\times 10^{3}\\,\\mathrm{eV}, 1.0 \\times 10^{19}\\,\\mathrm{m}^{-3}, 1.0 \\times 10^{5}\\,\\mathrm{s}^{-1}, 400, 5.0, 0.5, 1.0 \\times 10^{-3})$。\n- 案例 2（粗网格边界测试）：$(3.343583719 \\times 10^{-27}\\,\\mathrm{kg}, 2.0 \\times 10^{3}\\,\\mathrm{eV}, 1.0 \\times 10^{19}\\,\\mathrm{m}^{-3}, 1.0 \\times 10^{5}\\,\\mathrm{s}^{-1}, 40, 6.0, 0.5, 2.0 \\times 10^{-2})$。\n- 案例 3（零振幅边缘情况）：$(3.343583719 \\times 10^{-27}\\,\\mathrm{kg}, 1.0 \\times 10^{3}\\,\\mathrm{eV}, 5.0 \\times 10^{18}\\,\\mathrm{m}^{-3}, 3.0 \\times 10^{4}\\,\\mathrm{s}^{-1}, 60, 4.0, 0.0, 1.0 \\times 10^{-10})$。\n\n你的程序必须：\n- 为速度实现所述的离散化（单位 $\\mathrm{m/s}$），并为每个案例计算 $R$。\n- 为每个案例生成布尔值，指示 $R\\epsilon$ 是否成立。\n- 输出一行结果，格式为方括号内以逗号分隔的列表，例如 $[{\\mathrm{True}},{\\mathrm{False}},{\\mathrm{True}}]$。",
            "solution": "该问题提出了一个针对 Fokker-Planck 类碰撞算符数值实现的验证测试。待验证的基本原理是，根据构造，该算符的零空间包含任何与 Maxwellian 分布成比例的函数。此性质必须成立，因为碰撞算符守恒粒子数、动量和能量，并驱使系统趋向 Maxwellian 平衡态。因此，一个仅仅是平衡分布的重新标度的微扰，$h(\\mathbf{v}) = \\alpha M(\\mathbf{v})$，必须不产生碰撞效应，即 $C[h] = 0$。在任何动理学模拟代码的开发中，此验证都是一项关键的健全性检查。\n\n问题提供了一个作用于分布函数 $f(v)$ 的简化一维各向同性拖拽-扩散算符，其中 $v$ 是粒子速率：\n$$\nC[f](v) = \\nu \\, \\frac{1}{v^{2}}\\frac{\\partial}{\\partial v} \\left[ v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2}\\frac{\\partial f}{\\partial v} \\right) \\right]\n$$\n此处，$\\nu$ 是碰撞频率，$v_{\\mathrm{th}} = \\sqrt{2T/m}$ 是热速率，其中 $m$ 是粒子质量，$T$ 是其温度（以焦耳为单位）。外层方括号中的项是速度空间中的通量，我们将其表示为 $S(v)$：\n$$\nS(v) = v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2}\\frac{\\partial f}{\\partial v} \\right)\n$$\n问题要求在速率 $v$ 的均匀网格上进行数值求解。我们将构造算符 $C[h]$ 的离散表示并评估其大小。\n\n首先，我们建立离散速度网格。对于最大速率 $v_{\\max}$ 和 $N_{v}$ 个网格点，网格定义为 $v_i = i \\Delta v$，其中 $i = 0, 1, \\dots, N_{v}-1$，网格间距为 $\\Delta v = v_{\\max} / (N_v - 1)$。待测试的函数是 $h(v_i) = \\alpha M(v_i)$，其中 $M(v_i)$ 是离散的 Maxwellian 分布：\n$$\nM(v_i) = \\frac{n_{0}}{\\left(\\pi v_{\\mathrm{th}}^{2}\\right)^{3/2}} \\exp\\left(-\\frac{v_i^{2}}{v_{\\mathrm{th}}^{2}}\\right)\n$$\n其中 $n_0$ 是粒子密度。\n\n算符 $C[h]$ 的数值实现按以下步骤进行：\n\n1.  **离散化导数 $\\partial h/\\partial v$**：我们使用有限差分来近似函数 $h$ 在每个网格点 $v_i$ 处的导数。设 $h_i = h(v_i)$，$(\\partial h/\\partial v)_i$ 为其离散导数。\n    -   在边界 $v_0=0$ 处，对称性条件要求 $(\\partial h/\\partial v)_0 = 0$。\n    -   对于内部点 $i \\in [1, N_v-2]$，为保证精度，采用二阶中心差分：\n        $$ \\left(\\frac{\\partial h}{\\partial v}\\right)_i = \\frac{h_{i+1} - h_{i-1}}{2\\Delta v} $$\n    -   在外边界 $v_{N_v-1}$ 处，为保持精度，使用二阶后向差分模板：\n        $$ \\left(\\frac{\\partial h}{\\partial v}\\right)_{N_v-1} = \\frac{3h_{N_v-1} - 4h_{N_v-2} + h_{N_v-3}}{2\\Delta v} $$\n\n2.  **计算离散通量 $S_i$**：利用离散函数 $h_i$ 及其导数 $(\\partial h/\\partial v)_i$，我们在每个网格点计算通量 $S_i = S(v_i)$：\n    $$ S_i = v_i^2 \\left( v_i h_i + \\frac{v_{\\mathrm{th}}^2}{2} \\left(\\frac{\\partial h}{\\partial v}\\right)_i \\right) $$\n    注意，在 $i=0$ 处，$v_0=0$，所以 $S_0=0$。\n\n3.  **离散化通量导数 $\\partial S/\\partial v$**：我们将相同的有限差分格式应用于新计算的通量数组 $S_i$。设 $(\\partial S/\\partial v)_i$ 为其离散导数。\n    -   在边界 $v_0=0$ 处，我们使用二阶前向差分模板。由于 $S_0=0$，它简化为：\n        $$ \\left(\\frac{\\partial S}{\\partial v}\\right)_0 = \\frac{-3S_0 + 4S_1 - S_2}{2\\Delta v} = \\frac{4S_1 - S_2}{2\\Delta v} $$\n    -   对于内部点 $i \\in [1, N_v-2]$，我们再次使用中心差分：\n        $$ \\left(\\frac{\\partial S}{\\partial v}\\right)_i = \\frac{S_{i+1} - S_{i-1}}{2\\Delta v} $$\n    -   在外边界 $v_{N_v-1}$ 处，我们使用后向差分：\n        $$ \\left(\\frac{\\partial S}{\\partial v}\\right)_{N_v-1} = \\frac{3S_{N_v-1} - 4S_{N_v-2} + S_{N_v-3}}{2\\Delta v} $$\n\n4.  **计算离散算符 $C[h]_i$**：最后一步是组装算符。\n    -   对于 $i > 0$，算符直接根据其定义计算：\n        $$ C[h]_i = \\nu \\frac{1}{v_i^2} \\left(\\frac{\\partial S}{\\partial v}\\right)_i $$\n    -   在 $v_0=0$ 处，项 $1/v^2$ 产生一个奇点。我们必须使用算符在 $v \\to 0$ 时的极限形式。对于满足 $\\partial h/\\partial v|_{v=0}=0$ 的函数，连续算符有一个明确定义的极限：$C[h](0) = \\nu(3h(0) + \\frac{3}{2} v_{\\mathrm{th}}^2 \\frac{\\partial^2 h}{\\partial v^2}|_{v=0})$。我们利用对称性 $h_{-1}=h_1$ 在 $v=0$ 处离散化二阶导数，得到 $\\frac{\\partial^2 h}{\\partial v^2}|_{0} \\approx \\frac{h_1 - 2h_0 + h_{-1}}{(\\Delta v)^2} = \\frac{2(h_1 - h_0)}{(\\Delta v)^2}$。因此，在 $v_0=0$ 处的离散算符为：\n        $$ C[h]_0 = \\nu \\left( 3h_0 + 3v_{\\mathrm{th}}^2 \\frac{h_1-h_0}{(\\Delta v)^2} \\right) $$\n    这种处理方式与底层数学原理一致，解决了奇点问题。\n\n计算出离散算符 $C[h]_i$ 后，我们评估验证度量 $R$：\n$$\nR = \\frac{\\max_{i} |C[h]_i|}{\\nu \\max_{i} |h_i|}\n$$\n$R$ 的值代表数值误差的归一化大小；在连续极限下，它将为零。对于给定的容差 $\\epsilon$，如果 $R  \\epsilon$，则测试通过。\n\n当振幅 $\\alpha=0$ 时，出现一个特殊情况。此时，对所有 $i$ 都有 $h_i=0$。离散算符 $C[0]$ 将恒等于零。度量 $R$ 变为不定的 $0/0$ 形式。然而，物理条件已完全满足，数值误差为零。因此，如果 $\\alpha=0$（或在计算上，如果 $\\max_i |h_i|=0$），则认为测试通过。\n\n通过为给定的参数集 $(m, T_{\\mathrm{eV}}, n_{0}, \\nu, N_{v}, \\lambda, \\alpha, \\epsilon)$ 实现此数值方案，并检查计算出的 $R$ 是否小于指定的 $\\epsilon$，来评估每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Fokker-Planck operator null-space verification problem.\n    \"\"\"\n    # Physical constant\n    e_charge = 1.602176634e-19  # Electron charge in Coulombs\n\n    # Test suite parameters: (m, T_eV, n0, nu, Nv, lambda, alpha, epsilon)\n    test_cases = [\n        (3.343583719e-27, 2.0e3, 1.0e19, 1.0e5, 400, 5.0, 0.5, 1.0e-3),\n        (3.343583719e-27, 2.0e3, 1.0e19, 1.0e5, 40, 6.0, 0.5, 2.0e-2),\n        (3.343583719e-27, 1.0e3, 5.0e18, 3.0e4, 60, 4.0, 0.0, 1.0e-10),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, T_ev, n0, nu, Nv, lam, alpha, eps = case\n\n        # Handle the trivial case where the perturbation is zero\n        if alpha == 0.0:\n            results.append(True)\n            continue\n\n        # Convert temperature from eV to Joules\n        T = T_ev * e_charge\n        \n        # Calculate thermal speed and set up the velocity grid\n        v_th = np.sqrt(2 * T / m)\n        v_max = lam * v_th\n        v, dv = np.linspace(0, v_max, Nv, retstep=True)\n\n        # Initialize the nonadiabatic distribution function h(v) = alpha * M(v)\n        norm_M = n0 / (np.pi * v_th**2)**1.5\n        M = norm_M * np.exp(-v**2 / v_th**2)\n        h = alpha * M\n\n        # Step 1: Compute the derivative of h(v) using finite differences\n        dh_dv = np.zeros(Nv, dtype=np.float64)\n        dh_dv[0] = 0.0  # Symmetry condition at v=0\n        # Second-order central difference for the interior\n        dh_dv[1:-1] = (h[2:] - h[:-2]) / (2 * dv)\n        # Second-order backward difference for the outer boundary\n        dh_dv[-1] = (3*h[-1] - 4*h[-2] + h[-3]) / (2 * dv)\n\n        # Step 2: Compute the flux S(v)\n        S = v**2 * (v * h + 0.5 * v_th**2 * dh_dv)\n\n        # Step 3: Compute the derivative of the flux S(v)\n        dS_dv = np.zeros(Nv, dtype=np.float64)\n        # Second-order forward difference for v=0 (using S[0]=0)\n        dS_dv[0] = (4*S[1] - S[2]) / (2 * dv)\n        # Second-order central difference for the interior\n        dS_dv[1:-1] = (S[2:] - S[:-2]) / (2 * dv)\n        # Second-order backward difference for the outer boundary\n        dS_dv[-1] = (3*S[-1] - 4*S[-2] + S[-3]) / (2 * dv)\n\n        # Step 4: Compute the discrete collision operator C[h]\n        C_h = np.zeros(Nv, dtype=np.float64)\n        # Special form for the singularity at v=0\n        d2h_dv2_0 = 2 * (h[1] - h[0]) / dv**2\n        C_h[0] = nu * (3 * h[0] + 1.5 * v_th**2 * d2h_dv2_0)\n        # Standard form for v > 0\n        C_h[1:] = nu / v[1:]**2 * dS_dv[1:]\n\n        # Step 5: Calculate the verification metric R and compare to tolerance\n        max_C_h = np.max(np.abs(C_h))\n        max_h = np.max(np.abs(h))\n\n        if max_h == 0.0:\n            # Should have been caught by alpha == 0 check, but is a safe fallback\n            is_passed = True\n        else:\n            R = max_C_h / (nu * max_h)\n            is_passed = R  eps\n        \n        results.append(is_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "物理守恒律，如粒子数守恒，必须在数值离散化后依然得到严格满足。本练习的核心是从第一性原理出发，构建一个保证粒子数守恒的一维有限体积格式 。通过将控制方程在每个单元上积分，我们能看到数值通量的离散求和如何自然地演变成一个伸缩求和，从而确保总粒子数的变化仅取决于边界通量，这是设计稳健数值方法的关键一步。",
            "id": "4202967",
            "problem": "您需要推导并实现一个在速度坐标上的一维有限体积离散化方案，该方案以守恒形式表示 Fokker-Planck 碰撞算子，并通过在速度空间边界上施加零净通量来确保粒子数的离散守恒。从相空间守恒和漂移-扩散通量定义的第一性原理出发，在一个可能非均匀的网格上构建一个计算单元平均分布函数的半离散时间导数的格式。\n\n仅使用以下基本定律和定义，不得使用其他任何内容：\n\n- 速度空间中的概率守恒表明，分布函数 $f(v,t)$ 服从形式为 $\\partial f / \\partial t + \\partial J / \\partial v = 0$ 的守恒定律，其中 $J$ 是速度空间通量。\n- 对于 Fokker-Planck 碰撞算子，通量 $J$ 是漂移和扩散贡献的总和，其系数可能依赖于 $v$：具体来说，$J(v,t) = -\\left(A(v)\\,f(v,t) + D(v)\\,\\frac{\\partial f}{\\partial v}(v,t)\\right)$，其中 $D(v) \\ge 0$。\n- 在速度空间划分上的有限体积法将守恒定律在每个控制体积（单元）上积分，从而将单元平均 $f$ 的变化率与通过边界面的通量差联系起来。\n- 离散粒子数守恒要求，所有单元的粒子含量变化率之和等于通过域边界的净通量，如果边界处的 $J$ 被设为零，该净通量必须为零。\n\n您的任务是：\n\n- 从上述基础出发，推导一个在由索引 $i$ 标记的单元和由索引 $j$ 标记的面组成的网格上，关于 $f$ 的有限体积半离散更新。该更新应使粒子含量变化的离散总和能够伸缩为边界净通量，并在边界通量设为零时消失。\n- 为通用的 $A(v)$ 和 $D(v)$ 以及非均匀网格，指定一个一致的面通量计算方法，使该格式具有守恒性。除了从守恒定律和上述定义中得出的公式外，您不得使用任何外部公式。您必须选择一个与积分有限体积方法一致的 $f$ 的面表示和 $\\partial f/\\partial v$ 的面表示。\n- 实现一个程序，在给定 $A(v)$、$D(v)$、网格和初始 $f(v)$ 的情况下，为每个单元 $i$ 计算半离散时间导数 $\\partial f_i/\\partial t$，并在零通量边界条件下返回总粒子数 $N(t) = \\int f(v,t)\\,dv$ 的离散时间变化率，即 $dN/dt$。\n\n所有变量都是无量纲的：速度 $v$ 由参考热速度归一化，时间 $t$ 由参考碰撞时间归一化，分布函数 $f$ 被归一化，使其积分等于一个无量纲的粒子数。您不得引入物理单位。\n\n设计测试用例以验证该格式的不同方面。使用以下测试套件，其中每个案例指定了区间、单元数量、系数函数和初始分布。在所有情况下，通过在域的边界面上将 $J$ 设为零来施加零通量边界条件。对于每个测试用例，计算您的半离散格式产生的离散 $dN/dt$。\n\n- 案例 $1$（均匀网格，线性漂移，恒定扩散，类麦克斯韦初始条件）：\n  - 域 $v \\in [-5,5]$。\n  - 单元数量 $N = 200$。\n  - 系数 $A(v) = v$，$D(v) = 1$。\n  - 初始分布 $f(v) = \\frac{1}{\\sqrt{\\pi}}\\,\\exp(-v^2)$。\n\n- 案例 $2$（中心区域加密的非均匀网格，线性漂移，恒定扩散，代数尾初始条件）：\n  - 域 $v \\in [-6,6]$。\n  - 单元数量 $N = 121$，通过将域划分为三个连续段构建，这些段的面在 $[-6,-2]$ 中产生 $N_{\\text{left}} = 20$ 个单元，在 $[-2,2]$ 中产生 $N_{\\text{center}} = 81$ 个单元，在 $[2,6]$ 中产生 $N_{\\text{right}} = 20$ 个单元。\n  - 系数 $A(v) = v$，$D(v) = 1$。\n  - 初始分布 $f(v) = C\\,(1+v^2)^{-1}$，其中 $C$ 的选择应使在域上的离散积分等于 $1$。\n\n- 案例 $3$（均匀网格，非线性漂移，速度相关的扩散，高斯初始条件）：\n  - 域 $v \\in [-4,4]$。\n  - 单元数量 $N = 64$。\n  - 系数 $A(v) = v^3$，$D(v) = 1 + 0.5\\,v^2$。\n  - 初始分布 $f(v) = \\frac{1}{\\sqrt{2\\pi}}\\,\\exp\\left(-\\frac{v^2}{2}\\right)$。\n\n- 案例 $4$（非常粗的均匀网格，振荡漂移，严格正扩散，高斯初始条件）：\n  - 域 $v \\in [-3,3]$。\n  - 单元数量 $N = 5$。\n  - 系数 $A(v) = \\sin(v)$，$D(v) = \\exp(-v^2) + 0.1$。\n  - 初始分布 $f(v) = \\exp\\left(-\\frac{v^2}{2}\\right)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为案例 $1$ 到案例 $4$，每个条目是相应案例计算出的离散 $dN/dt$ 的浮点值。例如，输出格式必须像 $[x_1,x_2,x_3,x_4]$，其中每个 $x_k$ 是一个浮点数。对于一个正确的方法，预期每个 $x_k$ 在浮点精度内都等于零，因为在零边界通量下，有限体积的伸缩保证必须独立于 $A(v)$、$D(v)$、网格和 $f(v)$ 的具体选择而成立。",
            "solution": "该问题要求推导并实现一个针对 Fokker-Planck 碰撞算子的一维有限体积离散化方案。该方案必须是守恒的，即必须在设计上保证粒子数的守恒。这一点通过在零通量边界条件下计算粒子总数的时间变化率 $dN/dt$ 来检验。预期结果应在浮点精度范围内为零。\n\n### 步骤 1：半离散有限体积格式的推导\n\n出发点是速度空间中分布函数 $f(v, t)$ 的一维守恒定律：\n$$ \\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0 $$\n其中 $J(v,t)$ 是速度空间通量。对于 Fokker-Planck 算子，此通量由漂移-扩散形式给出：\n$$ J(v,t) = -\\left(A(v)\\,f(v,t) + D(v)\\,\\frac{\\partial f}{\\partial v}(v,t)\\right) $$\n这里，$A(v)$ 是漂移系数，$D(v)$ 是扩散系数，且 $D(v) \\ge 0$。\n\n为了构建有限体积格式，我们将速度域 $[v_{\\min}, v_{\\max}]$ 划分为 $N$ 个连续的单元。设单元边界（面）位于位置 $v_{i+1/2}$，其中 $i=0, 1, \\dots, N$，且 $v_{1/2} = v_{\\min}$ 和 $v_{N+1/2} = v_{\\max}$。第 $i$ 个单元（$i=1, \\dots, N$）占据区间 $[v_{i-1/2}, v_{i+1/2}]$。单元 $i$ 的宽度为 $\\Delta v_i = v_{i+1/2} - v_{i-1/2}$。网格可以是非均匀的，因此 $\\Delta v_i$ 可能随 $i$ 变化。\n\n我们将守恒定律在第 $i$ 个单元上积分：\n$$ \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial f}{\\partial t} \\, dv + \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial J}{\\partial v} \\, dv = 0 $$\n我们来分析每一项。假设函数光滑，第一项成为单元内粒子总数的时间导数：\n$$ \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial f}{\\partial t} \\, dv = \\frac{d}{dt} \\int_{v_{i-1/2}}^{v_{i+1/2}} f(v, t) \\, dv $$\n我们定义单元平均分布函数 $f_i(t)$ 为：\n$$ f_i(t) = \\frac{1}{\\Delta v_i} \\int_{v_{i-1/2}}^{v_{i+1/2}} f(v, t) \\, dv $$\n因此，第一项是 $\\frac{d}{dt} (f_i(t) \\Delta v_i)$。由于网格是静态的，这简化为 $\\Delta v_i \\frac{d f_i}{dt}$。\n\n第二项使用微积分基本定理进行积分：\n$$ \\int_{v_{i-1/2}}^{v_{i+1/2}} \\frac{\\partial J}{\\partial v} \\, dv = J(v_{i+1/2}, t) - J(v_{i-1/2}, t) $$\n令 $J_{i \\pm 1/2}$ 表示在单元面 $v_{i \\pm 1/2}$ 处的通量。积分后的方程变为：\n$$ \\Delta v_i \\frac{d f_i}{dt} + J_{i+1/2} - J_{i-1/2} = 0 $$\n整理后得到单元平均分布函数 $f_i$ 的半离散更新法则：\n$$ \\frac{d f_i}{dt} = -\\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta v_i} $$\n这个方程是有限体积法的基础。它表明单元内平均密度的变化由通过其边界的净通量决定。\n\n### 步骤 2：离散粒子数守恒的证明\n\n域中的总粒子数 $N(t)$ 是 $f(v,t)$ 在整个速度空间上的积分。在离散表示中，它是所有单元中粒子数的总和：\n$$ N(t) = \\int_{v_{\\min}}^{v_{\\max}} f(v,t) \\, dv \\approx \\sum_{i=1}^{N} f_i(t) \\Delta v_i $$\n粒子总数的变化率为：\n$$ \\frac{dN}{dt} = \\frac{d}{dt} \\sum_{i=1}^{N} f_i \\Delta v_i = \\sum_{i=1}^{N} \\Delta v_i \\frac{d f_i}{dt} $$\n代入半离散更新法则：\n$$ \\frac{dN}{dt} = \\sum_{i=1}^{N} \\left( -(J_{i+1/2} - J_{i-1/2}) \\right) $$\n这是一个伸缩求和：\n$$ \\frac{dN}{dt} = -(J_{3/2} - J_{1/2}) - (J_{5/2} - J_{3/2}) - \\dots - (J_{N+1/2} - J_{N-1/2}) $$\n$$ \\frac{dN}{dt} = (J_{1/2} - J_{3/2}) + (J_{3/2} - J_{5/2}) + \\dots + (J_{N-1/2} - J_{N+1/2}) $$\n所有内部通量都相互抵消，只剩下边界通量：\n$$ \\frac{dN}{dt} = J_{1/2} - J_{N+1/2} $$\n这里，$J_{1/2}$ 是左边界 $v_{\\min}$ 处的通量，$J_{N+1/2}$ 是右边界 $v_{\\max}$ 处的通量。问题指定了零通量边界条件，这意味着 $J_{1/2} = 0$ 和 $J_{N+1/2} = 0$。因此，离散格式保证了：\n$$ \\frac{dN}{dt} = 0 $$\n这种守恒特性是有限体积法结构内建的，并且与内部通量 $J_{i+1/2}$ 如何近似无关，只要离开单元 $i$ 的通量与进入单元 $i+1$ 的通量完全相同。\n\n### 步骤 3：通量的离散化\n\n为了实现该格式，我们需要一个在单元 $i$ 和单元 $i+1$ 之间的面 $v_{i+1/2}$ 处通量 $J_{i+1/2}$ 的具体表达式。通量依赖于面上的 $f$ 和 $\\partial f / \\partial v$ 的值。我们使用单元平均值 $f_i$ 和 $f_{i+1}$ 来近似这些值，我们将这些平均值与单元中心 $v_i$ 和 $v_{i+1}$ 相关联。\n- 网格定义：\n  - 面位置：$v_{i+1/2}$\n  - 单元中心：$v_i = (v_{i-1/2} + v_{i+1/2}) / 2$\n  - 单元宽度：$\\Delta v_i = v_{i+1/2} - v_{i-1/2}$\n- 在面 $v_{i+1/2}$ 处的通量：\n  $$ J_{i+1/2} = -\\left(A(v_{i+1/2})\\,f_{i+1/2} + D(v_{i+1/2})\\,\\left.\\frac{\\partial f}{\\partial v}\\right|_{i+1/2}\\right) $$\n- 近似方法：\n  - 系数 $A$ 和 $D$ 直接在面上求值：$A_{i+1/2} = A(v_{i+1/2})$ 和 $D_{i+1/2} = D(v_{i+1/2})$。\n  - $f$ 的梯度通过相邻单元中心之间的中心差分来近似：\n    $$ \\left.\\frac{\\partial f}{\\partial v}\\right|_{i+1/2} \\approx \\frac{f_{i+1} - f_i}{v_{i+1} - v_i} $$\n    对于非均匀网格，单元中心之间的距离为 $v_{i+1} - v_i = (v_{i+1/2} + \\Delta v_{i+1}/2) - (v_{i+1/2} - \\Delta v_i/2) = (\\Delta v_i + \\Delta v_{i+1})/2$。\n  - 对于平流项，面上分布函数的值 $f_{i+1/2}$ 必须谨慎选择。一个简单、稳健且守恒的选择是一阶迎风格式。该值取自“上游”单元，即“流”（由 $A$ 的符号决定）的来源单元。\n    $$ f_{i+1/2} = \\begin{cases} f_i  \\text{若 } A_{i+1/2} \\ge 0 \\\\ f_{i+1}  \\text{若 } A_{i+1/2}  0 \\end{cases} $$\n这完成了数值格式的规范。实现将为给定的测试用例计算 $dN/dt$，根据此推导，该值应在浮点容差范围内为零。\n\n### 步骤 4：实现与测试用例\n\n以下 Python 代码实现了所推导的守恒有限体积格式。它构建网格、定义系数函数、初始化分布、使用上述迎风平流和中心扩散方法计算所有内部面上的通量，为每个单元计算半离散时间导数，最后将这些变化相加得到粒子总数的变化率 $dN/dt$。\n\n该逻辑应用于四个指定的测试用例，每个用例具有不同的网格、系数函数和初始分布。每个案例计算出的 $dN/dt$ 被收集并打印出来。如已证明，结果应在数值上与零无法区分，这展示了该算法的粒子数守恒性质。对于案例 2，特别注意按要求构建非均匀网格并归一化初始分布。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a 1D finite-volume scheme for the Fokker-Planck\n    operator and computes the rate of change of total particle number for\n    several test cases under zero-flux boundary conditions.\n    \"\"\"\n\n    def compute_dndt(domain, num_cells, grid_spec, A_func, D_func, f_func_init, normalize_f=False):\n        \"\"\"\n        Computes the discrete dN/dt for a single test case.\n\n        Args:\n            domain (tuple): (vmin, vmax) for the velocity domain.\n            num_cells (int): Total number of cells, N.\n            grid_spec (dict or None): Specification for non-uniform grid.\n            A_func (callable): Drift coefficient A(v).\n            D_func (callable): Diffusion coefficient D(v).\n            f_func_init (callable): Initial distribution function f(v,0).\n            normalize_f (bool): Flag to normalize the initial discrete distribution.\n\n        Returns:\n            float: The computed discrete dN/dt.\n        \"\"\"\n        vmin, vmax = domain\n\n        # 1. Construct the grid\n        if grid_spec is None:  # Uniform grid\n            v_faces = np.linspace(vmin, vmax, num_cells + 1)\n        else:  # Non-uniform grid for Case 2\n            partitions = grid_spec['partitions']\n            face_arrays = []\n            for i, p in enumerate(partitions):\n                p_vmin, p_vmax, p_ncells = p\n                # To concatenate correctly, don't include the last point,\n                # except for the very last partition.\n                include_last = (i == len(partitions) - 1)\n                num_points = p_ncells + 1 if include_last else p_ncells\n                face_arrays.append(np.linspace(p_vmin, p_vmax, p_ncells + 1)[:num_points])\n            v_faces = np.concatenate(face_arrays)\n        \n        # Cell properties\n        dv = v_faces[1:] - v_faces[:-1]\n        v_centers = 0.5 * (v_faces[1:] + v_faces[:-1])\n\n        # 2. Initialize the distribution function\n        f_vals = f_func_init(v_centers)\n        \n        if normalize_f:\n            total_N = np.sum(f_vals * dv)\n            f_vals /= total_N\n\n        # 3. Compute fluxes at interior faces\n        # Flux array size is N+1, for faces 0 to N.\n        # Boundary fluxes J_0 and J_N are zero.\n        fluxes = np.zeros(num_cells + 1)\n\n        # Loop over interior faces (indices 1 to N-1)\n        for j in range(1, num_cells):\n            # Face j is between cell j-1 (left) and cell j (right)\n            i_left, i_right = j - 1, j\n            \n            v_face = v_faces[j]\n            A_face = A_func(v_face)\n            D_face = D_func(v_face)\n            \n            f_left = f_vals[i_left]\n            f_right = f_vals[i_right]\n            \n            # Distance between adjacent cell centers for gradient calculation\n            dist_centers = v_centers[i_right] - v_centers[i_left]\n            \n            # Avoid division by zero if grid is pathologically coarse\n            if dist_centers == 0:\n                grad_f = 0.0\n            else:\n                 grad_f = (f_right - f_left) / dist_centers\n\n            # Upwind scheme for the advective part of the flux\n            if A_face >= 0:\n                f_face = f_left\n            else:\n                f_face = f_right\n                \n            fluxes[j] = -(A_face * f_face + D_face * grad_f)\n            \n        # 4. Compute df/dt for each cell\n        dfdt = -(fluxes[1:] - fluxes[:-1]) / dv\n\n        # 5. Compute the total dN/dt\n        # As derived, this is sum(dfdt * dv) = J_0 - J_N, which is 0.\n        # We compute it explicitly from dfdt to verify the implementation.\n        dndt = np.sum(dfdt * dv)\n        \n        return dndt\n\n    # --- Test Cases ---\n\n    # Case 1\n    case1_dndt = compute_dndt(\n        domain=(-5.0, 5.0),\n        num_cells=200,\n        grid_spec=None,\n        A_func=lambda v: v,\n        D_func=lambda v: 1.0,\n        f_func_init=lambda v: (1.0 / np.sqrt(np.pi)) * np.exp(-v**2)\n    )\n\n    # Case 2\n    case2_dndt = compute_dndt(\n        domain=(-6.0, 6.0),\n        num_cells=121,\n        grid_spec={\n            'partitions': [\n                (-6.0, -2.0, 20),\n                (-2.0, 2.0, 81),\n                (2.0, 6.0, 20)\n            ]},\n        A_func=lambda v: v,\n        D_func=lambda v: 1.0,\n        f_func_init=lambda v: 1.0 / (1.0 + v**2),\n        normalize_f=True\n    )\n    \n    # Case 3\n    case3_dndt = compute_dndt(\n        domain=(-4.0, 4.0),\n        num_cells=64,\n        grid_spec=None,\n        A_func=lambda v: v**3,\n        D_func=lambda v: 1.0 + 0.5 * v**2,\n        f_func_init=lambda v: (1.0 / np.sqrt(2.0 * np.pi)) * np.exp(-v**2 / 2.0)\n    )\n\n    # Case 4\n    case4_dndt = compute_dndt(\n        domain=(-3.0, 3.0),\n        num_cells=5,\n        grid_spec=None,\n        A_func=lambda v: np.sin(v),\n        D_func=lambda v: np.exp(-v**2) + 0.1,\n        f_func_init=lambda v: np.exp(-v**2 / 2.0)\n    )\n\n    results = [case1_dndt, case2_dndt, case3_dndt, case4_dndt]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "福克-普朗克算符中的漂移和扩散项引入了跨度极大的时间尺度，导致数值求解变得“刚性”，严重限制了显式时间积分方法的步长。本实践旨在解决这一核心挑战，通过实施一个无条件稳定且保持分布函数正定性的隐式时间积分方案 。您将学习并应用先进的Scharfetter-Gummel通量格式，这是一种在计算等离子体物理中广泛使用的技术，它能有效处理刚性问题，从而在保证稳定性和物理真实性的前提下，使用远大于显式格式限制的时间步长。",
            "id": "4202992",
            "problem": "考虑一个聚变等离子体湍流模拟中的单物种、一维速度空间碰撞弛豫过程，该过程由福克-普朗克碰撞算子描述。令 $f(v,t)$ 表示速度分布函数，其中速度 $v$ 的单位为 $\\mathrm{m/s}$，时间 $t$ 的单位为 $\\mathrm{s}$。假设该碰撞算子为漂移-扩散类型，其碰撞频率 $\\nu$ 的单位为 $\\mathrm{s^{-1}}$，热速度 $v_{\\mathrm{th}}$ 的单位为 $\\mathrm{m/s}$。其控制方程可以写成守恒形式，即一个包含碰撞通量的速度空间连续性方程：\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0,\n$$\n其中通量 $J$ 体现了摩擦（漂移）和扩散两种效应。我们将速度域限制在有限区间 $v \\in [v_{\\min}, v_{\\max}]$ 内，并施加零通量边界条件 $J(v_{\\min},t)=J(v_{\\max},t)=0$，以确保计算域内的粒子数守恒。\n\n从基本原理出发——即上述守恒（连续性）形式以及速度空间中漂移和扩散的物理解释——回答以下任务：\n\n1. 通过分别确定与漂移和扩散过程相关的显式前向欧拉时间步进稳定性约束，分析碰撞项的刚性。您的分析必须从守恒形式以及漂移和扩散的定义开始，并推导出一个可操作化的稳定性界限。在您的算法实现中，使用此界限来定义最大显式时间步长 $\\,\\Delta t_{\\mathrm{exp}}\\,$。在推导过程中，请勿假设或引用任何非从第一性原理得到的预推导公式。\n\n2. 提出一个无条件稳定的隐式时间步进格式，该格式允许使用大于 $\\,\\Delta t_{\\mathrm{exp}}\\,$ 的时间步长，同时保持 $f$ 的非负性（正性）和粒子数守恒。在均匀网格上实现连续性方程 $\\,\\partial_t f + \\partial_v J = 0\\,$ 的有限体积离散化。使用 Scharfetter–Gummel (SG) 离散格式（通过在每个网格单元上，在系数恒定的假设下精确求解稳态一维漂移-扩散平衡来定义）在单元界面上构造数值通量。已知该格式与零通量边界条件结合时能保持正性并产生守恒的更新。使用后向欧拉法进行隐式时间离散。您的格式必须满足：\n   - 正性：如果对所有 $v$ 都有 $f(v,t^n)\\ge 0$，那么对所有 $v$ 也都有 $f(v,t^{n+1})\\ge 0$。\n   - 粒子数守恒：在零通量边界条件下，$\\int_{v_{\\min}}^{v_{\\max}} f(v,t)\\,\\mathrm{d}v$ 随时间保持恒定。\n\n3. 将上述格式实现在一个完整的、可运行的程序中，该程序从 SG 通量构造离散算子矩阵，并从一个正的初始分布 $f_0(v)$ 执行一个隐式后向欧拉步。使用以下测试套件。在所有三种情况下，将初始条件定义为一维麦克斯韦分布\n$$\nf_0(v) = \\frac{n}{\\sqrt{\\pi}\\,v_{\\mathrm{th}}}\\,\\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right),\n$$\n其中密度 $n$ 的单位为 $\\mathrm{m^{-3}}$。区域为 $[v_{\\min}, v_{\\max}]$ 上的均匀网格，包含 $N$ 个网格点，并采用零通量边界。对于每种情况，设置隐式时间步长 $\\,\\Delta t = m \\,\\Delta t_{\\mathrm{exp}}\\,$，其中 $m$ 是一个乘数。在一个隐式步后，评估正性和守恒性。\n\n- 情况1（理想情况）：\n  - $N = 101$,\n  - $v_{\\min} = -5.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 5.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 5.0\\times 10^{6}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 1.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - 乘数 $m = 5$。\n\n- 情况2（强刚性）：\n  - $N = 81$,\n  - $v_{\\min} = -7.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 7.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 2.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 7.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - 乘数 $m = 50$。\n\n- 情况3（边界/粗网格边缘情况）：\n  - $N = 21$,\n  - $v_{\\min} = -4.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 4.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 1.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 8.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - 乘数 $m = 200$。\n\n算法要求：\n- Scharfetter–Gummel 通量必须通过在每个系数恒定的单元上精确求解稳态一维漂移-扩散平衡来推导，并使用局部界面速度在每个单元界面上进行评估。实现时必须确保在 $P\\to 0$ 时的相容性，其中 $P$ 表示界面单元佩克莱数。\n- 使用均匀网格间距 $\\,\\Delta v = (v_{\\max}-v_{\\min})/(N-1)\\,$。\n- 对于显式稳定性分析，从漂移和扩散约束中推导 $\\,\\Delta t_{\\mathrm{exp}}\\,$，并取更严格的界限。\n\n在代码中对每种情况执行一个隐式步后需要执行的验证任务：\n- 计算一个布尔值以指示正性，其定义为 $\\min_i f_i^{n+1} \\ge -\\epsilon \\max_i f_i^{n+1}$，其中 $\\epsilon = 10^{-12}$。\n- 计算一个布尔值以指示粒子数守恒，其定义为 $\\left|\\sum_i f_i^{n+1}\\Delta v - \\sum_i f_i^{n}\\Delta v\\right| \\le \\tau \\sum_i f_i^{n}\\Delta v$，其中容差 $\\tau = 10^{-6}$。\n- 计算并报告比率 $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$，作为一个浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。该列表必须按顺序包含情况1、情况2、情况3的每个情况的正性布尔值、守恒性布尔值和比率 $r$。输出中不应包含任何单位；所有布尔值和比率都是无量纲数。",
            "solution": "该问题被认为是有效的，因为它在科学上基于动理学理论和等离子体物理学原理，是适定的、客观的，并包含唯一解所需的所有必要信息。它提出了一个计算物理学中与福克-普朗克方程数值求解相关的标准问题。\n\n速度分布函数 $f(v, t)$ 的控制方程以守恒形式给出：\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0\n$$\n其中 $J$ 是速度空间中的碰撞通量。对于向热平衡态弛豫的单物种，福克-普朗克碰撞算子可以建模为漂移-扩散形式。驱动分布函数趋向麦克斯韦分布 $f_M \\propto \\exp(-v^2 / v_{\\mathrm{th}}^2)$ 的通量 $J$ 由下式给出：\n$$\nJ(v,t) = -\\nu \\left( v f(v,t) + \\frac{v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v} \\right)\n$$\n在此，与 $v f$ 成正比的项是漂移（或摩擦）项，它将粒子拉向 $v=0$；与 $\\partial f / \\partial v$ 成正比的项是扩散项，它使分布展宽。参数是碰撞频率 $\\nu$ 和热速度 $v_{\\mathrm{th}}$。可以验证，对于麦克斯韦分布，$J=0$，因此它是稳态解。\n\n该问题要求完成三项任务：对显式格式进行稳定性分析，设计并实现一个守恒且保正的隐式格式，以及在一套测试用例上执行此格式。\n\n### 1. 显式时间步进稳定性约束\n\n为分析碰撞算子的刚性，我们使用前向欧拉法对时间进行离散，并分别考察漂移项和扩散项所施加的稳定性约束。我们考虑一个间距为 $\\Delta v$ 的均匀速度网格 $v_i$。从时间 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的更新为 $f_i^{n+1} = f_i^n - \\frac{\\Delta t}{\\Delta v} (J_{i+1/2}^n - J_{i-1/2}^n)$。为保证稳定性，我们要求 $f_i^{n+1}$ 表达式中 $f_j^n$ 的系数满足特定条件，以防止误差放大。\n\n**扩散约束：**\n方程的扩散部分为 $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v} \\left(\\frac{\\nu v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v}\\right)$。对于常数扩散系数 $D = \\frac{\\nu v_{\\mathrm{th}}^2}{2}$，这就是热方程 $\\frac{\\partial f}{\\partial t} = D \\frac{\\partial^2 f}{\\partial v^2}$。使用标准的中心差分空间离散和前向欧拉时间离散，我们得到：\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} = D \\frac{f_{i+1}^n - 2f_i^n + f_{i-1}^n}{(\\Delta v)^2}\n$$\n已知该格式的稳定性（例如，通过冯·诺依曼分析或要求系数为正）受以下条件限制：\n$$\n\\Delta t \\le \\frac{(\\Delta v)^2}{2D} \\implies \\Delta t_{\\mathrm{diff}} \\le \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\n$$\n\n**漂移约束：**\n方程的漂移部分为 $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v}(\\nu v f)$。在守恒形式下，$\\frac{\\partial f}{\\partial t} + \\frac{\\partial J_{\\mathrm{drift}}}{\\partial v} = 0$，通量为 $J_{\\mathrm{drift}} = -\\nu v f$。这是一个具有空间相关速度 $c(v) = -\\nu v$ 的线性平流方程。为保证稳定性，若使用一阶迎风格式，则必须满足 Courant-Friedrichs-Lewy (CFL) 条件。显式平流格式的 CFL 条件为：\n$$\n\\Delta t \\le \\frac{\\Delta v}{\\max |c(v)|}\n$$\n在我们的速度域 $v \\in [v_{\\min}, v_{\\max}]$ 中，最大平流速度为 $|c(v)|_{\\max} = \\nu \\max(|v_{\\min}|, |v_{\\max}|)$。令 $v_{\\mathrm{domain\\_max}} = \\max(|v_{\\min}|, |v_{\\max}|)$。则稳定性约束为：\n$$\n\\Delta t_{\\mathrm{drift}} \\le \\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}\n$$\n\n**最大显式时间步长 $\\Delta t_{\\mathrm{exp}}$：**\n对于一个稳定的显式格式，两个条件都必须满足。因此，总的显式时间步长受两者中更严格的那个限制：\n$$\n\\Delta t_{\\mathrm{exp}} = \\min(\\Delta t_{\\mathrm{drift}}, \\Delta t_{\\mathrm{diff}}) = \\min\\left(\\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}, \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\\right)\n$$\n此界限用于定义隐式求解器的时间步长。\n\n### 2. 隐式时间步进格式\n\n我们使用有限体积离散化、后向欧拉时间积分和 Scharfetter-Gummel 通量近似来实现一个无条件稳定的隐式格式。\n\n**有限体积离散化：**\n我们在一个包含 $N$ 个点 $v_i$（$i=0, \\dots, N-1$）的均匀网格上进行离散化。第 $i$ 个有限体积是以 $v_i$ 为中心的 $[v_i - \\Delta v/2, v_i + \\Delta v/2]$。界面位于 $v_{i+1/2} = v_i + \\Delta v/2$。在第 $i$ 个单元上对连续性方程进行积分，得到：\n$$\n\\frac{d f_i}{d t} = -\\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta v}\n$$\n在时间上应用后向欧拉离散，得到：\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\n\n**Scharfetter-Gummel 通量：**\nSG 通量是通过在网格单元 $[v_i, v_{i+1}]$ 上求解稳态一维漂移-扩散方程 $J = \\text{常数}$ 推导出来的，其中假设系数是恒定的。需要求解的方程是：\n$$\nJ_{i+1/2} = -\\nu \\left( v_{i+1/2} f(v) + D \\frac{df}{dv} \\right)\n$$\n其中 $D = v_{\\mathrm{th}}^2/2$，而 $v_{i+1/2}$ 是界面处的速度。这是一个关于 $f(v)$ 的一阶线性常微分方程。在边界条件 $f(v_i)=f_i$ 和 $f(v_{i+1})=f_{i+1}$ 下求解该方程，可得到以单元边缘值 $f_i$ 和 $f_{i+1}$ 表示的通量 $J_{i+1/2}$：\n$$\nJ_{i+1/2} = \\frac{\\nu D}{\\Delta v} \\left[ B(P_{i+1/2}) f_i - B(-P_{i+1/2}) f_{i+1} \\right]\n$$\n这里，$P_{i+1/2}$ 是局部佩克莱数，它衡量了漂移与扩散的比率：\n$$\nP_{i+1/2} = \\frac{v_{i+1/2} \\Delta v}{D} = \\frac{2 v_{i+1/2} \\Delta v}{v_{\\mathrm{th}}^2}\n$$\n而 $B(x) = x / (e^x - 1)$ 是伯努利函数。这种通量公式至关重要，因为它能正确平衡漂移和扩散，并确保正性。\n\n**线性系统及其性质：**\n将 SG 通量代入后向欧拉方程，得到一个关于未知分布 $\\vec{f}^{n+1} = [f_0^{n+1}, \\dots, f_{N-1}^{n+1}]^T$ 的线性系统：\n$$\nM \\vec{f}^{n+1} = \\vec{f}^n\n$$\n矩阵 $M$ 是三对角的。零通量边界条件 $J(v_{\\min})=0$ 和 $J(v_{\\max})=0$ 是通过将区域边界上的通量设为零来实现的，即 $J_{-1/2} = 0$ 和 $J_{N-1/2} = 0$。对于 $i,j \\in \\{0, \\dots, N-1\\}$，得到的矩阵元素为：\n- 对于 $i \\in [1, N-2]$ (内部点):\n  - $M_{i,i-1} = -\\alpha B(P_{i-1/2})$\n  - $M_{i,i} = 1 + \\alpha (B(P_{i+1/2}) + B(-P_{i-1/2}))$\n  - $M_{i,i+1} = -\\alpha B(-P_{i+1/2})$\n- 对于 $i=0$ (左边界):\n  - $M_{0,0} = 1 + \\alpha B(P_{1/2})$\n  - $M_{0,1} = -\\alpha B(-P_{1/2})$\n- 对于 $i=N-1$ (右边界):\n  - $M_{N-1,N-2} = -\\alpha B(P_{N-3/2})$\n  - $M_{N-1,N-1} = 1 + \\alpha B(-P_{N-3/2})$\n其中 $\\alpha = \\frac{\\Delta t \\nu v_{\\mathrm{th}}^2}{2(\\Delta v)^2}$。\n\n**正性与守恒性：**\n伯努利函数 $B(x)$ 总是正的。因此，矩阵 $M$ 的对角线元素为正（$M_{ii} > 1$），非对角线元素为非正（$i \\ne j$ 时 $M_{ij} \\le 0$）。此外，可以证明 $M$ 的每一列之和恰好为1，这可以利用恒等式 $B(x)+B(-x) = x B(x)/(e^x-1) - x/(e^{-x}-1) = x/(e^x-1) + xe^x/(e^x-1)=x(1+e^x)/(e^x-1)$。等等，这变得复杂了。性质 $B(x) e^x = B(-x)$ 很简单。利用这个性质，该特性源于通量的构造方式。在 $f_i$ 的更新中，乘以 $f_j$ 的系数之和为1。$\\sum_i M_{ij} = 1$。这意味着 $M$ 是一个列随机矩阵。具有这些性质的矩阵是M-矩阵，其逆矩阵 $M^{-1}$ 的所有元素都将是非负的。因此，如果对所有 $i$ 都有 $f_i^n \\ge 0$，那么 $f_i^{n+1} = (M^{-1}\\vec{f}^n)_i \\ge 0$。该格式是保正的。\n\n通过采用零通量边界的有限体积公式，可以确保粒子数守恒。对所有单元 $i=0, \\dots, N-1$ 的离散方程求和：\n$$\n\\sum_i \\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\sum_i \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\n第二项求和是一个伸缩级数：$\\sum_i (J_{i+1/2} - J_{i-1/2}) = J_{N-1/2} - J_{-1/2}$。在边界条件 $J_{N-1/2}=0$ 和 $J_{-1/2}=0$ 下，此和为零。这导致 $\\sum_i (f_i^{n+1} - f_i^n) = 0$，即 $\\sum_i f_i^{n+1} \\Delta v = \\sum_i f_i^n \\Delta v$。总粒子数是守恒的。\n\n### 3. 算法实现\n\n程序实现了推导出的隐式格式。对于每个测试用例，它设置速度网格，计算 $\\Delta t_{\\mathrm{exp}}$ 和隐式 $\\Delta t$，并定义初始的麦克斯韦分布。然后，通过计算佩克莱数并在每个界面上评估伯努利函数来构造三对角矩阵 $M$。所得到的线性系统使用 `scipy.linalg.solve_banded` 进行高效求解。最后，它执行所要求的正性和粒子数守恒检查，并计算比率 $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef bernoulli(x):\n    \"\"\"\n    Robust implementation of the Bernoulli function B(x) = x / (e^x - 1).\n    Uses a Taylor expansion for small |x| to avoid division by zero and floating point errors.\n    \"\"\"\n    if np.abs(x)  1e-9:\n        # Taylor series for B(x) around x=0: 1 - x/2 + x^2/12 - x^4/720 + ...\n        return 1.0 - x / 2.0 + x**2 / 12.0 - x**4 / 720.0\n    else:\n        return x / (np.exp(x) - 1.0)\n\ndef solve_case(N, v_min, v_max, nu, v_th, n, m):\n    \"\"\"\n    Solves one test case for the Fokker-Planck collision operator.\n    \"\"\"\n    # 1. Grid and Initial Condition\n    v = np.linspace(v_min, v_max, N)\n    delta_v = (v_max - v_min) / (N - 1)\n    \n    f_initial = (n / (np.sqrt(np.pi) * v_th)) * np.exp(-(v**2 / v_th**2))\n\n    # 2. Timestep Calculation (based on explicit stability)\n    v_domain_max = np.max(np.abs([v_min, v_max]))\n    # Stability from drift (CFL condition)\n    dt_drift = delta_v / (nu * v_domain_max)\n    # Stability from diffusion\n    dt_diff = delta_v**2 / (nu * v_th**2)\n    # The more restrictive of the two determines the explicit timestep limit\n    dt_exp = min(dt_drift, dt_diff)\n    \n    # Set the implicit timestep as a multiple of the explicit limit\n    delta_t = m * dt_exp\n\n    # 3. Assemble the Implicit Matrix M for M*f_next = f_initial\n    # Interface velocities (N-1 interfaces)\n    v_interfaces = v[:-1] + delta_v / 2.0\n    \n    # Péclet numbers at interfaces\n    peclet = (2.0 * v_interfaces * delta_v) / (v_th**2)\n    \n    # Constant term alpha\n    D_coeff = v_th**2 / 2.0\n    alpha = (delta_t * nu * D_coeff) / (delta_v**2)\n\n    # Scipy's solve_banded expects the matrix in `ab` format.\n    # For a tridiagonal matrix (l=1, u=1), ab has 3 rows:\n    # ab[0, 1:] = Super-diagonal\n    # ab[1, :]   = Main diagonal\n    # ab[2, :-1] = Sub-diagonal\n    ab = np.zeros((3, N))\n    \n    B_p = np.array([bernoulli(p) for p in peclet])\n    B_neg_p = np.array([bernoulli(-p) for p in peclet])\n    \n    # Main diagonal M_i,i\n    ab[1, 1:-1] = 1.0 + alpha * (B_p[1:] + B_neg_p[:-1])\n    ab[1, 0] = 1.0 + alpha * B_p[0] # Left boundary\n    ab[1, -1] = 1.0 + alpha * B_neg_p[-1] # Right boundary\n\n    # Super-diagonal M_i,i+1\n    ab[0, 1:] = -alpha * B_neg_p\n\n    # Sub-diagonal M_i,i-1\n    ab[2, :-1] = -alpha * B_p\n\n    # 4. Solve the linear system\n    f_next = solve_banded((1, 1), ab, f_initial)\n    \n    # 5. Validation Checks\n    # Positivity check\n    epsilon = 1e-12\n    # Ensure min(f_next) is not negative beyond a small tolerance relative to max(f_next)\n    positivity = bool(np.min(f_next) >= -epsilon * np.max(f_next))\n    \n    # Conservation check\n    tau = 1e-6\n    total_N_initial = np.sum(f_initial) * delta_v\n    total_N_final = np.sum(f_next) * delta_v\n    \n    if np.abs(total_N_initial)  1e-15: # Handle case of zero initial distribution\n        conservation = bool(np.abs(total_N_final - total_N_initial) = tau)\n    else:\n        conservation = bool(np.abs(total_N_final - total_N_initial) = tau * np.abs(total_N_initial))\n    \n    # Ratio of implicit to explicit timestep\n    ratio = delta_t / dt_exp\n    \n    return positivity, conservation, ratio\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\"N\": 101, \"v_min\": -5.0e5, \"v_max\": 5.0e5, \"nu\": 5.0e6, \"v_th\": 1.0e5, \"n\": 1.0e19, \"m\": 5},\n        # Case 2 (strong stiffness)\n        {\"N\": 81, \"v_min\": -7.0e5, \"v_max\": 7.0e5, \"nu\": 2.0e7, \"v_th\": 7.0e4, \"n\": 1.0e19, \"m\": 50},\n        # Case 3 (boundary/coarse-grid edge case)\n        {\"N\": 21, \"v_min\": -4.0e5, \"v_max\": 4.0e5, \"nu\": 1.0e7, \"v_th\": 8.0e4, \"n\": 1.0e19, \"m\": 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        pos, cons, r = solve_case(\n            N=case[\"N\"],\n            v_min=case[\"v_min\"],\n            v_max=case[\"v_max\"],\n            nu=case[\"nu\"],\n            v_th=case[\"v_th\"],\n            n=case[\"n\"],\n            m=case[\"m\"]\n        )\n        # Python bools are 'True'/'False'. Format to lowercase 'true'/'false' if needed.\n        # But problem output example does not specify, so default representation is likely fine.\n        results.extend([pos, cons, r])\n\n    # Format the final output string exactly as required\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}