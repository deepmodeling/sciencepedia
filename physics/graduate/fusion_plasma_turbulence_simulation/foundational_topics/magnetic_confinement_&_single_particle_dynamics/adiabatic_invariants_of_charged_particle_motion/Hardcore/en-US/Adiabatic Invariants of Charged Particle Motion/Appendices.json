{
    "hands_on_practices": [
        {
            "introduction": "This first practice connects theory to a fundamental physical mechanism: the magnetic mirror force. By applying the principles of energy conservation and the conservation of the first adiabatic invariant, $\\mu$, in a simple, spatially varying magnetic field, you will analytically derive the force that underpins particle confinement in both natural and man-made magnetic traps . This exercise solidifies the understanding of how a particle's perpendicular energy couples to its parallel motion through the magnetic moment.",
            "id": "4180217",
            "problem": "A single charged particle of mass $m$ and charge $q$ moves in a static, linearly varying magnetic field $ \\mathbf{B}(z) = B_0 \\left(1 + \\alpha z \\right) \\hat{\\mathbf{z}} $, where $B_0 > 0$, $\\alpha$ is a constant with dimensions of inverse length, and $z$ is the coordinate along the magnetic field. There is no electric field, and non-magnetic forces are negligible. At $z=0$, the particle has perpendicular speed $v_{\\perp 0}$ and parallel speed $v_{\\parallel 0}$ relative to the local magnetic field direction. Assume the guiding-center approximation applies and the first adiabatic invariant (the magnetic moment) is conserved, under the ordering $\\alpha \\rho_L \\ll 1$, where the Larmor radius is $\\rho_L = v_{\\perp}/\\Omega$ and the gyrofrequency is $\\Omega = q B/m$. \n\nStarting from the Lorentz force law and the conservation of total kinetic energy in a static magnetic field, use the conservation of the first adiabatic invariant to derive, to leading order in the small parameter $\\alpha z$, the changes in the perpendicular and parallel speeds, $\\Delta v_{\\perp}(z) = v_{\\perp}(z) - v_{\\perp 0}$ and $\\Delta v_{\\parallel}(z) = v_{\\parallel}(z) - v_{\\parallel 0}$. Under the same ordering and assumptions, determine the parallel mirror force $F_{\\parallel}(z)$ exerted on the guiding center due to the magnetic field inhomogeneity. Express your final expressions in terms of the symbols $m$, $q$, $B_0$, $\\alpha$, $z$, $v_{\\perp 0}$, and $v_{\\parallel 0}$. Interpret the mirror force in International System of Units (SI) newtons, but do not attach units in the final boxed answer. Provide closed-form symbolic expressions valid to first order in $\\alpha z$. No numerical rounding is required.",
            "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- **Particle:** mass $m$, charge $q$.\n- **Magnetic Field:** $\\mathbf{B}(z) = B_0 \\left(1 + \\alpha z \\right) \\hat{\\mathbf{z}}$, where $B_0 > 0$ and $\\alpha$ is a constant.\n- **Electric Field:** $\\mathbf{E} = 0$.\n- **Other Forces:** Negligible.\n- **Initial Conditions (at $z=0$):** Perpendicular speed $v_{\\perp 0}$, parallel speed $v_{\\parallel 0}$.\n- **Assumptions:**\n    - Guiding-center approximation is valid.\n    - The first adiabatic invariant (magnetic moment, $\\mu$) is conserved.\n    - The ordering parameter $\\alpha \\rho_L \\ll 1$ holds, where $\\rho_L = v_{\\perp}/\\Omega$ and $\\Omega = q B/m$.\n- **Task:**\n    1. Derive the change in perpendicular speed, $\\Delta v_{\\perp}(z) = v_{\\perp}(z) - v_{\\perp 0}$, to leading order in $\\alpha z$.\n    2. Derive the change in parallel speed, $\\Delta v_{\\parallel}(z) = v_{\\parallel}(z) - v_{\\parallel 0}$, to leading order in $\\alpha z$.\n    3. Determine the parallel mirror force $F_{\\parallel}(z)$ under the same ordering.\n    4. Express results in terms of $m$, $q$, $B_0$, $\\alpha$, $z$, $v_{\\perp 0}$, and $v_{\\parallel 0}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem deals with the motion of a charged particle in an inhomogeneous magnetic field, a fundamental topic in plasma physics and electromagnetism. The concept of adiabatic invariants, specifically the magnetic moment, and the resulting mirror force are well-established and core to understanding phenomena like magnetic confinement in fusion devices and particle trapping in planetary magnetospheres. The linear approximation of the magnetic field, $B(z) = B_0(1 + \\alpha z)$, is a standard and valid approach for studying local dynamics. The problem is based on sound physical principles.\n- **Well-Posed:** The problem provides all necessary initial conditions ($v_{\\perp 0}$, $v_{\\parallel 0}$), the form of the magnetic field, and the governing conservation laws (conservation of energy and the first adiabatic invariant). This information is sufficient to uniquely determine the specified quantities ($\\Delta v_{\\perp}(z)$, $\\Delta v_{\\parallel}(z)$, $F_{\\parallel}(z)$) to the required order of approximation.\n- **Objective:** The problem is stated in precise, quantitative language, free of ambiguity, subjectivity, or opinion.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, objective, and complete. It is therefore deemed **valid**. The solution will now be derived.\n\nThe motion of the charged particle is governed by two fundamental conservation laws.\n\n**1. Conservation of Kinetic Energy:**\nThe Lorentz force, $\\mathbf{F} = q(\\mathbf{v} \\times \\mathbf{B})$, is always perpendicular to the particle's velocity $\\mathbf{v}$. Consequently, it does no work on the particle. Since the electric field is zero and other forces are negligible, the total kinetic energy $K$ of the particle is conserved.\nThe total kinetic energy is the sum of the kinetic energy associated with motion perpendicular to the magnetic field ($K_{\\perp}$) and parallel to it ($K_{\\parallel}$):\n$$K = K_{\\perp} + K_{\\parallel} = \\frac{1}{2}m v_{\\perp}^2 + \\frac{1}{2}m v_{\\parallel}^2$$\nConservation of energy implies:\n$$ \\frac{1}{2}m (v_{\\perp}(z)^2 + v_{\\parallel}(z)^2) = \\frac{1}{2}m (v_{\\perp 0}^2 + v_{\\parallel 0}^2) $$\n$$ v_{\\perp}(z)^2 + v_{\\parallel}(z)^2 = v_{\\perp 0}^2 + v_{\\parallel 0}^2 = \\text{constant} $$\n\n**2. Conservation of the First Adiabatic Invariant (Magnetic Moment):**\nThe problem states that the first adiabatic invariant, the magnetic moment $\\mu$, is conserved. The magnetic moment is defined as the ratio of the perpendicular kinetic energy to the magnitude of the magnetic field:\n$$ \\mu = \\frac{K_{\\perp}}{B} = \\frac{\\frac{1}{2} m v_{\\perp}^2}{B} $$\nConservation of $\\mu$ means:\n$$ \\frac{v_{\\perp}(z)^2}{B(z)} = \\frac{v_{\\perp 0}^2}{B_0} = \\text{constant} $$\nwhere $B(z) = |\\mathbf{B}(z)| = B_0(1 + \\alpha z)$ and $B(0) = B_0$.\n\nWe can now use these two principles to find the desired quantities.\n\n**Derivation of $\\Delta v_{\\perp}(z)$:**\nFrom the conservation of the magnetic moment, we have:\n$$ v_{\\perp}(z)^2 = v_{\\perp 0}^2 \\frac{B(z)}{B_0} = v_{\\perp 0}^2 \\frac{B_0(1 + \\alpha z)}{B_0} = v_{\\perp 0}^2 (1 + \\alpha z) $$\nTo find $v_{\\perp}(z)$, we take the square root:\n$$ v_{\\perp}(z) = v_{\\perp 0} \\sqrt{1 + \\alpha z} $$\nThe problem requires the result to leading order in the small parameter $\\alpha z$. We use the binomial approximation $\\sqrt{1+x} \\approx 1 + \\frac{1}{2}x$ for small $x$.\n$$ v_{\\perp}(z) \\approx v_{\\perp 0} \\left(1 + \\frac{1}{2} \\alpha z\\right) $$\nThe change in perpendicular speed, $\\Delta v_{\\perp}(z)$, is then:\n$$ \\Delta v_{\\perp}(z) = v_{\\perp}(z) - v_{\\perp 0} \\approx v_{\\perp 0} \\left(1 + \\frac{1}{2} \\alpha z\\right) - v_{\\perp 0} = \\frac{1}{2} v_{\\perp 0} \\alpha z $$\n\n**Derivation of $\\Delta v_{\\parallel}(z)$:**\nFrom the conservation of energy, we can express $v_{\\parallel}(z)^2$:\n$$ v_{\\parallel}(z)^2 = (v_{\\perp 0}^2 + v_{\\parallel 0}^2) - v_{\\perp}(z)^2 $$\nSubstituting the expression for $v_{\\perp}(z)^2$ from the conservation of $\\mu$:\n$$ v_{\\parallel}(z)^2 = (v_{\\perp 0}^2 + v_{\\parallel 0}^2) - v_{\\perp 0}^2 (1 + \\alpha z) = v_{\\parallel 0}^2 - v_{\\perp 0}^2 \\alpha z $$\nTo find $v_{\\parallel}(z)$, we take the square root:\n$$ v_{\\parallel}(z) = \\sqrt{v_{\\parallel 0}^2 - v_{\\perp 0}^2 \\alpha z} = v_{\\parallel 0} \\sqrt{1 - \\frac{v_{\\perp 0}^2}{v_{\\parallel 0}^2} \\alpha z} $$\nAgain, we use the binomial approximation $\\sqrt{1-x} \\approx 1 - \\frac{1}{2}x$ for small $x = \\frac{v_{\\perp 0}^2}{v_{\\parallel 0}^2} \\alpha z$:\n$$ v_{\\parallel}(z) \\approx v_{\\parallel 0} \\left(1 - \\frac{1}{2} \\frac{v_{\\perp 0}^2}{v_{\\parallel 0}^2} \\alpha z\\right) = v_{\\parallel 0} - \\frac{v_{\\perp 0}^2}{2 v_{\\parallel 0}} \\alpha z $$\nThe change in parallel speed, $\\Delta v_{\\parallel}(z)$, is:\n$$ \\Delta v_{\\parallel}(z) = v_{\\parallel}(z) - v_{\\parallel 0} \\approx \\left(v_{\\parallel 0} - \\frac{v_{\\perp 0}^2}{2 v_{\\parallel 0}} \\alpha z\\right) - v_{\\parallel 0} = -\\frac{v_{\\perp 0}^2}{2 v_{\\parallel 0}} \\alpha z $$\n\n**Derivation of the Parallel Mirror Force $F_{\\parallel}(z)$:**\nThe parallel force on the guiding center, known as the mirror force, arises from the magnetic field gradient. It is given by the negative gradient of the perpendicular kinetic energy, which acts as a potential for the parallel motion.\n$$ F_{\\parallel} = -\\nabla_{\\parallel} (\\mu B) $$\nSince the field varies only in the $z$-direction, this simplifies to:\n$$ F_{\\parallel}(z) = -\\mu \\frac{d B}{dz} $$\nThe magnetic moment $\\mu$ is constant and can be evaluated at $z=0$:\n$$ \\mu = \\frac{\\frac{1}{2} m v_{\\perp 0}^2}{B_0} $$\nThe gradient of the magnetic field is:\n$$ \\frac{d B}{dz} = \\frac{d}{dz} \\left[ B_0 (1 + \\alpha z) \\right] = B_0 \\alpha $$\nSubstituting these into the expression for the force:\n$$ F_{\\parallel}(z) = - \\left( \\frac{\\frac{1}{2} m v_{\\perp 0}^2}{B_0} \\right) (B_0 \\alpha) = -\\frac{1}{2} m v_{\\perp 0}^2 \\alpha $$\nThis result is independent of $z$ because the magnetic field gradient is constant. This expression is exact under the assumption that $\\mu$ is conserved. It doesn't rely on the small $\\alpha z$ approximation itself, but it is derived under the same physical assumptions. If $\\alpha > 0$, the force is directed in the $-\\hat{\\mathbf{z}}$ direction, pushing the particle away from the stronger field region, hence the term \"mirror force\".\n\nThe three requested quantities are:\n1. $\\Delta v_{\\perp}(z) = \\frac{1}{2} v_{\\perp 0} \\alpha z$\n2. $\\Delta v_{\\parallel}(z) = -\\frac{v_{\\perp 0}^2}{2 v_{\\parallel 0}} \\alpha z$\n3. $F_{\\parallel}(z) = -\\frac{1}{2} m v_{\\perp 0}^2 \\alpha$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2} v_{\\perp 0} \\alpha z & -\\frac{v_{\\perp 0}^{2}}{2 v_{\\parallel 0}} \\alpha z & -\\frac{1}{2} m v_{\\perp 0}^{2} \\alpha\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Adiabatic invariants are conserved when system parameters change \"slowly,\" but what does this mean in practice? This hands-on computational exercise challenges you to explore this question by building a simulation of a trapped particle's bounce motion and numerically calculating its second adiabatic invariant, $J_{\\parallel}$ . By testing how well $J_{\\parallel}$ is conserved under different rates of magnetic field variation, you will develop a practical intuition for the robustness and limitations of adiabatic theory.",
            "id": "4180180",
            "problem": "Consider a charged particle of mass $m$ and charge $q$ moving in a nonuniform magnetic field while the electric field parallel to the magnetic field is zero. The persistent slow variation of the magnetic field magnitude produces bounce motion for particles that are trapped in local magnetic wells. Under the guiding-center approximation derived from the Lorentz force law, the parallel dynamics along the field-line arc length coordinate $l$ can be represented by a one-dimensional equation of motion with the mirror force. The fundamental base is the Lorentz force law and the guiding-center approximation, which leads to the evolution equations $m\\,dv_\\parallel/dt = -\\mu\\,\\partial B/\\partial l$, with $dl/dt = v_\\parallel$ and $E_\\parallel = 0$, where $\\mu$ is the magnetic moment and $B(l,t)$ is the magnetic field strength along the field line. The canonical bounce action diagnostic is defined as the bounce integral of the parallel canonical momentum over the spatial path between mirror points. Your task is to implement, test, and evaluate the time invariance of this diagnostic from first principles.\n\nYou must write a complete and runnable program that:\n- Simulates guiding-center parallel motion using the one-dimensional equation $m\\,dv_\\parallel/dt = -\\mu\\,\\partial B/\\partial l$, with $dl/dt = v_\\parallel$ and $E_\\parallel = 0$, for a set of specified parameters.\n- Uses a magnetic field model $B(l,t) = B_0\\left(1+\\alpha\\,(l/L)^2\\right)\\left(1+\\varepsilon\\,\\sin(\\omega\\,t)\\right)$, where $B_0$ is the base magnetic field, $\\alpha$ controls the curvature of the magnetic well, $L$ is a characteristic length scale, $\\varepsilon$ is the dimensionless amplitude of slow temporal modulation, and $\\omega$ is the angular frequency of the modulation.\n- Computes the bounce action diagnostic $J_\\parallel(t)$ defined by $J_\\parallel(t)=\\int_{l_1(t)}^{l_2(t)} p_\\parallel\\,dl$, where $p_\\parallel = m\\,v_\\parallel$ and $l_1(t),l_2(t)$ are the instantaneous mirror points determined by zero crossings of $v_\\parallel(t)$.\n- Implements accurate mirror point detection by interpolation across velocity sign changes to estimate the crossing time and position at which $v_\\parallel=0$. The interpolation must be used to place $p_\\parallel=0$ at the mirror points and to delimit each half-bounce segment.\n- Evaluates the time invariance by computing, over all resolved half-bounce segments in the simulated time window, the dimensionless relative variation of the bounce action defined by $\\Delta_J=\\left(\\max(J_\\parallel)-\\min(J_\\parallel)\\right)/\\langle J_\\parallel\\rangle$, where $\\langle J_\\parallel\\rangle$ is the arithmetic mean of $J_\\parallel$ across segments. If fewer than two half-bounce segments are detected, return a not-a-number float for that case.\n- Uses the International System of Units (SI): $l$ in meters, $t$ in seconds, $v_\\parallel$ in meters per second, $m$ in kilograms, $B$ in tesla, $\\mu$ in joules per tesla, and $J_\\parallel$ in kilogram meter squared per second. The final reported output for each test case must be the dimensionless quantity $\\Delta_J$ expressed as a decimal number.\n\nNumerical requirements:\n- Use a fixed-step explicit method to integrate the ordinary differential equations; a fourth-order Rungeâ€“Kutta scheme is acceptable.\n- Detect all $v_\\parallel$ sign changes robustly and use linear interpolation to refine mirror point locations.\n- Compute the bounce action integral for each half-bounce by numerical quadrature over the simulated path using the trapezoidal rule applied to $p_\\parallel$ as a function of $l$ along the path between successive mirror points.\n\nTest suite:\nSimulate the following parameter sets. Each parameter set is a tuple $(m,\\mu,B_0,\\alpha,L,l_0,v_0,\\varepsilon,\\omega,t_{\\mathrm{end}},\\Delta t)$, with all quantities in SI units:\n- Case $1$ (static, deeply trapped): $(2.0\\times 10^{-27},\\,3.5\\times 10^{-18},\\,3.0,\\,4.0,\\,1.0,\\,0.0,\\,8.0\\times 10^{4},\\,0.0,\\,0.0,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-6})$.\n- Case $2$ (static, near separatrix): $(2.0\\times 10^{-27},\\,3.5\\times 10^{-18},\\,3.0,\\,4.0,\\,1.0,\\,0.0,\\,1.95\\times 10^{5},\\,0.0,\\,0.0,\\,2.0\\times 10^{-2},\\,1.0\\times 10^{-6})$.\n- Case $3$ (slow temporal modulation): $(2.0\\times 10^{-27},\\,3.5\\times 10^{-18},\\,3.0,\\,4.0,\\,1.0,\\,0.0,\\,1.0\\times 10^{5},\\,1.0\\times 10^{-2},\\,1.0\\times 10^{3},\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-6})$.\n- Case $4$ (strong modulation at bounce scale): $(2.0\\times 10^{-27},\\,3.5\\times 10^{-18},\\,3.0,\\,4.0,\\,1.0,\\,0.0,\\,1.0\\times 10^{5},\\,2.0\\times 10^{-1},\\,2.0\\times 10^{5},\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-6})$.\n- Case $5$ (very small amplitude, static): $(2.0\\times 10^{-27},\\,3.5\\times 10^{-18},\\,3.0,\\,4.0,\\,1.0,\\,0.0,\\,2.0\\times 10^{4},\\,0.0,\\,0.0,\\,5.0\\times 10^{-3},\\,1.0\\times 10^{-6})$.\n\nAnswer specification:\n- For each test case, compute the dimensionless relative variation $\\Delta_J$ across all resolved half-bounce segments in the simulated time window.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite cases, for example, $[\\Delta J_1,\\Delta J_2,\\Delta J_3,\\Delta J_4,\\Delta J_5]$.",
            "solution": "The problem requires a numerical investigation of the second adiabatic invariant, known as the longitudinal or bounce invariant $J_\\parallel$, for a charged particle undergoing bounce motion in a magnetic mirror. The validity of this invariant rests on the principle that if the parameters of an oscillating system change slowly compared to the oscillation period, then the action integral over one period is approximately constant. Here, we will test this principle by simulating the particle's motion and calculating the variation of $J_\\parallel$ under different conditions, particularly when the magnetic field itself varies in time.\n\nThe governing equations for the parallel guiding-center motion are provided as:\n$$\n\\frac{dl}{dt} = v_\\parallel\n$$\n$$\nm\\frac{dv_\\parallel}{dt} = F_\\parallel = -\\mu \\frac{\\partial B}{\\partial l}\n$$\nwhere $l$ is the coordinate along the magnetic field line, $v_\\parallel$ is the velocity parallel to the field line, $m$ is the particle mass, and $\\mu$ is its magnetic moment, which is assumed to be a constant (the first adiabatic invariant). The force $F_\\parallel$ arises from the spatial gradient of the magnetic field, known as the mirror force. The electric field parallel to $\\vec{B}$ is specified to be zero ($E_\\parallel = 0$).\n\nThis system constitutes a set of two coupled first-order ordinary differential equations (ODEs). We can represent the state of the system by a vector $\\mathbf{y}(t) = [l(t), v_\\parallel(t)]^T$. The evolution of the system is then described by $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$, where:\n$$\n\\mathbf{f}(t, \\mathbf{y}) = \\begin{pmatrix} v_\\parallel \\\\ -\\frac{\\mu}{m} \\frac{\\partial B}{\\partial l} \\end{pmatrix}\n$$\n\nThe magnetic field model is given as a parabolic well with sinusoidal time modulation:\n$$\nB(l,t) = B_0\\left(1+\\alpha\\left(\\frac{l}{L}\\right)^2\\right)\\left(1+\\varepsilon\\sin(\\omega t)\\right)\n$$\nTo calculate the mirror force, we must find the partial derivative of $B$ with respect to $l$:\n$$\n\\frac{\\partial B}{\\partial l} = B_0\\left(\\frac{2\\alpha l}{L^2}\\right)\\left(1+\\varepsilon\\sin(\\omega t)\\right)\n$$\nThis expression is then substituted into the equation of motion for $v_\\parallel$.\n\nTo solve this system numerically, we employ the fourth-order Runge-Kutta (RK4) method, a robust and widely used explicit scheme for integrating ODEs. Given a time step $\\Delta t$, the state vector $\\mathbf{y}_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is found from the state $\\mathbf{y}_n$ at time $t_n$ as follows:\n$$\n\\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(t_n, \\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}\\left(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2}\\right)\n$$\n$$\n\\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}\\left(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2}\\right)\n$$\n$$\n\\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3)\n$$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nWe apply this scheme step-by-step from the initial conditions $(l_0, v_0)$ at $t=0$ up to the final simulation time $t_{\\mathrm{end}}$, storing the trajectory $(t_i, l_i, v_{\\parallel, i})$ at each step.\n\nThe core of the analysis is the bounce action diagnostic, $J_\\parallel$, defined as the integral of the parallel momentum $p_\\parallel = m v_\\parallel$ along the spatial path between two consecutive mirror points, $l_1$ and $l_2$. This corresponds to a half-bounce of the particle.\n$$\nJ_\\parallel = \\int_{l_1}^{l_2} p_\\parallel \\, dl\n$$\nMirror points are the locations where the particle's parallel motion reverses, i.e., where $v_\\parallel = 0$. In our discrete simulation, we detect a mirror point crossing when the sign of $v_\\parallel$ changes between two consecutive time steps, i.e., $v_{\\parallel, i-1} \\cdot v_{\\parallel, i} \\le 0$. To accurately locate the mirror point, we use linear interpolation. If a crossing occurs between times $t_{i-1}$ and $t_i$, the time of the crossing $t_{\\text{mirror}}$ is estimated as:\n$$\nt_{\\text{mirror}} = t_{i-1} - v_{\\parallel, i-1} \\frac{t_i - t_{i-1}}{v_{\\parallel, i} - v_{\\parallel, i-1}}\n$$\nThe corresponding position $l_{\\text{mirror}}$ is found by linearly interpolating the position $l(t)$ at $t_{\\text{mirror}}$:\n$$\nl_{\\text{mirror}} = l_{i-1} + (t_{\\text{mirror}} - t_{i-1}) \\frac{l_i - l_{i-1}}{t_i - t_{i-1}}\n$$\n\nAfter the simulation, we identify all such mirror points to partition the trajectory into a series of complete half-bounce segments. For each segment, from a starting mirror point $M_1 = (t_{\\text{m1}}, l_{\\text{m1}})$ to an ending mirror point $M_2 = (t_{\\text{m2}}, l_{\\text{m2}})$, we construct the integration path. This path consists of the sequence of discrete points $(l_i, p_{\\parallel,i})$ from the simulation that lie between $M_1$ and $M_2$, augmented with the interpolated mirror points at the start and end, where momentum is zero: $(l_{\\text{m1}}, 0)$ and $(l_{\\text{m2}}, 0)$.\n\nThe integral for $J_\\parallel$ is then computed numerically using the trapezoidal rule, as specified. For a path defined by points $(l_j, p_{\\parallel, j})$, the integral is:\n$$\nJ_\\parallel \\approx \\sum_{j} \\frac{p_{\\parallel, j} + p_{\\parallel, j+1}}{2} (l_{j+1} - l_j)\n$$\nThe absolute value of the result is taken, as action is a positive definite quantity.\n\nFinally, to quantify the time invariance of the bounce action, we collect the values of $J_\\parallel$ computed for all resolved half-bounce segments. We then calculate the dimensionless relative variation $\\Delta_J$:\n$$\n\\Delta_J = \\frac{\\max(J_\\parallel) - \\min(J_\\parallel)}{\\langle J_\\parallel \\rangle}\n$$\nwhere $\\langle J_\\parallel \\rangle$ is the arithmetic mean of all measured $J_\\parallel$ values. If fewer than two segments are resolved, this metric is undefined, and we report a not-a-number (NaN) value. This procedure is repeated for each of the provided test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (m, mu, B0, alpha, L, l0, v0, epsilon, omega, t_end, dt)\n        (2.0e-27, 3.5e-18, 3.0, 4.0, 1.0, 0.0, 8.0e4, 0.0, 0.0, 1.0e-2, 1.0e-6),\n        (2.0e-27, 3.5e-18, 3.0, 4.0, 1.0, 0.0, 1.95e5, 0.0, 0.0, 2.0e-2, 1.0e-6),\n        (2.0e-27, 3.5e-18, 3.0, 4.0, 1.0, 0.0, 1.0e5, 1.0e-2, 1.0e3, 1.0e-2, 1.0e-6),\n        (2.0e-27, 3.5e-18, 3.0, 4.0, 1.0, 0.0, 1.0e5, 2.0e-1, 2.0e5, 1.0e-2, 1.0e-6),\n        (2.0e-27, 3.5e-18, 3.0, 4.0, 1.0, 0.0, 2.0e4, 0.0, 0.0, 5.0e-3, 1.0e-6),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation_and_analyze(params)\n        results.append(result)\n\n    # Format output as specified\n    result_str = ','.join([f\"{r:.16e}\" if not np.isnan(r) else \"nan\" for r in results])\n    print(f\"[{result_str}]\")\n\n\ndef run_simulation_and_analyze(params):\n    \"\"\"\n    Runs the guiding-center simulation for one set of parameters and computes Delta_J.\n    \"\"\"\n    m, mu, B0, alpha, L, l0, v0_initial, eps, omega, t_end, dt = params\n\n    # --- Define physics functions ---\n    def B_field(l, t):\n        spatial_part = B0 * (1 + alpha * (l / L)**2)\n        temporal_part = 1 + eps * np.sin(omega * t)\n        return spatial_part * temporal_part\n\n    def force_over_m(l, t):\n        # F/m = -mu/m * dB/dl\n        dB_dl = B0 * (2 * alpha * l / L**2) * (1 + eps * np.sin(omega * t))\n        return -mu / m * dB_dl\n\n    def derivatives(t, y):\n        l, v_parallel = y\n        dl_dt = v_parallel\n        dv_parallel_dt = force_over_m(l, t)\n        return np.array([dl_dt, dv_parallel_dt])\n\n    # --- Numerical Integration (RK4) ---\n    n_steps = int(t_end / dt)\n    t_hist = np.linspace(0, t_end, n_steps + 1)\n    l_hist = np.zeros(n_steps + 1)\n    v_hist = np.zeros(n_steps + 1)\n\n    l_hist[0] = l0\n    v_hist[0] = v0_initial\n\n    for i in range(n_steps):\n        t_n = t_hist[i]\n        y_n = np.array([l_hist[i], v_hist[i]])\n\n        k1 = dt * derivatives(t_n, y_n)\n        k2 = dt * derivatives(t_n + dt/2, y_n + k1/2)\n        k3 = dt * derivatives(t_n + dt/2, y_n + k2/2)\n        k4 = dt * derivatives(t_n + dt, y_n + k3)\n        \n        y_np1 = y_n + (k1 + 2*k2 + 2*k3 + k4) / 6\n        \n        l_hist[i+1] = y_np1[0]\n        v_hist[i+1] = y_np1[1]\n\n    # --- Analysis: Mirror Point Detection and J_parallel Calculation ---\n    mirror_points = []\n    for i in range(1, n_steps + 1):\n        if v_hist[i-1] * v_hist[i] <= 0 and v_hist[i-1] != v_hist[i]:\n            v1, v2 = v_hist[i-1], v_hist[i]\n            t1, t2 = t_hist[i-1], t_hist[i]\n            l1, l2 = l_hist[i-1], l_hist[i]\n            \n            # Linear interpolation to find the zero crossing\n            # t_mirror = t1 - v1 * (t2 - t1) / (v2 - v1)\n            # l_mirror = l1 - v1 * (l2 - l1) / (v2 - v1)\n            frac = -v1 / (v2 - v1)\n            t_mirror = t1 + frac * (t2 - t1)\n            l_mirror = l1 + frac * (l2 - l1)\n\n            mirror_points.append({'t': t_mirror, 'l': l_mirror, 'idx_after': i})\n    \n    J_values = []\n    if len(mirror_points) < 2:\n        return np.nan\n\n    for j in range(len(mirror_points) - 1):\n        start_mirror = mirror_points[j]\n        end_mirror = mirror_points[j+1]\n\n        # Get the trajectory points for this full half-bounce segment\n        idx_start_slice = start_mirror['idx_after']\n        idx_end_slice = end_mirror['idx_after'] # slice up to, but not including, the next crossing step\n        \n        l_segment_full_steps = l_hist[idx_start_slice:idx_end_slice]\n        p_segment_full_steps = m * v_hist[idx_start_slice:idx_end_slice]\n\n        # Construct the complete path for integration including interpolated endpoints\n        # Path: [start_mirror, full_steps..., end_mirror]\n        l_path = np.concatenate(([start_mirror['l']], l_segment_full_steps, [end_mirror['l']]))\n        p_path = np.concatenate(([0.0], p_segment_full_steps, [0.0]))\n        \n        # Compute J_parallel using the trapezoidal rule\n        # The integral is guaranteed to be over a monotonic `l` path for a half-bounce\n        J = np.trapz(p_path, l_path)\n        J_values.append(np.abs(J))\n\n    if len(J_values) < 2:\n        return np.nan\n\n    J_values = np.array(J_values)\n    max_J = np.max(J_values)\n    min_J = np.min(J_values)\n    mean_J = np.mean(J_values)\n\n    if mean_J == 0:\n        return np.nan\n\n    delta_J = (max_J - min_J) / mean_J\n    return delta_J\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "This final practice bridges the gap between fundamental theory and modern plasma physics research. You will step into the role of a computational scientist to diagnose how particle-wave interactions, modeled by transient electric fields, can break the adiabatic invariants . By calculating the changes in $\\mu$, $J_{\\parallel}$, and $P_{\\phi}$ for an ensemble of particles, you will learn how these quantities are used as powerful tools in large-scale simulations to quantify heating, transport, and the loss of confinement.",
            "id": "4180184",
            "problem": "Consider marker particles in a Particle-In-Cell (PIC) simulation of a magnetized, axisymmetric fusion plasma with one-dimensional field-line parameterization by arc length $s \\in [0,L]$. Let the magnetic field magnitude vary along $s$ according to a prescribed function $B(s)$ over a periodic domain of length $L$, and let the axisymmetric torus have major radius $R$. Each marker has mass $m$, charge $q$, position along the field line $s_0$, minor radius $r$, and parallel and perpendicular speeds $v_\\parallel$ and $v_\\perp$. During a short interaction time $\\tau$, the markers experience uniform parallel and perpendicular electric fields $E_\\parallel$ and $E_\\perp$, which perturb the velocities according to first-principles kinematics. Assume that the interaction time is short enough that particle positions $s_0$ and $r$ do not change during $\\tau$, and neglect drifts so that $v_\\phi \\approx v_\\parallel$ for the purposes of the toroidal motion.\n\nYour task is to programmatically compute, for an ensemble of markers, changes in three adiabatic invariants induced by the electric fields: the magnetic moment change $\\Delta \\mu$, the parallel action change $\\Delta J_\\parallel$, and the toroidal canonical momentum change $\\Delta P_\\phi$. The computation must start from fundamental laws and core definitions, and must not rely on shortcut formulas. Specifically:\n\n- Use the Lorentz force law and guiding-center decomposition to define the magnetic moment $\\mu$ from kinetic energy in the perpendicular degree of freedom and the local magnetic field magnitude $B$ at the marker position $s_0$.\n- Define the parallel action $J_\\parallel$ as the closed-path integral of the parallel canonical momentum along the field-line arc length over one period. For passing or trapped motion in the prescribed $B(s)$, evaluate the integral numerically over the full period $[0,L]$ using the positive part of the parallel momentum implied by energy conservation along the field line.\n- Derive the toroidal canonical momentum $P_\\phi$ from the axisymmetric Lagrangian definition in cylindrical coordinates, and express it in terms of mechanical toroidal momentum and poloidal magnetic flux at the marker radius $r$.\n\nFor each marker, compute initial values $\\mu_{\\mathrm{i}}$, $J_{\\parallel,\\mathrm{i}}$, $P_{\\phi,\\mathrm{i}}$ from its initial state, then update $v_\\parallel$ and $v_\\perp$ using constant accelerations due to $E_\\parallel$ and $E_\\perp$ over time $\\tau$ to obtain final values $\\mu_{\\mathrm{f}}$, $J_{\\parallel,\\mathrm{f}}$, $P_{\\phi,\\mathrm{f}}$, and differences $\\Delta \\mu = \\mu_{\\mathrm{f}} - \\mu_{\\mathrm{i}}$, $\\Delta J_\\parallel = J_{\\parallel,\\mathrm{f}} - J_{\\parallel,\\mathrm{i}}$, $\\Delta P_\\phi = P_{\\phi,\\mathrm{f}} - P_{\\phi,\\mathrm{i}}$. Then compute ensemble statistics (mean and standard deviation) of these differences across all markers for each test case.\n\nMagnetic geometry and fields for numerical evaluation:\n- The magnetic field magnitude along the field line is defined by\n$$\nB(s) = B_0 \\left[ 1 + \\delta \\cos\\left( \\frac{2\\pi s}{L} \\right) \\right],\n$$\nwith $s \\in [0,L]$ and parameters $B_0$ and $\\delta$ specified per test case.\n- The poloidal magnetic flux at minor radius $r$ is modeled as\n$$\n\\psi(r) = \\frac{1}{2}\\,\\psi_0\\,r^2,\n$$\nwith parameter $\\psi_0$ specified per test case.\n- The major radius $R$ is constant for all markers within a test case.\n\nElectric-field-induced velocity updates over time $\\tau$:\n- The parallel velocity update is $v_{\\parallel,\\mathrm{f}} = v_{\\parallel,\\mathrm{i}} + (q E_\\parallel/m)\\,\\tau$.\n- The perpendicular speed update magnitude is $v_{\\perp,\\mathrm{f}} = \\max\\{0, v_{\\perp,\\mathrm{i}} + (q E_\\perp/m)\\,\\tau\\}$.\n\nDefinitions required for numerical evaluation:\n- The total kinetic energy is $E = \\frac{1}{2} m \\left( v_\\perp^2 + v_\\parallel^2 \\right)$.\n- The parallel canonical momentum integrand along the field line is given by the positive root of twice the parallel kinetic energy, using the local magnetic field $B(s)$ and the magnetic moment $\\mu$ at $s_0$. Numerically, evaluate\n$$\nJ_\\parallel = \\int_0^L \\sqrt{ 2 m \\max\\left\\{ 0,\\, E - \\mu\\, B(s) \\right\\} } \\, ds,\n$$\nwhich yields the correct closed-path integral for both passing motion (where the integrand is positive over all $s$) and trapped motion (where the integrand is nonzero only between mirror points).\n\nUnits and output requirements:\n- Express $\\Delta \\mu$ in Joules per Tesla ($\\mathrm{J/T}$).\n- Express $\\Delta J_\\parallel$ in kilogram meter squared per second ($\\mathrm{kg\\,m^2/s}$).\n- Express $\\Delta P_\\phi$ in Joule-second ($\\mathrm{J\\,s}$).\n- Angles, if any appear in intermediate derivations, are not part of the output and should be assumed to be in radians.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of six floats in the order $[\\overline{\\Delta \\mu}, \\sigma_{\\Delta \\mu}, \\overline{\\Delta J_\\parallel}, \\sigma_{\\Delta J_\\parallel}, \\overline{\\Delta P_\\phi}, \\sigma_{\\Delta P_\\phi}]$. Aggregate the four test cases into a single list of lists; for example: $[[\\dots],[\\dots],[\\dots],[\\dots]]$.\n\nTest suite:\nFor each test case, draw an ensemble of $N=400$ markers with the following parameter sets and sampling rules. For each marker, sample $s_0$ uniformly from $[0,L]$, sample $r$ uniformly from the specified interval, and sample $v_{\\parallel,\\mathrm{i}}$ and $v_{\\perp,\\mathrm{i}}$ independently from normal distributions with the specified means and standard deviations. Use the same $(m,q)$ for all cases.\n\n- Global constants for all cases:\n  - $m = 3.343\\times 10^{-27}\\,\\mathrm{kg}$,\n  - $q = 1.602\\times 10^{-19}\\,\\mathrm{C}$.\n\n- Test Case 1 (off-resonant, weak fields):\n  - $B_0 = 3.0\\,\\mathrm{T}$, $\\delta = 0.05$, $L = 10.0\\,\\mathrm{m}$, $R = 1.7\\,\\mathrm{m}$, $\\psi_0 = 0.8\\,\\mathrm{Wb/m^2}$, $r \\in [0.3,0.5]\\,\\mathrm{m}$,\n  - $v_{\\parallel,\\mathrm{i}}$: mean $1.0\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $v_{\\perp,\\mathrm{i}}$: mean $1.5\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $E_\\parallel = 1.0\\,\\mathrm{V/m}$, $E_\\perp = 0.5\\,\\mathrm{V/m}$, $\\tau = 1.0\\times 10^{-6}\\,\\mathrm{s}$.\n\n- Test Case 2 (strong parallel interaction, Landau-like):\n  - $B_0 = 3.0\\,\\mathrm{T}$, $\\delta = 0.15$, $L = 10.0\\,\\mathrm{m}$, $R = 1.7\\,\\mathrm{m}$, $\\psi_0 = 0.8\\,\\mathrm{Wb/m^2}$, $r \\in [0.3,0.5]\\,\\mathrm{m}$,\n  - $v_{\\parallel,\\mathrm{i}}$: mean $2.0\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $v_{\\perp,\\mathrm{i}}$: mean $1.0\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $E_\\parallel = 200.0\\,\\mathrm{V/m}$, $E_\\perp = 5.0\\,\\mathrm{V/m}$, $\\tau = 2.0\\times 10^{-5}\\,\\mathrm{s}$.\n\n- Test Case 3 (strong perpendicular interaction, cyclotron-like):\n  - $B_0 = 5.0\\,\\mathrm{T}$, $\\delta = 0.10$, $L = 10.0\\,\\mathrm{m}$, $R = 1.7\\,\\mathrm{m}$, $\\psi_0 = 0.8\\,\\mathrm{Wb/m^2}$, $r \\in [0.3,0.5]\\,\\mathrm{m}$,\n  - $v_{\\parallel,\\mathrm{i}}$: mean $1.0\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $v_{\\perp,\\mathrm{i}}$: mean $1.0\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $E_\\parallel = 2.0\\,\\mathrm{V/m}$, $E_\\perp = 300.0\\,\\mathrm{V/m}$, $\\tau = 1.0\\times 10^{-5}\\,\\mathrm{s}$.\n\n- Test Case 4 (boundary case, constant field):\n  - $B_0 = 3.5\\,\\mathrm{T}$, $\\delta = 0.00$, $L = 10.0\\,\\mathrm{m}$, $R = 1.7\\,\\mathrm{m}$, $\\psi_0 = 0.8\\,\\mathrm{Wb/m^2}$, $r \\in [0.3,0.5]\\,\\mathrm{m}$,\n  - $v_{\\parallel,\\mathrm{i}}$: mean $0.8\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $v_{\\perp,\\mathrm{i}}$: mean $1.2\\times 10^5\\,\\mathrm{m/s}$, standard deviation $2.0\\times 10^4\\,\\mathrm{m/s}$,\n  - $E_\\parallel = 1.0\\times 10^{-4}\\,\\mathrm{V/m}$, $E_\\perp = 1.0\\times 10^{-4}\\,\\mathrm{V/m}$, $\\tau = 1.0\\times 10^{-4}\\,\\mathrm{s}$.\n\nYour program must:\n- Generate the ensembles, compute $\\Delta \\mu$, $\\Delta J_\\parallel$, and $\\Delta P_\\phi$ per marker, then compute the mean and standard deviation of each $\\Delta$ over the ensemble for each test case.\n- Produce a single line of output: a list of lists in the order specified above, for the four test cases, with numerical values as floats.",
            "solution": "The problem statement has been carefully reviewed and is determined to be valid. It is scientifically grounded in the principles of plasma physics concerning adiabatic invariants, is mathematically well-posed, and all necessary parameters, definitions, and models are provided explicitly and consistently. The problem requires the implementation of a defined physical model and computational procedure, which is a standard task in computational science.\n\n### 1. Definitions and Derivations of Adiabatic Invariants\n\nWe are given particles of mass $m$ and charge $q$ in an axisymmetric magnetic field. The three invariants to be considered are the magnetic moment $\\mu$, the parallel action $J_\\parallel$, and the toroidal canonical momentum $P_\\phi$.\n\n**1.1. Magnetic Moment ($\\mu$)**\n\nThe magnetic moment, $\\mu$, is the first adiabatic invariant, associated with the fast gyromotion of a charged particle around a magnetic field line. It is defined as the ratio of the perpendicular kinetic energy, $K_\\perp$, to the magnetic field strength, $B$. The problem specifies to use the guiding-center decomposition, which directly leads to this definition.\nThe perpendicular kinetic energy is given by $K_\\perp = \\frac{1}{2} m v_\\perp^2$, where $v_\\perp$ is the component of the particle's velocity perpendicular to the magnetic field vector. The magnetic moment is therefore:\n$$\n\\mu = \\frac{K_\\perp}{B} = \\frac{\\frac{1}{2} m v_\\perp^2}{B}\n$$\nIn our problem, the magnetic field $B$ varies along a field line, parameterized by arc length $s$. A particle is located at $s_0$, so its magnetic moment is computed using the local field strength $B(s_0)$:\n$$\n\\mu = \\frac{m v_\\perp^2}{2 B(s_0)}\n$$\nThe units of $\\mu$ are Joules per Tesla ($\\mathrm{J/T}$), as required.\n\n**1.2. Parallel Action ($J_\\parallel$)**\n\nThe parallel action, $J_\\parallel$, also known as the longitudinal invariant, is the second adiabatic invariant. It is associated with the periodic motion of a particle bouncing between magnetic mirrors (trapped particles) or transiting along a closed field line (passing particles). It is defined as the integral of the parallel momentum, $p_\\parallel = m v_\\parallel$, over one full period of this motion along the field line:\n$$\nJ_\\parallel = \\oint p_\\parallel ds = \\oint m v_\\parallel ds\n$$\nTo evaluate this, we use the conservation of energy, $E$, for a particle's guiding center motion along the field line. The total energy $E = K_\\parallel + K_\\perp = K_\\parallel + \\mu B(s)$ is constant in the absence of parallel electric fields or time-varying fields. The parallel kinetic energy is $K_\\parallel = E - \\mu B(s)$. From this, we can express the parallel velocity as $v_\\parallel = \\sqrt{2 K_\\parallel / m} = \\sqrt{2(E - \\mu B(s))/m}$. The momentum integrand is thus $p_\\parallel(s) = \\sqrt{2m(E - \\mu B(s))}$.\n\nThe problem specifies the domain is periodic from $s=0$ to $s=L$. For both passing and trapped particles, the integral over a full closed path is equivalent to the integral provided:\n$$\nJ_\\parallel = \\int_0^L \\sqrt{ 2 m \\max\\left\\{ 0, E - \\mu B(s) \\right\\} } \\, ds\n$$\nwhere $E = \\frac{1}{2} m (v_\\parallel^2 + v_\\perp^2)$ is the total kinetic energy, calculated from the particle's state at its initial position $s_0$. The $\\max\\{0, ...\\}$ term correctly handles trapped particles, for which the parallel kinetic energy would be negative in regions where they cannot penetrate, setting the integrand to zero outside the a priori unknown mirror points. This integral must be evaluated numerically. The units are $\\sqrt{\\mathrm{kg} \\cdot \\mathrm{J}} \\cdot \\mathrm{m} = \\sqrt{\\mathrm{kg} \\cdot (\\mathrm{kg \\cdot m^2/s^2})} \\cdot \\mathrm{m} = (\\mathrm{kg \\cdot m/s}) \\cdot \\mathrm{m} = \\mathrm{kg \\cdot m^2/s}$, as required.\n\n**1.3. Toroidal Canonical Momentum ($P_\\phi$)**\n\nThe toroidal canonical momentum, $P_\\phi$, is the third adiabatic invariant, associated with the slow drift motion of a particle's guiding center in an axisymmetric system. It is a conserved quantity due to the axisymmetry (Noether's theorem for rotational symmetry). The Lagrangian for a particle in an electromagnetic field is $L = \\frac{1}{2} m \\mathbf{v}^2 + q(\\mathbf{A} \\cdot \\mathbf{v} - \\Phi)$, where $\\mathbf{A}$ is the magnetic vector potential and $\\Phi$ is the electrostatic potential. In cylindrical coordinates $(R', \\phi, Z)$, the velocity is $\\mathbf{v} = \\dot{R'} \\hat{R'} + R' \\dot{\\phi} \\hat{\\phi} + \\dot{Z} \\hat{Z}$. The Lagrangian contains the term $L = ... + \\frac{1}{2}m(R')^2\\dot{\\phi}^2 + q A_\\phi R' \\dot{\\phi} + ...$.\n\nThe canonical momentum conjugate to the coordinate $\\phi$ is:\n$$\nP_\\phi = \\frac{\\partial L}{\\partial \\dot{\\phi}} = m (R')^2 \\dot{\\phi} + q R' A_\\phi\n$$\nSubstituting $v_\\phi = R' \\dot{\\phi}$, we get $P_\\phi = m R' v_\\phi + q R' A_\\phi$. For a particle near the major radius $R$, we approximate $R' \\approx R$. The poloidal magnetic flux $\\psi$ is related to the toroidal component of the vector potential by $\\psi = 2\\pi R A_\\phi$. Thus, $q R A_\\phi = q \\psi / (2\\pi)$.\nThe expression for $P_\\phi$ becomes:\n$$\nP_\\phi = m R v_\\phi + \\frac{q \\psi(r)}{2\\pi}\n$$\nwhere the first term is the mechanical toroidal momentum and the second term is derived from the magnetic field structure. The problem states we can approximate the toroidal velocity $v_\\phi$ with the parallel velocity $v_\\parallel$, which is a common simplification in field-aligned coordinate systems where the magnetic field is predominantly toroidal. The problem also provides the model $\\psi(r) = \\frac{1}{2} \\psi_0 r^2$. Substituting these gives the final expression used for computation:\n$$\nP_\\phi = m R v_\\parallel + \\frac{q \\psi_0 r^2}{4\\pi}\n$$\nThe units are $\\mathrm{kg \\cdot m \\cdot m/s} + \\mathrm{C \\cdot (Wb/m^2) \\cdot m^2} = \\mathrm{kg \\cdot m^2/s} + \\mathrm{C \\cdot Wb}$. Since $1\\,\\mathrm{Wb} = 1\\,\\mathrm{V \\cdot s}$ and $1\\,\\mathrm{J} = 1\\,\\mathrm{C \\cdot V}$, this becomes $\\mathrm{C \\cdot Wb} = \\mathrm{J \\cdot s}$. Also, $1\\,\\mathrm{J \\cdot s} = 1\\,(\\mathrm{kg \\cdot m^2/s^2})\\cdot \\mathrm{s} = \\mathrm{kg \\cdot m^2/s}$. The units are consistent and sum to $\\mathrm{J \\cdot s}$, as required.\n\n### 2. Computational Strategy\n\nThe core of the task is to compute the change in these three invariants for an ensemble of $N=400$ particles under the influence of prescribed electric fields for a duration $\\tau$.\n\nFor each of the four test cases, the following algorithm is implemented:\n1.  **Ensemble Generation**: An ensemble of $N=400$ marker particles is created. For each particle, its initial parameters are sampled from the specified distributions:\n    -   Position on the field line: $s_0 \\sim U(0, L)$\n    -   Minor radius: $r \\sim U(r_{\\min}, r_{\\max})$\n    -   Parallel velocity: $v_{\\parallel,\\mathrm{i}} \\sim N(\\mu_{v_\\parallel}, \\sigma_{v_\\parallel})$\n    -   Perpendicular speed: $v_{\\perp,\\mathrm{i}} \\sim N(\\mu_{v_\\perp}, \\sigma_{v_\\perp})$. The absolute value is taken to ensure the speed is non-negative.\n\n2.  **Initial Invariant Calculation**: For each particle in its initial state $(v_{\\parallel,\\mathrm{i}}, v_{\\perp,\\mathrm{i}})$ at position $(s_0, r)$, the initial invariants $(\\mu_{\\mathrm{i}}, J_{\\parallel,\\mathrm{i}}, P_{\\phi,\\mathrm{i}})$ are calculated using the formulas derived above. The computation of $J_{\\parallel,\\mathrm{i}}$ requires numerical integration of its defining integral from $s=0$ to $s=L$, for which the `scipy.integrate.quad` function is employed.\n\n3.  **State Update**: The particle's velocities are updated based on the constant acceleration from the electric fields $E_\\parallel$ and $E_\\perp$ over the time interval $\\tau$.\n    -   $v_{\\parallel,\\mathrm{f}} = v_{\\parallel,\\mathrm{i}} + (q E_\\parallel/m)\\tau$\n    -   $v_{\\perp,\\mathrm{f}} = \\max\\{0, v_{\\perp,\\mathrm{i}} + (q E_\\perp/m)\\tau\\}$\n    The particle's positions $s_0$ and $r$ are assumed to remain constant during this short interaction.\n\n4.  **Final Invariant Calculation**: Using the final velocities $(v_{\\parallel,\\mathrm{f}}, v_{\\perp,\\mathrm{f}})$ and the same positions $(s_0, r)$, the final invariants $(\\mu_{\\mathrm{f}}, J_{\\parallel,\\mathrm{f}}, P_{\\phi,\\mathrm{f}})$ are computed using the same procedure as in step 2.\n\n5.  **Change Calculation**: The changes in the invariants are computed by subtraction:\n    -   $\\Delta \\mu = \\mu_{\\mathrm{f}} - \\mu_{\\mathrm{i}}$\n    -   $\\Delta J_\\parallel = J_{\\parallel,\\mathrm{f}} - J_{\\parallel,\\mathrm{i}}$\n    -   $\\Delta P_\\phi = P_{\\phi,\\mathrm{f}} - P_{\\phi,\\mathrm{i}}$\n    These three values are stored for each particle.\n\n6.  **Ensemble Statistics**: After processing all $N=400$ particles, the mean and standard deviation of the collected values for $\\Delta \\mu$, $\\Delta J_\\parallel$, and $\\Delta P_\\phi$ are calculated using `numpy.mean` and `numpy.std`.\n\n7.  **Output Formatting**: The six statistical results for each test case are collected, and the final output is formatted into a single line as a list of lists of floating-point numbers, according to the problem specification.\n\nAn analytical check for $\\Delta P_\\phi$ shows that $\\Delta P_\\phi = m R(v_{\\parallel,\\mathrm{f}} - v_{\\parallel,\\mathrm{i}}) = m R (q E_\\parallel/m) \\tau = q R E_\\parallel \\tau$. This value is constant for all particles within a test case, implying its standard deviation should be zero. This provides a valuable internal consistency check for the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes changes in adiabatic invariants for ensembles of plasma particles.\n    \"\"\"\n    # Global constants for all cases\n    m = 3.343e-27  # kg\n    q = 1.602e-19  # C\n    N = 400\n\n    test_cases = [\n        # Test Case 1 (off-resonant, weak fields)\n        {'B0': 3.0, 'delta': 0.05, 'L': 10.0, 'R': 1.7, 'psi0': 0.8, 'r_lim': [0.3, 0.5], 'vpar_mean': 1.0e5, 'vpar_std': 2.0e4, 'vperp_mean': 1.5e5, 'vperp_std': 2.0e4, 'Epar': 1.0, 'Eperp': 0.5, 'tau': 1.0e-6},\n        # Test Case 2 (strong parallel interaction, Landau-like)\n        {'B0': 3.0, 'delta': 0.15, 'L': 10.0, 'R': 1.7, 'psi0': 0.8, 'r_lim': [0.3, 0.5], 'vpar_mean': 2.0e5, 'vpar_std': 2.0e4, 'vperp_mean': 1.0e5, 'vperp_std': 2.0e4, 'Epar': 200.0, 'Eperp': 5.0, 'tau': 2.0e-5},\n        # Test Case 3 (strong perpendicular interaction, cyclotron-like)\n        {'B0': 5.0, 'delta': 0.10, 'L': 10.0, 'R': 1.7, 'psi0': 0.8, 'r_lim': [0.3, 0.5], 'vpar_mean': 1.0e5, 'vpar_std': 2.0e4, 'vperp_mean': 1.0e5, 'vperp_std': 2.0e4, 'Epar': 2.0, 'Eperp': 300.0, 'tau': 1.0e-5},\n        # Test Case 4 (boundary case, constant field)\n        {'B0': 3.5, 'delta': 0.00, 'L': 10.0, 'R': 1.7, 'psi0': 0.8, 'r_lim': [0.3, 0.5], 'vpar_mean': 0.8e5, 'vpar_std': 2.0e4, 'vperp_mean': 1.2e5, 'vperp_std': 2.0e4, 'Epar': 1.0e-4, 'Eperp': 1.0e-4, 'tau': 1.0e-4},\n    ]\n\n    all_results = []\n    rng = np.random.default_rng(seed=42)\n\n    def calculate_invariants(v_par, v_perp, s0, r, case_params):\n        B0 = case_params['B0']\n        delta = case_params['delta']\n        L = case_params['L']\n        R = case_params['R']\n        psi0 = case_params['psi0']\n\n        def B_field(s):\n            return B0 * (1 + delta * np.cos(2 * np.pi * s / L))\n\n        B_s0 = B_field(s0)\n        \n        mu = 0.5 * m * v_perp**2 / B_s0 if B_s0 > 1e-9 else 0.0 # Avoid division by zero\n\n        E = 0.5 * m * (v_par**2 + v_perp**2)\n\n        def J_par_integrand(s):\n            parallel_ke = E - mu * B_field(s)\n            return np.sqrt(2 * m * max(0, parallel_ke))\n        \n        # Use quad for numerical integration\n        J_par, _ = integrate.quad(J_par_integrand, 0, L, epsabs=1e-9, limit=100)\n\n        psi_r = 0.5 * psi0 * r**2\n        P_phi = m * R * v_par + q * psi_r / (2 * np.pi)\n\n        return mu, J_par, P_phi\n\n    for case in test_cases:\n        s0_ensemble = rng.uniform(0, case['L'], N)\n        r_ensemble = rng.uniform(case['r_lim'][0], case['r_lim'][1], N)\n        vpar_i_ensemble = rng.normal(case['vpar_mean'], case['vpar_std'], N)\n        vperp_i_ensemble = np.abs(rng.normal(case['vperp_mean'], case['vperp_std'], N))\n\n        delta_mu_list = np.zeros(N)\n        delta_J_par_list = np.zeros(N)\n        delta_P_phi_list = np.zeros(N)\n\n        for i in range(N):\n            s0, r, vpar_i, vperp_i = s0_ensemble[i], r_ensemble[i], vpar_i_ensemble[i], vperp_i_ensemble[i]\n            \n            mu_i, J_par_i, P_phi_i = calculate_invariants(vpar_i, vperp_i, s0, r, case)\n\n            vpar_f = vpar_i + (q * case['Epar'] / m) * case['tau']\n            vperp_f = max(0, vperp_i + (q * case['Eperp'] / m) * case['tau'])\n\n            mu_f, J_par_f, P_phi_f = calculate_invariants(vpar_f, vperp_f, s0, r, case)\n\n            delta_mu_list[i] = mu_f - mu_i\n            delta_J_par_list[i] = J_par_f - J_par_i\n            delta_P_phi_list[i] = P_phi_f - P_phi_i\n\n        mean_dmu = np.mean(delta_mu_list)\n        std_dmu = np.std(delta_mu_list)\n\n        mean_dJ_par = np.mean(delta_J_par_list)\n        std_dJ_par = np.std(delta_J_par_list)\n\n        mean_dP_phi = np.mean(delta_P_phi_list)\n        std_dP_phi = np.std(delta_P_phi_list)\n        \n        case_results = [mean_dmu, std_dmu, mean_dJ_par, std_dJ_par, mean_dP_phi, std_dP_phi]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists\n    formatted_lists = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    result_string = f\"[{','.join(formatted_lists)}]\"\n    print(result_string)\n\nsolve()\n\n```"
        }
    ]
}