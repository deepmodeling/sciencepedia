{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在建立安全因子 $q$ 的几何定义与其在大环径比托卡马克中常用的近似表达式之间的关键联系。通过这个推导，您将更好地理解安全因子 $q$ 的物理意义，及其如何依赖于装置的几何参数与磁场分量。这项练习是掌握磁约束聚变基本概念的重要一步。",
            "id": "4195290",
            "problem": "考虑一个轴对称托卡马克，其磁通面为圆形同心面，小半径为 $r$，大半径为 $R_0$。设 $\\zeta$ 表示环向角，$\\theta$ 表示极向角，均以弧度为单位。假设大环径比，即 $\\epsilon \\equiv r/R_0 \\ll 1$，Shafranov 位移可忽略不计，并且磁场可以在一个磁通面上分解为一个环向分量 $B_{\\zeta}(\\psi)$ 和一个极向分量 $B_{\\theta}(\\psi)$，在 $\\epsilon$ 的主导阶上，这两个分量在该磁通面上近似为常数。磁力线的安全因子 $q(\\psi)$ 定义为在给定磁通面上，磁力线沿极向绕行一圈平均所对应的环向绕行圈数，可写作\n$$\nq(\\psi) \\equiv \\frac{1}{2\\pi} \\oint \\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}\\,\\mathrm{d}\\theta,\n$$\n其中积分是在一个固定的磁通面上沿完整的极向路径进行。仅使用此定义、圆形环面上弧长与角度之间的几何关系，以及磁力线满足 $\\mathrm{d}\\boldsymbol{x}\\parallel \\boldsymbol{B}$ 这一事实，推导 $q(r)$ 关于 $r$、$R_0$、$B_{\\zeta}$ 和 $B_{\\theta}$ 的主导阶表达式。将最终结果表示为单个闭式解析表达式。无需进行数值计算。明确写出您最终的 $q(r)$ 表达式。角度应以弧度处理，安全因子是无量纲的。",
            "solution": "用户希望我验证并解决一个问题。\n\n### 第1步：提取已知条件\n\n-   **系统**：轴对称托卡马克。\n-   **磁通面**：圆形、同心，小半径为 $r$，大半径为 $R_0$。\n-   **坐标**：环向角 $\\zeta$ 和极向角 $\\theta$，均以弧度为单位。\n-   **假设1**：大环径比，$\\epsilon \\equiv r/R_0 \\ll 1$。\n-   **假设2**：Shafranov 位移可忽略不计。\n-   **磁场**：分解为一个环向分量 $B_{\\zeta}(\\psi)$ 和一个极向分量 $B_{\\theta}(\\psi)$。\n-   **假设3**：在 $\\epsilon$ 的主导阶上，$B_{\\zeta}(\\psi)$ 和 $B_{\\theta}(\\psi)$ 在一个磁通面 $\\psi$ 上近似为常数。\n-   **定义**：安全因子 $q(\\psi)$ 由 $q(\\psi) \\equiv \\frac{1}{2\\pi} \\oint \\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}\\,\\mathrm{d}\\theta$ 给出，其中积分是沿一个完整的极向回路。\n-   **条件**：磁力线 $\\boldsymbol{x}$ 满足 $\\mathrm{d}\\boldsymbol{x} \\parallel \\boldsymbol{B}$。\n-   **目标**：推导 $q(r)$ 关于 $r$、$R_0$、$B_{\\zeta}$ 和 $B_{\\theta}$ 的主导阶表达式。\n\n### 第2步：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题基于等离子体物理学中使用的托卡马克的标准简化模型。所有概念（磁面、安全因子、环径比、环向坐标）都是磁约束聚变领域的基础。这些假设是入门推导的标准假设。该问题在科学上是合理的。\n-   **适定性**：该问题提供了一个清晰的定义、一组简化的假设和一个明确的目标。信息足以推导出唯一的主导阶表达式。对于指定的几何形状，从磁通面标签 $\\psi$ 到小半径 $r$ 的映射是一一对应的，因此求解 $q(r)$ 是一致的。该问题是适定的。\n-   **客观性**：该问题以精确的技术语言陈述，没有任何主观性或歧义。\n\n该问题没有表现出说明中列出的任何缺陷（例如，科学上不合理、不完整、矛盾等）。这是一个标准的、可解的物理问题。\n\n### 第3步：结论与行动\n\n问题是**有效的**。我将继续推导解答。\n\n***\n\n磁力线定义为空间中的一条曲线 $\\boldsymbol{x}$，其切线处处平行于磁场矢量 $\\boldsymbol{B}$。这个条件在数学上表示为 $\\mathrm{d}\\boldsymbol{x} \\parallel \\boldsymbol{B}$，其中 $\\mathrm{d}\\boldsymbol{x}$ 是沿磁力线的无穷小位移矢量。\n\n对于指定的环形几何结构，磁通面上的无穷小位移矢量可以分解为其极向和环向分量。极向的微分弧长 $\\mathrm{d}l_{\\theta}$ 由小半径 $r$ 和极向角微分 $\\mathrm{d}\\theta$ 的乘积给出：\n$$\n\\mathrm{d}l_{\\theta} = r \\, \\mathrm{d}\\theta\n$$\n环向的微分弧长 $\\mathrm{d}l_{\\zeta}$ 由局部大半径 $R$ 和环向角微分 $\\mathrm{d}\\zeta$ 的乘积给出。对于圆形磁通面，局部大半径为 $R = R_0 + r \\cos\\theta$。因此：\n$$\n\\mathrm{d}l_{\\zeta} = (R_0 + r \\cos\\theta) \\, \\mathrm{d}\\zeta\n$$\n平行条件 $\\mathrm{d}\\boldsymbol{x} \\parallel \\boldsymbol{B}$ 意味着路径长度分量的比率必须等于磁场分量的比率：\n$$\n\\frac{\\mathrm{d}l_{\\zeta}}{\\mathrm{d}l_{\\theta}} = \\frac{B_{\\zeta}}{B_{\\theta}}\n$$\n代入微分弧长的表达式：\n$$\n\\frac{(R_0 + r \\cos\\theta) \\, \\mathrm{d}\\zeta}{r \\, \\mathrm{d}\\theta} = \\frac{B_{\\zeta}}{B_{\\theta}}\n$$\n我们可以重新整理这个方程，解出比率 $\\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}$，它出现在安全因子的定义中：\n$$\n\\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta} = \\frac{r}{R_0 + r \\cos\\theta} \\frac{B_{\\zeta}}{B_{\\theta}}\n$$\n问题给出了安全因子 $q$ 的定义。由于磁通面由小半径 $r$ 指定，我们将 $q$ 写成 $r$ 的函数：\n$$\nq(r) = \\frac{1}{2\\pi} \\oint \\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta} \\, \\mathrm{d}\\theta\n$$\n积分是沿着一个完整的极向转动进行的，即从 $\\theta = 0$ 到 $\\theta = 2\\pi$。将我们推导出的 $\\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}$ 表达式代入此积分中，得到：\n$$\nq(r) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\left( \\frac{r}{R_0 + r \\cos\\theta} \\frac{B_{\\zeta}}{B_{\\theta}} \\right) \\, \\mathrm{d}\\theta\n$$\n问题指出，在 $\\epsilon \\equiv r/R_0$ 的主导阶上，磁场分量 $B_{\\zeta}$ 和 $B_{\\theta}$ 在一个磁通面上是常数。因此，我们可以将它们视为关于积分变量 $\\theta$ 的常数，并将其移到积分号外：\n$$\nq(r) = \\frac{r B_{\\zeta}}{2\\pi B_{\\theta}} \\int_{0}^{2\\pi} \\frac{1}{R_0 + r \\cos\\theta} \\, \\mathrm{d}\\theta\n$$\n我们需要求解在大环径比极限 $r/R_0 \\ll 1$ 下 $q(r)$ 的主导阶表达式。在此极限下，分母中的项 $r \\cos\\theta$ 与 $R_0$ 相比很小。主导阶近似是忽略此项，这实际上是将环体近似为一个半径为 $r$、长度为 $2\\pi R_0$ 的直圆柱体。这对应于设置 $R \\approx R_0$：\n$$\nR_0 + r \\cos\\theta \\approx R_0\n$$\n将此近似应用于被积函数：\n$$\nq(r) \\approx \\frac{r B_{\\zeta}}{2\\pi B_{\\theta}} \\int_{0}^{2\\pi} \\frac{1}{R_0} \\, \\mathrm{d}\\theta\n$$\n现在被积函数是一个常数 $\\frac{1}{R_0}$，所以积分是初等的：\n$$\n\\int_{0}^{2\\pi} \\frac{1}{R_0} \\, \\mathrm{d}\\theta = \\frac{1}{R_0} [\\theta]_{0}^{2\\pi} = \\frac{2\\pi}{R_0}\n$$\n将此结果代回 $q(r)$ 的表达式：\n$$\nq(r) \\approx \\frac{r B_{\\zeta}}{2\\pi B_{\\theta}} \\left( \\frac{2\\pi}{R_0} \\right)\n$$\n$2\\pi$ 因子相消，得到安全因子的最终主导阶表达式：\n$$\nq(r) = \\frac{r B_{\\zeta}}{R_0 B_{\\theta}}\n$$\n这就是所求的 $q(r)$ 关于指定变量的闭式解析表达式，在逆环径比的主导阶上有效。",
            "answer": "$$\n\\boxed{\\frac{r B_{\\zeta}}{R_0 B_{\\theta}}}\n$$"
        },
        {
            "introduction": "从解析理论转向计算实践，本练习将使用庞加莱图（Poincaré map）来直观地展示磁力线的复杂结构。通过编写一个简单的迭代程序，您将亲眼观察到连续的磁通量面、磁岛以及混沌区域是如何从磁力线动力学中涌现的。这为那些通常很抽象的概念提供了强大的视觉直觉。",
            "id": "4195263",
            "problem": "你需要构建一个离散庞加莱映射，用于描述磁力线与固定环形截面的交点，并计算旋转变换和安全因子。从磁坐标$(\\psi,\\theta,\\phi)$下的基本场线方程出发，其中$\\psi$标记磁通量面，$\\theta$是角向角，$\\phi$是环向角。在可积区域中，场线流满足$d\\theta/d\\phi = \\iota(\\psi)$，其中$\\iota(\\psi)$是旋转变换，定义为每环向转一圈的平均角向转数。在此约定下，安全因子$q(\\psi)$定义为$q(\\psi) = 1/\\iota(\\psi)$。在$\\phi$增量为$2\\pi$处取庞加莱截面，因此该截面映射了场线与$\\phi = 0$（模$2\\pi$）平面的连续交点。在可积情况下，庞加莱截面上的不变曲线对应于磁通量面$\\psi = \\mathrm{const}$，且该映射是$\\theta$上的刚性旋转。在带有小微扰的不可积情况下，可以使用近可积哈密顿扭转映射来模拟对可积性的偏离，同时保持保面积特性。\n\n实现以下近可积、保面积的庞加莱映射，该映射源于对每个环向圈（$\\Delta\\phi = 2\\pi$）采样的场线流的正则扭转映射近似：\n- 设类作用量坐标为$I$（$\\psi$的无量纲化代理），角为$\\theta$（单位为弧度）。使用线性扭转剖面$\\iota(I) = \\iota_0 + \\alpha I$，其中$\\iota_0$和$\\alpha$为常数。\n- 从$(I_n,\\theta_n)$到$(I_{n+1},\\theta_{n+1})$的单次迭代为\n$$\n\\Delta\\theta_n = 2\\pi\\,\\iota(I_n) + \\varepsilon\\,A\\,\\sin(m\\,\\theta_n), \\quad \\theta_{n+1} = \\theta_n + \\Delta\\theta_n \\; \\mathrm{mod}\\; 2\\pi,\n$$\n$$\nI_{n+1} = I_n + \\varepsilon\\,B\\,\\sin(m\\,\\theta_n),\n$$\n其中$\\varepsilon$是微扰振幅，$A$和$B$是微扰系数，$m$是整数模数。角度必须以弧度处理。迭代次数为$N$。\n\n对于每组参数，你必须：\n- 从$(I_0,\\theta_0)$开始，将映射迭代$N$步。\n- 根据累积的角度增量计算平均旋转变换$\\rho$\n$$\n\\rho = \\frac{1}{2\\pi N}\\sum_{n=0}^{N-1} \\Delta\\theta_n,\n$$\n以及安全因子$q = 1/\\rho$。\n- 通过计算$\\Delta I_{\\max} = \\max_n I_n - \\min_n I_n$并返回布尔值$\\mathrm{invariant} = (\\Delta I_{\\max} \\le \\mathrm{tol})$，来评估轨迹是否位于不变曲线上（即一条有界的薄曲线）。\n\n所有角度均以弧度为单位。所有输出均为无量纲。所有浮点数输出均表示为四舍五入到$6$位小数。\n\n测试套件（每个元组列出$(\\iota_0,\\alpha,I_0,\\theta_0,\\varepsilon,A,B,m,N,\\mathrm{tol})$）：\n- 用例 $1$（可积刚性旋转）：$(0.35, 0.0, 0.2, 1.1, 0.0, 0.0, 0.0, 3, 4000, 0.005)$。\n- 用例 $2$（仅有$\\theta$踢的近可积不变曲线）：$(0.381966011, 0.0, 0.15, 0.7, 0.02, 1.0, 0.0, 3, 5000, 0.01)$。\n- 用例 $3$（有理旋转变换附近的共振岛形成）：$(0.4, 0.0, 0.25, 0.7, 0.08, 1.0, 0.02, 1, 6000, 0.015)$。\n- 用例 $4$（具有较大微扰和扭转的混沌层）：$(0.35, 0.1, 0.5, 1.2, 0.25, 1.0, 0.2, 2, 6000, 0.05)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是$[\\rho,q,\\mathrm{invariant}]$形式的列表，其中$\\rho$和$q$是四舍五入到$6$位小数的浮点数，$\\mathrm{invariant}$是布尔值。例如，整体输出应如下所示：$[[\\rho_1,q_1,\\mathrm{invariant}_1],[\\rho_2,q_2,\\mathrm{invariant}_2],[\\rho_3,q_3,\\mathrm{invariant}_3],[\\rho_4,q_4,\\mathrm{invariant}_4]]$。",
            "solution": "该问题要求实现并分析一个离散庞加莱映射，该映射模拟了环形等离子体约束装置中磁力线的动力学。核心任务是从给定的初始条件开始，将一组给定的递推关系迭代指定的步数。根据生成的轨迹，我们需要计算平均旋转变换、相应的安全因子，并评估轨迹是否保持在不变曲线上。\n\n该系统由一个类作用量坐标$I$（磁通量面标签$\\psi$的代理）和一个角向角坐标$\\theta$描述。该映射描述了在一次完整的环向穿行之后，$(I_n, \\theta_n)$到$(I_{n+1}, \\theta_{n+1})$的演化，这对应于环向角增量$\\Delta\\phi = 2\\pi$。旋转变换被赋予了对作用量的线性依赖关系，$\\iota(I) = \\iota_0 + \\alpha I$。\n\n离散映射由以下迭代规则定义：\n$$\nI_{n+1} = I_n + \\varepsilon\\,B\\,\\sin(m\\,\\theta_n)\n$$\n$$\n\\theta_{n+1} = \\left( \\theta_n + \\Delta\\theta_n \\right) \\pmod{2\\pi}\n$$\n其中每次迭代的角度变化由下式给出：\n$$\n\\Delta\\theta_n = 2\\pi\\,\\iota(I_n) + \\varepsilon\\,A\\,\\sin(m\\,\\theta_n)\n$$\n此处，$\\varepsilon$是微扰振幅，$A$和$B$是系数，$m$是微扰的角向模数。迭代从初始状态$(I_0, \\theta_0)$开始，进行$N$步。所有角度均以弧度为单位。\n\n一个关键的分析点在于问题将此映射描述为“保面积”的说法。一个映射$(I_n, \\theta_n) \\mapsto (I_{n+1}, \\theta_{n+1})$是保面积的，如果其雅可比矩阵的行列式为1。该映射的雅可比矩阵$J$为：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial I_{n+1}}{\\partial I_n}  \\frac{\\partial I_{n+1}}{\\partial \\theta_n} \\\\ \\frac{\\partial \\theta_{n+1}}{\\partial I_n}  \\frac{\\partial \\theta_{n+1}}{\\partial \\theta_n} \\end{pmatrix} = \\begin{pmatrix} 1  \\varepsilon B m \\cos(m \\theta_n) \\\\ 2\\pi \\alpha  1 + \\varepsilon A m \\cos(m \\theta_n) \\end{pmatrix}\n$$\n其行列式为$\\det(J) = 1 \\cdot (1 + \\varepsilon A m \\cos(m \\theta_n)) - (2\\pi \\alpha)(\\varepsilon B m \\cos(m \\theta_n)) = 1 + \\varepsilon m \\cos(m \\theta_n) (A - 2\\pi \\alpha B)$。要使其对所有$\\theta_n$都等于$1$，必须满足条件$A - 2\\pi \\alpha B = 0$。非平凡测试用例（用例2、3和4）的参数不满足此条件。虽然这在问题的描述性文本中存在科学上的不准确性，但映射本身的数学公式是明确无误的。任务是实现指定的方程，而不是推导一个完全辛的映射。因此，我们继续实现给定的递推关系。\n\n每个测试用例需要计算的量如下：\n$1$. 平均旋转变换$\\rho$，通过$N$次迭代计算得出：\n$$\n\\rho = \\frac{1}{2\\pi N}\\sum_{n=0}^{N-1} \\Delta\\theta_n\n$$\n该量代表了计算出的轨道的有效旋转变换。在可积极限下（$\\varepsilon=0$），$\\rho$收敛到未受扰动的旋转变换$\\iota(I_0)$。\n\n$2$. 安全因子$q$，即旋转变换的倒数：\n$$\nq = \\frac{1}{\\rho}\n$$\n\n$3$. 评估轨迹是否形成不变曲线。这取决于作用量坐标$I$在整个轨迹上的最大变化量，$\\Delta I_{\\max} = \\max_{n \\in [0,N]} I_n - \\min_{n \\in [0,N]} I_n$。如果此变化量受给定容差$\\mathrm{tol}$的限制，则认为轨迹位于不变曲线上：\n$$\n\\mathrm{invariant} = (\\Delta I_{\\max} \\le \\mathrm{tol})\n$$\n一个小的、有界的$\\Delta I_{\\max}$表示一个规则的、非混沌的轨道，该轨道被限制在相空间的一个薄带中，这是KAM环面的特征。一个大的$\\Delta I_{\\max}$则表明轨道是混沌的，它会探索相空间中更广泛的区域。\n\n每个测试用例的算法如下：\n$1$. 初始化状态变量$I_n = I_0$和$\\theta_n = \\theta_0$。初始化总角度变化累加器$\\sum \\Delta\\theta_n = 0$，以及一个用于存储$I$值历史记录的列表，以$I_0$开始。\n$2$. 迭代$N$次，其中$n$从$0$到$N-1$：\n    a. 计算当前作用量下的旋转变换：$\\iota(I_n) = \\iota_0 + \\alpha I_n$。\n    b. 计算角度增量：$\\Delta\\theta_n = 2\\pi\\,\\iota(I_n) + \\varepsilon\\,A\\,\\sin(m\\,\\theta_n)$。\n    c. 更新总角度变化累加器。\n    d. 使用映射方程计算下一个状态$(I_{n+1}, \\theta_{n+1})$。角度$\\theta_{n+1}$必须使用模运算符保持在$[0, 2\\pi)$范围内。\n    e. 将新的作用量$I_{n+1}$存储在历史记录列表中。\n    f. 为下一次迭代更新状态变量：$I_n \\leftarrow I_{n+1}$，$\\theta_n \\leftarrow \\theta_{n+1}$。\n$3$. 循环完成后，使用累积的数据计算$\\rho$、$q$和$\\Delta I_{\\max}$。\n$4$. 将$\\Delta I_{\\max}$与$\\mathrm{tol}$进行比较，以确定$\\mathrm{invariant}$的布尔值。\n$5$. 将浮点结果$\\rho$和$q$四舍五入到$6$位小数，并按要求格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Poincaré map simulation for all test cases.\n    \"\"\"\n\n    # Test suite (each tuple lists (iota_0, alpha, I_0, theta_0, epsilon, A, B, m, N, tol)):\n    test_cases = [\n        # Case 1 (integrable rigid rotation)\n        (0.35, 0.0, 0.2, 1.1, 0.0, 0.0, 0.0, 3, 4000, 0.005),\n        # Case 2 (near-integrable invariant curve with theta-kick only)\n        (0.381966011, 0.0, 0.15, 0.7, 0.02, 1.0, 0.0, 3, 5000, 0.01),\n        # Case 3 (resonant island formation near rational rotational transform)\n        (0.4, 0.0, 0.25, 0.7, 0.08, 1.0, 0.02, 1, 6000, 0.015),\n        # Case 4 (chaotic layer with larger perturbation and twist)\n        (0.35, 0.1, 0.5, 1.2, 0.25, 1.0, 0.2, 2, 6000, 0.05),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _run_simulation(params)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # str() on a list converts it to a string like \"[item1, item2, True]\".\n    # The boolean True/False is capitalized by default in Python string conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _run_simulation(params):\n    \"\"\"\n    Executes the Poincaré map iteration for a single set of parameters.\n\n    Args:\n        params (tuple): A tuple containing all the parameters for one simulation case:\n                        (iota_0, alpha, I_0, theta_0, epsilon, A, B, m, N, tol).\n\n    Returns:\n        list: A list containing [rho, q, invariant], where rho and q are floats\n              rounded to 6 decimal places and invariant is a boolean.\n    \"\"\"\n    iota_0, alpha, I_0, theta_0, epsilon, A, B, m, N, tol = params\n\n    I_n = I_0\n    theta_n = theta_0\n\n    I_history = [I_0]\n    total_delta_theta = 0.0\n    \n    two_pi = 2.0 * np.pi\n\n    for _ in range(N):\n        # Calculate rotational transform at current action I_n\n        rotational_transform_val = iota_0 + alpha * I_n\n        \n        # Pre-calculate the sinusoidal term as it's used twice\n        sin_term = np.sin(m * theta_n)\n        \n        # Calculate the change in theta for this step\n        delta_theta = two_pi * rotational_transform_val + epsilon * A * sin_term\n        total_delta_theta += delta_theta\n        \n        # Calculate the next state (I_{n+1}, theta_{n+1})\n        I_next = I_n + epsilon * B * sin_term\n        # Use fmod to handle the modulo operation for floats, ensuring theta is in [0, 2*pi)\n        theta_next = np.fmod(theta_n + delta_theta, two_pi)\n        # Ensure result is positive for negative inputs\n        if theta_next  0:\n            theta_next += two_pi\n        \n        # Store the new action value\n        I_history.append(I_next)\n        \n        # Update the state for the next iteration\n        I_n = I_next\n        theta_n = theta_next\n\n    # Post-processing calculations after N iterations\n    \n    # Average rotational transform, rho\n    rho = total_delta_theta / (two_pi * N)\n    \n    # Safety factor, q\n    q = 1.0 / rho\n    \n    # Assess trajectory invariance\n    delta_I_max = np.max(I_history) - np.min(I_history)\n    is_invariant = delta_I_max = tol\n    \n    return [round(rho, 6), round(q, 6), is_invariant]\n\nsolve()\n```"
        },
        {
            "introduction": "这项高级练习将引导您完成一项高保真湍流模拟中的关键预备任务：构建优化的磁坐标系。通过将此问题构建为一个数值优化任务，您将学习如何设计布泽尔坐标（Boozer coordinates）以简化磁场强度的谱表示。这是实现高效、精确的谱方法模拟的关键步骤。",
            "id": "4195294",
            "problem": "您将获得一个简化的磁流体动力学（MHD）数值平衡的合成模型，该模型位于单个环形磁通量面上，并由一对角坐标 $(\\theta,\\zeta)$ 表示。这对坐标已经是具有已知旋转变换 $\\iota$ 的直磁力线角。目标是构建一个 Boozer 极向角映射 $(\\theta,\\zeta)\\mapsto(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})$，该映射保持磁力线的直线性，并使磁场强度 $B(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})$ 具有一个谱简化的傅里叶表示，该表示仅限于一组指定的整数螺旋度。\n\n基本依据和定义：\n- 一个环形磁通量面由位于该面上且与磁场 $\\mathbf{B}$ 相切的磁力线构成叶状结构。在直磁力线角坐标系 $(\\theta,\\zeta)$ 中，磁力线满足 $d\\theta/d\\zeta=\\iota$，其中 $\\iota$ 是旋转变换，安全因子为 $q=1/\\iota$。\n- Boozer 坐标 $(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})$ 是一种特殊的直磁力线角，在这种坐标系中，磁场强度 $B$ 具有特别简单的傅里叶谱，并且其逆变表示具有理想的性质。在具有固定 $\\iota$ 的单个磁面上，为了保持直线性，可以将映射限制为 $\\theta_{\\mathrm{B}}=\\theta+g(\\alpha)$ 和 $\\zeta_{\\mathrm{B}}=\\zeta$ 的形式，其中 $\\alpha=\\theta-\\iota\\,\\zeta$ 是磁力线标签。\n\n本问题的建模假设：\n- 您将假设给定的 $(\\theta,\\zeta)$ 是磁面上的直磁力线角，且具有已知的常数 $\\iota$。\n- Boozer 极向角由 $\\theta_{\\mathrm{B}}=\\theta+g(\\alpha)$ 建模，其中 $\\alpha=\\theta-\\iota\\zeta$，并使用傅里叶级数拟设 $g(\\alpha)=\\sum_{k=1}^{K}\\left[a_k\\cos(k\\alpha)+b_k\\sin(k\\alpha)\\right]$，其中 $K$ 是某个小整数。\n- 在 Boozer 坐标系中，磁场强度被建模为一个截断的傅里叶级数，该级数仅限于一组给定的允许整数螺旋度 $\\{(m_j,n_j)\\}_{j=1}^{J}$：\n$$\nB(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})=B_0+\\sum_{j=1}^{J}\\left[C_j\\cos\\left(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}\\right)+S_j\\sin\\left(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}\\right)\\right].\n$$\n- 角度 $\\theta$ 和 $\\zeta$ 以弧度为单位。\n\n合成数据生成：\n- 对于每个测试用例，您将获得一组基准真实参数 $(\\iota,K,\\{(m_j,n_j)\\}_{j=1}^J,\\{a_k^{\\star},b_k^{\\star}\\}_{k=1}^K,B_0^{\\star},\\{C_j^{\\star},S_j^{\\star}\\}_{j=1}^J)$。您必须在具有 $N_\\theta$ 和 $N_\\zeta$ 个点的规则网格上生成 $(\\theta,\\zeta)$ 值，计算 $\\alpha=\\theta-\\iota\\zeta$，使用基准真实系数构建 $\\theta_{\\mathrm{B}}^{\\star}=\\theta+g^{\\star}(\\alpha)$，设置 $\\zeta_{\\mathrm{B}}=\\zeta$，并计算\n$$\nB^{\\mathrm{obs}}(\\theta,\\zeta)=B_0^{\\star}+\\sum_{j=1}^{J}\\left[C_j^{\\star}\\cos\\left(m_j\\theta_{\\mathrm{B}}^{\\star}-n_j\\zeta\\right)+S_j^{\\star}\\sin\\left(m_j\\theta_{\\mathrm{B}}^{\\star}-n_j\\zeta\\right)\\right].\n$$\n\n作为优化问题的逆向构建：\n- 给定观测场 $B^{\\mathrm{obs}}(\\theta,\\zeta)$、已知的 $\\iota$、选择的 $K$ 以及允许的螺旋度，找到使残差平方和最小化的系数 $\\{a_k,b_k\\}$、$B_0$ 和 $\\{C_j,S_j\\}$\n$$\n\\mathcal{R}=\\sum_{i=1}^{N_\\theta}\\sum_{l=1}^{N_\\zeta}\\left[B^{\\mathrm{obs}}(\\theta_i,\\zeta_l)-\\left(B_0+\\sum_{j=1}^{J}\\left[C_j\\cos\\phi_{ijl}+S_j\\sin\\phi_{ijl}\\right]\\right)\\right]^2,\n$$\n其中 $\\phi_{ijl}=m_j\\left(\\theta_i+g(\\alpha_{il})\\right)-n_j\\zeta_l$ 且 $\\alpha_{il}=\\theta_i-\\iota\\zeta_l$。该目标函数强制实现谱简化，即映射后的磁场 $B$ 中仅出现允许的螺旋度，并且通过函数形式 $\\theta_{\\mathrm{B}}=\\theta+g(\\alpha)$ 保持了直线性。\n\n您的程序必须执行以下操作：\n1. 对于下面的每个测试用例，使用提供的基准真实参数，在 $[0,2\\pi)$ 范围内大小为 $N_\\theta\\times N_\\zeta$（其中 $N_\\theta=N_\\zeta=24$）的均匀网格上合成 $B^{\\mathrm{obs}}(\\theta,\\zeta)$。$\\theta$ 和 $\\zeta$ 使用弧度单位。\n2. 求解非线性最小二乘问题以估计系数 $\\{\\hat{a}_k,\\hat{b}_k\\}$、$\\hat{B}_0$ 和 $\\{\\hat{C}_j,\\hat{S}_j\\}$。\n3. 计算重构的 Boozer 角映射的均方根（RMS）误差，\n$$\n\\varepsilon_{\\mathrm{map}}=\\left(\\frac{1}{N_\\theta N_\\zeta}\\sum_{i,l}\\left[g(\\alpha_{il};\\{\\hat{a}_k,\\hat{b}_k\\})-g^{\\star}(\\alpha_{il})\\right]^2\\right)^{1/2},\n$$\n以弧度表示。\n4. 对于每个测试用例，报告标量 $\\varepsilon_{\\mathrm{map}}$，保留六位小数。\n\n角度单位要求：\n- 所有角度均以弧度为单位。RMS 误差 $\\varepsilon_{\\mathrm{map}}$ 必须以弧度报告。\n\n测试套件：\n- 所有用例均使用 $N_\\theta=N_\\zeta=24$。允许的螺旋度以整数对 $(m,n)$ 的形式给出。\n- 用例 1（理想路径）：\n  - $\\iota=1.0$，$K=1$，允许的螺旋度 $\\{(1,1),(2,2)\\}$，\n  - 基准真实映射系数 $a_1^{\\star}=0.2$，$b_1^{\\star}=-0.1$，\n  - 基准真实场系数 $B_0^{\\star}=1.2$，$(C_{(1,1)}^{\\star},S_{(1,1)}^{\\star})=(0.3,0.1)$，$(C_{(2,2)}^{\\star},S_{(2,2)}^{\\star})=(0.05,-0.02)$。\n- 用例 2（不同的旋转变换和单一螺旋度）：\n  - $\\iota=0.5$，$K=1$，允许的螺旋度 $\\{(2,1)\\}$，\n  - 基准真实映射系数 $a_1^{\\star}=0.15$，$b_1^{\\star}=0.05$，\n  - 基准真实场系数 $B_0^{\\star}=0.9$，$(C_{(2,1)}^{\\star},S_{(2,1)}^{\\star})=(0.25,0.12)$。\n- 用例 3（边界情况：恒等映射，仅含 theta 的谱）：\n  - $\\iota=1.0$，$K=2$，允许的螺旋度 $\\{(1,0)\\}$，\n  - 基准真实映射系数 $a_1^{\\star}=0.0$，$b_1^{\\star}=0.0$，$a_2^{\\star}=0.0$，$b_2^{\\star}=0.0$，\n  - 基准真实场系数 $B_0^{\\star}=1.0$，$(C_{(1,0)}^{\\star},S_{(1,0)}^{\\star})=(0.2,-0.15)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用例 1、2 和 3 的三个 RMS 误差列表（以弧度为单位），每个误差保留六位小数，格式为用方括号括起来的逗号分隔列表，例如 [0.001234,0.000987,0.000001]。",
            "solution": "用户提供了一个问题陈述，要求解决一个源于磁约束聚变研究的合成逆问题。任务是从合成生成的数据中恢复坐标变换和磁场模型的参数。\n\n### 问题验证\n\n首先，对问题陈述进行细致的验证。\n\n*   **步骤 1：提取已知条件**\n    *   **坐标**：直磁力线角坐标 $(\\theta, \\zeta)$，单位为弧度。\n    *   **旋转变换**：一个已知的常数 $\\iota$。\n    *   **磁力线标签**：$\\alpha = \\theta - \\iota\\zeta$。\n    *   **坐标映射**：到 Boozer 极向角 $\\theta_{\\mathrm{B}}$ 的映射由 $\\theta_{\\mathrm{B}} = \\theta + g(\\alpha)$ 给出，其中 $\\zeta_{\\mathrm{B}}=\\zeta$。\n    *   **映射函数拟设**：$g(\\alpha) = \\sum_{k=1}^{K} \\left[ a_k \\cos(k\\alpha) + b_k \\sin(k\\alpha) \\right]$。\n    *   **磁场模型**：在 Boozer 坐标系中，场强为 $B(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}}) = B_0 + \\sum_{j=1}^{J} \\left[ C_j \\cos(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}) + S_j \\sin(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}) \\right]$，其中 $\\{(m_j,n_j)\\}$ 为指定的螺旋度集合。\n    *   **合成数据生成**：$B^{\\mathrm{obs}}(\\theta,\\zeta)$ 是使用一组已知的基准真实参数 $(\\iota, K, \\{(m_j,n_j)\\}, \\{a_k^{\\star},b_k^{\\star}\\}, B_0^{\\star}, \\{C_j^{\\star},S_j^{\\star}\\})$ 在一个均匀的 $N_\\theta \\times N_\\zeta$ 网格（范围为 $[0,2\\pi) \\times [0,2\\pi)$）上生成的。\n    *   **目标函数**：最小化残差平方和 $\\mathcal{R} = \\sum_{i,l} \\left[ B^{\\mathrm{obs}}(\\theta_i,\\zeta_l) - B^{\\mathrm{model}}(\\theta_i,\\zeta_l; \\{a_k, b_k\\}, B_0, \\{C_j, S_j\\}) \\right]^2$。\n    *   **输出度量**：计算映射函数的均方根（RMS）误差，$\\varepsilon_{\\mathrm{map}} = \\left(\\frac{1}{N_\\theta N_\\zeta}\\sum_{i,l}\\left[g(\\alpha_{il};\\{\\hat{a}_k,\\hat{b}_k\\}) - g^{\\star}(\\alpha_{il})\\right]^2\\right)^{1/2}$，单位为弧度。\n    *   **网格**：$N_\\theta = N_\\zeta = 24$。\n    *   **测试用例**：提供了三组特定的基准真实参数。\n\n*   **步骤 2：使用提取的已知条件进行验证**\n    *   **科学依据**：该问题在聚变等离子体的磁流体动力学（MHD）理论中有坚实的基础。磁通量面、旋转变换、直磁力线坐标和 Boozer 坐标等概念是该领域的标准内容。该设置代表了一个简化但概念上正确的“孪生实验”或合成逆问题，这是计算科学中常用的方法。\n    *   **适定性**：该问题被表述为一个非线性最小二乘优化问题。系统是高度超定的（$24 \\times 24 = 576$ 个数据点对应最多 7 个参数），这为拟合提供了稳定性。由于合成数据是无噪声的，因此存在一个完美解（即基准真实参数），在该解处目标函数为零。这表明一个有效的非线性求解器应该能够找到一个非常接近全局最小值的解。因此，对于数值求解而言，该问题是适定的。\n    *   **客观性和完整性**：问题以精确的数学术语陈述，所有必需的参数、模型和常数都已明确提供。没有歧义或主观语言。\n    *   **一致性和可行性**：对于一个简化模型来说，给定的参数在物理上是合理的。计算任务是标准的，并且可以使用现有的数值库实现。内部没有矛盾。\n\n*   **步骤 3：结论与行动**\n    该问题被判定为**有效**。它是一个自洽、科学上合理且适定的数值问题。我现在将着手制定并实施解决方案。\n\n### 解决方案构建\n\n问题的核心是为三种不同的情况求解一个非线性最小二乘问题。对于每种情况，我们首先合成“观测”数据 $B^{\\mathrm{obs}}$，然后通过最小化残差 $\\mathcal{R}$ 来恢复模型参数。\n\n**1. 模型与参数定义**\n\n原始 $(\\theta, \\zeta)$ 网格上的磁场强度模型由下式给出：\n$$\nB^{\\mathrm{model}}(\\theta, \\zeta; \\mathbf{p}) = B_0 + \\sum_{j=1}^{J} \\left[ C_j \\cos\\phi_j + S_j \\sin\\phi_j \\right]\n$$\n其中相位 $\\phi_j$ 为\n$$\n\\phi_j(\\theta, \\zeta) = m_j \\theta_{\\mathrm{B}} - n_j \\zeta = m_j \\left( \\theta + \\sum_{k=1}^{K} [a_k \\cos(k\\alpha) + b_k \\sin(k\\alpha)] \\right) - n_j \\zeta\n$$\n且 $\\alpha = \\theta - \\iota\\zeta$。\n\n未知参数构成一个向量 $\\mathbf{p}$。对于一个给定的情况，其中映射函数 $g(\\alpha)$ 有 $K$ 个模式，场 $B$ 有 $J$ 个螺旋度，我们将 $\\mathbf{p}$ 定义为一个一维数组，按固定顺序列出所有系数：\n$$\n\\mathbf{p} = [a_1, \\dots, a_K, b_1, \\dots, b_K, B_0, C_1, \\dots, C_J, S_1, \\dots, S_J]\n$$\n需要求解的参数总数为 $2K + 2J + 1$。\n\n**2. 数据合成**\n\n对于每个测试用例，我们都有一组基准真实参数 $\\mathbf{p}^{\\star} = [a_1^{\\star}, \\dots, b_1^{\\star}, \\dots, B_0^{\\star}, \\dots, S_J^{\\star}]$。我们首先在跨越 $[0, 2\\pi) \\times [0, 2\\pi)$ 且 $N_\\theta=N_\\zeta=24$ 的均匀网格 $(\\theta_i, \\zeta_l)$ 上构建观测数据 $B^{\\mathrm{obs}}(\\theta_i, \\zeta_l)$。\n$$\n\\theta_i = \\frac{2\\pi i}{N_\\theta}, \\quad i = 0, \\dots, N_\\theta-1\n$$\n$$\n\\zeta_l = \\frac{2\\pi l}{N_\\zeta}, \\quad l = 0, \\dots, N_\\zeta-1\n$$\n$B^{\\mathrm{obs}}$ 通过计算 $B^{\\mathrm{model}}(\\theta_i, \\zeta_l; \\mathbf{p}^{\\star})$ 得到。\n\n**3. 优化**\n\n任务是找到使残差平方和最小化的参数向量 $\\hat{\\mathbf{p}}$：\n$$\n\\hat{\\mathbf{p}} = \\arg\\min_{\\mathbf{p}} \\sum_{i=1}^{N_\\theta}\\sum_{l=1}^{N_\\zeta} \\left[ B^{\\mathrm{obs}}(\\theta_i, \\zeta_l) - B^{\\mathrm{model}}(\\theta_i, \\zeta_l; \\mathbf{p}) \\right]^2\n$$\n这是一个标准的非线性最小二乘问题，可以使用数值优化库高效求解。我们将使用 `scipy.optimize.least_squares` 函数。该函数需要一个可调用对象来计算残差向量：\n$$\n\\mathbf{r}(\\mathbf{p}) = \\mathrm{vec}\\left( B^{\\mathrm{obs}}(\\theta_i, \\zeta_l) - B^{\\mathrm{model}}(\\theta_i, \\zeta_l; \\mathbf{p}) \\right)\n$$\n其中 $\\mathrm{vec}(\\cdot)$ 将 $N_\\theta \\times N_\\zeta$ 的残差矩阵展平为一维数组。迭代求解器需要一个初始猜测值 $\\mathbf{p}_0$。鉴于问题是无噪声的，并且由映射函数 $g(\\alpha)$ 引入的非线性，根据所提供的较小基准真实系数，预计是温和的，因此全零向量是一个简单而合适的选择。\n\n**4. 误差计算与报告**\n\n一旦找到最优参数向量 $\\hat{\\mathbf{p}}$，我们提取估计的映射系数 $\\{\\hat{a}_k, \\hat{b}_k\\}$。然后，我们在 $\\alpha_{il} = \\theta_i - \\iota\\zeta_l$ 值的网格上计算重构的映射函数 $g_{\\mathrm{hat}}(\\alpha)$ 和基准真实函数 $g^{\\star}(\\alpha)$。最终的性能指标是 RMS 误差：\n$$\n\\varepsilon_{\\mathrm{map}} = \\sqrt{ \\frac{1}{N_\\theta N_\\zeta} \\sum_{i,l} (g_{\\mathrm{hat}}(\\alpha_{il}) - g^{\\star}(\\alpha_{il}))^2 }\n$$\n为三个测试用例中的每一个计算该量，并以指定格式报告结果。由于数据是无噪声的，我们预计 $\\varepsilon_{\\mathrm{map}}$ 会非常接近于零，仅受优化器的容差和浮点精度限制。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # Grid parameters\n    N_theta = 24\n    N_zeta = 24\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1 (happy path)\",\n            \"iota\": 1.0, \"K\": 1, \"helicities\": [(1, 1), (2, 2)],\n            \"a_star\": np.array([0.2]), \"b_star\": np.array([-0.1]),\n            \"B0_star\": 1.2,\n            \"C_star\": np.array([0.3, 0.05]), \"S_star\": np.array([0.1, -0.02]),\n        },\n        {\n            \"name\": \"Case 2 (different transform and single helicity)\",\n            \"iota\": 0.5, \"K\": 1, \"helicities\": [(2, 1)],\n            \"a_star\": np.array([0.15]), \"b_star\": np.array([0.05]),\n            \"B0_star\": 0.9,\n            \"C_star\": np.array([0.25]), \"S_star\": np.array([0.12]),\n        },\n        {\n            \"name\": \"Case 3 (edge case: identity mapping, theta-only spectrum)\",\n            \"iota\": 1.0, \"K\": 2, \"helicities\": [(1, 0)],\n            \"a_star\": np.array([0.0, 0.0]), \"b_star\": np.array([0.0, 0.0]),\n            \"B0_star\": 1.0,\n            \"C_star\": np.array([0.2]), \"S_star\": np.array([-0.15]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(case, N_theta, N_zeta)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n\ndef solve_case(case_params, N_theta, N_zeta):\n    \"\"\"\n    Solves a single test case: synthesizes data, runs optimization, and computes error.\n    \"\"\"\n    iota = case_params[\"iota\"]\n    K = case_params[\"K\"]\n    J = len(case_params[\"helicities\"])\n    helicities = np.array(case_params[\"helicities\"])\n    \n    # Ground-truth parameters\n    a_star = case_params[\"a_star\"]\n    b_star = case_params[\"b_star\"]\n    B0_star = case_params[\"B0_star\"]\n    C_star = case_params[\"C_star\"]\n    S_star = case_params[\"S_star\"]\n\n    # 1. Synthesize B_obs on a uniform grid\n    theta_vals = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n    zeta_vals = np.linspace(0, 2 * np.pi, N_zeta, endpoint=False)\n    theta, zeta = np.meshgrid(theta_vals, zeta_vals, indexing='ij')\n\n    alpha = theta - iota * zeta\n\n    def g_func(alpha_grid, a, b):\n        g_val = np.zeros_like(alpha_grid)\n        for k_idx in range(len(a)):\n            k = k_idx + 1\n            g_val += a[k_idx] * np.cos(k * alpha_grid) + b[k_idx] * np.sin(k * alpha_grid)\n        return g_val\n    \n    g_star_grid = g_func(alpha, a_star, b_star)\n    theta_B_star = theta + g_star_grid\n\n    B_obs = np.full_like(theta, B0_star)\n    for j in range(J):\n        m, n = helicities[j]\n        phase = m * theta_B_star - n * zeta\n        B_obs += C_star[j] * np.cos(phase) + S_star[j] * np.sin(phase)\n\n    # 2. Solve the nonlinear least-squares problem\n    def residuals(p, K, J, helicities, theta, zeta, iota, B_obs_flat):\n        a = p[0:K]\n        b = p[K:2*K]\n        B0 = p[2*K]\n        C = p[2*K+1 : 2*K+1+J]\n        S = p[2*K+1+J : 2*K+1+2*J]\n        \n        alpha_grid = theta - iota * zeta\n        g_grid = g_func(alpha_grid, a, b)\n        theta_B = theta + g_grid\n\n        B_model = np.full_like(theta, B0)\n        for j in range(J):\n            m, n = helicities[j]\n            phase = m * theta_B - n * zeta\n            B_model += C[j] * np.cos(phase) + S[j] * np.sin(phase)\n        \n        return (B_model - B_obs_flat.reshape(theta.shape)).flatten()\n\n    num_params = 2 * K + 2 * J + 1\n    p0 = np.zeros(num_params)\n    \n    # Using np.mean(B_obs) as initial guess for B0 can improve convergence speed.\n    p0[2*K] = np.mean(B_obs)\n\n    res = least_squares(\n        residuals, \n        p0, \n        args=(K, J, helicities, theta, zeta, iota, B_obs),\n        method='lm'\n    )\n    p_hat = res.x\n\n    # 3. Compute the RMS error of the reconstructed Boozer angle mapping\n    a_hat = p_hat[0:K]\n    b_hat = p_hat[K:2*K]\n\n    g_hat_grid = g_func(alpha, a_hat, b_hat)\n    \n    error_map = (g_hat_grid - g_star_grid)**2\n    rms_error = np.sqrt(np.mean(error_map))\n\n    return rms_error\n\nsolve()\n```"
        }
    ]
}