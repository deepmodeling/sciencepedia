{
    "hands_on_practices": [
        {
            "introduction": "This practice takes us back to first principles. Before diving into complex numerical equilibria, it is essential to have a firm grasp of the fundamental relationships that govern magnetic geometry in idealized systems. This exercise guides you through the derivation of the widely used approximate formula for the safety factor, $q$, in a large-aspect-ratio circular tokamak, connecting the geometry ($r$, $R_0$) directly to the magnetic field components ($B_\\zeta$, $B_\\theta$) . Mastering this derivation builds crucial intuition about how the helical twist of magnetic field lines is determined.",
            "id": "4195290",
            "problem": "Consider an axisymmetric tokamak with circular, concentric magnetic flux surfaces of minor radius $r$ about a major radius $R_0$. Let $\\zeta$ denote the toroidal angle and $\\theta$ the poloidal angle, both measured in radians. Assume a large aspect ratio, meaning $\\epsilon \\equiv r/R_0 \\ll 1$, negligible Shafranov shift, and that the magnetic field can be decomposed on a flux surface into a toroidal component $B_{\\zeta}(\\psi)$ and a poloidal component $B_{\\theta}(\\psi)$ that are each approximately constant on that surface to leading order in $\\epsilon$. The field-line safety factor $q(\\psi)$ is defined as the average number of toroidal turns per poloidal turn of a magnetic field line on a given surface, and can be written as\n$$\nq(\\psi) \\equiv \\frac{1}{2\\pi} \\oint \\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}\\,\\mathrm{d}\\theta,\n$$\nwhere the integral is taken over one full poloidal circuit at fixed flux surface. Using only this definition, the geometric relations between arc lengths and angles on a circular torus, and the fact that a magnetic field line satisfies $\\mathrm{d}\\boldsymbol{x}\\parallel \\boldsymbol{B}$, derive a leading-order expression for $q(r)$ in terms of $r$, $R_0$, $B_{\\zeta}$, and $B_{\\theta}$. Express your final result as a single closed-form analytic expression. No numerical evaluation is required. State your final expression for $q(r)$ explicitly. Angles are to be treated in radians, and the safety factor is dimensionless.",
            "solution": "The user wants me to validate and solve a problem.\n\n### Step 1: Extract Givens\n\n-   **System**: Axisymmetric tokamak.\n-   **Flux Surfaces**: Circular, concentric, with minor radius $r$ and major radius $R_0$.\n-   **Coordinates**: Toroidal angle $\\zeta$ and poloidal angle $\\theta$, both in radians.\n-   **Assumption 1**: Large aspect ratio, $\\epsilon \\equiv r/R_0 \\ll 1$.\n-   **Assumption 2**: Negligible Shafranov shift.\n-   **Magnetic Field**: Decomposed into a toroidal component $B_{\\zeta}(\\psi)$ and a poloidal component $B_{\\theta}(\\psi)$.\n-   **Assumption 3**: $B_{\\zeta}(\\psi)$ and $B_{\\theta}(\\psi)$ are approximately constant on a flux surface $\\psi$ to leading order in $\\epsilon$.\n-   **Definition**: The safety factor $q(\\psi)$ is given by $q(\\psi) \\equiv \\frac{1}{2\\pi} \\oint \\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}\\,\\mathrm{d}\\theta$, where the integral is over one full poloidal circuit.\n-   **Condition**: A magnetic field line $\\boldsymbol{x}$ satisfies $\\mathrm{d}\\boldsymbol{x} \\parallel \\boldsymbol{B}$.\n-   **Objective**: Derive a leading-order expression for $q(r)$ in terms of $r$, $R_0$, $B_{\\zeta}$, and $B_{\\theta}$.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientific Grounding**: The problem is grounded in the standard, simplified model of a tokamak used in plasma physics. All concepts (magnetic surfaces, safety factor, aspect ratio, toroidal coordinates) are fundamental to the field of magnetic confinement fusion. The assumptions are standard for introductory derivations. The problem is scientifically sound.\n-   **Well-Posedness**: The problem provides a clear definition, a set of simplifying assumptions, and a well-defined objective. The information is sufficient to derive a unique leading-order expression. The mapping from flux surface label $\\psi$ to minor radius $r$ is one-to-one for the specified geometry, so asking for $q(r)$ is consistent. The problem is well-posed.\n-   **Objectivity**: The problem is stated in precise, technical language, free of any subjectivity or ambiguity.\n\nThe problem does not exhibit any of the flaws listed in the instructions (e.g., scientific unsoundness, incompleteness, contradiction, etc.). It is a standard, solvable physics problem.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. I will proceed to derive the solution.\n\n***\n\nA magnetic field line is defined as a curve $\\boldsymbol{x}$ in space whose tangent is everywhere parallel to the magnetic field vector $\\boldsymbol{B}$. This condition is expressed mathematically as $\\mathrm{d}\\boldsymbol{x} \\parallel \\boldsymbol{B}$, where $\\mathrm{d}\\boldsymbol{x}$ is the infinitesimal displacement vector along the field line.\n\nFor the specified toroidal geometry, the infinitesimal displacement vector on a magnetic flux surface can be decomposed into its poloidal and toroidal components. The differential arc length in the poloidal direction, $\\mathrm{d}l_{\\theta}$, is given by the product of the minor radius $r$ and the differential poloidal angle $\\mathrm{d}\\theta$:\n$$\n\\mathrm{d}l_{\\theta} = r \\, \\mathrm{d}\\theta\n$$\nThe differential arc length in the toroidal direction, $\\mathrm{d}l_{\\zeta}$, is given by the product of the local major radius $R$ and the differential toroidal angle $\\mathrm{d}\\zeta$. For a circular flux surface, the local major radius is $R = R_0 + r \\cos\\theta$. Therefore:\n$$\n\\mathrm{d}l_{\\zeta} = (R_0 + r \\cos\\theta) \\, \\mathrm{d}\\zeta\n$$\nThe parallelism condition $\\mathrm{d}\\boldsymbol{x} \\parallel \\boldsymbol{B}$ implies that the ratio of the path length components must be equal to the ratio of the magnetic field components:\n$$\n\\frac{\\mathrm{d}l_{\\zeta}}{\\mathrm{d}l_{\\theta}} = \\frac{B_{\\zeta}}{B_{\\theta}}\n$$\nSubstituting the expressions for the differential arc lengths:\n$$\n\\frac{(R_0 + r \\cos\\theta) \\, \\mathrm{d}\\zeta}{r \\, \\mathrm{d}\\theta} = \\frac{B_{\\zeta}}{B_{\\theta}}\n$$\nWe can rearrange this equation to solve for the ratio $\\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}$, which appears in the definition of the safety factor:\n$$\n\\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta} = \\frac{r}{R_0 + r \\cos\\theta} \\frac{B_{\\zeta}}{B_{\\theta}}\n$$\nThe problem provides the definition of the safety factor $q$. Since the flux surfaces are specified by the minor radius $r$, we write $q$ as a function of $r$:\n$$\nq(r) = \\frac{1}{2\\pi} \\oint \\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta} \\, \\mathrm{d}\\theta\n$$\nThe integral is taken over one complete poloidal turn, i.e., from $\\theta = 0$ to $\\theta = 2\\pi$. Substituting our derived expression for $\\frac{\\mathrm{d}\\zeta}{\\mathrm{d}\\theta}$ into this integral gives:\n$$\nq(r) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\left( \\frac{r}{R_0 + r \\cos\\theta} \\frac{B_{\\zeta}}{B_{\\theta}} \\right) \\, \\mathrm{d}\\theta\n$$\nThe problem states that to leading order in $\\epsilon \\equiv r/R_0$, the field components $B_{\\zeta}$ and $B_{\\theta}$ are constant on a flux surface. Thus, we can treat them as constants with respect to the integration variable $\\theta$ and move them outside the integral:\n$$\nq(r) = \\frac{r B_{\\zeta}}{2\\pi B_{\\theta}} \\int_{0}^{2\\pi} \\frac{1}{R_0 + r \\cos\\theta} \\, \\mathrm{d}\\theta\n$$\nWe are asked for a leading-order expression for $q(r)$ in the large aspect ratio limit, $r/R_0 \\ll 1$. In this limit, the term $r \\cos\\theta$ in the denominator is small compared to $R_0$. The leading-order approximation is to neglect this term, effectively approximating the torus as a straight cylinder of radius $r$ and length $2\\pi R_0$. This corresponds to setting $R \\approx R_0$:\n$$\nR_0 + r \\cos\\theta \\approx R_0\n$$\nApplying this approximation to the integrand:\n$$\nq(r) \\approx \\frac{r B_{\\zeta}}{2\\pi B_{\\theta}} \\int_{0}^{2\\pi} \\frac{1}{R_0} \\, \\mathrm{d}\\theta\n$$\nThe integrand is now a constant, $\\frac{1}{R_0}$, so the integral is elementary:\n$$\n\\int_{0}^{2\\pi} \\frac{1}{R_0} \\, \\mathrm{d}\\theta = \\frac{1}{R_0} [\\theta]_{0}^{2\\pi} = \\frac{2\\pi}{R_0}\n$$\nSubstituting this result back into the expression for $q(r)$:\n$$\nq(r) \\approx \\frac{r B_{\\zeta}}{2\\pi B_{\\theta}} \\left( \\frac{2\\pi}{R_0} \\right)\n$$\nThe factors of $2\\pi$ cancel, yielding the final leading-order expression for the safety factor:\n$$\nq(r) = \\frac{r B_{\\zeta}}{R_0 B_{\\theta}}\n$$\nThis is the desired closed-form analytic expression for $q(r)$ in terms of the specified variables, valid to leading order in the inverse aspect ratio.",
            "answer": "$$\n\\boxed{\\frac{r B_{\\zeta}}{R_0 B_{\\theta}}}\n$$"
        },
        {
            "introduction": "Abstract analytical concepts like flux surfaces come to life when they can be visualized. This practice introduces the Poincaré map, a powerful computational technique for tracing magnetic field lines and revealing the rich structure of the magnetic field in a cross-section of the torus. By implementing a simple iterative map, you will directly observe the formation of smooth invariant curves (representing ideal flux surfaces), the emergence of magnetic islands at rational surfaces, and the onset of chaos when perturbations become large . This exercise provides a concrete, visual understanding of the phase space of magnetic field line dynamics.",
            "id": "4195263",
            "problem": "You are to construct a discrete Poincaré map for the intersections of magnetic field lines with a fixed toroidal section and compute the rotational transform and safety factor. Starting from the fundamental field-line equation in magnetic coordinates $(\\psi,\\theta,\\phi)$, where $\\psi$ labels magnetic flux surfaces, $\\theta$ is the poloidal angle, and $\\phi$ is the toroidal angle, the field-line flow satisfies $d\\theta/d\\phi = \\iota(\\psi)$ in an integrable region, where $\\iota(\\psi)$ is the rotational transform, defined as the average number of poloidal turns per toroidal turn. The safety factor $q(\\psi)$ is defined as $q(\\psi) = 1/\\iota(\\psi)$ in this convention. A Poincaré section is taken at $\\phi$ increment of $2\\pi$, so the section maps successive intersections of a field line with the plane at $\\phi = 0$ modulo $2\\pi$. In the integrable case, invariant curves on the Poincaré section correspond to flux surfaces $\\psi = \\mathrm{const}$, and the map is a rigid rotation in $\\theta$. In non-integrable cases with small perturbations, near-integrable twist maps can be used to model deviations from ideal behavior. A common class of such models are area-preserving maps, which correspond to Hamiltonian systems.\n\nImplement the following near-integrable twist map, derived from a canonical twist map approximation of the field-line flow sampled each toroidal turn at $\\Delta\\phi = 2\\pi$:\n- Let the action-like coordinate be $I$ (a proxy for $\\psi$ scaled to be dimensionless) and the angle be $\\theta$ (in radians). Use a linear twist profile $\\iota(I) = \\iota_0 + \\alpha I$ with constants $\\iota_0$ and $\\alpha$.\n- A single iteration from $(I_n,\\theta_n)$ to $(I_{n+1},\\theta_{n+1})$ is\n$$\n\\Delta\\theta_n = 2\\pi\\,\\iota(I_n) + \\varepsilon\\,A\\,\\sin(m\\,\\theta_n), \\quad \\theta_{n+1} = \\theta_n + \\Delta\\theta_n \\; \\mathrm{mod}\\; 2\\pi,\n$$\n$$\nI_{n+1} = I_n + \\varepsilon\\,B\\,\\sin(m\\,\\theta_n),\n$$\nwhere $\\varepsilon$ is a perturbation amplitude, $A$ and $B$ are perturbation coefficients, and $m$ is an integer mode number. Angles must be treated in radians. The iteration count is $N$.\n\nFor each parameter set, you must:\n- Iterate the map for $N$ steps starting from $(I_0,\\theta_0)$.\n- Compute the average rotational transform $\\rho$ from the accumulated angle increments as\n$$\n\\rho = \\frac{1}{2\\pi N}\\sum_{n=0}^{N-1} \\Delta\\theta_n,\n$$\nand the safety factor $q = 1/\\rho$.\n- Assess whether the trajectory lies on an invariant curve in the sense of a bounded, thin curve by computing $\\Delta I_{\\max} = \\max_n I_n - \\min_n I_n$ and returning a boolean $\\mathrm{invariant} = (\\Delta I_{\\max} \\le \\mathrm{tol})$.\n\nAll angles are in radians. All outputs are dimensionless. Express all floating-point outputs rounded to $6$ decimal places.\n\nTest suite (each tuple lists $(\\iota_0,\\alpha,I_0,\\theta_0,\\varepsilon,A,B,m,N,\\mathrm{tol})$):\n- Case $1$ (integrable rigid rotation): $(0.35, 0.0, 0.2, 1.1, 0.0, 0.0, 0.0, 3, 4000, 0.005)$.\n- Case $2$ (near-integrable invariant curve with $\\theta$-kick only): $(0.381966011, 0.0, 0.15, 0.7, 0.02, 1.0, 0.0, 3, 5000, 0.01)$.\n- Case $3$ (resonant island formation near rational rotational transform): $(0.4, 0.0, 0.25, 0.7, 0.08, 1.0, 0.02, 1, 6000, 0.015)$.\n- Case $4$ (chaotic layer with larger perturbation and twist): $(0.35, 0.1, 0.5, 1.2, 0.25, 1.0, 0.2, 2, 6000, 0.05)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each case’s result must be a list of the form $[\\rho,q,\\mathrm{invariant}]$, where $\\rho$ and $q$ are floats rounded to $6$ decimals and $\\mathrm{invariant}$ is a boolean. For example, the overall output should look like $[[\\rho_1,q_1,\\mathrm{invariant}_1],[\\rho_2,q_2,\\mathrm{invariant}_2],[\\rho_3,q_3,\\mathrm{invariant}_3],[\\rho_4,q_4,\\mathrm{invariant}_4]]$.",
            "solution": "The problem requires the implementation and analysis of a discrete Poincaré map that models the dynamics of magnetic field lines in a toroidal plasma confinement device. The core task is to iterate a given set of recurrence relations for a specified number of steps, starting from a given initial condition. From the generated trajectory, we are to compute the average rotational transform, the corresponding safety factor, and assess whether the trajectory remains on an invariant curve.\n\nThe system is described by an action-like coordinate $I$, which is a proxy for the magnetic flux surface label $\\psi$, and a poloidal angle coordinate $\\theta$. The map describes the evolution of $(I_n, \\theta_n)$ to $(I_{n+1}, \\theta_{n+1})$ after one full toroidal transit, corresponding to an increment in toroidal angle of $\\Delta\\phi = 2\\pi$. The rotational transform is given a linear dependence on the action, $\\iota(I) = \\iota_0 + \\alpha I$.\n\nThe discrete map is defined by the following iteration rules:\n$$\nI_{n+1} = I_n + \\varepsilon\\,B\\,\\sin(m\\,\\theta_n)\n$$\n$$\n\\theta_{n+1} = \\left( \\theta_n + \\Delta\\theta_n \\right) \\pmod{2\\pi}\n$$\nwhere the change in angle per iteration is given by:\n$$\n\\Delta\\theta_n = 2\\pi\\,\\iota(I_n) + \\varepsilon\\,A\\,\\sin(m\\,\\theta_n)\n$$\nHere, $\\varepsilon$ is the perturbation amplitude, $A$ and $B$ are coefficients, and $m$ is the poloidal mode number of the perturbation. The iteration proceeds for $N$ steps from an initial state $(I_0, \\theta_0)$. All angles are in radians.\n\nA point of critical analysis concerns the problem's description of this map as \"area-preserving\". A map $(I_n, \\theta_n) \\mapsto (I_{n+1}, \\theta_{n+1})$ is area-preserving if the determinant of its Jacobian matrix is unity. The Jacobian matrix $J$ for this map is:\n$$\nJ = \\begin{pmatrix} \\frac{\\partial I_{n+1}}{\\partial I_n} & \\frac{\\partial I_{n+1}}{\\partial \\theta_n} \\\\ \\frac{\\partial \\theta_{n+1}}{\\partial I_n} & \\frac{\\partial \\theta_{n+1}}{\\partial \\theta_n} \\end{pmatrix} = \\begin{pmatrix} 1 & \\varepsilon B m \\cos(m \\theta_n) \\\\ 2\\pi \\alpha & 1 + \\varepsilon A m \\cos(m \\theta_n) \\end{pmatrix}\n$$\nThe determinant is $\\det(J) = 1 \\cdot (1 + \\varepsilon A m \\cos(m \\theta_n)) - (2\\pi \\alpha)(\\varepsilon B m \\cos(m \\theta_n)) = 1 + \\varepsilon m \\cos(m \\theta_n) (A - 2\\pi \\alpha B)$. For this to be equal to $1$ for all $\\theta_n$, the condition $A - 2\\pi \\alpha B = 0$ must be satisfied. This condition is not met by the parameters of the non-trivial test cases (Cases $2$, $3$, and $4$). While this represents a scientific inaccuracy in the problem's descriptive text, the mathematical formulation of the map itself is unambiguous. The task is to implement the specified equations, not to derive a perfectly symplectic map. We therefore proceed with the implementation of the given recurrence relations.\n\nThe quantities to be computed for each test case are:\n$1$. The average rotational transform, $\\rho$, calculated over the $N$ iterations:\n$$\n\\rho = \\frac{1}{2\\pi N}\\sum_{n=0}^{N-1} \\Delta\\theta_n\n$$\nThis quantity represents the effective rotational transform of the computed orbit. In the integrable limit ($\\varepsilon=0$), $\\rho$ converges to the unperturbed rotational transform $\\iota(I_0)$.\n\n$2$. The safety factor, $q$, which is the reciprocal of the rotational transform:\n$$\nq = \\frac{1}{\\rho}\n$$\n\n$3$. An assessment of whether the trajectory forms an invariant curve. This is determined by the maximum variation of the action coordinate $I$ over the entire trajectory, $\\Delta I_{\\max} = \\max_{n \\in [0,N]} I_n - \\min_{n \\in [0,N]} I_n$. The trajectory is considered to be on an invariant curve if this variation is bounded by a given tolerance, $\\mathrm{tol}$:\n$$\n\\mathrm{invariant} = (\\Delta I_{\\max} \\le \\mathrm{tol})\n$$\nA small, bounded $\\Delta I_{\\max}$ signifies a regular, non-chaotic orbit confined to a thin ribbon in phase space, characteristic of a KAM torus. A large $\\Delta I_{\\max}$ suggests a chaotic orbit that explores a wider region of phase space.\n\nThe algorithm for each test case is as follows:\n$1$. Initialize the state variables $I_n = I_0$ and $\\theta_n = \\theta_0$. Initialize an accumulator for the total angular change, $\\sum \\Delta\\theta_n = 0$, and a list to store the history of $I$ values, beginning with $I_0$.\n$2$. Iterate $N$ times, for $n$ from $0$ to $N-1$:\n    a. Compute the rotational transform for the current action: $\\iota(I_n) = \\iota_0 + \\alpha I_n$.\n    b. Compute the angular increment: $\\Delta\\theta_n = 2\\pi\\,\\iota(I_n) + \\varepsilon\\,A\\,\\sin(m\\,\\theta_n)$.\n    c. Update the total angular change accumulator.\n    d. Compute the next state $(I_{n+1}, \\theta_{n+1})$ using the map equations. The angle $\\theta_{n+1}$ must be kept within the range $[0, 2\\pi)$ using the modulo operator.\n    e. Store the new action $I_{n+1}$ in the history list.\n    f. Update the state variables for the next iteration: $I_n \\leftarrow I_{n+1}$, $\\theta_n \\leftarrow \\theta_{n+1}$.\n$3$. After the loop completes, use the accumulated data to compute $\\rho$, $q$, and $\\Delta I_{\\max}$.\n$4$. Compare $\\Delta I_{\\max}$ with $\\mathrm{tol}$ to determine the boolean value of $\\mathrm{invariant}$.\n$5$. Round the floating-point results, $\\rho$ and $q$, to $6$ decimal places and format the output as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Poincaré map simulation for all test cases.\n    \"\"\"\n\n    # Test suite (each tuple lists (iota_0, alpha, I_0, theta_0, epsilon, A, B, m, N, tol)):\n    test_cases = [\n        # Case 1 (integrable rigid rotation)\n        (0.35, 0.0, 0.2, 1.1, 0.0, 0.0, 0.0, 3, 4000, 0.005),\n        # Case 2 (near-integrable invariant curve with theta-kick only)\n        (0.381966011, 0.0, 0.15, 0.7, 0.02, 1.0, 0.0, 3, 5000, 0.01),\n        # Case 3 (resonant island formation near rational rotational transform)\n        (0.4, 0.0, 0.25, 0.7, 0.08, 1.0, 0.02, 1, 6000, 0.015),\n        # Case 4 (chaotic layer with larger perturbation and twist)\n        (0.35, 0.1, 0.5, 1.2, 0.25, 1.0, 0.2, 2, 6000, 0.05),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _run_simulation(params)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # str() on a list converts it to a string like \"[item1, item2, True]\".\n    # The boolean True/False is capitalized by default in Python string conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _run_simulation(params):\n    \"\"\"\n    Executes the Poincaré map iteration for a single set of parameters.\n\n    Args:\n        params (tuple): A tuple containing all the parameters for one simulation case:\n                        (iota_0, alpha, I_0, theta_0, epsilon, A, B, m, N, tol).\n\n    Returns:\n        list: A list containing [rho, q, invariant], where rho and q are floats\n              rounded to 6 decimal places and invariant is a boolean.\n    \"\"\"\n    iota_0, alpha, I_0, theta_0, epsilon, A, B, m, N, tol = params\n\n    I_n = I_0\n    theta_n = theta_0\n\n    I_history = [I_0]\n    total_delta_theta = 0.0\n    \n    two_pi = 2.0 * np.pi\n\n    for _ in range(N):\n        # Calculate rotational transform at current action I_n\n        rotational_transform_val = iota_0 + alpha * I_n\n        \n        # Pre-calculate the sinusoidal term as it's used twice\n        sin_term = np.sin(m * theta_n)\n        \n        # Calculate the change in theta for this step\n        delta_theta = two_pi * rotational_transform_val + epsilon * A * sin_term\n        total_delta_theta += delta_theta\n        \n        # Calculate the next state (I_{n+1}, theta_{n+1})\n        I_next = I_n + epsilon * B * sin_term\n        # Use fmod to handle the modulo operation for floats, ensuring theta is in [0, 2*pi)\n        theta_next = np.fmod(theta_n + delta_theta, two_pi)\n        # Ensure result is positive for negative inputs\n        if theta_next < 0:\n            theta_next += two_pi\n        \n        # Store the new action value\n        I_history.append(I_next)\n        \n        # Update the state for the next iteration\n        I_n = I_next\n        theta_n = theta_next\n\n    # Post-processing calculations after N iterations\n    \n    # Average rotational transform, rho\n    rho = total_delta_theta / (two_pi * N)\n    \n    # Safety factor, q\n    q = 1.0 / rho\n    \n    # Assess trajectory invariance\n    delta_I_max = np.max(I_history) - np.min(I_history)\n    is_invariant = delta_I_max <= tol\n    \n    return [round(rho, 6), round(q, 6), is_invariant]\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the foundational concepts, this final practice tackles a problem of direct relevance to modern plasma turbulence simulation. The performance of many simulation codes depends critically on the choice of coordinate system, and Boozer coordinates are often preferred for their property of representing the magnetic field strength with a simple Fourier spectrum. This exercise frames the construction of Boozer coordinates as a synthetic inverse problem, where you will use optimization techniques to find a coordinate transformation that \"straightens\" the field lines and simplifies the field's spectral representation from a given numerical equilibrium . This demonstrates a practical skill set at the interface of physics theory and computational science.",
            "id": "4195294",
            "problem": "You are given a simplified synthetic model of a magnetohydrodynamic (MHD) numerical equilibrium on a single toroidal magnetic flux surface, represented in a pair of angular coordinates $(\\theta,\\zeta)$ that are already straight-field-line angles with a known rotational transform $\\iota$. The goal is to construct a Boozer poloidal angle mapping $(\\theta,\\zeta)\\mapsto(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})$ that preserves straightness of field lines and makes the magnetic field magnitude $B(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})$ have a spectrally simple Fourier representation restricted to a specified set of integer helicities.\n\nFundamental base and definitions:\n- A toroidal magnetic flux surface is foliated by magnetic field lines that lie on the surface, tangent to the magnetic field $\\mathbf{B}$. A straight-field-line angular system $(\\theta,\\zeta)$ is one in which field lines satisfy $d\\theta/d\\zeta=\\iota$, where $\\iota$ is the rotational transform, and the safety factor is $q=1/\\iota$.\n- Boozer coordinates $(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})$ are special straight-field-line angles in which the magnetic field magnitude $B$ possesses a particularly simple Fourier spectrum and the contravariant representation has desirable properties. On a single surface with fixed $\\iota$, one may restrict to mappings of the form $\\theta_{\\mathrm{B}}=\\theta+g(\\alpha)$ and $\\zeta_{\\mathrm{B}}=\\zeta$, where $\\alpha=\\theta-\\iota\\,\\zeta$ is the field-line label, to preserve straightness.\n\nModeling assumptions for this problem:\n- You will assume that the given $(\\theta,\\zeta)$ are straight-field-line angles with known constant $\\iota$ on the surface.\n- The Boozer poloidal angle is modeled by $\\theta_{\\mathrm{B}}=\\theta+g(\\alpha)$ with $\\alpha=\\theta-\\iota\\zeta$ and a Fourier series ansatz $g(\\alpha)=\\sum_{k=1}^{K}\\left[a_k\\cos(k\\alpha)+b_k\\sin(k\\alpha)\\right]$ for some small integer $K$.\n- The magnetic field magnitude in Boozer coordinates is modeled as a truncated Fourier series restricted to a provided set of allowed integer helicities $\\{(m_j,n_j)\\}_{j=1}^{J}$:\n$$\nB(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}})=B_0+\\sum_{j=1}^{J}\\left[C_j\\cos\\left(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}\\right)+S_j\\sin\\left(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}\\right)\\right].\n$$\n- Angles $\\theta$ and $\\zeta$ are measured in radians.\n\nSynthetic data generation:\n- For each test case, you are provided a ground-truth set of parameters $(\\iota,K,\\{(m_j,n_j)\\}_{j=1}^J,\\{a_k^{\\star},b_k^{\\star}\\}_{k=1}^K,B_0^{\\star},\\{C_j^{\\star},S_j^{\\star}\\}_{j=1}^J)$. You must generate a regular grid of $(\\theta,\\zeta)$ values with $N_\\theta$ and $N_\\zeta$ points, compute $\\alpha=\\theta-\\iota\\zeta$, construct $\\theta_{\\mathrm{B}}^{\\star}=\\theta+g^{\\star}(\\alpha)$ using the ground-truth coefficients, set $\\zeta_{\\mathrm{B}}=\\zeta$, and evaluate\n$$\nB^{\\mathrm{obs}}(\\theta,\\zeta)=B_0^{\\star}+\\sum_{j=1}^{J}\\left[C_j^{\\star}\\cos\\left(m_j\\theta_{\\mathrm{B}}^{\\star}-n_j\\zeta\\right)+S_j^{\\star}\\sin\\left(m_j\\theta_{\\mathrm{B}}^{\\star}-n_j\\zeta\\right)\\right].\n$$\n\nInverse construction as an optimization problem:\n- Given the observed field $B^{\\mathrm{obs}}(\\theta,\\zeta)$, the known $\\iota$, the chosen $K$, and the allowed helicities, find coefficients $\\{a_k,b_k\\}$, $B_0$, and $\\{C_j,S_j\\}$ that minimize the squared residual\n$$\n\\mathcal{R}=\\sum_{i=1}^{N_\\theta}\\sum_{l=1}^{N_\\zeta}\\left[B^{\\mathrm{obs}}(\\theta_i,\\zeta_l)-\\left(B_0+\\sum_{j=1}^{J}\\left[C_j\\cos\\phi_{ijl}+S_j\\sin\\phi_{ijl}\\right]\\right)\\right]^2,\n$$\nwhere $\\phi_{ijl}=m_j\\left(\\theta_i+g(\\alpha_{il})\\right)-n_j\\zeta_l$ and $\\alpha_{il}=\\theta_i-\\iota\\zeta_l$. This objective enforces spectral simplicity in the sense that only the allowed helicities appear in $B$ after the mapping, and straightness is preserved by the functional form $\\theta_{\\mathrm{B}}=\\theta+g(\\alpha)$.\n\nWhat your program must do:\n1. For each test case below, synthesize $B^{\\mathrm{obs}}(\\theta,\\zeta)$ on a uniform grid of size $N_\\theta\\times N_\\zeta$ with $N_\\theta=N_\\zeta=24$ points in $[0,2\\pi)$, using the provided ground-truth parameters. Use $\\theta$ and $\\zeta$ in radians.\n2. Solve the nonlinear least-squares problem to estimate the coefficients $\\{\\hat{a}_k,\\hat{b}_k\\}$, $\\hat{B}_0$, and $\\{\\hat{C}_j,\\hat{S}_j\\}$.\n3. Compute the root-mean-square (RMS) error of the reconstructed Boozer angle mapping,\n$$\n\\varepsilon_{\\mathrm{map}}=\\left(\\frac{1}{N_\\theta N_\\zeta}\\sum_{i,l}\\left[g(\\alpha_{il};\\{\\hat{a}_k,\\hat{b}_k\\})-g^{\\star}(\\alpha_{il})\\right]^2\\right)^{1/2},\n$$\nexpressed in radians.\n4. Report, for each test case, the scalar $\\varepsilon_{\\mathrm{map}}$ rounded to six decimal places.\n\nAngle unit requirement:\n- All angles are in radians. The RMS error $\\varepsilon_{\\mathrm{map}}$ must be reported in radians.\n\nTest suite:\n- Use $N_\\theta=N_\\zeta=24$ for all cases. The allowed helicities are given as integer pairs $(m,n)$.\n- Case $1$ (happy path):\n  - $\\iota=1.0$, $K=1$, allowed $\\{(1,1),(2,2)\\}$,\n  - ground-truth mapping coefficients $a_1^{\\star}=0.2$, $b_1^{\\star}=-0.1$,\n  - ground-truth field coefficients $B_0^{\\star}=1.2$, $(C_{(1,1)}^{\\star},S_{(1,1)}^{\\star})=(0.3,0.1)$, $(C_{(2,2)}^{\\star},S_{(2,2)}^{\\star})=(0.05,-0.02)$.\n- Case $2$ (different transform and single helicity):\n  - $\\iota=0.5$, $K=1$, allowed $\\{(2,1)\\}$,\n  - ground-truth mapping coefficients $a_1^{\\star}=0.15$, $b_1^{\\star}=0.05$,\n  - ground-truth field coefficients $B_0^{\\star}=0.9$, $(C_{(2,1)}^{\\star},S_{(2,1)}^{\\star})=(0.25,0.12)$.\n- Case $3$ (edge case: identity mapping, theta-only spectrum):\n  - $\\iota=1.0$, $K=2$, allowed $\\{(1,0)\\}$,\n  - ground-truth mapping coefficients $a_1^{\\star}=0.0$, $b_1^{\\star}=0.0$, $a_2^{\\star}=0.0$, $b_2^{\\star}=0.0$,\n  - ground-truth field coefficients $B_0^{\\star}=1.0$, $(C_{(1,0)}^{\\star},S_{(1,0)}^{\\star})=(0.2,-0.15)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the list of the three RMS errors for Cases $1$, $2$, and $3$, in radians, each rounded to six decimal places, as a comma-separated list enclosed in square brackets, for example, $[0.001234,0.000987,0.000001]$.",
            "solution": "The user has provided a problem statement that requires the solution of a synthetic inverse problem arising in magnetic confinement fusion research. The task is to recover the parameters of a coordinate transformation and a magnetic field model from synthetically generated data.\n\n### Problem Validation\n\nFirst, a meticulous validation of the problem statement is performed.\n\n*   **Step 1: Extracted Givens**\n    *   **Coordinates**: Straight-field-line angular coordinates $(\\theta, \\zeta)$ with units of radians.\n    *   **Rotational Transform**: A known constant $\\iota$.\n    *   **Field-Line Label**: $\\alpha = \\theta - \\iota\\zeta$.\n    *   **Coordinate Mapping**: The mapping to Boozer poloidal angle $\\theta_{\\mathrm{B}}$ is given by $\\theta_{\\mathrm{B}} = \\theta + g(\\alpha)$, with $\\zeta_{\\mathrm{B}}=\\zeta$.\n    *   **Mapping Function Ansatz**: $g(\\alpha) = \\sum_{k=1}^{K} \\left[ a_k \\cos(k\\alpha) + b_k \\sin(k\\alpha) \\right]$.\n    *   **Magnetic Field Model**: In Boozer coordinates, the field magnitude is $B(\\theta_{\\mathrm{B}},\\zeta_{\\mathrm{B}}) = B_0 + \\sum_{j=1}^{J} \\left[ C_j \\cos(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}) + S_j \\sin(m_j\\theta_{\\mathrm{B}}-n_j\\zeta_{\\mathrm{B}}) \\right]$ for a specified set of helicities $\\{(m_j,n_j)\\}$.\n    *   **Synthetic Data Generation**: $B^{\\mathrm{obs}}(\\theta,\\zeta)$ is generated on a uniform $N_\\theta \\times N_\\zeta$ grid in $[0,2\\pi) \\times [0,2\\pi)$ using a set of known ground-truth parameters $(\\iota, K, \\{(m_j,n_j)\\}, \\{a_k^{\\star},b_k^{\\star}\\}, B_0^{\\star}, \\{C_j^{\\star},S_j^{\\star}\\})$.\n    *   **Objective Function**: Minimize the squared residual $\\mathcal{R} = \\sum_{i,l} \\left[ B^{\\mathrm{obs}}(\\theta_i,\\zeta_l) - B^{\\mathrm{model}}(\\theta_i,\\zeta_l; \\{a_k, b_k\\}, B_0, \\{C_j, S_j\\}) \\right]^2$.\n    *   **Output Metric**: Compute the root-mean-square (RMS) error of the mapping function, $\\varepsilon_{\\mathrm{map}} = \\left(\\frac{1}{N_\\theta N_\\zeta}\\sum_{i,l}\\left[g(\\alpha_{il};\\{\\hat{a}_k,\\hat{b}_k\\}) - g^{\\star}(\\alpha_{il})\\right]^2\\right)^{1/2}$, in radians.\n    *   **Grid**: $N_\\theta = N_\\zeta = 24$.\n    *   **Test Cases**: Three specific sets of ground-truth parameters are provided.\n\n*   **Step 2: Validation Using Extracted Givens**\n    *   **Scientific Grounding**: The problem is well-grounded in the theory of magnetohydrodynamics (MHD) for fusion plasmas. The concepts of flux surfaces, rotational transform, straight-field-line coordinates, and Boozer coordinates are standard in the field. The setup represents a simplified but conceptually correct \"twin experiment\" or synthetic inverse problem, a common methodology in computational science.\n    *   **Well-Posedness**: The problem is formulated as a nonlinear least-squares optimization. The system is highly overdetermined ($24 \\times 24 = 576$ data points for at most $7$ parameters), which lends stability to the fit. Since the synthetic data is noise-free, a perfect solution exists (the ground-truth parameters), at which the objective function is zero. This suggests that a competent nonlinear solver should be able to find a solution very close to the global minimum. The problem is thus well-posed for numerical solution.\n    *   **Objectivity and Completeness**: The problem is stated in precise mathematical terms, with all necessary parameters, models, and constants explicitly provided. There is no ambiguity or subjective language.\n    *   **Consistency and Feasibility**: The given parameters are physically plausible for a simplified model. The computational task is standard and feasible with available numerical libraries. There are no internal contradictions.\n\n*   **Step 3: Verdict and Action**\n    The problem is deemed **valid**. It is a self-contained, scientifically sound, and well-posed numerical problem. I will now proceed to formulate and implement the solution.\n\n### Solution Formulation\n\nThe core of the problem is to solve a nonlinear least-squares problem for three distinct cases. For each case, we first synthesize the \"observed\" data $B^{\\mathrm{obs}}$ and then recover the model parameters by minimizing the residual $\\mathcal{R}$.\n\n**1. Model and Parameter Definition**\n\nThe model for the magnetic field magnitude on the original $(\\theta, \\zeta)$ grid is given by:\n$$\nB^{\\mathrm{model}}(\\theta, \\zeta; \\mathbf{p}) = B_0 + \\sum_{j=1}^{J} \\left[ C_j \\cos\\phi_j + S_j \\sin\\phi_j \\right]\n$$\nwhere the phase $\\phi_j$ is\n$$\n\\phi_j(\\theta, \\zeta) = m_j \\theta_{\\mathrm{B}} - n_j \\zeta = m_j \\left( \\theta + \\sum_{k=1}^{K} [a_k \\cos(k\\alpha) + b_k \\sin(k\\alpha)] \\right) - n_j \\zeta\n$$\nand $\\alpha = \\theta - \\iota\\zeta$.\n\nThe unknown parameters form a vector $\\mathbf{p}$. For a given case with $K$ modes for the mapping function $g(\\alpha)$ and $J$ helicities for the field $B$, we define $\\mathbf{p}$ as a one-dimensional array containing the coefficients in a fixed order:\n$$\n\\mathbf{p} = [a_1, \\dots, a_K, b_1, \\dots, b_K, B_0, C_1, \\dots, C_J, S_1, \\dots, S_J]\n$$\nThe total number of parameters to be found is $2K + 2J + 1$.\n\n**2. Data Synthesis**\n\nFor each test case, we are given a set of ground-truth parameters $\\mathbf{p}^{\\star} = [a_1^{\\star}, \\dots, b_1^{\\star}, \\dots, B_0^{\\star}, \\dots, S_J^{\\star}]$. We first construct the observation data $B^{\\mathrm{obs}}(\\theta_i, \\zeta_l)$ on a uniform grid $(\\theta_i, \\zeta_l)$ spanning $[0, 2\\pi) \\times [0, 2\\pi)$ with $N_\\theta=N_\\zeta=24$.\n$$\n\\theta_i = \\frac{2\\pi i}{N_\\theta}, \\quad i = 0, \\dots, N_\\theta-1\n$$\n$$\n\\zeta_l = \\frac{2\\pi l}{N_\\zeta}, \\quad l = 0, \\dots, N_\\zeta-1\n$$\n$B^{\\mathrm{obs}}$ is computed by evaluating $B^{\\mathrm{model}}(\\theta_i, \\zeta_l; \\mathbf{p}^{\\star})$.\n\n**3. Optimization**\n\nThe task is to find the parameter vector $\\hat{\\mathbf{p}}$ that minimizes the sum of squared residuals:\n$$\n\\hat{\\mathbf{p}} = \\arg\\min_{\\mathbf{p}} \\sum_{i=1}^{N_\\theta}\\sum_{l=1}^{N_\\zeta} \\left[ B^{\\mathrm{obs}}(\\theta_i, \\zeta_l) - B^{\\mathrm{model}}(\\theta_i, \\zeta_l; \\mathbf{p}) \\right]^2\n$$\nThis is a standard nonlinear least-squares problem, which can be solved efficiently using numerical optimization libraries. We will use the `scipy.optimize.least_squares` function. This function requires a callable that computes the residual vector:\n$$\n\\mathbf{r}(\\mathbf{p}) = \\mathrm{vec}\\left( B^{\\mathrm{obs}}(\\theta_i, \\zeta_l) - B^{\\mathrm{model}}(\\theta_i, \\zeta_l; \\mathbf{p}) \\right)\n$$\nwhere $\\mathrm{vec}(\\cdot)$ flattens the $N_\\theta \\times N_\\zeta$ matrix of residuals into a one-dimensional array. An initial guess, $\\mathbf{p}_0$, is required for the iterative solver. A vector of all zeros is a simple and suitable choice, as the problem is noise-free and the nonlinearities introduced by the mapping function $g(\\alpha)$ are expected to be mild given the small ground-truth coefficients provided.\n\n**4. Error Calculation and Reporting**\n\nOnce the optimal parameter vector $\\hat{\\mathbf{p}}$ is found, we extract the estimated mapping coefficients $\\{\\hat{a}_k, \\hat{b}_k\\}$. We then compute the reconstructed mapping function $g_{\\mathrm{hat}}(\\alpha)$ and the ground-truth function $g^{\\star}(\\alpha)$ on the grid of $\\alpha_{il} = \\theta_i - \\iota\\zeta_l$ values. The final performance metric is the RMS error:\n$$\n\\varepsilon_{\\mathrm{map}} = \\sqrt{ \\frac{1}{N_\\theta N_\\zeta} \\sum_{i,l} (g_{\\mathrm{hat}}(\\alpha_{il}) - g^{\\star}(\\alpha_{il}))^2 }\n$$\nThis quantity is calculated for each of the three test cases, and the results are reported in the specified format. Since the data is noise-free, we expect $\\varepsilon_{\\mathrm{map}}$ to be very close to zero, limited only by the optimizer's tolerance and floating-point precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # Grid parameters\n    N_theta = 24\n    N_zeta = 24\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1 (happy path)\",\n            \"iota\": 1.0, \"K\": 1, \"helicities\": [(1, 1), (2, 2)],\n            \"a_star\": np.array([0.2]), \"b_star\": np.array([-0.1]),\n            \"B0_star\": 1.2,\n            \"C_star\": np.array([0.3, 0.05]), \"S_star\": np.array([0.1, -0.02]),\n        },\n        {\n            \"name\": \"Case 2 (different transform and single helicity)\",\n            \"iota\": 0.5, \"K\": 1, \"helicities\": [(2, 1)],\n            \"a_star\": np.array([0.15]), \"b_star\": np.array([0.05]),\n            \"B0_star\": 0.9,\n            \"C_star\": np.array([0.25]), \"S_star\": np.array([0.12]),\n        },\n        {\n            \"name\": \"Case 3 (edge case: identity mapping, theta-only spectrum)\",\n            \"iota\": 1.0, \"K\": 2, \"helicities\": [(1, 0)],\n            \"a_star\": np.array([0.0, 0.0]), \"b_star\": np.array([0.0, 0.0]),\n            \"B0_star\": 1.0,\n            \"C_star\": np.array([0.2]), \"S_star\": np.array([-0.15]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(case, N_theta, N_zeta)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n\ndef solve_case(case_params, N_theta, N_zeta):\n    \"\"\"\n    Solves a single test case: synthesizes data, runs optimization, and computes error.\n    \"\"\"\n    iota = case_params[\"iota\"]\n    K = case_params[\"K\"]\n    J = len(case_params[\"helicities\"])\n    helicities = np.array(case_params[\"helicities\"])\n    \n    # Ground-truth parameters\n    a_star = case_params[\"a_star\"]\n    b_star = case_params[\"b_star\"]\n    B0_star = case_params[\"B0_star\"]\n    C_star = case_params[\"C_star\"]\n    S_star = case_params[\"S_star\"]\n\n    # 1. Synthesize B_obs on a uniform grid\n    theta_vals = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n    zeta_vals = np.linspace(0, 2 * np.pi, N_zeta, endpoint=False)\n    theta, zeta = np.meshgrid(theta_vals, zeta_vals, indexing='ij')\n\n    alpha = theta - iota * zeta\n\n    def g_func(alpha_grid, a, b):\n        g_val = np.zeros_like(alpha_grid)\n        for k_idx in range(len(a)):\n            k = k_idx + 1\n            g_val += a[k_idx] * np.cos(k * alpha_grid) + b[k_idx] * np.sin(k * alpha_grid)\n        return g_val\n    \n    g_star_grid = g_func(alpha, a_star, b_star)\n    theta_B_star = theta + g_star_grid\n\n    B_obs = np.full_like(theta, B0_star)\n    for j in range(J):\n        m, n = helicities[j]\n        phase = m * theta_B_star - n * zeta\n        B_obs += C_star[j] * np.cos(phase) + S_star[j] * np.sin(phase)\n\n    # 2. Solve the nonlinear least-squares problem\n    def residuals(p, K, J, helicities, theta, zeta, iota, B_obs_flat):\n        a = p[0:K]\n        b = p[K:2*K]\n        B0 = p[2*K]\n        C = p[2*K+1 : 2*K+1+J]\n        S = p[2*K+1+J : 2*K+1+2*J]\n        \n        alpha_grid = theta - iota * zeta\n        g_grid = g_func(alpha_grid, a, b)\n        theta_B = theta + g_grid\n\n        B_model = np.full_like(theta, B0)\n        for j in range(J):\n            m, n = helicities[j]\n            phase = m * theta_B - n * zeta\n            B_model += C[j] * np.cos(phase) + S[j] * np.sin(phase)\n        \n        return (B_model - B_obs_flat.reshape(theta.shape)).flatten()\n\n    num_params = 2 * K + 2 * J + 1\n    p0 = np.zeros(num_params)\n    \n    # Using np.mean(B_obs) as initial guess for B0 can improve convergence speed.\n    p0[2*K] = np.mean(B_obs)\n\n    res = least_squares(\n        residuals, \n        p0, \n        args=(K, J, helicities, theta, zeta, iota, B_obs),\n        method='lm'\n    )\n    p_hat = res.x\n\n    # 3. Compute the RMS error of the reconstructed Boozer angle mapping\n    a_hat = p_hat[0:K]\n    b_hat = p_hat[K:2*K]\n\n    g_hat_grid = g_func(alpha, a_hat, b_hat)\n    \n    error_map = (g_hat_grid - g_star_grid)**2\n    rms_error = np.sqrt(np.mean(error_map))\n\n    return rms_error\n\nsolve()\n```"
        }
    ]
}