{
    "hands_on_practices": [
        {
            "introduction": "在系综蒙特卡罗（EMC）模拟中，最核心的步骤是确定每个载流子在两次散射事件之间的自由飞行时间。这个随机过程由散射率决定，而散射率本身又依赖于载流子在电场中飞行时不断变化的能量。本练习将指导你通过数值方法，精确计算在时变电场下自由飞行时间的具体过程 ()。",
            "id": "3743706",
            "problem": "考虑在已知的外部电场函数 $\\mathbf{E}(t)$ 下，沿场方向的一维近似中，导带电子的半经典输运。电子波矢 $k$ 根据半经典运动方程演化，且能量呈抛物线色散。您将使用这些基础来计算沿一次自由飞行的累积风险积分，并对其进行数值反演，以获得用于载流子输运的系综蒙特卡洛 (EMC) 模拟中的碰撞时间。\n\n基本原理：\n- 半经典运动方程为 $\\hbar\\,\\dfrac{dk}{dt}=-q\\,E(t)$，其中 $\\hbar$ 是约化普朗克常数，$q$ 是基本电荷量，$E(t)$ 是电场沿输运方向的标量投影。\n- 对于各向同性抛物线型导带，能量为 $\\varepsilon(t)=\\dfrac{\\hbar^2 k(t)^2}{2 m^\\star}$，群速度为 $v(t)=\\dfrac{\\hbar k(t)}{m^\\star}$，其中 $m^\\star$ 是电子有效质量。\n- 从时刻 $t_0$ 开始，持续时间为 $t$ 的一次自由飞行的累积风险为 $\\Lambda(t)=\\displaystyle\\int_{t_0}^{t_0+t}\\nu\\big(\\varepsilon(t')\\big)\\,dt'$，其中 $\\nu(\\varepsilon)$ 是能量为 $\\varepsilon$ 时的总散射率。\n- 在系综蒙特卡洛的一个步骤中，碰撞时间 $\\tau$ 由一个均匀分布的随机变量 $\\xi\\in(0,1)$ 通过 $\\Lambda(\\tau)=-\\ln\\xi$ 确定。\n\n假设散射率是能量的仿射函数 $\\nu(\\varepsilon)=\\nu_0+\\alpha\\,\\varepsilon$，其中 $\\nu_0>0$ 且 $\\alpha\\ge 0$。给定一个已知函数 $E(t)$ 及其满足 $\\dfrac{dA}{dt}=E(t)$ 的时间原函数 $A(t)$，波矢为 $k(t_0+t)=k_0-\\dfrac{q}{\\hbar}\\big(A(t_0+t)-A(t_0)\\big)$，其中 $k_0$ 是 $t=t_0$ 时的初始波矢，这进而确定了 $\\varepsilon(t)$ 和 $\\Lambda(t)$。\n\n任务：\n- 对于每个提供的测试用例，使用一种能保证单调区间套和收敛的数值稳定方法，计算碰撞时间 $\\tau$ (以秒为单位)，该时间求解 $\\Lambda(\\tau)=-\\ln\\xi$。您的数值反演必须利用当 $\\nu(\\varepsilon(t))>0$ 时，$\\Lambda(t)$ 是 $t$ 的严格递增函数这一特性。您必须：\n  1) 根据给定的 $E(t)$ 和 $A(t)$ 定义 $k(t)$。\n  2) 使用抛物线能带模型从 $k(t)$ 定义 $\\varepsilon(t)$。\n  3) 定义 $\\nu(\\varepsilon(t))$。\n  4) 通过对 $t$ 进行数值积分来计算 $\\Lambda(t)$。\n  5) 通过稳健的区间套和二分法反演 $\\Lambda(t)=-\\ln\\xi$ 以获得 $\\tau$。\n\n使用的物理常数为：$\\hbar=1.054571817\\times 10^{-34}$ $\\mathrm{J\\cdot s}$，$q=1.602176634\\times 10^{-19}$ $\\mathrm{C}$，$m_e=9.1093837015\\times 10^{-31}$ $\\mathrm{kg}$。除非另有说明，使用 $m^\\star=0.26\\,m_e$。\n\n单位：\n- 以十进制浮点数形式报告所有碰撞时间 $\\tau$，单位为秒。\n\n角度单位：\n- 任何角频率 $\\omega$ 的单位都必须是弧度/秒。\n\n测试用例：\n为以下四个科学上一致的场景提供数值碰撞时间。在所有情况下，均使用上述常数和定义。\n\n- 情况 $\\mathbf{1}$ (恒定电场，非零初始波矢)：\n  - $t_0=0$ $\\mathrm{s}$, $k_0=1.0\\times 10^{8}$ $\\mathrm{m^{-1}}$, $m^\\star=0.26\\,m_e$,\n  - $E(t)=E_0$，其中 $E_0=1.0\\times 10^{5}$ $\\mathrm{V/m}$，$A(t)=E_0\\,t$，\n  - $\\nu_0=1.0\\times 10^{11}$ $\\mathrm{s^{-1}}$, $\\alpha=2.0\\times 10^{31}$ $\\mathrm{s^{-1}\\,J^{-1}}$,\n  - $\\xi=0.37$。\n\n- 情况 $\\mathbf{2}$ (零电场，恒定风险，较高初始能量)：\n  - $t_0=0$ $\\mathrm{s}$, $k_0=5.0\\times 10^{8}$ $\\mathrm{m^{-1}}$, $m^\\star=0.26\\,m_e$,\n  - $E(t)=0$ $\\mathrm{V/m}$，$A(t)=0$，\n  - $\\nu_0=8.0\\times 10^{10}$ $\\mathrm{s^{-1}}$, $\\alpha=1.0\\times 10^{31}$ $\\mathrm{s^{-1}\\,J^{-1}}$,\n  - $\\xi=0.01$。\n\n- 情况 $\\mathbf{3}$ (正弦电场，非零开始时间)：\n  - $t_0=5.0\\times 10^{-13}$ $\\mathrm{s}$, $k_0=1.0\\times 10^{8}$ $\\mathrm{m^{-1}}$, $m^\\star=0.26\\,m_e$,\n  - $E(t)=E_1\\sin(\\omega t)$，其中 $E_1=2.0\\times 10^{5}$ $\\mathrm{V/m}$，$\\omega=2\\pi\\times 1.0\\times 10^{12}$ $\\mathrm{rad/s}$，$A(t)=-\\dfrac{E_1}{\\omega}\\cos(\\omega t)$，\n  - $\\nu_0=1.2\\times 10^{11}$ $\\mathrm{s^{-1}}$, $\\alpha=2.0\\times 10^{31}$ $\\mathrm{s^{-1}\\,J^{-1}}$,\n  - $\\xi=0.50$。\n\n- 情况 $\\mathbf{4}$ (线性斜坡电场，零初始波矢)：\n  - $t_0=0$ $\\mathrm{s}$, $k_0=0$ $\\mathrm{m^{-1}}$, $m^\\star=0.26\\,m_e$,\n  - $E(t)=\\beta\\,t$，其中 $\\beta=1.0\\times 10^{16}$ $\\mathrm{V/(m\\cdot s)}$，$A(t)=\\dfrac{1}{2}\\beta t^2$，\n  - $\\nu_0=1.0\\times 10^{11}$ $\\mathrm{s^{-1}}$, $\\alpha=3.0\\times 10^{31}$ $\\mathrm{s^{-1}\\,J^{-1}}$,\n  - $\\xi=0.999$。\n\n答案规格：\n- 您的程序应生成单行输出，其中包含四个情况下的碰撞时间 $\\tau$，按从 $\\mathbf{1}$ 到 $\\mathbf{4}$ 的顺序，以方括号括起来的逗号分隔列表形式。例如，输出必须是 $\\big[$$t_1$,$t_2$,$t_3$,$t_4$$\\big]$ 的形式，其中每个 $t_i$ 是一个以秒为单位的十进制浮点数。",
            "solution": "该问题要求在系综蒙特卡洛 (EMC) 模拟的框架内，计算电子的自由飞行碰撞时间 $\\tau$。这是通过数值求解一个超越方程来实现的，该方程将 $\\tau$ 与散射的累积风险联系起来。必须为四个不同的物理场景推导出解，每个场景都由特定的外部电场和材料参数定义。\n\n该问题的基础在于半导体导带中电子输运的半经典模型。电子的状态由其波矢 $k$ 描述，该波矢在外部电场 $E(t)$ 的影响下，根据运动方程演化：\n$$ \\hbar\\,\\frac{dk}{dt} = -q\\,E(t) $$\n其中 $\\hbar$ 是约化普朗克常数，$q$ 是基本电荷。将此方程从初始时间 $t_0$ 和初始波矢 $k_0$ 开始积分，得到作为绝对时间 $t_{abs}$ 函数的波矢：\n$$ k(t_{abs}) = k_0 - \\frac{q}{\\hbar} \\int_{t_0}^{t_{abs}} E(t')\\,dt' = k_0 - \\frac{q}{\\hbar} \\left( A(t_{abs}) - A(t_0) \\right) $$\n这里，$A(t)$ 是电场 $E(t)$ 的时间原函数。\n\n对于简单的各向同性抛物线型导带，电子的能量 $\\varepsilon$ 是其波矢的二次函数：\n$$ \\varepsilon(k) = \\frac{\\hbar^2 k^2}{2 m^\\star} $$\n其中 $m^\\star$ 是电子的有效质量。因此，电子的能量也成为时间的函数，$\\varepsilon(t_{abs}) = \\varepsilon(k(t_{abs}))$。\n\n电子散射的概率由总散射率 $\\nu(\\varepsilon)$ 描述，该散射率取决于电子的能量。在该问题中，散射率被建模为能量的仿射函数：\n$$ \\nu(\\varepsilon) = \\nu_0 + \\alpha\\,\\varepsilon $$\n其中给定的常数 $\\nu_0$ 为正，$\\alpha \\ge 0$。由于能量 $\\varepsilon$ 始终为非负值，散射率 $\\nu(\\varepsilon(t_{abs}))$ 始终为正。\n\n在蒙特卡洛方法中，一次自由飞行的持续时间 $\\tau$ 是一个随机变量。它是通过生成一个均匀随机数 $\\xi \\in (0, 1)$ 并求解以下方程来确定的：\n$$ -\\ln\\xi = \\Lambda(\\tau) $$\n其中 $\\Lambda(\\tau)$ 是累积风险积分，表示从时刻 $t_0$ 开始，在持续时间为 $\\tau$ 的自由飞行期间，散射事件的总期望数。该积分定义为：\n$$ \\Lambda(\\tau) = \\int_{t_0}^{t_0+\\tau} \\nu\\big(\\varepsilon(t')\\big)\\,dt' $$\n通过进行变量替换 $s = t' - t_0$，可以将其重写为在自由飞行持续时间从 $0$ 到 $\\tau$ 上的积分：\n$$ \\Lambda(\\tau) = \\int_{0}^{\\tau} \\nu\\big(\\varepsilon(t_0+s)\\big)\\,ds $$\n\n核心任务是找到满足方程 $f(\\tau) = 0$ 的 $\\tau > 0$ 的值，其中我们定义：\n$$ f(\\tau) = \\Lambda(\\tau) + \\ln\\xi $$\n由于对所有 $t'$ 都有 $\\nu(\\varepsilon(t')) > 0$，累积风险 $\\Lambda(\\tau)$ 是 $\\tau$ 的严格单调递增函数。此外，$\\Lambda(0) = 0$。鉴于 $\\xi \\in (0, 1)$，目标值 $-\\ln\\xi$ 总是正的。因此，保证存在方程 $f(\\tau)=0$ 的唯一正根 $\\tau$。\n\n这种结构使得该问题非常适合使用利用单调性的数值求根算法，例如二分法。步骤如下：\n1.  对于每个测试用例，定义电场时间原函数 $A(t_{abs})$、波矢 $k(t_{abs})$、能量 $\\varepsilon(t_{abs})$ 以及散射率被积函数 $\\nu(\\varepsilon(t_0+s))$ 的函数。\n2.  使用数值积分定义函数 $\\Lambda(\\tau)$。该积分使用稳健的算法计算，为此我们采用 SciPy 库中的 `quad` 函数。\n3.  定义目标函数 $f(\\tau) = \\left(\\int_{0}^{\\tau} \\nu(\\varepsilon(t_0+s))\\,ds\\right) + \\ln\\xi$。\n4.  找到根的一个区间 $[a, b]$，使得 $f(a) \\cdot f(b)  0$。由于 $f(0) = \\ln\\xi  0$，我们可以将下界设为 $a=0$。上界 $b$ 通过从一个小的正值（例如 $10^{-14}$ s）开始并迭代地加倍来找到，直到 $f(b) > 0$。由于 $\\Lambda(\\tau)$ 是无界且递增的，这保证会终止。\n5.  对区间 $[a, b]$ 应用二分法。该区间被反复对半，始终保留包含根的子区间，直到区间宽度小于指定的容差。这将产生碰撞时间 $\\tau$ 的高精度数值。\n\n此程序将应用于所有四个测试用例，使用提供的物理常数：$\\hbar=1.054571817\\times 10^{-34}$ $\\mathrm{J\\cdot s}$，$q=1.602176634\\times 10^{-19}$ $\\mathrm{C}$，以及 $m_e=9.1093837015\\times 10^{-31}$ $\\mathrm{kg}$。除非另有说明，电子有效质量为 $m^\\star = 0.26\\,m_e$。\n\n情况 1：恒定电场 $E(t)=E_0=1.0\\times 10^5$ $\\mathrm{V/m}$。\n$t_0=0$ $\\mathrm{s}$，$k_0=1.0\\times 10^8$ $\\mathrm{m^{-1}}$，$A(t)=E_0 t$。波矢为 $k(s) = k_0 - \\frac{qE_0}{\\hbar}s$。\n\n情况 2：零电场 $E(t)=0$。\n$t_0=0$ $\\mathrm{s}$，$k_0=5.0\\times 10^8$ $\\mathrm{m^{-1}}$，$A(t)=0$。波矢是恒定的，$k(s) = k_0$，导致散射率恒定。积分 $\\Lambda(\\tau)$ 简化为 $\\nu(\\varepsilon(k_0))\\tau$，从而可以得到 $\\tau$ 的解析解，这可作为数值方法的验证。\n\n情况 3：正弦电场 $E(t)=E_1\\sin(\\omega t)$。\n$t_0=5.0\\times 10^{-13}$ $\\mathrm{s}$，$k_0=1.0\\times 10^8$ $\\mathrm{m^{-1}}$，$A(t)=-\\frac{E_1}{\\omega}\\cos(\\omega t)$。波矢为 $k(t_0+s) = k_0 + \\frac{qE_1}{\\hbar\\omega}(\\cos(\\omega(t_0+s)) - \\cos(\\omega t_0))$。\n\n情况 4：线性斜坡电场 $E(t)=\\beta t$。\n$t_0=0$ $\\mathrm{s}$，$k_0=0$ $\\mathrm{m^{-1}}$，$A(t)=\\frac{1}{2}\\beta t^2$。波矢为 $k(s) = -\\frac{q\\beta}{2\\hbar}s^2$。能量变为 $\\varepsilon(s) \\propto s^4$，$\\Lambda(\\tau)$ 变为 $\\tau$ 的多项式，这可以用专门的多项式求根器求解，但通用的二分法是稳健且足够的。\n\n实现将对所有四个情况遵循此数值程序，以确保与问题要求的一致性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Main function to solve for the collision times for all test cases.\n    \"\"\"\n    # Physical constants\n    HBAR = 1.054571817e-34  # J.s\n    Q = 1.602176634e-19     # C\n    M_E = 9.1093837015e-31  # kg\n\n    def compute_tau(case_params):\n        \"\"\"\n        Computes the collision time tau for a single set of parameters.\n        \"\"\"\n        t0, k0, m_star_ratio, A_func, nu0, alpha, xi = case_params\n        \n        m_star = m_star_ratio * M_E\n        target_lambda = -np.log(xi)\n\n        # Pre-compute A(t0) for efficiency\n        A_t0 = A_func(t0)\n\n        def k_of_t_abs(t_abs):\n            \"\"\"Electron wavevector as a function of absolute time t_abs.\"\"\"\n            return k0 - (Q / HBAR) * (A_func(t_abs) - A_t0)\n\n        def epsilon_of_t_abs(t_abs):\n            \"\"\"Electron energy as a function of absolute time t_abs.\"\"\"\n            k_val = k_of_t_abs(t_abs)\n            return (HBAR**2 * k_val**2) / (2 * m_star)\n\n        def nu_integrand(s):\n            \"\"\"\n            Scattering rate as a function of time 's' elapsed since t0.\n            This is the integrand for the cumulative hazard integral.\n            \"\"\"\n            t_abs = t0 + s\n            energy = epsilon_of_t_abs(t_abs)\n            return nu0 + alpha * energy\n\n        def cumulative_hazard(tau):\n            \"\"\"\n            Computes the cumulative hazard Lambda(tau) by numerical integration.\n            \"\"\"\n            if tau == 0:\n                return 0.0\n            # Use scipy.integrate.quad for high-precision numerical integration\n            result, _ = quad(nu_integrand, 0, tau, epsabs=1e-12, epsrel=1e-12)\n            return result\n\n        def root_function(tau):\n            \"\"\"\n            The function f(tau) = Lambda(tau) - target_lambda, whose root is sought.\n            \"\"\"\n            return cumulative_hazard(tau) - target_lambda\n\n        # --- Bisection Method for Root Finding ---\n        \n        # 1. Find a valid bracket [a, b] such that f(a) * f(b)  0.\n        # Since Lambda(0) = 0 and target_lambda > 0, f(0) is always negative.\n        # So we can set a = 0.\n        a = 0.0\n        \n        # Find an upper bound 'b' by starting with a small guess and expanding.\n        # A typical scattering time is ~10-100 fs, so start with 10 fs.\n        b = 1e-14\n        # Expand the bracket until root_function(b) becomes positive\n        while root_function(b)  0:\n            b *= 2.0\n            # Safety break to avoid potential infinite loops with unusual parameters\n            if b > 1e-9: # 1 ns is a very long free-flight time\n                raise RuntimeError(\"Failed to find upper bracket for bisection below 1 ns.\")\n        \n        # 2. Use SciPy's bisection solver to find the root tau.\n        # A tight tolerance ensures high precision.\n        tau = bisect(root_function, a, b, xtol=1e-21)\n        \n        return tau\n\n    # Define the four test cases as specified in the problem statement.\n    # Each case is a tuple: (t0, k0, m_star_ratio, A_func, nu0, alpha, xi)\n    \n    # Case 1: Constant field\n    E0_1 = 1.0e5  # V/m\n    case1_params = (\n        0.0,                    # t0 (s)\n        1.0e8,                  # k0 (m^-1)\n        0.26,                   # m_star / m_e\n        lambda t: E0_1 * t,     # A(t)\n        1.0e11,                 # nu0 (s^-1)\n        2.0e31,                 # alpha (s^-1 J^-1)\n        0.37                    # xi\n    )\n\n    # Case 2: Zero field\n    case2_params = (\n        0.0,                     # t0 (s)\n        5.0e8,                   # k0 (m^-1)\n        0.26,                    # m_star / m_e\n        lambda t: 0.0,           # A(t)\n        8.0e10,                  # nu0 (s^-1)\n        1.0e31,                  # alpha (s^-1 J^-1)\n        0.01                     # xi\n    )\n    \n    # Case 3: Sinusoidal field\n    E1_3 = 2.0e5                # V/m\n    omega_3 = 2 * np.pi * 1.0e12  # rad/s\n    case3_params = (\n        5.0e-13,                # t0 (s)\n        1.0e8,                  # k0 (m^-1)\n        0.26,                   # m_star / m_e\n        lambda t: -(E1_3 / omega_3) * np.cos(omega_3 * t),  # A(t)\n        1.2e11,                 # nu0 (s^-1)\n        2.0e31,                 # alpha (s^-1 J^-1)\n        0.50                    # xi\n    )\n\n    # Case 4: Linearly ramping field\n    beta_4 = 1.0e16             # V/(m.s)\n    case4_params = (\n        0.0,                    # t0 (s)\n        0.0,                    # k0 (m^-1)\n        0.26,                   # m_star / m_e\n        lambda t: 0.5 * beta_4 * t**2, # A(t)\n        1.0e11,                 # nu0 (s^-1)\n        3.0e31,                 # alpha (s^-1 J^-1)\n        0.999                   # xi\n    )\n\n    test_cases = [case1_params, case2_params, case3_params, case4_params]\n\n    results = []\n    for case in test_cases:\n        tau_result = compute_tau(case)\n        results.append(tau_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.6e}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从模拟得到的粒子运动轨迹中提取宏观物理量是EMC方法的关键目标，而电流密度是其中最重要的物理量之一。本练习将探讨两种计算电流密度的方法：基于跨面通量的方法和基于单元内速度平均的方法。通过比较这两种方法的计算结果，你将深入理解电荷守恒在数值模拟中的重要性，并掌握检验模拟结果一致性的关键技术 ()。",
            "id": "3743692",
            "problem": "考虑一个具有均匀横截面积的一维半导体板，其中，系综蒙特卡罗（Ensemble Monte Carlo, EMC）模拟推进一组具有指定物理电荷权重的代表性超粒子，并跟踪它们穿越位于位置 $x$ 的一个假想平面的情况。目标是使用基于第一性原理的两种等效定义来计算沿输运方向的电流密度，并在特定条件下量化它们的一致性。\n\n基本原理：\n- 电荷连续性方程的微分形式 $\\partial \\rho / \\partial t + \\nabla \\cdot \\mathbf{J} = 0$，它将电荷密度 $\\rho$ 的时间变化率与电流密度 $\\mathbf{J}$ 的散度联系起来。\n- 电流密度 $\\mathbf{J}$ 定义为单位面积单位时间内的电荷通量；具体来说，通过垂直于 $x$ 方向的平面的分量 $J_x$ 是指单位面积单位时间内穿过该平面的净电荷。\n- 在离散粒子表示中，每个超粒子携带一个物理电荷 $q_{\\text{p}}$，控制体积内的体平均电流密度是电荷加权的平均载流子速度除以该控制体积。\n\n任务：\n1. 从上述基本原理出发，在你的解决方案中推导出以下操作公式：\n   - 使用在持续时间为 $\\Delta t$ 的时间窗口内、横截面积为 $A$ 的情况下，穿越位置 $x$ 处平面的净次数计算出的表面通量估计值 $J_x^{\\text{surf}}(x,t)$。\n   - 使用分配给以 $x$ 为中心、宽度为 $\\Delta x$ 的单元的电荷以及该单元内载流子速度 $v_{x}$ 计算出的体平均估计值 $J_x^{\\text{vol}}(x,t)$。\n2. 实现一个程序，该程序对下文定义的每个测试用例计算 $J_x^{\\text{surf}}$ 和 $J_x^{\\text{vol}}$，然后输出一个由下式定义的无量纲归一化差异 $\\delta$：\n   $$\\delta = \\frac{\\left| J_x^{\\text{surf}} - J_x^{\\text{vol}} \\right|}{\\max\\left( \\left| J_x^{\\text{surf}} \\right|, \\left| J_x^{\\text{vol}} \\right|, \\varepsilon \\right)}$$\n   其中 $\\varepsilon$ 是一个正常数，取值为 $\\varepsilon = 10^{-30}$，以避免在两个估计值都为零时出现除以零的情况。量 $\\delta$ 是无量纲的，应表示为浮点数。单独的电流密度 $J_x^{\\text{surf}}$ 和 $J_x^{\\text{vol}}$ 本身的单位是安培每平方米 (A/m$^2$)，但你不需要直接输出它们。\n3. 在你的解决方案中解释两种估计值达成一致所需的一致性条件，包括对时间步长、电荷权重和分配方案的约束。\n\n测试套件：\n对于每个测试用例 $i$，给定以下参数，均采用国际单位制（SI）：\n- 横截面积 $A$，单位 $\\text{m}^2$。\n- 单元宽度 $\\Delta x$，单位 $\\text{m}$。\n- 时间步长 $\\Delta t$，单位 $\\text{s}$。\n- 元电荷 $q$，单位 $\\text{C}$。\n- 表面通量电荷权重 $w_{\\text{surf}}$（$q$ 的无量纲乘数）。\n- 体平均电荷权重 $w_{\\text{vol}}$（$q$ 的无量纲乘数）。\n- 在持续时间为 $\\Delta t$ 的时间窗口内，位于位置 $x$ 的平面上从左到右（$N_{\\rightarrow}$）和从右到左（$N_{\\leftarrow}$）的穿越次数。\n- 分配给以相同 $x$ 为中心的宽度为 $\\Delta x$ 的单元内的一系列粒子在 $x$ 方向上的速度 $[v_{x,1}, v_{x,2}, \\dots, v_{x,N}]$，单位 $\\text{m/s}$。\n\n你将使用最近邻网格点（Nearest-Grid-Point, NGP）分配方案进行体平均估计，这意味着所有提供的速度都完全属于指定的单元。\n\n四个测试用例是：\n- 案例 1（理想情况，一致性数据）：\n  - $A = 10^{-12}$, $\\Delta x = 10^{-7}$, $\\Delta t = 2.5 \\times 10^{-13}$, $q = 1.602176634 \\times 10^{-19}$, $w_{\\text{surf}} = 10^{5}$, $w_{\\text{vol}} = 10^{5}$,\n  - $N_{\\rightarrow} = 1$, $N_{\\leftarrow} = 0$,\n  - $[v_{x,i}] = [10^{5}, 10^{5}, 10^{5}, 10^{5}]$。\n- 案例 2（双向净电流为零）：\n  - $A = 10^{-12}$, $\\Delta x = 10^{-7}$, $\\Delta t = 10^{-13}$, $q = 1.602176634 \\times 10^{-19}$, $w_{\\text{surf}} = 10^{5}$, $w_{\\text{vol}} = 10^{5}$,\n  - $N_{\\rightarrow} = 5$, $N_{\\leftarrow} = 5$,\n  - $[v_{x,i}] = [10^{5}, -10^{5}, 2 \\times 10^{5}, -2 \\times 10^{5}]$。\n- 案例 3（时间步长过大导致穿越计数不足）：\n  - $A = 10^{-12}$, $\\Delta x = 10^{-7}$, $\\Delta t = 10^{-12}$, $q = 1.602176634 \\times 10^{-19}$, $w_{\\text{surf}} = 10^{5}$, $w_{\\text{vol}} = 10^{5}$,\n  - $N_{\\rightarrow} = 1$, $N_{\\leftarrow} = 0$,\n  - $[v_{x,i}] = [10^{5}, 10^{5}, 10^{5}, 10^{5}]$。\n- 案例 4（方法间权重不一致）：\n  - $A = 10^{-12}$, $\\Delta x = 10^{-7}$, $\\Delta t = 2.5 \\times 10^{-13}$, $q = 1.602176634 \\times 10^{-19}$, $w_{\\text{surf}} = 10^{5}$, $w_{\\text{vol}} = 2 \\times 10^{5}$,\n  - $N_{\\rightarrow} = 1$, $N_{\\leftarrow} = 0$,\n  - $[v_{x,i}] = [10^{5}, 10^{5}, 10^{5}, 10^{5}]$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含案例1到4的四个 $\\delta$ 值，格式为逗号分隔的列表，并用方括号括起来，例如 $[d_1,d_2,d_3,d_4]$，其中每个 $d_i$ 是一个浮点数。\n\n所有计算都必须使用提供的数值进行。不需要也不允许外部输入。",
            "solution": "该问题要求基于电荷输运的基本原理，计算和比较一维半导体模拟中两种不同的电流密度估计量。对问题陈述的验证已确认其科学合理性、完整性和清晰性。我们现在开始解答。\n\n第一步是推导两种电流密度估计量的操作公式。\n\n**1. 表面通量电流密度估计值 $J_x^{\\text{surf}}$ 的推导**\n\n电流密度分量 $J_x$ 被定义为单位时间内穿过垂直于 $x$ 方向的单位面积平面的净电荷。在系综蒙特卡罗（EMC）模拟中，电荷由离散的超粒子表示。每个超粒子代表大量物理载流子，并被赋予一个物理电荷 $q_{\\text{p}}$。对于表面通量计算，此电荷为元电荷 $q$ 与无量纲权重 $w_{\\text{surf}}$ 的乘积，即 $q_{\\text{p}} = w_{\\text{surf}} \\cdot q$。\n\n在一个持续时间为 $\\Delta t$ 的模拟时间窗口内，我们已知有 $N_{\\rightarrow}$ 个超粒子沿正方向（从左到右）穿过位置 $x$ 处的平面，有 $N_{\\leftarrow}$ 个超粒子沿负方向（从右到左）穿过该平面。\n\n沿正方向穿过的总电荷为 $Q_{\\rightarrow} = N_{\\rightarrow} \\cdot q_{\\text{p}} = N_{\\rightarrow} \\cdot w_{\\text{surf}} \\cdot q$。\n沿负方向穿过的总电荷为 $Q_{\\leftarrow} = N_{\\leftarrow} \\cdot q_{\\text{p}} = N_{\\leftarrow} \\cdot w_{\\text{surf}} \\cdot q$。\n\n沿正 $x$ 方向穿过该平面的净电荷是这两个量之差：\n$$ \\Delta Q_{\\text{net}} = Q_{\\rightarrow} - Q_{\\leftarrow} = (N_{\\rightarrow} - N_{\\leftarrow}) \\cdot w_{\\text{surf}} \\cdot q $$\n\n该净电荷在时间间隔 $\\Delta t$ 内穿过指定的横截面积 $A$。将净电荷除以面积和时间的乘积，即可得到通过该表面的平均电流密度。因此，表面通量估计值 $J_x^{\\text{surf}}$ 为：\n$$ J_x^{\\text{surf}} = \\frac{\\Delta Q_{\\text{net}}}{A \\cdot \\Delta t} = \\frac{(N_{\\rightarrow} - N_{\\leftarrow}) \\cdot w_{\\text{surf}} \\cdot q}{A \\cdot \\Delta t} $$\n\n**2. 体平均电流密度估计值 $J_x^{\\text{vol}}$ 的推导**\n\n第二个基本定义将电流密度与体积内电荷载流子的运动联系起来。电流密度 $\\mathbf{J}$ 可以表示为电荷密度 $\\rho$ 和漂移速度 $\\mathbf{v}_d$ 的乘积，即 $\\mathbf{J} = \\rho \\mathbf{v}_d$。对于离散电荷载流子的集合，这等效于其各自电荷-速度乘积之和，并在一个控制体积 $V$ 上进行平均。\n\n对于一个宽度为 $\\Delta x$、横截面积为 $A$ 的一维单元，其体积为 $V = A \\cdot \\Delta x$。如果在给定时刻，该单元内有 $N$ 个超粒子，则 $x$ 方向的体平均电流密度为：\n$$ J_x^{\\text{vol}} = \\frac{1}{V} \\sum_{i=1}^{N} q_{\\text{p},i} v_{x,i} $$\n其中 $q_{\\text{p},i}$ 和 $v_{x,i}$ 分别是第 $i$ 个超粒子的电荷和 $x$ 方向的速度。\n\n根据问题陈述，此估计的物理电荷为 $q_{\\text{p}} = w_{\\text{vol}} \\cdot q$，并假定所有粒子都相同。问题使用了最近邻网格点（NGP）分配方案，并提供了一个包含分配给该单元的所有超粒子的 $N$ 个速度列表 $[v_{x,1}, v_{x,2}, \\dots, v_{x,N}]$。\n\n将 $V = A \\cdot \\Delta x$ 和 $q_{\\text{p},i} = w_{\\text{vol}} \\cdot q$ 代入求和公式，得到体平均估计值 $J_x^{\\text{vol}}$ 的操作公式：\n$$ J_x^{\\text{vol}} = \\frac{1}{A \\cdot \\Delta x} \\sum_{i=1}^{N} (w_{\\text{vol}} \\cdot q) v_{x,i} = \\frac{w_{\\text{vol}} \\cdot q}{A \\cdot \\Delta x} \\sum_{i=1}^{N} v_{x,i} $$\n\n**3. 一致性条件**\n\n这两种估计量 $J_x^{\\text{surf}}$ 和 $J_x^{\\text{vol}}$ 是同一物理量的离散近似。它们的一致性取决于离散数值框架内电荷守恒原理的满足情况。基于通量的测量与体平均测量的等效性是散度定理的一种离散形式，与器件物理学中的 Ramo-Shockley-Pellegrini 定理密切相关。一致性的关键条件如下：\n\n- **一致的电荷表示**：归属于一个超粒子的物理电荷必须是唯一的，且与测量方法无关。单个超粒子不能有两个不同的电荷。因此，两种估计量中使用的电荷权重必须相同：$w_{\\text{surf}} = w_{\\text{vol}}$。测试用例 4 表明，违反此条件会导致直接且可预测的差异。\n\n- **统计上一致的采样和时间步长标准**：用于两种估计的数据——$\\Delta t$ 时间内的粒子穿越数和 $\\Delta x$ 范围内的粒子状态——必须代表载流子系综在统计上一致的样本。对于一个均匀的载流子分布，其数密度为 $n$，平均速度为 $\\bar{v}_x$，一个单元内的载流子数量为 $N_{\\text{cell}} = n A \\Delta x$，而在时间 $\\Delta t$ 内预期穿过一个边界的数量为 $N_{\\text{cross}} = n A |\\bar{v}_x| \\Delta t$。这意味着存在一个一致性关系：$N_{\\text{cross}} = N_{\\text{cell}} \\cdot \\frac{|\\bar{v}_x| \\Delta t}{\\Delta x}$。如果模拟数据违反了此关系（如测试用例 3 所示），则估计量将不一致。导致这种违规的一个常见原因是时间步长 $\\Delta t$ 相对于单元渡越时间 $\\tau_{\\text{transit}} = \\Delta x / |\\bar{v}_x|$ 过大。如果 $\\Delta t \\gtrsim \\tau_{\\text{transit}}$，一个简单的穿越计数器算法可能会失效，例如，可能会漏掉在一个时间步内重新穿越边界的粒子，或者错误地归因于跳过整个单元的粒子的电流。因此，算法一致性的一个关键条件是 $\\Delta t \\ll \\tau_{\\text{transit}}$。\n\n- **电荷守恒的数值方案**：用于将粒子量（如电荷和电流）分配到空间网格的底层算法必须是电荷守恒的。也就是说，在体积积分量（如电荷密度）中计算的总电荷必须与在面积分量（如电流通量）中计算的总电荷一致。问题中指定的最近邻网格点（NGP）方案是电荷守恒方案中最简单的例子。\n\n以下程序实现了推导出的公式，并基于这些原理为每个测试用例计算归一化差异 $\\delta$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the electric current density using two equivalent definitions\n    and quantifies their agreement for given test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, consistent data)\n        {\n            \"A\": 1e-12, \"dx\": 1e-7, \"dt\": 2.5e-13, \"q\": 1.602176634e-19,\n            \"w_surf\": 1e5, \"w_vol\": 1e5,\n            \"N_right\": 1, \"N_left\": 0,\n            \"velocities\": [1e5, 1e5, 1e5, 1e5]\n        },\n        # Case 2 (zero net current both ways)\n        {\n            \"A\": 1e-12, \"dx\": 1e-7, \"dt\": 1e-13, \"q\": 1.602176634e-19,\n            \"w_surf\": 1e5, \"w_vol\": 1e5,\n            \"N_right\": 5, \"N_left\": 5,\n            \"velocities\": [1e5, -1e5, 2e5, -2e5]\n        },\n        # Case 3 (time-step too large leading to undercounted crossings)\n        {\n            \"A\": 1e-12, \"dx\": 1e-7, \"dt\": 1e-12, \"q\": 1.602176634e-19,\n            \"w_surf\": 1e5, \"w_vol\": 1e5,\n            \"N_right\": 1, \"N_left\": 0,\n            \"velocities\": [1e5, 1e5, 1e5, 1e5]\n        },\n        # Case 4 (weight inconsistency between methods)\n        {\n            \"A\": 1e-12, \"dx\": 1e-7, \"dt\": 2.5e-13, \"q\": 1.602176634e-19,\n            \"w_surf\": 1e5, \"w_vol\": 2e5,\n            \"N_right\": 1, \"N_left\": 0,\n            \"velocities\": [1e5, 1e5, 1e5, 1e5]\n        }\n    ]\n\n    results = []\n    epsilon = 1e-30\n\n    for case in test_cases:\n        A = case[\"A\"]\n        dx = case[\"dx\"]\n        dt = case[\"dt\"]\n        q = case[\"q\"]\n        w_surf = case[\"w_surf\"]\n        w_vol = case[\"w_vol\"]\n        N_right = case[\"N_right\"]\n        N_left = case[\"N_left\"]\n        velocities = case[\"velocities\"]\n\n        # Calculate the surface-flux estimate J_surf\n        # J_surf = (Net Crossings * Charge per Particle) / (Area * Time)\n        net_crossings = N_right - N_left\n        q_p_surf = w_surf * q\n        \n        # Denominator check to avoid division by zero runtime error\n        if A * dt == 0:\n            j_surf = 0.0 # Or some other appropriate handling\n        else:\n            j_surf = (net_crossings * q_p_surf) / (A * dt)\n\n        # Calculate the volume-averaged estimate J_vol\n        # J_vol = (Charge per Particle / (Area * Cell Width)) * Sum of Velocities\n        sum_of_velocities = np.sum(velocities)\n        q_p_vol = w_vol * q\n\n        # Denominator check\n        if A * dx == 0:\n            j_vol = 0.0\n        else:\n            j_vol = (q_p_vol / (A * dx)) * sum_of_velocities\n            \n        # Compute the dimensionless normalized difference delta\n        abs_diff = abs(j_surf - j_vol)\n        max_abs = max(abs(j_surf), abs(j_vol), epsilon)\n        \n        delta = abs_diff / max_abs\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在模拟真实半导体器件时，载流子的运动会改变电场分布，而变化的电场又反过来影响载流子的运动，这是一个自洽的耦合过程。本练习聚焦于EMC与泊松方程求解器耦合时的核心挑战：如何选择合适的电势更新时间步长$ \\Delta t_{\\phi} $以保证数值稳定性和计算精度。你将学习分析等离子体振荡和介电弛豫等物理现象，并推导出确保模拟稳定可靠的关键判据 ()。",
            "id": "3743667",
            "problem": "要求您形式化并分析在耦合的系综蒙特卡洛 (EMC) – 泊松方程模拟半导体载流子输运过程中，每隔 $ \\Delta t_{\\phi} $ 更新一次静电势所带来的稳定性和准确性影响。分析必须基于第一性原理，并得出程序可以根据给定物理参数进行评估的可计算判据。考虑一个一维小信号微扰机制下的均匀半导体，其电子数密度为 $ n $，导带有效质量为 $ m^{\\star} $，动量弛豫时间为 $ \\tau $，相对介电常数为 $ \\varepsilon_{r} $。使用以下经过充分检验的基本模型：\n\n- 弛豫时间近似下的牛顿第二定律：$ m^{\\star} \\, \\dfrac{dv}{dt} = q E - \\dfrac{m^{\\star}}{\\tau} v $，其中 $ q $ 是元电荷，$ v $ 是平均载流子速度。\n- 高斯定律：$ \\nabla \\cdot E = \\dfrac{\\rho}{\\varepsilon} $，其中 $ \\rho $ 是电荷密度，$ \\varepsilon = \\varepsilon_{r} \\varepsilon_{0} $ 是介电常数。\n- 连续性方程：$ \\dfrac{\\partial \\rho}{\\partial t} + \\nabla \\cdot J = 0 $，其中 $ J $ 是电流密度。\n- 德鲁德电导模型：$ J = \\sigma E $，其中 $ \\sigma = q n \\mu $ 且迁移率 $ \\mu = \\dfrac{q \\tau}{m^{\\star}} $。\n\n使用这些模型，推导出介电弛豫时间 $ \\tau_{d} = \\dfrac{\\varepsilon}{\\sigma} $ 和（无阻尼）等离子体角频率 $ \\omega_{p} = \\sqrt{\\dfrac{n q^{2}}{\\varepsilon m^{\\star}}} $。将 EMC-泊松耦合建模为对静电势的零阶保持：电势（及其对应的电场）在以 $ \\Delta t_{\\phi} $ 分隔的离散时刻进行更新，并在更新间隔之间保持恒定。\n\n定义以下可计算的度量和判据：\n\n1. 介电弛豫时间 $ \\tau_{d} $，单位为秒。\n2. 等离子体角频率 $ \\omega_{p} $，单位为弧度/秒。\n3. 在一个保持间隔内，对于指数弛豫的微扰，其最坏情况下的逐点相对误差界。假设连续更新的电势遵循 $ \\phi(t) \\propto e^{-t/\\tau_{d}} $，而零阶保持器在 $ \\Delta t_{\\phi} $ 时间内使 $ \\phi $ 保持恒定。使用此误差界\n   $$ e_{\\mathrm{rel}} = 1 - e^{-\\Delta t_{\\phi} / \\tau_{d}}. $$\n4. 受奈奎斯特-香农采样定理启发的采样稳定性判据：为了在 EMC-泊松耦合中无混叠地解析等离子体振荡，要求\n   $$ \\Delta t_{\\phi}  \\frac{\\pi}{\\omega_{p}}. $$\n   定义一个布尔值 $ \\mathrm{stable\\_sampling} $，当且仅当此严格不等式成立时为真。\n5. 相对于用户指定的容差 $ \\varepsilon_{\\mathrm{tol}} $（无量纲小数）的准确性判据。定义一个布尔值 $ \\mathrm{meets\\_accuracy} $，当且仅当 $ e_{\\mathrm{rel}} \\le \\varepsilon_{\\mathrm{tol}} $ 时为真。\n6. 一个推荐的势更新间隔的安全选择，该选择在保守裕度下同时考虑了碰撞、弛豫和采样尺度：\n   $$ \\Delta t_{\\phi,\\mathrm{safe}} = \\min\\!\\left( -\\tau_{d} \\ln(1 - \\varepsilon_{\\mathrm{tol}}), \\; \\frac{\\pi}{10 \\, \\omega_{p}}, \\; 0.2 \\, \\tau \\right), $$\n   以秒为单位返回。\n\n您的程序必须实现上述量的计算，使用常数 $ q = 1.602176634 \\times 10^{-19} \\, \\mathrm{C} $，$ \\varepsilon_{0} = 8.8541878128 \\times 10^{-12} \\, \\mathrm{F/m} $，以及自由电子质量 $ m_{e} = 9.1093837015 \\times 10^{-31} \\, \\mathrm{kg} $，并且必须通过其与 $ m_e $ 的比率 $ m^{\\star}/m_{e} $ 来接受导带有效质量。\n\n测试套件：\n为以下参数集提供结果，每个参数集指定为一个元组 $ (n, \\tau, m^{\\star}/m_{e}, \\varepsilon_{r}, \\Delta t_{\\phi}, \\varepsilon_{\\mathrm{tol}}) $，其中所有时间单位为秒，密度单位为 $ \\mathrm{m}^{-3} $：\n- 案例1（理想情况，$ \\Delta t_{\\phi} $ 相对于 $ \\tau $ 和 $ \\tau_{d} $ 较小）：$ (1.0 \\times 10^{21}, \\; 1.0 \\times 10^{-13}, \\; 0.26, \\; 11.7, \\; 1.0 \\times 10^{-15}, \\; 0.01) $。\n- 案例2（边缘情况，高密度，大 $ \\Delta t_{\\phi} $）：$ (1.0 \\times 10^{24}, \\; 1.0 \\times 10^{-14}, \\; 0.26, \\; 11.7, \\; 5.0 \\times 10^{-13}, \\; 0.10) $。\n- 案例3（接近采样极限的边界情况）：$ (1.0 \\times 10^{20}, \\; 1.0 \\times 10^{-12}, \\; 0.26, \\; 11.7, \\; 3.0 \\times 10^{-11}, \\; 0.05) $。\n- 案例4（更新间隔等于碰撞时间）：$ (5.0 \\times 10^{22}, \\; 2.0 \\times 10^{-13}, \\; 0.26, \\; 11.7, \\; 2.0 \\times 10^{-13}, \\; 0.05) $。\n\n所需输出：\n对于每个测试案例，计算并返回列表 $ [\\tau_{d}, \\, \\omega_{p}, \\, e_{\\mathrm{rel}}, \\, \\mathrm{stable\\_sampling}, \\, \\mathrm{meets\\_accuracy}, \\, \\Delta t_{\\phi,\\mathrm{safe}}] $。您的程序应生成单行输出，该输出包含一个由各案例结果组成的、以逗号分隔的列表，并用方括号括起来。也就是说，输出应为表示列表的列表的单行文本，每个内部列表均按上述指定顺序排列。所有时间单位必须是秒，角频率单位是弧度/秒。容差和误差表示为小数（而非百分比）。",
            "solution": "经评估，用户提供的问题陈述是**有效的**。它在科学上基于半导体物理和数值分析的既定原理，其定义和数据完整、一致，问题提法得当，且其表述是客观的。该问题要求对耦合的系综蒙特卡洛 (EMC) – 泊松方程模拟的稳定性和准确性判据进行形式化，这是计算器件建模中的一项标准且关键的任务。所要求的计算基于经典模型，并且定义清晰。\n\n求解过程首先从给定条件推导出必要的物理参数，然后基于基本原理计算六个指定的度量指标。\n\n使用指定的以下物理常数：\n- 元电荷：$q = 1.602176634 \\times 10^{-19} \\, \\mathrm{C}$\n- 真空介电常数：$\\varepsilon_{0} = 8.8541878128 \\times 10^{-12} \\, \\mathrm{F/m}$\n- 自由电子质量：$m_{e} = 9.1093837015 \\times 10^{-31} \\, \\mathrm{kg}$\n\n根据输入参数，我们首先确定材料的特定属性：\n- 半导体的绝对介电常数为 $\\varepsilon = \\varepsilon_{r} \\varepsilon_{0}$，其中 $\\varepsilon_{r}$ 是给定的相对介电常数。\n- 电子有效质量为 $m^{\\star} = (m^{\\star}/m_{e}) m_{e}$，由提供的质量比计算得出。\n- 直流电导率 $\\sigma$ 根据德鲁德模型推导。迁移率为 $\\mu = q \\tau / m^{\\star}$，电导率为 $\\sigma = n q \\mu$，其中 $n$ 是电子数密度，$τ$ 是动量弛豫时间。将它们结合起来得到 $\\sigma = \\dfrac{n q^{2} \\tau}{m^{\\star}}$。\n\n有了这些参数，我们现在可以定义和计算六个所需的度量指标。\n\n1.  **介电弛豫时间, $\\tau_{d}$**：该时间常数表征了导电介质中净电荷不平衡的指数衰减过程。它源于连续性方程 $\\nabla \\cdot \\vec{J} + \\dfrac{\\partial \\rho}{\\partial t} = 0$ 和高斯定律 $\\nabla \\cdot \\vec{E} = \\rho / \\varepsilon$ 的结合。假设在均匀介质中电导率 $\\sigma$ 是常数，并使用欧姆定律 $\\vec{J} = \\sigma \\vec{E}$，连续性方程变为 $\\sigma (\\nabla \\cdot \\vec{E}) + \\dfrac{\\partial \\rho}{\\partial t} = 0$。代入高斯定律，得到一个关于电荷密度 $\\rho$ 的一阶微分方程：$\\dfrac{\\sigma}{\\varepsilon}\\rho + \\dfrac{\\partial \\rho}{\\partial t} = 0$。其解为 $\\rho(t) = \\rho(0) e^{-t/\\tau_d}$，其中介电弛豫时间由下式给出：\n    $$ \\tau_{d} = \\frac{\\varepsilon}{\\sigma} = \\frac{\\varepsilon m^{\\star}}{n q^{2} \\tau} $$\n\n2.  **等离子体角频率, $\\omega_{p}$**：这是载流子电荷密度（等离子体）在忽略阻尼效应时，对微小静电扰动响应的自然振荡频率。它是通过将牛顿第二定律（代表惯性）与高斯定律（代表恢复力）耦合推导出来的。对于电荷片的一维位移 $x$，牛顿定律为 $m^{\\star} \\dfrac{d^2x}{dt^2} = qE$。该位移产生表面电荷密度，导致电场 $E = - (n q / \\varepsilon) x$。运动方程变为 $m^{\\star} \\dfrac{d^2x}{dt^2} = - \\dfrac{n q^2}{\\varepsilon} x$，这是一个简谐振荡方程。这种无阻尼振荡的角频率为：\n    $$ \\omega_{p} = \\sqrt{\\frac{n q^{2}}{\\varepsilon m^{\\star}}} $$\n\n3.  **相对误差界, $e_{\\mathrm{rel}}$**：在耦合的 EMC-泊松模拟中，电场在时间间隔 $\\Delta t_{\\phi}$ 内保持恒定。在此期间，真实系统中的电荷扰动会发生弛豫。如果一个扰动按 $f(t) \\propto e^{-t/\\tau_d}$ 指数衰减，零阶保持近似会引入误差。在间隔开始时，保持值为 $f(0)$。在间隔结束时，真实值为 $f(\\Delta t_{\\phi}) = f(0) e^{-\\Delta t_{\\phi}/\\tau_d}$。在间隔结束时的逐点相对误差代表了单调衰减的最坏情况误差，其值为 $\\frac{|f(0) - f(\\Delta t_{\\phi})|}{|f(0)|}$。这给出了指定的误差界：\n    $$ e_{\\mathrm{rel}} = 1 - e^{-\\Delta t_{\\phi} / \\tau_{d}} $$\n\n4.  **采样稳定性, $\\mathrm{stable\\_sampling}$**：奈奎斯特-香农采样定理规定，为了完美重构一个信号，采样频率 $f_s$ 必须严格大于信号中最高频率 $f_{\\mathrm{max}}$ 的两倍。在 EMC-泊松循环的背景下，频率为 $\\omega_p$ 的等离子体振荡是一个关键动态。这里的“采样”是电势的更新，采样间隔为 $\\Delta t_\\phi$，采样频率为 $f_s = 1/\\Delta t_\\phi$。物理频率为 $f_p = \\omega_p / (2\\pi)$。稳定性判据是 $f_s  2 f_p$，这可转换为 $\\frac{1}{\\Delta t_{\\phi}}  2 \\frac{\\omega_p}{2\\pi} = \\frac{\\omega_p}{\\pi}$。为时间步长整理后得到严格不等式：\n    $$ \\Delta t_{\\phi}  \\frac{\\pi}{\\omega_{p}} $$\n    布尔值 $\\mathrm{stable\\_sampling}$ 当且仅当此条件成立时为真。\n\n5.  **准确性判据, $\\mathrm{meets\\_accuracy}$**：这是一个直接的检查，用于确定计算出的相对误差界 $e_{\\mathrm{rel}}$ 是否在用户指定的容差 $\\varepsilon_{\\mathrm{tol}}$ 之内。这是控制数值误差的标准程序。布尔值 $\\mathrm{meets\\_accuracy}$ 当且仅当以下条件成立时为真：\n    $$ e_{\\mathrm{rel}} \\le \\varepsilon_{\\mathrm{tol}} $$\n\n6.  **安全的势更新间隔, $\\Delta t_{\\phi,\\mathrm{safe}}$**：该度量通过考虑三个不同的物理和数值约束，为 $\\Delta t_{\\phi}$ 提供了一个实用且保守的建议。最安全的选择是这些约束所施加的时间尺度中的最小值。\n    -   *准确性约束*：为确保 $e_{\\mathrm{rel}} \\le \\varepsilon_{\\mathrm{tol}}$，我们必须有 $1 - e^{-\\Delta t_{\\phi}/\\tau_d} \\le \\varepsilon_{\\mathrm{tol}}$。反解这个不等式得到 $\\Delta t_{\\phi} \\le -\\tau_{d} \\ln(1 - \\varepsilon_{\\mathrm{tol}})$。\n    -   *稳定性约束*：为了稳健地满足等离子体振荡的奈奎斯特准则，引入了一个安全裕度。选择采样频率为奈奎斯特极限的10倍，即 $f_s  10 \\times (2 f_p)$，可导出 $\\Delta t_{\\phi}  \\frac{\\pi}{10 \\, \\omega_{p}}$。\n    -   *碰撞解析度约束*：在EMC模拟中，粒子在散射事件之间进行自由飞行，散射事件发生的平均时间尺度为 $\\tau$。为了使自由飞行期间电场恒定的假设有效，电场在此时间尺度内不能有显著变化。因此，$\\Delta t_{\\phi}$ 应选择为 $\\tau$ 的一小部分。启发式选择 $0.2 \\, \\tau$ 是一个合理的选择。\n    结合这些约束，得到复合的安全间隔：\n    $$ \\Delta t_{\\phi,\\mathrm{safe}} = \\min\\!\\left( -\\tau_{d} \\ln(1 - \\varepsilon_{\\mathrm{tol}}), \\; \\frac{\\pi}{10 \\, \\omega_{p}}, \\; 0.2 \\, \\tau \\right) $$\n\n以下程序为提供的测试用例实现了这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates stability and accuracy metrics for coupled EMC-Poisson simulations.\n    \"\"\"\n    # Define physical constants\n    Q = 1.602176634e-19  # Elementary charge in C\n    EPS0 = 8.8541878128e-12 # Permittivity of free space in F/m\n    M_E = 9.1093837015e-31 # Free-electron mass in kg\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, tau, m_star/m_e, eps_r, dt_phi, eps_tol)\n        (1.0e21, 1.0e-13, 0.26, 11.7, 1.0e-15, 0.01),\n        (1.0e24, 1.0e-14, 0.26, 11.7, 5.0e-13, 0.10),\n        (1.0e20, 1.0e-12, 0.26, 11.7, 3.0e-11, 0.05),\n        (5.0e22, 2.0e-13, 0.26, 11.7, 2.0e-13, 0.05),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n, tau, m_star_ratio, eps_r, dt_phi, eps_tol = case\n\n        # Calculate intermediate physical parameters\n        eps = eps_r * EPS0\n        m_star = m_star_ratio * M_E\n        \n        # Conductivity sigma = n * q^2 * tau / m_star\n        # Avoid division by zero if m_star is zero, though not expected here.\n        if m_star == 0:\n            sigma = np.inf if n > 0 and tau > 0 else 0\n        else:\n            sigma = (n * Q**2 * tau) / m_star\n\n        # 1. Dielectric relaxation time, tau_d\n        # Avoid division by zero if sigma is zero.\n        if sigma == 0:\n            tau_d = np.inf\n        else:\n            tau_d = eps / sigma\n\n        # 2. Plasma angular frequency, omega_p\n        # Avoid sqrt of negative, though not expected from physics\n        omega_p_sq = (n * Q**2) / (eps * m_star)\n        omega_p = np.sqrt(omega_p_sq) if omega_p_sq >= 0 else 0.0\n\n        # 3. Relative error bound, e_rel\n        if tau_d == np.inf:\n            e_rel = 0.0\n        else:\n            e_rel = 1.0 - np.exp(-dt_phi / tau_d)\n\n        # 4. Sampling stability, stable_sampling\n        # Avoid division by zero if omega_p is zero\n        if omega_p == 0:\n            stable_sampling = True # No oscillations to alias\n        else:\n            stable_sampling = dt_phi  (np.pi / omega_p)\n\n        # 5. Accuracy criterion, meets_accuracy\n        meets_accuracy = e_rel = eps_tol\n\n        # 6. Safe potential-update interval, dt_phi_safe\n        # Term 1: Accuracy constraint\n        # Avoid log of non-positive\n        if eps_tol >= 1.0:\n            term1 = np.inf\n        else:\n            term1 = -tau_d * np.log(1.0 - eps_tol)\n\n        # Term 2: Stability constraint\n        # Avoid division by zero if omega_p is zero\n        if omega_p == 0:\n            term2 = np.inf\n        else:\n            term2 = np.pi / (10.0 * omega_p)\n            \n        # Term 3: Collision resolution constraint\n        term3 = 0.2 * tau\n\n        dt_phi_safe = min(term1, term2, term3)\n\n        case_result = [\n            tau_d,\n            omega_p,\n            e_rel,\n            stable_sampling,\n            meets_accuracy,\n            dt_phi_safe,\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as a list of lists.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    str_results = []\n    for res in all_results:\n        # Convert each item in the inner list to a string\n        # Python's str() of a boolean is 'True' or 'False' which is correct\n        # Python's str() of a float is used for numerical values\n        res_str = '[' + ','.join(map(str, res)) + ']'\n        str_results.append(res_str)\n    final_output = '[' + ','.join(str_results) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}