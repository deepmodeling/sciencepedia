{
    "hands_on_practices": [
        {
            "introduction": "Scharfetter-Gummel离散化方法的核心在于对伯努利函数 $B(\\xi)$ 的数值处理。由于该函数在自变量 $\\xi$ 趋近于零时会遭遇灾难性相消（catastrophic cancellation），而在 $|\\xi|$ 较大时则可能出现上溢或下溢，直接计算会导致严重的数值不稳定性。此实践练习旨在指导您构建一个鲁棒的、分段实现的算法，通过运用泰勒级数展开和渐近分析，确保在整个实数域内都能准确稳定地计算伯努利函数，这是开发可靠的半导体器件仿真软件的基础技能 ()。",
            "id": "3780761",
            "problem": "必须编写一个程序来评估在半导体器件建模的漂移扩散方程的 Scharfetter–Gummel (SG) 离散化方法中使用的伯努利函数。Scharfetter–Gummel 方法依赖于在长度为 $\\Delta x$ 的网格边上，对具有恒定电场的稳态一维漂移扩散通量进行精确积分，其中使用了爱因斯坦关系和通量在边上恒定的要求。得到的通量表达式引入了依赖于无量纲电势降的伯努利函数，这对于离散化的数值稳定性和物理一致性至关重要。从基本原理出发，从一维电子电流密度关系开始，\n$$\nJ_n = q \\mu_n n E + q D_n \\frac{d n}{d x},\n$$\n其中 $q$ 是元电荷，$\\mu_n$ 是电子迁移率，$D_n$ 是电子扩散系数，$n$ 是电子浓度，$E$ 是电场；将此与爱因斯坦关系 $D_n = \\mu_n U_T$（其中 $U_T$ 是热电压）以及要求 $J_n$ 在一条边上恒定的稳态条件相结合。精确的边积分产生一个由电势降定义的无量纲参数 $\\xi$，以及通量公式所需的一对伯努利函数求值 $B(\\xi)$ 和 $B(-\\xi)$。\n\n你的任务是构建一个数值稳定的算法蓝图并加以实现，用于评估 $B(\\xi)$ 和 $B(-\\xi)$，该算法能避免在 $\\xi = 0$ 附近发生灾难性抵消，并能在处理 $\\xi$ 的极端值时避免溢出或下溢。该算法的设计必须仅基于对伯努利函数行为的标准数学分析（包括级数展开、渐近分析和恒等式），而不能依赖于问题陈述中提供的任何快捷公式。实现必须遵守以下约束：\n\n- 在 $\\xi = 0$ 附近使用 $B(\\xi)$ 的麦克劳林级数展开，以减轻减法抵消并为小的 $|\\xi|$ 实现高相对精度。选择一个由级数分析证明合理的截断阶数，并为 $|\\xi| \\leq 10^{-4}$ 提供至少 $10^{-12}$ 量级的相对误差。\n- 对于中等大小的 $\\xi$ 值，使用数值稳定的变换（例如在计算 $e^{\\xi} - 1$ 时不会损失有效数字的操作）来评估表达式，以减少抵消。在实现 $B(\\xi)$ 和 $B(-\\xi)$ 时，避免直接减去几乎相等的量。\n- 对于大的正值或大的负值 $\\xi$，使用适当的渐近近似来避免指数函数中的溢出或下溢，同时与 $B(\\xi)$ 和 $B(-\\xi)$ 的极限行为保持一致。\n- 尽管伯努利函数具有精确的对称性，但当 $\\xi$ 的量级很大时，你必须避免使用数值上危险的恒等式，这些恒等式会将一个指数级小的量与一个指数级大的量相乘。\n\n生成一个单一程序，为以下测试集中的每个 $\\xi$ 评估 $B(\\xi)$ 和 $B(-\\xi)$：\n- $\\xi = 0$\n- $\\xi = 10^{-12}$\n- $\\xi = -10^{-12}$\n- $\\xi = 10^{-8}$\n- $\\xi = -10^{-8}$\n- $\\xi = 0.1$\n- $\\xi = -0.1$\n- $\\xi = 1$\n- $\\xi = -1$\n- $\\xi = 10$\n- $\\xi = -10$\n- $\\xi = 700$\n- $\\xi = -700$\n- $\\xi = 1000$\n- $\\xi = -1000$\n\n要求的最终输出格式：你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中对于给定的 $\\xi$ 的每个结果本身就是一个双元素列表 $[B(\\xi), B(-\\xi)]$。例如，输出应如下所示\n$$\n[[B(\\xi_1),B(-\\xi_1)],[B(\\xi_2),B(-\\xi_2)],\\ldots]\n$$\n由于 $\\xi$ 是无量纲的，因此不涉及物理单位；所有输出均为浮点数。",
            "solution": "问题陈述要求开发并实现一个数值稳定的算法，用于评估伯努利函数 $B(\\xi)$ 和 $B(-\\xi)$，作为 Scharfetter-Gummel 离散化方法的核心组成部分。\n\n## 问题验证\n\n### 第 1 步：提取已知信息\n- **物理背景**：用于半导体漂移扩散方程的 Scharfetter-Gummel (SG) 离散化。\n- **控制方程**：一维电子电流密度，$J_n = q \\mu_n n E + q D_n \\frac{d n}{d x}$，其中 $q$ 是元电荷，$\\mu_n$ 是电子迁移率，$D_n$ 是电子扩散系数，$n$ 是电子浓度，$E$ 是电场。\n- **辅助关系**：爱因斯坦关系，$D_n = \\mu_n U_T$，其中 $U_T$ 是热电压。\n- **假设**：稳态（$J_n$ 恒定）和在长度为 $\\Delta x$ 的网格边上电场 $E$ 恒定。\n- **核心任务**：构建一个数值稳定的算法，用于评估伯努利函数 $B(\\xi)$ 及其对应项 $B(-\\xi)$，其中 $\\xi$ 是无量纲电势降。\n- **算法约束**：\n    1.  该算法必须从函数性质的基础数学分析中推导得出。\n    2.  对于小的 $|\\xi|$，必须使用麦克劳林级数展开以避免灾难性抵消。截断必须有合理的依据，以在 $|\\xi| \\leq 10^{-4}$ 时提供大约 $10^{-12}$ 的相对误差。\n    3.  对于中等大小的 $\\xi$ 值，必须使用数值稳定的形式。\n    4.  对于大的正值或负值 $\\xi$，必须使用渐近近似以防止溢出/下溢。\n    5.  必须避免使用数值上危险的恒等式。\n- **测试集**：包含 15 个 $\\xi$ 值的列表：$0, \\pm 10^{-12}, \\pm 10^{-8}, \\pm 0.1, \\pm 1, \\pm 10, \\pm 700, \\pm 1000$。\n- **输出格式**：一个包含双元素列表的单行列表，例如 `[[B(xi_1),B(-xi_1)],[B(xi_2),B(-xi_2)],...]`。\n\n### 第 2 步：使用提取的已知信息进行验证\n- **科学依据**：该问题牢固地植根于半导体器件物理和数值分析。漂移扩散模型、爱因斯坦关系和 Scharfetter-Gummel 方法都是标准且成熟的概念。物理原理是正确的。\n- **适定性**：任务定义清晰：在明确的数值稳定性约束下，实现一个特定的数学函数 $B(\\xi)$。输入（测试用例）和所需的输出格式都已精确指定。虽然没有给出 $B(\\xi)$ 的显式形式，但从所提供的物理方程推导它是该主题的标准部分，这使得问题对于知识渊博的从业者来说是自洽的。\n- **客观性**：问题以精确、技术性的语言陈述，没有主观性或歧义。\n- **缺陷分析**：\n    1.  *科学/事实不准确*：无。\n    2.  *不可形式化/不相关*：无。该问题可直接形式化且高度相关。\n    3.  *设置不完整/矛盾*：无。未提供 $B(\\xi)$ 的公式是该问题的有意设计，需要从上下文中推导或识别。\n    4.  *不切实际/不可行*：无。这些要求在高质量的数值软件中是标准的。\n    5.  *不适定/结构不良*：无。可以设计出唯一的稳定解。\n    6.  *伪深刻/琐碎*：无。该问题解决了计算物理学中一个真实且不平凡的挑战。\n    7.  *超出科学可验证性*：无。结果在数学上是可验证的。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将开发完整的解决方案。\n\n## Scharfetter-Gummel 方案中伯努利函数的推导\n\n出发点是一维稳态电子电流密度方程：\n$$\nJ_n = q \\mu_n n E + q D_n \\frac{d n}{d x}\n$$\n使用爱因斯坦关系 $D_n = \\mu_n U_T$ 来消除迁移率 $\\mu_n = D_n / U_T$，并通过 $E = -d\\psi/dx$ 将电场与静电势 $\\psi$ 联系起来，方程变为：\n$$\nJ_n = q \\frac{D_n}{U_T} n \\left(-\\frac{d\\psi}{dx}\\right) + q D_n \\frac{d n}{d x}\n$$\n两边除以 $q D_n$ 并定义归一化电势 $\\phi = \\psi / U_T$，我们得到：\n$$\n\\frac{J_n}{q D_n} = -n \\frac{d\\phi}{dx} + \\frac{d n}{d x}\n$$\n这是一个关于电子密度 $n(x)$ 的一阶线性常微分方程。假设 $J_n$ 和 $D_n$ 在从 $x_i$ 到 $x_{i+1}$ 的网格区间上是常数，我们可以写出：\n$$\n\\frac{d}{dx} \\left(n(x) e^{-\\phi(x)}\\right) = \\left(\\frac{d n}{d x} - n \\frac{d\\phi}{dx}\\right) e^{-\\phi(x)} = \\frac{J_n}{q D_n} e^{-\\phi(x)}\n$$\n从 $x_i$ 到 $x_{i+1}$ 积分：\n$$\nn_{i+1} e^{-\\phi_{i+1}} - n_i e^{-\\phi_i} = \\frac{J_n}{q D_n} \\int_{x_i}^{x_{i+1}} e^{-\\phi(x)} dx\n$$\n其中 $n_k = n(x_k)$ 且 $\\phi_k = \\phi(x_k)$。关键的 Scharfetter-Gummel 假设是节点之间的电场 $E$ 是恒定的，这意味着归一化电势 $\\phi(x)$ 是线性的。设 $\\xi = \\phi_{i+1} - \\phi_i$ 为长度为 $\\Delta x = x_{i+1} - x_i$ 的区间上的归一化电势降。线性电势为 $\\phi(x) = \\phi_i + \\xi \\frac{x-x_i}{\\Delta x}$。该积分的计算结果为：\n$$\n\\int_{x_i}^{x_{i+1}} e^{-\\left(\\phi_i + \\xi \\frac{x-x_i}{\\Delta x}\\right)} dx = e^{-\\phi_i} \\Delta x \\frac{1 - e^{-\\xi}}{\\xi}\n$$\n将其代回并求解 $J_n$：\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} e^{\\phi_i} (n_{i+1} e^{-\\phi_{i+1}} - n_i e^{-\\phi_i})\n$$\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} (n_{i+1} e^{\\phi_i - \\phi_{i+1}} - n_i) = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} (n_{i+1} e^{-\\xi} - n_i)\n$$\n为了揭示标准形式，我们分配前置因子：\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\left( n_{i+1} \\frac{\\xi e^{-\\xi}}{1 - e^{-\\xi}} - n_i \\frac{\\xi}{1-e^{-\\xi}} \\right)\n$$\n通过将伯努利函数定义为 $B(x) = \\frac{x}{e^x - 1}$，我们可以识别这些项。第一项的系数是 $\\frac{\\xi e^{-\\xi}}{1 - e^{-\\xi}} = \\frac{\\xi}{e^{\\xi} - 1} = B(\\xi)$。第二项的系数是 $\\frac{\\xi}{1-e^{-\\xi}} = \\frac{-\\xi}{e^{-\\xi}-1} = B(-\\xi)$。因此，离散化的电流密度为：\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\left[ n_{i+1} B(\\xi) - n_i B(-\\xi) \\right]\n$$\n这个推导证实了核心计算任务是稳定地评估 $B(\\xi) = \\frac{\\xi}{e^\\xi - 1}$。\n\n## 数值实现策略\n\n函数 $B(\\xi) = \\frac{\\xi}{e^{\\xi} - 1}$ 在某些 $\\xi$ 的范围内会带来数值计算上的困难。一个稳健的实现需要一个分段方法，覆盖参数 $\\xi$ 的三个不同区域。\n\n### 区域 1：小的 $|\\xi|$\n当 $\\xi \\to 0$ 时，分子和分母都趋近于零。直接求值会导致 $0/0$ 的不定形式，并且由于 $e^\\xi \\approx 1$，在浮点运算中会遭受灾难性抵消。我们使用麦克劳林级数展开，它源自伯努利数 $b_k$ 的生成函数：\n$$\nB(\\xi) = \\sum_{k=0}^{\\infty} b_k \\frac{\\xi^k}{k!} = b_0 + b_1 \\xi + \\frac{b_2}{2!} \\xi^2 + \\frac{b_4}{4!} \\xi^4 + \\frac{b_6}{6!} \\xi^6 + \\dots\n$$\n使用已知的伯努利数值（$b_0=1, b_1=-1/2, b_2=1/6, b_4=-1/30, b_6=1/42$，且对于 $k\\ge1$ 有 $b_{2k+1}=0$），级数为：\n$$\nB(\\xi) = 1 - \\frac{1}{2}\\xi + \\frac{1}{12}\\xi^2 - \\frac{1}{720}\\xi^4 + \\frac{1}{30240}\\xi^6 - \\frac{1}{1209600}\\xi^8 + O(\\xi^{10})\n$$\n问题要求在 $|\\xi| \\leq 10^{-4}$ 时相对误差约为 $10^{-12}$。让我们在 $\\xi^6$ 项之后截断级数。首项误差项为 $-\\frac{\\xi^8}{1209600}$。在该区域的边界处，即 $|\\xi| = 10^{-4}$，绝对误差约为 $\\frac{(10^{-4})^8}{1209600} \\approx 8.3 \\times 10^{-39}$。由于在此区域内 $B(\\xi) \\approx 1$，这个绝对误差也就是相对误差。这个精度水平远高于要求，确保了方法的稳健性。选择的近似值为：\n$$\nB(\\xi) \\approx 1 - \\frac{\\xi}{2} + \\frac{\\xi^2}{12} - \\frac{\\xi^4}{720} + \\frac{\\xi^6}{30240}\n$$\n\n### 区域 2：大的 $|\\xi|$\n对于大的 $|\\xi|$ 值，项 $e^\\xi$ 可能会导致溢出（大的正 $\\xi$）或下溢（大的负 $\\xi$）。在这些情况下，我们使用渐近近似。\n- **对于大的正 $\\xi$**：当 $\\xi \\to +\\infty$ 时，$e^\\xi \\to \\infty$。分母 $e^\\xi - 1 \\approx e^\\xi$。\n  $$ B(\\xi) = \\frac{\\xi}{e^\\xi-1} \\approx \\frac{\\xi}{e^\\xi} = \\xi e^{-\\xi} \\to 0 $$\n  对于标准的双精度浮点数，$e^\\xi$ 在 $\\xi \\approx 709.7$ 左右溢出。我们选择一个保守的阈值，例如 $\\xi > 37$。对于 $\\xi=37$，$B(37) \\approx 37 e^{-37} \\approx 3.0 \\times 10^{-15}$，这已经低于机器精度。因此，对于 $\\xi > 37$，我们可以安全地近似 $B(\\xi) = 0$。\n- **对于大的负 $\\xi$**：令 $\\xi = -z$，其中 $z \\to +\\infty$。\n  $$ B(\\xi) = B(-z) = \\frac{-z}{e^{-z} - 1} $$\n  当 $z \\to \\infty$ 时，$e^{-z} \\to 0$。分母趋近于 $-1$。\n  $$ B(\\xi) \\approx \\frac{-z}{-1} = z = -\\xi $$\n  此近似的误差为 $B(\\xi) - (-\\xi) = \\frac{\\xi}{e^{\\xi}-1} + \\xi = \\frac{\\xi e^{\\xi}}{e^\\xi-1}$。对于 $\\xi  -37$，此误差的量级为 $|\\xi|e^{\\xi}$，它会下溢到零。因此，对于 $\\xi  -37$，我们近似 $B(\\xi) = -\\xi$。\n\n### 区域 3：中等的 $|\\xi|$\n对于那些对于级数展开来说不够小，对于渐近近似来说又不够大（即 $10^{-4}  |\\xi| \\leq 37$）的 $\\xi$ 值，可以使用直接公式 $B(\\xi) = \\frac{\\xi}{e^\\xi - 1}$。为了在靠近小 `|`$\\xi$`|` 边界时保持精度，分母 $e^\\xi - 1$ 应使用专门的库函数（如 `expm1(\\xi)`）来计算，即使在 $\\xi$ 接近零时，它也能精确计算该表达式。\n\n## 算法蓝图\n基于以上分析，我们可以分段定义函数 $B(\\xi)$：\n$$\nB(\\xi) =\n\\begin{cases}\n    1 - \\frac{1}{2}\\xi + \\frac{\\xi^2}{12} - \\frac{\\xi^4}{720} + \\frac{\\xi^6}{30240}  \\text{如果 } |\\xi| \\leq 10^{-4} \\\\\n    -\\xi  \\text{如果 } \\xi  -37 \\\\\n    0  \\text{如果 } \\xi > 37 \\\\\n    \\frac{\\xi}{e^{\\xi}-1}  \\text{其他情况}\n\\end{cases}\n$$\n该算法提供了一种完整、稳健且准确的方法，用于在整个实数范围内评估伯努利函数，满足了问题的所有约束。对于每个测试值 $\\xi_k$，我们将通过两次调用此函数来计算配对 $[B(\\xi_k), B(-\\xi_k)]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating the Bernoulli functions B(xi) and B(-xi)\n    for a given set of test cases using a numerically stable algorithm.\n    \"\"\"\n\n    # The test cases for xi provided in the problem statement.\n    test_cases = [\n        0,\n        1e-12,\n        -1e-12,\n        1e-8,\n        -1e-8,\n        0.1,\n        -0.1,\n        1.0,\n        -1.0,\n        10.0,\n        -10.0,\n        700.0,\n        -700.0,\n        1000.0,\n        -1000.0,\n    ]\n\n    def bernoulli(xi):\n        \"\"\"\n        Computes the Bernoulli function B(xi) = xi / (exp(xi) - 1)\n        using a numerically stable piecewise implementation.\n\n        Args:\n            xi (float): The input argument, a dimensionless potential drop.\n\n        Returns:\n            float: The value of B(xi).\n        \"\"\"\n        # Regime 1: Small |xi|. Use Maclaurin series expansion to avoid\n        # catastrophic cancellation from exp(xi) - 1 approaching 0.\n        # The threshold 1e-4 is from the problem statement.\n        if abs(xi) = 1e-4:\n            # B(xi) = 1 - xi/2 + xi^2/12 - xi^4/720 + xi^6/30240 - ...\n            # Using Horner's method for efficient polynomial evaluation.\n            xi2 = xi * xi\n            # Coefficients from b_k / k!\n            c0 = 1.0\n            c1 = -0.5\n            c2 = 1.0/12.0\n            c4 = -1.0/720.0\n            c6 = 1.0/30240.0\n            \n            # Truncating at O(xi^6) gives more than enough precision.\n            return c0 + xi * (c1 + xi * (c2 + xi2 * (c4 + xi2 * c6)))\n\n        # Regime 2: Large negative xi.\n        # B(xi) approaches -xi as xi -> -inf.\n        # The threshold -37 is chosen as exp(xi) underflows below this value\n        # and the asymptotic approximation is highly accurate.\n        if xi  -37.0:\n            return -xi\n\n        # Regime 3: Large positive xi.\n        # B(xi) approaches 0 as xi -> +inf.\n        # The threshold +37 is chosen as exp(xi) is very large and B(xi) is\n        # smaller than machine precision.\n        if xi > 37.0:\n            return 0.0\n\n        # Regime 4: Moderate |xi|. The direct formula is stable.\n        # Use np.expm1(xi) to compute exp(xi) - 1 accurately.\n        return xi / np.expm1(xi)\n\n    results = []\n    for xi_val in test_cases:\n        # For each xi, calculate both B(xi) and B(-xi)\n        b_xi = bernoulli(xi_val)\n        b_minus_xi = bernoulli(-xi_val)\n        results.append([b_xi, b_minus_xi])\n\n    # The final print statement must produce only the specified single-line format.\n    # str(list) automatically adds the '[...]' formatting.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了深刻理解Scharfetter-Gummel (SG) 离散化方法的优越性，将其与更基础的数值格式进行对比是一种非常有效的方法。本练习将SG格式与一阶迎风和二阶中心差分格式在存在剧烈势垒的场景下进行比较，SG格式基于对漂移扩散方程的局域精确积分，而其他格式则基于简单的泰勒展开。通过亲手实现并对比这些方法，您将直观地观察到SG格式在捕捉尖锐边界层、避免非物理振荡以及保持载流子浓度正定性等方面的卓越能力，从而理解其为何成为器件仿真的标准方法 ()。",
            "id": "3780759",
            "problem": "考虑半导体器件中在一维、稳态、漂移-扩散框架下的电子输运。设空间域为闭区间 $[0,1]$，其上有一个包含 $N$ 个节点的均匀网格，无量纲静电势记为 $\\phi(x)$。假设在 $x_0$ 处存在一个宽度为 $\\delta$、总幅度为 $\\Delta\\Phi$ 的急剧电势降，因此 $\\phi(x)$ 由分段函数定义：左侧为恒定区域，在区间 $[x_0-\\delta/2, x_0+\\delta/2]$ 上为斜率为 $\\Delta\\Phi/\\delta$ 的线性斜坡，右侧为恒定区域。具体定义如下\n$$\n\\phi(x) = \n\\begin{cases}\n0,  x \\le x_0 - \\delta/2, \\\\\n\\frac{\\Delta\\Phi}{\\delta}\\,\\left(x - \\left(x_0 - \\frac{\\delta}{2}\\right)\\right),  x_0 - \\delta/2  x  x_0 + \\delta/2, \\\\\n\\Delta\\Phi,  x \\ge x_0 + \\delta/2.\n\\end{cases}\n$$\n假设采用无量纲标度，电子扩散系数等于 $1$，并使用迁移率和扩散系数之间的爱因斯坦关系来证明此归一化的合理性。无量纲形式的电子通量 $J_n$ 由基本输运原理推导出的漂移-扩散定律给出，\n$$\nJ_n(x) = -\\left(\\frac{dn}{dx} + n(x)\\,\\frac{d\\phi}{dx}\\right),\n$$\n其中 $n(x)$ 是电子密度。考虑平衡态零通量情况 $J_n(x) \\equiv 0$。在此平衡假设下，连续解满足 Boltzmann 关系 $n(x) \\propto \\exp(-\\phi(x))$。对所有情况施加左侧 Dirichlet 边界条件 $n(0) = 1$，因此网格上的精确参考解为 $n_{\\text{exact}}(x_i) = \\exp(-\\phi(x_i))$。\n\n您的任务是，从 $n(0)=1$ 开始，为整个网格单元上的零通量平衡递推关系 $n$ 实现三种不同的数值离散化方案：\n\n- 对流项的一阶迎风有限差分离散化（根据局部单元电势增量的符号选择迎风状态）。\n- 对流项的二阶中心有限差分离散化。\n- 在局部场恒定的假设下，通过对每个单元上的漂移-扩散方程进行精确积分得到的 Scharfetter-Gummel (SG) 离散化。\n\n不要使用任何来自外部来源的预先推导出的离散化公式；从控制通量定律和所述假设出发，推导每种递推关系。对于每个单元 $[x_i,x_{i+1}]$，计算局部电势增量 $\\Delta\\phi_i = \\phi(x_{i+1}) - \\phi(x_i)$，并根据每种方案使用它将 $n_i$ 传播到 $n_{i+1}$。对于 SG 方法，使用在局部场恒定条件下通过精确积分得到的适当单元关系。\n\n数值网格构建细节：\n\n- 使用一个包含 $N$ 个节点的均匀网格，其中 $x_i = i/(N-1)$，$i=0,1,\\dots,N-1$。\n- 使用给定的 $\\Delta\\Phi$、$\\delta$ 和 $x_0$，根据上述分段定义精确构建 $\\phi(x_i)$。\n\n为每种方法和每个测试用例计算的评估指标：\n\n- 右边界处的绝对误差，定义为 $|n_{\\text{method}}(x_{N-1}) - n_{\\text{exact}}(x_{N-1})|$。\n- 一个正性布尔值，指示所有计算出的节点密度在整个域上是否严格为正。\n- 最大绝对节点误差，定义为 $\\max_i |n_{\\text{method}}(x_i) - n_{\\text{exact}}(x_i)|$。\n\n测试套件：\n\n为以下参数集计算上述指标，这些参数集共同涵盖了一个适中的“理想路径”情景和逐渐尖锐的边界层：\n\n- 案例 1：$N=100$，$\\Delta\\Phi=1$，$\\delta=0.2$，$x_0=0.5$。\n- 案例 2：$N=100$，$\\Delta\\Phi=5$，$\\delta=0.02$，$x_0=0.5$。\n- 案例 3：$N=200$，$\\Delta\\Phi=10$，$\\delta=0.01$，$x_0=0.5$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个包含七个条目的列表，顺序如下：\n$[$Scharfetter-Gummel 的右端绝对误差, 迎风法的右端绝对误差, 中心差分法的右端绝对误差, 迎风法的正性布尔值, 中心差分法的正性布尔值, 迎风法在所有节点上的最大绝对误差, 中心差分法在所有节点上的最大绝对误差$]$。\n\n将所有三个测试用例的结果聚合为一个包含这些按用例划分的列表的列表。例如，最终输出应类似于\n$[[\\ldots],[\\ldots],[\\ldots]]$\n，不含空格。",
            "solution": "所提出的问题是半导体输运方程数值分析中一个有效且适定的练习。它在科学上基于漂移-扩散模型，提供了一套完整且一致的参数，并要求将标准数值方案与解析解进行有意义的比较。我们将首先推导三种指定离散化方法的递推关系，然后实现它们以计算所需的误差指标。\n\n控制物理定律是一维稳态电子通量 $J_n$ 的漂移-扩散方程。在指定的平衡条件下 ($J_n(x) \\equiv 0$)，该方程简化为：\n$$\nJ_n(x) = -\\left(\\frac{dn}{dx} + n(x)\\,\\frac{d\\phi}{dx}\\right) = 0\n$$\n其中 $n(x)$ 是电子密度，$\\phi(x)$ 是无量纲静电势。这是关于 $n(x)$ 的一阶常微分方程 (ODE)：\n$$\n\\frac{dn}{dx} = -n(x)\\frac{d\\phi}{dx}\n$$\n问题指定了一个包含 $N$ 个节点的均匀网格，$x_i = i/(N-1)$，$i=0, 1, \\dots, N-1$。设网格间距为 $h = x_{i+1} - x_i = 1/(N-1)$。我们的任务是推导递推关系，以根据前一个节点的值 $n_i = n(x_i)$ 计算节点密度 $n_{i+1} = n(x_{i+1})$。设 $\\Delta\\phi_i = \\phi(x_{i+1}) - \\phi(x_i) = \\phi_{i+1} - \\phi_i$ 为单元 $[x_i, x_{i+1}]$ 上的电势差。\n\n具有边界条件 $n(0)=1$ 和 $\\phi(0)=0$ 的常微分方程的连续解是 $n(x) = \\exp(-\\phi(x))$。这将作为我们在网格上的精确参考解：$n_{\\text{exact}}(x_i) = \\exp(-\\phi(x_i))$。\n\n这三种数值方案近似了单元 $[x_i, x_{i+1}]$ 中点处的通量 $J_{n, i+1/2}$ 并将其设为零。通量的一个简单有限差分近似是：\n$$\nJ_{n, i+1/2} \\approx -\\left(\\frac{n_{i+1} - n_i}{h} + n_{i+1/2} \\frac{\\phi_{i+1} - \\phi_i}{h}\\right) = 0\n$$\n这导致了三种方案以不同方式解释的核心离散关系：\n$$\nn_{i+1} - n_i + n_{i+1/2} (\\phi_{i+1} - \\phi_i) = 0\n$$\n其中 $n_{i+1/2}$ 是单元界面处密度的近似值。\n\n**1. 中心有限差分离散化**\n\n该方案使用节点密度的简单算术平均值来近似界面密度 $n_{i+1/2}$：\n$$\nn_{i+1/2} \\approx \\frac{n_i + n_{i+1}}{2}\n$$\n将其代入核心关系式可得：\n$$\nn_{i+1} - n_i + \\left(\\frac{n_i + n_{i+1}}{2}\\right) \\Delta\\phi_i = 0\n$$\n我们求解 $n_{i+1}$：\n$$\nn_{i+1} \\left(1 + \\frac{\\Delta\\phi_i}{2}\\right) = n_i \\left(1 - \\frac{\\Delta\\phi_i}{2}\\right)\n$$\n$$\nn_{i+1} = n_i \\frac{1 - \\Delta\\phi_i/2}{1 + \\Delta\\phi_i/2} = n_i \\frac{2 - \\Delta\\phi_i}{2 + \\Delta\\phi_i}\n$$\n对于小的 $\\Delta\\phi_i$，这个递推关系是二阶精确的。然而，如果 $|\\Delta\\phi_i| > 2$，即使 $n_i$ 是正的，计算出的 $n_{i+1}$ 也可能变为负值，这违反了载流子密度为正的物理约束。\n\n**2. 一阶迎风有限差分离散化**\n\n迎风方案通过选择上游节点值来近似 $n_{i+1/2}$。“流”的方向由电场符号决定，$E_{i+1/2} \\approx -\\Delta\\phi_i/h$。\n\n- 如果 $E_{i+1/2} > 0$ (即 $\\Delta\\phi_i  0$)，对流场从 $i+1$ 指向 $i$。上游节点是 $i+1$，所以我们设 $n_{i+1/2} = n_{i+1}$。递推关系变为：\n  $$\n  n_{i+1} - n_i + n_{i+1} \\Delta\\phi_i = 0 \\implies n_{i+1}(1+\\Delta\\phi_i) = n_i \\implies n_{i+1} = \\frac{n_i}{1 + \\Delta\\phi_i}\n  $$\n- 如果 $E_{i+1/2}  0$ (即 $\\Delta\\phi_i > 0$)，对流场从 $i$ 指向 $i+1$。上游节点是 $i$，所以我们设 $n_{i+1/2} = n_i$。递推关系变为：\n  $$\n  n_{i+1} - n_i + n_i \\Delta\\phi_i = 0 \\implies n_{i+1} = n_i (1 - \\Delta\\phi_i)\n  $$\n- 如果 $\\Delta\\phi_i = 0$，两个公式都正确地得出 $n_{i+1}=n_i$。\n\n该方案只有一阶精度，但比中心差分方案更稳定。然而，如果 $\\Delta\\phi_i > 1$ 或 $\\Delta\\phi_i \\le -1$，它仍然可能产生非物理的负密度。\n\n**3. Scharfetter-Gummel (SG) 离散化**\n\nSG 方案是通过假设在每个单元 $[x_i, x_{i+1}]$ 内通量 $J_n$ 和电场 $E$ 是恒定的来推导的。恒定场为 $E = -\\Delta\\phi_i/h$。在这些假设下，漂移-扩散方程在单元内变成一个具有常系数的一阶线性常微分方程：\n$$\n\\frac{dn}{dx} + E n(x) = -\\frac{J_n}{D_n}\n$$\n在指定的归一化 $D_n=1$ 条件下，我们有：\n$$\n\\frac{dn}{dx} - \\frac{\\Delta\\phi_i}{h} n(x) = -J_n\n$$\n这个常微分方程可以使用积分因子 $e^{-\\Delta\\phi_i(x-x_i)/h}$ 在区间 $[x_i, x_{i+1}]$ 上精确求解。该解将节点密度与恒定通量 $J_n$ 联系起来：\n$$\nJ_{n, i+1/2} = -\\frac{1}{h} \\left[ B(\\Delta\\phi_i) n_{i+1} - B(-\\Delta\\phi_i) n_i \\right]\n$$\n其中 $B(x) = x/(e^x - 1)$ 是 Bernoulli 函数。\n\n对于平衡情况，我们强制 $J_{n, i+1/2} = 0$：\n$$\nB(\\Delta\\phi_i) n_{i+1} - B(-\\Delta\\phi_i) n_i = 0\n$$\n$$\nn_{i+1} = n_i \\frac{B(-\\Delta\\phi_i)}{B(\\Delta\\phi_i)}\n$$\n代入 Bernoulli 函数的定义和恒等式 $B(-x) = B(x) e^x$：\n$$\n\\frac{B(-\\Delta\\phi_i)}{B(\\Delta\\phi_i)} = \\frac{B(\\Delta\\phi_i)e^{\\Delta\\phi_i}}{B(\\Delta\\phi_i)} = e^{\\Delta\\phi_i}\n$$\n因此，对于零通量情况，SG 递推关系简化为：\n$$\nn_{i+1} = n_i e^{\\Delta\\phi_i}\n$$\n等一下，在我们的问题定义中，$J_n = -(\\frac{dn}{dx} + n\\frac{d\\phi}{dx})$ 和 $J_n=0$ 意味着 $\\frac{dn}{dx} = -n\\frac{d\\phi}{dx}$，其解为 $n(x) \\propto e^{-\\phi(x)}$。因此 $n_{i+1} = n_i e^{-(\\phi_{i+1}-\\phi_i)} = n_i e^{-\\Delta\\phi_i}$。上述推导结果为 $e^{\\Delta\\phi_i}$，这表明我的SG通量公式定义与问题中的电流定义不一致。让我们以 $\\frac{dn}{dx} = -n\\frac{d\\phi}{dx}$ 为起点重新推导SG。\n常微分方程 $\\frac{dn}{n} = -d\\phi$ 在单元上积分得 $\\ln(n_{i+1}/n_i) = -(\\phi_{i+1}-\\phi_i) = -\\Delta\\phi_i$。因此 $n_{i+1} = n_i e^{-\\Delta\\phi_i}$。\n这个递推关系与精确解析解 $n(x_i) = \\exp(-\\phi(x_i))$ 中相邻点之间的关系完全相同。因此，SG 方法将以机器精度计算节点密度，相关的误差几乎为零。这展示了该方法的强大之处，因为它在数值上保持了物理上的 Boltzmann 关系。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D drift-diffusion problem for three schemes and reports metrics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, DeltaPhi, delta, x0)\n        (100, 1.0, 0.2, 0.5),\n        (100, 5.0, 0.02, 0.5),\n        (200, 10.0, 0.01, 0.5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, dPhi, delta, x0 = case\n        \n        # 1. Construct grid and potential profile\n        x = np.linspace(0.0, 1.0, N)\n        \n        phi = np.zeros(N)\n        left_boundary = x0 - delta / 2.0\n        right_boundary = x0 + delta / 2.0\n        \n        # Vectorized calculation of the piecewise potential\n        in_ramp = (x > left_boundary)  (x  right_boundary)\n        right_of_ramp = x >= right_boundary\n        \n        if delta > 0:\n            phi[in_ramp] = (dPhi / delta) * (x[in_ramp] - left_boundary)\n        phi[right_of_ramp] = dPhi\n        \n        # 2. Compute exact solution\n        n_exact = np.exp(-phi)\n        \n        # 3. Initialize solution arrays for the three methods\n        n_sg = np.zeros(N)\n        n_upwind = np.zeros(N)\n        n_central = np.zeros(N)\n        \n        # Apply Dirichlet boundary condition at x=0\n        n_sg[0] = 1.0\n        n_upwind[0] = 1.0\n        n_central[0] = 1.0\n        \n        # 4. March across the grid and apply recurrence relations\n        for i in range(N - 1):\n            dphi_i = phi[i+1] - phi[i]\n            \n            # Scharfetter-Gummel\n            # For J=0, this scheme exactly reproduces the Boltzmann relation\n            n_sg[i+1] = n_sg[i] * np.exp(-dphi_i)\n            \n            # Upwind\n            if dphi_i > 0: # E_field  0, upwind node is i\n                n_upwind[i+1] = n_upwind[i] * (1.0 - dphi_i)\n            else: # dphi_i = 0, E_field >= 0, upwind node is i+1\n                denom = 1.0 + dphi_i\n                if abs(denom)  1e-15:\n                    n_upwind[i+1] = np.finfo(float).max\n                else:\n                    n_upwind[i+1] = n_upwind[i] / denom\n\n            # Central Difference\n            denom = 2.0 + dphi_i\n            if abs(denom)  1e-15:\n                n_central[i+1] = np.finfo(float).max\n            else:\n                 n_central[i+1] = n_central[i] * (2.0 - dphi_i) / denom\n                 \n        # 5. Calculate evaluation metrics\n        err_sg_end = abs(n_sg[-1] - n_exact[-1])\n        err_up_end = abs(n_upwind[-1] - n_exact[-1])\n        err_cen_end = abs(n_central[-1] - n_exact[-1])\n        \n        # Check for positivity, excluding boundary condition n[0]=1\n        pos_up = bool(np.all(n_upwind[1:] > 0))\n        pos_cen = bool(np.all(n_central[1:] > 0))\n        \n        max_err_up = np.max(np.abs(n_upwind - n_exact))\n        max_err_cen = np.max(np.abs(n_central - n_exact))\n        \n        # Assemble results for the current case in the specified order\n        case_results = [\n            err_sg_end, err_up_end, err_cen_end,\n            pos_up, pos_cen,\n            max_err_up, max_err_cen\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Using str() and replace() is a robust way to get the required format\n    # with no spaces and correct boolean representation.\n    print(str(results).replace(\" \", \"\").replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```"
        },
        {
            "introduction": "从计算单个边上的通量到模拟整个器件，需要将离散方程组装成一个全局系统。本练习将引导您学习如何系统地构建全局算子矩阵，重点在于如何通过一致的边方向定义和正确的通量符号约定，来保证粒子数守恒这一基本物理定律在离散层面得以严格满足。掌握这一组装过程，是将局域通量公式转化为具有守恒性、对称性等全局系统性质的关键一步，也是构建有限体积法求解器的核心实践 ()。",
            "id": "3780755",
            "problem": "考虑一个使用有限体积法（FVM）和夏弗特-古梅尔（Scharfetter-Gummel, SG）边通量组装的漂移扩散半导体输运模型的一维离散化。所有量都已通过热电压进行无量纲化，因此本问题中没有物理单位。基本原理是稳态电子连续性方程和漂移扩散本构律：电子电流密度的散度为零，电子电流密度是漂移和扩散的总和，扩散与迁移率之间满足爱因斯坦关系。您的任务是设计并实现一个与方向一致的全局离散算子组装过程，该算子将节点电子密度映射到每个节点的净有向通量残差。\n\n从第一性原理出发：\n- 稳态电子连续性定律指出，电子电流密度的散度为零，在离散层面，这是通过平衡每个控制体积的流出和流入边通量之和来实现的。\n- 电子输运的漂移扩散本构律是漂移（与电场和密度成正比）和扩散（与密度梯度成正比）的总和，其中爱Einstein关系通过热电压将扩散系数与迁移率联系起来。\n- Scharfetter-Gummel离散化是基于沿边假定电场恒定和密度呈指数变化的假设得出的，从而产生一个依赖于边上电势降和节点密度的封闭形式、单调且守恒的边通量公式。\n- 在指数拟合下，伯努利响应函数自然地出现在SG边通量中，并且必须以数值稳定的方式进行评估，尤其是在参数接近零时。\n\n边方向与全局守恒要求：\n- 连接两个节点的每条边都必须被赋予一个从源节点到目标节点的一致方向。方向的选择是任意的，但在组装过程中必须保持一致使用。\n- 每条边通量对其两个关联节点的残差的贡献必须带有符号，以使离开一个节点的通量恰好进入另一个节点，从而确保局部守恒，并保证对于只有内部节点的网格，所有残差的全局总和为零。\n- 当电势恒定时（零电场），对于具有恒定扩散系数的均匀一维网格，组装出的算子简化为一个对称的纯扩散算子。\n\n您的程序必须：\n1. 以数值稳定的方式实现伯努利响应函数，记为 $B(x)$，并在 $x = 0$ 处具有明确定义的极限。\n2. 对于给定的坐标为 $\\{x_i\\}$ 的一维网格、一个有向边集 $\\{(i \\rightarrow j)\\}$、节点电势 $\\{\\varphi_i\\}$ 和一个恒定的扩散系数 $D$，组装一个全局矩阵 $A$，并对于给定的节点电子密度向量 $\\mathbf{n}$ 计算残差 $\\mathbf{r} = A \\mathbf{n}$。组装过程必须使用一致的边方向，并对边贡献进行符号标记，以使添加到源节点的通量贡献与从目标节点减去的贡献互为相反数，从而保证守恒性。\n3. 通过测试用例验证组装过程在适当情况下是守恒的、方向不变的和对称的。\n\n测试套件和参数（所有量均为无量纲）：\n- 测试用例 $1$（对称扩散和常数解）：\n  - 节点：$x = [\\,0.0,\\,0.5,\\,1.0\\,]$。\n  - 有向边：$(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$。\n  - 电势：$\\varphi = [\\,0.0,\\,0.0,\\,0.0\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,1.0,\\,1.0,\\,1.0\\,]$。\n  - 要求检查：矩阵 $A$ 是对称的（在数值容差范围内），并且残差 $\\mathbf{r}$ 是零向量（在数值容差范围内）。\n\n- 测试用例 $2$（非零电场下的守恒性）：\n  - 节点：$x = [\\,0.0,\\,0.5,\\,1.0\\,]$。\n  - 有向边：$(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$。\n  - 电势：$\\varphi = [\\,0.0,\\,0.1,\\,0.2\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,0.8,\\,1.1,\\,0.9\\,]$。\n  - 要求检查：全局总和 $\\sum_i r_i$ 在数值上为零，以证明守恒性。\n\n- 测试用例 $3$（方向不变性）：\n  - 节点：$x = [\\,0.0,\\,0.5,\\,1.0\\,]$。\n  - 描述相同物理连接的两个有向边集：\n    - 正向方向：$(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$。\n    - 反向方向：$(1 \\rightarrow 0)$, $(2 \\rightarrow 1)$。\n  - 电势：$\\varphi = [\\,0.0,\\,0.1,\\,0.2\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,0.7,\\,1.0,\\,1.2\\,]$。\n  - 要求检查：由两种方向组装的矩阵和残差在数值容差范围内是相同的。\n\n- 测试用例 $4$（边界边和强场下的单调性）：\n  - 节点：$x = [\\,0.0,\\,1.0\\,]$。\n  - 有向边：$(0 \\rightarrow 1)$。\n  - 电势：$\\varphi = [\\,0.0,\\,5.0\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,1.0,\\,2.0\\,]$。\n  - 要求检查：组装出的 $A$ 的非对角线元素为非正数，对角线元素为正数，并且全局总和 $\\sum_i r_i$ 在数值上为零。\n\n算法要求：\n- 对于边 $(i \\rightarrow j)$，计算每条边的长度 $L$ 为 $L = |x_j - x_i|$。\n- 在计算电势降 $\\,\\Delta \\varphi = \\varphi_j - \\varphi_i\\,$ 以及将带符号的贡献组装到 $A$ 和 $\\mathbf{r}$ 中时，对每条边使用单一且一致的方向。\n- 在检查浮点数值相等时，使用 $10^{-10}$ 的数值容差。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3,result4]$），其中每个 $result$ 是一个布尔值，指示相应的测试用例是否通过。布尔值必须以编程语言的规范布尔形式打印。",
            "solution": "该问题要求设计并实现一个程序，用于组装一维稳态漂移扩散电子输运模型的全局离散算子。该组装过程必须在有限体积法（FVM）框架内使用夏弗特-古梅尔（Scharfetter-Gummel, SG）离散化方案。最终得到的算子是一个矩阵 $A$，它将节点电子密度向量 $\\mathbf{n}$ 映射到节点通量残差向量 $\\mathbf{r}$，使得 $\\mathbf{r} = A\\mathbf{n}$。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **模型**：一维、稳态电子连续性方程及漂移扩散本构律。所有量都已通过热电压进行无量纲化。\n- **离散化**：有限体积法与Scharfetter-Gummel边通量。\n- **方程（连续性）**：$\\nabla \\cdot \\mathbf{J}_n = 0$，离散化为每个控制体积的通量平衡。\n- **方程（本构）**：电子电流密度 $\\mathbf{J}_n$ 是漂移（与电场和密度成正比）和扩散（与密度梯度成正比）的总和。假定爱因斯坦关系成立。\n- **SG 通量**：基于沿网格边电场恒定的假设，得出一个涉及伯努利函数 $B(x)$ 的边通量的封闭形式表达式。\n- **组装要求**：\n    - 对每条边 $(i \\rightarrow j)$ 使用一致的、任意的方向。\n    - 对源节点残差的通量贡献必须是对目标节点残差贡献的相反数，以确保局部和全局守恒。\n- **输入**：网格节点坐标 $\\{x_i\\}$，一个有向边集 $\\{(i \\rightarrow j)\\}$，节点电势 $\\{\\varphi_i\\}$，一个恒定的扩散系数 $D$，以及一个节点电子密度向量 $\\mathbf{n}$。\n- **输出**：全局矩阵 $A$ 和残差向量 $\\mathbf{r} = A\\mathbf{n}$。\n- **伯努利函数**：必须以数值稳定的方式实现，记为 $B(x)$，特别注意处理 $x \\approx 0$ 的情况。\n- **测试用例**：提供了四个具体的测试用例，包含所有必要的参数和检查，以验证对称性、守恒性、方向不变性和单调性。\n- **数值容差**：$10^{-10}$ 用于浮点数比较。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学基础（关键）**：该问题从根本上基于漂移扩散模型（半导体器件物理学的基石）和Scharfetter-Gummel方案（该领域广泛使用和验证的数值方法）。这些原理是公认的。（有效）\n- **适定的**：问题定义清晰。输入已指定，期望的输出（矩阵算子 $A$ 和残差 $\\mathbf{r}$）由输入和指定的物理及数值模型唯一确定。测试用例提供了具体的验证标准。（有效）\n- **客观的（关键）**：问题使用精确、形式化的数学和物理语言陈述。没有主观或基于意见的成分。（有效）\n- **科学或事实上的不健全**：不存在违规之处。物理和数学都是标准的。\n- **非形式化或不相关**：问题可直接形式化，并且是Scharfetter-Gummel方法这一主题的核心。\n- **不完整或矛盾的设置**：设置是完整的。测试用例所需的所有数据和条件都已提供。关于物理守恒及其对组装过程影响的描述是一致的。\n- **不现实或不可行**：参数是无量纲的，代表了此类数值方案的标准测试条件。不涉及任何物理上的不可能性。\n- **不适定或结构不良**：问题结构良好，可导出一个唯一的解。\n- **伪深刻、琐碎或同义反复**：问题涉及数值建模中一个不平凡的任务，需要仔细实现SG方案和组装过程。测试用例旨在探测正确实现的关键属性。\n- **超出科学可验证性**：结果完全可以通过计算并与SG方案的已知理论属性进行比较来验证。\n\n**1.3. 结论与行动**\n问题有效。将提供一个合理的解决方案。\n\n### 步骤 2：推导与算法设计\n\n**2.1. 夏弗特-古梅尔通量**\n一维稳态漂移扩散方程中，电子粒子通量 $J_n$（问题中称为“电子电流密度”）为：\n$$ J_n(x) = -D \\left( \\frac{dn}{dx} + n \\frac{d\\varphi}{dx} \\right) $$\n其中 $n$ 是电子密度，$\\varphi$ 是无量纲电势，$D$ 是扩散系数。连续性方程要求 $\\frac{dJ_n}{dx}=0$，这意味着在没有源或汇的任何段上 $J_n$ 是常数。\n\nScharfetter-Gummel方法将此方程离散化到连接节点 $i$ 和 $j$ 的网格边上。它假设电场 $-\\frac{d\\varphi}{dx}$ 沿边是恒定的。对于长度为 $L = |x_j - x_i|$、电势降为 $\\Delta\\varphi = \\varphi_j - \\varphi_i$ 的边，这得到 $\\frac{d\\varphi}{dx} = \\frac{\\Delta\\varphi}{L}$。然后可以求解 $n(x)$ 的常微分方程，满足边界条件 $n(x_i)=n_i$ 和 $n(x_j)=n_j$。求解常数通量 $J_n$ 即可得到著名的 SG 公式。从源节点 $i$ 到目标节点 $j$ 的粒子通量为：\n$$ J_{i \\to j} = \\frac{D}{L_{ij}} \\left[ n_i B(-\\Delta\\varphi) - n_j B(\\Delta\\varphi) \\right] $$\n其中 $L_{ij} = |x_j - x_i|$ 是边长，$B(x) = \\frac{x}{e^x - 1}$ 是伯努利函数，$\\Delta\\varphi = \\varphi_j - \\varphi_i$。\n\n**2.2. 伯努利函数**\n伯努利函数 $B(x)$ 在 $x=0$ 附近需要仔细的数值评估，因为直接的公式会导致 $0/0$ 的不定形式。其极限为 $\\lim_{x\\to0} B(x) = 1$。对于小的 $|x|$，`np.expm1(x)` 提供了 $e^x - 1$ 的精确值。然而，为了稳健地处理 $x=0$ 的情况以及周围的浮点值，我们将在 $|x|$ 小于一个很小的阈值时使用泰勒级数展开：\n$$ B(x) = 1 - \\frac{x}{2} + \\frac{x^2}{12} - O(x^4) $$\n对于 $|x|  10^{-10}$，这个展开式非常精确。对于较大的 $|x|$，使用 `np.expm1` 的直接公式 $x / (e^x - 1)$ 是稳定且高效的。\n\n**2.3. 算子组装**\n节点 $k$ 处的残差 $r_k$ 是离开围绕节点 $k$ 的控制体积的净粒子通量。对于一条有向边 $(i \\to j)$，通量 $J_{i \\to j}$ 离开节点 $i$ 并进入节点 $j$。因此，它对残差的贡献是：\n- $\\Delta r_i = +J_{i \\to j}$\n- $\\Delta r_j = -J_{i \\to j}$\n\n我们寻求矩阵 $A$ 使得 $\\mathbf{r} = A\\mathbf{n}$。将通量公式代入残差贡献中：\n$$ \\Delta r_i = \\left(\\frac{D}{L_{ij}} B(-\\Delta\\varphi)\\right) n_i - \\left(\\frac{D}{L_{ij}} B(\\Delta\\varphi)\\right) n_j $$\n$$ \\Delta r_j = -\\left(\\frac{D}{L_{ij}} B(-\\Delta\\varphi)\\right) n_i + \\left(\\frac{D}{L_{ij}} B(\\Delta\\varphi)\\right) n_j $$\n\n这直接给出了对每条边 $(i \\to j)$ 矩阵 $A$ 的更新：\n令 $g_{ij} = \\frac{D}{L_{ij}} B(-\\Delta\\varphi)$ 和 $g_{ji} = \\frac{D}{L_{ij}} B(\\Delta\\varphi)$。\n- $A_{ii} \\mathrel{+}= g_{ij}$\n- $A_{ij} \\mathrel{+}= -g_{ji}$\n- $A_{ji} \\mathrel{+}= -g_{ij}$\n- $A_{jj} \\mathrel{+}= g_{ji}$\n\n这个组装过程确保了关键属性：\n- **守恒性**：$A$ 中任何列 $k$ 的元素之和为零。这是因为对于影响列 $k$ 的每条边，一个相等且符号相反的量被加到两个不同的行中。这意味着对所有 $k$ 有 $\\sum_i A_{ik} = 0$，所以 $\\mathbf{1}^T A = \\mathbf{0}^T$。因此，对于任何密度向量 $\\mathbf{n}$，残差的全局总和 $\\sum_k r_k = \\mathbf{1}^T \\mathbf{r} = (\\mathbf{1}^T A)\\mathbf{n} = 0$。\n- **对称性**：如果电势恒定，则所有边的 $\\Delta\\varphi = 0$。那么 $B(0)=1$，所以 $g_{ij} = g_{ji} = D/L_{ij}$。更新规则变得对称：$A_{ij}$ 获得 $-D/L_{ij}$，$A_{ji}$ 也获得 $-D/L_{ij}$。最终得到的矩阵 $A$ 是对称的。\n- **方向不变性**：通量 $J_{j \\to i} = -J_{i \\to j}$。如果我们反转边的方向为 $(j \\to i)$，对 $r_j$ 的贡献变为 $+J_{j \\to i} = -J_{i \\to j}$，对 $r_i$ 的贡献变为 $-J_{j \\to i} = +J_{i \\to j}$。这些与边 $(i \\to j)$ 对残差的更新完全相同，因此最终组装的矩阵 $A$ 与所选的边方向无关。\n- **单调性**：SG方案被设计为单调的。这表现为组装的矩阵 $A$（对于纯输运问题）是一个非奇异M-矩阵，这要求正的对角线元素和非正的非对角线元素。由于对于所有实数 $x$，$B(x) > 0$，所以系数 $g_{ij}$ 和 $g_{ji}$ 总是正的。因此，非对角线元素 $A_{ij}$ 和 $A_{ji}$（对于 $i \\neq j$）是负项（如 $-g_{ji}$）的和，因此是非正的。对角线元素 $A_{ii}$ 是正项的和，因此是正的。\n\n实现将遵循此算法设计，为每个测试用例组装矩阵 $A$，计算残差 $\\mathbf{r}$，并执行指定的检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines, runs, and evaluates the test cases\n    for the Scharfetter-Gummel discretization.\n    \"\"\"\n\n    TOL = 1e-10\n\n    def B(x):\n        \"\"\"\n        Numerically stable Bernoulli function B(x) = x / (exp(x) - 1).\n        Uses a Taylor series expansion for small |x| to avoid numerical issues.\n        \"\"\"\n        if abs(x)  TOL:\n            # Taylor series: 1 - x/2 + x^2/12 - x^4/720 + ...\n            # The first three terms are sufficient for this tolerance.\n            return 1.0 - x / 2.0 + (x**2) / 12.0\n        else:\n            return x / np.expm1(x)\n\n    def assemble(nodes, edges, potential, D, n_vec):\n        \"\"\"\n        Assembles the Scharfetter-Gummel operator matrix A and computes the\n        residual vector r = A @ n.\n        \"\"\"\n        num_nodes = len(nodes)\n        A = np.zeros((num_nodes, num_nodes))\n\n        for i_src, i_tgt in edges:\n            # 1. Compute edge properties\n            L = abs(nodes[i_tgt] - nodes[i_src])\n            d_phi = potential[i_tgt] - potential[i_src]\n\n            # 2. Compute SG coefficients\n            # Flux J_{i->j} = g_ij * n_i - g_ji * n_j\n            # where g_ij = (D/L)*B(-d_phi) and g_ji = (D/L)*B(d_phi)\n            g_ij = (D / L) * B(-d_phi)\n            g_ji = (D / L) * B(d_phi)\n\n            # 3. Assemble contributions into the global matrix A\n            # Contribution to residual r_i is +J_{i->j}\n            A[i_src, i_src] += g_ij\n            A[i_src, i_tgt] -= g_ji\n\n            # Contribution to residual r_j is -J_{i->j}\n            A[i_tgt, i_src] -= g_ij\n            A[i_tgt, i_tgt] += g_ji\n\n        # 4. Compute residual\n        r = A @ n_vec\n        return A, r\n\n    # --- Test Cases ---\n\n    test_cases = [\n        {\n            \"name\": \"Test Case 1: Symmetric Diffusion\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges\": [(0, 1), (1, 2)],\n            \"potential\": np.array([0.0, 0.0, 0.0]),\n            \"D\": 1.0,\n            \"n\": np.array([1.0, 1.0, 1.0]),\n            \"check\": lambda A, r: (\n                np.allclose(A, A.T, atol=TOL, rtol=0) and\n                np.allclose(r, np.zeros_like(r), atol=TOL, rtol=0)\n            )\n        },\n        {\n            \"name\": \"Test Case 2: Conservation\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges\": [(0, 1), (1, 2)],\n            \"potential\": np.array([0.0, 0.1, 0.2]),\n            \"D\": 1.0,\n            \"n\": np.array([0.8, 1.1, 0.9]),\n            \"check\": lambda A, r: np.isclose(np.sum(r), 0.0, atol=TOL, rtol=0)\n        },\n        {\n            \"name\": \"Test Case 3: Orientation Invariance\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges_fwd\": [(0, 1), (1, 2)],\n            \"edges_rev\": [(1, 0), (2, 1)],\n            \"potential\": np.array([0.0, 0.1, 0.2]),\n            \"D\": 1.0,\n            \"n\": np.array([0.7, 1.0, 1.2]),\n            \"check\": lambda A_fwd, r_fwd, A_rev, r_rev: (\n                np.allclose(A_fwd, A_rev, atol=TOL, rtol=0) and\n                np.allclose(r_fwd, r_rev, atol=TOL, rtol=0)\n            )\n        },\n        {\n            \"name\": \"Test Case 4: Monotonicity\",\n            \"nodes\": np.array([0.0, 1.0]),\n            \"edges\": [(0, 1)],\n            \"potential\": np.array([0.0, 5.0]),\n            \"D\": 1.0,\n            \"n\": np.array([1.0, 2.0]),\n            \"check\": lambda A, r: (\n                # Off-diagonals non-positive (within tolerance)\n                (A[0, 1] = TOL) and (A[1, 0] = TOL) and\n                # Diagonals positive\n                (A[0, 0] > 0) and (A[1, 1] > 0) and\n                # Conservation\n                np.isclose(np.sum(r), 0.0, atol=TOL, rtol=0)\n            )\n        }\n    ]\n\n    results = []\n    \n    # Test Case 1\n    case = test_cases[0]\n    A1, r1 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A1, r1))\n\n    # Test Case 2\n    case = test_cases[1]\n    A2, r2 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A2, r2))\n\n    # Test Case 3\n    case = test_cases[2]\n    A_fwd, r_fwd = assemble(case[\"nodes\"], case[\"edges_fwd\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    A_rev, r_rev = assemble(case[\"nodes\"], case[\"edges_rev\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A_fwd, r_fwd, A_rev, r_rev))\n\n    # Test Case 4\n    case = test_cases[3]\n    A4, r4 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A4, r4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [str(r).lower() for r in results]))}]\")\n\nsolve()\n```"
        }
    ]
}