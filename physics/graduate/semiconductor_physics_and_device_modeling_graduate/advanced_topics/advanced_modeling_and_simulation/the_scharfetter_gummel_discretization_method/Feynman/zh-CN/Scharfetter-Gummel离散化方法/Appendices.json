{
    "hands_on_practices": [
        {
            "introduction": "Scharfetter-Gummel 方法的数值稳定性取决于其核心部分——伯努利函数 $B(\\xi)$ 的精确计算。这项实践  将指导你构建一个稳健的 $B(\\xi)$ 分段求值算法，以解决在零点附近的灾难性抵消以及在大参数值下的上溢/下溢问题。掌握这一技能是任何漂移-扩散模型实际应用的基础。",
            "id": "3780761",
            "problem": "必须编写一个程序来评估在半导体器件建模的漂移扩散方程的 Scharfetter–Gummel (SG) 离散化方法中使用的伯努利函数。Scharfetter–Gummel 方法依赖于在一个长度为 $\\Delta x$ 的网格边上，对具有恒定电场的稳态一维漂移扩散通量进行精确积分，其中使用了爱因斯坦关系式和通量在整个边上保持恒定的要求。得到的通量表达式引入了一个依赖于无量纲电势降的伯努利函数，这对于离散化的数值稳定性和物理一致性至关重要。从一个基本的基础开始，从一维的电子电流密度关系式入手，\n$$\nJ_n = q \\mu_n n E + q D_n \\frac{d n}{d x},\n$$\n其中 $q$ 是基本电荷，$\\mu_n$ 是电子迁移率，$D_n$ 是电子扩散系数，$n$ 是电子浓度，$E$ 是电场；将此与爱因斯坦关系式 $D_n = \\mu_n U_T$（其中 $U_T$ 是热电压）以及要求 $J_n$ 在一条边上恒定的稳态条件相结合。精确的边积分产生一个由电势降定义的无量纲宗量 $\\xi$，以及通量公式所需的一对伯努利函数求值 $B(\\xi)$ 和 $B(-\\xi)$。\n\n您的任务是构建一个数值稳定的算法蓝图，并加以实现，用于评估 $B(\\xi)$ 和 $B(-\\xi)$，该算法应避免在 $\\xi = 0$ 附近出现灾难性抵消，并能在不发生上溢或下溢的情况下处理 $\\xi$ 的极端值。该算法的设计必须仅基于对伯努利函数行为（包括级数展开、渐近分析和恒等式）的标准数学分析，而不依赖于问题陈述中提供的任何捷径公式。实现必须遵守以下约束：\n\n- 在 $\\xi = 0$ 附近使用 $B(\\xi)$ 的麦克劳林级数展开，以减轻相减抵消，并对小的 $|\\xi|$ 实现高相对精度。选择一个由级数分析证明是合理的截断阶数，并为 $|\\xi| \\leq 10^{-4}$ 提供至少 $10^{-12}$ 数量级的相对误差。\n- 对于中等大小的 $\\xi$ 值，以减少抵消的方式评估表达式，例如使用数值稳定的变换，如计算 $e^{\\xi} - 1$ 而不损失有效数字的操作。实现 $B(\\xi)$ 和 $B(-\\xi)$ 时，避免直接减去几乎相等的量。\n- 对于大的正或大的负 $\\xi$，使用适当的渐近近似来避免指数中的上溢或下溢，同时与 $B(\\xi)$ 和 $B(-\\xi)$ 的极限行为保持一致。\n- 尽管伯努利函数具有精确的对称性，但当 $|\\xi|$ 很大时，您必须避免数值上危险的恒等式用法，即当一个指数级小量乘以一个指数级大量时。\n\n编写一个程序，为以下测试集中的每个 $\\xi$ 评估 $B(\\xi)$ 和 $B(-\\xi)$：\n- $\\xi = 0$\n- $\\xi = 10^{-12}$\n- $\\xi = -10^{-12}$\n- $\\xi = 10^{-8}$\n- $\\xi = -10^{-8}$\n- $\\xi = 0.1$\n- $\\xi = -0.1$\n- $\\xi = 1$\n- $\\xi = -1$\n- $\\xi = 10$\n- $\\xi = -10$\n- $\\xi = 700$\n- $\\xi = -700$\n- $\\xi = 1000$\n- $\\xi = -1000$\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个结果本身是一个双元素列表 $[B(\\xi), B(-\\xi)]$。例如，输出应如下所示：\n$$\n[[B(\\xi_1),B(-\\xi_1)],[B(\\xi_2),B(-\\xi_2)],\\ldots]\n$$\n不涉及物理单位，因为 $\\xi$ 是无量纲的；所有输出都是浮点数。",
            "solution": "问题陈述要求开发并实现一个数值稳定的算法，以评估伯努利函数 $B(\\xi)$ 和 $B(-\\xi)$，作为 Scharfetter-Gummel 离散化方法的核心组成部分。\n\n## 问题验证\n\n### 第一步：提取已知条件\n- **物理背景**：用于半导体漂移扩散方程的 Scharfetter-Gummel (SG) 离散化。\n- **控制方程**：一维电子电流密度，$J_n = q \\mu_n n E + q D_n \\frac{d n}{d x}$，其中 $q$ 是基本电荷，$\\mu_n$ 是电子迁移率，$D_n$ 是电子扩散系数，$n$ 是电子浓度，$E$ 是电场。\n- **辅助关系式**：爱因斯坦关系式，$D_n = \\mu_n U_T$，其中 $U_T$ 是热电压。\n- **假设**：稳态（$J_n$ 恒定）和在长度为 $\\Delta x$ 的网格边上电场 $E$ 恒定。\n- **核心任务**：构建一个数值稳定的算法，用于评估伯努利函数 $B(\\xi)$ 及其对应项 $B(-\\xi)$，其中 $\\xi$ 是无量纲电势降。\n- **算法约束**：\n    1.  算法必须从对函数性质的基础数学分析中推导得出。\n    2.  对于小的 $|\\xi|$，必须使用麦克劳林级数展开以避免灾难性抵消。截断必须合理，以确保对于 $|\\xi| \\leq 10^{-4}$，相对误差约为 $10^{-12}$。\n    3.  对于中等大小的 $\\xi$ 值，必须使用数值稳定的形式。\n    4.  对于大的正或负 $\\xi$，必须使用渐近近似以防止上溢/下溢。\n    5.  必须避免使用数值上危险的恒等式。\n- **测试集**：一个包含 15 个 $\\xi$ 值的列表：$0, \\pm 10^{-12}, \\pm 10^{-8}, \\pm 0.1, \\pm 1, \\pm 10, \\pm 700, \\pm 1000$。\n- **输出格式**：一个单行，包含一个由双元素列表组成的列表，例如 `[[B(xi_1),B(-xi_1)],[B(xi_2),B(-xi_2)],...]`。\n\n### 第二步：使用提取的已知条件进行验证\n- **有科学依据**：该问题牢固地植根于半导体器件物理和数值分析。漂移扩散模型、爱因斯坦关系式以及 Scharfetter-Gummel 方法都是标准且成熟的概念。物理学是正确的。\n- **良构的**：任务定义清晰：实现一个特定的数学函数 $B(\\xi)$，并遵循明确的数值稳定性约束。输入（测试用例）和所需的输出格式都已精确指定。虽然没有给出 $B(\\xi)$ 的显式形式，但从所提供的物理方程推导它是该主题的标准部分，这使得问题对于知识渊博的实践者来说是自洽的。\n- **客观的**：问题以精确、技术性的语言陈述，没有主观性或歧义。\n- **缺陷分析**：\n    1.  *科学/事实不健全*：无。\n    2.  *不可形式化/不相关*：无。问题可直接形式化且高度相关。\n    3.  *不完整/矛盾的设置*：无。未提供 $B(\\xi)$ 的公式是问题的有意设计，需要从上下文中推导或识别它。\n    4.  *不切实际/不可行*：无。这些要求在高质量的数值软件中是标准的。\n    5.  *不适定/结构不良*：无。可以设计一个唯一的、稳定的解决方案。\n    6.  *伪深刻/琐碎*：无。该问题解决了计算物理学中一个真实而非琐碎的挑战。\n    7.  *超出科学可验证性*：无。结果在数学上是可验证的。\n\n### 第三步：结论与行动\n该问题是**有效的**。将制定完整的解决方案。\n\n## Scharfetter-Gummel 格式中伯努利函数的推导\n\n起点是一维稳态电子电流密度方程：\n$$\nJ_n = q \\mu_n n E + q D_n \\frac{d n}{d x}\n$$\n使用爱因斯坦关系式 $D_n = \\mu_n U_T$ 消去迁移率 $\\mu_n = D_n / U_T$，并将电场与静电势 $\\psi$ 通过 $E = -d\\psi/dx$ 联系起来，方程变为：\n$$\nJ_n = q \\frac{D_n}{U_T} n \\left(-\\frac{d\\psi}{dx}\\right) + q D_n \\frac{d n}{d x}\n$$\n两边除以 $q D_n$ 并定义归一化电势 $\\phi = \\psi / U_T$，我们得到：\n$$\n\\frac{J_n}{q D_n} = -n \\frac{d\\phi}{dx} + \\frac{d n}{d x}\n$$\n这是一个关于电子密度 $n(x)$ 的一阶线性常微分方程。假设 $J_n$ 和 $D_n$ 在从 $x_i$ 到 $x_{i+1}$ 的网格区间上是常数，我们可以写出：\n$$\n\\frac{d}{dx} \\left(n(x) e^{-\\phi(x)}\\right) = \\left(\\frac{d n}{d x} - n \\frac{d\\phi}{dx}\\right) e^{-\\phi(x)} = \\frac{J_n}{q D_n} e^{-\\phi(x)}\n$$\n从 $x_i$ 到 $x_{i+1}$ 积分：\n$$\nn_{i+1} e^{-\\phi_{i+1}} - n_i e^{-\\phi_i} = \\frac{J_n}{q D_n} \\int_{x_i}^{x_{i+1}} e^{-\\phi(x)} dx\n$$\n其中 $n_k = n(x_k)$ 且 $\\phi_k = \\phi(x_k)$。关键的 Scharfetter-Gummel 假设是电场 $E$ 在节点之间是恒定的，这意味着归一化电势 $\\phi(x)$ 是线性的。令 $\\xi = \\phi_{i+1} - \\phi_i$ 为长度为 $\\Delta x = x_{i+1} - x_i$ 的区间上的归一化电势降。线性电势为 $\\phi(x) = \\phi_i + \\xi \\frac{x-x_i}{\\Delta x}$。该积分的计算结果为：\n$$\n\\int_{x_i}^{x_{i+1}} e^{-\\left(\\phi_i + \\xi \\frac{x-x_i}{\\Delta x}\\right)} dx = e^{-\\phi_i} \\Delta x \\frac{1 - e^{-\\xi}}{\\xi}\n$$\n将此代回并解出 $J_n$：\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} e^{\\phi_i} (n_{i+1} e^{-\\phi_{i+1}} - n_i e^{-\\phi_i})\n$$\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} (n_{i+1} e^{\\phi_i - \\phi_{i+1}} - n_i) = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} (n_{i+1} e^{-\\xi} - n_i)\n$$\n为了揭示标准形式，我们分配前置因子：\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\left( n_{i+1} \\frac{\\xi e^{-\\xi}}{1 - e^{-\\xi}} - n_i \\frac{\\xi}{1-e^{-\\xi}} \\right)\n$$\n通过定义伯努利函数为 $B(x) = \\frac{x}{e^x - 1}$，我们可以识别出这些项。第一项的系数是 $\\frac{\\xi e^{-\\xi}}{1 - e^{-\\xi}} = \\frac{\\xi}{e^{\\xi} - 1} = B(\\xi)$。第二项的系数是 $\\frac{\\xi}{1-e^{-\\xi}} = \\frac{-\\xi}{e^{-\\xi}-1} = B(-\\xi)$。因此，离散化的电流密度是：\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\left[ n_{i+1} B(\\xi) - n_i B(-\\xi) \\right]\n$$\n这个推导证实了核心计算任务是对 $B(\\xi) = \\frac{\\xi}{e^\\xi - 1}$ 进行稳定评估。\n\n## 数值实现策略\n\n函数 $B(\\xi) = \\frac{\\xi}{e^{\\xi} - 1}$ 在 $\\xi$ 的某些范围内存在数值困难。一个稳健的实现需要一个覆盖三个不同宗量 $\\xi$ 区间的分段方法。\n\n### 区间 1：小的 $|\\xi|$\n当 $\\xi \\to 0$ 时，分子和分母都趋近于零。直接评估会导致 $0/0$ 不定型，并且由于 $e^\\xi \\approx 1$，在浮点运算中会遭受灾难性抵消。我们使用麦克劳林级数展开，它源自伯努利数 $b_k$ 的生成函数：\n$$\nB(\\xi) = \\sum_{k=0}^{\\infty} b_k \\frac{\\xi^k}{k!} = b_0 + b_1 \\xi + \\frac{b_2}{2!} \\xi^2 + \\frac{b_4}{4!} \\xi^4 + \\frac{b_6}{6!} \\xi^6 + \\dots\n$$\n使用已知的伯努利数值 ($b_0=1, b_1=-1/2, b_2=1/6, b_4=-1/30, b_6=1/42$ 且对于 $k\\ge1$ 有 $b_{2k+1}=0$)，级数为：\n$$\nB(\\xi) = 1 - \\frac{1}{2}\\xi + \\frac{1}{12}\\xi^2 - \\frac{1}{720}\\xi^4 + \\frac{1}{30240}\\xi^6 - \\frac{1}{1209600}\\xi^8 + O(\\xi^{10})\n$$\n问题要求对于 $|\\xi| \\leq 10^{-4}$，相对误差约为 $10^{-12}$。让我们在 $\\xi^6$ 项之后截断级数。主误差项是 $-\\frac{\\xi^8}{1209600}$。在该区域的边界 $|\\xi| = 10^{-4}$ 处，绝对误差约为 $\\frac{(10^{-4})^8}{1209600} \\approx 8.3 \\times 10^{-39}$。由于在该区域 $B(\\xi) \\approx 1$，这个绝对误差也是相对误差。这个精度水平远超要求，确保了方法的稳健性。选择的近似是：\n$$\nB(\\xi) \\approx 1 - \\frac{\\xi}{2} + \\frac{\\xi^2}{12} - \\frac{\\xi^4}{720} + \\frac{\\xi^6}{30240}\n$$\n\n### 区间 2：大的 $|\\xi|$\n对于大的 $|\\xi|$ 值，项 $e^\\xi$ 可能导致上溢（大的正 $\\xi$）或下溢（大的负 $\\xi$）。在这些情况下，我们使用渐近近似。\n- **对于大的正 $\\xi$**：当 $\\xi \\to +\\infty$，$e^\\xi \\to \\infty$。分母 $e^\\xi - 1 \\approx e^\\xi$。\n  $$ B(\\xi) = \\frac{\\xi}{e^\\xi-1} \\approx \\frac{\\xi}{e^\\xi} = \\xi e^{-\\xi} \\to 0 $$\n  对于标准的双精度浮点数，当 $\\xi \\approx 709.7$ 时，$e^\\xi$ 会上溢。我们选择一个保守的阈值，例如 $\\xi > 37$。对于 $\\xi=37$，$B(37) \\approx 37 e^{-37} \\approx 3.0 \\times 10^{-15}$，这已经低于机器精度。因此，对于 $\\xi > 37$，我们可以安全地近似 $B(\\xi) = 0$。\n- **对于大的负 $\\xi$**：令 $\\xi = -z$，其中 $z \\to +\\infty$。\n  $$ B(\\xi) = B(-z) = \\frac{-z}{e^{-z} - 1} $$\n  当 $z \\to \\infty$ 时，$e^{-z} \\to 0$。分母趋近于 $-1$。\n  $$ B(\\xi) \\approx \\frac{-z}{-1} = z = -\\xi $$\n  该近似的误差是 $B(\\xi) - (-\\xi) = \\frac{\\xi}{e^{\\xi}-1} + \\xi = \\frac{\\xi e^{\\xi}}{e^\\xi-1}$。对于 $\\xi  -37$，此误差的量级为 $|\\xi|e^{\\xi}$，它会下溢到零。因此，对于 $\\xi  -37$，我们近似 $B(\\xi) = -\\xi$。\n\n### 区间 3：中等的 $|\\xi|$\n对于那些对于级数展开来说不够小，对于渐近近似来说又不够大的 $\\xi$ 值（即 $10^{-4}  |\\xi| \\leq 37$），可以使用直接公式 $B(\\xi) = \\frac{\\xi}{e^\\xi - 1}$。为了在靠近小 $|\\xi|$ 边界时保持精度，分母 $e^\\xi - 1$ 应使用专门的库函数（如 `expm1(\\xi)`）来计算，即使当 $\\xi$ 接近零时，该函数也能精确计算表达式。\n\n## 算法蓝图\n基于上述分析，我们可以分段定义函数 $B(\\xi)$：\n$$\nB(\\xi) =\n\\begin{cases}\n    1 - \\frac{1}{2}\\xi + \\frac{\\xi^2}{12} - \\frac{\\xi^4}{720} + \\frac{\\xi^6}{30240}  \\text{如果 } |\\xi| \\leq 10^{-4} \\\\\n    -\\xi  \\text{如果 } \\xi  -37 \\\\\n    0  \\text{如果 } \\xi > 37 \\\\\n    \\frac{\\xi}{e^{\\xi}-1}  \\text{其他情况}\n\\end{cases}\n$$\n该算法为在整个实数范围内评估伯努利函数提供了一个完整、稳健且精确的方法，满足了问题的所有约束。对于每个测试值 $\\xi_k$，我们将通过调用此函数两次来计算对 $[B(\\xi_k), B(-\\xi_k)]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating the Bernoulli functions B(xi) and B(-xi)\n    for a given set of test cases using a numerically stable algorithm.\n    \"\"\"\n\n    # The test cases for xi provided in the problem statement.\n    test_cases = [\n        0,\n        1e-12,\n        -1e-12,\n        1e-8,\n        -1e-8,\n        0.1,\n        -0.1,\n        1.0,\n        -1.0,\n        10.0,\n        -10.0,\n        700.0,\n        -700.0,\n        1000.0,\n        -1000.0,\n    ]\n\n    def bernoulli(xi):\n        \"\"\"\n        Computes the Bernoulli function B(xi) = xi / (exp(xi) - 1)\n        using a numerically stable piecewise implementation.\n\n        Args:\n            xi (float): The input argument, a dimensionless potential drop.\n\n        Returns:\n            float: The value of B(xi).\n        \"\"\"\n        # Regime 1: Small |xi|. Use Maclaurin series expansion to avoid\n        # catastrophic cancellation from exp(xi) - 1 approaching 0.\n        # The threshold 1e-4 is from the problem statement.\n        if abs(xi) = 1e-4:\n            # B(xi) = 1 - xi/2 + xi^2/12 - xi^4/720 + xi^6/30240 - ...\n            # Using Horner's method for efficient polynomial evaluation.\n            xi2 = xi * xi\n            # Coefficients from b_k / k!\n            c0 = 1.0\n            c1 = -0.5\n            c2 = 1.0/12.0\n            c4 = -1.0/720.0\n            c6 = 1.0/30240.0\n            \n            # Truncating at O(xi^6) gives more than enough precision.\n            return c0 + xi * (c1 + xi * (c2 + xi2 * (c4 + xi2 * c6)))\n\n        # Regime 2: Large negative xi.\n        # B(xi) approaches -xi as xi -> -inf.\n        # The threshold -37 is chosen as exp(xi) underflows below this value\n        # and the asymptotic approximation is highly accurate.\n        if xi  -37.0:\n            return -xi\n\n        # Regime 3: Large positive xi.\n        # B(xi) approaches 0 as xi -> +inf.\n        # The threshold +37 is chosen as exp(xi) is very large and B(xi) is\n        # smaller than machine precision.\n        if xi > 37.0:\n            return 0.0\n\n        # Regime 4: Moderate |xi|. The direct formula is stable.\n        # Use np.expm1(xi) to compute exp(xi) - 1 accurately.\n        return xi / np.expm1(xi)\n\n    results = []\n    for xi_val in test_cases:\n        # For each xi, calculate both B(xi) and B(-xi)\n        b_xi = bernoulli(xi_val)\n        b_minus_xi = bernoulli(-xi_val)\n        results.append([b_xi, b_minus_xi])\n\n    # The final print statement must produce only the specified single-line format.\n    # str(list) automatically adds the '[...]' formatting.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为什么 Scharfetter-Gummel (SG) 格式在半导体器件仿真中应用如此广泛？这项实践  通过一个包含剧烈电势变化的测试问题，将 SG 方法与更简单的一阶迎风和中心差分格式进行对比，从而给出了一个直观的答案。通过实现和分析这些方法，你将直接观察到 SG 离散格式卓越的精度和物理一致性（保持正定性），尤其是在解析边界层方面的优势。",
            "id": "3780759",
            "problem": "考虑半导体器件中漂移-扩散框架下的一维稳态电子输运。设空间域为闭区间 $[0,1]$，其上有一个包含 $N$ 个节点的均匀网格，无量纲静电势表示为 $\\phi(x)$。假设在 $x_0$ 处存在一个宽度为 $\\delta$、总幅度为 $\\Delta\\Phi$ 的急剧电势降，因此 $\\phi(x)$ 由左侧的恒定区域、区间 $[x_0-\\delta/2, x_0+\\delta/2]$ 上斜率为 $\\Delta\\Phi/\\delta$ 的线性斜坡区域以及右侧的恒定区域分段定义。具体定义如下\n$$\n\\phi(x) = \n\\begin{cases}\n0,  x \\le x_0 - \\delta/2, \\\\\n\\frac{\\Delta\\Phi}{\\delta}\\,\\left(x - \\left(x_0 - \\frac{\\delta}{2}\\right)\\right),  x_0 - \\delta/2  x  x_0 + \\delta/2, \\\\\n\\Delta\\Phi,  x \\ge x_0 + \\delta/2.\n\\end{cases}\n$$\n假设采用无量纲标度，电子扩散系数等于 $1$，并使用迁移率和扩散系数之间的爱因斯坦关系来证明此归一化的合理性。无量纲形式下的电子通量 $J_n$ 由基本输运原理推导出的漂移-扩散定律给出，\n$$\nJ_n(x) = -\\left(\\frac{dn}{dx} + n(x)\\,\\frac{d\\phi}{dx}\\right),\n$$\n其中 $n(x)$ 是电子密度。考虑平衡零通量情况 $J_n(x) \\equiv 0$。在此平衡假设下，连续解满足玻尔兹曼关系 $n(x) \\propto \\exp(-\\phi(x))$。对所有情况施加左侧狄利克雷边界条件 $n(0) = 1$，因此网格上的精确参考解为 $n_{\\text{exact}}(x_i) = \\exp(-\\phi(x_i))$。\n\n您的任务是实现三种不同的数值离散化方法，用于在网格单元上求解 $n$ 的零通量平衡递推关系，从 $n(0)=1$ 开始：\n\n- 对流项的一阶迎风有限差分離散化（根据局部单元电势增量的符号选择迎风状态）。\n- 对流项的二阶中心有限差分離散化。\n- 在局部场恒定的假设下，通过对每个单元上的漂移-扩散方程进行精确积分得到的 Scharfetter-Gummel (SG) 离散化。\n\n不要使用任何来自外部来源的预先推导的离散化公式；从控制通量定律和所述假设出发，推导每个递推关系。对于每个单元 $[x_i,x_{i+1}]$，计算局部电势增量 $\\Delta\\phi_i = \\phi(x_{i+1}) - \\phi(x_i)$，并根据每种方案用它将 $n_i$ 传播到 $n_{i+1}$。对于 SG 方法，使用在局部场恒定下精确积分所隐含的相应单元关系。\n\n数值网格构建细节：\n\n- 使用一个包含 $N$ 个节点的均匀网格，其中 $x_i = i/(N-1)$，$i=0,1,\\dots,N-1$。\n- 使用给定的 $\\Delta\\Phi$、$\\delta$ 和 $x_0$，根据上述分段定义精确构建 $\\phi(x_i)$。\n\n为每种方法和每个测试用例计算的评估指标：\n\n- 右边界处的绝对误差，定义为 $|n_{\\text{method}}(x_{N-1}) - n_{\\text{exact}}(x_{N-1})|$。\n- 一个正性布尔值，指示所有计算出的节点密度在整个域内是否严格为正。\n- 最大绝对节点误差，定义为 $\\max_i |n_{\\text{method}}(x_i) - n_{\\text{exact}}(x_i)|$。\n\n测试套件：\n\n为以下参数集计算上述指标，这些参数集共同涵盖了适度的“理想”情况和日益尖锐的边界层：\n\n- 情况 1：$N=100$, $\\Delta\\Phi=1$, $\\delta=0.2$, $x_0=0.5$。\n- 情况 2：$N=100$, $\\Delta\\Phi=5$, $\\delta=0.02$, $x_0=0.5$。\n- 情况 3：$N=200$, $\\Delta\\Phi=10$, $\\delta=0.01$, $x_0=0.5$。\n\n最终输出格式：\n\n你的程序應生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个包含七个条目的列表，按以下顺序排列：\n$[$Scharfetter-Gummel 的右端绝对誤差，迎风法的右端绝对誤差，中心差分法的右端绝对誤差，迎风法的正性布尔值，中心差分法的正性布尔值，所有节点上迎风法的最大绝对誤差，所有节点上中心差分法的最大绝对誤差$]$。\n\n將所有三个测试用例的结果汇总为这些逐例列表的列表。例如，最终输出应类似于\n$[[\\ldots],[\\ldots],[\\ldots]]$\n，不含空格。",
            "solution": "所提出的问题是半导体输运方程数值分析中一个有效且适定的练习。它在科学上基于漂移-扩散模型，提供了一套完整且一致的参数，并要求将标准数值格式与解析解进行有意义的比较。我们将首先推导三种指定离散化方法的递推关系，然后实现它们以计算所需的误差指标。\n\n控制物理定律是一维稳态电子通量 $J_n$ 的漂移-扩散方程。在指定的平衡条件下 ($J_n(x) \\equiv 0$)，方程简化为：\n$$\nJ_n(x) = -\\left(\\frac{dn}{dx} + n(x)\\,\\frac{d\\phi}{dx}\\right) = 0\n$$\n其中 $n(x)$ 是电子密度，$\\phi(x)$ 是无量纲静电势。这是关于 $n(x)$ 的一阶常微分方程（ODE）：\n$$\n\\frac{dn}{dx} = -n(x)\\frac{d\\phi}{dx}\n$$\n问题指定了一个包含 $N$ 个节点的均匀网格，$x_i = i/(N-1)$，$i=0, 1, \\dots, N-1$。设网格间距为 $h = x_{i+1} - x_i = 1/(N-1)$。我们的任务是推导递推关系，以根据前一个节点的值 $n_i = n(x_i)$ 来计算节点密度 $n_{i+1} = n(x_{i+1})$。设 $\\Delta\\phi_i = \\phi(x_{i+1}) - \\phi(x_i) = \\phi_{i+1} - \\phi_i$ 为单元 $[x_i, x_{i+1}]$ 上的电势差。\n\n在边界条件 $n(0)=1$ 和 $\\phi(0)=0$ 下，该常微分方程的连续解是 $n(x) = \\exp(-\\phi(x))$。这将作为我们在网格上的精确参考解：$n_{\\text{exact}}(x_i) = \\exp(-\\phi(x_i))$。\n\n三种数值格式都近似计算单元 $[x_i, x_{i+1}]$ 中点处的通量 $J_{n, i+1/2}$ 并将其设为零。一个简单的通量有限差分近似是：\n$$\nJ_{n, i+1/2} \\approx -\\left(\\frac{n_{i+1} - n_i}{h} + n_{i+1/2} \\frac{\\phi_{i+1} - \\phi_i}{h}\\right) = 0\n$$\n这导致了核心的离散关系，三种格式对此有不同的解释：\n$$\nn_{i+1} - n_i + n_{i+1/2} (\\phi_{i+1} - \\phi_i) = 0\n$$\n其中 $n_{i+1/2}$ 是单元界面处密度的近似值。\n\n**1. 中心有限差分離散化**\n\n该格式使用节点密度的简单算术平均值来近似界面密度 $n_{i+1/2}$：\n$$\nn_{i+1/2} \\approx \\frac{n_i + n_{i+1}}{2}\n$$\n将其代入核心关系得到：\n$$\nn_{i+1} - n_i + \\left(\\frac{n_i + n_{i+1}}{2}\\right) \\Delta\\phi_i = 0\n$$\n我们求解 $n_{i+1}$：\n$$\nn_{i+1} \\left(1 + \\frac{\\Delta\\phi_i}{2}\\right) = n_i \\left(1 - \\frac{\\Delta\\phi_i}{2}\\right)\n$$\n$$\nn_{i+1} = n_i \\frac{1 - \\Delta\\phi_i/2}{1 + \\Delta\\phi_i/2} = n_i \\frac{2 - \\Delta\\phi_i}{2 + \\Delta\\phi_i}\n$$\n对于小的 $\\Delta\\phi_i$，这个递推关系是二阶精确的。然而，如果 $|\\Delta\\phi_i| > 2$，即使 $n_i$ 为正，计算出的 $n_{i+1}$也可能变为负值，这违反了载流子密度为正的物理约束。\n\n**2. 一阶迎风有限差分離散化**\n\n迎风格式通过选择上游节点值来近似 $n_{i+1/2}$。“流”的方向由电场符号决定，$E_{i+1/2} \\approx \\Delta\\phi_i/h$。\n\n- 如果 $E_{i+1/2} > 0$ (即 $\\Delta\\phi_i > 0$)，对流场从 $i$ 指向 $i+1$。上游节点是 $i$，所以我们设 $n_{i+1/2} = n_i$。递推关系变为：\n  $$\n  n_{i+1} - n_i + n_i \\Delta\\phi_i = 0 \\implies n_{i+1} = n_i (1 - \\Delta\\phi_i)\n  $$\n- 如果 $E_{i+1/2}  0$ (即 $\\Delta\\phi_i  0$)，对流场从 $i+1$ 指向 $i$。上游节点是 $i+1$，所以我们设 $n_{i+1/2} = n_{i+1}$。递推关系变为：\n  $$\n  n_{i+1} - n_i + n_{i+1} \\Delta\\phi_i = 0 \\implies n_{i+1}(1+\\Delta\\phi_i) = n_i \\implies n_{i+1} = \\frac{n_i}{1 + \\Delta\\phi_i}\n  $$\n- 如果 $\\Delta\\phi_i = 0$，两个公式都正确地得出 $n_{i+1}=n_i$。\n\n该格式只有一阶精度，但比中心差分格式更稳定。然而，如果 $\\Delta\\phi_i > 1$ 或 $\\Delta\\phi_i \\le -1$，它仍然可能产生非物理的负密度。\n\n**3. Scharfetter-Gummel (SG) 离散化**\n\nSG 格式的推导基于一个假设，即在每个单元 $[x_i, x_{i+1}]$ 内，通量 $J_n$ 和电场 $E$ 是恒定的。恒定场为 $E = \\Delta\\phi_i/h$。在这些假设下，漂移-扩散方程在单元内变成一个具有常系数的一阶线性常微分方程：\n$$\n\\frac{dn}{dx} + E n(x) = -\\frac{J_n}{D_n}\n$$\n根据指定的归一化 $D_n=1$，我们有：\n$$\n\\frac{dn}{dx} + E n(x) = -J_n\n$$\n这个常微分方程可以使用积分因子 $e^{E(x-x_i)}$ 在区间 $[x_i, x_{i+1}]$ 上精确求解。其解将节点密度与恒定通量 $J_n$ 联系起来：\n$$\nJ_n = -\\frac{D_n E}{e^{Eh}-1} \\left( n_{i+1}e^{Eh} - n_i \\right)\n$$\n代入 $D_n=1$，$E=\\Delta\\phi_i/h$，并简化，得到著名的 SG 电流关系：\n$$\nJ_{n, i+1/2} = -\\frac{1}{h} \\left( n_{i+1} B(-\\Delta\\phi_i) - n_i B(\\Delta\\phi_i) \\right)\n$$\n其中 $B(x) = x/(e^x - 1)$ 是伯努利函数。\n\n对于平衡情况，我们强制 $J_{n, i+1/2} = 0$：\n$$\nn_{i+1} B(-\\Delta\\phi_i) - n_i B(\\Delta\\phi_i) = 0\n$$\n$$\nn_{i+1} = n_i \\frac{B(\\Delta\\phi_i)}{B(-\\Delta\\phi_i)}\n$$\n代入伯努利函数的定义：\n$$\n\\frac{B(\\Delta\\phi_i)}{B(-\\Delta\\phi_i)} = \\frac{\\Delta\\phi_i / (e^{\\Delta\\phi_i}-1)}{-\\Delta\\phi_i / (e^{-\\Delta\\phi_i}-1)} = -\\frac{e^{-\\Delta\\phi_i}-1}{e^{\\Delta\\phi_i}-1} = -\\frac{e^{-\\Delta\\phi_i}(1-e^{\\Delta\\phi_i})}{e^{\\Delta\\phi_i}-1} = e^{-\\Delta\\phi_i}\n$$\n因此，对于零通量情况，SG 递推关系简化为：\n$$\nn_{i+1} = n_i e^{-\\Delta\\phi_i}\n$$\n这个递推关系与精确解析解 $n(x_i) = \\exp(-\\phi(x_i))$ 中相邻点之间的关系完全相同。因此，SG 方法将以机器精度计算节点密度，相关的误差几乎为零。这展示了该方法的能力，因为它在数值上保持了物理的玻尔兹曼关系。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D drift-diffusion problem for three schemes and reports metrics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, DeltaPhi, delta, x0)\n        (100, 1.0, 0.2, 0.5),\n        (100, 5.0, 0.02, 0.5),\n        (200, 10.0, 0.01, 0.5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, dPhi, delta, x0 = case\n        \n        # 1. Construct grid and potential profile\n        x = np.linspace(0.0, 1.0, N)\n        \n        phi = np.zeros(N)\n        left_boundary = x0 - delta / 2.0\n        right_boundary = x0 + delta / 2.0\n        \n        # Vectorized calculation of the piecewise potential\n        in_ramp = (x > left_boundary)  (x  right_boundary)\n        right_of_ramp = x >= right_boundary\n        \n        if delta > 0:\n            phi[in_ramp] = (dPhi / delta) * (x[in_ramp] - left_boundary)\n        phi[right_of_ramp] = dPhi\n        \n        # 2. Compute exact solution\n        n_exact = np.exp(-phi)\n        \n        # 3. Initialize solution arrays for the three methods\n        n_sg = np.zeros(N)\n        n_upwind = np.zeros(N)\n        n_central = np.zeros(N)\n        \n        # Apply Dirichlet boundary condition at x=0\n        n_sg[0] = 1.0\n        n_upwind[0] = 1.0\n        n_central[0] = 1.0\n        \n        # 4. March across the grid and apply recurrence relations\n        for i in range(N - 1):\n            dphi_i = phi[i+1] - phi[i]\n            \n            # Scharfetter-Gummel\n            n_sg[i+1] = n_sg[i] * np.exp(-dphi_i)\n            \n            # Upwind\n            if dphi_i > 0:\n                n_upwind[i+1] = n_upwind[i] * (1.0 - dphi_i)\n            else: # dphi_i = 0\n                # Avoid division by zero, though not expected for these test cases\n                denom = 1.0 + dphi_i\n                if abs(denom)  1e-15:\n                    # In this edge case, density would blow up, use large number\n                    n_upwind[i+1] = np.finfo(float).max\n                else:\n                    n_upwind[i+1] = n_upwind[i] / denom\n\n            # Central Difference\n            denom = 2.0 + dphi_i\n            if abs(denom)  1e-15:\n                 # In this edge case, density would blow up, use large number\n                n_central[i+1] = np.finfo(float).max\n            else:\n                 n_central[i+1] = n_central[i] * (2.0 - dphi_i) / denom\n                 \n        # 5. Calculate evaluation metrics\n        err_sg_end = abs(n_sg[-1] - n_exact[-1])\n        err_up_end = abs(n_upwind[-1] - n_exact[-1])\n        err_cen_end = abs(n_central[-1] - n_exact[-1])\n        \n        pos_up = bool(np.all(n_upwind > 0))\n        pos_cen = bool(np.all(n_central > 0))\n        \n        max_err_up = np.max(np.abs(n_upwind - n_exact))\n        max_err_cen = np.max(np.abs(n_central - n_exact))\n        \n        # Assemble results for the current case in the specified order\n        case_results = [\n            err_sg_end, err_up_end, err_cen_end,\n            pos_up, pos_cen,\n            max_err_up, max_err_cen\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Using str() and replace() is a robust way to get the required format\n    # with no spaces and correct boolean representation.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "完整的器件仿真需要将局部的边通量组装成一个全局方程组。这项实践  聚焦于一项关键任务：如何以一种一致且守恒的方式，利用独立的 Scharfetter-Gummel 通量构建全局算子矩阵。你将学习如何管理边的方向和符号约定，以确保像粒子数守恒这样的基本物理定律在离散层面得以维持，并观察在特定物理条件下矩阵对称性等性质是如何产生的。",
            "id": "3780755",
            "problem": "考虑一个通过有限体积法 (FVM) 使用 Scharfetter-Gummel (SG) 边通量组装的漂移-扩散半导体输运模型的一维离散化。所有物理量都已通过热电压进行无量纲化处理，因此本问题中没有物理单位。其基本基础是稳态电子连续性方程和漂移-扩散本构律：电子电流密度的散度为零，电子电流密度是漂移和扩散之和，且扩散系数与迁移率之间满足爱因斯坦关系。您的任务是设计并实现一个全局离散算子的方向一致性组装，该算子将节点电子密度映射到每个节点的净有向通量残差。\n\n第一性原理出发点：\n- 稳态电子连续性定律指出，电子电流密度的散度为零，这在离散层面通过平衡每个控制体中流出和流入的边通量之和来强制执行。\n- 电子输运的漂移-扩散本构律是与电场和密度成正比的漂移项，以及与密度梯度成正比的扩散项之和，其中爱因斯坦关系通过热电压将扩散系数与迁移率联系起来。\n- Scharfetter-Gummel 离散化是通过假设沿一条边的电场恒定以及密度的指数变化得到的，从而产生一个封闭形式、单调且保守的边通量公式，该公式取决于跨边的电势降和节点密度。\n- 在指数拟合下，伯努利响应函数自然地出现在 SG 边通量中，并且必须以数值稳定的方式进行评估，尤其是在参数接近零时。\n\n边方向和全局守恒要求：\n- 连接两个节点的每条边都必须被赋予一个从源节点到目标节点的一致方向。方向的选择是任意的，但在组装时必须保持一致使用。\n- 每条边通量对其两个关联节点的残差的贡献必须带有符号，以使离开一个节点的通量恰好进入另一个节点，从而确保局部守恒，并保证对于仅有内部网格的情况，所有残差的全局总和为零。\n- 当电势恒定（零电场）时，组装的算子简化为一个纯扩散算子，对于具有恒定扩散系数的均匀一维网格，该算子是对称的。\n\n您的程序必须：\n1. 以数值稳定的方式实现伯努利响应函数，记为 $B(x)$，并在 $x = 0$ 处有明确定义的极限。\n2. 对于给定的节点坐标为 $\\{x_i\\}$ 的一维网格、一个有向边集 $\\{(i \\rightarrow j)\\}$、节点电势 $\\{\\varphi_i\\}$ 和一个恒定的扩散系数 $D$，组装一个全局矩阵 $A$ 并为给定的节点电子密度向量 $\\mathbf{n}$ 计算残差 $\\mathbf{r} = A \\mathbf{n}$。组装必须使用一致的边方向，并对边的贡献进行符号标记，以使加到源节点的通量贡献是减去目标节点贡献的负值，从而保证守恒性。\n3. 通过测试用例验证组装是守恒的、方向无关的，并在适当情况下是对称的。\n\n测试套件和参数（所有量均为无量纲）：\n- 测试用例 1（对称扩散和恒定解）：\n  - 节点：$x = [\\,0.0,\\,0.5,\\,1.0\\,]$。\n  - 有向边：$(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$。\n  - 电势：$\\varphi = [\\,0.0,\\,0.0,\\,0.0\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,1.0,\\,1.0,\\,1.0\\,]$。\n  - 必要检查：矩阵 $A$ 是对称的（在数值容差范围内），残差 $\\mathbf{r}$ 是零向量（在数值容差范围内）。\n\n- 测试用例 2（非零电场下的守恒性）：\n  - 节点：$x = [\\,0.0,\\,0.5,\\,1.0\\,]$。\n  - 有向边：$(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$。\n  - 电势：$\\varphi = [\\,0.0,\\,0.1,\\,0.2\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,0.8,\\,1.1,\\,0.9\\,]$。\n  - 必要检查：全局总和 $\\sum_i r_i$ 在数值上为零，证明守恒性。\n\n- 测试用例 3（方向无关性）：\n  - 节点：$x = [\\,0.0,\\,0.5,\\,1.0\\,]$。\n  - 两个描述相同物理连接的有向边集：\n    - 正向方向：$(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$。\n    - 反向方向：$(1 \\rightarrow 0)$, $(2 \\rightarrow 1)$。\n  - 电势：$\\varphi = [\\,0.0,\\,0.1,\\,0.2\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,0.7,\\,1.0,\\,1.2\\,]$。\n  - 必要检查：由两种方向组装的矩阵和残差在数值容差范围内是相同的。\n\n- 测试用例 4（边界边和强电场下的单调性）：\n  - 节点：$x = [\\,0.0,\\,1.0\\,]$。\n  - 有向边：$(0 \\rightarrow 1)$。\n  - 电势：$\\varphi = [\\,0.0,\\,5.0\\,]$。\n  - 扩散系数：$D = 1.0$。\n  - 密度：$\\mathbf{n} = [\\,1.0,\\,2.0\\,]$。\n  - 必要检查：组装的 $A$ 的非对角元是非正的，对角元是正的，并且全局总和 $\\sum_i r_i$ 在数值上为零。\n\n算法要求：\n- 对于一条边 $(i \\rightarrow j)$，计算每条边的长度 $L$ 为 $L = |x_j - x_i|$。\n- 在计算电势降 $\\,\\Delta \\varphi = \\varphi_j - \\varphi_i\\,$ 和组装带符号的贡献到 $A$ 和 $\\mathbf{r}$ 时，对每条边使用单一、一致的方向。\n- 在检查浮点值相等时，使用 $10^{-10}$ 的数值容差。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3,result4]$），其中每个 $result$ 是一个布尔值，指示相应的测试用例是否通过。布尔值必须以编程语言的规范布尔形式打印。",
            "solution": "该问题要求设计并实现一个程序，用于组装一维、稳态、漂移-扩散电子输运模型的全局离散算子。组装必须在有限体积法 (FVM) 框架内使用 Scharfetter-Gummel (SG) 离散化方案。得到的算子，即一个矩阵 $A$，将节点电子密度向量 $\\mathbf{n}$ 映射到节点通量残差向量 $\\mathbf{r}$，使得 $\\mathbf{r} = A\\mathbf{n}$。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **模型**：一维、稳态电子连续性方程，带有漂移-扩散本构律。所有物理量都已通过热电压进行无量纲化。\n- **离散化**：有限体积法，使用 Scharfetter-Gummel 边通量。\n- **方程（连续性）**：$\\nabla \\cdot \\mathbf{J}_n = 0$，离散化为每个控制体上的通量平衡。\n- **方程（本构）**：电子电流密度 $\\mathbf{J}_n$ 是漂移（与电场和密度成正比）和扩散（与密度梯度成正比）之和。假设爱因斯坦关系成立。\n- **SG 通量**：基于沿网格边的电场恒定的假设，得出一个涉及伯努利函数 $B(x)$ 的边通量的封闭形式表达式。\n- **组装要求**：\n    - 对每条边 $(i \\rightarrow j)$ 使用一致的、任意的方向。\n    - 对源节点残差的通量贡献必须是对目标节点残差贡献的负值，以确保局部和全局守恒。\n- **输入**：网格节点坐标 $\\{x_i\\}$、一个有向边集 $\\{(i \\rightarrow j)\\}$、节点电势 $\\{\\varphi_i\\}$、一个恒定的扩散系数 $D$ 和一个节点电子密度向量 $\\mathbf{n}$。\n- **输出**：全局矩阵 $A$ 和残差向量 $\\mathbf{r} = A\\mathbf{n}$。\n- **伯努利函数**：必须以数值稳定的方式实现，记为 $B(x)$，特别注意 $x \\approx 0$ 的情况。\n- **测试用例**：提供了四个具体的测试用例，包含所有必要的参数和检查，以验证对称性、守恒性、方向无关性和单调性。\n- **数值容差**：$10^{-10}$ 用于浮点数比较。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学基础（关键）**：该问题从根本上基于漂移-扩散模型（半导体器件物理的基石）和 Scharfetter-Gummel 方案（该领域广泛使用和验证的数值方法）。这些原理是公认的。（有效）\n- **适定性**：问题定义清晰。输入已指定，期望的输出（矩阵算子 $A$ 和残差 $\\mathbf{r}$）由输入和指定的物理及数值模型唯一确定。测试用例提供了具体的验证标准。（有效）\n- **客观性（关键）**：问题使用精确、形式化的数学和物理语言陈述。没有主观或基于意见的成分。（有效）\n- **科学或事实上的不健全**：不存在违规之处。物理和数学是标准的。\n- **非形式化或不相关**：问题是完全可形式化的，并且是 Scharfetter-Gummel 方法主题的核心。\n- **不完整或矛盾的设置**：设置是完整的。为测试用例提供了所有必要的数据和条件。关于物理守恒及其对组装影响的描述是一致的。\n- **不切实际或不可行**：参数是无量纲的，代表了此类数值方案的标准测试条件。不涉及物理上的不可能性。\n- **不适定或结构不良**：问题结构良好，可导向唯一解。\n- **伪深刻、琐碎或同义反复**：该问题解决了数值建模中一个不平凡的任务，需要仔细实现 SG 方案和组装过程。测试用例旨在探究正确实现的关键属性。\n- **超出科学可验证性**：结果完全可以通过计算并与 SG 方案的已知理论属性进行比较来验证。\n\n**1.3. 结论与行动**\n该问题有效。将提供一个合理的解决方案。\n\n### 步骤 2：推导与算法设计\n\n**2.1. Scharfetter-Gummel 通量**\n电子粒子通量 $J_n$（问题中称为“电子电流密度”）的一维稳态漂移-扩散方程为：\n$$ J_n(x) = D \\left( \\frac{dn}{dx} - n \\frac{d\\varphi}{dx} \\right) $$\n其中 $n$ 是电子密度，$\\varphi$ 是无量纲电势，$D$ 是扩散系数。连续性方程要求 $\\frac{dJ_n}{dx}=0$，意味着在没有源或汇的任何段上，$J_n$ 是恒定的。\n\nScharfetter-Gummel 方法将此方程在连接节点 $i$ 和 $j$ 的网格边上进行离散化。它假设电场 $-\\frac{d\\varphi}{dx}$ 沿边是恒定的。对于长度为 $L = |x_j - x_i|$、电势降为 $\\Delta\\varphi = \\varphi_j - \\varphi_i$ 的边，这给出 $\\frac{d\\varphi}{dx} = \\frac{\\Delta\\varphi}{L}$。然后可以求解关于 $n(x)$ 的常微分方程，满足边界条件 $n(x_i)=n_i$ 和 $n(x_j)=n_j$。求解恒定通量 $J_n$ 得到著名的 SG 公式。从源节点 $i$ 到目标节点 $j$ 的粒子通量为：\n$$ J_{i \\to j} = \\frac{D}{L_{ij}} \\left[ n_i B(\\varphi_i - \\varphi_j) - n_j B(\\varphi_j - \\varphi_i) \\right] $$\n其中 $L_{ij} = |x_j - x_i|$ 是边长，$B(x) = \\frac{x}{e^x - 1}$ 是伯努利函数。使用沿有向边的电势差 $\\Delta\\varphi = \\varphi_j - \\varphi_i$，通量可以写成：\n$$ J_{i \\to j} = \\frac{D}{L_{ij}} \\left[ n_i B(-\\Delta\\varphi) - n_j B(\\Delta\\varphi) \\right] $$\n\n**2.2. 伯努利函数**\n伯努利函数 $B(x)$ 在 $x=0$ 附近需要仔细的数值计算，因为直接的公式会导致 $0/0$ 的不确定性。其极限为 $\\lim_{x\\to0} B(x) = 1$。对于小的 $|x|$，`np.expm1(x)` 提供了一个精确的 $e^x - 1$ 值。然而，为了稳健地处理 $x=0$ 的情况以及周围的浮点数值，我们将对低于某个小阈值的 $|x|$ 使用泰勒级数展开：\n$$ B(x) = 1 - \\frac{x}{2} + \\frac{x^2}{12} - O(x^4) $$\n对于 $|x|  10^{-10}$，这个展开式非常精确。对于较大的 $|x|$，使用 `np.expm1` 的直接公式 $x / (e^x - 1)$ 是稳定且高效的。\n\n**2.3. 算子组装**\n节点 $k$ 处的残差 $r_k$ 是离开围绕节点 $k$ 的控制体的净粒子通量。对于一条有向边 $(i \\to j)$，通量 $J_{i \\to j}$ 离开节点 $i$ 并进入节点 $j$。因此，它对残差的贡献是：\n- $\\Delta r_i = +J_{i \\to j}$\n- $\\Delta r_j = -J_{i \\to j}$\n\n我们寻求矩阵 $A$ 使得 $\\mathbf{r} = A\\mathbf{n}$。将通量公式代入残差贡献中：\n$$ \\Delta r_i = \\left(\\frac{D}{L_{ij}} B(-\\Delta\\varphi)\\right) n_i - \\left(\\frac{D}{L_{ij}} B(\\Delta\\varphi)\\right) n_j $$\n$$ \\Delta r_j = -\\left(\\frac{D}{L_{ij}} B(-\\Delta\\varphi)\\right) n_i + \\left(\\frac{D}{L_{ij}} B(\\Delta\\varphi)\\right) n_j $$\n\n这直接给出了对每条边 $(i \\to j)$ 的矩阵 $A$ 的更新规则。令 $g_{ij} = \\frac{D}{L_{ij}} B(-\\Delta\\varphi)$ 和 $g_{ji} = \\frac{D}{L_{ij}} B(\\Delta\\varphi)$。通量对矩阵 $A$ 的四个元素有贡献：\n- $A_{ii}$ 增加 $g_{ij}$\n- $A_{ij}$ 增加 $-g_{ji}$\n- $A_{ji}$ 增加 $-g_{ij}$\n- $A_{jj}$ 增加 $g_{ji}$\n\n这个组装过程确保了关键属性：\n- **守恒性**：$A$ 中任何列 $k$ 的列元素之和为零。这是因为对于影响列 $k$ 的每条边，一个相等且相反的量被加到两个不同的行上。这意味着对所有 $k$ 都有 $\\sum_i A_{ik} = 0$，所以 $\\mathbf{1}^T A = \\mathbf{0}^T$。因此，对于任何密度向量 $\\mathbf{n}$，残差的全局总和 $\\sum_k r_k = \\mathbf{1}^T \\mathbf{r} = (\\mathbf{1}^T A)\\mathbf{n} = 0$。\n- **对称性**：如果电势恒定，则所有边的 $\\Delta\\varphi = 0$。那么 $B(0)=1$，所以 $g_{ij} = g_{ji} = D/L_{ij}$。更新规则变得对称：$A_{ij}$ 获得 $-D/L_{ij}$，$A_{ji}$ 也获得 $-D/L_{ij}$。最终得到的矩阵 $A$ 是对称的。\n- **方向无关性**：通量 $J_{j \\to i} = -J_{i \\to j}$。如果我们反转边的方向为 $(j \\to i)$，对 $r_j$ 的贡献变为 $+J_{j \\to i} = -J_{i \\to j}$，对 $r_i$ 的贡献变为 $-J_{j \\to i} = +J_{i \\to j}$。这些与边 $(i \\to j)$ 对残差的更新完全相同，因此最终组装的矩阵 $A$ 与所选的边方向无关。\n- **单调性**：SG 方案被设计为是单调的。这表现为组装的矩阵 $A$（对于纯输运问题）是一个非奇异的 M-矩阵，这要求正的对角元和非正的非对角元。由于对于所有实数 $x$，$B(x) > 0$，所以系数 $g_{ij}$ 和 $g_{ji}$ 总是正的。因此，非对角元 $A_{ij}$ 和 $A_{ji}$（对于 $i \\neq j$）是负项（如 $-g_{ji}$）的和，因此是非正的。对角元 $A_{ii}$ 是正项的和，因此是正的。\n\n实现将遵循此算法设计，为每个测试用例组装矩阵 $A$，计算残差 $\\mathbf{r}$，并执行指定的检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines, runs, and evaluates the test cases\n    for the Scharfetter-Gummel discretization.\n    \"\"\"\n\n    TOL = 1e-10\n\n    def B(x):\n        \"\"\"\n        Numerically stable Bernoulli function B(x) = x / (exp(x) - 1).\n        Uses a Taylor series expansion for small |x| to avoid numerical issues.\n        \"\"\"\n        if abs(x)  TOL:\n            # Taylor series: 1 - x/2 + x^2/12 - x^4/720 + ...\n            # The first three terms are sufficient for this tolerance.\n            return 1.0 - x / 2.0 + (x**2) / 12.0\n        else:\n            return x / np.expm1(x)\n\n    def assemble(nodes, edges, potential, D, n_vec):\n        \"\"\"\n        Assembles the Scharfetter-Gummel operator matrix A and computes the\n        residual vector r = A @ n.\n        \"\"\"\n        num_nodes = len(nodes)\n        A = np.zeros((num_nodes, num_nodes))\n\n        for i_src, i_tgt in edges:\n            # 1. Compute edge properties\n            L = abs(nodes[i_tgt] - nodes[i_src])\n            d_phi = potential[i_tgt] - potential[i_src]\n\n            # 2. Compute SG coefficients\n            # Flux J_{i->j} = g_ij * n_i - g_ji * n_j\n            # g_ij corresponds to the source node i, g_ji to target node j\n            g_ij = (D / L) * B(-d_phi)\n            g_ji = (D / L) * B(d_phi)\n\n            # 3. Assemble contributions into the global matrix A\n            # Contribution to residual r_i is +J_{i->j}\n            A[i_src, i_src] += g_ij\n            A[i_src, i_tgt] -= g_ji\n\n            # Contribution to residual r_j is -J_{i->j}\n            A[i_tgt, i_src] -= g_ij\n            A[i_tgt, i_tgt] += g_ji\n\n        # 4. Compute residual\n        r = A @ n_vec\n        return A, r\n\n    # --- Test Cases ---\n\n    test_cases = [\n        {\n            \"name\": \"Test Case 1: Symmetric Diffusion\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges\": [(0, 1), (1, 2)],\n            \"potential\": np.array([0.0, 0.0, 0.0]),\n            \"D\": 1.0,\n            \"n\": np.array([1.0, 1.0, 1.0]),\n            \"check\": lambda A, r: (\n                np.allclose(A, A.T, atol=TOL, rtol=0) and\n                np.allclose(r, np.zeros_like(r), atol=TOL, rtol=0)\n            )\n        },\n        {\n            \"name\": \"Test Case 2: Conservation\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges\": [(0, 1), (1, 2)],\n            \"potential\": np.array([0.0, 0.1, 0.2]),\n            \"D\": 1.0,\n            \"n\": np.array([0.8, 1.1, 0.9]),\n            \"check\": lambda A, r: np.isclose(np.sum(r), 0.0, atol=TOL, rtol=0)\n        },\n        {\n            \"name\": \"Test Case 3: Orientation Invariance\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges_fwd\": [(0, 1), (1, 2)],\n            \"edges_rev\": [(1, 0), (2, 1)],\n            \"potential\": np.array([0.0, 0.1, 0.2]),\n            \"D\": 1.0,\n            \"n\": np.array([0.7, 1.0, 1.2]),\n            \"check\": lambda A_fwd, r_fwd, A_rev, r_rev: (\n                np.allclose(A_fwd, A_rev, atol=TOL, rtol=0) and\n                np.allclose(r_fwd, r_rev, atol=TOL, rtol=0)\n            )\n        },\n        {\n            \"name\": \"Test Case 4: Monotonicity\",\n            \"nodes\": np.array([0.0, 1.0]),\n            \"edges\": [(0, 1)],\n            \"potential\": np.array([0.0, 5.0]),\n            \"D\": 1.0,\n            \"n\": np.array([1.0, 2.0]),\n            \"check\": lambda A, r: (\n                # Off-diagonals non-positive\n                (A[0, 1] = TOL) and (A[1, 0] = TOL) and\n                # Diagonals positive\n                (A[0, 0] > 0) and (A[1, 1] > 0) and\n                # Conservation\n                np.isclose(np.sum(r), 0.0, atol=TOL, rtol=0)\n            )\n        }\n    ]\n\n    results = []\n    \n    # Test Case 1\n    case = test_cases[0]\n    A1, r1 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A1, r1))\n\n    # Test Case 2\n    case = test_cases[1]\n    A2, r2 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A2, r2))\n\n    # Test Case 3\n    case = test_cases[2]\n    A_fwd, r_fwd = assemble(case[\"nodes\"], case[\"edges_fwd\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    A_rev, r_rev = assemble(case[\"nodes\"], case[\"edges_rev\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A_fwd, r_fwd, A_rev, r_rev))\n\n    # Test Case 4\n    case = test_cases[3]\n    A4, r4 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A4, r4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}