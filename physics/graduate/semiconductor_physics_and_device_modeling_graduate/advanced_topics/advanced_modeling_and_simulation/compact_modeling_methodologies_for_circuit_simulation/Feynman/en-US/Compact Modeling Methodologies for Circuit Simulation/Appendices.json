{
    "hands_on_practices": [
        {
            "introduction": "A core challenge in compact modeling is to accurately relate the intrinsic behavior of a transistor, governed by its internal physics, to the extrinsic characteristics observed at its terminals. This practice demonstrates how to account for parasitic series resistances at the source and drain, which are unavoidable in real devices. By deriving the apparent transconductance ($g_m$) and output conductance ($g_{ds}$), you will gain hands-on experience in analyzing how external components modify a device's small-signal response .",
            "id": "3734170",
            "problem": "Consider a three-terminal Metal–Oxide–Semiconductor Field-Effect Transistor (MOSFET) described by a quasi-static compact model that is linearized at a given operating point to yield the intrinsic incremental transconductance $g_{m}$ and the intrinsic incremental output conductance $g_{ds}$. The gate and body currents are assumed negligible so that only the drain and source conduction path carries current. The external source and drain terminals are connected to the intrinsic source and drain via series resistances $R_{s}$ and $R_{d}$, respectively. Let the small-signal external gate voltage be $v_{g}$, the small-signal external drain voltage be $v_{d}$, and the external source be the small-signal reference (zero). Denote by $i_{d}$ the small-signal drain current measured at the external drain terminal.\n\nStarting from basic circuit laws and definitions appropriate for compact modeling, namely Kirchhoff’s laws, Ohm’s law for the series resistors, and the intrinsic small-signal two-port description of the transistor channel, derive how the series resistances $R_{s}$ and $R_{d}$ modify the internal voltages and feed back on the channel to yield the apparent transconductance and output conductance as observed at the external terminals. Treat $g_{m}$ and $g_{ds}$ as constants of the linearization at the operating point and neglect body transconductance.\n\nYour task is to obtain closed-form analytic expressions for the apparent transconductance $g_{m,\\mathrm{app}}$ and apparent output conductance $g_{out,\\mathrm{app}}$ as measured at the external terminals, in terms of $g_{m}$, $g_{ds}$, $R_{s}$, and $R_{d}$. Express your final answer as a single row matrix containing $g_{m,\\mathrm{app}}$ and $g_{out,\\mathrm{app}}$. No numerical evaluation is required, and no units are required in the final answer.",
            "solution": "The goal is to express the external drain current $i_d$ as a function of the external voltages $v_g$ and $v_d$ to find the apparent conductances. The derivation proceeds as follows:\n\n1.  **Relate internal to external voltages**: The current $i_d$ flowing through the series resistances creates voltage drops. The internal node voltages ($v_{g'}, v_{d'}, v_{s'}$) are related to the external ones ($v_g, v_d, v_s=0$) as follows:\n    *   Gate: Since no gate current flows, $v_{g'} = v_g$.\n    *   Source: The voltage at the internal source is $v_{s'} = i_d R_s$.\n    *   Drain: The voltage at the internal drain is $v_{d'} = v_d - i_d R_d$.\n\n2.  **Express intrinsic control voltages**: The intrinsic transistor's behavior depends on its terminal voltage differences, $v_{g's'}$ and $v_{d's'}$.\n    *   $v_{g's'} = v_{g'} - v_{s'} = v_g - i_d R_s$\n    *   $v_{d's'} = v_{d'} - v_{s'} = (v_d - i_d R_d) - i_d R_s = v_d - i_d(R_s + R_d)$\n\n3.  **Substitute into the intrinsic model**: The intrinsic drain current is given by $i_d = g_m v_{g's'} + g_{ds} v_{d's'}$. Substituting the expressions from step 2:\n    $$i_d = g_m (v_g - i_d R_s) + g_{ds} (v_d - i_d(R_s + R_d))$$\n\n4.  **Solve for $i_d$**: Rearrange the equation to solve for $i_d$ in terms of $v_g$ and $v_d$:\n    $$i_d = g_m v_g - g_m i_d R_s + g_{ds} v_d - g_{ds} i_d(R_s + R_d)$$\n    $$i_d (1 + g_m R_s + g_{ds}(R_s + R_d)) = g_m v_g + g_{ds} v_d$$\n    $$i_d = \\frac{g_m}{1 + g_m R_s + g_{ds}(R_s + R_d)} v_g + \\frac{g_{ds}}{1 + g_m R_s + g_{ds}(R_s + R_d)} v_d$$\n\n5.  **Identify apparent conductances**: The apparent transconductance $g_{m,\\mathrm{app}}$ is the coefficient of $v_g$, and the apparent output conductance $g_{out,\\mathrm{app}}$ is the coefficient of $v_d$.\n    *   $g_{m,\\mathrm{app}} = \\frac{g_m}{1 + g_m R_s + g_{ds}(R_s + R_d)}$\n    *   $g_{out,\\mathrm{app}} = \\frac{g_{ds}}{1 + g_m R_s + g_{ds}(R_s + R_d)}$\n    \nThese expressions match the final answer.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{g_{m}}{1 + g_{m} R_{s} + g_{ds} (R_{s} + R_{d})}  \\frac{g_{ds}}{1 + g_{m} R_{s} + g_{ds} (R_{s} + R_{d})} \\end{pmatrix}}$$"
        },
        {
            "introduction": "Circuit simulators like SPICE rely on numerical methods that require model equations to be continuously differentiable to ensure stable and rapid convergence. However, many physical descriptions involve non-smooth operations like $\\max()$ or the absolute value function, which can hinder the solver. This exercise guides you through the process of replacing a non-differentiable function with a smooth approximation and deriving the maximum resulting error, illustrating the crucial trade-off between numerical robustness and model accuracy .",
            "id": "3734155",
            "problem": "Consider a Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) compact model intended for robust circuit simulation with the Newton-Raphson (NR) method, where continuity of first derivatives with respect to terminal voltages is required for stable convergence. A common source of non-smooth behavior in compact models is the use of the absolute value operation $|x|$ and the minimum or maximum operators $\\min(x,y)$ and $\\max(x,y)$, for example in formulations that symmetrize channel transport with respect to $V_{ds}$ or enforce non-negativity of inversion charge $Q_{\\mathrm{inv}}$ through $\\max(0, V_{gs}-V_{th})$. To eliminate derivative discontinuities while preserving the physical monotonicity, one replaces these non-smooth operations by smooth approximations. Specifically, consider replacing the absolute value function $|x|$ by the smooth approximation (sometimes called the “soft absolute” function)\n$$\ng_{a}(x) = \\frac{1}{a}\\,\\ln\\!\\big(2\\cosh(a x)\\big),\n$$\nwhere $a0$ is a smoothing parameter with units inverse to those of $x$ and $\\cosh(\\cdot)$ is the hyperbolic cosine. This replacement is widely used in compact modeling methodologies because $g_{a}(x)$ is infinitely differentiable and convex, while $|x|$ is convex but non-differentiable at $x=0$. Starting from first principles of calculus and properties of hyperbolic functions, derive a closed-form expression for the supremum norm of the approximation error\n$$\nE_{\\max}(a) = \\sup_{x\\in\\mathbb{R}} \\left|\\,g_{a}(x) - |x|\\,\\right|.\n$$\nYour derivation must not assume or reference pre-derived error bounds. Carry out the derivation from the definitions of $\\cosh(\\cdot)$ and $\\ln(\\cdot)$ and standard properties of convex and even functions. Express your final answer as a single exact analytic expression in terms of $a$. No numerical rounding is required. Do not include units in your final expression.",
            "solution": "The objective is to find the supremum norm of the approximation error, defined as\n$$\nE_{\\max}(a) = \\sup_{x\\in\\mathbb{R}} \\left|\\,g_{a}(x) - |x|\\,\\right|\n$$\nwhere $g_{a}(x)$ is the smooth approximation to the absolute value function $|x|$, given by\n$$\ng_{a}(x) = \\frac{1}{a}\\,\\ln\\!\\big(2\\cosh(a x)\\big)\n$$\nwith a smoothing parameter $a0$.\n\nLet us define the error function $E(x,a) = g_{a}(x) - |x|$. The problem is to determine the supremum of $|E(x,a)|$ over all $x \\in \\mathbb{R}$.\n\nFirst, we analyze the properties of the functions involved. The absolute value function $|x|$ is an even function, meaning $|-x|=|x|$. The hyperbolic cosine function, defined as $\\cosh(z) = \\frac{1}{2}(\\exp(z) + \\exp(-z))$, is also an even function since $\\cosh(-z) = \\cosh(z)$. Consequently, the smooth approximation $g_{a}(x)$ is an even function of $x$:\n$$\ng_{a}(-x) = \\frac{1}{a}\\,\\ln\\!\\big(2\\cosh(a (-x))\\big) = \\frac{1}{a}\\,\\ln\\!\\big(2\\cosh(ax)\\big) = g_{a}(x)\n$$\nSince both $g_{a}(x)$ and $|x|$ are even functions, their difference, the error function $E(x,a)$, is also an even function. This symmetry allows us to restrict our analysis to the domain $x \\ge 0$, as the behavior for $x  0$ will be a mirror image. For $x \\ge 0$, we have $|x|=x$.\n\nLet's derive a simplified expression for $E(x,a)$ for $x \\ge 0$. Substituting the definition of $\\cosh(\\cdot)$:\n$$\nE(x,a) = \\frac{1}{a}\\,\\ln\\!\\left(2 \\cdot \\frac{\\exp(ax)+\\exp(-ax)}{2}\\right) - x\n$$\n$$\nE(x,a) = \\frac{1}{a}\\,\\ln\\!\\big(\\exp(ax)+\\exp(-ax)\\big) - x\n$$\nWe can factor out the term $\\exp(ax)$ from the argument of the logarithm:\n$$\nE(x,a) = \\frac{1}{a}\\,\\ln\\!\\big(\\exp(ax)(1+\\exp(-2ax))\\big) - x\n$$\nUsing the property of logarithms $\\ln(uv) = \\ln(u) + \\ln(v)$:\n$$\nE(x,a) = \\frac{1}{a}\\,\\big[\\ln(\\exp(ax)) + \\ln(1+\\exp(-2ax))\\big] - x\n$$\nSince $\\ln(\\exp(z))=z$:\n$$\nE(x,a) = \\frac{1}{a}\\,\\big[ax + \\ln(1+\\exp(-2ax))\\big] - x\n$$\n$$\nE(x,a) = x + \\frac{1}{a}\\ln(1+\\exp(-2ax)) - x\n$$\n$$\nE(x,a) = \\frac{1}{a}\\ln(1+\\exp(-2ax))\n$$\nThis is the expression for the error for $x \\ge 0$.\n\nNow we need to determine the sign of $E(x,a)$. The parameter $a$ is given as $a0$. For the domain of analysis $x \\ge 0$, the exponent $-2ax \\le 0$. This implies $\\exp(-2ax) \\in (0, 1]$. Therefore, the argument of the logarithm, $1+\\exp(-2ax)$, is in the interval $(1, 2]$. Since $\\ln(z) > 0$ for $z1$, we have $\\ln(1+\\exp(-2ax)) \\ge 0$. As $a0$, it follows that $E(x,a) \\ge 0$ for all $x \\ge 0$.\nSince $E(x,a)$ is an even function, $E(x,a) \\ge 0$ for all $x \\in \\mathbb{R}$. This proves that the smooth approximation $g_a(x)$ is always greater than or equal to $|x|$, i.e., it approximates $|x|$ from above.\nThis finding simplifies our task, as the absolute value on the error becomes redundant:\n$$\n|E(x,a)| = |g_a(x) - |x|| = g_a(x) - |x| = E(x,a)\n$$\nThe problem is now reduced to finding the supremum of $E(x,a)$ for $x \\in \\mathbb{R}$.\n$$\nE_{\\max}(a) = \\sup_{x\\in\\mathbb{R}} E(x,a)\n$$\nDue to the even symmetry of $E(x,a)$, its supremum over $\\mathbb{R}$ is the same as its supremum over $[0, \\infty)$.\n$$\nE_{\\max}(a) = \\sup_{x \\ge 0} E(x,a) = \\sup_{x \\ge 0} \\left( \\frac{1}{a}\\ln(1+\\exp(-2ax)) \\right)\n$$\nTo find this supremum, we analyze the monotonicity of $E(x,a)$ for $x \\ge 0$ by examining its first derivative with respect to $x$. Let $f(x) = E(x,a)$.\n$$\nf'(x) = \\frac{d}{dx} \\left[ \\frac{1}{a}\\ln(1+\\exp(-2ax)) \\right]\n$$\nUsing the chain rule:\n$$\nf'(x) = \\frac{1}{a} \\cdot \\frac{1}{1+\\exp(-2ax)} \\cdot \\frac{d}{dx}(1+\\exp(-2ax))\n$$\n$$\nf'(x) = \\frac{1}{a} \\cdot \\frac{1}{1+\\exp(-2ax)} \\cdot (-2a\\exp(-2ax))\n$$\n$$\nf'(x) = -\\frac{2\\exp(-2ax)}{1+\\exp(-2ax)}\n$$\nFor $x0$ and $a0$, the term $\\exp(-2ax)$ is strictly positive. Therefore, the numerator $-2\\exp(-2ax)$ is strictly negative, and the denominator $1+\\exp(-2ax)$ is strictly positive. This implies that $f'(x)  0$ for all $x  0$.\nA function with a negative first derivative on an interval is strictly decreasing on that interval. Thus, $E(x,a)$ is a strictly decreasing function of $x$ on $[0, \\infty)$.\n\nThe supremum of a strictly decreasing function on a closed interval $[0, \\infty)$ must be achieved at the left-most point, which is $x=0$.\nTherefore, the maximum error is the value of the error function at $x=0$.\n$$\nE_{\\max}(a) = E(0,a) = \\frac{1}{a}\\ln(1+\\exp(-2a \\cdot 0))\n$$\n$$\nE_{\\max}(a) = \\frac{1}{a}\\ln(1+\\exp(0))\n$$\n$$\nE_{\\max}(a) = \\frac{1}{a}\\ln(1+1)\n$$\n$$\nE_{\\max}(a) = \\frac{1}{a}\\ln(2)\n$$\nThis is the closed-form expression for the supremum norm of the approximation error.\nAs a final check, we can evaluate the limit of the error as $x \\to \\infty$:\n$$\n\\lim_{x\\to\\infty} E(x,a) = \\lim_{x\\to\\infty} \\frac{1}{a}\\ln(1+\\exp(-2ax)) = \\frac{1}{a}\\ln(1+0) = 0\n$$\nSince the function decreases from its maximum at $x=0$ towards $0$ as $x \\to \\infty$, the value at $x=0$ is indeed the supremum. The maximum approximation error occurs at the point where the original function $|x|$ has its non-differentiable point, which is intuitively expected for a smoothing approximation.",
            "answer": "$$\n\\boxed{\\frac{\\ln(2)}{a}}\n$$"
        },
        {
            "introduction": "Before a compact model can be deployed, it must be rigorously tested to ensure it complies with fundamental physical laws. This quality assurance step prevents non-physical artifacts in circuit simulations. This practice puts you in the role of a model validation engineer, where you will implement three critical consistency checks—reciprocity, charge conservation, and Gummel symmetry—to diagnose specific flaws within a set of test models, a process central to modern compact model development .",
            "id": "3734152",
            "problem": "You are tasked with building a program that performs consistency checks on compact models used in circuit simulation for semiconductor devices. The context is multi-terminal quasi-static charge-based compact modeling where terminal charges are functions of the terminal voltages. Your checks must evaluate mathematical properties that ensure physical plausibility and numerical stability in circuit simulators: reciprocity of capacitance, Gummel symmetry, and charge conservation. All computations must use the International System of Units (SI), with voltage in volts (V), charge in coulombs (C), current in amperes (A), and capacitance in farads (F). Although the program’s final outputs are dimensionless booleans, the internal calculations must consistently use these units.\n\nFundamental base:\n- Let the device have terminals indexed by $\\{g,d,s,b\\}$ corresponding to gate, drain, source, and bulk. Denote terminal voltages by $V_g$, $V_d$, $V_s$, and $V_b$.\n- In a quasi-static charge-based compact model, terminal charges $Q_i(V_g,V_d,V_s,V_b)$ are defined either directly or through a scalar energy function $E(V_g,V_d,V_s,V_b)$ via $Q_i = -\\partial E/\\partial V_i$.\n- Mixed (cross) capacitances are defined by $C_{ij} = -\\partial Q_i/\\partial V_j$ for $i \\neq j$.\n- If $Q_i$ are derived from a sufficiently smooth scalar energy $E$, then by equality of mixed partial derivatives one expects reciprocity $C_{ij} = C_{ji}$.\n- Charge conservation for a multi-terminal device holds if the model is gauge-invariant, i.e., the energy depends only on voltage differences. Then $\\sum_{i \\in \\{g,d,s,b\\}} Q_i = 0$.\n- Gummel symmetry test (GST) for a symmetric two-terminal conduction path (e.g., a Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) channel between drain and source) checks that the drain current $I_d$ is an odd function of the drain-to-source voltage $V_{ds} = V_d - V_s$ near symmetric bias; specifically, $I_d(V_{ds}) \\approx -I_d(-V_{ds})$ when all other biases are held fixed (this reflects invariance under interchange of drain and source in a symmetric device).\n\nYour program must implement the following checks:\n1. Reciprocity of capacitance: At a specified central bias, compute $C_{gd} = -\\partial Q_g/\\partial V_d$ and $C_{dg} = -\\partial Q_d/\\partial V_g$ numerically using a central difference scheme and return a boolean indicating whether $|C_{gd} - C_{dg}| \\le \\tau_C$, with tolerance $\\tau_C = 1\\times 10^{-14}\\ \\mathrm{F}$.\n2. Gummel symmetry: At fixed $V_g$ and $V_b$, evaluate $I_d$ at $V_{ds} = +\\Delta$ and $V_{ds} = -\\Delta$ and return a boolean indicating whether $|I_d(+\\Delta) + I_d(-\\Delta)| \\le \\tau_I$, with tolerance $\\tau_I = 1\\times 10^{-12}\\ \\mathrm{A}$ and $\\Delta = 0.1\\ \\mathrm{V}$.\n3. Charge conservation: Over a specified grid of bias points, compute $\\max |Q_g + Q_d + Q_s + Q_b|$ and return a boolean indicating whether this maximum is $\\le \\tau_Q$, with tolerance $\\tau_Q = 1\\times 10^{-20}\\ \\mathrm{C}$.\n\nNumerical method:\n- Use central finite difference (FD) approximations for partial derivatives at the central bias point $(V_g^\\star,V_d^\\star,V_s^\\star,V_b^\\star)$ with steps $\\Delta V_g = 0.1\\ \\mathrm{V}$ and $\\Delta V_d = 0.1\\ \\mathrm{V}$:\n  - $-\\partial Q_g/\\partial V_d \\approx -\\dfrac{Q_g(V_d^\\star+\\Delta V_d) - Q_g(V_d^\\star-\\Delta V_d)}{2\\,\\Delta V_d}$ evaluated at $V_g=V_g^\\star$, $V_b=V_b^\\star$, $V_s=V_s^\\star$.\n  - $-\\partial Q_d/\\partial V_g \\approx -\\dfrac{Q_d(V_g^\\star+\\Delta V_g) - Q_d(V_g^\\star-\\Delta V_g)}{2\\,\\Delta V_g}$ evaluated at $V_d=V_d^\\star$, $V_b=V_b^\\star$, $V_s=V_s^\\star$.\n\nTest suite and datasets:\nYou must evaluate four independent dataset cases on a bias grid. The grid is\n- Gate voltage set: $V_g \\in \\{0.8,\\,0.9,\\,1.0\\}\\ \\mathrm{V}$.\n- Drain voltage set: $V_d \\in \\{-0.1,\\,0.0,\\,0.1\\}\\ \\mathrm{V}$.\n- Source voltage: $V_s = 0.0\\ \\mathrm{V}$.\n- Bulk voltage: $V_b = -0.2\\ \\mathrm{V}$.\n\nThe central bias is $V_g^\\star=0.9\\ \\mathrm{V}$, $V_d^\\star=0.0\\ \\mathrm{V}$, $V_s^\\star=0.0\\ \\mathrm{V}$, $V_b^\\star=-0.2\\ \\mathrm{V}$.\n\nFor each case below, define $x = V_g - V_s$, $y = V_d - V_s$, and $z = V_b - V_s$.\n\nCase 1 (energy-based, consistent model):\n- Define an energy function\n$$\nE(x,y,z) = \\tfrac{1}{2}C_{gs}x^2 + \\tfrac{1}{2}C_{ds}y^2 + \\tfrac{1}{2}C_{bs}z^2 + C_{gd}xy + C_{gb}xz + C_{db}yz + \\tfrac{1}{4}\\alpha\\,x^2 y^2,\n$$\nwith constants $C_{gs}=1.0\\times 10^{-12}\\ \\mathrm{F}$, $C_{ds}=5.0\\times 10^{-13}\\ \\mathrm{F}$, $C_{bs}=2.0\\times 10^{-13}\\ \\mathrm{F}$, $C_{gd}=1.0\\times 10^{-13}\\ \\mathrm{F}$, $C_{gb}=5.0\\times 10^{-14}\\ \\mathrm{F}$, $C_{db}=2.0\\times 10^{-14}\\ \\mathrm{F}$, and $\\alpha=5.0\\times 10^{-13}\\ \\mathrm{F}/\\mathrm{V}^2$.\n- Terminal charges are $Q_g = -\\partial E/\\partial V_g = -\\partial E/\\partial x$, $Q_d = -\\partial E/\\partial V_d = -\\partial E/\\partial y$, $Q_b = -\\partial E/\\partial V_b = -\\partial E/\\partial z$, and $Q_s = -\\partial E/\\partial V_s$ obtained via the chain rule.\n- Drain current is defined as a symmetric odd function of $y$: $I_d = k\\,(x - V_{\\mathrm{th}})\\,y$ with $k = 1.0\\times 10^{-5}\\ \\mathrm{S}$ and $V_{\\mathrm{th}} = 0.6\\ \\mathrm{V}$.\n\nCase 2 (direct charge definitions with nonreciprocal cross-dependence):\n- Define\n$$\nQ_g(x,y,z) = -\\big(a\\,x + b\\,y + e\\,z + \\beta\\,x\\,y^2\\big),\\quad\nQ_d(x,y,z) = -\\big(c\\,y + d\\,x + f\\,z + \\gamma\\,x^2\\,y\\big),\n$$\nwith $a=1.0\\times 10^{-12}\\ \\mathrm{F}$, $b=2.0\\times 10^{-13}\\ \\mathrm{F}$, $e=5.0\\times 10^{-14}\\ \\mathrm{F}$, $c=5.0\\times 10^{-13}\\ \\mathrm{F}$, $d=5.0\\times 10^{-14}\\ \\mathrm{F}$, $f=2.0\\times 10^{-14}\\ \\mathrm{F}$, $\\beta=3.0\\times 10^{-13}\\ \\mathrm{F}/\\mathrm{V}^2$, and $\\gamma=5.0\\times 10^{-13}\\ \\mathrm{F}/\\mathrm{V}^2$. Set $Q_b(x,y,z) = -(g\\,z + h\\,x + i\\,y)$ with $g=2.0\\times 10^{-13}\\ \\mathrm{F}$, $h=5.0\\times 10^{-14}\\ \\mathrm{F}$, $i=2.0\\times 10^{-14}\\ \\mathrm{F}$, and define $Q_s$ by $Q_s = -(Q_g + Q_d + Q_b)$ so that total charge sums to zero by construction. Drain current is the same as in Case 1: $I_d = k\\,(x - V_{\\mathrm{th}})\\,y$.\n- This construction intentionally violates reciprocity between $g$ and $d$ because $-\\partial Q_g/\\partial V_d$ and $-\\partial Q_d/\\partial V_g$ do not match.\n\nCase 3 (energy-based charges with explicit charge conservation violation):\n- Use the same energy $E$ and $Q_g,Q_d,Q_b$ as in Case 1. Define $Q_s$ by $Q_s = -(Q_g + Q_d + Q_b) + \\delta_Q$ with $\\delta_Q = 1.0\\times 10^{-13}\\ \\mathrm{C}$, thereby breaking charge conservation. Drain current remains $I_d = k\\,(x - V_{\\mathrm{th}})\\,y$.\n\nCase 4 (energy-based charges, Gummel symmetry violation in current):\n- Use the same energy $E$ and charges $Q_g,Q_d,Q_b$ as in Case 1, and define $Q_s = -(Q_g + Q_d + Q_b)$ to conserve charge. Define drain current as $I_d = k\\,(x - V_{\\mathrm{th}})\\,y + \\eta\\,y^2$ with $\\eta = 1.0\\times 10^{-6}\\ \\mathrm{A}/\\mathrm{V}^2$, which adds an even-in-$y$ component to violate Gummel symmetry.\n\nImplementation requirements:\n- Your program must evaluate, for each case independently, the three booleans: reciprocity, Gummel symmetry, and charge conservation, following the numerical method and tolerances specified above.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The order must be\n$[\\mathrm{rec}_1,\\mathrm{gum}_1,\\mathrm{chg}_1,\\mathrm{rec}_2,\\mathrm{gum}_2,\\mathrm{chg}_2,\\mathrm{rec}_3,\\mathrm{gum}_3,\\mathrm{chg}_3,\\mathrm{rec}_4,\\mathrm{gum}_4,\\mathrm{chg}_4]$,\nwhere $\\mathrm{rec}_k$ is the reciprocity boolean for case $k$, $\\mathrm{gum}_k$ is the Gummel symmetry boolean for case $k$, and $\\mathrm{chg}_k$ is the charge conservation boolean for case $k$.",
            "solution": "The problem requires the implementation of a program to perform three fundamental consistency checks on four different quasi-static charge-based compact models for a four-terminal semiconductor device. The checks are for reciprocity of capacitance, Gummel symmetry of the channel current, and overall charge conservation. These properties are critical for ensuring that a compact model is physically plausible and numerically well-behaved when used in circuit simulation software. The solution involves defining the mathematical models for each test case, implementing the numerical checking procedures, and applying these checks to each model.\n\n**1. Principles and Numerical Checks**\n\nThe device has four terminals: gate (g), drain (d), source (s), and bulk (b), with corresponding voltages $V_g, V_d, V_s, V_b$ and charges $Q_g, Q_d, Q_s, Q_b$.\n\n- **Reciprocity of Capacitance**: For a model where terminal charges are derived from a scalar energy potential $E(V_g, V_d, V_s, V_b)$ via $Q_i = -\\partial E / \\partial V_i$, the mixed partial derivatives of $E$ must be equal (Clairaut's theorem). This implies reciprocity of the transcapacitances, $C_{ij} = -\\partial Q_i / \\partial V_j$ and $C_{ji} = -\\partial Q_j / \\partial V_i$. Specifically for the gate and drain terminals, we must have $C_{gd} = C_{dg}$.\nThe check numerically validates this property at a central bias point $(V_g^\\star, V_d^\\star, V_s^\\star, V_b^\\star)$ by computing the difference between $C_{gd}$ and $C_{dg}$ using a central finite difference approximation and comparing it to a tolerance $\\tau_C$.\n$$C_{gd} = -\\frac{\\partial Q_g}{\\partial V_d} \\approx -\\frac{Q_g(V_d^\\star+\\Delta V_d) - Q_g(V_d^\\star-\\Delta V_d)}{2\\Delta V_d}$$\n$$C_{dg} = -\\frac{\\partial Q_d}{\\partial V_g} \\approx -\\frac{Q_d(V_g^\\star+\\Delta V_g) - Q_d(V_g^\\star-\\Delta V_g)}{2\\Delta V_g}$$\nThe condition is $|C_{gd} - C_{dg}| \\le \\tau_C$, with $\\tau_C = 1 \\times 10^{-14}\\ \\mathrm{F}$, $\\Delta V_g = 0.1\\ \\mathrm{V}$, and $\\Delta V_d = 0.1\\ \\mathrm{V}$.\n\n- **Gummel Symmetry**: For a symmetric device structure (e.g., a MOSFET where drain and source are interchangeable), the drain current $I_d$ should be an odd function of the drain-source voltage $V_{ds} = V_d - V_s$ when the device is operated in the linear region near $V_{ds}=0$. This means $I_d(V_{ds}) = -I_d(-V_{ds})$, or $I_d(V_{ds}) + I_d(-V_{ds}) = 0$.\nThe check evaluates this property by computing $I_d$ at $V_{ds} = +\\Delta$ and $V_{ds} = -\\Delta$ (with $\\Delta = 0.1\\ \\mathrm{V}$) while keeping other terminal voltages fixed. The condition is $|I_d(V_{ds}=+\\Delta) + I_d(V_{ds}=-\\Delta)| \\le \\tau_I$, with $\\tau_I = 1 \\times 10^{-12}\\ \\mathrm{A}$.\n\n- **Charge Conservation**: A charge-based model must conserve charge, meaning the sum of all terminal charges must be zero, $\\sum_i Q_i = 0$. This property is a consequence of gauge invariance of the underlying energy function, i.e., the energy depends only on voltage differences between terminals.\nThe check verifies this by calculating $\\sum_i Q_i$ over a grid of bias points and ensuring that the maximum absolute value of this sum is below a tolerance $\\tau_Q$. The condition is $\\max |\\sum_i Q_i| \\le \\tau_Q$, with $\\tau_Q = 1 \\times 10^{-20}\\ \\mathrm{C}$.\n\n**2. Model Definitions**\n\nThe models are defined in terms of the voltage differences $x = V_g - V_s$, $y = V_d - V_s$, and $z = V_b - V_s$.\n\n- **Case 1 (Baseline Consistent Model)**: This model is derived from an energy function, ensuring reciprocity and charge conservation by construction.\n  - Energy: $E(x,y,z) = \\tfrac{1}{2}C_{gs}x^2 + \\tfrac{1}{2}C_{ds}y^2 + \\tfrac{1}{2}C_{bs}z^2 + C_{gd}xy + C_{gb}xz + C_{db}yz + \\tfrac{1}{4}\\alpha x^2 y^2$.\n  - Charges are found by differentiation, e.g., $Q_g = -\\partial E/\\partial x = -(C_{gs}x + C_{gd}y + C_{gb}z + \\tfrac{1}{2}\\alpha x y^2)$. Since the energy function depends only on voltage differences, charge conservation $\\sum Q_i = 0$ is guaranteed if $Q_s$ is derived correctly using the chain rule: $Q_s = - \\partial E / \\partial V_s = \\partial E / \\partial x + \\partial E / \\partial y + \\partial E / \\partial z = -(Q_g+Q_d+Q_b)$.\n  - Current: $I_d = k(x-V_{\\mathrm{th}})y$, which is an odd function of $y$, thus satisfying Gummel symmetry.\n  - This case is expected to pass all three checks.\n\n- **Case 2 (Non-Reciprocal Model)**: Charge functions are defined directly, with coefficients chosen to violate reciprocity.\n  - Charges: $Q_g = -(a x + b y + \\dots)$, $Q_d = -(c y + d x + \\dots)$, where the coefficients of the cross terms are unequal ($b \\neq d$ for the linear part). Specifically, $-\\partial Q_g / \\partial y \\neq -\\partial Q_d / \\partial x$ is engineered.\n  - $Q_s$ is defined as $Q_s = -(Q_g+Q_d+Q_b)$, so charge conservation holds by construction.\n  - Current is identical to Case 1, so Gummel symmetry holds.\n  - This case is expected to fail the reciprocity check but pass the other two.\n\n- **Case 3 (Charge Non-Conservation Model)**: Based on Case 1, but charge conservation is deliberately broken.\n  - Charges $Q_g, Q_d, Q_b$ are as in Case 1.\n  - $Q_s$ is defined as $Q_s = -(Q_g+Q_d+Q_b) + \\delta_Q$, where $\\delta_Q = 1 \\times 10^{-13}\\ \\mathrm{C}$. The total charge is thus always $\\sum Q_i = \\delta_Q$.\n  - This case is expected to fail only the charge conservation check.\n\n- **Case 4 (Gummel Asymmetry Model)**: Based on Case 1, but the current model is modified to violate Gummel symmetry.\n  - All charges are identical to Case 1, so reciprocity and charge conservation hold.\n  - Current: $I_d = k(x-V_{\\mathrm{th}})y + \\eta y^2$. The addition of the $\\eta y^2$ term, which is even in $y=V_{ds}$, breaks the odd symmetry.\n  - This case is expected to fail only the Gummel symmetry check.\n\n**3. Implementation Strategy**\n\nThe solution is implemented in Python. A class is defined for each of the four cases, encapsulating the respective model parameters and providing methods to compute the terminal charges ($Q_g, Q_d, Q_s, Q_b$) and the drain current ($I_d$) as functions of the terminal voltages.\n\nThree separate functions implement the checks: `check_reciprocity`, `check_gummel`, and `check_charge_conservation`. These functions take a model object as input and perform the numerical calculations as specified in the problem statement, returning a boolean result.\n\nThe main `solve` function orchestrates the process. It initializes the model objects for all four cases. It then iterates through each model, applies the three checking functions, and collects the twelve resulting boolean values. Finally, it formats these results into the required single-line string output. This modular design ensures clarity, reusability, and correctness in implementing the specified validation procedures. For example, the analytical reciprocity check for Case 2 relies on comparing $-\\partial Q_g/\\partial y = b+2\\beta xy$ with $-\\partial Q_d/\\partial x = d+2\\gamma xy$. At the central bias point where $y=V_d-V_s=0.0-0.0=0$, this simplifies to comparing $b=2.0\\times 10^{-13}\\ \\mathrm{F}$ and $d=5.0\\times 10^{-14}\\ \\mathrm{F}$. Their difference, $1.5\\times 10^{-13}\\ \\mathrm{F}$, exceeds the tolerance $\\tau_C=1\\times 10^{-14}\\ \\mathrm{F}$, correctly predicting a `False` result for reciprocity. The code confirms this prediction numerically.",
            "answer": "```python\nimport numpy as np\n\n# Tolerances and constants from the problem statement\nTAU_C = 1e-14  # F\nTAU_I = 1e-12  # A\nTAU_Q = 1e-20  # C\nDELTA_V_G = 0.1  # V\nDELTA_V_D = 0.1  # V\nDELTA_GST = 0.1  # V for Gummel Symmetry Test\n\n# Central bias point\nV_STAR = (0.9, 0.0, 0.0, -0.2)  # (Vg, Vd, Vs, Vb)\n\n# Bias grid for charge conservation check\nV_G_GRID = [0.8, 0.9, 1.0]\nV_D_GRID = [-0.1, 0.0, 0.1]\nV_S_GRID = 0.0\nV_B_GRID = -0.2\n\n\nclass ModelCase1:\n    \"\"\"Case 1: Energy-based, consistent model.\"\"\"\n    def __init__(self):\n        self.Cgs = 1.0e-12\n        self.Cds = 5.0e-13\n        self.Cbs = 2.0e-13\n        self.Cgd = 1.0e-13\n        self.Cgb = 5.0e-14\n        self.Cdb = 2.0e-14\n        self.alpha = 5.0e-13\n        self.k = 1.0e-5\n        self.Vth = 0.6\n\n    def _get_xyz(self, Vg, Vd, Vs, Vb):\n        x = Vg - Vs\n        y = Vd - Vs\n        z = Vb - Vs\n        return x, y, z\n\n    def Qg(self, Vg, Vd, Vs, Vb):\n        x, y, z = self._get_xyz(Vg, Vd, Vs, Vb)\n        return -(self.Cgs * x + self.Cgd * y + self.Cgb * z + 0.5 * self.alpha * x * y**2)\n\n    def Qd(self, Vg, Vd, Vs, Vb):\n        x, y, z = self._get_xyz(Vg, Vd, Vs, Vb)\n        return -(self.Cds * y + self.Cgd * x + self.Cdb * z + 0.5 * self.alpha * x**2 * y)\n\n    def Qb(self, Vg, Vd, Vs, Vb):\n        x, y, z = self._get_xyz(Vg, Vd, Vs, Vb)\n        return -(self.Cbs * z + self.Cgb * x + self.Cdb * y)\n\n    def Qs(self, Vg, Vd, Vs, Vb):\n        qg = self.Qg(Vg, Vd, Vs, Vb)\n        qd = self.Qd(Vg, Vd, Vs, Vb)\n        qb = self.Qb(Vg, Vd, Vs, Vb)\n        return -(qg + qd + qb)\n\n    def Id(self, Vg, Vd, Vs, Vb):\n        x, y, _ = self._get_xyz(Vg, Vd, Vs, Vb)\n        return self.k * (x - self.Vth) * y\n\n\nclass ModelCase2:\n    \"\"\"Case 2: Direct charge definitions with nonreciprocal cross-dependence.\"\"\"\n    def __init__(self):\n        self.a = 1.0e-12; self.b = 2.0e-13; self.e = 5.0e-14\n        self.c = 5.0e-13; self.d = 5.0e-14; self.f = 2.0e-14\n        self.g = 2.0e-13; self.h = 5.0e-14; self.i = 2.0e-14\n        self.beta = 3.0e-13; self.gamma = 5.0e-13\n        self.k = 1.0e-5; self.Vth = 0.6\n\n    def _get_xyz(self, Vg, Vd, Vs, Vb):\n        x = Vg - Vs; y = Vd - Vs; z = Vb - Vs\n        return x, y, z\n\n    def Qg(self, Vg, Vd, Vs, Vb):\n        x, y, z = self._get_xyz(Vg, Vd, Vs, Vb)\n        return -(self.a * x + self.b * y + self.e * z + self.beta * x * y**2)\n\n    def Qd(self, Vg, Vd, Vs, Vb):\n        x, y, z = self._get_xyz(Vg, Vd, Vs, Vb)\n        return -(self.c * y + self.d * x + self.f * z + self.gamma * x**2 * y)\n\n    def Qb(self, Vg, Vd, Vs, Vb):\n        x, y, z = self._get_xyz(Vg, Vd, Vs, Vb)\n        return -(self.g * z + self.h * x + self.i * y)\n\n    def Qs(self, Vg, Vd, Vs, Vb):\n        qg = self.Qg(Vg, Vd, Vs, Vb)\n        qd = self.Qd(Vg, Vd, Vs, Vb)\n        qb = self.Qb(Vg, Vd, Vs, Vb)\n        return -(qg + qd + qb)\n\n    def Id(self, Vg, Vd, Vs, Vb):\n        x, y, _ = self._get_xyz(Vg, Vd, Vs, Vb)\n        return self.k * (x - self.Vth) * y\n\n\nclass ModelCase3(ModelCase1):\n    \"\"\"Case 3: Energy-based charges with explicit charge conservation violation.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.delta_Q = 1.0e-13\n\n    def Qs(self, Vg, Vd, Vs, Vb):\n        # Override Qs to break charge conservation\n        qg = self.Qg(Vg, Vd, Vs, Vb)\n        qd = self.Qd(Vg, Vd, Vs, Vb)\n        qb = self.Qb(Vg, Vd, Vs, Vb)\n        return -(qg + qd + qb) + self.delta_Q\n\n\nclass ModelCase4(ModelCase1):\n    \"\"\"Case 4: Energy-based charges, Gummel symmetry violation in current.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.eta = 1.0e-6\n\n    def Id(self, Vg, Vd, Vs, Vb):\n        # Override Id to break Gummel symmetry\n        x, y, _ = self._get_xyz(Vg, Vd, Vs, Vb)\n        return self.k * (x - self.Vth) * y + self.eta * y**2\n\n\ndef check_reciprocity(model, V_star, dV_g, dV_d, tau_c):\n    \"\"\"Checks for C_gd = C_dg.\"\"\"\n    Vg_s, Vd_s, Vs_s, Vb_s = V_star\n    \n    # Calculate C_gd = -dQg/dVd\n    qg_plus = model.Qg(Vg_s, Vd_s + dV_d, Vs_s, Vb_s)\n    qg_minus = model.Qg(Vg_s, Vd_s - dV_d, Vs_s, Vb_s)\n    C_gd = -(qg_plus - qg_minus) / (2 * dV_d)\n    \n    # Calculate C_dg = -dQd/dVg\n    qd_plus = model.Qd(Vg_s + dV_g, Vd_s, Vs_s, Vb_s)\n    qd_minus = model.Qd(Vg_s - dV_g, Vd_s, Vs_s, Vb_s)\n    C_dg = -(qd_plus - qd_minus) / (2 * dV_g)\n    \n    return abs(C_gd - C_dg) = tau_c\n\ndef check_gummel(model, V_star, delta, tau_i):\n    \"\"\"Checks if Id is an odd function of Vds.\"\"\"\n    Vg_s, _, Vs_s, Vb_s = V_star\n    \n    # Since Vds = Vd - Vs, and we typically hold Vs=0, we vary Vd\n    # Problem text implies fixed Vg, Vb, Vs from central bias, where Vs=0\n    Id_plus = model.Id(Vg_s, Vs_s + delta, Vs_s, Vb_s)\n    Id_minus = model.Id(Vg_s, Vs_s - delta, Vs_s, Vb_s)\n    \n    return abs(Id_plus + Id_minus) = tau_i\n\ndef check_charge_conservation(model, Vg_grid, Vd_grid, Vs, Vb, tau_q):\n    \"\"\"Checks if sum of charges is zero over a bias grid.\"\"\"\n    max_abs_q_sum = 0\n    for vg in Vg_grid:\n        for vd in Vd_grid:\n            qg = model.Qg(vg, vd, Vs, Vb)\n            qd = model.Qd(vg, vd, Vs, Vb)\n            qs = model.Qs(vg, vd, Vs, Vb)\n            qb = model.Qb(vg, vd, Vs, Vb)\n            q_sum = qg + qd + qs + qb\n            if abs(q_sum)  max_abs_q_sum:\n                max_abs_q_sum = abs(q_sum)\n    \n    return max_abs_q_sum = tau_q\n\ndef solve():\n    \"\"\"Main function to run all checks on all cases.\"\"\"\n    \n    test_cases = [\n        ModelCase1(),\n        ModelCase2(),\n        ModelCase3(),\n        ModelCase4()\n    ]\n    \n    results = []\n    for model in test_cases:\n        # 1. Reciprocity check\n        rec_pass = check_reciprocity(model, V_STAR, DELTA_V_G, DELTA_V_D, TAU_C)\n        results.append(rec_pass)\n        \n        # 2. Gummel symmetry check\n        gum_pass = check_gummel(model, V_STAR, DELTA_GST, TAU_I)\n        results.append(gum_pass)\n        \n        # 3. Charge conservation check\n        chg_pass = check_charge_conservation(model, V_G_GRID, V_D_GRID, V_S_GRID, V_B_GRID, TAU_Q)\n        results.append(chg_pass)\n\n    # Format output as specified\n    # Python's str(True) -> 'True', str(False) -> 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}