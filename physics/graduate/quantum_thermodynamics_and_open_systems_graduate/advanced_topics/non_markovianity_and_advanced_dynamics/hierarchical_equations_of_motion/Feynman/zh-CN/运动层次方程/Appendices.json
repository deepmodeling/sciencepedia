{
    "hands_on_practices": [
        {
            "introduction": "要掌握运动层次方程（HEOM）方法，首先必须理解其核心结构。本练习将引导你从普适的HEOM公式出发，推导第一层级辅助密度算符的具体运动方程。通过这个基本练习 ，你将熟悉HEOM的耦合结构以及各层级之间的关系，这是进行更复杂分析和数值实现的基础。",
            "id": "190598",
            "problem": "层次运动方程 (HEOM) 为研究与谐振子热库耦合的量子系统的动力学提供了一种强大的非微扰方法。考虑一个哈密顿量为 $H_S$ 的量子系统，通过相互作用哈密顿量 $H_{SB} = V \\otimes B$ 与谐振子热库耦合，其中 $V$ 是一个系统算符，$B$ 是一个集体热库坐标。\n\n热库的性质及其与系统的耦合完全由热库关联函数 $C(t) = \\langle B(t)B(0) \\rangle_B$ 来表征，该函数通过涨落-耗散定理与谱密度 $J(\\omega)$ 相关联。对于由 Drude-Lorentz 谱密度描述的热库，\n$$ J(\\omega) = 2\\lambda\\gamma \\frac{\\omega}{\\omega^2 + \\gamma^2} $$\n其中 $\\lambda$ 是重组能，$\\gamma$ 是热库的特征频率，在有限温度 $T$ 下，关联函数对于 $t>0$ 可以分解为指数项的无穷级数：\n$$ C(t) = \\sum_{k=0}^{\\infty} c_k e^{-\\nu_k t} $$\n指数由 Drude 衰减率 $\\nu_0 = \\gamma$ 和松原频率 $\\nu_k = 2\\pi k/(\\beta\\hbar)$（对于 $k \\ge 1$）给出，其中 $\\beta = 1/(k_B T)$。相应的系数为：\n$$ c_0 = \\lambda\\gamma \\left( \\cot\\left(\\frac{\\beta\\hbar\\gamma}{2}\\right) - i \\right) $$\n$$ c_k = \\frac{4\\lambda\\gamma\\nu_k}{\\beta\\hbar(\\nu_k^2 - \\gamma^2)} \\quad \\text{for } k \\ge 1 $$\n\nHEOM 方法通过将系统的约化密度算符 $\\rho(t)$ 与一系列辅助密度算符 (ADO) $\\rho_{\\mathbf{n}}(t)$ 耦合来描述其演化。指标 $\\mathbf{n} = (n_0, n_1, n_2, \\dots)$ 是一个非负整数向量，其中 $n_k$ 对应于 $C(t)$ 指数分解中的第 $k$ 个模式。物理密度算符是该层次结构的顶层成员，即 $\\rho(t) \\equiv \\rho_{\\mathbf{n}=\\mathbf{0}}(t)$。整个层次结构的时间演化由以下耦合微分方程组给出：\n$$ \\frac{d}{dt}\\rho_{\\mathbf{n}}(t) = -\\left(\\frac{i}{\\hbar}[H_S, \\cdot] + \\sum_{j=0}^{\\infty} n_j \\nu_j \\right) \\rho_{\\mathbf{n}}(t) - \\frac{i}{\\hbar} \\sum_{j=0}^{\\infty} [V, \\rho_{\\mathbf{n}+\\mathbf{e}_j}(t)] - \\frac{i}{\\hbar} \\sum_{j=0}^{\\infty} n_j \\left(c_j V \\rho_{\\mathbf{n}-\\mathbf{e}_j}(t) - c_j^* \\rho_{\\mathbf{n}-\\mathbf{e}_j}(t) V\\right) $$\n其中 $\\mathbf{e}_j$ 是一个单位向量，其第 $j$ 个位置为 1，其他位置为 0。\n\nADO $\\rho_{\\mathbf{n}}$ 的阶由其指标之和定义，$N = \\sum_j n_j$。第一阶对应于 $N=1$。我们将这些第一阶 ADO 表示为 $\\rho^{(k)}(t) \\equiv \\rho_{\\mathbf{e}_k}(t)$。类似地，第二阶 ADO 可以表示为 $\\rho^{(k,j)}(t) \\equiv \\rho_{\\mathbf{e}_k+\\mathbf{e}_j}(t)$。\n\n你的任务是为任意非负整数 $k \\ge 0$ 推导第一阶辅助密度算符 $\\frac{d}{dt}\\rho^{(k)}(t)$ 的具体运动方程。请用 $H_S$、$V$、热库参数（$\\nu_k, c_k$）、第零阶算符 $\\rho(t)$、第一阶算符 $\\rho^{(k)}(t)$ 和第二阶算符 $\\rho^{(k,j)}(t)$ 来表示你的答案。",
            "solution": "我们从指标为 $\\mathbf{n}=(n_0,n_1,\\dots)$ 的 ADO 的通用 HEOM 方程开始：\n\n$$\n\\frac{d}{dt}\\rho_{\\mathbf{n}}\n=-\\Bigl(\\frac{i}{\\hbar}[H_S,\\cdot]+\\sum_j n_j\\nu_j\\Bigr)\\rho_{\\mathbf{n}}\n-\\frac{i}{\\hbar}\\sum_j[V,\\rho_{\\mathbf{n}+\\mathbf{e}_j}]\n-\\frac{i}{\\hbar}\\sum_j n_j\\bigl(c_jV\\rho_{\\mathbf{n}-\\mathbf{e}_j}-c_j^*\\rho_{\\mathbf{n}-\\mathbf{e}_j}V\\bigr).\n$$\n\n对于第一阶 ADO $\\rho^{(k)}=\\rho_{\\mathbf{e}_k}$，我们有 $n_j=\\delta_{jk}$。因此：\n1. $\\sum_j n_j\\nu_j = \\nu_k.$\n2. $\\rho_{\\mathbf{e}_k+\\mathbf{e}_j}=\\rho^{(k,j)},$ 所以 \n   $\\sum_j [V,\\rho_{\\mathbf{e}_k+\\mathbf{e}_j}]\n   =\\sum_{j=0}^\\infty[V,\\rho^{(k,j)}].$\n3. 在最后一项求和中只有 $j=k$ 有贡献：\n   当 $j=k$ 时，$\\rho_{\\mathbf{e}_k-\\mathbf{e}_j}=\\rho_{\\mathbf{0}}=\\rho(t)$，否则为零。  \n   因此\n   $\\sum_j n_j(c_jV\\rho_{\\mathbf{e}_k-\\mathbf{e}_j}-c_j^*\\rho_{\\mathbf{e}_k-\\mathbf{e}_j}V)\n   =c_kV\\rho(t)-c_k^*\\rho(t)V.$\n\n将这些部分组合在一起，\n\n$$\n\\frac{d}{dt}\\rho^{(k)}(t)\n=-\\frac{i}{\\hbar}[H_S,\\rho^{(k)}]\n-\\nu_k\\,\\rho^{(k)}\n-\\frac{i}{\\hbar}\\sum_{j=0}^\\infty[V,\\rho^{(k,j)}]\n-\\frac{i}{\\hbar}\\bigl(c_kV\\rho(t)-c_k^*\\rho(t)V\\bigr).\n$$",
            "answer": "$$\\boxed{\\frac{d}{dt}\\rho^{(k)}(t)\n=-\\frac{i}{\\hbar}[H_S,\\rho^{(k)}(t)]\n-\\nu_k\\,\\rho^{(k)}(t)\n-\\frac{i}{\\hbar}\\sum_{j=0}^\\infty[V,\\rho^{(k,j)}(t)]\n-\\frac{i}{\\hbar}\\bigl(c_kV\\rho(t)-c_k^*\\rho(t)V\\bigr)}$$"
        },
        {
            "introduction": "在实际应用中，HEOM层级必须被截断，但简单的截断可能破坏动力学映射的完备正性（complete positivity），导致非物理结果。本练习通过一个反例揭示了这一陷阱，并要求你推导出一个基于绝热消除的修正项来恢复完备正性。这个过程  不仅能加深你对开放量子系统基本物理原则的理解，也是开发可靠数值模拟方法的关键一步。",
            "id": "3771225",
            "problem": "考虑一个两能级量子系统（量子比特），其系统哈密顿量为 $H = \\frac{\\omega}{2}\\,\\sigma_z$，系统-浴耦合算符为 $V = \\sigma_x$。该系统与一个玻色子环境相互作用，环境的平衡态双时关联函数可进行单指数分解 $C(t) = c\\,e^{-\\nu t}$，其中 $c > 0$ 和 $\\nu > 0$ 是无量纲常数。约化系统的动力学可以使用在 $N=1$ 阶截断的分层运动方程 (HEOM) 来描述，这为物理密度算符 $\\rho_0(t)$ 和单个辅助密度算符 $\\rho_1(t)$ 提供了一组耦合线性方程组：\n- 物理密度算符遵循 $\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] - i[V,\\rho_1(t)]$。\n- 辅助密度算符遵循 $\\frac{d}{dt}\\rho_1(t) = -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)]$。\n此处 $[A,B] = AB - BA$ 表示对易子。在 $N=1$ 阶的朴素截断将 $\\rho_{2}(t) \\equiv 0$，并且在此截断之外不引入任何闭合项。\n\n通常，在因子化初始条件下，精确的开放系统动力学是完全正定的 (CP)。然而，近似方案，包括朴素截断的 HEOM，可能产生不满足完全正定性的动力学。在本任务中，您将构建一个反例，其中朴素的 $N=1$ HEOM 截断在固定的最终时间 $t_{\\mathrm{f}}$ 产生一个非完全正定的动力学映射，通过检查该动力学映射的 Choi 矩阵来诊断其失效原因，然后提出并实现一个基于受控时间尺度分离的修正终止项，以恢复近似的完全正定性。\n\n从描述系统加环境总状态的基本刘维尔-冯·诺伊曼方程 $\\frac{d}{dt}\\rho_{\\mathrm{tot}}(t) = -i[H_{\\mathrm{tot}},\\rho_{\\mathrm{tot}}(t)]$ 和针对单指数浴关联 $C(t)$ 的 HEOM 构建定义出发，推导一个基于绝热消除的闭合，它将截断层对 $\\rho_0(t)$ 动力学的影响近似为一个 Gorini–Kossakowski–Sudarshan–Lindblad (GKSL) 形式的有效时间局域生成元。您的推导应从上述方程出发，通过对辅助密度算符应用受控的时间尺度分离论证并将其消除，从而获得一个仅作用于 $\\rho_0(t)$ 的显式生成元，该生成元在 $V$ 为厄米算符时显然是完全正定的。不要使用或引用任何快捷公式；基于所提供的方程和单指数关联模型，从第一性原理推导耗散项的结构和系数。\n\n按如下方式数值验证完全正定性。对于一组固定的参数和固定的时间 $t_{\\mathrm{f}}$，通过将四个矩阵单位 $E_{00} = |0\\rangle\\langle 0|$, $E_{01} = |0\\rangle\\langle 1|$, $E_{10} = |1\\rangle\\langle 0|$, $E_{11} = |1\\rangle\\langle 1|$ 从 $t=0$ 演化到 $t=t_{\\mathrm{f}}$，构建由所选动力学（朴素截断的 HEOM 或修正的 GKSL 闭合终止项）导出的动力学映射 $\\mathcal{E}_{t_{\\mathrm{f}}}$。构建 Choi 矩阵 $J(\\mathcal{E}_{t_{\\mathrm{f}}}) = \\sum_{i,j\\in\\{0,1\\}} \\mathcal{E}_{t_{\\mathrm{f}}}(|i\\rangle\\langle j|) \\otimes |i\\rangle\\langle j|$ 并计算其最小本征值。负的最小本征值表示违反了完全正定性，而非负的最小本征值对应于一个完全正定的映射。\n\n您的程序必须实现朴素截断的 HEOM 动力学和通过您的绝热消除分析推导出的修正终止项，并为以下三个测试用例评估 Choi 矩阵的最小本征值。所有量都是无量纲的；不需要物理单位。\n\n测试套件（每个测试用例是一个指定 $(\\text{方法}, \\omega, c, \\nu, t_{\\mathrm{f}})$ 的元组）：\n- 用例 1（强耦合，朴素截断）：$(\\text{naive}, 1.0, 6.0, 0.5, 3.0)$。\n- 用例 2（强耦合，修正终止项）：$(\\text{terminator}, 1.0, 6.0, 0.5, 3.0)$。\n- 用例 3（弱耦合，朴素截断）：$(\\text{naive}, 1.0, 0.2, 2.0, 3.0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个测试用例的条目必须是一个浮点数，等于相应 Choi 矩阵在时间 $t_{\\mathrm{f}}$ 的最小本征值。使用数值稳定的积分方案，并通过对称化 $J \\mapsto \\frac{1}{2}(J + J^\\dagger)$ 确保 Choi 矩阵在计算其本征值之前是厄米矩阵。清晰地分开朴素截断和修正终止项的实现，并确保程序无需外部输入即可自包含运行。",
            "solution": "所述问题在科学上是成立的、适定的，并包含了完整解答所需的所有信息。它提出了开放量子系统研究中的一个标准但非平凡的任务：分析一个近似方案（朴素 HEOM 截断）的缺点，并推导和实现一个有物理动机的修正（基于绝热消除的终止项）。因此，该问题被认为是有效的。\n\n任务的核心是通过从所提供的在 $N=1$ 阶截断的层次结构中消除辅助算符 $\\rho_1(t)$，来为物理密度算符 $\\rho_0(t)$ 推导出一个主方程。出发点是给定的耦合微分方程组：\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] - i[V,\\rho_1(t)] \\quad \\cdots \\quad (1)\n$$\n$$\n\\frac{d}{dt}\\rho_1(t) = -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)] \\quad \\cdots \\quad (2)\n$$\n其中 $H = \\frac{\\omega}{2}\\,\\sigma_z$，$V = \\sigma_x$，且 $[A,B] = AB-BA$。\n\n推导通过一个绝热消除过程进行，该过程依赖于时间尺度的分离。我们假设辅助算符 $\\rho_1(t)$ 的动力学远快于物理算符 $\\rho_0(t)$ 的动力学。这在浴记忆时间（由 $\\nu^{-1}$ 表征）非常短的极限下具有物理合理性，或者等效地说，当浴衰减率 $\\nu$ 相对于问题中的其他能量尺度（如 $\\omega$ 和耦合范数）非常大时。在此极限下，$\\rho_1(t)$ 会迅速调整到 $\\rho_0(t)$ 的瞬时状态，使我们能将其时间导数近似为零。\n\n将此准稳态近似应用于方程 $(2)$，我们设 $\\frac{d}{dt}\\rho_1(t) \\approx 0$：\n$$\n0 \\approx -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)]\n$$\n为了求解 $\\rho_1(t)$，我们做出一个与时间尺度分离论证相一致的进一步受控近似。如果 $\\nu$ 是 $\\rho_1$ 动力学中的主导尺度，即 $\\nu \\gg \\omega$，则项 $-\\nu\\,\\rho_1(t)$ 将主导项 $-i[H,\\rho_1(t)]$。忽略后者，我们得到一个简化的代数关系：\n$$\n0 \\approx - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)]\n$$\n解此方程得到 $\\rho_1(t)$，即可得出用物理算符表示的辅助算符的表达式：\n$$\n\\rho_1(t) \\approx -\\frac{ic}{\\nu}\\,[V,\\rho_0(t)] \\quad \\cdots \\quad (3)\n$$\n此表达式抓住了该近似的本质：编码了系统-浴关联的辅助算符，与驱动耗散动力学的对易子 $[V, \\rho_0(t)]$ 直接且瞬时成正比。\n\n接下来，我们将 $\\rho_1(t)$ 的这个表达式代回到 $\\rho_0(t)$ 的运动方程，即方程 $(1)$ 中：\n$$\n\\frac{d}{dt}\\rho_0(t) \\approx -i[H,\\rho_0(t)] - i\\left[V, \\left(-\\frac{ic}{\\nu}\\,[V,\\rho_0(t)]\\right)\\right]\n$$\n简化表达式可得：\n$$\n\\frac{d}{dt}\\rho_0(t) \\approx -i[H,\\rho_0(t)] - \\frac{c}{\\nu}\\left[V, [V,\\rho_0(t)]\\right] \\quad \\cdots \\quad (4)\n$$\n这是一个关于 $\\rho_0(t)$ 的时间局域或马尔可夫主方程。为了验证它具有 Gorini–Kossakowski–Sudarshan–Lindblad (GKSL) 形式，我们展开双重对易子项。对于任何算符 $V$ 和 $\\rho$：\n$$\n[V, [V, \\rho]] = V(V\\rho - \\rho V) - (V\\rho - \\rho V)V = V^2\\rho - V\\rho V - V\\rho V + \\rho V^2 = V^2\\rho + \\rho V^2 - 2V\\rho V\n$$\n这可以用反对易子 $\\{A,B\\} = AB+BA$ 写成：\n$$\n[V, [V, \\rho]] = \\{V^2, \\rho\\} - 2V\\rho V\n$$\n将此代入方程 $(4)$ 的耗散部分：\n$$\n-\\frac{c}{\\nu}\\left[V, [V,\\rho_0(t)]\\right] = -\\frac{c}{\\nu}\\left(\\{V^2, \\rho_0(t)\\} - 2V\\rho_0(t)V\\right) = \\frac{2c}{\\nu}\\left(V\\rho_0(t)V - \\frac{1}{2}\\{V^2, \\rho_0(t)\\}\\right)\n$$\n现在主方程的形式为：\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] + \\frac{2c}{\\nu}\\left(V\\rho_0(t)V - \\frac{1}{2}\\{V^2, \\rho_0(t)\\}\\right)\n$$\n这显然是 GKSL 形式 $\\frac{d}{dt}\\rho = -i[H,\\rho] + \\sum_k \\gamma_k \\left( L_k \\rho L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho\\} \\right)$。在我们的例子中，只有一个 Lindblad 算符 $L_1 = V = \\sigma_x$，它是厄米的（$V^\\dagger=V$），以及相应的衰减率 $\\gamma_1 = \\frac{2c}{\\nu}$。因为任何 GKSL 形式的主方程都会生成一个完全正定 (CP) 的动力学映射，所以这个“终止项”方程保证了动力学完全正定性的保持。\n\n对于特定的耦合算符 $V=\\sigma_x$，我们有 $V^2 = \\sigma_x^2 = I$，其中 $I$ 是 $2 \\times 2$ 单位矩阵。反对易子简化为 $\\{V^2, \\rho_0\\} = \\{I, \\rho_0\\} = I\\rho_0 + \\rho_0 I = 2\\rho_0$。修正后的主方程变为：\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] + \\frac{2c}{\\nu}\\left(\\sigma_x\\rho_0(t)\\sigma_x - \\rho_0(t)\\right)\n$$\n这就是将要进行数值实现的“终止项”方法的方程。数值部分将证实这个推导出的方程确实产生一个 CP 映射（Choi 矩阵的最小本征值 $\\ge 0$），而朴素截断在某些参数下可能会失效（最小本征值 $ 0$）。\n\n为了进行数值验证，我们通过演化一组算符基来构建动力学映射 $\\mathcal{E}_{t_{\\mathrm{f}}}$。然后，Choi 矩阵被构建为 $J(\\mathcal{E}_{t_{\\mathrm{f}}}) = \\sum_{i,j=0}^{1} \\mathcal{E}_{t_{\\mathrm{f}}}(|i\\rangle\\langle j|) \\otimes |i\\rangle\\langle j|$。映射 $\\mathcal{E}_{t_{\\mathrm{f}}}$ 是完全正定的当且仅当其 Choi 矩阵 $J(\\mathcal{E}_{t_{\\mathrm{f}}})$ 是半正定的，这通过检查其最小本征值是否非负来验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Define global constants (Pauli matrices, identity, and basis matrices)\n# for convenience and to avoid re-declaration.\nSIGMA_X = np.array([[0, 1], [1, 0]], dtype=complex)\nSIGMA_Z = np.array([[1, 0], [0, -1]], dtype=complex)\nID2 = np.identity(2, dtype=complex)\nE00 = np.array([[1, 0], [0, 0]], dtype=complex)\nE01 = np.array([[0, 1], [0, 0]], dtype=complex)\nE10 = np.array([[0, 0], [1, 0]], dtype=complex)\nE11 = np.array([[0, 0], [0, 1]], dtype=complex)\nBASIS = [E00, E01, E10, E11]\n\ndef dydt_naive(t, y, H, V, c, nu):\n    \"\"\"\n    Computes the time derivative for the naive N=1 truncated HEOM.\n    The state vector y is an 8-element complex array representing flattened\n    rho_0 (first 4 elements) and rho_1 (last 4 elements).\n    \"\"\"\n    # Reshape the flattened state vector into 2x2 density matrices\n    rho0 = y[0:4].reshape((2, 2))\n    rho1 = y[4:8].reshape((2, 2))\n    \n    # Calculate required commutators for the equations of motion\n    comm_H_rho0 = H @ rho0 - rho0 @ H\n    comm_V_rho1 = V @ rho1 - rho1 @ V\n    comm_H_rho1 = H @ rho1 - rho1 @ H\n    comm_V_rho0 = V @ rho0 - rho0 @ V\n    \n    # Equation for the physical density operator rho_0\n    d_rho0_dt = -1j * comm_H_rho0 - 1j * comm_V_rho1\n    \n    # Equation for the auxiliary density operator rho_1\n    d_rho1_dt = -1j * comm_H_rho1 - nu * rho1 - 1j * c * comm_V_rho0\n    \n    # Flatten the derivatives and concatenate into a single vector\n    return np.concatenate((d_rho0_dt.flatten(), d_rho1_dt.flatten()))\n\ndef dydt_terminator(t, y, H, V, c, nu):\n    \"\"\"\n    Computes the time derivative for the modified terminator (GKSL) equation.\n    The state vector y is a 4-element complex array representing flattened rho_0.\n    \"\"\"\n    # Reshape the flattened state vector into a 2x2 density matrix\n    rho0 = y.reshape((2, 2))\n    \n    # Coherent part of the evolution\n    comm_H_rho0 = H @ rho0 - rho0 @ H\n    \n    # Dissipative part (GKSL form derived from adiabatic elimination)\n    # The rate is gamma = 2*c/nu and the Lindblad operator is V = sigma_x.\n    # Since V^2 = I, the dissipator is gamma * (V * rho0 * V - rho0).\n    gamma = 2.0 * c / nu\n    dissipator = gamma * (V @ rho0 @ V - rho0)\n    \n    # Full equation of motion\n    d_rho0_dt = -1j * comm_H_rho0 + dissipator\n    \n    # Flatten the derivative for the ODE solver\n    return d_rho0_dt.flatten()\n\n\ndef calculate_min_eigenvalue(method, omega, c, nu, t_f):\n    \"\"\"\n    Calculates the minimal eigenvalue of the Choi matrix for a given dynamical\n    map at time t_f.\n    \"\"\"\n    # Define system Hamiltonian and coupling operator\n    H = (omega / 2.0) * SIGMA_Z\n    V = SIGMA_X\n    \n    # Store the evolved basis matrices E_ij(t_f)\n    evolved_basis = []\n    \n    # Propagate each basis matrix from t=0 to t=t_f\n    for E_ij in BASIS:\n        if method == 'naive':\n            # Initial state: rho_0(0) = E_ij, rho_1(0) = 0\n            y0 = np.concatenate((E_ij.flatten(), np.zeros(4, dtype=complex)))\n            # Define anonymous function for the ODE solver with fixed parameters\n            ode_func = lambda t, y: dydt_naive(t, y, H, V, c, nu)\n            sol = solve_ivp(ode_func, (0, t_f), y0, method='RK45', atol=1e-9, rtol=1e-9)\n            # Extract final physical density operator\n            rho_f = sol.y[0:4, -1].reshape((2, 2))\n        elif method == 'terminator':\n            # Initial state: rho_0(0) = E_ij\n            y0 = E_ij.flatten()\n            ode_func = lambda t, y: dydt_terminator(t, y, H, V, c, nu)\n            sol = solve_ivp(ode_func, (0, t_f), y0, method='RK45', atol=1e-9, rtol=1e-9)\n            # Extract final density operator\n            rho_f = sol.y[:, -1].reshape((2, 2))\n        else:\n            raise ValueError(f\"Unknown method '{method}' specified.\")\n            \n        evolved_basis.append(rho_f)\n        \n    # Unpack the evolved basis matrices\n    rho_f_00, rho_f_01, rho_f_10, rho_f_11 = evolved_basis\n    \n    # Construct the Choi matrix J using the formula\n    # J(E) = sum_{i,j} E(|i>"
        },
        {
            "introduction": "即使是经过修正的HEOM，其计算成本也可能很高，因此利用系统对称性进行优化至关重要。本练习以一个纯退相干模型为例，展示了如何利用自旋守恒对称性将HEOM生成元进行块对角化。通过这个练习 ，你将学会如何分析并利用模型的对称性来显著提高计算效率，而又不损失物理精度。",
            "id": "5294946",
            "problem": "考虑一个二能级量子系统（自旋-$\\frac{1}{2}$），其系统哈密顿量为 $H_{\\mathrm{s}} = \\tfrac{\\omega_{0}}{2} \\sigma_{z}$，该系统与一个玻色子环境相互作用，环境的平衡自相关函数由单指数项 $c \\, e^{-\\gamma t}$ 近似表示。在开放量子系统框架的标准假设（类玻恩的因子化初始态和平稳高斯浴）下，当仅保留一个指数项时，层次化运动方程（HEOM）可以在有限的层级深度 $K$ 处进行一致的截断。HEOM的未知量是主密度算符 $\\rho_{0}$ 和辅助密度算符 $\\rho_{n}$（$n = 1, 2, \\dots, K$）。在刘维尔空间中，通过按列堆叠对算符进行矢量化后，每个 $2 \\times 2$ 矩阵由一个长度为 $4$ 的向量表示。其时间演化是线性的且不依赖于时间，可以写成一个一阶常微分方程组：\n$$\n\\frac{d}{dt} \\, \\mathrm{vec}(\\rho_{n}) = \\mathcal{L}_{\\mathrm{s}} \\, \\mathrm{vec}(\\rho_{n}) - n \\gamma \\, \\mathrm{vec}(\\rho_{n}) - i \\, \\mathrm{vec}\\left([V, \\rho_{n+1}]\\right) - i n c \\, \\mathrm{vec}\\left([V, \\rho_{n-1}]\\right),\n$$\n其中 $n = 0, 1, \\dots, K$，并约定当 $n+1 > K$ 或 $n-1  0$ 时，相应项被省略。$V = \\sigma_{z}$，且 $\\mathcal{L}_{\\mathrm{s}}(\\cdot) = -i [H_{\\mathrm{s}}, \\cdot]$ 是系统刘维尔超算符。对易超算符的作用方式为 $[A, \\rho] = A \\rho - \\rho A$，在按列堆叠矢量化下，$\\mathrm{vec}(A \\rho - \\rho A) = \\left(I \\otimes A - A^{\\mathsf{T}} \\otimes I\\right) \\mathrm{vec}(\\rho)$，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。\n\n要求您利用组合哈密顿量与耦合算符的对称性，特别是沿 $z$ 轴的自旋投影守恒（等效于计算基中的宇称守恒），来将HEOM生成元进行块对角化。对于 $H_{\\mathrm{s}} \\propto \\sigma_{z}$ 和 $V = \\sigma_{z}$ 的情况，观察到 $\\mathcal{L}_{\\mathrm{s}}$ 和与 $V$ 的对易子保持了算符空间到对角和非对角子空间的分解。定义对角子空间为 $\\{|0\\rangle\\langle 0|, |1\\rangle\\langle 1|\\}$ 的张成空间，非对角子空间为 $\\{|0\\rangle\\langle 1|, |1\\rangle\\langle 0|\\}$ 的张成空间。证明当按子空间对矢量化变量进行排序时，HEOM生成元是块对角化的，并利用此特性计算相对于不使用对称性的朴素稠密方法的理论计算加速比。假设稠密矩阵-向量乘法的计算成本与矩阵维度 $n$ 的平方成正比，即与 $n^{2}$ 成正比。对于一个块大小为 $n_{1}, n_{2}, \\dots$ 的块对角矩阵，假设成本与 $\\sum_{b} n_{b}^{2}$ 成正比。\n\n从上述基本定义出发，设计一个程序，该程序能够：\n- 针对给定的参数 $(\\omega_{0}, \\gamma, c, K)$，使用按列堆叠矢量化以及超算符恒等式 $\\mathcal{L}_{\\mathrm{s}} = -i \\left(I \\otimes H_{\\mathrm{s}} - H_{\\mathrm{s}}^{\\mathsf{T}} \\otimes I\\right)$ 和 $[V, \\cdot] \\mapsto \\left(I \\otimes V - V^{\\mathsf{T}} \\otimes I\\right)$，构建完整的HEOM生成元矩阵。\n- 通过首先将所有层级的所有对角分量组合在一起，然后是所有层级的所有非对角分量，来构建对称性重排后的生成元，从而产生两个独立的块。\n- 计算理论加速因子 $S$，定义为\n$$\nS \\equiv \\frac{n_{\\mathrm{full}}^{2}}{\\sum_{b} n_{b}^{2}},\n$$\n其中 $n_{\\mathrm{full}}$ 是完整生成元的维度，$n_{b}$ 是对称性约简后的块维度。\n- 通过计算生成元的矩阵指数并将其应用于初始态，在指定的时间列表上进行HEOM的时间演化。对于完整演化和块对角化演化，使用相同的初始 $\\rho_{0}$ 和为零的辅助密度 $\\rho_{n>0}$，并从演化后的主密度 $\\rho_{0}(t)$ 重建可观测量。\n\n为了证明基于对称性的约简不会引入物理精度的损失，在每个时间点为两种方法计算来自 $\\rho_{0}(t)$ 的两个可观测量，并报告在整个时间网格上的最大绝对偏差：\n- 沿 $z$ 轴的自旋投影，$\\langle \\sigma_{z} \\rangle(t) = \\mathrm{Tr}(\\sigma_{z} \\rho_{0}(t))$。\n- 非对角相干性的大小，$\\left| \\rho_{0,01}(t) \\right|$，其中 $\\rho_{0,01}(t)$ 表示矩阵元 $\\langle 0 | \\rho_{0}(t) | 1 \\rangle$。\n\n使用以下测试套件。所有频率单位为弧度/秒，时间单位为秒。初始主密度算符 $\\rho_{0}(0)$ 由其对角元 $p_{\\uparrow}$ 和 $p_{\\downarrow}$ 以及一个复数非对角元 $r$ 指定；辅助密度初始化为零。确保 $\\rho_{0}(0)$ 是半正定的且迹为1。对于每个测试用例，演化到所列的时间点并报告：\n- 理论加速因子 $S$（浮点数）。\n- 在整个时间网格上 $\\langle \\sigma_{z} \\rangle(t)$ 的最大绝对偏差（浮点数）。\n- 在整个时间网格上 $\\left| \\rho_{0,01}(t) \\right|$ 的最大绝对偏差（浮点数）。\n- 一个布尔值，指示两个偏差是否都小于 $10^{-10}$。\n\n测试套件：\n- 情况 1（一般正常路径）：$\\omega_{0} = 1.0 \\times 10^{12}$，$\\gamma = 2.5 \\times 10^{12}$， $c = 3.0 \\times 10^{11}$， $K = 1$，$p_{\\uparrow} = 0.6$，$p_{\\downarrow} = 0.4$，$r = 0.2 + 0.1 i$，时间点 $[0.0, 5.0 \\times 10^{-13}, 1.0 \\times 10^{-12}, 2.0 \\times 10^{-12}]$。\n- 情况 2（边界情况：纯对角初始态）：$\\omega_{0} = 1.0 \\times 10^{12}$，$\\gamma = 2.5 \\times 10^{12}$， $c = 3.0 \\times 10^{11}$， $K = 1$，$p_{\\uparrow} = 0.6$，$p_{\\downarrow} = 0.4$，$r = 0.0 + 0.0 i$，时间点 $[0.0, 1.0 \\times 10^{-12}]$。\n- 情况 3（边界情况：零系统劈裂，更深层级）：$\\omega_{0} = 0.0$，$\\gamma = 1.0 \\times 10^{13}$， $c = 5.0 \\times 10^{12}$， $K = 2$，$p_{\\uparrow} = 0.7$，$p_{\\downarrow} = 0.3$，$r = 0.0 + 0.25 i$，时间点 $[0.0, 1.0 \\times 10^{-13}, 5.0 \\times 10^{-13}, 1.0 \\times 10^{-12}]$。\n\n您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表。列表中的每个元素本身都是一个列表，按测试套件的顺序对应一个测试用例。每个内部列表必须是如上所述的 $[S, \\mathrm{max\\_abs\\_dev\\_sz}, \\mathrm{max\\_abs\\_dev\\_coh}, \\mathrm{is\\_accurate}]$ 形式。例如，一个有效的输出看起来会是 $[[2.0,0.0,0.0,True],[\\dots],[\\dots]]$。",
            "solution": "用户提供了一个关于二能级量子系统的层次化运动方程（HEOM）的问题。任务是验证该问题，如果有效，则提供一个合理的解决方案和一个利用特定对称性以实现计算加速的Python实现。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **系统哈密顿量**：$H_{\\mathrm{s}} = \\tfrac{\\omega_{0}}{2} \\sigma_{z}$。\n*   **系统-浴耦合算符**：$V = \\sigma_{z}$。\n*   **玻色子环境**：平衡自相关函数由单指数项 $c \\, e^{-\\gamma t}$ 近似表示。\n*   **HEOM 结构**：\n    $$ \\frac{d}{dt} \\, \\mathrm{vec}(\\rho_{n}) = \\mathcal{L}_{\\mathrm{s}} \\, \\mathrm{vec}(\\rho_{n}) - n \\gamma \\, \\mathrm{vec}(\\rho_{n}) - i \\, \\mathrm{vec}\\left([V, \\rho_{n+1}]\\right) - i n c \\, \\mathrm{vec}\\left([V, \\rho_{n-1}]\\right) $$\n    其中 $n = 0, 1, \\dots, K$，并有对超出此范围的索引的截断条件。\n*   **超算符与矢量化**：\n    *   $\\mathcal{L}_{\\mathrm{s}}(\\cdot) = -i [H_{\\mathrm{s}}, \\cdot]$。\n    *   矢量化方式为按列堆叠。\n    *   对易子的矩阵形式：$\\mathrm{vec}(A \\rho B) = (B^{\\mathsf{T}} \\otimes A)\\mathrm{vec}(\\rho)$，导出 $\\mathrm{vec}([A, \\rho]) = \\mathrm{vec}(A\\rho - \\rho A) = (I \\otimes A - A^{\\mathsf{T}} \\otimes I)\\mathrm{vec}(\\rho)$。\n    *   因此，$\\mathcal{L}_{\\mathrm{s}}$ 由矩阵 $-i(I \\otimes H_{\\mathrm{s}} - H_{\\mathrm{s}}^{\\mathsf{T}} \\otimes I)$ 表示。\n*   **对称性与子空间**：\n    *   对于 $H_{\\mathrm{s}} \\propto \\sigma_{z}$ 和 $V = \\sigma_{z}$，动力学保持算符空间到对角和非对角子空间的分解。\n    *   对角子空间：$\\{ |0\\rangle\\langle 0|, |1\\rangle\\langle 1| \\}$ 的张成空间。\n    *   非对角子空间：$\\{ |0\\rangle\\langle 1|, |1\\rangle\\langle 0| \\}$ 的张成空间。\n*   **计算成本与加速比**：\n    *   稠密矩阵-向量乘法的成本与 $n^2$ 成正比。\n    *   块对角矩阵的成本与 $\\sum_{b} n_{b}^{2}$ 成正比。\n    *   加速比定义为 $S \\equiv \\frac{n_{\\mathrm{full}}^{2}}{\\sum_{b} n_{b}^{2}}$。\n*   **任务**：\n    1.  构建完整的和对称性重排后的HEOM生成元。\n    2.  计算理论加速比 $S$。\n    3.  使用两种生成元通过矩阵指数化方法对初始态进行时间演化。\n    4.  比较得到的观测量 $\\langle \\sigma_{z} \\rangle(t) = \\mathrm{Tr}(\\sigma_{z} \\rho_{0}(t))$ 和 $|\\rho_{0,01}(t)|$，找出最大绝对偏差并验证精度（ $10^{-10}$）。\n*   **初始条件**：$\\rho_{0}(0)$ 由其布居数 $p_{\\uparrow}, p_{\\downarrow}$ 和相干项 $r$ 指定。辅助密度 $\\rho_{n>0}(0) = 0$。\n*   **测试套件**：提供了三个具体案例，包含 $(\\omega_{0}, \\gamma, c, K)$、初始态和时间点的参数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在科学上是成立的，属于开放量子系统标准理论的范畴。HEOM表述是非马尔可夫动力学的基石之一。所选的系统，一个具有纯退相干哈密顿量（$H_s \\propto \\sigma_z$）和耦合（$V = \\sigma_z$）的自旋-玻色子模型，是一个典型的例子。所有的数学定义（矢量化、超算符）都是标准的。问题是适定的：它指定了一个具有常系数矩阵（HEOM生成元）的线性常微分方程组，对于给定的初始状态，它有唯一的解。测试用例中提供的初始密度矩阵在物理上是有效的（迹为1且半正定）。参数和任务定义清晰、完整且一致。所要求的对称性分析是计算物理中一种有效且常用的降低计算成本的技术。该问题既不琐碎也非不适定。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。这是一个计算物理学中合理、定义明确的问题。将提供完整的解决方案。\n\n### 解决方案\n\n该问题要求我们构建层次化运动方程（HEOM）的生成元，利用对称性将其块对角化，并对两种方法进行数值比较。\n\n**1. 刘维尔空间表示**\n\n一个 $2 \\times 2$ 的密度算符 $\\rho$ 是一个 $4$ 维向量空间（刘维尔空间）中的一个点。使用按列堆叠矢量化，矩阵 $\\rho = \\begin{pmatrix} \\rho_{00}  \\rho_{01} \\\\ \\rho_{10}  \\rho_{11} \\end{pmatrix}$ 被映射为一个向量 $\\mathrm{vec}(\\rho) = [\\rho_{00}, \\rho_{10}, \\rho_{01}, \\rho_{11}]^{\\mathsf{T}}$。HEOM描述了总维度为 $n_{\\mathrm{full}} = 4(K+1)$ 的状态向量 $\\vec{\\mathcal{R}} = [\\mathrm{vec}(\\rho_0)^{\\mathsf{T}}, \\mathrm{vec}(\\rho_1)^{\\mathsf{T}}, \\dots, \\mathrm{vec}(\\rho_K)^{\\mathsf{T}}]^{\\mathsf{T}}$ 的时间演化。演化方程为 $\\frac{d}{dt}\\vec{\\mathcal{R}} = \\mathcal{L}_{\\mathrm{HEOM}} \\vec{\\mathcal{R}}$，其中 $\\mathcal{L}_{\\mathrm{HEOM}}$ 是不依赖时间的HEOM生成元。\n\n**2. 超算符矩阵**\n\n系统哈密顿量是 $H_{\\mathrm{s}} = \\frac{\\omega_0}{2}\\sigma_z$，耦合算符是 $V=\\sigma_z$。我们采用计算基 $\\{|0\\rangle, |1\\rangle\\}$，其中 $\\sigma_z = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}$。$H_s$ 和 $V$ 都是对角矩阵。利用恒等式 $\\mathrm{vec}(A\\rho B) = (B^{\\mathsf{T}} \\otimes A)\\mathrm{vec}(\\rho)$，系统刘维尔超算符 $\\mathcal{L}_{\\mathrm{s}} = -i[H_s, \\cdot]$ 和耦合超算符项 $-i[V, \\cdot]$ 可由 $4 \\times 4$ 矩阵表示：\n$$ \\mathcal{L}_{\\mathrm{s}} \\rightarrow \\mathbf{L_s} = -i(I \\otimes H_s - H_s^{\\mathsf{T}} \\otimes I) = \\mathrm{diag}(0, i\\omega_0, -i\\omega_0, 0) $$\n$$ -i[V, \\cdot] \\rightarrow \\mathbf{V_{op}} = -i(I \\otimes V - V^{\\mathsf{T}} \\otimes I) = \\mathrm{diag}(0, 2i, -2i, 0) $$\n这些矩阵作用于矢量化的密度算符 $[\\rho_{00}, \\rho_{10}, \\rho_{01}, \\rho_{11}]^{\\mathsf{T}}$。\n\n**3. HEOM生成元构建**\n\n完整的HEOM生成元 $\\mathcal{L}_{\\mathrm{HEOM}}$ 是一个大小为 $4(K+1) \\times 4(K+1)$ 的块三对角矩阵。这些块是 $4 \\times 4$ 的矩阵，由HEOM结构定义：\n*   第 $(n,n)$ 块（在主对角线上）是 $\\mathbf{L_s} - n\\gamma I_4$。\n*   第 $(n,n+1)$ 块（在上对角线上）是 $\\mathbf{V_{op}}$。\n*   第 $(n,n)$ 块（在下对角线上）是 $n c \\mathbf{V_{op}}$。\n\n**4. 对称性与块对角化**\n\n关键在于，$\\mathbf{L_s}$ 和 $\\mathbf{V_{op}}$ 在标准按列堆叠基下都是对角矩阵。第一和第四个基向量对应 $\\rho$ 的对角元（$\\rho_{00}$ 和 $\\rho_{11}$），而第二和第三个基向量对应非对角元（$\\rho_{10}$ 和 $\\rho_{01}$）。$\\mathbf{L_s}$ 和 $\\mathbf{V_{op}}$ 的对角结构（第一和第四行/列为零）意味着它们不会混合对角和非对角子空间。\n\n此属性可以推广到整个HEOM生成元：所有辅助密度算符 $\\{\\rho_n\\}$ 的对角分量的动力学完全与它们的非对角分量的动力学解耦。因此，我们可以重新排列总状态向量 $\\vec{\\mathcal{R}}$ 的基，先将所有 $2(K+1)$ 个对角分量组合在一起，然后是所有 $2(K+1)$ 个非对角分量。这将 $\\mathcal{L}_{\\mathrm{HEOM}}$ 变换为一个块对角矩阵：\n$$ \\mathcal{L}_{\\mathrm{reordered}} = \\begin{pmatrix} \\mathcal{L}_{\\mathrm{D}}  0 \\\\ 0  \\mathcal{L}_{\\mathrm{OD}} \\end{pmatrix} $$\n*   第一个块 $\\mathcal{L}_{\\mathrm{D}}$ 的大小为 $n_{\\mathrm{D}} = 2(K+1)$，控制对角分量向量 $[\\rho_{00}^{(0)}, \\rho_{11}^{(0)}, \\dots, \\rho_{00}^{(K)}, \\rho_{11}^{(K)}]^{\\mathsf{T}}$ 的演化。\n*   第二个块 $\\mathcal{L}_{\\mathrm{OD}}$ 的大小为 $n_{\\mathrm{OD}} = 2(K+1)$，控制非对角分量向量 $[\\rho_{10}^{(0)}, \\rho_{01}^{(0)}, \\dots, \\rho_{10}^{(K)}, \\rho_{01}^{(K)}]^{\\mathsf{T}}$ 的演化。\n\n$\\mathcal{L_s}$ 和 $[V, \\cdot]$ 对任何对角算符的作用均为零。因此，对角子空间的生成元 $\\mathcal{L}_{\\mathrm{D}}$ 只是一个对角矩阵，其对角元为 $\\rho_n$ 分量对应的 $-n\\gamma$。非对角子空间的生成元 $\\mathcal{L}_{\\mathrm{OD}}$ 保留了块三对角结构，但其中的块是 $2 \\times 2$ 的，表示 $\\mathcal{L_s}$ 和 $[V, \\cdot]$ 在非对角子空间内的作用。\n\n**5. 计算加速**\n\n矩阵-向量乘法的计算成本与矩阵维度的平方成正比。对于原始的“朴素”方法，成本与 $n_{\\mathrm{full}}^2 = (4(K+1))^2$ 成正比。对于块对角化方法，成本是每个块成本的总和，即 $\\sum_b n_b^2 = n_{\\mathrm{D}}^2 + n_{\\mathrm{OD}}^2 = (2(K+1))^2 + (2(K+1))^2$。理论加速因子为：\n$$ S = \\frac{n_{\\mathrm{full}}^2}{n_{\\mathrm{D}}^2 + n_{\\mathrm{OD}}^2} = \\frac{(4(K+1))^2}{(2(K+1))^2 + (2(K+1))^2} = \\frac{16(K+1)^2}{4(K+1)^2 + 4(K+1)^2} = \\frac{16}{8} = 2 $$\n对于这个特定的纯退相干模型，加速比是一个常数因子 $2$，与层级深度 $K$ 无关。\n\n**6. 算法实现**\n\n程序将为每个测试用例实现以下步骤：\n1.  构建完整的生成元 $\\mathcal{L}_{\\mathrm{HEOM}}$ 和两个块生成元 $\\mathcal{L}_{\\mathrm{D}}$ 和 $\\mathcal{L}_{\\mathrm{OD}}$。\n2.  计算理论加速因子 $S=2.0$。\n3.  根据给定的参数 $p_{\\uparrow}, p_{\\downarrow}, r$ 准备完整表示和块分解表示的初始状态向量。\n4.  对于每个时间点 $t$，通过计算生成元的矩阵指数与初始状态向量的乘积来计算时间演化后的状态：$\\vec{\\mathcal{R}}(t) = e^{\\mathcal{L}_{\\mathrm{HEOM}} t} \\vec{\\mathcal{R}}(0)$。对完整方法和块对角化方法都执行此操作。\n5.  从演化后的状态向量中提取主密度算符 $\\rho_0(t)$。\n6.  为两种方法计算可观测量 $\\langle \\sigma_z \\rangle(t) = \\rho_{00}(t) - \\rho_{11}(t)$ 和 $|\\rho_{01}(t)|$。\n7.  确定两种方法在整个时间网格上每个可观测量的最大绝对偏差。\n8.  验证偏差是否低于 $10^{-10}$ 的数值容差。\n\n此过程将通过数值方式证明，基于对称性的块对角化在机器精度范围内产生相同的物理结果，同时提供计算优势。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef run_case(params):\n    \"\"\"\n    Solves one test case for the HEOM problem.\n    \"\"\"\n    w0, gamma, c, K, p_up, p_down, r, times = params\n\n    # 1. Define base matrices and superoperators\n    I2 = np.identity(2, dtype=complex)\n    sz = np.array([[1, 0], [0, -1]], dtype=complex)\n    Hs = (w0 / 2) * sz\n    V = sz\n\n    # Superoperators in 4D Liouville space (column-stacking: rho_00, rho_10, rho_01, rho_11)\n    # These are derived using the Kronecker product identity vec(ABC) = (C.T kron A)vec(B)\n    I4 = np.identity(4, dtype=complex)\n    Ls_full = -1j * (np.kron(I2, Hs) - np.kron(Hs.T, I2))\n    Cv_full = np.kron(I2, V) - np.kron(V.T, I2)\n    Vop_full = -1j * Cv_full\n    \n    # 2. Construct full HEOM generator\n    n_full_dim = 4 * (K + 1)\n    L_full = np.zeros((n_full_dim, n_full_dim), dtype=complex)\n    for n in range(K + 1):\n        idx = 4 * n\n        # Diagonal block (n, n)\n        L_full[idx:idx+4, idx:idx+4] = Ls_full - n * gamma * I4\n        # Super-diagonal block (n, n+1)\n        if n  K:\n            L_full[idx:idx+4, idx+4:idx+8] = Vop_full\n        # Sub-diagonal block (n, n-1)\n        if n > 0:\n            L_full[idx:idx+4, idx-4:idx] = n * c * Vop_full\n\n    # 3. Construct block-diagonal generators\n    n_diag_dim = 2 * (K + 1)\n    n_offdiag_dim = 2 * (K + 1)\n\n    # Diagonal block generator (for [rho_00, rho_11] components)\n    # The action of Ls and Vop on diagonal elements of rho is zero.\n    L_D = np.zeros((n_diag_dim, n_diag_dim), dtype=complex)\n    for n in range(K+1):\n        idx = 2 * n\n        L_D[idx:idx+2, idx:idx+2] = -n * gamma * I2\n        \n    # Off-diagonal block generator (for [rho_10, rho_01] components)\n    # The basis for this block is {|1>0|, |0>1|}\n    Ls_od = np.diag([1j * w0, -1j * w0])\n    Vop_od = np.diag([2j, -2j])\n    \n    L_OD = np.zeros((n_offdiag_dim, n_offdiag_dim), dtype=complex)\n    for n in range(K + 1):\n        idx = 2 * n\n        # Diagonal block (n, n)\n        L_OD[idx:idx+2, idx:idx+2] = Ls_od - n * gamma * I2\n        # Super-diagonal block (n, n+1)\n        if n  K:\n            L_OD[idx:idx+2, idx+2:idx+4] = Vop_od\n        # Sub-diagonal block (n, n-1)\n        if n > 0:\n            L_OD[idx:idx+2, idx-2:idx] = n * c * Vop_od\n\n    # 4. Calculate theoretical speedup factor\n    speedup = (n_full_dim**2) / (n_diag_dim**2 + n_offdiag_dim**2)\n\n    # 5. Prepare initial states\n    rho0_initial = np.array([[p_up, r], [np.conj(r), p_down]], dtype=complex)\n\n    # Full initial vector\n    R_full_0 = np.zeros(n_full_dim, dtype=complex)\n    R_full_0[0:4] = np.array([rho0_initial[0,0], rho0_initial[1,0], rho0_initial[0,1], rho0_initial[1,1]])\n\n    # Block-decomposed initial vectors\n    R_D_0 = np.zeros(n_diag_dim, dtype=complex)\n    R_D_0[0:2] = np.array([rho0_initial[0,0], rho0_initial[1,1]])\n    \n    R_OD_0 = np.zeros(n_offdiag_dim, dtype=complex)\n    R_OD_0[0:2] = np.array([rho0_initial[1,0], rho0_initial[0,1]])\n\n    # 6. Propagate in time and compare observables\n    sz_vals_full, coh_vals_full = [], []\n    sz_vals_block, coh_vals_block = [], []\n\n    for t in times:\n        # Full propagation\n        propagator_full = expm(L_full * t)\n        R_full_t = propagator_full @ R_full_0\n        vec_rho0_full = R_full_t[0:4]\n        rho0_full = np.array([[vec_rho0_full[0], vec_rho0_full[2]], [vec_rho0_full[1], vec_rho0_full[3]]])\n        \n        # Block propagation\n        propagator_D = expm(L_D * t)\n        R_D_t = propagator_D @ R_D_0\n        propagator_OD = expm(L_OD * t)\n        R_OD_t = propagator_OD @ R_OD_0\n        rho0_block = np.array([[R_D_t[0], R_OD_t[1]], [R_OD_t[0], R_D_t[1]]])\n        \n        # Calculate observables for both methods\n        sz_vals_full.append(np.trace(sz @ rho0_full).real)\n        coh_vals_full.append(np.abs(rho0_full[0, 1]))\n        \n        sz_vals_block.append(np.trace(sz @ rho0_block).real)\n        coh_vals_block.append(np.abs(rho0_block[0, 1]))\n        \n    # 7. Compute maximum absolute deviations\n    max_abs_dev_sz = np.max(np.abs(np.array(sz_vals_full) - np.array(sz_vals_block)))\n    max_abs_dev_coh = np.max(np.abs(np.array(coh_vals_full) - np.array(coh_vals_block)))\n    is_accurate = (max_abs_dev_sz  1e-10) and (max_abs_dev_coh  1e-10)\n    \n    return [speedup, max_abs_dev_sz, max_abs_dev_coh, is_accurate]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0e12, 2.5e12, 3.0e11, 1, 0.6, 0.4, 0.2 + 0.1j, np.array([0.0, 5.0e-13, 1.0e-12, 2.0e-12])),\n        (1.0e12, 2.5e12, 3.0e11, 1, 0.6, 0.4, 0.0 + 0.0j, np.array([0.0, 1.0e-12])),\n        (0.0, 1.0e13, 5.0e12, 2, 0.7, 0.3, 0.0 + 0.25j, np.array([0.0, 1.0e-13, 5.0e-13, 1.0e-12]))\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Custom string formatting to avoid default numpy/python representations\n    formatted_results = []\n    for res in results:\n        s = f\"[{res[0]},{res[1]},{res[2]},{'True' if res[3] else 'False'}]\"\n        formatted_results.append(s)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}