{
    "hands_on_practices": [
        {
            "introduction": "The Hierarchical Equations of Motion (HEOM) can appear daunting due to its abstract and general formulation. This first exercise provides a concrete starting point by asking you to derive the equation of motion for the first-tier auxiliary density operators from the general formula . By working through this derivation, you will gain a hands-on understanding of the HEOM's structure and how the different tiers of the hierarchy are interconnected.",
            "id": "190598",
            "problem": "The Hierarchical Equations of Motion (HEOM) provide a powerful non-perturbative method for studying the dynamics of a quantum system coupled to a harmonic bath. Consider a quantum system with Hamiltonian $H_S$ coupled to a bath of harmonic oscillators through an interaction Hamiltonian $H_{SB} = V \\otimes B$, where $V$ is a system operator and $B$ is a collective bath coordinate.\n\nThe properties of the bath and its coupling to the system are entirely characterized by the bath correlation function $C(t) = \\langle B(t)B(0) \\rangle_B$, which is related to the spectral density $J(\\omega)$ via the fluctuation-dissipation theorem. For a bath described by the Drude-Lorentz spectral density,\n$$ J(\\omega) = 2\\lambda\\gamma \\frac{\\omega}{\\omega^2 + \\gamma^2} $$\nwhere $\\lambda$ is the reorganization energy and $\\gamma$ is the characteristic frequency of the bath, the correlation function at a finite temperature $T$ can be decomposed into an infinite sum of exponential terms for $t>0$:\n$$ C(t) = \\sum_{k=0}^{\\infty} c_k e^{-\\nu_k t} $$\nThe exponents are given by the Drude decay rate $\\nu_0 = \\gamma$ and the Matsubara frequencies $\\nu_k = 2\\pi k/(\\beta\\hbar)$ for $k \\ge 1$, where $\\beta = 1/(k_B T)$. The corresponding coefficients are:\n$$ c_0 = \\lambda\\gamma \\left( \\cot\\left(\\frac{\\beta\\hbar\\gamma}{2}\\right) - i \\right) $$\n$$ c_k = \\frac{4\\lambda\\gamma\\nu_k}{\\beta\\hbar(\\nu_k^2 - \\gamma^2)} \\quad \\text{for } k \\ge 1 $$\n\nThe HEOM method describes the evolution of the system's reduced density operator $\\rho(t)$ by coupling it to a hierarchy of auxiliary density operators (ADOs), $\\rho_{\\mathbf{n}}(t)$. The index $\\mathbf{n} = (n_0, n_1, n_2, \\dots)$ is a vector of non-negative integers, where $n_k$ corresponds to the $k$-th mode in the exponential decomposition of $C(t)$. The physical density operator is the top-tier member of the hierarchy, $\\rho(t) \\equiv \\rho_{\\mathbf{n}=\\mathbf{0}}(t)$. The time evolution of the entire hierarchy is given by the set of coupled differential equations:\n$$ \\frac{d}{dt}\\rho_{\\mathbf{n}}(t) = -\\left(\\frac{i}{\\hbar}[H_S, \\cdot] + \\sum_{j=0}^{\\infty} n_j \\nu_j \\right) \\rho_{\\mathbf{n}}(t) - \\frac{i}{\\hbar} \\sum_{j=0}^{\\infty} [V, \\rho_{\\mathbf{n}+\\mathbf{e}_j}(t)] - \\frac{i}{\\hbar} \\sum_{j=0}^{\\infty} n_j \\left(c_j V \\rho_{\\mathbf{n}-\\mathbf{e}_j}(t) - c_j^* \\rho_{\\mathbf{n}-\\mathbf{e}_j}(t) V\\right) $$\nwhere $\\mathbf{e}_j$ is a unit vector with a 1 in the $j$-th position and 0 otherwise.\n\nThe tier of an ADO $\\rho_{\\mathbf{n}}$ is defined by the sum of its indices, $N = \\sum_j n_j$. The first tier corresponds to $N=1$. We denote these first-tier ADOs as $\\rho^{(k)}(t) \\equiv \\rho_{\\mathbf{e}_k}(t)$. Similarly, second-tier ADOs can be denoted as $\\rho^{(k,j)}(t) \\equiv \\rho_{\\mathbf{e}_k+\\mathbf{e}_j}(t)$.\n\nYour task is to derive the specific equation of motion for a first-tier auxiliary density operator, $\\frac{d}{dt}\\rho^{(k)}(t)$, for any non-negative integer $k \\ge 0$. Express your answer in terms of $H_S$, $V$, the bath parameters ($\\nu_k, c_k$), the zeroth-tier operator $\\rho(t)$, the first-tier operator $\\rho^{(k)}(t)$, and second-tier operators $\\rho^{(k,j)}(t)$.",
            "solution": "We start from the general HEOM for an ADO indexed by $\\mathbf{n}=(n_0,n_1,\\dots)$:\n\n$$\n\\frac{d}{dt}\\rho_{\\mathbf{n}}\n=-\\Bigl(\\frac{i}{\\hbar}[H_S,\\cdot]+\\sum_j n_j\\nu_j\\Bigr)\\rho_{\\mathbf{n}}\n-\\frac{i}{\\hbar}\\sum_j[V,\\rho_{\\mathbf{n}+\\mathbf{e}_j}]\n-\\frac{i}{\\hbar}\\sum_j n_j\\bigl(c_jV\\rho_{\\mathbf{n}-\\mathbf{e}_j}-c_j^*\\rho_{\\mathbf{n}-\\mathbf{e}_j}V\\bigr).\n$$\n\nFor the first‐tier ADO $\\rho^{(k)}=\\rho_{\\mathbf{e}_k}$, we have $n_j=\\delta_{jk}$.  Hence:\n1. $\\sum_j n_j\\nu_j = \\nu_k.$\n2. $\\rho_{\\mathbf{e}_k+\\mathbf{e}_j}=\\rho^{(k,j)},$ so \n   $\\sum_j [V,\\rho_{\\mathbf{e}_k+\\mathbf{e}_j}]\n   =\\sum_{j=0}^\\infty[V,\\rho^{(k,j)}].$\n3. Only $j=k$ contributes in the last sum:\n   $\\rho_{\\mathbf{e}_k-\\mathbf{e}_j}=\\rho_{\\mathbf{0}}=\\rho(t)$ when $j=k$, and zero otherwise.  \n   Thus\n   $\\sum_j n_j(c_jV\\rho_{\\mathbf{e}_k-\\mathbf{e}_j}-c_j^*\\rho_{\\mathbf{e}_k-\\mathbf{e}_j}V)\n   =c_kV\\rho(t)-c_k^*\\rho(t)V.$\n\nPutting these together,\n\n$$\n\\frac{d}{dt}\\rho^{(k)}(t)\n=-\\frac{i}{\\hbar}[H_S,\\rho^{(k)}]\n-\\nu_k\\,\\rho^{(k)}\n-\\frac{i}{\\hbar}\\sum_{j=0}^\\infty[V,\\rho^{(k,j)}]\n-\\frac{i}{\\hbar}\\bigl(c_kV\\rho(t)-c_k^*\\rho(t)V\\bigr).\n$$",
            "answer": "$$\\boxed{\\frac{d}{dt}\\rho^{(k)}(t)\n=-\\frac{i}{\\hbar}[H_S,\\rho^{(k)}(t)]\n-\\nu_k\\,\\rho^{(k)}(t)\n-\\frac{i}{\\hbar}\\sum_{j=0}^\\infty[V,\\rho^{(k,j)}(t)]\n-\\frac{i}{\\hbar}\\bigl(c_kV\\rho(t)-c_k^*\\rho(t)V\\bigr)}$$"
        },
        {
            "introduction": "In any practical application, the infinite hierarchy of the HEOM must be truncated, which can introduce unphysical artifacts. This exercise tackles a crucial issue: the potential violation of complete positivity by naive truncation, leading to nonsensical results like negative probabilities . You will not only diagnose this failure by constructing a numerical counterexample but also derive and implement a physically-motivated 'terminator' that restores the map's complete positivity.",
            "id": "3771225",
            "problem": "Consider a two-level quantum system (qubit) with system Hamiltonian $H = \\frac{\\omega}{2}\\,\\sigma_z$ and system-bath coupling operator $V = \\sigma_x$, interacting with a bosonic environment whose equilibrium two-time correlation function admits a single-exponential decomposition $C(t) = c\\,e^{-\\nu t}$, where $c > 0$ and $\\nu > 0$ are dimensionless constants. The reduced system dynamics can be described using the Hierarchical Equations of Motion (HEOM) truncated at tier $N=1$, yielding a coupled set of linear equations for the physical density operator $\\rho_0(t)$ and a single auxiliary density operator $\\rho_1(t)$:\n- The physical density operator obeys $\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] - i[V,\\rho_1(t)]$.\n- The auxiliary density operator obeys $\\frac{d}{dt}\\rho_1(t) = -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,(V\\rho_0(t) - \\rho_0(t)V)$.\nHere $[A,B] = AB - BA$ denotes the commutator. The naive truncation at tier $N=1$ sets $\\rho_{2}(t) \\equiv 0$ and does not introduce any closure terms beyond this truncation.\n\nIn general, exact open-system dynamics under factorized initial conditions is completely positive (CP). However, approximate schemes, including naively truncated HEOM, can produce dynamics that fail to be completely positive. In this task, you will construct a counterexample where the naive $N=1$ HEOM truncation yields a non-completely-positive dynamical map at a fixed final time $t_{\\mathrm{f}}$, diagnose the failure by inspecting the Choi matrix of the dynamical map, and then propose and implement a modified terminator based on controlled timescale separation that restores approximate complete positivity.\n\nStarting from the fundamental Liouville–von Neumann equation $\\frac{d}{dt}\\rho_{\\mathrm{tot}}(t) = -i[H_{\\mathrm{tot}},\\rho_{\\mathrm{tot}}(t)]$ for the total system-plus-bath state and the definition of the HEOM construction for single-exponential bath correlations $C(t)$, derive an adiabatic-elimination-based closure that approximates the influence of the truncated tier on the dynamics of $\\rho_0(t)$ as an effective time-local generator that is of the Gorini–Kossakowski–Sudarshan–Lindblad (GKSL) form. Your derivation should proceed from the equations given above by applying a controlled separation of timescales argument for the auxiliary density operator and eliminating it, thereby obtaining an explicit generator acting only on $\\rho_0(t)$ which is manifestly completely positive when $V$ is Hermitian. Do not use or quote any shortcut formulas; derive the structure and the coefficient of the dissipator from first principles based on the provided equations and the single-exponential correlation model.\n\nNumerically verify complete positivity as follows. For a fixed set of parameters and a fixed time $t_{\\mathrm{f}}$, construct the dynamical map $\\mathcal{E}_{t_{\\mathrm{f}}}$ induced by the chosen dynamics (either naive truncated HEOM or the modified GKSL-closure terminator) by propagating the four matrix units $E_{00} = |0\\rangle\\langle 0|$, $E_{01} = |0\\rangle\\langle 1|$, $E_{10} = |1\\rangle\\langle 0|$, $E_{11} = |1\\rangle\\langle 1|$ from $t=0$ to $t=t_{\\mathrm{f}}$. Form the Choi matrix $J(\\mathcal{E}_{t_{\\mathrm{f}}}) = \\sum_{i,j\\in\\{0,1\\}} \\mathcal{E}_{t_{\\mathrm{f}}}(|i\\rangle\\langle j|) \\otimes |i\\rangle\\langle j|$ and compute its minimal eigenvalue. A negative minimal eigenvalue indicates a violation of complete positivity, while a nonnegative minimal eigenvalue corresponds to a completely positive map.\n\nYour program must implement both the naive truncated HEOM dynamics and the modified terminator derived by your adiabatic elimination analysis, and evaluate the minimal eigenvalue of the Choi matrix for the three test cases below. All quantities are dimensionless; no physical units are required.\n\nTest suite (each test case is a tuple specifying $(\\text{method}, \\omega, c, \\nu, t_{\\mathrm{f}})$):\n- Case 1 (strong coupling, naive truncation): $(\\text{naive}, 1.0, 6.0, 0.5, 3.0)$.\n- Case 2 (strong coupling, modified terminator): $(\\text{terminator}, 1.0, 6.0, 0.5, 3.0)$.\n- Case 3 (weak coupling, naive truncation): $(\\text{naive}, 1.0, 0.2, 2.0, 3.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3]\"). The entry for each test case must be a float equal to the minimal eigenvalue of the corresponding Choi matrix at time $t_{\\mathrm{f}}$. Use a numerically stable integration scheme and ensure that the Choi matrix is Hermitian before computing its eigenvalues by symmetrization $J \\mapsto \\frac{1}{2}(J + J^\\dagger)$. Clearly separate the implementation of the naive truncation and the modified terminator, and ensure the program runs self-contained without external input.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and contains all necessary information for a complete solution. It poses a standard, albeit non-trivial, task in the study of open quantum systems: analyzing the shortcomings of an approximation scheme (naive HEOM truncation) and deriving and implementing a physically motivated correction (an adiabatic-elimination-based terminator). The problem is therefore deemed valid.\n\nThe core of the task is to derive a master equation for the physical density operator $\\rho_0(t)$ by eliminating the auxiliary operator $\\rho_1(t)$ from the provided hierarchy truncated at level $N=1$. The starting point is the given set of coupled differential equations:\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] - i[V,\\rho_1(t)] \\quad \\cdots \\quad (1)\n$$\n$$\n\\frac{d}{dt}\\rho_1(t) = -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)] \\quad \\cdots \\quad (2)\n$$\nwhere $H = \\frac{\\omega}{2}\\,\\sigma_z$, $V = \\sigma_x$, and $[A,B] = AB-BA$.\n\nThe derivation proceeds via an adiabatic elimination procedure, which relies on a separation of timescales. We assume that the dynamics of the auxiliary operator $\\rho_1(t)$ are much faster than those of the physical operator $\\rho_0(t)$. This is physically justified in the limit where the bath memory time, characterized by $\\nu^{-1}$, is very short, or equivalently, when the bath decay rate $\\nu$ is large compared to other energy scales in the problem (such as $\\omega$ and norms of the coupling). In this limit, $\\rho_1(t)$ rapidly adjusts to the instantaneous state of $\\rho_0(t)$, allowing us to approximate its time derivative as zero.\n\nApplying this quasi-steady-state approximation to equation $(2)$, we set $\\frac{d}{dt}\\rho_1(t) \\approx 0$:\n$$\n0 \\approx -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)]\n$$\nTo solve for $\\rho_1(t)$, a further controlled approximation is made consistent with the timescale separation argument. If $\\nu$ is the dominant scale in the dynamics of $\\rho_1$, i.e., $\\nu \\gg \\omega$, the term $-\\nu\\,\\rho_1(t)$ will dominate over the term $-i[H,\\rho_1(t)]$. Neglecting the latter, we obtain a simplified algebraic relation:\n$$\n0 \\approx - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)]\n$$\nSolving this equation for $\\rho_1(t)$ gives the expression for the auxiliary operator in terms of the physical operator:\n$$\n\\rho_1(t) \\approx -\\frac{ic}{\\nu}\\,[V,\\rho_0(t)] \\quad \\cdots \\quad (3)\n$$\nThis expression captures the essence of the approximation: the auxiliary operator, which encodes system-bath correlations, is directly and instantaneously proportional to the commutator $[V, \\rho_0(t)]$, which drives the dissipative dynamics.\n\nNext, we substitute this expression for $\\rho_1(t)$ back into the equation of motion for $\\rho_0(t)$, equation $(1)$:\n$$\n\\frac{d}{dt}\\rho_0(t) \\approx -i[H,\\rho_0(t)] - i\\left[V, \\left(-\\frac{ic}{\\nu}\\,[V,\\rho_0(t)]\\right)\\right]\n$$\nSimplifying the expression yields:\n$$\n\\frac{d}{dt}\\rho_0(t) \\approx -i[H,\\rho_0(t)] - \\frac{c}{\\nu}\\left[V, [V,\\rho_0(t)]\\right] \\quad \\cdots \\quad (4)\n$$\nThis is a time-local or Markovian master equation for $\\rho_0(t)$. To verify that it is of the Gorini–Kossakowski–Sudarshan–Lindblad (GKSL) form, we expand the double commutator term. For any operators $V$ and $\\rho$:\n$$\n[V, [V, \\rho]] = V(V\\rho - \\rho V) - (V\\rho - \\rho V)V = V^2\\rho - V\\rho V - V\\rho V + \\rho V^2 = V^2\\rho + \\rho V^2 - 2V\\rho V\n$$\nThis can be written using the anti-commutator $\\{A,B\\} = AB+BA$ as:\n$$\n[V, [V, \\rho]] = \\{V^2, \\rho\\} - 2V\\rho V\n$$\nSubstituting this into the dissipative part of equation $(4)$:\n$$\n-\\frac{c}{\\nu}\\left[V, [V,\\rho_0(t)]\\right] = -\\frac{c}{\\nu}\\left(\\{V^2, \\rho_0(t)\\} - 2V\\rho_0(t)V\\right) = \\frac{2c}{\\nu}\\left(V\\rho_0(t)V - \\frac{1}{2}\\{V^2, \\rho_0(t)\\}\\right)\n$$\nThe master equation now takes the form:\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] + \\frac{2c}{\\nu}\\left(V\\rho_0(t)V - \\frac{1}{2}\\{V^2, \\rho_0(t)\\}\\right)\n$$\nThis is manifestly of the GKSL form $\\frac{d}{dt}\\rho = -i[H,\\rho] + \\sum_k \\gamma_k \\left( L_k \\rho L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho\\} \\right)$. In our case, there is a single Lindblad operator $L_1 = V = \\sigma_x$, which is Hermitian ($V^\\dagger=V$), and a corresponding decay rate $\\gamma_1 = \\frac{2c}{\\nu}$. Because any master equation in GKSL form generates a completely positive (CP) dynamical map, this \"terminator\" equation is guaranteed to preserve the complete positivity of the dynamics.\n\nFor the specific coupling operator $V=\\sigma_x$, we have $V^2 = \\sigma_x^2 = I$, where $I$ is the $2 \\times 2$ identity matrix. The anti-commutator simplifies to $\\{V^2, \\rho_0\\} = \\{I, \\rho_0\\} = I\\rho_0 + \\rho_0 I = 2\\rho_0$. The modified master equation becomes:\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] + \\frac{2c}{\\nu}\\left(\\sigma_x\\rho_0(t)\\sigma_x - \\rho_0(t)\\right)\n$$\nThis is the equation for the \"terminator\" method that will be implemented numerically. The numerical part will confirm that this derived equation indeed yields a CP map (minimal eigenvalue of Choi matrix $\\ge 0$), while the naive truncation can fail for certain parameters (minimal eigenvalue $< 0$).\n\nTo perform the numerical verification, we construct the dynamical map $\\mathcal{E}_{t_{\\mathrm{f}}}$ by propagating a basis of operators. The Choi matrix is then constructed as $J(\\mathcal{E}_{t_{\\mathrm{f}}}) = \\sum_{i,j=0}^{1} \\mathcal{E}_{t_{\\mathrm{f}}}(|i\\rangle\\langle j|) \\otimes |i\\rangle\\langle j|$. The map $\\mathcal{E}_{t_{\\mathrm{f}}}$ is completely positive if and only if its Choi matrix $J(\\mathcal{E}_{t_{\\mathrm{f}}})$ is positive semidefinite, which is verified by checking that its minimal eigenvalue is non-negative.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Define global constants (Pauli matrices, identity, and basis matrices)\n# for convenience and to avoid re-declaration.\nSIGMA_X = np.array([[0, 1], [1, 0]], dtype=complex)\nSIGMA_Z = np.array([[1, 0], [0, -1]], dtype=complex)\nID2 = np.identity(2, dtype=complex)\nE00 = np.array([[1, 0], [0, 0]], dtype=complex)\nE01 = np.array([[0, 1], [0, 0]], dtype=complex)\nE10 = np.array([[0, 0], [1, 0]], dtype=complex)\nE11 = np.array([[0, 0], [0, 1]], dtype=complex)\nBASIS = [E00, E01, E10, E11]\n\ndef dydt_naive(t, y, H, V, c, nu):\n    \"\"\"\n    Computes the time derivative for the naive N=1 truncated HEOM.\n    The state vector y is an 8-element complex array representing flattened\n    rho_0 (first 4 elements) and rho_1 (last 4 elements).\n    \"\"\"\n    # Reshape the flattened state vector into 2x2 density matrices\n    rho0 = y[0:4].reshape((2, 2))\n    rho1 = y[4:8].reshape((2, 2))\n    \n    # Calculate required commutators for the equations of motion\n    comm_H_rho0 = H @ rho0 - rho0 @ H\n    comm_V_rho1 = V @ rho1 - rho1 @ V\n    comm_H_rho1 = H @ rho1 - rho1 @ H\n    comm_V_rho0 = V @ rho0 - rho0 @ V\n    \n    # Equation for the physical density operator rho_0\n    d_rho0_dt = -1j * comm_H_rho0 - 1j * comm_V_rho1\n    \n    # Equation for the auxiliary density operator rho_1\n    d_rho1_dt = -1j * comm_H_rho1 - nu * rho1 - 1j * c * comm_V_rho0\n    \n    # Flatten the derivatives and concatenate into a single vector\n    return np.concatenate((d_rho0_dt.flatten(), d_rho1_dt.flatten()))\n\ndef dydt_terminator(t, y, H, V, c, nu):\n    \"\"\"\n    Computes the time derivative for the modified terminator (GKSL) equation.\n    The state vector y is a 4-element complex array representing flattened rho_0.\n    \"\"\"\n    # Reshape the flattened state vector into a 2x2 density matrix\n    rho0 = y.reshape((2, 2))\n    \n    # Coherent part of the evolution\n    comm_H_rho0 = H @ rho0 - rho0 @ H\n    \n    # Dissipative part (GKSL form derived from adiabatic elimination)\n    # The rate is gamma = 2*c/nu and the Lindblad operator is V = sigma_x.\n    # Since V^2 = I, the dissipator is gamma * (V * rho0 * V - rho0).\n    gamma = 2.0 * c / nu\n    dissipator = gamma * (V @ rho0 @ V - rho0)\n    \n    # Full equation of motion\n    d_rho0_dt = -1j * comm_H_rho0 + dissipator\n    \n    # Flatten the derivative for the ODE solver\n    return d_rho0_dt.flatten()\n\n\ndef calculate_min_eigenvalue(method, omega, c, nu, t_f):\n    \"\"\"\n    Calculates the minimal eigenvalue of the Choi matrix for a given dynamical\n    map at time t_f.\n    \"\"\"\n    # Define system Hamiltonian and coupling operator\n    H = (omega / 2.0) * SIGMA_Z\n    V = SIGMA_X\n    \n    # Store the evolved basis matrices E_ij(t_f)\n    evolved_basis = []\n    \n    # Propagate each basis matrix from t=0 to t=t_f\n    for E_ij in BASIS:\n        if method == 'naive':\n            # Initial state: rho_0(0) = E_ij, rho_1(0) = 0\n            y0 = np.concatenate((E_ij.flatten(), np.zeros(4, dtype=complex)))\n            # Define anonymous function for the ODE solver with fixed parameters\n            ode_func = lambda t, y: dydt_naive(t, y, H, V, c, nu)\n            sol = solve_ivp(ode_func, (0, t_f), y0, method='RK45', atol=1e-9, rtol=1e-9)\n            # Extract final physical density operator\n            rho_f = sol.y[0:4, -1].reshape((2, 2))\n        elif method == 'terminator':\n            # Initial state: rho_0(0) = E_ij\n            y0 = E_ij.flatten()\n            ode_func = lambda t, y: dydt_terminator(t, y, H, V, c, nu)\n            sol = solve_ivp(ode_func, (0, t_f), y0, method='RK45', atol=1e-9, rtol=1e-9)\n            # Extract final density operator\n            rho_f = sol.y[:, -1].reshape((2, 2))\n        else:\n            raise ValueError(f\"Unknown method '{method}' specified.\")\n            \n        evolved_basis.append(rho_f)\n        \n    # Unpack the evolved basis matrices\n    rho_f_00, rho_f_01, rho_f_10, rho_f_11 = evolved_basis\n    \n    # Construct the Choi matrix J using the formula\n    # J(E) = sum_{i,j} E(|i><j|) (x) |i><j|\n    J = (np.kron(rho_f_00, E00) +\n         np.kron(rho_f_01, E01) +\n         np.kron(rho_f_10, E10) +\n         np.kron(rho_f_11, E11))\n    \n    # Symmetrize the Choi matrix: J -> (J + J^dagger)/2.\n    # This enforces Hermiticity, correcting for small numerical floating-point errors.\n    J_hermitian = 0.5 * (J + J.conj().T)\n    \n    # Calculate eigenvalues of the Hermitian Choi matrix.\n    # np.linalg.eigvalsh is used for Hermitian matrices and returns real sorted eigenvalues.\n    eigenvalues = np.linalg.eigvalsh(J_hermitian)\n    \n    # The minimal eigenvalue determines if the map is completely positive.\n    min_eig = eigenvalues[0]\n    \n    return min_eig\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # (method, omega, c, nu, t_f)\n        ('naive', 1.0, 6.0, 0.5, 3.0),\n        ('terminator', 1.0, 6.0, 0.5, 3.0),\n        ('naive', 1.0, 0.2, 2.0, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        method, omega, c, nu, t_f = case\n        result = calculate_min_eigenvalue(method, omega, c, nu, t_f)\n        results.append(result)\n\n    # Print the final results in the specified format \"[result1,result2,result3]\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "The power of the HEOM method is often limited by its significant computational cost, especially for deep hierarchies. This practice introduces a powerful optimization technique based on physical symmetry . You will explore a model where a conservation law decouples the HEOM into independent blocks, and then quantify the resulting computational speedup, demonstrating how physical insight can lead to more efficient and feasible simulations.",
            "id": "5294946",
            "problem": "Consider a two-level quantum system (spin-$\\tfrac{1}{2}$) with system Hamiltonian $H_{\\mathrm{s}} = \\tfrac{\\omega_{0}}{2} \\sigma_{z}$, interacting with a bosonic environment whose equilibrium autocorrelation is approximated by a single exponential term $c \\, e^{-\\gamma t}$. Under standard assumptions of the open quantum system framework (Born-like factorized initial state and stationary Gaussian bath), the Hierarchical Equations of Motion (HEOM) truncate consistently at a finite tier depth $K$ when only one exponential term is retained. The HEOM unknowns are the primary density operator $\\rho_{0}$ and auxiliary density operators $\\rho_{n}$ for $n = 1, 2, \\dots, K$. In Liouville space, after vectorizing operators by column-stacking, each $2 \\times 2$ matrix is represented by a length-$4$ vector. The time evolution is linear and time-independent, and may be written as a system of first-order ordinary differential equations:\n$$\n\\frac{d}{dt} \\, \\mathrm{vec}(\\rho_{n}) = \\mathcal{L}_{\\mathrm{s}} \\, \\mathrm{vec}(\\rho_{n}) - n \\gamma \\, \\mathrm{vec}(\\rho_{n}) - i \\, \\mathrm{vec}\\left([V, \\rho_{n+1}]\\right) - i n c \\, \\mathrm{vec}\\left([V, \\rho_{n-1}]\\right),\n$$\nfor $n = 0, 1, \\dots, K$ with the conventions that terms with $n+1 > K$ or $n-1 < 0$ are omitted, $V = \\sigma_{z}$, and $\\mathcal{L}_{\\mathrm{s}}(\\cdot) = -i [H_{\\mathrm{s}}, \\cdot]$ is the system Liouvillian superoperator. The commutator superoperator acts as $[A, \\rho] = A \\rho - \\rho A$, and under column-stacking vectorization, $\\mathrm{vec}(A \\rho - \\rho A) = \\left(I \\otimes A - A^{\\mathsf{T}} \\otimes I\\right) \\mathrm{vec}(\\rho)$, where $I$ is the $2 \\times 2$ identity matrix.\n\nYou are asked to use a symmetry of the combined Hamiltonian and coupling operator, specifically the conservation of spin projection along the $z$-axis (equivalently, parity in the computational basis), to block-diagonalize the HEOM generator. For $H_{\\mathrm{s}} \\propto \\sigma_{z}$ and $V = \\sigma_{z}$, observe that $\\mathcal{L}_{\\mathrm{s}}$ and the commutator with $V$ preserve the decomposition of operator space into diagonal and off-diagonal subspaces. Define the diagonal subspace as the span of $\\{|0\\rangle\\langle 0|, |1\\rangle\\langle 1|\\}$ and the off-diagonal subspace as the span of $\\{|0\\rangle\\langle 1|, |1\\rangle\\langle 0|\\}$. Show that the HEOM generator is block-diagonal when ordering the vectorized variables by subspace, and exploit this to compute a theoretical computational speedup relative to the naive dense approach without symmetry. Assume the computational cost of a dense matrix-vector multiplication scales as the square of the dimension $n$ of the matrix, i.e., proportional to $n^{2}$. For a block-diagonal matrix with blocks of sizes $n_{1}, n_{2}, \\dots$, assume the cost scales as $\\sum_{b} n_{b}^{2}$.\n\nStarting from the fundamental definitions above, design a program that:\n- Constructs the full HEOM generator matrix for given parameters $(\\omega_{0}, \\gamma, c, K)$, using the column-stacking vectorization, and the superoperator identities $\\mathcal{L}_{\\mathrm{s}} = -i \\left(I \\otimes H_{\\mathrm{s}} - H_{\\mathrm{s}}^{\\mathsf{T}} \\otimes I\\right)$ and $[V, \\cdot] \\mapsto \\left(I \\otimes V - V^{\\mathsf{T}} \\otimes I\\right)$.\n- Constructs the symmetry-reordered generator by grouping all diagonal components of all tiers first, followed by all off-diagonal components of all tiers, thereby yielding two independent blocks.\n- Computes the theoretical speedup factor defined as\n$$\nS \\equiv \\frac{n_{\\mathrm{full}}^{2}}{\\sum_{b} n_{b}^{2}},\n$$\nwhere $n_{\\mathrm{full}}$ is the full generator dimension and $n_{b}$ are the block dimensions after symmetry reduction.\n- Propagates the HEOM in time by computing the matrix exponential of the generator and applying it to the initial state for a specified list of times. Use the same initial $\\rho_{0}$ and vanishing auxiliary densities $\\rho_{n>0}$ for both the full and block-diagonalized evolutions, and reconstruct observables from the evolved primary density $\\rho_{0}(t)$.\n\nTo demonstrate that the symmetry-based reduction introduces no loss of physical accuracy, compute at each time two observables from $\\rho_{0}(t)$ for both methods and report the maximum absolute deviations over the time grid:\n- The spin projection along $z$, $\\langle \\sigma_{z} \\rangle(t) = \\mathrm{Tr}(\\sigma_{z} \\rho_{0}(t))$.\n- The magnitude of the off-diagonal coherence, $\\left| \\rho_{0,01}(t) \\right|$, where $\\rho_{0,01}(t)$ denotes the matrix element $\\langle 0 | \\rho_{0}(t) | 1 \\rangle$.\n\nUse the following test suite. All frequencies are in radians per second and time is in seconds. The initial primary density operator $\\rho_{0}(0)$ is specified by its diagonal entries $p_{\\uparrow}$ and $p_{\\downarrow}$ and a complex off-diagonal $r$; auxiliary densities are initialized to zero. Ensure $\\rho_{0}(0)$ is positive semidefinite and has unit trace. For each test case, propagate to the listed times and report:\n- The theoretical speedup factor $S$ as a float.\n- The maximum absolute deviation in $\\langle \\sigma_{z} \\rangle(t)$ across the time grid as a float.\n- The maximum absolute deviation in $\\left| \\rho_{0,01}(t) \\right|$ across the time grid as a float.\n- A boolean indicating whether both deviations are less than $10^{-10}$.\n\nTest suite:\n- Case $1$ (general happy path): $\\omega_{0} = 1.0 \\times 10^{12}$, $\\gamma = 2.5 \\times 10^{12}$, $c = 3.0 \\times 10^{11}$, $K = 1$, $p_{\\uparrow} = 0.6$, $p_{\\downarrow} = 0.4$, $r = 0.2 + 0.1 i$, times $[0.0, 5.0 \\times 10^{-13}, 1.0 \\times 10^{-12}, 2.0 \\times 10^{-12}]$.\n- Case $2$ (edge case: purely diagonal initial state): $\\omega_{0} = 1.0 \\times 10^{12}$, $\\gamma = 2.5 \\times 10^{12}$, $c = 3.0 \\times 10^{11}$, $K = 1$, $p_{\\uparrow} = 0.6$, $p_{\\downarrow} = 0.4$, $r = 0.0 + 0.0 i$, times $[0.0, 1.0 \\times 10^{-12}]$.\n- Case $3$ (boundary case: zero system splitting, deeper hierarchy): $\\omega_{0} = 0.0$, $\\gamma = 1.0 \\times 10^{13}$, $c = 5.0 \\times 10^{12}$, $K = 2$, $p_{\\uparrow} = 0.7$, $p_{\\downarrow} = 0.3$, $r = 0.0 + 0.25 i$, times $[0.0, 1.0 \\times 10^{-13}, 5.0 \\times 10^{-13}, 1.0 \\times 10^{-12}]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list corresponding to one test case, in the order of the test suite. Each inner list must be of the form $[S, \\mathrm{max\\_abs\\_dev\\_sz}, \\mathrm{max\\_abs\\_dev\\_coh}, \\mathrm{is\\_accurate}]$ as specified above. For example, a valid output would look like $[[2.0,0.0,0.0,True],[\\dots],[\\dots]]$.",
            "solution": "The user has provided a problem concerning the Hierarchical Equations of Motion (HEOM) for a two-level quantum system. The task is to validate the problem, and if valid, provide a reasoned solution and a Python implementation that exploits a specific symmetry to achieve a computational speedup.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **System Hamiltonian**: $H_{\\mathrm{s}} = \\tfrac{\\omega_{0}}{2} \\sigma_{z}$.\n*   **System-Bath Coupling Operator**: $V = \\sigma_{z}$.\n*   **Bosonic Environment**: Equilibrium autocorrelation function is approximated by a single exponential term $c \\, e^{-\\gamma t}$.\n*   **HEOM Structure**:\n    $$ \\frac{d}{dt} \\, \\mathrm{vec}(\\rho_{n}) = \\mathcal{L}_{\\mathrm{s}} \\, \\mathrm{vec}(\\rho_{n}) - n \\gamma \\, \\mathrm{vec}(\\rho_{n}) - i \\, \\mathrm{vec}\\left([V, \\rho_{n+1}]\\right) - i n c \\, \\mathrm{vec}\\left([V, \\rho_{n-1}]\\right) $$\n    for $n = 0, 1, \\dots, K$, with truncation conditions for indices outside this range.\n*   **Superoperators and Vectorization**:\n    *   $\\mathcal{L}_{\\mathrm{s}}(\\cdot) = -i [H_{\\mathrm{s}}, \\cdot]$.\n    *   Vectorization is column-stacking.\n    *   Matrix form of commutator: $\\mathrm{vec}(A \\rho - \\rho A) = (I \\otimes A - A^{\\mathsf{T}} \\otimes I)\\mathrm{vec}(\\rho)$.\n    *   Thus, $\\mathcal{L}_{\\mathrm{s}}$ is represented by the matrix $-i(I \\otimes H_{\\mathrm{s}} - H_{\\mathrm{s}}^{\\mathsf{T}} \\otimes I)$.\n*   **Symmetry and Subspaces**:\n    *   For $H_{\\mathrm{s}} \\propto \\sigma_{z}$ and $V = \\sigma_{z}$, the dynamics preserve the decomposition of the operator space into diagonal and off-diagonal subspaces.\n    *   Diagonal subspace: span of $\\{|0\\rangle\\langle 0|, |1\\rangle\\langle 1|\\}$.\n    *   Off-diagonal subspace: span of $\\{|0\\rangle\\langle 1|, |1\\rangle\\langle 0|\\}$.\n*   **Computational Cost and Speedup**:\n    *   Cost of dense matrix-vector multiplication scales as $n^2$.\n    *   Cost for block-diagonal matrix scales as $\\sum_{b} n_{b}^{2}$.\n    *   Speedup is defined as $S \\equiv \\frac{n_{\\mathrm{full}}^{2}}{\\sum_{b} n_{b}^{2}}$.\n*   **Tasks**:\n    1.  Construct the full and symmetry-reordered HEOM generators.\n    2.  Compute the theoretical speedup $S$.\n    3.  Propagate an initial state in time using both generators via matrix exponentiation.\n    4.  Compare the resulting observables $\\langle \\sigma_{z} \\rangle(t) = \\mathrm{Tr}(\\sigma_{z} \\rho_{0}(t))$ and $|\\rho_{0,01}(t)|$ to find the maximum absolute deviation and verify accuracy ($< 10^{-10}$).\n*   **Initial Conditions**: $\\rho_{0}(0)$ is specified by its populations $p_{\\uparrow}, p_{\\downarrow}$ and coherence $r$. Auxiliary densities $\\rho_{n>0}(0) = 0$.\n*   **Test Suite**: Three specific cases with parameters for $(\\omega_{0}, \\gamma, c, K)$, initial state, and time points are provided.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically well-grounded, belonging to the standard theory of open quantum systems. The HEOM formulation is a cornerstone of non-Markovian dynamics. The chosen system, a spin-boson model with a pure-dephasing Hamiltonian ($H_s \\propto \\sigma_z$) and coupling ($V = \\sigma_z$), is a canonical example. All mathematical definitions (vectorization, superoperators) are standard. The problem is well-posed: it specifies a system of linear ODEs with a constant coefficient matrix (the HEOM generator), which, given an initial state, has a unique solution. The initial density matrices provided in the test cases are physically valid (unit trace and positive semidefinite). The parameters and tasks are clearly defined, complete, and consistent. The requested symmetry analysis is a valid and common technique in computational physics for reducing computational cost. The problem is neither trivial nor ill-posed.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. It is a sound, well-defined problem in computational physics. A full solution will be provided.\n\n### Solution\n\nThe problem requires us to construct the generator for the Hierarchical Equations of Motion (HEOM), exploit a symmetry to block-diagonalize it, and compare the two approaches numerically.\n\n**1. Liouville Space Representation**\n\nA $2 \\times 2$ density operator $\\rho$ is a point in a $4$-dimensional vector space (Liouville space). Using column-stacking vectorization, the matrix $\\rho = \\begin{pmatrix} \\rho_{00} & \\rho_{01} \\\\ \\rho_{10} & \\rho_{11} \\end{pmatrix}$ is mapped to a vector $\\mathrm{vec}(\\rho) = [\\rho_{00}, \\rho_{10}, \\rho_{01}, \\rho_{11}]^{\\mathsf{T}}$. The HEOM describes the time evolution of a state vector $\\vec{\\mathcal{R}} = [\\mathrm{vec}(\\rho_0)^{\\mathsf{T}}, \\mathrm{vec}(\\rho_1)^{\\mathsf{T}}, \\dots, \\mathrm{vec}(\\rho_K)^{\\mathsf{T}}]^{\\mathsf{T}}$ of total dimension $n_{\\mathrm{full}} = 4(K+1)$. The evolution equation is $\\frac{d}{dt}\\vec{\\mathcal{R}} = \\mathcal{L}_{\\mathrm{HEOM}} \\vec{\\mathcal{R}}$, where $\\mathcal{L}_{\\mathrm{HEOM}}$ is the time-independent HEOM generator.\n\n**2. Superoperator Matrices**\n\nThe system Hamiltonian is $H_{\\mathrm{s}} = \\frac{\\omega_0}{2}\\sigma_z$ and the coupling operator is $V=\\sigma_z$. We adopt the computational basis $\\{|0\\rangle, |1\\rangle\\}$ where $\\sigma_z = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}$. Both $H_s$ and $V$ are diagonal. Using the identity $\\mathrm{vec}(A\\rho B) = (B^{\\mathsf{T}} \\otimes A)\\mathrm{vec}(\\rho)$, the system Liouvillian $\\mathcal{L}_{\\mathrm{s}} = -i[H_s, \\cdot]$ and the coupling superoperator term $-i[V, \\cdot]$ are represented by $4 \\times 4$ matrices:\n$$ \\mathcal{L}_{\\mathrm{s}} \\rightarrow \\mathbf{L_s} = -i(I \\otimes H_s - H_s^{\\mathsf{T}} \\otimes I) = \\mathrm{diag}(0, i\\omega_0, -i\\omega_0, 0) $$\n$$ -i[V, \\cdot] \\rightarrow \\mathbf{V_{op}} = -i(I \\otimes V - V^{\\mathsf{T}} \\otimes I) = \\mathrm{diag}(0, 2i, -2i, 0) $$\nThese matrices act on the vectorized density operator $[\\rho_{00}, \\rho_{10}, \\rho_{01}, \\rho_{11}]^{\\mathsf{T}}$.\n\n**3. HEOM Generator Construction**\n\nThe full HEOM generator $\\mathcal{L}_{\\mathrm{HEOM}}$ is a block-tridiagonal matrix of size $4(K+1) \\times 4(K+1)$. The blocks are $4 \\times 4$ matrices defined by the HEOM structure:\n*   The $(n,n)$-th block (on the main diagonal) is $\\mathbf{L_s} - n\\gamma I_4$.\n*   The $(n,n+1)$-th block (on the super-diagonal) is $\\mathbf{V_{op}}$.\n*   The $(n,n)$-th block (on the sub-diagonal) is $n c \\mathbf{V_{op}}$.\n\n**4. Symmetry and Block-Diagonalization**\n\nCrucially, both $\\mathbf{L_s}$ and $\\mathbf{V_{op}}$ are diagonal matrices in the standard column-stacking basis. The first and fourth basis vectors correspond to the diagonal elements of $\\rho$ ($\\rho_{00}$ and $\\rho_{11}$), while the second and third correspond to the off-diagonal elements ($\\rho_{10}$ and $\\rho_{01}$). The diagonal structure of $\\mathbf{L_s}$ and $\\mathbf{V_{op}}$ (with zeros in the first and fourth rows/columns) signifies that they do not mix the diagonal and off-diagonal subspaces.\n\nThis property extends to the full HEOM generator: the dynamics of the diagonal components of all auxiliary density operators $\\{\\rho_n\\}$ are entirely decoupled from the dynamics of their off-diagonal components. We can therefore reorder the basis of the total state vector $\\vec{\\mathcal{R}}$ to group all $2(K+1)$ diagonal components first, followed by all $2(K+1)$ off-diagonal components. This transforms $\\mathcal{L}_{\\mathrm{HEOM}}$ into a block-diagonal matrix:\n$$ \\mathcal{L}_{\\mathrm{reordered}} = \\begin{pmatrix} \\mathcal{L}_{\\mathrm{D}} & 0 \\\\ 0 & \\mathcal{L}_{\\mathrm{OD}} \\end{pmatrix} $$\n*   The first block, $\\mathcal{L}_{\\mathrm{D}}$, of size $n_{\\mathrm{D}} = 2(K+1)$, governs the evolution of the vector of diagonal components $[\\rho_{00}^{(0)}, \\rho_{11}^{(0)}, \\dots, \\rho_{00}^{(K)}, \\rho_{11}^{(K)}]^{\\mathsf{T}}$.\n*   The second block, $\\mathcal{L}_{\\mathrm{OD}}$, of size $n_{\\mathrm{OD}} = 2(K+1)$, governs the vector of off-diagonal components $[\\rho_{10}^{(0)}, \\rho_{01}^{(0)}, \\dots, \\rho_{10}^{(K)}, \\rho_{01}^{(K)}]^{\\mathsf{T}}$.\n\nThe action of $\\mathcal{L_s}$ and $[V, \\cdot]$ upon any diagonal operator is zero. Therefore, the generator for the diagonal subspace, $\\mathcal{L}_{\\mathrm{D}}$, is simply a diagonal matrix with entries $-n\\gamma$ for the components of $\\rho_n$. The generator for the off-diagonal subspace, $\\mathcal{L}_{\\mathrm{OD}}$, retains the block-tridiagonal structure but with $2 \\times 2$ blocks representing the action of $\\mathcal{L_s}$ and $[V, \\cdot]$ within the off-diagonal subspace.\n\n**5. Computational Speedup**\n\nThe computational cost of a matrix-vector product scales as the square of the matrix dimension. For the original \"naive\" approach, the cost is proportional to $n_{\\mathrm{full}}^2 = (4(K+1))^2$. For the block-diagonalized approach, the cost is the sum of the costs for each block, $\\sum_b n_b^2 = n_{\\mathrm{D}}^2 + n_{\\mathrm{OD}}^2 = (2(K+1))^2 + (2(K+1))^2$. The theoretical speedup factor is:\n$$ S = \\frac{n_{\\mathrm{full}}^2}{n_{\\mathrm{D}}^2 + n_{\\mathrm{OD}}^2} = \\frac{(4(K+1))^2}{(2(K+1))^2 + (2(K+1))^2} = \\frac{16(K+1)^2}{4(K+1)^2 + 4(K+1)^2} = \\frac{16}{8} = 2 $$\nThe speedup is a constant factor of $2$, independent of the hierarchy depth $K$, for this specific pure-dephasing model.\n\n**6. Algorithmic Implementation**\n\nThe program will implement the following steps for each test case:\n1.  Construct the full generator $\\mathcal{L}_{\\mathrm{HEOM}}$ and the two block generators $\\mathcal{L}_{\\mathrm{D}}$ and $\\mathcal{L}_{\\mathrm{OD}}$.\n2.  Calculate the theoretical speedup factor $S=2.0$.\n3.  Prepare the initial state vectors for both the full representation and the block-decomposed representation from the given parameters $p_{\\uparrow}, p_{\\downarrow}, r$.\n4.  For each time point $t$, compute the time-evolved state by calculating the matrix exponential of the generator multiplied by the initial state vector: $\\vec{\\mathcal{R}}(t) = e^{\\mathcal{L}_{\\mathrm{HEOM}} t} \\vec{\\mathcal{R}}(0)$. This is done for both full and block-diagonal methods.\n5.  Extract the primary density operator $\\rho_0(t)$ from the evolved state vectors.\n6.  Calculate the observables $\\langle \\sigma_z \\rangle(t) = \\rho_{00}(t) - \\rho_{11}(t)$ and $|\\rho_{01}(t)|$ for both methods.\n7.  Determine the maximum absolute deviation between the two methods over the time grid for each observable.\n8.  Verify if the deviations are below the numerical tolerance of $10^{-10}$.\n\nThis procedure will numerically demonstrate that the symmetry-based block-diagonalization yields identical physical results up to machine precision while offering a computational advantage.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef run_case(params):\n    \"\"\"\n    Solves one test case for the HEOM problem.\n    \"\"\"\n    w0, gamma, c, K, p_up, p_down, r, times = params\n\n    # 1. Define base matrices and superoperators\n    I2 = np.identity(2, dtype=complex)\n    sz = np.array([[1, 0], [0, -1]], dtype=complex)\n    Hs = (w0 / 2) * sz\n    V = sz\n\n    # Superoperators in 4D Liouville space (column-stacking: rho_00, rho_10, rho_01, rho_11)\n    # These are derived using the Kronecker product identity vec(ABC) = (C.T kron A)vec(B)\n    I4 = np.identity(4, dtype=complex)\n    Ls_full = -1j * (np.kron(I2, Hs) - np.kron(Hs.T, I2))\n    Cv_full = np.kron(I2, V) - np.kron(V.T, I2)\n    Vop_full = -1j * Cv_full\n    \n    # 2. Construct full HEOM generator\n    n_full_dim = 4 * (K + 1)\n    L_full = np.zeros((n_full_dim, n_full_dim), dtype=complex)\n    for n in range(K + 1):\n        idx = 4 * n\n        # Diagonal block (n, n)\n        L_full[idx:idx+4, idx:idx+4] = Ls_full - n * gamma * I4\n        # Super-diagonal block (n, n+1)\n        if n < K:\n            L_full[idx:idx+4, idx+4:idx+8] = Vop_full\n        # Sub-diagonal block (n, n-1)\n        if n > 0:\n            L_full[idx:idx+4, idx-4:idx] = n * c * Vop_full\n\n    # 3. Construct block-diagonal generators\n    n_diag_dim = 2 * (K + 1)\n    n_offdiag_dim = 2 * (K + 1)\n\n    # Diagonal block generator (for [rho_00, rho_11] components)\n    # The action of Ls and Vop on diagonal elements of rho is zero.\n    L_D = np.zeros((n_diag_dim, n_diag_dim), dtype=complex)\n    for n in range(K+1):\n        idx = 2 * n\n        L_D[idx:idx+2, idx:idx+2] = -n * gamma * I2\n        \n    # Off-diagonal block generator (for [rho_10, rho_01] components)\n    # The basis for this block is {|1><0|, |0><1|}\n    Ls_od = np.diag([1j * w0, -1j * w0])\n    Vop_od = -1j * np.diag([-2.0, 2.0]) # Action on [rho_10, rho_01]\n    \n    L_OD = np.zeros((n_offdiag_dim, n_offdiag_dim), dtype=complex)\n    for n in range(K + 1):\n        idx = 2 * n\n        # Diagonal block (n, n)\n        L_OD[idx:idx+2, idx:idx+2] = Ls_od - n * gamma * I2\n        # Super-diagonal block (n, n+1)\n        if n < K:\n            L_OD[idx:idx+2, idx+2:idx+4] = Vop_od\n        # Sub-diagonal block (n, n-1)\n        if n > 0:\n            L_OD[idx:idx+2, idx-2:idx] = n * c * Vop_od\n\n    # 4. Calculate theoretical speedup factor\n    speedup = (n_full_dim**2) / (n_diag_dim**2 + n_offdiag_dim**2)\n\n    # 5. Prepare initial states\n    rho0_initial = np.array([[p_up, r], [np.conj(r), p_down]], dtype=complex)\n\n    # Full initial vector\n    R_full_0 = np.zeros(n_full_dim, dtype=complex)\n    R_full_0[0:4] = np.array([rho0_initial[0,0], rho0_initial[1,0], rho0_initial[0,1], rho0_initial[1,1]])\n\n    # Block-decomposed initial vectors\n    R_D_0 = np.zeros(n_diag_dim, dtype=complex)\n    R_D_0[0:2] = np.array([rho0_initial[0,0], rho0_initial[1,1]])\n    \n    R_OD_0 = np.zeros(n_offdiag_dim, dtype=complex)\n    R_OD_0[0:2] = np.array([rho0_initial[1,0], rho0_initial[0,1]])\n\n    # 6. Propagate in time and compare observables\n    sz_vals_full, coh_vals_full = [], []\n    sz_vals_block, coh_vals_block = [], []\n\n    for t in times:\n        # Full propagation\n        propagator_full = expm(L_full * t)\n        R_full_t = propagator_full @ R_full_0\n        vec_rho0_full = R_full_t[0:4]\n        rho0_full = np.array([[vec_rho0_full[0], vec_rho0_full[2]], [vec_rho0_full[1], vec_rho0_full[3]]])\n        \n        # Block propagation\n        propagator_D = expm(L_D * t)\n        R_D_t = propagator_D @ R_D_0\n        propagator_OD = expm(L_OD * t)\n        R_OD_t = propagator_OD @ R_OD_0\n        rho0_block = np.array([[R_D_t[0], R_OD_t[1]], [R_OD_t[0], R_D_t[1]]])\n        \n        # Calculate observables for both methods\n        sz_vals_full.append(np.trace(sz @ rho0_full).real)\n        coh_vals_full.append(np.abs(rho0_full[0, 1]))\n        \n        sz_vals_block.append(np.trace(sz @ rho0_block).real)\n        coh_vals_block.append(np.abs(rho0_block[0, 1]))\n        \n    # 7. Compute maximum absolute deviations\n    max_abs_dev_sz = np.max(np.abs(np.array(sz_vals_full) - np.array(sz_vals_block)))\n    max_abs_dev_coh = np.max(np.abs(np.array(coh_vals_full) - np.array(coh_vals_block)))\n    is_accurate = (max_abs_dev_sz < 1e-10) and (max_abs_dev_coh < 1e-10)\n    \n    return [speedup, max_abs_dev_sz, max_abs_dev_coh, is_accurate]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0e12, 2.5e12, 3.0e11, 1, 0.6, 0.4, 0.2 + 0.1j, np.array([0.0, 5.0e-13, 1.0e-12, 2.0e-12])),\n        (1.0e12, 2.5e12, 3.0e11, 1, 0.6, 0.4, 0.0 + 0.0j, np.array([0.0, 1.0e-12])),\n        (0.0, 1.0e13, 5.0e12, 2, 0.7, 0.3, 0.0 + 0.25j, np.array([0.0, 1.0e-13, 5.0e-13, 1.0e-12]))\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Custom string formatting to avoid default numpy/python representations\n    formatted_results = []\n    for res in results:\n        # Format boolean to lowercase 'true'/'false'\n        is_accurate_str = str(res[3]).lower()\n        s = f\"[{res[0]},{res[1]},{res[2]},{is_accurate_str}]\"\n        formatted_results.append(s)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}