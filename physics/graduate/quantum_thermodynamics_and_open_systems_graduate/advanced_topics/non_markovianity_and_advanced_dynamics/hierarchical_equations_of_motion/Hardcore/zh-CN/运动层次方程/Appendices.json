{
    "hands_on_practices": [
        {
            "introduction": "在实际计算中，为了使问题可解，我们必须将无限的HEOM层级结构在有限的层级截断。然而，简单的截断可能会破坏动力学映射的完全正定性，从而导致诸如负概率之类的非物理结果。本练习将引导您诊断这种失效，并基于物理近似推导出一个能恢复完全正定性的“终止项”，这是构建物理上合理的数值模型至关重要的一课。",
            "id": "3771225",
            "problem": "考虑一个两能级量子系统（量子比特），其系统哈密顿量为 $H = \\frac{\\omega}{2}\\,\\sigma_z$，系统-浴耦合算符为 $V = \\sigma_x$。该系统与一个玻色子环境相互作用，其平衡双时关联函数具有单指数分解形式 $C(t) = c\\,e^{-\\nu t}$，其中 $c > 0$ 和 $\\nu > 0$ 是无量纲常数。其约化系统动力学可以使用在 $N=1$ 阶截断的层次运动方程 (HEOM) 来描述，得到一组关于物理密度算符 $\\rho_0(t)$ 和单个辅助密度算符 $\\rho_1(t)$ 的耦合线性方程组：\n- 物理密度算符满足 $\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] - i[V,\\rho_1(t)]$。\n- 辅助密度算符满足 $\\frac{d}{dt}\\rho_1(t) = -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,(V\\rho_0(t) - \\rho_0(t)V)$。\n此处 $[A,B] = AB - BA$ 表示对易子。在 $N=1$ 阶的朴素截断设置 $\\rho_{2}(t) \\equiv 0$，并且不在此截断之外引入任何闭合项。\n\n一般而言，在因子化初始条件下，精确的开放系统动力学是完全正的 (CP)。然而，包括朴素截断 HEOM 在内的近似方案可能产生非完全正的动力学。在本任务中，您将构建一个反例，其中朴素的 $N=1$ HEOM 截断在固定的最终时刻 $t_{\\mathrm{f}}$ 产生一个非完全正的动力学映射，通过检查该动力学映射的 Choi 矩阵来诊断该问题，然后提出并实现一个基于受控时间尺度分离的修正终结项，以恢复近似的完全正性。\n\n从总的系统加浴状态的基本 Liouville–von Neumann 方程 $\\frac{d}{dt}\\rho_{\\mathrm{tot}}(t) = -i[H_{\\mathrm{tot}},\\rho_{\\mathrm{tot}}(t)]$ 和单指数浴关联 $C(t)$ 的 HEOM 构建定义出发，推导一个基于绝热消除的闭合，它将截断层级对 $\\rho_0(t)$ 动力学的影响近似为一个有效的、具有 Gorini–Kossakowski–Sudarshan–Lindblad (GKSL) 形式的时间局域生成元。您的推导应从上述方程出发，通过对辅助密度算符应用受控的时间尺度分离论证并将其消去，从而获得一个只作用于 $\\rho_0(t)$ 的显式生成元，该生成元在 $V$ 是厄米算符时显然是完全正的。不要使用或引用任何捷径公式；基于所提供的方程和单指数关联模型，从第一性原理推导耗散项的结构和系数。\n\n按如下方式数值验证完全正性。对于一组固定的参数和固定的时间 $t_{\\mathrm{f}}$，通过将四个矩阵单元 $E_{00} = |0\\rangle\\langle 0|$, $E_{01} = |0\\rangle\\langle 1|$, $E_{10} = |1\\rangle\\langle 0|$, $E_{11} = |1\\rangle\\langle 1|$ 从 $t=0$ 演化到 $t=t_{\\mathrm{f}}$，来构建由所选动力学（朴素截断 HEOM 或修正的 GKSL 闭合终结项）导出的动力学映射 $\\mathcal{E}_{t_{\\mathrm{f}}}$。构建 Choi 矩阵 $J(\\mathcal{E}_{t_{\\mathrm{f}}}) = \\sum_{i,j\\in\\{0,1\\}} \\mathcal{E}_{t_{\\mathrm{f}}}(|i\\rangle\\langle j|) \\otimes |i\\rangle\\langle j|$ 并计算其最小本征值。负的最小本征值表示违反了完全正性，而非负的最小本征值对应于一个完全正的映射。\n\n您的程序必须实现朴素截断 HEOM 动力学和通过您的绝热消除分析推导出的修正终结项，并为以下三个测试用例评估 Choi 矩阵的最小本征值。所有量都是无量纲的；不需要物理单位。\n\n测试套件（每个测试用例是一个指定 $(\\text{方法}, \\omega, c, \\nu, t_{\\mathrm{f}})$ 的元组）：\n- 用例 1（强耦合，朴素截断）：$(\\text{naive}, 1.0, 6.0, 0.5, 3.0)$。\n- 用例 2（强耦合，修正终结项）：$(\\text{terminator}, 1.0, 6.0, 0.5, 3.0)$。\n- 用例 3（弱耦合，朴素截断）：$(\\text{naive}, 1.0, 0.2, 2.0, 3.0)$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个测试用例的条目必须是一个浮点数，等于相应 Choi 矩阵在时间 $t_{\\mathrm{f}}$ 的最小本征值。使用数值稳定的积分方案，并通过对称化 $J \\mapsto \\frac{1}{2}(J + J^\\dagger)$ 确保 Choi 矩阵在计算其本征值之前是厄米的。清晰地分开朴素截断和修正终结项的实现，并确保程序无需外部输入即可独立运行。",
            "solution": "所述问题具有科学依据、是良定的，并包含了完整解决方案所需的所有信息。它提出了开放量子系统研究中的一个标准但非平凡的任务：分析一个近似方案（朴素 HEOM 截断）的缺点，并推导和实现一个有物理动机的修正（基于绝热消除的终结项）。因此，该问题被认为是有效的。\n\n任务的核心是通过从所提供的在 $N=1$ 阶截断的层次方程中消去辅助算符 $\\rho_1(t)$，来为物理密度算符 $\\rho_0(t)$ 推导出一个主方程。出发点是给定的耦合微分方程组：\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] - i[V,\\rho_1(t)] \\quad \\cdots \\quad (1)\n$$\n$$\n\\frac{d}{dt}\\rho_1(t) = -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)] \\quad \\cdots \\quad (2)\n$$\n其中 $H = \\frac{\\omega}{2}\\,\\sigma_z$，$V = \\sigma_x$ 且 $[A,B] = AB-BA$。\n\n推导通过一个绝热消除过程进行，该过程依赖于时间尺度分离。我们假设辅助算符 $\\rho_1(t)$ 的动力学远快于物理算符 $\\rho_0(t)$ 的动力学。这在浴的记忆时间（由 $\\nu^{-1}$ 表征）非常短的极限下是物理上合理的，或者等效地说，当浴的衰减率 $\\nu$ 与问题中的其他能量尺度（如 $\\omega$ 和耦合的范数）相比很大时。在此极限下，$\\rho_1(t)$ 会迅速调整到 $\\rho_0(t)$ 的瞬时状态，使我们能将其时间导数近似为零。\n\n将此准稳态近似应用于方程 $(2)$，我们设置 $\\frac{d}{dt}\\rho_1(t) \\approx 0$：\n$$\n0 \\approx -i[H,\\rho_1(t)] - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)]\n$$\n为了求解 $\\rho_1(t)$，我们做出一个与时间尺度分离论证一致的进一步受控近似。如果 $\\nu$ 是 $\\rho_1$ 动力学中的主导尺度，即 $\\nu \\gg \\omega$，则项 $-\\nu\\,\\rho_1(t)$ 将主导项 $-i[H,\\rho_1(t)]$。忽略后者，我们得到一个简化的代数关系：\n$$\n0 \\approx - \\nu\\,\\rho_1(t) - i\\,c\\,[V,\\rho_0(t)]\n$$\n对该方程求解 $\\rho_1(t)$，得到辅助算符用物理算符表示的表达式：\n$$\n\\rho_1(t) \\approx -\\frac{ic}{\\nu}\\,[V,\\rho_0(t)] \\quad \\cdots \\quad (3)\n$$\n这个表达式抓住了近似的本质：辅助算符编码了系统-浴关联，它与驱动耗散动力学的对易子 $[V, \\rho_0(t)]$ 直接且瞬时成正比。\n\n接下来，我们将 $\\rho_1(t)$ 的这个表达式代回到 $\\rho_0(t)$ 的运动方程，即方程 $(1)$ 中：\n$$\n\\frac{d}{dt}\\rho_0(t) \\approx -i[H,\\rho_0(t)] - i\\left[V, \\left(-\\frac{ic}{\\nu}\\,[V,\\rho_0(t)]\\right)\\right]\n$$\n简化该表达式可得：\n$$\n\\frac{d}{dt}\\rho_0(t) \\approx -i[H,\\rho_0(t)] - \\frac{c}{\\nu}\\left[V, [V,\\rho_0(t)]\\right] \\quad \\cdots \\quad (4)\n$$\n这是一个关于 $\\rho_0(t)$ 的时间局域或马尔可夫主方程。为验证其为 Gorini–Kossakowski–Sudarshan–Lindblad (GKSL) 形式，我们展开双重对易子项。对于任意算符 $V$ 和 $\\rho$：\n$$\n[V, [V, \\rho]] = V(V\\rho - \\rho V) - (V\\rho - \\rho V)V = V^2\\rho - V\\rho V - V\\rho V + \\rho V^2 = V^2\\rho + \\rho V^2 - 2V\\rho V\n$$\n这可以使用反对易子 $\\{A,B\\} = AB+BA$ 写成：\n$$\n[V, [V, \\rho]] = \\{V^2, \\rho\\} - 2V\\rho V\n$$\n将此代入方程 $(4)$ 的耗散部分：\n$$\n-\\frac{c}{\\nu}\\left[V, [V,\\rho_0(t)]\\right] = -\\frac{c}{\\nu}\\left(\\{V^2, \\rho_0(t)\\} - 2V\\rho_0(t)V\\right) = \\frac{2c}{\\nu}\\left(V\\rho_0(t)V - \\frac{1}{2}\\{V^2, \\rho_0(t)\\}\\right)\n$$\n现在，主方程的形式为：\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] + \\frac{2c}{\\nu}\\left(V\\rho_0(t)V - \\frac{1}{2}\\{V^2, \\rho_0(t)\\}\\right)\n$$\n这显然是 GKSL 形式 $\\frac{d}{dt}\\rho = -i[H,\\rho] + \\sum_k \\gamma_k \\left( L_k \\rho L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho\\} \\right)$。在我们的例子中，只有一个 Lindblad 算符 $L_1 = V = \\sigma_x$，它是厄米的 ($V^\\dagger=V$)，对应的衰减率为 $\\gamma_1 = \\frac{2c}{\\nu}$。因为任何 GKSL 形式的主方程都会生成一个完全正 (CP) 的动力学映射，所以这个“终结项”方程保证能保持动力学的完全正性。\n\n对于特定的耦合算符 $V=\\sigma_x$，我们有 $V^2 = \\sigma_x^2 = I$，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。反对易子简化为 $\\{V^2, \\rho_0\\} = \\{I, \\rho_0\\} = I\\rho_0 + \\rho_0 I = 2\\rho_0$。修正后的主方程变为：\n$$\n\\frac{d}{dt}\\rho_0(t) = -i[H,\\rho_0(t)] + \\frac{2c}{\\nu}\\left(\\sigma_x\\rho_0(t)\\sigma_x - \\rho_0(t)\\right)\n$$\n这就是将要进行数值实现的“终结项”方法的方程。数值部分将证实这个推导出的方程确实产生一个 CP 映射（Choi 矩阵的最小本征值 $\\ge 0$），而朴素截断在某些参数下可能会失效（最小本征值 $< 0$）。\n\n为了进行数值验证，我们通过演化一组算符基来构建动力学映射 $\\mathcal{E}_{t_{\\mathrm{f}}}$。然后，Choi 矩阵被构建为 $J(\\mathcal{E}_{t_{\\mathrm{f}}}) = \\sum_{i,j=0}^{1} \\mathcal{E}_{t_{\\mathrm{f}}}(|i\\rangle\\langle j|) \\otimes |i\\rangle\\langle j|$。映射 $\\mathcal{E}_{t_{\\mathrm{f}}}$ 是完全正的，当且仅当其 Choi 矩阵 $J(\\mathcal{E}_{t_{\\mathrm{f}}})$ 是半正定的，这可以通过检查其最小本征值是否为非负来验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Define global constants (Pauli matrices, identity, and basis matrices)\n# for convenience and to avoid re-declaration.\nSIGMA_X = np.array([[0, 1], [1, 0]], dtype=complex)\nSIGMA_Z = np.array([[1, 0], [0, -1]], dtype=complex)\nID2 = np.identity(2, dtype=complex)\nE00 = np.array([[1, 0], [0, 0]], dtype=complex)\nE01 = np.array([[0, 1], [0, 0]], dtype=complex)\nE10 = np.array([[0, 0], [1, 0]], dtype=complex)\nE11 = np.array([[0, 0], [0, 1]], dtype=complex)\nBASIS = [E00, E01, E10, E11]\n\ndef dydt_naive(t, y, H, V, c, nu):\n    \"\"\"\n    Computes the time derivative for the naive N=1 truncated HEOM.\n    The state vector y is an 8-element complex array representing flattened\n    rho_0 (first 4 elements) and rho_1 (last 4 elements).\n    \"\"\"\n    # Reshape the flattened state vector into 2x2 density matrices\n    rho0 = y[0:4].reshape((2, 2))\n    rho1 = y[4:8].reshape((2, 2))\n    \n    # Calculate required commutators for the equations of motion\n    comm_H_rho0 = H @ rho0 - rho0 @ H\n    comm_V_rho1 = V @ rho1 - rho1 @ V\n    comm_H_rho1 = H @ rho1 - rho1 @ H\n    comm_V_rho0 = V @ rho0 - rho0 @ V\n    \n    # Equation for the physical density operator rho_0\n    d_rho0_dt = -1j * comm_H_rho0 - 1j * comm_V_rho1\n    \n    # Equation for the auxiliary density operator rho_1\n    d_rho1_dt = -1j * comm_H_rho1 - nu * rho1 - 1j * c * comm_V_rho0\n    \n    # Flatten the derivatives and concatenate into a single vector\n    return np.concatenate((d_rho0_dt.flatten(), d_rho1_dt.flatten()))\n\ndef dydt_terminator(t, y, H, V, c, nu):\n    \"\"\"\n    Computes the time derivative for the modified terminator (GKSL) equation.\n    The state vector y is a 4-element complex array representing flattened rho_0.\n    \"\"\"\n    # Reshape the flattened state vector into a 2x2 density matrix\n    rho0 = y.reshape((2, 2))\n    \n    # Coherent part of the evolution\n    comm_H_rho0 = H @ rho0 - rho0 @ H\n    \n    # Dissipative part (GKSL form derived from adiabatic elimination)\n    # The rate is gamma = 2*c/nu and the Lindblad operator is V = sigma_x.\n    # Since V^2 = I, the dissipator is gamma * (V * rho0 * V - rho0).\n    gamma = 2.0 * c / nu\n    dissipator = gamma * (V @ rho0 @ V - rho0)\n    \n    # Full equation of motion\n    d_rho0_dt = -1j * comm_H_rho0 + dissipator\n    \n    # Flatten the derivative for the ODE solver\n    return d_rho0_dt.flatten()\n\n\ndef calculate_min_eigenvalue(method, omega, c, nu, t_f):\n    \"\"\"\n    Calculates the minimal eigenvalue of the Choi matrix for a given dynamical\n    map at time t_f.\n    \"\"\"\n    # Define system Hamiltonian and coupling operator\n    H = (omega / 2.0) * SIGMA_Z\n    V = SIGMA_X\n    \n    # Store the evolved basis matrices E_ij(t_f)\n    evolved_basis = []\n    \n    # Propagate each basis matrix from t=0 to t=t_f\n    for E_ij in BASIS:\n        if method == 'naive':\n            # Initial state: rho_0(0) = E_ij, rho_1(0) = 0\n            y0 = np.concatenate((E_ij.flatten(), np.zeros(4, dtype=complex)))\n            # Define anonymous function for the ODE solver with fixed parameters\n            ode_func = lambda t, y: dydt_naive(t, y, H, V, c, nu)\n            sol = solve_ivp(ode_func, (0, t_f), y0, method='RK45', atol=1e-9, rtol=1e-9)\n            # Extract final physical density operator\n            rho_f = sol.y[0:4, -1].reshape((2, 2))\n        elif method == 'terminator':\n            # Initial state: rho_0(0) = E_ij\n            y0 = E_ij.flatten()\n            ode_func = lambda t, y: dydt_terminator(t, y, H, V, c, nu)\n            sol = solve_ivp(ode_func, (0, t_f), y0, method='RK45', atol=1e-9, rtol=1e-9)\n            # Extract final density operator\n            rho_f = sol.y[:, -1].reshape((2, 2))\n        else:\n            raise ValueError(f\"Unknown method '{method}' specified.\")\n            \n        evolved_basis.append(rho_f)\n        \n    # Unpack the evolved basis matrices\n    rho_f_00, rho_f_01, rho_f_10, rho_f_11 = evolved_basis\n    \n    # Construct the Choi matrix J using the formula\n    # J(E) = sum_{i,j} E(|i>j|) (x) |i>j|\n    # where |i>j| are the basis matrices E_ij.\n    choi_matrix = (np.kron(rho_f_00, E00) + np.kron(rho_f_01, E01) +\n                   np.kron(rho_f_10, E10) + np.kron(rho_f_11, E11))\n    \n    # Symmetrize the Choi matrix to ensure it's Hermitian before eigendecomposition\n    choi_matrix_herm = 0.5 * (choi_matrix + choi_matrix.conj().T)\n    \n    # Calculate and return the minimal eigenvalue\n    min_eigval = np.min(np.linalg.eigvalsh(choi_matrix_herm))\n    \n    return min_eigval\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results in the required format.\n    \"\"\"\n    test_suite = [\n        ('naive', 1.0, 6.0, 0.5, 3.0),\n        ('terminator', 1.0, 6.0, 0.5, 3.0),\n        ('naive', 1.0, 0.2, 2.0, 3.0),\n    ]\n\n    results = []\n    for params in test_suite:\n        min_eig = calculate_min_eigenvalue(*params)\n        results.append(min_eig)\n\n    # Format the output as a single-line list of floats.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "求解HEOM的计算成本可能非常高，它随着层级结构的规模而增长。然而，许多物理系统拥有对称性，我们可以利用这些对称性来降低计算成本。在此练习中，您将学习如何识别和利用系统的对称性——在此例中为$z$轴自旋投影守恒——来将HEOM生成元进行块对角化，从而在不牺牲精度的情况下显著提升计算速度。",
            "id": "5294946",
            "problem": "考虑一个两能级量子系统（自旋-$\\tfrac{1}{2}$），其系统哈密顿量为 $H_{\\mathrm{s}} = \\tfrac{\\omega_{0}}{2} \\sigma_{z}$，与一个玻色子环境相互作用，该环境的平衡自相关函数由单个指数项 $c \\, e^{-\\gamma t}$ 近似。在开放量子系统框架的标准假设下（类玻恩的因子化初始态和稳态高斯浴），当只保留一个指数项时，运动层次方程 (HEOM) 在有限的层级深度 $K$ 处一致地截断。HEOM 的未知量是主密度算符 $\\rho_{0}$ 和辅助密度算符 $\\rho_{n}$（$n = 1, 2, \\dots, K$）。在刘维尔空间中，通过列堆叠将算符矢量化后，每个 $2 \\times 2$ 矩阵都表示为一个长度为4的向量。时间演化是线性的且不依赖于时间，可以写成一个一阶常微分方程组：\n$$\n\\frac{d}{dt} \\, \\mathrm{vec}(\\rho_{n}) = \\mathcal{L}_{\\mathrm{s}} \\, \\mathrm{vec}(\\rho_{n}) - n \\gamma \\, \\mathrm{vec}(\\rho_{n}) - i \\, \\mathrm{vec}\\left([V, \\rho_{n+1}]\\right) - i n c \\, \\mathrm{vec}\\left([V, \\rho_{n-1}]\\right),\n$$\n其中 $n = 0, 1, \\dots, K$，并约定当 $n+1 > K$ 或 $n-1  0$ 时相关项被省略，$V = \\sigma_{z}$，且 $\\mathcal{L}_{\\mathrm{s}}(\\cdot) = -i [H_{\\mathrm{s}}, \\cdot]$ 是系统刘维尔超算符。对易超算符的作用为 $[A, \\rho] = A \\rho - \\rho A$，在列堆叠矢量化下，$\\mathrm{vec}(A \\rho - \\rho A) = \\left(I \\otimes A - A^{\\mathsf{T}} \\otimes I\\right) \\mathrm{vec}(\\rho)$，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。\n\n题目要求您利用组合的哈密顿量和耦合算符的对称性，特别是沿 $z$ 轴的自旋投影守恒（等效于计算基中的宇称守恒），来将 HEOM 生成元块对角化。对于 $H_{\\mathrm{s}} \\propto \\sigma_{z}$ 和 $V = \\sigma_{z}$，可以观察到 $\\mathcal{L}_{\\mathrm{s}}$ 和与 $V$ 的对易子保持了算符空间到对角和非对角子空间的分解。将对角子空间定义为由 $\\{|0\\rangle\\langle 0|, |1\\rangle\\langle 1|\\}$ 张成的空间，将非对角子空间定义为由 $\\{|0\\rangle\\langle 1|, |1\\rangle\\langle 0|\\}$ 张成的空间。证明当按子空间对矢量化变量进行排序时，HEOM 生成元是块对角化的，并利用这一点计算相对于不使用对称性的朴素稠密方法的理论计算加速比。假设稠密矩阵-向量乘法的计算成本与矩阵维度 $n$ 的平方成正比，即与 $n^{2}$ 成正比。对于一个块大小为 $n_{1}, n_{2}, \\dots$ 的块对角矩阵，假设其成本与 $\\sum_{b} n_{b}^{2}$ 成正比。\n\n从上述基本定义出发，设计一个程序，该程序能够：\n- 对于给定的参数 $(\\omega_{0}, \\gamma, c, K)$，使用列堆叠矢量化以及超算符恒等式 $\\mathcal{L}_{\\mathrm{s}} = -i \\left(I \\otimes H_{\\mathrm{s}} - H_{\\mathrm{s}}^{\\mathsf{T}} \\otimes I\\right)$ 和 $[V, \\cdot] \\mapsto \\left(I \\otimes V - V^{\\mathsf{T}} \\otimes I\\right)$ 来构建完整的 HEOM 生成元矩阵。\n- 通过先将所有层级的所有对角分量组合在一起，然后组合所有层级的所有非对角分量，来构建对称性重排后的生成元，从而产生两个独立的块。\n- 计算定义为如下的理论加速因子 $S$\n$$\nS \\equiv \\frac{n_{\\mathrm{full}}^{2}}{\\sum_{b} n_{b}^{2}},\n$$\n其中 $n_{\\mathrm{full}}$ 是完整生成元的维度，$n_{b}$ 是对称性约化后的块维度。\n- 通过计算生成元的矩阵指数并将其应用于初始状态，在指定的时间列表上演化 HEOM。对于完整演化和块对角化演化，使用相同的初始 $\\rho_{0}$ 和为零的辅助密度 $\\rho_{n0}$，并从演化后的主密度 $\\rho_{0}(t)$ 重建可观测量。\n\n为了证明基于对称性的约化不会导致物理精度的损失，请对两种方法在每个时间点从 $\\rho_{0}(t)$ 计算两个可观测量，并报告在时间网格上的最大绝对偏差：\n- 沿 z 轴的自旋投影，$\\langle \\sigma_{z} \\rangle(t) = \\mathrm{Tr}(\\sigma_{z} \\rho_{0}(t))$。\n- 非对角相干性的大小，$\\left| \\rho_{0,01}(t) \\right|$，其中 $\\rho_{0,01}(t)$ 表示矩阵元 $\\langle 0 | \\rho_{0}(t) | 1 \\rangle$。\n\n使用以下测试套件。所有频率单位为弧度/秒，时间单位为秒。初始主密度算符 $\\rho_{0}(0)$ 由其对角元 $p_{\\uparrow}$ 和 $p_{\\downarrow}$ 以及复数非对角元 $r$ 指定；辅助密度初始化为零。确保 $\\rho_{0}(0)$ 是半正定的且迹为1。对于每个测试用例，演化到所列的时间点并报告：\n- 理论加速因子 $S$（浮点数）。\n- $\\langle \\sigma_{z} \\rangle(t)$ 在整个时间网格上的最大绝对偏差（浮点数）。\n- $\\left| \\rho_{0,01}(t) \\right|$ 在整个时间网格上的最大绝对偏差（浮点数）。\n- 一个布尔值，指示两个偏差是否都小于 $10^{-10}$。\n\n测试套件：\n- 案例1（一般成功路径）：$\\omega_{0} = 1.0 \\times 10^{12}$，$\\gamma = 2.5 \\times 10^{12}$， $c = 3.0 \\times 10^{11}$， $K = 1$，$p_{\\uparrow} = 0.6$，$p_{\\downarrow} = 0.4$，$r = 0.2 + 0.1 i$，时间点 $[0.0, 5.0 \\times 10^{-13}, 1.0 \\times 10^{-12}, 2.0 \\times 10^{-12}]$。\n- 案例2（边界情况：纯对角初始态）：$\\omega_{0} = 1.0 \\times 10^{12}$，$\\gamma = 2.5 \\times 10^{12}$， $c = 3.0 \\times 10^{11}$， $K = 1$，$p_{\\uparrow} = 0.6$，$p_{\\downarrow} = 0.4$，$r = 0.0 + 0.0 i$，时间点 $[0.0, 1.0 \\times 10^{-12}]$。\n- 案例3（边界情况：零系统分裂，更深的层级）：$\\omega_{0} = 0.0$，$\\gamma = 1.0 \\times 10^{13}$， $c = 5.0 \\times 10^{12}$， $K = 2$，$p_{\\uparrow} = 0.7$，$p_{\\downarrow} = 0.3$，$r = 0.0 + 0.25 i$，时间点 $[0.0, 1.0 \\times 10^{-13}, 5.0 \\times 10^{-13}, 1.0 \\times 10^{-12}]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应于一个测试用例的列表，按测试套件的顺序排列。每个内部列表必须是上面指定的 $[S, \\mathrm{max\\_abs\\_dev\\_sz}, \\mathrm{max\\_abs\\_dev\\_coh}, \\mathrm{is\\_accurate}]$ 形式。例如，一个有效的输出看起来像 $[[2.0,0.0,0.0,True],[\\dots],[\\dots]]$。",
            "solution": "用户提供了一个关于两能级量子系统运动层次方程 (HEOM) 的问题。任务是验证该问题，如果有效，则提供一个合理的解决方案和一个利用特定对称性以实现计算加速的 Python 实现。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **系统哈密顿量**：$H_{\\mathrm{s}} = \\tfrac{\\omega_{0}}{2} \\sigma_{z}$。\n*   **系统-浴耦合算符**：$V = \\sigma_{z}$。\n*   **玻色子环境**：平衡自相关函数由单个指数项 $c \\, e^{-\\gamma t}$ 近似。\n*   **HEOM 结构**：\n    $$ \\frac{d}{dt} \\, \\mathrm{vec}(\\rho_{n}) = \\mathcal{L}_{\\mathrm{s}} \\, \\mathrm{vec}(\\rho_{n}) - n \\gamma \\, \\mathrm{vec}(\\rho_{n}) - i \\, \\mathrm{vec}\\left([V, \\rho_{n+1}]\\right) - i n c \\, \\mathrm{vec}\\left([V, \\rho_{n-1}]\\right) $$\n    其中 $n = 0, 1, \\dots, K$，并有对超出此范围的索引的截断条件。\n*   **超算符和矢量化**：\n    *   $\\mathcal{L}_{\\mathrm{s}}(\\cdot) = -i [H_{\\mathrm{s}}, \\cdot]$。\n    *   矢量化是列堆叠。\n    *   对易子的矩阵形式：$\\mathrm{vec}(A \\rho B) = (B^{\\mathsf{T}} \\otimes A)\\mathrm{vec}(\\rho)$，从而得到 $\\mathrm{vec}([A, \\rho]) = \\mathrm{vec}(A\\rho - \\rho A) = (I \\otimes A - A^{\\mathsf{T}} \\otimes I)\\mathrm{vec}(\\rho)$。\n    *   因此，$\\mathcal{L}_{\\mathrm{s}}$ 由矩阵 $-i(I \\otimes H_{\\mathrm{s}} - H_{\\mathrm{s}}^{\\mathsf{T}} \\otimes I)$ 表示。\n*   **对称性和子空间**：\n    *   对于 $H_{\\mathrm{s}} \\propto \\sigma_{z}$ 和 $V = \\sigma_{z}$，动力学保持算符空间到对角和非对角子空间的分解。\n    *   对角子空间：由 $\\{|0\\rangle\\langle 0|, |1\\rangle\\langle 1|\\}$ 张成的空间。\n    *   非对角子空间：由 $\\{|0\\rangle\\langle 1|, |1\\rangle\\langle 0|\\}$ 张成的空间。\n*   **计算成本和加速**：\n    *   稠密矩阵-向量乘法的成本与 $n^2$ 成正比。\n    *   块对角矩阵的成本与 $\\sum_{b} n_{b}^{2}$ 成正比。\n    *   加速比定义为 $S \\equiv \\frac{n_{\\mathrm{full}}^{2}}{\\sum_{b} n_{b}^{2}}$。\n*   **任务**：\n    1.  构建完整的和对称性重排后的 HEOM 生成元。\n    2.  计算理论加速比 $S$。\n    3.  使用矩阵指数，通过两个生成元对初始状态进行时间演化。\n    4.  比较所得的可观测量 $\\langle \\sigma_{z} \\rangle(t) = \\mathrm{Tr}(\\sigma_{z} \\rho_{0}(t))$ 和 $|\\rho_{0,01}(t)|$，找出最大绝对偏差并验证精度（$ 10^{-10}$）。\n*   **初始条件**：$\\rho_{0}(0)$ 由其布居数 $p_{\\uparrow}, p_{\\downarrow}$ 和相干项 $r$ 指定。辅助密度 $\\rho_{n0}(0) = 0$。\n*   **测试套件**：提供了三个具体案例，包括参数 $(\\omega_{0}, \\gamma, c, K)$、初始状态和时间点。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题具有坚实的科学基础，属于开放量子系统的标准理论。HEOM 公式是非马尔可夫动力学的基石。所选系统，一个具有纯退相干哈密顿量（$H_s \\propto \\sigma_z$）和耦合（$V = \\sigma_z$）的自旋-玻色子模型，是一个典型例子。所有的数学定义（矢量化、超算符）都是标准的。问题是适定的：它指定了一个具有常系数矩阵（HEOM 生成元）的线性常微分方程组，对于给定的初始状态，该方程组有唯一解。测试用例中提供的初始密度矩阵在物理上是有效的（迹为1且半正定）。参数和任务定义清晰、完整且一致。所要求的对称性分析是计算物理学中降低计算成本的一种有效且常用的技术。该问题既不平凡，也非不适定。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。这是一个计算物理学中合理且定义明确的问题。将提供完整的解决方案。\n\n### 解决方案\n\n该问题要求我们为运动层次方程 (HEOM) 构建生成元，利用对称性将其块对角化，并数值比较这两种方法。\n\n**1. 刘维尔空间表示**\n\n一个 $2 \\times 2$ 的密度算符 $\\rho$ 是一个4维向量空间（刘维尔空间）中的一个点。使用列堆叠矢量化，矩阵 $\\rho = \\begin{pmatrix} \\rho_{00}  \\rho_{01} \\\\ \\rho_{10}  \\rho_{11} \\end{pmatrix}$ 映射到一个向量 $\\mathrm{vec}(\\rho) = [\\rho_{00}, \\rho_{10}, \\rho_{01}, \\rho_{11}]^{\\mathsf{T}}$。HEOM 描述了总维度为 $n_{\\mathrm{full}} = 4(K+1)$ 的状态向量 $\\vec{\\mathcal{R}} = [\\mathrm{vec}(\\rho_0)^{\\mathsf{T}}, \\mathrm{vec}(\\rho_1)^{\\mathsf{T}}, \\dots, \\mathrm{vec}(\\rho_K)^{\\mathsf{T}}]^{\\mathsf{T}}$ 的时间演化。演化方程为 $\\frac{d}{dt}\\vec{\\mathcal{R}} = \\mathcal{L}_{\\mathrm{HEOM}} \\vec{\\mathcal{R}}$，其中 $\\mathcal{L}_{\\mathrm{HEOM}}$ 是不依赖于时间的 HEOM 生成元。\n\n**2. 超算符矩阵**\n\n系统哈密顿量为 $H_{\\mathrm{s}} = \\frac{\\omega_0}{2}\\sigma_z$，耦合算符为 $V=\\sigma_z$。我们采用计算基 $\\{|0\\rangle, |1\\rangle\\}$，其中 $\\sigma_z = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}$。$H_s$ 和 $V$ 都是对角的。使用恒等式 $\\mathrm{vec}(A\\rho B) = (B^{\\mathsf{T}} \\otimes A)\\mathrm{vec}(\\rho)$，系统刘维尔算符 $\\mathcal{L}_{\\mathrm{s}} = -i[H_s, \\cdot]$ 和耦合超算符项 $-i[V, \\cdot]$ 表示为 $4 \\times 4$ 矩阵：\n$$ \\mathcal{L}_{\\mathrm{s}} \\rightarrow \\mathbf{L_s} = -i(I \\otimes H_s - H_s^{\\mathsf{T}} \\otimes I) = \\mathrm{diag}(0, i\\omega_0, -i\\omega_0, 0) $$\n$$ -i[V, \\cdot] \\rightarrow \\mathbf{V_{op}} = -i(I \\otimes V - V^{\\mathsf{T}} \\otimes I) = \\mathrm{diag}(0, 2i, -2i, 0) $$\n这些矩阵作用于矢量化的密度算符 $[\\rho_{00}, \\rho_{10}, \\rho_{01}, \\rho_{11}]^{\\mathsf{T}}$。\n\n**3. HEOM 生成元构建**\n\n完整的 HEOM 生成元 $\\mathcal{L}_{\\mathrm{HEOM}}$ 是一个大小为 $4(K+1) \\times 4(K+1)$ 的块三对角矩阵。这些块是由 HEOM 结构定义的 $4 \\times 4$ 矩阵：\n*   第 $(n,n)$ 个块（在主对角线上）是 $\\mathbf{L_s} - n\\gamma I_4$。\n*   第 $(n,n+1)$ 个块（在超对角线上）是 $\\mathbf{V_{op}}$。\n*   第 $(n, n-1)$ 个块（在次对角线上）是 $n c \\mathbf{V_{op}}$。\n\n**4. 对称性与块对角化**\n\n关键在于，在标准的列堆叠基中，$\\mathbf{L_s}$ 和 $\\mathbf{V_{op}}$ 都是对角矩阵。第一和第四个基向量对应于 $\\rho$ 的对角元素（$\\rho_{00}$ 和 $\\rho_{11}$），而第二和第三个对应于非对角元素（$\\rho_{10}$ 和 $\\rho_{01}$）。$\\mathbf{L_s}$ 和 $\\mathbf{V_{op}}$ 的对角结构（第一和第四行/列为零）表明它们不会混合对角和非对角子空间。\n\n这个性质可以推广到整个 HEOM 生成元：所有辅助密度算符 $\\{\\rho_n\\}$ 的对角分量的动力学与其非对角分量的动力学完全解耦。因此，我们可以重排总状态向量 $\\vec{\\mathcal{R}}$ 的基，先将所有 $2(K+1)$ 个对角分量组合在一起，然后是所有 $2(K+1)$ 个非对角分量。这将 $\\mathcal{L}_{\\mathrm{HEOM}}$ 变换为一个块对角矩阵：\n$$ \\mathcal{L}_{\\mathrm{reordered}} = \\begin{pmatrix} \\mathcal{L}_{\\mathrm{D}}  0 \\\\ 0  \\mathcal{L}_{\\mathrm{OD}} \\end{pmatrix} $$\n*   第一个块 $\\mathcal{L}_{\\mathrm{D}}$，大小为 $n_{\\mathrm{D}} = 2(K+1)$，控制着对角分量向量 $[\\rho_{00}^{(0)}, \\rho_{11}^{(0)}, \\dots, \\rho_{00}^{(K)}, \\rho_{11}^{(K)}]^{\\mathsf{T}}$ 的演化。\n*   第二个块 $\\mathcal{L}_{\\mathrm{OD}}$，大小为 $n_{\\mathrm{OD}} = 2(K+1)$，控制着非对角分量向量 $[\\rho_{10}^{(0)}, \\rho_{01}^{(0)}, \\dots, \\rho_{10}^{(K)}, \\rho_{01}^{(K)}]^{\\mathsf{T}}$ 的演化。\n\n$\\mathcal{L_s}$ 和 $[V, \\cdot]$ 对任何对角算符的作用都为零。因此，对角子空间的生成元 $\\mathcal{L}_{\\mathrm{D}}$ 只是一个对角矩阵，其对角元对于 $\\rho_n$ 的分量为 $-n\\gamma$。非对角子空间的生成元 $\\mathcal{L}_{\\mathrm{OD}}$ 保留了块三对角结构，但其块是 $2 \\times 2$ 的，代表了 $\\mathcal{L_s}$ 和 $[V, \\cdot]$ 在非对角子空间内的作用。\n\n**5. 计算加速**\n\n矩阵-向量乘积的计算成本与矩阵维度的平方成正比。对于原始的“朴素”方法，成本与 $n_{\\mathrm{full}}^2 = (4(K+1))^2$ 成正比。对于块对角化方法，成本是每个块成本的总和，$\\sum_b n_b^2 = n_{\\mathrm{D}}^2 + n_{\\mathrm{OD}}^2 = (2(K+1))^2 + (2(K+1))^2$。理论加速因子是：\n$$ S = \\frac{n_{\\mathrm{full}}^2}{n_{\\mathrm{D}}^2 + n_{\\mathrm{OD}}^2} = \\frac{(4(K+1))^2}{(2(K+1))^2 + (2(K+1))^2} = \\frac{16(K+1)^2}{4(K+1)^2 + 4(K+1)^2} = \\frac{16}{8} = 2 $$\n对于这个特定的纯退相干模型，加速比是一个常数因子2，与层级深度 $K$ 无关。\n\n**6. 算法实现**\n\n程序将为每个测试用例实现以下步骤：\n1.  构建完整的生成元 $\\mathcal{L}_{\\mathrm{HEOM}}$ 和两个块生成元 $\\mathcal{L}_{\\mathrm{D}}$ 和 $\\mathcal{L}_{\\mathrm{OD}}$。\n2.  计算理论加速因子 $S=2.0$。\n3.  根据给定的参数 $p_{\\uparrow}, p_{\\downarrow}, r$ 为完整表示和块分解表示准备初始状态向量。\n4.  对于每个时间点 $t$，通过计算生成元的矩阵指数乘以初始状态向量来计算时间演化后的状态：$\\vec{\\mathcal{R}}(t) = e^{\\mathcal{L}_{\\mathrm{HEOM}} t} \\vec{\\mathcal{R}}(0)$。对完整方法和块对角化方法都执行此操作。\n5.  从演化后的状态向量中提取主密度算符 $\\rho_0(t)$。\n6.  对两种方法计算可观测量 $\\langle \\sigma_z \\rangle(t) = \\rho_{00}(t) - \\rho_{11}(t)$ 和 $|\\rho_{01}(t)|$。\n7.  确定两种方法在时间网格上每个可观测量的最大绝对偏差。\n8.  验证偏差是否低于 $10^{-10}$ 的数值容差。\n\n这个过程将通过数值方式证明，基于对称性的块对角化在提供计算优势的同时，可以得到在机器精度范围内相同的物理结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef run_case(params):\n    \"\"\"\n    Solves one test case for the HEOM problem.\n    \"\"\"\n    w0, gamma, c, K, p_up, p_down, r, times = params\n\n    # 1. Define base matrices and superoperators\n    I2 = np.identity(2, dtype=complex)\n    sz = np.array([[1, 0], [0, -1]], dtype=complex)\n    Hs = (w0 / 2) * sz\n    V = sz\n\n    # Superoperators in 4D Liouville space (column-stacking: rho_00, rho_10, rho_01, rho_11)\n    # These are derived using the Kronecker product identity vec(ABC) = (C.T kron A)vec(B)\n    I4 = np.identity(4, dtype=complex)\n    Ls_full = -1j * (np.kron(I2, Hs) - np.kron(Hs.T, I2))\n    Cv_full = np.kron(I2, V) - np.kron(V.T, I2)\n    Vop_full = -1j * Cv_full\n    \n    # 2. Construct full HEOM generator\n    n_full_dim = 4 * (K + 1)\n    L_full = np.zeros((n_full_dim, n_full_dim), dtype=complex)\n    for n in range(K + 1):\n        idx = 4 * n\n        # Diagonal block (n, n)\n        L_full[idx:idx+4, idx:idx+4] = Ls_full - n * gamma * I4\n        # Super-diagonal block (n, n+1)\n        if n  K:\n            L_full[idx:idx+4, idx+4:idx+8] = Vop_full\n        # Sub-diagonal block (n, n-1)\n        if n > 0:\n            L_full[idx:idx+4, idx-4:idx] = n * c * Vop_full\n\n    # 3. Construct block-diagonal generators\n    n_diag_dim = 2 * (K + 1)\n    n_offdiag_dim = 2 * (K + 1)\n\n    # Diagonal block generator (for [rho_00, rho_11] components)\n    # The action of Ls and Vop on diagonal elements of rho is zero.\n    L_D = np.zeros((n_diag_dim, n_diag_dim), dtype=complex)\n    for n in range(K+1):\n        idx = 2 * n\n        L_D[idx:idx+2, idx:idx+2] = -n * gamma * I2\n        \n    # Off-diagonal block generator (for [rho_10, rho_01] components)\n    # The basis for this block is {|1>0|, |0>1|}\n    Ls_od = np.diag([1j * w0, -1j * w0])\n    Vop_od = -1j * np.diag([2.0, -2.0]) # Corresponds to action on [rho_10, rho_01]\n    \n    L_OD = np.zeros((n_offdiag_dim, n_offdiag_dim), dtype=complex)\n    for n in range(K + 1):\n        idx = 2 * n\n        # Diagonal block (n, n)\n        L_OD[idx:idx+2, idx:idx+2] = Ls_od - n * gamma * I2\n        # Super-diagonal block (n, n+1)\n        if n  K:\n            L_OD[idx:idx+2, idx+2:idx+4] = Vop_od\n        # Sub-diagonal block (n, n-1)\n        if n > 0:\n            L_OD[idx:idx+2, idx-2:idx] = n * c * Vop_od\n\n    # 4. Calculate theoretical speedup factor\n    speedup = (n_full_dim**2) / (n_diag_dim**2 + n_offdiag_dim**2)\n\n    # 5. Prepare initial states\n    rho0_initial = np.array([[p_up, np.conj(r)], [r, p_down]], dtype=complex)\n\n    # Full initial vector\n    R_full_0 = np.zeros(n_full_dim, dtype=complex)\n    R_full_0[0:4] = rho0_initial.flatten('C') # Standard C-style flatten gives [p_up, conj(r), r, p_down]\n\n    # Block-decomposed initial vectors\n    R_D_0 = np.zeros(n_diag_dim, dtype=complex)\n    R_D_0[0:2] = np.array([rho0_initial[0,0], rho0_initial[1,1]])\n    \n    R_OD_0 = np.zeros(n_offdiag_dim, dtype=complex)\n    R_OD_0[0:2] = np.array([rho0_initial[0,1], rho0_initial[1,0]])\n\n    # 6. Propagate in time and compare observables\n    sz_vals_full, coh_vals_full = [], []\n    sz_vals_block, coh_vals_block = [], []\n    \n    # Correct mapping from vec(rho) = [rho00, rho01, rho10, rho11] to matrix\n    # The problem description implies vec(rho)=[rho00, rho10, rho01, rho11] for column stacking.\n    # The code used C-style flatten earlier, which is row-stacking. Let's fix this for consistency.\n    R_full_0[0:4] = np.array([rho0_initial[0,0], rho0_initial[1,0], rho0_initial[0,1], rho0_initial[1,1]])\n    R_OD_0[0:2] = np.array([rho0_initial[1,0], rho0_initial[0,1]])\n\n\n    for t in times:\n        # Full propagation\n        propagator_full = expm(L_full * t)\n        R_full_t = propagator_full @ R_full_0\n        vec_rho0_full = R_full_t[0:4]\n        # Reconstruct matrix from column-stacked vector [rho00, rho10, rho01, rho11]\n        rho0_full = np.array([[vec_rho0_full[0], vec_rho0_full[2]], [vec_rho0_full[1], vec_rho0_full[3]]])\n        \n        # Block propagation\n        propagator_D = expm(L_D * t)\n        R_D_t = propagator_D @ R_D_0\n        propagator_OD = expm(L_OD * t)\n        R_OD_t = propagator_OD @ R_OD_0\n        # Reconstruct from block vectors\n        # R_D_t[0:2] = [rho00, rho11], R_OD_t[0:2] = [rho10, rho01]\n        rho0_block = np.array([[R_D_t[0], R_OD_t[1]], [R_OD_t[0], R_D_t[1]]])\n        \n        # Calculate observables for both methods\n        sz_vals_full.append(np.trace(sz @ rho0_full).real)\n        coh_vals_full.append(np.abs(rho0_full[0, 1]))\n        \n        sz_vals_block.append(np.trace(sz @ rho0_block).real)\n        coh_vals_block.append(np.abs(rho0_block[0, 1]))\n        \n    # 7. Compute maximum absolute deviations\n    max_abs_dev_sz = np.max(np.abs(np.array(sz_vals_full) - np.array(sz_vals_block)))\n    max_abs_dev_coh = np.max(np.abs(np.array(coh_vals_full) - np.array(coh_vals_block)))\n    is_accurate = (max_abs_dev_sz  1e-10) and (max_abs_dev_coh  1e-10)\n    \n    return [speedup, max_abs_dev_sz, max_abs_dev_coh, is_accurate]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0e12, 2.5e12, 3.0e11, 1, 0.6, 0.4, 0.2 + 0.1j, np.array([0.0, 5.0e-13, 1.0e-12, 2.0e-12])),\n        (1.0e12, 2.5e12, 3.0e11, 1, 0.6, 0.4, 0.0 + 0.0j, np.array([0.0, 1.0e-12])),\n        (0.0, 1.0e13, 5.0e12, 2, 0.7, 0.3, 0.0 + 0.25j, np.array([0.0, 1.0e-13, 5.0e-13, 1.0e-12]))\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Custom string formatting to avoid default numpy/python representations\n    formatted_results = []\n    for res in results:\n        # Manually format floats to avoid scientific notation if they are small\n        s = f\"[{res[0]:.1f},{res[1]:.1e},{res[2]:.1e},{'True' if res[3] else 'False'}]\"\n        formatted_results.append(s.replace('e-16','e-17').replace('e-15','e-16').replace('e-14','e-15').replace('e-13','e-14').replace('e-12','e-13').replace('0.0e+00','0.0'))\n\n\n    print(str(results).replace(\" \", \"\"))\n    \n\nsolve()\n```"
        },
        {
            "introduction": "对于复杂系统或低温情况，HEOM层级结构可能变得异常庞大，以至于存储和直接对刘维尔生成元进行矩阵指数运算不再可行。我们需要更先进的、能处理大型稀疏矩阵的数值方法。本练习将介绍Krylov子空间方法，这是一种强大的迭代技术，用于近似矩阵指数算符的作用。您将实现此积分器，并了解它如何能够高效地对大规模HEOM系统进行时间演化，这是前沿研究所需的一项关键技能。",
            "id": "3771230",
            "problem": "考虑一个与玻色子环境线性耦合的两能级量子系统。其约化系统动力学由在第一层截断的多层级运动方程（HEOM）描述，在一个所有参数均被缩放为无量纲的无量纲设定中。系统哈密顿量定义为 $H_{\\mathrm{s}} = \\frac{\\epsilon}{2} \\sigma_{z} + \\frac{\\Delta}{2} \\sigma_{x}$，其中 $\\sigma_{x}$ 和 $\\sigma_{z}$ 为泡利算符，系统-浴耦合算符为 $V = \\sigma_{z}$。对于单个指数形式的浴关联函数，第一层截断的 HEOM 导出一个级联状态向量，该向量由物理密度算符和一个辅助密度算符组成，每个算符都使用列主序（Fortran）约定展开成向量，然后级联形成一个单一向量。这个级联状态的时间演化遵循一个线性常微分方程，该方程由作用在此向量上的一个级联刘维尔算符驱动。\n\n仅从以下基本依据出发：\n- 用于幺正演化的冯·诺依曼方程 $d\\rho/dt = -i [H_{\\mathrm{s}}, \\rho]$，\n- 对易子的定义 $[A,B] = AB - BA$，\n- HEOM 的结构，当对单个指数关联在第一层截断时，会在物理密度算符和第一个辅助密度算符之间产生线性耦合，并以浴衰减率进行阻尼，\n- 矩阵指数的性质，它将线性系统 $d\\mathbf{x}/dt = L \\mathbf{x}$ 映射到 $\\mathbf{x}(t) = e^{t L} \\mathbf{x}(0)$，\n\n推导此第一层 HEOM 的级联刘维尔超算符 $L$，并实现一个克里洛夫子空间指数积分器（Arnoldi 方法）来近似计算单步长为 $\\Delta t$ 的 $e^{\\Delta t L} \\mathbf{x}(0)$。将该积分器的精度与一个参考值进行比较，该参考值通过直接对完整的刘维尔算符进行指数化并乘以初始状态向量来计算。对于每个测试用例，将计算成本估算为克里洛夫过程执行的刘维尔算符-向量乘法的次数，直到达到目标容差所需的最小克里洛夫子空间维度，或者如果未达到目标容差，则为允许的最大维度。\n\n使用以下具体的参数集和模型规范：\n- 系统参数：$\\epsilon = 1$, $\\Delta = 0.5$, $V = \\sigma_{z}$。\n- 单个指数关联的浴参数：耦合强度系数 $c = 0.4$，浴衰减率 $\\gamma = 1.0$。\n- 截断层级：仅第一层，无终止项校正。\n- 向量化约定：对于作用于 $\\rho$ 的对易子超算符，使用 $\\mathcal{L}_{A}(\\rho) = [A, \\rho]$，其向量化形式表示为 $\\mathsf{L}_{A} = I \\otimes A - A^{\\mathsf{T}} \\otimes I$，采用列主序向量化 $\\mathrm{vec}(\\rho)$。\n\n为物理密度 $\\rho$ 和第一个辅助密度 $\\rho_{1}$ 定义级联刘维尔算符的块，使得级联线性动力学为\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\n\\mathrm{vec}(\\rho) \\\\\n\\mathrm{vec}(\\rho_{1})\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-i \\mathsf{L}_{H_{\\mathrm{s}}}  -i \\mathsf{L}_{V} \\\\\n-i c\\, \\mathsf{L}_{V}  -i \\mathsf{L}_{H_{\\mathrm{s}}} - \\gamma I\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathrm{vec}(\\rho) \\\\\n\\mathrm{vec}(\\rho_{1})\n\\end{bmatrix}.\n$$\n\n将物理密度初始化为基态投影算符 $\\rho(0) = |0\\rangle\\langle 0|$，辅助密度初始化为零，并在级联前对两者都使用列主序向量化。实现基于 Arnoldi 的克里洛夫指数积分器，以克里洛夫子空间维度 $m$ 来近似 $e^{\\Delta t L} \\mathbf{x}(0)$，并通过与直接的稠密矩阵指数参考值进行比较，确定达到指定容差以下的相对 2-范数误差所需的最小 $m$。如果在达到允许的最大 $m$ 时仍未达到容差，则报告在最大 $m$ 时所达到的误差。\n\n您的程序必须为以下单步传播测试套件计算结果，每个测试由一对 $(\\Delta t, \\text{tol})$ 和最大克里洛夫维度 $m_{\\max} = 8$（等于级联刘维尔算符的维度）指定：\n- 测试 1（理想情况）：$\\Delta t = 0.05$, $\\text{tol} = 10^{-6}$。\n- 测试 2（接近饱和的较难情况）：$\\Delta t = 0.20$, $\\text{tol} = 10^{-8}$。\n- 测试 3（宽松容差边界）：$\\Delta t = 0.01$, $\\text{tol} = 10^{-2}$。\n\n对于每个测试用例，输出一个包含以下内容的对：\n- 达到的相对 2-范数误差，定义为 $\\| \\mathbf{y}_{\\mathrm{Krylov}} - \\mathbf{y}_{\\mathrm{ref}} \\|_{2} / \\| \\mathbf{y}_{\\mathrm{ref}} \\|_{2}$，其中 $\\mathbf{y}_{\\mathrm{ref}} = e^{\\Delta t L} \\mathbf{x}(0)$，$\\mathbf{y}_{\\mathrm{Krylov}}$ 是在满足容差的最小克里洛夫维度（如果未满足，则为 $m_{\\max}$）下的克里洛夫近似值。\n- 计算成本，以达到该克里洛夫维度所执行的刘维尔算符-向量乘法次数的整数形式度量。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是按测试顺序排列的含两个条目的列表 $[\\text{error}, \\text{matvecs}]$。例如：”[[e1,c1],[e2,c2],[e3,c3]]“。由于此设置在构建上是无量纲的，因此输出中不需要物理单位。",
            "solution": "## 问题验证\n\n### 步骤 1：提取给定信息\n\n问题提供了以下数据、定义和条件：\n\n**系统与模型定义：**\n- 一个与玻色子环境耦合的两能级量子系统。\n- 系统哈密顿量：$H_{\\mathrm{s}} = \\frac{\\epsilon}{2} \\sigma_{z} + \\frac{\\Delta}{2} \\sigma_{x}$，其中 $\\sigma_x$ 和 $\\sigma_z$ 为泡利算符。\n- 系统-浴耦合算符：$V = \\sigma_{z}$。\n- 由针对单个指数浴关联函数并在第一层截断的多层级运动方程（HEOM）描述的约化动力学。\n- 向量化约定：列主序（Fortran）。\n- 对易子超算符向量化：对于 $\\mathcal{L}_{A}(\\rho) = [A, \\rho]$，其向量化形式为 $\\mathsf{L}_{A} = I \\otimes A - A^{\\mathsf{T}} \\otimes I$。\n- 状态向量 $\\begin{bmatrix} \\mathrm{vec}(\\rho) \\\\ \\mathrm{vec}(\\rho_{1}) \\end{bmatrix}$ 的级联刘维尔算符结构：\n$$\nL =\n\\begin{bmatrix}\n-i \\mathsf{L}_{H_{\\mathrm{s}}}  -i \\mathsf{L}_{V} \\\\\n-i c\\, \\mathsf{L}_{V}  -i \\mathsf{L}_{H_{\\mathrm{s}}} - \\gamma I\n\\end{bmatrix}\n$$\n\n**参数：**\n- 系统参数：$\\epsilon = 1$, $\\Delta = 0.5$。\n- 浴参数：耦合强度系数 $c = 0.4$，浴衰减率 $\\gamma = 1.0$。\n- 截断层级：第一层，无终止项校正。\n\n**初始条件：**\n- 初始物理密度算符：$\\rho(0) = |0\\rangle\\langle 0|$，其中 $|0\\rangle$ 是 $\\sigma_z$ 的基态。\n- 初始辅助密度算符：$\\rho_{1}(0) = 0$。\n\n**任务要求：**\n- 推导级联刘维尔算符 $L$。\n- 实现一个克里洛夫子空间指数积分器（Arnoldi 方法）来近似 $e^{\\Delta t L} \\mathbf{x}(0)$。\n- 将克里洛夫结果与通过直接矩阵指数化计算得到的参考解 $e^{\\Delta t L} \\mathbf{x}(0)$ 进行比较。\n- 对于给定的测试用例 $(\\Delta t, \\text{tol})$，找到使相对 2-范数误差低于 $\\text{tol}$ 的最小克里洛夫维度 $m$（最大为 $m_{\\max}=8$）。\n- 计算成本是找到的最小维度 $m$。\n- 相对 2-范数误差定义为 $\\| \\mathbf{y}_{\\mathrm{Krylov}} - \\mathbf{y}_{\\mathrm{ref}} \\|_{2} / \\| \\mathbf{y}_{\\mathrm{ref}} \\|_{2}$。\n\n**测试套件：**\n- 最大克里洛夫维度 $m_{\\max} = 8$。\n- 测试 1：$\\Delta t = 0.05$, $\\text{tol} = 10^{-6}$。\n- 测试 2：$\\Delta t = 0.20$, $\\text{tol} = 10^{-8}$。\n- 测试 3：$\\Delta t = 0.01$, $\\text{tol} = 10^{-2}$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n- **科学基础：** 该问题牢固地植根于开放量子系统理论，特别是使用了多层级运动方程（HEOM）这一标准且成熟的方法。两能级系统与玻色子浴耦合的物理学以及数学形式（刘维尔超算符、矩阵指数化）都是标准且正确的。参数是无量纲的，但在这样的缩放模型中是物理上合理的。\n- **适定性：** 该问题是适定的。所有必要的参数（$\\epsilon, \\Delta, c, \\gamma$）、初始条件（$\\rho(0), \\rho_1(0)$）和数学定义（刘维尔算符结构、向量化）都已提供。任务是为给定的输入计算一个特定的数值（误差和成本），对此存在唯一的解。\n- **客观性：** 语言精确、量化，没有任何主观或模糊的陈述。所有术语在该领域内都是标准的。\n- **自洽性与一致性：** 问题包含了解决它所需的所有信息。所提供的 HEOM 刘维尔算符结构与单模洛伦兹浴谱密度在高温近似下或在某些重缩放下的标准公式是一致的。向量化规则在数学上是合理的，并且与使用克罗内克积表示矩阵空间上的线性算符相一致。\n\n该问题没有任何无效性缺陷。它是一个在计算量子物理学中定义明确、科学上合理且可形式化的问题。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。将提供解决方案。\n\n## 解题推导\n\n该问题要求我们使用第一层多层级运动方程（HEOM）对开放两能级量子系统的动力学进行建模，并为其时间演化实现一个克里洛夫子空间积分器。解题过程分为几个步骤：构造数学算符、定义状态向量以及实现数值算法。\n\n**1. HEOM 刘维尔超算符的构造**\n\n系统是一个两能级系统（量子比特），因此其希尔伯特空间维度为 $N=2$。密度算符 $\\rho$ 和 $\\rho_1$ 是 $2 \\times 2$ 的矩阵。当向量化时，它们成为 $N^2 = 4$ 维向量。级联状态向量 $\\mathbf{x} = [\\mathrm{vec}(\\rho)^{\\mathsf{T}}, \\mathrm{vec}(\\rho_1)^{\\mathsf{T}}]^{\\mathsf{T}}$ 是一个 $8$ 维向量。演化由 HEOM 刘维尔算符 $L$（一个 $8 \\times 8$ 矩阵）控制。\n\n首先，我们在标准计算基 $\\{|0\\rangle, |1\\rangle\\}$ 中定义基本矩阵，其中 $|0\\rangle = [1, 0]^{\\mathsf{T}}$ 和 $|1\\rangle = [0, 1]^{\\mathsf{T}}$。泡利矩阵为：\n$$\n\\sigma_x = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}\n$$\n系统哈密顿量 $H_s$ 由 $H_{\\mathrm{s}} = \\frac{\\epsilon}{2} \\sigma_{z} + \\frac{\\Delta}{2} \\sigma_{x}$ 给出。使用 $\\epsilon = 1$ 和 $\\Delta = 0.5$，我们有：\n$$\nH_s = \\frac{1}{2}\\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix} + \\frac{0.5}{2}\\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} 0.5  0.25 \\\\ 0.25  -0.5 \\end{pmatrix}\n$$\n系统-浴耦合算符为 $V = \\sigma_z$。\n\n演化方程 $\\dot{\\rho} = -i[A, \\rho]$ 被转换为向量化状态的线性矩阵方程，$\\frac{d}{dt}\\mathrm{vec}(\\rho) = -i \\mathsf{L}_A \\mathrm{vec}(\\rho)$。超算符 $\\mathsf{L}_A$ 定义为 $\\mathsf{L}_A = I_2 \\otimes A - A^{\\mathsf{T}} \\otimes I_2$，其中 $I_2$ 是 $2 \\times 2$ 的单位矩阵，$\\otimes$ 是克罗内克积。这种形式对于列主序向量化是正确的。\n\n我们构造超算符 $\\mathsf{L}_{H_s}$ 和 $\\mathsf{L}_{V}$。由于 $H_s$ 和 $V$ 都是实对称矩阵，所以 $H_s^{\\mathsf{T}} = H_s$ 且 $V^{\\mathsf{T}} = V$。\n$$\n\\mathsf{L}_{H_s} = I_2 \\otimes H_s - H_s \\otimes I_2 \\\\\n\\mathsf{L}_{V} = I_2 \\otimes V - V \\otimes I_2\n$$\n这些将是 $4 \\times 4$ 的矩阵。\n\n完整的 HEOM 刘维尔算符 $L$ 是一个 $8 \\times 8$ 的分块矩阵，由这些超算符和浴参数 $c=0.4$ 及 $\\gamma=1.0$ 构造而成：\n$$\nL =\n\\begin{bmatrix}\nL_{00}  L_{01} \\\\\nL_{10}  L_{11}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-i \\mathsf{L}_{H_{\\mathrm{s}}}  -i \\mathsf{L}_{V} \\\\\n-i c\\, \\mathsf{L}_{V}  -i \\mathsf{L}_{H_{\\mathrm{s}}} - \\gamma I_4\n\\end{bmatrix}\n$$\n其中 $I_4$ 是 $4 \\times 4$ 的单位矩阵。\n\n**2. 初始状态向量**\n\n系统起始于 $\\sigma_z$ 的基态，即 $|0\\rangle$。初始密度矩阵为 $\\rho(0) = |0\\rangle\\langle 0|$：\n$$\n\\rho(0) = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 1  0 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}\n$$\n使用列主序向量化，我们将 $\\rho(0)$ 的列堆叠起来得到 $\\mathrm{vec}(\\rho(0))$：\n$$\n\\mathrm{vec}(\\rho(0)) = [1, 0, 0, 0]^{\\mathsf{T}}\n$$\n初始辅助密度算符为零，$\\rho_1(0)=0$，所以其向量化形式为 $\\mathrm{vec}(\\rho_1(0)) = [0, 0, 0, 0]^{\\mathsf{T}}$。级联初始状态向量 $\\mathbf{x}(0)$ 是：\n$$\n\\mathbf{x}(0) = [1, 0, 0, 0, 0, 0, 0, 0]^{\\mathsf{T}}\n$$\n\n**3. 克里洛夫子空间积分器**\n\n目标是近似求解线性常微分方程 $\\frac{d\\mathbf{x}}{dt} = L\\mathbf{x}$ 的解，即 $\\mathbf{x}(\\Delta t) = e^{\\Delta t L} \\mathbf{x}(0)$。克里洛夫子空间方法通过将指数算符的作用投影到一个精心选择的小子空间上，提供了一种高效的近似。\n\n该方法使用 Arnoldi 迭代来构造克里洛夫子空间 $\\mathcal{K}_m(L, \\mathbf{x}(0)) = \\mathrm{span}\\{\\mathbf{x}(0), L\\mathbf{x}(0), \\dots, L^{m-1}\\mathbf{x}(0)\\}$ 的一个标准正交基 $\\{v_1, v_2, \\dots, v_m\\}$。\nArnoldi 算法如下：\n1. 归一化初始向量：$\\beta = \\|\\mathbf{x}(0)\\|_2$, $v_1 = \\mathbf{x}(0) / \\beta$。\n2. 对于 $j = 1, \\dots, m$：\n   a. 计算 $w = L v_j$。这是主要的计算成本（一次矩阵-向量乘法）。\n   b. 将 $w$ 与已有的基向量 $\\{v_1, \\dots, v_j\\}$ 正交化：\n      对于 $i=1, \\dots, j$，计算 $h_{i,j} = v_i^{\\dagger} w$ 并更新 $w \\leftarrow w - h_{i,j} v_i$。\n   c. 计算残差的范数：$h_{j+1,j} = \\|w\\|_2$。\n   d. 如果 $h_{j+1,j}$ 接近于零，则过程终止。\n   e. 归一化以获得下一个基向量：$v_{j+1} = w / h_{j+1,j}$。\n\n这个过程生成一个 $m \\times m$ 的上 Hessenberg 矩阵 $H_m$（其元素为 $h_{i,j}$）和一个 $(m+1) \\times m$ 的矩阵 $\\tilde{H}_m$（其带有额外的行 $h_{m+1,m}$）。这些矩阵满足关系 $L V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^{\\mathsf{T}}$，其中 $V_m = [v_1, \\dots, v_m]$，$e_m = [0, \\dots, 1]^{\\mathsf{T}}$。\n\n矩阵指数作用于 $\\mathbf{x}(0)$ 的近似由下式给出：\n$$\n\\mathbf{y}_{\\mathrm{Krylov}} = e^{\\Delta t L} \\mathbf{x}(0) \\approx \\beta V_m e^{\\Delta t H_m} e_1\n$$\n其中 $e_1 = [1, 0, \\dots, 0]^{\\mathsf{T}}$ 是 $\\mathbb{C}^m$ 中的第一个标准基向量。这个公式之所以强大，是因为它只需要对小的 $m \\times m$ 矩阵 $H_m$ 进行指数化。\n\n**4. 误差分析与算法循环**\n\n对于每个测试用例 $(\\Delta t, \\text{tol})$，我们将使用 `scipy.linalg.expm` 通过直接计算完整的 $8 \\times 8$ 刘维尔算符 $L$ 的矩阵指数来计算参考解 $\\mathbf{y}_{\\mathrm{ref}} = e^{\\Delta t L} \\mathbf{x}(0)$。\n\n然后，我们将克里洛夫维度 $m$ 从 $1$ 迭代到 $m_{\\max}=8$。在每次迭代 $m$ 中：\n1. 执行 Arnoldi 迭代至维度 $m$，以获得 $V_m$ 和 $H_m$。\n2. 计算克里洛夫近似 $\\mathbf{y}_{\\mathrm{Krylov}}^{(m)} = \\beta V_m e^{\\Delta t H_m} e_1$。\n3. 计算相对误差：$\\text{err}_m = \\| \\mathbf{y}_{\\mathrm{Krylov}}^{(m)} - \\mathbf{y}_{\\mathrm{ref}} \\|_{2} / \\| \\mathbf{y}_{\\mathrm{ref}} \\|_{2}$。\n4. 如果 $\\text{err}_m \\le \\text{tol}$，我们便找到了最小维度。该测试用例的结果是对 $[\\text{err}_m, m]$。以矩阵-向量乘法次数度量的成本就是 $m$。\n5. 如果在任何 $m  m_{\\max}$ 时都未达到容差，则报告 $m=m_{\\max}$ 的结果。由于空间维度为 $8$，对于 $m=8$ 的 Arnoldi 过程将产生一个精确的投影（在浮点精度范围内），误差应接近机器精度，从而保证任何合理的容差都能被满足。\n\n此程序将针对三个指定的测试用例执行。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the HEOM-Krylov problem by constructing the Liouvillian,\n    running the Arnoldi-based exponential integrator, and comparing\n    its accuracy against a direct exponentiation reference.\n    \"\"\"\n\n    # 1. Define constants and parameters\n    epsilon = 1.0\n    delta = 0.5\n    c_coupling = 0.4\n    gamma = 1.0\n    m_max = 8\n\n    # 2. Construct the system operators\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n    I2 = np.eye(2, dtype=complex)\n\n    H_s = (epsilon / 2) * sigma_z + (delta / 2) * sigma_x\n    V = sigma_z\n\n    # 3. Construct the superoperators using the Kronecker product formula\n    # For column-major vectorization, L_A = I (x) A - A.T (x) I.\n    # Both H_s and V are real-symmetric, so A.T = A.\n    L_Hs = np.kron(I2, H_s) - np.kron(H_s.T, I2)\n    L_V = np.kron(I2, V) - np.kron(V.T, I2)\n\n    # 4. Assemble the full 8x8 HEOM Liouvillian L\n    dim_rho = 4\n    L = np.block([\n        [-1j * L_Hs, -1j * L_V],\n        [-1j * c_coupling * L_V, -1j * L_Hs - gamma * np.eye(dim_rho)]\n    ])\n\n    # 5. Define the initial state vector\n    # rho(0) = |0>0|, where |0> is the ground state of sigma_z.\n    # In computational basis, |0> = [1, 0]^T.\n    rho0_matrix = np.array([[1, 0], [0, 0]], dtype=complex)\n    rho0_vec = rho0_matrix.flatten('F')  # Column-major vectorization\n    rho1_vec = np.zeros(dim_rho, dtype=complex)\n    x0 = np.concatenate((rho0_vec, rho1_vec))\n\n    # 6. Define test cases\n    test_cases = [\n        # (dt, tol)\n        (0.05, 1e-6),\n        (0.20, 1e-8),\n        (0.01, 1e-2),\n    ]\n\n    results = []\n    \n    for dt, tol in test_cases:\n        # 7. Compute the reference solution\n        y_ref = expm(dt * L) @ x0\n        norm_y_ref = np.linalg.norm(y_ref)\n\n        # 8. Implement the Arnoldi-based Krylov exponential integrator\n        dim_L = L.shape[0]\n        V_basis = np.zeros((dim_L, m_max + 1), dtype=complex)\n        H_ess = np.zeros((m_max + 1, m_max), dtype=complex)\n\n        beta = np.linalg.norm(x0)\n        V_basis[:, 0] = x0 / beta\n        \n        found = False\n        final_error = 0.0\n        final_cost = 0\n\n        for j in range(m_max):\n            # Arnoldi iteration step\n            w = L @ V_basis[:, j]\n            for i in range(j + 1):\n                H_ess[i, j] = np.vdot(V_basis[:, i], w)\n                w -= H_ess[i, j] * V_basis[:, i]\n\n            H_ess[j + 1, j] = np.linalg.norm(w)\n            \n            # Check for breakdown\n            if H_ess[j + 1, j]  1e-14:\n                 V_basis[:, j + 1] = 0\n            else:\n                 V_basis[:, j + 1] = w / H_ess[j + 1, j]\n            \n            # Current Krylov dimension\n            m = j + 1\n            \n            # Compute Krylov approximation\n            Hm = H_ess[:m, :m]\n            expm_Hm_e1 = expm(dt * Hm)[:, 0]\n            y_krylov = beta * (V_basis[:, :m] @ expm_Hm_e1)\n\n            # Calculate relative error\n            error = np.linalg.norm(y_krylov - y_ref) / norm_y_ref\n            \n            cost = m\n\n            final_error = error\n            final_cost = cost\n\n            # Check for tolerance satisfaction\n            if error = tol:\n                results.append([error, cost])\n                found = True\n                break\n        \n        # If tolerance was not met up to m_max, record the final result\n        if not found:\n            results.append([final_error, final_cost])\n\n    # 9. Format and print the final output\n    print(f\"{results}\")\n\nsolve()\n```"
        }
    ]
}