{
    "hands_on_practices": [
        {
            "introduction": "张量网络天然适用于描述纯态，但如何表示混合态是一个核心挑战。解决方案是巧妙的“纯化”(purification) 方法，即在一个包含辅助系统的扩展空间中，用一个纯的矩阵乘积态 (MPS) 来表示原系统的混合态。这个练习  将通过推导表示一个简单混合态所需的最小辅助维度，帮助你深入理解这一基本构造及其效率。",
            "id": "3785968",
            "problem": "考虑一个在计算基 $\\{\\,|00\\rangle,|01\\rangle,|10\\rangle,|11\\rangle\\,\\}$ 上的两量子比特混合态，其密度算符 $\\rho$ 为对角矩阵 $\\rho=\\mathrm{diag}(p,1-p,0,0)$，其中 $p\\in(0,1)$。在矩阵乘积密度算符 (MPDO) 框架中，可以将 $\\rho$ 表示为一个定义在联合的系统-辅助系统希尔伯特空间上的矩阵乘积态 (MPS) 纯化 $|\\Psi\\rangle$ 对辅助系统 (ancilla) 求偏迹的结果。仅从纯化和密度算符谱分解的定义出发，并利用标准的线性代数和张量网络推理，完成以下任务：\n\n- 为 $\\rho$ 构建一个显式的纯化拟设 $|\\Psi\\rangle$，该拟设与由两个系统量子比特和一个辅助系统组成的链上的 MPS 表示兼容。\n- 利用 Schmidt 分解和秩的基本性质，推导辅助系统所需的最小希尔伯特空间维度 $d_{A}$，使得 $\\mathrm{Tr}_{A}(|\\Psi\\rangle\\langle\\Psi|)=\\rho$ 对所有 $p\\in(0,1)$ 精确成立。\n\n以等于最小 $d_{A}$ 的单个整数形式提供您的最终答案。无需四舍五入。不要包含单位。",
            "solution": "问题要求确定用于纯化一个给定的两量子比特混合态 $\\rho$ 的辅助系统的最小希尔伯特空间维度 $d_A$。纯化是在组合的系统-辅助系统空间中的一个纯态 $|\\Psi\\rangle$，它必须满足 $\\rho = \\mathrm{Tr}_{A}(|\\Psi\\rangle\\langle\\Psi|)$。\n\n首先，我们分析给定的密度算符 $\\rho$。它在计算基 $\\{\\,|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\,\\}$ 中以对角矩阵 $\\rho=\\mathrm{diag}(p, 1-p, 0, 0)$ 的形式给出，其中 $p \\in (0,1)$。这对应于算符形式：\n$$\n\\rho = p |00\\rangle\\langle00| + (1-p) |01\\rangle\\langle01|\n$$\n这个表达式是 $\\rho$ 的谱分解，因为态 $|00\\rangle$ 和 $|01\\rangle$ 是正交的。其本征值为 $\\lambda_1 = p$，$\\lambda_2 = 1-p$ 和 $\\lambda_3=\\lambda_4=0$。对应的标准正交本征矢为 $|\\psi_1\\rangle = |00\\rangle$、 $|\\psi_2\\rangle = |01\\rangle$、 $|\\psi_3\\rangle = |10\\rangle$ 和 $|\\psi_4\\rangle = |11\\rangle$。\n\n系统希尔伯特空间 $H_S$ 上的密度算符 $\\rho$ 的一个纯化，是在一个扩展的希尔伯特空间 $H_S \\otimes H_A$ 中的一个纯态 $|\\Psi\\rangle$，使得 $\\rho = \\mathrm{Tr}_A(|\\Psi\\rangle\\langle\\Psi|)$。给定谱分解 $\\rho = \\sum_i \\lambda_i |\\psi_i\\rangle\\langle\\psi_i|$，纯化的一般构造方法是：\n$$\n|\\Psi\\rangle = \\sum_i \\sqrt{\\lambda_i} |\\psi_i\\rangle \\otimes |a_i\\rangle\n$$\n其中 $\\{|a_i\\rangle\\}$ 是辅助系统希尔伯特空间 $H_A$ 中的一组标准正交态。所需的态 $|a_i\\rangle$ 的数量对应于 $\\rho$ 的非零本征值的数量。\n\n将此构造应用于我们特定的 $\\rho$，我们有两个非零本征值，$\\lambda_1 = p$ 和 $\\lambda_2 = 1-p$。让我们为辅助系统选择一组标准正交基 $\\{|0\\rangle_A, |1\\rangle_A, \\dots\\}$。我们可以使用前两个基矢来构造纯化。这满足了问题陈述的第一部分，即构造一个显式的纯化拟设 $|\\Psi\\rangle$：\n$$\n|\\Psi\\rangle = \\sqrt{p} |00\\rangle \\otimes |0\\rangle_A + \\sqrt{1-p} |01\\rangle \\otimes |1\\rangle_A\n$$\n这个态是归一化的，因为 $\\langle\\Psi|\\Psi\\rangle = (\\sqrt{p})^2 + (\\sqrt{1-p})^2 = p + 1 - p = 1$。让我们验证这是一个有效的纯化：\n$$\n\\mathrm{Tr}_{A}(|\\Psi\\rangle\\langle\\Psi|) = \\mathrm{Tr}_{A} \\left( p|00\\rangle\\langle00|\\otimes|0\\rangle_A\\langle0|_A + (1-p)|01\\rangle\\langle01|\\otimes|1\\rangle_A\\langle1|_A + \\sqrt{p(1-p)}(\\dots) \\right)\n$$\n对辅助系统基 $\\{|k\\rangle_A\\}$ 的偏迹是 $\\sum_k \\langle k|_A (\\dots) |k\\rangle_A$。\n$$\n\\mathrm{Tr}_{A}(|\\Psi\\rangle\\langle\\Psi|) = p|00\\rangle\\langle00| \\cdot \\langle 0|_A|0\\rangle_A\\langle 0|_A|0\\rangle_A + (1-p)|01\\rangle\\langle01| \\cdot \\langle 1|_A|1\\rangle_A\\langle 1|_A|1\\rangle_A = p|00\\rangle\\langle00| + (1-p)|01\\rangle\\langle01| = \\rho\n$$\n由于辅助系统态的正交性，交叉项消失。这证实了我们的拟设是一个有效的纯化。\n\n为了找到辅助系统所需的*最小*维度，我们援引 Schmidt 分解的性质。构造的态 $|\\Psi\\rangle$ 已经是系统-辅助系统二分划分下的 Schmidt 分解形式：\n$$\n|\\Psi\\rangle = \\sum_{k=1}^r s_k |u_k\\rangle_S |v_k\\rangle_A\n$$\n其中 $s_k$ 是 Schmidt 系数，$\\{|u_k\\rangle_S\\}$ 和 $\\{|v_k\\rangle_A\\}$ 是标准正交集，而 $r$ 是 Schmidt 秩。对于我们的态 $|\\Psi\\rangle$：\n- Schmidt 系数为 $s_1 = \\sqrt{p}$ 和 $s_2 = \\sqrt{1-p}$。\n- 系统 Schmidt 态为 $|u_1\\rangle_S = |00\\rangle$ 和 $|u_2\\rangle_S = |01\\rangle$。\n- 辅助系统 Schmidt 态为 $|v_1\\rangle_A = |0\\rangle_A$ 和 $|v_2\\rangle_A = |1\\rangle_A$。\n\n因为 $p \\in (0,1)$，所以 $p$ 和 $1-p$ 都是严格正的。因此，有两个非零的 Schmidt 系数。$|\\Psi\\rangle$ 的 Schmidt 秩因此为 $r=2$。\n\n量子力学的一个基本定理指出，一个纯二分体态 $|\\Psi\\rangle \\in H_S \\otimes H_A$ 的 Schmidt 秩等于约化密度算符 $\\rho_S = \\mathrm{Tr}_A(|\\Psi\\rangle\\langle\\Psi|)$ 和 $\\rho_A = \\mathrm{Tr}_S(|\\Psi\\rangle\\langle\\Psi|)$ 的秩。\n$$\n\\mathrm{rank}(\\rho_S) = \\mathrm{rank}(\\rho_A) = r\n$$\n希尔伯特空间的维度必须至少与作用在其上的任何密度算符的秩一样大。因此，对于辅助系统空间 $H_A$，我们必须有：\n$$\nd_A = \\dim(H_A) \\ge \\mathrm{rank}(\\rho_A)\n$$\n结合这些结果，我们发现辅助系统的最小维度由系统密度算符 $\\rho$ 的秩决定：\n$$\nd_{A, \\text{min}} = \\mathrm{rank}(\\rho_A) = \\mathrm{rank}(\\rho_S) = \\mathrm{rank}(\\rho)\n$$\n我们需要计算 $\\rho = \\mathrm{diag}(p, 1-p, 0, 0)$ 的秩。对角矩阵的秩是其非零对角元素的数量。给定 $p \\in (0,1)$， $p$ 和 $1-p$ 都是非零的。另外两个对角元素为零。因此，恰好有两个非零元素。\n$$\n\\mathrm{rank}(\\rho) = 2\n$$\n因此，对 $\\rho$ 进行精确纯化所需的辅助系统希尔伯特空间的最小维度为 $2$。我们构造的 $|\\Psi\\rangle$ 使用了一个具有两个基态 $|0\\rangle_A$ 和 $|1\\rangle_A$ 的辅助系统，这证实了维度 $2$ 是足够的。\n\n问题还提到了在由两个量子比特和辅助系统组成的链上对纯化进行 MPS 表示。我们构造的态是 $|\\Psi\\rangle = |0\\rangle_1 \\otimes (\\sqrt{p}|0\\rangle_2|0\\rangle_A + \\sqrt{1-p}|1\\rangle_2|1\\rangle_A)$。这种结构是第一个量子比特与链上其余部分之间的乘积态，这意味着位置 1 和 2 之间的键维数为 1。位置 2 和辅助系统的态是一个 Schmidt 秩为 2 的纠缠态，需要它们之间的键维数为 2。这证实了该纯化与链上键维数为 $(1, 2)$ 的 MPS 表示兼容，这需要一个维度 $d_A=2$ 的辅助系统。因此，所需的最小维度是 $d_A=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在建立了如何表示状态之后，下一步是进行时间演化。开放量子系统的动力学由一个称为刘维尔超算符 (Liouvillian superoperator) 的算符所支配，而这个超算符本身可以被高效地表示为一个矩阵乘积算符 (MPO)。这个练习  让你亲手为一个小型系统构建刘维尔算符，并分析其谱性质，这对于理解系统的弛豫行为至关重要。",
            "id": "3786071",
            "problem": "考虑一个由两个格点（标记为 $1$ 和 $2$）组成的自旋-$\\tfrac{1}{2}$链，其初始状态为一个由密度算符 $\\rho$ 描述的任意态。该动力学过程是马尔可夫的，并由不含相干哈密顿量部分的 Gorini–Kossakowski–Lindblad–Sudarshan (GKLS) 主方程所支配。每个格点通过局域 Lindblad 跳跃算符 $L_{1}=\\sqrt{\\gamma}\\,\\sigma_{z}^{(1)}$ 和 $L_{2}=\\sqrt{\\gamma}\\,\\sigma_{z}^{(2)}$ 与一个纯退相干环境耦合，其中 $\\gamma$ 是退相干速率，$\\sigma_{z}^{(i)}$ 是作用于格点 $i$ 的泡利-$z$ 算符，而在另一个格点上则为单位算符。刘维尔超算符 $\\mathcal{L}$ 生成了动力学过程 $d\\rho/dt=\\mathcal{L}[\\rho]$。\n\n使用两格点刘维尔算符的矩阵积算符 (MPO) 表示，将密度算符矢量化为一个16分量的刘维尔空间矢量，即将 $\\rho$ 在每个格点的局域算符基 $\\{I,\\sigma_{x},\\sigma_{y},\\sigma_{z}\\}$ 上展开。构建 $\\mathcal{L}$ 对应的 $16\\times 16$ 矩阵表示，并进行精确对角化以确定其完整谱。找出谱隙，其定义为刘维尔算符的本征值 $\\lambda$ 中 $-\\operatorname{Re}\\lambda$ 的最小非零值，该谱隙控制着无迹可观测量的渐近弛豫速率。\n\n请用退相干速率 $\\gamma$ 的闭合解析表达式来表示谱隙的最终答案。以秒的倒数（inverse seconds）为单位报告谱隙，但不要代入 $\\gamma$ 的数值，也不要四舍五入；请给出精确表达式。",
            "solution": "该问题要求计算在局域纯退相干作用下，描述一个两格点自旋-$\\frac{1}{2}$链动力学的刘维尔超算符的谱隙。该问题表述清晰，并在开放量子系统理论中有坚实的科学基础。我们着手求解。\n\n密度算符 $\\rho$ 的动力学由 Gorini–Kossakowski–Lindblad–Sudarshan (GKLS) 主方程描述。由于相干哈密顿量部分为零 ($H=0$)，该方程为：\n$$\n\\frac{d\\rho}{dt} = \\mathcal{L}[\\rho] = \\sum_{k=1,2} \\left( L_k \\rho L_k^\\dagger - \\frac{1}{2} \\{L_k^\\dagger L_k, \\rho\\} \\right)\n$$\nLindblad 跳跃算符为 $L_{1}=\\sqrt{\\gamma}\\,\\sigma_{z}^{(1)}$ 和 $L_{2}=\\sqrt{\\gamma}\\,\\sigma_{z}^{(2)}$，其中 $\\sigma_{z}^{(i)}$ 是作用于格点 $i$ 的泡利-$z$ 算符，而在另一个格点上为单位算符。退相干速率 $\\gamma$ 是一个正实数。\n\n由于 $\\sigma_z$ 是厄米算符，我们有 $L_k^\\dagger = L_k$。乘积 $L_k^\\dagger L_k$ 为：\n$$\nL_k^\\dagger L_k = (\\sqrt{\\gamma}\\,\\sigma_{z}^{(k)})(\\sqrt{\\gamma}\\,\\sigma_{z}^{(k)}) = \\gamma (\\sigma_{z}^{(k)})^2 = \\gamma I\n$$\n由于 $(\\sigma_{z}^{(k)})^2$ 是作用于整个两格点希尔伯特空间上的单位算符，所以 $L_k^\\dagger L_k = \\gamma I$。\n反对易子项变为 $\\frac{1}{2} \\{L_k^\\dagger L_k, \\rho\\} = \\frac{1}{2} \\{\\gamma I, \\rho\\} = \\frac{1}{2}(\\gamma I \\rho + \\rho \\gamma I) = \\gamma \\rho$。\n\n将此代入 GKLS 方程，刘维尔算符对于纯退相干的形式为：\n$$\n\\mathcal{L}[\\rho] = \\sum_{k=1,2} \\left( L_k \\rho L_k - \\gamma \\rho \\right) = \\gamma \\left( \\sigma_{z}^{(1)} \\rho \\sigma_{z}^{(1)} - \\rho \\right) + \\gamma \\left( \\sigma_{z}^{(2)} \\rho \\sigma_{z}^{(2)} - \\rho \\right)\n$$\n我们可以将其写为 $\\mathcal{L}[\\rho] = \\gamma (\\sigma_{z}^{(1)} \\rho \\sigma_{z}^{(1)} + \\sigma_{z}^{(2)} \\rho \\sigma_{z}^{(2)} - 2\\rho)$。\n\n为了找到 $\\mathcal{L}$ 的谱，我们必须将其对角化。这可以通过转换到刘维尔空间来完成，在该空间中，密度算符表示为矢量，而超算符表示为矩阵。两量子比特希尔伯特空间上的算符空间维度为 $4 \\times 4 = 16$。该空间的一个方便的基是单格点泡利基的张量积。令 $\\sigma_0 = I$, $\\sigma_1 = \\sigma_x$, $\\sigma_2 = \\sigma_y$, $\\sigma_3 = \\sigma_z$。我们的基算符是 $S_{\\alpha\\beta} = \\sigma_\\alpha^{(1)} \\otimes \\sigma_\\beta^{(2)}$，其中 $\\alpha, \\beta \\in \\{0, 1, 2, 3\\}$。\n\n$\\mathcal{L}$ 的本征值 $\\lambda$ 通过求解本征方程 $\\mathcal{L}[O] = \\lambda O$ 得到，其中 $O$ 是本征算符。幸运的是，对于本题，基算符 $S_{\\alpha\\beta}$ 正是 $\\mathcal{L}$ 的本征算符。我们通过计算 $\\mathcal{L}$ 对一个通用基算符 $S_{\\alpha\\beta}$ 的作用来证明这一点。\n刘维尔算符可以分解为两个对易的部分，$\\mathcal{L} = \\mathcal{L}_1 + \\mathcal{L}_2$，其中 $\\mathcal{L}_k[\\rho] = \\gamma (\\sigma_{z}^{(k)} \\rho \\sigma_{z}^{(k)} - \\rho)$。\n$$\n\\mathcal{L}[S_{\\alpha\\beta}] = \\mathcal{L}_1[\\sigma_\\alpha^{(1)} \\otimes \\sigma_\\beta^{(2)}] + \\mathcal{L}_2[\\sigma_\\alpha^{(1)} \\otimes \\sigma_\\beta^{(2)}]\n$$\n$$\n\\mathcal{L}[S_{\\alpha\\beta}] = \\gamma \\left( (\\sigma_{z}^{(1)} \\sigma_\\alpha^{(1)} \\sigma_{z}^{(1)}) \\otimes \\sigma_\\beta^{(2)} - \\sigma_\\alpha^{(1)} \\otimes \\sigma_\\beta^{(2)} \\right) + \\gamma \\left( \\sigma_\\alpha^{(1)} \\otimes (\\sigma_{z}^{(2)} \\sigma_\\beta^{(2)} \\sigma_{z}^{(2)}) - \\sigma_\\alpha^{(1)} \\otimes \\sigma_\\beta^{(2)} \\right)\n$$\n为了简化这个表达式，我们使用泡利矩阵在 $\\sigma_z$ 共轭下的性质：\n- 如果 $\\sigma_\\mu \\in \\{I, \\sigma_z\\}$，则 $\\sigma_z \\sigma_\\mu \\sigma_z = \\sigma_\\mu$。\n- 如果 $\\sigma_\\mu \\in \\{\\sigma_x, \\sigma_y\\}$，则 $\\sigma_z \\sigma_\\mu \\sigma_z = -\\sigma_\\mu$。这可由反对易关系 $\\{\\sigma_i, \\sigma_j\\} = 2\\delta_{ij}I$ 推导得出。对于 $i \\ne j$，$\\sigma_i \\sigma_j = -\\sigma_j \\sigma_i$。所以 $\\sigma_z \\sigma_x = i\\sigma_y = -\\sigma_x \\sigma_z$，这给出 $\\sigma_z \\sigma_x \\sigma_z = -\\sigma_x$。对于 $\\sigma_y$ 也是类似的。\n\n我们定义一个函数 $f(\\alpha)$，使得 $\\sigma_z \\sigma_\\alpha \\sigma_z = f(\\alpha) \\sigma_\\alpha$。那么，对于 $\\alpha \\in \\{0, 3\\}$，$f(\\alpha) = 1$；对于 $\\alpha \\in \\{1, 2\\}$，$f(\\alpha) = -1$。\n刘维尔算符的作用变为：\n$$\n\\mathcal{L}[S_{\\alpha\\beta}] = \\gamma \\left( f(\\alpha) - 1 \\right) S_{\\alpha\\beta} + \\gamma \\left( f(\\beta) - 1 \\right) S_{\\alpha\\beta} = \\gamma \\left( f(\\alpha) + f(\\beta) - 2 \\right) S_{\\alpha\\beta}\n$$\n这证实了 $S_{\\alpha\\beta}$ 是本征算符。对应于 $S_{\\alpha\\beta}$ 的本征值为 $\\lambda_{\\alpha\\beta} = \\gamma (f(\\alpha) + f(\\beta) - 2)$。\n\n现在，我们可以通过考虑所有16种 $\\alpha$ 和 $\\beta$ 的组合来找到完整的谱：\n1.  $\\alpha, \\beta \\in \\{0, 3\\}$：算符为 $I \\otimes I$, $I \\otimes \\sigma_z$, $\\sigma_z \\otimes I$, $\\sigma_z \\otimes \\sigma_z$。共有 $2 \\times 2 = 4$ 个这样的算符。\n    在这种情况下，$f(\\alpha) = 1$ 且 $f(\\beta) = 1$。本征值为 $\\lambda = \\gamma(1 + 1 - 2) = 0$。\n    因此，存在一个简并度为4的本征值 $\\lambda=0$。该子空间包含了系统的稳态（与 $I \\otimes I$ 成正比）。\n\n2.  $\\alpha \\in \\{1, 2\\}$ 且 $\\beta \\in \\{0, 3\\}$：算符为 $\\sigma_x \\otimes I$, $\\sigma_x \\otimes \\sigma_z$, $\\sigma_y \\otimes I$, $\\sigma_y \\otimes \\sigma_z$。共有 $2 \\times 2 = 4$ 个这样的算符。\n    在这种情况下，$f(\\alpha) = -1$ 且 $f(\\beta) = 1$。本征值为 $\\lambda = \\gamma(-1 + 1 - 2) = -2\\gamma$。\n\n3.  $\\alpha \\in \\{0, 3\\}$ 且 $\\beta \\in \\{1, 2\\}$：算符为 $I \\otimes \\sigma_x$, $I \\otimes \\sigma_y$, $\\sigma_z \\otimes \\sigma_x$, $\\sigma_z \\otimes \\sigma_y$。共有 $2 \\times 2 = 4$ 个这样的算符。\n    在这种情况下，$f(\\alpha) = 1$ 且 $f(\\beta) = -1$。本征值为 $\\lambda = \\gamma(1 - 1 - 2) = -2\\gamma$。\n    结合情况2和3，存在一个简并度总共为 $4+4=8$ 的本征值 $\\lambda=-2\\gamma$。这些本征算符对应于因单个格点上的退相干而衰减的相干项。\n\n4.  $\\alpha, \\beta \\in \\{1, 2\\}$：算符为 $\\sigma_x \\otimes \\sigma_x$, $\\sigma_x \\otimes \\sigma_y$, $\\sigma_y \\otimes \\sigma_x$, $\\sigma_y \\otimes \\sigma_y$。共有 $2 \\times 2 = 4$ 个这样的算符。\n    在这种情况下，$f(\\alpha) = -1$ 且 $f(\\beta) = -1$。本征值为 $\\lambda = \\gamma(-1 - 1 - 2) = -4\\gamma$。\n    因此，存在一个简并度为4的本征值 $\\lambda=-4\\gamma$。这些表示对两个格点上的退相干都敏感的相干项。\n\n刘维尔算符 $\\mathcal{L}$ 的完整谱由本征值集合 $\\{0, -2\\gamma, -4\\gamma\\}$ 组成，其简并度分别为 $4, 8, 4$。所有本征值都是实数。\n\n谱隙定义为 $-\\operatorname{Re}(\\lambda)$ 的最小非零值。由于所有本征值 $\\lambda$ 都是实数，这就是 $-\\lambda$ 的最小非零值。\n$-\\lambda$ 的值集合为 $\\{0, 2\\gamma, 4\\gamma\\}$。\n非零值为 $2\\gamma$ 和 $4\\gamma$。由于退相干速率 $\\gamma$ 必须为正，这些非零值中的最小值为 $2\\gamma$。\n\n谱隙决定了任意无迹可观测量向其稳态期望值弛豫的最慢渐近速率。对于此系统，该速率为 $2\\gamma$。$\\gamma$ 的单位是时间的倒数，因此谱隙的单位也是时间的倒数（例如，秒的倒数，$s^{-1}$）。",
            "answer": "$$\n\\boxed{2\\gamma}\n$$"
        },
        {
            "introduction": "有了状态的表示方法 (MPS) 和动力学演化生成元 (MPO)，最后一步就是模拟时间演化。由于对大型系统而言，精确地计算刘维尔算符的指数是不可行的，我们依赖于近似方案，如基于特罗特分解 (Trotter decomposition) 的时间演化块衰减 (TEBD) 算法。这个编程练习  旨在通过为一个小型系统实现该数值方法，并将其结果与精确解进行比较，来帮助你建立直观理解并验证其准确性。",
            "id": "3786061",
            "problem": "考虑一个由 Lindblad 主方程描述的开放量子多体系统，该方程是马尔可夫开放动力学的一个标准且被广泛接受的框架。从密度算符 $\\rho(t)$ 的时间演化基本定律出发：\n$$\n\\frac{d\\rho(t)}{dt} = -i[H,\\rho(t)] + \\sum_{k} \\left(L_k \\rho(t) L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho(t)\\}\\right),\n$$\n其中 $H$ 是哈密顿量，$L_k$ 是跳跃算符，$[\\cdot,\\cdot]$ 表示对易子，$\\{\\cdot,\\cdot\\}$ 表示反对易子。关注一个具有 $N=2$ 个格点且局域希尔伯特空间维度为 $d=2$ 的自旋-$\\frac{1}{2}$ 链。在每个格点上使用泡利矩阵 $\\sigma_x$、$\\sigma_y$、$\\sigma_z$ 和单位矩阵 $I$。\n\n将哈密顿量定义为 $x$ 和 $y$ 分量上的最近邻各向同性交换：\n$$\nH = J\\left(\\sigma_x^{(1)}\\sigma_x^{(2)} + \\sigma_y^{(1)}\\sigma_y^{(2)}\\right),\n$$\n其中 $J$ 是一个实数耦合常数，上标表示格点索引。用跳跃算符对每个格点上的局域纯退相干进行建模：\n$$\nL_1 = \\sqrt{\\gamma}\\,\\sigma_z^{(1)},\\quad L_2 = \\sqrt{\\gamma}\\,\\sigma_z^{(2)},\n$$\n其中 $\\gamma \\ge 0$ 是退相干速率。初始状态是乘积态 $|\\psi_0\\rangle = |+\\rangle\\otimes|+\\rangle$，其中 $|+\\rangle$ 是 $\\sigma_x$ 的本征值为 $+1$ 的本征矢量，且 $\\rho(0) = |\\psi_0\\rangle\\langle \\psi_0|$。\n\n你的任务是通过两种不同的方法计算开放动力学下随时变的观测量，并对这些小系统验证其一致性：\n\n1. 通过在矢量化算符空间上构建完整的刘维尔超算符，并将其指数化到最终时间 $T$，来计算精确演化。通过按列堆叠的方式将 $\\rho$ 矢量化，并使用恒等式 $\\mathrm{vec}(A X B) = (B^{\\mathsf{T}} \\otimes A)\\,\\mathrm{vec}(X)$ 来获得哈密顿量对易子和耗散项的超算符表示。然后精确计算 $\\rho(T)$ 为 $\\rho(T) = \\mathrm{unvec}\\!\\left(e^{T\\mathcal{L}}\\,\\mathrm{vec}(\\rho(0))\\right)$。\n\n2. 通过用于矩阵乘积算符 (MPOs) 的二阶 Suzuki–Trotter 时演块消减 (TEBD) 方案计算近似值。使用大小为 $\\Delta t$ 的 Trotter 步长，并根据对称二阶方案，将每个格点耗散子的局域通道与两格点哈密顿量生成元组合起来。在这个 $N=2$ 的系统上，此 TEBD 简化为每一步依次应用格点上的耗散超算符和两格点哈密顿量超算符。重复 $N_{\\text{steps}} = T/\\Delta t$ 步来近似 $\\rho(T)$。\n\n对于精确演化和 TEBD 演化，计算在最终时间 $T$ 的三个观测量：\n- $m_x^{(1)}(T) = \\mathrm{Tr}\\left(\\rho(T)\\,\\sigma_x^{(1)}\\right)$,\n- $m_x^{(2)}(T) = \\mathrm{Tr}\\left(\\rho(T)\\,\\sigma_x^{(2)}\\right)$,\n- $C_{xx}(T) = \\mathrm{Tr}\\left(\\rho(T)\\,\\sigma_x^{(1)}\\sigma_x^{(2)}\\right)$。\n\n对于每个测试用例，返回在时间 $T$ 时，这三个观测量在精确值和 TEBD 值之间的最大绝对差：\n$$\n\\epsilon_{\\max} = \\max\\left(\\left|m_x^{(1)}\\!-\\!m_{x,\\text{TEBD}}^{(1)}\\right|, \\left|m_x^{(2)}\\!-\\!m_{x,\\text{TEBD}}^{(2)}\\right|, \\left|C_{xx}\\!-\\!C_{xx,\\text{TEBD}}\\right|\\right).\n$$\n\n本问题中所有时间均采用任意单位，不涉及角度单位。无需使用百分比。\n\n实现一个单一程序，对以下旨在检验不同机制的测试套件执行这些计算：\n- 情况 1（一般相互作用的开放动力学）：$J=0.5$, $\\gamma=0.1$, $T=1.0$, $\\Delta t=0.01$。\n- 情况 2（纯幺正极限）：$J=0.5$, $\\gamma=0.0$, $T=1.0$, $\\Delta t=0.01$。\n- 情况 3（具有对易局域通道的纯耗散极限）：$J=0.0$, $\\gamma=0.2$, $T=1.0$, $\\Delta t=0.02$。\n- 情况 4（更强的耦合和耗散，更短的时间）：$J=1.2$, $\\gamma=0.8$, $T=0.5$, $\\Delta t=0.005$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是对应情况（按上述顺序列出）的浮点数 $\\epsilon_{\\max}$。程序必须是自包含的，除了打印最后一行外不执行任何输入/输出，并对超算符作用一致地使用按列堆叠矢量化。",
            "solution": "该问题要求使用两种不同的方法计算一个双格点开放量子自旋系统随时变的观测量：一种是通过完整的刘维尔超算符进行精确演化，另一种是使用二阶 Suzuki-Trotter 分解进行近似演化。目标是量化近似的误差。该问题具有坚实的科学基础、自成体系且算法精确。\n\n系统密度算符 $\\rho(t)$ 的时间演化由 Lindblad 主方程决定：\n$$\n\\frac{d\\rho(t)}{dt} = \\mathcal{L}(\\rho(t)) = -i[H,\\rho(t)] + \\sum_{k} \\mathcal{D}[L_k](\\rho(t))\n$$\n其中 $\\mathcal{L}$ 是刘维尔超算符，$H$ 是系统哈密顿量，$\\mathcal{D}[L_k](\\rho) = L_k \\rho(t) L_k^\\dagger - \\frac{1}{2}\\{L_k^\\dagger L_k, \\rho(t)\\}$ 是跳跃算符 $L_k$ 的耗散子。\n\n该系统是一个具有 $N=2$ 个格点的自旋-$\\frac{1}{2}$ 链，因此总希尔伯特空间维度为 $d^N = 2^2 = 4$。哈密顿量是最近邻 XY 相互作用：\n$$\nH = J\\left(\\sigma_x^{(1)}\\sigma_x^{(2)} + \\sigma_y^{(1)}\\sigma_y^{(2)}\\right)\n$$\n其中 $\\sigma_a^{(i)}$ 是作用在格点 $i$ 上的泡利-$\\alpha$ 矩阵。耗散过程是每个格点上的局域退相干，由跳跃算符描述：\n$$\nL_1 = \\sqrt{\\gamma}\\,\\sigma_z^{(1)}, \\quad L_2 = \\sqrt{\\gamma}\\,\\sigma_z^{(2)}\n$$\n初始状态是一个乘积态 $\\rho(0) = |\\psi_0\\rangle\\langle \\psi_0|$，其中 $|\\psi_0\\rangle = |+\\rangle \\otimes |+\\rangle$，$|+\\rangle$ 是 $\\sigma_x$ 本征值为 $+1$ 的本征矢量。\n\n为了数值求解动力学，我们将主方程从一个算符方程转换为一个标准的向量线性常微分方程。这是通过将密度算符矢量化来实现的。我们将 $D \\times D$ 的密度矩阵 $\\rho$（其中 $D=4$）表示为一个 $D^2=16$ 维的列向量 $\\mathrm{vec}(\\rho)$，方法是将其各列堆叠起来。刘维尔算符 $\\mathcal{L}$ 于是变成一个 $D^2 \\times D^2$ 的矩阵。利用恒等式 $\\mathrm{vec}(A X B) = (B^{\\mathsf{T}} \\otimes A)\\,\\mathrm{vec}(X)$，可以推导出刘维尔算符各分量的矩阵表示。\n\n哈密顿量部分 $\\mathcal{L}_H(\\rho) = -i(H\\rho - \\rho H)$ 变为超算符：\n$$\n\\mathcal{L}_H = -i(I \\otimes H - H^T \\otimes I)\n$$\n其中 $I$ 是 $D \\times D$ 单位矩阵，$\\otimes$ 是克罗内克积，而 $H$ 是实数矩阵，因此 $H^T = H^*$。\n\n对于单个跳跃算符 $L_k$ 的耗散部分 $\\mathcal{L}_{D_k}(\\rho) = L_k\\rho L_k^\\dagger - \\frac{1}{2}(L_k^\\dagger L_k \\rho + \\rho L_k^\\dagger L_k)$，变为超算符：\n$$\n\\mathcal{L}_{D_k} = (L_k^* \\otimes L_k) - \\frac{1}{2}\\left(I \\otimes (L_k^\\dagger L_k) + (L_k^\\dagger L_k)^T \\otimes I\\right)\n$$\n总刘维尔超算符是这些部分之和：$\\mathcal{L} = \\mathcal{L}_H + \\mathcal{L}_{D_1} + \\mathcal{L}_{D_2}$。\n\n**方法 1：精确演化**\n利用 $\\mathcal{L}$ 的矩阵形式，主方程变为 $\\frac{d}{dt}\\mathrm{vec}(\\rho(t)) = \\mathcal{L}\\,\\mathrm{vec}(\\rho(t))$。对于不依赖于时间的刘维尔算符，其解为：\n$$\n\\mathrm{vec}(\\rho(T)) = e^{T\\mathcal{L}}\\,\\mathrm{vec}(\\rho(0))\n$$\n具体步骤是构建 $16 \\times 16$ 的矩阵 $\\mathcal{L}$，使用标准的数值算法（如 `scipy.linalg.expm`）计算其矩阵指数，并将其应用于矢量化的初始状态。然后将得到的向量反矢量化，变回一个 $4 \\times 4$ 的密度矩阵 $\\rho(T)$。\n\n**方法 2：二阶 Suzuki-Trotter 近似**\n此方法通过将整个演化分解为多个小的时间步长 $\\Delta t$ 来近似。刘维尔算符被分解为两个非对易部分：哈密顿量部分 $\\mathcal{L}_H$ 和总耗散部分 $\\mathcal{L}_D = \\mathcal{L}_{D_1} + \\mathcal{L}_{D_2}$。一个对称的二阶 Suzuki-Trotter 分解将单步演化近似为：\n$$\ne^{\\Delta t \\mathcal{L}} = e^{\\Delta t (\\mathcal{L}_H + \\mathcal{L}_D)} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{L}_D} e^{\\Delta t \\mathcal{L}_H} e^{\\frac{\\Delta t}{2}\\mathcal{L}_D}\n$$\n这种近似的局域误差为 $(\\Delta t)^3$ 阶。为了达到最终时间 $T$，此步骤被重复 $N_{\\text{steps}} = T/\\Delta t$ 次。总演化近似为：\n$$\n\\mathrm{vec}(\\rho(T)) \\approx \\left( e^{\\frac{\\Delta t}{2}\\mathcal{L}_D} e^{\\Delta t \\mathcalL_H} e^{\\frac{\\Delta t}{2}\\mathcal{L}_D} \\right)^{N_{\\text{steps}}} \\mathrm{vec}(\\rho(0))\n$$\n实现上需要分别构建 $\\mathcal{L}_H$ 和 $\\mathcal{L}_D$，计算它们在相应时间间隔上的矩阵指数，并在一个循环中按顺序应用它们。\n\n**观测量和误差计算**\n从两种方法得到最终密度矩阵 $\\rho(T)$ 后，我们计算三个观测量的期望值：\n- $m_x^{(1)}(T) = \\mathrm{Tr}\\left(\\rho(T)\\,\\sigma_x^{(1)}\\right)$\n- $m_x^{(2)}(T) = \\mathrm{Tr}\\left(\\rho(T)\\,\\sigma_x^{(2)}\\right)$\n- $C_{xx}(T) = \\mathrm{Tr}\\left(\\rho(T)\\,\\sigma_x^{(1)}\\sigma_x^{(2)}\\right)$\n\nTrotter 近似的误差由精确方法和近似方法得到的值之间的最大绝对差来量化：\n$$\n\\epsilon_{\\max} = \\max\\left(\\left|m_x^{(1)}_{\\text{exact}} - m_{x,\\text{TEBD}}^{(1)}\\right|, \\left|m_x^{(2)}_{\\text{exact}} - m_{x,\\text{TEBD}}^{(2)}\\right|, \\left|C_{xx,\\text{exact}} - C_{xx,\\text{TEBD}}\\right|\\right)\n$$\n提供的 Python 代码为每个指定的测试用例实现了这整个过程。它构建了必要的算符和超算符，执行了两种演化，计算了观测量，并计算了 $\\epsilon_{\\max}$。在哈密顿量和刘维尔算符的耗散部分对易的情况下（即纯幺正演化或纯耗散演化），Trotter 误差 $\\epsilon_{\\max}$ 预计为零，直至机器浮点精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the open quantum system problem for the given test cases.\n    It compares an exact evolution with a Suzuki-Trotter approximation.\n    \"\"\"\n    \n    # Pauli matrices and identity for a single spin-1/2 site\n    I_1 = np.eye(2, dtype=complex)\n    sx_1 = np.array([[0, 1], [1, 0]], dtype=complex)\n    sy_1 = np.array([[0, -1j], [1j, 0]], dtype=complex)\n    sz_1 = np.array([[1, 0], [0, -1]], dtype=complex)\n\n    # Two-site operators using Kronecker product\n    I = np.kron(I_1, I_1)\n    sx1 = np.kron(sx_1, I_1)\n    sx2 = np.kron(I_1, sx_1)\n    sy1 = np.kron(sy_1, I_1)\n    sy2 = np.kron(I_1, sy_1)\n    sz1 = np.kron(sz_1, I_1)\n    sz2 = np.kron(I_1, sz_1)\n\n    # Observables\n    obs_mx1 = sx1\n    obs_mx2 = sx2\n    obs_cxx = np.kron(sx_1, sx_1)\n    observables = [obs_mx1, obs_mx2, obs_cxx]\n\n    # Initial state |+>|+>\n    plus_state = (1/np.sqrt(2)) * np.array([1, 1], dtype=complex)\n    psi0 = np.kron(plus_state, plus_state)\n    rho0 = np.outer(psi0, psi0.conj())\n    rho0_vec = rho0.flatten('F') # Column-stacking vectorization\n\n    d_sq = I.shape[0]**2\n    Id_sq = np.eye(d_sq, dtype=complex)\n    \n    def build_liouvillian_part(H, jump_ops):\n        \"\"\"\n        Constructs parts of the Liouvillian superoperator.\n        \"\"\"\n        dim = H.shape[0]\n        Id = np.eye(dim, dtype=complex)\n        \n        # Coherent part\n        L_H = -1j * (np.kron(Id, H) - np.kron(H.T, Id))\n        \n        # Dissipative part\n        L_D = np.zeros((dim**2, dim**2), dtype=complex)\n        for Lk in jump_ops:\n            Lk_dag = Lk.conj().T\n            Lk_dag_Lk = Lk_dag @ Lk\n            L_D += np.kron(Lk.conj(), Lk)\n            L_D -= 0.5 * (np.kron(Id, Lk_dag_Lk) + np.kron(Lk_dag_Lk.T, Id))\n            \n        return L_H, L_D\n\n    def evolve_exact(L_super, rho0_vec, T):\n        \"\"\"\n        Evolves the state using the exact Liouvillian exponential.\n        \"\"\"\n        U_super = expm(T * L_super)\n        rhoT_vec = U_super @ rho0_vec\n        return rhoT_vec.reshape((I.shape[0], I.shape[0]), order='F')\n\n    def evolve_trotter(L_H_super, L_D_super, rho0_vec, T, dt):\n        \"\"\"\n        Evolves the state using a 2nd-order Suzuki-Trotter decomposition.\n        \"\"\"\n        n_steps = int(round(T / dt))\n        \n        # Trotter step operators\n        U_H_step = expm(dt * L_H_super)\n        U_D_half_step = expm(0.5 * dt * L_D_super)\n        \n        U_trotter_step = U_D_half_step @ U_H_step @ U_D_half_step\n        \n        rho_vec = rho0_vec.copy()\n        for _ in range(n_steps):\n            rho_vec = U_trotter_step @ rho_vec\n            \n        return rho_vec.reshape((I.shape[0], I.shape[0]), order='F')\n\n    test_cases = [\n        # (J, gamma, T, dt)\n        (0.5, 0.1, 1.0, 0.01),\n        (0.5, 0.0, 1.0, 0.01),\n        (0.0, 0.2, 1.0, 0.02),\n        (1.2, 0.8, 0.5, 0.005),\n    ]\n\n    results = []\n    \n    for J, gamma, T, dt in test_cases:\n        # Construct system-specific Hamiltonian and jump operators\n        H = J * (np.kron(sx_1, sx_1) + np.kron(sy_1, sy_1))\n        L1 = np.sqrt(gamma) * sz1\n        L2 = np.sqrt(gamma) * sz2\n        jump_ops = [L1, L2]\n\n        # Build Liouvillian parts\n        L_H_super, L_D_super = build_liouvillian_part(H, jump_ops)\n        L_super = L_H_super + L_D_super\n\n        # --- Method 1: Exact Evolution ---\n        rhoT_exact = evolve_exact(L_super, rho0_vec, T)\n        vals_exact = [np.real(np.trace(rhoT_exact @ obs)) for obs in observables]\n\n        # --- Method 2: Trotter Evolution ---\n        rhoT_tebd = evolve_trotter(L_H_super, L_D_super, rho0_vec, T, dt)\n        vals_tebd = [np.real(np.trace(rhoT_tebd @ obs)) for obs in observables]\n\n        # --- Comparison ---\n        errors = np.abs(np.array(vals_exact) - np.array(vals_tebd))\n        epsilon_max = np.max(errors)\n        results.append(epsilon_max)\n\n    # Print the final result in the specified format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}