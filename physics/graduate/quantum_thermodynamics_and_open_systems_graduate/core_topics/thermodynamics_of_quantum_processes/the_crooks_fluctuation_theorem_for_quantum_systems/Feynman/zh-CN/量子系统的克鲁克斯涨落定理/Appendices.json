{
    "hands_on_practices": [
        {
            "introduction": "我们从一个孤立单量子比特的基础案例开始。本练习将指导您使用两点测量 (TPM) 方案，对克鲁克斯涨落定理进行解析推导和数值验证。通过为一个简单的两能级系统实现正向和反向协议，您将对其中的关键要素——吉布斯态、幺正演化、投影测量和量子功的定义——获得具体的理解。这个实践是掌握量子涨落定理核心逻辑的基石 。",
            "id": "3782357",
            "problem": "考虑一个有限维量子系统，该系统经历一个驱动协议，其中系统哈密顿量在一段时间内从初始哈密顿量 $H_0$ 变为最终哈密顿量 $H_1$，这段时间由一个有效幺正算符 $U$ 表示。假设系统在协议期间是孤立的，并且初始状态是相对于初始哈密顿量的热平衡态。两点测量（TPM）方案通过在协议开始和结束时进行能量的投影测量来定义量子功。在微观可逆性下，存在一个反向协议，通过一个与 $U$ 经时间反演对称性相关的幺正算符 $U_B$，将系统从 $H_1$ 驱动到 $H_0$。\n\n从基本定义出发：Gibbs 态 $\\rho = e^{-\\beta H}/Z$（其中 $Z = \\operatorname{Tr}[e^{-\\beta H}]$），能量的投影测量，孤立系统的幺正演化，以及时间反演不变性下的微观可逆性形式。仅使用这些基础，推导在时间反演不变驱动的 TPM 方案中，连接前向功分布和后向功分布的关系。然后实现一个程序，对于一组具体实例，数值上构建 TPM 的前向和后向功分布，并验证所推导的关系在指定的数值容差内成立。\n\n协议规范和计算要求：\n- 希尔伯特空间是二维的（一个量子比特），具有泡利算符 $\\sigma_x$、$\\sigma_y$ 和 $\\sigma_z$。\n- 能量和逆温度是无量纲的，普朗克常数约化值 $\\hbar$ 设为 $1$。\n- 前向协议包括：\n  1. 通过在逆温度为 $\\beta$ 的 Gibbs 态上对 $H_0$ 进行投影测量来采样初始能量。\n  2. 在幺正算符 $U$ 下演化。\n  3. 通过对 $H_1$ 进行投影测量来测量能量。\n- 反向协议包括：\n  1. 通过在相同逆温度 $\\beta$ 下的 Gibbs 态上对 $H_1$ 进行投影测量来采样初始能量。\n  2. 在满足时间反演不变性的幺正算符 $U_B$ 下演化（对于此二能级系统，取 $U_B = U^\\dagger$）。\n  3. 通过对 $H_0$ 进行投影测量来测量能量。\n- 在 TPM 方案中，对于与前向协议相关的一对特定的初始和最终能量结果 $(E_n^0, E_m^1)$，功 $W$ 定义为 $W = E_m^1 - E_n^0$。在反向协议中，相应的功为 $W' = E_n^0 - E_m^1$。\n- 程序必须通过对所有 $(n,m)$ 对求和来数值计算离散的前向功分布，其概率由 $H_0$ 的 Gibbs 权重和在 $U$ 作用下从 $|E_n^0\\rangle$ 到 $|E_m^1\\rangle$ 的跃迁振幅的平方给出。同样地，使用 $H_1$ 的 Gibbs 权重和在 $U^\\dagger$ 作用下的跃迁振幅计算后向功分布。\n- 程序必须使用推导出的前向和后向功分布之间的关系以及从 $Z_0 = \\operatorname{Tr}[e^{-\\beta H_0}]$ 和 $Z_1 = \\operatorname{Tr}[e^{-\\beta H_1}]$ 计算出的自由能差 $\\Delta F$，评估在所有实现的离散功值上，经验比率与理论预测之间的最大绝对偏差。\n\n角度单位：\n- 为哈密顿量轴和旋转幺正算符指定的所有角度都必须以弧度为单位进行解释。\n\n测试套件：\n实现并评估以下三个测试用例。对每个案例，如下定义 $H_0$、$H_1$、$U$ 和 $\\beta$。使用 $\\sigma_x = \\begin{pmatrix}0 & 1\\\\ 1 & 0\\end{pmatrix}$，$\\sigma_y = \\begin{pmatrix}0 & -i\\\\ i & 0\\end{pmatrix}$ 和 $\\sigma_z = \\begin{pmatrix}1 & 0\\\\ 0 & -1\\end{pmatrix}$。令绕 $y$ 轴的旋转为 $U = e^{-i \\theta \\sigma_y / 2} = \\cos(\\theta/2) I - i \\sin(\\theta/2) \\sigma_y$。\n- 案例1（一般非对易，中等温度）：\n  - $H_0 = \\frac{\\omega_0}{2} \\sigma_z$，其中 $\\omega_0 = 1.0$。\n  - $H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$，其中 $\\omega_1 = 0.8$ 且 $\\phi = \\pi/3$。\n  - $U = e^{-i \\theta \\sigma_y / 2}$，其中 $\\theta = 0.4$。\n  - $\\beta = 1.2$。\n- 案例2（对易，单位驱动，低温）：\n  - $H_0 = H_1 = \\frac{\\omega}{2} \\sigma_z$，其中 $\\omega = 2.0$。\n  - $U = I$。\n  - $\\beta = 3.5$。\n- 案例3（一般非对易，近乎无限温度边界）：\n  - $H_0 = \\frac{\\omega_0}{2} \\sigma_z$，其中 $\\omega_0 = 1.2$。\n  - $H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$，其中 $\\omega_1 = 2.0$ 且 $\\phi = 0.7$。\n  - $U = e^{-i \\theta \\sigma_y / 2}$，其中 $\\theta = 1.0$。\n  - $\\beta = 10^{-8}$。\n\n答案规范：\n- 对每个测试用例，计算前向与后向功分布的经验比率（在匹配的功值处评估）与从第一性原理推导出的理论预测之间的最大绝对偏差。然后将此偏差与 $10^{-9}$ 的容差进行比较，并返回一个布尔值，指示推导的关系是否在容差范围内成立。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与三个测试用例的顺序一致（例如，\"[True,True,False]\"）。",
            "solution": "该问题要求两项主要交付成果：首先，在时间反演对称性的特定条件下，推导两点测量（TPM）方案中前向和后向功分布之间的关系；其次，进行数值实现，以验证该推导关系在一组给定的量子协议下成立。\n\n首先，我们必须验证问题陈述。\n\n### 步骤1：提取已知条件\n- **系统**：一个有限维量子系统，具体为一个二维希尔伯特空间（量子比特）。\n- **初始状态（前向）**：热 Gibbs 态 $\\rho_0 = e^{-\\beta H_0}/Z_0$，逆温度为 $\\beta$，其中 $Z_0 = \\operatorname{Tr}[e^{-\\beta H_0}]$。\n- **前向协议**：\n    1.  对 $H_0$ 进行投影能量测量。结果为 $E_n^0$。\n    2.  幺正演化 $U$。\n    3.  对 $H_1$ 进行投影能量测量。结果为 $E_m^1$。\n- **功（前向）**：$W = E_m^1 - E_n^0$。\n- **初始状态（后向）**：热 Gibbs 态 $\\rho_1 = e^{-\\beta H_1}/Z_1$，逆温度同为 $\\beta$，其中 $Z_1 = \\operatorname{Tr}[e^{-\\beta H_1}]$。\n- **后向协议**：\n    1.  对 $H_1$ 进行投影能量测量。结果为 $E_m^1$。\n    2.  幺正演化 $U_B$。\n    3.  对 $H_0$ 进行投影能量测量。结果为 $E_n^0$。\n- **微观可逆性条件**：后向幺正算符被指定为 $U_B = U^\\dagger$。\n- **功（后向）**：$W' = E_n^0 - E_m^1$。\n- **数值常量与定义**：$\\hbar = 1$。泡利矩阵 $\\sigma_x = \\begin{pmatrix}0 & 1\\\\ 1 & 0\\end{pmatrix}$，$\\sigma_y = \\begin{pmatrix}0 & -i\\\\ i & 0\\end{pmatrix}$，$\\sigma_z = \\begin{pmatrix}1 & 0\\\\ 0 & -1\\end{pmatrix}$。旋转幺正算符 $U = e^{-i \\theta \\sigma_y / 2} = \\cos(\\theta/2) I - i \\sin(\\theta/2) \\sigma_y$。\n- **测试用例**：\n    - **案例1**：$H_0 = \\frac{\\omega_0}{2} \\sigma_z$，其中 $\\omega_0 = 1.0$。$H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$，其中 $\\omega_1 = 0.8$，$\\phi = \\pi/3$。$U$ 的 $\\theta = 0.4$。$\\beta = 1.2$。\n    - **案例2**：$H_0 = H_1 = \\frac{\\omega}{2} \\sigma_z$，其中 $\\omega = 2.0$。$U = I$。$\\beta = 3.5$。\n    - **案例3**：$H_0 = \\frac{\\omega_0}{2} \\sigma_z$，其中 $\\omega_0 = 1.2$。$H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$，其中 $\\omega_1 = 2.0$，$\\phi = 0.7$。$U$ 的 $\\theta = 1.0$。$\\beta = 10^{-8}$。\n- **验证任务**：计算分布比率的经验值 $P_F(W)/P_B(-W)$ 与理论预测之间的最大绝对偏差，并检查其是否在 $10^{-9}$ 的容差范围内。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学基础**：该问题基于量子统计力学的基本原理，包括 Gibbs 正则系综、投影测量（von Neumann 假设）和幺正时间演化（Schrödinger 方程）。TPM 方案是量子功的标准定义。待推导的关系式，即 Crooks 涨落定理，是非平衡统计力学的基石。假设 $U_B = U^\\dagger$ 是定义反向协议的一个具体、一致的选择，使得问题自洽。\n- **良态问题**：所有必要的参数、哈密顿量、演化算符和逆温度都为每个测试用例明确定义。目标清晰：推导一个特定的物理关系，然后根据精确的指令实现数值验证。存在唯一且有意义的解。\n- **客观性**：问题使用物理学和数学中的正式、无歧义的语言陈述。没有主观因素。\n\n### 步骤3：结论与行动\n该问题是有效的，因为它具有科学基础、是良态问题、客观且自洽。我将继续进行解答。\n\n### 涨落关系的推导\n\n目标是推导前向功分布 $P_F(W)$ 和后向功分布 $P_B(W')$ 之间的关系。\n\n**1. 前向功分布，$P_F(W)$**\n\n前向协议始于系统与初始哈密顿量 $H_0$ 在逆温度 $\\beta$ 下处于热平衡。密度矩阵是正则 Gibbs 态：\n$$\n\\rho_0 = \\frac{e^{-\\beta H_0}}{Z_0}, \\quad Z_0 = \\operatorname{Tr}[e^{-\\beta H_0}]\n$$\n设 $\\{|E_n^0\\rangle\\}$ 为 $H_0$ 的正交归一能量本征基，使得 $H_0|E_n^0\\rangle = E_n^0|E_n^0\\rangle$。TPM 方案的第一步是能量的投影测量。获得结果 $E_n^0$ 的概率由 Born 法则给出：\n$$\np(E_n^0) = \\langle E_n^0 | \\rho_0 | E_n^0 \\rangle = \\langle E_n^0 | \\frac{e^{-\\beta H_0}}{Z_0} | E_n^0 \\rangle = \\frac{e^{-\\beta E_n^0}}{Z_0}\n$$\n此次测量后，系统状态塌缩到 $|E_n^0\\rangle$。然后，它在幺正算符 $U$ 下演化到状态 $U|E_n^0\\rangle$。第二步是关于最终哈密顿量 $H_1$ 的能量投影测量。设 $\\{|E_m^1\\rangle\\}$ 为 $H_1$ 的本征基，满足 $H_1|E_m^1\\rangle = E_m^1|E_m^1\\rangle$。给定初始状态为 $|E_n^0\\rangle$，测量到 $E_m^1$ 的条件概率为：\n$$\np(E_m^1 | E_n^0) = |\\langle E_m^1 | U | E_n^0 \\rangle|^2\n$$\n观测到结果序列 $(E_n^0, E_m^1)$ 的联合概率是这些概率的乘积：\n$$\np_F(n,m) = p(E_m^1 | E_n^0) p(E_n^0) = |\\langle E_m^1 | U | E_n^0 \\rangle|^2 \\frac{e^{-\\beta E_n^0}}{Z_0}\n$$\n对于这个特定轨迹，对系统做的功定义为 $W = E_m^1 - E_n^0$。功的概率分布 $P_F(W)$ 是所有产生相同功值的轨迹的概率之和：\n$$\nP_F(W) = \\sum_{n,m} \\delta(W - (E_m^1 - E_n^0)) p_F(n,m)\n$$\n\n**2. 后向功分布，$P_B(W')$**\n\n后向协议始于系统与最终哈密顿量 $H_1$ 在相同逆温度 $\\beta$ 下处于热平衡。初始状态为：\n$$\n\\rho_1 = \\frac{e^{-\\beta H_1}}{Z_1}, \\quad Z_1 = \\operatorname{Tr}[e^{-\\beta H_1}]\n$$\n对 $H_1$ 进行能量测量得到结果 $E_m^1$ 的概率为：\n$$\np(E_m^1) = \\langle E_m^1 | \\rho_1 | E_m^1 \\rangle = \\frac{e^{-\\beta E_m^1}}{Z_1}\n$$\n系统状态塌缩到 $|E_m^1\\rangle$，并在后向幺正算符 $U_B = U^\\dagger$ 下演化。对 $H_0$ 进行最终能量测量得到结果 $E_n^0$ 的条件概率为：\n$$\np_B(E_n^0 | E_m^1) = |\\langle E_n^0 | U_B | E_m^1 \\rangle|^2 = |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2\n$$\n后向轨迹的联合概率为：\n$$\np_B(m,n) = p_B(E_n^0 | E_m^1) p(E_m^1) = |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2 \\frac{e^{-\\beta E_m^1}}{Z_1}\n$$\n后向过程的功定义为 $W' = E_n^0 - E_m^1$。后向功分布为：\n$$\nP_B(W') = \\sum_{n,m} \\delta(W' - (E_n^0 - E_m^1)) p_B(m,n)\n$$\n\n**3. Crooks 涨落关系**\n\n我们现在连接 $P_F(W)$ 和 $P_B(W')$。考虑一个特定的前向功值 $W$。我们考察在后向过程中获得功为 $-W$ 的概率。注意 $W' = E_n^0 - E_m^1 = -(E_m^1 - E_n^0) = -W$。\n$$\nP_F(W) = \\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 \\frac{e^{-\\beta E_n^0}}{Z_0}\n$$\n$$\nP_B(-W) = \\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2 \\frac{e^{-\\beta E_m^1}}{Z_1}\n$$\n两个表达式的求和条件是相同的。矩阵伴随的一个关键性质是 $|\\langle v_1 | A | v_2 \\rangle|^2 = |\\langle v_2 | A^\\dagger | v_1 \\rangle|^2$。将其应用于跃迁概率：\n$$\n|\\langle E_m^1 | U | E_n^0 \\rangle|^2 = |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2\n$$\n这意味着前向轨迹 $(n \\to m)$ 及其时间反演对应轨迹 $(m \\to n)$ 的量子跃迁概率是相同的。\n让我们考察给定功值 $W$ 时分布的比率：\n$$\n\\frac{P_F(W)}{P_B(-W)} = \\frac{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 \\frac{e^{-\\beta E_n^0}}{Z_0}}{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2 \\frac{e^{-\\beta E_m^1}}{Z_1}}\n$$\n使用跃迁概率的恒等式，我们可以简化为：\n$$\n\\frac{P_F(W)}{P_B(-W)} = \\frac{Z_1}{Z_0} \\frac{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 e^{-\\beta E_n^0}}{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 e^{-\\beta E_m^1}}\n$$\n我们可以使用功的定义 $W = E_m^1 - E_n^0$ 来重写 $e^{-\\beta E_n^0}$：\n$E_n^0 = E_m^1 - W \\implies e^{-\\beta E_n^0} = e^{-\\beta(E_m^1 - W)} = e^{\\beta W} e^{-\\beta E_m^1}$。\n由于 $W$ 对于求和中的所有项都是固定的，我们可以将 $e^{\\beta W}$ 因子提出来：\n$$\n\\frac{P_F(W)}{P_B(-W)} = \\frac{Z_1}{Z_0} \\frac{e^{\\beta W} \\sum_{n,m, ...} |\\langle ... \\rangle|^2 e^{-\\beta E_m^1}}{\\sum_{n,m, ...} |\\langle ... \\rangle|^2 e^{-\\beta E_m^1}} = \\frac{Z_1}{Z_0} e^{\\beta W}\n$$\nHelmholtz 自由能 $F$ 定义为 $F = -k_B T \\ln Z = - (1/\\beta) \\ln Z$。与 $H_1$ 和 $H_0$ 相关的平衡态之间的自由能变化为 $\\Delta F = F_1 - F_0 = -(1/\\beta)(\\ln Z_1 - \\ln Z_0) = -(1/\\beta)\\ln(Z_1/Z_0)$。因此，$Z_1/Z_0 = e^{-\\beta \\Delta F}$。\n将此代入我们的表达式，得到 Crooks 涨落关系：\n$$\n\\frac{P_F(W)}{P_B(-W)} = e^{-\\beta \\Delta F} e^{\\beta W} = e^{\\beta (W - \\Delta F)}\n$$\n这就是要进行数值验证的关系。\n\n### 数值实现计划\n程序将为所提供的二能级系统实现 TPM 方案。对每个测试用例：\n1.  构建初始哈密顿量 $H_0$、最终哈密顿量 $H_1$ 和幺正演化算符 $U$ 的矩阵表示。\n2.  数值对角化 $H_0$ 和 $H_1$，以找到它们各自的本征值（$E_n^0$, $E_m^1$）和本征向量（$|E_n^0\\rangle$, $|E_m^1\\rangle$）。\n3.  计算配分函数 $Z_0$ 和 $Z_1$，以及自由能差 $\\Delta F = -(1/\\beta) \\ln(Z_1/Z_0)$。\n4.  计算离散功分布 $P_F(W)$ 和 $P_B(-W)$。这涉及遍历所有四种可能的跃迁 $(n, m) \\in \\{ (0,0), (0,1), (1,0), (1,1) \\}$，计算功 $W = E_m^1 - E_n^0$ 以及前向和后向协议的相应联合概率，并对任何简并的功值求和概率。\n5.  对于每个唯一的功值 $W$（其中 $P_F(W) > 0$），计算经验比率 $R_{\\text{emp}} = P_F(W)/P_B(-W)$ 和理论比率 $R_{\\text{th}} = e^{\\beta (W - \\Delta F)}$。\n6.  确定在所有观测到的功值中最大的绝对偏差 $|R_{\\text{emp}} - R_{\\text{th}}|$。\n7.  将此最大偏差与指定的容差 $10^{-9}$ 进行比较，以返回一个布尔结果。\n此过程将对所有三个测试用例重复执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and numerically verifying the Crooks fluctuation theorem\n    for three specified quantum protocols.\n    \"\"\"\n\n    # Define Pauli matrices and Identity\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_y = np.array([[0, -1j], [1j, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n    identity = np.eye(2, dtype=complex)\n\n    def verify_crooks_relation(H0, H1, U, beta, tolerance):\n        \"\"\"\n        Numerically verifies the Crooks relation for a given protocol.\n\n        Args:\n            H0 (np.ndarray): Initial Hamiltonian.\n            H1 (np.ndarray): Final Hamiltonian.\n            U (np.ndarray): Unitary evolution operator.\n            beta (float): Inverse temperature.\n            tolerance (float): Numerical tolerance for verification.\n\n        Returns:\n            bool: True if the relation holds within the tolerance, False otherwise.\n        \"\"\"\n        # Step 1: Diagonalize Hamiltonians\n        evals0, evecs0 = np.linalg.eigh(H0)\n        evals1, evecs1 = np.linalg.eigh(H1)\n\n        # Step 2: Calculate partition functions and free energy difference\n        Z0 = np.sum(np.exp(-beta * evals0))\n        Z1 = np.sum(np.exp(-beta * evals1))\n        \n        # Avoid log(0) for edge cases, though not expected here\n        if Z0 == 0 or Z1 == 0:\n            # An unphysical scenario indicating an issue.\n            # For the given problems, Z0 and Z1 are always positive.\n            return False \n\n        delta_F = (-1 / beta) * np.log(Z1 / Z0)\n\n        # Step 3: Compute forward and backward work distributions\n        forward_work_dist = {}\n        backward_work_dist = {}\n        \n        U_dagger = U.conj().T\n\n        for n in range(2):\n            E_n0 = evals0[n]\n            vec_n0 = evecs0[:, n]\n            \n            for m in range(2):\n                E_m1 = evals1[m]\n                vec_m1 = evecs1[:, m]\n\n                # This is the quantum transition probability, identical for forward and back\n                transition_prob = np.abs(vec_m1.conj() @ U @ vec_n0)**2\n                \n                # Forward process\n                work_F = E_m1 - E_n0\n                prob_initial_F = np.exp(-beta * E_n0) / Z0\n                joint_prob_F = prob_initial_F * transition_prob\n                forward_work_dist[work_F] = forward_work_dist.get(work_F, 0) + joint_prob_F\n\n                # Backward process\n                work_B = E_n0 - E_m1 # This is -work_F\n                prob_initial_B = np.exp(-beta * E_m1) / Z1\n                joint_prob_B = prob_initial_B * transition_prob\n                backward_work_dist[work_B] = backward_work_dist.get(work_B, 0) + joint_prob_B\n        \n        # Step 4: Verify the relation for each realized work value\n        max_deviation = 0.0\n        \n        for W, P_F_W in forward_work_dist.items():\n            P_B_negW = backward_work_dist.get(-W, 0.0)\n\n            # The relation is only tested for work values with non-zero probability\n            if P_F_W > 1e-15 and P_B_negW > 1e-15:\n                empirical_ratio = P_F_W / P_B_negW\n                theoretical_ratio = np.exp(beta * (W - delta_F))\n                \n                deviation = np.abs(empirical_ratio - theoretical_ratio)\n                if deviation > max_deviation:\n                    max_deviation = deviation\n        \n        return max_deviation  tolerance\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general noncommuting, moderate temperature\n        {\n            'params': {'omega0': 1.0, 'omega1': 0.8, 'phi': np.pi / 3, 'theta': 0.4, 'beta': 1.2},\n            'H0_func': lambda p: (p['omega0'] / 2) * sigma_z,\n            'H1_func': lambda p: (p['omega1'] / 2) * (np.cos(p['phi']) * sigma_z + np.sin(p['phi']) * sigma_x),\n            'U_func': lambda p: np.cos(p['theta'] / 2) * identity - 1j * np.sin(p['theta'] / 2) * sigma_y\n        },\n        # Case 2: commuting, identity drive, low temperature\n        {\n            'params': {'omega': 2.0, 'beta': 3.5},\n            'H0_func': lambda p: (p['omega'] / 2) * sigma_z,\n            'H1_func': lambda p: (p['omega'] / 2) * sigma_z, # H1 = H0\n            'U_func': lambda p: identity # U = I\n        },\n        # Case 3: general noncommuting, near-infinite temperature boundary\n        {\n            'params': {'omega0': 1.2, 'omega1': 2.0, 'phi': 0.7, 'theta': 1.0, 'beta': 1e-8},\n            'H0_func': lambda p: (p['omega0'] / 2) * sigma_z,\n            'H1_func': lambda p: (p['omega1'] / 2) * (np.cos(p['phi']) * sigma_z + np.sin(p['phi']) * sigma_x),\n            'U_func': lambda p: np.cos(p['theta'] / 2) * identity - 1j * np.sin(p['theta'] / 2) * sigma_y\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        params = case['params']\n        H0 = case['H0_func'](params)\n        H1 = case['H1_func'](params)\n        U = case['U_func'](params)\n        beta = params['beta']\n        \n        is_verified = verify_crooks_relation(H0, H1, U, beta, tolerance)\n        results.append(is_verified)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在单量子比特系统中验证了该定理之后，我们现在在一个更复杂的、相互作用的多体系统中检验其有效性。本练习涉及模拟横向场伊辛自旋链中的一次猝灭过程。您将使用精确对角化来处理更大的希尔伯特空间，从而证明克鲁克斯关系是统计力学的一条普适原理，即使在存在量子关联和纠缠的情况下也同样成立 。",
            "id": "3787400",
            "problem": "考虑一个具有 $N$ 个自旋-$\\frac{1}{2}$ 自由度和开放边界条件的有限量子自旋链。设正向协议为在逆温 $\\beta$ 下，使用双投影测量方案，从初始哈密顿量 $H_{0}$ 突变为末态哈密顿量 $H_{1}$。逆向协议为在相同的逆温 $\\beta$ 下，同样使用双投影测量方案，从 $H_{1}$ 突变为 $H_{0}$。功被定义为末态和初态投影能量测量结果之差。所有量均为无量纲量，单位取约化普朗克常数和玻尔兹曼常数满足 $\\hbar = 1$ 和 $k_{\\mathrm{B}} = 1$。\n\n使用的基本原理和定义：\n- 哈密顿量 $H$ 在逆温 $\\beta$ 下的吉布斯态为 $\\rho = e^{-\\beta H}/Z$，其中 $Z = \\mathrm{Tr}\\left(e^{-\\beta H}\\right)$。\n- 功的双投影测量方案如下进行。对于正向协议：根据 $H_{0}$ 的吉布斯分布抽样一个初始能量结果 $E_{n}^{0}$，将哈密顿量突然变为 $H_{1}$，然后根据玻恩定则从淬火前的本征态抽样一个末态能量结果 $E_{m}^{1}$。实现的功为 $W = E_{m}^{1} - E_{n}^{0}$。逆向协议的定义与此类似，其中 $H_{1}$ 为初始哈密顿量，$H_{0}$ 为淬火后的哈密顿量。\n- 哈密顿量 $H$ 在逆温 $\\beta$ 下的平衡自由能为 $F = -\\tfrac{1}{\\beta}\\ln Z$，其中 $Z$ 如上所述。\n\n模型哈密顿量由横场伊辛形式指定\n$$\nH(J,h) = -J \\sum_{i=1}^{N-1} \\sigma_{z}^{(i)} \\sigma_{z}^{(i+1)} - h \\sum_{i=1}^{N} \\sigma_{x}^{(i)},\n$$\n其中 $\\sigma_{x}^{(i)}$ 和 $\\sigma_{z}^{(i)}$ 是作用于格点 $i$ 的泡利矩阵，$J$ 和 $h$ 是实标量。正向淬火哈密顿量对为 $(H_{0}, H_{1}) = \\left(H(J_{0}, h_{0}), H(J_{1}, h_{1})\\right)$。\n\n任务：\n- 从上述基本定义出发，构建突变淬火协议在逆温 $\\beta$ 下的离散正向功分布 $P_{\\mathrm{F}}(W)$ 和离散逆向功分布 $P_{\\mathrm{R}}(W)$。使用精确对角化方法获得 $H_{0}$ 和 $H_{1}$ 的能量本征值和本征向量，并利用玻恩定则通过淬火前后本征向量的交叠来计算结果概率。\n- 计算 $H_{0}$ 和 $H_{1}$ 的配分函数 $Z_{0}$ 和 $Z_{1}$，以及自由能差 $\\Delta F = F_{1}-F_{0}$。\n- 对于在正向和逆向过程中（逆向过程在 $-W$ 处取值）概率均不为零的功值 $W$ 集合，计算量\n$$\nC(W) = \\ln P_{\\mathrm{F}}(W) - \\ln P_{\\mathrm{R}}(-W) - \\beta\\left(W - \\Delta F\\right).\n$$\n- 通过计算最大绝对偏差来汇总结果\n$$\n\\|C\\|_{\\infty} = \\max_{W} |C(W)|.\n$$\n报告下面每个测试案例的 $\\|C\\|_{\\infty}$。\n\n实现细节与约束：\n- 在计算基中对 $H_{0}$ 和 $H_{1}$ 使用精确对角化以获得本征值和本征向量。通过泡利矩阵的克罗内克积构建 $H(J,h)$。\n- 离散功分布的支持集为形如 $W = E_{m}^{1} - E_{n}^{0}$ 的值。在数值聚合中，将相同 $W$ 值的贡献合并，使用四舍五入到小数点后 $12$ 位以避免浮点碎片化。在评估 $C(W)$ 时，仅使用 $P_{\\mathrm{F}}(W)$ 和 $P_{\\mathrm{R}}(-W)$ 均为严格正值的 $W$。\n- 能量、逆温和功都是无量纲的（不需要物理单位）。\n\n测试套件：\n为以下参数集提供结果，每个参数集指定为一个元组 $(N, J_{0}, h_{0}, J_{1}, h_{1}, \\beta)$:\n- 案例 $1$: $(3, 0.8, 1.0, 0.5, 0.3, 0.9)$\n- 案例 $2$ (对易哈密顿量: $h_{0} = 0$, $h_{1} = 0$): $(3, 0.4, 0.0, -0.7, 0.0, 1.2)$\n- 案例 $3$ (高温): $(4, 0.3, 0.9, 1.1, 0.6, 0.1)$\n- 案例 $4$ (低温): $(2, 1.0, 0.5, 0.2, 1.3, 3.0)$\n- 案例 $5$ (无相互作用自旋，在 $\\sigma_{x}$ 基中对易: $J_{0} = 0$, $J_{1} = 0$): $(3, 0.0, 0.7, 0.0, 1.4, 0.8)$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含按上述案例顺序排列的五个结果，格式为方括号括起来的逗号分隔列表。将每个结果表示为小数点后有 $10$ 位数字的科学记数法浮点数。例如，具有三个占位符结果的输出必须如下所示\n$[1.2345678901e-03,2.3456789012e-04,3.4567890123e-05]$。",
            "solution": "用户希望我验证横场伊辛模型中量子淬火的Crooks涨落定理。这是一个量子统计力学中定义明确的问题。所有提供的定义和参数都是标准的且自洽的。该问题在科学上是合理的、客观的，并且对于给定的系统规模来说计算上是可行的。这是一个有效的数值练习。\n\n### 基于原理的解决方案设计\n\n核心任务是数值验证应用于横场伊辛链的突变淬火协议的Crooks涨落定理。该定理关联了正向过程及其时间反演过程的功分布。对于一个最初处于逆温 $\\beta$ 的热平衡态的系统，经历一个由变化的哈密顿量描述的过程，该定理陈述为：\n$$\n\\frac{P_{\\mathrm{F}}(W)}{P_{\\mathrm{R}}(-W)} = e^{\\beta(W - \\Delta F)}\n$$\n这里，$P_{\\mathrm{F}}(W)$ 是正向过程中功为 $W$ 的概率分布，$P_{\\mathrm{R}}(-W)$ 是逆向过程中功为 $-W$ 的概率分布，$\\Delta F = F_{\\mathrm{final}} - F_{\\mathrm{initial}}$ 是系统平衡自由能的变化。\n\n问题要求计算量\n$$\nC(W) = \\ln P_{\\mathrm{F}}(W) - \\ln P_{\\mathrm{R}}(-W) - \\beta\\left(W - \\Delta F\\right)\n$$\n并报告其最大绝对值 $\\|C\\|_{\\infty} = \\max_W|C(W)|$。根据Crooks定理，我们期望对于所有 $W$，$C(W)$ 恒为零。任何数值计算出的非零值都将归因于浮点精度误差。\n\n计算 $\\|C\\|_{\\infty}$ 的分步过程如下：\n\n1.  **哈密顿量构建**：具有开放边界条件的 $N$ 个自旋链的横场伊辛哈密顿量由以下公式给出：\n    $$\n    H(J,h) = -J \\sum_{i=1}^{N-1} \\sigma_{z}^{(i)} \\sigma_{z}^{(i+1)} - h \\sum_{i=1}^{N} \\sigma_{x}^{(i)}\n    $$\n    其中 $\\sigma_{x}^{(i)}$ 和 $\\sigma_{z}^{(i)}$ 是作用于格点 $i$ 的泡利矩阵。我们在计算基（所有 $\\sigma_z$ 的本征基）中构建初始哈密顿量 $H_0 = H(J_0, h_0)$ 和末态哈密顿量 $H_1 = H(J_1, h_1)$ 的 $2^N \\times 2^N$ 矩阵。这是通过将和中的每一项表示为泡利矩阵和单位矩阵的克罗内克积来实现的，例如 $\\sigma_{z}^{(i)} \\sigma_{z}^{(i+1)} = I^{\\otimes (i-1)} \\otimes \\sigma_z \\otimes \\sigma_z \\otimes I^{\\otimes (N-i-1)}$。\n\n2.  **本征系统确定**：我们对厄米矩阵 $H_0$ 和 $H_1$ 进行精确对角化，以找到它们各自的本征值和本征向量。\n    $$\n    H_0 |E_n^0\\rangle = E_n^0 |E_n^0\\rangle \\quad \\text{其中 } n = 0, \\dots, 2^N-1\n    $$\n    $$\n    H_1 |E_m^1\\rangle = E_m^1 |E_m^1\\rangle \\quad \\text{其中 } m = 0, \\dots, 2^N-1\n    $$\n    这提供了完整的能谱 $\\{E_n^0\\}$、$\\{E_m^1\\}$ 和相应的正交归一本征向量基 $\\{|E_n^0\\rangle\\}$、$\\{|E_m^1\\rangle\\}$。\n\n3.  **自由能计算**：哈密顿量 $H$ 在逆温 $\\beta$ 下的平衡配分函数是 $Z = \\mathrm{Tr}(e^{-\\beta H}) = \\sum_k e^{-\\beta E_k}$。我们计算 $H_0$ 和 $H_1$ 的配分函数 $Z_0$ 和 $Z_1$：\n    $$\n    Z_0 = \\sum_{n} e^{-\\beta E_n^0} \\quad , \\quad Z_1 = \\sum_{m} e^{-\\beta E_m^1}\n    $$\n    然后自由能差为 $\\Delta F = F_1 - F_0 = -\\frac{1}{\\beta}(\\ln Z_1 - \\ln Z_0)$。\n\n4.  **功分布计算**：功分布源于双投影测量（TPM）方案。\n    *   **正向过程 ($H_0 \\to H_1$)**：\n        1.  系统最初与 $H_0$ 处于热平衡。一次能量测量得到本征值 $E_n^0$ 的概率为 $p_n^0 = e^{-\\beta E_n^0}/Z_0$。\n        2.  哈密顿量从 $H_0$ 突然淬火到 $H_1$。系统状态保持为 $|E_n^0\\rangle$。\n        3.  在 $H_1$ 的本征基中进行第二次能量测量。测得 $E_m^1$ 的概率由玻恩定则给出：$p(m|n) = |\\langle E_m^1 | E_n^0 \\rangle|^2$。\n        此轨迹的功为 $W = E_m^1 - E_n^0$。一个功值 $W$ 的总概率是通过对所有产生该功值的轨迹的概率求和得到的：\n        $$\n        P_{\\mathrm{F}}(W) = \\sum_{n,m} \\delta(W - (E_m^1 - E_n^0)) \\, |\\langle E_m^1 | E_n^0 \\rangle|^2 \\, \\frac{e^{-\\beta E_n^0}}{Z_0}\n        $$\n    *   **逆向过程 ($H_1 \\to H_0$)**：逻辑相同，只是 $H_0$ 和 $H_1$ 的角色互换。功为 $W = E_n^0 - E_m^1$。\n        $$\n        P_{\\mathrm{R}}(W) = \\sum_{n,m} \\delta(W - (E_n^0 - E_m^1)) \\, |\\langle E_n^0 | E_m^1 \\rangle|^2 \\, \\frac{e^{-\\beta E_m^1}}{Z_1}\n        $$\n    在数值上，我们遍历所有初始 ($n$) 和末态 ($m$) 本征态对，计算功 $W$ 和相应的概率，并将这些概率聚合到一个类似字典的数据结构中，其键是功值（四舍五入到小数点后12位以处理浮点不精确性）。\n\n5.  **偏差计算**：我们确定功值 $W$ 的集合，使得 $P_{\\mathrm{F}}(W)$ 和 $P_{\\mathrm{R}}(-W)$ 均不为零。对于每个这样的 $W$，我们计算 $C(W)$ 并找到其绝对值的最大值 $\\|C\\|_{\\infty}$。这个最终值是每个测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the problem by numerically verifying the Crooks fluctuation theorem\n    for a quantum quench in the transverse-field Ising model.\n    \"\"\"\n    \n    def build_hamiltonian(N, J, h):\n        \"\"\"\n        Constructs the transverse-field Ising model Hamiltonian matrix for a chain of N spins.\n        \"\"\"\n        dim = 2**N\n        H = np.zeros((dim, dim), dtype=np.complex128)\n\n        sigma_x = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n        sigma_z = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n        Id = np.eye(2, dtype=np.complex128)\n\n        # Interaction term: -J * sum_{i=1}^{N-1} sigma_z^(i) * sigma_z^(i+1)\n        if J != 0:\n            for i in range(N - 1):\n                op_list = [Id] * N\n                op_list[i] = sigma_z\n                op_list[i+1] = sigma_z\n                term = op_list[0]\n                for k in range(1, N):\n                    term = np.kron(term, op_list[k])\n                H -= J * term\n\n        # Field term: -h * sum_{i=1}^{N} sigma_x^(i)\n        if h != 0:\n            for i in range(N):\n                op_list = [Id] * N\n                op_list[i] = sigma_x\n                term = op_list[0]\n                for k in range(1, N):\n                    term = np.kron(term, op_list[k])\n                H -= h * term\n                \n        return H\n\n    def get_work_distribution(E_initial, V_initial, E_final, V_final, beta, Z_initial, round_digits=12):\n        \"\"\"\n        Calculates the discrete work distribution for a sudden quench process.\n        \"\"\"\n        work_dist = defaultdict(float)\n        dim = len(E_initial)\n        \n        overlap_matrix_sq = np.abs(V_final.conj().T @ V_initial)**2\n        \n        p_initial_dist = np.exp(-beta * E_initial) / Z_initial\n        \n        for n in range(dim): # initial state index\n            p_initial = p_initial_dist[n]\n            for m in range(dim): # final state index\n                transition_prob = overlap_matrix_sq[m, n]\n                \n                work = E_final[m] - E_initial[n]\n                work_rounded = round(work, round_digits)\n                \n                joint_prob = p_initial * transition_prob\n                work_dist[work_rounded] += joint_prob\n                \n        return dict(work_dist)\n\n    def calculate_max_deviation(params):\n        N, J0, h0, J1, h1, beta = params\n\n        H0 = build_hamiltonian(N, J0, h0)\n        H1 = build_hamiltonian(N, J1, h1)\n\n        evals0, evecs0 = np.linalg.eigh(H0)\n        evals1, evecs1 = np.linalg.eigh(H1)\n\n        Z0 = np.sum(np.exp(-beta * evals0))\n        Z1 = np.sum(np.exp(-beta * evals1))\n        \n        if Z0 == 0 or Z1 == 0: return np.nan\n\n        delta_F = (-1 / beta) * (np.log(Z1) - np.log(Z0))\n\n        pf_w = get_work_distribution(evals0, evecs0, evals1, evecs1, beta, Z0)\n        pr_w = get_work_distribution(evals1, evecs1, evals0, evecs0, beta, Z1)\n\n        max_c = 0.0\n        \n        # Round keys for pr_w to match the precision of pf_w keys\n        pr_w_rounded_keys = {round(k, 12): v for k, v in pr_w.items()}\n        \n        for w, prob_f in pf_w.items():\n            prob_r_neg_w = pr_w_rounded_keys.get(-w, 0.0)\n            \n            if prob_f > 1e-15 and prob_r_neg_w > 1e-15:\n                c_w = np.log(prob_f) - np.log(prob_r_neg_w) - beta * (w - delta_F)\n                if abs(c_w) > max_c:\n                    max_c = abs(c_w)\n        \n        return max_c\n        \n    test_cases = [\n        (3, 0.8, 1.0, 0.5, 0.3, 0.9),\n        (3, 0.4, 0.0, -0.7, 0.0, 1.2),\n        (4, 0.3, 0.9, 1.1, 0.6, 0.1),\n        (2, 1.0, 0.5, 0.2, 1.3, 3.0),\n        (3, 0.0, 0.7, 0.0, 1.4, 0.8)\n    ]\n    \n    results = [calculate_max_deviation(case) for case in test_cases]\n    \n    formatted_results = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的量子系统永远不会是完全孤立的。这最后一个练习将探索一个更真实的情景：一个受驱动的量子比特与环境相互作用，导致退相干。您将模拟这个开放量子系统，并计算其与理想克鲁克斯关系的偏离程度，从而为噪音引入的不可逆性提供一个定量的衡量标准。这个练习突出了定理成立的条件，并将其与更广泛的开放量子系统领域联系起来 。",
            "id": "3787449",
            "problem": "考虑一个在驱动过程中受到退相干噪声影响的驱动双能级量子系统（量子比特）。设系统哈密顿量是随时间变化的，由 $H(t)$ 定义，它在总协议持续时间 $T$ 内，从初始哈密顿量 $H(0)=H_0$ 插值到末态哈密顿量 $H(T)=H_1$。假设如下：\n\n- 希尔伯特空间是二维的，具有泡利算符 $\\sigma_x$、$\\sigma_y$、$\\sigma_z$。\n- 普朗克常数固定为 $\\hbar=1$，因此所有能量和频率都是无量纲的，时间也是无量纲的。\n- 瞬时哈密顿量由下式给出\n$$\nH(t) = \\frac{1}{2}\\omega(t)\\left(\\cos\\phi(t)\\sigma_z + \\sin\\phi(t)\\sigma_x\\right),\n$$\n其中频率 $\\omega(t) = \\omega_0 + (\\omega_1 - \\omega_0)\\,t/T$ 线性变化，轴角 $\\phi(t) = \\theta\\,t/T$ 线性变化，$\\omega_00$、$\\omega_10$ 和 $\\theta$ 是常数。角度必须以弧度为单位解释。\n\n- 系统从相对于 $H_0$ 的正则吉布斯态开始，其逆温度为 $\\beta$，即 $\\rho_0 = \\exp(-\\beta H_0)/Z_0$，其中 $Z_0 = \\mathrm{Tr}[\\exp(-\\beta H_0)]$。在逆向协议中，系统从相对于 $H_1$ 的、具有相同逆温度 $\\beta$ 的正则吉布斯态开始，即 $\\rho_1 = \\exp(-\\beta H_1)/Z_1$，其中 $Z_1 = \\mathrm{Tr}[\\exp(-\\beta H_1)]$。\n\n- 动力学过程被构建为一个Trotter化的幺正步骤序列，与瞬时能量本征基中的退相干通道交错进行。在一个小的时间步长 $\\Delta t$ 内，状态通过以下方式更新：\n    1. 幺正步骤：$\\rho \\mapsto U(t)\\,\\rho\\,U(t)^\\dagger$，其中 $U(t) = \\exp(-\\mathrm{i} H(t)\\,\\Delta t)$。\n    2. 在 $H(t)$ 的瞬时能量本征基中以速率 $\\gamma$ 进行退相干步骤：\n       如果 $H(t)$ 的本征矢量构成幺正矩阵 $V(t)$，使得 $V(t)^\\dagger H(t) V(t) = \\mathrm{diag}(E_-(t),E_+(t))$，那么在变换到此基底下后，密度矩阵的非对角元乘以 $\\mathrm{e}^{-\\gamma \\Delta t}$，而对角元保持不变，最后变换回实验室参考系。\n\n- 功由两点测量（TPM）方案定义：对于正向协议，在 $t=0$ 时对 $H_0$ 进行能量测量，将系统投影到能量为 $E_n^{(0)}$ 的态 $|n_0\\rangle$ 上，然后状态在含噪协议下演化至 $t=T$，接着对 $H_1$ 进行能量测量，将系统投影到能量为 $E_m^{(1)}$ 的态 $|m_1\\rangle$ 上。实现的功为 $W = E_m^{(1)} - E_n^{(0)}$。对于逆向协议，在 $t=0$ 时对 $H_1$ 进行能量测量，将系统投影到能量为 $E_l^{(1)}$ 的态 $|l_1\\rangle$ 上，然后状态在时间反演协议（规则与正向相同，但用 $H(T-t)$ 替代 $H(t)$）下演化至 $t=T$，再对 $H_0$ 进行能量测量，将系统投影到能量为 $E_k^{(0)}$ 的态 $|k_0\\rangle$ 上。实现的逆向功为 $W_{\\mathrm{rev}} = E_k^{(0)} - E_l^{(1)}$。\n\n- 正向功分布 $P_F(W)$ 是对所有正向跃迁的总和，每个跃迁都按其初始吉布斯概率和条件跃迁概率加权。类似地，为逆向协议定义逆向功分布 $P_R(W_{\\mathrm{rev}})$。\n\n定义正向-逆向一致性偏差度量如下。计算自由能差\n$$\n\\Delta F = F_1 - F_0 = -\\frac{1}{\\beta}\\ln Z_1 + \\frac{1}{\\beta}\\ln Z_0,\n$$\n并对于正向分布中出现的每个功值 $W$，定义\n$$\nQ(W) = \\ln P_F(W) - \\ln P_R(-W) - \\beta\\big(W - \\Delta F\\big).\n$$\n最大绝对偏差则为\n$$\nD = \\max_{W}\\,\\big|Q(W)\\big|.\n$$\n\n您的任务是使用具有 $N$ 个均匀步长 $\\Delta t = T/N$ 的中点Trotter分解规则，对上述协议进行数值模拟，计算包含所述退相干效应的正向和逆向TPM功分布，然后计算偏差度量 $D$。\n\n实现以下特定的测试套件参数集以评估不同方面：\n\n- 公共参数：$\\omega_0 = 1.0$，$\\omega_1 = 1.7$，$\\theta = 0.9$ (弧度)，$\\beta = 0.7$ (无量纲)，$T = 2.0$ (无量纲)，$N = 4000$ 步。对步数 $s = 0,1,\\ldots,N-1$，使用中点时间 $t_s = (s+0.5)\\Delta t$。\n\n- 退相干速率 $\\gamma$ 的测试用例：\n    1. 边界情况（无退相干）：$\\gamma = 0.0$。\n    2. 中等退相干（正常路径）：$\\gamma = 0.2$。\n    3. 强退相干（边缘情况）：$\\gamma = 3.0$。\n\n通过使用物理上合理的双能级时变哈密顿量和瞬时能量基中的标准相位阻尼通道，确保了科学真实性。在 $\\hbar=1$ 的单位制中，所有能量和逆温度都是无量纲的，角度以弧度为单位。程序必须为每个测试用例返回偏差度量 $D$，作为无量纲浮点值。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含计算结果 $[D_{\\gamma=0.0},D_{\\gamma=0.2},D_{\\gamma=3.0}]$，形式为方括号括起来的逗号分隔列表，顺序与上面列出的测试用例一致。条目必须是浮点数。不应打印任何其他文本。",
            "solution": "该问题要求对一个受退相干噪声影响的驱动双能级量子系统（量子比特），数值计算其与Crooks涨落定理的偏差度量。解决方案涉及模拟正向和时间反演协议下的量子动力学，构建相应的功分布，然后计算指定的度量。\n\n### 理论框架\n\n**1. 系统哈密顿量与本征结构**\n\n系统由一个二维希尔伯特空间上的时变哈密顿量描述，如下所示：\n$$\nH(t) = \\frac{1}{2}\\,\\omega(t)\\,\\big(\\cos\\phi(t)\\,\\sigma_z + \\sin\\phi(t)\\,\\sigma_x\\big)\n$$\n其中 $\\sigma_x$ 和 $\\sigma_z$ 是标准泡利矩阵。随时间变化的参数是一个线性插值的频率 $\\omega(t) = \\omega_0 + (\\omega_1 - \\omega_0)\\,t/T$ 和一个线性增长的角度 $\\phi(t) = \\theta\\,t/T$。\n\n哈密顿量可以写成 $H(t) = \\vec{h}(t) \\cdot \\vec{\\sigma}$ 的形式，其中 $\\vec{h}(t) = \\frac{1}{2}\\omega(t) (\\sin\\phi(t), 0, \\cos\\phi(t))$。瞬时本征值由 $E_\\pm(t) = \\pm|\\vec{h}(t)|$ 给出。由于 $\\sin^2\\phi + \\cos^2\\phi = 1$，本征值为：\n$$\nE_\\pm(t) = \\pm\\frac{1}{2}\\,\\omega(t)\n$$\n相应的瞬时本征矢量 $|E_\\pm(t)\\rangle$ 构成了时间 $t$ 的能量本征基。初始哈密顿量是 $H_0 = H(0)$，其本征值为 $\\pm\\frac{1}{2}\\omega_0$；末态哈密顿量是 $H_1 = H(T)$，其本征值为 $\\pm\\frac{1}{2}\\omega_1$。\n\n**2. 初始态与自由能**\n\n系统初始处于逆温度为 $\\beta$ 的正则吉布斯态。对于正向协议，初始态为 $\\rho_0 = \\exp(-\\beta H_0)/Z_0$，其中 $Z_0$ 是配分函数：\n$$\nZ_0 = \\mathrm{Tr}\\left[e^{-\\beta H_0}\\right] = e^{-\\beta E_+(0)} + e^{-\\beta E_-(0)} = e^{-\\beta \\omega_0/2} + e^{\\beta \\omega_0/2} = 2\\cosh\\left(\\frac{\\beta\\omega_0}{2}\\right)\n$$\n类似地，对于逆向协议，初始态是相对于 $H_1$ 的，其配分函数为 $Z_1 = 2\\cosh(\\frac{\\beta\\omega_1}{2})$。\n\n末态和初态平衡态之间的亥姆霍兹自由能差定义为 $\\Delta F = F_1 - F_0 = -\\frac{1}{\\beta}(\\ln Z_1 - \\ln Z_0)$。\n\n**3. 两点测量（TPM）方案与功分布**\n\n功是通过TPM方案随机定义的。\n对于**正向协议**：\n1. 在 $t=0$ 时，测量系统的能量（相对于 $H_0$）。系统以概率 $p_i^{(0)} = e^{-\\beta E_i^{(0)}}/Z_0$ 投影到 $H_0$ 的能量为 $E_i^{(0)}$ 的本征态 $|E_i^{(0)}\\rangle$ 上。\n2. 在指定的动力学下，将状态从 $t=0$ 演化到 $t=T$。初始纯态 $|E_i^{(0)}\\rangle\\langle E_i^{(0)}|$ 演化为末态密度矩阵 $\\rho_i^{(T)}$。\n3. 在 $t=T$ 时，测量能量（相对于 $H_1$）。获得结果 $E_j^{(1)}$ 的概率为 $P(j|i) = \\mathrm{Tr}\\left[ \\Pi_j^{(1)} \\rho_i^{(T)} \\right]$，其中 $\\Pi_j^{(1)}$ 是到本征态 $|E_j^{(1)}\\rangle$ 上的投影算符。\n4. 在此实现中做的功为 $W = E_j^{(1)} - E_i^{(0)}$。此功值的总概率为 $P_F(W) = \\sum_{i,j \\text{ s.t. } E_j^{(1)}-E_i^{(0)}=W} p_i^{(0)} P(j|i)$。\n\n**逆向协议**遵循类似的过程，从相对于 $H_1$ 的吉布斯态开始，在时间反演的哈密顿协议 $H(T-t)$ 下演化，最后测量相对于 $H_0$ 的能量。这会得到逆向功分布 $P_R(W_{\\text{rev}})$。\n\n**4. Crooks涨落定理与偏差度量**\n\n对于经历幺正演化的闭合量子系统，Crooks涨落定理给出了正向和逆向功分布之间的基本关系：\n$$\n\\frac{P_F(W)}{P_R(-W)} = e^{\\beta(W - \\Delta F)}\n$$\n重新整理该式可得 $\\ln P_F(W) - \\ln P_R(-W) - \\beta(W - \\Delta F) = 0$。问题将量 $Q(W)$ 定义为这个表达式。在存在非幺正动力学（例如退相干通道）的情况下，该等式预计不成立。偏差度量 $D = \\max_W |Q(W)|$ 量化了对Crooks关系的违背程度。非零的 $D$ 是系统开放性以及由环境引入的不可逆性的一个标志。\n\n### 数值实现\n\n连续时间动力学通过在 $N$ 个大小为 $\\Delta t = T/N$ 的离散时间步上进行Trotter化演化来近似。\n\n**1. 离散化演化步骤**\n\n在每一步 $s$（从 $s=0$ 到 $N-1$），密度矩阵 $\\rho$ 使用在中心点时间 $t_s = (s+0.5)\\Delta t$ 处计算的哈密顿量进行更新。更新包括两个子步骤：\n\na. **幺正演化：** 状态在哈密顿量 $H(t_s)$ 下演化 $\\Delta t$ 的时间。\n$$\n\\rho \\mapsto U(t_s) \\rho U(t_s)^\\dagger, \\quad \\text{where} \\quad U(t_s) = e^{-i H(t_s) \\Delta t}\n$$\n矩阵指数通过数值计算得出。\n\nb. **退相干通道：** 此步骤模拟在 $H(t_s)$ 的瞬时能量基中的能量阻尼。\n   i. 对角化哈密顿量：$H(t_s) = V_s D_s V_s^\\dagger$，其中 $V_s$ 是本征矢量矩阵。\n   ii. 将密度矩阵变换到能量本征基：$\\tilde{\\rho} = V_s^\\dagger \\rho V_s$。\n   iii. 通过抑制非对角元（相干项）来施加退相干：\n      $$\n      \\tilde{\\rho}_{ij} \\mapsto \\tilde{\\rho}_{ij} \\times \\begin{cases} 1  \\text{if } i=j \\\\ e^{-\\gamma \\Delta t}  \\text{if } i \\neq j \\end{cases}\n      $$\n   iv. 变换回原始基底：$\\rho \\mapsto V_s \\tilde{\\rho} V_s^\\dagger$。\n\n**2. 模拟正向和逆向协议**\n\n完整的演化是这 $N$ 个步骤的复合。为了构建功分布，我们必须演化初始能量投影算符。\n\n- **正向协议：** $H_0$ 的本征态上的两个投影算符 $\\{|E_i^{(0)}\\rangle\\langle E_i^{(0)}|\\}$，每一个都使用哈密顿量序列 $H(t_s)$ 演化 $N$ 步。这会产生两个末态密度矩阵 $\\{\\rho_i^{(T)}\\}$。然后使用TPM公式计算功概率。\n\n- **逆向协议：** 演化 $H_1$ 本征态上的投影算符 $\\{|E_k^{(1)}\\rangle\\langle E_k^{(1)}|\\}$。逆向协议在步骤 $s$ 的哈密顿量序列是 $H(T-t_s)$。使用得到的末态来计算逆向功分布。可以证明，对于中点规则，哈密顿量序列 $\\{H(T-t_s)\\}_{s=0}^{N-1}$ 是正向集合 $\\{H(t_s)\\}_{s=0}^{N-1}$ 的时间反演序列。具体来说，$T-t_s = t_{N-1-s}$。这个顺序对于正确检验Crooks关系至关重要。\n\n**3. 偏差度量 $D$ 的计算**\n\n有了 $P_F(W)$ 和 $P_R(W_{\\text{rev}})$ 的完整字典后，我们可以计算 $D$。\n1. 计算自由能差 $\\Delta F$。\n2. 对于正向分布中出现的每个功值 $W$（即 $P_F(W)0$）：\n   a. 获取 $P_F(W)$ 和 $P_R(-W)$。\n   b. 计算 $Q(W) = \\ln P_F(W) - \\ln P_R(-W) - \\beta(W-\\Delta F)$。\n3. 偏差是所有计算出的 $Q(W)$ 值中的最大绝对值：$D = \\max_W |Q(W)|$。\n\n对于 $\\gamma=0$ 的情况，演化在Trotter误差范围内是幺正的。中点Trotter分解的特定选择并不完全满足离散Crooks关系精确成立所需的时间反演性质 ($U_{\\text{rev,Trot}} \\neq U_{\\text{fwd,Trot}}^\\dagger$)，因此预计会有一个小的非零 $D$。对于 $\\gamma  0$，退相干引入了真正的不可逆性，预计 $D$ 会随 $\\gamma$ 显著增加。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the deviation from the Crooks relation for a driven, dephasing qubit.\n    \"\"\"\n\n    # Common parameters for all test cases\n    w0 = 1.0\n    w1 = 1.7\n    theta = 0.9  # radians\n    beta = 0.7   # dimensionless inverse temperature\n    T = 2.0      # dimensionless total time\n    N = 4000     # number of Trotter steps\n    \n    # Test cases for the dephasing rate gamma\n    gamma_cases = [0.0, 0.2, 3.0]\n    \n    # Pauli matrices (using complex numbers for consistency)\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n\n    def get_hamiltonian(t, w0_p, w1_p, T_p, theta_p):\n        \"\"\"Constructs the Hamiltonian H(t).\"\"\"\n        w_t = w0_p + (w1_p - w0_p) * t / T_p\n        phi_t = theta_p * t / T_p\n        return 0.5 * w_t * (np.cos(phi_t) * sigma_z + np.sin(phi_t) * sigma_x)\n\n    def run_protocol(initial_projector, gamma, is_forward):\n        \"\"\"Evolves an initial state according to the specified protocol.\"\"\"\n        rho = initial_projector.copy()\n        dt = T / N\n        \n        for s in range(N):\n            t_mid = (s + 0.5) * dt\n            \n            if is_forward:\n                current_t = t_mid\n            else: # Reverse protocol\n                current_t = T - t_mid\n\n            H_s = get_hamiltonian(current_t, w0, w1, T, theta)\n\n            # 1. Unitary step\n            U_s = expm(-1j * H_s * dt)\n            rho = U_s @ rho @ U_s.conj().T\n\n            # 2. Dephasing step (only if gamma > 0)\n            if gamma > 0:\n                _evals, evecs = np.linalg.eigh(H_s)\n                \n                # Transform to energy eigenbasis\n                rho_eb = evecs.conj().T @ rho @ evecs\n\n                # Apply dephasing\n                dephasing_factor = np.exp(-gamma * dt)\n                rho_eb[0, 1] *= dephasing_factor\n                rho_eb[1, 0] *= dephasing_factor\n                \n                # Transform back to lab frame\n                rho = evecs @ rho_eb @ evecs.conj().T\n        \n        return rho\n\n    results = []\n    for gamma in gamma_cases:\n        # --- Initial and Final Setup ---\n        H0 = get_hamiltonian(0.0, w0, w1, T, theta)\n        H1 = get_hamiltonian(T, w0, w1, T, theta)\n\n        evals0, evecs0 = np.linalg.eigh(H0)\n        evals1, evecs1 = np.linalg.eigh(H1)\n\n        Z0 = np.sum(np.exp(-beta * evals0))\n        Z1 = np.sum(np.exp(-beta * evals1))\n        \n        delta_F = (-1 / beta) * (np.log(Z1) - np.log(Z0))\n\n        # --- Forward Protocol Simulation ---\n        p0_forward = np.exp(-beta * evals0) / Z0\n        initial_projectors_fwd = [np.outer(v, v.conj()) for v in evecs0.T]\n\n        PF_map = {}\n        for i, proj0 in enumerate(initial_projectors_fwd):\n            final_rho_i = run_protocol(proj0, gamma, is_forward=True)\n            for j in range(2):\n                final_projector_j = np.outer(evecs1[:,j], evecs1[:,j].conj())\n                prob_j_given_i = np.real(np.trace(final_projector_j @ final_rho_i))\n                \n                work = evals1[j] - evals0[i]\n                total_prob = p0_forward[i] * prob_j_given_i\n                PF_map[work] = PF_map.get(work, 0) + total_prob\n\n        # --- Reverse Protocol Simulation ---\n        p0_reverse = np.exp(-beta * evals1) / Z1\n        initial_projectors_rev = [np.outer(v, v.conj()) for v in evecs1.T]\n        \n        PR_map = {}\n        for k, proj1 in enumerate(initial_projectors_rev):\n            final_rho_k = run_protocol(proj1, gamma, is_forward=False)\n            for l in range(2):\n                final_projector_l = np.outer(evecs0[:,l], evecs0[:,l].conj())\n                prob_l_given_k = np.real(np.trace(final_projector_l @ final_rho_k))\n                \n                work_rev = evals0[l] - evals1[k]\n                total_prob_rev = p0_reverse[k] * prob_l_given_k\n                PR_map[work_rev] = PR_map.get(work_rev, 0) + total_prob_rev\n\n        # --- Calculate Deviation Metric D ---\n        Q_values = []\n        for work, pf_w in PF_map.items():\n            neg_work = -work\n            pr_neg_w = PR_map.get(neg_work, 0.0)\n            \n            # Avoid log(0) issues; if a probability is zero, the relation is\n            # maximally violated, but this shouldn't happen with the noise model.\n            # A small epsilon can be used for numerical stability if needed.\n            if pf_w > 1e-15 and pr_neg_w > 1e-15:\n                q_val = np.log(pf_w) - np.log(pr_neg_w) - beta * (work - delta_F)\n                Q_values.append(q_val)\n        \n        deviation_D = np.max(np.abs(Q_values)) if Q_values else 0.0\n        results.append(deviation_D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}