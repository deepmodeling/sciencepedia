{
    "hands_on_practices": [
        {
            "introduction": "Understanding a profound result like the Crooks fluctuation theorem begins with mastering its foundations. This first practice challenges you to derive the theorem from first principles for an isolated quantum system, using the two-point measurement (TPM) scheme. By then implementing a numerical simulation for a driven qubit , you will gain direct, hands-on experience with the concepts of quantum work distributions and microreversibility, solidifying your grasp of this cornerstone of quantum thermodynamics.",
            "id": "3782357",
            "problem": "Consider a finite-dimensional quantum system subjected to a driving protocol where the system Hamiltonian changes from an initial Hamiltonian $H_0$ to a final Hamiltonian $H_1$ over a duration that is represented by an effective unitary operator $U$. Assume the system is isolated during the protocol and that the initial state is a thermal equilibrium state with respect to the initial Hamiltonian. The Two-Point Measurement (TPM) scheme defines quantum work by performing a projective measurement of energy at the beginning and end of the protocol. Under microreversibility, a backward protocol exists that drives the system from $H_1$ to $H_0$ via a unitary $U_B$ related to $U$ by time-reversal symmetry.\n\nStart from fundamental definitions: the Gibbs state $\\rho = e^{-\\beta H}/Z$ with $Z = \\operatorname{Tr}[e^{-\\beta H}]$, projective energy measurements, unitary evolution for an isolated system, and the form of microreversibility under time-reversal invariance. Using only these bases, derive the relation connecting the forward work distribution and the backward work distribution in the TPM scheme for a time-reversal invariant drive. Then implement a program that, for a set of concrete instances, numerically constructs the TPM forward and backward work distributions and verifies the derived relation to a specified numerical tolerance.\n\nProtocol specification and computation requirements:\n- The Hilbert space is two-dimensional (a quantum bit) with Pauli operators $\\sigma_x$, $\\sigma_y$, and $\\sigma_z$.\n- Energies and inverse temperatures are dimensionless with Planck’s constant reduced $\\hbar$ set to $1$.\n- The forward protocol consists of:\n  1. Sampling the initial energy via projective measurement of $H_0$ on the Gibbs state at inverse temperature $\\beta$.\n  2. Evolving under unitary $U$.\n  3. Measuring energy via projective measurement of $H_1$.\n- The backward protocol consists of:\n  1. Sampling the initial energy via projective measurement of $H_1$ on the Gibbs state at the same inverse temperature $\\beta$.\n  2. Evolving under the unitary $U_B$ satisfying time-reversal invariance (take $U_B = U^\\dagger$ for this two-level system).\n  3. Measuring energy via projective measurement of $H_0$.\n- In the TPM scheme, for a particular pair of initial and final energy outcomes $(E_n^0, E_m^1)$ associated with the forward protocol, the work $W$ is defined as $W = E_m^1 - E_n^0$. In the backward protocol, the corresponding work is $W' = E_n^0 - E_m^1$.\n- The program must numerically compute the discrete forward work distribution by summing over all $(n,m)$ pairs, with probabilities given by the Gibbs weights of $H_0$ and the squared transition amplitudes from $|E_n^0\\rangle$ to $|E_m^1\\rangle$ under $U$. Similarly, compute the backward work distribution using Gibbs weights of $H_1$ and transition amplitudes under $U^\\dagger$.\n- Using the derived relation between the forward and backward work distributions and the free energy difference $\\Delta F$ computed from $Z_0 = \\operatorname{Tr}[e^{-\\beta H_0}]$ and $Z_1 = \\operatorname{Tr}[e^{-\\beta H_1}]$, the program must evaluate the maximum absolute deviation between the empirical ratio and the theoretical prediction across all realized discrete work values.\n\nAngle units:\n- All angles specified for Hamiltonian axes and rotation unitaries must be interpreted in radians.\n\nTest suite:\nImplement and evaluate the following three test cases. For each case, define $H_0$, $H_1$, $U$, and $\\beta$ as follows. Use $\\sigma_x = \\begin{pmatrix}0 & 1\\\\ 1 & 0\\end{pmatrix}$, $\\sigma_y = \\begin{pmatrix}0 & -i\\\\ i & 0\\end{pmatrix}$, and $\\sigma_z = \\begin{pmatrix}1 & 0\\\\ 0 & -1\\end{pmatrix}$. Let the rotation about the $y$-axis be $U = e^{-i \\theta \\sigma_y / 2} = \\cos(\\theta/2) I - i \\sin(\\theta/2) \\sigma_y$.\n- Case 1 (general noncommuting, moderate temperature):\n  - $H_0 = \\frac{\\omega_0}{2} \\sigma_z$ with $\\omega_0 = 1.0$.\n  - $H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$ with $\\omega_1 = 0.8$ and $\\phi = \\pi/3$.\n  - $U = e^{-i \\theta \\sigma_y / 2}$ with $\\theta = 0.4$.\n  - $\\beta = 1.2$.\n- Case 2 (commuting, identity drive, low temperature):\n  - $H_0 = H_1 = \\frac{\\omega}{2} \\sigma_z$ with $\\omega = 2.0$.\n  - $U = I$.\n  - $\\beta = 3.5$.\n- Case 3 (general noncommuting, near-infinite temperature boundary):\n  - $H_0 = \\frac{\\omega_0}{2} \\sigma_z$ with $\\omega_0 = 1.2$.\n  - $H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$ with $\\omega_1 = 2.0$ and $\\phi = 0.7$.\n  - $U = e^{-i \\theta \\sigma_y / 2}$ with $\\theta = 1.0$.\n  - $\\beta = 10^{-8}$.\n\nAnswer specification:\n- For each test case, compute the maximum absolute deviation between the empirical ratio of forward to backward work distributions (evaluated at matched work values) and the theoretical prediction derived from first principles. Then compare this deviation to a tolerance of $10^{-9}$ and return a boolean indicating whether the derived relation holds within tolerance.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the three test cases (e.g., \"[True,True,False]\").",
            "solution": "The problem asks for two main deliverables: first, a derivation of the relationship between the forward and backward work distributions in the Two-Point Measurement (TPM) scheme under specific conditions of time-reversal symmetry; second, a numerical implementation to verify this derived relation for a set of given quantum protocols.\n\nFirst, we must validate the problem statement.\n\n### Step 1: Extract Givens\n- **System**: A finite-dimensional quantum system, specifically a two-dimensional Hilbert space (qubit).\n- **Initial State (Forward)**: Thermal Gibbs state $\\rho_0 = e^{-\\beta H_0}/Z_0$ at inverse temperature $\\beta$, with $Z_0 = \\operatorname{Tr}[e^{-\\beta H_0}]$.\n- **Forward Protocol**:\n    1.  Projective energy measurement of $H_0$. Outcome $E_n^0$.\n    2.  Unitary evolution $U$.\n    3.  Projective energy measurement of $H_1$. Outcome $E_m^1$.\n- **Work (Forward)**: $W = E_m^1 - E_n^0$.\n- **Initial State (Backward)**: Thermal Gibbs state $\\rho_1 = e^{-\\beta H_1}/Z_1$ at the same $\\beta$, with $Z_1 = \\operatorname{Tr}[e^{-\\beta H_1}]$.\n- **Backward Protocol**:\n    1.  Projective energy measurement of $H_1$. Outcome $E_m^1$.\n    2.  Unitary evolution $U_B$.\n    3.  Projective energy measurement of $H_0$. Outcome $E_n^0$.\n- **Microreversibility Condition**: The backward unitary is specified as $U_B = U^\\dagger$.\n- **Work (Backward)**: $W' = E_n^0 - E_m^1$.\n- **Numerical Constants & Definitions**: $\\hbar = 1$. Pauli matrices $\\sigma_x = \\begin{pmatrix}0 & 1\\\\ 1 & 0\\end{pmatrix}$, $\\sigma_y = \\begin{pmatrix}0 & -i\\\\ i & 0\\end{pmatrix}$, $\\sigma_z = \\begin{pmatrix}1 & 0\\\\ 0 & -1\\end{pmatrix}$. Rotation unitary $U = e^{-i \\theta \\sigma_y / 2} = \\cos(\\theta/2) I - i \\sin(\\theta/2) \\sigma_y$.\n- **Test Cases**:\n    - **Case 1**: $H_0 = \\frac{\\omega_0}{2} \\sigma_z$ with $\\omega_0 = 1.0$. $H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$ with $\\omega_1 = 0.8$, $\\phi = \\pi/3$. $U$ with $\\theta = 0.4$. $\\beta = 1.2$.\n    - **Case 2**: $H_0 = H_1 = \\frac{\\omega}{2} \\sigma_z$ with $\\omega = 2.0$. $U = I$. $\\beta = 3.5$.\n    - **Case 3**: $H_0 = \\frac{\\omega_0}{2} \\sigma_z$ with $\\omega_0 = 1.2$. $H_1 = \\frac{\\omega_1}{2} (\\cos \\phi\\, \\sigma_z + \\sin \\phi\\, \\sigma_x)$ with $\\omega_1 = 2.0$, $\\phi = 0.7$. $U$ with $\\theta = 1.0$. $\\beta = 10^{-8}$.\n- **Verification Task**: Compute the maximum absolute deviation between the empirical ratio of distributions $P_F(W)/P_B(-W)$ and the theoretical prediction, and check if it is within a tolerance of $10^{-9}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the fundamental principles of quantum statistical mechanics, including the Gibbs canonical ensemble, projective measurements (von Neumann postulate), and unitary time evolution (Schrödinger equation). The TPM scheme is the standard definition of quantum work. The relation to be derived, the Crooks fluctuation theorem, is a cornerstone of non-equilibrium statistical mechanics. The postulate $U_B = U^\\dagger$ is a specific, consistent choice for defining the backward protocol, making the problem self-contained.\n- **Well-Posed**: All necessary parameters, Hamiltonians, evolution operators, and the inverse temperature are explicitly defined for each test case. The objective is clear: derive a specific physical relation and then implement a numerical verification according to precise instructions. A unique and meaningful solution exists.\n- **Objective**: The problem is stated using formal, unambiguous language from physics and mathematics. There are no subjective elements.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. I will proceed with the solution.\n\n### Derivation of the Fluctuation Relation\n\nThe objective is to derive the relation between the forward work distribution, $P_F(W)$, and the backward work distribution, $P_B(W')$.\n\n**1. Forward Work Distribution, $P_F(W)$**\n\nThe forward protocol begins with the system in thermal equilibrium with the initial Hamiltonian $H_0$ at an inverse temperature $\\beta$. The density matrix is the canonical Gibbs state:\n$$\n\\rho_0 = \\frac{e^{-\\beta H_0}}{Z_0}, \\quad Z_0 = \\operatorname{Tr}[e^{-\\beta H_0}]\n$$\nLet $\\{|E_n^0\\rangle\\}$ be the orthonormal energy eigenbasis of $H_0$, such that $H_0|E_n^0\\rangle = E_n^0|E_n^0\\rangle$. The first step of the TPM scheme is a projective measurement of energy. The probability of obtaining the outcome $E_n^0$ is given by the Born rule:\n$$\np(E_n^0) = \\langle E_n^0 | \\rho_0 | E_n^0 \\rangle = \\langle E_n^0 | \\frac{e^{-\\beta H_0}}{Z_0} | E_n^0 \\rangle = \\frac{e^{-\\beta E_n^0}}{Z_0}\n$$\nFollowing this measurement, the system's state collapses to $|E_n^0\\rangle$. It then evolves under the unitary operator $U$ to the state $U|E_n^0\\rangle$. The second step is a projective measurement of energy with respect to the final Hamiltonian $H_1$. Let $\\{|E_m^1\\rangle\\}$ be the eigenbasis of $H_1$, with $H_1|E_m^1\\rangle = E_m^1|E_m^1\\rangle$. The conditional probability of measuring $E_m^1$, given the initial state was $|E_n^0\\rangle$, is:\n$$\np(E_m^1 | E_n^0) = |\\langle E_m^1 | U | E_n^0 \\rangle|^2\n$$\nThe joint probability of observing the sequence of outcomes $(E_n^0, E_m^1)$ is the product of these probabilities:\n$$\np_F(n,m) = p(E_m^1 | E_n^0) p(E_n^0) = |\\langle E_m^1 | U | E_n^0 \\rangle|^2 \\frac{e^{-\\beta E_n^0}}{Z_0}\n$$\nThe work performed on the system for this specific trajectory is defined as $W = E_m^1 - E_n^0$. The probability distribution for work, $P_F(W)$, is the sum of probabilities of all trajectories that yield the same work value:\n$$\nP_F(W) = \\sum_{n,m} \\delta(W - (E_m^1 - E_n^0)) p_F(n,m)\n$$\n\n**2. Backward Work Distribution, $P_B(W')$**\n\nThe backward protocol starts with the system in thermal equilibrium with the final Hamiltonian $H_1$ at the same inverse temperature $\\beta$. The initial state is:\n$$\n\\rho_1 = \\frac{e^{-\\beta H_1}}{Z_1}, \\quad Z_1 = \\operatorname{Tr}[e^{-\\beta H_1}]\n$$\nAn energy measurement on $H_1$ yields outcome $E_m^1$ with probability:\n$$\np(E_m^1) = \\langle E_m^1 | \\rho_1 | E_m^1 \\rangle = \\frac{e^{-\\beta E_m^1}}{Z_1}\n$$\nThe system state collapses to $|E_m^1\\rangle$ and evolves under the backward unitary $U_B = U^\\dagger$. A final energy measurement on $H_0$ yields outcome $E_n^0$ with conditional probability:\n$$\np_B(E_n^0 | E_m^1) = |\\langle E_n^0 | U_B | E_m^1 \\rangle|^2 = |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2\n$$\nThe joint probability for the backward trajectory is:\n$$\np_B(m,n) = p_B(E_n^0 | E_m^1) p(E_m^1) = |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2 \\frac{e^{-\\beta E_m^1}}{Z_1}\n$$\nThe work for the backward process is defined as $W' = E_n^0 - E_m^1$. The backward work distribution is:\n$$\nP_B(W') = \\sum_{n,m} \\delta(W' - (E_n^0 - E_m^1)) p_B(m,n)\n$$\n\n**3. The Crooks Fluctuation Relation**\n\nWe now connect $P_F(W)$ and $P_B(W')$. Consider a specific forward work value $W$. We examine the probability in the backward process of obtaining work $-W$. Note that $W' = E_n^0 - E_m^1 = -(E_m^1 - E_n^0) = -W$.\n$$\nP_F(W) = \\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 \\frac{e^{-\\beta E_n^0}}{Z_0}\n$$\n$$\nP_B(-W) = \\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2 \\frac{e^{-\\beta E_m^1}}{Z_1}\n$$\nThe summation condition is identical for both expressions. A key property of the matrix adjoint is that $|\\langle v_1 | A | v_2 \\rangle|^2 = |\\langle v_2 | A^\\dagger | v_1 \\rangle|^2$. Applying this to the transition probabilities:\n$$\n|\\langle E_m^1 | U | E_n^0 \\rangle|^2 = |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2\n$$\nThis means the quantum transition probabilities for a forward trajectory $(n \\to m)$ and its time-reversed counterpart $(m \\to n)$ are identical.\nLet's examine the ratio of the distributions for a given work value $W$:\n$$\n\\frac{P_F(W)}{P_B(-W)} = \\frac{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 \\frac{e^{-\\beta E_n^0}}{Z_0}}{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_n^0 | U^\\dagger | E_m^1 \\rangle|^2 \\frac{e^{-\\beta E_m^1}}{Z_1}}\n$$\nUsing the identity for transition probabilities, we can simplify:\n$$\n\\frac{P_F(W)}{P_B(-W)} = \\frac{Z_1}{Z_0} \\frac{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 e^{-\\beta E_n^0}}{\\sum_{n,m, E_m^1 - E_n^0 = W} |\\langle E_m^1 | U | E_n^0 \\rangle|^2 e^{-\\beta E_m^1}}\n$$\nWe can rewrite $e^{-\\beta E_n^0}$ using the work definition $W = E_m^1 - E_n^0$:\n$E_n^0 = E_m^1 - W \\implies e^{-\\beta E_n^0} = e^{-\\beta(E_m^1 - W)} = e^{\\beta W} e^{-\\beta E_m^1}$.\nSince $W$ is fixed for all terms in the sum, we can factor out $e^{\\beta W}$:\n$$\n\\frac{P_F(W)}{P_B(-W)} = \\frac{Z_1}{Z_0} \\frac{e^{\\beta W} \\sum_{n,m, ...} |\\langle ... \\rangle|^2 e^{-\\beta E_m^1}}{\\sum_{n,m, ...} |\\langle ... \\rangle|^2 e^{-\\beta E_m^1}} = \\frac{Z_1}{Z_0} e^{\\beta W}\n$$\nThe Helmholtz free energy $F$ is defined as $F = -k_B T \\ln Z = - (1/\\beta) \\ln Z$. The change in free energy between the equilibrium states associated with $H_1$ and $H_0$ is $\\Delta F = F_1 - F_0 = -(1/\\beta)(\\ln Z_1 - \\ln Z_0) = -(1/\\beta)\\ln(Z_1/Z_0)$. Thus, $Z_1/Z_0 = e^{-\\beta \\Delta F}$.\nSubstituting this into our expression yields the Crooks fluctuation relation:\n$$\n\\frac{P_F(W)}{P_B(-W)} = e^{-\\beta \\Delta F} e^{\\beta W} = e^{\\beta (W - \\Delta F)}\n$$\nThis is the relation to be numerically verified.\n\n### Numerical Implementation Plan\nThe program will implement the TPM scheme for the provided two-level system. For each test case:\n1.  Construct the matrix representations of the initial Hamiltonian $H_0$, the final Hamiltonian $H_1$, and the unitary evolution operator $U$.\n2.  Numerically diagonalize $H_0$ and $H_1$ to find their respective eigenvalues ($E_n^0$, $E_m^1$) and eigenvectors ($|E_n^0\\rangle$, $|E_m^1\\rangle$).\n3.  Calculate the partition functions $Z_0$ and $Z_1$, and the free energy difference $\\Delta F = -(1/\\beta) \\ln(Z_1/Z_0)$.\n4.  Compute the discrete work distributions $P_F(W)$ and $P_B(-W)$. This involves iterating through all four possible transitions $(n, m) \\in \\{ (0,0), (0,1), (1,0), (1,1) \\}$, calculating the work $W = E_m^1 - E_n^0$ and the corresponding joint probability for both forward and backward protocols, and summing probabilities for any degenerate work values.\n5.  For each unique work value $W$ where $P_F(W) > 0$, calculate the empirical ratio $R_{\\text{emp}} = P_F(W)/P_B(-W)$ and the theoretical ratio $R_{\\text{th}} = e^{\\beta (W - \\Delta F)}$.\n6.  Determine the maximum absolute deviation $|R_{\\text{emp}} - R_{\\text{th}}|$ across all observed work values.\n7.  Compare this maximum deviation against the specified tolerance of $10^{-9}$ to return a boolean result.\nThis procedure will be repeated for all three test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and numerically verifying the Crooks fluctuation theorem\n    for three specified quantum protocols.\n    \"\"\"\n\n    # Define Pauli matrices and Identity\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_y = np.array([[0, -1j], [1j, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n    identity = np.eye(2, dtype=complex)\n\n    def verify_crooks_relation(H0, H1, U, beta, tolerance):\n        \"\"\"\n        Numerically verifies the Crooks relation for a given protocol.\n\n        Args:\n            H0 (np.ndarray): Initial Hamiltonian.\n            H1 (np.ndarray): Final Hamiltonian.\n            U (np.ndarray): Unitary evolution operator.\n            beta (float): Inverse temperature.\n            tolerance (float): Numerical tolerance for verification.\n\n        Returns:\n            bool: True if the relation holds within the tolerance, False otherwise.\n        \"\"\"\n        # Step 1: Diagonalize Hamiltonians\n        evals0, evecs0 = np.linalg.eigh(H0)\n        evals1, evecs1 = np.linalg.eigh(H1)\n\n        # Step 2: Calculate partition functions and free energy difference\n        Z0 = np.sum(np.exp(-beta * evals0))\n        Z1 = np.sum(np.exp(-beta * evals1))\n        \n        # Avoid log(0) for edge cases, though not expected here\n        if Z0 = 0 or Z1 = 0:\n            # An unphysical scenario indicating an issue.\n            # For the given problems, Z0 and Z1 are always positive.\n            return False \n\n        delta_F = (-1 / beta) * np.log(Z1 / Z0)\n\n        # Step 3: Compute forward and backward work distributions\n        forward_work_dist = {}\n        backward_work_dist = {}\n        \n        U_dagger = U.conj().T\n\n        for n in range(2):\n            E_n0 = evals0[n]\n            vec_n0 = evecs0[:, n]\n            \n            for m in range(2):\n                E_m1 = evals1[m]\n                vec_m1 = evecs1[:, m]\n\n                # This is the quantum transition probability, identical for forward and back\n                transition_prob = np.abs(vec_m1.conj() @ U @ vec_n0)**2\n                \n                # Forward process\n                work_F = E_m1 - E_n0\n                prob_initial_F = np.exp(-beta * E_n0) / Z0\n                joint_prob_F = prob_initial_F * transition_prob\n                forward_work_dist[work_F] = forward_work_dist.get(work_F, 0) + joint_prob_F\n\n                # Backward process\n                work_B = E_n0 - E_m1 # This is -work_F\n                prob_initial_B = np.exp(-beta * E_m1) / Z1\n                joint_prob_B = prob_initial_B * transition_prob\n                backward_work_dist[work_B] = backward_work_dist.get(work_B, 0) + joint_prob_B\n        \n        # Step 4: Verify the relation for each realized work value\n        max_deviation = 0.0\n        \n        for W, P_F_W in forward_work_dist.items():\n            P_B_negW = backward_work_dist.get(-W, 0.0)\n\n            # The relation is only tested for work values with non-zero probability\n            if P_F_W > 1e-15 and P_B_negW > 1e-15:\n                empirical_ratio = P_F_W / P_B_negW\n                theoretical_ratio = np.exp(beta * (W - delta_F))\n                \n                deviation = np.abs(empirical_ratio - theoretical_ratio)\n                if deviation > max_deviation:\n                    max_deviation = deviation\n        \n        return max_deviation  tolerance\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general noncommuting, moderate temperature\n        {\n            'params': {'omega0': 1.0, 'omega1': 0.8, 'phi': np.pi / 3, 'theta': 0.4, 'beta': 1.2},\n            'H0_func': lambda p: (p['omega0'] / 2) * sigma_z,\n            'H1_func': lambda p: (p['omega1'] / 2) * (np.cos(p['phi']) * sigma_z + np.sin(p['phi']) * sigma_x),\n            'U_func': lambda p: np.cos(p['theta'] / 2) * identity - 1j * np.sin(p['theta'] / 2) * sigma_y\n        },\n        # Case 2: commuting, identity drive, low temperature\n        {\n            'params': {'omega': 2.0, 'beta': 3.5},\n            'H0_func': lambda p: (p['omega'] / 2) * sigma_z,\n            'H1_func': lambda p: (p['omega'] / 2) * sigma_z, # H1 = H0\n            'U_func': lambda p: identity # U = I\n        },\n        # Case 3: general noncommuting, near-infinite temperature boundary\n        {\n            'params': {'omega0': 1.2, 'omega1': 2.0, 'phi': 0.7, 'theta': 1.0, 'beta': 1e-8},\n            'H0_func': lambda p: (p['omega0'] / 2) * sigma_z,\n            'H1_func': lambda p: (p['omega1'] / 2) * (np.cos(p['phi']) * sigma_z + np.sin(p['phi']) * sigma_x),\n            'U_func': lambda p: np.cos(p['theta'] / 2) * identity - 1j * np.sin(p['theta'] / 2) * sigma_y\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        params = case['params']\n        H0 = case['H0_func'](params)\n        H1 = case['H1_func'](params)\n        U = case['U_func'](params)\n        beta = params['beta']\n        \n        is_verified = verify_crooks_relation(H0, H1, U, beta, tolerance)\n        results.append(is_verified)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After verifying the theorem for a single qubit, it is natural to ask whether this relationship holds for more complex, interacting systems. This practice scales up the challenge to a many-body transverse-field Ising model, a canonical example of a system exhibiting quantum phase transitions. By using exact diagonalization to compute the work distributions for a quantum quench , you will test the remarkable generality of the Crooks theorem and develop valuable skills for simulating many-body quantum dynamics.",
            "id": "3787400",
            "problem": "Consider a finite quantum spin chain with $N$ spin-$\\frac{1}{2}$ degrees of freedom and open boundary conditions. Let the forward protocol be a sudden quench from an initial Hamiltonian $H_{0}$ to a final Hamiltonian $H_{1}$ at inverse temperature $\\beta$, using the two-projective-measurement scheme. The reverse protocol is the sudden quench from $H_{1}$ to $H_{0}$ at the same inverse temperature $\\beta$, again using the two-projective-measurement scheme. Work is defined as the difference between the final and initial projective energy measurement outcomes. All quantities are dimensionless, in units where the reduced Planck constant and Boltzmann constant satisfy $\\hbar = 1$ and $k_{\\mathrm{B}} = 1$.\n\nFundamental base and definitions to be used:\n- The Gibbs state of a Hamiltonian $H$ at inverse temperature $\\beta$ is $\\rho = e^{-\\beta H}/Z$ with $Z = \\mathrm{Tr}\\left(e^{-\\beta H}\\right)$.\n- The two-projective-measurement scheme for work proceeds as follows. For the forward protocol: sample an initial energy outcome $E_{n}^{0}$ according to the Gibbs distribution of $H_{0}$, suddenly change the Hamiltonian to $H_{1}$, and then sample a final energy outcome $E_{m}^{1}$ according to the Born rule from the pre-quench eigenstate. The realized work is $W = E_{m}^{1} - E_{n}^{0}$. The reverse protocol is defined analogously with $H_{1}$ as the initial Hamiltonian and $H_{0}$ as the post-quench Hamiltonian.\n- The equilibrium free energy of a Hamiltonian $H$ at inverse temperature $\\beta$ is $F = -\\frac{1}{\\beta}\\ln Z$, with $Z$ as above.\n\nThe model Hamiltonians are specified by the transverse-field Ising form\n$$\nH(J,h) = -J \\sum_{i=1}^{N-1} \\sigma_{z}^{(i)} \\sigma_{z}^{(i+1)} - h \\sum_{i=1}^{N} \\sigma_{x}^{(i)},\n$$\nwhere $\\sigma_{x}^{(i)}$ and $\\sigma_{z}^{(i)}$ are Pauli matrices acting on site $i$, and $J$ and $h$ are real scalars. The forward-quench Hamiltonian pair is $(H_{0}, H_{1}) = \\left(H(J_{0}, h_{0}), H(J_{1}, h_{1})\\right)$.\n\nTask:\n- Starting from the fundamental definitions above, construct the discrete forward work distribution $P_{\\mathrm{F}}(W)$ and the discrete reverse work distribution $P_{\\mathrm{R}}(W)$ for the sudden-quench protocol at inverse temperature $\\beta$. Use exact diagonalization to obtain the energy eigenvalues and eigenvectors of $H_{0}$ and $H_{1}$, and the Born rule to compute outcome probabilities from the overlaps of eigenvectors across the quench.\n- Compute the partition functions $Z_{0}$ and $Z_{1}$ of $H_{0}$ and $H_{1}$, respectively, and the free-energy difference $\\Delta F = F_{1}-F_{0}$.\n- For the set of work values $W$ that have nonzero probability in both forward and reverse processes (with reverse evaluated at $-W$), compute the quantity\n$$\nC(W) = \\ln P_{\\mathrm{F}}(W) - \\ln P_{\\mathrm{R}}(-W) - \\beta\\left(W - \\Delta F\\right).\n$$\n- Aggregate the result by computing the maximum absolute deviation\n$$\n\\|C\\|_{\\infty} = \\max_{W} \\left|C(W)\\right|.\n$$\nReport $\\|C\\|_{\\infty}$ for each test case below.\n\nImplementation details and constraints:\n- Use exact diagonalization of $H_{0}$ and $H_{1}$ in the computational basis to obtain eigenvalues and eigenvectors. Construct $H(J,h)$ via Kronecker products of Pauli matrices.\n- The discrete work distributions are supported on values of the form $W = E_{m}^{1} - E_{n}^{0}$. In numerical aggregation, combine contributions at equal values of $W$ using rounding to $12$ decimal places to avoid floating-point fragmentation. Only use $W$ for which both $P_{\\mathrm{F}}(W)$ and $P_{\\mathrm{R}}(-W)$ are strictly positive when evaluating $C(W)$.\n- Energies, inverse temperatures, and work are all dimensionless (no physical units are required).\n\nTest suite:\nProvide results for the following parameter sets, each specified as a tuple $(N, J_{0}, h_{0}, J_{1}, h_{1}, \\beta)$:\n- Case $1$: $(3, 0.8, 1.0, 0.5, 0.3, 0.9)$\n- Case $2$ (commuting Hamiltonians: $h_{0} = 0$, $h_{1} = 0$): $(3, 0.4, 0.0, -0.7, 0.0, 1.2)$\n- Case $3$ (high temperature): $(4, 0.3, 0.9, 1.1, 0.6, 0.1)$\n- Case $4$ (low temperature): $(2, 1.0, 0.5, 0.2, 1.3, 3.0)$\n- Case $5$ (noninteracting spins, commuting in the $\\sigma_{x}$ basis: $J_{0} = 0$, $J_{1} = 0$): $(3, 0.0, 0.7, 0.0, 1.4, 0.8)$\n\nRequired final output format:\nYour program should produce a single line of output containing the five results in the order of the cases above, formatted as a comma-separated list enclosed in square brackets. Express each result as a floating-point number in scientific notation with $10$ digits after the decimal point. For example, an output with three placeholder results must look like\n$[1.2345678901e-03,2.3456789012e-04,3.4567890123e-05]$.",
            "solution": "The user wants me to validate the Crooks fluctuation theorem for a quantum quench in the transverse-field Ising model. This is a well-posed problem in quantum statistical mechanics. All provided definitions and parameters are standard and self-consistent. The problem is scientifically sound, objective, and computationally feasible for the given system sizes. It is a valid numerical exercise.\n\n### Principle-Based Solution Design\n\nThe core task is to numerically verify the Crooks fluctuation theorem for a sudden quench protocol applied to a transverse-field Ising chain. The theorem relates the work distributions of a forward process and its time-reversed counterpart. For a system initially in thermal equilibrium at inverse temperature $\\beta$, undergoing a process described by a changing Hamiltonian, the theorem states:\n$$\n\\frac{P_{\\mathrm{F}}(W)}{P_{\\mathrm{R}}(-W)} = e^{\\beta(W - \\Delta F)}\n$$\nHere, $P_{\\mathrm{F}}(W)$ is the probability distribution for work $W$ in the forward process, $P_{\\mathrm{R}}(-W)$ is the probability distribution for work $-W$ in the reverse process, and $\\Delta F = F_{\\mathrm{final}} - F_{\\mathrm{initial}}$ is the change in the system's equilibrium free energy.\n\nThe problem asks to compute the quantity\n$$\nC(W) = \\ln P_{\\mathrm{F}}(W) - \\ln P_{\\mathrm{R}}(-W) - \\beta\\left(W - \\Delta F\\right)\n$$\nand report its maximum absolute value, $\\|C\\|_{\\infty} = \\max_W|C(W)|$. Based on the Crooks theorem, we expect $C(W)$ to be identically zero for all $W$. Any numerically computed non-zero value will be attributable to floating-point precision errors.\n\nThe step-by-step procedure to compute $\\|C\\|_{\\infty}$ is as follows:\n\n1.  **Hamiltonian Construction**: The transverse-field Ising Hamiltonian for a chain of $N$ spins with open boundary conditions is given by:\n    $$\n    H(J,h) = -J \\sum_{i=1}^{N-1} \\sigma_{z}^{(i)} \\sigma_{z}^{(i+1)} - h \\sum_{i=1}^{N} \\sigma_{x}^{(i)}\n    $$\n    where $\\sigma_{x}^{(i)}$ and $\\sigma_{z}^{(i)}$ are Pauli matrices acting on site $i$. We construct the $2^N \\times 2^N$ matrices for the initial Hamiltonian $H_0 = H(J_0, h_0)$ and the final Hamiltonian $H_1 = H(J_1, h_1)$ in the computational basis (the eigenbasis of all $\\sigma_z$). This is done by representing each term in the sum as a Kronecker product of Pauli matrices and identity matrices, e.g., $\\sigma_{z}^{(i)} \\sigma_{z}^{(i+1)} = I^{\\otimes (i-1)} \\otimes \\sigma_z \\otimes \\sigma_z \\otimes I^{\\otimes (N-i-1)}$.\n\n2.  **Eigensystem Determination**: We perform exact diagonalization on the Hermitian matrices $H_0$ and $H_1$ to find their respective eigenvalues and eigenvectors.\n    $$\n    H_0 |E_n^0\\rangle = E_n^0 |E_n^0\\rangle \\quad \\text{for } n = 0, \\dots, 2^N-1\n    $$\n    $$\n    H_1 |E_m^1\\rangle = E_m^1 |E_m^1\\rangle \\quad \\text{for } m = 0, \\dots, 2^N-1\n    $$\n    This provides the complete energy spectra $\\{E_n^0\\}$, $\\{E_m^1\\}$ and the corresponding orthonormal bases of eigenvectors $\\{|E_n^0\\rangle\\}$, $\\{|E_m^1\\rangle\\}$.\n\n3.  **Free Energy Calculation**: The equilibrium partition function for a Hamiltonian $H$ at inverse temperature $\\beta$ is $Z = \\mathrm{Tr}(e^{-\\beta H}) = \\sum_k e^{-\\beta E_k}$. We compute the partition functions $Z_0$ and $Z_1$ for $H_0$ and $H_1$:\n    $$\n    Z_0 = \\sum_{n} e^{-\\beta E_n^0} \\quad , \\quad Z_1 = \\sum_{m} e^{-\\beta E_m^1}\n    $$\n    The free energy difference is then $\\Delta F = F_1 - F_0 = -\\frac{1}{\\beta}(\\ln Z_1 - \\ln Z_0)$.\n\n4.  **Work Distribution Calculation**: The work distributions are derived from the two-projective measurement (TPM) scheme.\n    *   **Forward Process ($H_0 \\to H_1$)**:\n        1.  The system is initially in thermal equilibrium with $H_0$. An energy measurement yields eigenvalue $E_n^0$ with probability $p_n^0 = e^{-\\beta E_n^0}/Z_0$.\n        2.  The Hamiltonian is suddenly quenched from $H_0$ to $H_1$. The state of the system remains $|E_n^0\\rangle$.\n        3.  A second energy measurement is performed in the eigenbasis of $H_1$. The probability of measuring $E_m^1$ is given by the Born rule: $p(m|n) = |\\langle E_m^1 | E_n^0 \\rangle|^2$.\n        The work for this trajectory is $W = E_m^1 - E_n^0$. The total probability for a work value $W$ is obtained by summing the probabilities of all trajectories that yield this work:\n        $$\n        P_{\\mathrm{F}}(W) = \\sum_{n,m} \\delta(W - (E_m^1 - E_n^0)) \\, |\\langle E_m^1 | E_n^0 \\rangle|^2 \\, \\frac{e^{-\\beta E_n^0}}{Z_0}\n        $$\n    *   **Reverse Process ($H_1 \\to H_0$)**: The logic is identical, with the roles of $H_0$ and $H_1$ swapped. The work is $W = E_n^0 - E_m^1$.\n        $$\n        P_{\\mathrm{R}}(W) = \\sum_{n,m} \\delta(W - (E_n^0 - E_m^1)) \\, |\\langle E_n^0 | E_m^1 \\rangle|^2 \\, \\frac{e^{-\\beta E_m^1}}{Z_1}\n        $$\n    Numerically, we iterate through all pairs of initial ($n$) and final ($m$) eigenstates, calculate the work $W$ and the corresponding probability, and aggregate these probabilities in a dictionary-like data structure where keys are work values (rounded to $12$ decimal places to handle floating-point inaccuracies).\n\n5.  **Deviation Calculation**: We identify the set of work values $W$ for which both $P_{\\mathrm{F}}(W)$ and $P_{\\mathrm{R}}(-W)$ are non-zero. For each such $W$, we compute $C(W)$ and find the maximum of its absolute value, $\\|C\\|_{\\infty}$. This final value is the result for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def build_hamiltonian(N, J, h):\n        \"\"\"\n        Constructs the transverse-field Ising model Hamiltonian matrix for a chain of N spins.\n        \"\"\"\n        dim = 2**N\n        H = np.zeros((dim, dim), dtype=np.complex128)\n\n        sigma_x = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n        sigma_z = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n        Id = np.eye(2, dtype=np.complex128)\n\n        # Interaction term: -J * sum_{i=1}^{N-1} sigma_z^(i) * sigma_z^(i+1)\n        if J != 0:\n            for i in range(N - 1):\n                op_list = [Id] * N\n                op_list[i] = sigma_z\n                op_list[i+1] = sigma_z\n                term = op_list[0]\n                for k in range(1, N):\n                    term = np.kron(term, op_list[k])\n                H -= J * term\n\n        # Field term: -h * sum_{i=1}^{N} sigma_x^(i)\n        if h != 0:\n            for i in range(N):\n                op_list = [Id] * N\n                op_list[i] = sigma_x\n                term = op_list[0]\n                for k in range(1, N):\n                    term = np.kron(term, op_list[k])\n                H -= h * term\n                \n        return H\n\n    def get_work_distribution(E_initial, V_initial, E_final, V_final, beta, Z_initial):\n        \"\"\"\n        Calculates the discrete work distribution for a sudden quench process.\n        \"\"\"\n        work_dist = defaultdict(float)\n        dim = len(E_initial)\n        \n        # Overlap matrix: O_mn = E_m^final | E_n^initial\n        overlap_matrix = V_final.conj().T @ V_initial\n        \n        # Transition probabilities: P(m|n) = |E_m^final | E_n^initial|^2\n        transition_probs = np.abs(overlap_matrix)**2\n\n        # Initial state probabilities from Gibbs distribution\n        initial_probs = np.exp(-beta * E_initial) / Z_initial\n\n        for n in range(dim): # Loop over initial eigenstates\n            if initial_probs[n] == 0:\n                continue\n            \n            for m in range(dim): # Loop over final eigenstates\n                if transition_probs[m, n] == 0:\n                    continue\n                \n                work = E_final[m] - E_initial[n]\n                # Round to 12 decimal places as specified\n                work_key = round(work, 12)\n                \n                probability = initial_probs[n] * transition_probs[m, n]\n                work_dist[work_key] += probability\n                \n        return dict(work_dist)\n\n    def calculate_crooks_deviation(N, J0, h0, J1, h1, beta):\n        \"\"\"\n        Computes the max absolute deviation from the Crooks relation prediction.\n        \"\"\"\n        # 1. Construct Hamiltonians\n        H0 = build_hamiltonian(N, J0, h0)\n        H1 = build_hamiltonian(N, J1, h1)\n\n        # 2. Diagonalize Hamiltonians\n        E0, V0 = np.linalg.eigh(H0)\n        E1, V1 = np.linalg.eigh(H1)\n        \n        # 3. Compute partition functions and free energy difference\n        Z0 = np.sum(np.exp(-beta * E0))\n        Z1 = np.sum(np.exp(-beta * E1))\n        \n        # Check for non-physical parameters leading to Z=0\n        if Z0 == 0 or Z1 == 0:\n            return 0.0\n\n        F0 = -np.log(Z0) / beta\n        F1 = -np.log(Z1) / beta\n        delta_F = F1 - F0\n\n        # 4. Compute work distributions\n        PF_dist = get_work_distribution(E0, V0, E1, V1, beta, Z0)\n        PR_dist = get_work_distribution(E1, V1, E0, V0, beta, Z1)\n        \n        # 5. Compute max absolute deviation C(W)\n        c_abs_values = []\n        \n        pf_keys = set(PF_dist.keys())\n        pr_keys = set(PR_dist.keys())\n\n        # Find W where both P_F(W) and P_R(-W) are strictly positive\n        for W_f in pf_keys:\n            # Check if -W_f exists as a key in the reverse distribution\n            if round(-W_f, 12) in pr_keys:\n                pf_w = PF_dist[W_f]\n                pr_neg_w = PR_dist[round(-W_f, 12)]\n                \n                # Probabilities should be  0 by construction of the dictionaries\n                C_w = np.log(pf_w) - np.log(pr_neg_w) - beta * (W_f - delta_F)\n                c_abs_values.append(np.abs(C_w))\n\n        if not c_abs_values:\n            return 0.0\n\n        return max(c_abs_values)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, J0, h0, J1, h1, beta)\n        (3, 0.8, 1.0, 0.5, 0.3, 0.9),\n        (3, 0.4, 0.0, -0.7, 0.0, 1.2),\n        (4, 0.3, 0.9, 1.1, 0.6, 0.1),\n        (2, 1.0, 0.5, 0.2, 1.3, 3.0),\n        (3, 0.0, 0.7, 0.0, 1.4, 0.8)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, J0, h0, J1, h1, beta = case\n        result = calculate_crooks_deviation(N, J0, h0, J1, h1, beta)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.10e}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The standard Crooks fluctuation theorem relies on the assumption of microreversible dynamics, which is characteristic of isolated, unitary systems. This final exercise pushes the boundaries by introducing an environment that induces dephasing noise during the driving protocol. By simulating this open quantum system and quantifying the deviation from the standard Crooks relation , you will explore the deep connection between information, thermodynamics, and irreversibility, gaining insight into how fluctuation theorems are modified in more realistic, non-ideal scenarios.",
            "id": "3787449",
            "problem": "Consider a driven two-level quantum system (qubit) subject to dephasing noise during the drive. Let the system Hamiltonian be time dependent and defined by $H(t)$ that interpolates between an initial Hamiltonian $H(0)=H_0$ and a final Hamiltonian $H(T)=H_1$ over a total protocol duration $T$. Assume the following:\n\n- The Hilbert space is two dimensional with Pauli operators $\\sigma_x$, $\\sigma_y$, $\\sigma_z$.\n- Planck's constant is fixed as $\\hbar=1$, so all energies and frequencies are dimensionless and time is dimensionless.\n- The instantaneous Hamiltonian is given by\n$$\nH(t) = \\frac{1}{2}\\,\\omega(t)\\,\\big(\\cos\\phi(t)\\,\\sigma_z + \\sin\\phi(t)\\,\\sigma_x\\big),\n$$\nwith a linearly varying frequency $\\omega(t) = \\omega_0 + (\\omega_1 - \\omega_0)\\,t/T$ and a linearly varying axis angle $\\phi(t) = \\theta\\,t/T$, where $\\omega_00$, $\\omega_10$, and $\\theta$ are constants. Angles must be interpreted in radians.\n\n- The system starts from a canonical Gibbs state at inverse temperature $\\beta$ with respect to $H_0$, that is $\\rho_0 = \\exp(-\\beta H_0)/Z_0$ where $Z_0 = \\mathrm{Tr}[\\exp(-\\beta H_0)]$. In the reverse protocol, the system starts from the canonical Gibbs state at the same inverse temperature $\\beta$ with respect to $H_1$, that is $\\rho_1 = \\exp(-\\beta H_1)/Z_1$ with $Z_1 = \\mathrm{Tr}[\\exp(-\\beta H_1)]$.\n\n- The dynamics is constructed as a Trotterized sequence of unitary steps interlaced with a dephasing channel in the instantaneous energy eigenbasis. Over a small time step $\\Delta t$, the state is updated by\n    1. Unitary step: $\\rho \\mapsto U(t)\\,\\rho\\,U(t)^\\dagger$ with $U(t) = \\exp(-\\mathrm{i} H(t)\\,\\Delta t)$.\n    2. Dephasing step in the instantaneous energy eigenbasis of $H(t)$ with rate $\\gamma$:\n       If $H(t)$ has eigenvectors collected into the unitary matrix $V(t)$ so that $V(t)^\\dagger H(t) V(t) = \\mathrm{diag}(E_-(t),E_+(t))$, then after transforming to this basis, off-diagonal elements of the density matrix are multiplied by $e^{-\\gamma \\Delta t}$ while diagonal elements are left unchanged, and finally transformed back to the lab frame.\n\n- Work is defined by the Two-Point Measurement (TPM) scheme: for the forward protocol, an energy measurement of $H_0$ at $t=0$ projects onto $|n_0\\rangle$ with energy $E_n^{(0)}$, then the state is evolved under the noisy protocol to $t=T$ followed by an energy measurement of $H_1$ projecting onto $|m_1\\rangle$ with energy $E_m^{(1)}$. The realized work is $W = E_m^{(1)} - E_n^{(0)}$. For the reverse protocol, an energy measurement of $H_1$ at $t=0$ projects onto $|l_1\\rangle$ with energy $E_l^{(1)}$, then the state is evolved under the time-reversed protocol (same rule as forward but with $H(T-t)$ replacing $H(t)$) to $t=T$ and an energy measurement of $H_0$ projects onto $|k_0\\rangle$ with energy $E_k^{(0)}$. The realized reverse work is $W_{\\mathrm{rev}} = E_k^{(0)} - E_l^{(1)}$.\n\n- The forward work distribution $P_F(W)$ is the sum over all forward transitions weighted by their initial Gibbs probabilities and conditional transition probabilities. Similarly, the reverse work distribution $P_R(W_{\\mathrm{rev}})$ is defined for the reverse protocol.\n\nDefine the forward-reverse consistency deviation metric as follows. Compute the free energy difference\n$$\n\\Delta F = F_1 - F_0 = -\\frac{1}{\\beta}\\ln Z_1 + \\frac{1}{\\beta}\\ln Z_0,\n$$\nand for each work value $W$ that appears in the forward distribution, define\n$$\nQ(W) = \\ln P_F(W) - \\ln P_R(-W) - \\beta\\big(W - \\Delta F\\big).\n$$\nThe maximum absolute deviation is then\n$$\nD = \\max_{W}\\,\\big|Q(W)\\big|.\n$$\n\nYour task is to implement a numerical simulation of the above protocol using a midpoint Trotterization rule with $N$ uniform steps of size $\\Delta t = T/N$, computing both the forward and reverse TPM work distributions with dephasing as described, and then computing the deviation metric $D$.\n\nImplement the following specific test suite parameter sets to assess different facets:\n\n- Common parameters: $\\omega_0 = 1.0$, $\\omega_1 = 1.7$, $\\theta = 0.9$ (radians), $\\beta = 0.7$ (dimensionless), $T = 2.0$ (dimensionless), $N = 4000$ steps. Use the midpoint time $t_s = (s+0.5)\\Delta t$ for step $s = 0,1,\\ldots,N-1$.\n\n- Test cases for dephasing rate $\\gamma$:\n    1. Boundary case (no dephasing): $\\gamma = 0.0$.\n    2. Moderate dephasing (happy path): $\\gamma = 0.2$.\n    3. Strong dephasing (edge case): $\\gamma = 3.0$.\n\nScientific realism is ensured by using a physically plausible two-level time-dependent Hamiltonian and a standard phase-damping channel in the instantaneous energy basis. All energies and inverse temperatures are dimensionless in units where $\\hbar=1$, and angles are in radians. The program must return the deviation metric $D$ for each test case as dimensionless floating-point values.\n\nFinal output format requirement:\nYour program should produce a single line of output containing the computed results $[D_{\\gamma=0.0},D_{\\gamma=0.2},D_{\\gamma=3.0}]$ as a comma-separated list enclosed in square brackets, in the order of the test cases listed above. The entries must be floats. No other text should be printed.",
            "solution": "The problem requires the numerical calculation of a deviation metric from the Crooks fluctuation theorem for a driven two-level quantum system (qubit) subjected to dephasing noise. The solution involves simulating the quantum dynamics under both a forward and a time-reversed protocol, constructing the corresponding work distributions, and then computing the specified metric.\n\n### Theoretical Framework\n\n**1. System Hamiltonian and Eigen-structure**\n\nThe system is described by a time-dependent Hamiltonian on a two-dimensional Hilbert space, given by:\n$$\nH(t) = \\frac{1}{2}\\,\\omega(t)\\,\\big(\\cos\\phi(t)\\,\\sigma_z + \\sin\\phi(t)\\,\\sigma_x\\big)\n$$\nwhere $\\sigma_x$ and $\\sigma_z$ are the standard Pauli matrices. The time-dependent parameters are a linearly interpolated frequency $\\omega(t) = \\omega_0 + (\\omega_1 - \\omega_0)\\,t/T$ and a linearly growing angle $\\phi(t) = \\theta\\,t/T$.\n\nThe Hamiltonian can be written as $H(t) = \\vec{h}(t) \\cdot \\vec{\\sigma}$ with $\\vec{h}(t) = \\frac{1}{2}\\omega(t) (\\sin\\phi(t), 0, \\cos\\phi(t))$. The instantaneous eigenvalues are given by $E_\\pm(t) = \\pm|\\vec{h}(t)|$. Since $\\sin^2\\phi + \\cos^2\\phi = 1$, the eigenvalues are:\n$$\nE_\\pm(t) = \\pm\\frac{1}{2}\\,\\omega(t)\n$$\nThe corresponding instantaneous eigenvectors, $|E_\\pm(t)\\rangle$, form the energy eigenbasis at time $t$. The initial Hamiltonian is $H_0 = H(0)$ with eigenvalues $\\pm\\frac{1}{2}\\omega_0$, and the final Hamiltonian is $H_1 = H(T)$ with eigenvalues $\\pm\\frac{1}{2}\\omega_1$.\n\n**2. Initial States and Free Energy**\n\nThe system is initially in a canonical Gibbs state at inverse temperature $\\beta$. For the forward protocol, the initial state is $\\rho_0 = \\exp(-\\beta H_0)/Z_0$, where $Z_0$ is the partition function:\n$$\nZ_0 = \\mathrm{Tr}\\left[e^{-\\beta H_0}\\right] = e^{-\\beta E_+(0)} + e^{-\\beta E_-(0)} = e^{-\\beta \\omega_0/2} + e^{\\beta \\omega_0/2} = 2\\cosh\\left(\\frac{\\beta\\omega_0}{2}\\right)\n$$\nSimilarly, for the reverse protocol, the initial state is with respect to $H_1$, with partition function $Z_1 = 2\\cosh(\\frac{\\beta\\omega_1}{2})$.\n\nThe Helmholtz free energy difference between the final and initial equilibrium states is defined as $\\Delta F = F_1 - F_0 = -\\frac{1}{\\beta}(\\ln Z_1 - \\ln Z_0)$.\n\n**3. The Two-Point Measurement (TPM) Scheme and Work Distributions**\n\nWork is defined stochastically via the TPM scheme.\nFor the **forward protocol**:\n1. At $t=0$, measure the energy of the system with respect to $H_0$. The system is projected into an eigenstate $|E_i^{(0)}\\rangle$ of $H_0$ with energy $E_i^{(0)}$ and probability $p_i^{(0)} = e^{-\\beta E_i^{(0)}}/Z_0$.\n2. Evolve the state from $t=0$ to $t=T$ under the specified dynamics. The initial pure state $|E_i^{(0)}\\rangle\\langle E_i^{(0)}|$ evolves into a final density matrix $\\rho_i^{(T)}$.\n3. At $t=T$, measure the energy with respect to $H_1$. The probability of obtaining outcome $E_j^{(1)}$ is $P(j|i) = \\mathrm{Tr}\\left[ \\Pi_j^{(1)} \\rho_i^{(T)} \\right]$, where $\\Pi_j^{(1)}$ is the projector onto the eigenstate $|E_j^{(1)}\\rangle$.\n4. The work performed in this realization is $W = E_j^{(1)} - E_i^{(0)}$. The total probability of this work value is $P_F(W) = \\sum_{i,j \\text{ s.t. } E_j^{(1)}-E_i^{(0)}=W} p_i^{(0)} P(j|i)$.\n\nThe **reverse protocol** follows an analogous procedure, starting from a Gibbs state with respect to $H_1$, evolving under the time-reversed Hamiltonian protocol $H(T-t)$, and finally measuring energy with respect to $H_0$. This yields the reverse work distribution $P_R(W_{\\text{rev}})$.\n\n**4. The Crooks Fluctuation Theorem and Deviation Metric**\n\nFor a closed quantum system undergoing unitary evolution, the Crooks fluctuation theorem provides a fundamental relationship between the forward and reverse work distributions:\n$$\n\\frac{P_F(W)}{P_R(-W)} = e^{\\beta(W - \\Delta F)}\n$$\nRearranging this gives $\\ln P_F(W) - \\ln P_R(-W) - \\beta(W - \\Delta F) = 0$. The problem defines the quantity $Q(W)$ as precisely this expression. In the presence of non-unitary dynamics, such as the dephasing channel, this equality is not expected to hold. The deviation metric $D = \\max_W |Q(W)|$ quantifies the extent of the violation of the Crooks relation. A non-zero $D$ is a signature of the system's open-ness and the irreversibility introduced by the environment.\n\n### Numerical Implementation\n\nThe continuous-time dynamics are approximated using a Trotterized evolution over $N$ discrete time steps of size $\\Delta t = T/N$.\n\n**1. Discretized Evolution Step**\n\nAt each step $s$ (from $s=0$ to $N-1$), the density matrix $\\rho$ is updated using the Hamiltonian evaluated at the midpoint time $t_s = (s+0.5)\\Delta t$. The update consists of two sub-steps:\n\na. **Unitary Evolution:** The state evolves under the Hamiltonian $H(t_s)$ for a duration $\\Delta t$.\n$$\n\\rho \\mapsto U(t_s) \\rho U(t_s)^\\dagger, \\quad \\text{where} \\quad U(t_s) = e^{-i H(t_s) \\Delta t}\n$$\nThe matrix exponential is computed numerically.\n\nb. **Dephasing Channel:** This step models energy damping in the instantaneous energy basis of $H(t_s)$.\n   i. Diagonalize the Hamiltonian: $H(t_s) = V_s D_s V_s^\\dagger$, where $V_s$ is the matrix of eigenvectors.\n   ii. Transform the density matrix to the energy eigenbasis: $\\tilde{\\rho} = V_s^\\dagger \\rho V_s$.\n   iii. Apply dephasing by suppressing the off-diagonal elements (coherences):\n      $$\n      \\tilde{\\rho}_{ij} \\mapsto \\tilde{\\rho}_{ij} \\times \\begin{cases} 1  \\text{if } i=j \\\\ e^{-\\gamma \\Delta t}  \\text{if } i \\neq j \\end{cases}\n      $$\n   iv. Transform back to the original basis: $\\rho \\mapsto V_s \\tilde{\\rho} V_s^\\dagger$.\n\n**2. Simulating Forward and Reverse Protocols**\n\nThe full evolution is the composition of these $N$ steps. To build the work distributions, we must evolve the initial energy projectors.\n\n- **Forward Protocol:** The two projectors onto the eigenstates of $H_0$, $\\{|E_i^{(0)}\\rangle\\langle E_i^{(0)}|\\}$, are each evolved for $N$ steps using the Hamiltonian sequence $H(t_s)$. This yields two final density matrices $\\{\\rho_i^{(T)}\\}$. The work probabilities are then computed using the TPM formula.\n\n- **Reverse Protocol:** The projectors onto the eigenstates of $H_1$, $\\{|E_k^{(1)}\\rangle\\langle E_k^{(1)}|\\}$, are evolved. The Hamiltonian sequence for the reverse protocol at step $s$ is $H(T-t_s)$. The resulting final states are used to compute the reverse work distribution. It can be shown that the sequence of Hamiltonians for the midpoint rule, $\\{H(T-t_s)\\}_{s=0}^{N-1}$, is a time-reversed sequence of the forward set, $\\{H(t_s)\\}_{s=0}^{N-1}$. Specifically, $T-t_s = t_{N-1-s}$. This ordering is critical for correctly testing the Crooks relation.\n\n**3. Calculation of the Deviation Metric $D$**\n\nWith the complete dictionaries for $P_F(W)$ and $P_R(W_{\\text{rev}})$, we can calculate $D$.\n1. Compute the free energy difference $\\Delta F$.\n2. For each work value $W$ appearing in the forward distribution (i.e., $P_F(W)0$):\n   a. Retrieve $P_F(W)$ and $P_R(-W)$.\n   b. Calculate $Q(W) = \\ln P_F(W) - \\ln P_R(-W) - \\beta(W-\\Delta F)$.\n3. The deviation is the maximum absolute value among all calculated $Q(W)$ values: $D = \\max_W |Q(W)|$.\n\nFor the case $\\gamma=0$, the evolution is unitary up to the Trotter error. The specific choice of midpoint Trotterization does not perfectly satisfy the time-reversal property required for the discrete Crooks relation to hold exactly ($U_{\\text{rev,Trot}} \\neq U_{\\text{fwd,Trot}}^\\dagger$), so a small non-zero $D$ is expected. For $\\gamma  0$, the dephasing introduces genuine irreversibility, and $D$ is expected to increase significantly with $\\gamma$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the deviation from the Crooks relation for a driven, dephasing qubit.\n    \"\"\"\n\n    # Common parameters for all test cases\n    w0 = 1.0\n    w1 = 1.7\n    theta = 0.9  # radians\n    beta = 0.7   # dimensionless inverse temperature\n    T = 2.0      # dimensionless total time\n    N = 4000     # number of Trotter steps\n    \n    # Test cases for the dephasing rate gamma\n    gamma_cases = [0.0, 0.2, 3.0]\n    \n    # Pauli matrices (using complex numbers for consistency)\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n\n    def get_hamiltonian(t, w0_p, w1_p, T_p, theta_p):\n        \"\"\"Constructs the Hamiltonian H(t).\"\"\"\n        w_t = w0_p + (w1_p - w0_p) * t / T_p\n        phi_t = theta_p * t / T_p\n        return 0.5 * w_t * (np.cos(phi_t) * sigma_z + np.sin(phi_t) * sigma_x)\n\n    def run_protocol(initial_projector, gamma, is_forward):\n        \"\"\"Evolves an initial state according to the specified protocol.\"\"\"\n        rho = initial_projector.copy()\n        dt = T / N\n        \n        for s in range(N):\n            t_mid = (s + 0.5) * dt\n            \n            if is_forward:\n                current_t = t_mid\n            else: # Reverse protocol\n                current_t = T - t_mid\n\n            H_s = get_hamiltonian(current_t, w0, w1, T, theta)\n\n            # 1. Unitary step\n            U_s = expm(-1j * H_s * dt)\n            rho = U_s @ rho @ U_s.conj().T\n\n            # 2. Dephasing step (only if gamma  0)\n            if gamma  0:\n                _evals, evecs = np.linalg.eigh(H_s)\n                \n                # Transform to energy eigenbasis\n                rho_eb = evecs.conj().T @ rho @ evecs\n\n                # Apply dephasing\n                dephasing_factor = np.exp(-gamma * dt)\n                rho_eb[0, 1] *= dephasing_factor\n                rho_eb[1, 0] *= dephasing_factor\n                \n                # Transform back to lab frame\n                rho = evecs @ rho_eb @ evecs.conj().T\n        \n        return rho\n\n    results = []\n    for gamma in gamma_cases:\n        # --- Initial and Final Setup ---\n        H0 = get_hamiltonian(0.0, w0, w1, T, theta)\n        H1 = get_hamiltonian(T, w0, w1, T, theta)\n\n        evals0, evecs0 = np.linalg.eigh(H0)\n        evals1, evecs1 = np.linalg.eigh(H1)\n\n        Z0 = np.sum(np.exp(-beta * evals0))\n        Z1 = np.sum(np.exp(-beta * evals1))\n        \n        delta_F = (-1 / beta) * (np.log(Z1) - np.log(Z0))\n\n        # --- Forward Protocol Simulation ---\n        p0_forward = np.exp(-beta * evals0) / Z0\n        initial_projectors_fwd = [np.outer(v, v.conj()) for v in evecs0.T]\n\n        PF_map = {}\n        for i, proj0 in enumerate(initial_projectors_fwd):\n            final_rho_i = run_protocol(proj0, gamma, is_forward=True)\n            for j in range(2):\n                final_projector_j = np.outer(evecs1[:,j], evecs1[:,j].conj())\n                prob_j_given_i = np.real(np.trace(final_projector_j @ final_rho_i))\n                \n                work = evals1[j] - evals0[i]\n                total_prob = p0_forward[i] * prob_j_given_i\n                PF_map[work] = PF_map.get(work, 0) + total_prob\n\n        # --- Reverse Protocol Simulation ---\n        p0_reverse = np.exp(-beta * evals1) / Z1\n        initial_projectors_rev = [np.outer(v, v.conj()) for v in evecs1.T]\n        \n        PR_map = {}\n        for k, proj1 in enumerate(initial_projectors_rev):\n            final_rho_k = run_protocol(proj1, gamma, is_forward=False)\n            for l in range(2):\n                final_projector_l = np.outer(evecs0[:,l], evecs0[:,l].conj())\n                prob_l_given_k = np.real(np.trace(final_projector_l @ final_rho_k))\n                \n                work_rev = evals0[l] - evals1[k]\n                total_prob_rev = p0_reverse[k] * prob_l_given_k\n                PR_map[work_rev] = PR_map.get(work_rev, 0) + total_prob_rev\n\n        # --- Calculate Deviation Metric D ---\n        Q_values = []\n        for work, pf_w in PF_map.items():\n            neg_work = -work\n            # Find the closest key in PR_map due to potential float precision issues\n            closest_neg_work_key = min(PR_map.keys(), key=lambda k: abs(k - neg_work))\n            if abs(closest_neg_work_key - neg_work) > 1e-9:\n                pr_neg_w = 0.0\n            else:\n                pr_neg_w = PR_map.get(closest_neg_work_key, 0.0)\n\n            if pf_w > 1e-15 and pr_neg_w > 1e-15:\n                q_val = np.log(pf_w) - np.log(pr_neg_w) - beta * (work - delta_F)\n                Q_values.append(q_val)\n        \n        deviation_D = np.max(np.abs(Q_values)) if Q_values else 0.0\n        results.append(deviation_D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}