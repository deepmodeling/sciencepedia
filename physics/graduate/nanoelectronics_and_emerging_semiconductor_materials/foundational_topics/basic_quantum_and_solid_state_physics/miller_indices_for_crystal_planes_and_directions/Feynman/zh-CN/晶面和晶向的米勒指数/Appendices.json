{
    "hands_on_practices": [
        {
            "introduction": "理解米勒指数最基本的方法是探究其如何直接源于晶面在空间中的几何方位。本练习旨在巩固这一定义，通过从晶格中的三个特定点出发，推导包含这些点的晶面方程，并最终确定其米勒指数。这个过程不仅能加深您对晶面截距定义的理解，还能锻炼您在晶体学背景下应用矢量代数解决问题的能力。",
            "id": "2779321",
            "problem": "在与纳米力学以及表面和界面科学相关的立方晶体中，原子平面决定了滑移、附着和界面能。考虑一个具有晶格矢量 $\\mathbf{a}_{1}$、$\\mathbf{a}_{2}$ 和 $\\mathbf{a}_{3}$ 的传统立方布拉菲晶格。分数（简约）坐标 $(u,v,w)$ 表示点 $\\mathbf{r} = u\\,\\mathbf{a}_{1} + v\\,\\mathbf{a}_{2} + w\\,\\mathbf{a}_{3}$。一个实验确定的原子平面经过分数坐标为 $(1,0,0)$、$(0,\\tfrac{1}{2},0)$ 和 $(0,0,\\tfrac{1}{3})$ 的 3 个轴截距点。从米勒指数 $(h\\,k\\,l)$ 的核心定义出发，即用与晶面在晶轴上截距的倒数成正比的最小整数集来标记晶面，完成以下任务：\n- 在分数坐标空间 $(u,v,w)$ 中，推导经过给定三点的唯一平面的方程。仅使用矢量代数和三维空间中平面的定义来建立平面方程，并由此确认这三点的共面性。\n- 从您推导出的平面方程中，根据定义确定米勒指数 $(h\\,k\\,l)$，即没有公约数的最小整数。\n\n将您的最终答案以单行矩阵 $\\bigl(h\\;k\\;l\\bigr)$ 的形式报告为米勒指数三元组。不包括单位。无需四舍五入。",
            "solution": "我们从三维空间中平面的基本几何描述开始。给定三个不共线的点，存在一个包含它们的唯一平面。在与立方晶轴相关的分数坐标空间 $(u,v,w)$ 中，这三个点是\n$$(u_{1},v_{1},w_{1}) = (1,0,0), \\quad (u_{2},v_{2},w_{2}) = \\left(0,\\tfrac{1}{2},0\\right), \\quad (u_{3},v_{3},w_{3}) = \\left(0,0,\\tfrac{1}{3}\\right)。$$\n在平面内定义两个独立的方向矢量：\n$$\\mathbf{v}_{1} = (u_{2}-u_{1},\\,v_{2}-v_{1},\\,w_{2}-w_{1}) = \\left(-1,\\,\\tfrac{1}{2},\\,0\\right),$$\n$$\\mathbf{v}_{2} = (u_{3}-u_{1},\\,v_{3}-v_{1},\\,w_{3}-w_{1}) = \\left(-1,\\,0,\\,\\tfrac{1}{3}\\right)。$$\n平面的法向量 $\\mathbf{n}$ 由叉积 $\\mathbf{n} = \\mathbf{v}_{1} \\times \\mathbf{v}_{2}$ 给出。计算\n$$\\mathbf{n} = \n\\begin{vmatrix}\n\\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\\n-1  \\tfrac{1}{2}  0 \\\\\n-1  0  \\tfrac{1}{3}\n\\end{vmatrix}\n= \\mathbf{i}\\left(\\tfrac{1}{2}\\cdot\\tfrac{1}{3} - 0\\cdot 0\\right) - \\mathbf{j}\\left((-1)\\cdot\\tfrac{1}{3} - 0\\cdot(-1)\\right) + \\mathbf{k}\\left((-1)\\cdot 0 - \\tfrac{1}{2}\\cdot(-1)\\right)。$$\n因此\n$$\\mathbf{n} = \\left(\\tfrac{1}{6},\\,\\tfrac{1}{3},\\,\\tfrac{1}{2}\\right)。$$\n乘以 $6$（一个非零标量）得到一个成比例的整数法向量\n$$\\mathbf{n}' = (1,\\,2,\\,3)。$$\n一个法向量为 $\\mathbf{n}'$ 且经过点 $(u_{1},v_{1},w_{1})=(1,0,0)$ 的平面方程为\n$$\\mathbf{n}'\\cdot\\bigl[(u,v,w)-(1,0,0)\\bigr] = 0。$$\n展开得到\n$$(1,2,3)\\cdot(u-1,\\,v-0,\\,w-0) = 0 \\;\\;\\Rightarrow\\;\\; 1\\cdot(u-1) + 2\\cdot v + 3\\cdot w = 0,$$\n化简为\n$$u + 2v + 3w = 1。$$\n这就是在分数坐标空间中的平面方程。代入给定的三个点中的每一个点来确认共面性：\n- 对于 $(1,0,0)$：$1 + 2\\cdot 0 + 3\\cdot 0 = 1$，满足。\n- 对于 $\\left(0,\\tfrac{1}{2},0\\right)$：$0 + 2\\cdot \\tfrac{1}{2} + 0 = 1$，满足。\n- 对于 $\\left(0,0,\\tfrac{1}{3}\\right)$：$0 + 0 + 3\\cdot \\tfrac{1}{3} = 1$，满足。\n因此，这三个点共面并定义了这个唯一的平面。\n\n为了得到米勒指数 $(h\\,k\\,l)$，使用核心定义：它们与平面在晶轴上的分数截距的倒数成正比。从平面方程 $u + 2v + 3w = 1$ 中，通过将两个坐标设为零来找到截距：\n- $u$-截距：设 $v=0$ 和 $w=0$，得到 $u=1$。\n- $v$-截距：设 $u=0$ 和 $w=0$，得到 $2v=1 \\Rightarrow v=\\tfrac{1}{2}$。\n- $w$-截距：设 $u=0$ 和 $v=0$，得到 $3w=1 \\Rightarrow w=\\tfrac{1}{3}$。\n取倒数得到与 $(h\\,k\\,l)$ 成正比的三元组：\n$$\\left(\\frac{1}{1},\\,\\frac{1}{1/2},\\,\\frac{1}{1/3}\\right) = (1,\\,2,\\,3)。$$\n这些已经是没有公约数的最小整数，因此米勒指数为 $(1\\,2\\,3)$。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  2  3\\end{pmatrix}}$$"
        },
        {
            "introduction": "在我们掌握了如何描述单个晶面之后，下一步便是探究不同晶面之间的几何关系。本练习将引导您解决一个在材料表征中常见的实际问题：确定“晶带轴”，即两个晶面相交所形成的共同方向。这项技能对于在透射电子显微镜（TEM）中解译电子衍射图谱至关重要，它将米勒指数的概念与实验观测紧密联系起来。",
            "id": "2779320",
            "problem": "在晶格常数相等的立方晶体的透射电子显微镜（Transmission Electron Microscopy (TEM)）取向操作中，一个常见的实验任务是确定两个晶格平面共有的晶带轴。考虑一个立方晶体，其正晶格基矢与一个标准正交笛卡尔坐标系对齐，且两个平面由米勒指数 $\\left(1\\ 1\\ 0\\right)$ 和 $\\left(1\\ \\bar{1}\\ 0\\right)$ 标定。从第一性原理出发：\n\n- 在立方晶体中，使用平面的米勒指数定义，将平面法线与相应的晶向关联起来。\n- 使用正交性和基本矢量代数来获得两平面交线（即晶带轴）的方向。\n- 利用该晶带轴方向，通过计算其与晶向 $\\left[0\\ 0\\ 1\\right]$ 之间夹角 $\\theta$ 的余弦值，来评估两者间的平行性。\n\n报告标量 $\\left|\\cos\\theta\\right|$ 的精确值作为一个无量纲数作为你的最终答案。不要对答案进行四舍五入。角度 $\\theta$ 应以弧度计，但你不能报告 $\\theta$；只报告 $\\left|\\cos\\theta\\right|$ 的精确值。",
            "solution": "对于立方晶系，其基本原理是：正晶格基矢 $\\vec{a}_1, \\vec{a}_2, \\vec{a}_3$ 相互正交且长度相等（设为 $a$），带有米勒指数 $(h\\ k\\ l)$ 的平面的法线平行于晶向 $[h\\ k\\ l]$。问题指明正晶格基矢与一个标准正交笛卡尔坐标系对齐，这使我们能够在该坐标系中将晶向表示为矢量，而无需进行坐标变换。\n\n设两个给定的平面为 $P_1$ 和 $P_2$，其米勒指数分别为 $(h_1\\ k_1\\ l_1) = (1\\ 1\\ 0)$ 和 $(h_2\\ k_2\\ l_2) = (1\\ \\bar{1}\\ 0)$。记号 $\\bar{1}$ 等价于 $-1$。\n\n平面 $P_1$ 的法向量方向，记为 $\\vec{n}_1$，由晶向 $[1\\ 1\\ 0]$ 给出。在笛卡尔坐标系中，我们可以将此向量写为：\n$$\n\\vec{n}_1 = 1\\hat{i} + 1\\hat{j} + 0\\hat{k}\n$$\n类似地，平面 $P_2$ 的法向量方向，记为 $\\vec{n}_2$，由晶向 $[1\\ \\bar{1}\\ 0]$ 给出。在笛卡尔坐标系中，此向量为：\n$$\n\\vec{n}_2 = 1\\hat{i} - 1\\hat{j} + 0\\hat{k}\n$$\n根据定义，晶带轴是两平面 $P_1$ 和 $P_2$ 的交线。沿此线的矢量，我们记为 $\\vec{v}_{za}$，必须同时垂直于两个平面法线 $\\vec{n}_1$ 和 $\\vec{n}_2$。这样的矢量可以通过计算 $\\vec{n}_1$ 和 $\\vec{n}_2$ 的矢量叉积得到。\n$$\n\\vec{v}_{za} = \\vec{n}_1 \\times \\vec{n}_2\n$$\n我们通过计算一个矩阵的行列式来计算这个叉积，该矩阵的第一行是笛卡尔单位矢量，后续行是 $\\vec{n}_1$ 和 $\\vec{n}_2$ 的分量：\n$$\n\\vec{v}_{za} = \\begin{vmatrix}\n\\hat{i}  \\hat{j}  \\hat{k} \\\\\nh_1  k_1  l_1 \\\\\nh_2  k_2  l_2\n\\end{vmatrix} = \\begin{vmatrix}\n\\hat{i}  \\hat{j}  \\hat{k} \\\\\n1  1  0 \\\\\n1  -1  0\n\\end{vmatrix}\n$$\n展开行列式，我们得到 $\\vec{v}_{za}$ 的分量：\n$$\n\\vec{v}_{za} = \\hat{i}((1)(0) - (0)(-1)) - \\hat{j}((1)(0) - (0)(1)) + \\hat{k}((1)(-1) - (1)(1))\n$$\n$$\n\\vec{v}_{za} = \\hat{i}(0) - \\hat{j}(0) + \\hat{k}(-1 - 1) = -2\\hat{k}\n$$\n代表晶带轴的矢量是 $\\vec{v}_{za} = [0\\ 0\\ -2]$。在晶体学中，方向指数要约化为最小整数集。因此，方向 $[0\\ 0\\ -2]$ 等效于方向 $[0\\ 0\\ \\bar{1}]$。\n\n问题要求我们评估此晶带轴与晶向 $[0\\ 0\\ 1]$ 之间的平行性。我们将后一个方向用矢量 $\\vec{v}_{ref}$ 表示：\n$$\n\\vec{v}_{ref} = 0\\hat{i} + 0\\hat{j} + 1\\hat{k} = \\hat{k}\n$$\n两个矢量 $\\vec{A}$ 和 $\\vec{B}$ 之间的夹角 $\\theta$ 与它们的点积和模长通过以下公式相关联：\n$$\n\\cos\\theta = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{A}| |\\vec{B}|}\n$$\n我们将此公式应用于我们的矢量 $\\vec{v}_{za}$ 和 $\\vec{v}_{ref}$：\n$$\n\\cos\\theta = \\frac{\\vec{v}_{za} \\cdot \\vec{v}_{ref}}{|\\vec{v}_{za}| |\\vec{v}_{ref}|}\n$$\n首先，我们计算点积：\n$$\n\\vec{v}_{za} \\cdot \\vec{v}_{ref} = (0)(0) + (0)(0) + (-2)(1) = -2\n$$\n接下来，我们计算矢量的模长：\n$$\n|\\vec{v}_{za}| = \\sqrt{0^2 + 0^2 + (-2)^2} = \\sqrt{4} = 2\n$$\n$$\n|\\vec{v}_{ref}| = \\sqrt{0^2 + 0^2 + 1^2} = \\sqrt{1} = 1\n$$\n将这些值代回余弦公式：\n$$\n\\cos\\theta = \\frac{-2}{(2)(1)} = -1\n$$\n问题要求 $|\\cos\\theta|$ 的值。\n$$\n|\\cos\\theta| = |-1| = 1\n$$\n$|\\cos\\theta| = 1$ 的值表明两个方向是平行的（同向或反向）。此处，由于 $\\cos\\theta = -1$，夹角 $\\theta = \\pi$ 弧度，意味着方向 $[0\\ 0\\ \\bar{1}]$ 和 $[0\\ 0\\ 1]$ 是反平行的，这也是作为直线而言平行的特殊情况。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "为了从理想化的简单晶系过渡到真实材料的复杂性，我们必须处理非正交晶格。这项高级计算练习引入了“度量矩阵”，这是一个在任何晶系中精确计算晶面间距和夹角等几何性质的强大工具。通过本练习，您将把理论知识与实验数据分析相结合，通过编写一个最小二乘法拟合程序来鉴定未知的晶面，从而掌握一项在现代晶体学研究中不可或缺的计算技能。",
            "id": "4287493",
            "problem": "您的任务是实现一个程序，该程序使用晶体学度规矩阵计算候选米勒指数的晶面间距和晶面夹角，然后使用最小二乘法选择与实验数据最佳拟合的结果。其背景是分析纳米电子和新兴半导体材料中的晶面，在这些材料中，严格的度规处理对于处理非立方晶格至关重要。您的算法必须从第一性原理和经过充分检验的定义出发。\n\n定义和基本原理：\n- 正晶格参数是长度 $a$、 $b$、 $c$ 和角度 $\\alpha$、 $\\beta$、 $\\gamma$，其中 $\\alpha$ 是 $\\mathbf{b}$ 和 $\\mathbf{c}$ 之间的夹角，$\\beta$ 是 $\\mathbf{a}$ 和 $\\mathbf{c}$ 之间的夹角，$\\gamma$ 是 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的夹角。\n- 正度规矩阵 $G$ 编码了正晶格基矢的内积，其表达式为\n$$\nG = \\begin{bmatrix}\na^2  a b \\cos \\gamma  a c \\cos \\beta \\\\\na b \\cos \\gamma  b^2  b c \\cos \\alpha \\\\\na c \\cos \\beta  b c \\cos \\alpha  c^2\n\\end{bmatrix}.\n$$\n- 倒易度规矩阵 $G^{\\ast}$ 是 $G$ 的逆矩阵，即 $G^{\\ast} = G^{-1}$。这源于倒易基矢 $\\mathbf{a}^{\\ast}$、 $\\mathbf{b}^{\\ast}$、 $\\mathbf{c}^{\\ast}$ 的定义，它们满足 $\\mathbf{a}^{\\ast} \\cdot \\mathbf{a} = 1$，$\\mathbf{a}^{\\ast} \\cdot \\mathbf{b} = 0$ 等，并得出 $G G^{\\ast} = I$。\n- 对于一个具有米勒指数 $(h,k,l)$ 的晶面，其对应的倒易晶格矢量为 $\\mathbf{H} = h \\mathbf{a}^{\\ast} + k \\mathbf{b}^{\\ast} + l \\mathbf{c}^{\\ast}$，其范数的平方计算如下\n$$\n\\lVert \\mathbf{H} \\rVert^2 = \\begin{bmatrix} h  k  l \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h \\\\ k \\\\ l \\end{bmatrix}.\n$$\n- 晶面间距为 $d_{hkl} = \\frac{1}{\\lVert \\mathbf{H} \\rVert}$，如果 $a$、 $b$、 $c$ 以埃（Å）为单位，则其单位也为埃（Å）。\n- 两个晶面 $(h_1,k_1,l_1)$ 和 $(h_2,k_2,l_2)$ 之间的夹角是它们在倒易空间中法线之间的夹角：\n$$\n\\cos \\phi = \\frac{\\mathbf{H}_1 \\cdot \\mathbf{H}_2}{\\lVert \\mathbf{H}_1 \\rVert \\, \\lVert \\mathbf{H}_2 \\rVert} = \\frac{\\begin{bmatrix} h_1  k_1  l_1 \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h_2 \\\\ k_2 \\\\ l_2 \\end{bmatrix}}{\\sqrt{\\begin{bmatrix} h_1  k_1  l_1 \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h_1 \\\\ k_1 \\\\ l_1 \\end{bmatrix}} \\, \\sqrt{\\begin{bmatrix} h_2  k_2  l_2 \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h_2 \\\\ k_2 \\\\ l_2 \\end{bmatrix}}}.\n$$\n角度 $\\phi$ 必须以度为单位报告。\n\n目标和最小二乘法：\n- 您将获得一组实验晶面间距 $d_i$（对于 $i = 1,\\dots,N$，单位为埃 Å）和一组针对指定指数对 $(i_p, j_p)$ 的实验晶面夹角 $\\phi_p$（单位为度）。\n- 对于每个间距 $d_i$，提供一个小的候选米勒指数集合 $\\{(h,k,l)\\}$。\n- 您的目标是为每个 $i$ 从其候选集中精确选择一个三元组 $(h_i,k_i,l_i)$，使得计算出的间距和角度在归一化最小二乘意义上与实验值最佳拟合。\n- 定义间距的归一化残差平方为\n$$\nr_{d,i}^2 = \\left( \\frac{d_{\\text{calc},i} - d_{\\text{exp},i}}{d_{\\text{exp},i}} \\right)^2,\n$$\n角度的归一化残差平方为\n$$\nr_{\\phi,p}^2 = \\left( \\frac{\\phi_{\\text{calc},p} - \\phi_{\\text{exp},p}}{180} \\right)^2,\n$$\n其中 $d_{\\text{calc},i}$ 和 $\\phi_{\\text{calc},p}$ 是根据上述度规矩阵计算得出的。总平方和为\n$$\nS = \\sum_{i=1}^{N} r_{d,i}^2 + \\sum_{p=1}^{P} r_{\\phi,p}^2.\n$$\n- 选择使 $S$ 最小化的指数组合。报告均方根（RMS）误差\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{S}{N + P}}.\n$$\n\n单位：\n- 所有晶面间距 $d_{hkl}$ 必须以埃（Å）为单位进行计算和比较。\n- 所有角度必须以度为单位进行计算和比较。\n\n程序要求：\n- 实现从 $(a,b,c,\\alpha,\\beta,\\gamma)$ 计算 $G$ 和 $G^{\\ast}$。\n- 使用度规矩阵实现 $d_{hkl}$ 和 $\\phi$ 的计算。\n- 对于每个测试用例，枚举候选指数的所有组合（笛卡尔积），并选择使 $S$ 最小化的组合。\n- 计算并报告所选组合的 RMS 误差。\n\n测试套件：\n为下面的所有测试用例提供解决方案。您的程序必须硬编码这些案例，并以末尾指定的精确最终格式生成输出。\n\n测试用例1（类六方纤锌矿）：\n- 晶格参数：$a = 3.189\\ \\text{Å}$，$b = 3.189\\ \\text{Å}$，$c = 5.185\\ \\text{Å}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 120^\\circ$。\n- 实验间距 (Å)：$[2.760, 2.595, 2.440, 1.590]$。\n- 角度对和实验角度 (度)：指数 $i=0$ 和 $j=1$ 之间：$90.3^\\circ$；指数 $i=0$ 和 $j=3$ 之间：$30.1^\\circ$。\n- 每个间距 $i$ 的候选集：\n  - $i=0$: $\\{(1,0,0), (0,0,2), (1,1,0)\\}$。\n  - $i=1$: $\\{(0,0,2), (1,0,1), (1,1,0)\\}$。\n  - $i=2$: $\\{(1,0,1), (1,1,1), (0,0,3)\\}$。\n  - $i=3$: $\\{(1,1,0), (2,0,0), (0,0,4)\\}$。\n\n测试用例2（类四方金红石）：\n- 晶格参数：$a = 4.5937\\ \\text{Å}$，$b = 4.5937\\ \\text{Å}$，$c = 2.9587\\ \\text{Å}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$。\n- 实验间距 (Å)：$[3.249, 2.487, 2.300]$。\n- 角度对和实验角度 (度)：$i=0$ 和 $j=1$ 之间：$67.6^\\circ$；$i=1$ 和 $j=2$ 之间：$57.2^\\circ$。\n- 候选集：\n  - $i=0$: $\\{(1,1,0), (2,0,0), (2,1,1)\\}$。\n  - $i=1$: $\\{(1,0,1), (2,1,0), (1,1,2)\\}$。\n  - $i=2$: $\\{(2,0,0), (0,0,2), (1,1,1)\\}$。\n\n测试用例3（类正交层状）：\n- 晶格参数：$a = 3.313\\ \\text{Å}$，$b = 10.473\\ \\text{Å}$，$c = 4.374\\ \\text{Å}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$。\n- 实验间距 (Å)：$[5.220, 2.186, 1.656]$。\n- 角度对和实验角度 (度)：$i=0$ 和 $j=2$ 之间：$90.0^\\circ$；$i=1$ 和 $j=2$ 之间：$90.0^\\circ$。\n- 候选集：\n  - $i=0$: $\\{(0,2,0), (0,1,0), (1,0,0)\\}$。\n  - $i=1$: $\\{(0,0,2), (1,0,1), (0,1,1)\\}$。\n  - $i=2$: $\\{(2,0,0), (1,1,0), (0,0,3)\\}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，输出一个列表，其元素是按 $i=0$ 到 $N-1$ 顺序排列的所选米勒指数列表，后跟四舍五入到六位小数的 RMS 误差。例如：\n\"[[[h0,k0,l0],[h1,k1,l1],...,rms_case1],[[...],rms_case2],[[...],rms_case3]]\"。\n不应打印任何附加文本。",
            "solution": "求解方法包括三个主要阶段：\n1.  **度规张量构建：** 对于由参数 $a$、$b$、$c$、$\\alpha$、$\\beta$、$\\gamma$ 定义的给定晶格，构建正度规张量 $G$。该矩阵封装了正晶格基矢的几何结构。然后计算倒易度规张量 $G^{\\ast} = G^{-1}$。$G^{\\ast}$ 是在倒易空间中执行计算的基本算子。\n2.  **倒易空间计算：** 计算出的 $G^{\\ast}$ 用于确定任何给定米勒指数集 $(h,k,l)$ 的理论晶面间距和角度值。\n    - 晶面间距 $d_{hkl}$ 是倒易晶格矢量 $\\mathbf{H} = h \\mathbf{a}^{\\ast} + k \\mathbf{b}^{\\ast} + l \\mathbf{c}^{\\ast}$ 大小的倒数。这个大小使用 $G^{\\ast}$ 计算：$\\lVert \\mathbf{H} \\rVert^2 = \\mathbf{h}^T G^{\\ast} \\mathbf{h}$，其中 $\\mathbf{h}$ 是列向量 $[h, k, l]^T$。因此，$d_{hkl} = (\\mathbf{h}^T G^{\\ast} \\mathbf{h})^{-1/2}$。\n    - 两个晶面 $(h_1, k_1, l_1)$ 和 $(h_2, k_2, l_2)$ 之间的夹角 $\\phi$ 由它们各自的倒易晶格矢量 $\\mathbf{H}_1$ 和 $\\mathbf{H}_2$ 的点积得出。这个点积也通过度规张量计算：$\\mathbf{H}_1 \\cdot \\mathbf{H}_2 = \\mathbf{h}_1^T G^{\\ast} \\mathbf{h}_2$。然后角度由 $\\cos \\phi = (\\mathbf{h}_1^T G^{\\ast} \\mathbf{h}_2) / (\\lVert \\mathbf{H}_1 \\rVert \\lVert \\mathbf{H}_2 \\rVert)$ 给出。\n3.  **组合优化：** 为了找到与实验数据最匹配的米勒指数，执行穷举搜索。通过取为每个实验间距提供的候选集的笛卡尔积，生成所有可能的米勒指数分配集。对于每个完整的分配（一个组合），计算归一化总平方和 $S$：\n    $$\n    S = \\sum_{i=1}^{N} \\left( \\frac{d_{\\text{calc},i} - d_{\\text{exp},i}}{d_{\\text{exp},i}} \\right)^2 + \\sum_{p=1}^{P} \\left( \\frac{\\phi_{\\text{calc},p} - \\phi_{\\text{exp},p}}{180} \\right)^2\n    $$\n    使 $S$ 最小化的指数组合被选为最优解。最后，计算均方根（RMS）误差 $\\mathrm{RMS} = \\sqrt{S_{\\min} / (N+P)}$，作为拟合质量的度量。\n\n该实现将使用 Python 完成，利用 `numpy` 库进行高效准确的线性代数运算（矩阵构建、求逆和乘积），并利用 `itertools` 库生成用于搜索的组合。对于每个测试用例，算法将：\n1.  定义晶格参数、实验数据和候选指数集。\n2.  为每个测试用例预先计算一次倒易度规张量 $G^{\\ast}$。\n3.  遍历候选指数的每个组合。\n4.  对于每个组合，使用 $G^{\\ast}$ 计算相应的理论间距和角度。\n5.  计算总平方误差 $S$。\n6.  跟踪产生最小 $S$ 的组合。\n7.  搜索后，为最佳组合计算最终的 RMS 误差。\n8.  按规定格式化所得的最优指数和 RMS 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\nimport math\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases for crystallographic analysis.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Test Case 1 (Hexagonal wurtzite-like)\",\n            \"lattice_params\": {\n                \"a\": 3.189, \"b\": 3.189, \"c\": 5.185,\n                \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 120.0\n            },\n            \"exp_spacings\": [2.760, 2.595, 2.440, 1.590],\n            \"exp_angles\": [\n                {\"indices\": (0, 1), \"angle\": 90.3},\n                {\"indices\": (0, 3), \"angle\": 30.1}\n            ],\n            \"candidate_indices\": [\n                [(1, 0, 0), (0, 0, 2), (1, 1, 0)],\n                [(0, 0, 2), (1, 0, 1), (1, 1, 0)],\n                [(1, 0, 1), (1, 1, 1), (0, 0, 3)],\n                [(1, 1, 0), (2, 0, 0), (0, 0, 4)]\n            ]\n        },\n        {\n            \"name\": \"Test Case 2 (Tetragonal rutile-like)\",\n            \"lattice_params\": {\n                \"a\": 4.5937, \"b\": 4.5937, \"c\": 2.9587,\n                \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0\n            },\n            \"exp_spacings\": [3.249, 2.487, 2.300],\n            \"exp_angles\": [\n                {\"indices\": (0, 1), \"angle\": 67.6},\n                {\"indices\": (1, 2), \"angle\": 57.2}\n            ],\n            \"candidate_indices\": [\n                [(1, 1, 0), (2, 0, 0), (2, 1, 1)],\n                [(1, 0, 1), (2, 1, 0), (1, 1, 2)],\n                [(2, 0, 0), (0, 0, 2), (1, 1, 1)]\n            ]\n        },\n        {\n            \"name\": \"Test Case 3 (Orthorhombic layered-like)\",\n            \"lattice_params\": {\n                \"a\": 3.313, \"b\": 10.473, \"c\": 4.374,\n                \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0\n            },\n            \"exp_spacings\": [5.220, 2.186, 1.656],\n            \"exp_angles\": [\n                {\"indices\": (0, 2), \"angle\": 90.0},\n                {\"indices\": (1, 2), \"angle\": 90.0}\n            ],\n            \"candidate_indices\": [\n                [(0, 2, 0), (0, 1, 0), (1, 0, 0)],\n                [(0, 0, 2), (1, 0, 1), (0, 1, 1)],\n                [(2, 0, 0), (1, 1, 0), (0, 0, 3)]\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        lattice = case[\"lattice_params\"]\n        a, b, c = lattice[\"a\"], lattice[\"b\"], lattice[\"c\"]\n        alpha_rad = np.deg2rad(lattice[\"alpha\"])\n        beta_rad = np.deg2rad(lattice[\"beta\"])\n        gamma_rad = np.deg2rad(lattice[\"gamma\"])\n\n        # Construct the direct metric matrix G\n        g_matrix = np.array([\n            [a**2, a * b * np.cos(gamma_rad), a * c * np.cos(beta_rad)],\n            [a * b * np.cos(gamma_rad), b**2, b * c * np.cos(alpha_rad)],\n            [a * c * np.cos(beta_rad), b * c * np.cos(alpha_rad), c**2]\n        ])\n\n        # Compute the reciprocal metric matrix G*\n        g_star_matrix = np.linalg.inv(g_matrix)\n\n        min_s = float('inf')\n        best_combo = None\n\n        # Generate all combinations of candidate indices\n        index_combinations = itertools.product(*case[\"candidate_indices\"])\n\n        # For each combination, calculate S and find the minimum\n        for combo in index_combinations:\n            total_s = 0.0\n            \n            # Calculate d_hkl for the current combination\n            calculated_spacings = []\n            for hkl in combo:\n                h = np.array(hkl).reshape(3, 1)\n                h_norm_sq = h.T @ g_star_matrix @ h\n                d_hkl = 1.0 / np.sqrt(h_norm_sq[0, 0])\n                calculated_spacings.append(d_hkl)\n            \n            # Calculate spacing residuals\n            for i, d_exp in enumerate(case[\"exp_spacings\"]):\n                d_calc = calculated_spacings[i]\n                total_s += ((d_calc - d_exp) / d_exp)**2\n\n            # Calculate interplanar angles for the current combination\n            for angle_info in case[\"exp_angles\"]:\n                idx1, idx2 = angle_info[\"indices\"]\n                h1_tuple, h2_tuple = combo[idx1], combo[idx2]\n                \n                h1 = np.array(h1_tuple).reshape(3, 1)\n                h2 = np.array(h2_tuple).reshape(3, 1)\n\n                h1_norm = np.sqrt(h1.T @ g_star_matrix @ h1)\n                h2_norm = np.sqrt(h2.T @ g_star_matrix @ h2)\n                \n                h1_dot_h2 = h1.T @ g_star_matrix @ h2\n                \n                cos_phi_val = h1_dot_h2 / (h1_norm * h2_norm)\n                # Clip to handle potential floating point inaccuracies\n                cos_phi_val = np.clip(cos_phi_val, -1.0, 1.0)\n                \n                phi_calc_rad = np.arccos(cos_phi_val)\n                phi_calc_deg = np.rad2deg(phi_calc_rad)[0, 0]\n                \n                phi_exp = angle_info[\"angle\"]\n                total_s += ((phi_calc_deg - phi_exp) / 180.0)**2\n\n            if total_s  min_s:\n                min_s = total_s\n                best_combo = combo\n\n        # Calculate RMS for the best combination\n        num_spacings = len(case[\"exp_spacings\"])\n        num_angles = len(case[\"exp_angles\"])\n        rms = np.sqrt(min_s / (num_spacings + num_angles))\n\n        # Format the result for this case\n        case_result = [list(hkl) for hkl in best_combo]\n        case_result.append(float(f\"{rms:.6f}\"))\n        all_results.append(case_result)\n\n    # Custom string formatter to match the required output style (no spaces)\n    def format_output_string(data):\n        items = []\n        for item in data:\n            if isinstance(item, list):\n                items.append(format_output_string(item))\n            elif isinstance(item, float):\n                items.append(f\"{item:.6f}\")\n            else:\n                items.append(str(item))\n        return f\"[{','.join(items)}]\"\n    \n    print(format_output_string(all_results))\n\nsolve()\n\n```"
        }
    ]
}