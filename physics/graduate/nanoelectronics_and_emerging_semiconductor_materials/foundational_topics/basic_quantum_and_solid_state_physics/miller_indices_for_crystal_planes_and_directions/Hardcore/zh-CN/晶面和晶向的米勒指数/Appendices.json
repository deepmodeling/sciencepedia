{
    "hands_on_practices": [
        {
            "introduction": "理解密勒指数始于其基本定义，即将其与晶面在晶格轴上的截距相关联。本练习提供了该定义的直接应用，引导您完成从空间中三个点确定晶面指数的过程 ()。通过从空间坐标反推到平面方程，再到最终的指数，您将巩固对这一核心概念的掌握。",
            "id": "2779321",
            "problem": "在与纳米力学以及表面和界面科学相关的立方晶体中，原子面决定了滑移、粘附和界面能。考虑一个具有晶格矢量 $\\mathbf{a}_{1}$、$\\mathbf{a}_{2}$ 和 $\\mathbf{a}_{3}$ 的常规立方布拉菲晶格。分数（简约）坐标 $(u,v,w)$ 表示点 $\\mathbf{r} = u\\,\\mathbf{a}_{1} + v\\,\\mathbf{a}_{2} + w\\,\\mathbf{a}_{3}$。一个通过实验确定的原子面经过三个轴截距点，其分数坐标分别为 $(1,0,0)$、$(0,\\tfrac{1}{2},0)$ 和 $(0,0,\\tfrac{1}{3})$。从密勒指数 $(h\\,k\\,l)$ 的核心定义出发——即密勒指数是通过与晶面在晶轴上的分数截距的倒数成正比的最小整数集来标记该晶面——完成以下任务：\n- 在分数坐标空间 $(u,v,w)$ 中，推导经过给定三个点的唯一平面的方程。仅使用矢量代数和三维空间中平面的定义来建立该平面方程，并由此确认这三点的共面性。\n- 根据您推导出的平面方程，确定密勒指数 $(h\\,k\\,l)$，其应为与定义一致、无公约数的最小整数集。\n\n将您的最终答案以单行矩阵 $\\bigl(h\\;k\\;l\\bigr)$ 的形式报告。不包括单位。无需四舍五入。",
            "solution": "我们从三维空间中平面的基本几何描述开始。给定三个非共线点，存在一个包含它们的唯一平面。在与立方晶轴相关联的分数坐标空间 $(u,v,w)$ 中，这三个点是\n$$(u_{1},v_{1},w_{1}) = (1,0,0), \\quad (u_{2},v_{2},w_{2}) = \\left(0,\\tfrac{1}{2},0\\right), \\quad (u_{3},v_{3},w_{3}) = \\left(0,0,\\tfrac{1}{3}\\right)$$\n在平面内定义两个独立的方向矢量：\n$$\\mathbf{v}_{1} = (u_{2}-u_{1},\\,v_{2}-v_{1},\\,w_{2}-w_{1}) = \\left(-1,\\,\\tfrac{1}{2},\\,0\\right),$$\n$$\\mathbf{v}_{2} = (u_{3}-u_{1},\\,v_{3}-v_{1},\\,w_{3}-w_{1}) = \\left(-1,\\,0,\\,\\tfrac{1}{3}\\right)$$\n平面的法矢量 $\\mathbf{n}$ 由叉积 $\\mathbf{n} = \\mathbf{v}_{1} \\times \\mathbf{v}_{2}$ 给出。计算\n$$\\mathbf{n} = \n\\begin{vmatrix}\n\\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\\n-1  \\tfrac{1}{2}  0 \\\\\n-1  0  \\tfrac{1}{3}\n\\end{vmatrix}\n= \\mathbf{i}\\left(\\tfrac{1}{2}\\cdot\\tfrac{1}{3} - 0\\cdot 0\\right) - \\mathbf{j}\\left((-1)\\cdot\\tfrac{1}{3} - 0\\cdot(-1)\\right) + \\mathbf{k}\\left((-1)\\cdot 0 - \\tfrac{1}{2}\\cdot(-1)\\right)$$\n因此\n$$\\mathbf{n} = \\left(\\tfrac{1}{6},\\,\\tfrac{1}{3},\\,\\tfrac{1}{2}\\right)$$\n乘以 $6$（一个非零标量）得到一个成比例的整数法矢量\n$$\\mathbf{n}' = (1,\\,2,\\,3)$$\n一个法矢量为 $\\mathbf{n}'$ 且经过点 $(u_{1},v_{1},w_{1})=(1,0,0)$ 的平面，其方程为\n$$\\mathbf{n}'\\cdot\\bigl[(u,v,w)-(1,0,0)\\bigr] = 0$$\n展开得到\n$$(1,2,3)\\cdot(u-1,\\,v-0,\\,w-0) = 0 \\;\\;\\Rightarrow\\;\\; 1\\cdot(u-1) + 2\\cdot v + 3\\cdot w = 0,$$\n化简为\n$$u + 2v + 3w = 1$$\n这是在分数坐标空间中的平面方程。将给定的三个点分别代入，可以确认其共面性：\n- 对于 $(1,0,0)$: $1 + 2\\cdot 0 + 3\\cdot 0 = 1$，满足。\n- 对于 $\\left(0,\\tfrac{1}{2},0\\right)$: $0 + 2\\cdot \\tfrac{1}{2} + 0 = 1$，满足。\n- 对于 $\\left(0,0,\\tfrac{1}{3}\\right)$: $0 + 0 + 3\\cdot \\tfrac{1}{3} = 1$，满足。\n因此，这三个点是共面的，并定义了这个唯一的平面。\n\n为了获得密勒指数 $(h\\,k\\,l)$，我们使用其核心定义：它们与平面在晶轴上的分数截距的倒数成正比。从平面方程 $u + 2v + 3w = 1$ 中，通过将两个坐标设为零来找到截距：\n- $u$轴截距：设 $v=0$ 且 $w=0$，得到 $u=1$。\n- $v$轴截距：设 $u=0$ 且 $w=0$，得到 $2v=1 \\Rightarrow v=\\tfrac{1}{2}$。\n- $w$轴截距：设 $u=0$ 且 $v=0$，得到 $3w=1 \\Rightarrow w=\\tfrac{1}{3}$。\n取倒数以获得与 $(h\\,k\\,l)$ 成比例的三元组：\n$$\\left(\\frac{1}{1},\\,\\frac{1}{1/2},\\,\\frac{1}{1/3}\\right) = (1,\\,2,\\,3)$$\n这些数已经是没有公约数的最小整数，因此密勒指数是 $(1\\,2\\,3)$。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  2  3\\end{pmatrix}}$$"
        },
        {
            "introduction": "在材料表征中，尤其是在透射电子显微镜（TEM）技术中，经常需要将晶体沿特定方向（即晶带轴）取向。晶带轴是一组晶面共有的方向。本练习将引导您运用矢量代数来找出两个相交晶面的晶带轴 ()，这是解读电子衍射图谱和为成像校准样品的关键技能。",
            "id": "2779320",
            "problem": "在透射电子显微镜（Transmission Electron Microscopy, TEM）对具有相等晶格参数的立方晶体进行取向时，一个常见的实验任务是确定两个晶格平面共有的晶带轴。考虑一个立方晶体，其正点阵基矢与一个标准正交笛卡尔坐标系对齐，且两个平面由密勒指数 $\\left(1\\ 1\\ 0\\right)$ 和 $\\left(1\\ \\bar{1}\\ 0\\right)$ 标定。从第一性原理出发：\n\n- 使用立方晶体中平面的密勒指数定义，将平面法线与相应的晶向关联起来。\n- 使用正交性和基础向量代数，求得两个平面交线（即晶带轴）的方向。\n- 利用该晶带轴方向，通过计算其与晶向 $\\left[0\\ 0\\ 1\\right]$ 之间夹角 $\\theta$ 的余弦值，来评估两者间的平行性。\n\n报告标量 $\\left|\\cos\\theta\\right|$ 的精确值作为你的最终答案，它是一个无量纲数。不要对答案进行四舍五入。角度 $\\theta$ 应视为弧度，但你不能报告 $\\theta$；只报告 $\\left|\\cos\\theta\\right|$ 的精确值。",
            "solution": "所述问题是有效的、自洽的、有科学依据的且提法恰当。我们将进行推导。\n\n对于立方晶系，其基本原理是：正点阵基矢 $\\vec{a}_1, \\vec{a}_2, \\vec{a}_3$ 相互正交且长度相等，均为 $a$，此时密勒指数为 $(h\\ k\\ l)$ 的平面的法线平行于晶向 $[h\\ k\\ l]$。问题指明，正点阵基矢与一个标准正交笛卡尔坐标系对齐，这使我们能够在该坐标系中将晶向表示为向量，而无需进行坐标变换。\n\n设给定的两个平面为 $P_1$ 和 $P_2$，其密勒指数分别为 $(h_1\\ k_1\\ l_1) = (1\\ 1\\ 0)$ 和 $(h_2\\ k_2\\ l_2) = (1\\ \\bar{1}\\ 0)$。符号 $\\bar{1}$ 等价于 $-1$。\n\n平面 $P_1$ 的法向量方向，记为 $\\vec{n}_1$，由晶向 $[1\\ 1\\ 0]$ 给出。在笛卡尔坐标系中，我们可以将此向量写为：\n$$\n\\vec{n}_1 = 1\\hat{i} + 1\\hat{j} + 0\\hat{k}\n$$\n类似地，平面 $P_2$ 的法向量方向，记为 $\\vec{n}_2$，由晶向 $[1\\ \\bar{1}\\ 0]$ 给出。在笛卡尔坐标系中，此向量为：\n$$\n\\vec{n}_2 = 1\\hat{i} - 1\\hat{j} + 0\\hat{k}\n$$\n根据定义，晶带轴是两个平面 $P_1$ 和 $P_2$ 的交线。沿此线的向量，我们记为 $\\vec{v}_{za}$，必须同时与两个平面法线 $\\vec{n}_1$ 和 $\\vec{n}_2$ 正交。这样的向量可以通过计算 $\\vec{n}_1$ 和 $\\vec{n}_2$ 的向量叉乘得到。\n$$\n\\vec{v}_{za} = \\vec{n}_1 \\times \\vec{n}_2\n$$\n我们通过计算一个矩阵的行列式来求此叉乘，该矩阵的第一行是笛卡尔单位向量，后续行是 $\\vec{n}_1$ 和 $\\vec{n}_2$ 的分量：\n$$\n\\vec{v}_{za} = \\begin{vmatrix}\n\\hat{i}  \\hat{j}  \\hat{k} \\\\\nh_1  k_1  l_1 \\\\\nh_2  k_2  l_2\n\\end{vmatrix} = \\begin{vmatrix}\n\\hat{i}  \\hat{j}  \\hat{k} \\\\\n1  1  0 \\\\\n1  -1  0\n\\end{vmatrix}\n$$\n展开行列式，我们得到 $\\vec{v}_{za}$ 的分量：\n$$\n\\vec{v}_{za} = \\hat{i}((1)(0) - (0)(-1)) - \\hat{j}((1)(0) - (0)(1)) + \\hat{k}((1)(-1) - (1)(1))\n$$\n$$\n\\vec{v}_{za} = \\hat{i}(0) - \\hat{j}(0) + \\hat{k}(-1 - 1) = -2\\hat{k}\n$$\n代表晶带轴的向量是 $\\vec{v}_{za} = [0\\ 0\\ -2]$。在晶体学中，方向指数被约化为最小整数集。因此，方向 $[0\\ 0\\ -2]$ 等价于方向 $[0\\ 0\\ \\bar{1}]$。\n\n问题要求我们评估该晶带轴与晶向 $[0\\ 0\\ 1]$ 之间的平行性。我们将后者表示为向量 $\\vec{v}_{ref}$：\n$$\n\\vec{v}_{ref} = 0\\hat{i} + 0\\hat{j} + 1\\hat{k} = \\hat{k}\n$$\n两个向量 $\\vec{A}$ 和 $\\vec{B}$ 之间的夹角 $\\theta$ 与它们的点积和模长通过以下公式相关联：\n$$\n\\cos\\theta = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{A}| |\\vec{B}|}\n$$\n我们将此公式应用于我们的向量 $\\vec{v}_{za}$ 和 $\\vec{v}_{ref}$：\n$$\n\\cos\\theta = \\frac{\\vec{v}_{za} \\cdot \\vec{v}_{ref}}{|\\vec{v}_{za}| |\\vec{v}_{ref}|}\n$$\n首先，我们计算点积：\n$$\n\\vec{v}_{za} \\cdot \\vec{v}_{ref} = (0)(0) + (0)(0) + (-2)(1) = -2\n$$\n接下来，我们计算向量的模长：\n$$\n|\\vec{v}_{za}| = \\sqrt{0^2 + 0^2 + (-2)^2} = \\sqrt{4} = 2\n$$\n$$\n|\\vec{v}_{ref}| = \\sqrt{0^2 + 0^2 + 1^2} = \\sqrt{1} = 1\n$$\n将这些值代回余弦公式：\n$$\n\\cos\\theta = \\frac{-2}{(2)(1)} = -1\n$$\n问题要求 $|\\cos\\theta|$ 的值。\n$$\n|\\cos\\theta| = |-1| = 1\n$$\n$|\\cos\\theta| = 1$ 的值表示两个方向是平行的（同向或反向）。这里，由于 $\\cos\\theta = -1$，夹角 $\\theta = \\pi$ 弧度，意味着方向 $[0\\ 0\\ \\bar{1}]$ 和 $[0\\ 0\\ 1]$ 是反平行的，这是作为直线平行的特例。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "尽管简单的立方晶系为入门提供了直观的理解，但现实世界中的材料通常具有更复杂的非正交晶格。这个高级的计算练习引入了度规张量——一个处理任何晶系几何问题的强大工具 ()。通过编写算法将实验衍射数据与候选的密勒指数进行匹配，您将把抽象的理论与实际的材料分析联系起来，这是现代纳米电子学和材料科学研究中的核心任务。",
            "id": "4287493",
            "problem": "您的任务是实现一个程序，该程序使用晶体学度量矩阵为候选的密勒指数计算晶面间距和晶面夹角，然后使用最小二乘法选择与实验数据最佳拟合的结果。其背景是对纳米电子学和新兴半导体材料中晶面的分析，在这些材料中，严格的度量处理对于处理非立方晶格至关重要。您的算法必须从第一性原理和经过充分检验的定义出发。\n\n定义与基本原理：\n- 正晶格参数为长度 $a$、$b$、$c$ 和角度 $\\alpha$、$\\beta$、$\\gamma$，其中 $\\alpha$ 是 $\\mathbf{b}$ 和 $\\mathbf{c}$ 之间的夹角，$\\beta$ 是 $\\mathbf{a}$ 和 $\\mathbf{c}$ 之间的夹角，$\\gamma$ 是 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的夹角。\n- 正度量矩阵 $G$ 编码了正晶格基矢的内积，由下式给出\n$$\nG = \\begin{bmatrix}\na^2  a b \\cos \\gamma  a c \\cos \\beta \\\\\na b \\cos \\gamma  b^2  b c \\cos \\alpha \\\\\na c \\cos \\beta  b c \\cos \\alpha  c^2\n\\end{bmatrix}.\n$$\n- 倒易度量矩阵 $G^{\\ast}$ 是 $G$ 的逆矩阵，即 $G^{\\ast} = G^{-1}$。这源于倒易基矢 $\\mathbf{a}^{\\ast}$、$\\mathbf{b}^{\\ast}$、$\\mathbf{c}^{\\ast}$ 的定义，其满足 $\\mathbf{a}^{\\ast} \\cdot \\mathbf{a} = 1$、$\\mathbf{a}^{\\ast} \\cdot \\mathbf{b} = 0$ 等关系，并得出 $G G^{\\ast} = I$。\n- 对于一个密勒指数为 $(h,k,l)$ 的晶面，其对应的倒易晶格矢量为 $\\mathbf{H} = h \\mathbf{a}^{\\ast} + k \\mathbf{b}^{\\ast} + l \\mathbf{c}^{\\ast}$，其范数的平方计算如下\n$$\n\\lVert \\mathbf{H} \\rVert^2 = \\begin{bmatrix} h  k  l \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h \\\\ k \\\\ l \\end{bmatrix}.\n$$\n- 晶面间距为 $d_{hkl} = \\frac{1}{\\lVert \\mathbf{H} \\rVert}$，如果 $a$、$b$、$c$ 以埃（Å）为单位，则其单位也为埃（Å）。\n- 两个晶面 $(h_1,k_1,l_1)$ 和 $(h_2,k_2,l_2)$ 之间的夹角是它们在倒易空间中法线之间的夹角：\n$$\n\\cos \\phi = \\frac{\\mathbf{H}_1 \\cdot \\mathbf{H}_2}{\\lVert \\mathbf{H}_1 \\rVert \\, \\lVert \\mathbf{H}_2 \\rVert} = \\frac{\\begin{bmatrix} h_1  k_1  l_1 \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h_2 \\\\ k_2 \\\\ l_2 \\end{bmatrix}}{\\sqrt{\\begin{bmatrix} h_1  k_1  l_1 \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h_1 \\\\ k_1 \\\\ l_1 \\end{bmatrix}} \\, \\sqrt{\\begin{bmatrix} h_2  k_2  l_2 \\end{bmatrix} \\, G^{\\ast} \\, \\begin{bmatrix} h_2 \\\\ k_2 \\\\ l_2 \\end{bmatrix}}}.\n$$\n角度 $\\phi$ 必须以度为单位报告。\n\n目标与最小二乘法：\n- 您将获得一组实验晶面间距 $d_i$（对于 $i = 1,\\dots,N$，单位为埃 Å）和一组针对指定指数对 $(i_p, j_p)$ 的实验晶面夹角 $\\phi_p$（单位为度）。\n- 对于每个间距 $d_i$，都提供了一个小的可能密勒指数候选集 $\\{(h,k,l)\\}$。\n- 您的目标是为每个 $i$ 从其候选集中恰好选择一个三元组 $(h_i,k_i,l_i)$，使得计算出的间距和角度在归一化最小二乘意义上与实验值最佳拟合。\n- 定义间距的归一化平方残差为\n$$\nr_{d,i}^2 = \\left( \\frac{d_{\\text{calc},i} - d_{\\text{exp},i}}{d_{\\text{exp},i}} \\right)^2,\n$$\n角度的归一化平方残差为\n$$\nr_{\\phi,p}^2 = \\left( \\frac{\\phi_{\\text{calc},p} - \\phi_{\\text{exp},p}}{180} \\right)^2,\n$$\n其中 $d_{\\text{calc},i}$ 和 $\\phi_{\\text{calc},p}$ 是根据上述度量矩阵计算得出的。总平方和为\n$$\nS = \\sum_{i=1}^{N} r_{d,i}^2 + \\sum_{p=1}^{P} r_{\\phi,p}^2.\n$$\n- 选择使 $S$ 最小化的指数组合。报告均方根（RMS）误差\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{S}{N + P}}.\n$$\n\n单位：\n- 所有晶面间距 $d_{hkl}$ 必须以埃（Å）为单位进行计算和比较。\n- 所有角度必须以度为单位进行计算和比较。\n\n程序要求：\n- 实现从 $(a,b,c,\\alpha,\\beta,\\gamma)$ 计算 $G$ 和 $G^{\\ast}$。\n- 使用度量矩阵实现 $d_{hkl}$ 和 $\\phi$ 的计算。\n- 对于每个测试用例，枚举候选指数的所有组合（笛卡尔积），并选择使 $S$ 最小化的组合。\n- 计算并报告所选组合的RMS误差。\n\n测试套件：\n为以下所有测试用例提供解决方案。您的程序必须硬编码这些用例，并按照末尾指定的精确最终格式生成输出。\n\n测试用例1（类六方纤锌矿）：\n- 晶格参数: $a = 3.189\\ \\text{Å}$，$b = 3.189\\ \\text{Å}$，$c = 5.185\\ \\text{Å}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 120^\\circ$。\n- 实验间距（单位：Å）: $[2.760, 2.595, 2.440, 1.590]$。\n- 角度对和实验角度（单位：度）：指数 $i=0$ 和 $j=1$ 之间：$90.3^\\circ$；指数 $i=0$ 和 $j=3$ 之间：$30.1^\\circ$。\n- 每个间距 $i$ 的候选集：\n  - $i=0$: $\\{(1,0,0), (0,0,2), (1,1,0)\\}$。\n  - $i=1$: $\\{(0,0,2), (1,0,1), (1,1,0)\\}$。\n  - $i=2$: $\\{(1,0,1), (1,1,1), (0,0,3)\\}$。\n  - $i=3$: $\\{(1,1,0), (2,0,0), (0,0,4)\\}$。\n\n测试用例2（类四方金红石）：\n- 晶格参数: $a = 4.5937\\ \\text{Å}$，$b = 4.5937\\ \\text{Å}$，$c = 2.9587\\ \\text{Å}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$。\n- 实验间距（单位：Å）: $[3.249, 2.487, 2.300]$。\n- 角度对和实验角度（单位：度）：指数 $i=0$ 和 $j=1$ 之间：$67.6^\\circ$；指数 $i=1$ 和 $j=2$ 之间：$57.2^\\circ$。\n- 候选集：\n  - $i=0$: $\\{(1,1,0), (2,0,0), (2,1,1)\\}$。\n  - $i=1$: $\\{(1,0,1), (2,1,0), (1,1,2)\\}$。\n  - $i=2$: $\\{(2,0,0), (0,0,2), (1,1,1)\\}$。\n\n测试用例3（类正交层状）：\n- 晶格参数: $a = 3.313\\ \\text{Å}$，$b = 10.473\\ \\text{Å}$，$c = 4.374\\ \\text{Å}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$。\n- 实验间距（单位：Å）: $[5.220, 2.186, 1.656]$。\n- 角度对和实验角度（单位：度）：指数 $i=0$ 和 $j=2$ 之间：$90.0^\\circ$；指数 $i=1$ 和 $j=2$ 之间：$90.0^\\circ$。\n- 候选集：\n  - $i=0$: $\\{(0,2,0), (0,1,0), (1,0,0)\\}$。\n  - $i=1$: $\\{(0,0,2), (1,0,1), (0,1,1)\\}$。\n  - $i=2$: $\\{(2,0,0), (1,1,0), (0,0,3)\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个列表，其元素是按 $i=0$ 到 $N-1$ 顺序排列的所选密勒指数列表，后跟四舍五入到六位小数的RMS误差。例如：\n\"[[[h0,k0,l0],[h1,k1,l1],...,rms_case1],[[...],rms_case2],[[...],rms_case3]]\"。\n不应打印任何额外文本。",
            "solution": "用户的请求是开发一个程序，该程序能根据实验数据确定晶面的密勒指数。该问题定义明确，并以晶体学和固态物理学原理为基础。它要求实现基于晶体学度量张量的计算，以处理通用的非正交晶格系统，并应用最小二乘法最小化程序来找到计算数据与实验数据之间的最佳拟合。\n\n问题陈述的有效性验证如下：\n- **科学依据：**该问题基于晶体学的基本且正确的定义，包括正度量张量和倒易度量张量（$G$ 和 $G^{\\ast}$）、晶面间距（$d_{hkl}$）和晶面夹角（$\\phi$）。使用最小二乘法进行数据拟合是标准的科学实践。\n- **良构性：**目标是在一个有限的可能性集合（候选密勒指数集的笛卡尔积）上最小化一个平方和函数 $S$。最小值保证存在。该问题是自洽的，提供了所有必需的晶格参数、实验数据、候选指数以及代价函数和最终度量（RMS误差）的定义。\n- **客观性：**该问题使用精确的数学公式和客观的数值数据进行陈述，没有主观或含糊的语言。\n\n该问题被认为是有效的，因为它在科学上是合理的、完整的，并且是定量指定的。解决方案按所概述的第一性原理进行。\n\n方法论方法包括三个主要阶段：\n1.  **度量张量构建：**对于由参数 $a$、$b$、$c$、$\\alpha$、$\\beta$、$\\gamma$ 定义的给定晶格，构建正度量张量 $G$。该矩阵封装了正晶格基矢的几何结构。然后计算倒易度量张量 $G^{\\ast} = G^{-1}$。$G^{\\ast}$ 是在倒易空间中执行计算的基本算子。\n2.  **倒易空间计算：**计算出的 $G^{\\ast}$ 用于确定任何给定密勒指数集 $(h,k,l)$ 的晶面间距和夹角的理论值。\n    - 晶面间距 $d_{hkl}$ 是倒易晶格矢量 $\\mathbf{H} = h \\mathbf{a}^{\\ast} + k \\mathbf{b}^{\\ast} + l \\mathbf{c}^{\\ast}$ 大小的倒数。这个大小使用 $G^{\\ast}$ 计算：$\\lVert \\mathbf{H} \\rVert^2 = \\mathbf{h}^T G^{\\ast} \\mathbf{h}$，其中 $\\mathbf{h}$ 是列向量 $[h, k, l]^T$。因此，$d_{hkl} = (\\mathbf{h}^T G^{\\ast} \\mathbf{h})^{-1/2}$。\n    - 两个晶面 $(h_1, k_1, l_1)$ 和 $(h_2, k_2, l_2)$ 之间的夹角 $\\phi$ 由它们各自的倒易晶格矢量 $\\mathbf{H}_1$ 和 $\\mathbf{H}_2$ 的点积求得。此点积也通过度量张量计算：$\\mathbf{H}_1 \\cdot \\mathbf{H}_2 = \\mathbf{h}_1^T G^{\\ast} \\mathbf{h}_2$。然后，角度由 $\\cos \\phi = (\\mathbf{h}_1^T G^{\\ast} \\mathbf{h}_2) / (\\lVert \\mathbf{H}_1 \\rVert \\lVert \\mathbf{H}_2 \\rVert)$ 给出。\n3.  **组合优化：**为了找到与实验数据最佳匹配的密勒指数，将执行穷举搜索。通过对为每个实验间距提供的候选集进行笛卡尔积运算，生成所有可能的密勒指数分配集。对于每个完整的分配（一个组合），计算归一化总平方和 $S$：\n    $$\n    S = \\sum_{i=1}^{N} \\left( \\frac{d_{\\text{calc},i} - d_{\\text{exp},i}}{d_{\\text{exp},i}} \\right)^2 + \\sum_{p=1}^{P} \\left( \\frac{\\phi_{\\text{calc},p} - \\phi_{\\text{exp},p}}{180} \\right)^2\n    $$\n    选择使 $S$ 最小化的指数组合作为最优解。最后，计算均方根（RMS）误差 $\\mathrm{RMS} = \\sqrt{S_{\\min} / (N+P)}$，作为拟合质量的度量。\n\n实现将使用 Python 语言，利用 `numpy` 库进行高效准确的线性代数运算（矩阵构建、求逆和乘积），并使用 `itertools` 库生成用于搜索的组合。对于每个测试用例，算法将：\n1.  定义晶格参数、实验数据和候选指数集。\n2.  每个测试用例预先计算一次倒易度量张量 $G^{\\ast}$。\n3.  遍历候选指数的每个组合。\n4.  对于每个组合，使用 $G^{\\ast}$ 计算相应的理论间距和角度。\n5.  计算总平方误差 $S$。\n6.  跟踪产生最小 $S$ 的组合。\n7.  搜索结束后，计算最佳组合的最终RMS误差。\n8.  按规定格式化所得的最优指数和RMS值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\nimport math\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases for crystallographic analysis.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Test Case 1 (Hexagonal wurtzite-like)\",\n            \"lattice_params\": {\n                \"a\": 3.189, \"b\": 3.189, \"c\": 5.185,\n                \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 120.0\n            },\n            \"exp_spacings\": [2.760, 2.595, 2.440, 1.590],\n            \"exp_angles\": [\n                {\"indices\": (0, 1), \"angle\": 90.3},\n                {\"indices\": (0, 3), \"angle\": 30.1}\n            ],\n            \"candidate_indices\": [\n                [(1, 0, 0), (0, 0, 2), (1, 1, 0)],\n                [(0, 0, 2), (1, 0, 1), (1, 1, 0)],\n                [(1, 0, 1), (1, 1, 1), (0, 0, 3)],\n                [(1, 1, 0), (2, 0, 0), (0, 0, 4)]\n            ]\n        },\n        {\n            \"name\": \"Test Case 2 (Tetragonal rutile-like)\",\n            \"lattice_params\": {\n                \"a\": 4.5937, \"b\": 4.5937, \"c\": 2.9587,\n                \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0\n            },\n            \"exp_spacings\": [3.249, 2.487, 2.300],\n            \"exp_angles\": [\n                {\"indices\": (0, 1), \"angle\": 67.6},\n                {\"indices\": (1, 2), \"angle\": 57.2}\n            ],\n            \"candidate_indices\": [\n                [(1, 1, 0), (2, 0, 0), (2, 1, 1)],\n                [(1, 0, 1), (2, 1, 0), (1, 1, 2)],\n                [(2, 0, 0), (0, 0, 2), (1, 1, 1)]\n            ]\n        },\n        {\n            \"name\": \"Test Case 3 (Orthorhombic layered-like)\",\n            \"lattice_params\": {\n                \"a\": 3.313, \"b\": 10.473, \"c\": 4.374,\n                \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0\n            },\n            \"exp_spacings\": [5.220, 2.186, 1.656],\n            \"exp_angles\": [\n                {\"indices\": (0, 2), \"angle\": 90.0},\n                {\"indices\": (1, 2), \"angle\": 90.0}\n            ],\n            \"candidate_indices\": [\n                [(0, 2, 0), (0, 1, 0), (1, 0, 0)],\n                [(0, 0, 2), (1, 0, 1), (0, 1, 1)],\n                [(2, 0, 0), (1, 1, 0), (0, 0, 3)]\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        lattice = case[\"lattice_params\"]\n        a, b, c = lattice[\"a\"], lattice[\"b\"], lattice[\"c\"]\n        alpha_rad = np.deg2rad(lattice[\"alpha\"])\n        beta_rad = np.deg2rad(lattice[\"beta\"])\n        gamma_rad = np.deg2rad(lattice[\"gamma\"])\n\n        # Construct the direct metric matrix G\n        g_matrix = np.array([\n            [a**2, a * b * np.cos(gamma_rad), a * c * np.cos(beta_rad)],\n            [a * b * np.cos(gamma_rad), b**2, b * c * np.cos(alpha_rad)],\n            [a * c * np.cos(beta_rad), b * c * np.cos(alpha_rad), c**2]\n        ])\n\n        # Compute the reciprocal metric matrix G*\n        g_star_matrix = np.linalg.inv(g_matrix)\n\n        min_s = float('inf')\n        best_combo = None\n\n        # Generate all combinations of candidate indices\n        index_combinations = itertools.product(*case[\"candidate_indices\"])\n\n        # For each combination, calculate S and find the minimum\n        for combo in index_combinations:\n            total_s = 0.0\n            \n            # Calculate d_hkl for the current combination\n            calculated_spacings = []\n            for hkl in combo:\n                h = np.array(hkl).reshape(3, 1)\n                h_norm_sq = h.T @ g_star_matrix @ h\n                d_hkl = 1.0 / np.sqrt(h_norm_sq[0, 0])\n                calculated_spacings.append(d_hkl)\n            \n            # Calculate spacing residuals\n            for i, d_exp in enumerate(case[\"exp_spacings\"]):\n                d_calc = calculated_spacings[i]\n                total_s += ((d_calc - d_exp) / d_exp)**2\n\n            # Calculate interplanar angles for the current combination\n            for angle_info in case[\"exp_angles\"]:\n                idx1, idx2 = angle_info[\"indices\"]\n                h1_tuple, h2_tuple = combo[idx1], combo[idx2]\n                \n                h1 = np.array(h1_tuple).reshape(3, 1)\n                h2 = np.array(h2_tuple).reshape(3, 1)\n\n                h1_norm = np.sqrt(h1.T @ g_star_matrix @ h1)\n                h2_norm = np.sqrt(h2.T @ g_star_matrix @ h2)\n                \n                h1_dot_h2 = h1.T @ g_star_matrix @ h2\n                \n                cos_phi_val = h1_dot_h2 / (h1_norm * h2_norm)\n                # Clip to handle potential floating point inaccuracies\n                cos_phi_val = np.clip(cos_phi_val, -1.0, 1.0)\n                \n                phi_calc_rad = np.arccos(cos_phi_val)\n                phi_calc_deg = np.rad2deg(phi_calc_rad)[0, 0]\n                \n                phi_exp = angle_info[\"angle\"]\n                total_s += ((phi_calc_deg - phi_exp) / 180.0)**2\n\n            if total_s  min_s:\n                min_s = total_s\n                best_combo = combo\n\n        # Calculate RMS for the best combination\n        num_spacings = len(case[\"exp_spacings\"])\n        num_angles = len(case[\"exp_angles\"])\n        rms = np.sqrt(min_s / (num_spacings + num_angles))\n\n        # Format the result for this case\n        case_result = [list(hkl) for hkl in best_combo]\n        case_result.append(float(f\"{rms:.6f}\"))\n        all_results.append(case_result)\n\n    # Custom string formatter to match the required output style (no spaces)\n    def format_output_string(data):\n        items = []\n        for item in data:\n            if isinstance(item, list):\n                items.append(format_output_string(item))\n            elif isinstance(item, float):\n                items.append(f\"{item:.6f}\")\n            else:\n                items.append(str(item))\n        return f\"[{','.join(items)}]\"\n    \n    print(format_output_string(all_results))\n\nsolve()\n\n```"
        }
    ]
}