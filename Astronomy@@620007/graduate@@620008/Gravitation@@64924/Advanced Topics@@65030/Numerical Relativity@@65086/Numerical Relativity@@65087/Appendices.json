{"hands_on_practices": [{"introduction": "In numerical relativity, the choice of coordinates—or \"gauge\"—is not a passive background but a crucial, dynamic element of the evolution. The lapse function, $\\alpha$, dictates how time steps forward across the computational grid. This thought exercise explores what happens when we make the simplest choice, called Geodesic Slicing, and uncovers a classic pitfall in black hole simulations. Understanding this failure mode [@problem_id:1814395] is a critical first step in appreciating the sophisticated \"singularity-avoiding\" techniques that underpin modern, stable simulations.", "problem": "In the 3+1 formalism of General Relativity, spacetime is decomposed into a sequence of three-dimensional space-like hypersurfaces, or \"slices,\" indexed by a global time coordinate $t$. The geometry of this slicing is described by two key quantities: the lapse function $\\alpha$ and the shift vector $\\beta^i$. The lapse function $\\alpha(t, \\vec{x})$ dictates the rate of flow of proper time $\\tau$ relative to coordinate time $t$ for a hypothetical \"Eulerian\" observer who remains at a fixed spatial coordinate $\\vec{x}$ and moves orthogonally to each slice. The relationship is given by $d\\tau = \\alpha dt$.\n\nA numerical relativity code is set up to simulate the evolution of a Schwarzschild black hole spacetime, including its interior. A crucial choice for the stability and longevity of such a simulation is the \"slicing condition,\" which is a rule that determines the lapse function $\\alpha$ as the simulation progresses.\n\nConsider the simplest possible slicing condition, known as \"Geodesic Slicing,\" where the lapse function is set to unity everywhere and for all time, i.e., $\\alpha(t, \\vec{x}) = 1$. While computationally simple, this choice is known to be problematic for long-term simulations of spacetimes containing singularities.\n\nWhich of the following statements correctly identifies the primary reason why Geodesic Slicing leads to the termination of a black hole simulation?\n\nA. The area of the event horizon spuriously decreases over time, violating the Hawking area theorem and leading to a non-physical solution.\n\nB. The constant lapse function causes the computational grid to expand infinitely fast near the event horizon, a phenomenon known as \"grid stretching,\" which makes the simulation computationally intractable.\n\nC. The coordinates defined by the slices are comoving with freely-falling observers, causing the slices to advance directly into the central singularity, where physical quantities like curvature diverge and cause a computational overflow.\n\nD. The condition $\\alpha=1$ is incompatible with the Hamiltonian and momentum constraints of General Relativity, causing these constraints to be violated exponentially and leading to a rapid breakdown of the simulation's physical validity.\n\nE. Time evolution halts globally because the proper time for all observers becomes equal to the coordinate time, effectively \"freezing\" the geometry of the entire spacetime.", "solution": "The problem asks to identify the primary failure mode of \"Geodesic Slicing\" ($\\alpha=1$) in a numerical simulation of a black hole spacetime. Let's analyze the physical meaning of this slicing condition and its consequences inside a black hole.\n\nFirst, we must understand the role of the lapse function, $\\alpha$. It relates the passage of proper time $\\tau$ for an observer moving normal to the spatial slices to the advance in coordinate time $t$ through the equation $d\\tau = \\alpha dt$. Geodesic Slicing sets $\\alpha=1$. This means that for observers at fixed spatial coordinate positions, their proper time elapses at exactly the same rate as the global coordinate time, $d\\tau = dt$. Such observers are in free-fall; their worldlines are geodesics. The spatial slices are therefore surfaces of constant proper time for a family of freely-falling observers.\n\nNext, consider the structure of a Schwarzschild black hole. Once an observer or a particle crosses the event horizon, it enters a region where the roles of the radial coordinate $r$ and the time coordinate are interchanged. The radial coordinate $r$ becomes timelike, and all future-directed worldlines must inevitably move towards smaller values of $r$, terminating at the physical singularity at $r=0$. There is no physical force that can prevent this inward motion.\n\nNow, let's combine these two points. A numerical simulation using Geodesic Slicing foliates the spacetime with hypersurfaces that are effectively \"carried along\" by a swarm of freely-falling observers. Outside the black hole, this is not necessarily a problem. However, for any part of the computational domain that is inside the event horizon, these freely-falling observers (and thus, the computational grid points associated with them) are inexorably drawn towards the central singularity at $r=0$.\n\nThe spatial slices, which represent \"now\" for the simulation, will therefore advance in time by marching steadily towards $r=0$. At the singularity, the spacetime curvature is infinite. Physical quantities that a numerical simulation must compute, such as components of the Riemann curvature tensor or scalar invariants like the Kretschmann scalar ($K = R_{abcd}R^{abcd} \\propto 1/r^6$ for Schwarzschild), diverge as $r \\to 0$. As the simulation slices approach the singularity, the computed values for these quantities will grow without bound. Any real computer has a finite limit on the size of the numbers it can represent. This unbounded growth will quickly lead to a \"floating-point overflow\" error, causing the simulation to crash. This phenomenon is often called \"singularity crashing\".\n\nWith this understanding, let's evaluate the given options:\n\n**A. The area of the event horizon spuriously decreases over time...** This is incorrect. The Hawking area theorem is a fundamental physical law. A correctly formulated numerical code solving the Einstein Field Equations will respect this, regardless of the coordinate system (slicing) used. Violations may occur due to numerical error, but this is a symptom of poor resolution, not a primary failure caused by the $\\alpha=1$ condition itself.\n\n**B. The constant lapse function causes the computational grid to expand infinitely fast near the event horizon...** This is incorrect. In fact, the opposite problem is more common with \"singularity-avoiding\" slicings (like harmonic or 1+log slicing). Those slicings cause the lapse $\\alpha$ to collapse to zero near the singularity to \"freeze\" time there, which can lead to extreme grid stretching elsewhere. The problem with $\\alpha=1$ is that it *fails* to slow down time, not that it causes grid stretching.\n\n**C. The coordinates defined by the slices are comoving with freely-falling observers, causing the slices to advance directly into the central singularity, where physical quantities like curvature diverge and cause a computational overflow.** This is the correct description of the failure mode. The slices are dragged into the singularity, and the attempt to calculate infinite physical quantities on a finite computer causes the simulation to halt.\n\n**D. The condition $\\alpha=1$ is incompatible with the Hamiltonian and momentum constraints...** This is incorrect. The choice of lapse and shift (the gauge) is, in principle, independent of the satisfaction of the constraint equations. The constraints must be satisfied on the initial slice, and a correct implementation of the evolution equations will ensure they remain satisfied (up to numerical error) on subsequent slices, regardless of the gauge choice. The failure is a consequence of the coordinates reaching a region of physical pathology (the singularity), not an inherent incompatibility with the fundamental equations.\n\n**E. Time evolution halts globally because the proper time for all observers becomes equal to the coordinate time...** This describes the opposite of what happens. Setting $\\alpha=1$ *forces* time to evolve everywhere at a constant rate. The problem is that this evolution leads the slices into a region where the physics breaks down. Time evolution does not halt; it proceeds directly into a catastrophe. A \"frozen\" geometry would correspond to a static spacetime, which is not what happens during a dynamic simulation.\n\nTherefore, the primary reason for the failure of Geodesic Slicing is that it does not avoid the singularity, leading to a computational crash as the slices reach it.", "answer": "$$\\boxed{C}$$", "id": "1814395"}, {"introduction": "A numerical code is only as reliable as our ability to verify its results. Since simulations produce approximations, a key question is whether these approximations are systematically approaching the true solution. This is the essence of convergence, a concept that demands that the numerical error shrinks predictably as we increase the resolution of our computational grid. This practice problem [@problem_id:1814389] walks you through a convergence test, the single most important diagnostic tool for building trust in a simulation's output and confirming the code's accuracy.", "problem": "A physicist is performing a convergence test on a new numerical relativity code. The code solves the Einstein Field Equations to evolve an initial configuration of spacetime. The accuracy of the spatial discretization scheme is characterized by its order of convergence, $p$. For a numerical method of order $p$, the discretization error $E$ is expected to scale with the grid spacing $h$ as $E \\propto h^p$.\n\nTo measure $p$, the physicist runs the simulation three times with systematically refined grid resolutions. The resolutions are a coarse grid with spacing $h_c$, a medium grid with spacing $h_m = h_c/r$, and a fine grid with spacing $h_f = h_m/r$. The constant $r$ is known as the refinement factor. In this test, a refinement factor of $r=2.0$ is used.\n\nThe physicist measures the value of a specific scalar quantity $\\Phi$ (derived from the spacetime metric) at a fixed spacetime point after a set evolution time. The three simulations yield the following values:\n- Coarse resolution ($\\Phi_c$): $2.4000$\n- Medium resolution ($\\Phi_m$): $2.3568$\n- Fine resolution ($\\Phi_f$): $2.3456$\n\nAssuming that the error is dominated by the leading-order term from the discretization, calculate the measured order of convergence $p$ for the numerical code. Round your final answer to three significant figures.", "solution": "We assume that the measured quantity at grid spacing $h$ has the form $\\Phi(h)=\\Phi^{*}+C h^{p}+o(h^{p})$, where $\\Phi^{*}$ is the exact value, $C$ is a constant, and $p$ is the order of convergence. For the three grid spacings $h_{c}$, $h_{m}=h_{c}/r$, and $h_{f}=h_{m}/r=h_{c}/r^{2}$, the leading-order differences satisfy\n$$\n\\Phi_{c}-\\Phi_{m}=C\\left(h_{c}^{p}-h_{m}^{p}\\right)=C h_{c}^{p}\\left(1-r^{-p}\\right),\n$$\n$$\n\\Phi_{m}-\\Phi_{f}=C\\left(h_{m}^{p}-h_{f}^{p}\\right)=C h_{m}^{p}\\left(1-r^{-p}\\right)=C h_{c}^{p} r^{-p}\\left(1-r^{-p}\\right).\n$$\nTherefore, the ratio\n$$\nR=\\frac{\\Phi_{c}-\\Phi_{m}}{\\Phi_{m}-\\Phi_{f}}=r^{p},\n$$\nand hence\n$$\np=\\frac{\\ln R}{\\ln r}=\\frac{\\ln\\left(\\left|\\frac{\\Phi_{c}-\\Phi_{m}}{\\Phi_{m}-\\Phi_{f}}\\right|\\right)}{\\ln r}.\n$$\nSubstituting the given values,\n$$\n\\Phi_{c}-\\Phi_{m}=2.4000-2.3568=0.0432,\\quad \\Phi_{m}-\\Phi_{f}=2.3568-2.3456=0.0112,\n$$\nso\n$$\nR=\\frac{0.0432}{0.0112}=\\frac{432}{112}=\\frac{27}{7}.\n$$\nWith $r=2$, we obtain\n$$\np=\\frac{\\ln\\left(\\frac{27}{7}\\right)}{\\ln 2}\\approx 1.94753,\n$$\nwhich rounded to three significant figures gives $1.95$.", "answer": "$$\\boxed{1.95}$$", "id": "1814389"}, {"introduction": "To overcome the instabilities that plagued early simulations, researchers developed more robust formulations of Einstein's equations, such as the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formalism. The BSSN system achieves superior stability by decomposing the metric and extrinsic curvature into conformally related variables with better numerical behavior. This capstone practice [@problem_id:2420591] transitions from theory to application, guiding you to write a routine that transforms initial data from the standard ADM form into the BSSN variables. This is a foundational software component in a modern numerical relativity code.", "problem": "You are to implement, verify, and test a transformation from Arnowitt–Deser–Misner (ADM) initial data to Baumgarte–Shapiro–Shibata–Nakamura (BSSN) variables on a uniform three-dimensional Cartesian grid using periodic boundary conditions. The ADM initial data consist of the spatial metric $\\gamma_{ij}$ and the extrinsic curvature $K_{ij}$. The BSSN variables to be produced are the conformal factor $\\phi$, the conformal metric $\\tilde{\\gamma}_{ij}$, the conformal trace-free extrinsic curvature $A_{ij}$, the mean curvature $K$, and the contracted conformal connection functions $\\tilde{\\Gamma}^{i}$.\n\nStarting point (fundamental definitions and identities from the $3+1$ decomposition and the BSSN formulation):\n- The conformal decomposition of the metric is $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$ with $\\det(\\tilde{\\gamma}_{ij}) = 1$. From this, $\\det(\\gamma_{ij}) = e^{12 \\phi}$ and thus $\\phi = \\frac{1}{12} \\ln \\det(\\gamma_{ij})$.\n- The mean curvature is the trace of the extrinsic curvature with respect to $\\gamma_{ij}$: $K = \\gamma^{ij} K_{ij}$, where $\\gamma^{ij}$ is the matrix inverse of $\\gamma_{ij}$.\n- The trace-free part of $K_{ij}$ is $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$. The conformal trace-free extrinsic curvature is $A_{ij} = e^{-4 \\phi} S_{ij}$.\n- The contracted conformal connection functions in Cartesian coordinates with $\\det(\\tilde{\\gamma}_{ij}) = 1$ satisfy $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$, where $\\tilde{\\gamma}^{ij}$ is the matrix inverse of $\\tilde{\\gamma}_{ij}$. Spatial derivatives are to be approximated numerically.\n\nNumerical requirements:\n- Use a uniform Cartesian grid with $N \\times N \\times N$ points covering the periodic domain $[0, L] \\times [0, L] \\times [0, L]$. Grid spacing is $\\Delta x = \\Delta y = \\Delta z = L/N$. Grid points are located at $x_{n} = n \\Delta x$, $y_{m} = m \\Delta y$, $z_{p} = p \\Delta z$ for integers $n, m, p$ in $\\{0, 1, \\dots, N-1\\}$.\n- Use periodic boundary conditions in all three directions.\n- Compute spatial derivatives with a second-order central finite difference. For any scalar or tensor component $u$, the discrete derivative along coordinate $x$ is $\\partial_{x} u \\approx \\left(u(x+\\Delta x) - u(x-\\Delta x)\\right) / (2 \\Delta x)$, and similarly for $y$ and $z$, with periodic wrapping.\n\nImplementation tasks:\n- Write a module that, given fields $\\gamma_{ij}$ and $K_{ij}$ on the grid, computes $\\phi$, $\\tilde{\\gamma}_{ij}$, $A_{ij}$, $K$, and $\\tilde{\\Gamma}^{i}$ at every grid point according to the definitions above.\n- Validate the implementation on the following three test cases. In each case, the ADM data are specified analytically, and you must construct $\\gamma_{ij}$ and $K_{ij}$ on the grid, apply your transformation, and compare to analytically known BSSN quantities wherever they are nontrivial.\n\nTest suite (use the same grid parameters $N$ and $L$ for all cases):\n- Common grid parameters: $N = 32$, $L = 2\\pi$.\n\n- Case $1$ (pure conformal factor with flat conformal metric, vanishing extrinsic curvature):\n  - Define $f(x) = a \\sin(k x)$ with $a = 0.1$ and $k = 1$, depending on $x$ only.\n  - Set $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ and $K_{ij} = 0$.\n  - Analytic BSSN references: $\\phi = f(x)$, $\\tilde{\\gamma}_{ij} = \\delta_{ij}$, $A_{ij} = 0$, $K = 0$, $\\tilde{\\Gamma}^{i} = 0$.\n\n- Case $2$ (nontrivial unit-determinant conformal metric with zero conformal factor and vanishing extrinsic curvature):\n  - Define $h(x) = b \\cos(k x)$ with $b = 0.2$ and $k = 2$, depending on $x$ only.\n  - Set $\\tilde{\\gamma}_{ij} = \\mathrm{diag}\\left(e^{h(x)}, e^{-h(x)}, 1\\right)$ and $\\gamma_{ij} = \\tilde{\\gamma}_{ij}$, with $K_{ij} = 0$.\n  - Analytic BSSN references: $\\phi = 0$, $A_{ij} = 0$, $K = 0$. The inverse conformal metric is $\\tilde{\\gamma}^{ij} = \\mathrm{diag}\\left(e^{-h(x)}, e^{h(x)}, 1\\right)$. Hence $\\tilde{\\Gamma}^{x} = -\\partial_{x}\\tilde{\\gamma}^{xx} = e^{-h(x)} h'(x)$ with $h'(x) = - b k \\sin(k x)$, and $\\tilde{\\Gamma}^{y} = 0$, $\\tilde{\\Gamma}^{z} = 0$.\n\n- Case $3$ (nontrivial conformal factor, flat conformal metric, and extrinsic curvature with prescribed trace and trace-free parts):\n  - Define $f(x) = a \\cos(k x)$ with $a = 0.05$ and $k = 3$, depending on $x$ only. Let $K_{0} = 0.4$ and $s = 0.3$ be constants.\n  - Set $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ and define a constant trace-free tensor $S_{ij} = \\mathrm{diag}(s, -s/2, -s/2)$ (trace-free with respect to $\\delta_{ij}$). Define $K_{ij} = \\frac{1}{3} \\gamma_{ij} K_{0} + e^{4 f(x)} S_{ij}$.\n  - Analytic BSSN references: $\\phi = f(x)$, $\\tilde{\\gamma}_{ij} = \\delta_{ij}$, $K = K_{0}$, $A_{ij} = S_{ij}$, $\\tilde{\\Gamma}^{i} = 0$.\n\nError evaluation and required output:\n- For each case, compute:\n  - The maximum absolute error in $\\phi$ over all grid points: $\\max |\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{ref}}|$.\n  - The maximum absolute error in $K$ over all grid points: $\\max |K_{\\mathrm{num}} - K_{\\mathrm{ref}}|$.\n  - The maximum absolute error in $A_{ij}$ over all grid points and components: $\\max |A^{\\mathrm{num}}_{ij} - A^{\\mathrm{ref}}_{ij}|$.\n  - The maximum pointwise Euclidean norm of the error in $\\tilde{\\Gamma}^{i}$: $\\max \\sqrt{(\\Delta \\tilde{\\Gamma}^{x})^{2} + (\\Delta \\tilde{\\Gamma}^{y})^{2} + (\\Delta \\tilde{\\Gamma}^{z})^{2}}$.\n- Your program should produce a single line of output containing all results for the three cases, in order, as a comma-separated list enclosed in square brackets: $[\\mathrm{case1\\_phi},\\mathrm{case1\\_K},\\mathrm{case1\\_A},\\mathrm{case1\\_\\tilde{\\Gamma}};\\mathrm{case2\\_phi},\\mathrm{case2\\_K},\\mathrm{case2\\_A},\\mathrm{case2\\_\\tilde{\\Gamma}};\\mathrm{case3\\_phi},\\mathrm{case3\\_K},\\mathrm{case3\\_A},\\mathrm{case3\\_\\tilde{\\Gamma}}]$. Replace semicolons with commas in the actual output string, resulting in a flat list of $12$ floating-point numbers. No other text should be printed.", "solution": "The problem statement is submitted for validation. The givens, definitions, and test cases are extracted and analyzed for internal consistency and scientific validity. The problem concerns the transformation of initial data for Einstein's field equations from the Arnowitt–Deser–Misner (ADM) formalism to the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formalism. All definitions—the conformal decomposition of the metric $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$, the definition of the mean curvature $K = \\gamma^{ij} K_{ij}$, the conformal trace-free extrinsic curvature $A_{ij}$, and the contracted conformal connection functions $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$—are standard in the field of numerical relativity. The provided test cases are verified to be consistent with these definitions. The problem is a well-posed computational physics task with clear, objective specifications and verifiable outcomes. It is therefore deemed valid.\n\nThe solution requires implementing a numerical procedure to compute the BSSN variables ($\\phi, \\tilde{\\gamma}_{ij}, K, A_{ij}, \\tilde{\\Gamma}^{i}$) from the ADM variables ($\\gamma_{ij}, K_{ij}$) on a uniform Cartesian grid. The procedure is as follows.\n\nFirst, a uniform, periodic, three-dimensional Cartesian grid is established. The grid has $N \\times N \\times N$ points, where $N=32$, covering the domain $[0, L] \\times [0, L] \\times [0, L]$ with $L=2\\pi$. The grid spacing is $\\Delta x = \\Delta y = \\Delta z = L/N$. The coordinates at each grid point $(i,j,k)$ are $(x_i, y_j, z_k)$. For each of the three test cases, the initial ADM tensor fields $\\gamma_{ij}$ and $K_{ij}$ are constructed as arrays on this grid according to their analytical definitions.\n\nThe transformation proceeds with the following sequence of calculations at each grid point:\n\n1.  **Conformal Factor $\\phi$**: The determinant of the spatial metric, $\\det(\\gamma_{ij})$, is computed. The conformal factor is then given by $\\phi = \\frac{1}{12} \\ln(\\det(\\gamma_{ij}))$. This isolates the volumetric part of the spatial geometry.\n\n2.  **Conformal Metric $\\tilde{\\gamma}_{ij}$**: Using the computed conformal factor $\\phi$, the physical metric $\\gamma_{ij}$ is conformally rescaled to obtain the conformal metric $\\tilde{\\gamma}_{ij} = e^{-4\\phi} \\gamma_{ij}$. By construction, this metric has a unit determinant, $\\det(\\tilde{\\gamma}_{ij}) = 1$.\n\n3.  **Mean Curvature $K$**: The inverse of the physical spatial metric, $\\gamma^{ij}$, is computed by inverting the $3 \\times 3$ matrix $\\gamma_{ij}$ at each grid point. The mean curvature is then found by contracting the inverse metric with the extrinsic curvature: $K = \\gamma^{ij} K_{ij}$. This is a summation over both indices, representing the trace of $K_{ij}$.\n\n4.  **Conformal Trace-Free Extrinsic Curvature $A_{ij}$**: First, the trace-free part of the extrinsic curvature with respect to the physical metric is calculated as $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$. This tensor is then conformally rescaled to yield the BSSN variable $A_{ij} = e^{-4\\phi} S_{ij}$.\n\n5.  **Contracted Conformal Connection Functions $\\tilde{\\Gamma}^{i}$**: This is the only step requiring numerical differentiation.\n    a.  The inverse of the conformal metric, $\\tilde{\\gamma}^{ij}$, is computed from $\\tilde{\\gamma}_{ij}$.\n    b.  The spatial derivatives $\\partial_j$ of the components of $\\tilde{\\gamma}^{ij}$ are computed using a second-order central finite difference scheme with periodic boundary conditions. For a field $u(x,y,z)$ and grid spacing $\\Delta x$, the derivative with respect to $x$ at grid point $i$ is approximated as $\\partial_x u_i \\approx \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x}$. The periodic nature of the domain means that index $i+1$ at the boundary wraps to the beginning, and $i-1$ wraps to the end.\n    c.  The connection functions are then computed by contracting these derivatives: $\\tilde{\\Gamma}^{i} = - \\sum_{j} \\partial_j \\tilde{\\gamma}^{ij}$. Explicitly, for each component $i \\in \\{x, y, z\\}$:\n    $$ \\tilde{\\Gamma}^x = -(\\partial_x \\tilde{\\gamma}^{xx} + \\partial_y \\tilde{\\gamma}^{xy} + \\partial_z \\tilde{\\gamma}^{xz}) $$\n    $$ \\tilde{\\Gamma}^y = -(\\partial_x \\tilde{\\gamma}^{yx} + \\partial_y \\tilde{\\gamma}^{yy} + \\partial_z \\tilde{\\gamma}^{yz}) $$\n    $$ \\tilde{\\Gamma}^z = -(\\partial_x \\tilde{\\gamma}^{zx} + \\partial_y \\tilde{\\gamma}^{zy} + \\partial_z \\tilde{\\gamma}^{zz}) $$\n    Note that because the inverse metric is symmetric ($\\tilde{\\gamma}^{ij} = \\tilde{\\gamma}^{ji}$), the expression is equivalent to the divergence of the rows (or columns) of the inverse conformal metric tensor.\n\nFinally, for each test case, the numerically computed BSSN fields are compared against their provided analytical reference solutions. The error metrics are calculated as specified: the maximum absolute error for the scalar and tensor fields $\\phi$, $K$, and $A_{ij}$, and the maximum of the pointwise Euclidean norm of the error vector for $\\tilde{\\Gamma}^{i}$. These errors are expected to be small, on the order of the truncation error of the second-order finite difference scheme, which is $O(\\Delta x^2)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted from the specified environment.\n\ndef solve():\n    \"\"\"\n    Implements and tests the ADM to BSSN transformation for numerical relativity.\n    \"\"\"\n    N = 32\n    L = 2.0 * np.pi\n    dx = L / N\n    # We use np.mgrid to create coordinate arrays where the first axis corresponds to x,\n    # the second to y, and the third to z. This is unconventional but allows for\n    # straightforward indexing e.g., axis=0 for x-derivatives.\n    coords = np.mgrid[0:N, 0:N, 0:N].astype(float) * dx\n    x, y, z = coords[0], coords[1], coords[2]\n\n    def central_diff(field, axis, step):\n        \"\"\"Computes 2nd-order periodic central difference.\"\"\"\n        return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2.0 * step)\n\n    def adm_to_bssn(gamma, K_ij, dx, dy, dz):\n        \"\"\"\n        Performs the transformation from ADM to BSSN variables on the grid.\n        \n        Args:\n            gamma (np.ndarray): Physical metric, shape (3, 3, N, N, N).\n            K_ij (np.ndarray): Extrinsic curvature, shape (3, 3, N, N, N).\n            dx, dy, dz (float): Grid spacings.\n\n        Returns:\n            A tuple of BSSN variables: (phi, tilde_gamma, A_ij, K_trace, Gamma_i).\n        \"\"\"\n        # Transpose for np.linalg functions which operate on the last two axes\n        gamma_T = gamma.transpose(2, 3, 4, 0, 1)\n        \n        # 1. Conformal factor phi\n        gamma_det = np.linalg.det(gamma_T)\n        phi = (1.0 / 12.0) * np.log(gamma_det)\n\n        # 2. Conformal metric tilde_gamma_ij\n        # Use broadcasting: (N,N,N) * (3,3,N,N,N)\n        tilde_gamma = np.exp(-4.0 * phi) * gamma\n        \n        # 3. Mean curvature K\n        gamma_inv_T = np.linalg.inv(gamma_T)\n        gamma_inv = gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        K_trace = np.einsum('ij...,ij...->...', gamma_inv, K_ij)\n\n        # 4. Conformal trace-free extrinsic curvature A_ij\n        S_ij = K_ij - (1.0 / 3.0) * K_trace * gamma  # Broadcasting K_trace * gamma\n        A_ij = np.exp(-4.0 * phi) * S_ij\n        \n        # 5. Contracted conformal connection functions Gamma^i\n        tilde_gamma_T = tilde_gamma.transpose(2, 3, 4, 0, 1)\n        tilde_gamma_inv_T = np.linalg.inv(tilde_gamma_T)\n        tilde_gamma_inv = tilde_gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        \n        Gamma_i = np.zeros((3, N, N, N))\n        \n        # Sum over j: partial_j tilde_gamma^ij\n        # For i = 0 (x-component):\n        Gamma_i[0] = -(central_diff(tilde_gamma_inv[0, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[0, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[0, 2], 2, dz))\n        # For i = 1 (y-component):\n        Gamma_i[1] = -(central_diff(tilde_gamma_inv[1, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[1, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[1, 2], 2, dz))\n        # For i = 2 (z-component):\n        Gamma_i[2] = -(central_diff(tilde_gamma_inv[2, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[2, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[2, 2], 2, dz))\n        \n        return phi, tilde_gamma, A_ij, K_trace, Gamma_i\n\n    all_errors = []\n\n    # Test Case 1\n    a, k = 0.1, 1.0\n    f_x = a * np.sin(k * x)\n    \n    gamma_1 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_1[0, 0] = conf_factor\n    gamma_1[1, 1] = conf_factor\n    gamma_1[2, 2] = conf_factor\n    \n    K_ij_1 = np.zeros((3, 3, N, N, N))\n    \n    phi_num_1, tilde_gamma_num_1, A_ij_num_1, K_num_1, Gamma_i_num_1 = adm_to_bssn(gamma_1, K_ij_1, dx, dx, dx)\n    \n    phi_ref_1 = f_x\n    K_ref_1 = np.zeros_like(phi_ref_1)\n    A_ij_ref_1 = np.zeros_like(A_ij_num_1)\n    Gamma_i_ref_1 = np.zeros_like(Gamma_i_num_1)\n    \n    err_phi_1 = np.max(np.abs(phi_num_1 - phi_ref_1))\n    err_K_1 = np.max(np.abs(K_num_1 - K_ref_1))\n    err_A_1 = np.max(np.abs(A_ij_num_1 - A_ij_ref_1))\n    err_Gamma_1 = np.max(np.sqrt(np.sum((Gamma_i_num_1 - Gamma_i_ref_1)**2, axis=0)))\n    all_errors.extend([err_phi_1, err_K_1, err_A_1, err_Gamma_1])\n\n    # Test Case 2\n    b, k = 0.2, 2.0\n    h_x = b * np.cos(k * x)\n    \n    gamma_2 = np.zeros((3, 3, N, N, N))\n    gamma_2[0, 0] = np.exp(h_x)\n    gamma_2[1, 1] = np.exp(-h_x)\n    gamma_2[2, 2] = 1.0\n    \n    K_ij_2 = np.zeros((3, 3, N, N, N))\n\n    phi_num_2, _, A_ij_num_2, K_num_2, Gamma_i_num_2 = adm_to_bssn(gamma_2, K_ij_2, dx, dx, dx)\n\n    phi_ref_2 = np.zeros_like(phi_num_2)\n    K_ref_2 = np.zeros_like(K_num_2)\n    A_ij_ref_2 = np.zeros_like(A_ij_num_2)\n    \n    Gamma_i_ref_2 = np.zeros((3, N, N, N))\n    hp_x = -b * k * np.sin(k * x)\n    Gamma_i_ref_2[0] = np.exp(-h_x) * hp_x\n    \n    err_phi_2 = np.max(np.abs(phi_num_2 - phi_ref_2))\n    err_K_2 = np.max(np.abs(K_num_2 - K_ref_2))\n    err_A_2 = np.max(np.abs(A_ij_num_2 - A_ij_ref_2))\n    err_Gamma_2 = np.max(np.sqrt(np.sum((Gamma_i_num_2 - Gamma_i_ref_2)**2, axis=0)))\n    all_errors.extend([err_phi_2, err_K_2, err_A_2, err_Gamma_2])\n\n    # Test Case 3\n    a, k = 0.05, 3.0\n    K0, s = 0.4, 0.3\n    f_x = a * np.cos(k * x)\n    \n    gamma_3 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_3[0, 0] = conf_factor\n    gamma_3[1, 1] = conf_factor\n    gamma_3[2, 2] = conf_factor\n    \n    S_ij_const = np.zeros((3, 3))\n    S_ij_const[0, 0] = s\n    S_ij_const[1, 1] = -s / 2.0\n    S_ij_const[2, 2] = -s / 2.0\n    \n    K_ij_3 = (1.0 / 3.0) * K0 * gamma_3 + conf_factor * S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    \n    phi_num_3, _, A_ij_num_3, K_num_3, Gamma_i_num_3 = adm_to_bssn(gamma_3, K_ij_3, dx, dx, dx)\n\n    phi_ref_3 = f_x\n    K_ref_3 = np.full_like(K_num_3, K0)\n    A_ij_ref_3 = S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    Gamma_i_ref_3 = np.zeros_like(Gamma_i_num_3)\n    \n    err_phi_3 = np.max(np.abs(phi_num_3 - phi_ref_3))\n    err_K_3 = np.max(np.abs(K_num_3 - K_ref_3))\n    err_A_3 = np.max(np.abs(A_ij_num_3 - A_ij_ref_3))\n    err_Gamma_3 = np.max(np.sqrt(np.sum((Gamma_i_num_3 - Gamma_i_ref_3)**2, axis=0)))\n    all_errors.extend([err_phi_3, err_K_3, err_A_3, err_Gamma_3])\n\n    print(f\"[{','.join(map(str, all_errors))}]\")\n\nsolve()\n```", "id": "2420591"}]}