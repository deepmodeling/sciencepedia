{
    "hands_on_practices": [
        {
            "introduction": "时间步进法和事件驱动法之间的核心权衡在于计算效率与数值精度。本练习旨在通过一个基础性任务，来量化分析一种简单的时间步进法（前向欧拉法）在模拟经典的泄漏积分发放（LIF）模型时引入的积分误差，并将其与事件驱动法中使用的精确积分进行比较。这项实践将为我们理解为何事件驱动法在高精度模拟中通常更受青睐奠定基础。",
            "id": "4044438",
            "problem": "考虑一个由漏电积分-发放（LIF）动力学在阈下区域建模的单个神经元，其中在一个数值步长内不会发生脉冲阈值穿越。膜电位用 $V(t)$ 表示，并根据以下一阶线性常微分方程（ODE）演化\n$$\n\\frac{dV}{dt} = -\\frac{1}{\\tau}\\left(V(t) - R I(t)\\right),\n$$\n其中 $\\tau$ 是膜时间常数，$R$ 是膜电阻，$I(t)$ 是输入电流。在神经形态模拟中典型的事件驱动背景下，假设在突触事件之间输入电流是分段恒定的。在从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个宏观步长内，假设 $I(t) = I_n$ 是恒定的。\n\n从该常微分方程和局部截断误差的定义（假设在 $t_n$ 处具有精确初始条件，精确单步解与数值单步更新之间的差异）出发，完成以下任务：\n\n- 在恒定输入假设下，推导上述常微分方程的精确解 $V(t_{n+1})$，以及事件驱动积分中使用的相应指数欧拉（精确子步积分）更新。\n\n- 推导同一步长的正向欧拉更新。\n\n- 使用这些结果，计算步长为 $\\Delta t$ 的正向欧拉的局部截断误差，表示为 $t_{n+1}$ 处的精确解与从 $V(t_n) = V_n$ 和 $I_n$ 计算出的正向欧拉更新之间的差值。将最终误差表示为 $V_n$、$I_n$、$R$、$\\tau$ 和 $\\Delta t$ 的闭式函数。\n\n- 使用第一性原理和泰勒展开论证，简要解释为什么在事件驱动模拟的分段恒定输入假设下，指数欧拉方法可以减少离散化误差。\n\n您的最终答案必须是单个闭式解析表达式。不需要四舍五入，最终答案中也不应包含任何物理单位。",
            "solution": "漏电积分-发放（LIF）模型的阈下动力学由以下线性常微分方程给出\n$$\n\\frac{dV}{dt} = -\\frac{1}{\\tau}\\left(V(t) - R I(t)\\right),\n$$\n在区间 $[t_n, t_{n+1}]$ 上，输入 $I(t) = I_n$ 为分段常数，其中 $t_{n+1} = t_n + \\Delta t$。将该步长内恒定输入的稳态（或不动点）电压定义为\n$$\nV_{\\infty} \\equiv R I_n.\n$$\n在此假设下，该常微分方程在区间上简化为\n$$\n\\frac{dV}{dt} = -\\frac{1}{\\tau}\\left(V(t) - V_{\\infty}\\right),\n$$\n这是一个系数恒定的一阶线性常微分方程。从 $V(t_n) = V_n$ 出发的精确解可以通过标准方法（分离变量法或积分因子法）得到。使用积分因子 $\\exp\\left(\\frac{t}{\\tau}\\right)$，解为\n$$\nV(t) = V_{\\infty} + \\left(V_n - V_{\\infty}\\right)\\exp\\left(-\\frac{t - t_n}{\\tau}\\right), \\quad t \\in [t_n, t_{n+1}].\n$$\n在 $t_{n+1} = t_n + \\Delta t$ 处求值，精确的单步解为\n$$\nV_{\\text{exact}}(t_{n+1}) = V_{\\infty} + \\left(V_n - V_{\\infty}\\right)\\exp\\left(-\\frac{\\Delta t}{\\tau}\\right).\n$$\n在具有精确子步积分（对于线性漂移项，通常称为指数欧拉法）的事件驱动模拟中，人们在分段恒定输入的假设下使用这种精确的闭式更新。因此，指数欧拉单步更新等于 $V_{\\text{exact}}(t_{n+1})$，并且在这类区间上的局部截断误差为零。\n\n作为比较，应用于该常微分方程的正向欧拉方法使用在步长开始时评估的漂移项：\n$$\nV_{\\text{FE}}(t_{n+1}) = V_n + \\Delta t \\cdot \\left[-\\frac{1}{\\tau}\\left(V_n - V_{\\infty}\\right)\\right] = V_n - \\frac{\\Delta t}{\\tau}\\left(V_n - V_{\\infty}\\right).\n$$\n根据定义，正向欧拉法在这一步的局部截断误差（LTE）是 $t_{n+1}$ 处的精确解与正向欧拉更新之间的差值，假设在 $t_n$ 处具有精确的初始值：\n$$\n\\mathrm{LTE}_{\\text{FE}}(\\Delta t) = V_{\\text{exact}}(t_{n+1}) - V_{\\text{FE}}(t_{n+1}).\n$$\n代入上面推导出的表达式，令 $\\delta \\equiv V_n - V_{\\infty}$ 和 $h \\equiv \\frac{\\Delta t}{\\tau}$。那么\n$$\nV_{\\text{exact}}(t_{n+1}) = V_{\\infty} + \\delta \\exp(-h),\n$$\n$$\nV_{\\text{FE}}(t_{n+1}) = V_n - h \\delta,\n$$\n所以\n$$\n\\mathrm{LTE}_{\\text{FE}}(\\Delta t) = \\left[V_{\\infty} + \\delta \\exp(-h)\\right] - \\left[V_n - h \\delta\\right] = V_{\\infty} - V_n + \\delta \\exp(-h) + h \\delta.\n$$\n由于 $V_{\\infty} - V_n = -\\delta$，这可以简化为\n$$\n\\mathrm{LTE}_{\\text{FE}}(\\Delta t) = \\delta\\left(h + \\exp(-h) - 1\\right).\n$$\n回到原始符号，\n$$\n\\mathrm{LTE}_{\\text{FE}}(\\Delta t) = \\left(V_n - R I_n\\right)\\left(\\frac{\\Delta t}{\\tau} + \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right) - 1\\right).\n$$\n\n为了证明为什么在分段恒定输入假设下指数欧拉法可以减少离散化误差，请注意，精确子步积分使用了具有恒定驱动项的线性常微分方程的闭式解，该解与 $V_{\\text{exact}}(t_{n+1})$ 完全匹配，因此在这类区间上的局部截断误差为零。相比之下，正向欧拉方法通过一阶泰勒步长来近似指数松弛。指数函数的泰勒展开明确地显示了误差结构：\n$$\n\\exp(-h) = 1 - h + \\frac{h^{2}}{2} - \\frac{h^{3}}{6} + \\cdots,\n$$\n代入误差表达式可得\n$$\n\\mathrm{LTE}_{\\text{FE}}(\\Delta t) = \\delta\\left(h + \\left[1 - h + \\frac{h^{2}}{2} - \\frac{h^{3}}{6} + \\cdots\\right] - 1\\right) = \\delta\\left(\\frac{h^{2}}{2} - \\frac{h^{3}}{6} + \\cdots\\right),\n$$\n该误差是 $\\mathcal{O}\\!\\left(h^{2}\\right)$ 阶的，并且对于 $h > 0$ 是严格非零的，除非 $\\delta = 0$（已经处于不动点）或 $\\Delta t = 0$。因此，在分段恒定输入（事件驱动的神经形态模拟中离散突触事件之间的一个自然假设）下，指数欧拉法消除了局部截断误差，而正向欧拉法会产生一个由初始偏差 $\\delta = V_n - R I_n$ 缩放的 $\\left(\\Delta t / \\tau\\right)^{2}$ 阶误差。这表明在LIF动力学中，相对于按时间步进的正向欧拉方法，精确子步积分如何减少离散化误差。",
            "answer": "$$\\boxed{\\left(V_n - R I_n\\right)\\left(\\frac{\\Delta t}{\\tau} + \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right) - 1\\right)}$$"
        },
        {
            "introduction": "在探讨了事件驱动法的精度优势之后，我们现在转向其实现的正确性与鲁棒性问题。在事件驱动模拟中，多个事件（例如，输入脉冲到达、不应期结束）可能被调度在完全相同的时间戳上。本练习将探讨一项关键任务：设计一个确定性的时间冲突消解策略，以一致的顺序处理这些并发事件，并证明该策略能够保持神经元模型的基本不变量，从而保证其与概念上同步更新的等效性。这项实践将深入探讨设计稳健模拟器的核心技术细节。",
            "id": "4044402",
            "problem": "考虑一个采用漏积分-发放 (LIF) 神经元的脉冲神经网络 (SNN)，该网络在事件驱动和时间步长两种语义下进行模拟。设 $V_i(t)$ 表示神经元 $i$ 在时间 $t$ 的膜电位，设 $V_{\\mathrm{th}}$ 表示阈值，设 $V_{\\mathrm{reset}}$ 表示重置电位，设 $\\tau$ 表示膜时间常数，设 $t_{\\mathrm{ref\\_end},i}$ 表示神经元 $i$ 的绝对不应期结束时间。在事件之间，LIF 动力学遵循经过充分检验的定律 $V_i(t) = V_i(t_0)\\exp\\left(-(t-t_0)/\\tau\\right)$（对于 $t \\ge t_0$ 且无突触输入的情况），这是神经形态计算中数值模型的基本依据。在时间戳 $t$，定义一个事件集 $E(t)$，其中包含两种瞬时事件：(i) 输入到达事件，形式为 $(\\text{input}, i, w)$，表示向神经元 $i$ 增加突触权重 $w$；以及 (ii) 不应期结束事件，形式为 $(\\text{refr\\_end}, i)$，表示神经元 $i$ 的绝对不应期结束。\n\n您的任务是构建一个确定性的时间冲突消解策略，以解决当两个或多个事件具有相同时间戳 $t$ 时出现的脉冲排序差异问题，并证明该策略保持了以下模型不变量，这些不变量必须在每个时间戳 $t$ 得到强制执行：\n\n- 不变量 I (同步等价性)：在时间戳 $t$ 的事件驱动更新必须为每个神经元 $i$ 产生与同步时间步长微更新相同的更新后膜电位 $V_i(t^+)$。同步时间步长微更新定义如下：首先通过 $V_i(t^-)=V_i(t_{\\mathrm{last},i})\\exp\\left(-(t-t_{\\mathrm{last},i})/\\tau\\right)$ 将 $V_i$ 从其上次更新时间 $t_{\\mathrm{last},i}$ 衰减到 $t$，然后，如果 $t \\ge t_{\\mathrm{ref\\_end},i}$，则累积输入总和 $S_i(t) = \\sum\\limits_{(\\text{input},i,w)\\in E(t)} w$，否则 $S_i(t)=0$，最后应用阈值和重置，如果 $V_i(t^-)+S_i(t) \\ge V_{\\mathrm{th}}$，则 $V_i(t^+) = V_{\\mathrm{reset}}$，否则 $V_i(t^+)=V_i(t^-)+S_i(t)$。\n- 不变量 II (不应期门控)：对于每个神经元 $i$，时间戳 $t$ 的输入仅在计入时间 $t$ 的任何不应期结束标记后，该神经元在 $t$ 时不处于绝对不应期的情况下，才对总和有贡献。形式上，如果一个不应期结束标记 $(\\text{refr\\_end},i)\\in E(t)$，则在对输入进行门控之前设置 $t_{\\mathrm{ref\\_end},i}\\leftarrow t$；然后，门控后的输入总和等于上面定义的 $S_i(t)$。\n- 不变量 III (脉冲边界确定性)：神经元 $i$ 在时间戳 $t$ 产生一个脉冲，当且仅当 $V_i(t^-)+S_i(t) \\ge V_{\\mathrm{th}}$。在此条件下，在 $t$ 时刻只记录一个脉冲，且不会在 $t$ 时刻产生额外的脉冲。\n\n按如下纯数学和逻辑术语设计时间冲突消解策略。在集合 $E(t)$ 中，为每个事件分配一个相位标签 $\\phi(e)$，其中 $\\phi((\\text{refr\\_end},i))=0$ 且 $\\phi((\\text{input},i,w))=1$。通过按 $(\\phi(e), i, \\kappa)$ 的字典序对事件进行排序，来定义时间戳 $t$ 处事件的顺序，其中 $i$ 是神经元索引，$\\kappa$ 是一个稳定的逐事件索引，用于保留针对同一神经元的事件的到达顺序（任何确定性的索引方法都是可接受的）。然后，在时间戳 $t$ 的事件驱动微更新按以下步骤进行：(a) 将每个 $V_i$ 从 $t_{\\mathrm{last},i}$ 衰减到 $t$ 以获得 $V_i(t^-)$，(b) 按排序顺序处理所有 $(\\text{refr\\_end},\\cdot)$ 事件，以在需要时更新 $t_{\\mathrm{ref\\_end},i}$，(c) 按排序顺序处理所有 $(\\text{input},\\cdot)$ 事件，同时根据 $t \\ge t_{\\mathrm{ref\\_end},i}$ 进行门控，以及 (d) 应用阈值处理以生成 $V_i(t^+)$，如果 $V_i(t^-)+S_i(t)\\ge V_{\\mathrm{th}}$ 则重置为 $V_{\\mathrm{reset}}$。必须证明该策略保持了不变量 I–III。\n\n您还必须实现一个程序，该程序：\n- 使用上述排序计算事件驱动的微更新，并计算由不变量陈述定义的同步参考微更新。\n- 对提供的测试套件检查不变量 I–III 的保持情况，为每个测试用例返回一个布尔值，指示该用例的所有不变量是否都得到保持。\n\n不涉及物理单位；所有量都是无量纲的标量。不使用角度。\n\n测试套件由以下参数集组成；每个测试用例指定神经元数量 $N$、初始膜电位 $V_i(0)$、上次更新时间 $t_{\\mathrm{last},i}$、不应期结束时间 $t_{\\mathrm{ref\\_end},i}$、阈值 $V_{\\mathrm{th}}$、重置电位 $V_{\\mathrm{reset}}$、时间常数 $\\tau$、要处理的时间戳 $t$ 以及事件多重集 $E(t)$。\n\n- 测试用例 1 (正常路径，多个同时输入)：\n  - $N = 1$, $V_0(0) = 0.3$, $t_{\\mathrm{last},0} = 0.0$, $t_{\\mathrm{ref\\_end},0} = -\\infty$, $V_{\\mathrm{th}} = 1.0$, $V_{\\mathrm{reset}} = 0.0$, $\\tau = 20.0$, $t = 10.0$,\n  - $E(t) = \\{(\\text{input}, 0, 0.5), (\\text{input}, 0, 0.25)\\}$。\n\n- 测试用例 2 (边界情况，不应期恰好在时间戳结束且输入到达)：\n  - $N = 1$, $V_0(0) = 0.0$, $t_{\\mathrm{last},0} = 0.0$, $t_{\\mathrm{ref\\_end},0} = 10.0$, $V_{\\mathrm{th}} = 1.0$, $V_{\\mathrm{reset}} = 0.0$, $\\tau = 20.0$, $t = 10.0$,\n  - $E(t) = \\{(\\text{refr\\_end}, 0), (\\text{input}, 0, 1.0)\\}$。\n\n- 测试用例 3 (边缘情况，不应期延续到时间戳之后；输入必须被阻断)：\n  - $N = 1$, $V_0(0) = 0.4$, $t_{\\mathrm{last},0} = 0.0$, $t_{\\mathrm{ref\\_end},0} = 12.0$, $V_{\\mathrm{th}} = 1.0$, $V_{\\mathrm{reset}} = 0.0$, $\\tau = 20.0$, $t = 10.0$,\n  - $E(t) = \\{(\\text{input}, 0, 0.7)\\}$。\n\n- 测试用例 4 (两个神经元，精确阈值边界和亚阈值更新)：\n  - $N = 2$, $V_0(0) = 0.0$, $V_1(0) = 0.8$, $t_{\\mathrm{last},0} = 0.0$, $t_{\\mathrm{last},1} = 0.0$, $t_{\\mathrm{ref\\_end},0} = -\\infty$, $t_{\\mathrm{ref\\_end},1} = -\\infty$, $V_{\\mathrm{th}} = 1.0$, $V_{\\mathrm{reset}} = 0.0$, $\\tau = 20.0$, $t = 5.0$,\n  - $E(t) = \\{(\\text{input}, 0, 0.5), (\\text{input}, 0, 0.5), (\\text{input}, 1, 0.125)\\}$。\n\n- 测试用例 5 (混合情况：跨神经元的不应期结束和多个输入；包括零权重输入)：\n  - $N = 2$, $V_0(0) = 0.5$, $V_1(0) = 0.2$, $t_{\\mathrm{last},0} = 0.0$, $t_{\\mathrm{last},1} = 0.0$, $t_{\\mathrm{ref\\_end},0} = 20.0$, $t_{\\mathrm{ref\\_end},1} = 25.0$, $V_{\\mathrm{th}} = 1.0$, $V_{\\mathrm{reset}} = 0.0$, $\\tau = 20.0$, $t = 20.0$,\n  - $E(t) = \\{(\\text{refr\\_end}, 0), (\\text{input}, 0, 0.25), (\\text{input}, 0, 0.25), (\\text{input}, 1, 0.9), (\\text{input}, 1, 0.0)\\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”），其中每个条目都是一个布尔值，指示相应测试用例的不变量 I–III 是否成立。该程序必须是一个完整、可运行的实现，并且只使用指定的运行时环境和库。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且自洽的。它提出了一个关于漏积分-发放 (LIF) 神经元的事件驱动和同步模拟语义等价性的形式化问题，这是计算神经科学和神经形态工程中的一个标准且重要的课题。该问题提供了所有必要的定义、常数和测试用例，以便构建和验证解决方案。因此，我们可以着手进行数学证明和后续的实现。\n\n核心任务是证明所提出的事件驱动微更新策略（该策略对同时发生的事件使用特定的时间冲突消解规则）能够保持三个基本不变量，这三个不变量定义了神经元模型的正确、同步的语义。该策略在给定时间戳 $t$ 按元组 $(\\phi(e), i, \\kappa)$ 的字典序对事件进行排序，其中 $\\phi$ 是相位标签（不应期结束事件为 $0$，输入事件为 $1$），$i$ 是神经元索引，$\\kappa$ 是一个稳定的事件索引。这确保了在任何时间戳 $t$，所有不应期结束事件都在所有输入事件之前处理。\n\n让我们用神经元 $i$ 在时间 $t$ 更新前的状态来表示，即其自上次更新以来的膜电位 $V_i(t_{\\mathrm{last},i})$ 和其不应期结束时间 $t_{\\mathrm{ref\\_end},i}^{\\text{pre}}$。时间 $t$ 的事件集为 $E(t)$。\n\n证明将通过分析每个不变量来进行。\n\n**不变量 II (不应期门控) 的证明**\n\n不变量 II 要求，对于每个神经元 $i$，时间戳 $t$ 的输入是基于其在计入该神经元在时间 $t$ 的任何不应期结束事件*之后*的不应期状态进行门控的。具体来说，如果 $(\\text{refr\\_end},i)\\in E(t)$，则该神经元的不应期结束时间必须在处理其输入*之前*更新为 $t$。门控后的总输入和定义为，如果神经元在此潜在更新后不处于不应期，则 $S_i(t) = \\sum_{(\\text{input},i,w)\\in E(t)} w$，否则 $S_i(t)=0$。\n\n所提出的事件驱动策略由对 $(\\phi(e), i, \\kappa)$ 的字典序排序定义。相位标签定义为 $\\phi((\\text{refr\\_end},i))=0$ 和 $\\phi((\\text{input},i,w))=1$。根据字典序排序的性质，任何 $\\phi=0$ 的事件都将排在任何 $\\phi=1$ 的事件之前。\n\n事件驱动的微更新过程遵循此排序顺序：\n1.  步骤 (b) 处理所有 $(\\text{refr\\_end}, \\cdot)$ 事件。对于神经元 $i$，如果事件 $(\\text{refr\\_end}, i)$ 在 $E(t)$ 中，其状态变量 $t_{\\mathrm{ref\\_end},i}$ 被更新为 $t$。我们称更新后的值为 $t_{\\mathrm{ref\\_end},i}^{\\text{post}}$。\n2.  步骤 (c) 接着处理所有 $(\\text{input}, \\cdot)$ 事件。对于每个传入的输入 $(\\text{input}, i, w)$，仅当满足条件 $t \\ge t_{\\mathrm{ref\\_end},i}$ 时，权重 $w$ 才被累加到神经元 $i$ 的总和中。在此阶段，$t_{\\mathrm{ref\\_end},i}$ 持有上一步中计算的值 $t_{\\mathrm{ref\\_end},i}^{\\text{post}}$。\n\n这个过程顺序直接实现了不变量 II 指定的逻辑。步骤 (c) 中累积的总和正是不变量中定义的门控输入总和 $S_i(t)$。因此，该时间冲突消解策略通过其构造强制执行了不变量 II。\n\n**不变量 I (同步等价性) 和不变量 III (脉冲边界确定性) 的证明**\n\n这两个不变量关系到最终电位 $V_i(t^+)$ 和脉冲的产生。我们将通过证明事件驱动模型和同步模型计算出相同的中间值和最终值来一并证明它们。\n\n同步微更新由三个逻辑步骤定义：\n1.  **衰减 (Decay)**：计算在应用事件之前 $t$ 时刻的电位：$V_i(t^-)=V_i(t_{\\mathrm{last},i})\\exp\\left(-(t-t_{\\mathrm{last},i})/\\tau\\right)$。\n2.  **累积 (Accumulate)**：根据不变量 II 中的规则计算门控后的总输入和 $S_i(t)$。\n3.  **阈值/重置 (Threshold/Reset)**：将电位更新为 $V_i(t^+)$。如果 $V_i(t^-)+S_i(t) \\ge V_{\\mathrm{th}}$，则产生一个脉冲，并且 $V_i(t^+)$ 变为 $V_{\\mathrm{reset}}$。否则，$V_i(t^+)=V_i(t^-)+S_i(t)$。\n\n事件驱动的微更新由四个过程步骤定义：\na. **衰减**：为所有神经元计算 $V_i(t^-)$。\nb. **处理不应期结束事件**：更新 $t_{\\mathrm{ref\\_end},i}$ 的值。\nc. **处理输入事件**：计算门控后的总和 $S_i(t)$。\nd. **应用阈值处理**：确定脉冲和最终电位 $V_i(t^+)$。\n\n让我们对任何神经元 $i$ 逐一比较这些步骤：\n\n- **衰减步骤**：事件驱动模型的步骤 (a) 与同步模型的步骤 (1) 完全相同。两者都计算出相同的值 $V_i(t^-) = V_i(t_{\\mathrm{last},i})\\exp(-(t-t_{\\mathrm{last},i})/\\tau)$。\n- **累积步骤**：正如为不变量 II 所证明的，事件驱动模型中由 $(\\phi(e), i, \\kappa)$ 排序顺序决定的步骤 (b) 和 (c) 的组合，计算出的门控输入总和与同步模型步骤 (2) 中定义的总和 $S_i(t)$ 完全相同。\n- **阈值和脉冲步骤**：现在，两个模型都拥有相同的衰减后电位 $V_i(t^-)$ 和相同的门控输入总和 $S_i(t)$。\n    - 产生脉冲的条件是 $V_i(t^-)+S_i(t) \\ge V_{\\mathrm{th}}$。由于所有项都相同，因此这个布尔比较的结果对两个模型来说是相同的。这证明了不变量 III (脉冲边界确定性)：神经元 $i$ 在时间 $t$ 在一个模型中产生脉冲，当且仅当它在另一个模型中也产生脉冲。\n    - 最终电位 $V_i(t^+)$ 由此条件确定。如果产生脉冲，在两个模型中 $V_i(t^+) = V_{\\mathrm{reset}}$。如果不产生脉冲，在两个模型中 $V_i(t^+) = V_i(t^-) + S_i(t)$。由于所有右侧的量都相同，所以得到的 $V_i(t^+)$ 也相同。这证明了不变量 I (同步等价性)。\n\n总之，所提出的时间冲突消解策略确定性地对事件处理队列进行排序，以确保在给定时间戳，所有不应期结束事件都在任何输入事件之前处理。这种过程性排序是指定同步语义的正确实现，确保了输入门控是基于最新的不应期状态。因此，事件驱动的微更新计算出的门控输入总和、脉冲发生情况以及更新后的膜电位与同步参考模型完全相同，从而保持了不变量 I、II 和 III。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required.\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and comparing the event-driven and\n    synchronous micro-update models for a suite of test cases.\n    \"\"\"\n    \n    # Define test cases. Using -np.inf for past refractory periods.\n    test_cases = [\n        {\n            \"N\": 1, \"V_initial\": np.array([0.3]), \"t_last\": np.array([0.0]),\n            \"t_ref_end\": np.array([-np.inf]), \"V_th\": 1.0, \"V_reset\": 0.0, \"tau\": 20.0,\n            \"t\": 10.0, \"events\": [('input', 0, 0.5), ('input', 0, 0.25)]\n        },\n        {\n            \"N\": 1, \"V_initial\": np.array([0.0]), \"t_last\": np.array([0.0]),\n            \"t_ref_end\": np.array([10.0]), \"V_th\": 1.0, \"V_reset\": 0.0, \"tau\": 20.0,\n            \"t\": 10.0, \"events\": [('refr_end', 0), ('input', 0, 1.0)]\n        },\n        {\n            \"N\": 1, \"V_initial\": np.array([0.4]), \"t_last\": np.array([0.0]),\n            \"t_ref_end\": np.array([12.0]), \"V_th\": 1.0, \"V_reset\": 0.0, \"tau\": 20.0,\n            \"t\": 10.0, \"events\": [('input', 0, 0.7)]\n        },\n        {\n            \"N\": 2, \"V_initial\": np.array([0.0, 0.8]), \"t_last\": np.array([0.0, 0.0]),\n            \"t_ref_end\": np.array([-np.inf, -np.inf]), \"V_th\": 1.0, \"V_reset\": 0.0, \"tau\": 20.0,\n            \"t\": 5.0, \"events\": [('input', 0, 0.5), ('input', 0, 0.5), ('input', 1, 0.125)]\n        },\n        {\n            \"N\": 2, \"V_initial\": np.array([0.5, 0.2]), \"t_last\": np.array([0.0, 0.0]),\n            \"t_ref_end\": np.array([20.0, 25.0]), \"V_th\": 1.0, \"V_reset\": 0.0, \"tau\": 20.0,\n            \"t\": 20.0, \"events\": [('refr_end', 0), ('input', 0, 0.25), ('input', 0, 0.25), ('input', 1, 0.9), ('input', 1, 0.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run both simulation models\n        v_sync, s_sync, spiked_sync = synchronous_update(\n            case[\"N\"], case[\"V_initial\"], case[\"t_last\"], case[\"t_ref_end\"], case[\"V_th\"],\n            case[\"V_reset\"], case[\"tau\"], case[\"t\"], case[\"events\"]\n        )\n        \n        v_event, s_event, spiked_event = event_driven_update(\n            case[\"N\"], case[\"V_initial\"], case[\"t_last\"], case[\"t_ref_end\"], case[\"V_th\"],\n            case[\"V_reset\"], case[\"tau\"], case[\"t\"], case[\"events\"]\n        )\n\n        # Check invariants\n        # Invariant I: Post-update potentials must be equal\n        inv1_ok = np.allclose(v_sync, v_event)\n        \n        # Invariant II: Gated input sums must be equal\n        inv2_ok = np.allclose(s_sync, s_event)\n        \n        # Invariant III: Spike decisions must be identical\n        inv3_ok = np.array_equal(spiked_sync, spiked_event)\n        \n        results.append(inv1_ok and inv2_ok and inv3_ok)\n\n    # Format the final output as a string\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef synchronous_update(N, V_initial, t_last, t_ref_end_initial, V_th, V_reset, tau, t, events):\n    \"\"\"\n    Implements the synchronous reference micro-update.\n    Returns final potential, gated input sum, and spike vector.\n    \"\"\"\n    # Create copies to avoid side effects\n    t_ref_end_updated = np.copy(t_ref_end_initial)\n\n    # Per Invariant II, handle refractory-end events before gating inputs\n    for event in events:\n        if event[0] == 'refr_end':\n            neuron_idx = event[1]\n            t_ref_end_updated[neuron_idx] = t\n    \n    # Step 1: Decay potentials\n    V_decayed = V_initial * np.exp(-(t - t_last) / tau)\n    \n    # Step 2: Accumulate gated input sum S\n    S = np.zeros(N)\n    for event in events:\n        if event[0] == 'input':\n            neuron_idx, weight = event[1], event[2]\n            # Gating condition using the updated refractory time\n            if t >= t_ref_end_updated[neuron_idx]:\n                S[neuron_idx] += weight\n                \n    # Step 3: Apply thresholding and reset\n    V_integrated = V_decayed + S\n    spiked = V_integrated >= V_th\n    V_plus = np.where(spiked, V_reset, V_integrated)\n    \n    return V_plus, S, spiked\n\ndef event_driven_update(N, V_initial, t_last, t_ref_end_initial, V_th, V_reset, tau, t, events):\n    \"\"\"\n    Implements the event-driven micro-update with the specified tie-breaking policy.\n    Returns final potential, gated input sum, and spike vector.\n    \"\"\"\n    # Step (a): Decay potentials\n    V_minus = V_initial * np.exp(-(t - t_last) / tau)\n    \n    # Prepare events for sorting with phase and stable index\n    # (phi, neuron_idx, kappa, event_tuple)\n    # phi=0 for 'refr_end', phi=1 for 'input'\n    # kappa is the original index in the list for a stable sort\n    sorted_events = []\n    for kappa, event in enumerate(events):\n        event_type = event[0]\n        neuron_idx = event[1]\n        phi = 0 if event_type == 'refr_end' else 1\n        sorted_events.append((phi, neuron_idx, kappa, event))\n    \n    sorted_events.sort()\n\n    # Initialize working state variables\n    t_ref_end_current = np.copy(t_ref_end_initial)\n    S = np.zeros(N)\n\n    # Process events in sorted order\n    # Step (b): Process 'refr_end' events\n    for phi, neuron_idx, kappa, event in sorted_events:\n        if phi == 0: # 'refr_end' event\n            t_ref_end_current[neuron_idx] = t\n\n    # Step (c): Process 'input' events\n    for phi, neuron_idx, kappa, event in sorted_events:\n        if phi == 1: # 'input' event\n            weight = event[2]\n            # Gating condition using the most current refractory time\n            if t >= t_ref_end_current[neuron_idx]:\n                S[neuron_idx] += weight\n\n    # Step (d): Apply thresholding\n    V_integrated = V_minus + S\n    spiked = V_integrated >= V_th\n    V_plus = np.where(spiked, V_reset, V_integrated)\n    \n    return V_plus, S, spiked\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们通过探索一种增强时间步进法的混合策略来总结。虽然前面的练习突出了基本时间步进法的局限性，但这项实践展示了如何恢复因离散化而损失的部分时间精度。您的任务是设计一个鲁棒的步内事件检测器，它使用多项式插值来精确估计神经元膜电位跨越发放阈值的时刻，即使该时刻发生在两个离散时间步之间。这项技术对于既要求高性能又需要精确脉冲时间的模拟至关重要。",
            "id": "4044420",
            "problem": "您正在为一个单室漏电积分-发放膜建立模型，该模型可在固定时间步长内检测向上的阈值穿越事件。在时间步长 $[t_n, t_{n+1}]$ 内，膜电位 $V(t)$ 在恒定电流作用下遵循以下常微分方程：\n$$\nC \\,\\frac{dV}{dt} = -g_L \\,\\big(V(t) - E_L\\big) + I,\n$$\n其中，$C$ 是电容，$g_L$ 是漏电导，$E_L$ 是漏泄反转电位，$I$ 是该区间上的恒定输入电流。膜时间常数为 $\\tau_m = C/g_L$，稳态电位为 $V_\\infty = E_L + I/g_L$。\n\n您的目标是设计一个鲁棒的步内事件检测器，如果存在向上穿越阈值 $V_\\theta$ 的情况，该检测器返回唯一的穿越时间 $t^\\star \\in [t_n, t_{n+1}]$，否则返回一个哨兵值。该检测器必须基于步长内 $V(t)$ 的一个局部多项式插值，并且必须强制单调性以避免由过冲引起的伪脉冲。\n\n仅从上述基本定义和输入电流在时间步长内恒定的假设出发，完成以下任务：\n\n- 从微分方程及其推论 $\\frac{dV}{dt} = -\\frac{1}{\\tau_m}\\big(V(t) - V_\\infty\\big)$ 出发，推导一种局部插值策略。该策略使用值 $V_n = V(t_n)$ 和 $V_{n+1} = V(t_{n+1})$，以及端点导数 $\\dot V_n = \\frac{dV}{dt}(t_n)$ 和 $\\dot V_{n+1} = \\frac{dV}{dt}(t_{n+1})$。插值函数必须是基于归一化时间 $s = \\frac{t - t_n}{h}$（其中 $h = t_{n+1} - t_n$）的三次 Hermite 多项式。\n- 解释当 $V_{n+1} > V_n$ 或 $V_{n+1}  V_n$ 时，如何通过适当地限制端点斜率来强制插值函数的单调性以防止过冲。您的斜率限制方法必须从保持单调数据形状的第一性原理推导得出，并且必须适用于递增和递减数据。\n- 提出一种区间求根方法，该方法在向上穿越被区间限定时，能保证找到插值方程 $H(s) = V_\\theta$ 在 $s \\in [0,1]$ 内的唯一根，并且可证明在没有区间限定的情况下不会报告穿越。该方法必须在存在 $|\\dot V|$ 很小的近切线穿越时保持鲁棒性。您的方法必须返回绝对时间 $t^\\star = t_n + s^\\star h$（单位：秒），或者在没有向上穿越被区间限定时返回一个哨兵值。\n- 采用以下检测策略：仅当 $V_n  V_\\theta \\le V_{n+1}$ 且单调插值函数在 $[0,1]$ 中有唯一根时，才报告事件；如果在左边界处 $V_n$ 在容差 $\\varepsilon = 10^{-12}\\,\\mathrm{V}$ 内恰好等于 $V_\\theta$，则返回哨兵值，表示没有新事件；如果在容差范围内 $V_{n+1}$ 恰好等于 $V_\\theta$ 且 $V_n  V_\\theta$，则返回 $t^\\star = t_{n+1}$。\n\n实现要求：\n\n- 对每个测试用例，使用恒定输入的精确解从 $V_n$ 计算 $V_{n+1}$：\n$$\nV_{n+1} = V_\\infty + \\big(V_n - V_\\infty\\big)\\,e^{-h/\\tau_m}.\n$$\n使用 $\\dot V = -\\frac{1}{\\tau_m}\\big(V - V_\\infty\\big)$ 计算端点导数。\n- 在 $s \\in [0,1]$ 上用基函数构建三次 Hermite 插值 $H(s)$，并应用一个保持单调性的斜率限制器。然后，当且仅当 $V_n  V_\\theta \\le V_{n+1}$ 时，使用区间法求解 $H(s^\\star) = V_\\theta$ 找到 $s^\\star \\in [0,1]$，并返回 $t^\\star = t_n + s^\\star h$（单位：秒）。\n- 如果没有向上穿越被区间限定，则返回哨兵值 $-1.0$。所有返回的时间必须以秒为单位。\n\n测试套件：\n\n使用以下六个测试用例，每个用例均以国际单位制 $(C, g_L, E_L, I, V_n, t_n, h, V_\\theta)$ 的形式给出，并为检测到的向上穿越输出绝对时间（单位：秒），如果未检测到事件，则输出 $-1.0$。\n\n- 案例 1（理想路径，明确穿越）：$C = 200\\times 10^{-12}\\,\\mathrm{F}$，$g_L = 10\\times 10^{-9}\\,\\mathrm{S}$，$E_L = -0.07\\,\\mathrm{V}$，$I = 1\\times 10^{-9}\\,\\mathrm{A}$，$V_n = -0.055\\,\\mathrm{V}$，$t_n = 0.0\\,\\mathrm{s}$，$h = 0.002\\,\\mathrm{s}$，$V_\\theta = -0.05\\,\\mathrm{V}$。\n- 案例 2（步长内无穿越）：$C = 200\\times 10^{-12}\\,\\mathrm{F}$，$g_L = 10\\times 10^{-9}\\,\\mathrm{S}$，$E_L = -0.07\\,\\mathrm{V}$，$I = 0.3\\times 10^{-9}\\,\\mathrm{A}$，$V_n = -0.06\\,\\mathrm{V}$，$t_n = 0.010\\,\\mathrm{s}$，$h = 0.001\\,\\mathrm{s}$，$V_\\theta = -0.05\\,\\mathrm{V}$。\n- 案例 3（起始点在阈值之上，递减；无向上穿越）：$C = 200\\times 10^{-12}\\,\\mathrm{F}$，$g_L = 10\\times 10^{-9}\\,\\mathrm{S}$，$E_L = -0.07\\,\\mathrm{V}$，$I = 0.0\\,\\mathrm{A}$，$V_n = -0.048\\,\\mathrm{V}$，$t_n = 0.020\\,\\mathrm{s}$，$h = 0.003\\,\\mathrm{s}$，$V_\\theta = -0.05\\,\\mathrm{V}$。\n- 案例 4（在右端点处精确边界穿越）：$C = 200\\times 10^{-12}\\,\\mathrm{F}$，$g_L = 10\\times 10^{-9}\\,\\mathrm{S}$，$E_L = -0.07\\,\\mathrm{V}$，$I = 1\\times 10^{-9}\\,\\mathrm{A}$，$V_n = -0.05410168771008193\\,\\mathrm{V}$，$t_n = 0.030\\,\\mathrm{s}$，$h = 0.001\\,\\mathrm{s}$，$V_\\theta = -0.05\\,\\mathrm{V}$。\n- 案例 5（小斜率的近切线穿越）：$C = 200\\times 10^{-12}\\,\\mathrm{F}$，$g_L = 10\\times 10^{-9}\\,\\mathrm{S}$，$E_L = -0.07\\,\\mathrm{V}$，$I = 0.21\\times 10^{-9}\\,\\mathrm{A}$，$V_n = -0.051\\,\\mathrm{V}$，$t_n = 0.040\\,\\mathrm{s}$，$h = 0.020\\,\\mathrm{s}$，$V_\\theta = -0.05\\,\\mathrm{V}$。\n- 案例 6（在左端点处触及边界；应报告无新事件）：$C = 200\\times 10^{-12}\\,\\mathrm{F}$，$g_L = 10\\times 10^{-9}\\,\\mathrm{S}$，$E_L = -0.07\\,\\mathrm{V}$，$I = 1\\times 10^{-9}\\,\\mathrm{A}$，$V_n = -0.05\\,\\mathrm{V}$，$t_n = 0.050\\,\\mathrm{s}$，$h = 0.002\\,\\mathrm{s}$，$V_\\theta = -0.05\\,\\mathrm{V}$。\n\n最终输出规范：\n\n- 对于每个测试用例，您的程序必须计算绝对穿越时间 $t^\\star$（以秒为单位的浮点数），或者如果根据上述策略未检测到向上穿越，则计算哨兵值 $-1.0$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_i$ 是案例 $i$ 的结果（单位：秒）。",
            "solution": "该问题要求为漏电积分-发放（LIF）神经元模型在单个时间步长 $[t_n, t_{n+1}]$ 内设计一个鲁棒的事件检测器。这涉及到推导并实现一个保形三次 Hermite 插值，以找到向上阈值穿越的精确时间。\n\n膜电位 $V(t)$ 由以下线性常微分方程（ODE）控制：\n$$\nC \\,\\frac{dV}{dt} = -g_L \\,\\big(V(t) - E_L\\big) + I\n$$\n其中 $C$ 是膜电容，$g_L$ 是漏电导，$E_L$ 是漏泄反转电位，$I$ 是在时长为 $h = t_{n+1} - t_n$ 的时间步长内的恒定输入电流。该方程可以根据膜时间常数 $\\tau_m = C/g_L$ 和稳态电位 $V_\\infty = E_L + I/g_L$ 重写为：\n$$\n\\frac{dV}{dt} = -\\frac{1}{\\tau_m}\\big(V(t) - V_\\infty\\big)\n$$\n给定初始电位 $V_n = V(t_n)$，对于 $t \\in [t_n, t_{n+1}]$ 的精确解为：\n$$\nV(t) = V_\\infty + \\big(V_n - V_\\infty\\big)\\,e^{-(t-t_n)/\\tau_m}\n$$\n由此，我们可以计算步长末端的电位 $V_{n+1} = V(t_{n+1})$，以及端点处的导数 $\\dot V_n = \\frac{dV}{dt}(t_n)$ 和 $\\dot V_{n+1} = \\frac{dV}{dt}(t_{n+1})$。\n\n任务的核心是在归一化时间区间 $s \\in [0, 1]$（其中 $s = (t - t_n)/h$）上构建一个插值多项式 $H(s)$。该插值函数使用 $(V_n, V_{n+1}, \\dot V_n, \\dot V_{n+1})$ 这四条信息来近似步长内的 $V(t)$，并找到满足 $V(t^\\star) = V_\\theta$ 的时间 $t^\\star$。\n\n**1. 三次 Hermite 插值**\n\n一个三次多项式有四个自由度，可以由两点处的函数值和一阶导数唯一确定。与 $s=0$ 和 $s=1$ 处的函数值 $V_n, V_{n+1}$ 以及缩放后的导数 $d_n=h\\dot V_n, d_{n+1}=h\\dot V_{n+1}$ 相匹配的三次 Hermite 插值 $H(s)$ 由下式给出：\n$$\nH(s) = H_{00}(s)V_n + H_{10}(s)d_n + H_{01}(s)V_{n+1} + H_{11}(s)d_{n+1}\n$$\n其中 $H_{ij}(s)$ 是 Hermite 基函数：\n- $H_{00}(s) = 2s^3 - 3s^2 + 1$\n- $H_{10}(s) = s^3 - 2s^2 + s$\n- $H_{01}(s) = -2s^3 + 3s^2$\n- $H_{11}(s) = s^3 - s^2$\n\n这些基函数满足属性 $H_{00}(0)=1$, $H_{01}(1)=1$, $H_{10}'(0)=1$, $H_{11}'(1)=1$，在端点处所有其他值和导数均为零。\n\n**2. 强制单调性与斜率限制**\n\n标准三次插值可能会出现“过冲”，产生原始数据中不存在的局部极值。这可能导致伪脉冲检测。为确保插值函数在数据表明其应为单调（即当 $V_{n+1} > V_n$ 或 $V_{n+1}  V_n$）时是单调的，我们必须对斜率 $d_n$ 和 $d_{n+1}$ 进行约束。\n\n分析和确保三次曲线保形特性的一个强大方法是将其表示从 Hermite 形式转换为 Bézier 形式。一条三次 Bézier 曲线由四个控制点 $P_0, P_1, P_2, P_3$ 定义。该曲线保证被包含在这些点的凸包内。单调性的一个充分条件是控制点本身是单调的（例如，$P_0 \\le P_1 \\le P_2 \\le P_3$）。\n\nHermite 表示 $(V_n, d_n, V_{n+1}, d_{n+1})$ 与贝塞尔控制点（在值维度上）之间的关系是：\n- $P_0 = V_n$\n- $P_1 = V_n + d_n/3$\n- $P_2 = V_{n+1} - d_{n+1}/3$\n- $P_3 = V_{n+1}$\n\n令 $\\Delta = V_{n+1} - V_n$。\n为了使插值函数单调递增 ($V_n \\le V_{n+1}$)，我们需要 $P_0 \\le P_1 \\le P_2 \\le P_3$。 这对斜率产生以下条件：\n1. $P_0 \\le P_1 \\implies V_n \\le V_n + d_n/3 \\implies d_n \\ge 0$\n2. $P_2 \\le P_3 \\implies V_{n+1} - d_{n+1}/3 \\le V_{n+1} \\implies d_{n+1} \\ge 0$\n3. $P_1 \\le P_2 \\implies V_n + d_n/3 \\le V_{n+1} - d_{n+1}/3 \\implies d_n + d_{n+1} \\le 3(V_{n+1} - V_n) = 3\\Delta$\n\n对于单调递减的插值函数 ($V_n \\ge V_{n+1}$)，不等式反向，得到条件 $d_n \\le 0$, $d_{n+1} \\le 0$ 和 $d_n + d_{n+1} \\ge 3\\Delta$。\n\n为了强制执行这些属性，我们对原始斜率 $d_n^{orig} = h\\dot V_n$ 和 $d_{n+1}^{orig} = h\\dot V_{n+1}$ 应用斜率限制算法，以获得受限斜率 $d_n^{lim}$ 和 $d_{n+1}^{lim}$：\n- 如果 $\\Delta = 0$：区间是平的。为防止任何凸起，必须有 $d_n^{lim} = 0$ 和 $d_{n+1}^{lim} = 0$。\n- 如果 $\\Delta > 0$：\n    1. 强制符号正确：$d_n' = \\max(0, d_n^{orig})$，$d_{n+1}' = \\max(0, d_{n+1}^{orig})$。\n    2. 强制幅度约束：如果 $d_n' + d_{n+1}' > 3\\Delta$，则将两个斜率都乘以一个因子 $\\lambda = \\frac{3\\Delta}{d_n' + d_{n+1}'}$。最终的受限斜率为 $d_n^{lim} = \\lambda d_n'$ 和 $d_{n+1}^{lim} = \\lambda d_{n+1}'$。否则，$d_n^{lim} = d_n'$ 和 $d_{n+1}^{lim} = d_{n+1}'$。\n- 如果 $\\Delta  0$：\n    1. 强制符号正确：$d_n' = \\min(0, d_n^{orig})$，$d_{n+1}' = \\min(0, d_{n+1}^{orig})$。\n    2. 强制幅度约束：如果 $d_n' + d_{n+1}'  3\\Delta$，则将两个斜率都乘以一个因子 $\\lambda = \\frac{3\\Delta}{d_n' + d_{n+1}'}$（注意，由于所有项都为负，$\\lambda > 0$）。最终的受限斜率为 $d_n^{lim} = \\lambda d_n'$ 和 $d_{n+1}^{lim} = \\lambda d_{n+1}'$。否则，$d_n^{lim} = d_n'$ 和 $d_{n+1}^{lim} = d_{n+1}'$。\n\n此过程保证了使用受限斜率的三次 Hermite 插值 $H(s)$ 在 $s \\in [0, 1]$ 上是单调的。\n\n**3. 求根与检测策略**\n\n当电位 $V(t)$ 从下方穿越阈值 $V_\\theta$ 时，发生向上穿越事件。检测策略如下：\n- 仅当向上穿越被步长端点所限定时，即 $V_n  V_\\theta \\le V_{n+1}$，才搜索事件。\n- 如果 $V_n$ 已经达到或高于阈值，或者在数值上无法区分（对于一个小的容差 $\\varepsilon = 10^{-12}\\,\\mathrm{V}$，有 $|V_n - V_\\theta| \\le \\varepsilon$），则认为在此步长内没有*新*事件发生。\n- 如果轨迹在右边界恰好落在阈值上（$|V_{n+1} - V_\\theta| \\le \\varepsilon$）且起始电位低于阈值（$V_n  V_\\theta$），则报告穿越时间为 $t_{n+1}$。\n- 在所有其他情况下，当 $V_n  V_\\theta  V_{n+1}$ 时，我们必须为 $s \\in (0, 1)$ 求解方程 $H(s) - V_\\theta = 0$ 的根。\n\n条件 $V_n  V_\\theta$ 和 $V_{n+1} > V_\\theta$ 意味着 $H(0) - V_\\theta  0$ 和 $H(1) - V_\\theta > 0$。由于插值函数 $H(s)$ 已被设为单调，因此保证在 $(0, 1)$ 中存在唯一的根 $s^\\star$。\n\n需要一种鲁棒的区间求根算法。Brent 方法是一个理想的选择，因为它结合了二分法的保证收敛性与割线法和逆二次插值的更快收敛速度。即使在导数很小的近切线穿越情况下，它也具有鲁棒性。\n\n每个时间步长的整体算法如下：\n1. 使用 ODE 的精确解计算 $V_{n+1}$。\n2. 检查检测策略：如果 $|V_n - V_\\theta| \\le \\varepsilon$ 或者不满足条件 $V_n  V_\\theta \\le V_{n+1}$，则返回哨兵值 $-1.0$。\n3. 如果 $V_n  V_\\theta$ 且 $|V_{n+1} - V_\\theta| \\le \\varepsilon$，则返回 $t_n + h$。\n4. 否则（$V_n  V_\\theta  V_{n+1}$），计算导数 $\\dot V_n, \\dot V_{n+1}$，确定受限斜率 $d_n^{lim}, d_{n+1}^{lim}$，并定义函数 $f(s) = H(s) - V_\\theta$。\n5. 使用 Brent 方法（例如 `scipy.optimize.brentq`）在区间 $[0, 1]$ 中找到 $f(s)$ 的根 $s^\\star$。\n6. 返回绝对穿越时间 $t^\\star = t_n + s^\\star h$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the spike times in a leaky integrate-and-fire model\n    using a shape-preserving cubic Hermite interpolant for event detection.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, clear crossing)\n        (200e-12, 10e-9, -0.07, 1e-9, -0.055, 0.0, 0.002, -0.05),\n        # Case 2 (no crossing within step)\n        (200e-12, 10e-9, -0.07, 0.3e-9, -0.06, 0.010, 0.001, -0.05),\n        # Case 3 (start above threshold, decreasing; no upward crossing)\n        (200e-12, 10e-9, -0.07, 0.0, -0.048, 0.020, 0.003, -0.05),\n        # Case 4 (boundary crossing exactly at right endpoint)\n        (200e-12, 10e-9, -0.07, 1e-9, -0.05410168771008193, 0.030, 0.001, -0.05),\n        # Case 5 (near-tangential crossing with small slope)\n        (200e-12, 10e-9, -0.07, 0.21e-9, -0.051, 0.040, 0.020, -0.05),\n        # Case 6 (boundary touch at left endpoint; should report no new event)\n        (200e-12, 10e-9, -0.07, 1e-9, -0.05, 0.050, 0.002, -0.05),\n    ]\n\n    results = []\n    sentinel = -1.0\n    epsilon = 1e-12\n\n    for case in test_cases:\n        C, g_L, E_L, I, V_n, t_n, h, V_theta = case\n\n        # 1. Calculate model parameters and endpoint value\n        tau_m = C / g_L\n        V_inf = E_L + I / g_L\n        V_n_plus_1 = V_inf + (V_n - V_inf) * np.exp(-h / tau_m)\n\n        # 2. Apply the detection policy\n        # If starts at or above threshold, no new event.\n        if V_n >= V_theta or abs(V_n - V_theta) = epsilon:\n            results.append(sentinel)\n            continue\n\n        # An upward crossing is only possible if V_n  V_theta = V_n+1\n        if not (V_n  V_theta = V_n_plus_1):\n            results.append(sentinel)\n            continue\n        \n        # If crosses exactly at the right boundary\n        if abs(V_n_plus_1 - V_theta) = epsilon:\n            results.append(t_n + h)\n            continue\n\n        # 3. Setup for interpolation and root-finding\n        # Calculate endpoint derivatives and normalized slopes\n        V_dot_n = -(V_n - V_inf) / tau_m\n        V_dot_n_plus_1 = -(V_n_plus_1 - V_inf) / tau_m\n        d_n_orig = h * V_dot_n\n        d_n_plus_1_orig = h * V_dot_n_plus_1\n        \n        # 4. Apply monotonicity-preserving slope limiter\n        delta = V_n_plus_1 - V_n\n        d_n_lim, d_n_plus_1_lim = d_n_orig, d_n_plus_1_orig\n\n        if delta > 0:\n            d_n_lim = max(0.0, d_n_lim)\n            d_n_plus_1_lim = max(0.0, d_n_plus_1_lim)\n            if d_n_lim + d_n_plus_1_lim > 3 * delta:\n                lam = (3 * delta) / (d_n_lim + d_n_plus_1_lim)\n                d_n_lim *= lam\n                d_n_plus_1_lim *= lam\n        elif delta  0: # This branch is not strictly needed for V_n  V_theta = V_n+1\n            d_n_lim = min(0.0, d_n_lim)\n            d_n_plus_1_lim = min(0.0, d_n_plus_1_lim)\n            # Avoid division by zero if both slopes are zero\n            if d_n_lim + d_n_plus_1_lim != 0 and d_n_lim + d_n_plus_1_lim  3 * delta:\n                lam = (3 * delta) / (d_n_lim + d_n_plus_1_lim)\n                d_n_lim *= lam\n                d_n_plus_1_lim *= lam\n        else: # delta == 0\n            d_n_lim, d_n_plus_1_lim = 0.0, 0.0\n            \n        # 5. Define root function f(s) = H(s) - V_theta\n        def hermite_interpolant(s, v0, v1, d0, d1):\n            s2 = s * s\n            s3 = s2 * s\n            h00 = 2 * s3 - 3 * s2 + 1\n            h10 = s3 - 2 * s2 + s\n            h01 = -2 * s3 + 3 * s2\n            h11 = s3 - s2\n            return h00 * v0 + h10 * d0 + h01 * v1 + h11 * d1\n\n        def root_function(s):\n            return hermite_interpolant(s, V_n, V_n_plus_1, d_n_lim, d_n_plus_1_lim) - V_theta\n\n        # 6. Find the root s_star using a robust bracketing method\n        try:\n            # The bracket is guaranteed by the policy checks and monotonicity\n            s_star = brentq(root_function, 0, 1)\n            t_star = t_n + s_star * h\n            results.append(t_star)\n        except ValueError:\n            # Should not happen with current logic, but as a fallback\n            results.append(sentinel)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}