{
    "hands_on_practices": [
        {
            "introduction": "要实现片上可塑性，我们首先必须对学习规则有清晰的数学描述。本练习聚焦于脉冲时间依赖可塑性（Spike-Timing-Dependent Plasticity, STDP）的经典模型，其中权重变化由突触前和突触后脉冲的精确时间差 $\\Delta t$ 决定。通过为单个脉冲对计算权重更新，您将具体地理解STDP学习窗口是如何通过指数衰减迹线来定义的。",
            "id": "4054266",
            "problem": "一个互补金属氧化物半导体（CMOS）神经形态突触实现了基于脉冲对的脉冲时间依赖可塑性（STDP），其中脉冲时间由一阶漏电积分器生成的指数衰减的突触前和突触后轨迹编码。设突触前轨迹 $x_{+}(t)$ 和突触后轨迹 $x_{-}(t)$ 由以下标准线性时不变动力学定义：\n$$\n\\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\sum_{k} \\delta\\!\\left(t - t^{\\mathrm{pre}}_{k}\\right), \n\\qquad\n\\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\sum_{\\ell} \\delta\\!\\left(t - t^{\\mathrm{post}}_{\\ell}\\right),\n$$\n初始条件为，当 $t  \\min\\{t^{\\mathrm{pre}}_{k},t^{\\mathrm{post}}_{\\ell}\\}$ 时，$x_{+}(t)=0$ 和 $x_{-}(t)=0$。突触权重 $w$ 在事件发生时通过对相应的轨迹进行采样来更新，这符合基于脉冲对的STDP定义：在突触后脉冲时刻 $t^{\\mathrm{post}}$，施加一个长时程增强增量\n$$\n\\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right),\n$$\n在突触前脉冲时刻 $t^{\\mathrm{pre}}$，施加一个长时程抑制减量\n$$\n\\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right),\n$$\n其中 $A_{+}0$、$A_{-}0$、$\\tau_{+}0$ 和 $\\tau_{-}0$ 是电路参数。\n\n考虑一个单一孤立的脉冲对，其中一个突触前脉冲在 $t=0$ 时刻，一个突触后脉冲在 $t=\\Delta t$ 时刻，其中 $\\Delta t = 12\\ \\text{ms}$。在区间 $(-\\infty,\\infty)$ 内没有其他脉冲，且轨迹未饱和。电路参数为 $A_{+} = 0.01$、$\\tau_{+} = 20\\ \\text{ms}$、$A_{-} = 0.012$ 和 $\\tau_{-} = 18\\ \\text{ms}$。仅使用上述定义和线性时不变系统特性，确定由这个单一脉冲对产生的瞬时突触更新量 $\\Delta w$。\n\n将最终答案表示为一个无量纲的实数，四舍五入到四位有效数字。最终答案中不要包含单位。",
            "solution": "在尝试求解之前，将首先根据指定标准对问题进行验证。\n\n### 第 1 步：提取已知信息\n已知信息如下：\n- 突触前轨迹动力学：$\n\\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\sum_{k} \\delta\\!\\left(t - t^{\\mathrm{pre}}_{k}\\right)\n$\n- 突触后轨迹动力学：$\n\\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\sum_{\\ell} \\delta\\!\\left(t - t^{\\mathrm{post}}_{\\ell}\\right)\n$\n- 初始条件：当 $t  \\min\\{t^{\\mathrm{pre}}_{k},t^{\\mathrm{post}}_{\\ell}\\}$ 时，$x_{+}(t)=0$ 和 $x_{-}(t)=0$。\n- 突触权重更新规则：\n  - 在突触后脉冲时刻 $t^{\\mathrm{post}}$ 的长时程增强 (LTP)：$\\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right)$\n  - 在突触前脉冲时刻 $t^{\\mathrm{pre}}$ 的长时程抑制 (LTD)：$\\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right)$\n- 脉冲时间：一个突触前脉冲发生在 $t^{\\mathrm{pre}} = 0$，一个突触后脉冲发生在 $t^{\\mathrm{post}} = \\Delta t$。\n- 电路参数：\n  - $\\Delta t = 12\\ \\text{ms}$\n  - $A_{+} = 0.01$\n  - $\\tau_{+} = 20\\ \\text{ms}$\n  - $A_{-} = 0.012$\n  - $\\tau_{-} = 18\\ \\text{ms}$\n- 问题要求计算这个单一脉冲对的总瞬时突触更新量 $\\Delta w$。\n\n### 第 2 步：使用提取的已知信息进行验证\n对问题陈述进行有效性评估：\n- **科学依据**：该问题描述了一个数学上精确且标准的基于脉冲对的脉冲时间依赖可塑性 (STDP) 模型，这是计算神经科学和神经形态工程中的一个基本概念。使用以狄拉克δ函数为输入的一阶线性微分方程是模拟此类现象的公认有效方法。\n- **适定性**：该问题定义清晰，提供了所有必要的方程、参数、初始条件和脉冲时间。它有一个唯一且有意义的解，可以直接从所提供的信息中推导出来。\n- **客观性**：该问题使用形式化的数学语言和客观、明确的术语进行陈述。\n\n该问题没有表现出任何诸如科学性不健全、不完整、矛盾或模糊之类的缺陷。\n\n### 第 3 步：结论和行动\n该问题被认为是 **有效的**。将推导解答。\n\n总突触权重更新量 $\\Delta w$ 是在脉冲时刻发生的所有单个更新的总和。有两个脉冲事件：一个在 $t=0$ 的突触前脉冲和一个在 $t=\\Delta t$ 的突触后脉冲。\n\n1.  **在突触前脉冲时刻 $t=0$ 的权重更新**：\n    在突触前脉冲时刻 $t^{\\mathrm{pre}} = 0$，权重变化由 LTD 规则确定：\n    $$\n    \\Delta w(t=0) = \\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right) = -A_{-}\\, x_{-}\\!\\left(0^{-}\\right)\n    $$\n    为了找到在 $t=0$ 之前突触后轨迹 $x_{-}(t)$ 的值，我们考察其控制微分方程：\n    $$\n    \\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\delta\\!\\left(t - \\Delta t\\right)\n    $$\n    该系统的唯一输入是在 $t=\\Delta t = 12\\ \\text{ms}$ 时刻的单个突触后脉冲。初始条件规定，在第一个突触后脉冲之前的所有时间 $t$，都有 $x_{-}(t)=0$。由于 $0  \\Delta t$，因此对于任何时间 $t  \\Delta t$，都有 $x_{-}(t)=0$。具体来说，在 $t=0^{-}$ 时，我们有：\n    $$\n    x_{-}\\!\\left(0^{-}\\right) = 0\n    $$\n    因此，在突触前脉冲时刻的权重更新为：\n    $$\n    \\Delta w(t=0) = -A_{-} \\times 0 = 0\n    $$\n\n2.  **在突触后脉冲时刻 $t=\\Delta t$ 的权重更新**：\n    在突触后脉冲时刻 $t^{\\mathrm{post}} = \\Delta t$，权重变化由 LTP 规则确定：\n    $$\n    \\Delta w(t=\\Delta t) = \\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right) = A_{+}\\, x_{+}\\!\\left(\\Delta t^{-}\\right)\n    $$\n    为了求得此值，我们必须首先求解突触前轨迹 $x_{+}(t)$。其动力学由以下方程给出：\n    $$\n    \\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\delta\\!\\left(t - 0\\right)\n    $$\n    这是一个一阶线性常微分方程。在 $t=0$ 处的狄拉克δ函数 $\\delta(t)$ 导致 $x_{+}(t)$ 的值发生瞬时跳变。我们可以通过在无穷小区间 $[0^{-}, 0^{+}]$ 上对该方程进行积分来求得此跳变的大小：\n    $$\n    \\int_{0^{-}}^{0^{+}} \\frac{d x_{+}}{dt} dt = \\int_{0^{-}}^{0^{+}} \\left(-\\frac{x_{+}}{\\tau_{+}}\\right) dt + \\int_{0^{-}}^{0^{+}} \\delta(t) dt\n    $$\n    这得到：\n    $$\n    x_{+}(0^{+}) - x_{+}(0^{-}) = 0 + 1\n    $$\n    假设 $x_{+}$ 本身不是一个分布，当积分区间缩小时，项 $-x_{+}/\\tau_{+}$ 的积分趋于零。根据初始条件，我们知道对于 $t0$ 有 $x_{+}(t)=0$，所以 $x_{+}(0^{-})=0$。因此，脉冲发生后轨迹的瞬时值为：\n    $$\n    x_{+}(0^{+}) = 1\n    $$\n    对于 $t > 0$，系统是无源的，其动力学由齐次方程决定：\n    $$\n    \\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}}\n    $$\n    在初始条件 $x_{+}(0^{+})=1$ 下，该方程的解是一个指数衰减：\n    $$\n    x_{+}(t) = \\exp\\left(-\\frac{t}{\\tau_{+}}\\right) \\quad \\text{for } t > 0\n    $$\n    我们需要在突触后脉冲发生前的一刻，$t = \\Delta t^{-}$，评估该轨迹的值。由于函数 $x_{+}(t)$ 在 $t>0$ 时是连续的，所以 $x_{+}(\\Delta t^{-}) = x_{+}(\\Delta t)$。\n    $$\n    x_{+}\\!\\left(\\Delta t^{-}\\right) = \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    因此，在 $t=\\Delta t$ 时的权重更新为：\n    $$\n    \\Delta w(t=\\Delta t) = A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n\n3.  **总突触更新**：\n    总更新量 $\\Delta w$ 是所有脉冲事件处更新量的总和：\n    $$\n    \\Delta w = \\Delta w(t=0) + \\Delta w(t=\\Delta t) = 0 + A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    $$\n    \\Delta w = A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    现在，我们代入给定的数值：$A_{+} = 0.01$，$\\Delta t = 12\\ \\text{ms}$，以及 $\\tau_{+} = 20\\ \\text{ms}$。$\\Delta t$ 和 $\\tau_{+}$ 中的时间单位 (ms) 会消掉，留下一个符合要求的无量纲指数。\n    $$\n    \\Delta w = 0.01 \\times \\exp\\left(-\\frac{12}{20}\\right) = 0.01 \\times \\exp(-0.6)\n    $$\n    计算数值：\n    $$\n    \\exp(-0.6) \\approx 0.548811636\n    $$\n    $$\n    \\Delta w \\approx 0.01 \\times 0.548811636 = 0.00548811636\n    $$\n    问题要求将答案四舍五入到四位有效数字。\n    $$\n    \\Delta w \\approx 0.005488\n    $$",
            "answer": "$$\\boxed{0.005488}$$"
        },
        {
            "introduction": "STDP模型依赖于指数衰减的迹线，但我们如何在物理电路中生成这些信号呢？本练习将探讨一种漏积分器（leaky integrator）的模拟电路实现，它是片上可塑性电路的一个基本构建模块，使用工作在亚阈值区的晶体管。通过从第一性原理推导该积分器的时间常数 $\\tau$，您将揭示其对物理参数（如热电压 $U_T$）和温度的依赖关系，并思考创建稳定、鲁棒的学习系统的策略。",
            "id": "4054208",
            "problem": "一个一阶对数域积分器使用工作在亚阈值区的金属氧化物半导体场效应晶体管 (MOSFET) 器件构建，其斜率因子为 $n$，热电压为 $U_{T} = k_{B} T / q$，其中 $k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，$q$ 是元电荷。该积分器采用一个电容 $C$，连接到一个节点，该节点的电压通过指数型亚阈值电流-电压关系对状态电流的对数进行编码，并采用一个跨导线性环路来强制实现一个关于该电流的一阶线性微分方程。驱动跨导线性环路的偏置电流由一个温度相关的参考源生成，使得 $I_{b}(T) = I_{b0} \\left(\\frac{T}{T_{0}}\\right)^{\\alpha}$，其中 $I_{b0}$ 是参考温度 $T_{0}$ 下的偏置电流，$\\alpha$ 是由偏置架构设定的可设计指数（例如，对于与绝对温度成正比 (PTAT) 的情况，$\\alpha = 1$；对于与绝对温度成反比 (CTAT) 的情况，$\\alpha = -1$）。\n\n仅从电容器上的电荷守恒、斜率因子为 $n$ 的指数型亚阈值电流-电压定律以及热电压 $U_{T}$ 的定义出发，推导积分器时间常数 $\\tau$ 随温度变化的规律。以 $n$、$C$、$k_{B}$、$q$、$T$、$I_{b0}$、$T_{0}$ 和 $\\alpha$ 的形式，报告 $\\tau(T)$ 的闭式表达式。最终答案以秒为单位表示。此外，讨论通过适当选择 $\\alpha$ 以及补偿 $n$ 的任何残余温度依赖性来最小化 $\\tau$ 的温度漂移的偏置策略，但不要将此讨论包含在最终表达式中。",
            "solution": "该问题要求推导一阶对数域积分器的随温度变化的时间常数 $\\tau(T)$，并讨论温度补偿策略。\n\n首先对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   **系统**：一阶对数域积分器。\n-   **器件**：工作在亚阈值区的金属氧化物半导体场效应晶体管 (MOSFET) 器件。\n-   **器件/物理参数**：\n    -   斜率因子：$n$。\n    -   热电压：$U_{T} = k_{B} T / q$。\n    -   玻尔兹曼常数：$k_{B}$。\n    -   绝对温度：$T$。\n    -   元电荷：$q$。\n-   **电路元件和原理**：\n    -   一个电容，容值为 $C$。\n    -   电容器两端的节点电压 $V_{node}$ 对状态电流 $I_{state}$ 的对数进行编码。\n    -   电路基于指数型亚阈值电流-电压关系工作。\n    -   一个跨导线性环路强制实现一个关于状态电流的一阶线性微分方程。\n-   **偏置电流**：\n    -   随温度变化的偏置电流：$I_{b}(T) = I_{b0} \\left(\\frac{T}{T_{0}}\\right)^{\\alpha}$。\n    -   $I_{b0}$ 是参考温度 $T_{0}$ 下的偏置电流。\n    -   $\\alpha$ 是一个可设计的指数。\n-   **任务**：\n    1.  推导积分器时间常数 $\\tau$ 作为温度的函数 $\\tau(T)$。\n    2.  以 $n, C, k_{B}, q, T, I_{b0}, T_{0}, \\alpha$ 的形式给出闭式表达式。\n    3.  讨论最小化 $\\tau$ 温度漂移的偏置策略。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在科学上是合理的。它基于模拟和神经形态 VLSI 设计中一个标准的、有据可查的电路原型。其原理——亚阈值 MOSFET 物理、跨导线性原理和对数域滤波——是低功耗模拟信号处理的基石。\n-   **适定性**：该问题是适定的。它提供了一套清晰的物理定律和电路约束，并要求推导一个特定参数，即时间常数 $\\tau$。所提供的信息足以得出一个唯一的解析解。\n-   **客观性**：该问题以精确、客观和技术性的语言陈述，没有歧义或主观论断。\n\n### 步骤 3：结论与行动\n该问题是有效的。它是模拟集成电路理论中一个标准的、非平凡的问题。将提供一个合理的解决方案。\n\n### 时间常数 $\\tau(T)$ 的推导\n\n推导过程通过连接所提供的三个基本原理进行：电容器上的电荷守恒、亚阈值 MOSFET 电流-电压定律以及由跨导线性环路决定的动态行为。\n\n**1. 将电容电压与状态电流关联起来：**\n问题陈述该积分器工作在亚阈值区。在此区域，MOSFET 的漏极电流 $I_D$ 是其栅源电压 $V_{GS}$ 的指数函数。对于一个承载状态电流 $I_{state}$ 的二极管连接晶体管（栅极连接到漏极），其电压 $V_{node}$ 与 $I_{state}$ 的关系如下：\n$$I_{state} = I_{s} \\exp\\left(\\frac{V_{node}}{n U_T}\\right)$$\n其中 $I_s$ 是与工艺相关的饱和电流，$n$ 是斜率因子。电压 $V_{node}$ 是电容器 $C$ 两端的电压。我们可以通过反转此关系来用 $I_{state}$ 表示 $V_{node}$：\n$$V_{node} = n U_T \\ln\\left(\\frac{I_{state}}{I_s}\\right)$$\n\n**2. 将电容电流与状态电流的变化率关联起来：**\n流过电容器的电流 $I_C$ 由电容定律给出：\n$$I_C = C \\frac{dV_{node}}{dt}$$\n为了用 $I_{state}$ 表示 $I_C$，我们对 $V_{node}$ 的表达式关于时间 $t$ 求导。使用链式法则，并将 $n$、$U_T$ 和 $I_s$ 视为相对于电路的动态时间尺度是常数（但不一定相对于温度 $T$ 是常数）：\n$$\\frac{dV_{node}}{dt} = \\frac{d}{dt} \\left[ n U_T \\ln\\left(\\frac{I_{state}}{I_s}\\right) \\right] = n U_T \\frac{I_s}{I_{state}} \\left(\\frac{1}{I_s} \\frac{dI_{state}}{dt}\\right) = \\frac{n U_T}{I_{state}} \\frac{dI_{state}}{dt}$$\n将此结果代入电容电流方程，得到：\n$$I_C = C \\left(\\frac{n U_T}{I_{state}}\\right) \\frac{dI_{state}}{dt}$$\n\n**3. 整合跨导线性环路动力学：**\n问题陈述一个跨导线性环路强制实现一个关于状态电流的一阶线性微分方程。这种方程的规范形式是 $\\tau \\frac{dI_{state}}{dt} + I_{state} = I_{in}$，其中 $I_{in}$ 是输入电流。时间常数 $\\tau$ 由系统的衰减特性决定，这对应于 $I_{in} = 0$ 的情况。微分方程变为：\n$$\\frac{dI_{state}}{dt} = -\\frac{1}{\\tau} I_{state}$$\n对数域积分器的电路实现使用偏置电流 $I_b$ 来设定积分或衰减的速率。对于衰减阶段，跨导线性电路被设计为从电容节点吸收一个恒定电流，其大小等于偏置电流 $I_b$。因此，电容电流为 $I_C = -I_b$。\n\n**4. 求解时间常数 $\\tau$：**\n我们现在有两个描述衰减期间电路行为的表达式：\n从动力学可知：$\\frac{dI_{state}}{dt} = -\\frac{I_{state}}{\\tau}$\n从电路物理学可知，当 $I_C = -I_b$ 时：$-I_b = C \\left(\\frac{n U_T}{I_{state}}\\right) \\frac{dI_{state}}{dt}$\n\n我们可以将第一个方程代入第二个方程：\n$$-I_b = C \\left(\\frac{n U_T}{I_{state}}\\right) \\left(-\\frac{I_{state}}{\\tau}\\right)$$\n$-1$ 和 $I_{state}$ 项相互消去：\n$$I_b = \\frac{C n U_T}{\\tau}$$\n求解时间常数 $\\tau$ 得到对数域积分器的基本关系：\n$$\\tau = \\frac{C n U_T}{I_b}$$\n\n**5. 将时间常数表示为温度的函数：**\n我们已知 $U_T$ 和 $I_b$ 的温度依赖性：\n$$U_T(T) = \\frac{k_B T}{q}$$\n$$I_b(T) = I_{b0} \\left(\\frac{T}{T_0}\\right)^{\\alpha}$$\n电容 $C$ 和元电荷 $q$ 被认为是与温度无关的。斜率因子 $n$ 有弱的温度依赖性，但问题要求以 $n$ 作为参数推导表达式，然后讨论其补偿，所以我们将其保留为 $n$。将随温度变化的表达式代入 $\\tau$ 的方程：\n$$\\tau(T) = \\frac{C n \\cdot U_T(T)}{I_b(T)} = \\frac{C n \\left(\\frac{k_B T}{q}\\right)}{I_{b0} \\left(\\frac{T}{T_0}\\right)^{\\alpha}}$$\n为了简化，我们可以分离出随温度变化的部分：\n$$\\tau(T) = \\frac{C n k_B}{q I_{b0}} \\cdot \\frac{T}{ \\left(\\frac{T}{T_0}\\right)^{\\alpha} } = \\frac{C n k_B}{q I_{b0}} \\cdot T \\cdot T^{-\\alpha} \\cdot T_0^{\\alpha}$$\n合并包含 $T$ 的项，得到最终的闭式表达式：\n$$\\tau(T) = \\frac{C n k_B T_0^{\\alpha}}{q I_{b0}} T^{1-\\alpha}$$\n该表达式的单位是秒，经量纲分析验证：$\\frac{F \\cdot J/K \\cdot K^{\\alpha} \\cdot K^{1-\\alpha}}{C \\cdot A} = \\frac{(s/\\Omega) \\cdot (J)}{A \\cdot s \\cdot A} = \\frac{J}{\\Omega \\cdot A^2} = \\frac{V \\cdot A \\cdot s}{ (V/A) \\cdot A^2} = s$。\n\n### 温度漂移补偿的讨论\n\n推导出的表达式 $\\tau(T) \\propto n(T) T^{1-\\alpha}$揭示了积分器的时间常数如何随温度变化。最小化这种温度漂移对于构建稳定可靠的系统至关重要。\n\n**一阶补偿：**\n主要的温度依赖性来自项 $T^{1-\\alpha}$。为了消除这种依赖性，设计者可以选择偏置指数 $\\alpha$，使得 $T$ 的指数变为零。\n$$1 - \\alpha = 0 \\implies \\alpha = 1$$\n$\\alpha = 1$ 的偏置电流被称为与绝对温度成正比 (PTAT) 的电流，即 $I_b(T) \\propto T$。通过使用 PTAT 偏置电流，时间常数在一阶近似下变为：\n$$\\tau = \\frac{C n k_B T_0}{q I_{b0}}$$\n在这种情况下，热电压 $U_T$ 的线性温度依赖性被 PTAT 偏置电流 $I_b$ 的线性温度依赖性精确抵消，从而使得 $\\tau$ 与温度无关（假设 $n$ 是常数）。\n\n**对 $n(T)$ 的二阶补偿：**\n斜率因子 $n$ 并非完全不随温度变化。它由 $n \\approx 1 + C_{dep}/C_{ox}$ 给出，其中 $C_{dep}$ 是沟道的耗尽层电容。$C_{dep}$ 具有弱的温度依赖性，主要通过费米势体现，这导致 $n$ 具有一个小的负温度系数（即，随着 $T$ 增加，$n$ 会轻微减小）。让我们将这种依赖性建模为幂律关系，$n(T) \\propto T^{\\beta}$，其中 $\\beta$ 是一个小的负数（例如，$\\beta \\approx -0.05$）。\n\n那么 $\\tau$ 的完全温度依赖性为：\n$$\\tau(T) \\propto n(T) T^{1-\\alpha} \\propto T^{\\beta} T^{1-\\alpha} = T^{1+\\beta-\\alpha}$$\n为了实现 $\\tau$ 的零温度系数，我们现在必须将总指数设为零：\n$$1 + \\beta - \\alpha = 0 \\implies \\alpha = 1 + \\beta$$\n由于 $\\beta$ 是一个小的负数，$\\alpha$ 的理想值将略小于 $1$。例如，如果 $\\beta = -0.05$，最佳选择将是 $\\alpha = 0.95$。这需要一个“亚线性”的 PTAT 偏置电流，即一个随温度增加但增速略慢于纯 PTAT 电流的电流。这样的电流源可以通过对一个 PTAT 电流 ($I_1 \\propto T$) 和一个与温度无关的（零温度系数，ZTC）电流 ($I_2 = \\text{const}$) 进行加权求和来合成，即 $I_b(T) = w_1 I_1(T) + w_2 I_2(T)$，其中权重 $w_1$ 和 $w_2$ 的选择是为了在工作温度范围内近似所需的目标 $T^{1+\\beta}$ 依赖关系。这种二阶补偿方案可以设计出高度稳定的对数域时间常数。",
            "answer": "$$\\boxed{\\frac{C n k_{B} T_{0}^{\\alpha}}{q I_{b0}} T^{1-\\alpha}}$$"
        },
        {
            "introduction": "除了模拟电路，可塑性规则也可以用数字逻辑实现，这在精度、功耗和灵活性方面提供了一套不同的权衡。本练习将挑战您设计并仿真一个基于有限状态机（Finite-State Machine, FSM）的数字STDP学习引擎。通过使用循环缓冲器和查找表来近似STDP规则，您将获得设计可扩展数字神经形态处理器所需的算法思维的实践经验。",
            "id": "4054257",
            "problem": "您的任务是形式化并实现一个用于片上学习的同步、事件驱动的有限状态机 (FSM)，该状态机在离散时间设置下使用查找表来模拟脉冲时间依赖可塑性 (STDP)。该 FSM 必须在可配置的窗口内累积近期突触前和突触后脉冲的计数，并根据脉冲事件的相对时间应用权重更新。最终的程序必须模拟一组指定的测试用例，并为每个用例输出最终的突触权重。\n\n从以下基础概念开始：\n- 脉冲时间依赖可塑性 (STDP) 是一项经实验证实的原理，即突触权重的更新取决于突触前脉冲和突触后脉冲之间的相对时间差。如果突触前脉冲在突触后脉冲之前发生，突触将经历长时程增强 (LTP)；如果突触后脉冲在突触前脉冲之前发生，突触将经历长时程抑制 (LTD)。\n- 在数字神经形态硬件中，时间被离散化为时间步 (ticks)。设离散时间索引为 $t \\in \\{0,1,\\dots,T-1\\}$。每个时间步处理二进制输入事件 $x_{\\mathrm{pre}}(t) \\in \\{0,1\\}$ 和 $x_{\\mathrm{post}}(t) \\in \\{0,1\\}$，它们分别指示在时间 $t$ 是否发生了突触前或突触后脉冲。\n- 查找表可以近似 STDP 学习窗口。定义两个查找表 $L_+[\\delta]$ 用于增强，$L_-[\\delta]$ 用于抑制，其索引分别为 $\\delta \\in \\{1,2,\\dots,W_+\\}$ 和 $\\delta \\in \\{1,2,\\dots,W_-\\}$。这里，$W_+$ 和 $W_-$ 是增强和抑制的窗口长度，$\\delta$ 表示事件之间的离散正延迟。在此模型中，$\\delta=0$（同时脉冲）的情况不会产生更新。\n\n根据以下规则构建 FSM：\n- 定义状态以反映每个时间步的处理流水线：$S_{\\mathrm{age}}$（推进时间并老化缓冲区）、$S_{\\mathrm{acc\\_pre}}$（累积突触前脉冲）、$S_{\\mathrm{acc\\_post}}$（累积突触后脉冲）和 $S_{\\mathrm{update}}$（计算并应用权重更新）。\n- FSM 在每个时间步按固定顺序运行：$S_{\\mathrm{age}} \\rightarrow S_{\\mathrm{acc\\_pre}} \\rightarrow S_{\\mathrm{acc\\_post}} \\rightarrow S_{\\mathrm{update}}$。此顺序确保更新仅依赖于已定义窗口内的过去事件。\n- 维护两个长度为 $W=\\max(W_+,W_-)$ 的循环缓冲区：$B_{\\mathrm{pre}}$ 和 $B_{\\mathrm{post}}$，用于存储在离散延迟处的脉冲整型计数。设缓冲区指针为 $p \\in \\{0,1,\\dots,W-1\\}$，指示当前的零延迟仓。在每个时间步的 $S_{\\mathrm{age}}$ 状态中，更新 $p \\leftarrow (p+1) \\bmod W$ 并清除两个缓冲区中的仓 $p$，以代表新的当前时间槽。\n- 在 $S_{\\mathrm{acc\\_pre}}$ 中，如果 $x_{\\mathrm{pre}}(t)=1$，则增加 $B_{\\mathrm{pre}}[p]$。在 $S_{\\mathrm{acc\\_post}}$ 中，如果 $x_{\\mathrm{post}}(t)=1$，则增加 $B_{\\mathrm{post}}[p]$。\n- 在 $S_{\\mathrm{update}}$ 中，仅当 $x_{\\mathrm{post}}(t)=1$ 时，使用索引映射 $\\mathrm{idx}(\\delta) = (p-\\delta) \\bmod W$ 计算增强贡献，该贡献是对延迟 1 到 $W_+$ 的过去突触前计数的总和：\n  $$\\Delta w_+(t) = \\sum_{\\delta=1}^{W_+} L_+[\\delta] \\cdot B_{\\mathrm{pre}}[\\mathrm{idx}(\\delta)]。$$\n  仅当 $x_{\\mathrm{pre}}(t)=1$ 时，计算抑制贡献，该贡献是对延迟 1 到 $W_-$ 的过去突触后计数的总和：\n  $$\\Delta w_-(t) = \\sum_{\\delta=1}^{W_-} L_-[\\delta] \\cdot B_{\\mathrm{post}}[\\mathrm{idx}(\\delta)]。$$\n  应用净更新\n  $$w \\leftarrow \\mathrm{clip}\\left(w + \\Delta w_+(t) - \\Delta w_-(t),\\, w_{\\min},\\, w_{\\max}\\right)$$\n  其中 $\\mathrm{clip}(\\cdot)$ 函数使权重饱和，以保持在指定边界 $[w_{\\min}, w_{\\max}]$ 内。\n\n实现约束：\n- 程序必须完全按照上述描述实现 FSM，使用循环缓冲区累积计数，并使用查找表计算 $\\Delta w$ 贡献。$\\delta=0$ 的情况必须不产生更新；只有严格的正延迟才有贡献。在同一时间步 ($\\delta=0$) 发生的并发事件不得对任何更新产生贡献。\n- 输入脉冲是为测试套件固定的、硬编码的序列。没有外部输入。每个测试用例从初始权重 $w_0$ 开始独立运行，并且必须记录 $T$ 个时间步后的最终权重。\n\n测试套件：\n对于每个测试用例，给定参数 $(T, W_+, W_-, L_+, L_-, w_0, w_{\\min}, w_{\\max}, \\mathcal{P}, \\mathcal{Q})$，其中 $\\mathcal{P}$ 和 $\\mathcal{Q}$ 分别是突触前和突触后脉冲时间的集合。以下所有数字都是无单位的离散计数。共有 5 个测试用例：\n- 案例 1（增强主导，窗口内配对）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{2, 10\\}$, $\\mathcal{Q}=\\{4, 12\\}$.\n- 案例 2（抑制主导，窗口内配对）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{5, 15\\}$, $\\mathcal{Q}=\\{3, 13\\}$.\n- 案例 3（无脉冲，边界情况）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\emptyset$, $\\mathcal{Q}=\\emptyset$.\n- 案例 4（脉冲在窗口外，边界情况）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{0\\}$, $\\mathcal{Q}=\\{10\\}$.\n- 案例 5（重度配对下的饱和，边界行为）：\n  - $T=6$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{0,1,2,3,4\\}$, $\\mathcal{Q}=\\{1,2,3,4,5\\}$.\n\n输出规格：\n- 程序必须为每个测试用例计算处理完所有 $T$ 个时间步后的最终突触权重 $w$。\n- 每个结果必须是四舍五入到 6 位小数的浮点数。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$[w_1,w_2,w_3,w_4,w_5]$）。\n\n不允许外部输入；所有参数均按测试套件固定。不涉及角度。不涉及物理单位；所有量均为无量纲的离散计数。FSM 和 LUT 操作必须完全按照描述实现，以确保科学真实性和内部一致性。",
            "solution": "我们从脉冲时间依赖可塑性 (STDP) 的实验基础定义开始：突触权重的更新取决于突触前脉冲和突触后脉冲之间的相对时间。具体而言，突触前脉冲先于突触后脉冲会产生长时程增强 (LTP)，而突触后脉冲先于突触前脉冲则会产生长时程抑制 (LTD)。在片上学习电路中，时间是离散表示的；因此我们考虑时间步 $t \\in \\{0,1,\\dots,T-1\\}$，并使用二进制脉冲指示符 $x_{\\mathrm{pre}}(t)$ 和 $x_{\\mathrm{post}}(t)$。\n\n为了在离散时间内忠实地模拟硬件中的 STDP，我们必须：\n1. 累积足够的脉冲历史记录，以确定在有限学习窗口内的相对时间。\n2. 根据 $+\\Delta t$ 和 $-\\Delta t$ 的时间关系应用更新，其幅度由学习窗口函数控制。\n\n查找表是学习窗口的一种以硬件为中心的实现方式。我们定义用于增强的 $L_+[\\delta]$ 和用于抑制的 $L_-[\\delta]$，它们作用于正延迟 $\\delta = 1,2,\\dots$。这些表近似了连续的 STDP 核函数。离散 FSM 将实现基于脉冲对的 STDP：\n- 如果发生突触后脉冲，它会从过去 $W_+$ 个时间步内的任何突触前脉冲中诱导出增强贡献，其幅度由 $L_+[\\delta]$ 决定。\n- 如果发生突触前脉冲，它会从过去 $W_-$ 个时间步内的任何突触后脉冲中诱导出抑制贡献，其幅度由 $L_-[\\delta]$ 决定。\n\n我们使用长度为 $W = \\max(W_+, W_-)$ 的循环缓冲区 $B_{\\mathrm{pre}}$ 和 $B_{\\mathrm{post}}$ 来表示历史记录。指针 $p$ 指示当前的零延迟仓。在每个时间步，$p$ 按照模 $W$ 递增 1，并且新的仓被清除以接收当前时间的事件。对于严格为正的延迟 $\\delta$，保存 $\\delta$ 个时间步之前事件的缓冲区索引是 $\\mathrm{idx}(\\delta) = (p - \\delta) \\bmod W$。这种映射确保了先进先出的老化过程，而无需移动数据，这与硬件友好的设计相一致。\n\nFSM 设计：\n- 在 $S_{\\mathrm{age}}$ 中，设置 $p \\leftarrow (p + 1) \\bmod W$，清除 $B_{\\mathrm{pre}}[p]$ 和 $B_{\\mathrm{post}}[p]$。\n- 在 $S_{\\mathrm{acc\\_pre}}$ 中，如果 $x_{\\mathrm{pre}}(t) = 1$，则增加 $B_{\\mathrm{pre}}[p]$。\n- 在 $S_{\\mathrm{acc\\_post}}$ 中，如果 $x_{\\mathrm{post}}(t) = 1$，则增加 $B_{\\mathrm{post}}[p]$。\n- 在 $S_{\\mathrm{update}}$ 中，计算\n  $$\\Delta w_+(t) = \\begin{cases}\n  \\sum_{\\delta=1}^{W_+} L_+[\\delta] \\cdot B_{\\mathrm{pre}}[(p-\\delta)\\bmod W],  \\text{if } x_{\\mathrm{post}}(t)=1,\\\\\n  0,  \\text{otherwise},\n  \\end{cases}$$\n  $$\\Delta w_-(t) = \\begin{cases}\n  \\sum_{\\delta=1}^{W_-} L_-[\\delta] \\cdot B_{\\mathrm{post}}[(p-\\delta)\\bmod W],  \\text{if } x_{\\mathrm{pre}}(t)=1,\\\\\n  0,  \\text{otherwise}.\n  \\end{cases}$$\n  然后应用饱和更新\n  $$w \\leftarrow \\mathrm{clip}\\left(w + \\Delta w_+(t) - \\Delta w_-(t),\\, w_{\\min},\\, w_{\\max}\\right)。$$\n排除 $\\delta=0$ 强制要求同时发生的脉冲不产生贡献，这是一个合理且常用的离散时间近似方法。\n\n算法的正确性直接源于将基于脉冲对的 STDP 原理映射到离散缓冲区上：增强是在突触后触发事件之前对突触前事件求和，而抑制是在突触前触发事件之前对突触后事件求和，两者都受限于可配置的有限窗口。循环缓冲区和指针算术一致地实现了时间老化。\n\n我们现在为指定的测试用例计算最终权重。权重更新是在每个时间步循序进行的。\n\n给定 $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$, $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$。\n\n-   案例 1：$\\mathcal{P}=\\{2,10\\}$, $\\mathcal{Q}=\\{4,12\\}$, $T=20$, $W_+=W_-=5$。\n    -   初始: $w=0.5$。\n    -   $t=4$（突触后脉冲）: 触发增强。一个在 $t=2$ 的突触前脉冲，延迟 $\\delta=2$。$\\Delta w = L_+[1] = 0.3$。$w \\leftarrow \\text{clip}(0.5+0.3, 0, 1) = 0.8$。\n    -   $t=12$（突触后脉冲）: 触发增强。一个在 $t=10$ 的突触前脉冲，延迟 $\\delta=2$。$\\Delta w = L_+[1] = 0.3$。$w \\leftarrow \\text{clip}(0.8+0.3, 0, 1) = \\text{clip}(1.1, 0, 1) = 1.0$。\n    -   最终权重为 $1.0$。\n\n-   案例 2：$\\mathcal{P}=\\{5,15\\}$, $\\mathcal{Q}=\\{3,13\\}$, $T=20$, $W_+=W_-=5$。\n    -   初始: $w=0.5$。\n    -   $t=5$（突触前脉冲）: 触发抑制。一个在 $t=3$ 的突触后脉冲，延迟 $\\delta=2$。$\\Delta w = -L_-[1] = -0.2$。$w \\leftarrow \\text{clip}(0.5-0.2, 0, 1) = 0.3$。\n    -   $t=15$（突触前脉冲）: 触发抑制。一个在 $t=13$ 的突触后脉冲，延迟 $\\delta=2$。$\\Delta w = -L_-[1] = -0.2$。$w \\leftarrow \\text{clip}(0.3-0.2, 0, 1) = 0.1$。\n    -   最终权重为 $0.1$。\n\n-   案例 3：$\\mathcal{P}=\\emptyset$, $\\mathcal{Q}=\\emptyset$, $T=20$。\n    没有脉冲，不发生更新。最终权重为 $0.5$。\n\n-   案例 4：$\\mathcal{P}=\\{0\\}$, $\\mathcal{Q}=\\{10\\}$, $T=20$。\n    在 $t=10$ 发生突触后脉冲，但最近的突触前脉冲在 $t=0$，延迟 $\\delta=10$。这超出了增强窗口 $W_+=5$。不发生更新。最终权重为 $0.5$。\n\n-   案例 5：$\\mathcal{P}=\\{0,1,2,3,4\\}$, $\\mathcal{Q}=\\{1,2,3,4,5\\}$, $T=6$, $W_+=W_-=5$。\n    -   初始: $w=0.5$。\n    -   $t=1$（前后脉冲）: $\\Delta w_+ = L_+[0] = 0.4$ (来自 $t=0$ 的 pre)。$w \\leftarrow 0.5+0.4 = 0.9$。\n    -   $t=2$（前后脉冲）: $\\Delta w_+ = L_+[0] + L_+[1] = 0.4+0.3=0.7$ (来自 $t=1,0$ 的 pre)。$\\Delta w_- = L_-[0] = 0.3$ (来自 $t=1$ 的 post)。$w \\leftarrow \\text{clip}(0.9 + 0.7 - 0.3, 0, 1) = \\text{clip}(1.3, 0, 1) = 1.0$。\n    -   从 $t=2$ 开始，权重已饱和在 $w=1.0$。后续更新不会改变其值。\n    -   最终权重为 $1.0$。\n\n因此，当四舍五入到 6 位小数时，预期的最终权重为 $[1.000000, 0.100000, 0.500000, 0.500000, 1.000000]$。所提供的程序将实现该 FSM 并精确地产生这些输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(T, W_plus, W_minus, L_plus, L_minus, w0, wmin, wmax, pre_times, post_times):\n    \"\"\"\n    Simulate the FSM-based STDP with LUT updates over T ticks.\n    - T: total ticks\n    - W_plus, W_minus: window lengths for LTP and LTD\n    - L_plus, L_minus: lookup tables for positive lags (lengths W_plus and W_minus)\n    - w0: initial weight\n    - wmin, wmax: saturation bounds\n    - pre_times, post_times: sorted lists (or sets) of tick indices with pre/post spikes\n    \"\"\"\n    W = max(W_plus, W_minus)\n    # Circular buffers for counts per lag\n    pre_buf = np.zeros(W, dtype=int)\n    post_buf = np.zeros(W, dtype=int)\n    p = -1  # pointer to current zero-lag bin; will advance at first tick to 0\n\n    w = float(w0)\n    pre_set = set(pre_times)\n    post_set = set(post_times)\n\n    for t in range(T):\n        # S_age: advance pointer and clear current bin\n        p = (p + 1) % W\n        pre_buf[p] = 0\n        post_buf[p] = 0\n\n        # Accumulate events\n        pre_event = (t in pre_set)\n        post_event = (t in post_set)\n\n        # S_acc_pre\n        if pre_event:\n            pre_buf[p] += 1\n\n        # S_acc_post\n        if post_event:\n            post_buf[p] += 1\n\n        # S_update: compute LUT-based contributions\n        delta_w = 0.0\n\n        if post_event and W_plus  0:\n            # Potentiation: sum over past pre spikes within W_plus\n            for d in range(1, W_plus + 1):\n                idx = (p - d) % W\n                count = pre_buf[idx]\n                if count:\n                    delta_w += L_plus[d - 1] * count\n\n        if pre_event and W_minus  0:\n            # Depression: sum over past post spikes within W_minus\n            for d in range(1, W_minus + 1):\n                idx = (p - d) % W\n                count = post_buf[idx]\n                if count:\n                    delta_w -= L_minus[d - 1] * count\n\n        # Apply update with saturation\n        w = max(wmin, min(wmax, w + delta_w))\n\n    return w\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [2, 10],\n            \"post_times\": [4, 12],\n        },\n        # Case 2\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [5, 15],\n            \"post_times\": [3, 13],\n        },\n        # Case 3\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [],\n            \"post_times\": [],\n        },\n        # Case 4\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [0],\n            \"post_times\": [10],\n        },\n        # Case 5\n        {\n            \"T\": 6,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [0, 1, 2, 3, 4],\n            \"post_times\": [1, 2, 3, 4, 5],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(\n            T=case[\"T\"],\n            W_plus=case[\"W_plus\"],\n            W_minus=case[\"W_minus\"],\n            L_plus=case[\"L_plus\"],\n            L_minus=case[\"L_minus\"],\n            w0=case[\"w0\"],\n            wmin=case[\"wmin\"],\n            wmax=case[\"wmax\"],\n            pre_times=case[\"pre_times\"],\n            post_times=case[\"post_times\"],\n        )\n        results.append(result)\n\n    # Format results to 6 decimal places\n    formatted = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}