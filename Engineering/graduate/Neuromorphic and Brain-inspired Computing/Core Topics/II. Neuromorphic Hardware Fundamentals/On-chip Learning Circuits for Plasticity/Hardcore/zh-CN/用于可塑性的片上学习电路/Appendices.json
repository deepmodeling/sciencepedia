{
    "hands_on_practices": [
        {
            "introduction": "这个练习提供了一个具体的起点，要求你计算由单个突触前-后脉冲对引起的权重变化 。掌握这项基本计算是理解复杂脉冲序列如何通过脉冲时间依赖可塑性（Spike-Timing-Dependent Plasticity, STDP）共同塑造突触强度的第一步。它将抽象的STDP学习窗口与一个可触摸的数值结果直接联系起来。",
            "id": "4054266",
            "problem": "一个互补金属氧化物半导体 (CMOS) 神经形态突触实现了基于脉冲对的脉冲时间依赖可塑性 (STDP)，其中脉冲时间由一阶漏电积分器生成的指数衰减的突触前和突触后轨迹编码。令突触前轨迹 $x_{+}(t)$ 和突触后轨迹 $x_{-}(t)$ 由标准线性时不变动力学定义\n$$\n\\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\sum_{k} \\delta\\!\\left(t - t^{\\mathrm{pre}}_{k}\\right), \n\\qquad\n\\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\sum_{\\ell} \\delta\\!\\left(t - t^{\\mathrm{post}}_{\\ell}\\right),\n$$\n初始条件为当 $t  \\min\\{t^{\\mathrm{pre}}_{k},t^{\\mathrm{post}}_{\\ell}\\}$ 时，$x_{+}(t)=0$ 且 $x_{-}(t)=0$。突触权重 $w$ 根据基于脉冲对的 STDP 定义，在事件发生时通过采样相应的轨迹进行更新：在突触后脉冲时间 $t^{\\mathrm{post}}$，施加一个长时程增强增量\n$$\n\\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right),\n$$\n在突触前脉冲时间 $t^{\\mathrm{pre}}$，施加一个长时程抑制减量\n$$\n\\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right),\n$$\n其中 $A_{+}0$，$A_{-}0$，$\\tau_{+}0$ 和 $\\tau_{-}0$ 是电路参数。\n\n考虑一个单个孤立的脉冲对，其中一个突触前脉冲在 $t=0$ 发生，一个突触后脉冲在 $t=\\Delta t$ 发生，其中 $\\Delta t = 12\\ \\text{ms}$。在区间 $(-\\infty,\\infty)$ 内没有其他脉冲，并且轨迹未饱和。电路参数为 $A_{+} = 0.01$，$\\tau_{+} = 20\\ \\text{ms}$，$A_{-} = 0.012$ 和 $\\tau_{-} = 18\\ \\text{ms}$。仅使用上面给出的定义和线性时不变系统特性，确定由这个单个脉冲对产生的瞬时突触更新 $\\Delta w$。\n\n将最终答案表示为一个无量纲的实数，四舍五入到四位有效数字。最终答案中不要包含单位。",
            "solution": "在尝试求解之前，将首先根据指定的标准对问题进行验证。\n\n### 第1步：提取已知条件\n已知信息如下：\n- 突触前轨迹动力学：$\n\\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\sum_{k} \\delta\\!\\left(t - t^{\\mathrm{pre}}_{k}\\right)\n$\n- 突触后轨迹动力学：$\n\\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\sum_{\\ell} \\delta\\!\\left(t - t^{\\mathrm{post}}_{\\ell}\\right)\n$\n- 初始条件：当 $t  \\min\\{t^{\\mathrm{pre}}_{k},t^{\\mathrm{post}}_{\\ell}\\}$ 时，$x_{+}(t)=0$ 且 $x_{-}(t)=0$。\n- 突触权重更新规则：\n  - 在突触后脉冲时间 $t^{\\mathrm{post}}$ 的长时程增强 (LTP)：$\\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right)$\n  - 在突触前脉冲时间 $t^{\\mathrm{pre}}$ 的长时程抑制 (LTD)：$\\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right)$\n- 脉冲时间：单个突触前脉冲发生在 $t^{\\mathrm{pre}} = 0$，单个突触后脉冲发生在 $t^{\\mathrm{post}} = \\Delta t$。\n- 电路参数：\n  - $\\Delta t = 12\\ \\text{ms}$\n  - $A_{+} = 0.01$\n  - $\\tau_{+} = 20\\ \\text{ms}$\n  - $A_{-} = 0.012$\n  - $\\tau_{-} = 18\\ \\text{ms}$\n- 问题要求计算这个单个脉冲对的总瞬时突触更新 $\\Delta w$。\n\n### 第2步：使用提取的已知条件进行验证\n对问题陈述的有效性进行评估：\n- **科学依据**：该问题描述了一个数学上精确且标准的基于脉冲对的脉冲时间依赖可塑性 (STDP) 模型，这是计算神经科学和神经形态工程中的一个基本概念。使用以狄拉克δ函数为输入的线性一阶微分方程是对此类现象建模的一种公认且有效的方法。\n- **适定性**：问题定义清晰，提供了所有必需的方程、参数、初始条件和脉冲时间。它有一个唯一且有意义的解，可以直接从所提供的信息中推导出来。\n- **客观性**：问题使用形式化的数学语言和客观、明确的术语进行陈述。\n\n该问题不存在科学上不健全、不完整、矛盾或模棱两可等任何缺陷。\n\n### 第3步：结论与行动\n该问题被判定为**有效**。将推导解答。\n\n总突触权重更新 $\\Delta w$ 是在脉冲时刻发生的所有单个更新的总和。有两个脉冲事件：一个在 $t=0$ 的突触前脉冲和一个在 $t=\\Delta t$ 的突触后脉冲。\n\n1.  **在突触前脉冲时间 $t=0$ 的权重更新**：\n    在突触前脉冲时间 $t^{\\mathrm{pre}} = 0$ 时，权重变化由 LTD 规则确定：\n    $$\n    \\Delta w(t=0) = \\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right) = -A_{-}\\, x_{-}\\!\\left(0^{-}\\right)\n    $$\n    为了找到在 $t=0$ 之前的突触后轨迹 $x_{-}(t)$ 的值，我们检查其控制微分方程：\n    $$\n    \\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\delta\\!\\left(t - \\Delta t\\right)\n    $$\n    该系统的唯一输入是在 $t=\\Delta t = 12\\ \\text{ms}$ 时的单个突触后脉冲。初始条件规定，在第一个突触后脉冲之前的所有时间 $t$，都有 $x_{-}(t)=0$。因为 $0  \\Delta t$，所以对于任何时间 $t  \\Delta t$，$x_{-}(t)=0$。具体来说，在 $t=0^{-}$ 时，我们有：\n    $$\n    x_{-}\\!\\left(0^{-}\\right) = 0\n    $$\n    因此，在突触前脉冲时间的权重更新为：\n    $$\n    \\Delta w(t=0) = -A_{-} \\times 0 = 0\n    $$\n\n2.  **在突触后脉冲时间 $t=\\Delta t$ 的权重更新**：\n    在突触后脉冲时间 $t^{\\mathrm{post}} = \\Delta t$ 时，权重变化由 LTP 规则确定：\n    $$\n    \\Delta w(t=\\Delta t) = \\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right) = A_{+}\\, x_{+}\\!\\left(\\Delta t^{-}\\right)\n    $$\n    为了求得此值，我们必须首先求解突触前轨迹 $x_{+}(t)$。其动力学由下式给出：\n    $$\n    \\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\delta\\!\\left(t - 0\\right)\n    $$\n    这是一个一阶线性常微分方程。在 $t=0$ 处的狄拉克δ函数 $\\delta(t)$ 导致 $x_{+}(t)$ 的值发生瞬时跳变。我们可以通过在无穷小区间 $[0^{-}, 0^{+}]$ 上对该方程进行积分来找到这个跳变的大小：\n    $$\n    \\int_{0^{-}}^{0^{+}} \\frac{d x_{+}}{dt} dt = \\int_{0^{-}}^{0^{+}} \\left(-\\frac{x_{+}}{\\tau_{+}}\\right) dt + \\int_{0^{-}}^{0^{+}} \\delta(t) dt\n    $$\n    这得出：\n    $$\n    x_{+}(0^{+}) - x_{+}(0^{-}) = 0 + 1\n    $$\n    假设 $x_{+}$ 本身不是一个分布，当积分区间缩小时，项 $-x_{+}/\\tau_{+}$ 的积分趋于零。根据初始条件，我们知道当 $t0$ 时 $x_{+}(t)=0$，所以 $x_{+}(0^{-})=0$。因此，脉冲刚发生后轨迹的值为：\n    $$\n    x_{+}(0^{+}) = 1\n    $$\n    对于 $t  0$，系统是无源的，其动力学由齐次方程控制：\n    $$\n    \\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}}\n    $$\n    该方程在初始条件 $x_{+}(0^{+})=1$ 下的解是一个指数衰减：\n    $$\n    x_{+}(t) = \\exp\\left(-\\frac{t}{\\tau_{+}}\\right) \\quad \\text{for } t  0\n    $$\n    我们评估该轨迹的时间点，是在突触后脉冲发生前的一刻，$t = \\Delta t^{-}$。由于函数 $x_{+}(t)$ 在 $t0$ 时是连续的，所以 $x_{+}(\\Delta t^{-}) = x_{+}(\\Delta t)$。\n    $$\n    x_{+}\\!\\left(\\Delta t^{-}\\right) = \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    因此，在 $t=\\Delta t$ 时的权重更新为：\n    $$\n    \\Delta w(t=\\Delta t) = A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n\n3.  **总突触更新**：\n    总更新 $\\Delta w$ 是所有脉冲事件处更新的总和：\n    $$\n    \\Delta w = \\Delta w(t=0) + \\Delta w(t=\\Delta t) = 0 + A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    $$\n    \\Delta w = A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    现在，我们代入给定的数值：$A_{+} = 0.01$，$\\Delta t = 12\\ \\text{ms}$，以及 $\\tau_{+} = 20\\ \\text{ms}$。$\\Delta t$ 和 $\\tau_{+}$ 中的时间单位 (ms) 相抵消，留下一个符合要求的无量纲指数。\n    $$\n    \\Delta w = 0.01 \\times \\exp\\left(-\\frac{12}{20}\\right) = 0.01 \\times \\exp(-0.6)\n    $$\n    计算数值：\n    $$\n    \\exp(-0.6) \\approx 0.548811636\n    $$\n    $$\n    \\Delta w \\approx 0.01 \\times 0.548811636 = 0.00548811636\n    $$\n    问题要求将答案四舍五入到四位有效数字。\n    $$\n    \\Delta w \\approx 0.005488\n    $$",
            "answer": "$$\\boxed{0.005488}$$"
        },
        {
            "introduction": "尽管可塑性的数学模型很优雅，但它们在模拟电路中的物理实现面临着温度漂移等现实世界的挑战。本练习深入研究了亚阈值对数域积分器，这是在芯片上实现可塑性时间常数的关键部件 。通过推导其时间常数 $\\tau$ 对温度的依赖性，你将深入了解器件物理学与电路稳定性之间的关键联系，并探索设计稳健神经形态系统的策略。",
            "id": "4054208",
            "problem": "一个一阶对数域积分器使用斜率因子为 $n$、热电压为 $U_{T} = k_{B} T / q$ 的金属-氧化物-半导体场效应晶体管 (MOSFET) 器件在亚阈值区构建，其中 $k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，$q$ 是元电荷。该积分器采用一个电容 $C$，其连接到一个节点，该节点的电压通过亚阈值区的指数型电流-电压关系编码了状态电流的对数；同时，一个跨导线性环路在该电流上强制实现一个一阶线性微分方程。驱动跨导线性环路的偏置电流由一个温度相关的参考源产生，使得 $I_{b}(T) = I_{b0} \\left(\\frac{T}{T_{0}}\\right)^{\\alpha}$，其中 $I_{b0}$ 是在参考温度 $T_{0}$ 下的偏置电流，$\\alpha$ 是由偏置架构设定的可设计指数（例如，对于与绝对温度成正比 (PTAT) 的情况，$\\alpha = 1$；对于与绝对温度成反比 (CTAT) 的情况，$\\alpha = -1$）。\n\n仅从电容上的电荷守恒、斜率因子为 $n$ 的亚阈值区指数型电流-电压定律以及热电压 $U_{T}$ 的定义出发，推导积分器时间常数 $\\tau$ 如何随温度变化。以 $n$、$C$、$k_{B}$、$q$、$T$、$I_{b0}$、$T_{0}$ 和 $\\alpha$ 的闭式表达式形式报告 $\\tau(T)$。最终答案以秒为单位表示。此外，请讨论通过恰当选择 $\\alpha$ 以及补偿 $n$ 的任何残余温度依赖性来最小化 $\\tau$ 的温度漂移的偏置策略，但不要将此讨论包含在您的最终表达式中。",
            "solution": "该问题要求推导一阶对数域积分器的温度相关时间常数 $\\tau(T)$，并讨论温度补偿策略。\n\n首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n-   **系统**：一阶对数域积分器。\n-   **器件**：工作在亚阈值区的金属-氧化物-半导体场效应晶体管 (MOSFET) 器件。\n-   **器件/物理参数**：\n    -   斜率因子：$n$。\n    -   热电压：$U_{T} = k_{B} T / q$。\n    -   玻尔兹曼常数：$k_{B}$。\n    -   绝对温度：$T$。\n    -   元电荷：$q$。\n-   **电路元件与原理**：\n    -   一个电容值为 $C$ 的电容器。\n    -   电容器两端的节点电压 $V_{node}$ 编码了状态电流 $I_{state}$ 的对数。\n    -   电路基于亚阈值区的指数型电流-电压关系工作。\n    -   一个跨导线性环路在状态电流上强制实现一个一阶线性微分方程。\n-   **偏置电流**：\n    -   温度相关的偏置电流：$I_{b}(T) = I_{b0} \\left(\\frac{T}{T_{0}}\\right)^{\\alpha}$。\n    -   $I_{b0}$ 是在参考温度 $T_{0}$ 下的偏置电流。\n    -   $\\alpha$ 是一个可设计的指数。\n-   **任务**：\n    1.  推导积分器时间常数 $\\tau$ 作为温度的函数 $\\tau(T)$。\n    2.  以 $n, C, k_{B}, q, T, I_{b0}, T_{0}, \\alpha$ 的闭式表达式形式提供结果。\n    3.  讨论最小化 $\\tau$ 的温度漂移的偏置策略。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在科学上是合理的。它基于模拟和神经形态VLSI设计中一个标准的、有据可查的电路原型。其原理——亚阈值MOSFET物理、跨导线性原理和对数域滤波——是低功耗模拟信号处理的基石。\n-   **良构性**：该问题是良构的。它提供了一套清晰的物理定律和电路约束，并要求推导一个特定参数——时间常数 $\\tau$。所提供的信息足以得出一个唯一的解析解。\n-   **客观性**：该问题以精确、客观和技术性的语言陈述，没有歧义或主观性陈述。\n\n### 步骤3：结论与行动\n该问题是有效的。它是模拟集成电路理论中一个标准的、非平凡的问题。将提供一个合理的解答。\n\n### 时间常数 $\\tau(T)$ 的推导\n\n推导过程通过连接所提供的三个基本原理进行：电容上的电荷守恒、亚阈值MOSFET的电流-电压定律以及跨导线性环路所施加的动态行为。\n\n**1. 将电容电压与状态电流关联：**\n问题陈述该积分器在亚阈值区工作。在此区域，MOSFET的漏极电流 $I_D$ 是其栅源电压 $V_{GS}$ 的指数函数。对于一个承载状态电流 $I_{state}$ 的二极管连接晶体管（栅极连接到漏极），其电压 $V_{node}$ 与 $I_{state}$ 的关系如下：\n$$I_{state} = I_{s} \\exp\\left(\\frac{V_{node}}{n U_T}\\right)$$\n其中 $I_s$ 是一个与工艺相关的饱和电流，$n$ 是斜率因子。电压 $V_{node}$ 是电容 $C$ 两端的电压。我们可以通过反转这个关系，用 $I_{state}$ 来表示 $V_{node}$：\n$$V_{node} = n U_T \\ln\\left(\\frac{I_{state}}{I_s}\\right)$$\n\n**2. 将电容电流与状态电流的变化率关联：**\n流过电容的电流 $I_C$ 由电容定律给出：\n$$I_C = C \\frac{dV_{node}}{dt}$$\n为了用 $I_{state}$ 表示 $I_C$，我们对 $V_{node}$ 的表达式关于时间 $t$ 求导。使用链式法则，并将 $n$、$U_T$ 和 $I_s$ 视为相对于电路的动态时间尺度是常数（但相对于温度 $T$ 不一定）：\n$$\\frac{dV_{node}}{dt} = \\frac{d}{dt} \\left[ n U_T \\ln\\left(\\frac{I_{state}}{I_s}\\right) \\right] = n U_T \\frac{I_s}{I_{state}} \\left(\\frac{1}{I_s} \\frac{dI_{state}}{dt}\\right) = \\frac{n U_T}{I_{state}} \\frac{dI_{state}}{dt}$$\n将此代入电容电流方程，得到：\n$$I_C = C \\left(\\frac{n U_T}{I_{state}}\\right) \\frac{dI_{state}}{dt}$$\n\n**3. 结合跨导线性环路动力学：**\n问题陈述一个跨导线性环路对状态电流强制实现一个一阶线性微分方程。这种方程的规范形式是 $\\tau \\frac{dI_{state}}{dt} + I_{state} = I_{in}$，其中 $I_{in}$ 是输入电流。时间常数 $\\tau$ 由系统的衰减特性决定，这对应于 $I_{in} = 0$ 的情况。微分方程变为：\n$$\\frac{dI_{state}}{dt} = -\\frac{1}{\\tau} I_{state}$$\n对数域积分器的电路实现使用一个偏置电流 $I_b$ 来设定积分或衰减的速率。在衰减阶段，跨导线性电路被设计为从电容节点吸收一个等于偏置电流 $I_b$ 的恒定电流。因此，电容电流为 $I_C = -I_b$。\n\n**4. 求解时间常数 $\\tau$：**\n现在我们有两个描述电路在衰减期间行为的表达式：\n从动力学角度：$\\frac{dI_{state}}{dt} = -\\frac{I_{state}}{\\tau}$\n从电路物理角度（$I_C = -I_b$）：$-I_b = C \\left(\\frac{n U_T}{I_{state}}\\right) \\frac{dI_{state}}{dt}$\n\n我们可以将第一个方程代入第二个方程：\n$$-I_b = C \\left(\\frac{n U_T}{I_{state}}\\right) \\left(-\\frac{I_{state}}{\\tau}\\right)$$\n$-1$ 和 $I_{state}$ 项相互抵消：\n$$I_b = \\frac{C n U_T}{\\tau}$$\n求解时间常数 $\\tau$ 得到对数域积分器的基本关系式：\n$$\\tau = \\frac{C n U_T}{I_b}$$\n\n**5. 将时间常数表示为温度的函数：**\n我们已知 $U_T$ 和 $I_b$ 的温度依赖性：\n$$U_T(T) = \\frac{k_B T}{q}$$\n$$I_b(T) = I_{b0} \\left(\\frac{T}{T_0}\\right)^{\\alpha}$$\n电容 $C$ 和元电荷 $q$ 被认为是与温度无关的。斜率因子 $n$ 具有弱的温度依赖性，但问题要求将表达式推导为以 $n$ 为参数的形式，然后讨论其补偿，所以我们将其保留为 $n$。将温度相关的表达式代入 $\\tau$ 的方程：\n$$\\tau(T) = \\frac{C n \\cdot U_T(T)}{I_b(T)} = \\frac{C n \\left(\\frac{k_B T}{q}\\right)}{I_{b0} \\left(\\frac{T}{T_0}\\right)^{\\alpha}}$$\n为简化起见，我们可以分离出与温度相关的部分：\n$$\\tau(T) = \\frac{C n k_B}{q I_{b0}} \\cdot \\frac{T}{ \\left(\\frac{T}{T_0}\\right)^{\\alpha} } = \\frac{C n k_B}{q I_{b0}} \\cdot T \\cdot T^{-\\alpha} \\cdot T_0^{\\alpha}$$\n合并包含 $T$ 的项，得到最终的闭式表达式：\n$$\\tau(T) = \\frac{C n k_B T_0^{\\alpha}}{q I_{b0}} T^{1-\\alpha}$$\n该表达式的单位是秒，通过量纲分析验证：$\\frac{F \\cdot J/K \\cdot K^{\\alpha} \\cdot K^{1-\\alpha}}{C \\cdot A} = \\frac{(s/\\Omega) \\cdot (J)}{A \\cdot s \\cdot A} = \\frac{J}{\\Omega \\cdot A^2} = \\frac{V \\cdot A \\cdot s}{ (V/A) \\cdot A^2} = s$。\n\n### 温度漂移补偿的讨论\n\n推导出的表达式 $\\tau(T) \\propto n(T) T^{1-\\alpha}$ 揭示了积分器的时间常数如何随温度变化。最小化这种温度漂移对于构建稳定可靠的系统至关重要。\n\n**一阶补偿：**\n主要的温度依赖性来自项 $T^{1-\\alpha}$。为了消除这种依赖性，设计者可以选择偏置指数 $\\alpha$，使得 $T$ 的指数变为零。\n$$1 - \\alpha = 0 \\implies \\alpha = 1$$\n$\\alpha = 1$ 的偏置电流被称为与绝对温度成正比 (PTAT) 电流，即 $I_b(T) \\propto T$。通过使用PTAT偏置电流，时间常数在一阶近似下变为：\n$$\\tau = \\frac{C n k_B T_0}{q I_{b0}}$$\n在这种情况下，热电压 $U_T$ 的线性温度依赖性被PTAT偏置电流 $I_b$ 的线性温度依赖性精确抵消，从而使得 $\\tau$ 与温度无关（假设 $n$ 是常数）。\n\n**$n(T)$ 的二阶补偿：**\n斜率因子 $n$ 并非完全不随温度变化。它由 $n \\approx 1 + C_{dep}/C_{ox}$ 给出，其中 $C_{dep}$ 是沟道的耗尽层电容。$C_{dep}$ 具有弱的温度依赖性，主要通过费米势起作用，这导致 $n$ 具有一个小的负温度系数（即，随着 $T$ 升高，$n$ 会轻微减小）。让我们将这种依赖性建模为幂律形式，$n(T) \\propto T^{\\beta}$，其中 $\\beta$ 是一个小的负数（例如，$\\beta \\approx -0.05$）。\n\n那么 $\\tau$ 的完整温度依赖性为：\n$$\\tau(T) \\propto n(T) T^{1-\\alpha} \\propto T^{\\beta} T^{1-\\alpha} = T^{1+\\beta-\\alpha}$$\n为了实现 $\\tau$ 的零温度系数，我们现在必须将总指数设为零：\n$$1 + \\beta - \\alpha = 0 \\implies \\alpha = 1 + \\beta$$\n由于 $\\beta$ 是一个小的负数，$\\alpha$ 的理想值将略小于1。例如，如果 $\\beta = -0.05$，最优选择将是 $\\alpha = 0.95$。这需要一个“亚线性”的PTAT偏置电流，即一个随温度升高而增加但增速略慢于纯PTAT电流的电流。这样的电流源可以通过对一个PTAT电流（$I_1 \\propto T$）和一个与温度无关的（零温度系数，ZTC）电流（$I_2 = \\text{const}$）进行加权求和来合成，即 $I_b(T) = w_1 I_1(T) + w_2 I_2(T)$，其中权重 $w_1$ 和 $w_2$ 的选择是为了在工作温度范围内近似所需的目标 $T^{1+\\beta}$ 依赖关系。这种二阶补偿方案能够设计出高度稳定的对数域时间常数。",
            "answer": "$$\\boxed{\\frac{C n k_{B} T_{0}^{\\alpha}}{q I_{b0}} T^{1-\\alpha}}$$"
        },
        {
            "introduction": "本练习挑战你将 STDP 的连续时间概念转化为具体的数字算法 。你将设计一个使用查找表（Look-Up Tables, LUTs）和循环缓冲区的有限状态机（Finite-State Machine, FSM），这些都是数字神经形态硬件中的常用技术。这项实践对于理解在芯片上创建高效、可扩展且事件驱动的学习系统所涉及的设计权衡与实现模式至关重要。",
            "id": "4054257",
            "problem": "您的任务是形式化并实现一个用于片上学习的同步、事件驱动的有限状态机（FSM），该状态机在离散时间设置下使用查找表来模拟脉冲时间依赖可塑性（STDP）。该 FSM 必须在可配置的窗口内累积近期突触前和突触后脉冲的计数，并根据脉冲事件的相对时间应用权重更新。最终的程序必须模拟一组指定的测试用例，并为每个用例输出最终的突触权重。\n\n从以下基础开始：\n- 脉冲时间依赖可塑性（STDP）是一项经实验确立的原则，即突触权重的更新取决于突触前脉冲和突触后脉冲之间的相对时间差。如果突触前脉冲发生在突触后脉冲之前，则突触会经历长时程增强（LTP）；如果突触后脉冲先于突触前脉冲，则突触会经历长时程抑制（LTD）。\n- 在数字神经形态硬件中，时间被离散化为时间步（ticks）。设离散时间索引为 $t \\in \\{0,1,\\dots,T-1\\}$。每个时间步处理二进制输入事件 $x_{\\mathrm{pre}}(t) \\in \\{0,1\\}$ 和 $x_{\\mathrm{post}}(t) \\in \\{0,1\\}$，它们指示在时间 $t$ 是否发生了突触前或突触后脉冲。\n- 查找表可以近似 STDP 学习窗口。为增强和抑制定义两个查找表 $L_+[\\delta]$ 和 $L_-[\\delta]$，其索引分别为 $\\delta \\in \\{1,2,\\dots,W_+\\}$ 和 $\\delta \\in \\{1,2,\\dots,W_-\\}$。此处，$W_+$ 和 $W_-$ 分别是增强和抑制窗口的长度，$\\delta$ 表示事件之间的离散正延迟。在此模型中，$\\delta=0$（同时脉冲）的情况不会产生更新。\n\n根据以下规则构建 FSM：\n- 定义状态以反映每个时间步的处理流水线：$S_{\\mathrm{age}}$（推进时间和老化缓冲区）、$S_{\\mathrm{acc\\_pre}}$（累积突触前脉冲）、$S_{\\mathrm{acc\\_post}}$（累积突触后脉冲）和 $S_{\\mathrm{update}}$（计算并应用权重更新）。\n- FSM 在每个时间步按固定顺序运行：$S_{\\mathrm{age}} \\rightarrow S_{\\mathrm{acc\\_pre}} \\rightarrow S_{\\mathrm{acc\\_post}} \\rightarrow S_{\\mathrm{update}}$。此顺序确保更新仅依赖于已定义窗口内的过去事件。\n- 维护两个长度为 $W=\\max(W_+,W_-)$ 的循环缓冲区：$B_{\\mathrm{pre}}$ 和 $B_{\\mathrm{post}}$，用于存储离散延迟下的脉冲整数计数。设缓冲区指针为 $p \\in \\{0,1,\\dots,W-1\\}$，指示当前的零延迟仓。在每个时间步，于 $S_{\\mathrm{age}}$ 状态下，更新 $p \\leftarrow (p+1) \\bmod W$ 并清除两个缓冲区中的仓 $p$，以代表新的当前时间槽。\n- 在 $S_{\\mathrm{acc\\_pre}}$ 中，如果 $x_{\\mathrm{pre}}(t)=1$，则增加 $B_{\\mathrm{pre}}[p]$。在 $S_{\\mathrm{acc\\_post}}$ 中，如果 $x_{\\mathrm{post}}(t)=1$，则增加 $B_{\\mathrm{post}}[p]$。\n- 在 $S_{\\mathrm{update}}$ 中，仅当 $x_{\\mathrm{post}}(t)=1$ 时，使用索引映射 $\\mathrm{idx}(\\delta) = (p-\\delta) \\bmod W$ 计算增强贡献，即对延迟为 $1$ 到 $W_+$ 的过去突触前脉冲计数求和：\n  $$\\Delta w_+(t) = \\sum_{\\delta=1}^{W_+} L_+[\\delta] \\cdot B_{\\mathrm{pre}}[\\mathrm{idx}(\\delta)].$$\n  仅当 $x_{\\mathrm{pre}}(t)=1$ 时，计算抑制贡献，即对延迟为 $1$ 到 $W_-$ 的过去突触后脉冲计数求和：\n  $$\\Delta w_-(t) = \\sum_{\\delta=1}^{W_-} L_-[\\delta] \\cdot B_{\\mathrm{post}}[\\mathrm{idx}(\\delta)].$$\n  应用净更新\n  $$w \\leftarrow \\mathrm{clip}\\left(w + \\Delta w_+(t) - \\Delta w_-(t),\\, w_{\\min},\\, w_{\\max}\\right)$$\n  其中 $\\mathrm{clip}(\\cdot)$ 函数使权重饱和，以保持在指定的边界 $[w_{\\min}, w_{\\max}]$ 内。\n\n实现约束：\n- 程序必须完全按照上述描述实现 FSM，使用循环缓冲区累积计数，并使用查找表计算 $\\Delta w$ 贡献。$\\delta=0$ 的情况必须不产生任何更新；只有严格为正的延迟才会产生贡献。同一时间步（$\\delta=0$）的并发事件不得对任何更新做出贡献。\n- 输入脉冲是为测试套件固定的、硬编码的序列。没有外部输入。每个测试用例从初始权重 $w_0$ 开始独立运行，并且必须记录 $T$ 个时间步后的最终权重。\n\n测试套件：\n对于每个测试用例，给定参数 $(T, W_+, W_-, L_+, L_-, w_0, w_{\\min}, w_{\\max}, \\mathcal{P}, \\mathcal{Q})$，其中 $\\mathcal{P}$ 和 $\\mathcal{Q}$ 分别是突触前和突触后脉冲时间的集合。以下所有数字都是无单位的离散计数。共有 $5$ 个测试用例：\n- 用例 1（增强主导，窗口内配对）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{2, 10\\}$, $\\mathcal{Q}=\\{4, 12\\}$。\n- 用例 2（抑制主导，窗口内配对）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{5, 15\\}$, $\\mathcal{Q}=\\{3, 13\\}$。\n- 用例 3（无脉冲，边缘情况）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\emptyset$, $\\mathcal{Q}=\\emptyset$。\n- 用例 4（脉冲在窗口外，边缘情况）：\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{0\\}$, $\\mathcal{Q}=\\{10\\}$。\n- 用例 5（重度配对下的饱和，边界行为）：\n  - $T=6$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{0,1,2,3,4\\}$, $\\mathcal{Q}=\\{1,2,3,4,5\\}$。\n\n输出规范：\n- 程序必须在处理完每个测试用例的所有 $T$ 个时间步后，计算最终的突触权重 $w$。\n- 每个结果必须是四舍五入到小数点后 $6$ 位的浮点数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[w_1,w_2,w_3,w_4,w_5]$）。\n\n不允许外部输入；所有参数均根据测试套件固定。不涉及角度。不涉及物理单位；所有量均为无量纲的离散计数。FSM 和 LUT 操作必须严格按照描述实现，以确保科学真实性和内部一致性。",
            "solution": "我们从脉冲时间依赖可塑性（STDP）的实验基础定义开始：突触权重的更新取决于突触前脉冲和突触后脉冲之间的相对时间。具体来说，突触前脉冲先于突触后脉冲会产生长时程增强（LTP），而突触后脉冲先于突触前脉冲则会产生长时程抑制（LTD）。在片上学习电路中，时间是离散表示的；因此我们考虑时间步 $t \\in \\{0,1,\\dots,T-1\\}$，并使用二进制脉冲指示符 $x_{\\mathrm{pre}}(t)$ 和 $x_{\\mathrm{post}}(t)$。\n\n为了在离散时间下于硬件中忠实地模拟 STDP，我们必须：\n1. 累积足够的脉冲历史，以确定有限学习窗口内的相对时间。\n2. 根据 $+\\Delta t$ 和 $-\\Delta t$ 的时间关系应用更新，其幅度由学习窗口函数决定。\n\n查找表是学习窗口的一种以硬件为中心的实现方式。我们为正延迟 $\\delta = 1,2,\\dots$ 定义了用于增强的 $L_+[\\delta]$ 和用于抑制的 $L_-[\\delta]$。这些表近似了连续的 STDP 核函数。离散 FSM 将实现基于配对的 STDP：\n- 如果发生突触后脉冲，它会从过去 $W_+$ 个时间步内的任何突触前脉冲中引发增强贡献，其幅度由 $L_+[\\delta]$ 决定。\n- 如果发生突触前脉冲，它会从过去 $W_-$ 个时间步内的任何突触后脉冲中引发抑制贡献，其幅度为 $L_-[\\delta]$。\n\n我们使用长度为 $W = \\max(W_+, W_-)$ 的循环缓冲区 $B_{\\mathrm{pre}}$ 和 $B_{\\mathrm{post}}$ 来表示历史。指针 $p$ 指示当前的零延迟仓。在每个时间步，$p$ 按模 $W$ 前进 $1$，并且新的仓被清除以接收当前时间的事件。对于一个严格为正的延迟 $\\delta$，保存 $\\delta$ 个时间步前事件的缓冲区索引是 $\\mathrm{idx}(\\delta) = (p - \\delta) \\bmod W$。这种映射无需移动数据即可确保先进先出的老化过程，与硬件友好型设计一致。\n\nFSM 设计：\n- 在 $S_{\\mathrm{age}}$ 中，设置 $p \\leftarrow (p + 1) \\bmod W$，清除 $B_{\\mathrm{pre}}[p]$ 和 $B_{\\mathrm{post}}[p]$。\n- 在 $S_{\\mathrm{acc\\_pre}}$ 中，如果 $x_{\\mathrm{pre}}(t) = 1$，则增加 $B_{\\mathrm{pre}}[p]$。\n- 在 $S_{\\mathrm{acc\\_post}}$ 中，如果 $x_{\\mathrm{post}}(t) = 1$，则增加 $B_{\\mathrm{post}}[p]$。\n- 在 $S_{\\mathrm{update}}$ 中，计算\n  $$\\Delta w_+(t) = \\begin{cases}\n  \\sum_{\\delta=1}^{W_+} L_+[\\delta] \\cdot B_{\\mathrm{pre}}[(p-\\delta)\\bmod W],  \\text{if } x_{\\mathrm{post}}(t)=1,\\\\\n  0,  \\text{otherwise},\n  \\end{cases}$$\n  $$\\Delta w_-(t) = \\begin{cases}\n  \\sum_{\\delta=1}^{W_-} L_-[\\delta] \\cdot B_{\\mathrm{post}}[(p-\\delta)\\bmod W],  \\text{if } x_{\\mathrm{pre}}(t)=1,\\\\\n  0,  \\text{otherwise}.\n  \\end{cases}$$\n  然后应用饱和更新\n  $$w \\leftarrow \\mathrm{clip}\\left(w + \\Delta w_+(t) - \\Delta w_-(t),\\, w_{\\min},\\, w_{\\max}\\right).$$\n排除 $\\delta=0$ 强制要求同时发生的脉冲不产生贡献，这是一种合理且常用的离散时间近似方法。\n\n算法的正确性直接源于将基于配对的 STDP 原理映射到离散缓冲区上：增强是对突触后触发器之前的突触前事件求和，而抑制是对突触前触发器之前的突触后事件求和，两者都受限于可配置的有限窗口。循环缓冲区和指针算术一致地实现了时间老化。\n\n我们现在为指定的测试用例计算最终权重：\n\n给定 $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$, $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$。查找表 $L_+$ 和 $L_-$ 根据问题定义使用1-based索引。\n\n- 用例 1：$\\mathcal{P}=\\{2,10\\}$, $\\mathcal{Q}=\\{4,12\\}$, $T=20$, $W_+=W_-=5$。\n  在 $t=4$ 时发生增强，源于 $t=2$ 的突触前脉冲，延迟 $\\delta=2$ 产生 $\\Delta w = L_+[2] = 0.3$ 的增益。在 $t=12$ 时发生另一次增强，源于 $t=10$ 的突触前脉冲，延迟 $\\delta=2$ 产生 $\\Delta w = L_+[2] = 0.3$ 的增益。抑制不会发生，因为在 $t=2$ 或 $t=10$ 之前 $W_-$ 窗口内没有更早的突触后脉冲。净 $\\Delta w = 0.3 + 0.3 = 0.6$，因此 $w = 0.5 + 0.6 = 1.1$，饱和至 $1.0$。\n\n- 用例 2：$\\mathcal{P}=\\{5,15\\}$, $\\mathcal{Q}=\\{3,13\\}$, $T=20$, $W_+=W_-=5$。\n  在 $t=5$ 时发生抑制，源于 $t=3$ 的突触后脉冲，延迟 $\\delta=2$ 产生 $\\Delta w = -L_-[2] = -0.2$ 的减益。在 $t=15$ 时发生另一次抑制，源于 $t=13$ 的突触后脉冲，延迟 $\\delta=2$ 产生 $\\Delta w = -L_-[2] = -0.2$ 的减益。增强不会发生，因为突触前脉冲不在突触后脉冲之前的 $W_+$ 窗口内。净 $\\Delta w = -0.2 - 0.2 = -0.4$，因此 $w = 0.5 - 0.4 = 0.1$。\n\n- 用例 3：$\\mathcal{P}=\\emptyset$, $\\mathcal{Q}=\\emptyset$, $T=20$。\n  没有脉冲，因此 $w$ 保持为 $0.5$。\n\n- 用例 4：$\\mathcal{P}=\\{0\\}$, $\\mathcal{Q}=\\{10\\}$, $T=20$。\n  延迟 $\\delta=10$ 超过了窗口 $W_+=5$，因此没有增强；同样，也没有抑制发生。因此 $w$ 保持为 $0.5$。\n\n- 用例 5：$\\mathcal{P}=\\{0,1,2,3,4\\}$, $\\mathcal{Q}=\\{1,2,3,4,5\\}$, $T=6$, $W_+=W_-=5$。\n  这是一个密集配对的场景，权重会因为连续的更新而迅速饱和。我们来逐步追踪权重 $w$ 的变化，初始值为 $w_0=0.5$：\n  - $t=0$：突触前脉冲。无更新。$w=0.5$。\n  - $t=1$：突触前和突触后脉冲。LTP事件，因 $t=0$ 的突触前脉冲，延迟 $\\delta=1$。$\\Delta w = L_+[1] = 0.4$。LTD事件不触发（无更早的突触后脉冲）。$w = 0.5 + 0.4 = 0.9$。\n  - $t=2$：突触前和突触后脉冲。LTP事件，因 $t=0,1$ 的突触前脉冲，延迟 $\\delta=2,1$。$\\Delta w_{LTP} = L_+[2] + L_+[1] = 0.3 + 0.4 = 0.7$。LTD事件，因 $t=1$ 的突触后脉冲，延迟 $\\delta=1$。$\\Delta w_{LTD} = -L_-[1] = -0.3$。净 $\\Delta w = 0.7 - 0.3 = 0.4$。$w = 0.9 + 0.4 = 1.3$。裁剪后 $w = 1.0$。\n  - $t=3$：权重已经饱和在 $w_{\\max}=1.0$。LTP事件因 $\\delta=1,2,3$ 触发，LTD事件因 $\\delta=1,2$ 触发。净更新为正，但权重已饱和。$w$ 保持为 $1.0$。\n  - $t=4$：同上，权重保持 $1.0$。\n  - $t=5$：仅有突触后脉冲。LTP事件触发，净更新为正。权重保持 $1.0$。\n  因此，最终权重饱和在 $1.0$。\n\n因此，当四舍五入到小数点后 6 位时，预期的最终权重为 $[1.000000, 0.100000, 0.500000, 0.500000, 1.000000]$。所提供的程序将实现该 FSM 并精确地产生这些输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(T, W_plus, W_minus, L_plus, L_minus, w0, wmin, wmax, pre_times, post_times):\n    \"\"\"\n    Simulate the FSM-based STDP with LUT updates over T ticks.\n    - T: total ticks\n    - W_plus, W_minus: window lengths for LTP and LTD\n    - L_plus, L_minus: lookup tables for positive lags (lengths W_plus and W_minus)\n    - w0: initial weight\n    - wmin, wmax: saturation bounds\n    - pre_times, post_times: sorted lists (or sets) of tick indices with pre/post spikes\n    \"\"\"\n    W = max(W_plus, W_minus)\n    # Circular buffers for counts per lag\n    pre_buf = np.zeros(W, dtype=int)\n    post_buf = np.zeros(W, dtype=int)\n    p = -1  # pointer to current zero-lag bin; will advance at first tick to 0\n\n    w = float(w0)\n    pre_set = set(pre_times)\n    post_set = set(post_times)\n\n    for t in range(T):\n        # S_age: advance pointer and clear current bin\n        p = (p + 1) % W\n        pre_buf[p] = 0\n        post_buf[p] = 0\n\n        # Accumulate events\n        pre_event = (t in pre_set)\n        post_event = (t in post_set)\n\n        # S_acc_pre\n        if pre_event:\n            pre_buf[p] += 1\n\n        # S_acc_post\n        if post_event:\n            post_buf[p] += 1\n\n        # S_update: compute LUT-based contributions\n        delta_w = 0.0\n\n        if post_event and W_plus > 0:\n            # Potentiation: sum over past pre spikes within W_plus\n            for d in range(1, W_plus + 1):\n                idx = (p - d) % W\n                count = pre_buf[idx]\n                if count:\n                    delta_w += L_plus[d - 1] * count\n\n        if pre_event and W_minus > 0:\n            # Depression: sum over past post spikes within W_minus\n            for d in range(1, W_minus + 1):\n                idx = (p - d) % W\n                count = post_buf[idx]\n                if count:\n                    delta_w -= L_minus[d - 1] * count\n\n        # Apply update with saturation\n        w = max(wmin, min(wmax, w + delta_w))\n\n    return w\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [2, 10],\n            \"post_times\": [4, 12],\n        },\n        # Case 2\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [5, 15],\n            \"post_times\": [3, 13],\n        },\n        # Case 3\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [],\n            \"post_times\": [],\n        },\n        # Case 4\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [0],\n            \"post_times\": [10],\n        },\n        # Case 5\n        {\n            \"T\": 6,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [0, 1, 2, 3, 4],\n            \"post_times\": [1, 2, 3, 4, 5],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(\n            T=case[\"T\"],\n            W_plus=case[\"W_plus\"],\n            W_minus=case[\"W_minus\"],\n            L_plus=case[\"L_plus\"],\n            L_minus=case[\"L_minus\"],\n            w0=case[\"w0\"],\n            wmin=case[\"wmin\"],\n            wmax=case[\"wmax\"],\n            pre_times=case[\"pre_times\"],\n            post_times=case[\"post_times\"],\n        )\n        results.append(result)\n\n    # Format results to 6 decimal places\n    formatted = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}