{
    "hands_on_practices": [
        {
            "introduction": "Understanding on-chip learning begins with a firm grasp of the underlying plasticity models. This first exercise focuses on the canonical pair-based Spike-Timing-Dependent Plasticity (STDP) rule, a cornerstone of neuromorphic engineering. By calculating the weight update for a single, isolated spike pair, you will develop a concrete intuition for how the relative timing of events is translated into synaptic potentiation or depression in a widely used mathematical framework .",
            "id": "4054266",
            "problem": "A Complementary Metal–Oxide–Semiconductor (CMOS) neuromorphic synapse implements pair-based spike-timing-dependent plasticity (STDP), where spike timing is encoded by exponentially decaying pre- and postsynaptic traces generated by first-order leaky integrators. Let the presynaptic trace $x_{+}(t)$ and the postsynaptic trace $x_{-}(t)$ be defined by the standard linear time-invariant dynamics\n$$\n\\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\sum_{k} \\delta\\!\\left(t - t^{\\mathrm{pre}}_{k}\\right), \n\\qquad\n\\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\sum_{\\ell} \\delta\\!\\left(t - t^{\\mathrm{post}}_{\\ell}\\right),\n$$\nwith initial conditions $x_{+}(t)=0$ and $x_{-}(t)=0$ for $t\\min\\{t^{\\mathrm{pre}}_{k},t^{\\mathrm{post}}_{\\ell}\\}$. The synaptic weight $w$ is updated at event times by sampling the appropriate trace, in accordance with the pair-based STDP definition: at a postsynaptic spike time $t^{\\mathrm{post}}$, a long-term potentiation increment is applied\n$$\n\\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right),\n$$\nand at a presynaptic spike time $t^{\\mathrm{pre}}$, a long-term depression decrement is applied\n$$\n\\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right),\n$$\nwhere $A_{+}0$, $A_{-}0$, $\\tau_{+}0$, and $\\tau_{-}0$ are circuit parameters.\n\nConsider a single isolated spike pair with one presynaptic spike at $t=0$ and one postsynaptic spike at $t=\\Delta t$, where $\\Delta t = 12\\ \\text{ms}$. There are no other spikes in the interval $(-\\infty,\\infty)$, and the traces are not saturated. The circuit parameters are $A_{+} = 0.01$, $\\tau_{+} = 20\\ \\text{ms}$, $A_{-} = 0.012$, and $\\tau_{-} = 18\\ \\text{ms}$. Using only the definitions given above and linear time-invariant system properties, determine the instantaneous synaptic update $\\Delta w$ produced by this single spike pair.\n\nExpress the final answer as a single real number (dimensionless), rounded to four significant figures. Do not include units in your final answer.",
            "solution": "The problem will first be validated against the specified criteria before a solution is attempted.\n\n### Step 1: Extract Givens\nThe given information is as follows:\n- Presynaptic trace dynamics: $\n\\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\sum_{k} \\delta\\!\\left(t - t^{\\mathrm{pre}}_{k}\\right)\n$\n- Postsynaptic trace dynamics: $\n\\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\sum_{\\ell} \\delta\\!\\left(t - t^{\\mathrm{post}}_{\\ell}\\right)\n$\n- Initial conditions: $x_{+}(t)=0$ and $x_{-}(t)=0$ for $t\\min\\{t^{\\mathrm{pre}}_{k},t^{\\mathrm{post}}_{\\ell}\\}$.\n- Synaptic weight update rules:\n  - Long-term potentiation (LTP) at a postsynaptic spike time $t^{\\mathrm{post}}$: $\\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right)$\n  - Long-term depression (LTD) at a presynaptic spike time $t^{\\mathrm{pre}}$: $\\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right)$\n- Spike timing: A single presynaptic spike occurs at $t^{\\mathrm{pre}} = 0$, and a single postsynaptic spike occurs at $t^{\\mathrm{post}} = \\Delta t$.\n- Circuit parameters:\n  - $\\Delta t = 12\\ \\text{ms}$\n  - $A_{+} = 0.01$\n  - $\\tau_{+} = 20\\ \\text{ms}$\n  - $A_{-} = 0.012$\n  - $\\tau_{-} = 18\\ \\text{ms}$\n- The problem asks for the total instantaneous synaptic update $\\Delta w$ for this single spike pair.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated for validity:\n- **Scientifically Grounded**: The problem describes a mathematically precise and standard model of pair-based spike-timing-dependent plasticity (STDP), a fundamental concept in computational neuroscience and neuromorphic engineering. The use of linear first-order differential equations with Dirac delta functions as inputs is a well-established and valid method for modeling such phenomena.\n- **Well-Posed**: The problem is clearly defined with all necessary equations, parameters, initial conditions, and spike times provided. It has a unique and meaningful solution that can be derived directly from the supplied information.\n- **Objective**: The problem is stated using formal mathematical language and objective, unambiguous terminology.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived.\n\nThe total synaptic weight update, $\\Delta w$, is the sum of all individual updates occurring at the times of the spikes. There are two spike events: a presynaptic spike at $t=0$ and a postsynaptic spike at $t=\\Delta t$.\n\n1.  **Weight update at the presynaptic spike time, $t=0$**:\n    At the time of a presynaptic spike, $t^{\\mathrm{pre}} = 0$, the weight change is determined by the LTD rule:\n    $$\n    \\Delta w(t=0) = \\Delta w_{\\mathrm{LTD}} = -A_{-}\\, x_{-}\\!\\left(t^{\\mathrm{pre}^{-}}\\right) = -A_{-}\\, x_{-}\\!\\left(0^{-}\\right)\n    $$\n    To find the value of the postsynaptic trace $x_{-}(t)$ just before $t=0$, we examine its governing differential equation:\n    $$\n    \\frac{d x_{-}}{dt} = -\\frac{x_{-}}{\\tau_{-}} + \\delta\\!\\left(t - \\Delta t\\right)\n    $$\n    The only input to this system is a single postsynaptic spike at $t=\\Delta t = 12\\ \\text{ms}$. The initial condition states that $x_{-}(t)=0$ for all times $t$ before the first postsynaptic spike. Since $0  \\Delta t$, it follows that for any time $t  \\Delta t$, $x_{-}(t)=0$. Specifically, at $t=0^{-}$, we have:\n    $$\n    x_{-}\\!\\left(0^{-}\\right) = 0\n    $$\n    Therefore, the weight update at the presynaptic spike time is:\n    $$\n    \\Delta w(t=0) = -A_{-} \\times 0 = 0\n    $$\n\n2.  **Weight update at the postsynaptic spike time, $t=\\Delta t$**:\n    At the time of the postsynaptic spike, $t^{\\mathrm{post}} = \\Delta t$, the weight change is determined by the LTP rule:\n    $$\n    \\Delta w(t=\\Delta t) = \\Delta w_{\\mathrm{LTP}} = A_{+}\\, x_{+}\\!\\left(t^{\\mathrm{post}^{-}}\\right) = A_{+}\\, x_{+}\\!\\left(\\Delta t^{-}\\right)\n    $$\n    To find this value, we must first solve for the presynaptic trace $x_{+}(t)$. Its dynamics are given by:\n    $$\n    \\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}} + \\delta\\!\\left(t - 0\\right)\n    $$\n    This is a first-order linear ordinary differential equation. The Dirac delta function $\\delta(t)$ at $t=0$ causes an instantaneous jump in the value of $x_{+}(t)$. We can find the magnitude of this jump by integrating the equation over an infinitesimally small interval $[0^{-}, 0^{+}]$:\n    $$\n    \\int_{0^{-}}^{0^{+}} \\frac{d x_{+}}{dt} dt = \\int_{0^{-}}^{0^{+}} \\left(-\\frac{x_{+}}{\\tau_{+}}\\right) dt + \\int_{0^{-}}^{0^{+}} \\delta(t) dt\n    $$\n    This yields:\n    $$\n    x_{+}(0^{+}) - x_{+}(0^{-}) = 0 + 1\n    $$\n    The integral of the term $-x_{+}/\\tau_{+}$ goes to zero as the integration interval shrinks, assuming $x_{+}$ is not a distribution itself. From the initial conditions, we know $x_{+}(t)=0$ for $t0$, so $x_{+}(0^{-})=0$. Thus, the value of the trace immediately after the spike is:\n    $$\n    x_{+}(0^{+}) = 1\n    $$\n    For $t  0$, the system is source-free, and the dynamics are governed by the homogeneous equation:\n    $$\n    \\frac{d x_{+}}{dt} = -\\frac{x_{+}}{\\tau_{+}}\n    $$\n    The solution to this equation, with the initial condition $x_{+}(0^{+})=1$, is an exponential decay:\n    $$\n    x_{+}(t) = \\exp\\left(-\\frac{t}{\\tau_{+}}\\right) \\quad \\text{for } t  0\n    $$\n    We need to evaluate this trace at the time just before the postsynaptic spike, $t = \\Delta t^{-}$. Since the function $x_{+}(t)$ is continuous for $t0$, $x_{+}(\\Delta t^{-}) = x_{+}(\\Delta t)$.\n    $$\n    x_{+}\\!\\left(\\Delta t^{-}\\right) = \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    The weight update at $t=\\Delta t$ is therefore:\n    $$\n    \\Delta w(t=\\Delta t) = A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n\n3.  **Total synaptic update**:\n    The total update $\\Delta w$ is the sum of the updates at all spike events:\n    $$\n    \\Delta w = \\Delta w(t=0) + \\Delta w(t=\\Delta t) = 0 + A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    $$\n    \\Delta w = A_{+} \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)\n    $$\n    Now, we substitute the given numerical values: $A_{+} = 0.01$, $\\Delta t = 12\\ \\text{ms}$, and $\\tau_{+} = 20\\ \\text{ms}$. The units of time (ms) in $\\Delta t$ and $\\tau_{+}$ cancel, leaving a dimensionless exponent as required.\n    $$\n    \\Delta w = 0.01 \\times \\exp\\left(-\\frac{12}{20}\\right) = 0.01 \\times \\exp(-0.6)\n    $$\n    Calculating the numerical value:\n    $$\n    \\exp(-0.6) \\approx 0.548811636\n    $$\n    $$\n    \\Delta w \\approx 0.01 \\times 0.548811636 = 0.00548811636\n    $$\n    The problem requires the answer to be rounded to four significant figures.\n    $$\n    \\Delta w \\approx 0.005488\n    $$",
            "answer": "$$\\boxed{0.005488}$$"
        },
        {
            "introduction": "Abstract models of plasticity, such as the one explored previously, must be translated into physical circuits. The leaky integrators that create synaptic traces for STDP are fundamental building blocks, often implemented using low-power analog circuits. This practice challenges you to analyze a log-domain integrator built with subthreshold MOSFETs, deriving its time constant and considering a critical real-world challenge: maintaining stable operation despite temperature variations .",
            "id": "4054208",
            "problem": "A first-order log-domain integrator is built in the subthreshold regime using Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) devices with slope factor $n$ and thermal voltage $U_{T} = k_{B} T / q$, where $k_{B}$ is the Boltzmann constant, $T$ is the absolute temperature, and $q$ is the elementary charge. The integrator employs a capacitor $C$ connected to a node whose voltage encodes the logarithm of a state current via the exponential subthreshold current-voltage relationship, and a translinear loop that enforces a first-order linear differential equation in that current. The bias current driving the translinear loop is generated by a temperature-dependent reference such that $I_{b}(T) = I_{b0} \\left(\\frac{T}{T_{0}}\\right)^{\\alpha}$, where $I_{b0}$ is the bias at a reference temperature $T_{0}$ and $\\alpha$ is a designable exponent set by the bias architecture (for example, Proportional-To-Absolute-Temperature (PTAT) for $\\alpha = 1$, Complementary-To-Absolute-Temperature (CTAT) for $\\alpha = -1$).\n\nStarting only from charge conservation on the capacitor, the exponential subthreshold current-voltage law with slope factor $n$, and the definition of the thermal voltage $U_{T}$, derive how the integrator time constant $\\tau$ scales with temperature. Report $\\tau(T)$ as a closed-form expression in terms of $n$, $C$, $k_{B}$, $q$, $T$, $I_{b0}$, $T_{0}$, and $\\alpha$. Express your final answer in seconds. In addition, discuss bias strategies that minimize temperature drift of $\\tau$ by appropriate choices of $\\alpha$ and by compensating any residual temperature dependence of $n$, but do not include this discussion in your final expression.",
            "solution": "The problem asks for the derivation of the temperature-dependent time constant $\\tau(T)$ of a first-order log-domain integrator and a discussion of temperature compensation strategies.\n\nThe validation of the problem statement is performed first.\n\n### Step 1: Extract Givens\n-   **System**: A first-order log-domain integrator.\n-   **Devices**: Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) devices operating in the subthreshold regime.\n-   **Device/Physics Parameters**:\n    -   Slope factor: $n$.\n    -   Thermal voltage: $U_{T} = k_{B} T / q$.\n    -   Boltzmann constant: $k_{B}$.\n    -   Absolute temperature: $T$.\n    -   Elementary charge: $q$.\n-   **Circuit Components and Principles**:\n    -   A capacitor with capacitance $C$.\n    -   The node voltage $V_{node}$ across the capacitor encodes the logarithm of a state current $I_{state}$.\n    -   The circuit operates based on the exponential subthreshold current-voltage relationship.\n    -   A translinear loop enforces a first-order linear differential equation in the state current.\n-   **Bias Current**:\n    -   Temperature-dependent bias current: $I_{b}(T) = I_{b0} \\left(\\frac{T}{T_{0}}\\right)^{\\alpha}$.\n    -   $I_{b0}$ is the bias current at a reference temperature $T_{0}$.\n    -   $\\alpha$ is a designable exponent.\n-   **Tasks**:\n    1.  Derive the integrator time constant $\\tau$ as a function of temperature, $\\tau(T)$.\n    2.  Provide the result as a closed-form expression in terms of $n, C, k_{B}, q, T, I_{b0}, T_{0}, \\alpha$.\n    3.  Discuss bias strategies to minimize temperature drift of $\\tau$.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Grounding**: The problem is scientifically sound. It is based on a standard, well-documented circuit archetype in analog and neuromorphic VLSI design. The principles—subthreshold MOSFET physics, the translinear principle, and log-domain filtering—are cornerstones of low-power analog signal processing.\n-   **Well-Posedness**: The problem is well-posed. It provides a clear set of physical laws and circuit constraints and asks for the derivation of a specific parameter, the time constant $\\tau$. The information provided is sufficient to arrive at a unique analytical solution.\n-   **Objectivity**: The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard, non-trivial problem in analog integrated circuit theory. A reasoned solution will be provided.\n\n### Derivation of the Time Constant $\\tau(T)$\n\nThe derivation proceeds by connecting the three fundamental principles provided: charge conservation on the capacitor, the subthreshold MOSFET current-voltage law, and the dynamic behavior imposed by the translinear loop.\n\n**1. Relate Capacitor Voltage to State Current:**\nThe problem states that the integrator operates in the subthreshold regime. The drain current $I_D$ of a MOSFET in this regime is an exponential function of its gate-source voltage $V_{GS}$. For a diode-connected transistor (gate connected to drain) carrying the state current $I_{state}$, its voltage $V_{node}$ is related to $I_{state}$ as:\n$$I_{state} = I_{s} \\exp\\left(\\frac{V_{node}}{n U_T}\\right)$$\nwhere $I_s$ is a process-dependent saturation current and $n$ is the slope factor. The voltage $V_{node}$ is the voltage across the capacitor $C$. We can express $V_{node}$ in terms of $I_{state}$ by inverting this relationship:\n$$V_{node} = n U_T \\ln\\left(\\frac{I_{state}}{I_s}\\right)$$\n\n**2. Relate Capacitor Current to the Rate of Change of State Current:**\nThe current flowing through the capacitor, $I_C$, is given by the law of capacitance:\n$$I_C = C \\frac{dV_{node}}{dt}$$\nTo express $I_C$ in terms of $I_{state}$, we differentiate the expression for $V_{node}$ with respect to time $t$. Using the chain rule, and treating $n$, $U_T$, and $I_s$ as constant with respect to the circuit's dynamic timescale (but not necessarily with respect to temperature $T$):\n$$\\frac{dV_{node}}{dt} = \\frac{d}{dt} \\left[ n U_T \\ln\\left(\\frac{I_{state}}{I_s}\\right) \\right] = n U_T \\frac{I_s}{I_{state}} \\left(\\frac{1}{I_s} \\frac{dI_{state}}{dt}\\right) = \\frac{n U_T}{I_{state}} \\frac{dI_{state}}{dt}$$\nSubstituting this into the capacitor current equation yields:\n$$I_C = C \\left(\\frac{n U_T}{I_{state}}\\right) \\frac{dI_{state}}{dt}$$\n\n**3. Incorporate the Translinear Loop Dynamics:**\nThe problem states that a translinear loop enforces a first-order linear differential equation for the state current. The canonical form for such an equation is $\\tau \\frac{dI_{state}}{dt} + I_{state} = I_{in}$, where $I_{in}$ is an input current. The time constant $\\tau$ is determined by the decay characteristic of the system, which corresponds to the case where $I_{in} = 0$. The differential equation becomes:\n$$\\frac{dI_{state}}{dt} = -\\frac{1}{\\tau} I_{state}$$\nThe circuit implementation of a log-domain integrator uses a bias current $I_b$ to set the rate of integration or decay. For the decay phase, the translinear circuit is designed to sink a constant current from the capacitor node, equal to the bias current $I_b$. Therefore, the capacitor current is $I_C = -I_b$.\n\n**4. Solve for the Time Constant $\\tau$:**\nWe now have two expressions for the circuit's behavior during decay:\nFrom the dynamics: $\\frac{dI_{state}}{dt} = -\\frac{I_{state}}{\\tau}$\nFrom the circuit physics with $I_C = -I_b$: $-I_b = C \\left(\\frac{n U_T}{I_{state}}\\right) \\frac{dI_{state}}{dt}$\n\nWe can substitute the first equation into the second:\n$$-I_b = C \\left(\\frac{n U_T}{I_{state}}\\right) \\left(-\\frac{I_{state}}{\\tau}\\right)$$\nThe terms $-1$ and $I_{state}$ cancel out:\n$$I_b = \\frac{C n U_T}{\\tau}$$\nSolving for the time constant $\\tau$ gives the fundamental relationship for a log-domain integrator:\n$$\\tau = \\frac{C n U_T}{I_b}$$\n\n**5. Express the Time Constant as a Function of Temperature:**\nWe are given the temperature dependencies of $U_T$ and $I_b$:\n$$U_T(T) = \\frac{k_B T}{q}$$\n$$I_b(T) = I_{b0} \\left(\\frac{T}{T_0}\\right)^{\\alpha}$$\nThe capacitance $C$ and the elementary charge $q$ are considered temperature-independent. The slope factor $n$ has a weak temperature dependence, but the problem asks to derive the expression in terms of $n$ as a parameter and then discuss its compensation, so we leave it as $n$. Substituting the temperature-dependent expressions into the equation for $\\tau$:\n$$\\tau(T) = \\frac{C n \\cdot U_T(T)}{I_b(T)} = \\frac{C n \\left(\\frac{k_B T}{q}\\right)}{I_{b0} \\left(\\frac{T}{T_0}\\right)^{\\alpha}}$$\nTo simplify, we can separate the temperature-dependent part:\n$$\\tau(T) = \\frac{C n k_B}{q I_{b0}} \\cdot \\frac{T}{ \\left(\\frac{T}{T_0}\\right)^{\\alpha} } = \\frac{C n k_B}{q I_{b0}} \\cdot T \\cdot T^{-\\alpha} \\cdot T_0^{\\alpha}$$\nCombining the terms involving $T$ yields the final closed-form expression:\n$$\\tau(T) = \\frac{C n k_B T_0^{\\alpha}}{q I_{b0}} T^{1-\\alpha}$$\nThe units of this expression are seconds, as verified by dimensional analysis: $\\frac{F \\cdot J/K \\cdot K^{\\alpha} \\cdot K^{1-\\alpha}}{C \\cdot A} = \\frac{(s/\\Omega) \\cdot (J)}{A \\cdot s \\cdot A} = \\frac{J}{\\Omega \\cdot A^2} = \\frac{V \\cdot A \\cdot s}{ (V/A) \\cdot A^2} = s$.\n\n### Discussion of Temperature Drift Compensation\n\nThe derived expression $\\tau(T) \\propto n(T) T^{1-\\alpha}$ reveals how the integrator's time constant varies with temperature. Minimizing this temperature drift is critical for building stable and reliable systems.\n\n**First-Order Compensation:**\nThe dominant temperature dependence comes from the term $T^{1-\\alpha}$. To eliminate this dependence, a designer can choose the bias exponent $\\alpha$ such that the exponent of $T$ becomes zero.\n$$1 - \\alpha = 0 \\implies \\alpha = 1$$\nA bias current with $\\alpha = 1$ is known as a Proportional-To-Absolute-Temperature (PTAT) current, i.e., $I_b(T) \\propto T$. By using a PTAT bias current, the time constant becomes, to a first approximation:\n$$\\tau = \\frac{C n k_B T_0}{q I_{b0}}$$\nIn this case, the linear temperature dependence of the thermal voltage $U_T$ is precisely canceled by the linear temperature dependence of the PTAT bias current $I_b$, rendering $\\tau$ independent of temperature, assuming $n$ is constant.\n\n**Second-Order Compensation for $n(T)$:**\nThe slope factor $n$ is not perfectly constant with temperature. It is given by $n \\approx 1 + C_{dep}/C_{ox}$, where $C_{dep}$ is the depletion capacitance of the channel. $C_{dep}$ has a weak temperature dependence, primarily through the Fermi potential, which causes $n$ to have a small, negative temperature coefficient (i.e., $n$ decreases slightly as $T$ increases). Let's model this dependence as a power law, $n(T) \\propto T^{\\beta}$, where $\\beta$ is a small negative number (e.g., $\\beta \\approx -0.05$).\n\nThe full temperature dependence of $\\tau$ is then:\n$$\\tau(T) \\propto n(T) T^{1-\\alpha} \\propto T^{\\beta} T^{1-\\alpha} = T^{1+\\beta-\\alpha}$$\nTo achieve zero temperature coefficient for $\\tau$, we must now set the total exponent to zero:\n$$1 + \\beta - \\alpha = 0 \\implies \\alpha = 1 + \\beta$$\nSince $\\beta$ is a small negative number, the ideal value for $\\alpha$ will be slightly less than $1$. For example, if $\\beta = -0.05$, the optimal choice would be $\\alpha = 0.95$. This requires a \"sub-linear\" PTAT bias current, one that increases with temperature but slightly slower than a pure PTAT current. Such a current source can be synthesized by taking a weighted sum of a PTAT current ($I_1 \\propto T$) and a temperature-independent (Zero-Temperature-Coefficient, ZTC) current ($I_2 = \\text{const}$), as $I_b(T) = w_1 I_1(T) + w_2 I_2(T)$, where the weights $w_1$ and $w_2$ are chosen to approximate the desired $T^{1+\\beta}$ dependence over the operating temperature range. This second-order compensation scheme allows for the design of highly stable log-domain time constants.",
            "answer": "$$\\boxed{\\frac{C n k_{B} T_{0}^{\\alpha}}{q I_{b0}} T^{1-\\alpha}}$$"
        },
        {
            "introduction": "In contrast to the continuous-time dynamics of analog circuits, digital neuromorphic systems implement plasticity using discrete, event-driven algorithms. This exercise explores the design of a digital STDP engine, formalizing the learning rule as a finite-state machine (FSM) that uses lookup tables and circular buffers. By implementing this common digital pattern, you will gain insight into the trade-offs and techniques for achieving plasticity in synchronous hardware like FPGAs or custom ASICs .",
            "id": "4054257",
            "problem": "You are tasked with formalizing and implementing a synchronous, event-driven finite-state machine (FSM) for on-chip learning that emulates Spike-Timing-Dependent Plasticity (STDP) using lookup tables in a discrete-time setting. The FSM must accumulate counts of recent pre-synaptic and post-synaptic spikes within configurable windows and apply weight updates based on the relative timing of spike events. The resulting program must simulate a specified set of test cases and output the final synaptic weight for each case.\n\nBegin from the following foundational base:\n- Spike-Timing-Dependent Plasticity (STDP) is the experimentally established principle that synaptic weight updates depend on the relative timing difference between pre-synaptic and post-synaptic spikes. If a pre-synaptic spike occurs before a post-synaptic spike, the synapse undergoes long-term potentiation (LTP), and if the post-synaptic spike precedes the pre-synaptic spike, the synapse undergoes long-term depression (LTD).\n- In digital neuromorphic hardware, time is discretized into ticks. Let the discrete time index be $t \\in \\{0,1,\\dots,T-1\\}$. Each tick processes binary input events $x_{\\mathrm{pre}}(t) \\in \\{0,1\\}$ and $x_{\\mathrm{post}}(t) \\in \\{0,1\\}$ indicating whether a pre-synaptic or post-synaptic spike occurred at time $t$.\n- A lookup table can approximate the STDP learning window. Define two lookup tables $L_+[\\delta]$ for potentiation and $L_-[\\delta]$ for depression, with indices $\\delta \\in \\{1,2,\\dots,W_+\\}$ and $\\delta \\in \\{1,2,\\dots,W_-\\}$ respectively. Here $W_+$ and $W_-$ are the potentiation and depression window lengths, and $\\delta$ denotes the discrete positive lag between events. The case $\\delta=0$ (simultaneous spikes) produces no update in this model.\n\nConstruct the FSM under the following rules:\n- States are defined to reflect the pipeline of per-tick processing: $S_{\\mathrm{age}}$ (advance time and age buffers), $S_{\\mathrm{acc\\_pre}}$ (accumulate pre-synaptic spikes), $S_{\\mathrm{acc\\_post}}$ (accumulate post-synaptic spikes), and $S_{\\mathrm{update}}$ (compute and apply the weight update).\n- The FSM operates in a fixed sequence per tick: $S_{\\mathrm{age}} \\rightarrow S_{\\mathrm{acc\\_pre}} \\rightarrow S_{\\mathrm{acc\\_post}} \\rightarrow S_{\\mathrm{update}}$. This sequencing ensures updates depend only on past events within the defined windows.\n- Maintain two circular buffers of length $W=\\max(W_+,W_-)$: $B_{\\mathrm{pre}}$ and $B_{\\mathrm{post}}$, storing integer counts of spikes at discrete lags. Let the buffer pointer be $p \\in \\{0,1,\\dots,W-1\\}$ indicating the current zero-lag bin. At each tick, in $S_{\\mathrm{age}}$, update $p \\leftarrow (p+1) \\bmod W$ and clear bin $p$ in both buffers to represent the new current time slot.\n- In $S_{\\mathrm{acc\\_pre}}$, if $x_{\\mathrm{pre}}(t)=1$, increment $B_{\\mathrm{pre}}[p]$. In $S_{\\mathrm{acc\\_post}}$, if $x_{\\mathrm{post}}(t)=1$, increment $B_{\\mathrm{post}}[p]$.\n- In $S_{\\mathrm{update}}$, compute the potentiation contribution only when $x_{\\mathrm{post}}(t)=1$ as the sum over past pre-synaptic counts at lags $1$ through $W_+$ using the index mapping $\\mathrm{idx}(\\delta) = (p-\\delta) \\bmod W$:\n  $$\\Delta w_+(t) = \\sum_{\\delta=1}^{W_+} L_+[\\delta] \\cdot B_{\\mathrm{pre}}[\\mathrm{idx}(\\delta)].$$\n  Compute the depression contribution only when $x_{\\mathrm{pre}}(t)=1$ as the sum over past post-synaptic counts at lags $1$ through $W_-$:\n  $$\\Delta w_-(t) = \\sum_{\\delta=1}^{W_-} L_-[\\delta] \\cdot B_{\\mathrm{post}}[\\mathrm{idx}(\\delta)].$$\n  Apply the net update\n  $$w \\leftarrow \\mathrm{clip}\\left(w + \\Delta w_+(t) - \\Delta w_-(t),\\, w_{\\min},\\, w_{\\max}\\right)$$\n  where $\\mathrm{clip}(\\cdot)$ saturates the weight to stay within specified bounds $[w_{\\min}, w_{\\max}]$.\n\nImplementation constraints:\n- The program must implement the FSM exactly as described above, using circular buffers to accumulate counts and lookup tables for $\\Delta w$ contributions. The case $\\delta=0$ must produce no update; only strictly positive lags contribute. Concurrency at the same tick ($\\delta=0$) must not contribute to any update.\n- The input spikes are fixed, hard-coded sequences for the test suite. There is no external input. Each test case runs independently starting from an initial weight $w_0$, and the final weight after $T$ ticks must be recorded.\n\nTest suite:\nFor each test case, you are given the parameters $(T, W_+, W_-, L_+, L_-, w_0, w_{\\min}, w_{\\max}, \\mathcal{P}, \\mathcal{Q})$ where $\\mathcal{P}$ and $\\mathcal{Q}$ are the sets of pre-synaptic and post-synaptic spike times respectively. All numbers below are unitless discrete counts. There are $5$ test cases:\n- Case $1$ (potentiation-dominant, in-window pairing):\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{2, 10\\}$, $\\mathcal{Q}=\\{4, 12\\}$.\n- Case $2$ (depression-dominant, in-window pairing):\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{5, 15\\}$, $\\mathcal{Q}=\\{3, 13\\}$.\n- Case $3$ (no spikes, edge case):\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\emptyset$, $\\mathcal{Q}=\\emptyset$.\n- Case $4$ (spikes outside the window, edge case):\n  - $T=20$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{0\\}$, $\\mathcal{Q}=\\{10\\}$.\n- Case $5$ (saturation under heavy pairing, boundary behavior):\n  - $T=6$, $W_+=5$, $W_-=5$,\n  - $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$,\n  - $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$,\n  - $\\mathcal{P}=\\{0,1,2,3,4\\}$, $\\mathcal{Q}=\\{1,2,3,4,5\\}$.\n\nOutput specification:\n- The program must compute the final synaptic weight $w$ after processing all $T$ ticks for each test case.\n- Each result must be a floating-point number rounded to $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[w_1,w_2,w_3,w_4,w_5]$).\n\nNo external input is allowed; all parameters are fixed as per the test suite. Angles are not involved. Physical units are not involved; all quantities are dimensionless discrete counts. The FSM and LUT operations must be implemented exactly as described to ensure scientific realism and internal consistency.",
            "solution": "We begin from the experimentally grounded definition of Spike-Timing-Dependent Plasticity (STDP): synaptic weight updates depend on the relative timing between a pre-synaptic spike and a post-synaptic spike. In particular, pre-before-post yields long-term potentiation (LTP), while post-before-pre yields long-term depression (LTD). In on-chip learning circuits, timing is represented discretely; thus we consider time ticks $t \\in \\{0,1,\\dots,T-1\\}$ with binary spike indicators $x_{\\mathrm{pre}}(t)$ and $x_{\\mathrm{post}}(t)$.\n\nTo faithfully emulate STDP in hardware at discrete time, we must:\n1. Accumulate sufficient history of spikes to determine relative timing within a finite learning window.\n2. Apply updates based on $+\\Delta t$ and $-\\Delta t$ timing, with magnitudes governed by a learning window function.\n\nLookup tables are a hardware-centric realization of the learning window. We define $L_+[\\delta]$ for potentiation and $L_-[\\delta]$ for depression over positive lags $\\delta = 1,2,\\dots$. These tables approximate the continuous STDP kernels. The discrete FSM will implement pair-based STDP:\n- If a post-synaptic spike occurs, it induces potentiation contributions from any pre-synaptic spikes within the last $W_+$ ticks, with magnitude dictated by $L_+[\\delta]$.\n- If a pre-synaptic spike occurs, it induces depression contributions from any post-synaptic spikes within the last $W_-$ ticks, with magnitude $L_-[\\delta]$.\n\nWe represent history using circular buffers $B_{\\mathrm{pre}}$ and $B_{\\mathrm{post}}$ of length $W = \\max(W_+, W_-)$. The pointer $p$ indicates the current zero-lag bin. At each tick, $p$ advances by $1$ modulo $W$, and the new bin is cleared to accept events at the current time. For a strictly positive lag $\\delta$, the buffer index holding events from $\\delta$ ticks ago is $\\mathrm{idx}(\\delta) = (p - \\delta) \\bmod W$. This mapping ensures first-in-first-out aging without moving data, consistent with hardware-friendly design.\n\nFSM design:\n- In $S_{\\mathrm{age}}$, set $p \\leftarrow (p + 1) \\bmod W$, clear $B_{\\mathrm{pre}}[p]$ and $B_{\\mathrm{post}}[p]$.\n- In $S_{\\mathrm{acc\\_pre}}$, if $x_{\\mathrm{pre}}(t) = 1$, increment $B_{\\mathrm{pre}}[p]$.\n- In $S_{\\mathrm{acc\\_post}}$, if $x_{\\mathrm{post}}(t) = 1$, increment $B_{\\mathrm{post}}[p]$.\n- In $S_{\\mathrm{update}}$, compute\n  $$\\Delta w_+(t) = \\begin{cases}\n  \\sum_{\\delta=1}^{W_+} L_+[\\delta] \\cdot B_{\\mathrm{pre}}[(p-\\delta)\\bmod W],  \\text{if } x_{\\mathrm{post}}(t)=1,\\\\\n  0,  \\text{otherwise},\n  \\end{cases}$$\n  $$\\Delta w_-(t) = \\begin{cases}\n  \\sum_{\\delta=1}^{W_-} L_-[\\delta] \\cdot B_{\\mathrm{post}}[(p-\\delta)\\bmod W],  \\text{if } x_{\\mathrm{pre}}(t)=1,\\\\\n  0,  \\text{otherwise}.\n  \\end{cases}$$\n  Then apply the saturated update\n  $$w \\leftarrow \\mathrm{clip}\\left(w + \\Delta w_+(t) - \\Delta w_-(t),\\, w_{\\min},\\, w_{\\max}\\right).$$\nThe exclusion of $\\delta=0$ enforces that simultaneous spikes do not contribute, which is a reasonable and commonly used discrete-time approximation.\n\nAlgorithmic correctness follows directly from mapping the pair-based STDP principle onto discrete buffers: potentiation sums over pre-synaptic events before a post-synaptic trigger, and depression sums over post-synaptic events before a pre-synaptic trigger, both limited by configurable finite windows. The circular buffer and pointer arithmetic implement temporal aging consistently.\n\nWe now compute the final weights for the specified test cases:\n\nGiven $L_+=[0.4, 0.3, 0.2, 0.1, 0.05]$, $L_-=[0.3, 0.2, 0.1, 0.05, 0.025]$, $w_0=0.5$, $w_{\\min}=0.0$, $w_{\\max}=1.0$.\n\n- Case $1$: $\\mathcal{P}=\\{2,10\\}$, $\\mathcal{Q}=\\{4,12\\}$, $T=20$, $W_+=W_-=5$.\n  Weight updates occur at $t=4$ and $t=12$. At $t=4$, a post-spike sees a pre-spike at $t=2$ (lag $\\delta=2$), causing an update $\\Delta w = L_+[2] = 0.3$. The weight becomes $w=0.5+0.3=0.8$. At $t=12$, a post-spike sees a pre-spike at $t=10$ (lag $\\delta=2$), causing $\\Delta w=0.3$. The weight becomes $w = \\text{clip}(0.8+0.3) = \\text{clip}(1.1) = 1.0$.\n\n- Case $2$: $\\mathcal{P}=\\{5,15\\}$, $\\mathcal{Q}=\\{3,13\\}$, $T=20$, $W_+=W_-=5$.\n  Weight updates occur at $t=5$ and $t=15$. At $t=5$, a pre-spike sees a post-spike at $t=3$ (lag $\\delta=2$), causing $\\Delta w = -L_-[2] = -0.2$. The weight becomes $w=0.5-0.2=0.3$. At $t=15$, a pre-spike sees a post-spike at $t=13$ (lag $\\delta=2$), causing $\\Delta w=-0.2$. The weight becomes $w = 0.3-0.2 = 0.1$.\n\n- Case $3$: $\\mathcal{P}=\\emptyset$, $\\mathcal{Q}=\\emptyset$, $T=20$.\n  No spikes, so no updates. $w$ remains $0.5$.\n\n- Case $4$: $\\mathcal{P}=\\{0\\}$, $\\mathcal{Q}=\\{10\\}$, $T=20$.\n  The lag between the pre-spike at $t=0$ and the post-spike at $t=10$ is $\\delta=10$, which exceeds the window $W_+=5$. No update occurs. $w$ remains $0.5$.\n\n- Case $5$: $\\mathcal{P}=\\{0,1,2,3,4\\}$, $\\mathcal{Q}=\\{1,2,3,4,5\\}$, $T=6$, $W_+=W_-=5$.\n  We trace the weight $w$ per tick, starting at $w_0=0.5$.\n  $t=1$: Post-spike at $t=1$ sees pre-spike at $t=0$ ($\\delta=1$). $\\Delta w = L_+[1] = 0.4$. $w \\leftarrow \\text{clip}(0.5+0.4) = 0.9$.\n  $t=2$: Post-spike at $t=2$ sees pre-spikes at $t=1,0$ ($\\delta=1,2$). Pre-spike at $t=2$ sees post-spike at $t=1$ ($\\delta=1$). $\\Delta w = (L_+[1]+L_+[2]) - L_-[1] = (0.4+0.3)-0.3 = 0.4$. $w \\leftarrow \\text{clip}(0.9+0.4) = \\text{clip}(1.3) = 1.0$.\n  $t=3$ onwards: The weight has saturated at $w_{\\max}=1.0$. Subsequent updates with net positive $\\Delta w$ will not change the weight. For instance, at $t=3$, $\\Delta w = (L_+[1]+L_+[2]+L_+[3]) - (L_-[1]+L_-[2]) = (0.4+0.3+0.2) - (0.3+0.2) = 0.9 - 0.5 = 0.4$. $w \\leftarrow \\text{clip}(1.0+0.4) = 1.0$. The weight remains saturated. The final weight is $1.0$.\n\nTherefore, the expected final weights are $[1.0, 0.1, 0.5, 0.5, 1.0]$ when rounded to $6$ decimal places, i.e., $[1.000000, 0.100000, 0.500000, 0.500000, 1.000000]$. The provided program will implement the FSM and produce exactly these outputs.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(T, W_plus, W_minus, L_plus, L_minus, w0, wmin, wmax, pre_times, post_times):\n    \"\"\"\n    Simulate the FSM-based STDP with LUT updates over T ticks.\n    - T: total ticks\n    - W_plus, W_minus: window lengths for LTP and LTD\n    - L_plus, L_minus: lookup tables for positive lags (lengths W_plus and W_minus)\n    - w0: initial weight\n    - wmin, wmax: saturation bounds\n    - pre_times, post_times: sorted lists (or sets) of tick indices with pre/post spikes\n    \"\"\"\n    W = max(W_plus, W_minus)\n    # Circular buffers for counts per lag\n    pre_buf = np.zeros(W, dtype=int)\n    post_buf = np.zeros(W, dtype=int)\n    p = -1  # pointer to current zero-lag bin; will advance at first tick to 0\n\n    w = float(w0)\n    pre_set = set(pre_times)\n    post_set = set(post_times)\n\n    for t in range(T):\n        # S_age: advance pointer and clear current bin\n        p = (p + 1) % W\n        pre_buf[p] = 0\n        post_buf[p] = 0\n\n        # Accumulate events\n        pre_event = (t in pre_set)\n        post_event = (t in post_set)\n\n        # S_acc_pre\n        if pre_event:\n            pre_buf[p] += 1\n\n        # S_acc_post\n        if post_event:\n            post_buf[p] += 1\n\n        # S_update: compute LUT-based contributions\n        delta_w = 0.0\n\n        if post_event and W_plus > 0:\n            # Potentiation: sum over past pre spikes within W_plus\n            for d in range(1, W_plus + 1):\n                idx = (p - d) % W\n                count = pre_buf[idx]\n                if count:\n                    delta_w += L_plus[d - 1] * count\n\n        if pre_event and W_minus > 0:\n            # Depression: sum over past post spikes within W_minus\n            for d in range(1, W_minus + 1):\n                idx = (p - d) % W\n                count = post_buf[idx]\n                if count:\n                    delta_w -= L_minus[d - 1] * count\n\n        # Apply update with saturation\n        w = max(wmin, min(wmax, w + delta_w))\n\n    return w\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [2, 10],\n            \"post_times\": [4, 12],\n        },\n        # Case 2\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [5, 15],\n            \"post_times\": [3, 13],\n        },\n        # Case 3\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [],\n            \"post_times\": [],\n        },\n        # Case 4\n        {\n            \"T\": 20,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [0],\n            \"post_times\": [10],\n        },\n        # Case 5\n        {\n            \"T\": 6,\n            \"W_plus\": 5,\n            \"W_minus\": 5,\n            \"L_plus\": [0.4, 0.3, 0.2, 0.1, 0.05],\n            \"L_minus\": [0.3, 0.2, 0.1, 0.05, 0.025],\n            \"w0\": 0.5,\n            \"wmin\": 0.0,\n            \"wmax\": 1.0,\n            \"pre_times\": [0, 1, 2, 3, 4],\n            \"post_times\": [1, 2, 3, 4, 5],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(\n            T=case[\"T\"],\n            W_plus=case[\"W_plus\"],\n            W_minus=case[\"W_minus\"],\n            L_plus=case[\"L_plus\"],\n            L_minus=case[\"L_minus\"],\n            w0=case[\"w0\"],\n            wmin=case[\"wmin\"],\n            wmax=case[\"wmax\"],\n            pre_times=case[\"pre_times\"],\n            post_times=case[\"post_times\"],\n        )\n        results.append(result)\n\n    # Format results to 6 decimal places\n    formatted = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}