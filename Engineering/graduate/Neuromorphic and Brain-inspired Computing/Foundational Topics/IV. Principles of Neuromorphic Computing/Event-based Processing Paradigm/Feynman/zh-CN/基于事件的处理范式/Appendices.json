{
    "hands_on_practices": [
        {
            "introduction": "事件驱动处理的核心优势之一在于其数据效率，尤其是在处理时空稀疏信号时。本练习旨在通过第一性原理，引导您量化并对比事件相机与传统帧相机的输出数据率。通过推导这个比率，您将深刻理解事件驱动传感在何种场景下能够大幅减少数据冗余，为高效的下游处理奠定基础。",
            "id": "4043693",
            "problem": "考虑一个遵循基于事件处理范式的神经形态视觉传感器。在这种范式中，当局部信号发生足够大的变化时，像素会生成异步事件。假设在观测区间内以下场景是平稳的：$N_x \\times N_y$ 个像素中有比例为 $p$ 的像素是活跃的，每个活跃像素根据一个无记忆过程产生事件，平均速率为每秒 $\\lambda$ 个事件。每个事件携带一个 $b_a$ 比特的地址和一个 $b_t$ 比特的时间戳。忽略所有额外的协议开销，并假设每个事件的地址和时间戳是独立编码的。作为对比，考虑一个具有相同空间分辨率 $N_x \\times N_y$ 的传统基于帧的相机，其运行速率为每秒 $f$ 帧 (FPS)，其中每个像素强度用 $b_p$ 比特进行量化，并假设除了像素数据之外的开销可以忽略不计。\n\n从第一性原理以及关于速率过程和信息表示的成熟理论出发，推导事件流数据速率（单位为比特每秒）的期望值表达式，并在此基础上推导事件流数据速率与基于帧的数据速率的无量纲比率 $\\Gamma$ 的闭式表达式。请以 $p$、$\\lambda$、$f$、$b_a$、$b_t$ 和 $b_p$ 的函数形式，给出一个关于 $\\Gamma$ 的单一解析表达式作为最终答案。",
            "solution": "基于事件的传感器可以建模为每个像素对应一个独立点过程的集合。我们假设活跃像素具有平稳性和无记忆性，这与泊松过程模型是一致的。对于一个速率为 $\\lambda$（事件/秒）的泊松过程，在长度为 $T$ 的时间间隔内的期望事件数是 $\\lambda T$。根据期望的线性性质，由 $M$ 个速率均为 $\\lambda$ 的独立过程在时长 $T$ 内产生的事件的期望总数是 $M \\lambda T$。\n\n在给定场景中，$N_x \\times N_y$ 个像素中有比例为 $p$ 的像素是活跃的，因此活跃像素的期望数量为\n$$\nM \\;=\\; p \\, N_x N_y.\n$$\n因此，传感器每秒产生的事件的期望数量是\n$$\n\\text{events per second} \\;=\\; M \\lambda \\;=\\; p \\, N_x N_y \\, \\lambda.\n$$\n每个事件携带一个 $b_a$ 比特的地址和一个 $b_t$ 比特的时间戳。假设每个事件都包含这两者并且忽略其他开销，则每个事件的比特数为\n$$\nb_{\\text{event}} \\;=\\; b_a + b_t.\n$$\n因此，期望的事件流数据速率 $R_{\\text{event}}$（单位为比特每秒）是\n$$\nR_{\\text{event}} \\;=\\; \\Big(p \\, N_x N_y \\, \\lambda\\Big) \\, \\Big(b_a + b_t\\Big).\n$$\n\n对于基于帧的相机，每帧编码 $N_x N_y$ 个像素强度，每个像素 $b_p$ 比特。每帧的比特数是\n$$\nb_{\\text{frame}} \\;=\\; N_x N_y \\, b_p.\n$$\n以每秒 $f$ 帧的速率，基于帧的数据速率 $R_{\\text{frame}}$ 是\n$$\nR_{\\text{frame}} \\;=\\; f \\, b_{\\text{frame}} \\;=\\; f \\, N_x N_y \\, b_p.\n$$\n\n我们需要比较事件流数据速率与基于帧的数据速率，使用定义如下的无量纲比率 $\\Gamma$\n$$\n\\Gamma \\;=\\; \\frac{R_{\\text{event}}}{R_{\\text{frame}}}.\n$$\n代入上面推导出的表达式，\n$$\n\\Gamma \\;=\\; \\frac{\\Big(p \\, N_x N_y \\, \\lambda\\Big)\\, \\Big(b_a + b_t\\Big)}{f \\, N_x N_y \\, b_p}.\n$$\n公因子 $N_x N_y$ 被约掉，得到闭式表达式\n$$\n\\Gamma \\;=\\; \\frac{p \\, \\lambda \\, \\Big(b_a + b_t\\Big)}{f \\, b_p}.\n$$\n该表达式仅取决于活跃比例 $p$、每个活跃像素的事件速率 $\\lambda$、帧率 $f$ 以及比特分配 $b_a$、$b_t$ 和 $b_p$。它概括了所要求的比较，并且按要求是无量纲的。",
            "answer": "$$\\boxed{\\frac{p\\,\\lambda\\,(b_a+b_t)}{f\\,b_p}}$$"
        },
        {
            "introduction": "数据效率的优势最终会体现在计算效率上，尤其是在大规模神经网络中。本练习将带您从传感器层面深入到网络处理层面，分析一个事件驱动的前馈网络。您将推导出一个决定神经元何时“发言”的事件触发条件，并具体计算与传统的密集更新方案相比，这种稀疏处理方式能够节省多少计算操作（MACs），从而揭示该范式在现代人工智能应用中的巨大潜力。",
            "id": "4043669",
            "problem": "考虑一个在前馈网络中，采用基于事件的处理范式进行操作。该网络有一个大小为 $N_{0}$ 的输入层，一个大小为 $N_{1}$ 的隐藏层，以及一个大小为 $N_{2}$ 的输出层。隐藏层和输出层使用修正线性单元（ReLU）非线性激活函数，已知该函数是 $1$-Lipschitz 的，即对于任意输入 $u$ 和 $v$，有 $|\\mathrm{ReLU}(u) - \\mathrm{ReLU}(v)| \\leq |u - v|$。在密集更新模式下，在每个离散时间步 $t$，每个神经元计算其预激活值 $a_{j}^{(\\ell)}(t) = \\sum_{i} w_{ji}^{(\\ell)} x_{i}^{(\\ell-1)}(t) + b_{j}^{(\\ell)}$ 并应用非线性函数得到 $y_{j}^{(\\ell)}(t) = \\phi(a_{j}^{(\\ell)}(t))$，其中 $\\phi(u) = \\max\\{0, u\\}$。在事件驱动模式下，每个神经元维持一个本地存储的最后传输的预激活值 $\\hat{a}_{j}^{(\\ell)}$，并且仅当其当前预激活值与此存储值的偏差超过阈值 $\\tau_{\\ell}$ 时才传输一个事件。一个神经元上的事件会沿着其每个传出突触触发一次乘法累加（MAC）操作。\n\nA 部分（推导）：从非线性函数的 $L$-Lipschitz 连续性和层内传输激活偏差的误差容限 $\\varepsilon_{\\ell}$ 出发，推导出一个在层 $\\ell$ 中传播事件的充分条件，该条件保证仅当超过阈值时，不等式 $|\\phi(a_{j}^{(\\ell)}(t)) - \\phi(\\hat{a}_{j}^{(\\ell)})| \\leq \\varepsilon_{\\ell}$ 才会被违反。将您的条件表示为一个包含 $|a_{j}^{(\\ell)}(t) - \\hat{a}_{j}^{(\\ell)}|$ 和 $\\tau_{\\ell}$ 的不等式，并将 $\\tau_{\\ell}$ 与 $\\varepsilon_{\\ell}$ 以及 $\\phi$ 的 Lipschitz 常数 $L$ 联系起来。\n\nB 部分（计算）：考虑具体的网络大小 $N_{0} = 4096$，$N_{1} = 1024$，$N_{2} = 256$。假设有 $M = 10000$ 个离散时间步。在密集模式下，每个突触在每个时间步计为一次 MAC 操作（忽略应用非线性函数的成本）。在事件驱动模式下，假设输入层在整个时间窗口内总共产生 $E_{0} = 2.0 \\times 10^{6}$ 个事件，每个输入事件会沿着所有到隐藏层的传出突触触发 MAC 操作。隐藏层根据异步增量编码模型产生事件：在整个窗口内，所有隐藏神经元的预激活值的总变差为 $V_{1} = 1.024 \\times 10^{9}$，隐藏层的容限为 $\\varepsilon_{1} = 128$。利用 ReLU 的 $1$-Lipschitz 属性来设置 $\\tau_{1}$，并假设隐藏层事件的数量满足 $E_{1} = V_{1} / \\tau_{1}$，其中每个事件都会沿着所有到输出层的传出突触触发 MAC 操作。计算在整个窗口内，事件驱动模式相对于密集模式所节省的 MAC 操作总数。将您的最终答案报告为单个实数值。不要包含单位，也不要四舍五入；提供精确值。",
            "solution": "对于 A 部分，我们从 $L$-Lipschitz 连续性的定义开始。如果对于任意 $u$ 和 $v$ 都满足以下条件，则函数 $\\phi$ 是 $L$-Lipschitz 的：\n$$\n|\\phi(u) - \\phi(v)| \\leq L |u - v|.\n$$\n对于修正线性单元（ReLU），已知 $L = 1$。在基于事件的模式中，一个神经元存储其最后传输的预激活值 $\\hat{a}_{j}^{(\\ell)}$，并根据其当前预激活值 $a_{j}^{(\\ell)}(t)$ 的偏差来决定是否传输。为了保证传输激活值的偏差 $|\\phi(a_{j}^{(\\ell)}(t)) - \\phi(\\hat{a}_{j}^{(\\ell)})|$ 不超过层内容限 $\\varepsilon_{\\ell}$，只需确保\n$$\n|\\phi(a_{j}^{(\\ell)}(t)) - \\phi(\\hat{a}_{j}^{(\\ell)})| \\leq \\varepsilon_{\\ell}.\n$$\n根据 Lipschitz 连续性，\n$$\n|\\phi(a_{j}^{(\\ell)}(t)) - \\phi(\\hat{a}_{j}^{(\\ell)})| \\leq L |a_{j}^{(\\ell)}(t) - \\hat{a}_{j}^{(\\ell)}|.\n$$\n因此，如果我们强制 $|a_{j}^{(\\ell)}(t) - \\hat{a}_{j}^{(\\ell)}|  \\tau_{\\ell}$，其中 $\\tau_{\\ell} = \\varepsilon_{\\ell} / L$，那么激活偏差就被 $\\varepsilon_{\\ell}$ 所界定。因此，一个充分且标准的事件传播条件是\n$$\n|a_{j}^{(\\ell)}(t) - \\hat{a}_{j}^{(\\ell)}| \\geq \\tau_{\\ell},\n$$\n其中\n$$\n\\tau_{\\ell} = \\frac{\\varepsilon_{\\ell}}{L}.\n$$\n对于 ReLU，$L = 1$，所以 $\\tau_{\\ell} = \\varepsilon_{\\ell}$。该规则确保只有当存储的预激活值和当前的预激活值之间的差异至少达到与允许的激活偏差相对应的阈值时，事件才会被传播，因此通过仅在需要维持规定精度时才传输更新来遵循稀疏更新原则。\n\n对于 B 部分，我们量化两种模式下的 MAC 操作。\n\n密集模式：每个突触在每个时间步计为一次 MAC 操作。输入层和隐藏层之间的突触数量为 $N_{0} N_{1}$，隐藏层和输出层之间的突触数量为 $N_{1} N_{2}$。因此，在 $M$ 个时间步内，密集模式下的 MAC 总数为\n$$\n\\mathrm{MAC}_{\\mathrm{dense}} = M \\left( N_{0} N_{1} + N_{1} N_{2} \\right).\n$$\n代入给定值 $N_{0} = 4096$，$N_{1} = 1024$，$N_{2} = 256$ 和 $M = 10000$：\n$$\nN_{0} N_{1} = 4096 \\times 1024 = 4{,}194{,}304,\n$$\n$$\nN_{1} N_{2} = 1024 \\times 256 = 262{,}144,\n$$\n$$\nN_{0} N_{1} + N_{1} N_{2} = 4{,}194{,}304 + 262{,}144 = 4{,}456{,}448,\n$$\n$$\n\\mathrm{MAC}_{\\mathrm{dense}} = 10000 \\times 4{,}456{,}448 = 44{,}564{,}480{,}000.\n$$\n\n事件驱动模式：每个事件会沿着所有传出突触触发 MAC 操作。输入事件：有 $E_{0} = 2.0 \\times 10^{6}$ 个输入事件，每个事件扇出到 $N_{1}$ 个突触，所以\n$$\n\\mathrm{MAC}_{0 \\to 1} = E_{0} N_{1} = (2.0 \\times 10^{6}) \\times 1024 = 2{,}048{,}000{,}000.\n$$\n隐藏层事件：隐藏层使用异步增量编码。其总变差为 $V_{1} = 1.024 \\times 10^{9}$，由于 ReLU 是 $1$-Lipschitz 的，且隐藏层容限为 $\\varepsilon_{1} = 128$，我们设置\n$$\n\\tau_{1} = \\frac{\\varepsilon_{1}}{L} = \\frac{128}{1} = 128.\n$$\n在此编码下，隐藏事件的数量为\n$$\nE_{1} = \\frac{V_{1}}{\\tau_{1}} = \\frac{1.024 \\times 10^{9}}{128} = 8.0 \\times 10^{6}.\n$$\n每个隐藏层事件扇出到 $N_{2}$ 个突触，因此\n$$\n\\mathrm{MAC}_{1 \\to 2} = E_{1} N_{2} = (8.0 \\times 10^{6}) \\times 256 = 2{,}048{,}000{,}000.\n$$\n事件驱动模式下的 MAC 总数为\n$$\n\\mathrm{MAC}_{\\mathrm{event}} = \\mathrm{MAC}_{0 \\to 1} + \\mathrm{MAC}_{1 \\to 2} = 2{,}048{,}000{,}000 + 2{,}048{,}000{,}000 = 4{,}096{,}000{,}000.\n$$\n\n相对于密集更新所节省的操作数为\n$$\nS = \\mathrm{MAC}_{\\mathrm{dense}} - \\mathrm{MAC}_{\\mathrm{event}} = 44{,}564{,}480{,}000 - 4{,}096{,}000{,}000 = 40{,}468{,}480{,}000.\n$$\n用科学记数法表示，\n$$\nS = 4.046848 \\times 10^{10}.\n$$\n\n因此，事件传播的充分条件是 $|a_{j}^{(\\ell)}(t) - \\hat{a}_{j}^{(\\ell)}| \\geq \\tau_{\\ell}$，其中 $\\tau_{\\ell} = \\varepsilon_{\\ell} / L$，而在给定参数下节省的 MAC 操作的精确数量是 $40,468,480,000$。",
            "answer": "$$\\boxed{40468480000}$$"
        },
        {
            "introduction": "为了真正掌握事件驱动范式的精髓，没有什么比亲手实现其核心算法更有效了。这项最终的实践练习是一项编码挑战，要求您为一个经典的Leaky Integrate-and-Fire (LIF)神经元构建一个事件驱动模拟器。通过将其与传统的步进式模拟器进行对比，您将从实践中深刻体会到“仅在必要时处理信息”这一理念在算法上的优雅性和高效性。",
            "id": "4043696",
            "problem": "设计并实现一个针对单个漏积分放电（LIF）神经元的事件驱动模拟器，该模拟器仅在突触事件发生时和阈值穿越（脉冲发放）时推进状态。根据LIF动力学的基本定义推导模拟器行为，并通过第一性原理和渐近分析证明，其时间复杂度与事件数量成比例，而不是与均匀时间步数成比例。此外，实现一个参考用的时间步进模拟器以进行比较。您的程序必须计算若干测试用例的指定输出，并以要求的格式打印它们。\n\n基本原理和定义：\n- 漏积分放电（LIF）神经元的膜电位 $V(t)$ 由以下常微分方程控制：\n$$\\frac{dV}{dt} = -\\frac{V(t) - V_{\\mathrm{leak}}}{\\tau} + I_{\\mathrm{syn}}(t),$$\n其中 $V_{\\mathrm{leak}}$ 是漏泄反转电位，$\\tau$ 是膜时间常数，$I_{\\mathrm{syn}}(t)$ 是突触输入电流。我们将突触输入建模为一系列瞬时脉冲（狄拉克δ函数），这些脉冲会导致 $V(t)$ 发生瞬时跳变：\n$$I_{\\mathrm{syn}}(t) = \\sum_{k=1}^{K} w_k \\,\\delta(t - t_k),$$\n其中 $t_k$ 是事件时间，$w_k$ 是事件权重，单位为伏特（解释为由积分脉冲电流引起的膜电位瞬时跳变）。\n- 在突触事件之间且在不应期之外，齐次解产生指数衰减：\n$$V(t) = V_{\\mathrm{leak}} + \\big(V(t_0) - V_{\\mathrm{leak}}\\big)\\, e^{-\\frac{t - t_0}{\\tau}} \\quad \\text{for } t \\in (t_0, t_{\\mathrm{next}}),$$\n其中 $t_0$ 是上一次状态更新的时间。在事件时间 $t_k$，$V(t_k^-)$ 的膜电位发生瞬时跳变：\n$$V(t_k^+) = V(t_k^-) + w_k.$$\n- 阈值穿越规则：如果 $V(t_k^+) \\ge V_{\\mathrm{th}}$，则在时间 $t_k$ 发生一次脉冲，$V$ 被重置为 $V_{\\mathrm{reset}}$，并且神经元进入一个持续时间为 $t_{\\mathrm{ref}}$ 的绝对不应期，在此期间 $V(t) = V_{\\mathrm{reset}}$ 被钳制，突触输入被忽略。不应期结束后，动力学从 $V_{\\mathrm{reset}}$ 恢复。\n- 初始条件：$V(0) = V_{\\mathrm{leak}}$。所有时间单位为秒。所有电位和权重单位为伏特。阈值比较在事件瞬间使用规则 $V \\ge V_{\\mathrm{th}}$。\n\n算法目标：\n- 事件驱动模拟器：仅在突触事件时间和阈值穿越时推进状态。对于在同一时间 $t$ 发生的同步事件，通过求和将其权重聚合成一个总权重为 $\\sum w$ 的单次跳变。当事件时间发生在不应期内时，忽略该事件。复杂度通过计算状态推进次数来衡量，定义为处理的聚合事件时间数加上脉冲数。\n- 参考时间步进模拟器：在步长为 $\\Delta t$ 的均匀时间网格上使用前向欧拉更新，在包含事件时间的步长开始时应用事件。忽略不应期内的事件。复杂度通过计算时间步数 $N = \\lceil T_{\\mathrm{end}}/\\Delta t \\rceil$ 来衡量。\n\n数学和复杂度要求：\n- 从事件间的齐次指数衰减和事件发生时的瞬时跳变推导出事件驱动的更新规则。证明事件驱动模拟器执行的状态推进次数为 $K_{\\mathrm{agg}} + S$，其中 $K_{\\mathrm{agg}}$ 是聚合事件时间的数量，$S$ 是脉冲的数量，从而建立 $O(K_{\\mathrm{agg}} + S)$ 的复杂度。相比之下，无论事件稀疏性如何，时间步进模拟器都执行 $N$ 次更新，从而建立 $O(N)$ 的复杂度。提供清晰的推理，说明事件驱动模拟器在事件或脉冲之间不执行任何更新。\n- 对于每个测试用例，程序必须计算事件驱动模拟器产生的整数脉冲数、时间步进模拟器产生的整数脉冲数、事件驱动状态推进的整数计数以及时间步进更新的整数计数。此外，它必须以浮点数形式输出事件驱动脉冲时间的列表（单位为秒）。\n\n测试套件和参数：\n使用以下五个测试用例，所有单位均已明确说明：\n- 用例 $1$（混合兴奋性和抑制性的一般情况）：\n    - $\\tau = 0.02$ s, $V_{\\mathrm{leak}} = -0.065$ V, $V_{\\mathrm{th}} = -0.050$ V, $V_{\\mathrm{reset}} = -0.065$ V, $t_{\\mathrm{ref}} = 0.005$ s, $T_{\\mathrm{end}} = 0.1$ s, $\\Delta t = 0.0001$ s。\n    - 事件：$(t,w)$ 对，单位为秒和伏特：$(0.010, 0.012)$, $(0.030, 0.015)$, $(0.032, -0.010)$, $(0.070, 0.020)$。\n- 用例 $2$（无突触事件）：\n    - 参数与用例 $1$ 相同，但事件列表为空，$T_{\\mathrm{end}} = 0.1$ s, $\\Delta t = 0.0001$ s。\n- 用例 $3$（同一时间发生的同步事件被聚合）：\n    - 参数与用例 $1$ 相同。\n    - 事件：$(0.050, 0.010)$, $(0.050, 0.011)$, $(0.050, 0.010)$。\n- 用例 $4$（净抑制抑制脉冲发放）：\n    - 参数与用例 $1$ 相同。\n    - 事件：$(0.010, 0.010)$, $(0.015, -0.015)$, $(0.040, 0.008)$。\n- 用例 $5$（不应期内的事件被忽略）：\n    - 参数与用例 $1$ 相同。\n    - 事件：$(0.010, 0.020)$, $(0.012, 0.005)$, $(0.020, 0.020)$。\n\n答案规格：\n- 对于每个测试用例，计算一个形式为 $[S_{\\mathrm{event}}, S_{\\mathrm{time}}, C_{\\mathrm{event}}, C_{\\mathrm{time}}, \\text{spike\\_times\\_event}]$ 的列表，其中 $S_{\\mathrm{event}}$ 是事件驱动模拟器中的整数脉冲数，$S_{\\mathrm{time}}$ 是时间步进模拟器中的整数脉冲数，$C_{\\mathrm{event}} = K_{\\mathrm{agg}} + S_{\\mathrm{event}}$ 是事件驱动状态推进的整数计数，$C_{\\mathrm{time}} = N$ 是时间步进更新的整数计数，而 $\\text{spike\\_times\\_event}$ 是事件驱动脉冲时间的列表（单位为秒，浮点数）。\n- 您的程序应生成单行输出，其中包含所有五个测试用例的结果，以逗号分隔的列表形式包含在方括号内，例如：$[[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。",
            "solution": "该问题要求设计、分析和实现两种用于漏积分放电（LIF）神经元的模拟器：一种是事件驱动模拟器，另一种是时间步进模拟器。此分析将最终基于提供的测试套件进行计算比较。\n\nLIF神经元膜电位 $V(t)$ 的动力学由以下常微分方程控制：\n$$\n\\frac{dV}{dt} = -\\frac{V(t) - V_{\\mathrm{leak}}}{\\tau} + I_{\\mathrm{syn}}(t)\n$$\n这里，$\\tau$ 是膜时间常数，$V_{\\mathrm{leak}}$ 是漏泄反转电位，$I_{\\mathrm{syn}}(t)$ 代表突触输入电流。输入被建模为一系列在时间 $t_k$ 到达、权重为 $w_k$ 的瞬时脉冲：\n$$\nI_{\\mathrm{syn}}(t) = \\sum_{k=1}^{K} w_k \\,\\delta(t - t_k)\n$$\n在 $t_k$ 附近一个极小的时间区间内对该电流进行积分，会导致膜电位产生一个大小为 $w_k$ 的瞬时跳变。神经元的状态初始化为 $V(0) = V_{\\mathrm{leak}}$。\n\n如果在时间 $t$，膜电位 $V(t)$ 达到或超过阈值 $V_{\\mathrm{th}}$，则会产生一个脉冲。发放脉冲后，电位被重置为 $V_{\\mathrm{reset}}$，并在此值上被钳制一段持续时间为 $t_{\\mathrm{ref}}$ 的绝对不应期。在此期间，所有突触输入均被忽略。\n\n**事件驱动模拟器设计**\n\n事件驱动模拟器的核心原理是利用在没有输入时LIF动力学的解析解。在任意两个连续事件（突触输入或脉冲）之间，输入电流项 $I_{\\mathrm{syn}}(t)$ 为零。控制方程变为一个齐次线性一阶常微分方程：\n$$\n\\frac{dV}{dt} = -\\frac{V(t) - V_{\\mathrm{leak}}}{\\tau}\n$$\n给定在时间 $t_0$ 的电位 $V(t_0)$，对于任何后续时间 $t  t_0$（在下一个事件之前）的解是：\n$$\nV(t) = V_{\\mathrm{leak}} + \\big(V(t_0) - V_{\\mathrm{leak}}\\big)\\, e^{-\\frac{t - t_0}{\\tau}}\n$$\n这个解析解允许模拟器在时间上从一个事件“跳”到下一个事件，精确计算下一个事件时间的电位状态，而无需模拟中间的间隔。状态更新仅在系统动力学发生不连续变化的时刻是必要的，即突触事件发生的时刻。\n\n算法如下：\n1.  **初始化**：设置当前时间 $t_{\\mathrm{curr}} = 0$，膜电位 $V_{\\mathrm{curr}} = V_{\\mathrm{leak}}$，以及神经元不应期结束时间 $t_{\\mathrm{ref\\_end}} = -\\infty$。初始化一个空列表用于存储脉冲时间。\n2.  **事件聚合**：预处理突触事件列表 $(t_k, w_k)$。对于所有在完全相同时间发生的事件，它们的权重被相加。这产生一个按时间排序的、包含唯一聚合事件时间及其相应总权重的列表。设该列表有 $K_{\\mathrm{agg}}$ 个条目。\n3.  **事件循环**：按时间顺序遍历每个聚合事件 $(t_{\\mathrm{event}}, w_{\\mathrm{event}})$。\n    a. **不应期检查**：如果 $t_{\\mathrm{event}}  t_{\\mathrm{ref\\_end}}$，神经元处于其绝对不应期。该事件被忽略。\n    b. **状态推进**：如果事件未被忽略，神经元的电位必须从上次更新的时间推进到 $t_{\\mathrm{event}}$。衰减周期的开始时间为 $t_{\\mathrm{decay\\_start}} = \\max(t_{\\mathrm{curr}}, t_{\\mathrm{ref\\_end}})$。衰减开始时的电位 $V_{\\mathrm{at\\_decay\\_start}}$，如果神经元刚退出不应期，则为 $V_{\\mathrm{reset}}$，否则为 $V_{\\mathrm{curr}}$。在 $t_{\\mathrm{event}}$ 时突触跳变前的电位为：\n       $$\n       V(t_{\\mathrm{event}}^-) = V_{\\mathrm{leak}} + \\big(V_{\\mathrm{at\\_decay\\_start}} - V_{\\mathrm{leak}}\\big)\\, e^{-\\frac{t_{\\mathrm{event}} - t_{\\mathrm{decay\\_start}}}{\\tau}}\n       $$\n    c. **突触整合**：突触权重被瞬时加上：$V(t_{\\mathrm{event}}^+) = V(t_{\\mathrm{event}}^-) + w_{\\mathrm{event}}$。\n    d. **脉冲检查**：如果 $V(t_{\\mathrm{event}}^+) \\ge V_{\\mathrm{th}}$，则在 $t_{\\mathrm{event}}$ 记录一个脉冲。电位被重置为 $V_{\\mathrm{curr}} = V_{\\mathrm{reset}}$，不应期结束时间更新为 $t_{\\mathrm{ref\\_end}} = t_{\\mathrm{event}} + t_{\\mathrm{ref}}$。\n    e. **无脉冲更新**：如果没有发生脉冲，新电位设置为 $V_{\\mathrm{curr}} = V(t_{\\mathrm{event}}^+)$。\n    f. **时间更新**：当前模拟时间更新为 $t_{\\mathrm{curr}} = t_{\\mathrm{event}}$。\n\n**时间步进模拟器设计**\n\n时间步进模拟器在离散时间网格上使用数值积分方法来近似连续动力学。在这里，我们使用固定时间步长 $\\Delta t$ 的前向欧拉方法。\n常微分方程的离散形式为：\n$$\nV_{i+1} = V_i + \\Delta t \\left( -\\frac{V_i - V_{\\mathrm{leak}}}{\\tau} \\right)\n$$\n其中 $V_i$ 是时间 $t_i = i \\cdot \\Delta t$ 时的电位。\n\n算法如下：\n1.  **初始化**：设置 $t = 0$, $V = V_{\\mathrm{leak}}$, $t_{\\mathrm{ref\\_end}} = -\\infty$。确定总步数 $N = \\lceil T_{\\mathrm{end}} / \\Delta t \\rceil$。通过将突触事件分箱到它们所属的时间步长区间来预处理它们。\n2.  **时间循环**：对 $i$ 从 $0$ 到 $N-1$ 进行迭代。设当前时间为 $t = i \\cdot \\Delta t$。\n    a. **不应期检查**：如果 $t  t_{\\mathrm{ref\\_end}}$，设置 $V = V_{\\mathrm{reset}}$ 并继续到下一个时间步。\n    b. **突触整合**：将在区间 $[t, t+\\Delta t)$ 内发生的所有事件的权重相加，并将此总和加到 $V$ 上。\n    c. **脉冲检查**：如果 $V \\ge V_{\\mathrm{th}}$，则在时间 $t$ 记录一个脉冲，重置 $V = V_{\\mathrm{reset}}$，更新 $t_{\\mathrm{ref\\_end}} = t + t_{\\mathrm{ref}}$，并继续到下一个时间步。\n    d. **欧拉更新**：如果没有发生脉冲，使用欧拉公式更新电位：$V \\leftarrow V + \\Delta t \\cdot \\left(-(V - V_{\\mathrm{leak}})/\\tau\\right)$。\n\n**复杂度分析**\n\n计算复杂度由基本状态推进操作的数量来衡量。\n\n-   **事件驱动模拟器**：算法的主循环对 $K_{\\mathrm{agg}}$ 个聚合突触事件中的每一个迭代一次。在循环内部，执行恒定数量的算术运算。总脉冲数为 $S$。根据问题的定义，复杂度度量是处理的聚合事件数加上脉冲数，$C_{\\mathrm{event}} = K_{\\mathrm{agg}} + S$。因此，模拟循环的运行时间与 $K_{\\mathrm{agg}}$ 成正比。因此，时间复杂度为 $O(K_{\\mathrm{agg}} + S)$。对 $K$ 个初始事件进行预排序需要 $O(K \\log K)$，但模拟本身的复杂度与唯一事件时间的数量成比例，而不是模拟持续时间或时间步长分辨率。该方法在事件之间不执行任何更新，因为它通过解析方式弥合了时间间隙。\n\n-   **时间步进模拟器**：该算法执行一个循环固定次数，$N = \\lceil T_{\\mathrm{end}}/\\Delta t \\rceil$。在每次迭代中，它执行恒定数量的操作。计算成本与突触事件的数量无关。状态推进的总次数定义为时间步数，$C_{\\mathrm{time}} = N$。因此，时间复杂度为 $O(N)$。\n\n-   **比较**：当突触输入稀疏时，事件数 $K_{\\mathrm{agg}}$ 通常远小于精确模拟所需的时间步数 $N$（即 $K_{\\mathrm{agg}} \\ll T_{\\mathrm{end}}/\\Delta t$）。在这种情况下，事件驱动模拟器在计算效率上显著优于时间步进模拟器。",
            "answer": "[[2, 2, 6, 1000, [0.03, 0.07]], [0, 0, 0, 1000, []], [1, 1, 2, 1000, [0.05]], [0, 0, 3, 1000, []], [2, 2, 5, 1000, [0.01, 0.02]]]"
        }
    ]
}