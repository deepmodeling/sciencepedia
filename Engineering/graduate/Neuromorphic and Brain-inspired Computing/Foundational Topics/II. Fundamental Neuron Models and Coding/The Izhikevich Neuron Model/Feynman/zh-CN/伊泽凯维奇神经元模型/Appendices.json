{
    "hands_on_practices": [
        {
            "introduction": "在模拟Izhikevich模型复杂的脉冲动力学之前，理解其在无脉冲状态下的行为至关重要。本练习将指导您通过线性稳定性分析，以解析的方式确定神经元静息态的特性，这是神经科学中动力系统研究的一项基础技术 。通过计算不动点处的雅可比矩阵特征值，您将能够证明静息态是否稳定，并描述系统在受到微小扰动后如何返回平衡。",
            "id": "4029541",
            "problem": "考虑Izhikevich神经元模型，该模型通过耦合常微分方程（ODEs）描述膜电压和恢复变量的动力学\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I, \\qquad \\frac{du}{dt} = a\\,(b\\,v - u),\n$$\n并具有通常的尖峰重置机制（在不动点处不激活）。使用以下参数值，这些值是常规尖峰皮层锥体神经元的典型值：$a = 0.02$, $b = 0.2$, 以及恒定的外部输入 $I = 3$。不动点由电压和恢复零斜线的交点定义，分别由 $dv/dt = 0$ 和 $du/dt = 0$ 给出。在这些不动点中，关注电压较低的交点（即更超极化的那一个）。\n\n从不动点、零斜线、动力学系统的雅可比矩阵和线性稳定性（特征值的实部）的基本定义出发，执行以下操作：\n\n- 确定作为零斜线交点的不动点 $(v^{\\ast}, u^{\\ast})$。\n- 计算在 $(v^{\\ast}, u^{\\ast})$ 处的雅可比矩阵，并推导其特征值以评估局部线性稳定性。\n- 将 $(v^{\\ast}, u^{\\ast})$ 处特征值的最大实部以单一闭式解析表达式的形式报告。使用模型的原生时间单位，并以毫秒的倒数表示该值。不要对最终表达式进行四舍五入。",
            "solution": "该问题要求对Izhikevich神经元模型的一个不动点进行分析。该过程包括识别不动点，通过计算雅可比矩阵将系统动力学在该点附近线性化，然后通过计算雅可比矩阵的特征值来确定局部稳定性。最终要求的量是这些特征值实部的最大值。\n\n该动力学系统由以下耦合常微分方程描述：\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a\\,(b\\,v - u)\n$$\n所提供的参数为 $a = 0.02$, $b = 0.2$，外部输入电流为 $I = 3$。变量和参数的单位使得时间 $t$ 以毫秒（$ms$）计，电压 $v$ 以毫伏（$mV$）计。\n\n首先，我们通过将时间导数设为零来找到系统的不动点 $(v^{\\ast}, u^{\\ast})$。\n零斜线由以下方程给出：\n1.  电压零斜线 ($\\frac{dv}{dt} = 0$): $0.04\\,v^{2} + 5\\,v + 140 - u + I = 0$\n2.  恢复零斜线 ($\\frac{du}{dt} = 0$): $a\\,(b\\,v - u) = 0$\n\n从恢复零斜线可知，由于 $a = 0.02 \\ne 0$，我们必须有 $b\\,v - u = 0$。这给出了不动点处 $u$ 和 $v$ 之间的线性关系：\n$$\nu = b\\,v\n$$\n我们将这个 $u$ 的表达式代入电压零斜线方程：\n$$\n0.04\\,v^{2} + 5\\,v + 140 - (b\\,v) + I = 0\n$$\n$$\n0.04\\,v^{2} + (5 - b)v + (140 + I) = 0\n$$\n现在，我们代入给定的参数值 $b = 0.2$ 和 $I = 3$：\n$$\n0.04\\,v^{2} + (5 - 0.2)v + (140 + 3) = 0\n$$\n$$\n0.04\\,v^{2} + 4.8\\,v + 143 = 0\n$$\n这是一个关于不动点电压 $v$ 的二次方程。我们使用二次公式 $v = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$ 求解 $v$，其中 $A=0.04$, $B=4.8$, $C=143$：\n$$\nv = \\frac{-4.8 \\pm \\sqrt{(4.8)^{2} - 4(0.04)(143)}}{2(0.04)}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{23.04 - 22.88}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{0.16}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm 0.4}{0.08}\n$$\n这得出了 $v$ 的两个可能值：\n$$\nv_{1} = \\frac{-4.8 + 0.4}{0.08} = \\frac{-4.4}{0.08} = -55\n$$\n$$\nv_{2} = \\frac{-4.8 - 0.4}{0.08} = \\frac{-5.2}{0.08} = -65\n$$\n问题指定使用“电压较低的交点（即更超极化的那一个）”，这对应于更负的值。因此，我们选择 $v^{\\ast} = -65$。\n\n现在，我们使用关系式 $u = b\\,v$ 来找到恢复变量 $u^{\\ast}$ 的对应值：\n$$\nu^{\\ast} = b\\,v^{\\ast} = 0.2 \\times (-65) = -13\n$$\n相关的不动点是 $(v^{\\ast}, u^{\\ast}) = (-65, -13)$。\n\n接下来，我们计算系统的雅可比矩阵以分析其稳定性。该系统可以写成 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{F}(\\mathbf{x})$，其中 $\\mathbf{x} = [v, u]^T$ 且 $\\mathbf{F}(\\mathbf{x}) = [f(v,u), g(v,u)]^T$，其中：\n$$\nf(v, u) = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\ng(v, u) = a\\,(b\\,v - u) = ab\\,v - au\n$$\n雅可比矩阵 $J$ 由下式给出：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial f}{\\partial v} & \\frac{\\partial f}{\\partial u} \\\\ \\frac{\\partial g}{\\partial v} & \\frac{\\partial g}{\\partial u} \\end{pmatrix} = \\begin{pmatrix} 0.08\\,v + 5 & -1 \\\\ ab & -a \\end{pmatrix}\n$$\n我们在不动点 $(v^{\\ast}, u^{\\ast}) = (-65, -13)$ 处评估此矩阵，并代入参数值 $a = 0.02$ 和 $b = 0.2$：\n$$\nJ^{\\ast} = J(-65, -13) = \\begin{pmatrix} 0.08(-65) + 5 & -1 \\\\ (0.02)(0.2) & -0.02 \\end{pmatrix}\n$$\n$$\nJ^{\\ast} = \\begin{pmatrix} -5.2 + 5 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix} = \\begin{pmatrix} -0.2 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix}\n$$\n雅可比矩阵 $J^{\\ast}$ 的特征值 $\\lambda$ 决定了局部稳定性。它们是特征方程 $\\det(J^{\\ast} - \\lambda I) = 0$ 的根，其中 $I$ 是单位矩阵。对于一个 $2 \\times 2$ 矩阵，特征方程为 $\\lambda^{2} - \\text{Tr}(J^{\\ast})\\lambda + \\det(J^{\\ast}) = 0$。\n\n$J^{\\ast}$ 的迹（trace）是：\n$$\n\\text{Tr}(J^{\\ast}) = -0.2 + (-0.02) = -0.22\n$$\n$J^{\\ast}$ 的行列式（determinant）是：\n$$\n\\det(J^{\\ast}) = (-0.2)(-0.02) - (-1)(0.004) = 0.004 + 0.004 = 0.008\n$$\n因此，特征方程为：\n$$\n\\lambda^{2} - (-0.22)\\lambda + 0.008 = 0\n$$\n$$\n\\lambda^{2} + 0.22\\lambda + 0.008 = 0\n$$\n我们使用二次公式求解特征值 $\\lambda$：\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{(0.22)^{2} - 4(1)(0.008)}}{2(1)}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0484 - 0.032}}{2}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0164}}{2}\n$$\n判别式 $0.0164$ 为正，所以两个特征值都是实数。特征值的实部就是特征值本身。这两个特征值是：\n$$\n\\lambda_{1} = \\frac{-0.22 + \\sqrt{0.0164}}{2} \\quad \\text{和} \\quad \\lambda_{2} = \\frac{-0.22 - \\sqrt{0.0164}}{2}\n$$\n问题要求特征值的最大实部。这显然是 $\\lambda_{1}$。为了提供一个闭式解析表达式，我们简化平方根下的项：\n$$\n\\sqrt{0.0164} = \\sqrt{\\frac{164}{10000}} = \\frac{\\sqrt{4 \\times 41}}{100} = \\frac{2\\sqrt{41}}{100} = \\frac{\\sqrt{41}}{50}\n$$\n将此代回 $\\lambda_1$ 的表达式中：\n$$\n\\lambda_{\\max} = \\frac{1}{2}\\left(-0.22 + \\frac{\\sqrt{41}}{50}\\right) = \\frac{1}{2}\\left(-\\frac{22}{100} + \\frac{2\\sqrt{41}}{100}\\right) = \\frac{1}{2}\\left(\\frac{-22 + 2\\sqrt{41}}{100}\\right) = \\frac{-11 + \\sqrt{41}}{100}\n$$\n$\\sqrt{41}$ 的值约等于 $6.4$，所以 $-11 + \\sqrt{41}$ 是负数。这证实了该不动点是一个稳定节点，这与神经元模型的静息态的预期相符。特征值的最大实部是 $\\frac{-11 + \\sqrt{41}}{100}$。模型的时间单位是毫秒（$ms$），所以特征值的单位是 $ms^{-1}$。",
            "answer": "$$\\boxed{\\frac{-11 + \\sqrt{41}}{100}}$$"
        },
        {
            "introduction": "在理解了亚阈值状态后，我们现在转向模型的主要功能：产生脉冲。本练习涉及对模型进行数值模拟以生成脉冲序列，然后分析其时间结构，重点关注一种关键的生物学现象——脉冲频率适应 。您将实施欧拉方法来积分模型方程，并计算脉冲间期（ISIs），以量化神经元在响应恒定刺激时其发放率如何随时间变化。",
            "id": "4064812",
            "problem": "设计并实现一个程序，该程序模拟常规脉冲（RS）模式下的Izhikevich脉冲神经元，并计算峰间期（ISIs）和适应比。使用以下定义，这些定义是Izhikevich模型的基础。膜电位由$v$（单位为$\\mathrm{mV}$）表示，恢复变量由$u$（无量纲）表示，外部施加电流由$I$（单位为与模型一致的电流单位，使得$v$的单位为$\\mathrm{mV}$，时间的单位为$\\mathrm{ms}$）表示。Izhikevich模型由以下常微分方程（ODEs）系统控制：\n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I, \\quad \\frac{du}{dt} = a(bv - u),\n$$\n当膜电位达到脉冲阈值时，应用峰后重置条件：\n$$\n\\text{if } v \\ge 30 \\text{ (in } \\mathrm{mV}\\text{)}, \\text{ then set } v \\leftarrow c \\text{ and } u \\leftarrow u + d.\n$$\n假设初始条件为$v(0)=c$和$u(0)=bv(0)$。使用固定步长$\\Delta t$（单位为$\\mathrm{ms}$）的显式欧拉方法进行模拟，并通过在每个时间步内进行线性插值来实现脉冲事件检测：如果$v$在一个步长内从下向上穿过脉冲阈值，则通过对步长前后的$v$值进行线性插值来估计脉冲时间$t_{\\text{spike}}$（单位为$\\mathrm{ms}$）。使用每步的第一次穿越，并立即在该步应用重置规则。\n\n将峰间期（ISIs）定义为连续脉冲时间之间的差值，单位为毫秒。适应比定义为比率$\\text{ISI}_1/\\text{ISI}_5$，其中$\\text{ISI}_k$表示第$k$个ISI（按出现顺序）。如果在模拟窗口内发生的脉冲少于6个，则将适应比定义为$\\mathrm{nan}$（非数字）。\n\n所有时间必须以$\\mathrm{ms}$表示，电压以$\\mathrm{mV}$表示，适应比是无量纲的。您的程序必须计算以下测试套件的结果，并生成单行输出，其中包含每个测试用例的适应比，格式为方括号内以逗号分隔的列表，例如$[\\text{ratio}_1,\\text{ratio}_2,\\text{ratio}_3]$。将每个比率四舍五入到$6$位小数。如果比率未定义，则在其位置输出$\\mathrm{nan}$。\n\n测试套件（所有情况均使用RS参数）：\n- 常规脉冲（RS）参数：$(a,b,c,d) = (0.02,0.2,-65,8)$。\n- 脉冲阈值：$30 \\,\\mathrm{mV}$。\n\n测试用例：\n- 用例A（正常情况）：恒定电流$I=14$，总模拟时间$T=1000 \\,\\mathrm{ms}$，时间步长$\\Delta t = 0.1 \\,\\mathrm{ms}$。\n- 用例B（低电流边界）：恒定电流$I=5$，总模拟时间$T=1000 \\,\\mathrm{ms}$，时间步长$\\Delta t = 0.1 \\,\\mathrm{ms}$。\n- 用例C（高电流和更小步长）：恒定电流$I=30$，总模拟时间$T=500 \\,\\mathrm{ms}$，时间步长$\\Delta t = 0.05 \\,\\mathrm{ms}$。\n\n对于每个用例，计算前五个峰间期（单位为ms），然后计算适应比$\\text{ISI}_1/\\text{ISI}_5$。要求的最终输出格式为单行：\n$[\\text{ratio}_A,\\text{ratio}_B,\\text{ratio}_C]$\n其中每个数值都四舍五入到$6$位小数，并且在窗口内脉冲数少于$6$个的情况下使用$\\mathrm{nan}$。不应打印其他任何文本。",
            "solution": "用户想要模拟Izhikevich神经元模型，特别是在常规脉冲（RS）模式下，并根据产生的脉冲序列计算脉冲适应比。\n\n### 步骤1：问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n#### 已知条件提取\n\n-   **模型方程**：\n    $$\n    \\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I\n    $$\n    $$\n    \\frac{du}{dt} = a(bv - u)\n    $$\n-   **状态变量**：$v$（膜电位，$\\mathrm{mV}$），$u$（恢复变量，无量纲）。\n-   **输入电流**：$I$。\n-   **脉冲重置条件**：如果$v \\ge 30 \\, \\mathrm{mV}$，则$v \\leftarrow c$且$u \\leftarrow u + d$。\n-   **初始条件**：$v(0)=c$, $u(0)=bv(0)$。\n-   **模拟方法**：固定步长显式欧拉方法，时间步长为$\\Delta t$。\n-   **脉冲检测**：当$v$在一个时间步内从下向上穿过$30 \\, \\mathrm{mV}$的阈值时，使用线性插值计算脉冲时间$t_{\\text{spike}}$。重置将在“那一步”应用。\n-   **定义**：\n    -   峰间期（ISI）：连续脉冲之间的时间差。\n    -   适应比：$\\text{ISI}_1/\\text{ISI}_5$。如果发生的脉冲少于$6$个，则值为$\\mathrm{nan}$。\n-   **参数**：\n    -   常规脉冲（RS）：$(a,b,c,d) = (0.02, 0.2, -65, 8)$。\n    -   脉冲阈值：$30 \\, \\mathrm{mV}$。\n-   **测试用例**：\n    -   用例A：$I=14$, $T=1000 \\, \\mathrm{ms}$, $\\Delta t = 0.1 \\, \\mathrm{ms}$。\n    -   用例B：$I=5$, $T=1000 \\, \\mathrm{ms}$, $\\Delta t = 0.1 \\, \\mathrm{ms}$。\n    -   用例C：$I=30$, $T=500 \\, \\mathrm{ms}$, $\\Delta t = 0.05 \\, \\mathrm{ms}$。\n-   **输出格式**：单行`[ratio_A,ratio_B,ratio_C]`，比率四舍五入到$6$位小数，并在适当位置包含`nan`。\n\n#### 验证分析\n\n1.  **科学依据**：该问题基于Izhikevich神经元模型，这是计算神经科学的基石，发表于2003年一篇高被引论文。其参数和行为（常规脉冲）是标准且有据可查的。该问题在科学上是合理的。\n2.  **适定性**：该问题提供了一整套微分方程、初始条件、参数和指定的数值方法（显式欧拉法）。这确保了可以计算出唯一的数值解。所需的输出是基于模拟结果明确定义的。\n3.  **客观性**：该问题使用精确的数学和计算语言陈述。所有参数和条件都以客观数值形式给出。\n4.  **完整性和一致性**：提供了所有必要信息。变量、参数和单位（$\\mathrm{mV}$、$\\mathrm{ms}$）在整个问题描述中保持一致。\n5.  **无其他缺陷**：该问题并非无足轻重、比喻性的，或超出科学可验证性的范围。它是科学领域中的一个标准数值模拟任务。\n\n#### 结论\n\n该问题是**有效的**。它是计算神经科学中一个定义明确的任务，要求实现一种标准数值方法来模拟一个著名的模型。\n\n### 步骤2：解决方案设计与实现\n\n解决方案涉及使用显式欧拉方法对给定的两个常微分方程（ODEs）系统进行数值积分，同时处理指定的脉冲和重置条件。\n\n#### 数值方法：显式欧拉法\n\n显式欧拉方法基于时间$t$的状态及其变化率来近似时间$t + \\Delta t$的系统状态。对于我们的系统$(v, u)$，单个时间步长$\\Delta t$的更新规则是：\n$$\nv_{n+1} = v_n + \\Delta t \\cdot \\left( \\frac{dv}{dt} \\right)\\bigg|_{t_n} = v_n + \\Delta t \\cdot (0.04v_n^2 + 5v_n + 140 - u_n + I)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\cdot \\left( \\frac{du}{dt} \\right)\\bigg|_{t_n} = u_n + \\Delta t \\cdot a(bv_n - u_n)\n$$\n这里，$(v_n, u_n)$表示步长开始时的状态（时间$t_n$），而$(v_{n+1}, u_{n+1})$是步长结束时的暂定状态（时间$t_{n+1} = t_n + \\Delta t$）。\n\n#### 模拟算法\n\n对于每个测试用例，模拟过程如下：\n1.  **初始化**：\n    -   为特定用例设置参数$(a,b,c,d,I,T,\\Delta t)$。\n    -   在时间$t=0$时初始化状态变量：$v \\leftarrow c$和$u \\leftarrow b \\cdot c$。\n    -   初始化一个空列表 `spike_times`，用于存储脉冲发生的时间。\n\n2.  **时间步进循环**：模拟以固定的时间步长$\\Delta t$迭代总时间$T$。在每个步骤中，从当前时间$t$和状态$(v, u)$开始：\n    -   将当前电压存储为$v_{\\text{old}} \\leftarrow v$。\n    -   使用上述显式欧拉公式计算时间$t+\\Delta t$的暂定下一状态$(v_{\\text{next}}, u_{\\text{next}})$。\n    -   **脉冲检测**：检查膜电位是否从下方穿过脉冲阈值$v_{\\text{thresh}} = 30 \\, \\mathrm{mV}$。该条件是$v_{\\text{old}} < v_{\\text{thresh}}$且$v_{\\text{next}} \\ge v_{\\text{thresh}}$。\n    -   **状态更新**：\n        -   **如果检测到脉冲**：\n            1.  精确的脉冲时间$t_{\\text{spike}}$通过在点$(t, v_{\\text{old}})$和$(t+\\Delta t, v_{\\text{next}})$之间进行线性插值来估计：\n                $$\n                t_{\\text{spike}} = t + \\Delta t \\frac{v_{\\text{thresh}} - v_{\\text{old}}}{v_{\\text{next}} - v_{\\text{old}}}\n                $$\n            2.  将此$t_{\\text{spike}}$附加到`spike_times`列表中。\n            3.  应用峰后重置规则以确定下一个时间步的状态。问题指定了固定步长方法和“在该步”立即重置。这被解释为时间$t+\\Delta t$的状态变为重置状态。电压被重置为$c$，恢复变量$u$增加$d$。要增加的$u$值是在步长结束时计算出的$u_{\\text{next}}$，因为它反映了动作电位上升过程中恢复过程的累积。因此，对于下一步，我们设置：\n                $$\n                v \\leftarrow c\n                $$\n                $$\n                u \\leftarrow u_{\\text{next}} + d\n                $$\n        -   **如果未检测到脉冲**：下一步的状态就是欧拉近似的状态：\n            $$\n            v \\leftarrow v_{\\text{next}}\n            $$\n            $$\n            u \\leftarrow u_{\\text{next}}\n            $$\n\n3.  **模拟后分析**：\n    -   模拟循环完成后，检查记录的脉冲数量。\n    -   如果记录的脉冲少于6个，则无法计算五个ISI。在这种情况下，适应比定义为非数字（$\\mathrm{nan}$）。\n    -   如果记录了6个或更多脉冲，则峰间期（ISIs）计算为连续脉冲时间之间的差值：$\\text{ISI}_k = t_{\\text{spike}, k+1} - t_{\\text{spike}, k}$。\n    -   然后，适应比计算为第一个ISI与第五个ISI的比率：\n        $$\n        \\text{Ratio} = \\frac{\\text{ISI}_1}{\\text{ISI}_5}\n        $$\n\n4.  **最终输出**：计算出的比率四舍五入到6位小数。所有测试用例的结果被收集并格式化为所需的字符串`[ratio_A,ratio_B,ratio_C]`。\n\n整个过程被封装在一个Python脚本中。一个函数`simulate_neuron`实现单个测试用例的模拟和分析，而一个`solve`函数则遍历给定的测试套件，调用模拟函数并打印最终格式化的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_neuron(params):\n    \"\"\"\n    Simulates the Izhikevich neuron model for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing (a, b, c, d, I, T, dt).\n\n    Returns:\n        float: The computed adaptation ratio, or np.nan if undefined.\n    \"\"\"\n    # Unpack parameters\n    a, b, c, d, I, T, dt = params\n    v_thresh = 30.0\n\n    # Initial conditions\n    v = c\n    u = b * c\n    \n    spike_times = []\n    \n    # Use a precise number of steps to avoid floating point issues with the loop range\n    num_steps = int(round(T / dt))\n\n    for i in range(num_steps):\n        current_t = i * dt\n        v_old = v\n        \n        # Explicit Euler step: calculate derivatives at the current state (v, u)\n        dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n        du_dt = a * (b * v - u)\n        \n        # Calculate tentative state for the next time step\n        v_next = v + dv_dt * dt\n        u_next = u + du_dt * dt\n        \n        # Spike detection: check for threshold crossing from below\n        if v_old < v_thresh and v_next >= v_thresh:\n            # Estimate spike time using linear interpolation\n            if v_next - v_old > 0: # Avoid division by zero\n                t_spike = current_t + dt * (v_thresh - v_old) / (v_next - v_old)\n                spike_times.append(t_spike)\n            else: # Should not happen on upstroke, but as a safeguard\n                spike_times.append(current_t + dt)\n\n            # Apply reset rule for the state at the beginning of the next step.\n            # This is the standard way to handle resets in fixed-step methods.\n            v = c\n            u = u_next + d\n        else:\n            # No spike, so the state for the next step is the Euler-updated state\n            v = v_next\n            u = u_next\n            \n    # Calculate adaptation ratio after the simulation is complete\n    # At least 6 spikes are needed to compute 5 ISIs.\n    if len(spike_times) < 6:\n        return np.nan\n        \n    isis = np.diff(spike_times)\n    \n    # The length of isis is len(spike_times) - 1. We need at least 5 ISIs.\n    if len(isis) < 5:\n        return np.nan\n        \n    adaptation_ratio = isis[0] / isis[4]\n    \n    return adaptation_ratio\n\ndef solve():\n    \"\"\"\n    Runs the Izhikevich neuron simulation for all test cases and prints the result.\n    \"\"\"\n    # Define the regular spiking (RS) parameters\n    # (a, b, c, d)\n    rs_params = (0.02, 0.2, -65.0, 8.0)\n    \n    # Define the test cases from the problem statement\n    # Each case is a tuple: (*rs_params, I, T, dt)\n    test_cases = [\n        # Case A: happy path\n        (*rs_params, 14.0, 1000.0, 0.1),\n        # Case B: low-current boundary\n        (*rs_params, 5.0, 1000.0, 0.1),\n        # Case C: high-current and smaller step\n        (*rs_params, 30.0, 500.0, 0.05)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = simulate_neuron(case)\n        if np.isnan(ratio):\n            results.append(\"nan\")\n        else:\n            # Round the result to 6 decimal places as required\n            results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "神经元根据其对递增输入的起始发放模式进行分类，这一特性与其控制方程中的数学分岔直接相关。这项高级练习深入探讨了这一概念，要求您对I型兴奋性进行数值研究，其特点是能够以任意低的频率发放脉冲 。您将确定神经元的基电流，并验证其频率-电流曲线特有的平方根关系，这是其潜在的鞍结不变圆（SNIC）分岔的一个标志。",
            "id": "4064849",
            "problem": "您的任务是数值研究 Izhikevich 神经元模型中的 I 类兴奋性，并评估在不变圆上鞍结分岔情景下，当电流接近基电流时重复放电的起始情况。使用一个基于经过充分测试的点神经元模型并带有重置机制的二维动力学系统。膜电位 $v$ 和恢复变量 $u$ 服从以下常微分方程，其中 $I$ 是恒定的直流刺激：\n$$\n\\frac{dv}{dt} = 0.04\\,v^2 + 5\\,v + 140 - u + I,\\quad \n\\frac{du}{dt} = a\\,(b\\,v - u),\n$$\n当膜电位达到一个阈值时，应用峰电位后重置规则，这里设为 $v \\ge 30$ 毫伏：\n$$\n\\text{if } v \\ge 30\\ \\text{then}\\ \\begin{cases}\nv \\leftarrow c,\\\\\nu \\leftarrow u + d.\n\\end{cases}\n$$\n采用 I 类兴奋性参数集，该参数集表现出不变圆上鞍结分岔的起始特性，并且在阈值处具有任意低的放电速率（积分型神经元），具体参数为 $a = 0.02$, $b = -0.1$, $c = -55$, $d = 6$。使用初始条件 $v(0) = -65$ 毫伏和 $u(0) = b\\,v(0)$，固定时间步长为 $\\Delta t = 0.1$ 毫秒（即，使用一阶显式格式进行数值积分），并以赫兹为单位测量放电速率，计算方法为峰电位数量除以观测窗口时长（秒）。在此模型中，恒定刺激 $I$ 是无量纲的，所有时间单位均为毫秒；通过将峰电位计数除以观测时长（秒）来转换为赫兹（$1/\\text{second}$）。\n\n您的程序必须：\n- 通过单调搜索（例如，先确定区间再使用二分法）数值确定基底电流 $I_{rh}$，即持续重复放电（在初始暂态之后）开始时的电流。将持续放电定义为在预热暂态后的观测窗口内至少出现两次峰电位。\n- 通过对一小组略高于 $I_{rh}$ 的电流值，对 $\\log f$ 与 $\\log (I - I_{rh})$ 进行最小二乘线性拟合，估算稳态放电速率 $f$ 与电流偏移 $(I - I_{rh})$ 之间关系的指数 $p$。对于具有不变圆上鞍结分岔的 I 类兴奋性，预期的行为是 $p$ 约等于 $1/2$。\n- 验证在预热暂态之后测量时，电流为 $I = I_{rh}$ 时的放电速率为零。\n- 对于一组充分高于 $I_{rh}$ 的电流，验证放电速率随 $I$ 的增加而严格递增。\n\n单位和计算规格：\n- 使用 $\\Delta t = 0.1$ 毫秒。\n- 对于基底电流检测，模拟 $T = 12000$ 毫秒，预热时间为 $2000$ 毫秒；如果在 $(2000, 12000)$ 毫秒区间内至少有 $2$ 次峰电位，则将刺激 $I$ 分类为引起持续放电。\n- 对于频率测量，使用 $T = 20000$ 毫秒，预热时间为 $5000$ 毫秒，并以赫兹为单位计算放电速率，即峰电位数除以观测时长（秒）。\n- 峰电位阈值检测通过 $v \\ge 30$ 毫伏执行，并立即应用重置规则。\n\n测试套件：\n- 情况 1（起始点附近的指数）：使用高于基底电流的三个偏移量，具体为 $\\Delta I \\in \\{0.05, 0.1, 0.2\\}$，计算在 $I = I_{rh} + \\Delta I$ 时的放电速率，并报告拟合的指数 $p$（浮点数）。\n- 情况 2（起始点处的边界）：计算在 $I = I_{rh}$ 时的放电速率，并以赫兹为单位报告（浮点数）。\n- 情况 3（起始点上方的单调性）：使用电流 $I \\in \\{I_{rh} + 0.2,\\, I_{rh} + 0.4,\\, I_{rh} + 0.8\\}$，计算放电速率，并报告该序列是否严格递增（布尔值）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的、由逗号分隔的结果列表，顺序为 [result1,result2,result3]，其中 result1 是情况 1 的指数 $p$（浮点数），result2 是情况 2 在 $I_{rh}$ 处的放电速率（浮点数，单位为赫兹），result3 是情况 3 的单调性结果（布尔值）。例如：\"[0.5032,0.0,True]\"。",
            "solution": "该问题要求对 Izhikevich 神经元模型所描述的 I 类神经兴奋性进行数值研究。核心任务是确定基底电流（$I_{rh}$），分析放电速率（$f$）作为刺激电流（$I$）在放电起始点附近的函数，并验证不变圆上鞍结分岔（SNIC）的关键特性。\n\n神经元的动力学由一个二维常微分方程系统控制，该系统描述了膜电位 $v(t)$ 和恢复变量 $u(t)$：\n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a(bv - u)\n$$\n当膜电位达到峰值时，记录一次峰电位，并根据以下规则重置状态变量：\n$$\n\\text{if } v \\ge v_{thresh} \\quad \\text{then} \\quad \\begin{cases} v \\leftarrow c \\\\ u \\leftarrow u + d \\end{cases}\n$$\n指定的参数对应于 I 型神经元（一种在阈值处具有任意低放电速率的积分器）：\n- $a = 0.02$\n- $b = -0.1$\n- $c = -55 \\, \\text{mV}$\n- $d = 6$\n- 峰电位阈值 $v_{thresh} = 30 \\, \\text{mV}$\n\n初始条件设置为静息状态：$v(0) = -65 \\, \\text{mV}$ 和 $u(0) = b \\cdot v(0) = (-0.1) \\cdot (-65) = 6.5$。\n\n为了求解该系统，我们采用数值积分方法。问题指定了使用固定时间步长 $\\Delta t = 0.1 \\, \\text{ms}$ 的一阶显式（前向欧拉）方法。在时间步长 $n$ 处状态变量 $(v_n, u_n)$ 的离散更新规则为：\n$$\nv_{n+1} = v_n + \\Delta t \\left( 0.04 v_n^2 + 5 v_n + 140 - u_n + I \\right)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\cdot a (b v_n - u_n)\n$$\n峰电位检测和重置机制被集成到仿真循环中。在每个时间步开始时，计算导数之前，会检查膜电位 $v_n$ 是否达到阈值 $v_{thresh}$。如果 $v_n \\ge v_{thresh}$，则在时间 $t_n = n \\cdot \\Delta t$ 记录一个峰电位，并瞬时重置变量：$v_n \\leftarrow c$ 和 $u_n \\leftarrow u_n + d$。然后，仿真使用这些重置后的值继续计算下一个状态 $(v_{n+1}, u_{n+1})$。\n\n解题过程主要分为三个阶段，对应于三个测试用例。\n\n**1. 基底电流 ($I_{rh}$) 的数值确定**\n基底电流 $I_{rh}$ 是引起持续重复放电所需的最小输入电流。为了找到它，我们执行数值二分法搜索。\n- 建立一个搜索区间 $[I_{low}, I_{high}]$。基于对阈下不动点的初步稳定性分析，一个安全且稳健的区间是 $[0, 30]$。当 $I=0$ 时，系统处于一个稳定的静息状态，因此不会发生持续放电。当 $I=30$ 时，预计会发生放电。\n- 一个布尔函数 `check_firing(I)` 用于确定给定的电流 $I$ 是否产生持续放电。该函数模拟神经元 $12000 \\, \\text{ms}$，并计算在观测窗口 $(2000, 12000) \\, \\text{ms}$ 内的峰电位数量。如果计数至少为 $2$，则函数返回 true。\n- 二分算法反复将搜索区间减半，收敛到标记着无持续放电和持续放电边界的 $I_{rh}$ 值。当区间宽度小于一个很小的容差（例如 $10^{-8}$）时，搜索终止。最终区间的上界被视为 $I_{rh}$。\n\n**2. 情况 1：拟合放电速率指数 ($p$)**\n通过 SNIC 分岔实现的 I 类兴奋性预测，基底电流附近的放电速率 $f$ 与超额电流遵循平方根关系：\n$$\nf \\propto (I - I_{rh})^{1/2}\n$$\n这是一般形式 $f = k(I - I_{rh})^p$ 的一个特例，其中指数 $p$ 预期约为 $0.5$。为了验证这一点，我们对方程的对数形式进行线性回归：\n$$\n\\log(f) = p \\log(I - I_{rh}) + \\log(k)\n$$\n这是 $y = \\log(f)$ 和 $x = \\log(I - I_{rh})$ 之间的线性关系，斜率为 $p$。\n- 我们选择三个略高于基底电流的电流值：$I_i = I_{rh} + \\Delta I_i$，其中 $\\Delta I_i \\in \\{0.05, 0.1, 0.2\\}$。\n- 对于每个 $I_i$，我们模拟神经元 $T = 20000 \\, \\text{ms}$，并计算在观测窗口 $(5000, 20000) \\, \\text{ms}$ 内的峰电位数。以赫兹为单位的放电速率为 $f_i = \\text{峰电位计数} / (15.0 \\, \\text{s})$。\n- 然后，我们使用标准的最小二乘法计算通过数据点 $(\\log(\\Delta I_i), \\log(f_i))$ 的最佳拟合线的斜率 $p$。\n\n**3. 情况 2 & 3：边界和单调性分析**\n- **情况 2（起始点处的边界）：** 在分岔的精确点（$I = I_{rh}$），理论上的放电速率为零，因为放电所需时间（不变圆的周期）发散到无穷大。我们通过使用长仿真窗口（$T=20000$ ms，预热 $5000$ ms）计算 $I = I_{rh}$ 时的放电速率来检验这一点。我们预期任何初始的暂态峰电位都将停止，从而测得的稳态放电速率为 $0.0 \\, \\text{Hz}$。\n\n- **情况 3（起始点上方的单调性）：** 只要系统不处于复杂或混沌状态，神经元的放电速率应是输入电流的单调递增函数。我们通过计算一系列递增电流 $I \\in \\{I_{rh} + 0.2, I_{rh} + 0.4, I_{rh} + 0.8\\}$ 的放电速率来验证我们模型在近阈值区域的这一特性。我们检查所得的速率 $f_1, f_2, f_3$ 是否满足条件 $f_1 < f_2 < f_3$。\n\n一个 Python 脚本被设计来执行这整个协议，并按指定格式提供所需的三项结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically investigates Type I excitability in the Izhikevich neuron model.\n    \"\"\"\n    # Model parameters for Type I excitability (integrator)\n    a = 0.02\n    b = -0.1\n    c = -55.0  # mV\n    d = 6.0\n    v_thresh = 30.0  # mV\n\n    # Numerical integration parameters\n    dt = 0.1  # ms\n\n    # Initial conditions\n    v0 = -65.0  # mV\n    u0 = b * v0\n\n    memo_simulation = {}\n\n    def run_simulation(I, T_total_ms):\n        \"\"\"\n        Simulates the Izhikevich neuron for a given current and duration.\n        Caches results to avoid re-computation.\n        \"\"\"\n        sim_key = (I, T_total_ms)\n        if sim_key in memo_simulation:\n            return memo_simulation[sim_key]\n\n        v = v0\n        u = u0\n        \n        num_steps = int(T_total_ms / dt)\n        spike_times = []\n\n        for i in range(num_steps):\n            t = i * dt\n\n            if v >= v_thresh:\n                spike_times.append(t)\n                v = c\n                u = u + d\n\n            dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n            du_dt = a * (b * v - u)\n            \n            v += dt * dv_dt\n            u += dt * du_dt\n        \n        # Final check in case the last step crossed the threshold\n        if v >= v_thresh:\n            spike_times.append(T_total_ms)\n\n        result = np.array(spike_times)\n        memo_simulation[sim_key] = result\n        return result\n\n    def check_sustained_firing(I):\n        \"\"\"\n        Checks for sustained firing (>= 2 spikes) for rheobase search.\n        \"\"\"\n        T_sim = 12000  # ms\n        warmup = 2000  # ms\n        min_spikes = 2\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times > warmup) & (spike_times <= T_sim))\n        \n        return spikes_in_window >= min_spikes\n\n    def find_rheobase():\n        \"\"\"\n        Finds the rheobase current using bisection search.\n        \"\"\"\n        low_I = 0.0\n        high_I = 30.0\n        tolerance = 1e-8\n\n        # Verify bracket\n        if check_sustained_firing(low_I):\n             raise ValueError(\"Lower bound of rheobase search already fires.\")\n        if not check_sustained_firing(high_I):\n             raise ValueError(\"Upper bound of rheobase search does not fire.\")\n\n        while (high_I - low_I) > tolerance:\n            mid_I = (low_I + high_I) / 2\n            if check_sustained_firing(mid_I):\n                high_I = mid_I\n            else:\n                low_I = mid_I\n        \n        return high_I\n\n    def calculate_firing_rate(I):\n        \"\"\"\n        Calculates the steady-state firing rate in Hz.\n        \"\"\"\n        T_sim = 20000  # ms\n        warmup = 5000  # ms\n        observation_duration_s = (T_sim - warmup) / 1000.0\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times > warmup) & (spike_times <= T_sim))\n        \n        if observation_duration_s > 0:\n            return spikes_in_window / observation_duration_s\n        return 0.0\n\n    # Main logic\n    \n    # 1. Determine rheobase\n    I_rh = find_rheobase()\n\n    # 2. Case 1: Calculate exponent p\n    delta_Is = np.array([0.05, 0.1, 0.2])\n    currents_case1 = I_rh + delta_Is\n    rates_case1 = np.array([calculate_firing_rate(I) for I in currents_case1])\n    \n    # Check for non-positive rates before taking log\n    if np.any(rates_case1 <= 0):\n        # This case should not happen with the chosen delta_Is\n        # but as a safeguard:\n        result1 = np.nan\n    else:\n        log_delta_Is = np.log(delta_Is)\n        log_rates = np.log(rates_case1)\n        # Fit a line: log(rates) = p * log(delta_Is) + const\n        p_exponent = np.polyfit(log_delta_Is, log_rates, 1)[0]\n        result1 = p_exponent\n\n    # 3. Case 2: Firing rate at rheobase\n    rate_at_rh = calculate_firing_rate(I_rh)\n    result2 = rate_at_rh\n\n    # 4. Case 3: Monotonicity check\n    currents_case3 = I_rh + np.array([0.2, 0.4, 0.8])\n    rates_case3 = np.array([calculate_firing_rate(I) for I in currents_case3])\n    is_monotonic = (rates_case3[0] < rates_case3[1]) and (rates_case3[1] < rates_case3[2])\n    result3 = bool(is_monotonic)  # Ensure it's a standard Python boolean\n\n    # Final output\n    print(f\"[{result1},{result2},{result3}]\")\n\nsolve()\n```"
        }
    ]
}