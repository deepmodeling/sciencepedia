{
    "hands_on_practices": [
        {
            "introduction": "Before a neuron fires an action potential, its membrane potential typically resides at a stable equilibrium, or resting state. This exercise guides you through the fundamental process of analyzing this state within the Izhikevich model. By locating the system's fixed points at the intersection of nullclines and performing a linear stability analysis, you will determine the mathematical conditions that govern the neuron's subthreshold dynamics, a cornerstone of understanding any dynamical system in computational neuroscience. ",
            "id": "4029541",
            "problem": "Consider the Izhikevich neuron model, which describes the membrane voltage and recovery variable dynamics via the coupled Ordinary Differential Equations (ODEs)\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I, \\qquad \\frac{du}{dt} = a\\,(b\\,v - u),\n$$\nwith the usual spike-reset mechanism (not engaged at a fixed point). Use the following parameter values, typical of a regular-spiking cortical pyramidal neuron: $a = 0.02$, $b = 0.2$, and a constant external input $I = 3$. A fixed point is defined by the intersection of the voltage and recovery nullclines, given by $dv/dt = 0$ and $du/dt = 0$ respectively. Among the fixed points, focus on the lower-voltage intersection (the more hyperpolarized one).\n\nStarting from the fundamental definitions of a fixed point, nullclines, Jacobian of a dynamical system, and linear stability (real parts of eigenvalues), perform the following:\n\n- Determine the fixed point $(v^{\\ast}, u^{\\ast})$ as the intersection of the nullclines.\n- Compute the Jacobian matrix at $(v^{\\ast}, u^{\\ast})$ and derive its eigenvalues to assess local linear stability.\n- Report the maximum real part of the eigenvalues at $(v^{\\ast}, u^{\\ast})$ as a single closed-form analytic expression. Use the model’s native time unit and express the value in inverse milliseconds. Do not round your final expression.",
            "solution": "The problem requires an analysis of a fixed point of the Izhikevich neuron model. The process involves identifying the fixed point, linearizing the system dynamics around this point by computing the Jacobian matrix, and then determining the local stability by calculating the eigenvalues of the Jacobian. The final requested quantity is the maximum of the real parts of these eigenvalues.\n\nThe dynamical system is described by the coupled ordinary differential equations:\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a\\,(b\\,v - u)\n$$\nThe provided parameters are $a = 0.02$, $b = 0.2$, and the external input current is $I = 3$. The units of the variables and parameters are such that time $t$ is in milliseconds ($ms$) and voltage $v$ is in millivolts ($mV$).\n\nFirst, we find the fixed point $(v^{\\ast}, u^{\\ast})$ of the system by setting the time derivatives to zero.\nThe nullclines are given by:\n1.  Voltage nullcline ($\\frac{dv}{dt} = 0$): $0.04\\,v^{2} + 5\\,v + 140 - u + I = 0$\n2.  Recovery nullcline ($\\frac{du}{dt} = 0$): $a\\,(b\\,v - u) = 0$\n\nFrom the recovery nullcline, since $a = 0.02 \\ne 0$, we must have $b\\,v - u = 0$. This gives a linear relationship between $u$ and $v$ at the fixed point:\n$$\nu = b\\,v\n$$\nWe substitute this expression for $u$ into the voltage nullcline equation:\n$$\n0.04\\,v^{2} + 5\\,v + 140 - (b\\,v) + I = 0\n$$\n$$\n0.04\\,v^{2} + (5 - b)v + (140 + I) = 0\n$$\nNow, we substitute the given values for the parameters $b = 0.2$ and $I = 3$:\n$$\n0.04\\,v^{2} + (5 - 0.2)v + (140 + 3) = 0\n$$\n$$\n0.04\\,v^{2} + 4.8\\,v + 143 = 0\n$$\nThis is a quadratic equation for the voltage $v$ at the fixed point(s). We solve for $v$ using the quadratic formula, $v = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$, with $A=0.04$, $B=4.8$, and $C=143$:\n$$\nv = \\frac{-4.8 \\pm \\sqrt{(4.8)^{2} - 4(0.04)(143)}}{2(0.04)}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{23.04 - 22.88}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{0.16}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm 0.4}{0.08}\n$$\nThis yields two possible values for $v$:\n$$\nv_{1} = \\frac{-4.8 + 0.4}{0.08} = \\frac{-4.4}{0.08} = -55\n$$\n$$\nv_{2} = \\frac{-4.8 - 0.4}{0.08} = \\frac{-5.2}{0.08} = -65\n$$\nThe problem specifies to use the \"lower-voltage intersection (the more hyperpolarized one)\", which corresponds to the more negative value. Thus, we select $v^{\\ast} = -65$.\n\nNow, we find the corresponding value of the recovery variable $u^{\\ast}$ using the relation $u = b\\,v$:\n$$\nu^{\\ast} = b\\,v^{\\ast} = 0.2 \\times (-65) = -13\n$$\nThe relevant fixed point is $(v^{\\ast}, u^{\\ast}) = (-65, -13)$.\n\nNext, we compute the Jacobian matrix of the system to analyze its stability. The system can be written as $\\frac{d\\mathbf{x}}{dt} = \\mathbf{F}(\\mathbf{x})$, where $\\mathbf{x} = [v, u]^T$ and $\\mathbf{F}(\\mathbf{x}) = [f(v,u), g(v,u)]^T$ with:\n$$\nf(v, u) = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\ng(v, u) = a\\,(b\\,v - u) = ab\\,v - au\n$$\nThe Jacobian matrix $J$ is given by:\n$$\nJ = \\begin{pmatrix} \\frac{\\partial f}{\\partial v} & \\frac{\\partial f}{\\partial u} \\\\ \\frac{\\partial g}{\\partial v} & \\frac{\\partial g}{\\partial u} \\end{pmatrix} = \\begin{pmatrix} 0.08\\,v + 5 & -1 \\\\ ab & -a \\end{pmatrix}\n$$\nWe evaluate this matrix at the fixed point $(v^{\\ast}, u^{\\ast}) = (-65, -13)$, substituting the parameter values $a = 0.02$ and $b = 0.2$:\n$$\nJ^{\\ast} = J(-65, -13) = \\begin{pmatrix} 0.08(-65) + 5 & -1 \\\\ (0.02)(0.2) & -0.02 \\end{pmatrix}\n$$\n$$\nJ^{\\ast} = \\begin{pmatrix} -5.2 + 5 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix} = \\begin{pmatrix} -0.2 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix}\n$$\nThe eigenvalues $\\lambda$ of the Jacobian matrix $J^{\\ast}$ determine the local stability. They are the roots of the characteristic equation $\\det(J^{\\ast} - \\lambda I) = 0$, where $I$ is the identity matrix. The characteristic equation for a $2 \\times 2$ matrix is $\\lambda^{2} - \\text{Tr}(J^{\\ast})\\lambda + \\det(J^{\\ast}) = 0$.\n\nThe trace of $J^{\\ast}$ is:\n$$\n\\text{Tr}(J^{\\ast}) = -0.2 + (-0.02) = -0.22\n$$\nThe determinant of $J^{\\ast}$ is:\n$$\n\\det(J^{\\ast}) = (-0.2)(-0.02) - (-1)(0.004) = 0.004 + 0.004 = 0.008\n$$\nThe characteristic equation is therefore:\n$$\n\\lambda^{2} - (-0.22)\\lambda + 0.008 = 0\n$$\n$$\n\\lambda^{2} + 0.22\\lambda + 0.008 = 0\n$$\nWe solve for the eigenvalues $\\lambda$ using the quadratic formula:\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{(0.22)^{2} - 4(1)(0.008)}}{2(1)}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0484 - 0.032}}{2}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0164}}{2}\n$$\nThe discriminant $0.0164$ is positive, so the two eigenvalues are real. The real parts of the eigenvalues are the eigenvalues themselves. The two eigenvalues are:\n$$\n\\lambda_{1} = \\frac{-0.22 + \\sqrt{0.0164}}{2} \\quad \\text{and} \\quad \\lambda_{2} = \\frac{-0.22 - \\sqrt{0.0164}}{2}\n$$\nThe problem asks for the maximum real part of the eigenvalues. This is clearly $\\lambda_{1}$. To provide a closed-form analytic expression, we simplify the term under the square root:\n$$\n\\sqrt{0.0164} = \\sqrt{\\frac{164}{10000}} = \\frac{\\sqrt{4 \\times 41}}{100} = \\frac{2\\sqrt{41}}{100} = \\frac{\\sqrt{41}}{50}\n$$\nSubstituting this back into the expression for $\\lambda_1$:\n$$\n\\lambda_{\\max} = \\frac{1}{2}\\left(-0.22 + \\frac{\\sqrt{41}}{50}\\right) = \\frac{1}{2}\\left(-\\frac{22}{100} + \\frac{2\\sqrt{41}}{100}\\right) = \\frac{1}{2}\\left(\\frac{-22 + 2\\sqrt{41}}{100}\\right) = \\frac{-11 + \\sqrt{41}}{100}\n$$\nThe value of $\\sqrt{41}$ is approximately $6.4$, so $-11 + \\sqrt{41}$ is negative. This confirms that the fixed point is a stable node, as expected for the resting state of a neuron model. The maximum real part of the eigenvalues is $\\frac{-11 + \\sqrt{41}}{100}$. The time unit of the model is milliseconds ($ms$), so the eigenvalue has units of $ms^{-1}$.",
            "answer": "$$\\boxed{\\frac{-11 + \\sqrt{41}}{100}}$$"
        },
        {
            "introduction": "A neuron's defining characteristic is its ability to generate action potentials in response to sufficient input. This practice moves from subthreshold analysis to the dynamics of spiking, focusing on the critical relationship between input current and firing rate (the $f-I$ curve). You will numerically determine the rheobase—the minimum current required to elicit repetitive firing—and test a key theoretical prediction for Type I excitability, directly linking your simulation results to the bifurcation theory of neural dynamics. ",
            "id": "4064849",
            "problem": "You are tasked with numerically investigating Type I excitability in the Izhikevich neuron model and assessing the onset of repetitive firing near rheobase for a saddle-node on invariant circle scenario. Use a two-dimensional dynamical system based on a well-tested point-neuron model with a reset mechanism. The membrane potential $v$ and recovery variable $u$ obey ordinary differential equations with a constant direct-current stimulus $I$:\n$$\n\\frac{dv}{dt} = 0.04\\,v^2 + 5\\,v + 140 - u + I,\\quad \n\\frac{du}{dt} = a\\,(b\\,v - u),\n$$\nwith an after-spike reset rule applied whenever the membrane potential reaches a threshold, taken here as $v \\ge 30$ millivolts:\n$$\n\\text{if } v \\ge 30\\ \\text{then}\\ \\begin{cases}\nv \\leftarrow c,\\\\\nu \\leftarrow u + d.\n\\end{cases}\n$$\nAdopt the Type I excitability parameter set that exhibits a saddle-node on invariant circle onset and an arbitrarily low firing rate at threshold (an integrator-type neuron), specifically $a = 0.02$, $b = -0.1$, $c = -55$, $d = 6$. Use initial conditions $v(0) = -65$ millivolts and $u(0) = b\\,v(0)$, a fixed time step of $\\Delta t = 0.1$ milliseconds (i.e., numerical integration with a first-order explicit scheme), and measure firing rates in Hertz, computed as the number of spikes divided by the observation window length in seconds. The constant stimulus $I$ is dimensionless in this model, and all time is in milliseconds; convert to Hertz as $1/\\text{second}$ by dividing the spike count by the observation duration in seconds.\n\nYour program must:\n- Determine the rheobase current $I_{rh}$ numerically via a monotonic search (for example, bracket followed by bisection), where sustained repetitive firing (after an initial transient) begins. Define sustained firing as the presence of at least two spikes during an observation window following a warm-up transient.\n- Estimate the exponent $p$ of the relationship between the steady firing rate $f$ and the current offset $(I - I_{rh})$ near the onset, by performing a least-squares linear fit of $\\log f$ against $\\log (I - I_{rh})$ using a small set of currents just above $I_{rh}$. The expected behavior for Type I excitability with a saddle-node on invariant circle is that $p$ is approximately $1/2$.\n- Verify that the firing rate at $I = I_{rh}$ is zero when measured after the warm-up transient.\n- Verify that the firing rate is strictly increasing with $I$ for a set of currents sufficiently above $I_{rh}$.\n\nUnits and computational specifications:\n- Use $\\Delta t = 0.1$ milliseconds.\n- For rheobase detection, simulate for $T = 12000$ milliseconds with a warm-up of $2000$ milliseconds; classify a stimulus $I$ as eliciting sustained firing if there are at least $2$ spikes in the interval $(2000, 12000)$ milliseconds.\n- For frequency measurement, use $T = 20000$ milliseconds with a warm-up of $5000$ milliseconds, and compute the firing rate in Hertz as spikes divided by observation duration in seconds.\n- The spike threshold detection is performed via $v \\ge 30$ millivolts, immediately applying the reset rule.\n\nTest suite:\n- Case 1 (near-onset exponent): Use three offsets above rheobase, specifically $\\Delta I \\in \\{0.05, 0.1, 0.2\\}$, compute the firing rates at $I = I_{rh} + \\Delta I$, and report the fitted exponent $p$ as a float.\n- Case 2 (boundary at onset): Compute the firing rate at $I = I_{rh}$ and report it as a float in Hertz.\n- Case 3 (monotonicity above onset): Use currents $I \\in \\{I_{rh} + 0.2,\\, I_{rh} + 0.4,\\, I_{rh} + 0.8\\}$, compute firing rates, and report whether the sequence is strictly increasing as a boolean.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [result1,result2,result3], where result1 is the exponent $p$ from Case 1 (float), result2 is the firing rate at $I_{rh}$ from Case 2 (float, in Hertz), and result3 is the monotonicity result from Case 3 (boolean). For example: \"[0.5032,0.0,True]\".",
            "solution": "The problem requires a numerical investigation of Type I neural excitability as described by the Izhikevich neuron model. The central tasks are to determine the rheobase current ($I_{rh}$), analyze the firing rate ($f$) a function of the stimulus current ($I$) near the onset of firing, and verify key properties characteristic of a saddle-node on invariant circle (SNIC) bifurcation.\n\nThe dynamics of the neuron are governed by a two-dimensional system of ordinary differential equations for the membrane potential, $v(t)$, and a recovery variable, $u(t)$:\n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a(bv - u)\n$$\nWhen the membrane potential reaches a peak, a spike is registered, and the state variables are reset according to the rule:\n$$\n\\text{if } v \\ge v_{thresh} \\quad \\text{then} \\quad \\begin{cases} v \\leftarrow c \\\\ u \\leftarrow u + d \\end{cases}\n$$\nThe parameters specified correspond to a Type I neuron (an integrator with an arbitrarily low firing rate at threshold):\n- $a = 0.02$\n- $b = -0.1$\n- $c = -55 \\, \\text{mV}$\n- $d = 6$\n- Spike threshold $v_{thresh} = 30 \\, \\text{mV}$\n\nThe initial conditions are set to a resting state: $v(0) = -65 \\, \\text{mV}$ and $u(0) = b \\cdot v(0) = (-0.1) \\cdot (-65) = 6.5$.\n\nTo solve the system, we employ a numerical integration scheme. A first-order explicit (Forward Euler) method with a fixed time step of $\\Delta t = 0.1 \\, \\text{ms}$ is specified. The discrete update rules for the state variables $(v_n, u_n)$ at time step $n$ are:\n$$\nv_{n+1} = v_n + \\Delta t \\left( 0.04 v_n^2 + 5 v_n + 140 - u_n + I \\right)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\cdot a (b v_n - u_n)\n$$\nThe spike detection and reset mechanism is integrated into the simulation loop. At the beginning of each time step, before calculating the derivatives, the membrane potential $v_n$ is checked against the threshold $v_{thresh}$. If $v_n \\ge v_{thresh}$, a spike is recorded at time $t_n = n \\cdot \\Delta t$, and the variables are instantaneously reset: $v_n \\leftarrow c$ and $u_n \\leftarrow u_n + d$. The simulation then proceeds to calculate the next state $(v_{n+1}, u_{n+1})$ using these reset values.\n\nThe solution proceeds in three main stages corresponding to the test cases.\n\n**1. Numerical Determination of the Rheobase Current ($I_{rh}$)**\nThe rheobase, $I_{rh}$, is the minimum input current required to induce sustained repetitive firing. To find it, we perform a numerical bisection search.\n- A search interval $[I_{low}, I_{high}]$ is established. Based on a preliminary stability analysis of the subthreshold fixed points, a safe and robust interval is $[0, 30]$. For $I=0$, the system has a stable resting state, so no sustained firing occurs. For $I=30$, firing is expected.\n- A boolean function, `check_firing(I)`, determines if a given current $I$ produces sustained firing. This function simulates the neuron for $12000 \\, \\text{ms}$ and counts the number of spikes within the observation window $(2000, 12000) \\, \\text{ms}$. If this count is at least $2$, the function returns true.\n- The bisection algorithm repeatedly halves the search interval, converging on the value of $I_{rh}$ that marks the boundary between no sustained firing and sustained firing. The search terminates when the interval width is below a small tolerance (e.g., $10^{-8}$). The upper bound of the final interval is taken as $I_{rh}$.\n\n**2. Case 1: Fitting the Firing Rate Exponent ($p$)**\nType I excitability via a SNIC bifurcation predicts that the firing rate $f$ near rheobase follows a square-root relationship with the excess current:\n$$\nf \\propto (I - I_{rh})^{1/2}\n$$\nThis is a specific instance of the more general form $f = k(I - I_{rh})^p$, where the exponent $p$ is expected to be approximately $0.5$. To verify this, we perform a linear regression on the logarithmic form of the equation:\n$$\n\\log(f) = p \\log(I - I_{rh}) + \\log(k)\n$$\nThis is a linear relationship between $y = \\log(f)$ and $x = \\log(I - I_{rh})$, with slope $p$.\n- We select three currents slightly above rheobase: $I_i = I_{rh} + \\Delta I_i$, with $\\Delta I_i \\in \\{0.05, 0.1, 0.2\\}$.\n- For each $I_i$, we simulate the neuron for $T = 20000 \\, \\text{ms}$ and count the spikes in the observation window $(5000, 20000) \\, \\text{ms}$. The firing rate in Hertz is $f_i = \\text{spike count} / (15.0 \\, \\text{s})$.\n- We then compute the slope $p$ of the best-fit line through the data points $(\\log(\\Delta I_i), \\log(f_i))$ using a standard least-squares method.\n\n**3. Case 2 & 3: Boundary and Monotonicity Analysis**\n- **Case 2 (Boundary at Onset):** The theoretical firing rate at the exact point of bifurcation ($I = I_{rh}$) is zero, as the time to fire (the period of the invariant circle) diverges to infinity. We test this by computing the firing rate for $I = I_{rh}$ using the long simulation window ($T=20000$ ms, warm-up $5000$ ms). We expect any initial transient spikes to cease, resulting in a measured steady-state firing rate of $0.0 \\, \\text{Hz}$.\n\n- **Case 3 (Monotonicity Above Onset):** The firing rate of a neuron should be a monotonically increasing function of the input current, provided the system is not in a complex or chaotic regime. We verify this property for our model in the near-threshold region by computing the firing rates for a sequence of increasing currents: $I \\in \\{I_{rh} + 0.2, I_{rh} + 0.4, I_{rh} + 0.8\\}$. We check if the resulting rates, $f_1, f_2, f_3$, satisfy the condition $f_1 < f_2 < f_3$.\n\nA Python script is designed to execute this entire protocol, providing the three required results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically investigates Type I excitability in the Izhikevich neuron model.\n    \"\"\"\n    # Model parameters for Type I excitability (integrator)\n    a = 0.02\n    b = -0.1\n    c = -55.0  # mV\n    d = 6.0\n    v_thresh = 30.0  # mV\n\n    # Numerical integration parameters\n    dt = 0.1  # ms\n\n    # Initial conditions\n    v0 = -65.0  # mV\n    u0 = b * v0\n\n    memo_simulation = {}\n\n    def run_simulation(I, T_total_ms):\n        \"\"\"\n        Simulates the Izhikevich neuron for a given current and duration.\n        Caches results to avoid re-computation.\n        \"\"\"\n        sim_key = (I, T_total_ms)\n        if sim_key in memo_simulation:\n            return memo_simulation[sim_key]\n\n        v = v0\n        u = u0\n        \n        num_steps = int(T_total_ms / dt)\n        spike_times = []\n\n        for i in range(num_steps):\n            t = i * dt\n\n            if v >= v_thresh:\n                spike_times.append(t)\n                v = c\n                u = u + d\n\n            dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n            du_dt = a * (b * v - u)\n            \n            v += dt * dv_dt\n            u += dt * du_dt\n        \n        # Final check in case the last step crossed the threshold\n        if v >= v_thresh:\n            spike_times.append(T_total_ms)\n\n        result = np.array(spike_times)\n        memo_simulation[sim_key] = result\n        return result\n\n    def check_sustained_firing(I):\n        \"\"\"\n        Checks for sustained firing (>= 2 spikes) for rheobase search.\n        \"\"\"\n        T_sim = 12000  # ms\n        warmup = 2000  # ms\n        min_spikes = 2\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times > warmup)  (spike_times = T_sim))\n        \n        return spikes_in_window >= min_spikes\n\n    def find_rheobase():\n        \"\"\"\n        Finds the rheobase current using bisection search.\n        \"\"\"\n        low_I = 0.0\n        high_I = 30.0\n        tolerance = 1e-8\n\n        # Verify bracket\n        if check_sustained_firing(low_I):\n             raise ValueError(\"Lower bound of rheobase search already fires.\")\n        if not check_sustained_firing(high_I):\n             raise ValueError(\"Upper bound of rheobase search does not fire.\")\n\n        while (high_I - low_I) > tolerance:\n            mid_I = (low_I + high_I) / 2\n            if check_sustained_firing(mid_I):\n                high_I = mid_I\n            else:\n                low_I = mid_I\n        \n        return high_I\n\n    def calculate_firing_rate(I):\n        \"\"\"\n        Calculates the steady-state firing rate in Hz.\n        \"\"\"\n        T_sim = 20000  # ms\n        warmup = 5000  # ms\n        observation_duration_s = (T_sim - warmup) / 1000.0\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times > warmup)  (spike_times = T_sim))\n        \n        if observation_duration_s > 0:\n            return spikes_in_window / observation_duration_s\n        return 0.0\n\n    # Main logic\n    \n    # 1. Determine rheobase\n    I_rh = find_rheobase()\n\n    # 2. Case 1: Calculate exponent p\n    delta_Is = np.array([0.05, 0.1, 0.2])\n    currents_case1 = I_rh + delta_Is\n    rates_case1 = np.array([calculate_firing_rate(I) for I in currents_case1])\n    \n    # Check for non-positive rates before taking log\n    if np.any(rates_case1 = 0):\n        # This case should not happen with the chosen delta_Is\n        # but as a safeguard:\n        result1 = np.nan\n    else:\n        log_delta_Is = np.log(delta_Is)\n        log_rates = np.log(rates_case1)\n        # Fit a line: log(rates) = p * log(delta_Is) + const\n        p_exponent = np.polyfit(log_delta_Is, log_rates, 1)[0]\n        result1 = p_exponent\n\n    # 3. Case 2: Firing rate at rheobase\n    rate_at_rh = calculate_firing_rate(I_rh)\n    result2 = rate_at_rh\n\n    # 4. Case 3: Monotonicity check\n    currents_case3 = I_rh + np.array([0.2, 0.4, 0.8])\n    rates_case3 = np.array([calculate_firing_rate(I) for I in currents_case3])\n    is_monotonic = (rates_case3[0]  rates_case3[1]) and (rates_case3[1]  rates_case3[2])\n    result3 = bool(is_monotonic)  # Ensure it's a standard Python boolean\n\n    # Final output\n    print(f\"[{result1},{result2},{result3}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Computational models are powerful tools, but their results are only as reliable as the numerical methods used to generate them. This final practice tackles the crucial issue of numerical accuracy by asking you to systematically investigate how the simulation time step, $\\Delta t$, influences the model's predicted firing rate. By implementing a convergence diagnostic based on first principles of numerical analysis, you will develop the essential skill of distinguishing genuine model behavior from artifacts of the simulation method. ",
            "id": "4029521",
            "problem": "Consider the Izhikevich neuron model, which describes the membrane potential and recovery variable dynamics via ordinary differential equations (ODEs). The model is defined by the system\n$$\n\\frac{dv}{dt} = 0.04 v^2 + 5 v + 140 - u + I,\\quad \\frac{du}{dt} = a\\,(b\\,v - u),\n$$\ntogether with the after-spike resetting rule applied whenever the membrane potential crosses the spike threshold,\n$$\n\\text{if } v \\ge 30 \\text{ then } v \\leftarrow c,\\quad u \\leftarrow u + d.\n$$\nUse the standard \"regular spiking\" parameters $a=0.02$, $b=0.2$, $c=-65$, $d=8$, and initialize the state at $v(0)=c$, $u(0)=b\\,c$. Assume the dynamics are integrated using the explicit first-order forward Euler method with a fixed time step $ \\Delta t $ in milliseconds, and that the spike threshold is checked after each Euler update. The membrane potential $v$ and the recovery variable $u$ are in model units (dimensionless). The input current $I$ is constant (dimensionless model units).\n\nThe firing rate as a function of input current (the $f$–$I$ curve) is estimated by counting spikes over a finite simulation duration $T$ and dividing by the duration in seconds. Explicitly, if $N_{\\text{spike}}$ spikes occur over $T$ milliseconds, the firing rate $f$ must be reported in Hertz (Hz) as\n$$\nf = \\frac{N_{\\text{spike}}}{T/1000}.\n$$\n\nYour task is to compute the effect of numerical discretization on $f$–$I$ curve estimation and to design a convergence diagnostic that distinguishes numerical artifacts from true model behavior. Proceed from first principles of numerical integration and ODE error analysis, without using any specialized shortcut formulas beyond the Izhikevich model itself and fundamental properties of the explicit Euler method.\n\nImplement a program that:\n- Simulates the Izhikevich model using explicit Euler with time steps $\\Delta t \\in \\{1.0, 0.5, 0.25, 0.125\\}$ milliseconds.\n- For each specified test case, computes firing rates for a set of constant currents $I$ at all specified $\\Delta t$ values over a simulation duration $T$ milliseconds, and then evaluates a convergence diagnostic for each $I$:\n  1. Define the sequence of firing rates $f_{\\Delta t}$, $f_{\\Delta t/2}$, $f_{\\Delta t/4}$, $f_{\\Delta t/8}$.\n  2. Define successive absolute differences $D_1 = |f_{\\Delta t} - f_{\\Delta t/2}|$, $D_2 = |f_{\\Delta t/2} - f_{\\Delta t/4}|$, $D_3 = |f_{\\Delta t/4} - f_{\\Delta t/8}|$.\n  3. Define the convergence ratio\n     $$\n     R = \\frac{D_1}{D_2},\n     $$\n     which is expected to be near $2$ for a first-order method when the solution is smooth in the relevant sense.\n  4. Declare the diagnostic to pass for a current $I$ if all of the following are satisfied:\n     - Monotone refinement of differences: $D_1 \\ge D_2 \\ge D_3$.\n     - Asymptotic ratio consistency: $R$ lies within the interval $[1.25, 3.0]$ whenever $D_2  0$; if $D_2 = 0$ and $D_1 = 0$, treat this condition as satisfied.\n     - Fine-scale stability: $D_3 \\le \\epsilon$, with $\\epsilon = 1.0$ Hz.\n     Additionally, if all four firing rates are exactly zero for a given $I$ (no spiking across all discretizations), treat the diagnostic as trivially satisfied for that $I$.\n  5. The test case result is the boolean indicating whether the diagnostic passes for all currents in that case.\n\nScientific realism requirements:\n- Use $T = 2000$ milliseconds for all simulations, and report firing rates in Hertz (Hz).\n- The explicit Euler method must be used to approximate the ODEs, and spikes must be detected by thresholding $v$ at $30$ after each Euler update, applying the reset instantaneously when a spike is detected. This event handling should be identical across all $\\Delta t$ values.\n\nTest suite:\n- Case $1$ (general \"happy path\"): $I \\in \\{10, 14, 20, 30\\}$, $T = 2000$ ms, base step $\\Delta t_0 = 1.0$ ms.\n- Case $2$ (near rheobase boundary): $I \\in \\{6, 8, 10\\}$, $T = 2000$ ms, base step $\\Delta t_0 = 1.0$ ms.\n- Case $3$ (high-input regime): $I \\in \\{40, 60\\}$, $T = 2000$ ms, base step $\\Delta t_0 = 1.0$ ms.\n- Case $4$ (subthreshold edge): $I \\in \\{0, 2\\}$, $T = 2000$ ms, base step $\\Delta t_0 = 1.0$ ms.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list of booleans (one per test case), enclosed in square brackets, for example $[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$. Each boolean indicates whether the convergence diagnostic passes for all currents in the corresponding test case. This line must be the only output produced by the program.",
            "solution": "The problem requires the implementation and analysis of the Izhikevich neuron model, a system of ordinary differential equations (ODEs) with a discontinuous reset condition, to assess the impact of numerical discretization on the calculated firing rate. The analysis is performed using a custom convergence diagnostic based on fundamental principles of numerical error analysis for the explicit first-order forward Euler method.\n\nThe Izhikevich model is defined by the following system for the membrane potential $v(t)$ and the recovery variable $u(t)$:\n$$\n\\frac{dv}{dt} = 0.04 v^2 + 5 v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a(b v - u)\n$$\nwhere $I$ is a constant input current. A spike is registered and the state variables are reset when $v$ reaches a threshold of $30$:\n$$\n\\text{if } v \\ge 30, \\text{ then } v \\leftarrow c \\text{ and } u \\leftarrow u + d.\n$$\nThe problem specifies the use of parameters for \"regular spiking\" neurons: $a = 0.02$, $b = 0.2$, $c = -65$, and $d = 8$. The initial conditions are set to a resting state, $v(0) = c = -65$ and $u(0) = b \\cdot c = 0.2 \\cdot (-65) = -13$.\n\nThe solution to this ODE system is approximated using the explicit first-order forward Euler method. Given the state $(v_n, u_n)$ at time $t_n$, the state $(v_{n+1}, u_{n+1})$ at time $t_{n+1} = t_n + \\Delta t$ is computed as:\n$$\nv_{n+1} = v_n + \\Delta t \\left( 0.04 v_n^2 + 5 v_n + 140 - u_n + I \\right)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\left( a(b v_n - u_n) \\right)\n$$\nIt is crucial that the derivatives for both $v$ and $u$ are evaluated at the same time point $t_n$, using the values $v_n$ and $u_n$. After each Euler step, the new potential $v_{n+1}$ is checked against the spike threshold. If $v_{n+1} \\ge 30$, a spike is counted, and the reset conditions are applied instantaneously to the just-computed state: $v_{n+1}$ is set to $c$, and $u_{n+1}$ is incremented by $d$.\n\nThe core of the problem is to evaluate a convergence diagnostic for the firing rate, $f$, which is a functional of the solution trajectory. The firing rate is calculated as $f = N_{\\text{spike}} / (T/1000)$, where $N_{\\text{spike}}$ is the total number of spikes over a simulation duration of $T = 2000$ milliseconds. This calculation converts the rate to Hertz (Hz). The diagnostic assesses how the computed rate $f$ changes as the time step $\\Delta t$ is refined. Simulations are run for a sequence of time steps $\\Delta t \\in \\{1.0, 0.5, 0.25, 0.125\\}$ ms. Let the corresponding firing rates be $f_1, f_2, f_3, f_4$.\n\nThe diagnostic consists of three conditions grounded in the theory of numerical integration:\n\n1.  **Monotone Refinement of Differences**: $D_1 \\ge D_2 \\ge D_3$, where $D_1 = |f_1 - f_2|$, $D_2 = |f_2 - f_3|$, and $D_3 = |f_3 - f_4|$. This condition checks that successive refinements of $\\Delta t$ lead to progressively smaller changes in the computed firing rate. This indicates well-behaved convergence. A violation, such as $D_1  D_2$, can suggest oscillatory convergence or that the coarser time steps are in a region of numerical instability.\n\n2.  **Asymptotic Ratio Consistency**: The ratio of successive differences, $R = D_1 / D_2$, is expected to approach $2^p$ for a method of order $p$. For the first-order Euler method ($p=1$), this ratio should be approximately $2$. The diagnostic requires $R \\in [1.25, 3.0]$ when $D_2  0$. This interval provides a reasonable tolerance for deviations from the ideal asymptotic behavior, which are expected in a system with discontinuities like spike resets. If $D_2=0$ and $D_1=0$, the rates have converged, so this condition is considered satisfied.\n\n3.  **Fine-scale Stability**: The absolute difference at the finest scale, $D_3$, must be below a tolerance $\\epsilon = 1.0$ Hz. This ensures that the computed rate is sufficiently close to its converged value and that further refinements of $\\Delta t$ would likely yield only minor changes.\n\nA special case is handled where no spikes are detected for any of the four time steps. In this subthreshold regime, all four firing rates are $0$, and the diagnostic is considered trivially passed. For a given test case, the final result is `True` only if this diagnostic passes for every input current $I$ in that case.\n\nThe implementation consists of three main parts. First, a function `simulate_izhikevich` that executes the simulation for a given set of parameters ($I$, $\\Delta t$, etc.) and returns the spike count. Second, a function `evaluate_diagnostic` that, for a given current $I$, runs the simulation for all four $\\Delta t$ values, computes the firing rates, and evaluates the three conditions of the diagnostic. Finally, a main `solve` function iterates through the predefined test cases, calls the diagnostic evaluation for each current within a case, and aggregates the boolean results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    # Model parameters for regular spiking (RS)\n    a = 0.02\n    b = 0.2\n    c = -65.0\n    d = 8.0\n\n    # Simulation and diagnostic parameters\n    T = 2000.0  # ms\n    time_steps = [1.0, 0.5, 0.25, 0.125] # ms\n    epsilon = 1.0 # Hz\n\n    # Test suite\n    test_cases = [\n        # Case 1: general \"happy path\"\n        {'I_values': [10.0, 14.0, 20.0, 30.0]},\n        # Case 2: near rheobase boundary\n        {'I_values': [6.0, 8.0, 10.0]},\n        # Case 3: high-input regime\n        {'I_values': [40.0, 60.0]},\n        # Case 4: subthreshold edge\n        {'I_values': [0.0, 2.0]},\n    ]\n\n    def simulate_izhikevich(I_val, dt):\n        \"\"\"\n        Simulates the Izhikevich neuron model using forward Euler.\n        \n        Args:\n            I_val (float): Input current.\n            dt (float): Time step in ms.\n        \n        Returns:\n            int: Number of spikes.\n        \"\"\"\n        v = c\n        u = b * c\n        spike_count = 0\n        \n        num_steps = int(T / dt)\n        \n        for _ in range(num_steps):\n            # Forward Euler update\n            v_old = v\n            u_old = u\n            \n            dv = (0.04 * v_old**2 + 5.0 * v_old + 140.0 - u_old + I_val)\n            du = a * (b * v_old - u_old)\n            \n            v = v_old + dt * dv\n            u = u_old + dt * du\n            \n            # Spike detection and reset\n            if v >= 30.0:\n                spike_count += 1\n                v = c\n                u = u + d\n                \n        return spike_count\n\n    def evaluate_diagnostic(I_val):\n        \"\"\"\n        Calculates firing rates and evaluates the convergence diagnostic for a given current.\n        \n        Args:\n            I_val (float): Input current.\n            \n        Returns:\n            bool: True if the diagnostic passes, False otherwise.\n        \"\"\"\n        firing_rates = []\n        for dt in time_steps:\n            n_spikes = simulate_izhikevich(I_val, dt)\n            rate = n_spikes / (T / 1000.0)\n            firing_rates.append(rate)\n\n        # Trivial pass condition: no spikes at any resolution\n        if all(rate == 0 for rate in firing_rates):\n            return True\n\n        # Define successive absolute differences\n        D1 = abs(firing_rates[0] - firing_rates[1])\n        D2 = abs(firing_rates[1] - firing_rates[2])\n        D3 = abs(firing_rates[2] - firing_rates[3])\n\n        # 1. Monotone refinement of differences\n        cond_monotonicity = (D1 >= D2) and (D2 >= D3)\n\n        # 2. Asymptotic ratio consistency\n        cond_ratio = False\n        if D2 > 0:\n            R = D1 / D2\n            if 1.25 = R = 3.0:\n                cond_ratio = True\n        elif D1 == 0:  # and D2 is implicitly 0\n            cond_ratio = True\n        \n        # 3. Fine-scale stability\n        cond_stability = (D3 = epsilon)\n\n        return cond_monotonicity and cond_ratio and cond_stability\n\n    results = []\n    for case in test_cases:\n        case_passed = True\n        for I in case['I_values']:\n            if not evaluate_diagnostic(I):\n                case_passed = False\n                break\n        results.append(case_passed)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}