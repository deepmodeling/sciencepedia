{
    "hands_on_practices": [
        {
            "introduction": "在使用任何测量工具之前，我们必须了解其精度。脉冲触发平均（Spike-Triggered Average, STA）是一种估计量，其准确性取决于数据量（即脉冲数量）。本练习深入探讨 STA 的统计基础，通过推导其方差并构建置信区间，您将定量地理解该估计量的可靠性如何随着收集到的脉冲数量的增加而提高。这项实践巩固了感受野分析的理论基础，并提供了评估经验性 STA 测量质量的工具。",
            "id": "4060196",
            "problem": "考虑一个由时间白噪声、零均值、独立高斯刺激驱动的神经元，其每个分量的方差为 $\\,\\sigma^{2}\\,$。令 $\\,\\mathbf{s}_{t}\\in\\mathbb{R}^{d}\\,$ 表示在离散时间 $\\,t\\,$ 的刺激向量，并假设在时间 $\\,t_{1},t_{2},\\dots,t_{N}\\,$ 记录到脉冲。将固定延迟 $\\,\\tau\\,$ 下的脉冲触发平均 (STA) 定义为脉冲之前的刺激向量的经验均值：\n$$\n\\widehat{\\mathbf{m}}(\\tau)\\;=\\;\\frac{1}{N}\\sum_{j=1}^{N}\\mathbf{s}_{t_{j}-\\tau}.\n$$\n关注任一单个 STA 分量 $\\,\\widehat{m}_{i}(\\tau)\\,$，它是第 $\\,i\\,$ 个刺激坐标在 $\\,N\\,$ 个脉冲触发样本上的平均值。假设脉冲触发样本 $\\,\\{s_{t_{j}-\\tau,i}\\}_{j=1}^{N}\\,$ 是独立同分布的，其均值为 $\\,\\mu_{i}(\\tau)\\,$，方差为 $\\,\\sigma^{2}\\,$，并进一步假设每个样本都是亚高斯的，其代理方差参数为 $\\,\\sigma^{2}\\,$（即，其矩生成函数的上界为一个中心化高斯分布的矩生成函数，该高斯分布的方差为 $\\,\\sigma^{2}\\,$）。\n\n从这些前提出发，不使用任何特殊的简化公式，推导：\n- STA 分量 $\\,\\widehat{m}_{i}(\\tau)\\,$ 的方差，表示为脉冲计数 $\\,N\\,$ 和刺激方差 $\\,\\sigma^{2}\\,$ 的函数。\n- 一个双边置信区间的半宽度 $\\,r(N,\\sigma,\\delta)\\,$，使得对于给定的置信水平 $\\,1-\\delta\\,$（其中 $\\,\\delta\\in(0,1)\\,$），满足\n$$\n\\mathbb{P}\\Big(|\\widehat{m}_{i}(\\tau)-\\mu_{i}(\\tau)|\\le r(N,\\sigma,\\delta)\\Big)\\;\\ge\\;1-\\delta,\n$$\n并使用由亚高斯假设所保证的集中不等式。\n\n将最终答案表示为一个单行矩阵，按顺序包含 $\\,\\mathrm{Var}[\\widehat{m}_{i}(\\tau)]\\,$ 和 $\\,r(N,\\sigma,\\delta)\\,$ 这两个量。无需进行数值计算或四舍五入；请提供闭式解析表达式。",
            "solution": "### 推导\n让我们将第 $i$ 个分量的单个脉冲触发刺激样本表示为 $X_j = s_{t_{j}-\\tau,i}$。问题陈述，样本集 $\\{X_j\\}_{j=1}^{N}$ 是独立同分布的，其均值为 $\\mathbb{E}[X_j] = \\mu_{i}(\\tau)$，方差为 $\\mathrm{Var}[X_j] = \\sigma^2$。STA 分量是这些变量的样本均值：\n$$\n\\widehat{m}_{i}(\\tau) = \\frac{1}{N}\\sum_{j=1}^{N} X_j\n$$\n\n**第1部分：STA 分量的方差**\n\n我们要计算 $\\widehat{m}_{i}(\\tau)$ 的方差。利用方差的性质，我们首先可以提出常数项 $\\frac{1}{N}$：\n$$\n\\mathrm{Var}[\\widehat{m}_{i}(\\tau)] = \\mathrm{Var}\\left[\\frac{1}{N}\\sum_{j=1}^{N} X_j\\right] = \\frac{1}{N^2}\\mathrm{Var}\\left[\\sum_{j=1}^{N} X_j\\right]\n$$\n因为假设随机变量 $X_j$ 是独立的，所以它们的和的方差等于它们方差的和：\n$$\n\\mathrm{Var}\\left[\\sum_{j=1}^{N} X_j\\right] = \\sum_{j=1}^{N} \\mathrm{Var}[X_j]\n$$\n我们已知每个独立样本的方差是 $\\mathrm{Var}[X_j] = \\sigma^2$。因此，方差之和为：\n$$\n\\sum_{j=1}^{N} \\mathrm{Var}[X_j] = \\sum_{j=1}^{N} \\sigma^2 = N\\sigma^2\n$$\n将此结果代回到 STA 分量方差的表达式中，我们得到：\n$$\n\\mathrm{Var}[\\widehat{m}_{i}(\\tau)] = \\frac{1}{N^2} (N\\sigma^2) = \\frac{\\sigma^2}{N}\n$$\n这是第一个所求的量。\n\n**第2部分：置信区间半宽度**\n\n我们需要找到真实均值 $\\mu_i(\\tau)$ 的置信区间的半宽度 $r = r(N,\\sigma,\\delta)$。问题指定使用由亚高斯假设所保证的集中不等式。\n\n我们感兴趣的量是样本均值与真实均值之间的偏差：$\\widehat{m}_{i}(\\tau) - \\mu_{i}(\\tau)$。这可以写成：\n$$\n\\widehat{m}_{i}(\\tau) - \\mu_{i}(\\tau) = \\frac{1}{N}\\sum_{j=1}^{N} X_j - \\mu_i(\\tau) = \\frac{1}{N}\\sum_{j=1}^{N} (X_j - \\mu_i(\\tau))\n$$\n这是 $N$ 个独立同分布的零均值随机变量 $Z_j = X_j - \\mu_i(\\tau)$ 的平均值。问题陈述每个 $X_j$ 是亚高斯的，其代理方差参数为 $\\sigma^2$。此性质意味着对于任何 $\\lambda \\in \\mathbb{R}$：\n$$\n\\mathbb{E}[\\exp(\\lambda Z_j)] = \\mathbb{E}[\\exp(\\lambda (X_j - \\mu_i(\\tau)))] \\le \\exp\\left(\\frac{\\lambda^2 \\sigma^2}{2}\\right)\n$$\n对于 $N$ 个此类独立同分布变量的平均值，Hoeffding 不等式提供了一个紧密的集中界。该不等式表明，对于任何 $\\epsilon > 0$：\n$$\n\\mathbb{P}\\left(\\left|\\frac{1}{N}\\sum_{j=1}^{N} Z_j\\right| \\ge \\epsilon\\right) \\le 2 \\exp\\left(-\\frac{N \\epsilon^2}{2\\sigma^2}\\right)\n$$\n在我们的符号表示中，即为：\n$$\n\\mathbb{P}\\Big(|\\widehat{m}_{i}(\\tau) - \\mu_{i}(\\tau)| \\ge \\epsilon\\Big) \\le 2 \\exp\\left(-\\frac{N \\epsilon^2}{2\\sigma^2}\\right)\n$$\n我们正在寻找一个半宽度 $r$，使得 $\\mathbb{P}(|\\widehat{m}_{i}(\\tau)-\\mu_{i}(\\tau)|\\le r) \\ge 1-\\delta$。这等价于确保其相反事件的概率上界为 $\\delta$：\n$$\n\\mathbb{P}\\Big(|\\widehat{m}_{i}(\\tau) - \\mu_{i}(\\tau)| > r\\Big) \\le \\delta\n$$\n我们可以通过将 Hoeffding 不等式的上界设为 $\\delta$ 并求解 $\\epsilon$ 来实现这一点，这个 $\\epsilon$ 就是我们的半宽度 $r$。\n$$\n\\delta = 2 \\exp\\left(-\\frac{N r^2}{2\\sigma^2}\\right)\n$$\n现在，我们求解 $r(N,\\sigma,\\delta)$：\n$$\n\\frac{\\delta}{2} = \\exp\\left(-\\frac{N r^2}{2\\sigma^2}\\right)\n$$\n对两边取自然对数：\n$$\n\\ln\\left(\\frac{\\delta}{2}\\right) = -\\frac{N r^2}{2\\sigma^2}\n$$\n两边乘以 $-1$ 并使用性质 $\\ln(1/x) = -\\ln(x)$：\n$$\n\\ln\\left(\\frac{2}{\\delta}\\right) = \\frac{N r^2}{2\\sigma^2}\n$$\n分离出 $r^2$：\n$$\nr^2 = \\frac{2\\sigma^2}{N} \\ln\\left(\\frac{2}{\\delta}\\right)\n$$\n最后，取平方根得到半宽度 $r$ 的表达式：\n$$\nr(N,\\sigma,\\delta) = \\sqrt{\\frac{2\\sigma^2}{N} \\ln\\left(\\frac{2}{\\delta}\\right)} = \\sigma \\sqrt{\\frac{2}{N} \\ln\\left(\\frac{2}{\\delta}\\right)}\n$$\n这是第二个所求的量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sigma^2}{N} & \\sigma \\sqrt{\\frac{2}{N} \\ln\\left(\\frac{2}{\\delta}\\right)}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "计算出脉冲触发平均（STA）后，我们通常得到一条曲线或一个时空图。为了使这个结果有用，我们需要将其提炼成几个有意义的参数。这个编程实践将指导您完成从离散 STA 轨迹中以编程方式提取关键时间特征（如延迟和持续时间）的过程。这些指标为神经元的时间感受野提供了一个简洁且可解释的总结。",
            "id": "4060247",
            "problem": "给定离散的脉冲触发平均 (STA) 在不同时间延迟下的迹线，要求您通过定位 STA 中的峰值来计算主导时间感受野波瓣的时间潜伏期和持续时间，并将这些量与突触整合特性联系起来。严格在离散时间内进行计算。设离散时间延迟定义为 $ \\tau_i = (i - i_0)\\,\\Delta t $，其中 $ i \\in \\{0,1,\\dots,N-1\\} $，$ i_0 $ 是零延迟索引，$ \\Delta t $ 是以毫秒为单位的均匀采样间隔。设 STA 样本由一个长度为 $ N $ 的实值序列 $ s[i] $ 给出。使用以下定义和要求计算所需的量。\n\n基本基础和定义：\n- 对于一个刺激 $ x(t) $，脉冲触发平均 (STA) 是脉冲前刺激的条件期望，$ \\mathrm{STA}(\\tau) = \\mathbb{E}[x(t-\\tau)\\,|\\,\\text{spike at }t] $。在线性滤波器、加性噪声和单调静态非线性模型下，当刺激在时间上是白噪声时，STA 与线性时间滤波器（时间感受野）成正比，因此其主导波瓣编码了最能强烈驱动脉冲放电的时间敏感性轮廓。\n- 主导波瓣的时间潜伏期是 STA 的幅值达到其最大绝对值时的时间延迟，$ t_{\\mathrm{lat}} = \\tau_{i_{\\max}} $，其中 $ i_{\\max} = \\arg\\max_i |s[i]| $。\n- 主导波瓣的持续时间通过该波瓣的半峰全宽 (FWHM) 来量化。设 $ \\sigma = \\mathrm{sign}(s[i_{\\max}]) \\in \\{-1,+1\\} $，并设主导波瓣是包含 $ i_{\\max} $ 的最大连续索引集 $ \\mathcal{L} = \\{ \\ell,\\ell+1,\\dots,r \\} $，使得对于所有 $ j \\in \\mathcal{L} $ 都有 $ s[j]\\cdot\\sigma > 0 $，该集合在其两侧以首次过零点或数组边界为界。设 $ a[j] = \\sigma\\, s[j] \\ge 0 $ 在 $ \\mathcal{L} $ 上，且 $ h = \\tfrac{1}{2}\\,a[i_{\\max}] $ 为半峰值。如果存在，则通过在离散网格上进行线性插值来定义左、右半峰值穿越时间：\n  - 找到最小的 $ k \\in \\{\\ell+1,\\dots,i_{\\max}\\} $ 使得 $ a[k-1] < h \\le a[k] $，则\n    $$ \\tau_{\\mathrm{L}} = \\tau_{k-1} + \\frac{h - a[k-1]}{a[k] - a[k-1]}\\,\\Delta t. $$\n  - 找到最大的 $ k \\in \\{ i_{\\max},\\dots,r-1 \\} $ 使得 $ a[k] \\ge h > a[k+1] $，则\n    $$ \\tau_{\\mathrm{R}} = \\tau_{k} + \\frac{h - a[k]}{a[k+1] - a[k]}\\,\\Delta t. $$\n  如果两个穿越点都存在，则 FWHM 持续时间为 $ t_{\\mathrm{dur}} = \\tau_{\\mathrm{R}} - \\tau_{\\mathrm{L}} $。如果只存在一侧的穿越点（左侧或右侧），则将 $ t_{\\mathrm{dur}} $ 定义为峰值周围单侧半宽的两倍。如果两侧都不存在，则定义 $ t_{\\mathrm{dur}} = (r-\\ell+1)\\,\\Delta t $。\n- 有效突触整合窗口由主导波瓣上的面积与峰值之比来量化，\n  $$ T_{\\mathrm{eff}} = \\frac{\\Delta t \\sum_{j=\\ell}^{r} a[j]}{a[i_{\\max}]}, $$\n  该值的单位是毫秒，等于输入相对于峰值响应做出贡献的有效时间尺度，与波瓣的具体形状无关。这个度量源于这样一个事实：对于一个非负核函数 $ k(t) $，比值 $ \\int k(t)\\,dt / \\max_t k(t) $ 是一个反映整合过程的类宽度尺度。\n- 主导波瓣的符号编码了在线性范围内，脉冲前刺激的增加是兴奋性的还是抑制性的：输出一个整数标志 $ u \\in \\{-1,+1\\} $，其中如果 $ \\sigma=+1 $ 则 $ u=+1 $，如果 $ \\sigma=-1 $ 则 $ u=-1 $。\n\n计算任务：\n给定以毫秒为单位的 $ \\Delta t $、零延迟索引 $ i_0 $ 和 STA 样本 $ s[i] $，根据上述定义计算四元组 $ [t_{\\mathrm{lat}},\\, t_{\\mathrm{dur}},\\, T_{\\mathrm{eff}},\\, u] $。所有时间量必须以毫秒表示，并四舍五入到三位小数。符号标志 $ u $ 必须是整数。\n\n测试套件：\n实现您的程序，为以下四种情况计算结果。在每种情况下，定义 $ \\tau_i = (i - i_0)\\,\\Delta t $ 并按规定构造 $ s[i] $。\n\n- 情况 A（单峰高斯波瓣）：\n  - $ N = 201 $，$ \\Delta t = 1.0 $，$ i_0 = 100 $。\n  - $ s[i] = \\exp\\!\\left( -\\tfrac{1}{2}\\,\\big(\\tfrac{\\tau_i - 25.0}{5.0}\\big)^2 \\right) $。\n\n- 情况 B（双相高斯差分，主导负波瓣）：\n  - $ N = 181 $，$ \\Delta t = 1.0 $，$ i_0 = 90 $。\n  - $ s[i] = 0.8\\,\\exp\\!\\left( -\\tfrac{1}{2}\\,\\big(\\tfrac{\\tau_i - 35.0}{6.0}\\big)^2 \\right) - 1.2\\,\\exp\\!\\left( -\\tfrac{1}{2}\\,\\big(\\tfrac{\\tau_i - 10.0}{4.0}\\big)^2 \\right) $。\n\n- 情况 C（带延迟的 alpha 函数突触核）：\n  - $ N = 151 $，$ \\Delta t = 1.0 $，$ i_0 = 50 $。\n  - 定义 $ d = 30.0 $ 和 $ \\tau_s = 8.0 $。设\n    $$ s[i] =\n      \\begin{cases}\n        \\left(\\dfrac{\\tau_i - d}{\\tau_s}\\right)\\exp\\!\\left(1 - \\dfrac{\\tau_i - d}{\\tau_s}\\right), & \\text{if } \\tau_i \\ge d,\\\\\n        0, & \\text{if } \\tau_i  d.\n      \\end{cases}\n    $$\n\n- 情况 D（边界情况：单样本波瓣）：\n  - $ N = 51 $，$ \\Delta t = 1.0 $，$ i_0 = 25 $。\n  - 对于所有 $ i $，$ s[i] = 0 $，除了 $ s[i_0 + 5] = 1.0 $。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应 A、B、C、D 四个测试用例之一，并且本身是一个四元组列表 $ [t_{\\mathrm{lat}}, t_{\\mathrm{dur}}, T_{\\mathrm{eff}}, u] $。例如，打印的结构必须类似于 $ [[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],\\dots] $，所有时间量四舍五入到三位小数，$ u $ 为整数。不应打印任何额外文本。",
            "solution": "核心任务是实现一个计算过程，对于给定的离散 STA 迹线 $s[i]$，提取一组四个特征量：潜伏期 $t_{\\mathrm{lat}}$、持续时间 $t_{\\mathrm{dur}}$、有效整合时间 $T_{\\mathrm{eff}}$ 和主导波瓣的符号 $u$。整个过程可以分解为以下步骤，这些步骤直接遵循所提供的定义。\n\n**第 1 步：STA 信号生成**\n对于每个测试用例，我们都给定了样本数 $N$、采样间隔 $\\Delta t$ 和零延迟索引 $i_0$。第一步是构造离散时间延迟数组 $\\tau$ 和相应的 STA 信号 $s$。\n时间延迟定义为：\n$$ \\tau_i = (i - i_0)\\,\\Delta t \\quad \\text{for } i \\in \\{0, 1, \\dots, N-1\\} $$\n使用这些时间延迟，根据每种情况提供的特定函数（高斯、高斯差分等）生成 STA 信号 $s[i]$。\n\n**第 2 步：主导波瓣峰值和符号识别**\n主导波瓣由 STA 绝对幅值的峰值定义。\n首先，我们找到 $|s[i]|$ 取最大值时的索引 $i_{\\max}$：\n$$ i_{\\max} = \\arg\\max_i |s[i]| $$\n时间潜伏期 $t_{\\mathrm{lat}}$ 是对应于此峰值的时间延迟：\n$$ t_{\\mathrm{lat}} = \\tau_{i_{\\max}} = (i_{\\max} - i_0)\\,\\Delta t $$\n主导波瓣的符号 $\\sigma$ 表示它是兴奋性的（正）还是抑制性的（负）。它由 STA 在峰值处的符号确定，并相应地设置输出标志 $u$：\n$$ \\sigma = \\mathrm{sign}(s[i_{\\max}]) $$\n$$ u = \\sigma $$\n\n**第 3 步：主导波瓣边界检测**\n主导波瓣是围绕峰值 $i_{\\max}$ 且与峰值符号相同的连续区域。我们必须找到包含 $i_{\\max}$ 的最大连续索引集 $\\mathcal{L} = \\{\\ell, \\ell+1, \\dots, r\\}$，使得对于所有 $j \\in \\mathcal{L}$，都有 $s[j] \\cdot \\sigma  0$。\n左边界 $\\ell$ 是通过从 $i_{\\max}$ 开始向后搜索（减小索引 $j$），直到找到第一个 $s[j] \\cdot \\sigma \\le 0$ 的索引或到达数组边界 $j=0$ 为止。波瓣内第一个点的索引即为 $\\ell$。\n同样，右边界 $r$ 是通过从 $i_{\\max}$ 开始向前搜索（增加索引 $j$），直到找到第一个 $s[j] \\cdot \\sigma \\le 0$ 的索引或到达数组边界 $j=N-1$ 为止。波瓣内最后一个点的索引即为 $r$。\n\n**第 4 步：有效整合时间 ($T_{\\mathrm{eff}}$)**\n该度量量化了整合窗口的有效持续时间。它计算为波瓣面积与其峰高之比。为计算此值，我们首先定义一个正值版本的波瓣，$a[j] = \\sigma \\cdot s[j]$，对于 $j \\in \\mathcal{L}$。这个整流后波瓣的峰值为 $a[i_{\\max}] = |s[i_{\\max}]|$。\n波瓣下的面积通过离散求和来近似：\n$$ A_{\\mathrm{lobe}} = \\Delta t \\sum_{j=\\ell}^{r} a[j] = \\Delta t \\sum_{j=\\ell}^{r} \\sigma \\cdot s[j] $$\n有效整合时间则为：\n$$ T_{\\mathrm{eff}} = \\frac{A_{\\mathrm{lobe}}}{a[i_{\\max}]} = \\frac{\\Delta t \\sum_{j=\\ell}^{r} a[j]}{a[i_{\\max}]} $$\n\n**第 5 步：通过半峰全宽 (FWHM) 计算波瓣持续时间 ($t_{\\mathrm{dur}}$)**\nFWHM 测量波瓣在其最大振幅一半处的宽度。\n首先，我们计算半峰高度：\n$$ h = \\frac{1}{2} a[i_{\\max}] $$\n接下来，我们找到整流后的波瓣 $a[j]$ 穿过此高度 $h$ 的时间点 $\\tau_{\\mathrm{L}}$ 和 $\\tau_{\\mathrm{R}}$。由于信号是离散的，这些点通过相邻样本之间的线性插值找到。\n\n为找到左穿越时间 $\\tau_{\\mathrm{L}}$，我们搜索最小的索引 $k \\in \\{\\ell+1, \\dots, i_{\\max}\\}$ 使得 $a[k-1]  h \\le a[k]$。如果找到了这样的 $k$，则 $\\tau_{\\mathrm{L}}$ 插值如下：\n$$ \\tau_{\\mathrm{L}} = \\tau_{k-1} + \\frac{h - a[k-1]}{a[k] - a[k-1]}\\,\\Delta t $$\n为找到右穿越时间 $\\tau_{\\mathrm{R}}$，我们搜索最大的索引 $k \\in \\{i_{\\max}, \\dots, r-1\\}$ 使得 $a[k] \\ge h  a[k+1]$。如果找到了这样的 $k$，则 $\\tau_{\\mathrm{R}}$ 插值如下：\n$$ \\tau_{\\mathrm{R}} = \\tau_{k} + \\frac{h - a[k]}{a[k+1] - a[k]}\\,\\Delta t $$\n\n然后根据找到的穿越点确定持续时间 $t_{\\mathrm{dur}}$：\n1.  如果 $\\tau_{\\mathrm{L}}$ 和 $\\tau_{\\mathrm{R}}$ 都存在，$t_{\\mathrm{dur}} = \\tau_{\\mathrm{R}} - \\tau_{\\mathrm{L}}$。\n2.  如果只有 $\\tau_{\\mathrm{L}}$ 存在，$t_{\\mathrm{dur}} = 2 \\cdot (\\tau_{i_{\\max}} - \\tau_{\\mathrm{L}})$。\n3.  如果只有 $\\tau_{\\mathrm{R}}$ 存在，$t_{\\mathrm{dur}} = 2 \\cdot (\\tau_{\\mathrm{R}} - \\tau_{i_{\\max}})$。\n4.  如果两个穿越点都不存在（例如，一个非常窄的、单样本的峰值），$t_{\\mathrm{dur}} = (r - \\ell + 1) \\cdot \\Delta t$。\n\n这个综合过程为任何给定的 STA 迹线计算了四个所需的量。它将针对指定的四个测试用例分别实现。所得的基于时间的量（$t_{\\mathrm{lat}}, t_{\\mathrm{dur}}, T_{\\mathrm{eff}}$）按要求四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\n\ndef compute_sta_features(N, dt, i0, s_func):\n    \"\"\"\n    Computes temporal features of a spike-triggered average (STA) trace.\n    \"\"\"\n    # Step 1: STA Signal Generation\n    indices = np.arange(N)\n    tau = (indices - i0) * dt\n    s = s_func(tau)\n\n    # Handle all-zero STA gracefully, though not expected in tests.\n    if not np.any(s):\n        return [0.0, 0.0, 0.0, 1]\n\n    # Step 2: Dominant Lobe Peak and Sign Identification\n    i_max = np.argmax(np.abs(s))\n    t_lat = (i_max - i0) * dt\n    s_peak = s[i_max]\n    sigma = np.sign(s_peak)\n    if sigma == 0: sigma = 1  # Convention for zero-peak case\n    u = int(sigma)\n\n    # Step 3: Dominant Lobe Boundary Detection\n    l, r = i_max, i_max\n    # Find left boundary\n    if l > 0:\n        for i in range(i_max - 1, -1, -1):\n            if s[i] * sigma > 0:\n                l = i\n            else:\n                break\n    # Find right boundary\n    if r  N - 1:\n        for i in range(i_max + 1, N):\n            if s[i] * sigma > 0:\n                r = i\n            else:\n                break\n\n    # Step 4: Effective Integration Time (T_eff)\n    lobe_indices = np.arange(l, r + 1)\n    a_lobe_values = s[lobe_indices] * sigma\n    a_max = s_peak * sigma\n    \n    if a_max == 0:\n        T_eff = 0.0\n    else:\n        T_eff = dt * np.sum(a_lobe_values) / a_max\n    \n    # Step 5: Lobe Duration (t_dur) via FWHM\n    h = 0.5 * a_max\n    \n    a_full = s * sigma  # Rectified full signal\n    tau_L, tau_R = None, None\n\n    # Find left crossing (search from lobe start up to the peak)\n    for k in range(l + 1, i_max + 1):\n        if a_full[k-1]  h = a_full[k]:\n            if a_full[k] - a_full[k-1] != 0:\n                tau_L = tau[k-1] + (h - a_full[k-1]) / (a_full[k] - a_full[k-1]) * dt\n            else:  # Flat region at half-max\n                tau_L = tau[k]\n            break\n\n    # Find right crossing (search from lobe end down to the peak)\n    # The problem asks for the largest k, so searching backwards and stopping works.\n    for k in range(r - 1, i_max - 1, -1):\n        if a_full[k] >= h > a_full[k+1]:\n            if a_full[k+1] - a_full[k] != 0:\n                tau_R = tau[k] + (h - a_full[k]) / (a_full[k+1] - a_full[k]) * dt\n            else:\n                tau_R = tau[k]\n            break\n\n    # Determine t_dur based on which crossings were found\n    t_peak = tau[i_max]\n    if tau_L is not None and tau_R is not None:\n        t_dur = tau_R - tau_L\n    elif tau_L is not None:\n        t_dur = 2 * (t_peak - tau_L)\n    elif tau_R is not None:\n        t_dur = 2 * (tau_R - t_peak)\n    else: # Neither crossing exists (e.g., single-point lobe)\n        t_dur = (r - l + 1) * dt\n\n    return [\n        round(t_lat, 3),\n        round(t_dur, 3),\n        round(T_eff, 3),\n        u\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: unimodal Gaussian lobe\n        {\n            \"N\": 201, \"dt\": 1.0, \"i0\": 100,\n            \"s_func\": lambda tau: np.exp(-0.5 * ((tau - 25.0) / 5.0)**2)\n        },\n        # Case B: biphasic difference of Gaussians, dominant negative lobe\n        {\n            \"N\": 181, \"dt\": 1.0, \"i0\": 90,\n            \"s_func\": lambda tau: 0.8 * np.exp(-0.5 * ((tau - 35.0) / 6.0)**2) - 1.2 * np.exp(-0.5 * ((tau - 10.0) / 4.0)**2)\n        },\n        # Case C: alpha-function synaptic kernel with delay\n        {\n            \"N\": 151, \"dt\": 1.0, \"i0\": 50,\n            \"s_func\": lambda tau, d=30.0, tau_s=8.0: np.piecewise(\n                tau, [tau  d], [0.0, lambda t: ((t - d) / tau_s) * np.exp(1 - (t - d) / tau_s)]\n            )\n        },\n        # Case D: boundary case: single-sample lobe\n        {\n            \"N\": 51, \"dt\": 1.0, \"i0\": 25,\n            \"s_func\": lambda tau: np.where(tau == 5.0, 1.0, 0.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_sta_features(case[\"N\"], case[\"dt\"], case[\"i0\"], case[\"s_func\"])\n        results.append(result)\n\n    # Format the output string as specified in the problem\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]) + \"]\"\n\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "感受野并非一成不变，它们通过突触可塑性由经验塑造而成。一个基本问题是，局部学习规则如何产生我们观察到的结构化感受野。本练习探索了赫布型学习（Hebbian-style learning）与脉冲触发统计之间的深刻联系。通过仿真，您将观察到一个简单的、符合生物学原理的突触更新规则如何使神经元的突触权重收敛到一个与输入的脉冲触发均值成比例的向量。这项实践为了解感受野形成的背后学习动态提供了关键的洞见，弥合了 STA 的描述能力与突触可塑性的规定性机制之间的鸿沟。",
            "id": "4060251",
            "problem": "考虑一个在神经形态和脑启发计算中的离散时间突触学习场景，其中突触前和突触后脉冲序列在小的时间窗内均被建模为泊松过程。令时间索引 $t$ 处的突触前输入为一个 $d$ 维非负整数向量 $x_t \\in \\mathbb{N}^d$，其中每个坐标 $x_{t,i}$ 是从速率为 $\\lambda_i  0$ 的泊松分布中进行的独立抽样。定义中心化的突触前活动为 $z_t = x_t - \\lambda$，其中 $\\lambda \\in \\mathbb{R}^d$ 是速率向量。令突触后脉冲指示符为 $s_t \\in \\{0,1\\}$，其中 $s_t = 1$ 表示在时间窗 $t$ 内有脉冲，其伯努利概率 $p_t$ 由一个logistic非线性函数给出\n$$\np_t = \\sigma\\!\\left(b + g\\, w_\\ast^\\top z_t \\right),\n$$\n其中 $w_\\ast \\in \\mathbb{R}^d$ 是一个固定但未知的目标滤波器方向，$b \\in \\mathbb{R}$ 是一个偏置，$g0$ 是一个增益，$\\sigma(u) = \\frac{1}{1 + e^{-u}}$ 是logistic函数。在小时间窗内的这种伯努利脉冲发放与用于突触后脉冲发放的非齐次泊松过程模型是一致的。\n\n一个突触权重向量 $w_t \\in \\mathbb{R}^d$ 根据一个带稳态衰减的、基于相关的更新规则进行演化\n$$\nw_{t+1} = w_t + \\eta \\left( s_t z_t - \\delta\\, w_t \\right),\n$$\n其中 $\\eta  0$ 是一个学习率，$\\delta  0$ 是一个衰减系数。将中心化输入的脉冲触发平均 (STM) 定义为\n$$\nm = \\mathbb{E}\\left[ z_t \\mid s_t = 1 \\right],\n$$\n及其经验估计量\n$$\n\\hat{m} = \\frac{1}{N_{\\text{spike}}} \\sum_{t: s_t = 1} z_t,\n$$\n其中 $N_{\\text{spike}}$ 是 $s_t = 1$ 的时间窗数量。\n\n从泊松过程和伯努利过程的基本定义以及指定的学习规则出发，利用第一性原理推导，为何期望更新会将突触权重的方向与脉冲触发平均 $\\hat{m}$ 对齐，其间的比例常数由衰减 $\\delta$ 设定。然后实现一个仿真，在大数量的时间步长 $T$ 上估计 $w_T$ 和 $\\hat{m}$，并通过余弦相似度\n$$\n\\mathrm{cos\\_sim}(w_T, \\hat{m}) = \\frac{w_T^\\top \\hat{m}}{\\|w_T\\|_2 \\, \\|\\hat{m}\\|_2},\n$$\n来量化收敛性，前提是两个范数均不为零。在 $\\|\\hat{m}\\|_2 = 0$ 的情况下，STM 的方向未明确定义；此时，应改为使用最终范数 $\\|w_T\\|_2$ 来量化收敛性。\n\n您的程序必须为以下三个测试用例实现仿真，使用指定的随机种子以保证可复现性，并生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表。每个测试用例的结果是按规定计算的单个浮点数。\n\n用于推导和程序的定义与假设：\n- 突触前输入 $x_{t,i}$ 在维度和时间上是独立的，且 $x_{t,i} \\sim \\mathrm{Poisson}(\\lambda_i)$。\n- 中心化输入为 $z_t = x_t - \\lambda$，因此 $\\mathbb{E}[z_t] = 0$。\n- 突触后脉冲 $s_t \\sim \\mathrm{Bernoulli}(p_t)$，其中 $p_t = \\sigma(b + g\\, w_\\ast^\\top z_t)$。\n- 学习规则是 $w_{t+1} = w_t + \\eta ( s_t z_t - \\delta w_t )$。\n\n测试套件：\n1. 一般情况 (happy path)：$d = 32$，$T = 120{,}000$，对所有 $i$ 有 $\\lambda_i = 5$，$b = -0.75$，$g = 0.15$，$\\eta = 0.01$，$\\delta = 0.01$，随机种子为 $123$，且 $w_\\ast$ 是从标准正态分布中抽取并归一化为单位长度的随机单位范数向量。输出余弦相似度 $\\mathrm{cos\\_sim}(w_T, \\hat{m})$，结果为浮点数。\n2. 独立性边缘情况：$d = 32$，$T = 120{,}000$，对所有 $i$ 有 $\\lambda_i = 5$，$b = -0.75$，$g = 0.0$ (使得突触后脉冲独立于 $z_t$)，$\\eta = 0.01$，$\\delta = 0.01$，随机种子为 $456$，且 $w_\\ast = 0$ (零向量)。输出最终权重范数 $\\|w_T\\|_2$，结果为浮点数。\n3. 低速率边界情况：$d = 32$，$T = 200{,}000$，对所有 $i$ 有 $\\lambda_i = 5$，$b = -3.0$，$g = 0.5$，$\\eta = 0.005$，$\\delta = 0.01$，随机种子为 $789$，且 $w_\\ast$ 是从标准正态分布中抽取并归一化为单位长度的随机单位范数向量。输出余弦相似度 $\\mathrm{cos\\_sim}(w_T, \\hat{m})$，结果为浮点数。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表（例如，\"[result1,result2,result3]\"），结果的顺序与上面列出的三个测试用例的顺序一致。",
            "solution": "### 理论推导\n\n目标是利用第一性原理证明，该学习规则能将突触权重向量 $w_t$ 与中心化输入的脉冲触发平均 (STM) $m = \\mathbb{E}[ z_t \\mid s_t = 1 ]$ 对齐。STM 的经验估计量是 $\\hat{m}$，对于足够大的时间步长 $T$，我们期望 $\\hat{m} \\approx m$。因此，证明与 $m$ 对齐即意味着最终会与 $\\hat{m}$ 对齐。\n\n突触权重向量 $w_t \\in \\mathbb{R}^d$ 根据带有稳态衰减项的、基于相关的更新规则进行演化：\n$$\nw_{t+1} = w_t + \\eta \\left( s_t z_t - \\delta\\, w_t \\right)\n$$\n其中 $\\eta  0$ 是学习率，$\\delta  0$ 是衰减系数，$s_t \\in \\{0, 1\\}$ 是突触后脉冲指示符，$z_t \\in \\mathbb{R}^d$ 是中心化的突触前活动。\n\n为了理解 $w_t$ 的长期行为，我们分析权重在单个时间步长内的期望变化。我们对更新量 $\\Delta w_t = w_{t+1} - w_t$ 关于随机变量 $z_t$ 和 $s_t$ 的分布求期望。该期望以当前权重状态 $w_t$ 为条件。\n$$\n\\mathbb{E}[\\Delta w_t \\mid w_t] = \\mathbb{E}[w_{t+1} - w_t \\mid w_t] = \\mathbb{E}\\left[ \\eta (s_t z_t - \\delta w_t) \\mid w_t \\right]\n$$\n根据期望的线性性质，并注意到 $w_t$ 在时间 $t$ 的期望计算中是常数：\n$$\n\\mathbb{E}[\\Delta w_t \\mid w_t] = \\eta \\left( \\mathbb{E}[s_t z_t] - \\delta \\mathbb{E}[w_t] \\right) = \\eta \\left( \\mathbb{E}[s_t z_t] - \\delta w_t \\right)\n$$\n$s_t$ 和 $z_t$ 的分布对 $w_t$ 没有依赖关系，因为 $p_t$ 依赖于 $w_\\ast$，而不是 $w_t$。\n\n分析的核心在于计算相关项 $\\mathbb{E}[s_t z_t]$。我们可以利用全期望定律，通过以脉冲指示符 $s_t$ 的值为条件来计算它：\n$$\n\\mathbb{E}[s_t z_t] = \\mathbb{E}[s_t z_t \\mid s_t=1] P(s_t=1) + \\mathbb{E}[s_t z_t \\mid s_t=0] P(s_t=0)\n$$\n当 $s_t=1$ 时，表达式变为 $\\mathbb{E}[1 \\cdot z_t \\mid s_t=1] P(s_t=1)$。根据定义，项 $\\mathbb{E}[z_t \\mid s_t=1]$ 就是脉冲触发平均 $m$。\n当 $s_t=0$ 时，表达式变为 $\\mathbb{E}[0 \\cdot z_t \\mid s_t=0] P(s_t=0) = 0$。\n\n令 $P_{\\text{spike}} = P(s_t=1)$ 表示突触后脉冲的平均概率。将这些代入 $\\mathbb{E}[s_t z_t]$ 的方程中可得：\n$$\n\\mathbb{E}[s_t z_t] = m \\cdot P_{\\text{spike}} + 0 = P_{\\text{spike}} \\, m\n$$\n这个结果表明，脉冲与中心化输入之间的期望相关性就是脉冲触发平均值乘以平均发放率。\n\n现在，我们将其代回期望权重更新的方程中：\n$$\n\\mathbb{E}[\\Delta w_t \\mid w_t] = \\eta \\left( P_{\\text{spike}} \\, m - \\delta w_t \\right)\n$$\n当权重的期望变化为零时，即 $\\mathbb{E}[\\Delta w_t \\mid w_t] = 0$，系统达到一个稳定点或平衡点。令 $w_{\\text{eq}}$ 为此平衡点处的权重向量。\n$$\n\\eta \\left( P_{\\text{spike}} \\, m - \\delta w_{\\text{eq}} \\right) = 0\n$$\n因为 $\\eta  0$ 且 $\\delta  0$，我们可以解出 $w_{\\text{eq}}$：\n$$\n\\delta w_{\\text{eq}} = P_{\\text{spike}} \\, m\n$$\n$$\nw_{\\text{eq}} = \\frac{P_{\\text{spike}}}{\\delta} m\n$$\n此推导表明，学习规则期望的固定点 $w_{\\text{eq}}$ 与真实的脉冲触发平均 $m$ 成正比。比例常数由平均发放率 $P_{\\text{spike}}$ 与衰减系数 $\\delta$ 的比值给出。\n\n该学习规则实际上是在一个潜在的目标函数上执行随机梯度上升，该函数的最大值位于 $w_{\\text{eq}}$ 处。经过许多时间步后，突触权重向量 $w_t$ 将会围绕这个期望平衡值波动。经验脉冲触发平均 $\\hat{m} = \\frac{1}{N_{\\text{spike}}} \\sum_{t: s_t = 1} z_t$ 是真实STM $m$ 的一个统计估计量。对于大量的时间步 $T$ 和足够数量的脉冲 $N_{\\text{spike}}$，大数定律确保 $\\hat{m}$ 收敛于 $m$。因此，最终权重向量 $w_T$ 预期会与 $\\hat{m}$ 对齐，因为两者（在相差一个缩放因子的情况下）都是对源于神经活动统计的同一潜在方向量的估计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running three distinct simulations of a synaptic learning rule\n    and computes the specified metric for each case.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (d, T, lam_val, b, g, eta, delta, seed, w_star_mode, metric)\n        (32, 120_000, 5.0, -0.75, 0.15, 0.01, 0.01, 123, 'random', 'cos_sim'),\n        (32, 120_000, 5.0, -0.75, 0.0, 0.01, 0.01, 456, 'zero', 'norm_wT'),\n        (32, 200_000, 5.0, -3.0, 0.5, 0.005, 0.01, 789, 'random', 'cos_sim'),\n    ]\n\n    results = []\n\n    def sigma(u):\n        \"\"\"\n        Computes the logistic sigmoid function with clipping to prevent overflow.\n        \"\"\"\n        # Clip input to a safe range for np.exp to avoid overflow.\n        u_clipped = np.clip(u, -700, 700)\n        return 1.0 / (1.0 + np.exp(-u_clipped))\n\n    for case in test_cases:\n        d, T, lam_val, b, g, eta, delta, seed, w_star_mode, metric = case\n        \n        rng = np.random.default_rng(seed)\n\n        if w_star_mode == 'random':\n            w_star_raw = rng.standard_normal(d)\n            norm_w_star = np.linalg.norm(w_star_raw)\n            # Normalize to unit length, handling the unlikely case of a zero vector.\n            w_star = w_star_raw if norm_w_star == 0 else w_star_raw / norm_w_star\n        elif w_star_mode == 'zero':\n            w_star = np.zeros(d)\n\n        lam_vec = np.full(d, lam_val)\n        w = np.zeros(d)\n        \n        z_sum_spiked = np.zeros(d)\n        n_spike = 0\n        \n        # Pre-compute the decay factor for the weight update\n        decay_factor = 1.0 - eta * delta\n        \n        for _ in range(T):\n            # 1. Generate pre-synaptic Poisson spikes\n            x_t = rng.poisson(lam_vec)\n            \n            # 2. Compute centered input\n            z_t = x_t - lam_vec\n            \n            # 3. Compute post-synaptic spiking probability\n            p_t = sigma(b + g * np.dot(w_star, z_t))\n            \n            # 4. Generate post-synaptic spike\n            s_t = 1 if rng.random()  p_t else 0\n            \n            # 5. Accumulate spike-triggered inputs\n            if s_t == 1:\n                z_sum_spiked += z_t\n                n_spike += 1\n            \n            # 6. Apply learning rule\n            w = decay_factor * w + eta * s_t * z_t\n\n        w_T = w\n        \n        if n_spike > 0:\n            m_hat = z_sum_spiked / n_spike\n        else:\n            m_hat = np.zeros(d)\n\n        # Calculate the result based on the specified metric for the test case\n        if metric == 'cos_sim':\n            norm_wT = np.linalg.norm(w_T)\n            norm_m_hat = np.linalg.norm(m_hat)\n            \n            # Per problem instructions, if m_hat is a zero vector, use norm of w_T.\n            if norm_m_hat == 0:\n                result = norm_wT\n            # Otherwise, if w_T is zero, the similarity is zero.\n            elif norm_wT == 0:\n                result = 0.0\n            # Standard cosine similarity calculation\n            else:\n                result = np.dot(w_T, m_hat) / (norm_wT * norm_m_hat)\n        \n        elif metric == 'norm_wT':\n            # This metric is explicitly requested for Test Case 2\n            result = np.linalg.norm(w_T)\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}