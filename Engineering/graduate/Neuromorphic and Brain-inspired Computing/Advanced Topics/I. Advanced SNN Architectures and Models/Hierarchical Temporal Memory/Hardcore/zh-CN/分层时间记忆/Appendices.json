{
    "hands_on_practices": [
        {
            "introduction": "空间池化器是HTM系统的入口，负责将原始输入转换为稀疏分布式表示（SDR）。此过程中的关键第一步是为每个微柱计算“重叠分数”，该分数用于量化每个柱的连接与当前输入模式的匹配程度。本练习将指导您从基本原理推导重叠分数，并将其应用于一个具体场景，其中“增强”机制被用来确保神经可塑性和所有柱在长期内的公平利用 。",
            "id": "4047287",
            "problem": "考虑一个遵循分层时间记忆（HTM）原理的系统，其中每个微型柱都具有连接到二进制输入空间的近端突触，该输入空间被建模为稀疏分布式表示（SDR）。对于一个索引为 $i$ 的给定列，设二进制输入为 $x \\in \\{0,1\\}^{N}$，其分量为 $x_{j}$，并设从输入位 $j$ 到列 $i$ 的近端突触的永久性为 $p_{ij} \\in [0,1]$。如果一个突触的永久性达到或超过一个固定的阈值 $p_{\\text{th}}$，则该突触被认为是连接的。列的重叠度在操作上定义为接收到活动输入的已连接突触的数量，并且在应用局部抑制（竞争）之前，使用一个正的乘法增强因子 $b_{i}$ 来缩放重叠度。\n\n从这些核心定义出发，不假设任何预先推导的公式，执行以下操作：\n\n1. 推导列 $i$ 的未增强重叠度的符号表达式，该表达式仅依赖于二进制输入 $x_{j}$ 以及用 $p_{ij}$ 和 $p_{\\text{th}}$ 表示的连接性标准。然后，使用第一性原理，论证乘法增强因子在竞争中如何影响重叠度。\n\n2. 对于一个具体配置，其中 $N=12$，输入 $x$ 由 $j \\in \\{1,3,4,7,9,12\\}$ 时 $x_{j} = 1$、否则 $x_{j} = 0$ 指定。永久性阈值为 $p_{\\text{th}} = 0.25$。有三个列，索引为 $i \\in \\{1,2,3\\}$，其永久性值如下：\n- 对于列 $i=1$：$p_{1,1} = 0.30$, $p_{1,3} = 0.20$, $p_{1,4} = 0.28$, $p_{1,8} = 0.10$, $p_{1,9} = 0.40$, $p_{1,12} = 0.24$，所有其他 $j$ 的 $p_{1,j} = 0$。\n- 对于列 $i=2$：$p_{2,1} = 0.27$, $p_{2,3} = 0.26$, $p_{2,7} = 0.29$, $p_{2,9} = 0.18$, $p_{2,10} = 0.50$, $p_{2,12} = 0.31$，所有其他 $j$ 的 $p_{2,j} = 0$。\n- 对于列 $i=3$：$p_{3,2} = 0.90$, $p_{3,4} = 0.26$, $p_{3,5} = 0.22$, $p_{3,7} = 0.23$, $p_{3,9} = 0.27$, $p_{3,11} = 0.30$, $p_{3,12} = 0.26$，所有其他 $j$ 的 $p_{3,j} = 0$。\n\n设增强因子为 $b_{1} = 1.2$，$b_{2} = 0.9$ 和 $b_{3} = 1.5$。考虑一个由这三列组成的局部抑制邻域，它根据增强后的重叠度选择前 $k=1$ 的列。计算该邻域中单个获胜列的增强重叠度。将最终答案表示为一个实数。不需要四舍五入。",
            "solution": "用户希望我解决一个关于分层时间记忆的问题。我将首先验证问题，然后解决它。\n\n### 第1步：提取已知条件\n- **系统模型**：分层时间记忆 (HTM)。\n- **输入**：二进制向量 $x \\in \\{0,1\\}^{N}$，其分量为 $x_{j}$。\n- **突触**：从输入位 $j$ 到列 $i$ 的近端突触具有永久性 $p_{ij} \\in [0,1]$。\n- **连接规则**：如果一个突触的永久性 $p_{ij}$ 大于或等于阈值 $p_{\\text{th}}$，则该突触是连接的。\n- **未增强重叠度**：接收到活动输入（$x_j=1$）的已连接突触的数量。\n- **增强**：一个正的乘法因子 $b_{i}$ 用于缩放列 $i$ 的重叠度。\n- **竞争**：局部抑制根据增强后的重叠度选择获胜列。\n\n- **第1部分任务**：\n  - 推导列 $i$ 的未增强重叠度的符号表达式。\n  - 论证乘法增强因子在竞争中的作用。\n\n- **第2部分具体配置**：\n  - 输入空间维度：$N=12$。\n  - 输入向量 $x$：对于 $j \\in \\{1,3,4,7,9,12\\}$，$x_{j} = 1$，否则 $x_{j} = 0$。\n  - 永久性阈值：$p_{\\text{th}} = 0.25$。\n  - 列数：$3$ 个，索引为 $i \\in \\{1,2,3\\}$。\n  - 列 $i=1$ 的永久性值：$p_{1,1} = 0.30$, $p_{1,3} = 0.20$, $p_{1,4} = 0.28$, $p_{1,8} = 0.10$, $p_{1,9} = 0.40$, $p_{1,12} = 0.24$。所有其他 $p_{1,j}=0$。\n  - 列 $i=2$ 的永久性值：$p_{2,1} = 0.27$, $p_{2,3} = 0.26$, $p_{2,7} = 0.29$, $p_{2,9} = 0.18$, $p_{2,10} = 0.50$, $p_{2,12} = 0.31$。所有其他 $p_{2,j}=0$。\n  - 列 $i=3$ 的永久性值：$p_{3,2} = 0.90$, $p_{3,4} = 0.26$, $p_{3,5} = 0.22$, $p_{3,7} = 0.23$, $p_{3,9} = 0.27$, $p_{3,11} = 0.30$, $p_{3,12} = 0.26$。所有其他 $p_{3,j}=0$。\n  - 增强因子：$b_{1} = 1.2$, $b_{2} = 0.9$, $b_{3} = 1.5$。\n  - 局部抑制：从集合 $\\{1,2,3\\}$ 中选择前 $k=1$ 的列。\n  - **第2部分任务**：计算单个获胜列的增强重叠度。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在科学上基于分层时间记忆的原理，这是计算神经科学中一个公认的模型。术语（SDR、永久性、重叠度、增强、抑制）在该领域是标准的。问题提法清晰，提供了所有必要的数据和约束，可以得出一个唯一的、可验证的数值答案。它是客观的，没有歧义。基于这些原因，该问题是有效的。\n\n### 第3步：结论与行动\n问题有效。将提供详细的解决方案。\n\n### 第1部分：符号推导与论证\n\n列 $i$ 的未增强重叠度（表示为 $O_i$）定义为其接收到活动输入的已连接突触的数量。让我们将其形式化。\n\n从输入位 $j$ 到列 $i$ 的突触，如果其永久性 $p_{ij}$ 达到或超过阈值 $p_{\\text{th}}$，则为已连接。我们可以用一个函数来表示这个条件，例如亥维赛阶跃函数 $H(z)$，其中当 $z \\ge 0$ 时 $H(z)=1$，当 $z  0$ 时 $H(z)=0$。设 $C_{ij}$ 是一个表示连接的指示变量：\n$$C_{ij} = H(p_{ij} - p_{\\text{th}})$$\n如果突触是连接的，$C_{ij}$ 为 $1$，否则为 $0$。\n\n输入位 $x_j$ 要么是 $1$（活动），要么是 $0$（非活动）。一个突触 $(i,j)$ 仅在它既是连接的（$C_{ij}=1$）又接收到活动输入（$x_j=1$）时才对重叠度计数有贡献。单个突触的贡献是乘积 $C_{ij} \\cdot x_j$。由于这两项都是二进制的，这个乘积当且仅当两个条件都满足时为 $1$，否则为 $0$。\n\n总的未增强重叠度 $O_i$ 是对所有 $N$ 个输入位的这些贡献的总和：\n$$O_i = \\sum_{j=1}^{N} C_{ij} \\cdot x_j = \\sum_{j=1}^{N} H(p_{ij} - p_{\\text{th}}) x_j$$\n这是未增强重叠度的符号表达式。\n\n乘法增强因子 $b_i$ 应用于此未增强重叠度，以确定该列在竞争过程中的最终得分。增强后的重叠度 $O'_i$ 由下式给出：\n$$O'_{i} = b_{i} \\cdot O_{i}$$\n然后，局部抑制机制根据这些增强后的得分选择一个或多个列变为活动状态。在“k-赢家通吃”方案中，局部邻域中具有最高增强重叠度的 $k$ 个列变为活动状态。\n\n这种机制的理由是稳态调节。它确保一个区域内的所有列随时间推移都被利用。如果一个列的激活频率较低（即，它最近没有赢得竞争），它的增强因子 $b_i$ 就会增加。这给了该列一个竞争优势，使其在未来更有可能获胜，即使其原始模式匹配（未增强重叠度 $O_i$）不是最高的。相反，一个赢得过于频繁的列，其增强因子会降低，使其不太可能获胜。这可以防止少数列主导所有模式的表示，并确保整个列群体的表示能力得到利用，这对于稳健和分布式的学习至关重要。\n\n### 第2部分：数值计算\n\n我们已知活动输入位 $j \\in \\{1,3,4,7,9,12\\}$，永久性阈值 $p_{\\text{th}} = 0.25$，以及三列的永久性和增强因子。我们将为每列计算未增强重叠度 $O_i$ 和增强重叠度 $O'_i$。获胜者是具有最高增强重叠度的列。\n\n**列1（$i=1$）的计算：**\n未增强重叠度 $O_1$ 是活动输入的已连接突触的数量。我们只需要检查索引 $j \\in \\{1,3,4,7,9,12\\}$ 处的永久性。\n- $j=1$: $p_{1,1} = 0.30 \\ge 0.25$。已连接。\n- $j=3$: $p_{1,3} = 0.20  0.25$。未连接。\n- $j=4$: $p_{1,4} = 0.28 \\ge 0.25$。已连接。\n- $j=7$: $p_{1,7}=0  0.25$。未连接。\n- $j=9$: $p_{1,9} = 0.40 \\ge 0.25$。已连接。\n- $j=12$: $p_{1,12} = 0.24  0.25$。未连接。\n\n接收活动输入的已连接突触的数量是 $3$。\n所以，未增强重叠度是 $O_1 = 3$。\n增强因子是 $b_1 = 1.2$。\n增强重叠度是 $O'_1 = b_1 \\cdot O_1 = 1.2 \\times 3 = 3.6$。\n\n**列2（$i=2$）的计算：**\n我们检查 $j \\in \\{1,3,4,7,9,12\\}$ 的永久性。\n- $j=1$: $p_{2,1} = 0.27 \\ge 0.25$。已连接。\n- $j=3$: $p_{2,3} = 0.26 \\ge 0.25$。已连接。\n- $j=4$: $p_{2,4}=0  0.25$。未连接。\n- $j=7$: $p_{2,7} = 0.29 \\ge 0.25$。已连接。\n- $j=9$: $p_{2,9} = 0.18  0.25$。未连接。\n- $j=12$: $p_{2,12} = 0.31 \\ge 0.25$。已连接。\n\n接收活动输入的已连接突触的数量是 $4$。\n所以，未增强重叠度是 $O_2 = 4$。\n增强因子是 $b_2 = 0.9$。\n增强重叠度是 $O'_2 = b_2 \\cdot O_2 = 0.9 \\times 4 = 3.6$。\n\n**列3（$i=3$）的计算：**\n我们检查 $j \\in \\{1,3,4,7,9,12\\}$ 的永久性。\n- $j=1$: $p_{3,1}=0  0.25$。未连接。\n- $j=3$: $p_{3,3}=0  0.25$。未连接。\n- $j=4$: $p_{3,4} = 0.26 \\ge 0.25$。已连接。\n- $j=7$: $p_{3,7} = 0.23  0.25$。未连接。\n- $j=9$: $p_{3,9} = 0.27 \\ge 0.25$。已连接。\n- $j=12$: $p_{3,12} = 0.26 \\ge 0.25$。已连接。\n\n接收活动输入的已连接突触的数量是 $3$。\n所以，未增强重叠度是 $O_3 = 3$。\n增强因子是 $b_3 = 1.5$。\n增强重叠度是 $O'_3 = b_3 \\cdot O_3 = 1.5 \\times 3 = 4.5$。\n\n**确定获胜者：**\n我们比较增强重叠度：\n- $O'_1 = 3.6$\n- $O'_2 = 3.6$\n- $O'_3 = 4.5$\n\n最大的增强重叠度是 $4.5$，属于列 $3$。因此，列 $3$ 是获胜列。问题要求计算这个获胜列的增强重叠度。\n\n获胜列的增强重叠度是 $4.5$。",
            "answer": "$$\\boxed{4.5}$$"
        },
        {
            "introduction": "一旦空间池化器选定了一组活动柱，时间记忆模块便开始接管，以学习和预测序列。该过程的核心在于，根据前一时间步做出的预测，来确定这些活动柱中的哪些特定细胞应该被激活。本练习将深入探讨这一关键机制，要求您应用规则来激活被预测的细胞，并解决当没有预测发生时系统进入的“簇生”（bursting）状态——这是HTM处理新颖性及学习新序列的基础 。",
            "id": "4047239",
            "problem": "一个分层时序记忆 (HTM) 的时序记忆单个区域由 $N$ 个柱构成，每个柱包含 $M$ 个细胞。在每个离散时间步 $t$，一部分柱由于前馈输入而变为激活状态。该时序记忆为每个细胞维持一组远端树突段，每个树突段包含到其他细胞的潜在突触。如果一个潜在突触的持久性至少为一个固定的连接阈值 $p_c$，则认为该突触是连接的。如果一个细胞上的某个树突段，其连接的突觸中，突触前细胞在时间 $t-1$ 处于激活状态的数量至少为一个固定的激活阈值 $\\theta$，则认为该树突段是激活的。如果在时间 $t$，一个细胞的任何树突段是激活的，则该细胞在时间 $t$ 处于预测状态。\n\n当时间 $t$ 的前馈输入激活了一组柱时，时间 $t$ 的下一个激活细胞集合按如下方式确定：\n- 对于每个激活的柱，如果该柱中有一个或多个细胞在时间 $t$ 处于预测状态，那么该柱中恰好是那些处于预测状态的细胞变为激活状态。\n- 否则（在该激活的柱中没有预测状态的细胞），该柱处于簇生状态，这里通过选择单个获胜细胞来解决。簇生柱中的获胜细胞，是指其最佳远端树突段与前一个激活细胞集合匹配分数最高的那个细胞，而一个树突段的匹配分数是其已连接的突触中，其突触前细胞在时间 $t-1$ 处于激活状态的数量。如果匹配分数出现平局，则选择那些匹配的已连接突触的持久性之和最大的细胞来打破平局；如果仍然平局，则选择柱内细胞索引最小的细胞。在该柱中，只有那个获胜细胞变为激活状态。\n\n考虑一个HTM模块，有 $N = 6$ 个柱，索引为 $j \\in \\{0,1,2,3,4,5\\}$，每个柱有 $M = 4$ 个细胞，索引为 $i \\in \\{0,1,2,3\\}$。用一个有序对 $(j,i)$ 表示一个细胞。连接阈值为 $p_c = 0.20$，激活阈值为 $\\theta = 2$。上一个时间步激活的细胞集合是 $S_{t-1}$：\n$$S_{t-1} = \\{(0,2),(2,1),(2,3),(4,2),(5,1),(5,3)\\}.$$\n在当前时间 $t$，考虑新的前馈输入之前，预测细胞集合 $P$ 由下式给出：\n$$P = \\{(0,1),(0,3),(2,0),(4,2),(5,2)\\}.$$\n时间 $t$ 的前馈输入激活了以下柱 $A$：\n$$A = \\{0,1,3,5\\}.$$\n\n为了在簇生柱中选择获胜细胞，仅指定了柱 $1$ 和 $3$ 中细胞的远端树突段结构和突触持久性（所有其他树突段细节可以忽略）。这些细胞中的每一个都有一个远端树突段，具有以下潜在突触和持久性：\n- 柱 $1$：\n  - 细胞 $(1,0)$：到 $(0,2)$ 的潜在突触，持久性为 $0.18$；到 $(2,1)$ 的潜在突触，持久性为 $0.25$；以及到 $(3,2)$ 的潜在突触，持久性为 $0.30$。\n  - 细胞 $(1,1)$：到 $(4,2)$ 的潜在突触，持久性为 $0.19$；以及到 $(5,1)$ 的潜在突触，持久性为 $0.35$。\n  - 细胞 $(1,2)$：到 $(2,3)$ 的潜在突触，持久性为 $0.15$；以及到 $(5,3)$ 的潜在突触，持久性为 $0.21$。\n  - 细胞 $(1,3)$：到 $(0,2)$ 的一个潜在突触，持久性为 $0.22$。\n- 柱 $3$：\n  - 细胞 $(3,0)$：到 $(2,1)$ 的潜在突触，持久性为 $0.19$；以及到 $(4,2)$ 的潜在突触，持久性为 $0.21$。\n  - 细胞 $(3,1)$：到 $(5,3)$ 的一个潜在突触，持久性为 $0.20$。\n  - 细胞 $(3,2)$：到 $(0,2)$ 的一个潜在突触，持久性为 $0.19$。\n  - 细胞 $(3,3)$：到 $(2,3)$ 的潜在突触，持久性为 $0.22$；以及到 $(5,1)$ 的潜在突触，持久性为 $0.18$。\n\n仅使用上述定义和所提供的数据，确定在应用所述的HTM时序记忆选择规则后，在时间 $t$ 将被激活的细胞总数。以整数形式给出答案（无单位）。",
            "solution": "问题要求在一个指定的分层时序记忆 (HTM) 区域中，在时间步 $t$ 将被激活的细胞总数。解决方案需要应用一套规则来确定给定激活柱集合内的激活细胞。\n\n首先，我们整理给定的数据：\n- 柱的数量 $N = 6$，索引为 $j \\in \\{0,1,2,3,4,5\\}$。\n- 每个柱的细胞数量 $M = 4$，索引为 $i \\in \\{0,1,2,3\\}$。\n- 连接阈值 $p_c = 0.20$。\n- 激活阈值 $\\theta = 2$。\n- 上一个时间步 $t-1$ 激活的细胞集合：\n$$S_{t-1} = \\{(0,2),(2,1),(2,3),(4,2),(5,1),(5,3)\\}$$\n- 当前时间步 $t$ 处于预测状态的细胞集合：\n$$P = \\{(0,1),(0,3),(2,0),(4,2),(5,2)\\}$$\n- 时间 $t$ 由前馈输入激活的柱集合：\n$$A = \\{0,1,3,5\\}$$\n- 提供了柱 $j=1$ 和 $j=3$ 中细胞的远端树突段突触持久性。\n\n确定时间 $t$ 的激活细胞（表示为 $S_t$）的过程是检查激活集合 $A$ 中的每个柱 $j$。对于每个这样的柱，我们确定其哪些细胞（如果有的话）将变为激活状态。\n\n规则如下：\n1. 如果一个激活的柱 $j \\in A$ 在预测集合 $P$ 中有一个或多个细胞，则这些预测状态的细胞变为激活状态。\n2. 如果一个激活的柱 $j \\in A$ 在预测集合 $P$ 中没有细胞，则该柱处于“簇生”状态。选择一个“获胜细胞”变为激活状态。获胜者是具有最高“匹配分数”的细胞。\n    - 如果一个突触的持久性大于或等于 $p_c$，则该突触是“连接的”。\n    - 一个树突段的“匹配分数”是其已连接的突触中，其突触前细胞在 $S_{t-1}$ 中的数量。\n    - 最高匹配分数的平局打破规则：首先，按匹配的已连接突触的持久性之和最大者；其次，按最小的细胞索引 $i$。\n\n我们现在将这些规则应用于激活集合 $A = \\{0,1,3,5\\}$ 中的每个柱。\n\n**柱 $j = 0$：**\n该柱在激活集合 $A$ 中。我们通过将柱 $0$ 中的细胞集合（即 $\\{(0,i) \\mid i \\in \\{0,1,2,3\\}\\}$）与预测集合 $P$ 求交集来检查该柱中的预测细胞。\n$P$ 中位于柱 $0$ 的细胞是 $(0,1)$ 和 $(0,3)$。\n由于该柱中有预测细胞，规则1适用。预测细胞 $(0,1)$ 和 $(0,3)$ 变为激活状态。\n来自柱 $0$ 的激活细胞数：$2$。\n\n**柱 $j = 1$：**\n该柱在激活集合 $A$ 中。我们检查该柱中的预测细胞。预测集合 $P$ 中没有形如 $(1,i)$ 的细胞。\n因此，柱 $1$ 处于簇生状态，规则2适用。我们必须通过计算柱 $1$ 中每个细胞的匹配分数来找到获胜细胞。如果一个突触的持久性 $p \\ge p_c = 0.20$，则它是连接的。匹配分数是其突触前细胞在 $S_{t-1}$ 中的已连接突触的数量。\n- **细胞 (1,0):** 到 $(0,2)$ ($p=0.18$)、$(2,1)$ ($p=0.25$)、$(3,2)$ ($p=0.30$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：到 $(2,1)$ 和 $(3,2)$。\n  - 在 $S_{t-1}$ 中的突触前细胞：$(2,1) \\in S_{t-1}$，但 $(3,2) \\notin S_{t-1}$。\n  - 匹配分数 = $1$。\n  - 匹配的已连接突触的持久性之和 = $0.25$。\n- **细胞 (1,1):** 到 $(4,2)$ ($p=0.19$)、$(5,1)$ ($p=0.35$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：到 $(5,1)$。\n  - 在 $S_{t-1}$ 中的突触前细胞：$(5,1) \\in S_{t-1}$。\n  - 匹配分数 = $1$。\n  - 匹配的已连接突触的持久性之和 = $0.35$。\n- **细胞 (1,2):** 到 $(2,3)$ ($p=0.15$)、$(5,3)$ ($p=0.21$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：到 $(5,3)$。\n  - 在 $S_{t-1}$ 中的突触前细胞：$(5,3) \\in S_{t-1}$。\n  - 匹配分数 = $1$。\n  - 匹配的已连接突触的持久性之和 = $0.21$。\n- **细胞 (1,3):** 到 $(0,2)$ ($p=0.22$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：到 $(0,2)$。\n  - 在 $S_{t-1}$ 中的突触前细胞：$(0,2) \\in S_{t-1}$。\n  - 匹配分数 = $1$。\n  - 匹配的已连接突触的持久性之和 = $0.22$。\n\n所有四个细胞的匹配分数都为 $1$。我们使用第一个平局打破规则：选择匹配的突触持久性之和最大的细胞。\n- (1,0): 和 = $0.25$\n- (1,1): 和 = $0.35$\n- (1,2): 和 = $0.21$\n- (1,3): 和 = $0.22$\n最大和为 $0.35$，对应于细胞 $(1,1)$。因此，细胞 $(1,1)$ 是获胜者。\n来自柱 $1$ 的激活细胞数：$1$。\n\n**柱 $j = 3$：**\n该柱在激活集合 $A$ 中。我们检查预测细胞。预测集合 $P$ 中没有形如 $(3,i)$ 的细胞。\n因此，柱 $3$ 处于簇生状态，规则2适用。我们计算柱 $3$ 中每个细胞的匹配分数。\n- **细胞 (3,0):** 到 $(2,1)$ ($p=0.19$)、$(4,2)$ ($p=0.21$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：到 $(4,2)$。\n  - 在 $S_{t-1}$ 中的突触前细胞：$(4,2) \\in S_{t-1}$。\n  - 匹配分数 = $1$。\n  - 匹配的已连接突触的持久性之和 = $0.21$。\n- **细胞 (3,1):** 到 $(5,3)$ ($p=0.20$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：到 $(5,3)$，因为 $0.20 \\ge p_c$。\n  - 在 $S_{t-1}$ 中的突触前细胞：$(5,3) \\in S_{t-1}$。\n  - 匹配分数 = $1$。\n  - 匹配的已连接突触的持久性之和 = $0.20$。\n- **细胞 (3,2):** 到 $(0,2)$ ($p=0.19$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：无。\n  - 匹配分数 = $0$。\n- **细胞 (3,3):** 到 $(2,3)$ ($p=0.22$)、$(5,1)$ ($p=0.18$) 的潜在突触。\n  - 已连接的突触 ($p \\ge 0.20$)：到 $(2,3)$。\n  - 在 $S_{t-1}$ 中的突触前细胞：$(2,3) \\in S_{t-1}$。\n  - 匹配分数 = $1$。\n  - 匹配的已连接突触的持久性之和 = $0.22$。\n\n细胞 $(3,0)$、$(3,1)$ 和 $(3,3)$ 的最高匹配分数为 $1$。我们使用第一个平局打破规则：\n- (3,0): 和 = $0.21$\n- (3,1): 和 = $0.20$\n- (3,3): 和 = $0.22$\n最大和为 $0.22$，对应于细胞 $(3,3)$。因此，细胞 $(3,3)$ 是获胜者。\n来自柱 $3$ 的激活细胞数：$1$。\n\n**柱 $j = 5$：**\n该柱在激活集合 $A$ 中。我们检查预测细胞。细胞 $(5,2)$ 在预测集合 $P$ 中。\n由于该柱中有预测细胞，规则1适用。预测细胞 $(5,2)$ 变为激活状态。\n来自柱 $5$ 的激活细胞数：$1$。\n\n**激活细胞总数：**\n为求出时间 $t$ 激活的细胞总数，我们将 $A$ 中每个柱的激活细胞数相加：\n- 来自柱 $0$：$2$ 个细胞（$(0,1)$ 和 $(0,3)$）\n- 来自柱 $1$：$1$ 个细胞（$(1,1)$）\n- 来自柱 $3$：$1$ 个细胞（$(3,3)$）\n- 来自柱 $5$：$1$ 个细胞（$(5,2)$）\n\n总激活细胞数 = $2 + 1 + 1 + 1 = 5$。\n时间 $t$ 的激活细胞集合是 $S_t = \\{(0,1), (0,3), (1,1), (3,3), (5,2)\\}$。该集合的大小为 $5$。\n激活阈值 $\\theta=2$ 已给出，但在计算中并未使用，因为预测细胞集合 $P$ 是直接提供的。该信息是HTM一般描述的一部分，但对于此特定计算不是必需的。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "在掌握了细胞激活的机制之后，我们现在来探究时间记忆模块的一项更高级的能力：解决序列中的歧义性。在许多现实世界的场景中，同一事件可能出现在不同的上下文中。这个思想实验将时间记忆的核心约束条件——例如每柱细胞数（$C$）和树突段激活阈值（$\\theta$）——进行抽象化，以分析其处理歧义的能力。通过对这些系统限制进行形式化分析，您将更深入地理解HTM的结构如何使其能够表征不同的时间上下文 。",
            "id": "4047299",
            "problem": "您需要在一个简化的分层时间记忆（HTM）时间记忆模型中，针对无噪声操作和收敛学习条件下的模糊序列预测，形式化并计算两个量。\n\n基本原理和定义：\n- 在由 Numenta 提出的分层时间记忆（HTM）的时间记忆部分，时变输入被编码为在皮层柱上的稀疏分布式表示。每个皮层柱包含多个细胞，这些细胞可以在不同的时间上下文中表示相同的前馈特征。令 $C$ 表示每个皮层柱的细胞数量。\n- 如果一个细胞的任何远端树突段被激活，该细胞就会进入预测状态。如果一个远端树突段从前一时间步激活的细胞接收输入的连接突触数量至少达到一个阈值 $\\theta$（树突段激活阈值），则该树突段被激活。前一激活集的大小表示为 $M$（前一时间步的激活突触前细胞数量）。在无噪声输入和适当的树突段形成下，学习确保了对于每个真实观察到的转换，在一个专用细胞上存在一个树突段，该树突段与相关的前一激活细胞有至少 $\\theta$ 个连接的突触，前提是 $M \\ge \\theta$。\n- 考虑离散符号序列，其中每个符号映射到一个不同的皮层柱。令 $X$ 为一个在多个序列中作为末尾符号出现的符号。令 $K$ 表示在训练数据中导致 $X$ 出现的不同前驱时间上下文的数量。例如，在共享 $X$ 的序列对 $ABX$ 和 $ACX$ 中，$X$ 的不同前驱上下文数量为 $K=2$，因为 $B$ 和 $C$ 是不同的。\n- 定义 $X$ 的消歧时间为最小整数 $t \\ge 0$，使得在 $X$ 之前的最后 $t$ 个观察到的时间步足以在所有以 $X$ 结尾的序列中，为 $X$ 所在的皮层柱选择一个唯一的预测细胞。如果容量或树突段约束使得对于至少一个上下文来说这是不可能的，则将消歧时间定义为 $-1$。\n- 定义 $X$ 的预测细胞分配为在上述假设下，$X$ 所在皮层柱中专门用于（学习后）不同前驱上下文的不同细胞的数量。\n\n假设：\n- 输入是无噪声的。\n- 适当的树突段形成：对于任何实际观察到的转换和任何需要预测的上下文，只要 $M \\ge \\theta$，就存在一个远端树突段，其与先前激活的细胞有至少 $\\theta$ 个连接的突触。\n- 容量限制：对于同一符号，最多有 $C$ 个不同的上下文可以映射到该符号所在皮层柱中的唯一细胞上。\n\n任务：\n1. 仅使用上述定义和假设，推导并实现一个函数，该函数在给定 $(C,\\theta,K,M)$ 的情况下，返回\n   - $X$ 的消歧时间（整数），以及\n   - $X$ 的预测细胞分配（整数）。\n2. 将抽象设定具体化，用于共享 $X$ 的模糊序列 $ABX$ 和 $ACX$，其中 $C=32$ 且 $\\theta=15$，在无噪声输入和适当树突段形成的条件下。将直接前驱上下文视为不同的，并假设 $M \\ge \\theta$ 以便学习到的树突段可以被激活。计算此情况下的消歧时间和预测细胞分配。\n\n测试套件：\n实现您的程序以计算以下参数集的结果，每个参数集表示为一个元组 $(C,\\theta,K,M)$：\n- 案例 1（理想路径，$ABX$ 和 $ACX$ 设定）：$(32,15,2,20)$。\n- 案例 2（容量边界相等）：$(32,15,32,20)$。\n- 案例 3（超出容量，至少一个上下文无法解决）：$(32,15,40,20)$。\n- 案例 4（单上下文平凡情况）：$(32,15,1,20)$。\n- 案例 5（阈值边界，突触前支持恰好足够）：$(8,15,8,15)$。\n- 案例 6（极低容量）：$(1,15,2,20)$。\n\n所需输出：\n- 对于每个案例，输出一个双元素列表 $[t,A]$，其中 $t$ 是消歧时间，$A$ 是预测细胞分配。\n- 您的程序应生成单行输出，其中包含结果，格式为由逗号分隔的双元素列表组成的列表，用方括号括起来，并按上述案例的顺序排列。例如：\"[[t1,A1],[t2,A2],...[t6,A6]]\"。\n- 所有答案都是没有单位的整数。",
            "solution": "本问题要求在一个简化的分层时间记忆（HTM）模型中，对出现在 $K$ 个不同时间上下文中的符号 $X$ 的两个指标进行形式化和计算：预测细胞分配（$A$）和消歧时间（$t$）。计算基于四个参数：每个皮层柱的细胞数量（$C$）、树突段激活阈值（$\\theta$）、不同前驱上下文的数量（$K$）以及来自前一时间步的激活突触前细胞数量（$M$）。\n\n解决方案是通过分析模型定义所施加的约束来推导的。\n\n首先，我们分析一个细胞进入预测状态的基本操作要求。一个细胞在其某个远端树突段被激活时进入预测状态。一个树突段如果从前一时间步接收到至少 $\\theta$ 个激活细胞的输入，则该树突段被激活。问题陈述中说明，此类激活的突触前细胞数量为 $M$。假设学习已经收敛，这意味着存在一个与正确的突触前细胞集有连接的树突段。然而，为了使该树突段被激活，可用激活输入数量 $M$ 必须至少达到阈值 $\\theta$。这建立了**树突段激活约束**：\n$$\nM \\ge \\theta\n$$\n如果 $M  \\theta$，无论树突段学习得多好，它都无法被激活。因此，$X$ 所在皮层柱中的任何细胞都无法进入预测状态。这代表了预测机制的根本性失败。\n\n其次，我们分析唯一上下文表示的条件。问题指明有 $K$ 个不同的时间上下文导致符号 $X$ 的出现。为了完美地对这些上下文进行消歧，系统必须在 $X$ 的皮层柱中为每个不同的上下文分配一个唯一的细胞。$X$ 的皮层柱具有 $C$ 个细胞的有限容量。这建立了**皮层柱容量约束**：\n$$\nK \\le C\n$$\n如果 $K > C$，则上下文的数量超过了可用细胞的数量，使得无法为每个上下文分配一个唯一的细胞。至少有 $K-C$ 个上下文要么不会被表示，要么会被模糊地映射到也代表其他上下文的细胞上。\n\n有了这两个约束，我们就可以推导出预测细胞分配（$A$）和消歧时间（$t$）。\n\n**预测细胞分配（$A$）的推导**\n预测细胞分配 $A$ 是 $X$ 皮层柱中专门用于表示前驱上下文的不同细胞的数量。\n\n1.  如果不满足树突段激活约束（即 $M  \\theta$），则无法形成任何预测。没有细胞可以被可靠地置于预测状态，因此没有细胞被分配。所以，\n    $$A = 0 \\quad \\text{如果 } M  \\theta$$\n\n2.  如果满足树突段激活约束（即 $M \\ge \\theta$），则系统功能正常，细胞分配取决于容量 $C$ 相对于上下文数量 $K$。\n    -   如果 $K \\le C$，则有足够的容量为 $K$ 个上下文中的每一个分配一个唯一的细胞。分配的细胞总数为 $A = K$。\n    -   如果 $K > C$，则容量被超出。系统最多只能利用其所有可用细胞。用于预测的不同细胞的数量将是皮层柱中的细胞总数，即 $C$。因此，$A = C$。\n    \n综合这些情况，对于一个功能正常的系统（$M \\ge \\theta$），分配的细胞数是上下文数量和可用细胞数量的最小值。$A$ 的完整公式是：\n$$\nA = \\begin{cases} 0  \\text{如果 } M  \\theta \\\\ \\min(K, C)  \\text{如果 } M \\ge \\theta \\end{cases}\n$$\n\n**消歧时间（$t$）的推导**\n消歧时间 $t$ 是为一个给定上下文选择一个唯一预测细胞所需的最小历史长度。根据定义，如果对于任何上下文，唯一选择是不可能的，则 $t = -1$。\n\n1.  失败条件：如果两个基本约束中的任何一个被违反，就无法选择一个唯一的预测细胞。\n    -   如果 $M  \\theta$，预测在全系统范围内失败。消歧是不可能的。\n    -   如果 $K > C$，则无法为 $K$ 个上下文中的每一个分配一个唯一的细胞。不满足消歧的定义。\n    在这两种失败场景中，消歧时间被定义为 $-1$。\n    $$\n    t = -1 \\quad \\text{如果 } M  \\theta \\text{ 或 } K > C\n    $$\n\n2.  成功条件：如果两个约束都得到满足（$M \\ge \\theta$ 且 $K \\le C$），系统就具备成功消歧的必要资源。$t$ 的值取决于是否存在需要解决的模糊性。\n    -   如果 $K=1$，只有一个上下文。不同上下文之间没有模糊性。因此，*消歧*所需的时间为 0。\n        $$t = 0 \\quad \\text{如果 } M \\ge \\theta \\text{ 且 } K = 1$$\n    -   如果 $K > 1$，则存在必须解决的模糊性。问题的结构设定为，$K$ 个上下文被指定为“不同的前驱时间上下文”，例如序列 $A \\rightarrow B \\rightarrow X$ 和 $A \\rightarrow C \\rightarrow X$ 中，由于直接前驱 $B$ 和 $C$ 是不同的，因此 $K=2$。这意味着通过观察紧邻的前一个时间步的状态就可以区分上下文。因此，回溯一个时间步就足以解决模糊性。因此，最小的非负整数时间是 1。\n        $$t = 1 \\quad \\text{如果 } M \\ge \\theta \\text{ 且 } 1  K \\le C$$\n\n**计算逻辑总结**\n给定一组参数 $(C, \\theta, K, M)$，$t$ 和 $A$ 的值按以下方式确定：\n\n1.  检查树突段激活约束：如果 $M  \\theta$，返回 $[t, A] = [-1, 0]$。\n2.  否则，检查皮层柱容量约束：如果 $K > C$，返回 $[t, A] = [-1, C]$。\n3.  否则（如果 $M \\ge \\theta$ 且 $K \\le C$），系统正常运行：\n    -   预测细胞分配为 $A = K$。\n    -   如果 $K=1$，消歧时间为 $t=0$；如果 $K>1$，消歧时间为 $t=1$。\n    -   返回 $[t, A]$。\n\n将此逻辑应用于每个测试案例以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the disambiguation time and predictive cell allocation\n    for a simplified HTM model based on the provided parameters.\n    \"\"\"\n\n    # Test cases are provided as tuples of (C, theta, K, M).\n    # C: number of cells per column\n    # theta: segment activation threshold\n    # K: number of distinct predecessor contexts\n    # M: number of active presynaptic cells\n    test_cases = [\n        (32, 15, 2, 20),   # Case 1: Standard ambiguous case (e.g., ABX/ACX)\n        (32, 15, 32, 20),  # Case 2: Capacity boundary equality\n        (32, 15, 40, 20),  # Case 3: Over capacity\n        (32, 15, 1, 20),   # Case 4: Single, unambiguous context\n        (8, 15, 8, 15),    # Case 5: Threshold boundary equality\n        (1, 15, 2, 20),    # Case 6: Extreme low capacity\n    ]\n\n    results = []\n    for case in test_cases:\n        C, theta, K, M = case\n        \n        # Initialize t (disambiguation time) and A (predictive cell allocation)\n        t = 0\n        A = 0\n\n        # 1. Validate the Segment Activation Constraint.\n        # If the number of active presynaptic cells M is less than the\n        # activation threshold theta, no segment can become active, and thus\n        # no predictions can be formed.\n        if M  theta:\n            t = -1\n            A = 0\n            results.append([t, A])\n            continue\n\n        # At this point, M >= theta, so the system is potentially functional.\n        \n        # 2. Validate the Column Capacity Constraint.\n        # If the number of distinct contexts K exceeds the number of cells C in the\n        # column, it is impossible to assign a unique cell to each context.\n        # This makes disambiguation impossible.\n        if K > C:\n            t = -1\n            # The number of allocated cells is capped by the column's capacity.\n            A = C\n            results.append([t, A])\n            continue\n\n        # At this point, M >= theta and K = C, so the system can\n        # successfully perform disambiguation.\n\n        # 3. Calculate A and t for the successful case.\n        # The number of allocated cells equals the number of contexts, as there\n        # is enough capacity.\n        A = K\n\n        # The disambiguation time depends on whether there is any ambiguity.\n        if K == 1:\n            # If there is only one context, there is no ambiguity to resolve.\n            # The minimal time to disambiguate is 0.\n            t = 0\n        else: # K > 1\n            # If there is more than one context, an ambiguity exists.\n            # The problem framing implies contexts are distinguishable by the\n            # immediate predecessor, so a look-back of 1 time step is sufficient.\n            t = 1\n\n        results.append([t, A])\n\n    # The final output must be a single line, formatted as a string\n    # representation of a list of lists.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}