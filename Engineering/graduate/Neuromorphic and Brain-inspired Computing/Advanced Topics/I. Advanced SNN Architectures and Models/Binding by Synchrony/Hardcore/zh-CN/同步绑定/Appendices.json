{
    "hands_on_practices": [
        {
            "introduction": "要理解大规模的神经同步，我们首先需要从最基本的构建单元开始：两个相互作用的振荡器。这个练习将引导您推导两个具有不同内禀频率的神经振荡器实现锁相的条件。通过运用相位缩减和平均化理论，您将揭示振荡器频率失配（$Δω$）与它们之间耦合强度（$K$）之间的根本性竞争关系，这是理解大脑中同步如何建立和维持的关键第一步 。",
            "id": "4037645",
            "problem": "两个弱耦合的神经形态振荡器代表了两个特征编码集群，它们之间的绑定是通过相位同步实现的。设集群的相位分别为 $\\,\\theta_{1}(t)\\,$ 和 $\\,\\theta_{2}(t)\\,$，其内禀角频率分别为 $\\,\\omega_{1}\\,$ 和 $\\,\\omega_{2} = \\omega_{1} + \\Delta\\omega\\,$。假设耦合足够弱，以至于相位缩减和平均理论适用：每个振荡器的相位遵循\n$$\n\\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\epsilon\\,Z(\\theta_{i})\\,I(\\theta_{j}), \\quad i\\neq j,\n$$\n其中 $\\,\\epsilon0\\,$ 是一个小的耦合参数，$\\,Z(\\theta)\\,$ 是 $2\\pi$-周期的无穷小相位响应曲线 (PRC)，而 $\\,I(\\theta)\\,$ 是由另一个振荡器状态引起的 $2\\pi$-周期的相互作用波形。考虑一个生物学上合理的II型PRC和一个由一阶傅里叶谐波主导的兴奋性相互作用，模型如下\n$$\nZ(\\theta) = \\cos\\theta, \\qquad I(\\theta) = \\sin\\theta.\n$$\n定义相位差 $\\,\\phi(t) = \\theta_{2}(t) - \\theta_{1}(t)\\,$。使用平均理论在一个周期内对 $\\,\\epsilon\\,$ 的主导阶进行平均，推导出 $\\,\\phi(t)\\,$ 的慢动力学，并获得以 $\\,\\Delta\\omega\\,$ 和有效耦合强度为函数的锁相条件。然后，对于 $\\,\\Delta\\omega0\\,$ 和正的有效耦合 $\\,K0\\,$，以闭式解计算稳定的锁定相位差 $\\,\\phi^{\\ast}\\,$。以弧度表示 $\\,\\phi^{\\ast}\\,$。最终答案必须仅为 $\\,\\phi^{\\ast}\\,$ 的解析表达式。",
            "solution": "题目提供了一个由两个弱耦合神经形态振荡器组成的系统，其相位 $\\theta_{1}(t)$ 和 $\\theta_{2}(t)$ 由以下微分方程控制：\n$$\n\\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\epsilon\\,Z(\\theta_{i})\\,I(\\theta_{j}), \\quad i,j \\in \\{1,2\\}, i\\neq j\n$$\n内禀角频率给定为 $\\omega_{1}$ 和 $\\omega_{2} = \\omega_{1} + \\Delta\\omega$。耦合强度 $\\epsilon$ 是一个小的正参数，$\\epsilon  0$。相位响应曲线 (PRC) 为 $Z(\\theta) = \\cos\\theta$，相互作用函数为 $I(\\theta) = \\sin\\theta$。\n\n首先，我们写出两个振荡器的显式方程：\n$$\n\\frac{d\\theta_{1}}{dt} = \\omega_{1} + \\epsilon\\,Z(\\theta_{1})\\,I(\\theta_{2}) = \\omega_{1} + \\epsilon\\,\\cos(\\theta_{1})\\,\\sin(\\theta_{2})\n$$\n$$\n\\frac{d\\theta_{2}}{dt} = \\omega_{2} + \\epsilon\\,Z(\\theta_{2})\\,I(\\theta_{1}) = \\omega_{2} + \\epsilon\\,\\cos(\\theta_{2})\\,\\sin(\\theta_{1})\n$$\n\n我们关心的是相位差的动力学，定义为 $\\phi(t) = \\theta_{2}(t) - \\theta_{1}(t)$。我们通过对其求时间导数来找到 $\\phi(t)$ 的微分方程：\n$$\n\\frac{d\\phi}{dt} = \\frac{d\\theta_{2}}{dt} - \\frac{d\\theta_{1}}{dt}\n$$\n代入 $\\frac{d\\theta_{1}}{dt}$ 和 $\\frac{d\\theta_{2}}{dt}$ 的表达式：\n$$\n\\frac{d\\phi}{dt} = \\left(\\omega_{2} + \\epsilon\\,\\cos(\\theta_{2})\\,\\sin(\\theta_{1})\\right) - \\left(\\omega_{1} + \\epsilon\\,\\cos(\\theta_{1})\\,\\sin(\\theta_{2})\\right)\n$$\n按 $\\omega$ 和 $\\epsilon$ 对各项进行分组：\n$$\n\\frac{d\\phi}{dt} = (\\omega_{2} - \\omega_{1}) + \\epsilon \\left( \\cos(\\theta_{2})\\,\\sin(\\theta_{1}) - \\cos(\\theta_{1})\\,\\sin(\\theta_{2}) \\right)\n$$\n使用定义 $\\Delta\\omega = \\omega_{2} - \\omega_{1}$ 和差值正弦的三角恒等式 $\\sin(A-B) = \\sin(A)\\cos(B) - \\cos(A)\\sin(B)$：\n$$\n\\frac{d\\phi}{dt} = \\Delta\\omega + \\epsilon \\sin(\\theta_{1} - \\theta_{2})\n$$\n因为 $\\phi = \\theta_{2} - \\theta_{1}$，我们有 $\\theta_{1} - \\theta_{2} = -\\phi$。因此：\n$$\n\\frac{d\\phi}{dt} = \\Delta\\omega + \\epsilon \\sin(-\\phi) = \\Delta\\omega - \\epsilon \\sin(\\phi)\n$$\n\n这个方程描述了相位差 $\\phi(t)$ 的精确动力学。在这个特殊情况下，因为 PRC 和相互作用函数被给定为一阶傅里叶谐波，相位差的动力学与单个相位完全解耦。根据题目的要求，对于更一般的 $Z(\\theta)$ 和 $I(\\theta)$，形式上需要应用平均理论，但在本例中，这会得到相同的结果。为了证明这一点，设耦合项为 $G(\\theta_1, \\theta_2) = Z(\\theta_2)I(\\theta_1) - Z(\\theta_1)I(\\theta_2)$。我们通过代入 $\\theta_2 = \\theta_1 + \\phi$，将其用一个相位（比如 $\\theta_1$）和相位差 $\\phi$ 来表示：\n$$ G(\\theta_1, \\phi) = \\cos(\\theta_1+\\phi)\\sin(\\theta_1) - \\cos(\\theta_1)\\sin(\\theta_1+\\phi) = \\sin(\\theta_1 - (\\theta_1+\\phi)) = -\\sin(\\phi) $$\n平均理论指出，$\\phi$ 的慢动力学由耦合项在快变量 $\\theta_1$ 上（在一个 $2\\pi$ 区间内）的平均值决定：\n$$ \\langle G(\\phi) \\rangle = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} G(\\theta, \\phi) d\\theta = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} (-\\sin(\\phi)) d\\theta $$\n由于 $-\\sin(\\phi)$ 相对于积分变量 $\\theta$ 是常数，所以平均值就是：\n$$ \\langle G(\\phi) \\rangle = -\\sin(\\phi) $$\n因此，$\\phi$ 的慢动力学的平均方程为：\n$$\n\\frac{d\\phi}{dt} = \\Delta\\omega + \\epsilon \\langle G(\\phi) \\rangle = \\Delta\\omega - \\epsilon \\sin(\\phi)\n$$\n这证实了之前推导出的方程，即阿德勒方程 (Adler equation)。\n\n当相位差达到一个恒定值 $\\phi^{\\ast}$ 时，就会发生锁相，这个值是动力学系统的一个稳定不动点。在不动点处，$\\frac{d\\phi}{dt} = 0$：\n$$\n\\Delta\\omega - \\epsilon \\sin(\\phi^{\\ast}) = 0 \\implies \\sin(\\phi^{\\ast}) = \\frac{\\Delta\\omega}{\\epsilon}\n$$\n为了使 $\\phi^{\\ast}$ 的实数解存在，正弦函数的值必须在其范围 $[-1, 1]$ 内。这给出了锁相的条件：\n$$\n\\left| \\frac{\\Delta\\omega}{\\epsilon} \\right| \\le 1 \\implies |\\Delta\\omega| \\le \\epsilon\n$$\n量 $\\epsilon$ 代表了耦合对相位差动力学影响的大小，因此被确定为有效耦合强度。题目要求在最后部分用 $K$ 表示它。设 $K = \\epsilon$。因为 $\\epsilon  0$，所以我们有 $K  0$。锁相条件是 $|\\Delta\\omega| \\le K$。\n\n为了找到稳定的锁定相位差，我们必须分析不动点的稳定性。方程 $\\frac{d\\phi}{dt} = f(\\phi)$ 的一个不动点 $\\phi^{\\ast}$ 是稳定的，如果 $f'(\\phi^{\\ast})  0$。这里，$f(\\phi) = \\Delta\\omega - K \\sin(\\phi)$。其导数为：\n$$\nf'(\\phi) = \\frac{d}{d\\phi} (\\Delta\\omega - K \\sin(\\phi)) = -K \\cos(\\phi)\n$$\n因此，稳定性条件是 $-K \\cos(\\phi^{\\ast})  0$。\n\n题目指定了条件 $\\Delta\\omega  0$ 和 $K  0$。在这些条件下：\n1.  从不动点方程可知，$\\sin(\\phi^{\\ast}) = \\frac{\\Delta\\omega}{K}  0$。这意味着 $\\phi^{\\ast}$ 必须在第一或第二象限，即 $0  \\phi^{\\ast}  \\pi$。\n2.  从稳定性条件可知，由于 $K  0$，我们要求 $-K \\cos(\\phi^{\\ast})  0$，这简化为 $\\cos(\\phi^{\\ast})  0$。这意味着 $\\phi^{\\ast}$ 必须在第一或第四象限。\n\n结合这两个要求，稳定的锁相状态 $\\phi^{\\ast}$ 必须位于第一象限，此时其正弦和余弦值均为正。方程 $\\sin(\\phi) = \\frac{\\Delta\\omega}{K}$ 在区间 $[0, 2\\pi)$ 内有两个解：\n- $\\phi_{1}^{\\ast} = \\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$\n- $\\phi_{2}^{\\ast} = \\pi - \\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$\n\n鉴于 $|\\frac{\\Delta\\omega}{K}| \\le 1$ 且 $\\frac{\\Delta\\omega}{K}  0$，$\\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$ 的值在区间 $(0, \\frac{\\pi}{2}]$ 内。\n- 对于第一个解 $\\phi_{1}^{\\ast}$，我们有 $0  \\phi_{1}^{\\ast} \\le \\frac{\\pi}{2}$。在此区间内，$\\cos(\\phi_{1}^{\\ast}) \\ge 0$。稳定性条件 $\\cos(\\phi^{\\ast})0$ 得到满足（不包括稳定性为中性的边界情况 $|\\Delta\\omega|=K$）。这是稳定不动点。\n- 对于第二个解 $\\phi_{2}^{\\ast}$，我们有 $\\frac{\\pi}{2} \\le \\phi_{2}^{\\ast}  \\pi$。在此区间内，$\\cos(\\phi_{2}^{\\ast}) \\le 0$。稳定性条件 $\\cos(\\phi^{\\ast})0$ 未得到满足。这是不稳定不动点。\n\n因此，在给定条件下，唯一的稳定锁定相位差是 $\\phi^{\\ast} = \\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$。",
            "answer": "$$\n\\boxed{\\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)}\n$$"
        },
        {
            "introduction": "真实的神经系统由大量神经元组成，并且不可避免地受到噪声的干扰。本练习将我们的视角从简单的双振荡器系统扩展到一个庞大的振荡器群体，并探讨噪声如何影响集体同步。您将使用来自统计力学的强大工具——Fokker–Planck 方程——来推导出一个关键的自洽关系，该关系描述了从无序到同步的相变，并揭示了系统在噪声存在下维持同步的临界条件 。",
            "id": "4037607",
            "problem": "考虑一个由相同的相位振荡器组成的大型布居，这些振荡器代表了神经形态系统中的特征绑定单元。振荡器的相位由 $\\theta \\in [0, 2\\pi)$ 表示，在全局正弦耦合和加性高斯白相位噪声的作用下，其在单位圆上演化。在热力学极限下，假设在随布居平均相位旋转的参考系中，单个振荡器的相位动力学具有以下形式\n$$\nd\\theta = v(\\theta)\\,dt + \\sqrt{2D}\\,dW(t),\n$$\n其中 $v(\\theta)$ 是由平均场决定的平滑的 $2\\pi$ 周期漂移，$D0$ 是由相位噪声引起的扩散常数。令布居平均同步态由 Kuramoto 序参量 $r \\in [0,1]$ 来量化，其定义为\n$$\nr\\,\\exp(i\\psi) = \\int_{0}^{2\\pi} \\exp(i\\theta)\\,p(\\theta)\\,d\\theta,\n$$\n其中 $p(\\theta)$ 是相位的稳态概率密度函数 (PDF)，$\\psi$ 是平均相位。在平均场近似下，取漂移为正弦相互作用 $v(\\theta) = -K r \\sin\\theta$，其中 $K0$ 是均匀耦合强度，并且已选择参考系使得 $\\psi=0$。假设稳态相位密度 $p(\\theta)$ 是 $2\\pi$ 周期的且可归一化的，并且稳态性意味着圆上的概率流为零。\n\n从 $p(\\theta,t)$ 的 Fokker-Planck 方程和上述定义出发，推导稳态相位密度 $p_{*}(\\theta)$ 以及连接 $r$ 和 $D$ 的自洽关系。然后，关注同步绑定的起始（即 $r$ 很小的区域），进行系统的小参数展开，以获得刚好在去同步阈值以下的稳态序参量 $r(D)$ 的领先阶显式解析表达式，该表达式用 $K$ 和 $D$ 表示。以闭合形式提供 $r(D)$ 的最终表达式，该表达式在控制到阈值距离的小参数下领先阶有效。不需要进行数值舍入，最终结果是无量纲的。",
            "solution": "本问题要求在向同步转变的邻域内，推导稳态序参量 $r$ 作为噪声强度 $D$ 和耦合强度 $K$ 的函数。推导过程分为三个主要步骤：1. 从 Fokker-Planck 方程求出稳态概率密度函数 (PDF)。2. 建立序参量 $r$ 的自洽方程。3. 进行小 $r$ 展开，以找到去同步阈值附近的领先阶行为。\n\n**第一步：稳态 Fokker-Planck 方程及其解**\n\n单个振荡器相位 $\\theta$ 的动力学由朗之万方程给出：\n$$\nd\\theta = v(\\theta)\\,dt + \\sqrt{2D}\\,dW(t)\n$$\n其中漂移为 $v(\\theta) = -K r \\sin\\theta$，其中 $K  0$ 是耦合强度，$r \\in [0,1]$ 是 Kuramoto 序参量，$D  0$ 是噪声引起的扩散常数。\n\n对应的概率密度 $p(\\theta, t)$ 的 Fokker-Planck 方程为：\n$$\n\\frac{\\partial p}{\\partial t} = -\\frac{\\partial}{\\partial \\theta} [v(\\theta)p] + D\\frac{\\partial^2 p}{\\partial \\theta^2}\n$$\n这可以写成概率流 $J(\\theta, t)$ 的形式：\n$$\n\\frac{\\partial p}{\\partial t} = -\\frac{\\partial J}{\\partial \\theta}, \\quad \\text{其中} \\quad J(\\theta,t) = v(\\theta)p(\\theta,t) - D\\frac{\\partial p(\\theta,t)}{\\partial \\theta}\n$$\n在稳态下，$\\frac{\\partial p}{\\partial t} = 0$，这意味着稳态概率流 $J_*$ 对于 $\\theta$ 必须是常数。对于一个在周期势作用下处于圆上的系统，为了维持稳态，净流量必须为零，因此我们施加条件 $J_* = 0$。这给出了稳态 PDF $p_*(\\theta)$ 的常微分方程：\n$$\nv(\\theta)p_*(\\theta) - D\\frac{d p_*(\\theta)}{d \\theta} = 0\n$$\n代入 $v(\\theta) = -K r \\sin\\theta$：\n$$\n-K r \\sin\\theta \\, p_*(\\theta) = D\\frac{d p_*(\\theta)}{d \\theta}\n$$\n这是一个可分离的一阶常微分方程。我们可以写成：\n$$\n\\frac{d p_*}{p_*} = -\\frac{K r}{D} \\sin\\theta \\, d\\theta\n$$\n对两边积分得到：\n$$\n\\ln(p_*(\\theta)) = \\frac{K r}{D} \\cos\\theta + C'\n$$\n其中 $C'$ 是积分常数。取指数得到未归一化的 PDF：\n$$\np_*(\\theta) = C \\exp\\left(\\frac{K r}{D} \\cos\\theta\\right)\n$$\n其中 $C = \\exp(C')$。归一化常数 $C$ 由条件 $\\int_{0}^{2\\pi} p_*(\\theta) \\, d\\theta = 1$ 确定。\n$$\n1 = C \\int_{0}^{2\\pi} \\exp\\left(\\frac{K r}{D} \\cos\\theta\\right) d\\theta\n$$\n该积分与零阶第一类修正贝塞尔函数 $I_0(z)$ 相关，其定义为 $I_0(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(z \\cos\\phi) \\, d\\phi$。因此，该积分为 $2\\pi I_0(Kr/D)$。归一化常数为 $C = \\frac{1}{2\\pi I_0(Kr/D)}$。\n\n因此，稳态相位密度为：\n$$\np_*(\\theta) = \\frac{\\exp\\left(\\frac{K r}{D} \\cos\\theta\\right)}{2\\pi I_0\\left(\\frac{K r}{D}\\right)}\n$$\n这被称为 von Mises 分布。\n\n**第二步：自洽关系**\n\n序参量 $r$ 由 $r\\,\\exp(i\\psi) = \\int_{0}^{2\\pi} \\exp(i\\theta)\\,p(\\theta)\\,d\\theta$ 定义。在已选择参考系使得平均相位 $\\psi=0$ 的情况下，我们有：\n$$\nr = \\int_{0}^{2\\pi} \\cos(\\theta) p_*(\\theta) \\, d\\theta + i \\int_{0}^{2\\pi} \\sin(\\theta) p_*(\\theta) \\, d\\theta\n$$\n由于 $p_*(\\theta)$ 是 $\\theta$ 的偶函数（因为 $\\cos\\theta$ 是偶函数），含有 $\\sin\\theta$ 的积分为零。这证实了选择 $\\psi=0$ 的一致性。$r$ 的自洽关系为：\n$$\nr = \\int_{0}^{2\\pi} \\cos(\\theta) \\frac{\\exp\\left(\\frac{K r}{D} \\cos\\theta\\right)}{2\\pi I_0\\left(\\frac{K r}{D}\\right)} d\\theta\n$$\n分子中的积分与一阶第一类修正贝塞尔函数 $I_1(z)$ 相关，其定义为 $I_1(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\cos(\\theta) \\exp(z \\cos\\theta) \\, d\\theta$。因此，该积分为 $2\\pi I_1(Kr/D)$。\n将此代入 $r$ 的方程，我们得到超越自洽方程：\n$$\nr = \\frac{I_1\\left(\\frac{K r}{D}\\right)}{I_0\\left(\\frac{K r}{D}\\right)}\n$$\n\n**第三步：去同步阈值附近的小参数展开**\n\n我们关心的是同步的起始，这对应于序参量 $r$ 为小正数的区域。令 $x = Kr/D$。由于 $r \\to 0^+$，我们有 $x \\to 0^+$。我们使用贝塞尔函数在小宗量下的级数展开：\n$$\nI_0(x) = 1 + \\frac{x^2}{4} + O(x^4)\n$$\n$$\nI_1(x) = \\frac{x}{2} + \\frac{x^3}{16} + O(x^5)\n$$\n那么比值为：\n$$\n\\frac{I_1(x)}{I_0(x)} = \\frac{\\frac{x}{2} + \\frac{x^3}{16} + \\dots}{1 + \\frac{x^2}{4} + \\dots} = \\left(\\frac{x}{2} + \\frac{x^3}{16}\\right)\\left(1 - \\frac{x^2}{4}\\right) + O(x^5) = \\frac{x}{2} - \\frac{x^3}{8} + \\frac{x^3}{16} + O(x^5) = \\frac{x}{2} - \\frac{x^3}{16} + O(x^5)\n$$\n将此展开式代回自洽方程 $r = I_1(x)/I_0(x)$，其中 $x=Kr/D$：\n$$\nr = \\frac{1}{2}\\left(\\frac{Kr}{D}\\right) - \\frac{1}{16}\\left(\\frac{Kr}{D}\\right)^3 + O(r^5)\n$$\n该方程总有平凡解 $r=0$，对应于完全去同步态。在分岔点处会出现一个非平凡解（$r0$）。为找到此解，我们两边同除以 $r$：\n$$\n1 = \\frac{K}{2D} - \\frac{K^3 r^2}{16D^3} + O(r^4)\n$$\n去同步阈值 $D_c$ 是非平凡解从 $r=0$ 分岔出来的地方。在这一点，我们有 $r \\to 0$，得到 $1 = K/(2D_c)$，因此临界扩散为 $D_c = K/2$。对于 $D  D_c$，只存在 $r=0$ 的解。对于 $D  D_c$，出现一个 $r0$ 的解。我们关心的是刚好在此阈值以下的区域。\n\n为了找到 $r(D)$ 的领先阶表达式，我们重新整理方程以解出 $r^2$：\n$$\n\\frac{K^3 r^2}{16D^3} = \\frac{K}{2D} - 1\n$$\n$$\n\\frac{K^3 r^2}{16D^3} = \\frac{K - 2D}{2D}\n$$\n现在，我们求解 $r^2$：\n$$\nr^2 = \\frac{16D^3}{K^3}\\left(\\frac{K - 2D}{2D}\\right) = \\frac{8D^2(K - 2D)}{K^3}\n$$\n该表达式在 $K-2D \\ge 0$ 时有效，即 $D \\le K/2$，这与分岔分析一致。序参量是此表达式的正平方根：\n$$\nr(D) = \\sqrt{\\frac{8D^2(K - 2D)}{K^3}}\n$$\n这就是在去同步阈值 $D_c = K/2$ 附近的 $D$ 值下，稳态序参量 $r$ 作为 $D$ 和 $K$ 的函数的领先阶显式解析表达式。",
            "answer": "$$\n\\boxed{\\sqrt{\\frac{8D^2(K - 2D)}{K^3}}}\n$$"
        },
        {
            "introduction": "“同步绑定”假说的核心在于，大脑如何能够在表征多个物体的同时，保持它们各自特征的独立性，避免信息混淆。这个实践项目将理论付诸实践，要求您通过编程构建一个 Kuramoto 模型的仿真，以展示“簇同步”现象。通过精心设计一个模块化的网络结构，其中模块内部耦合强而模块间耦合弱，您将亲眼见证系统如何自发形成多个内部同步但彼此独立的神经元簇，从而为大脑如何解决“绑定问题”提供一个具体而生动的计算模型 。",
            "id": "4037690",
            "problem": "您需要设计并实现一个仿真，该仿真在Kuramoto框架内形式化一个弱耦合相位振子网络，以展示其簇同步现象，从而模拟通过同步实现的联结，并使模块间的串扰最小化。核心要求是，模块内部实现同步，同时避免整个网络发生全局同步，从而表示内部联结但彼此保持独立的独立对象。角度必须以弧度为单位，时间以秒为单位，自然频率以弧度/秒为单位。程序必须按照末尾指定的精确格式产生单行输出。\n\n使用以下基本框架：\n- Kuramoto模型由$N$个相位振子组成，其相位为$\\theta_i(t)$，自然频率为$\\omega_i$，耦合矩阵为$K_{ij}$。其动力学方程为\n$$\n\\frac{d\\theta_i}{dt} = \\omega_i + \\sum_{j=1}^{N} K_{ij} \\sin\\big(\\theta_j(t) - \\theta_i(t)\\big).\n$$\n- $t$时刻的全局Kuramoto序参量为\n$$\nR_{\\text{global}}(t) = \\left| \\frac{1}{N} \\sum_{i=1}^{N} e^{\\mathrm{i}\\,\\theta_i(t)} \\right|.\n$$\n- 对于索引集为$\\mathcal{M}_m$的模块$m$，$t$时刻的模块序参量为\n$$\nR_m(t) = \\left| \\frac{1}{|\\mathcal{M}_m|} \\sum_{i \\in \\mathcal{M}_m} e^{\\mathrm{i}\\,\\theta_i(t)} \\right|.\n$$\n- 模块平均相位为\n$$\n\\phi_m(t) = \\arg\\left( \\frac{1}{|\\mathcal{M}_m|} \\sum_{i \\in \\mathcal{M}_m} e^{\\mathrm{i}\\,\\theta_i(t)} \\right).\n$$\n- 在时间窗口内，对于时间点$\\{t_k\\}$处的样本，模块$a$和$b$之间的模块间锁相值定义为\n$$\n\\mathrm{PLV}_{a,b} = \\left| \\frac{1}{K} \\sum_{k=1}^{K} e^{\\mathrm{i}\\,[\\phi_a(t_k) - \\phi_b(t_k)]} \\right|.\n$$\n\n您的任务是：\n- 使用时间步长$\\Delta t$和前向欧拉法，实现一个数值积分器来仿真Kuramoto模型。\n- 构建具有块状结构的耦合矩阵：模块内耦合是均匀的，等于$K_{\\text{intra}}$（不包括自耦合）；模块间耦合是均匀的，等于$K_{\\text{inter}}$。\n- 在$[0,2\\pi)$上均匀随机地初始化相位$\\theta_i(0)$。\n- 根据指定的均值$\\mu_m$和标准差$\\sigma_m$，从正态分布中为每个模块的振子分配自然频率$\\omega_i$。\n- 在仿真持续时间$T$后，使用仿真的后半部分样本（以排除瞬态过程）计算时间平均的全局序参量$\\overline{R}_{\\text{global}}$、模块序参量$\\overline{R}_m$以及最大模块间锁相值$\\max_{a \\neq b} \\mathrm{PLV}_{a,b}$。\n- 为每个测试用例定义一个二元决策，如果满足以下所有条件，则表示成功实现了串扰最小的簇同步：\n  1. 每个模块的时间平均序参量满足$\\overline{R}_m \\geq r_{\\text{intra}}$，\n  2. 时间平均的全局序参量满足$\\overline{R}_{\\text{global}} \\leq r_{\\text{global}}$，\n  3. 最大模块间锁相值满足$\\max_{a \\neq b} \\mathrm{PLV}_{a,b} \\leq p_{\\text{max}}$。\n- 使用阈值$r_{\\text{intra}} = 0.8$，$r_{\\text{global}} = 0.6$ 和 $p_{\\text{max}} = 0.4$。\n\n角度以弧度为单位，时间以秒为单位，自然频率以弧度/秒为单位。数值积分必须使用以秒为单位的$\\Delta t$。将所有阈值和耦合常数表示为无量纲标量。您的实现必须是确定性的；固定伪随机数生成器的种子以确保可复现性。\n\n测试套件和参数化：\n实现以下$5$个测试用例。每个案例由元组$(\\text{modules}, K_{\\text{intra}}, K_{\\text{inter}}, \\{\\mu_m\\}, \\{\\sigma_m\\}, \\Delta t, T)$指定，其中$\\text{modules}$是模块大小的列表，其总和为$N$。\n\n- 案例1（理想情况，两个不同模块，模块间耦合较小）：\n  - $\\text{modules} = [10, 10]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.05$,\n  - $\\{\\mu_m\\} = [1.5, 2.0]$,\n  - $\\{\\sigma_m\\} = [0.05, 0.05]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$。\n- 案例2（由于模块间耦合较强，趋向于全局同步的边界情况）：\n  - $\\text{modules} = [10, 10]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.35$,\n  - $\\{\\mu_m\\} = [1.5, 2.0]$,\n  - $\\{\\sigma_m\\} = [0.05, 0.05]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$。\n- 案例3（模块间耦合为零的边缘情况）：\n  - $\\text{modules} = [10, 10]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.0$,\n  - $\\{\\mu_m\\} = [1.5, 2.0]$,\n  - $\\{\\sigma_m\\} = [0.05, 0.05]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$。\n- 案例4（异构模块大小和中等模块间耦合）：\n  - $\\text{modules} = [12, 8]$,\n  - $K_{\\text{intra}} = 0.8$,\n  - $K_{\\text{inter}} = 0.1$,\n  - $\\{\\mu_m\\} = [1.7, 2.2]$,\n  - $\\{\\sigma_m\\} = [0.03, 0.03]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$。\n- 案例5（三个具有不同平均频率和较小模块间耦合的模块）：\n  - $\\text{modules} = [8, 8, 8]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.02$,\n  - $\\{\\mu_m\\} = [1.2, 1.6, 2.1]$,\n  - $\\{\\sigma_m\\} = [0.04, 0.04, 0.04]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$），其中每个$\\text{result}$是一个布尔值，指示该案例是否在上述标准下实现了串扰最小的簇同步。",
            "solution": "该问题陈述经评估是有效的。它提出了一个计算神经科学领域中明确定义的任务，该任务基于已建立的Kuramoto耦合振子模型。其目标、参数和评估标准都足够精确，足以得出一个唯一且可验证的解。该问题要求对一个常微分方程组进行仿真并进行后续数据分析，这是定量科学研究中的一个标准程序。\n\n关于耦合常数$K_{\\text{intra}}$和$K_{\\text{inter}}$的单位存在一个微小的不明确之处。控制微分方程，\n$$\n\\frac{d\\theta_i}{dt} = \\omega_i + \\sum_{j=1}^{N} K_{ij} \\sin\\big(\\theta_j(t) - \\theta_i(t)\\big)\n$$\n为了量纲一致性，要求耦合常数$K_{ij}$具有频率单位（例如rad/s），因为$\\frac{d\\theta_i}{dt}$和自然频率$\\omega_i$的单位都是rad/s，而正弦函数是无量纲的。然而，问题将这些常数描述为“无量纲标量”。这是该领域的一个常见约定，其中耦合强度被默认为具有频率单位，或者已经相对于某个参考频率进行了无量纲化处理。鉴于上下文和为$\\omega_i$指定的值，将$K$的值解释为rad/s是合适的。这个轻微的不精确之处并不会使问题无效，因为它可以通过标准解释来解决。问题的所有其他方面都是清晰、一致且科学合理的。\n\n解决方案的步骤是：首先构建模型，然后仿真其动力学过程，最后根据指定标准分析结果。\n\n**1. 模型构建**\n\n系统由$N$个振子组成，这些振子被划分为不同的模块。振子的总数$N$是给定测试用例中指定的所有模块大小的总和。\n\n**自然频率($\\omega_i$):**\n对于属于模块$m$的每个振子$i$，其自然频率$\\omega_i$从正态分布$\\mathcal{N}(\\mu_m, \\sigma_m^2)$中抽取，其中$\\mu_m$是该模块的平均频率，$\\sigma_m$是标准差。模块间平均频率的差异对于建立不同的同步簇至关重要。\n\n**耦合矩阵($K_{ij}$):**\n振子之间的相互作用由$N \\times N$的耦合矩阵$K$定义。该矩阵被构造成块状结构，以反映网络的模块化组织。\n- 对于同一模块内的任意两个不同振子$i$和$j$，耦合强度是均匀的，并设置为$K_{ij} = K_{\\text{intra}}$。\n- 对于不同模块中的任意两个振子$i$和$j$，耦合强度是均匀的，并设置为$K_{ij} = K_{\\text{inter}}$。\n- 自耦合被排除，因此对角线元素为$K_{ii} = 0$。\n$K_{\\text{intra}} \\gg K_{\\text{inter}}$的条件预计将促进模块内的强同步，同时保持模块间的相对独立性。\n\n**初始条件($\\theta_i(0)$):**\n每个振子的初始相位$\\theta_i(0)$从区间$[0, 2\\pi)$上的均匀随机分布中独立抽取。这对应于整个网络的初始非相干状态。\n\n**2. 数值仿真**\n\n耦合常微分方程组使用前向欧拉法进行数值求解。给定一个时间步长$\\Delta t$，每个振子在时间$t + \\Delta t$的相位根据其在时间$t$的状态近似得出：\n$$\n\\theta_i(t+\\Delta t) = \\theta_i(t) + \\Delta t \\cdot \\left( \\omega_i + \\sum_{j=1}^{N} K_{ij} \\sin(\\theta_j(t) - \\theta_i(t)) \\right)\n$$\n在每个更新步骤之后，使用模运算符将相位包裹在$[0, 2\\pi)$区间内，以处理角度的周期性。仿真总共运行持续时间$T$。\n\n**3. 分析与评估**\n\n为确保分析反映系统的稳态行为，所有指标都使用从$t = T/2$到$t = T$的后半段仿真数据进行计算，从而丢弃初始瞬态。\n\n**序参量:**\n同步程度使用Kuramoto序参量进行量化。对于一组相位为$\\{\\psi_k\\}$的振子，序参量为$R = |\\frac{1}{L} \\sum_{k=1}^{L} e^{\\mathrm{i}\\psi_k}|$，其中$L$是该集合中振子的数量。$R \\approx 1$的值表示强同步，而$R \\approx 0$表示非相干。我们计算：\n- **全局序参量**，$R_{\\text{global}}(t)$，在所有$N$个振子上计算。\n- **模块序参量**，$R_m(t)$，为每个模块$m$在其组成振子上计算。\n然后将这些参数在分析窗口内进行时间平均，得到$\\overline{R}_{\\text{global}}$和$\\overline{R}_m$。\n\n**模块间锁相值 (PLV):**\n为了测量模块*之间*的同步性，我们首先计算分析窗口中每个时间步$t_k$处每个模块$m$的平均相位：\n$$\n\\phi_m(t_k) = \\arg\\left( \\frac{1}{|\\mathcal{M}_m|} \\sum_{i \\in \\mathcal{M}_m} e^{\\mathrm{i}\\,\\theta_i(t_k)} \\right)\n$$\n然后，两个模块$a$和$b$之间的PLV是时间平均的相位差向量的模：\n$$\n\\mathrm{PLV}_{a,b} = \\left| \\frac{1}{K} \\sum_{k=1}^{K} e^{\\mathrm{i}\\,[\\phi_a(t_k) - \\phi_b(t_k)]} \\right|\n$$\n其中，求和是对分析窗口中所有$K$个时间样本进行的。我们找出所有不同模块对之间的最大PLV，即$\\max_{a \\neq b} \\mathrm{PLV}_{a,b}$。\n\n**决策标准:**\n当且仅当以下所有三个条件都满足时，一个测试用例被分类为展示了成功的簇同步：\n1.  _高模块内凝聚力_: 对所有模块$m$，$\\overline{R}_m \\geq r_{\\text{intra}}$，其中$r_{\\text{intra}} = 0.8$。\n2.  _低全局凝聚力_: $\\overline{R}_{\\text{global}} \\leq r_{\\text{global}}$，其中$r_{\\text{global}} = 0.6$。\n3.  _低模块间串扰_: $\\max_{a \\neq b} \\mathrm{PLV}_{a,b} \\leq p_{\\text{max}}$，其中$p_{\\text{max}} = 0.4$。\n\n实现将处理五个测试用例中的每一个，应用此逻辑，并为每个用例返回一个布尔结果。伪随机数生成器的固定种子确保了结果的确定性和可复现性。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Kuramoto model cluster synchronization.\n    \"\"\"\n    # Fix the pseudo-random generator seed for reproducibility.\n    # This ensures that initial phases and natural frequencies are the same for each run.\n    np.random.seed(0)\n\n    # Define the test cases as specified in the problem statement.\n    # Each case: (modules, K_intra, K_inter, {mu_m}, {sigma_m}, dt, T)\n    test_cases = [\n        # Case 1: Happy path\n        ([10, 10], 0.9, 0.05, [1.5, 2.0], [0.05, 0.05], 0.01, 20.0),\n        # Case 2: Tending to global sync\n        ([10, 10], 0.9, 0.35, [1.5, 2.0], [0.05, 0.05], 0.01, 20.0),\n        # Case 3: Zero inter-coupling\n        ([10, 10], 0.9, 0.0, [1.5, 2.0], [0.05, 0.05], 0.01, 20.0),\n        # Case 4: Heterogeneous modules\n        ([12, 8], 0.8, 0.1, [1.7, 2.2], [0.03, 0.03], 0.01, 20.0),\n        # Case 5: Three modules\n        ([8, 8, 8], 0.9, 0.02, [1.2, 1.6, 2.1], [0.04, 0.04, 0.04], 0.01, 20.0),\n    ]\n\n    # Thresholds for success criteria\n    r_intra = 0.8\n    r_global = 0.6\n    p_max = 0.4\n    \n    results = []\n    for case_params in test_cases:\n        result = run_kuramoto_simulation(case_params, r_intra, r_global, p_max)\n        results.append(result)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_kuramoto_simulation(params, r_intra, r_global, p_max):\n    \"\"\"\n    Runs a single simulation of the Kuramoto model and evaluates cluster synchronization.\n    \"\"\"\n    module_sizes, K_intra, K_inter, mus, sigmas, dt, T = params\n    \n    # 1. Initialization\n    num_modules = len(module_sizes)\n    N = sum(module_sizes)\n    \n    # Generate module indices for each oscillator\n    module_indices = []\n    start_idx = 0\n    for size in module_sizes:\n        module_indices.append(list(range(start_idx, start_idx + size)))\n        start_idx += size\n\n    # Natural frequencies (omega)\n    omega = np.zeros(N)\n    for i in range(num_modules):\n        omega[module_indices[i]] = np.random.normal(mus[i], sigmas[i], module_sizes[i])\n        \n    # Initial phases (theta)\n    theta = np.random.uniform(0, 2 * np.pi, N)\n    \n    # Coupling matrix (K)\n    K = np.full((N, N), K_inter)\n    for i in range(num_modules):\n        idx = np.ix_(module_indices[i], module_indices[i])\n        K[idx] = K_intra\n    np.fill_diagonal(K, 0)\n\n    # 2. Simulation\n    num_steps = int(T / dt)\n    analysis_start_step = num_steps // 2\n    \n    # History storage for analysis window\n    history_len = num_steps - analysis_start_step\n    R_global_hist = np.zeros(history_len)\n    R_modules_hist = np.zeros((num_modules, history_len))\n    phi_modules_hist = np.zeros((num_modules, history_len))\n\n    for step in range(num_steps):\n        # Calculate phase differences (theta_j - theta_i) efficiently\n        phase_diffs = theta - theta[:, np.newaxis]\n        \n        # Calculate sum term of the ODE\n        interaction_term = np.sum(K * np.sin(phase_diffs), axis=1)\n        \n        # Update phases using Euler forward method\n        theta = (theta + dt * (omega + interaction_term)) % (2 * np.pi)\n        \n        # Store metrics if in analysis window\n        if step = analysis_start_step:\n            hist_idx = step - analysis_start_step\n            \n            # Global order parameter\n            R_global_hist[hist_idx] = np.abs(np.mean(np.exp(1j * theta)))\n            \n            # Module-specific order parameters and mean phases\n            for m in range(num_modules):\n                module_theta = theta[module_indices[m]]\n                mean_phasor = np.mean(np.exp(1j * module_theta))\n                R_modules_hist[m, hist_idx] = np.abs(mean_phasor)\n                phi_modules_hist[m, hist_idx] = np.angle(mean_phasor)\n\n    # 3. Analysis and Evaluation\n    \n    # Time-averaged global order parameter\n    avg_R_global = np.mean(R_global_hist)\n    \n    # Time-averaged module order parameters\n    avg_R_modules = np.mean(R_modules_hist, axis=1)\n    \n    # Maximum inter-module Phase-Locking Value (PLV)\n    max_plv = 0.0\n    if num_modules  1:\n        plv_values = []\n        for m1, m2 in combinations(range(num_modules), 2):\n            phase_diff_hist = phi_modules_hist[m1, :] - phi_modules_hist[m2, :]\n            plv = np.abs(np.mean(np.exp(1j * phase_diff_hist)))\n            plv_values.append(plv)\n        if plv_values:\n            max_plv = np.max(plv_values)\n\n    # 4. Decision Logic\n    cond1 = np.all(avg_R_modules = r_intra)\n    cond2 = avg_R_global = r_global\n    cond3 = max_plv = p_max\n    \n    return cond1 and cond2 and cond3\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}