{
    "hands_on_practices": [
        {
            "introduction": "临界性的核心思想是，系统在特定参数值（即“临界点”）下会表现出跨尺度的复杂行为。分支过程是描述神经雪崩等级联现象的经典理论模型。这项练习  将指导您从第一性原理出发，推导平均雪崩规模与分支比 $\\sigma$ 之间的关系，从而揭示当 $\\sigma \\to 1$ 时系统如何接近临界状态。",
            "id": "4041825",
            "problem": "考虑一个神经雪崩，它是由大型稀疏网络中的单个活跃神经元引发的级联。将该级联建模为一个 Galton–Watson 分支过程，其中每个活跃神经元在下一个时间步独立地激活随机数量的下游神经元。假设子代数量服从平均分支比为 $\\sigma$ 的泊松分布，即每个活跃神经元的下游激活数量 $K$ 满足 $K \\sim \\text{Poisson}(\\sigma)$，且在不同神经元和时间步之间是独立的。定义雪崩规模 $S$ 为级联中被激活的神经元总数，包括初始神经元。仅使用 Galton–Watson 过程的基本性质，即子分支的独立性和期望的线性性，推导在亚临界状态 $\\sigma \\in (0,1)$ 下期望雪崩规模 $\\mathbb{E}[S]$ 作为 $\\sigma$ 函数的精确闭式表达式。然后，计算当 $\\sigma = 0.95$ 时的期望规模，并从数学上解释当 $\\sigma \\to 1^{-}$ 时 $\\mathbb{E}[S]$ 如何发散。将 $\\sigma = 0.95$ 时的数值计算结果用科学记数法表示，保留四位有效数字，并提供最终的无单位数值答案。",
            "solution": "用户需要一个关于神经雪崩问题的解答。我将首先验证问题陈述。\n\n### 步骤 1：提取已知条件\n-   **模型**：神经雪崩作为 Galton–Watson 分支过程。\n-   **起始**：级联由单个活跃神经元开始。\n-   **网络**：大型，稀疏。\n-   **子代分布**：每个活跃神经元的下游激活数量 $K$ 服从平均分支比为 $\\sigma$ 的泊松分布，即 $K \\sim \\text{Poisson}(\\sigma)$。\n-   **独立性**：子代数量在不同神经元和时间步之间是独立的。\n-   **定义**：雪崩规模 $S$ 是级联中被激活的神经元总数，包括初始神经元。\n-   **约束**：仅使用基本性质：子分支的独立性和期望的线性性。\n-   **状态**：亚临界，$\\sigma \\in (0,1)$。\n-   **任务**：\n    1.  推导期望雪崩规模 $\\mathbb{E}[S]$ 作为 $\\sigma$ 函数的精确闭式表达式。\n    2.  计算当 $\\sigma = 0.95$ 时的 $\\mathbb{E}[S]$。\n    3.  从数学上解释当 $\\sigma \\to 1^{-}$ 时 $\\mathbb{E}[S]$ 如何发散。\n-   **格式要求**：将 $\\sigma = 0.95$ 时的数值计算结果用科学记数法表示，保留四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题具有充分的科学依据。Galton–Watson 过程是用于建模分支现象的标准数学框架，其在神经雪崩中的应用是理论神经科学和复杂性科学的基石。在此背景下，泊松分布是子代分布的一个常见且合适的选择。\n2.  **问题定义明确**：该问题是良构的。它要求分支过程理论中的一个标准结果（亚临界过程的 $\\mathbb{E}[S]$），对此存在唯一且有意义的解。\n3.  **客观性**：语言精确、量化，没有主观或模糊的术语。\n4.  **完整性和一致性**：问题提供了所有必要信息（模型类型、子代分布、规模定义、参数状态），且不包含内部矛盾。\n5.  **可行性**：这些条件对于此类模型是标准的，不涉及任何物理或数学上的不可能性。\n6.  **难度适中**：该问题并非微不足道；它需要基于递归分解和全期望定律的特定、非显而易见的推理思路才能得出解。\n\n### 步骤 3：结论与行动\n问题是有效的。我将继续进行解答。\n\n问题要求在一个 Galton-Watson 分支过程中推导期望雪崩规模 $\\mathbb{E}[S]$。该过程始于代数 $g=0$ 的一个初始神经元。令 $S$ 为雪崩的总规模。这个初始神经元在下一代激活 $K$ 个神经元，其中 $K$ 是一个随机变量，服从均值为 $\\sigma$ 的泊松分布，即 $K \\sim \\text{Poisson}(\\sigma)$。\n\n雪崩总规模 $S$ 可以表示为初始神经元（1个）与由其 $K$ 个直接子代各自引发的子雪崩规模之和。令 $S_i$ 为第 $i$ 个子代（$i=1, 2, \\dots, K$）引发的子雪崩的总规模。\n我们可以为随机变量 $S$ 写出一个递归表达式：\n$$S = 1 + \\sum_{i=1}^{K} S_i$$\n如果 $K=0$，则求和为空，其值为 $0$，因此 $S=1$。这是正确的，因为没有子代的雪崩总规模为 $1$（即初始神经元本身）。\n\n根据 Galton-Watson 过程的性质，从一个子代开始的每个子雪崩都是一个独立的、与原过程在统计上完全相同的过程。因此，每个随机变量 $S_i$ 的概率分布与 $S$ 相同，从而期望值也相同：$\\mathbb{E}[S_i] = \\mathbb{E}[S]$。\n\n我们想要求解 $\\mathbb{E}[S]$。我们对 $S$ 的递归方程取期望：\n$$\\mathbb{E}[S] = \\mathbb{E}\\left[1 + \\sum_{i=1}^{K} S_i\\right]$$\n利用期望的线性性，我们得到：\n$$\\mathbb{E}[S] = \\mathbb{E}[1] + \\mathbb{E}\\left[\\sum_{i=1}^{K} S_i\\right] = 1 + \\mathbb{E}\\left[\\sum_{i=1}^{K} S_i\\right]$$\n项 $\\mathbb{E}\\left[\\sum_{i=1}^{K} S_i\\right]$ 是一个随机数量的随机变量之和的期望。为了计算它，我们使用全期望定律（在此背景下也称为沃尔德恒等式），以子代数量 $K$ 为条件：\n$$\\mathbb{E}\\left[\\sum_{i=1}^{K} S_i\\right] = \\mathbb{E}\\left[\\mathbb{E}\\left[\\sum_{i=1}^{K} S_i \\Bigg| K\\right]\\right]$$\n让我们首先计算内部的期望，以某个整数 $k \\ge 0$ 的条件 $K=k$ 为前提：\n$$\\mathbb{E}\\left[\\sum_{i=1}^{k} S_i \\Bigg| K=k\\right]$$\n由于子雪崩的规模 $S_i$ 与子代数量 $K$ 无关，并且它们是独立同分布的，所以条件期望是：\n$$\\sum_{i=1}^{k} \\mathbb{E}[S_i] = \\sum_{i=1}^{k} \\mathbb{E}[S] = k \\mathbb{E}[S]$$\n所以，我们有 $\\mathbb{E}\\left[\\sum_{i=1}^{K} S_i \\Bigg| K\\right] = K \\mathbb{E}[S]$。现在我们将其代回全期望定律：\n$$\\mathbb{E}\\left[\\sum_{i=1}^{K} S_i\\right] = \\mathbb{E}[K \\mathbb{E}[S]]$$\n由于 $\\mathbb{E}[S]$ 是一个常数（我们试图确定的值），我们可以将其从期望中提取出来：\n$$\\mathbb{E}[K \\mathbb{E}[S]] = \\mathbb{E}[S] \\mathbb{E}[K]$$\n问题陈述指出 $K$ 服从均值为 $\\sigma$ 的泊松分布。因此，$\\mathbb{E}[K] = \\sigma$。\n将此结果代回我们关于 $\\mathbb{E}[S]$ 的主方程：\n$$\\mathbb{E}[S] = 1 + \\sigma \\mathbb{E}[S]$$\n现在我们可以求解 $\\mathbb{E}[S]$。这个推导仅在 $\\mathbb{E}[S]$ 为有限值时有效，这在亚临界状态 $\\sigma  1$ 下是成立的。\n$$\\mathbb{E}[S] - \\sigma \\mathbb{E}[S] = 1$$\n$$\\mathbb{E}[S] (1 - \\sigma) = 1$$\n这就得出了在亚临界状态 $\\sigma \\in (0,1)$ 下期望雪崩规模的闭式表达式：\n$$\\mathbb{E}[S] = \\frac{1}{1 - \\sigma}$$\n接下来，我们计算当 $\\sigma = 0.95$ 时此表达式的值：\n$$\\mathbb{E}[S] = \\frac{1}{1 - 0.95} = \\frac{1}{0.05} = 20$$\n用科学记数法表示并保留四位有效数字，结果是 $2.000 \\times 10^1$。\n\n最后，我们解释当 $\\sigma \\to 1^{-}$ 时的发散行为。期望规模的表达式是 $\\mathbb{E}[S] = \\frac{1}{1 - \\sigma}$。为了分析当分支比 $\\sigma$ 从下方趋近于临界值 $1$ 时的行为，我们取其极限：\n$$\\lim_{\\sigma \\to 1^{-}} \\mathbb{E}[S] = \\lim_{\\sigma \\to 1^{-}} \\frac{1}{1 - \\sigma}$$\n当 $\\sigma$ 从小于 $1$ 的值趋近于 $1$ 时，分母 $(1 - \\sigma)$ 从正方向趋近于 $0$。因此，该分数发散到正无穷大：\n$$\\lim_{\\sigma \\to 1^{-}} \\mathbb{E}[S] = +\\infty$$\n这种数学上的发散标志着一个相变。$\\sigma = 1$ 是系统的临界点。对于 $\\sigma  1$（亚临界），雪崩保证会终止并具有有限的期望规模。在 $\\sigma = 1$（临界）时，雪崩的期望规模变为无穷大。这并不意味着每个雪崩都无限大；而是雪崩规模的概率分布呈现出“重尾”（具体来说是幂律分布），使得系统规模的级联能够以足够的概率发生，从而导致平均规模发散。这种临界状态是理解复杂系统的关键概念，因为它允许信息在所有尺度上传播。对于 $\\sigma > 1$（超临界），灭绝的概率小于 $1$，雪崩可以指数级增长，导致期望规模为无穷大。",
            "answer": "$$\\boxed{2.000 \\times 10^{1}}$$"
        },
        {
            "introduction": "理论模型是强大的，但要将其与实验数据联系起来，我们必须首先将抽象的“雪崩”概念转化为一个可操作的定义。这项实践  要求您根据原始神经脉冲数据（脉冲栅格）实现一个标准的雪崩检测算法。通过这种方式，您将学习如何将连续的神经活动流粗粒化为一组离散的、可供统计分析的雪崩事件。",
            "id": "4041876",
            "problem": "考虑一个离散时间脉冲栅格，表示为一个二进制矩阵 $R \\in \\{0,1\\}^{N \\times T}$，其中 $N$ 是通道数，$T$ 是时间步数。每个条目 $R_{n,t} = 1$ 表示在通道 $n$ 的时间索引 $t$ 上有一个脉冲，$R_{n,t} = 0$ 表示没有脉冲。假设基础时间步长 $\\Delta t = 1$ 任意时间单位。\n\n从神经雪崩分析的基本定义和经过充分测试的观测方法出发，实现以下基于平均事件间隔（MEI）分箱的精确雪崩检测规则：\n\n- 通过收集所有时间索引 $t$（对于任意通道 $n$，$R_{n,t} = 1$）来定义事件时间序列 $\\{t_i\\}$，同一时间索引下不同通道上的同时脉冲需计入多次。将 $\\{t_i\\}$ 按非递减顺序排序。\n- 对于序列中所有存在 $i+1$ 的索引 $i$，定义事件间间隔 $\\Delta_i = t_{i+1} - t_{i}$。定义平均事件间隔（MEI）为 $\\bar{\\Delta} = \\frac{1}{M-1} \\sum_{i=1}^{M-1} \\Delta_i$，其中 $M$ 是 $\\{t_i\\}$ 中的事件总数。如果 $M  2$，则按惯例定义 $\\bar{\\Delta} := 1$。\n- 通过对 $\\bar{\\Delta}$ 进行四舍五入到最近的整数来定义整数箱宽 $w$，即 $w := \\max\\left(1, \\operatorname{round}(\\bar{\\Delta})\\right)$，小数部分为0.5时向上取整。\n- 从时间索引 $t = 0$ 开始，将时间轴划分为宽度为 $w$ 的连续不重叠的箱 $B_k$，使得 $B_k$ 包含满足 $kw \\le t \\le \\min((k+1)w - 1, T-1)$ 的时间索引 $t$，其中 $k = 0, 1, \\dots, K-1$ 且 $K = \\left\\lceil \\frac{T}{w} \\right\\rceil$。\n- 定义箱活动度 $a_k = \\sum_{n=1}^{N} \\sum_{t \\in B_k} R_{n,t}$，如果 $a_k > 0$，则称 $B_k$ 为“活动”的，否则为“静默”的。\n- 定义雪崩为任意由静默箱在两侧界定的最大连续活动箱序列。将边界 $k = -1$ 和 $k = K$ 视作静默。雪崩大小 $s$ 是该序列中各箱内脉冲的总数，即序列中各箱的 $a_k$ 之和。\n\n你的任务是实现一个程序，对下面的每个测试用例，计算雪崩大小的分布。分布必须以列表 $[c_1, c_2, \\dots, c_{s_{\\max}}]$ 的形式报告，其中 $c_s$ 是大小为 $s$ 的雪崩的数量，$s_{\\max}$ 是在该测试用例中观察到的最大雪崩大小。如果没有检测到雪崩，则返回空列表 $[]$。程序必须严格遵循上述检测规则。\n\n测试套件（每个栅格指定为行列表，每行是一个包含 $T$ 个值的列表，值为 $\\{0,1\\}$ 中的一个）：\n\n- 测试用例 1（一般多通道情况）。参数：$N = 3$, $T = 18$。栅格 $R$:\n  - 通道 0: $[0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0]$\n  - 通道 1: $[0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0]$\n  - 通道 2: $[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0]$\n- 测试用例 2（无脉冲的边界情况）。参数：$N = 2$, $T = 10$。栅格 $R$:\n  - 通道 0: $[0,0,0,0,0,0,0,0,0,0]$\n  - 通道 1: $[0,0,0,0,0,0,0,0,0,0]$\n- 测试用例 3（全时活动的单通道，最小 MEI）。参数：$N = 1$, $T = 8$。栅格 $R$:\n  - 通道 0: $[1,1,1,1,1,1,1,1]$\n- 测试用例 4（需要四舍五入的非整数 MEI）。参数：$N = 2$, $T = 12$。栅格 $R$:\n  - 通道 0: $[0,1,0,0,1,0,0,1,0,0,0,0]$\n  - 通道 1: $[0,0,1,0,0,1,0,0,0,1,0,0]$\n\n你的程序应该生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例的分布列表，顺序与上面列出的一致。例如，格式为 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，逗号之间没有空格。最终输出值必须是整数列表，并允许空列表。",
            "solution": "问题陈述为一个在离散脉冲栅格 $R \\in \\{0,1\\}^{N \\times T}$ 中进行神经雪崩检测的、定义明确且有科学依据的程序。该方法基于计算神经科学中用于研究神经系统临界性的标准观测技术。所有参数和规则都得到了明确的规定。因此，该问题是有效的。\n\n雪崩分析的核心原理是识别具有因果关联的神经活动集群。神经雪崩被概念化为在网络中传播的脉冲活动级联。这里规定的方法使用平均事件间隔（MEI）来定义系统动力学的一个特征时间尺度。这个时间尺度，表示为 $\\bar{\\Delta}$，代表所有通道上连续脉冲之间的平均持续时间。通过将时间轴划分为宽度为 $w$（由 $\\bar{\\Delta}$ 导出）的箱，我们可以对脉冲序列进行粗粒化。包含任意数量脉冲的箱被视为“活动的”，而脉冲数为零的箱则为“静默的”。然后，雪崩被定义为一个连续的活动箱序列，其在时间上由静默箱界定。这个操作性定义旨在将时间上聚集的脉冲分组为内聚的事件，这些事件由比特征时间尺度更长的静默期分隔开。雪崩的大小 $s$ 是它所包含的脉冲总数，这是衡量其量级的主要指标。\n\n解决方案通过为每个测试用例一丝不苟地实现指定的算法步骤来推进。\n\n**第1步：提取事件时间并计算平均事件间隔（MEI）**\n\n首先，我们编译一个事件时间序列 $\\{t_i\\}$，它包含栅格 $R$ 中每个脉冲的时间索引。如果在同一时间索引 $t$ 有多个通道发放脉冲，则该索引 $t$ 在序列中为每个脉冲包含一次。然后将该序列按非递减顺序排序。设 $M$ 为脉冲总数（$\\{t_i\\}$ 的长度）。\n\n事件间间隔为 $\\Delta_i = t_{i+1} - t_i$。MEI $\\bar{\\Delta}$ 是它们的平均值。\n$$ \\bar{\\Delta} = \\frac{1}{M-1} \\sum_{i=1}^{M-1} \\Delta_i = \\frac{1}{M-1} \\sum_{i=1}^{M-1} (t_{i+1} - t_i) $$\n这个和是一个伸缩级数，可以简化为：\n$$ \\bar{\\Delta} = \\frac{t_M - t_1}{M-1} $$\n其中 $t_1$ 和 $t_M$ 分别是排序后序列中第一个和最后一个脉冲的时间。如果 $M  2$，我们使用惯例 $\\bar{\\Delta} := 1$。\n\n**第2步：确定箱宽**\n\n整数箱宽 $w$ 是通过将 MEI 四舍五入到最近的整数来确定的，并带有约束 $w \\ge 1$。问题规定，小数部分为一半（例如2.5）时向上取整。这对应于操作 $w := \\max\\left(1, \\lfloor \\bar{\\Delta} + 0.5 \\rfloor\\right)$。\n\n**第3步：对脉冲数据分箱并计算活动度**\n\n总时长 $T$ 被划分为 $K = \\lceil T/w \\rceil$ 个连续的箱。每个箱 $B_k$（其中 $k \\in \\{0, 1, \\dots, K-1\\}$）的活动度 $a_k$ 是时间索引 $t$ 满足 $kw \\le t  (k+1)w$ 的脉冲总数。如果 $a_k > 0$，则箱是“活动的”；如果 $a_k = 0$，则是“静默的”。\n\n**第4步：识别雪崩及其大小**\n\n雪崩是一个最大的、连续的活动箱序列。我们通过扫描箱活动度 $\\{a_k\\}_{k=0}^{K-1}$ 来识别这些序列。当在静默箱（隐式边界 $k=-1$ 被认为是静默的）之后遇到一个活动箱时，一个新的雪崩开始。只要后续的箱是活动的，雪崩就继续。当遇到一个静默箱时，它就终止。雪崩的大小 $s$ 是该序列中所有箱的活动度 $a_k$ 的总和。\n\n**第5步：计算雪崩大小分布**\n\n在识别所有雪崩并计算其大小后，我们将结果汇编成一个频率分布。对于每个测试用例，我们计算一个列表 $[c_1, c_2, \\dots, c_{s_{\\max}}]$，其中 $c_s$ 是观测到的大小为 $s$ 的雪崩数量，$s_{\\max}$ 是找到的最大雪崩大小。如果没有检测到雪崩，结果是一个空列表。\n\n我们现在将此过程应用于每个测试用例。\n\n**测试用例 1: $N=3, T=18$**\n- **事件时间：** 脉冲发生在以下时间（含重复）：$[1, 1, 2, 5, 6, 7, 13, 13, 13, 15]$。总脉冲数 $M=10$。\n- **MEI：** $\\bar{\\Delta} = \\frac{t_{10} - t_1}{10-1} = \\frac{15 - 1}{9} = \\frac{14}{9} \\approx 1.556$。\n- **箱宽：** $w = \\max(1, \\lfloor 1.556 + 0.5 \\rfloor) = \\max(1, \\lfloor 2.056 \\rfloor) = 2$。\n- **分箱 ($w=2, T=18, K=9$)：**\n  - 每个时间步的总活动度：$S_t = [0, 2, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0]$。\n  - 箱活动度 $a_k$：$[2, 1, 1, 2, 0, 0, 3, 1, 0]$。\n- **雪崩：**\n  - 箱 $0-3$ 是活动的：大小 $s_1 = 2+1+1+2 = 6$。\n  - 箱 $4,5$ 是静默的。\n  - 箱 $6-7$ 是活动的：大小 $s_2 = 3+1 = 4$。\n  - 箱 $8$ 是静默的。\n  - 雪崩大小为 $[6, 4]$。\n- **分布：** $s_{\\max}=6$。有一个大小为4的雪崩和一个大小为6的雪崩。分布为 $[c_1, \\dots, c_6] = [0, 0, 0, 1, 0, 1]$。\n\n**测试用例 2: $N=2, T=10$**\n- **事件时间：** 没有脉冲。$M=0$。\n- **MEI：** 按照惯例，对于 $M2$，$\\bar{\\Delta}=1$。\n- **箱宽：** $w = \\max(1, \\lfloor 1 + 0.5 \\rfloor) = 1$。\n- **分箱 ($w=1$)：** 所有箱活动度均为 $0$。\n- **雪崩：** 没有活动箱，因此没有雪崩。\n- **分布：** 结果是空列表 $[]$。\n\n**测试用例 3: $N=1, T=8$**\n- **事件时间：** 每个时间步都有脉冲：$[0, 1, 2, 3, 4, 5, 6, 7]$。$M=8$。\n- **MEI：** $\\bar{\\Delta} = \\frac{7 - 0}{8-1} = \\frac{7}{7} = 1$。\n- **箱宽：** $w = \\max(1, \\lfloor 1 + 0.5 \\rfloor) = 1$。\n- **分箱 ($w=1$)：** 所有 $8$ 个箱都处于活动状态，活动度为 $a_k=1$。\n- **雪崩：** 一个单一的雪崩横跨所有箱。其大小为 $s = 8 \\times 1 = 8$。\n- **分布：** $s_{\\max}=8$。一个大小为8的雪崩。分布为 $[0, 0, 0, 0, 0, 0, 0, 1]$。\n\n**测试用例 4: $N=2, T=12$**\n- **事件时间：** 脉冲发生在 $[1, 2, 4, 5, 7, 9]$。$M=6$。\n- **MEI：** $\\bar{\\Delta} = \\frac{9 - 1}{6-1} = \\frac{8}{5} = 1.6$。\n- **箱宽：** $w = \\max(1, \\lfloor 1.6 + 0.5 \\rfloor) = \\max(1, \\lfloor 2.1 \\rfloor) = 2$。\n- **分箱 ($w=2, T=12, K=6$)：**\n  - 每个时间步的总活动度：$S_t = [0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0]$。\n  - 箱活动度 $a_k$：$[1, 1, 2, 1, 1, 0]$。\n- **雪崩：** 箱 $0-4$ 是活动的，随后是一个静默箱。一个大小为 $s = 1+1+2+1+1 = 6$ 的雪崩。\n- **分布：** $s_{\\max}=6$。一个大小为6的雪崩。分布为 $[0, 0, 0, 0, 0, 1]$。",
            "answer": "```python\nimport numpy as np\n\ndef compute_avalanche_distribution(R_list):\n    \"\"\"\n    Computes the distribution of avalanche sizes for a given spike raster.\n\n    Args:\n        R_list (list of lists): The spike raster as a list of lists.\n\n    Returns:\n        list: The avalanche size distribution [c_1, ..., c_s_max], or [] if no avalanches.\n    \"\"\"\n    R = np.array(R_list, dtype=np.int8)\n    N, T = R.shape\n\n    # Step 1: Extract Event Times\n    # Find all (row, col) indices where a spike occurred.\n    spike_indices = np.where(R == 1)\n    # The event times are the column indices (t) of these spikes.\n    event_times = np.sort(spike_indices[1])\n    \n    M = len(event_times)\n\n    # Step 2: Calculate Mean Inter-Event Interval (MEI)\n    if M  2:\n        mei = 1.0\n    else:\n        # MEI = (last_spike_time - first_spike_time) / (M - 1)\n        mei = (event_times[-1] - event_times[0]) / (M - 1)\n\n    # Step 3: Determine Bin Width (w)\n    # round(x) with ties at halves rounded up is floor(x + 0.5)\n    w = int(np.floor(mei + 0.5))\n    w = max(1, w)\n\n    # Step 4: Bin the Spike Data and Compute Activity\n    # Get total number of spikes at each time step\n    total_spikes_per_t = R.sum(axis=0)\n    \n    num_bins = (T + w - 1) // w\n    bin_activity = np.zeros(num_bins, dtype=int)\n    \n    for k in range(num_bins):\n        start_t = k * w\n        # Python slice end is exclusive, handles final bin correctly\n        end_t = (k + 1) * w\n        bin_activity[k] = np.sum(total_spikes_per_t[start_t:end_t])\n\n    # Step 5: Identify Avalanches and Their Sizes\n    avalanche_sizes = []\n    current_size = 0\n    is_in_avalanche = False\n    \n    for activity in bin_activity:\n        if activity > 0:\n            current_size += activity\n            is_in_avalanche = True\n        else:\n            if is_in_avalanche:\n                avalanche_sizes.append(current_size)\n                current_size = 0\n                is_in_avalanche = False\n                \n    # If the last bin was part of an avalanche, it needs to be recorded\n    if is_in_avalanche:\n        avalanche_sizes.append(current_size)\n        \n    # Step 6: Compute Avalanche Size Distribution\n    if not avalanche_sizes:\n        return []\n        \n    s_max = max(avalanche_sizes)\n    distribution = [0] * s_max\n    for s in avalanche_sizes:\n        # Sizes are 1-indexed, list is 0-indexed\n        distribution[s - 1] += 1\n        \n    return distribution\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [[0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0],\n         [0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0],\n         [0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0]],\n        # Test case 2\n        [[0,0,0,0,0,0,0,0,0,0],\n         [0,0,0,0,0,0,0,0,0,0]],\n        # Test case 3\n        [[1,1,1,1,1,1,1,1]],\n        # Test case 4\n        [[0,1,0,0,1,0,0,1,0,0,0,0],\n         [0,0,1,0,0,1,0,0,0,1,0,0]]\n    ]\n    \n    results = []\n    for R_list in test_cases:\n        dist = compute_avalanche_distribution(R_list)\n        results.append(dist)\n        \n    # Format the output string precisely as specified: [[...],[...]] with no spaces\n    formatted_results = []\n    for res_list in results:\n        # Convert each integer list to a string like '[c1,c2,...]'\n        formatted_list = f\"[{','.join(map(str, res_list))}]\"\n        formatted_results.append(formatted_list)\n    \n    # Join the formatted list strings into the final output format\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在从数据中提取出雪崩事件并测量其规模后，下一步是检验临界性理论的关键预测：雪崩规模的幂律分布。然而，从有限且含噪声的数据中稳健地估计幂律指数并评估拟合优度，充满了统计陷阱。这项练习  通过一系列概念性问题，旨在强调严谨分析的重要性，并介绍避免常见偏见和错误的原则性方法。",
            "id": "4041874",
            "problem": "一个神经形态多电极阵列产生一份神经雪崩目录，这些雪崩被定义为在宽度为 $\\Delta t$ 的离散时间窗内，活动超过检测阈值的连续序列。对于每次雪崩，您测量其大小 $s$（总脉冲数）和持续时间 $T$（连续活动时间窗的数量乘以 $\\Delta t$）。您假设，在一个中间标度范围内，大小和持续时间服从重尾定律，形式为 $P(s)\\propto s^{-\\tau}$ 和 $P(T)\\propto T^{-\\alpha}$，适用范围为 $s\\ge s_{\\min}$ 和 $T\\ge T_{\\min}$，直到在 $s\\approx s_{\\max}$ 和 $T\\approx T_{\\max}$ 处出现有限尺寸滚降。数据集包含 $N$ 次雪崩，但小 $s$ 和小 $T$ 的统计数据因阈值处理和离散化而失真，而大 $s$ 和大 $T$ 的统计数据因网络大小和观测时间而截断。您需要估计 $\\tau$ 和 $\\alpha$ 并评估拟合优度，仅使用基于统计推断的有原则的程序。\n\n根据基本原理，回顾一下：(i) 对于独立样本 $\\{x_i\\}_{i=1}^n$ 的概率模型 $p_{\\theta}(x)$ 产生一个似然函数 $L(\\theta)=\\prod_{i=1}^n p_{\\theta}(x_i)$ 和一个对数似然函数 $\\ell(\\theta)=\\sum_{i=1}^n \\log p_{\\theta}(x_i)$；(ii) 最大似然估计选择使 $\\ell(\\theta)$ 最大化的参数；(iii) 两个累积分布函数之间的 Kolmogorov–Smirnov (KS) 统计量是它们在定义域上绝对差的上确界。\n\n下列哪个陈述正确地解决了从有限、含噪声的雪崩数据中估计指数的认知挑战，以及下限截止值 $s_{\\min}$ 和 $T_{\\min}$ 的作用？\n\nA. 因为幂律标度在不同尺度上是自相似的，所以在整个观测范围 $\\left[s_{\\min}^{\\text{obs}},\\,s_{\\max}^{\\text{obs}}\\right]$ 内对对数-对数直方图进行直线拟合是渐近无偏的，即使最小的尺寸受到阈值处理的影响；更多的数据总是能减少偏差。\n\nB. 通过最小化 $s\\ge s_{\\min}$ 的经验累积分布函数与拟合的幂律模型之间的 Kolmogorov–Smirnov 距离来选择 $s_{\\min}$，然后对未分箱数据使用最大似然估计来估计 $\\tau$，这样做可以减少模型设定不当的偏差，但代价是随着 $s_{\\min}$ 的增加，方差会增大。\n\nC. 使用互补累积分布函数并在对数-对数空间中进行线性回归可以消除异方差性，并产生一个对 $\\tau$ 的无偏估计，而无需使用截止值。\n\nD. 因为持续时间 $T$ 是以 $\\Delta t$ 为步长离散化的，所以选择一个严格大于由 $\\Delta t$ 设定的离散化尺度的 $T_{\\min}$，可以减轻由离散化和阈值处理引起的小 $T$ 区域的曲率，否则这种曲率会使对 $\\alpha$ 的估计产生偏差。\n\nE. 如果系统大小强制产生一个上限截止值 $s_{\\max}$，在拟合一个未截断的幂律时，应该保留 $s$ 接近 $s_{\\max}$ 的雪崩，因为排除最大的事件会增加方差但不会改变偏差。\n\nF. 一个有原则的拟合优度检验程序会从具有相同 $s_{\\min}$（和 $T_{\\min}$）的拟合（可能截断的）幂律模型中抽取大小为 $N$ 的合成数据集，为每个合成数据集计算 Kolmogorov–Smirnov 统计量，并报告观测统计量的蒙特卡洛 $p$ 值。\n\nG. 如果检测噪声以与 $s$ 和 $T$ 无关的概率随机合并相邻的雪崩，那么估计的指数 $\\tau$ 和 $\\alpha$ 基本上保持无偏，因为合并过程与尺度无关。\n\n选择所有适用项。",
            "solution": "问题陈述提出了一个关于如何从神经雪崩的经验数据中，有原则地进行幂律指数的统计估计的问题，这些数据受到常见的实验伪影（如阈值处理、离散化和有限尺寸效应）的影响。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **系统**：一个产生神经雪崩的神经形态多电极阵列。\n- **雪崩定义**：在宽度为 $\\Delta t$ 的离散时间窗内，活动超过检测阈值的连续序列。\n- **数据**：对于每次雪崩，其大小 $s$（总脉冲数）和持续时间 $T$（活动时间窗数量 $\\times \\Delta t$）。\n- **假设模型**：\n    - 大小分布：$P(s) \\propto s^{-\\tau}$，对于 $s \\ge s_{\\min}$。\n    - 持续时间分布：$P(T) \\propto T^{-\\alpha}$，对于 $T \\ge T_{\\min}$。\n- **数据局限性**：\n    - 数据集包含 $N$ 次雪崩。\n    - 标度定律在中间范围内成立。\n    - 小 $s$ 和小 $T$ 的数据因阈值处理和离散化而失真。\n    - 大 $s$ 和大 $T$ 的数据因有限的网络大小和观测时间而被截断，在 $s \\approx s_{\\max}$ 和 $T \\approx T_{\\max}$ 处出现滚降。\n- **任务**：评估关于估计 $\\tau$ 和 $\\alpha$ 及评估拟合优度的陈述。\n- **提供的原理**：\n    - (i) 似然函数：$L(\\theta)=\\prod_{i=1}^n p_{\\theta}(x_i)$。\n    - (ii) 对数似然函数：$\\ell(\\theta)=\\sum_{i=1}^n \\log p_{\\theta}(x_i)$。\n    - (iii) 最大似然估计 (MLE) 最大化 $\\ell(\\theta)$。\n    - (iv) Kolmogorov–Smirnov (KS) 统计量：$D = \\sup_x |F_{\\text{empirical}}(x) - F_{\\text{model}}(x)|$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在计算神经科学和统计物理领域，特别是在神经系统临界性的研究中，有充分的依据。所描述的概念（神经雪崩、幂律分布、MLE、KS检验、有限尺寸效应、离散化伪影）是该研究领域的标准和核心内容。\n- **适定性**：问题是适定的。它要求在现实的、非理想的条件下，评估几个关于统计推断的程序性陈述。所提供的信息足以根据已建立的统计理论来判断这些陈述的有效性，并且是自洽的。\n- **客观性**：问题以客观、技术性的语言陈述，没有主观或模糊的术语。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它描述了一个标准的、现实的、且非平凡的科学情景。它在科学上是合理的、适定的、客观的，其组成部分可以通过统计推断的原理进行验证。我将继续分析每个选项。\n\n### 选项分析\n\n**A. 因为幂律标度在不同尺度上是自相似的，所以在整个观测范围 $\\left[s_{\\min}^{\\text{obs}},\\,s_{\\max}^{\\text{obs}}\\right]$ 内对对数-对数直方图进行直线拟合是渐近无偏的，即使最小的尺寸受到阈值处理的影响；更多的数据总是能减少偏差。**\n\n这个陈述包含几个谬误。\n1.  **方法**：通过线性回归对对数-对数直方图进行直线拟合是估计幂律指数的一种已知的有偏方法。该方法对分箱的选择很敏感，并且错误地假设频率对数的误差是独立同分布的（同方差），而事实并非如此。\n2.  **数据范围**：问题明确指出，小 $s$ 的统计数据“因阈值处理而失真”。将这些不遵循幂律假设的数据包含在拟合中，会引入系统误差（模型设定不当偏差）。真实幂律的自相似性不适用于混合分布。\n3.  **偏差与数据量**：声称“更多的数据总是能减少偏差”是不正确的。更多的数据会减少估计量的*方差*（统计不确定性），但它无法修正由拟合错误模型或使用有偏估计程序引起的系统*偏差*。事实上，随着数据量的增加，拟合会更精确地收敛到那个错误的、有偏的值。\n\n**结论：不正确。**\n\n**B. 通过最小化 $s\\ge s_{\\min}$ 的经验累积分布函数与拟合的幂律模型之间的 Kolmogorov–Smirnov 距离来选择 $s_{\\min}$，然后对未分箱数据使用最大似然估计来估计 $\\tau$，这样做可以减少模型设定不当的偏差，但代价是随着 $s_{\\min}$ 的增加，方差会增大。**\n\n这个陈述准确地描述了一种用于拟合幂律分布的有原则且被广泛采用的方法。\n1.  **程序**：所描述的方法是寻找标度区域下界 $s_{\\min}$ 的标准技术。对于每个候选的 $s_{\\min}$，使用最大似然估计 (MLE) 将幂律指数 $\\tau$ 拟合到数据 $\\{s_i | s_i \\ge s_{\\min}\\}$，MLE 是渐近无偏且有效的。然后，选择使数据的经验累积分布函数 (CDF) 与拟合的幂律 CDF 之间的 KS 距离最小化的那个 $s_{\\min}$ 作为最优值。此程序旨在找到模型与数据尾部之间的最佳匹配。\n2.  **偏差-方差权衡**：随着 $s_{\\min}$ 的增加，偏离幂律的低端数据点被丢弃。这减少了由模型设定不当引起的偏差。然而，丢弃数据会减少用于估计的样本量 $n$。$\\tau$ 的 MLE 的方差为 $\\text{Var}(\\hat{\\tau}) = (\\tau-1)^2/n + O(1/n^2)$，它随着 $n$ 的减小而增大。因此，增加 $s_{\\min}$ 是以增加方差为代价来换取减少偏差。这是统计模型选择中的一个基本概念。\n\n**结论：正确。**\n\n**C. 使用互补累积分布函数并在对数-对数空间中进行线性回归可以消除异方差性，并产生一个对 $\\tau$ 的无偏估计，而无需使用截止值。**\n\n这个陈述在多个方面都是不正确的。\n1.  **异方差性**：虽然绘制对数变换后的互补累积分布函数 (CCDF) 通常在视觉上比对数分箱的直方图更平滑，但它并不能消除异方差性。CCDF 图上的点在统计上不是独立的（例如，在 $s$ 处的值与在 $s+1$ 处的值相关），并且它们的方差也不相等。应用假设误差独立且同方差的标准线性回归，仍然是一种有偏的估计程序。\n2.  **无偏估计**：由于线性回归的假设被违反，因此得到的 $\\tau$ 的估计是有偏的。最大似然估计 (MLE) 是获得渐近无偏估计的首选方法。\n3.  **截止值的需要**：问题指出，幂律行为仅在 $s \\ge s_{\\min}$ 时成立。任何低于此截止值的数据都会导致经验 CCDF 偏离幂律形状。因此，仍然需要一个截止值 $s_{\\min}$ 来定义执行线性回归的域。包含失真的小 $s$ 数据会使拟合产生偏差。\n\n**结论：不正确。**\n\n**D. 因为持续时间 $T$ 是以 $\\Delta t$ 为步长离散化的，所以选择一个严格大于由 $\\Delta t$ 设定的离散化尺度的 $T_{\\min}$，可以减轻由离散化和阈值处理引起的小 $T$ 区域的曲率，否则这种曲率会使对 $\\alpha$ 的估计产生偏差。**\n\n离散化问题对于神经雪崩数据至关重要。\n1.  **离散化效应**：持续时间 $T$ 是时间窗 $\\Delta t$ 的整数倍。对于较小的 $T$ 值（例如，$T = \\Delta t, 2\\Delta t, \\dots$），连续幂律模型 $P(T) \\propto T^{-\\alpha}$ 是对离散现实的一个不良近似。此外，雪崩的定义本身（连续的活动窗超过阈值）就可能在最小可能持续时间处产生伪影。例如，单个活动窗是最小的可能雪崩，其频率可能会根据精确的阈值和噪声水平而异常地高或低。这些效应在对数-对数图中引入了“曲率”或偏离直线的情况。\n2.  **缓解措施**：通过选择一个比 $\\Delta t$ 大几倍的下限截止值 $T_{\\min}$，可以将拟合集中在数据的离散性不那么显著且连续幂律近似更准确的区域。此程序有效地忽略了分布中受离散化和阈值处理伪影影响最严重的第一部分，从而减少了指数 $\\alpha$ 估计中的偏差。\n\n**结论：正确。**\n\n**E. 如果系统大小强制产生一个上限截止值 $s_{\\max}$，在拟合一个未截断的幂律时，应该保留 $s$ 接近 $s_{\\max}$ 的雪崩，因为排除最大的事件会增加方差但不会改变偏差。**\n\n这个陈述误解了上限截止值的效果。\n1.  **上限截止值的效果**：有限的系统大小会导致分布出现“滚降”，这意味着最大事件的频率低于纯幂律所预测的频率。其潜在分布更适合用截断幂律来描述，例如 $P(s) \\propto s^{-\\tau} f(s/s_c)$，其中 $f$ 是一个截止函数，如 $e^{-s/s_c}$。\n2.  **偏差**：将一个*未截断*的幂律模型拟合到包含此滚降区域的数据是一种模型设定不当。频率较低的大事件会系统地“拉低”拟合的尾部，导致更陡的斜率。这会导致对指数 $\\tau$ 的*高估*。因此，保留这些事件会*引入*偏差，而不是使其保持不变。正确的程序应该是拟合一个截断幂律模型，或者在滚降开始的点 $s  s_{\\max}$ 处截断数据本身。\n3.  **方差**：排除最大的事件确实会增加估计的方差（通过减少样本量），但这是为了避免保留它们所引入的显著偏差而做出的权衡。\n\n**结论：不正确。**\n\n**F. 一个有原则的拟合优度检验程序会从具有相同 $s_{\\min}$（和 $T_{\\min}$）的拟合（可能截断的）幂律模型中抽取大小为 $N$ 的合成数据集，为每个合成数据集计算 Kolmogorov–Smirnov 统计量，并报告观测统计量的蒙特卡洛 $p$ 值。**\n\n这个陈述准确地描述了当模型参数从数据中估计时，进行拟合优度检验的一种当前最佳方法。\n1.  **标准检验的问题**：用于 KS 检验 $p$ 值的标准教科书公式仅在假设的分布在*查看*数据之前已完全指定时才有效。当参数（如 $\\tau$ 和 $s_{\\min}$）是从数据中估计时，数据自然会更接近拟合的模型，使得 KS 统计量比正常情况下要小。使用标准表格会导致对原假设的拒绝不足（即，我们会认为拟合比实际情况要好）。\n2.  **蒙特卡洛/自助法解决方案**：所描述的程序是一种半参数自助法，它正确地计算了在原假设（即数据来自幂律分布*族*）下 KS 统计量的分布。通过从*最佳拟合*模型生成合成数据，并对每个合成数据集重新进行拟合以计算合成 KS 统计量，可以为检验统计量创建正确的零分布。将观测到的 KS 统计量与此分布进行比较，可以得出一个统计上有效的 $p$ 值。\n\n**结论：正确。**\n\n**G. 如果检测噪声以与 $s$ 和 $T$ 无关的概率随机合并相邻的雪崩，那么估计的指数 $\\tau$ 和 $\\alpha$ 基本上保持无偏，因为合并过程与尺度无关。**\n\n这个陈述对事件合并效应做出了错误的结论。\n1.  **合并的影响**：当两个较小的相邻雪崩合并成一个较大的雪崩时，雪崩总数减少一个。分布的变化是从主体中移除了两个事件，并在尾部增加了一个事件。这不是一个尺度不变的操作。它系统地耗尽了较小雪崩的数量，并创造了可能不会自然发生的较大雪崩。\n2.  **对指数的影响**：这种聚合过程会使分布的尾部比真实情况“更重”。更重的尾部对应于*更小*的幂律指数。因此，估计的指数 $\\tau$ 和 $\\alpha$ 将会有偏差，具体来说，它们很可能会被低估。前提“与尺度无关”并不能挽救结论，因为合并本身就是对概率分布的一种尺度相关的变换。\n\n**结论：不正确。**",
            "answer": "$$\\boxed{BDF}$$"
        }
    ]
}