{
    "hands_on_practices": [
        {
            "introduction": "为了理解类器官计算的内在机制，数学模型是必不可少的工具。Wilson-Cowan模型是描述兴奋性与抑制性神经元群体相互作用的经典框架。本练习将通过分析该模型，帮助你理解这些相互作用如何产生节律性活动（振荡），这也是在脑活动和类器官的多电极阵列（MEA）记录中常见的特征。",
            "id": "4037921",
            "problem": "考虑一个作为生物混合系统与多电极阵列 (MEA) 连接的皮层类器官网络。一种粗粒化的兴奋-抑制群体描述由 Wilson–Cowan 方程建模\n$$\\tau_{e} \\,\\dot{E}(t) = -E(t) + S\\!\\left(w_{ee}\\,E(t) - w_{ei}\\,I(t) + P\\right)$$\n$$\\tau_{i} \\,\\dot{I}(t) = -I(t) + S\\!\\left(w_{ie}\\,E(t) - w_{ii}\\,I(t)\\right),$$\n其中 $E(t)$ 和 $I(t)$ 是无量纲的群体放电率，$\\tau_{e}$ 和 $\\tau_{i}$ 是正时间常数，$w_{ee}, w_{ei}, w_{ie}, w_{ii}$ 是无量纲的有效突触耦合，$P$ 是一个恒定的兴奋性驱动，$S(x)$ 是一个表示群体响应曲线的可微 S 型激活函数。在一个工作状态下，该类器官表现出稳态活动，并在 MEA 功率谱中可观测到小振幅振荡。在此状态下，$S$ 在稳态输入处的局部增益（斜率）被经验地估计为 $s_{e} = S'\\!\\left(w_{ee}\\,E^{*} - w_{ei}\\,I^{*} + P\\right)$ 和 $s_{i} = S'\\!\\left(w_{ie}\\,E^{*} - w_{ii}\\,I^{*}\\right)$，其中 $E^{*}$ 和 $I^{*}$ 表示稳态速率。\n\n从模型方程和基本的线性系统分析出发，推导在何种条件下，围绕 $(E^{*}, I^{*})$ 的线性化动力学表现出振荡模式，并用线性化参数得到小振荡角频率的表达式。然后，对于给定的参数集\n- $\\tau_{e} = 0.02 \\ \\mathrm{s}$, $\\tau_{i} = 0.01 \\ \\mathrm{s}$,\n- $w_{ee} = 1.5$, $w_{ei} = 2.0$, $w_{ie} = 3.0$, $w_{ii} = 0.5$,\n- $s_{e} = 0.8$, $s_{i} = 0.7$,\n计算在 MEA 功率谱中观测到的预测振荡频率，假设系统足够接近稳态工作点，以使线性预测有效。将您的答案四舍五入到 $4$ 位有效数字，并以 $\\mathrm{Hz}$ 为单位表示。您可以将 $P$ 和稳态 $(E^{*}, I^{*})$ 视为仅确定 $s_{e}$ 和 $s_{i}$ 的固定量，并且除了这些斜率之外，它们不会显式地进入线性化过程。",
            "solution": "用户提供的问题被评估为有效。它在科学上基于完善的神经群体动力学 Wilson-Cowan 模型，这是计算神经科学中的一个标准框架。该问题是适定的，为标准的线性稳定性分析提供了一套完整的方程和参数。语言客观精确，设定自洽且内部一致。未发现任何会使问题无效的缺陷。因此，我们可以继续进行解答。\n\n该问题要求推导由 Wilson-Cowan 方程描述的系统出现振荡行为的条件及相应的振荡频率，然后对给定的参数集进行数值计算。分析始于将系统在其稳态点 $(E^{*}, I^{*})$ 周围进行线性化。\n\n给定的方程组是：\n$$\n\\tau_{e} \\,\\dot{E}(t) = -E(t) + S(u_e(t))\n$$\n$$\n\\tau_{i} \\,\\dot{I}(t) = -I(t) + S(u_i(t))\n$$\n其中 $u_e(t) = w_{ee}\\,E(t) - w_{ei}\\,I(t) + P$ 且 $u_i(t) = w_{ie}\\,E(t) - w_{ii}\\,I(t)$。\n\n在稳态 $(E^{*}, I^{*})$ 处，时间导数为零：\n$$\n0 = -E^{*} + S(u_e^{*})\n$$\n$$\n0 = -I^{*} + S(u_i^{*})\n$$\n其中 $u_e^{*} = w_{ee}\\,E^{*} - w_{ei}\\,I^{*} + P$ 且 $u_i^{*} = w_{ie}\\,E^{*} - w_{ii}\\,I^{*}$。\n\n为了分析这个稳态附近的动力学，我们引入小扰动 $\\delta_E(t) = E(t) - E^{*}$ 和 $\\delta_I(t) = I(t) - I^{*}$。通过将 $E(t) = E^{*} + \\delta_E(t)$ 和 $I(t) = I^{*} + \\delta_I(t)$ 代入原方程，并对 S 型函数 $S(x)$ 在稳态输入 $u_e^{*}$ 和 $u_i^{*}$ 周围进行一阶泰勒展开，可以找到这些扰动的时间演化。\n\n对于兴奋性群体：\n$$\n\\tau_e \\dot{\\delta}_E(t) = -(E^{*} + \\delta_E(t)) + S(u_e^{*} + w_{ee}\\delta_E(t) - w_{ei}\\delta_I(t))\n$$\n使用泰勒展开 $S(x_0 + \\Delta x) \\approx S(x_0) + S'(x_0)\\Delta x$：\n$$\n\\tau_e \\dot{\\delta}_E(t) \\approx -E^{*} - \\delta_E(t) + S(u_e^{*}) + S'(u_e^{*})(w_{ee}\\delta_E(t) - w_{ei}\\delta_I(t))\n$$\n由于在稳态时 $-E^{*} + S(u_e^{*}) = 0$，并使用给定的定义 $s_e = S'(u_e^{*})$，该方程简化为：\n$$\n\\tau_e \\dot{\\delta}_E(t) = -\\delta_E(t) + s_e(w_{ee}\\delta_E(t) - w_{ei}\\delta_I(t))\n$$\n$$\n\\dot{\\delta}_E(t) = \\frac{1}{\\tau_e}[(s_e w_{ee} - 1)\\delta_E(t) - s_e w_{ei}\\delta_I(t)]\n$$\n\n同样，对于抑制性群体：\n$$\n\\tau_i \\dot{\\delta}_I(t) = -(I^{*} + \\delta_I(t)) + S(u_i^{*} + w_{ie}\\delta_E(t) - w_{ii}\\delta_I(t))\n$$\n展开并使用稳态条件 $-I^{*} + S(u_i^{*}) = 0$ 和定义 $s_i = S'(u_i^{*})$：\n$$\n\\tau_i \\dot{\\delta}_I(t) \\approx -\\delta_I(t) + s_i(w_{ie}\\delta_E(t) - w_{ii}\\delta_I(t))\n$$\n$$\n\\dot{\\delta}_I(t) = \\frac{1}{\\tau_i}[s_i w_{ie}\\delta_E(t) - (1 + s_i w_{ii})\\delta_I(t)]\n$$\n\n这个线性化系统可以写成矩阵形式 $\\dot{\\mathbf{x}} = J\\mathbf{x}$，其中 $\\mathbf{x} = \\begin{pmatrix} \\delta_E \\\\ \\delta_I \\end{pmatrix}$，$J$ 是在稳态处求值的雅可比矩阵：\n$$\nJ = \\begin{pmatrix}\n\\frac{s_e w_{ee} - 1}{\\tau_e}  -\\frac{s_e w_{ei}}{\\tau_e} \\\\\n\\frac{s_i w_{ie}}{\\tau_i}  -\\frac{1 + s_i w_{ii}}{\\tau_i}\n\\end{pmatrix}\n$$\n线性化系统的动力学由 $J$ 的特征值 $\\lambda$ 决定，它们是特征方程 $\\det(J - \\lambda I) = 0$ 的根。该方程为 $\\lambda^2 - \\text{Tr}(J)\\lambda + \\det(J) = 0$，其中 $\\text{Tr}(J)$ 是雅可比矩阵的迹，$\\det(J)$ 是其行列式。\n\n特征值由下式给出：\n$$\n\\lambda = \\frac{\\text{Tr}(J) \\pm \\sqrt{(\\text{Tr}(J))^2 - 4\\det(J)}}{2}\n$$\n当特征值为一对共轭复数时，系统表现出振荡模式。这种情况发生在特征方程的判别式为负时。\n振荡模式的条件：\n$$\n(\\text{Tr}(J))^2 - 4\\det(J)  0\n$$\n当此条件满足时，特征值的形式为 $\\lambda = \\alpha \\pm i\\omega$，其中 $\\alpha = \\frac{\\text{Tr}(J)}{2}$ 是决定稳定性（振荡的增长或衰减）的实部，$\\omega$ 是表示小振荡角频率的虚部。\n角频率的表达式为：\n$$\n\\omega = \\frac{\\sqrt{4\\det(J) - (\\text{Tr}(J))^2}}{2}\n$$\n这完成了问题的推导部分。\n\n现在，我们为给定的参数计算数值：\n$\\tau_{e} = 0.02 \\ \\mathrm{s}$, $\\tau_{i} = 0.01 \\ \\mathrm{s}$\n$w_{ee} = 1.5$, $w_{ei} = 2.0$, $w_{ie} = 3.0$, $w_{ii} = 0.5$\n$s_{e} = 0.8$, $s_{i} = 0.7$\n\n首先，计算雅可比矩阵 $J$ 的元素：\n$$\nJ_{11} = \\frac{s_e w_{ee} - 1}{\\tau_e} = \\frac{(0.8)(1.5) - 1}{0.02} = \\frac{1.2 - 1}{0.02} = \\frac{0.2}{0.02} = 10 \\ \\mathrm{s}^{-1}\n$$\n$$\nJ_{12} = -\\frac{s_e w_{ei}}{\\tau_e} = -\\frac{(0.8)(2.0)}{0.02} = -\\frac{1.6}{0.02} = -80 \\ \\mathrm{s}^{-1}\n$$\n$$\nJ_{21} = \\frac{s_i w_{ie}}{\\tau_i} = \\frac{(0.7)(3.0)}{0.01} = \\frac{2.1}{0.01} = 210 \\ \\mathrm{s}^{-1}\n$$\n$$\nJ_{22} = -\\frac{1 + s_i w_{ii}}{\\tau_i} = -\\frac{1 + (0.7)(0.5)}{0.01} = -\\frac{1 + 0.35}{0.01} = -\\frac{1.35}{0.01} = -135 \\ \\mathrm{s}^{-1}\n$$\n雅可比矩阵为 $J = \\begin{pmatrix} 10  -80 \\\\ 210  -135 \\end{pmatrix}$。\n\n接下来，我们计算 $J$ 的迹和行列式：\n$$\n\\text{Tr}(J) = J_{11} + J_{22} = 10 - 135 = -125 \\ \\mathrm{s}^{-1}\n$$\n$$\n\\det(J) = J_{11}J_{22} - J_{12}J_{21} = (10)(-135) - (-80)(210) = -1350 + 16800 = 15450 \\ \\mathrm{s}^{-2}\n$$\n\n现在，我们检查振荡的条件：\n$$\n(\\text{Tr}(J))^2 - 4\\det(J) = (-125)^2 - 4(15450) = 15625 - 61800 = -46175\n$$\n由于判别式为负 ($-46175  0$)，系统表现出振荡行为。由于 $\\text{Tr}(J)  0$，振荡是阻尼的，稳态是一个稳定的螺线点，这与问题描述的“具有小振幅振荡的稳态活动”一致。\n\n最后，我们计算角频率 $\\omega$ 和以赫兹为单位的频率 $f$。\n$$\n\\omega = \\frac{\\sqrt{4\\det(J) - (\\text{Tr}(J))^2}}{2} = \\frac{\\sqrt{4(15450) - (-125)^2}}{2} = \\frac{\\sqrt{61800 - 15625}}{2} = \\frac{\\sqrt{46175}}{2} \\ \\mathrm{rad/s}\n$$\n以赫兹为单位的频率是 $f = \\frac{\\omega}{2\\pi}$：\n$$\nf = \\frac{\\sqrt{46175}}{4\\pi} \\approx \\frac{214.88369}{4\\pi} \\approx 17.09999 \\ \\mathrm{Hz}\n$$\n四舍五入到 $4$ 位有效数字，预测的振荡频率是 $17.10 \\ \\mathrm{Hz}$。",
            "answer": "$$\n\\boxed{17.10}\n$$"
        },
        {
            "introduction": "在建立了动力学模型之后，下一步是量化系统的功能。一个核心目标是评估类器官处理信息的能力。本练习将介绍来自香农信息论的互信息（Mutual Information）这一强大工具，它能够不依赖特定模型来衡量刺激与神经响应之间的关联强度，并具体计算一个简单的类器官系统能够传递多少信息。",
            "id": "4037904",
            "problem": "一个与微电极阵列（MEA）连接的人类皮层类器官，通过离散的细胞外刺激幅度进行驱动，在短观察窗口内产生脉冲计数响应。设离散刺激集为 $S \\in \\{s_{1}, s_{2}, s_{3}\\}$，分别代表低、中、高三种幅度。在一个固定的 $T = 50\\,\\mathrm{ms}$ 观察窗口内，脉冲计数响应被离散化为 $Y \\in \\{0, 1, 2, 3\\}$。假设系统具有平稳性，并且在每个刺激下的重复试验产生了以下根据经验观察到的条件响应分布：\n- 对于 $s_{1}$：$p(y \\mid s_{1}) = [0.5, 0.3, 0.15, 0.05]$，对应 $y = 0, 1, 2, 3$。\n- 对于 $s_{2}$：$p(y \\mid s_{2}) = [0.2, 0.4, 0.3, 0.1]$，对应 $y = 0, 1, 2, 3$。\n- 对于 $s_{3}$：$p(y \\mid s_{3}) = [0.05, 0.15, 0.35, 0.45]$，对应 $y = 0, 1, 2, 3$。\n\n假设先验刺激分布是均匀的，即 $p(s_{1}) = p(s_{2}) = p(s_{3}) = 1/3$。使用香农信息论中互信息的定义，计算刺激 $S$ 和脉冲计数响应 $Y$ 之间的互信息 $I(S;Y)$。请用比特（使用以2为底的对数）表示您的答案，并将结果四舍五入到四位有效数字。此外，基于计算出的值和所提供的分布，简要解释当刺激强度增加到超过 $s_{3}$ 时，高刺激强度下脉冲计数的饱和现象对 $I(S;Y)$ 意味着什么。",
            "solution": "用户提供了一个在计算神经科学和信息论领域中明确定义的问题。该问题具有科学依据、内容自洽，且所有给出的概率分布都是有效的（即，在每种条件下，概率之和为1）。因此，该问题被认定为有效，并将提供解答。\n\n主要任务是计算刺激集 $S = \\{s_1, s_2, s_3\\}$ 与脉冲计数响应集 $Y = \\{0, 1, 2, 3\\}$ 之间的互信息 $I(S;Y)$。互信息量化了通过观察一个随机变量而获得的关于另一个随机变量不确定性的减少量。它有几种等价的定义方式，对于本问题而言，最方便的一种是：\n$$I(S;Y) = H(Y) - H(Y|S)$$\n其中 $H(Y)$ 是响应分布的熵，$H(Y|S)$ 是在给定刺激下的响应的条件熵。计算将使用以2为底的对数，因为答案要求以比特为单位。\n\n首先，我们计算条件熵 $H(Y|S)$。该量是响应的平均熵，其中平均值是针对所有可能的刺激计算的。其公式如下：\n$$H(Y|S) = \\sum_{s \\in S} p(s) H(Y|S=s)$$\n其中 $H(Y|S=s)$ 是针对特定刺激 $s$ 的响应分布的熵：\n$$H(Y|S=s) = -\\sum_{y \\in Y} p(y|s) \\log_2(p(y|s))$$\n问题陈述了刺激的先验分布是均匀的，所以 $p(s_1) = p(s_2) = p(s_3) = \\frac{1}{3}$。\n\n让我们计算每个刺激下的条件熵：\n对于 $s_1$：\n$H(Y|S=s_1) = -[p(0|s_1)\\log_2(p(0|s_1)) + p(1|s_1)\\log_2(p(1|s_1)) + p(2|s_1)\\log_2(p(2|s_1)) + p(3|s_1)\\log_2(p(3|s_1))]$\n$H(Y|S=s_1) = -[0.5\\log_2(0.5) + 0.3\\log_2(0.3) + 0.15\\log_2(0.15) + 0.05\\log_2(0.05)]$\n$H(Y|S=s_1) \\approx 1.64775$ 比特。\n\n对于 $s_2$：\n$H(Y|S=s_2) = -[0.2\\log_2(0.2) + 0.4\\log_2(0.4) + 0.3\\log_2(0.3) + 0.1\\log_2(0.1)]$\n$H(Y|S=s_2) \\approx 1.84644$ 比特。\n\n对于 $s_3$：\n$H(Y|S=s_3) = -[0.05\\log_2(0.05) + 0.15\\log_2(0.15) + 0.35\\log_2(0.35) + 0.45\\log_2(0.45)]$\n$H(Y|S=s_3) \\approx 1.67517$ 比特。\n\n现在，我们可以计算总条件熵 $H(Y|S)$：\n$H(Y|S) = p(s_1)H(Y|S=s_1) + p(s_2)H(Y|S=s_2) + p(s_3)H(Y|S=s_3)$\n$H(Y|S) = \\frac{1}{3} (1.64775 + 1.84644 + 1.67517) = \\frac{1}{3} (5.16936)$\n$H(Y|S) \\approx 1.72312$ 比特。\n\n接下来，我们计算响应的边缘熵 $H(Y)$。为此，我们首先需要响应的边缘概率分布 $p(y)$，它可以通过全概率定律求得：\n$$p(y) = \\sum_{s \\in S} p(y|s)p(s)$$\n鉴于均匀先验 $p(s) = \\frac{1}{3}$：\n$p(y=0) = \\frac{1}{3} (p(0|s_1) + p(0|s_2) + p(0|s_3)) = \\frac{1}{3} (0.5 + 0.2 + 0.05) = \\frac{0.75}{3} = 0.25$\n$p(y=1) = \\frac{1}{3} (p(1|s_1) + p(1|s_2) + p(1|s_3)) = \\frac{1}{3} (0.3 + 0.4 + 0.15) = \\frac{0.85}{3}$\n$p(y=2) = \\frac{1}{3} (p(2|s_1) + p(2|s_2) + p(2|s_3)) = \\frac{1}{3} (0.15 + 0.3 + 0.35) = \\frac{0.80}{3}$\n$p(y=3) = \\frac{1}{3} (p(3|s_1) + p(3|s_2) + p(3|s_3)) = \\frac{1}{3} (0.05 + 0.1 + 0.45) = \\frac{0.60}{3} = 0.20$\n\n现在，我们计算边缘熵 $H(Y)$：\n$$H(Y) = -\\sum_{y \\in Y} p(y)\\log_2(p(y))$$\n$H(Y) = -[p(0)\\log_2(p(0)) + p(1)\\log_2(p(1)) + p(2)\\log_2(p(2)) + p(3)\\log_2(p(3))]$\n$H(Y) = -[0.25\\log_2(0.25) + \\frac{0.85}{3}\\log_2(\\frac{0.85}{3}) + \\frac{0.80}{3}\\log_2(\\frac{0.80}{3}) + 0.20\\log_2(0.20)]$\n$H(Y) \\approx -[0.25(-2) + 0.28333(-1.8193) + 0.26667(-1.9069) + 0.20(-2.3219)]$\n$H(Y) \\approx -[-0.5 - 0.51547 - 0.50851 - 0.46438]$\n$H(Y) \\approx 1.98838$ 比特。\n\n最后，我们计算互信息 $I(S;Y)$：\n$I(S;Y) = H(Y) - H(Y|S) \\approx 1.98838 - 1.72312 = 0.26526$ 比特。\n四舍五入到四位有效数字，我们得到 $0.2653$ 比特。\n\n问题的第二部分要求解释当刺激强度增加到超过 $s_{3}$ 时，脉冲计数的饱和现象对 $I(S;Y)$ 意味着什么。\n神经响应饱和意味着，当刺激强度 $s$ 大于某个水平（在此例中为超过 $s_3$）时，脉冲计数响应分布 $p(y|s)$ 不再发生显著变化。例如，对于一个刺激 $s_4  s_3$，我们会有 $p(y|s_4) \\approx p(y|s_3)$。互信息 $I(S;Y)$ 衡量了利用响应 $Y$ 来区分 $S$ 中不同刺激的能力。如果多个不同的高强度刺激（例如 $s_3, s_4, s_5, \\dots$）都产生相同的统计响应，那么基于观察脉冲计数 $Y$ 就无法区分它们。尽管增加刺激水平的数量会增加刺激集 $S$ 的总熵 $H(S)$，但传输的信息 $I(S;Y)$ 不会成比例增加。无法区分饱和刺激意味着在给定响应的情况下关于刺激的不确定性 $H(S|Y)$ 会随着 $H(S)$ 一起增长，导致它们的差值 $I(S;Y)$ 达到一个平台期。由类器官形成的信息通道达到饱和，表明系统能够编码的关于刺激强度的信息量存在一个上限。本质上，不同的输入被映射到统计上无法区分的输出，导致了信息传输的瓶颈。",
            "answer": "$$\n\\boxed{0.2653}\n$$"
        },
        {
            "introduction": "多电极阵列（MEA）记录为我们提供了一个观察类器官活动的窗口，但其底层的网络结构是隐藏的。格兰杰因果（Granger causality）分析是一种从时间序列数据中推断功能性连接方向的统计方法。本练习将演示如何从原始时间序列数据中构建一个描绘网络中潜在信息流动的图谱，并强调了在分析中考虑共同输入以避免伪连接的重要性。",
            "id": "4037977",
            "problem": "给定一项指令，要求您设计并实现一种算法，该算法在向量自回归 (VAR) 框架内使用格兰杰因果关系 (GC) 来推断从生物混合系统（例如配备多个电极的类器官网络）记录的通道之间的有向连接性。请从格兰杰因果关系的公认定义开始：如果时间序列 $x_t$ 的过去值包含了对 $y_t$ 的独特预测信息，而这些信息超出了仅 $y_t$ 的过去值所包含的信息，则称时间序列 $x_t$ 格兰杰导致 (Granger-cause) 时间序列 $y_t$。使用适当阶数的 VAR 模型和通过普通最小二乘法 (OLS) 进行嵌套假设检验的原理，来推导并实现一个有向连接性的检验。通过计算双变量 GC（忽略共同输入）和条件 GC（包含一个记录到的共同输入通道以控制混淆）来明确地纳入共同输入的情况。从第一性原理和标准假设出发，论证在存在共同输入时，因果可识别性在何种条件下可以实现。\n\n您必须生成一个完整的、可运行的程序，该程序能够：\n- 根据指定的测试用例，使用一个稳定的 $p$ 阶向量自回归 (VAR) 模型来模拟多通道时间序列：\n$$\n\\mathbf{y}_t = \\sum_{k=1}^{p} \\mathbf{A}_k \\mathbf{y}_{t-k} + \\mathbf{e}_t,\n$$\n其中 $\\mathbf{y}_t \\in \\mathbb{R}^n$ 是时间 $t$ 的通道向量，$\\mathbf{A}_k \\in \\mathbb{R}^{n \\times n}$ 是滞后系数矩阵，$\\mathbf{e}_t \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$ 是协方差为 $\\boldsymbol{\\Sigma}$ 的零均值高斯新息噪声。必须通过选择系数以使伴随矩阵的谱半径小于 $1$ 来确保稳定性。\n\n- 对于每个有向对 $(x \\to y)$，拟合一个包含所有相关通道滞后项的无约束 OLS 回归，以及一个排除驱动通道滞后项的有约束 OLS 回归。使用嵌套模型框架计算格兰杰因果关系 $F$-统计量及其在用户定义的显著性水平 $\\alpha$（以小数表示）下的显著性水平。\n\n- 对于每次检验，从候选集中选择 VAR 阶数 $p$。使用从目标通道的无约束回归中计算出的贝叶斯信息准则 (BIC) 进行选择。考虑候选集 $p \\in \\{1, 2\\}$，并选择使 BIC 最小化的 $p$。\n\n- 对于每个测试用例，计算四个布尔值输出，表示在水平 $\\alpha$ 下存在显著的有向连接性：\n    $[\\text{X}\\to\\text{Y (双变量)},\\ \\text{Y}\\to\\text{X (双变量)},\\ \\text{X}\\to\\text{Y (条件)},\\ \\text{Y}\\to\\text{X (条件)}]$。\n\n应使用的科学基础和假设：\n- 时域中的格兰杰因果关系 (GC) 定义：如果在给定已包含变量的条件下，包含 $x_t$ 的过去值相比于排除 $x_t$ 过去值的模型，能够减少 $y_t$ 的预测误差方差，则 $x_t$ 格兰杰导致 $y_t$。\n- 在高斯新息下的普通最小二乘法 (OLS) 为线性 VAR 模型提供了最大似然估计量，从而在标准正则性条件下能够进行有效的 $F$-检验。\n- 用于模型阶数选择的贝叶斯信息准则 (BIC)：对于一个具有 $n_{\\text{eff}}$ 个样本、残差平方和为 $\\text{RSS}$ 和 $k$ 个参数的 OLS 回归，BIC 为\n$$\n\\text{BIC} = n_{\\text{eff}} \\cdot \\ln\\left(\\frac{\\text{RSS}}{n_{\\text{eff}}}\\right) + k \\cdot \\ln(n_{\\text{eff}}).\n$$\n\n检验框架和显著性计算：\n- 对于有向检验 $x \\to y$，选择的滞后阶数为 $p$，包含的通道集大小为 $d$，定义无约束回归，它有 $k_u = d \\cdot p$ 个参数（无截距），用所有包含通道的滞后值预测 $y_t$。同时定义有约束回归，它从预测变量中移除了 $x_t$ 的 $p$ 个滞后项，从而得到 $k_r = (d-1) \\cdot p$ 个参数。对于 $n_{\\text{eff}} = T - p$ 个有效样本以及残差平方和 $\\text{RSS}_u$ 和 $\\text{RSS}_r$，计算 $F$-统计量：\n$$\nF = \\frac{\\left(\\text{RSS}_r - \\text{RSS}_u\\right) / m}{\\text{RSS}_u / (n_{\\text{eff}} - k_u)},\n$$\n其中 $m = p$ 是线性约束的数量。在 $x_t$ 不格兰杰导致 $y_t$ 的零假设下，$F$ 服从自由度为 $(m, n_{\\text{eff}} - k_u)$ 的 $F$-分布。计算 $p$-值，如果 $p$-值小于 $\\alpha$ 且 $\\text{RSS}_r  \\text{RSS}_u$，则宣告显著。\n\n存在共同输入时的因果可识别性条件：\n- 为了减轻由同时驱动 $x_t$ 和 $y_t$ 的共同输入 $z_t$ 引起的伪因果关系，条件 GC 必须在 VAR 模型中包含记录到的 $z_t$。如果共同输入被记录并包含在内，并且通道间的新息不相关，则在平稳性和模型阶数正确的条件下，条件 GC 检验能够渐近地识别有向连接性。\n- 如果存在一个未被记录的潜在共同输入，可识别性可能会失败；有助于识别的条件包括：观测变量足以阻断所有后门路径、新息的独立性和白噪声特性、不存在瞬时（零延迟）耦合，以及使用正确的滞后阶数以捕捉真实动态。\n\n使用以下测试套件来模拟数据并评估算法。在所有情况下，将显著性阈值设置为 $\\alpha = 0.01$，候选滞后阶数设置为 $p \\in \\{1, 2\\}$，随机种子设置为 $0$。通道索引为 $X \\equiv 0$, $Y \\equiv 1$, $Z \\equiv 2$。\n\n- 测试用例 1（存在共同输入和真实有向边的理想情况）：$T = 1024$, $n = 3$，$\\mathbf{A}_1$ 和 $\\mathbf{A}_2$ 由下式给出\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2   0.0   0.3 \\\\\n0.5   0.2   0.4 \\\\\n0.0   0.0   0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\begin{bmatrix}\n0.0   0.0   0.0 \\\\\n0.0   0.0   0.0 \\\\\n0.0   0.0   0.0\n\\end{bmatrix},\n$$\n其中 $\\boldsymbol{\\Sigma} = \\sigma^2 \\mathbf{I}$，$\\sigma = 0.5$。\n\n- 测试用例 2（纯共同输入，X 和 Y 之间没有直接边）：$T = 1024$, $n = 3$，\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2   0.0   0.5 \\\\\n0.0   0.2   0.5 \\\\\n0.0   0.0   0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 0.5$。\n\n- 测试用例 3（弱耦合和低信噪比）：$T = 1024$, $n = 3$，\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2   0.0   0.0 \\\\\n0.15   0.2   0.0 \\\\\n0.0   0.0   0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 1.0$。\n\n- 测试用例 4（无共同输入的双向耦合）：$T = 1024$, $n = 3$，\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2   0.25   0.0 \\\\\n0.35   0.2   0.0 \\\\\n0.0   0.0   0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 0.5$。\n\n- 测试用例 5（短记录长度边界情况）：$T = 64$, $n = 3$，\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.1   0.0   0.3 \\\\\n0.3   0.1   0.2 \\\\\n0.0   0.0   0.2\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 0.5$。\n\n程序要求：\n- 针对每种情况，使用指定的 $\\mathbf{A}_k$ 和 $\\boldsymbol{\\Sigma}$ 实现模拟。\n- 对于每个测试用例，计算四个布尔型 GC 显著性指标：双变量 $X \\to Y$，双变量 $Y \\to X$，包含 $Z$ 的条件 $X \\to Y$，包含 $Z$ 的条件 $Y \\to X$，每个都在 $\\alpha = 0.01$ 的水平下。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果都按指定顺序以四个布尔值的列表形式报告。例如：\n$[\\,[\\text{true},\\text{false},\\text{true},\\text{false}],\\ldots\\,]$。",
            "solution": "从多通道时间序列中推断有向连接性的问题是理解复杂系统的基础，尤其是在神经科学和生物混合计算领域，这些领域使用电极阵列记录神经网络或类器官的活动。所提出的任务是实现格兰杰因果关系 (GC) 分析，这是一种广泛用于此目的的统计方法，其基础是向量自回归 (VAR) 框架。该问题在科学上是有效的、适定的，并为稳健的计算实现提供了完整的规范。\n\n格兰杰因果关系的核心是预测性原理。如果时间序列 $x_t$ 的过去值包含了有助于比仅使用 $y_t$ 的过去值更好地预测 $y_t$ 未来值的信息，那么就称 $x_t$ 格兰杰导致 $y_t$。这个概念通过比较两个嵌套线性回归模型的假设检验来操作化。\n\n系统的动态由一个 $p$ 阶的 VAR 过程建模。对于一个具有时间序列数据 $\\mathbf{y}_t \\in \\mathbb{R}^n$ 的 $n$ 通道系统，模型为：\n$$\n\\mathbf{y}_t = \\sum_{k=1}^{p} \\mathbf{A}_k \\mathbf{y}_{t-k} + \\mathbf{e}_t\n$$\n在这里，$\\mathbf{A}_k \\in \\mathbb{R}^{n \\times n}$ 是滞后 $k$ 的系数矩阵，$\\mathbf{e}_t$ 是一个零均值高斯新息噪声向量，$\\mathbf{e}_t \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$。$\\mathbf{A}_k$ 矩阵的非对角元素代表一个通道在那个滞后上对另一个通道的线性影响。一个非零项 $A_k[i, j]$ 意味着通道 $j$ 在滞后 $k$ 时影响通道 $i$。如果对于 $k=1, \\dots, p$ 中至少有一个系数 $A_k[i, j]$ 非零，则存在从通道 $j$到通道 $i$ 的格兰杰因果关系。\n\n对于待测试的每对有向通道（例如 $X \\to Y$），算法按几个不同步骤进行。\n\n首先，我们必须为每个测试用例模拟数据。根据指定的方程生成一个稳定的 VAR 过程。我们生成 $T + T_{\\text{burn-in}}$ 个样本并丢弃前 $T_{\\text{burn-in}}$ 个，以使过程达到其平稳分布，确保所分析数据的统计特性是时不变的。过程的稳定性是有效 GC 分析的先决条件，通过确保 VAR 伴随矩阵的谱半径小于 $1$ 来保证。\n\n其次，对于每个特定的检验（例如，双变量 $X \\to Y$，或给定 $Z$ 的条件 $X \\to Y$），我们必须选择一个合适的模型阶数 $p$。阶数过低可能无法捕捉到真实的动态，而阶数过高则可能过拟合数据。贝叶斯信息准则 (BIC) 提供了一种在模型拟合度与简约性之间进行权衡的原则性方法。对于每个候选滞后阶数 $p \\in \\{1, 2\\}$，我们拟合一个*无约束*线性模型，该模型使用检验中包含的所有通道的过去 $p$ 个值来预测目标通道。BIC 计算如下：\n$$\n\\text{BIC} = n_{\\text{eff}} \\cdot \\ln\\left(\\frac{\\text{RSS}}{n_{\\text{eff}}}\\right) + k \\cdot \\ln(n_{\\text{eff}})\n$$\n其中 $n_{\\text{eff}} = T - p$ 是有效样本数，$\\text{RSS}$ 是来自普通最小二乘法 (OLS) 拟合的残差平方和， $k$ 是模型中的参数数量（对于 $d$ 个包含的通道，$k = d \\cdot p$）。选择产生最小 BIC 的滞后阶数 $p$ 用于假设检验。此选择对一个案例中的四个检验（双变量 $X \\to Y$、双变量 $Y \\to X$、条件 $X \\to Y$、条件 $Y \\to X$）独立进行，因为包含的变量集以及因此的 BIC 可能会有所不同。\n\n第三，使用选定的阶数 $p$，我们进行假设检验。为了检验 $X \\to Y$，我们比较两个模型：\n1.  **无约束模型** ($M_u$)，它使用所有包含通道的 $p$ 个滞后值（例如，双变量情况下的 $X$ 和 $Y$；条件情况下的 $X, Y, Z$）来预测 $Y_t$。该模型有 $k_u = d \\cdot p$ 个参数，并产生残差平方和 $\\text{RSS}_u$。\n2.  **有约束模型** ($M_r$)，它使用除源通道 $X$ 之外的所有包含通道的 $p$ 个滞后值来预测 $Y_t$。该模型有 $k_r = (d-1) \\cdot p$ 个参数，并产生 $\\text{RSS}_r$。\n\n零假设 ($H_0$) 是 $X$ 不格兰杰导致 $Y$，这对应于 $X$ 的滞后项的 $p$ 个系数联合为零。如果 $H_0$ 为真，那么移除这些预测变量时，RSS 不应有统计上显著的增加，即 $\\text{RSS}_r$ 不应显著大于 $\\text{RSS}_u$。我们用 $F$-统计量来量化这一点：\n$$\nF = \\frac{\\left(\\text{RSS}_r - \\text{RSS}_u\\right) / m}{\\text{RSS}_u / (n_{\\text{eff}} - k_u)}\n$$\n其中 $m = p$ 是约束的数量（被省略的参数数量）。在 $H_0$ 下，该统计量服从自由度为 $(m, n_{\\text{eff}} - k_u)$ 的 $F$-分布。我们根据此分布计算 $p$-值。如果 $p$-值小于显著性水平 $\\alpha$（且 $\\text{RSS}_r  \\text{RSS}_u$），我们拒绝 $H_0$，并断定存在显著的格兰杰因果关系。\n\n因果推断的一个关键方面是处理混淆变量。在我们的系统背景下，一个同时驱动 $X$ 和 $Y$ 的共同输入 $Z$ 会引起伪相关，而双变量 GC 检验（仅考虑 $X$ 和 $Y$）可能会错误地将其解释为直接的因果联系。**条件格兰杰因果关系**通过在无约束和有约束模型中都包含潜在的混淆变量 $Z$ 来解决这个问题。这样，我们检验的是在考虑了来自 $Y$ 自身过去和 $Z$ 过去的信息之后，$X$ 的过去所具有的预测能力。如果通道 $Z$ 确实是唯一的共同驱动因素，并且被成功记录并包含在模型中，那么条件 GC 可以正确区分直接因果关系 ($X \\to Y$) 和由共同驱动因素引起的伪相关。这凸显了因果可识别性的一个关键条件：所有显著的共同驱动因素（即创建“后门路径”的混淆变量）都必须被观察到并作为条件。\n\n所提供的实现遵循了这些原则。一个 `simulate_var` 函数生成时间序列。一个辅助函数 `prepare_regression_mats` 为 OLS 模型构建必要的数据矩阵。核心函数 `granger_causality_test` 负责基于 BIC 的模型选择和随后的 F-检验，以提供一个布尔型的显著性结果。主 `solve` 函数遍历指定的测试用例，应用 GC 检验，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f as f_dist\n\ndef solve():\n    \"\"\"\n    Main function to run the Granger causality analysis on all test cases.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.2, 0.0, 0.3], [0.5, 0.2, 0.4], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.2, 0.0, 0.5], [0.0, 0.2, 0.5], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 1.0,\n            \"A_mats\": [\n                np.array([[0.2, 0.0, 0.0], [0.15, 0.2, 0.0], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.2, 0.25, 0.0], [0.35, 0.2, 0.0], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 64, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.1, 0.0, 0.3], [0.3, 0.1, 0.2], [0.0, 0.0, 0.2]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        }\n    ]\n\n    alpha = 0.01\n    candidate_lags = [1, 2]\n    np.random.seed(0)\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        data = simulate_var(\n            T=case_params[\"T\"],\n            n=case_params[\"n\"],\n            A_mats=case_params[\"A_mats\"],\n            sigma=case_params[\"sigma\"]\n        )\n        \n        # Channel indices\n        X, Y, Z = 0, 1, 2\n        \n        case_results = []\n        \n        # Bivariate X -> Y\n        res_bv_xy = granger_causality_test(data, X, Y, [], candidate_lags, alpha)\n        case_results.append(res_bv_xy)\n        \n        # Bivariate Y -> X\n        res_bv_yx = granger_causality_test(data, Y, X, [], candidate_lags, alpha)\n        case_results.append(res_bv_yx)\n        \n        # Conditional X -> Y | Z\n        res_cond_xy = granger_causality_test(data, X, Y, [Z], candidate_lags, alpha)\n        case_results.append(res_cond_xy)\n        \n        # Conditional Y -> X | Z\n        res_cond_yx = granger_causality_test(data, Y, X, [Z], candidate_lags, alpha)\n        case_results.append(res_cond_yx)\n        \n        all_results.append(case_results)\n\n    # Format the final output string\n    str_results = [f\"[{','.join(str(b).lower() for b in res)}]\" for res in all_results]\n    final_output = f\"[{','.join(str_results)}]\"\n    print(final_output)\n\ndef simulate_var(T, n, A_mats, sigma):\n    \"\"\"\n    Simulates a stable Vector Autoregressive (VAR) process.\n    \"\"\"\n    burn_in = 100\n    p_gen = len(A_mats)\n    total_T = T + burn_in\n    \n    Y = np.zeros((total_T, n))\n    noise = np.random.randn(total_T, n) * sigma\n    \n    for t in range(p_gen, total_T):\n        y_t = np.zeros(n)\n        for k in range(p_gen):\n            y_t += A_mats[k] @ Y[t - k - 1, :]\n        Y[t, :] = y_t + noise[t, :]\n        \n    return Y[burn_in:, :]\n\ndef prepare_regression_mats(data, p, regressor_indices, target_idx):\n    \"\"\"\n    Constructs the response vector (y_vec) and predictor matrix (X_mat) for OLS.\n    \"\"\"\n    T, _ = data.shape\n    n_eff = T - p\n    \n    y_vec = data[p:, target_idx]\n    \n    num_regressors = len(regressor_indices)\n    X_mat = np.zeros((n_eff, num_regressors * p))\n    \n    col_idx = 0\n    for idx in regressor_indices:\n        for lag in range(1, p + 1):\n            X_mat[:, col_idx] = data[p - lag : T - lag, idx]\n            col_idx += 1\n            \n    return y_vec, X_mat\n\ndef granger_causality_test(data, source_idx, target_idx, conditioning_indices, candidate_lags, alpha):\n    \"\"\"\n    Performs a Granger causality test from a source to a target channel.\n    \"\"\"\n    T = data.shape[0]\n    all_indices = sorted(list(set([source_idx, target_idx] + conditioning_indices)))\n    \n    # 1. Model order selection using BIC on the unrestricted model\n    best_p = -1\n    min_bic = np.inf\n\n    for p in candidate_lags:\n        if T = p: continue\n        \n        y_vec, X_u = prepare_regression_mats(data, p, all_indices, target_idx)\n        n_eff = len(y_vec)\n        k_u = X_u.shape[1]\n\n        if k_u >= n_eff: continue\n\n        # lstsq returns sum of squared residuals in the second element of the tuple\n        residuals = np.linalg.lstsq(X_u, y_vec, rcond=None)[1]\n        \n        if not residuals: # Perfect fit, RSS is 0\n            rss_u = 1e-10 # Use a small number to avoid log(0)\n        else:\n            rss_u = residuals[0]\n\n        bic = n_eff * np.log(rss_u / n_eff) + k_u * np.log(n_eff)\n        \n        if bic  min_bic:\n            min_bic = bic\n            best_p = p\n\n    if best_p == -1:\n        return False # Not enough data to select a model\n\n    # 2. Perform F-test with the selected lag order 'best_p'\n    p = best_p\n    \n    # Unrestricted model\n    y_vec, X_u = prepare_regression_mats(data, p, all_indices, target_idx)\n    \n    # Restricted model (omitting the source channel's lags)\n    restricted_indices = [idx for idx in all_indices if idx != source_idx]\n    _, X_r = prepare_regression_mats(data, p, restricted_indices, target_idx)\n    \n    n_eff = len(y_vec)\n    k_u = X_u.shape[1]\n\n    # Check if the unrestricted model is solvable\n    if k_u >= n_eff:\n        return False\n\n    rss_u_val = np.linalg.lstsq(X_u, y_vec, rcond=None)[1]\n    rss_r_val = np.linalg.lstsq(X_r, y_vec, rcond=None)[1]\n    \n    rss_u = rss_u_val[0] if rss_u_val else 0.0\n    rss_r = rss_r_val[0] if rss_r_val else 0.0\n\n    if rss_r = rss_u or rss_u  1e-9:\n        # If restriction doesn't worsen the fit or the fit is already perfect, H0 is not rejected.\n        return False\n        \n    m = p  # number of restrictions\n    df1 = m\n    df2 = n_eff - k_u\n\n    if df2 = 0:\n        return False # Cannot compute the F-statistic\n\n    F_stat = ((rss_r - rss_u) / df1) / (rss_u / df2)\n    p_value = f_dist.sf(F_stat, df1, df2)\n\n    return p_value  alpha\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}