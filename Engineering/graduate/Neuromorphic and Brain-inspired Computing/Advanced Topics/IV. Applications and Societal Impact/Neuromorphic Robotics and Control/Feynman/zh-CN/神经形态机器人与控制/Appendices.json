{
    "hands_on_practices": [
        {
            "introduction": "神经形态计算的一个核心驱动力是其卓越的能源效率。为了从根本上理解这一点，我们需要将“脉冲”这一抽象概念与底层硬件的物理现实联系起来。本练习将引导你从第一性原理出发，推导为神经元膜电容充电所需消耗的能量，从而量化单个脉冲的能量成本 。",
            "id": "4052832",
            "problem": "一台腿式机器人使用一个片上神经形态控制器，该控制器由漏积分-发放（Leaky Integrate-and-Fire, LIF）类型的脉冲神经元实现。每个神经元的细胞膜被建模为一个理想线性电容器，其电容为 $C_{\\mathrm{m}}$，连接在膜节点和参考地之间。一个不应期复位电路在脉冲之间将膜完全放电至地，因此在每次新的上升行程开始前，膜电压为 $v(0)=0$。导致达到阈值的上升行程是由一个理想的高顺从性跨导级产生的，该跨导级从能量储存库向膜节点提供电流，因此在上升行程期间没有电阻或漏电损耗，所有输送的电能都储存在膜电容器的电场中。阈值穿越发生在膜电压为 $v(T)=V_{\\mathrm{p}}$ 时，其中 $V_{\\mathrm{p}}$ 是上升行程结束时脉冲的峰值（相对于地）。\n\n仅使用电容器的本构定律 $q=C v$、电流的定义 $i=\\mathrm{d}q/\\mathrm{d}t$ 和瞬时功率的定义 $p=v\\,i$，从第一性原理推导一个封闭形式的解析表达式，用于计算在从 $v(0)=0$ 到 $v(T)=V_{\\mathrm{p}}$ 的上升行程期间从源汲取的能量。然后，对于一个硬件神经元，其参数为 $C_{\\mathrm{m}}=8\\times 10^{-12}$ 和 $V_{\\mathrm{p}}=0.12$，计算这个能量。将最终能量以焦耳为单位表示，并将您的答案四舍五入到四位有效数字。",
            "solution": "该问题被认为是有效的，因为它科学地基于电路理论的基本原理，问题提出得当，提供了足够的信息以获得唯一解，并且使用客观、明确的语言进行陈述。给定的数值对于神经形态硬件实现是物理上现实的。\n\n目标是推导一个表达式，用于计算在神经元膜电容 $C_{\\mathrm{m}}$ 从初始电压 $v(0)=0$ 充电到最终峰值电压 $v(T)=V_{\\mathrm{p}}$ 期间，从源汲取的总能量 $E$。我们被指示仅使用电荷、电流和功率的基本关系。问题陈述，在上升行程期间，没有电阻或漏电损耗，并且所有输送的电能都储存在膜电容器的电场中。这意味着从源汲取的能量等于储存在电容器中的能量。\n\n总能量 $E$ 是瞬时功率 $p(t)$ 在事件持续时间（从 $t=0$ 到 $t=T$）上的时间积分。\n$$\nE = \\int_{0}^{T} p(t) \\, \\mathrm{d}t\n$$\n问题提供了瞬时功率的定义为 $p(t) = v(t) i(t)$，其中 $v(t)$ 是瞬时膜电压，$i(t)$ 是流入膜的瞬时电流。将此代入能量积分中得到：\n$$\nE = \\int_{0}^{T} v(t) i(t) \\, \\mathrm{d}t\n$$\n接下来，我们必须用电压 $v(t)$ 和电容 $C_{\\mathrm{m}}$ 来表示电流 $i(t)$。我们已知电流的定义 $i(t) = \\frac{\\mathrm{d}q}{\\mathrm{d}t}$ 和电容器的本构定律 $q(t) = C_{\\mathrm{m}} v(t)$，其中 $C_{\\mathrm{m}}$ 是一个常数。通过对本构定律关于时间求导，我们得到电流：\n$$\ni(t) = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( C_{\\mathrm{m}} v(t) \\right) = C_{\\mathrm{m}} \\frac{\\mathrm{d}v}{\\mathrm{d}t}\n$$\n现在，将这个 $i(t)$ 的表达式代回到能量的积分中：\n$$\nE = \\int_{0}^{T} v(t) \\left( C_{\\mathrm{m}} \\frac{\\mathrm{d}v}{\\mathrm{d}t} \\right) \\, \\mathrm{d}t\n$$\n由于 $C_{\\mathrm{m}}$ 是一个常数，它可以被移到积分符号外面。我们也可以重新排列被积函数中的项：\n$$\nE = C_{\\mathrm{m}} \\int_{0}^{T} v(t) \\frac{\\mathrm{d}v}{\\mathrm{d}t} \\, \\mathrm{d}t\n$$\n为了求解这个积分，我们进行变量替换，从时间 $t$ 变为电压 $v$。微分元 $\\mathrm{d}v$ 与 $\\mathrm{d}t$ 的关系为 $\\mathrm{d}v = \\frac{\\mathrm{d}v}{\\mathrm{d}t} \\mathrm{d}t$。我们还必须改变积分的上下限。在下限 $t=0$ 时，电压为 $v(0)=0$。在上限 $t=T$ 时，电压为 $v(T)=V_{\\mathrm{p}}$。积分变换如下：\n$$\nE = C_{\\mathrm{m}} \\int_{v(0)}^{v(T)} v \\, \\mathrm{d}v = C_{\\mathrm{m}} \\int_{0}^{V_{\\mathrm{p}}} v \\, \\mathrm{d}v\n$$\n这是一个标准积分。$v$ 相对于 $v$ 的不定积分是 $\\frac{1}{2}v^2$。在新的上下限下计算这个不定积分：\n$$\nE = C_{\\mathrm{m}} \\left[ \\frac{1}{2} v^2 \\right]_{0}^{V_{\\mathrm{p}}}\n$$\n$$\nE = C_{\\mathrm{m}} \\left( \\frac{1}{2} V_{\\mathrm{p}}^2 - \\frac{1}{2} (0)^2 \\right)\n$$\n这简化为能量的最终封闭形式解析表达式：\n$$\nE = \\frac{1}{2} C_{\\mathrm{m}} V_{\\mathrm{p}}^2\n$$\n这是储存在充电至电压 $V_{\\mathrm{p}}$ 的理想线性电容器中的能量的著名表达式。\n\n问题接着要求为电容 $C_{\\mathrm{m}} = 8 \\times 10^{-12}$ 法拉、峰值电压 $V_{\\mathrm{p}} = 0.12$ 伏特的硬件神经元计算这个能量。将这些值代入我们推导的表达式中：\n$$\nE = \\frac{1}{2} (8 \\times 10^{-12} \\, \\text{F}) (0.12 \\, \\text{V})^2\n$$\n$$\nE = (4 \\times 10^{-12}) (0.0144) \\, \\text{J}\n$$\n$$\nE = 5.76 \\times 10^{-14} \\, \\text{J}\n$$\n问题要求答案以焦耳表示，并四舍五入到四位有效数字。计算出的值 $5.76 \\times 10^{-14}$ 有三位有效数字。为了用四位有效数字表示，我们追加一个零。\n$$\nE = 5.760 \\times 10^{-14} \\, \\text{J}\n$$",
            "answer": "$$\n\\boxed{5.760 \\times 10^{-14}}\n$$"
        },
        {
            "introduction": "在将生物神经元的连续时间动态转化为可在机器人控制器上运行的离散时间算法时，我们必须面对计算精度和效率之间的权衡。本练习要求你实现并比较一个LIF神经元的两种仿真方法：一种是适用于固定步长控制器的数值积分，另一种是精确的事件驱动解析解。通过分析这两种方法之间的误差，你将深入理解在神经形态系统中仿真步长选择的重要性 。",
            "id": "4052836",
            "problem": "请考虑一个嵌入在神经形态机器人控制器中的漏放电积分 (LIF) 神经元，该控制器以固定的时间步长执行。该神经元遵循标准的膜方程，该方程由电荷守恒和欧姆定律在恒定输入电流下导出。其连续时间动力学由以下常微分方程控制：$$C \\frac{dv(t)}{dt} = -g_L \\left(v(t) - E_L\\right) + I_0,$$ 其中，$C$ 是以法拉 (F) 为单位的膜电容，$g_L$ 是以西门子 (S) 为单位的漏电导，$E_L$ 是以伏特 (V) 为单位的漏泄反转（静息）电位，$I_0$ 是以安培 (A) 为单位的恒定输入电流，而 $v(t)$ 是以伏特 (V) 为单位的膜电位。当 $v(t)$ 达到一个阈值 $V_{\\text{th}}$ (V) 时，神经元发放一个脉冲，此时 $v(t)$ 会被瞬时重置为 $V_{\\text{reset}}$ (V)。假设没有不应期。该控制器以一个固定的步长 $\\Delta t$ (s) 运行，采用零阶保持输入和显式状态更新。\n\n任务：\n- 从第一性原理出发，通过对膜常微分方程进行标准的显式积分，推导出一个适用于固定步长控制器的离散时间更新规则。在一个程序中实现这个离散时间更新，处理步长边界上的阈值检测和瞬时重置。对于步长内的阈值检测，使用步长端点之间的线性插值来估计该步长内的穿越时间。\n- 独立地推导在恒定输入电流下，能够以闭式解形式求解脉冲事件之间连续时间动力学的精确事件驱动解，并实现它以在相同的离散采样时间点生成基准膜电位。使用恒定输入下的闭式脉冲间隔来安排精确的重置。\n- 分析固定步长离散时间更新与事件驱动解之间作为步长 $\\Delta t$ 函数的误差。使用两个指标量化此误差：\n  1. 在仿真时长内的膜电位均方根 (RMS) 误差，以伏特 (V) 表示。\n  2. 首次脉冲时间的绝对误差（精确解与固定步长线性插值估计值之间的差异），以秒 (s) 表示。\n- 如果在仿真时长内两种方法都没有产生脉冲，则将首次脉冲时间误差定义为 $0.0$ 秒。如果精确的事件驱动方法在时长内产生了脉冲，而离散时间方法没有，则将首次脉冲时间误差定义为等于仿真时长（以秒为单位）。\n\n使用以下经过充分检验的事实和核心定义作为您推导的基础：电容器上的电荷守恒、漏泄通道的欧姆定律，以及时间常数 $\\tau = C / g_L$ 的定义。不要在问题陈述中直接写下任何目标离散时间更新或闭式解；相反，应在您的解答中从所述基础进行推导。\n\n初始条件：\n- 初始膜电位为 $v(0) = V_{\\text{reset}}$。\n\n仿真时长：\n- 在总时间 $T$ (s) 内进行仿真，在控制器步长时间 $t_k = k \\Delta t$（对于整数 $k \\ge 1$ 直至 $T$）对膜电位进行采样。\n\n单位：\n- 电压必须以伏特 (V) 为单位。\n- 电流必须以安培 (A) 为单位。\n- 电导必须以西门子 (S) 为单位。\n- 电容必须以法拉 (F) 为单位。\n- 时间必须以秒 (s) 为单位。\n- 本问题不涉及角度。\n\n测试套件：\n实现您的程序以运行以下参数集；每个参数均以指定单位提供。\n\n- 情况 1（理想情况，小步长）：\n  - $C = 200 \\times 10^{-12}\\ \\mathrm{F}$, $g_L = 10 \\times 10^{-9}\\ \\mathrm{S}$, $E_L = -0.065\\ \\mathrm{V}$, $V_{\\text{th}} = -0.050\\ \\mathrm{V}$, $V_{\\text{reset}} = -0.070\\ \\mathrm{V}$, $I_0 = 0.5 \\times 10^{-9}\\ \\mathrm{A}$, $\\Delta t = 0.0001\\ \\mathrm{s}$, $T = 0.5\\ \\mathrm{s}$。\n- 情况 2（中等步长）：\n  - $C = 200 \\times 10^{-12}\\ \\mathrm{F}$, $g_L = 10 \\times 10^{-9}\\ \\mathrm{S}$, $E_L = -0.065\\ \\mathrm{V}$, $V_{\\text{th}} = -0.050\\ \\mathrm{V}$, $V_{\\text{reset}} = -0.070\\ \\mathrm{V}$, $I_0 = 0.5 \\times 10^{-9}\\ \\mathrm{A}$, $\\Delta t = 0.001\\ \\mathrm{s}$, $T = 0.5\\ \\mathrm{s}$。\n- 情况 3（大步长）：\n  - $C = 200 \\times 10^{-12}\\ \\mathrm{F}$, $g_L = 10 \\times 10^{-9}\\ \\mathrm{S}$, $E_L = -0.065\\ \\mathrm{V}$, $V_{\\text{th}} = -0.050\\ \\mathrm{V}$, $V_{\\text{reset}} = -0.070\\ \\mathrm{V}$, $I_0 = 0.5 \\times 10^{-9}\\ \\mathrm{A}$, $\\Delta t = 0.005\\ \\mathrm{s}$, $T = 0.5\\ \\mathrm{s}$。\n- 情况 4（非常大的步长，接近时间常数）：\n  - $C = 200 \\times 10^{-12}\\ \\mathrm{F}$, $g_L = 10 \\times 10^{-9}\\ \\mathrm{S}$, $E_L = -0.065\\ \\mathrm{V}$, $V_{\\text{th}} = -0.050\\ \\mathrm{V}$, $V_{\\text{reset}} = -0.070\\ \\mathrm{V}$, $I_0 = 0.5 \\times 10^{-9}\\ \\mathrm{A}$, $\\Delta t = 0.02\\ \\mathrm{s}$, $T = 0.5\\ \\mathrm{s}$。\n- 情况 5（无脉冲区域）：\n  - $C = 200 \\times 10^{-12}\\ \\mathrm{F}$, $g_L = 10 \\times 10^{-9}\\ \\mathrm{S}$, $E_L = -0.065\\ \\mathrm{V}$, $V_{\\text{th}} = -0.050\\ \\mathrm{V}$, $V_{\\text{reset}} = -0.070\\ \\mathrm{V}$, $I_0 = 0.1 \\times 10^{-9}\\ \\mathrm{A}$, $\\Delta t = 0.001\\ \\mathrm{s}$, $T = 0.5\\ \\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含测试套件的结果，形式为一个由方括号括起来的逗号分隔列表，每个测试用例贡献一个包含两个浮点数的列表：膜电位均方根误差（单位 V）和首次脉冲时间绝对误差（单位 s）。每个浮点数必须四舍五入到六位小数。例如，输出格式必须为：$$\\left[ [x_1, y_1], [x_2, y_2], [x_3, y_3], [x_4, y_4], [x_5, y_5] \\right],$$ 其中 $x_i$ 的单位是伏特 (V)，$y_i$ 的单位是秒 (s)。",
            "solution": "该问题要求对一个受到恒定输入电流的漏放电积分 (LIF) 神经元模型进行两种仿真方法的比较分析。第一种方法是适用于固定步长控制器的离散时间数值积分，第二种是基于神经元动力学解析闭式解的精确事件驱动解。分析的重点是量化数值方法随仿真步长 $\\Delta t$ 变化的误差。\n\nLIF 神经元膜电位 $v(t)$ 的连续时间动力学由以下常微分方程 (ODE) 给出：\n$$C \\frac{dv(t)}{dt} = -g_L \\left(v(t) - E_L\\right) + I_0$$\n该方程表示电荷守恒，其中电容电流 $C \\frac{dv}{dt}$ 与漏电流 $-g_L(v-E_L)$（欧姆定律）和恒定外部输入电流 $I_0$ 的总和相平衡。\n\n**1. 离散时间更新的推导（前向欧拉法）**\n\n为了实现一个用于固定步长控制器的离散时间更新，我们首先重新排列控制 ODE 以分离出导数项 $\\frac{dv}{dt}$：\n$$\\frac{dv}{dt} = \\frac{1}{C}\\left(-g_L(v - E_L) + I_0\\right)$$\n引入膜时间常数 $\\tau = C/g_L$，我们可以将方程重写为：\n$$\\frac{dv}{dt} = -\\frac{1}{\\tau}(v - E_L) + \\frac{I_0}{C}$$\n这是一个形如 $\\frac{dv}{dt} = f(v)$ 的表达式。对于一个固定的时间步长 $\\Delta t$，我们可以使用显式前向欧拉法从当前状态 $v(t_k)$ 近似计算下一步的状态 $v(t_{k+1})$：\n$$v(t_{k+1}) \\approx v(t_k) + \\Delta t \\cdot \\frac{dv}{dt}\\bigg|_{t=t_k}$$\n代入 $\\frac{dv}{dt}$ 的表达式并使用符号 $v_k = v(t_k)$，我们得到离散时间更新规则：\n$$v_{k+1} = v_k + \\Delta t \\left( -\\frac{1}{\\tau}(v_k - E_L) + \\frac{I_0}{C} \\right)$$\n$$v_{k+1} = v_k - \\frac{\\Delta t}{\\tau}v_k + \\frac{\\Delta t}{\\tau}E_L + \\frac{\\Delta t}{C}I_0$$\n$$v_{k+1} = v_k \\left(1 - \\frac{\\Delta t}{\\tau}\\right) + \\frac{\\Delta t}{\\tau}E_L + \\frac{R_L I_0 \\Delta t}{\\tau}$$\n其中 $R_L = 1/g_L$。这也可以写成：\n$$v_{k+1} = v_k\\left(1 - \\frac{\\Delta t}{\\tau}\\right) + \\frac{\\Delta t}{\\tau} \\left(E_L + R_L I_0 \\right)$$\n脉冲机制实现如下：对于从 $t_k$ 到 $t_{k+1}$ 的每一步，我们计算一个预期的电位 $v'_{k+1}$。如果 $v_k  V_{\\text{th}}$ 且 $v'_{k+1} \\ge V_{\\text{th}}$，则认为在该区间内发生了一次脉冲。这次脉冲的时间 $t_{spike}$ 使用 $(t_k, v_k)$ 和 $(t_{k+1}, v'_{k+1})$ 之间的线性插值来估计：\n$$t_{spike} = t_k + \\Delta t \\frac{V_{\\text{th}} - v_k}{v'_{k+1} - v_k}$$\n一旦检测到在 $[t_k, t_{k+1})$ 内有脉冲，下一个时间步的状态变量 $v_{k+1}$ 就被设置为重置电位 $V_{\\text{reset}}$。如果没有检测到脉冲，$v_{k+1}$ 则被赋予计算出的值 $v'_{k+1}$。\n\n**2. 精确解析解的推导**\n\n控制 ODE 是一个具有常系数的一阶线性非齐次微分方程。我们可以找到它的精确解。首先，我们通过将时间导数设为零来找到稳态电位 $v_\\infty$：\n$$0 = -g_L(v_\\infty - E_L) + I_0 \\implies v_\\infty = E_L + \\frac{I_0}{g_L}$$\n对于初始值 $v(t_0)$，该 ODE 的通解为：\n$$v(t) = v_\\infty + (v(t_0) - v_\\infty)e^{-(t-t_0)/\\tau}$$\n这个方程描述了膜电位在脉冲事件之间的演化。当 $v(t)$ 达到 $V_{\\text{th}}$ 时，发生一次脉冲。让我们计算脉冲间隔 $\\Delta T_{spike}$，即从 $V_{\\text{reset}}$ 上升到 $V_{\\text{th}}$ 所需的时间。设 $t_0$ 为一次重置的时刻，因此 $v(t_0) = V_{\\text{reset}}$。我们求解时间 $t_{spike}$ 使得 $v(t_{spike}) = V_{\\text{th}}$：\n$$V_{\\text{th}} = v_\\infty + (V_{\\text{reset}} - v_\\infty)e^{-(t_{spike}-t_0)/\\tau}$$\n$$\\frac{V_{\\text{th}} - v_\\infty}{V_{\\text{reset}} - v_\\infty} = e^{-\\Delta T_{spike}/\\tau}$$\n其中 $\\Delta T_{spike} = t_{spike} - t_0$。求解 $\\Delta T_{spike}$：\n$$\\ln\\left(\\frac{V_{\\text{th}} - v_\\infty}{V_{\\text{reset}} - v_\\infty}\\right) = -\\frac{\\Delta T_{spike}}{\\tau}$$\n$$\\Delta T_{spike} = -\\tau \\ln\\left(\\frac{V_{\\text{th}} - v_\\infty}{V_{\\text{reset}} - v_\\infty}\\right) = \\tau \\ln\\left(\\frac{V_{\\text{reset}} - v_\\infty}{V_{\\text{th}} - v_\\infty}\\right)$$\n这个公式仅在可能产生脉冲时有效。给定 $V_{\\text{reset}}  V_{\\text{th}}$，电位必须向上驱动，这要求 $v_\\infty > V_{\\text{th}}$。如果 $v_\\infty \\le V_{\\text{th}}$，神经元将永远不会达到阈值，$\\Delta T_{spike}$ 为无穷大。精确解的仿真涉及使用解析公式传播电位，并在从开始算起的 $\\Delta T_{spike}$ 的倍数时刻安排重置。\n\n**3. 误差分析方法**\n\n为了量化离散时间数值方法的误差，我们对每个参数集在时间范围 $T$ 内并行执行两种仿真。一种仿真使用离散时间更新，另一种使用精确的解析求解器提供基准参考。两者都生成在时间点 $t_k = k\\Delta t$（其中 $k \\in \\{1, 2, \\dots, N\\}$，$N = \\lfloor T/\\Delta t \\rfloor$）采样的膜电位轨迹。\n\n误差用两个指标来量化：\n1.  **均方根 (RMS) 电位误差**：这衡量了两个电位轨迹之间的平均偏差：\n    $$E_{RMS} = \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N} \\left(v_{discrete}(t_k) - v_{exact}(t_k)\\right)^2}$$\n2.  **首次脉冲时间绝对误差**：这衡量了每种方法产生的首次脉冲时间的差异。设 $t_{spike, discrete}$ 为数值仿真的首次脉冲时间，$t_{spike, exact}$ 为解析解的首次脉冲时间。误差根据以下条件定义：\n    - 如果在 $[0, T]$ 内两种方法都没有产生脉冲，则误差为 $0.0$。\n    - 如果精确方法产生了脉冲但离散方法没有，则误差为 $T$。\n    - 在所有其他情况下（例如，两者都产生脉冲），误差为绝对差 $|t_{spike, discrete} - t_{spike, exact}|$.\n\n该实现将为所提供的五个测试用例中的每一个计算这两个误差指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LIF neuron simulation problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path, small step)\n        {\n            \"C\": 200e-12, \"g_L\": 10e-9, \"E_L\": -0.065, \"V_th\": -0.050,\n            \"V_reset\": -0.070, \"I_0\": 0.5e-9, \"dt\": 0.0001, \"T\": 0.5\n        },\n        # Case 2 (moderate step)\n        {\n            \"C\": 200e-12, \"g_L\": 10e-9, \"E_L\": -0.065, \"V_th\": -0.050,\n            \"V_reset\": -0.070, \"I_0\": 0.5e-9, \"dt\": 0.001, \"T\": 0.5\n        },\n        # Case 3 (large step)\n        {\n            \"C\": 200e-12, \"g_L\": 10e-9, \"E_L\": -0.065, \"V_th\": -0.050,\n            \"V_reset\": -0.070, \"I_0\": 0.5e-9, \"dt\": 0.005, \"T\": 0.5\n        },\n        # Case 4 (very large step, near time constant)\n        {\n            \"C\": 200e-12, \"g_L\": 10e-9, \"E_L\": -0.065, \"V_th\": -0.050,\n            \"V_reset\": -0.070, \"I_0\": 0.5e-9, \"dt\": 0.02, \"T\": 0.5\n        },\n        # Case 5 (no-spike regime)\n        {\n            \"C\": 200e-12, \"g_L\": 10e-9, \"E_L\": -0.065, \"V_th\": -0.050,\n            \"V_reset\": -0.070, \"I_0\": 0.1e-9, \"dt\": 0.001, \"T\": 0.5\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        C, g_L, E_L = params[\"C\"], params[\"g_L\"], params[\"E_L\"]\n        V_th, V_reset = params[\"V_th\"], params[\"V_reset\"]\n        I_0, dt, T = params[\"I_0\"], params[\"dt\"], params[\"T\"]\n        \n        tau = C / g_L\n        v_inf = E_L + I_0 / g_L\n        \n        num_steps = int(T / dt)\n        \n        # --- Discrete-time simulation (Forward Euler) ---\n        v_discrete_trace = []\n        v_d = V_reset\n        t_spike_discrete_first = float('inf')\n        \n        for i in range(num_steps):\n            t_k = i * dt\n            v_prev = v_d\n            \n            # Forward Euler update\n            dv_dt = (-g_L * (v_prev - E_L) + I_0) / C\n            v_unclamped = v_prev + dt * dv_dt\n            \n            # Spike detection and reset\n            if v_prev  V_th and v_unclamped >= V_th:\n                if t_spike_discrete_first == float('inf'):\n                    # Linear interpolation for spike time\n                    dt_spike = dt * (V_th - v_prev) / (v_unclamped - v_prev)\n                    t_spike_discrete_first = t_k + dt_spike\n                # Reset for the next step's starting potential\n                v_d = V_reset\n            else:\n                v_d = v_unclamped\n                \n            v_discrete_trace.append(v_d)\n\n        # --- Exact analytical solution ---\n        v_exact_trace = []\n        \n        # Calculate exact inter-spike interval (ISI)\n        isi = float('inf')\n        if v_inf > V_th:\n            # Check for non-physical arguments to log\n            # v_inf - V_reset and v_inf - V_th must be > 0.\n            # Given V_reset  V_th, this is guaranteed if v_inf > V_th.\n            log_arg = (v_inf - V_reset) / (v_inf - V_th)\n            if log_arg > 0:\n                isi = tau * np.log(log_arg)\n        \n        t_spike_exact_first = isi if isi != float('inf') else float('inf')\n\n        for i in range(1, num_steps + 1):\n            t_sample = i * dt\n            t_last_reset = 0.0\n            \n            if isi != float('inf'):\n               # Number of spikes before the current sample time\n               num_spikes_before = np.floor(t_sample / isi)\n               t_last_reset = num_spikes_before * isi\n\n            # Time elapsed since the last reset\n            delta_t_since_reset = t_sample - t_last_reset\n            \n            v_e = v_inf + (V_reset - v_inf) * np.exp(-delta_t_since_reset / tau)\n            v_exact_trace.append(v_e)\n            \n        # --- Error Analysis ---\n        v_discrete_trace_np = np.array(v_discrete_trace)\n        v_exact_trace_np = np.array(v_exact_trace)\n        \n        # 1. RMS potential error\n        rms_error = np.sqrt(np.mean((v_discrete_trace_np - v_exact_trace_np)**2))\n        \n        # 2. First spike time error\n        spiked_discrete = t_spike_discrete_first = T\n        spiked_exact = t_spike_exact_first = T\n        \n        spike_time_error = 0.0\n        if not spiked_discrete and not spiked_exact:\n            spike_time_error = 0.0\n        elif spiked_exact and not spiked_discrete:\n            spike_time_error = T\n        else: # Covers (spiked_discrete and spiked_exact) and (spiked_discrete and not spiked_exact)\n             # The problem doesn't define the latter case, but abs diff is the natural choice.\n             # In our test cases, this case does not occur.\n             t1 = t_spike_discrete_first if spiked_discrete else float('inf')\n             t2 = t_spike_exact_first if spiked_exact else float('inf')\n             spike_time_error = abs(t1 - t2)\n             \n        results.append([round(rms_error, 6), round(spike_time_error, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{r[0]:.6f}, {r[1]:.6f}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "一个完整的神经形态控制系统的性能不仅取决于单个神经元的模型，还取决于编码方案以及系统对噪声的鲁棒性。这个综合性练习将引导你分析脉冲时间抖动（一种常见的噪声来源）如何通过时间编码方案影响解码精度，并最终影响闭环控制系统的稳态性能。通过这个实践，你将把神经元动力学、噪声分析和经典控制理论结合起来，对一个完整的神经形态机器人控制回路进行性能评估 。",
            "id": "4052833",
            "problem": "您的任务是严谨地分析和仿真脉冲时间抖动对时间编码解码误差的影响，并将此误差在一个用于简单线性被控对象的闭环神经形态控制系统中进行传播。编码方案是使用首脉冲时间的标量时间编码，被控对象是标量线性的，控制器是静态状态反馈。您的程序必须为一组测试用例计算稳态闭环性能指标。\n\n假设存在以下基础，您必须以此为基础进行推导：\n\n- 时间编码使用从标量指令 $y$（无量纲）到脉冲时间 $T(y)$ 的单调仿射映射，定义为 $T(y) = T_0 - k y$，其中 $T_0$ 是以秒为单位的恒定偏移量，$k$ 是斜率，单位为秒/单位指令。您可以将 $T_0$ 设置为任意常数，因为它在该映射的解码误差中会被抵消。\n- 观测到的脉冲时间受到加性脉冲时间抖动 $\\varepsilon$ 的干扰，其均值为零，方差为 $\\sigma_t^2$（单位为 $\\text{s}^2$），在神经元和控制周期之间独立。该抖动被建模为一个具有有限二阶矩的独立同分布随机变量。\n- 解码对每个脉冲时间使用编码器的无偏逆运算来估计指令，并可选择对共享相同编码器的 $N$ 个独立神经元进行平均。\n- 被控对象是一个连续时间标量线性时不变（LTI）系统，其动力学为 $\\dot{x}(t) = a x(t) + b u(t)$，其中 $x$ 是状态（无量纲），$u$ 是控制输入（无量纲），$a$ 的单位是 $\\text{s}^{-1}$，$b$ 是无量纲的。控制律是在离散采样时刻 $t_k$ 的 $u_k = -K x_k + r + \\tilde{e}_k$，其中 $K$ 是反馈增益（无量纲），$r$ 是一个恒定参考值（无量纲），$\\tilde{e}_k$ 是时间编码在每个控制周期注入的解码指令误差。\n- 控制回路以采样周期 $h$（单位为秒）和零阶保持器运行，从而产生一个用于分析的离散时间系统。\n\n您的任务是：\n\n1. 从第一性原理推导解码指令误差 $\\tilde{e}_k$ 的方差，作为脉冲时间抖动方差 $\\sigma_t^2$、编码器斜率 $k$ 以及用于平均的神经元数量 $N$ 的函数。\n2. 使用零阶保持器将连续时间被控对象离散化，以获得在采样周期 $h$ 内状态更新的离散时间系数。\n3. 使用静态反馈控制律下的离散时间闭环系统，推导当闭环系统均方稳定时，仅由注入的解码指令误差 $\\tilde{e}_k$ 引起的状态 $x_k$ 的稳态方差。\n4. 实现一个程序，为下面的每个测试用例计算 $x_k$ 的稳态标准差（稳态方差的平方根），并将每个用例的最终标准差四舍五入到六位小数。\n\n重要细节和要求：\n\n- 不涉及角度；无需指定角度单位。\n- 所有时间必须以秒为单位处理，所有方差的单位必须是其对应变量单位的平方（例如，$\\sigma_t^2$ 的单位是 $\\text{s}^2$）。状态 $x$ 和指令 $y$ 是无量纲的。\n- 您必须将最终输出表示为无量纲的标准差。\n- 您不得假设任何未从上述基础推导出的捷径公式；您的推导必须源于所述的编码器、噪声模型、被控对象和控制器。\n- 如果闭环系统不是均方稳定的（即，如果闭环标量系数的绝对值不严格小于一），则稳态方差不存在。对于这种情况，您的程序必须为该测试用例输出一个非数值（Not-a-Number）。但是，所提供的测试套件避免了不稳定性。\n\n测试套件：\n\n对于每个测试用例，参数为 $(a, b, h, K, k, \\sigma_t^2, N)$，使用指定的单位。\n\n- 用例1（一般稳定情况）：$a = -2.0$ $\\text{s}^{-1}$，$b = 1.0$，$h = 0.02$ $\\text{s}$，$K = 1.0$，$k = 0.01$ $\\text{s}$/单位指令，$\\sigma_t^2 = 1.0 \\times 10^{-6}$ $\\text{s}^2$，$N = 1$。\n- 用例2（中性连续时间被控对象）：$a = 0.0$ $\\text{s}^{-1}$，$b = 1.0$，$h = 0.01$ $\\text{s}$，$K = 50.0$，$k = 0.01$ $\\text{s}$/单位指令，$\\sigma_t^2 = 1.0 \\times 10^{-6}$ $\\text{s}^2$，$N = 1$。\n- 用例3（接近稳定边界）：$a = 0.5$ $\\text{s}^{-1}$，$b = 1.0$，$h = 0.1$ $\\text{s}$，$K = 0.51$，$k = 0.02$ $\\text{s}$/单位指令，$\\sigma_t^2 = 1.0 \\times 10^{-6}$ $\\text{s}^2$，$N = 1$。\n- 用例4（多神经元平均）：$a = -2.0$ $\\text{s}^{-1}$，$b = 1.0$，$h = 0.02$ $\\text{s}$，$K = 1.0$，$k = 0.01$ $\\text{s}$/单位指令，$\\sigma_t^2 = 1.0 \\times 10^{-6}$ $\\text{s}^2$，$N = 4$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含四个用例的稳态标准差，四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表，例如，“[s1,s2,s3,s4]”。每个条目必须是浮点数。",
            "solution": "我们从时间编码和解码开始。编码器通过 $T(y) = T_0 - k y$ 将一个无量纲指令 $y$ 映射到一个脉冲时间，其中 $T_0 \\in \\mathbb{R}$ 的单位是秒，$k > 0$ 的单位是秒/单位指令。观测到的脉冲时间受到抖动的干扰，该抖动被建模为一个加性随机变量 $\\varepsilon$，其均值为零，方差为 $\\sigma_t^2$，单位为 $\\text{s}^2$。因此，观测到的脉冲时间为 $t_{\\text{obs}} = T(y) + \\varepsilon = T_0 - k y + \\varepsilon$。\n\n解码器对编码器的仿射映射进行逆运算。对于单个脉冲，解码后的指令估计值为\n$$\n\\hat{y} = \\frac{T_0 - t_{\\text{obs}}}{k} = \\frac{T_0 - (T_0 - k y + \\varepsilon)}{k} = \\frac{k y - \\varepsilon}{k} = y - \\frac{\\varepsilon}{k}.\n$$\n因此，单个脉冲的解码误差为\n$$\n\\tilde{e} = \\hat{y} - y = -\\frac{\\varepsilon}{k}.\n$$\n由于 $\\varepsilon$ 的均值为零，方差为 $\\sigma_t^2$，可得 $\\tilde{e}$ 的均值为零，方差为\n$$\n\\sigma_y^2 = \\operatorname{Var}[\\tilde{e}] = \\frac{\\sigma_t^2}{k^2}.\n$$\n\n如果有 $N$ 个独立的神经元，每个控制周期发放一个脉冲，且具有相同分布的独立抖动 $\\varepsilon_i$，并且解码器对它们的估计值进行平均，则平均解码指令估计值为\n$$\n\\hat{y}_{\\text{avg}} = \\frac{1}{N} \\sum_{i=1}^N \\left( y - \\frac{\\varepsilon_i}{k} \\right) = y - \\frac{1}{k} \\cdot \\frac{1}{N} \\sum_{i=1}^N \\varepsilon_i.\n$$\n平均解码误差为\n$$\n\\tilde{e}_{\\text{avg}} = \\hat{y}_{\\text{avg}} - y = - \\frac{1}{k} \\cdot \\frac{1}{N} \\sum_{i=1}^N \\varepsilon_i.\n$$\n根据独立性，和的方差等于方差的和，因此\n$$\n\\operatorname{Var}\\left[ \\frac{1}{N} \\sum_{i=1}^N \\varepsilon_i \\right] = \\frac{1}{N^2} \\cdot N \\cdot \\sigma_t^2 = \\frac{\\sigma_t^2}{N}.\n$$\n因此，平均解码误差的方差为\n$$\n\\sigma_{y,\\text{avg}}^2 = \\operatorname{Var}[\\tilde{e}_{\\text{avg}}] = \\frac{1}{k^2} \\cdot \\frac{\\sigma_t^2}{N} = \\frac{\\sigma_t^2}{k^2 N}.\n$$\n\n我们现在将此解码误差在闭环系统中进行传播。连续时间被控对象为\n$$\n\\dot{x}(t) = a x(t) + b u(t),\n$$\n其中 $a \\in \\mathbb{R}$ 的单位是 $\\text{s}^{-1}$，$b \\in \\mathbb{R}$ 是无量纲的。在采样周期为 $h > 0$ 秒的零阶保持器控制下，一个采样区间内的离散时间等效系统将 $x_k = x(t_k)$ 映射到 $x_{k+1} = x(t_{k+1})$，其关系为\n$$\nx_{k+1} = A_d x_k + B_d u_k,\n$$\n其中 $A_d = e^{a h}$ 并且\n$$\nB_d =\n\\begin{cases}\nb \\dfrac{e^{a h} - 1}{a},  \\text{若 } a \\neq 0, \\\\\nb h,  \\text{若 } a = 0.\n\\end{cases}\n$$\n这些表达式是通过在一个区间内用常数输入求解线性微分方程，并将脉冲响应 $\\exp(a \\tau)$ 从 $0$ 积分到 $h$ 得到的。\n\n在采样点 $k$ 的静态状态反馈控制律为\n$$\nu_k = - K x_k + r + \\tilde{e}_k,\n$$\n其中 $K$ 是反馈增益（无量纲），$r$ 是恒定参考值（无量纲），$\\tilde{e}_k$ 是加性注入的解码指令误差（无量纲）。代入后，闭环状态更新变为\n$$\nx_{k+1} = (A_d - B_d K) x_k + B_d r + B_d \\tilde{e}_k.\n$$\n令 $A_{\\text{cl}} = A_d - B_d K$ 表示标量闭环系数。项 $B_d r$ 对状态均值有贡献，但对由 $\\tilde{e}_k$ 引起的方差没有贡献。假设序列 $\\{ \\tilde{e}_k \\}$ 在 $k$ 之间独立，均值为零，方差为 $\\sigma_y^2$（或在对 $N$ 个神经元求平均时为 $\\sigma_{y,\\text{avg}}^2$），并且与 $x_k$ 独立，则对于带有输入噪声的1阶自回归模型（AR(1)），标量方差传播为\n$$\n\\operatorname{Var}[x_{k+1}] = A_{\\text{cl}}^2 \\operatorname{Var}[x_k] + B_d^2 \\sigma_y^2.\n$$\n在均方稳定系统的稳态下，方差满足离散李雅普诺夫方程\n$$\n\\Sigma = A_{\\text{cl}}^2 \\Sigma + B_d^2 \\sigma_y^2,\n$$\n其解为\n$$\n\\Sigma = \\frac{B_d^2 \\sigma_y^2}{1 - A_{\\text{cl}}^2},\n$$\n条件是 $\\lvert A_{\\text{cl}} \\rvert  1$。稳态标准差是 $\\sqrt{\\Sigma}$。\n\n将早前推导的解码误差方差与此传播过程结合：\n\n- 对于 $N = 1$，$\\sigma_y^2 = \\dfrac{\\sigma_t^2}{k^2}$。\n- 对于一般的 $N$，$\\sigma_y^2 = \\dfrac{\\sigma_t^2}{k^2 N}$。\n\n因此，稳态方差为\n$$\n\\Sigma = \\frac{B_d^2}{1 - (A_d - B_d K)^2} \\cdot \\frac{\\sigma_t^2}{k^2 N},\n$$\n而所要求的闭环性能指标是稳态标准差\n$$\n\\sqrt{\\Sigma} = \\sqrt{ \\frac{B_d^2}{1 - (A_d - B_d K)^2} \\cdot \\frac{\\sigma_t^2}{k^2 N} }.\n$$\n\n对于每个带有参数 $(a, b, h, K, k, \\sigma_t^2, N)$ 的测试用例的算法步骤：\n\n1. 计算 $A_d = e^{a h}$。\n2. 如果 $a \\neq 0$，使用 $B_d = b \\dfrac{e^{a h} - 1}{a}$ 计算 $B_d$，否则 $B_d = b h$。\n3. 计算 $A_{\\text{cl}} = A_d - B_d K$。\n4. 计算解码指令误差方差 $\\sigma_y^2 = \\dfrac{\\sigma_t^2}{k^2 N}$。\n5. 如果 $\\lvert A_{\\text{cl}} \\rvert \\geq 1$，稳态方差不存在；为此用例返回一个非数值。否则，计算\n$$\n\\Sigma = \\frac{B_d^2 \\sigma_y^2}{1 - A_{\\text{cl}}^2},\n$$\n并输出四舍五入到六位小数的 $\\sqrt{\\Sigma}$。\n\n将这些步骤应用于提供的测试套件，将产生四个浮点数，代表由脉冲时间抖动通过时间解码器和闭环动力学传播引起的状态 $x_k$ 的稳态标准差。最终程序将这些结果聚合到指定格式的单行输出中。",
            "answer": "```python\nimport numpy as np\n\ndef steady_state_std(a, b, h, K, k, sigma_t2, N):\n    # Discrete-time coefficients under zero-order hold\n    Ad = np.exp(a * h)\n    if a != 0.0:\n        Bd = b * (Ad - 1.0) / a\n    else:\n        Bd = b * h\n\n    Acl = Ad - Bd * K\n\n    # Decoded command error variance with N-neuron averaging\n    sigma_y2 = sigma_t2 / (k ** 2 * N)\n\n    # Check mean-square stability\n    if abs(Acl) >= 1.0:\n        return float('nan')\n\n    denom = 1.0 - (Acl ** 2)\n    Sigma = (Bd ** 2) * sigma_y2 / denom\n    std = np.sqrt(Sigma)\n    return std\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each case is (a, b, h, K, k, sigma_t^2, N)\n    test_cases = [\n        (-2.0, 1.0, 0.02, 1.0, 0.01, 1.0e-6, 1),\n        ( 0.0, 1.0, 0.01, 50.0, 0.01, 1.0e-6, 1),\n        ( 0.5, 1.0, 0.10, 0.51, 0.02, 1.0e-6, 1),\n        (-2.0, 1.0, 0.02, 1.0, 0.01, 1.0e-6, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, h, K, k, sigma_t2, N = case\n        std = steady_state_std(a, b, h, K, k, sigma_t2, N)\n        # Round to six decimal places as required\n        if np.isnan(std):\n            results.append(\"nan\")\n        else:\n            results.append(f\"{std:.6f}\")\n\n    # Final print statement in the exact required format: single line, comma-separated, enclosed in brackets\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}