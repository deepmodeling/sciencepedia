{
    "hands_on_practices": [
        {
            "introduction": "本练习构成了疲劳分析的基石。我们将首先从基本的试验数据中确定材料的应力-寿命（$S-N$）特性，然后利用该模型结合Palmgren-Miner线性损伤法则，来预测在给定服役寿命下的许用应力。此练习强调了在简单载荷条件下，将材料性能与设计要求相关联的核心方法论。",
            "id": "2628812",
            "problem": "一根旋转钢轴在高周疲劳范围内承受完全反向弯曲。在此范围内，观察到应力-寿命关系可以通过基于两次完全反向拉压试验的幂律拟合很好地近似：当应力幅 $S_{a,1} = 350 \\ \\text{MPa}$ 时，失效循环次数为 $N_{f,1} = 6.0 \\times 10^{5}$；当应力幅 $S_{a,2} = 250 \\ \\text{MPa}$ 时，失效循环次数为 $N_{f,2} = 5.0 \\times 10^{6}$。该轴在服役期间承受重复的相同载荷块，每个载荷块包含在单一未知恒定应力幅 $S_{a}$ 下的 $n = 1.20 \\times 10^{5}$ 次完全反向循环。假设 Palmgren 和 Miner 的线性损伤累积假说适用于此服役载荷，因此当累积损伤达到1时发生失效。目标服役寿命为失效前承受 $B = 12$ 个相同的载荷块。\n\n从累积损伤和幂律应力-寿命关系的基本定义出发，确定能够达到目标服役寿命的最大许用应力幅 $S_{a}$。然后，使用您拟合的参数，确定寿命对应力幅的对数灵敏度 $\\partial \\ln N_{f} / \\partial \\ln S_{a}$，并根据微小相对变化来解释其含义。将 $S_{a}$ 的最终数值四舍五入至三位有效数字，并以 $\\text{MPa}$ 为单位表示。您报告的最终答案必须仅为按要求取整后的 $S_{a}$ 值。任何关于灵敏度的讨论都不需要单独的数值答案。",
            "solution": "所述问题有待验证。\n\n已知条件摘录如下：\n- 一根旋转钢轴，在高周疲劳范围内承受完全反向弯曲。\n- 应力-寿命关系可以用幂律拟合来近似。\n- 试验1：应力幅 $S_{a,1} = 350 \\ \\text{MPa}$，失效循环次数 $N_{f,1} = 6.0 \\times 10^{5}$。\n- 试验2：应力幅 $S_{a,2} = 250 \\ \\text{MPa}$，失效循环次数 $N_{f,2} = 5.0 \\times 10^{6}$。\n- 服役载荷由重复的相同载荷块组成。\n- 每块循环次数：$n = 1.20 \\times 10^{5}$。\n- 每块应力：未知的恒定应力幅 $S_{a}$。\n- 失效准则：Palmgren-Miner线性损伤累积，当累积损伤为1时发生失效。\n- 目标服役寿命：$B = 12$ 块。\n- 任务1：确定最大许用应力幅 $S_{a}$。\n- 任务2：确定对数灵敏度 $\\partial \\ln N_f / \\partial \\ln S_a$。\n- 取整：$S_{a}$ 保留三位有效数字。\n\n验证结论：\n该问题具有科学依据、提法明确且客观。它基于固体力学的既定原理，特别是用幂律应力-寿命（S-N）关系（Basquin关系式）描述的金属高周疲劳行为，以及Palmgren-Miner线性损伤累积法则。所提供的数据充分且一致，足以确定幂律模型的两个参数，并随后求解未知的应力幅。应力和寿命的数值对于钢材而言是符合物理实际的。因此，该问题被认为是有效的，并将提供解答。\n\n在高周疲劳范围内，应力-寿命关系由一个幂律给出，通常称为Basquin方程。这可以表示为：\n$$ S_a = A (N_f)^b $$\n其中 $S_a$ 是应力幅，$N_f$ 是失效循环次数，$A$ 和 $b$ 是材料常数。\n\n两个给定的数据点 $(S_{a,1}, N_{f,1})$ 和 $(S_{a,2}, N_{f,2})$ 可用于确定指数 $b$。\n我们得到以下两个方程组成的方程组：\n$$ S_{a,1} = A (N_{f,1})^b $$\n$$ S_{a,2} = A (N_{f,2})^b $$\n将第一个方程除以第二个方程，消去常数 $A$：\n$$ \\frac{S_{a,1}}{S_{a,2}} = \\left(\\frac{N_{f,1}}{N_{f,2}}\\right)^b $$\n为了求解 $b$，我们对两边取自然对数：\n$$ \\ln\\left(\\frac{S_{a,1}}{S_{a,2}}\\right) = b \\ln\\left(\\frac{N_{f,1}}{N_{f,2}}\\right) $$\n因此，指数 $b$ 为：\n$$ b = \\frac{\\ln(S_{a,1}/S_{a,2})}{\\ln(N_{f,1}/N_{f,2})} $$\n代入给定值，$S_{a,1} = 350 \\ \\text{MPa}$，$N_{f,1} = 6.0 \\times 10^{5}$ 次循环，$S_{a,2} = 250 \\ \\text{MPa}$，以及 $N_{f,2} = 5.0 \\times 10^{6}$ 次循环：\n$$ b = \\frac{\\ln(350/250)}{\\ln(6.0 \\times 10^{5} / 5.0 \\times 10^{6})} = \\frac{\\ln(1.4)}{\\ln(0.12)} $$\n\n接下来，我们应用Palmgren-Miner线性损伤累积法则。该法则指出，当累积损伤 $D$ 达到1时，发生失效。损伤 $D$ 是每种加载条件下循环次数比的总和：\n$$ D = \\sum_i \\frac{n_i}{N_{f,i}} = 1 $$\n在这个问题中，服役载荷由 $B = 12$ 个相同的载荷块组成，每个载荷块包含在恒定应力幅 $S_a$ 下的 $n = 1.20 \\times 10^{5}$ 次循环。施加的总循环次数为 $n_{total} = B \\times n$。在此应力幅下，失效循环次数为 $N_f(S_a)$。\n损伤方程简化为：\n$$ D = \\frac{n_{total}}{N_f(S_a)} = \\frac{B \\times n}{N_f(S_a)} = 1 $$\n因此，轴的设计疲劳寿命 $N_f$ 必须等于施加的总循环次数：\n$$ N_f(S_a) = B \\times n = 12 \\times (1.20 \\times 10^{5}) = 1.44 \\times 10^{6} \\ \\text{cycles} $$\n\n现在我们必须找出与此所需寿命 $N_f(S_a)$ 相对应的应力幅 $S_a$。我们可以使用S-N关系，将未知应力状态 $(S_a, N_f)$ 与一个已知试验点（例如 $(S_{a,1}, N_{f,1})$）关联起来：\n$$ \\frac{S_a}{S_{a,1}} = \\left(\\frac{N_f}{N_{f,1}}\\right)^b $$\n求解 $S_a$：\n$$ S_a = S_{a,1} \\left(\\frac{N_f}{N_{f,1}}\\right)^b $$\n代入数值：\n$$ S_a = 350 \\ \\text{MPa} \\times \\left(\\frac{1.44 \\times 10^{6}}{6.0 \\times 10^{5}}\\right)^{\\frac{\\ln(1.4)}{\\ln(0.12)}} $$\n$$ S_a = 350 \\times (2.4)^{\\frac{\\ln(1.4)}{\\ln(0.12)}} $$\n我们计算指数和最终应力的值：\n$b \\approx \\frac{0.3364722}{ -2.1202635} \\approx -0.1586938$\n$$ S_a \\approx 350 \\times (2.4)^{-0.1586938} \\approx 350 \\times (0.87068) \\approx 304.738 \\ \\text{MPa} $$\n按要求保留三位有效数字，最大许用应力幅为 $S_a = 305 \\ \\text{MPa}$。\n\n问题的第二部分要求确定寿命对应力的对数灵敏度 $\\partial \\ln N_f / \\partial \\ln S_a$。我们从S-N关系的对数形式开始：\n$$ \\ln(S_a) = \\ln(A) + b \\ln(N_f) $$\n整理得到 $\\ln(N_f)$：\n$$ \\ln(N_f) = \\frac{1}{b} (\\ln(S_a) - \\ln(A)) $$\n对 $\\ln(S_a)$求导，得到灵敏度：\n$$ \\frac{\\partial \\ln(N_f)}{\\partial \\ln(S_a)} = \\frac{1}{b} $$\n该灵敏度是Basquin指数 $b$ 的倒数。\n$$ \\frac{\\partial \\ln(N_f)}{\\partial \\ln(S_a)} = \\frac{1}{b} = \\frac{\\ln(N_{f,1}/N_{f,2})}{\\ln(S_{a,1}/S_{a,2})} = \\frac{\\ln(0.12)}{\\ln(1.4)} \\approx \\frac{-2.1202635}{0.3364722} \\approx -6.3015 $$\n对此结果的解释是，对于小的相对变化，有 $\\frac{\\Delta N_f}{N_f} \\approx \\frac{1}{b} \\frac{\\Delta S_a}{S_a}$。这个大的负值表明，疲劳寿命对应力幅的变化高度敏感。应力幅增加 $1\\%$（即 $\\frac{\\Delta S_a}{S_a} = 0.01$）会导致疲劳寿命大约减少 $6.3\\%$（即 $\\frac{\\Delta N_f}{N_f} \\approx -6.3 \\times 0.01 = -0.063$）。这种高灵敏度是高周疲劳的一个基本特征。\n\n最终要求的答案是 $S_a$ 的数值。",
            "answer": "$$\\boxed{305}$$"
        },
        {
            "introduction": "现实世界中的服役载荷很少是简单或重复的，而通常是复杂和随机的。为了分析这类变幅载荷历史，我们必须首先将其分解为一系列离散的损伤事件。本练习将介绍雨流计数法，这是一种从应力反转点序列中识别完整循环和半循环的行业标准算法，也是应用累积损伤理论的必要前提。",
            "id": "2628868",
            "problem": "一个光滑、名义上弹性的金属试样中的单轴、比例应力历史被足够密集地采样，以至于所有的转折点（局部最大值和最小值）都已被提取出来。由此得到的有序转折点应力序列（单位：兆帕，MPa）为：\n$0, 90, -30, 130, 10, 170, -10, 150, 20, 80, -50, 60, -20, 100, -40$。\n  \n仅使用转折点、闭合滞后回线以及《疲劳分析中循环计数标准规程》(ASTM E1049-85) 中规定的标准雨流计数原理的定义，对该序列进行雨流计数，以识别所有完整循环和残余的半循环。对于每个识别出的循环，确定其应力幅和应力比，其中应力幅定义为循环范围的一半，应力比定义为该循环中的最小应力除以最大应力。将每个循环报告为一对 $(S_a, R)$，其中 $S_a$ 的单位为 MPa。然后，通过将权重为 $1$ 的完整循环和权重为 $1/2$ 的半循环进行聚合，计算等效的完整循环总数。\n\n将最终答案表示为一个纯数字（无单位）。无需四舍五入；请提供精确值。",
            "solution": "所陈述的问题具有科学依据，提法恰当且完整。它描述了疲劳分析中的一个标准程序——雨流计数，该方法已在 ASTM E1049-85 中被编纂成规。所有必要的数据和定义均已提供。因此，该问题是有效的，并允许唯一的解。\n\n任务是对给定的应力转折点序列进行雨流计数。我们将采用四点算法，这是雨流计数原理的直接实现，可以正确识别完整循环和残余半循环。设转折点序列用 $S$ 表示。我们将通过维护一个我们称之为 $T$ 的残余堆栈来处理该序列。\n\n给定的应力转折点序列为：\n$$ S = [0, 90, -30, 130, 10, 170, -10, 150, 20, 80, -50, 60, -20, 100, -40] $$\n所有应力值的单位均为兆帕 (MPa)。\n\n算法流程如下：我们遍历 $S$ 中的点，将每个点添加到残余堆栈 $T$ 中。每次添加后，我们检查 $T$ 中的最后四个点是否形成了一个完整循环。设最后四个点为 $s_1, s_2, s_3, s_4$。如果范围 $|s_3 - s_2|$ 小于或等于范围 $|s_4 - s_1|$，则计数一个对应于 $s_2$ 和 $s_3$ 之间应力范围的完整循环。如果识别出一个循环，则从 $T$ 中移除点 $s_2$ 和 $s_3$，并在新的残余堆栈上重复此检查。如果没有识别出循环，我们继续处理 $S$ 中的下一个点。\n\n让我们追踪执行过程：\n\n1.  初始化残余堆栈 $T = []$。\n2.  处理来自 $S$ 的点：\n    - 添加 $0, 90, -30$。$T = [0, 90, -30]$。长度为 $3$，不检查。\n    - 添加 $130$。$T = [0, 90, -30, 130]$。检查最后四个点：$s_1=0, s_2=90, s_3=-30, s_4=130$。内范围 $|-30 - 90| = 120$ 小于或等于外范围 $|130 - 0| = 130$。计数一个从 $90$ 到 $-30$ 的完整循环。移除 $90$ 和 $-30$。$T$ 变为 $[0, 130]$。\n    - 添加 $10, 170$。$T = [0, 130, 10, 170]$。检查最后四个点：$s_1=0, s_2=130, s_3=10, s_4=170$。内范围 $|10 - 130| = 120$ 小于或等于外范围 $|170 - 0| = 170$。计数一个从 $130$ 到 $10$ 的完整循环。移除 $130$ 和 $10$。$T$ 变为 $[0, 170]$。\n    - 添加 $-10, 150$。$T = [0, 170, -10, 150]$。检查：$|-10 - 170| = 180$ 不 $\\le |150 - 0| = 150$。无循环。\n    - 添加 $20$。$T = [0, 170, -10, 150, 20]$。检查最后四个点 $[170, -10, 150, 20]$：$|150 - (-10)| = 160$ 不 $\\le |20 - 170| = 150$。无循环。\n    - 添加 $80$。$T = [0, 170, -10, 150, 20, 80]$。检查最后四个点 $[-10, 150, 20, 80]$：$|20 - 150| = 130$ 不 $\\le |80 - (-10)| = 90$。无循环。\n    - 添加 $-50$。$T = [0, 170, -10, 150, 20, 80, -50]$。检查最后四个点 $[150, 20, 80, -50]$：$|80 - 20| = 60 \\le |-50 - 150| = 200$。计数一个从 $20$ 到 $80$ 的完整循环。移除 $20$ 和 $80$。$T$ 变为 $[0, 170, -10, 150, -50]$。我们重新检查新的最后四个点 $[170, -10, 150, -50]$：$|150 - (-10)| = 160 \\le |-50 - 170| = 220$。计数一个从 $-10$ 到 $150$ 的完整循环。移除 $-10$ 和 $150$。$T$ 变为 $[0, 170, -50]$。长度为 $3$，不进一步检查。\n    - 添加 $60$。$T = [0, 170, -50, 60]$。检查：$|-50 - 170| = 220$ 不 $\\le |60 - 0| = 60$。无循环。\n    - 添加 $-20$。$T = [0, 170, -50, 60, -20]$。检查最后四个点 $[170, -50, 60, -20]$：$|60 - (-50)| = 110 \\le |-20 - 170| = 190$。计数一个从 $-50$ 到 $60$ 的完整循环。移除 $-50$ 和 $60$。$T$ 变为 $[0, 170, -20]$。\n    - 添加 $100$。$T = [0, 170, -20, 100]$。检查：$|-20 - 170| = 190$ 不 $\\le |100 - 0| = 100$。无循环。\n    - 添加 $-40$。$T = [0, 170, -20, 100, -40]$。检查最后四个点 $[170, -20, 100, -40]$：$|100 - (-20)| = 120 \\le |-40 - 170| = 210$。计数一个从 $-20$ 到 $100$ 的完整循环。移除 $-20$ 和 $100$。$T$ 变为 $[0, 170, -40]$。\n\n3.  输入序列 $S$ 现已处理完毕。最终的残余堆栈为 $T = [0, 170, -40]$。\n\n对于每个识别出的循环，我们计算应力幅 $S_a = \\frac{S_{max} - S_{min}}{2}$ 和应力比 $R = \\frac{S_{min}}{S_{max}}$。\n\n完整循环 ($N_{full} = 6$):\n1.  来自 $(90, -30)$：$S_{max}=90, S_{min}=-30$。$S_a = \\frac{90 - (-30)}{2} = 60$。$R = \\frac{-30}{90} = -\\frac{1}{3}$。配对：$(60, -\\frac{1}{3})$。\n2.  来自 $(130, 10)$：$S_{max}=130, S_{min}=10$。$S_a = \\frac{130 - 10}{2} = 60$。$R = \\frac{10}{130} = \\frac{1}{13}$。配对：$(60, \\frac{1}{13})$。\n3.  来自 $(80, 20)$：$S_{max}=80, S_{min}=20$。$S_a = \\frac{80 - 20}{2} = 30$。$R = \\frac{20}{80} = \\frac{1}{4}$。配对：$(30, \\frac{1}{4})$。\n4.  来自 $(150, -10)$：$S_{max}=150, S_{min}=-10$。$S_a = \\frac{150 - (-10)}{2} = 80$。$R = \\frac{-10}{150} = -\\frac{1}{15}$。配对：$(80, -\\frac{1}{15})$。\n5.  来自 $(60, -50)$：$S_{max}=60, S_{min}=-50$。$S_a = \\frac{60 - (-50)}{2} = 55$。$R = \\frac{-50}{60} = -\\frac{5}{6}$。配对：$(55, -\\frac{5}{6})$。\n6.  来自 $(100, -20)$：$S_{max}=100, S_{min}=-20$。$S_a = \\frac{100 - (-20)}{2} = 60$。$R = \\frac{-20}{100} = -\\frac{1}{5}$。配对：$(60, -\\frac{1}{5})$。\n\n残余半循环 ($N_{half} = 2$):\n残余堆栈 $T = [0, 170, -40]$ 通过配对相邻点产生两个半循环。\n1.  来自 $(0, 170)$：$S_{max}=170, S_{min}=0$。$S_a = \\frac{170 - 0}{2} = 85$。$R = \\frac{0}{170} = 0$。配对：$(85, 0)$。\n2.  来自 $(170, -40)$：$S_{max}=170, S_{min}=-40$。$S_a = \\frac{170 - (-40)}{2} = 105$。$R = \\frac{-40}{170} = -\\frac{4}{17}$。配对：$(105, -\\frac{4}{17})$。\n\n最后，我们计算等效的完整循环总数。每个完整循环的权重为 $1$，每个半循环的权重为 $\\frac{1}{2}$。\n$$ N_{total} = N_{full} + \\frac{1}{2} N_{half} $$\n代入计数结果：\n$$ N_{total} = 6 + \\frac{1}{2}(2) = 6 + 1 = 7 $$\n循环总数为 $7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "从手动计算迈向自动化分析是现代工程中的关键一步。这项综合性练习要求您将前面所有概念——反转点提取、雨流计数、平均应力修正和Miner法则——集成到一个完整的计算流程中。通过构建一个能将原始应力时间序列转化为最终损伤值的程序，您将对疲劳分析在实际软件中的实现方式获得深刻且实用的理解。",
            "id": "2875935",
            "problem": "您必须编写一个完整、可运行的程序，通过实施一个原则性的流程，将离散应力时间序列转换为累积疲劳损伤 $D$。该流程包括：对反转点进行雨流循环计数、线性平均应力修正、通过 $S$-$N$ 关系映射到破坏循环次数，以及随后的线性损伤累积。推导过程应基于核心定义：通过反转和闭合提取循环、每个循环的幅值和平均应力、参考极限抗拉强度的线性平均应力修正、与高周疲劳一致的 $S$-$N$ 关系，以及线性累积损伤。程序必须仅产生如下文规定的数值结果。\n\n必需的概念流程：\n- 从离散应力序列 $s(t_i)$ 开始，首先提取反转点（局部极大值和极小值），并保留序列的第一个和最后一个点。\n- 对反转点执行雨流计数，以产生具有范围 $\\Delta S$ 和平均值 $S_m$ 的循环，同时计数闭合循环和两端的剩余半循环。\n- 对于每个循环，计算应力幅 $S_a$ 和平均应力 $S_m$；应用参考极限抗拉强度 $S_u$ 的线性平均应力修正（Goodman 类型），以获得等效的完全反转幅值。\n- 使用具有确定疲劳极限 $S_e$ 的幂律 $S$-$N$ 关系，将等效幅值映射到破坏循环次数，当幅值低于疲劳极限时，损伤计为零。\n- 通过对所有循环进行线性求和来累积损伤，以获得 $D$。\n\n科学和数值要求：\n- 所有应力必须以兆帕 (MPa) 为单位处理。\n- 累积损伤 $D$ 是无量纲的。将 $D$ 表示为小数点后保留 $6$ 位的小数。\n- 将等效幅值小于或等于疲劳极限 $S_e$ 的循环视为造成零损伤。\n- 根据雨流标准，将剩余半循环视为贡献一个完整循环的 $0.5$ 权重。\n- 使用参考于 $S_u$ 的线性平均应力修正。\n- 使用由常数 $C$ 和 $m$ 表征的幂律 $S$-$N$ 关系。\n\n测试套件：\n- 对于所有测试用例，使用相同的材料参数：\n  - 极限抗拉强度 $S_u = 700$ MPa。\n  - 疲劳极限 $S_e = 160$ MPa。\n  - $S$-$N$ 常数：$C = 4.9 \\times 10^{12}$, $m = 3.0$。\n- 时间序列以兆帕 (MPa) 为单位的离散应力值 $s_i$ 给出。您的实现必须首先将每个序列简化为反转点，然后执行雨流计数。\n\n待评估的测试用例：\n- 用例 $1$ (理想情况，高于 $S_e$ 的完全反转循环): `[0, 200, -200, 200, -200, 0]`.\n- 用例 $2$ (边界情况，低于 $S_e$ 的完全反转循环): `[0, 80, -80, 80, -80, 0]`.\n- 用例 $3$ (显著的非零平均应力，修正后高于 $S_e$): `[100, 280, -80, 280, -80, 100]`.\n- 用例 $4$ (边缘情况，包含混合的小循环和一个产生半循环的未闭合大偏移): `[0, 50, 0, -50, 0, 220, 0]`.\n\n您的程序应生成单行输出，其中包含按用例顺序排列的结果，格式为方括号内的逗号分隔列表，例如 $[d_1,d_2,d_3,d_4]$，其中每个 $d_i$ 是四舍五入到小数点后 $6$ 位的累积损伤。\n\n交付内容：\n- 一个独立的 Python 程序，该程序：\n  - 实现反转点提取、雨流计数、平均应力修正（相对于 $S_u$ 的线性修正）以及使用提供的 $C$、$m$、$S_e$ 进行的 $S$-$N$ 映射。\n  - 通过线性累积计算每个测试用例的 $D$。\n  - 严格按照 $[d_1,d_2,d_3,d_4]$ 的格式打印一行，其中每个 $d_i$ 四舍五入到小数点后 $6$ 位。\n\n在您的书面解决方案中，清楚地识别并论证此流程中涉及的每个近似或建模选择的合理性，包括但不限于 $s(t)$ 的离散化、反转点提取、雨流闭合准则、线性平均应力修正、通过 $S_e$ 进行的 $S$-$N$ 外推和阈值处理，以及线性损伤累积。代码输出必须保持为上文指定的纯数字格式。",
            "solution": "所述问题是计算材料力学领域一个明确定义的练习，具体涉及累积疲劳损伤的估算。它具有科学依据，内部一致，并包含计算唯一解所需的所有必要参数和数据。因此，该问题被认为是有效的。\n\n解决方案需要实现一个标准的疲劳分析流程。每个步骤都基于既定的原则和模型，这些原则和模型涉及某些必须明确说明的理想化和近似。该过程从应力-时间历史 $s(t)$ 开始，最终得到一个单一的无量纲损伤值 $D$。\n\n**步骤1：反转点提取**\n疲劳损伤是由应力反转驱动的，而不是由整个时间历史驱动的。第一步是将离散应力序列 $s_i$ 提炼为其局部极值（峰值和谷值）的序列。如果点 $s_i$ 满足条件 $(s_i - s_{i-1})(s_{i+1} - s_i)  0$，则它被视为一个反转点。根据问题规范，序列的第一个和最后一个点总是保留在反转序列中。\n\n**步骤2：雨流循环计数**\n从反转点序列中，必须识别出单个的应力循环。雨流计数算法是完成此项任务的标准方法，因为它能正确地将应力峰值和谷值配对，形成与材料应力-应变行为中的闭合滞后回线相对应的循环。我们将采用符合 ASTM E1049 标准的“三点法”实现。\n\n算法流程如下：\n1. 将反转点序列复制到一个工作列表 $P$ 中。\n2. 循环处理列表 $P$，直到无法再提取出完整的循环。在每次迭代中：\n   a. 遍历列表，寻找第一个满足三点法准则的序列。设连续三个点为 $p_1, p_2, p_3$。\n   b. 检查应力范围 $\\Delta S_{12} = |p_2 - p_1|$ 和 $\\Delta S_{23} = |p_3 - p_2|$。如果 $\\Delta S_{12} \\ge \\Delta S_{23}$，则识别出一个闭合循环。\n   c. 此循环由点 $p_2$ 和 $p_3$ 定义。它被计为一个完整循环 ($n_i = 1$)。我们提取它用于损伤计算，并从列表 $P$ 中移除点 $p_2$ 和 $p_3$。然后从头开始重新扫描修改后的列表。\n3. 遍历完后，$P$ 中剩余的任何点构成未闭合的残余循环。最终列表中每对相邻的点 $(p_j, p_{j+1})$ 代表一个半循环 ($n_i = 0.5$)。\n\n对于每个识别出的循环（完整或半循环），我们计算其应力幅 $S_a$ 和平均应力 $S_m$：\n$$ S_a = \\frac{S_{\\text{max}} - S_{\\text{min}}}{2} $$\n$$ S_m = \\frac{S_{\\text{max}} + S_{\\text{min}}}{2} $$\n\n**步骤3：平均应力修正**\n应力循环的损伤效应取决于其幅值和平均应力。拉伸平均应力 ($S_m > 0$) 通常会降低疲劳寿命。问题指定了参考极限抗拉强度 $S_u$ 的线性平均应力修正。这对应于 Goodman 关系。我们用它来计算一个等效的、完全反转的应力幅 $S_{a,eq}$，理论上该应力幅将产生与具有幅值 $S_a$ 和平均应力 $S_m$ 的实际循环相同的疲劳寿命。\n\nGoodman 关系式如下：\n$$ \\frac{S_a}{S_{a,eq}} + \\frac{S_m}{S_u} = 1 $$\n解出等效幅值 $S_{a,eq}$：\n$$ S_{a,eq} = \\frac{S_a}{1 - \\frac{S_m}{S_u}} $$\n该方程适用于拉伸平均应力 ($S_m > 0$)。对于压缩性平均应力 ($S_m \\le 0$)，一种标准的、保守的工程实践是假设没有平均应力效应，因此我们取 $S_{a,eq} = S_a$。\n\n**步骤4：破坏循环次数（$S$-$N$ 关系）**\n应力幅值与破坏循环次数 $N_f$ 之间的关系由 $S$-$N$ 曲线描述。问题指定了一个幂律关系，这是 Basquin 方程的一种形式，由常数 $C$ 和 $m$ 定义：\n$$ S_{a,eq}^m \\cdot N_f = C $$\n由此，我们可以计算给定等效幅值下的破坏循环次数：\n$$ N_f = \\frac{C}{S_{a,eq}^m} $$\n该模型的一个关键特征是疲劳极限 $S_e$。假设任何等效幅值 $S_{a,eq}$ 小于或等于 $S_e$ 的应力循环造成的损伤为零 ($N_f \\to \\infty$)。这是许多设计规范中的一个基本假设。\n\n**步骤5：线性损伤累积（Miner 法则）**\n最后一步是汇总所有已识别循环的损伤贡献。为此，我们使用 Palmgren-Miner 线性损伤累积法则。该法则假设总损伤 $D$ 是每个循环损伤分数的线性总和。第 $i$ 个循环的损伤分数是其施加次数 $n_i$（完整循环为 $1$，半循环为 $0.5$）与其破坏循环次数 $N_{f,i}$ 的比值。\n\n总累积损伤为：\n$$ D = \\sum_{i} \\frac{n_i}{N_{f,i}} $$\n求和遍及所有满足 $S_{a,eq,i} > S_e$ 的循环。\n\n**计算总结**\n提供的材料参数为：$S_u = 700$ MPa, $S_e = 160$ MPa, $C = 4.9 \\times 10^{12}$, $m = 3.0$。\n\n- **用例 1**：`[0, 200, -200, 200, -200, 0]`。雨流计数产生两个从 -200 到 200 的完整循环。$S_a=200$ MPa, $S_m=0$ MPa。$S_{a,eq} = 200 > S_e$。\n$N_f = (4.9 \\times 10^{12}) / 200^3 = 612500$。\n$D = 2 \\times (1 / 612500) \\approx 0.000003$。\n\n- **用例 2**：`[0, 80, -80, 80, -80, 0]`。雨流计数产生两个从 -80 到 80 的完整循环。$S_a=80$ MPa, $S_m=0$ MPa。$S_{a,eq} = 80 \\le S_e$。\n$D = 0$。\n\n- **用例 3**：`[100, 280, -80, 280, -80, 100]`。正确的雨流计数得到1.5个主要循环，其 $S_a=180$ MPa 和 $S_m=100$ MPa。\n$S_{a,eq} = 180 / (1 - 100/700) = 210$ MPa。$S_{a,eq} > S_e$。\n$N_f = (4.9 \\times 10^{12}) / 210^3 \\approx 529099.45$。\n$D = 1.5 / N_f \\approx 0.000003$。\n\n- **用例 4**：`[0, 50, 0, -50, 0, 220, 0]`。提取反转点后为 `[0, 50, -50, 220, 0]`。雨流计数识别出一个从 50 到 -50 的完整循环和两个半循环。最大的等效应力来自半循环 (0, 220)，其 $S_a = 110$ MPa, $S_m = 110$ MPa。\n$S_{a,eq} = 110 / (1 - 110/700) \\approx 130.51$ MPa。由于 $130.51 \\le S_e$，此循环及所有更小的循环造成的损伤为零。\n$D = 0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes cumulative fatigue damage for a set of stress time series\n    using a standard pipeline: reversal extraction, rainflow counting,\n    Goodman mean stress correction, and Miner's linear damage rule.\n    \"\"\"\n\n    # Material parameters (all stresses in MPa)\n    S_u = 700.0   # Ultimate tensile strength\n    S_e = 160.0   # Endurance limit\n    C = 4.9e12    # S-N constant\n    m = 3.0       # S-N exponent\n\n    test_cases = [\n        [0.0, 200.0, -200.0, 200.0, -200.0, 0.0],\n        [0.0, 80.0, -80.0, 80.0, -80.0, 0.0],\n        [100.0, 280.0, -80.0, 280.0, -80.0, 100.0],\n        [0.0, 50.0, 0.0, -50.0, 0.0, 220.0, 0.0],\n    ]\n\n    def extract_reversals(series):\n        \"\"\"\n        Extracts reversal points (peaks and valleys) from a time series.\n        Keeps the first and last points.\n        \"\"\"\n        if len(series)  3:\n            return series\n\n        reversals = [series[0]]\n        for i in range(1, len(series) - 1):\n            p_prev, p_curr, p_next = series[i - 1], series[i], series[i + 1]\n            if (p_curr - p_prev) * (p_next - p_curr)  0:\n                reversals.append(p_curr)\n        reversals.append(series[-1])\n        return reversals\n\n    def rainflow_count(reversals):\n        \"\"\"\n        Performs rainflow cycle counting using a standard 3-point algorithm (ASTM E1049).\n        Returns a list of tuples (amplitude, mean, count).\n        \"\"\"\n        points = list(reversals)\n        cycles = []\n\n        while len(points) >= 3:\n            found_cycle_in_pass = False\n            for i in range(len(points) - 2):\n                p1, p2, p3 = points[i], points[i+1], points[i+2]\n                range1 = abs(p2 - p1)\n                range2 = abs(p3 - p2)\n\n                if range1 >= range2:\n                    amplitude = range2 / 2.0\n                    mean_stress = (p2 + p3) / 2.0\n                    cycles.append((amplitude, mean_stress, 1.0))\n                    \n                    points.pop(i+1)\n                    points.pop(i+1) # p3 is now at i+1\n                    found_cycle_in_pass = True\n                    break \n            \n            if not found_cycle_in_pass:\n                break\n        \n        # Process residual half-cycles\n        for i in range(len(points) - 1):\n            p1, p2 = points[i], points[i+1]\n            amplitude = abs(p2 - p1) / 2.0\n            mean_stress = (p1 + p2) / 2.0\n            cycles.append((amplitude, mean_stress, 0.5))\n\n        return cycles\n\n    results = []\n    for case_series in test_cases:\n        reversals = extract_reversals(case_series)\n        cycles = rainflow_count(reversals)\n\n        total_damage = 0.0\n        for Sa, Sm, count in cycles:\n            if Sa == 0:\n                continue\n\n            # Apply Goodman mean stress correction\n            Sa_eq = Sa\n            if Sm > 0:\n                if Sm  S_u:\n                    Sa_eq = Sa / (1.0 - Sm / S_u)\n                else: \n                    Sa_eq = float('inf')\n\n            # Accumulate damage only if equivalent amplitude is above endurance limit\n            if Sa_eq > S_e:\n                Nf = C / (Sa_eq ** m)\n                total_damage += count / Nf\n\n        results.append(round(total_damage, 6))\n\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"
        }
    ]
}