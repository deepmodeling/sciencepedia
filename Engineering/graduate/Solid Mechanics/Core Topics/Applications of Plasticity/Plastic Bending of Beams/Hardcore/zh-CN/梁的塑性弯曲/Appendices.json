{
    "hands_on_practices": [
        {
            "introduction": "塑性分析的第一步是理解横截面的完全塑性状态。本练习提供了计算塑性中和轴位置的基本实践，该计算基于力平衡的基本原理，这也是计算塑性弯矩承载力 $M_p$ 的基石。通过分析一个非对称的T形截面 ，这个练习将清晰地展示这一核心概念的应用。",
            "id": "2670368",
            "problem": "一根关于其强轴单轴对称的T形截面直棱柱梁，承受正弯曲作用，使得上翼缘受压，底部纤维受拉。材料为理想弹塑性体，屈服应力为 $\\sigma_{y}$，且梁中无轴力。平截面假定成立。\n\nT形截面的几何尺寸如下：翼缘宽度 $b_{f} = 200\\,\\mathrm{mm}$，翼缘厚度 $t_{f} = 20\\,\\mathrm{mm}$，腹板厚度 $t_{w} = 20\\,\\mathrm{mm}$，翼缘下方的腹板高度 $h_{w} = 180\\,\\mathrm{mm}$。截面总高度为 $h = t_{f} + h_{w} = 200\\,\\mathrm{mm}$。\n\n根据理想弹塑性材料的内力和弯矩平衡的基本原理，确定在弯矩 $M = M_{p}$ 对应的全塑性状态下：\n- 从顶面算起的塑性中和轴位置 $y_{p}$，以及\n- 受压和受拉塑性区的竖向范围 $a_{c}$ 和 $a_{t}$，它们分别定义为从塑性中和轴到最外侧受压纤维（顶面）和最外侧受拉纤维（底面）的距离。\n\n所有距离以 $\\mathrm{mm}$ 为单位表示。请勿使用任何未从所述原理推导出的简便公式。",
            "solution": "所述问题具有科学依据，提法明确，且无内在矛盾。这是一个结构塑性分析中的标准问题。我们可以开始求解。\n\n纯弯曲（零轴力）作用下全塑性横截面分析的基本原理源于内力的平衡。材料被指定为理想弹塑性体。在全塑性状态下，横截面中的每一根纤维都已屈服。这意味着应力大小是均匀的，等于屈服应力 $\\sigma_y$，其正负号取决于纤维是受拉还是受压。\n\n设受压区的横截面面积为 $A_c$，受拉区的横截面面积为 $A_t$。受压区的应力为 $-\\sigma_y$，受拉区的应力为 $+\\sigma_y$。塑性中和轴（PNA）是这两个区域之间的分界线。轴向力平衡要求横截面上的总力为零：\n$$ \\sum F_x = \\int_A \\sigma \\, dA = 0 $$\n代入全塑性状态下的应力值：\n$$ \\int_{A_c} (-\\sigma_y) \\, dA + \\int_{A_t} (+\\sigma_y) \\, dA = 0 $$\n由于 $\\sigma_y$ 是一个非零常数，可以将其提取出来：\n$$ -\\sigma_y \\int_{A_c} dA + \\sigma_y \\int_{A_t} dA = 0 $$\n$$ -\\sigma_y A_c + \\sigma_y A_t = 0 $$\n这就导出了确定塑性中和轴位置的基本条件：\n$$ A_c = A_t $$\n横截面的总面积为 $A = A_c + A_t$。因此，PNA必须将总面积平分为两半：\n$$ A_c = A_t = \\frac{A}{2} $$\n首先，我们计算T形横截面的总面积。几何尺寸已知：翼缘宽度 $b_f = 200\\,\\mathrm{mm}$，翼缘厚度 $t_f = 20\\,\\mathrm{mm}$，腹板厚度 $t_w = 20\\,\\mathrm{mm}$，翼缘下方的腹板高度 $h_w = 180\\,\\mathrm{mm}$。\n翼缘的面积为 $A_f = b_f \\times t_f = 200\\,\\mathrm{mm} \\times 20\\,\\mathrm{mm} = 4000\\,\\mathrm{mm}^2$。\n腹板的面积为 $A_w = h_w \\times t_w = 180\\,\\mathrm{mm} \\times 20\\,\\mathrm{mm} = 3600\\,\\mathrm{mm}^2$。\n截面的总面积为 $A = A_f + A_w = 4000\\,\\mathrm{mm}^2 + 3600\\,\\mathrm{mm}^2 = 7600\\,\\mathrm{mm}^2$。\n\n根据上面推导的原理，受压区面积 $A_c$ 必须是总面积的一半：\n$$ A_c = \\frac{A}{2} = \\frac{7600\\,\\mathrm{mm}^2}{2} = 3800\\,\\mathrm{mm}^2 $$\n题目说明上翼缘受压。我们必须找到从顶面算起的PNA位置，用 $y_p$ 表示，使得其上方的面积为 $3800\\,\\mathrm{mm}^2$。\n我们将所需的受压区面积 $A_c$ 与翼缘面积 $A_f$ 进行比较。\n$A_c = 3800\\,\\mathrm{mm}^2$ 且 $A_f = 4000\\,\\mathrm{mm}^2$。\n由于 $A_c  A_f$，塑性中和轴必定位于翼缘内部。\n\n设 $y_p$ 是从顶面到PNA的距离。由于PNA在翼缘内（$0 \\le y_p \\le t_f$），受压区是一个宽度为 $b_f$、深度为 $y_p$ 的矩形：\n$$ A_c = b_f \\times y_p $$\n代入已知值：\n$$ 3800\\,\\mathrm{mm}^2 = 200\\,\\mathrm{mm} \\times y_p $$\n求解 $y_p$：\n$$ y_p = \\frac{3800\\,\\mathrm{mm}^2}{200\\,\\mathrm{mm}} = 19\\,\\mathrm{mm} $$\n$y_p = 19\\,\\mathrm{mm}$ 这个值小于翼缘厚度 $t_f = 20\\,\\mathrm{mm}$，这证实了我们关于PNA位于翼缘内的假设。\n因此，从顶面向下测量的塑性中和轴位置为 $y_p = 19\\,\\mathrm{mm}$。\n\n接下来，我们确定受压区和受拉区的竖向范围 $a_c$ 和 $a_t$。\n$a_c$ 定义为从PNA到最外侧受压纤维（即梁的顶面）的距离。顶面位于 $y=0$。PNA位于 $y=y_p$。\n$$ a_c = |y_p - 0| = y_p = 19\\,\\mathrm{mm} $$\n$a_t$ 定义为从PNA到最外侧受拉纤维（即梁的底面）的距离。截面的总高度为 $h = t_f + h_w = 20\\,\\mathrm{mm} + 180\\,\\mathrm{mm} = 200\\,\\mathrm{mm}$。底面位于 $y=h$。\n$$ a_t = |h - y_p| = 200\\,\\mathrm{mm} - 19\\,\\mathrm{mm} = 181\\,\\mathrm{mm} $$\n作为验算，这两个范围之和必须等于梁的总高度：$a_c + a_t = 19\\,\\mathrm{mm} + 181\\,\\mathrm{mm} = 200\\,\\mathrm{mm}$，结果正确。\n\n所求的量是塑性中和轴的位置 $y_p$ 以及受压区和受拉区的范围 $a_c$ 和 $a_t$。\n计算出的值为：\n$y_p = 19\\,\\mathrm{mm}$\n$a_c = 19\\,\\mathrm{mm}$\n$a_t = 181\\,\\mathrm{mm}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n19  19  181\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一旦确定了截面的塑性弯矩承载力，我们就可以用它来评估整个结构的极限承载能力。本练习应用极限分析的静力（下限）定理，这是一个获得结构失稳荷载安全估计的强大工具。它要求学生将平衡原理和屈服条件应用于一个静不定梁 ，从而将截面分析的知识扩展到结构层面。",
            "id": "2670343",
            "problem": "一根长度为 $L$ 的直棱柱梁，在 $x=0$ 处为固支，在 $x=L$ 处为简支（铰接），形成一个支承悬臂梁。该梁在 $0 \\le x \\le L$ 的区间内承受未知常数集度为 $w$ 的均布荷载。材料被建模为弯曲刚-理想塑性体，具有对称的、截面恒定的塑性极限弯矩 $M_p$（即，对于所有 $x$ ，弯矩屈服条件为 $|M(x)| \\le M_p$）。忽略剪切破坏，且梁在横向足够宽，满足平截面假定。\n\n利用极限分析的静力（下限）定理，并仅使用梁的平衡关系，确定 $w$ 的最大值，使得存在一个弯矩场 $M(x)$ 满足以下条件：\n- 与所施加的荷载满足一维平衡关系，\n- 满足 $x=L$ 处铰链施加的边界条件，\n- 并且处处满足屈服条件 $|M(x)| \\le M_p$。\n\n不使用任何运动（上限）法论证。将最终答案表示为仅含 $M_p$ 和 $L$ 的闭合形式表达式。不需要进行数值计算，最终表达式中也不应包含单位。",
            "solution": "在尝试求解之前，需对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n-   梁的几何形状：直棱柱梁，长度 $L$。\n-   边界条件：在 $x=0$ 处为固支，在 $x=L$ 处为简支（铰接）。\n-   荷载：在整个跨度 $0 \\le x \\le L$ 上，承受常数集度为 $w$ 的均布荷载。\n-   材料模型：刚-理想塑性。\n-   屈服准则：弯矩 $M(x)$ 受塑性极限弯矩 $M_p$ 的限制，即对于所有 $x \\in [0, L]$，有 $|M(x)| \\le M_p$。\n-   方法：极限分析的静力（下限）定理，仅使用平衡关系。\n-   目标：找到 $w$ 的最大值，使得存在一个弯矩场 $M(x)$，该场满足平衡关系、边界条件 $M(L)=0$ 以及屈服准则。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题是结构塑性分析中的一个经典练习，特别是将静力定理应用于静不定梁。所有提供的信息在固体力学领域都是标准的。\n-   **科学依据：** 该问题基于梁理论、平衡理论以及完善的塑性极限分析理论的基本原理。刚-理想塑性模型是一种标准的理想化模型。该问题在科学上是合理的。\n-   **适定性：** 该问题要求在满足一组约束条件下的最大荷载，这是一个适定的优化问题。预期可以得到极限荷载的唯一解。\n-   **客观性：** 问题陈述使用了精确、无歧义的技术术语。\n问题设定是完整的、一致的、可形式化的。没有科学、逻辑或结构上的缺陷。\n\n**结论**\n该问题有效。下面将推导解答。\n\n**解答推导**\n该问题要求找到与极限分析静力定理一致的最大荷载 $w$。这需要找到一个满足以下条件的弯矩场 $M(x)$：\n1.  平衡：该场必须与所施加的荷载 $w$ 及支座反力保持平衡。\n2.  边界条件：该场必须满足任何给定的弯矩边界条件。此处为 $M(L)=0$。\n3.  屈服条件：对于所有 $x \\in [0, L]$，弯矩的绝对值不得超过塑性极限弯矩，即 $|M(x)| \\le M_p$。\n\n设 $R_L$ 为 $x=L$ 处铰支座的竖向反力。一个直接的方法是对荷载进行积分。弯矩的平衡方程为 $\\frac{d^2M}{dx^2} = -w$。\n对 $x$ 积分得到剪力 $V(x) = \\frac{dM}{dx} = -wx + C_1$。\n再次积分得到弯矩 $M(x) = -\\frac{1}{2}wx^2 + C_1x + C_2$。\n\n常数 $C_1$ 和 $C_2$ 由支座反力确定。在固支端 $x=0$ 处，剪力为 $V(0) = R_0$，弯矩为 $M(0)=M_0$。因此，$C_1=R_0$ 且 $C_2=M_0$。\n弯矩场为 $M(x) = M_0 + R_0x - \\frac{1}{2}wx^2$。\n总的竖向力平衡关系为 $R_0+R_L=wL$。\n该问题是静不定的。静力定理允许我们通过找到存在有效弯矩场的最大 $w$ 来求得极限荷载。这种情况将在形成破坏机构时发生，对于此梁，这需要形成两个塑性铰。这些塑性铰的可能位置在弯矩绝对值最大的点。在均布向下的荷载作用下，负弯矩峰值出现在固支处（$x=0$），正弯矩峰值出现在跨中某处。\n\n将 $x=L$ 处的反力 $R_L$ 作为多余未知数，重写弯矩表达式。\n$M(x) = R_L(L-x) - \\frac{w}{2}(L-x)^2$。\n这个表达式自动满足 $M(L)=0$ 和平衡条件。\n\n临界弯矩值为：\n1.  固支处的弯矩，$x=0$：\n    $M(0) = R_L L - \\frac{wL^2}{2}$。这将是最大负弯矩的位置。\n2.  跨内的最大正弯矩。这发生在剪力为零处：\n    $V(x) = \\frac{dM}{dx} = -R_L + w(L-x) = 0 \\implies x_p = L - \\frac{R_L}{w}$。\n    将 $x_p$ 代入弯矩表达式，得到最大正弯矩：\n    $M_{pos,max} = M(x_p) = R_L\\left(\\frac{R_L}{w}\\right) - \\frac{w}{2}\\left(\\frac{R_L}{w}\\right)^2 = \\frac{R_L^2}{w} - \\frac{R_L^2}{2w} = \\frac{R_L^2}{2w}$。\n\n为使梁处于塑性容许状态，必须对所有 $x$ 满足 $|M(x)| \\le M_p$。这要求：\n-   $|M(0)| \\le M_p \\implies -M_p \\le R_L L - \\frac{wL^2}{2}$。\n-   $M_{pos,max} \\le M_p \\implies \\frac{R_L^2}{2w} \\le M_p$。\n\n极限荷载 $w$ 是指存在一个 $R_L$ 值能满足这些条件的最大荷载。当等式成立时达到这个最大值，这标志着塑性铰的形成：\n1.  $M(0) = -M_p \\implies R_L L - \\frac{wL^2}{2} = -M_p$。\n2.  $M_{pos,max} = M_p \\implies \\frac{R_L^2}{2w} = M_p$。\n\n我们求解这个关于 $w$ 和 $R_L$ 的二元方程组。从第一个方程，我们表示出 $R_L$：\n$R_L = \\frac{wL}{2} - \\frac{M_p}{L}$。\n将此代入第二个方程：\n$\\frac{1}{2w}\\left(\\frac{wL}{2} - \\frac{M_p}{L}\\right)^2 = M_p$。\n展开平方项：\n$\\frac{1}{2w}\\left(\\frac{w^2L^2}{4} - 2\\frac{wL}{2}\\frac{M_p}{L} + \\frac{M_p^2}{L^2}\\right) = M_p$。\n$\\frac{w^2L^2}{4} - wM_p + \\frac{M_p^2}{L^2} = 2wM_p$。\n整理各项得到一个关于 $w$ 的二次方程：\n$\\frac{w^2L^2}{4} - 3wM_p + \\frac{M_p^2}{L^2} = 0$。\n为简化，两边乘以 $4L^2$：\n$w^2L^4 - 12wL^2M_p + 4M_p^2 = 0$。\n使用二次方程求根公式 $w = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ 求解 $w$：\n$w = \\frac{12L^2M_p \\pm \\sqrt{(-12L^2M_p)^2 - 4(L^4)(4M_p^2)}}{2L^4}$。\n$w = \\frac{12L^2M_p \\pm \\sqrt{144L^4M_p^2 - 16L^4M_p^2}}{2L^4}$。\n$w = \\frac{12L^2M_p \\pm \\sqrt{128L^4M_p^2}}{2L^4} = \\frac{12L^2M_p \\pm 8\\sqrt{2}L^2M_p}{2L^4}$。\n$w = \\frac{(12 \\pm 8\\sqrt{2})M_p}{2L^2} = (6 \\pm 4\\sqrt{2})\\frac{M_p}{L^2}$。\n\n必须选择物理上正确的解。内部塑性铰的形成要求其位置 $x_p$ 在梁的跨度内，即 $0  x_p  L$。\n$x_p = L - \\frac{R_L}{w} = L - \\frac{1}{w}\\left(\\frac{wL}{2} - \\frac{M_p}{L}\\right) = \\frac{L}{2} + \\frac{M_p}{wL}$。\n条件 $x_p  L$ 意味着 $\\frac{M_p}{wL}  \\frac{L}{2}$，这要求 $w > \\frac{2M_p}{L^2}$。\n$w$ 的两个解是：\n$w_1 = (6 + 4\\sqrt{2})\\frac{M_p}{L^2} \\approx 11.657\\frac{M_p}{L^2}$。\n$w_2 = (6 - 4\\sqrt{2})\\frac{M_p}{L^2} \\approx 0.343\\frac{M_p}{L^2}$。\n显然，$w_1 > \\frac{2M_p}{L^2}$ 且 $w_2  \\frac{2M_p}{L^2}$。\n较大的根 $w_1$ 对应于一个带有内部塑性铰的有效破坏机构。较小的根 $w_2$ 对应于最大正弯矩会出现在梁跨度之外的情况，这与假设的塑性铰形成模式相矛盾。因此，可以承受的最大 $w$ 值为 $w_1$。",
            "answer": "$$\\boxed{(6 + 4\\sqrt{2})\\frac{M_p}{L^2}}$$"
        },
        {
            "introduction": "解析解通常局限于理想化的材料模型，例如理想弹塑性材料。这个高级实践将我们带入计算力学的领域，要求你通过编写纤维模型程序来追踪具有复杂、非均匀材料硬化特性的梁的完整弯矩-曲率响应。这项练习  弥合了理论与现代工程数值模拟之间的鸿沟，是真正意义上的“动手”实践。",
            "id": "2670335",
            "problem": "要求您实现一个完整、可运行的程序，该程序使用单轴率无关塑性与各向同性硬化的逐层（纤维）数值积分方法，构建层合矩形金属梁在给定曲率历史下的增量弯曲响应。截面响应必须通过对未知轴向应变进行标量牛顿迭代，在每个曲率增量下强制满足轴向力平衡来计算，同时每一层通过适用于其硬化定律的一维返回映射算法进行更新。\n\n该问题必须在以下假设和基本原则下求解：\n- 运动学：小应变和 Bernoulli-Euler 假设，即平截面在变形后保持为平面且垂直于中性轴。沿截面深度坐标的轴向应变分布由 $ \\varepsilon(y) = \\varepsilon_0 - \\kappa \\, y $ 给出，其中 $ \\varepsilon_0 $ 是几何形心（$ y = 0 $）处的截面轴向应变，$ \\kappa $ 是标量曲率，$ y $ 是指向顶面为正的坐标。\n- 静力学：截面力合力为 $ N = \\int_A \\sigma \\, \\mathrm{d}A $ 和 $ M = \\int_A \\sigma \\, y \\, \\mathrm{d}A $，其中 $ \\sigma $ 是轴向柯西应力。对于宽度恒为 $ b $ 的矩形截面，在逐层中点积分下，这些积分简化为黎曼和 $ N \\approx \\sum_i \\sigma_i \\, b \\, t_i $ 和 $ M \\approx \\sum_i \\sigma_i \\, y_i \\, b \\, t_i $，其中 $ t_i $ 是层的厚度，$ y_i $ 是其形心。\n- 每层的本构响应：一维、率无关、相关联塑性，与基于偏应力张量第二不变量 (J2) 的 von Mises 准则在单轴应力下的特例相一致。设应变加法分解为 $ \\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}} $，其中 $ \\sigma = E \\, \\varepsilon^{\\mathrm{e}} $（胡克定律），屈服函数为 $ \\varphi(\\sigma,p) = |\\sigma| - \\sigma_{y0} - R(p) \\le 0 $，其中 $ \\sigma_{y0} $ 是初始屈服应力，$ p $ 是累积等效塑性应变，$ R(p) $ 是一个各向同性硬化函数。流动法则是 $ \\mathrm{d}\\varepsilon^{\\mathrm{p}} = \\mathrm{d}\\lambda \\, \\mathrm{sign}(\\sigma) $ 和 $ \\mathrm{d}p = \\mathrm{d}\\lambda $，并遵循 Karush-Kuhn-Tucker 加载-卸载条件。如果发生屈服，必须通过求解标量塑性一致性问题来实现层级的单轴返回映射。\n\n您的代码必须实现：\n- 将矩形横截面进行纤维离散化，划分为 $ N_{\\ell} $ 个等厚度层，每层厚度为 $ t = h/N_{\\ell} $，其中 $ h $ 是截面深度。层的形心坐标为 $ y_i = -h/2 + \\left(i+\\tfrac{1}{2}\\right) t $，其中 $ i = 0, 1, \\dots, N_{\\ell}-1 $。\n- 在每个加载步，对未知量 $ \\varepsilon_0 $ 进行牛顿迭代，强制满足 $ N = N_{\\mathrm{ext}} $，其中 $ N_{\\mathrm{ext}} = 0 $，而曲率 $ \\kappa $ 由加载历史给定。对于给定的迭代值 $ \\varepsilon_0 $，层的总应变为 $ \\varepsilon_i = \\varepsilon_0 - \\kappa \\, y_i $。使用逐层返回映射计算该状态下的 $ \\sigma_i $ 和算法切线 $ \\partial \\sigma_i / \\partial \\varepsilon_i $。组集残差 $ r = \\sum_i \\sigma_i \\, b \\, t - N_{\\mathrm{ext}} $ 和截面切线 $ K = \\sum_i \\left(\\partial \\sigma_i / \\partial \\varepsilon_i\\right) b \\, t $，并更新 $ \\varepsilon_0 \\leftarrow \\varepsilon_0 - r/K $ 直至轴向力收敛。收敛后，计算弯矩 $ M = \\sum_i \\sigma_i \\, y_i \\, b \\, t $。\n- 按深度区域划分的层硬化定律：\n  - 顶部三分之一（即 $ y \\in (h/6, h/2] $）：线性各向同性硬化 $ R(p) = H \\, p $。\n  - 中部三分之一（即 $ y \\in [-h/6, h/6] $）：理想弹塑性 $ R(p) = 0 $。\n  - 底部三分之一（即 $ y \\in [-h/2, -h/6) $）：Voce 型饱和硬化 $ R(p) = Q \\left( 1 - e^{-b_{\\mathrm{V}} p} \\right) $。\n- 层级的返回映射：\n  - 根据层的总应变和上一步的塑性应变计算弹性试探应力。\n  - 如果是弹性的，则接受试探状态。\n  - 如果是塑性的，则求解由 $ \\varphi(\\sigma_{n+1}, p_{n+1}) = 0 $ 产生的标量塑性一致性问题，以获得塑性乘子增量。对于线性硬化和理想弹塑性，该标量方程有闭合解。对于 Voce 定律，使用稳健的牛顿法求解该标量方程，并对屈服函数设置合适的停止准则。\n  - 提供截面级牛顿迭代所需的、更新后状态下的算法一致切线 $ \\partial \\sigma / \\partial \\varepsilon $。\n\n物理和数值单位：\n- 所有长度 $ b $ 和 $ h $ 的单位为米。弹性模量 $ E $、屈服应力 $ \\sigma_{y0} $ 以及硬化参数 $ H $ 和 $ Q $ 的单位为帕斯卡。曲率 $ \\kappa $ 的单位为米的倒数。弯矩 $ M $ 必须以牛顿-米为单位报告。最终答案以牛顿-米表示，并四舍五入到三位有效数字。\n\n测试套件和要求输出：\n- 为以下三个测试用例实现计算。每个用例都使用上述按三分之一深度分配硬化定律的相同方式，但具有各自的几何形状和曲率历史。截面宽度 $b$ 沿深度保持不变。对于每个用例，在每个加载步中，轴向合力都被约束为 $ N_{\\mathrm{ext}} = 0 $。使用包含端点的等间距曲率步。\n\n  - 用例 A（通用混合塑性，“理想路径”）：\n    - 几何参数：$ b = 0.06 \\ \\mathrm{m} $，$ h = 0.12 \\ \\mathrm{m} $，层数 $ N_{\\ell} = 120 $。\n    - 按区域划分的材料参数：\n      - 顶部三分之一（线性硬化）：$ E = 2.10 \\times 10^{11} \\ \\mathrm{Pa} $，$ \\sigma_{y0} = 3.20 \\times 10^{8} \\ \\mathrm{Pa} $，$ H = 1.20 \\times 10^{9} \\ \\mathrm{Pa} $。\n      - 中部三分之一（理想塑性）：$ E = 2.00 \\times 10^{11} \\ \\mathrm{Pa} $，$ \\sigma_{y0} = 2.20 \\times 10^{8} \\ \\mathrm{Pa} $。\n      - 底部三分之一（Voce）：$ E = 2.10 \\times 10^{11} \\ \\mathrm{Pa} $，$ \\sigma_{y0} = 3.00 \\times 10^{8} \\ \\mathrm{Pa} $，$ Q = 1.50 \\times 10^{8} \\ \\mathrm{Pa} $，$ b_{\\mathrm{V}} = 25 $。\n    - 曲率历史：从 $ \\kappa = 0 $ 到 $ \\kappa = 0.06 \\ \\mathrm{m}^{-1} $，分为 $ 80 $ 个等增量步。\n\n  - 用例 B（纯弹性边界情况）：\n    - 几何参数：$ b = 0.06 \\ \\mathrm{m} $，$ h = 0.12 \\ \\mathrm{m} $，层数 $ N_{\\ell} = 120 $。\n    - 材料参数与用例 A 相同。\n    - 曲率历史：从 $ \\kappa = 0 $ 到 $ \\kappa = 1.0 \\times 10^{-5} \\ \\mathrm{m}^{-1} $，分为 $ 4 $ 个等增量步。\n\n  - 用例 C（反向弯曲和强塑性边缘情况）：\n    - 几何参数：$ b = 0.05 \\ \\mathrm{m} $，$ h = 0.10 \\ \\mathrm{m} $，层数 $ N_{\\ell} = 100 $。\n    - 按区域划分的材料参数：\n      - 顶部三分之一（线性硬化）：$ E = 2.05 \\times 10^{11} \\ \\mathrm{Pa} $，$ \\sigma_{y0} = 3.00 \\times 10^{8} \\ \\mathrm{Pa} $，$ H = 1.00 \\times 10^{9} \\ \\mathrm{Pa} $。\n      - 中部三分之一（理想塑性）：$ E = 2.00 \\times 10^{11} \\ \\mathrm{Pa} $，$ \\sigma_{y0} = 2.00 \\times 10^{8} \\ \\mathrm{Pa} $。\n      - 底部三分之一（Voce）：$ E = 2.10 \\times 10^{11} \\ \\mathrm{Pa} $，$ \\sigma_{y0} = 3.20 \\times 10^{8} \\ \\mathrm{Pa} $，$ Q = 2.00 \\times 10^{8} \\ \\mathrm{Pa} $，$ b_{\\mathrm{V}} = 20 $。\n    - 曲率历史：从 $ \\kappa = 0 $到 $ \\kappa = -0.05 \\ \\mathrm{m}^{-1} $，分为 $ 60 $ 个等增量步。\n\n- 对于每个用例，报告其历史中最终曲率下的弯矩。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为三个弯矩值（单位为牛顿-米），按 [用例 A 结果, 用例 B 结果, 用例 C 结果] 的顺序排列，并四舍五入到三位有效数字。例如，您的输出必须类似于 $ [m_A, m_B, m_C] $，其中每个 $ m_\\cdot $ 是一个四舍五入到三位有效数字的浮点数（单位为牛顿-米）。\n\n科学真实性和实现约束：\n- 使用上述本构和平衡原理。除了所述的逐层数值积分和牛顿解法外，不要假定任何闭合形式的截面响应。\n- 对层级塑性求解和截面级牛顿求解均使用稳健的容差。确保算法对给定的测试套件收敛，并且轴向力平衡残差相对于特征截面力尺度被驱动到一个可忽略的值。\n- 最终代码必须是自包含的，不需任何输入，并遵守后面指定的执行环境。唯一允许的外部库是 Numerical Python (NumPy) 和 Python 标准库。",
            "solution": "所提出的问题是计算固体力学中一个适定且科学合理的问题。它要求实现一个数值算法来模拟层合梁的塑性弯曲。所提供的关于几何形状、材料行为、加载和数值方法的细节是完整、一致的，并且基于已建立的力学原理。该问题是有效的。我们开始进行求解。\n\n任务是计算一个矩形梁截面在给定曲率历史 $\\kappa$ 和净轴向力为零 $N=0$ 的约束下所承受的弯矩 $M$。该梁由具有不同材料属性的层组成，表现出带各向同性硬化的弹塑性行为。求解需要一个嵌套迭代方法：一个外循环增加曲率，一个内层 Newton-Raphson 循环确定截面的中性轴应变 $\\varepsilon_0$ 以满足轴向平衡。每个材料层的状态使用返回映射算法进行更新。\n\n**1. 运动学和截面离散化**\n\n我们采用 Bernoulli-Euler 假设，即平截面保持为平面。距离截面几何形心 $y$ 处的轴向应变 $\\varepsilon$ 是线性的：\n$$ \\varepsilon(y) = \\varepsilon_0 - \\kappa y $$\n此处，$ \\varepsilon_0 $ 是形心（$y=0$）处的轴向应变，$ \\kappa $ 是给定的曲率。坐标 $y$ 指向梁的顶面为正。\n\n高为 $h$、宽为 $b$ 的矩形截面被离散化为 $N_{\\ell}$ 个等厚度层，每层厚度 $t = h/N_{\\ell}$。每一层 $i$（其中 $i=0, \\dots, N_{\\ell}-1$）由其形心坐标 $y_i$ 和面积 $A_i=b \\cdot t$ 表示：\n$$ y_i = -\\frac{h}{2} + \\left(i+\\frac{1}{2}\\right)t $$\n这种离散表示将截面力合力的积分定义转化为黎曼和：\n- 轴向力：$N = \\int_A \\sigma \\, \\mathrm{d}A \\approx \\sum_{i=0}^{N_{\\ell}-1} \\sigma_i \\, A_i$\n- 弯矩：$M = \\int_A \\sigma y \\, \\mathrm{d}A \\approx \\sum_{i=0}^{N_{\\ell}-1} \\sigma_i \\, y_i \\, A_i$\n其中 $\\sigma_i$ 是第 $i$ 层内的均匀轴向应力。\n\n**2. 层的本构模型与返回映射**\n\n每一层遵循一维、率无关的弹塑性本构律。总应变 $\\varepsilon$ 被加法分解为一个弹性部分 $\\varepsilon^{\\mathrm{e}}$ 和一个塑性部分 $\\varepsilon^{\\mathrm{p}}$：\n$$ \\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}} $$\n应力 $\\sigma$ 通过胡克定律与弹性应变相关联，$\\sigma = E \\varepsilon^{\\mathrm{e}}$，其中 $E$ 是杨氏模量。\n\n塑性变形由一个屈服函数 $\\varphi$ 控制，该函数依赖于应力 $\\sigma$ 和一个内状态变量，即累积塑性应变 $p$：\n$$ \\varphi(\\sigma, p) = |\\sigma| - (\\sigma_{y0} + R(p)) \\le 0 $$\n其中 $\\sigma_{y0}$ 是初始屈服应力，$R(p)$ 是描述屈服面扩展的硬化函数。塑性流动仅在 $\\varphi = 0$ 时发生。\n\n塑性应变的演化由一个相关联流动法则描述：\n$$ \\mathrm{d}\\varepsilon^{\\mathrm{p}} = \\mathrm{d}\\lambda \\, \\mathrm{sign}(\\sigma) \\quad \\text{and} \\quad \\mathrm{d}p = |\\mathrm{d}\\varepsilon^{\\mathrm{p}}| = \\mathrm{d}\\lambda $$\n其中 $\\mathrm{d}\\lambda \\ge 0$ 是塑性乘子。必须满足 Karush-Kuhn-Tucker (KKT) 条件：$\\mathrm{d}\\lambda \\ge 0$，$\\varphi \\le 0$ 和 $\\mathrm{d}\\lambda \\cdot \\varphi = 0$。\n\n对于给定的总应变增量，更新后的应力和状态变量通过返回映射算法求得：\n1.  **弹性预测**：假设步长是纯弹性的，计算试探应力：\n    $$ \\sigma^{\\mathrm{trial}} = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_n) $$\n    其中下标 $n$ 表示增量开始时的状态。\n2.  **屈服检查**：在试探状态下评估屈服函数：\n    $$ \\varphi^{\\mathrm{trial}} = |\\sigma^{\\mathrm{trial}}| - (\\sigma_{y0} + R(p_n)) $$\n    如果 $\\varphi^{\\mathrm{trial}} \\le 0$，则该步是弹性的。状态更新为 $\\sigma_{n+1} = \\sigma^{\\mathrm{trial}}$，$\\varepsilon^{\\mathrm{p}}_{n+1} = \\varepsilon^{\\mathrm{p}}_n$，$p_{n+1}=p_n$。材料响应是线性的，因此算法切线模量为 $E^{\\mathrm{alg}} = E$。\n3.  **塑性修正**：如果 $\\varphi^{\\mathrm{trial}} > 0$，则该步是塑性的。状态必须被“返回”到更新后的屈服面上。这需要求解满足步末一致性条件 $\\varphi(\\sigma_{n+1}, p_{n+1})=0$ 的塑性乘子增量 $\\Delta\\lambda > 0$。代入关系式 $\\sigma_{n+1} = \\sigma^{\\mathrm{trial}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{trial}})$ 和 $p_{n+1} = p_n + \\Delta\\lambda$，我们得到一个关于 $\\Delta\\lambda$ 的标量方程：\n    $$ g(\\Delta\\lambda) = |\\sigma^{\\mathrm{trial}}| - E\\Delta\\lambda - (\\sigma_{y0} + R(p_n + \\Delta\\lambda)) = 0 $$\n    $\\Delta\\lambda$ 的解取决于硬化函数 $R(p)$ 的形式：\n    - **理想弹塑性 ($R(p)=0$):** 该方程是线性的，得到闭合解：$\\Delta\\lambda = \\frac{|\\sigma^{\\mathrm{trial}}| - \\sigma_{y0}}{E}$。\n    - **线性硬化 ($R(p)=H p$):** 该方程对于 $\\Delta\\lambda$ 也是线性的：$\\Delta\\lambda = \\frac{|\\sigma^{\\mathrm{trial}}| - (\\sigma_{y0} + H p_n)}{E+H}$。\n    - **Voce 饱和硬化 ($R(p) = Q(1-e^{-b_{\\mathrm{V}}p})$):** 该方程变为非线性，必须数值求解，为此我们实现一个标量牛顿法。迭代公式为 $\\Delta\\lambda_{k+1} = \\Delta\\lambda_k - g(\\Delta\\lambda_k)/g'(\\Delta\\lambda_k)$，其中 $g'(\\Delta\\lambda) = -E - R'(p_n+\\Delta\\lambda)$。\n\n一旦求得 $\\Delta\\lambda$，状态就更新为：$p_{n+1}=p_n+\\Delta\\lambda$, $\\varepsilon^{\\mathrm{p}}_{n+1} = \\varepsilon^{\\mathrm{p}}_n + \\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{trial}})$, 以及 $\\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n+1})$。\n\n截面级牛顿迭代需要一致算法切线模量 $E^{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma_{n+1}}{\\mathrm{d}\\varepsilon_{n+1}}$。对于弹性步，$E^{\\mathrm{alg}}=E$。对于塑性步，它由以下公式给出：\n$$ E^{\\mathrm{alg}} = \\frac{E \\, R'(p_{n+1})}{E + R'(p_{n+1})} $$\n其中 $R'(p)$ 是硬化模量。对于理想塑性，$R'=0$，所以 $E^{\\mathrm{alg}}=0$。对于线性硬化，$R'=H$，所以 $E^{\\mathrm{alg}}=\\frac{EH}{E+H}$。\n\n**3. 截面级平衡**\n\n对于每个给定的曲率 $\\kappa_{n+1}$，我们必须找到满足轴向力平衡条件 $N(\\varepsilon_0) = 0$ 的轴向应变 $\\varepsilon_0$。这是一个标量求根问题，我们使用牛顿法来求解。\n从 $\\varepsilon_0$ 的一个初始猜测值开始，我们进行迭代：\n$$ \\varepsilon_0^{(k+1)} = \\varepsilon_0^{(k)} - \\frac{r^{(k)}}{K^{(k)}} $$\n残差 $r^{(k)}$ 是净轴向力，切向刚度 $K^{(k)}$ 是它关于 $\\varepsilon_0$ 的导数：\n$$ r^{(k)} = N(\\varepsilon_0^{(k)}) = \\sum_{i} \\sigma_i(\\varepsilon_0^{(k)}) \\, A_i $$\n$$ K^{(k)} = \\frac{\\mathrm{d}N}{\\mathrm{d}\\varepsilon_0}\\bigg|_{\\varepsilon_0^{(k)}} = \\sum_{i} \\frac{\\mathrm{d}\\sigma_i}{\\mathrm{d}\\varepsilon_i} \\frac{\\mathrm{d}\\varepsilon_i}{\\mathrm{d}\\varepsilon_0} A_i = \\sum_{i} E^{\\mathrm{alg}}_i \\, A_i $$\n迭代持续进行，直到残差的量值 $|r^{(k)}|$ 低于指定的容差。\n\n**4. 模拟算法**\n\n完整的模拟过程如下：\n1.  **初始化**：离散化截面，并根据每层的形心坐标 $y_i$ 分配材料属性（杨氏模量、屈服应力、硬化定律）。初始化所有状态变量：所有层的塑性应变 $\\varepsilon^{\\mathrm{p}}_i = 0$ 和累积塑性应变 $p_i = 0$。\n2.  **曲率增量**：遍历从 $\\kappa=0$ 到最终目标曲率的给定等间距曲率值序列。\n3.  **截面分析**：对于每个新的曲率值 $\\kappa_{n+1}$：\n    a.  使用上述截面级 Newton-Raphson 方法求解相应的形心应变 $\\varepsilon_0$。前一个曲率步的收敛值用作初始猜测值。\n    b.  在每次牛顿迭代中，根据当前试探总应变 $\\varepsilon_i = \\varepsilon_0 - \\kappa_{n+1}y_i$，使用返回映射算法计算每层的应力 $\\sigma_i$ 和算法切线 $E^{\\mathrm{alg}}_i$。\n4.  **状态更新**：一旦 $\\varepsilon_0$ 收敛，计算并存储当前曲率步的最终层状态（$\\sigma_i, \\varepsilon^{\\mathrm{p}}_i, p_i$），这些状态将成为下一个增量步的“上一步”状态。\n5.  **弯矩计算**：在最后一个曲率步求解完毕后，使用收敛后的层应力计算相应的弯矩：$M = \\sum_i \\sigma_i \\, y_i \\, A_i$。\n\n将此程序应用于问题陈述中指定的三个测试用例，以获得最终弯矩。",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Constants for numerical tolerances and limits\nSECTION_FORCE_TOL = 1e-6  # Tolerance for section axial force equilibrium [N]\nLAYER_CONSISTENCY_TOL = 1e-9  # Tolerance for layer consistency condition [Pa]\nMAX_SECTION_ITER = 20  # Max iterations for section Newton-Raphson\nMAX_LAYER_ITER = 20  # Max iterations for layer (Voce) Newton-Raphson\n\ndef round_to_sf(x, sf):\n    \"\"\"Rounds a number to a specified number of significant figures.\"\"\"\n    if x == 0:\n        return 0.0\n    return float(f\"{x:.{sf}g}\")\n\ndef _solve_voce_consistency(sig_trial_abs, p_n, E, sigy0, h_params):\n    \"\"\"\n    Solves the nonlinear consistency equation for Voce hardening\n    using Newton's method to find the plastic multiplier increment delta_lambda.\n    \"\"\"\n    Q, b_V = h_params\n    delta_lambda = 0.0\n\n    for _ in range(MAX_LAYER_ITER):\n        # Evaluate consistency residual g(delta_lambda)\n        p_np1 = p_n + delta_lambda\n        R_np1 = Q * (1.0 - math.exp(-b_V * p_np1))\n        g = sig_trial_abs - E * delta_lambda - (sigy0 + R_np1)\n\n        if abs(g)  LAYER_CONSISTENCY_TOL:\n            return delta_lambda\n\n        # Evaluate derivative g'(delta_lambda)\n        hardening_modulus_np1 = Q * b_V * math.exp(-b_V * p_np1)\n        g_prime = -E - hardening_modulus_np1\n        \n        # Newton update\n        delta_lambda -= g / g_prime\n\n    return delta_lambda # Return best effort if not converged\n\ndef update_layer_state(total_strain, ep_n, p_n, mat_props):\n    \"\"\"\n    Performs the return-mapping algorithm for a single layer.\n    \"\"\"\n    E, sigy0, hardening_type, h_params = mat_props\n\n    # 1. Elastic predictor\n    sig_trial = E * (total_strain - ep_n)\n    sig_trial_abs = abs(sig_trial)\n\n    # Calculate hardening at previous step\n    if hardening_type == 'perfect':\n        R_n = 0.0\n    elif hardening_type == 'linear':\n        H = h_params[0]\n        R_n = H * p_n\n    else: # Voce\n        Q, b_V = h_params\n        R_n = Q * (1.0 - math.exp(-b_V * p_n))\n\n    # 2. Yield check\n    phi_trial = sig_trial_abs - (sigy0 + R_n)\n\n    if phi_trial = 1e-9:  # Elastic step\n        E_alg = E\n        return sig_trial, E_alg, ep_n, p_n\n    \n    # 3. Plastic corrector\n    sign_sig = np.sign(sig_trial) if sig_trial != 0 else 1.0\n    \n    # Solve for plastic multiplier increment delta_lambda\n    if hardening_type == 'perfect':\n        delta_lambda = phi_trial / E\n        hardening_modulus_np1 = 0.0\n    elif hardening_type == 'linear':\n        H = h_params[0]\n        delta_lambda = phi_trial / (E + H)\n        hardening_modulus_np1 = H\n    else: # Voce\n        delta_lambda = _solve_voce_consistency(sig_trial_abs, p_n, E, sigy0, h_params)\n        Q, b_V = h_params\n        p_np1 = p_n + delta_lambda\n        hardening_modulus_np1 = Q * b_V * math.exp(-b_V * p_np1)\n\n    # Update state variables\n    p_np1 = p_n + delta_lambda\n    ep_np1 = ep_n + delta_lambda * sign_sig\n    sig_np1 = E * (total_strain - ep_np1)\n\n    # Calculate consistent algorithmic tangent\n    if (E + hardening_modulus_np1) == 0:\n        E_alg = 0.0\n    else:\n        E_alg = (E * hardening_modulus_np1) / (E + hardening_modulus_np1)\n    \n    return sig_np1, E_alg, ep_np1, p_np1\n\ndef run_simulation(case):\n    \"\"\"Main simulation driver for a single test case.\"\"\"\n    b, h, Nl = case['geom']\n    materials = case['materials']\n    kappa_start, kappa_end, n_steps = case['history']\n    \n    # Section discretization\n    t = h / Nl\n    layer_area = b * t\n    y_coords = -h / 2.0 + (np.arange(Nl) + 0.5) * t\n\n    # Assign material properties to layers\n    layer_mat_props = []\n    h_6 = h / 6.0\n    for y_i in y_coords:\n        if y_i  h_6:\n            layer_mat_props.append(materials['top'])\n        elif y_i  -h_6:\n            layer_mat_props.append(materials['bottom'])\n        else:\n            layer_mat_props.append(materials['middle'])\n\n    # Initialize state variables\n    ep_vals = np.zeros(Nl)  # Plastic strain\n    p_vals = np.zeros(Nl)   # Accumulated plastic strain\n    epsilon0 = 0.0\n\n    kappa_hist = np.linspace(kappa_start, kappa_end, n_steps + 1)\n\n    # Loop through curvature increments\n    for kappa_curr in kappa_hist[1:]:\n        epsilon0_guess = epsilon0  # Use previous converged value as guess\n        \n        # Section-level Newton-Raphson for epsilon0\n        for _ in range(MAX_SECTION_ITER):\n            # Store layer results for current iteration\n            sig_vals_iter = np.zeros(Nl)\n            E_alg_vals_iter = np.zeros(Nl)\n            \n            # Layer-wise update\n            total_strains_iter = epsilon0_guess - kappa_curr * y_coords\n            for i in range(Nl):\n                sig_i, E_alg_i, _, _ = update_layer_state(\n                    total_strains_iter[i], ep_vals[i], p_vals[i], layer_mat_props[i]\n                )\n                sig_vals_iter[i] = sig_i\n                E_alg_vals_iter[i] = E_alg_i\n            \n            # Assemble residual and tangent stiffness\n            residual_N = np.sum(sig_vals_iter) * layer_area\n            tangent_K = np.sum(E_alg_vals_iter) * layer_area\n            \n            # Check for convergence\n            if abs(residual_N)  SECTION_FORCE_TOL:\n                epsilon0 = epsilon0_guess\n                break\n            \n            if abs(tangent_K)  1e-9: # Avoid division by zero\n                # This should not happen in these problems\n                epsilon0 = epsilon0_guess\n                break\n\n            # Newton update\n            epsilon0_guess -= residual_N / tangent_K\n        else:\n            # If loop finishes without break, it did not converge\n            # Use the last guess and proceed\n            epsilon0 = epsilon0_guess\n        \n        # Update state variables for the converged step\n        final_strains = epsilon0 - kappa_curr * y_coords\n        for i in range(Nl):\n            _, _, ep_np1, p_np1 = update_layer_state(\n                final_strains[i], ep_vals[i], p_vals[i], layer_mat_props[i]\n            )\n            ep_vals[i] = ep_np1\n            p_vals[i] = p_np1\n            \n    # Final calculation after all increments\n    final_strains = epsilon0 - kappa_end * y_coords\n    final_sigmas = np.zeros(Nl)\n    for i in range(Nl):\n        sig_i, _, _, _ = update_layer_state(\n            final_strains[i], ep_vals[i], p_vals[i], layer_mat_props[i]\n        )\n        final_sigmas[i] = sig_i\n\n    final_moment = np.sum(final_sigmas * y_coords) * layer_area\n    return final_moment\n\ndef solve():\n    \"\"\"Defines and runs the test cases, then prints the results.\"\"\"\n    test_cases = [\n        # Case A\n        {\n            'geom': (0.06, 0.12, 120),\n            'materials': {\n                'top':    (2.10e11, 3.20e8, 'linear', (1.20e9,)),\n                'middle': (2.00e11, 2.20e8, 'perfect', ()),\n                'bottom': (2.10e11, 3.00e8, 'voce', (1.50e8, 25.0)),\n            },\n            'history': (0.0, 0.06, 80),\n        },\n        # Case B\n        {\n            'geom': (0.06, 0.12, 120),\n            'materials': {\n                'top':    (2.10e11, 3.20e8, 'linear', (1.20e9,)),\n                'middle': (2.00e11, 2.20e8, 'perfect', ()),\n                'bottom': (2.10e11, 3.00e8, 'voce', (1.50e8, 25.0)),\n            },\n            'history': (0.0, 1.0e-5, 4),\n        },\n        # Case C\n        {\n            'geom': (0.05, 0.10, 100),\n            'materials': {\n                'top':    (2.05e11, 3.00e8, 'linear', (1.00e9,)),\n                'middle': (2.00e11, 2.00e8, 'perfect', ()),\n                'bottom': (2.10e11, 3.20e8, 'voce', (2.00e8, 20.0)),\n            },\n            'history': (0.0, -0.05, 60),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        moment = run_simulation(case)\n        rounded_moment = round_to_sf(moment, 3)\n        results.append(rounded_moment)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}