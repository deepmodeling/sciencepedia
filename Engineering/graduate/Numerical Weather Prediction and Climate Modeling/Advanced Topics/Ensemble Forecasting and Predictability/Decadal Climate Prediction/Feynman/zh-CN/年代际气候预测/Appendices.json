{
    "hands_on_practices": [
        {
            "introduction": "年代际可预报性的核心来源之一是气候系统中的“慢变”分量，如海洋热含量。本练习将通过一个简洁而强大的一阶自回归（AR(1)）模型，来量化这种系统“记忆”的强度，并揭示为何持续性预报的技巧会随预报时效的延长而衰减 。理解这种内在的可预报性上限，是评估复杂气候模型性能的基础。",
            "id": "4030524",
            "problem": "在年代际气候预测中，缓慢变化的成分，如海盆平均的上层海洋热含量异常，通常被建模为一阶自回归过程。考虑一个用于表示海洋热含量异常序列 $\\{X_t\\}$ 的零均值一阶自回归 (AR(1)) 过程，其年分辨率由 $X_{t+1} = \\phi X_t + \\epsilon_t$ 给出，其中 $\\{ \\epsilon_t \\}$ 是一个零均值、序列不相关（白）噪声过程，方差为 $\\sigma_{\\epsilon}^{2}$，且独立于 $\\{X_t\\}$，并且 $|\\phi|  1$，因此该过程是具有有限方差的严格平稳过程。在时间 $t$ 发布的、预报时效为 $L$ 的持续性预报使用 $F_{t+L|t} = X_t$作为 $X_{t+L}$ 的预报。预报时效为 $L$ 的异常相关系数 (ACC) 定义为在平稳分布下，对许多独立预报实例的预报异常与验证异常之间的皮尔逊相关性，即 $\\mathrm{ACC}(L) = \\mathrm{Corr}(F_{t+L|t}, X_{t+L})$。\n\n仅从 AR(1) 的定义、白噪声假设和相关性的定义出发，推导期望 $\\mathrm{ACC}(L)$ 作为 $\\phi$ 和 $L$ 的函数的闭式表达式。以闭式形式给出最终表达式。然后，根据该模型中海洋热含量异常的记忆性来解释该表达式。最终答案必须是无单位的单个解析表达式。不需要进行数值舍入。",
            "solution": "我们从海洋热含量异常的模型定义开始，这是一个零均值一阶自回归 (AR(1)) 过程：\n$$\nX_{t+1} = \\phi X_t + \\epsilon_t,\n$$\n其中 $|\\phi|  1$，且 $\\{\\epsilon_t\\}$ 是一个零均值、序列不相关（白）噪声新息序列，其方差为 $\\sigma_{\\epsilon}^{2}$，且独立于 $\\{X_t\\}$。在这些条件下，该过程是具有有限方差的严格平稳过程。\n\n在时间 $t$ 发布的、预报时效为 $L$ 的持续性预报定义为\n$$\nF_{t+L|t} = X_t.\n$$\n预报时效为 $L$ 的异常相关系数 (ACC) 是 $F_{t+L|t}$ 与验证异常 $X_{t+L}$ 之间的皮尔逊相关性，在从平稳分布中抽取的许多预报实例上进行平均：\n$$\n\\mathrm{ACC}(L) = \\mathrm{Corr}(F_{t+L|t}, X_{t+L}) = \\frac{\\mathrm{Cov}(F_{t+L|t}, X_{t+L})}{\\sqrt{\\mathrm{Var}(F_{t+L|t}) \\, \\mathrm{Var}(X_{t+L})}}.\n$$\n在平稳性条件下，$\\mathrm{Var}(X_{t+L}) = \\mathrm{Var}(X_t)$。同样，$\\mathrm{Var}(F_{t+L|t}) = \\mathrm{Var}(X_t)$。因此，\n$$\n\\mathrm{ACC}(L) = \\frac{\\mathrm{Cov}(X_t, X_{t+L})}{\\mathrm{Var}(X_t)}.\n$$\n\n剩下的任务是计算 $\\mathrm{Cov}(X_t, X_{t+L})$。将 AR(1) 模型向前迭代 $L$ 步，可以得到众所周知的线性分解（可通过重复代换获得）：\n$$\nX_{t+L} = \\phi^{L} X_t + \\sum_{k=0}^{L-1} \\phi^{k} \\epsilon_{t+L-1-k}.\n$$\n新息序列 $\\{\\epsilon_s\\}$ 独立于 $X_t$ 且序列不相关。因此，\n$$\n\\mathrm{Cov}(X_t, X_{t+L}) = \\mathrm{Cov}\\!\\left(X_t, \\phi^{L} X_t + \\sum_{k=0}^{L-1} \\phi^{k} \\epsilon_{t+L-1-k}\\right) = \\phi^{L} \\mathrm{Cov}(X_t, X_t) + \\sum_{k=0}^{L-1} \\phi^{k} \\mathrm{Cov}(X_t, \\epsilon_{t+L-1-k}).\n$$\n对于每个 $k$，$\\epsilon_{t+L-1-k}$ 独立于 $X_t$，所以 $\\mathrm{Cov}(X_t, \\epsilon_{t+L-1-k}) = 0$。因此，\n$$\n\\mathrm{Cov}(X_t, X_{t+L}) = \\phi^{L} \\mathrm{Var}(X_t).\n$$\n代入 ACC 的表达式，我们得到\n$$\n\\mathrm{ACC}(L) = \\frac{\\phi^{L} \\mathrm{Var}(X_t)}{\\mathrm{Var}(X_t)} = \\phi^{L}.\n$$\n\n这就是在 AR(1) 模型下，持续性预报在预报时效为 $L$ 时的期望异常相关系数的闭式表达式。\n\n就记忆性而言的解释：ACC 等于 $\\phi^{L}$，这是一阶自回归过程在滞后 $L$ 时的自相关函数。因此，持续性预报的技巧随预报时效呈几何级数衰减，其衰减幅度由 $|\\phi|$ 控制。有效记忆时间尺度，定义为以时间步长为单位的 $e$ 折退相关时间，为\n$$\n\\tau = -\\frac{1}{\\ln |\\phi|}.\n$$\n当 $0  \\phi  1$ 时，ACC 为正，并随 $L$ 单调衰减。如果 $\\phi  0$，ACC 的符号随 $L$ 交替变化，而其大小则以 $|\\phi|^{L}$ 的速率衰减。较大的 $|\\phi|$ 意味着更长的记忆性和基于持续性的预报技巧随预报时效的衰减更慢。",
            "answer": "$$\\boxed{\\phi^{L}}$$"
        },
        {
            "introduction": "在生成气候预报后，我们必须使用严谨的指标来评估其表现。本练习将引导你推导并应用一个关键的评估工具——均方技巧评分（MSSS），它衡量了预报相对于一个基准（如气候平均态）的改进程度 。通过这个过程，你将学会如何量化预报技巧，并批判性地思考基准选择对技巧评估结果的重要影响。",
            "id": "4030497",
            "problem": "考虑一个区域平均地表温度异常时间序列的年代际气候预测实验。设有 $n$ 个年代际验证时间，索引为 $i = 1, \\dots, n$。将预测异常表示为 $f_i$，观测异常表示为 $o_i$，参考气候学预测表示为 $c_i$。在该实验中，技巧评分定义为预测相对于参考预测的均方误差的相对改进。\n\n从均方误差的基本定义 $MSE[X] = \\mathbb{E}\\left[(X - O)^{2}\\right]$ 出发，并使用其对于有限 $n$ 的无偏样本估计量 $\\frac{1}{n}\\sum_{i=1}^{n}(X_i - o_i)^{2}$，推导均方技巧评分的解析表达式，该表达式应以预测相对于气候学参考的误差平方和来表示。\n\n然后，将您推导的表达式应用于以下八个年代际的数据集（$n = 8$）。观测异常为\n$o_1 = 0.12$, $o_2 = -0.08$, $o_3 = 0.05$, $o_4 = 0.10$, $o_5 = -0.02$, $o_6 = 0.03$, $o_7 = 0.07$, $o_8 = -0.01$。\n预测异常为\n$f_1 = 0.10$, $f_2 = -0.05$, $f_3 = 0.00$, $f_4 = 0.12$, $f_5 = 0.00$, $f_6 = 0.02$, $f_7 = 0.06$, $f_8 = -0.02$。\n假设参考气候学是一个固定的异常基线，由 $c_i = 0$（对所有 $i$）给出（即，异常是相对于一个固定的基线期定义的，因此整个时期的气候学异常为零）。\n\n计算该数据集的均方技巧评分。将最终结果四舍五入至四位有效数字。将最终技巧评分表示为无量纲小数。\n\n最后，解释参考气候学 $c_i$ 的选择（例如，固定基线与包含趋势估计的随时间演变的气候学）如何影响年代际预测中技巧评分的解释。",
            "solution": "按照要求，解答分为三个部分：技巧评分表达式的推导，给定数据集的计算，以及对参考气候学作用的解释。\n\n**第1部分：均方技巧评分（MSSS）表达式的推导**\n\n均方技巧评分（MSSS）定义为预测（$f$）相对于参考预测（$c$）的均方误差（MSE）的相对改进，两者都与观测（$o$）进行比较。对于像MSE这样的误差度量，数值越小越好，完美评分为0，其技巧评分由下式给出：\n$$\nMSSS = \\frac{MSE_c - MSE_f}{MSE_c} = 1 - \\frac{MSE_f}{MSE_c}\n$$\n其中 $MSE_f$ 是预测的均方误差，$MSE_c$ 是参考预测的均方误差。\n\n使用为长度为 $n$ 的时间序列提供的无偏样本估计量，我们有：\n$$\nMSE_f = \\frac{1}{n}\\sum_{i=1}^{n}(f_i - o_i)^{2}\n$$\n$$\nMSE_c = \\frac{1}{n}\\sum_{i=1}^{n}(c_i - o_i)^{2}\n$$\n将这些代入MSSS的定义中，$\\frac{1}{n}$ 项相互抵消：\n$$\nMSSS = 1 - \\frac{\\sum_{i=1}^{n}(f_i - o_i)^{2}}{\\sum_{i=1}^{n}(c_i - o_i)^{2}}\n$$\n为了根据问题要求推导表达式，我们可以处理分子。让我们通过加上再减去参考预测 $c_i$ 来展开项 $(f_i - o_i)^2$：\n$$\n(f_i - o_i)^2 = ((f_i - c_i) - (o_i - c_i))^2 = (f_i - c_i)^2 - 2(f_i - c_i)(o_i - c_i) + (o_i - c_i)^2\n$$\n对所有 $i=1, \\dots, n$ 求和：\n$$\n\\sum_{i=1}^{n}(f_i - o_i)^{2} = \\sum_{i=1}^{n}(f_i - c_i)^2 - 2\\sum_{i=1}^{n}(f_i - c_i)(o_i - c_i) + \\sum_{i=1}^{n}(o_i - c_i)^2\n$$\n现在，将这个展开的分子代回MSSS表达式中：\n$$\nMSSS = 1 - \\frac{\\sum_{i=1}^{n}(f_i - c_i)^2 - 2\\sum_{i=1}^{n}(f_i - c_i)(o_i - c_i) + \\sum_{i=1}^{n}(o_i - c_i)^2}{\\sum_{i=1}^{n}(c_i - o_i)^{2}}\n$$\n注意到 $\\sum_{i=1}^{n}(o_i - c_i)^{2} = \\sum_{i=1}^{n}(c_i - o_i)^{2}$，我们可以将分数拆分：\n$$\nMSSS = 1 - \\left( \\frac{\\sum_{i=1}^{n}(f_i - c_i)^2}{\\sum_{i=1}^{n}(c_i - o_i)^{2}} - \\frac{2\\sum_{i=1}^{n}(f_i - c_i)(o_i - c_i)}{\\sum_{i=1}^{n}(c_i - o_i)^{2}} + 1 \\right)\n$$\n$$\nMSSS = \\frac{2\\sum_{i=1}^{n}(f_i - c_i)(o_i - c_i) - \\sum_{i=1}^{n}(f_i - c_i)^2}{\\sum_{i=1}^{n}(c_i - o_i)^{2}}\n$$\n这就是所求的MSSS解析表达式。对于参考气候学为零异常的特殊情况，即对所有 $i$ 都有 $c_i = 0$，该表达式简化为：\n$$\nMSSS = \\frac{2\\sum_{i=1}^{n}f_i o_i - \\sum_{i=1}^{n}f_i^2}{\\sum_{i=1}^{n}o_i^2}\n$$\n\n**第2部分：针对给定数据集的计算**\n\n数据集是针对 $n=8$ 个年代际给出的。\n观测异常：$o = [0.12, -0.08, 0.05, 0.10, -0.02, 0.03, 0.07, -0.01]$。\n预测异常：$f = [0.10, -0.05, 0.00, 0.12, 0.00, 0.02, 0.06, -0.02]$。\n参考气候学：对所有 $i$ 都有 $c_i = 0$。\n\n我们将使用 $c_i=0$ 的简化公式。\n首先，我们计算分母 $\\sum_{i=1}^{8} o_i^2$：\n$$\n\\sum_{i=1}^{8} o_i^2 = (0.12)^2 + (-0.08)^2 + (0.05)^2 + (0.10)^2 + (-0.02)^2 + (0.03)^2 + (0.07)^2 + (-0.01)^2\n$$\n$$\n\\sum_{i=1}^{8} o_i^2 = 0.0144 + 0.0064 + 0.0025 + 0.0100 + 0.0004 + 0.0009 + 0.0049 + 0.0001 = 0.0396\n$$\n接下来，我们计算分子中的两项。\n第一项是 $2\\sum_{i=1}^{8} f_i o_i$：\n$$\n\\sum_{i=1}^{8} f_i o_i = (0.10)(0.12) + (-0.05)(-0.08) + (0.00)(0.05) + (0.12)(0.10) + (0.00)(-0.02) + (0.02)(0.03) + (0.06)(0.07) + (-0.02)(-0.01)\n$$\n$$\n\\sum_{i=1}^{8} f_i o_i = 0.0120 + 0.0040 + 0 + 0.0120 + 0 + 0.0006 + 0.0042 + 0.0002 = 0.0330\n$$\n所以，$2\\sum_{i=1}^{8} f_i o_i = 2 \\times 0.0330 = 0.0660$。\n\n第二项是 $\\sum_{i=1}^{8} f_i^2$：\n$$\n\\sum_{i=1}^{8} f_i^2 = (0.10)^2 + (-0.05)^2 + (0.00)^2 + (0.12)^2 + (0.00)^2 + (0.02)^2 + (0.06)^2 + (-0.02)^2\n$$\n$$\n\\sum_{i=1}^{8} f_i^2 = 0.0100 + 0.0025 + 0 + 0.0144 + 0 + 0.0004 + 0.0036 + 0.0004 = 0.0313\n$$\n现在，组合MSSS：\n$$\nMSSS = \\frac{2\\sum f_i o_i - \\sum f_i^2}{\\sum o_i^2} = \\frac{0.0660 - 0.0313}{0.0396} = \\frac{0.0347}{0.0396}\n$$\n$$\nMSSS \\approx 0.87626262...\n$$\n四舍五入到四位有效数字，结果是 $0.8763$。\n\n**第3部分：参考气候学作用的解释**\n\n参考预测 $c_i$ 的选择是解释像MSSS这样的技巧评分的关键方面，因为它定义了衡量技巧的基线。MSSS值为0意味着预测的表现不优于此基线。\n\n1.  **固定基线气候学（$c_i = 0$ 或 $c_i = \\text{常数}$）：** 这种参考通常简称为“气候学”，它假设未来状态将是长期平均值，意味着零异常。该参考的均方误差 $MSE_c = \\frac{1}{n} \\sum (o_i - 0)^2$ 是均方异常，与观测时间序列的方差密切相关。如果一个预测平均而言比零猜测更接近观测异常，那么它相对于该参考就会获得正的技巧评分（$MSSS > 0$）。在年代际预测的背景下，气候系统表现出强迫趋势（例如，由于人为变暖）和低频内部变率。固定基线是技巧的一个“低门槛”，因为任何仅捕捉长期变暖趋势的预测都将轻易胜过假设没有变化的参考。相对于固定基线的高MSSS可能主要反映了模型再现强迫气候响应的能力，而不一定是其预测更具混沌性的内部年代际波动的能力。\n\n2.  **随时间演变的气候学（例如，包含趋势）：** 这是一个更复杂、更严格的参考。例如，$c_i$ 可以由拟合过去观测的线性趋势定义，如 $c_i = a \\cdot t_i + b$。这种参考预测假设未来将遵循最近观测到的趋势。年代际预测的目标不仅是捕捉这种强迫趋势，还要预测*偏离趋势的部分*，这些偏差是由气候系统的初始状态（例如，初始海洋热含量）及其内部动力学（例如，像大西洋多年代际振荡这样的模态）驱动的。要相对于基于趋势的参考获得正的技巧评分，预测系统（$f_i$）必须提供比单独的趋势外推更准确的完整异常预测。这意味着它必须在预测年代际尺度内部气候变率的时间和幅度方面具有更高的技巧。",
            "answer": "$$\\boxed{0.8763}$$"
        },
        {
            "introduction": "气候模型的原始输出往往包含需要校正的系统性误差，即偏差。这个实践性的编程练习将向你展示如何实施偏差校正，同时通过使用稳健的交叉验证方法，来避免因信息泄露而导致“技巧虚高”的常见陷阱 。这项技能对于从模式后处理中获得可靠的预报产品至关重要。",
            "id": "4030499",
            "problem": "给定一个全球平均气候指数的确定性年代际后报异常值和相应的观测异常值。将预报偏差视为预报与观测之间的期望差异。从数值天气预报和气候模拟领域的核心统计定义出发，构建一个程序，该程序使用留一法（LOO）后报计算交叉验证的偏差校正，并量化其与样本内校正相比对技巧膨胀的影响。使用具有物理意义的单位进行计算。\n\n基本原理：\n- 将年份索引为 $t$ 的预报定义为 $f_t$，观测定义为 $y_t$，其中 $t \\in \\{1, \\dots, N\\}$。\n- 将预报误差 $e_t$ 定义为 $e_t = f_t - y_t$。\n- 将恒定偏差 $\\beta$ 定义为期望值 $\\beta = \\mathbb{E}[e_t]$。\n- 使用样本均值从 $N$ 年的集合中估计偏差：$\\hat{\\beta} = \\frac{1}{N}\\sum_{t=1}^{N} e_t$。\n- 在留一法交叉验证中，对每个目标年份 $t$，使用所有其他年份来估计偏差：$\\hat{\\beta}_{-t} = \\frac{1}{N-1}\\sum_{s \\neq t} e_s$。\n\n技巧量化：\n- 将年份 $t$ 的样本内偏差校正后的预报定义为 $\\tilde{f}_t^{\\text{in}} = f_t - \\hat{\\beta}$。\n- 将年份 $t$ 的交叉验证偏差校正后的预报定义为 $\\tilde{f}_t^{\\text{cv}} = f_t - \\hat{\\beta}_{-t}$。\n- 将均方误差（MSE）定义为 $\\mathrm{MSE} = \\frac{1}{N}\\sum_{t=1}^{N} (\\tilde{f}_t - y_t)^2$，其中 $\\tilde{f}_t$ 是评估中使用的校正后预报。\n- 将技巧膨胀（正值表示样本内校正看起来人为地更好）定义为差值 $\\Delta = \\mathrm{MSE}_{\\text{cv}} - \\mathrm{MSE}_{\\text{in}}$。\n\n单位和数值要求：\n- 所有异常值均以开尔文（$\\mathrm{K}$）为单位。您必须以平方开尔文（$\\mathrm{K}^2$）为单位计算并报告技巧膨胀 $\\Delta$。返回原始小数值。\n- 不涉及角度。\n- 最终输出必须将整个测试套件的结果汇总为一行：一个用方括号括起来的逗号分隔列表，例如 $[x_1, x_2, x_3]$。\n\n测试套件：\n对于以下每种情况，将所提供的序列视为完整的 $N$ 年后报-观测对。按规定计算 $\\Delta$ 并按顺序返回四个结果。\n\n1. 理想路径，中等样本量 $N = 10$，具有近似恒定的正偏差：\n   - 观测值 $y^{(1)}$: $[0.10, 0.20, 0.00, -0.10, 0.30, 0.40, 0.20, 0.00, -0.20, 0.10]$ $\\mathrm{K}$\n   - 后报值 $f^{(1)}$: $[0.42, 0.49, 0.31, 0.20, 0.58, 0.73, 0.49, 0.32, 0.07, 0.40]$ $\\mathrm{K}$\n\n2. 边界情况，极小样本量 $N = 3$：\n   - 观测值 $y^{(2)}$: $[0.00, 0.40, -0.20]$ $\\mathrm{K}$\n   - 后报值 $f^{(2)}$: $[0.70, 0.80, 0.20]$ $\\mathrm{K}$\n\n3. 边缘情况，完美预报 $N = 8$：\n   - 观测值 $y^{(3)}$: $[0.05, -0.05, 0.10, -0.10, 0.00, 0.02, -0.03, 0.04]$ $\\mathrm{K}$\n   - 后报值 $f^{(3)}$: $[0.05, -0.05, 0.10, -0.10, 0.00, 0.02, -0.03, 0.04]$ $\\mathrm{K}$\n\n4. 趋势不匹配，具有时变偏差 $N = 10$：\n   - 观测值 $y^{(4)}$: $[0.00, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50]$ $\\mathrm{K}$\n   - 后报值 $f^{(4)}$: $[0.20, 0.33, 0.46, 0.55, 0.64, 0.77, 0.83, 0.96, 1.04, 1.15]$ $\\mathrm{K}$\n\n实现要求：\n- 对每种情况，计算样本内偏差 $\\hat{\\beta}$、样本内校正后的预报 $\\tilde{f}_t^{\\text{in}}$ 和 $\\mathrm{MSE}_{\\text{in}}$。\n- 对每种情况，为每个 $t$ 计算 LOO 偏差 $\\hat{\\beta}_{-t}$、LOO 校正后的预报 $\\tilde{f}_t^{\\text{cv}}$ 和 $\\mathrm{MSE}_{\\text{cv}}$。\n- 对每种情况，以 $\\mathrm{K}^2$ 为单位计算技巧膨胀 $\\Delta = \\mathrm{MSE}_{\\text{cv}} - \\mathrm{MSE}_{\\text{in}}$，并收集四个 $\\Delta$ 值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$）作为结果，其中每个 $x_i$ 是一个以 $\\mathrm{K}^2$ 为单位的小数。\n\n数据是固定的和自包含的。您的实现必须是确定性的和自包含的，仅使用标准数值例程，无需外部输入或文件。留一法（LOO）和均方误差（MSE）必须直接根据上述定义实现。",
            "solution": "我们从适用于年代际气候后报评估的基本定义开始。年份索引为 $t$ 的预报是 $f_t$，观测是 $y_t$。预报误差是 $e_t = f_t - y_t$。偏差是误差的期望值，$\\beta = \\mathbb{E}[e_t]$，一个基于 $N$ 个样本的标准、广为接受的估计量是样本均值 $\\hat{\\beta} = \\frac{1}{N}\\sum_{t=1}^{N} e_t$。\n\n偏差校正对预报应用一个恒定的平移来消除平均误差。对于样本内校正，偏差校正后的预报为 $\\tilde{f}_t^{\\text{in}} = f_t - \\hat{\\beta}$（对每个 $t$）。在样本内校正下的均方误差（MSE）是\n$$\n\\mathrm{MSE}_{\\text{in}} = \\frac{1}{N}\\sum_{t=1}^{N} (\\tilde{f}_t^{\\text{in}} - y_t)^2 \n= \\frac{1}{N}\\sum_{t=1}^{N} (f_t - \\hat{\\beta} - y_t)^2 \n= \\frac{1}{N}\\sum_{t=1}^{N} (e_t - \\hat{\\beta})^2.\n$$\n\n为避免因在训练集中重复使用验证目标而导致的技巧膨胀，留一法（LOO）交叉验证为每个目标年份 $t$ 使用所有其他年份来估计偏差：\n$$\n\\hat{\\beta}_{-t} = \\frac{1}{N-1}\\sum_{s \\neq t} e_s.\n$$\n年份 $t$ 的 LOO 校正预报为 $\\tilde{f}_t^{\\text{cv}} = f_t - \\hat{\\beta}_{-t}$，相应的均方误差为\n$$\n\\mathrm{MSE}_{\\text{cv}} = \\frac{1}{N}\\sum_{t=1}^{N} (\\tilde{f}_t^{\\text{cv}} - y_t)^2 \n= \\frac{1}{N}\\sum_{t=1}^{N} (e_t - \\hat{\\beta}_{-t})^2.\n$$\n\n我们现在联系这些定义来量化技巧膨胀。将样本内平均误差表示为 $m = \\hat{\\beta} = \\frac{1}{N}\\sum_{t=1}^{N} e_t$。通过对 LOO 均值进行代数操作，注意到所有误差的总和为 $N m$，我们得到\n$$\n\\hat{\\beta}_{-t} = \\frac{N m - e_t}{N-1}.\n$$\n因此，\n$$\ne_t - \\hat{\\beta}_{-t} \n= e_t - \\frac{N m - e_t}{N-1} \n= \\frac{N(e_t - m)}{N-1}.\n$$\n对 $t$ 求平方并取平均值，得到精确的恒等式\n$$\n\\mathrm{MSE}_{\\text{cv}} \n= \\frac{1}{N}\\sum_{t=1}^{N} \\left( \\frac{N(e_t - m)}{N-1} \\right)^2\n= \\left( \\frac{N}{N-1} \\right)^2 \\cdot \\frac{1}{N} \\sum_{t=1}^{N} (e_t - m)^2\n= \\left( \\frac{N}{N-1} \\right)^2 \\mathrm{MSE}_{\\text{in}}.\n$$\n这表明对于恒定偏差校正，当 $N > 1$ 时，交叉验证的 MSE 比样本内的 MSE 大一个乘法因子 $\\left( \\frac{N}{N-1} \\right)^2 > 1$。技巧膨胀定义为差值\n$$\n\\Delta = \\mathrm{MSE}_{\\text{cv}} - \\mathrm{MSE}_{\\text{in}},\n$$\n即\n$$\n\\Delta = \\mathrm{MSE}_{\\text{in}} \\left[ \\left( \\frac{N}{N-1} \\right)^2 - 1 \\right].\n$$\n对于 $N > 1$ 时，该值严格为正，表明样本内偏差校正是乐观偏差的，这是由于信息重复使用导致技巧膨胀的典型表现。\n\n算法实现：\n- 对每种情况，构建 $f_t$ 和 $y_t$ 的数组（单位为 $\\mathrm{K}$）。\n- 计算误差 $e_t = f_t - y_t$。\n- 计算 $\\hat{\\beta} = \\frac{1}{N}\\sum e_t$ 并构建 $\\tilde{f}_t^{\\text{in}} = f_t - \\hat{\\beta}$。\n- 计算 $\\mathrm{MSE}_{\\text{in}} = \\frac{1}{N}\\sum (\\tilde{f}_t^{\\text{in}} - y_t)^2 = \\frac{1}{N}\\sum (e_t - \\hat{\\beta})^2$。\n- 对于 LOO，对每个 $t$，计算 $\\hat{\\beta}_{-t} = \\frac{1}{N-1}\\sum_{s \\neq t} e_s$ 和 $\\tilde{f}_t^{\\text{cv}} = f_t - \\hat{\\beta}_{-t}$，然后计算 $\\mathrm{MSE}_{\\text{cv}} = \\frac{1}{N}\\sum ( \\tilde{f}_t^{\\text{cv}} - y_t )^2$。\n- 计算并返回每种情况的 $\\Delta$（单位为 $\\mathrm{K}^2$）。\n- 将四个 $\\Delta$ 值汇总成指定的带括号、逗号分隔格式的单行输出。\n\n测试套件涵盖：\n- 具有轻微偏差的典型年代际后报（情况 1）。\n- 交叉验证不稳定性最明显的极小样本（情况 2）。\n- 用于验证零膨胀的完美模型情况（情况 3）。\n- 用于测试推导普适性的趋势不匹配和时变偏差情况（情况 4）。\n\n所有数值结果的量纲均为 $\\mathrm{K}^2$，符合要求，并且计算严格遵守定义的程序，不使用问题陈述中的快捷公式。该代码直接根据定义评估 MSE。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_inflation(y, f):\n    \"\"\"\n    Compute skill inflation (MSE_cv - MSE_in) in K^2 using\n    in-sample constant bias correction and leave-one-out cross-validated bias correction.\n    \"\"\"\n    y = np.asarray(y, dtype=float)\n    f = np.asarray(f, dtype=float)\n    assert y.shape == f.shape, \"Observation and forecast arrays must have the same shape.\"\n    n = y.size\n    # Errors\n    e = f - y\n    # In-sample bias estimate and corrected forecasts\n    beta_in = np.mean(e)\n    f_corr_in = f - beta_in\n    mse_in = np.mean((f_corr_in - y) ** 2)\n    # Leave-one-out bias correction per element\n    f_corr_cv = np.empty_like(f_corr_in)\n    # Precompute sum of errors for efficiency\n    sum_e = np.sum(e)\n    for t in range(n):\n        # Leave-one-out mean of errors\n        beta_loo_t = (sum_e - e[t]) / (n - 1) if n  1 else beta_in\n        f_corr_cv[t] = f[t] - beta_loo_t\n    mse_cv = np.mean((f_corr_cv - y) ** 2)\n    # Skill inflation: positive means in-sample appears better\n    inflation = mse_cv - mse_in\n    return float(inflation)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: Happy path, moderate sample size N=10 with approximately constant positive bias\n    y1 = [0.10, 0.20, 0.00, -0.10, 0.30, 0.40, 0.20, 0.00, -0.20, 0.10]\n    f1 = [0.42, 0.49, 0.31, 0.20, 0.58, 0.73, 0.49, 0.32, 0.07, 0.40]\n\n    # Case 2: Boundary case, very small sample N=3\n    y2 = [0.00, 0.40, -0.20]\n    f2 = [0.70, 0.80, 0.20]\n\n    # Case 3: Edge case, perfect forecasts N=8\n    y3 = [0.05, -0.05, 0.10, -0.10, 0.00, 0.02, -0.03, 0.04]\n    f3 = [0.05, -0.05, 0.10, -0.10, 0.00, 0.02, -0.03, 0.04]\n\n    # Case 4: Trend mismatch with time-varying bias N=10\n    y4 = [0.00, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50]\n    f4 = [0.20, 0.33, 0.46, 0.55, 0.64, 0.77, 0.83, 0.96, 1.04, 1.15]\n\n    test_cases = [\n        (y1, f1),\n        (y2, f2),\n        (y3, f3),\n        (y4, f4),\n    ]\n\n    results = []\n    for y, f in test_cases:\n        result = compute_inflation(y, f)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}