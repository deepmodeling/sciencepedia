{
    "hands_on_practices": [
        {
            "introduction": "虽然小的初始误差最初会呈指数增长，但在像大气这样的有界系统中，这种增长不可能无限持续。本练习引入了一个简单而强大的分析模型——逻辑斯谛曲线——来描述误差增长的整个生命周期，从最初的指数阶段到最终的非线性饱和。掌握这个模型为理解可预报性极限提供了一个关键的概念框架 。",
            "id": "4077561",
            "problem": "在数值天气预报 (NWP) 和气候模拟中，混沌流中初始条件微小扰动的增长，在切线性机制下可以很好地通过由最大李雅普诺夫指数 $\\lambda$ 控制的指数放大来描述，因此对于足够小的扰动，误差范数 $\\|\\delta x(t)\\|$ 的初始行为类似于 $\\|\\delta x(0)\\|\\exp(\\lambda t)$。有限振幅效应和大气有限的背景变率限制了这种增长，导致在由气候变率设定的特征振幅处发生非线性饱和。考虑一个状态向量 $x(t)$ 和一个误差范数 $\\|\\delta x(t)\\|$，对于所有 $t \\geq 0$，它由饱和S形曲线建模\n$$\n\\|\\delta x(t)\\|=\\frac{A\\,\\exp(\\lambda t)}{1+B\\,\\exp(\\lambda t)},\n$$\n其中 $A>0$ 和 $B>0$ 是待定参数。设初始误差大小为 $\\|\\delta x(0)\\|=\\delta_{0}$，其中 $\\delta_{0}>0$，并设背景变率尺度为 $S>0$，定义为误差范数的渐近饱和水平，与感兴趣的时空尺度上 $\\|x\\|$ 的气候均方根振幅一致。假设 $\\delta_{0}  S$，推导出参数 $A$ 和 $B$ 的表达式，并求出误差范数达到其饱和水平 $S$ 的一个比例 $p \\in (0,1)$ 时所需的时间 $t_p$（以天为单位）。",
            "solution": "该问题陈述是大气科学和混沌动力学领域中一个有效的、适定的问题。它要求确定一个逻辑斯谛增长模型的参数，并随后应用该模型。\n\n误差范数 $\\|\\delta x(t)\\|$ 的增长由以下函数建模：\n$$ \\|\\delta x(t)\\|=\\frac{A\\,\\exp(\\lambda t)}{1+B\\,\\exp(\\lambda t)} $$\n其中 $t \\geq 0$，且 $A$、$B$、$\\lambda$ 是正常数。\n\n给定两个条件来确定参数 $A$ 和 $B$：\n1. $t=0$ 时的初始误差为 $\\|\\delta x(0)\\| = \\delta_{0}$。\n2. 当 $t \\to \\infty$ 时，渐近饱和水平为 $S$，因此 $\\lim_{t\\to\\infty} \\|\\delta x(t)\\| = S$。\n\n首先，我们应用 $t=0$ 时的初始条件：\n$$ \\|\\delta x(0)\\| = \\frac{A\\,\\exp(\\lambda \\cdot 0)}{1+B\\,\\exp(\\lambda \\cdot 0)} = \\frac{A \\cdot 1}{1+B \\cdot 1} = \\frac{A}{1+B} $$\n令其等于 $\\delta_{0}$，我们得到第一个方程：\n$$ \\delta_{0} = \\frac{A}{1+B} \\quad (1) $$\n\n接下来，我们通过计算 $t \\to \\infty$ 时的极限来应用饱和条件。由于 $\\lambda > 0$，当 $t \\to \\infty$ 时，$\\exp(\\lambda t) \\to \\infty$。为了计算这个有理表达式的极限，我们将分子和分母同时除以 $\\exp(\\lambda t)$：\n$$ S = \\lim_{t\\to\\infty} \\|\\delta x(t)\\| = \\lim_{t\\to\\infty} \\frac{A\\,\\exp(\\lambda t)}{1+B\\,\\exp(\\lambda t)} = \\lim_{t\\to\\infty} \\frac{A}{\\frac{1}{\\exp(\\lambda t)}+B} $$\n当 $t \\to \\infty$ 时，$\\exp(-\\lambda t) = \\frac{1}{\\exp(\\lambda t)} \\to 0$。因此，极限为：\n$$ S = \\frac{A}{0+B} = \\frac{A}{B} \\quad (2) $$\n\n现在我们有一个包含两个未知数 $A$ 和 $B$ 的方程组：\n1. $\\delta_{0}(1+B) = A$\n2. $A = SB$\n\n将方程 $(2)$ 中 $A$ 的表达式代入方程 $(1)$：\n$$ \\delta_{0} = \\frac{SB}{1+B} $$\n现在，我们求解 $B$。题目说明 $\\delta_{0}  S$。\n$$ \\delta_{0}(1+B) = SB $$\n$$ \\delta_{0} + \\delta_{0}B = SB $$\n$$ \\delta_{0} = SB - \\delta_{0}B $$\n$$ \\delta_{0} = B(S - \\delta_{0}) $$\n由于 $S > \\delta_{0}$，因此 $S - \\delta_{0} > 0$，所以我们可以通过除法求得 $B$：\n$$ B = \\frac{\\delta_{0}}{S - \\delta_{0}} $$\n现在我们可以用方程 $(2)$，$A = SB$，来求 $A$：\n$$ A = S \\left( \\frac{\\delta_{0}}{S - \\delta_{0}} \\right) = \\frac{S\\delta_{0}}{S - \\delta_{0}} $$\n题目说明 $A>0$ 且 $B>0$。由于 $S>0$，$\\delta_{0}>0$ 且 $S>\\delta_{0}$，两个分母都为正，因此 $A$ 和 $B$ 确实为正。\n\n在确定了 $A$ 和 $B$ 之后，误差范数的模型变为：\n$$ \\|\\delta x(t)\\| = \\frac{\\frac{S\\delta_{0}}{S - \\delta_{0}}\\exp(\\lambda t)}{1+\\frac{\\delta_{0}}{S - \\delta_{0}}\\exp(\\lambda t)} $$\n分子和分母同时乘以 $(S-\\delta_{0})$ 可以简化表达式：\n$$ \\|\\delta x(t)\\| = \\frac{S\\delta_{0}\\exp(\\lambda t)}{(S - \\delta_{0}) + \\delta_{0}\\exp(\\lambda t)} $$\n\n任务的第二部分是求出误差范数达到饱和水平 $S$ 的一个比例 $p \\in (0,1)$ 时的时间 $t_{p}$。我们设 $\\|\\delta x(t_{p})\\| = pS$：\n$$ pS = \\frac{S\\delta_{0}\\exp(\\lambda t_{p})}{(S - \\delta_{0}) + \\delta_{0}\\exp(\\lambda t_{p})} $$\n由于 $S > 0$，我们可以将两边同时除以 $S$：\n$$ p = \\frac{\\delta_{0}\\exp(\\lambda t_{p})}{(S - \\delta_{0}) + \\delta_{0}\\exp(\\lambda t_{p})} $$\n现在我们求解 $t_{p}$。首先，我们分离出 $\\exp(\\lambda t_{p})$ 项：\n$$ p((S - \\delta_{0}) + \\delta_{0}\\exp(\\lambda t_{p})) = \\delta_{0}\\exp(\\lambda t_{p}) $$\n$$ p(S - \\delta_{0}) + p\\delta_{0}\\exp(\\lambda t_{p}) = \\delta_{0}\\exp(\\lambda t_{p}) $$\n$$ p(S - \\delta_{0}) = \\delta_{0}\\exp(\\lambda t_{p}) - p\\delta_{0}\\exp(\\lambda t_{p}) $$\n$$ p(S - \\delta_{0}) = (1-p)\\delta_{0}\\exp(\\lambda t_{p}) $$\n现在，我们可以解出 $\\exp(\\lambda t_{p})$：\n$$ \\exp(\\lambda t_{p}) = \\frac{p(S - \\delta_{0})}{(1-p)\\delta_{0}} $$\n为了求 $t_{p}$，我们对两边取自然对数。由于 $p \\in (0,1)$、$S>\\delta_{0}$ 且 $\\delta_{0}>0$，对数的参数为正。\n$$ \\lambda t_{p} = \\ln\\left(\\frac{p(S - \\delta_{0})}{\\delta_{0}(1-p)}\\right) $$\n最后，除以 $\\lambda$（因为 $\\lambda>0$）得到 $t_{p}$ 的表达式：\n$$ t_{p} = \\frac{1}{\\lambda}\\ln\\left(\\frac{p(S - \\delta_{0})}{\\delta_{0}(1-p)}\\right) $$\n题目要求以天为单位表示 $t_{p}$。这是一个关于单位的说明。如果最大李雅普诺夫指数 $\\lambda$ 的单位是 天$^{-1}$，那么上述 $t_{p}$ 的公式将得出以天为单位的结果。\n\n推导出的 $A$、$B$ 和 $t_{p}$ 的表达式为：\n- $A=\\frac{S\\delta_{0}}{S - \\delta_{0}}$\n- $B=\\frac{\\delta_{0}}{S - \\delta_{0}}$\n- $t_{p}=\\frac{1}{\\lambda}\\ln\\left(\\frac{p(S - \\delta_{0})}{\\delta_{0}(1-p)}\\right)$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{S\\delta_{0}}{S - \\delta_{0}}  \\frac{\\delta_{0}}{S - \\delta_{0}}  \\frac{1}{\\lambda}\\ln\\left(\\frac{p(S - \\delta_{0})}{\\delta_{0}(1-p)}\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在误差增长的概念模型之上，我们现在转向一个实际的计算任务：量化一个真实混沌系统中这种增长的速率。由李雅普诺夫指数表示的增长率并非一个常数，而是随系统状态而变化。本实践将指导您完成经典 Lorenz '63 模型的有限时间李雅普诺夫指数 (FTLE) 的数值计算，为您提供评估任何动力系统中可预报性的核心技能 。",
            "id": "4077615",
            "problem": "考虑一个由常微分方程（ODE）$\\,\\dot{\\boldsymbol{x}} = \\boldsymbol{f}(\\boldsymbol{x})\\,$ 定义的连续时间动力系统，其中 $\\boldsymbol{x}(t) \\in \\mathbb{R}^3$。沿轨迹 $\\boldsymbol{x}(t)$ 在有限时间 $T>0$ 上的有限时间李雅普诺夫指数（FTLE）是为扰动 $\\delta \\boldsymbol{x}(t)$ 定义的，该扰动根据变分（切线线性）方程演化，其定义如下\n$$\n\\lambda_T = \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\boldsymbol{x}(T)\\|}{\\|\\delta \\boldsymbol{x}(0)\\|}\\right).\n$$\n扰动 $\\delta \\boldsymbol{x}(t)$ 满足线性化动力学\n$$\n\\frac{d}{dt}\\,\\delta \\boldsymbol{x}(t) = \\mathbf{J}(\\boldsymbol{x}(t))\\,\\delta \\boldsymbol{x}(t),\n$$\n其中 $\\mathbf{J}(\\boldsymbol{x}) = \\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{x}}$ 是 $\\boldsymbol{f}$ 的雅可比矩阵，沿参考轨迹 $\\boldsymbol{x}(t)$ 求值。设 $\\mathbf{\\Phi}(t)$ 表示满足 $\\dot{\\mathbf{\\Phi}}(t)=\\mathbf{J}(\\boldsymbol{x}(t))\\,\\mathbf{\\Phi}(t)$ 和 $\\mathbf{\\Phi}(0)=\\mathbf{I}$ 的变分方程的基本矩阵解。则 $\\delta \\boldsymbol{x}(T) = \\mathbf{\\Phi}(T)\\,\\delta \\boldsymbol{x}(0)$。\n\n在本问题中，基流是 Lorenz '63 模型：\n- $\\,\\dot{x} = \\sigma(y-x)$,\n- $\\,\\dot{y} = x(\\rho - z) - y$,\n- $\\,\\dot{z} = xy - \\beta z$,\n使用标准参数 $\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$。基准轨迹的初始条件是 $\\boldsymbol{x}(0)=(1,1,1)$，时间范围是 $T=5$，除非另有说明。Lorenz '63 的雅可比矩阵 $\\mathbf{J}(\\boldsymbol{x})$ 为\n$$\n\\mathbf{J}(x,y,z) =\n\\begin{bmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{bmatrix}.\n$$\n\n您的任务是使用变分方程计算有限时间李雅普诺夫指数 $\\lambda_T$，方法是数值积分 $(\\boldsymbol{x}(t), \\mathbf{\\Phi}(t))$ 的增广系统，然后应用 $\\lambda_T$ 的定义。范数 $\\|\\cdot\\|$ 将是以下之一：\n- $p=2$ 欧几里得范数：$\\|\\boldsymbol{v}\\|_2 = \\sqrt{v_1^2 + v_2^2 + v_3^2}$。\n- $p=1$ 曼哈顿范数：$\\|\\boldsymbol{v}\\|_1 = |v_1| + |v_2| + |v_3|$。\n- $p=\\infty$ 最大范数：$\\|\\boldsymbol{v}\\|_\\infty = \\max(|v_1|,|v_2|,|v_3|)$。\n\n使用以下测试用例集，每个用例指定了扰动向量 $\\delta \\boldsymbol{x}(0)$、时间范围 $T$ 和范数类型：\n1. 用例 A（理想情况）：$\\delta \\boldsymbol{x}(0) = [1\\times 10^{-6},\\,0,\\,0]$，$T = 5$，范数 $p=2$。\n2. 用例 B（尺度不变性检验）：$\\delta \\boldsymbol{x}(0) = [1\\times 10^{-8},\\,0,\\,0]$，$T = 5$，范数 $p=2$。\n3. 用例 C（范数敏感性）：$\\delta \\boldsymbol{x}(0) = [0,\\,1\\times 10^{-6},\\,0]$，$T = 5$，范数 $p=1$。\n4. 用例 D（范数敏感性）：$\\delta \\boldsymbol{x}(0) = [0,\\,0,\\,1\\times 10^{-6}]$，$T = 5$，范数 $p=\\infty$。\n5. 用例 E（短时行为）：$\\delta \\boldsymbol{x}(0) = [1\\times 10^{-6},\\,1\\times 10^{-6},\\,1\\times 10^{-6}]$，$T = 0.5$，范数 $p=2$。\n\n要求和约束：\n- 所有用例的基准轨迹都从 $\\boldsymbol{x}(0)=(1,1,1)$ 开始。\n- 对 $(\\boldsymbol{x}(t), \\mathbf{\\Phi}(t))$ 的增广系统（其中 $\\mathbf{\\Phi}(0)=\\mathbf{I}$）进行积分，然后计算 $\\delta \\boldsymbol{x}(T)=\\mathbf{\\Phi}(T)\\delta \\boldsymbol{x}(0)$，并使用每个用例指定的范数来评估 $\\lambda_T$。\n- 确保在所有计算中 $T>0$。\n- 所有输出都是无量纲的。将最终数值结果表示为四舍五入到六位小数的浮点数。\n- 您的程序应生成单行输出，其中包含用例 A–E 的结果，按顺序排列，格式为方括号内以逗号分隔的列表（例如，“[resultA,resultB,resultC,resultD,resultE]”）。\n\n交付成果：\n- 一个完整、可运行的程序，该程序对指定的用例执行 Lorenz '63 系统及其变分方程的数值积分，并返回所要求的 FTLE 值，同时遵循上面指定的最终输出格式。",
            "solution": "该问题要求为 Lorenz '63 系统的几个测试用例计算有限时间李雅普诺夫指数（FTLE）。FTLE，记作 $\\lambda_T$，量化了在有限时间间隔 $T  0$ 内无限近的轨迹的平均指数发散率。其定义为：\n$$\n\\lambda_T = \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\boldsymbol{x}(T)\\|}{\\|\\delta \\boldsymbol{x}(0)\\|}\\right)\n$$\n其中 $\\delta \\boldsymbol{x}(t)$ 是一个无穷小扰动向量，其演化由系统的线性化动力学控制。\n\n该方法的核心是求解一个常微分方程（ODE）的增广系统。该系统结合了用于状态向量 $\\boldsymbol{x}(t) = [x(t), y(t), z(t)]^T \\in \\mathbb{R}^3$ 的原始非线性 Lorenz '63 方程和控制基本矩阵解 $\\mathbf{\\Phi}(t) \\in \\mathbb{R}^{3 \\times 3}$ 演化的变分方程。基本矩阵通过 $\\delta\\boldsymbol{x}(T) = \\mathbf{\\Phi}(T)\\delta\\boldsymbol{x}(0)$ 将初始扰动映射到最终扰动。\n\n增广系统的状态是一个 12 维向量 $\\boldsymbol{Y}(t)$，通过连接 Lorenz 状态向量 $\\boldsymbol{x}(t)$ 和向量化的基本矩阵 $\\mathbf{\\Phi}(t)$ 构建：\n$$\n\\boldsymbol{Y}(t) = [\\boldsymbol{x}(t)^T, (\\text{vec}(\\mathbf{\\Phi}(t)))^T]^T \\in \\mathbb{R}^{12}\n$$\n该增广系统的控制 ODE 为 $\\dot{\\boldsymbol{Y}}(t) = \\boldsymbol{F}(\\boldsymbol{Y}(t))$，可分解为两部分：\n$1$. Lorenz '63 方程：\n$$\n\\dot{\\boldsymbol{x}} = \\boldsymbol{f}(\\boldsymbol{x}) =\n\\begin{pmatrix}\n\\sigma(y-x) \\\\\nx(\\rho - z) - y \\\\\nxy - \\beta z\n\\end{pmatrix}\n$$\n参数为 $\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$。\n$2$. 基本矩阵的变分方程：\n$$\n\\dot{\\mathbf{\\Phi}}(t) = \\mathbf{J}(\\boldsymbol{x}(t))\\,\\mathbf{\\Phi}(t)\n$$\n其中 $\\mathbf{J}(\\boldsymbol{x})$ 是 $\\boldsymbol{f}(\\boldsymbol{x})$ 的雅可比矩阵，沿轨迹 $\\boldsymbol{x}(t)$ 求值：\n$$\n\\mathbf{J}(x,y,z) =\n\\begin{bmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{bmatrix}\n$$\n此增广系统的初始条件是 $\\boldsymbol{x}(0) = (1,1,1)$ 和 $\\mathbf{\\Phi}(0) = \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵。\n\n每个测试用例的计算过程如下：\n$1$. 为 12 维增广系统构建初始状态向量 $\\boldsymbol{Y}(0)$。\n$2$. 使用高精度求解器（如 `scipy.integrate.solve_ivp`）对这 12 个 ODE 组成的系统从 $t=0$ 积分到指定的最终时间 $T$。\n$3$. 从最终状态 $\\boldsymbol{Y}(T)$ 中提取 $3 \\times 3$ 的基本矩阵 $\\mathbf{\\Phi}(T)$。\n$4$. 对于给定的初始扰动 $\\delta\\boldsymbol{x}(0)$，计算最终扰动 $\\delta\\boldsymbol{x}(T) = \\mathbf{\\Phi}(T)\\delta\\boldsymbol{x}(0)$。\n$5$. 使用用例指定的范数（$p=1$、$p=2$ 或 $p=\\infty$）计算初始扰动范数 $\\|\\delta\\boldsymbol{x}(0)\\|$ 和最终扰动范数 $\\|\\delta\\boldsymbol{x}(T)\\|$。\n$6$. 使用其定义计算 FTLE $\\lambda_T$。\n\n从线性变分方程导出的 FTLE 的一个关键特性是，其结果与初始扰动的幅度无关，仅与其方向有关。这是因为范数是齐次的，即 $\\|c\\boldsymbol{v}\\| = |c|\\|\\boldsymbol{v}\\|$，并且项 $|c|$ 在对数内的比率中被消掉。因此，用例 A 和用例 B 预计将产生相同的结果，从而为数值实现提供了验证。其他用例测试了对初始扰动方向和范数选择的敏感性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes the finite-time Lyapunov exponent (FTLE) for the Lorenz '63 system\n    for a suite of test cases.\n    \"\"\"\n\n    def lorenz_augmented_rhs(t, state, sigma, rho, beta):\n        \"\"\"\n        Computes the time derivative of the augmented state vector, which includes\n        the Lorenz '63 state and the fundamental matrix.\n        \n        Args:\n            t (float): Current time (unused, as the system is autonomous).\n            state (np.ndarray): 12-element array [x, y, z, phi_11, ..., phi_33].\n            sigma (float): Lorenz parameter sigma.\n            rho (float): Lorenz parameter rho.\n            beta (float): Lorenz parameter beta.\n\n        Returns:\n            np.ndarray: The 12-element time derivative of the state vector.\n        \"\"\"\n        x, y, z = state[:3]\n        phi = state[3:].reshape((3, 3))\n\n        # Lorenz '63 equations\n        dxdt = sigma * (y - x)\n        dydt = x * (rho - z) - y\n        dzdt = x * y - beta * z\n        \n        lorenz_derivs = np.array([dxdt, dydt, dzdt])\n\n        # Jacobian matrix\n        J = np.array([\n            [-sigma, sigma, 0],\n            [rho - z, -1, -x],\n            [y, x, -beta]\n        ])\n\n        # Variational equations for the fundamental matrix\n        dphi_dt = J @ phi\n\n        # Concatenate derivatives into a single state derivative vector\n        d_state_dt = np.concatenate((lorenz_derivs, dphi_dt.flatten()))\n        \n        return d_state_dt\n\n    # Lorenz '63 parameters\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n\n    # Initial condition for the base trajectory\n    x0 = np.array([1.0, 1.0, 1.0])\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case A: happy path\n        {'delta_x0': np.array([1e-6, 0.0, 0.0]), 'T': 5.0, 'norm_p': 2},\n        # Case B: scaling invariance check\n        {'delta_x0': np.array([1e-8, 0.0, 0.0]), 'T': 5.0, 'norm_p': 2},\n        # Case C: norm sensitivity\n        {'delta_x0': np.array([0.0, 1e-6, 0.0]), 'T': 5.0, 'norm_p': 1},\n        # Case D: norm sensitivity\n        {'delta_x0': np.array([0.0, 0.0, 1e-6]), 'T': 5.0, 'norm_p': np.inf},\n        # Case E: short-time behavior\n        {'delta_x0': np.array([1e-6, 1e-6, 1e-6]), 'T': 0.5, 'norm_p': 2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T = case['T']\n        delta_x0 = case['delta_x0']\n        norm_p = case['norm_p']\n\n        # Initial conditions for the augmented system\n        phi0_flat = np.identity(3).flatten()\n        y0 = np.concatenate((x0, phi0_flat))\n\n        # Integrate the augmented ODE system.\n        # Higher precision is used for better accuracy in chaotic systems.\n        sol = solve_ivp(\n            lorenz_augmented_rhs,\n            [0, T],\n            y0,\n            t_eval=[T],\n            args=(sigma, rho, beta),\n            method='RK45',\n            rtol=1e-9,  # Relative tolerance\n            atol=1e-12 # Absolute tolerance\n        )\n        \n        # Extract the final state and the fundamental matrix\n        y_T = sol.y[:, 0]\n        Phi_T = y_T[3:].reshape((3, 3))\n\n        # Compute the final perturbation vector\n        delta_x_T = Phi_T @ delta_x0\n\n        # Calculate initial and final norms\n        norm_initial = np.linalg.norm(delta_x0, ord=norm_p)\n        norm_final = np.linalg.norm(delta_x_T, ord=norm_p)\n\n        # Calculate FTLE, ensuring T > 0 and norm_initial > 0 to avoid division by zero\n        if T > 0 and norm_initial > 0:\n            ftle = (1.0 / T) * np.log(norm_final / norm_initial)\n        else:\n            # This case should not be reached based on the problem description\n            ftle = 0.0\n\n        results.append(f\"{ftle:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在研究了沿单一轨道的误差增长后，我们将视角提升到评估系统的整体复杂性。本实践探讨了“有效自由度”的概念，即对系统变率和不可预报性有积极贡献的维度数量。您将推导并计算两种不同的复杂性度量：基于集合统计的参与率维度 $D_{\\mathrm{PR}}$ 和基于系统基本李雅普诺夫指数的卡普兰-约克维度 $D_{\\mathrm{KY}}$，从而对混沌的结构获得更深刻的见解 。",
            "id": "4077608",
            "problem": "考虑一个表示大气-海洋状态向量演化的离散时间、有限维动力系统。使用轨迹集合来量化变率和预报不确定性。设集合异常被收集在一个矩阵中，其样本协方差是对称半正定的。主成分分析（PCA）提供了一个正交基，在该基中协方差是对角化的，其特征值表示沿主成分的方差。参与率是一个有效维度的概念，它量化了方差在主成分间的分布情况。另外，混沌动力学由李雅普诺夫指数来表征，而卡普兰-约克维度则根据这些指数来估计吸引子的分形维数。您的任务是根据主成分的参与率推导并实现有效自由度，并将其与从李雅普诺夫谱计算出的卡普兰-约克维度联系起来。\n\n仅从基本定义出发，完成以下任务：\n- 从集合异常的样本协方差、对称半正定矩阵的正交对角化以及主成分方差分数的概念开始。利用这些来推导基于参与率的有效维度，作为主成分方差的函数。然后，实现一个算法，通过首先提取协方差矩阵的主成分方差来计算此有效维度。\n- 从李雅普诺夫指数的定义开始，即邻近轨迹的长期平均指数发散或收敛率，并按从大到小的顺序排列。使用累积有序指数以确定总膨胀符号变化位置的标准构造方法，推导卡普兰-约克维度作为有序指数的函数。然后，实现一个算法，从给定的指数列表中计算它。阐明并实现边界情况，包括最大指数为负、所有部分和直到最后一个指数都保持非负，以及阈值处的下一个指数为零的情况。\n\n从数值天气预报和气候建模中的可预报性极限和活动自由度的角度解释这两个维度。您必须为指定的测试套件提供数值输出，并且必须在一个程序中实现这些算法，该程序输出所需的结果。不允许外部输入。\n\n本问题中的所有答案均为无量纲量。除非明确指定旋转，否则不需要物理单位或角度单位；在这种情况下，角度以弧度为单位。\n\n您必须从以下定义开始：\n- 设集合异常为 $\\mathbb{R}^n$ 中的列向量。样本协方差矩阵定义为 $$\\mathbf{C}=\\frac{1}{m-1}\\sum_{k=1}^{m} \\mathbf{x}_k' \\mathbf{x}_k'^{\\top},$$ 其中 $m$ 是集合大小，$\\mathbf{x}_k'$ 是异常。\n- 由于 $\\mathbf{C}$ 是对称半正定的，存在一个正交矩阵 $\\mathbf{Q}$ 使得 $$\\mathbf{Q}^{\\top}\\mathbf{C}\\mathbf{Q}=\\operatorname{diag}(\\lambda_1,\\ldots,\\lambda_n),$$ 其中 $\\lambda_i \\ge 0$ 是主成分方差。\n- 李雅普诺夫指数 $\\{\\ell_i\\}_{i=1}^n$ 定义为长期平均指数率，并按 $\\ell_1 \\ge \\ell_2 \\ge \\cdots \\ge \\ell_n$ 的顺序排列。\n\n用于评估您实现的测试套件：\n- 情况 $1$（各向异性协方差，中度耗散谱）：\n  - 协方差特征值：$[4.0,\\,1.0,\\,0.25,\\,0.25,\\,0.01]$。\n  - 李雅普诺夫指数：$[0.4,\\,0.05,\\,-0.02,\\,-0.3,\\,-0.5]$。\n- 情况 $2$（各向同性协方差，边界含零指数）：\n  - 协方差特征值：$[2.0,\\,2.0,\\,2.0,\\,2.0,\\,2.0]$。\n  - 李雅普诺夫指数：$[0.2,\\,0.0,\\,-0.2,\\,-0.2,\\,-0.2]$。\n- 情况 $3$（一个主导主成分，其余部分强阻尼）：\n  - 协方差特征值：$[100.0,\\,0.001,\\,0.001,\\,0.001,\\,0.001]$。\n  - 李雅普诺夫指数：$[0.5,\\,-0.8,\\,-1.0,\\,-1.0,\\,-2.0]$。\n- 情况 $4$（带旋转的秩亏协方差，阻尼谱）：\n  - 协方差特征值：$[3.0,\\,2.0,\\,0.0,\\,0.0,\\,0.0]$ 以及在前两个坐标中按角度 $\\theta=\\pi/6$ 弧度进行的正交旋转，即 $$\\mathbf{Q}=\\begin{bmatrix}\\cos\\theta  -\\sin\\theta  0  0  0\\\\ \\sin\\theta  \\cos\\theta  0  0  0\\\\ 0  0  1  0  0\\\\ 0  0  0  1  0\\\\ 0  0  0  0  1\\end{bmatrix},\\quad \\mathbf{C}=\\mathbf{Q}\\,\\operatorname{diag}(3.0,\\,2.0,\\,0.0,\\,0.0,\\,0.0)\\,\\mathbf{Q}^{\\top}.$$\n  - 李雅普诺夫指数：$[0.3,\\,-0.4,\\,-0.5,\\,-1.0,\\,-2.0]$。\n- 情况 $5$（混合小方差，所有指数均为负）：\n  - 协方差特征值：$[1.0,\\,0.5,\\,0.5,\\,0.2,\\,0.1]$。\n  - 李雅普诺夫指数：$[-0.05,\\,-0.1,\\,-0.2,\\,-0.3,\\,-0.4]$。\n\n要求的输出：\n- 对于每种情况，从协方差计算参与率有效维度 $D_{\\mathrm{PR}}$，并从李雅普诺夫谱计算卡普兰-约克维度 $D_{\\mathrm{KY}}$。同时计算差值 $\\Delta=D_{\\mathrm{PR}}-D_{\\mathrm{KY}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每种情况表示为包含三个浮点数的列表 $[D_{\\mathrm{PR}},\\,D_{\\mathrm{KY}},\\,\\Delta]$，保留 $6$ 位小数。例如，输出可能看起来像 $[[1.234000,2.345000,-1.111000],[\\dots],\\dots]$。\n\n覆盖性设计：\n- 情况 1 是一个通用的“理想路径”，具有混合方差和带少量弱负指数的谱。\n- 情况 2 测试了指数的部分和恰好为零且协方差为各向同性的边界条件。\n- 情况 3 测试了协方差中具有单个主导模式和第一个指数后强阻尼谱的极端各向异性情况。\n- 情况 4 测试了通过旋转构建的非对角协方差，确保特征值提取在正交变换下是不变的。\n- 情况 5 测试了所有李雅普诺夫指数均为负的边缘情况，这意味着 $D_{\\mathrm{KY}}=0$。\n\n您的解决方案必须展示推导过程并提供用于计算的算法。最终程序必须实现这些算法并以指定的确切格式输出结果。",
            "solution": "此问题要求推导和实现两种不同的动力系统有效维度度量：基于参与率的有效维度 $D_{\\mathrm{PR}}$（源自集合的统计分析）和卡普兰-约克维度 $D_{\\mathrm{KY}}$（源自系统的李雅普诺夫指数）。我们将首先从基本原理推导所需的公式，然后讨论它们的解释，最后概述其计算算法。\n\n### 第 1 部分：参与率有效维度 ($D_{\\mathrm{PR}}$)\n\n参与率是用于估计对给定状态有贡献的有效基态数量的一种度量。在我们的情境中，我们将此概念应用于系统状态集合的主成分间的方差分布。\n\n设集合异常由一组向量表示，从中计算出样本协方差矩阵 $\\mathbf{C}$。如前所述，$\\mathbf{C}$ 是一个 $n \\times n$ 的对称半正定矩阵。根据谱定理，它可以通过一个正交矩阵 $\\mathbf{Q}$ 对角化：\n$$\n\\mathbf{Q}^{\\top}\\mathbf{C}\\mathbf{Q} = \\mathbf{\\Lambda} = \\operatorname{diag}(\\lambda_1, \\lambda_2, \\ldots, \\lambda_n)\n$$\n其中 $\\lambda_i \\ge 0$ 是 $\\mathbf{C}$ 的特征值。这些特征值，也称为主成分方差，量化了集合数据沿每个主成分方向（$\\mathbf{Q}$ 的列）的方差大小。\n\n集合的总方差是沿所有方向的方差之和，由协方差矩阵的迹给出。迹在基变换下是不变的，因此：\n$$\n\\operatorname{Tr}(\\mathbf{C}) = \\sum_{i=1}^n \\lambda_i\n$$\n第 $i$ 个主成分所占的总方差分数为：\n$$\np_i = \\frac{\\lambda_i}{\\sum_{j=1}^n \\lambda_j}\n$$\n分数集合 $\\{p_i\\}_{i=1}^n$ 形成一个离散概率分布，因为 $p_i \\ge 0$ 且 $\\sum_{i=1}^n p_i = 1$。此分布描述了系统的变率如何在主成分之间进行划分。\n\n参与率 $D_{\\mathrm{PR}}$ 量化了对总方差有贡献的有效主成分数量。它定义为分数平方和的倒数，这一度量在其他领域中与逆 Simpson 指数或 Herfindahl-Hirschman 指数相关。\n$$\nD_{\\mathrm{PR}} = \\frac{1}{\\sum_{i=1}^n p_i^2}\n$$\n代入 $p_i$ 的表达式，我们推导出以特征值 $\\lambda_i$ 表示的 $D_{\\mathrm{PR}}$ 公式：\n$$\nD_{\\mathrm{PR}} = \\frac{1}{\\sum_{i=1}^n \\left( \\frac{\\lambda_i}{\\sum_{j=1}^n \\lambda_j} \\right)^2} = \\frac{(\\sum_{j=1}^n \\lambda_j)^2}{\\sum_{i=1}^n \\lambda_i^2}\n$$\n这就是要实现的公式。其取值范围从 $1$（如果所有方差都在单个主成分中，即只有一个 $k$ 使得 $\\lambda_k > 0$）到 $n$（如果方差在所有主成分中平均分布，即所有 $\\lambda_i$ 都相等且非零）。如果所有 $\\lambda_i = 0$，则没有方差，有效维度为 $0$。\n\n**解释**：$D_{\\mathrm{PR}}$ 衡量了捕捉系统短期变率（由集合表示）的子空间的有效维度。在数值天气预报中，这关系到在预报时刻对预报不确定性最重要的“增长模态”或模式的数量。一个低的 $D_{\\mathrm{PR}}$ 值表示不确定性集中在少数几个明确定义的空间模式中。\n\n**$D_{\\mathrm{PR}}$ 的算法**：\n1. 获取协方差矩阵 $\\mathbf{C}$ 的主成分方差（特征值）$\\lambda_1, \\ldots, \\lambda_n$。在本问题中，这些值要么是直接给出的，要么是像情况 4 中那样是 $\\mathbf{C}$ 特征分解的平凡结果。\n2. 计算特征值之和，$S_1 = \\sum_{i=1}^n \\lambda_i$。\n3. 如果 $S_1 = 0$，则返回 $D_{\\mathrm{PR}} = 0$。\n4. 计算特征值的平方和，$S_2 = \\sum_{i=1}^n \\lambda_i^2$。\n5. 计算 $D_{\\mathrm{PR}} = S_1^2 / S_2$。\n\n### 第 2 部分：卡普兰-约克维度 ($D_{\\mathrm{KY}}$)\n\n卡普兰-约克维度是基于猜想的对混沌吸引子分形维数的估计。它源自系统的李雅普诺夫指数。\n\n设李雅普诺夫指数按从大到小的顺序排列：$\\ell_1 \\ge \\ell_2 \\ge \\cdots \\ge \\ell_n$。这些指数定量描述了相空间中沿 $n$ 个正交方向的无穷小邻近轨迹的平均指数发散或收敛率。\n- 正指数（$\\ell_i > 0$）表示一个扩张（不稳定）方向。\n- 零指数（$\\ell_i = 0$）对应一个中性方向，通常沿着轨迹的流向。\n- 负指数（$\\ell_i  0$）表示一个收缩（稳定）方向。\n\n前 $k$ 个指数的和 $\\sum_{i=1}^k \\ell_i$ 决定了相空间中 $k$ 维体积元的变化率。卡普兰-约克猜想假定，吸引子的维度是这样一个值 $D$，对于该值，一个无穷小的 $D$ 维体积元平均而言既不增长也不收缩。\n\n为了找到这个维度，我们首先找到最大的整数 $j$，使得一个 $j$ 维体积元是非收缩的，即前 $j$ 个指数的和为非负。\n$$\n\\sum_{i=1}^j \\ell_i \\ge 0 \\quad \\text{and} \\quad \\sum_{i=1}^{j+1} \\ell_i  0\n$$\n这意味着吸引子至少有 $j$ 维，但小于 $j+1$ 维。卡普兰-约克维度 $D_{\\mathrm{KY}}$ 通过线性插值得到，即在 $j$ 上加上一个小数部分，该小数部分用下一个负指数 $\\ell_{j+1}$ 来平衡正和 $\\sum_{i=1}^j \\ell_i$。\n$$\nD_{\\mathrm{KY}} = j + \\frac{\\sum_{i=1}^j \\ell_i}{|\\ell_{j+1}|} = j + \\frac{\\sum_{i=1}^j \\ell_i}{-\\ell_{j+1}}\n$$\n第二种形式是有效的，因为为了使和跨越零点，$\\ell_{j+1}$ 必须为负。\n\n我们必须考虑边界情况：\n1. **所有指数均为负**：如果 $\\ell_1  0$，所有轨迹都收敛到一个稳定不动点。吸引子的维度是 $0$。我们的公式可以处理这种情况：如果 $\\ell_1  0$，我们定义 $j=0$（空和为 $0$），则 $D_{\\mathrm{KY}} = 0 + 0/|\\ell_1| = 0$。\n2. **所有指数之和为非负**：如果 $\\sum_{i=1}^n \\ell_i \\ge 0$，系统耗散性不足以形成有限维吸引子。“吸引子”将充满整个相空间。在这种情况下，$D_{\\mathrm{KY}} = n$。\n3. **部分和为零**：如果 $\\sum_{i=1}^j \\ell_i = 0$ 且 $\\ell_{j+1}  0$，则公式给出 $D_{\\mathrm{KY}} = j + 0/|\\ell_{j+1}| = j$。这是一个明确定义的边界。\n\n**解释**：$D_{\\mathrm{KY}}$ 估计了系统长期演化所局限的几何对象（吸引子）的维度。它代表了系统长期行为中活跃的、动力学上相关的自由度数量。对于可预报性而言，一个状态只能在吸引子的几何形状内被知晓，其维度量化了这一基本极限。\n\n**$D_{\\mathrm{KY}}$ 的算法**：\n1. 获取有序的李雅普诺夫指数 $\\ell_1, \\ldots, \\ell_n$。\n2. 如果列表为空或 $\\ell_1  0$，则返回 $D_{\\mathrm{KY}} = 0.0$。\n3. 初始化部分和 $S = 0.0$。\n4. 使用索引 $j$ 从 $0$ 到 $n-1$ 进行迭代：\n    a. 设 $S_{\\text{next}} = S + \\ell_{j}$。\n    b. 如果 $S_{\\text{next}}  0$，则找到了交叉点。整数部分为 $j$。维度是 $D_{\\mathrm{KY}} = j + S / |\\ell_{j}|$。返回此值。\n    c. 更新 $S = S_{\\text{next}}$。\n5. 如果循环完成，意味着所有部分和均为非负。维度是整个空间的维度，所以返回 $D_{\\mathrm{KY}} = n$。\n\n差值 $\\Delta = D_{\\mathrm{PR}} - D_{\\mathrm{KY}}$ 比较了短期不确定性结构与长期吸引子的维度，从而提供了关于基于集合的变率在多大程度上采样了潜在混沌动力学的洞见。",
            "answer": "```python\nimport numpy as np\n\ndef compute_d_pr(eigenvalues):\n    \"\"\"\n    Computes the Participation Ratio-based effective dimension.\n\n    Args:\n        eigenvalues (list or np.ndarray): A list of the eigenvalues (principal\n                                          component variances) of the covariance matrix.\n\n    Returns:\n        float: The effective dimension D_PR.\n    \"\"\"\n    lambdas = np.array(eigenvalues, dtype=float)\n    \n    # Filter out any non-positive eigenvalues, which don't contribute to variance\n    lambdas = lambdas[lambdas > 1e-12] # Use a small tolerance for zero\n    \n    if lambdas.size == 0:\n        return 0.0\n\n    sum_lambda = np.sum(lambdas)\n    sum_lambda_sq = np.sum(lambdas**2)\n\n    if sum_lambda_sq == 0.0:\n        # This case implies all positive eigenvalues are numerically zero,\n        # covered by the size==0 check, but as a safeguard.\n        return 0.0\n\n    d_pr = sum_lambda**2 / sum_lambda_sq\n    return d_pr\n\ndef compute_d_ky(lyap_exponents):\n    \"\"\"\n    Computes the Kaplan-Yorke dimension.\n\n    Args:\n        lyap_exponents (list or np.ndarray): A list of Lyapunov exponents,\n                                             ordered from largest to smallest.\n\n    Returns:\n        float: The Kaplan-Yorke dimension D_KY.\n    \"\"\"\n    exponents = np.array(lyap_exponents, dtype=float)\n    n = len(exponents)\n\n    if n == 0 or exponents[0]  0:\n        return 0.0\n\n    partial_sum = 0.0\n    for j, exp in enumerate(exponents):\n        if partial_sum + exp  0:\n            # The sum becomes negative when adding the j-th exponent (0-indexed).\n            # The integer part of the dimension is j.\n            # The fractional part is partial_sum / |exp|.\n            if abs(exp)  1e-12:\n                # This case should not be reached if partial_sum + exp  0\n                # and partial_sum >= 0, unless exp is negative. If it is\n                # numerically zero, we can consider the dimension to be the\n                # integer part.\n                return float(j)\n            return j + partial_sum / abs(exp)\n        partial_sum += exp\n    \n    # If the loop completes, the sum of all exponents is non-negative.\n    # The dimension is the full phase space dimension.\n    return float(n)\n\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating D_PR, D_KY, and their difference\n    for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: anisotropic covariance, moderately dissipative spectrum\n        {\n            \"cov_eigenvalues\": [4.0, 1.0, 0.25, 0.25, 0.01],\n            \"lyap_exponents\": [0.4, 0.05, -0.02, -0.3, -0.5]\n        },\n        # Case 2: isotropic covariance, boundary with a zero exponent\n        {\n            \"cov_eigenvalues\": [2.0, 2.0, 2.0, 2.0, 2.0],\n            \"lyap_exponents\": [0.2, 0.0, -0.2, -0.2, -0.2]\n        },\n        # Case 3: one dominant principal component, strongly damped remainder\n        {\n            \"cov_eigenvalues\": [100.0, 0.001, 0.001, 0.001, 0.001],\n            \"lyap_exponents\": [0.5, -0.8, -1.0, -1.0, -2.0]\n        },\n        # Case 4: rank-deficient covariance. Eigenvalues are given by the\n        # diagonal matrix in the SVD-like decomposition.\n        {\n            \"cov_eigenvalues\": [3.0, 2.0, 0.0, 0.0, 0.0],\n            \"lyap_exponents\": [0.3, -0.4, -0.5, -1.0, -2.0]\n        },\n        # Case 5: mixed small variances, all exponents negative\n        {\n            \"cov_eigenvalues\": [1.0, 0.5, 0.5, 0.2, 0.1],\n            \"lyap_exponents\": [-0.05, -0.1, -0.2, -0.3, -0.4]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        d_pr = compute_d_pr(case[\"cov_eigenvalues\"])\n        d_ky = compute_d_ky(case[\"lyap_exponents\"])\n        delta = d_pr - d_ky\n        results.append([d_pr, d_ky, delta])\n\n    # Format the output string exactly as specified.\n    case_strings = []\n    for res in results:\n        d_pr_str = f\"{res[0]:.6f}\"\n        d_ky_str = f\"{res[1]:.6f}\"\n        delta_str = f\"{res[2]:.6f}\"\n        case_strings.append(f\"[{d_pr_str},{d_ky_str},{delta_str}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}