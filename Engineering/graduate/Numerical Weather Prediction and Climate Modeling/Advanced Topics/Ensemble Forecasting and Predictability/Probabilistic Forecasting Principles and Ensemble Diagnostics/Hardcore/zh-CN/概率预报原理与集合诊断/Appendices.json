{
    "hands_on_practices": [
        {
            "introduction": "评估概率预报的质量需要专门的评分体系，而布莱尔分数 (Brier score) 是其中的基石。通过将其分解，我们可以分离出预报质量的不同方面，其中可靠性 (reliability) 部分对于评估预报概率与观测频率的统计一致性至关重要。此练习 ([@problem-id:4079061]) 将提供从第一性原理推导并根据可靠性图数据计算这一基本指标的动手实践。",
            "id": "4079061",
            "problem": "一个研究小组正在评估一个对流可分辨数值天气预报（NWP）集合对某一流域的二元事件“六小时累积降水量超过 $10$ 毫米”的概率预报。令 $Y \\in \\{0,1\\}$ 表示事件发生的验证指标，令 $F \\in [0,1]$ 表示该集合发布的预报概率。Brier评分定义为 $BS = \\mathbb{E}[(F - Y)^{2}]$，其中期望是针对由预报系统和验证自然所产生的 $(F,Y)$ 的联合分布来计算的。\n\n利用全期望定律和条件期望的性质，将Brier评分分解为可靠性、分辨率和不确定性分量，从第一性原理推导出可靠性分量，其形式为一个包含 $F$ 和条件事件频率 $\\mathbb{E}[Y \\mid F]$ 的期望。然后，在一个将预报空间划分为 $K$ 个离散箱的可靠性图分箱方案下，每个箱内具有代表性概率 $q_{k}$、经验计数 $n_{k}$ 和观测相对频率 $\\bar{y}_{k}$，利用这些分箱摘要得出一个可靠性分量的一致有限样本估计量。\n\n一项为期一年的评估为 $K=5$ 个箱生成了以下可靠性图摘要：\n- 箱 $k=1$：$q_{1} = 0.05$，$n_{1} = 40$，$\\bar{y}_{1} = 0.10$。\n- 箱 $k=2$：$q_{2} = 0.15$，$n_{2} = 60$，$\\bar{y}_{2} = 0.12$。\n- 箱 $k=3$：$q_{3} = 0.35$，$n_{3} = 80$，$\\bar{y}_{3} = 0.30$。\n- 箱 $k=4$：$q_{4} = 0.65$，$n_{4} = 50$，$\\bar{y}_{4} = 0.60$。\n- 箱 $k=5$：$q_{5} = 0.85$，$n_{5} = 70$，$\\bar{y}_{5} = 0.90$。\n\n令 $N = \\sum_{k=1}^{K} n_{k}$ 表示预报-验证对的总数。使用您推导的估计量，计算该数据集的可靠性分量。将最终答案表示为一个精确的既约分数（无量纲）。不要使用百分号。",
            "solution": "问题陈述已经过分析并被认为是有效的。它在科学上基于概率预报验证的原理，问题提法良好，有足够的数据得出唯一解，并以客观、明确的语言表达。我们可以开始求解。\n\n该问题要求完成两项主要任务：首先，从第一性原理推导Brier评分的可靠性分量；其次，为其推导一个有限样本估计量，并使用该估计量计算给定数据集下该分量的值。\n\n令 $Y \\in \\{0, 1\\}$ 为事件发生的二元变量，$F \\in [0, 1]$ 为预报概率。Brier评分（$BS$）定义为预报的均方误差：\n$$\nBS = \\mathbb{E}[(F - Y)^{2}]\n$$\n期望 $\\mathbb{E}[\\cdot]$ 是对预报和观测的联合分布取的。\n\n**第一部分：可靠性分量的推导**\n\n我们可以使用全期望定律来分解Brier评分。我们以预报值 $F$ 为条件。\n$$\nBS = \\mathbb{E}_{F} \\left[ \\mathbb{E}_{Y \\mid F} [(F - Y)^{2} \\mid F] \\right]\n$$\n我们来分析内部的期望 $\\mathbb{E}[(F-Y)^2 \\mid F]$。给定一个特定的预报值 $F=f$，则 $f$ 是一个常数。\n$$\n\\mathbb{E}[(f - Y)^{2} \\mid F=f] = \\mathbb{E}[f^2 - 2fY + Y^2 \\mid F=f]\n$$\n根据期望的线性性质：\n$$\n= f^2 - 2f \\mathbb{E}[Y \\mid F=f] + \\mathbb{E}[Y^2 \\mid F=f]\n$$\n由于 $Y$ 是一个指示变量，$Y \\in \\{0, 1\\}$，因此有 $Y^2 = Y$。所以，$\\mathbb{E}[Y^2 \\mid F=f] = \\mathbb{E}[Y \\mid F=f]$。我们将条件事件频率，即给定预报下事件的真实概率，定义为 $\\bar{y}(f) \\equiv \\mathbb{E}[Y \\mid F=f]$。将其代入表达式中得到：\n$$\n\\mathbb{E}[(f - Y)^{2} \\mid F=f] = f^2 - 2f \\bar{y}(f) + \\bar{y}(f)\n$$\n我们可以加上再减去 $(\\bar{y}(f))^2$ 来配方：\n$$\n= f^2 - 2f \\bar{y}(f) + (\\bar{y}(f))^2 - (\\bar{y}(f))^2 + \\bar{y}(f)\n$$\n$$\n= (f - \\bar{y}(f))^2 + (\\bar{y}(f) - (\\bar{y}(f))^2)\n$$\n现在，我们对 $F$ 取外层期望，回到Brier评分：\n$$\nBS = \\mathbb{E}_{F} \\left[ (F - \\bar{y}(F))^2 + (\\bar{y}(F) - (\\bar{y}(F))^2) \\right]\n$$\n$$\nBS = \\mathbb{E} \\left[ (F - \\mathbb{E}[Y \\mid F])^2 \\right] + \\mathbb{E} \\left[ \\mathbb{E}[Y \\mid F] (1 - \\mathbb{E}[Y \\mid F]) \\right]\n$$\n这个表达式将Brier评分分解为两项。第一项 $\\mathbb{E}[(F - \\mathbb{E}[Y \\mid F])^2]$ 是**可靠性分量**。它衡量的是预报概率与对应这些概率的观测条件均值之间的加权均方差。一个完全可靠的预报系统对于所有的 $f$ 都会有 $\\mathbb{E}[Y \\mid F=f] = f$，从而使该分量为零。这完成了第一部分的推导。\n\n第二项可以进一步分解为分辨率和不确定性，得到完整的分解式 $BS = REL - RES + UNC$，但这超出了当前问题的范围。可靠性分量是：\n$$\nREL = \\mathbb{E} \\left[ (F - \\mathbb{E}[Y \\mid F])^2 \\right]\n$$\n\n**第二部分：有限样本估计量和计算**\n\n为了从一组 $N$ 个预报-验证对中获得有限样本估计量，我们通常使用问题中所述的分箱方法。预报概率空间 $[0,1]$ 被划分为 $K$ 个箱。对于每个箱 $k \\in \\{1, \\dots, K\\}$，我们有：\n- $n_k$：落入箱 $k$ 的预报数量。\n- $q_k$：箱 $k$ 的代表性预报概率（例如，箱的中点或箱内预报的平均值）。这是 $F$ 的经验对应物。\n- $\\bar{y}_k$：箱 $k$ 内预报的事件观测相对频率。这是条件期望 $\\mathbb{E}[Y \\mid F \\in \\text{bin } k]$ 的经验估计。\n\n总体期望 $\\mathbb{E}[\\cdot]$ 被估计为所有 $N$ 个样本的平均值，这可以转化为对 $K$ 个箱的加权平均。每个箱 $k$ 的权重是其样本频率 $n_k/N$。期望内的项 $(F - \\mathbb{E}[Y \\mid F])^2$ 对每个箱 $k$ 而言，被估计为 $(q_k - \\bar{y}_k)^2$。\n\n结合这些，可靠性分量的有限样本估计量，我们记为 $\\widehat{REL}$，是：\n$$\n\\widehat{REL} = \\sum_{k=1}^{K} \\frac{n_k}{N} (q_k - \\bar{y}_k)^2\n$$\n其中 $N = \\sum_{k=1}^{K} n_k$。\n\n现在，我们使用所提供的数据计算 $\\widehat{REL}$：\n- 箱 $k=1$：$q_{1} = 0.05$，$n_{1} = 40$，$\\bar{y}_{1} = 0.10$。\n- 箱 $k=2$：$q_{2} = 0.15$，$n_{2} = 60$，$\\bar{y}_{2} = 0.12$。\n- 箱 $k=3$：$q_{3} = 0.35$，$n_{3} = 80$，$\\bar{y}_{3} = 0.30$。\n- 箱 $k=4$：$q_{4} = 0.65$，$n_{4} = 50$，$\\bar{y}_{4} = 0.60$。\n- 箱 $k=5$：$q_{5} = 0.85$，$n_{5} = 70$，$\\bar{y}_{5} = 0.90$。\n\n首先，我们计算预报-验证对的总数 $N$：\n$$\nN = n_1 + n_2 + n_3 + n_4 + n_5 = 40 + 60 + 80 + 50 + 70 = 300\n$$\n现在，我们计算每个箱的项：\n- 箱 1：$\\frac{40}{300} (0.05 - 0.10)^2 = \\frac{4}{30} (-0.05)^2 = \\frac{2}{15} (0.0025) = \\frac{2}{15} \\left(\\frac{1}{400}\\right) = \\frac{2}{6000} = \\frac{1}{3000}$。\n- 箱 2：$\\frac{60}{300} (0.15 - 0.12)^2 = \\frac{6}{30} (0.03)^2 = \\frac{1}{5} (0.0009) = \\frac{1}{5} \\left(\\frac{9}{10000}\\right) = \\frac{9}{50000}$。\n- 箱 3：$\\frac{80}{300} (0.35 - 0.30)^2 = \\frac{8}{30} (0.05)^2 = \\frac{4}{15} (0.0025) = \\frac{4}{15} \\left(\\frac{1}{400}\\right) = \\frac{4}{6000} = \\frac{1}{1500}$。\n- 箱 4：$\\frac{50}{300} (0.65 - 0.60)^2 = \\frac{5}{30} (0.05)^2 = \\frac{1}{6} (0.0025) = \\frac{1}{6} \\left(\\frac{1}{400}\\right) = \\frac{1}{2400}$。\n- 箱 5：$\\frac{70}{300} (0.85 - 0.90)^2 = \\frac{7}{30} (-0.05)^2 = \\frac{7}{30} (0.0025) = \\frac{7}{30} \\left(\\frac{1}{400}\\right) = \\frac{7}{12000}$。\n\n现在我们对这些贡献求和：\n$$\n\\widehat{REL} = \\frac{1}{3000} + \\frac{9}{50000} + \\frac{1}{1500} + \\frac{1}{2400} + \\frac{7}{12000}\n$$\n为了对这些分数求和，我们找到一个公分母。分母分别为 $3000=3\\times10^3$、$50000=5\\times10^4$、$1500=1.5\\times10^3$、$2400=2.4\\times10^3$ 和 $12000=1.2\\times10^4$。分母 $(3000, 50000, 1500, 2400, 12000)$ 的最小公倍数是 $300000$。\n将每个分数转换为该分母：\n$$\n\\frac{1}{3000} = \\frac{100}{300000}\n$$\n$$\n\\frac{9}{50000} = \\frac{9 \\times 6}{50000 \\times 6} = \\frac{54}{300000}\n$$\n$$\n\\frac{1}{1500} = \\frac{200}{300000}\n$$\n$$\n\\frac{1}{2400} = \\frac{125}{300000}\n$$\n$$\n\\frac{7}{12000} = \\frac{7 \\times 25}{12000 \\times 25} = \\frac{175}{300000}\n$$\n对分子求和：\n$$\n100 + 54 + 200 + 125 + 175 = 654\n$$\n所以，可靠性分量是：\n$$\n\\widehat{REL} = \\frac{654}{300000}\n$$\n最后，我们将分数化为最简形式。分子和分母都可以被 $6$ 整除：\n$$\n\\widehat{REL} = \\frac{654 \\div 6}{300000 \\div 6} = \\frac{109}{50000}\n$$\n由于 $109$ 是一个质数，该分数已完全化简。",
            "answer": "$$\n\\boxed{\\frac{109}{50000}}\n$$"
        },
        {
            "introduction": "在掌握了像布莱尔分数这样的连续评分之后，我们转向另一个核心诊断工具：等级直方图 (rank histogram)。等级直方图为检验集合预报的可靠性提供了直观的视觉评估和统计检验方法。本练习 ([@problem-id:4079006]) 将指导你实现标准的皮尔逊卡方 ($\\chi^2$) 检验，这是分析集合预报性能的必备技能。",
            "id": "4079006",
            "problem": "考虑一个用于数值天气预报和气候模拟的、包含 $M$ 个集合成员的集合概率预报系统。对于每个检验观测值，我们使用标准的秩柱状图构建方法，在 $M$ 个集合成员中定义其秩 $r \\in \\{0,1,\\dots,M\\}$。在该方法中，平局被随机打破，观测值被概念性地插入到排序后的集合中。根据概率预报的校准原则，观测值和集合成员是可交换的，这意味着 $r$ 是从 $\\{0,1,\\dots,M\\}$ 上的离散均匀分布中抽取的一个样本。对于 $N$ 个独立的预报-观测对，令 $O_r$ 为秩区间 $r$ 中的观测频数，因此有 $\\sum_{r=0}^{M} O_r = N$。在均匀性的零假设下，每个区间的期望频数为 $E_r = N/(M+1)$。\n\n从离散均匀性的定义以及总频数约束减少一个自由度这一事实出发，推导用于检验秩柱状图均匀性的 Pearson 卡方拟合优度检验。检验统计量为\n$$\nT = \\sum_{r=0}^{M} \\frac{(O_r - E_r)^2}{E_r},\n$$\n在零假设下，该统计量近似服从自由度为 $M$ 的卡方分布。$p$ 值是上尾概率\n$$\np = \\Pr\\left(\\chi^2_M \\ge T\\right).\n$$\n在显著性水平 $\\alpha = 0.05$ 下，决策规则是：如果 $p  \\alpha$，则拒绝均匀性假设。\n\n你的任务是实现一个完整的、可运行的程序，该程序：\n- 无需输入，并使用下面指定的嵌入式测试套件。\n- 对每个测试用例，计算 $N$、$E_r$（对所有 $r$ 均为常数）、卡方统计量 $T$、自由度 $M$、$p$ 值 $p$，以及定义为 $p  \\alpha$ 的布尔决策 $\\text{reject}$。\n- 输出单行结果，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果必须是包含四个元素的列表，顺序为 $[T, M, p, \\text{reject}]$。浮点数 $T$ 和 $p$ 必须四舍五入到六位小数。最终打印的行不得包含任何空格。\n\n注意：\n- 所有量都是无量纲的。\n- 确保所提供的频数向量长度与 $M+1$ 匹配，并且所有频数都是非负整数。\n- 已知卡方近似是渐近的；当某些期望频数 $E_r$ 很小时，应谨慎解释 $p$ 值，但仍按规定进行计算。\n\n测试套件（每个测试用例是一对 $(M, \\{O_r\\}_{r=0}^{M})$）：\n1. $M = 9$, $O = [100,100,100,100,100,100,100,100,100,100]$。\n2. $M = 9$, $O = [300,120,100,90,90,80,70,60,50,40]$。\n3. $M = 4$, $O = [1,1,1,1,1]$。\n4. $M = 19$, $O = [4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0]$。\n5. $M = 1$, $O = [45,5]$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，且不含空格。列表中的每个元素对应一个测试用例，其本身是一个包含四个元素的列表，形式为 $[T, M, p, \\text{reject}]$。例如，你的输出格式必须类似于：[[t1,df1,p1,b1],[t2,df2,p2,b2],...]，其中 $t_i$ 和 $p_i$ 四舍五入到六位小数，$df_i$ 是整数，$b_i$ 是布尔值。",
            "solution": "其基本原理是集合预报的概率校准，这意味着在预报分布下，集合成员与检验观测值之间具有可交换性。可交换性导致观测值等可能地落入 $M+1$ 个秩位置中的任何一个。形式上，如果预报是可靠的，那么观测值在 $M$ 个集合成员中的秩 $r$ 在 $\\{0,1,\\dots,M\\}$ 上服从均匀分布，因此\n$$\n\\Pr(r = j) = \\frac{1}{M+1} \\quad \\text{for all } j \\in \\{0,\\dots,M\\}.\n$$\n当观测 $N$ 个独立的预报-观测对时，将 $O_r$ 定义为秩等于 $r$ 的观测数量。在均匀性的零假设下，\n$$\nE_r = \\mathbb{E}[O_r] = N \\cdot \\Pr(r = j) = \\frac{N}{M+1} \\quad \\text{for all } r,\n$$\n且向量 $(O_0, O_1, \\dots, O_M)$ 服从多项分布，其参数为 $N$ 和相等的单元格概率 $1/(M+1)$。\n\nPearson 卡方拟合优度统计量评估了观测频数与期望频数之间的偏差：\n$$\nT = \\sum_{r=0}^{M} \\frac{(O_r - E_r)^2}{E_r}.\n$$\n该统计量源于对数似然比的二阶泰勒展开，该似然比用于比较具有相等概率的多项模型与频数的经验分布。在零假设下，且对于足够大的期望频数，$T$ 在分布上收敛于一个卡方分布，其自由度等于单元格数量减一。在这里，频数必须满足约束条件 $\\sum_{r=0}^{M} O_r = N$，这减少了一个自由度，从而得到\n$$\n\\text{degrees of freedom} = (M+1) - 1 = M.\n$$\n\n该检验的 $p$ 值是一个自由度为 $M$ 的卡方随机变量超过观测统计量的上尾概率：\n$$\np = \\Pr\\left(\\chi^2_M \\ge T\\right).\n$$\n在显著性水平 $\\alpha = 0.05$ 下的决策规则是：\n$$\n\\text{reject} = \\begin{cases}\n\\text{true},  \\text{if } p  \\alpha, \\\\\n\\text{false},  \\text{otherwise}.\n\\end{cases}\n$$\n\n针对给定测试用例实现该检验的算法步骤：\n1. 读取 $M$ 和频数列表 $[O_0, O_1, \\dots, O_M]$；验证列表长度为 $M+1$ 且频数为非负整数。\n2. 计算 $N = \\sum_{r=0}^{M} O_r$ 和 $k = M+1$。\n3. 计算每个区间的期望频数 $E = N/k$。由于所有区间的期望频数相等，因此对于所有 $r$，$E_r = E$。\n4. 计算卡方统计量：\n   $$\n   T = \\sum_{r=0}^{M} \\frac{(O_r - E)^2}{E}.\n   $$\n5. 设置自由度 $\\text{df} = M$。\n6. 将 $p$ 值计算为卡方分布的生存函数（上尾）：\n   $$\n   p = \\Pr\\left(\\chi^2_{\\text{df}} \\ge T\\right).\n   $$\n   在数值上，这可以通过卡方分布的生存函数获得。\n7. 将 $p$ 与 $\\alpha = 0.05$ 进行比较，并设置 $\\text{reject} = (p  \\alpha)$。\n8. 将 $T$ 和 $p$ 四舍五入到六位小数。\n9. 按规定格式，将每个测试用例的结果输出为 $[T, \\text{df}, p, \\text{reject}]$，并汇总到单行中。\n\n解释测试套件：\n- 案例 1 的频数完全均匀，因此 $T = 0$ 且 $p = 1$，不拒绝原假设。\n- 案例 2 的频数集中在低秩区间，导致 $T$ 值很大，$p$ 值很小，表明非均匀性，应拒绝原假设。\n- 案例 3 的期望频数非常小，$E = 1$，得出 $T = 0$ 且 $p = 1$，但渐近近似在这种情况下是不可靠的；尽管如此，计算仍按规定进行。\n- 案例 4 中，一半区间的频数为零，另一半的频数是期望值的两倍，这会产生一个相当大的 $T$ 值和很小的 $p$ 值。\n- 案例 5 使用了最少数量的非平凡区间（$M=1$），其中不平衡会产生很大的 $T$ 值和反对均匀性的强有力证据。\n\n此过程是一种有原则的集合诊断方法：秩柱状图均匀性检验评估了预报的可靠性，而可靠性是数值天气预报和气候模拟中概率预报的核心原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\nALPHA = 0.05\n\ndef chi_square_rank_uniformity(m: int, counts: np.ndarray):\n    \"\"\"\n    Compute Pearson chi-square test for uniformity of rank histograms.\n\n    Parameters:\n        m (int): Ensemble size (number of members), yielding m+1 rank bins.\n        counts (np.ndarray): Observed counts per rank bin of length m+1.\n\n    Returns:\n        tuple: (T_rounded, df, p_rounded, reject_bool)\n    \"\"\"\n    # Validate length\n    k = m + 1\n    if counts.shape[0] != k:\n        raise ValueError(\"Counts length must be M+1.\")\n    # Validate nonnegative integer counts\n    if np.any(counts  0) or not np.all(np.equal(counts, np.floor(counts))):\n        raise ValueError(\"Counts must be nonnegative integers.\")\n\n    n = int(np.sum(counts))\n    # Expected count per bin under uniformity\n    E = n / k\n    # Handle the degenerate case n == 0 (not present in test suite), avoid division by zero\n    if E == 0:\n        T = 0.0\n    else:\n        diffs = counts - E\n        T = float(np.sum((diffs * diffs) / E))\n\n    df = m\n    # Upper-tail p-value\n    p = float(chi2.sf(T, df))\n\n    # Decision based on the unrounded p-value\n    reject = p  ALPHA\n\n    # Round floats to six decimals for output\n    T_rounded = round(T, 6)\n    p_rounded = round(p, 6)\n    \n    return T_rounded, df, p_rounded, reject\n\ndef format_nested_no_spaces(results):\n    \"\"\"\n    Format a nested list of results into a single string with no spaces,\n    where booleans are rendered as True/False and floats have six decimals.\n    \"\"\"\n    def fmt_item(x):\n        if isinstance(x, list):\n            return '[' + ','.join(fmt_item(y) for y in x) + ']'\n        elif isinstance(x, bool):\n            return 'True' if x else 'False'\n        elif isinstance(x, float):\n            # Ensure six decimal places\n            return f\"{x:.6f}\"\n        elif isinstance(x, int):\n            return str(x)\n        else:\n            # Fallback for other types\n            return str(x)\n    return '[' + ','.join(fmt_item(elem) for elem in results) + ']'\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (9, [100,100,100,100,100,100,100,100,100,100]),\n        (9, [300,120,100,90,90,80,70,60,50,40]),\n        (4, [1,1,1,1,1]),\n        (19, [4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0]),\n        (1, [45,5]),\n    ]\n\n    results = []\n    for m, counts_list in test_cases:\n        counts = np.array(counts_list, dtype=float)\n        T, df, p, reject = chi_square_rank_uniformity(m, counts)\n        # Store with formatting constraint: floats will be printed with six decimals\n        results.append([T, df, p, reject])\n\n    # Final print statement in the exact required format: no spaces.\n    print(format_nested_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "在前一个练习的基础上，本节将探讨一个更高级的主题。虽然卡方 ($\\chi^2$) 检验被广泛使用，但其统计有效性依赖于可能在典型集合预报规模下不成立的渐近假设。这个基于模拟的练习 ([@problem-id:4079028]) 将挑战你研究这种“离散化偏差”(discretization bias)，从而培养对标准统计工具在真实场景中应用的批判性视角。",
            "id": "4079028",
            "problem": "您的任务是通过排序直方图和标准的均匀性检验，量化集合大小如何影响概率预报的可靠性评估，并重点关注由有限的离散区间引起的离散化偏差。考虑一个包含 $M$ 个成员的集合预报，以及每个预报案例对应一个验证观测值。在预报可靠性的前提下（观测值和集合成员独立地从同一分布中抽样），观测值在排序后的集合成员中的排序值在集合 $\\{0,1,\\dots,M\\}$ 上服从离散均匀分布。因此，在 $N$ 个预报案例上收集的排序直方图有 $M+1$ 个区间，每个区间 $i$ 的期望概率相等，为 $p_i = 1/(M+1)$。一种常用的均匀性检验是皮尔逊卡方 (Pearson $\\chi^2$) 检验，它将观测到的区间计数与均匀性零假设下的期望计数进行比较。在实践中，该检验使用渐近卡方分布作为其参考分布。当期望区间计数较小时，排序值的离散性（取决于 $M$）和有限的 $N$ 会导致检验统计量的真实有限样本分布与其渐近参考分布之间产生差异；这种差异表现为名义显著性水平与经验第一类错误拒绝率之间的差值。我们将此差值定义为在给定集合大小下，均匀性检验的离散化偏差。\n\n从以下基本基础开始：\n\n- 在可靠性条件下，观测值 $y$ 和每个集合成员 $e_m$ 都是从一个共同的连续分布（例如，标准正态分布）中独立同分布地抽取的。$y$ 在 $M$ 个集合成员中的排序值 $R$ 由 $R = \\sum_{m=1}^{M} \\mathbf{1}\\{e_m  y\\}$ 给出，当分布是连续且出现平局的概率为零时，该排序值在 $\\{0,\\dots,M\\}$ 上是离散均匀的。\n\n- 对于 $N$ 个独立的预报案例，产生的排序值为 $R_j$（其中 $j=1,\\dots,N$），区间计数 $(O_0,\\dots,O_M)$ 在可靠性条件下，作为一个多项式随机向量分布，其参数为 $N$ 和类别概率 $p_i = 1/(M+1)$。\n\n- 皮尔逊卡方统计量定义为\n$$\nX^2 = \\sum_{i=0}^{M} \\frac{(O_i - E_i)^2}{E_i},\n$$\n其中 $E_i = N p_i = N/(M+1)$ 是期望区间计数。在具有相等类别概率的多项式模型下，$X^2$ 的精确期望为 $\\mathbb{E}[X^2] = M$，但当期望计数较小时，其有限样本分布与具有 $M$ 个自由度的渐近卡方分布不同。\n\n编写一个完整的程序，完成以下任务：\n\n- 对于每个指定的测试用例，模拟 $R$ 次独立的蒙特卡洛复制。在每次复制中，生成 $N$ 个预报案例，集合大小为 $M$，其中集合成员 $e_m$ 和验证观测值 $y$ 均为标准正态分布 $\\mathcal{N}(0,1)$ 的独立抽样。对于每个案例，计算排序值 $R_j = \\sum_{m=1}^{M} \\mathbf{1}\\{e_{j,m}  y_j\\}$，其中 $j=1,\\dots,N$。在 $N$ 个案例上累积一个排序直方图 $(O_0,\\dots,O_M)$，然后计算皮尔逊 $X^2$ 统计量，其中所有区间 $i$ 的 $E_i = N/(M+1)$，并使用具有 $M$ 个自由度的渐近卡方阈值 $q_{1-\\alpha}$ 在显著性水平 $\\alpha$ 下做出拒绝决策。在 $R$ 次复制中，估计经验第一类错误拒绝率 $\\hat{\\rho}$，并以小数形式（非百分比）报告离散化偏差 $\\hat{b} = \\hat{\\rho} - \\alpha$。\n\n- 使用固定的随机种子以确保可复现性。\n\n- 所有结果均以小数表示，并将所有测试用例的输出聚合到指定格式的单行中。\n\n测试套件：\n\n- 对整个模拟使用固定的随机种子 $42$。\n\n- 每个测试用例使用 $R = 500$ 次蒙特卡洛复制。\n\n- 使用以下测试用例，全部在可靠性假设下（观测值和集合成员独立地从 $\\mathcal{N}(0,1)$ 中抽样），名义显著性水平 $\\alpha = 0.1$：\n\n    1. $(M, N, \\alpha) = (1, 200, 0.1)$\n\n    2. $(M, N, \\alpha) = (2, 200, 0.1)$\n\n    3. $(M, N, \\alpha) = (10, 200, 0.1)$\n\n    4. $(M, N, \\alpha) = (50, 200, 0.1)$\n\n    5. $(M, N, \\alpha) = (50, 100, 0.1)$\n\n要求的最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含每个测试用例的离散化偏差 $\\hat{b}$，顺序与上面列出的一致，每个值四舍五入到 $4$ 位小数，例如 $[\\hat{b}_1,\\hat{b}_2,\\hat{b}_3,\\hat{b}_4,\\hat{b}_5]$。\n\n科学真实性和自洽性：\n\n- 使用连续分布（标准正态分布 $\\mathcal{N}(0,1)$），使得平局的概率为零，确保在可靠性条件下排序分布是精确的离散均匀分布。\n\n- 基于模拟的离散化偏差估计是合理的，因为在多项式模型下，$X^2$ 的有限样本分布与渐近卡方分布不同，尤其是在期望计数 $E_i$ 较小（当 $M$ 大或 $N$ 小时）的情况下。\n\n您的任务是准确地实现这个模拟，遵守指定的参数和输出格式。此问题不涉及物理单位或角度单位。",
            "solution": "该问题是有效的。它在科学上基于统计假设检验和集合预报验证的原理，问题陈述清晰，所有必要的参数和方法都已指定，并且其表述是客观的。我们将着手提供一个解决方案。\n\n目标是量化应用于集合预报排序直方图的皮尔逊 $\\chi^2$ 均匀性检验的离散化偏差。该偏差表示为 $\\hat{b}$，是经验第一类错误率 $\\hat{\\rho}$ 与名义显著性水平 $\\alpha$ 之间的差值。它的产生是因为检验统计量的有限样本分布偏离了其假定的渐近 $\\chi^2$ 分布，尤其是在期望区间计数较低时。此分析通过蒙特卡洛模拟进行。\n\n该方法的核心是在完美预报可靠性的零假设下模拟生成排序直方图的过程，然后执行 $\\chi^2$ 检验。此过程重复多次以估计真实的拒绝率。\n\n对于由特定集合大小 $M$、预报案例数 $N$ 和显著性水平 $\\alpha$ 定义的每个测试用例，模拟程序如下：\n\n1.  **初始化**：我们执行 $R = 500$ 次独立的蒙特卡洛复制。假设检验的名义显著性水平固定为 $\\alpha = 0.1$。用于记录拒绝次数的计数器初始化为 $0$。\n\n2.  **确定临界值**：使用皮尔逊 $\\chi^2$ 统计量来检验均匀性的零假设。该统计量的渐近参考分布是具有 $M$ 个自由度的卡方分布，即 $\\chi^2_M$。自由度的计算方式是区间数 ($M+1$) 减 $1$，因为区间概率是由零假设预先指定的，而不是从数据中估计的。如果计算出的统计量 $X^2$ 超过临界值 $q_{1-\\alpha}$（即 $\\chi^2_M$ 分布的 $(1-\\alpha)$-分位数），则拒绝零假设。该值会为每个测试用例预先计算。\n\n3.  **蒙特卡洛复制**：对于 $R$ 次复制中的每一次：\n    a. **数据生成**：我们模拟 $N$ 个预报-验证对。对于每一对 $j=1, \\dots, N$，我们生成 $M$ 个集合成员 $\\{e_{j,m}\\}_{m=1}^M$ 和一个验证观测值 $y_j$。根据问题的可靠性假设，所有 $M+1$ 个值都是来自标准正态分布 $\\mathcal{N}(0, 1)$ 的独立抽样。此设置完美满足零假设。\n\n    b. **排序值计算**：对于 $N$ 对中的每一对，计算观测值 $y_j$ 相对于其对应集合成员的排序值。排序值 $R_j$ 是小于观测值的集合成员数量：$R_j = \\sum_{m=1}^{M} \\mathbf{1}\\{e_{j,m}  y_j\\}$。由于基础分布是连续的，平局的概率为零，排序值 $R_j$ 是集合 $\\{0, 1, \\dots, M\\}$ 中的一个整数。\n\n    c. **排序直方图**：将计算出的 $N$ 个排序值聚合到一个排序直方图中，该直方图包含 $M+1$ 个计数 $(O_0, O_1, \\dots, O_M)$，其中每个 $O_i$ 是排序值等于 $i$ 的次数。\n\n    d. **卡方检验**：使用以下公式计算皮尔逊 $\\chi^2$ 统计量：\n    $$\n    X^2 = \\sum_{i=0}^{M} \\frac{(O_i - E_i)^2}{E_i}\n    $$\n    这里，$O_i$ 是排序直方图中的观测计数。在均匀性的零假设下，每个区间 $i$ 的期望计数是相同的：$E_i = N \\times p_i = N/(M+1)$。\n\n    e. **假设决策**：将计算出的 $X^2$ 值与预先确定的临界值 $q_{1-\\alpha}$ 进行比较。如果 $X^2 > q_{1-\\alpha}$，则在此次复制中拒绝零假设，并将拒绝计数器加一。\n\n4.  **偏差计算**：完成所有 $R$ 次复制后，经验第一类错误拒绝率 $\\hat{\\rho}$ 被估计为总拒绝次数除以 $R$。然后，离散化偏差计算为此经验率与名义率的偏差：\n    $$\n    \\hat{b} = \\hat{\\rho} - \\alpha\n    $$\n\n这整个过程在提供的 Python 程序中实现。使用固定的随机种子确保了模拟结果的可复现性。程序会遍历指定的测试用例，为每个用例计算 $\\hat{b}$，并按要求格式化输出。为了提高计算效率，模拟采用了向量化处理，允许在单次复制内同时计算所有 $N$ 个排序值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef run_simulation_vectorized(M, N, R, alpha, rng):\n    \"\"\"\n    Runs the vectorized Monte Carlo simulation for a single test case.\n\n    Args:\n        M (int): The ensemble size.\n        N (int): The number of forecast cases.\n        R (int): The number of Monte Carlo replicates.\n        alpha (float): The nominal significance level.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The calculated discretization bias.\n    \"\"\"\n    num_bins = M + 1\n    rejection_count = 0\n    \n    # Degrees of freedom for the chi-squared test is M.\n    df = M\n    \n    # The chi-squared test is not defined for df=0.\n    if df == 0:\n        return -alpha\n\n    # Critical value from the asymptotic chi-squared distribution\n    critical_value = chi2.ppf(1 - alpha, df)\n    \n    expected_counts = N / num_bins\n    \n    for _ in range(R):\n        # Generate all random numbers for N forecast cases at once\n        ensemble_members = rng.standard_normal(size=(N, M))\n        observations = rng.standard_normal(size=(N, 1))\n        \n        # Calculate N ranks using vectorization and broadcasting.\n        # np.sum counts the number of ensemble members less than the observation for each case.\n        ranks = np.sum(ensemble_members  observations, axis=1)\n        \n        # Create the rank histogram (observed counts) using np.bincount.\n        # minlength ensures the array has M+1 bins even if high ranks don't occur.\n        observed_counts = np.bincount(ranks, minlength=num_bins)\n        \n        # Calculate Pearson's chi-squared statistic\n        if expected_counts  0:\n            chi_sq_stat = np.sum((observed_counts - expected_counts)**2 / expected_counts)\n        else: # This case will not be reached given N>0.\n            chi_sq_stat = 0.0\n\n        # Perform the hypothesis test by comparing with the critical value\n        if chi_sq_stat  critical_value:\n            rejection_count += 1\n            \n    # Estimate the empirical Type I rejection rate\n    empirical_rejection_rate = rejection_count / R\n    \n    # Calculate the discretization bias\n    discretization_bias = empirical_rejection_rate - alpha\n    \n    return discretization_bias\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    Initializes parameters, iterates through test cases, and prints the final result.\n    \"\"\"\n    # Define fixed parameters from the problem statement\n    random_seed = 42\n    num_replicates = 500\n    \n    # Initialize the random number generator with a fixed seed for reproducibility\n    rng = np.random.default_rng(random_seed)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (M, N, alpha)\n    test_cases = [\n        (1, 200, 0.1),\n        (2, 200, 0.1),\n        (10, 200, 0.1),\n        (50, 200, 0.1),\n        (50, 100, 0.1),\n    ]\n\n    results = []\n    for m_val, n_val, alpha_val in test_cases:\n        # Run the simulation for the current test case.\n        bias = run_simulation_vectorized(m_val, n_val, num_replicates, alpha_val, rng)\n        results.append(bias)\n\n    # Format the final output as a comma-separated list in brackets,\n    # with each result rounded to 4 decimal places.\n    formatted_results = [f'{res:.4f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main solver function.\nsolve()\n```"
        }
    ]
}