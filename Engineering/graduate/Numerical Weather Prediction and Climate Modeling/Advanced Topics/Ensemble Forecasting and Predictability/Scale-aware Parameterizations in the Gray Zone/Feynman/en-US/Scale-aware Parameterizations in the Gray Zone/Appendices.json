{
    "hands_on_practices": [
        {
            "introduction": "A central challenge in the gray zone is the potential for \"double counting,\" where turbulent transport is accounted for by both the resolved model dynamics and a parameterization scheme. This exercise provides a hands-on method to diagnose and quantify this issue. You will construct a numerical diagnostic to compare the momentum tendency from a resolved turbulent flux with the tendency from a non-scale-aware parameterization, revealing how their overlap changes with grid spacing $\\Delta x$ . This practice is fundamental to understanding why naive parameterizations fail in the gray zone and is a crucial first step in testing scale-aware alternatives.",
            "id": "4085719",
            "problem": "You are tasked with constructing and implementing a diagnostic that detects double counting of vertical momentum transport in the atmospheric \"gray zone\" by comparing resolved flux divergence with parameterized tendencies at varying horizontal grid spacing. The gray zone refers to scales where part of turbulent transport is resolved by the model dynamics while another part is still represented by parameterizations, leading to potential double counting. Your program must compute a quantitative index for this double counting and report it for a specified test suite.\n\nFundamental base:\n- Begin from the Reynolds-Averaged Navier–Stokes (RANS) momentum equation, whose vertical transport term for horizontal momentum involves the divergence of the vertical turbulent flux. In one-dimensional vertical form for a horizontal wind component, a resolved tendency is associated with the divergence of the resolved vertical momentum flux.\n- Common parameterizations represent unresolved vertical momentum transport using an eddy viscosity (first-order closure), producing a parameterized tendency proportional to the divergence of the vertical diffusive flux of momentum.\n\nDefinitions and setup:\n- Consider a one-dimensional vertical column with vertical coordinate $z$ over a depth $H$ discretized into $N$ equally spaced levels $z_i$ for $i = 0, 1, \\dots, N-1$ with spacing $\\Delta z = H/(N-1)$.\n- Let $F_{\\text{res}}(z; \\Delta x)$ denote a modeled resolved vertical flux of horizontal momentum (covariance of vertical and horizontal velocity fluctuations) at scale $\\Delta x$. Assume this flux has the form\n$$\nF_{\\text{res}}(z; \\Delta x) = S(\\Delta x)\\, F_0 \\exp\\!\\left(-\\frac{z}{H_e}\\right),\n$$\nwhere $F_0$ is a surface-level flux scale with units $\\mathrm{m^2\\,s^{-2}}$, $H_e$ is a vertical e-folding scale in $\\mathrm{m}$, and $S(\\Delta x)$ is a scale-partition function characterizing the resolved fraction of turbulent transport at horizontal grid spacing $\\Delta x$. Use\n$$\nS(\\Delta x) = \\frac{1}{1 + \\left(\\frac{\\Delta x}{L_t}\\right)^p},\n$$\nwith $L_t$ a turbulent length scale in $\\mathrm{m}$ and $p$ a positive exponent.\n- Let $K_m(z)$ denote an eddy viscosity profile with units $\\mathrm{m^2\\,s^{-1}}$:\n$$\nK_m(z) = K_0 \\left(\\frac{z}{H}\\right) \\exp\\!\\left(-\\frac{z}{H_k}\\right),\n$$\nwith $K_0$ a scale amplitude and $H_k$ a vertical decay scale.\n- Let the mean horizontal wind profile be\n$$\nu(z) = U_0 \\left(1 - \\exp\\!\\left(-\\frac{z}{z_0}\\right)\\right),\n$$\nwith $U_0$ a velocity scale in $\\mathrm{m\\,s^{-1}}$ and $z_0$ a shear scale in $\\mathrm{m}$.\n\nDiagnostic quantities:\n- Define the resolved tendency due to resolved vertical momentum transport as\n$$\nT_{\\text{res}}(z) = -\\frac{\\partial F_{\\text{res}}(z; \\Delta x)}{\\partial z}.\n$$\n- Define the parameterized tendency (unadjusted, i.e., without any scale-aware partition) using eddy viscosity closure as\n$$\nT_{\\text{param}}(z) = -\\frac{\\partial}{\\partial z}\\left( K_m(z)\\, \\frac{\\partial u}{\\partial z} \\right).\n$$\n- Construct a Double-Counting Index (DCI) that measures the overlap of the two tendencies when they act in the same sign (reinforcing each other), normalized by their combined magnitudes:\n$$\n\\mathrm{DCI} = \\frac{\\sum_{i=0}^{N-1} \\left[ \\mathcal{H}\\!\\left(T_{\\text{res},i}\\, T_{\\text{param},i}\\right) \\cdot \\min\\!\\left(\\left|T_{\\text{res},i}\\right|, \\left|T_{\\text{param},i}\\right|\\right) \\right]}{\\sum_{i=0}^{N-1} \\left( \\left|T_{\\text{res},i}\\right| + \\left|T_{\\text{param},i}\\right| \\right)},\n$$\nwhere $\\mathcal{H}(\\cdot)$ is the Heaviside step function taking value $1$ if its argument is strictly positive and $0$ otherwise. If the denominator is zero, define $\\mathrm{DCI} = 0$ by convention. The DCI is a dimensionless decimal fraction in $[0, 0.5]$.\n\nNumerical requirements:\n- Approximate all needed vertical derivatives using second-order accurate finite differences with one-sided differences at the boundaries $z=0$ and $z=H$. At interior points $z_i$ for $i=1$ to $i=N-2$, use centered differences. At boundaries, use first-order one-sided differences consistent with the grid spacing $\\Delta z$.\n- Do not apply any scale partition to $T_{\\text{param}}(z)$; the diagnostic’s purpose is to detect double counting arising from the naive parameterized tendency overlapping with the resolved tendency as $\\Delta x$ varies.\n- All physical units must be consistent: $z$, $H$, $H_e$, $H_k$, $L_t$, and $z_0$ in $\\mathrm{m}$; $U_0$ in $\\mathrm{m\\,s^{-1}}$; $K_0$ in $\\mathrm{m^2\\,s^{-1}}$; $F_0$ in $\\mathrm{m^2\\,s^{-2}}$; tendencies $T_{\\text{res}}$ and $T_{\\text{param}}$ in $\\mathrm{m\\,s^{-2}}$. The final DCI is unitless and must be expressed as a decimal fraction.\n\nParameter values:\n- Use $H = 2000\\,\\mathrm{m}$, $N = 64$, $F_0 = 0.3\\,\\mathrm{m^2\\,s^{-2}}$, $H_e = 600\\,\\mathrm{m}$, $K_0 = 10\\,\\mathrm{m^2\\,s^{-1}}$, $H_k = 500\\,\\mathrm{m}$, $U_0 = 15\\,\\mathrm{m\\,s^{-1}}$, $z_0 = 100\\,\\mathrm{m}$, $L_t = 400\\,\\mathrm{m}$, and $p = 1.5$. These values are scientifically plausible for a convective boundary layer scenario.\n\nTest suite:\nImplement the diagnostic and compute $\\mathrm{DCI}$ for the following four cases:\n- Case A (happy path): $\\Delta x = 1000\\,\\mathrm{m}$, with the baseline parameters specified above.\n- Case B (fine-grid gray zone): $\\Delta x = 250\\,\\mathrm{m}$, with the baseline parameters specified above.\n- Case C (coarse-grid limit): $\\Delta x = 8000\\,\\mathrm{m}$, with the baseline parameters specified above.\n- Case D (edge case: no transport): $\\Delta x = 1000\\,\\mathrm{m}$, but set $F_0 = 0.0\\,\\mathrm{m^2\\,s^{-2}}$ and $U_0 = 0.0\\,\\mathrm{m\\,s^{-1}}$; all other parameters as baseline. This case should yield a diagnostic value of $0.0$ under the given convention.\n\nOutput specification:\n- Your program should produce a single line of output containing the four $\\mathrm{DCI}$ values for Cases A–D, formatted as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (e.g., $[0.123456,0.234567,0.000000,0.456789]$). The DCI must be expressed as a decimal fraction without a percentage sign.",
            "solution": "The task is grounded in the Reynolds-Averaged Navier–Stokes (RANS) momentum equation, where vertical momentum transport of a horizontal wind component is represented by the divergence of the vertical turbulent flux. In a one-dimensional vertical column, the resolved tendency associated with turbulent transport is given by $-\\partial F_{\\text{res}}/\\partial z$, where $F_{\\text{res}}$ is the resolved vertical momentum flux. Simultaneously, parameterizations approximate the unresolved turbulent transport via an eddy viscosity closure, yielding a parameterized tendency $-\\partial/\\partial z(K_m\\, \\partial u/\\partial z)$.\n\nIn the gray zone, the resolved portion of turbulent transport increases as the horizontal grid spacing $\\Delta x$ decreases, while parameterizations often continue to apply a substantial tendency. If both the resolved tendency and the parameterized tendency act in the same direction (i.e., have the same sign) in a given layer, their combined effect can double count the transport. The proposed Double-Counting Index (DCI) quantifies the overlapping magnitude of these tendencies only when they reinforce each other, normalized by their total magnitude. This creates a dimensionless decimal fraction that is zero when there is no overlapping reinforcement and rises towards an upper bound of $0.5$ when both tendencies are identical and act in the same direction.\n\nStep-by-step derivation and algorithm:\n\n1) Vertical discretization:\n- Define $N$ equally spaced levels $z_i$ with $z_0 = 0$, $z_{N-1} = H$, and spacing $\\Delta z = H/(N-1)$.\n\n2) Resolved flux model:\n- Use the scale-partition function $S(\\Delta x) = 1/(1 + (\\Delta x/L_t)^p)$ to represent the fraction of turbulent transport that is resolved given the horizontal grid spacing $\\Delta x$, turbulent length scale $L_t$, and exponent $p$.\n- Define the resolved vertical momentum flux:\n$$\nF_{\\text{res}}(z_i; \\Delta x) = S(\\Delta x)\\, F_0 \\exp\\!\\left(-\\frac{z_i}{H_e}\\right).\n$$\nThis captures a surface-intensified flux that decays with height and scales with the resolved fraction.\n\n3) Eddy viscosity parameterization and mean wind profile:\n- Define $K_m(z_i) = K_0 (z_i/H)\\exp(-z_i/H_k)$, representing mixing that grows from the surface then decays aloft.\n- Define the mean wind $u(z_i) = U_0 (1 - \\exp(-z_i/z_0))$, which increases from near-zero at the surface toward an asymptote set by $U_0$.\n\n4) Numerical differentiation:\n- Compute $\\partial F_{\\text{res}}/\\partial z$ with second-order accurate finite differences:\n  - For interior points $i = 1, \\dots, N-2$, use the centered difference\n  $$\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_i} \\approx \\frac{F_{\\text{res}}(z_{i+1}) - F_{\\text{res}}(z_{i-1})}{2\\Delta z}.\n  $$\n  - For boundaries, use one-sided differences:\n  $$\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_0} \\approx \\frac{F_{\\text{res}}(z_{1}) - F_{\\text{res}}(z_{0})}{\\Delta z}, \\quad\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_{N-1}} \\approx \\frac{F_{\\text{res}}(z_{N-1}) - F_{\\text{res}}(z_{N-2})}{\\Delta z}.\n  $$\n- Compute $\\partial u/\\partial z$ similarly via centered differences at interior points and one-sided differences at boundaries.\n- Form the diffusive flux of momentum $K_m\\, \\partial u/\\partial z$ at each level, then compute its vertical derivative $\\partial/\\partial z(K_m\\, \\partial u/\\partial z)$ with the same finite-difference scheme.\n\n5) Tendencies:\n- The resolved tendency is\n$$\nT_{\\text{res}}(z_i) = -\\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_i}.\n$$\n- The parameterized tendency (naive, unadjusted) is\n$$\nT_{\\text{param}}(z_i) = -\\left.\\frac{\\partial}{\\partial z}\\left( K_m\\, \\frac{\\partial u}{\\partial z} \\right)\\right|_{z_i}.\n$$\n\n6) Double-Counting Index (DCI):\n- Define the Heaviside function $\\mathcal{H}(x)$ as $1$ if $x > 0$ and $0$ otherwise.\n- Compute\n$$\n\\mathrm{DCI} = \\frac{\\sum_{i=0}^{N-1} \\left[ \\mathcal{H}\\!\\left(T_{\\text{res},i}\\, T_{\\text{param},i}\\right) \\cdot \\min\\!\\left(\\left|T_{\\text{res},i}\\right|, \\left|T_{\\text{param},i}\\right|\\right) \\right]}{\\sum_{i=0}^{N-1} \\left( \\left|T_{\\text{res},i}\\right| + \\left|T_{\\text{param},i}\\right| \\right)}.\n$$\n- If the denominator is zero (i.e., both tendencies are zero everywhere), set $\\mathrm{DCI} = 0$.\n\n7) Interpretation:\n- $\\mathrm{DCI} \\in [0, 0.5]$ since at each level the overlap contribution is bounded above by the smaller of the two magnitudes, and the denominator counts the sum of magnitudes.\n- Larger $\\mathrm{DCI}$ indicates greater potential double counting from overlapping tendencies acting in the same direction. As $\\Delta x$ decreases, $S(\\Delta x)$ increases, enhancing $F_{\\text{res}}$ and $T_{\\text{res}}$, so the naive $T_{\\text{param}}$ is more likely to overlap and increase $\\mathrm{DCI}$.\n- As $\\Delta x$ increases (coarser grid), $S(\\Delta x)$ decreases, reducing $T_{\\text{res}}$, leading to smaller overlap and $\\mathrm{DCI}$.\n\n8) Test suite execution:\n- Use the specified baseline parameters $H = 2000\\,\\mathrm{m}$, $N = 64$, $F_0 = 0.3\\,\\mathrm{m^2\\,s^{-2}}$, $H_e = 600\\,\\mathrm{m}$, $K_0 = 10\\,\\mathrm{m^2\\,s^{-1}}$, $H_k = 500\\,\\mathrm{m}$, $U_0 = 15\\,\\mathrm{m\\,s^{-1}}$, $z_0 = 100\\,\\mathrm{m}$, $L_t = 400\\,\\mathrm{m}$, $p = 1.5$ for Cases A–C, with $\\Delta x$ set to $1000\\,\\mathrm{m}$, $250\\,\\mathrm{m}$, and $8000\\,\\mathrm{m}$ respectively. For Case D, set $F_0 = 0.0\\,\\mathrm{m^2\\,s^{-2}}$ and $U_0 = 0.0\\,\\mathrm{m\\,s^{-1}}$ while keeping $\\Delta x = 1000\\,\\mathrm{m}$ and other parameters unchanged.\n- Compute and round each $\\mathrm{DCI}$ to six decimal places.\n\n9) Output:\n- Print a single line with the list $[\\mathrm{DCI}_A, \\mathrm{DCI}_B, \\mathrm{DCI}_C, \\mathrm{DCI}_D]$ as comma-separated decimal fractions enclosed in square brackets, each rounded to six decimal places, consistent with the specified units and format requirements.\n\nThis algorithm integrates the fundamental physics of vertical momentum transport from the Reynolds-averaged formulation with a practical, scale-aware diagnostic that is numerically robust via second-order finite differences and yields a quantifiable, unitless measure of double counting across varying $\\Delta x$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef finite_difference_first_derivative(y, dz):\n    \"\"\"\n    Compute first derivative dy/dz using second-order accurate scheme\n    with centered differences in the interior and one-sided at boundaries.\n    y: array of length N\n    dz: scalar grid spacing\n    Returns dy_dz: array of length N\n    \"\"\"\n    N = y.size\n    dy_dz = np.empty_like(y)\n\n    if N < 2:\n        # Degenerate case; no derivative possible\n        dy_dz[:] = 0.0\n        return dy_dz\n\n    # One-sided difference at bottom boundary\n    dy_dz[0] = (y[1] - y[0]) / dz\n    # Centered differences in the interior\n    if N > 2:\n        dy_dz[1:-1] = (y[2:] - y[:-2]) / (2.0 * dz)\n    else:\n        # If N == 2, we only have boundaries\n        pass\n    # One-sided difference at top boundary\n    dy_dz[-1] = (y[-1] - y[-2]) / dz\n\n    return dy_dz\n\ndef compute_profiles(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx):\n    \"\"\"\n    Compute vertical profiles for z, Fres(z; dx), Km(z), u(z).\n    \"\"\"\n    z = np.linspace(0.0, H, N)\n    dz = z[1] - z[0] if N > 1 else 1.0\n\n    # Scale-partition function S(dx)\n    S = 1.0 / (1.0 + (dx / Lt) ** p)\n\n    # Resolved vertical momentum flux Fres(z; dx)\n    Fres = S * F0 * np.exp(-z / He)\n\n    # Eddy viscosity profile Km(z)\n    Km = K0 * (z / H) * np.exp(-z / Hk)\n\n    # Mean wind profile u(z)\n    u = U0 * (1.0 - np.exp(-z / z0))\n\n    return z, dz, Fres, Km, u\n\ndef compute_tendencies(z, dz, Fres, Km, u):\n    \"\"\"\n    Compute Tres(z) = - dFres/dz and Tparam(z) = - d/dz ( Km * du/dz ).\n    \"\"\"\n    # dFres/dz\n    dF_dz = finite_difference_first_derivative(Fres, dz)\n    Tres = -dF_dz\n\n    # du/dz\n    du_dz = finite_difference_first_derivative(u, dz)\n    # Diffusive flux of momentum: Km * du/dz\n    diff_flux = Km * du_dz\n    # d/dz of diffusive flux\n    d_diff_flux_dz = finite_difference_first_derivative(diff_flux, dz)\n    Tparam = -d_diff_flux_dz\n\n    return Tres, Tparam\n\ndef double_counting_index(Tres, Tparam):\n    \"\"\"\n    Compute DCI as sum(H(Tres*Tparam) * min(|Tres|, |Tparam|)) / sum(|Tres| + |Tparam|)\n    If denominator is zero, return 0.0\n    \"\"\"\n    overlap_mask = (Tres * Tparam) > 0.0\n    overlap_contrib = np.minimum(np.abs(Tres), np.abs(Tparam))\n    numerator = np.sum(overlap_contrib[overlap_mask])\n    denominator = np.sum(np.abs(Tres) + np.abs(Tparam))\n    if denominator == 0.0:\n        return 0.0\n    return numerator / denominator\n\ndef run_case(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx):\n    z, dz, Fres, Km, u = compute_profiles(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx)\n    Tres, Tparam = compute_tendencies(z, dz, Fres, Km, u)\n    dci = double_counting_index(Tres, Tparam)\n    return dci\n\ndef solve():\n    # Baseline parameters\n    H = 2000.0      # m\n    N = 64\n    F0 = 0.3        # m^2/s^2\n    He = 600.0      # m\n    K0 = 10.0       # m^2/s\n    Hk = 500.0      # m\n    U0 = 15.0       # m/s\n    z0 = 100.0      # m\n    Lt = 400.0      # m\n    p = 1.5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: dx=1000 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 1000.0},\n        # Case B: dx=250 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 250.0},\n        # Case C: dx=8000 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 8000.0},\n        # Case D: dx=1000 m, no transport (F0=0, U0=0)\n        {\"H\": H, \"N\": N, \"F0\": 0.0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": 0.0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 1000.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        dci = run_case(**case)\n        results.append(dci)\n\n    # Final print statement in the exact required format, rounded to six decimals.\n    formatted = \",\".join(f\"{r:.6f}\" for r in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "After diagnosing a problem like double counting, the next step is to design a solution. This practice guides you through the process of creating a simple yet robust scale-aware mass-flux coefficient for a convection parameterization. You will first analyze a simulated velocity field to determine the \"resolved updraft fraction,\" and then use this information, along with a grid-scale ratio, to engineer a mathematical function that intelligently tapers the parameterized convection as the model begins to resolve it explicitly . This exercise sharpens your ability to translate core physical principles into functional code, a key skill for a modern atmospheric modeler.",
            "id": "4085754",
            "problem": "You are given a discrete representation of a simulated vertical velocity perturbation field for use in Numerical Weather Prediction (NWP) and climate modeling. The aim is to compute a resolved updraft fraction from an updraft mask based on a strict threshold, and then design a scale-aware mass-flux coefficient that depends on this fraction and on the ratio between the model grid spacing and a convective length scale. Work in purely mathematical terms with the following base definitions and constraints that are consistent with established practice in the gray zone of deep convection. Use standard physical units where specified.\n\nFundamental base and definitions:\n- Let the vertical velocity be decomposed as $w = \\overline{w} + w'$, where $w'$ is the vertical velocity perturbation and $\\overline{w}$ is a slowly varying mean. You are provided with discrete samples of $w'$ in each grid box.\n- Define a strict updraft mask by the indicator function $I = 1$ if $w' > w_0$ and $I = 0$ otherwise, with threshold $w_0$ expressed in meters per second $\\mathrm{m}\\,\\mathrm{s}^{-1}$.\n- On an equally weighted discrete grid with $N$ samples, define the resolved updraft fraction $f_{\\mathrm{res}}$ as the fraction of samples for which the mask is active.\n- Define a scale-aware parameterization designed to provide a mass-flux coefficient $k$ in inverse seconds $\\mathrm{s}^{-1}$ that supplements the resolved contribution by operating only on the unresolved fraction of the updraft area. The design must satisfy all of the following constraints:\n  1. $k$ must be bounded such that $0 \\le k \\le C_0$, where $C_0$ is a base coefficient with units $\\mathrm{s}^{-1}$.\n  2. $k$ must be a monotonically nonincreasing function of $f_{\\mathrm{res}}$ and must satisfy the limiting behaviors $k \\to C_0$ as $f_{\\mathrm{res}} \\to 0$, and $k \\to 0$ as $f_{\\mathrm{res}} \\to 1$.\n  3. $k$ must depend smoothly on the non-dimensional grid-to-convective-scale ratio $r = \\Delta / L_c$, where $\\Delta$ is the grid spacing in meters $\\mathrm{m}$ and $L_c$ is a convective length scale in meters $\\mathrm{m}$. The dependence must be such that parameterized contribution diminishes as the grid resolves more of the convective motions, namely $k \\to 0$ as $\\Delta / L_c \\to 0$ for any fixed $f_{\\mathrm{res}} \\in (0,1)$, and $k \\to C_0 (1 - f_{\\mathrm{res}})$ as $\\Delta / L_c \\to +\\infty$.\n  4. The design should be characterized by a positive sensitivity exponent $p$ (dimensionless), controlling how rapidly $k$ transitions with scale.\n\nYour task:\n- For each test case, compute $f_{\\mathrm{res}}$ using the strict threshold $w' > w_0$.\n- Propose and implement a smooth functional form $k = \\mathcal{K}(f_{\\mathrm{res}}, \\Delta, L_c, C_0, p)$ consistent with the constraints above, ensuring correct dimensionality in $\\mathrm{s}^{-1}$.\n- Output, for each test case, a list containing two floating-point numbers: first $f_{\\mathrm{res}}$ (dimensionless), then $k$ (in $\\mathrm{s}^{-1}$).\n\nPhysical units:\n- The vertical velocity perturbations $w'$ and threshold $w_0$ are in $\\mathrm{m}\\,\\mathrm{s}^{-1}$.\n- The grid spacing $\\Delta$ and convective length $L_c$ are in $\\mathrm{m}$.\n- The base coefficient $C_0$ and the designed coefficient $k$ are in $\\mathrm{s}^{-1}$.\n\nAngle units are not applicable.\n\nTest suite:\nUse the following set of test cases to cover general behavior, limiting cases, and edge conditions. In each case, the list of $w'$ values is given in $\\mathrm{m}\\,\\mathrm{s}^{-1}$, the threshold $w_0$ is in $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $\\Delta$ and $L_c$ are in $\\mathrm{m}$, $C_0$ is in $\\mathrm{s}^{-1}$, and $p$ is dimensionless:\n- Case $1$ (general mixed field, gray-zone scale): $w' = [-0.2, 0.3, 0.7, 1.2, -0.1, 0.5, 0.0, -0.4, 0.8, -0.3]$, $w_0 = 0.5$, $\\Delta = 1000$, $L_c = 1000$, $C_0 = 0.005$, $p = 1$.\n- Case $2$ (coarse grid, no resolved updrafts): $w' = [-0.1, 0.4, 0.5, -0.2, 0.49]$, $w_0 = 0.5$, $\\Delta = 10000$, $L_c = 2000$, $C_0 = 0.006$, $p = 1$.\n- Case $3$ (all resolved updrafts): $w' = [0.6, 0.7, 0.8, 1.0]$, $w_0 = 0.5$, $\\Delta = 5000$, $L_c = 1000$, $C_0 = 0.004$, $p = 1$.\n- Case $4$ (threshold equality edge): $w' = [0.5, 0.5, 0.5, 0.49, 0.51]$, $w_0 = 0.5$, $\\Delta = 1000$, $L_c = 1500$, $C_0 = 0.005$, $p = 1$.\n- Case $5$ (fine grid, strong scale-awareness): $w' = [0.1, 0.6, 0.7, -0.1, 1.2, 0.4, 0.55, -0.2]$, $w_0 = 0.5$, $\\Delta = 200$, $L_c = 1000$, $C_0 = 0.01$, $p = 2$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list containing $[f_{\\mathrm{res}}, k]$. For example, your output should look like $[[f_1,k_1],[f_2,k_2],\\dots]$ with all numeric values represented as standard floating-point numbers.",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically grounded, well-posed, and objective. It presents a standard, albeit challenging, design task within the field of atmospheric modeling, specifically concerning the parameterization of sub-grid scale processes in the convection gray zone. The constraints provided for the design of the mass-flux coefficient are largely consistent, with a minor ambiguity in the interplay between limiting behaviors which can be resolved through a physically-sound interpretation. We may therefore proceed with a complete solution.\n\nThe solution is divided into two parts: first, the computation of the resolved updraft fraction $f_{\\mathrm{res}}$, and second, the design and implementation of a functional form for the scale-aware mass-flux coefficient $k$.\n\n**Part 1: Computation of the Resolved Updraft Fraction ($f_{\\mathrm{res}}$)**\n\nThe problem defines the resolved updraft fraction, $f_{\\mathrm{res}}$, as the fraction of grid points where the vertical velocity perturbation $w'$ exceeds a given threshold $w_0$. On a discrete grid with $N$ equally weighted samples of $w'$, this is computed by first defining an updraft mask via the indicator function $I_i$:\n$$\nI_i =\n\\begin{cases}\n1 & \\text{if } w'_i > w_0 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nwhere $w'_i$ is the $i$-th sample of the vertical velocity perturbation. The resolved updraft fraction is then the arithmetic mean of the indicator function over all $N$ samples:\n$$\nf_{\\mathrm{res}} = \\frac{1}{N} \\sum_{i=1}^{N} I_i\n$$\nThis calculation is performed for each test case using the provided list of $w'$ values and the corresponding $w_0$ threshold.\n\n**Part 2: Design of the Scale-Aware Mass-Flux Coefficient ($k$)**\n\nThe primary task is to design a smooth function $k = \\mathcal{K}(f_{\\mathrm{res}}, \\Delta, L_c, C_0, p)$ that satisfies a set of specific constraints. Let us analyze these constraints to guide the design. We define the non-dimensional scale ratio as $r = \\Delta / L_c$.\n\nThe constraints are:\n1.  **Boundedness**: $0 \\le k \\le C_0$.\n2.  **Dependence on $f_{\\mathrm{res}}$**: $k$ is a monotonically nonincreasing function of $f_{\\mathrm{res}}$. It must satisfy the limits $k \\to C_0$ as $f_{\\mathrm{res}} \\to 0$ and $k \\to 0$ as $f_{\\mathrm{res}} \\to 1$.\n3.  **Dependence on $r$**: $k$ is a smooth function of $r$. It must satisfy the limits $k \\to 0$ as $r \\to 0$ (fine-resolution limit) and $k \\to C_0 (1 - f_{\\mathrm{res}})$ as $r \\to +\\infty$ (coarse-resolution limit).\n4.  **Sensitivity**: A positive exponent $p$ controls the rate of transition with scale.\n\nA potential conflict exists between constraint 2 ($k \\to C_0$ as $f_{\\mathrm{res}} \\to 0$) and constraint 3 ($k \\to 0$ as $r \\to 0$) at the point $(r, f_{\\mathrm{res}}) = (0, 0)$, where the limit depends on the path taken. A standard interpretation in physical modeling is that the general constraints (like constraint 2) describe the behavior in the limit where the parameterization is fully active, i.e., the coarse-grid limit ($r \\to \\infty$). The coarse-grid limit from constraint 3, $k \\to C_0 (1 - f_{\\mathrm{res}})$ as $r \\to \\infty$, correctly yields $k \\to C_0$ as $f_{\\mathrm{res}} \\to 0$. Thus, we can synthesize the constraints by designing a function that correctly interpolates between the fine-grid behavior ($k=0$) and the coarse-grid behavior.\n\nLet's define the coarse-grid behavior as $k_{\\mathrm{coarse}}(f_{\\mathrm{res}}) = C_0 (1 - f_{\\mathrm{res}})$. This form already satisfies the monotonicity and limiting behaviors for $f_{\\mathrm{res}}$ requested for the coarse-grid limit.\n\nNow, we introduce a scale-dependent blending function, $S(r, p)$, which modulates this coarse-grid behavior. The function $S(r, p)$ must encapsulate the scale-awareness. It must satisfy:\n- $S(r, p) \\to 0$ as $r \\to 0$.\n- $S(r, p) \\to 1$ as $r \\to +\\infty$.\n- $S(r, p)$ must be a smooth, monotonically increasing function of $r$ for $r \\ge 0$.\n- The exponent $p$ should control the steepness of the transition.\n\nWe propose the following functional form for $k$:\n$$\nk = k_{\\mathrm{coarse}}(f_{\\mathrm{res}}) \\cdot S(r, p) = C_0 (1 - f_{\\mathrm{res}}) \\cdot S(r, p)\n$$\nA common and suitable choice for the blending function $S(r, p)$ that satisfies all its requirements is a rational function of the Hill-Langmuir type:\n$$\nS(r, p) = \\frac{r^p}{1 + r^p}\n$$\nThis function is smooth for $r \\ge 0$ (for integer $p \\ge 1$), transitions from $0$ to $1$ as $r$ goes from $0$ to $\\infty$, and the exponent $p$ controls the sharpness of the transition around $r=1$.\n\nTherefore, our final proposed functional form is:\n$$\nk(f_{\\mathrm{res}}, r, C_0, p) = C_0 (1 - f_{\\mathrm{res}}) \\frac{r^p}{1 + r^p}\n$$\nwhere $r = \\Delta / L_c$. This function satisfies all constraints under the physically consistent interpretation discussed. With $0 \\le f_{\\mathrm{res}} \\le 1$ and $0 \\le S(r,p) < 1$, the bound $0 \\le k < C_0$ is guaranteed.\n\nThe procedure for each test case is:\n1.  Compute $f_{\\mathrm{res}}$ from the given $w'$ array and $w_0$ threshold.\n2.  Compute the scale ratio $r = \\Delta / L_c$.\n3.  Substitute $f_{\\mathrm{res}}$, $r$, $C_0$, and $p$ into the derived formula for $k$ to compute its value.\n4.  Return the pair $[f_{\\mathrm{res}}, k]$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the resolved updraft fraction and a scale-aware mass-flux coefficient\n    for a series of test cases based on a derived functional form.\n    \"\"\"\n    test_cases = [\n        {'w_prime': [-0.2, 0.3, 0.7, 1.2, -0.1, 0.5, 0.0, -0.4, 0.8, -0.3], 'w0': 0.5, 'Delta': 1000, 'Lc': 1000, 'C0': 0.005, 'p': 1},\n        {'w_prime': [-0.1, 0.4, 0.5, -0.2, 0.49], 'w0': 0.5, 'Delta': 10000, 'Lc': 2000, 'C0': 0.006, 'p': 1},\n        {'w_prime': [0.6, 0.7, 0.8, 1.0], 'w0': 0.5, 'Delta': 5000, 'Lc': 1000, 'C0': 0.004, 'p': 1},\n        {'w_prime': [0.5, 0.5, 0.5, 0.49, 0.51], 'w0': 0.5, 'Delta': 1000, 'Lc': 1500, 'C0': 0.005, 'p': 1},\n        {'w_prime': [0.1, 0.6, 0.7, -0.1, 1.2, 0.4, 0.55, -0.2], 'w0': 0.5, 'Delta': 200, 'Lc': 1000, 'C0': 0.01, 'p': 2},\n    ]\n\n    results = []\n    \n    def mass_flux_coefficient(f_res, r, C0, p):\n        \"\"\"\n        Calculates the scale-aware mass-flux coefficient k based on the derived model.\n        k(f_res, r, C0, p) = C0 * (1 - f_res) * (r^p / (1 + r^p))\n        \"\"\"\n        # Handle the edge case r = 0 to avoid potential 0/0 or inf/inf with large p\n        if r == 0:\n            return 0.0\n            \n        scale_function = (r**p) / (1 + r**p)\n        k = C0 * (1 - f_res) * scale_function\n        return k\n\n    for case in test_cases:\n        w_prime = np.array(case['w_prime'])\n        w0 = case['w0']\n        Delta = case['Delta']\n        Lc = case['Lc']\n        C0 = case['C0']\n        p = case['p']\n\n        # Part 1: Compute the resolved updraft fraction (f_res)\n        num_samples = len(w_prime)\n        if num_samples == 0:\n            f_res = 0.0\n        else:\n            # Count samples where w' > w0 (strict inequality)\n            updraft_mask = w_prime > w0\n            num_updrafts = np.sum(updraft_mask)\n            f_res = num_updrafts / num_samples\n\n        # Part 2: Compute the mass-flux coefficient (k)\n        scale_ratio = Delta / Lc\n        k = mass_flux_coefficient(f_res, scale_ratio, C0, p)\n\n        # Format each result pair as [f_res, k]\n        results.append(f\"[{f_res},{k}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To move beyond simplified models and understand the fundamental physics of the gray zone, we must analyze the flow of energy across scales. This advanced exercise tasks you with computing the spectral energy flux, $\\Pi(k)$, in a simulated two-dimensional turbulent flow. The flux at the model's cutoff wavenumber, $\\Pi(k_\\Delta)$, represents the net energy transferred to unresolved scales—precisely the quantity a subgrid-scale parameterization aims to represent . By observing how $\\Pi(k_\\Delta)$ changes with resolution $\\Delta$, you will gain a foundational understanding of why the parameterization target itself is scale-dependent, providing a rigorous physical basis for scale-aware design.",
            "id": "4085750",
            "problem": "You are tasked with constructing a scientifically consistent and computationally testable measure of the spectral energy flux in a simulated turbulent flow, and then using it to assess gray-zone scale-awareness for parameterization design. Consider an incompressible, homogeneous, isotropic, periodic, $2$-dimensional flow on a square domain of side length $L = 2\\pi$ (nondimensional units). The velocity field $\\mathbf{u}(x,y)$ is divergence-free and derived from a streamfunction $\\psi(x,y)$ via the relations $\\mathbf{u} = (\\partial \\psi / \\partial y,\\,-\\partial \\psi / \\partial x)$. The incompressible Navier–Stokes equations with no external forcing and viscosity are\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p,\n$$\nwith $\\nabla\\cdot\\mathbf{u} = 0$. The kinetic energy density is $E = \\tfrac{1}{2}\\,\\mathbf{u}\\cdot\\mathbf{u}$. The spectral energy budget follows from Fourier transforming to wavenumber space $(k_x,k_y)$ and projecting onto the solenoidal (divergence-free) subspace to remove pressure. The nonlinear transfer function at wavenumber magnitude $k = \\sqrt{k_x^2 + k_y^2}$ can be defined from the solenoidal part of the advective acceleration. Under the Fast Fourier Transform (FFT) discretization on the periodic domain, the scalar energy transfer contribution per mode is obtained by the real part of the inner product of the velocity mode and the projected nonlinear mode, and the shell-integrated transfer is computed by summing over all modes whose radial wavenumber falls in an integer shell. The spectral energy flux $\\Pi(k_0)$ through a cutoff wavenumber $k_0$ is defined as the cumulative nonlinear energy transfer received by modes with wavenumber magnitude greater than $k_0$, namely a discrete shell-sum over all shells with $k > k_0$. Positive $\\Pi(k_0)$ indicates net forward transfer into unresolved small scales, while negative $\\Pi(k_0)$ indicates net inverse transfer into larger scales.\n\nYour program must:\n\n- Construct a single high-resolution divergence-free velocity field on an $N \\times N$ grid with $N = 256$ and $L = 2\\pi$, in nondimensional units, by building a streamfunction $\\psi(x,y)$ as a sum of a finite set of Fourier modes with wavenumber magnitudes in the band $k \\in [3,6]$ with random phases, and amplitudes that decay with increasing $k$ to ensure physical realism and numerical stability.\n- Compute the velocity field $\\mathbf{u}$ via spectral derivatives of $\\psi$.\n- Compute the advective acceleration $\\mathbf{A} = (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ using spectral derivatives for $\\nabla\\mathbf{u}$ and pointwise products in physical space. To mitigate aliasing, apply the two-thirds truncation rule to the nonlinear term: remove all Fourier components of $\\mathbf{A}$ where either $|k_x|$ or $|k_y|$ exceeds $N/3$.\n- Project the Fourier transform of $\\mathbf{A}$ onto the solenoidal subspace for each wavenumber using the projection operator $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\mathbf{k}\\mathbf{k}^\\top / |\\mathbf{k}|^2$ where $\\mathbf{k} = (k_x,k_y)$ and $|\\mathbf{k}|^2 = k_x^2 + k_y^2$, with the zero mode treated as no contribution. Define the nonlinear term used in the energy transfer as $\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\mathbf{P}(\\mathbf{k})\\,\\widehat{\\mathbf{A}}(\\mathbf{k})$.\n- Compute the spectral energy transfer per mode $T(\\mathbf{k})$ as the real part of the inner product $T(\\mathbf{k}) = \\Re\\left[\\widehat{\\mathbf{u}}(\\mathbf{k})^* \\cdot \\widehat{\\mathbf{N}}(\\mathbf{k})\\right]$, and bin $T(\\mathbf{k})$ into integer shells $k_s = \\mathrm{round}(\\sqrt{k_x^2 + k_y^2}) \\in \\mathbb{N}$ to obtain shell-summed transfers $T_s(k_s)$ for $k_s \\ge 1$.\n- For a given coarse-grid spacing $\\Delta = L / N_\\Delta$ with $N_\\Delta$ an even integer resolution, define the cutoff wavenumber $k_\\Delta = \\pi / \\Delta = N_\\Delta / 2$. Compute the spectral energy flux $\\Pi(k_\\Delta)$ as the cumulative shell sum over all shells with $k_s > k_\\Delta$, $\\Pi(k_\\Delta) = \\sum_{k_s > k_\\Delta} T_s(k_s)$, using the single high-resolution field just constructed (that is, always compute $\\Pi(k_\\Delta)$ from the same high-resolution $N=256$ field by summing over the appropriate high-resolution shells).\n- Express all outputs in nondimensional units, rounded to six decimal places.\n\nTest Suite and Output Specification:\n\n- Use the following set of coarse resolutions $N_\\Delta$: $\\{16, 32, 64, 96, 128, 256\\}$. For each $N_\\Delta$, compute $k_\\Delta = N_\\Delta / 2$ and then compute $\\Pi(k_\\Delta)$ as defined above from the high-resolution field.\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the order of the provided test suite resolutions. For example, the output must have the form $[\\pi_{16},\\pi_{32},\\pi_{64},\\pi_{96},\\pi_{128},\\pi_{256}]$ where each $\\pi_{N_\\Delta}$ is a decimal float rounded to six decimal places.\n\nInterpretation Requirement (to be reflected in your algorithmic choices and comments): The results should be interpreted in the context of scale-aware parameterizations in the gray zone, where $k_\\Delta$ shifts with $\\Delta$. A decrease in $|\\Pi(k_\\Delta)|$ as $\\Delta$ decreases indicates that less net transfer is crossing into unresolved scales, implying that a scale-aware closure should taper its contribution with resolution. Conversely, larger $|\\Pi(k_\\Delta)|$ at coarse resolution indicates stronger unresolved transfers requiring more aggressive parameterized dissipation. Your code must implement the computation as specified using only the high-resolution field and must not perform any time integration.\n\nAngle units are radians. All quantities are nondimensional. The final outputs must be floats rounded to six decimal places.",
            "solution": "We begin from the incompressible Navier–Stokes equations in nondimensional form on a periodic domain,\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p,\\quad \\nabla\\cdot\\mathbf{u}=0,\n$$\nwith kinetic energy density $E = \\tfrac{1}{2}\\mathbf{u}\\cdot\\mathbf{u}$. Taking the Fourier transform, we define the wavenumber vector $\\mathbf{k} = (k_x,k_y)$ where both components are integers when the physical domain length is $L=2\\pi$, because $\\widehat{f}(\\mathbf{k})$ is indexed by integer wave numbers with the Fast Fourier Transform (FFT) when the sample spacing is $d=L/N$. The energy transfer due to the nonlinear advection arises from the term $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$, which is not solenoidal; the pressure gradient enforces incompressibility by removing the irrotational component. Therefore, for energy budget consistency at each wavenumber, one must project the advective acceleration onto the solenoidal subspace with the projection operator\n$$\n\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{|\\mathbf{k}|^2},\\quad |\\mathbf{k}|^2 = k_x^2 + k_y^2,\n$$\nfor $\\mathbf{k}\\neq\\mathbf{0}$, and treat the zero mode as having no contribution to energy transfer.\n\nDefine the advective acceleration $\\mathbf{A} = (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$. In spectral space this is computed pseudo-spectrally: we evaluate spatial derivatives via FFT (which gives spectral derivatives as multiplication by $\\mathrm{i}k_x$ and $\\mathrm{i}k_y$), form the products in physical space, then transform back. To mitigate aliasing errors intrinsic to discrete nonlinear products, we apply the two-thirds truncation rule, which zeroes out Fourier components of the nonlinear term where either $|k_x|$ or $|k_y|$ exceeds $N/3$; this eliminates triad interactions that would alias back into the resolved range.\n\nThe projected nonlinear term that enters the spectral energy transfer is\n$$\n\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\mathbf{P}(\\mathbf{k})\\,\\widehat{\\mathbf{A}}(\\mathbf{k}),\\quad \\mathbf{k}\\neq\\mathbf{0},\n$$\nwith $\\widehat{\\mathbf{N}}(\\mathbf{0})$ taken as zero. The instantaneous spectral energy transfer per mode is\n$$\nT(\\mathbf{k}) = \\Re\\left[\\widehat{\\mathbf{u}}(\\mathbf{k})^*\\cdot \\widehat{\\mathbf{N}}(\\mathbf{k})\\right],\n$$\nwhere the dot is the Euclidean inner product over velocity components and the asterisk denotes complex conjugation. Because the nonlinear term redistributes energy across scales without creating or destroying it, we expect that the sum over all modes satisfies $\\sum_{\\mathbf{k}} T(\\mathbf{k}) \\approx 0$ (up to numerical truncation and aliasing mitigation).\n\nWe then define isotropic shells by integer radial wavenumbers\n$$\nk_s = \\mathrm{round}\\left(\\sqrt{k_x^2+k_y^2}\\right),\\quad k_s\\in\\mathbb{N}.\n$$\nThe shell-integrated transfer is\n$$\nT_s(k_s) = \\sum_{\\mathbf{k}: \\mathrm{round}(|\\mathbf{k}|)=k_s} T(\\mathbf{k}),\\quad k_s\\ge 1.\n$$\nGiven a coarse resolution $N_\\Delta$ with spacing $\\Delta = L/N_\\Delta$ and cutoff wavenumber\n$$\nk_\\Delta = \\frac{\\pi}{\\Delta} = \\frac{N_\\Delta}{2},\n$$\nthe spectral energy flux through $k_\\Delta$ is the cumulative transfer into modes beyond the cutoff:\n$$\n\\Pi(k_\\Delta) = \\sum_{k_s>k_\\Delta} T_s(k_s).\n$$\nThis definition is consistent with the forward flux convention: a positive $\\Pi(k_\\Delta)$ indicates a net transfer into unresolved small scales ($k>k_\\Delta$), whereas a negative $\\Pi(k_\\Delta)$ indicates a net transfer into larger scales (inverse transfer). In two-dimensional turbulence, the energy cascade is often inverse (toward small $k$) with a forward enstrophy cascade (toward large $k$), so it is possible and physically plausible to obtain $\\Pi(k_\\Delta)<0$ depending on the instantaneous flow realization.\n\nAlgorithmic steps:\n\n$1.$ Construct a single high-resolution streamfunction $\\psi(x,y)$ on an $N\\times N$ grid with $N=256$ and $L=2\\pi$. Choose a set of integer wavenumber pairs $(k_x,k_y)$ whose magnitudes lie in $[3,6]$ and assign random phases. To ensure physical realism, choose amplitudes that decay with wavenumber magnitude, for example proportional to $1/(k_x^2+k_y^2)$. Build $\\psi$ as a sum of cosine modes\n$$\n\\psi(x,y) = \\sum_{m=1}^{M} a_m \\cos(k_{x,m} x + k_{y,m} y + \\phi_m),\n$$\nwith $M$ finite. This construction ensures $\\psi$ is real and smooth.\n\n$2.$ Compute the velocity in spectral space using $\\widehat{u}_x = \\mathrm{i}k_y\\widehat{\\psi}$ and $\\widehat{u}_y = -\\mathrm{i}k_x\\widehat{\\psi}$, then inverse FFT to obtain $u_x(x,y)$ and $u_y(x,y)$.\n\n$3.$ Compute the spatial derivatives needed for $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ using spectral differentiation: transform $\\widehat{u}_x$ and $\\widehat{u}_y$ and multiply by $\\mathrm{i}k_x$ or $\\mathrm{i}k_y$ to obtain $\\partial u_x/\\partial x$, $\\partial u_x/\\partial y$, $\\partial u_y/\\partial x$, and $\\partial u_y/\\partial y$, then inverse FFT to physical space.\n\n$4.$ Form the nonlinear advective term in physical space:\n$$\nA_x = u_x \\frac{\\partial u_x}{\\partial x} + u_y \\frac{\\partial u_x}{\\partial y},\\quad\nA_y = u_x \\frac{\\partial u_y}{\\partial x} + u_y \\frac{\\partial u_y}{\\partial y}.\n$$\nFFT these to obtain $\\widehat{A}_x$ and $\\widehat{A}_y$. Apply the two-thirds rule by zeroing $\\widehat{A}$ where either $|k_x|>N/3$ or $|k_y|>N/3$.\n\n$5.$ Project onto the solenoidal subspace:\n$$\n\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\left(\\widehat{\\mathbf{A}}(\\mathbf{k}) - \\frac{\\mathbf{k}(\\mathbf{k}\\cdot \\widehat{\\mathbf{A}}(\\mathbf{k}))}{|\\mathbf{k}|^2}\\right),\\quad \\mathbf{k}\\neq \\mathbf{0},\n$$\nand set $\\widehat{\\mathbf{N}}(\\mathbf{0})=\\mathbf{0}$.\n\n$6.$ Compute the per-mode transfer\n$$\nT(\\mathbf{k}) = \\Re\\left[\\widehat{u}_x(\\mathbf{k})^*\\,\\widehat{N}_x(\\mathbf{k}) + \\widehat{u}_y(\\mathbf{k})^*\\,\\widehat{N}_y(\\mathbf{k})\\right],\n$$\nand bin into shells $k_s=\\mathrm{round}(|\\mathbf{k}|)$ to form $T_s(k_s)$ for $k_s\\ge 1$.\n\n$7.$ For each $N_\\Delta$ in the test suite, set $k_\\Delta = N_\\Delta/2$, and compute\n$$\n\\Pi(k_\\Delta) = \\sum_{k_s>k_\\Delta} T_s(k_s).\n$$\n\nPrinciple-based interpretation of gray-zone scale-awareness: In numerical weather prediction and climate modeling, scale-aware parameterizations should modulate their effect as resolution changes. Here, $k_\\Delta$ marks the transition between resolved and unresolved scales for a given resolution. If $|\\Pi(k_\\Delta)|$ decreases as $\\Delta$ decreases (equivalently, as $N_\\Delta$ increases), then the nonlinearity transfers less energy into the unresolved range, suggesting that a parameterization mimicking subgrid dissipation should diminish in strength with increasing resolution. Conversely, larger $|\\Pi(k_\\Delta)|$ at coarse resolution indicates that stronger parameterized damping is needed. The sign conveys cascade direction: negative $\\Pi(k_\\Delta)$ suggests inverse energy transfer (typical in $2$-dimensional flows), so a naive forward-energy-dissipation closure may be inappropriate; instead, one may target enstrophy removal while preserving large-scale energy. The algorithm computes $\\Pi(k_\\Delta)$ from a single high-resolution flow snapshot, which is sufficient to illustrate the resolution dependence central to gray-zone parameterization design.\n\nNumerical aspects: Using FFT ensures accurate spectral derivatives consistent with periodic boundaries. The two-thirds rule limits aliasing, maintaining fidelity in the computed transfer. Shell binning by integer radii produces an isotropic spectrum. The outputs are nondimensional and are rounded to six decimal places. The final program computes and prints $[\\Pi(8), \\Pi(16), \\Pi(32), \\Pi(48), \\Pi(64), \\Pi(128)]$ corresponding to $N_\\Delta \\in \\{16,32,64,96,128,256\\}$, where each $\\Pi(k_\\Delta)$ is computed from the same high-resolution field.",
            "answer": "```python\nimport numpy as np\n\ndef construct_streamfunction(N, L, seed=42, num_modes=20, kmin=3, kmax=6, amp0=1.0):\n    \"\"\"\n    Construct a real-valued streamfunction psi(x,y) on an N x N grid over [0,L)^2,\n    as a sum of cosine modes with wavenumbers in [kmin, kmax] and random phases.\n    Amplitude decays with k^2 for smoothness.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.linspace(0.0, L, N, endpoint=False)\n    y = np.linspace(0.0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Select unique integer wavenumber pairs in the annulus k in [kmin, kmax]\n    modes = set()\n    # Enumerate all candidate integer pairs in the range and sample until num_modes\n    candidates = []\n    for kx in range(-kmax, kmax + 1):\n        for ky in range(-kmax, kmax + 1):\n            if kx == 0 and ky == 0:\n                continue\n            kmag = np.sqrt(kx**2 + ky**2)\n            if kmin <= kmag <= kmax:\n                candidates.append((kx, ky))\n    rng.shuffle(candidates)\n    idx = 0\n    while len(modes) < num_modes and idx < len(candidates):\n        modes.add(candidates[idx])\n        idx += 1\n    if len(modes) < num_modes:\n        # If not enough unique modes, reuse random picks with possible duplicates (harmless)\n        while len(modes) < num_modes:\n            kx, ky = rng.choice(candidates)\n            modes.add((kx, ky))\n\n    psi = np.zeros((N, N), dtype=np.float64)\n    for (kx, ky) in list(modes)[:num_modes]:\n        phase = rng.uniform(0.0, 2.0 * np.pi)\n        kmag2 = kx**2 + ky**2\n        amplitude = amp0 / (kmag2 if kmag2 > 0 else 1.0)\n        psi += amplitude * np.cos(kx * X + ky * Y + phase)\n\n    return psi\n\ndef fft_wavenumbers(N, L):\n    \"\"\"\n    Compute FFT wavenumbers for domain length L. Returns kx, ky grids and 1D vectors.\n    For L=2*pi and d=L/N, the radian wavenumbers are integers.\n    \"\"\"\n    dx = L / N\n    k1d = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)  # radian wavenumbers\n    kx = k1d.reshape(N, 1) * np.ones((1, N))\n    ky = k1d.reshape(1, N) * np.ones((N, 1))\n    return kx, ky, k1d\n\ndef spectral_derivative(field_hat, kx, ky, comp='x'):\n    \"\"\"\n    Compute spectral derivative of a Fourier-transformed field w.r.t. x or y.\n    comp: 'x' or 'y'\n    \"\"\"\n    if comp == 'x':\n        return 1j * kx * field_hat\n    elif comp == 'y':\n        return 1j * ky * field_hat\n    else:\n        raise ValueError(\"comp must be 'x' or 'y'\")\n\ndef project_solenoidal(Ax_hat, Ay_hat, kx, ky):\n    \"\"\"\n    Project the vector Fourier field A_hat onto the solenoidal subspace:\n    N_hat = -(A_hat - k (k·A_hat)/|k|^2)\n    with zero mode handled specially.\n    \"\"\"\n    ksq = kx**2 + ky**2\n    kdotA = kx * Ax_hat + ky * Ay_hat\n    with np.errstate(divide='ignore', invalid='ignore'):\n        coeff = np.where(ksq != 0.0, kdotA / ksq, 0.0)\n    PxAx = Ax_hat - kx * coeff\n    PxAy = Ay_hat - ky * coeff\n    Nx_hat = -PxAx\n    Ny_hat = -PxAy\n    # Ensure zero mode is zero\n    zero_mask = (ksq == 0.0)\n    Nx_hat[zero_mask] = 0.0 + 0.0j\n    Ny_hat[zero_mask] = 0.0 + 0.0j\n    return Nx_hat, Ny_hat\n\ndef two_thirds_dealias_mask(kx, ky, N):\n    \"\"\"\n    Two-thirds rule mask: keep modes where both |kx| <= kc and |ky| <= kc, with kc = N/3 in integer units\n    since kx, ky are integers when L=2*pi.\n    \"\"\"\n    kc = N / 3.0\n    return (np.abs(kx) <= kc) & (np.abs(ky) <= kc)\n\ndef compute_transfer_shells(psi, N, L):\n    \"\"\"\n    Compute shell-integrated nonlinear energy transfer T_s(k_s) from a streamfunction psi.\n    Returns T_shell (1D array), shell_indices (array of integer shell numbers), and k magnitude grid.\n    \"\"\"\n    # Wavenumbers\n    kx, ky, k1d = fft_wavenumbers(N, L)\n    # FFT of psi\n    psi_hat = np.fft.fft2(psi)\n    # Velocity in spectral space\n    ux_hat = 1j * ky * psi_hat\n    uy_hat = -1j * kx * psi_hat\n    # Physical velocity fields\n    ux = np.fft.ifft2(ux_hat).real\n    uy = np.fft.ifft2(uy_hat).real\n    # Derivatives of velocity components via spectral differentiation\n    dux_dx_hat = spectral_derivative(ux_hat, kx, ky, comp='x')\n    dux_dy_hat = spectral_derivative(ux_hat, kx, ky, comp='y')\n    duy_dx_hat = spectral_derivative(uy_hat, kx, ky, comp='x')\n    duy_dy_hat = spectral_derivative(uy_hat, kx, ky, comp='y')\n    dux_dx = np.fft.ifft2(dux_dx_hat).real\n    dux_dy = np.fft.ifft2(dux_dy_hat).real\n    duy_dx = np.fft.ifft2(duy_dx_hat).real\n    duy_dy = np.fft.ifft2(duy_dy_hat).real\n    # Advective term in physical space\n    Ax = ux * dux_dx + uy * dux_dy\n    Ay = ux * duy_dx + uy * duy_dy\n    # Transform to spectral space\n    Ax_hat = np.fft.fft2(Ax)\n    Ay_hat = np.fft.fft2(Ay)\n    # Two-thirds dealiasing on nonlinear term\n    mask = two_thirds_dealias_mask(kx, ky, N)\n    Ax_hat = Ax_hat * mask\n    Ay_hat = Ay_hat * mask\n    # Project onto solenoidal subspace and negate\n    Nx_hat, Ny_hat = project_solenoidal(Ax_hat, Ay_hat, kx, ky)\n    # Energy transfer per mode: Re(u_hat* · N_hat)\n    T_mode = np.real(np.conj(ux_hat) * Nx_hat + np.conj(uy_hat) * Ny_hat)\n    # Shell binning by integer-rounded radial wavenumber\n    kr = np.sqrt(kx**2 + ky**2)\n    k_shell = np.rint(kr).astype(int)\n    # Exclude shell 0\n    valid = (k_shell >= 1)\n    k_shell_flat = k_shell[valid].flatten()\n    T_mode_flat = T_mode[valid].flatten()\n    # Maximum shell index present\n    kmax_shell = k_shell_flat.max() if k_shell_flat.size > 0 else 0\n    # Bin transfers into shells\n    T_shell = np.bincount(k_shell_flat, weights=T_mode_flat, minlength=kmax_shell + 1)\n    return T_shell\n\ndef compute_fluxes_for_resolutions(T_shell, resolutions):\n    \"\"\"\n    Given shell-integrated transfers T_shell and a list of N_delta resolutions,\n    compute Pi(k_delta) = sum_{k > k_delta} T_shell[k].\n    \"\"\"\n    kmax = len(T_shell) - 1\n    fluxes = []\n    for N_delta in resolutions:\n        k_delta = N_delta // 2  # since N_delta is even\n        # Sum over shells greater than k_delta, ensure within bounds\n        start = min(kmax + 1, k_delta + 1)\n        flux = float(np.sum(T_shell[start:]))\n        fluxes.append(flux)\n    return fluxes\n\ndef solve():\n    # Domain and base resolution\n    N = 256\n    L = 2.0 * np.pi\n\n    # Construct a single high-resolution streamfunction and velocity field\n    psi = construct_streamfunction(N=N, L=L, seed=42, num_modes=20, kmin=3, kmax=6, amp0=1.0)\n\n    # Compute shell-integrated transfer from the nonlinear term\n    T_shell = compute_transfer_shells(psi, N, L)\n\n    # Test suite resolutions and corresponding k_delta\n    test_resolutions = [16, 32, 64, 96, 128, 256]\n\n    # Compute fluxes Pi(k_delta) for each resolution using the same high-resolution field\n    fluxes = compute_fluxes_for_resolutions(T_shell, test_resolutions)\n\n    # Format output: floats rounded to six decimal places\n    formatted = [f\"{f:.6f}\" for f in fluxes]\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}