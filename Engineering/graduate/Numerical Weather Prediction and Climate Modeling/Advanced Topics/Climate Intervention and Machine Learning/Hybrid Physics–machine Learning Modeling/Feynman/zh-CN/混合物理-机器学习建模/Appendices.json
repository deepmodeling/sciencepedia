{
    "hands_on_practices": [
        {
            "introduction": "用快速的机器学习代理模型替代高成本、高保真度的物理模型（如逐线辐射传输求解器）是混合建模的主要应用之一。然而，这总是涉及到计算速度和模型精度之间的权衡。本练习提供了一个具体的框架，用于量化这种计算加速与精度损失之间的得失关系。",
            "id": "4052754",
            "problem": "考虑一个用于数值天气预报和气候模拟中辐射传输的物理-机器学习混合建模场景。一个逐线 (LBL) 求解器通过对 Schwarzschild 方程进行数值积分，计算出大气层顶的光谱分辨长波向上通量，\n$$\n\\frac{dI_{\\nu}}{ds} = -\\kappa_{\\nu} I_{\\nu} + \\kappa_{\\nu} B_{\\nu}(T),\n$$\n其中 $I_{\\nu}$ 是单色强度，$s$ 是路径长度，$\\kappa_{\\nu}$ 是吸收系数，$B_{\\nu}(T)$ 是温度 $T$ 下的普朗克函数。光谱积分向上通量 $F$ 通过角度和光谱积分得到，\n$$\nF = \\int_{0}^{\\infty} \\int_{4\\pi} I_{\\nu} \\cos \\theta \\, d\\Omega \\, d\\nu,\n$$\n在实践中，这通过一组带有求积权重的有限光谱带进行近似。一个机器学习代理模型根据大气状态来近似波段积分通量。为了定量评估计算成本的降低和精度的权衡，基于带权重的波段分解定义以下指标：\n1. 一种基于求积的光谱积分通量近似方法使用索引为 $j = 1,2,\\dots,N$ 的波段，其波段通量为 $F_j$，非负权重为 $w_j$，满足 $\\sum_{j=1}^{N} w_j = 1$，这些权重在与普朗克函数相关的加权下近似光谱积分。\n2. 机器学习代理模型（表示为 $F^{\\mathrm{ML}}_j$）与逐线基准模型（表示为 $F^{\\mathrm{LBL}}_j$）之间的加权 $L^1$ 相对通量误差定义为\n$$\n\\epsilon = \\frac{\\sum_{j=1}^{N} w_j \\left| F^{\\mathrm{ML}}_j - F^{\\mathrm{LBL}}_j \\right|}{\\delta + \\sum_{j=1}^{N} w_j \\left| F^{\\mathrm{LBL}}_j \\right|},\n$$\n其中 $\\delta$ 是一个小的正则化常数，以避免除以零。使用 $\\delta = 10^{-12}$（单位：瓦/平方米）以确保数值稳定性。误差 $\\epsilon$ 是无量纲的，并且必须以小数（而非百分比）报告。\n3. 计算加速比定义为\n$$\nS = \\frac{t_{\\mathrm{LBL}}}{t_{\\mathrm{ML}}},\n$$\n其中 $t_{\\mathrm{LBL}}$ 和 $t_{\\mathrm{ML}}$ 分别是逐线求解器和机器学习代理模型的挂钟运行时间，均以秒为单位表示。\n4. 一个简单的精度-成本权衡得分定义为\n$$\nT = \\frac{S}{1 + \\epsilon},\n$$\n该得分随加速比的增加而增加，随误差的减小而增加，优先考虑精确、更快的代理模型。\n\n您的任务是实现一个程序，对下面列出的每个测试用例，使用上述定义计算三元组 $(S, \\epsilon, T)$。所有通量必须以瓦/平方米为单位处理，所有时间以秒为单位，角度在此设置中不显式出现。程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按给定顺序连接每个测试用例的 $(S, \\epsilon, T)$ 结果。\n\n测试套件：\n- 用例 $1$（典型的晴空长波）：\n  - 波段数：$N = 5$。\n  - 权重：$w = [0.25, 0.20, 0.18, 0.22, 0.15]$。\n  - LBL 波段通量：$F^{\\mathrm{LBL}} = [50, 60, 55, 65, 30]$（单位：瓦/平方米）。\n  - ML 波段通量：$F^{\\mathrm{ML}} = [49, 61, 54, 66, 31]$（单位：瓦/平方米）。\n  - 运行时间：$t_{\\mathrm{LBL}} = 2.8$（秒），$t_{\\mathrm{ML}} = 0.07$（秒）。\n- 用例 $2$（代理模型更快但精度较低）：\n  - 波段数：$N = 5$。\n  - 权重：$w = [0.25, 0.20, 0.18, 0.22, 0.15]$。\n  - LBL 波段通量：$F^{\\mathrm{LBL}} = [52, 58, 57, 63, 30]$（单位：瓦/平方米）。\n  - ML 波段通量：$F^{\\mathrm{ML}} = [57, 53, 62, 58, 35]$（单位：瓦/平方米）。\n  - 运行时间：$t_{\\mathrm{LBL}} = 2.8$（秒），$t_{\\mathrm{ML}} = 0.02$（秒）。\n- 用例 $3$（代理模型精度完美）：\n  - 波段数：$N = 5$。\n  - 权重：$w = [0.25, 0.20, 0.18, 0.22, 0.15]$。\n  - LBL 波段通量：$F^{\\mathrm{LBL}} = [48, 62, 56, 64, 30]$（单位：瓦/平方米）。\n  - ML 波段通量：$F^{\\mathrm{ML}} = [48, 62, 56, 64, 30]$（单位：瓦/平方米）。\n  - 运行时间：$t_{\\mathrm{LBL}} = 3.0$（秒），$t_{\\mathrm{ML}} = 0.06$（秒）。\n\n答案规范：\n- 对每个用例使用上述公式和 $\\delta = 10^{-12}$（单位：瓦/平方米）计算 $(S, \\epsilon, T)$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[S_1, \\epsilon_1, T_1, S_2, \\epsilon_2, T_2, S_3, \\epsilon_3, T_3]$，其中下标索引测试用例编号。",
            "solution": "问题陈述具有科学依据，提法明确，并为得出唯一解提供了所有必要信息。其背景是机器学习代理模型在计算物理学中的一个标准应用，特别是针对大气辐射传输。所定义的加速比、误差和权衡指标是一致且数学上合理的。未发现不一致或模糊之处。因此，该问题被认为是有效的，我们可以着手求解。\n\n目标是为一个逐线 (LBL) 辐射传输模型的机器学习 (ML) 代理模型计算三个性能指标。这些指标是计算加速比 ($S$)、加权相对通量误差 ($\\epsilon$) 和精度-成本权衡得分 ($T$)。我们获得了三个不同的测试用例，每个用例都有运行时间和波段积分通量的具体数据。我们将按顺序对每个用例进行计算。\n\n基本公式如下：\n1. 计算加速比，$S$：该指标量化了 ML 代理模型相对于 LBL 模型所实现的加速。它是它们各自运行时间 $t_{\\mathrm{LBL}}$ 和 $t_{\\mathrm{ML}}$ 的比值。\n$$\nS = \\frac{t_{\\mathrm{LBL}}}{t_{\\mathrm{ML}}}\n$$\n\n2. 加权 $L^1$ 相对通量误差，$\\epsilon$：该指标衡量 ML 代理模型的准确性。它是波段通量绝对差的加权和，通过 LBL 参考通量的加权和进行归一化。一个小的常数 $\\delta = 10^{-12}$ 确保分母不为零。\n$$\n\\epsilon = \\frac{\\sum_{j=1}^{N} w_j \\left| F^{\\mathrm{ML}}_j - F^{\\mathrm{LBL}}_j \\right|}{\\delta + \\sum_{j=1}^{N} w_j \\left| F^{\\mathrm{LBL}}_j \\right|}\n$$\n\n3. 精度-成本权衡得分，$T$：该得分在加速比和误差之间取得平衡。得分越高表示代理模型越理想。\n$$\nT = \\frac{S}{1 + \\epsilon}\n$$\n我们现在将这些公式应用于每个测试用例。\n\n**用例 1：典型的晴空长波**\n提供的数据是：\n- 权重：$w = [0.25, 0.20, 0.18, 0.22, 0.15]$\n- LBL 波段通量：$F^{\\mathrm{LBL}} = [50, 60, 55, 65, 30]$ 瓦/平方米\n- ML 波段通量：$F^{\\mathrm{ML}} = [49, 61, 54, 66, 31]$ 瓦/平方米\n- 运行时间：$t_{\\mathrm{LBL}} = 2.8$ 秒, $t_{\\mathrm{ML}} = 0.07$ 秒\n\n首先，我们计算加速比 $S_1$：\n$$\nS_1 = \\frac{2.8}{0.07} = 40.0\n$$\n接下来，我们计算误差 $\\epsilon_1$。分子是通量绝对差的加权和：\n$$\n\\sum_{j=1}^{5} w_j \\left| F^{\\mathrm{ML}}_j - F^{\\mathrm{LBL}}_j \\right| = 0.25|49-50| + 0.20|61-60| + 0.18|54-55| + 0.22|66-65| + 0.15|31-30|\n$$\n$$\n= 0.25(1) + 0.20(1) + 0.18(1) + 0.22(1) + 0.15(1) = 1.0\n$$\n分母是正则化的 LBL 通量的加权和（所有通量均为正，因此 $|F_j^{\\mathrm{LBL}}| = F_j^{\\mathrm{LBL}}$）：\n$$\n\\delta + \\sum_{j=1}^{5} w_j F^{\\mathrm{LBL}}_j = 10^{-12} + (0.25 \\cdot 50 + 0.20 \\cdot 60 + 0.18 \\cdot 55 + 0.22 \\cdot 65 + 0.15 \\cdot 30)\n$$\n$$\n= 10^{-12} + (12.5 + 12.0 + 9.9 + 14.3 + 4.5) = 10^{-12} + 53.2\n$$\n误差 $\\epsilon_1$ 是该比率：\n$$\n\\epsilon_1 = \\frac{1.0}{53.2 + 10^{-12}} \\approx 0.018796992481203006\n$$\n最后，我们计算权衡得分 $T_1$：\n$$\nT_1 = \\frac{S_1}{1 + \\epsilon_1} = \\frac{40.0}{1 + 0.018796992481203006} \\approx 39.26182329304142\n$$\n\n**用例 2：代理模型更快但精度较低**\n提供的数据是：\n- $w = [0.25, 0.20, 0.18, 0.22, 0.15]$\n- $F^{\\mathrm{LBL}} = [52, 58, 57, 63, 30]$ 瓦/平方米\n- $F^{\\mathrm{ML}} = [57, 53, 62, 58, 35]$ 瓦/平方米\n- $t_{\\mathrm{LBL}} = 2.8$ 秒, $t_{\\mathrm{ML}} = 0.02$ 秒\n\n加速比 $S_2$ 是：\n$$\nS_2 = \\frac{2.8}{0.02} = 140.0\n$$\n$\\epsilon_2$ 的分子：\n$$\n\\sum w_j |F^{\\mathrm{ML}}_j - F^{\\mathrm{LBL}}_j| = 0.25|57-52| + 0.20|53-58| + 0.18|62-57| + 0.22|58-63| + 0.15|35-30|\n$$\n$$\n= 0.25(5) + 0.20(5) + 0.18(5) + 0.22(5) + 0.15(5) = 5 \\sum w_j = 5(1) = 5.0\n$$\n$\\epsilon_2$ 的分母：\n$$\n\\delta + \\sum w_j F^{\\mathrm{LBL}}_j = 10^{-12} + (0.25 \\cdot 52 + 0.20 \\cdot 58 + 0.18 \\cdot 57 + 0.22 \\cdot 63 + 0.15 \\cdot 30)\n$$\n$$\n= 10^{-12} + (13.0 + 11.6 + 10.26 + 13.86 + 4.5) = 10^{-12} + 53.22\n$$\n误差 $\\epsilon_2$ 是：\n$$\n\\epsilon_2 = \\frac{5.0}{53.22 + 10^{-12}} \\approx 0.09394964300075159\n$$\n权衡得分 $T_2$ 是：\n$$\nT_2 = \\frac{S_2}{1 + \\epsilon_2} = \\frac{140.0}{1 + 0.09394964300075159} \\approx 127.97746031746032\n$$\n\n**用例 3：代理模型精度完美**\n提供的数据是：\n- $w = [0.25, 0.20, 0.18, 0.22, 0.15]$\n- $F^{\\mathrm{LBL}} = [48, 62, 56, 64, 30]$ 瓦/平方米\n- $F^{\\mathrm{ML}} = [48, 62, 56, 64, 30]$ 瓦/平方米\n- $t_{\\mathrm{LBL}} = 3.0$ 秒, $t_{\\mathrm{ML}} = 0.06$ 秒\n\n加速比 $S_3$ 是：\n$$\nS_3 = \\frac{3.0}{0.06} = 50.0\n$$\n对于误差 $\\epsilon_3$，我们观察到对所有波段 $j$，都有 $F^{\\mathrm{ML}}_j = F^{\\mathrm{LBL}}_j$。因此，对所有 $j$，绝对差 $|F^{\\mathrm{ML}}_j - F^{\\mathrm{LBL}}_j|$ 都为 $0$。所以 $\\epsilon_3$ 的分子为 $0$。\n$$\n\\sum w_j |F^{\\mathrm{ML}}_j - F^{\\mathrm{LBL}}_j| = 0\n$$\n分母不为零，因此误差 $\\epsilon_3$ 精确为 $0$：\n$$\n\\epsilon_3 = 0.0\n$$\n权衡得分 $T_3$ 是：\n$$\nT_3 = \\frac{S_3}{1 + \\epsilon_3} = \\frac{50.0}{1 + 0} = 50.0\n$$\n这些计算出的三元组 $(S_1, \\epsilon_1, T_1)$、$(S_2, \\epsilon_2, T_2)$ 和 $(S_3, \\epsilon_3, T_3)$ 将被连接起来形成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes performance metrics for a machine learning surrogate model\n    based on three test cases.\n    \"\"\"\n    # The regularization constant delta is defined as 10^-12 W/m^2.\n    delta = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"w\": np.array([0.25, 0.20, 0.18, 0.22, 0.15]),\n            \"f_lbl\": np.array([50, 60, 55, 65, 30]),\n            \"f_ml\": np.array([49, 61, 54, 66, 31]),\n            \"t_lbl\": 2.8,\n            \"t_ml\": 0.07,\n        },\n        {\n            \"w\": np.array([0.25, 0.20, 0.18, 0.22, 0.15]),\n            \"f_lbl\": np.array([52, 58, 57, 63, 30]),\n            \"f_ml\": np.array([57, 53, 62, 58, 35]),\n            \"t_lbl\": 2.8,\n            \"t_ml\": 0.02,\n        },\n        {\n            \"w\": np.array([0.25, 0.20, 0.18, 0.22, 0.15]),\n            \"f_lbl\": np.array([48, 62, 56, 64, 30]),\n            \"f_ml\": np.array([48, 62, 56, 64, 30]),\n            \"t_lbl\": 3.0,\n            \"t_ml\": 0.06,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract data for the current case.\n        w = case[\"w\"]\n        f_lbl = case[\"f_lbl\"]\n        f_ml = case[\"f_ml\"]\n        t_lbl = case[\"t_lbl\"]\n        t_ml = case[\"t_ml\"]\n\n        # 1. Compute computational speedup (S).\n        # S = t_LBL / t_ML\n        S = t_lbl / t_ml\n\n        # 2. Compute weighted L1 relative flux error (epsilon).\n        # epsilon = (sum(w * |F_ML - F_LBL|)) / (delta + sum(w * |F_LBL|))\n        # Note: Since fluxes are physical quantities (power), they are non-negative,\n        # so abs(F_LBL) is F_LBL.\n        numerator_eps = np.sum(w * np.abs(f_ml - f_lbl))\n        denominator_eps = delta + np.sum(w * np.abs(f_lbl))\n        epsilon = numerator_eps / denominator_eps\n\n        # 3. Compute accuracy-cost trade-off score (T).\n        # T = S / (1 + epsilon)\n        T = S / (1.0 + epsilon)\n\n        # Append the calculated triple (S, epsilon, T) to the results list.\n        results.extend([S, epsilon, T])\n\n    # Final print statement must produce a single line with comma-separated\n    # values enclosed in square brackets.\n    # The map(str, ...) function ensures all numbers are converted to strings\n    # for the join operation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "混合建模中最强大的技术之一，是在训练过程中用物理定律来指导机器学习模型。我们可以不把物理一致性作为后处理步骤，而是将其作为“软约束”或惩罚项直接编码到损失函数中。本练习将演示如何构建一个复合损失函数，通过惩罚对湿静力能量守恒（热力学第一定律的直接推论）的违反，来保证模型的物理一致性。",
            "id": "4052750",
            "problem": "您正在为用于数值天气预报 (NWP) 和气候模拟的单柱模型 (SCM) 设计一种物理-机器学习 (ML) 混合参数化方案。ML 组件预测温度和比湿的分层趋势，并且必须通过闭合湿静力能收支来遵守湿空气的热力学第一定律。您的任务是推导、实现和评估一个复合损失函数，该函数同时惩罚监督误差和违反湿静力能闭合的情况。\n\n从以下基本原理开始。考虑应用于固定高度欧拉控制体积中湿空气的热力学第一定律，其中重力加速度为常数。将湿静力能定义为 $$s = c_p T + g z + L_v q,$$ 其中 $T$ 是温度，$z$ 是几何高度，$q$ 是比湿，$c_p$ 是定压空气比热容，$g$ 是重力加速度，$L_v$ 是汽化潜热。在 $z$ 不随时间变化的固定高度层中，局地湿静力能趋势简化为 $$\\frac{\\partial s}{\\partial t} = c_p \\frac{\\partial T}{\\partial t} + L_v \\frac{\\partial q}{\\partial t}.$$ 在不考虑平流的情况下，当关注由 ML 模型学习的次网格和辐射过程时，局地收支的闭合要求单位质量的非绝热源（记为 $H$，单位为 $\\mathrm{W\\,kg^{-1}}$）满足 $$c_p \\frac{\\partial T}{\\partial t} + L_v \\frac{\\partial q}{\\partial t} = H.$$\n\n您将构建一个由两部分组成的复合损失：一个监督数据损失和一个物理闭合正则化项。监督数据损失将 ML 预测的趋势 $\\widehat{\\partial T/\\partial t}$ 和 $\\widehat{\\partial q/\\partial t}$ 与每层的观测目标趋势 $y_T$ 和 $y_q$ 进行比较。物理损失使用残差 $$r = c_p \\widehat{\\frac{\\partial T}{\\partial t}} + L_v \\widehat{\\frac{\\partial q}{\\partial t}} - H.$$ 来惩罚湿静力能收支的不闭合。残差必须在各层之间进行质量加权，以表示整层积分的惩罚。对于一个离散为由 $i$ 索引的层的气柱，层密度为 $\\rho_i$，厚度为 $\\Delta z_i$，单位面积的质量为 $w_i = \\rho_i \\Delta z_i$，整层平均的残差平方应由 $w_i$ 加权。\n\n定义您的程序必须为每个测试用例计算的以下复合损失：\n- 监督数据损失为\n$$L_{\\text{data}} = \\frac{1}{N} \\sum_{i=1}^{N} \\left[ \\left( \\frac{\\widehat{T}_i - y_{T,i}}{S_T} \\right)^2 + \\beta \\left( \\frac{\\widehat{q}_i - y_{q,i}}{S_q} \\right)^2 \\right],$$\n其中 $N$ 是层数，$\\widehat{T}_i = \\widehat{\\partial T/\\partial t}$ 是第 $i$ 层的温度趋势，单位为 $\\mathrm{K\\,s^{-1}}$，$\\widehat{q}_i = \\widehat{\\partial q/\\partial t}$ 是第 $i$ 层的比湿趋势，单位为 $\\mathrm{s^{-1}}$（因为 $q$ 在 $\\mathrm{kg\\,kg^{-1}}$ 中是无量纲的），$y_{T,i}$ 和 $y_{q,i}$ 是相应的观测目标，$S_T$ 和 $S_q$ 是用于无量纲化各项的缩放参数，$\\beta$ 是一个相对权重参数。\n- 物理闭合损失为\n$$L_{\\text{phys}} = \\frac{\\sum_{i=1}^{N} w_i \\, r_i^2}{\\left(\\sum_{i=1}^{N} w_i\\right) \\, H_{\\text{scale}}^2},$$\n其中 $r_i = c_p \\widehat{T}_i + L_v \\widehat{q}_i - H_i$，$w_i = \\rho_i \\Delta z_i$，$H_{\\text{scale}}$ 是一个用于无量纲化的固定缩放常数。\n- 总损失为\n$$L_{\\text{total}} = L_{\\text{data}} + \\lambda \\, L_{\\text{phys}},$$\n其中 $\\lambda$ 是一个非负的调整参数。\n\n在所有计算中使用以下常数（以国际单位制 SI 表示）：\n- $c_p = 1004 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n- $L_v = 2.5 \\times 10^6 \\ \\mathrm{J\\,kg^{-1}}$,\n- $g = 9.81 \\ \\mathrm{m\\,s^{-2}}$（请注意，由于 $z$ 是固定的，$g$ 不会被直接使用）,\n- $S_T = 1.0 \\times 10^{-5} \\ \\mathrm{K\\,s^{-1}}$,\n- $S_q = 1.0 \\times 10^{-8} \\ \\mathrm{s^{-1}}$,\n- $\\beta = 1$,\n- $H_{\\text{scale}} = 5.0 \\times 10^{-2} \\ \\mathrm{W\\,kg^{-1}}$,\n- $\\lambda = 10$.\n\n实现一个程序，为以下每个测试用例计算 $L_{\\text{total}}$。所有数组都按层索引 $i$ 的递增顺序列出，每个条目都是一个层的值。必须严格遵守指定的单位。\n\n测试用例 A（理想路径，精确闭合但监督误差非零）：\n- 层数 $N = 3$。\n- 层厚度 $\\Delta z = [1000, 1000, 1000] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.2, 0.9, 0.7] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML 预测的温度趋势 $\\widehat{T} = [1.0 \\times 10^{-5}, 1.2 \\times 10^{-5}, 0.8 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$。\n- ML 预测的比湿趋势 $\\widehat{q} = [1.0 \\times 10^{-8}, 0.5 \\times 10^{-8}, 0.0 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n- 已知的非绝热源 $H$，其构造满足分层精确闭合：\n  - $H = [0.03504, 0.024548, 0.008032] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标趋势 $y_T = [1.1 \\times 10^{-5}, 1.1 \\times 10^{-5}, 0.9 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [0.8 \\times 10^{-8}, 0.6 \\times 10^{-8}, 0.1 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n\n测试用例 B（强烈的物理违背和监督差异）：\n- 层数 $N = 3$。\n- 层厚度 $\\Delta z = [800, 1200, 1500] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.0, 0.8, 0.6] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML 预测的温度趋势 $\\widehat{T} = [2.0 \\times 10^{-5}, -0.5 \\times 10^{-5}, 0.0 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$。\n- ML 预测的比湿趋势 $\\widehat{q} = [2.0 \\times 10^{-8}, -1.0 \\times 10^{-8}, 0.5 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n- 已知的非绝热源 $H = [0.005, 0.0, -0.002] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标趋势 $y_T = [1.5 \\times 10^{-5}, -0.4 \\times 10^{-5}, 0.2 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [1.5 \\times 10^{-8}, -1.2 \\times 10^{-8}, 0.4 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n\n测试用例 C（边界情况：单个干层，平凡的闭合和监督）：\n- 层数 $N = 1$。\n- 层厚度 $\\Delta z = [500] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.1] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML 预测的温度趋势 $\\widehat{T} = [0.0] \\ \\mathrm{K\\,s^{-1}}$。\n- ML 预测的比湿趋势 $\\widehat{q} = [0.0] \\ \\mathrm{s^{-1}}$。\n- 已知的非绝热源 $H = [0.0] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标趋势 $y_T = [0.0] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [0.0] \\ \\mathrm{s^{-1}}$。\n\n测试用例 D（边界情况：完美的监督和精确的闭合）：\n- 层数 $N = 2$。\n- 层厚度 $\\Delta z = [1000, 1000] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.1, 0.9] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML 预测的温度趋势 $\\widehat{T} = [1.0 \\times 10^{-5}, -1.0 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$。\n- ML 预测的比湿趋势 $\\widehat{q} = [1.0 \\times 10^{-8}, 2.0 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n- 已知的非绝热源 $H = [0.03504, 0.03996] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标趋势 $y_T = [1.0 \\times 10^{-5}, -1.0 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [1.0 \\times 10^{-8}, 2.0 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n\n您的程序必须为每个测试用例计算 $L_{\\text{total}}$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[ \\ell_A, \\ell_B, \\ell_C, \\ell_D ]$，其中每个 $\\ell$ 是一个浮点值。不允许有任何其他输出。所有计算都必须以国际单位制（SI）进行，输出应严格按照此处描述的单行格式打印。",
            "solution": "该问题在科学和数学上是有效的。它定义明确、自成体系，并以大气热力学和物理信息机器学习的原理为基础。所有常数、变量和函数形式都已明确定义，提供的测试用例包含唯一解所需的所有数据。我们将继续进行计算。\n\n目标是为四个不同的测试用例计算总损失函数 $L_{\\text{total}}$。该损失函数是监督数据损失分量 $L_{\\text{data}}$ 和基于物理的闭合损失分量 $L_{\\text{phys}}$ 的复合。总损失定义为加权和：\n$$L_{\\text{total}} = L_{\\text{data}} + \\lambda \\, L_{\\text{phys}}$$\n\n监督数据损失 $L_{\\text{data}}$ 量化了 ML 预测趋势与观测目标趋势之间的均方误差，并由缩放因子归一化。对于一个有 $N$ 层的气柱，它由以下公式给出：\n$$L_{\\text{data}} = \\frac{1}{N} \\sum_{i=1}^{N} \\left[ \\left( \\frac{\\widehat{T}_i - y_{T,i}}{S_T} \\right)^2 + \\beta \\left( \\frac{\\widehat{q}_i - y_{q,i}}{S_q} \\right)^2 \\right]$$\n其中 $\\widehat{T}_i$ 和 $\\widehat{q}_i$ 是第 $i$ 层温度和比湿的预测趋势，$y_{T,i}$ 和 $y_{q,i}$ 是相应的观测目标，$S_T$ 和 $S_q$ 是归一化尺度，$\\beta$ 是一个相对权重因子。\n\n物理闭合损失 $L_{\\text{phys}}$ 惩罚对湿静力能收支的违反。它被表述为能量守恒方程的质量加权、归一化的均方残差：\n$$L_{\\text{phys}} = \\frac{\\sum_{i=1}^{N} w_i \\, r_i^2}{\\left(\\sum_{i=1}^{N} w_i\\right) \\, H_{\\text{scale}}^2}$$\n每层的物理残差 $r_i$ 为 $r_i = c_p \\widehat{T}_i + L_v \\widehat{q}_i - H_i$，其中 $H_i$ 是已知的非绝热源。每层的质量权重为 $w_i = \\rho_i \\Delta z_i$，其中 $\\rho_i$ 是层密度，$\\Delta z_i$ 是层厚度。$H_{\\text{scale}}$ 是用于无量纲化的常数。\n\n计算将使用指定的以下国际单位制常数：\n- 空气比热容, $c_p = 1004 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$\n- 汽化潜热, $L_v = 2.5 \\times 10^6 \\ \\mathrm{J\\,kg^{-1}}$\n- 温度趋势尺度, $S_T = 1.0 \\times 10^{-5} \\ \\mathrm{K\\,s^{-1}}$\n- 比湿趋势尺度, $S_q = 1.0 \\times 10^{-8} \\ \\mathrm{s^{-1}}$\n- 数据损失湿度权重, $\\beta = 1$\n- 物理损失尺度, $H_{\\text{scale}} = 5.0 \\times 10^{-2} \\ \\mathrm{W\\,kg^{-1}}$\n- 物理损失权重, $\\lambda = 10$\n\n我们现在为每个测试用例计算 $L_{\\text{total}}$。\n\n**测试用例 A**\n该模型有 $N=3$ 层。问题陈述非绝热源 $H_i$ 的构造是为了精确闭合，这意味着对所有 $i$ 物理残差 $r_i=0$。\n首先，我们验证层 $i=1$ 的此属性：\n$r_1 = c_p \\widehat{T}_1 + L_v \\widehat{q}_1 - H_1 = (1004)(1.0 \\times 10^{-5}) + (2.5 \\times 10^6)(1.0 \\times 10^{-8}) - 0.03504 = 0.01004 + 0.025 - 0.03504 = 0$。\n根据构造，层 $i=2$ 和 $i=3$ 的残差也为 $0$。因此，$L_{\\text{phys}} = 0$。\n\n接下来，我们计算 $L_{\\text{data}}$：\n温度的逐层归一化平方误差为：\n$\\left( \\frac{(1.0 - 1.1) \\times 10^{-5}}{1.0 \\times 10^{-5}} \\right)^2 = (-0.1)^2 = 0.01$\n$\\left( \\frac{(1.2 - 1.1) \\times 10^{-5}}{1.0 \\times 10^{-5}} \\right)^2 = (0.1)^2 = 0.01$\n$\\left( \\frac{(0.8 - 0.9) \\times 10^{-5}}{1.0 \\times 10^{-5}} \\right)^2 = (-0.1)^2 = 0.01$\n比湿的逐层归一化平方误差为：\n$\\left( \\frac{(1.0 - 0.8) \\times 10^{-8}}{1.0 \\times 10^{-8}} \\right)^2 = (0.2)^2 = 0.04$\n$\\left( \\frac{(0.5 - 0.6) \\times 10^{-8}}{1.0 \\times 10^{-8}} \\right)^2 = (-0.1)^2 = 0.01$\n$\\left( \\frac{(0.0 - 0.1) \\times 10^{-8}}{1.0 \\times 10^{-8}} \\right)^2 = (-0.1)^2 = 0.01$\n当 $\\beta=1$ 时，逐层损失项的总和为 $(0.01 + 0.04) + (0.01 + 0.01) + (0.01 + 0.01) = 0.05 + 0.02 + 0.02 = 0.09$。\n$L_{\\text{data}} = \\frac{1}{3} \\times 0.09 = 0.03$。\n$L_{\\text{total, A}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0.03 + (10)(0) = 0.03$。\n\n**测试用例 B**\n该模型有 $N=3$ 层。\n首先，我们计算 $L_{\\text{data}}$：\n逐层归一化平方误差为：\n$i=1: \\left(\\frac{(2.0 - 1.5) \\times 10^{-5}}{1.0 \\times 10^{-5}}\\right)^2 + 1 \\cdot \\left(\\frac{(2.0 - 1.5) \\times 10^{-8}}{1.0 \\times 10^{-8}}\\right)^2 = (0.5)^2 + (0.5)^2 = 0.25 + 0.25 = 0.5$。\n$i=2: \\left(\\frac{(-0.5 - (-0.4)) \\times 10^{-5}}{1.0 \\times 10^{-5}}\\right)^2 + 1 \\cdot \\left(\\frac{(-1.0 - (-1.2)) \\times 10^{-8}}{1.0 \\times 10^{-8}}\\right)^2 = (-0.1)^2 + (0.2)^2 = 0.01 + 0.04 = 0.05$。\n$i=3: \\left(\\frac{(0.0 - 0.2) \\times 10^{-5}}{1.0 \\times 10^{-5}}\\right)^2 + 1 \\cdot \\left(\\frac{(0.5 - 0.4) \\times 10^{-8}}{1.0 \\times 10^{-8}}\\right)^2 = (-0.2)^2 + (0.1)^2 = 0.04 + 0.01 = 0.05$。\n$L_{\\text{data}} = \\frac{1}{3} (0.5 + 0.05 + 0.05) = \\frac{0.6}{3} = 0.2$。\n\n接下来，我们计算 $L_{\\text{phys}}$：\n层质量权重 $w_i = \\rho_i \\Delta z_i$：\n$w_1 = (1.0)(800) = 800 \\ \\mathrm{kg\\,m^{-2}}$。\n$w_2 = (0.8)(1200) = 960 \\ \\mathrm{kg\\,m^{-2}}$。\n$w_3 = (0.6)(1500) = 900 \\ \\mathrm{kg\\,m^{-2}}$。\n总质量 $\\sum w_i = 800 + 960 + 900 = 2660 \\ \\mathrm{kg\\,m^{-2}}$。\n物理残差 $r_i = c_p \\widehat{T}_i + L_v \\widehat{q}_i - H_i$：\n$r_1 = (1004)(2.0 \\times 10^{-5}) + (2.5 \\times 10^6)(2.0 \\times 10^{-8}) - 0.005 = 0.02008 + 0.05 - 0.005 = 0.06508$。\n$r_2 = (1004)(-0.5 \\times 10^{-5}) + (2.5 \\times 10^6)(-1.0 \\times 10^{-8}) - 0.0 = -0.00502 - 0.025 = -0.03002$。\n$r_3 = (1004)(0.0) + (2.5 \\times 10^6)(0.5 \\times 10^{-8}) - (-0.002) = 0 + 0.0125 + 0.002 = 0.0145$。\n$L_{\\text{phys}}$ 的分子： $\\sum w_i r_i^2 = 800(0.06508)^2 + 960(-0.03002)^2 + 900(0.0145)^2 \\approx 3.38833 + 0.86515 + 0.189225 = 4.4427$。\n$L_{\\text{phys}}$ 的分母： $(\\sum w_i) H_{\\text{scale}}^2 = (2660)(5.0 \\times 10^{-2})^2 = 2660 \\times 0.0025 = 6.65$。\n$L_{\\text{phys}} \\approx 4.4427 / 6.65 \\approx 0.6680756$。\n$L_{\\text{total, B}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0.2 + 10(0.6680756) = 0.2 + 6.680756 = 6.880756$。\n\n**测试用例 C**\n这是一个单层情况（$N=1$），其中所有预测趋势、目标趋势和非绝热源均为零。\n$L_{\\text{data}}$：差值 $\\widehat{T}_1 - y_{T,1}$ 和 $\\widehat{q}_1 - y_{q,1}$ 均为 $0$。因此，$L_{\\text{data}} = 0$。\n$L_{\\text{phys}}$：残差 $r_1 = c_p(0) + L_v(0) - 0 = 0$。因此，$L_{\\text{phys}} = 0$。\n$L_{\\text{total, C}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0 + (10)(0) = 0$。\n\n**测试用例 D**\n这是一个具有 $N=2$ 层的情况，具有完美的监督（$\\widehat{T}_i = y_{T,i}$，$\\widehat{q}_i = y_{q,i}$）和精确的物理闭合。\n$L_{\\text{data}}$：由于所有层的预测趋势和目标趋势都相同，误差均为 $0$。因此，$L_{\\text{data}} = 0$。\n$L_{\\text{phys}}$：根据构造，闭合是精确的，意味着所有层的 $r_i=0$。我们可以验证层 $i=2$：\n$r_2 = (1004)(-1.0 \\times 10^{-5}) + (2.5 \\times 10^6)(2.0 \\times 10^{-8}) - 0.03996 = -0.01004 + 0.05 - 0.03996 = 0$。\n由于所有残差均为 $0$，$L_{\\text{phys}} = 0$。\n$L_{\\text{total, D}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0 + (10)(0) = 0$。\n\n结果摘要：\n- 测试用例 A：$L_{\\text{total}} = 0.03$\n- 测试用例 B：$L_{\\text{total}} \\approx 6.880756$\n- 测试用例 C：$L_{\\text{total}} = 0.0$\n- 测试用例 D：$L_{\\text{total}} = 0.0$\n这些值将通过编程计算到机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total loss for a hybrid physics-ML model for given test cases.\n    \"\"\"\n    # Define physical and model constants\n    c_p = 1004.0         # J kg^-1 K^-1\n    L_v = 2.5e6          # J kg^-1\n    S_T = 1.0e-5         # K s^-1\n    S_q = 1.0e-8         # s^-1\n    beta = 1.0           # dimensionless\n    H_scale = 5.0e-2     # W kg^-1\n    lambda_ = 10.0       # dimensionless\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"N\": 3,\n            \"delta_z\": np.array([1000, 1000, 1000]),\n            \"rho\": np.array([1.2, 0.9, 0.7]),\n            \"T_hat\": np.array([1.0e-5, 1.2e-5, 0.8e-5]),\n            \"q_hat\": np.array([1.0e-8, 0.5e-8, 0.0e-8]),\n            \"H\": np.array([0.03504, 0.024548, 0.008032]),\n            \"y_T\": np.array([1.1e-5, 1.1e-5, 0.9e-5]),\n            \"y_q\": np.array([0.8e-8, 0.6e-8, 0.1e-8]),\n        },\n        # Test Case B\n        {\n            \"N\": 3,\n            \"delta_z\": np.array([800, 1200, 1500]),\n            \"rho\": np.array([1.0, 0.8, 0.6]),\n            \"T_hat\": np.array([2.0e-5, -0.5e-5, 0.0e-5]),\n            \"q_hat\": np.array([2.0e-8, -1.0e-8, 0.5e-8]),\n            \"H\": np.array([0.005, 0.0, -0.002]),\n            \"y_T\": np.array([1.5e-5, -0.4e-5, 0.2e-5]),\n            \"y_q\": np.array([1.5e-8, -1.2e-8, 0.4e-8]),\n        },\n        # Test Case C\n        {\n            \"N\": 1,\n            \"delta_z\": np.array([500]),\n            \"rho\": np.array([1.1]),\n            \"T_hat\": np.array([0.0]),\n            \"q_hat\": np.array([0.0]),\n            \"H\": np.array([0.0]),\n            \"y_T\": np.array([0.0]),\n            \"y_q\": np.array([0.0]),\n        },\n        # Test Case D\n        {\n            \"N\": 2,\n            \"delta_z\": np.array([1000, 1000]),\n            \"rho\": np.array([1.1, 0.9]),\n            \"T_hat\": np.array([1.0e-5, -1.0e-5]),\n            \"q_hat\": np.array([1.0e-8, 2.0e-8]),\n            \"H\": np.array([0.03504, 0.03996]),\n            \"y_T\": np.array([1.0e-5, -1.0e-5]),\n            \"y_q\": np.array([1.0e-8, 2.0e-8]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T_hat = case[\"T_hat\"]\n        q_hat = case[\"q_hat\"]\n        y_T = case[\"y_T\"]\n        y_q = case[\"y_q\"]\n        delta_z = case[\"delta_z\"]\n        rho = case[\"rho\"]\n        H = case[\"H\"]\n\n        # 1. Compute L_data\n        term_T = ((T_hat - y_T) / S_T)**2\n        term_q = ((q_hat - y_q) / S_q)**2\n        L_data = (1.0 / N) * np.sum(term_T + beta * term_q)\n\n        # 2. Compute L_phys\n        # Physical residual for each layer\n        r = c_p * T_hat + L_v * q_hat - H\n        \n        # Mass weight for each layer\n        w = rho * delta_z\n        \n        # Mass-weighted squared residual sum (numerator)\n        numerator = np.sum(w * r**2)\n        \n        # Total mass and scaling (denominator)\n        denominator = np.sum(w) * (H_scale**2)\n        \n        # Handle case of zero denominator to avoid division by zero\n        if denominator == 0:\n            if numerator == 0:\n                L_phys = 0.0\n            else:\n                # This case implies non-zero residual with zero mass,\n                # which is physically ill-defined, but for numerical\n                # stability we can treat it as infinite penalty.\n                L_phys = np.inf\n        else:\n            L_phys = numerator / denominator\n\n        # 3. Compute L_total\n        L_total = L_data + lambda_ * L_phys\n        results.append(L_total)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在“软约束”的基础上，我们可以为一些关键的物理原则引入“硬约束”，即模型在设计上就无法违反这些原则。这可以通过构建具有内在物理一致性的模型架构来实现。这个高级练习将展示如何构建一个湍流闭包中的涡粘性张量，通过保证该张量是半正定的，从而确保动能耗散的非负性——这是植根于热力学第二定律的一个重要物理属性。",
            "id": "4052738",
            "problem": "考虑在二维空间中，由带有涡粘性闭合项以处理子网格应力的不可压缩、滤波的Navier-Stokes方程所控制的解析动力学。令解析速度表示为 $\\mathbf{u}(\\mathbf{x},t)$，解析压力表示为 $p(\\mathbf{x},t)$，解析的对称应变率张量定义为 $S = (\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})/2$，其分量为 $S_{ij}$，其中 $i,j \\in \\{x,y\\}$。解析动能密度为 $K = (1/2)\\,\\mathbf{u}\\cdot\\mathbf{u}$。需要构建一个混合物理-机器学习 (ML) 涡粘性闭合模型，以保证非负的能量耗散。该闭合模型在线性作用于对称二阶张量空间。为了表示这种线性作用，采用 $S$ 的类Voigt向量化形式 $s \\in \\mathbb{R}^{3}$，给定为 $s = [S_{xx}, \\sqrt{2}\\,S_{xy}, S_{yy}]^{\\top}$，使得Frobenius内积 $S:S$ 等于 $s^{\\top}s$。\n\n涡粘性算子表示为一个作用于 $s$ 的对称矩阵 $A(\\mathbf{x}) \\in \\mathbb{R}^{3\\times 3}$。目标是设计 $A(\\mathbf{x})$，使其为半正定 (PSD)，从而确保非负的动能耗散。\n\n第一部分 (推导)：从不可压缩动量方程和解析动能密度 $K$ 的定义出发，推导由作用于 $s$ 的线性、对称涡粘性算子 $A$ 引起的逐点耗散密度的表达式，并证明如果 $A$ 是PSD，则耗散密度为非负。您的推导必须从基本定律开始，特别是滤波的不可压缩Navier-Stokes动量方程和 $K$ 的定义，并贯穿动能收支的分析。清晰地陈述为消除边界通量所需的任何边界条件假设。最后以一个陈述结束，说明为什么 $A$ 的PSD性质意味着非负的耗散密度。\n\n第二部分 (参数化)：提出一个 $A$ 的参数化方案，以保证对于任何无约束的ML输出来说，它都是PSD。使用一个下三角矩阵 $L \\in \\mathbb{R}^{3\\times 3}$，其对角线元素通过一个光滑非线性函数约束为非负，并设置\n$$\nA = L\\,L^{\\top} + \\nu_{0}\\,I,\n$$\n其中 $I$ 是 $3\\times 3$ 的单位矩阵，$\\nu_{0}\\ge 0$ 是一个来自物理的标量基线涡粘性。指定如何从一个无约束的向量 $z \\in \\mathbb{R}^{6}$ 构建 $L$，以及如何从特征 $x \\in \\mathbb{R}^{p}$ 构建 $\\nu_{0}$，从而使 $A$ 是PSD。您的参数化必须包括：\n- 一个根据 $z$ 的元素定义 $L$ 的方法，其中对角线元素使用光滑函数（如由 $\\mathrm{softplus}(a)=\\log(1+\\exp(a))$ 定义的SoftPlus非线性）强制为非负。\n- 一个根据 $x$ 的线性映射并通过 $\\mathrm{softplus}$ 函数传递后定义 $\\nu_{0}$ 的方法。\n- 一个加到对角线元素上的小的正常数 $\\varepsilon$，以确保数值稳定性。\n\n第三部分 (实现)：实现一个程序，为几个测试用例构建 $A$，并使用第一部分推导的表达式验证非负耗散。使用以下对ML和物理组件的规范：\n- 维度为二维，因此 $s\\in\\mathbb{R}^{3}$ 且 $A\\in\\mathbb{R}^{3\\times 3}$。\n- 给定特征 $x\\in\\mathbb{R}^{5}$，形成 $z = W\\,x + b \\in \\mathbb{R}^{6}$，其中\n$$\nW = \\begin{bmatrix}\n0.5  &-0.3  &0.1  &0.0  &0.2 \\\\\n-0.4  &0.6  &-0.2  &0.1  &-0.1 \\\\\n0.3  &-0.5  &0.2  &-0.1  &0.0 \\\\\n0.2  &0.1  &-0.3  &0.5  &-0.4 \\\\\n-0.1  &0.4  &0.2  &-0.2  &0.3 \\\\\n0.6  &-0.2  &0.0  &0.1  &-0.3\n\\end{bmatrix},\\quad\nb = \\begin{bmatrix}-1.0 \\\\ -1.5 \\\\ -2.0 \\\\ 0.0 \\\\ 0.5 \\\\ -0.3\\end{bmatrix}.\n$$\n- 从 $z$ 构建 $L$ 如下\n$$\nL = \\begin{bmatrix}\nd_{1}  &0  &0 \\\\\n\\ell_{21}  &d_{2}  &0 \\\\\n\\ell_{31}  &\\ell_{32}  &d_{3}\n\\end{bmatrix},\n\\quad\n\\text{其中}\\quad\n\\begin{aligned}\nd_{1} = \\mathrm{softplus}(z_{1}) + \\varepsilon,\\\\\nd_{2} = \\mathrm{softplus}(z_{2}) + \\varepsilon,\\\\\nd_{3} = \\mathrm{softplus}(z_{3}) + \\varepsilon,\\\\\n\\ell_{21} = z_{4},\\ \\ell_{31} = z_{5},\\ \\ell_{32} = z_{6}.\n\\end{aligned}\n$$\n- 定义基线标量涡粘性为\n$$\n\\nu_{0} = \\mathrm{softplus}(\\gamma^{\\top} x + \\gamma_{0}),\n\\quad\n\\gamma = \\begin{bmatrix}0.2\\\\ -0.1\\\\ 0.4\\\\ 0.0\\\\ 0.3\\end{bmatrix},\\quad\n\\gamma_{0} = -0.2.\n$$\n- 使用 $\\varepsilon = 10^{-9}$。\n\n给定一个对称应变率矩阵\n$$\nS = \\begin{bmatrix} S_{xx}  &S_{xy} \\\\ S_{xy}  &S_{yy} \\end{bmatrix},\n$$\n形成 $s = [S_{xx}, \\sqrt{2}\\,S_{xy}, S_{yy}]^{\\top}$ 并根据您第一部分的推导计算耗散密度。\n\n使用以下特征向量 $x^{(k)}$ 和应变矩阵 $S^{(k)}$ 的测试套件：\n- 情况1：$x^{(1)} = [0.8, 0.1, 0.5, 0.0, 0.2]^{\\top}$，$S^{(1)} = \\begin{bmatrix}0.01  &0.02 \\\\ 0.02  &-0.01\\end{bmatrix}$。\n- 情况2：$x^{(2)} = [0.0, 0.0, 0.0, 0.0, 0.0]^{\\top}$，$S^{(2)} = \\begin{bmatrix}0.0  &0.0 \\\\ 0.0  &0.0\\end{bmatrix}$。\n- 情况3：$x^{(3)} = [2.0, -1.0, 3.0, 0.5, -0.5]^{\\top}$，$S^{(3)} = \\begin{bmatrix}0.5  &-0.8 \\\\ -0.8  &0.3\\end{bmatrix}$。\n- 情况4：$x^{(4)} = [-10.0, -10.0, -10.0, -10.0, -10.0]^{\\top}$，$S^{(4)} = \\begin{bmatrix}0.1  &-0.05 \\\\ -0.05  &0.2\\end{bmatrix}$。\n\n验证与数值容差：对于每种情况，计算耗散密度并以数值容差 $\\delta = 10^{-12}$ 检查其非负性，将大于或等于 $-\\delta$ 的值解释为非负。此外，计算 $A$ 的最小特征值并检查它在相同容差内是否为非负。\n\n最终输出格式：您的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表的结果，顺序为\n$$\n[\\text{B}_{1}, \\text{B}_{2}, \\text{B}_{3}, \\text{B}_{4}],\n$$\n其中 $\\text{B}_{k}$ 是一个布尔值，指示对于情况 $k$，耗散密度和 $A$ 的最小特征值是否均为非负（在容差范围内）。由于量是以一致的无量纲形式表示，因此不需要物理单位。",
            "solution": "该问题要求推导混合物理-机器学习模型的能量耗散条件，构建满足此条件的特定参数化方案，并实现该模型以对测试用例进行验证。解决方案按要求分为三部分呈现。\n\n### 第一部分：耗散密度的推导\n\n分析始于二维空间（$i,j \\in \\{x,y\\}$）中的滤波不可压缩Navier-Stokes方程。解析速度场 $\\mathbf{u}(\\mathbf{x},t)$ 的动量方程可写为：\n$$\n\\frac{\\partial u_i}{\\partial t} + u_j \\frac{\\partial u_i}{\\partial x_j} = - \\frac{\\partial p}{\\partial x_i} - \\frac{\\partial \\tau_{ij}}{\\partial x_j}\n$$\n此处，$p$ 是解析压力（已由常数密度 $\\rho=1$ 归一化），$\\tau_{ij}$ 是子网格尺度 (SGS) 应力张量，表示未解析运动对解析流动的影响。分子粘性已被忽略，这在子网格尺度效应占主导地位的高雷诺数湍流建模中是常见的。流动是不可压缩的，满足 $\\nabla \\cdot \\mathbf{u} = 0$，或 $\\partial u_k / \\partial x_k = 0$。\n\n解析动能密度定义为 $K = (1/2) \\mathbf{u}\\cdot\\mathbf{u} = (1/2) u_i u_i$。为了推导其演化方程，我们对 $K$ 取时间导数并代入动量方程：\n$$\n\\frac{\\partial K}{\\partial t} = u_i \\frac{\\partial u_i}{\\partial t} = u_i \\left( - u_j \\frac{\\partial u_i}{\\partial x_j} - \\frac{\\partial p}{\\partial x_i} - \\frac{\\partial \\tau_{ij}}{\\partial x_j} \\right)\n$$\n我们分析右侧的每一项：\n1. **平流项：** 使用乘积法则和不可压缩性条件，此项表示动能的输运：\n$$\n- u_i u_j \\frac{\\partial u_i}{\\partial x_j} = - u_j \\frac{\\partial}{\\partial x_j} \\left(\\frac{1}{2} u_i u_i\\right) = - \\mathbf{u} \\cdot \\nabla K = -\\nabla \\cdot (K\\mathbf{u})\n$$\n2. **压力项：** 此项表示由压力力引起的能量输运：\n$$\n- u_i \\frac{\\partial p}{\\partial x_i} = - \\frac{\\partial (u_i p)}{\\partial x_i} + p \\frac{\\partial u_i}{\\partial x_i} = -\\nabla \\cdot (p \\mathbf{u}) \\quad (\\text{因为 } \\nabla \\cdot \\mathbf{u} = 0)\n$$\n3. **SGS应力项：** 此项描述了解析尺度和未解析尺度之间的能量交换：\n$$\n- u_i \\frac{\\partial \\tau_{ij}}{\\partial x_j} = - \\frac{\\partial (u_i \\tau_{ij})}{\\partial x_j} + \\tau_{ij} \\frac{\\partial u_i}{\\partial x_j}\n$$\n第二部分 $\\tau_{ij} (\\partial u_i / \\partial x_j)$ 是SGS应力对解析速度场做功的速率。由于SGS张量 $\\tau_{ij}$ 是对称的，其与速度梯度张量的乘积可以通过将梯度分解为其对称和反对称部分来简化：\n$$\n\\tau_{ij} \\frac{\\partial u_i}{\\partial x_j} = \\tau_{ij} \\left( \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i}\\right) \\right) + \\tau_{ij} \\left( \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j} - \\frac{\\partial u_j}{\\partial x_i}\\right) \\right)\n$$\n右边的第二项为零，因为它是对称张量（$\\boldsymbol{\\tau}$）和反对称张量的内积。第一项涉及对称应变率张量 $S_{ij} = (1/2)(\\partial u_i / \\partial x_j + \\partial u_j / \\partial x_i)$。因此，功速率为 $\\boldsymbol{\\tau}:S$。\n\n综合所有项，逐点动能收支为：\n$$\n\\frac{\\partial K}{\\partial t} = -\\nabla \\cdot (K\\mathbf{u}) - \\nabla \\cdot (p\\mathbf{u}) - \\nabla \\cdot (\\mathbf{u} \\cdot \\boldsymbol{\\tau}) + \\boldsymbol{\\tau}:S\n$$\n最后一项 $\\boldsymbol{\\tau}:S$ 表示从解析尺度产生（若为正）或移除（若为负）动能。逐点耗散密度 $\\mathcal{D}$ 定义为从解析尺度到子网格尺度的能量传递速率，这对应于能量收支中的一个损失项。因此，$\\mathcal{D} = -\\boldsymbol{\\tau}:S$。为使模型具有物理耗散性，我们要求 $\\mathcal{D} \\ge 0$。\n\n问题指出涡粘性闭合是作用于对称二阶张量空间的线性算子，在Voigt表示法中由矩阵 $A$ 表示。一个广义的线性各向异性涡粘性模型，是对标量模型 $\\boldsymbol{\\tau}=-2\\nu_t S$ 的扩展，其形式为：\n$$\nt_v = -2 A s\n$$\n其中 $t_v$ 和 $s$ 分别是 $\\boldsymbol{\\tau}$ 和 $S$ 的Voigt向量化形式。问题指定的Voigt映射使得Frobenius内积 $S:S$ 等于 $s^\\top s$。此性质可推广到两个不同张量的内积，即 $\\boldsymbol{\\tau}:S = t_v^\\top s$。\n\n将模型代入耗散密度表达式：\n$$\n\\mathcal{D} = -\\boldsymbol{\\tau}:S = -t_v^\\top s = -(-2As)^\\top s = 2(As)^\\top s = 2 s^\\top A^\\top s\n$$\n由于问题指定 $A$ 是一个对称矩阵（$A^\\top = A$），逐点耗散密度的最终表达式为：\n$$\n\\mathcal{D} = 2 s^\\top A s\n$$\n为保证对于任何可能的流动状态（即对于任何对称应变率张量 $S$ 及其对应的向量 $s$）耗散均为非负（$\\mathcal{D} \\ge 0$），必须满足条件 $s^\\top A s \\ge 0$ 对所有 $s \\in \\mathbb{R}^3$ 成立。这是半正定 (PSD) 矩阵的定义。因此，如果矩阵 $A$ 是PSD，该闭合模型保证非负的能量耗散。\n\n对于一个域 $\\Omega$ 上的总动能收支，需要对逐点方程进行积分。散度项可以通过散度定理转换成面积分。为分离出总耗散，必须假设边界条件（例如，周期性边界），使得这些面积分为零。\n\n### 第二部分：保证PSD的参数化\n\n目标是参数化对称矩阵 $A \\in \\mathbb{R}^{3\\times 3}$，以保证其无论机器学习模型的无约束输出为何值，都是半正定的。一个构建PSD矩阵的稳健方法是通过类Cholesky分解。我们提出以下形式：\n$$\nA = L L^\\top + \\nu_0 I\n$$\n其中 $L \\in \\mathbb{R}^{3\\times 3}$ 是一个下三角矩阵，$I$ 是 $3\\times 3$ 单位矩阵，$\\nu_0 \\ge 0$ 是一个标量基线粘性。\n\n这种构造保证了 $A$ 是PSD。为了证明这一点，考虑对于任何向量 $s \\in \\mathbb{R}^3$ 的二次型 $s^\\top A s$：\n$$\ns^\\top A s = s^\\top (L L^\\top + \\nu_0 I) s = s^\\top L L^\\top s + \\nu_0 s^\\top I s = (L^\\top s)^\\top (L^\\top s) + \\nu_0 s^\\top s = \\|L^\\top s\\|_2^2 + \\nu_0 \\|s\\|_2^2\n$$\n由于任何向量的欧几里得范数的平方都是非负的，并且我们强制 $\\nu_0 \\ge 0$，因此右侧的两项都是非负的。所以，$s^\\top A s \\ge 0$，这证明了 $A$ 是PSD。\n\n从无约束的ML输出向量 $z \\in \\mathbb{R}^6$ 和特征向量 $x \\in \\mathbb{R}^p$ 进行的具体参数化如下：\n1. 下三角矩阵 $L$ 由 $z$ 构造：\n$$\nL = \\begin{bmatrix} d_1  &0  &0 \\\\ \\ell_{21}  &d_2  &0 \\\\ \\ell_{31}  &\\ell_{32}  &d_3 \\end{bmatrix}\n$$\n非对角线元素是无约束的，可以直接从 $z$ 中取值：$\\ell_{21} = z_4$，$\\ell_{31} = z_5$，$\\ell_{32} = z_6$。\n对角线元素必须是非负的。这通过使用SoftPlus函数 $\\mathrm{softplus}(a) = \\log(1+\\exp(a))$ 来强制实现，该函数将任何实数映射到一个正实数。为了数值稳定性，加入一个小的常数 $\\varepsilon > 0$，确保对角线项是严格为正的。\n$$\n\\begin{aligned}\nd_1 = \\mathrm{softplus}(z_1) + \\varepsilon \\\\\nd_2 = \\mathrm{softplus}(z_2) + \\varepsilon \\\\\nd_3 = \\mathrm{softplus}(z_3) + \\varepsilon\n\\end{aligned}\n$$\n2. 基线标量涡粘性 $\\nu_0$ 也必须是非负的。它由特征向量 $x$ 通过一个线性变换后，再经过SoftPlus函数构造：\n$$\n\\nu_0 = \\mathrm{softplus}(\\gamma^\\top x + \\gamma_0)\n$$\n其中 $\\gamma$ 是一个权重向量，$\\gamma_0$ 是一个偏置。这保证了 $\\nu_0 > 0$。\n\n这种参数化保证了 $A$ 不仅是PSD，而且是严格正定 (PD) 的，因为对于任何 $s \\ne 0$，都有 $\\|s\\|_2^2 > 0$，并且 $\\nu_0 > 0$。\n\n### 第三部分：实现逻辑\n\n实现将遵循第二部分的参数化和第一部分的耗散公式，以在提供的测试用例上验证模型。对于由特征向量 $x^{(k)}$ 和应变率矩阵 $S^{(k)}$ 定义的每个用例，执行以下步骤：\n1. **计算ML输出：** 使用给定的仿射变换从特征 $x$ 计算无约束向量 $z$：$z = Wx + b$。\n2. **构造L：** 按照第二部分中的规定，使用 $z$ 的元素组装下三角矩阵 $L$。对角线元素使用SoftPlus函数计算，并加上 $\\varepsilon = 10^{-9}$。\n3. **计算$\\nu_0$：** 使用指定的线性模型和SoftPlus函数从 $x$ 计算基线粘性 $\\nu_0$。\n4. **构造A：** 构建PSD矩阵 $A$ 为 $A = L L^\\top + \\nu_0 I$。\n5. **计算A的特征值：** 计算对称矩阵 $A$ 的特征值。确定最小特征值 $\\lambda_{\\min}$。根据理论，$\\lambda_{\\min}$ 必须是非负的。我们检查是否 $\\lambda_{\\min} \\ge -\\delta$，容差为 $\\delta = 10^{-12}$。\n6. **计算耗散：** 将应变率矩阵 $S$ 转换为其Voigt向量形式 $s = [S_{xx}, \\sqrt{2}S_{xy}, S_{yy}]^\\top$。然后计算耗散密度为 $\\mathcal{D} = 2 s^\\top A s$。\n7. **验证耗散：** 计算出的耗散 $\\mathcal{D}$ 必须是非负的。我们检查是否 $\\mathcal{D} \\ge -\\delta$。\n8. **确定结果：** 当且仅当最小特征值和耗散密度在指定容差内均为非负时，该用例的布尔结果 $\\text{B}_k$ 为 `True`。\n对所有四个测试用例重复这些步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by constructing a PSD eddy-viscosity matrix A\n    and verifying non-negative dissipation for several test cases.\n    \"\"\"\n\n    # --- Problem Constants and Definitions ---\n\n    # Part III: ML model parameters\n    W = np.array([\n        [0.5, -0.3, 0.1, 0.0, 0.2],\n        [-0.4, 0.6, -0.2, 0.1, -0.1],\n        [0.3, -0.5, 0.2, -0.1, 0.0],\n        [0.2, 0.1, -0.3, 0.5, -0.4],\n        [-0.1, 0.4, 0.2, -0.2, 0.3],\n        [0.6, -0.2, 0.0, 0.1, -0.3]\n    ])\n    b = np.array([-1.0, -1.5, -2.0, 0.0, 0.5, -0.3])\n\n    gamma = np.array([0.2, -0.1, 0.4, 0.0, 0.3])\n    gamma_0 = -0.2\n\n    epsilon = 1e-9\n    delta = 1e-12\n\n    # Part II: Smooth nonlinearity\n    def softplus(a):\n        \"\"\"Computes the softplus function log(1 + exp(a)).\"\"\"\n        # Clip 'a' to avoid overflow in exp(a) for large positive values.\n        # For large a, softplus(a) approaches a.\n        # For large negative a, softplus(a) approaches 0.\n        clipped_a = np.clip(a, -np.inf, 50)\n        return np.log(1.0 + np.exp(clipped_a))\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"x\": np.array([0.8, 0.1, 0.5, 0.0, 0.2]),\n            \"S\": np.array([[0.01, 0.02], [0.02, -0.01]])\n        },\n        {\n            \"x\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"S\": np.array([[0.0, 0.0], [0.0, 0.0]])\n        },\n        {\n            \"x\": np.array([2.0, -1.0, 3.0, 0.5, -0.5]),\n            \"S\": np.array([[0.5, -0.8], [-0.8, 0.3]])\n        },\n        {\n            \"x\": np.array([-10.0, -10.0, -10.0, -10.0, -10.0]),\n            \"S\": np.array([[0.1, -0.05], [-0.05, 0.2]])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        x = case[\"x\"]\n        S = case[\"S\"]\n\n        # 1. Compute ML outputs (z and nu_0)\n        z = W @ x + b\n        nu_0 = softplus(gamma.T @ x + gamma_0)\n\n        # 2. Construct the lower-triangular matrix L\n        L = np.zeros((3, 3))\n        # Diagonals with softplus and epsilon\n        L[0, 0] = softplus(z[0]) + epsilon\n        L[1, 1] = softplus(z[1]) + epsilon\n        L[2, 2] = softplus(z[2]) + epsilon\n        # Off-diagonals\n        L[1, 0] = z[3]  # l_21\n        L[2, 0] = z[4]  # l_31\n        L[2, 1] = z[5]  # l_32\n\n        # 3. Construct the PSD matrix A\n        A = L @ L.T + nu_0 * np.eye(3)\n\n        # 4. Check if A is PSD by computing its smallest eigenvalue\n        # Use eigvalsh for symmetric matrices for efficiency and numerical stability\n        eigenvalues = np.linalg.eigvalsh(A)\n        min_eigenvalue = np.min(eigenvalues)\n        is_psd = min_eigenvalue >= -delta\n\n        # 5. Form strain-rate vector s\n        S_xx, S_xy, S_yy = S[0, 0], S[0, 1], S[1, 1]\n        s = np.array([S_xx, np.sqrt(2) * S_xy, S_yy])\n\n        # 6. Compute dissipation density D = 2 * s^T * A * s\n        dissipation = 2 * s.T @ A @ s\n        is_dissipation_nonnegative = dissipation >= -delta\n        \n        # 7. Final check for the case\n        results.append(is_psd and is_dissipation_nonnegative)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}