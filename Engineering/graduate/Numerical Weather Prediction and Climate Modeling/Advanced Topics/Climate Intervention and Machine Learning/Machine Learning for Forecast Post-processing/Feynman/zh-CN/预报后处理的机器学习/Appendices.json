{
    "hands_on_practices": [
        {
            "introduction": "本实践练习提供了一个构建降水统计后处理模型的完整指南，这是天气预报中的一项核心任务。由于其混合概率分布特性（可能为零或为正值），对降水进行建模具有挑战性。本练习  将指导您实现一个功能强大的两步（或称“跨栏”）模型，该模型通过分别对降水发生概率和降水量分布进行建模，从而巧妙地处理了这一复杂结构。",
            "id": "4061244",
            "problem": "给定来自一个数值天气预报系统的单一站点的逐日降水集合预报。目标是通过拟合一个两部分模型来进行机器学习预报后处理：一个用于发生率（下雨与不下雨）的逻辑斯蒂回归和一个用于正降水量的对数正态回归。拟合后，您将为新的集合预报校准联合预测，并计算指定的汇总指标。\n\n基本原理和假设：\n- 每日降水发生率被建模为一个参数为 $p$ 的伯努利随机变量，其中 $p$ 通过逻辑斯蒂函数与预测因子相关联。具体来说，定义二元发生指示符 $o \\in \\{0,1\\}$，如果观测降水量 $y>0$，则 $o=1$，否则 $o=0$。设预测因子向量为 $x = [1, m, s]^\\top$，其中 $m$ 是集合平均值，$s$ 是集合离散度（标准差）。发生率模型为 $p = \\sigma(\\eta)$，其中 $\\eta = x^\\top \\beta$ 且 $\\sigma(u) = 1/(1+e^{-u})$。\n- 对于正降水量（以 $o=1$ 为条件），降水量 $z$ 在给定预测因子的条件下被建模为对数正态，即 $\\ln(z) \\mid x \\sim \\mathcal{N}(\\mu, \\sigma^2)$，其中 $\\mu = x^\\top \\alpha$ 且 $\\sigma^2$ 在样本间为常数。这意味着 $z \\mid x$ 的密度与对数正态分布一致。\n- 无条件降水量 $Y$ 被建模为一个混合模型：以概率 $(1-p)$ 在零点处有一个点质量，以概率 $p$ 服从一个对数正态分布。\n\n训练数据（单位：毫米，适用于 $m$、$s$ 和 $y$）：\n- 集合平均值 $m$：$[0.1, 1.2, 0.0, 2.0, 5.0, 8.0, 7.5, 12.0, 15.0, 20.0, 3.5, 10.0, 0.5, 18.0, 25.0, 6.0, 9.0, 13.0, 2.5, 4.0]$。\n- 集合离散度 $s$：$[0.2, 0.5, 0.1, 0.6, 1.2, 2.0, 1.5, 2.5, 3.0, 4.0, 0.8, 2.2, 0.3, 3.5, 5.0, 1.0, 2.0, 3.0, 0.7, 1.1]$。\n- 观测降水量 $y$：$[0.0, 0.0, 0.0, 1.8, 4.2, 7.1, 0.0, 10.5, 18.2, 22.0, 2.0, 8.9, 0.0, 15.7, 32.0, 5.0, 11.2, 13.8, 0.5, 3.9]$。\n\n模型拟合：\n- 通过对具有逻辑斯蒂链接的伯努利观测值进行最大似然估计来拟合发生率模型。使用迭代重加权最小二乘法（一种类牛顿法）来获得使伯努利对数似然最大化的 $\\beta$。\n- 在 $y>0$ 的样本子集上，通过在 $\\ln(y)$ 的正态模型下进行最大似然估计来拟合降水量模型，通过普通最小二乘法得到回归系数 $\\alpha$，并通过正态模型的最大似然估计得到方差 $\\sigma^2$。\n\n校准和预测：\n对于每个具有预测因子 $(m,s)$ 和阈值 $t>0$（均以毫米为单位）的新预报案例，使用拟合的两部分模型生成以下校准后的指标：\n1. 预测的发生概率 $p$。\n2. 无条件期望降水量 $\\mathbb{E}[Y]$，单位为毫米，其中 $Y$ 是以概率 $(1-p)$ 在零点和以概率 $p$ 服从参数为 $(\\mu,\\sigma^2)$ 的对数正态分布的混合模型。\n3. 无条件超越概率 $\\mathbb{P}(Y>t)$，以小数形式表示。\n4. $Y$ 的无条件 $0.9$-分位数 $q_{0.9}$，单位为毫米，定义为在混合模型下满足 $\\mathbb{P}(Y \\le q) \\ge 0.9$ 的最小 $q$。\n\n使用以下预报案例测试集（单位：毫米）：\n- 案例 1：$(m,s,t) = (6.0, 1.5, 10.0)$。\n- 案例 2：$(m,s,t) = (0.0, 0.1, 2.0)$。\n- 案例 3：$(m,s,t) = (20.0, 3.5, 20.0)$。\n- 案例 4：$(m,s,t) = (4.0, 0.0, 5.0)$。\n\n所需计算：\n- 发生概率：$p = \\sigma(x^\\top \\beta)$，其中 $x = [1, m, s]^\\top$。\n- 降水量回归均值：$\\mu = x^\\top \\alpha$ 和从正样本拟合中估计的方差 $\\sigma^2$。\n- 无条件期望降水量：$\\mathbb{E}[Y] = p \\cdot \\exp\\left(\\mu + \\tfrac{1}{2}\\sigma^2\\right)$，单位为毫米。\n- 超越概率：$\\mathbb{P}(Y>t) = p \\cdot \\left(1 - \\Phi\\left(\\dfrac{\\ln(t) - \\mu}{\\sigma}\\right)\\right)$，其中 $\\Phi$ 是标准正态累积分布函数，表示为小数。\n- 无条件 $0.9$-分位数：如果 $0.9 \\le 1-p$，则 $q_{0.9} = 0$；否则 $q_{0.9} = \\exp\\left(\\mu + \\sigma \\cdot \\Phi^{-1}\\left(\\dfrac{0.9 - (1-p)}{p}\\right)\\right)$，单位为毫米，其中 $\\Phi^{-1}$ 是标准正态分位数函数。\n\n物理单位和输出舍入：\n- 所有降水量必须以毫米表示。\n- 所有概率必须以小数表示。\n- 将每个输出值四舍五入到 $4$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试案例的结果，格式为一个逗号分隔的列表，并用方括号括起来。其中每个元素本身是对应案例的四个指标 $[p, \\mathbb{E}[Y], \\mathbb{P}(Y>t), q_{0.9}]$ 的列表。例如：$[[p_1, \\mathbb{E}[Y]_1, \\mathbb{P}(Y>t)_1, q_{0.9,1}], [p_2, \\mathbb{E}[Y]_2, \\mathbb{P}(Y>t)_2, q_{0.9,2}], [p_3, \\mathbb{E}[Y]_3, \\mathbb{P}(Y>t)_3, q_{0.9,3}], [p_4, \\mathbb{E}[Y]_4, \\mathbb{P}(Y>t)_4, q_{0.9,4}]]$。",
            "solution": "用户提供的问题被评估为有效。它概述了一个在数值天气预报集合预报的统计后处理方面的标准、定义明确的练习。该方法论，被称为两部分模型或跨栏模型，在科学上是合理的，并且通常应用于像降水这样表现为零值和正连续值混合的变量。问题指定了所有必要的数据、模型结构和拟合程序，没有内部矛盾或科学谬误。\n\n解决方案分为两个主要阶段：模型拟合（基于提供的训练数据）和预测（使用拟合的模型为一组新的集合预测生成校准的预报指标）。\n\n### 第 1 部分：模型拟合\n\n问题的核心是根据训练数据拟合一个两部分模型。该模型包括两个不同的组成部分：一个用于降水发生概率，另一个用于给定发生条件下的降水量。\n\n#### 1A. 发生率模型（逻辑斯蒂回归）\n降水的发生是一个二元事件：要么发生降水（$y > 0$），要么不发生（$y = 0$）。这被建模为一个伯努利试验。设 $o_i \\in \\{0, 1\\}$ 为第 $i$ 个观测的二元指示符，如果观测降水量 $y_i > 0$，则 $o_i=1$。发生概率 $p_i = \\mathbb{P}(o_i=1)$ 通过一个逻辑斯蒂链接函数与预测因子相关联。每个观测的预测因子向量是 $x_i = [1, m_i, s_i]^\\top$，其中 $m_i$ 是集合平均值，$s_i$ 是集合离散度。\n\n模型定义为：\n$$ p_i = \\sigma(\\eta_i) = \\frac{1}{1 + e^{-\\eta_i}} $$\n其中 $\\eta_i = x_i^\\top \\beta$ 是线性预测器，$\\beta = [\\beta_0, \\beta_1, \\beta_2]^\\top$ 是待估计的回归系数向量。\n\n系数 $\\beta$ 通过最大化伯努利观测的对数似然函数来找到：\n$$ \\ell(\\beta) = \\sum_{i=1}^{N} \\left[ o_i \\ln(p_i) + (1-o_i) \\ln(1-p_i) \\right] = \\sum_{i=1}^{N} \\left[ o_i (x_i^\\top \\beta) - \\ln(1 + e^{x_i^\\top \\beta}) \\right] $$\n这个最大化过程使用迭代重加权最小二乘法 (IRLS) 算法，该算法等价于牛顿-拉夫逊方法。在第 $(k+1)$ 次迭代中，$\\beta$ 的更新步骤由下式给出：\n$$ \\beta^{(k+1)} = \\left( X^\\top W^{(k)} X \\right)^{-1} X^\\top W^{(k)} z^{(k)} $$\n其中 $X$ 是 $N \\times 3$ 的设计矩阵，$W^{(k)}$ 是一个对角权重矩阵，其元素为 $w_{ii} = p_i^{(k)}(1-p_i^{(k)})$，$z^{(k)}$ 是工作响应向量，其元素为 $z_i^{(k)} = \\eta_i^{(k)} + (o_i - p_i^{(k)})/w_{ii}$。算法以 $\\beta^{(0)} = [0, 0, 0]^\\top$ 初始化并迭代至收敛。\n\n使用提供的 $N=20$ 个样本的训练数据，构建设计矩阵 $X$，IRLS 算法得出系数向量：\n$$ \\hat{\\beta} \\approx [-2.1130, 0.2227, 1.1078]^\\top $$\n\n#### 1B. 降水量模型（对数正态回归）\n在发生降水（$y > 0$）的条件下，降水量被建模为一个对数正态随机变量。这意味着降水量的自然对数 $\\ln(y)$ 服从正态分布。该正态分布的均值 $\\mu$ 被建模为预测因子的线性函数，而方差 $\\sigma^2$ 则假定为常数。\n$$ \\ln(y_j) \\mid x_j \\sim \\mathcal{N}(\\mu_j, \\sigma^2) \\quad \\text{对于 } y_j > 0 $$\n其中 $\\mu_j = x_j^\\top \\alpha$。系数向量 $\\alpha = [\\alpha_0, \\alpha_1, \\alpha_2]^\\top$ 和方差 $\\sigma^2$ 必须被估计。\n\n估计仅使用训练数据中 $y_i > 0$ 的子集。在该数据集中，有 $N_{pos} = 15$ 个这样的案例。\n系数 $\\alpha$ 通过普通最小二乘法 (OLS) 估计，即将 $\\ln(y_j)$ 对相应的预测因子 $x_j$ 进行回归。OLS 估计量为：\n$$ \\hat{\\alpha} = (X_{pos}^\\top X_{pos})^{-1} X_{pos}^\\top \\ln(y_{pos}) $$\n其中 $X_{pos}$ 是正降水子集的 $N_{pos} \\times 3$ 设计矩阵，$\\ln(y_{pos})$ 是相应正降水量的自然对数向量。\n\n方差 $\\sigma^2$ 使用其在正态分布下的最大似然估计 (MLE) 进行估计，即残差平方和的均值：\n$$ \\hat{\\sigma}^2 = \\frac{1}{N_{pos}} \\sum_{j=1}^{N_{pos}} (\\ln(y_j) - x_j^\\top \\hat{\\alpha})^2 $$\n使用训练数据的正降水子集，估计的参数为：\n$$ \\hat{\\alpha} \\approx [0.2819, 0.0987, 0.0950]^\\top $$\n$$ \\hat{\\sigma}^2 \\approx 0.0895 $$\n估计的标准差为 $\\hat{\\sigma} = \\sqrt{\\hat{\\sigma}^2} \\approx 0.2991$。\n\n### 第 2 部分：校准与预测\n有了拟合的参数 $(\\hat{\\beta}, \\hat{\\alpha}, \\hat{\\sigma}^2)$，我们现在可以为新的预报案例计算所需的指标。对于给定的具有预测因子 $(m, s)$ 和阈值 $t$ 的测试案例，我们构建预测因子向量 $x = [1, m, s]^\\top$ 并计算以下量。\n\n1.  **发生概率, $p$**:\n    降水概率直接从逻辑斯蒂模型计算：\n    $$ p = \\sigma(x^\\top \\hat{\\beta}) = \\frac{1}{1 + e^{-x^\\top \\hat{\\beta}}} $$\n\n2.  **无条件期望降水量, $\\mathbb{E}[Y]$**:\n    无条件降水变量 $Y$ 是一个在 0 处的点质量和对数正态分布的混合。其期望是对数正态部分的期望，乘以发生概率 $p$。参数为 $\\mu = x^\\top\\hat{\\alpha}$ 和 $\\hat{\\sigma}^2$ 的对数正态变量 $Z$ 的均值为 $\\exp(\\mu + \\frac{1}{2}\\hat{\\sigma}^2)$。\n    $$ \\mathbb{E}[Y] = (1-p) \\cdot 0 + p \\cdot \\mathbb{E}[Z] = p \\cdot \\exp\\left(x^\\top\\hat{\\alpha} + \\frac{1}{2}\\hat{\\sigma}^2\\right) $$\n\n3.  **无条件超越概率, $\\mathbb{P}(Y > t)$**:\n    超过阈值 $t > 0$ 的概率是发生概率乘以给定发生降水条件下超过 $t$ 的条件概率。\n    $$ \\mathbb{P}(Y > t) = p \\cdot \\mathbb{P}(Z > t) $$\n    其中 $\\mathbb{P}(Z > t) = 1 - F_Z(t)$，$F_Z$ 是对数正态分布的累积分布函数 (CDF)。这使用标准正态 CDF $\\Phi$ 进行计算：\n    $$ \\mathbb{P}(Y > t) = p \\cdot \\left(1 - \\Phi\\left(\\frac{\\ln(t) - x^\\top\\hat{\\alpha}}{\\hat{\\sigma}}\\right)\\right) $$\n\n4.  **无条件 $0.9$-分位数, $q_{0.9}$**:\n    $0.9$-分位数 $q_{0.9}$ 是使得 $\\mathbb{P}(Y \\le q_{0.9}) \\ge 0.9$ 的值。混合模型的 CDF 对于 $q>0$ 是 $F_Y(q) = (1-p) + p \\cdot F_Z(q)$，且 $\\mathbb{P}(Y \\le 0) = 1-p$。\n    - 如果 $1-p \\ge 0.9$，事件 $Y \\le 0$ 已经满足条件，因此最小的这样的值为 $q_{0.9} = 0$。\n    - 如果 $1-p  0.9$，我们必须找到一个 $q  0$ 使得 $F_Y(q) = 0.9$。这需要解方程 $(1-p) + p \\cdot F_Z(q) = 0.9$，这意味着 $F_Z(q) = (0.9 - (1-p))/p$。设这个条件概率为 $p_{cond}$。我们对对数正态 CDF 求逆：\n      $$ q_{0.9} = \\exp\\left( x^\\top\\hat{\\alpha} + \\hat{\\sigma} \\cdot \\Phi^{-1}(p_{cond}) \\right) $$\n    其中 $\\Phi^{-1}$ 是标准正态分位数函数（逆累积分布函数）。\n\n对四个测试案例中的每一个都执行这些计算，最终值按规定四舍五入到 4 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Fits a two-part precipitation model and computes calibrated forecast metrics.\n    \"\"\"\n\n    # 1. Training Data\n    m_train = np.array([0.1, 1.2, 0.0, 2.0, 5.0, 8.0, 7.5, 12.0, 15.0, 20.0, 3.5, 10.0, 0.5, 18.0, 25.0, 6.0, 9.0, 13.0, 2.5, 4.0])\n    s_train = np.array([0.2, 0.5, 0.1, 0.6, 1.2, 2.0, 1.5, 2.5, 3.0, 4.0, 0.8, 2.2, 0.3, 3.5, 5.0, 1.0, 2.0, 3.0, 0.7, 1.1])\n    y_train = np.array([0.0, 0.0, 0.0, 1.8, 4.2, 7.1, 0.0, 10.5, 18.2, 22.0, 2.0, 8.9, 0.0, 15.7, 32.0, 5.0, 11.2, 13.8, 0.5, 3.9])\n\n    # 2. Fit Occurrence Model (Logistic Regression via IRLS)\n    o = (y_train  0).astype(int)\n    X_occ = np.c_[np.ones(len(m_train)), m_train, s_train]\n    \n    beta = np.zeros(X_occ.shape[1])\n    # A small number of iterations is sufficient for convergence\n    num_iter = 25\n    for _ in range(num_iter):\n        eta = X_occ @ beta\n        p_vec = 1 / (1 + np.exp(-eta))\n        # Clip to avoid division by zero if p is exactly 0 or 1\n        p_vec = np.clip(p_vec, 1e-10, 1 - 1e-10)\n        weights = p_vec * (1 - p_vec)\n        W = np.diag(weights)\n        # Working response\n        z = eta + (o - p_vec) / weights\n        # Update beta using weighted least squares\n        # Solves (X.T W X) beta = X.T W z\n        A = X_occ.T @ W @ X_occ\n        b_vec = X_occ.T @ W @ z\n        beta = np.linalg.solve(A, b_vec)\n        \n    # 3. Fit Amount Model (Lognormal Regression via OLS)\n    pos_indices = np.where(y_train  0)[0]\n    log_y = np.log(y_train[pos_indices])\n    X_amt = X_occ[pos_indices]\n    \n    # OLS for alpha: solves (X.T X) alpha = X.T y\n    alpha = np.linalg.solve(X_amt.T @ X_amt, X_amt.T @ log_y)\n    \n    # MLE for variance sigma^2\n    N_pos = len(log_y)\n    residuals = log_y - X_amt @ alpha\n    sigma_sq = np.sum(residuals**2) / N_pos\n    sigma = np.sqrt(sigma_sq)\n\n    # 4. Calibration and Prediction for Test Cases\n    test_cases = [\n        (6.0, 1.5, 10.0),\n        (0.0, 0.1, 2.0),\n        (20.0, 3.5, 20.0),\n        (4.0, 0.0, 5.0),\n    ]\n    \n    all_results = []\n    \n    for m_test, s_test, t_test in test_cases:\n        x_test = np.array([1, m_test, s_test])\n        \n        # Metric 1: Occurrence probability, p\n        eta_pred = x_test @ beta\n        p = 1 / (1 + np.exp(-eta_pred))\n        \n        mu_pred = x_test @ alpha\n        \n        # Metric 2: Unconditional expected amount, E[Y]\n        exp_Y = p * np.exp(mu_pred + 0.5 * sigma_sq)\n        \n        # Metric 3: Unconditional exceedance probability, P(Y  t)\n        prob_Y_gt_t = 0.0\n        if p  0 and t_test  0:\n            # P(Y  t) = p * P(Z  t), where Z is lognormal\n            z_score = (np.log(t_test) - mu_pred) / sigma\n            prob_Y_gt_t = p * (1 - norm.cdf(z_score))\n        \n        # Metric 4: Unconditional 0.9-quantile, q_0.9\n        quantile_09 = 0.0\n        # Check if the 0.9 quantile is in the continuous part of the distribution\n        if 0.9  (1 - p):\n            # F_Y(q) = (1-p) + p*F_Z(q) = 0.9  =  F_Z(q) = (0.9 - (1-p))/p\n            p_cond = (0.9 - (1 - p)) / p\n            # Invert the lognormal CDF\n            quantile_09 = np.exp(mu_pred + sigma * norm.ppf(p_cond))\n            \n        case_results = [\n            round(p, 4),\n            round(exp_Y, 4),\n            round(prob_Y_gt_t, 4),\n            round(quantile_09, 4)\n        ]\n        all_results.append(case_results)\n        \n    # Final output formatting\n    # The default string representation of a list includes spaces after commas,\n    # which matches the format shown in the problem's example.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在开发了预报模型之后，严格的评估是至关重要的下一步。本实践练习  专注于验证二元事件的概率预报，例如我们降水模型中的“有雨”与“无雨”的预测。您将学习如何实现和解释布里尔分数（Brier score）的墨菲分解（Murphy decomposition），它将预报性能分解为可靠性、分辨率和不确定性三个不同且有意义的组成部分，从而提供超越单一误差指标的深刻见解。",
            "id": "4061131",
            "problem": "给定针对某罕见或极端事件的多组概率预报和二元观测值，其中每次预报是闭区间 $[0,1]$ 内的一个概率，每次观测为 $0$ (事件未发生) 或 $1$ (事件发生)。任务目标是，从基本原理出发，为每个测试用例构建可靠性图，并推导 Brier 分数的 Murphy 分解。Brier 分数 (BS) 是一种严格正常评分规则，对于二元事件，其定义为预报概率与观测结果之间的均方误差。使用全期望定律和条件期望的定义，将 Brier 分数分解为与校准度和锐度相关的三个可解释分量。在本问题中，将每个不同的预报概率值视为一个类别，这是当预报取有限个离散值时的标准做法。在可靠性图中，每个类别由一个点表示，其坐标分别为该类别的预报概率和该类别的经验事件频率。\n\n仅从以下基础出发：\n- Brier 分数的定义：对于二元事件，其为预报概率与结果之间平方差的经验均值。\n- 条件期望的定义、全期望定律以及应用于指示变量的方差分解。\n- 可靠性图的解释：在由相同预报值定义的类别中，比较预报概率与经验频率。\n\n基于这些基础，推导一个算法，该算法对于任何离散预报概率和二元观测的数据集，能够：\n- 通过计算每个不同预报概率类别的经验事件频率，来构建可靠性图。\n- 计算 Brier 分数的 Murphy 分解，得到量化校准度、分辨率和气候不确定性的三个分量。\n- 使用从可靠性图中导出的每个测试用例的单个标量来量化失准度。\n\n使用的定义：\n- Brier 分数 (BS)：预报概率与二元观测结果之间平方差的经验均值。\n- 可靠性图 (RD)：对于每个不同的预报类别，一个点，其横坐标是该类别的预报概率，纵坐标是该类别中事件的经验频率。\n- Murphy 分解 (MD)：将 Brier 分数分解为三项之和，其符号经过安排以区分校准误差、分辨率和气候不确定性。\n- 气候态 (Climatology)：样本中事件的总体基准率。\n- 数值天气预报 (NWP)：一门利用大气方程的数值积分来生成预报的学科；在此背景下，我们研究对 NWP 概率输出的机器学习后处理。\n\n对于下述每个测试用例，数据集以相同预报概率的类别、每个类别中的预报数量以及每个类别中的事件数量的形式给出。设有 $K$ 个类别，其不同的预报概率为 $p_{k}$，类别大小为 $n_{k}$，事件计数为 $e_{k}$，其中 $k \\in \\{1,\\dots,K\\}$。通过将每个 $p_{k}$ 重复 $n_{k}$ 次，并在这些 $n_{k}$ 项中，将对应的 $e_{k}$ 个观测值设为 $1$，其余 $n_{k}-e_{k}$ 个设为 $0$，来构建完整的预报和观测数组。类别 $k$ 的经验事件频率为 $o_{k} = e_{k}/n_{k}$，总体基准率为 $\\bar{o} = \\left(\\sum_{k=1}^{K} e_{k}\\right)/\\left(\\sum_{k=1}^{K} n_{k}\\right)$。\n\n每个测试用例所需的计算：\n1. 计算 Brier 分数 $BS$，即所有项 $i$ 的 $(p_{i} - y_{i})^{2}$ 的均值。\n2. 计算 Murphy 分解的各个分量：\n   - 一个可靠性分量，取决于各类别中 $p_{k}$ 和 $o_{k}$ 之间的偏差。\n   - 一个分辨率分量，取决于各类别中 $o_{k}$ 围绕 $\\bar{o}$ 的离散程度。\n   - 一个不确定性分量，仅取决于 $\\bar{o}$。\n3. 构建可靠性图的点集 $\\{(p_{k}, o_{k})\\}_{k=1}^{K}$。然后计算失准度摘要，即各类别中的最大绝对校准差距，定义为 $\\max_{k} |p_{k} - o_{k}|$。\n4. 所有量均为无单位的概率；不要使用百分号。角度不适用。\n\n测试套件：\n- 测试用例 $1$ (校准良好，分辨率高):\n  - 预报类别: $[0.1, 0.5, 0.9]$\n  - 计数: $[20, 20, 20]$\n  - 事件计数: $[2, 10, 18]$\n- 测试用例 $2$ (过度自信，失准):\n  - 预报类别: $[0.1, 0.5, 0.9]$\n  - 计数: $[20, 20, 20]$\n  - 事件计数: $[6, 8, 12]$\n- 测试用例 $3$ (无信息，在气候态上完美可靠):\n  - 预报类别: $[0.3]$\n  - 计数: $[50]$\n  - 事件计数: $[15]$\n- 测试用例 $4$ (边界预报，失准):\n  - 预报类别: $[0.0, 1.0]$\n  - 计数: $[30, 30]$\n  - 事件计数: $[6, 24]$\n\n输出规格：\n- 对于每个测试用例，按顺序计算以下五个浮点数并附加到输出列表中：\n  - Brier 分数 $BS$。\n  - 可靠性分量。\n  - 分辨率分量。\n  - 不确定性分量。\n  - 最大绝对校准差距 $\\max_{k} |p_{k} - o_{k}|$。\n- 你的程序应生成单行输出，其中包含四个测试用例的所有结果，格式为方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数。例如，如果有两个测试用例，格式将是 $[bs_{1},rel_{1},res_{1},unc_{1},gap_{1},bs_{2},rel_{2},res_{2},unc_{2},gap_{2}]$。",
            "solution": "该问题是有效的，因为它在科学上基于预报检验的原理，有充足的数据使其成为一个适定问题，并且其定义和所需计算是客观的。我们将从第一性原理出发推导 Brier 分数的 Murphy 分解，然后将所得算法应用于所提供的测试用例。\n\n设 $p_i$ 为第 $i$ 次预报概率，$y_i \\in \\{0, 1\\}$ 为对应的二元观测值，共有一组 $N$ 个预报-观测对，其中 $i = 1, \\dots, N$。Brier 分数 ($BS$) 定义为预报与观测之间的均方误差：\n$$BS = \\frac{1}{N} \\sum_{i=1}^N (p_i - y_i)^2$$\n\n问题提供的数据被分组为 $K$ 个不同的预报类别。对于每个类别 $k \\in \\{1, \\dots, K\\}$，我们已知预报概率 $p_k$、该类别中的预报数量 $n_k$ 以及观测到的事件数量 $e_k$。预报总数为 $N = \\sum_{k=1}^K n_k$。在每个类别内部，我们可以计算经验事件频率，即条件观测均值 $o_k = e_k/n_k$。总体观测均值，即气候态，为 $\\bar{o} = (\\sum_{k=1}^K e_k) / N = (\\sum_{k=1}^K n_k o_k) / N$。\n\n利用这些分类数据，可以更高效地计算 $BS$。单个类别 $k$ 内的平方误差之和包含 $e_k$ 个 $(p_k - 1)^2$ 项和 $n_k - e_k$ 个 $(p_k - 0)^2$ 项。因此，总 $BS$ 为：\n$$BS = \\frac{1}{N} \\sum_{k=1}^K \\left[ e_k(p_k - 1)^2 + (n_k - e_k)p_k^2 \\right]$$\n\n现在，我们来推导 Murphy 分解。推导过程首先在 Brier 分数定义的平方项内加减条件事件频率 $o_k$。我们可以将对所有 $i$ 的求和表示为对类别 $k$ 和每个类别内项目 $j$ 的双重求和。对于类别 $k$ 中的一个项目，预报为 $p_k$，条件频率为 $o_k$。\n$$BS = \\frac{1}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} (p_k - y_{k,j})^2$$\n其中 $y_{k,j}$ 是类别 $k$ 中的第 $j$ 个观测值。\n$$BS = \\frac{1}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} ( (p_k - o_k) + (o_k - y_{k,j}) )^2$$\n展开平方项：\n$$BS = \\frac{1}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} \\left[ (p_k - o_k)^2 + (o_k - y_{k,j})^2 + 2(p_k - o_k)(o_k - y_{k,j}) \\right]$$\n我们可以将其分为三项。第一项是：\n$$\\frac{1}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} (p_k - o_k)^2 = \\frac{1}{N} \\sum_{k=1}^K n_k (p_k - o_k)^2$$\n这就是**可靠性** (Reliability) 分量 ($REL$)。它衡量了每个类别的预报概率与观测频率之间的加权均方差。对于一个完美校准的预报（即对所有 $k$ 都有 $p_k = o_k$），该值为零。\n\n第三项是交叉项：\n$$ \\frac{2}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} (p_k - o_k)(o_k - y_{k,j}) = \\frac{2}{N} \\sum_{k=1}^K (p_k - o_k) \\sum_{j=1}^{n_k} (o_k - y_{k,j}) $$\n让我们分析内部的和：$\\sum_{j=1}^{n_k} (o_k - y_{k,j}) = n_k o_k - \\sum_{j=1}^{n_k} y_{k,j}$。根据定义，$o_k = (\\sum_{j=1}^{n_k} y_{k,j}) / n_k$，这意味着 $\\sum_{j=1}^{n_k} y_{k,j} = n_k o_k$。因此，内部的和为 $n_k o_k - n_k o_k = 0$。这对每个类别 $k$ 都成立，所以整个交叉项为零。这是一个基于条件均值 $o_k$ 定义的基本结果。\n\nBrier 分数简化为：\n$$BS = \\frac{1}{N} \\sum_{k=1}^K n_k(p_k - o_k)^2 + \\frac{1}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} (o_k - y_{k,j})^2$$\n第二项可以进一步分解。我们加减气候态 $\\bar{o}$：\n$$\\frac{1}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} ( (o_k - \\bar{o}) - (y_{k,j} - \\bar{o}) )^2$$\n展开这个平方项：\n$$ \\frac{1}{N} \\sum_{k=1}^K \\sum_{j=1}^{n_k} \\left[ (o_k - \\bar{o})^2 - 2(o_k - \\bar{o})(y_{k,j} - \\bar{o}) + (y_{k,j} - \\bar{o})^2 \\right] $$\n同样，我们可以分析在一个类别内对 $j$ 求和后的交叉项：\n$$ - \\frac{2}{N} \\sum_{k=1}^K (o_k - \\bar{o}) \\sum_{j=1}^{n_k} (y_{k,j} - \\bar{o}) $$\n内部的和是 $\\sum y_{k,j} - n_k \\bar{o} = n_k o_k - n_k \\bar{o} = n_k(o_k - \\bar{o})$。\n所以对所有类别的求和变为：\n$$ - \\frac{2}{N} \\sum_{k=1}^K n_k(o_k - \\bar{o})^2 $$\n这使得我们得到：\n$$BS = \\underbrace{\\frac{1}{N} \\sum_{k=1}^K n_k(p_k-o_k)^2}_{REL} + \\underbrace{\\frac{1}{N}\\sum_{k=1}^K n_k(o_k-\\bar{o})^2}_{RES} - \\underbrace{2\\frac{1}{N}\\sum_{k=1}^K n_k(o_k-\\bar{o})^2}_{-2 \\times RES} + \\underbrace{\\frac{1}{N}\\sum_{i=1}^N (y_i-\\bar{o})^2}_{\\text{Variance of obs}} $$\n不，这条路径不正确。让我们用一个更优雅的方法重新开始分解第二项。\n设第二项为 $T_2 = \\frac{1}{N} \\sum_{i=1}^N (o(p_i) - y_i)^2$，其中 $o(p_i)$ 是对应于预报 $p_i$ 的条件频率 $o_k$。\n$$T_2 = \\frac{1}{N} \\sum_{i=1}^N (o(p_i)^2 - 2o(p_i)y_i + y_i^2)$$\n利用均值的线性性质（对 $N$ 求和）：\n$$T_2 = \\frac{1}{N}\\sum_i o(p_i)^2 - \\frac{2}{N}\\sum_i o(p_i)y_i + \\frac{1}{N}\\sum_i y_i^2$$\n和 $\\sum_i o(p_i)y_i = \\sum_k \\sum_{j \\in k} o_k y_{k,j} = \\sum_k o_k \\sum_{j \\in k} y_{k,j} = \\sum_k o_k (n_k o_k) = \\sum_k n_k o_k^2$。\n所以, $\\frac{1}{N}\\sum_i o(p_i)y_i = \\frac{1}{N}\\sum_k n_k o_k^2$。\n同样地, $\\frac{1}{N}\\sum_i o(p_i)^2 = \\frac{1}{N}\\sum_k n_k o_k^2$。\n并且 $\\frac{1}{N}\\sum_i y_i^2 = \\frac{1}{N}\\sum_i y_i = \\bar{o}$ 因为 $y_i^2=y_i$。\n$$T_2 = \\frac{1}{N}\\sum_k n_k o_k^2 - 2\\frac{1}{N}\\sum_k n_k o_k^2 + \\bar{o} = \\bar{o} - \\frac{1}{N}\\sum_k n_k o_k^2$$\n我们可以写成 $\\bar{o} = \\bar{o}^2 + \\bar{o}(1-\\bar{o})$。\n$$T_2 = \\bar{o}(1-\\bar{o}) - \\left( \\frac{1}{N}\\sum_k n_k o_k^2 - \\bar{o}^2 \\right)$$\n项 $\\frac{1}{N}\\sum_k n_k o_k^2 - \\bar{o}^2 = \\frac{1}{N}\\sum_k n_k o_k^2 - 2\\bar{o}^2 + \\bar{o}^2 = \\frac{1}{N}\\sum_k n_k o_k^2 - 2\\bar{o}\\frac{\\sum n_k o_k}{N} + \\bar{o}^2\\frac{\\sum n_k}{N} = \\frac{1}{N}\\sum_k n_k(o_k^2 - 2\\bar{o}o_k + \\bar{o}^2) = \\frac{1}{N}\\sum_k n_k (o_k-\\bar{o})^2$。这是分辨率(Resolution)。\n\n所以我们有：\n$T_2 = \\bar{o}(1-\\bar{o}) - \\frac{1}{N}\\sum_k n_k (o_k-\\bar{o})^2$。\n\n将所有部分组合起来，我们得到 Murphy 分解：\n$$BS = REL - RES + UNC$$\n其中：\n1.  **可靠性 ($REL$)**: $REL = \\frac{1}{N} \\sum_{k=1}^K n_k (p_k - o_k)^2$。这是校准误差，它惩罚预报概率与实际事件频率之间的偏差。值越低越好。\n2.  **分辨率 ($RES$)**: $RES = \\frac{1}{N} \\sum_{k=1}^K n_k (o_k - \\bar{o})^2$。它衡量预报系统区分出事件频率不同于气候态的子集的能力。值越高越好。\n3.  **不确定性 ($UNC$)**: $UNC = \\bar{o}(1 - \\bar{o})$。这是数据集中二元结果的内在方差，代表了预报问题的难度。它不依赖于预报系统本身。\n\n最后，失准度摘要是所有预报类别中的最大绝对校准差距：\n$$Gap = \\max_{k} |p_k - o_k|$$\n\n以下算法将被实现，用于计算每个测试用例的这些量。\n对于每个具有类别 $\\{p_k, n_k, e_k\\}_{k=1}^K$ 的测试用例：\n1. 计算总数 $N = \\sum n_k$，$E = \\sum e_k$。\n2. 计算气候态 $\\bar{o} = E/N$ 和各类别频率 $o_k = e_k/n_k$。\n3. 计算 Brier 分数 $BS = \\frac{1}{N} \\sum_{k=1}^K [e_k(p_k - 1)^2 + (n_k - e_k)p_k^2]$。\n4. 计算可靠性分量 $REL = \\frac{1}{N} \\sum_{k=1}^K n_k(p_k - o_k)^2$。\n5. 计算分辨率分量 $RES = \\frac{1}{N} \\sum_{k=1}^K n_k(o_k - \\bar{o})^2$。\n6. 计算不确定性分量 $UNC = \\bar{o}(1 - \\bar{o})$。\n7. 计算最大校准差距 $Gap = \\max_k |p_k - o_k|$。\n每个测试用例都将计算这五个值 ($BS, REL, RES, UNC, Gap$)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Brier Score and its Murphy decomposition for several\n    test cases of probabilistic forecasts.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (well-calibrated, high resolution)\n        {'p': [0.1, 0.5, 0.9], 'n': [20, 20, 20], 'e': [2, 10, 18]},\n        # Test Case 2 (overconfident, miscalibrated)\n        {'p': [0.1, 0.5, 0.9], 'n': [20, 20, 20], 'e': [6, 8, 12]},\n        # Test Case 3 (uninformative, perfectly reliable at climatology)\n        {'p': [0.3], 'n': [50], 'e': [15]},\n        # Test Case 4 (boundary forecasts, miscalibrated)\n        {'p': [0.0, 1.0], 'n': [30, 30], 'e': [6, 24]},\n    ]\n\n    results = []\n    for case in test_cases:\n        p_k = np.array(case['p'], dtype=float)\n        n_k = np.array(case['n'], dtype=float)\n        e_k = np.array(case['e'], dtype=float)\n\n        # Total number of forecasts and events\n        N = np.sum(n_k)\n        E = np.sum(e_k)\n\n        # Climatology (overall base rate)\n        o_bar = E / N\n\n        # Empirical event frequency for each category\n        # Handle division by zero for categories with n_k=0, though not present in tests.\n        o_k = np.divide(e_k, n_k, out=np.zeros_like(e_k), where=n_k!=0)\n\n        # 1. Compute Brier Score (BS)\n        # BS = (1/N) * sum_k [ e_k*(p_k - 1)^2 + (n_k-e_k)*p_k^2 ]\n        sum_sq_err = np.sum(e_k * (p_k - 1)**2 + (n_k - e_k) * p_k**2)\n        brier_score = sum_sq_err / N\n\n        # 2. Compute Murphy decomposition components\n        # Reliability (REL) = (1/N) * sum_k [ n_k*(p_k - o_k)^2 ]\n        reliability = np.sum(n_k * (p_k - o_k)**2) / N\n\n        # Resolution (RES) = (1/N) * sum_k [ n_k*(o_k - o_bar)^2 ]\n        resolution = np.sum(n_k * (o_k - o_bar)**2) / N\n\n        # Uncertainty (UNC) = o_bar * (1 - o_bar)\n        uncertainty = o_bar * (1 - o_bar)\n\n        # Sanity check: BS should equal REL - RES + UNC\n        # assert np.isclose(brier_score, reliability - resolution + uncertainty)\n        \n        # 3. Compute maximum absolute calibration gap\n        max_cal_gap = np.max(np.abs(p_k - o_k))\n\n        # Append the five required floats to the results list\n        results.extend([brier_score, reliability, resolution, uncertainty, max_cal_gap])\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}