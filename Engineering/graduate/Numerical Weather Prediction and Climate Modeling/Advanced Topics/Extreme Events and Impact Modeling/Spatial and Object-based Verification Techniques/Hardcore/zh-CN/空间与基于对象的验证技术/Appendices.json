{
    "hands_on_practices": [
        {
            "introduction": "结构-振幅-位置（SAL）方法是一种强大的诊断工具，它将预报误差分解为三个直观的分量，从而能够对预报系统性偏差的来源进行更深入的分析。本练习  旨在通过一个理想化的情景——两个高斯形状的降水场——来阐明SAL的计算机制。通过亲手计算这三个分量，您将清晰地理解每个分量（$S$、$A$、$L$）分别衡量了预报在对象大小、总体降水量和空间位置方面的何种误差。",
            "id": "4090731",
            "problem": "考虑定义在半径为 $R$ 的圆形域 $\\Omega = \\{\\mathbf{x} \\in \\mathbb{R}^{2}:\\ \\|\\mathbf{x}\\| \\leq R\\}$ 上的连续二维降水强度场，其中预报场由 $F(\\mathbf{x}) = H_{f} \\exp\\!\\big(-\\|\\mathbf{x} - \\mathbf{x}_{f}\\|^{2}/(2\\sigma_{f}^{2})\\big)$ 给出，观测场由 $O(\\mathbf{x}) = H_{o} \\exp\\!\\big(-\\|\\mathbf{x} - \\mathbf{x}_{o}\\|^{2}/(2\\sigma_{o}^{2})\\big)$ 给出。中心位于同一位置，即原点，$\\mathbf{x}_{f} = \\mathbf{x}_{o} = \\mathbf{0}$。假设各向同性，且域半径 $R$ 相对于 $\\sigma_{f}$ 和 $\\sigma_{o}$ 足够大，因此在 $r=R$ 处对高斯尾部的截断对四位有效数字的影响可以忽略不计。\n\n使用结构-振幅-位置 (Structure–Amplitude–Location, SAL) 检验三元组，计算在以下参数选择下的分量 $S$、$A$ 和 $L$\n- $H_{o} = 20$ 单位 $\\mathrm{mm\\,h^{-1}}$，$\\sigma_{o} = 15$ 单位 $\\mathrm{km}$，\n- $H_{f} = 12$ 单位 $\\mathrm{mm\\,h^{-1}}$，$\\sigma_{f} = 30$ 单位 $\\mathrm{km}$，\n- $R = 200$ 单位 $\\mathrm{km}$。\n\n使用以下定义：\n- 振幅分量：域平均值 $\\overline{F} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}$ 和 $\\overline{O} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} O(\\mathbf{x})\\, d\\mathbf{x}$，以及\n$$A = \\frac{2\\big(\\overline{F} - \\overline{O}\\big)}{\\overline{F} + \\overline{O}}.$$\n- 位置分量：$L = L_{1} + L_{2}$，其中 $L_{1} = \\frac{\\|\\mathbf{x}_{f} - \\mathbf{x}_{o}\\|}{2R}$ 以及基于离散度的项\n$$r(F) = \\frac{\\int_{\\Omega} \\|\\mathbf{x} - \\mathbf{x}_{f}\\|\\, F(\\mathbf{x})\\, d\\mathbf{x}}{\\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}}, \\quad r(O) = \\frac{\\int_{\\Omega} \\|\\mathbf{x} - \\mathbf{x}_{o}\\|\\, O(\\mathbf{x})\\, d\\mathbf{x}}{\\int_{\\Omega} O(\\mathbf{x})\\, d\\mathbf{x}}, \\quad L_{2} = \\frac{|r(F) - r(O)|}{2R}.$$\n- 结构分量：将每个场的半峰高强度核心定义为，\n$$C(F) = \\left\\{\\mathbf{x} \\in \\Omega:\\ F(\\mathbf{x}) \\geq \\frac{H_{f}}{2}\\right\\}, \\quad C(O) = \\left\\{\\mathbf{x} \\in \\Omega:\\ O(\\mathbf{x}) \\geq \\frac{H_{o}}{2}\\right\\},$$\n以及归一化的核心面积分数\n$$s(F) = \\frac{\\mathrm{area}\\big(C(F)\\big)}{\\pi R^{2}}, \\quad s(O) = \\frac{\\mathrm{area}\\big(C(O)\\big)}{\\pi R^{2}}, \\quad S = \\frac{2\\big(s(F) - s(O)\\big)}{s(F) + s(O)}.$$\n\n在上述大域近似下计算 $S$、$A$ 和 $L$，并以无量纲数的形式提供最终的 SAL 三元组。将每个分量四舍五入至四位有效数字。使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境将最终答案表示为单行向量。",
            "solution": "用户提供的问题通过了所有验证标准。它在气象预报检验领域有科学依据，数学上适定、客观，并包含获得唯一解所需的所有信息。因此，我将对结构-振幅-位置 (SAL) 各分量进行完整推导。\n\n该问题要求计算二维高斯降水场的 SAL 三元组 $(S, A, L)$。预报场为 $F(\\mathbf{x}) = H_{f} \\exp(-\\|\\mathbf{x} - \\mathbf{x}_{f}\\|^{2}/(2\\sigma_{f}^{2}))$，观测场为 $O(\\mathbf{x}) = H_{o} \\exp(-\\|\\mathbf{x} - \\mathbf{x}_{o}\\|^{2}/(2\\sigma_{o}^{2}))$。中心位于同一位置，即原点，因此 $\\mathbf{x}_{f} = \\mathbf{x}_{o} = \\mathbf{0}$。场定义在半径为 $R$ 的圆形域 $\\Omega$ 上。大域近似表明，$\\Omega$ 外部场的贡献可以忽略不计，这使我们可以用在整个平面 $\\mathbb{R}^{2}$ 上的积分来近似在 $\\Omega$ 上的积分。\n\n给定参数如下：\n$H_{o} = 20$，$\\sigma_{o} = 15$\n$H_{f} = 12$，$\\sigma_{f} = 30$\n$R = 200$\n所有单位都是一致的（强度单位为 mm/h，长度单位为 km）。\n\n我们将依次计算 SAL 三元组的每个分量。\n\n### 1. 振幅分量 ($A$)\n\n振幅分量 $A$ 定义为\n$$A = \\frac{2\\big(\\overline{F} - \\overline{O}\\big)}{\\overline{F} + \\overline{O}}$$\n其中 $\\overline{F}$ 和 $\\overline{O}$ 是域平均降水强度。\n$\\overline{F} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}$ 且 $\\overline{O} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} O(\\mathbf{x})\\, d\\mathbf{x}$。\n\n我们首先计算总降水量，即强度场在整个域上的积分。对于预报场，当 $\\mathbf{x}_{f} = \\mathbf{0}$ 时：\n$$V_{f} = \\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x} = \\int_{\\Omega} H_{f} \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right)\\, d\\mathbf{x}$$\n使用大域近似，我们可以将积分扩展到整个平面 $\\mathbb{R}^{2}$。我们转换到极坐标 $(r, \\theta)$，其中 $\\|\\mathbf{x}\\| = r$ 且 $d\\mathbf{x} = r\\,dr\\,d\\theta$。\n$$V_{f} \\approx \\int_{0}^{2\\pi} \\int_{0}^{\\infty} H_{f} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) r\\,dr\\,d\\theta$$\n该积分可分为角度和径向两部分：\n$$V_{f} = 2\\pi H_{f} \\int_{0}^{\\infty} r \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) dr$$\n令 $u = r^{2}/(2\\sigma_{f}^{2})$，则 $du = r/\\sigma_{f}^{2} \\,dr$，得到 $r\\,dr = \\sigma_{f}^{2}\\,du$。\n$$V_{f} = 2\\pi H_{f} \\int_{0}^{\\infty} \\exp(-u) \\sigma_{f}^{2}\\,du = 2\\pi H_{f} \\sigma_{f}^{2} [-\\exp(-u)]_{0}^{\\infty} = 2\\pi H_{f} \\sigma_{f}^{2}$$\n通过完全类似的推导，总观测体积为 $V_{o} = 2\\pi H_{o} \\sigma_{o}^{2}$。\n\n现在我们可以计算域平均强度：\n$$\\overline{F} = \\frac{V_{f}}{\\pi R^{2}} = \\frac{2\\pi H_{f} \\sigma_{f}^{2}}{\\pi R^{2}} = \\frac{2 H_{f} \\sigma_{f}^{2}}{R^{2}}$$\n$$\\overline{O} = \\frac{V_{o}}{\\pi R^{2}} = \\frac{2\\pi H_{o} \\sigma_{o}^{2}}{\\pi R^{2}} = \\frac{2 H_{o} \\sigma_{o}^{2}}{R^{2}}$$\n代入给定值：\n$\\overline{F} = \\frac{2(12)(30)^{2}}{200^{2}} = \\frac{24 \\cdot 900}{40000} = \\frac{21600}{40000} = 0.54$。\n$\\overline{O} = \\frac{2(20)(15)^{2}}{200^{2}} = \\frac{40 \\cdot 225}{40000} = \\frac{9000}{40000} = 0.225$。\n\n最后，我们计算 $A$：\n$$A = \\frac{2(0.54 - 0.225)}{0.54 + 0.225} = \\frac{2(0.315)}{0.765} = \\frac{0.63}{0.765} \\approx 0.823529...$$\n四舍五入到四位有效数字，$A = 0.8235$。\n\n### 2. 位置分量 ($L$)\n\n位置分量为 $L = L_{1} + L_{2}$。\n项 $L_{1}$ 与质心的位移有关：\n$$L_{1} = \\frac{\\|\\mathbf{x}_{f} - \\mathbf{x}_{o}\\|}{2R}$$\n由于给定中心位于同一位置，$\\mathbf{x}_{f} = \\mathbf{x}_{o} = \\mathbf{0}$，我们有 $L_{1} = 0$。\n\n项 $L_{2}$ 与降水到各自中心的平均距离之差有关：\n$$L_{2} = \\frac{|r(F) - r(O)|}{2R}$$\n其中 $r(F) = \\frac{\\int_{\\Omega} \\|\\mathbf{x} - \\mathbf{x}_{f}\\|\\, F(\\mathbf{x})\\, d\\mathbf{x}}{\\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}}$。\n当 $\\mathbf{x}_{f} = \\mathbf{0}$ 时，分母为 $V_{f} = 2\\pi H_{f} \\sigma_{f}^{2}$。分子为：\n$$N_{f} = \\int_{\\Omega} \\|\\mathbf{x}\\| F(\\mathbf{x})\\, d\\mathbf{x} = \\int_{\\Omega} \\|\\mathbf{x}\\| H_{f} \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right)\\, d\\mathbf{x}$$\n再次使用极坐标和大域近似：\n$$N_{f} \\approx \\int_{0}^{2\\pi} \\int_{0}^{\\infty} r H_{f} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) r\\,dr\\,d\\theta = 2\\pi H_{f} \\int_{0}^{\\infty} r^{2} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) dr$$\n这是一个标准的高斯积分，形式为 $\\int_{0}^{\\infty} x^{2} \\exp(-ax^{2})dx = \\frac{\\sqrt{\\pi}}{4a^{3/2}}$。此处，$a=1/(2\\sigma_{f}^{2})$。\n$$\\int_{0}^{\\infty} r^{2} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) dr = \\frac{\\sqrt{\\pi}}{4(1/(2\\sigma_{f}^{2}))^{3/2}} = \\frac{\\sqrt{\\pi}}{4/(2\\sigma_{f}^{2}\\sqrt{2\\sigma_{f}^{2}})} = \\frac{\\sqrt{\\pi} \\cdot 2\\sqrt{2} \\sigma_{f}^{3}}{4} = \\frac{\\sqrt{2\\pi}}{2}\\sigma_{f}^{3}$$\n所以，分子为 $N_{f} = 2\\pi H_{f} \\left(\\frac{\\sqrt{2\\pi}}{2}\\sigma_{f}^{3}\\right) = \\pi\\sqrt{2\\pi}H_{f}\\sigma_{f}^{3}$。\n那么，$r(F)$ 是分子与分母的比值：\n$$r(F) = \\frac{N_{f}}{V_{f}} = \\frac{\\pi\\sqrt{2\\pi}H_{f}\\sigma_{f}^{3}}{2\\pi H_{f}\\sigma_{f}^{2}} = \\frac{\\sqrt{2\\pi}}{2}\\sigma_{f}$$\n类似地，对于观测场，$r(O) = \\frac{\\sqrt{2\\pi}}{2}\\sigma_{o}$。\n\n现在我们代入数值：\n$r(F) = \\frac{\\sqrt{2\\pi}}{2}(30) = 15\\sqrt{2\\pi}$ km。\n$r(O) = \\frac{\\sqrt{2\\pi}}{2}(15) = 7.5\\sqrt{2\\pi}$ km。\n\n$L_{2} = \\frac{|15\\sqrt{2\\pi} - 7.5\\sqrt{2\\pi}|}{2(200)} = \\frac{7.5\\sqrt{2\\pi}}{400}$。\n$L_{2} \\approx \\frac{7.5(2.506628)}{400} \\approx \\frac{18.79971}{400} \\approx 0.046999...$\n因此，$L = L_{1} + L_{2} = 0 + L_{2} \\approx 0.046999...$。\n四舍五入到四位有效数字，$L = 0.04700$。\n\n### 3. 结构分量 ($S$)\n\n结构分量 $S$ 定义为\n$$S = \\frac{2\\big(s(F) - s(O)\\big)}{s(F) + s(O)}$$\n其中 $s(F)$ 和 $s(O)$ 是归一化的核心面积分数。核心 $C(F)$ 定义为强度至少为其最大值一半的区域：\n$C(F) = \\{\\mathbf{x} \\in \\Omega:\\ F(\\mathbf{x}) \\geq H_{f}/2\\}$。\n$$H_{f} \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right) \\geq \\frac{H_{f}}{2} \\implies \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right) \\geq \\frac{1}{2}$$\n对两边取自然对数：\n$$\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}} \\geq \\ln\\left(\\frac{1}{2}\\right) = -\\ln(2)$$\n$$\\|\\mathbf{x}\\|^{2} \\leq 2\\sigma_{f}^{2}\\ln(2) \\implies \\|\\mathbf{x}\\| \\leq \\sigma_{f}\\sqrt{2\\ln(2)}$$\n这描述了一个以原点为中心的圆盘。该核心的半径是 $R_{f} = \\sigma_{f}\\sqrt{2\\ln(2)}$。核心的面积是 $\\mathrm{area}(C(F)) = \\pi R_{f}^{2} = 2\\pi\\sigma_{f}^{2}\\ln(2)$。\n归一化的核心面积分数为：\n$$s(F) = \\frac{\\mathrm{area}(C(F))}{\\pi R^{2}} = \\frac{2\\pi\\sigma_{f}^{2}\\ln(2)}{\\pi R^{2}} = \\frac{2\\sigma_{f}^{2}\\ln(2)}{R^{2}}$$\n类似地，$s(O) = \\frac{2\\sigma_{o}^{2}\\ln(2)}{R^{2}}$。\n\n现在我们计算 $S$：\n$$S = \\frac{2\\left(\\frac{2\\sigma_{f}^{2}\\ln(2)}{R^{2}} - \\frac{2\\sigma_{o}^{2}\\ln(2)}{R^{2}}\\right)}{\\frac{2\\sigma_{f}^{2}\\ln(2)}{R^{2}} + \\frac{2\\sigma_{o}^{2}\\ln(2)}{R^{2}}}$$\n公因子 $2\\ln(2)/R^{2}$ 从分子和分母中约去：\n$$S = \\frac{2(\\sigma_{f}^{2} - \\sigma_{o}^{2})}{\\sigma_{f}^{2} + \\sigma_{o}^{2}}$$\n代入给定的 $\\sigma_{f}$ 和 $\\sigma_{o}$ 值：\n$\\sigma_{f}^{2} = 30^{2} = 900$。\n$\\sigma_{o}^{2} = 15^{2} = 225$。\n$$S = \\frac{2(900 - 225)}{900 + 225} = \\frac{2(675)}{1125} = \\frac{1350}{1125} = 1.2$$\n保留四位有效数字，$S = 1.200$。\n\n### 总结\n\n计算出的 SAL 三元组分量为：\n- 结构 $S = 1.200$\n- 振幅 $A = 0.8235$\n- 位置 $L = 0.04700$\n\n最终的 SAL 三元组，按 $(S, A, L)$ 顺序排列，为 $(1.200, 0.8235, 0.04700)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1.200  0.8235  0.04700 \\end{pmatrix}}$$"
        },
        {
            "introduction": "从理想化的连续场转向实际的格点数据后，邻域法成为评估空间预报技巧的关键。分数技巧评分（FSS）是一种广受欢迎的邻域检验方法，它能够评估预报在不同空间尺度上的表现。本练习  要求您通过编程实现FSS，并探讨一个在预报检验中至关重要的问题：即使我们关注的物理尺度保持不变，模式的网格分辨率如何影响最终的检验分数。这个实践将加深您对尺度依赖性及其在解释检验结果时重要性的理解。",
            "id": "4090719",
            "problem": "您的任务是在数值天气预报和气候模拟的背景下，使用空间和基于对象的检验技术，实现分数技巧评分 (FSS) 对网格间距变化的数值敏感性分析。分数技巧评分 (FSS) 必须根据第一性原理，使用在固定物理尺度上计算的邻域分数来定义，并且该分析必须在保持物理尺度不变的情况下，隔离网格间距对平滑算子的影响。\n\n从以下基本基础开始：\n- 将预报和观测事件的发生表示为二维域上的二元指示场，事件区域内的值等于 $1$，区域外的值等于 $0$。\n- 通过将指示场与一个半径对应于固定物理长度尺度的离散圆形高帽核进行卷积，来计算邻域分数。一个网格单元的邻域分数定义为：核内属于该事件的网格单元数占核内总单元数的比例。\n- 对所有网格间距使用固定的物理邻域半径，确保以网格单元计量的核大小随网格间距的变化而相应调整。\n- 将预报和观测分数场之间的分数技巧评分 (FSS) 构建为一个无量纲技巧度量：完美匹配时等于 $1$，上限为 $1$，并随着分数场之间平方差的增加而单调递减，该平方差通过分数场的自平方和进行归一化。以科学合理的方式处理任何分母为零的极端情况。\n\n科学设置：\n- 考虑一个大小为 $L_x = 100$ km × $L_y = 100$ km 的方形物理域。\n- 观测事件是一个半径为 $R_o = 12$ km、中心位于 $(x_o,y_o)$ 的实心圆盘。\n- 预报事件是一个半径为 $R_f = 12$ km、中心位于 $(x_f,y_f)$ 的实心圆盘。\n- 固定的物理邻域（平滑）半径为 $R_s = 10$ km。\n\n离散化规则：\n- 对于选定的网格间距 $d_x$（单位为公里），将域离散化为一个均匀网格，其单元中心平铺 $[0, L_x) \\times [0, L_y)$。\n- 对于中心为 $(x_c,y_c)$、半径为 $R$ 的圆盘，其指示场在与中心 $(x_c,y_c)$ 的欧几里得距离小于或等于 $R$ 的网格单元处的值为 $1$，否则为 $0$。\n- 离散圆形高帽核的半径为 $r_{\\text{cells}} = \\max(1,\\mathrm{round}(R_s/d_x))$ 个网格单元。在以网格单元计量的欧几里得距离小于或等于 $r_{\\text{cells}}$ 的偏移量处，核权重等于 $1$，否则等于 $0$。使用零边界填充，并通过不变的核总和来归一化邻域分数。\n- 计算域中所有网格单元上预报和观测分数场之间的分数技巧评分 (FSS)。\n\n单位：\n- 距离、网格间距和半径必须以公里为单位处理。最终答案必须是无量纲的，并表示为精确到六位小数的浮点数。\n\n测试套件：\n计算以下四个测试用例的 FSS，每个用例由 $(d_x,(x_o,y_o),(x_f,y_f))$ 指定，其中 $L_x = L_y = 100$ km，$R_o = R_f = 12$ km，以及固定的 $R_s = 10$ km：\n1. $d_x = 1$ km, $(x_o,y_o) = (50,50)$ km, $(x_f,y_f) = (55,50)$ km。\n2. $d_x = 2$ km, $(x_o,y_o) = (50,50)$ km, $(x_f,y_f) = (55,50)$ km。\n3. $d_x = 5$ km, $(x_o,y_o) = (50,50)$ km, $(x_f,y_f) = (55,50)$ km。\n4. $d_x = 2$ km, $(x_o,y_o) = (12,50)$ km, $(x_f,y_f) = (18,50)$ km。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含上述四个测试用例的 FSS 值，四舍五入到六位小数，以逗号分隔的列表形式包含在方括号内，例如，“[$f_1,f_2,f_3,f_4$]”。",
            "solution": "该问题要求实现分数技巧评分 (FSS) 对网格间距变化的数值敏感性分析。该分析将在一个合成数据集上进行，该数据集将预报和观测事件表示为二维域上的圆形区域。解决方案必须根据概述的第一性原理来构建。\n\n该方法论途径包括几个不同的步骤：首先，将连续物理域和事件特征离散化到网格上；其次，通过平滑操作将二元事件场转换为连续分数场；第三，从这些分数场计算 FSS。\n\n**1. 域和场的离散化**\n\n物理域是一个大小为 $L_x \\times L_y$ 的正方形，其中 $L_x = L_y = 100$ km。该域被离散化为一个 $N_x \\times N_y$ 个单元的均匀网格，其中每个维度上的单元数由网格间距 $d_x$ 决定。具体来说，$N_x = \\text{int}(L_x / d_x)$ 且 $N_y = \\text{int}(L_y / d_x)$。单元中心 $(x_i, y_j)$ 被定义为平铺区间 $[0, L_x) \\times [0, L_y)$，我们通过设置其坐标来实现：\n$$ x_i = i \\cdot d_x + \\frac{d_x}{2}, \\quad \\text{for } i \\in \\{0, 1, \\dots, N_x-1\\} $$\n$$ y_j = j \\cdot d_x + \\frac{d_x}{2}, \\quad \\text{for } j \\in \\{0, 1, \\dots, N_y-1\\} $$\n\n观测和预报事件是半径分别为 $R_o = 12$ km 和 $R_f = 12$ km 的实心圆盘，中心分别位于 $(x_o, y_o)$ 和 $(x_f, y_f)$。这些连续形状被栅格化到网格上以创建二元指示场 $I_o$ 和 $I_f$。如果网格单元 $(x_i, y_j)$ 的中心位于圆盘内部或其边界上，则其值被赋为 $1$，否则为 $0$。这由以下条件表示：\n$$ I(i,j) = \\begin{cases} 1  \\text{if } \\sqrt{(x_i-x_c)^2 + (y_j-y_c)^2} \\le R \\\\ 0  \\text{otherwise} \\end{cases} $$\n其中 $(x_c, y_c)$ 和 $R$ 分别是对应圆盘的中心和半径。\n\n**2. 邻域平滑和分数场**\n\n代表事件存在与否的二元指示场被转换为邻域分数的连续场。这是通过将每个指示场与一个平滑核进行卷积来实现的。问题指定了一个具有固定物理半径 $R_s = 10$ km 的圆形高帽核。此敏感性分析的关键方面在于，随着网格间距 $d_x$ 的变化，这个以网格单元计量的核的大小必须进行调整，以保持固定的物理尺度。以网格单元计量的核半径 $r_{\\text{cells}}$ 对每个 $d_x$ 计算如下：\n$$ r_{\\text{cells}} = \\max(1, \\text{round}(R_s / d_x)) $$\n核 $K$ 是一个二维矩阵，如果元素与核中心的欧几里得距离在 $r_{\\text{cells}}$ 之内，则其值为 $1$，否则为 $0$。\n\n邻域分数场 $F_o$ 和 $F_f$ 是通过将指示场与核 $K$ 进行二维卷积（$*$），并除以核权重的总和来计算的。对于任何给定的单元 $(i,j)$，此操作有效地计算了包含该事件的邻域（由核的形状和大小定义）的比例。卷积在边界处使用零填充。\n$$ F(i,j) = \\frac{(I * K)(i,j)}{\\sum_{k,l} K(k,l)} = \\frac{\\sum_{k,l} I(i-k, j-l) K(k,l)}{\\sum_{k,l} K(k,l)} $$\n分母 $\\sum_{k,l} K(k,l)$ 是离散圆形核内的网格单元总数。\n\n**3. 分数技巧评分 (FSS) 计算**\n\nFSS 是一种量化预报分数场 $F_f$ 相对于观测分数场 $F_o$ 的技巧的度量。它基于两个场之间的均方误差 (MSE) 进行定义，并由一个参考 MSE 进行归一化。MSE 为：\n$$ \\text{MSE} = \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} (F_f(i,j) - F_o(i,j))^2 $$\n参考 MSE，$MSE_{ref}$，是预报场和观测场分别与零场（代表无重叠的最坏情况）的 MSE 之和。其定义为：\n$$ \\text{MSE}_{\\text{ref}} = \\frac{1}{N_x N_y} \\left( \\sum_{i,j} F_f(i,j)^2 + \\sum_{i,j} F_o(i,j)^2 \\right) $$\nFSS 则由下式给出：\n$$ \\text{FSS} = 1 - \\frac{\\text{MSE}}{\\text{MSE}_{\\text{ref}}} $$\n代入定义并通过消去 $1/(N_x N_y)$ 项进行简化，公式变为：\n$$ \\text{FSS} = 1 - \\frac{\\sum_{i,j} (F_f(i,j) - F_o(i,j))^2}{\\sum_{i,j} F_f(i,j)^2 + \\sum_{i,j} F_o(i,j)^2} $$\n这种形式确保了对于完美预报（$F_f = F_o$），FSS 为 $1$，并随着场之间差异的增加而减小。如果分母为零，则会出现一种特殊情况。这种情况仅在 $F_f$ 和 $F_o$ 都处处为零时发生，意味着没有观测到或预报任何事件。在这种情况下，分子也为零。这构成了一次对无事件的完美预报，因此 FSS 被正确地定义为 $1$。\n\n通过对问题陈述中提供的每个测试用例依次应用这些步骤来实现该算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef calculate_fss(d_x, center_o, center_f, L_x, L_y, R_o, R_f, R_s):\n    \"\"\"\n    Computes the Fractions Skill Score (FSS) for a given set of parameters.\n\n    Args:\n        d_x (float): Grid spacing in km.\n        center_o (tuple): Center coordinates (x, y) of the observation disk in km.\n        center_f (tuple): Center coordinates (x, y) of the forecast disk in km.\n        L_x (float): Domain width in km.\n        L_y (float): Domain height in km.\n        R_o (float): Radius of the observation disk in km.\n        R_f (float): Radius of the forecast disk in km.\n        R_s (float): Physical radius of the smoothing kernel in km.\n\n    Returns:\n        float: The calculated Fractions Skill Score.\n    \"\"\"\n    # 1. Grid setup\n    # Determine the number of grid points\n    N_x = int(L_x / d_x)\n    N_y = int(L_y / d_x)\n    \n    # Create grid cell center coordinates\n    x_coords = np.arange(N_x) * d_x + d_x / 2.0\n    y_coords = np.arange(N_y) * d_x + d_x / 2.0\n    xx, yy = np.meshgrid(x_coords, y_coords)\n\n    # 2. Generate Binary Indicator Fields\n    # Observation field\n    x_o, y_o = center_o\n    dist_sq_o = (xx - x_o)**2 + (yy - y_o)**2\n    indicator_o = (dist_sq_o = R_o**2).astype(float)\n\n    # Forecast field\n    x_f, y_f = center_f\n    dist_sq_f = (xx - x_f)**2 + (yy - y_f)**2\n    indicator_f = (dist_sq_f = R_f**2).astype(float)\n\n    # 3. Define and Apply Smoothing Kernel\n    # Calculate kernel radius in grid cells from fixed physical radius\n    r_cells = int(max(1, np.round(R_s / d_x)))\n    \n    # Create the circular top-hat kernel\n    ky, kx = np.mgrid[-r_cells:r_cells+1, -r_cells:r_cells+1]\n    kernel_mask = (kx**2 + ky**2 = r_cells**2).astype(float)\n    kernel_sum = np.sum(kernel_mask)\n\n    # 4. Compute Neighborhood Fraction Fields\n    # Use 2D convolution to apply the smoothing kernel\n    if kernel_sum == 0:\n        # This case is unlikely with r_cells >= 1 but is included for robustness\n        fraction_field_o = np.zeros_like(indicator_o)\n        fraction_field_f = np.zeros_like(indicator_f)\n    else:\n        # Pad with zeros at the boundary as specified\n        fraction_field_o = convolve2d(indicator_o, kernel_mask, mode='same', boundary='fill', fillvalue=0) / kernel_sum\n        fraction_field_f = convolve2d(indicator_f, kernel_mask, mode='same', boundary='fill', fillvalue=0) / kernel_sum\n\n    # 5. Compute the Fractions Skill Score (FSS)\n    # Sum of squared differences between the fraction fields\n    numerator = np.sum((fraction_field_o - fraction_field_f)**2)\n    # Sum of self-squared fraction fields for reference\n    denominator = np.sum(fraction_field_o**2) + np.sum(fraction_field_f**2)\n\n    if denominator == 0:\n        # If both fields are zero, it's a perfect forecast of a non-event. FSS is 1.\n        return 1.0\n    \n    fss = 1.0 - numerator / denominator\n    return fss\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (d_x, (x_o, y_o), (x_f, y_f))\n    test_cases = [\n        (1.0, (50.0, 50.0), (55.0, 50.0)),\n        (2.0, (50.0, 50.0), (55.0, 50.0)),\n        (5.0, (50.0, 50.0), (55.0, 50.0)),\n        (2.0, (12.0, 50.0), (18.0, 50.0)),\n    ]\n\n    # Fixed scientific parameters\n    L_x = 100.0  # km\n    L_y = 100.0  # km\n    R_o = 12.0   # km\n    R_f = 12.0   # km\n    R_s = 10.0   # km\n\n    results = []\n    for case in test_cases:\n        d_x, center_o, center_f = case\n        fss = calculate_fss(d_x, center_o, center_f, L_x, L_y, R_o, R_f, R_s)\n        results.append(fss)\n\n    # Final print statement in the exact required format.\n    # Results are rounded to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习  是一个综合性的顶点实践，它将引导您完成一个完整的基于对象的检验（OBV）工作流程。OBV方法通过将预报场和观测场中的连续信息转化为离散的“对象”来进行比较，从而提供了一种与天气系统特征更直接相关的评估。您将从原始的格点数据出发，识别出预报和观测对象，计算它们各自的关键属性（如面积、形状和强度），并最终基于一个自定义的成本函数执行最优匹配。这项练习将为您提供在实践中应用OBV技术的全景式视图。",
            "id": "4090773",
            "problem": "给定一个用于评估数值天气预报（NWP）和气候模型中空间和基于对象的检验的合成设置。具体来说，您将计算二维网格场中经过二值化阈值处理的连通对象的属性，然后使用严格定义的代价函数和线性总和分配（LSA）准则，对预报对象和观测对象进行最优匹配。\n\n基本原理：\n- 基于对象的检验（OBV）作用于由网格强度定义的阈值化二值场，并根据指定的邻域规则将场划分为连通分量。每个对象的面积、形状描述符和强度统计量等属性都会被计算。\n- 对于二维（2D）网格场，对象边界由一个阈值 $T$ 应用于由行 $r$ 和列 $c$ 索引的离散网格上的强度 $I_{r,c}$ 而产生。\n- 连通性通过 $8$-连通性定义：如果两个网格单元的行索引之差最多为 $1$ 且列索引之差最多为 $1$（包括对角相邻），则它们是邻居。\n\n将使用的定义：\n- 阈值化：对于每个强度为 $I_{r,c}$ 的网格单元 $(r,c)$，如果 $I_{r,c} \\ge T$，则定义一个二值掩码 $M_{r,c} = 1$，否则 $M_{r,c} = 0$。\n- 连通对象：在 $8$-连通性下，一组 $M_{r,c} = 1$ 的单元构成的极大连通集合。\n- 面积：对象的面积是其网格单元的数量。将面积表示为网格单元的整数计数。\n- 最大强度：对象中所有单元的 $I_{r,c}$ 的最大值。将其表示为实数。\n- 偏心率：对于一个包含 $n$ 个单元的对象，其坐标为 $(x_i,y_i)$，其中 $x_i$ 是列索引，$y_i$ 是行索引，计算其质心 $(\\bar{x},\\bar{y})$：\n$$\n\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i, \\quad \\bar{y} = \\frac{1}{n}\\sum_{i=1}^{n} y_i.\n$$\n定义二阶中心矩（协方差）矩阵\n$$\n\\mathbf{C} = \\begin{pmatrix}\n\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})^2  \\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})(y_i-\\bar{y})\\\\\n\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})(y_i-\\bar{y})  \\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\bar{y})^2\n\\end{pmatrix}.\n$$\n设 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 是 $\\mathbf{C}$ 的特征值，满足 $\\lambda_{\\max} \\ge \\lambda_{\\min} \\ge 0$。定义对象偏心率\n$$\ne = \\sqrt{1 - \\frac{\\lambda_{\\min}}{\\lambda_{\\max}}}\n$$\n当 $\\lambda_{\\max}  0$ 时，如果 $\\lambda_{\\max} = 0$ 则设 $e = 0$。将偏心率表示为 $[0,1]$ 区间内的实数。\n\n成对属性差异归一化：\n- 设预报对象的属性为 $(A_f, e_f, M_f)$，观测对象的属性为 $(A_o, e_o, M_o)$。定义归一化的属性差异\n$$\nd_A = \\frac{|A_f - A_o|}{\\max(A_f, A_o)}, \\quad d_E = |e_f - e_o|, \\quad d_M = \\frac{|M_f - M_o|}{\\max(M_f, M_o)}.\n$$\n所有差异都是无量纲的，且界于 $[0,1]$ 之间。\n\n匹配代价函数：\n- 给定权重 $(w_A, w_E, w_M)$，定义成对代价\n$$\nc = w_A d_A + w_E d_E + w_M d_M.\n$$\n- 对于一个包含 $N_f$ 个预报对象和 $N_o$ 个观测对象的矩形预报-观测配对，最优分配旨在最小化一个大小为 $\\min(N_f, N_o)$ 的一对一匹配中选定配对的代价总和，再加上对每个未匹配的预报对象的惩罚 $p_u$：\n$$\nJ = \\sum_{(i,j)\\in \\mathcal{M}} c_{ij} + p_u \\cdot (N_f - |\\mathcal{M}|),\n$$\n其中 $\\mathcal{M}$ 是已匹配索引对的集合，且 $|\\mathcal{M}| = \\min(N_f, N_o)$。\n\n数据规格：\n- 网格维度为 $8 \\times 8$；索引 $r$ 和 $c$ 从 $0$ 到 $7$。\n- 预报场强度 $I^{(f)}_{r,c}$：所有未指定的单元强度为 $0$。非零强度位于以下坐标，每对表示为 $((r,c), I)$：\n    - $((1,1), 2.0)$, $((1,2), 1.6)$, $((2,1), 1.4)$, $((2,2), 1.2)$,\n    - $((3,4), 1.1)$, $((3,5), 1.4)$, $((3,6), 1.6)$, $((4,4), 1.0)$, $((4,5), 1.2)$, $((4,6), 1.3)$,\n    - $((5,1), 0.95)$, $((5,2), 1.0)$, $((6,1), 1.2)$, $((6,2), 1.3)$, $((7,1), 2.2)$, $((7,2), 2.0)$.\n- 观测场强度 $I^{(o)}_{r,c}$：所有未指定的单元强度为 $0$。非零强度位于以下坐标：\n    - $((3,2), 1.0)$, $((3,3), 1.3)$, $((3,4), 1.5)$, $((4,2), 0.95)$, $((4,3), 1.1)$, $((4,4), 1.2)$,\n    - $((4,6), 1.1)$, $((4,7), 1.2)$, $((5,6), 1.4)$, $((5,7), 1.6)$, $((6,6), 1.7)$, $((6,7), 1.8)$.\n- 对于所有测试用例，阈值固定为 $T = 1.0$。\n\n连通性规则：\n- 使用 $8$-连通性来识别阈值化二值掩码中的连通分量。\n\n测试套件：\n对于每个用例，计算预报和观测对象，推导出每个对象的 $(A,e,M)$，使用给定的权重构建成对代价矩阵，解决最优分配问题，并计算包括未匹配惩罚在内的总目标 $J$。返回四舍五入到 $4$ 位小数的浮点数 $J$。\n- 用例 1：$(w_A, w_E, w_M) = (1.0, 1.0, 1.0)$, $p_u = 0.25$。\n- 用例 2：$(w_A, w_E, w_M) = (0.5, 2.0, 1.0)$, $p_u = 0.25$。\n- 用例 3：$(w_A, w_E, w_M) = (1.5, 0.0, 1.0)$, $p_u = 0.40$。\n- 用例 4：$(w_A, w_E, w_M) = (0.2, 1.0, 3.0)$, $p_u = 0.10$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用例 1 到 4 的结果，形式为逗号分隔的列表，并用方括号括起来，每个浮点数四舍五入到 $4$ 位小数（例如，$[j_1,j_2,j_3,j_4]$）。",
            "solution": "该问题被评估为有效。它在科学上基于数值天气预报检验的原理，算法上定义良好，内部一致，并包含得出唯一解所需的所有信息。\n\n解决方案通过以下四个主要步骤展开：\n1.  对象识别：基于给定的强度阈值，在预报场和观测场中分离出连通对象。\n2.  属性计算：为每个识别出的对象计算指定的属性（面积、最大强度、偏心率）。\n3.  代价矩阵构建：对于每个测试用例，使用该用例特定的权重计算每个预报对象和每个观测对象之间的成对代价。\n4.  最优分配和总代价：解决线性总和分配问题以找到最优匹配，并计算包括未匹配预报对象惩罚在内的总目标函数 $J$。\n\n所有数学实体均按要求使用 LaTeX 排版。\n\n**第 1 步：对象识别**\n\n首先，填充 $8 \\times 8$ 的预报（$I^{(f)}$）和观测（$I^{(o)}$）强度网格。然后，通过识别强度 $I_{r,c}$ 大于或等于阈值 $T=1.0$ 的单元，为每个网格生成一个二值掩码。\n\n$M_{r,c} = 1 \\text{ 如果 } I_{r,c} \\ge T, \\text{ 且 } M_{r,c} = 0 \\text{ 否则。}$\n\n使用 $8$-连通性的连通分量标记算法（例如，在二值掩码上进行广度优先搜索），识别出对象。\n\n对于**预报场**，以下单元的强度高于阈值：\n- $\\{(1,1), (1,2), (2,1), (2,2)\\}$\n- $\\{(3,4), (3,5), (3,6), (4,4), (4,5), (4,6)\\}$\n- $\\{(5,2), (6,1), (6,2), (7,1), (7,2)\\}$\n\n此过程产生 $N_f = 3$ 个不同的预报对象：\n- $F_1$：位于左上角的一个 $2 \\times 2$ 的单元块。\n- $F_2$：位于网格中部的一个包含 $6$ 个单元的集合。\n- $F_3$：位于左下角的一个包含 $5$ 个单元的组。\n\n对于**观测场**，以下单元的强度高于阈值：\n- $\\{(3,2), (3,3), (3,4), (4,3), (4,4)\\}$\n- $\\{(4,6), (4,7), (5,6), (5,7), (6,6), (6,7)\\}$\n\n此过程产生 $N_o = 2$ 个不同的观测对象：\n- $O_1$：一个包含 $5$ 个单元的组。\n- $O_2$：一个 $3 \\times 2$ 的单元块，包含 $6$ 个单元。\n\n**第 2 步：属性计算**\n\n对于 $N_f=3$ 个预报对象和 $N_o=2$ 个观测对象中的每一个，我们计算一组三个属性：面积（$A$）、最大强度（$M$）和偏心率（$e$）。坐标 $(x,y)$ 定义为（列索引，行索引）。\n\n**预报对象 $F_2$ 的计算示例：**\n- **单元**：$\\{(3,4), (3,5), (3,6), (4,4), (4,5), (4,6)\\}$\n- **面积（$A_{F2}$）**：该对象由 $n=6$ 个单元组成，所以 $A_{F2} = 6$。\n- **最大强度（$M_{F2}$）**：强度为 $\\{1.1, 1.4, 1.6, 1.0, 1.2, 1.3\\}$。最大值为 $M_{F2} = 1.6$。\n- **偏心率（$e_{F2}$）**：\n    - 坐标 $(x_i, y_i)$: $\\{(4,3), (5,3), (6,3), (4,4), (5,4), (6,4)\\}$.\n    - 质心: $(\\bar{x}, \\bar{y}) = (\\frac{1}{6}\\sum x_i, \\frac{1}{6}\\sum y_i) = (5.0, 3.5)$。\n    - 协方差矩阵 $\\mathbf{C}$：\n    $$ \\mathbf{C} = \\begin{pmatrix} \\frac{1}{n}\\sum(x_i-\\bar{x})^2  \\frac{1}{n}\\sum(x_i-\\bar{x})(y_i-\\bar{y})\\\\ \\frac{1}{n}\\sum(x_i-\\bar{x})(y_i-\\bar{y})  \\frac{1}{n}\\sum(y_i-\\bar{y})^2 \\end{pmatrix} = \\begin{pmatrix} 0.666...  0.0 \\\\ 0.0  0.25 \\end{pmatrix} $$\n    - 特征值：此对角矩阵的特征值为 $\\lambda_{\\max} = 2/3$ 和 $\\lambda_{\\min} = 0.25$。\n    - 偏心率：$e_{F2} = \\sqrt{1 - \\frac{\\lambda_{\\min}}{\\lambda_{\\max}}} = \\sqrt{1 - \\frac{0.25}{2/3}} = \\sqrt{1 - 0.375} = \\sqrt{0.625} \\approx 0.79057$。\n    \n对所有对象执行此过程，得出以下属性：\n\n| 对象   | 面积 ($A$) | 最大强度 ($M$) | 偏心率 ($e$)     |\n|:------:|:----------:|:-------------------:|:------------------:|\n| $F_1$  |     $4$    |        $2.0$        |     $0.0$          |\n| $F_2$  |     $6$    |        $1.6$        |  $\\approx 0.79057$ |\n| $F_3$  |     $5$    |        $2.2$        |  $\\approx 0.81650$ |\n| $O_1$  |     $5$    |        $1.5$        |  $\\approx 0.81650$ |\n| $O_2$  |     $6$    |        $1.8$        |  $\\approx 0.79057$ |\n\n**第 3 步：代价矩阵和最优匹配**\n\n对于每个测试用例，我们构建一个 $3 \\times 2$ 的代价矩阵，其中条目 $c_{ij}$ 是匹配预报对象 $F_i$ 与观测对象 $O_j$ 的代价。代价为 $c_{ij} = w_A d_A + w_E d_E + w_M d_M$。\n\n**用例 1 示例**：$(w_A, w_E, w_M) = (1.0, 1.0, 1.0)$。\n让我们计算匹配 $F_2$ 和 $O_2$ 的代价 $c_{22}$。\n- 属性：$F_2(A=6, M=1.6, e\\approx0.79057)$ 和 $O_2(A=6, M=1.8, e\\approx0.79057)$。\n- $d_A = \\frac{|6-6|}{\\max(6,6)} = 0$。\n- $d_E = |0.79057 - 0.79057| = 0$。\n- $d_M = \\frac{|1.6-1.8|}{\\max(1.6, 1.8)} = \\frac{0.2}{1.8} \\approx 0.11111$。\n- $c_{22} = 1.0 \\cdot (0) + 1.0 \\cdot (0) + 1.0 \\cdot (0.11111) = 0.11111$。\n\n为用例 1 填充整个代价矩阵：\n$$ \\mathbf{C}_{\\text{cost}} = \\begin{pmatrix}\n1.2665  1.2239 \\\\\n0.2551  0.1111 \\\\\n0.3182  0.3744\n\\end{pmatrix} $$\n我们对此矩阵应用线性总和分配算法。由于 $N_f  N_o$，该算法为 $N_o=2$ 个观测对象找到最佳匹配。用例 1 的最优分配是匹配 $(F_2, O_2)$ 和 $(F_3, O_1)$，使 $F_1$ 未匹配。\n\n**第 4 步：总目标计算**\n\n总目标函数为 $J = \\sum_{(i,j)\\in \\mathcal{M}} c_{ij} + p_u \\cdot (N_f - |\\mathcal{M}|)$，其中 $\\mathcal{M}$ 是最优代价对的集合。\n\n**用例 1 示例**：\n- 权重：$(w_A, w_E, w_M) = (1.0, 1.0, 1.0)$。\n- 惩罚：$p_u = 0.25$。\n- 最优对：$(F_2, O_2)$ 代价 $c_{22} \\approx 0.1111$ 和 $(F_3, O_1)$ 代价 $c_{31} \\approx 0.3182$。\n- 匹配代价总和：$0.11111 + 0.31818 \\approx 0.4293$。\n- 未匹配的预报对象数：$N_f - |\\mathcal{M}| = 3 - 2 = 1$。\n- 惩罚代价：$p_u \\cdot 1 = 0.25$。\n- 总目标：$J_1 = 0.4293 + 0.25 = 0.6793$。\n\n对四个测试用例重复这整个过程，每个用例都有不同的权重和惩罚，以产生最终的结果向量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Computes an object-based verification metric for synthetic forecast and observation fields.\n    \n    The process involves:\n    1. Identifying connected objects in both fields via thresholding.\n    2. Calculating area, max intensity, and eccentricity for each object.\n    3. For each test case, building a pairwise cost matrix based on attribute differences.\n    4. Solving the linear sum assignment problem to find the optimal matching.\n    5. Calculating the total objective J, including a penalty for unmatched forecast objects.\n    \"\"\"\n\n    # --- Data Specification ---\n    GRID_DIM = 8\n    THRESHOLD = 1.0\n    \n    forecast_intensities_spec = {\n        ((1, 1), 2.0), ((1, 2), 1.6), ((2, 1), 1.4), ((2, 2), 1.2),\n        ((3, 4), 1.1), ((3, 5), 1.4), ((3, 6), 1.6), ((4, 4), 1.0), ((4, 5), 1.2), ((4, 6), 1.3),\n        ((5, 1), 0.95), ((5, 2), 1.0), ((6, 1), 1.2), ((6, 2), 1.3), ((7, 1), 2.2), ((7, 2), 2.0)\n    }\n    \n    observed_intensities_spec = {\n        ((3, 2), 1.0), ((3, 3), 1.3), ((3, 4), 1.5), ((4, 2), 0.95), ((4, 3), 1.1), ((4, 4), 1.2),\n        ((4, 6), 1.1), ((4, 7), 1.2), ((5, 6), 1.4), ((5, 7), 1.6), ((6, 6), 1.7), ((6, 7), 1.8)\n    }\n\n    # --- Test Suite ---\n    test_cases = [\n        # (w_A, w_E, w_M), p_u\n        ((1.0, 1.0, 1.0), 0.25),\n        ((0.5, 2.0, 1.0), 0.25),\n        ((1.5, 0.0, 1.0), 0.40),\n        ((0.2, 1.0, 3.0), 0.10),\n    ]\n\n    def create_grid(spec, dim):\n        grid = np.zeros((dim, dim), dtype=float)\n        for (r, c), intensity in spec:\n            grid[r, c] = intensity\n        return grid\n\n    def find_objects(intensity_grid, threshold):\n        mask = intensity_grid >= threshold\n        labels = np.zeros_like(mask, dtype=int)\n        current_label = 0\n        rows, cols = mask.shape\n        \n        for r in range(rows):\n            for c in range(cols):\n                if mask[r, c] and labels[r, c] == 0:\n                    current_label += 1\n                    q = [(r, c)]\n                    labels[r, c] = current_label\n                    head = 0\n                    while head  len(q):\n                        row, col = q[head]\n                        head += 1\n                        \n                        for dr in [-1, 0, 1]:\n                            for dc in [-1, 0, 1]:\n                                if dr == 0 and dc == 0:\n                                    continue\n                                nr, nc = row + dr, col + dc\n                                \n                                if 0 = nr  rows and 0 = nc  cols and \\\n                                   mask[nr, nc] and labels[nr, nc] == 0:\n                                    labels[nr, nc] = current_label\n                                    q.append((nr, nc))\n                                    \n        return labels, current_label\n\n    def calculate_attributes(labeled_grid, intensity_grid, num_objects):\n        attributes = []\n        for label in range(1, num_objects + 1):\n            # Coordinates are (row, col)\n            coords_r, coords_c = np.where(labeled_grid == label)\n            \n            # Area\n            area = len(coords_r)\n            \n            # Max Intensity\n            max_intensity = np.max(intensity_grid[coords_r, coords_c])\n            \n            # Eccentricity\n            if area = 1:\n                eccentricity = 0.0\n            else:\n                # Per problem spec, x is col, y is row\n                x_coords = coords_c.astype(float)\n                y_coords = coords_r.astype(float)\n                \n                # Covariance matrix with 1/n normalization (bias=True)\n                # np.cov expects variables as rows, observations as columns\n                cov_matrix = np.cov(np.vstack((x_coords, y_coords)), bias=True)\n\n                if cov_matrix.ndim  2:\n                    # Occurs if e.g. all x or all y are identical\n                    lambda_max = cov_matrix.item()\n                    lambda_min = 0.0\n                else: \n                    eigenvalues = np.linalg.eigvalsh(cov_matrix)\n                    lambda_min, lambda_max = eigenvalues[0], eigenvalues[1]\n\n                if lambda_max > 0:\n                    # Clip argument to sqrt to avoid small negative values from float precision\n                    eccentricity = np.sqrt(max(0, 1 - lambda_min / lambda_max))\n                else:\n                    eccentricity = 0.0\n\n            attributes.append({'A': area, 'e': eccentricity, 'M': max_intensity})\n        return attributes\n\n    # --- Step 1  2: Identify objects and calculate base attributes (once) ---\n    I_f = create_grid(forecast_intensities_spec, GRID_DIM)\n    I_o = create_grid(observed_intensities_spec, GRID_DIM)\n\n    labels_f, n_f = find_objects(I_f, THRESHOLD)\n    labels_o, n_o = find_objects(I_o, THRESHOLD)\n\n    attrs_f = calculate_attributes(labels_f, I_f, n_f)\n    attrs_o = calculate_attributes(labels_o, I_o, n_o)\n\n    results = []\n    # --- Loop through test cases ---\n    for (w_A, w_E, w_M), p_u in test_cases:\n        \n        # --- Step 3: Cost Matrix Construction ---\n        cost_matrix = np.zeros((n_f, n_o))\n        for i in range(n_f):\n            for j in range(n_o):\n                f_obj = attrs_f[i]\n                o_obj = attrs_o[j]\n                \n                d_A = abs(f_obj['A'] - o_obj['A']) / max(f_obj['A'], o_obj['A']) if max(f_obj['A'], o_obj['A']) > 0 else 0\n                d_E = abs(f_obj['e'] - o_obj['e'])\n                d_M = abs(f_obj['M'] - o_obj['M']) / max(f_obj['M'], o_obj['M']) if max(f_obj['M'], o_obj['M']) > 0 else 0\n                \n                cost = w_A * d_A + w_E * d_E + w_M * d_M\n                cost_matrix[i, j] = cost\n\n        # --- Step 4: Optimal Assignment and Total Cost ---\n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        matched_cost_sum = cost_matrix[row_ind, col_ind].sum()\n        \n        num_matched = len(row_ind)\n        num_unmatched_f = n_f - num_matched\n        \n        unmatched_penalty = p_u * num_unmatched_f\n        \n        total_objective_J = matched_cost_sum + unmatched_penalty\n        results.append(round(total_objective_J, 4))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}