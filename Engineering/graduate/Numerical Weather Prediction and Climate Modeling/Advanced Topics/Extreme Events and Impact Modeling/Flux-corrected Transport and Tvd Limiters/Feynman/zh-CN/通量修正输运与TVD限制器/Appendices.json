{
    "hands_on_practices": [
        {
            "introduction": "要理解为何需要像通量修正输运（FCT）这样的高级方法，我们首先需要一个基准。本练习将探讨最简单的单调数值格式——一阶迎风格式的性质。\n\n通过将该格式应用于一个急剧的不连续面并计算总变差，您将直接观察到它的两个关键特性：它避免了产生新的振荡（即总变差不增，TVD），但同时也引入了显著的数值耗散，使陡峭的锋面变得模糊。这项练习  为理解稳定性和准确性之间的权衡提供了基础，而这种权衡正是开发高分辨率 TVD 限制器的动因。",
            "id": "4043793",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中速度 $a>0$ 为常数，定义在均匀网格 $x_{i} = i\\,\\Delta x$上，其中 $i \\in \\mathbb{Z}$。设库朗数 $C = a\\,\\Delta t / \\Delta x = 0.7$。初始数据为离散亥维赛阶跃函数，由 $u_{i}^{0} = 0$（对于 $i \\leq 0$）和 $u_{i}^{0} = 1$（对于 $i \\geq 1$）给出。假设计算区域足够大，并以这些恒定状态进行初始化，使得在第一个时间步内边界效应可以忽略不计。\n\n使用与正平流速度 $a>0$ 相对应的保守一阶迎风格式，将解从 $t^{0}$ 推进一个时间步到 $t^{1} = t^{0} + \\Delta t$。然后，计算在 $t^{1}$ 时的离散总变差，其定义为\n$$\n\\mathrm{TV}\\!\\left(u^{1}\\right) = \\sum_{i=-\\infty}^{\\infty} \\left| u_{i+1}^{1} - u_{i}^{1} \\right|.\n$$\n解答下列问题，从构成通量修正输运和总变差不增（TVD）方法基础的守恒性和单调性基本原理出发，并以该一阶迎风格式为基准：以通量形式推导单步更新公式，确定间断点附近的非平凡更新值，并计算离散总变差。将您的最终答案表示为等于 $\\mathrm{TV}\\!\\left(u^{1}\\right)$ 的单个实数，无需单位。无需进行四舍五入。",
            "solution": "该问题要求使用一阶迎风格式，计算一维线性平流方程的解在一个时间步后的离散总变差 $\\mathrm{TV}(u^1)$。\n\n控制偏微分方程为线性平流方程：\n$$\nu_{t} + a\\,u_{x} = 0\n$$\n其中平流速度 $a$ 是一个正数 ($a>0$)。通过将通量函数定义为 $F(u) = a u$，该方程可以写成守恒形式 $u_t + F(u)_x = 0$。\n\n在间距为 $\\Delta x$ 的均匀网格上、时间步长为 $\\Delta t$ 的情况下，该方程的一个通用保守有限体积格式由下式给出：\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n此处，$u_i^n$ 是在网格点 $x_i = i\\,\\Delta x$ 和时间 $t^n = n\\,\\Delta t$ 处解的数值近似。$F_{i\\pm 1/2}$ 项表示单元 $i$ 和单元 $i\\pm1$ 之间界面的数值通量。\n\n问题指定使用一阶迎风格式。对于 $a>0$，信息沿 x-正方向（从左到右）传播。因此，界面 $x_{i+1/2}$（单元 $i$ 的右边界）处的“迎风”值是来自单元 $i$ 的值。因此，数值通量定义为：\n$$\nF_{i+1/2} = F(u_i^n) = a u_i^n\n$$\n类似地，单元 $i$ 的左边界 $x_{i-1/2}$ 处的通量由迎风单元（即单元 $i-1$）确定：\n$$\nF_{i-1/2} = F(u_{i-1}^n) = a u_{i-1}^n\n$$\n将这些通量定义代入保守格式，得到通量形式的更新法则：\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\frac{\\Delta t}{\\Delta x} \\left( a u_i^n - a u_{i-1}^n \\right)\n$$\n通过定义库朗数 $C = \\frac{a \\Delta t}{\\Delta x}$，方程简化为：\n$$\nu_{i}^{n+1} = u_{i}^{n} - C \\left( u_{i}^{n} - u_{i-1}^{n} \\right)\n$$\n这是一阶迎风格式的单步更新公式。已知当 $0 \\leq C \\leq 1$ 时，该格式是总变差不增（TVD）的。\n\n问题提供以下数据：\n- 库朗数：$C = 0.7$。\n- 时间 $t=t^0$ 时的初始条件：$u_i^0$ 是一个离散亥维赛阶跃函数。\n$$\nu_{i}^{0} = \\begin{cases} 0  \\text{for } i \\leq 0 \\\\ 1  \\text{for } i \\geq 1 \\end{cases}\n$$\n我们应用 $n=0$ 时的更新公式来求解 $t^1 = t^0 + \\Delta t$ 时的解：\n$$\nu_{i}^{1} = u_{i}^{0} - 0.7 \\left( u_{i}^{0} - u_{i-1}^{0} \\right)\n$$\n只有在差值 $u_{i}^{0} - u_{i-1}^{0}$ 非零的地方，$u_i^1$ 的值才会与 $u_i^0$ 不同。这种情况仅发生在网格点 $i=1$ 处，因为 $u_1^0=1$ 且 $u_0^0=0$。\n\n让我们计算所有相关网格指数 $i$ 的更新值 $u_i^1$：\n1.  对于 $i \\leq 0$：\n    $u_{i}^{0}$ 和 $u_{i-1}^{0}$ 都等于 $0$。\n    $$\n    u_{i}^{1} = 0 - 0.7 \\left( 0 - 0 \\right) = 0\n    $$\n    因此，对于所有 $i \\leq 0$，$u_{i}^{1} = 0$。\n\n2.  对于 $i = 1$：\n    我们有 $u_{1}^{0}=1$ 和 $u_{0}^{0}=0$。\n    $$\n    u_{1}^{1} = u_{1}^{0} - 0.7 \\left( u_{1}^{0} - u_{0}^{0} \\right) = 1 - 0.7 \\left( 1 - 0 \\right) = 1 - 0.7 = 0.3\n    $$\n\n3.  对于 $i \\geq 2$：\n    $u_{i}^{0}$ 和 $u_{i-1}^{0}$ 都等于 $1$。\n    $$\n    u_{i}^{1} = 1 - 0.7 \\left( 1 - 1 \\right) = 1\n    $$\n    因此，对于所有 $i \\geq 2$，$u_{i}^{1} = 1$。\n\n因此，$t^1$ 时刻解的分布为：\n$$\nu_i^1 = \\begin{cases} 0  \\text{if } i \\le 0 \\\\ 0.3  \\text{if } i = 1 \\\\ 1  \\text{if } i \\ge 2 \\end{cases}\n$$\n最初的陡峭阶跃在单元 $i=0$ 和 $i=2$ 之间的界面上被抹平了，这是一阶迎风格式特有的扩散行为。\n\n现在，我们使用给定的定义来计算这个新状态的离散总变差 $\\mathrm{TV}(u^1)$：\n$$\n\\mathrm{TV}\\!\\left(u^{1}\\right) = \\sum_{i=-\\infty}^{\\infty} \\left| u_{i+1}^{1} - u_{i}^{1} \\right|\n$$\n我们只需对差值非零的项求和。这些项出现在解值发生变化的界面处。\n-   对于 $i \\leq -1$：$|u_{i+1}^1 - u_i^1| = |0-0| = 0$。\n-   对于 $i = 0$：$|u_1^1 - u_0^1| = |0.3 - 0| = 0.3$。\n-   对于 $i = 1$：$|u_2^1 - u_1^1| = |1 - 0.3| = 0.7$。\n-   对于 $i \\geq 2$：$|u_{i+1}^1 - u_i^1| = |1-1| = 0$。\n\n总变差是这些跳跃幅度的总和：\n$$\n\\mathrm{TV}\\!\\left(u^{1}\\right) = 0.3 + 0.7 = 1\n$$\n作为参照，初始数据的总变差是 $\\mathrm{TV}(u^0) = |u_1^0 - u_0^0| = |1-0| = 1$。$\\mathrm{TV}(u^1) \\leq \\mathrm{TV}(u^0)$ 这一事实证实了该方法在这种情况下具有总变差不增（TVD）的性质。\n最终答案是 $\\mathrm{TV}(u^1)$ 的数值。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "在了解了迎风格式的数值耗散之后，我们现在转向如何提高计算精度。一种有效的方法是在计算通量之前，在每个网格单元内重构一个更精细、更高阶的廓线。\n\n这项练习  深入探讨了斜率限制重构的核心机制，这是现代高分辨率格式的基石。您将学习如何使用像 `minmod` 这样的限制器来约束重构的斜率，从而在保持平滑区域高阶精度的同时防止产生振荡。通过计算界面左右状态值和最终的数值通量，您将具体地、一步步地理解 TVD 原理是如何在数值方法的最底层被强制执行的。",
            "id": "4043760",
            "problem": "考虑一个一维被动示踪剂在数值天气预报模型中被恒定的纬向风平流，该过程可理想化为线性平流方程 $u_{t} + a\\,u_{x} = 0$。其中，速度 $a > 0$ 为常数，且计算在网格中心由索引 $i$ 标记的均匀网格上进行。在通量修正输运范式中，高分辨率重构需要遵循全变差递减 (TVD) 原则，以防止在陡峭梯度附近出现伪振荡。假设采用斜率限制的线性重构，并通过使用 minmod 限制器来强制执行 TVD 属性。minmod 限制器定义为 $\\mathrm{minmod}(\\alpha,\\beta)$，如果 $\\alpha$ 和 $\\beta$ 符号相同，则返回绝对值较小的参数；否则返回 $0$。\n\n给定五个连续网格中心的离散廓线：$u_{i-2} = 1.1$，$u_{i-1} = 1.6$，$u_{i} = 2.0$，$u_{i+1} = 3.0$，$u_{i+2} = 3.4$。风速为 $a = 15$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n\n从重构必须满足 TVD 且与线性平流一致的要求出发，推导计算网格 $i$ 和 $i+1$ 之间界面上的左状态 $u_{i+1/2}^{-}$ 和右状态 $u_{i+1/2}^{+}$ 所需的斜率限制界面重构。然后，在该界面上构造 $a > 0$ 对应的迎风数值通量。给出精确值，不要四舍五入。以米/秒（$\\mathrm{m}\\,\\mathrm{s}^{-1}$）为单位表示最终的数值通量。",
            "solution": "该问题要求计算网格 $i$ 和 $i+1$ 之间界面 $x_{i+1/2}$ 处的数值通量。这是有限体积法中的一个关键步骤。该方法涉及在每个网格单元内对解 $u$ 进行分段线性重构，并由 TVD 限制器进行约束以避免伪振荡。\n\n在一个通用网格单元 $j$ 内，解由一个线性函数近似：\n$$ u(x) = u_j + \\sigma_j \\frac{x - x_j}{\\Delta x} $$\n其中 $u_j$ 是网格平均值，$x_j$ 是网格中心坐标，$\\Delta x$ 是均匀的网格宽度，$\\sigma_j$ 是受限斜率。\n\n网格单元 $j$ 的左界面 ($x_{j-1/2}$) 和右界面 ($x_{j+1/2}$) 上的值由下式给出：\n$$ u_{j-1/2}^{+} = u_j - \\frac{1}{2}\\sigma_j $$\n$$ u_{j+1/2}^{-} = u_j + \\frac{1}{2}\\sigma_j $$\n\n问题要求的是特定界面 $x_{i+1/2}$ 上的状态。界面左侧的状态 $u_{i+1/2}^{-}$ 由网格 $i$ 中的重构决定。界面右侧的状态 $u_{i+1/2}^{+}$ 由网格 $i+1$ 中的重构决定。\n$$ u_{i+1/2}^{-} = u_i + \\frac{1}{2}\\sigma_i $$\n$$ u_{i+1/2}^{+} = u_{i+1} - \\frac{1}{2}\\sigma_{i+1} $$\n\n要计算这些状态，我们必须首先确定受限斜率 $\\sigma_i$ 和 $\\sigma_{i+1}$。`minmod` 限制器应用于从相邻网格平均值导出的斜率。在网格单元 $j$ 中，一个强制执行 TVD 属性的常见斜率选择是通过向前和向后差分来限制中心差分斜率。这是通过将 `minmod` 函数应用于向前和向后差分本身来实现的：\n$$ \\sigma_j = \\mathrm{minmod}(u_{j+1} - u_j, u_j - u_{j-1}) $$\n`minmod` 函数定义为：\n$$ \\mathrm{minmod}(\\alpha, \\beta) = \\begin{cases} \\alpha  \\text{if } |\\alpha| \\le |\\beta| \\text{ and } \\alpha\\beta > 0 \\\\ \\beta  \\text{if } |\\beta| < |\\alpha| \\text{ and } \\alpha\\beta > 0 \\\\ 0  \\text{if } \\alpha\\beta \\le 0 \\end{cases} $$\n\n首先，我们计算网格 $i$ 的斜率 $\\sigma_i$。相关的差分为：\n- 向前差分：$u_{i+1} - u_i = 3.0 - 2.0 = 1.0$\n- 向后差分：$u_i - u_{i-1} = 2.0 - 1.6 = 0.4$\n\n两个差分都为正，因此它们的乘积为正。我们应用 `minmod` 函数：\n$$ \\sigma_i = \\mathrm{minmod}(1.0, 0.4) $$\n由于两个参数符号相同，函数返回绝对值较小的那一个。\n$$ \\sigma_i = 0.4 $$\n\n接下来，我们计算网格 $i+1$ 的斜率 $\\sigma_{i+1}$。相关的差分为：\n- 向前差分：$u_{i+2} - u_{i+1} = 3.4 - 3.0 = 0.4$\n- 向后差分：$u_{i+1} - u_i = 3.0 - 2.0 = 1.0$\n\n同样，两个差分都为正。我们应用 `minmod` 函数：\n$$ \\sigma_{i+1} = \\mathrm{minmod}(0.4, 1.0) $$\n函数返回绝对值较小的参数。\n$$ \\sigma_{i+1} = 0.4 $$\n\n现在我们可以计算界面状态 $u_{i+1/2}^{-}$ 和 $u_{i+1/2}^{+}$。\n界面处的左状态是：\n$$ u_{i+1/2}^{-} = u_i + \\frac{1}{2}\\sigma_i = 2.0 + \\frac{1}{2}(0.4) = 2.0 + 0.2 = 2.2 $$\n界面处的右状态是：\n$$ u_{i+1/2}^{+} = u_{i+1} - \\frac{1}{2}\\sigma_{i+1} = 3.0 - \\frac{1}{2}(0.4) = 3.0 - 0.2 = 2.8 $$\n\n最后一步是计算界面处的数值通量 $F_{i+1/2}$。对于线性平流方程 $u_t + a u_x = 0$，物理通量为 $F(u) = au$。数值通量通过求解界面上具有重构状态 $(u_L, u_R) = (u_{i+1/2}^{-}, u_{i+1/2}^{+})$ 的黎曼问题来确定。\n\n由于平流速度 $a = 15$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$ 为正 ($a > 0$)，信息从左向右传播。因此，迎风格式选择界面左侧（迎风侧）的状态来计算通量。\n$$ F_{i+1/2} = F(u_{i+1/2}^{-}) = a \\cdot u_{i+1/2}^{-} $$\n\n代入已知值：\n$$ F_{i+1/2} = 15 \\cdot (2.2) $$\n$$ F_{i+1/2} = 33 $$\n\n问题要求答案以 $\\mathrm{m}\\,\\mathrm{s}^{-1}$ 表示。量 $a$ 的单位是 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。要使乘积 $a \\cdot u$ 的单位也是 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，示踪剂的值 $u$ 必须是无量纲量（例如，混合比）。这是大气建模中的常见约定。因此，数值通量的值为 $33$，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。",
            "answer": "$$\n\\boxed{33}\n$$"
        },
        {
            "introduction": "通过应用来理解理论是最佳途径。这最后一个练习要求您综合所学知识，从第一性原理出发，实现一个完整的通量修正输运（FCT）算法。\n\n这项编程练习  超越了简单的纸笔计算，进入了对一个稳健、无振荡输送格式的实际构建。您将构造低阶解，计算高阶反扩散修正，最关键的是，您将实现 Zalesak 通量限制器来强制施加物理边界和单调性。通过在多种初始条件下测试您的代码，您将对 FCT 格式如何有效平衡精度和稳定性获得深刻的、操作层面的理解，而这正是它们在气候和天气模拟中成为宝贵工具的原因。",
            "id": "4043809",
            "problem": "考虑由线性输运方程控制的一维水汽混合比 $q(x,t)$ 的守恒平流\n$$\n\\partial_t q + a \\,\\partial_x q = 0,\n$$\n其中 $a$ 是一个恒定的平流速度，$q$ 受物理约束 $q \\in [0,1]$ 的限制。任务是实现一个单独的通量修正输运 (FCT) 步骤，该步骤结合了低阶单调通量和高阶通量，并对反扩散通量进行限制，以防止超出边界的过冲，同时最小化数值扩散。计算在一个一维空间均匀周期性网格上进行。\n\n您必须从以下基础出发：\n- 在有限体积离散化中，质量守恒意味着网格平均值的变化仅由网格交界面处的数值通量差决定。\n- 对于库朗数 $C = |a| \\Delta t / \\Delta x \\leq 1$，低阶迎风格式通量是单调且保正的。\n- 高阶通量（例如，中心或二阶精度通量）可以减少数值扩散，但可能在陡峭梯度附近产生过冲和下冲。\n- 通量修正输运将反扩散通量定义为所选高阶通量与低阶单调通量之差，然后限制此反扩散通量以强制执行边界并避免产生新的极值。\n\n实现以下要求，不要使用问题文本中提供的快捷公式：\n- 使用一个覆盖 $[0,L)$ 的 $N$ 个网格单元的均匀周期性网格，网格宽度为 $\\Delta x = L/N$，以及一个由指定的库朗数 $C$ 通过 $\\Delta t = C \\Delta x / |a|$ 决定的显式时间步长 $\\Delta t$。\n- 构建一个陡峭的水汽锋面初始条件 $q(x,0)$，该条件为分段常数：在一个或多个指定区间内 $q(x,0) = 1$，在其他地方 $q(x,0) = 0$（在 $x=0$ 和 $x=L$ 处呈周期性）。\n- 计算网格交界面处的低阶单调数值通量、一个高阶相容数值通量，并以它们的差值形成原始反扩散通量。然后计算受限的反扩散通量，该通量需满足：\n  1) 在修正步骤后强制 $q \\in [0,1]$，以及\n  2) 避免相对于前一时间层的三点模板产生新的局部极值。\n- 执行一个 FCT 更新步骤，将受限的反扩散通量应用于低阶解，从而得到该单个时间步的最终 $q$。\n\n单位：\n- 平流速度 $a$ 必须以米/秒（$\\mathrm{m/s}$）为单位指定。\n- 空间长度 $L$ 必须以米（$\\mathrm{m}$）为单位指定。\n- 时间步长 $\\Delta t$ 必须使用库朗数 $C$ 计算，单位为秒（$\\mathrm{s}$）。\n\n您的程序必须在 FCT 限制更新后，为每个测试案例计算以下三个诊断量：\n- 上边界以上的过冲幅度：$\\max(\\max_i q_i - 1, 0)$，以小数形式表示。\n- 下边界以下的下冲幅度：$\\max(0 - \\min_i q_i, 0)$，以小数形式表示。\n- 在周期性网格上定义的总变差：$\\sum_{i=0}^{N-1} |q_{i+1 \\bmod N} - q_i|$，以小数形式表示。\n\n测试套件：\n使用以下四个测试案例，每个案例由 $(N,L,a,C,\\text{intervals})$ 指定，其中 intervals 是 $[0,L)$ 的子范围，在这些子范围上初始时 $q=1$：\n- 测试 $1$：$N=200$，$L=1$，$a=1$，$C=0.5$，区间 $\\{[0.4L,0.6L]\\}$。\n- 测试 $2$：$N=200$，$L=1$，$a=1$，$C=0.5$，跨边界环绕的区间：$\\{[0.9L, L), [0, 0.1L]\\}$。\n- 测试 $3$：$N=200$，$L=1$，$a=1$，$C=0.95$，区间 $\\{[0.25L,0.35L]\\}$。\n- 测试 $4$：$N=200$，$L=1$，$a=-1$，$C=0.7$，区间 $\\{[0.5L,0.7L]\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有四个测试按顺序连接的诊断量，形式为用方括号括起来的逗号分隔列表。具体如下：\n$[o_1,u_1,tv_1,o_2,u_2,tv_2,o_3,u_3,tv_3,o_4,u_4,tv_4]$\n其中 $o_k$ 是过冲幅度，$u_k$ 是下冲幅度，$tv_k$ 是测试 $k$ 的总变差，每个都以小数形式表示。",
            "solution": "该问题要求实现一维线性平流方程的一个时间步，\n$$\n\\partial_t q + a \\, \\partial_x q = 0,\n$$\n其中 $q(x,t)$ 是一个水汽混合比，物理上约束在 $q \\in [0,1]$ 范围内，$a$ 是一个恒定的平流速度。解将在一个覆盖域 $[0, L)$ 的 $N$ 个网格单元的均匀周期性网格上计算。核心任务是实现一个通量修正输运 (FCT) 更新步骤。\n\n该方程在一个网格单元 $i$（从 $x_{i-1/2}$ 到 $x_{i+1/2}$）上的有限体积离散化，导出了网格平均量 $q_i$ 的更新公式：\n$$\nq_i^{n+1} = q_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2}),\n$$\n其中 $q_i^n$ 是时间层 $n$ 的值，$\\Delta x = L/N$ 是网格宽度，$\\Delta t$ 是时间步长，$F_{i+1/2}$ 是网格单元 $i$ 和 $i+1$ 之间交界面上的数值通量。时间步长由库朗数 $C$ 决定，即 $\\Delta t = C \\Delta x / |a|$。\n\nFCT 方法将一个低阶、单调的格式与一个高阶、更精确但可能产生振荡的格式相结合，以获得既精确又非振荡的解。该过程分几个阶段执行。\n\n**1. 低阶解（输运和扩散）**\n\n首先，使用低阶单调通量 $F^L$ 计算一个试探解 $q^L$。一个标准的选择是一阶迎风通量，它具有扩散性，但保证对于 $q^n \\in [0,1]$ 和库朗数 $C \\le 1$，解 $q^L$ 也将保持在 $[0,1]$ 范围内，并且不会产生新的极值。迎风通量定义为：\n$$\nF^L_{i+1/2} = \\begin{cases} a q_i^n  \\text{if } a > 0 \\\\ a q_{i+1}^n  \\text{if } a < 0 \\end{cases}\n$$\n那么，低阶的、“经输运和扩散后的”解 $q_i^L$ 是：\n$$\nq_i^L = q_i^n - \\frac{\\Delta t}{\\Delta x} (F^L_{i+1/2} - F^L_{i-1/2})\n$$\n\n**2. 反扩散通量计算**\n\n接下来，我们定义一个反扩散通量，它代表高阶通量 $F^H$ 和低阶通量 $F^L$ 之间的差值。此通量将用于“修正”过度扩散的低阶解。一个合适的高阶选择是二阶精度的 Lax-Wendroff 通量。原始（未限制的）反扩散通量 $A_{i+1/2}$ 是：\n$$\nA_{i+1/2} = F^H_{i+1/2} - F^L_{i+1/2}\n$$\n对于线性平流方程，可以证明这个差值等效于应用数值反扩散。使用 Lax-Wendroff 格式作为高阶参考，反扩散通量简化为：\n$$\nA_{i+1/2} = \\frac{|a|}{2}(1-C)(q_{i+1}^n - q_i^n)\n$$\n其中 $C = |a| \\Delta t / \\Delta x$ 是库朗数。该通量与局部梯度成正比，旨在锐化由低阶步骤扩散的特征。\n\n**3. 通量限制（“修正”步骤）**\n\n直接应用原始反扩散通量可能会重新引入高阶格式的过冲和下冲。FCT 的核心思想是限制这些通量，以确保最终解保持物理有界，并且不产生新的局部极值。受限通量 $A^c_{i+1/2}$ 是原始通量的一部分：$A^c_{i+1/2} = \\alpha_{i+1/2} A_{i+1/2}$，其中修正因子 $\\alpha_{i+1/2}$ 在 $[0,1]$ 范围内。我们使用 Zalesak (1979) 的稳健方法。\n\na. **定义局部边界**：对于每个网格单元 $i$，我们确定更新后解 $q_i^{n+1}$ 的最大和最小允许值。这些值受到物理边界 $[0,1]$ 和相对于前一时间层解 $q^n$ 的“无新极值”条件的约束。网格单元 $i$ 的边界是：\n$$\nQ_i^{\\max} = \\min(1, \\max(q_{i-1}^n, q_i^n, q_{i+1}^n))\n$$\n$$\nQ_i^{\\min} = \\max(0, \\min(q_{i-1}^n, q_i^n, q_{i+1}^n))\n$$\n索引按周期性处理。\n\nb. **计算网格容量**：低阶解 $q_i^L$ 作为基础。网格单元 $i$ 的最大可能增加量是 $Q_i^{\\max} - q_i^L$，最大可能减少量是 $q_i^L - Q_i^{\\min}$。我们计算流入的反扩散质量的总“空间” $M_i^+$，以及可用于流出的反扩散质量的总“物质” $M_i^-$：\n$$\nM_i^+ = (Q_i^{\\max} - q_i^L) \\Delta x\n$$\n$$\nM_i^- = (q_i^L - Q_i^{\\min}) \\Delta x\n$$\n\nc. **原始通量求和**：对于每个网格单元 $i$，我们计算由流入的原始反扩散通量增加的总质量 $P_i^+$，以及由流出的原始反扩散通量移除的总质量 $P_i^-$：\n$$\nP_i^+ = \\Delta t (\\max(0, A_{i-1/2}) - \\min(0, A_{i+1/2}))\n$$\n$$\nP_i^- = \\Delta t (\\max(0, A_{i+1/2}) - \\min(0, A_{i-1/2}))\n$$\n\nd. **确定修正比率**：我们逐个网格地计算流入 ($R_i^+$) 和流出 ($R_i^-$) 通量的修正比率。这些比率决定了在不违反边界的情况下，可以容纳总流入/流出通量的多大一部分。\n$$\nR_i^+ = \\begin{cases} \\min(1, M_i^+ / P_i^+)  \\text{if } P_i^+ > 0 \\\\ 1  \\text{if } P_i^+ = 0 \\end{cases}\n$$\n$$\nR_i^- = \\begin{cases} \\min(1, M_i^- / P_i^-)  \\text{if } P_i^- > 0 \\\\ 1  \\text{if } P_i^- = 0 \\end{cases}\n$$\n\ne. **限制每个通量**：每个通量 $A_{i+1/2}$ 都受到其给予单元和接收单元双方的约束限制。\n如果 $A_{i+1/2} > 0$，它从网格单元 $i$（给予单元）移除质量，并向网格单元 $i+1$（接收单元）添加质量。修正因子为 $\\alpha_{i+1/2} = \\min(R_i^-, R_{i+1}^+)$。\n如果 $A_{i+1/2} < 0$，它向网格单元 $i$（接收单元）添加质量，并从网格单元 $i+1$（给予单元）移除质量。修正因子为 $\\alpha_{i+1/2} = \\min(R_i^+, R_{i+1}^-)$。\n如果 $A_{i+1/2} = 0$，$\\alpha_{i+1/2}$ 未定义，但修正后的通量为 $0$。修正后的通量则为 $A^c_{i+1/2} = \\alpha_{i+1/2} A_{i+1/2}$。\n\n**4. 最终更新（反扩散）**\n\n最后，将受限的反扩散通量应用于低阶解，以获得该时间步的最终修正解：\n$$\nq_i^{n+1} = q_i^L - \\frac{\\Delta t}{\\Delta x}(A^c_{i+1/2} - A^c_{i-1/2})\n$$\n根据构造，$q_i^{n+1}$ 将遵守物理边界，并且不会包含任何新的、非物理的振荡。\n\n**诊断量**\n\n该格式的性能通过从最终状态 $q^{n+1}$ 计算的三个诊断量进行评估：\n- 过冲：$\\max(\\max_i q_i^{n+1} - 1, 0)$\n- 下冲：$\\max(0 - \\min_i q_i^{n+1}, 0)$\n- 总变差 (TV)：$\\sum_{i=0}^{N-1} |q_{(i+1) \\bmod N}^{n+1} - q_i^{n+1}|$。对于方波，理想的格式会保持总变差不增加。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_fct_step(N, L, a, C, intervals):\n    \"\"\"\n    Performs a single Flux-Corrected Transport (FCT) step and computes diagnostics.\n    \n    Args:\n        N (int): Number of grid cells.\n        L (float): Length of the periodic domain.\n        a (float): Advection velocity.\n        C (float): Courant number.\n        intervals (list of tuples): List of [start, end) intervals where q=1.\n\n    Returns:\n        tuple: A tuple containing (overshoot, undershoot, total_variation).\n    \"\"\"\n\n    # 1. Grid and Parameters Setup\n    dx = L / N\n    dt = C * dx / abs(a)\n    \n    # Cell centers\n    x = (np.arange(N) + 0.5) * dx\n    \n    # Initial condition q^n\n    q_n = np.zeros(N, dtype=np.float64)\n    for start, end in intervals:\n        # Indices for cells whose centers fall in [start, end)\n        i_start = int(np.ceil(start / dx - 0.5))\n        i_end = int(np.floor(end / dx - 0.5))\n        if i_start = i_end: # Handles standard interval\n            q_n[i_start : i_end + 1] = 1.0\n        else: # Handle wrap-around case e.g., i_start > i_end\n            q_n[i_start:] = 1.0\n            q_n[:i_end+1] = 1.0\n    \n    # Helper for periodic boundaries\n    def roll(arr, shift):\n        return np.roll(arr, shift)\n\n    # 2. Low-Order Solution (Transport and Diffusion)\n    # Using first-order upwind scheme\n    if a > 0:\n        # Flux F^L_{i+1/2} = a * q_i\n        # Flux F^L_{i-1/2} = a * q_{i-1} -> roll(q_n, 1)\n        flux_diff = a * (q_n - roll(q_n, 1))\n    else:  # a  0\n        # Flux F^L_{i+1/2} = a * q_{i+1} -> roll(q_n, -1)\n        # Flux F^L_{i-1/2} = a * q_i\n        flux_diff = a * (roll(q_n, -1) - q_n)\n    \n    q_L = q_n - (dt / dx) * flux_diff\n\n    # 3. Anti-Diffusive Flux Calculation\n    # A_{i+1/2} = |a|/2 * (1-C) * (q_{i+1} - q_i)\n    # A_{i+1/2} is defined at interfaces, so we calculate it for all N interfaces\n    q_ip1 = roll(q_n, -1)\n    A_ip12 = (abs(a) / 2.0) * (1.0 - C) * (q_ip1 - q_n)\n    \n    # 4. Flux Limiting (Zalesak, 1979)\n    \n    # a. Define Local Bounds\n    q_im1 = roll(q_n, 1) # q_{i-1} for all i\n    Q_max = np.minimum(1.0, np.maximum(np.maximum(q_im1, q_n), q_ip1))\n    Q_min = np.maximum(0.0, np.minimum(np.minimum(q_im1, q_n), q_ip1))\n    \n    # b. Calculate Cell Capacities (as mass)\n    M_plus = (Q_max - q_L) * dx\n    M_minus = (q_L - Q_min) * dx\n    \n    # c. Sum Raw Fluxes (as mass)\n    # Fluxes for cell i are A_{i-1/2} and A_{i+1/2}\n    # A_{i-1/2} for all i is roll(A_ip12, 1)\n    A_im12 = roll(A_ip12, 1)\n    \n    P_plus = dt * (np.maximum(0, A_im12) - np.minimum(0, A_ip12))\n    P_minus = dt * (np.maximum(0, A_ip12) - np.minimum(0, A_im12))\n\n    # d. Determine Correction Ratios\n    # Use np.divide to handle division by zero safely\n    R_plus = np.divide(M_plus, P_plus, out=np.ones_like(P_plus), where=P_plus > 1e-15)\n    R_plus = np.minimum(1.0, R_plus)\n\n    R_minus = np.divide(M_minus, P_minus, out=np.ones_like(P_minus), where=P_minus > 1e-15)\n    R_minus = np.minimum(1.0, R_minus)\n\n    # e. Limit Each Flux\n    # Flux A_{i+1/2} affects cells i and i+1\n    # R_plus for cell i+1 is roll(R_plus, -1)\n    # R_minus for cell i+1 is roll(R_minus, -1)\n    R_plus_ip1 = roll(R_plus, -1)\n    R_minus_ip1 = roll(R_minus, -1)\n    \n    # Correction factor alpha_{i+1/2}\n    alpha = np.ones_like(A_ip12)\n    # Case A_{i+1/2} > 0: donor is i, receiver is i+1\n    # alpha_{i+1/2} = min(R_i^-, R_{i+1}^+)\n    positive_flux_mask = A_ip12 > 0\n    alpha[positive_flux_mask] = np.minimum(R_minus[positive_flux_mask], R_plus_ip1[positive_flux_mask])\n    \n    # Case A_{i+1/2}  0: donor is i+1, receiver is i\n    # alpha_{i+1/2} = min(R_i^+, R_{i+1}^-)\n    negative_flux_mask = A_ip12  0\n    alpha[negative_flux_mask] = np.minimum(R_plus[negative_flux_mask], R_minus_ip1[negative_flux_mask])\n\n    A_c_ip12 = alpha * A_ip12\n    \n    # 5. Final Update (Anti-Diffusion)\n    # Corrected fluxes at i-1/2 interface\n    A_c_im12 = roll(A_c_ip12, 1)\n    q_new = q_L - (dt / dx) * (A_c_ip12 - A_c_im12)\n    \n    # 6. Diagnostics\n    overshoot = max(np.max(q_new) - 1.0, 0.0)\n    undershoot = max(0.0 - np.min(q_new), 0.0)\n    total_variation = np.sum(np.abs(roll(q_new, -1) - q_new))\n    \n    return overshoot, undershoot, total_variation\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, a, C, intervals)\n        (200, 1.0, 1.0, 0.5, [(0.4, 0.6)]),\n        (200, 1.0, 1.0, 0.5, [(0.9, 1.0), (0.0, 0.1)]),\n        (200, 1.0, 1.0, 0.95, [(0.25, 0.35)]),\n        (200, 1.0, -1.0, 0.7, [(0.5, 0.7)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, a, C, raw_intervals = case\n        # Scale intervals by L\n        intervals = [(start * L, end * L) for start, end in raw_intervals]\n        \n        overshoot, undershoot, tv = run_fct_step(N, L, a, C, intervals)\n        results.extend([overshoot, undershoot, tv])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}