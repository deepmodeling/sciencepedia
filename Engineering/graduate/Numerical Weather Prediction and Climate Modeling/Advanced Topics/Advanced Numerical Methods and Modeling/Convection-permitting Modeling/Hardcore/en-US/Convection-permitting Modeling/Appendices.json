{
    "hands_on_practices": [
        {
            "introduction": "Convection-permitting models (CPMs) are fundamentally non-hydrostatic, a crucial feature that allows them to simulate small-scale, intense weather phenomena. This practice explores the physical justification for this non-hydrostatic approach by focusing on convective cold pools, which are driven by pressure gradients that hydrostatic models cannot represent. By applying scale analysis to the Boussinesq momentum equations, you will quantify the misrepresentation of these essential dynamics, building a first-principles understanding of the limitations of hydrostatic models .",
            "id": "4025935",
            "problem": "Cold-pool outflows in convection-permitting modeling of Numerical Weather Prediction (NWP) are driven by horizontal pressure gradients associated with nonhydrostatic dynamics, while hydrostatic models enforce vertical pressure balance that filters those dynamic perturbations. Consider an idealized, dry, inviscid, Boussinesq cold pool of depth $H$ and a near-surface horizontal outflow with characteristic speed $U$. The reference density is $\\rho_{0}$, gravitational acceleration is $g$, and pressure perturbations relative to a horizontally homogeneous environment are denoted by $p'$. \n\nStarting from the inviscid Boussinesq momentum equations,\n$$\n\\rho_{0}\\,\\frac{D u}{D t} = -\\frac{\\partial p'}{\\partial x}, \\quad\n\\rho_{0}\\,\\frac{D w}{D t} = -\\frac{\\partial p'}{\\partial z} + \\rho'\\,g,\n$$\nand the hydrostatic approximation for hydrostatic models,\n$$\n\\frac{\\partial p}{\\partial z} \\approx -\\rho\\,g,\n$$\nderive, by scale analysis, the characteristic magnitude of the nonhydrostatic dynamic pressure perturbation $p'$ that balances horizontal advective acceleration in the outflow, and compare it to the hydrostatic pressure variation across the cold-pool depth $H$. Define the hydrostatic misrepresentation ratio\n$$\nE \\equiv \\frac{\\text{dynamic pressure scale}}{\\text{hydrostatic pressure variation across }H}.\n$$\nAssume that the dominant horizontal pressure-gradient–advection balance occurs over a horizontal length scale comparable to the cold pool depth, and take $U=10\\ \\mathrm{m\\,s^{-1}}$, $H=500\\ \\mathrm{m}$, and $g=9.81\\ \\mathrm{m\\,s^{-2}}$. \n\nCompute $E$ and express it as a pure number. Round your answer to four significant figures.",
            "solution": "The goal is to quantify how a hydrostatic model misrepresents the pressure perturbations associated with a cold-pool outflow, by comparing a nonhydrostatic dynamic pressure scale to the hydrostatic pressure variation across the cold-pool depth. We begin from first principles using the inviscid Boussinesq momentum equations as the fundamental base.\n\nFor the horizontal momentum,\n$$\n\\rho_{0}\\,\\frac{D u}{D t} = -\\frac{\\partial p'}{\\partial x}.\n$$\nIn the outflow, the characteristic horizontal advective acceleration scales as\n$$\n\\frac{D u}{D t} \\sim \\frac{U^{2}}{L},\n$$\nwhere $L$ is a characteristic horizontal length scale over which the outflow decelerates or accelerates. For density currents such as cold pools, the frontal thickness is typically of order the cold-pool depth, so we take $L \\sim H$ as a leading-order estimate. The pressure-gradient term scales as $\\partial p'/\\partial x \\sim p'/L$. Equating the two sides at leading order gives\n$$\n\\rho_{0}\\,\\frac{U^{2}}{L} \\sim \\frac{p'}{L} \\quad \\Rightarrow \\quad p' \\sim \\rho_{0}\\,U^{2}.\n$$\nThis provides the characteristic magnitude of the nonhydrostatic dynamic pressure perturbation associated with the outflow.\n\nNext, we consider the hydrostatic vertical pressure variation across the cold-pool depth. Under hydrostatic balance,\n$$\n\\frac{\\partial p}{\\partial z} \\approx -\\rho\\,g,\n$$\nso the hydrostatic pressure change over a depth $H$ is\n$$\n\\Delta p_{\\mathrm{hyd}} \\sim \\rho_{0}\\, g\\, H,\n$$\nusing the Boussinesq approximation with $\\rho \\approx \\rho_{0}$ as the leading-order density.\n\nWe define the hydrostatic misrepresentation ratio\n$$\nE \\equiv \\frac{p'}{\\Delta p_{\\mathrm{hyd}}}.\n$$\nSubstituting the two scales obtained above,\n$$\nE \\sim \\frac{\\rho_{0}\\,U^{2}}{\\rho_{0}\\,g\\,H} = \\frac{U^{2}}{g\\,H}.\n$$\nThis dimensionless ratio quantifies the relative magnitude of the nonhydrostatic dynamic pressure perturbation to the hydrostatic pressure variation across the depth and is equivalent to the square of the internal Froude number associated with the flow.\n\nNow we evaluate with the given values $U=10\\ \\mathrm{m\\,s^{-1}}$, $H=500\\ \\mathrm{m}$, and $g=9.81\\ \\mathrm{m\\,s^{-2}}$:\n$$\nE = \\frac{U^{2}}{g\\,H} = \\frac{10^{2}}{9.81 \\times 500} = \\frac{100}{4905}.\n$$\nCarrying out the division,\n$$\nE \\approx 0.020387\\ldots\n$$\nRounding to four significant figures gives\n$$\nE \\approx 0.02039.\n$$\nThis value indicates that the dynamic pressure perturbation driving the outflow is about $2.039 \\times 10^{-2}$ of the hydrostatic pressure variation across the cold-pool depth, providing a quantitative measure of hydrostatic misrepresentation for the specified cold-pool parameters.",
            "answer": "$$\\boxed{0.02039}$$"
        },
        {
            "introduction": "Having established the physical necessity of non-hydrostatic dynamics, we turn to the practical challenges of numerical implementation. The stability of a numerical model is paramount, and it is governed by the relationship between the time step ($\\Delta t$), grid spacing ($h$), and the characteristic speeds of the system. This exercise provides hands-on practice in analyzing the numerical stability of a common scheme, requiring you to derive the stability criterion for a Runge-Kutta time-stepping method and apply it to determine a safe time step for a given advection problem .",
            "id": "4025927",
            "problem": "In convection-permitting numerical weather prediction, consider one-dimensional linear advection for a prognostic tracer as a proxy for a semi-Lagrangian transported variable in a fully Eulerian, compressible model. The governing equation is the linear advection equation $u_{t} + U u_{x} = 0$ on a uniform grid with spacing $h$. Assume a spatial semi-discretization by the second-order centered finite difference for $u_{x}$ on a periodic domain, and a time integration by an explicit three-stage, third-order Runge–Kutta (RK) method. Let the Courant number be defined as $C = U \\Delta t / h$.\n\nTasks:\n- Starting from the Fourier analysis of the semi-discrete operator for the second-order centered difference and the linear test equation $y' = \\lambda y$, derive the scalar amplification factor $R(z)$ of the explicit three-stage, third-order Runge–Kutta method, where $z = \\lambda \\Delta t$.\n- Determine the condition on the imaginary-axis parameter $y$ in $z = \\mathrm{i} y$ under which the absolute stability condition $\\lvert R(\\mathrm{i} y) \\rvert \\le 1$ holds. Then, translate this condition into a bound on the Courant number $C$ for the centered-difference spatial discretization of linear advection.\n- With wind speed $U = 20\\ \\mathrm{m\\,s^{-1}}$ and grid spacing $h = 1\\ \\mathrm{km}$, choose the time step $\\Delta t$ corresponding to a target Courant number $C = 0.5$. Express the final value of $\\Delta t$ in seconds and round your answer to four significant figures.",
            "solution": "The problem is validated and deemed to be a self-contained, scientifically grounded, and well-posed problem in numerical analysis as applied to geophysical fluid dynamics. The solution proceeds by addressing the three tasks in the order presented.\n\nThe governing equation is the one-dimensional linear advection equation for a tracer concentration $u(x,t)$:\n$$ u_{t} + U u_{x} = 0 $$\nwhere $u_t = \\frac{\\partial u}{\\partial t}$ and $u_x = \\frac{\\partial u}{\\partial x}$. The equation is discretized on a uniform grid with spacing $h$ and integrated in time with a step $\\Delta t$.\n\n### Part 1: Derivation of the Amplification Factor $R(z)$\nThe problem specifies a time integration by an explicit three-stage, third-order Runge–Kutta (RK) method. To derive the amplification factor $R(z)$, we apply the numerical method to the linear test equation $y' = \\lambda y$, where $\\lambda$ is a complex constant. The exact solution evolves as $y(t_{n+1}) = y(t_n) \\exp(\\lambda \\Delta t)$.\n\nA numerical method of order $p$ provides an approximation $y_{n+1} = R(\\lambda \\Delta t) y_n$. For the method to be $p$-th order accurate, its amplification factor $R(z)$ must match the Taylor series expansion of $\\exp(z)$ up to and including the term of order $p$. Here, $z = \\lambda \\Delta t$.\n\nThe Taylor expansion of the exponential function is:\n$$ \\exp(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} + \\dots $$\nFor a third-order method ($p=3$), the amplification factor $R(z)$ must be identical to the first four terms of this series. Therefore, the scalar amplification factor for any explicit third-order RK method is:\n$$ R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 $$\n\n### Part 2: Stability Condition and Bound on the Courant Number\nFirst, we analyze the spatial semi-discretization. The partial derivative $u_x$ is approximated by a second-order centered finite difference at grid point $j$:\n$$ u_x \\approx \\frac{u_{j+1} - u_{j-1}}{2h} $$\nSubstituting this into the advection equation yields a system of ordinary differential equations (ODEs), one for each grid point $u_j(t)$:\n$$ \\frac{du_j}{dt} + U \\left( \\frac{u_{j+1} - u_{j-1}}{2h} \\right) = 0 \\implies \\frac{du_j}{dt} = - \\frac{U}{2h} (u_{j+1} - u_{j-1}) $$\nTo perform a von Neumann stability analysis, we consider a single Fourier mode solution $u_j(t) = \\hat{u}(t) \\exp(\\mathrm{i} k x_j)$, where $k$ is the wavenumber and $x_j = jh$. Substituting this into the semi-discrete equation gives:\n$$ \\frac{d\\hat{u}}{dt} \\exp(\\mathrm{i} kjh) = - \\frac{U}{2h} \\left[ \\hat{u}\\exp(\\mathrm{i}k(j+1)h) - \\hat{u}\\exp(\\mathrm{i}k(j-1)h) \\right] $$\nDividing by $\\hat{u} \\exp(\\mathrm{i} kjh)$:\n$$ \\frac{1}{\\hat{u}}\\frac{d\\hat{u}}{dt} = - \\frac{U}{2h} \\left[ \\exp(\\mathrm{i}kh) - \\exp(-\\mathrm{i}kh) \\right] $$\nUsing Euler's identity, $\\sin(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) - \\exp(-\\mathrm{i}\\theta)}{2\\mathrm{i}}$, the term in brackets becomes $2\\mathrm{i}\\sin(kh)$.\n$$ \\frac{d\\hat{u}}{dt} = \\left( - \\frac{U}{2h} [2\\mathrm{i}\\sin(kh)] \\right) \\hat{u} = \\left( - \\frac{\\mathrm{i} U \\sin(kh)}{h} \\right) \\hat{u} $$\nThis equation is of the form $\\frac{d\\hat{u}}{dt} = \\lambda \\hat{u}$, where the eigenvalue $\\lambda$ of the spatial operator for mode $k$ is purely imaginary:\n$$ \\lambda = - \\frac{\\mathrm{i} U \\sin(kh)}{h} $$\nThe argument of the amplification factor $R(z)$ is $z = \\lambda \\Delta t$:\n$$ z = \\left( - \\frac{\\mathrm{i} U \\sin(kh)}{h} \\right) \\Delta t = - \\mathrm{i} \\frac{U \\Delta t}{h} \\sin(kh) $$\nUsing the definition of the Courant number, $C = U \\Delta t / h$, we get:\n$$ z = - \\mathrm{i} C \\sin(kh) $$\nThis expression for $z$ is purely imaginary. We can write $z = \\mathrm{i}y$, where $y = -C \\sin(kh)$. The stability condition is $|R(z)| \\le 1$, which translates to $|R(\\mathrm{i}y)| \\le 1$. We substitute $z = \\mathrm{i}y$ into the expression for $R(z)$:\n$$ R(\\mathrm{i}y) = 1 + (\\mathrm{i}y) + \\frac{1}{2}(\\mathrm{i}y)^2 + \\frac{1}{6}(\\mathrm{i}y)^3 = 1 + \\mathrm{i}y - \\frac{1}{2}y^2 - \\frac{\\mathrm{i}}{6}y^3 $$\nGrouping the real and imaginary parts:\n$$ R(\\mathrm{i}y) = \\left(1 - \\frac{1}{2}y^2\\right) + \\mathrm{i}\\left(y - \\frac{1}{6}y^3\\right) $$\nThe squared magnitude is $|R(\\mathrm{i}y)|^2 = (\\mathrm{Re}[R(\\mathrm{i}y)])^2 + (\\mathrm{Im}[R(\\mathrm{i}y)])^2$:\n$$ |R(\\mathrm{i}y)|^2 = \\left(1 - \\frac{1}{2}y^2\\right)^2 + \\left(y - \\frac{1}{6}y^3\\right)^2 = \\left(1 - y^2 + \\frac{1}{4}y^4\\right) + \\left(y^2 - \\frac{1}{3}y^4 + \\frac{1}{36}y^6\\right) $$\n$$ |R(\\mathrm{i}y)|^2 = 1 + \\left(\\frac{1}{4} - \\frac{1}{3}\\right)y^4 + \\frac{1}{36}y^6 = 1 - \\frac{1}{12}y^4 + \\frac{1}{36}y^6 $$\nThe stability condition $|R(\\mathrm{i}y)|^2 \\le 1$ translates to:\n$$ 1 - \\frac{1}{12}y^4 + \\frac{1}{36}y^6 \\le 1 \\implies \\frac{1}{36}y^6 - \\frac{1}{12}y^4 \\le 0 $$\nFactoring out $\\frac{y^4}{36}$:\n$$ \\frac{y^4}{36} (y^2 - 3) \\le 0 $$\nSince $y^4 \\ge 0$, this inequality is satisfied if and only if $y^2 - 3 \\le 0$, which yields $y^2 \\le 3$. The condition on the imaginary-axis parameter $y$ is therefore:\n$$ |y| \\le \\sqrt{3} $$\nTo translate this into a bound on the Courant number $C$, we use $y = -C \\sin(kh)$:\n$$ |-C \\sin(kh)| \\le \\sqrt{3} \\implies C |\\sin(kh)| \\le \\sqrt{3} $$\nThis condition must hold for all wavenumbers $k$ present in the numerical solution. The stability of the scheme is determined by the most restrictive case, which occurs when $|\\sin(kh)|$ is at its maximum. The maximum value of $|\\sin(kh)|$ is $1$. Therefore, to ensure stability for all Fourier modes, we must have:\n$$ C \\le \\sqrt{3} $$\n\n### Part 3: Calculation of the Time Step $\\Delta t$\nThe problem provides the following parameters:\n- Wind speed: $U = 20\\ \\mathrm{m\\,s^{-1}}$\n- Grid spacing: $h = 1\\ \\mathrm{km} = 1000\\ \\mathrm{m}$\n- Target Courant number: $C = 0.5$\n\nThe selected Courant number $C = 0.5$ satisfies the stability condition $C \\le \\sqrt{3}$, as $\\sqrt{3} \\approx 1.732$. We can now calculate the corresponding time step $\\Delta t$ from the definition of the Courant number:\n$$ C = \\frac{U \\Delta t}{h} \\implies \\Delta t = \\frac{C h}{U} $$\nSubstituting the numerical values:\n$$ \\Delta t = \\frac{0.5 \\times 1000\\ \\mathrm{m}}{20\\ \\mathrm{m\\,s^{-1}}} = \\frac{500}{20}\\ \\mathrm{s} = 25\\ \\mathrm{s} $$\nThe problem asks for the result to be expressed in seconds and rounded to four significant figures.\n$$ \\Delta t = 25.00\\ \\mathrm{s} $$",
            "answer": "$$ \\boxed{25.00} $$"
        },
        {
            "introduction": "The ultimate test of a convection-permitting model is its ability to produce realistic forecasts of weather phenomena. Traditional verification scores can be misleading for high-resolution forecasts, as small spatial errors in otherwise accurate predictions are heavily penalized. This practice introduces a modern, object-based verification method that assesses model performance by identifying and comparing the characteristics of simulated and observed convective systems, providing a more physically meaningful evaluation of forecast quality .",
            "id": "4026010",
            "problem": "You are given two gridded intensity fields representing convective precipitation rates: one from a Convection-Permitting Model (CPM) and one from radar-derived observations. The model and radar fields share the same Cartesian grid spacing. Your task is to detect convective objects in each field using a threshold-based connected-component approach and compute object-based diagnostics. Then, perform a one-to-one matching between CPM and radar objects based on centroid distance to assess realism. Implement a complete program that carries out this workflow and returns quantitative metrics for a specified test suite.\n\nFundamental base and definitions:\n- A convective object is defined as a connected set of grid cells where the intensity $I(i,j)$ satisfies $I(i,j) \\ge T$, with $T$ a prescribed threshold. Use $8$-neighbor connectivity (each cell connected to its $8$ surrounding neighbors).\n- Let the grid spacing be uniform with $\\Delta x = \\Delta y$, in units of kilometers. Let the physical coordinates of grid point $(i,j)$ be $x_{i} = i \\Delta x$ and $y_{j} = j \\Delta y$, with origin $(x,y) = (0,0)$ at index $(i,j) = (0,0)$. Indices $i$ and $j$ are the column and row indices, respectively.\n- For each detected object $o$ (a set of indices $(i,j)$):\n  - Size $S(o)$ is the total area of the object, computed as $S(o) = N(o) \\Delta x \\Delta y$, where $N(o)$ is the count of grid cells in $o$. Report $S(o)$ in $\\mathrm{km}^2$.\n  - Peak intensity $P(o)$ is the maximum local intensity over the object, $P(o) = \\max_{(i,j) \\in o} I(i,j)$. Report $P(o)$ in $\\mathrm{mm\\,h^{-1}}$.\n  - Geometric centroid $C(o)$ is $(x_c(o),y_c(o))$ with\n    $$\n    x_c(o) = \\frac{1}{N(o)} \\sum_{(i,j) \\in o} x_i, \\quad\n    y_c(o) = \\frac{1}{N(o)} \\sum_{(i,j) \\in o} y_j.\n    $$\n- Matching rule: Given the set of CPM objects $\\{o^M_k\\}$ and radar objects $\\{o^R_\\ell\\}$, construct the pairwise Euclidean distance matrix $D_{k\\ell} = \\lVert C(o^M_k) - C(o^R_\\ell) \\rVert_2$. Perform a minimum-cost one-to-one assignment that minimizes the total sum of distances. Accept matches only if the distance is less than or equal to a prescribed maximum $D_{\\max}$; discard pairs that exceed this threshold.\n- Realism metrics over accepted matches:\n  - Fraction matched $F = \\dfrac{N_{\\text{matched}}}{\\max(N_M, N_R)}$, where $N_{\\text{matched}}$ is the number of accepted matches, $N_M$ is the number of CPM objects, and $N_R$ is the number of radar objects. If $N_M = N_R = 0$, define $F = 1$.\n  - Mean absolute size difference $\\overline{\\Delta S} = \\dfrac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} | S(o^M) - S(o^R) |$, reported in $\\mathrm{km}^2$. If $N_{\\text{matched}} = 0$, define $\\overline{\\Delta S} = 0$.\n  - Mean absolute peak intensity difference $\\overline{\\Delta P} = \\dfrac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} | P(o^M) - P(o^R) |$, reported in $\\mathrm{mm\\,h^{-1}}$. If $N_{\\text{matched}} = 0$, define $\\overline{\\Delta P} = 0$.\n  - Mean centroid distance $\\overline{d} = \\dfrac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} \\lVert C(o^M) - C(o^R) \\rVert_2$, reported in kilometers. If $N_{\\text{matched}} = 0$, define $\\overline{d} = 0$.\n\nImplement the above using the following parameters and test suite. All intensities are in millimeters per hour ($\\mathrm{mm\\,h^{-1}}$); distances are in kilometers; areas are in $\\mathrm{km}^2$.\n\nGlobal parameters:\n- Threshold $T = 10$.\n- Grid spacing $\\Delta x = \\Delta y = 2$.\n- Maximum match distance $D_{\\max} = 5$.\n\nTest suite of four cases, each case specifying $(I_M, I_R)$, two $6 \\times 6$ arrays:\n\nCase $1$ (happy path; two similar objects):\n- $I_M =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 12 & 14 & 0 & 0 \\\\\n  0 & 0 & 11 & 13 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 20 & 21 & 0 & 0 & 0 \\\\\n  0 & 18 & 22 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0\n  \\end{bmatrix}\n  $\n- $I_R =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 13 & 15 & 0 & 0 \\\\\n  0 & 0 & 12 & 16 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 19 & 20 & 0 & 0 & 0 \\\\\n  0 & 18 & 23 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0\n  \\end{bmatrix}\n  $\n\nCase $2$ (CPM splitting versus radar merging):\n- $I_M =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 11 & 0 & 0 & 0 \\\\\n  0 & 0 & 12 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 14 & 15 & 0 \\\\\n  0 & 0 & 0 & 13 & 16 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0\n  \\end{bmatrix}\n  $\n- $I_R =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 11 & 12 & 0 & 0 \\\\\n  0 & 0 & 12 & 13 & 0 & 0 \\\\\n  0 & 0 & 11 & 14 & 15 & 0 \\\\\n  0 & 0 & 0 & 13 & 16 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0\n  \\end{bmatrix}\n  $\n\nCase $3$ (no objects in either field):\n- $I_M =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0\n  \\end{bmatrix}\n  $\n- $I_R =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0\n  \\end{bmatrix}\n  $\n\nCase $4$ (radar has an extra object not present in CPM):\n- $I_M =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  11 & 12 & 0 & 0 & 17 & 0 \\\\\n  13 & 14 & 0 & 0 & 18 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0\n  \\end{bmatrix}\n  $\n- $I_R =$\n  $\n  \\begin{bmatrix}\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  10 & 13 & 0 & 0 & 18 & 0 \\\\\n  12 & 15 & 0 & 0 & 19 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 16 & 17 & 18\n  \\end{bmatrix}\n  $\n\nYour program must:\n- Detect CPM and radar objects using the above definitions and parameters.\n- Compute $S(o)$, $P(o)$, and $C(o)$ for each object.\n- Perform minimum-cost matching subject to the $D_{\\max}$ criterion.\n- Compute the realism metrics $F$, $\\overline{\\Delta S}$ (in $\\mathrm{km}^2$), $\\overline{\\Delta P}$ (in $\\mathrm{mm\\,h^{-1}}$), and $\\overline{d}$ (in $\\mathrm{km}$) for each test case.\n- Aggregate the results for all test cases in a single line of output containing a comma-separated list enclosed in square brackets, where each test case’s result is itself a list in the order $[F,\\overline{\\Delta S},\\overline{\\Delta P},\\overline{d}]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[\\dots],[\\dots],[\\dots],[\\dots]]$), with each inner list ordered as $[F,\\overline{\\Delta S},\\overline{\\Delta P},\\overline{d}]$.",
            "solution": "The user has provided a well-defined problem in the domain of numerical weather prediction verification. A critical assessment confirms its validity.\n\n### Step 1: Extract Givens\n- **Fields**: Convection-Permitting Model (CPM) intensity field $I_M$ and radar-derived observation intensity field $I_R$.\n- **Grid**: Uniform Cartesian grid with spacing $\\Delta x = \\Delta y$. The physical coordinates of a grid point at column index $i$ and row index $j$ are $(x_i, y_j)$, where $x_i = i \\Delta x$ and $y_j = j \\Delta y$. The origin $(x,y)=(0,0)$ corresponds to index $(i,j)=(0,0)$.\n- **Object Definition**: A convective object is a connected set of grid cells where the intensity $I(i,j)$ is greater than or equal to a threshold $T$. Connectivity is defined by the $8$ surrounding neighbors (Moore neighborhood).\n- **Object Attributes**: For an object $o$ comprising $N(o)$ grid cells:\n  - Size: $S(o) = N(o) \\Delta x \\Delta y$, in $\\mathrm{km}^2$.\n  - Peak Intensity: $P(o) = \\max_{(i,j) \\in o} I(i,j)$, in $\\mathrm{mm\\,h^{-1}}$.\n  - Geometric Centroid: $C(o) = (x_c(o), y_c(o))$, where $x_c(o) = \\frac{1}{N(o)} \\sum_{(i,j) \\in o} x_i$ and $y_c(o) = \\frac{1}{N(o)} \\sum_{(i,j) \\in o} y_j$.\n- **Matching**: Given CPM objects $\\{o^M_k\\}$ and radar objects $\\{o^R_\\ell\\}$, a one-to-one assignment is found by minimizing the total sum of pairwise Euclidean centroid distances, $D_{k\\ell} = \\lVert C(o^M_k) - C(o^R_\\ell) \\rVert_2$. A match is accepted only if its distance is less than or equal to a maximum distance $D_{\\max}$.\n- **Realism Metrics**:\n  - Fraction Matched: $F = N_{\\text{matched}} / \\max(N_M, N_R)$, where $N_{\\text{matched}}$ is the count of accepted matches, $N_M$ is the number of CPM objects, and $N_R$ is the number of radar objects. If $N_M = N_R = 0$, then $F = 1$.\n  - Mean Absolute Size Difference: $\\overline{\\Delta S} = \\frac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} | S(o^M) - S(o^R) |$. For $N_{\\text{matched}} = 0$, $\\overline{\\Delta S} = 0$.\n  - Mean Absolute Peak Intensity Difference: $\\overline{\\Delta P} = \\frac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} | P(o^M) - P(o^R) |$. For $N_{\\text{matched}} = 0$, $\\overline{\\Delta P} = 0$.\n  - Mean Centroid Distance: $\\overline{d} = \\frac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} \\lVert C(o^M) - C(o^R) \\rVert_2$. For $N_{\\text{matched}} = 0$, $\\overline{d} = 0$.\n- **Global Parameters**:\n  - Threshold $T = 10\\ \\mathrm{mm\\,h^{-1}}$.\n  - Grid spacing $\\Delta x = 2\\ \\mathrm{km}$, $\\Delta y = 2\\ \\mathrm{km}$.\n  - Maximum match distance $D_{\\max} = 5\\ \\mathrm{km}$.\n- **Test Suite**: Four test cases, each defined by a pair of $6 \\times 6$ matrices for $I_M$ and $I_R$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed to be **valid**.\n- **Scientifically Grounded**: The problem describes a standard object-based verification methodology used in meteorology to evaluate high-resolution precipitation forecasts. All concepts are standard in data analysis and image processing.\n- **Well-Posed**: The problem is computationally well-posed. The inputs, parameters, algorithmic steps, and output format are all specified unambiguously. The definitions for edge cases (e.g., no objects, no matches) ensure a unique and stable solution can always be computed.\n- **Objective**: The problem is stated using formal mathematical definitions and precise, unbiased language.\n- **Completeness and Consistency**: All necessary data and parameters ($I_M, I_R, T, \\Delta x, \\Delta y, D_{\\max}$) are provided. Definitions are internally consistent.\n- **Realism and Feasibility**: The physical context, parameter values, and grid data are plausible for the specified application. The problem is computationally feasible.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete, reasoned solution will be provided.\n\n### Solution\n\nThe solution implements a systematic, object-based verification workflow. This approach evaluates forecast quality by comparing the properties of discrete phenomena (convective objects) rather than by performing a point-wise comparison of the entire fields. The process is partitioned into four primary stages: object identification, attribute calculation, object matching, and metric computation.\n\n**1. Object Identification**\n\nFor each intensity field, $I_M$ and $I_R$, objects are identified through a two-step process. First, a binary mask is created by applying the intensity threshold $T$. A grid cell at location $(i,j)$ is considered part of a potential object if its intensity $I(i,j) \\ge T$. Let this binary field be $B(i,j)$.\n$$\nB(i,j) = \\begin{cases} 1 & \\text{if } I(i,j) \\ge T \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nSecond, a connected-component labeling algorithm is applied to the binary field $B$. The problem specifies $8$-connectivity, meaning a cell is connected to its eight immediate neighbors (horizontally, vertically, and diagonally). This algorithm partitions the set of all cells where $B(i,j) = 1$ into disjoint subsets, each constituting a distinct object. Each object is assigned a unique integer label. The number of unique labels found corresponds to the total number of objects in the field ($N_M$ for the model, $N_R$ for the radar).\n\n**2. Object Attribute Calculation**\n\nFor each identified object $o$, a set of physical attributes is computed. An object $o_k$ is represented by the set of grid indices $\\{(i,j)\\}$ that share the label $k$.\n\n- **Size ($S$)**: The size of an object is its physical area. It is calculated by multiplying the number of grid cells in the object, $N(o_k)$, by the area of a single grid cell, $\\Delta x \\Delta y$.\n  $$\n  S(o_k) = N(o_k) \\cdot \\Delta x \\cdot \\Delta y\n  $$\n  Given $\\Delta x = \\Delta y = 2 \\ \\mathrm{km}$, the area of one cell is $4 \\ \\mathrm{km}^2$.\n\n- **Peak Intensity ($P$)**: The peak intensity is the maximum intensity value found within the original, non-thresholded field $I$ over all cells belonging to the object.\n  $$\n  P(o_k) = \\max_{(i,j) \\in o_k} I(i,j)\n  $$\n\n- **Geometric Centroid ($C$)**: The centroid represents the object's center of mass, assuming uniform density. It is the arithmetic mean of the physical coordinates of all cells in the object. For an object $o_k$ with constituent cell indices $\\{(i_m, j_m)\\}_{m=1}^{N(o_k)}$, the centroid $(x_c(o_k), y_c(o_k))$ is:\n  $$\n  x_c(o_k) = \\frac{1}{N(o_k)} \\sum_{(i,j) \\in o_k} x_i = \\frac{\\Delta x}{N(o_k)} \\sum_{(i,j) \\in o_k} i\n  $$\n  $$\n  y_c(o_k) = \\frac{1}{N(o_k)} \\sum_{(i,j) \\in o_k} y_j = \\frac{\\Delta y}{N(o_k)} \\sum_{(i,j) \\in o_k} j\n  $$\n  Here, $i$ and $j$ are the column and row indices, respectively, as defined in the problem.\n\n**3. Object Matching**\n\nThis stage establishes a correspondence between the model objects $\\{o^M_k\\}$ and radar objects $\\{o^R_\\ell\\}$. This is formulated as a minimum-cost assignment problem.\n\n- **Cost Matrix**: An $N_M \\times N_R$ cost matrix, $D$, is constructed. The element $D_{k\\ell}$ is the Euclidean distance between the centroid of the $k$-th model object and the $\\ell$-th radar object.\n  $$\n  D_{k\\ell} = \\lVert C(o^M_k) - C(o^R_\\ell) \\rVert_2 = \\sqrt{(x_c(o^M_k) - x_c(o^R_\\ell))^2 + (y_c(o^M_k) - y_c(o^R_\\ell))^2}\n  $$\n\n- **Optimal Assignment**: The goal is to find a set of one-to-one pairs $(k, \\ell)$ that minimizes the sum of distances $\\sum D_{k\\ell}$. This is a classic linear sum assignment problem, which can be solved efficiently by the Hungarian algorithm. The algorithm finds the optimal pairing of rows (model objects) to columns (radar objects), or vice-versa, depending on which set is smaller.\n\n- **Filtering**: The resulting optimal pairs are filtered based on a distance criterion. A pair is considered a valid match only if its centroid distance is within a specified maximum, $D_{k\\ell} \\le D_{\\max}$. Pairs with distances exceeding $D_{\\max}$ are discarded. The number of remaining pairs is $N_{\\text{matched}}$.\n\n**4. Metric Computation**\n\nFinally, a set of summary metrics is computed based on the accepted matches to quantify the model's realism.\n\n- **Fraction Matched ($F$)**: This metric quantifies the degree of spatial correspondence. It is the ratio of the number of matched objects to the total number of objects, normalized by the larger of $N_M$ or $N_R$ to penalize both misses and false alarms.\n  $$\n  F = \\frac{N_{\\text{matched}}}{\\max(N_M, N_R)}\n  $$\n  The rules specify $F=1$ if $N_M=N_R=0$, and $F$ is calculated as above otherwise.\n\n- **Mean Attribute Differences ($\\overline{\\Delta S}, \\overline{\\Delta P}$)**: These metrics assess the bias in object properties. They are the average absolute differences in size and peak intensity over all matched pairs.\n  $$\n  \\overline{\\Delta S} = \\frac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} |S(o^M) - S(o^R)|\n  $$\n  $$\n  \\overline{\\Delta P} = \\frac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} |P(o^M) - P(o^R)|\n  $$\n  If $N_{\\text{matched}} = 0$, both metrics are defined to be $0$.\n\n- **Mean Centroid Distance ($\\overline{d}$)**: This metric measures the average location error for matched objects.\n  $$\n  \\overline{d} = \\frac{1}{N_{\\text{matched}}} \\sum_{\\text{matched pairs}} \\lVert C(o^M) - C(o^R) \\rVert_2\n  $$\n  If $N_{\\text{matched}} = 0$, this metric is also defined to be $0$.\n\nThis comprehensive procedure transforms a complex field-to-field comparison into a digestible set of quantitative scores, providing insights into the model's ability to reproduce the location, size, and intensity of observed convective systems.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, maximum, sum as ndimage_sum\nfrom scipy.optimize import linear_sum_assignment\n\nclass ConvectiveObject:\n    \"\"\"A class to store attributes of a detected convective object.\"\"\"\n    def __init__(self, size_km2, peak_intensity, centroid_km):\n        self.size = size_km2\n        self.peak = peak_intensity\n        self.centroid = centroid_km\n\ndef analyze_field(intensity_field, threshold, dx, dy):\n    \"\"\"\n    Detects convective objects in an intensity field and calculates their properties.\n    \"\"\"\n    # 1. Object Identification\n    # Create a binary mask using the threshold\n    mask = intensity_field >= threshold\n    # Define 8-connectivity structure\n    structure = np.ones((3, 3), dtype=int)\n    # Perform connected-component labeling\n    labeled_array, num_objects = label(mask, structure=structure)\n    \n    if num_objects == 0:\n        return []\n\n    # Get object indices using a more efficient method\n    object_indices = np.arange(1, num_objects + 1)\n    \n    # 2. Attribute Calculation\n    # Calculate cell count (N) for each object\n    cell_counts = ndimage_sum(mask, labeled_array, index=object_indices)\n    \n    # Calculate Size (S)\n    cell_area = dx * dy\n    sizes = cell_counts * cell_area\n\n    # Calculate Peak Intensity (P)\n    peak_intensities = maximum(intensity_field, labeled_array, index=object_indices)\n\n    # Calculate Geometric Centroid (C)\n    # Create coordinate grids\n    rows, cols = intensity_field.shape\n    grid_y, grid_x = np.meshgrid(np.arange(rows), np.arange(cols), indexing='ij')\n    \n    # Sum of coordinates for each object\n    sum_x_coords = ndimage_sum(grid_x, labeled_array, index=object_indices)\n    sum_y_coords = ndimage_sum(grid_y, labeled_array, index=object_indices)\n    \n    # Mean coordinates (in grid index units)\n    centroid_x_indices = sum_x_coords / cell_counts\n    centroid_y_indices = sum_y_coords / cell_counts\n    \n    # Convert to physical coordinates (km)\n    centroid_x_km = centroid_x_indices * dx\n    centroid_y_km = centroid_y_indices * dy\n    \n    # Create and return a list of ConvectiveObject instances\n    objects = []\n    for i in range(num_objects):\n        centroid = np.array([centroid_x_km[i], centroid_y_km[i]])\n        obj = ConvectiveObject(sizes[i], peak_intensities[i], centroid)\n        objects.append(obj)\n        \n    return objects\n\n\ndef calculate_metrics(I_M, I_R, T, dx, dy, D_max):\n    \"\"\"\n    Performs the full object-based analysis and computes realism metrics for one case.\n    \"\"\"\n    model_objects = analyze_field(I_M, T, dx, dy)\n    radar_objects = analyze_field(I_R, T, dx, dy)\n    \n    N_M = len(model_objects)\n    N_R = len(radar_objects)\n\n    # Handle case with no objects\n    if N_M == 0 and N_R == 0:\n        return [1.0, 0.0, 0.0, 0.0]\n\n    # Handle cases where one or both fields have no objects\n    if N_M == 0 or N_R == 0:\n        F = 0.0\n        return [F, 0.0, 0.0, 0.0]\n\n    # 3. Object Matching\n    # Construct the cost matrix of centroid distances\n    cost_matrix = np.zeros((N_M, N_R))\n    for i, m_obj in enumerate(model_objects):\n        for j, r_obj in enumerate(radar_objects):\n            dist = np.linalg.norm(m_obj.centroid - r_obj.centroid)\n            cost_matrix[i, j] = dist\n\n    # Solve the linear sum assignment problem\n    row_ind, col_ind = linear_sum_assignment(cost_matrix)\n    \n    # Filter matches based on D_max\n    matched_pairs = []\n    for i, j in zip(row_ind, col_ind):\n        if cost_matrix[i, j] <= D_max:\n            matched_pairs.append({\n                'model_obj': model_objects[i],\n                'radar_obj': radar_objects[j],\n                'distance': cost_matrix[i, j]\n            })\n\n    N_matched = len(matched_pairs)\n\n    # 4. Metric Computation\n    # Fraction Matched (F)\n    F = N_matched / max(N_M, N_R)\n\n    # Other metrics (if there are matches)\n    if N_matched == 0:\n        return [F, 0.0, 0.0, 0.0]\n    \n    delta_S_vals = [abs(p['model_obj'].size - p['radar_obj'].size) for p in matched_pairs]\n    delta_P_vals = [abs(p['model_obj'].peak - p['radar_obj'].peak) for p in matched_pairs]\n    dist_vals = [p['distance'] for p in matched_pairs]\n\n    mean_delta_S = sum(delta_S_vals) / N_matched\n    mean_delta_P = sum(delta_P_vals) / N_matched\n    mean_dist = sum(dist_vals) / N_matched\n    \n    return [F, mean_delta_S, mean_delta_P, mean_dist]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Global parameters\n    T = 10.0\n    dx = 2.0\n    dy = 2.0\n    D_max = 5.0\n\n    # Test suite\n    test_cases = [\n        # Case 1\n        (np.array([\n            [0, 0, 12, 14, 0, 0],\n            [0, 0, 11, 13, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 20, 21, 0, 0, 0],\n            [0, 18, 22, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]\n        ]), np.array([\n            [0, 0, 13, 15, 0, 0],\n            [0, 0, 12, 16, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 19, 20, 0, 0, 0],\n            [0, 18, 23, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]\n        ])),\n        # Case 2\n        (np.array([\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 11, 0, 0, 0],\n            [0, 0, 12, 0, 0, 0],\n            [0, 0, 0, 14, 15, 0],\n            [0, 0, 0, 13, 16, 0],\n            [0, 0, 0, 0, 0, 0]\n        ]), np.array([\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 11, 12, 0, 0],\n            [0, 0, 12, 13, 0, 0],\n            [0, 0, 11, 14, 15, 0],\n            [0, 0, 0, 13, 16, 0],\n            [0, 0, 0, 0, 0, 0]\n        ])),\n        # Case 3\n        (np.array([\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]\n        ]), np.array([\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]\n        ])),\n        # Case 4\n        (np.array([\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [11, 12, 0, 0, 17, 0],\n            [13, 14, 0, 0, 18, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]\n        ]), np.array([\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [10, 13, 0, 0, 18, 0],\n            [12, 15, 0, 0, 19, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 16, 17, 18]\n        ]))\n    ]\n    \n    results = []\n    for I_M, I_R in test_cases:\n        result = calculate_metrics(I_M, I_R, T, dx, dy, D_max)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    inner_results_str = [','.join(map(str, r)) for r in results]\n    final_output_str = f\"[[{'],['.join(inner_results_str)}]]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}