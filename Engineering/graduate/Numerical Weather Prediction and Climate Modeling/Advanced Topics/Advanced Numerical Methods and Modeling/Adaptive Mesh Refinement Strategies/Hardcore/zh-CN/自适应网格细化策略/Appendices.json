{
    "hands_on_practices": [
        {
            "introduction": "许多物理模型的基石是守恒原理。当我们在数值模拟中使用自适应网格加密（AMR）时，确保像质量和能量这样的物理量在粗细网格界面上保持守恒至关重要。这个练习  通过要求您推导在省略通量修正（refluxing）时产生的质量误差的数学形式，提供了一个关键的洞见，从而证明了该技术在守恒型AMR方案中不可或缺的作用。",
            "id": "4008986",
            "problem": "考虑一个一维两层自适应网格加密（AMR）层次结构，该结构具有单个粗细网格界面（界面面积为 $A$）和不可穿透的外边界。设 $q(x,t)$ 是一个守恒标量密度，满足守恒律 $\\partial q / \\partial t + \\partial F(q) / \\partial x = 0$。该层次结构使用有限体积法（FVM）进行时间推进。粗网格层使用的时间步长为 $\\Delta t_{c}$，细网格层进行子循环，每个粗网格步长包含 $r$ 个细网格步长，即 $\\Delta t_{f} = \\Delta t_{c} / r$。记 $F_{c}$ 为一个粗网格步长内通过粗细网格界面的粗网格层数值通量，$\\bar{F}_{f}$ 为在同一粗网格时间间隔内平均的细网格层数值通量，其定义为 $\\bar{F}_{f} = \\frac{1}{\\Delta t_{c}} \\sum_{k=1}^{r} F_{f}^{(k)} \\Delta t_{f}$，其中 $F_{f}^{(k)}$ 是在子步长 $k$ 上的细网格通量。在本测试中，假设粗网格通量与细网格平均通量在每个粗网格步长相差一个恒定的偏移量，\n$$\nF_{c} = \\bar{F}_{f} + \\delta,\n$$\n其中 $\\delta$ 与时间步长索引无关。假设没有应用回流修正；也就是说，粗网格的更新不被细网格通量所修正。\n\n设 $M_{0}$ 表示在所有层级所有单元上求和的初始总质量，设 $M(n)$ 表示在无回流修正的 AMR 推进 $n$ 个粗网格步长后的总质量。将在 $n$ 个粗网格步长后的无量纲累积质量误差定义为\n$$\n\\epsilon(n) = \\frac{M(n) - M_{0}}{M_{0}}。\n$$\n\n在上述假设下，从守恒性和有限体积法通量平衡原理出发，推导一个关于 $n$、$\\delta$、$A$、$\\Delta t_{c}$ 和 $M_{0}$ 的 $\\epsilon(n)$ 的精确闭式表达式。您的最终答案必须是单一的解析表达式。不要代入数值。最终方框内的表达式中不要包含单位。如果引入任何角度，请以弧度表示。由于答案是纯符号形式，因此不需要四舍五入。",
            "solution": "用户希望我验证问题陈述，如果有效，则提供解答。\n\n### 第 1 步：提取已知条件\n- **系统**：一个具有不可穿透外边界的一维两层自适应网格加密（AMR）层次结构。\n- **界面**：一个面积为 $A$ 的单一粗细网格界面。\n- **控制方程**：一个守恒标量密度 $q(x,t)$ 满足守恒律 $\\frac{\\partial q}{\\partial t} + \\frac{\\partial F(q)}{\\partial x} = 0$。\n- **数值方法**：有限体积法（FVM）。\n- **时间步进**：粗网格层使用时间步长 $\\Delta t_{c}$。细网格层以加密比 $r$ 进行子循环，因此细网格时间步长为 $\\Delta t_{f} = \\frac{\\Delta t_{c}}{r}$。\n- **通量**：\n    - $F_{c}$ 是在一个粗网格步长 $\\Delta t_{c}$ 内通过界面的粗网格层数值通量。\n    - $F_{f}^{(k)}$ 是在子步长 $k$ 时通过界面的细网格层通量。\n    - $\\bar{F}_{f}$ 是在一个粗网格时间间隔内时间平均的细网格层通量，定义为 $\\bar{F}_{f} = \\frac{1}{\\Delta t_{c}} \\sum_{k=1}^{r} F_{f}^{(k)} \\Delta t_{f}$。\n- **通量不匹配**：粗网格通量和平均细网格通量通过 $F_{c} = \\bar{F}_{f} + \\delta$ 相关联，其中 $\\delta$ 是一个与时间步长索引无关的常数。\n- **AMR 算法细节**：不应用回流修正，意味着粗网格更新不使用细网格通量信息进行修正。\n- **质量定义**：\n    - $M_{0}$ 是系统中的初始总质量。\n    - $M(n)$ 是经过 $n$ 个粗网格步长后的总质量。\n- **误差定义**：$n$ 个粗网格步长后的无量纲累积质量误差为 $\\epsilon(n) = \\frac{M(n) - M_{0}}{M_{0}}$。\n- **目标**：推导 $\\epsilon(n)$ 关于 $n$、$\\delta$、$A$、$\\Delta t_{c}$ 和 $M_{0}$ 的精确闭式表达式。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n- **科学依据**：是。该问题描述了分析双曲守恒律 AMR 格式中守恒特性的典型场景，这是数值分析和计算物理中的一个标准课题。\n- **适定的**：是。该问题提供了所有必要的定义和关系，以推导目标量 $\\epsilon(n)$ 的唯一解析表达式。\n- **目标明确**：是。该问题使用精确、无歧义的数学语言进行陈述。\n\n该问题未表现出任何无效性缺陷。它在指定领域是一个适定的、科学上合理的问题。\n\n### 第 3 步：结论与行动\n问题是**有效**的。将提供解答。\n\n有限体积法（FVM）的基本原理是，控制体积内守恒量的变化等于穿过其边界的净通量。对于整个计算域中的总质量 $M$，其变化率仅由通过该域外边界的通量决定。问题陈述指出这些外边界是不可穿透的，意味着通过它们的通量为零。在一个完全守恒的数值格式中，这将意味着总质量 $M$ 在所有时间内都是恒定的。\n\n然而，问题明确指出在粗细网格界面上没有应用回流修正。这个细节至关重要，因为它是质量守恒误差的来源。在这种格式中，质量通量在界面两侧没有得到一致的处理。粗网格求解器计算出的离开粗网格区域的质量，与细网格求解器计算出的进入细网格区域的质量并不相同。这种差异导致在每个时间步长内在界面上产生质量的净生成或净消失。\n\n让我们来量化在一个粗网格时间步长 $\\Delta t_{c}$ 内的质量误差。我们可以采用一个符号约定，即从粗网格到细网格方向的通量为正。\n\n在时间间隔 $\\Delta t_{c}$ 内，由粗网格求解器计算出的、在界面处离开粗网格区域的总质量由下式给出：\n$$\n\\Delta M_{\\text{coarse, out}} = F_{c} A \\Delta t_{c}\n$$\n\n在同一时间间隔 $\\Delta t_{c}$ 内，进入细网格区域的总质量是通过对 $r$ 个细网格子步长的贡献求和来计算的：\n$$\n\\Delta M_{\\text{fine, in}} = \\sum_{k=1}^{r} (F_{f}^{(k)} A \\Delta t_{f}) = A \\sum_{k=1}^{r} F_{f}^{(k)} \\Delta t_{f}\n$$\n\n在一个粗网格步长期间，系统总质量的净变化（我们记为 $\\Delta M_{\\text{step}}$）是有效进入细网格的质量与有效离开粗网格的质量之差。\n$$\n\\Delta M_{\\text{step}} = \\Delta M_{\\text{fine, in}} - \\Delta M_{\\text{coarse, out}}\n$$\n代入这些质量传输的表达式可得：\n$$\n\\Delta M_{\\text{step}} = \\left( A \\sum_{k=1}^{r} F_{f}^{(k)} \\Delta t_{f} \\right) - (F_{c} A \\Delta t_{c})\n$$\n我们可以提出常数项 $A$ 和 $\\Delta t_{c}$：\n$$\n\\Delta M_{\\text{step}} = A \\Delta t_{c} \\left( \\left[ \\frac{1}{\\Delta t_{c}} \\sum_{k=1}^{r} F_{f}^{(k)} \\Delta t_{f} \\right] - F_{c} \\right)\n$$\n问题给出了时间平均的细网格层通量的定义，$\\bar{F}_{f} = \\frac{1}{\\Delta t_{c}} \\sum_{k=1}^{r} F_{f}^{(k)} \\Delta t_{f}$。将其代入我们的 $\\Delta M_{\\text{step}}$ 表达式中，得到：\n$$\n\\Delta M_{\\text{step}} = A \\Delta t_{c} (\\bar{F}_{f} - F_{c})\n$$\n我们还已知粗网格通量和平均细网格通量之间的关系：$F_{c} = \\bar{F}_{f} + \\delta$。这意味着差值 $\\bar{F}_{f} - F_{c} = -\\delta$。将此代入 $\\Delta M_{\\text{step}}$ 的方程中，得到每个粗网格步长产生的净质量误差：\n$$\n\\Delta M_{\\text{step}} = A \\Delta t_{c} (-\\delta) = -\\delta A \\Delta t_{c}\n$$\n问题陈述指出 $\\delta$ 是一个与时间步长索引无关的常数。这意味着在 $n$ 个粗网格时间步长的每一步中，都会引入相同数量的质量误差 $\\Delta M_{\\text{step}}$。因此，在 $n$ 步之后，总的累积质量变化 $M(n) - M_0$ 是每步误差乘以步数：\n$$\nM(n) - M_{0} = n \\cdot \\Delta M_{\\text{step}} = -n \\delta A \\Delta t_{c}\n$$\n无量纲累积质量误差 $\\epsilon(n)$ 定义为 $\\epsilon(n) = \\frac{M(n) - M_{0}}{M_{0}}$。使用我们推导出的总质量变化 $M(n) - M_{0}$ 的表达式，我们得到误差的最终表达式：\n$$\n\\epsilon(n) = \\frac{-n \\delta A \\Delta t_{c}}{M_{0}}\n$$\n该表达式按要求将累积无量纲误差直接与步数 $n$、通量不匹配参数 $\\delta$、界面面积 $A$、粗网格时间步长 $\\Delta t_c$ 和初始总质量 $M_0$ 联系起来。",
            "answer": "$$\\boxed{-\\frac{n \\delta A \\Delta t_{c}}{M_{0}}}$$"
        },
        {
            "introduction": "为了最大化计算效率，AMR算法常常在不同层级的网格上使用不同的时间步长，这种技术被称为时间子循环（subcycling）。然而，这也引入了一个显著的逻辑挑战：即如何“编排”各层级之间的相互作用。在这个实践中 ，您将详细规划出关键操作（同步、数据传输和通量修正）的精确时间序列，以理解一个多层级模拟是如何在时间演化中保持一致性和准确性的。",
            "id": "4009024",
            "problem": "考虑一个用于双曲守恒律有限体积离散化的块结构自适应网格加密 (AMR) 层次结构，其层级为 $\\ell=0,1,2$。假设在时间上采用子循环，相邻层级间的加密比为常数 $r=2$，且基础（最粗）时间步长为 $\\Delta t_0$。该离散化是守恒的，并使用在每个层级的每个时间步长上积分的面通量。由 Courant–Friedrichs–Lewy (CFL) 条件给出的稳定性要求强制，相对于较粗层级，加密层级上的时间步长必须充分减小，并且每个加密层级在其父层级的一个步长时间间隔内执行 $r$ 个子步。所有层级都从绝对时间 $t=0$ 开始，积分推进到绝对时间 $t=3\\,\\Delta t_0$。\n\n你需要根据上述基础和离散守恒结构进行推理，以确定三个层级之间子循环的时间协调。具体来说：\n- 计算在 $[0,3\\,\\Delta t_0]$ 时间区间内，层级 $\\ell=2$ 与层级 $\\ell=1$ 同步、层级 $\\ell=1$ 与层级 $\\ell=0$ 同步、以及所有三个层级 $\\ell=0,1,2$ 同时同步的完整、有序的时间序列。\n- 通过列出 $[0,3\\,\\Delta t_0]$ 内相应的绝对时间，确定何时必须发生回流。回流是在粗细网格界面上应用的通量修正操作，用于在细网格层级完成足够多的子步以达到粗网格层级的时间后，强制实现离散守恒。\n- 通过列出 $[0,3\\,\\Delta t_0]$ 内相应的绝对时间，确定何时必须发生从层级 $\\ell=2$到层级 $\\ell=1$ 以及从层级 $\\ell=1$到层级 $\\ell=0$ 的限制（将细网格层级的单元平均值向下平均到下一个较粗层级）操作。\n- 通过列出 $[0,3\\,\\Delta t_0]$ 内相应的绝对时间，确定何时必须对层级 $\\ell=1$ 和层级 $\\ell=2$ 进行延拓（将粗网格层级的状态插值到细网格层级的虚拟单元中，以在细网格层级推进前初始化并填充边界数据）操作，这些时间被解释为 $[0,3\\,\\Delta t_0]$ 内每个细网格层级子步的开始时间。\n\n所有时间都用 $\\Delta t_0$ 的符号形式表示。将你的最终答案表示为一个单行矩阵，其条目按顺序为以下各项的时间集合：\n1. 层级 $\\ell=2$ 与层级 $\\ell=1$ 同步，\n2. 层级 $\\ell=1$ 与层级 $\\ell=0$ 同步，\n3. 所有层级 $\\ell=0,1,2$ 同步，\n4. 回流事件，\n5. 从层级 $\\ell=2$到层级 $\\ell=1$ 的限制事件，\n6. 从层级 $\\ell=1$到层级 $\\ell=0$ 的限制事件，\n7. 层级 $\\ell=1$ 的延拓事件，\n8. 层级 $\\ell=2$ 的延拓事件。\n\n无需四舍五入。最终答案以 $\\Delta t_0$ 的精确符号集合形式表示，不带单位。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 步骤 1：提取给定信息\n- 具有层级 $\\ell=0,1,2$ 的 AMR 层次结构。\n- 双曲守恒律的有限体积离散化。\n- 时间子循环。\n- 恒定的加密比 $r=2$。\n- 基础（最粗）时间步长为 $\\Delta t_0$。\n- 离散化是守恒的并使用面通量。\n- CFL 条件规定了在加密层级上的时间步长缩减。\n- 每个加密层级在父层级的一个步长时间内执行 $r$ 个子步。\n- 所有层级从绝对时间 $t=0$ 开始。\n- 积分推进至绝对时间 $t=3\\,\\Delta t_0$。\n- 需要分析的操作：同步、回流、限制、延拓。\n- 输出要求：八个有序的时间集合，以 $\\Delta t_0$ 的符号形式表示。\n\n### 步骤 2：使用提取的给定信息进行验证\n- **科学依据**：该问题在偏微分方程数值分析领域有坚实的基础。块结构自适应网格加密 (AMR)、时间子循环、CFL 条件、回流（通量修正）、限制和延拓等概念是已建立算法（例如用于双曲系统的 Berger-Oliger 方法）的标准组成部分。该设置在科学上是合理的，并描述了物理学和工程学中典型的高性能计算场景。\n- **适定的**：该问题是适定的。它提供了所有必要的参数（层级数、加密比 $r$、基础时间步长 $\\Delta t_0$ 以及总积分时间），以唯一确定所有指定 AMR 操作的时间序列。问题是精确的，并能导出一个唯一的、可确定的解。\n- **客观的**：该问题使用计算科学中常见的客观、技术性语言陈述。没有主观或模糊的陈述。\n- **缺陷清单**：该问题不违反任何无效性标准。它在科学上是合理的、可形式化的、完整的、现实的、适定的且非平凡的。\n\n### 步骤 3：结论与行动\n该问题被判定为 **有效**。将推导解答。\n\n### 解答推导\n\n该问题要求确定在时间子循环的块结构 AMR 算法中，关键操作发生的精确时间。该层次结构包含三个层级 $\\ell=0, 1, 2$，相邻层级之间在时间和空间上的加密比均为 $r=2$。\n\n首先，我们确定每个层级的时间步长。基础时间步长是层级 $\\ell=0$ 的 $\\Delta t_0$。加密比为 $r=2$，则更精细层级的时间步长为：\n- 层级 $\\ell=1$ 的时间步长：$\\Delta t_1 = \\frac{\\Delta t_0}{r} = \\frac{\\Delta t_0}{2}$。\n- 层级 $\\ell=2$ 的时间步长：$\\Delta t_2 = \\frac{\\Delta t_1}{r} = \\frac{\\Delta t_0}{r^2} = \\frac{\\Delta t_0}{4}$。\n\n总积分时间为 $T = 3\\,\\Delta t_0$。子循环过程规定，对于粗层级的每一步，下一个更精细的层级必须完成 $r$ 个子步以覆盖相同的时间间隔。仿真是通过以大小为 $\\Delta t_0$ 的三个步长推进最粗层级 $\\ell=0$ 来进行的。\n\n我们现在将确定在时间区间 $[0, 3\\,\\Delta t_0]$ 内每个指定操作的时间序列。\n\n**1. 同步时间：层级 $\\ell=2$ 与层级 $\\ell=1$**\n层级 $\\ell=2$ 必须在层级 $\\ell=1$ 的每个时间步结束时与其父层级 $\\ell=1$ 同步。这发生在 $\\Delta t_1$ 的整数倍时刻。时间点为 $t_k = k\\,\\Delta t_1 = k\\,\\frac{\\Delta t_0}{2}$。由于仿真从 $t=0$ 运行到 $t=3\\,\\Delta t_0 = 6\\,\\Delta t_1$，同步时间点对应于 $k=0, 1, 2, 3, 4, 5, 6$。包含 $t=0$ 反映了所有层级的初始同步状态。\n时间集合为：$\\{0, \\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0, 3\\Delta t_0\\}$。\n\n**2. 同步时间：层级 $\\ell=1$ 与层级 $\\ell=0$**\n类似地，层级 $\\ell=1$ 在层级 $\\ell=0$ 的每个时间步结束时与其父层级 $\\ell=0$ 同步。这发生在 $\\Delta t_0$ 的整数倍时刻。时间点为 $t_k = k\\,\\Delta t_0$。由于仿真运行到 $t=3\\,\\Delta t_0$，同步时间点对应于 $k=0, 1, 2, 3$。\n时间集合为：$\\{0, \\Delta t_0, 2\\Delta t_0, 3\\Delta t_0\\}$。\n\n**3. 同步时间：所有层级 ($\\ell=0, 1, 2$)**\n所有三个层级仅在层级 $\\ell=1$ 与 $\\ell=0$ 同步且层级 $\\ell=2$ 与 $\\ell=1$ 同步时才同时同步。这对应于上面推导的两个时间集合的交集。$\\{k\\,\\frac{\\Delta t_0}{2} \\mid k \\in \\{0,..,6\\}\\}$ 和 $\\{k\\,\\Delta t_0 \\mid k \\in \\{0,..,3\\}\\}$ 的交集即为层级 $\\ell=0$ 的时间集合。\n时间集合为：$\\{0, \\Delta t_0, 2\\Delta t_0, 3\\Delta t_0\\}$。\n\n**4. 回流时间**\n回流是在细层级推进到粗层级的时间后，在粗细网格界面上应用的通量修正，以确保离散守恒。这是一个在循环结束时执行的操作，因此它发生在 $t > 0$ 的时刻。\n- **L2/L1 界面**：从 $\\ell=2$ 到 $\\ell=1$ 的回流发生在每个 $\\ell=1$ 时间步的末尾，即在时间点 $k\\,\\Delta t_1$ (其中 $k=1, ..., 6$)。时间点：$\\{\\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0, 3\\Delta t_0\\}$。\n- **L1/L0 界面**：从 $\\ell=1$ 到 $\\ell=0$ 的回流发生在每个 $\\ell=0$ 时间步的末尾，即在时间点 $k\\,\\Delta t_0$ (其中 $k=1, 2, 3$)。时间点：$\\{\\Delta t_0, 2\\Delta t_0, 3\\Delta t_0\\}$。\n问题要求一个单一的回流时间集合。这意味着任何回流操作发生的所有时间的并集。\n时间集合是上述两个集合的并集：$\\{\\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0, 3\\Delta t_0\\}$。\n\n**5. 限制时间：从层级 $\\ell=2$ 到层级 $\\ell=1$**\n限制是将细网格数据平均到其下的粗网格单元上。这发生在细网格推进之后，在与粗网格同步的时刻。对于 $\\ell=2 \\rightarrow \\ell=1$，这发生在每个层级 $\\ell=1$ 时间步的末尾（对于 $t>0$）。\n时间集合与 L2/L1 回流时间相同：$\\{\\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0, 3\\Delta t_0\\}$。\n\n**6. 限制时间：从层级 $\\ell=1$ 到层级 $\\ell=0$**\n类似地，从 $\\ell=1 \\rightarrow \\ell=0$ 的限制发生在每个层级 $\\ell=0$ 时间步的末尾（对于 $t > 0$）。\n时间集合为：$\\{\\Delta t_0, 2\\Delta t_0, 3\\Delta t_0\\}$。\n\n**7. 层级 $\\ell=1$ 的延拓时间**\n延拓通过从其父层级插值来为细层级提供边界数据。这必须在每个细层级时间步开始时完成。层级 $\\ell=1$ 以大小为 $\\Delta t_1$ 的步长推进。总区间 $[0, 3\\Delta t_0]$ 对应于 $[0, 6\\Delta t_1]$。层级 $\\ell=1$ 的时间步为 $[k\\Delta t_1, (k+1)\\Delta t_1]$ (其中 $k=0, 1, 2, 3, 4, 5$)。在每个这些区间的开始都需要进行延拓。\n时间集合为：$\\{0, \\Delta t_1, 2\\Delta t_1, 3\\Delta t_1, 4\\Delta t_1, 5\\Delta t_1\\}$，即 $\\{0, \\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0\\}$。\n\n**8. 层级 $\\ell=2$ 的延拓时间**\n层级 $\\ell=2$ 以大小为 $\\Delta t_2$ 的步长推进。总区间 $[0, 3\\Delta t_0]$ 对应于 $[0, 12\\Delta t_2]$。层级 $\\ell=2$ 的时间步为 $[k\\Delta t_2, (k+1)\\Delta t_2]$ (其中 $k=0, 1, ..., 11$)。在每个这些区间的开始都需要进行延拓。时间点为 $t_k = k\\,\\Delta t_2 = k\\,\\frac{\\Delta t_0}{4}$ (其中 $k=0, 1, ..., 11$)。\n时间集合为：$\\{0, \\frac{1}{4}\\Delta t_0, \\frac{2}{4}\\Delta t_0, \\frac{3}{4}\\Delta t_0, \\frac{4}{4}\\Delta t_0, \\frac{5}{4}\\Delta t_0, \\frac{6}{4}\\Delta t_0, \\frac{7}{4}\\Delta t_0, \\frac{8}{4}\\Delta t_0, \\frac{9}{4}\\Delta t_0, \\frac{10}{4}\\Delta t_0, \\frac{11}{4}\\Delta t_0\\}$。\n简化分数后得到：$\\{0, \\frac{1}{4}\\Delta t_0, \\frac{1}{2}\\Delta t_0, \\frac{3}{4}\\Delta t_0, \\Delta t_0, \\frac{5}{4}\\Delta t_0, \\frac{3}{2}\\Delta t_0, \\frac{7}{4}\\Delta t_0, 2\\Delta t_0, \\frac{9}{4}\\Delta t_0, \\frac{5}{2}\\Delta t_0, \\frac{11}{4}\\Delta t_0\\}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\{0, \\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0, 3\\Delta t_0\\} & \\{0, \\Delta t_0, 2\\Delta t_0, 3\\Delta t_0\\} & \\{0, \\Delta t_0, 2\\Delta t_0, 3\\Delta t_0\\} & \\{\\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0, 3\\Delta t_0\\} & \\{\\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0, 3\\Delta t_0\\} & \\{\\Delta t_0, 2\\Delta t_0, 3\\Delta t_0\\} & \\{0, \\frac{1}{2}\\Delta t_0, \\Delta t_0, \\frac{3}{2}\\Delta t_0, 2\\Delta t_0, \\frac{5}{2}\\Delta t_0\\} & \\{0, \\frac{1}{4}\\Delta t_0, \\frac{1}{2}\\Delta t_0, \\frac{3}{4}\\Delta t_0, \\Delta t_0, \\frac{5}{4}\\Delta t_0, \\frac{3}{2}\\Delta t_0, \\frac{7}{4}\\Delta t_0, 2\\Delta t_0, \\frac{9}{4}\\Delta t_0, \\frac{5}{2}\\Delta t_0, \\frac{11}{4}\\Delta t_0\\} \\end{pmatrix}}$$"
        },
        {
            "introduction": "AMR的“自适应”特性在于其能够将计算资源动态地集中于解最复杂或物理意义最重要的区域。这个综合性练习  将挑战您从头开始设计并实现一个针对球形地球网格的真实加密策略。您将基于地形梯度（这是数值天气预报中的一个关键因素）来建立一个加密准则，并学习如何处理球面几何与实际应用中的各种细节。",
            "id": "4009005",
            "problem": "您的任务是设计一个程序，为球形地球网格构建一个自适应网格加密（AMR）掩码。该掩码由地形梯度驱动，并由地形跟随坐标变形进行加权。程序必须实现球面距离度量，并以与球面几何一致的方式计算梯度。目标是为每个测试用例生成加密结果的量化指标，并将其汇总到单行输出中。\n\n程序基础必须建立在以下原则之上：\n- 地球被建模为半径为 $R$ 的球体，坐标由纬度 $\\phi$ 和经度 $\\lambda$ 给出。球面上的位置必须使用弧度作为角度单位进行几何和微积分计算，其中 $R$ 的单位是米。\n- 球面上标量场 $h(\\phi,\\lambda)$ 的水平梯度使用度量尺度因子。如果 $h$ 表示以米为单位的表面高程，那么以米/米为单位测量的水平梯度大小 $|\\nabla h|$ 由符合度量的偏导数构建：\n$$\n\\left|\\nabla h\\right| = \\sqrt{\\left(\\frac{\\partial h}{\\partial x}\\right)^2 + \\left(\\frac{\\partial h}{\\partial y}\\right)^2}, \\quad \\frac{\\partial h}{\\partial x} \\approx \\frac{\\partial h}{\\partial \\lambda} \\cdot \\frac{1}{R \\cos\\phi}, \\quad \\frac{\\partial h}{\\partial y} \\approx \\frac{\\partial h}{\\partial \\phi} \\cdot \\frac{1}{R}.\n$$\n离散化必须在角度坐标上使用有限差分，并通过经度的度量尺度因子 $R\\cos\\phi$ 和纬度的度量尺度因子 $R$ 转换为物理距离。边界处使用单边差分，内部使用中心差分。\n- 两点 $(\\phi_1,\\lambda_1)$ 和 $(\\phi_2,\\lambda_2)$ 之间的球面距离必须使用物理上一致的测地线度量（例如，半正矢公式）来计算，以支持在加密区域周围进行缓冲。\n\n地形跟随坐标变形必须通过一个无量纲的权重因子来引入，该因子用于修正加密标准。考虑一个地形跟随垂直坐标，它将物理高度 $z$ 映射到一个无量纲坐标 $\\sigma$，其顶部边界为 $z_{top}$，底部边界为表面 $z_{surf} = h(\\phi,\\lambda)$。一个简单且科学上合理的变形权重是：\n$$\nW(\\phi,\\lambda) = \\sqrt{1 + \\left(\\gamma \\frac{z_{top} - h(\\phi,\\lambda)}{H_{ref}} \\left|\\nabla h(\\phi,\\lambda)\\right|\\right)^2},\n$$\n其中 $\\gamma$ 是一个无量纲的调整参数，$H_{ref}$ 是以米为单位的参考垂直尺度。这会增强在地形跟随面陡峭倾斜区域的加密，这些区域是数值天气预报（NWP）中气压梯度力误差的来源。\n\n将加权坡度大小定义为 $S_w = W \\left|\\nabla h\\right|$。通过阈值化构建初始的二元加密掩码 $M_0$：\n$$\nM_0(\\phi,\\lambda) = \\begin{cases}\n1, & S_w(\\phi,\\lambda) \\ge s_{th},\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\n其中 $s_{th}$ 是一个以米/米表示的无量纲坡度阈值。然后对 $M_0$ 执行球面缓冲（膨胀），方法是标记所有与任何 $M_0=1$ 的单元格的测地距离在 $r_{buf}$（单位为米）之内的网格单元，从而生成最终掩码 $M$。\n\n您的程序必须：\n1. 为每个测试用例构建网格（经纬度数组以度为单位，但所有内部计算均以弧度和米为单位执行）。\n2. 使用测试套件中指定的解析形式生成地形 $h$（表面高程，单位为米）。\n3. 以米/米为单位，计算符合度量的水平梯度大小 $\\left|\\nabla h\\right|$。\n4. 计算地形跟随权重 $W$ 和加权坡度大小 $S_w$。\n5. 使用阈值 $s_{th}$ 构建初始掩码 $M_0$，然后使用半径 $r_{buf}$ 执行球面缓冲以生成 $M$。\n6. 为每个测试用例报告一个包含三个值的列表：加密单元格的数量（整数）、网格上找到的最大加权坡度大小 $S_w$（浮点数），以及加密分数（浮点数），定义为加密单元格数量除以总网格单元格数量。将第二个和第三个值表示为四舍五入到六位小数的十进制浮点数。角度在内部必须以弧度处理。距离必须以米表示。坡度大小 $S_w$ 是无量纲的（米/米）。\n\n地球半径为 $R = 6{,}371{,}000$ 米。输入网格中的角度以度为单位给出，但所有几何运算都必须将其转换为弧度。\n\n测试套件：\n- 案例 1（中纬度高斯山脉）：\n    - 网格：纬度从 $-20^{\\circ}$ 到 $20^{\\circ}$（含），步长 $2^{\\circ}$；经度从 $0^{\\circ}$ 到 $40^{\\circ}$（含），步长 $2^{\\circ}$。\n    - 地形：一个以 $(\\phi_0=0^{\\circ}, \\lambda_0=20^{\\circ})$ 为中心的高斯山脉，高度为\n    $$\n    h(\\phi,\\lambda) = 500 + H_0 \\exp\\left(-\\frac{d(\\phi,\\lambda;\\phi_0,\\lambda_0)^2}{2 a^2}\\right),\n    $$\n    其中 $H_0 = 2000$ 米，$a = 200{,}000$ 米，$d(\\cdot)$ 是以米为单位的球面测地距离。\n    - 地形跟随参数：$\\gamma=2.0$, $H_{ref}=8000$ 米, $z_{top}=18{,}000$ 米。\n    - 加密：$s_{th}=0.02$（无量纲），缓冲半径 $r_{buf}=50{,}000$ 米。\n- 案例 2（带有经向波动的近极地纬向山脊）：\n    - 网格：纬度从 $80^{\\circ}$ 到 $89^{\\circ}$（含），步长 $1^{\\circ}$；经度从 $0^{\\circ}$ 到 $20^{\\circ}$（含），步长 $2^{\\circ}$。\n    - 地形：一个以 $\\phi_0=85^{\\circ}$ 为中心的纬向山脊，标准差为 $\\sigma=1^{\\circ}$，并带有经向调制\n    $$\n    h(\\phi,\\lambda) = 200 + H_0 \\exp\\left(-\\frac{(\\phi - \\phi_0)^2}{2 \\sigma^2}\\right)\\left[1 + 0.3 \\sin(3 \\lambda)\\right],\n    $$\n    其中 $H_0=1500$ 米，所有角度在计算时均转换为弧度。\n    - 地形跟随参数：$\\gamma=1.5$, $H_{ref}=10{,}000$ 米, $z_{top}=20{,}000$ 米。\n    - 加密：$s_{th}=0.03$（无量纲），缓冲半径 $r_{buf}=30{,}000$ 米。\n- 案例 3（平坦地形边缘案例）：\n    - 网格：纬度从 $-10^{\\circ}$ 到 $10^{\\circ}$（含），步长 $5^{\\circ}$；经度从 $-10^{\\circ}$ 到 $10^{\\circ}$（含），步长 $5^{\\circ}$。\n    - 地形：$h(\\phi,\\lambda) = 0$ 米，处处如此。\n    - 地形跟随参数：$\\gamma=2.0$, $H_{ref}=8000$ 米, $z_{top}=15{,}000$ 米。\n    - 加密：$s_{th}=0.01$（无量纲），缓冲半径 $r_{buf}=10{,}000$ 米。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例报告为一个三元列表，顺序为 [加密单元格数量, 最大加权坡度大小, 加密分数]。输出中不允许有任何空格。例如，输出必须采用以下形式：\n\"[[N1,M1,F1],[N2,M2,F2],[N3,M3,F3]]\"",
            "solution": "问题陈述在科学上是合理的、适定的和客观的，为一项植根于数值地球物理流体动力学原理的计算任务提供了完整的规范。所有必需的常数、公式和参数都已提供，测试用例也定义明确。因此，该问题是有效的，我们可以着手解决。\n\n任务是基于地形复杂性，为球形网格构建一个自适应网格加密（AMR）掩码。该过程涉及多个步骤，每个步骤都基于物理和数值原理。我们将概述一个实现此过程的程序设计。\n\n地球被建模为半径 $R = 6,371,000$ 米的球体。位置由纬度 $\\phi$ 和经度 $\\lambda$ 指定。虽然输入网格以度为单位定义，但所有几何和三角计算都必须以弧度进行。\n\n首先，我们建立计算网格。对于每个测试用例，我们在纬度和经度上构建一个二维规则网格。纬度的一维坐标数组 $\\phi_i$ 和经度的 $\\lambda_j$ 被转换为弧度。由此，创建二维坐标场 $\\Phi(\\phi_i, \\lambda_j)$ 和 $\\Lambda(\\phi_i, \\lambda_j)$ 来表示每个网格点的位置。\n\n接下来，在每个网格点计算表面高程或地形 $h(\\phi, \\lambda)$。问题为 $h$ 指定了解析函数。例如，中纬度高斯山脉是相对于其中心 $(\\phi_0, \\lambda_0)$ 使用球面测地距离 $d$ 定义的。两点 $(\\phi_1, \\lambda_1)$ 和 $(\\phi_2, \\lambda_2)$ 之间的测地距离使用半正矢公式计算：\n$$\nd = 2R \\arcsin\\left(\\sqrt{\\sin^2\\left(\\frac{\\phi_2-\\phi_1}{2}\\right) + \\cos\\phi_1\\cos\\phi_2\\sin^2\\left(\\frac{\\lambda_2-\\lambda_1}{2}\\right)}\\right)\n$$\n那么高斯山脉案例的地形为：\n$$\nh(\\phi,\\lambda) = 500 + H_0 \\exp\\left(-\\frac{d(\\phi,\\lambda;\\phi_0,\\lambda_0)^2}{2 a^2}\\right)\n$$\n对于其他情况，如近极地山脊，使用提供的特定函数。对于平坦地形情况，$h(\\phi, \\lambda) = 0$ 对所有点都成立。\n\n加密标准的核心是地形水平梯度的大小 $|\\nabla h|$。在球面上，梯度分量必须考虑度量尺度因子，这些因子将角度位移与物理距离联系起来。物理东西向（$x$）和南北向（$y$）的偏导数为：\n$$\n\\frac{\\partial h}{\\partial x} \\approx \\frac{1}{R \\cos\\phi} \\frac{\\partial h}{\\partial \\lambda} \\quad \\text{and} \\quad \\frac{\\partial h}{\\partial y} \\approx \\frac{1}{R} \\frac{\\partial h}{\\partial \\phi}\n$$\n我们使用中心有限差分来近似内部网格点的角度偏导数 $\\frac{\\partial h}{\\partial \\phi}$ 和 $\\frac{\\partial h}{\\partial \\lambda}$，并在边界处使用单边差分。梯度大小的单位是高程变化米数/水平距离米数（无量纲），其计算公式为：\n$$\n|\\nabla h| = \\sqrt{\\left(\\frac{\\partial h}{\\partial x}\\right)^2 + \\left(\\frac{\\partial h}{\\partial y}\\right)^2}\n$$\n\n加密标准通过一个权重因子 $W$ 得到增强，该因子考虑了与数值天气预报（NWP）等模型中陡峭倾斜的地形跟随坐标相关的数值误差。权重 $W$ 在这些坐标面发生扭曲的地方放大了标准。其定义为：\n$$\nW(\\phi,\\lambda) = \\sqrt{1 + \\left(\\gamma \\frac{z_{top} - h(\\phi,\\lambda)}{H_{ref}} |\\nabla h(\\phi,\\lambda)|\\right)^2}\n$$\n其中 $\\gamma$ 是一个调整参数，$z_{top}$ 是模型顶部高度，$H_{ref}$ 是一个参考垂直尺度高度。然后将加权坡度大小 $S_w$ 计算为权重和梯度大小的乘积：\n$$\nS_w = W |\\nabla h|\n$$\n这个场 $S_w$ 作为网格加密的主要指标。我们还必须确定其在整个网格上的最大值以便报告。\n\n在建立 $S_w$ 场之后，我们分两个阶段生成一个二元加密掩码。首先，通过对加权坡度应用阈值 $s_{th}$ 来创建初始掩码 $M_0$：\n$$\nM_0(\\phi,\\lambda) = \\begin{cases}\n1, & S_w(\\phi,\\lambda) \\ge s_{th} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\n单元格值为 $1$ 表示需要加密。\n\n其次，为了确保加密区域和粗糙区域之间的平滑过渡，并包含紧邻高坡度区域的区域，需要添加一个缓冲区。这是通过对初始掩码 $M_0$ 进行球面膨胀来实现的。最终掩码 $M$ 的构建方式是：如果一个网格单元到初始掩码 $M_0$ 中*任何*标记单元的测地距离小于或等于指定的缓冲半径 $r_{buf}$，则该单元被标记为需要加密（$M=1$）。此操作通过遍历所有不在 $M_0$ 中的网格单元，并计算它们到所有在 $M_0$ 中的单元集合的最小测地距离来执行。\n\n最后，程序必须为每个测试用例计算并报告三个量化指标：\n1.  最终掩码中加密单元格的总数，$N = \\sum M(\\phi_i, \\lambda_j)$。\n2.  整个网格上的最大加权坡度大小，$\\max(S_w)$。\n3.  加密网格的分数，$F = N / N_{total}$，其中 $N_{total}$ 是网格单元的总数。\n\n这些步骤被封装到一个程序中，该程序按顺序处理每个测试用例，并按照指定格式将结果格式化为单行输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation and solution process.\n    It sets up test cases, processes each, and prints the final formatted result.\n    \"\"\"\n    R_EARTH = 6371000.0  # meters\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"grid\": {\"lat\": (-20.0, 20.0, 2.0), \"lon\": (0.0, 40.0, 2.0)},\n            \"oro_type\": \"gaussian\",\n            \"oro_params\": {\"h_base\": 500.0, \"H0\": 2000.0, \"phi0_deg\": 0.0, \"lambda0_deg\": 20.0, \"a\": 200000.0},\n            \"terrain_params\": {\"gamma\": 2.0, \"H_ref\": 8000.0, \"z_top\": 18000.0},\n            \"refine_params\": {\"s_th\": 0.02, \"r_buf\": 50000.0}\n        },\n        {\n            \"id\": 2,\n            \"grid\": {\"lat\": (80.0, 89.0, 1.0), \"lon\": (0.0, 20.0, 2.0)},\n            \"oro_type\": \"ridge\",\n            \"oro_params\": {\"h_base\": 200.0, \"H0\": 1500.0, \"phi0_deg\": 85.0, \"sigma_deg\": 1.0},\n            \"terrain_params\": {\"gamma\": 1.5, \"H_ref\": 10000.0, \"z_top\": 20000.0},\n            \"refine_params\": {\"s_th\": 0.03, \"r_buf\": 30000.0}\n        },\n        {\n            \"id\": 3,\n            \"grid\": {\"lat\": (-10.0, 10.0, 5.0), \"lon\": (-10.0, 10.0, 5.0)},\n            \"oro_type\": \"flat\",\n            \"oro_params\": {},\n            \"terrain_params\": {\"gamma\": 2.0, \"H_ref\": 8000.0, \"z_top\": 15000.0},\n            \"refine_params\": {\"s_th\": 0.01, \"r_buf\": 10000.0}\n        }\n    ]\n\n    def haversine(phi1, lon1, phi2, lon2, R):\n        \"\"\"\n        Calculate the haversine distance between point(s) 1 and point(s) 2.\n        Accepts scalar or array inputs for phi/lon, assuming standard numpy broadcasting.\n        All angle inputs must be in radians.\n        \"\"\"\n        dphi = phi2 - phi1\n        dlon = lon2 - lon1\n        a = np.sin(dphi / 2.0)**2 + np.cos(phi1) * np.cos(phi2) * np.sin(dlon / 2.0)**2\n        # Clip 'a' to handle potential floating point errors for antipodal points\n        a = np.minimum(a, 1.0)\n        c = 2 * np.arcsin(np.sqrt(a))\n        return R * c\n\n    def process_case(case_data, R):\n        \"\"\"\n        Processes a single test case to generate the required metrics.\n        \"\"\"\n        # 1. Grid Setup\n        lat_min, lat_max, lat_step = case_data[\"grid\"][\"lat\"]\n        lon_min, lon_max, lon_step = case_data[\"grid\"][\"lon\"]\n\n        num_lat = int(round((lat_max - lat_min) / lat_step)) + 1\n        num_lon = int(round((lon_max - lon_min) / lon_step)) + 1\n\n        lat_deg_1d = np.linspace(lat_min, lat_max, num_lat)\n        lon_deg_1d = np.linspace(lon_min, lon_max, num_lon)\n\n        lat_rad_1d = np.radians(lat_deg_1d)\n        lon_rad_1d = np.radians(lon_deg_1d)\n\n        PHI, LAM = np.meshgrid(lat_rad_1d, lon_rad_1d, indexing='ij')\n\n        # 2. Orography Generation\n        oro_params = case_data[\"oro_params\"]\n        if case_data[\"oro_type\"] == \"gaussian\":\n            phi0_rad = np.radians(oro_params[\"phi0_deg\"])\n            lambda0_rad = np.radians(oro_params[\"lambda0_deg\"])\n            d = haversine(phi0_rad, lambda0_rad, PHI, LAM, R)\n            h = oro_params[\"h_base\"] + oro_params[\"H0\"] * np.exp(-d**2 / (2 * oro_params[\"a\"]**2))\n        elif case_data[\"oro_type\"] == \"ridge\":\n            phi0_rad = np.radians(oro_params[\"phi0_deg\"])\n            sigma_rad = np.radians(oro_params[\"sigma_deg\"])\n            h = oro_params[\"h_base\"] + oro_params[\"H0\"] * np.exp(-(PHI - phi0_rad)**2 / (2 * sigma_rad**2)) * (1 + 0.3 * np.sin(3 * LAM))\n        elif case_data[\"oro_type\"] == \"flat\":\n            h = np.zeros_like(PHI)\n\n        # 3. Gradient Computation\n        dh_dphi, dh_dlam = np.gradient(h, lat_rad_1d, lon_rad_1d, axis=(0, 1))\n        \n        dh_dy = dh_dphi / R\n        \n        cos_phi = np.cos(PHI)\n        # Avoid division by zero at the poles\n        dh_dx = np.divide(dh_dlam, R * cos_phi, out=np.zeros_like(dh_dlam), where=np.abs(cos_phi) > 1e-9)\n\n        grad_h_mag = np.sqrt(dh_dx**2 + dh_dy**2)\n\n        # 4. Weighted Slope Computation\n        tp = case_data[\"terrain_params\"]\n        W = np.sqrt(1 + (tp[\"gamma\"] * (tp[\"z_top\"] - h) / tp[\"H_ref\"] * grad_h_mag)**2)\n        S_w = W * grad_h_mag\n        max_sw = np.max(S_w) if S_w.size > 0 else 0.0\n\n        # 5. Mask Generation and Buffering\n        rp = case_data[\"refine_params\"]\n        M0 = S_w >= rp[\"s_th\"]\n        M = M0.copy()\n\n        refined_indices = np.argwhere(M0)\n        if refined_indices.size > 0:\n            initially_refined_phis = PHI[refined_indices[:, 0], refined_indices[:, 1]]\n            initially_refined_lons = LAM[refined_indices[:, 0], refined_indices[:, 1]]\n            \n            # Indices of points not yet refined\n            check_indices = np.argwhere(~M)\n            \n            for idx in check_indices:\n                i, j = idx[0], idx[1]\n                phi_ij, lam_ij = PHI[i, j], LAM[i, j]\n                \n                distances = haversine(phi_ij, lam_ij, initially_refined_phis, initially_refined_lons, R)\n                \n                if np.min(distances) = rp[\"r_buf\"]:\n                    M[i, j] = True\n\n        # 6. Metrics Calculation\n        num_refined_cells = int(np.sum(M))\n        refined_fraction = num_refined_cells / M.size if M.size > 0 else 0.0\n        \n        return [num_refined_cells, max_sw, refined_fraction]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case, R_EARTH)\n        all_results.append(result)\n        \n    result_strings = [f'[{r[0]},{r[1]:.6f},{r[2]:.6f}]' for r in all_results]\n    print(f\"[[{','.join(result_strings)}]]\")\n\nsolve()\n```"
        }
    ]
}