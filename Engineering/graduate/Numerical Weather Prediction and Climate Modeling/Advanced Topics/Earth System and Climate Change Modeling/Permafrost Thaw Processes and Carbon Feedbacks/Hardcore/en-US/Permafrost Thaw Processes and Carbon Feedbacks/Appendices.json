{
    "hands_on_practices": [
        {
            "introduction": "A critical first step in studying permafrost-climate interactions is to accurately diagnose the state of the permafrost itself from model output or observational data. The Active Layer Thickness (ALT), representing the maximum depth of seasonal thaw, is a fundamental indicator of permafrost health. This practice  challenges you to translate the physical definition of ALT into a robust computational algorithm, a common task for climate scientists, which involves handling discrete data and using interpolation to pinpoint the thaw front.",
            "id": "4074459",
            "problem": "Consider a one-dimensional soil column in a numerical weather prediction and climate modeling framework. The thermodynamic state of the column is described by the temperature field $T(z,t)$, where $z$ is depth measured positively downward from the ground surface and $t$ is time. The Active Layer Thickness (ALT) is the maximum depth of seasonally thawed soil, defined for permafrost as the deepest position of the thaw front that occurs during the warm season. Assume the following scientific bases: energy conservation in a continuum and phase change at the melting temperature enforce that the thaw front location satisfies $T(z,t) = T_{\\mathrm{m}}$ at the interface between thawed and frozen soil; perennially frozen soil below the active layer remains below the melting temperature during the warm season. In a discretized soil column with finite depth nodes, the thaw front is inferred from model outputs of $T(z,t)$ without directly tracking latent heat.\n\nDefinition of Active Layer Thickness (ALT) for this problem: For each warm season time $t$ in a prescribed index set $\\mathcal{W}$, define the contiguous thaw depth at time $t$ as the largest depth $z^{\\ast}(t)$ such that $T(z',t) \\ge T_{\\mathrm{m}}$ for all depths $z' \\in [0,z^{\\ast}(t)]$, with the additional requirement that $T(0,t) \\ge T_{\\mathrm{m}}$ at that time. The seasonal Active Layer Thickness is then $\\mathrm{ALT} = \\max_{t \\in \\mathcal{W}} z^{\\ast}(t)$. If, at time $t$, there is a depth interval $[z_i, z_{i+1}]$ in the discrete grid where $T(z_i,t) \\ge T_{\\mathrm{m}}$ and $T(z_{i+1},t)  T_{\\mathrm{m}}$, infer the thaw front within that interval by a consistent monotone interpolation in $z$ based on the local temperature profile. If $T(0,t)  T_{\\mathrm{m}}$ for a given $t$, then $z^{\\ast}(t) = 0$ by the contiguity requirement. If all depths in the grid satisfy $T(z,t) \\ge T_{\\mathrm{m}}$ at a time $t$, then $z^{\\ast}(t)$ equals the maximum grid depth.\n\nYour task: Implement a program to compute $\\mathrm{ALT}$ for each of the provided test cases, using the above contiguous thaw depth criterion and an appropriate interpolation when the thaw front lies between depth nodes. Express all $\\mathrm{ALT}$ values in meters, rounded to four decimal places. Angles do not appear in this problem. The temperature unit is Kelvin, and depth is in meters. Time is given as discrete indices.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$\\mathrm{ALT}_1,\\mathrm{ALT}_2,\\dots$]\"), where each entry is a floating-point number representing the $\\mathrm{ALT}$ for the corresponding test case in meters, rounded to four decimal places.\n\nTest Suite:\n\nTest Case $1$ (general warm-season thaw progression; \"happy path\"):\n- Depth grid $z = [0.0, 0.25, 0.5, 0.75, 1.0]\\,\\mathrm{m}$.\n- Warm season time indices $\\mathcal{W} = \\{0,1,2,3,4,5\\}$.\n- Melting temperature $T_{\\mathrm{m}} = 273.15\\,\\mathrm{K}$.\n- Temperatures $T(z,t)$ at each time:\n  - $t=0$: $[274.0, 272.5, 271.5, 270.5, 269.5]\\,\\mathrm{K}$.\n  - $t=1$: $[275.0, 274.0, 272.8, 271.0, 270.0]\\,\\mathrm{K}$.\n  - $t=2$: $[276.0, 275.0, 274.0, 272.5, 271.0]\\,\\mathrm{K}$.\n  - $t=3$: $[277.0, 276.0, 275.0, 273.5, 272.0]\\,\\mathrm{K}$.\n  - $t=4$: $[276.5, 275.5, 274.5, 273.2, 272.2]\\,\\mathrm{K}$.\n  - $t=5$: $[275.0, 274.0, 273.7, 273.0, 272.5]\\,\\mathrm{K}$.\n\nTest Case $2$ (no surface thaw; deeper warming non-contiguous with the surface):\n- Depth grid $z = [0.0, 0.5, 1.0]\\,\\mathrm{m}$.\n- Warm season time indices $\\mathcal{W} = \\{0,1,2\\}$.\n- Melting temperature $T_{\\mathrm{m}} = 273.15\\,\\mathrm{K}$.\n- Temperatures:\n  - $t=0$: $[272.0, 274.0, 274.5]\\,\\mathrm{K}$.\n  - $t=1$: $[272.5, 273.5, 274.5]\\,\\mathrm{K}$.\n  - $t=2$: $[272.8, 274.2, 274.8]\\,\\mathrm{K}$.\n\nTest Case $3$ (threshold equality and full-column thaw at a time):\n- Depth grid $z = [0.0, 0.5, 1.0]\\,\\mathrm{m}$.\n- Warm season time indices $\\mathcal{W} = \\{0,1,2\\}$.\n- Melting temperature $T_{\\mathrm{m}} = 273.15\\,\\mathrm{K}$.\n- Temperatures:\n  - $t=0$: $[273.15, 273.15, 272.0]\\,\\mathrm{K}$.\n  - $t=1$: $[273.15, 273.20, 273.15]\\,\\mathrm{K}$.\n  - $t=2$: $[273.10, 273.18, 273.16]\\,\\mathrm{K}$.\n\nTest Case $4$ (mid-depth cold barrier preventing contiguity to deeper thawed layers):\n- Depth grid $z = [0.0, 0.4, 0.8, 1.2]\\,\\mathrm{m}$.\n- Warm season time indices $\\mathcal{W} = \\{0,1,2,3\\}$.\n- Melting temperature $T_{\\mathrm{m}} = 273.15\\,\\mathrm{K}$.\n- Temperatures:\n  - $t=0$: $[274.0, 273.8, 272.7, 274.0]\\,\\mathrm{K}$.\n  - $t=1$: $[275.0, 274.2, 272.9, 273.5]\\,\\mathrm{K}$.\n  - $t=2$: $[274.5, 273.5, 273.0, 272.8]\\,\\mathrm{K}$.\n  - $t=3$: $[273.8, 273.4, 272.6, 272.5]\\,\\mathrm{K}$.\n\nTest Case $5$ (freezing point depression; lower effective threshold):\n- Depth grid $z = [0.0, 0.3, 0.6, 0.9, 1.2]\\,\\mathrm{m}$.\n- Warm season time indices $\\mathcal{W} = \\{0,1,2,3\\}$.\n- Melting temperature $T_{\\mathrm{m}} = 272.5\\,\\mathrm{K}$.\n- Temperatures:\n  - $t=0$: $[273.0, 272.7, 272.3, 271.9, 271.5]\\,\\mathrm{K}$.\n  - $t=1$: $[273.2, 272.9, 272.6, 272.2, 271.8]\\,\\mathrm{K}$.\n  - $t=2$: $[273.1, 273.0, 272.8, 272.4, 272.0]\\,\\mathrm{K}$.\n  - $t=3$: $[272.9, 272.8, 272.7, 272.5, 272.3]\\,\\mathrm{K}$.\n\nImplementation requirements:\n- For each test case, evaluate $z^{\\ast}(t)$ across the specified warm season index set $\\mathcal{W}$ and report $\\mathrm{ALT}$ as the maximum value of $z^{\\ast}(t)$ over $t \\in \\mathcal{W}$.\n- Use a depth-wise monotone interpolation when the thaw front lies strictly between two consecutive depth nodes where temperatures straddle $T_{\\mathrm{m}}$.\n- Return results as a single-line list of floats in meters, rounded to four decimal places, in the order of the test cases $1$ through $5$.",
            "solution": "The problem has been validated and is deemed scientifically grounded, well-posed, objective, and self-contained. The provided definitions and data are sufficient and consistent for deriving a unique, meaningful solution. The physical context is based on standard principles of thermodynamics and permafrost geophysics as employed in climate modeling. The task is a direct application of these principles to discrete data.\n\nThe objective is to compute the seasonal Active Layer Thickness, denoted $\\mathrm{ALT}$, for five distinct test cases. The $\\mathrm{ALT}$ is defined as the maximum contiguous thaw depth, $z^{\\ast}(t)$, that occurs over a specified set of warm season time indices, $\\mathcal{W}$.\n$$\n\\mathrm{ALT} = \\max_{t \\in \\mathcal{W}} z^{\\ast}(t)\n$$\nThe core of the problem is to determine the contiguous thaw depth, $z^{\\ast}(t)$, for a given one-dimensional temperature profile $T(z,t)$ at a specific time $t$. The temperature profile is provided at discrete depth nodes $z_i$, where $i=0, 1, \\dots, N$. The depth $z$ is measured positively downwards from the surface, so $z_0=0$.\n\nThe algorithm to compute $z^{\\ast}(t)$ for a single time step is as follows:\n\n1.  **Check Surface Condition**: The definition requires that the thaw be contiguous with the surface. Therefore, we first check the surface temperature, $T(z_0, t) = T(0, t)$. If $T(0, t)  T_{\\mathrm{m}}$, where $T_{\\mathrm{m}}$ is the melting temperature, the ground is frozen at the surface. By the contiguity requirement, the thaw depth is zero, irrespective of temperatures at deeper layers. Thus, $z^{\\ast}(t) = 0$.\n\n2.  **Iterate Through Depth Nodes**: If $T(0, t) \\ge T_{\\mathrm{m}}$, we proceed to find the maximum depth of the contiguous thawed layer. We iterate downwards through the depth nodes $z_i$ for $i = 1, 2, \\dots, N$. We search for the first depth index $i$ at which the temperature drops below the melting point, i.e., $T(z_i, t)  T_{\\mathrm{m}}$.\n\n3.  **Determine Thaw Depth**:\n    a. **Thaw Front Between Nodes**: If such an index $i$ is found, it signifies that the soil is thawed (or at the melting point) down to depth $z_{i-1}$, since $T(z_j, t) \\ge T_{\\mathrm{m}}$ for all $j  i$. The thaw front, where $T(z,t) = T_{\\mathrm{m}}$, lies in the interval $[z_{i-1}, z_i]$. The problem specifies using a \"consistent monotone interpolation\" to find the exact location. Linear interpolation is the standard and appropriate choice. Given the two points $(z_{i-1}, T(z_{i-1}, t))$ and $(z_i, T(z_i, t))$, we find the depth $z^{\\ast}(t)$ where the linearly interpolated temperature equals $T_{\\mathrm{m}}$. The equation for the line connecting the two points is:\n    $$\n    \\frac{z - z_{i-1}}{z_i - z_{i-1}} = \\frac{T_{\\mathrm{m}} - T(z_{i-1}, t)}{T(z_i, t) - T(z_{i-1}, t)}\n    $$\n    Solving for $z$, which we identify as $z^{\\ast}(t)$, yields:\n    $$\n    z^{\\ast}(t) = z_{i-1} + (z_i - z_{i-1}) \\frac{T_{\\mathrm{m}} - T(z_{i-1}, t)}{T(z_i, t) - T(z_{i-1}, t)}\n    $$\n    A special case within this is if $T(z_{i-1}, t) = T_{\\mathrm{m}}$, in which case the formula correctly simplifies to $z^{\\ast}(t) = z_{i-1}$.\n\n    b. **Full Column Thaw**: If the loop completes without finding any depth $z_i$ where $T(z_i, t)  T_{\\mathrm{m}}$, it means that $T(z_i, t) \\ge T_{\\mathrm{m}}$ for all nodes in the grid. In this scenario, the entire modeled soil column is thawed. The contiguous thaw depth $z^{\\ast}(t)$ is therefore equal to the maximum depth of the grid, $z_N$.\n\nBy applying this procedure for each time $t \\in \\mathcal{W}$, we obtain a set of seasonal thaw depths $\\{z^{\\ast}(t)\\}$. The final $\\mathrm{ALT}$ for a given test case is the maximum value in this set. This entire process is repeated for each of the five test cases provided. The final result for each case is rounded to four decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Active Layer Thickness (ALT) for a series of test cases based on 1D soil temperature profiles.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"z\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"Tm\": 273.15,\n            \"T_profiles\": [\n                [274.0, 272.5, 271.5, 270.5, 269.5],\n                [275.0, 274.0, 272.8, 271.0, 270.0],\n                [276.0, 275.0, 274.0, 272.5, 271.0],\n                [277.0, 276.0, 275.0, 273.5, 272.0],\n                [276.5, 275.5, 274.5, 273.2, 272.2],\n                [275.0, 274.0, 273.7, 273.0, 272.5],\n            ],\n        },\n        {\n            \"z\": [0.0, 0.5, 1.0],\n            \"Tm\": 273.15,\n            \"T_profiles\": [\n                [272.0, 274.0, 274.5],\n                [272.5, 273.5, 274.5],\n                [272.8, 274.2, 274.8],\n            ],\n        },\n        {\n            \"z\": [0.0, 0.5, 1.0],\n            \"Tm\": 273.15,\n            \"T_profiles\": [\n                [273.15, 273.15, 272.0],\n                [273.15, 273.20, 273.15],\n                [273.10, 273.18, 273.16],\n            ],\n        },\n        {\n            \"z\": [0.0, 0.4, 0.8, 1.2],\n            \"Tm\": 273.15,\n            \"T_profiles\": [\n                [274.0, 273.8, 272.7, 274.0],\n                [275.0, 274.2, 272.9, 273.5],\n                [274.5, 273.5, 273.0, 272.8],\n                [273.8, 273.4, 272.6, 272.5],\n            ],\n        },\n        {\n            \"z\": [0.0, 0.3, 0.6, 0.9, 1.2],\n            \"Tm\": 272.5,\n            \"T_profiles\": [\n                [273.0, 272.7, 272.3, 271.9, 271.5],\n                [273.2, 272.9, 272.6, 272.2, 271.8],\n                [273.1, 273.0, 272.8, 272.4, 272.0],\n                [272.9, 272.8, 272.7, 272.5, 272.3],\n            ],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        depth_grid = np.array(case[\"z\"])\n        Tm = case[\"Tm\"]\n        T_profiles = case[\"T_profiles\"]\n        \n        max_thaw_depth_for_case = 0.0\n\n        for t_profile in T_profiles:\n            T = np.array(t_profile)\n            \n            # Check for surface thaw. If surface is frozen, contiguous thaw depth is 0.\n            if T[0]  Tm:\n                thaw_depth_t = 0.0\n            else:\n                # Find the first depth where temperature is below Tm\n                frozen_indices = np.where(T  Tm)[0]\n                \n                if len(frozen_indices) == 0:\n                    # Entire column is thawed or at melting point\n                    thaw_depth_t = depth_grid[-1]\n                else:\n                    # Thaw front is between nodes\n                    first_frozen_idx = frozen_indices[0]\n                    \n                    # This check is needed for the case where the first node T[0] is >= Tm,\n                    # but the second node T[1] is already  Tm.\n                    if first_frozen_idx == 0:\n                        # This should not happen due to the T[0]  Tm check above, but as a safeguard.\n                        thaw_depth_t = 0.0\n                    else:\n                        prev_idx = first_frozen_idx - 1\n                        z_prev = depth_grid[prev_idx]\n                        T_prev = T[prev_idx]\n                        \n                        z_curr = depth_grid[first_frozen_idx]\n                        T_curr = T[first_frozen_idx]\n\n                        # Handle the case where T_prev == T_curr, to avoid division by zero.\n                        # If T_prev is >= Tm and T_curr is  Tm, they cannot be equal.\n                        # However, if T_prev == Tm, the thaw front is exactly at z_prev.\n                        if T_prev == Tm:\n                             thaw_depth_t = z_prev\n                        # The case T_curr == Tm is not possible here as T_curr  Tm.\n                        else:\n                            # Linear interpolation to find the depth where T = Tm\n                            thaw_depth_t = z_prev + (z_curr - z_prev) * (Tm - T_prev) / (T_curr - T_prev)\n\n            if thaw_depth_t > max_thaw_depth_for_case:\n                max_thaw_depth_for_case = thaw_depth_t\n        \n        results.append(round(max_thaw_depth_for_case, 4))\n\n    # Format output as a single-line string\n    print(f\"[\" + \",\".join([f\"{r:.4f}\" for r in results]) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Understanding the local process of permafrost thaw is crucial, but its global significance comes from the resulting carbon release, which acts as a positive feedback on climate change. This exercise  provides a hands-on opportunity to quantify this feedback by connecting an increased rate of atmospheric $CO_2$ concentration to a tangible global temperature response. You will apply a standard climate modeling framework that combines the logarithmic radiative forcing of $CO_2$ with an impulse-response function for temperature, linking a specific feedback mechanism to its global climatic impact.",
            "id": "4074432",
            "problem": "Consider a stylized coupling between permafrost thaw carbon release and the climate system within a numerical climate modeling framework. Atmospheric carbon dioxide concentration $C(t)$ is assumed to evolve under a prescribed combined anthropogenic-plus-permafrost emission pathway such that\n$$C(t)=C_{0}\\exp(r t),$$\nfor $t$ in years, where $C_{0}$ is the preindustrial concentration and $r$ is an effective concentration growth rate that aggregates anthropogenic emissions and the net carbon feedback from permafrost thaw. Take $C_{0}=280\\,\\text{ppm}$ and $r=r_{\\text{anth}}+r_{\\text{pf}}$ with $r_{\\text{anth}}=4.0\\times 10^{-3}\\,\\text{yr}^{-1}$ and $r_{\\text{pf}}=1.0\\times 10^{-3}\\,\\text{yr}^{-1}$.\n\nUse the widely accepted logarithmic carbon dioxide radiative forcing relation with coefficient $\\alpha$ such that the carbon dioxide radiative forcing is\n$$\\Delta F_{\\text{CO}_{2}}(t)=\\alpha \\ln\\!\\big(C(t)/C_{0}\\big),$$\nwith $\\alpha=5.35\\,\\text{W}\\,\\text{m}^{-2}$.\n\nTranslate the time-varying radiative forcing into a global-mean surface air temperature response using a linear impulse response function (IRF) representation of the climate system with two timescales. Specifically, assume the temperature IRF is\n$$H(t)=\\sum_{i=1}^{2}\\frac{\\beta_{i}}{\\tau_{i}}\\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right),\\quad t\\ge 0,$$\nwhere the step response to a unit forcing is $\\Phi(t)=\\sum_{i=1}^{2}\\beta_{i}\\big(1-\\exp(-t/\\tau_{i})\\big)$, with parameters $\\beta_{1}=0.5\\,\\text{K}\\,(\\text{W}^{-1}\\,\\text{m}^{2})$, $\\beta_{2}=0.3\\,\\text{K}\\,(\\text{W}^{-1}\\,\\text{m}^{2})$, $\\tau_{1}=4\\,\\text{yr}$, and $\\tau_{2}=200\\,\\text{yr}$. The global-mean temperature change is given by the causal convolution\n$$\\Delta T(t)=\\int_{0}^{t}H(t-s)\\,\\Delta F_{\\text{CO}_{2}}(s)\\,\\mathrm{d}s.$$\n\nCompute the global-mean temperature change $\\Delta T(100\\,\\text{yr})$ implied by this pathway and model. Round your answer to four significant figures. Express the temperature change in kelvin (K).",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\nThe given information is as follows:\n- Atmospheric carbon dioxide concentration: $C(t)=C_{0}\\exp(r t)$, where $t$ is in years.\n- Preindustrial concentration: $C_{0}=280\\,\\text{ppm}$.\n- Effective concentration growth rate: $r=r_{\\text{anth}}+r_{\\text{pf}}$.\n- Anthropogenic growth rate component: $r_{\\text{anth}}=4.0\\times 10^{-3}\\,\\text{yr}^{-1}$.\n- Permafrost growth rate component: $r_{\\text{pf}}=1.0\\times 10^{-3}\\,\\text{yr}^{-1}$.\n- Carbon dioxide radiative forcing: $\\Delta F_{\\text{CO}_{2}}(t)=\\alpha \\ln\\!\\big(C(t)/C_{0}\\big)$.\n- Radiative forcing coefficient: $\\alpha=5.35\\,\\text{W}\\,\\text{m}^{-2}$.\n- Temperature impulse response function (IRF): $H(t)=\\sum_{i=1}^{2}\\frac{\\beta_{i}}{\\tau_{i}}\\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right)$ for $t\\ge 0$.\n- IRF parameters:\n  - $\\beta_{1}=0.5\\,\\text{K}\\,(\\text{W}^{-1}\\,\\text{m}^{2})$, $\\tau_{1}=4\\,\\text{yr}$.\n  - $\\beta_{2}=0.3\\,\\text{K}\\,(\\text{W}^{-1}\\,\\text{m}^{2})$, $\\tau_{2}=200\\,\\text{yr}$.\n- Global-mean temperature change: $\\Delta T(t)=\\int_{0}^{t}H(t-s)\\,\\Delta F_{\\text{CO}_{2}}(s)\\,\\mathrm{d}s$.\n- The goal is to compute $\\Delta T(100\\,\\text{yr})$ and round the result to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a stylized but standard exercise in climate modeling.\n- **Scientifically Grounded:** The model uses established concepts: exponential growth for CO2 concentration (a simplification, but valid for modeling), logarithmic radiative forcing, and a linear impulse response function to model temperature change. These are cornerstone techniques in simplified climate models. The parameter values are within a plausible range for such a model. The problem correctly identifies a key climate feedback loop (permafrost thaw).\n- **Well-Posed:** All necessary functions, parameters, and initial conditions are provided. The task is to compute a specific quantity, $\\Delta T(100\\,\\text{yr})$, for which a unique solution can be derived from the given convolution integral.\n- **Objective:** The problem is stated using precise mathematical and physical terminology, free from ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is valid. We proceed with the solution.\n\nFirst, we determine the total effective concentration growth rate $r$:\n$$r = r_{\\text{anth}} + r_{\\text{pf}} = 4.0\\times 10^{-3}\\,\\text{yr}^{-1} + 1.0\\times 10^{-3}\\,\\text{yr}^{-1} = 5.0\\times 10^{-3}\\,\\text{yr}^{-1}.$$\nNext, we derive the explicit form of the radiative forcing, $\\Delta F_{\\text{CO}_{2}}(t)$, as a function of time. We substitute the expression for $C(t)$ into the forcing equation:\n$$\\Delta F_{\\text{CO}_{2}}(t)=\\alpha \\ln\\!\\left(\\frac{C_{0}\\exp(r t)}{C_{0}}\\right) = \\alpha \\ln(\\exp(r t)) = \\alpha r t.$$\nThe radiative forcing is a linear function of time, often called a ramp forcing.\n\nNow, we must compute the global-mean temperature change $\\Delta T(t)$ using the convolution integral:\n$$\\Delta T(t) = \\int_{0}^{t} H(t-s) \\Delta F_{\\text{CO}_{2}}(s)\\,\\mathrm{d}s.$$\nSubstituting the expressions for $H(t-s)$ and $\\Delta F_{\\text{CO}_{2}}(s)$:\n$$\\Delta T(t) = \\int_{0}^{t} \\left( \\sum_{i=1}^{2}\\frac{\\beta_{i}}{\\tau_{i}}\\exp\\!\\left(-\\frac{t-s}{\\tau_{i}}\\right) \\right) (\\alpha r s)\\,\\mathrm{d}s.$$\nWe can interchange the summation and integration:\n$$\\Delta T(t) = \\alpha r \\sum_{i=1}^{2} \\frac{\\beta_{i}}{\\tau_{i}} \\int_{0}^{t} s \\exp\\!\\left(-\\frac{t-s}{\\tau_{i}}\\right)\\,\\mathrm{d}s.$$\nLet's evaluate the integral for a single component $i$. We can factor out the term depending only on $t$:\n$$I_{i}(t) = \\int_{0}^{t} s \\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right)\\exp\\!\\left(\\frac{s}{\\tau_{i}}\\right)\\,\\mathrm{d}s = \\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right) \\int_{0}^{t} s \\exp\\!\\left(\\frac{s}{\\tau_{i}}\\right)\\,\\mathrm{d}s.$$\nWe solve the integral using integration by parts, $\\int u\\,\\mathrm{d}v = uv - \\int v\\,\\mathrm{d}u$. Let $u=s$ and $\\mathrm{d}v = \\exp(s/\\tau_{i})\\,\\mathrm{d}s$. Then $\\mathrm{d}u = \\mathrm{d}s$ and $v = \\tau_{i}\\exp(s/\\tau_{i})$.\n\\begin{align*} \\int_{0}^{t} s \\exp\\!\\left(\\frac{s}{\\tau_{i}}\\right)\\,\\mathrm{d}s = \\left[s \\tau_{i} \\exp\\!\\left(\\frac{s}{\\tau_{i}}\\right)\\right]_{0}^{t} - \\int_{0}^{t} \\tau_{i} \\exp\\!\\left(\\frac{s}{\\tau_{i}}\\right)\\,\\mathrm{d}s \\\\ = \\left(t \\tau_{i} \\exp\\!\\left(\\frac{t}{\\tau_{i}}\\right) - 0\\right) - \\left[\\tau_{i}^{2} \\exp\\!\\left(\\frac{s}{\\tau_{i}}\\right)\\right]_{0}^{t} \\\\ = t \\tau_{i} \\exp\\!\\left(\\frac{t}{\\tau_{i}}\\right) - \\left(\\tau_{i}^{2} \\exp\\!\\left(\\frac{t}{\\tau_{i}}\\right) - \\tau_{i}^{2} \\exp(0)\\right) \\\\ = t \\tau_{i} \\exp\\!\\left(\\frac{t}{\\tau_{i}}\\right) - \\tau_{i}^{2} \\exp\\!\\left(\\frac{t}{\\tau_{i}}\\right) + \\tau_{i}^{2}.\\end{align*}\nSubstituting this result back into the expression for $I_{i}(t)$:\n$$I_{i}(t) = \\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right) \\left( t \\tau_{i} \\exp\\!\\left(\\frac{t}{\\tau_{i}}\\right) - \\tau_{i}^{2} \\exp\\!\\left(\\frac{t}{\\tau_{i}}\\right) + \\tau_{i}^{2} \\right) = t\\tau_{i} - \\tau_{i}^{2} + \\tau_{i}^{2}\\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right).$$\nThis can be factored as $I_i(t) = \\tau_i \\left( t - \\tau_i \\left(1 - \\exp\\left(-\\frac{t}{\\tau_i}\\right)\\right) \\right)$.\n\nNow, we assemble the full expression for $\\Delta T(t)$:\n$$\\Delta T(t) = \\alpha r \\sum_{i=1}^{2} \\frac{\\beta_{i}}{\\tau_{i}} I_{i}(t) = \\alpha r \\sum_{i=1}^{2} \\frac{\\beta_{i}}{\\tau_{i}} \\left( t\\tau_{i} - \\tau_{i}^{2} + \\tau_{i}^{2}\\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right) \\right).$$\nSimplifying by canceling $\\tau_i$:\n$$\\Delta T(t) = \\alpha r \\sum_{i=1}^{2} \\beta_{i} \\left( t - \\tau_{i} + \\tau_{i}\\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right) \\right) = \\alpha r \\sum_{i=1}^{2} \\beta_{i} \\left[t - \\tau_{i}\\left(1 - \\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right)\\right)\\right].$$\nWe are asked to compute $\\Delta T(t)$ at $t = 100\\,\\text{yr}$. Let's substitute the numerical values.\n$r = 5.0\\times 10^{-3}\\,\\text{yr}^{-1}$\n$\\alpha = 5.35\\,\\text{W}\\,\\text{m}^{-2}$\n$t=100\\,\\text{yr}$\nTerm $1$ ($i=1$): $\\beta_{1}=0.5\\,\\text{K}\\,(\\text{W}^{-1}\\,\\text{m}^{2})$, $\\tau_{1}=4\\,\\text{yr}$.\nTerm $2$ ($i=2$): $\\beta_{2}=0.3\\,\\text{K}\\,(\\text{W}^{-1}\\,\\text{m}^{2})$, $\\tau_{2}=200\\,\\text{yr}$.\n\nLet's calculate the sum inside the expression first. Let $S = \\sum_{i=1}^{2} \\beta_{i} \\left[t - \\tau_{i}\\left(1 - \\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right)\\right)\\right]$.\n$$S_1 = \\beta_{1} \\left[t - \\tau_{1}\\left(1 - \\exp\\!\\left(-\\frac{t}{\\tau_{1}}\\right)\\right)\\right] = 0.5 \\left[100 - 4\\left(1 - \\exp\\!\\left(-\\frac{100}{4}\\right)\\right)\\right] = 0.5 \\left[100 - 4\\left(1 - \\exp(-25)\\right)\\right].$$\n$$S_2 = \\beta_{2} \\left[t - \\tau_{2}\\left(1 - \\exp\\!\\left(-\\frac{t}{\\tau_{2}}\\right)\\right)\\right] = 0.3 \\left[100 - 200\\left(1 - \\exp\\!\\left(-\\frac{100}{200}\\right)\\right)\\right] = 0.3 \\left[100 - 200\\left(1 - \\exp(-0.5)\\right)\\right].$$\nNow calculating the numerical values:\nThe term $\\exp(-25)$ is exceedingly small, $\\exp(-25) \\approx 1.3888 \\times 10^{-11}$. Thus, $1 - \\exp(-25) \\approx 1$.\n$$S_1 \\approx 0.5 [100 - 4(1)] = 0.5 \\times 96 = 48.$$\nFor the second term, $\\exp(-0.5) \\approx 0.60653066$.\n$$S_2 = 0.3 [100 - 200(1 - 0.60653066)] = 0.3 [100 - 200(0.39346934)] = 0.3 [100 - 78.693868] = 0.3[21.306132] \\approx 6.3918396.$$\nThe total sum $S = S_1 + S_2 \\approx 48 + 6.3918396 = 54.3918396$.\nThe units of $S$ are $\\text{K}\\,(\\text{W}^{-1}\\,\\text{m}^{2})\\,\\text{yr}$.\n\nFinally, we calculate $\\Delta T(100\\,\\text{yr})$:\n$$\\Delta T(100\\,\\text{yr}) = \\alpha r S = (5.35\\,\\text{W}\\,\\text{m}^{-2}) \\times (5.0\\times 10^{-3}\\,\\text{yr}^{-1}) \\times S.$$\n$$\\alpha r = 0.02675\\,\\text{W}\\,\\text{m}^{-2}\\,\\text{yr}^{-1}.$$\n$$\\Delta T(100\\,\\text{yr}) = 0.02675 \\times 54.3918396 \\approx 1.4552019\\,\\text{K}.$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\\Delta T(100\\,\\text{yr}) \\approx 1.455\\,\\text{K}.$$\n\nFinal check of units:\n$$[\\Delta T] = [\\alpha] \\times [r] \\times [\\beta] \\times [\\tau] = (\\text{W}\\,\\text{m}^{-2}) \\times (\\text{yr}^{-1}) \\times (\\text{K}\\,\\text{W}^{-1}\\,\\text{m}^{2}) \\times (\\text{yr}) = \\text{K}.$$\nThe units are consistent.",
            "answer": "$$\\boxed{1.455}$$"
        },
        {
            "introduction": "The predictive power of our permafrost and climate models hinges on their ability to accurately represent reality, a goal achieved by integrating real-world observations. This advanced practice  delves into the sophisticated technique of three-dimensional variational (3D-Var) data assimilation. You will design and implement a scheme to correct a model's subsurface temperature profile using satellite-derived Land Surface Temperature (LST) observations, gaining practical experience with the mathematical framework that underpins modern weather forecasting and Earth system analysis.",
            "id": "4074452",
            "problem": "You are tasked with formulating and implementing a linear observation operator and a Three-Dimensional Variational (3D-Var) data assimilation scheme for the vertical soil temperature profile relevant to permafrost thaw processes and ensuing carbon feedbacks in the context of numerical weather prediction and climate modeling. The objective is to assimilate satellite Land Surface Temperature (LST) and measured snow depth into the model soil temperature states.\n\nState definition: Let the control vector be the discrete soil temperature profile $x \\in \\mathbb{R}^n$ with components $x_i = T(z_i)$ at depths $z_i$ (in meters). In this problem, use $n = 3$ with depths $z = [z_1, z_2, z_3] = [0.05, 0.20, 1.00]$ meters. All temperatures must be expressed in kelvin.\n\nObservation operator: Satellite LST senses an effective surface skin temperature impacted by soil temperatures near the surface, air temperature, and the insulating effect of snow. Begin from Fourier’s law of one-dimensional vertical heat conduction, which states that the conductive flux $q$ satisfies $q = -k \\,\\partial T/\\partial z$ in soil or snow, and that at steady state, resistances in series add. To obtain a linear, observation-centric parameterization that is consistent with this physics, define:\n- An exponential depth weighting for soil influence on the surface: for a skin-depth scale $\\lambda$ (in meters), define unnormalized weights $\\tilde{\\alpha}_i = \\exp(-z_i/\\lambda)$, and normalized weights $\\alpha_i = \\tilde{\\alpha}_i / \\sum_{j=1}^n \\tilde{\\alpha}_j$.\n- A snow-decoupling factor based on snow depth $h$ (in meters), $\\sigma(h) = \\exp(-h/h_s)$, where $h_s$ (in meters) is a snow-insulation scale.\n\nWith these, define the linear observation operator $H(x; h, T_{\\mathrm{air}})$ mapping state $x$ to the modeled LST (in kelvin) by\n$$\nH(x; h, T_{\\mathrm{air}}) = \\sigma(h)\\sum_{i=1}^{n}\\alpha_i T(z_i) + \\left(1 - \\sigma(h)\\right) T_{\\mathrm{air}},\n$$\nwhere $T_{\\mathrm{air}}$ (in kelvin) is the near-surface air temperature from the numerical weather prediction forcing. This parameterization captures that, for vanishing snow depth $h \\to 0$, the skin temperature is dominated by shallow soil layers, while for thick snow $h \\to \\infty$, the skin temperature approaches the air temperature.\n\nBackground and observation error models: Assume a Gaussian background prior $x \\sim \\mathcal{N}(x_b, B)$ and Gaussian observation errors $y \\sim \\mathcal{N}(H(x; h, T_{\\mathrm{air}}), R)$ with scalar $R = r$ (in $\\mathrm{K}^2$). The background error covariance $B$ (in $\\mathrm{K}^2$) is specified by a stationary Gaussian correlation with e-folding length $L_b$ (in meters) and variance $s_b^2$:\n$$\nB_{ij} = s_b^2 \\exp\\!\\left(-\\frac{|z_i - z_j|}{L_b}\\right).\n$$\n\nVariational objective: Given a single LST observation $y$ (in kelvin), snow depth $h$ (in meters), and air temperature $T_{\\mathrm{air}}$ (in kelvin), define the quadratic cost function\n$$\nJ(x) = \\tfrac{1}{2}(x - x_b)^\\top B^{-1}(x - x_b) + \\tfrac{1}{2}\\left[y - H(x; h, T_{\\mathrm{air}})\\right]^\\top R^{-1}\\left[y - H(x; h, T_{\\mathrm{air}})\\right].\n$$\nThe analysis $x_a$ is the minimizer of $J(x)$.\n\nFundamental bases required for your derivation and implementation:\n- Fourier’s law $q = -k \\,\\partial T/\\partial z$ and the notion of series thermal resistances motivate the depth weighting and snow-decoupling attenuations.\n- Gaussian error models and the definition of the 3D-Var objective $J(x)$ under linear observation mapping.\n\nYour task:\n1. Using the definitions above, derive the linear algebraic form of the minimizer $x_a$ of $J(x)$ when $H(x; h, T_{\\mathrm{air}})$ is linear in $x$ plus a known offset term. Clearly state how to construct the effective observation operator row vector and offset term from $\\alpha_i$, $\\sigma(h)$, and $T_{\\mathrm{air}}$.\n2. Implement a program that computes $x_a$ for each test case below and returns the analysis temperature at the shallowest soil node $T_a(z_1)$ in kelvin. All results must be rounded to three decimal places.\n3. Use the following fixed parameters for all cases: $\\lambda = 0.10$ meters, $h_s = 0.20$ meters, and depths $z = [0.05, 0.20, 1.00]$ meters.\n4. Test suite. For each case, all temperatures are in kelvin, depths are in meters, and variances are in kelvin squared:\n   - Case $1$ (happy path, moderate snow): $h = 0.20$, $T_{\\mathrm{air}} = 265.0$, $y = 268.0$, $x_b = [270.0, 268.0, 265.0]$, $s_b^2 = 4.0$, $L_b = 0.30$, $r = 1.0$.\n   - Case $2$ (snow-free boundary): $h = 0.00$, $T_{\\mathrm{air}} = 290.0$, $y = 289.0$, $x_b = [285.0, 283.0, 280.0]$, $s_b^2 = 1.0$, $L_b = 0.10$, $r = 0.25$.\n   - Case $3$ (thick snow edge): $h = 1.00$, $T_{\\mathrm{air}} = 255.0$, $y = 255.5$, $x_b = [260.0, 258.0, 256.0]$, $s_b^2 = 9.0$, $L_b = 0.50$, $r = 1.0$.\n   - Case $4$ (high observation error): $h = 0.05$, $T_{\\mathrm{air}} = 273.0$, $y = 274.0$, $x_b = [272.0, 271.0, 270.0]$, $s_b^2 = 4.0$, $L_b = 0.20$, $r = 9.0$.\n   - Case $5$ (thin active layer, strong constraint): $h = 0.00$, $T_{\\mathrm{air}} = 276.0$, $y = 275.0$, $x_b = [274.0, 272.0, 268.0]$, $s_b^2 = 2.0$, $L_b = 0.30$, $r = 0.50$.\n\nImplementation requirements:\n- Your program must construct $\\alpha_i$ and $\\sigma(h)$ exactly as specified, assemble $B$ using the given $s_b^2$ and $L_b$, and compute the 3D-Var analysis $x_a$ for each case.\n- Angle units are not applicable.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result must be $T_a(z_1)$ in kelvin, rounded to three decimal places.",
            "solution": "The problem has been validated and is determined to be scientifically grounded, well-posed, and self-contained. The formulation represents a standard problem in geophysical data assimilation, specifically Three-Dimensional Variational (3D-Var) analysis, applied to a simplified but physically motivated model of soil thermodynamics. All required parameters and definitions are provided, and no contradictions or ambiguities are present.\n\nThe solution proceeds in two parts: first, a derivation of the analytical solution for the analysis state; second, a description of the algorithm for its numerical implementation.\n\n### Derivation of the Analysis State\n\nThe objective is to find the analysis state vector $x_a$ that minimizes the 3D-Var cost function $J(x)$. The cost function is defined as:\n$$\nJ(x) = \\tfrac{1}{2}(x - x_b)^\\top B^{-1}(x - x_b) + \\tfrac{1}{2}\\left[y - H(x; h, T_{\\mathrm{air}})\\right]^\\top R^{-1}\\left[y - H(x; h, T_{\\mathrm{air}})\\right]\n$$\nwhere $x \\in \\mathbb{R}^n$ is the state vector of soil temperatures, $x_b$ is the background state, $B$ is the background error covariance matrix, $y$ is the scalar LST observation, $R$ is the scalar observation error variance $r$, and $H(x; h, T_{\\mathrm{air}})$ is the observation operator.\n\nFirst, we linearize the observation operator. The problem defines it as:\n$$\nH(x; h, T_{\\mathrm{air}}) = \\sigma(h)\\sum_{i=1}^{n}\\alpha_i x_i + \\left(1 - \\sigma(h)\\right) T_{\\mathrm{air}}\n$$\nwhere $x_i = T(z_i)$. This can be expressed in linear algebraic form as:\n$$\nH(x) = \\mathbf{H}x + d\n$$\nHere, $\\mathbf{H}$ is a $1 \\times n$ row vector, and $d$ is a scalar offset. By inspection, we identify these components:\n- The effective observation operator row vector $\\mathbf{H}$ is given by:\n$$\n\\mathbf{H} = \\sigma(h) \\begin{bmatrix} \\alpha_1  \\alpha_2  \\dots  \\alpha_n \\end{bmatrix}\n$$\n- The scalar offset term $d$ is given by:\n$$\nd = \\left(1 - \\sigma(h)\\right) T_{\\mathrm{air}}\n$$\n\nWith this linear form, the cost function $J(x)$ becomes a quadratic function of $x$. To find its minimum, we compute the gradient of $J(x)$ with respect to $x$ and set it to zero. Using standard rules of vector calculus $(\\nabla_x (u^\\top A u) = 2Au$ for symmetric $A$ and $\\nabla_x(c^\\top x) = c)$, the gradient $\\nabla_x J(x)$ is:\n$$\n\\nabla_x J(x) = B^{-1}(x - x_b) - \\mathbf{H}^\\top R^{-1}(y - (\\mathbf{H}x + d)) = 0\n$$\nSince $y$ and $R=r$ are scalars, this simplifies to:\n$$\nB^{-1}(x - x_b) - \\frac{1}{r}\\mathbf{H}^\\top(y - \\mathbf{H}x - d) = 0\n$$\nTo solve for $x$ (which is the analysis state $x_a$ at the minimum), we rearrange the terms:\n$$\nB^{-1}x_a - B^{-1}x_b - \\frac{1}{r}\\mathbf{H}^\\top(y-d) + \\frac{1}{r}\\mathbf{H}^\\top\\mathbf{H}x_a = 0\n$$\n$$\n\\left(B^{-1} + \\frac{1}{r}\\mathbf{H}^\\top\\mathbf{H}\\right)x_a = B^{-1}x_b + \\frac{1}{r}\\mathbf{H}^\\top(y-d)\n$$\nThe analysis state is therefore:\n$$\nx_a = \\left(B^{-1} + \\mathbf{H}^\\top R^{-1}\\mathbf{H}\\right)^{-1} \\left(B^{-1}x_b + \\mathbf{H}^\\top R^{-1}(y-d)\\right)\n$$\nWhile correct, this form requires inverting the $n \\times n$ matrix $\\left(B^{-1} + \\mathbf{H}^\\top R^{-1}\\mathbf{H}\\right)$, which can be computationally expensive and numerically unstable. A more practical formulation is the gain form. Using the Woodbury matrix identity, the solution can be expressed as:\n$$\nx_a = x_b + \\mathbf{K}(y - H(x_b))\n$$\n$$\nx_a = x_b + \\mathbf{K}(y - (\\mathbf{H}x_b + d))\n$$\nwhere $\\mathbf{K}$ is the analysis gain matrix (in this case, a vector), defined as:\n$$\n\\mathbf{K} = B\\mathbf{H}^\\top (\\mathbf{H}B\\mathbf{H}^\\top + R)^{-1}\n$$\nThe term $y - H(x_b)$ is the innovation, representing the difference between the observation and the background state projected into observation space. Since $y$ is a scalar and $\\mathbf{H}$ is a row vector, the term $\\mathbf{H}B\\mathbf{H}^\\top + R$ is a scalar quantity, making its inversion trivial. For a scalar observation error variance $R=r$, the gain vector $\\mathbf{K}$ is:\n$$\n\\mathbf{K} = \\frac{B\\mathbf{H}^\\top}{\\mathbf{H}B\\mathbf{H}^\\top + r}\n$$\nThis form avoids large matrix inversions and is the basis for the implementation.\n\n### Algorithm\nThe procedure to compute the analysis state $x_a$ for each test case is as follows:\n1.  **Initialize Constants**: Define the fixed parameters: soil depths $z = [0.05, 0.20, 1.00]$, skin-depth scale $\\lambda = 0.10$, and snow-insulation scale $h_s = 0.20$.\n2.  **Loop Through Test Cases**: For each case, retrieve the parameters: snow depth $h$, air temperature $T_{\\mathrm{air}}$, LST observation $y$, background state $x_b$, background variance $s_b^2$, background correlation length $L_b$, and observation error variance $r$.\n3.  **Construct Background Error Covariance $B$**: The elements $B_{ij}$ of the $n \\times n$ matrix $B$ are calculated using the provided formula:\n    $$\n    B_{ij} = s_b^2 \\exp\\!\\left(-\\frac{|z_i - z_j|}{L_b}\\right)\n    $$\n4.  **Construct Observation Operator Components**:\n    a.  Calculate the normalized depth weights $\\alpha_i$:\n        $$\n        \\tilde{\\alpha}_i = \\exp(-z_i/\\lambda); \\quad \\alpha_i = \\frac{\\tilde{\\alpha}_i}{\\sum_{j=1}^n \\tilde{\\alpha}_j}\n        $$\n    b.  Calculate the snow-decoupling factor $\\sigma(h)$:\n        $$\n        \\sigma(h) = \\exp(-h/h_s)\n        $$\n    c.  Form the effective observation operator row vector $\\mathbf{H} = \\sigma(h) \\alpha^\\top$ and the offset $d = (1 - \\sigma(h)) T_{\\mathrm{air}}$.\n5.  **Compute Analysis Gain $\\mathbf{K}$**:\n    a.  Compute the scalar term $\\mathbf{H}B\\mathbf{H}^\\top$.\n    b.  Compute the gain vector $\\mathbf{K} = (B\\mathbf{H}^\\top) / (\\mathbf{H}B\\mathbf{H}^\\top + r)$.\n6.  **Calculate the Innovation**: Compute the scalar innovation $i = y - (\\mathbf{H}x_b + d)$.\n7.  **Compute the Analysis State $x_a$**: Update the background state using the gain and innovation:\n    $$\n    x_a = x_b + \\mathbf{K} i\n    $$\n8.  **Extract and Store Result**: The required result is the first component of the analysis vector, $T_a(z_1) = (x_a)_1$. This value is rounded to three decimal places.\n9.  **Format Output**: After processing all cases, the results are formatted into a single comma-separated string enclosed in square brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 3D-Var data assimilation problem for soil temperature profiles.\n    \"\"\"\n\n    # Fixed parameters from the problem statement\n    z = np.array([0.05, 0.20, 1.00])  # Soil depths in meters\n    lambda_scale = 0.10  # Skin-depth scale in meters\n    h_s = 0.20  # Snow-insulation scale in meters\n    \n    # Test suite from the problem statement\n    test_cases = [\n        # (h, T_air, y, x_b, s_b^2, L_b, r)\n        (0.20, 265.0, 268.0, [270.0, 268.0, 265.0], 4.0, 0.30, 1.0),\n        (0.00, 290.0, 289.0, [285.0, 283.0, 280.0], 1.0, 0.10, 0.25),\n        (1.00, 255.0, 255.5, [260.0, 258.0, 256.0], 9.0, 0.50, 1.0),\n        (0.05, 273.0, 274.0, [272.0, 271.0, 270.0], 4.0, 0.20, 9.0),\n        (0.00, 276.0, 275.0, [274.0, 272.0, 268.0], 2.0, 0.30, 0.50),\n    ]\n\n    results = []\n    \n    # Pre-calculate depth weights alpha, as they only depend on z and lambda\n    tilde_alpha = np.exp(-z / lambda_scale)\n    alpha = tilde_alpha / np.sum(tilde_alpha)\n\n    for case in test_cases:\n        h, T_air, y, xb_list, s_b2, L_b, r = case\n        xb = np.array(xb_list)\n        \n        # 1. Construct Background Error Covariance Matrix B\n        # |z_i - z_j| matrix using broadcasting\n        z_diff_matrix = np.abs(z[:, np.newaxis] - z)\n        B = s_b2 * np.exp(-z_diff_matrix / L_b)\n        \n        # 2. Construct Observation Operator (H_vec, d)\n        sigma_h = np.exp(-h / h_s)\n        H_vec = sigma_h * alpha\n        d = (1 - sigma_h) * T_air\n\n        # 3. Compute the Kalman Gain K\n        # Transpose H_vec to a column vector for matrix multiplication\n        H_vec_T = H_vec.reshape(-1, 1)\n        \n        # Denominator of the gain formula (a scalar)\n        # H_vec @ B @ H_vec_T is equivalent to H_vec @ (B @ H_vec_T)\n        HBH_T = H_vec @ B @ H_vec_T.flatten() # Ensure scalar\n        \n        # Numerator of the gain formula (a column vector)\n        BH_T = B @ H_vec_T\n        \n        # Kalman gain vector\n        K = BH_T / (HBH_T + r)\n\n        # 4. Calculate the innovation\n        # H(xb) = H_vec . xb + d\n        H_of_xb = H_vec @ xb + d\n        innovation = y - H_of_xb\n        \n        # 5. Compute the analysis state xa\n        # K is a (3,1) column vector, must flatten to add to (3,) xb\n        xa = xb + K.flatten() * innovation\n        \n        # 6. Store the result for the shallowest node\n        # Round to three decimal places as required\n        results.append(round(xa[0], 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}