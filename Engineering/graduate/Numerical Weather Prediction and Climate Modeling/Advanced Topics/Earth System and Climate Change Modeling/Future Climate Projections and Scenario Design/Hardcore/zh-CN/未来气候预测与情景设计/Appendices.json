{
    "hands_on_practices": [
        {
            "introduction": "单箱能量平衡模型 (one-box energy balance model) 是理解全球温度如何响应辐射强迫的基石。本练习邀请您解析求解一个突变强迫情景下的该模型，这是一个气候科学中的经典思想实验。通过从第一性原理推导温度随时间的变化，您将亲身体会气候系统如何趋近新的平衡态，并理解系统内在调整时间尺度的物理意义 。",
            "id": "4047383",
            "problem": "在未来气候预测中，一个常用的教学和情景设计工具是全球平均单箱能量平衡模型，它代表了混合层海洋-大气系统的能量守恒。设全球平均热容为 $C$（单位为 $\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$），净气候反馈参数为 $\\lambda$（单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$），外部施加的辐射强迫为 $F(t)$（单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$）。能量守恒意味着全球平均温度异常 $T(t)$（单位为 $\\mathrm{K}$）满足 $C\\,\\frac{dT}{dt}=F(t)-\\lambda\\,T(t)$。\n\n考虑一个情景设计实验，在时间 $t=0$ 时施加一个突变的强迫阶跃，这代表了向一个新的强迫水平的理想化过渡，用于探测瞬态和平衡响应。具体来说，假设 $F(t)=F_{0}\\,H(t)$，其中 $F_{0}>0$ 是一个常数，$H(t)$ 是亥维赛阶跃函数。假设在阶跃之前，系统处于平衡状态，异常为零，即对于 $t\\le 0$ 有 $T(t)=0$。\n\n从上述能量守恒陈述出发，且不使用任何预先推导的解公式，解析地求解当 $t\\ge 0$ 时的 $T(t)$。然后定义内在调整时间尺度 $\\tau=C/\\lambda$ 并计算 $T(3\\tau)$。以 $\\mathrm{K}$ 为单位表示最终的温度变化。如果您选择将最终结果保留为封闭形式，请不要对其进行数值近似。",
            "solution": "首先将根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n问题陈述中提供了以下信息：\n-   **控制方程**：全球平均温度异常 $T(t)$ 由能量守恒方程 $C\\,\\frac{dT}{dt}=F(t)-\\lambda\\,T(t)$ 控制。\n-   **常数和变量**：\n    -   $C$：全球平均热容（$\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$）。\n    -   $\\lambda$：净气候反馈参数（$\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$）。\n    -   $F(t)$：外部施加的辐射强迫（$\\mathrm{W}\\,\\mathrm{m}^{-2}$）。\n    -   $T(t)$：全球平均温度异常（$\\mathrm{K}$）。\n-   **强迫情景**：辐射强迫是一个突变的阶跃函数，$F(t)=F_{0}\\,H(t)$，其中 $F_{0}>0$ 是一个常数，$H(t)$ 是亥维赛阶跃函数。\n-   **初始条件**：当 $t \\le 0$ 时，系统处于平衡状态，异常为零，即对于 $t \\le 0$ 有 $T(t)=0$。这意味着具体的初始条件为 $T(0)=0$。\n-   **目标**：\n    1.  解析地求解当 $t\\ge 0$ 时的 $T(t)$。\n    2.  定义时间尺度 $\\tau=C/\\lambda$。\n    3.  计算 $T(3\\tau)$ 的值。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题的有效性进行评估。\n\n-   **科学依据**：单箱能量平衡模型是简化气候动力学的基石。方程 $C\\,\\frac{dT}{dt}=F(t)-\\lambda\\,T(t)$ 是一个标准的、基于物理的公式，表示热量储存率（$C\\,\\frac{dT}{dt}$）、外部能量输入（$F(t)$）和辐射阻尼（$-\\lambda\\,T(t)$）之间的平衡，这是斯蒂芬-玻尔兹曼定律的线性化。该模型对于其预期的教学和概念目的在科学上是合理的。\n-   **适定性**：该问题指定了一个一阶线性常微分方程（ODE），具有给定的强迫函数和明确的初始条件（$T(0)=0$）。这构成了一个适定的初值问题，保证了唯一且稳定解的存在。\n-   **客观性**：问题陈述使用了精确、无歧义的数学和物理术语。\n-   **量纲一致性**：单位是一致的。项 $C\\,\\frac{dT}{dt}$ 的单位为 $(\\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}) \\cdot (\\mathrm{K}\\,\\mathrm{s}^{-1}) = \\mathrm{J}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1} = \\mathrm{W}\\,\\mathrm{m}^{-2}$。强迫项 $F(t)$ 和反馈项 $\\lambda\\,T(t)$ 的单位也都是 $\\mathrm{W}\\,\\mathrm{m}^{-2}$，正如方程所要求的。\n\n该问题不违反任何无效标准。它具有科学依据、是适定的、客观的、完整的和一致的。\n\n### 步骤 3：结论和行动\n该问题被认为是**有效的**。现在将推导完整的解析解。\n\n### 解的推导\n控制微分方程为：\n$$C\\,\\frac{dT}{dt}=F(t)-\\lambda\\,T(t)$$\n对于 $t \\ge 0$，强迫为 $F(t) = F_{0}\\,H(t) = F_{0}$，因为当 $t>0$ 时 $H(t)=1$。方程变为：\n$$C\\,\\frac{dT}{dt} = F_{0} - \\lambda\\,T(t)$$\n这是一个一阶线性非齐次常微分方程。我们可以将其整理为标准形式 $\\frac{dy}{dx} + P(x)y = Q(x)$：\n$$\\frac{dT}{dt} + \\frac{\\lambda}{C}\\,T(t) = \\frac{F_{0}}{C}$$\n这个方程可以使用积分因子法求解。积分因子 $I(t)$ 由下式给出：\n$$I(t) = \\exp\\left(\\int \\frac{\\lambda}{C} \\, dt\\right) = \\exp\\left(\\frac{\\lambda}{C}t\\right)$$\n将标准形式的方程乘以积分因子 $I(t)$ 得到：\n$$\\exp\\left(\\frac{\\lambda}{C}t\\right)\\frac{dT}{dt} + \\frac{\\lambda}{C}\\exp\\left(\\frac{\\lambda}{C}t\\right)T(t) = \\frac{F_{0}}{C}\\exp\\left(\\frac{\\lambda}{C}t\\right)$$\n左侧是乘积 $T(t)I(t)$ 的导数：\n$$\\frac{d}{dt}\\left[T(t)\\exp\\left(\\frac{\\lambda}{C}t\\right)\\right] = \\frac{F_{0}}{C}\\exp\\left(\\frac{\\lambda}{C}t\\right)$$\n对两边关于 $t$ 积分：\n$$\\int \\frac{d}{dt}\\left[T(t)\\exp\\left(\\frac{\\lambda}{C}t\\right)\\right] dt = \\int \\frac{F_{0}}{C}\\exp\\left(\\frac{\\lambda}{C}t\\right) dt$$\n$$T(t)\\exp\\left(\\frac{\\lambda}{C}t\\right) = \\frac{F_{0}}{C} \\left(\\frac{C}{\\lambda}\\right) \\exp\\left(\\frac{\\lambda}{C}t\\right) + K$$\n其中 $K$ 是积分常数。\n$$T(t)\\exp\\left(\\frac{\\lambda}{C}t\\right) = \\frac{F_{0}}{\\lambda}\\exp\\left(\\frac{\\lambda}{C}t\\right) + K$$\n乘以 $\\exp\\left(-\\frac{\\lambda}{C}t\\right)$ 求解 $T(t)$：\n$$T(t) = \\frac{F_{0}}{\\lambda} + K\\exp\\left(-\\frac{\\lambda}{C}t\\right)$$\n为了确定常数 $K$，我们应用初始条件 $T(0)=0$。\n$$T(0) = 0 = \\frac{F_{0}}{\\lambda} + K\\exp(0)$$\n$$0 = \\frac{F_{0}}{\\lambda} + K \\implies K = -\\frac{F_{0}}{\\lambda}$$\n将 $K$ 的值代回通解，得到当 $t \\ge 0$ 时 $T(t)$ 的特解：\n$$T(t) = \\frac{F_{0}}{\\lambda} - \\frac{F_{0}}{\\lambda}\\exp\\left(-\\frac{\\lambda}{C}t\\right)$$\n$$T(t) = \\frac{F_{0}}{\\lambda}\\left(1 - \\exp\\left(-\\frac{\\lambda}{C}t\\right)\\right)$$\n这是温度异常作为时间函数的解析解。\n\n接下来，我们定义内在调整时间尺度 $\\tau = C/\\lambda$。我们可以将其代入 $T(t)$ 的解中：\n$$T(t) = \\frac{F_{0}}{\\lambda}\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right)$$\n问题要求计算 $T(3\\tau)$。我们将 $t=3\\tau$ 代入此表达式：\n$$T(3\\tau) = \\frac{F_{0}}{\\lambda}\\left(1 - \\exp\\left(-\\frac{3\\tau}{\\tau}\\right)\\right)$$\n$$T(3\\tau) = \\frac{F_{0}}{\\lambda}\\left(1 - \\exp(-3)\\right)$$\n这是在时间 $t=3\\tau$ 时温度异常的最终解析表达式。单位是开尔文（$\\mathrm{K}$），正如对 $T(t)$ 所规定的。",
            "answer": "$$\\boxed{\\frac{F_{0}}{\\lambda}\\left(1 - \\exp(-3)\\right)}$$"
        },
        {
            "introduction": "虽然解析模型能提供深刻见解，但现实中的气候科学通常涉及分析复杂的数值模拟。本练习将介绍格雷戈里回归 (Gregory regression)，这是一种从模型输出中估算基本气候参数（如反馈参数 $\\lambda$ 和平衡态气候敏感度 $\\mathrm{ECS}$）的强大技术。通过处理模拟全球气候模型 (GCM) 实验的合成数据，您不仅将学会执行回归分析，还将学习如何量化这些关键估算值的不确定性，这是任何严谨科学分析中的一项至关重要的技能 。",
            "id": "4047350",
            "problem": "提供给您一组来自突变强迫模型实验的合成全球年平均时间序列，包括大气层顶净辐射不平衡 $N(t)$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$）和全球平均地表温度异常 $T(t)$（单位：$\\mathrm{K}$）。您的任务是使用 Gregory 回归估计气候反馈参数 $\\lambda$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$）和二氧化碳加倍后的有效辐射强迫 $F_{2\\times \\mathrm{CO}_2}$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$），并量化平衡气候敏感度（ECS）的不确定性。ECS 定义为在施加的强迫下，净辐射不平衡恢复到零时的平衡温度异常（单位：$\\mathrm{K}$）。\n\n基本原理：\n- 大气层顶的能量守恒意味着净辐射不平衡 $N(t)$ 等于行星热含量的变化率，当系统获得热量时，该变化率为非负值。在外部施加的辐射强迫发生阶跃变化（例如二氧化碳突然加倍）的情况下，广泛使用的线性反馈近似将外部施加的强迫与对温度的辐射响应联系起来。\n- 在一个单箱能量平衡框架中，$T(t)$ 在阶跃强迫后的瞬态演变可以通过一个指数函数很好地近似，该函数趋向于一个平衡值，其特征是单一的 e-折叠时间尺度。\n\n对于每个测试用例 $i$，合成数据按以下方式生成：\n- 给定参数 $(F_i, \\lambda_i, \\tau_i, n_i, \\sigma_{T,i}, \\sigma_{N,i}, s_i)$，其中 $F_i$ 是施加的有效辐射强迫（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$），$\\lambda_i$ 是气候反馈参数（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$），$\\tau_i$ 是特征 e-折叠时间尺度（单位：年），$n_i$ 是年数，$\\sigma_{T,i}$ 是温度内部变率噪声的标准差（单位：$\\mathrm{K}$），$\\sigma_{N,i}$ 是净不平衡内部变率噪声的标准差（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$），$s_i$ 是用于可复现性的随机种子。\n- 定义 $T_{\\mathrm{eq},i} = F_i / \\lambda_i$（单位：$\\mathrm{K}$）。\n- 对于整数 $t = 1, 2, \\dots, n_i$（单位：年），\n  - 使用种子 $s_i$ 初始化随机数生成器，抽取独立的高斯噪声 $\\eta_t \\sim \\mathcal{N}(0, \\sigma_{T,i}^2)$ 和 $\\xi_t \\sim \\mathcal{N}(0, \\sigma_{N,i}^2)$。\n  - 设置 $T_i(t) = T_{\\mathrm{eq},i}\\left(1 - \\exp\\left(-t / \\tau_i\\right)\\right) + \\eta_t$（单位：$\\mathrm{K}$）。\n  - 设置 $N_i(t) = F_i - \\lambda_i T_i(t) + \\xi_t$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$）。\n\n任务：\n1. 对于每个测试用例，通过普通最小二乘法对 $(T_i(t), N_i(t))$ 的散点图进行拟合一条直线，从而执行 Gregory 回归。其中 $N_i(t)$ 作为响应变量，$T_i(t)$ 作为预测变量，使用模型 $N_i(t) = a_i + b_i T_i(t) + \\varepsilon_t$，其中 $\\varepsilon_t$ 捕获残余变率。根据拟合系数，解释 $\\hat{F}_i = a_i$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$）和 $\\hat{\\lambda}_i = -b_i$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$）。\n2. 对每个测试用例，估计平衡气候敏感度为 $\\widehat{\\mathrm{ECS}}_i = \\hat{F}_i / \\hat{\\lambda}_i$（单位：$\\mathrm{K}$）。通过传播 $(a_i, b_i)$ 的普通最小二乘法参数不确定性，使用一阶（delta 方法）正态近似来量化 $\\widehat{\\mathrm{ECS}}_i$ 的不确定性，以获得一个双边 $95\\%$ 置信区间 $[\\mathrm{ECS}^{\\mathrm{L}}_i, \\mathrm{ECS}^{\\mathrm{U}}_i]$（单位：$\\mathrm{K}$）。将下界和上界表示为小数。\n3. 对于每个测试用例，报告五个量 $[\\hat{\\lambda}_i, \\hat{F}_i, \\widehat{\\mathrm{ECS}}_i, \\mathrm{ECS}^{\\mathrm{L}}_i, \\mathrm{ECS}^{\\mathrm{U}}_i]$，每个值四舍五入到三位小数。\n\n测试套件：\n- 用例 1：$(F_1, \\lambda_1, \\tau_1, n_1, \\sigma_{T,1}, \\sigma_{N,1}, s_1) = (3.71, 1.00, 4.00, 60, 0.05, 0.15, 17)$。\n- 用例 2：$(F_2, \\lambda_2, \\tau_2, n_2, \\sigma_{T,2}, \\sigma_{N,2}, s_2) = (3.50, 1.20, 3.00, 50, 0.00, 0.00, 0)$。\n- 用例 3：$(F_3, \\lambda_3, \\tau_3, n_3, \\sigma_{T,3}, \\sigma_{N,3}, s_3) = (3.80, 0.90, 10.00, 15, 0.10, 0.30, 123)$。\n\n物理单位：\n- 以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$ 为单位报告 $\\hat{\\lambda}_i$。\n- 以 $\\mathrm{W}\\,\\mathrm{m}^{-2}$ 为单位报告 $\\hat{F}_i$。\n- 以 $\\mathrm{K}$ 为单位报告 $\\widehat{\\mathrm{ECS}}_i$、$\\mathrm{ECS}^{\\mathrm{L}}_i$ 和 $\\mathrm{ECS}^{\\mathrm{U}}_i$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个按 $[\\hat{\\lambda}_i, \\hat{F}_i, \\widehat{\\mathrm{ECS}}_i, \\mathrm{ECS}^{\\mathrm{L}}_i, \\mathrm{ECS}^{\\mathrm{U}}_i]$ 顺序排列的方括号列表。例如，输出应类似于 $[[x_1,x_2,x_3,x_4,x_5],[y_1,y_2,y_3,y_4,y_5],[z_1,z_2,z_3,z_4,z_5]]$，其中每个值都按规定四舍五入到三位小数。",
            "solution": "我们的分析基于气候建模中使用的行星能量平衡和线性辐射反馈概念。大气层顶净辐射不平衡 $N(t)$ 代表在时间 $t$ 进入地球系统的净能量通量，能量守恒意味着 $N(t)$ 等于热含量的变化率。在外部施加的辐射强迫发生阶跃增加的情况下，许多综合气候模型和简单的能量平衡模型都表现出外部施加的强迫与对地表温度变化的辐射响应之间存在近似线性的关系。这为在瞬态响应期间将 $N(t)$ 和 $T(t)$ 之间的关系视为近似线性提供了依据。\n\n出发点：在 $t = 0$ 时施加一个阶跃强迫 $F$，一个具有有效热容 $C$ 和气候反馈参数 $\\lambda$ 的单箱能量平衡模型遵循\n$$\nC \\frac{dT}{dt} = F - \\lambda T\n$$\n这个常微分方程的解是\n$$\nT(t) = T_{\\mathrm{eq}}\\left(1 - e^{-t/\\tau}\\right)\n$$\n其中 $T_{\\mathrm{eq}} = \\frac{F}{\\lambda}$ 是平衡温度异常，$\\tau = \\frac{C}{\\lambda}$ 是特征 e-折叠时间尺度。在瞬态调整期间，净辐射不平衡可以分解为外部施加的强迫减去与温度异常成正比的线性化反馈响应。将内部变率视为随机噪声，我们考虑由以下公式生成的合成可观测量：\n$$\nT(t) = T_{\\mathrm{eq}}\\left(1 - e^{-t/\\tau}\\right) + \\eta_t,\\quad \\eta_t \\sim \\mathcal{N}(0,\\sigma_T^2),\n$$\n$$\nN(t) = F - \\lambda T(t) + \\xi_t,\\quad \\xi_t \\sim \\mathcal{N}(0,\\sigma_N^2),\n$$\n其中 $\\eta_t$ 和 $\\xi_t$ 是独立的。这种构造通过满足能量平衡结构和在 $t \\to \\infty$ 时（无噪声情况下）趋近于 $N(t) \\to 0$ 来确保科学真实性，同时包含了合理的内部变率。\n\nGregory 回归：Gregory 方法通过将 $N(t)$ 对 $T(t)$ 进行回归来估计有效强迫和反馈。我们使用普通最小二乘法拟合线性模型\n$$\nN(t) = a + b\\,T(t) + \\varepsilon_t,\n$$\n其中 $a$ 是截距，$b$ 是斜率，$\\varepsilon_t$ 是残差项。从回归中解释物理参数，\n$$\n\\hat{F} = a,\\quad \\hat{\\lambda} = -b,\n$$\n因为其底层的物理关系近似为 $N \\approx F - \\lambda T$。平衡气候敏感度定义为 $N = 0$ 时的平衡温度异常，即\n$$\n\\widehat{\\mathrm{ECS}} = \\frac{\\hat{F}}{\\hat{\\lambda}}.\n$$\n\n普通最小二乘估计：设 $y \\in \\mathbb{R}^n$ 表示 $n$ 年内 $N(t)$ 的向量，$x \\in \\mathbb{R}^n$ 表示 $T(t)$ 的向量。定义设计矩阵\n$$\nX = \\begin{bmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_n \\end{bmatrix},\n$$\n参数向量 $\\beta = \\begin{bmatrix} a \\\\ b \\end{bmatrix}$，以及模型 $y = X \\beta + \\varepsilon$。普通最小二乘估计量为\n$$\n\\hat{\\beta} = (X^\\top X)^{-1} X^\\top y\n$$\n得到 $\\hat{a}$ 和 $\\hat{b}$。残差为 $r = y - X \\hat{\\beta}$，残差方差由下式估计\n$$\n\\hat{\\sigma}^2 = \\frac{r^\\top r}{n - p},\n$$\n其中 $p = 2$ 是参数的数量。$\\hat{\\beta}$ 的估计协方差矩阵是\n$$\n\\widehat{\\mathrm{Cov}}(\\hat{\\beta}) = \\hat{\\sigma}^2 (X^\\top X)^{-1}.\n$$\n\n$\\widehat{\\mathrm{ECS}}$ 的不确定性量化：ECS 估计量是 $(\\hat{a}, \\hat{b})$ 的一个平滑函数：\n$$\ng(\\hat{a}, \\hat{b}) = \\frac{\\hat{F}}{\\hat{\\lambda}} = \\frac{\\hat{a}}{-\\hat{b}} = -\\frac{\\hat{a}}{\\hat{b}}\n$$\n根据 delta 方法（一阶泰勒近似），$g(\\hat{a}, \\hat{b})$ 的方差近似为\n$$\n\\mathrm{Var}\\left(g(\\hat{a}, \\hat{b})\\right) \\approx \\nabla g^\\top \\, \\widehat{\\mathrm{Cov}}(\\hat{\\beta}) \\, \\nabla g,\n$$\n其中梯度为\n$$\n\\nabla g = \\begin{bmatrix} \\frac{\\partial g}{\\partial \\hat{a}} \\\\ \\frac{\\partial g}{\\partial \\hat{b}} \\end{bmatrix} = \\begin{bmatrix} -\\frac{1}{\\hat{b}} \\\\ \\frac{\\hat{a}}{\\hat{b}^2} \\end{bmatrix}.\n$$\n因此，\n$$\n\\widehat{\\mathrm{SE}}(\\widehat{\\mathrm{ECS}}) = \\sqrt{\\mathrm{Var}\\left(g(\\hat{a}, \\hat{b})\\right)}.\n$$\n假设 $(\\hat{a}, \\hat{b})$ 的渐近正态性，ECS 的一个双边 $95\\%$ 置信区间为\n$$\n\\left[\\widehat{\\mathrm{ECS}} - 1.96\\,\\widehat{\\mathrm{SE}}(\\widehat{\\mathrm{ECS}}),\\ \\widehat{\\mathrm{ECS}} + 1.96\\,\\widehat{\\mathrm{SE}}(\\widehat{\\mathrm{ECS}})\\right].\n$$\n\n每个测试用例的算法步骤：\n1. 根据上述方程，使用提供的 $(F, \\lambda, \\tau, n, \\sigma_T, \\sigma_N, s)$ 生成 $T(t)$ 和 $N(t)$ 序列，确保高斯噪声项具有指定的标准差和随机种子并且是独立的。\n2. 构造 $X$ 并通过正规方程使用普通最小二乘法计算 $\\hat{\\beta} = (\\hat{a}, \\hat{b})^\\top$。\n3. 计算 $\\hat{F} = \\hat{a}$ 和 $\\hat{\\lambda} = -\\hat{b}$。\n4. 计算 $\\widehat{\\mathrm{ECS}} = \\hat{F} / \\hat{\\lambda}$。\n5. 从残差方差和 $(X^\\top X)^{-1}$ 计算 $\\widehat{\\mathrm{Cov}}(\\hat{\\beta})$。\n6. 计算在 $(\\hat{a}, \\hat{b})$ 处的梯度 $\\nabla g$，通过 delta 方法计算标准误，并计算 $95\\%$ 置信区间界限。\n7. 将 $\\hat{\\lambda}$、$\\hat{F}$、$\\widehat{\\mathrm{ECS}}$ 以及置信区间的下界和上界四舍五入到三位小数。\n8. 将所有测试用例的结果聚合成指定的单行输出格式：一个由方括号括起来的、逗号分隔的列表的列表，每个子列表对应一个测试用例，顺序为 $[\\hat{\\lambda}, \\hat{F}, \\widehat{\\mathrm{ECS}}, \\mathrm{ECS}^{\\mathrm{L}}, \\mathrm{ECS}^{\\mathrm{U}}]$。\n\n该设计清晰地整合了物理基础（能量平衡和线性反馈）、统计估计器（普通最小二乘法）和不确定性量化（delta 方法），从而从瞬态模型实验数据中生成具有量化不确定性的、科学上可解释的 ECS 估计值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_synthetic_data(F, lam, tau, n_years, sigma_T, sigma_N, seed):\n    \"\"\"\n    Generate synthetic annual mean time series T(t) [K] and N(t) [W/m^2]\n    following a one-box EBM transient with internal variability noise.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    t = np.arange(1, n_years + 1, dtype=float)  # years since forcing\n    T_eq = F / lam  # equilibrium temperature [K]\n    T_clean = T_eq * (1.0 - np.exp(-t / tau))\n    # Draw independent noise sequences\n    eta = rng.normal(0.0, sigma_T, size=n_years) if sigma_T > 0 else np.zeros(n_years)\n    xi = rng.normal(0.0, sigma_N, size=n_years) if sigma_N > 0 else np.zeros(n_years)\n    T = T_clean + eta\n    N = F - lam * T + xi\n    return T, N\n\ndef ols_regression_with_cov(x, y):\n    \"\"\"\n    Perform OLS regression of y on x with intercept: y = a + b x + eps.\n    Returns a_hat, b_hat, cov_beta (2x2 covariance matrix), residual variance.\n    \"\"\"\n    n = len(x)\n    X = np.column_stack([np.ones(n), x])\n    # OLS solution\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    beta_hat = XtX_inv @ (X.T @ y)\n    a_hat, b_hat = beta_hat[0], beta_hat[1]\n    # Residuals and variance estimate\n    residuals = y - X @ beta_hat\n    dof = n - 2  # two parameters\n    # If dof = 0 (n = 2), avoid division by zero: set variance to NaN\n    if dof > 0:\n        sigma2_hat = (residuals @ residuals) / dof\n    else:\n        sigma2_hat = np.nan\n    cov_beta = sigma2_hat * XtX_inv\n    return a_hat, b_hat, cov_beta, sigma2_hat\n\ndef ecs_with_uncertainty(a_hat, b_hat, cov_beta):\n    \"\"\"\n    Compute ECS = -a_hat / b_hat and 95% CI using delta method.\n    cov_beta is 2x2 covariance matrix of [a, b].\n    Returns ECS_hat, ECS_lower, ECS_upper.\n    \"\"\"\n    # Map to physical parameters\n    F_hat = a_hat\n    lam_hat = -b_hat\n    # ECS estimate\n    ecs_hat = F_hat / lam_hat  # = -a_hat / b_hat\n    # Delta method: g(a,b) = -a/b\n    # gradient: [-1/b, a/b^2]\n    # Handle potential near-zero b_hat\n    if np.isfinite(cov_beta).all() and b_hat != 0.0:\n        grad = np.array([-1.0 / b_hat, a_hat / (b_hat ** 2)])\n        var_g = grad @ cov_beta @ grad\n        # Numerical safety: var_g should be non-negative\n        if var_g  0:\n            # Clamp to zero if negative due to numerical round-off\n            var_g = 0.0\n        se_g = np.sqrt(var_g)\n        lower = ecs_hat - 1.96 * se_g\n        upper = ecs_hat + 1.96 * se_g\n    else:\n        # If covariance is invalid or slope is zero, return NaNs for CI\n        lower = np.nan\n        upper = np.nan\n    return ecs_hat, lower, upper\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (F [W/m^2], lambda [W/m^2/K], tau [yr], n_years, sigma_T [K], sigma_N [W/m^2], seed)\n    test_cases = [\n        (3.71, 1.00, 4.00, 60, 0.05, 0.15, 17),\n        (3.50, 1.20, 3.00, 50, 0.00, 0.00, 0),\n        (3.80, 0.90, 10.00, 15, 0.10, 0.30, 123),\n    ]\n\n    results = []\n    for F, lam, tau, n, sigma_T, sigma_N, seed in test_cases:\n        # Generate synthetic data for this case\n        T, N = generate_synthetic_data(F, lam, tau, n, sigma_T, sigma_N, seed)\n        # Perform OLS regression: N = a + b T\n        a_hat, b_hat, cov_beta, _ = ols_regression_with_cov(T, N)\n        # Map to physical parameters\n        F_hat = a_hat\n        lam_hat = -b_hat\n        # Compute ECS and uncertainty\n        ecs_hat, ecs_lower, ecs_upper = ecs_with_uncertainty(a_hat, b_hat, cov_beta)\n        # Round to three decimals as specified\n        vals = [\n            round(lam_hat, 3),\n            round(F_hat, 3),\n            round(ecs_hat, 3),\n            round(ecs_lower, 3) if np.isfinite(ecs_lower) else float('nan'),\n            round(ecs_upper, 3) if np.isfinite(ecs_upper) else float('nan'),\n        ]\n        results.append(vals)\n\n    # Final print statement in the exact required format.\n    # Produce a single line: a bracketed comma-separated list of lists.\n    def fmt_list(lst):\n        return \"[\" + \",\".join(map(lambda v: \"nan\" if (isinstance(v, float) and np.isnan(v)) else f\"{v}\", lst)) + \"]\"\n\n    print(\"[\" + \",\".join(fmt_list(res) for res in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "气候科学的一个关键挑战是不同气候模型预测结果之间存在的巨大差异所导致的不确定性。这项高级练习将探讨“涌现约束” (emergent constraint) 方法，这是一种减少这种不确定性的前沿手段。您将实现一个统计框架，该框架利用多模型集合中一个当前可观测变量与未来预测之间的关系，并结合一个带有不确定性的真实世界观测值，来约束未来可能的结果，从而获得更可靠的“受约束”预测。此练习展示了如何超越简单的模型平均，从而生成更稳健、更可靠的气候预测 。",
            "id": "4047342",
            "problem": "给你一个气候模拟中涌现约束的概念性设置：在多个全球气候模型（GCMs）中，一个当代可观测量 $X$（无量纲，例如，一个与反照率相关的指标）和一个未来响应变量 $Y$（例如，雪-反照率反馈强度）被配对为 $(X_i, Y_i)$，其中 $i = 1, \\dots, n$。涌现约束假定，$X$ 的系统性模型间差异通过一个具有物理动机且可进行统计检验的关系来解释 $Y$ 的模型间差异。假设跨模型存在一个线性模型，$Y_i = a + b\\,X_i + \\varepsilon_i$，其中 $\\varepsilon_i$ 是均值为零、方差相同的同方差高斯噪声，$a$ 和 $b$ 是未知系数。你观测到带有测量不确定性的真实世界当代量，$X^\\star \\sim \\mathcal{N}(x_{\\mathrm{obs}}, s_x^2)$，其中 $x_{\\mathrm{obs}}$ 是观测值，$s_x$ 是其不确定性的标准差。任务是利用模型集合和观测所蕴含的涌现约束，来量化真实世界未来量 $Y^\\star$ 的受约束的预估不确定性。\n\n从统计推断的第一性原理（适用于高斯似然和无信息先验的贝叶斯定理）、作为线性高斯模型最大似然估计的普通最小二乘法 (OLS) 估计，以及全期望定律和全方差定律出发，推导并实现一个方法来：\n- 估计跨模型中 $X$ 和 $Y$ 之间的线性关系。\n- 构建在不确定的真实世界 $X^\\star \\sim \\mathcal{N}(x_{\\mathrm{obs}}, s_x^2)$ 条件下 $Y^\\star$ 的后验预测分布。\n- 通过 $Y^\\star$ 的预测均值和预测标准差来量化受约束的预估不确定性。\n- 通过跨模型 $Y_i$ 的样本标准差来量化未受约束的预估不确定性，并报告定义为受约束的预测标准差与未受约束的集合标准差之比的缩减因子。\n\n所有涉及 $Y$ 的输出必须以 $\\mathrm{W\\,m^{-2}\\,K^{-1}}$ 为单位，并且是浮点数。缩减因子必须表示为浮点小数（无单位）。本问题不涉及角度。\n\n实现一个完整的 Python 程序，为每个测试用例计算 $Y^\\star$ 的受约束的预测均值、$Y^\\star$ 的受约束的预测标准差以及缩减因子（受约束的标准差除以未受约束的集合标准差）。该程序不应读取任何输入，且必须能直接运行。\n\n使用以下参数值的测试套件，涵盖一系列场景，包括高相关性情况、弱相关性情况、零测量不确定性的边界情况以及大测量不确定性情况。在每种情况下，$X$ 是无量纲的，$Y$ 的单位是 $\\mathrm{W\\,m^{-2}\\,K^{-1}}$：\n\n- 测试用例 1 (高相关性，小测量不确定性):\n  - $X = [\\,0.2,\\,0.4,\\,0.6,\\,0.8,\\,1.0,\\,0.3,\\,0.7,\\,0.9\\,]$\n  - $Y = [\\,0.98,\\,1.25,\\,1.73,\\,2.08,\\,2.51,\\,1.10,\\,1.86,\\,2.32\\,]$，单位 $\\mathrm{W\\,m^{-2}\\,K^{-1}}$\n  - $x_{\\mathrm{obs}} = 0.65$\n  - $s_x = 0.05$\n\n- 测试用例 2 (弱相关性，可比噪声):\n  - $X = [\\,0.1,\\,0.2,\\,0.5,\\,0.6,\\,0.8,\\,0.3,\\,0.4,\\,0.7,\\,0.9,\\,0.55\\,]$\n  - $Y = [\\,0.71,\\,1.27,\\,0.95,\\,1.26,\\,0.93,\\,1.08,\\,0.99,\\,1.17,\\,0.89,\\,1.205\\,]$，单位 $\\mathrm{W\\,m^{-2}\\,K^{-1}}$\n  - $x_{\\mathrm{obs}} = 0.50$\n  - $s_x = 0.05$\n\n- 测试用例 3 (边界情况：零测量不确定性且观测值位于集合均值处):\n  - $X = [\\,0.2,\\,0.3,\\,0.4,\\,0.5,\\,0.6\\,]$\n  - $Y = [\\,0.0,\\,0.05,\\,0.22,\\,0.27,\\,0.41\\,]$，单位 $\\mathrm{W\\,m^{-2}\\,K^{-1}}$\n  - $x_{\\mathrm{obs}} = 0.40$\n  - $s_x = 0.00$\n\n- 测试用例 4 (中等相关性，大测量不确定性):\n  - $X = [\\,0.2,\\,0.5,\\,0.7,\\,1.0,\\,0.3,\\,0.9\\,]$\n  - $Y = [\\,0.70,\\,0.85,\\,1.40,\\,1.65,\\,0.65,\\,1.65\\,]$，单位 $\\mathrm{W\\,m^{-2}\\,K^{-1}}$\n  - $x_{\\mathrm{obs}} = 0.60$\n  - $s_x = 0.20$\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个三元素浮点数列表，顺序为 $[\\,Y^\\star \\text{的预测均值},\\,Y^\\star \\text{的预测标准差},\\,\\text{缩减因子}\\,]$，所有数值均格式化为六位小数。例如，要求的格式为：$[[\\mu_1,\\sigma_1,r_1],[\\mu_2,\\sigma_2,r_2],[\\mu_3,\\sigma_3,r_3],[\\mu_4,\\sigma_4,r_4]]$。",
            "solution": "该问题要求推导并实现一种方法，使用从模型模拟集合中得出的涌现约束来计算未来气候变量 $Y^\\star$ 的受约束的预估不确定性。该约束是当代可观测量 $X$ 与未来变量 $Y$ 之间的线性关系。对当代量 $X^\\star$ 的真实世界观测是不确定的，并由一个高斯分布描述。\n\n推导过程分为三个主要阶段：首先，使用普通最小二乘法 (OLS) 从模型集合中估计线性关系；其次，通过线性模型传播来自 $X^\\star$ 观测的不确定性，从而推导出 $Y^\\star$ 的预测均值和方差；第三，量化不确定性的缩减程度。\n\n**1. 通过普通最小二乘法 (OLS) 估计线性关系**\n\n我们从一个气候模型集合中得到 $n$ 对数据点 $(X_i, Y_i)$。假设的线性模型是：\n$$\nY_i = a + b\\,X_i + \\varepsilon_i\n$$\n其中 $a$ 和 $b$ 分别是截距和斜率系数，$\\varepsilon_i$ 是来自均值为零、方差为 $\\sigma^2$ 的高斯分布的独立同分布随机误差，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n\nOLS 方法通过最小化残差平方和来找到系数的估计值 $\\hat{a}$ 和 $\\hat{b}$。在高斯误差假设下，这些估计值也是最大似然估计。它们由以下公式给出：\n$$\n\\hat{b} = \\frac{\\sum_{i=1}^n (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sum_{i=1}^n (X_i - \\bar{X})^2} = \\frac{S_{XY}}{S_{XX}}\n$$\n$$\n\\hat{a} = \\bar{Y} - \\hat{b}\\,\\bar{X}\n$$\n其中 $\\bar{X} = \\frac{1}{n}\\sum_{i=1}^n X_i$ 和 $\\bar{Y} = \\frac{1}{n}\\sum_{i=1}^n Y_i$ 是样本均值。\n\n残差的方差 $\\sigma^2$ 代表了模型围绕回归线的散布程度（一种模型结构不确定性的形式），它通过其无偏估计量 $\\hat{\\sigma}^2$ 来估计：\n$$\n\\hat{\\sigma}^2 = \\frac{1}{n-2} \\sum_{i=1}^n (Y_i - (\\hat{a} + \\hat{b}\\,X_i))^2\n$$\n分母是 $n-2$，因为估计两个参数 $\\hat{a}$ 和 $\\hat{b}$ 用掉了两个自由度。\n\n**2. 受约束预测分布的推导**\n\n我们的任务是基于对真实世界当代量 $X^\\star$ 的不确定观测来预测真实世界的未来量 $Y^\\star$。该观测以分布形式给出：$X^\\star \\sim \\mathcal{N}(x_{\\mathrm{obs}}, s_x^2)$。量 $Y^\\star$ 通过模型 $Y^\\star = \\hat{a} + \\hat{b}\\,X^\\star$ 与 $X^\\star$ 相关，但这个预测本身是不确定的。\n\n$Y^\\star$ 预测的总不确定性源于三个来源：(1) 模型关系内在的“结构性”不确定性，由 $\\hat{\\sigma}^2$ 捕捉；(2) 估计的回归参数 $\\hat{a}$ 和 $\\hat{b}$ 的不确定性；以及 (3) 预测变量 $X^\\star$ 的不确定性，由 $s_x^2$ 捕捉。\n\n为了找到 $Y^\\star$ 的后验预测分布的均值和方差，我们使用全期望定律和全方差定律。\n\n**$Y^\\star$ 的预测均值**\n全期望定律表明 $\\mathbb{E}[Y^\\star] = \\mathbb{E}_{X^\\star}[\\mathbb{E}[Y^\\star | X^\\star]]$。\n内层期望是对于给定的 $X^\\star$ 值，$Y^\\star$ 的预测值：\n$$\n\\mathbb{E}[Y^\\star | X^\\star = x] = \\hat{a} + \\hat{b}\\,x\n$$\n对 $X^\\star$ 的分布取外层期望：\n$$\n\\mu_{Y^\\star} = \\mathbb{E}[Y^\\star] = \\mathbb{E}_{X^\\star}[\\hat{a} + \\hat{b}\\,X^\\star] = \\hat{a} + \\hat{b}\\,\\mathbb{E}[X^\\star]\n$$\n由于 $\\mathbb{E}[X^\\star] = x_{\\mathrm{obs}}$，预测均值为：\n$$\n\\mu_{Y^\\star} = \\hat{a} + \\hat{b}\\,x_{\\mathrm{obs}}\n$$\n\n**$Y^\\star$ 的预测方差**\n全方差定律表明 $\\mathrm{Var}[Y^\\star] = \\mathbb{E}_{X^\\star}[\\mathrm{Var}[Y^\\star | X^\\star]] + \\mathrm{Var}_{X^\\star}[\\mathbb{E}[Y^\\star | X^\\star]]$。\n\n第一项 $\\mathbb{E}_{X^\\star}[\\mathrm{Var}[Y^\\star | X^\\star]]$ 代表平均预测不确定性。对于一个位于*已知*点 $x$ 的*单个新观测*，其预测方差由以下公式给出：\n$$\n\\mathrm{Var}[Y^\\star | X^\\star=x] = \\hat{\\sigma}^2 \\left( 1 + \\frac{1}{n} + \\frac{(x - \\bar{X})^2}{S_{XX}} \\right)\n$$\n这个表达式既考虑了残差方差（$\\hat{\\sigma}^2$），也考虑了估计的回归线本身的不确定性（包含 $1/n$ 和 $(x - \\bar{X})^2/S_{XX}$ 的项）。我们现在对 $X^\\star$ 的分布对此表达式求平均：\n$$\n\\mathbb{E}_{X^\\star}[\\mathrm{Var}[Y^\\star | X^\\star]] = \\mathbb{E}_{X^\\star} \\left[ \\hat{\\sigma}^2 \\left( 1 + \\frac{1}{n} + \\frac{(X^\\star - \\bar{X})^2}{S_{XX}} \\right) \\right]\n$$\n$$\n= \\hat{\\sigma}^2 \\left( 1 + \\frac{1}{n} \\right) + \\frac{\\hat{\\sigma}^2}{S_{XX}} \\mathbb{E}_{X^\\star}[(X^\\star - \\bar{X})^2]\n$$\n期望 $\\mathbb{E}[(X^\\star - \\bar{X})^2]$ 可以展开为 $\\mathbb{E}[(X^\\star - x_{\\mathrm{obs}} + x_{\\mathrm{obs}} - \\bar{X})^2] = \\mathbb{E}[(X^\\star-x_{\\mathrm{obs}})^2] + (x_{\\mathrm{obs}}-\\bar{X})^2 = s_x^2 + (x_{\\mathrm{obs}}-\\bar{X})^2$。\n因此，总方差的第一项是：\n$$\n\\mathbb{E}_{X^\\star}[\\mathrm{Var}[Y^\\star | X^\\star]] = \\hat{\\sigma}^2 \\left( 1 + \\frac{1}{n} + \\frac{s_x^2 + (x_{\\mathrm{obs}} - \\bar{X})^2}{S_{XX}} \\right)\n$$\n\n第二项 $\\mathrm{Var}_{X^\\star}[\\mathbb{E}[Y^\\star | X^\\star]]$ 代表由于预测变量 $X^\\star$ 的不确定性而导致的均值预测的不确定性。\n$$\n\\mathrm{Var}_{X^\\star}[\\mathbb{E}[Y^\\star | X^\\star]] = \\mathrm{Var}_{X^\\star}[\\hat{a} + \\hat{b}\\,X^\\star] = \\hat{b}^2\\,\\mathrm{Var}[X^\\star]\n$$\n由于 $\\mathrm{Var}[X^\\star] = s_x^2$，该项为：\n$$\n\\mathrm{Var}_{X^\\star}[\\mathbb{E}[Y^\\star | X^\\star]] = \\hat{b}^2 s_x^2\n$$\n\n结合这两项，总预测方差 $\\sigma^2_{Y^\\star}$ 为：\n$$\n\\sigma^2_{Y^\\star} = \\hat{\\sigma}^2 \\left( 1 + \\frac{1}{n} + \\frac{(x_{\\mathrm{obs}} - \\bar{X})^2 + s_x^2}{S_{XX}} \\right) + \\hat{b}^2 s_x^2\n$$\n受约束的预测标准差是 $\\sigma_{Y^\\star} = \\sqrt{\\sigma^2_{Y^\\star}}$。\n\n**3. 未受约束的不确定性和缩减因子**\n\n未受约束的预估不确定性定义为未来响应变量 $Y$ 在原始模型集合中的散布程度，通过样本标准差来量化：\n$$\ns_Y = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (Y_i - \\bar{Y})^2}\n$$\n缩减因子 $R$ 量化了涌现约束带来的益处。它是受约束的预测标准差与未受约束的集合标准差之比：\n$$\nR = \\frac{\\sigma_{Y^\\star}}{s_Y}\n$$\n$R  1$ 的值表明该约束成功地减少了预估不确定性。\n\n该实现将遵循这些推导出的公式，为每个给定的测试用例计算 $(\\mu_{Y^\\star}, \\sigma_{Y^\\star}, R)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes constrained projections and uncertainty reduction for a series of test cases\n    based on the emergent constraint methodology.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"X\": [0.2, 0.4, 0.6, 0.8, 1.0, 0.3, 0.7, 0.9],\n            \"Y\": [0.98, 1.25, 1.73, 2.08, 2.51, 1.10, 1.86, 2.32],\n            \"x_obs\": 0.65,\n            \"s_x\": 0.05,\n        },\n        {\n            \"X\": [0.1, 0.2, 0.5, 0.6, 0.8, 0.3, 0.4, 0.7, 0.9, 0.55],\n            \"Y\": [0.71, 1.27, 0.95, 1.26, 0.93, 1.08, 0.99, 1.17, 0.89, 1.205],\n            \"x_obs\": 0.50,\n            \"s_x\": 0.05,\n        },\n        {\n            \"X\": [0.2, 0.3, 0.4, 0.5, 0.6],\n            \"Y\": [0.0, 0.05, 0.22, 0.27, 0.41],\n            \"x_obs\": 0.40,\n            \"s_x\": 0.00,\n        },\n        {\n            \"X\": [0.2, 0.5, 0.7, 1.0, 0.3, 0.9],\n            \"Y\": [0.70, 0.85, 1.40, 1.65, 0.65, 1.65],\n            \"x_obs\": 0.60,\n            \"s_x\": 0.20,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        X_data = np.array(case[\"X\"])\n        Y_data = np.array(case[\"Y\"])\n        x_obs = case[\"x_obs\"]\n        s_x = case[\"s_x\"]\n\n        n = len(X_data)\n        \n        # Step 1: OLS Estimation\n        X_mean = np.mean(X_data)\n        Y_mean = np.mean(Y_data)\n\n        S_xy = np.sum((X_data - X_mean) * (Y_data - Y_mean))\n        S_xx = np.sum((X_data - X_mean)**2)\n        \n        if S_xx == 0:\n            # Handle degenerate case where all X values are the same.\n            # This should not occur in the given test cases.\n            # In this scenario, b_hat is undefined and correlation is meaningless.\n            # For a valid solution, we would need to flag this as problematic.\n            # This simple handling prevents division by zero.\n            b_hat = 0\n            a_hat = Y_mean\n            sigma_hat_sq = np.var(Y_data, ddof=1) if n > 1 else 0\n        else:\n            b_hat = S_xy / S_xx\n            a_hat = Y_mean - b_hat * X_mean\n\n            Y_pred_model = a_hat + b_hat * X_data\n            residuals = Y_data - Y_pred_model\n            SSR = np.sum(residuals**2)\n            # Degrees of freedom are n-2 for simple linear regression\n            sigma_hat_sq = SSR / (n - 2)\n            \n        # Step 2: Calculate constrained predictive mean and variance\n        pred_mean_Y = a_hat + b_hat * x_obs\n        \n        # The total predictive variance calculation requires S_xx > 0\n        if S_xx > 0:\n            term1 = sigma_hat_sq * (1 + 1/n + ((x_obs - X_mean)**2 + s_x**2) / S_xx)\n            term2 = b_hat**2 * s_x**2\n            pred_var_Y = term1 + term2\n        else: # If S_xx=0, we cannot use the constraint. Uncertainty is just the sample variance.\n            pred_var_Y = np.var(Y_data, ddof=1) if n > 1 else 0\n\n        pred_std_Y = np.sqrt(pred_var_Y)\n        \n        # Step 3: Quantify uncertainty reduction\n        unconstrained_std_Y = np.std(Y_data, ddof=1)\n        \n        if unconstrained_std_Y > 0:\n            reduction_factor = pred_std_Y / unconstrained_std_Y\n        else:\n            # If original data has no spread, the concept of reduction is ill-defined.\n            reduction_factor = 1.0 if pred_std_Y == 0 else float('inf')\n\n        results.append([pred_mean_Y, pred_std_Y, reduction_factor])\n\n    # Final print statement in the exact required format.\n    # Format each float to 6 decimal places and then join.\n    formatted_results = []\n    for res_list in results:\n        formatted_list_str = f\"[{','.join([f'{val:.6f}' for val in res_list])}]\"\n        formatted_results.append(formatted_list_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}