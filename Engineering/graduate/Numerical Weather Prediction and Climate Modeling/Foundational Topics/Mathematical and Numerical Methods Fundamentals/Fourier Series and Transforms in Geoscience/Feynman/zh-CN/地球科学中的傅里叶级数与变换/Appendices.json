{
    "hands_on_practices": [
        {
            "introduction": "地球科学数据几乎总是离散采样的，因此理解混叠（aliasing）现象至关重要。本练习将提供一个编程实践，让您亲眼见证当采样频率低于奈奎斯特频率时，信号的频谱会如何失真。通过这个练习，您将掌握避免和识别地球物理时间序列中混叠问题的基本技能 ()。",
            "id": "4045320",
            "problem": "考虑一个合成的、均匀采样的一维时间序列，它代表一个地球物理信号，该信号包含 $2$ 个正弦分量，例如大气或海洋场中的日变化和半日变化。设其潜在的连续时间信号为\n$$\ns(t) \\;=\\; A_1 \\cos\\!\\big(2\\pi F_1 t + \\phi_1\\big) \\;+\\; A_2 \\cos\\!\\big(2\\pi F_2 t + \\phi_2\\big),\n$$\n其中 $A_1, A_2$ 是振幅，$F_1, F_2$ 是频率（单位为赫兹，Hz），$\\phi_1, \\phi_2$ 是相位（单位为弧度）。该信号以采样频率 $f_s$（单位为赫兹，Hz）和采样间隔 $\\Delta t = 1/f_s$ 进行采样，生成一个离散时间序列\n$$\nx[n] \\;=\\; s(n \\Delta t) \\;=\\; s\\!\\left(\\frac{n}{f_s}\\right), \\quad n = 0,1,\\dots,N-1,\n$$\n总共 $N$ 个样本。$x[n]$ 的离散傅里叶变换 (DFT) 定义为\n$$\nX[k] \\;=\\; \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad k = 0,1,\\dots,N-1,\n$$\n其关联的频率仓 (frequency bin) 为\n$$\nf_k \\;=\\; \\frac{k f_s}{N}.\n$$\n对于实值 $x[n]$，可以通过取 $X[k]$ 的模 $|X[k]|$、除以 $N$ 进行缩放，并将除直流 (DC) 分量（$k=0$ 的仓）和（当 $N$ 为偶数时）奈奎斯特仓（$k=N/2$ 的仓）之外的所有振幅加倍，来形成单边振幅谱。\n\n当真实频率 $F$ 超过奈奎斯特频率 $f_s/2$ 时，会发生混叠（aliasing）。在理想采样中，对于任意整数 $m$，位于 $F$ 和 $F' = F \\pm m f_s$ 的不同连续时间正弦波会产生相同的采样序列。此时，表观单边谱将在混叠频率处被观测到\n$$\nF_{\\text{alias}} \\;=\\; \\left| \\left(\\left(F + \\frac{f_s}{2}\\right) \\bmod f_s\\right) - \\frac{f_s}{2} \\right|,\n$$\n该频率位于区间 $[0, f_s/2]$ 内。在实践中，对于有限的 $N$ 和矩形窗，频谱泄漏（spectral leakage）会将真实（或混叠）谱线附近的能量分布到相邻的频率仓中；因此，从 DFT 幅值中选取的峰值会出现在最接近的可分辨频率仓处，该频率仓由频率分辨率量化\n$$\n\\Delta f \\;=\\; \\frac{f_s}{N}.\n$$\n\n您的任务是实现一个程序，该程序：\n- 使用以下参数，根据给定的 $s(t)$ 合成 $x[n]$。\n- 使用离散傅里叶变换计算单边振幅谱。\n- 通过在单边振幅谱中找到两个最大的不同峰值（不包括直流分量仓）来识别两个主导谱峰，如有必要，通过首先选择较低频率的仓来解决平局问题。为确保峰值是不同的，在选择位于仓 $k_1$ 的最大峰值后，在选择第二大峰值之前，排除 $k_1$ 周围 $\\pm 1$ 个仓的邻域。\n- 对于每个测试用例，返回这两个峰值的估计频率（单位 Hz），该频率通过将选定的仓索引映射回 $f_k = k f_s/N$ 获得。将这两个频率按升序排序，并将每个频率四舍五入到六位小数。\n\n在所有测试用例中使用以下固定的信号参数：\n- $A_1 = 2.0$, $A_2 = 1.0$ (无量纲)。\n- $F_1 = 5.0$ Hz, $F_2 = 12.0$ Hz。\n- $\\phi_1 = 0.0$ 弧度, $\\phi_2 = \\pi/3$ 弧度。\n\n角度必须以弧度为单位。频率必须以赫兹（Hz）表示。时间必须以秒为单位。\n\n测试套件：\n- 案例 1（正常路径，两个分量均低于奈奎斯特频率）：$f_s = 64$ Hz, $N = 256$。\n- 案例 2（单分量混叠，$F_2$ 高于奈奎斯特频率）：$f_s = 20$ Hz, $N = 256$。\n- 案例 3（边界情况，$F_2$ 恰好在奈奎斯特频率）：$f_s = 24$ Hz, $N = 256$。\n- 案例 4（两个分量均混叠，均高于奈奎斯特频率）：$f_s = 9$ Hz, $N = 256$。\n\n算法和数值要求：\n- 对于 $n = 0,1,\\dots,N-1$，精确地构造 $x[n] = A_1 \\cos(2\\pi F_1 n/f_s + \\phi_1) + A_2 \\cos(2\\pi F_2 n/f_s + \\phi_2)$。\n- 使用实数到复数的 DFT 计算单边谱，并对实数信号应用正确的振幅缩放，即除了直流分量和奈奎斯特分量（如适用）外，将所有仓的振幅加倍。\n- 在搜索峰值之前，通过将其振幅设置为零来排除直流分量仓。\n- 按照规定识别两个主导峰值，并将其仓索引映射为赫兹（Hz）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是一个包含两个浮点数的列表：对应测试用例的两个估计峰值频率（单位 Hz），按升序排序并四舍五入到六位小数。例如：[[f11,f12],[f21,f22],[f31,f32],[f41,f42]]。\n\n没有用户输入。程序必须是自包含的，并且必须仅以上述确切格式打印最终结果行。",
            "solution": "我们从连续时间信号开始\n$$\ns(t) \\;=\\; A_1 \\cos\\!\\big(2\\pi F_1 t + \\phi_1\\big) \\;+\\; A_2 \\cos\\!\\big(2\\pi F_2 t + \\phi_2\\big),\n$$\n固定参数为 $A_1 = 2.0$, $A_2 = 1.0$, $F_1 = 5.0$ Hz, $F_2 = 12.0$ Hz, $\\phi_1 = 0.0$ 弧度, $\\phi_2 = \\pi/3$ 弧度。离散采样以采样频率 $f_s$（单位 Hz）和采样间隔 $\\Delta t = 1/f_s$ 进行，产生样本\n$$\nx[n] \\;=\\; s\\!\\left(\\frac{n}{f_s}\\right) \\;=\\; A_1 \\cos\\!\\Big(2\\pi F_1 \\frac{n}{f_s} + \\phi_1\\Big) \\;+\\; A_2 \\cos\\!\\Big(2\\pi F_2 \\frac{n}{f_s} + \\phi_2\\Big),\n$$\n对于 $n = 0, 1, \\dots, N-1$。$x[n]$ 的离散傅里叶变换 (DFT) 是\n$$\nX[k] \\;=\\; \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad k = 0,1,\\dots,N-1.\n$$\n对于实值序列 $x[n]$，其频谱是共轭对称的，因此只需考虑 $k = 0,1,\\dots,\\lfloor N/2 \\rfloor$ 的单边谱。对应的物理频率为\n$$\nf_k \\;=\\; \\frac{k f_s}{N}.\n$$\n为了形成一个物理上可解释的单边振幅谱 $A(f_k)$，我们计算\n$$\nA(f_k) \\;=\\; \\begin{cases}\n\\frac{1}{N}\\,|X[0]|,  k = 0,\\\n$$6pt]\n\\frac{2}{N}\\,|X[k]|,  1 \\le k \\le \\frac{N}{2}-1 \\text{ (对于偶数 } N),\\\n$$6pt]\n\\frac{1}{N}\\,|X[N/2]|,  k = N/2 \\text{ (奈奎斯特频率, 对于偶数 } N),\n\\end{cases}\n$$\n当 $N$ 为奇数时定义类似（当 $N$ 为奇数时没有奈奎斯特仓）。由于所有测试用例中 $N$ 都指定为 $256$，我们总是处理 $N$ 为偶数的情况，奈奎斯特仓 $k = N/2$ 被包括在内，但其振幅不加倍。\n\nNyquist-Shannon 采样定理指出，如果 $f_s \\ge 2 F_{\\max}$，其中 $F_{\\max}$ 是存在的最大频率，那么可以从样本中完美地重建连续时间频谱。如果条件不满足，位于 $F$ 和 $F \\pm m f_s$（对于任意整数 $m$）的连续时间正弦波在采样后将无法区分，因为\n$$\n\\cos\\!\\big(2\\pi (F \\pm m f_s) t + \\phi\\big)\\Big|_{t = n/f_s}\n= \\cos\\!\\Big(2\\pi F \\frac{n}{f_s} \\pm 2\\pi m n + \\phi\\Big)\n= \\cos\\!\\Big(2\\pi F \\frac{n}{f_s} + \\phi\\Big),\n$$\n利用了余弦函数周期为 $2\\pi$ 的周期性。因此，表观单边谱将在混叠频率处被观测到\n$$\nF_{\\text{alias}} \\;=\\; \\left| \\left(\\left(F + \\frac{f_s}{2}\\right) \\bmod f_s\\right) - \\frac{f_s}{2} \\right| \\;\\in\\; [0, f_s/2].\n$$\n\n在使用 $N$ 个样本的有限窗口和矩形窗（在对原始数据进行 DFT 时是隐式的）进行数值计算时，除非正弦波在窗口内完成整数个周期，否则会发生频谱泄漏。狄利克雷核（Dirichlet kernel）描述了能量扩散到相邻频率仓中的情况。因此，观测到的峰值将位于最接近真实谱线的 DFT 频率仓，该频率仓由频率分辨率量化\n$$\n\\Delta f \\;=\\; \\frac{f_s}{N}.\n$$\n\n实现的算法步骤：\n- 对于每个测试用例，使用指定的 $A_1, A_2, F_1, F_2, \\phi_1, \\phi_2$ 以及给定的 $f_s$ 和 $N$ 构造 $x[n]$。\n- 使用实数输入的快速傅里叶变换计算单边谱，然后如上所述缩放振幅。将直流分量仓的振幅设置为零，以将其从峰值选择中排除。\n- 识别最大的峰值索引 $k_1 = \\arg\\max A(f_k)$。为确保两个峰值是不同的，并且不是同一主瓣的相邻点，将 $k_1$ 周围 $\\pm 1$ 个仓（裁剪到有效索引）邻域内的振幅清零。然后选择第二大峰值索引 $k_2$。\n- 使用 $f_k = k f_s/N$ 将 $k_1$ 和 $k_2$ 映射为频率 $f_{k_1}, f_{k_2}$（单位 Hz），按升序排序，并四舍五入到六位小数。\n\n关于测试套件的推理：\n- 案例 1：$f_s = 64$ Hz, $N = 256$。奈奎斯特频率为 $32$ Hz，两个频率 $F_1 = 5$ Hz 和 $F_2 = 12$ Hz 均低于奈奎斯特频率。频率分辨率为 $\\Delta f = f_s/N = 0.25$ Hz。$F_1$ 和 $F_2$ 都是 $\\Delta f$ 的整数倍，因此没有泄漏，峰值恰好在 $5.0$ Hz 和 $12.0$ Hz。\n- 案例 2：$f_s = 20$ Hz, $N = 256$。奈奎斯特频率为 $10$ Hz。$F_1 = 5$ Hz 低于奈奎斯特频率，并且恰好落在一个仓上，因为 $\\Delta f = 20/256 = 0.078125$ Hz 可以整除 $5.0$ Hz。$F_2 = 12$ Hz 混叠为 $F_{2,\\text{alias}} = |12 - 1\\cdot 20| = 8$ Hz。因为 $8.0$ Hz 不是 $\\Delta f$ 的整数倍，会发生泄漏，观测到的最大值位于 $8$ Hz 附近的最近仓位。\n- 案例 3：$f_s = 24$ Hz, $N = 256$。奈奎斯特频率为 $12$ Hz，恰好等于 $F_2$，因此其能量出现在奈奎斯特仓，振幅不加倍。$F_1 = 5$ Hz 低于奈奎斯特频率，但不是 $\\Delta f = 24/256 = 0.09375$ Hz 的精确倍数，因此观测到的峰值是 $5$ Hz 附近的最近仓位。\n- 案例 4：$f_s = 9$ Hz, $N = 256$。奈奎斯特频率为 $4.5$ Hz，因此 $F_1 = 5$ Hz 和 $F_2 = 12$ Hz 都会混叠：$F_{1,\\text{alias}} = |5 - 1\\cdot 9| = 4$ Hz 和 $F_{2,\\text{alias}} = |12 - 1\\cdot 9| = 3$ Hz。由于 $\\Delta f = 9/256 \\approx 0.03515625$ Hz，两者都不恰好在仓上，因此峰值将出现在 $4$ Hz 和 $3$ Hz 附近。\n\n程序精确地实现了这些步骤，并为每个测试用例输出两个选定的峰值频率（单位 Hz），按升序排序并四舍五入到六位小数，格式为所需的单行列表之列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef one_sided_amplitude_spectrum(x, fs):\n    \"\"\"\n    Compute one-sided amplitude spectrum for a real-valued signal x sampled at fs.\n    Returns frequencies (Hz) and amplitudes.\n    \"\"\"\n    N = x.size\n    # Real FFT: length N//2 + 1 for even N\n    X = np.fft.rfft(x)\n    freqs = np.fft.rfftfreq(N, d=1.0/fs)\n    # Amplitude scaling to get one-sided amplitude spectrum\n    amp = np.abs(X) / N\n    if N > 1:\n        # Double all bins except DC and Nyquist (if N even)\n        amp[1:-1] *= 2.0\n    return freqs, amp\n\ndef synthesize_signal(N, fs, A1, A2, F1, F2, phi1, phi2):\n    n = np.arange(N)\n    t = n / fs\n    x = (A1 * np.cos(2.0 * np.pi * F1 * t + phi1) +\n         A2 * np.cos(2.0 * np.pi * F2 * t + phi2))\n    return x\n\ndef pick_two_dominant_peaks(freqs, amp):\n    \"\"\"\n    Pick two dominant peaks from one-sided amplitude spectrum.\n    Exclude DC by zeroing amp[0] before selection.\n    After picking the dominant peak, zero out a neighborhood of +/-1 bins to ensure distinct peaks.\n    Return the two peak frequencies in ascending order.\n    \"\"\"\n    amp = amp.copy()\n    # Exclude DC\n    if amp.size > 0:\n        amp[0] = 0.0\n    # First peak\n    idx1 = int(np.argmax(amp))\n    # Zero out neighborhood around first peak to avoid adjacent bins of same lobe\n    lo = max(1, idx1 - 1)  # keep DC excluded\n    hi = min(amp.size - 1, idx1 + 1)\n    amp[lo:hi+1] = 0.0\n    # Second peak\n    idx2 = int(np.argmax(amp))\n    f1 = freqs[idx1]\n    f2 = freqs[idx2]\n    return tuple(sorted((f1, f2)))\n\ndef solve():\n    # Fixed signal parameters\n    A1, A2 = 2.0, 1.0\n    F1, F2 = 5.0, 12.0  # Hz\n    phi1, phi2 = 0.0, np.pi / 3.0  # radians\n\n    # Define the test cases from the problem statement: (fs, N)\n    test_cases = [\n        (64.0, 256),  # Case 1: both below Nyquist\n        (20.0, 256),  # Case 2: F2 aliases\n        (24.0, 256),  # Case 3: F2 at Nyquist\n        (9.0, 256),   # Case 4: both alias\n    ]\n\n    results = []\n    for fs, N in test_cases:\n        x = synthesize_signal(N, fs, A1, A2, F1, F2, phi1, phi2)\n        freqs, amp = one_sided_amplitude_spectrum(x, fs)\n        f_low, f_high = pick_two_dominant_peaks(freqs, amp)\n        # Round to six decimals as required\n        results.append([round(f_low, 6), round(f_high, 6)])\n\n    # Final print statement in the exact required format: list of lists.\n    # Ensure six decimal places formatting.\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{v:.6f}\" for v in pair) + \"]\" for pair in results\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在确保数据被正确采样后，我们希望获得尽可能精确的频谱估计。本练习将介绍一种常用技术——零填充（zero-padding），并通过理论推导和编程实践，阐明它为何能有效插值频谱，从而更精确地定位谱峰。这个练习将帮助您区分真实的频谱分辨率和通过计算方法提高的频率网格密度 ()。",
            "id": "4045295",
            "problem": "在数值天气预报和气候模拟的背景下，您正在分析均匀采样的地球科学时间序列，其中傅里叶方法被用于估计日变化和天气尺度变率的能量含量。考虑一个实值的有限长度离散时间序列 $x[n]$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，以采样间隔 $\\Delta t$ 进行均匀时间采样。$x[n]$ 的离散时间傅里叶变换 (DTFT) 使用以弧度为单位的角频率 $\\omega$ 定义为\n$$\nX(\\omega) \\;=\\; \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\,\\omega\\, n} \\quad \\text{for } \\omega \\in \\mathbb{R}.\n$$\n离散傅里叶变换 (DFT) 在一个有限网格 $\\omega_k = 2\\pi k/N$（其中 $k \\in \\{0,1,\\dots,N-1\\}$）上对 DTFT 进行采样：\n$$\nX_N[k] \\;=\\; \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\,2\\pi\\, k\\, n / N}.\n$$\n现在定义一个长度为 $M$ 的补零序列 $x_M[n]$，其中当 $0 \\le n \\le N-1$ 时 $x_M[n] = x[n]$，当 $N \\le n \\le M-1$ 时 $x_M[n] = 0$。这里 $M$ 是 $N$ 的整数倍，即 $M = L N$，其中 $L \\in \\mathbb{N}$。该补零序列的 $M$点 DFT 为\n$$\nX_M[k] \\;=\\; \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i \\,2\\pi\\, k\\, n / M}.\n$$\n任务：\n1) 仅使用这些定义和求和的线性性质，从第一性原理推导为什么补零操作会将采样频率网格的密度从间距 $2\\pi/N$ 增加到间距 $2\\pi/M$，而不会增加关于 $x[n]$ 的新信息。解释为什么当 $M = L N$ 时，对于实值 $x[n]$，在对应的非负频率上，$\\ell \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ 的值 $X_M[\\ell L]$ 精确等于 $X_N[\\ell]$。并将此现象解释为对同一底层 $X(\\omega)$ 的插值，而不是创建了新的频谱内容。\n2) 实现一个程序，为以下测试套件构建实值时间序列。对于每个测试用例，使用实数快速傅里叶变换 (RFFT) 计算长度为 $N$ 和补零后长度为 $M=L N$ 的单边幅谱，然后计算指定的诊断量以验证第 (1) 部分的数学结论。任何公式中的角度单位都必须是弧度，但程序的输出必须是指定的无量纲浮点数或布尔值。\n\n测试套件：\n- 测试 A (网格一致性，理想情况)：设 $N = 128$ 且 $L = 4$。定义\n  $$\n  x[n] \\;=\\; \\sin(2\\pi \\cdot 0.125 \\, n) \\;+\\; 0.6 \\cos(2\\pi \\cdot 0.27 \\, n + 0.3) \\;+\\; 0.2 \\sin(2\\pi \\cdot 0.37 \\, n),\n  $$\n  对于 $n = 0,1,\\dots,127$。计算长度为 $N$ 和长度为 $M = 512$ 的 RFFT。设 $X_N[\\ell]$ 表示在索引 $\\ell \\in \\{0,1,\\dots,N/2\\}$ 处的 RFFT 输出， $X_M[k]$ 表示在索引 $k \\in \\{0,1,\\dots,M/2\\}$ 处的 RFFT 输出。计算最大绝对差\n  $$\n  d_A \\;=\\; \\max_{0 \\le \\ell \\le N/2} \\left| X_M[\\ell L] - X_N[\\ell] \\right|.\n  $$\n  以浮点数形式返回 $d_A$。\n- 测试 B (插值的峰值幅度，非整数倍频点)：设 $N = 180$，$L = 8$，$f_0 = 23.7 / N$ 周期/采样点。定义 $x[n] = \\cos(2\\pi f_0 n)$，对于 $n = 0,1,\\dots,179$。计算未补零 RFFT 中的最大幅度 $P_N = \\max_k |X_N[k]|$，以及补零后 RFFT 中的最大幅度 $P_M = \\max_k |X_M[k]|$。返回一个布尔值，指示是否 $P_M > P_N$。\n- 测试 C (插值的频率估计改善)：设 $N = 240$，$L = 10$，$f_0 = 1/24 + 0.0037$ 周期/采样点。定义 $x[n] = \\cos(2\\pi f_0 n)$，对于 $n = 0,1,\\dots,239$。设 $\\hat{k}_N$ 和 $\\hat{k}_M$ 分别为长度为 $N$ 和 $M$ 的 RFFT 中最大幅度频点的索引。定义归一化频点频率估计 $\\hat{f}_N = \\hat{k}_N / N$ 和 $\\hat{f}_M = \\hat{k}_M / M$。计算比率\n  $$\n  r_C \\;=\\; \\frac{|\\hat{f}_N - f_0|}{|\\hat{f}_M - f_0|}.\n  $$\n  以浮点数形式返回 $r_C$。\n- 测试 D (边界情况，零信号)：设 $N = 64$ 且 $L = 16$，其中对于所有 $n$，$x[n] = 0$。与测试 A 中类似，计算 $d_D = \\max_{0 \\le \\ell \\le N/2} | X_M[\\ell L] - X_N[\\ell] |$。返回一个布尔值，指示是否 $d_D = 0.0$。\n\n实现要求：\n- 仅使用实数快速傅里叶变换获取单边谱。信号定义中的所有角度单位均为弧度。程序必须按上述顺序计算并返回四个结果。\n- 最终输出格式必须是单行，包含一个 Python 风格的列表，按顺序存放四个结果：$[d_A, \\text{resultB}, r_C, \\text{resultD}]$，其中 $d_A$ 和 $r_C$ 是浮点数，resultB 和 resultD 是布尔值。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[0.0,True,2.5,True]\"）。不允许有其他任何输出。",
            "solution": "该问题陈述已经过验证，被认为是合理的。它以数字信号处理原理为科学基础，给出了所有必要的定义和参数，是适定且客观的。其任务是可形式化和可验证的。因此，我们可以着手解决。\n\n该问题要求从第一性原理推导补零对时间序列的离散傅里叶变换 (DFT) 的影响，然后通过数值实现来演示这些影响。\n\n**第 1 部分：理论推导与解释**\n\n我们需要证明为什么将长度为 $N$ 的有限长度离散时间序列 $x[n]$ 补零到新长度 $M=LN$ 会增加频率网格的密度，并证明原始 $N$ 点 DFT 与补零后的 $M$ 点 DFT 之间的关系。\n\n设原始实值时间序列为 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。其离散时间傅里叶变换 (DTFT) 是角频率 $\\omega$ 的连续函数，由下式给出：\n$$\nX(\\omega) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\omega n}\n$$\n$N$ 点 DFT，记作 $X_N[k]$，在 $N$ 个离散频率 $\\omega_k = \\frac{2\\pi k}{N}$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）上对该 DTFT 进行采样。该网格的频率间距（或分辨率）为 $\\Delta \\omega_N = \\omega_{k+1} - \\omega_k = \\frac{2\\pi}{N}$。\n$$\nX_N[k] = X(\\omega_k) = X\\left(\\frac{2\\pi k}{N}\\right) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{N}}\n$$\n现在，我们定义一个长度为 $M = LN$ 的补零序列 $x_M[n]$，其中 $L \\in \\mathbb{N}$ 且 $L > 1$：\n$$\nx_M[n] = \\begin{cases} x[n]  0 \\le n \\le N-1 \\\\ 0  N \\le n \\le M-1 \\end{cases}\n$$\n这个补零序列的 $M$ 点 DFT，记作 $X_M[k]$，为：\n$$\nX_M[k] = \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i \\frac{2\\pi k n}{M}}\n$$\n通过代入 $x_M[n]$ 的定义，由于所有后续项均为零，求和可以在 $N-1$ 处截断：\n$$\nX_M[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{M}} + \\sum_{n=N}^{M-1} (0) \\cdot e^{-i \\frac{2\\pi k n}{M}} = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{M}}\n$$\n让我们将此结果与原始 DTFT $X(\\omega)$ 进行比较。如果我们在新的频率网格点 $\\omega'_k = \\frac{2\\pi k}{M}$ 上计算 $X(\\omega)$ 的值，我们得到：\n$$\nX(\\omega'_k) = X\\left(\\frac{2\\pi k}{M}\\right) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\left(\\frac{2\\pi k}{M}\\right) n}\n$$\n我们观察到 $X_M[k] = X\\left(\\frac{2\\pi k}{M}\\right)$。这是核心发现。补零序列的 $M$ 点 DFT 在数学上等同于在更精细的一组频率点 $\\omega'_k$ 上对*原始、未补零序列* $x[n]$ 的 DTFT 进行采样。\n\n这个新频率网格的间距是 $\\Delta \\omega_M = \\frac{2\\pi}{M}$。由于 $M = LN > N$，间距 $\\Delta \\omega_M$ 小于原始间距 $\\Delta \\omega_N$。具体来说，$\\Delta \\omega_M = \\frac{\\Delta \\omega_N}{L}$。这证实了补零操作会增加采样频率网格的密度。\n\n至关重要的是，这个过程不会增加任何关于信号 $x[n]$ 的新信息。底层的 DTFT $X(\\omega)$ 完全由原始的 $N$ 个数据点确定。补零是一种将此 DTFT 插值到更精细频率网格上的高效计算方法。它并不能提高*真实*的谱分辨率，后者从根本上受限于原始观测长度 $N \\Delta t$。但是，它可以揭示原始 DFT 采样点之间谱形状的细节，这对于更准确地估计那些不恰好落在原始粗糙网格点之一上的谱峰的频率和幅度非常有用。\n\n最后，我们必须证明在原始频率采样位置，新的 DFT 与旧的 DFT 相匹配。我们检验在索引 $k = \\ell L$（其中 $\\ell \\in \\{0, 1, \\dots, N-1\\}$）处 $X_M[k]$ 的值。\n$$\nX_M[\\ell L] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi (\\ell L) n}{M}}\n$$\n代入 $M = LN$，指数中的因子 $L$ 被消去：\n$$\nX_M[\\ell L] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi \\ell n}{N}}\n$$\n右侧的表达式正是 $N$ 点 DFT $X_N[\\ell]$ 的定义。因此，我们证明了恒等式：\n$$\nX_M[\\ell L] = X_N[\\ell]\n$$\n该恒等式证实了插值谱 $X_M$ 在原始网格点上精确地恢复了原始谱 $X_N$。对于实值信号 $x[n]$，其频谱是共轭对称的，通常使用实数快速傅里叶变换 (RFFT) 来仅计算非负频率的唯一分量。问题指定使用 RFFT，它计算从 $\\ell=0$ 到 $\\ell=\\lfloor N/2 \\rfloor$ 的索引范围内的变换。恒等式 $X_M[\\ell L] = X_N[\\ell]$ 对于这个索引范围也成立，这一点将通过数值进行验证。\n\n**第 2 部分：数值实现与验证**\n\n我们现在实现问题陈述中描述的四个测试用例。代码将生成指定的信号，计算它们的 $N$ 点和补零后的 $M$ 点 RFFT，并计算所需的诊断量。\n\n- 测试 A 验证了对于一个复合信号的恒等式 $X_M[\\ell L] = X_N[\\ell]$。由于浮点运算，我们预计差值 $d_A$ 将是一个非常接近零的小数，但不一定精确为零。\n- 测试 B 演示了对于一个频率落在粗糙 DFT 网格频点之间的信号分量，补零如何帮助找到更准确的峰值幅度。补零变换中的峰值幅度 $P_M$ 应大于未补零变换中的峰值幅度 $P_N$。\n- 测试 C 表明，补零产生的更密集的频率网格可以实现更准确的频率估计。来自补零变换的频率估计 $\\hat{f}_M$ 将比来自未补零变换的估计 $\\hat{f}_N$ 更接近真实频率 $f_0$，从而导致误差比 $r_C > 1$。\n- 测试 D 是一个使用零信号的合理性检查，对于零信号，其变换恒等于零。差值 $d_D$ 必须精确为 $0.0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement\n    related to zero-padding in Fourier transforms.\n    \"\"\"\n    results = []\n\n    # Test A (grid-consistency, happy path)\n    N_A = 128\n    L_A = 4\n    M_A = N_A * L_A\n    n_A = np.arange(N_A)\n    x_A = (np.sin(2.0 * np.pi * 0.125 * n_A) +\n           0.6 * np.cos(2.0 * np.pi * 0.27 * n_A + 0.3) +\n           0.2 * np.sin(2.0 * np.pi * 0.37 * n_A))\n\n    # Compute RFFT at length N and M (with zero-padding)\n    # The 'n' parameter in rfft handles zero-padding if n > len(x)\n    X_N_A = np.fft.rfft(x_A)\n    X_M_A = np.fft.rfft(x_A, n=M_A)\n\n    # Verify that X_M[l*L] == X_N[l]\n    # The length of rfft output is n//2 + 1\n    ell_values_A = np.arange(N_A // 2 + 1)\n    k_values_A = ell_values_A * L_A\n    \n    # Calculate the maximum absolute difference\n    d_A = np.max(np.abs(X_M_A[k_values_A] - X_N_A[ell_values_A]))\n    results.append(d_A)\n\n    # Test B (interpolated peak magnitude off-bin)\n    N_B = 180\n    L_B = 8\n    M_B = N_B * L_B\n    f0_B = 23.7 / N_B\n    n_B = np.arange(N_B)\n    x_B = np.cos(2.0 * np.pi * f0_B * n_B)\n\n    X_N_B = np.fft.rfft(x_B)\n    X_M_B = np.fft.rfft(x_B, n=M_B)\n\n    P_N = np.max(np.abs(X_N_B))\n    P_M = np.max(np.abs(X_M_B))\n\n    result_B = P_M > P_N\n    results.append(result_B)\n\n    # Test C (interpolated frequency estimate improves)\n    N_C = 240\n    L_C = 10\n    M_C = N_C * L_C\n    f0_C = 1.0 / 24.0 + 0.0037\n    n_C = np.arange(N_C)\n    x_C = np.cos(2.0 * np.pi * f0_C * n_C)\n\n    X_N_C = np.fft.rfft(x_C)\n    X_M_C = np.fft.rfft(x_C, n=M_C)\n\n    # Find indices of largest magnitude bins\n    k_hat_N = np.argmax(np.abs(X_N_C))\n    k_hat_M = np.argmax(np.abs(X_M_C))\n\n    # Calculate normalized frequency estimates\n    f_hat_N = k_hat_N / N_C\n    f_hat_M = k_hat_M / M_C\n\n    # Compute the ratio of estimation errors\n    error_N = np.abs(f_hat_N - f0_C)\n    error_M = np.abs(f_hat_M - f0_C)\n    r_C = error_N / error_M\n    results.append(r_C)\n\n    # Test D (edge case, zero signal)\n    N_D = 64\n    L_D = 16\n    M_D = N_D * L_D\n    x_D = np.zeros(N_D)\n\n    X_N_D = np.fft.rfft(x_D)\n    X_M_D = np.fft.rfft(x_D, n=M_D)\n\n    ell_values_D = np.arange(N_D // 2 + 1)\n    k_values_D = ell_values_D * L_D\n\n    d_D = np.max(np.abs(X_M_D[k_values_D] - X_N_D[ell_values_D]))\n    result_D = (d_D == 0.0)\n    results.append(result_D)\n\n    # Format and print the final output as a single-line list\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "傅里叶分析的强大之处不仅在于分析单个时间序列，更在于揭示多个序列之间的关系。本练习模拟了一个典型的地球科学场景：分析两个不同位置的信号，以理解它们之间的物理联系，例如平流输运或波的传播。您将通过编程实现交叉谱分析，学习如何从数据中提取信号之间的相位延迟和相干性，这是诊断和验证气候和天气模型中物理过程的关键技能 ()。",
            "id": "4045315",
            "problem": "一对合成的地球科学时间序列用于表示通过具有已知时间延迟的平流输运连接的两个位置的标量异常（例如，海平面气压异常）。这些信号共享指定的窄带频谱分量和独立的宽带噪声。任务是使用基于分段平均离散傅里叶变换的方差缩减方法来估计交叉谱和幅值平方相干性，并验证在共享频带处恢复由时滞所隐含的预期相位，以及在这些频带处存在显著的相干峰。\n\n基本原理：\n- 设 $x(t)$ 和 $y(t)$ 是以间隔 $\\Delta t$（秒）采样的实值平稳过程，采样频率为 $F_s = 1/\\Delta t$（赫兹）。离散时间样本为 $x_n = x(n \\Delta t)$ 和 $y_n = y(n \\Delta t)$，其中 $n$ 为整数。\n- 函数 $x(t)$ 的连续时间傅里叶变换为 $X(f) = \\int_{-\\infty}^{\\infty} x(t) e^{-i 2 \\pi f t} \\, dt$，其中 $f$ 是频率，单位为赫兹。时移性质指出，如果 $y(t) = x(t - \\tau)$，则对于时滞 $\\tau$（秒），有 $Y(f) = X(f) e^{-i 2 \\pi f \\tau}$。\n- 对于联合平稳过程，交叉谱 $S_{xy}(f)$ 定义为 $S_{xy}(f) = \\lim_{T \\to \\infty} \\mathbb{E}\\{X_T(f) \\overline{Y_T(f)}\\}$，其中 $X_T(f)$ 是在持续时间 $T$ 上的有限时间傅里叶变换，$\\overline{Y_T(f)}$ 表示复共轭。在 $y(t) = x(t - \\tau)$ 的条件下，交叉谱满足 $\\arg S_{xy}(f) = -2 \\pi f \\tau$（弧度）。\n- 幅值平方相干性定义为 $\\gamma^2_{xy}(f) = \\dfrac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)}$，其取值范围在 $[0,1]$ 内，量化了在频率 $f$ 上 $x$ 的功率中与 $y$ 线性相关的部分。\n\n您必须实现一个程序，该程序：\n1. 通过对指定共享频带 $\\{(f_i, A_i)\\}$ 上的余弦求和，生成具有已知时滞 $\\tau$ 和指定标准差的独立零均值高斯噪声的合成数据对 $(x_n, y_n)$。使用 $x_n = \\sum_i A_i \\cos(2 \\pi f_i t_n) + \\varepsilon^{(x)}_n$， $y_n = \\sum_i A_i \\cos(2 \\pi f_i (t_n - \\tau)) + \\varepsilon^{(y)}_n$，其中 $t_n = n \\Delta t$，$\\varepsilon^{(x)}_n$ 和 $\\varepsilon^{(y)}_n$ 是独立同分布的高斯噪声序列，各自具有给定的标准差。在进行谱估计之前，移除样本均值（常数类型去趋势）。\n2. 使用 Welch 方法（带有 Hann 窗和 $50\\%$ 重叠的分段平均离散傅里叶变换）估计交叉谱 $S_{xy}(f)$ 和幅值平方相干性 $\\gamma^2_{xy}(f)$，返回以赫兹为单位的频率点 $f_k$。\n3. 对于每个指定的共享频带 $f_i$，识别最近的频率点 $f_k$ 并计算：\n   - 估计的交叉谱相位 $\\hat{\\phi}_i = \\arg S_{xy}(f_k)$（以弧度为单位）。\n   - 估计的相干性 $\\hat{\\gamma}^2_i = \\gamma^2_{xy}(f_k)$。\n   - 预期的相位 $\\phi^{\\star}_i = -2 \\pi f_i \\tau$（以弧度为单位），归约到 $(-\\pi, \\pi]$；相位误差 $\\delta_i$ 必须计算为 $\\hat{\\phi}_i$ 和 $\\phi^{\\star}_i$ 之间的环绕角差（以弧度为单位）。\n4. 对每个频带验证：\n   - 绝对相位误差满足 $|\\delta_i| \\leq \\theta_{\\mathrm{tol}}$，其中 $\\theta_{\\mathrm{tol}} = 0.35$（弧度）。\n   - 相干性超过阈值 $\\hat{\\gamma}^2_i \\geq \\gamma_{\\mathrm{min}}$，其中 $\\gamma_{\\mathrm{min}} = 0.7$，并且是在 $\\pm r$ 个频率点（其中 $r=2$）的邻域内的局部峰值。\n如果一个测试案例中的所有共享频带都满足相位和相干性条件，则该案例被视为成功。\n\n物理和数值单位及角度单位：\n- 时滞 $\\tau$ 必须以秒为单位。\n- 采样间隔 $\\Delta t$ 必须以秒为单位。\n- 频率 $f_i$ 必须以赫兹为单位。\n- 相位和相位误差必须以弧度为单位。\n\n您的程序应实现以上内容并评估以下测试套件。每个测试案例是一个元组 $(\\Delta t, N, \\tau, \\{(f_i, A_i)\\}, \\sigma_x, \\sigma_y)$，指定了采样间隔、样本数、时滞、带有振幅的共享频带集合以及噪声标准差。使用以下案例：\n- 案例 $1$ (理想情况，多频带，正延迟): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 4320,\\ \\tau = 21600\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 2.0),\\ (f_2 = 1/259200\\ \\mathrm{Hz},\\ A_2 = 1.5)\\},\\ \\sigma_x = 0.5,\\ \\sigma_y = 0.5)$。\n- 案例 $2$ (边界情况，零延迟): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 2880,\\ \\tau = 0\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 2.0),\\ (f_2 = 1/432000\\ \\mathrm{Hz},\\ A_2 = 1.2)\\},\\ \\sigma_x = 0.3,\\ \\sigma_y = 0.3)$。\n- 案例 $3$ (边缘情况，近奈奎斯特分量，负延迟): $(\\Delta t = 21600\\ \\mathrm{s},\\ N = 1200,\\ \\tau = -10800\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 1.0),\\ (f_2 = 0.9 \\times (1/(2 \\times 21600))\\ \\mathrm{Hz},\\ A_2 = 1.0)\\},\\ \\sigma_x = 0.3,\\ \\sigma_y = 0.3)$。\n- 案例 $4$ (低信噪比，预期失败): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 1440,\\ \\tau = 14400\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 0.6),\\ (f_2 = 1/432000\\ \\mathrm{Hz},\\ A_2 = 0.4)\\},\\ \\sigma_x = 1.5,\\ \\sigma_y = 1.5)$。\n\n随机性与可复现性：\n- 为高斯噪声生成使用固定的伪随机种子。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个条目是一个布尔值，表示相应测试案例是否成功，顺序如上所列（例如，$[True,False,True,True]$）。",
            "solution": "该问题要求实现并验证一种交叉谱分析方法，以估计两个合成生成的时间序列之间的时间延迟。该问题在科学上是合理的、适定的，并为唯一解提供了足够的信息，但这取决于对 Welch 方法中一个参数的标准假设。验证过程如下。\n\n**1. 问题说明与给定条件**\n\n问题的核心是分析两个离散时间序列 $x_n$ 和 $y_n$，它们根据以下模型生成：\n$$x_n = \\sum_i A_i \\cos(2 \\pi f_i t_n) + \\varepsilon^{(x)}_n$$\n$$y_n = \\sum_i A_i \\cos(2 \\pi f_i (t_n - \\tau)) + \\varepsilon^{(y)}_n$$\n其中 $t_n = n \\Delta t$，$n = 0, 1, \\dots, N-1$。项 $\\varepsilon^{(x)}_n$ 和 $\\varepsilon^{(y)}_n$ 代表具有指定标准差 $\\sigma_x$ 和 $\\sigma_y$ 的独立、零均值高斯白噪声序列。序列 $y_n$ 是 $x_n$ 的确定性分量加上独立噪声的时间延迟版本，延迟为 $\\tau$ 秒。\n\n所测试的基本原理是傅里叶变换的时移性质。对于一个连续信号 $x(t)$ 及其傅里叶变换 $X(f)$，一个时移版本 $y(t) = x(t-\\tau)$（即对于 $\\tau > 0$，$y$ 滞后于 $x$）的变换为 $Y(f) = X(f) e^{-i 2 \\pi f \\tau}$。交叉谱，若定义为 $S_{xy}(f) \\propto E[\\overline{X_T(f)} Y_T(f)]$（这是 SciPy 等标准库中的常见约定），则继承了这种相位关系。代入 $Y(f)$ 的表达式，可得 $S_{xy}(f) \\propto e^{-i 2 \\pi f \\tau} E[|X_T(f)|^2]$。因此，交叉谱的预期相位与频率和时间延迟成正比：\n$$\\arg S_{xy}(f) = -2 \\pi f \\tau$$\n我们将遵循此公式。\n\n分析使用 Welch 方法来估计交叉谱密度（CSD）$S_{xy}(f)$ 和幅值平方相干性 $\\gamma^2_{xy}(f) = \\frac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)}$。问题指定了 Hann 窗和 $50\\%$ 的重叠。Welch 方法的一个关键参数——分段长度 `nperseg`——没有被指定。我们将基于一个标准且合理的假设继续进行，即使用 `scipy.signal` 库的默认值 `nperseg=256`。对于给定的信号长度，此选择在频率分辨率和方差缩减之间提供了良好的平衡。预处理要求在谱估计之前从每个时间序列中移除样本均值。\n\n对每个共享频带 $f_i$ 的验证包括三个条件：\n1.  **相位准确性**：绝对环绕相位误差 $|\\delta_i|$ 不得超过容差 $\\theta_{\\mathrm{tol}} = 0.35$ 弧度。\n2.  **相干性大小**：估计的相干性 $\\hat{\\gamma}^2_i$ 必须达到或超过最小阈值 $\\gamma_{\\mathrm{min}} = 0.7$。\n3.  **相干性峰值**：值 $\\hat{\\gamma}^2_i$ 必须是 $\\pm r$ 个频率点（其中 $r=2$）邻域内的局部最大值。\n\n只有当一个测试案例中的所有指定频带都满足所有三个条件时，该案例才被视为成功。\n\n**2. 算法流程**\n\n对于每个测试案例 $(\\Delta t, N, \\tau, \\{(f_i, A_i)\\}, \\sigma_x, \\sigma_y)$：\n\n**步骤 1：信号生成**\n- 使用固定种子初始化伪随机数生成器，以确保可复现性。\n- 创建一个长度为 $N$ 的时间向量 $t$：$t = [0, \\Delta t, 2\\Delta t, \\dots, (N-1)\\Delta t]$。\n- 通过对指定的余弦项求和，合成信号 $x$ 和 $y$ 的确定性分量。\n- 生成独立的高斯噪声并将其添加到每个信号中。\n- 计算并减去每个完整时间序列的全局均值，以满足去趋势要求。\n\n**步骤 2：谱估计**\n- 计算采样频率 $F_s = 1/\\Delta t$。\n- 使用 `scipy.signal.csd(x, y, fs=F_s, window='hann', nperseg=256, noverlap=128, detrend=False)` 估计交叉谱密度 $S_{xy}$。由于已手动移除了全局均值，因此使用 `detrend=False`。\n- 使用 `scipy.signal.coherence(x, y, fs=F_s, window='hann', nperseg=256, noverlap=128, detrend=False)` 估计幅值平方相干性 $\\gamma^2_{xy}$。\n- 这些函数返回估计的谱量和相应的频率数组 $f_k$。\n\n**步骤 3：验证**\n- 将标志 `case_successful` 初始化为 `True`。\n- 对于测试案例中的每个目标频率 $f_i$：\n    - 找到最接近 $f_i$ 的频率点 $f_k$ 的索引 $k$：$k = \\operatorname{argmin}_{j} |f_j - f_i|$。\n    - 提取估计相位：$\\hat{\\phi}_i = \\operatorname{angle}(S_{xy}[k])$。此值在 $(-\\pi, \\pi]$ 范围内。\n    - 计算理论预期相位 $\\phi^{\\star}_{i, \\text{raw}} = -2 \\pi f_i \\tau$，然后将其环绕到 $(-\\pi, \\pi]$ 区间：$\\phi^{\\star}_i = \\operatorname{atan2}(\\sin(\\phi^{\\star}_{i, \\text{raw}}), \\cos(\\phi^{\\star}_{i, \\text{raw}}))$。\n    - 计算环绕相位差（误差）：$\\delta_i = \\operatorname{atan2}(\\sin(\\hat{\\phi}_i - \\phi^{\\star}_i), \\cos(\\hat{\\phi}_i - \\phi^{\\star}_i))$。\n    - 检查条件 $|\\delta_i| \\leq \\theta_{\\mathrm{tol}}$。如果失败，将 `case_successful` 设置为 `False`，并终止此测试案例的验证。\n    - 提取估计的相干性：$\\hat{\\gamma}^2_i = \\gamma^2_{xy}[k]$。\n    - 检查条件 $\\hat{\\gamma}^2_i \\geq \\gamma_{\\mathrm{min}}$。如果失败，将 `case_successful` 设置为 `False` 并终止该案例的流程。\n    - 检查局部峰值条件。提取从索引 $k-r$ 到 $k+r$ 的相干性数组切片（带边界处理）。如果 $\\hat{\\gamma}^2_i$ 不是此邻域中的最大值，则将 `case_successful` 设置为 `False`。\n- 检查完所有频带后，记录测试案例的最终 `case_successful` 值。\n\n对所有四个测试案例重复此过程，并将布尔结果编译成最终列表。第四个案例设计为低信噪比，预计将无法通过相干性检查，从而展示该方法对噪声的敏感性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying cross-spectral estimation of time lag\n    between two synthetic geoscience time series.\n    \"\"\"\n    \n    # Define verification parameters from the problem statement.\n    theta_tol = 0.35  # radians\n    gamma_min = 0.7\n    r = 2  # neighborhood radius for peak checking\n    \n    # Use a fixed seed for reproducibility of random noise.\n    rng = np.random.default_rng(seed=42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (happy path, multi-band, positive lag)\n        (3600.0, 4320, 21600.0, [(1.0/86400.0, 2.0), (1.0/259200.0, 1.5)], 0.5, 0.5),\n        # Case 2: (boundary, zero lag)\n        (3600.0, 2880, 0.0, [(1.0/86400.0, 2.0), (1.0/432000.0, 1.2)], 0.3, 0.3),\n        # Case 3: (edge, near-Nyquist component, negative lag)\n        (21600.0, 1200, -10800.0, [(1.0/86400.0, 1.0), (0.9 * (1.0 / (2.0 * 21600.0)), 1.0)], 0.3, 0.3),\n        # Case 4: (low signal-to-noise, expected failure)\n        (3600.0, 1440, 14400.0, [(1.0/86400.0, 0.6), (1.0/432000.0, 0.4)], 1.5, 1.5),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        dt, N, tau, bands, sigma_x, sigma_y = case\n        \n        # --- 1. Generate synthetic time series ---\n        t = np.arange(N) * dt\n        x_signal = np.zeros(N)\n        y_signal = np.zeros(N)\n        \n        for f_i, A_i in bands:\n            x_signal += A_i * np.cos(2 * np.pi * f_i * t)\n            y_signal += A_i * np.cos(2 * np.pi * f_i * (t - tau))\n            \n        noise_x = rng.normal(0, sigma_x, N)\n        noise_y = rng.normal(0, sigma_y, N)\n        \n        x = x_signal + noise_x\n        y = y_signal + noise_y\n        \n        # Remove the sample mean (detrend of type constant)\n        x -= np.mean(x)\n        y -= np.mean(y)\n\n        # --- 2. Estimate cross-spectrum and coherence ---\n        fs = 1.0 / dt\n        nperseg = 256  # Using scipy default as it's not specified\n        noverlap = nperseg // 2 # 50% overlap\n\n        # Use detrend=False since we manually detrended the whole signal\n        freqs, S_xy = signal.csd(x, y, fs=fs, window='hann', nperseg=nperseg, noverlap=noverlap, detrend=False)\n        coh_freqs, C_xy = signal.coherence(x, y, fs=fs, window='hann', nperseg=nperseg, noverlap=noverlap, detrend=False)\n\n        case_successful = True\n        \n        # --- 3. Verify conditions for each shared band ---\n        for f_i, _ in bands:\n            # Find the nearest frequency bin\n            k = np.argmin(np.abs(freqs - f_i))\n\n            # a) Verify phase error\n            phi_est = np.angle(S_xy[k])\n            # Corrected expected phase based on scipy's convention for y lagging x\n            phi_exp_raw = -2 * np.pi * f_i * tau\n            \n            # Wrap expected phase to (-pi, pi] to match np.angle output\n            phi_exp = np.arctan2(np.sin(phi_exp_raw), np.cos(phi_exp_raw))\n\n            # Calculate wrapped angular difference\n            phase_error = np.arctan2(np.sin(phi_est - phi_exp), np.cos(phi_est - phi_exp))\n\n            if np.abs(phase_error) > theta_tol:\n                case_successful = False\n                break\n\n            # b) Verify coherence magnitude\n            gamma2_est = C_xy[k]\n            if gamma2_est  < gamma_min:\n                case_successful = False\n                break\n                \n            # c) Verify coherence is a local peak\n            start_idx = max(0, k - r)\n            end_idx = min(len(C_xy), k + r + 1)\n            neighborhood = C_xy[start_idx:end_idx]\n            \n            # Check if the estimated coherence is the maximum in its neighborhood.\n            # np.isclose is used to handle potential floating-point inaccuracies.\n            if not np.isclose(gamma2_est, np.max(neighborhood)):\n                case_successful = False\n                break\n\n        if not case_successful: # break from outer loop if inner loop failed\n             results.append(False)\n             continue\n        \n        results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}