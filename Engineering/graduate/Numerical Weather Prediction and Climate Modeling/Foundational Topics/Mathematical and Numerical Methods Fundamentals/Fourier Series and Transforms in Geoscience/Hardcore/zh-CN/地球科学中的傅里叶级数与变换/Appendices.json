{
    "hands_on_practices": [
        {
            "introduction": "在将傅里叶分析应用于地球科学数据之前，我们必须掌握一个核心概念：采样。实际的地球物理过程是连续的，而我们的观测和模型输出是离散的。这个练习  将通过一个动手编程任务，直观地揭示当采样频率不足以解析信号中的高频成分时（即违反奈奎斯特准则时）会发生什么，这种被称为“混叠”的现象会严重扭曲我们对信号频率组成的理解。",
            "id": "4045320",
            "problem": "考虑一个合成的、均匀采样的一维时间序列，它代表一个具有$2$个正弦分量的地球物理信号，例如大气或海洋场中的日变化和半日变化。设其底层的连续时间信号为\n$$\ns(t) \\;=\\; A_1 \\cos\\!\\big(2\\pi F_1 t + \\phi_1\\big) \\;+\\; A_2 \\cos\\!\\big(2\\pi F_2 t + \\phi_2\\big),\n$$\n其中 $A_1, A_2$ 是振幅，$F_1, F_2$ 是以赫兹 (Hz) 为单位的频率，$\\phi_1, \\phi_2$ 是以弧度为单位的相位。该信号以采样频率 $f_s$（单位为 Hz）和采样间隔 $\\Delta t = 1/f_s$ 进行采样，生成一个离散时间序列\n$$\nx[n] \\;=\\; s(n \\Delta t) \\;=\\; s\\!\\left(\\frac{n}{f_s}\\right), \\quad n = 0,1,\\dots,N-1,\n$$\n总共有 $N$ 个样本。$x[n]$ 的离散傅里叶变换 (DFT) 定义为\n$$\nX[k] \\;=\\; \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad k = 0,1,\\dots,N-1,\n$$\n其相关的频率仓为\n$$\nf_k \\;=\\; \\frac{k f_s}{N}.\n$$\n对于实值 $x[n]$，可以通过取 $|X[k]|$ 的模、按 $N$ 进行缩放，并将除直流 (DC) 仓 $k=0$ 和（当 $N$ 为偶数时）奈奎斯特仓 $k=N/2$ 之外的所有振幅加倍，来从 $X[k]$ 构建单边振幅谱。\n\n当真实频率 $F$ 超过奈奎斯特频率 $f_s/2$ 时，会发生混叠。在理想采样中，对于任何整数 $m$，位于 $F$ 和 $F' = F \\pm m f_s$ 的不同连续时间正弦波会产生相同的采样序列。此时，表观单边谱在混叠频率处被观测到\n$$\nF_{\\text{alias}} \\;=\\; \\left| \\left(\\left(F + \\frac{f_s}{2}\\right) \\bmod f_s\\right) - \\frac{f_s}{2} \\right|,\n$$\n该频率位于区间 $[0, f_s/2]$ 内。在实践中，对于有限的 $N$ 和矩形窗，频谱泄漏会将真实（或混叠）谱线附近的能量分布到相邻的频率仓中；因此，从 DFT 幅度中拾取的峰值出现在最接近的可分辨频率仓频率处，该频率由频率分辨率量化\n$$\n\\Delta f \\;=\\; \\frac{f_s}{N}.\n$$\n\n你的任务是实现一个程序，该程序：\n- 使用以下参数根据给定的 $s(t)$ 合成 $x[n]$。\n- 使用离散傅里叶变换计算单边振幅谱。\n- 通过在单边振幅谱中找到两个最大的不同峰值（不包括直流仓）来识别两个主要谱峰。如果出现幅值相同的情况，优先选择频率较低的仓。为确保峰值是不同的，在选择位于仓 $k_1$ 的最大峰值后，排除 $k_1$ 周围 $\\pm 1$ 个仓的邻域，然后再选择第二大峰值。\n- 对于每个测试用例，返回这两个峰值的估计频率（单位：Hz），这些频率是通过将所选的仓索引映射回 $f_k = k f_s/N$ 获得的。将这两个频率按升序排序，并将每个频率四舍五入到六位小数。\n\n在所有测试用例中，使用以下固定的信号参数：\n- $A_1 = 2.0$, $A_2 = 1.0$（无量纲）。\n- $F_1 = 5.0$ Hz, $F_2 = 12.0$ Hz。\n- $\\phi_1 = 0.0$ 弧度, $\\phi_2 = \\pi/3$ 弧度。\n\n角度必须以弧度为单位。频率必须以赫兹表示。时间必须以秒为单位。\n\n测试套件：\n- 情况 $1$（理想情况，两个分量均低于奈奎斯特频率）：$f_s = 64$ Hz, $N = 256$。\n- 情况 $2$（单分量混叠，$F_2$ 高于奈奎斯特频率）：$f_s = 20$ Hz, $N = 256$。\n- 情况 $3$（边界情况，$F_2$ 正好在奈奎斯特频率上）：$f_s = 24$ Hz, $N = 256$。\n- 情况 $4$（两个分量都混叠，都高于奈奎斯特频率）：$f_s = 9$ Hz, $N = 256$。\n\n算法和数值要求：\n- 精确地构造 $x[n] = A_1 \\cos(2\\pi F_1 n/f_s + \\phi_1) + A_2 \\cos(2\\pi F_2 n/f_s + \\phi_2)$，其中 $n = 0,1,\\dots,N-1$。\n- 使用实数到复数的 DFT 计算单边谱，并对实数信号应用正确的振幅缩放，即除了直流和奈奎斯特（如适用）仓外，所有仓的振幅都加倍。\n- 在搜索峰值之前，通过将其振幅设置为零来排除直流仓。\n- 按照规定识别两个主要峰值，并将其仓索引映射为赫兹单位的频率。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是一个包含两个浮点数的列表：对应测试用例的两个估计峰值频率（单位：Hz），按升序排序并四舍五入到六位小数。例如：[[f11,f12],[f21,f22],[f31,f32],[f41,f42]]。\n\n没有用户输入。程序必须是自包含的，并且必须仅以上述指定的精确格式打印最终结果行。",
            "solution": "我们从连续时间信号开始\n$$\ns(t) \\;=\\; A_1 \\cos\\!\\big(2\\pi F_1 t + \\phi_1\\big) \\;+\\; A_2 \\cos\\!\\big(2\\pi F_2 t + \\phi_2\\big),\n$$\n其固定参数为 $A_1 = 2.0$，$A_2 = 1.0$，$F_1 = 5.0$ Hz，$F_2 = 12.0$ Hz，$\\phi_1 = 0.0$ 弧度，$\\phi_2 = \\pi/3$ 弧度。离散采样以采样频率 $f_s$（单位 Hz）和采样间隔 $\\Delta t = 1/f_s$ 进行，产生样本\n$$\nx[n] \\;=\\; s\\!\\left(\\frac{n}{f_s}\\right) \\;=\\; A_1 \\cos\\!\\Big(2\\pi F_1 \\frac{n}{f_s} + \\phi_1\\Big) \\;+\\; A_2 \\cos\\!\\Big(2\\pi F_2 \\frac{n}{f_s} + \\phi_2\\Big),\n$$\n对于 $n = 0, 1, \\dots, N-1$。$x[n]$ 的离散傅里叶变换 (DFT) 是\n$$\nX[k] \\;=\\; \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad k = 0,1,\\dots,N-1.\n$$\n对于实值序列 $x[n]$，频谱是共轭对称的，因此只需考虑 $k = 0,1,\\dots,\\lfloor N/2 \\rfloor$ 的单边谱。相应的物理频率为\n$$\nf_k \\;=\\; \\frac{k f_s}{N}.\n$$\n为了构建一个物理上可解释的单边振幅谱 $A(f_k)$，我们计算\n$$\nA(f_k) \\;=\\; \\begin{cases}\n\\frac{1}{N}\\,|X[0]|,  k = 0,\\\\[6pt]\n\\frac{2}{N}\\,|X[k]|,  1 \\le k \\le \\frac{N}{2}-1 \\text{ (对于偶数 } N),\\\\[6pt]\n\\frac{1}{N}\\,|X[N/2]|,  k = N/2 \\text{ (奈奎斯特, 对于偶数 } N),\n\\end{cases}\n$$\n当 $N$ 为奇数时，定义类似（当 $N$ 为奇数时没有奈奎斯特仓）。由于在所有测试用例中 $N$ 都指定为 $256$，我们总是处于偶数 $N$ 的情况，奈奎斯特仓 $k = N/2$ 包括在内，但其振幅不加倍。\n\n奈奎斯特-香农采样定理指出，如果 $f_s \\ge 2 F_{\\max}$，其中 $F_{\\max}$ 是存在的最大频率，那么连续时间频谱可以从样本中完美重建。如果条件不满足，位于 $F$ 和 $F \\pm m f_s$（对于任何整数 $m$）的连续时间正弦波在采样后将无法区分，因为\n$$\n\\cos\\!\\big(2\\pi (F \\pm m f_s) t + \\phi\\big)\\Big|_{t = n/f_s}\n= \\cos\\!\\Big(2\\pi F \\frac{n}{f_s} \\pm 2\\pi m n + \\phi\\Big)\n= \\cos\\!\\Big(2\\pi F \\frac{n}{f_s} + \\phi\\Big),\n$$\n利用了余弦函数周期为 $2\\pi$ 的性质。因此，表观单边谱在混叠频率处被观测到\n$$\nF_{\\text{alias}} \\;=\\; \\left| \\left(\\left(F + \\frac{f_s}{2}\\right) \\bmod f_s\\right) - \\frac{f_s}{2} \\right| \\;\\in\\; [0, f_s/2].\n$$\n\n在数值计算中，使用有限的 $N$ 个样本和矩形窗（在对原始数据进行 DFT 时隐式使用）时，除非正弦波在窗口内完成整数个周期，否则会发生频谱泄漏。狄利克雷核描述了能量向相邻仓的扩散。因此，观测到的峰值将位于最接近真实谱线的 DFT 频率仓处，该频率由频率分辨率量化\n$$\n\\Delta f \\;=\\; \\frac{f_s}{N}.\n$$\n\n实现的算法步骤：\n- 对于每个测试用例，使用指定的 $A_1, A_2, F_1, F_2, \\phi_1, \\phi_2$ 以及给定的 $f_s$ 和 $N$ 构造 $x[n]$。\n- 使用实数输入的快速傅里叶变换计算单边谱，然后如上所述缩放振幅。将直流仓的振幅设置为零，以将其从峰值选择中排除。\n- 识别最大峰值索引 $k_1 = \\arg\\max A(f_k)$。为确保两个峰值是不同的，而不是同一主瓣的相邻点，将 $k_1$ 周围 $\\pm 1$ 个仓（裁剪到有效索引）的振幅清零。然后选择第二大峰值索引 $k_2$。\n- 使用 $f_k = k f_s/N$ 将 $k_1$ 和 $k_2$ 映射为以赫兹为单位的频率 $f_{k_1}, f_{k_2}$，按升序排序，并四舍五入到六位小数。\n\n关于测试套件的推理：\n- 情况 $1$：$f_s = 64$ Hz, $N = 256$。奈奎斯特频率为 $32$ Hz，两个频率 $F_1 = 5$ Hz 和 $F_2 = 12$ Hz 均低于奈奎斯特频率。频率分辨率为 $\\Delta f = f_s/N = 0.25$ Hz。$F_1$ 和 $F_2$ 都是 $\\Delta f$ 的整数倍，因此没有泄漏，峰值精确地位于 $5.0$ Hz 和 $12.0$ Hz。\n- 情况 $2$：$f_s = 20$ Hz, $N = 256$。奈奎斯特频率为 $10$ Hz。$F_1 = 5$ Hz 低于奈奎斯特频率，并且正好落在一个频率仓上，因为 $\\Delta f = 20/256 = 0.078125$ Hz 能整除 $5.0$ Hz。$F_2 = 12$ Hz 混叠为 $F_{2,\\text{alias}} = |12 - 1\\cdot 20| = 8$ Hz。因为 $8.0$ Hz 不是 $\\Delta f$ 的整数倍，所以会发生泄漏，观测到的最大值位于 $8$ Hz 附近的最近频率仓。\n- 情况 $3$：$f_s = 24$ Hz, $N = 256$。奈奎斯特频率为 $12$ Hz，恰好等于 $F_2$，因此能量出现在奈奎斯特仓，振幅不加倍。$F_1 = 5$ Hz 低于奈奎斯特频率，但不是 $\\Delta f = 24/256 = 0.09375$ Hz 的精确倍数，因此观测到的峰值是 $5$ Hz 附近的最近频率仓。\n- 情况 $4$：$f_s = 9$ Hz, $N = 256$。奈奎斯特频率为 $4.5$ Hz，因此 $F_1 = 5$ Hz 和 $F_2 = 12$ Hz 都会混叠：$F_{1,\\text{alias}} = |5 - 1\\cdot 9| = 4$ Hz 和 $F_{2,\\text{alias}} = |12 - 1\\cdot 9| = 3$ Hz。由于 $\\Delta f = 9/256 \\approx 0.03515625$ Hz，两者都不完全落在频率仓中心，因此峰值位于 $4$ Hz 和 $3$ Hz 附近。\n\n程序精确地实现了这些步骤，并为每个测试用例输出两个拾取的峰值频率（单位 Hz），按升序排序并四舍五入到六位小数，格式为单行的列表的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef one_sided_amplitude_spectrum(x, fs):\n    \"\"\"\n    Compute one-sided amplitude spectrum for a real-valued signal x sampled at fs.\n    Returns frequencies (Hz) and amplitudes.\n    \"\"\"\n    N = x.size\n    # Real FFT: length N//2 + 1 for even N\n    X = np.fft.rfft(x)\n    freqs = np.fft.rfftfreq(N, d=1.0/fs)\n    # Amplitude scaling to get one-sided amplitude spectrum\n    amp = np.abs(X) / N\n    if N > 1:\n        # Double all bins except DC and Nyquist (if N even)\n        # For rfft, the last element is the Nyquist frequency when N is even.\n        if N % 2 == 0:\n            amp[1:-1] *= 2.0\n        else: # N is odd, no Nyquist bin\n            amp[1:] *= 2.0\n    return freqs, amp\n\ndef synthesize_signal(N, fs, A1, A2, F1, F2, phi1, phi2):\n    n = np.arange(N)\n    t = n / fs\n    x = (A1 * np.cos(2.0 * np.pi * F1 * t + phi1) +\n         A2 * np.cos(2.0 * np.pi * F2 * t + phi2))\n    return x\n\ndef pick_two_dominant_peaks(freqs, amp):\n    \"\"\"\n    Pick two dominant peaks from one-sided amplitude spectrum.\n    Exclude DC by zeroing amp[0] before selection.\n    After picking the dominant peak, zero out a neighborhood of +/-1 bins to ensure distinct peaks.\n    Return the two peak frequencies in ascending order.\n    \"\"\"\n    amp = amp.copy()\n    # Exclude DC\n    if amp.size > 0:\n        amp[0] = 0.0\n    # First peak\n    idx1 = int(np.argmax(amp))\n    # Zero out neighborhood around first peak to avoid adjacent bins of same lobe\n    lo = max(1, idx1 - 1)  # keep DC excluded\n    hi = min(amp.size - 1, idx1 + 1)\n    amp[lo:hi+1] = 0.0\n    # Second peak\n    idx2 = int(np.argmax(amp))\n    f1 = freqs[idx1]\n    f2 = freqs[idx2]\n    return tuple(sorted((f1, f2)))\n\ndef solve():\n    # Fixed signal parameters\n    A1, A2 = 2.0, 1.0\n    F1, F2 = 5.0, 12.0  # Hz\n    phi1, phi2 = 0.0, np.pi / 3.0  # radians\n\n    # Define the test cases from the problem statement: (fs, N)\n    test_cases = [\n        (64.0, 256),  # Case 1: both below Nyquist\n        (20.0, 256),  # Case 2: F2 aliases\n        (24.0, 256),  # Case 3: F2 at Nyquist\n        (9.0, 256),   # Case 4: both alias\n    ]\n\n    results = []\n    for fs, N in test_cases:\n        x = synthesize_signal(N, fs, A1, A2, F1, F2, phi1, phi2)\n        freqs, amp = one_sided_amplitude_spectrum(x, fs)\n        # The logic was simplified as the problem states N is always even (256)\n        # The original code's logic is simpler and sufficient for even N\n        if N > 1:\n            amp[1:-1] *= 2.0\n            \n        f_low, f_high = pick_two_dominant_peaks(freqs, amp)\n        # Round to six decimals as required\n        results.append([round(f_low, 6), round(f_high, 6)])\n\n    # Final print statement in the exact required format: list of lists.\n    # Ensure six decimal places formatting.\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{v:.6f}\" for v in pair) + \"]\" for pair in results\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在获得离散傅里叶变换（DFT）频谱后，我们常常希望更精确地定位谱峰的位置和幅度，特别是当真实频率落在DFT频率网格之间时。一种常见的技术是在时间序列末尾补零以增加DFT的计算点数，即“零填充”。这个实践  将从第一性原理出发，并通过编程实践证明，零填充的本质是对潜在的连续频谱（DTFT）进行更密集的采样或插值，它并不能增加真实的光谱分辨率，但能帮助我们更准确地估计信号特征。",
            "id": "4045295",
            "problem": "您正在数值天气预报和气候模拟的背景下分析均匀采样的地球科学时间序列，其中傅里叶方法被用来估计日变化和天气尺度变率的能量含量。考虑一个实值的、有限长度的离散时间序列 $x[n]$，对于 $n \\in \\{0,1,\\dots,N-1\\}$，以采样间隔 $\\Delta t$ 进行均匀时间采样。$x[n]$ 的离散时间傅里叶变换 (DTFT) 使用以弧度为单位的角频率定义为\n$$\nX(\\omega) \\;=\\; \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\,\\omega\\, n} \\quad \\text{for } \\omega \\in \\mathbb{R}.\n$$\n离散傅里叶变换 (DFT) 在一个有限网格 $\\omega_k = 2\\pi k/N$（其中 $k \\in \\{0,1,\\dots,N-1\\}$）上对 DTFT 进行采样：\n$$\nX_N[k] \\;=\\; \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\,2\\pi\\, k\\, n / N}.\n$$\n现在定义一个长度为 $M$ 的补零序列 $x_M[n]$，其中当 $0 \\le n \\le N-1$ 时 $x_M[n] = x[n]$，当 $N \\le n \\le M-1$ 时 $x_M[n] = 0$。这里 $M$ 是 $N$ 的整数倍，即 $M = L N$，$L \\in \\mathbb{N}$。补零序列的 $M$ 点 DFT 为\n$$\nX_M[k] \\;=\\; \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i \\,2\\pi\\, k\\, n / M}.\n$$\n任务：\n1) 仅使用这些定义和求和的线性性质，从第一性原理出发，推导为什么补零操作会将采样频率网格的密度从间距 $2\\pi/N$ 增加到间距 $2\\pi/M$，而不增加关于 $x[n]$ 的新信息。解释为什么当 $M = L N$ 时，对于一个实值 $x[n]$，在对应的非负频率上，值 $X_M[\\ell L]$（其中 $\\ell \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$）精确等于 $X_N[\\ell]$，并将其解释为对同一个底层 $X(\\omega)$ 的插值，而不是产生了新的频谱内容。\n2) 实现一个程序，为以下测试套件构建实值时间序列。对于每个测试用例，使用长度为 $N$ 和补零后长度为 $M=L N$ 的实数快速傅里叶变换 (RFFT) 计算单边幅谱，然后计算指定的诊断量，以证明第 (1) 部分的数学结论。任何公式中的角度都必须以弧度为单位，但您的程序输出必须是指定格式的无量纲浮点数或布尔值。\n\n测试套件：\n- 测试 A (网格一致性，理想情况)：设 $N = 128$ 且 $L = 4$。定义\n  $$\n  x[n] \\;=\\; \\sin(2\\pi \\cdot 0.125 \\, n) \\;+\\; 0.6 \\cos(2\\pi \\cdot 0.27 \\, n + 0.3) \\;+\\; 0.2 \\sin(2\\pi \\cdot 0.37 \\, n),\n  $$\n  其中 $n = 0,1,\\dots,127$。计算长度为 $N$ 和长度为 $M = 512$ 的 RFFT。设 $X_N[\\ell]$ 表示在索引 $\\ell \\in \\{0,1,\\dots,N/2\\}$ 处的 RFFT 输出，$X_M[k]$ 表示在索引 $k \\in \\{0,1,\\dots,M/2\\}$ 处的 RFFT 输出。计算最大绝对差\n  $$\n  d_A \\;=\\; \\max_{0 \\le \\ell \\le N/2} \\left| X_M[\\ell L] - X_N[\\ell] \\right|.\n  $$\n  以浮点数形式返回 $d_A$。\n- 测试 B (非网格点上的插值峰值幅度)：设 $N = 180$，$L = 8$，且 $f_0 = 23.7 / N$ 周期/采样点。定义 $x[n] = \\cos(2\\pi f_0 n)$，其中 $n = 0,1,\\dots,179$。计算未补零 RFFT 中的最大幅度 $P_N = \\max_k |X_N[k]|$，以及补零后 RFFT 中的最大幅度 $P_M = \\max_k |X_M[k]|$。返回一个布尔值，指示是否 $P_M > P_N$。\n- 测试 C (插值频率估计的改善)：设 $N = 240$，$L = 10$，且 $f_0 = 1/24 + 0.0037$ 周期/采样点。定义 $x[n] = \\cos(2\\pi f_0 n)$，其中 $n = 0,1,\\dots,239$。设 $\\hat{k}_N$ 和 $\\hat{k}_M$ 分别为长度为 $N$ 和 $M$ 时最大幅度 RFFT 频率仓的索引。定义归一化频率仓的频率估计 $\\hat{f}_N = \\hat{k}_N / N$ 和 $\\hat{f}_M = \\hat{k}_M / M$。计算比率\n  $$\n  r_C \\;=\\; \\frac{|\\hat{f}_N - f_0|}{|\\hat{f}_M - f_0|}.\n  $$\n  以浮点数形式返回 $r_C$。\n- 测试 D (边缘情况，零信号)：设 $N = 64$ 且 $L = 16$，其中对所有 $n$ 都有 $x[n] = 0$。如同测试 A 一样，计算 $d_D = \\max_{0 \\le \\ell \\le N/2} | X_M[\\ell L] - X_N[\\ell] |$。返回一个布尔值，指示 $d_D$ 是否等于 $0.0$。\n\n实现要求：\n- 仅使用实数快速傅里叶变换来获取单边谱。信号定义中的所有角度均以弧度为单位。程序必须按上述顺序计算并返回四个结果。\n- 最终输出格式必须是单行，包含一个 Python 风格的列表，按顺序包含四个结果：$[d_A, \\text{resultB}, r_C, \\text{resultD}]$，其中 $d_A$ 和 $r_C$ 是浮点数，resultB 和 resultD 是布尔值。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[0.0,True,2.5,True]\"）。不允许有其他输出。",
            "solution": "该问题陈述已经过验证，被认为是可靠的。它在科学上基于数字信号处理的原理，定义和参数齐全，问题适定且客观。各项任务均可形式化和验证。因此，我们可以着手解决。\n\n该问题要求首先从第一性原理推导补零对时间序列离散傅里叶变换 (DFT) 的影响，然后通过数值实现来验证这些影响。\n\n**第 1 部分：理论推导与解释**\n\n我们需要证明为什么将长度为 $N$ 的有限长度离散时间序列 $x[n]$ 补零到新的长度 $M=LN$ 会增加频率网格的密度，并证明原始 $N$ 点 DFT 与补零后的 $M$ 点 DFT 之间的关系。\n\n设原始实值时间序列为 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。其离散时间傅里叶变换 (DTFT) 是角频率 $\\omega$ 的连续函数，由下式给出：\n$$\nX(\\omega) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\omega n}\n$$\n$N$ 点 DFT，记作 $X_N[k]$，在 $N$ 个离散频率 $\\omega_k = \\frac{2\\pi k}{N}$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）上对该 DTFT 进行采样。此网格的频率间距或分辨率为 $\\Delta \\omega_N = \\omega_{k+1} - \\omega_k = \\frac{2\\pi}{N}$。\n$$\nX_N[k] = X(\\omega_k) = X\\left(\\frac{2\\pi k}{N}\\right) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{N}}\n$$\n现在，我们定义一个长度为 $M = LN$ 的补零序列 $x_M[n]$，其中 $L \\in \\mathbb{N}$ 且 $L > 1$：\n$$\nx_M[n] = \\begin{cases} x[n],  0 \\le n \\le N-1 \\\\ 0,  N \\le n \\le M-1 \\end{cases}\n$$\n这个补零序列的 $M$ 点 DFT，记作 $X_M[k]$，是：\n$$\nX_M[k] = \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i \\frac{2\\pi k n}{M}}\n$$\n通过代入 $x_M[n]$ 的定义，由于之后的所有项都为零，求和可以截断到 $N-1$：\n$$\nX_M[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{M}} + \\sum_{n=N}^{M-1} (0) \\cdot e^{-i \\frac{2\\pi k n}{M}} = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{M}}\n$$\n让我们将此结果与原始 DTFT $X(\\omega)$ 进行比较。如果我们在新的频率网格点 $\\omega'_k = \\frac{2\\pi k}{M}$ 上计算 $X(\\omega)$ 的值，我们得到：\n$$\nX(\\omega'_k) = X\\left(\\frac{2\\pi k}{M}\\right) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\left(\\frac{2\\pi k}{M}\\right) n}\n$$\n我们观察到 $X_M[k] = X\\left(\\frac{2\\pi k}{M}\\right)$。这是核心发现。补零序列的 $M$ 点 DFT 在数学上等效于在更精细的频率点集合 $\\omega'_k$ 上对*原始、未补零序列* $x[n]$ 的 DTFT 进行采样。\n\n这个新频率网格的间距为 $\\Delta \\omega_M = \\frac{2\\pi}{M}$。由于 $M = LN > N$，间距 $\\Delta \\omega_M$ 小于原始间距 $\\Delta \\omega_N$。具体来说，$\\Delta \\omega_M = \\frac{\\Delta \\omega_N}{L}$。这证实了补零会增加采样频率网格的密度。\n\n至关重要的是，这个过程不会增加任何关于信号 $x[n]$ 的新信息。底层的 DTFT $X(\\omega)$ 完全由原始的 $N$ 个数据点确定。补零是一种将此 DTFT 插值到一个更精细频率网格上的高效计算方法。它并不能提高*真实*的谱分辨率，后者从根本上受限于原始观测长度 $N \\Delta t$。然而，它可以揭示原始 DFT 采样点之间谱形状的细节，这对于更准确地估计未精确落在原始粗糙网格点之一的谱峰的频率和幅度非常有用。\n\n最后，我们必须证明在原始频率采样位置，新的 DFT 与旧的 DFT 相匹配。我们考察 $X_M[k]$ 在索引 $k = \\ell L$（其中 $\\ell \\in \\{0, 1, \\dots, N-1\\}$）处的值。\n$$\nX_M[\\ell L] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi (\\ell L) n}{M}}\n$$\n代入 $M = LN$，指数中的因子 $L$ 被消掉：\n$$\nX_M[\\ell L] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi \\ell n}{N}}\n$$\n右侧的表达式正是 $N$ 点 DFT $X_N[\\ell]$ 的定义。因此，我们证明了以下恒等式：\n$$\nX_M[\\ell L] = X_N[\\ell]\n$$\n这个恒等式证实了插值谱 $X_M$ 在原始网格点上精确地恢复了原始谱 $X_N$。对于一个实值信号 $x[n]$，其频谱是共轭对称的，通常使用实数快速傅里叶变换 (RFFT) 来仅计算非负频率的唯一分量。问题指定使用 RFFT，它计算从索引 $\\ell=0$ 到 $\\ell=\\lfloor N/2 \\rfloor$ 的变换。恒等式 $X_M[\\ell L] = X_N[\\ell]$ 对此索引范围同样成立，这将在数值上得到验证。\n\n**第 2 部分：数值实现与验证**\n\n我们现在实现问题陈述中描述的四个测试用例。代码将生成指定的信号，计算它们的 $N$ 点和补零后的 $M$ 点 RFFT，并计算所需的诊断量。\n\n- **测试 A** 为一个复合信号验证了恒等式 $X_M[\\ell L] = X_N[\\ell]$。由于浮点运算，我们预期差值 $d_A$ 会是一个非常接近零的小数，但不一定精确为零。\n- **测试 B** 展示了对于频率落在粗糙 DFT 网格频率仓之间的信号分量，补零如何帮助找到更准确的峰值幅度。补零后变换中的峰值幅度 $P_M$ 应大于未补零变换中的峰值幅度 $P_N$。\n- **测试 C** 显示，补零产生的更密集的频率网格可以实现更准确的频率估计。来自补零后变换的频率估计 $\\hat{f}_M$ 将比来自未补零变换的估计 $\\hat{f}_N$ 更接近真实频率 $f_0$，从而导致误差比 $r_C > 1$。\n- **测试 D** 是使用一个零信号进行的合理性检查，对于零信号，其变换恒等于零。差值 $d_D$ 必须精确为 $0.0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement\n    related to zero-padding in Fourier transforms.\n    \"\"\"\n    results = []\n\n    # Test A (grid-consistency, happy path)\n    N_A = 128\n    L_A = 4\n    M_A = N_A * L_A\n    n_A = np.arange(N_A)\n    x_A = (np.sin(2.0 * np.pi * 0.125 * n_A) +\n           0.6 * np.cos(2.0 * np.pi * 0.27 * n_A + 0.3) +\n           0.2 * np.sin(2.0 * np.pi * 0.37 * n_A))\n\n    # Compute RFFT at length N and M (with zero-padding)\n    # The 'n' parameter in rfft handles zero-padding if n > len(x)\n    X_N_A = np.fft.rfft(x_A)\n    X_M_A = np.fft.rfft(x_A, n=M_A)\n\n    # Verify that X_M[l*L] == X_N[l]\n    # The length of rfft output is n//2 + 1\n    ell_values_A = np.arange(N_A // 2 + 1)\n    k_values_A = ell_values_A * L_A\n    \n    # Calculate the maximum absolute difference\n    d_A = np.max(np.abs(X_M_A[k_values_A] - X_N_A[ell_values_A]))\n    results.append(d_A)\n\n    # Test B (interpolated peak magnitude off-bin)\n    N_B = 180\n    L_B = 8\n    M_B = N_B * L_B\n    f0_B = 23.7 / N_B\n    n_B = np.arange(N_B)\n    x_B = np.cos(2.0 * np.pi * f0_B * n_B)\n\n    X_N_B = np.fft.rfft(x_B)\n    X_M_B = np.fft.rfft(x_B, n=M_B)\n\n    P_N = np.max(np.abs(X_N_B))\n    P_M = np.max(np.abs(X_M_B))\n\n    result_B = P_M > P_N\n    results.append(result_B)\n\n    # Test C (interpolated frequency estimate improves)\n    N_C = 240\n    L_C = 10\n    M_C = N_C * L_C\n    f0_C = 1.0 / 24.0 + 0.0037\n    n_C = np.arange(N_C)\n    x_C = np.cos(2.0 * np.pi * f0_C * n_C)\n\n    X_N_C = np.fft.rfft(x_C)\n    X_M_C = np.fft.rfft(x_C, n=M_C)\n\n    # Find indices of largest magnitude bins\n    k_hat_N = np.argmax(np.abs(X_N_C))\n    k_hat_M = np.argmax(np.abs(X_M_C))\n\n    # Calculate normalized frequency estimates\n    f_hat_N = k_hat_N / N_C\n    f_hat_M = k_hat_M / M_C\n\n    # Compute the ratio of estimation errors\n    error_N = np.abs(f_hat_N - f0_C)\n    error_M = np.abs(f_hat_M - f0_C)\n    r_C = error_N / error_M\n    results.append(r_C)\n\n    # Test D (edge case, zero signal)\n    N_D = 64\n    L_D = 16\n    M_D = N_D * L_D\n    x_D = np.zeros(N_D)\n\n    X_N_D = np.fft.rfft(x_D)\n    X_M_D = np.fft.rfft(x_D, n=M_D)\n\n    ell_values_D = np.arange(N_D // 2 + 1)\n    k_values_D = ell_values_D * L_D\n\n    d_D = np.max(np.abs(X_M_D[k_values_D] - X_N_D[ell_values_D]))\n    result_D = (d_D == 0.0)\n    results.append(result_D)\n\n    # Format and print the final output as a single-line list\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "地球科学中的许多核心问题都涉及分析不同地点或不同变量之间的时间序列关系，例如追踪波的传播、识别遥相关模式等。交叉谱分析是研究这些关系的有力工具，它揭示了信号在不同频率上的相位关系和线性相关性。本练习  模拟了两个由平流过程联系在一起的地球科学信号，要求您通过计算交叉谱和相干性，来恢复信号之间的已知时间延迟和关系强度，从而掌握分析多变量系统的核心技能。",
            "id": "4045315",
            "problem": "一对合成的地球科学时间序列被用来表示由具有已知时间延迟的平流输运连接的两个位置的标量异常（例如，海平面气压异常）。这些信号共享指定的窄带谱分量和独立的宽带噪声。任务是使用基于分段平均离散傅里叶变换的方差缩减方法来估计互谱和幅度平方相干，并验证在共享频带上恢复的期望相位与时滞所隐含的一致，同时在这些频带上存在明显的相干峰。\n\n基本原理：\n- 设 $x(t)$ 和 $y(t)$ 是以间隔 $\\Delta t$（秒）采样的实值平稳过程，采样频率为 $F_s = 1/\\Delta t$（赫兹）。离散时间样本为 $x_n = x(n \\Delta t)$ 和 $y_n = y(n \\Delta t)$，其中 $n$ 为整数。\n- 函数 $x(t)$ 的连续时间傅里叶变换为 $X(f) = \\int_{-\\infty}^{\\infty} x(t) e^{-i 2 \\pi f t} \\, dt$，其中 $f$ 是频率，单位为赫兹。时移性质指出，如果 $y(t) = x(t - \\tau)$，则对于时滞 $\\tau$（秒），有 $Y(f) = X(f) e^{-i 2 \\pi f \\tau}$。\n- 对于联合平稳过程，互谱 $S_{xy}(f)$ 定义为 $S_{xy}(f) = \\lim_{T \\to \\infty} \\mathbb{E}\\{X_T(f) \\overline{Y_T(f)}\\}$，其中 $X_T(f)$ 是在时长 $T$ 上的有限时间傅里叶变换，$\\overline{Y_T(f)}$ 表示复共轭。在 $y(t) = x(t - \\tau)$ 的条件下，互谱满足 $\\arg S_{xy}(f) = 2 \\pi f \\tau$（弧度）。\n- 幅度平方相干定义为 $\\gamma^2_{xy}(f) = \\dfrac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)}$，取值范围在 $[0,1]$，量化了在频率 $f$ 处 $x$ 的功率中与 $y$ 线性相关的部分。\n\n你必须实现一个程序，该程序：\n1. 通过在指定的共享频带 $\\{(f_i, A_i)\\}$ 上对余弦求和，并加入具有已知时滞 $\\tau$ 和指定标准差的独立零均值高斯噪声，来生成合成数据对 $(x_n, y_n)$。使用 $x_n = \\sum_i A_i \\cos(2 \\pi f_i t_n) + \\varepsilon^{(x)}_n$， $y_n = \\sum_i A_i \\cos(2 \\pi f_i (t_n - \\tau)) + \\varepsilon^{(y)}_n$，其中 $t_n = n \\Delta t$，并且 $\\varepsilon^{(x)}_n$，$\\varepsilon^{(y)}_n$ 是独立同分布的高斯噪声序列，每个序列都具有给定的标准差。在进行谱估计之前，移除样本均值（常数类型去趋势）。\n2. 使用 Welch 方法（带有 Hann 窗和 $50\\%$ 重叠的分段平均离散傅里叶变换）估计互谱 $S_{xy}(f)$ 和幅度平方相干 $\\gamma^2_{xy}(f)$，返回频率仓 $f_k$，单位为赫兹。\n3. 对于每个指定的共享频带 $f_i$，识别最近的频率仓 $f_k$ 并计算：\n   - 估计的互谱相位 $\\hat{\\phi}_i = \\arg S_{xy}(f_k)$，单位为弧度。\n   - 估计的相干性 $\\hat{\\gamma}^2_i = \\gamma^2_{xy}(f_k)$。\n   - 期望相位 $\\phi^{\\star}_i = 2 \\pi f_i \\tau$，单位为弧度，并归约到 $(-\\pi, \\pi]$ 区间；相位误差 $\\delta_i$ 必须计算为 $\\hat{\\phi}_i$ 和 $\\phi^{\\star}_i$ 之间的缠绕角差，单位为弧度。\n4. 对每个频带进行验证：\n   - 绝对相位误差满足 $|\\delta_i| \\leq \\theta_{\\mathrm{tol}}$，其中 $\\theta_{\\mathrm{tol}} = 0.35$（弧度）。\n   - 相干性超过一个阈值 $\\hat{\\gamma}^2_i \\geq \\gamma_{\\mathrm{min}}$，其中 $\\gamma_{\\mathrm{min}} = 0.7$，并且是在 $\\pm r$ 个频率仓的邻域内的局部峰值，其中 $r = 2$。\n如果一个测试用例中的所有共享频带都同时满足相位和相干性条件，则该测试用例被视为成功。\n\n物理和数值单位以及角度单位：\n- 时滞 $\\tau$ 必须以秒为单位。\n- 采样间隔 $\\Delta t$ 必须以秒为单位。\n- 频率 $f_i$ 必须以赫兹为单位。\n- 相位和相位误差必须以弧度为单位。\n\n你的程序应实现上述功能并评估以下测试套件。每个测试用例是一个元组 $(\\Delta t, N, \\tau, \\{(f_i, A_i)\\}, \\sigma_x, \\sigma_y)$，指定了采样间隔、样本数、时滞、带有幅度的共享频带集合以及噪声标准差。使用以下用例：\n- 用例 $1$ (正常情况，多频带，正延迟): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 4320,\\ \\tau = 21600\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 2.0),\\ (f_2 = 1/259200\\ \\mathrm{Hz},\\ A_2 = 1.5)\\},\\ \\sigma_x = 0.5,\\ \\sigma_y = 0.5)$。\n- 用例 $2$ (边界情况，零延迟): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 2880,\\ \\tau = 0\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 2.0),\\ (f_2 = 1/432000\\ \\mathrm{Hz},\\ A_2 = 1.2)\\},\\ \\sigma_x = 0.3,\\ \\sigma_y = 0.3)$。\n- 用例 $3$ (边缘情况，近奈奎斯特分量，负延迟): $(\\Delta t = 21600\\ \\mathrm{s},\\ N = 1200,\\ \\tau = -10800\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 1.0),\\ (f_2 = 0.9 \\times (1/(2 \\times 21600))\\ \\mathrm{Hz},\\ A_2 = 1.0)\\},\\ \\sigma_x = 0.3,\\ \\sigma_y = 0.3)$。\n- 用例 $4$ (低信噪比，预期失败): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 1440,\\ \\tau = 14400\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 0.6),\\ (f_2 = 1/432000\\ \\mathrm{Hz},\\ A_2 = 0.4)\\},\\ \\sigma_x = 1.5,\\ \\sigma_y = 1.5)$。\n\n随机性与可复现性：\n- 为高斯噪声生成使用一个固定的伪随机种子。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个条目是一个布尔值，表示相应测试用例是否成功，顺序与上面列出的一致（例如，$[True,False,True,True]$）。",
            "solution": "该问题要求实现并验证一种互谱分析方法，以估计两个合成生成的时间序列之间的时间延迟。该问题在科学上是合理的、良态的，并为获得唯一解提供了足够的信息，但这取决于对 Welch 方法中一个参数的标准假设。验证过程如下。\n\n**1. 问题规范与给定条件**\n\n问题的核心是分析两个离散时间序列 $x_n$ 和 $y_n$，它们根据以下模型生成：\n$$x_n = \\sum_i A_i \\cos(2 \\pi f_i t_n) + \\varepsilon^{(x)}_n$$\n$$y_n = \\sum_i A_i \\cos(2 \\pi f_i (t_n - \\tau)) + \\varepsilon^{(y)}_n$$\n其中 $t_n = n \\Delta t$，对于 $n = 0, 1, \\dots, N-1$。$\\varepsilon^{(x)}_n$ 和 $\\varepsilon^{(y)}_n$ 项表示独立的、零均值的高斯白噪声序列，其标准差分别为指定的 $\\sigma_x$ 和 $\\sigma_y$。序列 $y_n$ 是 $x_n$ 确定性分量的一个时滞版本，延迟为 $\\tau$ 秒，并叠加了独立的噪声。\n\n所测试的基本原理是傅里叶变换的时移性质。对于一个连续信号 $x(t)$ 及其傅里叶变换 $X(f)$，其时移版本 $y(t) = x(t-\\tau)$ 的变换为 $Y(f) = X(f) e^{-i 2 \\pi f \\tau}$。互谱，形式上定义为 $S_{xy}(f) = \\lim_{T \\to \\infty} \\mathbb{E}\\{X_T(f) \\overline{Y_T(f)}\\}$，继承了这种相位关系。在理想的无噪声情况下，即 $y(t) = x(t-\\tau)$，互谱的相位与频率和时间延迟成正比。\n\n在所提供的信号生成模型中，$y_n$ 是由 $x(t_n - \\tau)$ 构建的，这意味着对于 $\\tau > 0$，$y$ 滞后于 $x$（即 $x$ 中的一个特征在时间 $t_0$ 出现，将在 $y$ 中于时间 $t_0+\\tau$ 出现）。对于滞后信号，互谱 $S_{xy}$ 的期望相位是正的，因此问题陈述中的公式 $\\phi^{\\star}(f) = 2 \\pi f \\tau$ 是正确的。我们将遵循此公式。\n\n分析使用 Welch 方法来估计互谱密度 (CSD) $S_{xy}(f)$ 和幅度平方相干 $\\gamma^2_{xy}(f) = \\frac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)}$。问题指定了使用 Hann 窗和 $50\\%$ 重叠。Welch 方法的一个关键参数——段长度 `nperseg`——没有被指定。我们将基于一个标准且合理的假设继续，即使用 `scipy.signal` 库的默认值 `nperseg=256`。对于给定的信号长度，这个选择在频率分辨率和方差缩减之间提供了一个良好的平衡。预处理要求在进行谱估计之前，从每个时间序列中移除样本均值。\n\n对每个共享频带 $f_i$ 的验证包括三个条件：\n1.  **相位准确性**：绝对缠绕相位误差 $|\\delta_i|$ 不得超过容差 $\\theta_{\\mathrm{tol}} = 0.35$ 弧度。\n2.  **相干性幅度**：估计的相干性 $\\hat{\\gamma}^2_i$ 必须达到或超过最小阈值 $\\gamma_{\\mathrm{min}} = 0.7$。\n3.  **相干性峰值**：值 $\\hat{\\gamma}^2_i$ 必须是在 $\\pm r$ 个频率仓（其中 $r=2$）邻域内的局部最大值。\n\n一个测试用例仅当其所有指定的频带都满足所有三个条件时，才被视为成功。\n\n**2. 算法流程**\n\n对于每个测试用例 $(\\Delta t, N, \\tau, \\{(f_i, A_i)\\}, \\sigma_x, \\sigma_y)$：\n\n**步骤 1：信号生成**\n- 使用一个固定的种子初始化伪随机数生成器，以确保可复现性。\n- 创建一个长度为 $N$ 的时间向量 $t$：$t = [0, \\Delta t, 2\\Delta t, \\dots, (N-1)\\Delta t]$。\n- 通过对指定的余弦项求和，合成了信号 $x$ 和 $y$ 的确定性分量。\n- 生成独立的高斯噪声并加到每个信号上。\n- 根据去趋势的要求，计算并减去每个完整时间序列的全局均值。\n\n**步骤 2：谱估计**\n- 计算采样频率 $F_s = 1/\\Delta t$。\n- 使用 `scipy.signal.csd(x, y, fs=F_s, window='hann', nperseg=256, noverlap=128, detrend=False)` 估计互谱密度 $S_{xy}$。这里使用 `detrend=False` 是因为已经手动移除了全局均值。\n- 使用 `scipy.signal.coherence(x, y, fs=F_s, window='hann', nperseg=256, noverlap=128, detrend=False)` 估计幅度平方相干 $\\gamma^2_{xy}$。\n- 这些函数返回估计的谱量以及对应的频率数组 $f_k$。\n\n**步骤 3：验证**\n- 初始化一个标志 `case_successful` 为 `True`。\n- 对于测试用例中的每个目标频率 $f_i$：\n    - 找到最接近 $f_i$ 的频率仓 $f_k$ 的索引 $k$：$k = \\operatorname{argmin}_{j} |f_j - f_i|$。\n    - 提取估计的相位：$\\hat{\\phi}_i = \\operatorname{angle}(S_{xy}[k])$。该值在 $(-\\pi, \\pi]$ 范围内。\n    - 计算理论期望相位 $\\phi^{\\star}_{i, \\text{raw}} = 2 \\pi f_i \\tau$，然后将其缠绕到 $(-\\pi, \\pi]$ 区间：$\\phi^{\\star}_i = \\operatorname{atan2}(\\sin(\\phi^{\\star}_{i, \\text{raw}}), \\cos(\\phi^{\\star}_{i, \\text{raw}}))$。\n    - 计算缠绕相位差（误差）：$\\delta_i = \\operatorname{atan2}(\\sin(\\hat{\\phi}_i - \\phi^{\\star}_i), \\cos(\\hat{\\phi}_i - \\phi^{\\star}_i))$。\n    - 检查条件 $|\\delta_i| \\leq \\theta_{\\mathrm{tol}}$。如果失败，将 `case_successful` 设置为 `False`，并终止对此测试用例的验证。\n    - 提取估计的相干性：$\\hat{\\gamma}^2_i = \\gamma^2_{xy}[k]$。\n    - 检查条件 $\\hat{\\gamma}^2_i \\geq \\gamma_{\\mathrm{min}}$。如果失败，将 `case_successful` 设置为 `False` 并终止该用例的处理。\n    - 检查局部峰值条件。提取从索引 $k-r$ 到 $k+r$ 的相干数组切片（带边界处理）。如果 $\\hat{\\gamma}^2_i$ 不是此邻域中的最大值，则将 `case_successful` 设置为 `False`。\n- 检查完所有频带后，记录该测试用例的 `case_successful` 的最终值。\n\n对所有四个测试用例重复此过程，并将布尔结果编译成最终列表。第四个用例设计为低信噪比，预期会因相干性检查失败，从而展示该方法对噪声的敏感性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying cross-spectral estimation of time lag\n    between two synthetic geoscience time series.\n    \"\"\"\n    \n    # Define verification parameters from the problem statement.\n    theta_tol = 0.35  # radians\n    gamma_min = 0.7\n    r = 2  # neighborhood radius for peak checking\n    \n    # Use a fixed seed for reproducibility of random noise.\n    rng = np.random.default_rng(seed=42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (happy path, multi-band, positive lag)\n        (3600.0, 4320, 21600.0, [(1.0/86400.0, 2.0), (1.0/259200.0, 1.5)], 0.5, 0.5),\n        # Case 2: (boundary, zero lag)\n        (3600.0, 2880, 0.0, [(1.0/86400.0, 2.0), (1.0/432000.0, 1.2)], 0.3, 0.3),\n        # Case 3: (edge, near-Nyquist component, negative lag)\n        (21600.0, 1200, -10800.0, [(1.0/86400.0, 1.0), (0.9 * (1.0 / (2.0 * 21600.0)), 1.0)], 0.3, 0.3),\n        # Case 4: (low signal-to-noise, expected failure)\n        (3600.0, 1440, 14400.0, [(1.0/86400.0, 0.6), (1.0/432000.0, 0.4)], 1.5, 1.5),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        dt, N, tau, bands, sigma_x, sigma_y = case\n        \n        # --- 1. Generate synthetic time series ---\n        t = np.arange(N) * dt\n        x_signal = np.zeros(N)\n        y_signal = np.zeros(N)\n        \n        for f_i, A_i in bands:\n            x_signal += A_i * np.cos(2 * np.pi * f_i * t)\n            y_signal += A_i * np.cos(2 * np.pi * f_i * (t - tau))\n            \n        noise_x = rng.normal(0, sigma_x, N)\n        noise_y = rng.normal(0, sigma_y, N)\n        \n        x = x_signal + noise_x\n        y = y_signal + noise_y\n        \n        # Remove the sample mean (detrend of type constant)\n        x -= np.mean(x)\n        y -= np.mean(y)\n\n        # --- 2. Estimate cross-spectrum and coherence ---\n        fs = 1.0 / dt\n        nperseg = 256  # Using scipy default as it's not specified\n        noverlap = nperseg // 2 # 50% overlap\n\n        # Use detrend=False since we manually detrended the whole signal\n        freqs, S_xy = signal.csd(x, y, fs=fs, window='hann', nperseg=nperseg, noverlap=noverlap, detrend=False)\n        coh_freqs, C_xy = signal.coherence(x, y, fs=fs, window='hann', nperseg=nperseg, noverlap=noverlap, detrend=False)\n\n        case_successful = True\n        \n        # --- 3. Verify conditions for each shared band ---\n        for f_i, _ in bands:\n            if not case_successful: # Skip other bands if one has already failed\n                break\n\n            # Find the nearest frequency bin\n            k = np.argmin(np.abs(freqs - f_i))\n\n            # a) Verify phase error\n            phi_est = np.angle(S_xy[k])\n            phi_exp_raw = 2 * np.pi * f_i * tau\n            \n            # Wrap expected phase to (-pi, pi] to match np.angle output\n            phi_exp = np.arctan2(np.sin(phi_exp_raw), np.cos(phi_exp_raw))\n\n            # Calculate wrapped angular difference\n            phase_error = np.arctan2(np.sin(phi_est - phi_exp), np.cos(phi_est - phi_exp))\n\n            if np.abs(phase_error) > theta_tol:\n                case_successful = False\n                continue\n\n            # b) Verify coherence magnitude\n            gamma2_est = C_xy[k]\n            if gamma2_est  gamma_min:\n                case_successful = False\n                continue\n                \n            # c) Verify coherence is a local peak\n            start_idx = max(0, k - r)\n            end_idx = min(len(C_xy), k + r + 1)\n            neighborhood = C_xy[start_idx:end_idx]\n            \n            # Check if the estimated coherence is the maximum in its neighborhood.\n            # np.isclose is used to handle potential floating-point inaccuracies.\n            if not np.isclose(gamma2_est, np.max(neighborhood)):\n                case_successful = False\n                continue\n        \n        results.append(case_successful)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res).lower() for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}