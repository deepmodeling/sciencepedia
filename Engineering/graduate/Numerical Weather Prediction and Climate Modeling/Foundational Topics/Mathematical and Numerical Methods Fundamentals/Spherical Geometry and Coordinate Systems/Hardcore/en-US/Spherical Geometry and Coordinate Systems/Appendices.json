{
    "hands_on_practices": [
        {
            "introduction": "In numerical modeling, ensuring the conservation of physical quantities like mass and energy is paramount. This exercise connects the fundamental geometry of the sphere to this principle by tasking you with deriving the exact area of a latitude-longitude grid cell. You will then apply this result to understand how first-order conservative remapping weights are calculated, a crucial step when transferring data between different model grids .",
            "id": "4092520",
            "problem": "A global atmospheric model on a spherical Earth uses a latitude–longitude grid. Assume the Earth is a perfect sphere of radius $R$, with geographic latitude $\\phi \\in \\left[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right]$ and longitude $\\lambda \\in [0, 2\\pi)$. Consider a single latitude–longitude cell that spans $\\phi \\in \\left[\\phi - \\frac{\\Delta \\phi}{2}, \\phi + \\frac{\\Delta \\phi}{2}\\right]$ and $\\lambda \\in \\left[\\lambda_{0} - \\frac{\\Delta \\lambda}{2}, \\lambda_{0} + \\frac{\\Delta \\lambda}{2}\\right]$, where all angles are in radians.\n\nStarting from first principles of spherical geometry, derive an exact, closed-form expression (no small-angle approximations) for the surface area of this cell on the sphere. Then, using the requirement that the integral of a cell-averaged scalar field is conserved under remapping, derive the expression for the first-order conservative remapping weight from a source cell to a target cell in terms of the area of their spherical overlap and the area of the target cell.\n\nFinally, evaluate that conservative remapping weight for the following concrete configuration, in which a single source cell contributes to a target cell. The source cell spans\n$\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right]$ and $\\lambda \\in \\left[0, \\frac{\\pi}{18}\\right]$.\nThe target cell spans\n$\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right]$ and $\\lambda \\in \\left[\\frac{\\pi}{36}, \\frac{\\pi}{12}\\right]$.\nAssume there are no other overlapping source cells considered here; compute only the weight for this single source cell’s contribution into the target cell, defined by the ratio of the spherical overlap area to the target cell area. All angles are in radians. Express the final weight as a single exact number or a simplified exact expression without units. No rounding is required.",
            "solution": "The problem is validated as follows.\n\n**Step 1: Extract Givens**\n- The Earth is a perfect sphere of radius $R$.\n- Geographic latitude is denoted by $\\phi$, where $\\phi \\in \\left[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right]$.\n- Longitude is denoted by $\\lambda$, where $\\lambda \\in [0, 2\\pi)$.\n- A general latitude-longitude cell spans $\\phi \\in \\left[\\phi - \\frac{\\Delta \\phi}{2}, \\phi + \\frac{\\Delta \\phi}{2}\\right]$ and $\\lambda \\in \\left[\\lambda_{0} - \\frac{\\Delta \\lambda}{2}, \\lambda_{0} + \\frac{\\Delta \\lambda}{2}\\right]$.\n- The problem requires a derivation of the cell's surface area from first principles without small-angle approximations.\n- The integral of a cell-averaged scalar field is conserved under remapping.\n- A source cell ($S$) is defined by:\n  - Latitude: $\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right]$\n  - Longitude: $\\lambda \\in \\left[0, \\frac{\\pi}{18}\\right]$\n- A target cell ($T$) is defined by:\n  - Latitude: $\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right]$\n  - Longitude: $\\lambda \\in \\left[\\frac{\\pi}{36}, \\frac{\\pi}{12}\\right]$\n- The conservative remapping weight is defined as the ratio of the spherical overlap area to the target cell area.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly based on the principles of spherical geometry and the concept of conservative remapping, which are fundamental in numerical weather prediction and climate modeling. The setup is a standard, albeit simplified, representation of grid-to-grid transformations in these models.\n- **Well-Posed:** The problem is clearly structured. It asks for three distinct outputs: (1) a general formula for a cell's area, (2) a general formula for a remapping weight, and (3) a specific numerical value for that weight given a concrete configuration. The information provided is sufficient and consistent for all three tasks.\n- **Objective:** The problem is stated using precise mathematical language and definitions, free of ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is scientifically sound, well-posed, objective, and contains all necessary information to derive a unique solution. The solution process will now proceed.\n\n**Part 1: Derivation of the Surface Area of a Latitude-Longitude Cell**\n\nA point on the surface of a sphere of radius $R$ can be described by spherical coordinates $(\\lambda, \\phi)$, where $\\lambda$ is the longitude and $\\phi$ is the latitude. The infinitesimal surface area element $dA$ on the sphere is given by:\n$$dA = R^2 \\cos(\\phi) \\, d\\phi \\, d\\lambda$$\nA latitude-longitude cell is defined by the bounds $\\phi \\in [\\phi_1, \\phi_2]$ and $\\lambda \\in [\\lambda_1, \\lambda_2]$. The total surface area $A$ of this cell is found by integrating the area element over these bounds:\n$$A = \\int_{\\lambda_1}^{\\lambda_2} \\int_{\\phi_1}^{\\phi_2} R^2 \\cos(\\phi) \\, d\\phi \\, d\\lambda$$\nSince the integrand and the limits of integration are separable, we can write the integral as:\n$$A = R^2 \\left( \\int_{\\lambda_1}^{\\lambda_2} d\\lambda \\right) \\left( \\int_{\\phi_1}^{\\phi_2} \\cos(\\phi) \\, d\\phi \\right)$$\nEvaluating each integral separately:\nThe integral over longitude is:\n$$\\int_{\\lambda_1}^{\\lambda_2} d\\lambda = \\lambda_2 - \\lambda_1 = \\Delta\\lambda$$\nThe integral over latitude is:\n$$\\int_{\\phi_1}^{\\phi_2} \\cos(\\phi) \\, d\\phi = [\\sin(\\phi)]_{\\phi_1}^{\\phi_2} = \\sin(\\phi_2) - \\sin(\\phi_1)$$\nCombining these results gives the exact, closed-form expression for the surface area of the cell:\n$$A = R^2 (\\lambda_2 - \\lambda_1) (\\sin(\\phi_2) - \\sin(\\phi_1))$$\nThis expression is derived from first principles and does not use any small-angle approximations.\n\n**Part 2: Derivation of the Conservative Remapping Weight**\n\nLet $\\Psi$ be a cell-averaged scalar quantity (e.g., mass of a tracer per unit area). Conservative remapping requires that the total amount of this quantity is conserved when moving from a source grid to a target grid.\nThe total amount of the quantity, $Q$, in a cell is the product of the cell-averaged value $\\Psi$ and the cell area $A$: $Q = \\Psi A$.\nLet's consider a target cell $T$ that is overlapped by a set of source cells $\\{S_i\\}$. The total quantity in the target cell, $Q_T = \\Psi_T A_T$, must be equal to the sum of the quantities contributed by each overlapping source cell.\n$$Q_T = \\sum_i Q_{S_i \\to T}$$\nwhere $Q_{S_i \\to T}$ is the quantity transferred from source cell $S_i$ to target cell $T$.\nAssuming the scalar field is uniformly distributed within each source cell $S_i$, the amount of the quantity transferred to the target cell $T$ is proportional to the area of their intersection, $A_{S_i \\cap T}$. The quantity transferred from $S_i$ is its total quantity, $Q_{S_i} = \\Psi_{S_i} A_{S_i}$, multiplied by the fractional area of overlap:\n$$Q_{S_i \\to T} = Q_{S_i} \\frac{A_{S_i \\cap T}}{A_{S_i}} = (\\Psi_{S_i} A_{S_i}) \\frac{A_{S_i \\cap T}}{A_{S_i}} = \\Psi_{S_i} A_{S_i \\cap T}$$\nSubstituting this back into the conservation equation for $Q_T$:\n$$\\Psi_T A_T = \\sum_i \\Psi_{S_i} A_{S_i \\cap T}$$\nSolving for the cell-averaged value in the target cell, $\\Psi_T$:\n$$\\Psi_T = \\sum_i \\Psi_{S_i} \\left(\\frac{A_{S_i \\cap T}}{A_T}\\right)$$\nThis equation defines the first-order conservative remapping. The term $w_{S_i \\to T} = \\frac{A_{S_i \\cap T}}{A_T}$ is the remapping weight, which represents the contribution of source cell $S_i$ to target cell $T$. This confirms the definition provided in the problem statement.\n\n**Part 3: Evaluation of the Specific Remapping Weight**\n\nWe need to compute the weight $w_{S \\to T} = \\frac{A_{S \\cap T}}{A_T}$ for the given source cell ($S$) and target cell ($T$).\n\nThe bounds for the source cell are:\n- Latitude: $\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right] = \\left[\\frac{5\\pi}{36}, \\frac{7\\pi}{36}\\right]$\n- Longitude: $\\lambda \\in \\left[0, \\frac{\\pi}{18}\\right]$\n\nThe bounds for the target cell are:\n- Latitude: $\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right] = \\left[\\frac{5\\pi}{36}, \\frac{7\\pi}{36}\\right]$\n- Longitude: $\\lambda \\in \\left[\\frac{\\pi}{36}, \\frac{\\pi}{12}\\right]$\n\nFirst, we calculate the area of the target cell, $A_T$.\n- Latitude bounds: $\\phi_1 = \\frac{5\\pi}{36}$, $\\phi_2 = \\frac{7\\pi}{36}$\n- Longitude bounds: $\\lambda_1 = \\frac{\\pi}{36}$, $\\lambda_2 = \\frac{\\pi}{12} = \\frac{3\\pi}{36}$\nThe longitudinal width is $\\Delta\\lambda_T = \\lambda_2 - \\lambda_1 = \\frac{3\\pi}{36} - \\frac{\\pi}{36} = \\frac{2\\pi}{36} = \\frac{\\pi}{18}$.\nUsing the area formula:\n$$A_T = R^2 \\left(\\frac{\\pi}{18}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]$$\n\nNext, we determine the region of overlap, $S \\cap T$, and calculate its area, $A_{S \\cap T}$.\n- Latitude overlap: The latitude ranges for $S$ and $T$ are identical, so the overlap range is $\\phi \\in \\left[\\frac{5\\pi}{36}, \\frac{7\\pi}{36}\\right]$.\n- Longitude overlap: We find the intersection of the longitude intervals $\\left[0, \\frac{\\pi}{18}\\right]$ and $\\left[\\frac{\\pi}{36}, \\frac{\\pi}{12}\\right]$.\n  Let's use a common denominator of $36$: $\\left[0, \\frac{2\\pi}{36}\\right]$ and $\\left[\\frac{\\pi}{36}, \\frac{3\\pi}{36}\\right]$.\n  The intersection is $\\lambda \\in \\left[\\frac{\\pi}{36}, \\frac{2\\pi}{36}\\right] = \\left[\\frac{\\pi}{36}, \\frac{\\pi}{18}\\right]$.\nSo, for the overlap region $S \\cap T$:\n- Latitude bounds: $\\phi_1 = \\frac{5\\pi}{36}$, $\\phi_2 = \\frac{7\\pi}{36}$\n- Longitude bounds: $\\lambda_1 = \\frac{\\pi}{36}$, $\\lambda_2 = \\frac{\\pi}{18}$\nThe longitudinal width of the overlap is $\\Delta\\lambda_{S \\cap T} = \\frac{\\pi}{18} - \\frac{\\pi}{36} = \\frac{2\\pi - \\pi}{36} = \\frac{\\pi}{36}$.\nThe area of the overlap is:\n$$A_{S \\cap T} = R^2 \\left(\\frac{\\pi}{36}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]$$\n\nFinally, we compute the remapping weight $w_{S \\to T}$:\n$$w_{S \\to T} = \\frac{A_{S \\cap T}}{A_T} = \\frac{R^2 \\left(\\frac{\\pi}{36}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]}{R^2 \\left(\\frac{\\pi}{18}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]}$$\nThe terms $R^2$ and $\\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]$ cancel out. The weight simplifies to the ratio of the longitudinal widths of the overlap region and the target cell region:\n$$w_{S \\to T} = \\frac{\\frac{\\pi}{36}}{\\frac{\\pi}{18}} = \\frac{\\pi}{36} \\cdot \\frac{18}{\\pi} = \\frac{18}{36} = \\frac{1}{2}$$\nThe conservative remapping weight is $\\frac{1}{2}$.",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "The choice of a spherical coordinate system has profound consequences for the numerical stability of a model, a phenomenon famously known as the \"pole problem.\" This practice explores the direct link between grid geometry and model dynamics by deriving the Courant-Friedrichs-Lewy (CFL) stability limit for advection on a latitude-longitude grid. By calculating the maximum allowable timestep, you will gain a tangible understanding of why high-latitude regions pose a significant computational challenge for global models using explicit time-stepping schemes .",
            "id": "4092519",
            "problem": "Consider a latitude–longitude spherical grid used in numerical weather prediction and climate modeling on a spherical Earth of radius $R = 6.371 \\times 10^{6}$ m. A passive scalar $q$ is advected by a purely zonal wind of peak speed $U$ along a parallel at latitude $\\phi$. The governing transport is the linear advection equation $\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial s} = 0$, where $s$ denotes arc length along the parallel at fixed $\\phi$ and $u$ is the zonal component of the wind. The distance along a parallel corresponding to an angular longitude increment $\\Delta \\lambda$ is $R \\cos(\\phi) \\, \\Delta \\lambda$, with $\\Delta \\lambda$ measured in radians. The model employs an explicit first-order upwind discretization in time and longitude and is constrained by the Courant–Friedrichs–Lewy (CFL) stability requirement in the advective direction.\n\nStarting from the advection equation and the spherical arc-length relation, derive the expression for the maximum allowable timestep $\\Delta t_{\\max}$ at latitude $\\phi$ as a function of $R$, $\\phi$, $\\Delta \\lambda$, and $U$. Then, evaluate the maximum allowable timestep for the following configuration:\n- latitude $\\phi = 60^{\\circ}$,\n- initial longitude spacing $\\Delta \\lambda_{0} = 0.5^{\\circ}$,\n- refined longitude spacing $\\Delta \\lambda_{1} = 0.25^{\\circ}$,\n- peak zonal wind $U = 90$ m/s,\nwith the angles converted to radians for calculation.\n\nReport the maximum allowable timestep at $\\Delta \\lambda_{0}$, the maximum allowable timestep at $\\Delta \\lambda_{1}$, and the ratio $\\Delta t_{\\max}(\\Delta \\lambda_{1}) / \\Delta t_{\\max}(\\Delta \\lambda_{0})$. Round all reported values to four significant figures. Express the timesteps in seconds and the ratio as a dimensionless decimal.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of fluid dynamics and numerical methods, is well-posed, and uses objective language. The units for the radius $R$ and wind speed $U$ are explicitly provided, which are conventional in atmospheric science.\n\nThe first step is to derive the general expression for the maximum allowable timestep, $\\Delta t_{\\max}$. The governing equation for the transport of a passive scalar $q$ is the one-dimensional linear advection equation:\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial s} = 0\n$$\nwhere $t$ is time, $s$ is the arc length coordinate along a parallel of latitude, and $u$ is the constant zonal wind speed, given as $U$.\n\nThe problem specifies an explicit first-order upwind discretization. The partial derivative with respect to time, $\\frac{\\partial q}{\\partial t}$, is approximated using a forward difference:\n$$\n\\frac{\\partial q}{\\partial t} \\approx \\frac{q_j^{n+1} - q_j^n}{\\Delta t}\n$$\nwhere the superscript $n$ denotes the time level and the subscript $j$ denotes the spatial grid point in the longitudinal direction.\n\nThe spatial derivative, $\\frac{\\partial q}{\\partial s}$, is approximated using a first-order upwind difference. Since the wind is zonal, we can assume $u = U > 0$ without loss of generality (representing a westerly wind). The upwind direction is thus the grid point $j-1$. The spatial derivative is:\n$$\n\\frac{\\partial q}{\\partial s} \\approx \\frac{q_j^n - q_{j-1}^n}{\\Delta s}\n$$\nwhere $\\Delta s$ is the spatial grid spacing along the parallel of latitude.\n\nSubstituting these approximations into the advection equation gives the fully discretized scheme:\n$$\n\\frac{q_j^{n+1} - q_j^n}{\\Delta t} + U \\left( \\frac{q_j^n - q_{j-1}^n}{\\Delta s} \\right) = 0\n$$\nTo analyze stability, we rearrange the equation to solve for the value at the next time step, $q_j^{n+1}$:\n$$\nq_j^{n+1} = q_j^n - \\frac{U \\Delta t}{\\Delta s} (q_j^n - q_{j-1}^n)\n$$\nThis can be rewritten by defining the Courant number, $C$, as:\n$$\nC = \\frac{U \\Delta t}{\\Delta s}\n$$\nThe discretized equation becomes:\n$$\nq_j^{n+1} = (1 - C) q_j^n + C q_{j-1}^n\n$$\nFor this explicit scheme to be stable, the von Neumann stability analysis (or a simpler analysis of the coefficients) requires that the Courant number $C$ satisfies the condition $0 \\le C \\le 1$. Since $U$, $\\Delta t$, and $\\Delta s$ are all positive, the condition $C \\ge 0$ is inherently satisfied. The stability is thus governed by the Courant–Friedrichs–Lewy (CFL) condition:\n$$\nC = \\frac{U \\Delta t}{\\Delta s} \\le 1\n$$\nThe maximum allowable timestep, $\\Delta t_{\\max}$, is found at the limit of this inequality, where $C=1$:\n$$\n\\frac{U \\Delta t_{\\max}}{\\Delta s} = 1 \\implies \\Delta t_{\\max} = \\frac{\\Delta s}{U}\n$$\nThe problem provides the relationship for the arc length $\\Delta s$ corresponding to a longitude increment $\\Delta \\lambda$ (in radians) at latitude $\\phi$ on a sphere of radius $R$:\n$$\n\\Delta s = R \\cos(\\phi) \\Delta \\lambda\n$$\nSubstituting this expression for $\\Delta s$ into the equation for $\\Delta t_{\\max}$ yields the general formula:\n$$\n\\Delta t_{\\max} = \\frac{R \\cos(\\phi) \\Delta \\lambda}{U}\n$$\n\nNext, we evaluate this expression for the specified configuration. The given parameters are:\n- Radius of Earth, $R = 6.371 \\times 10^{6}$ m.\n- Peak zonal wind speed, $U = 90$ m/s.\n- Latitude, $\\phi = 60^{\\circ}$.\n- Initial longitude spacing, $\\Delta \\lambda_{0} = 0.5^{\\circ}$.\n- Refined longitude spacing, $\\Delta \\lambda_{1} = 0.25^{\\circ}$.\n\nAngles must be converted from degrees to radians for use in calculations, using the conversion factor $\\frac{\\pi}{180}$.\nThe latitude in radians is $\\phi = 60^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} = \\frac{\\pi}{3}$ radians. The cosine of this latitude is $\\cos(\\frac{\\pi}{3}) = 0.5$.\nThe longitude spacings in radians are:\n$$\n\\Delta \\lambda_{0} = 0.5^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} \\text{ rad}\n$$\n$$\n\\Delta \\lambda_{1} = 0.25^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} \\text{ rad}\n$$\n\nNow, we calculate the maximum timestep for the initial longitude spacing, $\\Delta t_{\\max}(\\Delta \\lambda_{0})$:\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{0}) = \\frac{(6.371 \\times 10^{6}) \\times \\cos(60^{\\circ}) \\times (0.5 \\times \\frac{\\pi}{180})}{90}\n$$\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{0}) = \\frac{(6.371 \\times 10^{6}) \\times 0.5 \\times (0.5 \\times \\pi)}{90 \\times 180} = \\frac{1592750 \\times \\pi}{16200} \\approx 308.8767 \\text{ s}\n$$\nRounding to four significant figures, we get $\\Delta t_{\\max}(\\Delta \\lambda_{0}) = 308.9$ s.\n\nNext, we calculate the maximum timestep for the refined longitude spacing, $\\Delta t_{\\max}(\\Delta \\lambda_{1})$:\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{1}) = \\frac{(6.371 \\times 10^{6}) \\times \\cos(60^{\\circ}) \\times (0.25 \\times \\frac{\\pi}{180})}{90}\n$$\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{1}) = \\frac{(6.371 \\times 10^{6}) \\times 0.5 \\times (0.25 \\times \\pi)}{90 \\times 180} = \\frac{796375 \\times \\pi}{16200} \\approx 154.4384 \\text{ s}\n$$\nRounding to four significant figures, we get $\\Delta t_{\\max}(\\Delta \\lambda_{1}) = 154.4$ s.\n\nFinally, we compute the ratio $\\frac{\\Delta t_{\\max}(\\Delta \\lambda_{1})}{\\Delta t_{\\max}(\\Delta \\lambda_{0})}$. From the derived formula, we can see that $\\Delta t_{\\max}$ is directly proportional to $\\Delta \\lambda$, with all other factors being constant. Thus, the ratio is:\n$$\n\\frac{\\Delta t_{\\max}(\\Delta \\lambda_{1})}{\\Delta t_{\\max}(\\Delta \\lambda_{0})} = \\frac{\\frac{R \\cos(\\phi) \\Delta \\lambda_{1}}{U}}{\\frac{R \\cos(\\phi) \\Delta \\lambda_{0}}{U}} = \\frac{\\Delta \\lambda_{1}}{\\Delta \\lambda_{0}}\n$$\nUsing the given values in degrees:\n$$\n\\text{Ratio} = \\frac{0.25^{\\circ}}{0.5^{\\circ}} = 0.5\n$$\nAs a decimal rounded to four significant figures, the ratio is $0.5000$.\n\nThe three requested values are: the maximum allowable timestep for $\\Delta \\lambda_{0}$, the maximum allowable timestep for $\\Delta \\lambda_{1}$, and their ratio.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 308.9 & 154.4 & 0.5000 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Models and observations rarely exist on the same grid, making efficient spatial queries a fundamental requirement in data assimilation and analysis. This hands-on coding challenge guides you through building a powerful tool for nearest-neighbor searches on the sphere: a k-dimensional tree. You will implement the algorithm from first principles, including the critical transformation from geodetic to 3D Cartesian coordinates, and develop a provably correct pruning strategy based on the geometry of the sphere .",
            "id": "4092517",
            "problem": "Consider a spherical Earth model with radius $R = 6{,}371{,}000\\,\\text{m}$. In numerical weather prediction and climate modeling, spatial queries on the sphere are frequently required, for example when mapping observations to model grid points. A general strategy to accelerate such queries is to build a k-dimensional tree (KD-Tree) over points, which supports efficient nearest neighbor (NN) searches.\n\nYou are to construct an algorithm that, given a set of geolocated points on the sphere, computes the great-circle distances for NN searches using a spherical KD-Tree, and then analyze the computational complexity of the search procedure. Your algorithm must be derived from first principles of spherical geometry and linear algebra, beginning from the following base:\n\n- A great-circle on a sphere of radius $R$ is the locus of points with minimal geodesic distance between any two points on the sphere's surface.\n- The scalar (dot) product of two unit vectors equals the cosine of the angle between them.\n- The Euclidean norm is defined by $\\lVert \\mathbf{x} \\rVert = \\sqrt{x_1^2 + x_2^2 + x_3^2}$.\n\nAlgorithm design requirements:\n\n- Represent each location by geodetic latitude $\\varphi$ and longitude $\\lambda$ in degrees. State clearly how to transform $(\\varphi, \\lambda)$ to a $3$-dimensional unit vector on the sphere.\n- Define the great-circle distance between two points on the sphere using only the fundamental definitions above. Avoid providing any target formulas in the problem statement.\n- Build a KD-Tree in $\\mathbb{R}^3$ over the unit vectors, using axis-aligned splits alternating over coordinates $x$, $y$, and $z$. The tree should be constructed by median splits to ensure balance.\n- Perform NN search against a query point by traversing the KD-Tree. Use a provably valid pruning criterion grounded in the monotonic relationship between the Euclidean chord distance in $\\mathbb{R}^3$ and the great-circle distance on the sphere. Define and count the number of node point evaluations performed during search as the total count of times the search algorithm computes the distance from the query to a stored node point. If there is a tie in distance, break ties by choosing the smallest index.\n- Distances must be expressed in meters, rounded to the nearest integer meter. Angles in inputs are given in degrees and must be converted to radians internally.\n\nTest suite:\n\nThere are $4$ test cases. Indices of points start at $0$ in the order provided.\n\n$1.$ Happy-path with heterogeneous global locations:\n- Points $(\\varphi, \\lambda)$ in degrees:\n  $[(51.5074, -0.1278), (48.8566, 2.3522), (40.7128, -74.0060), (35.6895, 139.6917), (-33.8688, 151.2093), (-33.9249, 18.4241), (-22.9068, -43.1729), (55.7558, 37.6173), (28.7041, 77.1025), (-1.2921, 36.8219)]$.\n- Query $(\\varphi, \\lambda)$: $(48.1351, 11.5820)$.\n- Output per test case: $[\\text{distance\\_m}, \\text{index}, \\text{nodes\\_visited}]$.\n\n$2.$ Exact match case for correctness at zero distance:\n- Points: $[(10.0, 20.0), (-10.0, -20.0), (0.0, 0.0)]$.\n- Query: $(0.0, 0.0)$.\n\n$3.$ Near-antipodal scenario to test numerical robustness and pruning efficacy:\n- Points: $[(0.0, 0.0), (0.0, 180.0), (10.0, 90.0), (-10.0, -90.0)]$.\n- Query: $(0.0, 179.999)$.\n\n$4.$ Polar and International Date Line proximity to test handling of extreme longitudes and high latitudes:\n- Points: $[(89.9, 0.0), (89.9, 179.9), (89.9, -179.9), (0.0, 180.0)]$.\n- Query: $(89.95, -179.5)$.\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets and with each test case formatted as a sublist of the three specified values. For example: $[[d_1,i_1,v_1],[d_2,i_2,v_2],[d_3,i_3,v_3],[d_4,i_4,v_4]]$, where each $d_k$ is the integer number of meters, each $i_k$ is an integer index, and each $v_k$ is an integer node visit count.\n\nNotes on scientific realism:\n\n- Assume a spherical Earth with uniform radius $R$ as specified.\n- Use the convention that positive latitude is north and positive longitude is east.\n- Ensure numerical stability by appropriate clamping when computing angles from dot products.",
            "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in spherical geometry and computational geometry, well-posed with a clear objective and sufficient constraints, and objective in its language. The problem is a formalizable and non-trivial task relevant to the specified domain of numerical modeling. All necessary data and definitions are provided, and there are no internal contradictions or scientifically implausible requirements.\n\n### 1. Fundamental Principles and Definitions\n\nThe solution is constructed from the foundational principles specified in the problem statement.\n\n#### 1.1. Coordinate System Transformation\n\nA point on the Earth's surface is given by its geodetic latitude $\\varphi$ (in degrees, positive for North) and longitude $\\lambda$ (in degrees, positive for East). To perform calculations in a Euclidean space, we transform these spherical coordinates into a $3$-dimensional Cartesian coordinate system $(x, y, z)$. The origin is at the center of the Earth, the $z$-axis passes through the North Pole, the $x$-axis passes through the intersection of the Prime Meridian $(\\lambda=0^\\circ)$ and the Equator $(\\varphi=0^\\circ)$, and the $y$-axis completes the right-handed system.\n\nFirst, we convert latitude and longitude from degrees to radians:\n$$ \\varphi_{\\text{rad}} = \\varphi \\cdot \\frac{\\pi}{180} $$\n$$ \\lambda_{\\text{rad}} = \\lambda \\cdot \\frac{\\pi}{180} $$\n\nFor a sphere of unit radius ($R=1$), the transformation equations are derived from the standard spherical-to-Cartesian conversion, noting that the geodetic latitude $\\varphi$ is the complement of the standard polar angle $\\theta$ (measured from the $z$-axis), i.e., $\\theta = \\frac{\\pi}{2} - \\varphi_{\\text{rad}}$:\n$$ x = \\cos(\\varphi_{\\text{rad}}) \\cos(\\lambda_{\\text{rad}}) $$\n$$ y = \\cos(\\varphi_{\\text{rad}}) \\sin(\\lambda_{\\text{rad}}) $$\n$$ z = \\sin(\\varphi_{\\text{rad}}) $$\nThis transformation maps any geodetic coordinate pair to a unique unit vector $\\mathbf{u} = (x, y, z)$ where $\\lVert \\mathbf{u} \\rVert = 1$. This representation is advantageous as it avoids the singularities at the poles and the discontinuity at the $180^\\circ$ meridian present in the $(\\varphi, \\lambda)$ system.\n\n#### 1.2. Great-Circle Distance\n\nThe great-circle distance is the shortest distance between two points on the surface of a sphere. For two points represented by their 3D unit vectors $\\mathbf{u}_1$ and $\\mathbf{u}_2$, the central angle $\\gamma$ between them can be found using the dot product, as specified:\n$$ \\mathbf{u}_1 \\cdot \\mathbf{u}_2 = \\lVert \\mathbf{u}_1 \\rVert \\lVert \\mathbf{u}_2 \\rVert \\cos(\\gamma) = (1)(1)\\cos(\\gamma) = \\cos(\\gamma) $$\nThe angle $\\gamma$ (in radians) is therefore:\n$$ \\gamma = \\arccos(\\mathbf{u}_1 \\cdot \\mathbf{u}_2) $$\nDue to potential floating-point inaccuracies, the dot product might slightly exceed the valid range $[-1, 1]$. It must be clamped to this interval before applying $\\arccos$. The great-circle distance $d_{gc}$ on a sphere of radius $R$ is the arc length subtended by this angle:\n$$ d_{gc} = R \\gamma = R \\arccos(\\text{clamp}(\\mathbf{u}_1 \\cdot \\mathbf{u}_2, -1, 1)) $$\nThe Earth's radius is given as $R = 6{,}371{,}000\\,\\text{m}$.\n\n### 2. K-Dimensional Tree (KD-Tree) Implementation\n\n#### 2.1. Tree Construction\n\nA KD-Tree is a binary space-partitioning data structure for organizing points in a $k$-dimensional space. Here, we build it in $\\mathbb{R}^3$ ($k=3$) using the Cartesian unit vectors derived in Section 1.1.\n\nThe tree is constructed recursively:\n1.  **Base Case**: If the list of points is empty, return `None`.\n2.  **Select Axis**: Determine the splitting axis based on the depth of the recursion, cycling through $x, y, z$. The axis index is given by `depth % 3`.\n3.  **Find Median**: Find the median of the points along the selected axis. A computationally efficient method is to use a partition algorithm (like `introselect`) to find the median element in linear time, which partitions the point list into two sub-lists of roughly equal size. The point at the median position becomes the current node.\n4.  **Recurse**: Recursively build the left subtree from the points with coordinate values less than the median on the splitting axis, and the right subtree from the points with values greater than or equal to the median.\n\nThis median-split strategy helps to create a balanced tree, which is crucial for efficient searching. The construction time complexity for $N$ points is $O(N \\log N)$.\n\n#### 2.2. Nearest Neighbor Search and Pruning\n\nThe NN search algorithm traverses the KD-Tree to find the point in the tree closest to a given query point. A key feature is the ability to prune entire branches of the tree, avoiding an exhaustive search.\n\n**Pruning Criterion**: The pruning rule relies on the monotonic relationship between the great-circle distance $d_{gc}$ and the Euclidean chord distance $d_{chord}$ in $\\mathbb{R}^3$. For two unit vectors $\\mathbf{u}_1$ and $\\mathbf{u}_2$, their squared chord distance is:\n$$ d_{chord}^2 = \\lVert \\mathbf{u}_1 - \\mathbf{u}_2 \\rVert^2 = (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot (\\mathbf{u}_1 - \\mathbf{u}_2) = \\lVert \\mathbf{u}_1 \\rVert^2 + \\lVert \\mathbf{u}_2 \\rVert^2 - 2(\\mathbf{u}_1 \\cdot \\mathbf{u}_2) $$\n$$ d_{chord}^2 = 1 + 1 - 2\\cos(\\gamma) = 2(1 - \\cos(\\gamma)) $$\nSince $\\gamma = d_{gc}/R$, and both $\\sin(\\gamma/2)$ (related to $d_{chord}$) and $\\gamma$ are monotonically increasing for $\\gamma \\in [0, \\pi]$, minimizing the chord distance is equivalent to minimizing the great-circle distance. The search algorithm can therefore work with the computationally cheaper squared chord distances.\n\n**Search Algorithm**:\nThe search is a recursive procedure, maintaining the current best-found point and its squared chord distance to the query point, $d^2_{best}$.\n1.  Start at the root of the tree.\n2.  At each node, update the best-found point if the current node is closer than the current best. The squared chord distance is calculated, and if it is smaller than $d^2_{best}$ (or equal, with a smaller original point index), the best guess is updated.\n3.  Determine which subtree to search first. Compare the query point's coordinate on the node's splitting axis with the node's coordinate. Descend into the \"closer\" subtree (the one containing the query point).\n4.  After returning from the closer subtree, a pruning check is performed for the \"farther\" subtree. The squared Euclidean distance from the query point to the splitting hyperplane is $(q_{axis} - n_{axis})^2$, where $q_{axis}$ is the query's coordinate and $n_{axis}$ is the node's coordinate on the splitting axis. If this distance is greater than the current best squared distance, $(q_{axis} - n_{axis})^2 > d^2_{best}$, then no point in the farther subtree can be closer than the current best. The entire farther branch is pruned.\n5.  If not pruned, recursively search the farther subtree.\n6.  The process terminates when the tree has been fully explored or pruned.\n\nThe number of node point evaluations is the count of times the algorithm computes a distance between the query and a point stored in a tree node.\n\n**Computational Complexity**: For uniformly distributed data, the average-case time complexity of an NN search in a balanced KD-Tree is $O(\\log N)$. However, for points lying on a lower-dimensional manifold (like our 2D spherical surface in 3D space), pruning can be less effective, and the worst-case complexity can approach $O(N)$.\n\n### 3. Final Algorithm Summary\n\n1.  Define the Earth radius $R = 6{,}371{,}000\\,\\text{m}$.\n2.  For each test case:\n    a. Convert all input latitude/longitude points (including the query point) to 3D Cartesian unit vectors. Store the original index of each point.\n    b. Construct the KD-Tree from the list of 3D point vectors and their indices using the recursive median-split method.\n    c. Initialize a node visit counter to $0$.\n    d. Perform the nearest neighbor search for the query point's vector. The search uses the squared chord distance for comparisons and the pruning rule described above. Tie-breaking is done using the original point index. The node visit counter is incremented at each distance calculation.\n    e. The search returns the nearest point vector and its original index.\n    f. Calculate the great-circle distance between the query vector and the found nearest neighbor vector using the dot product formula: $d_{gc} = R \\arccos(\\text{clamp}(\\mathbf{q} \\cdot \\mathbf{p}_{best}, -1, 1))$.\n    g. Round the distance to the nearest integer meter.\n    h. Store the triplet `[distance_m, index, nodes_visited]`.\n3.  Format and print the results for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Earth radius in meters as specified\nR_EARTH_M = 6371000\n\nclass Node:\n    \"\"\"A node in the KD-Tree.\"\"\"\n    def __init__(self, point_data=None, axis=None, left=None, right=None):\n        # point_data is a tuple: (3D point vector, original index)\n        self.point_data = point_data\n        self.axis = axis\n        self.left = left\n        self.right = right\n\nclass KDTree:\n    \"\"\"A K-Dimensional Tree for nearest neighbor search on a sphere.\"\"\"\n    def __init__(self, points_with_indices):\n        self.root = self._build_tree(points_with_indices, depth=0)\n        self.nodes_visited = 0\n\n    def _build_tree(self, points_with_indices, depth):\n        if not points_with_indices:\n            return None\n\n        k = 3  # 3 dimensions (x, y, z)\n        axis = depth % k\n        \n        # Sort points based on the current axis and find the median\n        # Using np.partition would be more efficient for large N, but sorting is clear\n        # points_with_indices.sort(key=lambda p: p[0][axis])\n        # median_idx = len(points_with_indices) // 2\n\n        # Using np.partition as it's O(n) vs O(n log n) for sort\n        points_array = np.array([p[0] for p in points_with_indices])\n        median_idx = len(points_with_indices) // 2\n        \n        # Partition the array of coordinates\n        partition_indices = np.argpartition(points_array[:, axis], median_idx)\n        \n        # Reorder the original list of tuples based on the partition\n        points_with_indices = [points_with_indices[i] for i in partition_indices]\n\n        node = Node(point_data=points_with_indices[median_idx], axis=axis)\n        node.left = self._build_tree(points_with_indices[:median_idx], depth + 1)\n        node.right = self._build_tree(points_with_indices[median_idx + 1:], depth + 1)\n\n        return node\n\n    def find_nearest(self, query_point):\n        self.nodes_visited = 0\n        if self.root is None:\n            return None, float('inf'), 0\n\n        best_point_data, best_sq_dist = self._search_recursive(self.root, query_point)\n        \n        # Final calculation of great-circle distance\n        query_vec = np.array(query_point)\n        best_vec = np.array(best_point_data[0])\n        dot_product = np.dot(query_vec, best_vec)\n        \n        # Clamp for numerical stability\n        dot_product = np.clip(dot_product, -1.0, 1.0)\n        \n        angle = np.arccos(dot_product)\n        distance = R_EARTH_M * angle\n        \n        return best_point_data, distance, self.nodes_visited\n\n    def _search_recursive(self, node, query_point):\n        # Initial best guess is the root itself\n        best_point_data = self.root.point_data\n        best_sq_dist = np.sum((np.array(query_point) - np.array(best_point_data[0]))**2)\n        \n        # Use a mutable object to pass best guess through recursion\n        best_info = {'point_data': best_point_data, 'sq_dist': best_sq_dist}\n        \n        self._search_helper(self.root, query_point, best_info)\n        \n        return best_info['point_data'], best_info['sq_dist']\n\n    def _search_helper(self, node, query_point, best_info):\n        if node is None:\n            return\n\n        self.nodes_visited += 1\n        \n        # Calculate squared Euclidean distance to current node's point\n        point_vec = np.array(node.point_data[0])\n        query_vec = np.array(query_point)\n        sq_dist = np.sum((point_vec - query_vec)**2)\n\n        # Update best if this node is closer (or equal with smaller index)\n        if sq_dist  best_info['sq_dist'] or \\\n           (sq_dist == best_info['sq_dist'] and node.point_data[1]  best_info['point_data'][1]):\n            best_info['sq_dist'] = sq_dist\n            best_info['point_data'] = node.point_data\n\n        axis = node.axis\n        diff = query_point[axis] - node.point_data[0][axis]\n\n        # Choose which subtree to visit first\n        if diff  0:\n            close_child, far_child = node.left, node.right\n        else:\n            close_child, far_child = node.right, node.left\n\n        # Recurse down the closer subtree\n        self._search_helper(close_child, query_point, best_info)\n\n        # Pruning check: if the hypersphere of the best distance crosses the splitting plane\n        if diff**2  best_info['sq_dist']:\n            self._search_helper(far_child, query_point, best_info)\n\n\ndef geo_to_cartesian(lat, lon):\n    \"\"\"Converts geodetic lat/lon (degrees) to 3D Cartesian unit vector.\"\"\"\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n    x = np.cos(lat_rad) * np.cos(lon_rad)\n    y = np.cos(lat_rad) * np.sin(lon_rad)\n    z = np.sin(lat_rad)\n    return (x, y, z)\n\ndef solve():\n    test_cases = [\n        {\n            \"points\": [(51.5074, -0.1278), (48.8566, 2.3522), (40.7128, -74.0060), \n                       (35.6895, 139.6917), (-33.8688, 151.2093), (-33.9249, 18.4241), \n                       (-22.9068, -43.1729), (55.7558, 37.6173), (28.7041, 77.1025), \n                       (-1.2921, 36.8219)],\n            \"query\": (48.1351, 11.5820)\n        },\n        {\n            \"points\": [(10.0, 20.0), (-10.0, -20.0), (0.0, 0.0)],\n            \"query\": (0.0, 0.0)\n        },\n        {\n            \"points\": [(0.0, 0.0), (0.0, 180.0), (10.0, 90.0), (-10.0, -90.0)],\n            \"query\": (0.0, 179.999)\n        },\n        {\n            \"points\": [(89.9, 0.0), (89.9, 179.9), (89.9, -179.9), (0.0, 180.0)],\n            \"query\": (89.95, -179.5)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        points_geo = case[\"points\"]\n        query_geo = case[\"query\"]\n\n        # Convert points to Cartesian and store with original index\n        points_with_indices = [\n            (geo_to_cartesian(p[0], p[1]), i) for i, p in enumerate(points_geo)\n        ]\n        query_cartesian = geo_to_cartesian(query_geo[0], query_geo[1])\n\n        # Build tree and perform search\n        kdtree = KDTree(points_with_indices)\n        best_point_data, distance, nodes_visited = kdtree.find_nearest(query_cartesian)\n        \n        best_index = best_point_data[1]\n        distance_m = int(round(distance))\n        \n        results.append([distance_m, best_index, nodes_visited])\n\n    # Format output as a list of lists, without spaces\n    result_str = '[' + ','.join([f'[{r[0]},{r[1]},{r[2]}]' for r in results]) + ']'\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}