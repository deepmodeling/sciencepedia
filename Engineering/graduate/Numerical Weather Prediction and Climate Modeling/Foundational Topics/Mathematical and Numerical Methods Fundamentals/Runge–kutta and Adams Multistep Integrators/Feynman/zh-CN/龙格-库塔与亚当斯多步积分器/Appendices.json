{
    "hands_on_practices": [
        {
            "introduction": "龙格-库塔（Runge-Kutta）方法是求解常微分方程的基石，而布彻表（Butcher tableau）则为这些方法提供了一种优雅而紧凑的表示方式。本练习将指导您从头开始构建经典的四阶龙格-库塔（RK4）方法的布彻表，揭示其系数是如何通过满足特定精度阶数条件而被确定的。通过这个过程，您将深入理解一个数值积分器代数结构与其精度之间的基本联系。",
            "id": "4084659",
            "problem": "在数值天气预报（NWP）中，对大气原始方程进行空间半离散化会产生一个大型常微分方程（ODE）组，其形式为 $\\frac{d\\mathbf{u}}{dt}=\\mathbf{F}(t,\\mathbf{u})$，其中 $\\mathbf{u}$ 表示计算网格上的预报变量，如速度分量和位温，而 $\\mathbf{F}$ 则包含了离散化的动力和物理倾向。显式龙格-库塔（RK）格式因其良好的精度和稳定性，被广泛用作此类系统的时间积分器。从一个显式 $s$ 阶龙格-库塔方法的核心定义出发，该方法具有级横坐标 $\\mathbf{c}=(c_{1},\\dots,c_{s})^{\\top}$、级矩阵 $A=(a_{ij})$ 和权重 $\\mathbf{b}=(b_{1},\\dots,b_{s})^{\\top}$，并将其应用于大气模型稳定性分析中使用的自治线性测试问题 $\\frac{dy}{dt}=\\lambda y$。通过对线性测试方程的精确指数解强制要求四阶精度，推导出经典四阶龙格-库塔方法（经典 RK4）的 Butcher 表。然后，验证对于所构造的系数，结构约束 $\\,\\mathbf{c}=A\\mathbf{1}\\,$ 和 $\\,\\sum_{i=1}^{s} b_{i}=1\\,$ 成立，其中 $\\mathbf{1}$ 表示所有分量都为 $1$ 的向量。最后，计算诊断量\n$$\nD \\;=\\; \\left\\| \\mathbf{c}-A\\mathbf{1} \\right\\|_{2} \\;+\\; \\left| \\sum_{i=1}^{s} b_{i} - 1 \\right|\n$$\n对于经典 RK4 的系数。将 $D$ 的最终答案表示为一个无单位的实数。无需四舍五入。",
            "solution": "用户要求完整推导经典四阶龙格-库塔（RK4）方法的 Butcher 表，验证其两个结构性质，并计算一个诊断量。\n\n该问题具有科学依据、适定且客观。它是常微分方程（ODE）数值分析领域的一个标准练习，并具有数值天气预报中的相关应用背景。因此，我们可以着手解答。\n\n对于初值问题 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(t, \\mathbf{u})$，一个 $s$ 阶显式龙格-库塔方法由系数 $(\\mathbf{c}, A, \\mathbf{b})$ 定义，其中 $\\mathbf{c} \\in \\mathbb{R}^s$ 是级横坐标向量，$A \\in \\mathbb{R}^{s \\times s}$ 是严格下三角的级矩阵，$\\mathbf{b} \\in \\mathbb{R}^s$ 是权重向量。数值解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 的过程如下：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\sum_{i=1}^{s} b_i \\mathbf{k}_i\n$$\n其中，各级 $\\mathbf{k}_i$ 由下式给出：\n$$\n\\mathbf{k}_i = \\mathbf{F}(t_n + c_i \\Delta t, \\mathbf{u}_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} \\mathbf{k}_j)\n$$\n\n问题要求通过对线性测试问题 $\\frac{dy}{dt} = \\lambda y$ 强制要求四阶精度来推导经典 RK4 方法的 Butcher 表。将 RK 方法应用于此测试问题，得到 $y_{n+1} = R(z) y_n$，其中 $z = \\lambda \\Delta t$，$R(z)$ 是稳定性函数。对于一个显式 RK 方法，稳定性函数可以表示为：\n$$\nR(z) = 1 + z \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1}\n$$\n其中 $\\mathbf{1}$ 是全为 1 的向量。由于 $A$ 是严格下三角矩阵，矩阵 $I-zA$ 是可逆的。使用 Neumann 级数展开其逆矩阵，我们展开 $R(z)$：\n$$\nR(z) = 1 + z \\mathbf{b}^T \\sum_{k=0}^{s-1} (zA)^k \\mathbf{1} = 1 + z(\\mathbf{b}^T\\mathbf{1}) + z^2(\\mathbf{b}^TA\\mathbf{1}) + z^3(\\mathbf{b}^TA^2\\mathbf{1}) + z^4(\\mathbf{b}^TA^3\\mathbf{1}) + \\dots\n$$\n测试问题的精确解为 $y(t_n+\\Delta t) = y(t_n) \\exp(\\lambda \\Delta t) = y_n \\exp(z)$。$\\exp(z)$ 的泰勒级数展开为：\n$$\n\\exp(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} + \\dots\n$$\n为了使一个方法达到四阶精度，其稳定性函数 $R(z)$ 必须与 $\\exp(z)$ 的级数展开在直到 $z^4$ 的项上都匹配。这导出了所谓的线性阶条件：\n\\begin{align*}\n\\mathbf{b}^T \\mathbf{1} = 1  (\\text{1 阶}) \\\\\n\\mathbf{b}^T A \\mathbf{1} = \\frac{1}{2}  (\\text{2 阶}) \\\\\n\\mathbf{b}^T A^2 \\mathbf{1} = \\frac{1}{6}  (\\text{3 阶}) \\\\\n\\mathbf{b}^T A^3 \\mathbf{1} = \\frac{1}{24}  (\\text{4 阶})\n\\end{align*}\n这些条件对于一般非线性问题达到四阶精度是必要但不充分的。一个方法是 $p=4$ 阶的，如果它满足一套更全面的八个代数方程，即阶条件。经典 RK4 方法是这八个方程组在做出若干简化假设下的一个特解。我们现在通过在这些简化选择下求解该系统来推导系数。\n\n四阶 ($p=4$) 的八个条件是：\n\\begin{align*}\n(1) \\quad  \\sum_{i} b_i = 1 \\\\\n(2) \\quad  \\sum_{i} b_i c_i = \\frac{1}{2} \\\\\n(3) \\quad  \\sum_{i} b_i c_i^2 = \\frac{1}{3} \\\\\n(4) \\quad  \\sum_{i,j} b_i a_{ij} c_j = \\frac{1}{6} \\\\\n(5) \\quad  \\sum_{i} b_i c_i^3 = \\frac{1}{4} \\\\\n(6) \\quad  \\sum_{i,j} b_i c_i a_{ij} c_j = \\frac{1}{8} \\\\\n(7) \\quad  \\sum_{i,j} b_i a_{ij} c_j^2 = \\frac{1}{12} \\\\\n(8) \\quad  \\sum_{i,j,k} b_i a_{ij} a_{jk} c_k = \\frac{1}{24}\n\\end{align*}\n经典 RK4 方法使用 $s=4$ 级。其定义性的简化假设是：\n(A1) 横坐标的选择：$\\mathbf{c} = (0, 1/2, 1/2, 1)^T$。\n(A2) 行和条件成立：对于 $i=2,3,4$，$c_i = \\sum_{j=1}^{i-1} a_{ij}$。\n(A3) 对 $A$ 的进一步结构简化：$a_{31}=0$ 且 $a_{41}=a_{42}=0$。\n\n让我们来推导这些系数。根据 (A1)，$c_1=0, c_2=1/2, c_3=1/2, c_4=1$。\n将它们代入条件 (2) 和 (3)：\n$$\n\\frac{1}{2} b_2 + \\frac{1}{2} b_3 + b_4 = \\frac{1}{2} \\quad \\implies \\quad b_2 + b_3 + 2b_4 = 1\n$$\n$$\n\\frac{1}{4} b_2 + \\frac{1}{4} b_3 + b_4 = \\frac{1}{3} \\quad \\implies \\quad b_2 + b_3 + 4b_4 = \\frac{4}{3}\n$$\n用第二个方程减去第一个方程得到 $2b_4 = 4/3 - 1 = 1/3$，所以 $b_4 = 1/6$。\n将 $b_4$ 代回得到 $b_2 + b_3 + 2(1/6) = 1$，所以 $b_2 + b_3 = 2/3$。\n根据条件 (1)，$b_1+b_2+b_3+b_4 = 1$。代入已知值，$b_1 + 2/3 + 1/6 = 1$，得到 $b_1 = 1 - 5/6 = 1/6$。\n\n现在我们确定矩阵 $A$。\n根据 (A2)：$a_{21}=c_2=1/2$。\n根据 (A2) 和 (A3)：$a_{31}+a_{32}=c_3=1/2$ 且 $a_{31}=0$，这意味着 $a_{32}=1/2$。\n根据 (A2) 和 (A3)：$a_{41}+a_{42}+a_{43}=c_4=1$ 且 $a_{41}=a_{42}=0$，这意味着 $a_{43}=1$。\n因此，矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n0 & 0 & 0 & 0 \\\\\n1/2 & 0 & 0 & 0 \\\\\n0 & 1/2 & 0 & 0 \\\\\n0 & 0 & 1 & 0\n\\end{pmatrix}\n$$\n最后，我们使用另一个阶条件来确定剩余的权重 $b_2$ 和 $b_3$。条件 (4) 是 $\\sum_{i,j} b_i a_{ij} c_j = 1/6$。由于 $c_1=0$，该式简化为：\n$$\nb_3 a_{32} c_2 + b_4 (a_{42} c_2 + a_{43} c_3) = \\frac{1}{6}\n$$\n代入推导出的 $A$ 和 $c_i$ 的值：\n$$\nb_3 (\\frac{1}{2})(\\frac{1}{2}) + \\frac{1}{6} (0 \\cdot \\frac{1}{2} + 1 \\cdot \\frac{1}{2}) = \\frac{1}{6}\n$$\n$$\n\\frac{1}{4} b_3 + \\frac{1}{12} = \\frac{1}{6} \\quad \\implies \\quad \\frac{1}{4} b_3 = \\frac{1}{12} \\quad \\implies \\quad b_3 = \\frac{4}{12} = \\frac{1}{3}\n$$\n由于 $b_2+b_3=2/3$，我们得到 $b_2 = 2/3 - 1/3 = 1/3$。\n现在所有系数都已确定。经典 RK4 方法的 Butcher 表是：\n$$\n\\begin{array}{c|cccc}\n0 & 0 & 0 & 0 & 0 \\\\\n\\frac{1}{2} & \\frac{1}{2} & 0 & 0 & 0 \\\\\n\\frac{1}{2} & 0 & \\frac{1}{2} & 0 & 0 \\\\\n1 & 0 & 0 & 1 & 0 \\\\\n\\hline\n & \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6}\n\\end{array}\n$$\n可以验证，这组系数满足所有八个阶条件。\n\n接下来，我们验证推导出的系数的两个结构约束。\n1.  验证 $\\mathbf{c} = A\\mathbf{1}$：\n    $$\n    A\\mathbf{1} = \\begin{pmatrix}\n    0 & 0 & 0 & 0 \\\\\n    1/2 & 0 & 0 & 0 \\\\\n    0 & 1/2 & 0 & 0 \\\\\n    0 & 0 & 1 & 0\n    \\end{pmatrix}\n    \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n    0 \\\\\n    1/2 \\\\\n    1/2 \\\\\n    1\n    \\end{pmatrix}\n    = \\mathbf{c}\n    $$\n    该约束成立。这在推导中被用作简化假设 (A2)。\n\n2.  验证 $\\sum_{i=1}^{s} b_i = 1$：\n    $$\n    \\sum_{i=1}^{4} b_i = \\frac{1}{6} + \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{6} = \\frac{1}{6} + \\frac{2}{6} + \\frac{2}{6} + \\frac{1}{6} = \\frac{6}{6} = 1\n    $$\n    这个约束，即一阶条件，也成立。\n\n最后，我们计算诊断量 $D$：\n$$\nD = \\left\\| \\mathbf{c}-A\\mathbf{1} \\right\\|_{2} + \\left| \\sum_{i=1}^{s} b_{i} - 1 \\right|\n$$\n基于上面的直接验证：\n第一项是向量差 $\\mathbf{c} - A\\mathbf{1}$ 的 L2 范数。由于我们证明了 $\\mathbf{c} = A\\mathbf{1}$，这个差是零向量 $\\mathbf{0}=(0,0,0,0)^T$。\n$$\n\\left\\| \\mathbf{c}-A\\mathbf{1} \\right\\|_{2} = \\left\\| \\mathbf{0} \\right\\|_{2} = 0\n$$\n第二项涉及权重的和，我们已经证明其为 $1$。\n$$\n\\left| \\sum_{i=1}^{s} b_{i} - 1 \\right| = |1 - 1| = 0\n$$\n因此，诊断量 $D$ 是：\n$$\nD = 0 + 0 = 0\n$$",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "构建了一个数值方法后，下一个关键问题是它的稳定性，这对于包含快速传播波（如重力波）的大气模型尤为重要。本练习通过将RK4方法应用于标准的线性测试方程来推导其稳定性函数，并分析其绝对稳定域的特征。通过这个实践，您将把抽象的数值理论与数值天气预报中的具体问题联系起来，从而深刻理解为何显式方法在处理刚性问题时会受到严格的时间步长限制。",
            "id": "4084714",
            "problem": "在一个数值天气预报系统的半隐式谱核心中，线性化离散原始方程的某些模式可以作为空间算子的本征模被分离出来。经过一致的空间离散化后，每个这样的模式都遵循标量常微分方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 是离散化线性算子的一个特征值，该特征值可以编码重力波的传播（$\\lambda$ 具有接近纯虚数的值）或扩散（$\\lambda$ 具有负实部）。考虑将经典的显式四阶四步龙格-库塔方法（Runge-Kutta (RK)）以固定的时间步长 $h > 0$ 应用于这个标量测试问题。设该方法由以下阶段方程定义\n$$\nk_{1} = f(y_{n}), \\quad\nk_{2} = f\\!\\left(y_{n} + \\frac{h}{2} k_{1}\\right), \\quad\nk_{3} = f\\!\\left(y_{n} + \\frac{h}{2} k_{2}\\right), \\quad\nk_{4} = f\\!\\left(y_{n} + h\\, k_{3}\\right),\n$$\n以及更新方程\n$$\ny_{n+1} = y_{n} + \\frac{h}{6}\\left(k_{1} + 2 k_{2} + 2 k_{3} + k_{4}\\right),\n$$\n其中 $f(y) = \\lambda y$ 且 $z = h \\lambda$。从这些定义和标量测试方程出发，推导由 $y_{n+1} = R(z)\\, y_{n}$ 定义的稳定性函数 $R(z)$。然后，基于 $R(z)$，定性地描述复平面中的绝对稳定域 $\\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$，说明它如何与负实轴相交以及它在虚轴附近的行为。在数值天气预报和气候模拟中，简要解释这些特征对于重力波和扩散模态的显式时间步进的意义，并将其与 Adams 型多步法的定性稳定性特性进行对比。请提供 $R(z)$ 的解析表达式作为最终答案。无需四舍五入，最终表达式中不应包含任何单位。",
            "solution": "问题陈述是适定的、有科学依据的，并包含了推导经典四阶龙格-库塔方法的稳定性函数及其性质所需的所有信息。该问题是有效的。\n\n任务是推导显式四阶四步龙格-库塔（RK4）方法在应用于标量测试方程 $y'(t) = \\lambda y(t)$（其中 $\\lambda \\in \\mathbb{C}$）时的稳定性函数 $R(z)$。稳定性函数由关系式 $y_{n+1} = R(z) y_n$ 定义，其中 $z = h\\lambda$， $h$ 是时间步长。\n\nRK4 方法定义如下：\n$$\nk_{1} = f(y_{n})\n$$\n$$\nk_{2} = f\\left(y_{n} + \\frac{h}{2} k_{1}\\right)\n$$\n$$\nk_{3} = f\\left(y_{n} + \\frac{h}{2} k_{2}\\right)\n$$\n$$\nk_{4} = f\\left(y_{n} + h k_{3}\\right)\n$$\n$$\ny_{n+1} = y_{n} + \\frac{h}{6}\\left(k_{1} + 2 k_{2} + 2 k_{3} + k_{4}\\right)\n$$\n\n对于测试方程 $y' = \\lambda y$，函数为 $f(y) = \\lambda y$。我们将其代入阶段方程：\n\n第 1 阶段：\n$$\nk_1 = \\lambda y_n\n$$\n\n第 2 阶段：\n$$\nk_2 = \\lambda \\left(y_n + \\frac{h}{2} k_1\\right) = \\lambda \\left(y_n + \\frac{h}{2} (\\lambda y_n)\\right) = \\lambda y_n \\left(1 + \\frac{h\\lambda}{2}\\right)\n$$\n\n第 3 阶段：\n$$\nk_3 = \\lambda \\left(y_n + \\frac{h}{2} k_2\\right) = \\lambda \\left(y_n + \\frac{h}{2} \\left[\\lambda y_n \\left(1 + \\frac{h\\lambda}{2}\\right)\\right]\\right) = \\lambda y_n \\left(1 + \\frac{h\\lambda}{2} + \\frac{(h\\lambda)^2}{4}\\right)\n$$\n\n第 4 阶段：\n$$\nk_4 = \\lambda \\left(y_n + h k_3\\right) = \\lambda \\left(y_n + h \\left[\\lambda y_n \\left(1 + \\frac{h\\lambda}{2} + \\frac{(h\\lambda)^2}{4}\\right)\\right]\\right) = \\lambda y_n \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{4}\\right)\n$$\n\n现在，我们将阶段 $k_1, k_2, k_3, k_4$ 的这些表达式代入 $y_{n+1}$ 的最终更新公式中：\n$$\ny_{n+1} = y_n + \\frac{h}{6} \\left[ \\lambda y_n + 2\\lambda y_n \\left(1 + \\frac{h\\lambda}{2}\\right) + 2\\lambda y_n \\left(1 + \\frac{h\\lambda}{2} + \\frac{(h\\lambda)^2}{4}\\right) + \\lambda y_n \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{4}\\right) \\right]\n$$\n从右侧提出公因子 $y_n$，并代入 $z = h\\lambda$：\n$$\ny_{n+1} = y_n \\left( 1 + \\frac{h\\lambda}{6} \\left[ 1 + 2\\left(1 + \\frac{h\\lambda}{2}\\right) + 2\\left(1 + \\frac{h\\lambda}{2} + \\frac{(h\\lambda)^2}{4}\\right) + \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{4}\\right) \\right] \\right)\n$$\n$$\ny_{n+1} = y_n \\left( 1 + \\frac{z}{6} \\left[ 1 + 2\\left(1 + \\frac{z}{2}\\right) + 2\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right) \\right] \\right)\n$$\n简化方括号内的表达式：\n$$\n[ \\dots ] = 1 + (2+z) + (2+z+\\frac{z^2}{2}) + (1+z+\\frac{z^2}{2}+\\frac{z^3}{4})\n$$\n$$\n[ \\dots ] = (1+2+2+1) + (z+z+z) + \\left(\\frac{z^2}{2}+\\frac{z^2}{2}\\right) + \\frac{z^3}{4} = 6 + 3z + z^2 + \\frac{z^3}{4}\n$$\n将此结果代回 $y_{n+1}$ 的表达式中：\n$$\ny_{n+1} = y_n \\left( 1 + \\frac{z}{6} \\left[ 6 + 3z + z^2 + \\frac{z^3}{4} \\right] \\right)\n$$\n$$\ny_{n+1} = y_n \\left( 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} \\right)\n$$\n通过与定义 $y_{n+1} = R(z) y_n$ 进行比较，我们确定稳定性函数 $R(z)$ 为：\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} = \\sum_{k=0}^{4} \\frac{z^k}{k!}\n$$\n这是指数函数 $\\exp(z)$ 的四阶泰勒级数展开。精确常微分方程的解是 $y(t_{n+1}) = \\exp(h\\lambda) y(t_n) = \\exp(z) y(t_n)$，因此 $R(z)$ 是 $\\exp(z)$ 的一个四阶近似。\n\n绝对稳定域是集合 $\\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$。\n定性地看，这个区域是复平面左半部分一个有界的、豆形的区域，它关于实轴对称并包含原点。\n-   它与负实轴的交集是一个区间 $[x_0, 0]$。左端点 $x_0$ 通过求解 $R(x_0)=-1$ 得到，得出 $x_0 \\approx -2.785$。因此，对于纯扩散问题（$z=h\\lambda$ 是实数且为负），稳定性要求是 $|z| \\leq 2.785$。\n-   它与虚轴的交集是一个区间 $[-i\\omega_0, i\\omega_0]$。端点通过求解 $|R(i\\omega)| = 1$ 得到。这发生在 $\\omega_0 = \\sqrt{8} = 2\\sqrt{2} \\approx 2.828$。因此，对于纯振荡问题（$z=h\\lambda$ 是纯虚数），稳定性要求是 $|z| \\leq 2\\sqrt{2}$。\n\n在数值天气预报和气候模拟的背景下：\n-   **扩散模态**对应于具有负实部的 $\\lambda$。负实轴上的稳定性限制（$|h\\lambda| \\leq 2.785$）对时间步长 $h$ 施加了一个约束，该约束与扩散强度成反比。对于强扩散（大的 $|\\text{Re}(\\lambda)|$），$h$ 必须非常小。\n-   **重力波模态**对应于接近纯虚数的 $\\lambda$。稳定域沿虚轴的有限范围（$|h\\lambda| \\leq 2\\sqrt{2}$）尤其具有限制性。快速传播的重力波具有大的 $\\lambda$ 虚部，这迫使使用非常小的时间步长 $h$ 来维持稳定性。这就是针对这些波的 Courant–Friedrichs–Lewy (CFL) 条件。这种严格的时间步长限制是在大气模型中使用半隐式格式的一个主要动机，在这些模型中，负责快波的项被隐式处理以消除这种稳定性约束。\n\n与 Adams 型多步法的对比：\n-   **Adams-Bashforth (显式) 方法：** 与 RK4 类似，这些是具有有界稳定域的显式方法。对于给定的阶数，它们的稳定域通常比龙格-库塔方法的稳定域更小，形状更复杂。例如，四阶 Adams-Bashforth 方法在实轴上的稳定区间约为 $[-1.3, 0]$，这比 RK4 的限制性要强得多。它们同样不适用于大气模型的刚性分量。\n-   **Adams-Moulton (隐式) 方法：** 这些方法具有大得多的稳定域。二阶 Adams-Moulton 方法（梯形法则）是 A-稳定的，意味着其稳定域包含整个左半平面，即 $\\text{Re}(z) \\leq 0$。这使其对任何扩散或纯振荡的稳定模态都是无条件稳定的。更高阶的 Adams-Moulton 方法不是 A-稳定的，但是是“刚性稳定”的，其稳定域比任何同阶的显式方法都要大得多。这种有利的稳定性特性允许使用更大的时间步长，这使得它们以及其他隐式格式，对于大气和气候模型的有效长期积分至关重要，因为在这些模型中，由各种物理过程引起的刚性是一个主要特征。像 RK4 这样的显式方法通常保留给非刚性分量，如平流，或用于启动多步法。",
            "answer": "$$\n\\boxed{1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}}\n$$"
        },
        {
            "introduction": "在实际的科学计算中，固定步长积分方案往往效率低下，因为系统通常包含快慢不同的多种过程。本练习将引导您实现一个自适应龙格-库塔方法，它使用嵌入式方法（如此处著名的Dormand-Prince RK5(4)对）来估计局部误差，并利用该误差动态调整时间步长。通过编写代码来解决一个典型的刚性问题，您将亲身体验现代数值求解器中平衡精度与效率的核心机制。",
            "id": "4084691",
            "problem": "你的任务是为一个代表快速衰减模式的标量线性常微分方程 $y'=\\lambda y$（其中 $\\lambda=-100\\,\\mathrm{s}^{-1}$）实现一个单步自适应积分。你需要使用嵌入式的 Dormand-Prince RK5(4) 对，其系数在提供的解法代码中给出。\n\n实现一个标准的步长控制器，该控制器使用缩放后的局部误差估计 $\\mathrm{err}$ 来调整步长 $\\Delta t$。接受一个时间步的条件是 $\\mathrm{err} \\leq 1$。如果一个时间步被拒绝，则使用以下公式更新步长：\n$$\n\\Delta t_{\\text{new}}=\\Delta t \\cdot \\gamma \\cdot \\mathrm{err}^{-1/5}\n$$\n其中，安全因子 $\\gamma=0.9$，并且步长缩放因子被限制在区间 $[0.2, 5.0]$ 内。\n\n对于以下四个测试用例，每个用例都以给定的初始值 $y_0$ 和初始步长 $\\Delta t_0$ 开始，计算并报告被控制器接受的第一个时间步长 $\\Delta t$ 的值。\n\n1.  $y_0=1.0, \\Delta t_0=0.05, \\mathrm{atol}=10^{-6}, \\mathrm{rtol}=10^{-3}$\n2.  $y_0=1.0, \\Delta t_0=0.5, \\mathrm{atol}=10^{-9}, \\mathrm{rtol}=10^{-6}$\n3.  $y_0=1.0, \\Delta t_0=0.5, \\mathrm{atol}=10^{-6}, \\mathrm{rtol}=10^{-2}$\n4.  $y_0=1.0 \\cdot 10^{-8}, \\Delta t_0=0.5, \\mathrm{atol}=10^{-12}, \\mathrm{rtol}=10^{-3}$\n\n你的最终答案应该是一个包含所有四个用例的已接受步长值的列表。",
            "solution": "标量初值问题 $y'=\\lambda y$（其中 $\\lambda=-100\\,\\mathrm{s}^{-1}$）模拟一个指数衰减的模式，其精确解为 $y(t)=y_0\\exp(\\lambda t)$。在数值天气预报和气候模拟中，显式时间积分器常用于非刚性分量或在避免复杂的线性求解时使用，但它们需要自适应步长控制来管理局部误差和稳定性，尤其是在存在快速衰减率时。\n\nDormand–Prince 嵌入式 Runge–Kutta 对提供两个近似解，分别为五阶和四阶，它们使用同一组级计算得出。差值 $y^{[5]}-y^{[4]}$ 作为局部误差估计。为了调整步长，需要将缩放后的误差与一个目标容差进行比较，该容差基于绝对容差 $\\mathrm{atol}$ 和相对容差 $\\mathrm{rtol}$。标量误差度量\n$$\n\\mathrm{err}=\\frac{\\left|y^{[5]}-y^{[4]}\\right|}{\\mathrm{atol}+\\mathrm{rtol}\\cdot\\max\\left(\\left|y_n\\right|,\\left|y^{[5]}\\right|\\right)}\n$$\n反映了广泛使用的求解器中的标准做法：分母将一个绝对下限与一个与解的量级成比例的项相结合，并取当前量级和试探量级中的较大者作为基准以稳定缩放。接受条件是 $\\mathrm{err}\\leq 1$；否则，该步被拒绝并且更新时间步长。\n\n自适应更新的基本原理是，局部误差的行为近似于步长的幂函数。对于一个嵌入式四/五阶对，误差估计的主导项与 $\\Delta t^{5}$ 成正比。因此，一个形式为\n$$\n\\Delta t_{\\text{new}}=\\Delta t \\cdot \\gamma \\cdot \\mathrm{err}^{-1/5}\n$$\n的控制器能在下一次尝试中使 $\\mathrm{err}$ 更接近 1，其中 $\\gamma\\in(0,1)$ 是一个安全因子，用于补偿模型不确定性和非线性效应。为了避免过度的振荡并保持数值鲁棒性，乘法变化量被限制在 $f_{\\min}$ 和 $f_{\\max}$ 之间，得到\n$$\n\\Delta t \\leftarrow \\Delta t \\cdot \\min\\left(f_{\\max},\\max\\left(f_{\\min},\\gamma\\cdot \\mathrm{err}^{-1/5}\\right)\\right),\n$$\n典型值为 $\\gamma=0.9$、$f_{\\min}=0.2$ 和 $f_{\\max}=5.0$。如果 $\\mathrm{err}=0$，差值 $y^{[5]}-y^{[4]}$ 在机器精度下为零；用一个小的正数替换 $\\mathrm{err}$ 可以避免除以零，且不影响接受判断，因为 $\\mathrm{err}\\leq 1$ 会立即触发接受。\n\n为了计算 $y^{[5]}$ 和 $y^{[4]}$，我们应用显式 Runge–Kutta 的各级计算。记 $f(y)=\\lambda y$。对于有七个级的 Dormand–Prince RK$5(4)$ 方法，各级通过递归计算：\n$$\n\\begin{aligned}\nk_1 = f\\left(y_n\\right),\\\\\nk_2 = f\\left(y_n+\\Delta t\\,a_{21}\\,k_1\\right),\\\\\nk_3 = f\\left(y_n+\\Delta t\\,(a_{31}\\,k_1+a_{32}\\,k_2)\\right),\\\\\nk_4 = f\\left(y_n+\\Delta t\\,(a_{41}\\,k_1+a_{42}\\,k_2+a_{43}\\,k_3)\\right),\\\\\nk_5 = f\\left(y_n+\\Delta t\\,(a_{51}\\,k_1+a_{52}\\,k_2+a_{53}\\,k_3+a_{54}\\,k_4)\\right),\\\\\nk_6 = f\\left(y_n+\\Delta t\\,(a_{61}\\,k_1+a_{62}\\,k_2+a_{63}\\,k_3+a_{64}\\,k_4+a_{65}\\,k_5)\\right),\\\\\nk_7 = f\\left(y_n+\\Delta t\\,(a_{71}\\,k_1+a_{72}\\,k_2+a_{73}\\,k_3+a_{74}\\,k_4+a_{75}\\,k_5+a_{76}\\,k_6)\\right).\n\\end{aligned}\n$$\n然后两个解为\n$$\ny^{[5]}=y_n+\\Delta t\\sum_{i=1}^{7} b^{[5]}_i\\,k_i,\\qquad\ny^{[4]}=y_n+\\Delta t\\sum_{i=1}^{7} b^{[4]}_i\\,k_i.\n$$\n对于我们的标量函数 $f(y)=\\lambda y$，这些操作很简单：每个级是先前计算的各级的线性组合，并由 $\\lambda$ 和 $\\Delta t$ 缩放。\n\n单步自适应的算法步骤：\n- 初始化 $y_n=y_0$、$\\lambda=-100\\,\\mathrm{s}^{-1}$ 和一个试探步长 $\\Delta t=\\Delta t_0$。\n- 使用给定的 $a_{ij}$ 计算 $k_1,\\dots,k_7$。\n- 分别使用 $b^{[5]}$ 和 $b^{[4]}$ 构建 $y^{[5]}$ 和 $y^{[4]}$。\n- 使用 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 计算 $\\mathrm{err}$。\n- 如果 $\\mathrm{err}\\leq 1$，则接受并报告 $\\Delta t$；否则，使用带有 $\\gamma=0.9$、$f_{\\min}=0.2$、$f_{\\max}=5.0$ 的控制器更新 $\\Delta t$，强制 $\\Delta t\\geq \\Delta t_{\\min}=10^{-12}\\,\\mathrm{s}$，然后重复。\n- 一旦步长被接受即停止。\n\n此方法与显式 Adams 多步方案形成对比，后者需要多步历史信息和一个启动过程；而单步 Runge–Kutta 方法是自启动的，并且非常适合快速模式下的瞬态行为。控制器指数 $-1/5$ 针对嵌入式误差中占主导地位的 $\\Delta t^{5}$ 缩放特性，而安全因子加上边界限制可以缓解过于激进的步长变化。\n\n将此方法应用于所提供的测试套件：\n- 用例 1 具有中等容差，如果缩放误差已经 $\\leq 1$，通常会直接接受 $\\Delta t_0$。\n- 用例 2 具有严格的容差和较大的 $\\Delta t_0$，初始会拒绝步长，并减小 $\\Delta t$ 直到满足缩放误差标准。\n- 用例 3 具有宽松的容差，很可能会接受初始的 $\\Delta t_0$。\n- 用例 4 在 $y_0$ 很小时强调绝对容差分量，这会影响缩放和接受判断。\n\n程序使用 Dormand–Prince 系数实现这些步骤，并以方括号括起来的单个逗号分隔列表的形式，打印所有四个用例的已接受的 $\\Delta t$ 值（以秒为单位）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rk45_single_adaptive(lambda_val, y0, dt0, atol, rtol,\n                         safety=0.9, fac_min=0.2, fac_max=5.0,\n                         dt_floor=1e-12, max_iters=1000):\n    \"\"\"\n    Perform a single adaptive explicit RK step using Dormand–Prince RK45 on y' = lambda * y.\n    Returns the accepted dt.\n    \"\"\"\n    # Dormand–Prince 5(4) coefficients\n    a = np.zeros((7, 7), dtype=float)\n    a[1,0] = 1.0/5.0\n    a[2,0] = 3.0/40.0; a[2,1] = 9.0/40.0\n    a[3,0] = 44.0/45.0; a[3,1] = -56.0/15.0; a[3,2] = 32.0/9.0\n    a[4,0] = 19372.0/6561.0; a[4,1] = -25360.0/2187.0; a[4,2] = 64448.0/6561.0; a[4,3] = -212.0/729.0\n    a[5,0] = 9017.0/3168.0; a[5,1] = -355.0/33.0; a[5,2] = 46732.0/5247.0; a[5,3] = 49.0/176.0; a[5,4] = -5103.0/18656.0\n    a[6,0] = 35.0/384.0; a[6,1] = 0.0; a[6,2] = 500.0/1113.0; a[6,3] = 125.0/192.0; a[6,4] = -2187.0/6784.0; a[6,5] = 11.0/84.0\n\n    b5 = np.array([35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0], dtype=float)\n    b4 = np.array([5179.0/57600.0, 0.0, 7571.0/16695.0, 393.0/640.0, -92097.0/339200.0, 187.0/2100.0, 1.0/40.0], dtype=float)\n\n    dt = float(dt0)\n    y_n = float(y0)\n\n    for _ in range(max_iters):\n        # Compute stages k1..k7\n        k = np.zeros(7, dtype=float)\n        # k1\n        y_stage = y_n\n        k[0] = lambda_val * y_stage\n        # k2..k7\n        for i in range(1, 7):\n            y_stage = y_n + dt * np.dot(a[i, :i], k[:i])\n            k[i] = lambda_val * y_stage\n\n        # Fifth- and fourth-order solutions\n        y5 = y_n + dt * np.dot(b5, k)\n        y4 = y_n + dt * np.dot(b4, k)\n\n        # Scaled error\n        denom = atol + rtol * max(abs(y_n), abs(y5))\n        # Guard against zero denominator (should not happen if atol>0 or rtol>0)\n        if denom == 0.0:\n            denom = np.finfo(float).tiny\n        err = abs(y5 - y4) / denom\n\n        if err = 1.0:\n            # Accept the step; clamp to floor if needed\n            return max(dt, dt_floor)\n\n        # Update dt using controller with exponent 1/5\n        # Prevent division by zero or overflow by bounding err\n        err_safe = max(err, np.finfo(float).tiny)\n        factor = safety * err_safe ** (-1.0/5.0)\n        factor = min(fac_max, max(fac_min, factor))\n        dt = max(dt_floor, dt * factor)\n\n    # If we reach here, return the current dt (best effort)\n    return max(dt, dt_floor)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (y0, dt0, atol, rtol)\n    test_cases = [\n        (1.0, 0.05, 1e-6, 1e-3),      # Case 1: happy path\n        (1.0, 0.5, 1e-9, 1e-6),       # Case 2: rejection needed\n        (1.0, 0.5, 1e-6, 1e-2),       # Case 3: loose tolerance\n        (1e-8, 0.5, 1e-12, 1e-3),     # Case 4: absolute tolerance dominates\n    ]\n\n    lambda_val = -100.0  # s^-1\n    results = []\n    for y0, dt0, atol, rtol in test_cases:\n        accepted_dt = rk45_single_adaptive(lambda_val, y0, dt0, atol, rtol)\n        results.append(accepted_dt)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}