{
    "hands_on_practices": [
        {
            "introduction": "Understanding vertical motion in the atmosphere is fundamental to climate modeling, and this motion is largely driven by buoyancy. This exercise will guide you through a first-principles calculation to quantify how water vapor affects air density, making a moist air parcel buoyant relative to its dry surroundings. Mastering this calculation is key to appreciating how Atmospheric General Circulation Models (AGCMs) parameterize convection, a process crucial for global energy and water cycles. ",
            "id": "4013689",
            "problem": "An Atmospheric General Circulation Model (AGCM) grid column contains a near-surface air parcel characterized by temperature $T=300\\ \\mathrm{K}$, pressure $p=950\\ \\mathrm{hPa}$, and specific humidity $q_v=0.015$ (dimensionless mass fraction of water vapor). Assume no condensed water ($q_l=0$), and treat the surrounding reference environment as having the same $T$ and $p$ but being perfectly dry (i.e., $q_v=0$). Use the Ideal Gas Law applied to an ideal mixture of gases as the fundamental base, together with the standard specific gas constants for dry air $R_d=287.0\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$ and for water vapor $R_v=461.5\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$. Gravitational acceleration is $g=9.81\\ \\mathrm{m}\\ \\mathrm{s}^{-2}$.\n\nStarting from first principles, derive an expression for the moist-air density $\\rho$ in terms of $p$, $T$, $q_v$, $R_d$, and $R_v$, and compute the moist-air density of the parcel and the dry-air density of the environment at the stated conditions. Then, quantify the buoyancy effect of moisture by computing the buoyancy acceleration\n$$B = g\\,\\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{parcel}}}{\\rho_{\\mathrm{env}}},$$\nwhere $\\rho_{\\mathrm{env}}$ is the dry-air density at the given $p$ and $T$, and $\\rho_{\\mathrm{parcel}}$ is the moist-air density at the given $p$, $T$, and $q_v$.\n\nExpress the final numerical answer for $B$ in $\\mathrm{m}\\ \\mathrm{s}^{-2}$, and round your answer to four significant figures. Convert $p$ to $\\mathrm{Pa}$ for all calculations.",
            "solution": "The problem statement has been critically validated and found to be scientifically grounded, well-posed, internally consistent, and objective. It is a standard problem in atmospheric thermodynamics. Accordingly, I will proceed with a full solution.\n\nThe first step is to derive an expression for the density of a moist air parcel, $\\rho$, from first principles, namely the Ideal Gas Law applied to a mixture of ideal gases. Moist air is treated as a mixture of dry air and water vapor.\n\nAccording to Dalton's Law of partial pressures, the total pressure $p$ is the sum of the partial pressures of its constituents. For moist air, this is:\n$$p = p_d + e$$\nwhere $p_d$ is the partial pressure of dry air and $e$ is the partial pressure of water vapor.\n\nThe Ideal Gas Law can be applied to each component separately:\n$$p_d = \\rho_d R_d T$$\n$$e = \\rho_v R_v T$$\nwhere $\\rho_d$ and $\\rho_v$ are the densities of dry air and water vapor, respectively, $R_d$ is the specific gas constant for dry air, $R_v$ is the specific gas constant for water vapor, and $T$ is the temperature of the mixture.\n\nThe total density of the moist air parcel, $\\rho$, is the sum of the component densities:\n$$\\rho = \\rho_d + \\rho_v$$\nThe specific humidity, $q_v$, is defined as the mass of water vapor per unit mass of moist air. In terms of densities, this is $q_v = \\rho_v / \\rho$. Similarly, the mass fraction of dry air is $q_d = \\rho_d / \\rho$. It follows that $q_d + q_v = 1$, or $q_d = 1 - q_v$.\nFrom these definitions, we can express the partial densities in terms of the total density $\\rho$:\n$$\\rho_v = q_v \\rho$$\n$$\\rho_d = (1 - q_v) \\rho$$\nSubstituting these expressions back into the equations for partial pressures:\n$$p_d = (1 - q_v) \\rho R_d T$$\n$$e = q_v \\rho R_v T$$\nNow, summing these to recover the total pressure $p$:\n$$p = p_d + e = (1 - q_v) \\rho R_d T + q_v \\rho R_v T$$\nWe can factor out $\\rho$ and $T$:\n$$p = \\rho T [(1 - q_v) R_d + q_v R_v]$$\nThis equation can be rearranged to solve for the moist air density $\\rho$:\n$$\\rho = \\frac{p}{T [(1 - q_v) R_d + q_v R_v]}$$\nThis is the desired expression for moist-air density in terms of the given variables. The term in the square brackets can be interpreted as the specific gas constant for the moist air mixture, $R_m = (1 - q_v) R_d + q_v R_v$. So, the Ideal Gas Law for moist air can be written as $p = \\rho R_m T$.\n\nNext, we compute the required quantities. The pressure must be converted to SI units (Pascals):\n$p = 950\\ \\mathrm{hPa} = 950 \\times 100\\ \\mathrm{Pa} = 95000\\ \\mathrm{Pa}$.\nThe other given values are:\n$T = 300\\ \\mathrm{K}$\n$g = 9.81\\ \\mathrm{m}\\ \\mathrm{s}^{-2}$\n$R_d = 287.0\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$\n$R_v = 461.5\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$\n\nFor the dry environment, the specific humidity is $q_v = 0$. The density formula simplifies to the Ideal Gas Law for dry air:\n$$\\rho_{\\mathrm{env}} = \\frac{p}{R_d T} = \\frac{95000\\ \\mathrm{Pa}}{(287.0\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1})(300\\ \\mathrm{K})} = \\frac{95000}{86100}\\ \\mathrm{kg}\\ \\mathrm{m}^{-3} \\approx 1.103368\\ \\mathrm{kg}\\ \\mathrm{m}^{-3}$$\nFor the moist air parcel, the specific humidity is $q_v = 0.015$. We first compute the specific gas constant for the moist air parcel, $R_m$:\n$$R_m = (1 - 0.015)(287.0\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}) + (0.015)(461.5\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1})$$\n$$R_m = (0.985)(287.0) + (0.015)(461.5)\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$$\n$$R_m = 282.695 + 6.9225\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1} = 289.6175\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$$\nNow we can compute the density of the moist parcel:\n$$\\rho_{\\mathrm{parcel}} = \\frac{p}{R_m T} = \\frac{95000\\ \\mathrm{Pa}}{(289.6175\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1})(300\\ \\mathrm{K})} = \\frac{95000}{86885.25}\\ \\mathrm{kg}\\ \\mathrm{m}^{-3} \\approx 1.093392\\ \\mathrm{kg}\\ \\mathrm{m}^{-3}$$\nAs expected, at the same temperature and pressure, the moist air is less dense than the dry air.\n\nFinally, we compute the buoyancy acceleration, $B$:\n$$B = g\\,\\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{parcel}}}{\\rho_{\\mathrm{env}}}$$\nThe fractional term can be simplified by substituting the expressions for density:\n$$\\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{parcel}}}{\\rho_{\\mathrm{env}}} = 1 - \\frac{\\rho_{\\mathrm{parcel}}}{\\rho_{\\mathrm{env}}} = 1 - \\frac{p/(R_m T)}{p/(R_d T)} = 1 - \\frac{R_d}{R_m} = \\frac{R_m - R_d}{R_m}$$\nWe have $R_m = 289.6175\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$ and $R_d = 287.0\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$.\n$$R_m - R_d = 289.6175 - 287.0 = 2.6175\\ \\mathrm{J}\\ \\mathrm{kg}^{-1}\\ \\mathrm{K}^{-1}$$\nIt is useful to verify this difference algebraically: $R_m - R_d = [(1-q_v)R_d + q_v R_v] - R_d = q_v(R_v - R_d)$.\nUsing the given values: $0.015 \\times (461.5 - 287.0) = 0.015 \\times 174.5 = 2.6175$. The values match, confirming our calculation of $R_m$.\n\nNow, we compute $B$:\n$$B = g \\frac{R_m - R_d}{R_m} = (9.81\\ \\mathrm{m}\\ \\mathrm{s}^{-2}) \\left( \\frac{2.6175}{289.6175} \\right)$$\n$$B \\approx (9.81\\ \\mathrm{m}\\ \\mathrm{s}^{-2})(0.009037748) \\approx 0.0886603\\ \\mathrm{m}\\ \\mathrm{s}^{-2}$$\nRounding the result to four significant figures gives $0.08866\\ \\mathrm{m}\\ \\mathrm{s}^{-2}$.",
            "answer": "$$\\boxed{0.08866}$$"
        },
        {
            "introduction": "A key task for any AGCM is to correctly simulate the large-scale atmospheric circulation, including prominent features like the jet streams. This hands-on practice explores the thermal wind relationship, a cornerstone of geophysical fluid dynamics that explains how vertical wind shear is maintained by horizontal temperature gradients. By working through this problem, you will see how the atmosphere's large-scale wind and temperature fields are dynamically coupled in geostrophic and hydrostatic balance. ",
            "id": "4013716",
            "problem": "An Atmospheric General Circulation Model (GCM) diagnoses the vertical shear of the zonal wind from the resolved temperature field under large-scale balance assumptions. Consider a midlatitude column at latitude $\\phi$ on a rotating sphere, where the meridional temperature gradient $\\partial T/\\partial y$ is approximately uniform with height over the tropospheric layer of interest. Starting only from hydrostatic balance, geostrophic balance on constant-pressure surfaces, and the ideal gas law, derive an expression for the vertical derivative of the geostrophic zonal wind with respect to logarithmic pressure, $\\partial u_g/\\partial \\ln p$, in terms of the meridional temperature gradient $\\partial T/\\partial y$, the Coriolis parameter $f$, and the specific gas constant for dry air $R$. Then, under the assumption that $\\partial T/\\partial y$ is constant with pressure in the layer, integrate this expression between the lower-tropospheric level $p_{\\ell}$ and the upper-tropospheric level $p_u$ to obtain $u_g(p_u)$ given $u_g(p_{\\ell})$.\n\nUse the following scientifically plausible parameters representative of a midlatitude wintertime state:\n- Latitude $\\phi = 45^{\\circ}$; treat $\\phi$ in degrees and convert to radians when evaluating trigonometric functions.\n- Earthâ€™s rotation rate $\\Omega = 7.292\\,1159 \\times 10^{-5}\\,\\mathrm{s}^{-1}$ and Coriolis parameter $f = 2 \\Omega \\sin \\phi$.\n- Dry-air gas constant $R = 287\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$.\n- Meridional temperature gradient $\\partial T/\\partial y = -6.0\\,\\mathrm{K}$ per $1000\\,\\mathrm{km}$, assumed constant with pressure over the layer (convert to $\\mathrm{K}\\,\\mathrm{m}^{-1}$).\n- Lower level $p_{\\ell} = 850\\,\\mathrm{hPa}$ with geostrophic zonal wind $u_g(p_{\\ell}) = 8.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$ (take eastward as positive).\n- Upper level $p_u = 200\\,\\mathrm{hPa}$ with an observed zonal wind $U_{\\mathrm{obs}}(p_u) = 38.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$.\n\nCompute the signed mismatch\n$$\\delta \\equiv u_{\\mathrm{TW}}(p_u) - U_{\\mathrm{obs}}(p_u),$$\nwhere $u_{\\mathrm{TW}}(p_u)$ is the thermally predicted geostrophic zonal wind at $p_u$ obtained by vertically integrating your derived expression. Express the final mismatch $\\delta$ in meters per second, and round your answer to three significant figures.",
            "solution": "The problem is valid as it is scientifically grounded in the fundamental principles of atmospheric dynamics, is well-posed with sufficient and consistent data, and is expressed in objective, formal language. It represents a standard application of the thermal wind relationship, a cornerstone of dynamic meteorology.\n\nThe task is to derive an expression for the vertical shear of the geostrophic zonal wind, integrate it to predict an upper-level wind speed, and compare this prediction to an observed value. The derivation starts from three fundamental principles:\n\n1.  **Geostrophic Balance** for the zonal wind ($u_g$) on an isobaric (constant pressure) surface:\n    $$u_g = -\\frac{1}{f} \\left(\\frac{\\partial \\Phi}{\\partial y}\\right)_p$$\n    where $\\Phi$ is the geopotential, $f$ is the Coriolis parameter, and the subscript $p$ indicates the derivative is taken at constant pressure.\n\n2.  **Hydrostatic Balance** in pressure coordinates:\n    $$\\frac{\\partial \\Phi}{\\partial p} = -\\frac{1}{\\rho}$$\n    where $p$ is pressure and $\\rho$ is air density.\n\n3.  **The Ideal Gas Law** for dry air:\n    $$p = \\rho R T \\implies \\frac{1}{\\rho} = \\frac{RT}{p}$$\n    where $R$ is the specific gas constant for dry air and $T$ is the temperature.\n\nOur goal is to find an expression for $\\partial u_g/\\partial \\ln p$. We begin by taking the partial derivative of the geostrophic wind equation with respect to pressure $p$:\n$$\\frac{\\partial u_g}{\\partial p} = \\frac{\\partial}{\\partial p} \\left[ -\\frac{1}{f} \\left(\\frac{\\partial \\Phi}{\\partial y}\\right)_p \\right]$$\nSince the Coriolis parameter $f$ is a function of latitude ($y$) only and not pressure, and assuming the geopotential field is sufficiently smooth, we can commute the partial derivatives:\n$$\\frac{\\partial u_g}{\\partial p} = -\\frac{1}{f} \\frac{\\partial}{\\partial y} \\left( \\frac{\\partial \\Phi}{\\partial p} \\right)_p$$\nNext, we substitute the hydrostatic balance equation into this expression:\n$$\\frac{\\partial u_g}{\\partial p} = -\\frac{1}{f} \\frac{\\partial}{\\partial y} \\left( -\\frac{1}{\\rho} \\right)_p = \\frac{1}{f} \\frac{\\partial}{\\partial y} \\left( \\frac{1}{\\rho} \\right)_p$$\nNow, we use the ideal gas law to replace density $\\rho$ with temperature $T$ and pressure $p$:\n$$\\frac{\\partial u_g}{\\partial p} = \\frac{1}{f} \\frac{\\partial}{\\partial y} \\left( \\frac{RT}{p} \\right)_p$$\nSince the derivative with respect to $y$ is taken at constant pressure $p$, and $R$ is a constant, we can write:\n$$\\frac{\\partial u_g}{\\partial p} = \\frac{R}{fp} \\left(\\frac{\\partial T}{\\partial y}\\right)_p$$\nThe problem asks for the derivative with respect to logarithmic pressure, $\\ln p$. We use the chain rule: $\\partial u_g/\\partial \\ln p = (\\partial u_g/\\partial p) (\\partial p/\\partial \\ln p)$. Since $d(\\ln p) = (1/p) dp$, we have $\\partial p/\\partial \\ln p = p$. Therefore:\n$$\\frac{\\partial u_g}{\\partial \\ln p} = \\left( \\frac{R}{fp} \\left(\\frac{\\partial T}{\\partial y}\\right)_p \\right) \\cdot p$$\n$$\\frac{\\partial u_g}{\\partial \\ln p} = \\frac{R}{f} \\left(\\frac{\\partial T}{\\partial y}\\right)_p$$\nThis is the thermal wind equation in log-pressure coordinates, expressing the vertical shear of the geostrophic wind in terms of the horizontal temperature gradient.\n\nThe second part of the problem requires integrating this expression from a lower pressure level $p_{\\ell}$ to an upper level $p_u$, assuming the meridional temperature gradient $\\partial T/\\partial y$ is constant with height (and thus with pressure). Since $R$ and $f$ are also constant with pressure, the entire right-hand side is constant.\n$$\\int_{u_g(p_{\\ell})}^{u_g(p_u)} d u_g = \\int_{\\ln p_{\\ell}}^{\\ln p_u} \\frac{R}{f} \\left(\\frac{\\partial T}{\\partial y}\\right)_p d(\\ln p)$$\n$$u_g(p_u) - u_g(p_{\\ell}) = \\left[ \\frac{R}{f} \\left(\\frac{\\partial T}{\\partial y}\\right)_p \\right] \\left( \\ln(p_u) - \\ln(p_{\\ell}) \\right)$$\n$$u_g(p_u) - u_g(p_{\\ell}) = \\frac{R}{f} \\left(\\frac{\\partial T}{\\partial y}\\right)_p \\ln\\left(\\frac{p_u}{p_{\\ell}}\\right)$$\nThe thermally predicted zonal wind at the upper level, which we denote $u_{\\mathrm{TW}}(p_u)$, is therefore:\n$$u_{\\mathrm{TW}}(p_u) = u_g(p_{\\ell}) + \\frac{R}{f} \\left(\\frac{\\partial T}{\\partial y}\\right)_p \\ln\\left(\\frac{p_u}{p_{\\ell}}\\right)$$\n\nFinally, we compute the numerical value for the mismatch $\\delta$.\nThe given parameters are:\n- Latitude: $\\phi = 45^{\\circ} = \\frac{\\pi}{4}$ radians\n- Earth's rotation rate: $\\Omega = 7.2921159 \\times 10^{-5}\\,\\mathrm{s}^{-1}$\n- Dry-air gas constant: $R = 287\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$\n- Meridional temperature gradient: $\\partial T/\\partial y = -6.0\\,\\mathrm{K} / (1000\\,\\mathrm{km}) = -6.0 \\times 10^{-6}\\,\\mathrm{K}\\,\\mathrm{m}^{-1}$\n- Lower level pressure: $p_{\\ell} = 850\\,\\mathrm{hPa}$\n- Lower level wind: $u_g(p_{\\ell}) = 8.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$\n- Upper level pressure: $p_u = 200\\,\\mathrm{hPa}$\n- Observed upper level wind: $U_{\\mathrm{obs}}(p_u) = 38.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$\n\nFirst, we calculate the Coriolis parameter $f$:\n$$f = 2 \\Omega \\sin\\phi = 2 \\times (7.2921159 \\times 10^{-5}\\,\\mathrm{s}^{-1}) \\times \\sin(45^{\\circ}) \\approx 1.03125 \\times 10^{-4}\\,\\mathrm{s}^{-1}$$\nNext, we calculate the thermal wind contribution, which is the change in wind speed between the two levels:\n$$\\Delta u_g = u_{\\mathrm{TW}}(p_u) - u_g(p_{\\ell}) = \\frac{R}{f} \\left(\\frac{\\partial T}{\\partial y}\\right)_p \\ln\\left(\\frac{p_u}{p_{\\ell}}\\right)$$\n$$\\Delta u_g \\approx \\frac{287\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}}{1.03125 \\times 10^{-4}\\,\\mathrm{s}^{-1}} \\times (-6.0 \\times 10^{-6}\\,\\mathrm{K}\\,\\mathrm{m}^{-1}) \\times \\ln\\left(\\frac{200}{850}\\right)$$\nThe term $\\ln(200/850) = \\ln(4/17) \\approx -1.44692$.\n$$\\Delta u_g \\approx (2.78278 \\times 10^6\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1}\\,\\mathrm{K}^{-1}) \\times (-6.0 \\times 10^{-6}\\,\\mathrm{K}\\,\\mathrm{m}^{-1}) \\times (-1.44692)$$\n$$\\Delta u_g \\approx (-16.6967\\,\\mathrm{m}\\,\\mathrm{s}^{-1}) \\times (-1.44692) \\approx 24.159\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$$\nThe predicted upper-level wind is:\n$$u_{\\mathrm{TW}}(p_u) = u_g(p_{\\ell}) + \\Delta u_g \\approx 8.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1} + 24.159\\,\\mathrm{m}\\,\\mathrm{s}^{-1} = 32.159\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$$\nThe signed mismatch $\\delta$ is the difference between the predicted and observed winds:\n$$\\delta = u_{\\mathrm{TW}}(p_u) - U_{\\mathrm{obs}}(p_u) \\approx 32.159\\,\\mathrm{m}\\,\\mathrm{s}^{-1} - 38.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1} = -5.841\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$$\nRounding the result to three significant figures, we get:\n$$\\delta \\approx -5.84\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$$",
            "answer": "$$\\boxed{-5.84}$$"
        },
        {
            "introduction": "The dynamical core of an AGCM solves the primitive equations on a discrete grid, and the specific arrangement of variables on that grid has profound implications for the model's accuracy and stability. This exercise dives into the numerical heart of AGCMs by having you implement and compare derivative operators on the Arakawa A-grid and C-grid. Through this practice, you will gain direct insight into how grid staggering choices affect the representation of divergence and vorticity, and why these choices are critical for preventing computational noise and simulating atmospheric waves correctly. ",
            "id": "4013641",
            "problem": "You are given a doubly periodic, two-dimensional rectangular domain of size $L_x \\times L_y$ with uniform grid spacing $\\,\\Delta x = L_x/N_x\\,$ and $\\,\\Delta y = L_y/N_y\\,$. Consider a test wind field composed of a rotational component described by a streamfunction and a divergent component described by a velocity potential. Let the streamfunction be\n$$\\psi(x,y) = A_\\psi \\cos\\left(\\frac{2\\pi m_\\psi x}{L_x}\\right)\\cos\\left(\\frac{2\\pi n_\\psi y}{L_y}\\right),$$\nand the velocity potential be\n$$\\chi(x,y) = A_\\chi \\sin\\left(\\frac{2\\pi m_\\chi x}{L_x}\\right)\\sin\\left(\\frac{2\\pi n_\\chi y}{L_y}\\right).$$\nDefine the wind components by the Helmholtz decomposition\n$$u(x,y) = \\frac{\\partial \\chi}{\\partial x} - \\frac{\\partial \\psi}{\\partial y}, \\qquad v(x,y) = \\frac{\\partial \\chi}{\\partial y} + \\frac{\\partial \\psi}{\\partial x}.$$\nFor completeness, a pressure field is also specified as\n$$p(x,y) = A_p \\cos\\left(\\frac{2\\pi m_p x}{L_x}\\right)\\cos\\left(\\frac{2\\pi n_p y}{L_y}\\right),$$\nbut it is not used directly in this task. The target diagnostic fields are the horizontal divergence and relative vorticity, defined by\n$$\\delta(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}, \\qquad \\zeta(x,y) = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y}.$$\nFrom the definitions of $\\,\\psi\\,$ and $\\,\\chi\\,$, the analytic divergence and vorticity satisfy\n$$\\delta_{\\mathrm{true}}(x,y) = \\nabla^2 \\chi(x,y), \\qquad \\zeta_{\\mathrm{true}}(x,y) = \\nabla^2 \\psi(x,y),$$\nwith the Laplacian in Cartesian coordinates given by $\\,\\nabla^2 = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2\\,$.\n\nImplement the following discrete operators on two grid layouts:\n- Arakawa A-grid (A-grid): wind components $\\,u\\,$ and $\\,v\\,$ are defined at cell centers located at $\\,x_i = (i+1/2)\\Delta x\\,$ and $\\,y_j = (j+1/2)\\Delta y\\,$ for $\\,i=0,\\dots,N_x-1\\,$ and $\\,j=0,\\dots,N_y-1\\,$. Use second-order centered differences with periodic boundary conditions to compute\n$$\\delta_A(i,j) = \\frac{u(i+1,j)-u(i-1,j)}{2\\Delta x} + \\frac{v(i,j+1)-v(i,j-1)}{2\\Delta y},$$\n$$\\zeta_A(i,j) = \\frac{v(i+1,j)-v(i-1,j)}{2\\Delta x} - \\frac{u(i,j+1)-u(i,j-1)}{2\\Delta y}.$$\n- Arakawa C-grid (C-grid): $\\,u\\,$ is defined at $\\,x$-faces located at $\\,x_i = i\\Delta x\\,$, $\\,y_j = (j+1/2)\\Delta y\\,$, and $\\,v\\,$ is defined at $\\,y$-faces located at $\\,x_i = (i+1/2)\\Delta x\\,$, $\\,y_j = j\\Delta y\\,$. Compute divergence at cell centers by finite-volume fluxes\n$$\\delta_C(i,j) = \\frac{u(i+1,j)-u(i,j)}{\\Delta x} + \\frac{v(i,j+1)-v(i,j)}{\\Delta y},$$\nwhere $\\,i,j\\,$ index cell centers at $\\,x_i = (i+1/2)\\Delta x\\,$, $\\,y_j = (j+1/2)\\Delta y\\,$. Compute vorticity at cell corners located at $\\,x_i = i\\Delta x\\,$, $\\,y_j = j\\Delta y\\,$ using\n$$\\zeta_C(i,j) = \\frac{v(i,j) - v(i-1,j)}{\\Delta x} - \\frac{u(i,j) - u(i,j-1)}{\\Delta y}.$$\nAll discrete differences must enforce periodic boundary conditions in both directions.\n\nFor each computed discrete field, quantify numerical accuracy by the root-mean-square error (RMSE) against the analytic field evaluated at the corresponding grid locations. For A-grid, compare $\\,\\delta_A\\,$ against $\\,\\delta_{\\mathrm{true}}\\,$ at cell centers and $\\,\\zeta_A\\,$ against $\\,\\zeta_{\\mathrm{true}}\\,$ at cell centers. For C-grid divergence, compare $\\,\\delta_C\\,$ at centers against $\\,\\delta_{\\mathrm{true}}\\,$ at centers. For C-grid vorticity, compare $\\,\\zeta_C\\,$ at corners against $\\,\\zeta_{\\mathrm{true}}\\,$ at corners.\n\nAdditionally, quantify spectral noise as follows. For each discrete field, compute its two-dimensional discrete Fourier transform and define the expected wavenumber pair for divergence as $\\,\\left(m_\\chi,n_\\chi\\right)\\,$ and for vorticity as $\\,\\left(m_\\psi,n_\\psi\\right)\\,$. Let the total spectral energy be the sum of squared magnitudes across all wavenumbers, and let the expected-mode energy be the sum of squared magnitudes at the four symmetric peaks $\\,\\left(\\pm m, \\pm n\\right)\\,$. Define the noise fraction as one minus the expected-mode energy divided by the total energy. Report the noise fraction for each operator-field pair.\n\nAnswer all RMSE values in $\\mathrm{s}^{-1}$, and all noise fractions as dimensionless floats. Angles are not involved. Your program should compute the quantities for the following test suite:\n\n- Test $1$ (smooth mixed flow): $\\,N_x=64\\,$, $\\,N_y=64\\,$, $\\,L_x=1.0\\,\\mathrm{m}\\,$, $\\,L_y=1.0\\,\\mathrm{m}\\,$, $\\,A_\\psi=1.0\\,$, $\\,A_\\chi=1.0\\,$, $\\,m_\\psi=2\\,$, $\\,n_\\psi=3\\,$, $\\,m_\\chi=3\\,$, $\\,n_\\chi=2\\,$, $\\,A_p=500.0\\,\\mathrm{Pa}\\,$, $\\,m_p=1\\,$, $\\,n_p=2\\,$.\n- Test $2$ (pure rotational): $\\,N_x=64\\,$, $\\,N_y=64\\,$, $\\,L_x=1.0\\,\\mathrm{m}\\,$, $\\,L_y=1.0\\,\\mathrm{m}\\,$, $\\,A_\\psi=1.0\\,$, $\\,A_\\chi=0.0\\,$, $\\,m_\\psi=4\\,$, $\\,n_\\psi=4\\,$, $\\,m_\\chi=3\\,$, $\\,n_\\chi=2\\,$, $\\,A_p=500.0\\,\\mathrm{Pa}\\,$, $\\,m_p=1\\,$, $\\,n_p=2\\,$.\n- Test $3$ (pure divergent): $\\,N_x=64\\,$, $\\,N_y=64\\,$, $\\,L_x=1.0\\,\\mathrm{m}\\,$, $\\,L_y=1.0\\,\\mathrm{m}\\,$, $\\,A_\\psi=0.0\\,$, $\\,A_\\chi=1.0\\,$, $\\,m_\\psi=2\\,$, $\\,n_\\psi=3\\,$, $\\,m_\\chi=6\\,$, $\\,n_\\chi=5\\,$, $\\,A_p=500.0\\,\\mathrm{Pa}\\,$, $\\,m_p=1\\,$, $\\,n_p=2\\,$.\n- Test $4$ (near-Nyquist): $\\,N_x=64\\,$, $\\,N_y=64\\,$, $\\,L_x=1.0\\,\\mathrm{m}\\,$, $\\,L_y=1.0\\,\\mathrm{m}\\,$, $\\,A_\\psi=1.0\\,$, $\\,A_\\chi=1.0\\,$, $\\,m_\\psi=31\\,$, $\\,n_\\psi=30\\,$, $\\,m_\\chi=31\\,$, $\\,n_\\chi=31\\,$, $\\,A_p=500.0\\,\\mathrm{Pa}\\,$, $\\,m_p=1\\,$, $\\,n_p=2\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes an inner list of eight floats in the following order:\n$[\\mathrm{RMSE\\_div\\_A},\\,\\mathrm{RMSE\\_div\\_C},\\,\\mathrm{RMSE\\_vort\\_A},\\,\\mathrm{RMSE\\_vort\\_C},\\,\\mathrm{noise\\_div\\_A},\\,\\mathrm{noise\\_div\\_C},\\,\\mathrm{noise\\_vort\\_A},\\,\\mathrm{noise\\_vort\\_C}]$.\nThus the final output has the form\n$$\\big[\\,[t1\\_8],\\,[t2\\_8],\\,[t3\\_8],\\,[t4\\_8]\\,\\big],$$\nwhere each $[t\\ell\\_8]$ is the list of eight floats for test $\\ell$ in the specified order.",
            "solution": "The user wants me to solve a numerical methods problem related to atmospheric modeling.\n\nHere's the plan:\n1.  **Validate the Problem**:\n    *   Extract all given parameters and definitions.\n    *   Check for scientific soundness, consistency, and well-posedness.\n    *   The problem involves standard concepts from fluid dynamics and numerical methods (Arakawa grids, finite differences, Fourier analysis). It seems scientifically grounded.\n    *   The problem provides all necessary equations, parameters, and definitions to compute the required quantities. It appears well-posed and complete.\n    *   The language is objective and precise.\n    *   The task is to compare numerical schemes against analytical solutions, which is a standard verification technique in computational science.\n    *   I'll need to be careful with the grid definitions (A-grid vs C-grid) and where each variable is evaluated.\n    *   The pressure field `p(x,y)` is explicitly stated as not being used directly, so it's just context. This is fine.\n    *   The definitions for RMSE and spectral noise fraction are clear.\n\n2.  **Deconstruct the Solution Steps**:\n    *   **Analytical Fields**: First, I need functions to compute the analytical fields: $\\psi(x,y)$, $\\chi(x,y)$, $u(x,y)$, $v(x,y)$, $\\delta_{\\mathrm{true}}(x,y)$, and $\\zeta_{\\mathrm{true}}(x,y)$.\n        *   The derivatives are straightforward:\n            *   $u(x,y) = \\frac{\\partial \\chi}{\\partial x} - \\frac{\\partial \\psi}{\\partial y}$\n            *   $v(x,y) = \\frac{\\partial \\chi}{\\partial y} + \\frac{\\partial \\psi}{\\partial x}$\n            *   $\\delta_{\\mathrm{true}}(x,y) = \\nabla^2 \\chi(x,y) = \\frac{\\partial^2 \\chi}{\\partial x^2} + \\frac{\\partial^2 \\chi}{\\partial y^2}$\n            *   $\\zeta_{\\mathrm{true}}(x,y) = \\nabla^2 \\psi(x,y) = \\frac{\\partial^2 \\psi}{\\partial x^2} + \\frac{\\partial^2 \\psi}{\\partial y^2}$\n        *   Let's write these out explicitly.\n            *   $\\psi = A_\\psi \\cos(k_{\\psi x} x) \\cos(k_{\\psi y} y)$ where $k_{\\psi x} = 2\\pi m_\\psi/L_x$ and $k_{\\psi y} = 2\\pi n_\\psi/L_y$.\n            *   $\\frac{\\partial \\psi}{\\partial x} = -A_\\psi k_{\\psi x} \\sin(k_{\\psi x} x) \\cos(k_{\\psi y} y)$\n            *   $\\frac{\\partial \\psi}{\\partial y} = -A_\\psi k_{\\psi y} \\cos(k_{\\psi x} x) \\sin(k_{\\psi y} y)$\n            *   $\\frac{\\partial^2 \\psi}{\\partial x^2} = -A_\\psi k_{\\psi x}^2 \\cos(k_{\\psi x} x) \\cos(k_{\\psi y} y) = -k_{\\psi x}^2 \\psi$\n            *   $\\frac{\\partial^2 \\psi}{\\partial y^2} = -A_\\psi k_{\\psi y}^2 \\cos(k_{\\psi x} x) \\cos(k_{\\psi y} y) = -k_{\\psi y}^2 \\psi$\n            *   $\\zeta_{\\mathrm{true}} = \\nabla^2 \\psi = -(k_{\\psi x}^2 + k_{\\psi y}^2) \\psi = - \\left( \\left(\\frac{2\\pi m_\\psi}{L_x}\\right)^2 + \\left(\\frac{2\\pi n_\\psi}{L_y}\\right)^2 \\right) A_\\psi \\cos(k_{\\psi x} x) \\cos(k_{\\psi y} y)$\n\n            *   $\\chi = A_\\chi \\sin(k_{\\chi x} x) \\sin(k_{\\chi y} y)$ where $k_{\\chi x} = 2\\pi m_\\chi/L_x$ and $k_{\\chi y} = 2\\pi n_\\chi/L_y$.\n            *   $\\frac{\\partial \\chi}{\\partial x} = A_\\chi k_{\\chi x} \\cos(k_{\\chi x} x) \\sin(k_{\\chi y} y)$\n            *   $\\frac{\\partial \\chi}{\\partial y} = A_\\chi k_{\\chi y} \\sin(k_{\\chi x} x) \\cos(k_{\\chi y} y)$\n            *   $\\frac{\\partial^2 \\chi}{\\partial x^2} = -A_\\chi k_{\\chi x}^2 \\sin(k_{\\chi x} x) \\sin(k_{\\chi y} y) = -k_{\\chi x}^2 \\chi$\n            *   $\\frac{\\partial^2 \\chi}{\\partial y^2} = -A_ \\chi k_{\\chi y}^2 \\sin(k_{\\chi x} x) \\sin(k_{\\chi y} y) = -k_{\\chi y}^2 \\chi$\n            *   $\\delta_{\\mathrm{true}} = \\nabla^2 \\chi = -(k_{\\chi x}^2 + k_{\\chi y}^2) \\chi = - \\left( \\left(\\frac{2\\pi m_\\chi}{L_x}\\right)^2 + \\left(\\frac{2\\pi n_\\chi}{L_y}\\right)^2 \\right) A_\\chi \\sin(k_{\\chi x} x) \\sin(k_{\\chi y} y)$\n\n        *   So, I can create functions for $u(x,y)$ and $v(x,y)$:\n            *   $u(x,y) = A_\\chi k_{\\chi x} \\cos(k_{\\chi x} x) \\sin(k_{\\chi y} y) + A_\\psi k_{\\psi y} \\cos(k_{\\psi x} x) \\sin(k_{\\psi y} y)$\n            *   $v(x,y) = A_chi k_{\\chi y} \\sin(k_{\\chi x} x) \\cos(k_{\\chi y} y) - A_\\psi k_{\\psi x} \\sin(k_{\\psi x} x) \\cos(k_{\\psi y} y)$\n\n    *   **Grid Generation**:\n        *   Arakawa A-grid centers:\n            *   $x_i = (i+1/2)\\Delta x$ for $i=0,...,N_x-1$\n            *   $y_j = (j+1/2)\\Delta y$ for $j=0,...,N_y-1$\n        *   Arakawa C-grid u-points (x-faces):\n            *   $x_i = i\\Delta x$ for $i=0,...,N_x-1$\n            *   $y_j = (j+1/2)\\Delta y$ for $j=0,...,N_y-1$\n        *   Arakawa C-grid v-points (y-faces):\n            *   $x_i = (i+1/2)\\Delta x$ for $i=0,...,N_x-1$\n            *   $y_j = j\\Delta y$ for $j=0,...,N_y-1$\n        *   Arakawa C-grid corners:\n            *   $x_i = i\\Delta x$ for $i=0,...,N_x-1$\n            *   $y_j = j\\Delta y$ for $j=0,...,N_y-1$\n\n    *   **Discrete Field Computation**:\n        *   **A-Grid**:\n            1.  Evaluate $u$ and $v$ at the A-grid cell centers.\n            2.  Compute $\\delta_A$ and $\\zeta_A$ using the provided finite difference formulas. These are second-order centered differences.\n            3.  Handle periodic boundaries: e.g., for $u(i-1, j)$ when $i=0$, we need $u(N_x-1, j)$. This can be handled with `np.roll`.\n                *   $\\delta_A(i,j) = \\frac{u(i+1,j)-u(i-1,j)}{2\\Delta x} + \\frac{v(i,j+1)-v(i,j-1)}{2\\Delta y}$\n                *   $\\zeta_A(i,j) = \\frac{v(i+1,j)-v(i-1,j)}{2\\Delta x} - \\frac{u(i,j+1)-u(i,j-1)}{2\\Delta y}$\n                *   Using `np.roll`:\n                    *   `u_ip1 = np.roll(u, -1, axis=0)`\n                    *   `u_im1 = np.roll(u, 1, axis=0)`\n                    *   `v_jp1 = np.roll(v, -1, axis=1)`\n                    *   `v_jm1 = np.roll(v, 1, axis=1)`\n                    *   Note: The problem uses `i` for x-index and `j` for y-index. `numpy` arrays are indexed `(row, col)`, so `(j,i)`. I need to be consistent. Let's use `(i,j)` for `(x,y)` indices, which maps to `(j,i)` in numpy arrays. Slices like `u[i+1, j]` will map to `u_array[j, i+1]`. `np.roll` with `axis=1` will handle the `i` index (x-direction), and `axis=0` will handle the `j` index (y-direction).\n\n        *   **C-Grid**:\n            1.  Evaluate $u$ at the C-grid u-points.\n            2.  Evaluate $v$ at the C-grid v-points.\n            3.  Compute $\\delta_C$ at cell centers.\n                *   $\\delta_C(i,j) = \\frac{u(i+1,j)-u(i,j)}{\\Delta x} + \\frac{v(i,j+1)-v(i,j)}{\\Delta y}$\n                *   Here, $u(i,j)$ refers to the $u$ value on the x-face at index $i$ and y-index $j$. The grid for $u$ has dimensions $N_x \\times N_y$. Let's call it `u_cgrid`.\n                *   $u(i,j)$ is at `x_i=i*dx, y_j=(j+0.5)*dy`.\n                *   $u(i+1,j)$ is at `x_{i+1}=(i+1)*dx, y_j=(j+0.5)*dy`.\n                *   $v(i,j)$ is at `x_i=(i+0.5)*dx, y_j=j*dy`.\n                *   $v(i,j+1)$ is at `x_i=(i+0.5)*dx, y_{j+1}=(j+1)*dy`.\n                *   The divergence $\\delta_C$ is calculated at cell centers. An index `(i,j)` for a center corresponds to the $u$-variable at `(i,j)` and `(i+1,j)`, and the $v$-variable at `(i,j)` and `(i,j+1)`. This seems to have an off-by-one indexing issue depending on conventions. Let's trace it carefully.\n                *   $\\delta_C$ at center `((i+0.5)dx, (j+0.5)dy)`. `u` is needed at `(i*dx, (j+0.5)dy)` and `((i+1)*dx, (j+0.5)dy)`. This corresponds to `u_cgrid(i,j)` and `u_cgrid(i+1,j)` if `u_cgrid` is indexed by `(face_x_index, center_y_index)`.\n                *   With periodicity, `u_cgrid(Nx, j)` is `u_cgrid(0, j)`.\n                *   Similarly, `v` is needed at `((i+0.5)dx, j*dy)` and `((i+0.5)dx, (j+1)dy)`. This corresponds to `v_cgrid(i,j)` and `v_cgrid(i,j+1)`.\n                *   Using `np.roll` for `d_u/dx`: `(np.roll(u_cgrid, -1, axis=1) - u_cgrid) / dx`. `axis=1` for x-direction.\n                *   Using `np.roll` for `d_v/dy`: `(np.roll(v_cgrid, -1, axis=0) - v_cgrid) / dy`. `axis=0` for y-direction.\n\n            4.  Compute $\\zeta_C$ at cell corners.\n                *   $\\zeta_C(i,j) = \\frac{v(i,j) - v(i-1,j)}{\\Delta x} - \\frac{u(i,j) - u(i,j-1)}{\\Delta y}$.\n                *   Here, `(i,j)` refers to corner indices `(i*dx, j*dy)`.\n                *   $v(i,j)$ vs $v(i-1,j)$: We need v-values at `((i+0.5)dx, j*dy)` and `((i-1+0.5)dx, j*dy)`. In my `v_cgrid(i,j)` defined at `x_i=(i+0.5)dx, y_j=j*dy`, this is `v_cgrid(i,j) - v_cgrid(i-1, j)`.\n                *   $u(i,j)$ vs $u(i,j-1)$: We need u-values at `(i*dx, (j+0.5)dy)` and `(i*dx, (j-1+0.5)dy)`. In my `u_cgrid(i,j)` defined at `x_i=i*dx, y_j=(j+0.5)dy`, this is `u_cgrid(i,j) - u_cgrid(i, j-1)`.\n                *   The resulting $\\zeta_C$ will be at corners `(i*dx, j*dy)`.\n                *   Using `np.roll` for `dv/dx`: `(v_cgrid - np.roll(v_cgrid, 1, axis=1)) / dx`.\n                *   Using `np.roll` for `du/dy`: `(u_cgrid - np.roll(u_cgrid, 1, axis=0)) / dy`.\n\n    *   **Error Calculation (RMSE)**:\n        *   RMSE formula: $\\sqrt{\\frac{1}{N} \\sum (\\text{discrete} - \\text{analytic})^2}$.\n        *   $\\mathrm{RMSE\\_div\\_A}$: Compare $\\delta_A$ (at A-grid centers) with $\\delta_{\\mathrm{true}}$ (evaluated at A-grid centers).\n        *   $\\mathrm{RMSE\\_div\\_C}$: Compare $\\delta_C$ (at C-grid centers, which are the same as A-grid centers) with $\\delta_{\\mathrm{true}}$ (evaluated at C-grid centers).\n        *   $\\mathrm{RMSE\\_vort\\_A}$: Compare $\\zeta_A$ (at A-grid centers) with $\\zeta_{\\mathrm{true}}$ (evaluated at A-grid centers).\n        *   $\\mathrm{RMSE\\_vort\\_C}$: Compare $\\zeta_C$ (at C-grid corners) with $\\zeta_{\\mathrm{true}}$ (evaluated at C-grid corners).\n\n    *   **Spectral Noise Calculation**:\n        *   Noise Fraction = $1 - (\\text{Expected Energy} / \\text{Total Energy})$.\n        *   For a given discrete field (e.g., $\\delta_A$):\n            1.  Compute its 2D discrete Fourier transform (DFT). `np.fft.fft2` is the tool.\n            2.  Total Energy = $\\sum_{k,l} |\\hat{F}(k,l)|^2$, where $\\hat{F}$ is the DFT. This is related to Parseval's theorem. Sum of squares in physical space is proportional to sum of squares in spectral space. `np.sum(np.abs(F_hat)**2)`.\n            3.  Expected wavenumbers: For divergence, it's $(m_\\chi, n_\\chi)$. For vorticity, it's $(m_\\psi, n_\\psi)$.\n            4.  Find the energy at these modes. The DFT gives complex coefficients for modes $e^{2\\pi i (kx/L_x + ly/L_y)}$. The cosine/sine functions will correspond to peaks at specific wavenumbers.\n                *   A function like $\\cos(2\\pi m x / L_x)$ corresponds to two delta functions in the continuous Fourier transform at wavenumbers $\\pm m$. In DFT, this power is split between the positive wavenumbers $(m,n)$ and their symmetric counterparts.\n                *   The DFT indices `(k, l)` correspond to wavenumbers $(k, l)$ for `k, l` in range. `numpy.fft.fftfreq` helps map indices to frequencies. The wavenumbers are $m$ and $n$. The DFT will have peaks at indices corresponding to wavenumbers $\\pm m$ and $\\pm n$.\n                *   So the Expected Energy is the sum of squared magnitudes at the four symmetric wavenumber pairs: $(\\pm m, \\pm n)$. These are $|\\hat{F}(m, n)|^2 + |\\hat{F}(-m, n)|^2 + |\\hat{F}(m, -n)|^2 + |\\hat{F}(-m, -n)|^2$.\n                *   Need to handle the mapping from wavenumbers $(m, n)$ to DFT array indices. For an array of size $N$, DFT indices $k$ from $0$ to $N-1$ correspond to frequencies. `np.fft.fftfreq(N)` gives frequencies $[0, 1/N, 2/N, ..., (N/2)/N, -(N/2-1)/N, ..., -1/N]$. We need to multiply by $N$ to get wavenumbers. Wait, `fftfreq(n, d=1.0)` gives frequencies in cycles per unit of sample spacing. Frequencies are $f_k=k/N$. We need to map our wavenumbers $m_\\chi, n_\\chi$ to these indices.\n                *   The wavenumber convention is $2\\pi m/L_x$. The DFT basis functions are $e^{2\\pi i (k x_i/L_x)}$. So mode `m` in the problem corresponds directly to DFT index `k=m`.\n                *   So, if we have $N_x$ points, the DFT indices are $0, 1, ..., N_x-1$. Wavenumber $m$ corresponds to index $k=m$. Wavenumber $-m$ corresponds to index $k=N_x-m$.\n                *   So, the four symmetric peaks for wavenumbers $(m, n)$ are at indices $(m, n)$, $(N_x-m, n)$, $(m, N_y-n)$, and $(N_x-m, N_y-n)$.\n            5.  `expected_energy = np.abs(F_hat[n, m])**2 + np.abs(F_hat[n, Nx-m])**2 + np.abs(F_hat[Ny-n, m])**2 + np.abs(F_hat[Ny-n, Nx-m])**2`\n            *   My `field` array is indexed `(j, i)` for `(y, x)`, so `F_hat` is indexed `(l, k)` for `(y_wavenum, x_wavenum)`. So $k$ maps to $m$, and $l$ maps to $n$.\n            *   `expected_energy = np.abs(F_hat[n, m])**2 + np.abs(F_hat[Ny-n, m])**2 + np.abs(F_hat[n, Nx-m])**2 + np.abs(F_hat[Ny-n, Nx-m])**2`.\n            *   This is not entirely correct. `cos(ax)cos(by)` will have 4 peaks. `sin(ax)sin(by)` will also have 4 peaks.\n                *   $\\cos(ax) = (e^{iax}+e^{-iax})/2$\n                *   $\\cos(by) = (e^{iby}+e^{-iby})/2$\n                *   $\\cos(ax)\\cos(by) = (e^{i(ax+by)} + e^{i(ax-by)} + e^{i(-ax+by)} + e^{i(-ax-by)})/4$\n                *   So four peaks at $(\\pm a, \\pm b)$ wavenumbers, which map to the four indices.\n            *   What about the case where $m=0$ or $n=0$? Not relevant here.\n            *   What if $m=N_x/2$? Then $m = N_x-m$. The two x-wavenumbers merge. Let's look at Test 4 again. $N_x=64, m=31$. $N_y=64, n=30, 31$. No component is exactly at Nyquist frequency (32). So `m != Nx-m` and `n != Ny-n`. The four indices are distinct.\n            *   Final check on `expected_energy`: A pure sine/cosine wave on a grid `f[j] = cos(2*pi*m*j/N)` has a DFT `(N/2) * (delta_{k,m} + delta_{k,N-m})`. So the square magnitude is `(N/2)^2`. A 2D field `cos(2*pi*m_x*i/Nx) * cos(2*pi*m_y*j/Ny)` will have four peaks. The magnitude at each peak will be `(Nx*Ny/4)`. Squared magnitude is `(Nx*Ny/4)^2`.\n            *   If `total_energy = np.sum(np.abs(F_hat)**2)`, then by Parseval's theorem, this is `Nx*Ny * np.sum(field**2)`.\n            *   Let's check the definition of `expected-mode energy` in the problem: \"the sum of squared magnitudes at the four symmetric peaks\". This is exactly what I wrote. It does not say 'all energy is in these modes'. It asks to sum the energy found at these spectral locations. So my formula for `expected_energy` is correct according to the prompt.\n            *   `noise_fraction = 1.0 - expected_energy / total_energy` if `total_energy > 0`, else `0`. `total_energy` will be zero only if the field is identically zero. This can happen in Test 2 for divergence and Test 3 for vorticity. In these cases, the noise fraction should be 0, as there's no signal and no noise. My formula gives `1 - 0/0`, which is a problem. Let's see: if `A_chi=0` and `A_psi=0` then `u=v=0`, and the discrete operators give exactly zero. `delta=0, zeta=0`. Then `total_energy` is zero.\n                *   Test 2: `A_chi=0`. So `delta_true=0`. `u = d_psi/dy`, `v = d_psi/dx`. The formulas for `delta_A` and `delta_C` should be checked.\n                    *   $\\delta_A = \\frac{\\partial^2}{\\partial x \\partial y}\\psi - \\frac{\\partial^2}{\\partial y \\partial x}\\psi + ... \\text{errors}$. Should be close to 0.\n                    *   $\\delta_C = ...$ same.\n                    *   So for divergence in Test 2, the true field is 0. The numerically computed fields `delta_A, delta_C` should also be nearly zero. `total_energy` will be very small. What are the expected wavenumbers? `m_chi=3, n_chi=2`. We are looking for energy at wavenumbers that don't exist in the signal. `expected_energy` should be zero or very small. `noise_fraction = 1 - small_1/small_2`. This can be anything. But `expected_energy` will be part of the total noise energy, so the ratio should be small. A value near 1 would mean most energy is NOT at the expected (but absent) peaks. This seems conceptually correct. If the signal is supposed to be zero, any non-zero energy is noise. My formula is looking for energy at certain wavenumbers. If the field is zero, then `total_energy=0, expected_energy=0`, `noise_fraction` is ill-defined.\n                *   Let's reread the prompt: \"define the expected wavenumber pair for divergence as $(m_\\chi, n_\\chi)$ and for vorticity as $(m_\\psi, n_\\psi)$\". This is a fixed definition regardless of the amplitudes $A_\\chi, A_\\psi$.\n                *   If `A_chi=0`, `delta_true` is 0. `delta_A` and `delta_C` will be calculated from a non-zero wind field. Due to discretization errors, they will not be identically zero. So `total_energy` will be non-zero (it's the total energy of the numerical error). `expected_energy` will be the portion of that error energy that happens to fall on the `(m_chi, n_chi)` modes. The noise fraction `1 - E_exp/E_tot` will be close to 1, which means that the error energy is spread across the spectrum and not concentrated at the (non-existent) signal's wavenumbers. This seems logical.\n                *   Let's consider the opposite: Test 3, `A_psi=0`. `zeta_true=0`. The computed `zeta_A` and `zeta_C` will be non-zero due to discretization errors. `total_energy` non-zero. The expected wavenumbers are `(m_psi, n_psi)`. We look for energy at these modes. Again, noise fraction should be close to 1.\n                *   Let's consider the edge case `total_energy == 0`. This will only happen if the calculated discrete field is identically zero.\n                    *   Test 2 (`A_chi=0`): `u=-dpsi/dy`, `v=dpsi/dx`. `delta_C = d/dx(-dpsi/dy) + d/dy(dpsi/dx)`. The discrete operators might not commute perfectly. Let's see: `delta_C(i, j) = (u(i+1,j)-u(i,j))/dx + (v(i,j+1)-v(i,j))/dy`. The `u` and `v` are evaluated at different locations. This calculation is not trivially zero. So `delta_C` will be non-zero. `total_energy` will be non-zero.\n                    *   Test 3 (`A_psi=0`): `u=dchi/dx`, `v=dchi/dy`. `zeta_A = d/dx(dchi/dy) - d/dy(dchi/dx)`. Again, due to discretization, this is not identically zero. `total_energy` will be non-zero.\n                *   So the case `total_energy=0` is unlikely to happen unless both `A_psi` and `A_chi` are zero, which is not a test case. I will add a check for `total_energy` being close to zero, and in that case, the noise fraction is 0. If there's no energy, there's no noise.\n\nLet's double-check the Arakawa C-grid vorticity definition.\n$\\zeta_C(i,j) = \\frac{v(i,j) - v(i-1,j)}{\\Delta x} - \\frac{u(i,j) - u(i,j-1)}{\\Delta y}.$\nThis is computed at corners, with index `(i,j)` for `x=i*dx, y=j*dy`.\n- The `dv/dx` term: `v(i,j)` is at `x=(i+0.5)dx, y=j*dy`. `v(i-1,j)` is at `x=(i-1+0.5)dx, y=j*dy`. These are two adjacent v-points in x. Correct. This approximates `dv/dx` at `x=i*dx, y=j*dy`.\n- The `du/dy` term: `u(i,j)` is at `x=i*dx, y=(j+0.5)dy`. `u(i,j-1)` is at `x=i*dx, y=(j-1+0.5)dy`. These are two adjacent u-points in y. Correct. This approximates `du/dy` at `x=i*dx, y=j*dy`.\nThe formula is consistent with standard C-grid definitions. Its location is at corners. My plan to evaluate `zeta_true` at `xx_cor, yy_cor` for comparison is correct.\n\nLet's double-check the Arakawa C-grid divergence definition.\n$\\delta_C(i,j) = \\frac{u(i+1,j)-u(i,j)}{\\Delta x} + \\frac{v(i,j+1)-v(i,j)}{\\Delta y}.$\nThis is computed at cell centers, `(i+0.5)dx, (j+0.5)dy`.\n- `du/dx` term: `u(i+1,j)` is at `x=(i+1)dx, y=(j+0.5)dy`. `u(i,j)` is at `x=i*dx, y=(j+0.5)dy`. These are two adjacent u-points bracketing the a cell center in x. Correct.\n- `dv/dy` term: `v(i,j+1)` is at `x=(i+0.5)dx, y=(j+1)dy`. `v(i,j)` is at `x=(i+0.5)dx, y=j*dy`. These are two adjacent v-points bracketing a cell center in y. Correct.\nThe formula is consistent. My plan to evaluate `delta_true` at `xx_cen, yy_cen` for comparison is correct.\n\nThe `scipy` library is listed as available, but `numpy` should be sufficient for everything here (array math, FFT). I will stick to `numpy`.\n\nThe problem seems valid. It is a standard numerical methods verification problem, well-posed, and scientifically grounded in computational fluid dynamics. All required information is provided. I will now write the solution.\n### Step 1: Extract Givens\nDomain: Doubly periodic, rectangular, size $L_x \\times L_y$.\nGrid: Uniform with spacing $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$.\nStreamfunction: $\\psi(x,y) = A_\\psi \\cos\\left(\\frac{2\\pi m_\\psi x}{L_x}\\right)\\cos\\left(\\frac{2\\pi n_\\psi y}{L_y}\\right)$.\nVelocity Potential: $\\chi(x,y) = A_\\chi \\sin\\left(\\frac{2\\pi m_\\chi x}{L_x}\\right)\\sin\\left(\\frac{2\\pi n_\\chi y}{L_y}\\right)$.\nWind Components (Helmholtz Decomposition): $u(x,y) = \\frac{\\partial \\chi}{\\partial x} - \\frac{\\partial \\psi}{\\partial y}$, $v(x,y) = \\frac{\\partial \\chi}{\\partial y} + \\frac{\\partial \\psi}{\\partial x}$.\nPressure (not used): $p(x,y) = A_p \\cos\\left(\\frac{2\\pi m_p x}{L_x}\\right)\\cos\\left(\\frac{2\\pi n_p y}{L_y}\\right)$.\nTarget Fields:\n- Divergence: $\\delta(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = \\nabla^2 \\chi(x,y)$.\n- Vorticity: $\\zeta(x,y) = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y} = \\nabla^2 \\psi(x,y)$.\n\nArakawa A-grid:\n- Variables $u, v$ at cell centers: $x_i = (i+1/2)\\Delta x$, $y_j = (j+1/2)\\Delta y$.\n- Operators:\n  $\\delta_A(i,j) = \\frac{u(i+1,j)-u(i-1,j)}{2\\Delta x} + \\frac{v(i,j+1)-v(i,j-1)}{2\\Delta y}$.\n  $\\zeta_A(i,j) = \\frac{v(i+1,j)-v(i-1,j)}{2\\Delta x} - \\frac{u(i,j+1)-u(i,j-1)}{2\\Delta y}$.\n\nArakawa C-grid:\n- Variable $u$ at x-faces: $x_i = i\\Delta x$, $y_j = (j+1/2)\\Delta y$.\n- Variable $v$ at y-faces: $x_i = (i+1/2)\\Delta x$, $y_j = j\\Delta y$.\n- Operators:\n  - Divergence at cell centers: $\\delta_C(i,j) = \\frac{u(i+1,j)-u(i,j)}{\\Delta x} + \\frac{v(i,j+1)-v(i,j)}{\\Delta y}$.\n  - Vorticity at cell corners: $\\zeta_C(i,j) = \\frac{v(i,j) - v(i-1,j)}{\\Delta x} - \\frac{u(i,j) - u(i,j-1)}{\\Delta y}$.\n\nMetrics:\n- RMSE: against analytic fields evaluated at corresponding grid locations.\n- Noise Fraction: $1 - E_{\\text{expected}} / E_{\\text{total}}$.\n  - $E_{\\text{total}}$ is sum of squared magnitudes of 2D DFT coefficients.\n  - $E_{\\text{expected}}$ is sum of squared magnitudes at four symmetric peaks $(\\pm m, \\pm n)$ where $(m,n)$ are $(m_\\chi, n_\\chi)$ for divergence and $(m_\\psi, n_\\psi)$ for vorticity.\n\nTest Cases:\n1. Smooth mixed flow: $N_x=64$, $N_y=64$, $L_x=1.0$, $L_y=1.0$, $A_\\psi=1.0$, $A_\\chi=1.0$, $m_\\psi=2$, $n_\\psi=3$, $m_\\chi=3$, $n_\\chi=2$.\n2. Pure rotational: $N_x=64$, $N_y=64$, $L_x=1.0$, $L_y=1.0$, $A_\\psi=1.0$, $A_\\chi=0.0$, $m_\\psi=4$, $n_\\psi=4$, $m_\\chi=3$, $n_\\chi=2$.\n3. Pure divergent: $N_x=64$, $N_y=64$, $L_x=1.0$, $L_y=1.0$, $A_\\psi=0.0$, $A_\\chi=1.0$, $m_\\psi=2$, $n_\\psi=3$, $m_\\chi=6$, $n_\\chi=5$.\n4. Near-Nyquist: $N_x=64$, $N_y=64$, $L_x=1.0$, $L_y=1.0$, $A_\\psi=1.0$, $A_\\chi=1.0$, $m_\\psi=31$, $n_\\psi=30$, $m_\\chi=31$, $n_\\chi=31$.\n\n(Shared parameters for all tests: $A_p=500.0, m_p=1, n_p=2$)\n\nOutput Format: A single line string representing a list of lists of 8 floats per test case: $[\\mathrm{RMSE\\_div\\_A},\\,\\mathrm{RMSE\\_div\\_C},\\,\\mathrm{RMSE\\_vort\\_A},\\,\\mathrm{RMSE\\_vort\\_C},\\,\\mathrm{noise\\_div\\_A},\\,\\mathrm{noise\\_div\\_C},\\,\\mathrm{noise\\_vort\\_A},\\,\\mathrm{noise\\_vort\\_C}]$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective.\n- **Scientific Grounding**: The problem uses standard definitions from geophysical fluid dynamics (streamfunction, velocity potential, Helmholtz decomposition, divergence, vorticity) and numerical analysis (Arakawa grids, finite differences, Fourier analysis). These are fundamental concepts in atmospheric modeling.\n- **Well-Posedness**: The problem is a standard verification exercise. All necessary parameters, equations, and definitions for grid structures, discrete operators, and evaluation metrics are provided. The inputs are clearly defined, and the required outputs are unambiguously specified, leading to a unique and meaningful solution.\n- **Objectivity**: The problem is stated in precise mathematical and computational terms, free of any subjective or ambiguous language.\n\nThe problem does not violate any of the invalidity criteria. It is a complete, consistent, and solvable problem in computational science.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Design\nThe solution involves comparing numerically computed diagnostic fields (divergence and vorticity) against their analytical counterparts. The process is broken down into several stages: analytical formulation, grid-based discretization, numerical computation, and error/noise analysis.\n\n**1. Analytical Formulation**\nFirst, we establish the ground truth. The wind components $u$ and $v$ are derived from the streamfunction $\\psi$ and velocity potential $\\chi$ via the Helmholtz relations:\n$$u(x,y) = \\frac{\\partial \\chi}{\\partial x} - \\frac{\\partial \\psi}{\\partial y} \\qquad v(x,y) = \\frac{\\partial \\chi}{\\partial y} + \\frac{\\partial \\psi}{\\partial x}$$\nLet $k_x = \\frac{2\\pi m}{L_x}$ and $k_y = \\frac{2\\pi n}{L_y}$. Differentiating the given forms of $\\psi$ and $\\chi$ yields:\n$$u(x,y) = A_\\chi k_{\\chi x} \\cos(k_{\\chi x} x)\\sin(k_{\\chi y} y) + A_\\psi k_{\\psi y} \\cos(k_{\\psi x} x)\\sin(k_{\\psi y} y)$$\n$$v(x,y) = A_\\chi k_{\\chi y} \\sin(k_{\\chi x} x)\\cos(k_{\\chi y} y) - A_\\psi k_{\\psi x} \\sin(k_{\\psi x} x)\\cos(k_{\\psi y} y)$$\n\nThe analytical divergence $\\delta_{\\mathrm{true}}$ and vorticity $\\zeta_{\\mathrm{true}}$ are the Laplacians of $\\chi$ and $\\psi$, respectively:\n$$\\delta_{\\mathrm{true}}(x,y) = \\nabla^2\\chi = -(k_{\\chi x}^2 + k_{\\chi y}^2) A_\\chi \\sin(k_{\\chi x} x)\\sin(k_{\\chi y} y)$$\n$$\\zeta_{\\mathrm{true}}(x,y) = \\nabla^2\\psi = -(k_{\\psi x}^2 + k_{\\psi y}^2) A_\\psi \\cos(k_{\\psi x} x)\\cos(k_{\\psi y} y)$$\nThese analytical solutions serve as the reference for calculating the accuracy of the numerical schemes.\n\n**2. Grid Discretization and Numerical Operators**\nWe implement two common staggered grid arrangements, the Arakawa A-grid and C-grid.\n- On the **A-grid**, all variables ($u, v$) are collocated at cell centers. We compute divergence and vorticity using second-order centered finite differences. For a field $f(i,j)$ on the grid, periodic boundary conditions are handled by using neighboring points with modular arithmetic on indices, which is efficiently implemented using `numpy.roll`.\n- On the **C-grid**, variables are staggered. The zonal wind $u$ is on vertical cell faces (x-faces), and the meridional wind $v$ is on horizontal cell faces (y-faces). This arrangement is designed to have favorable numerical properties. Divergence is naturally computed at cell centers by differencing fluxes across cell boundaries. Vorticity is naturally computed at cell corners by circulating around the grid cell. Again, periodicity is enforced using index wrapping.\n\n**3. Evaluation Metrics**\nTwo metrics are used to evaluate the performance of the numerical operators.\n\n- **Root-Mean-Square Error (RMSE)**: This quantifies the average magnitude of the error between the numerically computed field and the analytical solution. It is calculated as $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum (\\text{discrete} - \\text{analytic})^2}$, where the sum is over all $N$ grid points where the discrete field is defined. The analytical solution is evaluated at the corresponding grid points for a consistent comparison.\n\n- **Spectral Noise Fraction**: This metric assesses how well the numerical scheme preserves the spectral characteristics of the analytical solution. The analytical solutions are monochromatic (single wavenumber pair). Discretization error can introduce energy at other wavenumbers, which is considered numerical noise. The procedure is:\n    1. Compute the two-dimensional discrete Fourier transform (2D-DFT) of the numerical field.\n    2. Calculate the total spectral energy, $E_{\\text{total}}$, as the sum of the squared magnitudes of all DFT coefficients.\n    3. Identify the expected spectral energy, $E_{\\text{expected}}$, as the sum of squared magnitudes at the four DFT indices corresponding to the analytical wave's symmetric wavenumbers: $(\\pm m, \\pm n)$. For a grid of size $N_x \\times N_y$, these map to DFT indices $(m, n)$, $(N_x-m, n)$, $(m, N_y-n)$, and $(N_x-m, N_y-n)$.\n    4. The noise fraction is then defined as $1 - (E_{\\text{expected}} / E_{\\text{total}})$. A value near $0$ indicates low noise and preservation of the spectral structure, while a value near $1$ indicates high noise. If the total energy is zero (for a null field), the noise fraction is taken to be $0$.\n\nThe implementation will systematically apply these principles to each test case, generating the specified eight diagnostic values for each.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test 1 (smooth mixed flow)\n        dict(Nx=64, Ny=64, Lx=1.0, Ly=1.0, A_psi=1.0, A_chi=1.0, m_psi=2, n_psi=3, m_chi=3, n_chi=2),\n        # Test 2 (pure rotational)\n        dict(Nx=64, Ny=64, Lx=1.0, Ly=1.0, A_psi=1.0, A_chi=0.0, m_psi=4, n_psi=4, m_chi=3, n_chi=2),\n        # Test 3 (pure divergent)\n        dict(Nx=64, Ny=64, Lx=1.0, Ly=1.0, A_psi=0.0, A_chi=1.0, m_psi=2, n_psi=3, m_chi=6, n_chi=5),\n        # Test 4 (near-Nyquist)\n        dict(Nx=64, Ny=64, Lx=1.0, Ly=1.0, A_psi=1.0, A_chi=1.0, m_psi=31, n_psi=30, m_chi=31, n_chi=31),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_list = calculate_diagnostics(**params)\n        all_results.append(result_list)\n\n    # Format the final output string\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_diagnostics(Nx, Ny, Lx, Ly, A_psi, A_chi, m_psi, n_psi, m_chi, n_chi):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    # 1. Define grid parameters and wavenumbers\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    k_psi_x = 2.0 * np.pi * m_psi / Lx\n    k_psi_y = 2.0 * np.pi * n_psi / Ly\n    k_chi_x = 2.0 * np.pi * m_chi / Lx\n    k_chi_y = 2.0 * np.pi * n_chi / Ly\n\n    # 2. Define grid coordinates\n    i_nx = np.arange(Nx)\n    j_ny = np.arange(Ny)\n\n    # A-grid centers / C-grid centers\n    x_cen = (i_nx + 0.5) * dx\n    y_cen = (j_ny + 0.5) * dy\n    xx_cen, yy_cen = np.meshgrid(x_cen, y_cen) # (Ny, Nx) indexing\n\n    # C-grid u-points (x-faces)\n    x_u = i_nx * dx\n    y_u = (j_ny + 0.5) * dy\n    xx_u, yy_u = np.meshgrid(x_u, y_u)\n\n    # C-grid v-points (y-faces)\n    x_v = (i_nx + 0.5) * dx\n    y_v = j_ny * dy\n    xx_v, yy_v = np.meshgrid(x_v, y_v)\n\n    # C-grid corners\n    x_cor = i_nx * dx\n    y_cor = j_ny * dy\n    xx_cor, yy_cor = np.meshgrid(x_cor, y_cor)\n\n    # 3. Define analytical functions\n    def psi_analytic(x, y):\n        return A_psi * np.cos(k_psi_x * x) * np.cos(k_psi_y * y)\n\n    def chi_analytic(x, y):\n        return A_chi * np.sin(k_chi_x * x) * np.sin(k_chi_y * y)\n        \n    def u_analytic(x, y):\n        term_chi = A_chi * k_chi_x * np.cos(k_chi_x * x) * np.sin(k_chi_y * y)\n        term_psi = A_psi * k_psi_y * np.cos(k_psi_x * x) * np.sin(k_psi_y * y)\n        return term_chi + term_psi\n\n    def v_analytic(x, y):\n        term_chi = A_chi * k_chi_y * np.sin(k_chi_x * x) * np.cos(k_chi_y * y)\n        term_psi = -A_psi * k_psi_x * np.sin(k_psi_x * x) * np.cos(k_psi_y * y)\n        return term_chi + term_psi\n\n    def delta_true(x, y):\n        return -(k_chi_x**2 + k_chi_y**2) * chi_analytic(x, y)\n\n    def zeta_true(x, y):\n        return -(k_psi_x**2 + k_psi_y**2) * psi_analytic(x, y)\n\n    # 4. A-Grid Computations\n    u_A = u_analytic(xx_cen, yy_cen)\n    v_A = v_analytic(xx_cen, yy_cen)\n    \n    du_dx_A = (np.roll(u_A, -1, axis=1) - np.roll(u_A, 1, axis=1)) / (2 * dx)\n    dv_dy_A = (np.roll(v_A, -1, axis=0) - np.roll(v_A, 1, axis=0)) / (2 * dy)\n    delta_A = du_dx_A + dv_dy_A\n    \n    dv_dx_A = (np.roll(v_A, -1, axis=1) - np.roll(v_A, 1, axis=1)) / (2 * dx)\n    du_dy_A = (np.roll(u_A, -1, axis=0) - np.roll(u_A, 1, axis=0)) / (2 * dy)\n    zeta_A = dv_dx_A - du_dy_A\n\n    # 5. C-Grid Computations\n    u_C = u_analytic(xx_u, yy_u)\n    v_C = v_analytic(xx_v, yy_v)\n    \n    du_dx_C = (np.roll(u_C, -1, axis=1) - u_C) / dx\n    dv_dy_C = (np.roll(v_C, -1, axis=0) - v_C) / dy\n    delta_C = du_dx_C + dv_dy_C\n    \n    dv_dx_C_corner = (v_C - np.roll(v_C, 1, axis=1)) / dx\n    du_dy_C_corner = (u_C - np.roll(u_C, 1, axis=0)) / dy\n    zeta_C = dv_dx_C_corner - du_dy_C_corner\n    \n    # 6. RMSE Calculation\n    delta_true_cen = delta_true(xx_cen, yy_cen)\n    zeta_true_cen = zeta_true(xx_cen, yy_cen)\n    zeta_true_cor = zeta_true(xx_cor, yy_cor)\n    \n    rmse_div_A = np.sqrt(np.mean((delta_A - delta_true_cen)**2))\n    rmse_div_C = np.sqrt(np.mean((delta_C - delta_true_cen)**2))\n    rmse_vort_A = np.sqrt(np.mean((zeta_A - zeta_true_cen)**2))\n    rmse_vort_C = np.sqrt(np.mean((zeta_C - zeta_true_cor)**2))\n\n    # 7. Noise Fraction Calculation\n    def compute_noise_fraction(field, m, n, Nx, Ny):\n        total_field_power = np.sum(field**2)\n        if total_field_power  1e-30:\n            return 0.0\n\n        F_hat = np.fft.fft2(field)\n        total_energy = np.sum(np.abs(F_hat)**2)\n        \n        if total_energy  1e-30:\n            return 0.0\n            \n        m_idx = m\n        n_idx = n\n        m_neg_idx = Nx - m\n        n_neg_idx = Ny - n\n        \n        # Sum energy at the four symmetric spectral peaks\n        # Note: numpy order is (row, col) => (y, x) => (n, m)\n        expected_energy = 0\n        if m_idx > 0 and n_idx > 0 and m_idx != Nx/2 and n_idx != Ny/2:\n            expected_energy = (\n                np.abs(F_hat[n_idx, m_idx])**2 +\n                np.abs(F_hat[n_idx, m_neg_idx])**2 +\n                np.abs(F_hat[n_neg_idx, m_idx])**2 +\n                np.abs(F_hat[n_neg_idx, m_neg_idx])**2\n            )\n        # Simplified handling for cases on axes or Nyquist, though not in test suite\n        else:\n             # This more general form handles wavenumbers on axes properly\n             indices = set()\n             for sign_m in [-1, 1]:\n                 for sign_n in [-1, 1]:\n                     indices.add(((sign_n * n) % Ny, (sign_m * m) % Nx))\n             for n_i, m_i in indices:\n                 expected_energy += np.abs(F_hat[n_i, m_i])**2\n\n        noise_frac = 1.0 - expected_energy / total_energy\n        return noise_frac\n\n    noise_div_A = compute_noise_fraction(delta_A, m_chi, n_chi, Nx, Ny)\n    noise_div_C = compute_noise_fraction(delta_C, m_chi, n_chi, Nx, Ny)\n    noise_vort_A = compute_noise_fraction(zeta_A, m_psi, n_psi, Nx, Ny)\n    noise_vort_C = compute_noise_fraction(zeta_C, m_psi, n_psi, Nx, Ny)\n    \n    return [\n        rmse_div_A, rmse_div_C, rmse_vort_A, rmse_vort_C,\n        noise_div_A, noise_div_C, noise_vort_A, noise_vort_C\n    ]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}