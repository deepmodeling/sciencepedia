{
    "hands_on_practices": [
        {
            "introduction": "理解吉布斯现象要从分析其在最简单的离散情况下的行为开始。本练习将探讨理想低通滤波器（作为谱截断的代表）应用于离散阶跃函数的傅里叶变换时，如何不可避免地产生振铃。通过研究补零操作带来的影响，您还将更深入地理解离散傅里叶变换（$DFT$）与底层连续谱之间的关系，这是数字信号处理和数值方法中的一个基本概念 。",
            "id": "4049038",
            "problem": "考虑一个用于数值天气预报（NWP）和气候建模的光谱大气模型中的周期性一维经度网格。该网格有 $N$ 个点，索引为 $n \\in \\{0,1,\\dots,N-1\\}$，并有一个模拟尖锐锋面的离散阶跃序列：在阶跃索引之前，场值为 $0$，在阶跃索引处及之后，场值为 $A$。形式上，定义序列 $s[n]$ 为：当 $0 \\le n  n_0$ 时，$s[n] = 0$；当 $n_0 \\le n \\le N-1$ 时，$s[n] = A$。该序列定义在周期域上，但在离散傅里叶分析中被视为单个周期。\n\n长度为 $N$ 的序列 $x[n]$ 的离散傅里叶变换（DFT）定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi k n / N}, \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\n其中 $i$ 是虚数单位，其逆变换为\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi k n / N}.\n$$\n当补零至更大的长度 $M$（$M > N$）时，我们通过将原始的 $N$ 个样本放置在索引 $0,\\dots,N-1$ 处，并对 $n \\in \\{N,\\dots,M-1\\}$ 设置 $x_M[n] = 0$，来构建一个新的序列 $x_M[n]$。其 $M$ 点 DFT 为\n$$\nX_M[k] = \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i 2\\pi k n / M}, \\quad k \\in \\{0,1,\\dots,M-1\\}.\n$$\n\n在光谱大气模型中，截断至最大可解析波数相当于一个理想的低通滤波器。给定一个非负截断值 $K_c$ 且 $K_c  N/2$，定义长度为 $N$ 的理想低通滤波后的谱为\n$$\n\\widetilde{X}[k] = \n\\begin{cases}\nX[k],  \\text{if } k \\in \\{0,1,\\dots,K_c\\} \\cup \\{N-K_c,\\dots,N-1\\},\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n以及通过逆 DFT 得到的相应滤波后的场：\n$$\n\\widetilde{s}[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widetilde{X}[k] \\, e^{i 2\\pi k n / N}.\n$$\n类似地，当补零至长度 $M$ 时，为了保持相同的物理截断（奈奎斯特频率的分数），定义 $K_c^{(M)} = \\left\\lfloor \\frac{M}{N} K_c \\right\\rfloor$ 和理想低通滤波后的谱\n$$\n\\widetilde{X}_M[k] = \n\\begin{cases}\nX_M[k],  \\text{if } k \\in \\{0,1,\\dots,K_c^{(M)}\\} \\cup \\{M-K_c^{(M)},\\dots,M-1\\},\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其滤波后的场为\n$$\n\\widetilde{s}_M[n] = \\frac{1}{M} \\sum_{k=0}^{M-1} \\widetilde{X}_M[k] \\, e^{i 2\\pi k n / M}.\n$$\n\n任务：\n1. 使用等比数列恒等式，从第一性原理推导离散阶跃 $s[n]$ 的 DFT $X[k]$ 的闭式表达式。通过推导补零序列的 $X_M[k]$ 并将其与 $X[k]$ 关联，证明补零改变了底层离散时间傅里叶变换的采样。\n2. 实现一个算法，为给定的 $N$、$M$、$n_0$、$A$ 和 $K_c$ 计算 $\\widetilde{s}[n]$ 和 $\\widetilde{s}_M[n]$。然后，通过以下方式在空间域中量化 Gibbs 现象和谱振铃：\n   - 振铃幅度：对于非补零情况，在不连续点索引 $n_0$ 右侧的邻域内计算过冲幅度为 $\\max(\\widetilde{s}[n]) - A$；对于补零情况，计算过冲幅度为 $\\max(\\widetilde{s}_M[n]) - A$。\n   - 振铃角频率：估计不连续点附近的主导振荡。识别 $n_0$ 右侧 $\\widetilde{s}[n] - A$ 的前两个局部最大值，并通过 $\\omega = \\frac{2\\pi}{\\Delta n}$ 计算角波数（单位为弧度/网格索引），其中 $\\Delta n$ 是这两个最大值之间的网格索引间隔。对 $\\widetilde{s}_M[n] - A$ 使用相同的过程。如果在邻域内找到的局部最大值少于两个，则通过对邻域片段进行 DFT 并找到其幅度谱的峰值索引 $k^\\star$ 来估计主导频率，然后映射为 $\\omega = \\frac{2\\pi k^\\star}{L}$，其中 $L$ 是片段长度。\n3. 在所有频率报告中，使用弧度作为角度单位。本问题中没有物理单位。\n4. 对于每个测试用例，生成一个包含四个浮点数的列表作为最终结果：$[\\text{amp}_{N}, \\omega_{N}, \\text{amp}_{M}, \\omega_{M}]$，其中 $\\text{amp}_{N}$ 和 $\\omega_{N}$ 是未补零情况下的振铃幅度和角频率，$\\text{amp}_{M}$ 和 $\\omega_{M}$ 是补零情况下的振铃幅度和角频率。\n\n测试集：\n- 情况 1：$N=128$，$M=512$，$n_0=64$，$A=1.0$，$K_c=32$。\n- 情况 2：$N=32$，$M=256$，$n_0=16$，$A=1.0$，$K_c=8$。\n- 情况 3：$N=128$，$M=512$，$n_0=20$，$A=1.0$，$K_c=16$。\n- 情况 4：$N=64$，$M=256$，$n_0=4$，$A=1.0$，$K_c=16$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$），其中每个 $\\text{result}_i$ 本身是对应测试用例的 $[\\text{amp}_{N}, \\omega_{N}, \\text{amp}_{M}, \\omega_{M}]$ 形式的列表，并按上面列出的顺序排列。$\\omega$ 的角度单位必须是弧度/网格索引。",
            "solution": "该问题需要进行两部分分析：首先，对离散阶跃函数的离散傅里叶变换（DFT）及其补零效应进行理论推导；其次，通过数值实现来量化在谱域中对此阶跃函数进行低通滤波所引起的 Gibbs 现象（振铃）。\n\n### 第1部分：理论推导\n\n#### 1.1. 离散阶跃序列的 DFT\n设长度为 $N$ 的离散序列为 $s[n]$，定义如下：\n$$\ns[n] = \n\\begin{cases}\n0  \\text{ for } 0 \\le n  n_0 \\\\\nA  \\text{ for } n_0 \\le n \\le N-1\n\\end{cases}\n$$\n其 $N$ 点 DFT $X[k]$ 由下式给出：\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] e^{-i 2\\pi k n / N}\n$$\n代入 $s[n]$ 的定义：\n$$\nX[k] = \\sum_{n=n_0}^{N-1} A e^{-i 2\\pi k n / N} = A \\sum_{n=n_0}^{N-1} \\left(e^{-i 2\\pi k / N}\\right)^n\n$$\n这是一个有限等比数列。我们考虑频率索引 $k$ 的两种情况。\n\n**情况1：$k=0$（直流分量）**\n当 $k=0$ 时，指数项为 $e^0 = 1$。\n$$\nX[0] = A \\sum_{n=n_0}^{N-1} 1 = A \\cdot ((N-1) - n_0 + 1) = A(N-n_0)\n$$\n这表示信号的平均值乘以 $N$。\n\n**情况2：$k \\in \\{1, 2, \\dots, N-1\\}$**\n当 $k \\ne 0$ 时，等比数列的公比为 $r = e^{-i 2\\pi k / N} \\ne 1$。等比数列求和公式为 $\\sum_{j=a}^{b} r^j = r^a \\frac{1-r^{b-a+1}}{1-r}$。\n这里，首项是 $n=n_0$ 处的项，末项是 $n=N-1$ 处的项，项数为 $L = N-n_0$。\n$$\n\\sum_{n=n_0}^{N-1} r^n = r^{n_0} \\frac{1 - r^{N-n_0}}{1-r}\n$$\n代入 $r = e^{-i 2\\pi k / N}$：\n$$\nX[k] = A \\left(e^{-i 2\\pi k / N}\\right)^{n_0} \\frac{1 - \\left(e^{-i 2\\pi k / N}\\right)^{N-n_0}}{1 - e^{-i 2\\pi k / N}} = A e^{-i 2\\pi k n_0 / N} \\frac{1 - e^{-i 2\\pi k (N-n_0) / N}}{1 - e^{-i 2\\pi k / N}}\n$$\n我们可以使用整数 $k$ 的恒等式 $e^{-i2\\pi k} = 1$ 来简化项 $e^{-i 2\\pi k (N-n_0) / N} = e^{-i 2\\pi k} e^{i 2\\pi k n_0 / N} = e^{i 2\\pi k n_0 / N}$。表达式变为：\n$$\nX[k] = A e^{-i 2\\pi k n_0 / N} \\frac{1 - e^{i 2\\pi k n_0 / N}}{1 - e^{-i 2\\pi k / N}}\n$$\n这个表达式可以使用欧拉公式 $e^{i\\theta} - e^{-i\\theta} = 2i \\sin(\\theta)$ 进一步简化。\n$$\nX[k] = A \\frac{e^{-i 2\\pi k n_0/N} - 1}{e^{-i 2\\pi k / N} - 1} = A \\frac{e^{-i \\pi k n_0/N}(e^{-i \\pi k n_0/N} - e^{i \\pi k n_0/N})}{e^{-i \\pi k /N}(e^{-i \\pi k /N} - e^{i \\pi k /N})} = A \\frac{e^{-i \\pi k n_0/N}(-2i \\sin(\\frac{\\pi k n_0}{N}))}{e^{-i \\pi k /N}(-2i \\sin(\\frac{\\pi k}{N}))}\n$$\n$$\nX[k] = A e^{-i\\pi k(n_0-1)/N} \\frac{\\sin(\\pi k n_0 / N)}{\\sin(\\pi k / N)}\n$$\n这就是 $k \\ne 0$ 时 DFT 系数的闭式表达式。\n\n#### 1.2. 补零效应及其与 DTFT 的关系\n将长度为 $N$ 的序列 $s[n]$ 补零至长度 $M>N$ 会得到一个新序列 $s_M[n]$：\n$$\ns_M[n] = \n\\begin{cases}\ns[n]  \\text{ for } 0 \\le n  N \\\\\n0  \\text{ for } N \\le n  M\n\\end{cases}\n$$\n$s_M[n]$ 的 $M$ 点 DFT 为：\n$$\nX_M[k] = \\sum_{n=0}^{M-1} s_M[n] e^{-i 2\\pi k n / M} = \\sum_{n=0}^{N-1} s[n] e^{-i 2\\pi k n / M}\n$$\n该求和的项数与 $X[k]$ 的求和相同，但复指数在不同的频率上求值。这表明补零不会向频谱中添加新信息，但会改变其采样方式。\n\n为了将其形式化，我们引入原始有限长度序列 $s[n]$ 的离散时间傅里叶变换（DTFT），它是频率 $\\omega$ 的连续函数：\n$$\nS(e^{i\\omega}) = \\sum_{n=-\\infty}^{\\infty} s[n] e^{-i\\omega n} = \\sum_{n=0}^{N-1} s[n] e^{-i\\omega n}\n$$\n$N$ 点 DFT $X[k]$ 是 DTFT $S(e^{i\\omega})$ 在 $N$ 个离散频率 $\\omega_k = \\frac{2\\pi k}{N}$ 上的采样：\n$$\nX[k] = S(e^{i 2\\pi k / N})\n$$\n补零序列的 $M$ 点 DFT $X_M[k]$ 是对*相同* DTFT $S(e^{i\\omega})$ 的采样，但采样点位于 $M$ 个离散频率 $\\omega'_k = \\frac{2\\pi k}{M}$ 上：\n$$\nX_M[k] = S(e^{i 2\\pi k / M})\n$$\n由于 $M > N$，频率 $\\omega'_k$ 比 $\\omega_k$ 更密集。因此，补零提供了对底层连续谱 $S(e^{i\\omega})$ 的更密集采样，这通常能揭示其结构的更多细节。$X_M[k]$ 的闭式表达式可以通过在 $s[n]$ 在 $n_0$ 到 $N-1$ 范围内的等比数列求和中，将指数分母中的 $N$ 替换为 $M$ 来获得。\n\n### 第2部分：数值分析算法\n\n数值任务是模拟理想低通滤波器对阶跃序列的影响，并量化由此产生的 Gibbs 现象。\n\n1.  **信号生成**：对于给定的测试用例 $(N, M, n_0, A, K_c)$：\n    *   构建长度为 $N$ 的序列 $s[n]$，如定义所示。\n    *   构建长度为 $M$ 的补零序列 $s_M[n]$。\n\n2.  **谱滤波（非补零情况）**：\n    *   计算 $N$ 点 DFT，$X[k] = \\text{DFT}(s[n])$。\n    *   创建一个初始化为零的新谱 $\\widetilde{X}[k]$。\n    *   应用截断值为 $K_c$ 的理想低通滤波器：\n        $$\n        \\widetilde{X}[k] = \n        \\begin{cases}\n        X[k],  \\text{if } k \\in \\{0, \\dots, K_c\\} \\cup \\{N-K_c, \\dots, N-1\\} \\\\\n        0,  \\text{otherwise}\n        \\end{cases}\n        $$\n    *   通过逆 DFT 计算空间域中的滤波后信号：$\\widetilde{s}[n] = \\text{IDFT}(\\widetilde{X}[k])$。我们使用其实部 $\\mathbb{R}\\{\\widetilde{s}[n]\\}$ 进行分析。\n\n3.  **谱滤波（补零情况）**：\n    *   计算 $M$ 点 DFT，$X_M[k] = \\text{DFT}(s_M[n])$。\n    *   计算缩放后的截断波数 $K_c^{(M)} = \\lfloor \\frac{M}{N} K_c \\rfloor$。\n    *   将理想低通滤波器应用于 $X_M[k]$，使用新的截断值 $K_c^{(M)}$ 以获得 $\\widetilde{X}_M[k]$。\n    *   计算滤波后的信号：$\\widetilde{s}_M[n] = \\text{IDFT}(\\widetilde{X}_M[k])$。我们使用 $\\mathbb{R}\\{\\widetilde{s}_M[n]\\}$ 进行分析。\n\n4.  **振铃量化**：分析是在偏离平台值的基础上进行的，例如 $\\mathbb{R}\\{\\widetilde{s}[n]\\} - A$。\n    *   **振铃幅度**：最大过冲在不连续点右侧的邻域内找到。\n        *   非补零：$\\text{amp}_{N} = \\max_{n_0 \\le n  N} (\\mathbb{R}\\{\\widetilde{s}[n]\\}) - A$。\n        *   补零：$\\text{amp}_{M} = \\max_{n_0 \\le n  M} (\\mathbb{R}\\{\\widetilde{s}_M[n]\\}) - A$。\n    *   **振铃角频率**：\n        *   我们首先尝试在 $n_0$ 右侧的邻域中找到振铃信号（$\\mathbb{R}\\{\\widetilde{s}[n]\\} - A$）的前两个局部最大值。为此，我们对从索引 $n_0$ 到数组末尾的信号段使用峰值查找算法。\n        *   如果在索引 $p_1$ 和 $p_2$ 处找到至少两个峰值，则间隔为 $\\Delta n = p_2 - p_1$。角频率为 $\\omega = \\frac{2\\pi}{\\Delta n}$ 弧度/网格索引。\n        *   如果找到的峰值少于两个，我们转而采用频域估计。我们取从 $n_0$ 到末尾的振铃信号段，长度为 $L$。我们计算其 $L$ 点 DFT。我们找到使 DFT 系数幅度最大化的索引 $k^\\star$，不包括直流分量（$k=0$）和负频率。然后角频率估计为 $\\omega = \\frac{2\\pi k^\\star}{L}$。\n    此过程分别应用于非补零信号 $\\widetilde{s}[n]$ 和补零信号 $\\widetilde{s}_M[n]$，以找到 $\\omega_N$ 和 $\\omega_M$。\n\n这个全面的算法可以对每个测试用例中 Gibbs 现象的指定特征进行稳健的量化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying Gibbs phenomenon for a low-pass filtered step function\n    with and without zero-padding, as specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, M, n0, A, Kc)\n        (128, 512, 64, 1.0, 32),\n        (32, 256, 16, 1.0, 8),\n        (128, 512, 20, 1.0, 16),\n        (64, 256, 4, 1.0, 16),\n    ]\n\n    results = []\n    for N, M, n0, A, Kc in test_cases:\n        # --- Non-padded case ---\n        # 1. Create the signal\n        s_n = np.zeros(N)\n        s_n[n0:] = A\n\n        # 2. DFT and low-pass filtering\n        X_k = np.fft.fft(s_n)\n        X_tilde_k = np.zeros_like(X_k)\n        X_tilde_k[0 : Kc + 1] = X_k[0 : Kc + 1]\n        if Kc > 0:\n            X_tilde_k[N - Kc : N] = X_k[N - Kc : N]\n        s_tilde_n = np.fft.ifft(X_tilde_k).real\n\n        # 3. Quantify ringing\n        search_range_n = np.arange(n0, N)\n        signal_segment_n = s_tilde_n[search_range_n]\n        \n        # Amplitude\n        amp_N = np.max(signal_segment_n) - A\n\n        # Frequency\n        ringing_signal_n = signal_segment_n - A\n        peaks_n, _ = find_peaks(ringing_signal_n)\n        \n        if len(peaks_n) >= 2:\n            delta_n = peaks_n[1] - peaks_n[0]\n            omega_N = 2 * np.pi / delta_n\n        else:\n            L_n = len(ringing_signal_n)\n            if L_n > 1:\n                dft_segment_n = np.fft.fft(ringing_signal_n)\n                # Find peak in positive frequency half, excluding DC\n                magnitudes = np.abs(dft_segment_n[1 : L_n // 2])\n                if len(magnitudes) > 0:\n                    k_star = np.argmax(magnitudes) + 1\n                    omega_N = 2 * np.pi * k_star / L_n\n                else: # Segment too short for meaningful frequency\n                    omega_N = 0.0\n            else:\n                omega_N = 0.0\n\n        # --- Padded case ---\n        # 1. Create the padded signal\n        s_m = np.zeros(M)\n        s_m[n0:N] = A\n\n        # 2. DFT and low-pass filtering\n        Kc_M = int(np.floor(M / N * Kc))\n        X_m_k = np.fft.fft(s_m)\n        X_tilde_m_k = np.zeros_like(X_m_k)\n        X_tilde_m_k[0 : Kc_M + 1] = X_m_k[0 : Kc_M + 1]\n        if Kc_M > 0:\n            X_tilde_m_k[M - Kc_M : M] = X_m_k[M - Kc_M : M]\n        s_tilde_m = np.fft.ifft(X_tilde_m_k).real\n\n        # 3. Quantify ringing\n        search_range_m = np.arange(n0, M)\n        signal_segment_m = s_tilde_m[search_range_m]\n        \n        # Amplitude\n        amp_M = np.max(signal_segment_m) - A\n\n        # Frequency\n        ringing_signal_m = signal_segment_m - A\n        peaks_m, _ = find_peaks(ringing_signal_m)\n\n        if len(peaks_m) >= 2:\n            delta_m = peaks_m[1] - peaks_m[0]\n            omega_M = 2 * np.pi / delta_m\n        else:\n            L_m = len(ringing_signal_m)\n            if L_m > 1:\n                dft_segment_m = np.fft.fft(ringing_signal_m)\n                # Find peak in positive frequency half, excluding DC\n                magnitudes = np.abs(dft_segment_m[1 : L_m // 2])\n                if len(magnitudes) > 0:\n                    k_star = np.argmax(magnitudes) + 1\n                    omega_M = 2 * np.pi * k_star / L_m\n                else:\n                    omega_M = 0.0\n            else: \n                omega_M = 0.0\n\n        results.append(f\"[{amp_N},{omega_N},{amp_M},{omega_M}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "观察到谱振铃之后，下一步是学习如何控制它。在数值模型中，超扩散是实现此目的的标准技术。本练习将从简单的阶跃函数转向更真实的斜压急流廓线，以探索超扩散如何选择性地阻尼高波数振荡 。最关键的是，您将量化减少非物理振铃与保持物理梯度锋利度之间的权衡，这是设计数值方案时的一个核心挑战。",
            "id": "4049043",
            "problem": "考虑一个理想化斜压急流的周期性经向切片，它由定义域 $y \\in [0, 2\\pi)$ 上的纬向风速场 $u(y)$ 表示，其中 $y$ 以弧度为单位。该急流有一个风速近似恒定的平台区，由两个陡峭的锋区界定。本练习旨在演示由傅里叶截断（Gibbs 现象）产生的光谱振铃如何通过超扩散得到缓解，并在一个与数值天气预报和气候模拟实践相符的受控数值实验中，量化振铃缓解与梯度保真度之间的权衡。\n\n从以下基本依据出发：\n\n- 离散傅里叶变换 (DFT) 及其逆变换提供了周期函数与其谱系数之间的双射变换。DFT 将空间变化映射到波数空间，并支持通过乘以波数进行精确微分。\n- 快速傅里叶变换 (FFT) 是一种高效计算 DFT 的算法。\n- 一个大气谱模式可以理想化为使用截断的傅里葉表示，只保留波数 $|k| \\le k_c$ 的分量，这会因 Gibbs 现象而在陡峭梯度附近引入谱振铃。\n- 超扩散在连续时间中由线性偏微分方程 $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$ 建模，其中超扩散阶数 $p \\in \\mathbb{N}$，系数 $\\nu > 0$。此算子优先衰减高波数分量以缓解振铃。\n\n使用以下公式在 $N$ 个等距点上定义理想化的急流廓线\n$$\nu_{\\text{true}}(y) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_2}{w}\\right)\\right],\n$$\n其中 $U_0$ 是急流平台区速度，单位为米/秒，$y_1 = y_0 - \\Delta$, $y_2 = y_0 + \\Delta$, $y_0=\\pi$，$\\Delta$ 是急流半宽（以弧度为单位），$w$ 是决定锋区陡峭度的锐度参数（以弧度为单位）。离散网格为 $y_j = 2\\pi j/N$，其中 $j=0,\\dots,N-1$。\n\n令 $\\widehat{u}(k)$ 表示 $u(y)$ 在此网格上的 DFT，其中波数 $k$ 表示为与 $2\\pi$ 周期性一致的整数倍。截断谱表示将 $|k|>k_c$ 的 $\\widehat{u}(k)$ 置为 0，其中 $k_c$ 是分辨率截断值。超扩散应根据上述连续时间模型，在谱空间中对截断表示施加一个单位无量纲时间步长，这被解释为对保留模式的谱阻尼。您不得使用本问题中陈述的任何公式来绕过推导；所有步骤必须从给定的基本依据逻辑地推导出来。\n\n定义两个定量指标：\n\n1. 振铃振幅 $R$：重建场在物理上合理的范围 $\\left[0, U_0\\right]$ 之外的最大偏离，并由 $U_0$ 归一化，\n$$\nR = \\frac{1}{U_0}\\max\\left\\{\\max_{y}\\left(u(y)-U_0\\right)_+, \\max_{y}\\left(-u(y)\\right)_+\\right\\},\n$$\n其中 $(x)_+ = \\max(x,0)$，$u(y)$ 是经过截断和超扩散后的重建场。此指标为无量纲。\n\n2. 梯度保真度误差 $E$：经向梯度相对于真实场的相对 $\\ell^2$ 误差，\n$$\nE = \\frac{\\left\\|\\partial_y u(y) - \\partial_y u_{\\text{true}}(y)\\right\\|_2}{\\left\\|\\partial_y u_{\\text{true}}(y)\\right\\|_2},\n$$\n其中导数通过谱方法计算，$\\ell^2$ 范数在离散网格上计算。此指标为无量纲。\n\n您的程序必须：\n\n- 使用以下参数在周期性网格上构建 $u_{\\text{true}}(y)$。\n- 计算其 DFT，在 $|k| \\le k_c$ 处进行截断，然后根据 $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$ 为单位无量纲时间步长在谱空间中施加超扩散。\n- 通过逆 DFT 重建场，并计算上述定义的 $R$ 和 $E$。\n\n使用以下科学上真实的参数值创建一个测试套件，以检验这种权衡关系：\n\n- 网格大小: $N = 2048$。\n- 平台区速度: $U_0 = 40$ 米/秒。\n- 急流参数: $\\Delta = 0.7$ 弧度, $w = 0.02$ 弧度, $y_0 = \\pi$。\n- 谱截断值: $k_c = 128$。\n- 超扩散测试用例，表示为对 $(\\alpha, p)$，其中 $\\alpha$ 是一个无量纲强度参数，$p$ 是超扩散阶数：\n  1. 用例1 (边界情况，无超扩散): $(\\alpha, p) = (0.0, 4)$。\n  2. 用例2 (中等缓解): $(\\alpha, p) = (0.4, 4)$。\n  3. 用例3 (强超扩散): $(\\alpha, p) = (3.0, 4)$。\n  4. 用例4 (高阶超扩散): $(\\alpha, p) = (1.0, 8)$。\n\n所有角度单位必须是弧度。所有速度单位是米/秒，但输出是无量纲的，无需单位换算。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序排列结果：\n$$\n\\left[R_1, E_1, R_2, E_2, R_3, E_3, R_4, E_4\\right],\n$$\n其中 $R_i$ 和 $E_i$ 对应于用例 $i$。\n\n程序必须完整且可直接运行，无需用户输入，并且只能使用 Python 标准库和指定的数值库。输出值必须是 $\\text{float}$ 类型。设计应确保科学真实性和内部一致性，并且每个测试用例必须产生一个确定性的数值结果。",
            "solution": "该问题要求进行数值模拟，以量化在理想化大气急流的谱模式中使用超扩散时，在缓解谱振铃（Gibbs 现象）和保持梯度保真度之间的权衡。解决方案包括离散化急流廓线，使用快速傅里叶变换 (FFT) 将其转换到谱空间，应用谱截断和超扩散算子，再转换回物理空间，最后计算两个指定的指标：振铃振幅 $R$ 和梯度保真度误差 $E$。\n\n首先，我们建立计算域和真实状态。理想化的急流廓线 $u_{\\text{true}}(y)$ 定义在周期域 $y \\in [0, 2\\pi)$ 上。我们使用 $N=2048$ 个等距点 $y_j = 2\\pi j/N$（其中 $j = 0, \\dots, N-1$）来离散化此域。此网格上的真实速度场使用给定公式计算：\n$$\nu_{\\text{true}}(y_j) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_2}{w}\\right)\\right]\n$$\n参数为 $U_0=40$, $y_0=\\pi$, $\\Delta=0.7$, $w=0.02$, $y_1=y_0-\\Delta$, 以及 $y_2=y_0+\\Delta$。锐度参数 $w$ 很小，产生了陡峭的梯度，这将在谱截断时引起强烈的 Gibbs 振铃。\n\n该方法的核心在谱空间。我们使用离散傅里叶变换 (DFT)（通过 FFT 算法计算）来获得离散场 $u_{\\text{true}}(y_j)$ 的谱系数 $\\widehat{u}_{\\text{true}}(k)$。对于 $2\\pi$ 域上的 $N$ 点网格，获得相应的整数波数 $k$。物理空间中的微分算子 $\\partial_y$ 对应于谱空间中的乘法 $ik$，其中 $i = \\sqrt{-1}$。此属性用于计算所有空间导数。\n\n每个测试用例 $(\\alpha, p)$ 的数值模拟遵循一个精确的步骤序列：\n\n1.  **谱截断**：通过将波数绝对值 $|k|$ 超过截断值 $k_c=128$ 的所有系数设置为零，来截断真实谱 $\\widehat{u}_{\\text{true}}(k)$。这模拟了一个有限分辨率的谱模式。令得到的截断谱为 $\\widehat{u}_{\\text{trunc}}(k)$：\n    $$\n    \\widehat{u}_{\\text{trunc}}(k) = \\begin{cases} \\widehat{u}_{\\text{true}}(k)  \\text{if } |k| \\le k_c \\\\ 0  \\text{if } |k| > k_c \\end{cases}\n    $$\n    这种突兀的截断是 Gibbs 现象的来源。用例1，没有超扩散（$\\alpha=0$），单独分离出截斷的效应。\n\n2.  **超扩散阻尼**：将超扩散应用于截断谱，以阻尼高波数振荡。控制连续方程为 $u_t = -\\nu(-\\partial_y^2)^p u$。在谱空间中，这成为每个谱系数 $\\widehat{u}(k)$ 的常微分方程：\n    $$\n    \\frac{d\\widehat{u}(k, t)}{dt} = -\\nu (k^2)^p \\widehat{u}(k, t) = -\\nu k^{2p} \\widehat{u}(k, t)\n    $$\n    在一个单位无量纲时间步长（$t=1$）上的解为 $\\widehat{u}(k, 1) = \\widehat{u}(k, 0) \\exp(-\\nu k^{2p})$。问题提供的是无量纲强度参数 $\\alpha$，而不是系数 $\\nu$。遵循数值天气预报中的标准做法，我们将 $\\alpha$ 与截断波数 $k_c$ 处的阻尼强度关联起来。我们将阻尼因子在 $|k|=k_c$ 处的指数设为 $-\\alpha$。这得出关系式 $\\nu k_c^{2p} = \\alpha$，因此 $\\nu = \\alpha/k_c^{2p}$。因此，应用于任何保留模式（$|k| \\le k_c$）的阻尼因子 $D(k)$ 为：\n    $$\n    D(k) = \\exp\\left(-\\frac{\\alpha}{k_c^{2p}} k^{2p}\\right) = \\exp\\left[-\\alpha \\left(\\frac{|k|}{k_c}\\right)^{2p}\\right]\n    $$\n    将此因子乘以截断谱系数，得到最终谱 $\\widehat{u}_{\\text{final}}(k) = \\widehat{u}_{\\text{trunc}}(k) D(k)$。对于 $\\alpha=0$，$D(k)=1$，对应于无扩散。\n\n3.  **重建**：通过对 $\\widehat{u}_{\\text{final}}(k)$ 应用逆 DFT（通过 IFFT 算法），重建最终的物理场 $u(y)$。由于初始场是实数，我们取结果的实部以舍弃由浮点误差引起的任何微小虚部。\n\n在获得给定测试用例的最终场 $u(y)$ 后，我们计算两个指标：\n\n1.  **振铃振幅 ($R$)**：此指标量化了非物理振荡。它是计算场 $u(y)$ 超出物理预期范围 $[0, U_0]$ 的最大偏差，并由急流速度 $U_0$ 归一化。在离散网格上，它的计算方式为：\n    $$\n    R = \\frac{1}{U_0} \\max\\left\\{ \\max_j\\left( \\max(u(y_j)-U_0, 0) \\right), \\max_j\\left( \\max(-u(y_j), 0) \\right) \\right\\}\n    $$\n\n2.  **梯度保真度误差 ($E$)**：此指标衡量物理上重要的陡峭锋区的退化程度。它是最终场梯度相对于真实场梯度的相对 $\\ell^2$ 误差。为保证一致性和准确性，两个梯度都通过谱方法计算。真实场的梯度 $\\partial_y u_{\\text{true}}(y)$ 是通过对 $ik\\widehat{u}_{\\text{true}}(k)$ 进行逆 DFT 找到的。同样，最终场的梯度 $\\partial_y u(y)$ 是对 $ik\\widehat{u}_{\\text{final}}(k)$ 进行逆 DFT 的结果。误差 $E$ 则为：\n    $$\n    E = \\frac{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u(y_j) - \\partial_y u_{\\text{true}}(y_j)|^2}}{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u_{\\text{true}}(y_j)|^2}} = \\frac{\\|\\partial_y u - \\partial_y u_{\\text{true}}\\|_2}{\\|\\partial_y u_{\\text{true}}\\|_2}\n    $$\n分母 $\\|\\partial_y u_{\\text{true}}\\|_2$ 从完整、未截断的真实谱计算一次，作为恒定的参考。分子则对每个测试用例进行计算。此过程系统地应用于所有四个测试用例，以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes ringing and gradient error metrics for a spectral model\n    of an idealized jet with hyperdiffusion.\n    \"\"\"\n    # Define physical and numerical parameters\n    N = 2048\n    U0 = 40.0\n    delta = 0.7\n    w = 0.02\n    y0 = np.pi\n    kc = 128\n\n    # Define the hyperdiffusion test cases (alpha, p)\n    test_cases = [\n        (0.0, 4),  # Case 1: No hyperdiffusion\n        (0.4, 4),  # Case 2: Moderate hyperdiffusion\n        (3.0, 4),  # Case 3: Strong hyperdiffusion\n        (1.0, 8),  # Case 4: High-order hyperdiffusion\n    ]\n\n    # Create the spatial grid\n    y = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # Define the true jet profile\n    y1 = y0 - delta\n    y2 = y0 + delta\n    u_true = (U0 / 2.0) * (1.0 + np.tanh((y - y1) / w)) - \\\n             (U0 / 2.0) * (1.0 + np.tanh((y - y2) / w))\n\n    # Compute spectral representation of the true field and its gradient\n    # Wavenumbers k for a 2*pi periodic domain\n    k = np.fft.fftfreq(N) * N\n    u_true_hat = np.fft.fft(u_true)\n\n    # Compute the true gradient spectrally for the error metric denominator\n    grad_u_true_hat = 1j * k * u_true_hat\n    grad_u_true = np.real(np.fft.ifft(grad_u_true_hat))\n    norm_grad_u_true = np.linalg.norm(grad_u_true)\n\n    results = []\n\n    # Process each test case\n    for alpha, p in test_cases:\n        # Step 1: Spectral Truncation\n        # Create a copy to modify\n        u_final_hat = u_true_hat.copy()\n        # Apply sharp cutoff by zeroing out coefficients where |k| > kc\n        u_final_hat[np.abs(k) > kc] = 0.0\n\n        # Step 2: Apply Hyperdiffusion\n        if alpha > 0.0:\n            # We only need to compute and apply damping to the retained modes |k| = kc\n            # Find indices of modes to be damped\n            indices_to_damp = np.where(np.abs(k) = kc)[0]\n            k_to_damp = k[indices_to_damp]\n\n            # Calculate damping factor for these modes\n            # ratios = |k|/kc\n            ratios = np.abs(k_to_damp) / kc\n            # D(k) = exp(-alpha * (|k|/kc)^(2p))\n            dampers = np.exp(-alpha * (ratios**(2 * p)))\n            \n            # Apply the damping factor to the truncated spectrum\n            u_final_hat[indices_to_damp] *= dampers\n\n        # Step 3: Reconstruct the physical field\n        u_final = np.real(np.fft.ifft(u_final_hat))\n\n        # --- Compute Metrics ---\n\n        # Metric 1: Ringing amplitude (R)\n        overshoot = np.maximum(u_final - U0, 0)\n        undershoot = np.maximum(-u_final, 0)\n        R = np.maximum(np.max(overshoot), np.max(undershoot)) / U0\n        results.append(R)\n\n        # Metric 2: Gradient fidelity error (E)\n        # Gradient of the final field is computed from its spectrum u_final_hat\n        grad_u_final_hat = 1j * k * u_final_hat\n        grad_u_final = np.real(np.fft.ifft(grad_u_final_hat))\n        \n        # Calculate L2 norm of the gradient difference\n        grad_diff = grad_u_final - grad_u_true\n        norm_grad_diff = np.linalg.norm(grad_diff)\n        \n        # Calculate relative error E\n        E = norm_grad_diff / norm_grad_u_true\n        results.append(E)\n\n    # Format and print final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的全球气候与天气预报是在球面上进行的，而非一维直线上。这最后一个练习将我们的理解提升到这一至关重要的几何背景中。在这里，您将使用球谐函数——全球场的谱基——并设计一个滤波器来减轻合成海岸线周围的振铃现象 。本练习强调了滤波器必须尊重物理守恒定律的迫切需求，在此案例中是保持场的总质量，这在气候模拟中是一个不可妥协的要求。",
            "id": "4049060",
            "problem": "要求你设计并评估一个球面上的谱滤波器，该滤波器能够减少全球场中的吉布斯现象（谱振铃），同时保持总质量。背景设定为数值天气预报（NWP）和气候模拟，在这些领域中，全球场通常使用球谐函数在球面上表示。你的程序必须实现一个独立的球谐分析与合成过程，处理一个具有类海岸线不连续性的合成全球场，应用一个保持质量的高阶抑制滤波器，并量化振铃的减少程度。\n\n你必须从以下纯数学术语表述的基本基础出发：\n\n- 球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 在单位球面上构成一个标准正交基，其曲面元为 $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$，其中 $\\theta \\in [0,\\pi]$ 是以弧度表示的余纬，$\\phi \\in [0,2\\pi)$ 是以弧度表示的经度。正交归一性意味着\n$$\n\\int_{0}^{\\pi}\\int_{0}^{2\\pi} Y_{\\ell}^{m}(\\theta,\\phi)\\, Y_{\\ell'}^{m'}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}.\n$$\n- 球面上任何平方可积的标量场 $f(\\theta,\\phi)$ 都可以展开为\n$$\nf(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\n其球谐系数为\n$$\nc_{\\ell,m} \\;=\\; \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\n- 当通过截断谱展开表示不连续函数时，会出现吉布斯现象；高阶模态会在不连续点附近产生振荡过冲，这种过冲不会随着截断而消失，但可以通过对高阶模态进行适当滤波来缓解。\n\n设计目标和约束：\n\n1. 提出一个作用于球谐系数 $c_{\\ell,m}$ 的滤波器，该滤波器能抑制高阶模态，同时保持总质量。单位球面上场 $f(\\theta,\\phi)$ 的总质量与0阶0次系数 $c_{0,0}$ 成正比，因为 $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$。你的滤波器必须满足 $G(0) = 1$，以确保 $c_{0,0}$ 不被修改。\n2. 在一个等距经纬度网格上，使用权重为 $w(\\theta,\\phi) = \\sin\\theta\\, \\Delta\\theta\\, \\Delta\\phi$ 的离散求积法，实现数值球谐分析与合成。角度必须以弧度为单位。\n3. 通过定义一个陆海掩码 $f(\\theta,\\phi)$ 来构建一个具有类海岸线不连续性的合成全球气候场。对于经度 $\\phi \\in [0,\\pi)$（“陆地”半球），该场等于 $1$；对于 $\\phi \\in [\\pi,2\\pi)$（“海洋”半球），该场等于 $0$。该场在 $\\phi = \\pi$ 处呈现一条经向海岸线。\n4. 通过计算一个窄海岸带内的最大边界违例来量化海岸线周围的振铃。该边界违例定义为在带 $\\{(\\theta,\\phi): |\\phi-\\pi| \\leq 3\\Delta\\phi\\}$ 内（其中 $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$），重构场超过 $1$ 的正向过冲的最大值与低于 $0$ 的负向过冲的绝对值的最大值。该度量是一个非负浮点数。\n5. 通过计算绝对差 $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$ 来证明质量守恒。该量必须以浮点数形式报告，并且如果强制执行 $G(0)=1$，它在数值上应该非常小（理想情况下为零）。\n\n你必须实现以下滤波器规格和重构协议：\n\n- 定义滤波器传递函数 $G(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right)$，其中无量纲参数 $\\alpha \\ge 0$。该函数满足 $G(0)=1$ 并随 $\\ell$ 单调递减，从而强力抑制高阶模态，同时保持总质量不变。\n- 对于给定的截断阶数 $L_{\\text{trunc}}$，使用离散求积和计算 $0 \\le \\ell \\le L_{\\text{trunc}}$，$-\\ell \\le m \\le \\ell$ 的系数 $c_{\\ell,m}$：\n$$\nc_{\\ell,m} \\;\\approx\\; \\sum_{i=1}^{N_{\\text{lat}}}\\sum_{j=1}^{N_{\\text{lon}}} f(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^{*}\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi,\n$$\n其中网格为 $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\,\\Delta\\theta$（$i = 0,\\ldots,N_{\\text{lat}}-1$）和 $\\phi_j = j\\, \\Delta\\phi$（$j = 0,\\ldots,N_{\\text{lon}}-1$），且 $\\Delta\\theta = \\pi/N_{\\text{lat}}$，$\\Delta\\phi = 2\\pi/N_{\\text{lon}}$。\n- 重构基准截断场\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\n和滤波后的场\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n\n物理和数值单位：\n\n- 所有角度 $\\theta$ 和 $\\phi$ 必须以弧度为单位。\n- 场 $f(\\theta,\\phi)$ 是无量纲的。\n\n测试套件：\n\n使用一个 $N_{\\text{lat}} = 73$ 和 $N_{\\text{lon}} = 144$ 的等距网格。评估以下五个参数集，每个参数集由一对 $(L_{\\text{trunc}}, \\alpha)$ 定义：\n\n- 情况 1：$(L_{\\text{trunc}}, \\alpha) = (20, 0.0)$，基准，无滤波。\n- 情况 2：$(L_{\\text{trunc}}, \\alpha) = (20, 0.005)$，中等平滑。\n- 情况 3：$(L_{\\text{trunc}}, \\alpha) = (20, 0.02)$，强平滑。\n- 情况 4：$(L_{\\text{trunc}}, \\alpha) = (12, 0.02)$，较低截断阶数带平滑。\n- 情况 5：$(L_{\\text{trunc}}, \\alpha) = (20, 2.0)$，极端平滑，近似于仅保留0阶模态。\n\n对于每种情况，计算三个浮点数：\n- 使用相同的 $L_{\\text{trunc}}$ 但 $\\alpha = 0$（即无滤波）的基准边界违例幅度。\n- 使用指定 $\\alpha$ 的滤波后边界违例幅度。\n- 绝对质量差 $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$。\n\n最终输出格式：\n\n你的程序应该生成单行输出，包含一个由五个内部列表组成的逗号分隔列表，每个内部列表的形式为 $[b,f,m]$，其中 $b$ 是基准边界违例幅度，$f$ 是滤波后边界违例幅度，$m$ 是绝对质量差。数字必须四舍五入到六位小数。最终打印的行不得包含空格，例如：\n\"[[b1,f1,m1],[b2,f2,m2],[b3,f3,m3],[b4,f4,m4],[b5,f5,m5]]\"。",
            "solution": "我们从单位球面上球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 相对于曲面元 $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$ 的正交归一性开始。对于任何平方可积场 $f(\\theta,\\phi)$，其球谐系数为\n$$\nc_{\\ell,m} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi,\n$$\n谱重构为\n$$\nf(\\theta,\\phi) = \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n在数值天气预报和气候模拟中，标准做法是在阶数 $L_{\\text{trunc}}$ 处进行截断：\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n然而，仅截断会保留直到 $\\ell=L_{\\text{trunc}}$ 的高阶贡献，这会导致在海岸线等不连续点附近出现吉布斯现象，表现为超出物理边界的振荡过冲。一种缓解措施是对高阶模态进行谱滤波。\n\n我们提出基于拉普拉斯算子的指数滤波器\n$$\nG(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right),\n$$\n其中 $\\alpha \\ge 0$ 是无量纲的。该滤波器满足 $G(0) = 1$，从而保持了0阶模态。由于 $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$ 是常数，球谐系数 $c_{0,0}$ 与 $f$ 的全球质量（积分）成正比：\n$$\nc_{0,0} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{0}^{0}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi\n= \\sqrt{\\frac{1}{4\\pi}} \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\n由于 $G(0) = 1$，滤波后的系数 $c_{0,0}^{\\text{filtered}} = G(0)\\, c_{0,0} = c_{0,0}$，因此总质量在谱空间中是精确守恒的。\n\n为了数值计算系数，我们在一个等距网格上离散化球面：\n- 余纬 $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta\\theta$，其中 $\\Delta\\theta = \\pi/N_{\\text{lat}}$ 且 $i = 0,\\ldots,N_{\\text{lat}}-1$。\n- 经度 $\\phi_j = j\\,\\Delta\\phi$，其中 $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$ 且 $j = 0,\\ldots,N_{\\text{lon}}-1$。\n\n在此网格上，我们使用带有面积权重 $w(\\theta_i,\\phi_j) = \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi$ 的复合中点法则来近似积分：\n$$\nc_{\\ell,m} \\approx \\sum_{i=0}^{N_{\\text{lat}}-1}\\sum_{j=0}^{N_{\\text{lon}}-1}\nf(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^{*}\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi.\n$$\n这种求积方法与球面测度一致，对于中等 $L_{\\text{trunc}}$ 的演示已经足够。\n\n我们将基准截断场重构为\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\n并将滤波后的场重构为\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n因为原始场 $f$ 是实值的，数值重构取复值和的实部。\n\n为了量化位于 $\\phi = \\pi$ 的海岸线周围的振铃，我们定义一个半宽为 $3\\Delta\\phi$ 的窄海岸带：\n$$\n\\mathcal{B} = \\left\\{(\\theta,\\phi): |\\phi - \\pi| \\le 3\\Delta\\phi\\right\\}.\n$$\n在 $\\mathcal{B}$ 内，我们测量边界违例幅度\n$$\n\\text{viol}(g) = \\max\\left( \\max_{\\mathcal{B}} \\left[g(\\theta,\\phi) - 1\\right]_{+},\\; \\max_{\\mathcal{B}} \\left[-g(\\theta,\\phi)\\right]_{+} \\right),\n$$\n其中 $[x]_{+} = \\max(x,0)$，对于 $g = \\hat{f}_{\\text{base}}$（基准）和 $g = \\hat{f}_{\\text{filt}}$（滤波后）。该度量报告了重构场在海岸线附近超过上界 $1$ 或低于下界 $0$ 的程度。\n\n算法步骤：\n\n1. 构建网格，其中 $N_{\\text{lat}} = 73$，$N_{\\text{lon}} = 144$，角度以弧度为单位，并预计算 $\\sin\\theta_i$、$\\Delta\\theta$、$\\Delta\\phi$。\n2. 定义合成海岸场 $f(\\theta,\\phi) = 1$（对于 $\\phi \\in [0,\\pi)$）和 $f(\\theta,\\phi) = 0$（对于 $\\phi \\in [\\pi,2\\pi)$）。\n3. 对于每个测试用例 $(L_{\\text{trunc}}, \\alpha)$:\n   - 通过求积计算直到阶数 $L_{\\text{trunc}}$ 的球谐系数 $c_{\\ell,m}$。\n   - 使用 $c_{\\ell,m}$ 重构 $\\hat{f}_{\\text{base}}$。\n   - 计算基准违例 $\\text{viol}(\\hat{f}_{\\text{base}})$。\n   - 应用滤波器 $G(\\ell) = \\exp(-\\alpha \\ell(\\ell+1))$ 以获得滤波后的系数 $G(\\ell)c_{\\ell,m}$。\n   - 重构 $\\hat{f}_{\\text{filt}}$ 并计算滤波后的违例 $\\text{viol}(\\hat{f}_{\\text{filt}})$。\n   - 计算质量差 $|c_{0,0}^{\\text{filtered}} - c_{0,0}|$。因为 $G(0) = 1$，该值在数值上应为零，从而证明了总质量守恒。\n4. 将每个度量四舍五入到六位小数，并按规定格式输出结果。\n\n科学真实性和预期结果：\n\n- 海岸线阶跃引入了一个不连续性，这在截断的球谐重构中会产生吉布斯振铃。指数滤波器减少了导致振荡的高阶贡献，从而降低了海岸线附近的过冲和下冲。\n- $\\alpha = 0$ 的基准情况通常表现出非零的违例，增加 $\\alpha$ 会减小违例幅度。\n- 使用大的 $\\alpha$ 进行极端平滑会使场趋近于一个常数场（0阶），从而消除边界违例，但会移除空间结构。\n- 该滤波器保持总质量，因为它不改变 $c_{0,0}$。\n\n最终的程序实现了上述计算步骤，使用矢量化评估 $Y_{\\ell}^{m}(\\theta,\\phi)$ 和求和来获得 $c_{\\ell,m}$ 及重构场，遵循以弧度为单位的角度约定，并为指定的测试套件输出单行格式正确的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef make_grid(nlat: int, nlon: int):\n    # Midpoint rule in theta to avoid poles\n    dtheta = np.pi / nlat\n    dphi = 2.0 * np.pi / nlon\n    theta = (np.arange(nlat) + 0.5) * dtheta\n    phi = np.arange(nlon) * dphi\n    TH, PH = np.meshgrid(theta, phi, indexing='ij')\n    sinTH = np.sin(TH)\n    return TH, PH, sinTH, dtheta, dphi\n\ndef synthetic_coast_field(PH):\n    # Half-sphere land-sea mask: land for phi in [0, pi), sea otherwise.\n    # Field is dimensionless: 1 for land, 0 for sea.\n    return (PH  np.pi).astype(np.float64)\n\ndef analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L):\n    # Compute spherical harmonic coefficients c_{l,m} via quadrature\n    # c_{l,m} ~ sum f * conj(Y_{l,m}) * sin(theta) * dtheta * dphi\n    coeffs = {}\n    weights = sinTH * dtheta * dphi\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)  # complex-valued\n            integrand = f * np.conj(Y) * weights\n            c = np.sum(integrand)\n            coeffs[(l, m)] = c\n    return coeffs\n\ndef reconstruct_field(coeffs, TH, PH, L):\n    # Sum c_{l,m} * Y_{l,m} over l,m to reconstruct field; take real part.\n    f_rec = np.zeros_like(TH, dtype=np.complex128)\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)\n            f_rec += coeffs[(l, m)] * Y\n    return np.real(f_rec)\n\ndef apply_filter(coeffs, alpha):\n    # Exponential Laplacian filter: G(l) = exp(-alpha * l * (l+1)), preserves l=0 exactly.\n    filtered = {}\n    for (l, m), c in coeffs.items():\n        g = np.exp(-alpha * l * (l + 1))\n        filtered[(l, m)] = c * g\n    return filtered\n\ndef coastal_band_violation(f_rec, PH, nlon, band_center=np.pi, steps=3):\n    # Band around coastline at phi = band_center with half-width steps * dphi\n    dphi = 2.0 * np.pi / nlon\n    halfwidth = steps * dphi\n    # minimal angular distance on circle\n    delta = np.abs((PH - band_center + np.pi) % (2.0 * np.pi) - np.pi)\n    mask = delta = halfwidth\n    vals = f_rec[mask]\n    if vals.size == 0:\n        return 0.0\n    above1 = np.max(vals - 1.0) if vals.size else 0.0\n    below0 = np.max(-vals) if vals.size else 0.0\n    violation = max(above1 if above1 > 0.0 else 0.0, below0 if below0 > 0.0 else 0.0)\n    return float(violation)\n\ndef format_results(results):\n    # Format as [[b1,f1,m1],[b2,f2,m2],...] with no spaces and six decimals\n    def fmt(x): return f\"{x:.6f}\"\n    inner = []\n    for r in results:\n        inner.append(\"[\" + \",\".join(fmt(v) for v in r) + \"]\")\n    return \"[\" + \",\".join(inner) + \"]\"\n\ndef solve():\n    # Define grid\n    Nlat = 73\n    Nlon = 144\n    TH, PH, sinTH, dtheta, dphi = make_grid(Nlat, Nlon)\n    f = synthetic_coast_field(PH)\n\n    # Test cases: (L_trunc, alpha)\n    test_cases = [\n        (20, 0.0),    # baseline\n        (20, 0.005),  # moderate smoothing\n        (20, 0.02),   # strong smoothing\n        (12, 0.02),   # lower truncation with smoothing\n        (20, 2.0),    # extreme smoothing\n    ]\n\n    # Cache analyses for each distinct L\n    coeffs_cache = {}\n    baseline_violation_cache = {}\n\n    results = []\n    for L, alpha in test_cases:\n        # Analyze coefficients for this L (cached)\n        if L not in coeffs_cache:\n            coeffs = analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L)\n            coeffs_cache[L] = coeffs\n        else:\n            coeffs = coeffs_cache[L]\n\n        # Baseline reconstruction (alpha = 0)\n        if L not in baseline_violation_cache:\n            f_base = reconstruct_field(coeffs, TH, PH, L)\n            bviol = coastal_band_violation(f_base, PH, Nlon)\n            baseline_violation_cache[L] = (f_base, bviol)\n        else:\n            f_base, bviol = baseline_violation_cache[L]\n\n        # Apply filter\n        filt_coeffs = apply_filter(coeffs, alpha)\n        # Mass difference via c_{0,0}\n        c00_orig = coeffs[(0, 0)]\n        c00_filt = filt_coeffs[(0, 0)]\n        mass_diff = float(np.abs(c00_filt - c00_orig))\n\n        # Filtered reconstruction\n        f_filt = reconstruct_field(filt_coeffs, TH, PH, L)\n        fviol = coastal_band_violation(f_filt, PH, Nlon)\n\n        results.append((bviol, fviol, mass_diff))\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}