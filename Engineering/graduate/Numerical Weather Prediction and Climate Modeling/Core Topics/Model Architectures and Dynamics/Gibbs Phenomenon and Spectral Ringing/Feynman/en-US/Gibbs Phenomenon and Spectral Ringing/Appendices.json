{
    "hands_on_practices": [
        {
            "introduction": "Before we can mitigate spectral ringing, we must first be able to measure it. This exercise challenges you to move beyond a qualitative visual assessment of the Gibbs phenomenon and develop a rigorous numerical diagnostic. By constructing a metric from first principles based on local oscillation energy near sharp gradients , you will gain a deeper understanding of the mathematical structure of these artifacts and build a practical tool for analyzing numerical model output.",
            "id": "4049063",
            "problem": "Consider a one-dimensional periodic domain of length $L$ measured in meters and discretized uniformly into $N$ grid points with grid spacing $dx = L/N$. Let a scalar prognostic field $f(x)$ in Kelvin be sampled on this grid as $\\{ f_n \\}_{n=0}^{N-1}$, where $f_n = f(x_n)$ and $x_n = n \\, dx$. The Gibbs phenomenon in spectral representations produces oscillatory overshoots and undershoots near discontinuities when the spectrum is truncated. The task is to define and implement a diagnostic that quantifies Gibbs oscillations by measuring local oscillation energy around detected gradient maxima, and then compute its value for a synthetic step field reconstructed from spectrally truncated data.\n\nYou must derive the diagnostic from first principles using:\n- The definition of the Discrete Fourier Transform (DFT) and its inverse on a periodic, uniformly spaced grid.\n- The relationship between truncation of high-frequency modes and oscillatory artifacts near sharp gradients.\n- Discrete calculus definitions of differences and gradients on a grid.\n\nDefine the synthetic step field as follows. For a given amplitude $A$ in Kelvin, choose an index $n_0 = \\lfloor N/2 \\rfloor$ and set\n$$\nf_n = \\begin{cases}\n0  \\text{for } n  n_0, \\\\\nA  \\text{for } n \\ge n_0.\n\\end{cases}\n$$\nFrom $f_n$, construct a spectrally truncated reconstruction $g_n$ by computing the DFT of $f_n$ and zeroing all modes with wavenumber index strictly greater than a specified cutoff $K_{\\mathrm{cut}}$. For real-valued data, you may use the Real-valued Fast Fourier Transform (FFT) implementation, but the mathematical requirement is to keep only the nonnegative wavenumber indices $k \\in \\{0,1,2,\\dots, K_{\\mathrm{cut}}\\}$ and set all higher indices to zero before inverse transforming to obtain $g_n$.\n\nOn the reconstructed field $g_n$, compute the centered discrete gradient\n$$\n(\\nabla g)_n = \\frac{g_{n+1} - g_{n-1}}{2 \\, dx},\n$$\nwith periodic indexing. Define the set of locations of gradient maxima $\\mathcal{I}$ by the condition that $(\\nabla g)_n$ is a local maximum in magnitude and exceeds a fraction $\\gamma$ of the maximum gradient magnitude in the field:\n$$\n\\mathcal{I} = \\left\\{ n \\in \\{0,\\dots,N-1\\} \\;\\middle|\\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n-1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n+1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\gamma \\, \\max_m \\left|(\\nabla g)_m\\right| \\right\\}.\n$$\n\nFor each $i \\in \\mathcal{I}$, define a neighborhood of radius $r$ grid points,\n$$\n\\mathcal{S}_i = \\{ n \\;\\mid\\; \\text{$n$ is within $r$ indices of $i$ under periodic wrap} \\},\n$$\nand within this neighborhood compute a local oscillation energy that isolates oscillatory ringing. Use the first difference\n$$\n\\delta_n = g_n - g_{n-1},\n$$\nand the second difference\n$$\n\\Delta^2 g_n = g_{n+1} - 2 g_n + g_{n-1}.\n$$\nDefine an oscillation indicator at index $n$ by\n$$\ns_n = \\begin{cases}\n1  \\text{if } \\delta_n \\cdot \\delta_{n+1}  0, \\\\\n0  \\text{otherwise},\n\\end{cases}\n$$\nwhich flags a local sign change in successive first differences (an overshoot followed by an undershoot or vice versa). The local oscillation energy around $i$ is then\n$$\nE_i = \\sum_{n \\in \\mathcal{S}_i} \\left( \\Delta^2 g_n \\right)^2 \\, s_n,\n$$\nwith units Kelvin squared. Define the overall Gibbs oscillation diagnostic as\n$$\nD = \\sum_{i \\in \\mathcal{I}} E_i,\n$$\nreported in Kelvin squared.\n\nImplement a program that:\n- Constructs the synthetic step field for specified $(N, L, A)$.\n- Performs spectral truncation using a specified fraction $s$ of the Nyquist wavenumber, meaning $K_{\\mathrm{cut}} = \\lfloor s \\cdot (N/2) \\rfloor$ and the reconstruction keeps nonnegative wavenumbers $k \\le K_{\\mathrm{cut}}$.\n- Computes the diagnostic $D$ using the above definitions, with gradient-maxima threshold fraction $\\gamma$ and neighborhood radius $r$.\n\nAnswer all outputs in units of Kelvin squared ($\\mathrm{K}^2$). Angles do not appear in this problem. The program must produce a single line of output containing a comma-separated list enclosed in square brackets with one floating-point number per test case.\n\nUse the following test suite of parameter sets to exercise the algorithm, covering typical ringing, heavy truncation, no truncation, a constant field edge case, and a small-grid boundary case:\n- Test $1$: $N = 256$, $L = 1.0$ meter, $A = 1.0$ Kelvin, $s = 0.20$, $\\gamma = 0.50$, $r = 10$.\n- Test $2$: $N = 256$, $L = 1.0$ meter, $A = 1.0$ Kelvin, $s = 0.05$, $\\gamma = 0.50$, $r = 10$.\n- Test $3$: $N = 256$, $L = 1.0$ meter, $A = 1.0$ Kelvin, $s = 1.00$, $\\gamma = 0.50$, $r = 10$.\n- Test $4$: $N = 256$, $L = 1.0$ meter, $A = 0.0$ Kelvin, $s = 0.20$, $\\gamma = 0.50$, $r = 10$.\n- Test $5$: $N = 33$, $L = 1.0$ meter, $A = 1.0$ Kelvin, $s = 0.20$, $\\gamma = 0.80$, $r = 1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[d_1,d_2,d_3,d_4,d_5]$), where each $d_j$ is the diagnostic $D$ computed for the corresponding test case.",
            "solution": "The problem requires the definition and implementation of a diagnostic, $D$, to quantify Gibbs oscillations in a spectrally truncated field. The derivation and implementation procedure are based on fundamental principles of numerical analysis, Fourier analysis, and discrete calculus.\n\nFirst, we establish the domain and the initial field. The physical domain is one-dimensional and periodic with length $L$. It is discretized into $N$ uniformly spaced grid points, $\\{x_n\\}_{n=0}^{N-1}$, with grid spacing $dx = L/N$, where $x_n = n \\, dx$. On this grid, we define a synthetic step field, $f_n$, with an amplitude $A$ in Kelvin. The discontinuity is placed at the grid index $n_0 = \\lfloor N/2 \\rfloor$:\n$$\nf_n = \\begin{cases}\n0  \\text{for } n  n_0, \\\\\nA  \\text{for } n \\ge n_0.\n\\end{cases}\n$$\nThis field $f_n$ represents an idealized sharp gradient, which is prone to producing Gibbs oscillations when its spectral representation is truncated.\n\nThe core of the Gibbs phenomenon lies in the approximation of a discontinuous function using a truncated Fourier series. To simulate this, we perform a spectral truncation on the field $f_n$. We first compute its Discrete Fourier Transform (DFT), which decomposes the function into a sum of complex sinusoids of different wavenumbers. The DFT coefficients, or spectrum, $\\hat{f}_k$, are given by:\n$$\n\\hat{f}_k = \\sum_{n=0}^{N-1} f_n \\, e^{-2\\pi i k n / N} \\quad \\text{for } k = 0, 1, \\dots, N-1.\n$$\nSince the input field $f_n$ is real-valued, its spectrum exhibits conjugate symmetry, $\\hat{f}_{N-k} = \\overline{\\hat{f}_k}$. This property allows for the use of a Real Fast Fourier Transform (RFFT) algorithm, which is computationally more efficient as it only computes the unique spectral coefficients for non-negative wavenumbers, typically for $k=0, 1, \\dots, \\lfloor N/2 \\rfloor$.\n\nSpectral truncation involves creating a new spectrum, $\\hat{g}_k$, by setting high-wavenumber coefficients of $\\hat{f}_k$ to zero. The problem specifies a cutoff wavenumber index $K_{\\mathrm{cut}} = \\lfloor s \\cdot (N/2) \\rfloor$, where $s$ is a given truncation fraction. The truncated spectrum $\\hat{g}_k$ is defined as:\n$$\n\\hat{g}_k = \\begin{cases}\n\\hat{f}_k  \\text{for non-negative } k \\le K_{\\mathrm{cut}}, \\\\\n0        \\text{for non-negative } k > K_{\\mathrm{cut}}.\n\\end{cases}\n$$\nWhen using a full complex DFT, this truncation must be mirrored for the negative wavenumbers to ensure the resulting field is real. When using an RFFT, this corresponds to setting coefficients with indices greater than $K_{\\mathrm{cut}}$ to zero in the output array. The reconstructed field, $g_n$, is then obtained by applying the inverse DFT (or inverse RFFT) to the truncated spectrum $\\hat{g}_k$:\n$$\ng_n = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{g}_k \\, e^{2\\pi i k n / N}.\n$$\nThis field $g_n$ is a smooth approximation of $f_n$ and will exhibit the characteristic oscillatory overshoots and undershoots of the Gibbs phenomenon near the discontinuity at $n_0$.\n\nNext, we formulate the diagnostic $D$ to quantify these oscillations. The diagnostic is designed to measure oscillation energy specifically in the vicinity of sharp gradients. We first locate these regions by computing the centered discrete gradient of the reconstructed field $g_n$:\n$$\n(\\nabla g)_n = \\frac{g_{n+1} - g_{n-1}}{2 \\, dx}.\n$$\nThe indices $n-1$ and $n+1$ are handled using periodic boundary conditions, meaning $g_{-1} = g_{N-1}$ and $g_N = g_0$. We then identify the set of indices $\\mathcal{I}$ corresponding to local maxima in the gradient's magnitude that are also prominent relative to the field's overall maximum gradient:\n$$\n\\mathcal{I} = \\left\\{ n \\in \\{0,\\dots,N-1\\} \\;\\middle|\\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n-1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n+1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\gamma \\, \\max_m \\left|(\\nabla g)_m\\right| \\right\\}.\n$$\nHere, $\\gamma$ is a specified threshold fraction. This definition effectively pinpoints the locations where the Gibbs oscillations are centered.\n\nFor each identified gradient peak $i \\in \\mathcal{I}$, we define a local neighborhood $\\mathcal{S}_i$ of radius $r$ grid points:\n$$\n\\mathcal{S}_i = \\{ n \\;\\mid\\; (n - i) \\pmod N \\text{ is in } [-r, r] \\}.\n$$\nThis set contains the $2r+1$ grid points centered on $i$, with periodic wrapping around the domain boundaries.\n\nWithin these neighborhoods, we measure the oscillatory content. The diagnostic uses two key discrete difference operators. The first difference,\n$$\n\\delta_n = g_n - g_{n-1},\n$$\napproximates the local slope. A change in the sign of the slope indicates an extremum (a crest or a trough of an oscillation). This is captured by the oscillation indicator $s_n$:\n$$\ns_n = \\begin{cases}\n1  \\text{if } \\delta_n \\cdot \\delta_{n+1}  0, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nThis indicator $s_n$ is non-zero only at grid points that represent a local extremum. The magnitude of the oscillation is quantified using the second difference, which approximates the curvature of the field:\n$$\n\\Delta^2 g_n = g_{n+1} - 2 g_n + g_{n-1}.\n$$\nThe local oscillation energy, $E_i$, for each gradient peak $i$ is defined as the sum of the squared second differences, weighted by the oscillation indicator $s_n$, over the neighborhood $\\mathcal{S}_i$:\n$$\nE_i = \\sum_{n \\in \\mathcal{S}_i} \\left( \\Delta^2 g_n \\right)^2 \\, s_n.\n$$\nThe units of $E_i$ are Kelvin squared ($\\mathrm{K}^2$). This metric sums the \"wiggliness\" (squared curvature) only at the points of oscillation within the high-gradient region.\n\nFinally, the total Gibbs oscillation diagnostic, $D$, is the sum of the local oscillation energies over all identified high-gradient regions:\n$$\nD = \\sum_{i \\in \\mathcal{I}} E_i.\n$$\nA larger value of $D$ indicates more pronounced Gibbs oscillations in the field.\n\nThe computational algorithm proceeds as follows:\n$1$. For a given set of parameters $(N, L, A, s, \\gamma, r)$, construct the initial step field $f_n$.\n$2$. Compute the RFFT of $f_n$ to obtain the spectrum $\\hat{f}_{\\mathrm{rfft}}$.\n$3$. Determine the cutoff index $K_{\\mathrm{cut}} = \\lfloor s \\cdot (N/2) \\rfloor$.\n$4$. Create the truncated spectrum $\\hat{g}_{\\mathrm{rfft}}$ by setting to zero all elements of $\\hat{f}_{\\mathrm{rfft}}$ with an index greater than $K_{\\mathrm{cut}}$.\n$5$. Compute the reconstructed field $g_n$ via the inverse RFFT of $\\hat{g}_{\\mathrm{rfft}}$.\n$6$. Calculate the discrete gradient $(\\nabla g)_n$ using periodic boundaries.\n$7$. Identify the set of gradient maxima indices $\\mathcal{I}$ based on the local maximum and threshold conditions. If this set is empty, $D=0$.\n$8$. For each index $i \\in \\mathcal{I}$, compute the local oscillation energy $E_i$ by summing $(\\Delta^2 g_n)^2 s_n$ over the neighborhood $\\mathcal{S}_i$.\n$9$. Sum all $E_i$ to obtain the final diagnostic $D$.\nThis procedure is applied to each test case to produce the required results.",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (N, L, A, s, gamma, r)\n        (256, 1.0, 1.0, 0.20, 0.50, 10),  # Test 1: Typical ringing\n        (256, 1.0, 1.0, 0.05, 0.50, 10),  # Test 2: Heavy truncation\n        (256, 1.0, 1.0, 1.00, 0.50, 10),  # Test 3: No truncation\n        (256, 1.0, 0.0, 0.20, 0.50, 10),  # Test 4: Constant field\n        (33, 1.0, 1.0, 0.20, 0.80, 1),   # Test 5: Small-grid boundary case\n    ]\n\n    results = []\n    for case in test_cases:\n        diagnostic = compute_diagnostic(*case)\n        results.append(diagnostic)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_diagnostic(N, L, A, s, gamma, r):\n    \"\"\"\n    Computes the Gibbs oscillation diagnostic D for a given set of parameters.\n\n    Args:\n        N (int): Number of grid points.\n        L (float): Length of the periodic domain in meters.\n        A (float): Amplitude of the step field in Kelvin.\n        s (float): Truncation fraction of the Nyquist wavenumber.\n        gamma (float): Gradient-maxima threshold fraction.\n        r (int): Neighborhood radius in grid points.\n\n    Returns:\n        float: The computed diagnostic D in Kelvin^2.\n    \"\"\"\n    # 1. Grid and Initial Field Setup\n    dx = L / N\n    n_0 = int(np.floor(N / 2))\n    \n    f_n = np.zeros(N)\n    if A != 0:\n        f_n[n_0:] = A\n\n    # 2. Spectral Truncation\n    # Using scipy.fft which is a newer and recommended API over numpy.fft\n    f_hat = fft.rfft(f_n)\n    K_cut = int(np.floor(s * (N / 2)))\n    \n    g_hat = f_hat.copy()\n    # Zero out modes with wavenumber index > K_cut\n    g_hat[K_cut + 1:] = 0\n    \n    g_n = fft.irfft(g_hat, n=N)\n\n    # 3. Compute Centered Discrete Gradient\n    g_plus_1 = np.roll(g_n, -1)\n    g_minus_1 = np.roll(g_n, 1)\n    grad_g = (g_plus_1 - g_minus_1) / (2 * dx)\n\n    # 4. Identify Gradient Maxima Locations\n    abs_grad_g = np.abs(grad_g)\n    max_grad_mag = np.max(abs_grad_g)\n\n    # Handle edge case of a constant field (e.g., A=0)\n    if max_grad_mag == 0:\n        return 0.0\n\n    grad_mag_plus_1 = np.roll(abs_grad_g, -1)\n    grad_mag_minus_1 = np.roll(abs_grad_g, 1)\n\n    is_local_max = (abs_grad_g >= grad_mag_minus_1)  (abs_grad_g >= grad_mag_plus_1)\n    is_above_thresh = (abs_grad_g >= gamma * max_grad_mag)\n    \n    I_indices = np.where(is_local_max  is_above_thresh)[0]\n    \n    if len(I_indices) == 0:\n        return 0.0\n\n    # 5. Compute Oscillation Indicator and Second Difference\n    # First difference: delta_n = g_n - g_{n-1}\n    delta_g = g_n - g_minus_1\n    # First difference at n+1: delta_{n+1}\n    delta_g_plus_1 = np.roll(delta_g, -1)\n    \n    # Oscillation indicator: s_n = 1 if delta_n * delta_{n+1}  0\n    s_n = (delta_g * delta_g_plus_1)  0\n\n    # Second difference: Delta^2 g_n = g_{n+1} - 2*g_n + g_{n-1}\n    delta2_g = g_plus_1 - 2 * g_n + g_minus_1\n    \n    # Term to be summed: (Delta^2 g_n)^2 * s_n\n    summand = (delta2_g ** 2) * s_n.astype(int)\n\n    # 6. Compute Total Diagnostic D\n    total_D = 0.0\n    for i in I_indices:\n        # Define neighborhood S_i: indices from i-r to i+r (periodic)\n        neighborhood_indices = (np.arange(i - r, i + r + 1)) % N\n        \n        # Compute local energy E_i\n        E_i = np.sum(summand[neighborhood_indices])\n        total_D += E_i\n        \n    return total_D\n\nsolve()\n```"
        },
        {
            "introduction": "Spectral models in operational use employ filters to control Gibbs oscillations. In this practice, you will implement one of the most common methods, hyperdiffusion, on an idealized baroclinic jet profile. Your task is to quantify the fundamental trade-off: while hyperdiffusion effectively suppresses spurious ringing, it can also excessively smooth sharp, physically important gradients . This exercise provides direct experience with the delicate balancing act that is central to designing robust numerical weather prediction and climate models.",
            "id": "4049043",
            "problem": "Consider a periodic meridional slice of an idealized baroclinic jet represented by a zonal wind speed field $u(y)$ over the domain $y \\in [0, 2\\pi)$, with $y$ measured in radians. The jet has a plateau of nearly constant wind speed bounded by two sharp fronts. The purpose of this exercise is to demonstrate how spectral ringing arising from Fourier truncation (the Gibbs phenomenon) is mitigated by hyperdiffusion, and to quantify the trade-off between ringing mitigation and gradient fidelity in a controlled numerical experiment that is aligned with numerical weather prediction and climate modeling practice.\n\nStarting from the following fundamental bases:\n\n- The Discrete Fourier Transform (DFT) and its inverse provide a bijective transform between a periodic function and its spectral coefficients. The DFT maps spatial variations into wavenumber space and supports exact differentiation via multiplication by the wavenumber.\n- The Fast Fourier Transform (FFT) is an algorithm to compute the DFT efficiently.\n- A spectral atmospheric model can be idealized as using a truncated Fourier representation, retaining only wavenumbers $|k| \\le k_c$, which introduces spectral ringing near sharp gradients due to the Gibbs phenomenon.\n- Hyperdiffusion is modeled in continuous time by the linear partial differential equation $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$, with hyperdiffusion order $p \\in \\mathbb{N}$ and coefficient $\\nu  0$. This operator preferentially damps high-wavenumber components to mitigate ringing.\n\nDefine the idealized jet profile on $N$ equally spaced points using\n$$\nu_{\\text{true}}(y) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_2}{w}\\right)\\right],\n$$\nwhere $U_0$ is the jet plateau speed in meters per second, $y_1 = y_0 - \\Delta$, $y_2 = y_0 + \\Delta$, $y_0=\\pi$, $\\Delta$ is the half-width of the jet in radians, and $w$ is the sharpness parameter (in radians) that determines the frontal steepness. The discrete grid is $y_j = 2\\pi j/N$ for $j=0,\\dots,N-1$.\n\nLet $\\widehat{u}(k)$ denote the DFT of $u(y)$ on this grid, with wavenumbers $k$ represented as integer multiples consistent with the $2\\pi$-periodicity. Truncated spectral representation sets $\\widehat{u}(k)=0$ for $|k|k_c$, where $k_c$ is the resolution cutoff. Hyperdiffusion should be applied in spectral space for a unit nondimensional time step to the truncated representation according to the continuous-time model above, interpreted as a spectral damping of retained modes. You must not use any formula stated in this problem to bypass derivation; all steps must follow logically from the bases given.\n\nDefine two quantitative metrics:\n\n1. Ringing amplitude $R$: The largest excursion of the reconstructed field outside the physically plausible range $\\left[0, U_0\\right]$, normalized by $U_0$,\n$$\nR = \\frac{1}{U_0}\\max\\left\\{\\max_{y}\\left(u(y)-U_0\\right)_+, \\max_{y}\\left(-u(y)\\right)_+\\right\\},\n$$\nwhere $(x)_+ = \\max(x,0)$ and $u(y)$ is the reconstructed field after truncation and hyperdiffusion. This metric is dimensionless.\n\n2. Gradient fidelity error $E$: The relative $\\ell^2$ error of the meridional gradient compared to the true field,\n$$\nE = \\frac{\\left\\|\\partial_y u(y) - \\partial_y u_{\\text{true}}(y)\\right\\|_2}{\\left\\|\\partial_y u_{\\text{true}}(y)\\right\\|_2},\n$$\nwhere derivatives are computed spectrally and the $\\ell^2$ norm is taken over the discrete grid. This metric is dimensionless.\n\nYour program must:\n\n- Construct $u_{\\text{true}}(y)$ on a periodic grid using the parameters below.\n- Compute its DFT, perform truncation at $|k| \\le k_c$, and then apply hyperdiffusion in spectral space consistently with $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$ for a unit nondimensional time step.\n- Reconstruct the field by inverse DFT and compute $R$ and $E$ as defined above.\n\nUse the following scientifically realistic parameter values to create a test suite that exercises the trade-off:\n\n- Grid size: $N = 2048$.\n- Plateau speed: $U_0 = 40$ meters per second.\n- Jet parameters: $\\Delta = 0.7$ radians, $w = 0.02$ radians, $y_0 = \\pi$.\n- Spectral cutoff: $k_c = 128$.\n- Hyperdiffusion test cases, expressed as pairs $(\\alpha, p)$, where $\\alpha$ is a nondimensional strength parameter and $p$ is the hyperdiffusion order:\n  1. Case 1 (boundary, no hyperdiffusion): $(\\alpha, p) = (0.0, 4)$.\n  2. Case 2 (moderate mitigation): $(\\alpha, p) = (0.4, 4)$.\n  3. Case 3 (strong hyperdiffusion): $(\\alpha, p) = (3.0, 4)$.\n  4. Case 4 (high-order hyperdiffusion): $(\\alpha, p) = (1.0, 8)$.\n\nAll angles must be in radians. All speeds are in meters per second, but the outputs are dimensionless and need no unit conversions.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n\\left[R_1, E_1, R_2, E_2, R_3, E_3, R_4, E_4\\right],\n$$\nwhere $R_i$ and $E_i$ correspond to Case $i$.\n\nThe program must be complete and runnable as provided, with no user input, and it must use only the Python standard library and the specified numerical libraries. The output values must be $\\text{float}$s. The design should ensure scientific realism and internal consistency, and each test case must lead to a deterministic numerical result.",
            "solution": "The problem requires a numerical simulation to quantify the trade-off between mitigating spectral ringing (Gibbs phenomenon) and preserving gradient fidelity when using hyperdiffusion in a spectral model of an idealized atmospheric jet. The solution involves discretizing the jet profile, transforming it to spectral space using the Fast Fourier Transform (FFT), applying spectral truncation and a hyperdiffusion operator, transforming back to physical space, and finally computing two specified metrics: ringing amplitude $R$ and gradient fidelity error $E$.\n\nFirst, we establish the computational domain and the true state. The idealized jet profile $u_{\\text{true}}(y)$ is defined on a periodic domain $y \\in [0, 2\\pi)$. We discretize this domain using $N=2048$ equally spaced points, $y_j = 2\\pi j/N$ for $j = 0, \\dots, N-1$. The true velocity field on this grid is computed using the given formula:\n$$\nu_{\\text{true}}(y_j) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_2}{w}\\right)\\right]\n$$\nwith parameters $U_0=40$, $y_0=\\pi$, $\\Delta=0.7$, $w=0.02$, $y_1=y_0-\\Delta$, and $y_2=y_0+\\Delta$. The sharpness parameter $w$ is small, creating sharp gradients that will induce strong Gibbs ringing upon spectral truncation.\n\nThe core of the method is in spectral space. We use the Discrete Fourier Transform (DFT), computed via the FFT algorithm, to obtain the spectral coefficients $\\widehat{u}_{\\text{true}}(k)$ of the discrete field $u_{\\text{true}}(y_j)$. The corresponding integer wavenumbers $k$ are obtained for the $N$-point grid on a $2\\pi$ domain. The derivative operator $\\partial_y$ in physical space corresponds to multiplication by $ik$ in spectral space, where $i = \\sqrt{-1}$. This property is used to compute all spatial derivatives.\n\nThe numerical simulation for each test case $(\\alpha, p)$ follows a precise sequence of steps:\n\n1.  **Spectral Truncation**: The true spectrum $\\widehat{u}_{\\text{true}}(k)$ is truncated by setting all coefficients for which the absolute value of the wavenumber $|k|$ exceeds the cutoff $k_c=128$ to zero. This simulates a finite-resolution spectral model. Let the resulting truncated spectrum be $\\widehat{u}_{\\text{trunc}}(k)$:\n    $$\n    \\widehat{u}_{\\text{trunc}}(k) = \\begin{cases} \\widehat{u}_{\\text{true}}(k)  \\text{if } |k| \\le k_c \\\\ 0  \\text{if } |k|  k_c \\end{cases}\n    $$\n    This abrupt truncation is the source of the Gibbs phenomenon. Case 1, with no hyperdiffusion ($\\alpha=0$), isolates the effect of truncation alone.\n\n2.  **Hyperdiffusion Damping**: Hyperdiffusion is applied to the truncated spectrum to damp the high-wavenumber oscillations. The governing continuous equation is $u_t = -\\nu(-\\partial_y^2)^p u$. In spectral space, this becomes an ordinary differential equation for each spectral coefficient $\\widehat{u}(k)$:\n    $$\n    \\frac{d\\widehat{u}(k, t)}{dt} = -\\nu (k^2)^p \\widehat{u}(k, t) = -\\nu k^{2p} \\widehat{u}(k, t)\n    $$\n    The solution over a unit nondimensional time step ($t=1$) is $\\widehat{u}(k, 1) = \\widehat{u}(k, 0) \\exp(-\\nu k^{2p})$. The problem provides a non-dimensional strength parameter $\\alpha$ rather than the coefficient $\\nu$. Following standard practice in numerical weather prediction, we associate $\\alpha$ with the damping strength at the truncation wavenumber $k_c$. We set the exponent of the damping factor at $|k|=k_c$ to be $-\\alpha$. This yields the relationship $\\nu k_c^{2p} = \\alpha$, so $\\nu = \\alpha/k_c^{2p}$. The damping factor $D(k)$ applied to any retained mode ($|k| \\le k_c$) is therefore:\n    $$\n    D(k) = \\exp\\left(-\\frac{\\alpha}{k_c^{2p}} k^{2p}\\right) = \\exp\\left[-\\alpha \\left(\\frac{|k|}{k_c}\\right)^{2p}\\right]\n    $$\n    This factor is multiplied by the truncated spectral coefficients to get the final spectrum, $\\widehat{u}_{\\text{final}}(k) = \\widehat{u}_{\\text{trunc}}(k) D(k)$. For $\\alpha=0$, $D(k)=1$, corresponding to no diffusion.\n\n3.  **Reconstruction**: The final physical field, $u(y)$, is reconstructed by applying the inverse DFT (via the IFFT algorithm) to $\\widehat{u}_{\\text{final}}(k)$. As the initial field is real, we take the real part of the result to discard any minor imaginary components arising from floating-point error.\n\nAfter obtaining the final field $u(y)$ for a given test case, we compute the two metrics:\n\n1.  **Ringing Amplitude ($R$)**: This metric quantifies unphysical oscillations. It is the maximum deviation of the computed field $u(y)$ outside the physically expected range $[0, U_0]$, normalized by the jet speed $U_0$. On the discrete grid, it is calculated as:\n    $$\n    R = \\frac{1}{U_0} \\max\\left\\{ \\max_j\\left( \\max(u(y_j)-U_0, 0) \\right), \\max_j\\left( \\max(-u(y_j), 0) \\right) \\right\\}\n    $$\n\n2.  **Gradient Fidelity Error ($E$)**: This metric measures the degradation of the physically important sharp fronts. It is the relative $\\ell^2$ error of the gradient of the final field with respect to the gradient of the true field. Both gradients are computed spectrally for consistency and accuracy. The gradient of the true field, $\\partial_y u_{\\text{true}}(y)$, is found by taking the inverse DFT of $ik\\widehat{u}_{\\text{true}}(k)$. Similarly, the gradient of the final field, $\\partial_y u(y)$, is the inverse DFT of $ik\\widehat{u}_{\\text{final}}(k)$. The error $E$ is then:\n    $$\n    E = \\frac{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u(y_j) - \\partial_y u_{\\text{true}}(y_j)|^2}}{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u_{\\text{true}}(y_j)|^2}} = \\frac{\\|\\partial_y u - \\partial_y u_{\\text{true}}\\|_2}{\\|\\partial_y u_{\\text{true}}\\|_2}\n    $$\nThe denominator, $\\|\\partial_y u_{\\text{true}}\\|_2$, is computed once from the full, non-truncated true spectrum to serve as a constant reference. The numerator is computed for each test case. This procedure is systematically applied to all four test cases to generate the required output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes ringing and gradient error metrics for a spectral model\n    of an idealized jet with hyperdiffusion.\n    \"\"\"\n    # Define physical and numerical parameters\n    N = 2048\n    U0 = 40.0\n    delta = 0.7\n    w = 0.02\n    y0 = np.pi\n    kc = 128\n\n    # Define the hyperdiffusion test cases (alpha, p)\n    test_cases = [\n        (0.0, 4),  # Case 1: No hyperdiffusion\n        (0.4, 4),  # Case 2: Moderate hyperdiffusion\n        (3.0, 4),  # Case 3: Strong hyperdiffusion\n        (1.0, 8),  # Case 4: High-order hyperdiffusion\n    ]\n\n    # Create the spatial grid\n    y = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # Define the true jet profile\n    y1 = y0 - delta\n    y2 = y0 + delta\n    u_true = (U0 / 2.0) * (1.0 + np.tanh((y - y1) / w)) - \\\n             (U0 / 2.0) * (1.0 + np.tanh((y - y2) / w))\n\n    # Compute spectral representation of the true field and its gradient\n    # Wavenumbers k for a 2*pi periodic domain\n    k = np.fft.fftfreq(N) * N\n    u_true_hat = np.fft.fft(u_true)\n\n    # Compute the true gradient spectrally for the error metric denominator\n    grad_u_true_hat = 1j * k * u_true_hat\n    grad_u_true = np.real(np.fft.ifft(grad_u_true_hat))\n    norm_grad_u_true = np.linalg.norm(grad_u_true)\n\n    results = []\n\n    # Process each test case\n    for alpha, p in test_cases:\n        # Step 1: Spectral Truncation\n        # Create a copy to modify\n        u_final_hat = u_true_hat.copy()\n        # Apply sharp cutoff by zeroing out coefficients where |k| > kc\n        u_final_hat[np.abs(k) > kc] = 0.0\n\n        # Step 2: Apply Hyperdiffusion\n        if alpha > 0.0:\n            # We only need to compute and apply damping to the retained modes |k| = kc\n            # Find indices of modes to be damped\n            indices_to_damp = np.where(np.abs(k) = kc)[0]\n            k_to_damp = k[indices_to_damp]\n\n            # Calculate damping factor for these modes\n            # ratios = |k|/kc\n            ratios = np.abs(k_to_damp) / kc\n            # D(k) = exp(-alpha * (|k|/kc)^(2p))\n            dampers = np.exp(-alpha * (ratios**(2 * p)))\n            \n            # Apply the damping factor to the truncated spectrum\n            u_final_hat[indices_to_damp] *= dampers\n\n        # Step 3: Reconstruct the physical field\n        u_final = np.real(np.fft.ifft(u_final_hat))\n\n        # --- Compute Metrics ---\n\n        # Metric 1: Ringing amplitude (R)\n        overshoot = np.maximum(u_final - U0, 0)\n        undershoot = np.maximum(-u_final, 0)\n        R = np.maximum(np.max(overshoot), np.max(undershoot)) / U0\n        results.append(R)\n\n        # Metric 2: Gradient fidelity error (E)\n        # Gradient of the final field is computed from its spectrum u_final_hat\n        grad_u_final_hat = 1j * k * u_final_hat\n        grad_u_final = np.real(np.fft.ifft(grad_u_final_hat))\n        \n        # Calculate L2 norm of the gradient difference\n        grad_diff = grad_u_final - grad_u_true\n        norm_grad_diff = np.linalg.norm(grad_diff)\n        \n        # Calculate relative error E\n        E = norm_grad_diff / norm_grad_u_true\n        results.append(E)\n\n    # Format and print final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The principles of spectral filtering must be adapted to the spherical geometry of our planet. This final practice elevates the challenge from a 1D periodic domain to a full global field represented by spherical harmonics. You will design and implement a high-degree filter that not only mitigates Gibbs ringing around a synthetic coastline but also respects a crucial physical constraint: the conservation of total mass . Mastering this task is a key step toward understanding the numerical core of modern global climate models.",
            "id": "4049060",
            "problem": "You are asked to design and evaluate a spectral filter on the sphere that reduces Gibbs phenomenon (spectral ringing) in a global field while preserving the total mass. The setting is Numerical Weather Prediction (NWP) and climate modeling, where global fields are commonly represented on the sphere using spherical harmonics. Your program must implement a self-contained spherical harmonic analysis and synthesis of a synthetic global field that exhibits a coastline-like discontinuity, apply a mass-preserving high-degree suppression filter, and quantify ringing reduction.\n\nYou must start from the following fundamental base, expressed in purely mathematical terms:\n\n- The spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ form an orthonormal basis on the unit sphere with respect to the surface area element $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$, where $\\theta \\in [0,\\pi]$ is the colatitude in radians and $\\phi \\in [0,2\\pi)$ is the longitude in radians. Orthonormality means\n$$\n\\int_{0}^{\\pi}\\int_{0}^{2\\pi} Y_{\\ell}^{m}(\\theta,\\phi)\\, Y_{\\ell'}^{m'}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}.\n$$\n- Any square-integrable scalar field $f(\\theta,\\phi)$ on the sphere admits the expansion\n$$\nf(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\nwith spherical harmonic coefficients\n$$\nc_{\\ell,m} \\;=\\; \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\n- Gibbs phenomenon arises when representing discontinuous functions via truncated spectral expansions; high-degree modes produce oscillatory overshoots near the discontinuity that do not vanish with truncation but are mitigated by appropriate filtering of high-degree modes.\n\nDesign objectives and constraints:\n\n1. Propose a filter on spherical harmonic coefficients $c_{\\ell,m}$ that suppresses high-degree modes while preserving total mass. The total mass of $f(\\theta,\\phi)$ over the unit sphere is proportional to the degree-$0$, order-$0$ coefficient $c_{0,0}$ because $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$. Your filter must satisfy $G(0) = 1$ so that $c_{0,0}$ is unmodified.\n2. Implement a numerical spherical harmonic analysis and synthesis using discrete quadrature with weights $w(\\theta,\\phi) = \\sin\\theta\\, \\Delta\\theta\\, \\Delta\\phi$ on an equally spaced latitude-longitude grid. Angles must be in radians.\n3. Construct a synthetic global climate field with coastline-like discontinuity by defining a land-sea mask $f(\\theta,\\phi)$ equal to $1$ for longitudes $\\phi \\in [0,\\pi)$ (the \"land\" half-sphere) and $0$ for $\\phi \\in [\\pi,2\\pi)$ (the \"sea\" half-sphere). This field exhibits a meridional coastline at $\\phi = \\pi$.\n4. Quantify ringing around the coastline by computing the maximum bound violation within a narrow coastal band, defined as the maximum of the positive overshoot above $1$ and the magnitude of the negative undershoot below $0$ of the reconstructed field within the band $\\{(\\theta,\\phi): |\\phi-\\pi| \\leq 3\\Delta\\phi\\}$, where $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$. This metric is a nonnegative float.\n5. Demonstrate mass preservation by computing the absolute difference $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$. This quantity must be reported as a float and should be numerically very small (ideally zero) if $G(0)=1$ is enforced.\n\nYou must implement the following filter specification and reconstruction protocol:\n\n- Define the filter transfer function $G(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right)$ with dimensionless parameter $\\alpha \\ge 0$. This function satisfies $G(0)=1$ and monotonically decreases with $\\ell$, strongly damping high-degree modes while leaving the total mass unchanged.\n- For a given truncation degree $L_{\\text{trunc}}$, compute $c_{\\ell,m}$ for $0 \\le \\ell \\le L_{\\text{trunc}}$, $-\\ell \\le m \\le \\ell$ using the discrete quadrature sum\n$$\nc_{\\ell,m} \\;\\approx\\; \\sum_{i=1}^{N_{\\text{lat}}}\\sum_{j=1}^{N_{\\text{lon}}} f(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^{*}\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi,\n$$\nwhere the grid is $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\,\\Delta\\theta$ for $i = 0,\\ldots,N_{\\text{lat}}-1$, and $\\phi_j = j\\, \\Delta\\phi$ for $j = 0,\\ldots,N_{\\text{lon}}-1$, with $\\Delta\\theta = \\pi/N_{\\text{lat}}$, $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$.\n- Reconstruct the baseline truncated field\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\nand the filtered field\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n\nPhysical and numerical units:\n\n- All angles $\\theta$ and $\\phi$ must be in radians.\n- The field $f(\\theta,\\phi)$ is dimensionless.\n\nTest suite:\n\nUse an equally spaced grid with $N_{\\text{lat}} = 73$ and $N_{\\text{lon}} = 144$. Evaluate the following five parameter sets, each defined by a pair $(L_{\\text{trunc}}, \\alpha)$:\n\n- Case $1$: $(L_{\\text{trunc}}, \\alpha) = (20, 0.0)$, baseline with no filtering.\n- Case $2$: $(L_{\\text{trunc}}, \\alpha) = (20, 0.005)$, moderate smoothing.\n- Case $3$: $(L_{\\text{trunc}}, \\alpha) = (20, 0.02)$, strong smoothing.\n- Case $4$: $(L_{\\text{trunc}}, \\alpha) = (12, 0.02)$, lower truncation with smoothing.\n- Case $5$: $(L_{\\text{trunc}}, \\alpha) = (20, 2.0)$, extreme smoothing approximating degree-$0$ preservation only.\n\nFor each case, compute three floats:\n- The baseline bound-violation amplitude using the same $L_{\\text{trunc}}$ but with $\\alpha = 0$ (i.e., no filtering).\n- The filtered bound-violation amplitude using the specified $\\alpha$.\n- The absolute mass difference $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list of five inner lists, each inner list in the form $[b,f,m]$ where $b$ is the baseline bound-violation amplitude, $f$ is the filtered bound-violation amplitude, and $m$ is the absolute mass difference. Numbers must be rounded to six decimal places. The final printed line must have no spaces, for example:\n\"[[b1,f1,m1],[b2,f2,m2],[b3,f3,m3],[b4,f4,m4],[b5,f5,m5]]\".",
            "solution": "We begin from the orthonormality of spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ on the unit sphere with respect to the surface element $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$. For any square-integrable field $f(\\theta,\\phi)$, the spherical harmonic coefficients are\n$$\nc_{\\ell,m} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi,\n$$\nand the spectral reconstruction is\n$$\nf(\\theta,\\phi) = \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\nIn numerical weather prediction and climate modeling, truncation at degree $L_{\\text{trunc}}$ is standard:\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\nHowever, truncation alone retains high-degree contributions up to $\\ell=L_{\\text{trunc}}$, which leads to Gibbs phenomenon near discontinuities such as coastlines, seen as oscillatory overshoot beyond the physical bounds. A mitigation is spectral filtering of high-degree modes.\n\nWe propose the Laplacian-based exponential filter\n$$\nG(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right),\n$$\nwhere $\\alpha \\ge 0$ is dimensionless. This filter satisfies $G(0) = 1$, preserving the degree-$0$ mode. Because $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$ is constant, the spherical harmonic coefficient $c_{0,0}$ is proportional to the global mass (integral) of $f$:\n$$\nc_{0,0} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{0}^{0}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi\n= \\sqrt{\\frac{1}{4\\pi}} \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\nSince $G(0) = 1$, the filtered coefficient $c_{0,0}^{\\text{filtered}} = G(0)\\, c_{0,0} = c_{0,0}$, and the total mass is exactly preserved in spectral space.\n\nTo compute coefficients numerically, we discretize the sphere on an equally spaced grid:\n- Colatitudes $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta\\theta$, where $\\Delta\\theta = \\pi/N_{\\text{lat}}$ and $i = 0,\\ldots,N_{\\text{lat}}-1$.\n- Longitudes $\\phi_j = j\\,\\Delta\\phi$, where $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$ and $j = 0,\\ldots,N_{\\text{lon}}-1$.\n\nOn this grid, we approximate the integral using the composite midpoint rule with area weights $w(\\theta_i,\\phi_j) = \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi$:\n$$\nc_{\\ell,m} \\approx \\sum_{i=0}^{N_{\\text{lat}}-1}\\sum_{j=0}^{N_{\\text{lon}}-1}\nf(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^{*}\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi.\n$$\nThis quadrature is consistent with the spherical measure and is sufficient for demonstration at moderate $L_{\\text{trunc}}$.\n\nWe reconstruct the baseline truncated field as\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\nand the filtered field as\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\nBecause the original field $f$ is real-valued, numerical reconstruction is taken as the real part of the complex-valued sum.\n\nTo quantify ringing around the coastline located at $\\phi = \\pi$, we define a narrow coastal band of half-width $3\\Delta\\phi$:\n$$\n\\mathcal{B} = \\left\\{(\\theta,\\phi): |\\phi - \\pi| \\le 3\\Delta\\phi\\right\\}.\n$$\nWithin $\\mathcal{B}$, we measure bound-violation amplitude\n$$\n\\text{viol}(g) = \\max\\left( \\max_{\\mathcal{B}} \\left[g(\\theta,\\phi) - 1\\right]_{+},\\; \\max_{\\mathcal{B}} \\left[-g(\\theta,\\phi)\\right]_{+} \\right),\n$$\nwhere $[x]_{+} = \\max(x,0)$, for $g = \\hat{f}_{\\text{base}}$ (baseline) and $g = \\hat{f}_{\\text{filt}}$ (filtered). This metric reports how much the reconstructed field overshoots above the upper bound $1$ or undershoots below the lower bound $0$ near the coastline.\n\nAlgorithmic steps:\n\n1. Construct the grid with $N_{\\text{lat}} = 73$, $N_{\\text{lon}} = 144$, angles in radians, and precompute $\\sin\\theta_i$, $\\Delta\\theta$, $\\Delta\\phi$.\n2. Define the synthetic coast field $f(\\theta,\\phi) = 1$ for $\\phi \\in [0,\\pi)$ and $f(\\theta,\\phi) = 0$ for $\\phi \\in [\\pi,2\\pi)$.\n3. For each test case $(L_{\\text{trunc}}, \\alpha)$:\n   - Compute spherical harmonic coefficients $c_{\\ell,m}$ up to degree $L_{\\text{trunc}}$ via quadrature.\n   - Reconstruct $\\hat{f}_{\\text{base}}$ using $c_{\\ell,m}$.\n   - Compute the baseline violation $\\text{viol}(\\hat{f}_{\\text{base}})$.\n   - Apply the filter $G(\\ell) = \\exp(-\\alpha \\ell(\\ell+1))$ to obtain filtered coefficients $G(\\ell)c_{\\ell,m}$.\n   - Reconstruct $\\hat{f}_{\\text{filt}}$ and compute the filtered violation $\\text{viol}(\\hat{f}_{\\text{filt}})$.\n   - Compute mass difference $|c_{0,0}^{\\text{filtered}} - c_{0,0}|$. Because $G(0) = 1$, this value should be numerically zero, demonstrating preservation of total mass.\n4. Round each metric to six decimal places and output the results as specified.\n\nScientific realism and expected outcomes:\n\n- The coastline step introduces a discontinuity that yields Gibbs ringing in the truncated spherical harmonic reconstruction. The exponential filter reduces high-degree contributions responsible for oscillations, thereby lowering overshoot and undershoot near the coastline. The baseline case with $\\alpha = 0$ typically exhibits nonzero violation, and increasing $\\alpha$ reduces the violation amplitude. Extreme smoothing with large $\\alpha$ approaches a constant field (degree-$0$), eliminating bound violations but removing spatial structure. The filter preserves total mass because it leaves $c_{0,0}$ unchanged.\n\nThe final program implements the above computational steps using a vectorized evaluation of $Y_{\\ell}^{m}(\\theta,\\phi)$ and sums to obtain $c_{\\ell,m}$ and reconstructions, conforms to the angle unit in radians, and outputs a single correctly formatted line of results for the specified test suite.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef make_grid(nlat: int, nlon: int):\n    # Midpoint rule in theta to avoid poles\n    dtheta = np.pi / nlat\n    dphi = 2.0 * np.pi / nlon\n    theta = (np.arange(nlat) + 0.5) * dtheta\n    phi = np.arange(nlon) * dphi\n    TH, PH = np.meshgrid(theta, phi, indexing='ij')\n    sinTH = np.sin(TH)\n    return TH, PH, sinTH, dtheta, dphi\n\ndef synthetic_coast_field(PH):\n    # Half-sphere land-sea mask: land for phi in [0, pi), sea otherwise.\n    # Field is dimensionless: 1 for land, 0 for sea.\n    return (PH  np.pi).astype(np.float64)\n\ndef analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L):\n    # Compute spherical harmonic coefficients c_{l,m} via quadrature\n    # c_{l,m} ~ sum f * conj(Y_{l,m}) * sin(theta) * dtheta * dphi\n    coeffs = {}\n    weights = sinTH * dtheta * dphi\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)  # complex-valued\n            integrand = f * np.conj(Y) * weights\n            c = np.sum(integrand)\n            coeffs[(l, m)] = c\n    return coeffs\n\ndef reconstruct_field(coeffs, TH, PH, L):\n    # Sum c_{l,m} * Y_{l,m} over l,m to reconstruct field; take real part.\n    f_rec = np.zeros_like(TH, dtype=np.complex128)\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)\n            f_rec += coeffs[(l, m)] * Y\n    return np.real(f_rec)\n\ndef apply_filter(coeffs, alpha):\n    # Exponential Laplacian filter: G(l) = exp(-alpha * l * (l+1)), preserves l=0 exactly.\n    filtered = {}\n    for (l, m), c in coeffs.items():\n        g = np.exp(-alpha * l * (l + 1))\n        filtered[(l, m)] = c * g\n    return filtered\n\ndef coastal_band_violation(f_rec, PH, nlon, band_center=np.pi, steps=3):\n    # Band around coastline at phi = band_center with half-width steps * dphi\n    dphi = 2.0 * np.pi / nlon\n    halfwidth = steps * dphi\n    # minimal angular distance on circle\n    delta = np.abs((PH - band_center + np.pi) % (2.0 * np.pi) - np.pi)\n    mask = delta = halfwidth\n    vals = f_rec[mask]\n    if vals.size == 0:\n        return 0.0\n    above1 = np.max(vals - 1.0) if vals.size else 0.0\n    below0 = np.max(-vals) if vals.size else 0.0\n    violation = max(above1 if above1 > 0.0 else 0.0, below0 if below0 > 0.0 else 0.0)\n    return float(violation)\n\ndef format_results(results):\n    # Format as [[b1,f1,m1],[b2,f2,m2],...] with no spaces and six decimals\n    def fmt(x): return f\"{x:.6f}\"\n    inner = []\n    for r in results:\n        inner.append(\"[\" + \",\".join(fmt(v) for v in r) + \"]\")\n    return \"[\" + \",\".join(inner) + \"]\"\n\ndef solve():\n    # Define grid\n    Nlat = 73\n    Nlon = 144\n    TH, PH, sinTH, dtheta, dphi = make_grid(Nlat, Nlon)\n    f = synthetic_coast_field(PH)\n\n    # Test cases: (L_trunc, alpha)\n    test_cases = [\n        (20, 0.0),    # baseline\n        (20, 0.005),  # moderate smoothing\n        (20, 0.02),   # strong smoothing\n        (12, 0.02),   # lower truncation with smoothing\n        (20, 2.0),    # extreme smoothing\n    ]\n\n    # Cache analyses for each distinct L\n    coeffs_cache = {}\n    baseline_violation_cache = {}\n\n    results = []\n    for L, alpha in test_cases:\n        # Analyze coefficients for this L (cached)\n        if L not in coeffs_cache:\n            coeffs = analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L)\n            coeffs_cache[L] = coeffs\n        else:\n            coeffs = coeffs_cache[L]\n\n        # Baseline reconstruction (alpha = 0)\n        if L not in baseline_violation_cache:\n            f_base = reconstruct_field(coeffs, TH, PH, L)\n            bviol = coastal_band_violation(f_base, PH, Nlon)\n            baseline_violation_cache[L] = (f_base, bviol)\n        else:\n            f_base, bviol = baseline_violation_cache[L]\n\n        # Apply filter\n        filt_coeffs = apply_filter(coeffs, alpha)\n        # Mass difference via c_{0,0}\n        c00_orig = coeffs[(0, 0)]\n        c00_filt = filt_coeffs[(0, 0)]\n        mass_diff = float(np.abs(c00_filt - c00_orig))\n\n        # Filtered reconstruction\n        f_filt = reconstruct_field(filt_coeffs, TH, PH, L)\n        fviol = coastal_band_violation(f_filt, PH, Nlon)\n\n        results.append((bviol, fviol, mass_diff))\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}