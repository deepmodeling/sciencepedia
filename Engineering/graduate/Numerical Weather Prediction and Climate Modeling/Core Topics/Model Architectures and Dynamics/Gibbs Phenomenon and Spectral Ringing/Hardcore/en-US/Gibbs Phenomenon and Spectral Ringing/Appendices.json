{
    "hands_on_practices": [
        {
            "introduction": "To begin our hands-on exploration, we first examine the Gibbs phenomenon in its most fundamental discrete setting. This practice  challenges you to connect the theoretical Discrete Fourier Transform (DFT) of a step function with its practical, numerical implementation. By analyzing the effects of low-pass filtering and zero-padding, you will gain crucial insights into how spectral truncation generates ringing artifacts and how common signal processing techniques can reveal the underlying structure of the spectrum.",
            "id": "4049038",
            "problem": "Consider a periodic one-dimensional longitude grid used in spectral atmospheric models for Numerical Weather Prediction (NWP) and climate modeling. The grid has $N$ points with indices $n \\in \\{0,1,\\dots,N-1\\}$ and a discrete step sequence that mimics a sharp front: the field is $0$ before the step index and $A$ at and after the step index. Formally, define the sequence $s[n]$ by $s[n] = 0$ for $0 \\le n < n_0$ and $s[n] = A$ for $n_0 \\le n \\le N-1$. This sequence is defined on the periodic domain but is treated as a single period for discrete Fourier analysis.\n\nThe Discrete Fourier Transform (DFT) of a length-$N$ sequence $x[n]$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi k n / N}, \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\nwhere $i$ is the imaginary unit, and the inverse transform is\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi k n / N}.\n$$\nWhen zero-padding to a larger length $M$ (with $M > N$), we construct a new sequence $x_M[n]$ by placing the original $N$ samples at indices $0,\\dots,N-1$ and setting $x_M[n] = 0$ for $n \\in \\{N,\\dots,M-1\\}$. The $M$-point DFT is\n$$\nX_M[k] = \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i 2\\pi k n / M}, \\quad k \\in \\{0,1,\\dots,M-1\\}.\n$$\n\nIn spectral atmospheric models, truncation to a maximum resolved wavenumber acts as an ideal low-pass filter. Given a nonnegative cutoff $K_c$ with $K_c < N/2$, define the ideal low-pass filtered spectrum at length $N$ by\n$$\n\\widetilde{X}[k] = \n\\begin{cases}\nX[k], & \\text{if } k \\in \\{0,1,\\dots,K_c\\} \\cup \\{N-K_c,\\dots,N-1\\},\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nand the corresponding filtered field by inverse DFT:\n$$\n\\widetilde{s}[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widetilde{X}[k] \\, e^{i 2\\pi k n / N}.\n$$\nSimilarly, when zero-padding to length $M$, to preserve the same physical cutoff (fraction of Nyquist), define $K_c^{(M)} = \\left\\lfloor \\frac{M}{N} K_c \\right\\rfloor$ and the ideal low-pass filtered spectrum\n$$\n\\widetilde{X}_M[k] = \n\\begin{cases}\nX_M[k], & \\text{if } k \\in \\{0,1,\\dots,K_c^{(M)}\\} \\cup \\{M-K_c^{(M)},\\dots,M-1\\},\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwith the filtered field\n$$\n\\widetilde{s}_M[n] = \\frac{1}{M} \\sum_{k=0}^{M-1} \\widetilde{X}_M[k] \\, e^{i 2\\pi k n / M}.\n$$\n\nTasks:\n1. Derive from first principles the closed-form expression for the DFT $X[k]$ of the discrete step $s[n]$ using the geometric series identity. Demonstrate that zero-padding changes the sampling of the underlying discrete-time Fourier transform by deriving $X_M[k]$ for the zero-padded sequence and relating it to $X[k]$.\n2. Implement an algorithm to compute $\\widetilde{s}[n]$ and $\\widetilde{s}_M[n]$ for given $N$, $M$, $n_0$, $A$, and $K_c$. Then, quantify Gibbs phenomenon and spectral ringing in the spatial domain by:\n   - Ringing amplitude: compute the overshoot amplitude as $\\max(\\widetilde{s}[n]) - A$ over a neighborhood to the right of the discontinuity index $n_0$ for the non-padded case, and $\\max(\\widetilde{s}_M[n]) - A$ for the padded case.\n   - Ringing angular frequency: estimate the dominant oscillation near the discontinuity. Identify the first two local maxima of $\\widetilde{s}[n] - A$ to the right of $n_0$ and compute the angular wavenumber in radians per grid index by $\\omega = \\frac{2\\pi}{\\Delta n}$, where $\\Delta n$ is the separation in grid indices between these two maxima. Use the same procedure for $\\widetilde{s}_M[n] - A$. If fewer than two maxima are found in the neighborhood, estimate $\\omega$ by fitting the dominant frequency via the DFT magnitude of the neighborhood segment and mapping the peak index $k^\\star$ to $\\omega = \\frac{2\\pi k^\\star}{L}$, where $L$ is the segment length.\n3. Use the angle unit in radians in all frequency reports. There are no physical units in this problem.\n4. For each test case, produce the final result as a list of four floating-point numbers: $[\\text{amp}_{N}, \\omega_{N}, \\text{amp}_{M}, \\omega_{M}]$, where $\\text{amp}_{N}$ and $\\omega_{N}$ are the ringing amplitude and angular frequency without zero-padding, and $\\text{amp}_{M}$ and $\\omega_{M}$ are the ringing amplitude and angular frequency with zero-padding.\n\nTest suite:\n- Case $1$: $N=128$, $M=512$, $n_0=64$, $A=1.0$, $K_c=32$.\n- Case $2$: $N=32$, $M=256$, $n_0=16$, $A=1.0$, $K_c=8$.\n- Case $3$: $N=128$, $M=512$, $n_0=20$, $A=1.0$, $K_c=16$.\n- Case $4$: $N=64$, $M=256$, $n_0=4$, $A=1.0$, $K_c=16$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\dots]$), where each $\\text{result}_i$ is itself a list in the form $[\\text{amp}_{N}, \\omega_{N}, \\text{amp}_{M}, \\omega_{M}]$ for the corresponding test case, in the order listed above. The angle unit for $\\omega$ must be radians per grid index.",
            "solution": "The problem requires a two-part analysis: first, a theoretical derivation of the Discrete Fourier Transform (DFT) for a discrete step function and the effect of zero-padding; second, a numerical implementation to quantify the Gibbs phenomenon (ringing) that arises from low-pass filtering this step function in the spectral domain.\n\n### Part 1: Theoretical Derivation\n\n#### 1.1. DFT of the Discrete Step Sequence\nLet the discrete sequence be $s[n]$ of length $N$, defined as:\n$$\ns[n] = \n\\begin{cases}\n0 & \\text{for } 0 \\le n < n_0 \\\\\nA & \\text{for } n_0 \\le n \\le N-1\n\\end{cases}\n$$\nThe $N$-point DFT, $X[k]$, is given by:\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] e^{-i 2\\pi k n / N}\n$$\nSubstituting the definition of $s[n]$:\n$$\nX[k] = \\sum_{n=n_0}^{N-1} A e^{-i 2\\pi k n / N} = A \\sum_{n=n_0}^{N-1} \\left(e^{-i 2\\pi k / N}\\right)^n\n$$\nThis is a finite geometric series. We consider two cases for the frequency index $k$.\n\n**Case 1: $k=0$ (DC Component)**\nFor $k=0$, the exponential term is $e^0 = 1$.\n$$\nX[0] = A \\sum_{n=n_0}^{N-1} 1 = A \\cdot ((N-1) - n_0 + 1) = A(N-n_0)\n$$\nThis represents the mean value of the signal multiplied by $N$.\n\n**Case 2: $k \\in \\{1, 2, \\dots, N-1\\}$**\nFor $k \\ne 0$, the ratio of the geometric series is $r = e^{-i 2\\pi k / N} \\ne 1$. The sum of a geometric series $\\sum_{j=a}^{b} r^j$ is $r^a \\frac{1-r^{b-a+1}}{1-r}$.\nHere, the first term is at $n=n_0$, the last term is at $n=N-1$, and the number of terms is $L = N-n_0$.\n$$\n\\sum_{n=n_0}^{N-1} r^n = r^{n_0} \\frac{1 - r^{N-n_0}}{1-r}\n$$\nSubstituting $r = e^{-i 2\\pi k / N}$:\n$$\nX[k] = A \\left(e^{-i 2\\pi k / N}\\right)^{n_0} \\frac{1 - \\left(e^{-i 2\\pi k / N}\\right)^{N-n_0}}{1 - e^{-i 2\\pi k / N}} = A e^{-i 2\\pi k n_0 / N} \\frac{1 - e^{-i 2\\pi k (N-n_0) / N}}{1 - e^{-i 2\\pi k / N}}\n$$\nWe can use the identity $e^{-i2\\pi k} = 1$ for integer $k$ to simplify the term $e^{-i 2\\pi k (N-n_0) / N} = e^{-i 2\\pi k} e^{i 2\\pi k n_0 / N} = e^{i 2\\pi k n_0 / N}$. The expression becomes:\n$$\nX[k] = A e^{-i 2\\pi k n_0 / N} \\frac{1 - e^{i 2\\pi k n_0 / N}}{1 - e^{-i 2\\pi k / N}}\n$$\nThis expression can be further simplified using Euler's formula $e^{i\\theta} - e^{-i\\theta} = 2i \\sin(\\theta)$.\n$$\nX[k] = A \\frac{e^{-i 2\\pi k n_0/N} - 1}{e^{-i 2\\pi k / N} - 1} = A \\frac{e^{-i \\pi k n_0/N}(e^{-i \\pi k n_0/N} - e^{i \\pi k n_0/N})}{e^{-i \\pi k /N}(e^{-i \\pi k /N} - e^{i \\pi k /N})} = A \\frac{e^{-i \\pi k n_0/N}(-2i \\sin(\\frac{\\pi k n_0}{N}))}{e^{-i \\pi k /N}(-2i \\sin(\\frac{\\pi k}{N}))}\n$$\n$$\nX[k] = A e^{-i\\pi k(n_0-1)/N} \\frac{\\sin(\\pi k n_0 / N)}{\\sin(\\pi k / N)}\n$$\nThis is the closed-form expression for the DFT coefficients for $k \\ne 0$.\n\n#### 1.2. Effect of Zero-Padding and Relation to DTFT\nZero-padding a sequence $s[n]$ of length $N$ to a length $M>N$ results in a new sequence $s_M[n]$:\n$$\ns_M[n] = \n\\begin{cases}\ns[n] & \\text{for } 0 \\le n < N \\\\\n0 & \\text{for } N \\le n < M\n\\end{cases}\n$$\nThe $M$-point DFT of $s_M[n]$ is:\n$$\nX_M[k] = \\sum_{n=0}^{M-1} s_M[n] e^{-i 2\\pi k n / M} = \\sum_{n=0}^{N-1} s[n] e^{-i 2\\pi k n / M}\n$$\nThe sum has the same number of terms as the sum for $X[k]$, but the complex exponential is evaluated at different frequencies. This shows that zero-padding does not add new information to the spectrum but changes how it is sampled.\n\nTo formalize this, we introduce the Discrete-Time Fourier Transform (DTFT) of the original finite-length sequence $s[n]$, which is a continuous function of frequency $\\omega$:\n$$\nS(e^{i\\omega}) = \\sum_{n=-\\infty}^{\\infty} s[n] e^{-i\\omega n} = \\sum_{n=0}^{N-1} s[n] e^{-i\\omega n}\n$$\nThe $N$-point DFT, $X[k]$, is a sampling of the DTFT $S(e^{i\\omega})$ at $N$ discrete frequencies $\\omega_k = \\frac{2\\pi k}{N}$:\n$$\nX[k] = S(e^{i 2\\pi k / N})\n$$\nThe $M$-point DFT of the zero-padded sequence, $X_M[k]$, is a sampling of the *same* DTFT $S(e^{i\\omega})$ but at $M$ discrete frequencies $\\omega'_k = \\frac{2\\pi k}{M}$:\n$$\nX_M[k] = S(e^{i 2\\pi k / M})\n$$\nSince $M > N$, the frequencies $\\omega'_k$ are more closely spaced than $\\omega_k$. Therefore, zero-padding provides a denser sampling of the underlying continuous spectrum $S(e^{i\\omega})$, which often reveals more detail about its structure. The closed-form expression for $X_M[k]$ is obtained by replacing $N$ with $M$ in the denominator of the exponential in the geometric series summation for $s[n]$ over the range $n_0$ to $N-1$.\n\n### Part 2: Algorithm for Numerical Analysis\n\nThe numerical task is to simulate the effect of an ideal low-pass filter on the step sequence and quantify the resulting Gibbs phenomenon.\n\n1.  **Signal Generation**: For a given test case $(N, M, n_0, A, K_c)$:\n    *   Construct the sequence $s[n]$ of length $N$ as defined.\n    *   Construct the zero-padded sequence $s_M[n]$ of length $M$.\n\n2.  **Spectral Filtering (Non-Padded Case)**:\n    *   Compute the $N$-point DFT, $X[k] = \\text{DFT}(s[n])$.\n    *   Create a new spectrum $\\widetilde{X}[k]$ initialized to zeros.\n    *   Apply the ideal low-pass filter with cutoff $K_c$:\n        $$\n        \\widetilde{X}[k] = \n        \\begin{cases}\n        X[k], & \\text{if } k \\in \\{0, \\dots, K_c\\} \\cup \\{N-K_c, \\dots, N-1\\} \\\\\n        0, & \\text{otherwise}\n        \\end{cases}\n        $$\n    *   Compute the filtered signal in the spatial domain by taking the Inverse DFT: $\\widetilde{s}[n] = \\text{IDFT}(\\widetilde{X}[k])$. We use the real part $\\mathbb{R}\\{\\widetilde{s}[n]\\}$ for analysis.\n\n3.  **Spectral Filtering (Padded Case)**:\n    *   Compute the $M$-point DFT, $X_M[k] = \\text{DFT}(s_M[n])$.\n    *   Calculate the scaled cutoff wavenumber $K_c^{(M)} = \\lfloor \\frac{M}{N} K_c \\rfloor$.\n    *   Apply the ideal low-pass filter to $X_M[k]$ with the new cutoff $K_c^{(M)}$ to obtain $\\widetilde{X}_M[k]$.\n    *   Compute the filtered signal: $\\widetilde{s}_M[n] = \\text{IDFT}(\\widetilde{X}_M[k])$. We use $\\mathbb{R}\\{\\widetilde{s}_M[n]\\}$ for analysis.\n\n4.  **Quantification of Ringing**: The analysis is performed on the deviation from the plateau value, e.g., $\\mathbb{R}\\{\\widetilde{s}[n]\\} - A$.\n    *   **Ringing Amplitude**: The maximum overshoot is found in a neighborhood to the right of the discontinuity.\n        *   Non-padded: $\\text{amp}_{N} = \\max_{n_0 \\le n < N} (\\mathbb{R}\\{\\widetilde{s}[n]\\}) - A$.\n        *   Padded: $\\text{amp}_{M} = \\max_{n_0 \\le n < M} (\\mathbb{R}\\{\\widetilde{s}_M[n]\\}) - A$.\n    *   **Ringing Angular Frequency**:\n        *   We first attempt to find the first two local maxima of the ringing signal ($\\mathbb{R}\\{\\widetilde{s}[n]\\} - A$) in the neighborhood to the right of $n_0$. For this, we use a peak finding algorithm on the segment of the signal from index $n_0$ to the end of the array.\n        *   If at least two peaks are found at indices $p_1$ and $p_2$, the separation is $\\Delta n = p_2 - p_1$. The angular frequency is $\\omega = \\frac{2\\pi}{\\Delta n}$ radians per grid index.\n        *   If fewer than two peaks are found, we fall back to a frequency-domain estimation. We take the segment of the ringing signal from $n_0$ to the end, of length $L$. We compute its $L$-point DFT. We find the index $k^\\star$ that maximizes the magnitude of the DFT coefficients, excluding the DC component ($k=0$) and negative frequencies. The angular frequency is then estimated as $\\omega = \\frac{2\\pi k^\\star}{L}$.\n    This procedure is applied to both the non-padded signal $\\widetilde{s}[n]$ and the padded signal $\\widetilde{s}_M[n]$ to find $\\omega_N$ and $\\omega_M$, respectively.\n\nThis comprehensive algorithm allows for a robust quantification of the specified characteristics of the Gibbs phenomenon for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying Gibbs phenomenon for a low-pass filtered step function\n    with and without zero-padding, as specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, M, n0, A, Kc)\n        (128, 512, 64, 1.0, 32),\n        (32, 256, 16, 1.0, 8),\n        (128, 512, 20, 1.0, 16),\n        (64, 256, 4, 1.0, 16),\n    ]\n\n    results = []\n    for N, M, n0, A, Kc in test_cases:\n        # --- Non-padded case ---\n        # 1. Create the signal\n        s_n = np.zeros(N)\n        s_n[n0:] = A\n\n        # 2. DFT and low-pass filtering\n        X_k = np.fft.fft(s_n)\n        X_tilde_k = np.zeros_like(X_k)\n        X_tilde_k[0 : Kc + 1] = X_k[0 : Kc + 1]\n        if Kc > 0:\n            X_tilde_k[N - Kc : N] = X_k[N - Kc : N]\n        s_tilde_n = np.fft.ifft(X_tilde_k).real\n\n        # 3. Quantify ringing\n        search_range_n = np.arange(n0, N)\n        signal_segment_n = s_tilde_n[search_range_n]\n        \n        # Amplitude\n        amp_N = np.max(signal_segment_n) - A\n\n        # Frequency\n        ringing_signal_n = signal_segment_n - A\n        peaks_n, _ = find_peaks(ringing_signal_n)\n        \n        if len(peaks_n) >= 2:\n            delta_n = peaks_n[1] - peaks_n[0]\n            omega_N = 2 * np.pi / delta_n\n        else:\n            L_n = len(ringing_signal_n)\n            if L_n > 1:\n                dft_segment_n = np.fft.fft(ringing_signal_n)\n                # Find peak in positive frequency half, excluding DC\n                magnitudes = np.abs(dft_segment_n[1 : L_n // 2])\n                if len(magnitudes) > 0:\n                    k_star = np.argmax(magnitudes) + 1\n                    omega_N = 2 * np.pi * k_star / L_n\n                else: # Segment too short for meaningful frequency\n                    omega_N = 0.0\n            else:\n                omega_N = 0.0\n\n        # --- Padded case ---\n        # 1. Create the padded signal\n        s_m = np.zeros(M)\n        s_m[n0:N] = A\n\n        # 2. DFT and low-pass filtering\n        Kc_M = int(np.floor(M / N * Kc))\n        X_m_k = np.fft.fft(s_m)\n        X_tilde_m_k = np.zeros_like(X_m_k)\n        X_tilde_m_k[0 : Kc_M + 1] = X_m_k[0 : Kc_M + 1]\n        if Kc_M > 0:\n            X_tilde_m_k[M - Kc_M : M] = X_m_k[M - Kc_M : M]\n        s_tilde_m = np.fft.ifft(X_tilde_m_k).real\n\n        # 3. Quantify ringing\n        search_range_m = np.arange(n0, M)\n        signal_segment_m = s_tilde_m[search_range_m]\n        \n        # Amplitude\n        amp_M = np.max(signal_segment_m) - A\n\n        # Frequency\n        ringing_signal_m = signal_segment_m - A\n        peaks_m, _ = find_peaks(ringing_signal_m)\n\n        if len(peaks_m) >= 2:\n            delta_m = peaks_m[1] - peaks_m[0]\n            omega_M = 2 * np.pi / delta_m\n        else:\n            L_m = len(ringing_signal_m)\n            if L_m > 1:\n                dft_segment_m = np.fft.fft(ringing_signal_m)\n                # Find peak in positive frequency half, excluding DC\n                magnitudes = np.abs(dft_segment_m[1 : L_m // 2])\n                if len(magnitudes) > 0:\n                    k_star = np.argmax(magnitudes) + 1\n                    omega_M = 2 * np.pi * k_star / L_m\n                else:\n                    omega_M = 0.0\n            else: \n                omega_M = 0.0\n\n        results.append(f\"[{amp_N},{omega_N},{amp_M},{omega_M}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Having established how spectral ringing arises, we now turn to a practical method for its mitigation. This exercise  introduces hyperdiffusion, a technique widely used in operational spectral models to control numerical oscillations. You will implement this filter for an idealized atmospheric jet and quantify the fundamental trade-off that model developers face: reducing unphysical ringing without excessively smearing sharp, physically meaningful gradients.",
            "id": "4049043",
            "problem": "Consider a periodic meridional slice of an idealized baroclinic jet represented by a zonal wind speed field $u(y)$ over the domain $y \\in [0, 2\\pi)$, with $y$ measured in radians. The jet has a plateau of nearly constant wind speed bounded by two sharp fronts. The purpose of this exercise is to demonstrate how spectral ringing arising from Fourier truncation (the Gibbs phenomenon) is mitigated by hyperdiffusion, and to quantify the trade-off between ringing mitigation and gradient fidelity in a controlled numerical experiment that is aligned with numerical weather prediction and climate modeling practice.\n\nStarting from the following fundamental bases:\n\n- The Discrete Fourier Transform (DFT) and its inverse provide a bijective transform between a periodic function and its spectral coefficients. The DFT maps spatial variations into wavenumber space and supports exact differentiation via multiplication by the wavenumber.\n- The Fast Fourier Transform (FFT) is an algorithm to compute the DFT efficiently.\n- A spectral atmospheric model can be idealized as using a truncated Fourier representation, retaining only wavenumbers $|k| \\le k_c$, which introduces spectral ringing near sharp gradients due to the Gibbs phenomenon.\n- Hyperdiffusion is modeled in continuous time by the linear partial differential equation $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$, with hyperdiffusion order $p \\in \\mathbb{N}$ and coefficient $\\nu > 0$. This operator preferentially damps high-wavenumber components to mitigate ringing.\n\nDefine the idealized jet profile on $N$ equally spaced points using\n$$\nu_{\\text{true}}(y) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_2}{w}\\right)\\right],\n$$\nwhere $U_0$ is the jet plateau speed in meters per second, $y_1 = y_0 - \\Delta$, $y_2 = y_0 + \\Delta$, $y_0=\\pi$, $\\Delta$ is the half-width of the jet in radians, and $w$ is the sharpness parameter (in radians) that determines the frontal steepness. The discrete grid is $y_j = 2\\pi j/N$ for $j=0,\\dots,N-1$.\n\nLet $\\widehat{u}(k)$ denote the DFT of $u(y)$ on this grid, with wavenumbers $k$ represented as integer multiples consistent with the $2\\pi$-periodicity. Truncated spectral representation sets $\\widehat{u}(k)=0$ for $|k|>k_c$, where $k_c$ is the resolution cutoff. Hyperdiffusion should be applied in spectral space for a unit nondimensional time step to the truncated representation according to the continuous-time model above, interpreted as a spectral damping of retained modes. You must not use any formula stated in this problem to bypass derivation; all steps must follow logically from the bases given.\n\nDefine two quantitative metrics:\n\n1. Ringing amplitude $R$: The largest excursion of the reconstructed field outside the physically plausible range $\\left[0, U_0\\right]$, normalized by $U_0$,\n$$\nR = \\frac{1}{U_0}\\max\\left\\{\\max_{y}\\left(u(y)-U_0\\right)_+, \\max_{y}\\left(-u(y)\\right)_+\\right\\},\n$$\nwhere $(x)_+ = \\max(x,0)$ and $u(y)$ is the reconstructed field after truncation and hyperdiffusion. This metric is dimensionless.\n\n2. Gradient fidelity error $E$: The relative $\\ell^2$ error of the meridional gradient compared to the true field,\n$$\nE = \\frac{\\left\\|\\partial_y u(y) - \\partial_y u_{\\text{true}}(y)\\right\\|_2}{\\left\\|\\partial_y u_{\\text{true}}(y)\\right\\|_2},\n$$\nwhere derivatives are computed spectrally and the $\\ell^2$ norm is taken over the discrete grid. This metric is dimensionless.\n\nYour program must:\n\n- Construct $u_{\\text{true}}(y)$ on a periodic grid using the parameters below.\n- Compute its DFT, perform truncation at $|k| \\le k_c$, and then apply hyperdiffusion in spectral space consistently with $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$ for a unit nondimensional time step.\n- Reconstruct the field by inverse DFT and compute $R$ and $E$ as defined above.\n\nUse the following scientifically realistic parameter values to create a test suite that exercises the trade-off:\n\n- Grid size: $N = 2048$.\n- Plateau speed: $U_0 = 40$ meters per second.\n- Jet parameters: $\\Delta = 0.7$ radians, $w = 0.02$ radians, $y_0 = \\pi$.\n- Spectral cutoff: $k_c = 128$.\n- Hyperdiffusion test cases, expressed as pairs $(\\alpha, p)$, where $\\alpha$ is a nondimensional strength parameter and $p$ is the hyperdiffusion order:\n  1. Case 1 (boundary, no hyperdiffusion): $(\\alpha, p) = (0.0, 4)$.\n  2. Case 2 (moderate mitigation): $(\\alpha, p) = (0.4, 4)$.\n  3. Case 3 (strong hyperdiffusion): $(\\alpha, p) = (3.0, 4)$.\n  4. Case 4 (high-order hyperdiffusion): $(\\alpha, p) = (1.0, 8)$.\n\nAll angles must be in radians. All speeds are in meters per second, but the outputs are dimensionless and need no unit conversions.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n\\left[R_1, E_1, R_2, E_2, R_3, E_3, R_4, E_4\\right],\n$$\nwhere $R_i$ and $E_i$ correspond to Case $i$.\n\nThe program must be complete and runnable as provided, with no user input, and it must use only the Python standard library and the specified numerical libraries. The output values must be $\\text{float}$s. The design should ensure scientific realism and internal consistency, and each test case must lead to a deterministic numerical result.",
            "solution": "The problem requires a numerical simulation to quantify the trade-off between mitigating spectral ringing (Gibbs phenomenon) and preserving gradient fidelity when using hyperdiffusion in a spectral model of an idealized atmospheric jet. The solution involves discretizing the jet profile, transforming it to spectral space using the Fast Fourier Transform (FFT), applying spectral truncation and a hyperdiffusion operator, transforming back to physical space, and finally computing two specified metrics: ringing amplitude $R$ and gradient fidelity error $E$.\n\nFirst, we establish the computational domain and the true state. The idealized jet profile $u_{\\text{true}}(y)$ is defined on a periodic domain $y \\in [0, 2\\pi)$. We discretize this domain using $N=2048$ equally spaced points, $y_j = 2\\pi j/N$ for $j = 0, \\dots, N-1$. The true velocity field on this grid is computed using the given formula:\n$$\nu_{\\text{true}}(y_j) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_2}{w}\\right)\\right]\n$$\nwith parameters $U_0=40$, $y_0=\\pi$, $\\Delta=0.7$, $w=0.02$, $y_1=y_0-\\Delta$, and $y_2=y_0+\\Delta$. The sharpness parameter $w$ is small, creating sharp gradients that will induce strong Gibbs ringing upon spectral truncation.\n\nThe core of the method is in spectral space. We use the Discrete Fourier Transform (DFT), computed via the FFT algorithm, to obtain the spectral coefficients $\\widehat{u}_{\\text{true}}(k)$ of the discrete field $u_{\\text{true}}(y_j)$. The corresponding integer wavenumbers $k$ are obtained for the $N$-point grid on a $2\\pi$ domain. The derivative operator $\\partial_y$ in physical space corresponds to multiplication by $ik$ in spectral space, where $i = \\sqrt{-1}$. This property is used to compute all spatial derivatives.\n\nThe numerical simulation for each test case $(\\alpha, p)$ follows a precise sequence of steps:\n\n1.  **Spectral Truncation**: The true spectrum $\\widehat{u}_{\\text{true}}(k)$ is truncated by setting all coefficients for which the absolute value of the wavenumber $|k|$ exceeds the cutoff $k_c=128$ to zero. This simulates a finite-resolution spectral model. Let the resulting truncated spectrum be $\\widehat{u}_{\\text{trunc}}(k)$:\n    $$\n    \\widehat{u}_{\\text{trunc}}(k) = \\begin{cases} \\widehat{u}_{\\text{true}}(k) & \\text{if } |k| \\le k_c \\\\ 0 & \\text{if } |k| > k_c \\end{cases}\n    $$\n    This abrupt truncation is the source of the Gibbs phenomenon. Case 1, with no hyperdiffusion ($\\alpha=0$), isolates the effect of truncation alone.\n\n2.  **Hyperdiffusion Damping**: Hyperdiffusion is applied to the truncated spectrum to damp the high-wavenumber oscillations. The governing continuous equation is $u_t = -\\nu(-\\partial_y^2)^p u$. In spectral space, this becomes an ordinary differential equation for each spectral coefficient $\\widehat{u}(k)$:\n    $$\n    \\frac{d\\widehat{u}(k, t)}{dt} = -\\nu (k^2)^p \\widehat{u}(k, t) = -\\nu k^{2p} \\widehat{u}(k, t)\n    $$\n    The solution over a unit nondimensional time step ($t=1$) is $\\widehat{u}(k, 1) = \\widehat{u}(k, 0) \\exp(-\\nu k^{2p})$. The problem provides a non-dimensional strength parameter $\\alpha$ rather than the coefficient $\\nu$. Following standard practice in numerical weather prediction, we associate $\\alpha$ with the damping strength at the truncation wavenumber $k_c$. We set the exponent of the damping factor at $|k|=k_c$ to be $-\\alpha$. This yields the relationship $\\nu k_c^{2p} = \\alpha$, so $\\nu = \\alpha/k_c^{2p}$. The damping factor $D(k)$ applied to any retained mode ($|k| \\le k_c$) is therefore:\n    $$\n    D(k) = \\exp\\left(-\\frac{\\alpha}{k_c^{2p}} k^{2p}\\right) = \\exp\\left[-\\alpha \\left(\\frac{|k|}{k_c}\\right)^{2p}\\right]\n    $$\n    This factor is multiplied by the truncated spectral coefficients to get the final spectrum, $\\widehat{u}_{\\text{final}}(k) = \\widehat{u}_{\\text{trunc}}(k) D(k)$. For $\\alpha=0$, $D(k)=1$, corresponding to no diffusion.\n\n3.  **Reconstruction**: The final physical field, $u(y)$, is reconstructed by applying the inverse DFT (via the IFFT algorithm) to $\\widehat{u}_{\\text{final}}(k)$. As the initial field is real, we take the real part of the result to discard any minor imaginary components arising from floating-point error.\n\nAfter obtaining the final field $u(y)$ for a given test case, we compute the two metrics:\n\n1.  **Ringing Amplitude ($R$)**: This metric quantifies unphysical oscillations. It is the maximum deviation of the computed field $u(y)$ outside the physically expected range $[0, U_0]$, normalized by the jet speed $U_0$. On the discrete grid, it is calculated as:\n    $$\n    R = \\frac{1}{U_0} \\max\\left\\{ \\max_j\\left( \\max(u(y_j)-U_0, 0) \\right), \\max_j\\left( \\max(-u(y_j), 0) \\right) \\right\\}\n    $$\n\n2.  **Gradient Fidelity Error ($E$)**: This metric measures the degradation of the physically important sharp fronts. It is the relative $\\ell^2$ error of the gradient of the final field with respect to the gradient of the true field. Both gradients are computed spectrally for consistency and accuracy. The gradient of the true field, $\\partial_y u_{\\text{true}}(y)$, is found by taking the inverse DFT of $ik\\widehat{u}_{\\text{true}}(k)$. Similarly, the gradient of the final field, $\\partial_y u(y)$, is the inverse DFT of $ik\\widehat{u}_{\\text{final}}(k)$. The error $E$ is then:\n    $$\n    E = \\frac{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u(y_j) - \\partial_y u_{\\text{true}}(y_j)|^2}}{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u_{\\text{true}}(y_j)|^2}} = \\frac{\\|\\partial_y u - \\partial_y u_{\\text{true}}\\|_2}{\\|\\partial_y u_{\\text{true}}\\|_2}\n    $$\nThe denominator, $\\|\\partial_y u_{\\text{true}}\\|_2$, is computed once from the full, non-truncated true spectrum to serve as a constant reference. The numerator is computed for each test case. This procedure is systematically applied to all four test cases to generate the required output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes ringing and gradient error metrics for a spectral model\n    of an idealized jet with hyperdiffusion.\n    \"\"\"\n    # Define physical and numerical parameters\n    N = 2048\n    U0 = 40.0\n    delta = 0.7\n    w = 0.02\n    y0 = np.pi\n    kc = 128\n\n    # Define the hyperdiffusion test cases (alpha, p)\n    test_cases = [\n        (0.0, 4),  # Case 1: No hyperdiffusion\n        (0.4, 4),  # Case 2: Moderate hyperdiffusion\n        (3.0, 4),  # Case 3: Strong hyperdiffusion\n        (1.0, 8),  # Case 4: High-order hyperdiffusion\n    ]\n\n    # Create the spatial grid\n    y = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # Define the true jet profile\n    y1 = y0 - delta\n    y2 = y0 + delta\n    u_true = (U0 / 2.0) * (1.0 + np.tanh((y - y1) / w)) - \\\n             (U0 / 2.0) * (1.0 + np.tanh((y - y2) / w))\n\n    # Compute spectral representation of the true field and its gradient\n    # Wavenumbers k for a 2*pi periodic domain\n    k = np.fft.fftfreq(N) * N\n    u_true_hat = np.fft.fft(u_true)\n\n    # Compute the true gradient spectrally for the error metric denominator\n    grad_u_true_hat = 1j * k * u_true_hat\n    grad_u_true = np.real(np.fft.ifft(grad_u_true_hat))\n    norm_grad_u_true = np.linalg.norm(grad_u_true)\n\n    results = []\n\n    # Process each test case\n    for alpha, p in test_cases:\n        # Step 1: Spectral Truncation\n        # Create a copy to modify\n        u_final_hat = u_true_hat.copy()\n        # Apply sharp cutoff by zeroing out coefficients where |k| > kc\n        u_final_hat[np.abs(k) > kc] = 0.0\n\n        # Step 2: Apply Hyperdiffusion\n        if alpha > 0.0:\n            # We only need to compute and apply damping to the retained modes |k| <= kc\n            # Find indices of modes to be damped\n            indices_to_damp = np.where(np.abs(k) <= kc)[0]\n            k_to_damp = k[indices_to_damp]\n\n            # Calculate damping factor for these modes\n            # ratios = |k|/kc\n            ratios = np.abs(k_to_damp) / kc\n            # D(k) = exp(-alpha * (|k|/kc)^(2p))\n            dampers = np.exp(-alpha * (ratios**(2 * p)))\n            \n            # Apply the damping factor to the truncated spectrum\n            u_final_hat[indices_to_damp] *= dampers\n\n        # Step 3: Reconstruct the physical field\n        u_final = np.real(np.fft.ifft(u_final_hat))\n\n        # --- Compute Metrics ---\n\n        # Metric 1: Ringing amplitude (R)\n        overshoot = np.maximum(u_final - U0, 0)\n        undershoot = np.maximum(-u_final, 0)\n        R = np.maximum(np.max(overshoot), np.max(undershoot)) / U0\n        results.append(R)\n\n        # Metric 2: Gradient fidelity error (E)\n        # Gradient of the final field is computed from its spectrum u_final_hat\n        grad_u_final_hat = 1j * k * u_final_hat\n        grad_u_final = np.real(np.fft.ifft(grad_u_final_hat))\n        \n        # Calculate L2 norm of the gradient difference\n        grad_diff = grad_u_final - grad_u_true\n        norm_grad_diff = np.linalg.norm(grad_diff)\n        \n        # Calculate relative error E\n        E = norm_grad_diff / norm_grad_u_true\n        results.append(E)\n\n    # Format and print final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice extends these concepts from one-dimensional domains to the spherical geometry essential for global modeling. In this task , you will use spherical harmonics, the natural basis functions on a sphere, to represent a global field with a sharp discontinuity simulating a coastline. You will then design and apply a mass-preserving spectral filter, directly observing how Gibbs ringing is managed in the context of state-of-the-art climate and weather prediction models.",
            "id": "4049060",
            "problem": "You are asked to design and evaluate a spectral filter on the sphere that reduces Gibbs phenomenon (spectral ringing) in a global field while preserving the total mass. The setting is Numerical Weather Prediction (NWP) and climate modeling, where global fields are commonly represented on the sphere using spherical harmonics. Your program must implement a self-contained spherical harmonic analysis and synthesis of a synthetic global field that exhibits a coastline-like discontinuity, apply a mass-preserving high-degree suppression filter, and quantify ringing reduction.\n\nYou must start from the following fundamental base, expressed in purely mathematical terms:\n\n- The spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ form an orthonormal basis on the unit sphere with respect to the surface area element $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$, where $\\theta \\in [0,\\pi]$ is the colatitude in radians and $\\phi \\in [0,2\\pi)$ is the longitude in radians. Orthonormality means\n$$\n\\int_{0}^{\\pi}\\int_{0}^{2\\pi} Y_{\\ell}^{m}(\\theta,\\phi)\\, Y_{\\ell'}^{m'}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}.\n$$\n- Any square-integrable scalar field $f(\\theta,\\phi)$ on the sphere admits the expansion\n$$\nf(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\nwith spherical harmonic coefficients\n$$\nc_{\\ell,m} \\;=\\; \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\n- Gibbs phenomenon arises when representing discontinuous functions via truncated spectral expansions; high-degree modes produce oscillatory overshoots near the discontinuity that do not vanish with truncation but are mitigated by appropriate filtering of high-degree modes.\n\nDesign objectives and constraints:\n\n1. Propose a filter on spherical harmonic coefficients $c_{\\ell,m}$ that suppresses high-degree modes while preserving total mass. The total mass of $f(\\theta,\\phi)$ over the unit sphere is proportional to the degree-$0$, order-$0$ coefficient $c_{0,0}$ because $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$. Your filter must satisfy $G(0) = 1$ so that $c_{0,0}$ is unmodified.\n2. Implement a numerical spherical harmonic analysis and synthesis using discrete quadrature with weights $w(\\theta,\\phi) = \\sin\\theta\\, \\Delta\\theta\\, \\Delta\\phi$ on an equally spaced latitude-longitude grid. Angles must be in radians.\n3. Construct a synthetic global climate field with coastline-like discontinuity by defining a land-sea mask $f(\\theta,\\phi)$ equal to $1$ for longitudes $\\phi \\in [0,\\pi)$ (the \"land\" half-sphere) and $0$ for $\\phi \\in [\\pi,2\\pi)$ (the \"sea\" half-sphere). This field exhibits a meridional coastline at $\\phi = \\pi$.\n4. Quantify ringing around the coastline by computing the maximum bound violation within a narrow coastal band, defined as $\\{(\\theta,\\phi): |\\phi-\\pi| \\leq 3\\Delta\\phi\\}$, where $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$. This metric is a nonnegative float.\n5. Demonstrate mass preservation by computing the absolute difference $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$. This quantity must be reported as a float and should be numerically very small (ideally zero) if $G(0)=1$ is enforced.\n\nYou must implement the following filter specification and reconstruction protocol:\n\n- Define the filter transfer function $G(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right)$ with dimensionless parameter $\\alpha \\ge 0$. This function satisfies $G(0)=1$ and monotonically decreases with $\\ell$, strongly damping high-degree modes while leaving the total mass unchanged.\n- For a given truncation degree $L_{\\text{trunc}}$, compute $c_{\\ell,m}$ for $0 \\le \\ell \\le L_{\\text{trunc}}$, $-\\ell \\le m \\le \\ell$ using the discrete quadrature sum\n$$\nc_{\\ell,m} \\;\\approx\\; \\sum_{i=1}^{N_{\\text{lat}}}\\sum_{j=1}^{N_{\\text{lon}}} f(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^{*}\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi,\n$$\nwhere the grid is $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\,\\Delta\\theta$ for $i = 0,\\ldots,N_{\\text{lat}}-1$, and $\\phi_j = j\\, \\Delta\\phi$ for $j = 0,\\ldots,N_{\\text{lon}}-1$, with $\\Delta\\theta = \\pi/N_{\\text{lat}}$, $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$.\n- Reconstruct the baseline truncated field\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\nand the filtered field\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n\nPhysical and numerical units:\n\n- All angles $\\theta$ and $\\phi$ must be in radians.\n- The field $f(\\theta,\\phi)$ is dimensionless.\n\nTest suite:\n\nUse an equally spaced grid with $N_{\\text{lat}} = 73$ and $N_{\\text{lon}} = 144$. Evaluate the following five parameter sets, each defined by a pair $(L_{\\text{trunc}}, \\alpha)$:\n\n- Case $1$: $(L_{\\text{trunc}}, \\alpha) = (20, 0.0)$, baseline with no filtering.\n- Case $2$: $(L_{\\text{trunc}}, \\alpha) = (20, 0.005)$, moderate smoothing.\n- Case $3$: $(L_{\\text{trunc}}, \\alpha) = (20, 0.02)$, strong smoothing.\n- Case $4$: $(L_{\\text{trunc}}, \\alpha) = (12, 0.02)$, lower truncation with smoothing.\n- Case $5$: $(L_{\\text{trunc}}, \\alpha) = (20, 2.0)$, extreme smoothing approximating degree-$0$ preservation only.\n\nFor each case, compute three floats:\n- The baseline bound-violation amplitude using the same $L_{\\text{trunc}}$ but with $\\alpha = 0$ (i.e., no filtering).\n- The filtered bound-violation amplitude using the specified $\\alpha$.\n- The absolute mass difference $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list of five inner lists, each inner list in the form $[b,f,m]$ where $b$ is the baseline bound-violation amplitude, $f$ is the filtered bound-violation amplitude, and $m$ is the absolute mass difference. Numbers must be rounded to six decimal places. The final printed line must have no spaces, for example:\n\"[[b1,f1,m1],[b2,f2,m2],[b3,f3,m3],[b4,f4,m4],[b5,f5,m5]]\".",
            "solution": "We begin from the orthonormality of spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ on the unit sphere with respect to the surface element $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$. For any square-integrable field $f(\\theta,\\phi)$, the spherical harmonic coefficients are\n$$\nc_{\\ell,m} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi,\n$$\nand the spectral reconstruction is\n$$\nf(\\theta,\\phi) = \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\nIn numerical weather prediction and climate modeling, truncation at degree $L_{\\text{trunc}}$ is standard:\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\nHowever, truncation alone retains high-degree contributions up to $\\ell=L_{\\text{trunc}}$, which leads to Gibbs phenomenon near discontinuities such as coastlines, seen as oscillatory overshoot beyond the physical bounds. A mitigation is spectral filtering of high-degree modes.\n\nWe propose the Laplacian-based exponential filter\n$$\nG(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right),\n$$\nwhere $\\alpha \\ge 0$ is dimensionless. This filter satisfies $G(0) = 1$, preserving the degree-$0$ mode. Because $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$ is constant, the spherical harmonic coefficient $c_{0,0}$ is proportional to the global mass (integral) of $f$:\n$$\nc_{0,0} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{0}^{0}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi\n= \\sqrt{\\frac{1}{4\\pi}} \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\nSince $G(0) = 1$, the filtered coefficient $c_{0,0}^{\\text{filtered}} = G(0)\\, c_{0,0} = c_{0,0}$, and the total mass is exactly preserved in spectral space.\n\nTo compute coefficients numerically, we discretize the sphere on an equally spaced grid:\n- Colatitudes $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta\\theta$, where $\\Delta\\theta = \\pi/N_{\\text{lat}}$ and $i = 0,\\ldots,N_{\\text{lat}}-1$.\n- Longitudes $\\phi_j = j\\,\\Delta\\phi$, where $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$ and $j = 0,\\ldots,N_{\\text{lon}}-1$.\n\nOn this grid, we approximate the integral using the composite midpoint rule with area weights $w(\\theta_i,\\phi_j) = \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi$:\n$$\nc_{\\ell,m} \\approx \\sum_{i=0}^{N_{\\text{lat}}-1}\\sum_{j=0}^{N_{\\text{lon}}-1}\nf(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^{*}\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi.\n$$\nThis quadrature is consistent with the spherical measure and is sufficient for demonstration at moderate $L_{\\text{trunc}}$.\n\nWe reconstruct the baseline truncated field as\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\nand the filtered field as\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\nBecause the original field $f$ is real-valued, numerical reconstruction is taken as the real part of the complex-valued sum.\n\nTo quantify ringing around the coastline located at $\\phi = \\pi$, we define a narrow coastal band of half-width $3\\Delta\\phi$:\n$$\n\\mathcal{B} = \\left\\{(\\theta,\\phi): |\\phi - \\pi| \\le 3\\Delta\\phi\\right\\}.\n$$\nWithin $\\mathcal{B}$, we measure bound-violation amplitude\n$$\n\\text{viol}(g) = \\max\\left( \\max_{\\mathcal{B}} \\left[g(\\theta,\\phi) - 1\\right]_{+},\\; \\max_{\\mathcal{B}} \\left[-g(\\theta,\\phi)\\right]_{+} \\right),\n$$\nwhere $[x]_{+} = \\max(x,0)$, for $g = \\hat{f}_{\\text{base}}$ (baseline) and $g = \\hat{f}_{\\text{filt}}$ (filtered). This metric reports how much the reconstructed field overshoots above the upper bound $1$ or undershoots below the lower bound $0$ near the coastline.\n\nAlgorithmic steps:\n\n1. Construct the grid with $N_{\\text{lat}} = 73$, $N_{\\text{lon}} = 144$, angles in radians, and precompute $\\sin\\theta_i$, $\\Delta\\theta$, $\\Delta\\phi$.\n2. Define the synthetic coast field $f(\\theta,\\phi) = 1$ for $\\phi \\in [0,\\pi)$ and $f(\\theta,\\phi) = 0$ for $\\phi \\in [\\pi,2\\pi)$.\n3. For each test case $(L_{\\text{trunc}}, \\alpha)$:\n   - Compute spherical harmonic coefficients $c_{\\ell,m}$ up to degree $L_{\\text{trunc}}$ via quadrature.\n   - Reconstruct $\\hat{f}_{\\text{base}}$ using $c_{\\ell,m}$.\n   - Compute the baseline violation $\\text{viol}(\\hat{f}_{\\text{base}})$.\n   - Apply the filter $G(\\ell) = \\exp(-\\alpha \\ell(\\ell+1))$ to obtain filtered coefficients $G(\\ell)c_{\\ell,m}$.\n   - Reconstruct $\\hat{f}_{\\text{filt}}$ and compute the filtered violation $\\text{viol}(\\hat{f}_{\\text{filt}})$.\n   - Compute mass difference $|c_{0,0}^{\\text{filtered}} - c_{0,0}|$. Because $G(0) = 1$, this value should be numerically zero, demonstrating preservation of total mass.\n4. Round each metric to six decimal places and output the results as specified.\n\nScientific realism and expected outcomes:\n\n- The coastline step introduces a discontinuity that yields Gibbs ringing in the truncated spherical harmonic reconstruction. The exponential filter reduces high-degree contributions responsible for oscillations, thereby lowering overshoot and undershoot near the coastline. The baseline case with $\\alpha = 0$ typically exhibits nonzero violation, and increasing $\\alpha$ reduces the violation amplitude. Extreme smoothing with large $\\alpha$ approaches a constant field (degree-$0$), eliminating bound violations but removing spatial structure. The filter preserves total mass because it leaves $c_{0,0}$ unchanged.\n\nThe final program implements the above computational steps using a vectorized evaluation of $Y_{\\ell}^{m}(\\theta,\\phi)$ and sums to obtain $c_{\\ell,m}$ and reconstructions, conforms to the angle unit in radians, and outputs a single correctly formatted line of results for the specified test suite.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef make_grid(nlat: int, nlon: int):\n    # Midpoint rule in theta to avoid poles\n    dtheta = np.pi / nlat\n    dphi = 2.0 * np.pi / nlon\n    theta = (np.arange(nlat) + 0.5) * dtheta\n    phi = np.arange(nlon) * dphi\n    TH, PH = np.meshgrid(theta, phi, indexing='ij')\n    sinTH = np.sin(TH)\n    return TH, PH, sinTH, dtheta, dphi\n\ndef synthetic_coast_field(PH):\n    # Half-sphere land-sea mask: land for phi in [0, pi), sea otherwise.\n    # Field is dimensionless: 1 for land, 0 for sea.\n    return (PH < np.pi).astype(np.float64)\n\ndef analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L):\n    # Compute spherical harmonic coefficients c_{l,m} via quadrature\n    # c_{l,m} ~ sum f * conj(Y_{l,m}) * sin(theta) * dtheta * dphi\n    coeffs = {}\n    weights = sinTH * dtheta * dphi\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)  # complex-valued\n            integrand = f * np.conj(Y) * weights\n            c = np.sum(integrand)\n            coeffs[(l, m)] = c\n    return coeffs\n\ndef reconstruct_field(coeffs, TH, PH, L):\n    # Sum c_{l,m} * Y_{l,m} over l,m to reconstruct field; take real part.\n    f_rec = np.zeros_like(TH, dtype=np.complex128)\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)\n            f_rec += coeffs[(l, m)] * Y\n    return np.real(f_rec)\n\ndef apply_filter(coeffs, alpha):\n    # Exponential Laplacian filter: G(l) = exp(-alpha * l * (l+1)), preserves l=0 exactly.\n    filtered = {}\n    for (l, m), c in coeffs.items():\n        g = np.exp(-alpha * l * (l + 1))\n        filtered[(l, m)] = c * g\n    return filtered\n\ndef coastal_band_violation(f_rec, PH, nlon, band_center=np.pi, steps=3):\n    # Band around coastline at phi = band_center with half-width steps * dphi\n    dphi = 2.0 * np.pi / nlon\n    halfwidth = steps * dphi\n    # minimal angular distance on circle\n    delta = np.abs((PH - band_center + np.pi) % (2.0 * np.pi) - np.pi)\n    mask = delta <= halfwidth\n    vals = f_rec[mask]\n    if vals.size == 0:\n        return 0.0\n    above1 = np.max(vals - 1.0) if vals.size else 0.0\n    below0 = np.max(-vals) if vals.size else 0.0\n    violation = max(above1 if above1 > 0.0 else 0.0, below0 if below0 > 0.0 else 0.0)\n    return float(violation)\n\ndef format_results(results):\n    # Format as [[b1,f1,m1],[b2,f2,m2],...] with no spaces and six decimals\n    def fmt(x): return f\"{x:.6f}\"\n    inner = []\n    for r in results:\n        inner.append(\"[\" + \",\".join(fmt(v) for v in r) + \"]\")\n    return \"[\" + \",\".join(inner) + \"]\"\n\ndef solve():\n    # Define grid\n    Nlat = 73\n    Nlon = 144\n    TH, PH, sinTH, dtheta, dphi = make_grid(Nlat, Nlon)\n    f = synthetic_coast_field(PH)\n\n    # Test cases: (L_trunc, alpha)\n    test_cases = [\n        (20, 0.0),    # baseline\n        (20, 0.005),  # moderate smoothing\n        (20, 0.02),   # strong smoothing\n        (12, 0.02),   # lower truncation with smoothing\n        (20, 2.0),    # extreme smoothing\n    ]\n\n    # Cache analyses for each distinct L\n    coeffs_cache = {}\n    baseline_violation_cache = {}\n\n    results = []\n    for L, alpha in test_cases:\n        # Analyze coefficients for this L (cached)\n        if L not in coeffs_cache:\n            coeffs = analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L)\n            coeffs_cache[L] = coeffs\n        else:\n            coeffs = coeffs_cache[L]\n\n        # Baseline reconstruction (alpha = 0)\n        if L not in baseline_violation_cache:\n            f_base = reconstruct_field(coeffs, TH, PH, L)\n            bviol = coastal_band_violation(f_base, PH, Nlon)\n            baseline_violation_cache[L] = (f_base, bviol)\n        else:\n            f_base, bviol = baseline_violation_cache[L]\n\n        # Apply filter\n        filt_coeffs = apply_filter(coeffs, alpha)\n        # Mass difference via c_{0,0}\n        c00_orig = coeffs[(0, 0)]\n        c00_filt = filt_coeffs[(0, 0)]\n        mass_diff = float(np.abs(c00_filt - c00_orig))\n\n        # Filtered reconstruction\n        f_filt = reconstruct_field(filt_coeffs, TH, PH, L)\n        fviol = coastal_band_violation(f_filt, PH, Nlon)\n\n        results.append((bviol, fviol, mass_diff))\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}