{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of spectral methods, we begin with the simplest, most fundamental case: representing a spatially constant field. This exercise allows us to explore the foundational properties of spherical harmonics, particularly the unique role of the global mean mode, $Y_{00}$. By deriving the spectral coefficients for a constant tracer, you will gain insight into how a physical field is decomposed and see the direct connection between the lowest-order coefficient and a globally conserved quantity like total mass .",
            "id": "4091678",
            "problem": "Consider a global tracer field in Numerical Weather Prediction (NWP) that is constant in space on the sphere. Let the Earth be represented by a sphere of radius $R$, with spherical coordinates $(\\theta,\\phi)$, where $\\theta \\in [0,\\pi]$ is the colatitude and $\\phi \\in [0,2\\pi)$ is the longitude. The tracer field is non-dimensional and given by $f(\\theta,\\phi) = c$, where $c$ is a constant. The spherical harmonics $Y_{\\ell}^m(\\theta,\\phi)$ form a complete orthonormal basis on the unit sphere $S^{2}$ with respect to the inner product $\\int_{S^{2}} Y_{\\ell}^m(\\theta,\\phi) Y_{\\ell'}^{m' *}(\\theta,\\phi) \\,\\mathrm{d}\\Omega = \\delta_{\\ell \\ell'} \\delta_{m m'}$, where $\\mathrm{d}\\Omega = \\sin\\theta \\,\\mathrm{d}\\theta \\,\\mathrm{d}\\phi$ and the asterisk denotes complex conjugation. The spectral projection of $f$ onto this basis is defined by the coefficients\n$$\na_{\\ell m} = \\int_{S^{2}} f(\\theta,\\phi) \\, Y_{\\ell}^{m *}(\\theta,\\phi) \\,\\mathrm{d}\\Omega.\n$$\nStarting from these foundational definitions and properties, do the following:\n1. Derive the value of $Y_{00}(\\theta,\\phi)$ implied by the orthonormality and the fact that $Y_{00}$ is constant over the sphere.\n2. Use the orthonormality to prove that for the constant field $f(\\theta,\\phi)=c$, all spectral coefficients $a_{\\ell m}$ vanish except possibly $a_{00}$.\n3. Compute $a_{00}$ explicitly as a closed-form expression in terms of $c$ and universal constants.\n4. Using the area element $\\mathrm{d}A = R^{2} \\mathrm{d}\\Omega$, show that the total tracer mass $M$ computed directly from $f$ equals the mass computed from its spectral representation, thereby demonstrating mass conservation under spectral truncation for this constant field.\n\nSubmit your final answer as the closed-form expression for $a_{00}$. The tracer is non-dimensional; express $a_{00}$ in non-dimensional units. No rounding is required.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and contains all necessary information for a rigorous derivation. It is a fundamental problem in spectral methods applied to geophysical fluid dynamics. We shall proceed with the solution by addressing each of the four requested parts in sequence.\n\nThe foundation of this problem is the representation of a scalar field on a sphere, $f(\\theta, \\phi)$, as an expansion in spherical harmonics, $Y_{\\ell}^m(\\theta, \\phi)$:\n$$\nf(\\theta, \\phi) = \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} a_{\\ell m} Y_{\\ell}^m(\\theta, \\phi)\n$$\nwhere the coefficients $a_{\\ell m}$ are found by projecting $f$ onto the basis functions:\n$$\na_{\\ell m} = \\int_{S^{2}} f(\\theta,\\phi) \\, Y_{\\ell}^{m *}(\\theta,\\phi) \\,\\mathrm{d}\\Omega\n$$\nThe spherical harmonics form an orthonormal basis, satisfying:\n$$\n\\int_{S^{2}} Y_{\\ell}^m(\\theta,\\phi) Y_{\\ell'}^{m' *}(\\theta,\\phi) \\,\\mathrm{d}\\Omega = \\delta_{\\ell \\ell'} \\delta_{m m'}\n$$\nwhere $\\mathrm{d}\\Omega = \\sin\\theta \\,\\mathrm{d}\\theta \\,\\mathrm{d}\\phi$ is the differential solid angle.\n\n**1. Derivation of $Y_{00}(\\theta,\\phi)$**\n\nWe are given that $Y_{00}(\\theta, \\phi)$ is a constant. Let us denote this constant by $K$, so $Y_{00}(\\theta, \\phi) = K$. By convention in physics, $K$ is a real, positive constant, so $Y_{00}^{*} = Y_{00} = K$. We use the orthonormality condition for the case $\\ell = \\ell' = 0$ and $m = m' = 0$:\n$$\n\\int_{S^{2}} Y_{00}(\\theta,\\phi) Y_{00}^{*}(\\theta,\\phi) \\,\\mathrm{d}\\Omega = \\delta_{00} \\delta_{00} = 1\n$$\nSubstituting $Y_{00} = K$, we have:\n$$\n\\int_{S^{2}} K \\cdot K \\,\\mathrm{d}\\Omega = 1 \\implies K^{2} \\int_{S^{2}} \\,\\mathrm{d}\\Omega = 1\n$$\nThe integral $\\int_{S^{2}} \\,\\mathrm{d}\\Omega$ represents the total solid angle of a sphere. We compute this integral explicitly in spherical coordinates:\n$$\n\\int_{S^{2}} \\,\\mathrm{d}\\Omega = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} \\sin\\theta \\,\\mathrm{d}\\theta \\,\\mathrm{d}\\phi\n$$\nThe integral over $\\theta$ yields:\n$$\n\\int_{0}^{\\pi} \\sin\\theta \\,\\mathrm{d}\\theta = [-\\cos\\theta]_{0}^{\\pi} = -(\\cos\\pi - \\cos 0) = -(-1 - 1) = 2\n$$\nSubstituting this back into the integral over $\\phi$:\n$$\n\\int_{0}^{2\\pi} 2 \\,\\mathrm{d}\\phi = 2[\\phi]_{0}^{2\\pi} = 2(2\\pi - 0) = 4\\pi\n$$\nThus, the total solid angle of a sphere is $4\\pi$. Now we can solve for $K$:\n$$\nK^{2} (4\\pi) = 1 \\implies K^{2} = \\frac{1}{4\\pi} \\implies K = \\frac{1}{\\sqrt{4\\pi}}\n$$\nWe take the positive root by convention. Therefore, the constant spherical harmonic $Y_{00}$ is:\n$$\nY_{00}(\\theta,\\phi) = \\frac{1}{\\sqrt{4\\pi}}\n$$\n\n**2. Proof that $a_{\\ell m}$ vanishes for $(\\ell, m) \\neq (0, 0)$**\n\nThe tracer field is given as a constant, $f(\\theta, \\phi) = c$. We can express this constant field in terms of the basis function $Y_{00}$. From the result of part 1, we know that $1 = \\sqrt{4\\pi} Y_{00}(\\theta, \\phi)$. Therefore, we can write the field $f$ as:\n$$\nf(\\theta, \\phi) = c = c \\cdot 1 = c \\sqrt{4\\pi} Y_{00}(\\theta, \\phi)\n$$\nNow, we compute the spectral coefficients $a_{\\ell m}$ using their definition:\n$$\na_{\\ell m} = \\int_{S^{2}} f(\\theta,\\phi) \\, Y_{\\ell}^{m *}(\\theta,\\phi) \\,\\mathrm{d}\\Omega\n$$\nSubstituting the expression for $f(\\theta, \\phi)$:\n$$\na_{\\ell m} = \\int_{S^{2}} \\left( c \\sqrt{4\\pi} Y_{00}(\\theta, \\phi) \\right) Y_{\\ell}^{m *}(\\theta, \\phi) \\,\\mathrm{d}\\Omega\n$$\nThe term $c \\sqrt{4\\pi}$ is a constant and can be taken outside the integral:\n$$\na_{\\ell m} = c \\sqrt{4\\pi} \\int_{S^{2}} Y_{00}(\\theta, \\phi) Y_{\\ell}^{m *}(\\theta, \\phi) \\,\\mathrm{d}\\Omega\n$$\nThe integral is precisely the inner product of $Y_{00}$ and $Y_{\\ell}^m$. By the orthonormality relation, this integral evaluates to $\\delta_{0\\ell}\\delta_{0m}$:\n$$\na_{\\ell m} = c \\sqrt{4\\pi} \\, \\delta_{0\\ell} \\delta_{0m}\n$$\nThe Kronecker delta $\\delta_{ij}$ is equal to $1$ if $i=j$ and $0$ otherwise. For any pair $(\\ell, m)$ where $\\ell \\neq 0$ or $m \\neq 0$, at least one of the Kronecker deltas will be zero. Consequently, $a_{\\ell m} = 0$ for all $(\\ell, m) \\neq (0, 0)$. This proves that only the $a_{00}$ coefficient can be non-zero for a constant field.\n\n**3. Computation of $a_{00}$**\n\nWe can find $a_{00}$ by setting $\\ell=0$ and $m=0$ in the general expression for $a_{\\ell m}$ derived in part 2:\n$$\na_{00} = c \\sqrt{4\\pi} \\, \\delta_{00} \\delta_{00} = c \\sqrt{4\\pi} \\cdot 1 \\cdot 1 = c \\sqrt{4\\pi}\n$$\nAlternatively, we can compute $a_{00}$ directly from its definition:\n$$\na_{00} = \\int_{S^{2}} f(\\theta,\\phi) Y_{00}^{*}(\\theta,\\phi) \\,\\mathrm{d}\\Omega\n$$\nWith $f(\\theta,\\phi) = c$ and $Y_{00}^{*} = Y_{00} = \\frac{1}{\\sqrt{4\\pi}}$:\n$$\na_{00} = \\int_{S^{2}} c \\left( \\frac{1}{\\sqrt{4\\pi}} \\right) \\,\\mathrm{d}\\Omega = \\frac{c}{\\sqrt{4\\pi}} \\int_{S^{2}} \\,\\mathrm{d}\\Omega\n$$\nAs established in part 1, the integral $\\int_{S^{2}} \\,\\mathrm{d}\\Omega = 4\\pi$. Substituting this value:\n$$\na_{00} = \\frac{c}{\\sqrt{4\\pi}} (4\\pi) = c\\sqrt{4\\pi}\n$$\nBoth methods yield the same result.\n\n**4. Demonstration of Mass Conservation**\n\nThe term \"mass\" refers to the total amount of the non-dimensional tracer, obtained by integrating the field over the surface area of the sphere. The surface area element is $\\mathrm{d}A = R^{2} \\mathrm{d}\\Omega$.\n\nFirst, we compute the total mass $M_{\\text{direct}}$ directly from the field $f(\\theta, \\phi) = c$:\n$$\nM_{\\text{direct}} = \\int_{\\text{surface}} f(\\theta, \\phi) \\,\\mathrm{d}A = \\int_{S^{2}} c \\, (R^{2} \\,\\mathrm{d}\\Omega)\n$$\nSince $c$ and $R^{2}$ are constants, we can factor them out:\n$$\nM_{\\text{direct}} = c R^{2} \\int_{S^{2}} \\,\\mathrm{d}\\Omega = c R^{2} (4\\pi) = 4\\pi R^{2} c\n$$\nThis is the expected result: the surface area of the sphere, $4\\pi R^{2}$, multiplied by the constant tracer density, $c$.\n\nNext, we compute the mass $M_{\\text{spec}}$ from the spectral representation of the field. For the constant field, the spectral series truncates after the first term, as all other coefficients are zero. The spectral representation is exact:\n$$\nf(\\theta, \\phi) = a_{00} Y_{00}(\\theta, \\phi) \n$$\nLet's verify this representation is correct: $f(\\theta, \\phi) = (c \\sqrt{4\\pi}) \\left( \\frac{1}{\\sqrt{4\\pi}} \\right) = c$. It is indeed correct. Now, we compute the mass from this representation:\n$$\nM_{\\text{spec}} = \\int_{\\text{surface}} \\left( a_{00} Y_{00}(\\theta, \\phi) \\right) \\,\\mathrm{d}A = \\int_{S^{2}} a_{00} Y_{00}(\\theta, \\phi) \\, (R^{2} \\,\\mathrm{d}\\Omega)\n$$\nFactoring out the constants $a_{00}$ and $R^2$:\n$$\nM_{\\text{spec}} = a_{00} R^{2} \\int_{S^{2}} Y_{00}(\\theta, \\phi) \\,\\mathrm{d}\\Omega\n$$\nSubstituting $Y_{00}(\\theta, \\phi) = \\frac{1}{\\sqrt{4\\pi}}$:\n$$\nM_{\\text{spec}} = a_{00} R^{2} \\int_{S^{2}} \\frac{1}{\\sqrt{4\\pi}} \\,\\mathrm{d}\\Omega = \\frac{a_{00} R^{2}}{\\sqrt{4\\pi}} \\int_{S^{2}} \\,\\mathrm{d}\\Omega\n$$\nThe integral is again $4\\pi$:\n$$\nM_{\\text{spec}} = \\frac{a_{00} R^{2}}{\\sqrt{4\\pi}} (4\\pi) = a_{00} R^{2} \\sqrt{4\\pi}\n$$\nFinally, substituting the value of $a_{00} = c\\sqrt{4\\pi}$ from part 3:\n$$\nM_{\\text{spec}} = (c\\sqrt{4\\pi}) R^{2} \\sqrt{4\\pi} = c R^{2} (4\\pi) = 4\\pi R^{2} c\n$$\nWe find that $M_{\\text{direct}} = M_{\\text{spec}}$. This demonstrates that the total tracer mass is conserved when using the spectral representation. For a constant field, this holds even for a spectral model truncated at the lowest possible order (retaining only the $\\ell=0$ mode), as all information about the field is contained within the $a_{00}$ coefficient.",
            "answer": "$$\\boxed{c\\sqrt{4\\pi}}$$"
        },
        {
            "introduction": "While the full spherical harmonic series can represent any smooth field perfectly, numerical models must use a truncated series with a finite number of modes. This practice explores the practical consequences of this necessary truncation. By attempting to reconstruct a localized Gaussian bump from a truncated Fourier series, you will computationally investigate the Gibbs phenomenon—the characteristic \"ringing\" artifacts that appear near sharp gradients—and quantify the approximation error as a function of spectral resolution . This is a vital exercise for developing an intuition for the strengths and limitations of spectral representations in capturing localized atmospheric phenomena.",
            "id": "4091659",
            "problem": "Consider a one-dimensional longitudinal spectral representation commonly used in numerical weather prediction and climate modeling to approximate fields on a sphere at a fixed latitude. The longitudinal coordinate is denoted by $\\lambda \\in [0,2\\pi)$, with angles measured in radians. The field is assumed to be $2\\pi$-periodic in $\\lambda$. The fundamental basis is the Fourier series representation, which follows from orthogonality of the complex exponentials on the circle. Let the basis functions be $e^{\\mathrm{i} m \\lambda}$ for integer $m$, and define the Discrete Fourier Transform (DFT) on a uniform grid as a numerical quadrature approximation to the continuous Fourier coefficients. The truncated series at wavenumber limit $L$ is defined by summing modes with $m \\in \\{-L,-L+1,\\dots,L-1,L\\}$.\n\nYou are asked to design a test using a localized Gaussian bump to measure reconstruction error and ringing as a function of truncation $L$. The Gaussian bump is defined by a periodic distance on the circle. For a chosen center longitude $\\lambda_0$ and width $\\sigma$, define the minimal angular distance function $\\Delta(\\lambda,\\lambda_0)$ by wrapping differences into $[-\\pi,\\pi)$ and taking absolute value. The Gaussian bump is then\n$$\nf(\\lambda) = \\exp\\left( - \\left( \\frac{\\Delta(\\lambda,\\lambda_0)}{\\sigma} \\right)^2 \\right).\n$$\nThis $f(\\lambda)$ is smooth and localized; its truncated Fourier reconstructions will exhibit approximation error and small-amplitude ringing due to spectral truncation. Using the DFT on a uniform grid of $N$ points in $\\lambda$, compute the Fourier coefficients numerically and reconstruct $f(\\lambda)$ using only modes with $|m| \\le L$, yielding $f_L(\\lambda)$.\n\nStarting from the orthogonality of complex exponentials $e^{\\mathrm{i} m \\lambda}$ and the definition of the Fourier series on the circle, derive a computational procedure to:\n- Construct the periodic Gaussian bump $f(\\lambda)$ with the specified $\\lambda_0$ and $\\sigma$ on a uniform grid.\n- Compute its DFT to obtain discrete Fourier coefficients.\n- Apply a truncation at wavenumber limit $L$ by zeroing all coefficients with $|m| > L$.\n- Invert the DFT to obtain the truncated reconstruction $f_L(\\lambda)$.\n\nMeasure the following quantities for each truncation $L$:\n1. The relative $L^2$ error,\n$$\nE_{L^2}(L) = \\frac{\\left( \\frac{1}{N} \\sum_{j=0}^{N-1} \\left( f_L(\\lambda_j) - f(\\lambda_j) \\right)^2 \\right)^{1/2}}{\\left( \\frac{1}{N} \\sum_{j=0}^{N-1} f(\\lambda_j)^2 \\right)^{1/2}},\n$$\nwhere $\\lambda_j = \\frac{2\\pi j}{N}$.\n2. The positive ringing amplitude (overshoot above the true maximum),\n$$\nR_{+}(L) = \\max\\left( \\max_{j} f_L(\\lambda_j) - \\max_{j} f(\\lambda_j), \\, 0 \\right).\n$$\n3. The negative ringing amplitude (undershoot below the true minimum),\n$$\nR_{-}(L) = \\max\\left( \\min_{j} f(\\lambda_j) - \\min_{j} f_L(\\lambda_j), \\, 0 \\right).\n$$\n\nAngles must be in radians. All outputs must be expressed as decimals (floats). Your program must implement the above steps and produce the requested metrics for each specified test case.\n\nTest Suite:\n- Use a uniform grid with $N = 4096$ points in $\\lambda$.\n- Use a bump center at $\\lambda_0 = 0$.\n- Use a bump width $\\sigma = 0.2$.\n- Evaluate the truncation levels $L \\in \\{0, 4, 16, 64, 256, 1023\\}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of three floats $[E_{L^2}(L), R_{+}(L), R_{-}(L)]$ in the same order as the test suite values of $L$. For example, an output with two cases would look like $[[e_1,rp_1,rn_1],[e_2,rp_2,rn_2]]$. The final output for this problem must follow this exact format.",
            "solution": "The user-provided problem has been validated and is sound. The following solution presents the theoretical basis and computational procedure for analyzing the spectral reconstruction of a periodic Gaussian function.\n\n### Theoretical Foundation and Numerical Method\n\nThe problem addresses the approximation of a $2\\pi$-periodic function $f(\\lambda)$ using a truncated Fourier series. The function $f(\\lambda)$ can be represented by its infinite Fourier series:\n$$\nf(\\lambda) = \\sum_{m=-\\infty}^{\\infty} c_m e^{\\mathrm{i} m \\lambda}\n$$\nwhere $m$ is the integer wavenumber and $c_m$ are the complex Fourier coefficients. The basis functions $\\{e^{\\mathrm{i} m \\lambda}\\}_{m \\in \\mathbb{Z}}$ are orthogonal over the interval $[0, 2\\pi)$, satisfying:\n$$\n\\int_0^{2\\pi} e^{\\mathrm{i} m \\lambda} (e^{\\mathrm{i} n \\lambda})^* \\,d\\lambda = \\int_0^{2\\pi} e^{\\mathrm{i} (m-n) \\lambda} \\,d\\lambda = 2\\pi \\delta_{mn}\n$$\nwhere $\\delta_{mn}$ is the Kronecker delta. This orthogonality allows for the calculation of the coefficients $c_m$ via projection:\n$$\nc_m = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(\\lambda) e^{-\\mathrm{i} m \\lambda} \\,d\\lambda\n$$\nIn a numerical context, the continuous function $f(\\lambda)$ is sampled on a discrete, uniform grid of $N$ points:\n$$\n\\lambda_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1\n$$\nThe integral for $c_m$ is then approximated by a numerical quadrature, specifically a Riemann sum over the grid points. The sample values are denoted by $f_j = f(\\lambda_j)$.\n$$\nc_m \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} f(\\lambda_j) e^{-\\mathrm{i} m \\lambda_j} \\Delta\\lambda = \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} f_j e^{-\\mathrm{i} m \\frac{2\\pi j}{N}} \\frac{2\\pi}{N} = \\frac{1}{N} \\sum_{j=0}^{N-1} f_j e^{-\\frac{2\\pi \\mathrm{i} m j}{N}}\n$$\nThis expression is directly related to the Discrete Fourier Transform (DFT). The forward DFT of the sequence $\\{f_j\\}_{j=0}^{N-1}$ is defined as:\n$$\n\\hat{f}_k = \\sum_{j=0}^{N-1} f_j e^{-\\frac{2\\pi \\mathrm{i} k j}{N}}, \\quad k = 0, 1, \\dots, N-1\n$$\nBy comparing the two expressions, we see that the Fourier coefficient $c_m$ is approximated by the scaled DFT coefficient $\\hat{f}_k$ where the DFT frequency index $k$ corresponds to the wavenumber $m$. Specifically, $c_m \\approx \\frac{1}{N}\\hat{f}_m$. Due to aliasing, the DFT indices $k \\in \\{0, \\dots, N-1\\}$ correspond to a range of physical wavenumbers centered at zero, typically $m \\in \\{-N/2, \\dots, N/2 - 1\\}$ for an even $N$.\n\n### Spectral Truncation and Reconstruction\n\nA spectral approximation of $f(\\lambda)$ truncated at a maximum wavenumber $L$ is given by:\n$$\nf_L(\\lambda) = \\sum_{m=-L}^{L} c_m e^{\\mathrm{i} m \\lambda}\n$$\nEvaluating this on the discrete grid $\\lambda_j$ and substituting the DFT-based approximation for $c_m$ yields:\n$$\nf_L(\\lambda_j) \\approx \\sum_{m=-L}^{L} \\left( \\frac{1}{N} \\hat{f}_m \\right) e^{\\mathrm{i} m \\lambda_j} = \\frac{1}{N} \\sum_{m=-L}^{L} \\hat{f}_m e^{\\frac{2\\pi \\mathrm{i} m j}{N}}\n$$\nThis is precisely the Inverse Discrete Fourier Transform (IDFT) of a modified set of coefficients, $\\hat{f}_{L,k}$, which are equal to $\\hat{f}_k$ for wavenumbers $|m| \\le L$ and zero otherwise. The IDFT is defined as:\n$$\nf_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}_k e^{\\frac{2\\pi \\mathrm{i} k j}{N}}\n$$\nTherefore, the reconstructed field $f_L(\\lambda_j)$ can be computed efficiently by performing an IDFT on a spectrally filtered array of Fourier coefficients.\n\n### Computational Procedure\n\nThe procedural steps to compute the required metrics are as follows:\n\n1.  **Grid and Function Construction**:\n    - A uniform grid of $N=4096$ points, $\\lambda_j = \\frac{2\\pi j}{N}$, is constructed for $\\lambda \\in [0, 2\\pi)$.\n    - The periodic distance function $\\Delta(\\lambda, \\lambda_0)$ for $\\lambda_0=0$ is computed for each grid point. This is the shortest distance on the circle, given by $\\Delta(\\lambda_j, 0) = \\min(\\lambda_j, 2\\pi - \\lambda_j)$. A more general formula is $\\Delta(\\lambda,\\lambda_0) = |\\text{mod}(\\lambda - \\lambda_0 + \\pi, 2\\pi) - \\pi|$.\n    - The Gaussian bump function $f(\\lambda_j) = \\exp\\left( - \\left( \\frac{\\Delta(\\lambda_j, \\lambda_0=0)}{\\sigma=0.2} \\right)^2 \\right)$ is evaluated at each grid point.\n\n2.  **Forward Transform**:\n    - The DFT of the discrete signal $\\{f_j\\}$ is computed using a Fast Fourier Transform (FFT) algorithm, yielding the complex coefficients $\\hat{f}_k$.\n\n3.  **Spectral Truncation**:\n    - The integer wavenumbers $m$ corresponding to each DFT coefficient index $k$ are determined. For a DFT of length $N$, the wavenumbers are $m \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$.\n    - For each given truncation level $L$, a new array of coefficients $\\hat{f}_{L,k}$ is created. This is done by copying $\\hat{f}_k$ and setting to zero all coefficients for which the corresponding absolute wavenumber $|m|$ is greater than $L$.\n\n4.  **Inverse Transform (Reconstruction)**:\n    - The truncated reconstruction $\\{f_{L,j}\\}$ is obtained by computing the IDFT of the truncated coefficient array $\\{\\hat{f}_{L,k}\\}$. Since the original function is real, the result of the IDFT should also be real; any small imaginary component is discarded as numerical noise.\n\n5.  **Metric Calculation**:\n    - With the original field $f_j$ and the reconstructed field $f_{L,j}$, the three specified metrics are calculated for each value of $L$:\n      - The relative $L^2$ error, $E_{L^2}(L)$, which measures the normalized root-mean-square difference.\n      - The positive ringing amplitude, $R_{+}(L)$, which quantifies the maximum overshoot of the reconstruction.\n      - The negative ringing amplitude, $R_{-}(L)$, which quantifies the maximum undershoot of the reconstruction.\n\nThis procedure is repeated for each truncation level $L \\in \\{0, 4, 16, 64, 256, 1023\\}$.",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Computes spectral reconstruction error and ringing for a periodic Gaussian bump.\n    \"\"\"\n    # Test Suite Parameters\n    N = 4096\n    lambda_0 = 0.0\n    sigma = 0.2\n    L_values = [0, 4, 16, 64, 256, 1023]\n\n    # Step 1: Construct the grid and the function f(lambda)\n    # Create a uniform grid in lambda from 0 to 2*pi (exclusive of 2*pi)\n    lambda_grid = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # Calculate the periodic distance Delta(lambda, lambda_0)\n    # This finds the shortest angle between lambda_grid and lambda_0 on a circle.\n    # The expression wraps the difference into [-pi, pi) and takes the absolute value.\n    diff = lambda_grid - lambda_0\n    wrapped_diff = (diff + np.pi) % (2 * np.pi) - np.pi\n    delta = np.abs(wrapped_diff)\n\n    # Define the Gaussian bump function\n    f_values = np.exp(-(delta / sigma)**2)\n\n    # Pre-calculate values needed for metric computation\n    max_f = np.max(f_values)\n    min_f = np.min(f_values)\n    # The factors of 1/N in the L2 error definition cancel, so we can use linalg.norm\n    norm_f = np.linalg.norm(f_values)\n\n    # Step 2: Compute the DFT of the function\n    f_hat = scipy.fft.fft(f_values)\n\n    # Determine the integer wavenumbers 'm' corresponding to the DFT coefficients\n    # scipy.fft.fftfreq(N) returns frequency bins k/N. Multiplying by N gives integer k.\n    # These correspond to the wavenumbers m.\n    wavenumbers_m = scipy.fft.fftfreq(N) * N\n\n    results = []\n    for L in L_values:\n        # Step 3: Apply spectral truncation\n        # Create a copy of the coefficients\n        f_hat_truncated = f_hat.copy()\n        # Create a mask for wavenumbers to be zeroed out\n        truncation_mask = np.abs(wavenumbers_m) > L\n        # Apply the mask\n        f_hat_truncated[truncation_mask] = 0.0\n\n        # Step 4: Invert the DFT to get the reconstructed function f_L(lambda)\n        # The result of ifft on a real signal's spectrum should be real.\n        # We take the real part to discard small imaginary noise from floating point errors.\n        f_L = np.real(scipy.fft.ifft(f_hat_truncated))\n\n        # Step 5: Measure the required quantities\n        \n        # 1. Relative L2 error\n        # E_L2(L) = norm(f_L - f) / norm(f)\n        error_norm = np.linalg.norm(f_L - f_values)\n        E_L2 = error_norm / norm_f if norm_f > 0 else 0.0\n\n        # 2. Positive ringing amplitude (overshoot)\n        # R_+(L) = max( max(f_L) - max(f), 0 )\n        R_plus = np.maximum(np.max(f_L) - max_f, 0.0)\n\n        # 3. Negative ringing amplitude (undershoot)\n        # R_-(L) = max( min(f) - min(f_L), 0 )\n        R_minus = np.maximum(min_f - np.min(f_L), 0.0)\n        \n        results.append([E_L2, R_plus, R_minus])\n\n    # Final print statement in the exact required format\n    # The format is a list of lists of floats, represented as a string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The true power of spectral methods in atmospheric modeling lies in their application to solving time-dependent partial differential equations (PDEs). This advanced practice moves from static representation to dynamics, tasking you with building a 2D spectral solver for the advection-diffusion equation. You will see how spatial derivatives in a PDE transform into simple algebraic multiplications in spectral space, converting the PDE into a more manageable system of ordinary differential equations (ODEs). By implementing a time-stepping scheme and comparing it to an exact analytical solution, you will gain hands-on experience with the complete workflow of a spectral model and explore the role of hyperdiffusion, a critical tool for numerical stability in modern climate and weather prediction systems .",
            "id": "4091581",
            "problem": "You are to design and implement a spectral experiment for a two-dimensional tracer advection–hyperdiffusion equation on a doubly periodic square domain. The goal is to compute error norms by comparing a numerical spectral time integration against an analytical spectral solution for different hyperdiffusion orders. The experiment must be fully self-contained and operate in dimensionless units on a square domain with periodic boundary conditions.\n\nStart from the conservation of a passive scalar tracer in a uniform, divergence-free velocity field on a periodic domain. The governing equation is\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} + v \\frac{\\partial q}{\\partial y} = - \\nu \\left( - \\nabla^2 \\right)^p q,\n$$\nwhere $q(x,y,t)$ is the tracer concentration, $u$ and $v$ are constant velocities, $\\nu$ is the hyperdiffusion coefficient, and $p$ is a positive integer hyperdiffusion order. The spatial domain is the square $[0,L)\\times[0,L)$ with $L=2\\pi$, and all fields are $L$-periodic in both directions.\n\nUse the following well-tested mathematical facts and definitions from spectral methods:\n- The Fast Fourier Transform (FFT) maps a discrete, periodic field $q(x,y)$ on an $N\\times N$ grid to its discrete Fourier coefficients $\\hat{q}(k_x,k_y)$, where the angular wavenumbers are given by $k_x = 2\\pi f_x$ and $k_y = 2\\pi f_y$ with $f_x$ and $f_y$ the FFT frequencies computed by the discrete Fourier transform grid spacing.\n- Spatial differentiation in spectral space is exact for the discrete Fourier representation: $\\widehat{\\partial_x q} = i k_x \\hat{q}$ and $\\widehat{\\partial_y q} = i k_y \\hat{q}$, and the Laplacian is $\\widehat{\\nabla^2 q} = -\\left(k_x^2 + k_y^2\\right)\\hat{q}$.\n- For constant coefficients and linear operators, each discrete Fourier mode evolves independently as an ordinary differential equation in time.\n\nFrom these foundations, derive the exact discrete spectral-time evolution for each Fourier mode and then implement a numerical time integrator. Specifically:\n1. Represent the initial tracer field as a Gaussian blob centered at $(x_0,y_0)$:\n$$\nq(x,y,0) = \\exp\\left( - \\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2} \\right),\n$$\nwith periodicity implied by the domain. Use $x_0 = \\pi/2$, $y_0 = \\pi$, and $\\sigma = 0.30$.\n2. In spectral space, show that each mode satisfies\n$$\n\\frac{d \\hat{q}}{dt} = \\left( - i \\left( u k_x + v k_y \\right) - \\nu \\left( k_x^2 + k_y^2 \\right)^p \\right) \\hat{q},\n$$\nand therefore the exact discrete solution at time $t$ is\n$$\n\\hat{q}(t) = \\hat{q}(0) \\exp\\left( - i \\left( u k_x + v k_y \\right) t - \\nu \\left( k_x^2 + k_y^2 \\right)^p t \\right).\n$$\n3. Implement a numerical time integration of the spectral ordinary differential equation using the classical Fourth-Order Runge–Kutta (RK4) method over $N_t$ steps of size $\\Delta t$ such that $t = N_t \\Delta t$. Compute the numerical approximation $\\hat{q}_{\\text{num}}(t)$ and its inverse FFT to obtain $q_{\\text{num}}(x,y,t)$.\n4. Compute the analytical benchmark $q_{\\text{exact}}(x,y,t)$ by applying the exact spectral evolution to the initial spectrum and inverse transforming.\n5. Compute error norms between $q_{\\text{num}}(x,y,t)$ and $q_{\\text{exact}}(x,y,t)$ on the grid:\n   - The $L^2$ error is\n   $$\n   E_{2} = \\sqrt{ \\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( q_{\\text{num}}(x_i,y_j,t) - q_{\\text{exact}}(x_i,y_j,t) \\right)^2 }.\n   $$\n   - The $L^{\\infty}$ error is\n   $$\n   E_{\\infty} = \\max_{0 \\le i,j < N} \\left| q_{\\text{num}}(x_i,y_j,t) - q_{\\text{exact}}(x_i,y_j,t) \\right|.\n   $$\n\nNumerical implementation requirements:\n- Use an $N \\times N$ grid with $N$ given per test case, a domain length $L = 2\\pi$, and grid spacing $\\Delta x = L/N$ and $\\Delta y = L/N$.\n- Use FFT-based spectral differentiation with angular wavenumbers $k_x = 2\\pi \\, \\text{fftfreq}(N, d=\\Delta x)$ and $k_y = 2\\pi \\, \\text{fftfreq}(N, d=\\Delta y)$.\n- Use the RK4 method in spectral space for time stepping of the linear ordinary differential equation for each Fourier mode.\n- The velocity components and hyperdiffusion parameters are specified per test case.\n- All quantities are dimensionless; no physical units are required.\n\nTest suite:\nFor each test case, use $x_0 = \\pi/2$, $y_0 = \\pi$, and total integration time $T = 0.50$ with time step $\\Delta t = 0.005$ so that $N_t = 100$ steps. The velocity components are $u = 1.0$ and $v = 0.5$. The test cases vary the grid size and hyperdiffusion parameters to probe different regimes:\n- Case $1$: $N = 64$, $p = 1$, $\\nu = 0.010$.\n- Case $2$: $N = 64$, $p = 2$, $\\nu = 0.00050$.\n- Case $3$: $N = 64$, $p = 4$, $\\nu = 1.0 \\times 10^{-12}$.\n- Case $4$: $N = 64$, $p = 1$, $\\nu = 0.0$ (pure advection).\n\nAnswer specification:\n- For each test case, compute and return a list $[E_{2}, E_{\\infty}]$ where both entries are floating-point numbers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s result also enclosed in square brackets, in the exact order of the test suite. For example:\n$$\n\\text{[}[E_{2}^{(1)},E_{\\infty}^{(1)}],[E_{2}^{(2)},E_{\\infty}^{(2)}],[E_{2}^{(3)},E_{\\infty}^{(3)}],[E_{2}^{(4)},E_{\\infty}^{(4)}]\\text{]}.\n$$",
            "solution": "The problem is validated as scientifically grounded, well-posed, and internally consistent. It presents a standard verification test for a numerical solver of a linear partial differential equation using spectral methods. We shall proceed with a complete solution.\n\nThe core of the problem lies in solving the advection-hyperdiffusion equation for a passive scalar tracer $q(x,y,t)$ on a doubly periodic domain $[0, L) \\times [0, L)$ where $L=2\\pi$. The governing equation is:\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} + v \\frac{\\partial q}{\\partial y} = - \\nu \\left( - \\nabla^2 \\right)^p q\n$$\nHere, $u$ and $v$ are constant velocity components, $\\nu$ is the hyperdiffusion coefficient, and $p$ is the integer order of hyperdiffusion. The spectral method is ideal for this problem due to the periodic boundary conditions and the constant-coefficient linear operators.\n\n**1. Transformation to Spectral Space**\n\nWe represent the field $q(x,y,t)$ on a discrete $N \\times N$ grid. Its spectral representation, $\\hat{q}(k_x, k_y, t)$, is obtained via a two-dimensional discrete Fourier transform (DFT), implemented using the Fast Fourier Transform (FFT) algorithm. The key property of the Fourier transform is that it converts differential operators into algebraic multiplication. The partial derivatives $\\partial/\\partial x$ and $\\partial/\\partial y$ transform to multiplication by $i k_x$ and $i k_y$ respectively, where $k_x$ and $k_y$ are the angular wavenumbers corresponding to the grid.\n\nApplying the Fourier transform to the governing PDE term by term, we get:\n$$\n\\frac{d \\hat{q}}{dt} + u (i k_x \\hat{q}) + v (i k_y \\hat{q}) = - \\nu \\left( - (-(k_x^2 + k_y^2)) \\right)^p \\hat{q}\n$$\nThe Laplacian operator $\\nabla^2 = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2$ transforms to multiplication by $-(k_x^2 + k_y^2)$. The hyperdiffusion operator $(-\\nabla^2)^p$ thus becomes multiplication by $(k_x^2 + k_y^2)^p$.\n\nRearranging the equation gives a system of independent ordinary differential equations (ODEs) for each Fourier mode $\\hat{q}(k_x, k_y, t)$:\n$$\n\\frac{d \\hat{q}}{dt} = \\left( -i(u k_x + v k_y) - \\nu(k_x^2 + k_y^2)^p \\right) \\hat{q}\n$$\nThis is a linear ODE of the form $d\\hat{q}/dt = \\mathcal{L}\\hat{q}$, where $\\mathcal{L}$ is a complex-valued scalar (the spectral operator) that depends on the wavenumbers $(k_x, k_y)$ and the physical parameters $(u, v, \\nu, p)$.\n\n**2. Discretization and Initial Condition**\n\nThe spatial domain $[0, 2\\pi) \\times [0, 2\\pi)$ is discretized on an $N \\times N$ grid, with $N=64$. The grid spacing is $\\Delta x = \\Delta y = L/N = 2\\pi/N$. The physical coordinates are $x_j = j \\Delta x$ and $y_l = l \\Delta y$ for $j, l \\in \\{0, 1, \\dots, N-1\\}$. The discrete wavenumbers are computed as $k = 2\\pi f$, where $f$ are the frequencies returned by `numpy.fft.fftfreq(N, d=2\\pi/N)`. This results in integer wavenumbers $k_x, k_y \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$. We construct 2D arrays for $k_x$ and $k_y$ to correspond with the 2D array of Fourier coefficients.\n\nThe initial condition is a Gaussian blob:\n$$\nq(x,y,0) = \\exp\\left( - \\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2} \\right)\n$$\nwith $x_0 = \\pi/2$, $y_0 = \\pi$, and $\\sigma = 0.30$. This function is evaluated on the 2D physical grid to obtain the initial state $q_0$. Its spectral representation, $\\hat{q}_0 = \\text{FFT2D}(q_0)$, serves as the initial condition for the system of ODEs.\n\n**3. Numerical Time Integration (RK4)**\n\nThe numerical solution is obtained by integrating the spectral ODEs forward in time using the classical fourth-order Runge-Kutta (RK4) method. For a given state $\\hat{q}_n$ at time $t_n$, the state $\\hat{q}_{n+1}$ at time $t_n + \\Delta t$ is computed as follows, where $f(\\hat{q}) = \\mathcal{L}\\hat{q}$:\n\\begin{align*}\n    K_1 &= \\mathcal{L} \\, \\hat{q}_n \\\\\n    K_2 &= \\mathcal{L} \\, (\\hat{q}_n + \\frac{\\Delta t}{2} K_1) \\\\\n    K_3 &= \\mathcal{L} \\, (\\hat{q}_n + \\frac{\\Delta t}{2} K_2) \\\\\n    K_4 &= \\mathcal{L} \\, (\\hat{q}_n + \\Delta t K_3) \\\\\n    \\hat{q}_{n+1} &= \\hat{q}_n + \\frac{\\Delta t}{6} (K_1 + 2K_2 + 2K_3 + K_4)\n\\end{align*}\nThis process is repeated for $N_t = 100$ steps with a time step of $\\Delta t=0.005$ to reach the final time $T=0.5$. The result is the numerical approximation of the spectrum at time $T$, denoted $\\hat{q}_{\\text{num}}(T)$. The physical-space solution $q_{\\text{num}}(x,y,T)$ is recovered by applying the inverse 2D FFT and taking the real part.\n\n**4. Analytical Solution**\n\nSince the ODE for each mode is linear with a constant coefficient $\\mathcal{L}$, the exact solution is given by:\n$$\n\\hat{q}(T) = \\hat{q}(0) \\exp(\\mathcal{L} T)\n$$\nThis analytical solution $\\hat{q}_{\\text{exact}}(T)$ is computed in a single step by multiplying the initial spectrum $\\hat{q}_0$ by the exponential factor. The corresponding physical field $q_{\\text{exact}}(x,y,T)$ is obtained via an inverse 2D FFT. This solution serves as the \"ground truth\" against which the RK4 numerical solution is compared.\n\n**5. Error Calculation**\n\nThe accuracy of the numerical simulation is quantified by calculating the error between the numerical solution $q_{\\text{num}}$ and the exact solution $q_{\\text{exact}}$ on the physical grid. Two standard error norms are used:\n- The $L^2$ error, which measures the root-mean-square difference:\n$$\nE_{2} = \\sqrt{ \\frac{1}{N^2} \\sum_{i,j} \\left( q_{\\text{num}}(x_i,y_j,T) - q_{\\text{exact}}(x_i,y_j,T) \\right)^2 }\n$$\n- The $L^{\\infty}$ error, which measures the maximum absolute difference at any grid point:\n$$\nE_{\\infty} = \\max_{i,j} \\left| q_{\\text{num}}(x_i,y_j,T) - q_{\\text{exact}}(x_i,y_j,T) \\right|\n$$\nThese steps are performed for each of the four test cases specified in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D advection-hyperdiffusion equation using a spectral method\n    and computes error norms against an analytical solution.\n    \"\"\"\n\n    def run_simulation(N, p, nu, u, v, L, x0, y0, sigma, T, dt):\n        \"\"\"\n        Runs a single simulation case.\n        \"\"\"\n        # 1. Setup Grid and Wavenumbers\n        dx = L / N\n        dy = L / N\n        x = np.arange(0, N) * dx\n        y = np.arange(0, N) * dy\n        xx, yy = np.meshgrid(x, y)\n\n        kx_vec = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        ky_vec = 2 * np.pi * np.fft.fftfreq(N, d=dy)\n        kx, ky = np.meshgrid(kx_vec, ky_vec)\n\n        # 2. Initial Condition\n        q0 = np.exp(-(((xx - x0)**2 + (yy - y0)**2) / (2 * sigma**2)))\n        q0_hat = np.fft.fft2(q0)\n\n        # 3. Define Spectral Operator and RHS for ODE\n        advection_op = -1j * (u * kx + v * ky)\n        k_sq = kx**2 + ky**2\n        \n        # Avoid issues with k=0 for p=0, though p is a positive integer here.\n        # Zero-wavenumber mode should not be diffused.\n        k_sq[0, 0] = 0\n        diffusion_op = -nu * (k_sq)**p\n        \n        spectral_op = advection_op + diffusion_op\n\n        def rhs(q_hat):\n            return spectral_op * q_hat\n\n        # 4. Time Integration (RK4) for Numerical Solution\n        q_num_hat = q0_hat.copy()\n        Nt = int(round(T / dt))\n        for _ in range(Nt):\n            k1 = rhs(q_num_hat)\n            k2 = rhs(q_num_hat + 0.5 * dt * k1)\n            k3 = rhs(q_num_hat + 0.5 * dt * k2)\n            k4 = rhs(q_num_hat + dt * k3)\n            q_num_hat += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        \n        q_num = np.real(np.fft.ifft2(q_num_hat))\n\n        # 5. Compute Analytical Solution\n        q_exact_hat = q0_hat * np.exp(spectral_op * T)\n        q_exact = np.real(np.fft.ifft2(q_exact_hat))\n\n        # 6. Compute Error Norms\n        diff = q_num - q_exact\n        e2 = np.sqrt(np.mean(diff**2))\n        e_inf = np.max(np.abs(diff))\n\n        return [e2, e_inf]\n\n    # Shared parameters for all test cases\n    L = 2.0 * np.pi\n    x0 = np.pi / 2.0\n    y0 = np.pi\n    sigma = 0.30\n    T = 0.50\n    dt = 0.005\n    u = 1.0\n    v = 0.5\n\n    # Test suite from the problem statement\n    test_cases = [\n        {'N': 64, 'p': 1, 'nu': 0.010},       # Case 1\n        {'N': 64, 'p': 2, 'nu': 0.00050},     # Case 2\n        {'N': 64, 'p': 4, 'nu': 1.0e-12},     # Case 3\n        {'N': 64, 'p': 1, 'nu': 0.0},         # Case 4 (p is irrelevant when nu=0)\n    ]\n\n    results = []\n    for case in test_cases:\n        e2, e_inf = run_simulation(\n            N=case['N'], p=case['p'], nu=case['nu'],\n            u=u, v=v, L=L, x0=x0, y0=y0, sigma=sigma, T=T, dt=dt\n        )\n        results.append(f\"[{e2},{e_inf}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}