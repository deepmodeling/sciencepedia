{
    "hands_on_practices": [
        {
            "introduction": "为了理解和控制模式的“自转调整”（spin-up）过程，我们首先需要一种严谨的方法来定义和量化动力不平衡。正规模分析为此提供了基本的理论框架，它将大气状态分解为平衡的“慢模态”和非平衡的“快模态”（惯性重力波）。 本练习将指导您计算线性化浅水模式的系统正规模，并用其对初始状态进行投影，从而量化初始场中存在于快速、非平衡模态中的动能比例。这个练习旨在建立对不平衡本质的基础理解。",
            "id": "4064940",
            "problem": "在科里奥利参数恒定的平面（$f$-平面）上的旋转浅水线性模型，为量化数值天气预报和气候模拟中模式初始化和启动控制期间的动力不平衡提供了一个基本基础。考虑围绕静止状态（平均流体深度为 $H$，表面高度扰动为 $\\eta$）的线性化旋转浅水方程：\n$$\n\\frac{\\partial u}{\\partial t} - f v = - g \\frac{\\partial \\eta}{\\partial x}, \\quad\n\\frac{\\partial v}{\\partial t} + f u = - g \\frac{\\partial \\eta}{\\partial y}, \\quad\n\\frac{\\partial \\eta}{\\partial t} + H \\left( \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} \\right) = 0,\n$$\n其中 $u$ 和 $v$ 是水平速度分量，$g$ 是重力加速度，$f$ 是科里奥利参数。对于具有波数矢量 $\\mathbf{k} = (k_x, k_y)$ 的单个空间傅里叶分量，将状态写为复傅里叶振幅 $\\hat{u}$、$\\hat{v}$ 和 $\\hat{\\eta}$，使得空间导数的作用等同于乘以 $i k_x$ 和 $i k_y$。其演化可以写成一个线性系统 $\\frac{d}{dt} \\mathbf{s} = A \\mathbf{s}$，其中 $\\mathbf{s} = [\\hat{u}, \\hat{v}, \\hat{\\eta}]^\\top$ 且\n$$\nA =\n\\begin{bmatrix}\n0  & f  & - g i k_x \\\\\n- f  & 0  & - g i k_y \\\\\n- H i k_x  & - H i k_y  & 0\n\\end{bmatrix}.\n$$\n简正模分解将此系统对角化。平衡子空间对应于零频率本征模，而不平衡快子空间对应于惯性重力本征模。驻留在快子空间中的动能分数是使用单个傅里叶分量的单位质量空间平均动能定义的，\n$$\nE_k = \\frac{1}{4}\\left( |\\hat{u}|^2 + |\\hat{v}|^2 \\right),\n$$\n快模贡献通过将初始状态投影到快本征子空间并保留其速度分量来计算。\n\n任务：实现一个程序，对于每个指定的测试用例，构造矩阵 $A$，计算其右本征分解，形成到快子空间（非零频率本征空间）的投影算子，将此投影应用于初始傅里叶状态 $\\mathbf{s}_0$，并返回快模态中的动能分数，定义为\n$$\n\\phi = \\frac{E_{k,\\text{fast}}}{E_{k,\\text{total}}},\n$$\n其中 $E_{k,\\text{fast}}$ 是快投影状态的动能，$E_{k,\\text{total}}$ 是初始状态的动能。如果 $E_{k,\\text{total}} = 0$，则返回 $0$。\n\n所有量必须按以下单位处理：速度分量 $u$ 和 $v$ 单位为 $\\text{m s}^{-1}$，表面高度扰动 $\\eta$ 单位为 $\\text{m}$，重力加速度 $g$ 单位为 $\\text{m s}^{-2}$，科里奥利参数 $f$ 单位为 $\\text{s}^{-1}$，波数 $k_x$ 和 $k_y$ 单位为 $\\text{m}^{-1}$。输入可能包括表示复傅里叶振幅的 $\\hat{u}$、$\\hat{v}$ 和 $\\hat{\\eta}$ 的复数项。\n\n使用以下测试套件。每个测试用例是一个元组 $(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta})$：\n\n$1.$ 具有混合平衡和不平衡内容的中纬度尺度：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 4\\times 10^{-6}, 3\\times 10^{-6}, 1.5, -0.5, 0.8).\n$$\n\n$2.$ 在给定波数下为满足地转关系而构建的纯平衡初始状态：\n$$\ng = 9.81, \\quad H = 10000, \\quad f = 10^{-4}, \\quad k_x = 4\\times 10^{-6}, \\quad k_y = 3\\times 10^{-6},\n$$\n与\n$$\n\\hat{\\eta} = 1.2, \\quad \\hat{u} = - i \\frac{g k_y}{f} \\hat{\\eta}, \\quad \\hat{v} = i \\frac{g k_x}{f} \\hat{\\eta}.\n$$\n\n$3.$ 零波数边界情况：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 0, 0, 0.7, 0.9, 2.0).\n$$\n\n$4.$ 高波数重力波主导的状态：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 2\\times 10^{-5}, 2\\times 10^{-5}, 0.2, -0.3, 0.05).\n$$\n\n$5.$ 波数极小且高度扰动可忽略的近惯性状态：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 10^{-7}, 0, 0.4, 0.4, 0.0).\n$$\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\phi_1,\\phi_2,\\phi_3,\\phi_4,\\phi_5]$），其中每个 $\\phi_j$ 是第 $j$ 个测试用例中快模态的动能分数，表示为小数。",
            "solution": "该问题要求计算线性化旋转浅水系统中包含在不平衡的快传播模态（惯性重力波）内的动能分数。这是数据同化和模式初始化中的一个基本程序，旨在滤除可能污染数值预报的高频振荡。该解决方案涉及将初始状态分解为其在系统简正模上的投影。\n\n傅里叶域中的控制线性系统由 $\\frac{d\\mathbf{s}}{dt} = A \\mathbf{s}$ 给出，其中状态向量为 $\\mathbf{s} = [\\hat{u}, \\hat{v}, \\hat{\\eta}]^\\top$，动力学矩阵为：\n$$\nA =\n\\begin{bmatrix}\n0  & f  & - g i k_x \\\\\n- f  & 0  & - g i k_y \\\\\n- H i k_x  & - H i k_y  & 0\n\\end{bmatrix}\n$$\n这里，$\\hat{u}$ 和 $\\hat{v}$ 是速度分量的复傅里叶振幅，$\\hat{\\eta}$ 是表面高度扰动的振幅，$f$ 是科里奥利参数，$g$ 是重力加速度，$H$ 是平均流体深度，$\\mathbf{k} = (k_x, k_y)$ 是波数矢量。数 $i$ 是虚数单位。\n\n系统的简正模是矩阵 $A$ 的本征向量。相关的本征值 $\\lambda$ 决定了这些模态的时间行为。特征方程 $\\det(A - \\lambda I) = 0$ 为：\n$$\n-\\lambda \\left( \\lambda^2 + f^2 + gH(k_x^2 + k_y^2) \\right) = 0\n$$\n这产生了三个不同的本征值，它们代表了缩放后的频率：\n$$\n\\lambda_1 = 0 \\quad \\text{(地转模或慢模)}\n$$\n$$\n\\lambda_{2,3} = \\pm i \\sqrt{f^2 + gHk^2} \\quad \\text{(惯性重力模或快模)}\n$$\n其中 $k = \\sqrt{k_x^2 + k_y^2}$ 是总波数。与 $\\lambda_1 = 0$ 相关的本征向量张成平衡子空间（或称慢子空间）。与 $\\lambda_{2,3} \\neq 0$（对于非平凡的 $f$ 或 $k$）相关的两个本征向量张成不平衡子空间（或称快子空间）。\n\n为了确定快模中的能量分数，我们必须将初始状态向量 $\\mathbf{s}_0$ 投影到快子空间上。$A$ 的一组右本征向量，记为 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，构成了状态空间 $\\mathbb{C}^3$ 的一个基。任何初始状态 $\\mathbf{s}_0$ 都可以唯一地表示为这些本征向量的线性组合：\n$$\n\\mathbf{s}_0 = c_1 \\mathbf{r}_1 + c_2 \\mathbf{r}_2 + c_3 \\mathbf{r}_3\n$$\n$\\mathbf{s}_0$ 在快子空间上的投影 $\\mathbf{s}_{\\text{fast}}$ 是总和中对应于快模的部分：\n$$\n\\mathbf{s}_{\\text{fast}} = c_2 \\mathbf{r}_2 + c_3 \\mathbf{r}_3\n$$\n系数 $c_j$ 是使用 $A$ 的一组左本征向量 $\\{\\mathbf{l}_j\\}$ 求得的，这些左本征向量与右本征向量是双正交的。如果归一化使得 $\\mathbf{l}_j^\\dagger \\mathbf{r}_k = \\delta_{jk}$（其中 $\\dagger$ 表示共轭转置，$\\delta_{jk}$ 是克罗内克 delta），则系数由投影 $c_j = \\mathbf{l}_j^\\dagger \\mathbf{s}_0$ 给出。\n\n在计算上，这个投影可以使用矩阵代数来实现。设 $R$ 是其列为右本征向量 $\\mathbf{r}_j$ 的矩阵。则系数向量 $\\mathbf{c} = [c_1, c_2, c_3]^\\top$ 可以通过 $\\mathbf{c} = R^{-1} \\mathbf{s}_0$ 求得。$R^{-1}$ 的行是共轭转置后的左本征向量 $\\mathbf{l}_j^\\dagger$。\n\n求 $\\mathbf{s}_{\\text{fast}}$ 的算法步骤如下：\n1.  对于给定的参数集 $(g, H, f, k_x, k_y)$，构造矩阵 $A$。\n2.  数值计算矩阵 $A$ 的本征值 $\\lambda_j$ 和右本征向量矩阵 $R$。\n3.  计算左本征向量矩阵 $L = R^{-1}$。\n4.  给定一个初始状态 $\\mathbf{s}_0 = [\\hat{u}_0, \\hat{v}_0, \\hat{\\eta}_0]^\\top$，计算系数向量 $\\mathbf{c} = L \\mathbf{s}_0$。\n5.  识别与快模对应的系数（即那些 $|\\lambda_j| > \\epsilon$ 的系数，其中 $\\epsilon$ 是一个小的数值容差）。构建一个新的系数向量 $\\mathbf{c}_{\\text{fast}}$，其中慢模的系数被设为零。\n6.  重构快投影状态向量：$\\mathbf{s}_{\\text{fast}} = R \\mathbf{c}_{\\text{fast}}$。设此向量为 $\\mathbf{s}_{\\text{fast}} = [\\hat{u}_{\\text{fast}}, \\hat{v}_{\\text{fast}}, \\hat{\\eta}_{\\text{fast}}]^\\top$。\n\n最后，我们计算所需的动能分数 $\\phi$。总初始动能为：\n$$\nE_{k,\\text{total}} = \\frac{1}{4}\\left( |\\hat{u}_0|^2 + |\\hat{v}_0|^2 \\right)\n$$\n投影的快模分量的动能为：\n$$\nE_{k,\\text{fast}} = \\frac{1}{4}\\left( |\\hat{u}_{\\text{fast}}|^2 + |\\hat{v}_{\\text{fast}}|^2 \\right)\n$$\n快模中的动能分数为：\n$$\n\\phi = \\frac{E_{k,\\text{fast}}}{E_{k,\\text{total}}}\n$$\n如果 $E_{k,\\text{total}} = 0$，问题规定应返回 $\\phi$ 为 $0$。此过程应用于每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    def calculate_phi(params):\n        \"\"\"\n        Calculates the fraction of kinetic energy in the fast modes for a single test case.\n\n        Args:\n            params: A tuple containing the physical parameters and initial state:\n                    (g, H, f, kx, ky, u_hat, v_hat, eta_hat)\n\n        Returns:\n            The fraction phi as a float.\n        \"\"\"\n        g, H, f, kx, ky = params[:5]\n        u_hat, v_hat, eta_hat = params[5:]\n\n        # For Test Case 2, u_hat and v_hat are defined by geostrophic balance\n        if isinstance(u_hat, str) and u_hat == 'geostrophic':\n            # Note: f cannot be zero for this case, which is true for the test suite.\n            u_hat = -1j * g * ky * eta_hat / f\n            v_hat = 1j * g * kx * eta_hat / f\n\n        u_hat, v_hat, eta_hat = complex(u_hat), complex(v_hat), complex(eta_hat)\n\n        s0 = np.array([u_hat, v_hat, eta_hat], dtype=complex)\n\n        # Calculate total initial kinetic energy\n        # The 1/4 factor cancels in the ratio, so we can omit it.\n        E_k_total = np.abs(u_hat)**2 + np.abs(v_hat)**2\n\n        # If total kinetic energy is zero, the fraction is zero.\n        if E_k_total  1e-12:\n            return 0.0\n\n        # Construct the matrix A\n        A = np.array([\n            [0, f, -1j * g * kx],\n            [-f, 0, -1j * g * ky],\n            [-1j * H * kx, -1j * H * ky, 0]\n        ], dtype=complex)\n\n        # Compute eigen-decomposition of A\n        # eigvals: eigenvalues\n        # R: right eigenvectors (as columns)\n        try:\n            eigvals, R = np.linalg.eig(A)\n        except np.linalg.LinAlgError:\n            # Handle cases where eigendecomposition might fail, though unlikely for this matrix.\n            return np.nan\n\n        # Compute the inverse of R to get the left eigenvectors\n        # The rows of L are the (conjugate transpose of) the left eigenvectors.\n        try:\n            L = np.linalg.inv(R)\n        except np.linalg.LinAlgError:\n            # Handle non-invertible R (degenerate eigenvectors), also unlikely.\n            return np.nan\n\n        # Project the initial state onto the eigenvectors to get the mode coefficients\n        # c = L @ s0\n        c = np.dot(L, s0)\n\n        # Identify fast modes (those with non-zero eigenvalues)\n        # and create a new coefficient vector for only the fast modes.\n        c_fast = np.zeros_like(c, dtype=complex)\n        # Use a small tolerance to identify the zero eigenvalue\n        fast_mode_indices = np.where(np.abs(eigvals) > 1e-9)[0]\n        c_fast[fast_mode_indices] = c[fast_mode_indices]\n\n        # Reconstruct the state vector component in the fast subspace\n        # s_fast = R @ c_fast\n        s_fast = np.dot(R, c_fast)\n        \n        u_fast, v_fast = s_fast[0], s_fast[1]\n\n        # Calculate the kinetic energy in the fast modes\n        E_k_fast = np.abs(u_fast)**2 + np.abs(v_fast)**2\n\n        # Return the fraction\n        phi = E_k_fast / E_k_total\n        return phi\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General midlatitude scales\n        (9.81, 10000, 1e-4, 4e-6, 3e-6, 1.5, -0.5, 0.8),\n        # Case 2: Purely balanced initial state\n        (9.81, 10000, 1e-4, 4e-6, 3e-6, 'geostrophic', 'geostrophic', 1.2),\n        # Case 3: Zero wavenumber\n        (9.81, 10000, 1e-4, 0, 0, 0.7, 0.9, 2.0),\n        # Case 4: High-wavenumber gravity-wave-dominated\n        (9.81, 10000, 1e-4, 2e-5, 2e-5, 0.2, -0.3, 0.05),\n        # Case 5: Near-inertial regime\n        (9.81, 10000, 1e-4, 1e-7, 0, 0.4, 0.4, 0.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_phi(case)\n        results.append(f\"{result:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在识别出不平衡之后，初始化的一个关键任务是调整模式场以达到平衡状态。一种被广泛应用于数据同化方案的强大技术是施加动力平衡约束，例如地转平衡。 在本练习中，您将通过求解相关的线性平衡方程（一个泊松方程），从给定的风场增量中推导出平衡的质量场增量。这项编程任务将演示如何从风场中滤除非地转的非平衡分量，从而获得一个地转协调的状态，以减弱模式的自转调整。",
            "id": "4064908",
            "problem": "考虑一个二维正压浅水模型，该模型建立在一个常数科里奥利参数平面（通常称为$f$平面）上，具有边长为$L$的方形周期性域和$N \\times N$个点的均匀网格。设水平风分量为$u(x,y)$和$v(x,y)$，质量场为高度$h(x,y)$。地转平衡用位势$\\Phi(x,y) = g h(x,y)$表示为$f \\,\\hat{\\mathbf{k}} \\times \\mathbf{v}_g = - \\nabla \\Phi$，其中$g$是重力加速度，$f$是常数科里奥利参数，$\\hat{\\mathbf{k}}$是垂直单位向量，$\\mathbf{v}_g = (u_g, v_g)$是地转风。假设在两个水平方向上都采用周期性边界条件，并忽略任何外部强迫或摩擦。\n\n给定一个分析的风增量$(\\delta u, \\delta v)$，定义相对涡度增量为$\\delta \\zeta = \\partial_x \\delta v - \\partial_y \\delta u$。证明由地转平衡所隐含的平衡质量场增量$\\delta h$满足泊松方程\n$$\n\\nabla^2 \\delta h = \\frac{f}{g} \\, \\delta \\zeta,\n$$\n并且从$\\delta h$重构的相应地转风增量为\n$$\n\\delta \\mathbf{v}_g = \\frac{g}{f} \\, \\hat{\\mathbf{k}} \\times \\nabla \\delta h = \\left( -\\frac{g}{f} \\, \\partial_y \\delta h \\,,\\, \\frac{g}{f} \\, \\partial_x \\delta h \\right).\n$$\n则非地转残差增量为$\\delta \\mathbf{v}_a = (\\delta u, \\delta v) - \\delta \\mathbf{v}_g$。为了量化与模式初始化和spin-up控制相关的不平衡，定义无量纲比率\n$$\nR = \\frac{\\sqrt{\\langle \\lvert \\delta \\mathbf{v}_a \\rvert^2 \\rangle}}{\\sqrt{\\langle \\lvert \\delta \\mathbf{v} \\rvert^2 \\rangle}},\n$$\n其中$\\langle \\cdot \\rangle$表示在周期性域上的空间平均，且$\\lvert \\delta \\mathbf{v} \\rvert^2 = (\\delta u)^2 + (\\delta v)^2$。\n\n实现一个程序，对于指定的测试用例，构造$(\\delta u, \\delta v)$，使用快速傅里叶变换 (FFT) 在周期性域上求解$\\delta h$的泊松方程，重构$\\delta \\mathbf{v}_g$，计算残差$\\delta \\mathbf{v}_a$，并为每个用例输出比率$R$。使用与周期性域一致的波数进行离散傅里叶变换，并将$\\delta h$的零波数模态设置为零（强制高度增量为零平均值）。将$R$表示为十进制浮点数。\n\n对所有测试用例使用以下参数值：\n- 网格大小：每个维度$N = 64$个点。\n- 域大小：$L = 10^6$米。\n- 科里奥利参数：$f = 10^{-4}$ s$^{-1}$。\n- 重力加速度：$g = 9.81$ m s$^{-2}$。\n\n构造三个测试用例，涵盖平衡、辐散和混合增量：\n1. 平衡、无辐散增量，由流函数$\\psi(x,y) = \\psi_0 \\cos(k_x x) \\cos(k_y y)$导出，振幅$\\psi_0 = 5000$ m$^2$ s$^{-1}$，其中$k_x = 2\\pi m_x / L$和$k_y = 2\\pi m_y / L$，且$m_x = 2$和$m_y = 3$。定义$\\delta u = -\\partial_y \\psi$和$\\delta v = \\partial_x \\psi$。\n2. 纯辐散、无旋增量，由速度势$\\chi(x,y) = \\chi_0 \\cos(k_x x) \\cos(k_y y)$导出，振幅$\\chi_0 = 5000$ m$^2$ s$^{-1}$，其中$m_x = 4$和$m_y = 1$。定义$\\delta u = \\partial_x \\chi$和$\\delta v = \\partial_y \\chi$。\n3. 混合增量，结合流函数$\\psi(x,y) = \\psi_0 \\cos(k_x x) \\cos(k_y y)$（$\\psi_0 = 3000$ m$^2$ s$^{-1}$且$(m_x,m_y) = (3,2)$）和速度势$\\chi(x,y) = \\chi_0 \\cos(k_x x) \\cos(k_y y)$（$\\chi_0 = 2000$ m$^2$ s$^{-1}$且$(m_x,m_y) = (1,5)$）。定义$(\\delta u, \\delta v)$为无辐散和无旋分量之和。\n\n要求：\n- 使用FFT在周期性域上以谱方法离散化导数并求解泊松方程。使用从FFT频率向量缩放$2\\pi$计算出的角波数$k_x$和$k_y$。对于泊松方程$\\nabla^2 \\delta h = \\frac{f}{g} \\delta \\zeta$，在谱空间中求解为$\\widehat{\\delta h}(\\mathbf{k}) = - \\widehat{F}(\\mathbf{k}) / \\lvert \\mathbf{k} \\rvert^2$（对于非零波数），其中$F = \\frac{f}{g} \\delta \\zeta$且$\\lvert \\mathbf{k} \\rvert^2 = k_x^2 + k_y^2$，并设置$\\widehat{\\delta h}(\\mathbf{0}) = 0$。\n- 使用FFT计算涡度的空间导数以及从$\\delta h$重构地转风，确保与周期性边界条件的一致性。\n- 对于每个测试用例，计算并报告比率$R$，形式为十进制浮点数（无量纲）。\n- 你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3]`）。\n\n无需外部输入；按上述规定硬编码参数和测试用例。最终输出量为无量纲比率；输出值无需附加物理单位。",
            "solution": "所提出的问题是地球物理流体力学中一个有效且适定的练习，具体涉及地转平衡的概念及其在数值模式初始化中的应用。我们的任务是在一个简化的模型框架中，量化给定风场增量的地转不平衡。问题的核心是推导并数值求解一个泊松方程，以找到与给定风场相对应的平衡质量场。\n\n首先，我们将提供控制方程的理论推导。随后，我们将概述使用基于快速傅里叶变换 (FFT) 的谱方法的数值实现，该方法适用于指定的周期性域。\n\n**理论推导**\n\n该问题的基础是地转平衡，它描述了科里奥利力与气压梯度力完全平衡的状态。对于场的增量变化，这种平衡用位势增量$\\delta \\Phi = g \\delta h$和地转风增量$\\delta \\mathbf{v}_g = (\\delta u_g, \\delta v_g)$表示：\n$$\nf \\,\\hat{\\mathbf{k}} \\times \\delta \\mathbf{v}_g = - \\nabla \\delta \\Phi\n$$\n其中$f$是科里奥利参数，$g$是重力加速度，$\\delta h$是高度增量，$\\hat{\\mathbf{k}}$是垂直方向的单位向量。展开叉积可得分量关系式：\n$$\n-f \\delta v_g = - \\partial_x (g \\delta h)\n$$\n$$\nf \\delta u_g = - \\partial_y (g \\delta h)\n$$\n求解地转风增量的分量可得：\n$$\n\\delta u_g = -\\frac{g}{f} \\partial_y \\delta h \\quad \\text{和} \\quad \\delta v_g = \\frac{g}{f} \\partial_x \\delta h\n$$\n这可以紧凑地写作$\\delta \\mathbf{v}_g = \\frac{g}{f} \\hat{\\mathbf{k}} \\times \\nabla \\delta h$，这证实了问题陈述中为重构的地转风增量提供的表达式。\n\n接下来，我们推导高度增量$\\delta h$的泊松方程。这种“线性平衡”程序的基本假设是，平衡流（由地转风$\\delta \\mathbf{v}_g$表示）的涡度必须等于给定的总风增量$\\delta \\mathbf{v} = (\\delta u, \\delta v)$的涡度。\n\n总风增量的涡度定义为$\\delta \\zeta = \\partial_x \\delta v - \\partial_y \\delta u$。\n地转风增量的涡度（记作$\\delta \\zeta_g$）通过代入$\\delta u_g$和$\\delta v_g$的表达式计算得出：\n$$\n\\delta \\zeta_g = \\partial_x (\\delta v_g) - \\partial_y (\\delta u_g) = \\partial_x \\left(\\frac{g}{f} \\partial_x \\delta h\\right) - \\partial_y \\left(-\\frac{g}{f} \\partial_y \\delta h\\right)\n$$\n由于$f$和$g$是常数，我们有：\n$$\n\\delta \\zeta_g = \\frac{g}{f} \\left(\\frac{\\partial^2 \\delta h}{\\partial x^2} + \\frac{\\partial^2 \\delta h}{\\partial y^2}\\right) = \\frac{g}{f} \\nabla^2 \\delta h\n$$\n通过令地转涡度等于总涡度，即$\\delta \\zeta_g = \\delta \\zeta$，我们建立了定义平衡高度场的关系：\n$$\n\\frac{g}{f} \\nabla^2 \\delta h = \\delta \\zeta\n$$\n重新整理此方程，得到所需的平衡质量场增量$\\delta h$的泊松方程：\n$$\n\\nabla^2 \\delta h = \\frac{f}{g} \\delta \\zeta\n$$\n\n**数值方法**\n\n该问题设定在一个方形、双周期域上，这使得基于二维快速傅里叶变换 (FFT) 的谱方法成为数值求解的理想选择。对于微分和求解泊松方程，它们计算效率高且具有谱精度。\n\n网格上的连续场$A(x,y)$由一个离散的$N \\times N$数组表示。其二维离散傅里叶变换记作$\\hat{A}(k_x, k_y)$。傅里叶变换的关键性质是空间导数在谱空间中变为代数乘法：\n$$\n\\widehat{\\frac{\\partial A}{\\partial x}} = i k_x \\hat{A} \\quad \\text{和} \\quad \\widehat{\\frac{\\partial A}{\\partial y}} = i k_y \\hat{A}\n$$\n其中$k_x$和$k_y$是角波数。这些波数是根据`numpy.fft.fftfreq`提供的离散频率构建的。\n\n对于每个测试用例，求解算法如下：\n1.  **构建输入场**：使用给定的流函数和/或速度势，在$N \\times N$离散网格上解析地定义风增量$(\\delta u, \\delta v)$。\n2.  **计算涡度**：以谱方法计算涡度增量$\\delta \\zeta = \\partial_x \\delta v - \\partial_y \\delta u$。我们首先计算$\\delta u$和$\\delta v$的二维FFT得到$\\widehat{\\delta u}$和$\\widehat{\\delta v}$。然后，涡度的变换$\\widehat{\\delta \\zeta}$计算如下：\n    $$\n    \\widehat{\\delta \\zeta}(k_x, k_y) = i k_x \\widehat{\\delta v}(k_x, k_y) - i k_y \\widehat{\\delta u}(k_x, k_y)\n    $$\n3.  **求解泊松方程**：泊松方程$\\nabla^2 \\delta h = \\frac{f}{g} \\delta \\zeta$在谱域中转化为一个代数方程：\n    $$\n    -(k_x^2 + k_y^2) \\widehat{\\delta h} = \\frac{f}{g} \\widehat{\\delta \\zeta}\n    $$\n    我们求解高度增量的谱系数$\\widehat{\\delta h}$：\n    $$\n    \\widehat{\\delta h}(k_x, k_y) = - \\frac{f}{g} \\frac{\\widehat{\\delta \\zeta}(k_x, k_y)}{k_x^2 + k_y^2}\n    $$\n    对于零波数模态$(k_x, k_y) = (0,0)$，分母为零。按照规定，我们设置$\\widehat{\\delta h}(0,0) = 0$，这强制高度增量的空间平均值为零，即$\\langle \\delta h \\rangle = 0$。此条件确保了唯一解，并且是有效的，因为在周期性域上，右侧的空间平均值$\\langle \\delta \\zeta \\rangle$保证为零。\n4.  **重构地转风**：从计算出的$\\delta h$重构平衡地转风增量$\\delta \\mathbf{v}_g$。为保持一致性，这也以谱方法完成。我们首先通过求解泊松方程计算$\\widehat{\\delta h}$，然后找到其谱分量：\n    $$\n    \\widehat{\\delta u_g} = -\\frac{g}{f} (i k_y \\widehat{\\delta h}) \\quad \\text{和} \\quad \\widehat{\\delta v_g} = \\frac{g}{f} (i k_x \\widehat{\\delta h})\n    $$\n    对$\\widehat{\\delta u_g}$和$\\widehat{\\delta v_g}$进行逆二维FFT，得到实空间场$(\\delta u_g, \\delta v_g)$。\n5.  **计算不平衡比率**：非地转残差增量为$\\delta \\mathbf{v}_a = \\delta \\mathbf{v} - \\delta \\mathbf{v}_g$。不平衡比率$R$则计算为非地转风增量和总风增量的均方根大小之比：\n    $$\n    R = \\frac{\\sqrt{\\langle (\\delta u_a)^2 + (\\delta v_a)^2 \\rangle}}{\\sqrt{\\langle (\\delta u)^2 + (\\delta v)^2 \\rangle}}\n    $$\n    其中$\\langle \\cdot \\rangle$表示所有网格点的平均值。\n\n**测试用例的预期结果**\n*   **情况1（平衡）**：输入风场是纯旋转的（无辐散），由流函数$\\psi$导出。如验证思路所示，线性平衡方程通过$\\delta h = (f/g)\\psi$完美地将$\\delta h$与$\\psi$联系起来。重构的地转风$\\delta \\mathbf{v}_g$将与输入风$\\delta \\mathbf{v}$相同。因此，非地转残差$\\delta \\mathbf{v}_a$将为零，我们预期$R \\approx 0$（在数值精度范围内）。\n*   **情况2（辐散）**：输入风是纯辐散的（无旋），由速度势$\\chi$导出。其涡度$\\delta \\zeta$恒为零。$\\nabla^2 \\delta h = 0$在零平均值条件下的解是$\\delta h = 0$。因此，重构的地转风$\\delta \\mathbf{v}_g$为零。非地转残差就是整个输入风，$\\delta \\mathbf{v}_a = \\delta \\mathbf{v}$。因此，我们预期$R=1$。\n*   **情况3（混合）**：输入风是旋转和辐散分量的和，$\\delta \\mathbf{v} = \\mathbf{v}_\\psi + \\mathbf{v}_\\chi$。平衡过程只“看到”来自旋转部分$\\mathbf{v}_\\psi$的涡度。它将重构出$\\delta \\mathbf{v}_g = \\mathbf{v}_\\psi$。非地转残差将是纯辐散部分，$\\delta \\mathbf{v}_a = \\mathbf{v}_\\chi$。因此，比率$R$将是辐散分量的能量与总风能量的比值，其值介于0和1之间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the geostrophic imbalance ratio R for three test cases\n    of wind increments in a shallow-water model on a periodic f-plane.\n    \"\"\"\n    # Define physical and numerical-grid constants\n    N = 64\n    L = 1.0e6  # meters\n    f = 1.0e-4  # s^-1\n    g = 9.81  # m/s^2\n\n    # Set up the computational grid and wavenumbers\n    # The grid spacing dx is the same for both dimensions.\n    dx = L / N\n    # Create a 1D coordinate array.\n    x = np.arange(N) * dx\n    # Create 2D coordinate grids. The 'xy' indexing is the default and standard for\n    # ensuring that axis 0 corresponds to the y-dimension and axis 1 to the x-dimension.\n    # xx[i, j] = x[j], yy[i, j] = x[i]\n    xx, yy = np.meshgrid(x, x, indexing='xy')\n\n    # Create 1D array of angular wavenumbers.\n    k_freq = np.fft.fftfreq(N, d=dx)\n    k = 2 * np.pi * k_freq\n    # Create 2D wavenumber grids corresponding to the coordinate grids.\n    # kxx corresponds to differentiation along axis 1 (x).\n    # kyy corresponds to differentiation along axis 0 (y).\n    kxx, kyy = np.meshgrid(k, k, indexing='xy')\n    \n    # Squared total wavenumber.\n    ksq = kxx**2 + kyy**2\n\n    # Define the parameters for the three test cases.\n    test_cases = [\n        # Case 1: Purely balanced (nondivergent) flow.\n        {'psi_params': {'amp': 5000.0, 'mx': 2, 'my': 3}, 'chi_params': None},\n        # Case 2: Purely divergent (irrotational) flow.\n        {'psi_params': None, 'chi_params': {'amp': 5000.0, 'mx': 4, 'my': 1}},\n        # Case 3: Mixed flow with both rotational and divergent components.\n        {\n            'psi_params': {'amp': 3000.0, 'mx': 3, 'my': 2},\n            'chi_params': {'amp': 2000.0, 'mx': 1, 'my': 5}\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Initialize wind increments to zero.\n        du = np.zeros((N, N), dtype=float)\n        dv = np.zeros((N, N), dtype=float)\n\n        # Construct the total wind increment (du, dv) by summing components.\n        # Rotational (nondivergent) component from streamfunction psi.\n        if case['psi_params']:\n            p = case['psi_params']\n            psi0, mx, my = p['amp'], p['mx'], p['my']\n            kx_an = 2 * np.pi * mx / L\n            ky_an = 2 * np.pi * my / L\n            # du = -d/dy(psi)\n            du += psi0 * ky_an * np.cos(kx_an * xx) * np.sin(ky_an * yy)\n            # dv = d/dx(psi)\n            dv -= psi0 * kx_an * np.sin(kx_an * xx) * np.cos(ky_an * yy)\n        \n        # Divergent (irrotational) component from velocity potential chi.\n        if case['chi_params']:\n            c = case['chi_params']\n            chi0, mx, my = c['amp'], c['mx'], c['my']\n            kx_an = 2 * np.pi * mx / L\n            ky_an = 2 * np.pi * my / L\n            # du = d/dx(chi)\n            du -= chi0 * kx_an * np.sin(kx_an * xx) * np.cos(ky_an * yy)\n            # dv = d/dy(chi)\n            dv -= chi0 * ky_an * np.cos(kx_an * xx) * np.sin(ky_an * yy)\n\n        # Compute vorticity spectrally\n        du_hat = np.fft.fft2(du)\n        dv_hat = np.fft.fft2(dv)\n        dzeta_hat = 1j * kxx * dv_hat - 1j * kyy * du_hat\n        \n        # Solve the Poisson equation for the height increment in spectral space.\n        # Equation: -(kxx^2 + kyy^2) * dh_hat = (f/g) * dzeta_hat\n        dh_hat = np.zeros_like(dzeta_hat)\n        # Avoid division by zero at k=0 by using a mask.\n        non_zero_k = ksq != 0\n        dh_hat[non_zero_k] = (f / g) * dzeta_hat[non_zero_k] / (-ksq[non_zero_k])\n        # The mean height is set to zero by ensuring dh_hat[0, 0] = 0.\n\n        # Reconstruct the geostrophic wind increment in spectral space.\n        # dug_hat = -(g/f) * 1j * kyy * dh_hat\n        # dvg_hat = (g/f) * 1j * kxx * dh_hat\n        dug_hat = (-g / f) * 1j * kyy * dh_hat\n        dvg_hat = (g / f) * 1j * kxx * dh_hat\n        \n        # Transform geostrophic winds back to real space.\n        du_g = np.real(np.fft.ifft2(dug_hat))\n        dv_g = np.real(np.fft.ifft2(dvg_hat))\n        \n        # Compute the ageostrophic residual increment.\n        du_a = du - du_g\n        dv_a = dv - dv_g\n        \n        # Calculate the imbalance ratio R.\n        # Mean squared magnitude of the ageostrophic wind.\n        mean_sq_va = np.mean(du_a**2 + dv_a**2)\n        # Mean squared magnitude of the total wind.\n        mean_sq_v = np.mean(du**2 + dv**2)\n        \n        if mean_sq_v  1e-16: # Avoid division by zero for null fields\n            R = 0.0\n        else:\n            R = np.sqrt(mean_sq_va / mean_sq_v)\n            \n        results.append(R)\n\n    # Format and print the final results as specified.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了强制施加平衡约束外，另一种减少自转调整的常用方法是通过谱滤波直接去除高频运动。虽然这种方法能有效抑制虚假的重力波，但它并非没有代价，因为它可能无意中消除具有物理意义的小尺度特征。 本练习将初始化问题构建为一个权衡（trade-off）问题，您将数值评估一个谱滤波器如何同时影响“噪声”（不想要的高波数能量）和“信号”（可分辨的中尺度方差）。通过构建一个简化的“预报技巧”代理，此练习揭示了在最大化噪声去除的同时最小化对有用信号损害这一关键挑战。",
            "id": "4064937",
            "problem": "您的任务是形式化谱初始化滤波对中尺度方差的影响，并利用一个简单的预报技巧代理推导出一个定量的权衡关系。考虑一个长度为 $L$（单位为 $\\text{km}$）的一维周期性域，该域被离散化为 $N$ 个等距网格点。令 $k$ 表示由该域的离散傅里叶模构建的单边角波数，单位为 $\\text{rad}/\\text{km}$。假设初始单位波数的能量谱由物理上合理的函数形式 $E(k) = C_0 \\, k^{-\\beta} \\exp\\!\\big(- (k / k_d)^{\\gamma} \\big)$ 给出，其中 $C_0$ 是一个正常数，$k_d$ 是一个耗散尺度波数，$\\beta$ 和 $\\gamma$ 是正的形状参数。一个初始化滤波器在谱空间中乘法地应用于预报变量的振幅，其传递函数为 $G(k; s, k_c, p) = \\exp\\!\\big( - s \\, (k/k_c)^p \\big)$，其中 $s \\ge 0$ 是滤波强度，$k_c$ 是一个特征截止波数，$p  0$ 控制衰减的锐度。根据谱空间中方差的定义和傅里叶空间中滤波的线性性质，滤波后的方差密度变为 $E(k) \\, G(k)^2$。\n\n定义中尺度波段的波长为 $\\lambda \\in [\\lambda_{\\min}, \\lambda_{\\max}]$（单位为 $\\text{km}$），对应的波数为 $k \\in [2\\pi/\\lambda_{\\max}, 2\\pi/\\lambda_{\\min}]$。由于滤波导致的中尺度方差分数损失为\n$$\nL_{\\text{meso}}(s) = 1 - \\frac{\\int_{k \\in [2\\pi/\\lambda_{\\max}, \\, 2\\pi/\\lambda_{\\min}]} E(k) \\, G(k)^2 \\, \\mathrm{d}k}{\\int_{k \\in [2\\pi/\\lambda_{\\max}, \\, 2\\pi/\\lambda_{\\min}]} E(k) \\, \\mathrm{d}k}.\n$$\n定义噪声波段的波长为 $\\lambda \\le \\lambda_{\\text{noise}}$，对应的波数为 $k \\ge 2\\pi/\\lambda_{\\text{noise}}$。通过滤波移除的噪声方差分数为\n$$\nR_{\\text{noise-removed}}(s) = 1 - \\frac{\\int_{k \\ge 2\\pi/\\lambda_{\\text{noise}}} E(k) \\, G(k)^2 \\, \\mathrm{d}k}{\\int_{k \\ge 2\\pi/\\lambda_{\\text{noise}}} E(k) \\, \\mathrm{d}k}.\n$$\n定义一个简单的预报技巧代理，以反映保留中尺度信号和移除高波数噪声之间的权衡：\n$$\nS_{\\text{skill}}(s; w) = w \\, \\big(1 - L_{\\text{meso}}(s)\\big) + (1-w) \\, R_{\\text{noise-removed}}(s),\n$$\n其中 $w \\in [0,1]$ 是一个权重，用于设定保留中尺度信号与抑制噪声的相对重要性。\n\n从谱空间中方差的定义和线性滤波器傅里叶变换的基本性质（波数空间中的乘法传递函数）出发，使用单边波数网格上的离散和实现数值近似，以计算下面指定的参数集的 $L_{\\text{meso}}(s)$ 和 $S_{\\text{skill}}(s; w)$。将积分视为离散波数上的黎曼和，这样相同的均匀波数间距在比率中可以被抵消。确保任何分母为零的情况都通过为相应分数返回 $0$ 来处理。所有答案必须表示为小数（而非百分比）。\n\n使用以下参数集测试套件，每个参数集指定 $(L, N, C_0, \\beta, \\gamma, k_d, s, k_c, p, \\lambda_{\\min}, \\lambda_{\\max}, \\lambda_{\\text{noise}}, w)$，其中 $k_d$ 和 $k_c$ 的单位是 $\\text{rad}/\\text{km}$，波长的单位是 $\\text{km}$：\n\n- 情况 1：$(L = 10000, N = 4096, C_0 = 1.0, \\beta = 2.5, \\gamma = 1.0, k_d = 2\\pi/15, s = 1.0, k_c = 2\\pi/50, p = 2, \\lambda_{\\min} = 20, \\lambda_{\\max} = 200, \\lambda_{\\text{noise}} = 10, w = 0.6)$。\n- 情况 2：$(L = 10000, N = 4096, C_0 = 1.0, \\beta = 2.5, \\gamma = 1.0, k_d = 2\\pi/15, s = 0.0, k_c = 2\\pi/50, p = 2, \\lambda_{\\min} = 20, \\lambda_{\\max} = 200, \\lambda_{\\text{noise}} = 10, w = 0.6)$。\n- 情况 3：$(L = 10000, N = 4096, C_0 = 1.0, \\beta = 2.5, \\gamma = 1.0, k_d = 2\\pi/15, s = 5.0, k_c = 2\\pi/50, p = 2, \\lambda_{\\min} = 20, \\lambda_{\\max} = 200, \\lambda_{\\text{noise}} = 10, w = 0.6)$。\n- 情况 4：$(L = 10000, N = 1024, C_0 = 1.0, \\beta = 2.5, \\gamma = 1.0, k_d = 2\\pi/15, s = 1.5, k_c = 2\\pi/150, p = 2, \\lambda_{\\min} = 20, \\lambda_{\\max} = 200, \\lambda_{\\text{noise}} = 10, w = 0.6)$。\n\n您的程序应为每种情况计算有序对 $[L_{\\text{meso}}(s), S_{\\text{skill}}(s; w)]$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素本身必须是一个由两个小数组成的列表，对应于 $[L_{\\text{meso}}, S_{\\text{skill}}]$。例如，一个有效的最终输出格式是 $[[x_1, y_1],[x_2, y_2],[x_3, y_3],[x_4, y_4]]$。",
            "solution": "该计算基于谱空间中方差的定义以及线性滤波器在傅里叶空间中具有乘法性质的特性。考虑一个长度为 $L$ 的一维周期性域，离散为 $N$ 个点，间距为 $d = L/N$。单位为 $\\text{rad}/\\text{km}$ 的单边波数网格由离散傅里叶变换的非负频率得到，即 $k_n = 2\\pi f_n$，其中 $f_n$ 是单位为 周/$\\text{km}$ 的单边离散频率，由 $f_n = n/L$ 给出，其中整数 $n \\in \\{0,1,2,\\dots,N/2\\}$。\n\n能量谱 $E(k)$ 提供了单位波数的方差。对于任何波数带 $B \\subset [0, \\infty)$，该带内包含的方差与积分 $\\int_B E(k) \\, \\mathrm{d}k$ 成正比。在均匀的离散波数网格上，该积分通过黎曼和来近似，并且当在同一网格上计算此类积分的比率时，均匀的间距会相互抵消，从而允许使用 $E(k)$ 在相应指数上的简单求和。\n\n具有传递函数 $G(k; s, k_c, p) = \\exp\\!\\big( - s \\, (k/k_c)^p \\big)$ 的初始化谱滤波器将傅里叶模的振幅衰减 $G(k)$，因此将方差（与振幅成二次关系）衰减 $G(k)^2$。因此，滤波后的方差密度为 $E(k) \\, G(k)^2$，在一个波段 $B$ 内的保留分数为\n$$\nR_B(s) = \\frac{\\int_B E(k) \\, G(k)^2 \\, \\mathrm{d}k}{\\int_B E(k) \\, \\mathrm{d}k}.\n$$\n中尺度波段的方差损失为 $L_{\\text{meso}}(s) = 1 - R_{\\text{meso}}(s)$，其中波数空间中的中尺度波段为 $B_{\\text{meso}} = \\big[2\\pi/\\lambda_{\\max}, \\, 2\\pi/\\lambda_{\\min}\\big]$，由波长边界 $\\lambda_{\\min}$ 和 $\\lambda_{\\max}$ 推导得出。噪声波段为 $B_{\\text{noise}} = \\big[2\\pi/\\lambda_{\\text{noise}}, \\, \\infty)$，通过滤波移除的噪声方差分数为 $R_{\\text{noise-removed}}(s) = 1 - R_{B_{\\text{noise}}}(s)$。\n\n为了将这些量与预报技巧代理联系起来，我们假设技巧随着中尺度方差的保留和噪声方差的移除而增加。一个简单的凸组合模型可以描述这种权衡：\n$$\nS_{\\text{skill}}(s; w) = w \\, \\big(1 - L_{\\text{meso}}(s)\\big) + (1-w) \\, R_{\\text{noise-removed}}(s),\n$$\n当其构成分数位于 $[0,1]$ 且 $w \\in [0,1]$ 时，该值位于 $[0,1]$ 区间内。\n\n算法步骤：\n1. 使用 $k = 2\\pi \\, f$ 构建单位为 $\\text{rad}/\\text{km}$ 的单边波数数组 $k$，其中 $f$ 是单边离散频率 $f_n = n/L$，$n = 0,\\dots,\\lfloor N/2 \\rfloor$。在计算 $E(k)$ 时排除 $k = 0$ 以避免 $k^{-\\beta}$ 在 $k=0$ 处的奇点；如果需要，设置 $E(0) = 0$。\n2. 计算初始谱 $E(k) = C_0 \\, k^{-\\beta} \\exp\\!\\big(- (k / k_d)^{\\gamma} \\big)$。所有参数 $C_0$、$\\beta$、$\\gamma$ 和 $k_d$ 均为正，确保对于 $k  0$ 时谱是有限的，并具有真实的高波数衰减。\n3. 对所有 $k$ 计算滤波器传递函数 $G(k; s, k_c, p) = \\exp\\!\\big( - s \\, (k/k_c)^p \\big)$。\n4. 推导中尺度波段的波数边界：$k_{\\min,\\text{meso}} = 2\\pi/\\lambda_{\\max}$ 和 $k_{\\max,\\text{meso}} = 2\\pi/\\lambda_{\\min}$。为 $k \\in [k_{\\min,\\text{meso}}, k_{\\max,\\text{meso}}]$ 构建布尔掩码。\n5. 推导噪声波段的波数阈值：$k_{\\min,\\text{noise}} = 2\\pi/\\lambda_{\\text{noise}}$。为 $k \\ge k_{\\min,\\text{noise}}$ 构建掩码。\n6. 使用掩码索引上的和计算滤波前波段方差：$V_{\\text{meso, pre}} = \\sum_{k \\in B_{\\text{meso}}} E(k)$ 和 $V_{\\text{noise, pre}} = \\sum_{k \\in B_{\\text{noise}}} E(k)$。计算滤波后波段方差：$V_{\\text{meso, post}} = \\sum_{k \\in B_{\\text{meso}}} E(k) \\, G(k)^2$ 和 $V_{\\text{noise, post}} = \\sum_{k \\in B_{\\text{noise}}} E(k) \\, G(k)^2$。\n7. 形成保留分数 $R_{\\text{meso}} = V_{\\text{meso, post}} / V_{\\text{meso, pre}}$ 和 $R_{\\text{noise}} = V_{\\text{noise, post}} / V_{\\text{noise, pre}}$，约定当分母为 $0$ 时返回 $0$。\n8. 计算 $L_{\\text{meso}} = 1 - R_{\\text{meso}}$ 和 $R_{\\text{noise-removed}} = 1 - R_{\\text{noise}}$。\n9. 计算 $S_{\\text{skill}}(s; w) = w \\, (1 - L_{\\text{meso}}) + (1 - w) \\, R_{\\text{noise-removed}}$。\n10. 对每个测试用例重复步骤 $1$–$9$，并在单行上输出列表 $[[L_{\\text{meso}}^{(1)}, S_{\\text{skill}}^{(1)}], \\dots, [L_{\\text{meso}}^{(4)}, S_{\\text{skill}}^{(4)}]]$。\n\n此过程遵循基本的光谱分析原理：通过能量谱 $E(k)$ 进行方差分解，以及线性滤波器在傅里叶空间中的乘法作用，这与帕塞瓦尔定理和模式初始化滤波的标准处理方法一致。这些测试用例探讨了典型和边缘条件：无滤波（$s = 0$）作为基准，截止波数在中尺度波段之外的中等滤波，严重衰减较高波数的强滤波，以及将截止波数置于中尺度波段内并结合更粗分辨率以探测对滤波器位置和网格分辨率的敏感性。所有输出均为无量纲的小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(L_km, N, C0, beta, gamma, kd_rad_per_km, s, kc_rad_per_km, p, lam_min_km, lam_max_km, lam_noise_km, w):\n    # One-sided wavenumber grid in rad/km using rfftfreq (one-sided nonnegative frequencies).\n    # rfftfreq returns cycles per unit length; multiply by 2*pi to get angular wavenumber (rad per unit length).\n    dx = L_km / N\n    freqs = np.fft.rfftfreq(N, d=dx)  # cycles/km\n    k = 2.0 * np.pi * freqs           # rad/km\n\n    # Exclude k=0 for spectrum calculation to avoid singularity in k**(-beta). Set its energy to zero separately.\n    # Build spectrum E(k) = C0 * k^{-beta} * exp(-(k/kd)^gamma)\n    E = np.zeros_like(k)\n    # Handle k > 0\n    kpos_mask = k > 0\n    kpos = k[kpos_mask]\n    E_kpos = C0 * (kpos ** (-beta)) * np.exp(- (kpos / kd_rad_per_km) ** gamma)\n    E[kpos_mask] = E_kpos\n    # E at k=0 remains 0\n\n    # Filter transfer function G(k) = exp(- s * (k/kc)^p)\n    # Define G(0) = 1 (no attenuation at zero wavenumber)\n    G = np.ones_like(k)\n    if kc_rad_per_km = 0 or p = 0:\n        # Degenerate filter parameters: no filtering\n        pass\n    else:\n        G[kpos_mask] = np.exp(- s * (kpos / kc_rad_per_km) ** p)\n\n    # Mesoscale band masks\n    k_meso_min = 2.0 * np.pi / lam_max_km\n    k_meso_max = 2.0 * np.pi / lam_min_km\n    meso_mask = (k >= k_meso_min)  (k = k_meso_max)\n\n    # Noise band mask: wavelengths = lam_noise_km => k >= 2*pi/lam_noise\n    k_noise_min = 2.0 * np.pi / lam_noise_km\n    noise_mask = k >= k_noise_min\n\n    # Compute band variances via sums (uniform k-spacing cancels in ratios)\n    V_meso_pre = E[meso_mask].sum()\n    V_meso_post = (E[meso_mask] * (G[meso_mask] ** 2)).sum()\n\n    V_noise_pre = E[noise_mask].sum()\n    V_noise_post = (E[noise_mask] * (G[noise_mask] ** 2)).sum()\n\n    # Retained fractions with safe handling of zero denominators\n    R_meso = V_meso_post / V_meso_pre if V_meso_pre > 0 else 0.0\n    R_noise = V_noise_post / V_noise_pre if V_noise_pre > 0 else 0.0\n\n    # Loss of mesoscale variance and noise removed fraction\n    L_meso = 1.0 - R_meso\n    R_noise_removed = 1.0 - R_noise\n\n    # Skill proxy\n    S_skill = w * (1.0 - L_meso) + (1.0 - w) * R_noise_removed\n\n    return L_meso, S_skill\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L, N, C0, beta, gamma, kd, s, kc, p, lambda_min, lambda_max, lambda_noise, w)\n    two_pi = 2.0 * np.pi\n    test_cases = [\n        (10000.0, 4096, 1.0, 2.5, 1.0, two_pi/15.0, 1.0, two_pi/50.0, 2.0, 20.0, 200.0, 10.0, 0.6),\n        (10000.0, 4096, 1.0, 2.5, 1.0, two_pi/15.0, 0.0, two_pi/50.0, 2.0, 20.0, 200.0, 10.0, 0.6),\n        (10000.0, 4096, 1.0, 2.5, 1.0, two_pi/15.0, 5.0, two_pi/50.0, 2.0, 20.0, 200.0, 10.0, 0.6),\n        (10000.0, 1024, 1.0, 2.5, 1.0, two_pi/15.0, 1.5, two_pi/150.0, 2.0, 20.0, 200.0, 10.0, 0.6),\n    ]\n\n    results = []\n    for case in test_cases:\n        L_km, N, C0, beta, gamma, kd, s, kc, p, lam_min, lam_max, lam_noise, w = case\n        L_meso, S_skill = compute_metrics(\n            L_km=L_km,\n            N=N,\n            C0=C0,\n            beta=beta,\n            gamma=gamma,\n            kd_rad_per_km=kd,\n            s=s,\n            kc_rad_per_km=kc,\n            p=p,\n            lam_min_km=lam_min,\n            lam_max_km=lam_max,\n            lam_noise_km=lam_noise,\n            w=w\n        )\n        results.append([float(L_meso), float(S_skill)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        }
    ]
}