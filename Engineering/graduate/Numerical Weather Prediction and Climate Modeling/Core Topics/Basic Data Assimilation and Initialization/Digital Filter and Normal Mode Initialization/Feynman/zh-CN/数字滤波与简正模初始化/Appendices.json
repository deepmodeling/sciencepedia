{
    "hands_on_practices": [
        {
            "introduction": "为了应用正规模初始化，我们首先需要理解这些模式是如何在数值模型中定义和计算的。本练习将指导您完成一个基础但至关重要的任务：为一个简化的、具有恒定层结的大气模型构建离散的垂直本征值问题。通过将连续的理论方程转化为一个可解的矩阵问题，您将亲手计算出模型的垂直模态，这些模态构成了正规模初始化的基本单元。这个实践将理论与数值模型的实际实现联系起来，为您展示“快速”和“慢速”模式的数学根源。",
            "id": "4031276",
            "problem": "考虑在数值天气预报 (NWP) 和气候模拟中，静力近似和布辛涅斯克近似下的小振幅线性内重力波的垂直结构。在地表和模式顶部为恒定层结和刚盖边界的最简单情况下，垂直结构简化为一维 Sturm–Liouville 边界值问题。该框架是正常模态初始化 (NMI) 的基础，NMI 将初始条件分解为具有物理意义的模态，并用于设计选择性衰减快模态的数字滤波器。\n\n从与刚盖边界条件相关的一维垂直二阶常微分算子出发，在区间 $[0,H]$上（其中 $H$ 为模式顶部高度）构建连续特征值问题。然后，在 $K$ 个内部层上使用均匀网格的中心二阶有限差分格式，并在 $z=0$ 和 $z=H$ 处使用齐次狄利克雷边界条件，构建一个离散对应项。您的任务是：\n\n1. 推导垂直模态的连续边界值问题，将其表述为函数 $y(z)$ 在 $[0,H]$ 上的特征值问题，并附带适当的边界条件。解释边界条件如何从刚盖假设和垂直速度的连续性中产生。\n2. 在 $K$ 个内部层上，使用中心有限差分公式对二阶导数进行离散化，网格间距为 $\\Delta z = H/(K+1)$，并在端点处采用齐次狄利克雷边界条件。构建生成的 $K \\times K$ 三对角矩阵，并写出其定义的离散特征值问题。\n3. 对每个离散特征对，通过数值方法获得特征值和特征向量。通过按升序排列特征值，将第 $m$ 个离散特征对与第 $m$ 个连续模态关联起来。\n4. 通过比较以下内容来量化离散化误差：\n   - 特征值：计算相对误差 $\\epsilon_{\\lambda}(m) = \\left(\\lambda_{d}(m) - \\lambda_{c}(m)\\right)/\\lambda_{c}(m)$，其中 $\\lambda_{c}(m)$ 是第 $m$ 个模态的连续特征值，$\\lambda_{d}(m)$ 是对应的离散特征值。\n   - 特征向量：计算离散特征向量 $v_{d}^{(m)}$ 与在内部网格点采样的连续特征函数 $y_{c}^{(m)}(z)$ 之间的归一化均方根不匹配 $\\epsilon_{v}(m)$。为比较形状，首先将两个向量缩放至单位 $\\ell^{2}$ 范数，并选择其中一个的符号以最小化它们差的范数。\n\n科学基础：\n- 使用适用于刚盖边界和常数系数的标准一维垂直算子，以及经过充分检验的中心有限差分法来计算二阶导数。\n- 假设 $H$ 是有限正数，并使用齐次狄利克雷边界条件 $y(0) = 0$ 和 $y(H) = 0$ 来表示抑制端点处垂直位移的刚性边界。\n\n单位和输出：\n- 将 $H$ 的单位视为米，如果需要，以 $\\mathrm{m}^{-2}$ 为单位报告特征值。所需的输出是无量纲误差 $\\epsilon_{\\lambda}(m)$ 和 $\\epsilon_{v}(m)$；以小数形式报告它们（不带百分号）。\n- 不使用角度。\n\n测试套件：\n对于以下每个测试用例，计算所要求模态的误差集。所有用例均使用 $H = 10000$ 米。\n- 用例 1：$K=8$，模态 $m \\in \\{1,2,4,8\\}$。\n- 用例 2：$K=33$，模态 $m \\in \\{1,3,8,16\\}$。\n- 用例 3：$K=65$，模态 $m \\in \\{1,5,15,30\\}$。\n- 用例 4 (边缘情况)：$K=3$，模态 $m \\in \\{1,2\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，输出一个包含两个子列表的嵌套列表：第一个子列表按指定模态的顺序列出相对特征值误差 $\\epsilon_{\\lambda}(m)$，第二个子列表按相同顺序列出特征向量不匹配误差 $\\epsilon_{v}(m)$。整体输出必须是一个包含这些按用例排列的列表的列表，其顺序与上述测试套件的顺序一致。例如，其结构应为\n[[[e11,e12,...],[v11,v12,...]],[[e21,e22,...],[v21,v22,...]],[[e31,...],[v31,...]],[[e41,...],[v41,...]]]\n其中 $eij$ 和 $vij$ 是浮点数。",
            "solution": "该问题要求对一个一维 Sturm-Liouville 问题进行公式化和数值分析，该问题描述了简化大气模型中内重力波的垂直结构。分析过程涉及将连续问题的精确解析解与其有限差分离散化的数值解进行比较。\n\n### 1. 连续边界值问题\n\n在指定的近似（静力、布辛涅斯克、恒定层结）下，线性内重力波的垂直结构由一个关于垂直结构函数（我们记为 $y(z)$）的二阶常微分方程控制。该函数与高度 $z$ 处的垂直速度振幅成正比。与此结构相关的算子是二阶导数 $\\frac{d^2}{dz^2}$。寻找正常模态会导出一个特征值问题：\n$$\n\\frac{d^2 y(z)}{dz^2} = \\lambda y(z)\n$$\n其中 $\\lambda$ 是特征值，它与垂直波数的平方 ($k_z^2 = -\\lambda$) 相关。定义域为区间 $[0, H]$，其中 $z=0$ 是地表，$z=H$ 是模式顶部。\n\n“刚盖”边界条件意味着在边界处没有垂直运动。这意味着垂直速度以及结构函数 $y(z)$ 在这些点上必须为零。这产生了齐次狄利克雷边界条件：\n$$\ny(0) = 0 \\quad \\text{and} \\quad y(H) = 0\n$$\n问题是在这些边界条件下求解该微分方程。$y'' - \\lambda y = 0$ 的通解取决于 $\\lambda$ 的符号。对于振荡（类波）解，我们期望 $\\lambda  0$。设 $\\lambda = -k^2$，其中 $k$ 为某个实数 $k0$。方程变为 $y'' + k^2 y = 0$。\n通解是：\n$$\ny(z) = A \\sin(kz) + B \\cos(kz)\n$$\n应用第一个边界条件，$y(0) = 0$：\n$$\ny(0) = A \\sin(0) + B \\cos(0) = B = 0\n$$\n这使解简化为 $y(z) = A \\sin(kz)$。应用第二个边界条件，$y(H) = 0$：\n$$\ny(H) = A \\sin(kH) = 0\n$$\n为了得到非平凡解 ($A \\neq 0$)，必须有 $\\sin(kH) = 0$。当 $kH$ 是 $\\pi$ 的整数倍时，此条件成立。\n$$\nkH = m\\pi, \\quad \\text{for } m = 1, 2, 3, \\dots\n$$\n$m=0$ 的情况被排除，因为它会导致平凡解 $y(z)=0$。整数 $m$ 是模态数，表示垂直域中的半波长数量。\n由此，我们找到了 $k$ 的一组离散允许值，即垂直波数：$k_m = \\frac{m\\pi}{H}$。\n相应的连续特征值 $\\lambda_c(m)$ 为：\n$$\n\\lambda_c(m) = -k_m^2 = -\\left(\\frac{m\\pi}{H}\\right)^2\n$$\n每个模态 $m$ 的特征函数 $y_c^{(m)}(z)$ 为：\n$$\ny_c^{(m)}(z) = \\sin\\left(\\frac{m\\pi z}{H}\\right)\n$$\n此处省略了归一化常数，因为它将在后面处理。\n\n### 2. 离散化和离散特征值问题\n\n我们使用一个包含 $K$ 个内部点和 2 个边界点的均匀网格来离散化域 $[0, H]$。总区间数为 $K+1$。网格间距为 $\\Delta z = \\frac{H}{K+1}$。网格点为 $z_j = j \\Delta z$，其中 $j=0, 1, \\dots, K+1$。内部点为 $z_1, \\dots, z_K$。令 $y_j = y(z_j)$。\n\n在内部点 $z_j$ 处的二阶导数 $\\frac{d^2y}{dz^2}$ 使用中心二阶有限差分公式近似：\n$$\n\\frac{d^2 y}{dz^2}\\bigg|_{z_j} \\approx \\frac{y(z_{j+1}) - 2y(z_j) + y(z_{j-1})}{(\\Delta z)^2} = \\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2}\n$$\n离散特征值问题则为：\n$$\n\\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2} = \\lambda_d y_j \\quad \\text{for } j = 1, \\dots, K\n$$\n边界条件 $y(0)=0$ 和 $y(H)=0$ 变为 $y_0=0$ 和 $y_{K+1}=0$。\n这个包含 $K$ 个线性方程的系统可以写成矩阵形式 $A\\mathbf{v} = \\lambda_d \\mathbf{v}$，其中 $\\mathbf{v} = [y_1, y_2, \\dots, y_K]^T$ 是内部网格点上解的向量。$K \\times K$ 矩阵 $A$ 的构造如下：\n对于 $j=1$: $\\frac{y_2 - 2y_1 + y_0}{(\\Delta z)^2} = \\frac{y_2 - 2y_1}{(\\Delta z)^2} = \\lambda_d y_1$\n对于 $j=K$: $\\frac{y_{K+1} - 2y_K + y_{K-1}}{(\\Delta z)^2} = \\frac{-2y_K + y_{K-1}}{(\\Delta z)^2} = \\lambda_d y_K$\n对于任何其他 $j$: $\\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2} = \\lambda_d y_j$\n\n这导出了对称三对角矩阵 $A$：\n$$\nA = \\frac{1}{(\\Delta z)^2}\n\\begin{pmatrix}\n-2  1  0  \\cdots  0 \\\\\n1  -2  1  \\ddots  \\vdots \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  1  -2  1 \\\\\n0  \\cdots  0  1  -2\n\\end{pmatrix}_{K \\times K}\n$$\n\n### 3. 数值特征对和模态关联\n\n离散特征值 $\\lambda_d(m)$ 和特征向量 $v_d^{(m)}$ 是通过数值求解矩阵 $A$ 的特征系统得到的。由于 $A$ 是一个实对称矩阵，其特征值是实数，并且它拥有一套完备的正交特征向量。数值库通常按升序返回排序后的特征值。\n\n这个特定矩阵 $A$ 的解析特征值已知为 $\\lambda_d(m') = -\\frac{4}{(\\Delta z)^2}\\sin^2\\left(\\frac{m'\\pi}{2(K+1)}\\right)$，其中 $m' = 1, \\dots, K$。\n连续特征值为 $\\lambda_c(m) = -(m\\pi/H)^2$。\n物理模态数 $m$ 对应于半波长的数量。随着 $m$ 的增加，（负）特征值的绝对值增加，因此其值减小。\n$\\lambda_c(1)  \\lambda_c(2)  \\dots$\n类似地，离散特征值 $\\lambda_d(m')$ 随着 $m'$ 从 1 增加到 $K$ 而减小。\n一个数值特征求解器将按升序对特征值进行排序：$\\lambda_{(1)} \\le \\lambda_{(2)} \\le \\dots \\le \\lambda_{(K)}$。\n因此，最小的特征值 $\\lambda_{(1)}$ 对应于模态 $m'=K$，最大的特征值 $\\lambda_{(K)}$ 对应于模态 $m'=1$。\n问题将第 $m$ 个离散特征对与第 $m$ 个连续模态相关联。对于给定的模态数 $m$（来自问题陈述，例如 $m=1, 2, 4$），对应的离散特征值是 $\\lambda_d(m)$，离散特征向量是 $v_d^{(m)}$。从排序后的数值结果来看，该特征对将是第 $(K-m+1)$ 个元素。如果求解器返回的索引是 $0, \\dots, K-1$，那么模态 $m$ 的特征对将位于索引 $K-m$ 处。\n\n### 4. 离散化误差量化\n\n通过比较离散和连续的特征对来量化有限差分离散化引入的误差。\n\n**特征值误差：** 第 $m$ 个模态特征值的相对误差是：\n$$\n\\epsilon_{\\lambda}(m) = \\frac{\\lambda_d(m) - \\lambda_c(m)}{\\lambda_c(m)}\n$$\n其中 $\\lambda_c(m)$ 是解析的连续特征值，$\\lambda_d(m)$ 是对应的数值计算出的离散特征值。\n\n**特征向量不匹配：** 特征向量的误差计算为归一化的均方根不匹配。\n1. 离散特征向量 $v_d^{(m)}$ 是一个长度为 $K$ 的向量。\n2. 连续特征函数 $y_c^{(m)}(z) = \\sin(m\\pi z/H)$ 在 $K$ 个内部网格点（$z_j = j\\Delta z$，$j=1, \\dots, K$）上进行采样，形成一个向量 $y_c^{(m, \\text{sampled})}$。其分量为 $\\sin(m\\pi j / (K+1))$。\n3. 两个向量都缩放至单位 $\\ell^2$ 范数：$\\hat{v}_d^{(m)} = v_d^{(m)} / \\|v_d^{(m)}\\|_2$ 和 $\\hat{y}_c^{(m)} = y_c^{(m, \\text{sampled})} / \\|y_c^{(m, \\text{sampled})}\\|_2$。\n4. 特征向量的定义只到符号为止。为了确保对形状进行有意义的比较，需要调整数值特征向量的符号以匹配解析特征向量。如果 $\\hat{v}_d^{(m)} \\cdot \\hat{y}_c^{(m)}  0$，则翻转 $\\hat{v}_d^{(m)}$ 的符号。令这个修正后的向量为 $\\hat{v}_d'^{(m)}$。\n5. 特征向量不匹配度是归一化、符号校正后的向量之差的 $\\ell^2$ 范数：\n$$\n\\epsilon_{v}(m) = \\| \\hat{v}_d'^{(m)} - \\hat{y}_c^{(m)} \\|_2\n$$\n对于这个特定问题，解析的离散特征向量与采样的连续特征函数完全成比例。因此，$\\epsilon_{v}(m)$ 的非零值预期仅由数值特征求解器中的浮点不精确性引起，并应接近机器精度。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying discretization error for a 1D Sturm-Liouville\n    problem related to vertical modes in atmospheric models.\n    \"\"\"\n    \n    H = 10000.0  # Model top height in meters\n    \n    test_cases = [\n        {'K': 8, 'modes': [1, 2, 4, 8]},\n        {'K': 33, 'modes': [1, 3, 8, 16]},\n        {'K': 65, 'modes': [1, 5, 15, 30]},\n        {'K': 3, 'modes': [1, 2]},\n    ]\n    \n    overall_results = []\n    \n    for case in test_cases:\n        K = case['K']\n        modes_to_test = case['modes']\n        \n        delta_z = H / (K + 1)\n        \n        # 1. Assemble the K x K tridiagonal matrix A for the discrete operator\n        main_diag = -2.0 * np.ones(K)\n        off_diag = np.ones(K - 1)\n        \n        # The matrix for the second derivative is T/dz^2\n        # where T is the tridiagonal matrix with (-2, 1, 1).\n        A = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (delta_z**2)\n        \n        # 2. Solve the discrete eigenvalue problem numerically\n        # linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        discrete_eigenvalues, discrete_eigenvectors = linalg.eigh(A)\n        \n        case_lambda_errors = []\n        case_vec_errors = []\n        \n        # Grid points for sampling the continuous solution\n        z_grid = np.arange(1, K + 1) * delta_z\n        \n        for m in modes_to_test:\n            # Check if mode m can be resolved by the grid\n            if m  K:\n                continue\n\n            # 3. Calculate continuous eigenvalues and eigenfunctions\n            lambda_c = -((m * np.pi) / H)**2\n            \n            # The continuous eigenfunction sampled at interior grid points\n            # y_c(z_j) = sin(m*pi*z_j / H) = sin(m*pi*j*dz / H) = sin(m*pi*j / (K+1))\n            vec_c_sampled = np.sin(m * np.pi * np.arange(1, K + 1) / (K + 1))\n\n            # 4. Associate discrete results with the m-th mode\n            # Eigenvalues from eigh are sorted ascendingly.\n            # The physical mode 'm' corresponds to the (K-m+1)-th eigenvalue in\n            # a list sorted by physical meaning (decreasing value).\n            # In an ascending sort (from most negative to least), mode 'm'\n            # corresponds to index K-m.\n            eigval_index = K - m\n            lambda_d = discrete_eigenvalues[eigval_index]\n            vec_d = discrete_eigenvectors[:, eigval_index]\n            \n            # 5. Quantify errors\n            # Relative eigenvalue error\n            epsilon_lambda = (lambda_d - lambda_c) / lambda_c\n            case_lambda_errors.append(epsilon_lambda)\n            \n            # Eigenvector mismatch\n            # Normalize both vectors to unit l2 norm\n            norm_vec_d = np.linalg.norm(vec_d)\n            norm_vec_c = np.linalg.norm(vec_c_sampled)\n            \n            # Avoid division by zero if a vector is all zeros (highly unlikely)\n            if norm_vec_d == 0.0 or norm_vec_c == 0.0:\n                epsilon_v = np.nan\n            else:\n                v_d_norm = vec_d / norm_vec_d\n                v_c_norm = vec_c_sampled / norm_vec_c\n            \n                # Adjust sign of numerical eigenvector for consistent comparison\n                if np.dot(v_d_norm, v_c_norm)  0:\n                    v_d_norm *= -1.0\n                \n                # Compute normalized RMS mismatch as the L2 norm of the difference\n                epsilon_v = np.linalg.norm(v_d_norm - v_c_norm)\n                case_vec_errors.append(epsilon_v)\n\n        overall_results.append([case_lambda_errors, case_vec_errors])\n\n    # Format the final output exactly as specified\n    # Using a custom function to format the list of lists\n    def format_nested_list(data):\n        outer_parts = []\n        for sublist1 in data:\n            inner_parts = []\n            for sublist2 in sublist1:\n                inner_parts.append(f\"[{','.join(f'{x:.10f}' for x in sublist2)}]\")\n            outer_parts.append(f\"[{','.join(inner_parts)}]\")\n        return f\"[{','.join(outer_parts)}]\"\n\n    print(format_nested_list(overall_results))\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何确定模型的正规模之后，我们便可以利用它们来改善预报的初始场。这个练习通过一个简化的强迫谐振子模型，生动地揭示了初始场不平衡所导致的问题。您将比较三种不同初始方案下的预报演变：原始分析场、线性正规模初始化（NMI）和非线性正规模初始化（Nonlinear NMI）。通过量化不同方案下虚假重力波的振幅，您将直观地理解为何需要初始化，以及非线性初始化在滤除噪音、确保平稳预报开端方面的优越性。",
            "id": "4031279",
            "problem": "考虑一个简化的预报模型，该模型分离了由分析的斜压急流中的不平衡所产生的快速重力波振荡。其基本物理基础是 $f$ 平面上的旋转浅水方程，该方程允许一个平衡的地转（慢）模态和惯性重力（快）模态。在一维波数为 $k$ 的谱空间中，众所周知，旋转浅水方程的线性正规模态包含一个频率为 $0$ 的慢平衡模态和两个频率为 $\\pm \\omega$ 的快重力波模态，其中 $\\omega$ 是惯性重力波频率。平衡模态与快模态之间的弱非线性相互作用可以建模为平衡场对快模态的二次强迫。\n\n为本练习之目的，并将计算精力集中在快模态分量上，假设平衡斜压急流振幅 $B$ 在最初的 $12$ 小时内是时间常数，并通过二次非线性项作为快模态的源。将快模态位移振幅表示为 $G(t)$，其时间导数（快模态速度振幅）表示为 $V(t) = dG/dt$。重力波动力学由受迫谐振子建模：\n$$\n\\frac{dG}{dt} = V, \\qquad\n\\frac{dV}{dt} = -\\omega^2 G + \\epsilon B^2,\n$$\n其中 $\\omega$ 是非负的重力波角频率，单位为 $\\mathrm{s}^{-1}$；$\\epsilon$ 是一个小的非负系数，单位为 $\\mathrm{s}^{-2}$，它概括了弱非线性二次耦合的有效强度；$B$ 是一个无量纲振幅参数，代表斜压急流的强度。所有变量 $G$ 和 $V$ 均为无量纲。时间 $t$ 以秒为单位。\n\n您必须比较三种不同初始化状态下最初 $12$ 小时（$T = 43200 \\ \\mathrm{s}$）的预报演变：\n- 原始分析：提供初始条件 $G(0) = G_{\\mathrm{raw}}$ 和 $V(0) = V_{\\mathrm{raw}}$，其中可能因不平衡而包含虚假的快模态分量。\n- 线性正规模态初始化 (Linear Normal Mode Initialization, NMI)：设置 $G(0) = 0$ 和 $V(0) = 0$，通过投影到线性化算子的慢平衡子空间来移除线性的快模态分量。\n- 非线性正规模态初始化 (Nonlinear Normal Mode Initialization, NMI)：设置 $G(0) = \\epsilon B^2 / \\omega^2$ 和 $V(0) = 0$，这将快模态置于与二次平衡在主导阶上一致的非线性慢流形上，从而最小化启动瞬变。\n\n使用固定的时间步长 $\\Delta t$（单位为秒），对每种初始化在 $t \\in [0,T]$ 上对系统进行数值积分。通过对时间序列进行去趋势处理以移除任何恒定偏移，并报告半峰-峰振幅来量化重力波振荡的振幅：\n$$\n\\overline{G} = \\frac{1}{N} \\sum_{n=0}^{N-1} G(t_n), \\quad \\text{with} \\quad t_n = n \\Delta t, \\quad N = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor + 1,\n$$\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) - \\min_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) \\right],\n$$\n表示为一个无量纲浮点数。此 $A$ 测量了最初 $12$ 小时内高频重力波振荡的振幅。\n\n单位和数值要求：\n- 时间使用秒（$\\mathrm{s}$），频率使用秒的倒数（$\\mathrm{s}^{-1}$），非线性耦合系数使用秒的平方的倒数（$\\mathrm{s}^{-2}$）。所有振幅（$G$、 $V$、 $B$、 $A$）都是无量纲的。\n- 角频率 $\\omega$ 的单位为 $\\mathrm{s}^{-1}$，隐式使用弧度。\n- 使用给定的 $\\Delta t$ 实现一个数值稳定的显式格式（例如，经典的四阶龙格－库塔法）。\n- 所有振幅报告为浮点数。\n\n测试套件：\n对于下面的每个参数元组 $(\\omega, \\epsilon, B, G_{\\mathrm{raw}}, V_{\\mathrm{raw}}, \\Delta t)$，执行三次运行（原始分析、线性NMI、非线性NMI），并为每次运行计算 $A$。参数集如下：\n1. 典型的中纬度斜压急流和适度的二次耦合（理想情况）：\n   - $\\omega = 1.5 \\times 10^{-3} \\ \\mathrm{s}^{-1}$，\n   - $\\epsilon = 2.0 \\times 10^{-7} \\ \\mathrm{s}^{-2}$，\n   - $B = 1.0$，\n   - $G_{\\mathrm{raw}} = 0.5$，\n   - $V_{\\mathrm{raw}} = 0.0$，\n   - $\\Delta t = 60 \\ \\mathrm{s}$。\n2. 无虚假快模态分量且二次耦合为零的边界情况：\n   - $\\omega = 1.0 \\times 10^{-3} \\ \\mathrm{s}^{-1}$，\n   - $\\epsilon = 0.0 \\ \\mathrm{s}^{-2}$，\n   - $B = 0.8$，\n   - $G_{\\mathrm{raw}} = 0.0$，\n   - $V_{\\mathrm{raw}} = 0.0$，\n   - $\\Delta t = 60 \\ \\mathrm{s}$。\n3. 更强的二次耦合和更大的急流，具有微小但非零的初始快模态速度：\n   - $\\omega = 2.0 \\times 10^{-3} \\ \\mathrm{s}^{-1}$，\n   - $\\epsilon = 1.0 \\times 10^{-6} \\ \\mathrm{s}^{-2}$，\n   - $B = 2.0$，\n   - $G_{\\mathrm{raw}} = 0.1$，\n   - $V_{\\mathrm{raw}} = 1.0 \\times 10^{-4}$，\n   - $\\Delta t = 30 \\ \\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须按顺序包含每个测试用例的三个振幅 $(A_{\\mathrm{raw}}, A_{\\mathrm{linNMI}}, A_{\\mathrm{nonlinNMI}})$，并将它们展平成一个列表。例如，输出格式为 $[A_{1,\\mathrm{raw}},A_{1,\\mathrm{lin}},A_{1,\\mathrm{nonlin}},A_{2,\\mathrm{raw}},A_{2,\\mathrm{lin}},A_{2,\\mathrm{nonlin}},A_{3,\\mathrm{raw}},A_{3,\\mathrm{lin}},A_{3,\\mathrm{nonlin}}]$，表示为无量纲浮点数。",
            "solution": "该问题要求对一个简化数值天气预报模型的三种不同初始化方案进行比较分析。该模型的动力学由一个受迫谐振子控制，它代表了从平衡的斜压急流中产生的快速惯性重力波。任务的核心是数值积分该常微分方程组（ODEs），为每种初始化量化所产生的重力波振荡，并报告给定测试用例集的结果。\n\n快模态位移振幅 $G(t)$ 和速度振幅 $V(t)$ 的控制方程是一个由两个一阶常微分方程组成的系统：\n$$\n\\frac{dG}{dt} = V\n$$\n$$\n\\frac{dV}{dt} = -\\omega^2 G + \\epsilon B^2\n$$\n其中 $G$ 和 $V$ 是无量纲振幅， $t$ 是以秒为单位的时间， $\\omega$ 是以 $\\mathrm{s}^{-1}$ 为单位的重力波角频率， $\\epsilon$ 是以 $\\mathrm{s}^{-2}$ 为单位的非线性耦合系数， $B$ 是时间常数的斜压急流的无量纲振幅。该系统可以写成关于 $G(t)$ 的单个二阶常微分方程：\n$$\n\\frac{d^2G}{dt^2} + \\omega^2 G = \\epsilon B^2\n$$\n这是一个具有常数强迫项 $\\epsilon B^2$ 的标准受迫谐振子方程。\n\n该方程的通解是齐次解和特解之和。齐次方程 $\\frac{d^2G_h}{dt^2} + \\omega^2 G_h = 0$ 描述了频率为 $\\omega$ 的自由振荡。代表由常数项强迫的稳态的特解，可以通过将导数设为零来找到：$\\omega^2 G_p = \\epsilon B^2$，得到 $G_p = \\frac{\\epsilon B^2}{\\omega^2}$。这个特解，下文记为 $G_{\\text{balance}}$，代表了平衡态，此时气压梯度力（与 $G$ 相关）与急流非线性相互作用产生的强迫完全平衡。\n\n$G(t)$ 的完整解析解是：\n$$\nG(t) = \\left( G(0) - G_{\\text{balance}} \\right) \\cos(\\omega t) + \\frac{V(0)}{\\omega} \\sin(\\omega t) + G_{\\text{balance}}\n$$\n其中 $G(0)$ 和 $V(0)$ 是初始条件。该解由一个稳态分量 $G_{\\text{balance}}$ 和一个振荡分量组成，其振幅为 $A_{\\text{analytic}} = \\sqrt{\\left(G(0) - G_{\\text{balance}}\\right)^2 + \\left(\\frac{V(0)}{\\omega}\\right)^2}$。三种初始化方案可以根据此解来理解：\n1.  **原始分析**：初始状态为 $(G(0), V(0)) = (G_{\\mathrm{raw}}, V_{\\mathrm{raw}})$。此状态与平衡态 $(G_{\\text{balance}}, 0)$ 的任何偏差都将产生重力波振荡。振幅为 $A_{\\text{raw}} = \\sqrt{\\left(G_{\\mathrm{raw}} - G_{\\text{balance}}\\right)^2 + \\left(\\frac{V_{\\mathrm{raw}}}{\\omega}\\right)^2}$。这些振荡在预报中通常是虚假噪声。\n2.  **线性正规模态初始化 (NMI)**：初始状态设为 $(G(0), V(0)) = (0, 0)$。这移除了任何线性的快模态分量，相当于将快模态变量置零。然而，非线性强迫项 $\\epsilon B^2$ 仍然存在。这会迫使系统偏离 $(0, 0)$ 状态，自发地产生重力波。产生的振荡振幅为 $A_{\\text{linNMI}} = \\sqrt{\\left(0 - G_{\\text{balance}}\\right)^2 + 0^2} = |G_{\\text{balance}}| = \\frac{\\epsilon B^2}{\\omega^2}$。这是模型为适应强迫而调整时产生的“启动瞬变”。\n3.  **非线性正规模态初始化 (NMI)**：初始状态设为 $(G(0), V(0)) = (G_{\\text{balance}}, 0) = (\\frac{\\epsilon B^2}{\\omega^2}, 0)$。这将系统直接置于平衡稳态。根据解析解，振荡分量的振幅为零： $A_{\\text{nonlinNMI}} = \\sqrt{\\left(G_{\\text{balance}} - G_{\\text{balance}}\\right)^2 + 0^2} = 0$。该方案旨在通过将快模态初始化为与强迫项平衡的状态来消除启动瞬变，从而实现平滑的预报演变。\n\n为了获得数值解，我们必须在时间区间 $t \\in [0, T]$ 上对常微分方程组进行积分，其中 $T = 43200 \\ \\mathrm{s}$。问题指定使用稳定的显式格式，经典的四阶龙格－库塔 (RK4) 方法是一个绝佳选择。对于系统 $\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y})$ 和时间步长 $\\Delta t$，从时间 $t_n$ 的 $\\vec{y}_n$ 到时间 $t_{n+1} = t_n + \\Delta t$ 的 RK4 更新为：\n$$\n\\vec{y}_{n+1} = \\vec{y}_n + \\frac{\\Delta t}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\n其中\n$$\n\\begin{aligned}\n\\vec{k}_1 = \\vec{f}(t_n, \\vec{y}_n) \\\\\n\\vec{k}_2 = \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_1) \\\\\n\\vec{k}_3 = \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_2) \\\\\n\\vec{k}_4 = \\vec{f}(t_n + \\Delta t, \\vec{y}_n + \\Delta t \\vec{k}_3)\n\\end{aligned}\n$$\n在我们的情况下，状态向量是 $\\vec{y} = [G, V]^T$，函数 $\\vec{f}$ 是 $\\vec{f}(\\vec{y}) = [V, -\\omega^2 G + \\epsilon B^2]^T$，它与时间 $t$ 无关。此过程被迭代应用于 $n = 0, 1, \\dots, N-2$，以生成时间序列 $G(t_n)$，其中 $N = \\lfloor T/\\Delta t \\rfloor + 1$。\n\n最后，为了量化重力波振幅，我们计算 $G$ 的去趋势化时间序列的半峰-峰振幅。度量 $A$ 定义为：\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) - \\min_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) \\right]\n$$\n其中 $\\overline{G}$ 是序列 $G(t_n)$ 的时间平均值。由于从一个序列的所有元素中减去一个常数 $\\overline{G}$ 不会改变其最大值和最小值之差，此表达式可简化为：\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n  N} G(t_n) - \\min_{0 \\le n  N} G(t_n) \\right]\n$$\n将对所有提供的测试用例中的三种初始化方案分别计算该值。数值结果应与解析解的预测非常接近。具体来说，非线性 NMI 应产生接近于零的振幅，这证明了其在抑制虚假振荡方面的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing three initialization schemes for a simplified\n    numerical weather forecast model.\n    \"\"\"\n\n    def rk4_step(f, t, y, dt):\n        \"\"\"\n        Performs a single step of the classical fourth-order Runge-Kutta method.\n\n        Args:\n            f: The function defining the ODE system, dy/dt = f(t, y).\n            t: The current time.\n            y: The current state vector.\n            dt: The time step.\n            \n        Returns:\n            The state vector at time t + dt.\n        \"\"\"\n        k1 = dt * f(t, y)\n        k2 = dt * f(t + 0.5 * dt, y + 0.5 * k1)\n        k3 = dt * f(t + 0.5 * dt, y + 0.5 * k2)\n        k4 = dt * f(t + dt, y + k3)\n        return y + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n\n    def run_simulation(params, initial_conditions):\n        \"\"\"\n        Runs a single simulation for a given set of parameters and initial conditions.\n\n        Args:\n            params: A tuple of parameters (omega, epsilon, B, G_raw, V_raw, dt).\n            initial_conditions: A tuple (G0, V0) for the start of the simulation.\n\n        Returns:\n            The calculated half peak-to-peak amplitude 'A'.\n        \"\"\"\n        omega, epsilon, B, _, _, dt = params\n        G0, V0 = initial_conditions\n        \n        T = 43200.0  # Total integration time of 12 hours in seconds.\n\n        def f(t, y):\n            \"\"\"The ODE system dy/dt = f(t, y).\"\"\"\n            G, V = y\n            dG_dt = V\n            dV_dt = -omega**2 * G + epsilon * B**2\n            return np.array([dG_dt, dV_dt])\n\n        num_steps = int(np.floor(T / dt)) + 1\n        G_series = np.zeros(num_steps)\n        \n        y = np.array([G0, V0])\n        G_series[0] = y[0]\n        \n        t = 0.0\n        for i in range(num_steps - 1):\n            y = rk4_step(f, t, y, dt)\n            t += dt\n            G_series[i+1] = y[0]\n            \n        # Calculate the half peak-to-peak amplitude of the time series\n        # A = 0.5 * (max(G) - min(G)), which is equivalent to the detrended definition.\n        A = 0.5 * (np.max(G_series) - np.min(G_series))\n        return A\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Typical midlatitude baroclinic jet\n        (1.5e-3, 2.0e-7, 1.0, 0.5, 0.0, 60.0),\n        # 2. Boundary case with no forcing\n        (1.0e-3, 0.0, 0.8, 0.0, 0.0, 60.0),\n        # 3. Stronger coupling and larger jet\n        (2.0e-3, 1.0e-6, 2.0, 0.1, 1.0e-4, 30.0)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, epsilon, B, G_raw, V_raw, _ = case\n\n        # 1. Raw analysis initialization\n        ic_raw = (G_raw, V_raw)\n        A_raw = run_simulation(case, ic_raw)\n        \n        # 2. Linear Normal Mode Initialization (NMI)\n        ic_lin_nmi = (0.0, 0.0)\n        A_lin_nmi = run_simulation(case, ic_lin_nmi)\n        \n        # 3. Nonlinear Normal Mode Initialization (NMI)\n        # Avoid division by zero if omega is 0.\n        if omega == 0.0:\n            G0_nonlin_nmi = 0.0\n        else:\n            G0_nonlin_nmi = epsilon * B**2 / omega**2\n        ic_nonlin_nmi = (G0_nonlin_nmi, 0.0)\n        A_nonlin_nmi = run_simulation(case, ic_nonlin_nmi)\n        \n        all_results.extend([A_raw, A_lin_nmi, A_nonlin_nmi])\n\n    # Final print statement in the exact required format.\n    # We use a high precision format to avoid ambiguity in floating point representation.\n    print(f\"[{','.join(f'{r:.10f}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了在模态空间中操作的正规模初始化（NMI）之外，数字滤波初始化（DFI）提供了另一种在物理空间和时间域中滤除噪音的强大技术。本练习将让您亲手实现一个数字滤波器，并将其应用于一个采用蛙跳格式的简单模型。您的任务是量化该滤波器在抑制由时间积分格式本身产生的高频计算模方面的效果。这个实践突显了一种不同的初始化哲学，即通过对短时间序列进行加权平均来直接平滑初始状态，从而为理解现代资料同化和预报系统中的滤波技术提供了宝贵的实践经验。",
            "id": "4031228",
            "problem": "考虑一个复傅里叶系数，它代表了数值天气预报模型线性化动力核心的一个线性简正模。设复振幅表示为 $y(t)$，并假设它满足线性常微分方程 $dy/dt = i \\omega y$，其中 $\\omega$ 是一个以弧度/秒为单位的实角频率。时间离散化采用蛙跳格式，在时间步长为 $\\Delta t$ 秒的均匀网格上进行，由三时间层的递推关系 $y^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}$ 定义，其中 $y^{n} \\approx y(t_{n})$ 位于 $t_{n} = n \\Delta t$。蛙跳格式支持一个物理模和一个寄生的计算模，后者的特征是随时间交替变号。数字滤波器初始化 (DFI) 是一种时间对称的程序，通过将模型轨迹的一个短的、对称的窗口与固定权重进行卷积来减小计算模的振幅。\n\n您需要在此蛙跳格式设置下，为单个复标量 $y(t)$ 实现数字滤波器初始化 (DFI)，并量化初始化后紧接着的单个时间层上计算模振幅的减小程度。初始化通过单个前向 Euler 法启动来激发计算模，之后使用蛙跳格式。要求的步骤如下，每一步都必须完全按照所述实现：\n\n- 模型与离散化。使用线性模型 $dy/dt = i \\omega y$ 和蛙跳格式 $y^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}$。\n- 激发计算模的启动过程。设置 $y^{0} = 1 + 0 i$。通过 $y^{1}_{\\mathrm{FE}} = y^{0} + \\Delta t \\, i \\omega \\, y^{0}$ 计算到 $t_{1}$ 的单个前向 Euler 步。通过在 $n=0$ 处反转蛙跳递推关系来定义 $y^{-1}$，使得蛙跳关系在 $(n=-1,0,1)$ 处成立，即 $y^{-1} = y^{1}_{\\mathrm{FE}} - 2 i \\omega \\Delta t \\, y^{0}$。使用这个 $y^{-1}$ 和 $y^{0}$ 结合蛙跳格式，为从 $-K$ 到 $+K$ 的指数 $n$ 生成一个离散时间序列 $\\{ y^{n} \\}$，其中 $K$ 是一个固定的正整数。\n- 时间对称数字滤波器。使用一个长度为奇数 $L$ 的有限脉冲响应、对称、时不变数字滤波器，其权重为 $\\{ w_{k} \\}_{k=-M}^{M}$，其中 $M = (L-1)/2$，满足 $\\sum_{k=-M}^{M} w_{k} = 1$ 和 $\\sum_{k=-M}^{M} (-1)^{k} w_{k} = 0$。对于本任务，使用 $L-1$ 阶的归一化二项式权重，即对于 $k=-M,\\ldots,M$，有 $w_{k} = \\binom{L-1}{k+M} / 2^{L-1}$。例如，当 $L=3$ 时，权重为 $[1,2,1]/4$；当 $L=5$ 时，权重为 $[1,4,6,4,1]/16$。通过 $y^{n}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_{k} \\, y^{n+k}$ 定义时间指数 $n$ 处的滤波值，前提是所有指数 $n+k$ 都位于可用的时间窗口内。\n- 计算模振幅度量。对于任何连续的一对时间层，通过 $a^{n} = \\tfrac{1}{2} \\left( y^{n} - y^{n-1} \\right)$ 定义在指数 $n$ 处的交替（计算）分量。通过 $A_{\\mathrm{before}} = \\lvert a^{0} \\rvert = \\left\\lvert \\tfrac{1}{2} \\left( y^{0} - y^{-1} \\right) \\right\\rvert$ 定义初始化时刻的未滤波计算振幅。通过使用指数 $n=0$ 和 $n=-1$ 处的滤波值来定义滤波后的计算振幅，即 $A_{\\mathrm{after}} = \\left\\lvert \\tfrac{1}{2} \\left( y^{0}_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}} \\right) \\right\\rvert$。所需的度量是缩减因子 $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$，该因子是无量纲的。\n- 单位和数值约束。$\\omega$ 的单位使用弧度/秒，$\\Delta t$ 的单位使用秒。积分指数半跨度必须为 $K = 32$，以便时间窗口跨越指数 $n=-32,-31,\\ldots,+31,+32$。通过使用其 $\\omega \\Delta t$ 不违反线性振荡模型蛙跳格式稳定性的测试用例，确保蛙跳积分是数值中性的（无发散）。\n\n您的任务是编写一个完整的程序，该程序：\n- 使用指定的初始化方法为每个测试用例构建时间序列 $\\{ y^{n} \\}$。\n- 使用指定的权重，将以 $n=0$ 和 $n=-1$ 为中心的时间对称数字滤波器应用于时间序列。\n- 计算每个测试用例的缩减因子 $R$。\n\n测试套件：\n- 案例1：周期 $P = 600$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 30$ 秒，滤波器长度 $L = 3$。\n- 案例2：周期 $P = 240$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 30$ 秒，滤波器长度 $L = 3$。\n- 案例3：周期 $P = 1200$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 30$ 秒，滤波器长度 $L = 5$。\n- 案例4：周期 $P = 300$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 20$ 秒，滤波器长度 $L = 5$。\n\n所有输出必须是浮点数。您的程序应生成一行输出，其中包含按测试用例顺序排列的四个缩减因子，格式为方括号内以逗号分隔的列表，每个浮点数四舍五入到六位小数（例如，$[0.123456,0.234567,0.345678,0.456789]$）。不应打印任何其他文本。",
            "solution": "该问题要求为一个数值模型中的单个线性简正模实现并评估数字滤波器初始化 (DFI) 程序。目标是量化蛙跳时间步进格式固有的寄生计算模的减小程度。\n\n### 1. 模型与离散化格式\n\n物理系统是一个线性振荡器，由常微分方程描述：\n$$\n\\frac{dy}{dt} = i \\omega y\n$$\n其中 $y(t)$ 是一个复振幅，$\\omega$ 是一个实值角频率。其精确解为 $y(t) = y(0) e^{i \\omega t}$，代表一个纯粹的振荡。\n\n时间离散化是在均匀网格 $t_n = n \\Delta t$ 上使用三时间层的蛙跳格式完成的：\n$$\ny^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}\n$$\n这是对连续方程的有限差分近似。为分析其行为，我们寻找 $y^n = \\lambda^n$ 形式的解。将此代入递推关系，得到特征方程：\n$$\n\\lambda^2 - 2 i (\\omega \\Delta t) \\lambda - 1 = 0\n$$\n设 $x = \\omega \\Delta t$。根据二次公式，其根为：\n$$\n\\lambda = i x \\pm \\sqrt{1 - x^2}\n$$\n为使格式在数值上稳定，根的模不得超过 $1$。这要求 $1 - x^2 \\ge 0$，从而导出 Courant-Friedrichs-Lewy (CFL) 条件 $|x| = |\\omega \\Delta t| \\le 1$。问题陈述中提供的所有测试用例均满足此条件。\n\n在此条件下，存在两个模为 $1$ 的不同根：\n1.  **物理模根 ($\\lambda_p$)**: $\\lambda_p = \\sqrt{1 - x^2} + i x$。这可以写成 $\\lambda_p = e^{i\\theta_p}$，其中每个时间步的数值相变为 $\\theta_p = \\arcsin(x) = \\arcsin(\\omega \\Delta t)$。数值频率为 $\\omega_{\\text{num}} = \\theta_p / \\Delta t \\approx \\omega$（对于小的 $\\omega \\Delta t$）。这个根近似于真实的物理行为。\n2.  **计算模根 ($\\lambda_c$)**: $\\lambda_c = -\\sqrt{1 - x^2} + i x$。这可以写成 $\\lambda_c = e^{i\\theta_c}$，其中 $\\theta_c = \\pi - \\arcsin(\\omega \\Delta t)$。这个根是三时间层格式的人为产物。其频率接近奈奎斯特频率 $\\pi/\\Delta t$，并且由于其相位中含有 $\\pi$ 项，它表现出随时间交替的符号，使其具有寄生性。\n\n一般的数值解是这两个模的线性组合：\n$$\ny^n = A_p (\\lambda_p)^n + A_c (\\lambda_c)^n\n$$\n其中 $A_p$ 和 $A_c$ 分别是物理模和计算模的复振幅，由初始条件确定。\n\n### 2. 启动过程与计算模的激发\n\n问题指定了一个旨在有意激发计算模的启动过程。初始化从 $y^0 = 1$ 开始。通过单个前向 Euler 步获得第二个时间层的值：\n$$\ny^{1}_{\\mathrm{FE}} = y^{0} + i \\omega \\Delta t \\, y^{0} = (1 + i \\omega \\Delta t)\n$$\n要启动三层蛙跳格式，需要 $t_{-1}$ 处的值。$y^{-1}$ 的定义要求蛙跳关系对三元组 $(y^{-1}, y^0, y^1_{\\mathrm{FE}})$ 成立：\n$$\ny^{1}_{\\mathrm{FE}} = y^{-1} + 2 i \\omega \\Delta t \\, y^0 \\implies y^{-1} = y^{1}_{\\mathrm{FE}} - 2 i \\omega \\Delta t \\, y^0 = (1 + i \\omega \\Delta t) - 2 i \\omega \\Delta t = 1 - i \\omega \\Delta t\n$$\n这种两步初始化（使用像前向 Euler 这样的两层格式来生成一个点）在时间层之间造成了不平衡，这种不平衡会投影到计算模上，从而使 $A_c \\neq 0$。定义了 $y^{-1}$ 和 $y^0$ 后，就可以使用蛙跳递推关系从 $n=0$ 向前和向后生成整个时间序列 $\\{y^n\\}_{n=-K}^K$。\n\n### 3. 数字滤波器初始化 (DFI)\n\nDFI 旨在通过应用一个低通数字滤波器来抑制计算模。指定的滤波器是一个对称的、有限脉冲响应 (FIR) 滤波器，其长度为奇数 $L = 2M+1$，权重为 $\\{w_k\\}_{k=-M}^M$。在时间 $n$ 处的滤波值是一个加权平均：\n$$\ny^{n}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_{k} \\, y^{n+k}\n$$\n权重由 $L-1$ 阶的归一化二项式系数给出：\n$$\nw_k = \\frac{\\binom{L-1}{k+M}}{2^{L-1}}, \\quad k = -M, \\dots, M\n$$\n这些权重满足两个关键属性：\n1.  $\\sum_{k=-M}^{M} w_k = 1$：滤波器对于零频率信号（直流分量）的增益为1，从而保留了平均状态。\n2.  $\\sum_{k=-M}^{M} (-1)^k w_k = 0$：滤波器在奈奎斯特频率 $\\pi / \\Delta t$ 处的增益为零。由于计算模的频率接近此值，滤波器会对其进行强力衰减。\n\n该二项式滤波器的频率响应为 $H(\\Omega) = (\\cos(\\Omega/2))^{L-1}$，其中 $\\Omega$ 是数字频率。滤波器在计算模频率 $\\Omega_c = \\pi - \\theta_p$ 处的响应是 $(\\cos((\\pi-\\theta_p)/2))^{L-1} = (\\sin(\\theta_p/2))^{L-1}$。对于小的 $\\theta_p$，这个值非常小，证实了对计算模的强衰减作用。\n\n### 4. 量化缩减程度\n\n计算模的振幅通过其特有的高频振荡来衡量。交替分量定义为：\n$$\na^n = \\frac{1}{2} (y^n - y^{n-1})\n$$\n滤波前后该分量的振幅用于量化滤波器的效果。\n- **DFI 之前**：在初始化时间 $t_0$ 的振幅为 $A_{\\mathrm{before}} = |a^0| = \\left| \\frac{1}{2} (y^0 - y^{-1}) \\right|$。使用启动值：\n  $$\n  A_{\\mathrm{before}} = \\left| \\frac{1}{2} (1 - (1 - i \\omega \\Delta t)) \\right| = \\left| \\frac{1}{2} i \\omega \\Delta t \\right| = \\frac{\\omega \\Delta t}{2}\n  $$\n- **DFI 之后**：计算 $t_0$ 和 $t_{-1}$ 处的滤波值，并从中导出振幅：\n  $$\n  A_{\\mathrm{after}} = \\left| \\frac{1}{2} (y^0_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}}) \\right|\n  $$\n  其中 $y^0_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_k y^k$ 且 $y^{-1}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_k y^{k-1}$。\n缩减因子是比率 $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$。\n\n### 5. 算法流程\n\n对每个测试用例，通过以下步骤计算解：\n1.  计算 $\\omega = 2\\pi/P$。\n2.  设置时间序列半跨度 $K=32$。创建一个复值数组 `y` 来存储时间序列 $\\{y^n\\}_{n=-K}^K$。\n3.  根据启动过程初始化所需的两个初始值：$y^0 = 1$ 和 $y^{-1} = 1 - i \\omega \\Delta t$。\n4.  使用蛙跳递推关系生成完整的时间序列：\n    - 对于 $n=1, \\dots, K$：$y^n = y^{n-2} + 2 i \\omega \\Delta t \\, y^{n-1}$。\n    - 对于 $n=-2, \\dots, -K$：$y^n = y^{n+2} - 2 i \\omega \\Delta t \\, y^{n+1}$。\n5.  根据给定的滤波器长度 $L$，使用二项式系数公式计算 FIR 滤波器权重 $\\{w_k\\}$。\n6.  通过将权重与时间序列 `y` 的适当段进行卷积，计算滤波值 $y^0_{\\mathrm{filt}}$ 和 $y^{-1}_{\\mathrm{filt}}$。\n7.  计算“之前”的振幅 $A_{\\mathrm{before}} = |\\frac{1}{2}(y^0 - y^{-1})|$。\n8.  计算“之后”的振幅 $A_{\\mathrm{after}} = |\\frac{1}{2}(y^0_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}})|$。\n9.  计算并存储缩减因子 $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$。\n10. 按规定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Implements and evaluates Digital Filter Initialization (DFI) for a single\n    linear normal mode discretized with the leapfrog scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Period P in s, time step dt in s, filter length L)\n        (600.0, 30.0, 3),\n        (240.0, 30.0, 3),\n        (1200.0, 30.0, 5),\n        (300.0, 20.0, 5),\n    ]\n\n    results = []\n    \n    # Integration index half-span as specified\n    K = 32\n\n    for P, dt, L in test_cases:\n        # Step 1: Model and discretization parameters\n        omega = 2.0 * np.pi / P\n        \n        # The time series will be stored in an array where index j corresponds\n        # to time index n = j - K. Array size is 2*K+1 for n from -K to K.\n        y = np.zeros(2 * K + 1, dtype=np.complex128)\n\n        # Step 2: Start-up procedure to excite the computational mode\n        # y^0 = 1 + 0i\n        idx_0 = K\n        y[idx_0] = 1.0 + 0.0j\n        \n        # y^1_FE = y^0 + dt * i * omega * y^0\n        y1_fe = y[idx_0] * (1.0 + 1j * omega * dt)\n        \n        # y^-1 is defined by inverting leapfrog at n=0\n        # y^-1 = y^1_FE - 2 * i * omega * dt * y^0\n        idx_m1 = K - 1\n        y[idx_m1] = y1_fe - 2.0 * 1j * omega * dt * y[idx_0]\n        \n        # Use the first leapfrog step to define y^1\n        # y^1 = y^-1 + 2 * i * omega * dt * y^0, which equals y^1_FE\n        idx_p1 = K + 1\n        y[idx_p1] = y[idx_m1] + 2.0 * 1j * omega * dt * y[idx_0]\n        \n        # Generate the time series using the leapfrog scheme\n        # Forward in time from n=1 to K-1 - y^2...y^K\n        for n in range(1, K):\n            j = K + n  # current time index in array\n            y[j + 1] = y[j - 1] + 2.0 * 1j * omega * dt * y[j]\n        \n        # Backward in time from n=-1 to -K+1 - y^-2...y^-K\n        # Inverted leapfrog: y^(n-1) = y^(n+1) - 2*i*omega*dt*y^n\n        for n in range(0, -K, -1):\n            j = K + n  # current time index in array\n            y[j - 1] = y[j + 1] - 2.0 * 1j * omega * dt * y[j]\n            \n        # Step 3: Define the time-symmetric digital filter\n        M = (L - 1) // 2\n        weights = np.zeros(L)\n        for k_idx, k in enumerate(range(-M, M + 1)):\n            weights[k_idx] = comb(L - 1, k + M) / (2**(L - 1))\n            \n        # Apply the filter to find y^0_filt and y^-1_filt\n        # y^n_filt = sum_{k=-M to M} w_k * y^{n+k}\n        \n        # For y^0_filt, n=0. The window is y^{-M}, ..., y^{M}\n        # Array indices: K-M, ..., K+M\n        y0_filt = np.dot(weights, y[idx_0 - M : idx_0 + M + 1])\n        \n        # For y^-1_filt, n=-1. The window is y^{-1-M}, ..., y^{-1+M}\n        # Array indices: K-1-M, ..., K-1+M\n        ym1_filt = np.dot(weights, y[idx_m1 - M : idx_m1 + M + 1])\n\n        # Step 4: Compute computational mode amplitude before and after DFI\n        # A_before = |1/2 * (y^0 - y^-1)|\n        A_before = 0.5 * np.abs(y[idx_0] - y[idx_m1])\n        \n        # A_after = |1/2 * (y^0_filt - y^-1_filt)|\n        A_after = 0.5 * np.abs(y0_filt - ym1_filt)\n\n        # Compute the reduction factor R\n        if A_before == 0:\n            # Avoid division by zero, though not expected in these cases\n            R = 0.0 if A_after == 0.0 else np.inf\n        else:\n            R = A_after / A_before\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}