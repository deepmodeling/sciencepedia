{
    "hands_on_practices": [
        {
            "introduction": "Many time-stepping schemes used in numerical models, such as the efficient leapfrog scheme, can unfortunately introduce non-physical, high-frequency oscillations known as computational modes. Digital Filter Initialization (DFI) offers a direct and powerful method for removing this numerical noise right at the start of a forecast. This practice provides a concrete, hands-on implementation of a simple digital filter, allowing you to directly observe and quantify its effectiveness in cleaning up the initial model state .",
            "id": "4031228",
            "problem": "Consider a single complex Fourier coefficient representing a linear normal mode of the linearized dynamical core of a numerical weather prediction model. Let the complex amplitude be denoted by $y(t)$ and assume it satisfies the linear ordinary differential equation $dy/dt = i \\omega y$, where $\\omega$ is a real angular frequency in radians per second. The time discretization uses the leapfrog scheme on a uniform grid with time step $\\Delta t$ seconds, defined by the three-time-level recurrence $y^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}$, where $y^{n} \\approx y(t_{n})$ at $t_{n} = n \\Delta t$. The leapfrog scheme supports both a physical mode and a parasitic computational mode characterized by an alternating sign in time. Digital Filter Initialization (DFI) is a time-symmetric procedure to reduce the computational mode amplitude by convolving a short, symmetric window of the model trajectory with fixed weights.\n\nYou are to implement Digital Filter Initialization (DFI) in this leapfrog setting for a single complex scalar $y(t)$ and quantify the reduction in the computational mode amplitude at a single time level immediately after initialization. The initialization excites the computational mode via a single forward Euler start, after which the leapfrog scheme is used. The required steps are as follows, and every step must be implemented exactly as stated:\n\n- Model and discretization. Use the linear model $dy/dt = i \\omega y$ with the leapfrog scheme $y^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}$.\n- Startup that excites the computational mode. Set $y^{0} = 1 + 0 i$. Compute a single forward Euler step to $t_{1}$ by $y^{1}_{\\mathrm{FE}} = y^{0} + \\Delta t \\, i \\omega \\, y^{0}$. Define $y^{-1}$ by inverting the leapfrog recurrence at $n=0$ so that the leapfrog relation holds at $(n=-1,0,1)$, that is, $y^{-1} = y^{1}_{\\mathrm{FE}} - 2 i \\omega \\Delta t \\, y^{0}$. Use this $y^{-1}$ and $y^{0}$ together with the leapfrog scheme to generate a discrete time series $\\{ y^{n} \\}$ for indices $n$ from $-K$ to $+K$, where $K$ is a fixed positive integer.\n- Time-symmetric digital filter. Use a finite impulse response, symmetric, time-invariant digital filter of odd length $L$ with weights $\\{ w_{k} \\}_{k=-M}^{M}$, where $M = (L-1)/2$, satisfying $\\sum_{k=-M}^{M} w_{k} = 1$ and $\\sum_{k=-M}^{M} (-1)^{k} w_{k} = 0$. For this task, use the normalized binomial weights of order $L-1$, that is, $w_{k} = \\binom{L-1}{k+M} / 2^{L-1}$ for $k=-M,\\ldots,M$. For example, for $L=3$ the weights are $[1,2,1]/4$ and for $L=5$ the weights are $[1,4,6,4,1]/16$. Define the filtered value at time index $n$ by $y^{n}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_{k} \\, y^{n+k}$, provided all indices $n+k$ lie in the available time window.\n- Computational mode amplitude measure. For any consecutive pair of time levels, define the alternating (computational) component at index $n$ by $a^{n} = \\tfrac{1}{2} \\left( y^{n} - y^{n-1} \\right)$. Define the unfiltered computational amplitude at the initialization time by $A_{\\mathrm{before}} = \\lvert a^{0} \\rvert = \\left\\lvert \\tfrac{1}{2} \\left( y^{0} - y^{-1} \\right) \\right\\rvert$. Define the filtered computational amplitude by using filtered values at indices $n=0$ and $n=-1$ as $A_{\\mathrm{after}} = \\left\\lvert \\tfrac{1}{2} \\left( y^{0}_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}} \\right) \\right\\rvert$. The required metric is the reduction factor $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$, which is dimensionless.\n- Units and numerical constraints. Use $\\omega$ in radians per second and $\\Delta t$ in seconds. The integration index half-span must be $K = 32$ so that the time window spans indices $n=-32,-31,\\ldots,+31,+32$. Ensure that the leapfrog integration is numerically neutral (no blow-up) by using test cases whose $\\omega \\Delta t$ does not violate the leapfrog stability for the linear oscillation model.\n\nYour task is to write a complete program that:\n- Constructs the time series $\\{ y^{n} \\}$ for each test case using the specified initialization.\n- Applies the time-symmetric digital filter centered at $n=0$ and at $n=-1$ using the specified weights.\n- Computes the reduction factor $R$ for each test case.\n\nTest suite:\n- Case $1$: period $P = 600$ seconds, so $\\omega = 2\\pi / P$, time step $\\Delta t = 30$ seconds, filter length $L = 3$.\n- Case $2$: period $P = 240$ seconds, so $\\omega = 2\\pi / P$, time step $\\Delta t = 30$ seconds, filter length $L = 3$.\n- Case $3$: period $P = 1200$ seconds, so $\\omega = 2\\pi / P$, time step $\\Delta t = 30$ seconds, filter length $L = 5$.\n- Case $4$: period $P = 300$ seconds, so $\\omega = 2\\pi / P$, time step $\\Delta t = 20$ seconds, filter length $L = 5$.\n\nAll outputs must be floats. Your program should produce a single line of output containing the four reduction factors in the order of the test cases as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places (for example, $[0.123456,0.234567,0.345678,0.456789]$). No other text should be printed.",
            "solution": "The problem requires the implementation and evaluation of a Digital Filter Initialization (DFI) procedure for a single linear normal mode in a numerical model. The goal is to quantify the reduction of the parasitic computational mode inherent to the leapfrog time-stepping scheme.\n\n### 1. The Model and Discretization Scheme\n\nThe physical system is a linear oscillator described by the ordinary differential equation:\n$$\n\\frac{dy}{dt} = i \\omega y\n$$\nwhere $y(t)$ is a complex amplitude and $\\omega$ is a real-valued angular frequency. The exact solution is $y(t) = y(0) e^{i \\omega t}$, representing a pure oscillation.\n\nThe time discretization is performed using the three-time-level leapfrog scheme on a uniform grid $t_n = n \\Delta t$:\n$$\ny^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}\n$$\nThis is a finite difference approximation of the continuous equation. To analyze its behavior, we seek solutions of the form $y^n = \\lambda^n$. Substituting this into the recurrence relation yields the characteristic equation:\n$$\n\\lambda^2 - 2 i (\\omega \\Delta t) \\lambda - 1 = 0\n$$\nLet $x = \\omega \\Delta t$. The roots are given by the quadratic formula:\n$$\n\\lambda = i x \\pm \\sqrt{(-ix)^2 - (-1)} = i x \\pm \\sqrt{1 - x^2}\n$$\nFor the scheme to be numerically stable, the magnitude of the roots must not exceed $1$. This requires $1 - x^2 \\ge 0$, which leads to the Courant-Friedrichs-Lewy (CFL) condition $|x| = |\\omega \\Delta t| \\le 1$. All test cases provided in the problem statement satisfy this condition.\n\nUnder this condition, there are two distinct roots, both with a modulus of $1$:\n1.  **Physical Mode Root ($\\lambda_p$)**: $\\lambda_p = \\sqrt{1 - x^2} + i x$. This can be written as $\\lambda_p = e^{i\\theta_p}$ where the numerical phase change per time step is $\\theta_p = \\arcsin(x) = \\arcsin(\\omega \\Delta t)$. The numerical frequency is $\\omega_{\\text{num}} = \\theta_p / \\Delta t \\approx \\omega$ for small $\\omega \\Delta t$. This root approximates the true physical behavior.\n2.  **Computational Mode Root ($\\lambda_c$)**: $\\lambda_c = -\\sqrt{1 - x^2} + i x$. This can be written as $\\lambda_c = e^{i\\theta_c}$ where $\\theta_c = \\pi - \\arcsin(\\omega \\Delta t)$. This root is an artifact of the three-time-level scheme. Its frequency is close to the Nyquist frequency $\\pi/\\Delta t$, and it exhibits an alternating sign in time due to the $\\pi$ term in its phase, making it parasitic.\n\nThe general numerical solution is a linear combination of these two modes:\n$$\ny^n = A_p (\\lambda_p)^n + A_c (\\lambda_c)^n\n$$\nwhere $A_p$ and $A_c$ are the complex amplitudes of the physical and computational modes, respectively, determined by the initial conditions.\n\n### 2. Startup Procedure and Excitation of the Computational Mode\n\nThe problem specifies a startup procedure designed to intentionally excite the computational mode. The initialization begins with $y^0 = 1$. A second time level is obtained via a single forward Euler step:\n$$\ny^{1}_{\\mathrm{FE}} = y^{0} + i \\omega \\Delta t \\, y^{0} = (1 + i \\omega \\Delta t)\n$$\nTo start the three-level leapfrog scheme, a value at $t_{-1}$ is required. $y^{-1}$ is defined by requiring the leapfrog relation to hold for the triplet $(y^{-1}, y^0, y^1_{\\mathrm{FE}})$:\n$$\ny^{1}_{\\mathrm{FE}} = y^{-1} + 2 i \\omega \\Delta t \\, y^0 \\implies y^{-1} = y^{1}_{\\mathrm{FE}} - 2 i \\omega \\Delta t \\, y^0 = (1 + i \\omega \\Delta t) - 2 i \\omega \\Delta t = 1 - i \\omega \\Delta t\n$$\nThis two-step initialization (using a two-level scheme like forward Euler to generate a point) creates an imbalance between the time levels, which projects onto the computational mode, thus setting $A_c \\neq 0$. With $y^{-1}$ and $y^0$ defined, the entire time series $\\{y^n\\}_{n=-K}^K$ can be generated using the leapfrog recurrence forwards and backwards from $n=0$.\n\n### 3. Digital Filter Initialization (DFI)\n\nDFI aims to suppress the computational mode by applying a low-pass digital filter. The specified filter is a symmetric, finite impulse response (FIR) filter of odd length $L = 2M+1$ with weights $\\{w_k\\}_{k=-M}^M$. The filtered value at time $n$ is a weighted average:\n$$\ny^{n}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_{k} \\, y^{n+k}\n$$\nThe weights are given as normalized binomial coefficients of order $L-1$:\n$$\nw_k = \\frac{\\binom{L-1}{k+M}}{2^{L-1}}, \\quad k = -M, \\dots, M\n$$\nThese weights satisfy two crucial properties:\n1.  $\\sum_{k=-M}^{M} w_k = 1$: The filter has unit gain for zero-frequency signals (DC component), preserving the mean state.\n2.  $\\sum_{k=-M}^{M} (-1)^k w_k = 0$: The filter has zero gain at the Nyquist frequency $\\pi / \\Delta t$. Since the computational mode's frequency is close to this, the filter strongly damps it.\n\nThe frequency response of this binomial filter is $H(\\Omega) = (\\cos(\\Omega/2))^{L-1}$, where $\\Omega$ is the digital frequency. The filter's response at the computational mode's frequency $\\Omega_c = \\pi - \\theta_p$ is $(\\cos((\\pi-\\theta_p)/2))^{L-1} = (\\sin(\\theta_p/2))^{L-1}$. For small $\\theta_p$, this value is very small, confirming the strong damping of the computational mode.\n\n### 4. Quantifying the Reduction\n\nThe amplitude of the computational mode is measured by its characteristic high-frequency oscillation. The alternating component is defined as:\n$$\na^n = \\frac{1}{2} (y^n - y^{n-1})\n$$\nThe amplitude of this component before and after filtering is used to quantify the filter's effectiveness.\n- **Before DFI**: The amplitude at the initialization time $t_0$ is $A_{\\mathrm{before}} = |a^0| = \\left| \\frac{1}{2} (y^0 - y^{-1}) \\right|$. Using the startup values:\n  $$\n  A_{\\mathrm{before}} = \\left| \\frac{1}{2} (1 - (1 - i \\omega \\Delta t)) \\right| = \\left| \\frac{1}{2} i \\omega \\Delta t \\right| = \\frac{\\omega \\Delta t}{2}\n  $$\n- **After DFI**: The filtered values at $t_0$ and $t_{-1}$ are computed, and the amplitude is derived from them:\n  $$\n  A_{\\mathrm{after}} = \\left| \\frac{1}{2} (y^0_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}}) \\right|\n  $$\n  where $y^0_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_k y^k$ and $y^{-1}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_k y^{k-1}$.\nThe reduction factor is the ratio $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$.\n\n### 5. Algorithmic Procedure\n\nThe solution is computed by following these steps for each test case:\n1.  Calculate $\\omega = 2\\pi/P$.\n2.  Set the time series half-span $K=32$. Create a complex-valued array `y` to store the time series $\\{y^n\\}_{n=-K}^K$.\n3.  Initialize the first two required values based on the startup procedure: $y^0 = 1$ and $y^{-1} = 1 - i \\omega \\Delta t$.\n4.  Generate the full time series using the leapfrog recurrence relation:\n    - For $n=1, \\dots, K$: $y^n = y^{n-2} + 2 i \\omega \\Delta t \\, y^{n-1}$.\n    - For $n=-2, \\dots, -K$: $y^n = y^{n+2} - 2 i \\omega \\Delta t \\, y^{n+1}$.\n5.  Calculate the FIR filter weights $\\{w_k\\}$ for the given filter length $L$ using the binomial coefficient formula.\n6.  Compute the filtered values $y^0_{\\mathrm{filt}}$ and $y^{-1}_{\\mathrm{filt}}$ by convolving the weights with the appropriate segment of the time series `y`.\n7.  Calculate the 'before' amplitude $A_{\\mathrm{before}} = |\\frac{1}{2}(y^0 - y^{-1})|$.\n8.  Calculate the 'after' amplitude $A_{\\mathrm{after}} = |\\frac{1}{2}(y^0_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}})|$.\n9.  Compute and store the reduction factor $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$.\n10. Format the results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Implements and evaluates Digital Filter Initialization (DFI) for a single\n    linear normal mode discretized with the leapfrog scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Period P in s, time step dt in s, filter length L)\n        (600.0, 30.0, 3),\n        (240.0, 30.0, 3),\n        (1200.0, 30.0, 5),\n        (300.0, 20.0, 5),\n    ]\n\n    results = []\n    \n    # Integration index half-span as specified\n    K = 32\n\n    for P, dt, L in test_cases:\n        # Step 1: Model and discretization parameters\n        omega = 2.0 * np.pi / P\n        \n        # The time series will be stored in an array where index j corresponds\n        # to time index n = j - K. Array size is 2*K+1 for n from -K to K.\n        y = np.zeros(2 * K + 1, dtype=np.complex128)\n\n        # Step 2: Start-up procedure to excite the computational mode\n        # y^0 = 1 + 0i\n        idx_0 = K\n        y[idx_0] = 1.0 + 0.0j\n        \n        # y^1_FE = y^0 + dt * i * omega * y^0\n        y1_fe = y[idx_0] * (1.0 + 1j * omega * dt)\n        \n        # y^-1 is defined by inverting leapfrog at n=0\n        # y^-1 = y^1_FE - 2 * i * omega * dt * y^0\n        idx_m1 = K - 1\n        y[idx_m1] = y1_fe - 2.0 * 1j * omega * dt * y[idx_0]\n        \n        # Use the first leapfrog step to define y^1\n        # y^1 = y^-1 + 2 * i * omega * dt * y^0, which equals y^1_FE\n        idx_p1 = K + 1\n        y[idx_p1] = y[idx_m1] + 2.0 * 1j * omega * dt * y[idx_0]\n        \n        # Generate the time series using the leapfrog scheme\n        # Forward in time from n=1 to K-1 -> y^2...y^K\n        for n in range(1, K):\n            j = K + n  # current time index in array\n            y[j + 1] = y[j - 1] + 2.0 * 1j * omega * dt * y[j]\n        \n        # Backward in time from n=-1 to -K+1 -> y^-2...y^-K\n        # Inverted leapfrog: y^(n-1) = y^(n+1) - 2*i*omega*dt*y^n\n        for n in range(0, -K, -1):\n            j = K + n  # current time index in array\n            y[j - 1] = y[j + 1] - 2.0 * 1j * omega * dt * y[j]\n            \n        # Step 3: Define the time-symmetric digital filter\n        M = (L - 1) // 2\n        weights = np.zeros(L)\n        for k_idx, k in enumerate(range(-M, M + 1)):\n            weights[k_idx] = comb(L - 1, k + M) / (2**(L - 1))\n            \n        # Apply the filter to find y^0_filt and y^-1_filt\n        # y^n_filt = sum_{k=-M to M} w_k * y^{n+k}\n        \n        # For y^0_filt, n=0. The window is y^{-M}, ..., y^{M}\n        # Array indices: K-M, ..., K+M\n        y0_filt = np.dot(weights, y[idx_0 - M : idx_0 + M + 1])\n        \n        # For y^-1_filt, n=-1. The window is y^{-1-M}, ..., y^{-1+M}\n        # Array indices: K-1-M, ..., K-1+M\n        ym1_filt = np.dot(weights, y[idx_m1 - M : idx_m1 + M + 1])\n\n        # Step 4: Compute computational mode amplitude before and after DFI\n        # A_before = |1/2 * (y^0 - y^-1)|\n        A_before = 0.5 * np.abs(y[idx_0] - y[idx_m1])\n        \n        # A_after = |1/2 * (y^0_filt - y^-1_filt)|\n        A_after = 0.5 * np.abs(y0_filt - ym1_filt)\n\n        # Compute the reduction factor R\n        if A_before == 0:\n            # Avoid division by zero, though not expected in these cases\n            R = 0.0 if A_after == 0.0 else np.inf\n        else:\n            R = A_after / A_before\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While DFI provides a general-purpose filter, Normal Mode Initialization (NMI) offers a more physically targeted approach by adjusting the initial amplitudes of the model's \"normal modes\" of oscillation. To perform NMI, one must first identify these modes by solving an eigenvalue problem derived from the model's governing equations. This exercise takes you through this foundational step, bridging the gap between the continuous theory of vertical atmospheric structure and its discrete representation in a numerical model .",
            "id": "4031276",
            "problem": "Consider the vertical structure of small-amplitude, linear internal gravity waves under the Hydrostatic and Boussinesq approximations in Numerical Weather Prediction (NWP) and climate modeling. In the simplest case of constant stratification and rigid-lid boundaries at the surface and model top, the vertical structure reduces to a one-dimensional Sturm–Liouville boundary value problem. This framework underlies Normal Mode Initialization (NMI), which decomposes the initial conditions into physically meaningful modes, and the design of digital filters that selectively attenuate fast modes.\n\nStarting from the one-dimensional vertical second-order ordinary differential operator associated with rigid-lid boundary conditions, formulate the continuous eigenvalue problem on the interval $[0,H]$ with $H$ the model top height. Then construct a discrete counterpart using a uniform-grid, centered second-order finite-difference scheme on $K$ interior levels and homogeneous Dirichlet boundary conditions at $z=0$ and $z=H$. Your task is to:\n\n1. Derive the continuous boundary value problem for the vertical modes in terms of an eigenvalue problem for a function $y(z)$ on $[0,H]$ with appropriate boundary conditions. Explain how the boundary conditions arise from rigid-lid assumptions and continuity of the vertical velocity.\n2. Discretize the second derivative using a centered finite-difference formula on $K$ interior levels, with grid spacing $\\Delta z = H/(K+1)$ and homogeneous Dirichlet boundary conditions at the endpoints. Assemble the resulting $K \\times K$ tridiagonal matrix and write the discrete eigenvalue problem it defines.\n3. For each discrete eigenpair, obtain the eigenvalues and eigenvectors numerically. Associate the $m$-th discrete eigenpair to the $m$-th continuous mode by ordering eigenvalues increasingly.\n4. Quantify discretization error by comparing:\n   - Eigenvalues: compute the relative error $\\epsilon_{\\lambda}(m) = \\left(\\lambda_{d}(m) - \\lambda_{c}(m)\\right)/\\lambda_{c}(m)$, where $\\lambda_{c}(m)$ is the continuous eigenvalue of the $m$-th mode and $\\lambda_{d}(m)$ is the corresponding discrete eigenvalue.\n   - Eigenvectors: compute a normalized root-mean-square mismatch $\\epsilon_{v}(m)$ between the discrete eigenvector $v_{d}^{(m)}$ and the continuous eigenfunction $y_{c}^{(m)}(z)$ sampled at the interior grid points. To compare shapes, first scale both vectors to unit $\\ell^{2}$ norm and choose the sign of one to minimize the norm of their difference.\n\nScientific base:\n- Use the standard one-dimensional vertical operator appropriate for rigid-lid boundaries and constant coefficients, and the well-tested centered finite difference for the second derivative.\n- Assume $H$ is finite and positive, and use homogeneous Dirichlet boundary conditions $y(0) = 0$ and $y(H) = 0$ to represent rigid boundaries suppressing vertical displacement at the endpoints.\n\nUnits and output:\n- Treat $H$ in meters and report eigenvalues in $\\mathrm{m}^{-2}$ if needed. The required outputs are dimensionless errors $\\epsilon_{\\lambda}(m)$ and $\\epsilon_{v}(m)$; report them as decimals (without percentage signs).\n- Angles are not used.\n\nTest suite:\nFor each of the following test cases, compute the set of errors for the requested modes. Use $H = 10000$ meters for all cases.\n- Case 1: $K=8$, modes $m \\in \\{1,2,4,8\\}$.\n- Case 2: $K=33$, modes $m \\in \\{1,3,8,16\\}$.\n- Case 3: $K=65$, modes $m \\in \\{1,5,15,30\\}$.\n- Case 4 (edge case): $K=3$, modes $m \\in \\{1,2\\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a nested list with two sublists: the first sublist contains the relative eigenvalue errors $\\epsilon_{\\lambda}(m)$ in the order of the specified modes, and the second sublist contains the eigenvector mismatch errors $\\epsilon_{v}(m)$ in the same order. The overall output must be a list of these per-case lists, in the order of the test suite above. For example, the shape should be\n[[[e11,e12,...],[v11,v12,...]],[[e21,e22,...],[v21,v22,...]],[[e31,...],[v31,...]],[[e41,...],[v41,...]]]\nwhere $eij$ and $vij$ are floats.",
            "solution": "The problem requires the formulation and numerical analysis of a one-dimensional Sturm–Liouville problem that describes the vertical structure of internal gravity waves in a simplified atmospheric model. The analysis involves comparing the exact analytical solution of the continuous problem with the numerical solution of its finite-difference discretization.\n\n### 1. Continuous Boundary Value Problem\n\nThe vertical structure of linear internal gravity waves, under the specified approximations (hydrostatic, Boussinesq, constant stratification), is governed by a second-order ordinary differential equation for the vertical structure function, which we denote as $y(z)$. This function is proportional to the amplitude of the vertical velocity at height $z$. The operator associated with this structure is the second derivative, $\\frac{d^2}{dz^2}$. The search for normal modes leads to an eigenvalue problem:\n$$\n\\frac{d^2 y(z)}{dz^2} = \\lambda y(z)\n$$\nwhere $\\lambda$ is the eigenvalue, which is related to the vertical wavenumber squared ($k_z^2 = -\\lambda$). The domain is the interval $[0, H]$, where $z=0$ is the surface and $z=H$ is the model top.\n\nThe \"rigid-lid\" boundary conditions signify that there is no vertical motion at the boundaries. This means the vertical velocity, and thus the structure function $y(z)$, must be zero at these points. This gives rise to homogeneous Dirichlet boundary conditions:\n$$\ny(0) = 0 \\quad \\text{and} \\quad y(H) = 0\n$$\nThe problem is to solve the differential equation subject to these boundary conditions. The general solution to $y'' - \\lambda y = 0$ depends on the sign of $\\lambda$. For oscillatory (wave-like) solutions, we expect $\\lambda < 0$. Let $\\lambda = -k^2$ for some real $k>0$. The equation becomes $y'' + k^2 y = 0$.\nThe general solution is:\n$$\ny(z) = A \\sin(kz) + B \\cos(kz)\n$$\nApplying the first boundary condition, $y(0) = 0$:\n$$\ny(0) = A \\sin(0) + B \\cos(0) = B = 0\n$$\nThis simplifies the solution to $y(z) = A \\sin(kz)$. Applying the second boundary condition, $y(H) = 0$:\n$$\ny(H) = A \\sin(kH) = 0\n$$\nFor a non-trivial solution ($A \\neq 0$), we must have $\\sin(kH) = 0$. This condition is met when $kH$ is an integer multiple of $\\pi$.\n$$\nkH = m\\pi, \\quad \\text{for } m = 1, 2, 3, \\dots\n$$\nThe case $m=0$ is excluded as it leads to the trivial solution $y(z)=0$. The integer $m$ is the mode number, representing the number of half-wavelengths in the vertical domain.\nFrom this, we find the discrete set of allowed values for $k$, the vertical wavenumbers: $k_m = \\frac{m\\pi}{H}$.\nThe corresponding continuous eigenvalues $\\lambda_c(m)$ are:\n$$\n\\lambda_c(m) = -k_m^2 = -\\left(\\frac{m\\pi}{H}\\right)^2\n$$\nThe eigenfunctions $y_c^{(m)}(z)$ for each mode $m$ are:\n$$\ny_c^{(m)}(z) = \\sin\\left(\\frac{m\\pi z}{H}\\right)\n$$\nwhere a normalization constant is omitted as it will be handled later.\n\n### 2. Discretization and the Discrete Eigenvalue Problem\n\nWe discretize the domain $[0, H]$ using a uniform grid with $K$ interior points and $2$ boundary points. The total number of intervals is $K+1$. The grid spacing is $\\Delta z = \\frac{H}{K+1}$. The grid points are $z_j = j \\Delta z$ for $j=0, 1, \\dots, K+1$. The interior points are $z_1, \\dots, z_K$. Let $y_j = y(z_j)$.\n\nThe second derivative $\\frac{d^2y}{dz^2}$ at an interior point $z_j$ is approximated using a centered second-order finite-difference formula:\n$$\n\\frac{d^2 y}{dz^2}\\bigg|_{z_j} \\approx \\frac{y(z_{j+1}) - 2y(z_j) + y(z_{j-1})}{(\\Delta z)^2} = \\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2}\n$$\nThe discrete eigenvalue problem is then:\n$$\n\\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2} = \\lambda_d y_j \\quad \\text{for } j = 1, \\dots, K\n$$\nThe boundary conditions $y(0)=0$ and $y(H)=0$ become $y_0=0$ and $y_{K+1}=0$.\nThis system of $K$ linear equations can be written in matrix form $A\\mathbf{v} = \\lambda_d \\mathbf{v}$, where $\\mathbf{v} = [y_1, y_2, \\dots, y_K]^T$ is the vector of the solution at the interior grid points. The $K \\times K$ matrix $A$ is constructed as follows:\nFor $j=1$: $\\frac{y_2 - 2y_1 + y_0}{(\\Delta z)^2} = \\frac{y_2 - 2y_1}{(\\Delta z)^2} = \\lambda_d y_1$\nFor $j=K$: $\\frac{y_{K+1} - 2y_K + y_{K-1}}{(\\Delta z)^2} = \\frac{-2y_K + y_{K-1}}{(\\Delta z)^2} = \\lambda_d y_K$\nFor any other $j$: $\\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2} = \\lambda_d y_j$\n\nThis leads to the symmetric tridiagonal matrix $A$:\n$$\nA = \\frac{1}{(\\Delta z)^2}\n\\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 \\\\\n1 & -2 & 1 & \\ddots & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & 1 & -2 & 1 \\\\\n0 & \\cdots & 0 & 1 & -2\n\\end{pmatrix}_{K \\times K}\n$$\n\n### 3. Numerical Eigenpairs and Mode Association\n\nThe discrete eigenvalues $\\lambda_d(m)$ and eigenvectors $v_d^{(m)}$ are found by numerically solving the eigensystem for the matrix $A$. Since $A$ is a real, symmetric matrix, its eigenvalues are real and it possesses a complete set of orthogonal eigenvectors. Numerical libraries typically return eigenvalues sorted in increasing order.\n\nThe analytical eigenvalues of this specific matrix $A$ are known to be $\\lambda_d(m') = -\\frac{4}{(\\Delta z)^2}\\sin^2\\left(\\frac{m'\\pi}{2(K+1)}\\right)$ for $m' = 1, \\dots, K$.\nThe continuous eigenvalues are $\\lambda_c(m) = -(m\\pi/H)^2$.\nThe physical mode number $m$ corresponds to the number of half-wavelengths. For increasing $m$, the magnitude of the (negative) eigenvalue increases, so the value decreases.\n$\\lambda_c(1) > \\lambda_c(2) > \\dots$\nSimilarly, the discrete eigenvalues $\\lambda_d(m')$ decrease as $m'$ increases from $1$ to $K$.\nA numerical eigensolver will sort the eigenvalues in increasing order: $\\lambda_{(1)} \\le \\lambda_{(2)} \\le \\dots \\le \\lambda_{(K)}$.\nTherefore, the smallest eigenvalue $\\lambda_{(1)}$ corresponds to mode $m'=K$, and the largest eigenvalue $\\lambda_{(K)}$ corresponds to mode $m'=1$.\nThe problem associates the $m$-th discrete eigenpair with the $m$-th continuous mode. For a given mode number $m$ (from the problem statement, e.g., $m=1, 2, 4$), the corresponding discrete eigenvalue is $\\lambda_d(m)$ and the discrete eigenvector is $v_d^{(m)}$. From the sorted numerical results, this pair will be the $(K-m+1)$-th element. If the solver's returned indices are $0, \\dots, K-1$, then the eigenpair for mode $m$ will be at index $K-m$.\n\n### 4. Discretization Error Quantification\n\nThe error introduced by the finite-difference discretization is quantified by comparing the discrete and continuous eigenpairs.\n\n**Eigenvalue Error:** The relative error for the $m$-th mode's eigenvalue is:\n$$\n\\epsilon_{\\lambda}(m) = \\frac{\\lambda_d(m) - \\lambda_c(m)}{\\lambda_c(m)}\n$$\nwhere $\\lambda_c(m)$ is the analytical continuous eigenvalue and $\\lambda_d(m)$ is the corresponding numerically computed discrete eigenvalue.\n\n**Eigenvector Mismatch:** The error for the eigenvector is calculated as a normalized root-mean-square mismatch.\n1. The discrete eigenvector $v_d^{(m)}$ is a vector of length $K$.\n2. The continuous eigenfunction $y_c^{(m)}(z) = \\sin(m\\pi z/H)$ is sampled at the $K$ interior grid points, $z_j = j\\Delta z$ for $j=1, \\dots, K$, to form a vector $y_c^{(m, \\text{sampled})}$. The components are $\\sin(m\\pi j / (K+1))$.\n3. Both vectors are scaled to have a unit $\\ell^2$ norm: $\\hat{v}_d^{(m)} = v_d^{(m)} / \\|v_d^{(m)}\\|_2$ and $\\hat{y}_c^{(m)} = y_c^{(m, \\text{sampled})} / \\|y_c^{(m, \\text{sampled})}\\|_2$.\n4. Eigenvectors are defined only up to a sign. To ensure a meaningful comparison of shape, the sign of the numerical eigenvector is adjusted to match the analytical one. If $\\hat{v}_d^{(m)} \\cdot \\hat{y}_c^{(m)} < 0$, the sign of $\\hat{v}_d^{(m)}$ is flipped. Let this corrected vector be $\\hat{v}_d'^{(m)}$.\n5. The eigenvector mismatch is the $\\ell^2$ norm of the difference between the normalized, sign-corrected vectors:\n$$\n\\epsilon_{v}(m) = \\| \\hat{v}_d'^{(m)} - \\hat{y}_c^{(m)} \\|_2\n$$\nFor this specific problem, the analytical discrete eigenvectors are exactly proportional to the sampled continuous eigenfunctions. Therefore, $\\epsilon_{v}(m)$ is expected to be non-zero only due to floating-point inaccuracies in the numerical eigensolver, and should be close to machine precision.",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying discretization error for a 1D Sturm-Liouville\n    problem related to vertical modes in atmospheric models.\n    \"\"\"\n    \n    H = 10000.0  # Model top height in meters\n    \n    test_cases = [\n        {'K': 8, 'modes': [1, 2, 4, 8]},\n        {'K': 33, 'modes': [1, 3, 8, 16]},\n        {'K': 65, 'modes': [1, 5, 15, 30]},\n        {'K': 3, 'modes': [1, 2]},\n    ]\n    \n    overall_results = []\n    \n    for case in test_cases:\n        K = case['K']\n        modes_to_test = case['modes']\n        \n        delta_z = H / (K + 1)\n        \n        # 1. Assemble the K x K tridiagonal matrix A for the discrete operator\n        main_diag = -2.0 * np.ones(K)\n        off_diag = np.ones(K - 1)\n        \n        # The matrix for the second derivative is T/dz^2\n        # where T is the tridiagonal matrix with (-2, 1, 1).\n        A = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (delta_z**2)\n        \n        # 2. Solve the discrete eigenvalue problem numerically\n        # linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        discrete_eigenvalues, discrete_eigenvectors = linalg.eigh(A)\n        \n        case_lambda_errors = []\n        case_vec_errors = []\n        \n        # Grid points for sampling the continuous solution\n        z_grid = np.arange(1, K + 1) * delta_z\n        \n        for m in modes_to_test:\n            # Check if mode m can be resolved by the grid\n            if m > K:\n                continue\n\n            # 3. Calculate continuous eigenvalues and eigenfunctions\n            lambda_c = -((m * np.pi) / H)**2\n            \n            # The continuous eigenfunction sampled at interior grid points\n            # y_c(z_j) = sin(m*pi*z_j / H) = sin(m*pi*j*dz / H) = sin(m*pi*j / (K+1))\n            vec_c_sampled = np.sin(m * np.pi * np.arange(1, K + 1) / (K + 1))\n\n            # 4. Associate discrete results with the m-th mode\n            # Eigenvalues from eigh are sorted ascendingly.\n            # The physical mode 'm' corresponds to the (K-m+1)-th eigenvalue in\n            # a list sorted by physical meaning (decreasing value).\n            # In an ascending sort (from most negative to least), mode 'm'\n            # corresponds to index K-m.\n            eigval_index = K - m\n            lambda_d = discrete_eigenvalues[eigval_index]\n            vec_d = discrete_eigenvectors[:, eigval_index]\n            \n            # 5. Quantify errors\n            # Relative eigenvalue error\n            epsilon_lambda = (lambda_d - lambda_c) / lambda_c\n            case_lambda_errors.append(epsilon_lambda)\n            \n            # Eigenvector mismatch\n            # Normalize both vectors to unit l2 norm\n            norm_vec_d = np.linalg.norm(vec_d)\n            norm_vec_c = np.linalg.norm(vec_c_sampled)\n            \n            # Avoid division by zero if a vector is all zeros (highly unlikely)\n            if norm_vec_d == 0.0 or norm_vec_c == 0.0:\n                epsilon_v = np.nan\n            else:\n                v_d_norm = vec_d / norm_vec_d\n                v_c_norm = vec_c_sampled / norm_vec_c\n            \n                # Adjust sign of numerical eigenvector for consistent comparison\n                if np.dot(v_d_norm, v_c_norm) < 0:\n                    v_d_norm *= -1.0\n                \n                # Compute normalized RMS mismatch as the L2 norm of the difference\n                epsilon_v = np.linalg.norm(v_d_norm - v_c_norm)\n                case_vec_errors.append(epsilon_v)\n\n        overall_results.append([case_lambda_errors, case_vec_errors])\n\n    # Format the final output exactly as specified\n    # Using a custom function to format the list of lists\n    def format_nested_list(data):\n        outer_parts = []\n        for sublist1 in data:\n            inner_parts = []\n            for sublist2 in sublist1:\n                inner_parts.append(f\"[{','.join(f'{x:.10f}' for x in sublist2)}]\")\n            outer_parts.append(f\"[{','.join(inner_parts)}]\")\n        return f\"[{','.join(outer_parts)}]\"\n\n    print(format_nested_list(overall_results))\n\nsolve()\n```"
        },
        {
            "introduction": "With an understanding of what normal modes are, we can use them to initialize the model in a \"balanced\" state that is free from the spurious gravity waves that contaminate forecasts. Simply removing the linear fast modes is a good first step, but accounting for the nonlinear interactions between modes is the key to a truly quiet start. In this practice, you will directly compare a raw, unbalanced analysis with both Linear and Nonlinear NMI, quantifying the dramatic reduction in noise achieved by a properly balanced initial state .",
            "id": "4031279",
            "problem": "Consider a simplified forecast model that isolates fast gravity-wave oscillations generated by imbalance in an analyzed baroclinic jet. The underlying physical base is the rotating shallow-water equations on an $f$-plane, which admit a balanced geostrophic (slow) mode and inertia–gravity (fast) modes. In a one-dimensional spectral slice with wavenumber $k$, the linear normal modes of the rotating shallow-water equations are well known to consist of a slow balanced mode with frequency $0$ and two fast gravity-wave modes with frequencies $\\pm \\omega$, where $\\omega$ is the inertia–gravity wave frequency. Weakly nonlinear interactions between the balanced mode and the fast modes can be modeled as a quadratic forcing of the fast modes by the balanced field. \n\nFor the purpose of this exercise and to focus computational effort on the fast-mode content, assume the balanced baroclinic jet amplitude $B$ is constant in time over the first $12$ hours and acts as a source for fast modes through a quadratic nonlinear term. Denote the fast-mode displacement amplitude by $G(t)$ and its time derivative (fast-mode velocity amplitude) by $V(t) = dG/dt$. The gravity-wave dynamics is modeled by the forced harmonic oscillator\n$$\n\\frac{dG}{dt} = V, \\qquad\n\\frac{dV}{dt} = -\\omega^2 G + \\epsilon B^2,\n$$\nwhere $\\omega$ is the nonnegative gravity-wave angular frequency in $\\mathrm{s}^{-1}$, $\\epsilon$ is a small nonnegative coefficient with units $\\mathrm{s}^{-2}$ that encapsulates the effective strength of weakly nonlinear quadratic coupling, and $B$ is a dimensionless amplitude parameter representing the baroclinic jet magnitude. All variables $G$ and $V$ are dimensionless. Time $t$ is measured in seconds.\n\nYou must compare three forecast evolutions over the first $12$ hours ($T = 43200 \\ \\mathrm{s}$), each starting from a distinct initialization state:\n- Raw analysis: initial conditions $G(0) = G_{\\mathrm{raw}}$ and $V(0) = V_{\\mathrm{raw}}$ are provided and may include spurious fast-mode content due to imbalance.\n- Linear Normal Mode Initialization (NMI): set $G(0) = 0$ and $V(0) = 0$, which removes linear fast-mode components by projecting onto the slow balanced subspace of the linearized operator.\n- Nonlinear Normal Mode Initialization (NMI): set $G(0) = \\epsilon B^2 / \\omega^2$ and $V(0) = 0$, which places the fast mode on the nonlinear slow manifold consistent with quadratic balance to leading order, thereby minimizing startup transients.\n\nNumerically integrate the system for each initialization over $t \\in [0,T]$ using a fixed time step $\\Delta t$ (in seconds). Quantify the amplitude of gravity-wave oscillations by detrending the time series to remove any constant offset and reporting the half peak-to-peak amplitude:\n$$\n\\overline{G} = \\frac{1}{N} \\sum_{n=0}^{N-1} G(t_n), \\quad \\text{with} \\quad t_n = n \\Delta t, \\quad N = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor + 1,\n$$\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n < N} \\left( G(t_n) - \\overline{G} \\right) - \\min_{0 \\le n < N} \\left( G(t_n) - \\overline{G} \\right) \\right],\n$$\nexpressed as a dimensionless float. This $A$ measures the amplitude of the high-frequency gravity-wave oscillations over the first $12$ hours.\n\nUnits and numerical requirements:\n- Use seconds for time ($\\mathrm{s}$), seconds inverse for frequency ($\\mathrm{s}^{-1}$), and seconds inverse squared for the nonlinear coupling coefficient ($\\mathrm{s}^{-2}$). All amplitudes ($G$, $V$, $B$, $A$) are dimensionless.\n- Use radians implicitly for angular frequency $\\omega$ in $\\mathrm{s}^{-1}$.\n- Implement a numerically stable explicit scheme (for example, classical fourth-order Runge–Kutta) with the given $\\Delta t$.\n- Report all amplitudes as floats.\n\nTest suite:\nFor each parameter tuple $(\\omega, \\epsilon, B, G_{\\mathrm{raw}}, V_{\\mathrm{raw}}, \\Delta t)$ below, perform the three runs (raw analysis, linear NMI, nonlinear NMI) and compute $A$ for each. The parameter sets are:\n1. Typical midlatitude baroclinic jet and modest quadratic coupling (happy path):\n   - $\\omega = 1.5 \\times 10^{-3} \\ \\mathrm{s}^{-1}$,\n   - $\\epsilon = 2.0 \\times 10^{-7} \\ \\mathrm{s}^{-2}$,\n   - $B = 1.0$,\n   - $G_{\\mathrm{raw}} = 0.5$,\n   - $V_{\\mathrm{raw}} = 0.0$,\n   - $\\Delta t = 60 \\ \\mathrm{s}$.\n2. Boundary case with no spurious fast-mode content and zero quadratic coupling:\n   - $\\omega = 1.0 \\times 10^{-3} \\ \\mathrm{s}^{-1}$,\n   - $\\epsilon = 0.0 \\ \\mathrm{s}^{-2}$,\n   - $B = 0.8$,\n   - $G_{\\mathrm{raw}} = 0.0$,\n   - $V_{\\mathrm{raw}} = 0.0$,\n   - $\\Delta t = 60 \\ \\mathrm{s}$.\n3. Stronger quadratic coupling and a larger jet with small but nonzero initial fast-mode velocity:\n   - $\\omega = 2.0 \\times 10^{-3} \\ \\mathrm{s}^{-1}$,\n   - $\\epsilon = 1.0 \\times 10^{-6} \\ \\mathrm{s}^{-2}$,\n   - $B = 2.0$,\n   - $G_{\\mathrm{raw}} = 0.1$,\n   - $V_{\\mathrm{raw}} = 1.0 \\times 10^{-4}$,\n   - $\\Delta t = 30 \\ \\mathrm{s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each test case, the three amplitudes $(A_{\\mathrm{raw}}, A_{\\mathrm{linNMI}}, A_{\\mathrm{nonlinNMI}})$, flattened into one list. For example, the output format is $[A_{1,\\mathrm{raw}},A_{1,\\mathrm{lin}},A_{1,\\mathrm{nonlin}},A_{2,\\mathrm{raw}},A_{2,\\mathrm{lin}},A_{2,\\mathrm{nonlin}},A_{3,\\mathrm{raw}},A_{3,\\mathrm{lin}},A_{3,\\mathrm{nonlin}}]$, expressed as dimensionless floats.",
            "solution": "The problem requires a comparative analysis of three different initialization schemes for a simplified numerical weather forecast model. The model's dynamics are governed by a forced harmonic oscillator, representing the generation of fast inertia-gravity waves from a balanced baroclinic jet. The core of the task is to numerically integrate the system of ordinary differential equations (ODEs), quantify the resulting gravity-wave oscillations for each initialization, and report the findings for a given set of test cases.\n\nThe governing equations for the fast-mode displacement amplitude $G(t)$ and velocity amplitude $V(t)$ are given as a system of two first-order ODEs:\n$$\n\\frac{dG}{dt} = V\n$$\n$$\n\\frac{dV}{dt} = -\\omega^2 G + \\epsilon B^2\n$$\nwhere $G$ and $V$ are dimensionless amplitudes, $t$ is time in seconds, $\\omega$ is the gravity-wave angular frequency in $\\mathrm{s}^{-1}$, $\\epsilon$ is the nonlinear coupling coefficient in $\\mathrm{s}^{-2}$, and $B$ is the dimensionless amplitude of a time-constant baroclinic jet. This system can be written as a single second-order ODE for $G(t)$:\n$$\n\\frac{d^2G}{dt^2} + \\omega^2 G = \\epsilon B^2\n$$\nThis is the standard equation for a forced harmonic oscillator with a constant forcing term $\\epsilon B^2$.\n\nThe general analytical solution to this equation is the sum of a homogeneous solution and a particular solution. The homogeneous equation, $\\frac{d^2G_h}{dt^2} + \\omega^2 G_h = 0$, describes free oscillations with frequency $\\omega$. The particular solution, which represents a steady state forced by the constant term, is found by setting the derivatives to zero: $\\omega^2 G_p = \\epsilon B^2$, yielding $G_p = \\frac{\\epsilon B^2}{\\omega^2}$. This particular solution, hereafter denoted $G_{\\text{balance}}$, represents the balanced state where the pressure gradient force (related to $G$) exactly balances the forcing from the nonlinear interaction of the jet.\n\nThe complete analytical solution for $G(t)$ is:\n$$\nG(t) = \\left( G(0) - G_{\\text{balance}} \\right) \\cos(\\omega t) + \\frac{V(0)}{\\omega} \\sin(\\omega t) + G_{\\text{balance}}\n$$\nwhere $G(0)$ and $V(0)$ are the initial conditions. This solution consists of a steady component, $G_{\\text{balance}}$, and an oscillating component with an amplitude given by $A_{\\text{analytic}} = \\sqrt{\\left(G(0) - G_{\\text{balance}}\\right)^2 + \\left(\\frac{V(0)}{\\omega}\\right)^2}$. The three initialization schemes can be understood in terms of this solution:\n1.  **Raw analysis**: The initial state is $(G(0), V(0)) = (G_{\\mathrm{raw}}, V_{\\mathrm{raw}})$. Any deviation of this state from the balanced state $(G_{\\text{balance}}, 0)$ will generate gravity-wave oscillations. The amplitude is $A_{\\text{raw}} = \\sqrt{\\left(G_{\\mathrm{raw}} - G_{\\text{balance}}\\right)^2 + \\left(\\frac{V_{\\mathrm{raw}}}{\\omega}\\right)^2}$. These oscillations are often spurious noise in a forecast.\n2.  **Linear Normal Mode Initialization (NMI)**: The initial state is set to $(G(0), V(0)) = (0, 0)$. This removes any linear fast-mode components, which corresponds to zeroing out the fast-mode variables. However, the nonlinear forcing term $\\epsilon B^2$ is still present. This forces the system away from the $(0, 0)$ state, spontaneously generating gravity waves. The resulting oscillation amplitude is $A_{\\text{linNMI}} = \\sqrt{\\left(0 - G_{\\text{balance}}\\right)^2 + 0^2} = |G_{\\text{balance}}| = \\frac{\\epsilon B^2}{\\omega^2}$. This is a \"startup transient\" as the model adjusts to the forcing.\n3.  **Nonlinear Normal Mode Initialization (NMI)**: The initial state is set to $(G(0), V(0)) = (G_{\\text{balance}}, 0) = (\\frac{\\epsilon B^2}{\\omega^2}, 0)$. This places the system directly into the balanced steady state. According to the analytical solution, the oscillating component has zero amplitude: $A_{\\text{nonlinNMI}} = \\sqrt{\\left(G_{\\text{balance}} - G_{\\text{balance}}\\right)^2 + 0^2} = 0$. This scheme is designed to eliminate the startup transients by initializing the fast modes to be in balance with the forcing terms, leading to a smooth forecast evolution.\n\nTo obtain the numerical solution, we must integrate the system of ODEs over the time interval $t \\in [0, T]$, where $T = 43200 \\ \\mathrm{s}$. The problem specifies using a stable explicit scheme, for which the classical fourth-order Runge-Kutta (RK4) method is an excellent choice. For a system $\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y})$ and a time step $\\Delta t$, the RK4 update from $\\vec{y}_n$ at time $t_n$ to $\\vec{y}_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is:\n$$\n\\vec{y}_{n+1} = \\vec{y}_n + \\frac{\\Delta t}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\nwhere\n$$\n\\begin{aligned}\n\\vec{k}_1 &= \\vec{f}(t_n, \\vec{y}_n) \\\\\n\\vec{k}_2 &= \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_1) \\\\\n\\vec{k}_3 &= \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_2) \\\\\n\\vec{k}_4 &= \\vec{f}(t_n + \\Delta t, \\vec{y}_n + \\Delta t \\vec{k}_3)\n\\end{aligned}\n$$\nIn our case, the state vector is $\\vec{y} = [G, V]^T$ and the function $\\vec{f}$ is $\\vec{f}(\\vec{y}) = [V, -\\omega^2 G + \\epsilon B^2]^T$, which is independent of time $t$. This procedure is applied iteratively for $n = 0, 1, \\dots, N-2$ to generate the time series $G(t_n)$, where $N = \\lfloor T/\\Delta t \\rfloor + 1$.\n\nFinally, to quantify the gravity-wave amplitude, we compute the half peak-to-peak amplitude of the detrended time series for $G$. The metric $A$ is defined as:\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n < N} \\left( G(t_n) - \\overline{G} \\right) - \\min_{0 \\le n < N} \\left( G(t_n) - \\overline{G} \\right) \\right]\n$$\nwhere $\\overline{G}$ is the time-mean of the series $G(t_n)$. Since subtracting a constant $\\overline{G}$ from all elements of a series does not change the difference between its maximum and minimum, this expression simplifies to:\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n < N} G(t_n) - \\min_{0 \\le n < N} G(t_n) \\right]\n$$\nThis value will be calculated for each of the three initialization schemes across all provided test cases. The numerical results are expected to closely match the predictions from the analytical solution. Specifically, nonlinear NMI should yield a near-zero amplitude, demonstrating its effectiveness in suppressing spurious oscillations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing three initialization schemes for a simplified\n    numerical weather forecast model.\n    \"\"\"\n\n    def rk4_step(f, t, y, dt):\n        \"\"\"\n        Performs a single step of the classical fourth-order Runge-Kutta method.\n\n        Args:\n            f: The function defining the ODE system, dy/dt = f(t, y).\n            t: The current time.\n            y: The current state vector.\n            dt: The time step.\n            \n        Returns:\n            The state vector at time t + dt.\n        \"\"\"\n        k1 = dt * f(t, y)\n        k2 = dt * f(t + 0.5 * dt, y + 0.5 * k1)\n        k3 = dt * f(t + 0.5 * dt, y + 0.5 * k2)\n        k4 = dt * f(t + dt, y + k3)\n        return y + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n\n    def run_simulation(params, initial_conditions):\n        \"\"\"\n        Runs a single simulation for a given set of parameters and initial conditions.\n\n        Args:\n            params: A tuple of parameters (omega, epsilon, B, G_raw, V_raw, dt).\n            initial_conditions: A tuple (G0, V0) for the start of the simulation.\n\n        Returns:\n            The calculated half peak-to-peak amplitude 'A'.\n        \"\"\"\n        omega, epsilon, B, _, _, dt = params\n        G0, V0 = initial_conditions\n        \n        T = 43200.0  # Total integration time of 12 hours in seconds.\n\n        def f(t, y):\n            \"\"\"The ODE system dy/dt = f(t, y).\"\"\"\n            G, V = y\n            dG_dt = V\n            dV_dt = -omega**2 * G + epsilon * B**2\n            return np.array([dG_dt, dV_dt])\n\n        num_steps = int(np.floor(T / dt)) + 1\n        G_series = np.zeros(num_steps)\n        \n        y = np.array([G0, V0])\n        G_series[0] = y[0]\n        \n        t = 0.0\n        for i in range(num_steps - 1):\n            y = rk4_step(f, t, y, dt)\n            t += dt\n            G_series[i+1] = y[0]\n            \n        # Calculate the half peak-to-peak amplitude of the time series\n        # A = 0.5 * (max(G) - min(G)), which is equivalent to the detrended definition.\n        A = 0.5 * (np.max(G_series) - np.min(G_series))\n        return A\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Typical midlatitude baroclinic jet\n        (1.5e-3, 2.0e-7, 1.0, 0.5, 0.0, 60.0),\n        # 2. Boundary case with no forcing\n        (1.0e-3, 0.0, 0.8, 0.0, 0.0, 60.0),\n        # 3. Stronger coupling and larger jet\n        (2.0e-3, 1.0e-6, 2.0, 0.1, 1.0e-4, 30.0)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, epsilon, B, G_raw, V_raw, _ = case\n\n        # 1. Raw analysis initialization\n        ic_raw = (G_raw, V_raw)\n        A_raw = run_simulation(case, ic_raw)\n        \n        # 2. Linear Normal Mode Initialization (NMI)\n        ic_lin_nmi = (0.0, 0.0)\n        A_lin_nmi = run_simulation(case, ic_lin_nmi)\n        \n        # 3. Nonlinear Normal Mode Initialization (NMI)\n        # Avoid division by zero if omega is 0.\n        if omega == 0.0:\n            G0_nonlin_nmi = 0.0\n        else:\n            G0_nonlin_nmi = epsilon * B**2 / omega**2\n        ic_nonlin_nmi = (G0_nonlin_nmi, 0.0)\n        A_nonlin_nmi = run_simulation(case, ic_nonlin_nmi)\n        \n        all_results.extend([A_raw, A_lin_nmi, A_nonlin_nmi])\n\n    # Final print statement in the exact required format.\n    # We use a high precision format to avoid ambiguity in floating point representation.\n    print(f\"[{','.join(f'{r:.10f}' for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}