{
    "hands_on_practices": [
        {
            "introduction": "在我们初始化或过滤正规模态之前，我们必须首先理解它们是什么，以及它们在数值模型中是如何表示的。第一个练习将回到基础，关注大气波动的基本垂直结构。你将对垂直模态的控制方程进行离散化，并将你的数值解与精确的解析解进行比较，从而能够直接量化模型表示的准确性。",
            "id": "4031276",
            "problem": "考虑在数值天气预报（NWP）和气候模型中，静力平衡和 Boussinesq 近似下的小振幅线性内重力波的垂直结构。在最简单的情况下，即层结恒定且在表面和模式顶部分别有刚盖边界，其垂直结构可简化为一维 Sturm–Liouville 边值问题。该框架是正规模态初始化（NMI）的基础，NMI 将初始条件分解为具有物理意义的模态；该框架也是设计选择性衰减快模态的数字滤波器的基础。\n\n从与刚盖边界条件相关的一维垂直二阶常微分算子出发，在区间 $[0,H]$ 上构建连续特征值问题，其中 $H$ 是模式顶高。然后，在 $K$ 个内部层上使用均匀网格、中心二阶有限差分格式，并在 $z=0$ 和 $z=H$ 处使用齐次 Dirichlet 边界条件，构建其离散对应形式。您的任务是：\n\n1. 推导垂直模态的连续边值问题，形式为在 $[0,H]$ 上关于函数 $y(z)$ 的特征值问题，并给出适当的边界条件。解释边界条件是如何从刚盖假设和垂直速度的连续性中产生的。\n2. 在 $K$ 个内部层上，使用中心有限差分公式对二阶导数进行离散化，网格间距为 $\\Delta z = H/(K+1)$，并在端点处使用齐次 Dirichlet 边界条件。构建由此产生的 $K \\times K$ 三对角矩阵，并写出它所定义的离散特征值问题。\n3. 对每个离散特征对，数值求解其特征值和特征向量。通过按特征值升序排列，将第 $m$ 个离散特征对与第 $m$ 个连续模态关联起来。\n4. 通过比较以下内容来量化离散误差：\n   - 特征值：计算相对误差 $\\epsilon_{\\lambda}(m) = \\left(\\lambda_{d}(m) - \\lambda_{c}(m)\\right)/\\lambda_{c}(m)$，其中 $\\lambda_{c}(m)$ 是第 $m$ 个模态的连续特征值，$\\lambda_{d}(m)$ 是对应的离散特征值。\n   - 特征向量：计算离散特征向量 $v_{d}^{(m)}$ 与在内部网格点上采样的连续特征函数 $y_{c}^{(m)}(z)$ 之间的归一化均方根不匹配度 $\\epsilon_{v}(m)$。为比较形状，首先将两个向量缩放至单位 $\\ell^{2}$ 范数，并选择其中一个的符号以最小化它们差的范数。\n\n科学基础：\n- 使用适用于刚盖边界和常系数的标准一维垂直算子，以及经过充分检验的中心有限差分来计算二阶导数。\n- 假设 $H$ 是有限正数，并使用齐次 Dirichlet 边界条件 $y(0) = 0$ 和 $y(H) = 0$ 来表示抑制端点处垂直位移的刚性边界。\n\n单位和输出：\n- 将 $H$ 的单位视为米，如果需要，以 $\\mathrm{m}^{-2}$ 为单位报告特征值。所需的输出是无量纲误差 $\\epsilon_{\\lambda}(m)$ 和 $\\epsilon_{v}(m)$；以小数形式报告（不带百分号）。\n- 不使用角度。\n\n测试套件：\n对以下每个测试用例，计算所要求模态的误差集。所有用例均使用 $H = 10000$ 米。\n- 用例 1: $K=8$，模态 $m \\in \\{1,2,4,8\\}$。\n- 用例 2: $K=33$，模态 $m \\in \\{1,3,8,16\\}$。\n- 用例 3: $K=65$，模态 $m \\in \\{1,5,15,30\\}$。\n- 用例 4 (特殊情况): $K=3$，模态 $m \\in \\{1,2\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，输出一个嵌套列表，其中包含两个子列表：第一个子列表按指定模态的顺序列出相对特征值误差 $\\epsilon_{\\lambda}(m)$，第二个子列表按相同顺序列出特征向量不匹配误差 $\\epsilon_{v}(m)$。总体输出必须是这些按用例排列的列表的列表，顺序与上述测试套件相同。例如，其形状应为\n[[[e11,e12,...],[v11,v12,...]],[[e21,e22,...],[v21,v22,...]],[[e31,...],[v31,...]],[[e41,...],[v41,...]]]\n其中 $eij$ 和 $vij$ 是浮点数。",
            "solution": "该问题要求对描述简化大气模型中内重力波垂直结构的一维 Sturm–Liouville 问题进行公式化和数值分析。分析过程涉及将连续问题的精确解析解与其有限差分离散化的数值解进行比较。\n\n### 1. 连续边值问题\n\n在指定的近似（静力平衡、Boussinesq、恒定层结）下，线性内重力波的垂直结构由一个关于垂直结构函数（我们记为 $y(z)$）的二阶常微分方程控制。该函数与高度 $z$ 处的垂直速度振幅成正比。与此结构相关的算子是二阶导数 $\\frac{d^2}{dz^2}$。寻找正规模态会导出一个特征值问题：\n$$\n\\frac{d^2 y(z)}{dz^2} = \\lambda y(z)\n$$\n其中 $\\lambda$ 是特征值，它与垂直波数的平方有关（$k_z^2 = -\\lambda$）。定义域为区间 $[0, H]$，其中 $z=0$ 是地表，$z=H$ 是模式顶。\n\n“刚盖”边界条件表示在边界处没有垂直运动。这意味着垂直速度，以及因此的结构函数 $y(z)$，在这些点上必须为零。这产生了齐次 Dirichlet 边界条件：\n$$\ny(0) = 0 \\quad \\text{and} \\quad y(H) = 0\n$$\n问题在于求解满足这些边界条件的微分方程。$y'' - \\lambda y = 0$ 的通解取决于 $\\lambda$ 的符号。对于振荡（类波）解，我们期望 $\\lambda  0$。设 $\\lambda = -k^2$，其中 $k$ 是某个实数且 $k>0$。方程变为 $y'' + k^2 y = 0$。\n通解为：\n$$\ny(z) = A \\sin(kz) + B \\cos(kz)\n$$\n应用第一个边界条件 $y(0) = 0$：\n$$\ny(0) = A \\sin(0) + B \\cos(0) = B = 0\n$$\n这将解简化为 $y(z) = A \\sin(kz)$。应用第二个边界条件 $y(H) = 0$：\n$$\ny(H) = A \\sin(kH) = 0\n$$\n为了得到非平凡解（$A \\neq 0$），我们必须有 $\\sin(kH) = 0$。当 $kH$ 是 $\\pi$ 的整数倍时，此条件成立。\n$$\nkH = m\\pi, \\quad \\text{for } m = 1, 2, 3, \\dots\n$$\n$m=0$ 的情况被排除，因为它会导致平凡解 $y(z)=0$。整数 $m$ 是模态数，表示垂直域中的半波长数量。\n由此，我们得到 $k$（垂直波数）的离散允许值集合：$k_m = \\frac{m\\pi}{H}$。\n相应的连续特征值 $\\lambda_c(m)$ 是：\n$$\n\\lambda_c(m) = -k_m^2 = -\\left(\\frac{m\\pi}{H}\\right)^2\n$$\n每个模态 $m$ 的特征函数 $y_c^{(m)}(z)$ 是：\n$$\ny_c^{(m)}(z) = \\sin\\left(\\frac{m\\pi z}{H}\\right)\n$$\n其中省略了归一化常数，因为稍后会处理。\n\n### 2. 离散化与离散特征值问题\n\n我们使用一个包含 $K$ 个内部点和 2 个边界点的均匀网格来离散化域 $[0, H]$。总区间数为 $K+1$。网格间距为 $\\Delta z = \\frac{H}{K+1}$。网格点为 $z_j = j \\Delta z$，其中 $j=0, 1, \\dots, K+1$。内部点为 $z_1, \\dots, z_K$。令 $y_j = y(z_j)$。\n\n在内部点 $z_j$ 处的二阶导数 $\\frac{d^2y}{dz^2}$ 使用中心二阶有限差分公式近似：\n$$\n\\frac{d^2 y}{dz^2}\\bigg|_{z_j} \\approx \\frac{y(z_{j+1}) - 2y(z_j) + y(z_{j-1})}{(\\Delta z)^2} = \\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2}\n$$\n离散特征值问题则为：\n$$\n\\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2} = \\lambda_d y_j \\quad \\text{for } j = 1, \\dots, K\n$$\n边界条件 $y(0)=0$ 和 $y(H)=0$ 变为 $y_0=0$ 和 $y_{K+1}=0$。\n这个由 $K$ 个线性方程组成的系统可以写成矩阵形式 $A\\mathbf{v} = \\lambda_d \\mathbf{v}$，其中 $\\mathbf{v} = [y_1, y_2, \\dots, y_K]^T$ 是内部网格点上解的向量。$K \\times K$ 矩阵 $A$ 的构建如下：\n对于 $j=1$: $\\frac{y_2 - 2y_1 + y_0}{(\\Delta z)^2} = \\frac{y_2 - 2y_1}{(\\Delta z)^2} = \\lambda_d y_1$\n对于 $j=K$: $\\frac{y_{K+1} - 2y_K + y_{K-1}}{(\\Delta z)^2} = \\frac{-2y_K + y_{K-1}}{(\\Delta z)^2} = \\lambda_d y_K$\n对于任何其他 $j$: $\\frac{y_{j+1} - 2y_j + y_{j-1}}{(\\Delta z)^2} = \\lambda_d y_j$\n\n这导致了对称三对角矩阵 $A$：\n$$\nA = \\frac{1}{(\\Delta z)^2}\n\\begin{pmatrix}\n-2   1   0   \\cdots  0 \\\\\n1   -2  1   \\ddots  \\vdots \\\\\n0   \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  1  -2  1 \\\\\n0   \\cdots  0  1  -2\n\\end{pmatrix}_{K \\times K}\n$$\n\n### 3. 数值特征对与模态关联\n\n离散特征值 $\\lambda_d(m)$ 和特征向量 $v_d^{(m)}$ 是通过数值求解矩阵 $A$ 的特征系统得到的。由于 $A$ 是一个实对称矩阵，其特征值是实数，并且它拥有一套完备的正交特征向量。数值库通常返回按升序排列的特征值。\n\n这个特定矩阵 $A$ 的解析特征值已知为 $\\lambda_d(m') = -\\frac{4}{(\\Delta z)^2}\\sin^2\\left(\\frac{m'\\pi}{2(K+1)}\\right)$，其中 $m' = 1, \\dots, K$。\n连续特征值是 $\\lambda_c(m) = -(m\\pi/H)^2$。\n物理模态数 $m$ 对应于半波长的数量。随着 $m$ 的增加，（负）特征值的绝对值增加，因此其值减小。\n$\\lambda_c(1)  \\lambda_c(2)  \\dots$\n类似地，离散特征值 $\\lambda_d(m')$ 随着 $m'$ 从 1 增加到 $K$ 而减小。\n数值特征求解器将按升序对特征值进行排序：$\\lambda_{(1)} \\le \\lambda_{(2)} \\le \\dots \\le \\lambda_{(K)}$。\n因此，最小的特征值 $\\lambda_{(1)}$ 对应于模态 $m'=K$，最大的特征值 $\\lambda_{(K)}$ 对应于模态 $m'=1$。\n问题将第 $m$ 个离散特征对与第 $m$ 个连续模态相关联。对于给定的模态数 $m$（来自问题陈述，例如 $m=1, 2, 4$），对应的离散特征值是 $\\lambda_d(m)$，离散特征向量是 $v_d^{(m)}$。从排序后的数值结果来看，这对将是第 $(K-m+1)$ 个元素。如果求解器返回的索引是 $0, \\dots, K-1$，那么模态 $m$ 的特征对将位于索引 $K-m$ 处。\n\n### 4. 离散误差量化\n\n通过比较离散和连续的特征对来量化有限差分离散化引入的误差。\n\n**特征值误差：** 第 $m$ 个模态特征值的相对误差是：\n$$\n\\epsilon_{\\lambda}(m) = \\frac{\\lambda_d(m) - \\lambda_c(m)}{\\lambda_c(m)}\n$$\n其中 $\\lambda_c(m)$ 是解析连续特征值，$\\lambda_d(m)$ 是对应的数值计算出的离散特征值。\n\n**特征向量不匹配度：** 特征向量的误差计算为归一化均方根不匹配度。\n1. 离散特征向量 $v_d^{(m)}$ 是一个长度为 $K$ 的向量。\n2. 连续特征函数 $y_c^{(m)}(z) = \\sin(m\\pi z/H)$ 在 $K$ 个内部网格点 $z_j = j\\Delta z$ (其中 $j=1, \\dots, K$) 上进行采样，形成一个向量 $y_c^{(m, \\text{sampled})}$。其分量为 $\\sin(m\\pi j / (K+1))$。\n3. 两个向量都被缩放以具有单位 $\\ell^2$ 范数：$\\hat{v}_d^{(m)} = v_d^{(m)} / \\|v_d^{(m)}\\|_2$ 和 $\\hat{y}_c^{(m)} = y_c^{(m, \\text{sampled})} / \\|y_c^{(m, \\text{sampled})}\\|_2$。\n4. 特征向量的定义只到符号为止。为确保对形状进行有意义的比较，需调整数值特征向量的符号以匹配解析特征向量。如果 $\\hat{v}_d^{(m)} \\cdot \\hat{y}_c^{(m)}  0$，则翻转 $\\hat{v}_d^{(m)}$ 的符号。设这个修正后的向量为 $\\hat{v}_d'^{(m)}$。\n5. 特征向量不匹配度是归一化、符号校正后的向量之差的 $\\ell^2$ 范数：\n$$\n\\epsilon_{v}(m) = \\| \\hat{v}_d'^{(m)} - \\hat{y}_c^{(m)} \\|_2\n$$\n对于这个具体问题，解析的离散特征向量与采样的连续特征函数是精确成比例的。因此，$\\epsilon_{v}(m)$ 的非零值预期仅由数值特征求解器中的浮点不精确性引起，应接近于机器精度。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying discretization error for a 1D Sturm-Liouville\n    problem related to vertical modes in atmospheric models.\n    \"\"\"\n    \n    H = 10000.0  # Model top height in meters\n    \n    test_cases = [\n        {'K': 8, 'modes': [1, 2, 4, 8]},\n        {'K': 33, 'modes': [1, 3, 8, 16]},\n        {'K': 65, 'modes': [1, 5, 15, 30]},\n        {'K': 3, 'modes': [1, 2]},\n    ]\n    \n    overall_results = []\n    \n    for case in test_cases:\n        K = case['K']\n        modes_to_test = case['modes']\n        \n        delta_z = H / (K + 1)\n        \n        # 1. Assemble the K x K tridiagonal matrix A for the discrete operator\n        main_diag = -2.0 * np.ones(K)\n        off_diag = np.ones(K - 1)\n        \n        # The matrix for the second derivative is T/dz^2\n        # where T is the tridiagonal matrix with (-2, 1, 1).\n        A = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (delta_z**2)\n        \n        # 2. Solve the discrete eigenvalue problem numerically\n        # linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        discrete_eigenvalues, discrete_eigenvectors = linalg.eigh(A)\n        \n        case_lambda_errors = []\n        case_vec_errors = []\n        \n        # Grid points for sampling the continuous solution\n        z_grid = np.arange(1, K + 1) * delta_z\n        \n        for m in modes_to_test:\n            # Check if mode m can be resolved by the grid\n            if m > K:\n                continue\n\n            # 3. Calculate continuous eigenvalues and eigenfunctions\n            lambda_c = -((m * np.pi) / H)**2\n            \n            # The continuous eigenfunction sampled at interior grid points\n            # y_c(z_j) = sin(m*pi*z_j / H) = sin(m*pi*j*dz / H) = sin(m*pi*j / (K+1))\n            vec_c_sampled = np.sin(m * np.pi * np.arange(1, K + 1) / (K + 1))\n\n            # 4. Associate discrete results with the m-th mode\n            # Eigenvalues from eigh are sorted ascendingly.\n            # The physical mode 'm' corresponds to the (K-m+1)-th eigenvalue in\n            # a list sorted by physical meaning (decreasing value).\n            # In an ascending sort (from most negative to least), mode 'm'\n            # corresponds to index K-m.\n            eigval_index = K - m\n            lambda_d = discrete_eigenvalues[eigval_index]\n            vec_d = discrete_eigenvectors[:, eigval_index]\n            \n            # 5. Quantify errors\n            # Relative eigenvalue error\n            epsilon_lambda = (lambda_d - lambda_c) / lambda_c\n            case_lambda_errors.append(epsilon_lambda)\n            \n            # Eigenvector mismatch\n            # Normalize both vectors to unit l2 norm\n            norm_vec_d = np.linalg.norm(vec_d)\n            norm_vec_c = np.linalg.norm(vec_c_sampled)\n            \n            # Avoid division by zero if a vector is all zeros (highly unlikely)\n            if norm_vec_d == 0.0 or norm_vec_c == 0.0:\n                epsilon_v = np.nan\n            else:\n                v_d_norm = vec_d / norm_vec_d\n                v_c_norm = vec_c_sampled / norm_vec_c\n            \n                # Adjust sign of numerical eigenvector for consistent comparison\n                if np.dot(v_d_norm, v_c_norm)  0:\n                    v_d_norm *= -1.0\n                \n                # Compute normalized RMS mismatch as the L2 norm of the difference\n                epsilon_v = np.linalg.norm(v_d_norm - v_c_norm)\n                case_vec_errors.append(epsilon_v)\n\n        overall_results.append([case_lambda_errors, case_vec_errors])\n\n    # Format the final output exactly as specified\n    # Using a custom function to format the list of lists\n    def format_nested_list(data):\n        outer_parts = []\n        for sublist1 in data:\n            inner_parts = []\n            for sublist2 in sublist1:\n                inner_parts.append(f\"[{','.join(f'{x:.10f}' for x in sublist2)}]\")\n            outer_parts.append(f\"[{','.join(inner_parts)}]\")\n        return f\"[{','.join(outer_parts)}]\"\n\n    print(format_nested_list(overall_results))\n\nsolve()\n```"
        },
        {
            "introduction": "来自分析的原始初始数据通常包含不平衡，这会在预报中导致虚假的高频振荡。本练习通过比较不同初始状态下的预报，展示了初始化的重要性。你将模拟斜压急流产生重力波的过程，并观察线性和非线性正规模态初始化(NMI)方案如何抑制这些不必要的波动，从而实现更平滑、更准确的预报启动。",
            "id": "4031279",
            "problem": "考虑一个简化的预报模型，该模型分离了由分析的斜压急流中的不平衡所产生的快速重力波振荡。其物理基础是 $f$ 平面上的旋转浅水方程，该方程允许一个平衡的地转（慢）模和一个惯性重力（快）模。在一个波数为 $k$ 的一维谱截断中，众所周知，旋转浅水方程的线性正规模由一个频率为 $0$ 的慢平衡模和两个频率为 $\\pm \\omega$ 的快重力波模组成。平衡模与快模之间的弱非线性相互作用可以建模为平衡场对快模的二次强迫。\n\n为了本练习的目的，并将计算精力集中在快模分量上，假设平衡的斜压急流振幅 $B$ 在前 $12$ 小时内是时间常数，并通过一个二次非线性项作为快模的源。将快模的位移振幅表示为 $G(t)$，其时间导数（快模的速度振幅）表示为 $V(t) = dG/dt$。重力波动力学由受迫谐振子建模\n$$\n\\frac{dG}{dt} = V, \\qquad\n\\frac{dV}{dt} = -\\omega^2 G + \\epsilon B^2,\n$$\n其中 $\\omega$ 是非负的重力波角频率，单位为 $\\mathrm{s}^{-1}$；$\\epsilon$ 是一个小的非负系数，单位为 $\\mathrm{s}^{-2}$，它概括了弱非线性二次耦合的有效强度；$B$ 是一个无量纲的振幅参数，代表斜压急流的强度。$G$ 和 $V$ 都是无量纲变量。时间 $t$ 以秒为单位。\n\n您必须比较前 $12$ 小时（$T = 43200 \\ \\mathrm{s}$）内的三种预报演变，每种演变都从一个独特的初始化状态开始：\n- 原始分析 (Raw analysis)：初始条件 $G(0) = G_{\\mathrm{raw}}$ 和 $V(0) = V_{\\mathrm{raw}}$ 已给定，可能由于不平衡而包含虚假的快模分量。\n- 线性正规模初始化 (Linear Normal Mode Initialization, NMI)：设置 $G(0) = 0$ 和 $V(0) = 0$，这通过投影到线性化算子的慢平衡子空间上来移除线性的快模分量。\n- 非线性正规模初始化 (Nonlinear Normal Mode Initialization, NMI)：设置 $G(0) = \\epsilon B^2 / \\omega^2$ 和 $V(0) = 0$，这将快模置于与主导阶的二次平衡相一致的非线性慢流形上，从而最小化启动瞬变。\n\n对于每种初始化，使用固定的时间步长 $\\Delta t$（以秒为单位）在 $t \\in [0,T]$ 上对该系统进行数值积分。通过对时间序列进行去趋势处理以移除任何恒定偏移，并报告峰峰值振幅的一半来量化重力波振荡的振幅：\n$$\n\\overline{G} = \\frac{1}{N} \\sum_{n=0}^{N-1} G(t_n), \\quad \\text{with} \\quad t_n = n \\Delta t, \\quad N = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor + 1,\n$$\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) - \\min_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) \\right],\n$$\n表示为一个无量纲的浮点数。这个 $A$ 衡量了前 $12$ 小时内高频重力波振荡的振幅。\n\n单位和数值要求：\n- 时间使用秒（$\\mathrm{s}$），频率使用秒的倒数（$\\mathrm{s}^{-1}$），非线性耦合系数使用秒的倒数的平方（$\\mathrm{s}^{-2}$）。所有振幅（$G$、$V$、$B$、$A$）均为无量纲。\n- 对于角频率 $\\omega$（单位为 $\\mathrm{s}^{-1}$），隐式使用弧度。\n- 使用给定的 $\\Delta t$ 实现一个数值稳定的显式格式（例如，经典的四阶龙格－库塔法）。\n- 将所有振幅报告为浮点数。\n\n测试套件：\n对于下面的每个参数元组 $(\\omega, \\epsilon, B, G_{\\mathrm{raw}}, V_{\\mathrm{raw}}, \\Delta t)$，执行三次运行（原始分析、线性NMI、非线性NMI）并为每次运行计算 $A$。参数集如下：\n1. 典型的中纬度斜压急流和适度的二次耦合（理想情况）：\n   - $\\omega = 1.5 \\times 10^{-3} \\ \\mathrm{s}^{-1}$，\n   - $\\epsilon = 2.0 \\times 10^{-7} \\ \\mathrm{s}^{-2}$，\n   - $B = 1.0$，\n   - $G_{\\mathrm{raw}} = 0.5$，\n   - $V_{\\mathrm{raw}} = 0.0$，\n   - $\\Delta t = 60 \\ \\mathrm{s}$。\n2. 无虚假快模分量且二次耦合为零的边界情况：\n   - $\\omega = 1.0 \\times 10^{-3} \\ \\mathrm{s}^{-1}$，\n   - $\\epsilon = 0.0 \\ \\mathrm{s}^{-2}$，\n   - $B = 0.8$，\n   - $G_{\\mathrm{raw}} = 0.0$，\n   - $V_{\\mathrm{raw}} = 0.0$，\n   - $\\Delta t = 60 \\ \\mathrm{s}$。\n3. 具有较小的非零初始快模速度的更强二次耦合和更大的急流：\n   - $\\omega = 2.0 \\times 10^{-3} \\ \\mathrm{s}^{-1}$，\n   - $\\epsilon = 1.0 \\times 10^{-6} \\ \\mathrm{s}^{-2}$，\n   - $B = 2.0$，\n   - $G_{\\mathrm{raw}} = 0.1$，\n   - $V_{\\mathrm{raw}} = 1.0 \\times 10^{-4}$，\n   - $\\Delta t = 30 \\ \\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，该列表必须按顺序包含三个振幅 $(A_{\\mathrm{raw}}, A_{\\mathrm{linNMI}}, A_{\\mathrm{nonlinNMI}})$，并将它们平展成一个列表。例如，输出格式为 $[A_{1,\\mathrm{raw}},A_{1,\\mathrm{lin}},A_{1,\\mathrm{nonlin}},A_{2,\\mathrm{raw}},A_{2,\\mathrm{lin}},A_{2,\\mathrm{nonlin}},A_{3,\\mathrm{raw}},A_{3,\\mathrm{lin}},A_{3,\\mathrm{nonlin}}]$，表示为无量纲浮点数。",
            "solution": "该问题要求对一个简化的数值天气预报模型的三种不同初始化方案进行比较分析。该模型的动力学由一个受迫谐振子控制，该谐振子代表了从平衡的斜压急流中产生的快速惯性重力波。任务的核心是数值积分常微分方程组（ODEs），量化每种初始化产生的重力波振荡，并报告给定测试用例集的结果。\n\n快模位移振幅 $G(t)$ 和速度振幅 $V(t)$ 的控制方程以两个一阶常微分方程组的形式给出：\n$$\n\\frac{dG}{dt} = V\n$$\n$$\n\\frac{dV}{dt} = -\\omega^2 G + \\epsilon B^2\n$$\n其中 $G$ 和 $V$ 是无量纲振幅， $t$ 是以秒为单位的时间， $\\omega$ 是以 $\\mathrm{s}^{-1}$ 为单位的重力波角频率， $\\epsilon$ 是以 $\\mathrm{s}^{-2}$ 为单位的非线性耦合系数， $B$ 是一个时间常数斜压急流的无量纲振幅。该系统可以写成关于 $G(t)$ 的单个二阶常微分方程：\n$$\n\\frac{d^2G}{dt^2} + \\omega^2 G = \\epsilon B^2\n$$\n这是一个具有恒定强迫项 $\\epsilon B^2$ 的受迫谐振子的标准方程。\n\n该方程的通解是齐次解与特解之和。齐次方程 $\\frac{d^2G_h}{dt^2} + \\omega^2 G_h = 0$ 描述了频率为 $\\omega$ 的自由振荡。表示由常数项强迫的稳态的特解，可以通过将导数设置为零来找到：$\\omega^2 G_p = \\epsilon B^2$，得到 $G_p = \\frac{\\epsilon B^2}{\\omega^2}$。这个特解，下文表示为 $G_{\\text{balance}}$，代表了压力梯度力（与 $G$ 相关）与来自急流非线性相互作用的强迫完全平衡的平衡态。\n\n$G(t)$ 的完整解析解为：\n$$\nG(t) = \\left( G(0) - G_{\\text{balance}} \\right) \\cos(\\omega t) + \\frac{V(0)}{\\omega} \\sin(\\omega t) + G_{\\text{balance}}\n$$\n其中 $G(0)$ 和 $V(0)$ 是初始条件。该解由一个稳态分量 $G_{\\text{balance}}$ 和一个振荡分量组成，振荡分量的振幅由 $A_{\\text{analytic}} = \\sqrt{\\left(G(0) - G_{\\text{balance}}\\right)^2 + \\left(\\frac{V(0)}{\\omega}\\right)^2}$ 给出。这三种初始化方案可以用这个解来理解：\n1.  **原始分析 (Raw analysis)**：初始状态为 $(G(0), V(0)) = (G_{\\mathrm{raw}}, V_{\\mathrm{raw}})$。该状态与平衡态 $(G_{\\text{balance}}, 0)$ 的任何偏差都将产生重力波振荡。振幅为 $A_{\\text{raw}} = \\sqrt{\\left(G_{\\mathrm{raw}} - G_{\\text{balance}}\\right)^2 + \\left(\\frac{V_{\\mathrm{raw}}}{\\omega}\\right)^2}$。这些振荡在预报中通常是虚假噪声。\n2.  **线性正规模初始化 (Linear Normal Mode Initialization, NMI)**：初始状态设置为 $(G(0), V(0)) = (0, 0)$。这移除了任何线性的快模分量，相当于将快模变量置零。然而，非线性强迫项 $\\epsilon B^2$ 仍然存在。这会迫使系统偏离 $(0, 0)$ 状态，自发地产生重力波。产生的振荡振幅为 $A_{\\text{linNMI}} = \\sqrt{\\left(0 - G_{\\text{balance}}\\right)^2 + 0^2} = |G_{\\text{balance}}| = \\frac{\\epsilon B^2}{\\omega^2}$。当模型调整以适应强迫时，这是一种“启动瞬变”。\n3.  **非线性正规模初始化 (Nonlinear Normal Mode Initialization, NMI)**：初始状态设置为 $(G(0), V(0)) = (G_{\\text{balance}}, 0) = (\\frac{\\epsilon B^2}{\\omega^2}, 0)$。这将系统直接置于平衡稳态。根据解析解，振荡分量的振幅为零：$A_{\\text{nonlinNMI}} = \\sqrt{\\left(G_{\\text{balance}} - G_{\\text{balance}}\\right)^2 + 0^2} = 0$。该方案旨在通过将快模初始化为与强迫项平衡的状态来消除启动瞬变，从而实现平滑的预报演变。\n\n为了获得数值解，我们必须在时间间隔 $t \\in [0, T]$ 上积分该常微分方程组，其中 $T = 43200 \\ \\mathrm{s}$。问题指定使用稳定的显式格式，经典的四阶龙格－库塔 (RK4) 方法是极佳选择。对于一个系统 $\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y})$ 和一个时间步长 $\\Delta t$，从时间 $t_n$ 的 $\\vec{y}_n$ 到时间 $t_{n+1} = t_n + \\Delta t$ 的 $\\vec{y}_{n+1}$ 的 RK4 更新为：\n$$\n\\vec{y}_{n+1} = \\vec{y}_n + \\frac{\\Delta t}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\n其中\n$$\n\\begin{aligned}\n\\vec{k}_1 = \\vec{f}(t_n, \\vec{y}_n) \\\\\n\\vec{k}_2 = \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_1) \\\\\n\\vec{k}_3 = \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2}\\vec{k}_2) \\\\\n\\vec{k}_4 = \\vec{f}(t_n + \\Delta t, \\vec{y}_n + \\Delta t \\vec{k}_3)\n\\end{aligned}\n$$\n在我们的例子中，状态向量是 $\\vec{y} = [G, V]^T$，函数 $\\vec{f}$ 是 $\\vec{f}(\\vec{y}) = [V, -\\omega^2 G + \\epsilon B^2]^T$，它与时间 $t$ 无关。对 $n = 0, 1, \\dots, N-2$ 迭代应用此过程，以生成时间序列 $G(t_n)$，其中 $N = \\lfloor T/\\Delta t \\rfloor + 1$。\n\n最后，为了量化重力波振幅，我们计算 $G$ 的去趋势时间序列的峰峰值振幅的一半。度量 $A$ 定义为：\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) - \\min_{0 \\le n  N} \\left( G(t_n) - \\overline{G} \\right) \\right]\n$$\n其中 $\\overline{G}$ 是序列 $G(t_n)$ 的时间平均值。由于从序列的所有元素中减去一个常数 $\\overline{G}$ 不会改变其最大值和最小值之间的差，因此该表达式简化为：\n$$\nA = \\frac{1}{2}\\left[ \\max_{0 \\le n  N} G(t_n) - \\min_{0 \\le n  N} G(t_n) \\right]\n$$\n将为所有提供的测试用例中的三种初始化方案分别计算此值。预期数值结果将与解析解的预测非常吻合。具体而言，非线性NMI应产生接近零的振幅，从而证明其在抑制虚假振荡方面的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing three initialization schemes for a simplified\n    numerical weather forecast model.\n    \"\"\"\n\n    def rk4_step(f, t, y, dt):\n        \"\"\"\n        Performs a single step of the classical fourth-order Runge-Kutta method.\n\n        Args:\n            f: The function defining the ODE system, dy/dt = f(t, y).\n            t: The current time.\n            y: The current state vector.\n            dt: The time step.\n            \n        Returns:\n            The state vector at time t + dt.\n        \"\"\"\n        k1 = dt * f(t, y)\n        k2 = dt * f(t + 0.5 * dt, y + 0.5 * k1)\n        k3 = dt * f(t + 0.5 * dt, y + 0.5 * k2)\n        k4 = dt * f(t + dt, y + k3)\n        return y + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n\n    def run_simulation(params, initial_conditions):\n        \"\"\"\n        Runs a single simulation for a given set of parameters and initial conditions.\n\n        Args:\n            params: A tuple of parameters (omega, epsilon, B, G_raw, V_raw, dt).\n            initial_conditions: A tuple (G0, V0) for the start of the simulation.\n\n        Returns:\n            The calculated half peak-to-peak amplitude 'A'.\n        \"\"\"\n        omega, epsilon, B, _, _, dt = params\n        G0, V0 = initial_conditions\n        \n        T = 43200.0  # Total integration time of 12 hours in seconds.\n\n        def f(t, y):\n            \"\"\"The ODE system dy/dt = f(t, y).\"\"\"\n            G, V = y\n            dG_dt = V\n            dV_dt = -omega**2 * G + epsilon * B**2\n            return np.array([dG_dt, dV_dt])\n\n        num_steps = int(np.floor(T / dt)) + 1\n        G_series = np.zeros(num_steps)\n        \n        y = np.array([G0, V0])\n        G_series[0] = y[0]\n        \n        t = 0.0\n        for i in range(num_steps - 1):\n            y = rk4_step(f, t, y, dt)\n            t += dt\n            G_series[i+1] = y[0]\n            \n        # Calculate the half peak-to-peak amplitude of the time series\n        # A = 0.5 * (max(G) - min(G)), which is equivalent to the detrended definition.\n        A = 0.5 * (np.max(G_series) - np.min(G_series))\n        return A\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Typical midlatitude baroclinic jet\n        (1.5e-3, 2.0e-7, 1.0, 0.5, 0.0, 60.0),\n        # 2. Boundary case with no forcing\n        (1.0e-3, 0.0, 0.8, 0.0, 0.0, 60.0),\n        # 3. Stronger coupling and larger jet\n        (2.0e-3, 1.0e-6, 2.0, 0.1, 1.0e-4, 30.0)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, epsilon, B, G_raw, V_raw, _ = case\n\n        # 1. Raw analysis initialization\n        ic_raw = (G_raw, V_raw)\n        A_raw = run_simulation(case, ic_raw)\n        \n        # 2. Linear Normal Mode Initialization (NMI)\n        ic_lin_nmi = (0.0, 0.0)\n        A_lin_nmi = run_simulation(case, ic_lin_nmi)\n        \n        # 3. Nonlinear Normal Mode Initialization (NMI)\n        # Avoid division by zero if omega is 0.\n        if omega == 0.0:\n            G0_nonlin_nmi = 0.0\n        else:\n            G0_nonlin_nmi = epsilon * B**2 / omega**2\n        ic_nonlin_nmi = (G0_nonlin_nmi, 0.0)\n        A_nonlin_nmi = run_simulation(case, ic_nonlin_nmi)\n        \n        all_results.extend([A_raw, A_lin_nmi, A_nonlin_nmi])\n\n    # Final print statement in the exact required format.\n    # We use a high precision format to avoid ambiguity in floating point representation.\n    print(f\"[{','.join(f'{r:.10f}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数字滤波初始化(DFI)提供了另一种去除高频噪声的方法，且无需显式计算模型的正规模态。本练习为你提供了在采用常见蛙跳格式时间步进方案的模型中实施DFI方案的实践经验。你将对一个短期预报应用数字滤波器，以衰减寄生的计算模态，并量化滤波器的有效性，从而深入了解DFI如何实现平衡的初始状态。",
            "id": "4031228",
            "problem": "考虑一个复傅里叶系数，它代表了数值天气预报模式中线性化动力核心的一个线性正规模。设复振幅表示为 $y(t)$，并假设它满足线性常微分方程 $dy/dt = i \\omega y$，其中 $\\omega$ 是一个以弧度/秒为单位的实角频率。时间离散化在均匀网格上使用蛙跳格式，时间步长为 $\\Delta t$ 秒，由三时间层递推关系 $y^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}$ 定义，其中在 $t_{n} = n \\Delta t$ 时，$y^{n} \\approx y(t_{n})$。蛙跳格式支持一个物理模和一个寄生计算模，后者的特征是随时间交替变号。数字滤波初始化（DFI）是一种时间对称的过程，通过将模式轨迹的一个短的、对称的窗口与固定权重进行卷积，来减小计算模的振幅。\n\n你需要为单个复标量 $y(t)$ 在这种蛙跳格式设置下实现数字滤波初始化（DFI），并量化初始化后紧接着的单个时间层上计算模振幅的减小程度。初始化通过一次前向欧拉启动来激发计算模，之后使用蛙跳格式。所需步骤如下，并且每一步都必须严格按照说明执行：\n\n- 模式和离散化。使用线性模式 $dy/dt = i \\omega y$ 和蛙跳格式 $y^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}$。\n- 激发计算模的启动过程。设置 $y^{0} = 1 + 0 i$。通过 $y^{1}_{\\mathrm{FE}} = y^{0} + \\Delta t \\, i \\omega \\, y^{0}$ 计算到 $t_{1}$ 的单步前向欧拉。通过在 $n=0$ 处反转蛙跳递推关系来定义 $y^{-1}$，使得蛙跳关系在 $(n=-1,0,1)$ 处成立，即 $y^{-1} = y^{1}_{\\mathrm{FE}} - 2 i \\omega \\Delta t \\, y^{0}$。使用这个 $y^{-1}$ 和 $y^{0}$ 结合蛙跳格式，生成一个离散时间序列 $\\{ y^{n} \\}$，其索引 $n$ 从 $-K$ 到 $+K$，其中 $K$ 是一个固定的正整数。\n- 时间对称数字滤波器。使用一个长度为奇数 $L$ 的有限脉冲响应、对称、时不变的数字滤波器，其权重为 $\\{ w_{k} \\}_{k=-M}^{M}$，其中 $M = (L-1)/2$，满足 $\\sum_{k=-M}^{M} w_{k} = 1$ 和 $\\sum_{k=-M}^{M} (-1)^{k} w_{k} = 0$。对于本任务，使用 $L-1$ 阶的归一化二项式权重，即对于 $k=-M,\\ldots,M$，有 $w_{k} = \\binom{L-1}{k+M} / 2^{L-1}$。例如，对于 $L=3$，权重为 $[1,2,1]/4$；对于 $L=5$，权重为 $[1,4,6,4,1]/16$。将时间索引 $n$ 处的滤波值定义为 $y^{n}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_{k} \\, y^{n+k}$，前提是所有索引 $n+k$ 都在可用的时间窗口内。\n- 计算模振幅度量。对于任意连续的两个时间层，将索引 $n$ 处的交替（计算）分量定义为 $a^{n} = \\tfrac{1}{2} \\left( y^{n} - y^{n-1} \\right)$。将初始化时刻的未滤波计算振幅定义为 $A_{\\mathrm{before}} = \\lvert a^{0} \\rvert = \\left\\lvert \\tfrac{1}{2} \\left( y^{0} - y^{-1} \\right) \\right\\rvert$。通过使用索引 $n=0$ 和 $n=-1$ 处的滤波值来定义滤波后的计算振幅，即 $A_{\\mathrm{after}} = \\left\\lvert \\tfrac{1}{2} \\left( y^{0}_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}} \\right) \\right\\rvert$。所需的度量是削减因子 $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$，这是一个无量纲量。\n- 单位和数值约束。$\\omega$ 的单位为弧度/秒，$\\Delta t$ 的单位为秒。积分索引的半跨度必须为 $K = 32$，因此时间窗口跨越索引 $n=-32,-31,\\ldots,+31,+32$。通过使用其 $\\omega \\Delta t$ 不违反线性振荡模型的蛙跳格式稳定性的测试用例，确保蛙跳积分在数值上是中性的（不会发散）。\n\n你的任务是编写一个完整的程序，该程序：\n- 使用指定的初始化方法为每个测试用例构建时间序列 $\\{ y^{n} \\}$。\n- 使用指定的权重，在以 $n=0$ 和 $n=-1$ 为中心的位置应用时间对称数字滤波器。\n- 为每个测试用例计算削减因子 $R$。\n\n测试套件：\n- 情况 1：周期 $P = 600$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 30$ 秒，滤波器长度 $L = 3$。\n- 情况 2：周期 $P = 240$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 30$ 秒，滤波器长度 $L = 3$。\n- 情况 3：周期 $P = 1200$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 30$ 秒，滤波器长度 $L = 5$。\n- 情况 4：周期 $P = 300$ 秒，因此 $\\omega = 2\\pi / P$，时间步长 $\\Delta t = 20$ 秒，滤波器长度 $L = 5$。\n\n所有输出都必须是浮点数。你的程序应该生成一行输出，其中包含按测试用例顺序排列的四个削减因子，形式为逗号分隔的列表，并用方括号括起来，每个浮点数四舍五入到六位小数（例如，$[0.123456,0.234567,0.345678,0.456789]$）。不应打印任何其他文本。",
            "solution": "该问题要求为数值模型中的单个线性正规模实现并评估数字滤波初始化（DFI）过程。目标是量化蛙跳时间步进格式固有的寄生计算模的削减程度。\n\n### 1. 模式与离散化格式\n\n物理系统是一个线性振子，由常微分方程描述：\n$$\n\\frac{dy}{dt} = i \\omega y\n$$\n其中 $y(t)$ 是一个复振幅，$\\omega$ 是一个实值角频率。精确解为 $y(t) = y(0) e^{i \\omega t}$，代表一个纯粹的振荡。\n\n时间离散化采用三时间层蛙跳格式在均匀网格 $t_n = n \\Delta t$ 上进行：\n$$\ny^{n+1} = y^{n-1} + 2 i \\omega \\Delta t \\, y^{n}\n$$\n这是对连续方程的有限差分近似。为分析其行为，我们寻找 $y^n = \\lambda^n$ 形式的解。将其代入递推关系，得到特征方程：\n$$\n\\lambda^2 - 2 i (\\omega \\Delta t) \\lambda - 1 = 0\n$$\n设 $x = \\omega \\Delta t$。根据二次公式，根为：\n$$\n\\lambda = i x \\pm \\sqrt{(-ix)^2 - (-1)} = i x \\pm \\sqrt{1 - x^2}\n$$\n为使格式在数值上稳定，根的模不得超过 1。这要求 $1 - x^2 \\ge 0$，从而导出 Courant-Friedrichs-Lewy (CFL) 条件 $|x| = |\\omega \\Delta t| \\le 1$。问题陈述中提供的所有测试用例都满足此条件。\n\n在此条件下，存在两个不同的根，它们的模均为 1：\n1.  **物理模根 ($\\lambda_p$)**: $\\lambda_p = \\sqrt{1 - x^2} + i x$。这可以写成 $\\lambda_p = e^{i\\theta_p}$，其中每个时间步长的数值相位变为 $\\theta_p = \\arcsin(x) = \\arcsin(\\omega \\Delta t)$。数值频率为 $\\omega_{\\text{num}} = \\theta_p / \\Delta t \\approx \\omega$（对于小的 $\\omega \\Delta t$）。这个根近似于真实的物理行为。\n2.  **计算模根 ($\\lambda_c$)**: $\\lambda_c = -\\sqrt{1 - x^2} + i x$。这可以写成 $\\lambda_c = e^{i\\theta_c}$，其中 $\\theta_c = \\pi - \\arcsin(\\omega \\Delta t)$。这个根是三时间层格式的人为产物。其频率接近奈奎斯特频率 $\\pi/\\Delta t$，并且由于其相位中存在 $\\pi$ 项，它表现出随时间交替变号的特性，使其成为寄生模。\n\n一般的数值解是这两种模式的线性组合：\n$$\ny^n = A_p (\\lambda_p)^n + A_c (\\lambda_c)^n\n$$\n其中 $A_p$ 和 $A_c$ 分别是物理模和计算模的复振幅，由初始条件确定。\n\n### 2. 启动过程与计算模的激发\n\n问题指定了一个旨在有意激发计算模的启动过程。初始化从 $y^0 = 1$ 开始。通过单步前向欧拉获得第二个时间层的值：\n$$\ny^{1}_{\\mathrm{FE}} = y^{0} + i \\omega \\Delta t \\, y^{0} = (1 + i \\omega \\Delta t)\n$$\n为了启动三层蛙跳格式，需要 $t_{-1}$ 处的值。$y^{-1}$ 的定义要求蛙跳关系对三元组 $(y^{-1}, y^0, y^1_{\\mathrm{FE}})$ 成立：\n$$\ny^{1}_{\\mathrm{FE}} = y^{-1} + 2 i \\omega \\Delta t \\, y^0 \\implies y^{-1} = y^{1}_{\\mathrm{FE}} - 2 i \\omega \\Delta t \\, y^0 = (1 + i \\omega \\Delta t) - 2 i \\omega \\Delta t = 1 - i \\omega \\Delta t\n$$\n这种两步初始化（使用像前向欧拉这样的两层格式生成一个点）在时间层之间造成了不平衡，这种不平衡会投影到计算模上，从而使得 $A_c \\neq 0$。在定义了 $y^{-1}$ 和 $y^0$ 之后，整个时间序列 $\\{y^n\\}_{n=-K}^K$ 就可以通过从 $n=0$ 向前和向后使用蛙跳递推关系生成。\n\n### 3. 数字滤波初始化 (DFI)\n\nDFI 旨在通过应用一个低通数字滤波器来抑制计算模。指定的滤波器是一个对称的有限脉冲响应（FIR）滤波器，长度为奇数 $L = 2M+1$，权重为 $\\{w_k\\}_{k=-M}^M$。在时间 $n$ 的滤波值为一个加权平均：\n$$\ny^{n}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_{k} \\, y^{n+k}\n$$\n权重由 $L-1$ 阶的归一化二项式系数给出：\n$$\nw_k = \\frac{\\binom{L-1}{k+M}}{2^{L-1}}, \\quad k = -M, \\dots, M\n$$\n这些权重满足两个关键性质：\n1.  $\\sum_{k=-M}^{M} w_k = 1$：滤波器对于零频率信号（直流分量）具有单位增益，从而保留平均状态。\n2.  $\\sum_{k=-M}^{M} (-1)^k w_k = 0$：滤波器在奈奎斯特频率 $\\pi / \\Delta t$ 处具有零增益。由于计算模的频率接近此值，滤波器会强烈地衰减它。\n\n这种二项式滤波器的频率响应为 $H(\\Omega) = (\\cos(\\Omega/2))^{L-1}$，其中 $\\Omega$ 是数字频率。滤波器在计算模频率 $\\Omega_c = \\pi - \\theta_p$ 处的响应是 $(\\cos((\\pi-\\theta_p)/2))^{L-1} = (\\sin(\\theta_p/2))^{L-1}$。对于小的 $\\theta_p$，这个值非常小，证实了对计算模的强烈阻尼作用。\n\n### 4. 量化削减程度\n\n计算模的振幅通过其特有的高频振荡来衡量。交替分量定义为：\n$$\na^n = \\frac{1}{2} (y^n - y^{n-1})\n$$\n滤波前后该分量的振幅用于量化滤波器的有效性。\n- **DFI 之前**: 初始化时刻 $t_0$ 的振幅为 $A_{\\mathrm{before}} = |a^0| = \\left| \\frac{1}{2} (y^0 - y^{-1}) \\right|$。使用启动值：\n  $$\n  A_{\\mathrm{before}} = \\left| \\frac{1}{2} (1 - (1 - i \\omega \\Delta t)) \\right| = \\left| \\frac{1}{2} i \\omega \\Delta t \\right| = \\frac{\\omega \\Delta t}{2}\n  $$\n- **DFI 之后**: 计算 $t_0$ 和 $t_{-1}$ 处的滤波值，并从中导出振幅：\n  $$\n  A_{\\mathrm{after}} = \\left| \\frac{1}{2} (y^0_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}}) \\right|\n  $$\n  其中 $y^0_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_k y^k$ 且 $y^{-1}_{\\mathrm{filt}} = \\sum_{k=-M}^{M} w_k y^{k-1}$。\n削减因子是比率 $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$。\n\n### 5. 算法步骤\n\n对每个测试用例，通过以下步骤计算解答：\n1.  计算 $\\omega = 2\\pi/P$。\n2.  设置时间序列半跨度 $K=32$。创建一个复数数组 `y` 来存储时间序列 $\\{y^n\\}_{n=-K}^K$。\n3.  根据启动过程初始化所需的两个初始值：$y^0 = 1$ 和 $y^{-1} = 1 - i \\omega \\Delta t$。\n4.  使用蛙跳递推关系生成完整的时间序列：\n    - 对于 $n=1, \\dots, K$：$y^n = y^{n-2} + 2 i \\omega \\Delta t \\, y^{n-1}$。\n    - 对于 $n=-2, \\dots, -K$：$y^n = y^{n+2} - 2 i \\omega \\Delta t \\, y^{n+1}$。\n5.  根据给定的滤波器长度 $L$ 使用二项式系数公式计算 FIR 滤波器权重 $\\{w_k\\}$。\n6.  通过将权重与时间序列 `y` 的适当段进行卷积，计算滤波值 $y^0_{\\mathrm{filt}}$ 和 $y^{-1}_{\\mathrm{filt}}$。\n7.  计算“之前”的振幅 $A_{\\mathrm{before}} = |\\frac{1}{2}(y^0 - y^{-1})|$。\n8.  计算“之后”的振幅 $A_{\\mathrm{after}} = |\\frac{1}{2}(y^0_{\\mathrm{filt}} - y^{-1}_{\\mathrm{filt}})|$。\n9.  计算并存储削减因子 $R = A_{\\mathrm{after}} / A_{\\mathrm{before}}$。\n10. 按指定格式格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Implements and evaluates Digital Filter Initialization (DFI) for a single\n    linear normal mode discretized with the leapfrog scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Period P in s, time step dt in s, filter length L)\n        (600.0, 30.0, 3),\n        (240.0, 30.0, 3),\n        (1200.0, 30.0, 5),\n        (300.0, 20.0, 5),\n    ]\n\n    results = []\n    \n    # Integration index half-span as specified\n    K = 32\n\n    for P, dt, L in test_cases:\n        # Step 1: Model and discretization parameters\n        omega = 2.0 * np.pi / P\n        \n        # The time series will be stored in an array where index j corresponds\n        # to time index n = j - K. Array size is 2*K+1 for n from -K to K.\n        y = np.zeros(2 * K + 1, dtype=np.complex128)\n\n        # Step 2: Start-up procedure to excite the computational mode\n        # y^0 = 1 + 0i\n        idx_0 = K\n        y[idx_0] = 1.0 + 0.0j\n        \n        # y^1_FE = y^0 + dt * i * omega * y^0\n        y1_fe = y[idx_0] * (1.0 + 1j * omega * dt)\n        \n        # y^-1 is defined by inverting leapfrog at n=0\n        # y^-1 = y^1_FE - 2 * i * omega * dt * y^0\n        idx_m1 = K - 1\n        y[idx_m1] = y1_fe - 2.0 * 1j * omega * dt * y[idx_0]\n        \n        # Use the first leapfrog step to define y^1\n        # y^1 = y^-1 + 2 * i * omega * dt * y^0, which equals y^1_FE\n        idx_p1 = K + 1\n        y[idx_p1] = y[idx_m1] + 2.0 * 1j * omega * dt * y[idx_0]\n        \n        # Generate the time series using the leapfrog scheme\n        # Forward in time from n=1 to K-1 - y^2...y^K\n        for n in range(1, K):\n            j = K + n  # current time index in array\n            y[j + 1] = y[j - 1] + 2.0 * 1j * omega * dt * y[j]\n        \n        # Backward in time from n=-1 to -K+1 - y^-2...y^-K\n        # Inverted leapfrog: y^(n-1) = y^(n+1) - 2*i*omega*dt*y^n\n        for n in range(0, -K, -1):\n            j = K + n  # current time index in array\n            y[j - 1] = y[j + 1] - 2.0 * 1j * omega * dt * y[j]\n            \n        # Step 3: Define the time-symmetric digital filter\n        M = (L - 1) // 2\n        weights = np.zeros(L)\n        for k_idx, k in enumerate(range(-M, M + 1)):\n            weights[k_idx] = comb(L - 1, k + M) / (2**(L - 1))\n            \n        # Apply the filter to find y^0_filt and y^-1_filt\n        # y^n_filt = sum_{k=-M to M} w_k * y^{n+k}\n        \n        # For y^0_filt, n=0. The window is y^{-M}, ..., y^{M}\n        # Array indices: K-M, ..., K+M\n        y0_filt = np.dot(weights, y[idx_0 - M : idx_0 + M + 1])\n        \n        # For y^-1_filt, n=-1. The window is y^{-1-M}, ..., y^{-1+M}\n        # Array indices: K-1-M, ..., K-1+M\n        ym1_filt = np.dot(weights, y[idx_m1 - M : idx_m1 + M + 1])\n\n        # Step 4: Compute computational mode amplitude before and after DFI\n        # A_before = |1/2 * (y^0 - y^-1)|\n        A_before = 0.5 * np.abs(y[idx_0] - y[idx_m1])\n        \n        # A_after = |1/2 * (y^0_filt - y^-1_filt)|\n        A_after = 0.5 * np.abs(y0_filt - ym1_filt)\n\n        # Compute the reduction factor R\n        if A_before == 0:\n            # Avoid division by zero, though not expected in these cases\n            R = 0.0 if A_after == 0.0 else np.inf\n        else:\n            R = A_after / A_before\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}