{
    "hands_on_practices": [
        {
            "introduction": "数据同化中的一个核心挑战是如何在不“冲击”模型（即不激发不真实的快波）的情况下引入新的观测信息。本练习将使用经典的旋转浅水方程模型，探讨增量分析更新（IAU）是如何实现这一目标的。我们将学习如何将分析增量分解为慢（平衡）分量和快（不平衡）分量，并量化不同同化策略在处理这一挑战时的表现，从而深入理解IAU在维持模式平衡方面的关键作用 。",
            "id": "4069131",
            "problem": "考虑在科里奥利参数恒定的平面（通常称为 $f$ 平面）上，线性化旋转浅水方程的单个傅里叶波数表示。设状态向量为 $\\delta x = [\\hat{u}, \\hat{v}, \\hat{\\eta}]^\\top$，其中 $\\hat{u}$ 和 $\\hat{v}$ 分别是纬向和经向速度分量的复傅里叶振幅（单位：$\\mathrm{m/s}$），$\\hat{\\eta}$ 是自由表面高度扰动的复傅里叶振幅（单位：$\\mathrm{m}$）。对于给定的实波数 $k$（单位：$\\mathrm{rad/m}$）、平均深度 $H$（单位：$\\mathrm{m}$）、重力加速度 $g$（单位：$\\mathrm{m/s^2}$）和科里奥利参数 $f$（单位：$\\mathrm{s^{-1}}$），控制傅里叶振幅时间倾向的线性算子是由线性化动量和质量守恒的物理定律定义的 $3 \\times 3$ 复矩阵 $L(k)$：\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\n\\hat{u} \\\\ \\hat{v} \\\\ \\hat{\\eta}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0  f  -\\, i\\, g\\, k \\\\\n-\\, f  0  0 \\\\\n-\\, i\\, H\\, k  0  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\hat{u} \\\\ \\hat{v} \\\\ \\hat{\\eta}\n\\end{bmatrix}\n\\equiv L(k)\\, \\delta x,\n$$\n其中 $i$ 是虚数单位。$L(k)$ 的简正模分解产生一个平衡（零频率）本征模和两个具有纯虚频率的惯性重力快波。增量分析更新（IAU）将分析增量作为在持续时间为 $\\Delta t$（单位：$\\mathrm{s}$）的有限窗口内的时不变倾向引入，而不是作为瞬时变化。为减轻快波的虚假激发，一种策略是使用模态分解将分析增量 $\\delta x$ 分解为平衡和非平衡分量，并仅对平衡分量应用 IAU。\n\n您的任务是：\n- 从上面给出的线性系统及其谱表示出发，推导出将任意增量 $\\delta x$ 分解为一个平衡分量和两个快波分量的简正模分解。使用 $L(k)$ 的右特征向量和左特征向量的双正交集来定义模态系数。\n- 从线性时不变系统的第一性原理出发，推导每个模态对在窗口 $[0,\\Delta t]$ 上施加的时不变强迫的响应。利用此结果设计两种 IAU 策略：(i) 对完整增量应用 IAU 和 (ii) 仅对平衡分量应用 IAU。同时考虑直接瞬时插入（无 IAU）的基准策略。\n- 通过计算由下式定义的快波分数 $\\phi$ 来量化窗口结束后的快波含量：\n$$\n\\phi = \\frac{\\sum_{i \\in \\mathcal{F}} \\left| \\tilde{c}_i \\right|^2}{\\sum_{j} \\left| \\tilde{c}_j \\right|^2},\n$$\n其中 $\\tilde{c}$ 是给定策略对应的最终状态的模态系数，$\\mathcal{F}$ 索引两个快波模态。将 $\\phi$ 表示为十进制数。\n\n使用以下科学上真实的参数值和测试套件。在所有情况下，均使用 $g = 9.81\\,\\mathrm{m/s^2}$、$H = 10000\\,\\mathrm{m}$、$f = 1.0 \\times 10^{-4}\\,\\mathrm{s^{-1}}$，以及 IAU 窗口 $\\Delta t = 6000\\,\\mathrm{s}$。对于每个测试用例，$k$ 的单位是 $\\mathrm{rad/m}$，$\\delta x$ 由其分量 $(\\hat{u}, \\hat{v}, \\hat{\\eta})$ 给出，其中 $\\hat{u}$ 和 $\\hat{v}$ 的单位是 $\\mathrm{m/s}$，$\\hat{\\eta}$ 的单位是 $\\mathrm{m}$：\n- 测试用例 1（一般混合增量，理想情况）：$k = 1.0 \\times 10^{-6}$，$\\delta x = (1.0, 0.5, 0.1)$。\n- 测试用例 2（为满足地转相位关系而构建的纯平衡增量）：$k = 1.0 \\times 10^{-6}$，$\\delta x = \\left(0.0, i \\frac{g k}{f} \\times 1.0,\\ 1.0\\right)$。\n- 测试用例 3（纯快波类增量）：$k = 3.0 \\times 10^{-6}$，$\\delta x = (2.0, 0.0, 0.0)$。\n- 测试用例 4（$k=0$ 的边界情况）：$k = 0.0$，$\\delta x = (0.0, 0.0, 1.0)$。\n\n您的程序必须：\n1. 为每个测试用例构建 $L(k)$。\n2. 计算 $L(k)$ 的右特征向量 $V$ 和左特征向量 $W$，将它们双正交归一化以使 $W^\\top V = I$，并将在数值上最接近 $0$ 的特征值对应的模态识别为平衡模态。\n3. 计算模态增量 $\\delta c = W^\\top \\delta x$。\n4. 对于三种策略，计算 IAU 窗口结束后的最终模态系数：\n   - 直接插入（无 IAU）：$\\tilde{c}^{\\mathrm{dir}} = \\delta c$。\n   - 完整 IAU：对每个模态在持续时间 $\\Delta t$ 内应用精确的常数强迫响应，得到 $\\tilde{c}^{\\mathrm{full}}$。\n   - 仅平衡 IAU：$\\tilde{c}^{\\mathrm{bal}}$ 等于 $\\delta c$ 的平衡分量，所有快波分量设为零。\n5. 为每个测试用例计算 $\\phi^{\\mathrm{dir}}$、$\\phi^{\\mathrm{full}}$ 和 $\\phi^{\\mathrm{bal}}$，结果为无量纲十进制数。\n\n$k$ 的角度单位是弧度。所有物理量必须使用国际单位制（SI）处理。您的程序应生成单行输出，包含一个由四个列表组成的逗号分隔列表，每个测试用例一个列表，每个列表包含三个十进制数，顺序为 $[\\phi^{\\mathrm{dir}}, \\phi^{\\mathrm{full}}, \\phi^{\\mathrm{bal}}]$。例如，输出格式必须严格为\n`[[phi_1,dir,phi_1,full,phi_1,bal],[phi_2,dir,phi_2,full,phi_2,bal],[phi_3,dir,phi_3,full,phi_3,bal],[phi_4,dir,phi_4,full,phi_4,bal]]`\n其中每个 $\\phi$ 表示为十进制数。",
            "solution": "该问题要求在线性化旋转浅水方程（$f$ 平面）的框架内，对三种资料同化策略——直接插入、完整增量分析更新（IAU）和仅平衡 IAU——进行定量比较。比较的依据是每种策略产生的虚假快波能量的多少。这通过快波分数 $\\phi$ 来量化。解决方案首先推导系统的简正模分解，然后推导每个模态对 IAU 特有的常数强迫的响应，最后应用这些结果来计算每种策略和测试用例的 $\\phi$。\n\n**1. 线性算子的简正模分解**\n\n控制线性系统由 $\\frac{d}{dt}\\delta x = L(k) \\delta x$ 给出，其中 $\\delta x = [\\hat{u}, \\hat{v}, \\hat{\\eta}]^\\top$ 是傅里叶振幅的状态向量，$L(k)$ 是线性算子：\n$$\nL(k) =\n\\begin{bmatrix}\n0  f  -\\, i\\, g\\, k \\\\\n-\\, f  0  0 \\\\\n-\\, i\\, H\\, k  0  0\n\\end{bmatrix}\n$$\n系统的简正模对应于 $L(k)$ 的特征向量。相关的特征值 $\\lambda$ 是这些模态的复频率。它们通过求解特征方程 $\\det(L(k) - \\lambda I) = 0$ 来找到：\n$$\n\\det \\begin{bmatrix} -\\lambda  f  -igk \\\\ -f  -\\lambda  0 \\\\ -iHk  0  -\\lambda \\end{bmatrix} = -\\lambda(\\lambda^2) - f(f\\lambda) - igk(i\\lambda Hk) = -\\lambda(\\lambda^2 + f^2 + gHk^2) = 0\n$$\n对于 $k>0$ 和 $f>0$，这会产生三个不同的特征值：\n1.  $\\lambda_1 = 0$：这对应于一个静止的、零频率的模态，称为平衡模或地转模。\n2.  $\\lambda_{2,3} = \\pm i \\sqrt{f^2 + gHk^2} \\equiv \\pm i\\omega_{igw}$：这对应于一对反向传播的高频惯性重力波（快波），其频率为 $\\omega_{igw}$。\n\n系统可以使用右特征向量矩阵 $V$ 和左特征向量矩阵 $W$ 进行对角化。右特征向量 $V_j$ 是 $V$ 的列，满足 $L(k)V_j = \\lambda_j V_j$。左特征向量 $W_j$ 是 $W^\\top$ 对应的行，满足 $W_j^\\top L(k) = \\lambda_j W_j^\\top$。这些特征向量集是双正交的。它们可以被缩放以使 $W^\\top V = I$，其中 $I$ 是单位矩阵。这个关系意味着 $W^\\top = V^{-1}$。\n\n任意状态向量 $\\delta x$ 可以投影到这个模态基上：\n$$\n\\delta x = \\sum_j (\\delta c_j) V_j = V \\delta c\n$$\n其中 $\\delta c = [\\delta c_1, \\delta c_2, \\delta c_3]^\\top$ 是模态系数向量。利用双正交性，可以求得这些系数：\n$$\n\\delta c = V^{-1} \\delta x = W^\\top \\delta x\n$$\n系数 $\\delta c_1$ 表示 $\\delta x$ 的平衡模分量的振幅，而 $\\delta c_2$ 和 $\\delta c_3$ 表示两个快波分量的振幅。\n\n**2. 对常数强迫（IAU）的响应**\n\nIAU 将分析增量 $\\delta x$ 作为在持续时间为 $\\Delta t$ 的时间窗口内的常数强迫项施加。对于从 $x(0)=0$ 开始的状态 $x(t)$，其控制微分方程为：\n$$\n\\frac{d x}{dt} = L(k) x + \\frac{\\delta x}{\\Delta t}, \\quad \\text{for } t \\in [0, \\Delta t]\n$$\n将此方程投影到模态基上，我们得到一组关于模态系数 $c_j(t)$ 的解耦常微分方程：\n$$\n\\frac{d c_j}{dt} = \\lambda_j c_j + \\frac{\\delta c_j}{\\Delta t}\n$$\n该方程在初始条件 $c_j(0) = 0$ 下的解可以通过标准方法求得。对于 $\\lambda_j \\neq 0$：\n$$\nc_j(t) = \\frac{\\delta c_j}{\\lambda_j \\Delta t} (e^{\\lambda_j t} - 1)\n$$\n对于 $\\lambda_1 = 0$ 的平衡模，方程简化为 $\\frac{d c_1}{dt} = \\frac{\\delta c_1}{\\Delta t}$，积分得到 $c_1(t) = \\frac{\\delta c_1}{\\Delta t} t$。\n\n在 IAU 窗口结束时，即 $t=\\Delta t$，最终的模态系数 $\\tilde{c}_j = c_j(\\Delta t)$ 为：\n-   对于快波（$j=2,3$）：$\\tilde{c}_j = \\frac{\\delta c_j}{\\lambda_j \\Delta t} (e^{\\lambda_j \\Delta t} - 1)$。\n-   对于平衡模（$j=1$）：$\\tilde{c}_1 = \\frac{\\delta c_1}{\\Delta t} \\Delta t = \\delta c_1$。\n\n我们可以为每个模态定义一个响应因子 $R_j$，使得 $\\tilde{c}_j = R_j \\delta c_j$。\n$$\nR_j = \\begin{cases} \\frac{e^{\\lambda_j \\Delta t} - 1}{\\lambda_j \\Delta t}  \\text{if } \\lambda_j \\neq 0 \\\\ 1  \\text{if } \\lambda_j = 0 \\end{cases}\n$$\n极限 $\\lim_{\\lambda \\to 0} (e^{\\lambda \\Delta t}-1)/(\\lambda \\Delta t) = 1$，因此公式是一致的。快波的响应因子 $|R_{2,3}| = |\\mathrm{sinc}(\\omega_{igw} \\Delta t / 2)|$ 起到低通滤波器的作用。对于自变量 $\\omega_{igw} \\Delta t$ 很大的快波，其响应会显著衰减。\n\n**3. 同化策略的比较**\n\n现在我们可以为三种策略中的每一种定义最终的模态状态 $\\tilde{c}$。\n\n-   **直接插入 (dir)**：增量被瞬时添加。最终状态为 $\\delta x$。相应的模态系数就是增量本身的模态系数：\n    $$\n    \\tilde{c}^{\\mathrm{dir}} = \\delta c\n    $$\n-   **完整 IAU (full)**：增量作为在 $\\Delta t$ 时间内的常数强迫施加。最终的模态系数通过对每个模态应用响应因子得到：\n    $$\n    \\tilde{c}^{\\mathrm{full}}_j = R_j \\delta c_j\n    $$\n-   **仅平衡 IAU (bal)**：IAU 过程仅应用于增量的平衡部分，而快波分量被丢弃。这意味着最终状态只包含原始增量的平衡分量。\n    $$\n    \\tilde{c}^{\\mathrm{bal}}_1 = \\delta c_1, \\quad \\tilde{c}^{\\mathrm{bal}}_{2,3} = 0\n    $$\n\n**4. 快波分数的计算**\n\n快波分数 $\\phi$ 是快波中的能量与所有模态总能量之比。能量与模态系数的模平方和成正比。设 $\\mathcal{F} = \\{2,3\\}$ 为快波模态的索引集。\n$$\n\\phi = \\frac{\\sum_{j \\in \\mathcal{F}} \\left| \\tilde{c}_j \\right|^2}{\\sum_{j=1}^3 \\left| \\tilde{c}_j \\right|^2}\n$$\n-   对于直接插入：$\\phi^{\\mathrm{dir}} = \\frac{|\\delta c_2|^2 + |\\delta c_3|^2}{|\\delta c_1|^2 + |\\delta c_2|^2 + |\\delta c_3|^2}$。\n-   对于完整 IAU：$\\phi^{\\mathrm{full}} = \\frac{|R_2 \\delta c_2|^2 + |R_3 \\delta c_3|^2}{|R_1 \\delta c_1|^2 + |R_2 \\delta c_2|^2 + |R_3 \\delta c_3|^2}$。由于 $|\\lambda_2|=|\\lambda_3|$，因此有 $|R_2|=|R_3|=|R_{fast}|$，且 $R_1=1$。于是：\n    $$\n    \\phi^{\\mathrm{full}} = \\frac{|R_{fast}|^2 (|\\delta c_2|^2 + |\\delta c_3|^2)}{|\\delta c_1|^2 + |R_{fast}|^2 (|\\delta c_2|^2 + |\\delta c_3|^2)}\n    $$\n-   对于仅平衡 IAU：$\\phi^{\\mathrm{bal}} = \\frac{|0|^2 + |0|^2}{|\\delta c_1|^2 + |0|^2 + |0|^2} = 0$（假设 $\\delta c_1 \\neq 0$；如果 $\\delta c_1 = 0$，结果为 $0/0$，自然地解释为 $0$）。\n\n**5. 特殊情况：$k=0$**\n\n当 $k=0$ 时，算子 $L(0)$ 简化，得到的特征值为 $\\lambda_1=0$ 和 $\\lambda_{2,3}=\\pm if$。平衡模的特征向量变为 $[0, 0, 1]^\\top$，代表纯粹的高度扰动。快波则变为纯惯性振荡，其特征向量为 $[1, \\pm i, 0]^\\top$。计算 $\\phi$ 的过程保持不变，只是使用这些特定的模态。使用通用特征值求解器的数值实现可以处理这种情况，除了在矩阵 $L$ 中设置 $k=0$ 外，不需要单独的逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fast-mode fraction for three data assimilation strategies\n    based on a linearized rotating shallow-water model.\n    \"\"\"\n    # Define constants\n    g = 9.81  # m/s^2\n    H = 10000.0  # m\n    f = 1.0e-4  # s^-1\n    dt = 6000.0  # s\n\n    # Define test cases: (k, delta_x)\n    # delta_x is given as (u, v, eta)\n    test_cases = [\n        (1.0e-6, np.array([1.0, 0.5, 0.1], dtype=complex)),\n        (1.0e-6, np.array([0.0, 1j * g * 1.0e-6 / f * 1.0, 1.0], dtype=complex)),\n        (3.0e-6, np.array([2.0, 0.0, 0.0], dtype=complex)),\n        (0.0, np.array([0.0, 0.0, 1.0], dtype=complex)),\n    ]\n\n    results = []\n    \n    for k, delta_x in test_cases:\n        # 1. Construct the linear operator L(k)\n        L = np.array([\n            [0, f, -1j * g * k],\n            [-f, 0, 0],\n            [-1j * H * k, 0, 0]\n        ], dtype=complex)\n\n        # 2. Compute eigenvalues, right eigenvectors (V), and left eigenvectors (W^T)\n        eigvals, V = np.linalg.eig(L)\n        \n        # W.T = V^-1\n        try:\n            W_T = np.linalg.inv(V)\n        except np.linalg.LinAlgError:\n            # For rank-deficient matrices, use pseudo-inverse\n            W_T = np.linalg.pinv(V)\n\n        # Identify balanced mode index\n        bal_idx = np.argmin(np.abs(eigvals))\n        fast_indices = [i for i in range(3) if i != bal_idx]\n\n        # 3. Compute the modal increment vector\n        delta_c = W_T @ delta_x\n\n        # Calculate squared magnitudes of modal coefficients\n        delta_c_sq_mag = np.abs(delta_c)**2\n        \n        # Numerator and denominator for direct insertion phi\n        fast_c_sq_mag_dir = np.sum(delta_c_sq_mag[fast_indices])\n        total_c_sq_mag_dir = np.sum(delta_c_sq_mag)\n\n        # 4. Compute phi for each strategy\n\n        # Strategy 1: Direct insertion\n        if total_c_sq_mag_dir  1e-15:\n            phi_dir = 0.0\n        else:\n            phi_dir = fast_c_sq_mag_dir / total_c_sq_mag_dir\n\n        # Strategy 2: Full IAU\n        R = np.ones_like(eigvals, dtype=complex)\n        for i in range(3):\n            if np.abs(eigvals[i]) > 1e-12:  # Avoid division by zero\n                R[i] = (np.exp(eigvals[i] * dt) - 1) / (eigvals[i] * dt)\n        \n        c_tilde_full = R * delta_c\n        c_tilde_full_sq_mag = np.abs(c_tilde_full)**2\n        \n        fast_c_sq_mag_full = np.sum(c_tilde_full_sq_mag[fast_indices])\n        total_c_sq_mag_full = np.sum(c_tilde_full_sq_mag)\n\n        if total_c_sq_mag_full  1e-15:\n            phi_full = 0.0\n        else:\n            phi_full = fast_c_sq_mag_full / total_c_sq_mag_full\n            \n        # Strategy 3: Balanced-only IAU\n        # By definition, fast components are zero.\n        phi_bal = 0.0\n\n        results.append([phi_dir, phi_full, phi_bal])\n\n    # Final print statement in the exact required format.\n    # Using f-string for a compact representation.\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了Nudging方法的优势后，一个关键的实践问题随之而来：Nudging的强度应该设为多大？本练习将演示一种寻找最优Nudging强度 $\\alpha$ 的方法，该方法通过将预报误差建模为 $\\alpha$ 的函数来实现。通过对少量测试预报的结果进行曲线拟合，我们可以估算出能最小化预报误差的 $\\alpha$ 值，这是调整业务化天气预报模型中的一项常见任务 。",
            "id": "4069123",
            "problem": "考虑一个用于数值天气预报（NWP）的一维线性预报误差模型，该模型采用作为连续松弛（nudging）实现的增量分析更新（IAU）。设在离散模式时间 $t_k = k \\Delta t$ 时的预报误差为 $e_k$，其中同化时间步长为 $\\Delta t$。假设可分辨的线性模式动力学产生稳定的误差传播，其特征是每个时间步长的实数放大因子 $0  \\rho  1$，并且IAU-nudging以与误差成正比的松弛项形式引入，强度为 $\\alpha$（单位为时间的倒数）。组合的离散时间误差更新可以表示为\n$$\ne_{k+1} = \\left(\\rho - \\alpha \\Delta t\\right) e_k + \\xi_k,\n$$\n其中 $\\xi_k$ 是零均值、时间上不相关的过程噪声，其方差为 $\\sigma^2$，代表模式和未分辨过程的扰动。令预报时效为 $T = N \\Delta t$，并将预报均方根误差（RMSE）定义为\n$$\n\\mathrm{RMSE}(T;\\alpha) = \\sqrt{\\mathbb{E}\\left[e_N^2\\right]}.\n$$\n\n从上述动力学和统计假设出发，并使用在 $\\alpha \\Delta t$ 相对于 $\\rho$ 较小时有效的线性化方法，推导预报时效 $T$ 时预报误差方差 $\\mathbb{E}\\left[e_N^2\\right]$ 关于 $\\alpha$ 的二阶泰勒近似，表示为关于 $\\alpha$ 的二次响应曲线，\n$$\n\\mathbb{E}\\left[e_N^2\\right] \\approx \\beta_0 + \\beta_1 \\alpha + \\beta_2 \\alpha^2,\n$$\n其中系数 $\\beta_0$、$\\beta_1$ 和 $\\beta_2$ 是 $\\rho$、$\\Delta t$、 $N$、初始二阶矩 $v_0 = \\mathbb{E}\\left[e_0^2\\right]$ 以及过程噪声方差 $\\sigma^2$ 的函数。通过对 $\\mathbb{E}\\left[e_N^2\\right]$ 的精确 $\\alpha$ 依赖表达式关于 $\\alpha$ 求导并在 $\\alpha = 0$ 处求值，从第一性原理明确地确定这些系数。\n\n然后，假设一组在预报时效 $T$、同化时间步长 $\\Delta t = 600$ 秒和 $N = 36$ 条件下进行的受控预报实验，对于三种不同的nudging强度，得到了以下测量的RMSE值（单位为开尔文）：\n- $\\alpha_0 = 0$，此时 $\\mathrm{RMSE}(T; \\alpha_0) = 1.80$，\n- $\\alpha_1 = 2.0 \\times 10^{-4}$，此时 $\\mathrm{RMSE}(T; \\alpha_1) = 1.55$，\n- $\\alpha_2 = 6.0 \\times 10^{-4}$，此时 $\\mathrm{RMSE}(T; \\alpha_2) = 1.62$。\n\n将 $\\mathrm{RMSE}^2(T;\\alpha)$ 视为二次响应 $\\beta_0 + \\beta_1 \\alpha + \\beta_2 \\alpha^2$，将 $\\beta_0$、$\\beta_1$ 和 $\\beta_2$ 拟合到这三个数据点，并使用拟合曲线选择能使预报时效 $T$ 时的预报方差最小化的nudging强度 $\\alpha^\\star$。\n\n将您的最终 $\\alpha^\\star$ 值四舍五入至三位有效数字，并以 $\\mathrm{s}^{-1}$ 为单位表示。最终答案必须是一个实数。",
            "solution": "用户提供了一个由两部分组成的问题。第一部分要求推导预报误差方差的二次近似的系数。第二部分要求将此二次模型拟合到实验数据，并找出最优的nudging强度。\n\n### 问题验证\n问题陈述已经过验证，被认为是具有科学依据、适定、客观且自洽的。该模型是数值天气预报（NWP）中带有nudging的误差动力学的标准简化表示。任务在数学上是严谨的，不需要外部信息。所提供的数据对于所要求的分析是一致且充分的。因此，问题被判定为有效，并将提供完整的解答。\n\n### 第一部分：泰勒级数系数的推导\n\n时间步长 $k$ 时的预报误差 $e_k$ 由以下线性递推关系决定：\n$$\ne_{k+1} = (\\rho - \\alpha \\Delta t) e_k + \\xi_k\n$$\n让我们定义有效放大因子为 $R(\\alpha) = \\rho - \\alpha \\Delta t$。方程变为 $e_{k+1} = R(\\alpha) e_k + \\xi_k$。\n为了找到预报时效 $T = N \\Delta t$ 时的误差 $e_N$，我们可以从初始误差 $e_0$ 开始展开递推关系：\n$$\ne_1 = R(\\alpha) e_0 + \\xi_0 \\\\\ne_2 = R(\\alpha) e_1 + \\xi_1 = R(\\alpha) \\left(R(\\alpha) e_0 + \\xi_0\\right) + \\xi_1 = R(\\alpha)^2 e_0 + R(\\alpha) \\xi_0 + \\xi_1\n$$\n通过归纳法，第 $N$ 步的误差由下式给出：\n$$\ne_N = R(\\alpha)^N e_0 + \\sum_{j=0}^{N-1} R(\\alpha)^{N-1-j} \\xi_j\n$$\n问题要求的是预报误差方差 $V(\\alpha) = \\mathbb{E}[e_N^2]$。我们对 $e_N$ 的表达式求平方，然后取期望。\n$$\ne_N^2 = \\left(R(\\alpha)^N e_0 + \\sum_{j=0}^{N-1} R(\\alpha)^{N-1-j} \\xi_j\\right)^2 = R(\\alpha)^{2N} e_0^2 + 2 R(\\alpha)^N e_0 \\sum_{j=0}^{N-1} R(\\alpha)^{N-1-j} \\xi_j + \\left(\\sum_{j=0}^{N-1} R(\\alpha)^{N-1-j} \\xi_j\\right)^2\n$$\n取期望 $\\mathbb{E}[\\cdot]$，我们使用给定的统计特性：$\\mathbb{E}[\\xi_k] = 0$，$\\mathbb{E}[\\xi_j \\xi_k] = \\sigma^2 \\delta_{jk}$（其中 $\\delta_{jk}$ 是克罗内克δ函数），并且初始误差 $e_0$ 与过程噪声 $\\xi_k$ 不相关，因此 $\\mathbb{E}[e_0 \\xi_k] = \\mathbb{E}[e_0] \\mathbb{E}[\\xi_k] = 0$。\n交叉项的期望为零：\n$$\n\\mathbb{E}\\left[2 R(\\alpha)^N e_0 \\sum_{j=0}^{N-1} R(\\alpha)^{N-1-j} \\xi_j\\right] = 2 R(\\alpha)^N \\sum_{j=0}^{N-1} R(\\alpha)^{N-1-j} \\mathbb{E}[e_0 \\xi_j] = 0\n$$\n由于 $\\xi_k$ 的不相关性，噪声项平方和的期望可以简化为：\n$$\n\\mathbb{E}\\left[\\left(\\sum_{j=0}^{N-1} R(\\alpha)^{N-1-j} \\xi_j\\right)^2\\right] = \\sum_{j=0}^{N-1} \\sum_{l=0}^{N-1} R(\\alpha)^{N-1-j} R(\\alpha)^{N-1-l} \\mathbb{E}[\\xi_j \\xi_l] = \\sum_{j=0}^{N-1} (R(\\alpha)^{N-1-j})^2 \\sigma^2 \\delta_{jj} = \\sigma^2 \\sum_{j=0}^{N-1} R(\\alpha)^{2(N-1-j)}\n$$\n令 $k = N-1-j$，则求和变为 $\\sigma^2 \\sum_{k=0}^{N-1} R(\\alpha)^{2k}$。这是一个几何级数。\n合并各项，并使用 $v_0 = \\mathbb{E}[e_0^2]$，方差的精确表达式为：\n$$\nV(\\alpha) = \\mathbb{E}[e_N^2] = v_0 R(\\alpha)^{2N} + \\sigma^2 \\sum_{k=0}^{N-1} R(\\alpha)^{2k}\n$$\n问题要求 $V(\\alpha)$ 在 $\\alpha=0$ 附近的二阶泰勒近似：\n$$\nV(\\alpha) \\approx V(0) + V'(0)\\alpha + \\frac{1}{2}V''(0)\\alpha^2 = \\beta_0 + \\beta_1 \\alpha + \\beta_2 \\alpha^2\n$$\n系数为 $\\beta_0 = V(0)$、$\\beta_1 = V'(0)$ 和 $\\beta_2 = \\frac{1}{2}V''(0)$。我们通过微分法求得它们。\n\n**系数 $\\beta_0$**：\n令 $\\alpha=0$，则 $R(0) = \\rho$。\n$$\n\\beta_0 = V(0) = v_0 \\rho^{2N} + \\sigma^2 \\sum_{k=0}^{N-1} \\rho^{2k} = v_0 \\rho^{2N} + \\sigma^2 \\frac{1-\\rho^{2N}}{1-\\rho^2}\n$$\n\n**系数 $\\beta_1$**：\n首先，我们求导数 $V'(\\alpha)$。我们使用链式法则，注意到 $\\frac{dR}{d\\alpha} = -\\Delta t$。\n$$\nV'(\\alpha) = \\frac{d}{d\\alpha}\\left(v_0 R(\\alpha)^{2N} + \\sigma^2 \\sum_{k=0}^{N-1} R(\\alpha)^{2k}\\right) = v_0 \\cdot 2N R(\\alpha)^{2N-1} \\frac{dR}{d\\alpha} + \\sigma^2 \\sum_{k=1}^{N-1} 2k R(\\alpha)^{2k-1} \\frac{dR}{d\\alpha}\n$$\n（注意，求和中 $k=0$ 的项是常数1，所以其导数为零）。\n$$\nV'(\\alpha) = -\\Delta t \\left( 2N v_0 R(\\alpha)^{2N-1} + 2\\sigma^2 \\sum_{k=1}^{N-1} k R(\\alpha)^{2k-1} \\right)\n$$\n在 $\\alpha=0$ 处求值（此时 $R(0)=\\rho$）：\n$$\n\\beta_1 = V'(0) = -2\\Delta t \\left( N v_0 \\rho^{2N-1} + \\sigma^2 \\sum_{k=1}^{N-1} k \\rho^{2k-1} \\right)\n$$\n\n**系数 $\\beta_2$**：\n接下来，我们通过对 $V'(\\alpha)$ 求导来找到二阶导数 $V''(\\alpha)$：\n$$\nV''(\\alpha) = \\frac{d}{d\\alpha} V'(\\alpha) = (-\\Delta t) \\frac{d}{d\\alpha} \\left( 2N v_0 R(\\alpha)^{2N-1} + 2\\sigma^2 \\sum_{k=1}^{N-1} k R(\\alpha)^{2k-1} \\right)\n$$\n再次应用链式法则：\n$$\nV''(\\alpha) = (-\\Delta t)^2 \\left( 2N v_0 (2N-1) R(\\alpha)^{2N-2} + 2\\sigma^2 \\sum_{k=1}^{N-1} k(2k-1)R(\\alpha)^{2k-2} \\right)\n$$\n在 $\\alpha=0$ 处求值：\n$$\nV''(0) = (\\Delta t)^2 \\left( 2N(2N-1)v_0 \\rho^{2N-2} + 2\\sigma^2 \\sum_{k=1}^{N-1} k(2k-1)\\rho^{2k-2} \\right)\n$$\n系数 $\\beta_2$ 是 $\\frac{1}{2}V''(0)$：\n$$\n\\beta_2 = \\frac{1}{2}V''(0) = (\\Delta t)^2 \\left( N(2N-1)v_0 \\rho^{2N-2} + \\sigma^2 \\sum_{k=1}^{N-1} k(2k-1)\\rho^{2k-2} \\right)\n$$\n这些就是系数 $\\beta_0$、$\\beta_1$ 和 $\\beta_2$ 的表达式。\n\n### 第二部分：数据拟合与优化\n\n我们得到三个数据点 $(\\alpha_i, \\mathrm{RMSE}_i)$，并被要求拟合模型 $\\mathbb{E}[e_N^2] = \\beta_0 + \\beta_1 \\alpha + \\beta_2 \\alpha^2$。令 $y_i = \\mathrm{RMSE}_i^2$。这些数据点是：",
            "answer": "$$\n\\boxed{3.65 \\times 10^{-4}}\n$$"
        },
        {
            "introduction": "尽管Nudging是一个强大的工具，但它并非没有风险。如果用于Nudging的分析场存在系统性偏差，它会系统地将模式的气候态拖离其自然状态，导致模拟结果出现偏差。最后一个练习将使用一个简化的随机模型，从解析和数值两个层面展示这种由Nudging引起的模式偏差是如何产生的，以及如何在长期积分中诊断它 。",
            "id": "4069137",
            "problem": "考虑一个标量气候变量 $T(t)$，它代表以开尔文 (K) 为单位的大尺度气温异常。该变量在一系列综合作用下演变，这些作用包括物理弛豫、随机强迫以及一种试图使模型保持在目标分析场附近的逼近（nudging）趋势。其潜在的物理弛豫表现为以速率参数 $\\beta$（单位为 $\\mathrm{day}^{-1}$）向真实气候平衡态 $T^\\star$ 的线性趋近。逼近趋势则被参数化为以系数 $\\alpha$（单位为 $\\mathrm{day}^{-1}$）向指定目标 $T_s$ 的线性弛豫。目标 $T_s$ 相对于真实气候平衡态存在一个以开尔文为单位的恒定偏移量 $\\delta$ 的指定错误，因此有 $T_s = T^\\star + \\delta$。未解析的过程由高斯白噪声强迫表示，其振幅由扩散参数 $D$（单位为 $\\mathrm{K}^2 \\, \\mathrm{day}^{-1}$）设定。这种设置对应于增量分析更新（Incremental Analysis Updating, IAU），其中分析增量在时间上展开，并在此处表示为一个连续的趋势。\n\n我们使用欧拉-丸山（Euler–Maruyama）格式，在均匀时间步长 $\\Delta t$（单位为天）上对随机动力学进行离散化，其中 $\\xi_n$ 是独立的标准正态变量：\n$$\nT_{n+1} = T_n + \\left[-\\beta \\left(T_n - T^\\star\\right) - \\alpha \\left(T_n - T_s\\right)\\right]\\Delta t + \\sqrt{2D\\,\\Delta t}\\,\\xi_n.\n$$\n这是一个由恢复趋势和随机强迫共同驱动的线性奥恩斯坦-乌伦贝克（Ornstein–Uhlenbeck, OU）过程。目标是提出并实施一个诊断检验，通过检查长时间积分中的气候漂移，并将其与持续的 $\\alpha$ 和目标指定错误 $\\delta$ 相关联，来检测由逼近引入的偏差。\n\n从适用于数值天气预报和气候模拟的第一性原理出发，使用线性弛豫、期望和平稳性的定义，推导出平稳气候平均漂移 $\\overline{T} - T^\\star$ 作为 $\\alpha$、$\\beta$ 和 $\\delta$ 的函数。然后，实施一个诊断决策规则，当且仅当以下条件同时成立时，判定“存在逼近引入的偏差”：\n- 逼近系数满足 $\\alpha  0$ 且目标指定错误满足 $|\\delta|  0$。\n- 从数值模拟中观测到的长时间平均漂移与理论推导的平稳漂移在一个由绝对分量和相对分量组成的容差范围内一致。\n\n对系统进行数值模拟，积分长度为 $L$ 天。计算积分后半段的样本均值，以近似稳态均值。将容差定义为一个 $0.1$ K 的绝对阈值加上理论预测漂移量值的 $0.05$ 倍的相对阈值。该诊断检验应为每个测试用例返回一个布尔值，指示根据上述规则是否存在逼近引入的偏差。\n\n物理和数值单位：\n- 温度以开尔文 (K) 报告。\n- 速率 $\\alpha$ 和 $\\beta$ 的单位为 $\\mathrm{day}^{-1}$。\n- 时间步长 $\\Delta t$ 和积分长度 $L$ 的单位为天。\n- 扩散参数 $D$ 的单位为 $\\mathrm{K}^2 \\, \\mathrm{day}^{-1}$。\n\n你的程序必须实现该模拟和诊断，并将其应用于以下参数值测试套件，这些参数共同探测了不同的区域：\n- 测试用例 1（边界：无逼近）：$\\alpha = 0.0$ $\\mathrm{day}^{-1}$，$\\beta = 0.1$ $\\mathrm{day}^{-1}$，$\\delta = 2.0$ $\\mathrm{K}$，$D = 1.0$ $\\mathrm{K}^2 \\, \\mathrm{day}^{-1}$，$\\Delta t = 0.05$ $\\mathrm{day}$，$L = 20000$ $\\mathrm{day}$，$T^\\star = 288.0$ $\\mathrm{K}$。\n- 测试用例 2（理想路径：适度逼近，正向指定错误）：$\\alpha = 0.05$ $\\mathrm{day}^{-1}$，$\\beta = 0.1$ $\\mathrm{day}^{-1}$，$\\delta = 2.0$ $\\mathrm{K}$，$D = 1.0$ $\\mathrm{K}^2 \\, \\mathrm{day}^{-1}$，$\\Delta t = 0.05$ $\\mathrm{day}$，$L = 20000$ $\\mathrm{day}$，$T^\\star = 288.0$ $\\mathrm{K}$。\n- 测试用例 3（理想路径：较强逼近，负向指定错误）：$\\alpha = 0.2$ $\\mathrm{day}^{-1}$，$\\beta = 0.1$ $\\mathrm{day}^{-1}$，$\\delta = -1.0$ $\\mathrm{K}$，$D = 1.0$ $\\mathrm{K}^2 \\, \\mathrm{day}^{-1}$，$\\Delta t = 0.05$ $\\mathrm{day}$，$L = 20000$ $\\mathrm{day}$，$T^\\star = 288.0$ $\\mathrm{K}$。\n- 测试用例 4（边缘情况：零指定错误）：$\\alpha = 1.0$ $\\mathrm{day}^{-1}$，$\\beta = 0.1$ $\\mathrm{day}^{-1}$，$\\delta = 0.0$ $\\mathrm{K}$，$D = 1.0$ $\\mathrm{K}^2 \\, \\mathrm{day}^{-1}$，$\\Delta t = 0.05$ $\\mathrm{day}$，$L = 20000$ $\\mathrm{day}$，$T^\\star = 288.0$ $\\mathrm{K}$。\n- 测试用例 5（接近目标锁定：极强逼近）：$\\alpha = 2.0$ $\\mathrm{day}^{-1}$，$\\beta = 0.05$ $\\mathrm{day}^{-1}$，$\\delta = 1.5$ $\\mathrm{K}$，$D = 1.0$ $\\mathrm{K}^2 \\, \\mathrm{day}^{-1}$，$\\Delta t = 0.05$ $\\mathrm{day}$，$L = 20000$ $\\mathrm{day}$，$T^\\star = 288.0$ $\\mathrm{K}$。\n\n对于所有用例，均以 $T_0 = T^\\star$ 初始化。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 是一个布尔值，指示根据上述决策规则，测试用例 $i$ 是否存在逼近引入的偏差。不应打印任何其他文本。",
            "solution": "所提供的问题是随机动力系统分析领域一个有效且适定的练习，特别是在气候模拟和数据同化方面的应用。它要求对一种常见的数据同化技术，即逼近（nudging）或增量分析更新（Incremental Analysis Updating, IAU）所引入的偏差，进行解析推导和数值验证。该问题具有科学依据、内容自洽且算法精确。\n\n问题的核心在于分析线性奥恩斯坦-乌伦贝克（Ornstein-Uhlenbeck, OU）过程的平稳性质。温度异常 $T(t)$ 根据一个随机微分方程演变，该方程包括一个物理弛豫项、一个逼近项和随机强迫。我们的首要任务是推导期望的稳态偏差，即“气候平均漂移”$\\overline{T} - T^\\star$，其中 $\\overline{T}$ 是模型温度的长期平均值，而 $T^\\star$ 是真实的气候平衡态。\n\n动力学过程使用欧拉-丸山（Euler-Maruyama）格式离散化如下：\n$$\nT_{n+1} = T_n + \\left[-\\beta \\left(T_n - T^\\star\\right) - \\alpha \\left(T_n - T_s\\right)\\right]\\Delta t + \\sqrt{2D\\,\\Delta t}\\,\\xi_n\n$$\n此处，$T_n$ 是时间步 $n$ 的温度，$\\alpha$ 是逼近系数，$\\beta$ 是物理弛豫率，$T_s$ 是逼近目标，$T^\\star$ 是真实平衡态，$D$ 是扩散参数，$\\Delta t$ 是时间步长，$\\xi_n$ 是一个标准正态随机变量。逼近目标 $T_s$ 被定义为存在一个偏移量 $\\delta$ 的指定错误，即 $T_s = T^\\star + \\delta$。\n\n为求平稳均值 $\\overline{T}$，我们在其统计稳态下分析该系统。在此状态下，变量的期望值不随时间变化，即 $\\mathbb{E}[T_{n+1}] = \\mathbb{E}[T_n] = \\overline{T}$。我们可以对离散化方程求期望。由于 $\\mathbb{E}[\\xi_n] = 0$，随机项的期望为零。\n$$\n\\mathbb{E}[T_{n+1}] = \\mathbb{E}[T_n] + \\mathbb{E}\\left[\\left(-\\beta \\left(T_n - T^\\star\\right) - \\alpha \\left(T_n - T_s\\right)\\right)\\Delta t\\right] + \\mathbb{E}\\left[\\sqrt{2D\\,\\Delta t}\\,\\xi_n\\right]\n$$\n根据期望的线性性质，上式变为：\n$$\n\\overline{T} = \\overline{T} + \\left[-\\beta \\left(\\overline{T} - T^\\star\\right) - \\alpha \\left(\\overline{T} - T_s\\right)\\right]\\Delta t + 0\n$$\n由于 $\\Delta t  0$，为使方程成立，方括号内的项必须为零：\n$$\n-\\beta \\left(\\overline{T} - T^\\star\\right) - \\alpha \\left(\\overline{T} - T_s\\right) = 0\n$$\n我们现在求解 $\\overline{T}$。整理各项：\n$$\n\\beta \\left(\\overline{T} - T^\\star\\right) + \\alpha \\left(\\overline{T} - T_s\\right) = 0\n$$\n代入 $T_s = T^\\star + \\delta$：\n$$\n\\beta \\left(\\overline{T} - T^\\star\\right) + \\alpha \\left(\\overline{T} - (T^\\star + \\delta)\\right) = 0\n$$\n我们可以将涉及漂移 $\\overline{T} - T^\\star$ 的项组合在一起：\n$$\n\\beta \\left(\\overline{T} - T^\\star\\right) + \\alpha \\left(\\left(\\overline{T} - T^\\star\\right) - \\delta\\right) = 0\n$$\n$$\n(\\alpha + \\beta)\\left(\\overline{T} - T^\\star\\right) - \\alpha\\delta = 0\n$$\n这直接得出了平稳气候平均漂移的表达式：\n$$\n\\overline{T} - T^\\star = \\frac{\\alpha \\delta}{\\alpha + \\beta}\n$$\n这个结果是逼近引入偏差的理论预测。它证实了偏差取决于逼近强度 $\\alpha$ 与总弛豫率 $\\alpha + \\beta$ 的比值，并按目标指定错误 $\\delta$ 进行缩放。值得注意的是，该偏差与随机强迫振幅 $D$ 无关。\n\n任务的第二部分是基于此推导实现一个诊断检验。该检验在两个条件同时满足时，判定“存在逼近引入的偏差”：\n1. 偏差的因果因素存在：逼近必须是活动的（$\\alpha  0$）且目标必须是不正确的（$\\delta \\neq 0$，或 $|\\delta|  0$）。\n2. 观测到的效应与理论预测一致。我们对系统进行长时间 $L$ 的模拟，计算模拟后半段的样本平均温度 $\\overline{T}_{\\text{obs}}$，并计算观测到的漂移 $\\overline{T}_{\\text{obs}} - T^\\star$。这个观测到的漂移必须接近理论漂移 $\\frac{\\alpha \\delta}{\\alpha + \\beta}$。“接近度”的标准是一个定义的容差：\n$$\n\\left| (\\overline{T}_{\\text{obs}} - T^\\star) - \\left(\\frac{\\alpha \\delta}{\\alpha + \\beta}\\right) \\right| \\le \\tau\n$$\n其中容差 $\\tau$ 由 $\\tau = \\tau_{\\text{abs}} + \\tau_{\\text{rel}} \\left| \\frac{\\alpha \\delta}{\\alpha + \\beta} \\right|$ 给出，$\\tau_{\\text{abs}} = 0.1 \\mathrm{K}$，$\\tau_{\\text{rel}} = 0.05$。\n\n数值实现将包含一个针对每个时间步的循环，应用欧拉-丸山更新规则。在整个积分周期 $L$ 结束后，将计算从时间 $L/2$ 到 $L$ 的温度值的平均值，以得到 $\\overline{T}_{\\text{obs}}$。最后，将对诊断规则的两个条件进行评估，为每个测试用例生成一个布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation_and_diagnose(alpha, beta, delta, D, dt, L, T_star):\n    \"\"\"\n    Simulates the stochastic temperature model and applies the diagnostic rule for bias.\n\n    Args:\n        alpha (float): Nudging coefficient (day^-1).\n        beta (float): Physical relaxation rate (day^-1).\n        delta (float): Target mis-specification (K).\n        D (float): Diffusion parameter (K^2 day^-1).\n        dt (float): Time step (day).\n        L (float): Total integration length (day).\n        T_star (float): True climatological equilibrium (K).\n\n    Returns:\n        bool: True if nudging-induced bias is present, False otherwise.\n    \"\"\"\n    # --- 1. Analytical Derivation ---\n    # The sum of rates alpha + beta cannot be zero, which is ensured by problem constraints (beta > 0).\n    if alpha + beta == 0:\n        # This case is not expected based on the problem's physics.\n        # If both are zero, there is no relaxation and drift is ill-defined.\n        theoretical_drift = 0.0\n    else:\n        theoretical_drift = (alpha * delta) / (alpha + beta)\n\n    # --- 2. Diagnostic Rule: Condition 1 (Causal Factors) ---\n    cond1 = (alpha > 0 and abs(delta) > 0)\n\n    # If causal factors are not present, no nudging-induced bias by definition.\n    # The full simulation can be skipped if only the final boolean is needed.\n    # However, running the simulation is useful for verification.\n    # We will proceed with the simulation for all cases.\n\n    # --- 3. Numerical Simulation (Euler-Maruyama) ---\n    num_steps = int(L / dt)\n    T = np.zeros(num_steps + 1)\n    T[0] = T_star  # Initial condition\n\n    T_s = T_star + delta  # Biased nudging target\n\n    # Generate all random numbers at once for efficiency\n    xi = np.random.randn(num_steps)\n\n    for n in range(num_steps):\n        # Deterministic tendency (drift term)\n        physical_tendency = -beta * (T[n] - T_star)\n        nudging_tendency = -alpha * (T[n] - T_s)\n        deterministic_term = (physical_tendency + nudging_tendency) * dt\n\n        # Stochastic tendency (diffusion term)\n        stochastic_term = np.sqrt(2 * D * dt) * xi[n]\n\n        # Update temperature\n        T[n+1] = T[n] + deterministic_term + stochastic_term\n\n    # --- 4. Calculate Observed Drift ---\n    # Analyze the last half of the trajectory for stationary statistics\n    start_index = num_steps // 2\n    T_mean_observed = np.mean(T[start_index:])\n    observed_drift = T_mean_observed - T_star\n\n    # --- 5. Diagnostic Rule: Condition 2 (Consistency Check) ---\n    abs_tolerance = 0.1  # K\n    rel_tolerance = 0.05  # dimensionless\n    tolerance = abs_tolerance + rel_tolerance * abs(theoretical_drift)\n    \n    deviation = abs(observed_drift - theoretical_drift)\n    cond2 = deviation = tolerance\n    \n    # --- 6. Final Decision ---\n    # Bias is present if and only if both conditions are met.\n    is_bias_present = cond1 and cond2\n    \n    return is_bias_present\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Set a seed for reproducibility of the stochastic simulation\n    np.random.seed(42)\n\n    # Test cases from the problem statement:\n    # (alpha, beta, delta, D, dt, L, T_star)\n    test_cases = [\n        (0.0, 0.1, 2.0, 1.0, 0.05, 20000, 288.0),   # Case 1: No nudging\n        (0.05, 0.1, 2.0, 1.0, 0.05, 20000, 288.0),  # Case 2: Modest nudging, positive delta\n        (0.2, 0.1, -1.0, 1.0, 0.05, 20000, 288.0), # Case 3: Stronger nudging, negative delta\n        (1.0, 0.1, 0.0, 1.0, 0.05, 20000, 288.0),   # Case 4: No mis-specification\n        (2.0, 0.05, 1.5, 1.0, 0.05, 20000, 288.0)   # Case 5: Very strong nudging\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation_and_diagnose(*params)\n        results.append(result)\n\n    # Format the output as a comma-separated list of booleans inside brackets.\n    # Using .lower() to match a common convention for boolean string representation.\n    output_str = f\"[{','.join(map(lambda b: str(b).lower(), results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}