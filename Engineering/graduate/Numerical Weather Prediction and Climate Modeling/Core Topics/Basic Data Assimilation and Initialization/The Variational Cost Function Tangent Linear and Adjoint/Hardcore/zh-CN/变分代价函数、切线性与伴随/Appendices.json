{
    "hands_on_practices": [
        {
            "introduction": "在变分数据同化中，伴随模式是计算代价函数梯度的核心工具。然而，伴随模式的推导和代码实现过程复杂且容易出错。因此，在将其用于优化之前，一个严格的验证步骤是必不可少的。本练习将引导您完成“点积测试”，这是验证离散切线性模式和伴随模式正确性的黄金标准。通过一个简化的辐射传输模型，您将亲手实现这一关键的质量控制检查，确保所编写的伴随算子确实是切线性算子的精确转置（在给定内积下），即满足离散伴随一致性 。",
            "id": "4103767",
            "problem": "构建一个自包含的程序，为一个离散的切线性（TL）和伴随（ADJ）对执行点积测试。该算子对源于比尔-朗伯定律下的一个简化的$2$层、平面平行、非散射、上行辐射传输算子。在欧几里得内积下进行运算，并验证离散伴随一致性。程序必须从第一性原理实现以下内容。\n\n基本基态与正向算子：使用比尔-朗伯定律计算透过率，并对层发射进行线性叠加。考虑$2$个堆叠在发射表面之上的均匀层。设状态向量为 $x = [\\tau_1,\\tau_2,S_1,S_2]^\\top$，其中 $\\tau_1$ 和 $\\tau_2$ 分别是下层和上层的非负光学厚度，而 $S_1$ 和 $S_2$ 是它们对应的层源项（辐射率）。设 $E$ 表示地表发射（辐射率）。对于一组由 $k$ 索引的观测方向余弦 $\\mu_k \\in (0,1]$，定义透过率 $T_{1,k} = \\exp(-\\tau_1/\\mu_k)$ 和 $T_{2,k} = \\exp(-\\tau_2/\\mu_k)$。正向算子 $F: \\mathbb{R}^4 \\to \\mathbb{R}^K$ 将状态映射到大气层顶上行辐射率向量 $L \\in \\mathbb{R}^K$，其分量为\n$$\nL_k(x) = T_{1,k} T_{2,k} E + T_{1,k} \\left(1 - T_{2,k}\\right) S_2 + \\left(1 - T_{1,k}\\right) S_1,\\quad k=1,\\dots,K.\n$$\n\n切线性（TL）和伴随（ADJ）：在基态 $x_0$ 处的切线性算子是对于一个扰动 $\\delta x \\in \\mathbb{R}^4$ 的雅可比作用 $J(x_0)\\,\\delta x$。伴随算子是在欧几里得内积下，对于 $y \\in \\mathbb{R}^K$ 的转置作用 $J(x_0)^\\top\\,y$。离散伴随一致性要求\n$$\n\\langle J(x_0)\\,\\delta x,\\; y \\rangle = \\langle \\delta x,\\; J(x_0)^\\top\\,y \\rangle\n$$\n对于所有 $\\delta x \\in \\mathbb{R}^4$ 和 $y \\in \\mathbb{R}^K$ 成立，其中 $\\langle \\cdot,\\cdot\\rangle$ 表示标准的欧几里得内积。您必须从上述正向算子推导并实现解析的TL和ADJ对。\n\n数值点积测试：对于每个测试案例，计算标量值\n$$\n\\text{lhs} = \\langle J(x_0)\\,\\delta x,\\; y \\rangle,\\quad\n\\text{rhs} = \\langle \\delta x,\\; J(x_0)^\\top\\,y \\rangle,\n$$\n然后报告相对差异\n$$\n\\varepsilon = \\frac{\\left|\\text{lhs} - \\text{rhs}\\right|}{\\max\\left(1,\\left|\\text{lhs}\\right|,\\left|\\text{rhs}\\right|\\right)}.\n$$\n每个报告的 $\\varepsilon$ 是无单位的，并且必须表示为浮点值。\n\n角度和单位约定：直接使用方向余弦 $\\mu_k$（没有提供角度，因此不需要角度单位规范）。辐射率 $\\left(S_1,S_2,E\\right)$ 和正向算子输出 $L_k$ 具有一致的辐射率单位，但只需要输出无单位的相对差异 $\\varepsilon$。\n\n测试套件：为以下参数集实现点积测试，每个参数集定义了基态 $x_0$、地表发射 $E$、观测方向余弦 $\\{\\mu_k\\}_{k=1}^K$、一个扰动 $\\delta x$ 和一个观测空间中的权重向量 $y$。\n\n- 案例 $1$ (常规情况):\n  - $x_0 = [\\tau_1,\\tau_2,S_1,S_2] = [0.7, 1.3, 260.0, 280.0]$\n  - $E = 300.0$\n  - $\\mu = [1.0, 0.8, 0.5]$\n  - $\\delta x = [0.01, -0.02, 1.5, -0.5]$\n  - $y = [0.7, -1.2, 0.3]$\n- 案例 $2$ (近透明层):\n  - $x_0 = [1\\times 10^{-4}, 2\\times 10^{-4}, 250.0, 250.0]$\n  - $E = 250.0$\n  - $\\mu = [1.0]$\n  - $\\delta x = [1\\times 10^{-6}, -2\\times 10^{-6}, 0.1, -0.1]$\n  - $y = [2.0]$\n- 案例 $3$ (不透明层和斜视):\n  - $x_0 = [10.0, 12.0, 280.0, 290.0]$\n  - $E = 300.0$\n  - $\\mu = [0.2, 0.1]$\n  - $\\delta x = [-0.05, 0.04, -1.0, 2.0]$\n  - $y = [1.0, -0.5]$\n- 案例 $4$ (零扰动边界情况):\n  - $x_0 = [0.7, 1.3, 260.0, 280.0]$\n  - $E = 290.0$\n  - $\\mu = [0.3, 0.6, 1.0]$\n  - $\\delta x = [0.0, 0.0, 0.0, 0.0]$\n  - $y = [0.3, 0.4, -0.1]$\n- 案例 $5$ (零观测权重边界情况):\n  - $x_0 = [0.9, 0.4, 265.0, 275.0]$\n  - $E = 285.0$\n  - $\\mu = [0.9, 0.7, 0.4, 0.2]$\n  - $\\delta x = [0.03, 0.02, -3.0, 1.0]$\n  - $y = [0.0, 0.0, 0.0, 0.0]$\n\n程序要求和输出规范：\n- 在每个测试案例的基态 $x_0$ 处，根据正向算子解析地实现TL和ADJ算子。\n- 对每个案例，计算并收集上面定义的无单位相对差异 $\\varepsilon$ 作为浮点值。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中 $r_i$ 对应于所列顺序中的案例 $i$。\n- 程序必须是自包含的，不需要任何输入，并完全按照上述规定使用确定性值。",
            "solution": "我们从比尔-朗伯定律和线性发射叠加出发，为给定的$2$层上行辐射传输算子推导切线性（TL）和伴随（ADJ）算子。设状态为 $x = [\\tau_1,\\tau_2,S_1,S_2]^\\top$，地表发射为 $E$，观测方向余弦为 $\\{\\mu_k\\}_{k=1}^K$ 且 $\\mu_k \\in (0,1]$。定义透过率 $T_{1,k} = \\exp(-\\tau_1/\\mu_k)$ 和 $T_{2,k} = \\exp(-\\tau_2/\\mu_k)$。正向映射 $F:\\mathbb{R}^4 \\to \\mathbb{R}^K$ 的分量形式为\n$$\nL_k(x) = T_{1,k} T_{2,k} E + T_{1,k} \\left(1 - T_{2,k}\\right) S_2 + \\left(1 - T_{1,k}\\right) S_1.\n$$\n此构建使用了比尔-朗伯定律，该定律指出，沿着方向余弦为 $\\mu_k$ 的路径，通过光学厚度为 $\\tau$ 的层的透过率为 $\\exp(-\\tau/\\mu_k)$，并假设各向同性的层发射可线性相加，并被上覆层的透过率衰减。\n\n为构建切线性算子，我们计算在基态 $x_0$ 处的雅可比矩阵 $\\partial L_k/\\partial x_j$。令 $a_k \\equiv 1/\\mu_k$ 并将在 $x_0$ 处计算的 $T_{1,k} \\equiv \\exp(-\\tau_1 a_k)$ 和 $T_{2,k} \\equiv \\exp(-\\tau_2 a_k)$ 简记。$L_k$ 相对于状态分量的偏导数为\n$$\n\\frac{\\partial L_k}{\\partial S_1} = 1 - T_{1,k},\n\\quad\n\\frac{\\partial L_k}{\\partial S_2} = T_{1,k}\\left(1 - T_{2,k}\\right),\n$$\n并使用 $\\frac{\\partial T_{1,k}}{\\partial \\tau_1} = -a_k T_{1,k}$ 和 $\\frac{\\partial T_{2,k}}{\\partial \\tau_2} = -a_k T_{2,k}$，\n$$\n\\frac{\\partial L_k}{\\partial \\tau_1}\n= \\frac{\\partial T_{1,k}}{\\partial \\tau_1}\\,T_{2,k} E + \\frac{\\partial T_{1,k}}{\\partial \\tau_1}\\,\\left(1 - T_{2,k}\\right) S_2 - \\frac{\\partial T_{1,k}}{\\partial \\tau_1}\\,S_1\n= -a_k T_{1,k} T_{2,k} E - a_k T_{1,k}\\left(1 - T_{2,k}\\right) S_2 + a_k T_{1,k} S_1,\n$$\n$$\n\\frac{\\partial L_k}{\\partial \\tau_2}\n= T_{1,k}\\frac{\\partial T_{2,k}}{\\partial \\tau_2} E + T_{1,k}\\left(-\\frac{\\partial T_{2,k}}{\\partial \\tau_2}\\right) S_2\n= -a_k T_{1,k} T_{2,k} E + a_k T_{1,k} T_{2,k} S_2\n= a_k T_{1,k} T_{2,k}\\left(-E + S_2\\right).\n$$\n将这些偏导数收集到雅可比矩阵 $J \\in \\mathbb{R}^{K \\times 4}$ 中，其列对应于 $[\\tau_1,\\tau_2,S_1,S_2]$。对于一个扰动 $\\delta x = [\\delta \\tau_1,\\delta \\tau_2,\\delta S_1,\\delta S_2]^\\top$，TL作用是矩阵向量乘积\n$$\n\\left(J\\,\\delta x\\right)_k\n= \\frac{\\partial L_k}{\\partial \\tau_1}\\,\\delta \\tau_1\n+ \\frac{\\partial L_k}{\\partial \\tau_2}\\,\\delta \\tau_2\n+ \\frac{\\partial L_k}{\\partial S_1}\\,\\delta S_1\n+ \\frac{\\partial L_k}{\\partial S_2}\\,\\delta S_2.\n$$\n\n在欧几里得内积 $\\langle u,v\\rangle = \\sum_{i} u_i v_i$ 下，伴随算子是转置 $J^\\top$。对于任何 $y \\in \\mathbb{R}^K$，\n$$\n\\left(J^\\top y\\right)_1 = \\sum_{k=1}^K y_k \\frac{\\partial L_k}{\\partial \\tau_1},\\quad\n\\left(J^\\top y\\right)_2 = \\sum_{k=1}^K y_k \\frac{\\partial L_k}{\\partial \\tau_2},\\quad\n\\left(J^\\top y\\right)_3 = \\sum_{k=1}^K y_k \\frac{\\partial L_k}{\\partial S_1},\\quad\n\\left(J^\\top y\\right)_4 = \\sum_{k=1}^K y_k \\frac{\\partial L_k}{\\partial S_2}.\n$$\n根据欧几里得内积下矩阵转置的构造，我们得到离散伴随恒等式\n$$\n\\langle J\\,\\delta x,\\; y\\rangle = \\langle \\delta x,\\; J^\\top y\\rangle\n$$\n对于所有 $\\delta x$ 和 $y$ 均成立。我们的数值点积测试通过计算来评估此恒等式\n$$\n\\text{lhs} = \\sum_{k=1}^K \\left(J\\,\\delta x\\right)_k\\, y_k,\\quad\n\\text{rhs} = \\sum_{j=1}^4 \\delta x_j \\left(J^\\top y\\right)_j,\n$$\n以及无单位的相对差异\n$$\n\\varepsilon = \\frac{\\left|\\text{lhs} - \\text{rhs}\\right|}{\\max\\left(1,\\left|\\text{lhs}\\right|,\\left|\\text{rhs}\\right|\\right)}.\n$$\n\n算法设计：\n- 对于每个测试案例，在 $x_0$ 处计算 $T_{1,k}$ 和 $T_{2,k}$，并如上计算偏导数 $\\partial L_k/\\partial x_j$ (其中 $j \\in \\{1,2,3,4\\}$)。\n- 通过使用 $\\delta x$ 的分量对各列进行加权求和，计算TL作用 $J\\,\\delta x$。\n- 通过计算每个导数向量列与 $y$ 的内积，计算ADJ作用 $J^\\top y$。\n- 使用欧几里得内积构成 $\\text{lhs}$ 和 $\\text{rhs}$，并使用提供的归一化方法报告 $\\varepsilon$，以在不同尺度上保持稳健，包括其中一个向量为零向量的边界情况。\n- 对所有指定案例重复此过程，并在单行上输出列表 $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5]$。\n\n由于TL和ADJ是根据光滑有限维算子的精确解析导数，在双精度算术下实现的，因此差异 $\\varepsilon$ 应在浮点舍入误差的量级（通常接近 $10^{-15}$ 到 $10^{-16}$），对于扰动或观测权重为零向量的退化情况，根据归一化的构造，差异应精确为零。",
            "answer": "```python\nimport numpy as np\n\ndef perform_dot_product_test(case):\n    \"\"\"\n    Performs the dot product test for a single case.\n    \"\"\"\n    tau1, tau2, S1, S2 = case[\"x0\"]\n    E = case[\"E\"]\n    mu = np.array(case[\"mu\"])\n    d_x = np.array(case[\"dx\"])\n    y = np.array(case[\"y\"])\n    \n    K = len(mu)\n    # Jacobian matrix J of size K x 4\n    J = np.zeros((K, 4))\n    \n    # Pre-compute terms\n    a = 1.0 / mu\n    T1 = np.exp(-tau1 * a)\n    T2 = np.exp(-tau2 * a)\n    \n    # Populate the Jacobian matrix with partial derivatives\n    # Column 0: dL/d(tau1)\n    J[:, 0] = -a * T1 * T2 * E - a * T1 * (1 - T2) * S2 + a * T1 * S1\n    # Column 1: dL/d(tau2)\n    J[:, 1] = a * T1 * T2 * (S2 - E)\n    # Column 2: dL/d(S1)\n    J[:, 2] = 1 - T1\n    # Column 3: dL/d(S2)\n    J[:, 3] = T1 * (1 - T2)\n    \n    # Tangent-linear action: J * dx\n    tl_output = J @ d_x\n    \n    # Adjoint action: J^T * y\n    adj_output = J.T @ y\n    \n    # Compute the two sides of the dot product identity\n    lhs = np.dot(tl_output, y)\n    rhs = np.dot(d_x, adj_output)\n    \n    # Calculate relative difference\n    diff = np.abs(lhs - rhs)\n    norm = np.max([1.0, np.abs(lhs), np.abs(rhs)])\n    epsilon = diff / norm\n    \n    return epsilon\n\ndef solve_all_cases():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (Regular)\n        {\"x0\": [0.7, 1.3, 260.0, 280.0], \"E\": 300.0, \"mu\": [1.0, 0.8, 0.5], \"dx\": [0.01, -0.02, 1.5, -0.5], \"y\": [0.7, -1.2, 0.3]},\n        # Case 2 (Near-transparent)\n        {\"x0\": [1e-4, 2e-4, 250.0, 250.0], \"E\": 250.0, \"mu\": [1.0], \"dx\": [1e-6, -2e-6, 0.1, -0.1], \"y\": [2.0]},\n        # Case 3 (Opaque)\n        {\"x0\": [10.0, 12.0, 280.0, 290.0], \"E\": 300.0, \"mu\": [0.2, 0.1], \"dx\": [-0.05, 0.04, -1.0, 2.0], \"y\": [1.0, -0.5]},\n        # Case 4 (Zero perturbation)\n        {\"x0\": [0.7, 1.3, 260.0, 280.0], \"E\": 290.0, \"mu\": [0.3, 0.6, 1.0], \"dx\": [0.0, 0.0, 0.0, 0.0], \"y\": [0.3, 0.4, -0.1]},\n        # Case 5 (Zero observation weight)\n        {\"x0\": [0.9, 0.4, 265.0, 275.0], \"E\": 285.0, \"mu\": [0.9, 0.7, 0.4, 0.2], \"dx\": [0.03, 0.02, -3.0, 1.0], \"y\": [0.0, 0.0, 0.0, 0.0]}\n    ]\n    \n    results = [perform_dot_product_test(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve_all_cases()\n```"
        },
        {
            "introduction": "梯度（通过伴随模式计算）为我们指明了代价函数下降最快的方向，但要实现高效的优化并进行不确定性量化，理解代价函数的曲率至关重要。Hessian 矩阵精确地描述了这种曲率。本练习将通过一个具体的计算任务，演示如何利用切线性算子及其伴随算子作为基本构件，来构建代价函数 Hessian 矩阵的高斯-牛顿近似 。这不仅是许多高级优化算法（如牛顿法）的基础，也是评估分析误差协方差的关键。",
            "id": "4103712",
            "problem": "考虑在数值天气预报 (NWP) 和气候模拟中使用的标准变分资料同化代价函数，该函数用于四维变分 (4D-Var) 问题。此函数定义在状态向量 $\\mathbf{x} \\in \\mathbb{R}^{n}$ 和观测向量 $\\mathbf{y} \\in \\mathbb{R}^{m}$ 上，其中 $\\mathbf{B} \\in \\mathbb{R}^{n \\times n}$ 为正定背景误差协方差矩阵，$\\mathbf{R} \\in \\mathbb{R}^{m \\times m}$ 为正定观测误差协方差矩阵，$\\mathbf{H} : \\mathbb{R}^{n} \\to \\mathbb{R}^{m}$ 为可微观测算子。设迭代点为 $\\mathbf{x}^{k}$。在 $\\mathbf{x}^{k}$ 处的切线性算子是雅可比矩阵 $\\mathbf{H}'(\\mathbf{x}^{k})$，其伴随为 $\\mathbf{H}'(\\mathbf{x}^{k})^{T}$。\n\n从上述定义和基本的多变量微积分（泰勒展开和链式法则）出发，推导在 $\\mathbf{x}^{k}$ 处求值的代价函数的海森矩阵的 Gauss–Newton 近似，并用包含切线性算子及其伴随的背景项和观测项来表示它。\n\n然后，在以下具体的、量纲一致的情况下计算该表达式：\n- 状态维数 $n=2$，观测维数 $m=2$。\n- 背景误差协方差为 $\\mathbf{B} = \\mathrm{diag}(2,\\,1)$。\n- 观测误差协方差为 $\\mathbf{R} = \\mathrm{diag}\\!\\left(\\frac{1}{4},\\,1\\right)$。\n- 观测算子为 $\\mathbf{H}(\\mathbf{x}) = \\begin{pmatrix} x_{1}^{2} + x_{2} \\\\ \\sin(x_{1}) + x_{2} \\end{pmatrix}$。\n- 迭代点为 $\\mathbf{x}^{k} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n\n计算此情况下在 $\\mathbf{x}^{k}$ 处的海森矩阵的 Gauss–Newton 近似，并给出显式矩阵。如果出现三角函数项，请保留其精确形式。无需四舍五入。最终答案以无单位矩阵的形式表示。",
            "solution": "四维变分 (4D-Var) 代价函数定义为\n$$\nJ(\\mathbf{x}) = \\frac{1}{2}\\,(\\mathbf{x} - \\mathbf{x}_{b})^{T}\\,\\mathbf{B}^{-1}\\,(\\mathbf{x} - \\mathbf{x}_{b}) + \\frac{1}{2}\\,\\big(\\mathbf{H}(\\mathbf{x}) - \\mathbf{y}\\big)^{T}\\,\\mathbf{R}^{-1}\\,\\big(\\mathbf{H}(\\mathbf{x}) - \\mathbf{y}\\big),\n$$\n其中 $\\mathbf{x}_{b}$ 是背景（先验）状态。\n\n根据多变量微积分，$J$ 关于 $\\mathbf{x}$ 的梯度可通过对每一项求导得到。背景项是二次的，因此其贡献为\n$$\n\\nabla_{\\mathbf{x}} \\left[ \\frac{1}{2}\\,(\\mathbf{x} - \\mathbf{x}_{b})^{T}\\,\\mathbf{B}^{-1}\\,(\\mathbf{x} - \\mathbf{x}_{b}) \\right] = \\mathbf{B}^{-1}\\,(\\mathbf{x} - \\mathbf{x}_{b}).\n$$\n对于观测项，应用链式法则。令 $\\mathbf{d}(\\mathbf{x}) \\equiv \\mathbf{H}(\\mathbf{x}) - \\mathbf{y}$。则\n$$\n\\nabla_{\\mathbf{x}} \\left[ \\frac{1}{2}\\,\\mathbf{d}(\\mathbf{x})^{T}\\,\\mathbf{R}^{-1}\\,\\mathbf{d}(\\mathbf{x}) \\right] = \\mathbf{H}'(\\mathbf{x})^{T}\\,\\mathbf{R}^{-1}\\,\\mathbf{d}(\\mathbf{x}),\n$$\n其中 $\\mathbf{H}'(\\mathbf{x})$ 是在 $\\mathbf{x}$ 处求值的 $\\mathbf{H}$ 的雅可比矩阵（切线性算子），而 $\\mathbf{H}'(\\mathbf{x})^{T}$ 是其伴随。\n\n因此，梯度为\n$$\n\\nabla J(\\mathbf{x}) = \\mathbf{B}^{-1}\\,(\\mathbf{x} - \\mathbf{x}_{b}) + \\mathbf{H}'(\\mathbf{x})^{T}\\,\\mathbf{R}^{-1}\\,\\big(\\mathbf{H}(\\mathbf{x}) - \\mathbf{y}\\big).\n$$\n\n为得到海森矩阵，对梯度关于 $\\mathbf{x}$ 求导。背景项的海森矩阵即为\n$$\n\\nabla^{2}\\left[ \\frac{1}{2}\\,(\\mathbf{x} - \\mathbf{x}_{b})^{T}\\,\\mathbf{B}^{-1}\\,(\\mathbf{x} - \\mathbf{x}_{b}) \\right] = \\mathbf{B}^{-1}.\n$$\n对于观测项，对 $\\mathbf{H}'(\\mathbf{x})^{T}\\,\\mathbf{R}^{-1}\\,\\big(\\mathbf{H}(\\mathbf{x}) - \\mathbf{y}\\big)$ 求导。使用雅可比矩阵的乘积法则和链式法则，\n$$\n\\nabla_{\\mathbf{x}}\\left[ \\mathbf{H}'(\\mathbf{x})^{T}\\,\\mathbf{R}^{-1}\\,\\big(\\mathbf{H}(\\mathbf{x}) - \\mathbf{y}\\big) \\right]\n= \\mathbf{H}'(\\mathbf{x})^{T}\\,\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}) + \\sum_{i=1}^{m} \\left[ \\nabla^{2} H_{i}(\\mathbf{x}) \\right]\\,\\big(\\mathbf{R}^{-1}\\,\\mathbf{d}(\\mathbf{x})\\big)_{i},\n$$\n其中 $\\nabla^{2} H_{i}(\\mathbf{x})$ 表示标量函数 $H_{i}(\\mathbf{x})$ 的海森矩阵，$(\\cdot)_{i}$ 表示第 $i$ 个分量。第一项\n$$\n\\mathbf{H}'(\\mathbf{x})^{T}\\,\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}),\n$$\n来自对残差内的 $\\mathbf{H}(\\mathbf{x})$ 求导，而第二项汇集了由残差和 $\\mathbf{R}^{-1}$ 加权的 $\\mathbf{H}$ 的二阶导数。\n\n海森矩阵的 Gauss–Newton 近似忽略了包含 $\\nabla^{2} H_{i}(\\mathbf{x})$ 和残差的二阶项。当接近解时，残差很小，这样做是合理的，并且这是非线性最小二乘和变分资料同化中的标准近似。因此，在 $\\mathbf{x}^{k}$ 处，Gauss–Newton 海森矩阵为\n$$\n\\mathbf{G}(\\mathbf{x}^{k}) \\approx \\mathbf{B}^{-1} + \\mathbf{H}'(\\mathbf{x}^{k})^{T}\\,\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}^{k}).\n$$\n\n我们现在针对指定情况计算该表达式。给定的矩阵是\n$$\n\\mathbf{B} = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}, \\quad \\mathbf{R} = \\begin{pmatrix} \\frac{1}{4}  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n因此，\n$$\n\\mathbf{B}^{-1} = \\begin{pmatrix} \\frac{1}{2}  0 \\\\ 0  1 \\end{pmatrix}, \\quad \\mathbf{R}^{-1} = \\begin{pmatrix} 4  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n\n观测算子是\n$$\n\\mathbf{H}(\\mathbf{x}) = \\begin{pmatrix} H_{1}(\\mathbf{x}) \\\\ H_{2}(\\mathbf{x}) \\end{pmatrix} = \\begin{pmatrix} x_{1}^{2} + x_{2} \\\\ \\sin(x_{1}) + x_{2} \\end{pmatrix}.\n$$\n其雅可比矩阵（切线性）是\n$$\n\\mathbf{H}'(\\mathbf{x}) = \\begin{pmatrix}\n\\frac{\\partial H_{1}}{\\partial x_{1}}  \\frac{\\partial H_{1}}{\\partial x_{2}} \\\\\n\\frac{\\partial H_{2}}{\\partial x_{1}}  \\frac{\\partial H_{2}}{\\partial x_{2}}\n\\end{pmatrix}\n= \\begin{pmatrix}\n2 x_{1}  1 \\\\\n\\cos(x_{1})  1\n\\end{pmatrix}.\n$$\n在迭代点 $\\mathbf{x}^{k} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$ 处，这变为\n$$\n\\mathbf{H}'(\\mathbf{x}^{k}) = \\begin{pmatrix} 2  1 \\\\ \\cos(1)  1 \\end{pmatrix}.\n$$\n\n计算 $\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}^{k})$：\n$$\n\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}^{k}) = \n\\begin{pmatrix} 4  0 \\\\ 0  1 \\end{pmatrix}\n\\begin{pmatrix} 2  1 \\\\ \\cos(1)  1 \\end{pmatrix}\n=\n\\begin{pmatrix} 8  4 \\\\ \\cos(1)  1 \\end{pmatrix}.\n$$\n然后\n$$\n\\mathbf{H}'(\\mathbf{x}^{k})^{T}\\,\\big(\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}^{k})\\big) =\n\\begin{pmatrix} 2  \\cos(1) \\\\ 1  1 \\end{pmatrix}\n\\begin{pmatrix} 8  4 \\\\ \\cos(1)  1 \\end{pmatrix}\n=\n\\begin{pmatrix}\n16 + \\cos^{2}(1)  8 + \\cos(1) \\\\\n8 + \\cos(1)  5\n\\end{pmatrix}.\n$$\n\n最后，加上 $\\mathbf{B}^{-1}$：\n$$\n\\mathbf{G}(\\mathbf{x}^{k}) \\approx \\mathbf{B}^{-1} + \\mathbf{H}'(\\mathbf{x}^{k})^{T}\\,\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}^{k})\n=\n\\begin{pmatrix} \\frac{1}{2}  0 \\\\ 0  1 \\end{pmatrix}\n+\n\\begin{pmatrix}\n16 + \\cos^{2}(1)  8 + \\cos(1) \\\\\n8 + \\cos(1)  5\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{33}{2} + \\cos^{2}(1)  8 + \\cos(1) \\\\\n8 + \\cos(1)  6\n\\end{pmatrix}.\n$$\n\n该矩阵是在给定迭代点处变分代价函数的海森矩阵的 Gauss–Newton 近似，它明确地展示了分解为背景项 $\\mathbf{B}^{-1}$ 和包含切线性算子及其伴随的观测项 $\\mathbf{H}'(\\mathbf{x}^{k})^{T}\\,\\mathbf{R}^{-1}\\,\\mathbf{H}'(\\mathbf{x}^{k})$。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{33}{2}+\\cos^{2}(1)  8+\\cos(1) \\\\ 8+\\cos(1)  6\\end{pmatrix}}$$"
        },
        {
            "introduction": "变分框架的强大之处不仅在于估计系统的状态，还在于估计模型中未知的物理参数。本练习将探讨如何将切线性和伴随模式的工具箱应用于参数估计问题。您将学习如何构建费雪信息矩阵（Fisher Information Matrix），该矩阵直接关联了参数的微小变化与观测值的响应。通过分析这个矩阵，我们可以评估哪些参数能够被现有观测可靠地识别出来，并量化这些参数估计值的后验不确定性，从而将数据同化技术从状态估计扩展到更广泛的科学发现和模型改进中 。",
            "id": "4103682",
            "problem": "给定一个适用于数值天气预报和气候模拟的线性化数据同化设置，其中未知模型参数通过变分框架从含噪声的观测中推断得出。设参数向量为 $\\boldsymbol{\\theta} \\in \\mathbb{R}^n$，观测算子为 $\\boldsymbol{h}(\\cdot)$（将模型状态映射到观测空间），可用观测为 $\\boldsymbol{y} \\in \\mathbb{R}^m$，观测误差协方差为 $\\boldsymbol{R} \\in \\mathbb{R}^{m \\times m}$，背景（先验）均值为 $\\boldsymbol{\\theta}_b \\in \\mathbb{R}^n$，先验协方差为 $\\boldsymbol{B} \\in \\mathbb{R}^{n \\times n}$。标准的变分代价函数为\n$$\nJ(\\boldsymbol{\\theta}) = \\frac{1}{2}\\left(\\boldsymbol{h}(\\boldsymbol{s}(\\boldsymbol{\\theta})) - \\boldsymbol{y}\\right)^\\top \\boldsymbol{R}^{-1} \\left(\\boldsymbol{h}(\\boldsymbol{s}(\\boldsymbol{\\theta})) - \\boldsymbol{y}\\right) + \\frac{1}{2}\\left(\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_b\\right)^\\top \\boldsymbol{B}^{-1}\\left(\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_b\\right),\n$$\n其中 $\\boldsymbol{s}(\\boldsymbol{\\theta})$ 表示由 $\\boldsymbol{\\theta}$ 导出的模型状态。在一个线性化点 $\\boldsymbol{\\theta}_0$ 附近，映射 $\\boldsymbol{\\theta} \\mapsto \\boldsymbol{h}(\\boldsymbol{s}(\\boldsymbol{\\theta}))$ 的切线性（TL）算子是满足以下条件的矩阵 $\\boldsymbol{G} \\in \\mathbb{R}^{m \\times n}$\n$$\n\\delta \\boldsymbol{y} \\approx \\boldsymbol{G}\\,\\delta \\boldsymbol{\\theta},\n$$\n其中 $\\delta \\boldsymbol{\\theta}$ 和 $\\delta \\boldsymbol{y}$ 是小扰动。伴随算子 $\\boldsymbol{G}^\\star$ 是通过以下性质相对于欧几里得内积定义的\n$$\n\\langle \\boldsymbol{G}\\,\\delta \\boldsymbol{\\theta},\\,\\delta \\boldsymbol{y} \\rangle = \\langle \\delta \\boldsymbol{\\theta},\\, \\boldsymbol{G}^\\star\\,\\delta \\boldsymbol{y} \\rangle\n$$\n对于所有的 $\\delta \\boldsymbol{\\theta} \\in \\mathbb{R}^n$ 和 $\\delta \\boldsymbol{y} \\in \\mathbb{R}^m$。\n\n从以上定义出发，并利用线性化和伴随关系，推导一个算法来：\n- 通过内积恒等式验证所提供的切线性和伴随输出的伴随一致性；\n- 根据切线性/伴随输出和观测误差协方差计算参数的费雪信息矩阵；\n- 通过费雪信息矩阵的秩相对于参数维度的关系来评估参数的可辨识性；\n- 通过从先验和费雪信息得到的后验协方差的对角线来量化参数不确定性。\n\n此问题不涉及物理单位；所有量均为无量纲。所有角度均不相关。您应将所有浮点数结果四舍五入至六位小数。程序必须只产生布尔值、整数和浮点数输出。\n\n为以下测试用例集实现您的算法。在每个案例中，您会获得切线性矩阵 $\\boldsymbol{G}^{(k)}$、伴随矩阵 $(\\boldsymbol{G}^{(k)})^\\star$（在欧几里得内积下，它与转置矩阵一致）、观测误差协方差的对角线元素（因此 $\\boldsymbol{R}^{(k)} = \\mathrm{diag}(\\cdot)$）以及先验协方差的对角线元素（因此 $\\boldsymbol{B}^{(k)} = \\mathrm{diag}(\\cdot)$）。对伴随一致性测试使用指定的随机种子。\n\n案例 $1$：\n- $\\boldsymbol{G}^{(1)} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\end{bmatrix}$，\n- $(\\boldsymbol{G}^{(1)})^\\star = \\left(\\boldsymbol{G}^{(1)}\\right)^\\top$，\n- $\\boldsymbol{R}^{(1)} = \\mathrm{diag}(0.25, 0.25, 1.0)$，\n- $\\boldsymbol{B}^{(1)} = \\mathrm{diag}(1.0, 1.0)$，\n- 随机种子 $0$。\n\n案例 $2$：\n- $\\boldsymbol{G}^{(2)} = \\begin{bmatrix} 1  1  0 \\\\ 0  1  1 \\end{bmatrix}$，\n- $(\\boldsymbol{G}^{(2)})^\\star = \\left(\\boldsymbol{G}^{(2)}\\right)^\\top$，\n- $\\boldsymbol{R}^{(2)} = \\mathrm{diag}(1.0, 1.0)$，\n- $\\boldsymbol{B}^{(2)} = \\mathrm{diag}(100.0, 100.0, 100.0)$，\n- 随机种子 $1$。\n\n案例 $3$：\n- $\\boldsymbol{G}^{(3)} = \\begin{bmatrix} 1.0  0.999  0.001 \\\\ 0.999  0.998  0.002 \\\\ 0.001  0.002  0.999 \\end{bmatrix}$，\n- $(\\boldsymbol{G}^{(3)})^\\star = \\left(\\boldsymbol{G}^{(3)}\\right)^\\top$，\n- $\\boldsymbol{R}^{(3)} = \\mathrm{diag}(0.1, 0.1, 10.0)$，\n- $\\boldsymbol{B}^{(3)} = \\mathrm{diag}(1.0, 1.0, 1.0)$，\n- 随机种子 $2$。\n\n对于每个案例 $k \\in \\{1,2,3\\}$，执行以下计算：\n- 通过检查\n$$\n\\left|\\langle \\boldsymbol{G}^{(k)}\\,\\delta \\boldsymbol{\\theta},\\,\\delta \\boldsymbol{y} \\rangle - \\langle \\delta \\boldsymbol{\\theta},\\,(\\boldsymbol{G}^{(k)})^\\star\\,\\delta \\boldsymbol{y} \\rangle\\right| \\le \\varepsilon\n$$\n是否在容差 $\\varepsilon = 10^{-10}$ 下成立来验证伴随恒等式，其中随机向量 $\\delta \\boldsymbol{\\theta}$ 和 $\\delta \\boldsymbol{y}$ 是使用指定的种子从标准正态分布生成。报告一个表示通过或失败的布尔值。\n- 根据切线性/伴随输出和 $\\boldsymbol{R}^{(k)}$ 计算费雪信息矩阵，然后计算其矩阵的秩以及相应的可辨识性布尔值，该布尔值指示是否所有参数都可辨识（即秩等于 $n$）。\n- 计算费雪信息矩阵的谱条件数（在 $2$-范数下）；如果矩阵是奇异的，则报告一个无穷大值。\n- 计算通过组合先验和费雪信息形成的后验协方差 $\\boldsymbol{\\Sigma}_{\\text{post}}^{(k)}$，并返回 $\\boldsymbol{\\Sigma}_{\\text{post}}^{(k)}$ 的对角线元素。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个案例的条目本身就是一个形如\n$$\n[\\text{adjoint\\_ok},\\ \\text{rank},\\ \\text{cond},\\ [\\text{var}_1,\\ \\ldots,\\ \\text{var}_n]],\n$$\n的列表，所有浮点值都四舍五入到六位小数（对于无穷大值，请使用该语言的默认浮点无穷大）。例如，输出应如下所示\n$$\n[[\\text{True},\\ 2,\\ 1.500000,\\ [0.187500,\\ 0.187500]],\\ \\ldots].\n$$",
            "solution": "此问题的算法基于贝叶斯推断和线性化分析，旨在量化从观测中估计模型参数的不确定性。\n\n**步骤 1：伴随一致性验证**\n伴随算子 $\\boldsymbol{G}^\\star$ 在欧几里得内积下的定义要求 $\\langle \\boldsymbol{G}\\,\\delta \\boldsymbol{\\theta},\\,\\delta \\boldsymbol{y} \\rangle = \\langle \\delta \\boldsymbol{\\theta},\\, \\boldsymbol{G}^\\star\\,\\delta \\boldsymbol{y} \\rangle$。对于实数矩阵，这等同于要求 $\\boldsymbol{G}^\\star = \\boldsymbol{G}^\\top$。数值验证通过生成随机向量 $\\delta \\boldsymbol{\\theta}$ 和 $\\delta \\boldsymbol{y}$，并计算上述等式两边的差值来完成。如果差的绝对值小于一个小的容差（如 $10^{-10}$），则认为伴随实现是一致的。由于问题明确指出 $(\\boldsymbol{G}^{(k)})^\\star = (\\boldsymbol{G}^{(k)})^\\top$，此检查应通过，验证数值实现的准确性。\n\n**步骤 2：费雪信息矩阵 (FIM)**\n费雪信息矩阵 $\\mathcal{I}$ 量化了观测数据 $\\boldsymbol{y}$ 中包含的关于参数 $\\boldsymbol{\\theta}$ 的信息。它由代价函数观测项 $J_o$ 的Hessian矩阵给出。在线性化近似下，这可以表示为：\n$$\n\\mathcal{I} = \\nabla^2_{\\boldsymbol{\\theta}} J_o = \\boldsymbol{G}^\\top \\boldsymbol{R}^{-1} \\boldsymbol{G}\n$$\n这个 $n \\times n$ 的对称半正定矩阵是算法的核心。由于给定的 $\\boldsymbol{R}$ 是对角矩阵，其逆 $\\boldsymbol{R}^{-1}$ 可以通过对角线元素取倒数轻易获得。\n\n**步骤 3：参数可辨识性与条件数**\n参数 $\\boldsymbol{\\theta}$ 是否可以从观测中唯一确定，取决于FIM $\\mathcal{I}$ 是否为满秩。如果 $\\mathrm{rank}(\\mathcal{I}) = n$（$n$ 为参数个数），则所有参数都是局部可辨识的。如果 $\\mathrm{rank}(\\mathcal{I})  n$，则矩阵是奇异的，表明某些参数（或其线性组合）对观测没有影响，因此无法被确定。\nFIM的谱条件数 $\\kappa_2(\\mathcal{I}) = \\lambda_{\\max} / \\lambda_{\\min}$（最大与最小特征值之比）衡量了参数估计问题的病态程度。一个大的条件数意味着微小的观测误差可能导致参数估计值产生巨大的变化。如果 $\\mathcal{I}$ 是奇异的，则 $\\lambda_{\\min}=0$，条件数为无穷大。\n\n**步骤 4：后验协方差与不确定性**\n在贝叶斯框架下，参数的后验概率分布结合了先验信息（来自背景项 $J_b$）和从观测中获得的信息（来自观测项 $J_o$）。后验协方差矩阵 $\\boldsymbol{\\Sigma}_{\\text{post}}$ 的逆是完整代价函数 $J(\\boldsymbol{\\theta})$ 的Hessian矩阵：\n$$\n\\boldsymbol{\\Sigma}_{\\text{post}}^{-1} = \\nabla^2_{\\boldsymbol{\\theta}} J(\\boldsymbol{\\theta}) = \\nabla^2_{\\boldsymbol{\\theta}} J_b(\\boldsymbol{\\theta}) + \\nabla^2_{\\boldsymbol{\\theta}} J_o(\\boldsymbol{\\theta}) = \\boldsymbol{B}^{-1} + \\mathcal{I}\n$$\n因此，后验协方差矩阵是这个“后验精度矩阵”的逆：\n$$\n\\boldsymbol{\\Sigma}_{\\text{post}} = \\left(\\boldsymbol{B}^{-1} + \\mathcal{I}\\right)^{-1}\n$$\n$\\boldsymbol{\\Sigma}_{\\text{post}}$ 的对角线元素给出了每个参数的后验方差 $(\\sigma_i)^2$。这些值量化了结合先验知识和观测数据后，我们对参数估计值的不确定性。一个小的后验方差意味着参数被很好地约束了。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the data assimilation problem for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"G\": np.array([[1, 0], [0, 1], [1, 1]]),\n            \"R_diag\": np.array([0.25, 0.25, 1.0]),\n            \"B_diag\": np.array([1.0, 1.0]),\n            \"seed\": 0\n        },\n        {\n            \"G\": np.array([[1, 1, 0], [0, 1, 1]]),\n            \"R_diag\": np.array([1.0, 1.0]),\n            \"B_diag\": np.array([100.0, 100.0, 100.0]),\n            \"seed\": 1\n        },\n        {\n            \"G\": np.array([[1.0, 0.999, 0.001], [0.999, 0.998, 0.002], [0.001, 0.002, 0.999]]),\n            \"R_diag\": np.array([0.1, 0.1, 10.0]),\n            \"B_diag\": np.array([1.0, 1.0, 1.0]),\n            \"seed\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        G = case[\"G\"]\n        R_diag = case[\"R_diag\"]\n        B_diag = case[\"B_diag\"]\n        seed = case[\"seed\"]\n\n        m, n = G.shape\n        G_star = G.T\n        \n        # Invert diagonal matrices\n        R_inv = np.diag(1.0 / R_diag)\n        B_inv = np.diag(1.0 / B_diag)\n\n        # Step 1: Adjoint consistency validation\n        rng = np.random.RandomState(seed)\n        d_theta = rng.randn(n)\n        d_y = rng.randn(m)\n\n        lhs = (G @ d_theta).T @ d_y\n        rhs = d_theta.T @ (G_star @ d_y)\n        \n        adjoint_ok = bool(np.isclose(lhs, rhs, atol=1e-10, rtol=0))\n\n        # Step 2: Fisher Information Matrix (FIM)\n        fim = G.T @ R_inv @ G\n\n        # Step 3: Parameter identifiability and conditioning\n        rank = np.linalg.matrix_rank(fim)\n        identifiable = bool(rank == n) # Not required in output, but good practice\n        \n        # Use p=2 for spectral condition number\n        if rank  n:\n            cond = float('inf')\n        else:\n            cond = np.linalg.cond(fim, p=2) \n        \n        # Step 4: Posterior Covariance and Uncertainty\n        posterior_precision = fim + B_inv\n        posterior_cov = np.linalg.inv(posterior_precision)\n        variances = np.diag(posterior_cov)\n\n        # Format results for this case\n        case_result = [\n            adjoint_ok,\n            rank,\n            cond,\n            variances.tolist()\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in results:\n        adj_ok_str = str(res[0])\n        rank_str = str(res[1])\n        cond_str = f'{res[2]:.6f}' if np.isfinite(res[2]) else 'inf'\n        vars_list_str = ', '.join([f'{v:.6f}' for v in res[3]])\n        vars_str = f\"[{vars_list_str}]\"\n        formatted_results.append(f\"[{adj_ok_str}, {rank_str}, {cond_str}, {vars_str}]\")\n        \n    print(f\"[{', '.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}