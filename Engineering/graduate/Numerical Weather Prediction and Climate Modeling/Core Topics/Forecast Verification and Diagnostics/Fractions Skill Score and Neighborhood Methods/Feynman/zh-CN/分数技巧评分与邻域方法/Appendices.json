{
    "hands_on_practices": [
        {
            "introduction": "在将任何检验评分应用于实际预报之前，理解其理论性质至关重要。本练习通过一个理想化的棋盘格模式，推导分数技巧评分（FSS）的精确解析表达式，从而揭示其对空间位移误差的响应。通过这个练习，您将深入理解分数技巧评分（FSS）如何随邻域尺度的变化而变化，并为空间误差、邻域大小和评分值之间的关系建立起直观认识。",
            "id": "4045627",
            "problem": "考虑一个单位网格间距的无限二维周期性方形网格，其上的二元场定义在网格点中心。设观测二元场 $O(i,j)$ 是一个完美的棋盘格，使得对于所有整数 $i$ 和 $j$，当 $i+j$ 为偶数时 $O(i,j) = 1$，当 $i+j$ 为奇数时 $O(i,j) = 0$。预报二元场是观测场在 $x$ 方向上平移一个网格点的结果，即 $F(i,j) = O(i+1,j)$。你将使用方形窗口，通过邻域法来评估分数技巧评分（Fractions Skill Score, FSS）。\n\n将邻域分数 $o_{s}(i,j)$ 和 $f_{s}(i,j)$ 分别定义为 $O$ 和 $F$ 在以 $(i,j)$ 为中心的 $s \\times s$ 方形网格点区域上的平均值，其中 $s \\in \\mathbb{N}$ 是以网格点为单位测量的窗口边长。假设存在周期性，因此在每个 $(i,j)$ 处的窗口求和都是良定义的。将窗口大小为 $s$ 时的分数技巧评分（FSS）定义为\n$$\n\\mathrm{FSS}(s) \\equiv 1 - \\frac{\\mathrm{MSE}(s)}{\\mathrm{MSE}_{\\mathrm{ref}}(s)},\n$$\n其中\n$$\n\\mathrm{MSE}(s) \\equiv \\lim_{N \\to \\infty} \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left(f_{s}(i,j) - o_{s}(i,j)\\right)^{2},\n$$\n以及\n$$\n\\mathrm{MSE}_{\\mathrm{ref}}(s) \\equiv \\lim_{N \\to \\infty} \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left(f_{s}(i,j)^{2} + o_{s}(i,j)^{2}\\right).\n$$\n\n从这些定义出发，仅使用平均和周期性的基本性质，推导一个对所有整数 $s \\geq 1$ 都有效的 $\\mathrm{FSS}(s)$ 的闭式解析表达式。然后，采用“有用尺度”的广泛使用的业务定义，即 $\\mathrm{FSS}(s)$ 超过依赖于基础率的阈值的最小 $s$\n$$\nT \\equiv \\frac{1}{2} + \\frac{f}{2},\n$$\n其中 $f$ 是 $O$ 在原始网格尺度上的区域平均值，确定此配置下的有用尺度 $s^{\\ast}$。\n\n提供两个输出：(i) 对所有整数 $s \\geq 1$ 有效的 $\\mathrm{FSS}(s)$ 的解析表达式，以及 (ii) 满足上述阈值标准的最小整数 $s^{\\ast}$。无需四舍五入。最终答案必须按规定以一个二元行矩阵的形式呈现。",
            "solution": "该问题要求针对观测场和预报场的特定配置，给出分数技巧评分 $\\mathrm{FSS}(s)$ 的解析表达式，并由此推导出“有用尺度”$s^{\\ast}$。\n\n观测场是一个棋盘格图案，$O(i,j) = 1$ 当 $i+j$ 为偶数时，$O(i,j) = 0$ 当 $i+j$ 为奇数时。预报场是一个网格点的平移，$F(i,j) = O(i+1,j)$。\n\n首先，我们建立场 $O(i,j)$ 和 $F(i,j)$ 之间的关系。\n$O(i,j)$ 的值取决于 $i+j$ 的奇偶性。\n$F(i,j) = O(i+1,j)$ 的值取决于 $(i+1)+j = (i+j)+1$ 的奇偶性。\n如果 $i+j$ 是偶数，则 $O(i,j)=1$。那么 $(i+j)+1$ 是奇数，所以 $F(i,j)=O(i+1,j)=0$。\n如果 $i+j$ 是奇数，则 $O(i,j)=0$。那么 $(i+j)+1$ 是偶数，所以 $F(i,j)=O(i+1,j)=1$。\n在这两种情况下，都有 $F(i,j) = 1 - O(i,j)$。预报场是观测场的补集。\n\n邻域分数 $o_{s}(i,j)$ 和 $f_{s}(i,j)$ 是 $O$ 和 $F$ 在一个 $s \\times s$ 窗口上的平均值。由于平均算子的线性性，分数也存在类似的关系：\n$$f_{s}(i,j) = \\frac{1}{s^2} \\sum_{\\text{window}} F(k,l) = \\frac{1}{s^2} \\sum_{\\text{window}} (1 - O(k,l)) = 1 - \\frac{1}{s^2} \\sum_{\\text{window}} O(k,l) = 1 - o_{s}(i,j)$$\n\n现在我们可以重写均方误差（MSE）项。符号 $\\langle \\cdot \\rangle$ 将用于表示空间平均 $\\lim_{N \\to \\infty} \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j=1}^{N} (\\cdot)$。\n$$\\mathrm{MSE}(s) = \\langle (f_{s}(i,j) - o_{s}(i,j))^2 \\rangle = \\langle (1 - o_{s}(i,j) - o_{s}(i,j))^2 \\rangle = \\langle (1 - 2o_{s}(i,j))^2 \\rangle$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = \\langle f_{s}(i,j)^2 + o_{s}(i,j)^2 \\rangle = \\langle (1 - o_{s}(i,j))^2 + o_{s}(i,j)^2 \\rangle$$\n\n展开这些表达式：\n$$\\mathrm{MSE}(s) = \\langle 1 - 4o_{s}(i,j) + 4o_{s}(i,j)^2 \\rangle = 1 - 4 \\langle o_{s} \\rangle + 4 \\langle o_{s}^2 \\rangle$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = \\langle 1 - 2o_{s}(i,j) + 2o_{s}(i,j)^2 \\rangle = 1 - 2 \\langle o_{s} \\rangle + 2 \\langle o_{s}^2 \\rangle$$\n为了继续，我们需要计算空间平均 $\\langle o_s \\rangle$ 和 $\\langle o_s^2 \\rangle$。\n\n卷积场 $o_s$ 的平均值就是原始场 $O$ 的平均值。场 $O$ 由等量的 $1$ 和 $0$ 组成。因此，其空间平均为 $\\frac{1}{2}$。\n$$\\langle O \\rangle = \\frac{1}{2} \\implies \\langle o_s \\rangle = \\frac{1}{2} \\text{ for any } s \\ge 1$$\n\n$\\langle o_s^2 \\rangle$ 的计算取决于窗口大小 $s$ 的奇偶性。\n\n情况1：$s$ 为偶数。\n设 $s=2k$，其中 $k \\ge 1$ 为某个整数。一个 $s \\times s$ 的窗口可以被 $k^2$ 个不重叠的 $2 \\times 2$ 块完美地铺满。在一个棋盘格网格中，任何 $2 \\times 2$ 的网格点块都恰好包含两个 $O=1$ 的点和两个 $O=0$ 的点。因此，$O$ 在一个 $2 \\times 2$ 块上的和为 $2$。$O$ 在一个 $s \\times s$ 窗口上的和为 $k^2 \\times 2 = (s/2)^2 \\times 2 = s^2/2$。\n任何 $s \\times s$ 窗口中 $1$ 的分数是恒定的：\n$$o_{s}(i,j) = \\frac{s^2/2}{s^2} = \\frac{1}{2} \\quad (\\text{for } s \\text{ even})$$\n由于 $o_s(i,j)$ 是一个常数，其平均值为 $\\langle o_s \\rangle = \\frac{1}{2}$，其均方值为 $\\langle o_s^2 \\rangle = (\\frac{1}{2})^2 = \\frac{1}{4}$。\n现在我们求出偶数 $s$ 的 MSE 项：\n$$\\mathrm{MSE}(s) = 1 - 4(\\frac{1}{2}) + 4(\\frac{1}{4}) = 1 - 2 + 1 = 0$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = 1 - 2(\\frac{1}{2}) + 2(\\frac{1}{4}) = 1 - 1 + \\frac{1}{2} = \\frac{1}{2}$$\n偶数 $s$ 的 FSS 为：\n$$\\mathrm{FSS}(s) = 1 - \\frac{\\mathrm{MSE}(s)}{\\mathrm{MSE}_{\\mathrm{ref}}(s)} = 1 - \\frac{0}{1/2} = 1$$\n\n情况2：$s$ 为奇数。\n设 $s=2k+1$，其中 $k \\ge 0$ 为某个整数。窗口中的总点数为 $s^2$。在这种情况下，$1$ 和 $0$ 的数量不相等。\n对于以 $(i,j)$ 为中心的窗口，如果 $O(i,j)=1$（即 $i+j$ 为偶数），则窗口包含 $\\frac{s^2+1}{2}$ 个值为 $1$ 的点。如果 $O(i,j)=0$（即 $i+j$ 为奇数），则窗口包含 $\\frac{s^2-1}{2}$ 个值为 $1$ 的点。\n所以，$o_s(i,j)$ 有两个可能的值：\n$$o_s(i,j) = \\frac{s^2+1}{2s^2} \\quad \\text{if } i+j \\text{ is even}$$\n$$o_s(i,j) = \\frac{s^2-1}{2s^2} \\quad \\text{if } i+j \\text{ is odd}$$\n由于一半的网格点满足 $i+j$ 为偶数，另一半满足 $i+j$ 为奇数，空间平均 $\\langle o_s^2 \\rangle$ 为：\n$$\\langle o_s^2 \\rangle = \\frac{1}{2} \\left( \\frac{s^2+1}{2s^2} \\right)^2 + \\frac{1}{2} \\left( \\frac{s^2-1}{2s^2} \\right)^2$$\n$$\\langle o_s^2 \\rangle = \\frac{1}{2 \\cdot 4s^4} \\left[ (s^4+2s^2+1) + (s^4-2s^2+1) \\right] = \\frac{1}{8s^4} (2s^4+2) = \\frac{s^4+1}{4s^4}$$\n现在我们求出奇数 $s$ 的 MSE 项：\n$$\\mathrm{MSE}(s) = 1 - 4(\\frac{1}{2}) + 4\\left(\\frac{s^4+1}{4s^4}\\right) = 1 - 2 + \\frac{s^4+1}{s^4} = -1 + 1 + \\frac{1}{s^4} = \\frac{1}{s^4}$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = 1 - 2(\\frac{1}{2}) + 2\\left(\\frac{s^4+1}{4s^4}\\right) = 1 - 1 + \\frac{s^4+1}{2s^4} = \\frac{s^4+1}{2s^4}$$\n奇数 $s$ 的 FSS 为：\n$$\\mathrm{FSS}(s) = 1 - \\frac{1/s^4}{(s^4+1)/(2s^4)} = 1 - \\frac{2s^4}{s^4(s^4+1)} = 1 - \\frac{2}{s^4+1} = \\frac{s^4+1-2}{s^4+1} = \\frac{s^4-1}{s^4+1}$$\n\n为了给出一个对所有整数 $s \\ge 1$ 都有效的单一解析表达式：\n$$ \\mathrm{FSS}(s) = \\begin{cases} \\frac{s^4-1}{s^4+1}  \\text{if } s \\text{ is odd} \\\\ 1  \\text{if } s \\text{ is even} \\end{cases} $$\n这可以用 $(-1)^s$ 项来统一：\n$$\\mathrm{FSS}(s) = \\frac{1-(-1)^s}{2} \\left(\\frac{s^4-1}{s^4+1}\\right) + \\frac{1+(-1)^s}{2} (1) = \\frac{(1-(-1)^s)(s^4-1) + (1+(-1)^s)(s^4+1)}{2(s^4+1)}$$\n$$= \\frac{s^4-1 - (-1)^s s^4 + (-1)^s + s^4+1 + (-1)^s s^4 + (-1)^s}{2(s^4+1)} = \\frac{2s^4 + 2(-1)^s}{2(s^4+1)} = \\frac{s^4+(-1)^s}{s^4+1}$$\n该表达式对于偶数 $s$ 正确地得到 $1$，对于奇数 $s$ 正确地得到 $\\frac{s^4-1}{s^4+1}$。\n\n接下来，我们确定有用尺度 $s^{\\ast}$。这是使得 $\\mathrm{FSS}(s) > T$ 的最小整数 $s$，其中 $T = \\frac{1}{2} + \\frac{f}{2}$。\n基础率 $f$ 是 $O$ 在原始尺度上的区域平均值，即 $f = \\langle O \\rangle = \\frac{1}{2}$。\n阈值是 $T = \\frac{1}{2} + \\frac{1/2}{2} = \\frac{1}{2} + \\frac{1}{4} = \\frac{3}{4}$。\n\n我们寻找使 $\\mathrm{FSS}(s) > \\frac{3}{4}$ 成立的最小整数 $s \\ge 1$。\n让我们测试较小的整数 $s$ 值：\n对于 $s=1$（奇数）：\n$$\\mathrm{FSS}(1) = \\frac{1^4-1}{1^4+1} = 0$$\n$0 \\ngtr \\frac{3}{4}$，所以 $s=1$ 不是有用尺度。\n对于 $s=2$（偶数）：\n$$\\mathrm{FSS}(2) = 1$$\n$1 > \\frac{3}{4}$，所以 $s=2$ 满足该标准。\n因为我们正在寻找最小的整数 $s$，并且我们发现 $s=2$ 满足条件而 $s=1$ 不满足，所以有用尺度是 $s^{\\ast}=2$。\n\n两个要求的输出是 $\\mathrm{FSS}(s)$ 的表达式和 $s^{\\ast}$ 的值。\n(i) $\\mathrm{FSS}(s) = \\frac{s^4+(-1)^s}{s^4+1}$\n(ii) $s^{\\ast}=2$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{s^4+(-1)^s}{s^4+1} & 2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "将理论公式转化为实际代码时，会暴露出许多在理论层面不易察觉的挑战。本练习旨在解决分数技巧评分（FSS）在实际计算中的数值稳定性问题，特别是在处理罕见事件时，分母可能趋近于零，导致评分结果不可靠。学习并实现这些保护措施，是开发专业级检验工具的关键一步，确保了科学计算的严谨性和结果的有效性。",
            "id": "4045673",
            "problem": "给定代表数值天气预报（预报）和验证分析（观测）的二维二元超限场。对于每个格点，邻域法通过在方形窗口内对二元场进行平均，来计算局部超限分数。分数技巧评分 (FSS) 通过比较这些邻域分数来量化空间预报技巧。设 $X \\in \\{0,1\\}^{M \\times N}$ 表示预报二元场，$Y \\in \\{0,1\\}^{M \\times N}$ 表示观测二元场。对于以格点 $(i,j)$ 为中心、半径为 $r$（因此窗口宽度为 $2r+1$）的方形窗口，定义预报和观测的邻域分数为\n$$\nf_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} X_{pq}, \\quad o_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} Y_{pq},\n$$\n其中 $W_{ij}$ 是以 $(i,j)$ 为中心的方形窗口内属于定义域的索引集合，而 $A_{ij}$ 是 $W_{ij}$ 中属于定义域的点的数量。区域级的分数技巧评分通过对所有格点进行聚合来定义：\n$$\n\\mathrm{FSS} = \\frac{2 \\sum_{i,j} f_{ij} \\, o_{ij}}{\\sum_{i,j} f_{ij}^2 + \\sum_{i,j} o_{ij}^2}.\n$$\n在实践中，当分母很小（例如，对于非常罕见的事件）时，由于有限精度和噪声，可能会出现数值不稳定和评分的伪性膨胀。您的任务是实现一个数值稳定的 $\\mathrm{FSS}$ 计算方法，其中包含防止伪性膨胀的保障措施。\n\n从上述基本定义出发，设计并实现一个算法，该算法：\n- 使用带有边界截断的方形窗口计算邻域分数 $f_{ij}$ 和 $o_{ij}$（即，$A_{ij}$ 等于窗口内实际属于定义域的点的数量）。\n- 如上所示，将 $\\mathrm{FSS}$ 聚合为总和的比率，而不是局部比率的平均值。\n- 应用以下保障措施：\n  1. 有效性门控：对于用户指定的阈值 $\\theta$，排除满足 $f_{ij} + o_{ij}  \\theta$ 的格点，以移除事件质量可忽略不计的非信息性窗口。\n  2. 分母正则化：将分母 $D = \\sum_{i,j} f_{ij}^2 + \\sum_{i,j} o_{ij}^2$ 替换为 $D_{\\mathrm{reg}} = D + \\varepsilon_{\\mathrm{reg}}$，其中 $\\varepsilon_{\\mathrm{reg}}$ 是一个根据机器精度和经验性最小非零分数推导出的自适应正常数。具体地，设置\n     $$\n     \\varepsilon_{\\mathrm{reg}} = \\lambda \\, \\max\\!\\big( N_{\\mathrm{eff}} \\, \\epsilon_{\\mathrm{mach}}, \\, N_{\\mathrm{eff}} \\, p_{\\min}^2 \\big),\n     $$\n     其中 $N_{\\mathrm{eff}}$ 是经过有效性门控后包含的格点数，$\\epsilon_{\\mathrm{mach}}$ 是双精度算术的机器ε，$p_{\\min}$ 是在所包含点中 $\\{f_{ij}, o_{ij}\\}$ 里的最小严格正值，而 $\\lambda$ 是用户指定的缩放常数。\n  3. 零信息情况的约定：如果 $N_{\\mathrm{eff}} = 0$，则返回 $\\mathrm{FSS} = 1$（在门控阈值下，预报和观测在所有地方都实际上是“无事件”），而不是产生一个未定义的结果。\n  4. 范围强制：将最终得分裁剪到 $[0,1]$ 范围内。\n  \n您的程序必须实现上述要求，并为提供的测试套件计算稳定的 $\\mathrm{FSS}$。所有输入均为无量纲，输出必须是无量纲实数。所有输出都表示为四舍五入到 $6$ 位小数的十进制浮点数。\n\n测试套件：\n使用以下五个测试用例。每个用例指定了 $(X, Y, r, \\theta, \\lambda)$，其中 $M = N = 8$。在所有情况下，索引都是从零开始的，并且对于切片表示法，包含端点。请完全按照规定定义 $X$ 和 $Y$。\n\n- 用例1（中等事件，小位移，典型分母）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在行 $[3:6]$ 和列 $[3:6]$（一个居中的 $3 \\times 3$ 块）中为1，其余为0。\n  - $Y$ 在行 $[4:7]$ 和列 $[3:6]$（相同的块向下移动一个单位）中为1，其余为0。\n- 用例2（罕见事件，小分母，轻微不匹配）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在坐标 $(0,0)$ 和 $(1,2)$ 处为1，其余为0。\n  - $Y$ 在 $(0,1)$ 处为1，其余为0。\n- 用例3（无事件，零分母）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 全为0。\n  - $Y$ 全为0。\n- 用例4（完全不匹配的簇，正常分母）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在行 $[0:3]$ 和列 $[0:3]$（左上角 $3 \\times 3$ 块）中为1，其余为0。\n  - $Y$ 在行 $[5:8]$ 和列 $[5:8]$（右下角 $3 \\times 3$ 块）中为1，其余为0。\n- 用例5（完美的单点匹配，极其罕见）：\n  - $r = 2$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在 $(4,4)$ 处为1，其余为0。\n  - $Y$ 在 $(4,4)$ 处为1，其余为0。\n\n输出规格：\n您的程序应生成单行输出，其中包含五个用例的稳定 FSS 结果，形式为方括号括起来的逗号分隔列表，四舍五入到 $6$ 位小数，例如 $[0.123456,0.234567,0.345678,0.456789,0.567890]$。不得打印任何其他文本。",
            "solution": "该问题要求实现一种数值稳定的分数技巧评分（FSS）计算方法，用于比较二元预报场与观测场。FSS 是一种基于邻域的检验指标，广泛应用于气象学。核心任务包括计算局部超限分数，将其聚合成一个技巧评分，并应用特定的数值保障措施来处理常见的失效模式，例如在罕见事件情况下除以接近零的分母。\n\n该算法主要分四个阶段进行：\n1.  邻域分数的计算。\n2.  应用有效性门控以过滤非信息性格点。\n3.  从有效点中聚合评分分量（分子和分母）。\n4.  应用数值正则化和最终评分计算并进行裁剪。\n\n设 $X$ 和 $Y$ 分别是 $M \\times N$ 的二元预报场和观测场。窗口半径为 $r$。\n\n**步骤1：邻域分数计算**\n\n邻域分数，$f_{ij}$（预报）和 $o_{ij}$（观测），在每个格点 $(i,j)$ 处计算。该分数表示在以 $(i,j)$ 为中心的宽度为 $W = 2r+1$ 的方形窗口内“事件”点（值为1）的密度。其定义为：\n$$\nf_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} X_{pq}, \\quad o_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} Y_{pq}\n$$\n这里，$W_{ij}$ 是以 $(i,j)$ 为中心的窗口内的格点索引集合，$A_{ij}$ 是此窗口内位于域边界内的点的数量（即边界截断）。\n\n这个操作可以使用二维卷积高效实现。设 $K$ 是一个大小为 $(2r+1) \\times (2r+1)$ 且所有元素均为 $1$ 的核。总和 $\\sum X_{pq}$ 和 $\\sum Y_{pq}$ 可以通过将 $X$ 和 $Y$ 与 $K$ 进行卷积来计算。\n$$\n\\text{Sum}_{X} = X * K, \\quad \\text{Sum}_{Y} = Y * K\n$$\n卷积必须通过假设域外的值为 $0$ 来处理边界，这对应于 `scipy.ndimage.convolve` 中的 `mode='constant', cval=0` 设置。\n\n归一化因子 $A_{ij}$，用于解释靠近边界的截断窗口，可以通过将一个全为1的场 $I$（其中对所有 $p,q$，$I_{pq}=1$）与相同的核 $K$ 进行卷积来计算。\n$$\nA = I * K\n$$\n然后通过逐元素相除得到分数场：\n$$\nf = \\frac{\\text{Sum}_{X}}{A}, \\quad o = \\frac{\\text{Sum}_{Y}}{A}\n$$\n\n**步骤2：有效性门控**\n\n为防止非信息区域（预报和观测的事件分数都接近于零的区域）影响评分，应用了有效性门控。一个格点 $(i,j)$ 仅在其分数之和达到或超过阈值 $\\theta$ 时才被视为有效：\n$$\nf_{ij} + o_{ij} \\geq \\theta\n$$\n这将创建一个有效格点的布尔掩码。有效点数 $N_{\\mathrm{eff}}$ 是这类点的总数。\n\n如果 $N_{\\mathrm{eff}} = 0$，则出现一种特殊情况。这表明对于所选的窗口大小和阈值，在预报和观测中都没有显著事件。根据问题规范，这被认为是“完美”预报了一个无事件场，FSS 定义为 $1$。\n\n**步骤3：评分分量的聚合**\n\n如果 $N_{\\mathrm{eff}} > 0$，我们仅在有效格点集合上计算 FSS 公式的基本分量。设 $V$ 为有效点的索引集合。FSS 的分子 $N_{\\mathrm{FSS}}$ 和分母 $D_{\\mathrm{FSS}}$ 是：\n$$\nN_{\\mathrm{FSS}} = 2 \\sum_{(i,j) \\in V} f_{ij} \\, o_{ij}\n$$\n$$\nD_{\\mathrm{FSS}} = \\sum_{(i,j) \\in V} \\left( f_{ij}^2 + o_{ij}^2 \\right)\n$$\n标准的 FSS 将是比率 $N_{\\mathrm{FSS}} / D_{\\mathrm{FSS}}$。\n\n**步骤4：分母正则化和最终得分计算**\n\n对于罕见事件，分母 $D_{\\mathrm{FSS}}$ 可能非常小，导致数值不稳定和可能虚高的评分。为减轻此问题，向分母添加一个正则化项 $\\varepsilon_{\\mathrm{reg}}$。该项自适应定义为：\n$$\n\\varepsilon_{\\mathrm{reg}} = \\lambda \\, \\max\\!\\big( N_{\\mathrm{eff}} \\, \\epsilon_{\\mathrm{mach}}, \\, N_{\\mathrm{eff}} \\, p_{\\min}^2 \\big)\n$$\n其中：\n- $\\lambda$ 是用户指定的缩放因子。\n- $\\epsilon_{\\mathrm{mach}}$ 是双精度浮点数的机器ε，表示使得 $1.0 + \\epsilon_{\\mathrm{mach}} \\neq 1.0$ 的最小数。\n- $p_{\\min}$ 是在有效点集 $V$ 上所有分数 $\\{f_{ij}, o_{ij}\\}$ 中的最小严格正值。如果 $N_{\\mathrm{eff}} > 0$ 且 $\\theta > 0$，则必须存在至少一个这样的正分数。\n\n正则化后的分母是 $D_{\\mathrm{reg}} = D_{\\mathrm{FSS}} + \\varepsilon_{\\mathrm{reg}}$。然后原始 FSS 计算如下：\n$$\n\\mathrm{FSS}_{\\mathrm{raw}} = \\frac{N_{\\mathrm{FSS}}}{D_{\\mathrm{reg}}}\n$$\n这种正则化确保分母有界且不为零，提供了稳定性。\n\n最后，将得分裁剪到 $[0,1]$ 范围内，以强制其作为技巧评分的定义，其中 $1$ 表示完美，$0$ 表示没有技巧。\n$$\n\\mathrm{FSS} = \\mathrm{clip}(\\mathrm{FSS}_{\\mathrm{raw}}, 0, 1)\n$$\n这个最终值就是数值稳定的分数技巧评分。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef compute_stabilized_fss(X, Y, r, theta, lambd):\n    \"\"\"\n    Computes the numerically stabilized Fractions Skill Score (FSS).\n\n    Args:\n        X (np.ndarray): The M x N binary forecast field.\n        Y (np.ndarray): The M x N binary observation field.\n        r (int): The radius for the square neighborhood window.\n        theta (float): The validity gating threshold.\n        lambd (float): The regularization scaling constant.\n\n    Returns:\n        float: The stabilized FSS value.\n    \"\"\"\n    if X.shape != Y.shape:\n        raise ValueError(\"Input fields X and Y must have the same shape.\")\n\n    M, N = X.shape\n    width = 2 * r + 1\n    kernel = np.ones((width, width))\n\n    # Step 1: Compute neighborhood fractions\n    # Use convolution to get sums in the sliding window.\n    # mode='constant', cval=0 handles boundaries correctly for this problem.\n    sum_X = convolve(X.astype(float), kernel, mode='constant', cval=0)\n    sum_Y = convolve(Y.astype(float), kernel, mode='constant', cval=0)\n\n    # To get the normalization factor A_ij (number of in-domain points),\n    # convolve a field of ones with the same kernel.\n    A = convolve(np.ones((M, N), dtype=float), kernel, mode='constant', cval=0)\n    \n    # Avoid division by zero, although A should be > 0 for r >= 0.\n    A[A == 0] = 1.0 \n    \n    f = sum_X / A\n    o = sum_Y / A\n\n    # Step 2: Apply validity gating\n    valid_mask = (f + o) >= theta\n    N_eff = np.sum(valid_mask)\n\n    # Step 3 (rule 3): Handle zero-information case\n    if N_eff == 0:\n        return 1.0\n\n    # Filter fractions to include only valid points\n    f_valid = f[valid_mask]\n    o_valid = o[valid_mask]\n\n    # Step 4: Aggregate score components\n    numerator_fss = 2.0 * np.sum(f_valid * o_valid)\n    denominator_fss = np.sum(f_valid**2) + np.sum(o_valid**2)\n    \n    if denominator_fss == 0:\n        # If numerator is also zero, it's a perfect no-event case\n        # (already covered by N_eff=0). If num > 0, it's an issue not\n        # expected by problem statement. A safe return for N=0, D=0 would be 1.\n        return 1.0 if numerator_fss == 0 else 0.0\n\n    # Step 5: Compute regularization term\n    positive_fractions = np.concatenate((f_valid[f_valid > 0], o_valid[o_valid > 0]))\n    \n    if positive_fractions.size == 0:\n        # This case should ideally not be reached if N_eff > 0 and theta > 0.\n        # If it is, it means all valid fractions were zero, so D=0, handled above.\n        # We can treat this as having no regularization.\n        p_min_sq = 0.0\n    else:\n        p_min = np.min(positive_fractions)\n        p_min_sq = p_min**2\n\n    eps_mach = np.finfo(np.float64).eps\n    eps_reg = lambd * max(N_eff * eps_mach, N_eff * p_min_sq)\n\n    # Step 6: Compute regularized FSS and clip\n    denominator_reg = denominator_fss + eps_reg\n    \n    # Final division, protected against zero denominator\n    fss_raw = numerator_fss / denominator_reg if denominator_reg != 0 else 0.0\n    \n    fss_final = np.clip(fss_raw, 0.0, 1.0)\n\n    return fss_final\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the stabilized FSS computation.\n    \"\"\"\n    \n    M, N = 8, 8\n\n    # Case 1\n    X1 = np.zeros((M, N))\n    X1[3:6, 3:6] = 1\n    Y1 = np.zeros((M, N))\n    Y1[4:7, 3:6] = 1\n    case1 = (X1, Y1, 1, 0.05, 1.0)\n    \n    # Case 2\n    X2 = np.zeros((M, N))\n    X2[0, 0] = 1\n    X2[1, 2] = 1\n    Y2 = np.zeros((M, N))\n    Y2[0, 1] = 1\n    case2 = (X2, Y2, 1, 0.05, 1.0)\n\n    # Case 3\n    X3 = np.zeros((M, N))\n    Y3 = np.zeros((M, N))\n    case3 = (X3, Y3, 1, 0.05, 1.0)\n\n    # Case 4\n    X4 = np.zeros((M, N))\n    X4[0:3, 0:3] = 1\n    Y4 = np.zeros((M, N))\n    Y4[5:8, 5:8] = 1\n    case4 = (X4, Y4, 1, 0.05, 1.0)\n\n    # Case 5\n    X5 = np.zeros((M, N))\n    X5[4, 4] = 1\n    Y5 = np.zeros((M, N))\n    Y5[4, 4] = 1\n    case5 = (X5, Y5, 2, 0.05, 1.0)\n\n    test_cases = [case1, case2, case3, case4, case5]\n    \n    results = []\n    for params in test_cases:\n        X, Y, r, theta, lambd = params\n        fss = compute_stabilized_fss(X, Y, r, theta, lambd)\n        results.append(round(fss, 6))\n\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "最后的这项练习将分数技巧评分（FSS）应用于现代集合预报的实际场景中，其核心目标是计算“可用尺度”（useful scale）。可用尺度指的是预报开始具备技巧的最小空间尺度，是衡量预报性能的实用指标。通过为每个集合成员及集合平均计算该尺度，我们不仅能评估预报的整体质量，还能分析集合内部技巧的一致性与离散度。",
            "id": "4045696",
            "problem": "给定一个表示气象现象（例如，阈值化的“是/否”降水）发生情况的网格化事件场，以及一个预报场的集合，其中每个预报场都表示为一个二元数组，值 $1$ 表示事件发生，$0$ 表示未发生。您的任务是构建一种方法，使用基于邻域的分数技巧评分（Fraction Skill Score, FSS）评估，计算每个集合成员和集合平均的“有效尺度”，并比较各集合成员有效尺度的分布。\n\n此背景下的基本基础包括以下定义和经过充分检验的公式：\n\n1. 设预报场为一个二元数组 $F \\in \\{0,1\\}^{N_x \\times N_y}$，观测场为一个二元数组 $O \\in \\{0,1\\}^{N_x \\times N_y}$。\n\n2. 对于给定的邻域尺度 $s$（单位为公里）和网格间距 $\\Delta x$（单位为公里），通过选择最接近 $s/\\Delta x$ 的奇数整数来定义一个以网格单元为单位的奇数整数窗口宽度 $w(s)$。给定一个方形平均核 $K_s$，其中对于 $-r \\le i,j \\le r$ 有 $K_s(i,j) = 1$ 且 $w(s) = 2r+1$，通过离散卷积定义邻域分数场 $f_s$ 和 $o_s$\n   $$\n   f_s = \\frac{1}{w(s)^2} \\left( K_s * F \\right), \\quad o_s = \\frac{1}{w(s)^2} \\left( K_s * O \\right),\n   $$\n   其中 $*$ 表示二维离散卷积，并使用反射边界条件，以便通过对称反射处理边缘处的值。\n\n3. 尺度 $s$ 上的分数技巧评分（FSS）由归一化均方误差公式定义\n   $$\n   \\mathrm{FSS}(s) = 1 - \\frac{\\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left( f_s(i,j) - o_s(i,j) \\right)^2}{\\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left( f_s(i,j)^2 + o_s(i,j)^2 \\right)}.\n   $$\n   如果分母为零（这仅在 $f_s$ 和 $o_s$ 都恒为零时发生），则定义 $\\mathrm{FSS}(s) = 1$。\n\n4. 对于一个包含 $M$ 个成员的集合 $\\{F^{(m)}\\}_{m=1}^M$，定义集合平均场 $E$ 为\n   $$\n   E = \\frac{1}{M} \\sum_{m=1}^M F^{(m)},\n   $$\n   这是一个在 $[0,1]^{N_x \\times N_y}$ 上的实值场。在尺度 $s$ 上，通过以下方式计算平滑后的集合平均分数场 $e_s$\n   $$\n   e_s = \\frac{1}{w(s)^2} \\left( K_s * E \\right),\n   $$\n   并通过在分数技巧评分公式中用 $e_s$ 替换 $f_s$ 来计算 $\\mathrm{FSS}_{\\text{mean}}(s)$。\n\n5. 给定一个临界技巧阈值 $q \\in (0,1)$，将预报（单个成员或集合平均）的有效尺度 $s^\\ast$ 定义为\n   $$\n   s^\\ast = \\min \\{ s \\in \\mathcal{S} : \\mathrm{FSS}(s) \\ge q \\},\n   $$\n   其中 $\\mathcal{S}$ 是测试尺度的集合。如果没有测试尺度达到或超过该阈值，则设置 $s^\\ast = \\max(\\mathcal{S})$。\n\n实现一个程序，应用这些定义并为每个提供的测试用例计算：\n- 集合平均的有效尺度，以公里为单位表示。\n- 各集合成员有效尺度的中位数，以公里为单位表示。\n- 各集合成员有效尺度的方差，以平方公里为单位表示。\n\n使用如上定义的邻域方法和分数技巧评分（FSS）来计算有效尺度。在卷积过程中必须使用反射边界条件。所有输出都必须以公里（方差以平方公里）为单位表示，不带百分号。不涉及角度。程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，将所有测试用例的结果聚合为一个列表的列表，形式为\n“[ [case1_mean,case1_median,case1_variance], [case2_mean,case2_median,case2_variance], [case3_mean,case3_median,case3_variance] ]”\n所有条目均为浮点数。\n\n测试套件：\n\n所有测试用例都使用一个大小为 $N_x = N_y = 64$ 的网格，网格间距 $\\Delta x = 2$ 公里。观测场和集合成员是由中心 $(c_x,c_y)$（网格索引）和半径 $R$（网格单元）定义的圆盘（实心圆）。半径为 $R$ 个单元的圆盘意味着所有满足 $(i - c_x)^2 + (j - c_y)^2 \\le R^2$ 的网格点 $(i,j)$ 被赋值为 $1$，否则为 $0$。\n\n- 测试用例 1（成员误差不同的一般情况）：\n  - 观测场：中心 $(32,32)$，半径 $R_O = 8$。\n  - 集合成员（每个成员指定为 $(c_x,c_y,R)$）：\n    $$\n    \\{(27,28,8), (29,34,9), (34,31,7), (36,35,9), (30,37,8), (38,26,10), (32,32,8), (33,33,8), (31,30,8), (35,28,7), (26,37,11), (37,38,10)\\}.\n    $$\n  - 测试尺度（公里）：$\\mathcal{S} = [2, 6, 10, 14, 18, 22, 26]$。\n  - 临界阈值：$q = 0.5$。\n\n- 测试用例 2（完美预报）：\n  - 观测场：中心 $(30,30)$，半径 $R_O = 6$。\n  - 集合成员：六个与观测场 $(30,30,6)$ 完全相同的副本。\n  - 测试尺度（公里）：$\\mathcal{S} = [2, 4, 6, 8, 10]$。\n  - 临界阈值：$q = 0.7$。\n\n- 测试用例 3（远离观测场的不佳预报）：\n  - 观测场：中心 $(28,35)$，半径 $R_O = 10$。\n  - 集合成员：\n    $$\n    \\{(5,5,4), (55,55,4), (5,55,4), (55,5,4), (10,50,3), (50,10,3), (20,20,3), (44,44,3)\\}.\n    $$\n  - 测试尺度（公里）：$\\mathcal{S} = [2, 10, 18, 26, 34]$。\n  - 临界阈值：$q = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[[result1_case1,result2_case1,result3_case1],[result1_case2,result2_case2,result3_case2],[result1_case3,result2_case3,result3_case3]]”），其中每个“result”是如上定义的浮点数，每个用例中的前两个条目以公里为单位，第三个条目以平方公里为单位。",
            "solution": "该问题陈述在形式上被验证为具有科学依据、适定且客观的。它基于气象预报检验中的既定原则，特别是分数技巧评分（FSS）和集合预报的邻域方法，提出了一个清晰、独立的任务。所有定义、公式和数据都明确提供且相互一致，从而能够得出一个唯一且有意义的解。\n\n解决此问题的方法论遵循一系列明确定义的步骤，并严格遵守所提供的定义。\n\n首先，对于每个测试用例，我们必须为观测场和每个集合成员构建二元网格场。网格维度为 $N_x = 64, N_y = 64$，网格间距为 $\\Delta x = 2$ 公里。一个事件，表示为实心圆（圆盘），由其中心 $(c_x, c_y)$ 和半径 $R$ 定义。位于整数坐标 $(j, i)$ （列，行）的网格单元，如果满足条件 $(j-c_x)^2 + (i-c_y)^2 \\le R^2$，则赋值为 $1$，否则为 $0$。我们将给定的中心坐标 $(c_x, c_y)$ 解释为对应于（列，行）的 0-索引网格坐标。\n\n其次，我们为一组指定的邻域尺度 $\\mathcal{S}$ 计算分数技巧评分 $\\mathrm{FSS}(s)$。这需要在每个尺度 $s \\in \\mathcal{S}$ 上执行几个子步骤：\n\n1.  确定邻域窗口宽度 $w(s)$，定义为最接近比值 $s/\\Delta x$ 的奇数整数。在 $s/\\Delta x$ 与两个奇数整数等距的情况下（例如，如果 $s/\\Delta x$ 是一个偶数），我们采用选择较大奇数整数的约定。\n2.  生成邻域分数场。对于一个观测场 $O$ 和一个预报场 $F$（可以是单个集合成员 $F^{(m)}$ 或集合平均 $E$），我们计算分数场 $o_s$ 和 $f_s$（或对于集合平均为 $e_s$）。这是通过与一个大小为 $w(s) \\times w(s)$、完全由 1 组成的方形核 $K_s$ 进行二维离散卷积来完成的。卷积必须使用反射边界条件。所得场通过除以核的面积 $w(s)^2$ 进行归一化。\n    $$\n    o_s = \\frac{1}{w(s)^2} (K_s * O), \\quad f_s = \\frac{1}{w(s)^2} (K_s * F^{(m)}), \\quad e_s = \\frac{1}{w(s)^2} (K_s * E)\n    $$\n3.  使用提供的公式计算 $\\mathrm{FSS}(s)$：\n    $$\n    \\mathrm{FSS}(s) = 1 - \\frac{\\mathrm{MSE}(s)}{\\mathrm{MSE}_{\\mathrm{ref}}(s)} = 1 - \\frac{\\sum_{j=1}^{N_x} \\sum_{i=1}^{N_y} ( f_s(j,i) - o_s(j,i) )^2}{\\sum_{j=1}^{N_x} \\sum_{i=1}^{N_y} ( f_s(j,i)^2 + o_s(j,i)^2 )}\n    $$\n    如果分母 $\\mathrm{MSE}_{\\mathrm{ref}}(s)$ 为零（这仅在场 $F$ 和 $O$ 都恒为零时发生），我们设置 $\\mathrm{FSS}(s) = 1$。\n\n第三，我们确定每个预报的“有效尺度” $s^\\ast$。给定一个临界技巧阈值 $q$，有效尺度定义为评分达到或超过阈值的最小尺度 $s \\in \\mathcal{S}$：\n$$\ns^\\ast = \\min \\{ s \\in \\mathcal{S} : \\mathrm{FSS}(s) \\ge q \\}\n$$\n如果 $\\mathcal{S}$ 中没有尺度达到阈值 $q$，则有效尺度设置为最大测试尺度 $\\max(\\mathcal{S})$。此过程应用于 $M$ 个集合成员中的每一个，以获得一组有效尺度 $\\{s^\\ast_m\\}_{m=1}^M$，并应用于集合平均预报 $E$，以获得其有效尺度 $s^\\ast_{\\text{mean}}$。\n\n最后，我们为每个测试用例计算所需的输出统计数据：\n1.  集合平均的有效尺度，$s^\\ast_{\\text{mean}}$。\n2.  单个集合成员有效尺度的中位数，$\\mathrm{median}(\\{s^\\ast_m\\})$。\n3.  单个集合成员有效尺度的方差，$\\mathrm{var}(\\{s^\\ast_m\\})$。\n\n整个过程在一个程序中实现，使用 `NumPy` 库进行高效的数组操作，使用 `SciPy` 库进行卷积运算，并遵循指定的执行环境。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"grid_size\": (64, 64),\n            \"dx_km\": 2.0,\n            \"obs_params\": {\"center\": (32, 32), \"radius\": 8},\n            \"ensemble_params\": [\n                {\"center\": (27, 28), \"radius\": 8}, {\"center\": (29, 34), \"radius\": 9},\n                {\"center\": (34, 31), \"radius\": 7}, {\"center\": (36, 35), \"radius\": 9},\n                {\"center\": (30, 37), \"radius\": 8}, {\"center\": (38, 26), \"radius\": 10},\n                {\"center\": (32, 32), \"radius\": 8}, {\"center\": (33, 33), \"radius\": 8},\n                {\"center\": (31, 30), \"radius\": 8}, {\"center\": (35, 28), \"radius\": 7},\n                {\"center\": (26, 37), \"radius\": 11}, {\"center\": (37, 38), \"radius\": 10},\n            ],\n            \"scales_km\": np.array([2.0, 6.0, 10.0, 14.0, 18.0, 22.0, 26.0]),\n            \"q\": 0.5,\n        },\n        {\n            \"grid_size\": (64, 64),\n            \"dx_km\": 2.0,\n            \"obs_params\": {\"center\": (30, 30), \"radius\": 6},\n            \"ensemble_params\": [\n                {\"center\": (30, 30), \"radius\": 6} for _ in range(6)\n            ],\n            \"scales_km\": np.array([2.0, 4.0, 6.0, 8.0, 10.0]),\n            \"q\": 0.7,\n        },\n        {\n            \"grid_size\": (64, 64),\n            \"dx_km\": 2.0,\n            \"obs_params\": {\"center\": (28, 35), \"radius\": 10},\n            \"ensemble_params\": [\n                {\"center\": (5, 5), \"radius\": 4}, {\"center\": (55, 55), \"radius\": 4},\n                {\"center\": (5, 55), \"radius\": 4}, {\"center\": (55, 5), \"radius\": 4},\n                {\"center\": (10, 50), \"radius\": 3}, {\"center\": (50, 10), \"radius\": 3},\n                {\"center\": (20, 20), \"radius\": 3}, {\"center\": (44, 44), \"radius\": 3},\n            ],\n            \"scales_km\": np.array([2.0, 10.0, 18.0, 26.0, 34.0]),\n            \"q\": 0.5,\n        }\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        all_results.append(solve_case(case))\n        \n    # Format the final output string exactly as required\n    inner_parts = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef create_disk_field(grid_size, center, radius):\n    \"\"\"\n    Creates a binary grid with a filled circle (disk).\n    \n    Args:\n        grid_size (tuple): (Ny, Nx) dimensions of the grid.\n        center (tuple): (cx, cy) 0-indexed center coordinates (column, row).\n        radius (int): Radius of the disk in grid cells.\n        \n    Returns:\n        np.ndarray: A 2D binary grid.\n    \"\"\"\n    ny, nx = grid_size\n    cx, cy = center\n    radius_sq = radius**2\n    \n    y_indices, x_indices = np.ogrid[:ny, :nx]\n    \n    dist_sq = (x_indices - cx)**2 + (y_indices - cy)**2\n    \n    return (dist_sq = radius_sq).astype(float)\n\ndef get_window_width(s, dx):\n    \"\"\"\n    Calculates the odd integer window width closest to s/dx.\n    Tie-breaking rule: choose the larger odd integer.\n    \"\"\"\n    val = s / dx\n    w = int(round(val))\n    if w == 0:\n        return 1\n    if w % 2 == 0:\n        if val  w:\n            w = w - 1\n        else:\n            w = w + 1\n    return w\n\ndef calculate_fss_over_scales(forecast_field, obs_field, scales_km, dx):\n    \"\"\"\n    Computes the Fraction Skill Score (FSS) over a range of scales.\n    \n    Args:\n        forecast_field, obs_field (np.ndarray): The 2D fields.\n        scales_km (np.ndarray): Array of scales in kilometers.\n        dx (float): Grid spacing in kilometers.\n        \n    Returns:\n        np.ndarray: Array of FSS values for each scale.\n    \"\"\"\n    fss_values = []\n    for s in scales_km:\n        w = get_window_width(s, dx)\n        kernel = np.ones((w, w))\n        \n        o_s = convolve(obs_field, kernel, mode='reflect') / (w**2)\n        f_s = convolve(forecast_field, kernel, mode='reflect') / (w**2)\n        \n        mse = np.sum((f_s - o_s)**2)\n        mse_ref = np.sum(f_s**2 + o_s**2)\n        \n        if mse_ref == 0:\n            fss = 1.0\n        else:\n            fss = 1.0 - (mse / mse_ref)\n        fss_values.append(fss)\n        \n    return np.array(fss_values)\n\ndef find_useful_scale(fss_values, scales_km, q):\n    \"\"\"\n    Determines the useful scale from a set of FSS values.\n    \"\"\"\n    above_threshold = np.where(fss_values >= q)[0]\n    \n    if len(above_threshold) > 0:\n        return scales_km[above_threshold[0]]\n    else:\n        return np.max(scales_km)\n\ndef solve_case(case_params):\n    \"\"\"\n    Solves a single test case.\n    \"\"\"\n    grid_size = case_params[\"grid_size\"]\n    dx_km = case_params[\"dx_km\"]\n    obs_params = case_params[\"obs_params\"]\n    ensemble_params = case_params[\"ensemble_params\"]\n    scales_km = case_params[\"scales_km\"]\n    q = case_params[\"q\"]\n\n    # Create observation field\n    obs_field = create_disk_field(grid_size, obs_params[\"center\"], obs_params[\"radius\"])\n\n    # Process each ensemble member\n    ensemble_fields = []\n    member_useful_scales = []\n    for params in ensemble_params:\n        member_field = create_disk_field(grid_size, params[\"center\"], params[\"radius\"])\n        ensemble_fields.append(member_field)\n        \n        fss_values = calculate_fss_over_scales(member_field, obs_field, scales_km, dx_km)\n        s_star = find_useful_scale(fss_values, scales_km, q)\n        member_useful_scales.append(s_star)\n\n    member_useful_scales = np.array(member_useful_scales)\n\n    # Calculate statistics for members\n    median_s_star = np.median(member_useful_scales)\n    variance_s_star = np.var(member_useful_scales)\n    \n    # Process ensemble mean\n    ensemble_mean_field = np.mean(ensemble_fields, axis=0)\n    mean_fss_values = calculate_fss_over_scales(ensemble_mean_field, obs_field, scales_km, dx_km)\n    mean_s_star = find_useful_scale(mean_fss_values, scales_km, q)\n    \n    return [mean_s_star, median_s_star, variance_s_star]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}