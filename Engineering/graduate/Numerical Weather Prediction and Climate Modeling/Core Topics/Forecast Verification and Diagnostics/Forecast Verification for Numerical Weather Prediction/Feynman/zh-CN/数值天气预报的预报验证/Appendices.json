{
    "hands_on_practices": [
        {
            "introduction": "本练习是检验离散事件预报（例如“有大雨”或“无大雨”）的基石。通过构建一个 $2 \\times 2$ 的列联表，我们可以计算出描述预报性能不同方面的基本指标，例如正确探测事件的能力（命中率）与“狼来了”的倾向（误报率）之间的权衡。该练习提供了一种具体的方式来理解这些基本概念。",
            "id": "4044107",
            "problem": "针对一个确定性的数值天气预报（NWP）模型，进行了一项为期 $N=24$ 个连续日的单站日降水量验证研究。对于每一天 $i$，都有一个模型预报的24小时累积降水量（单位：毫米）和一个用于验证的观测值（单位：毫米）。考虑由10毫米降水阈值定义的二元事件：当且仅当24小时累积降水量大于或等于10毫米时，该事件发生。\n\n第 $i=1,\\dots,24$ 天的预报-观测对 $(f_i, o_i)$ 如下所示（所有数值单位均为毫米）：\n- 第1天：$f_1=12$, $o_1=13$\n- 第2天：$f_2=8$, $o_2=0$\n- 第3天：$f_3=15$, $o_3=5$\n- 第4天：$f_4=4$, $o_4=11$\n- 第5天：$f_5=20$, $o_5=22$\n- 第6天：$f_6=9$, $o_6=7$\n- 第7天：$f_7=11$, $o_7=9$\n- 第8天：$f_8=6$, $o_8=12$\n- 第9天：$f_9=14$, $o_9=16$\n- 第10天：$f_{10}=7$, $o_{10}=0$\n- 第11天：$f_{11}=10$, $o_{11}=9$\n- 第12天：$f_{12}=3$, $o_{12}=2$\n- 第13天：$f_{13}=13$, $o_{13}=4$\n- 第14天：$f_{14}=2$, $o_{14}=0$\n- 第15天：$f_{15}=18$, $o_{15}=19$\n- 第16天：$f_{16}=0$, $o_{16}=0$\n- 第17天：$f_{17}=16$, $o_{17}=14$\n- 第18天：$f_{18}=5$, $o_{18}=6$\n- 第19天：$f_{19}=9$, $o_{19}=15$\n- 第20天：$f_{20}=10$, $o_{20}=10$\n- 第21天：$f_{21}=11$, $o_{21}=8$\n- 第22天：$f_{22}=1$, $o_{22}=0$\n- 第23天：$f_{23}=7$, $o_{23}=13$\n- 第24天：$f_{24}=13$, $o_{24}=11$\n\n任务：\n1. 应用条件概率的基本原理于二元预报和观测指标，根据 $2\\times 2$ 列联表的计数和样本量 $N$，为命中率、空报率、基础率和精确度提供精确定义。\n2. 以10毫米为阈值对预报和观测值进行处理，构建包含命中、空报、漏报和正确否定计数的 $2\\times 2$ 列联表。\n3. 根据您定义的量，计算该预报系统的Peirce技巧评分（也称为真实技巧统计量）。\n\n将Peirce技巧评分的最终数值答案表示为四舍五入到四位有效数字的小数。",
            "solution": "该问题被验证为科学上合理、定义明确、客观且完整。它是气象预报验证中的一个标准练习。我们开始解题。\n\n根据题目要求，解答分为三个部分。\n\n### 第1步：验证指标的定义\n\n令二元事件用 $E$ 表示。当24小时累积降水量大于或等于10毫米的阈值时，该事件发生。对于每个预报-观测对 $(f_i, o_i)$，我们定义二元指示变量：\n- $I_{f,i} = 1$ 如果预报事件发生 ($f_i \\ge 10$)，否则 $I_{f,i} = 0$ ($f_i  10$)。\n- $I_{o,i} = 1$ 如果观测到事件发生 ($o_i \\ge 10$)，否则 $I_{o,i} = 0$ ($o_i  10$)。\n\n验证基于 $N$ 天样本中每对数据的四种可能结果，这些结果汇总在一个 $2 \\times 2$ 列联表中。每个类别的计数如下：\n- **命中 ($a$)**：事件被正确预报的次数。$a = \\sum_{i=1}^{N} I_{f,i} I_{o,i}$。\n- **空报 ($b$)**：预报了事件但事件未发生的次数。$b = \\sum_{i=1}^{N} I_{f,i} (1 - I_{o,i})$。\n- **漏报 ($c$)**：事件发生了但未被预报的次数。$c = \\sum_{i=1}^{N} (1 - I_{f,i}) I_{o,i}$。\n- **正确否定 ($d$)**：事件未发生且被正确地预报为不发生的次数。$d = \\sum_{i=1}^{N} (1 - I_{f,i}) (1 - I_{o,i})$。\n\n总案例数为 $N = a + b + c + d$。\n\n使用这些基本计数，我们可以根据条件概率的原理定义所要求的验证指标：\n\n1.  **命中率 ($H$)**：也称为探测概率（POD），是在事件发生的条件下，预报为“是”的条件概率。它是被正确预报的观测事件所占的比例。\n    $$H = P(\\text{forecast yes} | \\text{observed yes}) = \\frac{P(\\text{forecast yes} \\cap \\text{observed yes})}{P(\\text{observed yes})} = \\frac{a/N}{(a+c)/N} = \\frac{a}{a+c}$$\n\n2.  **空报率 ($F$)**：也称为虚警概率（POFD），是在事件未发生的条件下，预报为“是”的条件概率。它是被错误地预报为事件的非事件所占的比例。\n    $$F = P(\\text{forecast yes} | \\text{observed no}) = \\frac{P(\\text{forecast yes} \\cap \\text{observed no})}{P(\\text{observed no})} = \\frac{b/N}{(b+d)/N} = \\frac{b}{b+d}$$\n\n3.  **基础率 ($S$)**：也称为样本气候学概率，是样本中事件发生的无条件概率。它是所有案例中观测到事件发生的比例。\n    $$S = P(\\text{observed yes}) = \\frac{a+c}{N}$$\n\n4.  **精确度**：也称为成功率，是在预报事件发生的条件下，事件确实发生的条件概率。它是正确的“是”预报所占的比例。\n    $$\\text{Precision} = P(\\text{observed yes} | \\text{forecast yes}) = \\frac{P(\\text{observed yes} \\cap \\text{forecast yes})}{P(\\text{forecast yes})} = \\frac{a/N}{(a+b)/N} = \\frac{a}{a+b}$$\n\n### 第2步：构建列联表\n\n降水阈值为$10$毫米。我们将$N=24$个预报-观测对 $(f_i, o_i)$ 中的每一个分类到四个类别之一：命中、空报、漏报或正确否定。\n\n- 第1天：($12, 13$) $\\implies f_1 \\ge 10, o_1 \\ge 10 \\implies$ **命中**\n- 第2天：($8, 0$) $\\implies f_2  10, o_2  10 \\implies$ **正确否定**\n- 第3天：($15, 5$) $\\implies f_3 \\ge 10, o_3  10 \\implies$ **空报**\n- 第4天：($4, 11$) $\\implies f_4  10, o_4 \\ge 10 \\implies$ **漏报**\n- 第5天：($20, 22$) $\\implies f_5 \\ge 10, o_5 \\ge 10 \\implies$ **命中**\n- 第6天：($9, 7$) $\\implies f_6  10, o_6  10 \\implies$ **正确否定**\n- 第7天：($11, 9$) $\\implies f_7 \\ge 10, o_7  10 \\implies$ **空报**\n- 第8天：($6, 12$) $\\implies f_8  10, o_8 \\ge 10 \\implies$ **漏报**\n- 第9天：($14, 16$) $\\implies f_9 \\ge 10, o_9 \\ge 10 \\implies$ **命中**\n- 第10天：($7, 0$) $\\implies f_{10}  10, o_{10}  10 \\implies$ **正确否定**\n- 第11天：($10, 9$) $\\implies f_{11} \\ge 10, o_{11}  10 \\implies$ **空报**\n- 第12天：($3, 2$) $\\implies f_{12}  10, o_{12}  10 \\implies$ **正确否定**\n- 第13天：($13, 4$) $\\implies f_{13} \\ge 10, o_{13}  10 \\implies$ **空报**\n- 第14天：($2, 0$) $\\implies f_{14}  10, o_{14}  10 \\implies$ **正确否定**\n- 第15天：($18, 19$) $\\implies f_{15} \\ge 10, o_{15} \\ge 10 \\implies$ **命中**\n- 第16天：($0, 0$) $\\implies f_{16}  10, o_{16}  10 \\implies$ **正确否定**\n- 第17天：($16, 14$) $\\implies f_{17} \\ge 10, o_{17} \\ge 10 \\implies$ **命中**\n- 第18天：($5, 6$) $\\implies f_{18}  10, o_{18}  10 \\implies$ **正确否定**\n- 第19天：($9, 15$) $\\implies f_{19}  10, o_{19} \\ge 10 \\implies$ **漏报**\n- 第20天：($10, 10$) $\\implies f_{20} \\ge 10, o_{20} \\ge 10 \\implies$ **命中**\n- 第21天：($11, 8$) $\\implies f_{21} \\ge 10, o_{21}  10 \\implies$ **空报**\n- 第22天：($1, 0$) $\\implies f_{22}  10, o_{22}  10 \\implies$ **正确否定**\n- 第23天：($7, 13$) $\\implies f_{23}  10, o_{23} \\ge 10 \\implies$ **漏报**\n- 第24天：($13, 11$) $\\implies f_{24} \\ge 10, o_{24} \\ge 10 \\implies$ **命中**\n\n统计这些结果：\n- 命中 ($a$) = $7$\n- 空报 ($b$) = $5$\n- 漏报 ($c$) = $4$\n- 正确否定 ($d$) = $8$\n\n总计数为 $a+b+c+d = 7+5+4+8 = 24$，与样本量 $N$ 相符。得到的 $2 \\times 2$ 列联表如下：\n$$\n\\begin{array}{c|cc|c}\n\\multicolumn{2}{c}{}  \\multicolumn{2}{c}{\\text{观测}} \\\\\n\\multicolumn{2}{c}{}  \\text{是 (事件)}  \\text{否 (非事件)} \\\\\n\\cline{2-4}\n\\text{预报}  \\text{是}  a=7  b=5 \\\\\n \\text{否}  c=4  d=8 \\\\\n\\hline\n\\end{array}\n$$\n\n### 第3步：计算Peirce技巧评分\n\nPeirce技巧评分（PSS），也称为真实技巧统计量（TSS），定义为命中率（$H$）与空报率（$F$）之差：\n$$ \\text{PSS} = H - F $$\n使用第1步中的定义和第2步中的列联表计数：\n$$ \\text{PSS} = \\frac{a}{a+c} - \\frac{b}{b+d} $$\n代入数值 $a=7$, $b=5$, $c=4$ 和 $d=8$：\n$$ H = \\frac{7}{7+4} = \\frac{7}{11} $$\n$$ F = \\frac{5}{5+8} = \\frac{5}{13} $$\n因此，Peirce技巧评分为：\n$$ \\text{PSS} = \\frac{7}{11} - \\frac{5}{13} $$\n为了计算精确值，我们找到一个公分母，即 $11 \\times 13 = 143$：\n$$ \\text{PSS} = \\frac{7 \\times 13}{143} - \\frac{5 \\times 11}{143} = \\frac{91 - 55}{143} = \\frac{36}{143} $$\n为了获得最终的数值答案，我们计算这个分数的小数值：\n$$ \\text{PSS} = \\frac{36}{143} \\approx 0.25174825... $$\n题目要求答案四舍五入到四位有效数字。前四位有效数字是 $2, 5, 1, 7$。第五位数字是 $4$，因此不进位。\n$$ \\text{PSS} \\approx 0.2517 $$",
            "answer": "$$\\boxed{0.2517}$$"
        },
        {
            "introduction": "现代天气预报通常提供概率而非简单的“是/否”答案。评估这些概率预报不仅仅是看准确性；我们还需要知道这些概率是否值得信赖（可靠性），以及它们是否能成功地区分不同的结果（分辨率）。本练习将演示如何分解布莱尔分数 (Brier Score)，以诊断概率预报系统的这两个关键属性，尤其是在罕见事件这种具有挑战性的情景下。",
            "id": "4044089",
            "problem": "给定一组针对一个二元事件的概率预测，该事件定义为特定地点的$99$百分位阵风超限，同时还给出了相应的二元结果，用以指示事件是否发生（$1$）或未发生（$0$）。设随机变量 $O \\in \\{0,1\\}$ 表示观测到的事件指示符，随机变量 $P \\in [0,1]$ 表示预测概率。布里尔分数（Brier Score）从第一性原理定义为二元事件概率预测的均方误差，即 $$\\mathrm{BS} = \\mathbb{E}\\big[(P - O)^2\\big],$$ 其经验对应项为 $$\\widehat{\\mathrm{BS}} = \\frac{1}{N}\\sum_{i=1}^{N} (p_i - o_i)^2,$$ 其中 $N$ 是预测-观测对的数量，$(p_i, o_i)$ 是其实现值。\n\n将布里尔分数分解为量化校准度（calibration）和清晰度（sharpness）的分量的一种原则性方法，始于全期望定律和以预测类别为条件的思想。定义单位区间 $[0,1]$ 的一个划分为 $K$ 个不相交的概率分组，其边界为 $0 = b_0  b_1  \\dots  b_K = 1$。根据每个预测值 $p_i$ 所属的区间 $(b_{k-1}, b_k]$，将其分配到对应的分组索引 $g_i \\in \\{1,\\dots,K\\}$。对于分组 $k$，定义组内经验平均预测为 $$f_k = \\frac{1}{n_k}\\sum_{i:g_i = k} p_i,$$ 组内经验事件频率为 $$o_k = \\frac{1}{n_k}\\sum_{i:g_i = k} o_i,$$ 其中 $n_k$ 是落入分组 $k$ 的样本数量。总体事件基础发生率为 $$\\bar{o} = \\frac{1}{N}\\sum_{i=1}^{N} o_i.$$ 可靠性（reliability）分量是衡量整个划分上的校准误差的指标，而解析度（resolution）分量则量化了条件事件频率与总体基础发生率的差异程度。\n\n从 $P$、$O$、布里尔分数 $\\mathrm{BS}$、全期望定律以及按预测类别进行经验条件化的定义出发，推导出可靠性分量和解析度分量的表达式。这些表达式应是关于 $\\{n_k, f_k, o_k, \\bar{o}\\}_{k=1}^{K}$ 的函数，并且不假设对该分解有任何先验知识，而是完全基于这些基本原理。然后，实现一个程序，为以下测试套件计算经验可靠性分量和解析度分量。为保证数值稳定性和科学真实性，当某个分组的 $n_k = 0$ 时，在求和计算中应忽略该分组。\n\n该测试套件使用一组共享的分组边界 $$\\{b_k\\}_{k=0}^{6} = \\{0,\\,0.05,\\,0.15,\\,0.35,\\,0.55,\\,0.75,\\,1.0\\},$$ 并包含四个案例，每个案例都通过确定性地构建预测序列 $\\{p_i\\}$ 和结果序列 $\\{o_i\\}$ 来指定：\n\n- 案例1（具有稀疏正例的常规校准）：$N = 50$，$$\\{p_i\\} = \\underbrace{[0.01,\\dots,0.01]}_{44\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0.10,0.10,0.10,0.10]}_{4\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0.30,0.30]}_{2\\ \\text{次}},$$ $$\\{o_i\\} = \\underbrace{[0,\\dots,0]}_{44\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0,0,0,0]}_{4\\ \\text{次}} \\mathbin{\\|} [1,1].$$\n- 案例2（无观测事件的边界情况）：$N = 40$，$$\\{p_i\\} = \\underbrace{[0.01,\\dots,0.01]}_{30\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0.20,\\dots,0.20]}_{5\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0.40,\\dots,0.40]}_{5\\ \\text{次}},$$ $$\\{o_i\\} = \\underbrace{[0,\\dots,0]}_{40\\ \\text{次}}.$$\n- 案例3（具有混合校准度的极度稀疏正例）：$N = 100$，$$\\{p_i\\} = \\underbrace{[0.02,\\dots,0.02]}_{95\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0.50,\\dots,0.50]}_{5\\ \\text{次}},$$ $$\\{o_i\\} = \\underbrace{[0,\\dots,0]}_{95\\ \\text{次}} \\mathbin{\\|} [0,0,0,0,1].$$\n- 案例4（边际基础发生率与$99$百分位一致，但在高概率分组中存在严重失准）：$N = 60$, $$\\{p_i\\} = \\underbrace{[0.60,\\dots,0.60]}_{20\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0.20,\\dots,0.20]}_{20\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0.01,\\dots,0.01]}_{20\\ \\text{次}},$$ $$\\{o_i\\} = \\underbrace{[0,\\dots,0,1,1,1]}_{\\text{在20个0.60的条目中只有3个1}} \\mathbin{\\|} \\underbrace{[0,\\dots,0]}_{20\\ \\text{次}} \\mathbin{\\|} \\underbrace{[0,\\dots,0]}_{20\\ \\text{次}}.$$\n\n您的程序必须为每个案例计算基于上述分组方案的经验可靠性分量和解析度分量，求和时仅计入 $n_k > 0$ 的分组。输出结果是无量纲的。将每个分量四舍五入到$6$位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是一个双元素列表，按上述顺序包含一个案例的可靠性和解析度，例如：$$[[\\mathrm{REL}_1,\\mathrm{RES}_1],[\\mathrm{REL}_2,\\mathrm{RES}_2],[\\mathrm{REL}_3,\\mathrm{RES}_3],[\\mathrm{REL}_4,\\mathrm{RES}_4]]$$。通过在您的推导中讨论稀疏正例如何影响像$99$百分位阵风这样的罕见事件的可靠性项中的校准度估计和解析度项中的清晰度，来确保科学真实性。",
            "solution": "我们从二元事件概率预测的基本定义开始。设 $O \\in \\{0,1\\}$ 表示观测结果，当 $99$ 百分位阵风事件发生时 $O = 1$，否则 $O = 0$；设 $P \\in [0,1]$ 表示 $O=1$ 的预测概率。布里尔分数（Brier Score）定义为 $$\\mathrm{BS} = \\mathbb{E}\\big[(P - O)^2\\big],$$ 其经验形式为 $$\\widehat{\\mathrm{BS}} = \\frac{1}{N}\\sum_{i=1}^{N}(p_i - o_i)^2,$$ 其中 $N$ 是样本大小，$(p_i,o_i)$ 是 $(P,O)$ 的实现值。\n\n为了理解校准度（calibration）和清晰度（sharpness），我们寻求一种分解方法，其分量分别用于衡量预测概率与观测频率的匹配程度（可靠性）以及条件频率在不同预测类别间的差异程度（解析度）。该推导使用全期望定律以及基于 $[0,1]$ 区间划分定义的预测类别进行条件化。\n\n构建一个边界为 $0 = b_0  b_1  \\dots  b_K = 1$ 的划分，并定义类别索引 $G \\in \\{1,\\dots,K\\}$，使得当 $P \\in (b_{k-1}, b_k]$ 时 $G = k$。令 $w_k = \\mathbb{P}(G = k)$ 表示类别概率（经验上 $w_k = n_k/N$），$f_k = \\mathbb{E}[P \\mid G = k]$ 表示类内平均预测概率，$o_k = \\mathbb{E}[O \\mid G = k]$ 表示类内事件频率。总体事件基础发生率是 $\\bar{o} = \\mathbb{E}[O]$（经验上 $\\bar{o} = \\frac{1}{N}\\sum_{i=1}^{N} o_i$）。\n\n我们首先写出\n$$\n\\mathrm{BS} = \\mathbb{E}\\big[(P - O)^2\\big] = \\mathbb{E}\\Big( \\mathbb{E}\\big[(P - O)^2 \\mid G\\big] \\Big).\n$$\n对任意类别 $k$，展开条件期望：\n$$\n\\mathbb{E}\\big[(P - O)^2 \\mid G=k\\big]\n= \\mathbb{E}\\big[P^2 \\mid G=k\\big] - 2\\,\\mathbb{E}\\big[P O \\mid G=k\\big] + \\mathbb{E}\\big[O^2 \\mid G=k\\big].\n$$\n由于 $O \\in \\{0,1\\}$，我们有 $O^2 = O$，因此 $\\mathbb{E}\\big[O^2 \\mid G=k\\big] = o_k$。接下来，将 $\\mathbb{E}\\big[P^2 \\mid G=k\\big]$ 分解为 $\\mathrm{Var}(P \\mid G=k) + f_k^2$。对于交叉项，注意 $\\mathbb{E}\\big[P O \\mid G=k\\big] = \\mathbb{E}\\big[\\,\\mathbb{E}[P O \\mid O,G=k]\\,\\big]$。在不假设独立性的情况下，我们使用双线性展开\n$$\n\\mathbb{E}\\big[P O \\mid G=k\\big] = \\mathbb{E}\\big[(P - f_k) O \\mid G=k\\big] + f_k\\,\\mathbb{E}\\big[O \\mid G=k\\big] = \\mathrm{Cov}(P,O \\mid G=k) + f_k\\, o_k.\n$$\n代入可得\n$$\n\\mathbb{E}\\big[(P - O)^2 \\mid G=k\\big]\n= \\mathrm{Var}(P \\mid G=k) + f_k^2 - 2\\,\\mathrm{Cov}(P,O \\mid G=k) - 2\\,f_k\\,o_k + o_k.\n$$\n一种广泛使用的操作性分解方法，通过考虑由唯一概率值定义的预测类别，用代表性的类别平均值取代了详细的类内散布项；在这种构造下，$\\mathrm{Var}(P \\mid G=k) = 0$ 且 $\\mathrm{Cov}(P,O \\mid G=k) = 0$，因为在类别内 $P$ 是恒定的。更一般地，对于有限宽度的分组，当分组宽度较窄时，这些项很小，经验分解被解释为一种近似，当分组宽度缩小且类别代表唯一的概率时，这种近似变得精确。在此代表性类别假设下，条件贡献简化为\n$$\n\\mathbb{E}\\big[(P - O)^2 \\mid G=k\\big] \\approx (f_k - o_k)^2 + o_k (1 - o_k).\n$$\n使用权重 $w_k = \\mathbb{P}(G=k)$ 对所有类别进行平均，得到\n$$\n\\mathrm{BS} \\approx \\sum_{k=1}^{K} w_k (f_k - o_k)^2 + \\sum_{k=1}^{K} w_k\\,o_k(1 - o_k).\n$$\n对 $O$ 应用全方差定律，\n$$\n\\mathbb{E}[O(1 - O)] = \\bar{o}(1 - \\bar{o}) - \\sum_{k=1}^{K} w_k \\,\\big(o_k - \\bar{o}\\big)^2,\n$$\n我们得到 Murphy 分解：\n$$\n\\mathrm{BS} \\approx \\underbrace{\\sum_{k=1}^{K} w_k (f_k - o_k)^2}_{\\text{可靠性}} \\;-\\; \\underbrace{\\sum_{k=1}^{K} w_k \\,\\big(o_k - \\bar{o}\\big)^2}_{\\text{解析度}} \\;+\\; \\underbrace{\\bar{o}(1 - \\bar{o})}_{\\text{不确定性}}.\n$$\n在经验计算中，我们取 $w_k = n_k/N$，$f_k$ 和 $o_k$ 作为组内样本均值，忽略 $n_k = 0$ 的分组，并报告\n$$\n\\widehat{\\mathrm{REL}} = \\sum_{k: n_k>0} \\frac{n_k}{N}\\,\\big(f_k - o_k\\big)^2,\\qquad\n\\widehat{\\mathrm{RES}} = \\sum_{k: n_k>0} \\frac{n_k}{N}\\,\\big(o_k - \\bar{o}\\big)^2.\n$$\n\n算法设计：\n- 输入：预测概率 $\\{p_i\\}_{i=1}^{N}$，二元结果 $\\{o_i\\}_{i=1}^{N}$，以及固定的分组边界 $\\{b_k\\}_{k=0}^{K}$。\n- 步骤1：计算 $\\bar{o} = \\frac{1}{N}\\sum_{i=1}^{N} o_i$。\n- 步骤2：通过提供的边界，使用右闭区间 $(b_{k-1}, b_k]$ 将每个 $p_i$ 分配到一个分组索引 $g_i$，并按惯例将 $p_i = 0$ 包含在第一个分组中。\n- 步骤3：对于每个 $n_k > 0$ 的分组 $k$，计算 $f_k$、$o_k$ 和 $w_k = n_k/N$，然后如上累加 $\\widehat{\\mathrm{REL}}$ 和 $\\widehat{\\mathrm{RES}}$。\n- 步骤4：为每个案例输出一对 $[\\widehat{\\mathrm{REL}}, \\widehat{\\mathrm{RES}}]$，四舍五入到6位小数。\n\n稀疏正例对罕见事件的解释：\n- 当事件基础发生率 $\\bar{o}$ 很小时（例如$99$百分位阵风超限事件），大多数分组——尤其是那些包含低预测概率的分组——其 $o_k$ 将接近于0。这意味着 $\\widehat{\\mathrm{RES}}$ 会很小，除非某些分组的条件频率 $o_k$ 显著偏离 $\\bar{o}$。稀疏的正例会导致样本量少的分组中的 $o_k$ 存在统计噪声，这会夸大或缩小 $\\widehat{\\mathrm{REL}}$，具体取决于 $f_k$ 是否与实现的随机 $o_k$ 相匹配。例如，一个包含两个样本且两个均为观测事件（$o_k \\approx 1$）的分组，而其预测均值 $f_k$ 远低于1，会产生一个很大的 $(f_k - o_k)^2$ 项，即使其背后的预测系统在平均上是良好校准的；相反，没有观测到事件的分组无法揭示过度预测，除非通过非零的 $f_k$，而这会直接贡献于 $\\widehat{\\mathrm{REL}}$。因此，稀疏正例给校准度估计带来了挑战：$\\widehat{\\mathrm{REL}}$ 对 $o_k$ 的抽样变异性很敏感，而 $\\widehat{\\mathrm{RES}}$ 往往会很小，除非预测能有意义地将少数正例结果与基础发生率区分开来。这在零观测事件的边界情况中尤其明显，此时 $\\bar{o} = 0$ 导致 $\\widehat{\\mathrm{RES}} = 0$，只剩下 $\\widehat{\\mathrm{REL}}$，表明相对于零基础发生率存在过度预测。\n\n我们对四个确定性测试案例实施计算，使用共享的分组边界 $[0,\\,0.05,\\,0.15,\\,0.35,\\,0.55,\\,0.75,\\,1.0]$，结果四舍五入到6位小数，并将结果聚合为用方括号括起来的单个逗号分隔的数对列表。\n\n以下是实现该算法并为指定案例生成结果的Python代码：\n```python\n# Python 3.12 program to compute reliability and resolution components\n# of the Brier Score for a rare (99th percentile wind gust) event across\n# specified test cases using fixed probability bins.\n\nimport numpy as np\n\ndef brier_components(probabilities, outcomes, bin_edges):\n    \"\"\"\n    Compute empirical reliability and resolution components of the Brier Score\n    given forecast probabilities, binary outcomes, and bin edges.\n\n    Parameters:\n        probabilities (np.ndarray): Array of forecast probabilities in [0,1].\n        outcomes (np.ndarray): Array of binary outcomes in {0,1}.\n        bin_edges (np.ndarray): Monotonically increasing array of bin edges covering [0,1].\n\n    Returns:\n        (float, float): Reliability and Resolution components.\n    \"\"\"\n    p = np.asarray(probabilities, dtype=float)\n    o = np.asarray(outcomes, dtype=float)\n\n    # Basic validations (silent assumptions for this self-contained task)\n    if p.shape != o.shape:\n        raise ValueError(\"Forecast probabilities and outcomes must have the same length.\")\n    if np.any(p  0) or np.any(p > 1):\n        raise ValueError(\"Forecast probabilities must lie within [0,1].\")\n    if not np.all(np.logical_or(o == 0, o == 1)):\n        raise ValueError(\"Outcomes must be binary in {0,1}.\")\n\n    N = len(p)\n    # Overall base rate\n    o_bar = np.mean(o)\n\n    # Bin assignment: right-closed intervals (b_{k-1}, b_k].\n    # Special-case p == 0 to put them into the first bin.\n    # numpy.digitize with right=True implements (b_{k-1}  x = b_k).\n    bin_idx = np.digitize(p, bin_edges, right=True)\n    # bin_idx ranges from 0..len(bin_edges); map 0 to 1 (first bin)\n    bin_idx = np.clip(bin_idx, 1, len(bin_edges) - 1)\n\n    reliability = 0.0\n    resolution = 0.0\n\n    # Iterate over bins and compute weighted contributions\n    for k in range(1, len(bin_edges)):\n        members = (bin_idx == k)\n        n_k = int(np.sum(members))\n        if n_k == 0:\n            continue\n        f_k = float(np.mean(p[members]))\n        o_k = float(np.mean(o[members]))\n        w_k = n_k / N\n        reliability += w_k * (f_k - o_k) ** 2\n        resolution += w_k * (o_k - o_bar) ** 2\n\n    return reliability, resolution\n\ndef round6(x):\n    return float(f\"{x:.6f}\")\n\ndef solve():\n    # Shared bin edges\n    bin_edges = np.array([0.0, 0.05, 0.15, 0.35, 0.55, 0.75, 1.0], dtype=float)\n\n    test_cases = []\n\n    # Case 1: N=50\n    p1 = np.array([0.01] * 44 + [0.10] * 4 + [0.30] * 2, dtype=float)\n    o1 = np.array([0] * 44 + [0] * 4 + [1, 1], dtype=float)\n    test_cases.append((p1, o1))\n\n    # Case 2: N=40, all zeros\n    p2 = np.array([0.01] * 30 + [0.20] * 5 + [0.40] * 5, dtype=float)\n    o2 = np.array([0] * 40, dtype=float)\n    test_cases.append((p2, o2))\n\n    # Case 3: N=100, one positive among high-probability group\n    p3 = np.array([0.02] * 95 + [0.50] * 5, dtype=float)\n    o3 = np.array([0] * 95 + [0, 0, 0, 0, 1], dtype=float)\n    test_cases.append((p3, o3))\n\n    # Case 4: N=60, miscalibration with high probability bin\n    p4 = np.array([0.60] * 20 + [0.20] * 20 + [0.01] * 20, dtype=float)\n    # Only 3 ones among the 0.60 group; others zero\n    o4 = np.array([0] * 17 + [1, 1, 1] + [0] * 20 + [0] * 20, dtype=float)\n    test_cases.append((p4, o4))\n\n    results = []\n    for p, o in test_cases:\n        rel, res = brier_components(p, o, bin_edges)\n        results.append([round6(rel), round6(res)])\n    \n    # Return a string representation of the final list\n    return f\"[{','.join(str(pair) for pair in results)}]\"\n\n# The final answer is the output of the solve() function.\n# print(solve())\n```",
            "answer": "[[0.020488, 0.038400],[0.008375, 0.000000],[0.008600, 0.001900],[0.052000, 0.005000]]"
        },
        {
            "introduction": "对于空间预报（例如降水图），传统的评分如均方根误差（RMSE）可能会产生误导，因为一个小的位置误差可能导致巨大的惩罚（即“双重惩罚”问题）。基于对象的方法，如结构-振幅-位置（SAL）指标，通过将预报和观测到的特征作为实体进行比较，提供了更有洞察力的评估。本练习将 SAL 与 RMSE 进行对比，以突显我们如何能更深入、更全面地理解模型预测天气现象空间特征的能力。",
            "id": "4044117",
            "problem": "考虑代表数值天气预报和检验分析的二维网格化降水场。设预报场表示为 $F:\\Omega \\to \\mathbb{R}_{\\ge 0}$，观测/分析场表示为 $O:\\Omega \\to \\mathbb{R}_{\\ge 0}$，其中 $\\Omega = \\{0,1,\\ldots,n_x-1\\} \\times \\{0,1,\\ldots,n_y-1\\}$ 索引了网格单元的中心。所有降水强度必须被视为单位为毫米/小时 (mm/h) 的非负标量。目标是计算两个检验指标，并用它们来推断误差的性质：\n\n1. 一种逐像素的均方根误差 (RMSE)，根据函数空间中欧几里得距离的第一性原理定义。\n2. 一种基于对象的结构-振幅-位置 (SAL) 三元组，旨在通过质量和矩的构造来评估降水场的空间和结构特征。\n\n基本依据和定义：\n\n- 场 $X$ 在 $\\Omega$ 上的经验平均值为 $\\bar{X} = \\frac{1}{|\\Omega|} \\sum_{(i,j)\\in\\Omega} X_{i,j}$。\n- 逐像素均方根误差源于 $L^2$ 距离：$\\mathrm{RMSE}(F,O) = \\sqrt{\\frac{1}{|\\Omega|} \\sum_{(i,j)\\in\\Omega} \\left(F_{i,j} - O_{i,j}\\right)^2}$。RMSE 必须以毫米/小时 (mm/h) 为单位报告，并四舍五入到三位小数。\n- 场 $X$ 相对于 $\\Omega$ 的质心为 $\\mathbf{x}_X = \\left(\\frac{\\sum_{(i,j)\\in\\Omega} X_{i,j} \\, i}{\\sum_{(i,j)\\in\\Omega} X_{i,j}}, \\frac{\\sum_{(i,j)\\in\\Omega} X_{i,j} \\, j}{\\sum_{(i,j)\\in\\Omega} X_{i,j}}\\right)$，前提是 $\\sum_{(i,j)\\in\\Omega} X_{i,j} > 0$。如果 $\\sum_{(i,j)\\in\\Omega} X_{i,j} = 0$，则质心未定义，必须按下文所述进行明确处理。\n- 用于归一化位置距离的区域直径为 $D = \\sqrt{(n_x - 1)^2 + (n_y - 1)^2}$。\n\n对象识别和缩放体积：\n\n- 为了识别场 $X$ 中的连续降水对象，定义一个阈值 $t$ 为 $t = \\max\\left(0.1, \\, 0.15 \\cdot q_{95}\\right)$，其中 $q_{95}$ 是来自 $F$ 和 $O$ 两场所有强度值并集的第95百分位数。然后构造二值掩码 $M_X = \\{(i,j)\\in\\Omega : X_{i,j} \\ge t\\}$。\n- 场 $X$ 中的一个降水对象是 $M_X$ 中的一个最大连通分量，使用4邻域连通（北、南、东、西邻接）。\n- 对于场 $X$ 中的每个对象 $j$，定义其最大强度 $R_{j,\\max} = \\max_{(i,j)\\in\\text{obj}_j} X_{i,j}$ 和其对象总和 $V_j = \\sum_{(i,j)\\in\\text{obj}_j} X_{i,j}$。对象 $j$ 的缩放体积为 $v_j = \\frac{V_j}{R_{j,\\max}}$。该场的缩放体积摘要为 $S_X^\\star = \\sum_j v_j$。如果没有对象（即 $M_X$ 为空），则 $S_X^\\star = 0$。\n\n需要计算的SAL分量：\n\n- 振幅 $A$ 是由经验平均值构造的归一化平均差：如果 $\\bar{F} + \\bar{O} > 0$，则 $A = \\frac{\\bar{F} - \\bar{O}}{\\frac{1}{2}(\\bar{F} + \\bar{O})}$；如果 $\\bar{F} = \\bar{O} = 0$，则 $A = 0$。\n- 位置 $L$ 是两项之和 $L = L_1 + L_2$：\n  - 如果两个质心都存在，则 $L_1 = \\frac{\\|\\mathbf{x}_F - \\mathbf{x}_O\\|_2}{D}$；如果两个场都为空（总质量均为零），则 $L_1 = 0$；如果只有一个场为空，则设 $L_1 = 1$。\n  - $L_2 = \\left| r_F - r_O \\right|$，其中 $r_X = \\left(\\frac{\\sum_{(i,j)\\in\\Omega} X_{i,j} \\, \\|\\mathbf{x}_{i,j} - \\mathbf{x}_X\\|_2}{\\sum_{(i,j)\\in\\Omega} X_{i,j}}\\right)\\big/ D$ 是场 $X$ 围绕其质心的归一化一阶径向矩（离散度），且 $\\mathbf{x}_{i,j} = (i,j)$。如果两个场都为空，则设 $r_F = r_O = 0$。如果只有一个场为空，则将空场的离散度设为 $0$，非空场的离散度按上述公式计算。\n- 结构 $S$ 是缩放体积摘要的归一化差异：如果 $S_F^\\star + S_O^\\star > 0$，则 $S = \\frac{S_F^\\star - S_O^\\star}{\\frac{1}{2}(S_F^\\star + S_O^\\star)}$；如果 $S_F^\\star = S_O^\\star = 0$，则 $S = 0$。\n\n基于SAL与RMSE的认知分类：\n\n- 定义阈值 $a_{\\mathrm{th}} = 0.5$, $s_{\\mathrm{th}} = 0.5$ 和 $l_{\\mathrm{th}} = 0.3$（均为无量纲）。\n- 对每个测试用例，计算三个布尔指标：\n  - 位移主导误差：$\\mathrm{disp} = \\left(|A|  a_{\\mathrm{th}}\\right) \\wedge \\left(|S|  s_{\\mathrm{th}}\\right) \\wedge \\left(L > l_{\\mathrm{th}}\\right)$。\n  - 振幅偏差主导误差：$\\mathrm{amp} = \\left(|A| > a_{\\mathrm{th}}\\right) \\wedge \\left(L  l_{\\mathrm{th}}\\right)$。\n  - 结构差异主导误差：$\\mathrm{struc} = \\left(|S| > s_{\\mathrm{th}}\\right) \\wedge \\left(L  l_{\\mathrm{th}}\\right) \\wedge \\left(|A|  a_{\\mathrm{th}}\\right)$。\n\n测试套件和要求输出：\n\n在 $n_x = n_y = 5$ 的 $\\Omega$ 上使用以下 $(F,O)$ 对的测试套件。所有条目单位均为毫米/小时 (mm/h)。\n\n- 测试用例1（理想情况，近乎完美匹配）：\n  - $O_1 =$ \n    $\\begin{bmatrix}\n    0  0  1  0  0 \\\\\n    0  2  3  2  0 \\\\\n    1  3  5  3  1 \\\\\n    0  2  3  2  0 \\\\\n    0  0  1  0  0\n    \\end{bmatrix}$,\n  - $F_1 = O_1$。\n- 测试用例2（均匀振幅偏差，结构和位置相同）：\n  - $O_2 = O_1$,\n  - $F_2 = 1.5 \\cdot O_1$。\n- 测试用例3（纯位移，振幅和结构相似）：\n  - $O_3 = O_1$,\n  - $F_3$ 是 $O_1$ 向右平移一个网格单元并用零填充：\n    $\\begin{bmatrix}\n    0  0  0  1  0 \\\\\n    0  0  2  3  2 \\\\\n    0  1  3  5  3 \\\\\n    0  0  2  3  2 \\\\\n    0  0  0  1  0\n    \\end{bmatrix}$。\n- 测试用例4（结构差异：一个细长对象对两个紧凑对象；振幅相等）：\n  - $O_4 =$ \n    $\\begin{bmatrix}\n    0  0  0  0  0 \\\\\n    0  0  4  0  0 \\\\\n    0  0  4  0  0 \\\\\n    0  0  4  0  0 \\\\\n    0  0  0  0  0\n    \\end{bmatrix}$,\n  - $F_4 =$ \n    $\\begin{bmatrix}\n    0  0  0  0  0 \\\\\n    0  3  0  3  0 \\\\\n    0  3  0  3  0 \\\\\n    0  0  0  0  0 \\\\\n    0  0  0  0  0\n    \\end{bmatrix}$。\n- 测试用例5（边界条件：两者均为空）：\n  - $O_5 =$ $5\\times 5$ 的零矩阵,\n  - $F_5 =$ $5\\times 5$ 的零矩阵。\n- 测试用例6（边界条件：预报非空，观测为空）：\n  - $O_6 =$ $5\\times 5$ 的零矩阵,\n  - $F_6 = O_1$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中按顺序包含每个测试用例的结果，每个结果是一个包含七个条目的列表：$[A,S,L,\\mathrm{RMSE},\\mathrm{disp},\\mathrm{amp},\\mathrm{struc}]$，其中 $A$、$S$ 和 $L$ 是四舍五入到三位小数的无单位浮点数，$\\mathrm{RMSE}$ 是以毫米/小时 (mm/h) 为单位、四舍五入到三位小数的浮点数，三个布尔值是上面定义的认知分类。将六个测试用例的结果聚合成一个顶层列表，以逗号分隔的列表形式打印，并用方括号括起来；例如，格式应精确为 $[[A_1,S_1,L_1,\\mathrm{RMSE}_1,\\mathrm{disp}_1,\\mathrm{amp}_1,\\mathrm{struc}_1],[A_2,\\ldots],\\ldots]$，不含任何额外文本。",
            "solution": "该问题陈述是基于数值天气预报检验的既定原则的一个定义明确的计算任务。它要求实现均方根误差 (RMSE) 和结构-振幅-位置 (SAL) 检验指标。所有的定义、公式和边界条件都已明确给出，并且在数学和科学上都是合理的。测试用例旨在探究预报误差的不同方面，并在包括空场等边界情况在内的一系列条件下测试实现。该问题是自洽的、客观的，并有科学依据。\n\n### 步骤1：提取已知信息\n- **场**：预报 $F:\\Omega \\to \\mathbb{R}_{\\ge 0}$ 和观测 $O:\\Omega \\to \\mathbb{R}_{\\ge 0}$。\n- **区域**：$\\Omega = \\{0,1,\\ldots,n_x-1\\} \\times \\{0,1,\\ldots,n_y-1\\}$，其中 $n_x=n_y=5$。\n- **经验平均值**：$\\bar{X} = \\frac{1}{|\\Omega|} \\sum_{(i,j)\\in\\Omega} X_{i,j}$。\n- **RMSE**：$\\mathrm{RMSE}(F,O) = \\sqrt{\\frac{1}{|\\Omega|} \\sum_{(i,j)\\in\\Omega} \\left(F_{i,j} - O_{i,j}\\right)^2}$。\n- **质心**：如果 $\\sum X_{i,j} > 0$，则为 $\\mathbf{x}_X = \\left(\\frac{\\sum X_{i,j} \\, i}{\\sum X_{i,j}}, \\frac{\\sum X_{i,j} \\, j}{\\sum X_{i,j}}\\right)$。\n- **区域直径**：$D = \\sqrt{(n_x - 1)^2 + (n_y - 1)^2}$。\n- **对象阈值**：$t = \\max\\left(0.1, \\, 0.15 \\cdot q_{95}\\right)$，其中 $q_{95}$ 是 $F \\cup O$ 中所有值的第95百分位数。\n- **对象定义**：在 $M_X = \\{(i,j)\\in\\Omega : X_{i,j} \\ge t\\}$ 中使用4邻域连通的最大连通分量。\n- **缩放体积摘要**：$S_X^\\star = \\sum_j v_j = \\sum_j \\frac{V_j}{R_{j,\\max}}$，其中 $V_j$ 是对象 $j$ 的总和，$R_{j,\\max}$ 是对象 $j$ 中的最大强度。如果没有对象，则 $S_X^\\star=0$。\n- **振幅 (A)**：如果 $\\bar{F} + \\bar{O} > 0$，则 $A = \\frac{\\bar{F} - \\bar{O}}{\\frac{1}{2}(\\bar{F} + \\bar{O})}$；否则 $A=0$。\n- **位置 (L)**：$L = L_1 + L_2$。\n  - $L_1$：如果两个质心都存在，则为 $\\frac{\\|\\mathbf{x}_F - \\mathbf{x}_O\\|_2}{D}$。如果两个场都为空，则 $L_1=0$。如果只有一个场为空，则 $L_1=1$。\n  - $L_2$：$|r_F - r_O|$，其中 $r_X = \\left(\\frac{\\sum X_{i,j} \\, \\|\\mathbf{x}_{i,j} - \\mathbf{x}_X\\|_2}{\\sum X_{i,j}}\\right)\\big/ D$ 是归一化离散度。如果场为空，其离散度为 $0$。\n- **结构 (S)**：如果 $S_F^\\star + S_O^\\star > 0$，则 $S = \\frac{S_F^\\star - S_O^\\star}{\\frac{1}{2}(S_F^\\star + S_O^\\star)}$；否则 $S=0$。\n- **认知分类阈值**：$a_{\\mathrm{th}} = 0.5$, $s_{\\mathrm{th}} = 0.5$, $l_{\\mathrm{th}} = 0.3$。\n- **分类规则**：\n  - $\\mathrm{disp} = \\left(|A|  a_{\\mathrm{th}}\\right) \\wedge \\left(|S|  s_{\\mathrm{th}}\\right) \\wedge \\left(L > l_{\\mathrm{th}}\\right)$\n  - $\\mathrm{amp} = \\left(|A| > a_{\\mathrm{th}}\\right) \\wedge \\left(L  l_{\\mathrm{th}}\\right)$\n  - $\\mathrm{struc} = \\left(|S| > s_{\\mathrm{th}}\\right) \\wedge \\left(L  l_{\\mathrm{th}}\\right) \\wedge \\left(|A|  a_{\\mathrm{th}}\\right)$\n- **测试用例**：提供了六对 $(F, O)$ 矩阵。\n\n### 步骤2：使用提取的已知信息进行验证\n该问题有科学依据，借鉴了已有的预报检验文献（SAL指标）。这是一个适定问题，所有术语、常数和边界情况都已定义，确保每个测试用例都有唯一的解。语言客观、精确。该问题是自洽且内部一致的；定义中没有矛盾。任务的数值性质使其可以形式化和验证。对简化案例的手动检查证实了其逻辑成立，即使命名示例（例如“纯位移”）的分类结果由于特定阈值的设定而与直觉不符，这也是一个有效且有启发性的结果。该问题不违反任何无效性标准。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将提供完整的解决方案。\n\n### 基于原则的设计\n解决方案将构造成模块化函数，每个函数负责整个计算的一个不同部分。这种方法反映了指标本身的分层定义。\n\n1.  **主循环**：一个主函数将协调整个过程，遍历提供的每个测试用例。对于每个 $(F, O)$ 对，它将调用一个统一的计算函数。\n\n2.  **RMSE计算**：一个实现标准均方根误差公式的简单函数，利用`numpy`进行高效的数组操作。RMSE是逐像素误差平均大小的度量。\n\n3.  **振幅 (A) 计算**：一个计算区域平均降水量归一化差异的函数。按规定，特别注意处理两个场的平均值均为零的边界情况。`A`分离出总降水量中的系统性偏差。\n\n4.  **位置 (L) 计算**：这是最复杂的部分，将进一步分解。\n    *   一个辅助函数为给定的降水场计算质心（场的一阶矩）。如果场的总质量为零，它将返回一个特殊值。\n    *   另一个辅助函数计算围绕质心的归一化离散度（一阶径向矩）。它能正确处理空场。\n    *   主`L`函数整合这些部分来计算 $L_1$（质心之间的距离）和 $L_2$（离散度之差），并正确应用针对一个或两个场为空的特定规则。`L`量化了降水模式在整体位置和空间范围上的误差。\n\n5.  **结构 (S) 计算**：该部分评估降水特征的形状和大小。\n    *   首先，根据两个场组合降水数据的第95百分位数计算对象识别阈值 $t$。\n    *   一个辅助函数使用 `scipy.ndimage.label` 和4连通性规则识别高于此阈值的连续对象。对于每个对象，它计算“缩放体积”($V_j / R_{j,\\max}$)，该值捕捉了对象的“峰度”。一个大而平坦的对象将比一个总降水量相同但小而尖峰的对象具有更大的缩放体积。\n    *   `S`函数然后计算这些缩放体积总和（$S_F^\\star$ 和 $S_O^\\star$）的归一化差异。它能正确处理分母为零的情况。`S`量化了与观测相比，预报产生的降水对象平均而言是过大/过平还是过小/过尖。\n\n6.  **认知分类**：最后一个函数接收计算出的 $A$、$S$ 和 $L$ 值，并应用带有给定阈值的布尔逻辑来分类主导误差类型。\n\n这种模块化设计确保每个物理概念（振幅、位置、结构）都封装在自己的计算块中，从而提高了代码的清晰度、可验证性以及对问题定义的遵循度。所有数值结果都按要求四舍五入到三位小数。\n\n以下是实现该算法并为指定案例生成结果的Python代码：\n```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, maximum, sum as nd_sum\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Test case definitions\n    O1 = np.array([\n        [0, 0, 1, 0, 0],\n        [0, 2, 3, 2, 0],\n        [1, 3, 5, 3, 1],\n        [0, 2, 3, 2, 0],\n        [0, 0, 1, 0, 0]\n    ], dtype=float)\n    \n    F1 = O1.copy()\n    \n    O2 = O1.copy()\n    F2 = 1.5 * O1\n    \n    O3 = O1.copy()\n    F3 = np.array([\n        [0, 0, 0, 1, 0],\n        [0, 0, 2, 3, 2],\n        [0, 1, 3, 5, 3],\n        [0, 0, 2, 3, 2],\n        [0, 0, 0, 1, 0]\n    ], dtype=float)\n    \n    O4 = np.array([\n        [0, 0, 0, 0, 0],\n        [0, 0, 4, 0, 0],\n        [0, 0, 4, 0, 0],\n        [0, 0, 4, 0, 0],\n        [0, 0, 0, 0, 0]\n    ], dtype=float)\n    F4 = np.array([\n        [0, 0, 0, 0, 0],\n        [0, 3, 0, 3, 0],\n        [0, 3, 0, 3, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ], dtype=float)\n    \n    O5 = np.zeros((5, 5), dtype=float)\n    F5 = np.zeros((5, 5), dtype=float)\n    \n    O6 = np.zeros((5, 5), dtype=float)\n    F6 = O1.copy()\n\n    test_cases = [\n        (F1, O1),\n        (F2, O2),\n        (F3, O3),\n        (F4, O4),\n        (F5, O5),\n        (F6, O6),\n    ]\n\n    results = []\n    for F, O in test_cases:\n        case_result = compute_all_metrics(F, O)\n        results.append(case_result)\n\n    # Formatting the output string\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    return output_str\n\ndef compute_all_metrics(F, O):\n    \"\"\"\n    Computes all specified metrics for a given Forecast (F) and Observation (O) pair.\n    \"\"\"\n    nx, ny = F.shape\n    D = np.sqrt((nx - 1)**2 + (ny - 1)**2)\n    \n    # Grid coordinates for moment calculations\n    j_grid, i_grid = np.meshgrid(np.arange(ny), np.arange(nx))\n\n    # Calculate individual metrics\n    rmse = np.sqrt(np.mean((F - O)**2))\n    A = compute_A(F, O)\n    L = compute_L(F, O, i_grid, j_grid, D)\n    S = compute_S(F, O)\n    \n    # Epistemic classification\n    a_th, s_th, l_th = 0.5, 0.5, 0.3\n    disp = (abs(A)  a_th) and (abs(S)  s_th) and (L > l_th)\n    amp = (abs(A) > a_th) and (L  l_th)\n    struc = (abs(S) > s_th) and (L  l_th) and (abs(A)  a_th)\n    \n    return [\n        round(A, 3), \n        round(S, 3), \n        round(L, 3), \n        round(rmse, 3), \n        disp, \n        amp, \n        struc\n    ]\n\ndef compute_A(F, O):\n    \"\"\"Computes the Amplitude component A.\"\"\"\n    mean_F = np.mean(F)\n    mean_O = np.mean(O)\n    denominator = 0.5 * (mean_F + mean_O)\n    if denominator > 0:\n        return (mean_F - mean_O) / denominator\n    return 0.0\n\ndef get_com(X, i_grid, j_grid):\n    \"\"\"Computes the center of mass for a field.\"\"\"\n    total_mass = np.sum(X)\n    if total_mass == 0:\n        return None\n    com_i = np.sum(X * i_grid) / total_mass\n    com_j = np.sum(X * j_grid) / total_mass\n    return np.array([com_i, com_j])\n\ndef get_dispersion(X, com, i_grid, j_grid, D):\n    \"\"\"Computes the normalized dispersion r_X.\"\"\"\n    total_mass = np.sum(X)\n    if total_mass == 0:\n        return 0.0\n    distances = np.sqrt((i_grid - com[0])**2 + (j_grid - com[1])**2)\n    radial_moment = np.sum(X * distances)\n    return (radial_moment / total_mass) / D\n\ndef compute_L(F, O, i_grid, j_grid, D):\n    \"\"\"Computes the Location component L.\"\"\"\n    total_mass_F = np.sum(F)\n    total_mass_O = np.sum(O)\n    \n    com_F = get_com(F, i_grid, j_grid)\n    com_O = get_com(O, i_grid, j_grid)\n    \n    # Calculate L1\n    if total_mass_F == 0 and total_mass_O == 0:\n        L1 = 0.0\n    elif total_mass_F == 0 or total_mass_O == 0:\n        L1 = 1.0\n    else:\n        L1 = np.linalg.norm(com_F - com_O) / D\n        \n    # Calculate L2\n    r_F = get_dispersion(F, com_F if com_F is not None else np.array([0,0]), i_grid, j_grid, D)\n    r_O = get_dispersion(O, com_O if com_O is not None else np.array([0,0]), i_grid, j_grid, D)\n    L2 = abs(r_F - r_O)\n    \n    return L1 + L2\n\ndef compute_S_star(X, t):\n    \"\"\"Computes the scaled volume summary S* for a field.\"\"\"\n    mask = X >= t\n    if not np.any(mask):\n        return 0.0\n        \n    connectivity_structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    labeled_array, num_features = label(mask, structure=connectivity_structure)\n    \n    if num_features == 0:\n        return 0.0\n        \n    object_sums = nd_sum(X, labeled_array, index=np.arange(1, num_features + 1))\n    object_maxima = maximum(X, labeled_array, index=np.arange(1, num_features + 1))\n\n    scaled_volumes = np.divide(object_sums, object_maxima, \n                              out=np.zeros_like(object_sums, dtype=float), \n                              where=object_maxima!=0)\n\n    return np.sum(scaled_volumes)\n\ndef compute_S(F, O):\n    \"\"\"Computes the Structure component S.\"\"\"\n    combined_values = np.concatenate((F.flatten(), O.flatten()))\n    if combined_values.size == 0 or np.all(combined_values == 0):\n        q95 = 0.0\n    else:\n        q95 = np.percentile(combined_values[combined_values > 0], 95) if np.any(combined_values > 0) else 0.0\n\n    t = max(0.1, 0.15 * q95)\n\n    S_F_star = compute_S_star(F, t)\n    S_O_star = compute_S_star(O, t)\n\n    denominator = 0.5 * (S_F_star + S_O_star)\n    if denominator > 0:\n        return (S_F_star - S_O_star) / denominator\n    return 0.0\n\n# The final answer is the output of running the code.\n# if __name__ == \"__main__\":\n#     print(solve())\n```",
            "answer": "[[0.0, 0.0, 0.0, 0.0, False, False, False],[0.4, 0.0, 0.0, 0.612, False, False, False],[-0.041, -0.016, 0.177, 0.775, False, False, False],[0.0, 0.507, 0.177, 0.733, False, False, True],[0.0, 0.0, 0.0, 0.0, False, False, False],[2.0, 2.0, 1.242, 1.225, False, False, False]]"
        }
    ]
}