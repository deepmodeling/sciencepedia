{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in analyzing any atmospheric phenomenon is developing a robust method to track its state. For the Madden-Julian Oscillation, the Real-time Multivariate MJO (RMM) indices are the operational standard, quantifying its amplitude and propagation through a two-dimensional phase space. This foundational exercise guides you through the process of computing the $RMM1$ and $RMM2$ indices from first principles, providing hands-on experience with the essential techniques of data standardization, projection onto Empirical Orthogonal Functions (EOFs), and seasonal variance normalization that underpin modern MJO monitoring. ",
            "id": "4101233",
            "problem": "You are given daily anomalies of Outgoing Longwave Radiation (OLR) and zonal winds at $850$ hPa and $200$ hPa over a fixed set of longitudes associated with the intraseasonal signal of the Madden–Julian Oscillation (MJO). Your task is to compute two Real-time Multivariate MJO (RMM) indices, $RMM1$ and $RMM2$, for each day by projecting a combined standardized anomaly state onto provided Empirical Orthogonal Function (EOF) patterns and then standardizing by seasonal variance.\n\nStarting from a first-principles basis in Empirical Orthogonal Function analysis, assume the following:\n\n- The anomaly state at day $t$, for each field, is a vector of length $L$ over longitudes. Let $x_{\\mathrm{OLR}}(t) \\in \\mathbb{R}^{L}$ be the daily OLR anomalies in $\\mathrm{W\\, m^{-2}}$, $x_{u850}(t) \\in \\mathbb{R}^{L}$ be the daily zonal wind anomalies at $850$ hPa in $\\mathrm{m\\, s^{-1}}$, and $x_{u200}(t) \\in \\mathbb{R}^{L}$ be the daily zonal wind anomalies at $200$ hPa in $\\mathrm{m\\, s^{-1}}$.\n- To form a dimensionless combined state that equalizes the variance contributions of each field, define scaling coefficients $\\alpha_{\\mathrm{OLR}}$, $\\alpha_{u850}$, and $\\alpha_{u200}$. Construct the standardized combined state\n$$\ny(t) = \\left[\\alpha_{\\mathrm{OLR}}\\, x_{\\mathrm{OLR}}(t),\\ \\alpha_{u850}\\, x_{u850}(t),\\ \\alpha_{u200}\\, x_{u200}(t)\\right] \\in \\mathbb{R}^{3L},\n$$\nby concatenation of the three scaled anomaly vectors in the order OLR, $u850$, $u200$.\n- The provided two EOF patterns, $e_{1}$ and $e_{2}$, are each vectors in $\\mathbb{R}^{3L}$, associated with the leading two modes of the covariance operator of the standardized combined state. In the standardized space, the two EOF patterns must be orthonormal. If the given patterns are not orthonormal, you must first orthonormalize them using the Gram–Schmidt process in $\\mathbb{R}^{3L}$, and then normalize them to unit norm.\n- The principal component amplitudes for day $t$ are obtained by the orthogonal projection of $y(t)$ onto each EOF,\n$$\na_{1}(t) = \\langle y(t), e_{1} \\rangle,\\quad a_{2}(t) = \\langle y(t), e_{2} \\rangle,\n$$\nwhere $\\langle \\cdot, \\cdot \\rangle$ denotes the Euclidean inner product in $\\mathbb{R}^{3L}$.\n- To account for seasonal modulation of variance, let $\\sigma_{1}(t)  0$ and $\\sigma_{2}(t)  0$ denote seasonal variance scales associated with the first and second EOF patterns on day $t$. Define the standardized indices\n$$\nRMM1(t) = \\frac{a_{1}(t)}{\\sigma_{1}(t)},\\quad RMM2(t) = \\frac{a_{2}(t)}{\\sigma_{2}(t)}.\n$$\nThe indices $RMM1(t)$ and $RMM2(t)$ are dimensionless numbers with no physical unit.\n\nImplement a program that performs the above calculations for the following scientifically plausible and self-consistent test suite. Use $L = 4$ longitudes. Use scaling coefficients $\\alpha_{\\mathrm{OLR}} = 1/40$, $\\alpha_{u850} = 1/5$, and $\\alpha_{u200} = 1/10$.\n\nThe provided raw EOF patterns for the standardized space are given as variable-partitioned blocks, each of length $L$, concatenated in the order OLR, $u850$, $u200$. Let\n- For the first EOF, $e_{1}^{\\mathrm{raw}} \\in \\mathbb{R}^{12}$,\n$$\ne_{1,\\mathrm{OLR}} = [0.5,\\ 0.5,\\ -0.5,\\ -0.5],\\quad\ne_{1,u850} = [0.5,\\ -0.5,\\ 0.5,\\ -0.5],\\quad\ne_{1,u200} = [0.25,\\ 0.25,\\ 0.25,\\ 0.25],\n$$\nand take $e_{1}^{\\mathrm{raw}}$ to be the concatenation of these three $L$-vectors.\n- For the second EOF, $e_{2}^{\\mathrm{raw}} \\in \\mathbb{R}^{12}$,\n$$\ne_{2,\\mathrm{OLR}} = [0.5,\\ -0.5,\\ 0.5,\\ -0.5],\\quad\ne_{2,u850} = [-0.5,\\ -0.5,\\ 0.5,\\ 0.5],\\quad\ne_{2,u200} = [-0.25,\\ 0.25,\\ -0.25,\\ 0.25],\n$$\nand take $e_{2}^{\\mathrm{raw}}$ to be the concatenation of these three $L$-vectors.\n\nBefore projecting, apply Gram–Schmidt orthonormalization to $\\{e_{1}^{\\mathrm{raw}}, e_{2}^{\\mathrm{raw}}\\}$ in $\\mathbb{R}^{12}$ to produce an orthonormal set $\\{e_{1}, e_{2}\\}$ with $\\lVert e_{i} \\rVert_{2} = 1$ and $\\langle e_{1}, e_{2} \\rangle = 0$.\n\nCompute $RMM1$ and $RMM2$ for the following $4$ test cases (each case provides daily anomalies for OLR in $\\mathrm{W\\, m^{-2}}$, $u850$ in $\\mathrm{m\\, s^{-1}}$, $u200$ in $\\mathrm{m\\, s^{-1}}$, and seasonal variance scales, all at the same $L = 4$ longitudes):\n\n- Case $1$ (general balanced projection):\n  - $x_{\\mathrm{OLR}} = [-20,\\ -15,\\ 15,\\ 20]$,\n  - $x_{u850} = [4,\\ -4,\\ 4,\\ -4]$,\n  - $x_{u200} = [-8,\\ -8,\\ -8,\\ -8]$,\n  - $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.2$.\n- Case $2$ (dominant second mode alignment):\n  - $x_{\\mathrm{OLR}} = [-20,\\ 20,\\ -20,\\ 20]$,\n  - $x_{u850} = [-4,\\ -4,\\ 4,\\ 4]$,\n  - $x_{u200} = [-8,\\ 8,\\ -8,\\ 8]$,\n  - $\\sigma_{1} = 1.4$, $\\sigma_{2} = 0.9$.\n- Case $3$ (zero anomalies, boundary check):\n  - $x_{\\mathrm{OLR}} = [0,\\ 0,\\ 0,\\ 0]$,\n  - $x_{u850} = [0,\\ 0,\\ 0,\\ 0]$,\n  - $x_{u200} = [0,\\ 0,\\ 0,\\ 0]$,\n  - $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.0$.\n- Case $4$ (anti-phase of the first mode):\n  - $x_{\\mathrm{OLR}} = [20,\\ 15,\\ -15,\\ -20]$,\n  - $x_{u850} = [-4,\\ 4,\\ -4,\\ 4]$,\n  - $x_{u200} = [8,\\ 8,\\ 8,\\ 8]$,\n  - $\\sigma_{1} = 0.8$, $\\sigma_{2} = 1.6$.\n\nAll outputs must be dimensionless (no units). Your program should produce a single line of output containing the results as a comma-separated list of $4$ two-element lists, each two-element list being $[RMM1,RMM2]$ for the corresponding case, rounded to six decimal places. There must be no spaces in the output. For example, the format must be exactly like\n$$\n[[r_{11},r_{12}],[r_{21},r_{22}],[r_{31},r_{32}],[r_{41},r_{42}]],\n$$\nwhere $r_{i1}$ and $r_{i2}$ are the rounded floats for case $i$.\n\nThe problem assesses your ability to derive the projection and normalization from the foundational definition of Empirical Orthogonal Function analysis, construct a standardized combined state, enforce orthonormality of provided patterns, and correctly produce dimensionless indices. Implement the calculation without any external input; all data are provided above within this problem statement. Ensure scientific realism by preserving the physical units in inputs and using the specified scaling to obtain a dimensionless combined state before projection and seasonal standardization. The final outputs must be floats.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of climate science and statistical analysis, specifically Empirical Orthogonal Function (EOF) analysis as applied to the Madden-Julian Oscillation (MJO). The problem is well-posed, providing all necessary data, constants, and a clear, sequential mathematical procedure for calculating the Real-time Multivariate MJO (RMM) indices. The definitions and data are self-consistent, objective, and physically plausible.\n\nThe calculation of the RMM indices $RMM1$ and $RMM2$ for a given day $t$ follows a structured, principle-based procedure. This involves constructing a standardized anomaly state vector, projecting it onto an orthonormal set of EOF patterns, and then scaling the resulting principal component amplitudes by a seasonal variance.\n\nFirst, we define the parameters and input vectors as provided. The number of longitudes is $L=4$. The anomaly state on day $t$ is composed of three fields: Outgoing Longwave Radiation ($x_{\\mathrm{OLR}}(t) \\in \\mathbb{R}^{4}$), zonal wind at $850$ hPa ($x_{u850}(t) \\in \\mathbb{R}^{4}$), and zonal wind at $200$ hPa ($x_{u200}(t) \\in \\mathbb{R}^{4}$).\n\nThe first step is to construct the standardized combined state vector $y(t) \\in \\mathbb{R}^{12}$. This is achieved by scaling each anomaly vector by its respective coefficient and concatenating the results. The scaling coefficients are given as $\\alpha_{\\mathrm{OLR}} = 1/40$, $\\alpha_{u850} = 1/5$, and $\\alpha_{u200} = 1/10$. The combined state is formed as:\n$$\ny(t) = \\left[\\alpha_{\\mathrm{OLR}}\\, x_{\\mathrm{OLR}}(t),\\ \\alpha_{u850}\\, x_{u850}(t),\\ \\alpha_{u200}\\, x_{u200}(t)\\right]\n$$\n\nThe second step is to ensure the EOF patterns, on which the state vector will be projected, form an orthonormal basis. The provided raw patterns are $e_{1}^{\\mathrm{raw}}$ and $e_{2}^{\\mathrm{raw}}$, both in $\\mathbb{R}^{12}$.\n$e_{1}^{\\mathrm{raw}} = [0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.25, 0.25, 0.25, 0.25]$\n$e_{2}^{\\mathrm{raw}} = [0.5, -0.5, 0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.25, 0.25, -0.25, 0.25]$\n\nWe must orthonormalize these vectors using the Gram-Schmidt process. Let $v_1 = e_{1}^{\\mathrm{raw}}$ and $v_2 = e_{2}^{\\mathrm{raw}}$. The orthonormal basis $\\{e_1, e_2\\}$ is found as:\n$u_1 = v_1$\n$e_1 = \\frac{u_1}{\\lVert u_1 \\rVert_2}$\n$u_2 = v_2 - \\langle v_2, e_1 \\rangle e_1$\n$e_2 = \\frac{u_2}{\\lVert u_2 \\rVert_2}$\nwhere $\\langle \\cdot, \\cdot \\rangle$ is the Euclidean inner product.\n\nFirst, we compute the squared norm of $v_1$:\n$$\n\\lVert v_1 \\rVert_2^2 = (4 \\times 0.5^2) + (4 \\times 0.5^2) + (4 \\times 0.25^2) = 1 + 1 + 0.25 = 2.25\n$$\nThus, $\\lVert v_1 \\rVert_2 = \\sqrt{2.25} = 1.5$.\nNext, we compute the inner product of $v_1$ and $v_2$:\n$$\n\\langle v_1, v_2 \\rangle = (0.5 \\cdot 0.5 + 0.5 \\cdot (-0.5) + \\dots) + (0.5 \\cdot (-0.5) + \\dots) + (0.25 \\cdot (-0.25) + \\dots) = 0 + 0 + 0 = 0\n$$\nSince the raw vectors are already orthogonal, the Gram-Schmidt process simplifies to normalization.\n$e_1 = \\frac{v_1}{\\lVert v_1 \\rVert_2} = \\frac{1}{1.5} e_{1}^{\\mathrm{raw}}$.\nFor $e_2$, we have $u_2 = v_2 - \\langle v_2, e_1 \\rangle e_1 = v_2 - 0 = v_2$. We just need to normalize $v_2$.\n$$\n\\lVert v_2 \\rVert_2^2 = (4 \\times 0.5^2) + (4 \\times (-0.5)^2) + (4 \\times (-0.25)^2) = 1 + 1 + 0.25 = 2.25\n$$\nSo, $\\lVert v_2 \\rVert_2 = \\sqrt{2.25} = 1.5$.\n$e_2 = \\frac{v_2}{\\lVert v_2 \\rVert_2} = \\frac{1}{1.5} e_{2}^{\\mathrm{raw}}$.\nThe orthonormal EOFs are $e_1 = (2/3) e_{1}^{\\mathrm{raw}}$ and $e_2 = (2/3) e_{2}^{\\mathrm{raw}}$.\n\nThe third step is to compute the principal component amplitudes, $a_1(t)$ and $a_2(t)$, by projecting the standardized state vector $y(t)$ onto the orthonormal EOFs:\n$$\na_{1}(t) = \\langle y(t), e_{1} \\rangle, \\quad a_{2}(t) = \\langle y(t), e_{2} \\rangle\n$$\n\nThe final step is to standardize these amplitudes using the given seasonal variance scales, $\\sigma_1(t)$ and $\\sigma_2(t)$, to obtain the dimensionless RMM indices:\n$$\nRMM1(t) = \\frac{a_{1}(t)}{\\sigma_{1}(t)}, \\quad RMM2(t) = \\frac{a_{2}(t)}{\\sigma_{2}(t)}\n$$\n\nWe now apply this procedure to each test case.\n\nCase 1:\n- $x_{\\mathrm{OLR}} = [-20, -15, 15, 20]$, $x_{u850} = [4, -4, 4, -4]$, $x_{u200} = [-8, -8, -8, -8]$.\n- $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.2$.\nThe scaled anomaly vectors are:\n$\\alpha_{\\mathrm{OLR}} x_{\\mathrm{OLR}} = [-0.5, -0.375, 0.375, 0.5]$\n$\\alpha_{u850} x_{u850} = [0.8, -0.8, 0.8, -0.8]$\n$\\alpha_{u200} x_{u200} = [-0.8, -0.8, -0.8, -0.8]$\n$y_1 = [-0.5, -0.375, 0.375, 0.5, 0.8, -0.8, 0.8, -0.8, -0.8, -0.8, -0.8, -0.8]$.\nThe principal components are:\n$a_1(1) = \\langle y_1, e_1 \\rangle = \\frac{1}{1.5} \\langle y_1, e_{1}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(-0.875 + 1.6 - 0.8) = \\frac{-0.075}{1.5} = -0.05$.\n$a_2(1) = \\langle y_1, e_2 \\rangle = \\frac{1}{1.5} \\langle y_1, e_{2}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(-0.125 + 0.0 + 0.0) = \\frac{-0.125}{1.5} = -\\frac{1}{12} \\approx -0.083333$.\nThe RMM indices are:\n$RMM1(1) = \\frac{-0.05}{1.0} = -0.05$.\n$RMM2(1) = \\frac{-1/12}{1.2} = \\frac{-1/12}{6/5} = -\\frac{5}{72} \\approx -0.069444$.\n\nCase 2:\n- $x_{\\mathrm{OLR}} = [-20, 20, -20, 20]$, $x_{u850} = [-4, -4, 4, 4]$, $x_{u200} = [-8, 8, -8, 8]$.\n- $\\sigma_{1} = 1.4$, $\\sigma_{2} = 0.9$.\nThe scaled anomaly vectors are:\n$\\alpha_{\\mathrm{OLR}} x_{\\mathrm{OLR}} = [-0.5, 0.5, -0.5, 0.5]$\n$\\alpha_{u850} x_{u850} = [-0.8, -0.8, 0.8, 0.8]$\n$\\alpha_{u200} x_{u200} = [-0.8, 0.8, -0.8, 0.8]$\n$y_2 = [-0.5, 0.5, -0.5, 0.5, -0.8, -0.8, 0.8, 0.8, -0.8, 0.8, -0.8, 0.8]$.\n$a_1(2) = \\frac{1}{1.5} \\langle y_2, e_{1}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(0.0 + 0.0 + 0.0) = 0.0$.\n$a_2(2) = \\frac{1}{1.5} \\langle y_2, e_{2}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(-1.0 + 1.6 + 0.8) = \\frac{1.4}{1.5} = \\frac{14}{15} \\approx 0.933333$.\nThe RMM indices are:\n$RMM1(2) = \\frac{0.0}{1.4} = 0.0$.\n$RMM2(2) = \\frac{14/15}{0.9} = \\frac{14/15}{9/10} = \\frac{14 \\times 10}{15 \\times 9} = \\frac{28}{27} \\approx 1.037037$.\n\nCase 3:\n- $x_{\\mathrm{OLR}} = [0, 0, 0, 0]$, $x_{u850} = [0, 0, 0, 0]$, $x_{u200} = [0, 0, 0, 0]$.\n- $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.0$.\nThe combined state vector $y_3$ is the zero vector. The inner product of the zero vector with any vector is $0$.\n$a_1(3) = 0.0$, $a_2(3) = 0.0$.\nThe RMM indices are:\n$RMM1(3) = \\frac{0.0}{1.0} = 0.0$.\n$RMM2(3) = \\frac{0.0}{1.0} = 0.0$.\n\nCase 4:\n- $x_{\\mathrm{OLR}} = [20, 15, -15, -20]$, $x_{u850} = [-4, 4, -4, 4]$, $x_{u200} = [8, 8, 8, 8]$.\n- $\\sigma_{1} = 0.8$, $\\sigma_{2} = 1.6$.\nThe input anomaly vectors are the negative of those in Case 1. Thus, the combined state vector $y_4 = -y_1$. By the linearity of the inner product, $a_1(4) = \\langle -y_1, e_1 \\rangle = -a_1(1) = 0.05$ and $a_2(4) = \\langle -y_1, e_2 \\rangle = -a_2(1) = 1/12$.\nThe RMM indices are:\n$RMM1(4) = \\frac{0.05}{0.8} = \\frac{1/20}{4/5} = \\frac{5}{80} = \\frac{1}{16} = 0.0625$.\n$RMM2(4) = \\frac{1/12}{1.6} = \\frac{1/12}{8/5} = \\frac{5}{96} \\approx 0.052083$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Real-time Multivariate MJO (RMM) indices for a set of test cases.\n    \"\"\"\n    # Define problem constants and raw EOF patterns\n    L = 4\n    alpha_olr = 1 / 40\n    alpha_u850 = 1 / 5\n    alpha_u200 = 1 / 10\n\n    e1_raw_olr = np.array([0.5, 0.5, -0.5, -0.5])\n    e1_raw_u850 = np.array([0.5, -0.5, 0.5, -0.5])\n    e1_raw_u200 = np.array([0.25, 0.25, 0.25, 0.25])\n    e1_raw = np.concatenate([e1_raw_olr, e1_raw_u850, e1_raw_u200])\n\n    e2_raw_olr = np.array([0.5, -0.5, 0.5, -0.5])\n    e2_raw_u850 = np.array([-0.5, -0.5, 0.5, 0.5])\n    e2_raw_u200 = np.array([-0.25, 0.25, -0.25, 0.25])\n    e2_raw = np.concatenate([e2_raw_olr, e2_raw_u850, e2_raw_u200])\n\n    raw_eofs = [e1_raw, e2_raw]\n\n    # Perform Gram-Schmidt orthonormalization on the raw EOF patterns.\n    # The process is required by the problem statement, even if vectors might be\n    # already orthogonal.\n    orthonormal_eofs = []\n    for v in raw_eofs:\n        u = np.copy(v)\n        for e in orthonormal_eofs:\n            # Project u onto the basis vector e and subtract\n            proj = np.dot(u, e) * e\n            u -= proj\n        \n        # Normalize the resulting vector\n        norm = np.linalg.norm(u)\n        if norm > 1e-12:  # Tolerance for floating point precision\n            orthonormal_eofs.append(u / norm)\n    \n    e1, e2 = orthonormal_eofs[0], orthonormal_eofs[1]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x_olr\": np.array([-20, -15, 15, 20]),\n            \"x_u850\": np.array([4, -4, 4, -4]),\n            \"x_u200\": np.array([-8, -8, -8, -8]),\n            \"sigma1\": 1.0,\n            \"sigma2\": 1.2\n        },\n        {\n            \"x_olr\": np.array([-20, 20, -20, 20]),\n            \"x_u850\": np.array([-4, -4, 4, 4]),\n            \"x_u200\": np.array([-8, 8, -8, 8]),\n            \"sigma1\": 1.4,\n            \"sigma2\": 0.9\n        },\n        {\n            \"x_olr\": np.array([0, 0, 0, 0]),\n            \"x_u850\": np.array([0, 0, 0, 0]),\n            \"x_u200\": np.array([0, 0, 0, 0]),\n            \"sigma1\": 1.0,\n            \"sigma2\": 1.0\n        },\n        {\n            \"x_olr\": np.array([20, 15, -15, -20]),\n            \"x_u850\": np.array([-4, 4, -4, 4]),\n            \"x_u200\": np.array([8, 8, 8, 8]),\n            \"sigma1\": 0.8,\n            \"sigma2\": 1.6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Construct the standardized combined state vector y(t)\n        y_olr = alpha_olr * case[\"x_olr\"]\n        y_u850 = alpha_u850 * case[\"x_u850\"]\n        y_u200 = alpha_u200 * case[\"x_u200\"]\n        \n        y = np.concatenate([y_olr, y_u850, y_u200])\n\n        # Step 2: Compute principal component amplitudes a1 and a2\n        a1 = np.dot(y, e1)\n        a2 = np.dot(y, e2)\n\n        # Step 3: Compute the standardized RMM indices\n        rmm1 = a1 / case[\"sigma1\"]\n        rmm2 = a2 / case[\"sigma2\"]\n        \n        results.append([rmm1, rmm2])\n\n    # Final print statement in the exact required format.\n    # The format must be [[r11,r12],[r21,r22],...] with no spaces.\n    inner_strings = [f\"[{round(r[0], 6)},{round(r[1], 6)}]\" for r in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "With a method to track the MJO, we can now investigate the physical mechanisms that drive its signature eastward propagation. A leading theory posits that the slow eastward movement is enabled by the gradual moistening of the atmospheric column ahead of the MJO's main convective center. This practice delves into the Moist Static Energy (MSE) budget, a powerful diagnostic framework for testing this theory, allowing you to quantify the contributions of different physical processes—such as horizontal moisture advection, radiation, and surface fluxes—to the atmospheric \"preconditioning\" that fuels the MJO's journey across the tropics. ",
            "id": "4101301",
            "problem": "You are given a one-dimensional zonal transect representative of conditions in the Indian Ocean warm pool during an active phase of the Madden–Julian Oscillation (MJO). The goal is to compute the column-integrated moist static energy (MSE) tendency immediately ahead of an observed convective envelope and to test, using a mathematically defined criterion, whether horizontal moisture advection dominates the preconditioning of the column for deep convection.\n\nStart from fundamental thermodynamic principles and core definitions. Let the moist static energy be defined as $h = c_p T + L_v q + g z$, where $c_p$ is the specific heat capacity of dry air at constant pressure, $T$ is temperature, $L_v$ is the latent heat of vaporization, $q$ is specific humidity, $g$ is gravitational acceleration, and $z$ is height. Consider the column-integrated MSE budget per unit area derived from the first law of thermodynamics for a hydrostatic atmosphere and the conservation of energy, which includes contributions from horizontal MSE flux divergence, vertical MSE flux convergence, radiative heating, and surface turbulent enthalpy fluxes. In the preconvective region ahead of the convective envelope, use well-tested approximations suitable for numerical weather prediction and climate modeling of the MJO to isolate the terms that can be reliably estimated from reanalysis: horizontal moisture advection, net column radiation, and surface turbulent enthalpy fluxes.\n\nYour program must:\n- Compute the column mass per unit area $m = \\Delta p / g$, where $\\Delta p$ is the pressure thickness of the layer in $\\mathrm{Pa}$ and $g$ is gravitational acceleration in $\\mathrm{m}\\,\\mathrm{s}^{-2}$.\n- Approximate the local zonal moisture gradient at the evaluation point using a finite-difference scheme with grid spacing $\\Delta x$ (in $\\mathrm{m}$) from the provided specific humidity transect $q(x)$ in $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$. Use a centered difference at interior points and a one-sided difference at boundaries.\n- Compute the horizontal moisture advection contribution to the column MSE tendency per unit area using the zonal wind speed $u$ (in $\\mathrm{m}\\,\\mathrm{s}^{-1}$) at the evaluation point. Assume the dominant horizontal MSE advection contribution arises from the moisture component. Use physically consistent constants for $L_v$ and $g$ as provided below.\n- Combine the horizontal moisture advection tendency with the provided net column radiative heating rate $R$ (in $\\mathrm{W}\\,\\mathrm{m}^{-2}$) and the surface turbulent enthalpy flux, which is the sum of latent and sensible heat fluxes $E = F_{\\mathrm{lat}} + F_{\\mathrm{sen}}$ (each in $\\mathrm{W}\\,\\mathrm{m}^{-2}$), to obtain the total preconvective MSE tendency $T$ per unit area.\n- Evaluate whether horizontal moisture advection dominates the preconditioning using the criterion that the absolute contribution of horizontal moisture advection constitutes at least one-half of the sum of absolute magnitudes of the three contributions and that the total tendency is positive. Formally, define the dominance fraction $f = \\lvert A_h \\rvert / (\\lvert A_h \\rvert + \\lvert R \\rvert + \\lvert E \\rvert)$, where $A_h$ is the horizontal moisture advection contribution, and declare dominance if $T  0$ and $f \\ge 0.5$.\n\nConstants to use:\n- $L_v = 2.5 \\times 10^6\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}$.\n- $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$.\n- Use $c_p$ and $z$ only as needed for conceptual grounding; they are not required in the numerical computation for this task.\n\nUnits and outputs:\n- Express the total MSE tendency $T$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}$, rounded to three decimal places.\n- Express the dominance fraction $f$ as a decimal, rounded to three decimal places.\n- The dominance decision must be a boolean value.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[T, f, \\text{dominance}]$. For example, the output format must be like $[[T_1,f_1,\\text{True}],[T_2,f_2,\\text{False}],\\dots]$ on a single line.\n\nTest suite and parameter specification:\nFor each test case, you are provided:\n- A specific humidity transect $q$ as a list of values in $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$.\n- Zonal wind speed $u$ at the evaluation point in $\\mathrm{m}\\,\\mathrm{s}^{-1}$.\n- Grid spacing $\\Delta x$ in $\\mathrm{m}$.\n- Pressure thickness $\\Delta p$ of the layer in $\\mathrm{Pa}$.\n- Net column radiative heating rate $R$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}$.\n- Surface flux components $F_{\\mathrm{lat}}$ (latent heat) and $F_{\\mathrm{sen}}$ (sensible heat), each in $\\mathrm{W}\\,\\mathrm{m}^{-2}$.\n- The index of the convective envelope center $i_c$ and an ahead offset $o$ defining the evaluation index $i = i_c + o$ (east of the center). Use one-sided differencing at boundaries.\n\nUse the following test suite:\n1. General preconditioning case with strong west-to-east moisture decrease and westerly winds:\n   - $q = [0.0200, 0.0195, 0.0190, 0.0185, 0.0180]$,\n   - $u = 5.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -30.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 10.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 2$, $o = 1$.\n2. Boundary condition with negligible moisture gradient:\n   - $q = [0.0185, 0.0185, 0.0185, 0.0185, 0.0185]$,\n   - $u = 4.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 15.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 10.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 2$, $o = 1$.\n3. Strong radiative cooling overwhelming advection:\n   - $q = [0.0198, 0.0194, 0.0190, 0.0186, 0.0182]$,\n   - $u = 3.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -150.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 40.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 10.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 2$, $o = 1$.\n4. Ahead point at domain boundary with moisture increasing eastward:\n   - $q = [0.0180, 0.0185, 0.0190, 0.0195, 0.0200]$,\n   - $u = 5.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 60.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 3$, $o = 1$.\n\nYour task is to implement a complete program that computes, for each test case, the total MSE tendency $T$ (in $\\mathrm{W}\\,\\mathrm{m}^{-2}$), the dominance fraction $f$ (decimal), and the boolean dominance decision. The program must produce a single line containing a list of the form $[[T_1,f_1,\\text{dom}_1],[T_2,f_2,\\text{dom}_2],[T_3,f_3,\\text{dom}_3],[T_4,f_4,\\text{dom}_4]]$.",
            "solution": "The problem requires the calculation of the column-integrated moist static energy (MSE) tendency ahead of a convective envelope in the context of the Madden-Julian Oscillation (MJO). We are asked to determine if horizontal moisture advection is the dominant preconditioning mechanism based on a specific mathematical criterion.\n\nThe analysis begins with the definition of moist static energy, $h$, per unit mass:\n$$h = c_p T + L_v q + g z$$\nwhere $c_p$ is the specific heat of dry air at constant pressure, $T$ is temperature, $L_v$ is the latent heat of vaporization, $q$ is the specific humidity, $g$ is the gravitational acceleration, and $z$ is the height.\n\nThe local time tendency of the column-integrated MSE, denoted as $\\langle h \\rangle = \\frac{1}{g} \\int_{p_t}^{p_s} h \\, dp$, is governed by the atmospheric energy budget. Based on the problem statement, we consider a simplified budget equation for the preconvective environment, which isolates the contributions from horizontal advection, radiation, and surface fluxes:\n$$\\frac{\\partial \\langle h \\rangle}{\\partial t} = A_h + R + E$$\nHere, $\\frac{\\partial \\langle h \\rangle}{\\partial t}$ is the total MSE tendency $T$ in units of $\\mathrm{W}\\,\\mathrm{m}^{-2}$. $A_h$ represents the column-integrated MSE tendency due to horizontal advection. $R$ is the net column radiative heating rate, and $E$ is the total surface turbulent enthalpy flux, given by the sum of the latent heat flux $F_{\\mathrm{lat}}$ and sensible heat flux $F_{\\mathrm{sen}}$, so $E = F_{\\mathrm{lat}} + F_{\\mathrm{sen}}$.\n\nA critical step is to formulate the horizontal advection term, $A_h$. The full term for the column-integrated horizontal advection of MSE is $-\\langle \\mathbf{v}_h \\cdot \\nabla_h h \\rangle$, where $\\mathbf{v}_h$ is the horizontal wind vector and $\\nabla_h$ is the horizontal gradient operator. The problem specifies simplifying this term by considering only the zonal (east-west) component and assuming the advection of moisture is the dominant contributor to the MSE advection. This is a common and justified approximation in the moist tropics where humidity gradients are large. Thus, the term becomes:\n$$A_h \\approx - \\left\\langle u \\frac{\\partial (L_v q)}{\\partial x} \\right\\rangle$$\nwhere $u$ is the zonal wind and $x$ is the zonal coordinate. Since $L_v$ is a constant, we have:\n$$A_h = -L_v \\left\\langle u \\frac{\\partial q}{\\partial x} \\right\\rangle$$\nThe column integration $\\langle \\cdot \\rangle$ is performed over a single atmospheric layer of pressure thickness $\\Delta p$. Assuming $u$ and $\\frac{\\partial q}{\\partial x}$ are constant throughout this layer, the integration simplifies to multiplication by the column mass per unit area, $m = \\frac{\\Delta p}{g}$:\n$$A_h = -L_v u \\left( \\frac{\\partial q}{\\partial x} \\right) \\frac{\\Delta p}{g}$$\nThe constants provided are $L_v = 2.5 \\times 10^6\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}$ and $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$.\n\nTo compute $A_h$, the zonal moisture gradient, $\\frac{\\partial q}{\\partial x}$, must be approximated from the discrete specific humidity transect $q(x)$ provided at grid points with spacing $\\Delta x$. The problem specifies a finite-difference scheme based on the evaluation index $i$ within the transect of length $N$ (where indices run from $0$ to $N-1$):\n- For an interior point ($0  i  N-1$), a second-order centered difference is used:\n$$\\frac{\\partial q}{\\partial x} \\bigg\\rvert_{i} \\approx \\frac{q_{i+1} - q_{i-1}}{2 \\Delta x}$$\n- For a boundary point, a first-order one-sided difference is used. At the right boundary ($i=N-1$), this is a backward difference:\n$$\\frac{\\partial q}{\\partial x} \\bigg\\rvert_{i} \\approx \\frac{q_i - q_{i-1}}{\\Delta x}$$\nThe problem does not require evaluation at the left boundary ($i=0$), but for completeness, a forward difference would be $\\frac{q_{i+1} - q_i}{\\Delta x}$.\n\nWith all components defined, the total preconvective MSE tendency is calculated as:\n$$T = A_h + R + E$$\nTo evaluate whether horizontal moisture advection is the dominant preconditioning factor, a dominance fraction, $f$, is computed. This fraction is the ratio of the absolute magnitude of the moisture advection tendency to the sum of the absolute magnitudes of all contributing tendencies:\n$$f = \\frac{\\lvert A_h \\rvert}{\\lvert A_h \\rvert + \\lvert R \\rvert + \\lvert E \\rvert}$$\nThe criterion for dominance is two-fold: the total tendency must be positive (indicating a moistening or warming of the column, which is favorable for convection), and the dominance fraction must be at least $0.5$.\n1. $T  0$\n2. $f \\ge 0.5$\n\nBoth conditions must be met for the dominance decision to be true. The algorithm proceeds by applying these calculations to each test case, rounding the final numerical results for $T$ and $f$ to three decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the MJO preconditioning problem for a suite of test cases.\n    \"\"\"\n    \n    # Define physical constants\n    L_v = 2.5e6  # Latent heat of vaporization (J/kg)\n    g = 9.81     # Gravitational acceleration (m/s^2)\n\n    # Test suite as provided in the problem description\n    test_cases = [\n        # Case 1: General preconditioning\n        {\n            \"q\": [0.0200, 0.0195, 0.0190, 0.0185, 0.0180],\n            \"u\": 5.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -30.0, \"F_lat\": 20.0, \"F_sen\": 10.0,\n            \"i_c\": 2, \"o\": 1\n        },\n        # Case 2: Negligible moisture gradient\n        {\n            \"q\": [0.0185, 0.0185, 0.0185, 0.0185, 0.0185],\n            \"u\": 4.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -20.0, \"F_lat\": 15.0, \"F_sen\": 10.0,\n            \"i_c\": 2, \"o\": 1\n        },\n        # Case 3: Strong radiative cooling\n        {\n            \"q\": [0.0198, 0.0194, 0.0190, 0.0186, 0.0182],\n            \"u\": 3.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -150.0, \"F_lat\": 40.0, \"F_sen\": 10.0,\n            \"i_c\": 2, \"o\": 1\n        },\n        # Case 4: Boundary condition\n        {\n            \"q\": [0.0180, 0.0185, 0.0190, 0.0195, 0.0200],\n            \"u\": 5.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -20.0, \"F_lat\": 60.0, \"F_sen\": 20.0,\n            \"i_c\": 3, \"o\": 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        q_transect = case[\"q\"]\n        u = case[\"u\"]\n        delta_x = case[\"delta_x\"]\n        delta_p = case[\"delta_p\"]\n        R = case[\"R\"]\n        F_lat = case[\"F_lat\"]\n        F_sen = case[\"F_sen\"]\n        i_c = case[\"i_c\"]\n        o = case[\"o\"]\n        \n        # 1. Determine the evaluation index\n        i = i_c + o\n        n_points = len(q_transect)\n        \n        # 2. Calculate the zonal moisture gradient (dq/dx) using finite differences\n        dq_dx = 0.0\n        if 0  i  n_points - 1:\n            # Centered difference for interior points\n            dq_dx = (q_transect[i+1] - q_transect[i-1]) / (2 * delta_x)\n        elif i == 0 and n_points > 1:\n            # Forward difference for the first point (not used in test cases but included for completeness)\n            dq_dx = (q_transect[i+1] - q_transect[i]) / delta_x\n        elif i == n_points - 1 and n_points > 1:\n            # Backward difference for the last point\n            dq_dx = (q_transect[i] - q_transect[i-1]) / delta_x\n        \n        # 3. Compute horizontal moisture advection contribution (A_h)\n        # A_h = -L_v * u * (dq/dx) * (column_mass_per_unit_area)\n        # column_mass_per_unit_area = delta_p / g\n        A_h = -L_v * u * dq_dx * (delta_p / g)\n        \n        # 4. Compute surface turbulent enthalpy flux (E)\n        E = F_lat + F_sen\n        \n        # 5. Compute total preconvective MSE tendency (T)\n        T = A_h + R + E\n        \n        # 6. Evaluate the dominance criterion\n        abs_Ah = abs(A_h)\n        abs_R = abs(R)\n        abs_E = abs(E)\n        \n        denominator = abs_Ah + abs_R + abs_E\n        f = abs_Ah / denominator if denominator != 0 else 0.0\n        \n        # Dominance is true if total tendency is positive AND fraction is >= 0.5\n        is_dominant = (T > 0) and (f >= 0.5)\n        \n        # 7. Format results and append to the list\n        T_rounded = round(T, 3)\n        f_rounded = round(f, 3)\n        \n        # Handle -0.0 for display consistency, though rounding usually handles this.\n        if T_rounded == -0.0: T_rounded = 0.0\n        \n        results.append([T_rounded, f_rounded, is_dominant])\n\n    # 8. Print the final results in the specified format\n    # The str() of a list automatically includes spaces after commas, \n    # which we remove to exactly match a dense list format if needed,\n    # though the problem example does not specify this level of detail.\n    # The default str() is generally acceptable.\n    # For example: str([1.2, 3.4, True]) -> '[1.2, 3.4, True]'\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A primary goal of understanding the MJO is to improve its prediction in weather and climate models, yet many models struggle to accurately capture its behavior. A common and critical error is a bias in the MJO's propagation speed, where the simulated oscillation moves too fast or too slow compared to observations. This final exercise introduces a fundamental forecast verification technique, using synthetic Hovmöller diagrams to quantify model biases in phase speed and systematic longitudinal drift, providing you with essential skills for diagnosing and evaluating the performance of numerical models. ",
            "id": "4101298",
            "problem": "You are given the task of quantifying phase speed biases and systematic longitudinal drift in forecasts of the Madden-Julian Oscillation (MJO) by comparing forecast and observational Hovmöller diagrams of a convective envelope. The task must be completed by implementing a complete, runnable program that constructs synthetic but scientifically realistic datasets, estimates propagation characteristics from first principles, and reports the quantified biases.\n\nThe fundamental base for this problem is the advection of a coherent convective envelope along the equator. Consider a scalar convective proxy field $q(\\lambda,t)$ that satisfies the linear advection equation $\\partial_t q + c \\,\\partial_\\lambda q = 0$ along longitude $\\lambda$ (in degrees) and time $t$ (in days), where $c$ is the eastward phase speed in degrees per day. A coherent envelope translates without change of shape; hence the ridge of maximum convection follows $\\lambda_r(t) = a + c \\, t$, where $a$ is an intercept. In a Hovmöller diagram (longitude-time plot), this ridge is a straight line whose slope yields the phase speed. We assume a periodic domain in longitude with period $360^{\\circ}$. To avoid ambiguity across the prime meridian, ridge longitudes must be unwrapped into a continuous series prior to linear trend estimation.\n\nYour program must:\n- Generate synthetic observational and forecast Hovmöller fields for a convective envelope modeled as a wrapped Gaussian of the form $q(\\lambda,t) = A \\exp\\!\\left(-\\frac{d(\\lambda,\\lambda_c(t))^2}{2\\sigma^2}\\right) + \\eta$, where $A$ is amplitude, $\\sigma$ is the longitudinal standard deviation in degrees, $d(\\cdot,\\cdot)$ is the shortest signed angular distance on the circle in degrees, $\\lambda_c(t) = \\lambda_0 + c\\,t \\;\\bmod\\; 360$ is the center longitude of the convective envelope, and $\\eta$ is zero-mean Gaussian noise. All longitudes are in degrees and all times are in days.\n- For each field, estimate the ridge longitude time series $\\lambda_r(t)$ by taking, at each time, the longitude of the maximum of $q(\\lambda,t)$ over $\\lambda \\in [0,360)$. Then unwrap $\\lambda_r(t)$ into a continuous function of time.\n- Estimate the phase speed $c$ and intercept $a$ by ordinary least squares fitting of the model $\\lambda_r(t) = a + c\\, t + \\epsilon(t)$ to the unwrapped ridge, where $\\epsilon(t)$ is a residual.\n- Compute the phase speed bias between model and observation as $b_c = \\left(c_{\\text{mod}} - c_{\\text{obs}}\\right)\\,\\gamma$ in meters per second, where $\\gamma = \\frac{2\\pi R_e}{360 \\times 86400}$ with Earth’s equatorial radius $R_e = 6{,}378{,}137\\,\\text{m}$, so that a speed of $1\\,\\text{deg day}^{-1}$ corresponds to approximately $1.29\\,\\text{m s}^{-1}$. Express phase speed bias in meters per second (m/s), rounded to two decimals.\n- Compute the systematic longitudinal drift as the wrapped difference of intercepts $d_a = \\mathrm{wrap}_{[-180,180)}\\!\\left(a_{\\text{mod}} - a_{\\text{obs}}\\right)$ in degrees, rounded to two decimals, where $\\mathrm{wrap}_{[-180,180)}(x)$ maps any real angle $x$ (in degrees) to an equivalent in $[-180,180)$.\n\nUse the following fixed configuration for all test cases:\n- Longitudinal grid: $N_x = 144$ equally spaced points, with grid longitudes $\\lambda_i = i \\times 2.5^{\\circ}$ for $i=0,\\dots,N_x-1$ on $[0,360)$.\n- Time step: $\\Delta t = 1\\,\\text{day}$.\n- Envelope amplitude: $A = 1$.\n- Envelope width: $\\sigma = 20^{\\circ}$.\n- Noise is additive and independent with zero mean and specified standard deviation for each test case.\n\nImplement a test suite with the following four cases, each specified by $(T, c_{\\text{obs}}, c_{\\text{mod}}, \\Delta a, \\lambda_0, \\sigma_{\\eta})$, where $T$ is the total number of days, $c_{\\text{obs}}$ and $c_{\\text{mod}}$ are observational and model phase speeds in degrees per day, $\\Delta a$ is the model minus observation intercept offset (a systematic drift) in degrees, $\\lambda_0$ is the observation’s initial center longitude in degrees at $t=0$, and $\\sigma_{\\eta}$ is the noise standard deviation:\n- Case $1$: $(T = 80, c_{\\text{obs}} = 4.0, c_{\\text{mod}} = 5.0, \\Delta a = 10.0, \\lambda_0 = 30.0, \\sigma_{\\eta} = 0.10)$.\n- Case $2$: $(T = 90, c_{\\text{obs}} = 3.5, c_{\\text{mod}} = 3.5, \\Delta a = -30.0, \\lambda_0 = 350.0, \\sigma_{\\eta} = 0.15)$.\n- Case $3$: $(T = 70, c_{\\text{obs}} = 4.5, c_{\\text{mod}} = 2.5, \\Delta a = 0.0, \\lambda_0 = 120.0, \\sigma_{\\eta} = 0.30)$.\n- Case $4$: $(T = 20, c_{\\text{obs}} = 6.0, c_{\\text{mod}} = 6.5, \\Delta a = 15.0, \\lambda_0 = 260.0, \\sigma_{\\eta} = 0.10)$.\n\nFor each case, generate an observational Hovmöller field using $(T, c_{\\text{obs}}, \\Delta a = 0, \\lambda_0, \\sigma_{\\eta})$ and a model Hovmöller field using $(T, c_{\\text{mod}}, \\Delta a, \\lambda_0, \\sigma_{\\eta})$. Use a fixed random seed so that the noise is reproducible across runs.\n\nAngle unit: all angles are in degrees. Speed unit for the final bias: meters per second (m/s). The program must output, for the four test cases in order, a single list of floats in the form $[b_{c,1}, d_{a,1}, b_{c,2}, d_{a,2}, b_{c,3}, d_{a,3}, b_{c,4}, d_{a,4}]$, where $b_{c,i}$ is the phase speed bias in meters per second and $d_{a,i}$ is the systematic drift in degrees. Each value must be rounded to two decimals.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,\\dots]$), with no additional text.",
            "solution": "The posed problem is valid. It is a scientifically grounded, well-posed, and complete problem statement from the field of climate model diagnostics, specifically concerning the Madden-Julian Oscillation (MJO). All-encompassing parameters, physical constants, and procedural steps are provided to construct a reproducible numerical experiment. The task is to quantify MJO forecast biases by simulating and analyzing synthetic Hovmöller diagrams, a standard technique in atmospheric science.\n\nThe solution proceeds by first generating synthetic data representing \"observational\" and \"model forecast\" fields, then systematically processing this data to estimate propagation characteristics, and finally computing the specified bias metrics. The entire process is encapsulated within a program that rigorously follows the principles outlined.\n\nFirst, we establish the framework for data generation. The convective proxy field, $q(\\lambda,t)$, is defined on a two-dimensional grid of longitude $\\lambda$ and time $t$. The longitude domain is a periodic circle of $360^\\circ$ discretized into $N_x = 144$ grid points, yielding a resolution of $2.5^\\circ$. Time is discretized in steps of $\\Delta t = 1$ day. The convective envelope is modeled as a wrapped Gaussian function:\n$$\nq(\\lambda,t) = A \\exp\\!\\left(-\\frac{d(\\lambda, \\lambda_c(t))^2}{2\\sigma^2}\\right) + \\eta\n$$\nHere, the amplitude is fixed at $A=1$ and the longitudinal standard deviation (width) is $\\sigma = 20^\\circ$, representing a large-scale tropical convective anomaly. The term $\\eta$ represents zero-mean Gaussian noise with a specified standard deviation $\\sigma_\\eta$, simulating the inherent unpredictability and stochasticity in atmospheric data. The function $d(\\lambda, \\lambda_c)$ computes the shortest signed angular distance on the circle, ensuring the Gaussian is correctly centered. The center of the envelope, $\\lambda_c(t)$, propagates according to the linear advection model:\n$$\n\\lambda_c(t) = (\\lambda_0 + c \\cdot t) \\pmod{360}\n$$\nwhere $\\lambda_0$ is the initial longitude at $t=0$ and $c$ is the eastward phase speed in degrees per day. For each test case, we generate two such fields:\n1.  An \"observational\" field, using the true observational phase speed $c_{\\text{obs}}$ and an initial longitude $\\lambda_0$.\n2.  A \"model\" field, using the forecast model's phase speed $c_{\\text{mod}}$ and an initial longitude offset by a systematic drift, $\\lambda_0 + \\Delta a$.\n\nSecond, we devise the analysis pipeline to estimate the propagation characteristics from the generated $q(\\lambda,t)$ fields. This process mimics how a scientist would analyze real-world data.\n1.  **Ridge Detection**: For each time step $t$, we identify the longitude of maximum convection. This is achieved by finding the index of the maximum value of $q(\\lambda,t)$ along the longitude axis and retrieving the corresponding longitude value. This procedure yields a time series of ridge longitudes, $\\lambda_r(t)$, which are confined to the range $[0, 360)$.\n2.  **Longitude Unwrapping**: Because the ridge moves across the prime meridian (or any $0^\\circ/360^\\circ$ boundary), the raw $\\lambda_r(t)$ series will contain jumps of approximately $360^\\circ$. To perform linear regression, these discontinuities must be removed. We \"unwrap\" the time series by adding or subtracting multiples of $360^\\circ$ at each jump, creating a continuous representation of the total eastward distance traveled.\n3.  **Parameter Estimation**: With the unwrapped, continuous longitude series, we fit a linear model $\\lambda_r(t) = a + ct + \\epsilon(t)$ using Ordinary Least Squares (OLS) regression. The slope of the resulting line is the estimated phase speed, $c_{\\text{est}}$, and the y-intercept is the estimated initial longitude, $a_{\\text{est}}$.\n\nThird, we quantify the forecast biases by comparing the estimated parameters from the model and observational fields.\n1.  **Phase Speed Bias ($b_c$)**: The difference in estimated phase speeds, $c_{\\text{mod}} - c_{\\text{obs}}$, is converted from degrees per day to meters per second. This is done using the conversion factor $\\gamma = \\frac{2\\pi R_e}{360 \\times 86400}$, where $R_e = 6{,}378{,}137\\,\\text{m}$ is the Earth's equatorial radius. The final bias is $b_c = (c_{\\text{mod, est}} - c_{\\text{obs, est}})\\,\\gamma$. A positive value indicates the forecast MJO propagates eastward too quickly.\n2.  **Systematic Drift ($d_a$)**: The difference in the estimated intercepts, $a_{\\text{mod, est}} - a_{\\text{obs, est}}$, represents the systematic longitudinal error in the forecast's initial position. This difference is wrapped to the interval $[-180, 180)$ to provide the shortest angular displacement.\n\nThe implementation will utilize the `NumPy` library for efficient array computations. Key functions include `numpy.random.normal` for noise generation, `numpy.argmax` for ridge detection, `numpy.unwrap` for handling periodicity, and `numpy.polyfit` for OLS regression. A fixed random seed is used to ensure the noise realization is identical for each run, making the results reproducible and verifiable. The program iterates through the four specified test cases, computes the two bias metrics for each, and formats the output as a single list of rounded floating-point numbers.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_hovmoller(T, c, lambda0_initial, sigma_eta, A, sigma_envelope, lons, times, rng):\n    \"\"\"\n    Generates a synthetic Hovmöller diagram for a propagating convective envelope.\n    \n    Args:\n        T (int): Total number of days.\n        c (float): Phase speed in degrees/day.\n        lambda0_initial (float): Initial center longitude at t=0 in degrees.\n        sigma_eta (float): Standard deviation of the additive Gaussian noise.\n        A (float): Amplitude of the Gaussian envelope.\n        sigma_envelope (float): Standard deviation (width) of the Gaussian envelope in degrees.\n        lons (np.ndarray): Array of longitudes.\n        times (np.ndarray): Array of times.\n        rng (np.random.Generator): NumPy random number generator instance.\n        \n    Returns:\n        np.ndarray: The generated Hovmöller field q(t, lon).\n    \"\"\"\n    # Calculate the center longitude at each time step\n    lambda_c = (lambda0_initial + c * times) % 360\n    \n    # Create broadcastable arrays for vectorized computation\n    # lons: (1, Nx), lambda_c: (T, 1)\n    lons_grid = lons.reshape(1, -1)\n    lambda_c_grid = lambda_c.reshape(-1, 1)\n    \n    # Calculate the shortest signed angular distance d(lambda, lambda_c)\n    # The formula (x + 180) % 360 - 180 works for NumPy's % operator\n    delta = lons_grid - lambda_c_grid\n    dist = (delta + 180) % 360 - 180\n    \n    # Calculate the wrapped Gaussian field\n    gaussian_field = A * np.exp(-dist**2 / (2 * sigma_envelope**2))\n    \n    # Generate additive Gaussian noise\n    noise = rng.normal(loc=0.0, scale=sigma_eta, size=gaussian_field.shape)\n    \n    return gaussian_field + noise\n\ndef analyze_hovmoller(q, lons, times):\n    \"\"\"\n    Estimates phase speed and intercept from a Hovmöller diagram.\n    \n    Args:\n        q (np.ndarray): The Hovmöller field.\n        lons (np.ndarray): Array of longitudes.\n        times (np.ndarray): Array of times.\n        \n    Returns:\n        tuple[float, float]: Estimated phase speed (c_est) and intercept (a_est).\n    \"\"\"\n    # Find the longitude of maximum convection at each time step\n    max_indices = np.argmax(q, axis=1)\n    wrapped_lons = lons[max_indices]\n    \n    # Unwrap longitudes to handle periodicity for linear regression\n    # The period is 360 degrees.\n    unwrapped_lons = np.unwrap(wrapped_lons, period=360)\n    \n    # Perform ordinary least squares regression to find c (slope) and a (intercept)\n    # np.polyfit returns [slope, intercept] for degree 1\n    c_est, a_est = np.polyfit(times, unwrapped_lons, 1)\n    \n    return c_est, a_est\n\ndef wrap_to_180(angle):\n    \"\"\"Wraps an angle in degrees to the interval [-180, 180).\"\"\"\n    return (angle + 180) % 360 - 180\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute biases.\n    \"\"\"\n    # Use a fixed random seed for reproducibility\n    rng = np.random.default_rng(seed=42)\n\n    # Fixed configuration parameters\n    N_x = 144\n    A = 1.0\n    sigma_envelope = 20.0\n    R_e = 6378137.0  # Earth's equatorial radius in meters\n\n    # Conversion factor from degrees/day to m/s\n    gamma = (2 * np.pi * R_e) / (360 * 86400)\n\n    # Longitudinal grid\n    lons = np.linspace(0, 360, N_x, endpoint=False) # Grid on [0, 360)\n\n    # Test cases: (T, c_obs, c_mod, delta_a, lambda0, sigma_eta)\n    test_cases = [\n        (80, 4.0, 5.0, 10.0, 30.0, 0.10),\n        (90, 3.5, 3.5, -30.0, 350.0, 0.15),\n        (70, 4.5, 2.5, 0.0, 120.0, 0.30),\n        (20, 6.0, 6.5, 15.0, 260.0, 0.10),\n    ]\n\n    results = []\n    for T, c_obs, c_mod, delta_a, lambda0, sigma_eta in test_cases:\n        times = np.arange(T)\n\n        # --- Observational Run ---\n        # Initial longitude for observation is lambda0\n        q_obs = generate_hovmoller(T, c_obs, lambda0, sigma_eta, A, sigma_envelope, lons, times, rng)\n        c_obs_est, a_obs_est = analyze_hovmoller(q_obs, lons, times)\n\n        # --- Model Forecast Run ---\n        # Initial longitude for model is offset by delta_a\n        lambda0_mod_initial = lambda0 + delta_a\n        q_mod = generate_hovmoller(T, c_mod, lambda0_mod_initial, sigma_eta, A, sigma_envelope, lons, times, rng)\n        c_mod_est, a_mod_est = analyze_hovmoller(q_mod, lons, times)\n        \n        # --- Compute Biases ---\n        # Phase speed bias in m/s\n        b_c = (c_mod_est - c_obs_est) * gamma\n        \n        # Systematic longitudinal drift in degrees\n        d_a = wrap_to_180(a_mod_est - a_obs_est)\n\n        # Append rounded results to the list\n        results.append(round(b_c, 2))\n        results.append(round(d_a, 2))\n\n    # Print the final list in the specified format\n    print(f\"[{','.join(f'{r:.2f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}