{
    "hands_on_practices": [
        {
            "introduction": "我们从最基础的对流不稳定形式——干静力不稳定性开始。当位温随高度降低（即 $\\frac{\\partial \\theta}{\\partial z} \\lt 0$）时，就会出现这种不稳定性，大气层结变得“头重脚轻”。这个实践练习将指导您实现一种优雅而高效的“堆叠”算法（一种池邻违规者算法，Pool Adjacent Violators Algorithm, PAVA），通过混合不稳定的气层来消除这种不稳定性。这个练习不仅能让您掌握一种确保剖面物理真实性的重要数值方法，还能加深您对位温守恒在干绝热混合过程中核心作用的理解 。",
            "id": "4026309",
            "problem": "给定一个由 $N$ 个有限层表示的离散化垂直大气柱，从底部（$i=1$）到顶部（$i=N$）进行索引。每个层 $i$ 都有已知的单位水平面积质量 $m_i$（单位：千克/平方米，$\\mathrm{kg}/\\mathrm{m}^2$）和已知的位温 $\\theta_i$（单位：开尔文，K）。位温由经过充分检验的公式 $\\theta = T \\left(\\dfrac{p_0}{p}\\right)^{R/c_p}$ 定义，其中 $T$ 是温度（单位：开尔文，K），$p$ 是气压（单位：帕斯卡，$\\mathrm{Pa}$），$p_0$ 是参考气压（通常 $p_0 = 10^5\\,\\mathrm{Pa}$），$R$ 是干空气的比气体常数（单位：焦耳/千克·开尔文，$\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$），$c_p$ 是定压比热（单位：焦耳/千克·开尔文，$\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$）。对于干绝热运动，位温 $\\theta$ 是物质守恒的。\n\n在干状况下，如果 $\\dfrac{\\partial \\theta}{\\partial z} \\ge 0$，则大气柱是静力稳定的，其离散形式要求对于所有相邻层 $i$，都有 $\\theta_{i+1} \\ge \\theta_i$。如果任意一对相邻层违反了 $\\theta_{i+1} \\ge \\theta_i$，则该大气柱在该段是静力不稳定的。在干绝热动力学下，基于物理的对流调整会瞬间将任何静力不稳定的连续层集混合成一个中性状态，使得该混合层集具有均匀的位温。由于 $\\theta$ 是守恒的，并且假设混合是绝热的、没有源或汇，因此混合块的中性值必须等于该块中原始值的质量加权平均值：\n$$\n\\theta_{\\mathrm{mix}} = \\frac{\\sum_{j \\in \\mathcal{B}} m_j \\theta_j}{\\sum_{j \\in \\mathcal{B}} m_j},\n$$\n其中 $\\mathcal{B}$ 是混合块中各层的索引集。\n\n您的任务是实现一个堆栈算法（一种池旁违规者算法，PAVA），该算法通过逐层平均混合来消除静力不稳定性，从而得到一个随高度不减的最终调整后廓线 $\\{\\hat{\\theta}_i\\}_{i=1}^N$。该算法必须：\n- 从底部开始，将每一层作为一个包含其 $m_i$ 和 $\\theta_i$ 的块压入堆栈。\n- 每当顶部块的位温严格小于其下方块的位温时，将这两个块合并成一个新块。新块的质量是两个块的质量之和，其位温是两者的质量加权平均值，如上文所定义。只要不满足非递减条件，就重复合并操作。\n- 处理完所有层后，将堆栈展开回逐层序列，将合并块中每个原始层的位温都赋值为该块的中性位温 $\\theta_{\\mathrm{mix}}$。\n\n该方法应基于以下经过充分检验的基本原理：\n- 沿气块运动的干绝热位温 $\\theta$ 守恒。\n- 静力稳定判据 $\\dfrac{\\partial \\theta}{\\partial z} \\ge 0$。\n- 混合块内质量和整层积分位温守恒，这意味着需要进行质量加权平均。\n\n实现此算法，为下面列出的每个测试用例生成调整后的位温廓线。所有位温必须以开尔文（K）表示，并报告为四舍五入到五位小数的浮点数。假设所有 $m_i$ 均为严格正值，且混合是严格局地和绝热的。本问题不涉及角度。\n\n测试套件规范：\n- 情况 1 (已稳定):\n  - $N = 4$\n  - $m = [100, 100, 100, 100]$ 单位：$\\mathrm{kg}/\\mathrm{m}^2$\n  - $\\theta = [300, 301, 302, 303]$ 单位：$K$\n- 情况 2 (底部存在单一不稳定层对):\n  - $N = 3$\n  - $m = [100, 100, 100]$ 单位：$\\mathrm{kg}/\\mathrm{m}^2$\n  - $\\theta = [300, 299, 301]$ 单位：$K$\n- 情况 3 (非均匀质量的多层混合):\n  - $N = 4$\n  - $m = [800, 100, 100, 100]$ 单位：$\\mathrm{kg}/\\mathrm{m}^2$\n  - $\\theta = [300, 295, 290, 310]$ 单位：$K$\n- 情况 4 (从堆栈顶部开始的级联合并):\n  - $N = 4$\n  - $m = [100, 100, 100, 100]$ 单位：$\\mathrm{kg}/\\mathrm{m}^2$\n  - $\\theta = [300, 310, 305, 303]$ 单位：$K$\n- 情况 5 (等值，中性):\n  - $N = 3$\n  - $m = [50, 100, 150]$ 单位：$\\mathrm{kg}/\\mathrm{m}^2$\n  - $\\theta = [300, 300, 300]$ 单位：$K$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每一项对应一个测试用例，其本身是一个浮点数列表，表示每层调整后的位温廓线（单位：开尔文，K），四舍五入到五位小数。例如，输出必须如下所示：\n$[\\,[\\hat{\\theta}_1^{(1)}, \\ldots], [\\hat{\\theta}_1^{(2)}, \\ldots], \\ldots\\,]$。",
            "solution": "用户提供的问题已经过验证，是可靠的。它在科学上基于大气热力学原理，问题定义明确，算法和输入清晰，表述客观。因此，我们可以着手解决该问题。\n\n该问题要求为离散化的垂直大气柱实现一个对流调整算法。目标是将初始位温廓线 $\\{\\theta_i\\}_{i=1}^N$ 转换为最终的静力稳定廓线 $\\{\\hat{\\theta}_i\\}_{i=1}^N$。如果位温随高度不减，则廓线是静力稳定的，对于我们的离散层来说，这意味着对于所有相邻的层 $i$ 和 $i+1$，都有 $\\hat{\\theta}_{i+1} \\ge \\hat{\\theta}_i$。指定的算法是一种堆栈方法，它是池旁违规者算法（PAVA）的一种实现。\n\n该方法的物理基础依赖于两个关键原则：\n1.  **位温守恒**：对于干绝热过程，位温 $\\theta$ 是一个守恒量。当层发生混合时，没有外部热源或热汇，因此混合层的总“位温热含量”必须守恒。\n2.  **质量守恒**：混合层的总质量是守恒的。\n\n对于正在混合的一组连续层 $\\mathcal{B}$，结合这些原则，所得混合块的位温 $\\theta_{\\mathrm{mix}}$ 必须是该块中各层初始位温的质量加权平均值。这由给定公式表示：\n$$\n\\theta_{\\mathrm{mix}} = \\frac{\\sum_{j \\in \\mathcal{B}} m_j \\theta_j}{\\sum_{j \\in \\mathcal{B}} m_j}\n$$\n这可以改写为 $\\theta_{\\mathrm{mix}} \\sum m_j = \\sum (m_j \\theta_j)$，清楚地显示了总位温热含量 $\\sum m_j \\theta_j$ 的守恒。\n\n堆栈算法提供了一种系统化且计算高效的方法，用于识别所有不稳定区域并应用此混合规则以生成最终的稳定廓线。算法流程如下：\n\n1.  **初始化**：我们从一个空堆栈开始。此堆栈将用于存放“块”，每个块代表一个或多个已混合成单一均匀状态的连续原始层。我们从大气柱底部（$i=1$）到顶部（$i=N$）逐一处理初始层。\n\n2.  **迭代处理**：对于从 $1$ 到 $N$ 的每一层 $i$：\n    a. 我们创建一个代表该单层的新块，其质量为 $m_i$，位温为 $\\theta_i$，并将其压入堆栈顶部。\n    b. 然后我们检查不稳定性。如果堆栈包含至少两个块，并且顶部块的位温严格小于其正下方块的位温，则存在不稳定性。\n    c. 如果检测到不稳定性，则合并顶部的两个块。新的合并块的总质量是单个块的质量之和。其位温是两个块位温的质量加权平均值，这与守恒原则一致。这个新的合并块将取代堆栈上的两个原始块。\n    d. 重复此检查和合并步骤，直到堆栈顶部稳定为止（即，顶部块的位温大于或等于其下方块的位温，或者堆栈中只有一个块）。这种重复处理了级联不稳定性，即两个块的混合可能与下面的层产生新的不稳定性，从而引发进一步的合并。\n\n3.  **廓线重构**：在处理完所有 $N$ 层之后，堆栈中包含一系列块，每个块都具有均匀的位温，并且从底部块到顶部块，位温是随高度不减的。最终调整后的廓线 $\\{\\hat{\\theta}_i\\}$ 是通过展开这些块来构建的。对于堆栈中的每个块，我们将其均匀的位温分配给它所包含的所有原始大气层。\n\n在数值实现上，为每个块存储总质量（$M_{\\mathrm{block}}$）和总位温热含量（$\\Theta_{\\mathrm{block}} = \\sum m_j \\theta_j$）会更高效、更稳健。当合并两个块（例如块 $A$ 和块 $B$）时，新的合并块 $C$ 具有以下属性：\n$$\nM_C = M_A + M_B\n$$\n$$\n\\Theta_C = \\Theta_A + \\Theta_B\n$$\n然后，任何块的均匀位温就是 $\\theta_{\\mathrm{block}} = \\Theta_{\\mathrm{block}} / M_{\\mathrm{block}}$。这种方法可以最大限度地减少重复的乘法和除法运算。\n\n该算法保证了最终生成唯一、稳定的廓线，该廓线守恒质量和位温热含量，并遵循干绝热混合的物理约束。",
            "answer": "```python\nimport numpy as np\n\ndef convective_adjustment_pava(masses, thetas):\n    \"\"\"\n    Applies a pool-adjacent-violators style algorithm for convective adjustment.\n\n    This function takes a vertical profile of layer masses and potential temperatures\n    and returns a statically stable potential temperature profile, where static\n    instabilities have been removed through mass-conservative mixing.\n\n    Args:\n        masses (list of float): The mass per unit area of each layer, from bottom to top.\n        thetas (list of float): The potential temperature of each layer, from bottom to top.\n\n    Returns:\n        list of float: The adjusted, statically stable potential temperature profile.\n    \"\"\"\n    # The stack will store blocks. Each block is a dictionary representing a\n    # single mixed region of one or more layers. To improve numerical stability\n    # and efficiency, we store the sum of (mass * theta) instead of theta itself.\n    stack = []\n\n    for i in range(len(masses)):\n        # Add the current layer as a new block to the top of the stack.\n        # Ensure values are floats to prevent integer arithmetic issues.\n        stack.append({\n            'mass': float(masses[i]),\n            'theta_sum': float(masses[i]) * float(thetas[i]),\n            'num_layers': 1\n        })\n\n        # Check for instability and merge if necessary. The while loop handles\n        # cascading merges, where a merge might create a new instability with\n        # the block below it.\n        while len(stack) > 1:\n            top_block = stack[-1]\n            second_block = stack[-2]\n            \n            # An instability exists if theta_top  theta_second.\n            # We derive theta from theta_sum / mass for the comparison.\n            if (top_block['theta_sum'] / top_block['mass'])  (second_block['theta_sum'] / second_block['mass']):\n                # Pop the two unstable blocks.\n                stack.pop()\n                stack.pop()\n                \n                # Create a new block by merging them, conserving mass and total theta content.\n                merged_block = {\n                    'mass': top_block['mass'] + second_block['mass'],\n                    'theta_sum': top_block['theta_sum'] + second_block['theta_sum'],\n                    'num_layers': top_block['num_layers'] + second_block['num_layers']\n                }\n                # Push the new merged block back onto the stack.\n                stack.append(merged_block)\n            else:\n                # The top of the stack is stable, so we break the merge loop.\n                break\n    \n    # After processing all layers, the stack contains the final stable blocks.\n    # Unpack the stack to create the layer-by-layer final profile.\n    final_theta_profile = []\n    for block in stack:\n        block_theta = block['theta_sum'] / block['mass']\n        # Extend the final list with the block's uniform theta for each layer it contains.\n        final_theta_profile.extend([block_theta] * block['num_layers'])\n        \n    return final_theta_profile\n\ndef solve():\n    \"\"\"\n    Runs the convective adjustment algorithm for the specified test cases and\n    prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (already stable)\n        {'m': [100, 100, 100, 100], 'theta': [300, 301, 302, 303]},\n        # Case 2 (single unstable pair at the bottom)\n        {'m': [100, 100, 100], 'theta': [300, 299, 301]},\n        # Case 3 (multi-layer mixing with non-uniform mass)\n        {'m': [800, 100, 100, 100], 'theta': [300, 295, 290, 310]},\n        # Case 4 (cascading merges from the top of the stack)\n        {'m': [100, 100, 100, 100], 'theta': [300, 310, 305, 303]},\n        # Case 5 (equal values, neutral)\n        {'m': [50, 100, 150], 'theta': [300, 300, 300]}\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        adjusted_profile = convective_adjustment_pava(case['m'], case['theta'])\n        \n        # Format each number to five decimal places and join into a string like \"[n1,n2,...]\".\n        # This creates a JSON-like representation without extraneous whitespace.\n        formatted_profile = [f\"{t:.5f}\" for t in adjusted_profile]\n        profile_str = f\"[{','.join(formatted_profile)}]\"\n        result_strings.append(profile_str)\n        \n    # Combine the string representations of each test case result into the final output string.\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了干对流调整之后，我们将转向湿对流，这在真实大气中更为普遍且在能量上更为重要。这个练习引入了一个在湿绝热过程中守恒的关键物理量——湿静力能量（Moist Static Energy, MSE），其定义为 $h = c_p T + g z + L_v q$。您将实现一个调整方案，该方案不仅是简单地消除不稳定，而是将整个大气柱的温度剖面调整至一个预设的稳定递减率，同时严格保证总湿静力能量的守恒 。这是一个在许多对流参数化方案中广泛应用的经典方法，对于理解模型如何处理湿过程至关重要。",
            "id": "4026282",
            "problem": "考虑一个单一的垂直大气柱，它被离散化为 $N$ 层，对于第 $i=1,\\dots,N$ 层，其层中点的几何高度 $z_i$（单位：$\\mathrm{m}$）、温度 $T_i$（单位：$\\mathrm{K}$）、比湿 $q_i$（单位：$\\mathrm{kg}\\,\\mathrm{kg}^{-1}$）和气压 $p_i$（单位：$\\mathrm{Pa}$）均为已知。在数值天气预报 (NWP) 中，一种表示快速对流过程的常用方法是对流调整，该方法将气柱温度廓线松弛到一个给定的中性直减率，同时保持整层积分的湿静力能 (MSE) 守恒。单位质量的湿静力能 (MSE) 定义为 $h = c_p T + g z + L_v q$，其中 $c_p$ 是空气的定压比热容，$g$ 是重力加速度，$L_v$ 是蒸发潜热，$q$ 是比湿。单位水平面积的整层积分 MSE 为 $H = \\sum_{i=1}^{N} m_i h_i$，其中 $m_i$ 是第 $i$ 层的单位水平面积质量，$h_i$ 是该层单位质量的 MSE。\n\n您的任务是实现一个对流调整，该调整强制执行一个具有给定中性直减率 $\\Gamma$（单位：$\\mathrm{K}\\,\\mathrm{m}^{-1}$）的温度廓线，表示为 $T_{\\mathrm{adj}}(z) = T_0 - \\Gamma z$，同时保持整层积分的 MSE $H$ 守恒。假设如下：\n- 层质量 $m_i$ 从初始状态计算得出，并在调整期间保持不变。\n- 几何高度 $z_i$ 和比湿 $q_i$ 在调整期间保持不变。\n- 虚温 $T_{v,i}$ 近似为 $T_{v,i} = T_i (1 + \\epsilon q_i)$，其中 $\\epsilon = 0.61$。单位面积的层质量为 $m_i = \\rho_i \\Delta z_i$，其中根据理想气体定律 $\\rho_i = \\dfrac{p_i}{R_d T_{v,i}}$，$R_d$ 是干空气的比气体常数，$\\Delta z_i$ 是通过对 $z_i$ 网格进行一致的有限体积近似计算出的层厚度。\n\n从 $h$ 的基本定义和能量守恒的要求出发，推导确定截距 $T_0$ 的必要表达式，以确保在调整后的廓线 $T_{\\mathrm{adj}}(z)$ 下 $H$ 守恒，并实现一个算法来：\n1. 根据给定的 $z_i$、$p_i$、$T_i$ 和 $q_i$，使用理想气体定律和 $\\Delta z_i$ 的有限体积估计来计算层质量 $m_i$。\n2. 计算初始的整层积分 MSE $H$。\n3. 确定 $T_0$，使得调整后的廓线 $T_{\\mathrm{adj}}(z) = T_0 - \\Gamma z$ 能够使 $H$ 守恒。\n4. 计算调整后的温度 $T_{\\mathrm{adj},i} = T_0 - \\Gamma z_i$。\n5. 为每个测试案例计算两个诊断量：\n   - 绝对能量守恒误差 $E = \\left| H_{\\mathrm{adj}} - H \\right|$，单位为 $\\mathrm{J}\\,\\mathrm{m}^{-2}$，其中 $H_{\\mathrm{adj}}$ 是调整后的整层积分 MSE。\n   - 离散直减率与给定中性直减率的最大绝对偏差，定义为 $\\Lambda = \\max_{i=1,\\dots,N-1} \\left| \\dfrac{T_{\\mathrm{adj},i+1} - T_{\\mathrm{adj},i}}{z_{i+1} - z_i} + \\Gamma \\right|$，单位为 $\\mathrm{K}\\,\\mathrm{m}^{-1}$。\n\n使用以下物理常数：\n- $c_p = 1004\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$，\n- $g = 9.81\\ \\mathrm{m}\\,\\mathrm{s}^{-2}$，\n- $L_v = 2.5 \\times 10^{6}\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}$，\n- $R_d = 287\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$，\n- $\\epsilon = 0.61$。\n\n有限体积层厚度 $\\Delta z_i$ 必须按如下方式计算：\n- 对于 $i=1$，$\\Delta z_1 = z_2 - z_1$，\n- 对于 $1  i  N$，$\\Delta z_i = \\dfrac{z_{i+1} - z_{i-1}}{2}$，\n- 对于 $i=N$，$\\Delta z_N = z_N - z_{N-1}$。\n\n将您的解决方案实现为一个完整的、可运行的程序，处理以下包含四个案例的测试套件。每个测试案例提供数组 $z$、$T$、$q$、$p$ 和一个给定的 $\\Gamma$。所有数组都在层中点给出，必须按提供的方式使用。\n\n测试套件：\n- 案例 1（理想路径，超绝热初始廓线）：\n  - $z = [\\,0,\\ 500,\\ 1000,\\ 1500,\\ 2000,\\ 2500\\,]\\ \\mathrm{m}$，\n  - $T = [\\,300,\\ 296,\\ 291,\\ 285,\\ 278,\\ 270\\,]\\ \\mathrm{K}$，\n  - $q = [\\,0.01,\\ 0.01,\\ 0.01,\\ 0.01,\\ 0.01,\\ 0.01\\,]\\ \\mathrm{kg}\\,\\mathrm{kg}^{-1}$，\n  - $p = [\\,100000,\\ 93941.306,\\ 88249.690,\\ 82902.912,\\ 77880.078,\\ 73161.563\\,]\\ \\mathrm{Pa}$（通过 $p(z) = 100000 \\exp(-z/8000)$ 计算），\n  - $\\Gamma = 0.006\\ \\mathrm{K}\\,\\mathrm{m}^{-1}$。\n- 案例 2（已为中性但湿度变化的廓线）：\n  - $z = [\\,0,\\ 500,\\ 1000,\\ 1500,\\ 2000,\\ 2500\\,]\\ \\mathrm{m}$，\n  - $T = [\\,300,\\ 297,\\ 294,\\ 291,\\ 288,\\ 285\\,]\\ \\mathrm{K}$，\n  - $q = [\\,0.008,\\ 0.009,\\ 0.010,\\ 0.011,\\ 0.012,\\ 0.013\\,]\\ \\mathrm{kg}\\,\\mathrm{kg}^{-1}$，\n  - $p = [\\,100000,\\ 93941.306,\\ 88249.690,\\ 82902.912,\\ 77880.078,\\ 73161.563\\,]\\ \\mathrm{Pa}$，\n  - $\\Gamma = 0.006\\ \\mathrm{K}\\,\\mathrm{m}^{-1}$。\n- 案例 3（双层薄气柱，强不稳定）：\n  - $z = [\\,0,\\ 100\\,]\\ \\mathrm{m}$，\n  - $T = [\\,300,\\ 295\\,]\\ \\mathrm{K}$，\n  - $q = [\\,0.02,\\ 0.02\\,]\\ \\mathrm{kg}\\,\\mathrm{kg}^{-1}$，\n  - $p = [\\,100000,\\ 98757.859\\,]\\ \\mathrm{Pa}$（来自 $p(z) = 100000 \\exp(-z/8000)$），\n  - $\\Gamma = 0.0098\\ \\mathrm{K}\\,\\mathrm{m}^{-1}$。\n- 案例 4（非均匀间距，干空气柱）：\n  - $z = [\\,0,\\ 200,\\ 700,\\ 900,\\ 1400\\,]\\ \\mathrm{m}$，\n  - $T = [\\,300,\\ 288,\\ 280,\\ 276,\\ 270\\,]\\ \\mathrm{K}$，\n  - $q = [\\,0,\\ 0,\\ 0,\\ 0,\\ 0\\,]\\ \\mathrm{kg}\\,\\mathrm{kg}^{-1}$，\n  - $p = [\\,100000,\\ 97531.476,\\ 91664.418,\\ 89240.064,\\ 83852.982\\,]\\ \\mathrm{Pa}$（来自 $p(z) = 100000 \\exp(-z/8000)$），\n  - $\\Gamma = 0.0065\\ \\mathrm{K}\\,\\mathrm{m}^{-1}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 每个测试案例的结果必须是一个双元素列表 $[E,\\ \\Lambda]$，其中 $E$ 是能量守恒误差（单位：$\\mathrm{J}\\,\\mathrm{m}^{-2}$），$\\Lambda$ 是最大直减率偏差（单位：$\\mathrm{K}\\,\\mathrm{m}^{-1}$）。\n- 所有数值输出必须四舍五入到 $10^{-6}$（小数点后六位）。\n- 例如，一个包含两个案例的输出应类似于 $[[0.000001,0.000000],[0.123456,0.000001]]$。\n\n交付一个完整的、可运行的程序，该程序实现此对流调整并为所提供的测试套件生成所需的输出行。不允许用户输入。所有输出均需使用指定的单位和舍入格式。该算法必须遵守上述整层积分 MSE 守恒的原则，并必须使用所述的物理常数。",
            "solution": "我们从单层单位质量的湿静力能 (MSE) 的定义开始，其表达式为 $h = c_p T + g z + L_v q$，其中 $c_p$ 是空气的定压比热容，$T$ 是温度，$g$ 是重力加速度，$z$ 是几何高度，$L_v$ 是蒸发潜热，$q$ 是比湿。单位水平面积的整层积分 MSE 为 $H = \\sum_{i=1}^{N} m_i h_i$，其中求和遍历所有层，$m_i$ 是第 $i$ 层的单位面积质量，$h_i$ 是该层单位质量的 MSE。\n\n我们将执行一次对流调整，以在整个气柱中强制执行一个给定的中性直减率 $\\Gamma$，使得调整后的温度廓线为 $T_{\\mathrm{adj}}(z) = T_0 - \\Gamma z$，其中 $T_0$ 是在 $z=0$ 处的截距，有待确定。调整过程必须使整层积分 MSE $H$ 守恒。我们假设层质量 $m_i$ 是根据初始状态计算的，并在调整期间保持不变，同时 $z_i$ 和 $q_i$ 也保持不变。\n\n为了确定 $m_i$，我们引用理想气体定律和层厚度的有限体积近似。虚温 $T_{v,i}$ 近似为 $T_{v,i} = T_i (1 + \\epsilon q_i)$，其中 $\\epsilon = 0.61$，这考虑了水汽对密度的影响。层中点的密度由 $\\rho_i = \\dfrac{p_i}{R_d T_{v,i}}$ 给出，其中 $R_d$ 是干空气的比气体常数。层厚度 $\\Delta z_i$ 使用有限体积方案从高度网格计算得出：\n- 对于底层 ($i=1$)，$\\Delta z_1 = z_2 - z_1$，\n- 对于内部层 ($1  i  N$)，$\\Delta z_i = \\dfrac{z_{i+1} - z_{i-1}}{2}$，\n- 对于顶层 ($i=N$)，$\\Delta z_N = z_N - z_{N-1}$。\n然后，每层的单位面积质量为 $m_i = \\rho_i \\Delta z_i$。\n\n初始的整层积分 MSE 为\n$$\nH = \\sum_{i=1}^{N} m_i \\left( c_p T_i + g z_i + L_v q_i \\right).\n$$\n在调整后的温度廓线 $T_{\\mathrm{adj}}(z_i) = T_0 - \\Gamma z_i$ 下，且 $q_i$ 和 $z_i$ 保持不变时，调整后的整层积分 MSE 为\n$$\nH_{\\mathrm{adj}} = \\sum_{i=1}^{N} m_i \\left( c_p (T_0 - \\Gamma z_i) + g z_i + L_v q_i \\right)\n= c_p T_0 \\sum_{i=1}^{N} m_i - c_p \\Gamma \\sum_{i=1}^{N} m_i z_i + g \\sum_{i=1}^{N} m_i z_i + L_v \\sum_{i=1}^{N} m_i q_i.\n$$\n施加能量守恒条件 $H_{\\mathrm{adj}} = H$ 并求解 $T_0$，我们得到\n$$\nc_p T_0 \\sum_{i=1}^{N} m_i = H - g \\sum_{i=1}^{N} m_i z_i - L_v \\sum_{i=1}^{N} m_i q_i + c_p \\Gamma \\sum_{i=1}^{N} m_i z_i,\n$$\n由此得出\n$$\nT_0 = \\frac{H - g \\sum_{i=1}^{N} m_i z_i - L_v \\sum_{i=1}^{N} m_i q_i + c_p \\Gamma \\sum_{i=1}^{N} m_i z_i}{c_p \\sum_{i=1}^{N} m_i}.\n$$\n该表达式确保一旦计算出 $T_0$，调整后的温度廓线 $T_{\\mathrm{adj},i} = T_0 - \\Gamma z_i$ 就能使整层积分 MSE $H$ 守恒。\n\n然后我们计算诊断量：\n- 能量守恒误差\n$$\nE = \\left| H_{\\mathrm{adj}} - H \\right|,\n$$\n其值应接近于 $0$（在数值浮点舍入误差范围内）。\n- 最大直减率偏差 $\\Lambda$，由相邻层之间的离散差分定义\n$$\n\\Lambda = \\max_{i=1,\\dots,N-1} \\left| \\frac{T_{\\mathrm{adj},i+1} - T_{\\mathrm{adj},i}}{z_{i+1} - z_i} + \\Gamma \\right|,\n$$\n因为精确的调整后线性廓线满足 $\\dfrac{\\mathrm{d}T}{\\mathrm{d}z} = -\\Gamma$，因此离散斜率应等于 $-\\Gamma$，偏差仅由数值舍入引起。\n\n算法步骤：\n1. 对于每个测试案例，读取数组 $z_i$、$T_i$、$q_i$、$p_i$ 和给定的 $\\Gamma$。\n2. 计算 $T_{v,i} = T_i (1 + \\epsilon q_i)$，密度 $\\rho_i = \\dfrac{p_i}{R_d T_{v,i}}$，以及使用有限体积方案计算层厚度 $\\Delta z_i$，然后计算 $m_i = \\rho_i \\Delta z_i$。\n3. 构造 $H = \\sum_i m_i (c_p T_i + g z_i + L_v q_i)$、$S_m = \\sum_i m_i$、$S_{mz} = \\sum_i m_i z_i$ 和 $S_{mq} = \\sum_i m_i q_i$。\n4. 通过以下公式计算 $T_0$：\n$$\nT_0 = \\frac{H - g S_{mz} - L_v S_{mq} + c_p \\Gamma S_{mz}}{c_p S_m}.\n$$\n5. 计算 $T_{\\mathrm{adj},i} = T_0 - \\Gamma z_i$，然后将 $T_{\\mathrm{adj},i}$ 代入 MSE 表达式，并使用固定的 $m_i$、$z_i$ 和 $q_i$ 计算 $H_{\\mathrm{adj}}$。\n6. 根据离散斜率计算 $E = |H_{\\mathrm{adj}} - H|$ 和 $\\Lambda$。\n7. 将每个测试案例的输出四舍五入到 $10^{-6}$ 并以 $[E,\\ \\Lambda]$ 的形式返回。\n\n该程序在科学上基于对流调整方案中的 MSE 守恒，并使用理想气体定律进行质量加权。给定的中性直减率 $\\Gamma$ 通过构建调整后的线性温度廓线来确定性地强制执行，而截距 $T_0$ 的选择旨在在给定的层质量和湿度下精确地守恒整层积分 MSE。\n\n该程序为提供的四个测试案例实现了这些步骤，并打印一行包含每个案例的双元素列表 $[E,\\ \\Lambda]$ 的列表，四舍五入到小数点后六位，格式完全符合要求。",
            "answer": "```python\n# Python 3.12 program implementing column convective adjustment with MSE conservation\n# Allowed libraries: numpy (1.23.5), scipy (1.11.4) [scipy not used]\nimport numpy as np\n\n# Physical constants\nCP = 1004.0           # J/(kg K)\nG = 9.81              # m/s^2\nLV = 2.5e6            # J/kg\nRD = 287.0            # J/(kg K)\nEPS = 0.61            # dimensionless\n\ndef layer_thicknesses(z):\n    \"\"\"\n    Compute finite-volume layer thicknesses for midpoint heights z.\n    z: array of shape (N,)\n    Returns dz: array of shape (N,)\n    \"\"\"\n    z = np.asarray(z, dtype=float)\n    N = z.size\n    dz = np.empty(N, dtype=float)\n    if N == 1:\n        dz[0] = 0.0\n        return dz\n    dz[0] = z[1] - z[0]\n    for i in range(1, N-1):\n        dz[i] = 0.5 * (z[i+1] - z[i-1])\n    dz[-1] = z[-1] - z[-2]\n    return dz\n\ndef compute_masses(z, T, q, p):\n    \"\"\"\n    Compute layer masses per unit area m_i = rho_i * dz_i\n    using rho_i = p_i / (RD * T_v_i), T_v_i = T_i * (1 + EPS * q_i).\n    \"\"\"\n    z = np.asarray(z, dtype=float)\n    T = np.asarray(T, dtype=float)\n    q = np.asarray(q, dtype=float)\n    p = np.asarray(p, dtype=float)\n    Tv = T * (1.0 + EPS * q)\n    rho = p / (RD * Tv)\n    dz = layer_thicknesses(z)\n    m = rho * dz\n    return m, dz\n\ndef convective_adjustment_mse(z, T, q, p, Gamma):\n    \"\"\"\n    Perform convective adjustment to neutral lapse rate Gamma\n    while conserving column-integrated MSE.\n    Returns adjusted temperatures, T0, energy error E, max lapse deviation Lambda.\n    \"\"\"\n    z = np.asarray(z, dtype=float)\n    T = np.asarray(T, dtype=float)\n    q = np.asarray(q, dtype=float)\n    p = np.asarray(p, dtype=float)\n    # Masses based on initial state\n    m, dz = compute_masses(z, T, q, p)\n\n    # Compute initial column-integrated MSE\n    h_initial = CP * T + G * z + LV * q\n    H = np.sum(m * h_initial)\n\n    # Sums needed for T0\n    S_m = np.sum(m)\n    S_mz = np.sum(m * z)\n    S_mq = np.sum(m * q)\n\n    # Compute T0 from MSE conservation\n    T0 = (H - G * S_mz - LV * S_mq + CP * Gamma * S_mz) / (CP * S_m)\n\n    # Adjusted temperatures\n    T_adj = T0 - Gamma * z\n\n    # Compute adjusted column-integrated MSE to verify conservation\n    h_adj = CP * T_adj + G * z + LV * q\n    H_adj = np.sum(m * h_adj)\n\n    # Energy conservation error\n    E = abs(H_adj - H)\n\n    # Discrete lapse deviations\n    if z.size >= 2:\n        slopes = (T_adj[1:] - T_adj[:-1]) / (z[1:] - z[:-1])\n        # Target slope is -Gamma; deviation is slopes + Gamma\n        deviations = np.abs(slopes + Gamma)\n        Lambda = float(np.max(deviations))\n    else:\n        Lambda = 0.0\n\n    return T_adj, T0, E, Lambda\n\ndef format_results(results):\n    \"\"\"\n    Format results as a single-line string:\n    [[E1,Lambda1],[E2,Lambda2],...]\n    with each float rounded to 6 decimal places.\n    \"\"\"\n    def fmt_float(x):\n        return f\"{x:.6f}\"\n    inner = []\n    for (E, Lambda) in results:\n        inner.append(f\"[{fmt_float(E)},{fmt_float(Lambda)}]\")\n    return f\"[{','.join(inner)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"z\": [0.0, 500.0, 1000.0, 1500.0, 2000.0, 2500.0],\n            \"T\": [300.0, 296.0, 291.0, 285.0, 278.0, 270.0],\n            \"q\": [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],\n            \"p\": [100000.0, 93941.306, 88249.690, 82902.912, 77880.078, 73161.563],\n            \"Gamma\": 0.006\n        },\n        # Case 2\n        {\n            \"z\": [0.0, 500.0, 1000.0, 1500.0, 2000.0, 2500.0],\n            \"T\": [300.0, 297.0, 294.0, 291.0, 288.0, 285.0],\n            \"q\": [0.008, 0.009, 0.010, 0.011, 0.012, 0.013],\n            \"p\": [100000.0, 93941.306, 88249.690, 82902.912, 77880.078, 73161.563],\n            \"Gamma\": 0.006\n        },\n        # Case 3\n        {\n            \"z\": [0.0, 100.0],\n            \"T\": [300.0, 295.0],\n            \"q\": [0.02, 0.02],\n            \"p\": [100000.0, 98757.859],\n            \"Gamma\": 0.0098\n        },\n        # Case 4\n        {\n            \"z\": [0.0, 200.0, 700.0, 900.0, 1400.0],\n            \"T\": [300.0, 288.0, 280.0, 276.0, 270.0],\n            \"q\": [0.0, 0.0, 0.0, 0.0, 0.0],\n            \"p\": [100000.0, 97531.476, 91664.418, 89240.064, 83852.982],\n            \"Gamma\": 0.0065\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        z = case[\"z\"]\n        T = case[\"T\"]\n        q = case[\"q\"]\n        p = case[\"p\"]\n        Gamma = case[\"Gamma\"]\n        T_adj, T0, E, Lambda = convective_adjustment_mse(z, T, q, p, Gamma)\n        results.append((E, Lambda))\n\n    # Final print statement in the exact required format.\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}