{
    "hands_on_practices": [
        {
            "introduction": "在混合相云中，冰晶的初始形成是一个关键过程，它可以通过多种途径发生。本练习引导我们分析一个包裹着可溶性物质的矿物粉尘颗粒的成冰行为，这是一个在真实大气中常见的场景。通过这个练习，我们将运用开尔文效应和拉乌尔定律等基本热力学原理，来判断是先凝结成过冷液滴再冻结，还是直接凝华成冰，从而深入理解不同冰核化机制之间的竞争关系。",
            "id": "4054072",
            "problem": "一个带有半径为 $r_c = 0.25\\,\\mu\\mathrm{m}$ 的不溶性核的包裹性矿物尘埃颗粒，其表面覆盖着一层薄的可溶性硫酸盐壳，遇湿后会完全溶解。空气温度为 $T = -12\\,^{\\circ}\\mathrm{C}$，相对于液态水的饱和比为 $S_w = 1.01$。考虑在与数值天气预报（NWP）和气候模型相关的混合相云中，其初始活化路径可能是水汽凝结成液滴后进行浸润冻结，也可能是直接的凝华冰成核。分析必须从基本的热力学关系和毛细效应出发。\n\n使用 Kelvin 方程和理想溶液形式的 Raoult 定律作为评估弯曲水溶液界面上平衡饱和度的基础。Kelvin 曲率因子由参数\n$$\nA = \\frac{2\\,\\sigma_w\\,M_w}{R\\,T\\,\\rho_w},\n$$\n控制，其中 $\\sigma_w$ 是水的表面张力，$M_w$ 是水的摩尔质量，$R$ 是普适气体常数，$T$ 是绝对温度，$\\rho_w$ 是液态水的密度。假设在 $T=261.15\\,\\mathrm{K}$ 时，$\\sigma_w \\approx 0.076\\,\\mathrm{N\\,m^{-1}}$，$M_w = 0.018\\,\\mathrm{kg\\,mol^{-1}}$，$R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$，以及 $\\rho_w = 1000\\,\\mathrm{kg\\,m^{-3}}$。为评估凝结和凝华之间的竞争，取 $T=-12\\,^{\\circ}\\mathrm{C}$ 时水面和冰面的饱和水汽压之比为 $e_{sw}(T)/e_{si}(T) \\approx 1.18$（一个经过充分验证的热力学事实），因此环境相对于冰的饱和比为 $S_i = S_w\\,e_{sw}/e_{si}$。\n\n在此情景下，哪个陈述最能描述物理上一致的起始模式以及 Kelvin 效应与不溶性核的作用？\n\nA. 对于亚微米颗粒，在 $S_w=1.01$ 时，Kelvin 效应阻止了凝结，因此包裹性尘埃作为凝华冰成核颗粒（INP），由于 $S_i1$ 而直接生成冰。\n\nB. 不溶性核增大了初始曲率半径，降低了 Kelvin 势垒，使得凝结活化在 $S_w=1.01$ 时发生；可溶性壳通过 Raoult 效应进一步降低了平衡饱和度，促使液滴生长，之后在 $T=-12\\,^{\\circ}\\mathrm{C}$ 时，浸润冻结是可能的冰起始路径。\n\nC. 相对于纯可溶性气溶胶，不溶性核的存在增加了 Kelvin 势垒，使得凝结和凝华都不太可能发生；如果发生冻结，也只会在碰撞后通过接触机制发生。\n\nD. 因为 $S_i \\gg S_w$，凝华成核和凝结在包裹性尘埃上同时发生，直接形成冰的同时也生长液滴，且不溶性核在曲率效应中不起作用。",
            "solution": "问题要求分析在一个过冷云环境中，一个包裹性矿物尘埃颗粒的初始活化路径。该颗粒由一个不溶性核和一个可溶性壳组成。环境条件为温度 $T = -12\\,^{\\circ}\\mathrm{C}$ 和相对于液态水的饱和比 $S_w = 1.01$。我们必须确定该颗粒是首先作为云凝结核（CCN）形成液滴，还是作为冰成核颗粒（INP）通过凝华直接形成冰。\n\n首先，让我们验证物理参数并建立理论框架。气溶胶颗粒作为 CCN 的活化由 Köhler 理论决定，该理论结合了 Kelvin（曲率）效应和 Raoult（溶质）效应。\n\n半径为 $r_d$ 的水溶液液滴上的平衡饱和比 $S_{eq}$ 由下式给出：\n$$ S_{eq}(r_d) = a_w \\cdot K(r_d) $$\n其中 $a_w$ 是溶液中水的活度（Raoult 效应），$K(r_d)$ 是 Kelvin 曲率因子。\n\nKelvin 因子由下式给出：\n$$ K(r_d) = \\exp\\left(\\frac{2\\,\\sigma_w\\,M_w}{R\\,T\\,\\rho_w\\,r_d}\\right) = \\exp\\left(\\frac{A}{r_d}\\right) $$\n参数 $A$ 在问题中已定义。我们用给定的常数计算其值：\n-   温度，$T = -12\\,^{\\circ}\\mathrm{C} = 261.15\\,\\mathrm{K}$\n-   水的表面张力，$\\sigma_w = 0.076\\,\\mathrm{N\\,m^{-1}}$\n-   水的摩尔质量，$M_w = 0.018\\,\\mathrm{kg\\,mol^{-1}}$\n-   普适气体常数，$R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$\n-   液态水的密度，$\\rho_w = 1000\\,\\mathrm{kg\\,m^{-3}}$\n\n$$ A = \\frac{2 \\cdot (0.076\\,\\mathrm{N\\,m^{-1}}) \\cdot (0.018\\,\\mathrm{kg\\,mol^{-1}})}{(8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\cdot (261.15\\,\\mathrm{K}) \\cdot (1000\\,\\mathrm{kg\\,m^{-3}})} $$\n$$ A = \\frac{0.002736}{2171819.1} \\, \\mathrm{m} \\approx 1.2598 \\times 10^{-9}\\,\\mathrm{m} $$\n所以，$A \\approx 1.26\\,\\mathrm{nm}$。\n\n颗粒有一个半径为 $r_c = 0.25\\,\\mu\\mathrm{m} = 250\\,\\mathrm{nm}$ 的不溶性核。当液滴在该颗粒上形成时，其半径 $r_d$ 必须大于或至少等于核的半径，$r_d \\ge r_c$。Kelvin 效应增加了弯曲表面上的平衡水汽压。该效应对最小的曲率半径最大。在这种情况下，最小曲率半径由不溶性核决定，即 $r_c$。\n\n让我们通过考虑最小可能的液滴半径 $r_d = r_c$ 来评估 Kelvin 效应可能产生的最大势垒。这代表了仅由曲率项决定的最高平衡饱和度。\n$$ K_{max} = K(r_c) = \\exp\\left(\\frac{A}{r_c}\\right) = \\exp\\left(\\frac{1.26\\,\\mathrm{nm}}{250\\,\\mathrm{nm}}\\right) = \\exp(0.00504) \\approx 1.00505 $$\n这意味着，要在半径为 $250\\,\\mathrm{nm}$ 的不溶性球体上生长液滴，环境饱和比必须超过约 $1.005$。与均质成核或在更小颗粒上成核所需条件相比，这个较大的核尺寸显著 *降低* 了 Kelvin 势垒。\n\n给定的环境饱和比为 $S_w = 1.01$。由于 $S_w = 1.01  1.00505$，即使不考虑溶质效应，环境过饱和度也足以克服 Kelvin 势垒。\n\n现在，我们必须考虑由“薄的可溶性硫酸盐壳”引起的 Raoult 效应。当凝结开始时，这层壳会溶解，形成水溶液。溶质的存在降低了水的活度，$a_w  1$。这降低了液滴与环境达到平衡所需的平衡饱和比。完整的 Köhler 方程表明 $S_{eq}$ 是 Raoult 项和 Kelvin 项的乘积。由于 $a_w  1$，实际的平衡曲线将位于纯 Kelvin 曲线之下，活化的临界饱和比 $S_{crit}$ 将会更低：$S_{crit}  1.00505$。\n由于环境饱和度 $S_w = 1.01$ 远高于可能的最大活化势垒，该颗粒将作为 CCN 被活化，形成并生长一个过冷液滴。\n\n接下来，我们评估直接凝华成核的可能性。这个过程要求空气相对于冰是过饱和的，即 $S_i  1$。饱和比之间的关系由 $S_i = S_w \\cdot (e_{sw}/e_{si})$ 给出。\n使用给定的值 $S_w = 1.01$ 和 $e_{sw}/e_{si} \\approx 1.18$：\n$$ S_i = 1.01 \\times 1.18 \\approx 1.1918 $$\n由于 $S_i  1$，环境相对于冰是过饱和的，这使得凝华成核在热力学上是可能的。众所周知，矿物尘埃是一种有效的凝华核。\n\n然而，问题询问的是 *起始模式*。我们必须考虑动力学过程。在水面过饱和（$S_w  1$）条件下，水汽在可溶性或部分可溶性 CCN 上的凝结是一个非常快速的过程。一旦相对湿度超过颗粒的活化阈值（我们已经证明该阈值小于 1.01），一层液膜将迅速包裹颗粒。一旦颗粒被液态水覆盖，从水汽到固体表面的直接凝华就不再可能。任何后续的冰形成都必须在过冷液滴内部发生，这个过程被称为浸润冻结。在 $T = -12\\,^{\\circ}\\mathrm{C}$ 时，由矿物尘埃引发的浸润冻结是混合相云中冰形成的主要机制。\n\n因此，最符合物理规律的顺序是：\n1. 由于低的 Kelvin 势垒（来自大尺寸的核）和溶质效应（来自硫酸盐壳），作为 CCN 快速活化。\n2. 生长成一个过冷液滴。\n3. 该液滴随后通过由矿物尘埃核引发的浸润冻结而冻结。\n\n现在我们基于此分析来评估给出的选项。\n\n**A. 对于亚微米颗粒，在 $S_w=1.01$ 时，Kelvin 效应阻止了凝结，因此包裹性尘埃作为凝华冰成核颗粒（INP），由于 $S_i  1$ 而直接生成冰。**\n这个陈述是不正确的。该颗粒的核相对较大（$r_c = 0.25\\,\\mu\\mathrm{m}$），这使得 Kelvin 势垒相当小（$S \\approx 1.005$）。因此，凝结 *没有* 被阻止，反而是被促进了。其主要前提是错误的。\n**结论：不正确。**\n\n**B. 不溶性核增大了初始曲率半径，降低了 Kelvin 势垒，使得凝结活化在 $S_w=1.01$ 时发生；可溶性壳通过 Raoult 效应进一步降低了平衡饱和度，促使液滴生长，之后在 $T=-12\\,^{\\circ}\\mathrm{C}$ 时，浸润冻结是可能的冰起始路径。**\n这个陈述准确地描述了物理过程。不溶性核作为一个大的基底，降低了 Kelvin 势垒。可溶性壳通过 Raoult 效应进一步降低了所需的饱和度。因此，在 $S_w = 1.01$ 时，凝结活化是确定会发生的。随后的成冰路径被正确地识别为浸润冻结。这与我们的推导完全吻合。\n**结论：正确。**\n\n**C. 相对于纯可溶性气溶胶，不溶性核的存在增加了 Kelvin 势垒，使得凝结和凝华都不太可能发生；如果发生冻结，也只会在碰撞后通过接触机制发生。**\n这个陈述是不正确的。它错误地声称凝结是“不太可能”的，而我们的分析表明凝结是确定会发生的。与纯可溶性气溶胶的比较可能是一个障眼法；关键点是在给定条件下是否会发生活化，而事实是会发生。关于凝华也“不太可能”的结论是毫无根据的，因为 $S_i \\approx 1.19$。整个推理都有缺陷。\n**结论：不正确。**\n\n**D. 因为 $S_i \\gg S_w$，凝华成核和凝结在包裹性尘埃上同时发生，直接形成冰的同时也生长液滴，且不溶性核在曲率效应中不起作用。**\n这个陈述包含多个错误。声称凝华和凝结同时发生是不符合物理现实的；凝结和表面湿润会阻止凝华。最关键的是，声称不溶性核在曲率效应中“不起作用”是根本错误的。核的半径决定了形成液滴的最小曲率，是 Kelvin 效应分析的核心。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "冰晶一旦形成，就会通过水汽凝华继续生长，其生长速率与晶体形态（或称“晶习”）密切相关。本练习将单个冰晶的生长物理过程与整个冰晶群体的宏观行为联系起来。我们将学习如何从特定晶习（如片状和柱状）的单个冰晶的凝华增长系数出发，推导出一个代表整个混合群体效应的“有效”体积增长系数，这正是将微观物理参数化到大尺度模型中的核心技能。",
            "id": "4054067",
            "problem": "考虑一个嵌入在数值天气预报 (NWP) 和气候模型中的冰相微物理模块，该模块表示水汽在非球形冰晶上的凝华过程。在稳态、扩散限制的增长条件下，到达单个冰晶的水汽通量由 Fick 定律和稳态热传导方程控制，这两者共同表明，对于偏离饱和度较小的情况，单颗粒质量增长率与冰面过饱和度之间存在近似线性的关系。对于每种晶体习性 $h$（例如，板状或柱状），单颗粒凝华质量增长率近似为\n$$\\frac{dm_h}{dt} \\approx C_h \\left(S_i - 1\\right),$$\n其中 $S_i$ 是相对于冰面的饱和比，$C_h$ 是一个依赖于习性的凝华增长系数，该系数包含了几何电容、通风效应以及空气的扩散和热阻力的综合影响。\n\n一个混合的冰晶群占据单位体积的空气，其总数浓度为 $N$，板状晶体的习性分数为 $f_P$，柱状晶体的习性分数为 $f_C$，满足 $f_P + f_C = 1$。假设以下条件，这些条件代表了对流层中部的云层：\n- 温度 $T = 258\\,\\mathrm{K}$ 和气压 $p = 700\\,\\mathrm{hPa}$。\n- 总冰晶数浓度 $N = 2.0 \\times 10^{5}\\,\\mathrm{m}^{-3}$。\n- 习性分数 $f_P = 0.65$ 和 $f_C = 0.35$。\n- 在这些条件下，特定习性的单颗粒凝华系数（经过热力学和空气动力学校正）：\n  板状晶体为 $C_P = 4.8 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$，柱状晶体为 $C_C = 6.0 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$。\n\n从质量守恒和由扩散与热传导控制方程所隐含的线性叠加原理出发，推导习性加权的总体凝华增长系数 $C_{\\mathrm{eff}}$，使得单位体积内的总水汽-冰凝华趋势可以写成：\n$$\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = C_{\\mathrm{eff}} \\left(S_i - 1\\right).$$\n使用提供的参数计算 $C_{\\mathrm{eff}}$ 的数值。以 $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$ 为单位表示您的最终答案，并将其四舍五入到四位有效数字。",
            "solution": "单位体积内的总水汽-冰凝华趋势，记为 $\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}}$，表示该体积内所有单个冰晶质量增长率的总和。问题陈述中提到的“线性叠加原理”意味着，总增长率是所有单个颗粒增长率的总和，前提是假设它们独立增长，不会为同一局部的可用水汽而竞争。\n\n单位体积的空气包含总共 $N$ 个冰晶。这个群体由两种习性组成：板状（$P$）和柱状（$C$）。每种习性的数浓度由总浓度乘以各自的习性分数得出：\n- 板状晶体的数浓度：$N_P = N f_P$\n- 柱状晶体的数浓度：$N_C = N f_C$\n\n单位体积内的总质量增长率是该体积内所有板状晶体和所有柱状晶体贡献的总和。\n$$\n\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = N_P \\left(\\frac{dm_P}{dt}\\right) + N_C \\left(\\frac{dm_C}{dt}\\right)\n$$\n这里，$\\frac{dm_P}{dt}$ 和 $\\frac{dm_C}{dt}$ 分别是板状和柱状晶体的单颗粒质量增长率。问题给出了这些增长率的线性近似：\n$$\n\\frac{dm_P}{dt} \\approx C_P (S_i - 1)\n$$\n$$\n\\frac{dm_C}{dt} \\approx C_C (S_i - 1)\n$$\n将这些表达式代入总体增长率的方程中：\n$$\n\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} \\approx N_P \\left[ C_P (S_i - 1) \\right] + N_C \\left[ C_C (S_i - 1) \\right]\n$$\n现在，我们代入 $N_P$ 和 $N_C$ 的表达式：\n$$\n\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} \\approx (N f_P) C_P (S_i - 1) + (N f_C) C_C (S_i - 1)\n$$\n我们可以提出公因式 $N$ 和 $(S_i - 1)$：\n$$\n\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} \\approx \\left[ N (f_P C_P + f_C C_C) \\right] (S_i - 1)\n$$\n这个推导出的表达式与问题陈述中提供的目标方程具有相同的形式：\n$$\n\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = C_{\\mathrm{eff}} (S_i - 1)\n$$\n通过直接比较，我们确定了习性加权的总体凝华增长系数 $C_{\\mathrm{eff}}$：\n$$\nC_{\\mathrm{eff}} = N (f_P C_P + f_C C_C)\n$$\n这个表达式表明，有效总体系数是总数浓度乘以单颗粒凝华系数的习性分数加权平均值。\n\n现在我们使用提供的参数计算 $C_{\\mathrm{eff}}$ 的数值：\n- $N = 2.0 \\times 10^{5}\\,\\mathrm{m}^{-3}$\n- $f_P = 0.65$\n- $C_P = 4.8 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$\n- $f_C = 0.35$\n- $C_C = 6.0 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$\n\n首先，我们计算加权平均的单颗粒系数：\n$$\nf_P C_P + f_C C_C = (0.65)(4.8 \\times 10^{-11}) + (0.35)(6.0 \\times 10^{-11})\n$$\n$$\nf_P C_P + f_C C_C = (3.12 \\times 10^{-11}) + (2.10 \\times 10^{-11}) = 5.22 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}\n$$\n接下来，我们乘以总数浓度 $N$：\n$$\nC_{\\mathrm{eff}} = (2.0 \\times 10^{5}\\,\\mathrm{m}^{-3}) \\times (5.22 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}})\n$$\n$$\nC_{\\mathrm{eff}} = (2.0 \\times 5.22) \\times (10^{5} \\times 10^{-11})\\,\\mathrm{kg\\,m^{-3}\\,s^{-1}}\n$$\n$$\nC_{\\mathrm{eff}} = 10.44 \\times 10^{-6}\\,\\mathrm{kg\\,m^{-3}\\,s^{-1}}\n$$\n为了用标准科学记数法表示，我们调整尾数和指数：\n$$\nC_{\\mathrm{eff}} = 1.044 \\times 10^{-5}\\,\\mathrm{kg\\,m^{-3}\\,s^{-1}}\n$$\n题目要求答案四舍五入到四位有效数字。计算出的值 $1.044 \\times 10^{-5}$ 已经有四位有效数字。",
            "answer": "$$\\boxed{1.044 \\times 10^{-5}}$$"
        },
        {
            "introduction": "除了通过水汽凝华生长，冰晶还会通过碰撞并粘连在一起（即“碰并”）来增大尺寸，这一过程极大地改变了云的粒子谱分布。本练习是一个高级的计算实践，要求我们从斯莫霍夫斯基碰并方程出发，设计并实现一个数值方案来模拟这一过程。这个练习的核心挑战在于保证总质量在离散化的计算中严格守恒，这为我们提供了从第一性原理构建和验证复杂微物理过程数值模型代码的宝贵经验。",
            "id": "4054051",
            "problem": "在用于数值天气预报 (NWP) 和气候模式的冰相微物理学中，冰粒子的碰并 (凝结) 在保持总冰质量守恒的同时，改变了数浓度分布。考虑描述粒子质量 $m$ 的数浓度分布 $n(m,t)$ 的连续 Smoluchowski 碰并方程：\n$$\n\\frac{\\partial n(m,t)}{\\partial t}\n=\n\\frac{1}{2}\\int_{0}^{m} K(m',m-m')\\,n(m',t)\\,n(m-m',t)\\,\\mathrm{d}m'\n-\nn(m,t)\\int_{0}^{\\infty} K(m,m')\\,n(m',t)\\,\\mathrm{d}m',\n$$\n其中 $K(m,m')$ 是对称的碰并核函数，单位为 $\\mathrm{m^3\\,s^{-1}}$。\n\n请在离散质量网格 $\\{m_k\\}_{k=0}^{K-1}$ 上，为碰并积分设计一个使用固定枢轴的守恒数值格式。该网格具有固定的档枢轴质量 $m_k$ (单位 $\\mathrm{kg}$) 和数浓度 $\\{N_k\\}_{k=0}^{K-1}$ (单位 $\\mathrm{m^{-3}}$)。您的格式必须：\n- 从第一性原理出发离散化增益项和损失项，不使用任何预先推导的离散化捷径。\n- 对于任何足够小以维持非负性的显式前向欧拉时间步长 $\\Delta t$ (单位 $\\mathrm{s}$)，在理想运算精度下，精确保持离散一阶矩 (总质量) $M(t)=\\sum_{k=0}^{K-1} m_k N_k(t)$。\n- 对碰并产物质量 $m_p=m_i+m_j$，使用质量比例重分配方法将其分配到界定它的两个最近的枢轴上。\n- 处理对生成率时要与碰撞的对称性保持一致，确保对 $(i,j)$ ($i\\neq j$) 只计数一次，且自碰并 ($i=j$) 不被重复计数。\n\n仅从上述连续积分方程和离散分档的定义出发，推导保证离散质量守恒的固定枢轴重分配权重，并实现该格式以执行一次前向欧拉更新：\n$$\nN_k^{(t+\\Delta t)} = N_k^{(t)} + \\Delta t\\left(S_k - L_k\\right),\n$$\n其中 $S_k$ 是碰并增益汇入第 $k$ 档的源项，$L_k$ 是第 $k$ 档中的粒子参与碰撞造成的损失项，二者单位均为 $\\mathrm{m^{-3}\\,s^{-1}}$。\n\n您的程序必须：\n- 为下面指定的每个测试用例实现核函数 $K(m_i,m_j)$。\n- 使用您推导的守恒固定枢轴格式，计算单个时间步长 $\\Delta t$ 后更新的 $\\{N_k\\}$。\n- 验证并报告绝对质量守恒误差\n$$\nE = \\left|\\sum_{k=0}^{K-1} m_k N_k^{(t+\\Delta t)} - \\sum_{k=0}^{K-1} m_k N_k^{(t)}\\right|\n$$\n单位为千克每立方米 ($\\mathrm{kg\\,m^{-3}}$)，以浮点数形式表示。\n- 断言所有以非零生成率出现的碰并产物质量 $m_p=m_i+m_j$ 都落在枢轴范围 $[m_0,m_{K-1}]$ 内，从而确保由两个枢轴进行界定是良定义的。如果此条件被违反，格式不得继续执行（对于提供的测试套件，此条件通过构造已得到满足）。\n\n物理单位和约定：\n- 质量 $m_k$ 的单位是 $\\mathrm{kg}$。\n- 数浓度 $N_k$ 的单位是 $\\mathrm{m^{-3}}$。\n- 核函数 $K(m_i,m_j)$ 的单位是 $\\mathrm{m^3\\,s^{-1}}$。\n- 时间步长 $\\Delta t$ 的单位是 $\\mathrm{s}$。\n- 守恒误差 $E$ 必须以 $\\mathrm{kg\\,m^{-3}}$ 为单位报告。\n\n测试套件（所有测试均使用相同的枢轴集，包含 $K=5$ 个档，按因子 $2$ 呈几何级数：$m_0=10^{-12}\\,\\mathrm{kg}$, $m_1=2\\times 10^{-12}\\,\\mathrm{kg}$, $m_2=4\\times 10^{-12}\\,\\mathrm{kg}$, $m_3=8\\times 10^{-12}\\,\\mathrm{kg}$, $m_4=16\\times 10^{-12}\\,\\mathrm{kg}$）：\n- 测试 1 (理想情况，常数核函数)：\n  - 核函数：$K(m_i,m_j)=K_0$，$K_0=10^{-12}\\,\\mathrm{m^3\\,s^{-1}}$。\n  - 初始 $N$：$[10^{5},\\,5\\times 10^{4},\\,2\\times 10^{4},\\,10^{4},\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 5\\,\\mathrm{s}$。\n- 测试 2 (质量相关的加性核函数，中度变化)：\n  - 核函数：$K(m_i,m_j)=\\beta\\,(m_i+m_j)$，$\\beta=10\\,\\mathrm{m^3\\,s^{-1}\\,kg^{-1}}$。\n  - 初始 $N$：$[5\\times 10^{4},\\,5\\times 10^{4},\\,0,\\,2\\times 10^{4},\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 0.5\\,\\mathrm{s}$。\n- 测试 3 (边界界定恰好在顶部枢轴，常数核函数)：\n  - 核函数：$K(m_i,m_j)=K_0$，$K_0=5\\times 10^{-13}\\,\\mathrm{m^3\\,s^{-1}}$。\n  - 初始 $N$：$[0,\\,0,\\,3\\times 10^{4},\\,3\\times 10^{4},\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 10\\,\\mathrm{s}$。\n- 测试 4 (极小时间步长，常数核函数，稳定性检查)：\n  - 核函数：$K(m_i,m_j)=K_0$，$K_0=10^{-12}\\,\\mathrm{m^3\\,s^{-1}}$。\n  - 初始 $N$：$[10^{5},\\,10^{5},\\,10^{5},\\,0,\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 10^{-6}\\,\\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含四个测试的守恒误差，格式为方括号内以逗号分隔的列表，例如：\"[e1,e2,e3,e4]\"。每个 $e_i$ 必须是表示相应测试的绝对质量守恒误差 $E$ (单位 $\\mathrm{kg\\,m^{-3}}$) 的浮点数。",
            "solution": "### 1. 离散化框架\n\n连续 Smoluchowski 碰并方程描述了数浓度分布 $n(m,t)$ 作为粒子质量 $m$ 和时间 $t$ 的函数的演变：\n$$\n\\frac{\\partial n(m,t)}{\\partial t}\n=\n\\underbrace{\\frac{1}{2}\\int_{0}^{m} K(m',m-m')\\,n(m',t)\\,n(m-m',t)\\,\\mathrm{d}m'}_{\\text{增益项}}\n-\n\\underbrace{n(m,t)\\int_{0}^{\\infty} K(m,m')\\,n(m',t)\\,\\mathrm{d}m'}_{\\text{损失项}}\n$$\n我们将此方程离散化到一组固定的质量枢轴 $\\{m_k\\}_{k=0}^{K-1}$ 上，其对应的数浓度为 $\\{N_k\\}_{k=0}^{K-1}$。时间演变使用前向欧拉步长进行近似：\n$$\nN_k^{(t+\\Delta t)} = N_k^{(t)} + \\Delta t\\left(S_k - L_k\\right)\n$$\n在这里，$L_k$ 和 $S_k$ 分别是第 $k$ 档中粒子的离散损失率和源（增益）率。我们的目标是推导 $S_k$ 和 $L_k$ 的表达式，以保证总质量 $M = \\sum_{k=0}^{K-1} m_k N_k$ 的守恒。\n\n### 2. 损失项 ($L_k$) 的推导\n\n连续方程中的损失项表示质量为 $m$ 的粒子因与任何其他粒子碰撞而被移除。在我们的离散框架中，当来自第 $k$ 档（质量 $m_k$，浓度 $N_k$）的粒子与来自任何第 $j$ 档（质量 $m_j$，浓度 $N_j$）的粒子碰撞时，它就会损失掉。\n\n第 $k$ 档和第 $j$ 档粒子之间单位体积内的碰撞速率由 $K(m_k, m_j) N_k N_j$ 给出。为了求得第 $k$ 档粒子的总损失率，我们将它与所有档的粒子碰撞的速率相加：\n$$\nL_k = N_k \\sum_{j=0}^{K-1} K(m_k, m_j) N_j\n$$\n这个表达式是积分损失项的直接离散化。\n\n### 3. 增益项 ($S_k$) 的推导\n\n增益项代表新粒子的形成。来自第 $i$ 档的粒子和来自第 $j$ 档的粒子之间的碰撞会产生一个质量为 $m_p = m_i + m_j$ 的新碰并粒子。\n\n为避免重复计数，我们对满足 $i \\le j$ 的唯一对 $(i,j)$ 进行求和。由这样一对粒子形成新粒子的数生成率为：\n$$\n\\hat{C}_{ij} = \\begin{cases} K(m_i, m_j) N_i N_j  \\text{若 } i  j \\\\ \\frac{1}{2} K(m_i, m_i) N_i^2  \\text{若 } i = j \\end{cases}\n$$\n\n新形成的质量为 $m_p$ 的粒子通常不会与网格枢轴重合。我们使用质量比例重分配格式将其分配到两个最近的界定枢轴上。设这些枢轴为 $m_k$ 和 $m_{k+1}$，使得 $m_k \\le m_p \\le m_{k+1}$。为了保证质量守恒，由碰撞 $(i,j)$ 产生的质量必须被完全分配到目标档 $k$ 和 $k+1$。每次碰撞产生的质量为 $m_p=m_i+m_j$，其速率为 $\\hat{C}_{ij}$。因此，质量生成速率为 $\\hat{C}_{ij}(m_i+m_j)$。这个质量速率必须等于分配到目标档的质量速率之和，即 $\\Delta S_k m_k + \\Delta S_{k+1} m_{k+1}$，其中 $\\Delta S_k$ 和 $\\Delta S_{k+1}$ 是来自该次碰撞对 $S_k$ 和 $S_{k+1}$ 的贡献。同时，数生成率 $\\hat{C}_{ij}$ 也必须被完全分配，即 $\\hat{C}_{ij} = \\Delta S_k + \\Delta S_{k+1}$。联立求解这两个守恒方程：\n$$\n\\begin{cases} \\hat{C}_{ij}(m_i+m_j) = \\Delta S_k m_k + \\Delta S_{k+1} m_{k+1} \\\\ \\hat{C}_{ij} = \\Delta S_k + \\Delta S_{k+1} \\end{cases}\n$$\n解得贡献率为：\n$$\n\\Delta S_k = \\hat{C}_{ij} \\frac{m_{k+1} - (m_i+m_j)}{m_{k+1} - m_k} \\quad \\text{和} \\quad \\Delta S_{k+1} = \\hat{C}_{ij} \\frac{(m_i+m_j) - m_k}{m_{k+1} - m_k}\n$$\n第 $k$ 档的总源项 $S_k$ 是所有可能的碰撞对 $(i,j)$ 向第 $k$ 档贡献的总和。\n\n### 4. 质量守恒证明\n\n该格式通过构造保证了质量守恒。对于每个单独的碰撞事件 $(i,j)$，损失的质量是 $(m_i+m_j)$，其速率为 $\\hat{C}_{ij}$。生成的质量也被设计为 $(m_k \\Delta S_k / \\hat{C}_{ij} + m_{k+1} \\Delta S_{k+1} / \\hat{C}_{ij})$，其速率为 $\\hat{C}_{ij}$。根据重分配权重的推导，括号内的项恰好等于 $m_i+m_j$。因此，在每次碰撞中，损失的质量等于生成的质量。对所有碰撞对求和，总质量增益率精确地等于总质量损失率，从而保证了离散总质量的守恒（在浮点运算精度内）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the final results.\n    \"\"\"\n\n    # Define the common mass grid for all test cases.\n    m_pivots = np.array([1e-12, 2e-12, 4e-12, 8e-12, 16e-12], dtype=np.float64)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Test 1 (happy path, constant kernel)\",\n            \"kernel_func\": lambda m_i, m_j: 1e-12,\n            \"N_initial\": np.array([1e5, 5e4, 2e4, 1e4, 0], dtype=np.float64),\n            \"dt\": 5.0\n        },\n        {\n            \"name\": \"Test 2 (mass-dependent additive kernel, moderate change)\",\n            \"kernel_func\": lambda m_i, m_j: 10.0 * (m_i + m_j),\n            \"N_initial\": np.array([5e4, 5e4, 0, 2e4, 0], dtype=np.float64),\n            \"dt\": 0.5\n        },\n        {\n            \"name\": \"Test 3 (boundary bracketing exactly at top pivot, constant kernel)\",\n            \"kernel_func\": lambda m_i, m_j: 5e-13,\n            \"N_initial\": np.array([0, 0, 3e4, 3e4, 0], dtype=np.float64),\n            \"dt\": 10.0\n        },\n        {\n            \"name\": \"Test 4 (tiny time step, constant kernel, stability check)\",\n            \"kernel_func\": lambda m_i, m_j: 1e-12,\n            \"N_initial\": np.array([1e5, 1e5, 1e5, 0, 0], dtype=np.float64),\n            \"dt\": 1e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_coagulation_step(m_pivots, case[\"N_initial\"], case[\"dt\"], case[\"kernel_func\"])\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_coagulation_step(m_grid, N_initial, dt, kernel_func):\n    \"\"\"\n    Performs one time step of coagulation using the derived conservative scheme.\n\n    Args:\n        m_grid (np.ndarray): Array of mass pivots (kg).\n        N_initial (np.ndarray): Array of initial number concentrations (m^-3).\n        dt (float): Time step (s).\n        kernel_func (callable): Function K(m_i, m_j) returning the kernel value (m^3 s^-1).\n\n    Returns:\n        float: Absolute mass conservation error (kg m^-3).\n    \"\"\"\n    K = len(m_grid)\n    N = np.copy(N_initial)\n\n    # 1. Calculate initial total mass\n    M_initial = np.sum(m_grid * N)\n\n    # 2. Pre-compute the symmetric kernel matrix\n    K_matrix = np.zeros((K, K), dtype=np.float64)\n    for i in range(K):\n        for j in range(i, K):\n            val = kernel_func(m_grid[i], m_grid[j])\n            K_matrix[i, j] = val\n            K_matrix[j, i] = val\n\n    # 3. Calculate the loss term vector L\n    L = N * (K_matrix @ N)\n\n    # 4. Calculate the source term vector S\n    S = np.zeros(K, dtype=np.float64)\n    for i in range(K):\n        for j in range(i, K):\n            if N[i] == 0.0 or N[j] == 0.0:\n                continue\n\n            # Calculate the number production rate for the pair (i, j)\n            if i == j:\n                C_ij = 0.5 * K_matrix[i, i] * N[i] * N[i]\n            else:  # i  j\n                C_ij = K_matrix[i, j] * N[i] * N[j]\n            \n            # Form aggregate particle and check if it's within the grid mass range\n            m_p = m_grid[i] + m_grid[j]\n            \n            if not (m_grid[0] = m_p = m_grid[-1]):\n                # Per problem, this condition is satisfied by the test suite.\n                # In a real model, this mass would need to be handled.\n                raise ValueError(f\"Product mass {m_p} is outside the grid range [{m_grid[0]}, {m_grid[-1]}]\")\n\n            # Find bracketing pivots and redistribute mass\n            # 'searchsorted' finds the insertion index to maintain order. 'left' side returns the first suitable index.\n            k_high_idx = np.searchsorted(m_grid, m_p, side='left')\n\n            # Case 1: Product mass falls exactly on a pivot\n            if k_high_idx  K and np.isclose(m_grid[k_high_idx], m_p):\n                S[k_high_idx] += C_ij\n            # Case 2: Product mass falls between two pivots\n            else:\n                k_low_idx = k_high_idx - 1\n                \n                m_low = m_grid[k_low_idx]\n                m_high = m_grid[k_high_idx]\n                \n                denominator = m_high - m_low\n                \n                # These are the derived mass-conserving redistribution weights\n                weight_low = (m_high - m_p) / denominator\n                weight_high = (m_p - m_low) / denominator\n                \n                # Distribute the number rate C_ij according to the weights\n                S[k_low_idx] += C_ij * weight_low\n                S[k_high_idx] += C_ij * weight_high\n\n    # 5. Update number concentrations using forward Euler\n    N_new = N + dt * (S - L)\n    \n    # 6. Calculate final total mass\n    M_final = np.sum(m_grid * N_new)\n    \n    # 7. Calculate and return the absolute mass conservation error\n    error = np.abs(M_final - M_initial)\n    return error\n\nsolve()\n```"
        }
    ]
}