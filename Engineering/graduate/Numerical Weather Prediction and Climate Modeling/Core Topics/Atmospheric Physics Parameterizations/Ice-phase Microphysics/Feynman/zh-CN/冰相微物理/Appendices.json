{
    "hands_on_practices": [
        {
            "introduction": "在混合相云中，冰的初始形成并非一蹴而就。气溶胶粒子既可以先形成一个随后冻结的液滴，也可以直接从水汽中核化成冰。这个分岔口由热力学决定，特别是开尔文效应（曲率）、拉乌尔效应（溶质）以及环境相对于水和冰的饱和度之间的竞争。本练习  旨在挑战您将这些基本原理应用于一个真实的涂层尘埃粒子情景，从而磨练您诊断主导微物理路径的能力，这是大气建模中的一项关键技能。",
            "id": "4054072",
            "problem": "一个带有半径为 $r_c = 0.25\\,\\mu\\mathrm{m}$ 的不溶性核的包裹矿物尘埃颗粒，其表面带有一层薄的可溶性硫酸盐外壳，遇湿后会完全溶解。空气温度为 $T = -12\\,^{\\circ}\\mathrm{C}$，相对于液态水的饱和比为 $S_w = 1.01$。考虑在与数值天气预报（NWP）和气候模型相关的混合相云中的初始活化路径，其起始模式可能是水汽凝结成液滴后发生沉浸冻结，或者是直接的凝华成冰核化。分析必须从基本热力学关系和毛细效应出发。\n\n使用开尔文方程和理想溶液形式的拉乌尔定律作为评估弯曲水溶液界面上平衡饱和度的基础。开尔文曲率因子由以下参数控制：\n$$\nA = \\frac{2\\,\\sigma_w\\,M_w}{R\\,T\\,\\rho_w},\n$$\n其中 $\\sigma_w$ 是水的表面张力，$M_w$ 是水的摩尔质量，$R$ 是普适气体常数，$T$ 是绝对温度，$\\rho_w$ 是液态水的密度。假设在 $T=261.15\\,\\mathrm{K}$ 时，$\\sigma_w \\approx 0.076\\,\\mathrm{N\\,m^{-1}}$，$M_w = 0.018\\,\\mathrm{kg\\,mol^{-1}}$，$R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$，且 $\\rho_w = 1000\\,\\mathrm{kg\\,m^{-3}}$。为了评估凝结和凝华之间的竞争，取 $T=-12\\,^{\\circ}\\mathrm{C}$ 时水面饱和水汽压与冰面饱和水汽压之比为 $e_{sw}(T)/e_{si}(T) \\approx 1.18$（这是一个经过充分验证的热力学事实），因此环境相对于冰的饱和比为 $S_i = S_w\\,e_{sw}/e_{si}$。\n\n在此情景下，哪个陈述最能描述物理上一致的起始模式以及开尔文效应与不溶性核的作用？\n\nA. 对于亚微米颗粒，在 $S_w=1.01$ 时，凝结被开尔文效应所阻止，因此包裹的尘埃作为凝华冰核（INP）发挥作用，由于 $S_i>1$ 而直接引发成冰。\n\nB. 不溶性核增大了初始曲率半径，降低了开尔文势垒，从而在 $S_w=1.01$ 时发生凝结活化；可溶性外壳通过拉乌尔效应进一步降低了平衡饱和度，使得液滴得以生长，此后在 $T=-12\\,^{\\circ}\\mathrm{C}$ 时，沉浸冻结是可能的成冰路径。\n\nC. 相对于纯可溶性气溶胶，不溶性核的存在增加了开尔文势垒，使得凝结和凝华都不太可能发生；如果发生冻结，也只会通过碰撞后的接触机制发生。\n\nD. 因为 $S_i \\gg S_w$，凝华核化和凝结在包裹的尘埃上同时发生，直接形成冰的同时也生长液滴，而不溶性核在曲率效应中不起作用。",
            "solution": "该问题要求分析一个包裹的矿物尘埃颗粒在过冷云环境中的初始活化路径。该颗粒由一个不溶性核和一个可溶性外壳组成。给定的环境条件为温度 $T = -12\\,^{\\circ}\\mathrm{C}$ 和相对于液态水的饱和比 $S_w = 1.01$。我们必须确定该颗粒是首先作为云凝结核（CCN）形成液滴，还是作为冰核（INP）通过凝华直接形成冰。\n\n首先，让我们验证物理参数并建立理论框架。气溶胶颗粒作为CCN的活化由科勒理论决定，该理论结合了开尔文（曲率）效应和拉乌尔（溶质）效应。\n\n半径为 $r_d$ 的水溶液滴上的平衡饱和比 $S_{eq}$ 由下式给出：\n$$ S_{eq}(r_d) = a_w \\cdot K(r_d) $$\n其中 $a_w$ 是溶液中水的活度（拉乌尔效应），$K(r_d)$ 是开尔文曲率因子。\n\n开尔文因子由下式给出：\n$$ K(r_d) = \\exp\\left(\\frac{2\\,\\sigma_w\\,M_w}{R\\,T\\,\\rho_w\\,r_d}\\right) = \\exp\\left(\\frac{A}{r_d}\\right) $$\n参数 $A$ 在问题中已定义。让我们使用给定的常数计算其值：\n-   温度, $T = -12\\,^{\\circ}\\mathrm{C} = 261.15\\,\\mathrm{K}$\n-   水的表面张力, $\\sigma_w = 0.076\\,\\mathrm{N\\,m^{-1}}$\n-   水的摩尔质量, $M_w = 0.018\\,\\mathrm{kg\\,mol^{-1}}$\n-   普适气体常数, $R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$\n-   液态水的密度, $\\rho_w = 1000\\,\\mathrm{kg\\,m^{-3}}$\n\n$$ A = \\frac{2 \\cdot (0.076\\,\\mathrm{N\\,m^{-1}}) \\cdot (0.018\\,\\mathrm{kg\\,mol^{-1}})}{(8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\cdot (261.15\\,\\mathrm{K}) \\cdot (1000\\,\\mathrm{kg\\,m^{-3}})} $$\n$$ A = \\frac{0.002736}{2171819.1} \\, \\mathrm{m} \\approx 1.2598 \\times 10^{-9}\\,\\mathrm{m} $$\n因此，$A \\approx 1.26\\,\\mathrm{nm}$。\n\n该颗粒有一个半径为 $r_c = 0.25\\,\\mu\\mathrm{m} = 250\\,\\mathrm{nm}$ 的不溶性核。当液滴在该颗粒上形成时，其半径 $r_d$ 必须大于或至少等于核的半径，即 $r_d \\ge r_c$。开尔文效应会增加弯曲表面上的平衡水汽压。对于最小的曲率半径，该效应最大。在这种情况下，最小曲率半径由不溶性核 $r_c$ 决定。\n\n让我们通过考虑最小可能的液滴半径 $r_d = r_c$ 来评估开尔文效应可能造成的最大势垒。这代表了仅由曲率项所要求的最高平衡饱和度。\n$$ K_{max} = K(r_c) = \\exp\\left(\\frac{A}{r_c}\\right) = \\exp\\left(\\frac{1.26\\,\\mathrm{nm}}{250\\,\\mathrm{nm}}\\right) = \\exp(0.00504) \\approx 1.00505 $$\n这意味着，要在半径为 $250\\,\\mathrm{nm}$ 的不溶性球体上生长液滴，环境饱和比必须超过大约 $1.005$。与均相核化或在小得多的颗粒上核化所需相比，核的较大尺寸显著 *降低* 了开尔文势垒。\n\n给定的环境饱和比为 $S_w = 1.01$。由于 $S_w = 1.01 > 1.00505$，即使不考虑溶质效应，环境过饱和度也足以克服开尔文势垒。\n\n现在，我们必须考虑由“薄的可溶性硫酸盐外壳”引起的拉乌尔效应。当凝结开始时，此外壳溶解，形成水溶液。溶质的存在降低了水的活度，$a_w  1$。这降低了液滴与环境达到平衡所需的平衡饱和比。完整的科勒方程表明 $S_{eq}$ 是拉乌尔项和开尔文项的乘积。由于 $a_w  1$，实际的平衡曲线将位于纯开尔文曲线之下，而活化所需的临界饱和比 $S_{crit}$ 将会更低：$S_{crit}  1.00505$。由于环境饱和度 $S_w = 1.01$ 远高于最大可能活化势垒，该颗粒将作为CCN被活化，形成并生长一个过冷液滴。\n\n接下来，我们评估直接凝华核化的可能性。此过程要求空气相对于冰是过饱和的，即 $S_i > 1$。饱和比之间的关系由 $S_i = S_w \\cdot (e_{sw}/e_{si})$ 给出。\n使用给定的值 $S_w = 1.01$ 和 $e_{sw}/e_{si} \\approx 1.18$：\n$$ S_i = 1.01 \\times 1.18 \\approx 1.1918 $$\n由于 $S_i > 1$，环境相对于冰是过饱和的，这使得凝华核化在热力学上是可能的。众所周知，矿物尘埃是一种有效的凝华核。\n\n然而，问题问的是*起始模式*。我们必须考虑动力学。在水面过饱和（$S_w > 1$）条件下，水汽在可溶或部分可溶的CCN上凝结是一个非常快的过程。一旦相对湿度超过颗粒的活化阈值（我们已经证明该阈值小于1.01），一层液膜将迅速包裹该颗粒。一旦颗粒被液态水包裹，从水汽到固体表面的直接凝华就不再可能。任何随后的冰形成都必须在过冷液滴内部发生，这个过程被称为沉浸冻结。在 $T = -12\\,^{\\circ}\\mathrm{C}$ 时，由矿物尘埃引发的沉浸冻结是混合相云中冰形成的主要机制。\n\n因此，物理上最一致的顺序是：\n1. 由于低的开尔文势垒（来自大尺寸的核）和溶质效应（来自硫酸盐外壳），颗粒作为CCN被快速活化。\n2. 过冷液滴的生长。\n3. 该液滴随后通过由矿物尘埃核核化的沉浸冻结过程发生冻结。\n\n现在我们基于此分析评估给出的选项。\n\n**A. 对于亚微米颗粒，在 $S_w=1.01$ 时，凝结被开尔文效应所阻止，因此包裹的尘埃作为凝华冰核（INP）发挥作用，由于 $S_i1$ 而直接引发成冰。**\n这个陈述是不正确的。该颗粒的核相对较大（$r_c = 0.25\\,\\mu\\mathrm{m}$），这使得开尔vin势垒非常小（$S \\approx 1.005$）。因此，凝结*没有*被阻止，反而是被促进了。其主要前提是错误的。\n**结论：不正确。**\n\n**B. 不溶性核增大了初始曲率半径，降低了开尔文势垒，从而在 $S_w=1.01$ 时发生凝结活化；可溶性外壳通过拉乌尔效应进一步降低了平衡饱和度，使得液滴得以生长，此后在 $T=-12\\,^{\\circ}\\mathrm{C}$ 时，沉浸冻结是可能的成冰路径。**\n这个陈述准确地描述了物理过程。不溶性核作为一个大的基底，降低了开尔文势垒。可溶性外壳通过拉乌尔效应进一步降低了所需的饱和度。因此，在 $S_w = 1.01$ 时，凝结活化是确定无疑的。随后的成冰路径被正确地确定为沉浸冻结。这与我们的推导完全吻合。\n**结论：正确。**\n\n**C. 相对于纯可溶性气溶胶，不溶性核的存在增加了开尔文势垒，使得凝结和凝华都不太可能发生；如果发生冻结，也只会通过碰撞后的接触机制发生。**\n这个陈述是不正确的。它错误地声称凝结是“不太可能”的，而我们的分析表明它是确定无疑的。与纯可溶性气溶胶的比较是一个潜在的误导信息；关键点在于在给定条件下是否会发生活化，而事实是会发生。关于凝华也“不太可能”的结论是没有根据的，因为 $S_i \\approx 1.19$。整个推理过程都有缺陷。\n**结论：不正确。**\n\n**D. 因为 $S_i \\gg S_w$，凝华核化和凝结在包裹的尘埃上同时发生，直接形成冰的同时也生长液滴，而不溶性核在曲率效应中不起作用。**\n这个陈述包含多处错误。关于凝华和凝结同时发生的断言在物理上是不现实的；凝结和表面润湿会排除凝华的发生。最关键的是，声称不溶性核在曲率效应中“不起作用”是根本上错误的。核的半径决定了形成液滴的最小曲率，并且是开尔文效应分析的核心。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "一旦冰晶群体形成，其通过水汽凝华生长是影响云演变和降水的主要过程。模型需要一种高效的方法来表示一个网格框内所有晶体的总增长。单个晶体的生长取决于其晶习（形状），这会影响其收集水汽的能力；而整个群体的总（或“块状”）生长速率，是单个晶体生长速率按数量和晶习加权的平均值。通过这个练习 ，您将推导并计算一个块状凝华增长系数，从而将单颗粒物理学与大规模数值模型中使用的参数化方案联系起来，展示了为提高计算效率而如何简化复杂的微物理过程。",
            "id": "4054067",
            "problem": "考虑一个嵌入在数值天气预报（NWP）和气候模型中的冰相微物理模块，该模块描述水汽在非球形冰晶上的凝华过程。在稳态的扩散限制增长条件下，流向单个孤立冰晶的水汽通量由菲克定律和稳态热传导方程决定，这两者共同意味着当与饱和状态偏差较小时，单颗粒质量增长率与冰面过饱和度之间存在近似线性的关系。对于每种晶习 $h$（例如，片状或柱状），单颗粒的凝华质量增长率可近似表示为\n$$\\frac{dm_h}{dt} \\approx C_h \\left(S_i - 1\\right),$$\n其中，$S_i$ 是相对于冰面的饱和比，$C_h$ 是一个与晶习相关的凝华增长系数，该系数包含了冰晶的几何电容、通风效应以及空气的扩散和热阻。\n\n一个混合的冰晶粒子群占据单位体积的空气，其总数浓度为 $N$，其中片状冰晶的晶习分数为 $f_P$，柱状冰晶的晶习分数为 $f_C$，且满足 $f_P + f_C = 1$。假设以下条件，这些条件代表了对流层中层的云层特征：\n- 温度 $T = 258\\,\\mathrm{K}$ 和气压 $p = 700\\,\\mathrm{hPa}$。\n- 总冰晶数浓度 $N = 2.0 \\times 10^{5}\\,\\mathrm{m}^{-3}$。\n- 晶习分数 $f_P = 0.65$ 和 $f_C = 0.35$。\n- 在这些条件下，特定晶习的单颗粒凝华系数（经过热力学和空气动力学校正）为：\n  片状冰晶：$C_P = 4.8 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$，柱状冰晶：$C_C = 6.0 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$。\n\n从质量守恒定律以及由扩散和热传导控制方程所蕴含的线性叠加原理出发，推导与晶习相关的加权体积凝华增长系数 $C_{\\mathrm{eff}}$，使得单位体积内水汽到冰的总凝华趋势可以写作\n$$\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = C_{\\mathrm{eff}} \\left(S_i - 1\\right).$$\n使用所提供的参数计算 $C_{\\mathrm{eff}}$ 的数值。用 $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$ 单位表示你的最终答案，并四舍五入至四位有效数字。",
            "solution": "### 步骤1：提取已知条件\n- 晶习为 $h$ 的单颗粒质量增长率：$\\frac{dm_h}{dt} \\approx C_h (S_i - 1)$\n- 总冰晶数浓度：$N = 2.0 \\times 10^{5}\\,\\mathrm{m}^{-3}$\n- 片状冰晶的晶习分数：$f_P = 0.65$\n- 柱状冰晶的晶习分数：$f_C = 0.35$\n- 约束条件：$f_P + f_C = 1$\n- 片状冰晶的凝华增长系数：$C_P = 4.8 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$\n- 柱状冰晶的凝华增长系数：$C_C = 6.0 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$\n- 体积凝华趋势的表达式：$\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = C_{\\mathrm{eff}} (S_i - 1)$\n\n### 步骤2：推导体积凝华增长系数 $C_{\\mathrm{eff}}$\n单位体积内水汽到冰的总凝华趋势 $\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}}$ 是所有冰晶凝华增长率的总和。一个混合的冰晶群包含两种晶习：片状和柱状。\n- 单位体积内片状冰晶的数量为 $N_P = N \\cdot f_P$。\n- 单位体积内柱状冰晶的数量为 $N_C = N \\cdot f_C$。\n总增长率是片状和柱状冰晶增长率之和：\n$$ \\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = N_P \\cdot \\left(\\frac{dm_P}{dt}\\right) + N_C \\cdot \\left(\\frac{dm_C}{dt}\\right) $$\n将单颗粒增长率的表达式代入：\n$$ \\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = (N \\cdot f_P) \\cdot [C_P (S_i - 1)] + (N \\cdot f_C) \\cdot [C_C (S_i - 1)] $$\n提取公因式 $(S_i - 1)$ 和 $N$：\n$$ \\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = \\left[ N (f_P C_P + f_C C_C) \\right] (S_i - 1) $$\n通过与目标表达式 $\\left.\\frac{dM_{\\mathrm{dep}}}{dt}\\right|_{\\mathrm{bulk}} = C_{\\mathrm{eff}} (S_i - 1)$ 进行比较，我们得到：\n$$ C_{\\mathrm{eff}} = N (f_P C_P + f_C C_C) $$\n\n### 步骤3：代入数值计算 $C_{\\mathrm{eff}}$\n将已知数值代入上式：\n- $N = 2.0 \\times 10^{5}\\,\\mathrm{m}^{-3}$\n- $f_P = 0.65$\n- $C_P = 4.8 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$\n- $f_C = 0.35$\n- $C_C = 6.0 \\times 10^{-11}\\,\\mathrm{kg\\,s^{-1}}$\n$$ C_{\\mathrm{eff}} = (2.0 \\times 10^{5}) \\times [ (0.65 \\times 4.8 \\times 10^{-11}) + (0.35 \\times 6.0 \\times 10^{-11}) ] $$\n$$ C_{\\mathrm{eff}} = (2.0 \\times 10^{5}) \\times [ 3.12 \\times 10^{-11} + 2.1 \\times 10^{-11} ] $$\n$$ C_{\\mathrm{eff}} = (2.0 \\times 10^{5}) \\times [ 5.22 \\times 10^{-11} ] $$\n$$ C_{\\mathrm{eff}} = 10.44 \\times 10^{-6} = 1.044 \\times 10^{-5} \\,\\mathrm{kg\\,m^{-3}\\,s^{-1}} $$\n\n### 步骤4：最终答案\n将结果四舍五入至四位有效数字，最终答案为 $1.044 \\times 10^{-5}\\,\\mathrm{kg\\,m^{-3}\\,s^{-1}}$。",
            "answer": "$$\\boxed{1.044 \\times 10^{-5}}$$"
        },
        {
            "introduction": "除了从水汽中生长，冰晶还通过碰撞并粘合在一起（一个称为“聚合”的过程）来增长。精确地模拟这个过程对计算要求很高，而确保总质量守恒是任何数值方案的基本要求。Smoluchowski 碰并方程从数学上描述了这一过程，一个守恒的数值方案在离散化该方程的同时，能确保碰撞粒子损失的总质量精确等于新形成的聚合体获得的总质量。这项高级练习  要求您从第一性原理出发，设计并实现一个质量守恒的碰并方案。这项实践性的编码任务让您直接体验数值挑战和守恒定律，这些都是现代天气和气候模型中微物理参数化方案开发的核心。",
            "id": "4054051",
            "problem": "在用于数值天气预报（NWP）和气候模式的冰相微物理学中，冰粒子的聚合（凝并）过程在守恒总冰质量的同时，改变了数浓度分布。考虑粒子质量为 $m$ 的数浓度分布 $n(m,t)$ 的连续Smoluchowski凝并方程：\n$$\n\\frac{\\partial n(m,t)}{\\partial t}\n=\n\\frac{1}{2}\\int_{0}^{m} K(m',m-m')\\,n(m',t)\\,n(m-m',t)\\,\\mathrm{d}m'\n-\nn(m,t)\\int_{0}^{\\infty} K(m,m')\\,n(m',t)\\,\\mathrm{d}m',\n$$\n其中 $K(m,m')$ 是对称的凝并核函数，单位为 $\\mathrm{m^3\\,s^{-1}}$。\n\n请在离散质量网格 $\\{m_k\\}_{k=0}^{K-1}$ 上，为凝并积分设计一个使用固定主元的守恒数值方案。该网格具有固定的档（bin）主元质量 $m_k$（单位为 $\\mathrm{kg}$）和数浓度 $\\{N_k\\}_{k=0}^{K-1}$（单位为 $\\mathrm{m^{-3}}$）。您的方案必须：\n- 从第一性原理出发离散化增益和损失项，不使用任何预先推导的离散化捷径。\n- 在理想精度计算的极限下，对于任何足够小以维持非负性的显式向前欧拉时间步长 $\\Delta t$（单位为 $\\mathrm{s}$），精确守恒离散一阶矩（总质量）$M(t)=\\sum_{k=0}^{K-1} m_k N_k(t)$。\n- 使用按质量比例的再分配方法，将聚合产物质量 $m_p=m_i+m_j$ 分配到框定它的两个最近的主元上。\n- 确保对 $(i,j)$（其中 $i \\neq j$）的粒子对只计数一次，并且自碰撞 $(i=j)$ 不被重复计数，从而与碰撞的对称性一致地处理粒子对的生成率。\n\n仅从上述连续积分方程和离散分档的定义出发，推导保证离散质量守恒的固定主元再分配权重，并实现该方案以执行一次向前欧拉更新：\n$$\nN_k^{(t+\\Delta t)} = N_k^{(t)} + \\Delta t\\left(S_k - L_k\\right),\n$$\n其中 $S_k$ 是聚合增益进入档 $k$ 的源项，$L_k$ 是档 $k$ 中粒子参与碰撞造成的损失，二者的单位均为 $\\mathrm{m^{-3}\\,s^{-1}}$。\n\n您的程序必须：\n- 对下面指定的每个测试用例，实现核函数 $K(m_i,m_j)$。\n- 使用您推导的守恒固定主元方案，计算单个时间步长 $\\Delta t$ 后更新的 $\\{N_k\\}$。\n- 验证并报告绝对质量守恒误差\n$$\nE = \\left|\\sum_{k=0}^{K-1} m_k N_k^{(t+\\Delta t)} - \\sum_{k=0}^{K-1} m_k N_k^{(t)}\\right|\n$$\n该误差的单位为千克每立方米（$\\mathrm{kg\\,m^{-3}}$），并以浮点数形式表示。\n- 断言所有以非零生成率出现的聚合产物质量 $m_p=m_i+m_j$ 都落在主元范围 $[m_0,m_{K-1}]$ 内，以便两个主元的框定是良定义的。如果违反此条件，方案不得继续执行（对于所提供的测试套件，此条件因其构造而成立）。\n\n物理单位和约定：\n- 质量 $m_k$ 的单位是 $\\mathrm{kg}$。\n- 数浓度 $N_k$ 的单位是 $\\mathrm{m^{-3}}$。\n- 核函数 $K(m_i,m_j)$ 的单位是 $\\mathrm{m^3\\,s^{-1}}$。\n- 时间步长 $\\Delta t$ 的单位是 $\\mathrm{s}$。\n- 守恒误差 $E$ 必须以 $\\mathrm{kg\\,m^{-3}}$ 为单位报告。\n\n测试套件（所有测试均使用相同的 $K=5$ 个档的主元集，呈公比为2的几何级数：$m_0=10^{-12}\\,\\mathrm{kg}$, $m_1=2\\times 10^{-12}\\,\\mathrm{kg}$, $m_2=4\\times 10^{-12}\\,\\mathrm{kg}$, $m_3=8\\times 10^{-12}\\,\\mathrm{kg}$, $m_4=16\\times 10^{-12}\\,\\mathrm{kg}$）：\n- 测试1（理想路径，常数核函数）：\n  - 核函数：$K(m_i,m_j)=K_0$，其中 $K_0=10^{-12}\\,\\mathrm{m^3\\,s^{-1}}$。\n  - 初始 $N$：$[10^{5},\\,5\\times 10^{4},\\,2\\times 10^{4},\\,10^{4},\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 5\\,\\mathrm{s}$。\n- 测试2（依赖于质量的加性核函数，中等变化）：\n  - 核函数：$K(m_i,m_j)=\\beta\\,(m_i+m_j)$，其中 $\\beta=10\\,\\mathrm{m^3\\,s^{-1}\\,kg^{-1}}$。\n  - 初始 $N$：$[5\\times 10^{4},\\,5\\times 10^{4},\\,0,\\,2\\times 10^{4},\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 0.5\\,\\mathrm{s}$。\n- 测试3（边界框定恰好在顶层主元上，常数核函数）：\n  - 核函数：$K(m_i,m_j)=K_0$，其中 $K_0=5\\times 10^{-13}\\,\\mathrm{m^3\\,s^{-1}}$。\n  - 初始 $N$：$[0,\\,0,\\,3\\times 10^{4},\\,3\\times 10^{4},\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 10\\,\\mathrm{s}$。\n- 测试4（极小时间步长，常数核函数，稳定性检查）：\n  - 核函数：$K(m_i,m_j)=K_0$，其中 $K_0=10^{-12}\\,\\mathrm{m^3\\,s^{-1}}$。\n  - 初始 $N$：$[10^{5},\\,10^{5},\\,10^{5},\\,0,\\,0]\\,\\mathrm{m^{-3}}$。\n  - $\\Delta t = 10^{-6}\\,\\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试的守恒误差，格式为方括号内以逗号分隔的列表，例如：\"[e1,e2,e3,e4]\"。每个 $e_i$ 必须是表示相应测试的绝对质量守恒误差 $E$（单位为 $\\mathrm{kg\\,m^{-3}}$）的浮点数。",
            "solution": "### 1. 离散化框架\n\n连续Smoluchowski凝并方程描述了数浓度分布 $n(m,t)$ 作为粒子质量 $m$ 和时间 $t$ 的函数的演变：\n$$\n\\frac{\\partial n(m,t)}{\\partial t}\n=\n\\underbrace{\\frac{1}{2}\\int_{0}^{m} K(m',m-m')\\,n(m',t)\\,n(m-m',t)\\,\\mathrm{d}m'}_{\\text{增益项}}\n-\n\\underbrace{n(m,t)\\int_{0}^{\\infty} K(m,m')\\,n(m',t)\\,\\mathrm{d}m'}_{\\text{损失项}}\n$$\n我们将此方程离散化到一组固定的质量主元 $\\{m_k\\}_{k=0}^{K-1}$ 上，其对应的数浓度为 $\\{N_k\\}_{k=0}^{K-1}$（单位为 $\\mathrm{m^{-3}}$）。时间演变使用向前欧拉步长来近似：\n$$\nN_k^{(t+\\Delta t)} = N_k^{(t)} + \\Delta t\\left(S_k - L_k\\right)\n$$\n这里，$L_k$ 和 $S_k$ 分别是档 $k$ 中粒子的离散损失率和源项（增益）率，单位均为 $\\mathrm{m^{-3}\\,s^{-1}}$。我们的主要目标是推导出保证总质量 $M = \\sum_{k=0}^{K-1} m_k N_k$ 守恒的 $S_k$ 和 $L_k$ 的表达式。\n\n### 2. 损失项 ($L_k$) 的推导\n\n连续方程中的损失项表示质量为 $m$ 的粒子因与任何其他粒子碰撞而被移除。在我们的离散框架中，当一个来自档 $k$（质量 $m_k$，浓度 $N_k$）的粒子与来自任何档 $j$（质量 $m_j$，浓度 $N_j$）的粒子碰撞时，就会发生损失，其中 $j$ 的范围是从 $0$ 到 $K-1$。\n\n档 $k$ 和档 $j$ 之间的粒子单位体积碰撞率由 $K(m_k, m_j) N_k N_j$ 给出。为了找到档 $k$ 中粒子的总损失率，我们将它与所有档的粒子碰撞率相加：\n$$\nL_k = N_k \\sum_{j=0}^{K-1} K(m_k, m_j) N_j\n$$\n这个表达式是积分损失项的直接离散化。\n\n### 3. 增益项 ($S_k$) 的推导\n\n增益项表示新粒子的形成。在离散模型中，一个来自档 $i$ 的粒子和一个来自档 $j$ 的粒子碰撞会产生一个新的聚合粒子，其质量为 $m_p = m_i + m_j$。\n\n为避免重复计数，我们对满足 $i \\le j$ 的唯一粒子对 $(i,j)$ 进行求和。由这样一个粒子对形成新粒子的速率为：\n$$\n\\hat{C}_{ij} = \\begin{cases} K(m_i, m_j) N_i N_j  \\text{若 } i  j \\\\ \\frac{1}{2} K(m_i, m_i) N_i^2  \\text{若 } i = j \\end{cases}\n$$\n对于自碰撞（$i=j$），因子 $\\frac{1}{2}$ 是为了修正，因为每次碰撞涉及两个相同的粒子，而我们是在对粒子对进行计数。\n\n新形成的质量为 $m_p$ 的粒子通常不会恰好落在网格主元上。问题指定了一个按质量比例的再分配方案，将其分配到两个最近的框定主元上。设这些主元为 $m_k$ 和 $m_{k+1}$，使得 $m_k \\le m_p \\le m_{k+1}$。每次碰撞产生的粒子数率 $\\hat{C}_{ij}$ 必须分配给档 $k$ 和 $k+1$，以确保质量守恒。设分配到档 $k$ 的数率为 $S_k^{ij}$，分配到档 $k+1$ 的数率为 $S_{k+1}^{ij}$。我们要求：\n$$\n\\begin{cases} S_k^{ij} + S_{k+1}^{ij} = \\hat{C}_{ij}  (\\text{粒子数守恒}) \\\\ S_k^{ij} m_k + S_{k+1}^{ij} m_{k+1} = \\hat{C}_{ij} m_p  (\\text{质量守恒}) \\end{cases}\n$$\n解这个方程组，得到分配到每个档的数率：\n$$\nS_k^{ij} = \\hat{C}_{ij} \\frac{m_{k+1} - m_p}{m_{k+1} - m_k} \\quad \\text{以及} \\quad S_{k+1}^{ij} = \\hat{C}_{ij} \\frac{m_p - m_k}{m_{k+1} - m_k}\n$$\n因此，档 $k$ 的总源项 $S_k$ 是所有可能的碰撞对 $(i,j)$ 向档 $k$ 输送质量的所有贡献之和。\n\n### 4. 质量守恒证明\n\n为了证明该方案是质量守恒的，我们必须证明总质量增益率等于总质量损失率。\n由单个碰撞事件 $(i,j)$ 每单位时间添加到系统中的总质量为：\n$$ \\text{来自 }(i,j)\\text{ 的质量增益率} = S_k^{ij} m_k + S_{k+1}^{ij} m_{k+1} = \\hat{C}_{ij} m_p = \\hat{C}_{ij} (m_i + m_j) $$\n总质量增益率是所有唯一碰撞对的总和：\n$$ \\text{总质量增益率} = \\sum_{k=0}^{K-1} m_k S_k = \\sum_{i=0}^{K-1} \\sum_{j=i}^{K-1} (m_i + m_j) \\hat{C}_{ij} $$\n展开 $\\hat{C}_{ij}$ 的定义，并利用核函数的对称性（$K(m_i, m_j) = K(m_j, m_i)$），可以证明这个表达式等于总质量损失率：\n$$ \\text{总质量损失率} = \\sum_{k=0}^{K-1} m_k L_k = \\sum_{i=0}^{K-1} \\sum_{j=0}^{K-1} m_i K(m_i, m_j) N_i N_j = \\frac{1}{2} \\sum_{i=0}^{K-1} \\sum_{j=0}^{K-1} (m_i + m_j) K(m_i, m_j) N_i N_j $$\n这两个表达式是等价的，从而证明了该方案在没有浮点误差的情况下是精确质量守恒的。\n\n### 5. 实现策略\n1.  计算初始总质量 $M_{\\text{initial}}$。\n2.  预计算对称的核矩阵 $K_{ij}$。\n3.  使用矩阵-向量乘法计算损失向量 $L_k = N_k \\sum_j K_{kj} N_j$。\n4.  初始化源向量 $S_k = 0$。\n5.  遍历所有唯一的粒子对 $(i,j)$，其中 $i \\le j$。\n6.  计算碰撞率 $\\hat{C}_{ij}$，注意 $i=j$ 时的 $1/2$ 因子。\n7.  计算产物质量 $m_p = m_i + m_j$。\n8.  找到框定 $m_p$ 的主元 $m_k$ 和 $m_{k+1}$。\n9.  计算再分配权重并更新源向量 $S_k$ 和 $S_{k+1}$。\n10. 使用向前欧拉法更新数浓度：$N_k^{\\text{new}} = N_k + \\Delta t (S_k - L_k)$。\n11. 计算最终总质量 $M_{\\text{final}}$ 并报告误差 $|M_{\\text{final}} - M_{\\text{initial}}|$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the final results.\n    \"\"\"\n\n    # Define the common mass grid for all test cases.\n    m_pivots = np.array([1e-12, 2e-12, 4e-12, 8e-12, 16e-12], dtype=np.float64)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Test 1 (happy path, constant kernel)\",\n            \"kernel_func\": lambda m_i, m_j: 1e-12,\n            \"N_initial\": np.array([1e5, 5e4, 2e4, 1e4, 0], dtype=np.float64),\n            \"dt\": 5.0\n        },\n        {\n            \"name\": \"Test 2 (mass-dependent additive kernel, moderate change)\",\n            \"kernel_func\": lambda m_i, m_j: 10.0 * (m_i + m_j),\n            \"N_initial\": np.array([5e4, 5e4, 0, 2e4, 0], dtype=np.float64),\n            \"dt\": 0.5\n        },\n        {\n            \"name\": \"Test 3 (boundary bracketing exactly at top pivot, constant kernel)\",\n            \"kernel_func\": lambda m_i, m_j: 5e-13,\n            \"N_initial\": np.array([0, 0, 3e4, 3e4, 0], dtype=np.float64),\n            \"dt\": 10.0\n        },\n        {\n            \"name\": \"Test 4 (tiny time step, constant kernel, stability check)\",\n            \"kernel_func\": lambda m_i, m_j: 1e-12,\n            \"N_initial\": np.array([1e5, 1e5, 1e5, 0, 0], dtype=np.float64),\n            \"dt\": 1e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_coagulation_step(m_pivots, case[\"N_initial\"], case[\"dt\"], case[\"kernel_func\"])\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_coagulation_step(m_grid, N_initial, dt, kernel_func):\n    \"\"\"\n    Performs one time step of coagulation using the derived conservative scheme.\n\n    Args:\n        m_grid (np.ndarray): Array of mass pivots (kg).\n        N_initial (np.ndarray): Array of initial number concentrations (m^-3).\n        dt (float): Time step (s).\n        kernel_func (callable): Function K(m_i, m_j) returning the kernel value (m^3 s^-1).\n\n    Returns:\n        float: Absolute mass conservation error (kg m^-3).\n    \"\"\"\n    K = len(m_grid)\n    N = np.copy(N_initial)\n\n    # 1. Calculate initial total mass\n    M_initial = np.sum(m_grid * N)\n\n    # 2. Pre-compute the symmetric kernel matrix\n    K_matrix = np.zeros((K, K), dtype=np.float64)\n    for i in range(K):\n        for j in range(i, K):\n            val = kernel_func(m_grid[i], m_grid[j])\n            K_matrix[i, j] = val\n            K_matrix[j, i] = val\n\n    # 3. Calculate the loss term vector L\n    L = N * (K_matrix @ N)\n\n    # 4. Calculate the source term vector S\n    S = np.zeros(K, dtype=np.float64)\n    for i in range(K):\n        for j in range(i, K):\n            if N[i] == 0.0 or N[j] == 0.0:\n                continue\n\n            # Calculate the number production rate for the pair (i, j)\n            if i == j:\n                C_ij = 0.5 * K_matrix[i, i] * N[i] * N[i]\n            else:  # i  j\n                C_ij = K_matrix[i, j] * N[i] * N[j]\n            \n            # Form aggregate particle and check if it's within the grid mass range\n            m_p = m_grid[i] + m_grid[j]\n            \n            if not (m_grid[0] = m_p = m_grid[-1]):\n                # Per problem, this condition is satisfied by the test suite.\n                # In a real model, this mass would need to be handled.\n                raise ValueError(f\"Product mass {m_p} is outside the grid range [{m_grid[0]}, {m_grid[-1]}]\")\n\n            # Find bracketing pivots and redistribute mass\n            # 'searchsorted' finds the insertion index to maintain order. 'left' side returns the first suitable index.\n            k_high_idx = np.searchsorted(m_grid, m_p, side='left')\n\n            # Case 1: Product mass falls exactly on a pivot\n            if k_high_idx  K and np.isclose(m_grid[k_high_idx], m_p):\n                S[k_high_idx] += C_ij\n            # Case 2: Product mass falls between two pivots\n            else:\n                k_low_idx = k_high_idx - 1\n                \n                m_low = m_grid[k_low_idx]\n                m_high = m_grid[k_high_idx]\n                \n                denominator = m_high - m_low\n                \n                # These are the derived mass-conserving redistribution weights\n                weight_low = (m_high - m_p) / denominator\n                weight_high = (m_p - m_low) / denominator\n                \n                S[k_low_idx] += C_ij * weight_low\n                S[k_high_idx] += C_ij * weight_high\n\n    # 5. Update number concentrations using forward Euler\n    N_new = N + dt * (S - L)\n    \n    # 6. Calculate final total mass\n    M_final = np.sum(m_grid * N_new)\n    \n    # 7. Calculate and return the absolute mass conservation error\n    error = np.abs(M_final - M_initial)\n    return error\n\nsolve()\n```"
        }
    ]
}