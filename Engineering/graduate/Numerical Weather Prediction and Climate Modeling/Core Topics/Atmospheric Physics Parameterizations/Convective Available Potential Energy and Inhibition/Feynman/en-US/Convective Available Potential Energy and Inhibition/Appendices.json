{
    "hands_on_practices": [
        {
            "introduction": "Before writing complex code, it is crucial to understand the physical components of buoyancy. This first exercise guides you through an analytical derivation to isolate and quantify the contribution of water vapor to a parcel's total buoyancy, a concept encapsulated by the virtual temperature $T_v$ . By working through a simplified, hypothetical scenario, you will gain a concrete appreciation for why neglecting moisture effects leads to a systematic underestimation of convective potential.",
            "id": "4026572",
            "problem": "A core diagnostic in numerical weather prediction and climate modeling is Convective Available Potential Energy (CAPE). Starting from the ideal gas law for a moist mixture with water vapor mass mixing ratio $q_v$ and neglecting condensate, the density of moist air may be expressed by introducing the virtual temperature $T_v$, defined by $p = \\rho R_d T_v$, where $p$ is pressure, $\\rho$ is density, and $R_d$ is the specific gas constant for dry air. The virtual temperature satisfies $T_v \\approx T \\left(1 + \\alpha q_v\\right)$, where $\\alpha \\equiv \\frac{1}{\\epsilon} - 1$ with $\\epsilon \\equiv R_d/R_v \\approx 0.622$ and $R_v$ the specific gas constant for water vapor. Assume unsaturated conditions with no condensate so that $q_l = q_i = 0$ everywhere. The buoyancy acceleration of a parcel is defined by $B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}$, with $g$ the gravitational acceleration.\n\nConsider an environment with temperature profile $T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$ for $z \\in [0,H]$, where $T_0 = 300\\,\\mathrm{K}$, $\\Gamma = 6.5\\,\\mathrm{K\\,km^{-1}}$, and $H = 3000\\,\\mathrm{m}$. A lifted parcel over the same layer has a constant temperature excess $\\Delta T \\equiv T_{\\mathrm{par}} - T_{\\mathrm{env}} = 2\\,\\mathrm{K}$ and a constant specific humidity excess $\\Delta q_v \\equiv q_{v,\\mathrm{par}} - q_{v,\\mathrm{env}} = 0.004$. Take $g = 9.81\\,\\mathrm{m\\,s^{-2}}$ and $\\alpha = 0.61$. Assume small departures so that linearization in $(\\Delta T, \\Delta q_v)$ about the environment is valid.\n\nTasks:\n1) Starting from the ideal gas law and the definition of buoyancy, derive an expression for $B(z)$ accurate to first order in $(\\Delta T, \\Delta q_v)$ that isolates the contribution from temperature and water vapor, and write it in terms of $T_{\\mathrm{env}}(z)$, $\\Delta T$, and $\\Delta q_v$.\n2) Using your result, compute two CAPE values over $[0,H]$:\n- $ \\mathrm{CAPE}[T] \\equiv \\int_{0}^{H} B_T(z)\\,dz$, where water vapor is neglected in the buoyancy (i.e., replace $T_v$ by $T$ everywhere).\n- $ \\mathrm{CAPE}[T_v] \\equiv \\int_{0}^{H} B_{T_v}(z)\\,dz$, including the first-order water vapor contribution.\n3) Define the bias introduced by neglecting water vapor as $ \\mathrm{bias} \\equiv \\mathrm{CAPE}[T] - \\mathrm{CAPE}[T_v]$. Compute this bias numerically for the specified profiles.\n\nExpress the final bias in $J\\,kg^{-1}$ and round your answer to four significant figures.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- Ideal gas law for moist air: $p = \\rho R_d T_v$\n- Virtual temperature approximation: $T_v \\approx T \\left(1 + \\alpha q_v\\right)$\n- Parameter definition: $\\alpha \\equiv \\frac{1}{\\epsilon} - 1$ where $\\epsilon \\equiv R_d/R_v \\approx 0.622$\n- Condensate assumption: $q_l = q_i = 0$\n- Buoyancy acceleration definition: $B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}$\n- Environmental temperature profile: $T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$ for $z \\in [0,H]$\n- Constants and parameters:\n  - $T_0 = 300\\,\\mathrm{K}$\n  - $\\Gamma = 6.5\\,\\mathrm{K\\,km^{-1}}$\n  - $H = 3000\\,\\mathrm{m}$\n  - $\\Delta T \\equiv T_{\\mathrm{par}} - T_{\\mathrm{env}} = 2\\,\\mathrm{K}$ (constant)\n  - $\\Delta q_v \\equiv q_{v,\\mathrm{par}} - q_{v,\\mathrm{env}} = 0.004$ (constant)\n  - $g = 9.81\\,\\mathrm{m\\,s^{-2}}$\n  - $\\alpha = 0.61$\n- Assumption: Small departures, linearization in $(\\Delta T, \\Delta q_v)$ is valid.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on fundamental principles of atmospheric thermodynamics, including the ideal gas law, the concept of virtual temperature, and buoyancy. The equations and parameter values are standard in the field.\n- **Well-Posed**: The problem is clearly stated with three distinct tasks leading to a single numerical answer. The assumptions, such as constant temperature and moisture excesses, create a simplified but tractable problem.\n- **Objective**: The problem is expressed in precise, quantitative language, free of subjectivity.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid as it is consistent, scientifically sound, and well-posed. A solution will be developed.\n\n### Task 1: Derivation of the First-Order Buoyancy Expression\n\nThe buoyancy acceleration $B$ is defined as:\n$$B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}} = g \\left(1 - \\frac{\\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}\\right)$$\nUsing the ideal gas law for moist air, $p = \\rho R_d T_v$, we can express density as $\\rho = \\frac{p}{R_d T_v}$. A fundamental assumption in parcel theory is that the parcel is at the same pressure as its environment at any given height $z$, i.e., $p_{\\mathrm{par}}(z) = p_{\\mathrm{env}}(z) = p(z)$. Substituting the density expression into the buoyancy equation gives:\n$$B = g \\left(1 - \\frac{p / (R_d T_{v,\\mathrm{par}})}{p / (R_d T_{v,\\mathrm{env}})}\\right) = g \\left(1 - \\frac{T_{v,\\mathrm{env}}}{T_{v,\\mathrm{par}}}\\right) = g \\frac{T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}}}{T_{v,\\mathrm{par}}}$$\nLet the virtual temperature difference be $\\Delta T_v = T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}}$. Since the problem states that departures are small, we can linearize this expression by approximating the denominator $T_{v,\\mathrm{par}} \\approx T_{v,\\mathrm{env}}$, which yields:\n$$B \\approx g \\frac{\\Delta T_v}{T_{v,\\mathrm{env}}}$$\nNext, we express $\\Delta T_v$ in terms of the given temperature excess $\\Delta T$ and specific humidity excess $\\Delta q_v$. Using the definition $T_v \\approx T(1 + \\alpha q_v)$:\n$$T_{v,\\mathrm{par}} \\approx T_{\\mathrm{par}}(1 + \\alpha q_{v,\\mathrm{par}})$$\n$$T_{v,\\mathrm{env}} \\approx T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}})$$\nSubstituting $T_{\\mathrm{par}} = T_{\\mathrm{env}} + \\Delta T$ and $q_{v,\\mathrm{par}} = q_{v,\\mathrm{env}} + \\Delta q_v$:\n$$\\Delta T_v = T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}} \\approx (T_{\\mathrm{env}} + \\Delta T)(1 + \\alpha (q_{v,\\mathrm{env}} + \\Delta q_v)) - T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}})$$\nExpanding the product:\n$$\\Delta T_v \\approx (T_{\\mathrm{env}} + \\alpha T_{\\mathrm{env}}q_{v,\\mathrm{env}} + \\alpha T_{\\mathrm{env}}\\Delta q_v + \\Delta T + \\alpha \\Delta T q_{v,\\mathrm{env}} + \\alpha \\Delta T \\Delta q_v) - (T_{\\mathrm{env}} + \\alpha T_{\\mathrm{env}}q_{v,\\mathrm{env}})$$\nFor a first-order approximation in $(\\Delta T, \\Delta q_v)$, we neglect second-order terms like $\\alpha \\Delta T q_{v,\\mathrm{env}}$ and $\\alpha \\Delta T \\Delta q_v$. This simplifies to:\n$$\\Delta T_v \\approx \\Delta T + \\alpha T_{\\mathrm{env}} \\Delta q_v$$\nSubstituting this into the linearized buoyancy equation and also approximating $T_{v,\\mathrm{env}} = T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}}) \\approx T_{\\mathrm{env}}$ in the denominator (since $q_{v,\\mathrm{env}}$ is small), we obtain the desired expression for buoyancy, which we denote $B_{T_v}(z)$:\n$$B_{T_v}(z) \\approx g \\frac{\\Delta T + \\alpha T_{\\mathrm{env}}(z) \\Delta q_v}{T_{\\mathrm{env}}(z)} = g \\left(\\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + \\alpha \\Delta q_v\\right)$$\nThis expression isolates the contributions from temperature excess $(\\Delta T)$ and water vapor excess $(\\Delta q_v)$.\n\n### Task 2: Computation of CAPE Values\n\nFirst, we define the two buoyancy terms. The full buoyancy including water vapor, $B_{T_v}$, is the expression derived above. The buoyancy neglecting water vapor, $B_T$, is obtained by setting the virtual temperature $T_v$ to the actual temperature $T$, which is equivalent to setting $\\alpha=0$ in the virtual temperature definition. This results in:\n$$B_T(z) = g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}$$\n$$B_{T_v}(z) = g \\left(\\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + \\alpha \\Delta q_v\\right)$$\nNow we compute the corresponding CAPE values by integrating over the vertical domain $z \\in [0, H]$.\n\nThe CAPE due to temperature only is:\n$$\\mathrm{CAPE}[T] = \\int_{0}^{H} B_T(z)\\,dz = \\int_{0}^{H} g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}\\,dz$$\nSubstituting $T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$:\n$$\\mathrm{CAPE}[T] = g \\Delta T \\int_{0}^{H} \\frac{1}{T_0 - \\Gamma z}\\,dz$$\nThe integral is evaluated as:\n$$\\int_{0}^{H} \\frac{1}{T_0 - \\Gamma z}\\,dz = \\left[-\\frac{1}{\\Gamma} \\ln(T_0 - \\Gamma z)\\right]_{0}^{H} = -\\frac{1}{\\Gamma} \\left( \\ln(T_0 - \\Gamma H) - \\ln(T_0) \\right) = \\frac{1}{\\Gamma} \\ln\\left(\\frac{T_0}{T_0 - \\Gamma H}\\right)$$\nSo, the analytical expression for $\\mathrm{CAPE}[T]$ is:\n$$\\mathrm{CAPE}[T] = \\frac{g \\Delta T}{\\Gamma} \\ln\\left(\\frac{T_0}{T_0 - \\Gamma H}\\right)$$\nThe CAPE including the virtual temperature effect is:\n$$\\mathrm{CAPE}[T_v] = \\int_{0}^{H} B_{T_v}(z)\\,dz = \\int_{0}^{H} \\left( g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + g \\alpha \\Delta q_v \\right)\\,dz$$\nUsing the linearity of the integral:\n$$\\mathrm{CAPE}[T_v] = \\int_{0}^{H} g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}\\,dz + \\int_{0}^{H} g \\alpha \\Delta q_v\\,dz$$\nThe first term is $\\mathrm{CAPE}[T]$. The second term is the integral of a constant:\n$$\\int_{0}^{H} g \\alpha \\Delta q_v\\,dz = g \\alpha \\Delta q_v [z]_{0}^{H} = g \\alpha \\Delta q_v H$$\nThus, the expression for $\\mathrm{CAPE}[T_v]$ is:\n$$\\mathrm{CAPE}[T_v] = \\mathrm{CAPE}[T] + g \\alpha \\Delta q_v H$$\n\n### Task 3: Computation of the Bias\n\nThe bias is defined as $\\mathrm{bias} \\equiv \\mathrm{CAPE}[T] - \\mathrm{CAPE}[T_v]$. Using the expressions derived in Task 2:\n$$\\mathrm{bias} = \\mathrm{CAPE}[T] - (\\mathrm{CAPE}[T] + g \\alpha \\Delta q_v H) = -g \\alpha \\Delta q_v H$$\nThis remarkably simple result shows that, under the given assumptions, the bias introduced by neglecting the moisture effect on buoyancy is independent of the temperature profile. We can now compute its numerical value using the provided constants. It is important to ensure all units are in the SI system. The given values are:\n$g = 9.81\\,\\mathrm{m\\,s^{-2}}$\n$\\alpha = 0.61$ (dimensionless)\n$\\Delta q_v = 0.004$ (dimensionless, kg/kg)\n$H = 3000\\,\\mathrm{m}$\n\nSubstituting these values into the expression for the bias:\n$$\\mathrm{bias} = -(9.81\\,\\mathrm{m\\,s^{-2}}) \\times (0.61) \\times (0.004) \\times (3000\\,\\mathrm{m})$$\n$$\\mathrm{bias} = -71.8092\\,\\mathrm{m^2\\,s^{-2}}$$\nThe unit $\\mathrm{m^2\\,s^{-2}}$ is equivalent to Joules per kilogram ($\\mathrm{J\\,kg^{-1}}$).\nThe problem requires the answer to be rounded to four significant figures.\n$$\\mathrm{bias} \\approx -71.81\\,\\mathrm{J\\,kg^{-1}}$$\nThe negative sign indicates that neglecting water vapor leads to an underestimation of CAPE, as moist parcels are more buoyant than dry parcels at the same temperature.",
            "answer": "$$\\boxed{-71.81}$$"
        },
        {
            "introduction": "Moving from the continuous integrals of theory to the discrete vertical levels of a numerical model requires a robust algorithm. This practice challenges you to implement a complete calculator for Convective Available Potential Energy (CAPE) and Convective Inhibition (CIN) from discrete profile data . You will learn to handle the practical complexities of real-world soundings, such as locating the Level of Free Convection ($z_{\\mathrm{LFC}}$) and Equilibrium Level ($z_{\\mathrm{EL}}$), and address the common edge case where a parcel remains buoyant to the model top.",
            "id": "4026532",
            "problem": "Consider a vertical atmospheric column represented by discrete levels of geometric height $z$ in meters and corresponding environmental and parcel virtual temperatures $T_{ve}(z)$ and $T_{vp}(z)$ in kelvins. In numerical weather prediction (NWP), Convective Available Potential Energy (CAPE) and Convective Inhibition (CIN) quantify the integral effect of buoyancy. The parcel buoyancy acceleration $b(z)$ is defined using the virtual temperature approximation as $b(z) = g \\, \\frac{T_{vp}(z) - T_{ve}(z)}{T_{ve}(z)}$, where $g$ is the gravitational acceleration. The Level of Free Convection (LFC) is the lowest altitude where the parcel transitions from negatively buoyant to positively buoyant, and the Equilibrium Level (EL) is the altitude where a positively buoyant parcel returns to neutral buoyancy. CAPE is the vertical integral of $b(z)$ over the interval where the parcel is positively buoyant, and CIN is the magnitude of the negative integral of $b(z)$ from the surface up to the LFC. Both CAPE and CIN have units of joules per kilogram. In profiles where no $z_{EL}$ exists within the model top, the treatment requires defining a cutoff rule and assessing sensitivity to the chosen top boundary.\n\nStarting from the ideal gas law and the virtual temperature concept for moist air, and treating $b(z)$ as a continuous function interpolated linearly between discrete levels, the task is to implement an algorithm that:\n1. Identifies $z_{LFC}$ by locating the first zero crossing of $b(z)$ from negative to positive and interpolating linearly to the exact $z$ where $b(z)=0$.\n2. Identifies $z_{EL}$ by locating the first zero crossing of $b(z)$ from positive to non-positive above $z_{LFC}$; if no such crossing exists below a prescribed model top $z_{top}$, then apply an $\\epsilon$-neutral threshold: declare $z_{EL}$ at the first altitude where $b(z) \\le \\epsilon$ using linear interpolation. If neither a zero crossing nor the $\\epsilon$ threshold occurs below $z_{top}$, truncate the CAPE integration at $z_{top}$, thereby defining a cutoff $z_{cut} = z_{top}$.\n3. Computes CAPE as the integral of $b(z)$ from $z_{LFC}$ to $\\min(z_{EL}, z_{top})$, using trapezoidal integration with linear interpolation at the boundaries. Computes CIN as the magnitude of the integral of negative $b(z)$ from the surface ($z=0$) to $z_{LFC}$, also using trapezoidal integration and linear interpolation at the boundary.\n4. Assesses sensitivity to $z_{top}$ by computing CAPE at two different $z_{top}$ values for the same profile and reporting both the difference and the ratio.\n\nExpress all CAPE and CIN values in joules per kilogram ($J\\,kg^{-1}$). Use $g = 9.81 \\ \\mathrm{m\\,s^{-2}}$. Angles are not involved. The $\\epsilon$ threshold must be supplied in units of $\\mathrm{m\\,s^{-2}}$.\n\nYour program must implement this algorithm and apply it to the following test suite. For each test case, the input is a discrete profile defined by arrays of $z$ (meters), $T_{ve}$ (kelvins), and the parcel-environment virtual temperature difference $\\Delta T_v(z) = T_{vp}(z) - T_{ve}(z)$ (kelvins). The parcel virtual temperature is $T_{vp}(z) = T_{ve}(z) + \\Delta T_v(z)$. The program must calculate CAPE and CIN using $b(z)$ defined above. For each test case, compute:\n- CAPE for the first $z_{top}$,\n- CAPE for the second $z_{top}$,\n- the difference (second minus first) in $J\\,kg^{-1}$,\n- the ratio (second divided by first) as a decimal (dimensionless),\n- and include CIN as the first element of the output list for that test case.\n\nTest suite:\n- Test case $1$ (happy path with a well-defined $z_{EL}$):\n  - $z$ in meters: $[0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000]$.\n  - $T_{ve}$ in kelvins: $[300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0]$.\n  - $\\Delta T_v$ in kelvins: $[-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 8.0, 7.0, 5.0, 3.0, 1.0, 0.0, -1.0, -2.0, -3.0]$.\n  - $z_{top}$ values in meters: $[12000, 14000]$.\n  - $\\epsilon$ in $\\mathrm{m\\,s^{-2}}$: $0.02$.\n- Test case $2$ (no $z_{EL}$ below model top, parcel stays positively buoyant to the top):\n  - $z$ in meters: $[0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]$.\n  - $T_{ve}$ in kelvins: $[300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0, 202.5, 196.0]$.\n  - $\\Delta T_v$ in kelvins: $[-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]$.\n  - $z_{top}$ values in meters: $[12000, 16000]$.\n  - $\\epsilon$ in $\\mathrm{m\\,s^{-2}}$: $0.02$.\n- Test case $3$ (near-neutral plateau; use $\\epsilon$ cutoff if no zero crossing occurs):\n  - $z$ in meters: $[0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000]$.\n  - $T_{ve}$ in kelvins: $[300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0]$.\n  - $\\Delta T_v$ in kelvins: $[-1.0, 0.0, 2.0, 5.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.5, 0.2, 0.05, 0.02]$.\n  - $z_{top}$ values in meters: $[12000, 14000]$.\n  - $\\epsilon$ in $\\mathrm{m\\,s^{-2}}$: $0.02$.\n\nFor each test case, your program must produce a list of five floats $[\\mathrm{CIN}, \\mathrm{CAPE}(z_{top,1}), \\mathrm{CAPE}(z_{top,2}), \\mathrm{CAPE}(z_{top,2}) - \\mathrm{CAPE}(z_{top,1}), \\mathrm{CAPE}(z_{top,2}) / \\mathrm{CAPE}(z_{top,1})]$ in the specified units and order. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[x_1,x_2,x_3,x_4,x_5],[y_1,y_2,y_3,y_4,y_5],[z_1,z_2,z_3,z_4,z_5]]$), where each inner list corresponds to one test case in the same order as above.",
            "solution": "The problem requires the implementation of an algorithm to compute Convective Available Potential Energy (CAPE) and Convective Inhibition (CIN) from discrete atmospheric profile data, and to assess the sensitivity of CAPE to the model top height, $z_{top}$. The solution is grounded in the principles of atmospheric thermodynamics, specifically the concept of parcel buoyancy.\n\nFirst, we define the parcel buoyancy acceleration, $b(z)$, which is the fundamental quantity for both CAPE and CIN. Based on the virtual temperature approximation for moist air, buoyancy is given by:\n$$\nb(z) = g \\, \\frac{T_{vp}(z) - T_{ve}(z)}{T_{ve}(z)} = g \\, \\frac{\\Delta T_v(z)}{T_{ve}(z)}\n$$\nwhere $g$ is the gravitational acceleration ($9.81 \\, \\mathrm{m\\,s^{-2}}$), $T_{ve}(z)$ is the environmental virtual temperature, $T_{vp}(z)$ is the parcel virtual temperature, and $\\Delta T_v(z)$ is their difference at a geometric height $z$. We treat $b(z)$ as a continuous function by assuming linear interpolation between the given discrete data points.\n\nThe algorithm proceeds in three main stages: identifying critical atmospheric levels, performing numerical integration, and conducting a sensitivity analysis.\n\n**1. Identification of Critical Levels**\n\nThe two critical levels are the Level of Free Convection ($z_{LFC}$) and the Equilibrium Level ($z_{EL}$).\n\n*   **Level of Free Convection ($z_{LFC}$):** This is the lowest altitude at which a negatively buoyant parcel becomes positively buoyant. We must find the first height $z$ where $b(z)$ crosses from a non-positive to a positive value. To do this, we iterate through the discrete atmospheric layers defined by heights $[z_i, z_{i+1}]$ and find the first instance where $b(z_i) \\le 0$ and $b(z_{i+1}) > 0$. The exact altitude $z_{LFC}$ is then found by linear interpolation to locate the root where $b(z_{LFC}) = 0$. The interpolation formula is:\n    $$\n    z_{LFC} = z_i + (0 - b(z_i)) \\frac{z_{i+1} - z_i}{b(z_{i+1}) - b(z_i)}\n    $$\n\n*   **Equilibrium Level ($z_{EL}$):** This is the altitude above $z_{LFC}$ where the parcel's buoyancy returns to neutral or negative. The search for $z_{EL}$ follows a multi-step rule:\n    a. First, we search for the lowest altitude above $z_{LFC}$ where $b(z)$ crosses from positive to non-positive. If an interval $[z_j, z_{j+1}]$ with $b(z_j) > 0$ and $b(z_{j+1}) \\le 0$ is found, $z_{EL}$ is calculated by linear interpolation to find the root $b(z_{EL})=0$.\n    b. If no such zero-crossing occurs within the profile data, we then search for the lowest altitude where the buoyancy drops below a small positive threshold, $\\epsilon$. If an interval $[z_k, z_{k+1}]$ is found above $z_{LFC}$ such that $b(z_k) > \\epsilon$ and $b(z_{k+1}) \\le \\epsilon$, then $z_{EL}$ is determined by interpolating to find the height where $b(z_{EL}) = \\epsilon$.\n    c. If neither a zero-crossing nor an $\\epsilon$-crossing is found within the vertical extent of the data, it implies the parcel remains strongly buoyant up to the highest data level. In this situation, $z_{EL}$ is conceptually at or above the model top.\n\n**2. Numerical Integration for CIN and CAPE**\n\nBoth CIN and CAPE are defined as vertical integrals of buoyancy $b(z)$. The units are energy per unit mass, $\\mathrm{J\\,kg^{-1}}$. The integration is performed using the trapezoidal rule, generalized to handle integration limits that may not align with the discrete height levels.\n\nFor an arbitrary integration interval $[z_a, z_b]$, we construct a new set of points for integration consisting of the start point $z_a$, all original grid points between $z_a$ and $z_b$, and the end point $z_b$. The buoyancy values at $z_a$ and $z_b$ are found by linear interpolation. The standard trapezoidal rule is then applied to this new set of points.\n\n*   **Convective Inhibition (CIN):** CIN quantifies the energy barrier that must be overcome for convection to initiate. It is calculated as the magnitude of the integral of buoyancy from the surface ($z=0$) to $z_{LFC}$, where the buoyancy is negative.\n    $$\n    \\mathrm{CIN} = \\left| \\int_{0}^{z_{LFC}} b(z) \\, dz \\right| = - \\int_{0}^{z_{LFC}} b(z) \\, dz\n    $$\n\n*   **Convective Available Potential Energy (CAPE):** CAPE represents the total work a positively buoyant parcel can do on the environment. It is the integral of buoyancy over the region of positive buoyancy, starting from $z_{LFC}$. The upper integration limit, which we can call $z_{cut}$, is defined by the minimum of the determined Equilibrium Level $z_{EL}$ and the specified model top $z_{top}$.\n    $$\n    \\mathrm{CAPE} = \\int_{z_{LFC}}^{z_{cut}} b(z) \\, dz, \\quad \\text{where} \\quad z_{cut} = \\min(z_{EL}, z_{top})\n    $$\n    If no $z_{EL}$ is found below $z_{top}$, the integration is truncated at $z_{top}$, meaning $z_{cut} = z_{top}$.\n\n**3. Sensitivity Analysis**\n\nThe final step is to assess the sensitivity of the calculated CAPE value to the choice of the model top, $z_{top}$. This is particularly relevant in cases where $z_{EL}$ is near or above $z_{top}$. The algorithm computes CAPE for two different values, $z_{top,1}$ and $z_{top,2}$. The sensitivity is then quantified by calculating both the absolute difference, $\\mathrm{CAPE}(z_{top,2}) - \\mathrm{CAPE}(z_{top,1})$, and the relative ratio, $\\mathrm{CAPE}(z_{top,2}) / \\mathrm{CAPE}(z_{top,1})$.\n\nThis complete procedure is applied to each test case, yielding a five-element list containing $[\\mathrm{CIN}, \\mathrm{CAPE}(z_{top,1}), \\mathrm{CAPE}(z_{top,2}), \\text{Difference}, \\text{Ratio}]$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    # Gravitational acceleration in m/s^2\n    G = 9.81\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"z\": np.array([0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000], dtype=float),\n            \"T_ve\": np.array([300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0], dtype=float),\n            \"delta_Tv\": np.array([-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 8.0, 7.0, 5.0, 3.0, 1.0, 0.0, -1.0, -2.0, -3.0], dtype=float),\n            \"z_tops\": [12000.0, 14000.0],\n            \"epsilon\": 0.02\n        },\n        {\n            \"z\": np.array([0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000], dtype=float),\n            \"T_ve\": np.array([300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0, 202.5, 196.0], dtype=float),\n            \"delta_Tv\": np.array([-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0], dtype=float),\n            \"z_tops\": [12000.0, 16000.0],\n            \"epsilon\": 0.02\n        },\n        {\n            \"z\": np.array([0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000], dtype=float),\n            \"T_ve\": np.array([300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0], dtype=float),\n            \"delta_Tv\": np.array([-1.0, 0.0, 2.0, 5.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.5, 0.2, 0.05, 0.02], dtype=float),\n            \"z_tops\": [12000.0, 14000.0],\n            \"epsilon\": 0.02\n        }\n    ]\n\n    def find_crossing(z, y, target_y, start_idx, condition):\n        \"\"\"\n        Finds the first height z where y(z) crosses a target value, based on a condition.\n        condition is a lambda function: e.g., lambda y1, y2: y1 <= 0 and y2 > 0.\n        \"\"\"\n        for i in range(start_idx, len(z) - 1):\n            if condition(y[i], y[i+1]):\n                # Linear interpolation to find the exact crossing point.\n                if np.isclose(y[i+1], y[i]):\n                    return z[i] if np.isclose(y[i], target_y) else None\n                z_cross = z[i] + (target_y - y[i]) * (z[i+1] - z[i]) / (y[i+1] - y[i])\n                return z_cross\n        return None\n\n    def integrate_buoyancy(z, b, z_start, z_end):\n        \"\"\"\n        Integrates buoyancy 'b' from z_start to z_end using the trapezoidal rule.\n        Handles integration limits that are not on the grid points.\n        \"\"\"\n        if z_start >= z_end:\n            return 0.0\n\n        # Find indices of the grid points that bracket the integration interval\n        start_idx = np.searchsorted(z, z_start, side='right')\n        end_idx = np.searchsorted(z, z_end, side='left')\n        \n        # Create a combined array of z-points for integration\n        z_integration_points = np.concatenate(([z_start], z[start_idx:end_idx], [z_end]))\n        z_integration_points = np.unique(z_integration_points) # Ensure no duplicate points\n\n        # Interpolate buoyancy values at these points\n        b_integration_points = np.interp(z_integration_points, z, b)\n        \n        # Perform trapezoidal integration\n        return np.trapz(b_integration_points, z_integration_points)\n\n    def calculate_cape_cin(case_data):\n        \"\"\"\n        Calculates CIN, CAPE, and sensitivity for a single test case.\n        \"\"\"\n        z, T_ve, delta_Tv = case_data[\"z\"], case_data[\"T_ve\"], case_data[\"delta_Tv\"]\n        z_top1, z_top2 = case_data[\"z_tops\"]\n        epsilon = case_data[\"epsilon\"]\n\n        # 1. Calculate buoyancy profile\n        buoyancy = G * delta_Tv / T_ve\n\n        # 2. Find LFC (Level of Free Convection)\n        z_lfc = find_crossing(z, buoyancy, 0.0, 0, lambda b1, b2: b1 <= 0 and b2 > 0)\n        if z_lfc is None: # No positive buoyancy region\n            return [0.0, 0.0, 0.0, 0.0, np.nan]\n\n        # 3. Calculate CIN (Convective Inhibition)\n        cin = -integrate_buoyancy(z, buoyancy, z[0], z_lfc)\n\n        # 4. Find EL (Equilibrium Level)\n        lfc_idx = np.searchsorted(z, z_lfc, side='left')\n        \n        # Search for zero crossing\n        z_el = find_crossing(z, buoyancy, 0.0, lfc_idx, lambda b1, b2: b1 > 0 and b2 <= 0)\n        \n        # If no zero crossing, search for epsilon crossing\n        if z_el is None:\n            z_el = find_crossing(z, buoyancy, epsilon, lfc_idx, lambda b1, b2: b1 > epsilon and b2 <= epsilon)\n\n        # 5. Calculate CAPE for both z_top values\n        cape_values = []\n        for z_top in [z_top1, z_top2]:\n            z_cut = z_top\n            if z_el is not None:\n                z_cut = min(z_el, z_top)\n            \n            cape = integrate_buoyancy(z, buoyancy, z_lfc, z_cut)\n            cape_values.append(cape)\n        \n        cape1, cape2 = cape_values[0], cape_values[1]\n        \n        diff = cape2 - cape1\n        ratio = cape2 / cape1 if cape1 != 0 else np.nan\n        \n        return [cin, cape1, cape2, diff, ratio]\n\n    results = []\n    for case in test_cases:\n        result = calculate_cape_cin(case)\n        results.append(result)\n\n    # Format output string exactly as specified\n    output_str = '[' + ','.join([str(r).replace(' ', '') for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of CAPE and CIN calculations can be surprisingly sensitive to the choice of interpolation method between discrete data points. While simple linear interpolation is straightforward, it can introduce non-physical oscillations and create spurious regions of positive buoyancy, corrupting the final energy estimate. This final exercise introduces a professional-grade solution using shape-preserving interpolation, a technique that ensures the sign structure of buoyancy is maintained and that computed values accurately reflect the underlying physical profile .",
            "id": "4026587",
            "problem": "You are given discrete vertical profiles of environmental virtual temperature and a lifted parcel’s virtual temperature as functions of geometric height. From fundamental principles, the specific buoyant force per unit mass of an air parcel at height $z$ is defined by\n$$\nB(z) \\equiv g \\,\\frac{T_{v,p}(z) - T_{v,e}(z)}{T_{v,e}(z)},\n$$\nwhere $g$ is gravitational acceleration, $T_{v,e}(z)$ is the environmental virtual temperature, and $T_{v,p}(z)$ is the parcel virtual temperature. Convective Available Potential Energy (CAPE) and Convective Inhibition (CIN) are the path integrals of buoyant acceleration over the vertical, defined by\n$$ \\text{CAPE} \\equiv \\int_{z_{\\text{min}}}^{z_{\\text{max}}} \\max\\{B(z), 0\\} \\, dz, \\qquad \\text{CIN} \\equiv -\\int_{z_{\\text{min}}}^{z_{\\text{max}}} \\min\\{B(z), 0\\} \\, dz. $$\nIn numerical weather prediction and climate modeling, spurious creation of positive area in $B(z)$ due to oscillatory interpolation can corrupt $\\text{CAPE}$ estimates. You must design and implement a robust interpolation scheme for $T_{v,e}(z)$ and parcel $T_{v,p}(z)$ that preserves the sign structure of $B(z)$ and avoids spurious $\\text{CAPE}$ creation, starting from the following scientifically grounded base:\n- The Ideal Gas Law and the definition of virtual temperature imply that at a given pressure level the sign of buoyancy is determined by the sign of $T_{v,p}(z) - T_{v,e}(z)$.\n- Archimedes’ principle for a stratified fluid and hydrostatic balance motivate $B(z)$ as the vertical acceleration due to density (or virtual temperature) contrast.\n\nYour task is to compute $\\text{CAPE}$ and $\\text{CIN}$ from discrete data using an interpolation and integration method that:\n- Represents $T_{v,e}(z)$ with a shape-preserving piecewise cubic Hermite interpolant that avoids overshoot across grid intervals.\n- Represents the difference $D(z) \\equiv T_{v,p}(z) - T_{v,e}(z)$ with a shape-preserving piecewise cubic Hermite interpolant constructed directly from nodal differences, so that any nodal zeros in $D$ are exactly preserved and no oscillatory sign changes are introduced between nodes.\n- Defines $B(z)$ by $B(z) = g \\, D(z) / T_{v,e}(z)$ evaluated using the above interpolants.\n- Detects all sign changes of $B(z)$ by locating the zeros of $D(z)$ between nodes using robust bracketing and root finding. Include nodal zeros explicitly as breakpoints. Do not assume uniform spacing.\n- Partitions the vertical domain $[z_{\\text{min}}, z_{\\text{max}}]$ into subintervals bounded by consecutive zeros and nodes so that the sign of $B(z)$ is constant on each subinterval, and then integrates $B(z)$ over each subinterval using a numerically accurate quadrature rule. Accumulate positive contributions into $\\text{CAPE}$ and negative contributions into $\\text{CIN}$ as defined above.\n\nScientific and numerical requirements:\n- Use gravitational acceleration $g = 9.80665$ in $\\mathrm{m}/\\mathrm{s}^2$.\n- Heights $z$ are in meters and virtual temperatures are in Kelvin.\n- Express $\\text{CAPE}$ and $\\text{CIN}$ in $J\\,kg^{-1}$ (equivalently $m^2\\,s^{-2}$), rounded to one decimal place.\n\nTest suite:\nFor each case below, $z$ is strictly increasing and shared by both profiles. All temperatures are virtual temperatures.\n\n- Case A (happy path: negative near surface, then positive, then negative):\n  - $z = [\\,0,\\,500,\\,1000,\\,1500,\\,2000,\\,3000\\,]$ in meters.\n  - $T_{v,e}(z) = [\\,300.0,\\,296.0,\\,292.0,\\,288.5,\\,285.0,\\,281.0\\,]$ in Kelvin.\n  - $T_{v,p}(z) = [\\,300.0,\\,295.5,\\,292.5,\\,290.5,\\,289.0,\\,280.0\\,]$ in Kelvin.\n\n- Case B (plateau of zero buoyancy preserved exactly, then positive, then negative):\n  - $z = [\\,0,\\,200,\\,800,\\,1500,\\,2200\\,]$ in meters.\n  - $T_{v,e}(z) = [\\,302.0,\\,300.5,\\,296.0,\\,292.0,\\,288.0\\,]$ in Kelvin.\n  - $T_{v,p}(z) = [\\,302.0,\\,300.5,\\,296.5,\\,294.0,\\,287.0\\,]$ in Kelvin.\n\n- Case C (sharp curvature near a near-neutral layer; avoid spurious oscillatory positive area):\n  - $z = [\\,0,\\,1000,\\,1200,\\,2000,\\,4000\\,]$ in meters.\n  - $T_{v,e}(z) = [\\,305.0,\\,297.0,\\,296.8,\\,294.0,\\,289.0\\,]$ in Kelvin.\n  - $T_{v,p}(z) = [\\,305.0,\\,296.0,\\,296.7,\\,295.0,\\,292.0\\,]$ in Kelvin.\n\nYour program must:\n- Implement the interpolation and zero-preserving strategy described above.\n- Detect all zero-crossings robustly and integrate subintervals with constant sign.\n- Produce two real numbers for each case: $\\text{CAPE}$ and $\\text{CIN}$ in $\\text{J}/\\text{kg}$, rounded to one decimal place.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\,\\text{CAPE}_A,\\,\\text{CIN}_A,\\,\\text{CAPE}_B,\\,\\text{CIN}_B,\\,\\text{CAPE}_C,\\,\\text{CIN}_C\\,]$. For example, a syntactically valid output would look like \"[12.3,4.5,67.8,9.0,1.2,3.4]\" but with the correct computed values for the given inputs.",
            "solution": "The problem is valid. It presents a clear, self-contained, and scientifically grounded task in the field of numerical atmospheric modeling. The provided definitions for buoyant force, Convective Available Potential Energy (CAPE), and Convective Inhibition (CIN) are standard in meteorology. The problem addresses a genuine numerical challenge: the potential for standard interpolation methods to introduce spurious oscillations, leading to incorrect estimates of atmospheric stability parameters. The proposed solution, using shape-preserving piecewise cubic Hermite interpolation, is a well-established and appropriate technique to mitigate this issue. The data provided in the test cases are physically plausible, and the instructions for the numerical procedure are specific and internally consistent.\n\nThe method for calculating CAPE and CIN for each given atmospheric profile proceeds as follows:\n\nFirst, we establish the necessary physical constants and input data. The acceleration due to gravity is given as $g = 9.80665 \\, \\text{m}/\\text{s}^2$. For each test case, we are provided with discrete vertical profiles of height $z$ in meters, environmental virtual temperature $T_{v,e}(z)$ in Kelvin, and lifted parcel virtual temperature $T_{v,p}(z)$ in Kelvin.\n\nThe core of the methodology is the accurate representation of the continuous functions from the discrete data points. The problem mandates a shape-preserving approach to avoid numerical artifacts.\n1.  The environmental virtual temperature profile, $T_{v,e}(z)$, is represented by a shape-preserving piecewise cubic Hermite interpolating polynomial. This type of interpolant is monotonic, meaning it will not create new local extrema between the given data points. This is crucial for maintaining the physical character of the temperature profile. We construct this interpolant from the given $(z_i, T_{v,e,i})$ pairs.\n\n2.  The vertical profile of the virtual temperature difference, $D(z) \\equiv T_{v,p}(z) - T_{v,e}(z)$, is the direct determinant of the sign of the buoyancy. To ensure that the sign structure of the buoyancy is perfectly preserved between nodes, we first compute the nodal differences $D_i = T_{v,p,i} - T_{v,e,i}$ for each height $z_i$. Then, we construct a shape-preserving piecewise cubic Hermite interpolating polynomial for $D(z)$ directly from the $(z_i, D_i)$ pairs. This guarantees that if $D_i = 0$ at a node, the interpolant will also be zero at that node. Furthermore, if $D_i$ and $D_{i+1}$ have the same sign (or one is zero), the interpolant $D(z)$ will not change sign in the interval $(z_i, z_{i+1})$.\n\nWith these continuous representations, the specific buoyant force $B(z)$ is defined for any height $z$ within the profile's domain as:\n$$\nB(z) = g \\frac{D(z)}{T_{v,e}(z)}\n$$\nwhere $D(z)$ and $T_{v,e}(z)$ are the values obtained from their respective interpolating functions. Since $T_{v,e}(z)$ is always a positive quantity (in Kelvin), the sign of $B(z)$ is identical to the sign of $D(z)$.\n\nTo compute the CAPE and CIN integrals, the vertical domain $[z_{\\text{min}}, z_{\\text{max}}]$ must be partitioned into subintervals where $B(z)$ has a constant sign. The boundaries of these subintervals, or breakpoints, are the points where $B(z) = 0$. These occur where $D(z) = 0$. The set of breakpoints therefore consists of all the original nodes $z_i$ plus any additional roots of $D(z)=0$ that lie strictly between nodes.\nTo find these roots, we examine each interval $[z_i, z_{i+1}]$. If the nodal values $D_i$ and $D_{i+1}$ have opposite signs (i.e., $D_i \\cdot D_{i+1} < 0$), a root must exist within $(z_i, z_{i+1})$. A robust numerical root-finding algorithm, such as Brent's method, is employed on the interpolating function $D(z)$ within this bracketed interval to find the precise height of the zero-crossing. This process is repeated for all intervals. The complete, sorted set of unique nodes and roots forms the final list of integration breakpoints.\n\nFinally, we perform the integration. We iterate through each subinterval defined by consecutive breakpoints, $[z_j, z_{j+1}]$. Within each such subinterval, $B(z)$ is guaranteed to be either non-negative or non-positive. We compute the definite integral of $B(z)$ over this subinterval using a high-accuracy adaptive quadrature method.\n$$\nI_j = \\int_{z_j}^{z_{j+1}} B(z) \\, dz\n$$\nBased on the definitions of CAPE and CIN:\n- If $I_j > 0$, its value is added to the total CAPE.\n- If $I_j < 0$, its value is negated and added to the total CIN (since $\\text{CIN} = -\\int \\min(B,0) dz$).\n- If $I_j = 0$, there is no contribution.\n\nThis procedure is applied to the full vertical domain. The final accumulated values for CAPE and CIN are then rounded to one decimal place to yield the result in units of $\\text{J}/\\text{kg}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\nimport warnings\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n\n    # Gravitational acceleration in m/s^2\n    G = 9.80665\n\n    def calculate_cape_cin(z_nodes, tve_nodes, tvp_nodes):\n        \"\"\"\n        Calculates CAPE and CIN for a single atmospheric profile.\n\n        Args:\n            z_nodes (np.array): Heights in meters.\n            tve_nodes (np.array): Environmental virtual temperatures in Kelvin.\n            tvp_nodes (np.array): Parcel virtual temperatures in Kelvin.\n\n        Returns:\n            tuple: A tuple containing (CAPE, CIN) in J/kg, rounded to one decimal place.\n        \"\"\"\n        # Ensure inputs are numpy arrays for vector operations\n        z_nodes = np.array(z_nodes, dtype=float)\n        tve_nodes = np.array(tve_nodes, dtype=float)\n        tvp_nodes = np.array(tvp_nodes, dtype=float)\n\n        # 1. Create shape-preserving piecewise cubic Hermite interpolators.\n        # Interpolator for environmental virtual temperature T_ve(z).\n        tve_interp = PchipInterpolator(z_nodes, tve_nodes)\n\n        # Calculate nodal differences D = T_vp - T_ve.\n        d_nodes = tvp_nodes - tve_nodes\n        # Interpolator for the difference D(z), preserving sign structure.\n        d_interp = PchipInterpolator(z_nodes, d_nodes)\n\n        # 2. Define the continuous buoyancy function B(z).\n        def buoyancy(z):\n            # Since T_ve is always positive, sign of B(z) depends only on D(z).\n            return G * d_interp(z) / tve_interp(z)\n\n        # 3. Find all integration breakpoints (original nodes + roots of D(z)).\n        breakpoints = set(z_nodes)\n        for i in range(len(z_nodes) - 1):\n            z_start, z_end = z_nodes[i], z_nodes[i+1]\n            d_start, d_end = d_nodes[i], d_nodes[i+1]\n\n            # A root exists between nodes if their signs are opposite.\n            if d_start * d_end < 0:\n                try:\n                    # Brent's method is robust for finding a root in a bracketed interval.\n                    root = brentq(d_interp, z_start, z_end)\n                    breakpoints.add(root)\n                except ValueError:\n                    # This should not be reached if signs are truly opposite,\n                    # but included for robustness.\n                    pass\n        \n        sorted_breakpoints = sorted(list(breakpoints))\n\n        # 4. Integrate over subintervals of constant sign and accumulate CAPE/CIN.\n        cape = 0.0\n        cin = 0.0\n\n        for i in range(len(sorted_breakpoints) - 1):\n            z_a, z_b = sorted_breakpoints[i], sorted_breakpoints[i+1]\n            \n            # Avoid integrating over zero-width intervals if duplicates exist\n            if z_a >= z_b:\n                continue\n            \n            # Use adaptive quadrature for high accuracy.\n            # Suppress integration warnings which may occur in complex cases\n            # but are handled by the robust algorithm.\n            with warnings.catch_warnings():\n                warnings.filterwarnings('ignore', category=UserWarning)\n                integral, _ = quad(buoyancy, z_a, z_b, limit=100)\n\n            # Accumulate based on the sign of the integral.\n            if integral > 0:\n                cape += integral\n            else:\n                # CIN = - integral(min(B,0) dz), so we add the absolute value\n                # of the negative integral.\n                cin -= integral\n        \n        # 5. Round to one decimal place as required.\n        return round(cape, 1), round(cin, 1)\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A\n        (\n            [0, 500, 1000, 1500, 2000, 3000],\n            [300.0, 296.0, 292.0, 288.5, 285.0, 281.0],\n            [300.0, 295.5, 292.5, 290.5, 289.0, 280.0]\n        ),\n        # Case B\n        (\n            [0, 200, 800, 1500, 2200],\n            [302.0, 300.5, 296.0, 292.0, 288.0],\n            [302.0, 300.5, 296.5, 294.0, 287.0]\n        ),\n        # Case C\n        (\n            [0, 1000, 1200, 2000, 4000],\n            [305.0, 297.0, 296.8, 294.0, 289.0],\n            [305.0, 296.0, 296.7, 295.0, 292.0]\n        )\n    ]\n\n    results = []\n    for z, tve, tvp in test_cases:\n        cape, cin = calculate_cape_cin(z, tve, tvp)\n        results.extend([cape, cin])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}