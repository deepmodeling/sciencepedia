{
    "hands_on_practices": [
        {
            "introduction": "对流有效位能（CAPE）的计算根植于浮力，而浮力不仅取决于温度，也与空气湿度密切相关。为了准确描述湿空气的密度，我们引入了虚温 $T_v$ 的概念，它统一了温度和水汽对浮力的贡献。这项练习 () 将引导您通过第一性原理推导，量化在计算浮力时忽略水汽效应所引入的系统性偏差，从而深刻理解为何在精确的对流参数化方案中必须使用虚温。",
            "id": "4026572",
            "problem": "在数值天气预报和气候模拟中，一个核心诊断量是对流有效位能 (CAPE)。从水汽质量混合比为 $q_v$ 的湿空气混合物的理想气体定律出发，并忽略凝结物，湿空气的密度可以通过引入虚温 $T_v$ 来表示，其定义为 $p = \\rho R_d T_v$，其中 $p$ 是气压，$\\rho$ 是密度，$R_d$ 是干空气的比气体常数。虚温满足 $T_v \\approx T \\left(1 + \\alpha q_v\\right)$，其中 $\\alpha \\equiv \\frac{1}{\\epsilon} - 1$，$\\epsilon \\equiv R_d/R_v \\approx 0.622$，$R_v$ 是水汽的比气体常数。假设为未饱和条件，没有凝结物，因此处处有 $q_l = q_i = 0$。一个气块的浮力加速度定义为 $B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}$，其中 $g$ 是重力加速度。\n\n考虑一个环境，其温度廓线为 $T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$，$z \\in [0,H]$，其中 $T_0 = 300\\,\\mathrm{K}$，$\\Gamma = 6.5\\,\\mathrm{K\\,km^{-1}}$，$H = 3000\\,\\mathrm{m}$。在同一层内，一个被抬升的气块具有恒定的超温 $\\Delta T \\equiv T_{\\mathrm{par}} - T_{\\mathrm{env}} = 2\\,\\mathrm{K}$ 和恒定的比湿超量 $\\Delta q_v \\equiv q_{v,\\mathrm{par}} - q_{v,\\mathrm{env}} = 0.004$。取 $g = 9.81\\,\\mathrm{m\\,s^{-2}}$ 且 $\\alpha = 0.61$。假设偏差很小，因此关于环境的 $(\\Delta T, \\Delta q_v)$ 线性化是有效的。\n\n任务：\n1) 从理想气体定律和浮力的定义出发，推导一个关于 $(\\Delta T, \\Delta q_v)$ 精确到一阶的 $B(z)$ 表达式，该表达式能分离出温度和水汽的贡献，并用 $T_{\\mathrm{env}}(z)$、$\\Delta T$ 和 $\\Delta q_v$ 表示。\n2) 使用你的结果，计算在 $[0,H]$ 上的两个CAPE值：\n- $ \\mathrm{CAPE}[T] \\equiv \\int_{0}^{H} B_T(z)\\,dz$，其中浮力计算忽略了水汽（即，处处用 $T$ 代替 $T_v$）。\n- $ \\mathrm{CAPE}[T_v] \\equiv \\int_{0}^{H} B_{T_v}(z)\\,dz$，包括一阶水汽贡献。\n3) 将忽略水汽引入的偏差定义为 $ \\mathrm{bias} \\equiv \\mathrm{CAPE}[T] - \\mathrm{CAPE}[T_v]$。对指定的廓线，数值计算此偏差。\n\n以 $\\mathrm{J\\,kg^{-1}}$ 为单位表示最终偏差，并将答案四舍五入到四位有效数字。",
            "solution": "首先验证问题，以确保其科学基础扎实、提法恰当且客观。\n\n### 步骤 1：提取已知条件\n- 湿空气的理想气体定律：$p = \\rho R_d T_v$\n- 虚温近似：$T_v \\approx T \\left(1 + \\alpha q_v\\right)$\n- 参数定义：$\\alpha \\equiv \\frac{1}{\\epsilon} - 1$，其中 $\\epsilon \\equiv R_d/R_v \\approx 0.622$\n- 凝结物假设：$q_l = q_i = 0$\n- 浮力加速度定义：$B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}$\n- 环境温度廓线：$T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$，$z \\in [0,H]$\n- 常数和参数：\n  - $T_0 = 300\\,\\mathrm{K}$\n  - $\\Gamma = 6.5\\,\\mathrm{K\\,km^{-1}}$\n  - $H = 3000\\,\\mathrm{m}$\n  - $\\Delta T \\equiv T_{\\mathrm{par}} - T_{\\mathrm{env}} = 2\\,\\mathrm{K}$ (恒定)\n  - $\\Delta q_v \\equiv q_{v,\\mathrm{par}} - q_{v,\\mathrm{env}} = 0.004$ (恒定)\n  - $g = 9.81\\,\\mathrm{m\\,s^{-2}}$\n  - $\\alpha = 0.61$\n- 假设：偏差小，关于 $(\\Delta T, \\Delta q_v)$ 的线性化有效。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题基于大气热力学的基本原理，包括理想气体定律、虚温概念和浮力。方程和参数值均为该领域的标准。\n- **提法恰当**：问题陈述清晰，包含三个明确的任务，最终导出一个数值答案。恒定超温和水汽超量等假设创建了一个简化但可解的问题。\n- **客观性**：问题以精确、定量的语言表述，没有主观性。\n\n### 步骤 3：结论和行动\n该问题被认为是有效的，因为它是一致的、科学上合理的且提法恰当。将制定解决方案。\n\n### 任务 1：推导一阶浮力表达式\n\n浮力加速度 $B$ 定义为：\n$$B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}} = g \\left(1 - \\frac{\\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}\\right)$$\n使用湿空气的理想气体定律 $p = \\rho R_d T_v$，我们可以将密度表示为 $\\rho = \\frac{p}{R_d T_v}$。气块理论中的一个基本假设是，在任何给定高度 $z$，气块的压力与其环境相同，即 $p_{\\mathrm{par}}(z) = p_{\\mathrm{env}}(z) = p(z)$。将密度表达式代入浮力方程，得到：\n$$B = g \\left(1 - \\frac{p / (R_d T_{v,\\mathrm{par}})}{p / (R_d T_{v,\\mathrm{env}})}\\right) = g \\left(1 - \\frac{T_{v,\\mathrm{env}}}{T_{v,\\mathrm{par}}}\\right) = g \\frac{T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}}}{T_{v,\\mathrm{par}}}$$\n设虚温差为 $\\Delta T_v = T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}}$。由于问题指出偏差很小，我们可以通过近似分母 $T_{v,\\mathrm{par}} \\approx T_{v,\\mathrm{env}}$ 来线性化此表达式，得出：\n$$B \\approx g \\frac{\\Delta T_v}{T_{v,\\mathrm{env}}}$$\n接下来，我们用给定的超温 $\\Delta T$ 和比湿超量 $\\Delta q_v$ 来表示 $\\Delta T_v$。使用定义 $T_v \\approx T(1 + \\alpha q_v)$：\n$$T_{v,\\mathrm{par}} \\approx T_{\\mathrm{par}}(1 + \\alpha q_{v,\\mathrm{par}})$$\n$$T_{v,\\mathrm{env}} \\approx T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}})$$\n代入 $T_{\\mathrm{par}} = T_{\\mathrm{env}} + \\Delta T$ 和 $q_{v,\\mathrm{par}} = q_{v,\\mathrm{env}} + \\Delta q_v$：\n$$\\Delta T_v = T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}} \\approx (T_{\\mathrm{env}} + \\Delta T)(1 + \\alpha (q_{v,\\mathrm{env}} + \\Delta q_v)) - T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}})$$\n展开乘积：\n$$\\Delta T_v \\approx (T_{\\mathrm{env}} + \\alpha T_{\\mathrm{env}}q_{v,\\mathrm{env}} + \\alpha T_{\\mathrm{env}}\\Delta q_v + \\Delta T + \\alpha \\Delta T q_{v,\\mathrm{env}} + \\alpha \\Delta T \\Delta q_v) - (T_{\\mathrm{env}} + \\alpha T_{\\mathrm{env}}q_{v,\\mathrm{env}})$$\n对于 $(\\Delta T, \\Delta q_v)$ 的一阶近似，我们忽略像 $\\alpha \\Delta T q_{v,\\mathrm{env}}$ 和 $\\alpha \\Delta T \\Delta q_v$ 这样的二阶项。这简化为：\n$$\\Delta T_v \\approx \\Delta T + \\alpha T_{\\mathrm{env}} \\Delta q_v$$\n将此代入线性化的浮力方程，并在分母中近似 $T_{v,\\mathrm{env}} = T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}}) \\approx T_{\\mathrm{env}}$（因为 $q_{v,\\mathrm{env}}$ 很小），我们得到期望的浮力表达式，记为 $B_{T_v}(z)$：\n$$B_{T_v}(z) \\approx g \\frac{\\Delta T + \\alpha T_{\\mathrm{env}}(z) \\Delta q_v}{T_{\\mathrm{env}}(z)} = g \\left(\\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + \\alpha \\Delta q_v\\right)$$\n此表达式分离了来自超温 $(\\Delta T)$ 和水汽超量 $(\\Delta q_v)$ 的贡献。\n\n### 任务 2：计算 CAPE 值\n\n首先，我们定义两个浮力项。包含水汽的完整浮力 $B_{T_v}$ 是上面推导的表达式。忽略水汽的浮力 $B_T$ 是通过将虚温 $T_v$ 设置为实际温度 $T$ 得到的，这等同于在虚温定义中设置 $\\alpha=0$。结果是：\n$$B_T(z) = g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}$$\n$$B_{T_v}(z) = g \\left(\\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + \\alpha \\Delta q_v\\right)$$\n现在我们通过在垂直范围 $z \\in [0, H]$ 上积分来计算相应的 CAPE 值。\n\n仅由温度引起的 CAPE 是：\n$$\\mathrm{CAPE}[T] = \\int_{0}^{H} B_T(z)\\,dz = \\int_{0}^{H} g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}\\,dz$$\n代入 $T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$:\n$$\\mathrm{CAPE}[T] = g \\Delta T \\int_{0}^{H} \\frac{1}{T_0 - \\Gamma z}\\,dz$$\n积分计算如下：\n$$\\int_{0}^{H} \\frac{1}{T_0 - \\Gamma z}\\,dz = \\left[-\\frac{1}{\\Gamma} \\ln(T_0 - \\Gamma z)\\right]_{0}^{H} = -\\frac{1}{\\Gamma} \\left( \\ln(T_0 - \\Gamma H) - \\ln(T_0) \\right) = \\frac{1}{\\Gamma} \\ln\\left(\\frac{T_0}{T_0 - \\Gamma H}\\right)$$\n因此，$\\mathrm{CAPE}[T]$ 的解析表达式是：\n$$\\mathrm{CAPE}[T] = \\frac{g \\Delta T}{\\Gamma} \\ln\\left(\\frac{T_0}{T_0 - \\Gamma H}\\right)$$\n包含虚温效应的 CAPE 是：\n$$\\mathrm{CAPE}[T_v] = \\int_{0}^{H} B_{T_v}(z)\\,dz = \\int_{0}^{H} \\left( g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + g \\alpha \\Delta q_v \\right)\\,dz$$\n利用积分的线性性质：\n$$\\mathrm{CAPE}[T_v] = \\int_{0}^{H} g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}\\,dz + \\int_{0}^{H} g \\alpha \\Delta q_v\\,dz$$\n第一项是 $\\mathrm{CAPE}[T]$。第二项是一个常数的积分：\n$$\\int_{0}^{H} g \\alpha \\Delta q_v\\,dz = g \\alpha \\Delta q_v [z]_{0}^{H} = g \\alpha \\Delta q_v H$$\n因此，$\\mathrm{CAPE}[T_v]$ 的表达式是：\n$$\\mathrm{CAPE}[T_v] = \\mathrm{CAPE}[T] + g \\alpha \\Delta q_v H$$\n\n### 任务 3：计算偏差\n\n偏差定义为 $\\mathrm{bias} \\equiv \\mathrm{CAPE}[T] - \\mathrm{CAPE}[T_v]$。使用任务 2 中推导的表达式：\n$$\\mathrm{bias} = \\mathrm{CAPE}[T] - (\\mathrm{CAPE}[T] + g \\alpha \\Delta q_v H) = -g \\alpha \\Delta q_v H$$\n这个非常简单的结果表明，在给定的假设下，因忽略水汽对浮力的影响而引入的偏差与温度廓线无关。我们现在可以使用提供的常数计算其数值。确保所有单位都使用国际单位制（SI）非常重要。给定的值为：\n$g = 9.81\\,\\mathrm{m\\,s^{-2}}$\n$\\alpha = 0.61$ (无量纲)\n$\\Delta q_v = 0.004$ (无量纲, kg/kg)\n$H = 3000\\,\\mathrm{m}$\n\n将这些值代入偏差的表达式：\n$$\\mathrm{bias} = -(9.81\\,\\mathrm{m\\,s^{-2}}) \\times (0.61) \\times (0.004) \\times (3000\\,\\mathrm{m})$$\n$$\\mathrm{bias} = -71.8092\\,\\mathrm{m^2\\,s^{-2}}$$\n单位 $\\mathrm{m^2\\,s^{-2}}$ 等同于焦耳每千克 ($\\mathrm{J\\,kg^{-1}}$)。\n问题要求答案四舍五入到四位有效数字。\n$$\\mathrm{bias} \\approx -71.81\\,\\mathrm{J\\,kg^{-1}}$$\n负号表示忽略水汽会导致对 CAPE 的低估，因为在相同温度下，湿气块比干气块更具浮力。",
            "answer": "$$\\boxed{-71.81}$$"
        },
        {
            "introduction": "对流抑制（CIN）是阻碍对流发展的能量“盖子”，但这个“盖子”的强度并非一成不变，它会随着大气状态而演变。例如，逆温层顶部的辐射冷却会增强逆温，从而增大 CIN，进一步抑制或推迟对流的触发。本练习 () 构建了一个理想化的模型，让您亲手计算辐射冷却对 CIN 的影响，从而深入理解对流稳定度的日变化机理，这是天气预报中的一个关键环节。",
            "id": "4026583",
            "problem": "要求您计算对流抑制 (Convective Inhibition, CIN) 如何响应局限于逆温顶盖层内的辐射冷却而发生变化。请在一维垂直气柱中进行计算，并采用以下基于原理的建模和数值假设。\n\n从静力平衡、理想气体和用于小温差分数的 Boussinesq 近似出发：一个绝热抬升的气块相对于环境的浮力由下式给出\n$$\nB(z) \\equiv \\frac{g \\, \\left[T_{p}(z) - T_{e}(z)\\right]}{T_{\\mathrm{ref}}},\n$$\n其中 $g$ 是重力加速度，$T_{p}(z)$ 是气块温度，$T_{e}(z)$ 是环境温度，$T_{\\mathrm{ref}}$ 是一个恒定的参考温度。对流抑制 (CIN) 是将气块从地表抬升至自由对流高度 (Level of Free Convection, LFC) 所需的单位质量功，表示为负浮力的垂直积分：\n$$\n\\mathrm{CIN} \\equiv - \\int_{0}^{z_{\\mathrm{LFC}}} \\min\\{B(z), 0\\} \\, dz,\n$$\n其中 $z_{\\mathrm{LFC}}$ 是 $B(z)$ 变为非负的最小高度（如果存在）。如果 $B(z)$ 在模式层顶内没有变为非负，则将积分上限定义为模式层顶 $z_{\\mathrm{top}}$。\n\n假设环境温度结构如下：\n- 地表温度为 $T_{s}$，位于 $z = 0$。\n- 在逆温层底部 $z_{i}$ 以下，环境递减率为 $\\Gamma_{\\mathrm{bl}}$，因此对于 $0 \\le z  z_{i}$，\n$$\nT_{e}(z) = T_{s} - \\Gamma_{\\mathrm{bl}} \\, z.\n$$\n- 穿过厚度为 $d_{i}$ 的逆温层（从 $z_{i}$ 到 $z_{i}+d_{i}$），递减率为负值 $\\Gamma_{\\mathrm{inv}}  0$，因此温度随高度增加：\n$$\nT_{e}(z) = T_{e}(z_{i}^{-}) - \\Gamma_{\\mathrm{inv}} \\, (z - z_{i}), \\quad z_{i} \\le z  z_{i}+d_{i}.\n$$\n- 在逆温层顶部 $z_{i}+d_{i}$ 以上，自由对流层递减率为 $\\Gamma_{\\mathrm{ft}}$：\n$$\nT_{e}(z) = T_{e}(z_{i}+d_{i}) - \\Gamma_{\\mathrm{ft}} \\, \\left(z - (z_{i}+d_{i})\\right), \\quad z \\ge z_{i}+d_{i}.\n$$\n\n假设气块绝热上升，其递减率分为两层：\n- 气块在其抬升凝结高度 $z_{\\mathrm{LCL}}$ 以下是未饱和的，并以干绝热递减率 $\\Gamma_{d}$ 冷却：\n$$\nT_{p}(z) = T_{s} - \\Gamma_{d} \\, z, \\quad 0 \\le z \\le z_{\\mathrm{LCL}}.\n$$\n- 在 $z_{\\mathrm{LCL}}$ 以上，气块以恒定的湿绝热递减率 $\\Gamma_{m}$ 冷却：\n$$\nT_{p}(z) = \\left[T_{s} - \\Gamma_{d} \\, z_{\\mathrm{LCL}}\\right] - \\Gamma_{m} \\, (z - z_{\\mathrm{LCL}}), \\quad z \\ge z_{\\mathrm{LCL}}.\n$$\n使用一个标准的经验公式来近似抬升凝结高度：\n$$\nz_{\\mathrm{LCL}} \\approx 125 \\, \\left(T_{s} - T_{d}\\right),\n$$\n其中 $T_{d}$ 是地表露点温度，当 $T_{s}$ 和 $T_{d}$ 以开尔文为单位时，$z_{\\mathrm{LCL}}$ 以米为单位表示。\n\n将局限于逆温层内的辐射冷却建模为一个均匀的温度趋势 $r$（开尔文/秒），作用时间为 $\\Delta t$ 秒，且仅作用于逆温层 $z \\in [z_{i}, z_{i}+d_{i}]$ 内。即，\n$$\nT_{e}^{\\mathrm{cool}}(z) = \n\\begin{cases}\nT_{e}(z) - r \\, \\Delta t,  z_{i} \\le z \\le z_{i}+d_{i},\\\\\nT_{e}(z),  \\text{otherwise.}\n\\end{cases}\n$$\n\n常数和数值域：\n- 使用 $g = 9.81 \\ \\mathrm{m \\ s^{-2}}$ 和 $T_{\\mathrm{ref}} = 300 \\ \\mathrm{K}$。\n- 在从 $z=0$ 到 $z_{\\mathrm{top}} = 4000 \\ \\mathrm{m}$ 的均匀垂直网格上进行积分，网格间距为 $\\Delta z = 1 \\ \\mathrm{m}$。\n- 对于每种情况，将 $z_{\\mathrm{LFC}}$ 确定为 $B(z)$ 变为非负的最小 $z$ 值。如果在 $z_{\\mathrm{top}}$ 以下不存在这样的高度，则将积分上限设为 $z_{\\mathrm{top}}$。\n- 对于每种情况，计算 $t=0$ 时和施加冷却后 $t=\\Delta t$ 时的 $\\mathrm{CIN}$，并报告其变化量 $\\Delta \\mathrm{CIN} = \\mathrm{CIN}(t=\\Delta t) - \\mathrm{CIN}(t=0)$。\n\n单位和输出要求：\n- 所有最终的 $\\Delta \\mathrm{CIN}$ 值以 $\\mathrm{J \\ kg^{-1}}$ 为单位表示，并四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[ \\text{result1}, \\text{result2}, \\text{result3} \\right]$）。\n\n测试套件：\n对于每个测试用例，参数被指定为一个有序元组\n$$\n\\left(T_{s} \\ \\mathrm{[K]}, \\ T_{d} \\ \\mathrm{[K]}, \\ z_{i} \\ \\mathrm{[m]}, \\ d_{i} \\ \\mathrm{[m]}, \\ \\Gamma_{\\mathrm{bl}} \\ \\mathrm{[K \\ m^{-1}]}, \\ \\Gamma_{\\mathrm{inv}} \\ \\mathrm{[K \\ m^{-1}]}, \\ \\Gamma_{\\mathrm{ft}} \\ \\mathrm{[K \\ m^{-1}]}, \\ \\Gamma_{d} \\ \\mathrm{[K \\ m^{-1}]}, \\ \\Gamma_{m} \\ \\mathrm{[K \\ m^{-1}]}, \\ \\Delta t \\ \\mathrm{[s]}, \\ r \\ \\mathrm{[K \\ s^{-1}]}\\right).\n$$\n- 情况 1（基准中等冷却）：\n$$\n\\left(300.0, \\ 292.0, \\ 1200.0, \\ 200.0, \\ 0.0060, \\ -0.0150, \\ 0.0060, \\ 0.0098, \\ 0.0045, \\ 3600.0, \\ \\frac{1.5}{3600.0}\\right).\n$$\n- 情况 2（零冷却对照）：\n$$\n\\left(300.0, \\ 292.0, \\ 1200.0, \\ 200.0, \\ 0.0060, \\ -0.0150, \\ 0.0060, \\ 0.0098, \\ 0.0045, \\ 3600.0, \\ 0.0\\right).\n$$\n- 情况 3（强冷却，持续时间更长）：\n$\n\\left(300.0, \\ 292.0, \\ 1200.0, \\ 200.0, \\ 0.0060, \\ -0.0150, \\ 0.0060, \\ 0.0098, \\ 0.0045, \\ 7200.0, \\ \\frac{4.0}{3600.0}\\right).\n$\n- 情况 4（初始弱逆温顶；冷却产生更强的逆温顶）：\n$\n\\left(302.0, \\ 298.0, \\ 900.0, \\ 150.0, \\ 0.0090, \\ -0.0050, \\ 0.0070, \\ 0.0098, \\ 0.0040, \\ 5400.0, \\ \\frac{2.0}{3600.0}\\right).\n$\n\n您的任务是实现一个程序，为每种情况计算对流抑制的变化量 $\\Delta \\mathrm{CIN}$（单位为 $\\mathrm{J \\ kg^{-1}}$，四舍五入到三位小数），并按上述规定，将所有四个结果以方括号括起来的逗号分隔列表形式打印在单行中。",
            "solution": "用户问题已通过验证并被确定为**有效**。该问题具有科学依据，提法明确，客观，并包含进行求解所需的所有必要信息。\n\n### 基于原理的解决方案设计\n\n该问题要求计算由于大气逆温层内的辐射冷却引起的对流抑制 (CIN) 的变化。解决方案将通过首先构建物理系统的数学和数值表示，然后实现此表示来为几个测试用例计算所需量。\n\n**1. 物理和数学框架**\n\n问题的核心在于浮力 $B(z)$ 和对流抑制 CIN 的定义。\n\n- **浮力，$B(z)$**：气块的浮力是其相对于周围环境上升或下沉的趋势。它与给定高度 $z$ 处气块的温度 $T_p(z)$ 和环境的温度 $T_e(z)$ 之间的温差成正比。\n  $$\n  B(z) = \\frac{g}{T_{\\mathrm{ref}}} \\left[ T_p(z) - T_e(z) \\right]\n  $$\n  其中 $g$ 是重力加速度，$T_{\\mathrm{ref}}$ 是一个恒定的参考温度。\n\n- **对流抑制，CIN**：CIN 代表气块达到其自由对流高度 (LFC) 所必须克服的能量障碍，LFC 是气块获得正浮力并能自行上升的高度。它通过对从地表 ($z=0$) 到 LFC ($z_{\\text{LFC}}$) 的负浮力进行积分来计算。\n  $$\n  \\mathrm{CIN} \\equiv - \\int_{0}^{z_{\\mathrm{LFC}}} \\min\\{B(z), 0\\} \\, dz\n  $$\n  被积函数 $\\min\\{B(z), 0\\}$ 分离出负浮力区域。积分前面的负号使 CIN 成为一个正值，代表能量亏损。\n\n**2. 温度廓线**\n\n为了计算浮力，我们必须首先定义温度廓线 $T_p(z)$ 和 $T_e(z)$。问题将它们指定为连续的分段线性函数。\n\n- **环境温度，$T_e(z)$**：环境被建模为三层：边界层、逆温层及其上方的自由对流层。任何高度 $z$ 处的温度由地表温度 $T_s$ 和每层特定的递减率 ($\\Gamma$) 决定。廓线从地表向上连续构建。\n\n- **气块温度，$T_p(z)$**：假设气块从地表开始，温度为 $T_s$。当它被抬升时，它会绝热冷却。在其抬升凝结高度 ($z_{\\text{LCL}}$) 以下，它以干绝热递减率 $\\Gamma_d$ 冷却。在 $z_{\\text{LCL}}$ 以上，它以湿绝热递减率 $\\Gamma_m$ 冷却。$z_{\\text{LCL}}$ 的值是根据地表温度和露点 $T_d$ 估算的。\n\n**3. 辐射冷却建模**\n\n要建模的核心物理过程是辐射冷却的影响。这通过直接修改环境温度廓线来实现。问题规定，在持续时间 $\\Delta t$ 内，一个均匀的冷却速率 $r$ 仅在逆温层 ($z_i \\le z \\le z_i + d_i$) 内施加。由此产生的冷却后环境廓线 $T_e^{\\text{cool}}(z)$ 定义为：\n$$\nT_{e}^{\\mathrm{cool}}(z) = \n\\begin{cases}\nT_{e}(z) - r \\, \\Delta t,  z_{i} \\le z \\le z_{i}+d_{i},\\\\\nT_{e}(z),  \\text{otherwise.}\n\\end{cases}\n$$\n此定义意味着，在施加冷却后，温度廓线在逆温层的边界 $z_i$ 和 $z_i+d_i$ 处变得不连续。这是实现中的一个关键细节。\n\n**4. 数值实现策略**\n\n该解决方案将使用 `numpy` 库作为一个 Python 程序来实现。\n\n- **网格离散化**：将建立一个从 $z=0$ 到 $z_{\\text{top}} = 4000 \\ \\mathrm{m}$ 的均匀垂直网格，间距为 $\\Delta z = 1 \\ \\mathrm{m}$。所有物理量 ($T_e, T_p, B$) 将在此网格的每个点上计算。\n\n- **廓线计算**：将编写函数，根据其分段定义来计算 $T_p(z)$ 和 $T_e(z)$ 数组。冷却效应将通过从位于逆温层内的网格点的 $T_e$ 数组中减去总冷却量 $r \\cdot \\Delta t$ 来应用。\n\n- **LFC 识别**：自由对流高度 ($z_{\\text{LFC}}$) 是 $B(z) \\geq 0$ 的最低高度。这将通过在计算出的浮力数组 `B` 中搜索第一个非负值来找到。如果在 $z_{\\text{top}}$ 以下不存在这样的值，CIN 的积分上限将设置为 $z_{\\text{top}}$。\n\n- **数值积分**：CIN 积分将使用梯形法则进行数值计算，如 `numpy.trapz` 所实现的。积分将在被积函数数组 $\\min(B, 0)$ 上进行，从地表到与确定的 $z_{\\text{LFC}}$ 相对应的网格索引。\n\n- **主计算循环**：程序将遍历每个测试用例。对于每个用例，它将：\n  1. 使用未扰动的环境廓线计算初始 CIN，$\\mathrm{CIN}(t=0)$。\n  2. 使用冷却后的环境廓线计算最终 CIN，$\\mathrm{CIN}(t=\\Delta t)$。\n  3. 计算变化量，$\\Delta \\mathrm{CIN} = \\mathrm{CIN}(t=\\Delta t) - \\mathrm{CIN}(t=0)$。\n  4. 存储结果，并格式化为三位小数。\n\n最后，所有结果将被收集并以指定的逗号分隔列表格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as specified in the problem\nG = 9.81  # Gravitational acceleration in m/s^2\nT_REF = 300.0  # Reference temperature in K\nZ_TOP = 4000.0  # Model top in m\nDZ = 1.0  # Grid spacing in m\n\ndef compute_cin(params, apply_cooling):\n    \"\"\"\n    Computes Convective Inhibition (CIN) for a given set of atmospheric parameters.\n\n    Args:\n        params (tuple): A tuple containing all atmospheric parameters for a test case.\n        apply_cooling (bool): Flag to determine whether to apply radiative cooling.\n\n    Returns:\n        float: The computed CIN value in J/kg.\n    \"\"\"\n    (Ts, Td, zi, di, Gamma_bl, Gamma_inv, Gamma_ft, \n     Gamma_d, Gamma_m, delta_t, r) = params\n\n    # 1. Define the vertical grid from z=0 to z_top\n    z_grid = np.arange(0, Z_TOP + DZ, DZ)\n\n    # 2. Calculate derived parameters\n    z_lcl = 125.0 * (Ts - Td)\n    total_cooling = r * delta_t\n\n    # 3. Compute the initial environmental temperature profile (Te)\n    # The profile is defined piecewise and is continuous before cooling.\n    Te = np.zeros_like(z_grid)\n    \n    # Layer 1: Boundary Layer (0 = z  zi)\n    cond_bl = z_grid  zi\n    Te[cond_bl] = Ts - Gamma_bl * z_grid[cond_bl]\n    \n    # Layer 2: Inversion Layer (zi = z  zi + di)\n    cond_inv = (z_grid >= zi)  (z_grid  zi + di)\n    Te_at_zi = Ts - Gamma_bl * zi\n    Te[cond_inv] = Te_at_zi - Gamma_inv * (z_grid[cond_inv] - zi)\n    \n    # Layer 3: Free Troposphere (z >= zi + di)\n    cond_ft = z_grid >= zi + di\n    Te_at_zi_plus_di = Te_at_zi - Gamma_inv * di\n    Te[cond_ft] = Te_at_zi_plus_di - Gamma_ft * (z_grid[cond_ft] - (zi + di))\n\n    # 4. Apply radiative cooling if specified\n    # The problem defines cooling as a subtraction from the initial Te profile\n    # only within the inversion layer, creating discontinuities at zi and zi+di.\n    if apply_cooling:\n        cooling_indices = (z_grid >= zi)  (z_grid = zi + di)\n        Te[cooling_indices] -= total_cooling\n\n    # 5. Compute the parcel temperature profile (Tp)\n    # The profile is piecewise, with a change in lapse rate at the LCL.\n    Tp = np.zeros_like(z_grid)\n    \n    # Below LCL: Dry adiabatic ascent (0 = z = z_lcl)\n    cond_dry = z_grid = z_lcl\n    Tp[cond_dry] = Ts - Gamma_d * z_grid[cond_dry]\n    \n    # Above LCL: Moist adiabatic ascent (z > z_lcl)\n    cond_moist = z_grid > z_lcl\n    Tp_at_lcl = Ts - Gamma_d * z_lcl\n    Tp[cond_moist] = Tp_at_lcl - Gamma_m * (z_grid[cond_moist] - z_lcl)\n\n    # 6. Compute buoyancy B(z)\n    B = (G / T_REF) * (Tp - Te)\n\n    # 7. Find the Level of Free Convection (LFC)\n    # The LFC is the smallest height z where B(z) becomes nonnegative.\n    lfc_indices = np.where(B >= 0)[0]\n    \n    if lfc_indices.size > 0:\n        # LFC is found within the domain; integrate up to its grid index.\n        integration_limit_idx = lfc_indices[0]\n    else:\n        # LFC not found; integrate up to the model top as per problem spec.\n        integration_limit_idx = z_grid.size - 1\n\n    # 8. Compute CIN via numerical integration\n    # CIN = - integral from 0 to z_LFC of min(B(z), 0) dz\n    integrand = np.minimum(B, 0)\n    \n    # Use the trapezoidal rule on the relevant portion of the arrays.\n    # The slice [:idx+1] includes all points from index 0 to idx.\n    z_to_integrate = z_grid[:integration_limit_idx + 1]\n    integrand_to_integrate = integrand[:integration_limit_idx + 1]\n\n    # np.trapz requires at least two points. If LFC is at z=0, CIN is 0.\n    if len(z_to_integrate)  2:\n        cin = 0.0\n    else:\n        cin = -np.trapz(integrand_to_integrate, x=z_to_integrate)\n\n    return cin\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the calculation for all test cases\n    and prints the final output in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (baseline moderate cooling)\n        (300.0, 292.0, 1200.0, 200.0, 0.0060, -0.0150, 0.0060, 0.0098, 0.0045, 3600.0, 1.5/3600.0),\n        # Case 2 (zero cooling control)\n        (300.0, 292.0, 1200.0, 200.0, 0.0060, -0.0150, 0.0060, 0.0098, 0.0045, 3600.0, 0.0),\n        # Case 3 (strong cooling, longer duration)\n        (300.0, 292.0, 1200.0, 200.0, 0.0060, -0.0150, 0.0060, 0.0098, 0.0045, 7200.0, 4.0/3600.0),\n        # Case 4 (initially weak cap, subsequently weakened by cooling)\n        (302.0, 298.0, 900.0, 150.0, 0.0090, -0.0050, 0.0070, 0.0098, 0.0040, 5400.0, 2.0/3600.0),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # Calculate CIN before cooling\n        cin_initial = compute_cin(case_params, apply_cooling=False)\n        # Calculate CIN after cooling\n        cin_final = compute_cin(case_params, apply_cooling=True)\n        # Compute the change in CIN\n        delta_cin = cin_final - cin_initial\n        # Format and store the result\n        results.append(f\"{delta_cin:.3f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在数值模型中，大气廓线以离散数据点的形式存在，在这些点之间进行插值是计算积分所必需的步骤。然而，标准的插值方法（如三次样条）可能会产生虚假的振荡，从而在数据点之间“无中生有”地制造出自然界中不存在的浮力层，导致 CAPE 或 CIN 的计算失真。这项高级练习 () 要求您设计并实现一种能保持廓线形状的插值方案，以确保浮力 $B(z)$ 的符号结构在插值过程中不被破坏，从而得到更符合物理真实的 CAPE 和 CIN 估算值。",
            "id": "4026587",
            "problem": "给定环境虚温和抬升气块虚温随几何高度变化的离散垂直廓线。根据基本原理，在高度 $z$ 处，单位质量空气块的特定浮力定义为\n$$\nB(z) \\equiv g \\,\\frac{T_{v,p}(z) - T_{v,e}(z)}{T_{v,e}(z)},\n$$\n其中，$g$ 是重力加速度，$T_{v,e}(z)$ 是环境虚温，$T_{v,p}(z)$ 是气块虚温。对流有效位能 (CAPE) 和对流抑制能 (CIN) 是浮力加速度在垂直方向上的路径积分，定义为\n$$\n\\text{CAPE} \\equiv \\int_{z_{\\text{min}}}^{z_{\\text{max}}} \\max\\{B(z),\\,0\\}\\,dz, \\qquad\n\\text{CIN} \\equiv -\\int_{z_{\\text{min}}}^{z_{\\text{max}}} \\min\\{B(z),\\,0\\}\\,dz.\n$$\n在数值天气预报和气候模拟中，由振荡插值引起的 $B(z)$ 中虚假正值区域的产生会破坏 $\\text{CAPE}$ 的估算。您必须为 $T_{v,e}(z)$ 和气块 $T_{v,p}(z)$ 设计并实现一个稳健的插值方案，该方案能保留 $B(z)$ 的符号结构并避免虚假的 $\\text{CAPE}$ 产生，其科学基础如下：\n- 理想气体定律和虚温的定义表明，在给定的气压层上，浮力的符号由 $T_{v,p}(z) - T_{v,e}(z)$ 的符号决定。\n- 对于分层流体，阿基米德原理和静力平衡将 $B(z)$ 解释为由密度（或虚温）差异引起的垂直加速度。\n\n您的任务是使用一种插值和积分方法，根据离散数据计算 $\\text{CAPE}$ 和 $\\text{CIN}$，该方法：\n- 使用保形分段三次 Hermite 插值表示 $T_{v,e}(z)$，以避免在网格区间内出现过冲。\n- 使用直接根据节点差值构建的保形分段三次 Hermite 插值表示差值 $D(z) \\equiv T_{v,p}(z) - T_{v,e}(z)$，从而精确保留 $D$ 在节点上的零点，并且不在节点之间引入振荡性的符号变化。\n- 使用上述插值函数，通过 $B(z) = g \\, D(z) / T_{v,e}(z)$ 定义 $B(z)$。\n- 通过使用稳健的区间套定和求根方法定位节点间 $D(z)$ 的零点，来检测 $B(z)$ 的所有符号变化。将节点上的零点明确地作为断点。不要假设间距是均匀的。\n- 将垂直域 $[z_{\\text{min}}, z_{\\text{max}}]$ 分割成由连续的零点和节点界定的子区间，以使 $B(z)$ 在每个子区间上的符号恒定，然后使用数值精确的求积法则在每个子区间上对 $B(z)$进行积分。根据上述定义，将正贡献累加到 $\\text{CAPE}$ 中，将负贡献累加到 $\\text{CIN}$ 中。\n\n科学和数值要求：\n- 使用重力加速度 $g = 9.80665$ $\\text{m}/\\text{s}^2$。\n- 高度 $z$ 的单位是米，虚温的单位是开尔文。\n- 将 $\\text{CAPE}$ 和 $\\text{CIN}$ 以 $\\text{J}/\\text{kg}$（等同于 $\\text{m}^2/\\text{s}^2$）为单位表示，并四舍五入到一位小数。\n\n测试套件：\n对于以下每个案例，$z$ 都是严格递增的，并且对两个廓线共用。所有温度均为虚温。\n\n- 案例 A（理想路径：近地表为负，然后为正，再为负）：\n  - $z = [\\,0,\\,500,\\,1000,\\,1500,\\,2000,\\,3000\\,]$ 单位：米。\n  - $T_{v,e}(z) = [\\,300.0,\\,296.0,\\,292.0,\\,288.5,\\,285.0,\\,281.0\\,]$ 单位：开尔文。\n  - $T_{v,p}(z) = [\\,300.0,\\,295.5,\\,292.5,\\,290.5,\\,289.0,\\,280.0\\,]$ 单位：开尔文。\n\n- 案例 B（零浮力平稳段被精确保留，然后为正，再为负）：\n  - $z = [\\,0,\\,200,\\,800,\\,1500,\\,2200\\,]$ 单位：米。\n  - $T_{v,e}(z) = [\\,302.0,\\,300.5,\\,296.0,\\,292.0,\\,288.0\\,]$ 单位：开尔文。\n  - $T_{v,p}(z) = [\\,302.0,\\,300.5,\\,296.5,\\,294.0,\\,287.0\\,]$ 单位：开尔文。\n\n- 案例 C（近中性层附近的急剧曲率；避免虚假的振荡正值区域）：\n  - $z = [\\,0,\\,1000,\\,1200,\\,2000,\\,4000\\,]$ 单位：米。\n  - $T_{v,e}(z) = [\\,305.0,\\,297.0,\\,296.8,\\,294.0,\\,289.0\\,]$ 单位：开尔文。\n  - $T_{v,p}(z) = [\\,305.0,\\,296.0,\\,296.7,\\,295.0,\\,292.0\\,]$ 单位：开尔文。\n\n您的程序必须：\n- 实现上述的插值和零点保留策略。\n- 稳健地检测所有零点穿越，并在符号恒定的子区间上进行积分。\n- 为每个案例生成两个实数：$\\text{CAPE}$ 和 $\\text{CIN}$，单位为 $\\text{J}/\\text{kg}$，四舍五入到一位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\,\\text{CAPE}_A,\\,\\text{CIN}_A,\\,\\text{CAPE}_B,\\,\\text{CIN}_B,\\,\\text{CAPE}_C,\\,\\text{CIN}_C\\,]$。例如，一个语法上有效的输出看起来像“[12.3,4.5,67.8,9.0,1.2,3.4]”，但应使用为给定输入计算出的正确值。",
            "solution": "该问题是有效的。它在数值大气模拟领域提出了一个清晰、独立且具有科学依据的任务。所提供的浮力、对流有效位能 (CAPE) 和对流抑制能 (CIN) 的定义是气象学中的标准定义。该问题解决了一个真实的数值挑战：标准插值方法可能引入虚假振荡，从而导致对大气稳定度参数的错误估算。所提出的解决方案，即使用保形分段三次 Hermite 插值，是解决此问题的一种成熟且适当的技术。测试案例中提供的数据在物理上是合理的，并且数值计算步骤的说明是具体且内部一致的。\n\n为每个给定的大气廓线计算 CAPE 和 CIN 的方法如下：\n\n首先，我们确定必要的物理常数和输入数据。重力加速度给定为 $g = 9.80665 \\, \\text{m}/\\text{s}^2$。对于每个测试案例，我们都获得了高度 $z$（单位：米）、环境虚温 $T_{v,e}(z)$（单位：开尔文）和抬升气块虚温 $T_{v,p}(z)$（单位：开尔文）的离散垂直廓线。\n\n该方法的核心是从离散数据点准确地表示连续函数。问题要求采用一种保形方法以避免数值伪影。\n1.  环境虚温廓线 $T_{v,e}(z)$ 由一个保形分段三次 Hermite 插值多项式表示。这种类型的插值是单调的，意味着它不会在给定的数据点之间创建新的局部极值。这对于保持温度廓线的物理特性至关重要。我们根据给定的 $(z_i, T_{v,e,i})$ 数据对构建此插值函数。\n\n2.  虚温差的垂直廓线 $D(z) \\equiv T_{v,p}(z) - T_{v,e}(z)$ 是浮力符号的直接决定因素。为确保浮力的符号结构在节点之间被完美保留，我们首先计算每个高度 $z_i$ 处的节点差值 $D_i = T_{v,p,i} - T_{v,e,i}$。然后，我们直接从 $(z_i, D_i)$ 数据对构建一个用于 $D(z)$ 的保形分段三次 Hermite 插值多项式。这保证了如果在一个节点上 $D_i = 0$，插值函数在该节点处也为零。此外，如果 $D_i$ 和 $D_{i+1}$ 符号相同（或其中一个为零），插值函数 $D(z)$ 在区间 $(z_i, z_{i+1})$ 内不会改变符号。\n\n有了这些连续表示，比浮力 $B(z)$ 对于廓线域内的任何高度 $z$ 定义为：\n$$\nB(z) = g \\frac{D(z)}{T_{v,e}(z)}\n$$\n其中 $D(z)$ 和 $T_{v,e}(z)$ 是从它们各自的插值函数中获得的值。由于 $T_{v,e}(z)$（单位：开尔文）始终为正值，因此 $B(z)$ 的符号与 $D(z)$ 的符号相同。\n\n为了计算 CAPE 和 CIN 积分，垂直域 $[z_{\\text{min}}, z_{\\text{max}}]$ 必须被划分成 $B(z)$ 符号恒定的子区间。这些子区间的边界，或称断点，是 $B(z) = 0$ 的点。这些点发生在 $D(z) = 0$ 的地方。因此，断点的集合包括所有原始节点 $z_i$ 以及任何严格位于节点之间的 $D(z)=0$ 的额外根。\n为了找到这些根，我们检查每个区间 $[z_i, z_{i+1}]$。如果节点值 $D_i$ 和 $D_{i+1}$ 符号相反（即 $D_i \\cdot D_{i+1}  0$），则在 $(z_i, z_{i+1})$ 内必定存在一个根。我们在这个有界区间内对插值函数 $D(z)$ 采用一个稳健的数值求根算法，例如 Brent 方法，来找到零点穿越的精确高度。对所有区间重复此过程。所有唯一的节点和根组成的完整、排序后的集合构成了最终的积分断点列表。\n\n最后，我们进行积分。我们遍历由连续断点定义的每个子区间 $[z_j, z_{j+1}]$。在每个这样的子区间内，$B(z)$ 保证为非负或非正。我们使用高精度的自适应求积方法计算 $B(z)$ 在此子区间上的定积分。\n$$\nI_j = \\int_{z_j}^{z_{j+1}} B(z) \\, dz\n$$\n根据 CAPE 和 CIN 的定义：\n- 如果 $I_j > 0$，其值被加到总 CAPE 中。\n- 如果 $I_j  0$，其值被取反并加到总 CIN 中（因为 $\\text{CIN} = -\\int \\min(B,0) dz$）。\n- 如果 $I_j = 0$，则没有贡献。\n\n此过程应用于整个垂直域。然后将最终累积的 CAPE 和 CIN 值四舍五入到一位小数，以 $\\text{J}/\\text{kg}$ 为单位得出结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\nimport warnings\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n\n    # Gravitational acceleration in m/s^2\n    G = 9.80665\n\n    def calculate_cape_cin(z_nodes, tve_nodes, tvp_nodes):\n        \"\"\"\n        Calculates CAPE and CIN for a single atmospheric profile.\n\n        Args:\n            z_nodes (np.array): Heights in meters.\n            tve_nodes (np.array): Environmental virtual temperatures in Kelvin.\n            tvp_nodes (np.array): Parcel virtual temperatures in Kelvin.\n\n        Returns:\n            tuple: A tuple containing (CAPE, CIN) in J/kg, rounded to one decimal place.\n        \"\"\"\n        # Ensure inputs are numpy arrays for vector operations\n        z_nodes = np.array(z_nodes, dtype=float)\n        tve_nodes = np.array(tve_nodes, dtype=float)\n        tvp_nodes = np.array(tvp_nodes, dtype=float)\n\n        # 1. Create shape-preserving piecewise cubic Hermite interpolators.\n        # Interpolator for environmental virtual temperature T_ve(z).\n        tve_interp = PchipInterpolator(z_nodes, tve_nodes)\n\n        # Calculate nodal differences D = T_vp - T_ve.\n        d_nodes = tvp_nodes - tve_nodes\n        # Interpolator for the difference D(z), preserving sign structure.\n        d_interp = PchipInterpolator(z_nodes, d_nodes)\n\n        # 2. Define the continuous buoyancy function B(z).\n        def buoyancy(z):\n            # Since T_ve is always positive, sign of B(z) depends only on D(z).\n            return G * d_interp(z) / tve_interp(z)\n\n        # 3. Find all integration breakpoints (original nodes + roots of D(z)).\n        breakpoints = set(z_nodes)\n        for i in range(len(z_nodes) - 1):\n            z_start, z_end = z_nodes[i], z_nodes[i+1]\n            d_start, d_end = d_nodes[i], d_nodes[i+1]\n\n            # A root exists between nodes if their signs are opposite.\n            if d_start * d_end  0:\n                try:\n                    # Brent's method is robust for finding a root in a bracketed interval.\n                    root = brentq(d_interp, z_start, z_end)\n                    breakpoints.add(root)\n                except ValueError:\n                    # This should not be reached if signs are truly opposite,\n                    # but included for robustness.\n                    pass\n        \n        sorted_breakpoints = sorted(list(breakpoints))\n\n        # 4. Integrate over subintervals of constant sign and accumulate CAPE/CIN.\n        cape = 0.0\n        cin = 0.0\n\n        for i in range(len(sorted_breakpoints) - 1):\n            z_a, z_b = sorted_breakpoints[i], sorted_breakpoints[i+1]\n            \n            # Avoid integrating over zero-width intervals if duplicates exist\n            if z_a >= z_b:\n                continue\n            \n            # Use adaptive quadrature for high accuracy.\n            # Suppress integration warnings which may occur in complex cases\n            # but are handled by the robust algorithm.\n            with warnings.catch_warnings():\n                warnings.filterwarnings('ignore', category=UserWarning)\n                integral, _ = quad(buoyancy, z_a, z_b, limit=100)\n\n            # Accumulate based on the sign of the integral.\n            if integral > 0:\n                cape += integral\n            else:\n                # CIN = - integral(min(B,0) dz), so we add the absolute value\n                # of the negative integral.\n                cin -= integral\n        \n        # 5. Round to one decimal place as required.\n        return round(cape, 1), round(cin, 1)\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A\n        (\n            [0, 500, 1000, 1500, 2000, 3000],\n            [300.0, 296.0, 292.0, 288.5, 285.0, 281.0],\n            [300.0, 295.5, 292.5, 290.5, 289.0, 280.0]\n        ),\n        # Case B\n        (\n            [0, 200, 800, 1500, 2200],\n            [302.0, 300.5, 296.0, 292.0, 288.0],\n            [302.0, 300.5, 296.5, 294.0, 287.0]\n        ),\n        # Case C\n        (\n            [0, 1000, 1200, 2000, 4000],\n            [305.0, 297.0, 296.8, 294.0, 289.0],\n            [305.0, 296.0, 296.7, 295.0, 292.0]\n        )\n    ]\n\n    results = []\n    for z, tve, tvp in test_cases:\n        cape, cin = calculate_cape_cin(z, tve, tvp)\n        results.extend([cape, cin])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}