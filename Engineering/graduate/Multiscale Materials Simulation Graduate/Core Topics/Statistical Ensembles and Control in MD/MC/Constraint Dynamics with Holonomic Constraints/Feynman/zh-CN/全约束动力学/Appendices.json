{
    "hands_on_practices": [
        {
            "introduction": "在分子动力学模拟中，直接强制执行完整约束的一种基本方法是在每个无约束积分步骤后校正粒子位置。SHAKE算法是实现这一目标的经典且高效的方法，它利用拉格朗日乘子原理来最小化质量加权的位移。本练习将引导你从第一性原理出发，为一个简单的双原子系统推导并实现单步SHAKE校正，从而掌握约束动力学的核心计算步骤 。",
            "id": "3797892",
            "problem": "考虑一个嵌入在更大尺度多尺度材料模拟中的双粒子子系统。该子系统由两个点质量组成，其质量分别为 $m_1$ 和 $m_2$，它们的试验位置 $r_1^{\\mathrm{t}} \\in \\mathbb{R}^3$ 和 $r_2^{\\mathrm{t}} \\in \\mathbb{R}^3$ 是由一个无约束积分器步骤产生的。一个完整约束（holonomic constraint）强制两个粒子之间保持固定的键长，由约束函数 $g(r_1, r_2) = \\|r_2 - r_1\\|^2 - d_0^2 = 0$ 表示，其中 $d_0$ 是预设的键长。在 SHAKE 算法的单一步骤中，通过施加位置校正来获得校正后的位置 $r_1$ 和 $r_2$。这些校正强制执行约束，同时最小化一个根据约束动力学原理推导出的质量加权位移度量。\n\n从基本定律和核心定义——牛顿定律、完整约束、虚功原理和拉格朗日乘子——出发，推导与位置层面约束执行相关的标量乘子更新 $\\mu$ 的表达式，并计算校正后的位置 $r_1$ 和 $r_2$，使其在试验位置处以线性化方式满足约束。您的推导不得假定任何快捷公式；它必须依赖于适用于约束动力学和完整约束的第一性原理。您必须实现一个程序，在给定 $m_1$、$m_2$、$r_1^{\\mathrm{t}}$、$r_2^{\\mathrm{t}}$ 和 $d_0$ 的情况下，基于 $g$ 在试验位置的一阶线性化，计算单个 SHAKE 校正步骤的 $\\mu$ 以及校正后的位置 $r_1$ 和 $r_2$。\n\n科学真实性与单位：\n- $m_1$ 和 $m_2$ 的单位是千克 (kg)。\n- $r_1^{\\mathrm{t}}$、$r_2^{\\mathrm{t}}$、$r_1$ 和 $r_2$ 的单位是米 (m)。\n- $d_0$ 的单位是米 (m)。\n- 乘子更新 $\\mu$ 必须以千克 (kg) 为单位表示。\n\n角度单位不适用于此问题。所有计算出的数值答案必须是浮点数，并四舍五入到十二位有效数字。最终输出必须报告以千克为单位的 $\\mu$ 和以米为单位的所有位置分量。\n\n测试套件：\n实现程序以评估以下四个测试用例。在构建 $m_1$ 和 $m_2$ 时，请使用原子质量单位 $u = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$。\n\n1. 正常路径用例，碳氢键略长：\n   - $m_1 = 12u$, $m_2 = 1u$\n   - $d_0 = 1.09 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [0.0, 0.0, 0.0]\\,\\mathrm{m}$, $r_2^{\\mathrm{t}} = [1.14 \\times 10^{-10}, 0.0, 0.0]\\,\\mathrm{m}$\n\n2. 边界用例，试验位置已满足约束：\n   - $m_1 = 12u$, $m_2 = 1u$\n   - $d_0 = 1.09 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [2.0 \\times 10^{-10}, -1.0 \\times 10^{-10}, 0.5 \\times 10^{-10}]\\,\\mathrm{m}$\n   - $r_2^{\\mathrm{t}} = r_1^{\\mathrm{t}} + [1.09 \\times 10^{-10}, 0.0, 0.0]\\,\\mathrm{m}$\n\n3. 边缘用例，对角线方向，氧氢质量，键略短：\n   - $m_1 = 16u$, $m_2 = 1u$\n   - $d_0 = 0.97 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [0.0, 0.0, 0.0]\\,\\mathrm{m}$\n   - $r_2^{\\mathrm{t}} = \\frac{0.95 \\times 10^{-10}}{\\sqrt{3}} [1, 1, 1]\\,\\mathrm{m}$\n\n4. 近边界用例，质量相等，有微小违反：\n   - $m_1 = 12u$, $m_2 = 12u$\n   - $d_0 = 1.0 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [0.0, 0.0, 0.0]\\,\\mathrm{m}$\n   - $r_2^{\\mathrm{t}} = [1.0000005 \\times 10^{-10}, 0.0, 0.0]\\,\\mathrm{m}$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个形如 $[\\mu, r_{1x}, r_{1y}, r_{1z}, r_{2x}, r_{2y}, r_{2z}]$ 的列表，每个浮点数都四舍五入到十二位有效数字。例如，包含四个测试用例结果的一行应如下所示：\n\"[[\\mu_1,r_{1x}^{(1)},r_{1y}^{(1)},r_{1z}^{(1)},r_{2x}^{(1)},r_{2y}^{(1)},r_{2z}^{(1)}],[\\mu_2,\\dots],[\\mu_3,\\dots],[\\mu_4,\\dots]]\"。\n\n您的实现必须是自包含的，不需要用户输入，并且必须如前所述，基于第一性原理，使用单个 SHAKE 线性化校正步骤来计算以千克为单位的标量 $\\mu$ 和以米为单位的校正后位置。",
            "solution": "SHAKE 校正步骤的推导基于约束动力学原理，具体而言，是在一组完整约束条件下，最小化与无约束轨迹的偏差。对于给定的双粒子系统，我们寻求找到校正后的位置 $r_1$ 和 $r_2$，使其满足距离约束 $g(r_1, r_2) = 0$，同时在质量加权的意义上，与试验位置 $r_1^{\\mathrm t}$ 和 $r_2^{\\mathrm t}$ 的位移最小。\n\n目标是最小化函数 $S$：\n$$S(r_1, r_2) = \\frac{1}{2} m_1 \\|r_1 - r_1^{\\mathrm t}\\|^2 + \\frac{1}{2} m_2 \\|r_2 - r_2^{\\mathrm t}\\|^2$$\n该函数表示与试验位置的质量加权位移平方和。最小化受制于固定键长 $d_0$ 的完整约束：\n$$g(r_1, r_2) = \\|r_2 - r_1\\|^2 - d_0^2 = 0$$\n\n这个约束优化问题使用拉格朗日乘子法求解。我们定义一个拉格朗日函数 $\\mathcal{L}$，它包含目标函数 $S$ 和约束 $g$，并带有一个标量拉格朗日乘子，问题中将其表示为 $\\mu$。$\\mu$ 的单位被指定为千克 ($\\mathrm{kg}$)，这为拉格朗日函数的结构提供了信息。\n$$\\mathcal{L}(r_1, r_2, \\mu) = S(r_1, r_2) - \\mu g(r_1, r_2)$$\n$$\\mathcal{L}(r_1, r_2, \\mu) = \\left( \\frac{1}{2} m_1 \\|r_1 - r_1^{\\mathrm t}\\|^2 + \\frac{1}{2} m_2 \\|r_2 - r_2^{\\mathrm t}\\|^2 \\right) - \\mu \\left( \\|r_2 - r_1\\|^2 - d_0^2 \\right)$$\n在最小值处，$\\mathcal{L}$ 相对于每个位置向量的梯度必须为零。\n$$\\nabla_{r_1} \\mathcal{L} = m_1 (r_1 - r_1^{\\mathrm t}) - \\mu \\nabla_{r_1} g = 0$$\n$$\\nabla_{r_2} \\mathcal{L} = m_2 (r_2 - r_2^{\\mathrm t}) - \\mu \\nabla_{r_2} g = 0$$\n这些方程给出了位置校正 $\\delta r_i = r_i - r_i^{\\mathrm t}$ 的形式：\n$$\\delta r_1 = r_1 - r_1^{\\mathrm t} = \\frac{\\mu}{m_1} \\nabla_{r_1} g$$\n$$\\delta r_2 = r_2 - r_2^{\\mathrm t} = \\frac{\\mu}{m_2} \\nabla_{r_2} g$$\n让我们计算约束函数 $g$ 的梯度。设粒子间向量为 $d = r_2 - r_1$。那么 $g(d) = d \\cdot d - d_0^2$。\n$$\\nabla_{r_1} g = \\nabla_{r_1} ((r_2 - r_1) \\cdot (r_2 - r_1)) = -2(r_2 - r_1)$$\n$$\\nabla_{r_2} g = \\nabla_{r_2} ((r_2 - r_1) \\cdot (r_2 - r_1)) = 2(r_2 - r_1)$$\n\n问题要求基于约束函数 $g$ 在试验位置 $r_1^{\\mathrm t}$ 和 $r_2^{\\mathrm t}$ 处的线性化进行单步校正。我们将 $g(r_1, r_2)$ 在试验位置附近展开为泰勒级数，并保留到一阶项：\n$$g(r_1, r_2) \\approx g(r_1^{\\mathrm t}, r_2^{\\mathrm t}) + (r_1 - r_1^{\\mathrm t}) \\cdot \\nabla_{r_1} g(r_1^{\\mathrm t}, r_2^{\\mathrm t}) + (r_2 - r_2^{\\mathrm t}) \\cdot \\nabla_{r_2} g(r_1^{\\mathrm t}, r_2^{\\mathrm t}) = 0$$\n我们使用简写符号 $g^{\\mathrm t} = g(r_1^{\\mathrm t}, r_2^{\\mathrm t})$ 和 $\\nabla_{r_i} g^{\\mathrm t} = \\nabla_{r_i} g(r_1^{\\mathrm t}, r_2^{\\mathrm t})$。线性化的约束是：\n$$g^{\\mathrm t} + \\delta r_1 \\cdot \\nabla_{r_1} g^{\\mathrm t} + \\delta r_2 \\cdot \\nabla_{r_2} g^{\\mathrm t} = 0$$\n现在，代入校正量 $\\delta r_1$ 和 $\\delta r_2$ 的表达式：\n$$g^{\\mathrm t} + \\left(\\frac{\\mu}{m_1} \\nabla_{r_1} g^{\\mathrm t}\\right) \\cdot \\nabla_{r_1} g^{\\mathrm t} + \\left(\\frac{\\mu}{m_2} \\nabla_{r_2} g^{\\mathrm t}\\right) \\cdot \\nabla_{r_2} g^{\\mathrm t} = 0$$\n将 $\\mu$ 提取出来，我们得到：\n$$g^{\\mathrm t} + \\mu \\left( \\frac{1}{m_1} \\|\\nabla_{r_1} g^{\\mathrm t}\\|^2 + \\frac{1}{m_2} \\|\\nabla_{r_2} g^{\\mathrm t}\\|^2 \\right) = 0$$\n求解拉格朗日乘子 $\\mu$：\n$$\\mu = - \\frac{g^{\\mathrm t}}{\\frac{1}{m_1} \\|\\nabla_{r_1} g^{\\mathrm t}\\|^2 + \\frac{1}{m_2} \\|\\nabla_{r_2} g^{\\mathrm t}\\|^2}$$\n设试验分离向量为 $d^{\\mathrm t} = r_2^{\\mathrm t} - r_1^{\\mathrm t}$。所需的项是：\n$$g^{\\mathrm t} = \\|d^{\\mathrm t}\\|^2 - d_0^2$$\n$$\\nabla_{r_1} g^{\\mathrm t} = -2d^{\\mathrm t}$$\n$$\\nabla_{r_2} g^{\\mathrm t} = 2d^{\\mathrm t}$$\n将这些代入 $\\mu$ 的表达式中：\n$$\\|\\nabla_{r_1} g^{\\mathrm t}\\|^2 = \\|-2d^{\\mathrm t}\\|^2 = 4\\|d^{\\mathrm t}\\|^2$$\n$$\\|\\nabla_{r_2} g^{\\mathrm t}\\|^2 = \\|2d^{\\mathrm t}\\|^2 = 4\\|d^{\\mathrm t}\\|^2$$\n$\\mu$ 表达式的分母变成一个标量：\n$$\\frac{1}{m_1} (4\\|d^{\\mathrm t}\\|^2) + \\frac{1}{m_2} (4\\|d^{\\mathrm t}\\|^2) = 4 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) \\|d^{\\mathrm t}\\|^2$$\n因此，拉格朗日乘子 $\\mu$ 的最终表达式是：\n$$\\mu = - \\frac{\\|r_2^{\\mathrm t} - r_1^{\\mathrm t}\\|^2 - d_0^2}{4 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) \\|r_2^{\\mathrm t} - r_1^{\\mathrm t}\\|^2}$$\n量纲一致性检查如下：分子单位为 $\\mathrm{m}^2$，分母单位为 $(\\mathrm{kg}^{-1}) \\cdot \\mathrm{m}^2$。$\\mu$ 的最终单位是 $\\mathrm{kg}$，与问题陈述要求一致。\n\n一旦计算出 $\\mu$，就可以通过对试验位置施加校正来找到校正后的位置 $r_1$ 和 $r_2$。我们使用在试验位置处计算的梯度，这与线性化是一致的：\n$$r_1 = r_1^{\\mathrm t} + \\frac{\\mu}{m_1} \\nabla_{r_1} g^{\\mathrm t} = r_1^{\\mathrm t} - \\frac{2\\mu}{m_1}(r_2^{\\mathrm t} - r_1^{\\mathrm t})$$\n$$r_2 = r_2^{\\mathrm t} + \\frac{\\mu}{m_2} \\nabla_{r_2} g^{\\mathrm t} = r_2^{\\mathrm t} + \\frac{2\\mu}{m_2}(r_2^{\\mathrm t} - r_1^{\\mathrm t})$$\n这些方程提供了一个线性化 SHAKE 校正步骤的完整算法。步骤如下：\n1. 给定 $m_1$、$m_2$、$r_1^{\\mathrm t}$、$r_2^{\\mathrm t}$ 和 $d_0$。\n2. 计算试验分离向量 $d^{\\mathrm t} = r_2^{\\mathrm t} - r_1^{\\mathrm t}$ 及其模的平方 $\\|d^{\\mathrm t}\\|^2$。\n3. 计算试验位置处的约束违反量，$g^{\\mathrm t} = \\|d^{\\mathrm t}\\|^2 - d_0^2$。\n4. 如果 $g^{\\mathrm t}$ 为零（在容差范围内），则无需校正，因此 $\\mu=0$ 且 $r_i = r_i^{\\mathrm t}$。\n5. 否则，使用其推导出的表达式计算 $\\mu$。\n6. 使用其推导出的表达式计算最终的校正后位置 $r_1$ 和 $r_2$。\n这完全指定了要实现的计算过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Lagrange multiplier mu and corrected positions for a two-particle\n    system using a single linearized SHAKE correction step.\n    \"\"\"\n    # Universal constant\n    u = 1.66053906660e-27  # Atomic mass unit in kg\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"m1_u\": 12.0, \"m2_u\": 1.0, \"d0\": 1.09e-10,\n            \"r1_t\": np.array([0.0, 0.0, 0.0]),\n            \"r2_t\": np.array([1.14e-10, 0.0, 0.0])\n        },\n        {\n            \"m1_u\": 12.0, \"m2_u\": 1.0, \"d0\": 1.09e-10,\n            \"r1_t\": np.array([2.0e-10, -1.0e-10, 0.5e-10]),\n            \"r2_t\": np.array([2.0e-10 + 1.09e-10, -1.0e-10, 0.5e-10])\n        },\n        {\n            \"m1_u\": 16.0, \"m2_u\": 1.0, \"d0\": 0.97e-10,\n            \"r1_t\": np.array([0.0, 0.0, 0.0]),\n            \"r2_t\": (0.95e-10 / np.sqrt(3)) * np.array([1.0, 1.0, 1.0])\n        },\n        {\n            \"m1_u\": 12.0, \"m2_u\": 12.0, \"d0\": 1.0e-10,\n            \"r1_t\": np.array([0.0, 0.0, 0.0]),\n            \"r2_t\": np.array([1.0000005e-10, 0.0, 0.0])\n        }\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        m1 = case[\"m1_u\"] * u\n        m2 = case[\"m2_u\"] * u\n        d0 = case[\"d0\"]\n        r1_t = case[\"r1_t\"]\n        r2_t = case[\"r2_t\"]\n\n        # Calculate the trial separation vector and its squared magnitude\n        d_t = r2_t - r1_t\n        d_t_sq = np.dot(d_t, d_t)\n\n        # Calculate the constraint violation at the trial position\n        g_t = d_t_sq - d0**2\n\n        # If the trial distance is zero, gradient is undefined.\n        # Physically, r1_t should not equal r2_t. In this case, mu would be zero.\n        if d_t_sq == 0.0:\n            mu = 0.0\n        else:\n            # Calculate the Lagrange multiplier mu\n            mu_denom = 4.0 * (1.0/m1 + 1.0/m2) * d_t_sq\n            mu = -g_t / mu_denom\n\n        # Calculate the corrected positions\n        r1 = r1_t - (2.0 * mu / m1) * d_t\n        r2 = r2_t + (2.0 * mu / m2) * d_t\n\n        # Collect results for this test case\n        current_result = [mu, r1[0], r1[1], r1[2], r2[0], r2[1], r2[2]]\n\n        # Format results to 12 significant digits and prepare string for final output\n        current_result_str = \",\".join([\"{:.12g}\".format(v) for v in current_result])\n        all_results_str.append(f\"[{current_result_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在SHAKE算法的基础上，我们需要确保约束在速度层面也得到满足，以构建一个完整且时间可逆的积分器。RATTLE算法通过将SHAKE的位置校正与相应的速度校正相结合，确保系统在构型空间和相空间中都保持在约束流形上。通过完成本练习，你将实现一个完整的RATTLE积分步骤，从而更深入地理解如何在动力学演化过程中精确维持完整约束 。",
            "id": "3797876",
            "problem": "考虑一个双原子分子，建模为两个质点，其位置为 $r_1 \\in \\mathbb{R}^3$ 和 $r_2 \\in \\mathbb{R}^3$，速度为 $v_1 \\in \\mathbb{R}^3$ 和 $v_2 \\in \\mathbb{R}^3$，质量为 $m_1 > 0$ 和 $m_2 > 0$，受到的外力为 $F_1 \\in \\mathbb{R}^3$ 和 $F_2 \\in \\mathbb{R}^3$。设该系统受单个完整约束，该约束强制一个固定的键长 $d_0 > 0$，由约束函数 $g(q) = \\lVert r_2 - r_1 \\rVert^2 - d_0^2 = 0$ 给出，其中 $q = (r_1, r_2) \\in \\mathbb{R}^6$ 且 $\\lVert \\cdot \\rVert$ 表示欧几里得范数。相关的速度层级约束要求在所有时刻 $\\frac{d}{dt}g(q(t)) = \\nabla g(q(t)) \\cdot \\dot{q}(t) = 0$，其中 $\\dot{q} = (v_1, v_2)$ 且 $\\nabla g$ 是 $g$ 关于 $q$ 的梯度。\n\n从时间 $t^n$ 的已知状态 $(q^n, v^n)$ 和有限时间步长 $h > 0$ 开始，实现一个时间可逆约束积分器（RATTLE 算法）的一个步骤，该步骤：\n- 使用半步速度更新和位置更新来推进位置，\n- 校正位置以满足完整约束 $g(q^{n+1}) = 0$，\n- 将速度推进至完整步长，\n- 校正速度以满足速度约束 $\\nabla g(q^{n+1}) \\cdot v^{n+1} = 0$。\n\n在您的推导和实现中，请使用以下基本原理：牛顿第二运动定律、完整约束的定义、质量矩阵表示法以及用于施加约束的拉格朗日乘子。您不得在问题陈述中假设或使用任何预先推导的特定于约束的校正公式；所有必要的关系式必须在解答中推导出来。\n\n输入为三个测试用例，指定 $m_1$、$m_2$、$r_1^n$、$r_2^n$、$v_1^n$、$v_2^n$、$F_1^n$、$F_2^n$、$d_0$ 和 $h$，所有单位均为国际单位制 (SI)。质量必须以千克为单位，位置以米为单位，速度以米每秒为单位，力以牛顿为单位，时间以秒为单位。程序必须计算一个步骤后满足速度约束的校正后速度 $\\dot{q}^{n+1} = (v_1^{n+1}, v_2^{n+1})$。为了验证和统一输出，您的程序应针对每个测试用例，将标量速度约束残差的绝对值 $\\left|\\nabla g(q^{n+1}) \\cdot \\dot{q}^{n+1}\\right|$ 报告为一个以平方米每秒为单位的浮点数，并由默认的浮点表示法进行舍入。\n\n测试套件：\n- 案例1（正常路径，质量相等，存在径向违例）：\n  - $m_1 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$，$m_2 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$，\n  - $r_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{m}$，$r_2^n = (1.5 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{m}$，\n  - $v_1^n = (200.0, 0.0, 0.0)\\,\\mathrm{m/s}$，$v_2^n = (-200.0, 0.0, 0.0)\\,\\mathrm{m/s}$，\n  - $F_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{N}$，$F_2^n = (0.0, 0.0, 0.0)\\,\\mathrm{N}$，\n  - $d_0 = 1.5 \\times 10^{-10}\\,\\mathrm{m}$，$h = 5.0 \\times 10^{-16}\\,\\mathrm{s}$。\n- 案例2（质量不等，横向速度，外力引入径向分量）：\n  - $m_1 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$，$m_2 = 1.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$，\n  - $r_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{m}$，$r_2^n = (1.0 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{m}$，\n  - $v_1^n = (0.0, 1000.0, 0.0)\\,\\mathrm{m/s}$，$v_2^n = (0.0, -500.0, 0.0)\\,\\mathrm{m/s}$，\n  - $F_1^n = (1.0 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{N}$，$F_2^n = (-1.0 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{N}$，\n  - $d_0 = 1.0 \\times 10^{-10}\\,\\mathrm{m}$，$h = 1.0 \\times 10^{-15}\\,\\mathrm{s}$。\n- 案例3（边界情况，极小时间步长，混合速度分量）：\n  - $m_1 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$，$m_2 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$，\n  - $r_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{m}$，$r_2^n = (1.2 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{m}$，\n  - $v_1^n = (1000.0, 2000.0, 0.0)\\,\\mathrm{m/s}$，$v_2^n = (-1000.0, -2000.0, 0.0)\\,\\mathrm{m/s}$，\n  - $F_1^n = (5.0 \\times 10^{-11}, -1.0 \\times 10^{-10}, 0.0)\\,\\mathrm{N}$，$F_2^n = (-5.0 \\times 10^{-11}, 1.0 \\times 10^{-10}, 0.0)\\,\\mathrm{N}$，\n  - $d_0 = 1.2 \\times 10^{-10}\\,\\mathrm{m}$，$h = 1.0 \\times 10^{-18}\\,\\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与所提供的测试用例一致。例如，最终输出格式必须与 $[r_1,r_2,r_3]$ 完全一样，其中每个 $r_i$ 是以 $\\mathrm{m}^2/\\mathrm{s}$ 表示的标量速度约束残差的绝对值 $\\left|\\nabla g(q^{n+1}) \\cdot \\dot{q}^{n+1}\\right|$。",
            "solution": "用户提供的问题陈述已经过验证，并被认为是有效的。它具有科学依据、是适定且客观的。该问题描述了分子动力学模拟中的一个标准场景，并要求实现一种用于处理完整约束的成熟算法 RATTLE。所有必要的数据和条件均已提供。\n\n该问题要求针对双原子分子推导并实现 RATTLE 算法的单步过程。该算法是一种为带完整约束的哈密顿系统设计的时间可逆几何积分器。它建立在速度 Verlet 积分方案之上。我们将根据要求从第一性原理推导必要的方程。\n\n设广义坐标为 $q = (r_1, r_2) \\in \\mathbb{R}^6$，速度为 $\\dot{q} = v = (v_1, v_2) \\in \\mathbb{R}^6$。两个粒子的质量为 $m_1$ 和 $m_2$，外力为 $F_1$ 和 $F_2$，集合在一个广义力矢量 $F = (F_1, F_2)$ 中。质量矩阵 $M$ 是一个 $6 \\times 6$ 的对角矩阵，其对角线上的元素为 $(m_1, m_1, m_1, m_2, m_2, m_2)$。\n\n系统的动力学由牛顿第二定律决定，经过修改以包含约束力，该约束力由一个拉格朗日乘子 $\\lambda$ 导出：\n$$ M \\ddot{q} = F - (\\nabla_q g)^T \\lambda $$\n完整约束由 $g(q) = \\lVert r_2 - r_1 \\rVert^2 - d_0^2 = 0$ 给出。该约束函数关于广义坐标 $q$ 的梯度是：\n$$ \\nabla_q g = \\left( \\frac{\\partial g}{\\partial r_1}, \\frac{\\partial g}{\\partial r_2} \\right) = (-2(r_2 - r_1), 2(r_2 - r_1)) $$\nRATTLE 算法以大小为 $h > 0$ 的离散时间步进行，将系统从时间 $t^n$ 的状态 $(q^n, v^n)$ 推进到时间 $t^{n+1} = t^n + h$ 的状态 $(q^{n+1}, v^{n+1})$。初始和最终状态都必须分别满足位置约束 $g(q) = 0$ 和速度约束 $\\nabla_q g(q) \\cdot v = 0$。\n\n推导遵循问题陈述中概述的步骤。\n\n**步骤1：无约束位置预测器**\n此步骤是标准的速度 Verlet 更新。首先，我们通过施加半个时间步长的外力，计算出时间 $t^n + h/2$ 的中间速度。\n$$ v^{n+1/2, p} = v^n + \\frac{h}{2} M^{-1} F^n $$\n用粒子速度和力表示：\n$$ v_{1}^{n+1/2, p} = v_1^n + \\frac{h}{2m_1} F_1^n $$\n$$ v_{2}^{n+1/2, p} = v_2^n + \\frac{h}{2m_2} F_2^n $$\n接下来，我们使用这个半步速度来计算完整时间步长 $h$ 的临时位置更新：\n$$ q^{n+1, p} = q^n + h v^{n+1/2, p} $$\n用粒子位置表示：\n$$ r_{1}^{n+1, p} = r_1^n + h v_{1}^{n+1/2, p} $$\n$$ r_{2}^{n+1, p} = r_2^n + h v_{2}^{n+1/2, p} $$\n得到的位置 $q^{n+1, p}$ 是临时的（预测器 'p' 步骤），通常不满足约束 $g(q^{n+1, p}) = 0$。\n\n**步骤2：位置校正 (SHAKE)**\n目标是找到一个校正后的位置 $q^{n+1}$，它接近于预测位置 $q^{n+1, p}$ 并满足约束 $g(q^{n+1}) = 0$。校正是通过增加一个与 $M^{-1} (\\nabla_q g)^T$ 成比例的位移来执行的，该位移代表由约束力引起运动的方向。对于单个双原子约束，这可以解析求解。\n设校正量为 $\\delta q = q^{n+1} - q^{n+1,p} = (\\delta r_1, \\delta r_2)$。校正量是由约束力引起的，因此 $\\delta r_i \\propto \\frac{1}{m_i} \\nabla_{r_i} g$。\n$$ \\delta r_1 = \\gamma \\frac{1}{m_1} (-2(r_2^{n+1,p} - r_1^{n+1,p})) $$\n$$ \\delta r_2 = \\gamma \\frac{1}{m_2} (2(r_2^{n+1,p} - r_1^{n+1,p})) $$\n其中 $\\gamma$ 是一个待定的标量乘子。设 $r_{21}^p = r_2^{n+1,p} - r_1^{n+1,p}$。新的分离矢量为 $r_{21}^{n+1} = r_{21}^p + \\delta r_2 - \\delta r_1$。\n$$ r_{21}^{n+1} = r_{21}^p + 2\\gamma \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right) r_{21}^p = \\left(1 + 2\\gamma \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)\\right) r_{21}^p $$\n约束为 $\\lVert r_{21}^{n+1} \\rVert^2 = d_0^2$。取范数并解出括号中的项，得到：\n$$ \\left|1 + 2\\gamma \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)\\right| = \\frac{d_0}{\\lVert r_{21}^p \\rVert} $$\n假设校正量很小，我们取正根。设 $S = \\frac{d_0}{\\lVert r_{21}^p \\rVert} - 1$。则 $2\\gamma(\\frac{1}{m_1} + \\frac{1}{m_2}) = S$。我们现在可以找到各个校正量：\n$$ \\delta r_1 = -\\frac{S}{1/m_1 + 1/m_2} \\frac{1}{m_1} r_{21}^p = -\\frac{m_2}{m_1+m_2} S r_{21}^p $$\n$$ \\delta r_2 = \\frac{S}{1/m_1 + 1/m_2} \\frac{1}{m_2} r_{21}^p = \\frac{m_1}{m_1+m_2} S r_{21}^p $$\n校正后的位置是 $q^{n+1} = q^{n+1,p} + \\delta q$，或者：\n$$ r_1^{n+1} = r_1^{n+1, p} - \\frac{m_2}{m_1+m_2} S r_{21}^p $$\n$$ r_2^{n+1} = r_2^{n+1, p} + \\frac{m_1}{m_1+m_2} S r_{21}^p $$\n\n**步骤3：无约束速度预测器**\nRATTLE 算法定义了一个与校正后位置一致的校正半步速度 $v^{n+1/2}$：\n$$ v^{n+1/2} = \\frac{q^{n+1} - q^n}{h} $$\n然后将速度 Verlet “踢”的后半部分应用于此校正的半步速度，以获得时间 $t^{n+1}$ 的临时速度：\n$$ v^{n+1, p} = v^{n+1/2} + \\frac{h}{2} M^{-1} F^n = \\frac{q^{n+1} - q^n}{h} + \\frac{h}{2} M^{-1} F^n $$\n以分量形式表示：\n$$ v_{1}^{n+1, p} = \\frac{r_1^{n+1} - r_1^n}{h} + \\frac{h}{2m_1} F_1^n $$\n$$ v_{2}^{n+1, p} = \\frac{r_2^{n+1} - r_2^n}{h} + \\frac{h}{2m_2} F_2^n $$\n这个临时速度 $v^{n+1, p}$ 尚未满足速度约束。\n\n**步骤4：速度校正 (RATTLE)**\n我们必须找到一个最终速度 $v^{n+1}$，使其满足速度约束 $\\nabla_q g(q^{n+1}) \\cdot v^{n+1} = 0$。校正是在新位置 $q^{n+1}$ 处沿约束梯度方向施加的：\n$$ v^{n+1} = v^{n+1, p} - M^{-1} (\\nabla_q g(q^{n+1}))^T \\lambda_v $$\n这里 $\\lambda_v$ 是用于速度校正的标量拉格朗日乘子。我们将此代入速度约束方程以求得 $\\lambda_v$：\n$$ \\nabla_q g(q^{n+1}) \\cdot \\left( v^{n+1, p} - M^{-1} (\\nabla_q g(q^{n+1}))^T \\lambda_v \\right) = 0 $$\n$$ \\nabla_q g(q^{n+1}) \\cdot v^{n+1, p} - \\lambda_v \\left( \\nabla_q g(q^{n+1}) M^{-1} (\\nabla_q g(q^{n+1}))^T \\right) = 0 $$\n解出 $\\lambda_v$：\n$$ \\lambda_v = \\frac{\\nabla_q g(q^{n+1}) \\cdot v^{n+1, p}}{\\nabla_q g(q^{n+1}) M^{-1} (\\nabla_q g(q^{n+1}))^T} $$\n我们来计算分子和分母。设 $r_{21}^{n+1} = r_2^{n+1} - r_1^{n+1}$ 且 $v_{21}^{n+1,p} = v_2^{n+1,p} - v_1^{n+1,p}$。\n分子：\n$$ \\nabla_q g \\cdot v^{p} = (-2r_{21}^{n+1}) \\cdot v_1^{n+1,p} + (2r_{21}^{n+1}) \\cdot v_2^{n+1,p} = 2r_{21}^{n+1} \\cdot v_{21}^{n+1,p} $$\n分母：\n$$ \\nabla_q g M^{-1} (\\nabla_q g)^T = \\frac{1}{m_1} \\lVert -2r_{21}^{n+1} \\rVert^2 + \\frac{1}{m_2} \\lVert 2r_{21}^{n+1} \\rVert^2 = 4 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) \\lVert r_{21}^{n+1} \\rVert^2 $$\n由于 $q^{n+1}$ 满足位置约束，因此 $\\lVert r_{21}^{n+1} \\rVert^2 = d_0^2$。\n$$ \\lambda_v = \\frac{2r_{21}^{n+1} \\cdot v_{21}^{n+1,p}}{4d_0^2 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right)} = \\frac{r_{21}^{n+1} \\cdot v_{21}^{n+1,p}}{2d_0^2 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right)} $$\n最终校正后的速度是：\n$$ v_1^{n+1} = v_1^{n+1, p} - \\frac{1}{m_1}(-2r_{21}^{n+1})\\lambda_v = v_1^{n+1, p} + \\frac{2\\lambda_v}{m_1} r_{21}^{n+1} $$\n$$ v_2^{n+1} = v_2^{n+1, p} - \\frac{1}{m_2}(2r_{21}^{n+1})\\lambda_v = v_2^{n+1, p} - \\frac{2\\lambda_v}{m_2} r_{21}^{n+1} $$\n最终状态是 $(q^{n+1}, v^{n+1})$。问题要求报告残差 $|\\nabla_q g(q^{n+1}) \\cdot v^{n+1}|$，其值应在浮点精度范围内为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RATTLE integrator problem for the given test cases.\n    \"\"\"\n    amu_to_kg = 1.66053906660e-27\n\n    test_cases = [\n        {\n            \"m1\": 12.0 * amu_to_kg, \"m2\": 12.0 * amu_to_kg,\n            \"r1n\": np.array([0.0, 0.0, 0.0]), \"r2n\": np.array([1.5e-10, 0.0, 0.0]),\n            \"v1n\": np.array([200.0, 0.0, 0.0]), \"v2n\": np.array([-200.0, 0.0, 0.0]),\n            \"F1n\": np.array([0.0, 0.0, 0.0]), \"F2n\": np.array([0.0, 0.0, 0.0]),\n            \"d0\": 1.5e-10, \"h\": 5.0e-16\n        },\n        {\n            \"m1\": 12.0 * amu_to_kg, \"m2\": 1.0 * amu_to_kg,\n            \"r1n\": np.array([0.0, 0.0, 0.0]), \"r2n\": np.array([1.0e-10, 0.0, 0.0]),\n            \"v1n\": np.array([0.0, 1000.0, 0.0]), \"v2n\": np.array([0.0, -500.0, 0.0]),\n            \"F1n\": np.array([1.0e-10, 0.0, 0.0]), \"F2n\": np.array([-1.0e-10, 0.0, 0.0]),\n            \"d0\": 1.0e-10, \"h\": 1.0e-15\n        },\n        {\n            \"m1\": 12.0 * amu_to_kg, \"m2\": 12.0 * amu_to_kg,\n            \"r1n\": np.array([0.0, 0.0, 0.0]), \"r2n\": np.array([1.2e-10, 0.0, 0.0]),\n            \"v1n\": np.array([1000.0, 2000.0, 0.0]), \"v2n\": np.array([-1000.0, -2000.0, 0.0]),\n            \"F1n\": np.array([5.0e-11, -1.0e-10, 0.0]), \"F2n\": np.array([-5.0e-11, 1.0e-10, 0.0]),\n            \"d0\": 1.2e-10, \"h\": 1.0e-18\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2 = case[\"m1\"], case[\"m2\"]\n        r1n, r2n = case[\"r1n\"], case[\"r2n\"]\n        v1n, v2n = case[\"v1n\"], case[\"v2n\"]\n        F1n, F2n = case[\"F1n\"], case[\"F2n\"]\n        d0, h = case[\"d0\"], case[\"h\"]\n\n        # Step 1: Unconstrained position predictor (Half-kick, full-drift)\n        v1_half_p = v1n + (h / (2 * m1)) * F1n\n        v2_half_p = v2n + (h / (2 * m2)) * F2n\n        \n        r1_np1_p = r1n + h * v1_half_p\n        r2_np1_p = r2n + h * v2_half_p\n\n        # Step 2: Position correction (SHAKE)\n        r21_p = r2_np1_p - r1_np1_p\n        d_p = np.linalg.norm(r21_p)\n        \n        # S factor for correction\n        S = d0 / d_p - 1.0\n        \n        # Position correction displacements\n        dr1 = -(m2 / (m1 + m2)) * S * r21_p\n        dr2 = (m1 / (m1 + m2)) * S * r21_p\n        \n        # Corrected positions\n        r1_np1 = r1_np1_p + dr1\n        r2_np1 = r2_np1_p + dr2\n\n        # Step 3: Unconstrained velocity predictor\n        # Provisional velocities at t^{n+1}\n        v1_np1_p = (r1_np1 - r1n) / h + (h / (2 * m1)) * F1n\n        v2_np1_p = (r2_np1 - r2n) / h + (h / (2 * m2)) * F2n\n\n        # Step 4: Velocity correction (RATTLE)\n        r21_np1 = r2_np1 - r1_np1\n        v21_np1_p = v2_np1_p - v1_np1_p\n\n        # Lagrange multiplier for velocity correction\n        numerator_lambda_v = np.dot(r21_np1, v21_np1_p)\n        denominator_lambda_v = 2 * d0**2 * (1/m1 + 1/m2)\n        lambda_v = numerator_lambda_v / denominator_lambda_v\n\n        # Corrected velocities at t^{n+1}\n        v1_np1 = v1_np1_p + (2 * lambda_v / m1) * r21_np1\n        v2_np1 = v2_np1_p - (2 * lambda_v / m2) * r21_np1\n\n        # Final step: Calculate the velocity-constraint residual\n        # Residual = grad_g(q^{n+1}) . v^{n+1}\n        # grad_g_r1 = -2 * r21_np1, grad_g_r2 = 2 * r21_np1\n        # Residual = (-2 * r21_np1 . v1_np1) + (2 * r21_np1 . v2_np1)\n        #          = 2 * r21_np1 . (v2_np1 - v1_np1)\n        v21_np1 = v2_np1 - v1_np1\n        residual = 2 * np.dot(r21_np1, v21_np1)\n        \n        results.append(str(np.abs(residual)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与SHAKE和RATTLE等“硬”几何约束方法不同，我们也可以使用“软”约束，即通过罚函数势能来近似满足约束条件。罚函数法虽然实现简单，但会引入近似误差和高频振荡，从而严重限制模拟的时间步长。本练习将引导你分析这种权衡关系，计算满足精度要求所需的罚函数刚度及其对稳定性的影响，并将其与增广拉格朗日方法的优势进行对比 。",
            "id": "3797874",
            "problem": "考虑两个质点，其位置受到单个完整键长约束的限制。该完整约束要求两个质点之间的距离应保持等于一个预设的键长。在罚函数法中，通过向系统能量中增加一个二次罚函数项来强制执行该约束，该罚函数项会对偏离约束的情况进行惩罚。在增广拉格朗日方法中，拉格朗日乘子精确地强制执行约束（假设在每个时间步都进行精确投影），而罚函数项仅用于稳定和加速乘子更新的收敛。从第一性原理出发，推导在指定的最坏情况拉伸载荷下，为约束违背量设置上限所需的最小罚函数刚度，并分析增加的刚度如何影响显式时间积分的稳定性极限。假设运动沿着键的方向，并且与约束流形的偏差很小。\n\n您的推导必须从基本定律和核心定义开始，例如牛顿第二运动定律、完整约束的定义以及二次罚函数能量的表达式。在没有从这些基础上推导出来之前，您不得使用或假设任何关于罚函数刚度或时间步长限制的目标公式。将沿着键方向的相对坐标视为相关的标量约束坐标，并使用两体系统的约化质量来描述沿此坐标的有效动力学。假设外部载荷沿键方向作用，并且在所考虑的时间尺度上是恒定的。对于时间步长的限制，考虑将显式中心差分或速度Verlet格式应用于由罚函数项引起的刚性模态的线性化动力学，并包括系统中一个独立的最高物理频率的影响。\n\n对于下面的每个测试用例，计算并返回以下量：\n- 在指定的最坏情况拉伸载荷下，为确保绝对键长违背量保持在给定容差以下所需的最小罚函数刚度，单位为牛顿/米 ($\\mathrm{N}/\\mathrm{m}$)。\n- 使用罚函数法时的最大稳定显式时间步长，单位为秒 ($\\mathrm{s}$)，需考虑罚函数引起的高频和给定的最高物理频率，并取主导者。\n- 使用在每个时间步都进行精确约束投影的增广拉格朗日方法时的最大稳定显式时间步长，单位为秒 ($\\mathrm{s}$)（假设此方法从演化中移除了罚函数引起的刚性模态，因此稳定性极限仅由给定的最高物理频率决定）。\n\n必须遵守物理和数值单位：以 $\\mathrm{N}/\\mathrm{m}$ 表示罚函数刚度，以 $\\mathrm{s}$ 表示稳定时间步长。此问题不涉及角度。最终的程序输出必须是单行，包含一个逗号分隔的列表的列表，每个内部列表对应一个测试用例，并按上述顺序包含三个计算出的浮点数结果。例如，输出形式如 $[[\\dots],[\\dots],[\\dots]]$。\n\n使用以下测试套件，所有量均以国际单位制（SI）提供：\n\n- 测试用例 $1$ (正常情况):\n    - $m_1 = 1.0\\times 10^{-26}\\ \\mathrm{kg}$， $m_2 = 2.0\\times 10^{-26}\\ \\mathrm{kg}$，\n    - 键长 $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$，\n    - 沿键方向的最坏情况拉伸载荷 $F_{\\max} = 1.0\\times 10^{-9}\\ \\mathrm{N}$，\n    - 允许的绝对违背量 $\\varepsilon_{\\mathrm{tol}} = 1.0\\times 10^{-13}\\ \\mathrm{m}$，\n    - 最高物理频率 $\\omega_{\\mathrm{phys}} = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$。\n\n- 测试用例 $2$ (严格容差边界):\n    - $m_1 = 1.0\\times 10^{-26}\\ \\mathrm{kg}$， $m_2 = 2.0\\times 10^{-26}\\ \\mathrm{kg}$，\n    - $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$，\n    - $F_{\\max} = 1.0\\times 10^{-9}\\ \\mathrm{N}$，\n    - $\\varepsilon_{\\mathrm{tol}} = 1.0\\times 10^{-15}\\ \\mathrm{m}$，\n    - $\\omega_{\\mathrm{phys}} = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$。\n\n- 测试用例 $3$ (质量差异悬殊的边缘情况):\n    - $m_1 = 1.0\\times 10^{-25}\\ \\mathrm{kg}$， $m_2 = 1.0\\times 10^{-27}\\ \\mathrm{kg}$，\n    - $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$，\n    - $F_{\\max} = 5.0\\times 10^{-10}\\ \\mathrm{N}$，\n    - $\\varepsilon_{\\mathrm{tol}} = 5.0\\times 10^{-13}\\ \\mathrm{m}$，\n    - $\\omega_{\\mathrm{phys}} = 2.0\\times 10^{13}\\ \\mathrm{s}^{-1}$。\n\n- 测试用例 $4$ (高载荷情景):\n    - $m_1 = 1.0\\times 10^{-26}\\ \\mathrm{kg}$， $m_2 = 2.0\\times 10^{-26}\\ \\mathrm{kg}$，\n    - $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$，\n    - $F_{\\max} = 5.0\\times 10^{-9}\\ \\mathrm{N}$，\n    - $\\varepsilon_{\\mathrm{tol}} = 1.0\\times 10^{-12}\\ \\mathrm{m}$，\n    - $\\omega_{\\mathrm{phys}} = 1.0\\times 10^{12}\\ \\mathrm{s}^{-1}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素是包含三个浮点数的列表，顺序为：$[\\text{罚函数刚度 (单位 N/m)},\\ \\Delta t_{\\max}\\ \\text{使用罚函数法时 (单位 s)},\\ \\Delta t_{\\max}\\ \\text{使用增广拉格朗日法时 (单位 s)}]$。",
            "solution": "该问题被验证为具有科学依据、问题明确且客观。这是计算物理和分子模拟中的一个标准问题，所有必要的数据和约束都已明确定义。\n\n该系统由两个质点 $m_1$ 和 $m_2$ 组成，通过一个完整键长约束连接。我们关心的是沿相对坐标矢量 $\\vec{r} = \\vec{r}_2 - \\vec{r}_1$ 的动力学。问题陈述将分析简化为沿键方向的运动，允许我们使用一个标量相对坐标 $r = |\\vec{r}|$。这种相对运动的动力学可以使用系统的约化质量 $\\mu$ 来描述，其定义为：\n$$\n\\mu = \\frac{m_1 m_2}{m_1 + m_2}\n$$\n完整约束规定距离 $r$ 应等于一个预设的键长 $l_0$。因此，约束函数为 $g(r) = r - l_0 = 0$。\n\n### 第 1 部分：最小罚函数刚度 ($k_{\\text{min}}$)\n\n罚函数法通过向系统中添加一个势能项来近似地强制执行约束，该势能项对偏离约束流形的情况进行惩罚。对于给定的键长约束，使用二次罚函数势 $V_{\\text{penalty}}$：\n$$\nV_{\\text{penalty}}(r) = \\frac{1}{2} k (r - l_0)^2\n$$\n其中 $k$ 是罚函数刚度，是我们需要确定的一个参数。\n\n由该罚函数势产生的、沿相对坐标 $r$ 作用的力，由 $V_{\\text{penalty}}$ 相对于 $r$ 的负梯度给出：\n$$\nF_{\\text{penalty}} = - \\frac{\\partial V_{\\text{penalty}}}{\\partial r} = - \\frac{\\partial}{\\partial r} \\left( \\frac{1}{2} k (r - l_0)^2 \\right) = -k(r - l_0)\n$$\n令键长违背量为 $\\varepsilon = r - l_0$。罚函数力可以表示为 $F_{\\text{penalty}} = -k\\varepsilon$，这是一个类似于胡克定律的线性恢复力。\n\n问题要求我们找到最小刚度 $k_{\\text{min}}$，它能够抵消最坏情况下的拉伸载荷 $F_{\\max}$，同时确保绝对违背量 $|\\varepsilon|$ 不超过指定的容差 $\\varepsilon_{\\text{tol}}$。在载荷 $F_{\\max}$ 的准静态施加下，系统达到平衡，此时内部罚函数力与外部载荷相平衡：\n$$\n|F_{\\text{penalty}}| = F_{\\max}\n$$\n代入罚函数力的表达式，我们得到：\n$$\n| -k \\varepsilon | = k |\\varepsilon| = F_{\\max}\n$$\n这给出了最大载荷下的违背量为 $|\\varepsilon| = F_{\\max} / k$。为满足容差要求，我们必须有：\n$$\n|\\varepsilon| \\le \\varepsilon_{\\text{tol}}\n$$\n代入 $|\\varepsilon|$ 的表达式：\n$$\n\\frac{F_{\\max}}{k} \\le \\varepsilon_{\\text{tol}}\n$$\n为确保这个不等式成立，刚度 $k$ 必须足够大。通过将违背量设置为其最大允许值，可以找到所需的最小刚度 $k_{\\text{min}}$：\n$$\nk_{\\text{min}} = \\frac{F_{\\max}}{\\varepsilon_{\\text{tol}}}\n$$\n这是要计算的第一个量。\n\n### 第 2 部分：使用罚函数法时的最大稳定时间步长 ($\\Delta t_{\\text{max, penalty}}$)\n\n在罚函数力和其他物理力 $F_{\\text{phys}}$ 的影响下，相对坐标 $r$ 的运动方程由约化质量的牛顿第二定律给出：\n$$\n\\mu \\ddot{r} = F_{\\text{phys}} + F_{\\text{penalty}} = F_{\\text{phys}} - k(r-l_0)\n$$\n项 $-k(r-l_0)$ 在系统动力学中引入了一个刚性谐振子。为了分析时间步长的稳定性，我们通过忽略通常变化较慢的 $F_{\\text{phys}}$ 来考虑此刚性模态的线性化动力学。令 $\\delta r = r-l_0$ 为偏离平衡长度的量，我们有 $\\ddot{\\delta r} = \\ddot{r}$，刚性模态的方程变为：\n$$\n\\mu \\ddot{\\delta r} + k \\delta r = 0 \\quad \\implies \\quad \\ddot{\\delta r} + \\left(\\frac{k}{\\mu}\\right) \\delta r = 0\n$$\n这是简谐振子的典型方程 $\\ddot{x} + \\omega^2 x = 0$，其角频率 $\\omega_{\\text{penalty}}$ 由下式给出：\n$$\n\\omega_{\\text{penalty}} = \\sqrt{\\frac{k}{\\mu}}\n$$\n对于诸如速度Verlet或中心差分等稳定的显式时间积分格式，时间步长 $\\Delta t$ 必须足够小，以解析系统中最快的振荡。稳定性极限由 $\\omega_{\\max} \\Delta t \\le C$ 给出，其中 $\\omega_{\\max}$ 是系统中的最高频率，$C$ 是一个常数，通常为 $2$。因此，最大稳定时间步长为 $\\Delta t_{\\max} \\approx 2/\\omega_{\\max}$。\n\n系统有两个高频运动的来源：一是罚函数力，其频率为 $\\omega_{\\text{penalty}}$；二是由给定的最高物理频率 $\\omega_{\\text{phys}}$ 概括的其他物理相互作用。总体的最高频率是这两者中的最大值：\n$$\n\\omega_{\\max} = \\max(\\omega_{\\text{penalty}}, \\omega_{\\text{phys}})\n$$\n使用第 1 部分中得到的最小所需刚度 $k_{\\text{min}}$，罚函数法的最大稳定时间步长为：\n$$\n\\Delta t_{\\text{max, penalty}} = \\frac{2}{\\omega_{\\max}} = \\frac{2}{\\max\\left(\\sqrt{\\frac{k_{\\text{min}}}{\\mu}}, \\omega_{\\text{phys}}\\right)}\n$$\n这是要计算的第二个量。\n\n### 第 3 部分：使用增广拉格朗日方法时的最大稳定时间步长 ($\\Delta t_{\\text{max, aug-lag}}$)\n\n在具有精确投影的增广拉格朗日方法中，键长约束 $r - l_0 = 0$ 在每个时间步都通过算法投影（例如，像在 SHAKE 或 RATTLE 算法中那样）被精确地强制执行。在这种情况下，与罚函数力相关的刚性振动模态被有效地从系统坐标的时间演化中移除。罚函数项（如果存在）仅用于指导拉格朗日乘子的迭代收敛，并不直接控制由显式格式积分的动力学。\n\n如问题所述，此过程“从演化中移除了罚函数引起的刚性模态”。因此，时间积分的稳定性不再受 $\\omega_{\\text{penalty}}$ 的限制。最大稳定时间步长现在由系统中次高的频率决定，即给定的最高物理频率 $\\omega_{\\text{phys}}$。因此，最大稳定时间步长为：\n$$\n\\Delta t_{\\text{max, aug-lag}} = \\frac{2}{\\omega_{\\text{phys}}}\n$$\n这是要计算的第三个也是最后一个量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes penalty stiffness and stable time steps for a two-mass system\n    with a bond-length constraint, comparing penalty and augmented Lagrangian methods.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case: (m1, m2, l0, F_max, eps_tol, omega_phys) in SI units.\n    test_cases = [\n        (1.0e-26, 2.0e-26, 1.0e-10, 1.0e-9, 1.0e-13, 1.0e13),\n        (1.0e-26, 2.0e-26, 1.0e-10, 1.0e-9, 1.0e-15, 1.0e13),\n        (1.0e-25, 1.0e-27, 1.0e-10, 5.0e-10, 5.0e-13, 2.0e13),\n        (1.0e-26, 2.0e-26, 1.0e-10, 5.0e-9, 1.0e-12, 1.0e12),\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2, l0, F_max, eps_tol, omega_phys = case\n\n        # Part 1: Minimum penalty stiffness (k_min)\n        # k_min ensures that under the maximum load F_max, the violation does not exceed eps_tol.\n        # F_max = k_min * eps_tol => k_min = F_max / eps_tol\n        k_min = F_max / eps_tol\n\n        # Part 2: Maximum stable time step with the penalty method (dt_max_penalty)\n        # This is limited by the highest frequency in the system.\n        \n        # Calculate the reduced mass of the two-body system.\n        mu = (m1 * m2) / (m1 + m2)\n        \n        # Calculate the frequency induced by the penalty spring.\n        # omega_penalty^2 = k_min / mu\n        omega_penalty = np.sqrt(k_min / mu)\n        \n        # The stability-limiting frequency is the max of the penalty and physical frequencies.\n        omega_max = max(omega_penalty, omega_phys)\n        \n        # The stability limit for velocity-Verlet is dt = 2 / omega_max.\n        dt_max_penalty = 2.0 / omega_max\n\n        # Part 3: Maximum stable time step with the augmented Lagrangian method (dt_max_aug_lag)\n        # With exact projection, the stiff mode from the penalty is removed.\n        # The stability is determined only by the highest physical frequency.\n        dt_max_aug_lag = 2.0 / omega_phys\n\n        # Store the three results for this test case.\n        results.append([k_min, dt_max_penalty, dt_max_aug_lag])\n\n    # Final print statement in the exact required format.\n    # The map(str, results) will convert each inner list to its string representation.\n    # The join then concatenates them with commas.\n    # The outer f-string adds the enclosing square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}