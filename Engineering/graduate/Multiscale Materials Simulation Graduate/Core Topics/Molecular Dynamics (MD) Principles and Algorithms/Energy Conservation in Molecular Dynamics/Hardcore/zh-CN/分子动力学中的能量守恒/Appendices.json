{
    "hands_on_practices": [
        {
            "introduction": "数值积分算法的选择是任何分子动力学模拟稳定性和准确性的基础。本练习将提供一个动手实践，比较辛积分算法（Velocity Verlet，分子动力学标准算法）和通用非辛积分算法（四阶龙格-库塔法）。通过亲自实现这两种算法并观察它们的长期能量行为，您将具体理解为何辛属性对于长时间尺度上的能量守恒至关重要 。",
            "id": "3805850",
            "problem": "给定一个具有单一笛卡尔自由度的可分离哈密顿动力学系统，其哈密顿量定义为 $H(x,p) = T(p) + V(x)$，其中 $T(p) = \\frac{p^2}{2m}$，$V(x)$ 是一个标量势能。正则运动方程等价于牛顿第二定律，其中 $p = m v$ 且 $m \\ddot{x} = -\\frac{\\partial V}{\\partial x}$。对于精确动力学，总能量 $H(x,p)$ 应当守恒。您的任务是为这个可分离哈密顿系统实现两种时间步进算法，对几个测试案例进行长时间动力学模拟，并量化每个积分器的能量漂移。需要比较的两种算法是：速度Verlet方法（一种适用于可分离哈密顿量的辛组合方法）和经典的四阶龙格-库塔方法（Runge-Kutta 4，一种非辛的通用常微分方程积分器）。您的实现必须基于上述基本定律和核心定义，不得使用任何针对最终结果的预推导公式。\n\n定义和要求：\n- 状态变量为 $x(t)$ 和 $v(t)$，其中 $v(t) = \\dot{x}(t)$ 且 $p(t) = m v(t)$。\n- 力为 $F(x) = -\\frac{\\partial V}{\\partial x}$，加速度为 $a(x) = \\frac{F(x)}{m}$。\n- 总能量为 $H(x,p) = \\frac{p^2}{2m} + V(x) = \\frac{1}{2} m v^2 + V(x)$。\n- 速度Verlet更新在时间步长 $\\Delta t$ 下将 $(x_n, v_n)$推进到 $(x_{n+1}, v_{n+1})$，使用以下序列：半步速度更新、位置更新、以及另一次半步速度更新，其中加速度在位置 $x_n$ 和 $x_{n+1}$ 处进行评估。\n- Runge-Kutta 4更新通过对右侧函数 $f(y) = [v, a(x)]^\\top$ 进行四次分阶段评估，并进行加权平均以生成 $y_{n+1}$，来推进状态向量 $y = [x, v]^\\top$。\n\n能量漂移度量：\n- 对于给定的积分器、时间步长 $\\Delta t$、总模拟时间 $T$ 和初始条件 $(x(0), v(0))$，对系统进行积分，并记录在每个离散时间 $t_i = i \\Delta t$（$i = 0, 1, \\dots, N$，其中 $N = \\lfloor T / \\Delta t \\rfloor$）的总能量 $H(t_i)$。\n- 定义能量偏差 $E_i = H(t_i) - H(0)$。\n- 通过对 $E_i$ 与 $t_i$ 进行最小二乘回归，计算最佳拟合的线性漂移率 $s$（单位：焦耳/秒），即找到使 $\\sum_{i=0}^N (E_i - s t_i - b)^2$ 对 $s$ 和 $b$ 最小化的 $s$，并报告斜率 $s$。明确地，令 $\\bar{t} = \\frac{1}{N+1} \\sum_{i=0}^N t_i$ 且 $\\bar{E} = \\frac{1}{N+1} \\sum_{i=0}^N E_i$，然后计算 $$s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2}。$$\n\n势函数和单位：\n- 使用两种势函数，两者在 $H = T(p) + V(x)$ 的意义上都是可分离的：\n  1. 谐振子势：$V(x) = \\frac{1}{2} k x^2$，力为 $F(x) = -k x$。\n  2. 非谐四次势：$V(x) = \\frac{1}{2} k x^2 + \\frac{1}{4} \\alpha x^4$，力为 $F(x) = -k x - \\alpha x^3$。\n- 所有物理量均采用国际单位制（SI）：质量单位为千克（kg），位置单位为米（m），时间单位为秒（s），弹簧常数 $k$ 单位为牛顿/米（N/m），四次项系数 $\\alpha$ 单位为牛顿/立方米（N/m$^3$），能量单位为焦耳（J）。漂移率必须以焦耳/秒（J/s）为单位报告。\n\n实现两种积分器，进行模拟，并为以下测试套件中的每个案例计算漂移率。不允许外部输入；您的程序必须是自包含的。请使用双精度浮点数进行算术运算。\n\n测试套件：\n- 案例A（中等时间步长，谐振子）：\n  - $m = 1$ kg, $k = 1$ N/m, 初始条件 $x(0) = 1$ m, $v(0) = 0$ m/s。\n  - 时间步长 $\\Delta t = 0.05$ s。\n  - 总模拟时间 $T = 100 \\times 2\\pi \\sqrt{m/k}$ s。\n- 案例B（接近稳定边界的时间步长，谐振子）：\n  - $m = 1$ kg, $k = 1$ N/m, 初始条件 $x(0) = 1$ m, $v(0) = 0$ m/s。\n  - 时间步长 $\\Delta t = 1.9$ s。\n  - 总模拟时间 $T = 400$ s。\n- 案例C（非谐四次势，中等时间步长）：\n  - $m = 1$ kg, $k = 1$ N/m, $\\alpha = 1$ N/m$^3$, 初始条件 $x(0) = 1$ m, $v(0) = 0$ m/s。\n  - 时间步长 $\\Delta t = 0.01$ s。\n  - 总模拟时间 $T = 200$ s。\n- 案例D（刚性谐振子，多个周期）：\n  - $m = 1$ kg, $k = 100$ N/m, 初始条件 $x(0) = 0.1$ m, $v(0) = 0$ m/s。\n  - 时间步长 $\\Delta t = 0.02$ s。\n  - 总模拟时间 $T = 100 \\times 2\\pi \\sqrt{m/k}$ s。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试案例，并且必须是一个双元素列表 $[s_{\\mathrm{RK4}}, s_{\\mathrm{VV}}]$，单位为焦耳/秒，按案例A、B、C、D的顺序排列。例如：$[[s_A^{\\mathrm{RK4}}, s_A^{\\mathrm{VV}}],[s_B^{\\mathrm{RK4}}, s_B^{\\mathrm{VV}}],[s_C^{\\mathrm{RK4}}, s_C^{\\mathrm{VV}}],[s_D^{\\mathrm{RK4}}, s_D^{\\mathrm{VV}}]]$。",
            "solution": "该问题要求在一个一维、可分离的哈密顿系统背景下，对两种数值积分算法——速度Verlet方法和经典的四阶龙格-库塔方法——进行比较分析。主要目标是通过计算能量漂移率来量化和比较这些积分器的长期能量守恒特性。\n\n问题陈述的验证过程如下。\n\n**步骤1：提取给定信息**\n\n*   **系统定义**：一个可分离的哈密顿系统，其哈密顿量为 $H(x,p) = T(p) + V(x)$，其中 $T(p) = \\frac{p^2}{2m}$，$V(x)$ 是一个标量势能。\n*   **运动方程**：$p = mv$, $m \\ddot{x} = -\\frac{\\partial V}{\\partial x}$。\n*   **状态变量**：$x(t)$, $v(t) = \\dot{x}(t)$。\n*   **力和加速度**：$F(x) = -\\frac{\\partial V}{\\partial x}$, $a(x) = \\frac{F(x)}{m}$。\n*   **总能量**：$H(x,p) = \\frac{1}{2} m v^2 + V(x)$。\n*   **速度Verlet (VV) 积分器**：将 $(x_n, v_n)$ 更新为 $(x_{n+1}, v_{n+1})$ 分三步：\n    1.  半步速度更新。\n    2.  全步位置更新。\n    3.  第二次半步速度更新。\n*   **Runge-Kutta 4 (RK4) 积分器**：使用函数 $f(y) = [v, a(x)]^\\top$ 和四次分阶段评估来更新状态向量 $y = [x, v]^\\top$。\n*   **能量漂移度量**：\n    *   使用时间步长 $\\Delta t$ 模拟总时间 $T$，生成 $N+1$ 个数据点，其中 $N = \\lfloor T / \\Delta t \\rfloor$。\n    *   时间点：$t_i = i \\Delta t$，其中 $i = 0, \\dots, N$。\n    *   能量偏差：$E_i = H(t_i) - H(0)$。\n    *   漂移率 $s$：通过对 $E_i$ 与 $t_i$ 进行线性最小二乘拟合得到的斜率，由公式 $s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2}$ 给出，其中 $\\bar{t} = \\frac{1}{N+1} \\sum_{i=0}^N t_i$ 且 $\\bar{E} = \\frac{1}{N+1} \\sum_{i=0}^N E_i$。\n*   **势函数**：\n    1.  谐振子势：$V(x) = \\frac{1}{2} k x^2$, $F(x) = -k x$。\n    2.  非谐四次势：$V(x) = \\frac{1}{2} k x^2 + \\frac{1}{4} \\alpha x^4$, $F(x) = -k x - \\alpha x^3$。\n*   **单位**：国际单位制（kg, m, s, N/m, N/m$^3$, J, J/s）。\n*   **测试案例**：\n    *   案例 A：谐振子，$m=1$, $k=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=0.05$, $T=100 \\times 2\\pi \\sqrt{m/k}$。\n    *   案例 B：谐振子，$m=1$, $k=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=1.9$, $T=400$。\n    *   案例 C：非谐，$m=1$, $k=1$, $\\alpha=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=0.01$, $T=200$。\n    *   案例 D：谐振子，$m=1$, $k=100$, $x(0)=0.1$, $v(0)=0$, $\\Delta t=0.02$, $T=100 \\times 2\\pi \\sqrt{m/k}$。\n\n**步骤2：使用提取的给定信息进行验证**\n\n该问题具有科学依据、提法恰当且客观。它基于经典哈密顿力学的基本原理和常微分方程的标准数值方法。积分器的定义是标准的，能量漂移度量是一个明确定义的统计量。模拟和分析所需的所有参数均已提供，且没有内部矛盾。该问题是计算物理学中的一个标准练习，旨在说明对于哈密顿系统，辛积分器（如速度Verlet）相比于通用非辛积分器（如RK4）具有更优越的长期能量守恒性。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。将提供一个完整的、有理有据的解决方案。\n\n**解题推导**\n\n问题的核心在于牛顿运动方程的数值积分，这些方程源自一个哈密顿量。对于精确动力学，总能量 $H$ 是一个守恒量，即 $\\frac{dH}{dt}=0$。然而，数值积分器会引入离散化误差，可能导致计算出的能量随时间波动或系统性地漂移。\n\n**1. 哈密顿系统**\n\n系统由相空间中的状态 $(x, p)$ 描述。运动方程由哈密顿方程给出：\n$$ \\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\frac{\\partial V}{\\partial x} = F(x) $$\n使用 $p = mv$，这些方程等价于 $\\dot{x} = v$ 和 $\\dot{v} = F(x)/m = a(x)$，构成一个由两个一阶常微分方程（ODE）组成的系统。我们将其写为 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{y}(t) = [x(t), v(t)]^\\top$ 且 $\\mathbf{f}(\\mathbf{y}) = [v, a(x)]^\\top$。\n\n**2. 速度Verlet (VV) 积分器**\n\n速度Verlet算法是辛积分器家族的一员。这些算法专为哈密顿系统设计，具有保持相空间体积元的特性，从而带来出色的长期能量稳定性。能量不会系统性地漂移，而是在其真实的初始值附近振荡。\n\n该算法从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$，源于哈密顿演化算符的对称分裂。根据问题的描述性定义：\n\n1.  **第一次半步速度更新**：使用当前加速度 $a_n = a(x_n)$ 将速度推进半个时间步。\n    $$ v_{n+1/2} = v_n + a_n \\frac{\\Delta t}{2} $$\n2.  **全步位置更新**：使用半步速度将位置推进一个完整的时间步。\n    $$ x_{n+1} = x_n + v_{n+1/2} \\Delta t $$\n3.  **第二次半步速度更新**：首先，在新位置计算新的加速度 $a_{n+1} = a(x_{n+1})$。然后，完成速度更新。\n    $$ v_{n+1} = v_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2} $$\n\n这三个步骤构成了从 $(x_n, v_n)$ 到 $(x_{n+1}, v_{n+1})$ 的更新。\n\n**3. Runge-Kutta 4 (RK4) 积分器**\n\n经典的四阶龙格-库塔方法是一种广泛使用的、高精度的通用ODE求解器。它不是辛方法。虽然它单步精度很高（局部误差为 $O(\\Delta t^5)$），但对于哈密顿系统的长期积分，微小的误差会以一种通常导致总能量系统性漂移的方式累积。\n\n从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的更新由以下公式给出：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\n其中，阶段 $\\mathbf{k}_i$ 是具有两个分量 $[k_{i,x}, k_{i,v}]^\\top$ 的向量。对于我们的系统 $\\dot{\\mathbf{y}} = [v, a(x)]^\\top$，这些阶段是：\n$$ \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = [v_n, a(x_n)]^\\top $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) = \\left[ v_n + \\frac{\\Delta t}{2} k_{1,v}, a\\left(x_n + \\frac{\\Delta t}{2} k_{1,x}\\right) \\right]^\\top $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) = \\left[ v_n + \\frac{\\Delta t}{2} k_{2,v}, a\\left(x_n + \\frac{\\Delta t}{2} k_{2,x}\\right) \\right]^\\top $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3) = \\left[ v_n + \\Delta t k_{3,v}, a(x_n + \\Delta t k_{3,x}) \\right]^\\top $$\n然后使用阶段向量相应分量的加权平均来更新位置和速度的分量。\n\n**4. 能量漂移计算**\n\n对于每个模拟运行（即积分器、势函数和参数的一种选择），我们在时间 $t_i = i \\Delta t$（$i \\in \\{0, 1, ..., N\\}$）生成一个状态 $(x_i, v_i)$ 的时间序列。由此，我们计算总能量 $H_i = \\frac{1}{2}m v_i^2 + V(x_i)$ 和能量偏差 $E_i = H_i - H_0$。\n\n我们寻求点集 $(t_i, E_i)$ 的最佳拟合直线的斜率 $s$。最小二乘法通过最小化残差平方和 $S(s, b) = \\sum_{i=0}^N (E_i - (s t_i + b))^2$ 来实现。使该和最小化的斜率 $s$ 由简单线性回归的标准公式给出：\n$$ s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2} = \\frac{\\text{Cov}(t, E)}{\\text{Var}(t)} $$\n其中 $\\bar{t}$ 和 $\\bar{E}$ 分别是时间点和能量偏差的样本均值。这个值 $s$ 代表了模拟过程中能量变化的平均速率，单位为焦耳/秒。\n\n实现将包括用于物理（势函数和力）、两种积分器、模拟驱动程序和漂移计算的函数，并为四个指定的测试案例分别执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # --- Physics and Potential Definitions ---\n\n    def force_harmonic(x, k, **kwargs):\n        \"\"\"Force for the harmonic potential.\"\"\"\n        return -k * x\n\n    def potential_harmonic(x, k, **kwargs):\n        \"\"\"Harmonic potential energy.\"\"\"\n        return 0.5 * k * x**2\n\n    def force_quartic(x, k, alpha, **kwargs):\n        \"\"\"Force for the anharmonic quartic potential.\"\"\"\n        return -k * x - alpha * x**3\n\n    def potential_quartic(x, k, alpha, **kwargs):\n        \"\"\"Anharmonic quartic potential energy.\"\"\"\n        return 0.5 * k * x**2 + 0.25 * alpha * x**4\n\n    def acceleration(x, m, force_func, **params):\n        \"\"\"Calculate acceleration given a force function.\"\"\"\n        return force_func(x, **params) / m\n        \n    def total_energy(x, v, m, potential_func, **params):\n        \"\"\"Calculate total energy of the system.\"\"\"\n        kinetic = 0.5 * m * v**2\n        potential = potential_func(x, **params)\n        return kinetic + potential\n\n    # --- Integrator Implementations ---\n\n    def integrator_vv(x0, v0, m, dt, N, force_func, **params):\n        \"\"\"Velocity Verlet integrator.\"\"\"\n        x_hist = np.zeros(N + 1)\n        v_hist = np.zeros(N + 1)\n        x_hist[0], v_hist[0] = x0, v0\n\n        x, v = x0, v0\n        for i in range(N):\n            a_n = acceleration(x, m, force_func, **params)\n            v_half = v + 0.5 * dt * a_n\n            x_new = x + dt * v_half\n            a_n_plus_1 = acceleration(x_new, m, force_func, **params)\n            v_new = v_half + 0.5 * dt * a_n_plus_1\n            \n            x, v = x_new, v_new\n            x_hist[i+1], v_hist[i+1] = x, v\n        \n        return x_hist, v_hist\n\n    def integrator_rk4(x0, v0, m, dt, N, force_func, **params):\n        \"\"\"Classical 4th-order Runge-Kutta integrator.\"\"\"\n        x_hist = np.zeros(N + 1)\n        v_hist = np.zeros(N + 1)\n        x_hist[0], v_hist[0] = x0, v0\n\n        x, v = x0, v0\n        for i in range(N):\n            # k1\n            k1_x = v\n            k1_v = acceleration(x, m, force_func, **params)\n            \n            # k2\n            k2_x = v + 0.5 * dt * k1_v\n            k2_v = acceleration(x + 0.5 * dt * k1_x, m, force_func, **params)\n            \n            # k3\n            k3_x = v + 0.5 * dt * k2_v\n            k3_v = acceleration(x + 0.5 * dt * k2_x, m, force_func, **params)\n            \n            # k4\n            k4_x = v + dt * k3_v\n            k4_v = acceleration(x + dt * k3_x, m, force_func, **params)\n            \n            # Update\n            x_new = x + (dt / 6.0) * (k1_x + 2.0*k2_x + 2.0*k3_x + k4_x)\n            v_new = v + (dt / 6.0) * (k1_v + 2.0*k2_v + 2.0*k3_v + k4_v)\n            \n            x, v = x_new, v_new\n            x_hist[i+1], v_hist[i+1] = x, v\n            \n        return x_hist, v_hist\n        \n    # --- Analysis Definition ---\n    \n    def calculate_drift(times, energies):\n        \"\"\"\n        Calculates the energy drift rate s via linear regression.\n        s = Cov(t, E) / Var(t)\n        \"\"\"\n        t_bar = np.mean(times)\n        e_bar = np.mean(energies)\n        \n        numerator = np.sum((times - t_bar) * (energies - e_bar))\n        denominator = np.sum((times - t_bar)**2)\n        \n        if denominator == 0:\n            return 0.0\n        \n        return numerator / denominator\n\n    # --- Test Suite Definition ---\n    \n    test_cases = [\n        # Case A\n        {'name': 'A', 'm': 1.0, 'k': 1.0, 'alpha': 0.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 0.05, \n         'T': 100 * 2 * np.pi * np.sqrt(1.0/1.0),\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 1.0}},\n        # Case B\n        {'name': 'B', 'm': 1.0, 'k': 1.0, 'alpha': 0.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 1.9, 'T': 400.0,\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 1.0}},\n        # Case C\n        {'name': 'C', 'm': 1.0, 'k': 1.0, 'alpha': 1.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 200.0,\n         'force_func': force_quartic, 'pot_func': potential_quartic,\n         'params': {'k': 1.0, 'alpha': 1.0}},\n        # Case D\n        {'name': 'D', 'm': 1.0, 'k': 100.0, 'alpha': 0.0, \n         'x0': 0.1, 'v0': 0.0, 'dt': 0.02, \n         'T': 100 * 2 * np.pi * np.sqrt(1.0/100.0),\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 100.0}},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = int(np.floor(case['T'] / case['dt']))\n        times = np.linspace(0, N * case['dt'], N + 1)\n        \n        case_results = []\n        \n        # Runge-Kutta 4\n        x_hist_rk4, v_hist_rk4 = integrator_rk4(\n            case['x0'], case['v0'], case['m'], case['dt'], N, case['force_func'], **case['params']\n        )\n        energies_rk4 = total_energy(x_hist_rk4, v_hist_rk4, case['m'], case['pot_func'], **case['params'])\n        e_dev_rk4 = energies_rk4 - energies_rk4[0]\n        drift_rk4 = calculate_drift(times, e_dev_rk4)\n        case_results.append(drift_rk4)\n\n        # Velocity Verlet\n        x_hist_vv, v_hist_vv = integrator_vv(\n            case['x0'], case['v0'], case['m'], case['dt'], N, case['force_func'], **case['params']\n        )\n        energies_vv = total_energy(x_hist_vv, v_hist_vv, case['m'], case['pot_func'], **case['params'])\n        e_dev_vv = energies_vv - energies_vv[0]\n        drift_vv = calculate_drift(times, e_dev_vv)\n        case_results.append(drift_vv)\n        \n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了积分算法，势能函数本身的定义也是产生数值误差的一个关键来源。本练习将探讨一个常见问题：在截断半径处粗略地截断势能导致的能量不守恒。您将推导并量化由此产生的人为能量跳变，并了解“切换”势函数如何提供一种平滑且能量守恒的替代方案 。",
            "id": "3805821",
            "problem": "您的任务是，当使用截断 Lennard-Jones (LJ) 势或开关（平滑衰减）Lennard-Jones 势时，在微正则系综 (NVE) 分子动力学步骤中，推导、实现并数值评估单个粒子对每次截断穿越事件的能量漂移。目标是在约化 Lennard-Jones 单位中，量化每次在截断半径 $r_c$ 附近发生的穿越事件所引起的总机械能变化。即，距离以 $\\sigma$ 为单位，速度以 $\\sigma/\\tau$ 为单位，能量以 $\\epsilon$ 为单位，时间以 $\\tau$ 为单位，其中对于粒子质量 $m$，$\\tau = \\sqrt{m \\sigma^2 / \\epsilon}$。您程序的最终输出必须以 $\\epsilon$ 为单位表示能量漂移。\n\n从以下基础出发：\n- 牛顿第二定律：$m \\, \\mathrm{d}^2 \\mathbf{r}/\\mathrm{d}t^2 = \\mathbf{F}$。\n- 速度定义：$\\mathbf{v} = \\mathrm{d}\\mathbf{r}/\\mathrm{d}t$。\n- 经典力学中的机械能：$E = K + U$，其中 $K = \\frac{1}{2} m v^2$ 是动能，U 是势能。\n- 对于保守势 $U(\\mathbf{r})$，力为 $\\mathbf{F}(\\mathbf{r}) = - \\nabla U(\\mathbf{r})$。对于光滑的 $U$，在精确动力学下能量是守恒的，即 $\\mathrm{d}E/\\mathrm{d}t = \\mathbf{v} \\cdot (\\mathbf{F} + \\nabla U) = 0$。\n- Lennard-Jones 势：$U_{\\mathrm{LJ}}(r) = 4 \\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]$。\n\n定义两种在截断半径附近的相互作用模型：\n1. 截断未移动 Lennard-Jones 势：\n   $$U_{\\mathrm{T}}(r) = \\begin{cases}\n   U_{\\mathrm{LJ}}(r),  r  r_c, \\\\\n   0,  r \\ge r_c,\n   \\end{cases}\n   \\quad\n   \\mathbf{F}_{\\mathrm{T}}(r) = \\begin{cases}\n   -\\nabla U_{\\mathrm{LJ}}(r),  r  r_c, \\\\\n   \\mathbf{0},  r \\ge r_c.\n   \\end{cases}$$\n   注意，$U_{\\mathrm{T}}(r)$ 在 $r_c$ 处有一个大小为 $\\Delta U = U_{\\mathrm{LJ}}(r_c) - 0$ 的有限跳跃，这违反了可微性，并可能在粒子对穿越 $r_c$ 时导致离散的能量变化。\n2. 开关 Lennard-Jones 势：定义一个平滑的开关函数 $S(r)$，使得当 $r \\le r_s$ 时 $S(r) = 1$，当 $r \\ge r_c$ 时 $S(r) = 0$，并且 $S(r)$ 在 $[r_s, r_c]$ 上足够光滑。一种选择是五次平滑阶跃函数\n   $$x = \\frac{r - r_s}{r_c - r_s}, \\quad S(r) = \\begin{cases}\n   1,  r \\le r_s, \\\\\n   1 - 10 x^3 + 15 x^4 - 6 x^5,  r_s  r  r_c, \\\\\n   0,  r \\ge r_c,\n   \\end{cases}$$\n   这样 $S(r)$ 和 $\\frac{\\mathrm{d}S}{\\mathrm{d}r}$ 在 $r = r_s$ 和 $r = r_c$ 处是连续的。然后\n   $$U_{\\mathrm{S}}(r) = S(r) \\, U_{\\mathrm{LJ}}(r), \\quad \\mathbf{F}_{\\mathrm{S}}(r) = -\\nabla \\left( S(r) \\, U_{\\mathrm{LJ}}(r) \\right).$$\n   因为 $U_{\\mathrm{S}}(r)$ 是具有连续导数的连续函数，精确动力学在穿越 $r_c$ 时能量守恒，而不会在 $U$ 中产生任何有限跳跃。\n\n假设两个粒子的相对运动可以简化为在单个时间步长 $\\Delta t$ 内，在 $r_c$ 附近的一维径向坐标 $r(t)$ 和相对速度 $v_{\\mathrm{rel}}$；假设约化质量已被吸收到约化时间单位 $\\tau$ 中。考虑在一个时间步长 $\\Delta t$ 内的预测位移为 $r_1 \\approx r_0 + v_{\\mathrm{rel}} \\, \\Delta t$。如果 $r_0  r_c$ 且 $r_1 \\ge r_c$（向外穿越）或 $r_0  r_c$ 且 $r_1 \\le r_c$（向内穿越），则发生穿越事件。如果未发生穿越，两种模型的每次事件能量漂移均为零。\n\n您的任务：\n- 基于上述基础，推导截断未移动势和开关势两种模型下每次穿越事件的能量漂移表达式，定义为 $\\Delta E = E_{\\text{after}} - E_{\\text{before}}$。您必须明确说明为什么截断情况会产生与 $U$ 在 $r_c$ 处的跳跃相关的有限漂移，而开关情况则不会。\n- 实现一个程序，给定约化 Lennard-Jones 单位下的 $\\epsilon$、$\\sigma$、$r_c$、$r_s$、$r_0$、$v_{\\mathrm{rel}}$ 和 $\\Delta t$，检测是否发生穿越，并计算两种模型下每次事件的能量漂移 $\\Delta E$（以 $\\epsilon$ 为单位）。\n- 使用以下测试套件。对于每种情况，计算并返回一对以 $\\epsilon$ 为单位的十进制浮点数 $[\\Delta E_{\\mathrm{T}}, \\Delta E_{\\mathrm{S}}]$：\n  1. 情况 A（正常向外穿越）：$\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.49$, $v_{\\mathrm{rel}} = 0.8$, $\\Delta t = 0.02$。\n  2. 情况 B（步长内无穿越）：$\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.49$, $v_{\\mathrm{rel}} = 0.1$, $\\Delta t = 0.01$。\n  3. 情况 C（向内穿越）：$\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.51$, $v_{\\mathrm{rel}} = -0.8$, $\\Delta t = 0.02$。\n  4. 情况 D（在更大截断半径处向外穿越）：$\\epsilon = 1$, $\\sigma = 1$, $r_c = 3.0$, $r_s = 2.5$, $r_0 = 2.999$, $v_{\\mathrm{rel}} = 0.5$, $\\Delta t = 0.004$。\n  5. 情况 E（触及边界的向外穿越）：$\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.5 - 10^{-6}$, $v_{\\mathrm{rel}} = 1.0$, $\\Delta t = 10^{-6}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。每个元素对应一个测试用例，其本身是两个能量漂移值 $[\\Delta E_{\\mathrm{T}}, \\Delta E_{\\mathrm{S}}]$（以 $\\epsilon$ 为单位）的列表。例如：$[[e_{1,T},e_{1,S}],[e_{2,T},e_{2,S}],\\dots]$。",
            "solution": "该问题要求在一个分子动力学模拟步骤中，针对通过两种不同势模型（截断 Lennard-Jones 势和开关 Lennard-Jones 势）相互作用的双粒子系统，推导并计算每次截断穿越事件的能量漂移。分析将在约化 Lennard-Jones 单位中进行，其中特征能量 $\\epsilon = 1$，特征长度 $\\sigma = 1$，粒子质量 $m = 1$。总机械能由 $E = K + U$ 给出，其中 $K$ 是动能， $U$ 是势能。每次事件的能量漂移定义为 $\\Delta E = E_{\\text{after}} - E_{\\text{before}}$。\n\nLennard-Jones 势由下式给出：\n$$U_{\\mathrm{LJ}}(r) = 4 \\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]$$\n在约化单位中（$\\epsilon=1, \\sigma=1$），这简化为：\n$$U_{\\mathrm{LJ}}(r) = 4 \\left( r^{-12} - r^{-6} \\right)$$\n穿越事件定义为在单个时间步长 $\\Delta t$ 内发生，其中粒子的径向位置从 $r_0$ 变为 $r_1 = r_0 + v_{\\mathrm{rel}} \\Delta t$。如果 $r_0  r_c$ 且 $r_1 \\ge r_c$，则发生向外穿越。如果 $r_0  r_c$ 且 $r_1 \\le r_c$，则发生向内穿越。\n\n**截断未移动势 ($U_{\\mathrm{T}}$) 的分析**\n\n截断未移动势 $U_{\\mathrm{T}}(r)$ 定义为：\n$$U_{\\mathrm{T}}(r) = \\begin{cases}\nU_{\\mathrm{LJ}}(r),  r  r_c \\\\\n0,  r \\ge r_c\n\\end{cases}$$\n该势函数在截断半径 $r_c$ 处有一个跳跃不连续点。当 $r$ 从下方趋近 $r_c$ 时，势的值趋近于 $U_{\\mathrm{LJ}}(r_c)$，但在 $r=r_c$ 时突然降为 $0$。\n$$\\lim_{r \\to r_c^-} U_{\\mathrm{T}}(r) = U_{\\mathrm{LJ}}(r_c)$$\n$$\\lim_{r \\to r_c^+} U_{\\mathrm{T}}(r) = 0$$\n这个不连续的大小是 $|U_{\\mathrm{LJ}}(r_c)|$。问题中描述的“每次事件能量漂移”是由势能的这种跳跃引起的总能量的离散变化。当一对粒子穿越截断半径 $r_c$ 时，其动能 $K$ 在无穷小的穿越点上可以被认为是连续的，但势能 $U$ 会瞬时改变。因此，总能量的变化 $\\Delta E = \\Delta K + \\Delta U$ 主要由势能的跳跃决定，所以 $\\Delta E = \\Delta U$。\n\n1.  **向外穿越 ($r_0  r_c$ 且 $r_1 \\ge r_c$)**：\n    系统从一个由势 $U_{\\mathrm{LJ}}(r)$ 控制的状态过渡到一个势为 $0$ 的状态。在穿越 $r_c$ 的瞬间，势能有效地从 $U_{\\text{before}} = U_{\\mathrm{LJ}}(r_c)$ 变为 $U_{\\text{after}} = 0$。能量漂移为：\n    $$\\Delta E_{\\mathrm{T}} = U_{\\text{after}} - U_{\\text{before}} = 0 - U_{\\mathrm{LJ}}(r_c) = -U_{\\mathrm{LJ}}(r_c)$$\n    代入约化单位下的 $U_{\\mathrm{LJ}}(r_c)$ 表达式：\n    $$\\Delta E_{\\mathrm{T}} = -4 \\left( r_c^{-12} - r_c^{-6} \\right)$$\n\n2.  **向内穿越 ($r_0  r_c$ 且 $r_1 \\le r_c$)**：\n    系统从零势能区域过渡到势能为 $U_{\\mathrm{LJ}}(r)$ 的区域。在穿越 $r_c$ 的瞬间，势能从 $U_{\\text{before}} = 0$ 变为 $U_{\\text{after}} = U_{\\mathrm{LJ}}(r_c)$。能量漂移为：\n    $$\\Delta E_{\\mathrm{T}} = U_{\\text{after}} - U_{\\text{before}} = U_{\\mathrm{LJ}}(r_c) - 0 = U_{\\mathrm{LJ}}(r_c)$$\n    在约化单位中：\n    $$\\Delta E_{\\mathrm{T}} = 4 \\left( r_c^{-12} - r_c^{-6} \\right)$$\n\n3.  **无穿越**：\n    如果粒子对在时间步长内没有穿越截断半径 $r_c$，则在该步长内粒子的轨迹上，势能函数保持连续。因此，没有与势能不连续性相关的能量漂移。\n    $$\\Delta E_{\\mathrm{T}} = 0$$\n\n**开关势 ($U_{\\mathrm{S}}$) 的分析**\n\n开关势定义为 $U_{\\mathrm{S}}(r) = S(r) U_{\\mathrm{LJ}}(r)$，其中 $S(r)$ 是一个五次平滑阶跃开关函数：\n$$x(r) = \\frac{r - r_s}{r_c - r_s}$$\n$$S(r) = \\begin{cases}\n1,  r \\le r_s \\\\\n1 - 10 x^3 + 15 x^4 - 6 x^5,  r_s  r  r_c \\\\\n0,  r \\ge r_c\n\\end{cases}$$\n这个开关函数的构造使得它及其一阶导数在 $r=r_c$ 处连续且等于 $0$。具体来说，$S(r_c) = 0$ 且 $\\frac{\\mathrm{d}S}{\\mathrm{d}r}|_{r_c} = 0$。\n\n让我们检查 $U_{\\mathrm{S}}(r)$ 及其导数（与力相关）在截断半径 $r_c$ 处的行为：\n-   **势的连续性**：\n    当 $r \\to r_c^-$ 时，势为 $U_{\\mathrm{S}}(r) = S(r)U_{\\mathrm{LJ}}(r)$。极限为：\n    $$\\lim_{r \\to r_c^-} U_{\\mathrm{S}}(r) = S(r_c) U_{\\mathrm{LJ}}(r_c) = 0 \\cdot U_{\\mathrm{LJ}}(r_c) = 0$$\n    对于 $r \\ge r_c$，势 $U_{\\mathrm{S}}(r)$ 定义为 $0$。由于两个极限相等，$U_{\\mathrm{S}}(r)$ 在 $r_c$ 处是连续的。势能没有跳跃。\n\n-   **力的连续性**：\n    力为 $F_{\\mathrm{S}}(r) = -\\frac{\\mathrm{d}U_{\\mathrm{S}}}{\\mathrm{d}r}$。对于 $r_s  r  r_c$，使用乘法法则：\n    $$\\frac{\\mathrm{d}U_{\\mathrm{S}}}{\\mathrm{d}r} = \\frac{\\mathrm{d}S}{\\mathrm{d}r} U_{\\mathrm{LJ}}(r) + S(r) \\frac{\\mathrm{d}U_{\\mathrm{LJ}}}{\\mathrm{d}r}$$\n    当 $r \\to r_c^-$ 时，导数的极限为：\n    $$\\lim_{r \\to r_c^-} \\frac{\\mathrm{d}U_{\\mathrm{S}}}{\\mathrm{d}r} = \\left(\\frac{\\mathrm{d}S}{\\mathrm{d}r}\\bigg|_{r_c}\\right) U_{\\mathrm{LJ}}(r_c) + S(r_c) \\left(\\frac{\\mathrm{d}U_{\\mathrm{LJ}}}{\\mathrm{d}r}\\bigg|_{r_c}\\right) = (0) \\cdot U_{\\mathrm{LJ}}(r_c) + (0) \\cdot \\left(\\frac{\\mathrm{d}U_{\\mathrm{LJ}}}{\\mathrm{d}r}\\bigg|_{r_c}\\right) = 0$$\n    对于 $r \\ge r_c$，导数也为 $0$。因此，势的导数是连续的，这意味着力在 $r_c$ 处是连续的（且为零）。\n\n因为势 $U_{\\mathrm{S}}(r)$ 和由它导出的力在任何地方都是连续函数，所以在精确动力学下总机械能是守恒的。在截断处没有势的不连续性来引起能量的离散跳跃。因此，由突变机制定义的每次穿越事件的能量漂移对于开关势模型是零。在实际模拟中使用该势产生的任何能量漂移都将源于数值积分算法在有限时间步长 $\\Delta t$ 上的不精确性，而不是势本身的定义。\n$$\\Delta E_{\\mathrm{S}} = 0$$\n\n**算法总结**\n\n对于每个具有参数 $(\\epsilon, \\sigma, r_c, r_s, r_0, v_{\\mathrm{rel}}, \\Delta t)$ 的测试用例，能量漂移 $\\Delta E_{\\mathrm{T}}$ 和 $\\Delta E_{\\mathrm{S}}$ 的计算如下：\n1.  设置约化单位 $\\epsilon=1$ 和 $\\sigma=1$。\n2.  计算最终径向位置：$r_1 = r_0 + v_{\\mathrm{rel}} \\Delta t$。\n3.  检查是否发生穿越事件：\n    - 如果 $r_0  r_c$ 且 $r_1 \\ge r_c$，则发生向外穿越。\n    - 如果 $r_0  r_c$ 且 $r_1 \\le r_c$，则发生向内穿越。\n4.  计算 $\\Delta E_{\\mathrm{T}}$：\n    - 对于向外穿越：$\\Delta E_{\\mathrm{T}} = -4(r_c^{-12} - r_c^{-6})$。\n    - 对于向内穿越：$\\Delta E_{\\mathrm{T}} = +4(r_c^{-12} - r_c^{-6})$。\n    - 对于无穿越：$\\Delta E_{\\mathrm{T}} = 0$。\n5.  计算 $\\Delta E_{\\mathrm{S}}$：\n    - 根据势的连续性，$\\Delta E_{\\mathrm{S}}$ 始终为 $0$。\n然后收集结果并格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the energy drift per cutoff-crossing event for truncated and\n    switched Lennard-Jones potentials.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (epsilon, sigma, r_c, r_s, r_0, v_rel, dt)\n    test_cases = [\n        # Case A (happy path outward crossing)\n        (1.0, 1.0, 2.5, 2.0, 2.49, 0.8, 0.02),\n        # Case B (no crossing within the step)\n        (1.0, 1.0, 2.5, 2.0, 2.49, 0.1, 0.01),\n        # Case C (inward crossing)\n        (1.0, 1.0, 2.5, 2.0, 2.51, -0.8, 0.02),\n        # Case D (outward crossing at a larger cutoff)\n        (1.0, 1.0, 3.0, 2.5, 2.999, 0.5, 0.004),\n        # Case E (boundary-touching outward crossing)\n        (1.0, 1.0, 2.5, 2.0, 2.5 - 1e-6, 1.0, 1e-6),\n    ]\n\n    results = []\n\n    def u_lj(r, epsilon=1.0, sigma=1.0):\n        \"\"\"Calculates the Lennard-Jones potential in reduced units.\"\"\"\n        # Using np.power for robust floating point exponentiation\n        s_over_r_6 = np.power(sigma / r, 6)\n        s_over_r_12 = np.power(s_over_r_6, 2)\n        return 4.0 * epsilon * (s_over_r_12 - s_over_r_6)\n\n    for case in test_cases:\n        epsilon, sigma, r_c, r_s, r_0, v_rel, dt = case\n\n        # Calculate final position based on simple displacement approximation\n        r_1 = r_0 + v_rel * dt\n\n        # Initialize energy drifts\n        delta_E_T = 0.0\n        delta_E_S = 0.0 # By definition, the switched potential is smooth\n\n        # Check for crossing event based on problem definition\n        is_outward_crossing = (r_0  r_c) and (r_1 >= r_c)\n        is_inward_crossing = (r_0 > r_c) and (r_1 = r_c)\n\n        if is_outward_crossing:\n            # Energy drift is the negative of the potential energy discontinuity\n            delta_E_T = -u_lj(r_c, epsilon, sigma)\n        elif is_inward_crossing:\n            # Energy drift is the positive of the potential energy discontinuity\n            delta_E_T = u_lj(r_c, epsilon, sigma)\n        # Otherwise, if no crossing, delta_E_T remains 0.\n\n        # The energy drift for the switched potential is 0 by design,\n        # as there is no discontinuity in the potential or force.\n        delta_E_S = 0.0\n        \n        # All output energies are in units of epsilon. Since epsilon=1, the\n        # calculated values are the final answer.\n        results.append([delta_E_T, delta_E_S])\n\n    # Final print statement in the exact required format.\n    # Use map(str, ...) to convert each sublist to a string, then join.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多分子模型（如水模型）为了降低计算成本而采用刚性几何结构，这需要专门的约束算法。这个高级练习将深入探讨这些算法在强制维持刚性的同时，如何微妙地影响系统的总能量。通过实施一个稳定化程序，您将研究数值容差、约束满足度和能量漂移之间的关系，这是高性能模拟中的一个关键权衡 。",
            "id": "3805782",
            "problem": "考虑一个由三个质点（一个氧原子和两个氢原子）建模的单个刚性水分子。其刚性几何结构由完整约束强制实现，这些约束使所有三对原子间的距离保持固定。约束定义在距离的平方上，以使约束函数可微，并且其时间导数能产生线性的速度条件。从牛顿第二定律出发，定义一个作用于速度的约束稳定化步骤，通过施加质量加权的校正冲量，将当前速度矢量投影到约束流形的切空间上。计算由此稳定化引起的能量变化，并提出能够最小化能量漂移同时仍能达到可接受的约束满足程度的数值容差设置。\n\n基本原理。从牛顿第二定律 $m_i \\,\\mathbf{a}_i = \\mathbf{F}_i$ 和动能的定义 $T = \\frac{1}{2}\\sum_{i} m_i \\|\\mathbf{v}_i\\|^2$ 开始。对于一个完整约束 $g_k(\\mathbf{r}) = 0$，其速度级约束为 $\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\nabla g_k(\\mathbf{r}) \\cdot \\mathbf{v} = 0$。用于强制实现 $\\dot{g}_k=0$ 的质量加权投影通过添加速度冲量 $\\Delta \\mathbf{v}_i$ 来进行，这些冲量是约束梯度与拉格朗日乘子缩放后的线性组合。在一次顺序稳定化（Gauss–Seidel）扫描中，每个约束被依次校正，这可能会在其他约束中引入微小的违规，因此需要使用多次扫描，直到满足停止准则。\n\n模型和单位。使用为典型水模型设计的固定刚性几何结构：\n- 氧原子质量 $m_O = 15.999\\,\\mathrm{amu}$，氢原子质量 $m_H = 1.008\\,\\mathrm{amu}$，其中 $1\\,\\mathrm{amu} = 1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$。所有质量均以 $\\mathrm{kg}$ 表示。\n- 氧-氢键长 $r_{OH} = 9.572\\times 10^{-11}\\,\\mathrm{m}$。\n- 氢-氧-氢夹角 $\\theta = 104.52^\\circ$（角度单位为度）。\n- 将氧原子置于原点 $\\mathbf{r}_O = (0,0,0)$；将第一个氢原子置于 $\\mathbf{r}_{H1} = (r_{OH}, 0, 0)$；将第二个氢原子置于 $\\mathbf{r}_{H2} = (r_{OH}\\cos\\theta, r_{OH}\\sin\\theta, 0)$。\n- 使用平方距离函数强制实现三个距离约束\n$$\ng_1(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H1}\\|^2 - r_{OH}^2\\right),\\quad\ng_2(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H2}\\|^2 - r_{OH}^2\\right),\\quad\ng_3(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{H1}-\\mathbf{r}_{H2}\\|^2 - r_{HH}^2\\right),\n$$\n其中 $r_{HH} = 2\\,r_{OH}\\,\\sin(\\theta/2)$ 确保几何一致性。相应的速度约束为\n$$\n\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q) = 0,\n$$\n其中 $\\mathbf{r}_{pq} = \\mathbf{r}_p - \\mathbf{r}_q$ 代表约束 $k$ 的原子对。\n\n约束稳定化步骤。在对约束进行的一次 Gauss–Seidel 迭代中，对于连接原子 $p$ 和 $q$ 的每个约束 $k$，计算标量残差\n$$\ns_k = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q),\n$$\n并应用能使该约束单独满足 $s_k = 0$ 的最小质量加权校正：\n$$\n\\lambda_k = -\\frac{s_k}{\\alpha_{pq}},\\quad \\alpha_{pq} = \\|\\mathbf{r}_{pq}\\|^2\\left(\\frac{1}{m_p} + \\frac{1}{m_q}\\right),\n$$\n$$\n\\mathbf{v}_p \\leftarrow \\mathbf{v}_p + \\frac{\\lambda_k}{m_p}\\,\\mathbf{r}_{pq},\\quad\n\\mathbf{v}_q \\leftarrow \\mathbf{v}_q - \\frac{\\lambda_k}{m_q}\\,\\mathbf{r}_{pq}.\n$$\n迭代扫描，直到所有约束都满足一个归一化残差阈值。令瞬时质量加权均方根速率为\n$$\nv_{\\mathrm{rms}} = \\sqrt{\\frac{\\sum_i m_i \\|\\mathbf{v}_i\\|^2}{\\sum_i m_i}},\n$$\n并为每个约束定义无量纲的归一化残差\n$$\n\\rho_k = \\frac{|s_k|}{\\|\\mathbf{r}_{pq}\\|\\, v_{\\mathrm{rms}}}.\n$$\n当 $\\max_k \\rho_k \\le \\mathrm{rtol}$ 时终止迭代，其中 $\\mathrm{rtol}$ 是一个相对容差参数。\n\n稳定化引起的能量变化。稳定化前后的动能分别为\n$$\nT_{\\mathrm{before}} = \\tfrac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(before)}}\\|^2,\\quad\nT_{\\mathrm{after}} = \\tfrac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(after)}}\\|^2.\n$$\n能量变化为\n$$\n\\Delta T = T_{\\mathrm{after}} - T_{\\mathrm{before}},\n$$\n该值应以焦耳（J）表示。\n\n容差提议目标。给定一个目标归一化残差界限 $\\rho^\\ast = 10^{-6}$，从一个候选集合中提出一个容差 $\\mathrm{rtol}$，该容差在确保 $\\max_k \\rho_k \\le \\rho^\\ast$ 的同时最小化 $|\\Delta T|$。如果没有候选容差能达到目标，则在候选容差中选择使 $\\max_k \\rho_k$ 最小的一个，若有并列，则选择 $|\\Delta T|$ 最小的一个，若仍有并列，则选择 $\\mathrm{rtol}$ 最大的一个。\n\n测试套件。使用三个具有不同初始速度（单位为 $\\mathrm{m/s}$）的测试用例：\n- 用例 A（类热运动）：$\\mathbf{v}_O = (300,-200,100)$，$\\mathbf{v}_{H1} = (1500,2000,-1000)$，$\\mathbf{v}_{H2} = (-1200,800,600)$。\n- 用例 B（近刚性旋转）：定义角速度 $\\boldsymbol{\\omega} = (0, 5\\times 10^{11}, 0)\\,\\mathrm{s}^{-1}$，计算质心位置 $\\mathbf{r}_{\\mathrm{COM}}$，并设置 $\\mathbf{v}_i = \\boldsymbol{\\omega} \\times (\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{COM}})$，其中 $i \\in \\{O,H1,H2\\}$。\n- 用例 C（极端违规）：$\\mathbf{v}_O = (0,0,0)$，$\\mathbf{v}_{H1} = (20000,0,0)$，$\\mathbf{v}_{H2} = (0,0,0)$。\n\n候选容差和迭代上限。使用候选容差 $\\mathrm{rtol} \\in \\{10^{-2}, 10^{-4}, 10^{-6}, 10^{-8}, 10^{-10}\\}$，每次稳定化的最大 Gauss–Seidel 扫描次数为 $N_{\\max} = 200$。\n\n所需输出。对于每个测试用例，根据上述目标确定推荐的容差 $\\mathrm{rtol}_{\\mathrm{rec}}$，并计算稳定化后相应的能量变化 $\\Delta T$。每个 $\\Delta T$ 以 $\\mathrm{J}$ 表示。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是一个包含某个测试用例的 $[\\mathrm{rtol}_{\\mathrm{rec}}, \\Delta T]$ 的双元素列表。例如，格式为 $[[\\mathrm{rtol}_A,\\Delta T_A],[\\mathrm{rtol}_B,\\Delta T_B],[\\mathrm{rtol}_C,\\Delta T_C]]$，值为数值。",
            "solution": "该问题要求对应用于刚性水分子的速度级约束稳定化算法进行能量守恒分析。解决方案涉及为几种初始速度配置实现指定的高斯-赛德尔（Gauss-Seidel）迭代过程，并基于一个多部分目标函数选择最优的数值容差。\n\n### 系统与几何定义\n该系统由三个质点组成：一个氧原子（$O$，索引 $0$）和两个氢原子（$H1$，索引 $1$；$H2$，索引 $2$）。它们的质量为 $m_O = 15.999 \\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$ 和 $m_{H1} = m_{H2} = m_H = 1.008 \\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$。\n\n几何结构固定在一个平面上。将氧原子置于原点 $\\mathbf{r}_0 = (0,0,0)$，氢原子的位置由 O-H 键长 $r_{OH} = 9.572\\times 10^{-11}\\ \\mathrm{m}$ 和 H-O-H 夹角 $\\theta = 104.52^\\circ$ 定义。\n令 $\\theta_{rad}$ 为以弧度表示的角度。位置如下：\n- $\\mathbf{r}_0 = (0, 0, 0)$\n- $\\mathbf{r}_1 = (r_{OH}, 0, 0)$\n- $\\mathbf{r}_2 = (r_{OH}\\cos\\theta_{rad}, r_{OH}\\sin\\theta_{rad}, 0)$\n\n### 完整约束\n分子的刚性由三个关于原子间距离平方的完整约束强制实现：\n$g_1(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - r_{OH}^2\\right) = 0$\n$g_2(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_0 - \\mathbf{r}_2\\|^2 - r_{OH}^2\\right) = 0$\n$g_3(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_1 - \\mathbf{r}_2\\|^2 - r_{HH}^2\\right) = 0$\nH-H 距离 $r_{HH}$ 由几何结构决定：$r_{HH} = 2 r_{OH} \\sin(\\theta/2)$。这确保了约束的一致性。\n\n为了使运动对于刚体是物理上有效的，每个约束函数的时间导数必须为零。这导致了速度级约束。对于原子 $p$ 和 $q$ 之间的通用约束 $k$，我们有：\n$\\dot{g}_k(\\mathbf{r}, \\mathbf{v}) = \\frac{\\partial g_k}{\\partial \\mathbf{r}} \\cdot \\mathbf{v} = (\\mathbf{r}_p - \\mathbf{r}_q) \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) = 0$\n令 $\\mathbf{r}_{pq} = \\mathbf{r}_p - \\mathbf{r}_q$。条件是 $\\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) = 0$。这意味着两个原子的相对速度必须与其分离矢量正交。\n\n### 速度稳定化算法\n数值积分方案可能会引入微小误差，导致速度偏离约束流形，即 $\\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) \\neq 0$。稳定化算法将速度投影回此流形上。规定的方法是 Gauss-Seidel 迭代过程。在每次扫描中，我们依次对三个约束中的每一个进行校正。\n\n对于原子 $p$ 和 $q$ 之间的单个约束 $k$，违规程度由残差 $s_k = \\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q)$ 度量。目标是找到速度校正量 $\\Delta\\mathbf{v}_p$ 和 $\\Delta\\mathbf{v}_q$ 以消除此残差。该方法提供了一个解，相当于沿着分离矢量 $\\mathbf{r}_{pq}$ 的方向施加校正冲量。此方向与约束函数的梯度 $\\nabla_{\\mathbf{r}_p} g_k = \\mathbf{r}_{pq}$ 平行。速度变化为：\n$\\Delta \\mathbf{v}_p = \\frac{\\lambda_k}{m_p} \\mathbf{r}_{pq}$\n$\\Delta \\mathbf{v}_q = -\\frac{\\lambda_k}{m_q} \\mathbf{r}_{pq}$\n标量 $\\lambda_k$ 是一个拉格朗日乘子，通过要求新速度 $\\mathbf{v}'_p = \\mathbf{v}_p + \\Delta\\mathbf{v}_p$ 和 $\\mathbf{v}'_q = \\mathbf{v}_q + \\Delta\\mathbf{v}_q$ 满足约束来确定：\n$\\mathbf{r}_{pq} \\cdot (\\mathbf{v}'_p - \\mathbf{v}'_q) = 0 \\implies \\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) + \\lambda_k \\|\\mathbf{r}_{pq}\\|^2 \\left( \\frac{1}{m_p} + \\frac{1}{m_q} \\right) = 0$\n解出 $\\lambda_k$ 得：\n$\\lambda_k = - \\frac{s_k}{\\alpha_{pq}}$，其中 $\\alpha_{pq} = \\|\\mathbf{r}_{pq}\\|^2 \\left(\\frac{1}{m_p} + \\frac{1}{m_q}\\right)$。\n速度被依次对每个约束进行更新。因为校正一个约束可能会对其他约束引入微小的违规，所以这个过程会以扫描的方式重复，直到所有约束都满足期望的容差。\n\n### 收敛与容差\n迭代持续进行，直到最大归一化残差 $\\max_k \\rho_k$ 低于指定的容差 $\\mathrm{rtol}$。归一化残差 $\\rho_k = \\frac{|s_k|}{\\|\\mathbf{r}_{pq}\\| v_{\\mathrm{rms}}}$ 将约束违规的速度与系统的整体均方根速率 $v_{\\mathrm{rms}} = \\sqrt{2T/M_{tot}}$ 进行比较，其中 $T$ 是总动能，$M_{tot}$ 是总质量。如果达到收敛或在最多 $N_{max}=200$ 次扫描后，迭代停止。\n\n### 能量变化与容差选择\n稳定化前的动能是 $T_{\\mathrm{before}} = \\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(before)}}\\|^2$。稳定化后，最终动能为 $T_{\\mathrm{after}} = \\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(after)}}\\|^2$。变化量为 $\\Delta T = T_{\\mathrm{after}} - T_{\\mathrm{before}}$。虽然每个单独的校正步骤在质量加权的意义上是最小的，但 Gauss-Seidel 方案的顺序性通常会导致非零的 $\\Delta T$。\n\n目标是从集合 $\\{10^{-2},10^{-4},10^{-6},10^{-8},10^{-10}\\}$ 中为每个测试用例选择最佳的容差 `rtol`。\n1. 主要目标：满足严格的约束要求 $\\max_k \\rho_k \\le \\rho^\\ast=10^{-6}$。在满足此条件的容差中，选择导致最小绝对能量变化 $|\\Delta T|$ 的一个。\n2. 备选方案：如果没有容差达到主要目标，则选择产生最小 $\\max_k \\rho_k$ 的一个。若有并列，则选择最小的 $|\\Delta T|$，然后选择最大的 `rtol`。\n\n计算过程是针对每个测试用例和每个候选 `rtol` 运行稳定化，记录最终的 $\\max_k \\rho_k$ 和 $\\Delta T$，然后应用选择逻辑来找到推荐的容差和相应的能量变化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rigid water molecule constraint stabilization problem.\n    \"\"\"\n    #\n    # Step 1: Define Constants and System Geometry\n    #\n    AMU_TO_KG = 1.66053906660e-27\n    M_O_AMU = 15.999\n    M_H_AMU = 1.008\n    R_OH = 9.572e-11  # meters\n    THETA_DEG = 104.52  # degrees\n\n    m_o = M_O_AMU * AMU_TO_KG\n    m_h = M_H_AMU * AMU_TO_KG\n    masses = np.array([m_o, m_h, m_h])\n    \n    theta_rad = np.deg2rad(THETA_DEG)\n    r_h1 = np.array([R_OH, 0.0, 0.0])\n    r_h2 = np.array([R_OH * np.cos(theta_rad), R_OH * np.sin(theta_rad), 0.0])\n    r_o = np.array([0.0, 0.0, 0.0])\n    \n    positions = np.array([r_o, r_h1, r_h2])\n    \n    # Store constraint definitions: atom pairs (p, q) and reference squared distance\n    r_hh_sq = (2 * R_OH * np.sin(theta_rad / 2))**2\n    constraint_defs = [\n        (0, 1, R_OH**2),\n        (0, 2, R_OH**2),\n        (1, 2, r_hh_sq)\n    ]\n\n    r_pqs = [positions[p] - positions[q] for p, q, _ in constraint_defs]\n    r_pq_norms = [np.linalg.norm(rpq) for rpq in r_pqs]\n    \n    # Precompute alpha denominators for lambda calculation\n    alphas = []\n    for (p, q, _), rpq in zip(constraint_defs, r_pqs):\n        alpha = np.dot(rpq, rpq) * (1.0 / masses[p] + 1.0 / masses[q])\n        alphas.append(alpha)\n\n    #\n    # Step 2: Define Stabilization and Helper Functions\n    #\n    def calculate_ke(m, v):\n        \"\"\"Calculates total kinetic energy.\"\"\"\n        ke = 0.0\n        for i in range(len(m)):\n            ke += 0.5 * m[i] * np.dot(v[i], v[i])\n        return ke\n\n    def stabilize(v_init, rtol, max_sweeps):\n        \"\"\"Performs Gauss-Seidel velocity stabilization.\"\"\"\n        v = v_init.copy()\n        \n        for _ in range(max_sweeps):\n            # Convergence check after a full sweep\n            total_mass = np.sum(masses)\n            total_ke = calculate_ke(masses, v)\n            if total_ke == 0:\n                # If all velocities are zero, residuals are zero\n                max_rho = 0.0\n            else:\n                v_rms = np.sqrt(2 * total_ke / total_mass)\n                max_rho = 0.0\n                for i, (p, q, _) in enumerate(constraint_defs):\n                    s_k = np.dot(r_pqs[i], v[p] - v[q])\n                    rho_k = abs(s_k) / (r_pq_norms[i] * v_rms)\n                    if rho_k > max_rho:\n                        max_rho = rho_k\n            \n            if max_rho = rtol:\n                return v, max_rho\n\n            for i, (p, q, _) in enumerate(constraint_defs):\n                s_k = np.dot(r_pqs[i], v[p] - v[q])\n                lambda_k = -s_k / alphas[i]\n                \n                v[p] += (lambda_k / masses[p]) * r_pqs[i]\n                v[q] -= (lambda_k / masses[q]) * r_pqs[i]\n        \n        # If max_sweeps is reached, calculate and return final residual\n        total_mass = np.sum(masses)\n        total_ke = calculate_ke(masses, v)\n        if total_ke == 0:\n            max_rho = 0.0\n        else:\n            v_rms = np.sqrt(2 * total_ke / total_mass)\n            max_rho = 0.0\n            for i, (p, q, _) in enumerate(constraint_defs):\n                s_k = np.dot(r_pqs[i], v[p] - v[q])\n                rho_k = abs(s_k) / (r_pq_norms[i] * v_rms)\n                if rho_k > max_rho:\n                    max_rho = rho_k\n                    \n        return v, max_rho\n\n    #\n    # Step 3: Define Test Cases\n    #\n    # Case A\n    v_a = np.array([\n        [300.0, -200.0, 100.0],\n        [1500.0, 2000.0, -1000.0],\n        [-1200.0, 800.0, 600.0]\n    ])\n\n    # Case B\n    omega_b = np.array([0.0, 5.0e11, 0.0])\n    total_mass_b = np.sum(masses)\n    r_com_b = (masses[0] * positions[0] + masses[1] * positions[1] + masses[2] * positions[2]) / total_mass_b\n    v_b = np.array([\n        np.cross(omega_b, positions[0] - r_com_b),\n        np.cross(omega_b, positions[1] - r_com_b),\n        np.cross(omega_b, positions[2] - r_com_b)\n    ])\n    \n    # Case C\n    v_c = np.array([\n        [0.0, 0.0, 0.0],\n        [20000.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0]\n    ])\n    \n    test_cases = [v_a, v_b, v_c]\n    \n    #\n    # Step 4: Run Simulations and Apply Selection Logic\n    #\n    candidate_rtols = [1e-2, 1e-4, 1e-6, 1e-8, 1e-10]\n    rho_target = 1e-6\n    max_sweeps = 200\n    \n    final_results = []\n    \n    for v_initial in test_cases:\n        t_before = calculate_ke(masses, v_initial)\n        \n        results_per_case = []\n        for rtol in candidate_rtols:\n            v_final, max_rho_final = stabilize(v_initial, rtol, max_sweeps)\n            t_after = calculate_ke(masses, v_final)\n            delta_t = t_after - t_before\n            \n            results_per_case.append({\n                'rtol': rtol,\n                'max_rho': max_rho_final,\n                'delta_T': delta_t\n            })\n\n        # Apply selection logic\n        achieved_target = [res for res in results_per_case if res['max_rho'] = rho_target]\n        \n        if achieved_target:\n            # Minimize |delta_T| among those meeting the target\n            best_res = min(achieved_target, key=lambda x: abs(x['delta_T']))\n        else:\n            # Minimize max_rho, then |delta_T|, then maximize rtol\n            # Note: min on -rtol maximizes rtol\n            best_res = min(results_per_case, key=lambda x: (x['max_rho'], abs(x['delta_T']), -x['rtol']))\n\n        final_results.append([best_res['rtol'], best_res['delta_T']])\n\n    #\n    # Step 5: Format and Print Final Output\n    #\n    output_str = f\"[{','.join(map(str, final_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}