{
    "hands_on_practices": [
        {
            "introduction": "任何粒子网格埃瓦尔德（PME）计算的第一步都是将离散的粒子点电荷映射到规则的网格上，以创建一个平滑的电荷密度。本练习  将指导您从电荷守恒等基本原理出发，推导广泛使用的“单元内云”（Cloud-in-Cell, CIC）插值方案。掌握这一推导过程对于理解PME方法如何将基于粒子的描述与基于网格的连续介质描述无缝连接起来至关重要。",
            "id": "3849522",
            "problem": "在粒子网格埃瓦尔德（PME）方法中，一个关键步骤是将点电荷分配到一个网格上，以获得一个适合在傅里叶空间中求解泊松方程的光滑网格电荷密度。考虑一个三维均匀笛卡尔网格，其沿 $x$、$y$ 和 $z$ 轴的间距分别为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$。一个电荷为 $q$ 的粒子位于位置 $\\mathbf{r} = (x,y,z)$，处在一个网格单元内部。该单元由左下近角的节点索引 $(i,j,k)$ 和右上远角的节点索引 $(i+1,j+1,k+1)$ 界定。定义分数偏移量\n$$\nu_x = \\frac{x - x_i}{\\Delta x}, \\quad u_y = \\frac{y - y_j}{\\Delta y}, \\quad u_z = \\frac{z - z_k}{\\Delta z},\n$$\n其中 $x_i = i \\,\\Delta x$、$y_j = j \\,\\Delta y$ 和 $z_k = k \\,\\Delta z$，并假设 $u_x,u_y,u_z \\in [0,1)$。\n\n从适用于多尺度材料模拟和基于网格插值的第一性原理出发，仅使用以下基本要求来推导至八个最近网格节点的云中粒子（CIC）电荷分配权重：\n- 电荷守恒：分配的权重分数之和为一。\n- 局域性：只有包含粒子单元的八个最近节点获得非零权重。\n- 一维线性一致性：当限制在单个轴上时，分配简化为两个相邻节点之间的线性插值。\n- 笛卡尔网格上的张量积可分性：三维分配是沿每个轴的一维分配的乘积。\n\n推导八个无量纲权重 $w_n$ ($n=1,\\dots,8$) 的显式解析表达式，这些权重对应于按以下顺序排列的节点：\n$$\n(i,j,k),\\ (i+1,j,k),\\ (i,j+1,k),\\ (i+1,j+1,k),\\ (i,j,k+1),\\ (i+1,j,k+1),\\ (i,j+1,k+1),\\ (i+1,j+1,k+1).\n$$\n将最终答案表示为一个包含八个 $w_n$（按此顺序）的单行向量，用 $u_x$、$u_y$ 和 $u_z$ 表示。不包含单位。最终答案必须是单个解析表达式。",
            "solution": "该问题具有科学依据、良定、客观，并包含推导所要求的电荷分配权重所需的所有必要信息。因此，该问题被视为有效，并提供解答。\n\n推导过程从给定的基本要求出发。我们首先确定一维插值权重的形式，然后使用张量积可分性原理将其扩展到三维。\n\n一维线性一致性的要求指出，分配简化为线性插值。考虑 $x$ 轴。一个分数坐标为 $u_x \\in [0,1)$ 的粒子位于整数索引为 $i$ 和 $i+1$ 的网格节点之间。设 $W_i(u_x)$ 和 $W_{i+1}(u_x)$ 分别是分配给节点 $i$ 和 $i+1$ 的无量纲权重。对于线性插值，权重必须是 $u_x$ 的线性函数。\n当粒子恰好位于节点 $i$ 上时，其分数坐标为 $u_x=0$。粒子的全部电荷必须分配给节点 $i$。这给出了边界条件 $W_i(0) = 1$ 和 $W_{i+1}(0) = 0$。\n当粒子恰好位于节点 $i+1$ 上时，其分数坐标为 $u_x=1$。粒子的全部电荷必须分配给节点 $i+1$。这给出了边界条件 $W_i(1) = 0$ 和 $W_{i+1}(1) = 1$。\n满足条件 $W_i(0) = 1$ 和 $W_i(1) = 0$ 的唯一线性函数是：\n$$\nW_i(u_x) = 1 - u_x\n$$\n满足条件 $W_{i+1}(0) = 0$ 和 $W_{i+1}(1) = 1$ 的唯一线性函数是：\n$$\nW_{i+1}(u_x) = u_x\n$$\n这些是一维云中粒子（CIC）权重。我们验证一维电荷守恒：权重之和为 $W_i(u_x) + W_{i+1}(u_x) = (1 - u_x) + u_x = 1$。这与电荷守恒的要求一致。\n\n接下来，我们使用笛卡尔网格上的张量积可分性要求来构建三维权重。分配给一个节点的权重是每个坐标的一维权重的乘积。粒子位于其左下近角为节点 $(i,j,k)$ 的单元中。该单元的八个节点由 $(i+l, j+m, k+p)$ 索引，其中 $l, m, p \\in \\{0,1\\}$。\n分数坐标为 $u_x$、$u_y$ 和 $u_z$。分配给节点 $(i+l,j+m,k+p)$ 的权重 $w_{i+l,j+m,k+p}$ 由下式给出：\n$$\nw_{i+l,j+m,k+p} = W_l(u_x) W_m(u_y) W_p(u_z)\n$$\n其中，我们将一维权重函数推广为：对于任意给定轴上的“下”节点，权重函数为 $W_0(u) = 1-u$；对于“上”节点，权重函数为 $W_1(u) = u$。\n代入这些可得到分配给节点 $(i+l,j+m,k+p)$ 的权重的通用公式：\n$$\nw_{i+l,j+m,k+p} = (1-u_x)^{1-l} (u_x)^l (1-u_y)^{1-m} (u_y)^m (1-u_z)^{1-p} (u_z)^p\n$$\n局域性要求通过此构造得到满足，因为只有单元的八个节点（其中 $l,m,p \\in \\{0,1\\}$）获得非零权重。系统中的所有其他节点获得的权重均为零。\n总电荷守恒也由张量积结构保证：\n$$\n\\sum_{l=0}^{1} \\sum_{m=0}^{1} \\sum_{p=0}^{1} w_{i+l,j+m,k+p} = \\left( \\sum_{l=0}^{1} W_l(u_x) \\right) \\left( \\sum_{m=0}^{1} W_m(u_y) \\right) \\left( \\sum_{p=0}^{1} W_p(u_z) \\right)\n$$\n由于括号中的每个和都等于 1，所有八个权重的总和为 $1 \\times 1 \\times 1 = 1$。\n\n我们现在列出与指定的节点顺序相对应的八个权重 $w_n$（$n=1, \\dots, 8$）的显式表达式。\n对于节点 $(i,j,k)$，我们有 $(l,m,p)=(0,0,0)$，因此权重为 $w_1 = W_0(u_x)W_0(u_y)W_0(u_z) = (1-u_x)(1-u_y)(1-u_z)$。\n对于节点 $(i+1,j,k)$，我们有 $(l,m,p)=(1,0,0)$，因此权重为 $w_2 = W_1(u_x)W_0(u_y)W_0(u_z) = u_x(1-u_y)(1-u_z)$。\n对于节点 $(i,j+1,k)$，我们有 $(l,m,p)=(0,1,0)$，因此权重为 $w_3 = W_0(u_x)W_1(u_y)W_0(u_z) = (1-u_x)u_y(1-u_z)$。\n对于节点 $(i+1,j+1,k)$，我们有 $(l,m,p)=(1,1,0)$，因此权重为 $w_4 = W_1(u_x)W_1(u_y)W_0(u_z) = u_x u_y (1-u_z)$。\n对于节点 $(i,j,k+1)$，我们有 $(l,m,p)=(0,0,1)$，因此权重为 $w_5 = W_0(u_x)W_0(u_y)W_1(u_z) = (1-u_x)(1-u_y)u_z$。\n对于节点 $(i+1,j,k+1)$，我们有 $(l,m,p)=(1,0,1)$，因此权重为 $w_6 = W_1(u_x)W_0(u_y)W_1(u_z) = u_x(1-u_y)u_z$。\n对于节点 $(i,j+1,k+1)$，我们有 $(l,m,p)=(0,1,1)$，因此权重为 $w_7 = W_0(u_x)W_1(u_y)W_1(u_z) = (1-u_x)u_y u_z$。\n对于节点 $(i+1,j+1,k+1)$，我们有 $(l,m,p)=(1,1,1)$，因此权重为 $w_8 = W_1(u_x)W_1(u_y)W_1(u_z) = u_x u_y u_z$。\n\n这八个表达式构成了推导出的云中粒子分配权重。它们代表了分配给周围八个网格节点中每一个的粒子电荷 $q$ 的分数。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(1-u_x)(1-u_y)(1-u_z) & u_x(1-u_y)(1-u_z) & (1-u_x)u_y(1-u_z) & u_x u_y (1-u_z) & (1-u_x)(1-u_y)u_z & u_x(1-u_y)u_z & (1-u_x)u_y u_z & u_x u_y u_z\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一旦电荷被分配到网格上，我们就可以利用快速傅里叶变换（FFT）的高效性来求解长程静电相互作用。这个编程练习  将引导您构建PME算法的核心流程：对电荷密度进行傅里叶变换，在倒易空间中求解泊松方程，最后将计算出的力插值回每个粒子上。这个实践将揭开PME“黑箱”的神秘面纱，让您亲身体验其计算引擎的工作原理。",
            "id": "3282499",
            "problem": "您需要实现一个简化的三维质点网格Ewald (PME) 方法，使用快速傅里叶变换 (FFT) 在一个周期性立方体区域内评估长程静电力。目标是在周期性边界条件和无量纲单位下，仅计算由倒易空间（长程）分量产生的粒子作用力。实现必须是完全自洽的，并严格使用快速傅里叶变换 (FFT) 作为计算加速器。\n\n计算区域是一个边长为 $L=1$ 的周期性立方体。所有位置都以 $[0,1)$ 范围内的简约坐标给出，所有电荷都是无量纲的，力也必须以无量纲单位返回。不需要也不允许进行任何物理单位转换。在此设定中角度单位不适用。\n\n您必须从离散傅里叶变换和泊松方程的基本原理和定义出发，但问题描述没有为PME实现提供任何简便公式。您的方法必须从第一性原理推导：将电荷映射到网格上，通过FFT和屏蔽格林函数计算倒易空间中的势，在傅里叶空间中微分以获得电场，变换回实空间，并在粒子位置上插值计算力。\n\n算法规范：\n- 区域是一个边长为 $L=1$ 的周期性立方体，离散化为一个 $N \\times N \\times N$ 点的均匀网格。\n- 使用 Cloud-In-Cell (CIC) 电荷分配方案将粒子电荷放置到网格上。\n- 使用三维快速傅里叶变换 (FFT) 将网格电荷密度转换到倒易空间。\n- 应用一个由正屏蔽参数 $\\alpha$ 表征的屏蔽倒易空间格林函数来计算长程势。零模式 $\\mathbf{k}=\\mathbf{0}$ 必须设置为零，以强制周期性单元的电中性。\n- 通过在倒易空间中对势进行微分来计算电场。\n- 使用逆FFT返回实空间，并使用相同的CIC权重在粒子位置上插值电场。粒子 $i$ 上的力是其电荷 $q_i$ 乘以其位置处插值得到的电场。\n- 在整个过程中严格使用无量纲量。\n\n测试套件：\n实现您的程序，使其无需任何用户输入即可精确运行以下四个测试用例。对于每个用例，$N$ 表示网格大小，$\\alpha$ 表示屏蔽参数，$q_i$ 是粒子电荷，$\\mathbf{r}_i$ 是单位立方体内的粒子简约坐标。\n1. 正常路径用例：$N=16$，$\\alpha=3.5$，两个粒子，电荷为 $[1.0,-1.0]$，位置为 $\\mathbf{r}_1=[0.25,0.25,0.25]$，$\\mathbf{r}_2=[0.75,0.75,0.75]$。\n2. 边界放置用例：$N=16$，$\\alpha=2.5$，三个粒子，电荷为 $[1.0,-0.5,0.5]$，位置为 $\\mathbf{r}_1=[0.99,0.01,0.5]$，$\\mathbf{r}_2=[0.1,0.9,0.1]$，$\\mathbf{r}_3=[0.4,0.4,0.95]$。\n3. 零电荷边缘用例：$N=8$，$\\alpha=2.0$，四个粒子，电荷为 $[0.0,0.0,0.0,0.0]$，位置为 $\\mathbf{r}_1=[0.2,0.3,0.4]$，$\\mathbf{r}_2=[0.6,0.2,0.1]$，$\\mathbf{r}_3=[0.8,0.8,0.8]$，$\\mathbf{r}_4=[0.1,0.7,0.9]$。\n4. 对称布局用例：$N=32$，$\\alpha=3.0$，四个粒子，电荷为 $[1.0,1.0,-1.0,-1.0]$，位置为 $\\mathbf{r}_1=[0.25,0.25,0.5]$，$\\mathbf{r}_2=[0.75,0.25,0.5]$，$\\mathbf{r}_3=[0.25,0.75,0.5]$，$\\mathbf{r}_4=[0.75,0.75,0.5]$。\n\n所需输出：\n对于每个测试用例，输出一个粒子力矢量列表，其中每个力矢量是包含三个浮点数 $[F_x,F_y,F_z]$ 的列表，单位为无量纲。将四个用例的列表聚合到一个总列表中。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，且不含空格。列表中的每个元素本身就是一个力矢量列表（例如，$[[[F_{x,1},F_{y,1},F_{z,1}],\\ldots],\\ldots]$）。\n\n您的实现必须：\n- 仅使用Python标准库和NumPy库。\n- 是确定性的，且无需输入。\n- 在电荷分配和场插值中一致地处理周期性边界条件。\n- 使用三维FFT计算倒易空间解。",
            "solution": "问题要求实现一个简化的三维质点网格Ewald（PME）方法，用以计算周期性立方体区域内一组带电粒子的长程静电力分量。该解决方案必须从基本原理推导得出。\n\n### 1. 基本原理：倒易空间中的静电学\n\n静电势 $\\phi(\\mathbf{r})$ 与电荷密度 $\\rho(\\mathbf{r})$ 之间的基本关系由泊松方程给出。在本问题指定的无量纲单位中，我们写作：\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})\n$$\n电场 $\\mathbf{E}(\\mathbf{r})$ 是势的负梯度：\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi(\\mathbf{r})\n$$\n系统定义在一个边长为 $L=1$ 的立方体盒子中，并具有周期性边界条件。此类问题天然地适合使用傅里叶级数处理，出于计算目的，这变成了离散傅里叶变换 (DFT)。周期性区域上的函数 $f(\\mathbf{r})$ 可以由其傅里叶系数 $\\tilde{f}(\\mathbf{k})$ 表示：\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\tilde{f}(\\mathbf{k}) e^{i\\mathbf{k} \\cdot \\mathbf{r}}\n$$\n其中波矢量 $\\mathbf{k}$ 由于周期性而是离散的：$\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z) = 2\\pi(n_x, n_y, n_z)$，因为 $L=1$，且 $n_x, n_y, n_z$ 为整数。\n\n在傅里叶空间中，梯度算子 $\\nabla$ 变换为乘以 $i\\mathbf{k}$，拉普拉斯算子 $\\nabla^2$ 变换为乘以 $-|\\mathbf{k}|^2$。将傅里叶变换应用于控制方程，得到它们的代数对应形式：\n$$\n-|\\mathbf{k}|^2 \\tilde{\\phi}(\\mathbf{k}) = -\\tilde{\\rho}(\\mathbf{k}) \\implies \\tilde{\\phi}(\\mathbf{k}) = \\frac{\\tilde{\\rho}(\\mathbf{k})}{|\\mathbf{k}|^2}\n$$\n$$\n\\tilde{\\mathbf{E}}(\\mathbf{k}) = -i\\mathbf{k} \\tilde{\\phi}(\\mathbf{k})\n$$\n\n### 2. 质点网格Ewald (PME) 方法\n\nPME方法通过在网格上求解一个平滑势，提供了一种计算长程力的有效方式。Ewald分解的核心思想是将点电荷替换为两种分布的叠加：一种用于短程相互作用的局域分布（不属于本问题范畴），以及一种用于倒易空间计算的平滑长程分布。平滑分布通常是每个粒子周围的高斯云。\n\n这种平滑化在倒易空间中的效果是在势的计算中引入一个阻尼因子。问题中指定的“屏蔽倒易空间格林函数”将来自泊松方程的 $1/|\\mathbf{k}|^2$ 项与一个依赖于屏蔽参数 $\\alpha$ 的高斯因子结合起来。因此，傅里叶空间中的势计算如下：\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\n其中 $\\tilde{\\rho}(\\mathbf{k})$ 是网格上电荷密度的傅里叶变换，$\\tilde{G}(\\mathbf{k})$ 是 PME 倒易空间核（或格林函数）：\n$$\n\\tilde{G}(\\mathbf{k}) = \\frac{\\exp(-|\\mathbf{k}|^2 / (4\\alpha^2))}{|\\mathbf{k}|^2}\n$$\n对于 $\\mathbf{k} = \\mathbf{0}$，分母 $|\\mathbf{k}|^2$ 为零，导致一个奇异点。该项对应于系统的平均势。对于一个在周期性盒子中整体电中性的系统，该项对力的贡献为零。问题要求将 $\\mathbf{k}=\\mathbf{0}$ 模式设置为零，这是标准做法。因此，我们定义 $\\tilde{G}(\\mathbf{0}) = 0$。\n\n### 3. 离散化与算法步骤\n\n连续场在一个均匀的 $N \\times N \\times N$ 网格上被离散化。连续傅里叶变换被离散傅里叶变换（DFT）替代，后者通过快速傅里叶变换（FFT）算法高效计算。设网格间距为 $h = L/N = 1/N$。\n\n#### 步骤 1：电荷分配\n粒子电荷在连续表示中是δ函数，必须被转移到离散网格上。这里使用 Cloud-in-Cell (CIC) 或三线性插值方案。对于一个电荷为 $q_i$、简约坐标为 $\\mathbf{r}_i = (u_i, v_i, w_i) \\in [0,1)^3$ 的粒子 $i$，其缩放坐标为 $\\mathbf{s}_i = N\\mathbf{r}_i$。$\\mathbf{s}_i$ 的整数部分标识了主网格单元，$\\mathbf{n}_i = (\\lfloor s_{ix} \\rfloor, \\lfloor s_{iy} \\rfloor, \\lfloor s_{iz} \\rfloor)$，小数部分给出了在该单元内的位移，$\\mathbf{d}_i = \\mathbf{s}_i - \\mathbf{n}_i$。\n\n电荷 $q_i$ 被分配到包含 $\\mathbf{s}_i$ 的单元的 8 个角点上。分配给距离 $\\mathbf{n}_i$ 偏移量为 $(\\delta_x, \\delta_y, \\delta_z)$（其中 $\\delta_j \\in \\{0,1\\}$）的角点的电荷为：\n$$\n\\Delta\\rho = q_i \\cdot W_x(\\delta_x) \\cdot W_y(\\delta_y) \\cdot W_z(\\delta_z)\n$$\n其中权重因子为 $W_j(\\delta_j) = (1-d_{ij})^{1-\\delta_j} d_{ij}^{\\delta_j}$。对所有粒子执行此过程，在网格 $\\rho_{\\text{grid}}$ 上累积电荷。网格索引对 $N$ 取模以强制周期性。\n\n#### 步骤 2：电荷密度的傅里叶变换\n网格化电荷密度 $\\rho_{\\text{grid}}$ 使用三维 FFT 变换到倒易空间：\n$$\n\\tilde{\\rho}(\\mathbf{k}) = \\text{FFT3D}[\\rho_{\\text{grid}}]\n$$\n\n#### 步骤 3：倒易空间计算\n势和电场在傅里叶空间中计算。首先，构建离散波矢量 $\\mathbf{k} = 2\\pi(n_x, n_y, n_z)$ 的网格，其中 $n_x, n_y, n_z$ 是对应于 FFT 网格索引的整数频率。然后，计算所有 $\\mathbf{k}$ 的格林函数 $\\tilde{G}(\\mathbf{k})$，并设 $\\tilde{G}(\\mathbf{0})=0$。通过逐元素相乘找到势：\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\n然后计算电场分量：\n$$\n\\tilde{E}_x(\\mathbf{k}) = -i k_x \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_y(\\mathbf{k}) = -i k_y \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_z(\\mathbf{k}) = -i k_z \\tilde{\\phi}(\\mathbf{k})\n$$\n\n#### 步骤 4：逆傅里叶变换\n网格上的电场 $\\mathbf{E}_{\\text{grid}}$ 是通过对 $\\tilde{\\mathbf{E}}(\\mathbf{k})$ 的每个分量应用三维逆 FFT 得到的：\n$$\n\\mathbf{E}_{\\text{grid}}(\\mathbf{r}) = \\text{iFFT3D}[\\tilde{\\mathbf{E}}(\\mathbf{k})]\n$$\niFFT 的结果将是一个复数数组；物理场是它的实部。\n\n#### 步骤 5：力插值与计算\n为了找到每个粒子上的力，必须将电场从网格插值回粒子位置。为保持一致性并确保动量守恒（即 $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$），应用与电荷分配相同的 CIC 插值方案。粒子 $i$ 位置 $\\mathbf{r}_i$ 处的电场是其周围 8 个网格点上场值的加权平均：\n$$\n\\mathbf{E}(\\mathbf{r}_i) = \\sum_{\\text{8 neighbors } \\mathbf{g}} \\mathbf{E}_{\\text{grid}}(\\mathbf{g}) \\cdot W(\\mathbf{r}_i, \\mathbf{g})\n$$\n其中权重 $W$ 与步骤 1 中的三线性权重相同。最后，粒子 $i$ 上的力计算如下：\n$$\n\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)\n$$\n对所有粒子和提供的每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list_no_spaces(item):\n    \"\"\"\n    Recursively formats a nested list or numpy array into a string\n    with no spaces, as per the strict output format requirement.\n    \"\"\"\n    if isinstance(item, (list, np.ndarray)):\n        return \"[\" + \",\".join(format_list_no_spaces(x) for x in item) + \"]\"\n    # Format floats to have a reasonable number of decimal places for consistency\n    if isinstance(item, float):\n        return f\"{item:.8f}\"\n    return str(item)\n\ndef solve_pme_case(N, alpha, charges, positions):\n    \"\"\"\n    Computes reciprocal-space electrostatic forces for one test case.\n    \"\"\"\n    # Box length L=1 is assumed throughout.\n    L = 1.0\n    \n    # Step 1: Charge Assignment (CIC)\n    rho = np.zeros((N, N, N), dtype=float)\n    num_particles = len(charges)\n    # Store particle info for interpolation later\n    particle_info = []\n\n    for i in range(num_particles):\n        q_i = charges[i]\n        r_i = np.array(positions[i]) # Reduced coordinates [0, 1)\n\n        s_i = r_i * N\n        n_i = np.floor(s_i).astype(int)\n        d_i = s_i - n_i\n\n        particle_info.append({'n': n_i, 'd': d_i})\n\n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n                    \n                    weight = wx * wy * wz\n                    rho[x_idx, y_idx, z_idx] += q_i * weight\n    \n    # Step 2: FFT of charge density\n    rho_k = np.fft.fftn(rho)\n\n    # Step 3: Reciprocal Space Calculation\n    # Generate wave vectors k\n    kx_int = np.fft.fftfreq(N) * N\n    ky_int = np.fft.fftfreq(N) * N\n    kz_int = np.fft.fftfreq(N) * N\n    \n    kx = 2 * np.pi * kx_int / L\n    ky = 2 * np.pi * ky_int / L\n    kz = 2 * np.pi * kz_int / L\n    \n    kx_grid, ky_grid, kz_grid = np.meshgrid(kx, ky, kz, indexing='ij')\n\n    k_squared = kx_grid**2 + ky_grid**2 + kz_grid**2\n    \n    # Calculate reciprocal Green's function G_k\n    G_k = np.zeros((N, N, N), dtype=float)\n    # Avoid division by zero at k=0\n    non_zero_k = k_squared != 0\n    G_k[non_zero_k] = np.exp(-k_squared[non_zero_k] / (4 * alpha**2)) / k_squared[non_zero_k]\n    # k=0 mode is explicitly set to 0. It is already 0 from initialization.\n\n    # Calculate potential and field in Fourier space\n    phi_k = G_k * rho_k\n    \n    Ex_k = -1j * kx_grid * phi_k\n    Ey_k = -1j * ky_grid * phi_k\n    Ez_k = -1j * kz_grid * phi_k\n\n    # Step 4: Inverse FFT to get E-field on the grid\n    Ex_grid = np.real(np.fft.ifftn(Ex_k))\n    Ey_grid = np.real(np.fft.ifftn(Ey_k))\n    Ez_grid = np.real(np.fft.ifftn(Ez_k))\n\n    # Step 5  6: Force Interpolation and Calculation\n    forces = []\n    for i in range(num_particles):\n        q_i = charges[i]\n        n_i = particle_info[i]['n']\n        d_i = particle_info[i]['d']\n        \n        E_interp = np.zeros(3, dtype=float)\n        \n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n\n                    weight = wx * wy * wz\n                    E_interp[0] += Ex_grid[x_idx, y_idx, z_idx] * weight\n                    E_interp[1] += Ey_grid[x_idx, y_idx, z_idx] * weight\n                    E_interp[2] += Ez_grid[x_idx, y_idx, z_idx] * weight\n        \n        force_i = q_i * E_interp\n        forces.append(force_i.tolist())\n    \n    return forces\n\n\ndef main():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 16, \"alpha\": 3.5, \"charges\": [1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.25], [0.75, 0.75, 0.75]]\n        },\n        {\n            \"N\": 16, \"alpha\": 2.5, \"charges\": [1.0, -0.5, 0.5],\n            \"positions\": [[0.99, 0.01, 0.5], [0.1, 0.9, 0.1], [0.4, 0.4, 0.95]]\n        },\n        {\n            \"N\": 8, \"alpha\": 2.0, \"charges\": [0.0, 0.0, 0.0, 0.0],\n            \"positions\": [[0.2, 0.3, 0.4], [0.6, 0.2, 0.1], [0.8, 0.8, 0.8], [0.1, 0.7, 0.9]]\n        },\n        {\n            \"N\": 32, \"alpha\": 3.0, \"charges\": [1.0, 1.0, -1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.5], [0.75, 0.25, 0.5], [0.25, 0.75, 0.5], [0.75, 0.75, 0.5]]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_pme_case(case[\"N\"], case[\"alpha\"], case[\"charges\"], case[\"positions\"])\n        all_results.append(result)\n\n    # Reformat the output to match the expected precision in typical test runners\n    formatted_results = []\n    for case_result in all_results:\n        formatted_case = []\n        for force_vector in case_result:\n            formatted_vector = [f\"{val:.8f}\" for val in force_vector]\n            # Convert back to list of floats for final formatting if needed, but strings are fine\n            formatted_case.append([float(v) for v in formatted_vector])\n        formatted_results.append(formatted_case)\n    \n    # Final print statement in the exact required format (no spaces).\n    # The custom formatter is changed to produce a consistent number of decimal places.\n    print(format_list_no_spaces(formatted_results))\n\n# In a typical execution environment, the main function would be called.\nif __name__ == '__main__':\n    main()\n```"
        },
        {
            "introduction": "PME模拟的准确性在很大程度上取决于其参数的选择，这需要在实空间截断半径 $r_c$ 和倒易空间网格大小 $M$ 之间取得精妙的平衡。在最后一个练习  中，您将分析这种权衡关系，以推导在给定目标精度下这些参数之间的最优关系。这项技能对于进行可靠且高效的分子模拟至关重要。",
            "id": "3849516",
            "problem": "考虑一个边长为 $L$ 的周期性立方模拟单元，其中包含 $N$ 个带电粒子。长程静电作用通过粒子网格Ewald (PME) 方法进行计算。其中，基本的 Ewald 分解引入了参数为 $\\alpha$ 的高斯屏蔽，实空间相互作用在截断半径 $r_c$ 处被截断，而倒易空间的贡献则在每个笛卡尔方向上具有 $M$ 个点的均匀网格上计算。在这种设置下，主要的实空间截断误差来自于余补误差函数的尾部 $O\\!\\left(\\operatorname{erfc}(\\alpha r_c)\\right)$，而主要的倒易空间网格混叠或截断误差由高斯因子 $e^{-k^2/(4\\alpha^2)}$ 控制，该因子在由网格分辨率决定的最大可靠表示波数 $k_{\\max}$ 处取值。对于一个边长为 $L$ 的盒子中、每个方向有 $M$ 个点的网格上进行的标准三维快速傅里叶变换 (FFT)，取 $k_{\\max} \\approx \\pi M/L$ 在物理上是合理的。\n\n从这些核心事实和库仑核的 Ewald 分解出发，通过令实空间截断和倒易空间混叠/截断中的主导渐近衰减相等，推导 $r_c$ 和 $M$ 之间的误差平衡权衡关系。然后，推断对于一个固定的目标容差 $\\varepsilon$，这种权衡关系如何约束 $r_c$ 和 $M$（忽略对于标度分析不重要的乘法性无量纲前置因子）。选择所有与误差平衡最优条件一致的陈述。\n\nA. 在误差平衡最优条件下，主导指数项的参数相等，这意味着 $\\alpha r_c \\approx \\dfrac{\\pi M}{2\\alpha L}$。\n\nB. 对于固定的容差 $\\varepsilon$，乘积 $M r_c$ 受 $M r_c \\propto L\\ln\\!\\left(\\dfrac{1}{\\varepsilon}\\right)$ 约束（忽略一个常数前置因子），即 $M \\propto \\dfrac{L}{r_c}\\ln\\!\\left(\\dfrac{1}{\\varepsilon}\\right)$。\n\nC. 在保持 $\\varepsilon$ 和 $L$ 固定的情况下，如果 $r_c$ 加倍，为了在误差平衡最优条件下保持相同的误差水平，$M$ 应该减半（忽略前置因子）。\n\nD. 在误差平衡最优条件下，$\\alpha$ 随 $M$ 线性标度，关系为 $\\alpha \\approx \\dfrac{\\pi M}{L r_c}$。\n\nE. 为了在固定的 $\\varepsilon$ 和 $L$ 下最小化计算成本，误差平衡下的最优选择满足 $M\\propto r_c$，从而使得实空间邻居列表大小和倒易空间网格大小一同增加。",
            "solution": "该问题要求分析粒子网格Ewald (PME) 方法中实空间截断半径 $r_c$ 和倒易空间网格大小 $M$ 之间的误差平衡权衡。推导将基于令实空间和倒易空间贡献的主导阶渐近误差项相等。\n\n### 第一步：问题验证\n\n**1. 提取已知条件：**\n- 系统：一个边长为 $L$ 的周期性立方模拟单元。\n- 内容：$N$ 个带电粒子。\n- 方法：粒子网格Ewald (PME)。\n- Ewald 分解参数：$\\alpha$。\n- 实空间截断半径：$r_c$。\n- 倒易空间网格：每个笛卡尔方向上均匀分布 $M$ 个点。\n- 实空间截断误差：$O(\\operatorname{erfc}(\\alpha r_c))$。\n- 倒易空间混叠/截断误差：由高斯因子 $e^{-k^2/(4\\alpha^2)}$ 在 $k_{\\max}$ 处的值控制。\n- 最大波数：$k_{\\max} \\approx \\pi M/L$。\n- 目标：通过平衡实空间和倒易空间的误差来达到固定的目标容差 $\\varepsilon$。\n\n**2. 对照标准进行验证：**\n- **科学基础**：问题陈述坚实地基于Ewald求和及其PME实现的准则理论。实空间误差（与余补误差函数相关）和倒易空间误差（与傅里叶变换后的高斯函数相关）的表达式都是权威性的。基于网格大小 $M$ 和盒子长度 $L$ 对 $k_{\\max}$ 的近似，是一个标准结果，源于奈奎斯特-香农采样定理应用于网格上的离散傅里叶变换。\n- **适定性**：该问题是适定的。它要求基于一个清晰的物理指令进行推导：平衡主导误差项。这导出了参数之间一个唯一、稳定且有意义的关系。\n- **客观性**：问题以精确、客观、技术性的语言陈述，不含任何主观性。\n- **缺陷检查**：该问题未违反任何指定的无效标准。它在科学上是合理的，可形式化的，完整的，现实的，并且结构良好。\n\n**3. 结论：**\n问题陈述有效。我现在将进行推导和分析。\n\n### 第二步：误差平衡权衡的推导\n\nPME中误差平衡的核心原则是，将主导的实空间和倒易空间误差贡献设置得大致相等，使得每一项都与期望的总精度 $\\varepsilon$ 处于同一量级。\n\n**1. 实空间误差：**\n实空间误差的量级由余补误差函数给出，$\\varepsilon_{real} \\sim O(\\operatorname{erfc}(\\alpha r_c))$。对于大自变量 $x \\gg 1$，余补误差函数的渐近展开为 $\\operatorname{erfc}(x) \\approx \\frac{e^{-x^2}}{x\\sqrt{\\pi}}$。主导的指数衰减项是 $e^{-x^2}$。\n因此，实空间误差的主导衰减由以下公式决定：\n$$\n\\varepsilon_{real} \\sim e^{-(\\alpha r_c)^2}\n$$\n\n**2. 倒易空间误差：**\n倒易空间误差据称由高斯因子 $e^{-k^2/(4\\alpha^2)}$ 在最大可表示波数 $k_{\\max} \\approx \\pi M/L$ 处的值控制。该误差源于有限网格导致的混叠和截断。该误差的主导衰减由以下公式决定：\n$$\n\\varepsilon_{recip} \\sim e^{-k_{\\max}^2 / (4\\alpha^2)} \\approx e^{-(\\pi M/L)^2 / (4\\alpha^2)} = e^{-\\frac{\\pi^2 M^2}{4\\alpha^2 L^2}}\n$$\n\n**3. 误差平衡条件：**\n为了平衡误差，我们令主导的指数项相等。这等同于令指数的参数相等：\n$$\n(\\alpha r_c)^2 \\approx \\frac{\\pi^2 M^2}{4\\alpha^2 L^2}\n$$\n这是误差平衡的PME计算的基本关系。\n\n**4. 对于固定容差 $\\varepsilon$ 的约束：**\n对于一个固定的目标精度 $\\varepsilon$，两部分的误差贡献都应该在 $\\varepsilon$ 的量级。\n$$\n\\varepsilon_{real} \\sim e^{-(\\alpha r_c)^2} \\approx \\varepsilon \\implies (\\alpha r_c)^2 \\approx \\ln\\left(\\frac{1}{\\varepsilon}\\right)\n$$\n同样，对于倒易空间误差：\n$$\n\\varepsilon_{recip} \\sim e^{-\\frac{\\pi^2 M^2}{4\\alpha^2 L^2}} \\approx \\varepsilon \\implies \\frac{\\pi^2 M^2}{4\\alpha^2 L^2} \\approx \\ln\\left(\\frac{1}{\\varepsilon}\\right)\n$$\n这证实了对于给定的 $\\varepsilon$，令指数参数相等是实现平衡误差分布的正确步骤。\n\n从误差平衡条件 $(\\alpha r_c)^2 \\approx \\frac{\\pi^2 M^2}{4\\alpha^2 L^2}$，我们可以推导出权衡关系。让我们将 $(\\alpha r_c)^2 \\approx \\ln(1/\\varepsilon)$ 代入方程。首先，我们重新排列平衡条件，以求解倒易空间指数中的项。\n$$\n\\frac{\\pi M}{2\\alpha L} \\approx \\alpha r_c\n$$\n现在，由于两边都约等于 $\\sqrt{\\ln(1/\\varepsilon)}$，我们得到两个方程：\n1.  $\\alpha r_c \\approx \\sqrt{\\ln(1/\\varepsilon)}$\n2.  $\\frac{\\pi M}{2\\alpha L} \\approx \\sqrt{\\ln(1/\\varepsilon)}$\n\n从方程(2)中，我们可以解出 $\\alpha$：\n$$\n\\alpha \\approx \\frac{\\pi M}{2L\\sqrt{\\ln(1/\\varepsilon)}}\n$$\n现在，将这个 $\\alpha$ 的表达式代入方程(1)：\n$$\n\\left( \\frac{\\pi M}{2L\\sqrt{\\ln(1/\\varepsilon)}} \\right) r_c \\approx \\sqrt{\\ln(1/\\varepsilon)}\n$$\n两边同乘以 $2L\\sqrt{\\ln(1/\\varepsilon)}$ 得：\n$$\n\\pi M r_c \\approx 2L \\left( \\sqrt{\\ln(1/\\varepsilon)} \\right)^2\n$$\n$$\nM r_c \\approx \\frac{2L}{\\pi} \\ln\\left(\\frac{1}{\\varepsilon}\\right)\n$$\n这个最终方程表示了在固定的盒子大小 $L$ 和目标精度 $\\varepsilon$ 条件下，网格大小 $M$ 和实空间截断 $r_c$ 之间的权衡关系。\n\n### 第三步：分析所给选项\n\n**A. 在误差平衡最优条件下，主导指数项的参数相等，这意味着 $\\alpha r_c \\approx \\dfrac{\\pi M}{2\\alpha L}$。**\n推导始于令指数参数相等：$(\\alpha r_c)^2 \\approx \\frac{\\pi^2 M^2}{4\\alpha^2 L^2}$。两边直接开平方根得到 $\\alpha r_c \\approx \\frac{\\pi M}{2\\alpha L}$。这个陈述是误差平衡原则的直接且正确的结果。\n**结论：正确。**\n\n**B. 对于固定的容差 $\\varepsilon$，乘积 $M r_c$ 受 $M r_c \\propto L\\ln\\!\\left(\\dfrac{1}{\\varepsilon}\\right)$ 约束（忽略一个常数前置因子），即 $M \\propto \\dfrac{L}{r_c}\\ln\\!\\left(\\dfrac{1}{\\varepsilon}\\right)$。**\n我们推导出的权衡关系是 $M r_c \\approx \\frac{2L}{\\pi} \\ln(1/\\varepsilon)$。这表明乘积 $M r_c$ 与 $L \\ln(1/\\varepsilon)$ 成正比，比例常数为 $2/\\pi$。陈述的第二部分，$M \\propto \\frac{L}{r_c}\\ln(1/\\varepsilon)$，是第一部分的简单代数重排。此陈述与推导完全一致。\n**结论：正确。**\n\n**C. 在保持 $\\varepsilon$ 和 $L$ 固定的情况下，如果 $r_c$ 加倍，为了在误差平衡最优条件下保持相同的误差水平，$M$ 应该减半（忽略前置因子）。**\n根据在B中推导的关系，对于固定的 $\\varepsilon$ 和 $L$，乘积 $M r_c$ 近似为一个常数。设此常数为 $K$，则 $M r_c \\approx K$。如果我们将 $r_c$ 变为 $r'_c = 2r_c$，新的网格大小 $M'$ 必须满足 $M' r'_c \\approx K$。代入 $r'_c$：$M' (2r_c) \\approx K$。因为 $K \\approx M r_c$，我们有 $2 M' r_c \\approx M r_c$，这意味着 $M' \\approx M/2$。因此，将实空间截断加倍需要将倒易空间每个维度的网格点数减半，以保持相同的精度。\n**结论：正确。**\n\n**D. 在误差平衡最优条件下，$\\alpha$ 随 $M$ 线性标度，关系为 $\\alpha \\approx \\dfrac{\\pi M}{L r_c}$。**\n从对选项A的分析可知，平衡条件是 $\\alpha r_c \\approx \\frac{\\pi M}{2\\alpha L}$。这可以重排为 $\\alpha^2 \\approx \\frac{\\pi M}{2 L r_c}$，意味着 $\\alpha \\approx \\sqrt{\\frac{\\pi M}{2 L r_c}}$。因此，$\\alpha$ 的标度关系为 $\\sqrt{M/r_c}$，而不是 $M/r_c$。所提出的标度关系是错误的。\n**结论：错误。**\n\n**E. 为了在固定的 $\\varepsilon$ 和 $L$ 下最小化计算成本，误差平衡下的最优选择满足 $M\\propto r_c$，从而使得实空间邻居列表大小和倒易空间网格大小一同增加。**\n如选项B和C所确立的，误差平衡条件要求在固定的误差容差 $\\varepsilon$ 和盒子大小 $L$ 下，存在一个*反比*关系，$M \\propto 1/r_c$。而该陈述提出了一个正比关系，$M \\propto r_c$。这两种关系是矛盾的。成本最小化的目标是在由 $M r_c \\approx \\text{const.}$ 定义的曲线上找到最优点，而不是定义一个新的、相冲突的关系。在约束 $M r_c = K$ 的条件下，最小化总计算成本（一个关于 $r_c^3$ 和 $M^3 \\log M$ 的函数）会导出一个特定的最优 $r_c$ 和 $M$ 值，但这并不会改变它们在恒定误差曲线上基本存在的反比关系。\n**结论：错误。**",
            "answer": "$$\\boxed{ABC}$$"
        }
    ]
}