{
    "hands_on_practices": [
        {
            "introduction": "理论是实践的基石。在将Verlet算法应用于复杂系统之前，我们首先通过一个基础练习来剖析其核心机制。本题将Verlet算法应用于一个简谐振子——这是多尺度材料模拟中晶格振动等诸多物理现象的基石模型。通过推导其一步更新矩阵，你将能够清晰地看到算法如何将一个时间步长的动力学演化精确地映射为一个线性变换，从而加深对算法数学本质的理解 。",
            "id": "3852924",
            "problem": "在多尺度材料模拟中，诸如 Verlet 算法族之类的时间可逆和辛积分器被用于推进原子和粗粒化动力学变量，同时控制守恒量的长时间漂移。考虑一个被建模为谐振子的单一粗粒化模式，其质量为 $m$，刚度为 $k$，遵循牛顿第二定律 $m\\,\\ddot{x}(t)=-k\\,x(t)$。设离散时间步长为 $\\Delta t0$，并定义力 $F(x)=-k\\,x$ 和加速度 $a(x)=F(x)/m$。\n\n从时间 $t_n$ 时的相空间状态 $(x_n,v_n)$ 出发，使用速度 Verlet 算法将系统推进一个步长，该算法定义为在大小为 $\\Delta t$ 的一个步长内应用的以下序列：\n- 位置更新：$x_{n+1}=x_n+\\Delta t\\,v_n+\\tfrac{1}{2}(\\Delta t)^2\\,a(x_n)$，\n- 加速度刷新：$a(x_{n+1})=a(x)$ 在 $x=x_{n+1}$ 处求值，\n- 速度更新：$v_{n+1}=v_n+\\tfrac{1}{2}\\Delta t\\left[a(x_n)+a(x_{n+1})\\right]$。\n\n仅使用上述定义和牛顿第二定律，推导 $x_{n+1}$ 和 $v_{n+1}$ 关于 $x_n$、$v_n$、$m$、$k$ 和 $\\Delta t$ 的显式闭式表达式。然后将它们整合为一个单一的线性映射，写成一个 $2\\times 2$ 矩阵 $A(\\Delta t)$ 的形式，使得\n$$\n\\begin{pmatrix}\nx_{n+1}\\\\\nv_{n+1}\n\\end{pmatrix}\n=A(\\Delta t)\n\\begin{pmatrix}\nx_n\\\\\nv_n\n\\end{pmatrix}.\n$$\n用自然频率 $\\omega=\\sqrt{k/m}$ 和 $\\Delta t$ 表示你的最终矩阵，并尽可能简化。最终答案仅需提供矩阵 $A(\\Delta t)$。不需要进行数值计算，也无需四舍五入。",
            "solution": "该问题陈述经评估具有科学依据、适定且客观。它为应用于谐振子的速度 Verlet 算法提供了一套完整且一致的定义，并要求得出一个特定的、可推导的结果。所有必要信息均已提供，该任务是计算物理学中的一个标准练习。因此，该问题是有效的，并将推导求解。\n\n目标是找到 $2 \\times 2$ 矩阵 $A(\\Delta t)$，该矩阵表示应用于简谐振子的速度 Verlet 算法的单步传播子。第 $n$ 步的状态向量由 $\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$ 给出。更新后的状态向量为 $\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = A(\\Delta t) \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$。\n\n谐振子的控制运动方程是牛顿第二定律：\n$$m\\,\\ddot{x}(t) = -k\\,x(t)$$\n力是 $F(x) = -k\\,x$，加速度是 $a(x) = F(x)/m = -k\\,x/m$。\n我们将振子的自然频率定义为 $\\omega = \\sqrt{k/m}$，因此加速度可以写成：\n$$a(x) = -\\omega^2 x$$\n这意味着在时间 $t_n$ 和 $t_{n+1}$ 的加速度分别为 $a(x_n) = a_n = -\\omega^2 x_n$ 和 $a(x_{n+1}) = a_{n+1} = -\\omega^2 x_{n+1}$。\n\n速度 Verlet 算法由以下更新序列定义：\n1.  位置更新：$x_{n+1} = x_n + \\Delta t\\,v_n + \\frac{1}{2}(\\Delta t)^2\\,a_n$\n2.  速度更新：$v_{n+1} = v_n + \\frac{1}{2}\\Delta t\\left[a_n + a_{n+1}\\right]$\n\n我们现在将推导 $x_{n+1}$ 和 $v_{n+1}$ 关于 $x_n$ 和 $v_n$ 的显式表达式。\n\n首先，我们求 $x_{n+1}$ 的表达式。我们将 $a_n = -\\omega^2 x_n$ 代入位置更新方程：\n$$x_{n+1} = x_n + \\Delta t\\,v_n + \\frac{1}{2}(\\Delta t)^2 (-\\omega^2 x_n)$$\n按 $x_n$ 和 $v_n$ 分组各项：\n$$x_{n+1} = \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n$$\n该方程给出了矩阵 $A(\\Delta t)$ 的第一行。其分量为：\n$$A_{11} = 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2$$\n$$A_{12} = \\Delta t$$\n\n接下来，我们求 $v_{n+1}$ 的表达式。我们将加速度的表达式 $a_n = -\\omega^2 x_n$ 和 $a_{n+1} = -\\omega^2 x_{n+1}$ 代入速度更新方程：\n$$v_{n+1} = v_n + \\frac{1}{2}\\Delta t\\left[-\\omega^2 x_n - \\omega^2 x_{n+1}\\right]$$\n$$v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t (x_n + x_{n+1})$$\n目前这个 $v_{n+1}$ 的表达式依赖于 $x_{n+1}$。为了获得一个仅用时间 $t_n$ 的状态 $(x_n, v_n)$ 表示的表达式，我们必须代入先前推导出的 $x_{n+1}$ 的表达式：\n$$v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[ x_n + \\left( \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n \\right) \\right]$$\n现在，我们简化方括号中的项：\n$$x_n + \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n = \\left(2 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n$$\n将此代回 $v_{n+1}$ 的方程：\n$$v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[ \\left(2 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n \\right]$$\n将项 $-\\frac{1}{2}\\omega^2 \\Delta t$ 乘入方括号中：\n$$v_{n+1} = v_n - \\left( \\frac{1}{2}\\omega^2 \\Delta t \\cdot 2 - \\frac{1}{2}\\omega^2 \\Delta t \\cdot \\frac{1}{2}\\omega^2 (\\Delta t)^2 \\right) x_n - \\left( \\frac{1}{2}\\omega^2 \\Delta t \\cdot \\Delta t \\right) v_n$$\n$$v_{n+1} = v_n - \\left( \\omega^2 \\Delta t - \\frac{1}{4}\\omega^4 (\\Delta t)^3 \\right) x_n - \\frac{1}{2}\\omega^2 (\\Delta t)^2 v_n$$\n最后，我们按 $x_n$ 和 $v_n$ 分组各项：\n$$v_{n+1} = \\left( -\\omega^2 \\Delta t + \\frac{1}{4}\\omega^4 (\\Delta t)^3 \\right) x_n + \\left( 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2 \\right) v_n$$\n该方程给出了矩阵 $A(\\Delta t)$ 的第二行。其分量为：\n$$A_{21} = -\\omega^2 \\Delta t + \\frac{1}{4}\\omega^4 (\\Delta t)^3 = -\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)$$\n$$A_{22} = 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2$$\n$A_{21}$ 的表达式通过提取公因式 $-\\omega^2 \\Delta t$ 进行了简化。\n\n综合这些结果，线性映射为：\n$$\n\\begin{pmatrix}\nx_{n+1}\\\\\nv_{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2  \\Delta t \\\\\n-\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)  1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\n\\end{pmatrix}\n\\begin{pmatrix}\nx_n\\\\\nv_n\n\\end{pmatrix}\n$$\n因此，矩阵 $A(\\Delta t)$ 为：\n$$\nA(\\Delta t) =\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2  \\Delta t \\\\\n-\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)  1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\n\\end{pmatrix}\n$$\n这是用 $\\omega$ 和 $\\Delta t$ 表示的矩阵的最终简化形式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^{2} (\\Delta t)^{2}  \\Delta t \\\\\n-\\omega^{2} \\Delta t \\left(1 - \\frac{1}{4}\\omega^{2} (\\Delta t)^{2}\\right)  1 - \\frac{1}{2}\\omega^{2} (\\Delta t)^{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了Verlet算法的数学构造后，下一个关键步骤是亲手验证其优越的数值特性。本实践旨在通过编程来展示Verlet积分器最著名的性质之一：时间可逆性。你将模拟一个非线性单摆系统，先使其正向演化一段时间，然后反转其最终速度并反向演化相同时间，通过这种方式，你可以直观地验证算法在理论上的完美可逆性，并量化浮点数精度误差对结果的微小影响 。",
            "id": "2420944",
            "problem": "您需要研究无阻尼非线性单摆，其角位移 $\\theta(t)$ 由二阶常微分方程 $\\ddot{\\theta}(t) + \\dfrac{g}{L}\\sin(\\theta(t)) = 0$ 控制，其中 $g$ 是重力加速度，$L$ 是摆长。角度必须以弧度表示，时间以秒表示，角速度 $\\dot{\\theta}$ 以弧度/秒表示。任务是通过以下步骤来演示一个辛的二阶更新方案的时间可逆性：将系统从一个初始状态正向演化固定的步数，然后反向演化以返回初始状态，并量化正向再反向演化后与初始状态的偏差。\n\n定义如下：\n- 状态为 $(\\theta,\\dot{\\theta})$，其中 $\\theta \\in \\mathbb{R}$ 且 $\\dot{\\theta} \\in \\mathbb{R}$。\n- 角加速度函数为 $a(\\theta) = -\\dfrac{g}{L}\\sin(\\theta)$。\n- 正向演化包含 $N$ 个大小为 $\\Delta t$ 的离散时间步，其中 $N$ 是一个正整数，$T = N\\,\\Delta t$ 是总模拟时间。\n- 反向演化包含 $N$ 个步长，在时间反演对称的意义上精确地逆转正向演化：从正向演化的终点状态 $(\\theta_T,\\dot{\\theta}_T)$ 开始，将速度反转为 $-\\dot{\\theta}_T$，然后应用相同的 $N$ 个步长，最后再次反转速度，以便与初始状态 $(\\theta_0,\\dot{\\theta}_0)$ 进行比较。\n\n使用如下定义的无量纲误差来衡量最终偏差。设 $\\omega_0 = \\sqrt{g/L}$ 为小角度自然频率。设 $\\Delta \\theta$ 为恢复后的角度与初始角度之间的主值角差，如有必要，可通过加上 $2\\pi$ 的整数倍将其减小到 $(-\\pi,\\pi]$ 区间内。设 $\\Delta \\dot{\\theta}$ 为恢复后的角速度与初始角速度之差。定义无量纲误差\n$$\nE = \\sqrt{(\\Delta \\theta)^2 + \\left(\\dfrac{\\Delta \\dot{\\theta}}{\\omega_0}\\right)^2}.\n$$\n角度单位必须是弧度，角速度单位是弧度/秒，$\\omega_0$ 单位是弧度/秒，这样 $E$ 就是无量纲的。您的程序必须为下面列出的每个测试用例计算 $E$。\n\n测试套件。对于每个测试用例，请使用指定的参数 $(g, L, \\theta_0, \\dot{\\theta}_0, T, \\Delta t)$，所有参数均采用国际单位制 (SI)，角度以弧度为单位。对于每个测试，$T/\\Delta t$ 都是一个整数。\n- 测试 1 (小角度，典型步长): $g = 9.81 \\mathrm{m/s^2}$，$L = 1.0 \\mathrm{m}$，$\\theta_0 = 0.2 \\mathrm{rad}$，$\\dot{\\theta}_0 = 0.0 \\mathrm{rad/s}$，$T = 10.0 \\mathrm{s}$，$\\Delta t = 0.005 \\mathrm{s}$。\n- 测试 2 (接近垂直状态的大角度，精细步长): $g = 9.81 \\mathrm{m/s^2}$，$L = 1.0 \\mathrm{m}$，$\\theta_0 = 2.9 \\mathrm{rad}$，$\\dot{\\theta}_0 = 0.0 \\mathrm{rad/s}$，$T = 10.0 \\mathrm{s}$，$\\Delta t = 0.001 \\mathrm{s}$。\n- 测试 3 (非零初始速度): $g = 9.81 \\mathrm{m/s^2}$，$L = 0.7 \\mathrm{m}$，$\\theta_0 = 0.0 \\mathrm{rad}$，$\\dot{\\theta}_0 = 1.5 \\mathrm{rad/s}$，$T = 12.0 \\mathrm{s}$，$\\Delta t = 0.002 \\mathrm{s}$。\n- 测试 4 (接近线性稳定性边界的粗略步长): $g = 9.81 \\mathrm{m/s^2}$，$L = 2.0 \\mathrm{m}$，$\\theta_0 = 0.01 \\mathrm{rad}$，$\\dot{\\theta}_0 = 0.0 \\mathrm{rad/s}$，$T = 18.0 \\mathrm{s}$，$\\Delta t = 0.9 \\mathrm{s}$。\n\n您的程序必须：\n- 实现所述的无阻尼非线性摆动力学。\n- 对每个测试执行：进行 $N = T/\\Delta t$ 步的正向演化，然后进行所描述的反向演化，接着计算上面定义的无量纲误差 $E$。\n- 将结果聚合为单行输出，其中包含按上述顺序排列的测试误差列表，四舍五入到 $12$ 位有效数字，并以科学记数法的小数形式打印。\n\n最终输出格式。您的程序应生成单行内容，其中包含用方括号括起来的逗号分隔的结果列表，例如 `\"[e_1,e_2,e_3,e_4]\"`，其中每个 $e_k$ 是对测试 $k$ 定义的无量纲误差，并格式化为具有 $12$ 位有效数字的科学记数法。",
            "solution": "问题陈述是有效的。它描述了一个在计算物理学中适定 (well-posed) 的数值实验，其基础是经典力学和数值分析的标准原理。\n\n所考虑的物理系统是简单的非线性摆，其运动由二阶常微分方程控制：\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L}\\sin(\\theta(t)) = 0\n$$\n其中 $\\theta(t)$ 是角位移，$g$ 是重力加速度，$L$ 是摆的长度。通过定义状态向量 $(\\theta, \\dot{\\theta})$，该方程可以写成一个一阶方程组：\n$$\n\\begin{cases}\n\\frac{d\\theta}{dt} = \\dot{\\theta} \\\\\n\\frac{d\\dot{\\theta}}{dt} = -\\frac{g}{L}\\sin(\\theta)\n\\end{cases}\n$$\n该系统描述了在二维相空间中的运动。它是一个哈密顿系统，这意味着其动力学过程会守恒一个量，即比能（单位质量的能量），由 $E = \\frac{1}{2}L^2\\dot{\\theta}^2 - gL\\cos(\\theta)$ 给出。用于积分此类系统的数值方法理想情况下应保留相空间中流的几何特性。辛积分器就是为此目的而设计的。它们不一定精确地守恒能量，但它们确实守恒一个附近的“影子”哈密顿量，这可以防止能量的长期漂移，并确保相空间体积的守恒。许多辛积分器的一个关键特性是时间可逆性。如果一个算法从状态 $(\\theta_n, \\dot{\\theta}_n)$ 正向演化一个时间步到 $(\\theta_{n+1}, \\dot{\\theta}_{n+1})$，然后从一个时间反转的状态 $(\\theta_{n+1}, -\\dot{\\theta}_{n+1})$ 再正向演化一个时间步，结果得到状态 $(\\theta_n, -\\dot{\\theta}_n)$，则该算法是时间可逆的。\n\n该问题要求使用一个二阶的辛更新方案。Velocity Verlet 算法是一个标准且合适的选择。它是 Verlet 积分族的一员，以其在应用于形式为 $\\ddot{\\mathbf{q}} = \\mathbf{F}(\\mathbf{q})$ 的哈密顿系统时良好的稳定性和辛性质而闻名。对于我们的摆系统，其状态为 $(\\theta, \\dot{\\theta})$，加速度为 $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$，从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个积分步骤如下进行：\n1. 首先，计算时间间隔中点的速度：\n$$\n\\dot{\\theta}_{n+1/2} = \\dot{\\theta}_n + a(\\theta_n) \\frac{\\Delta t}{2}\n$$\n2. 接着，使用这个中点速度更新位置：\n$$\n\\theta_{n+1} = \\theta_n + \\dot{\\theta}_{n+1/2} \\, \\Delta t\n$$\n3. 最后，使用新的位置 $\\theta_{n+1}$ 更新区间的末端速度：\n$$\n\\dot{\\theta}_{n+1} = \\dot{\\theta}_{n+1/2} + a(\\theta_{n+1}) \\frac{\\Delta t}{2}\n$$\n该算法是显式时间可逆的，并且在 $\\Delta t$上具有二阶精度。\n\n为了演示数值模拟的时间可逆性，对每个测试用例实施以下程序：\n1. **正向演化：** 使用 Velocity Verlet 算法，将系统从初始状态 $(\\theta_0, \\dot{\\theta}_0)$ 演化总时间 $T$（共 $N = T/\\Delta t$ 步）。这会得到最终状态 $(\\theta_T, \\dot{\\theta}_T)$。\n2. **反向演化：** 为了逆转过程，我们从状态 $(\\theta_T, -\\dot{\\theta}_T)$ 开始——注意速度的反转。然后我们应用*相同*的 Velocity Verlet 算法再进行 $N$ 步。这将产生一个状态 $(\\theta'_{\\text{rec}}, \\dot{\\theta}'_{\\text{rec}})$。\n3. **最终状态恢复：** 再次反转最终速度以获得恢复的状态 $(\\theta_{\\text{rec}}, \\dot{\\theta}_{\\text{rec}}) = (\\theta'_{\\text{rec}}, -\\dot{\\theta}'_{\\text{rec}})$。在精确算术中，由于算法的时间可逆性，我们应该有 $(\\theta_{\\text{rec}}, \\dot{\\theta}_{\\text{rec}}) = (\\theta_0, \\dot{\\theta}_0)$。在实践中，浮点舍入误差会导致微小的偏差。\n\n偏差通过无量纲误差 $E$ 来量化：\n$$\nE = \\sqrt{(\\Delta \\theta)^2 + \\left(\\frac{\\Delta \\dot{\\theta}}{\\omega_0}\\right)^2}\n$$\n其中 $\\omega_0 = \\sqrt{g/L}$ 是小角度振荡的自然频率。差值为 $\\Delta \\dot{\\theta} = \\dot{\\theta}_{\\text{rec}} - \\dot{\\theta}_0$ 和 $\\Delta \\theta$，后者是主值角差，计算方式为 $\\Delta\\theta_{\\text{raw}} = \\theta_{\\text{rec}} - \\theta_0$，然后映射到区间 $(-\\pi, \\pi]$。这可以通过双参数反正切函数稳健地计算：$\\Delta\\theta = \\text{atan2}(\\sin(\\Delta\\theta_{\\text{raw}}), \\cos(\\Delta\\theta_{\\text{raw}}))$。\n\n实现过程为每个提供的测试用例精确地遵循这些步骤。所得误差 $E$ 是累积浮点不精确性的度量，预计该值会很小，从而证实了辛积分器优异的数值稳定性和可逆性。最终的程序实现了这一完整过程。对于每个测试用例，它设置参数，运行正向然后反向的模拟，计算误差，并按规定格式化结果。创建了一个实现 Velocity Verlet 步骤的函数。对每个测试用例调用该函数两次：一次用于正向演化，一次用于反向演化。收集所有测试用例计算出的误差，并以要求的格式打印。获得的数值应该非常小，这证实了与完美时间反演的偏差在机器精度量级，正如正确实现的时间可逆算法所预期的那样。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the time-reversibility error for the nonlinear pendulum simulation\n    using a symplectic Velocity Verlet integrator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (g, L, theta_0, v_theta_0, T, dt)\n        # Test 1\n        (9.81, 1.0, 0.2, 0.0, 10.0, 0.005),\n        # Test 2\n        (9.81, 1.0, 2.9, 0.0, 10.0, 0.001),\n        # Test 3\n        (9.81, 0.7, 0.0, 1.5, 12.0, 0.002),\n        # Test 4\n        (9.81, 2.0, 0.01, 0.0, 18.0, 0.9),\n    ]\n\n    results = []\n\n    def run_simulation(theta_init, v_theta_init, g, L, dt, N):\n        \"\"\"\n        Evolves the pendulum state for N steps using the Velocity Verlet algorithm.\n        \n        Args:\n            theta_init (float): Initial angle in radians.\n            v_theta_init (float): Initial angular velocity in rad/s.\n            g (float): Gravitational acceleration in m/s^2.\n            L (float): Pendulum length in m.\n            dt (float): Time step in s.\n            N (int): Number of steps.\n\n        Returns:\n            tuple[float, float]: Final angle and angular velocity.\n        \"\"\"\n        theta = theta_init\n        v_theta = v_theta_init\n        accel_factor = -g / L\n\n        for _ in range(N):\n            # Velocity Verlet half-step for velocity\n            v_theta_half = v_theta + 0.5 * dt * accel_factor * np.sin(theta)\n            # Full-step for position\n            theta = theta + dt * v_theta_half\n            # Second half-step for velocity, using the updated position\n            v_theta = v_theta_half + 0.5 * dt * accel_factor * np.sin(theta)\n        \n        return theta, v_theta\n\n    for case in test_cases:\n        g, L, theta_0, v_theta_0, T, dt = case\n        \n        # Number of steps. The problem guarantees T/dt is an integer.\n        N = int(round(T / dt))\n\n        # 1. Forward evolution from initial state (theta_0, v_theta_0)\n        theta_T, v_theta_T = run_simulation(theta_0, v_theta_0, g, L, dt, N)\n\n        # 2. Backward evolution\n        # Initial state for backward run: reverse velocity at the end of forward run\n        theta_B0 = theta_T\n        v_theta_B0 = -v_theta_T\n        \n        # Evolve \"forward\" in time from this new state\n        theta_rec_raw, v_theta_rec_raw = run_simulation(theta_B0, v_theta_B0, g, L, dt, N)\n        \n        # The true recovered state is obtained by re-reversing the final velocity\n        theta_rec = theta_rec_raw\n        v_theta_rec = -v_theta_rec_raw\n\n        # 3. Calculate dimensionless error E\n        omega_0 = np.sqrt(g / L)\n        \n        # Calculate deviation from initial state\n        delta_v_theta = v_theta_rec - v_theta_0\n        \n        # Calculate raw angular difference. Angle can wrap around many times.\n        delta_theta_raw = theta_rec - theta_0\n        \n        # Normalize angular difference to the principal-value interval (-pi, pi]\n        delta_theta = np.arctan2(np.sin(delta_theta_raw), np.cos(delta_theta_raw))\n        \n        # Calculate dimensionless error\n        E = np.sqrt(delta_theta**2 + (delta_v_theta / omega_0)**2)\n        results.append(E)\n\n    # Format output as specified: a list of errors in scientific notation with 12 significant digits.\n    # The format specifier {:.11e} gives 1 digit before the decimal and 11 after,\n    # totaling 12 significant digits for a normalized scientific number.\n    formatted_results = [\"{:.11e}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从理论和基础验证走向大规模实际应用，需要我们思考算法的实现效率。对于包含数百万甚至数十亿粒子的模拟，性能至关重要。本题将你的视角从算法本身提升到其在现代高性能计算架构（如CPU和GPU）上的优化实现。通过分析不同的循环结构和内存布局策略，你将学会如何在保证Verlet算法固有不变性（如时间可逆性和辛结构）的前提下，最大限度地提高计算效率和减少内存访问开销，这是连接理论与前沿计算科学实践的关键一步 。",
            "id": "3852918",
            "problem": "您正在为多尺度材料模拟中的大尺度保守分子动力学实现速度 Verlet 积分器，该实现将同时在中央处理器 (CPU) 和图形处理器 (GPU) 上运行。该系统由多个粒子组成，粒子的位置为 $\\mathbf{r}_i$，速度为 $\\mathbf{v}_i$，质量为 $m_i$。粒子所受的力 $\\mathbf{f}_i(\\{\\mathbf{r}\\})$ 源于一个不随时间变化的势，因此牛顿第二定律 $m_i \\, d\\mathbf{v}_i/dt = \\mathbf{f}_i(\\{\\mathbf{r}\\})$ 和运动学定义 $d\\mathbf{r}_i/dt = \\mathbf{v}_i$ 均成立。速度 Verlet 算法由一个对称的“半步-漂移-半步”分裂定义，当力在时间 $t$ 和 $t+\\Delta t$ 的一致位置上进行计算时，该算法能保持时间可逆性和辛结构。\n\n给定一个带有截断半径和缓冲层（skin）的邻居列表，其中粒子 $i$ 的邻居信息以压缩稀疏行（CSR）布局存储，包含一个头数组 $\\text{head}[i]$ 和一个连续的邻居索引列表 $\\text{nl}[k]$，使得粒子 $i$ 的邻居位于 $\\text{nl}[k]$ 中，其中 $k \\in [\\text{head}[i], \\text{head}[i+1))$。您必须选择一种循环结构和数据布局，使其在 CPU 上对缓存友好，在单指令多线程 (SIMT) 架构的 GPU 上友好，同时最小化全局内存流量并保持速度 Verlet 算法的不变量。您可以假设势是成对的且仅依赖于位置，并且邻居列表在多个步长内均有效。\n\n哪个选项最好地概述了这样一种循环结构和内存布局，并阐述了其关于最小化内存流量和保持不变量的理由？\n\nA. 对粒子数据使用数组结构 (SoA) 布局，包含数组 $\\text{x}[\\cdot], \\text{y}[\\cdot], \\text{z}[\\cdot], \\text{vx}[\\cdot], \\text{vy}[\\cdot], \\text{vz}[\\cdot], \\text{fx}[\\cdot], \\text{fy}[\\cdot], \\text{fz}[\\cdot]$。在 GPU 上，启动 N 个线程，并在每个时间步执行 2 个内核：内核 1 对每个粒子 $i$ 执行半步踢动和漂移，读取 $\\mathbf{f}_i(t)$、$\\mathbf{v}_i(t)$、$\\mathbf{r}_i(t)$，并写入 $\\mathbf{v}_i(t+\\tfrac{\\Delta t}{2})$ 和 $\\mathbf{r}_i(t+\\Delta t)$。内核 2 将 $\\mathbf{r}_i(t+\\Delta t)$ 读入寄存器，遍历完整邻居列表中的 $j \\in \\mathcal{N}(i)$（每对粒子被访问两次，一次是 $(i,j)$，一次是 $(j,i)$），通过只读缓存加载 $\\mathbf{r}_j(t+\\Delta t)$，在寄存器中累加 $\\mathbf{f}_i(t+\\Delta t)$ 而不在内循环中进行任何写操作或原子操作，然后完成第二次半步踢动 $\\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t+\\tfrac{\\Delta t}{2}) + \\tfrac{\\Delta t}{2 m_i}\\,\\mathbf{f}_i(t+\\Delta t)$，最后为下一步写入 $\\mathbf{f}_i(t+\\Delta t)$。内核边界提供了一个全局同步，确保在力计算之前所有的 $\\mathbf{r}_i(t+\\Delta t)$ 都是一致的，从而保持了积分器的不变量。SoA 布局可以合并跨线程的 $\\mathbf{r}$ 和 $\\mathbf{v}$ 的加载/存储操作，完整邻居列表避免了原子更新和分散写操作，而将 $\\mathbf{f}_i$ 保持在寄存器中直到最后，则将 $\\mathbf{f}_i$ 的全局内存流量最小化为每个粒子一次写操作，并避免了对每对粒子的存储。在 CPU 上，使用相同的两遍顺序和 SoA 布局，以利用 $\\text{nl}[\\cdot]$ 的空间局部性和硬件预取。\n\nB. 将所有阶段融合到一个 GPU 内核中，以减少内核启动开销。对于每个线程（粒子 $i$），读取 $\\mathbf{f}_i(t)$、$\\mathbf{v}_i(t)$、$\\mathbf{r}_i(t)$，执行半步踢动和漂移以获得 $\\mathbf{r}_i(t+\\Delta t)$，然后立即遍历邻居 $j \\in \\mathcal{N}(i)$ 来计算并累加 $\\mathbf{f}_i(t+\\Delta t)$。在漂移和力计算循环之间仅使用块级同步（例如 `__syncthreads`）；最后完成第二次半步踢动，并写回 $\\mathbf{v}_i(t+\\Delta t)$ 和 $\\mathbf{f}_i(t+\\Delta t)$。邻居列表是半列表（每对粒子只存储一次）以将算术运算减半，对粒子 $j$ 的作用力通过对全局内存中的 $\\mathbf{f}_j$ 进行原子加法来施加，以强制执行牛顿第三定律。\n\nC. 为了最大化算术强度，在 GPU 上将第二次半步踢动移到内层邻居循环中：在为当前对 $(i,j)$ 计算完对力 $\\mathbf{f}_{ij}$ 后，立即用 $\\tfrac{\\Delta t}{2 m_i}\\,\\mathbf{f}_{ij}$ 更新 $\\mathbf{v}_i$，并使用原子加法用 $-\\tfrac{\\Delta t}{2 m_j}\\,\\mathbf{f}_{ij}$ 更新 $\\mathbf{v}_j$；在循环结束时，写入目前累加的 $\\mathbf{f}_i(t+\\Delta t)$。使用结构数组 (AoS) 布局，使每个粒子的 $\\{\\mathbf{r}_i,\\mathbf{v}_i,\\mathbf{f}_i\\}$ 在内存中相邻，以减少指针运算。\n\nD. 在 CPU 上，对 $i$ 进行单遍处理，交错进行位置更新和力计算：对于每个 $i$，执行半步踢动和漂移以计算 $\\mathbf{r}_i(t+\\Delta t)$，然后遍历 $j \\in \\mathcal{N}(i)$，并使用 $\\mathbf{r}_i$ 或 $\\mathbf{r}_j$ 中最近更新的位置来计算对力（因此某些对的一个粒子使用 $\\mathbf{r}(t)$，另一个粒子使用 $\\mathbf{r}(t+\\Delta t)$），在计算每对力后将 $\\mathbf{f}_i$ 和 $\\mathbf{f}_j$ 写入内存。使用 AoS 改善每个粒子数据的局部性，并使用完整邻居列表来避免原子操作。",
            "solution": "用户要求对一个分子动力学实现问题进行批判性评估，重点是针对 CPU 和 GPU 架构的速度 Verlet 算法。主要任务是验证问题陈述的有效性，如果有效，则从给定选项中确定最佳实现策略。\n\n### 问题验证\n\n首先，我将解构并验证问题陈述。\n\n**步骤 1：提取已知条件**\n\n*   **算法**：用于保守分子动力学系统的速度 Verlet 积分器。\n*   **运动方程**：$m_i \\frac{d\\mathbf{v}_i}{dt} = \\mathbf{f}_i(\\{\\mathbf{r}\\})$ 和 $\\frac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i$。\n*   **势**：不随时间变化、成对且仅依赖于位置。\n*   **系统**：具有位置 $\\mathbf{r}_i$、速度 $\\mathbf{v}_i$ 和质量 $m_i$ 的粒子。\n*   **速度 Verlet 属性**：被描述为一种对称的“半步-漂移-半步”分裂，保持时间可逆性和辛结构。\n*   **力计算约束**：力必须在时间 $t$ 和 $t+\\Delta t$ 的一致位置上进行计算。\n*   **硬件目标**：中央处理器 (CPU) 和具有单指令多线程 (SIMT) 架构的图形处理器 (GPU)。\n*   **数据结构**：带有截断半径和缓冲层的邻居列表，以压缩稀疏行 (CSR) 格式存储（$\\text{head}[i]$, $\\text{nl}[k]$）。\n*   **优化目标**：\n    1.  在 CPU 上对缓存友好。\n    2.  在 GPU (SIMT) 上友好。\n    3.  最小化全局内存流量。\n    4.  保持速度 Verlet 算法的不变量。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学基础**：问题陈述牢固地植根于经典力学和计算物理学的原理。速度 Verlet 算法是求解牛顿运动方程的标准、稳健的数值积分器。硬件方面的考虑（CPU/GPU、SoA/AoS、内存合并、原子操作）是高性能科学计算的核心议题。该描述在科学和技术上都是合理的。\n*   **良构性**：该问题是良构的。它提出了一个明确的目标：根据正确性（保持不变量）和性能（缓存友好性、内存流量、架构适应性）的组合，从一组选项中确定最佳实现策略。“最佳”的标准被明确规定。\n*   **客观性**：语言精确且无偏见。所有使用的术语，如“辛结构”、“时间可逆性”、“SoA”、“SIMT”和“全局内存流量”，在相关领域中都具有客观、明确的含义。\n\n问题陈述没有表现出任何无效性缺陷：\n1.  **科学或事实不健全**：没有违反物理学或计算机科学原理。\n2.  **非形式化或不相关**：问题与多尺度材料模拟的实现直接且技术相关。\n3.  **设置不完整或矛盾**：设置是完整且自洽的。约束和目标都已明确定义。\n4.  **不切实际或不可行**：该场景非常现实，代表了 LAMMPS、GROMACS 或 OpenMM 等模拟软件开发者面临的标准问题。\n5.  **不适定或结构不良**：术语是标准且明确的。\n6.  **伪深刻、琐碎或同义反复**：该问题探讨了高性能计算中算法实现中复杂且非琐碎的权衡。\n7.  **超出科学可验证性**：选项中的声明可通过实现、性能分析和数值分析进行验证。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。我将继续推导解决方案并评估各个选项。\n\n### 推导与选项分析\n\n速度 Verlet 算法具有一个必须遵守的严格顺序和对称结构，以维持其理想属性（时间可逆性、辛性以及保守系统的长期能量守恒）。其标准形式为：\n\n1.  **速度半步踢动**：使用时间 $t$ 的力，将速度更新半步。\n    $$ \\mathbf{v}_i(t + \\tfrac{\\Delta t}{2}) = \\mathbf{v}_i(t) + \\frac{\\mathbf{f}_i(t)}{2m_i} \\Delta t $$\n2.  **位置漂移**：使用新的半步速度，将位置更新一个完整步长。\n    $$ \\mathbf{r}_i(t + \\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t + \\tfrac{\\Delta t}{2}) \\Delta t $$\n3.  **同步**：一个关键的、隐式的步骤。在继续之前，必须知道所有粒子的位置 $\\{\\mathbf{r}_i(t + \\Delta t)\\}$。\n4.  **力计算**：使用完全更新后的位置集合 $\\{\\mathbf{r}_k(t + \\Delta t)\\}$，计算新的力 $\\mathbf{f}_i(t + \\Delta t)$。\n5.  **速度半步踢动**：使用新的力，完成速度更新。\n    $$ \\mathbf{v}_i(t + \\Delta t) = \\mathbf{v}_i(t + \\tfrac{\\Delta t}{2}) + \\frac{\\mathbf{f}_i(t+\\Delta t)}{2m_i} \\Delta t $$\n\n一个关键的不变量是，步骤 4 中的力计算必须在全局一致的状态上操作，其中每个粒子的位置都对应于时间 $t+\\Delta t$。任何通过混合使用来自时间 $t$ 和 $t+\\Delta t$ 的位置而违反此规则的实现都将破坏算法的不变量。在像 GPU 这样的大规模并行架构上，这需要在位置更新阶段（步骤 2）和力计算阶段（步骤 4）之间设置一个全局同步屏障。内核启动边界提供了这样的屏障。\n\n**逐项选项分析**\n\n**A. 使用数组结构 (SoA) 布局... 启动 N 个线程并在每个时间步执行 2 个内核...**\n\n*   **数据布局**：指定了数组结构 (SoA)（$\\text{x}[\\cdot]$, $\\text{y}[\\cdot]$ 等）。对于 GPU 的 SIMT 架构，相邻线程（例如线程 0, 1, 2, ..., 31）处理相邻粒子（粒子 0, 1, 2, ..., 31），访问像 $\\text{x}[\\cdot]$ 这样的单个分量会产生连续的内存访问。这使得硬件能够将这些多个小的读取“合并”成一个单一的、宽的内存事务，这是访问全局内存最有效的方式。这对于 GPU 是一个最佳选择，并且也有利于 CPU 的向量化 (SIMD)。\n*   **循环结构**：使用了两个内核。内核 1 执行第一次半步踢动和完整的漂移。内核 2 执行力计算和第二次半步踢动。这两个内核之间的边界提供了**必要的全局同步**。它保证了所有线程在任何线程开始读取新位置 $\\mathbf{r}_i(t+\\Delta t)$ 进行力计算之前，都已经完成了对这些位置的写入。这正确地保持了积分器的不变量。\n*   **力计算**：使用了完整的邻居列表。这意味着每个对相互作用 $(i,j)$ 被计算两次（一次由线程 $i$ 计算，一次由线程 $j$ 计算）。虽然在计算上是冗余的，但这意​​味着线程 $i$ 只需要读取邻居数据，并且只写入其自己的力累加器 $\\mathbf{f}_i$。这个累加器可以在邻居循环期间保存在快速寄存器中，最终结果只向全局内存写入一次。这个策略完全避免了在力上进行缓慢、引起争用的原子操作。\n*   **内存流量**：SoA 用于合并访问、寄存器累加力以及最小化写入的双内核结构，共同构成了一种最先进的、内存高效的设计。\n*   **结论**：此选项正确识别并遵守了算法不变量。它提出的数据布局和循环结构对于目标架构的性能（内存合并、最小化流量、避免原子操作）和正确性都是最优的。**正确**。\n\n**B. 将所有阶段融合到一个 GPU 内核中以减少内核启动开销...仅使用块级同步...**\n\n*   **同步**：此选项明确提到仅使用块级同步（`__syncthreads`）。这种同步只对同一执行块内的线程（通常为 32-1024 个线程）有效。它*不*会同步不同块之间的线程。因此，块 0 中计算力的线程无法保证由块 1 中线程处理的粒子的位置更新已经完成。这导致力是在新旧位置的混合状态下计算的，这致命地违反了速度 Verlet 算法的辛性和时间可逆性。系统的能量将不会守恒。\n*   **力计算**：使用半列表和原子加法是一种有效的实现模式，但无法弥补同步中的根本缺陷。\n*   **结论**：所提出的循环融合与不充分的同步破坏了算法。**不正确**。\n\n**C. 为了最大化算术强度，将第二次半步踢动移到内层邻居循环中...使用结构数组 (AoS) 布局...**\n\n*   **算法结构**：此选项建议在计算完每个对力 $\\mathbf{f}_{ij}$ 后立即更新速度 $\\mathbf{v}_i$。第二次半步踢动需要粒子 $i$ 上的*总*力，即 $\\mathbf{f}_i(t+\\Delta t) = \\sum_j \\mathbf{f}_{ij}$。应用来自单个对力的部分更新会破坏 Verlet 积分器的对称结构。这在数学上是不正确的。\n*   **数据布局**：它建议使用结构数组 (AoS) 布局。对于 GPU 来说，这是非常低效的。当相邻线程访问例如位置的 x 分量时，它们访问的是由整个结构大小隔开的内存位置（例如 `particle[i].x`, `particle[i+1].x` 等）。这种跨步访问模式破坏了内存合并，导致性能不佳。\n*   **结论**：此选项提出的算法在数学上是不正确的，并且其数据布局不适合目标 GPU 架构。**不正确**。\n\n**D. 在 CPU 上，在单遍处理中交错进行位置更新和力计算...使用 $\\mathbf{r}_i$ 或 $\\mathbf{r}_j$ 中最近更新的位置...**\n\n*   **算法结构**：这明确描述了一种“混合时间步”力计算。在计算粒子 $i$ 和 $j$ 之间的力时，如果循环已经处理了 $i$ 但尚未处理 $j$，则计算将使用 $\\mathbf{r}_i(t+\\Delta t)$ 和 $\\mathbf{r}_j(t)$。如选项 B 的分析所述，这违反了力计算需要一致性状态的要求，并破坏了积分器的守恒属性。这有时被称为高斯-赛德尔类型的更新，不适用于保守的 NVE 模拟。\n*   **内存流量**：它还建议在每次对相互作用后将力写入内存。这将导致大量的小内存写操作，导致性能极差，比在寄存器中累加并每个粒子写一次要差几个数量级。\n*   **结论**：此选项描述的方法在此上下文中既是算法上不正确的，也是效率极低的。**不正确**。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}