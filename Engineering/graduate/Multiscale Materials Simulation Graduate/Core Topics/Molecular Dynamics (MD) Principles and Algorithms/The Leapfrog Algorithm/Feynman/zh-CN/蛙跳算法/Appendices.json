{
    "hands_on_practices": [
        {
            "introduction": "在将任何数值算法用于实际模拟之前，我们必须首先了解其稳定性边界。本练习将对蛙跳算法进行基础的稳定性分析，我们将其应用于最简单的振动系统——谐振子，它是包括晶格振动在内的许多物理现象的理想模型。通过推导其传递矩阵并求解特征值，您将亲手确定确保模拟稳定性的最大允许时间步长，这是任何分子动力学模拟中的一个关键参数 。",
            "id": "3847513",
            "problem": "在多尺度材料模拟中，晶格振动的时间积分通常在分子动力学（MD）中使用蛙跳算法进行。考虑一个由线性弹簧-质量系统的牛顿第二定律控制的单一粗粒化谐振模式，$$m\\,\\ddot{x}(t) + k\\,x(t) = 0,$$ 其中 $m$ 是质量，$k$ 是有效弹簧常数。蛙跳算法在整数时间 $t^{n} = n\\,\\Delta t$ 推进位置 $x^{n}$，在半整数时间 $t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$ 推进速度 $v^{n+1/2}$，使用在整数时间点计算的离散加速度。\n\n从牛顿第二定律和蛙跳算法更新的定义出发，推导状态向量从 $$\\begin{pmatrix} x^{n} \\\\ v^{n-1/2} \\end{pmatrix} \\mapsto \\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$ 的单步线性映射，并求出该映射的特征值作为其对应的放大因子。基于常系数离散动力系统的线性稳定性第一原理，推导出确保该振子离散轨迹有界的时间步长 $\\Delta t$ 需满足的条件，该条件是关于 $$\\omega \\equiv \\sqrt{\\frac{k}{m}}$$ 的函数。\n\n最后，对于一个具有代表性的粗粒化格点，其质量 $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$，弹簧常数 $$k = 64\\,\\text{N/m},$$ 计算线性稳定的最大蛙跳算法时间步长 $$\\Delta t_{\\max}$$，并以飞秒（femtosecond）为单位表示。将您的答案四舍五入至 $4$ 位有效数字，并报告 $$\\Delta t_{\\max}$$ 的数值（单位：飞秒，fs）。",
            "solution": "首先验证问题，以确保其科学基础扎实、提法恰当且客观。\n\n### 步骤 1：提取已知条件\n- 运动方程：$$m\\,\\ddot{x}(t) + k\\,x(t) = 0$$，其中 $$m$$ 是质量，$$k$$ 是弹簧常数。\n- 蛙跳算法更新：位置 $$x^{n}$$ 在整数时间 $$t^{n} = n\\,\\Delta t$$ 计算。速度 $$v^{n+1/2}$$ 在半整数时间 $$t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$$ 计算。\n- 任务 1：推导从状态向量 $$\\begin{pmatrix} x^{n} \\\\ v^{n-1/2} \\end{pmatrix}$$ 到 $$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$ 的单步线性映射。\n- 任务 2：求此映射的放大因子（特征值）。\n- 任务 3：推导 $$\\Delta t$$ 作为 $$\\omega \\equiv \\sqrt{\\frac{k}{m}}$$ 的函数的稳定性条件。\n- 任务 4：对于 $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$ 和 $$k = 64\\,\\text{N/m}$$，计算线性稳定的最大时间步长 $$\\Delta t_{\\max}$$（单位：飞秒），并四舍五入至 $$4$$ 位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础扎实**：该问题描述了应用于简谐振子的蛙跳（或 Störmer-Verlet）方法的线性稳定性分析。这是数值分析和计算物理中的一个典型问题，与分子动力学模拟尤其相关。其模型和方法都是成熟的。\n- **提法恰当**：问题阐述清晰。它要求推导一个转移矩阵、其特征值、由此产生的稳定性条件，并进行最终的数值计算。所有必要的定义和数据均已提供，且存在唯一、有意义的解。\n- **客观性**：问题使用精确、标准的科学术语陈述，没有歧义和主观性。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n谐振子的控制方程由牛顿第二定律给出：\n$$m\\,\\ddot{x}(t) + k\\,x(t) = 0$$\n这可以根据角频率 $$\\omega = \\sqrt{k/m}$$ 改写为：\n$$\\ddot{x}(t) = -\\omega^2 x(t)$$\n在任意时间 $$t$$ 的加速度为 $$a(t) = \\ddot{x}(t) = -\\omega^2 x(t)$$。\n\n蛙跳算法使用交错的时间网格。其更新定义如下：\n$1$. 速度从时间 $$t^{n-1/2}$$ 更新到 $$t^{n+1/2}$$，使用在整数时间步 $$t^n$$ 计算的加速度。\n$$v^{n+1/2} = v^{n-1/2} + a(t^n)\\,\\Delta t = v^{n-1/2} + a(x^n)\\,\\Delta t$$\n$2$. 位置从时间 $$t^n$$ 更新到 $$t^{n+1}$$，使用在半整数时间步 $$t^{n+1/2}$$ 新计算出的速度。\n$$x^{n+1} = x^n + v^{n+1/2}\\,\\Delta t$$\n\n我们的任务是找到将状态向量 $$\\begin{pmatrix} x^n \\\\ v^{n-1/2} \\end{pmatrix}$$ 变换为 $$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$ 的线性映射。为此，我们将加速度的表达式 $$a(x^n) = -\\omega^2 x^n$$ 代入速度更新方程：\n$$v^{n+1/2} = v^{n-1/2} - (\\omega^2 x^n)\\,\\Delta t$$\n这个方程可以改写为：\n$$v^{n+1/2} = -\\omega^2 \\Delta t\\,x^n + v^{n-1/2}$$\n\n接下来，我们将这个新的 $$v^{n+1/2}$$ 表达式代入位置更新方程：\n$$x^{n+1} = x^n + (v^{n-1/2} - \\omega^2 \\Delta t\\,x^n)\\,\\Delta t$$\n$$x^{n+1} = x^n + v^{n-1/2}\\,\\Delta t - \\omega^2 (\\Delta t)^2 x^n$$\n重新整理各项，将 $$x^n$$ 和 $$v^{n-1/2}$$ 分组：\n$$x^{n+1} = (1 - \\omega^2 (\\Delta t)^2)\\,x^n + \\Delta t\\,v^{n-1/2}$$\n\n我们现在得到了一个由两个线性方程组成的系统，它将步骤 $$n+1$$ 的状态与步骤 $$n$$ 的状态联系起来：\n$$x^{n+1} = (1 - \\omega^2 (\\Delta t)^2)\\,x^n + \\Delta t\\,v^{n-1/2}$$\n$$v^{n+1/2} = -\\omega^2 \\Delta t\\,x^n + 1 \\cdot v^{n-1/2}$$\n\n这个系统可以写成矩阵形式，代表了单步线性映射：\n$$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix} = \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 \\end{pmatrix} \\begin{pmatrix} x^n \\\\ v^{n-1/2} \\end{pmatrix}$$\n此方程中的矩阵是转移矩阵，通常称为放大矩阵 $$\\mathbf{A}$$。\n$$\\mathbf{A} = \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 \\end{pmatrix}$$\n\n放大因子是矩阵 $$\\mathbf{A}$$ 的特征值 $$\\lambda$$。它们通过求解特征方程 $$\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$$ 得到，其中 $$\\mathbf{I}$$ 是单位矩阵。\n$$\\det \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 - \\lambda & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 - \\lambda \\end{pmatrix} = 0$$\n$$(1 - \\omega^2 (\\Delta t)^2 - \\lambda)(1 - \\lambda) - (\\Delta t)(-\\omega^2 \\Delta t) = 0$$\n$$1 - \\lambda - \\omega^2 (\\Delta t)^2 + \\lambda \\omega^2 (\\Delta t)^2 - \\lambda + \\lambda^2 + \\omega^2 (\\Delta t)^2 = 0$$\n$$\\lambda^2 + (\\omega^2 (\\Delta t)^2 - 2)\\lambda + 1 = 0$$\n\n我们使用二次公式 $$\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$ 求解这个关于 $$\\lambda$$ 的二次方程，其中 $$a=1$$，$b = \\omega^2 (\\Delta t)^2 - 2$，$c=1$。\n$$\\lambda = \\frac{-( \\omega^2 (\\Delta t)^2 - 2) \\pm \\sqrt{(\\omega^2 (\\Delta t)^2 - 2)^2 - 4}}{2}$$\n$$\\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(\\omega \\Delta t)^4 - 4(\\omega \\Delta t)^2 + 4 - 4}}{2}$$\n$$\\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(\\omega \\Delta t)^2 ((\\omega \\Delta t)^2 - 4)}}{2}$$\n$$\\lambda = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm \\frac{\\omega \\Delta t}{2}\\sqrt{(\\omega \\Delta t)^2 - 4}$$\n\n为了使一个离散动力系统有有界解，它必须是稳定的。线性稳定性要求所有特征值的模（即 $$\\mathbf{A}$$ 的谱半径）不得超过 $$1$$。也就是说，$$|\\lambda| \\le 1$$。我们通过检查平方根下的项 $$(\\omega \\Delta t)^2 - 4$$ 来分析此条件。\n\n情况 1：$$(\\omega \\Delta t)^2 > 4$$，或 $$|\\omega \\Delta t| > 2$$。\n特征值为实数。两个特征值的乘积为 $$\\lambda_1 \\lambda_2 = c/a = 1$$。如果特征值是实数且不等于 $$\\pm 1$$，则一个的模必须大于 $$1$$，另一个的模必须小于 $$1$$。这对应于一个指数增长的不稳定模式。系统是不稳定的。\n\n情况 2：$$(\\omega \\Delta t)^2 = 4$$，或 $$|\\omega \\Delta t| = 2$$。\n平方根下的项为零，产生一个退化的特征值 $$\\lambda = 1 - \\frac{4}{2} = -1$$。由于 $$|\\lambda| = 1$$，这是稳定性的边界（临界稳定）。\n\n情况 3：$$(\\omega \\Delta t)^2 < 4$$，或 $$|\\omega \\Delta t| < 2$$。\n平方根下的项为负。特征值是一对共轭复数。\n$$\\lambda = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm i \\frac{\\omega \\Delta t}{2}\\sqrt{4 - (\\omega \\Delta t)^2}$$\n这些特征值的模的平方是：\n$$|\\lambda|^2 = \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 + \\left(\\frac{\\omega \\Delta t}{2}\\sqrt{4 - (\\omega \\Delta t)^2}\\right)^2$$\n$$|\\lambda|^2 = 1 - (\\omega \\Delta t)^2 + \\frac{(\\omega \\Delta t)^4}{4} + \\frac{(\\omega \\Delta t)^2}{4}(4 - (\\omega \\Delta t)^2)$$\n$$|\\lambda|^2 = 1 - (\\omega \\Delta t)^2 + \\frac{(\\omega \\Delta t)^4}{4} + (\\omega \\Delta t)^2 - \\frac{(\\omega \\Delta t)^4}{4}$$\n$$|\\lambda|^2 = 1$$\n因此，$$|\\lambda| = 1$$。在这种情况下，特征值位于复平面的单位圆上。离散演化在某种意义上保持了状态向量的范数，从而导致有界的振荡解。系统是稳定的。\n\n综合这些情况，线性稳定性（有界轨迹）的条件是 $$|\\omega \\Delta t| \\le 2$$。由于 $$\\omega > 0$$ 且 $$\\Delta t > 0$$，这可以简化为：\n$$\\omega \\Delta t \\le 2$$\n$$\\Delta t \\le \\frac{2}{\\omega}$$\n\n因此，线性稳定的最大时间步长为 $$\\Delta t_{\\max} = \\frac{2}{\\omega}$$。\n\n最后，我们根据给定的参数 $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$ 和 $$k = 64\\,\\text{N/m}$$ 计算 $$\\Delta t_{\\max}$$ 的数值。首先，我们计算 $$\\omega$$：\n$$\\omega = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{64\\,\\text{N/m}}{4.6636 \\times 10^{-26}\\,\\text{kg}}}$$\n$$\\omega \\approx \\sqrt{1.37229134 \\times 10^{27}\\,\\text{s}^{-2}} \\approx 3.7044448 \\times 10^{13}\\,\\text{rad/s}$$\n\n现在我们可以计算 $$\\Delta t_{\\max}$$：\n$$\\Delta t_{\\max} = \\frac{2}{\\omega} \\approx \\frac{2}{3.7044448 \\times 10^{13}\\,\\text{s}^{-1}}$$\n$$\\Delta t_{\\max} \\approx 5.398923 \\times 10^{-14}\\,\\text{s}$$\n\n问题要求答案以飞秒为单位（$$1\\,\\text{fs} = 10^{-15}\\,\\text{s}$$）。\n$$\\Delta t_{\\max} \\approx 5.398923 \\times 10^{-14}\\,\\text{s} \\times \\frac{1\\,\\text{fs}}{10^{-15}\\,\\text{s}} = 53.98923\\,\\text{fs}$$\n\n四舍五入到 $$4$$ 位有效数字，我们得到：\n$$\\Delta t_{\\max} \\approx 53.99\\,\\text{fs}$$",
            "answer": "$$\n\\boxed{53.99}\n$$"
        },
        {
            "introduction": "除了稳定性，蛙跳算法的卓越之处在于其几何性质，例如时间可逆性。这个动手练习将带您从纯理论走向实际的编程实现与验证，通过对哈密顿量流进行对称算符分裂来推导并实现蛙跳算法。通过执行一次“往返”数值实验——即先正向积分，再反向积分——您将亲眼见证时间可逆性如何在机器精度内得到保持，这正是该算法对称设计的直接体现 。",
            "id": "3847494",
            "problem": "您的任务是设计、实现并验证一个可逆的蛙跳（Leapfrog，也称为 Störmer–Verlet 或速度-Verlet）时间积分器，该积分器用于一个源于多尺度材料模拟的一维谐振子模型系统。您的任务是从第一性原理出发，推导一个对称、时间可逆的更新规则，将其在一个完整的程序中实现，然后运行一个数值实验，以确认其时间可逆性达到机器精度，并评估能量误差的标度行为。您的程序必须执行一个预定义的测试套件，并以指定格式输出单行结果。\n\n基本原理：从哈密顿力学开始，考虑一个一维质量-弹簧系统，其哈密顿量为\n$$\nH(x,p) = \\frac{p^2}{2m} + \\frac{k x^2}{2},\n$$\n其中 $x$ 是位置，$p$ 是动量，$m$ 是质量，$k$ 是刚度。哈密顿方程为\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial x} = -k x.\n$$\n定义速度 $v = \\dot{x} = p/m$。系统的固有频率为 $\\omega = \\sqrt{k/m}$。\n\n推导要求：仅使用上述基本定律和速度的定义，推导哈密顿流的一个对称算子分裂，将其分为动能和势能部分，从而得到一个二阶、时间可逆的蛙跳更新方案。不得引用任何无法从所述基本原理推导出的公式。具体要求如下：\n- 将单个时间步长 $\\Delta t$ 内的演化分裂为多个子步骤，这些子步骤分别精确地积分动能部分（$k=0$）和势能部分（$m \\to \\infty$），然后将它们在 $\\Delta t$ 上对称地组合，以获得一个二阶方法。该组合必须在时间上对称，从而在精确算术中，用 $-\\Delta t$ 替换 $\\Delta t$ 能精确地逆转一个步骤。\n- 用对 $(x,v)$ 在大小与 $\\Delta t$ 成比例的子步骤上的更新来表达算法，确保该方案对于线性稳定域内的任何 $(m,k,\\Delta t)$ 都是自洽且定义明确的。\n\n数值实验设计：对于下方的每个测试用例，执行以下操作。\n1. 从解析解 $x(t) = A \\cos(\\omega t + \\phi)$ 和 $v(t) = \\dot{x}(t) = -A \\,\\omega \\sin(\\omega t + \\phi)$ 在时间 $t=0$ 时的幅相参数化来初始化 $(x_0,v_0)$，其中 $A$ 是振幅，$\\phi$ 是以弧度为单位的相位。\n2. 使用推导出的蛙跳方案，以步长 $\\Delta t$ 执行 $N$ 步正向积分，得到 $(x_N, v_N)$。沿此正向轨迹，计算最大绝对能量偏差\n$$\n\\max_{0 \\leq n \\leq N} \\left| E_n - E_0 \\right|, \\quad E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2,\n$$\n其中 $E_0$ 是 $t=0$ 时的初始能量。\n3. 从 $(x_N, v_N)$ 开始，使用相同的蛙跳方案和步长 $-\\Delta t$ 执行 $N$ 步反向积分，以恢复初始状态的数值近似 $(\\tilde{x}_0, \\tilde{v}_0)$。\n4. 计算相空间往返误差\n$$\n\\varepsilon_{\\text{rt}} = \\max \\left( | \\tilde{x}_0 - x_0 |, | \\tilde{v}_0 - v_0 | \\right).\n$$\n\n误差容限：您必须指定并使用以下基于浮点舍入和后向误差分析的容限。\n- 令 $\\epsilon_{\\mathrm{mach}}$ 表示双精度浮点运算的机器$\\epsilon$。使用可逆性容限\n$$\n\\tau_{\\text{rt}} = \\alpha \\,\\epsilon_{\\mathrm{mach}} \\, \\left( 1 + |x_0| + |v_0| \\right) \\, N,\n$$\n其中 $\\alpha = 200$。如果 $\\varepsilon_{\\text{rt}} \\le \\tau_{\\text{rt}}$，则声明可逆性测试通过。\n- 对于正向轨迹上的能量误差，使用二次哈密顿量的辛积分器所特有的标度特性，并设置\n$$\n\\tau_{E} = \\gamma \\, E_0 \\, (\\omega \\Delta t)^2,\n$$\n其中 $\\gamma = 4$。如果 $\\max_{0 \\leq n \\leq N} |E_n - E_0| \\le \\tau_E$，则声明能量测试通过。\n\n单位与角度：所有量都是无量纲化的，因此将 $m$、$k$、$x$、$v$、$\\Delta t$ 和 $E$ 视为无单位量。$\\phi$ 的角度单位为弧度。\n\n稳定性约束：谐振子的蛙跳方案在线性稳定的条件是 $\\omega \\Delta t < 2$。确保每个测试用例都满足 $\\omega \\Delta t < 2$。\n\n测试套件：使用以下测试用例，每个用例为一个元组 $(m,k,\\Delta t,N,A,\\phi)$。\n- 用例 $\\#1$：$(1, 1, 0.01, 10000, 1.0, 0.0)$。\n- 用例 $\\#2$：$(2, 0.5, 3.99, 100, 0.1, 1.0)$，注意此时 $\\omega = \\sqrt{0.5/2} = 0.5$，所以 $2/\\omega = 4$，而 $\\Delta t = 3.99$ 接近但低于稳定边界。\n- 用例 $\\#3$：$(1, 4, 0.7, 5000, 0.5, 0.3)$。\n- 用例 $\\#4$：$(1, 1, 1.9, 1000, 0.7, 1.2)$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个长度为 $4$ 的列表。列表的每个元素对应一个测试用例，本身是一个包含两个布尔值的列表 $[\\text{reversibility\\_ok}, \\text{energy\\_ok}]$。输出必须是单行 Python 风格的列表字面量，例如，如果所有测试都通过，则为 $[[\\text{True},\\text{True}],[\\text{True},\\text{True}],[\\text{True},\\text{True}],[\\text{True},\\text{True}]]$。\n\n角度单位说明：所有 $\\phi$ 值均以弧度为单位。无需进行其他单位转换。\n\n您的程序必须是一个完整、可运行的程序，它实现了所推导的蛙跳方案，计算了所要求的度量指标，按规定应用了容限，并以所要求的精确单行格式打印结果。不允许用户输入；所有值必须如上所述硬编码。程序必须使用双精度算术。最终打印的行必须是唯一的输出。",
            "solution": "该问题要求对一个用于一维谐振子的时间可逆 Leapfrog 积分器进行推导、实现和验证。整个过程始于从哈密顿力学的第一性原理进行推导，然后设计并执行一个数值实验，以验证算法的时间可逆性和能量守恒特性。\n\n### 对称 Leapfrog 积分器的推导\n\n该系统由哈密顿量 $H(x,p) = \\frac{p^2}{2m} + \\frac{k x^2}{2}$ 描述，它可以分离为一个动能部分 $H_T = \\frac{p^2}{2m}$ 和一个势能部分 $H_V = \\frac{k x^2}{2}$。状态向量 $(x, p)$ 的时间演化由哈密顿方程决定，这可以形式化地用刘维尔算子（Liouvillian operator）$L_H$ 写成 $\\frac{d}{dt}(x,p) = L_H(x,p)$。在一个时间步长 $\\Delta t$ 内的形式解由演化算子 $e^{\\Delta t L_H}$ 的作用给出。\n\n由于 $H = H_T + H_V$，刘维尔算子也可以分裂：$L_H = L_T + L_V$。\n算子 $L_T$ 对应于仅在哈密顿量动能部分（$k=0$）作用下的运动方程：\n$$\n\\dot{x} = \\frac{p}{m}, \\quad \\dot{p} = 0 \\implies p(t) = \\text{const}, \\quad x(t) = x(0) + \\frac{p(0)}{m}t.\n$$\n算子 $L_V$ 对应于仅在势能部分（$m \\to \\infty$，这意味着 $\\dot{x} = p/m \\to 0$）作用下的运动方程：\n$$\n\\dot{x} = 0, \\quad \\dot{p} = -kx \\implies x(t) = \\text{const}, \\quad p(t) = p(0) - kx(0)t.\n$$\n演化算子 $e^{\\Delta t L_T}$ 和 $e^{\\Delta t L_V}$ 对应于这两个简化系统的精确解。\n\n可以使用 Strang 分裂构造一个二阶精确、对称且时间可逆的积分器，该方法将精确的子解以对称序列组合。在单个时间步长 $\\Delta t$ 内，演化算子近似为：\n$$\ne^{\\Delta t L_H} \\approx e^{\\frac{\\Delta t}{2} L_V} e^{\\Delta t L_T} e^{\\frac{\\Delta t}{2} L_V}\n$$\n这对应于从状态 $(x_n, p_n)$ 到 $(x_{n+1}, p_{n+1})$ 的一个三步更新过程：\n1.  **势能半步：** 在 $H_V$ 下演化 $\\Delta t/2$ 时间。\n    $$\n    p_{n+1/2}' = p_n - k x_n \\frac{\\Delta t}{2}\n    $$\n    $$\n    x_{n+1/2}' = x_n\n    $$\n2.  **动能全步：** 将结果在 $H_T$ 下演化 $\\Delta t$ 时间。\n    $$\n    x_{n+1} = x_{n+1/2}' + \\frac{p_{n+1/2}'}{m} \\Delta t = x_n + \\frac{p_{n+1/2}'}{m} \\Delta t\n    $$\n    $$\n    p_{n+1/2}'' = p_{n+1/2}'\n    $$\n3.  **势能半步：** 将结果在 $H_V$ 下演化 $\\Delta t/2$ 时间。\n    $$\n    p_{n+1} = p_{n+1/2}'' - k x_{n+1} \\frac{\\Delta t}{2} = p_{n+1/2}' - k x_{n+1} \\frac{\\Delta t}{2}\n    $$\n    $$\n    x_{n+1} \\text{ 保持不变。}\n    $$\n为了用速度 $v=p/m$ 来表示，我们代入 $p_n = m v_n$ 并定义加速度 $a(x) = F(x)/m = -kx/m$。步骤变为：\n从 $(x_n, v_n)$ 开始：\n1.  使用在 $x_n$ 处的加速度，用半步更新速度：\n    $$v_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}$$\n2.  使用中间步的速度 $v_{n+1/2}$，用全步更新位置：\n    $$x_{n+1} = x_n + v_{n+1/2} \\Delta t$$\n3.  使用在 $x_{n+1}$ 处的新加速度，用第二个半步更新速度：\n    $$v_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}$$\n这是 Leapfrog 算法的速度-Verlet 形式。其对称构造确保了时间可逆性：在精确算术中，使用时间步长 $-\\Delta t$ 应用相同的算法会精确地逆转一个正向步骤。\n\n### 数值实验\n\n根据问题规范实现并测试所推导的算法。对于每个测试用例，执行以下程序：\n1.  **初始化：** 系统在 $t=0$ 时使用振幅 $A$ 和相位 $\\phi$ 的解析解进行初始化：$x_0 = A \\cos(\\phi)$ 和 $v_0 = -A \\omega \\sin(\\phi)$，其中 $\\omega = \\sqrt{k/m}$。初始能量为 $E_0 = \\frac{1}{2}mv_0^2 + \\frac{1}{2}kx_0^2$。\n2.  **正向积分：** 系统以步长 $\\Delta t$ 正向积分 $N$ 步。在此轨迹中，计算数值能量的最大绝对偏差 $\\max_n |E_n - E_0|$。令最终状态为 $(x_N, v_N)$。\n3.  **反向积分：** 从 $(x_N, v_N)$ 开始，系统使用时间步长 $-\\Delta t$ 反向积分 $N$ 步。得到的状态 $(\\tilde{x}_0, \\tilde{v}_0)$ 是初始状态的一个近似。\n4.  **误差评估：**\n    *   **往返误差** $\\varepsilon_{\\text{rt}} = \\max(|\\tilde{x}_0 - x_0|, |\\tilde{v}_0 - v_0|)$ 量化了数值可逆性。如果 $\\varepsilon_{\\text{rt}} \\le \\tau_{\\text{rt}}$，则测试通过，其中容限 $\\tau_{\\text{rt}} = \\alpha \\epsilon_{\\mathrm{mach}} (1 + |x_0| + |v_0|) N$（$\\alpha=200$）考虑了浮点舍入误差的预期累积。\n    *   通过将最大能量偏差与容限 $\\tau_E = \\gamma E_0 (\\omega \\Delta t)^2$（$\\gamma=4$）进行比较来测试**能量守恒误差**。如果 $\\max_n |E_n - E_0| \\le \\tau_E$，则测试通过。此容限基于辛积分器对二次哈密顿量已知误差行为，即能量误差有界且与 $(\\Delta t)^2$ 成比例。\n\n程序遍历四个指定的测试用例，执行这些计算，并为每个用例确定两个布尔结果：`reversibility_ok` 和 `energy_ok`。最终结果被汇总并以指定格式打印。使用双精度浮点算术（在 Python 中为 `float`）和 `numpy` 库对于满足精度要求至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a reversible Leapfrog integrator for a 1D harmonic oscillator.\n    Executes a predefined test suite and reports on time reversibility and energy error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, k, dt, N, A, phi)\n        (1.0, 1.0, 0.01, 10000, 1.0, 0.0),\n        (2.0, 0.5, 3.99, 100, 0.1, 1.0),\n        (1.0, 4.0, 0.7, 5000, 0.5, 0.3),\n        (1.0, 1.0, 1.9, 1000, 0.7, 1.2),\n    ]\n\n    results = []\n    \n    # Define constants for error tolerances\n    eps_mach = np.finfo(float).eps\n    alpha = 200.0\n    gamma = 4.0\n\n    def leapfrog_step(x, v, m, k, dt):\n        \"\"\"Performs a single step of the velocity-Verlet algorithm.\"\"\"\n        a = -k * x / m\n        v_half = v + a * dt / 2.0\n        x_new = x + v_half * dt\n        a_new = -k * x_new / m\n        v_new = v_half + a_new * dt / 2.0\n        return x_new, v_new\n\n    for case in test_cases:\n        m, k, dt, N, A, phi = case\n        \n        # 1. Initialization\n        omega = np.sqrt(k / m)\n        \n        # Ensure stability constraint is met (as a sanity check)\n        if omega * abs(dt) >= 2.0:\n            raise ValueError(f\"Stability condition omega*dt  2 not met for case {case}\")\n            \n        x0 = A * np.cos(phi)\n        v0 = -A * omega * np.sin(phi)\n        E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n\n        # 2. Forward integration and energy error tracking\n        x_f, v_f = x0, v0\n        max_energy_deviation = 0.0\n        for _ in range(N):\n            x_f, v_f = leapfrog_step(x_f, v_f, m, k, dt)\n            En = 0.5 * m * v_f**2 + 0.5 * k * x_f**2\n            max_energy_deviation = max(max_energy_deviation, abs(En - E0))\n        \n        xN, vN = x_f, v_f\n\n        # 3. Backward integration\n        x_b, v_b = xN, vN\n        for _ in range(N):\n            x_b, v_b = leapfrog_step(x_b, v_b, m, k, -dt)\n        \n        x_tilde_0, v_tilde_0 = x_b, v_b\n\n        # 4. Compute errors and check against tolerances\n        \n        # Reversibility test\n        err_rt = max(abs(x_tilde_0 - x0), abs(v_tilde_0 - v0))\n        tol_rt = alpha * eps_mach * (1.0 + abs(x0) + abs(v0)) * N\n        reversibility_ok = err_rt = tol_rt\n        \n        # Energy conservation test\n        tol_E = gamma * E0 * (omega * dt)**2\n        if E0 == 0:\n            # If initial energy is zero (trivial case), it must remain exactly zero\n            energy_ok = (max_energy_deviation == 0.0)\n        else:\n            energy_ok = max_energy_deviation = tol_E\n\n        # Append boolean results\n        results.append([reversibility_ok, energy_ok])\n\n    # Final print statement in the exact required format.\n    # The format requires no spaces, e.g., [[True,True],[False,True]]\n    sub_results_str = [str(res_pair).replace(' ', '') for res_pair in results]\n    print(f\"[{','.join(sub_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "像蛙跳这样的辛积分器，其真正的威力在对非线性系统（这在材料科学中很常见）进行长期模拟时才会显现出来。最后一个练习将蛙跳算法与一种标准的高阶非辛方法进行对比，您将模拟一个非线性振子，并比较蛙跳算法和四阶龙格-库塔（RK4）方法的全局误差和能量守恒性。这项对比研究将有力地证明为何蛙跳算法尽管形式精度阶数较低，却是分子动力学模拟的首选，您将观察到其有界的能量误差，这与RK4方法的系统性能量漂移形成鲜明对比 。",
            "id": "3847470",
            "problem": "考虑一个单自由度保守非线性振子，该振子用于模拟多尺度材料模拟中的一个粗粒化模式。设位移为 $x(t)$，速度为 $v(t)=\\frac{dx}{dt}$，其动力学行为由单位质量在势能 $U(x)=\\frac{1}{2}x^{2}+\\frac{\\alpha}{4}x^{4}$ 下的牛顿第二定律决定。运动方程为以下一阶系统：\n$$\n\\frac{dx}{dt} = v,\\qquad \\frac{dv}{dt} = a(x) = -\\frac{dU}{dx} = -x - \\alpha x^{3}.\n$$\n哈密顿量（总能量）为\n$$\nH(x,v) = \\frac{1}{2}v^{2} + \\frac{1}{2}x^{2} + \\frac{\\alpha}{4}x^{4},\n$$\n在连续动力学中，该哈密顿量是精确保守的。\n\n您必须实现两种显式时间积分算法，使用均匀时间步长 $\\Delta t$，在长积分时间 $T$ 内将解从 $(x(0),v(0))$ 推进到 $(x(T),v(T))$：\n- Leapfrog 算法（也称为速度 Verlet），该算法更新交错的速度，并且已知是辛算法。\n- 四阶 Runge–Kutta 方法 (RK4)，该方法以经典的四阶精度推进耦合一阶系统，但不是辛算法。\n\n对于时间步长为 $\\Delta t$ 的数值方法，定义在最终时间 $T$ 的全局状态误差为\n$$\ne(\\Delta t; T) = \\sqrt{\\left(x_{\\Delta t}(T)-x_{\\mathrm{ref}}(T)\\right)^{2} + \\left(v_{\\Delta t}(T)-v_{\\mathrm{ref}}(T)\\right)^{2}},\n$$\n其中 $(x_{\\mathrm{ref}}(T),v_{\\mathrm{ref}}(T))$ 是使用一个更小的时间步长 $\\Delta t_{\\mathrm{ref}}$ 通过 RK4 方法获得的高精度参考解。\n\n您的程序必须：\n1. 对所有量 $(x,v,t,\\alpha,\\Delta t,T)$ 使用无量纲单位。\n2. 对于下面列出的每个测试用例，使用 RK4 在 $\\Delta t_{\\mathrm{ref}}=\\Delta t_{\\mathrm{base}}/16$ 时计算参考解，然后计算每种方法在每个时间步长 $\\Delta t \\in \\{\\Delta t_{\\mathrm{base}},\\Delta t_{\\mathrm{base}}/2,\\Delta t_{\\mathrm{base}}/4\\}$ 下的全局误差 $e(\\Delta t;T)$。\n3. 对于每种方法和每个测试用例，通过对三个 $\\Delta t$ 值进行 $\\log(e)$ 与 $\\log(\\Delta t)$ 的线性最小二乘拟合来估计经验误差缩放指数 $s$，使得 $e(\\Delta t;T)\\approx C\\,(\\Delta t)^{s}$。\n4. 对于每种方法，在最粗糙的步长 $\\Delta t=\\Delta t_{\\mathrm{base}}$ 时，计算在时间 $T$ 的相对能量漂移，\n$$\nd = \\frac{\\left|H\\big(x_{\\Delta t}(T),v_{\\Delta t}(T)\\big) - H\\big(x(0),v(0)\\big)\\right|}{H\\big(x(0),v(0)\\big)}.\n$$\n\n测试套件（所有量均为无量纲）：\n- 用例 1：$\\alpha=0.1$, $x(0)=1.0$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.05$。\n- 用例 2：$\\alpha=1.0$, $x(0)=0.5$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.04$。\n- 用例 3：$\\alpha=-0.3$, $x(0)=0.8$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.04$。\n- 用例 4：$\\alpha=0.5$, $x(0)=1.2$, $v(0)=0.0$, $T=192.0$, $\\Delta t_{\\mathrm{base}}=0.03$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个包含四个浮点数的子列表，顺序为 $[s_{\\mathrm{Leapfrog}}, s_{\\mathrm{RK4}}, d_{\\mathrm{Leapfrog}}, d_{\\mathrm{RK4}}]$，其中 $s$ 是经验误差缩放指数，$d$ 是在 $\\Delta t=\\Delta t_{\\mathrm{base}}$ 时的相对能量漂移。最终格式为\n$$\n\\text{[}[s_{L,1},s_{R,1},d_{L,1},d_{R,1}],\\ [s_{L,2},s_{R,2},d_{L,2},d_{R,2}],\\ [s_{L,3},s_{R,3},d_{L,3},d_{R,3}],\\ [s_{L,4},s_{R,4},d_{L,4},d_{R,4}]\\text{]},\n$$\n每个数字都表示为十进制数。程序必须是自包含的，并且不需要任何输入。确保对于每个用例，$T/\\Delta t$ 和 $T/\\Delta t_{\\mathrm{ref}}$ 都是整数，以便所有积分都能精确达到最终时间 $T$。",
            "solution": "该问题要求实现并比较两种数值积分算法，即 Leapfrog（速度 Verlet）方法和经典的四阶 Runge-Kutta (RK4) 方法，用于求解一个保守非线性振子。比较的依据是全局误差收敛率和长期能量守恒性。该振子是一个具有单位质量的单自由度系统，其动力学由哈密顿量 $H(x,v)$ 描述。\n\n该系统由位置 $x(t)$ 和速度 $v(t)$ 定义，其势能由 $U(x) = \\frac{1}{2}x^2 + \\frac{\\alpha}{4}x^4$ 给出。运动方程构成一个一阶系统：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = a(x) = -\\frac{dU}{dx} = -x - \\alpha x^3\n$$\n总能量，即哈密顿量，在精确动力学中是一个守恒量：\n$$\nH(x,v) = \\frac{1}{2}v^2 + U(x) = \\frac{1}{2}v^2 + \\frac{1}{2}x^2 + \\frac{\\alpha}{4}x^4\n$$\n我们将使用均匀的时间步长 $\\Delta t$ 对这些方程进行离散化，以将时间 $t_n$ 的状态 $(x_n, v_n)$ 推进到时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $(x_{n+1}, v_{n+1})$。\n\n**Leapfrog (速度 Verlet) 算法**\nLeapfrog 算法是一种二阶辛积分器，这一特性使其非常适合哈密顿系统的长期模拟。其辛性保证了一个“影子”哈密顿量的守恒，该哈密顿量是真实哈密顿量的一个微扰版本，从而导致有界的能量涨落而非系统性漂移。速度 Verlet 形式是一种流行且代数上等价的变体，它在整数时间步上同步位置和速度。从时间 $t_n$ 到 $t_{n+1}$ 的更新分三步进行：\n\n1. 将速度更新半步：\n$$\nv_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}\n$$\n2. 使用半步速度将位置更新一整步：\n$$\nx_{n+1} = x_n + v_{n+1/2} \\Delta t\n$$\n3. 使用新的加速度将速度更新剩余的半步：\n$$\nv_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}\n$$\n该算法是时间可逆的，局部截断误差为 $(\\Delta t)^3$ 阶，导致全局误差为 $(\\Delta t)^2$ 阶。因此，我们预期其经验误差缩放指数 $s_{\\mathrm{Leapfrog}}$ 约为 $2$。\n\n**四阶 Runge-Kutta (RK4) 算法**\n经典的 RK4 方法是一种用于常微分方程的高阶通用显式求解器。它通过在每个步骤中于精心选择的中间点处四次计算导数函数来达到四阶精度。对于状态向量 $\\mathbf{y}(t) = [x(t), v(t)]^T$，系统为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{f}(\\mathbf{y}) = [v, a(x)]^T$。更新规则为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中四个阶段为：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = [v_n, a(x_n)]^T\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n$$\nRK4 的局部截断误差为 $(\\Delta t)^5$ 阶，导致全局误差为 $(\\Delta t)^4$ 阶。我们预期其经验误差缩放指数 $s_{\\mathrm{RK4}}$ 约为 $4$。然而，RK4 不是一个辛积分器。对于哈密顿系统，这意味着它不守恒影子哈密顿量，并且数值能量在长积分时间内通常会表现出缓慢的、系统性的漂移。\n\n**数值分析**\n为了评估这些算法，我们执行以下任务：\n\n1. **参考解**：使用 RK4 方法和一个非常小的时间步长 $\\Delta t_{\\mathrm{ref}} = \\Delta t_{\\mathrm{base}}/16$ 来计算一个高精度参考解 $(x_{\\mathrm{ref}}(T), v_{\\mathrm{ref}}(T))$。该解作为真实解析解的近似。\n\n2. **全局误差和收敛率**：对于两种算法，在时间步长 $\\Delta t \\in \\{\\Delta t_{\\mathrm{base}}, \\Delta t_{\\mathrm{base}}/2, \\Delta t_{\\mathrm{base}}/4\\}$ 下计算全局误差 $e(\\Delta t; T)$。误差被度量为相空间中数值解与参考解之间的欧几里得距离：\n$$\ne(\\Delta t; T) = \\sqrt{\\left(x_{\\Delta t}(T)-x_{\\mathrm{ref}}(T)\\right)^{2} + \\left(v_{\\Delta t}(T)-v_{\\mathrm{ref}}(T)\\right)^{2}}\n$$\n经验收敛阶 $s$ 由关系 $e(\\Delta t) \\propto (\\Delta t)^s$ 确定。取对数后，我们得到 $\\log(e) = s \\log(\\Delta t) + \\text{const}$。我们通过对点集 $(\\log(\\Delta t_i), \\log(e_i))$ 进行线性最小二乘拟合来求得 $s$。这条线的斜率就是所求的指数 $s$。\n\n3. **能量守恒**：通过计算在最粗糙时间步长 $\\Delta t_{\\mathrm{base}}$ 下最终时间 $T$ 的相对能量漂移 $d$ 来评估积分器的长期稳定性：\n$$\nd = \\frac{\\left|H\\big(x_{\\Delta t}(T),v_{\\Delta t}(T)\\big) - H\\big(x(0),v(0)\\big)\\right|}{\\left|H\\big(x(0),v(0)\\big)\\right|}\n$$\n预期结果是，对于长积分时间 $T$，Leapfrog 算法尽管阶数较低，但与会表现出能量漂移的 RK4 相比，将展现出更优的能量守恒性（即更小的 $d$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing Leapfrog and RK4 integrators for a nonlinear oscillator.\n    \"\"\"\n    \n    # Test suite: (alpha, x0, v0, T, dt_base)\n    test_cases = [\n        (0.1, 1.0, 0.0, 200.0, 0.05),\n        (1.0, 0.5, 0.0, 200.0, 0.04),\n        (-0.3, 0.8, 0.0, 200.0, 0.04),\n        (0.5, 1.2, 0.0, 192.0, 0.03),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha, x0, v0, T, dt_base = case\n\n        # Define model-specific functions\n        def acceleration(x, alpha_val):\n            return -x - alpha_val * x**3\n\n        def hamiltonian(x, v, alpha_val):\n            return 0.5 * v**2 + 0.5 * x**2 + 0.25 * alpha_val * x**4\n\n        # Define integrator step functions\n        def leapfrog_step(x, v, dt, alpha_val):\n            v_half = v + acceleration(x, alpha_val) * dt / 2.0\n            x_new = x + v_half * dt\n            v_new = v_half + acceleration(x_new, alpha_val) * dt / 2.0\n            return x_new, v_new\n\n        def rk4_step(x, v, dt, alpha_val):\n            # k1\n            k1_x = v\n            k1_v = acceleration(x, alpha_val)\n            # k2\n            x2 = x + 0.5 * dt * k1_x\n            v2 = v + 0.5 * dt * k1_v\n            k2_x = v2\n            k2_v = acceleration(x2, alpha_val)\n            # k3\n            x3 = x + 0.5 * dt * k2_x\n            v3 = v + 0.5 * dt * k2_v\n            k3_x = v3\n            k3_v = acceleration(x3, alpha_val)\n            # k4\n            x4 = x + dt * k3_x\n            v4 = v + dt * k3_v\n            k4_x = v4\n            k4_v = acceleration(x4, alpha_val)\n\n            x_new = x + (dt / 6.0) * (k1_x + 2.0 * k2_x + 2.0 * k3_x + k4_x)\n            v_new = v + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v)\n            return x_new, v_new\n\n        # Define simulation runner\n        def run_simulation(step_func, x_start, v_start, T_sim, dt_sim, alpha_val):\n            x_curr, v_curr = x_start, v_start\n            num_steps = int(round(T_sim / dt_sim))\n            for _ in range(num_steps):\n                x_curr, v_curr = step_func(x_curr, v_curr, dt_sim, alpha_val)\n            return x_curr, v_curr\n\n        # 1. Compute reference solution\n        dt_ref = dt_base / 16.0\n        x_ref, v_ref = run_simulation(rk4_step, x0, v0, T, dt_ref, alpha)\n\n        # 2. Compute global errors for different dt\n        dts = np.array([dt_base, dt_base / 2.0, dt_base / 4.0])\n        errors_leapfrog = []\n        errors_rk4 = []\n\n        for dt in dts:\n            # Leapfrog error\n            x_L, v_L = run_simulation(leapfrog_step, x0, v0, T, dt, alpha)\n            err_L = np.sqrt((x_L - x_ref)**2 + (v_L - v_ref)**2)\n            errors_leapfrog.append(err_L)\n\n            # RK4 error\n            x_R, v_R = run_simulation(rk4_step, x0, v0, T, dt, alpha)\n            err_R = np.sqrt((x_R - x_ref)**2 + (v_R - v_ref)**2)\n            errors_rk4.append(err_R)\n\n        # 3. Estimate empirical error scaling exponent s\n        log_dts = np.log(dts)\n        log_errors_L = np.log(errors_leapfrog)\n        log_errors_R = np.log(errors_rk4)\n        \n        # Use np.polyfit for linear least-squares regression. It returns [slope, intercept].\n        s_leapfrog = np.polyfit(log_dts, log_errors_L, 1)[0]\n        s_rk4 = np.polyfit(log_dts, log_errors_R, 1)[0]\n\n        # 4. Compute relative energy drift d at dt = dt_base\n        H0 = hamiltonian(x0, v0, alpha)\n\n        # Leapfrog drift\n        x_L_final, v_L_final = run_simulation(leapfrog_step, x0, v0, T, dt_base, alpha)\n        H_L_final = hamiltonian(x_L_final, v_L_final, alpha)\n        d_leapfrog = np.abs(H_L_final - H0) / np.abs(H0) if H0 != 0 else 0\n\n        # RK4 drift\n        x_R_final, v_R_final = run_simulation(rk4_step, x0, v0, T, dt_base, alpha)\n        H_R_final = hamiltonian(x_R_final, v_R_final, alpha)\n        d_rk4 = np.abs(H_R_final - H0) / np.abs(H0) if H0 != 0 else 0\n\n        case_results = [s_leapfrog, s_rk4, d_leapfrog, d_rk4]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    inner_strings = [f\"[{','.join(f'{val}' for val in res)}]\" for res in all_results]\n    final_output_str = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output_str)\n\n```"
        }
    ]
}