{
    "hands_on_practices": [
        {
            "introduction": "在使用任何数值积分方法之前，理解其稳定性极限是至关重要的。本练习将引导你对应用于简谐振子的蛙跳算法进行一次基本的稳定性分析，而简谐振子是更复杂系统的基本构成单元。通过推导其放大矩阵并分析其特征值，你将揭示系统固有频率与最大稳定时间步长 $\\Delta t$ 之间的关键关系 。",
            "id": "3847513",
            "problem": "在多尺度材料模拟中，晶格振动的时间积分通常通过分子动力学（MD）中的蛙跳算法（leapfrog algorithm）来执行。考虑一个由线性弹簧-质量系统的牛顿第二定律所支配的单一粗粒化谐振模式，$$m\\,\\ddot{x}(t) + k\\,x(t) = 0,$$ 其中 $m$ 是质量，$k$ 是有效弹簧常数。蛙跳算法在整数时间 $t^{n} = n\\,\\Delta t$ 处推进位置 $x^{n}$，并在半整数时间 $t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$ 处推进速度 $v^{n+1/2}$，使用的是在整数时间点上计算的离散加速度。\n\n从牛顿第二定律和蛙跳更新的定义出发，推导状态向量从 $$\\begin{pmatrix} x^{n} \\\\ v^{n-1/2} \\end{pmatrix}$$ 到 $$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$ 的单步线性映射，并求出该映射的特征值作为其对应的放大因子。基于常系数离散动力学系统的线性稳定性第一原理，推导为确保此振子的离散轨迹有界，时间步长 $\\Delta t$ 必须满足的条件，该条件是关于 $$\\omega \\equiv \\sqrt{\\frac{k}{m}}$$ 的函数。\n\n最后，对于一个具有代表性的粗粒化格点，其质量 $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$，弹簧常数 $$k = 64\\,\\text{N/m}$$，计算线性稳定的最大蛙跳时间步长 $$\\Delta t_{\\max}$$，并以飞秒（femtoseconds）为单位表示。将您的答案四舍五入到 $4$ 位有效数字，并报告 $$\\Delta t_{\\max}$$ 的数值（单位为飞秒，fs）。",
            "solution": "首先验证问题，以确保其科学基础扎实、提法恰当且客观。\n\n### 步骤1：提取已知条件\n- 运动方程：$$m\\,\\ddot{x}(t) + k\\,x(t) = 0$$，其中 $$m$$ 是质量，$$k$$ 是弹簧常数。\n- 蛙跳算法更新：位置 $$x^{n}$$ 在整数时间 $$t^{n} = n\\,\\Delta t$$ 处计算。速度 $$v^{n+1/2}$$ 在半整数时间 $$t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$$ 处计算。\n- 任务1：推导从状态向量 $$\\begin{pmatrix} x^{n} \\\\ v^{n-1/2} \\end{pmatrix}$$ 到 $$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$ 的单步线性映射。\n- 任务2：求此映射的放大因子（特征值）。\n- 任务3：推导 $$\\Delta t$$ 作为 $$\\omega \\equiv \\sqrt{\\frac{k}{m}}$$ 的函数的稳定性条件。\n- 任务4：对于 $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$ 和 $$k = 64\\,\\text{N/m}$$，计算线性稳定的最大时间步长 $$\\Delta t_{\\max}$$（单位为飞秒），并四舍五入到 $$4$$ 位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学基础**：该问题描述了应用于简谐振子的蛙跳法（或Störmer-Verlet法）的线性稳定性分析。这是数值分析和计算物理学中的一个典型问题，在分子动力学模拟中尤其重要。其模型和方法都是公认的。\n- **提法恰当**：问题阐述清晰。它要求推导一个转移矩阵、其特征值、由此产生的稳定性条件以及最终的数值计算。所有必要的定义和数据都已提供，并且存在唯一且有意义的解。\n- **客观性**：问题使用了精确、标准的科学术语进行陈述。它没有歧义和主观性。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n谐振子的控制方程由牛顿第二定律给出：\n$$m\\,\\ddot{x}(t) + k\\,x(t) = 0$$\n这可以根据角频率 $$\\omega = \\sqrt{k/m}$$ 改写为：\n$$\\ddot{x}(t) = -\\omega^2 x(t)$$\n在任意时间 $$t$$ 的加速度为 $$a(t) = \\ddot{x}(t) = -\\omega^2 x(t)$$。\n\n蛙跳算法使用交错的时间网格。更新定义如下：\n$1$. 速度从时间 $$t^{n-1/2}$$ 更新到 $$t^{n+1/2}$$，使用在整数时间步 $$t^n$$ 处计算的加速度。\n$$v^{n+1/2} = v^{n-1/2} + a(t^n)\\,\\Delta t = v^{n-1/2} + a(x^n)\\,\\Delta t$$\n$2$. 位置从时间 $$t^n$$ 更新到 $$t^{n+1}$$，使用在半整数时间步 $$t^{n+1/2}$$ 处新计算的速度。\n$$x^{n+1} = x^n + v^{n+1/2}\\,\\Delta t$$\n\n我们的任务是找到将状态向量 $$\\begin{pmatrix} x^n \\\\ v^{n-1/2} \\end{pmatrix}$$ 转换为 $$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$ 的线性映射。为此，我们将加速度的表达式 $$a(x^n) = -\\omega^2 x^n$$ 代入速度更新方程：\n$$v^{n+1/2} = v^{n-1/2} - (\\omega^2 x^n)\\,\\Delta t$$\n这个方程可以改写为：\n$$v^{n+1/2} = -\\omega^2 \\Delta t\\,x^n + v^{n-1/2}$$\n\n接下来，我们将这个新的 $$v^{n+1/2}$$ 表达式代入位置更新方程：\n$$x^{n+1} = x^n + (v^{n-1/2} - \\omega^2 \\Delta t\\,x^n)\\,\\Delta t$$\n$$x^{n+1} = x^n + v^{n-1/2}\\,\\Delta t - \\omega^2 (\\Delta t)^2 x^n$$\n重新排列各项，将 $$x^n$$ 和 $$v^{n-1/2}$$ 分组：\n$$x^{n+1} = (1 - \\omega^2 (\\Delta t)^2)\\,x^n + \\Delta t\\,v^{n-1/2}$$\n\n我们现在有一个由两个线性方程组成的系统，它将步骤 $$n+1$$ 的状态与步骤 $$n$$ 的状态联系起来：\n$$x^{n+1} = (1 - \\omega^2 (\\Delta t)^2)\\,x^n + \\Delta t\\,v^{n-1/2}$$\n$$v^{n+1/2} = -\\omega^2 \\Delta t\\,x^n + 1 \\cdot v^{n-1/2}$$\n\n这个系统可以写成矩阵形式，代表了单步线性映射：\n$$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix} = \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2   \\Delta t \\\\ -\\omega^2 \\Delta t   1 \\end{pmatrix} \\begin{pmatrix} x^n \\\\ v^{n-1/2} \\end{pmatrix}$$\n此方程中的矩阵是转移矩阵，通常称为放大矩阵，$$\\mathbf{A}$$。\n$$\\mathbf{A} = \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2   \\Delta t \\\\ -\\omega^2 \\Delta t   1 \\end{pmatrix}$$\n\n放大因子是矩阵 $$\\mathbf{A}$$ 的特征值 $$\\lambda$$。它们通过求解特征方程 $$\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$$ 来找到，其中 $$\\mathbf{I}$$ 是单位矩阵。\n$$\\det \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 - \\lambda   \\Delta t \\\\ -\\omega^2 \\Delta t   1 - \\lambda \\end{pmatrix} = 0$$\n$$(1 - \\omega^2 (\\Delta t)^2 - \\lambda)(1 - \\lambda) - (\\Delta t)(-\\omega^2 \\Delta t) = 0$$\n$$1 - \\lambda - \\omega^2 (\\Delta t)^2 + \\lambda \\omega^2 (\\Delta t)^2 - \\lambda + \\lambda^2 + \\omega^2 (\\Delta t)^2 = 0$$\n$$\\lambda^2 + (\\omega^2 (\\Delta t)^2 - 2)\\lambda + 1 = 0$$\n\n我们使用二次公式 $$\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$ 来求解这个关于 $$\\lambda$$ 的二次方程，其中 $$a=1$$，$$b = \\omega^2 (\\Delta t)^2 - 2$$，以及 $$c=1$$。\n$$\\lambda = \\frac{-( \\omega^2 (\\Delta t)^2 - 2) \\pm \\sqrt{(\\omega^2 (\\Delta t)^2 - 2)^2 - 4}}{2}$$\n$$\\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(\\omega \\Delta t)^4 - 4(\\omega \\Delta t)^2 + 4 - 4}}{2}$$\n$$\\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(\\omega \\Delta t)^2 ((\\omega \\Delta t)^2 - 4)}}{2}$$\n$$\\lambda = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm \\frac{\\omega \\Delta t}{2}\\sqrt{(\\omega \\Delta t)^2 - 4}$$\n\n对于一个离散动力学系统，要使其解有界，它必须是稳定的。线性稳定性要求所有特征值的模（即 $$\\mathbf{A}$$ 的谱半径）不得超过 $$1$$。也就是说，$$|\\lambda| \\le 1$$。我们通过检查平方根下的项 $$(\\omega \\Delta t)^2 - 4$$ 来分析这个条件。\n\n情况1：$$(\\omega \\Delta t)^2  4$$，或 $$|\\omega \\Delta t|  2$$。\n特征值是实数。两个特征值的乘积是 $$\\lambda_1 \\lambda_2 = c/a = 1$$。如果特征值是实数且不等于 $$\\pm 1$$，则其中一个的模必须大于 $$1$$，另一个的模必须小于 $$1$$。这对应于一个指数增长的不稳定模式。系统是不稳定的。\n\n情况2：$$(\\omega \\Delta t)^2 = 4$$，或 $$|\\omega \\Delta t| = 2$$。\n平方根下的项为零，产生一个退化的特征值 $$\\lambda = 1 - \\frac{4}{2} = -1$$。由于 $$|\\lambda| = 1$$，这是稳定性的边界（临界稳定）。\n\n情况3：$$(\\omega \\Delta t)^2  4$$，或 $$|\\omega \\Delta t|  2$$。\n平方根下的项是负数。特征值是一对共轭复数。\n$$\\lambda = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm i \\frac{\\omega \\Delta t}{2}\\sqrt{4 - (\\omega \\Delta t)^2}$$\n这些特征值的模的平方是：\n$$|\\lambda|^2 = \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 + \\left(\\frac{\\omega \\Delta t}{2}\\sqrt{4 - (\\omega \\Delta t)^2}\\right)^2$$\n$$|\\lambda|^2 = 1 - (\\omega \\Delta t)^2 + \\frac{(\\omega \\Delta t)^4}{4} + \\frac{(\\omega \\Delta t)^2}{4}(4 - (\\omega \\Delta t)^2)$$\n$$|\\lambda|^2 = 1 - (\\omega \\Delta t)^2 + \\frac{(\\omega \\Delta t)^4}{4} + (\\omega \\Delta t)^2 - \\frac{(\\omega \\Delta t)^4}{4}$$\n$$|\\lambda|^2 = 1$$\n因此，$$|\\lambda| = 1$$。在这种情况下，特征值位于复平面的单位圆上。离散演化在某种意义上保持了状态向量的范数，从而导致有界的振荡解。系统是稳定的。\n\n综合这些情况，线性稳定性（有界轨迹）的条件是 $$|\\omega \\Delta t| \\le 2$$。由于 $$\\omega  0$$ 且 $$\\Delta t  0$$，这可以简化为：\n$$\\omega \\Delta t \\le 2$$\n$$\\Delta t \\le \\frac{2}{\\omega}$$\n\n因此，线性稳定的最大时间步长是 $$\\Delta t_{\\max} = \\frac{2}{\\omega}$$。\n\n最后，我们根据给定的参数 $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$ 和 $$k = 64\\,\\text{N/m}$$ 来计算 $$\\Delta t_{\\max}$$ 的数值。首先，我们计算 $$\\omega$$：\n$$\\omega = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{64\\,\\text{N/m}}{4.6636 \\times 10^{-26}\\,\\text{kg}}}$$\n$$\\omega \\approx \\sqrt{1.37229134 \\times 10^{27}\\,\\text{s}^{-2}} \\approx 3.7044448 \\times 10^{13}\\,\\text{rad/s}$$\n\n现在我们可以计算 $$\\Delta t_{\\max}$$：\n$$\\Delta t_{\\max} = \\frac{2}{\\omega} \\approx \\frac{2}{3.7044448 \\times 10^{13}\\,\\text{s}^{-1}}$$\n$$\\Delta t_{\\max} \\approx 5.398923 \\times 10^{-14}\\,\\text{s}$$\n\n问题要求答案以飞秒（$$1\\,\\text{fs} = 10^{-15}\\,\\text{s}$$）为单位。\n$$\\Delta t_{\\max} \\approx 5.398923 \\times 10^{-14}\\,\\text{s} \\times \\frac{1\\,\\text{fs}}{10^{-15}\\,\\text{s}} = 53.98923\\,\\text{fs}$$\n\n四舍五入到 $$4$$ 位有效数字，我们得到：\n$$\\Delta t_{\\max} \\approx 53.99\\,\\text{fs}$$",
            "answer": "$$\n\\boxed{53.99}\n$$"
        },
        {
            "introduction": "时间可逆性是蛙跳算法的一个关键几何特性，对其在长期模拟中的保真度至关重要。本练习要求你实现该算法，并设计一个“往返”数值实验，以验证该算法在机器精度下的可逆性。这个实践将为抽象的理论概念提供具体、可操作的证明 。",
            "id": "3847494",
            "problem": "您需要为一维谐振子设计、实现并验证一个可逆蛙跳（也称为 Störmer–Verlet 或速度-Verlet）时间积分器，该系统是多尺度材料模拟中出现的模型系统。您的任务是从第一性原理出发，推导出一个对称、时间可逆的更新法则，将其在一个完整的程序中实现，然后运行一个数值实验，以验证其时间可逆性达到机器精度，并评估其能量误差的标度。您的程序必须执行一个预定义的测试套件，并以指定格式输出单行结果。\n\n基本原理：从哈密顿力学出发，考虑一个一维质量-弹簧系统，其哈密顿量为\n$$\nH(x,p) = \\frac{p^2}{2m} + \\frac{k x^2}{2},\n$$\n其中 $x$ 是位置，$p$ 是动量，$m$ 是质量，$k$ 是刚度。哈密顿方程为\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial x} = -k x.\n$$\n定义速度 $v = \\dot{x} = p/m$。系统的自然频率是 $\\omega = \\sqrt{k/m}$。\n\n推导要求：仅使用上述基本定律和速度的定义，推导出哈密顿流的一个对称算子分裂，将其分为动能部分和势能部分，从而得到一个二阶、时间可逆的蛙跳更新法则。请勿引用任何无法从所述基础推导出的公式。具体要求如下：\n- 将单个时间步长 $\\Delta t$ 内的演化分解为多个子步骤，这些子步骤分别精确地积分动能部分（$k = 0$）和势能部分（$m \\to \\infty$），然后将它们在 $\\Delta t$ 上对称地组合，以获得一个二阶方法。该组合在时间上必须是对称的，以便在精确算术中，将 $\\Delta t$ 替换为 $-\\Delta t$ 能精确地逆转一个步骤。\n- 用更新 $(x,v)$ 的形式来表达算法，更新的子步长与 $\\Delta t$ 成比例，确保该方案在线性稳定域内对任何 $(m,k,\\Delta t)$ 都是自洽且定义明确的。\n\n数值实验设计：对于下文中的每个测试用例，执行以下操作。\n1.  根据解析解 $x(t) = A \\cos(\\omega t + \\phi)$ 和 $v(t) = \\dot{x}(t) = -A \\,\\omega \\sin(\\omega t + \\phi)$ 在时间 $t=0$ 时的振幅-相位参数化，初始化 $(x_0,v_0)$，其中 $A$ 是振幅，$\\phi$ 是以弧度为单位的相位。\n2.  使用推导出的蛙跳方案，以步长 $\\Delta t$ 执行 $N$ 步正向积分，得到 $(x_N, v_N)$。在此正向轨迹上，计算最大绝对能量偏差\n$$\n\\max_{0 \\leq n \\leq N} \\left| E_n - E_0 \\right|, \\quad E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2,\n$$\n其中 $E_0$ 是 $t=0$ 时的初始能量。\n3.  从 $(x_N, v_N)$ 开始，使用相同的蛙跳方案，以步长 $-\\Delta t$ 执行 $N$ 步反向积分，以恢复初始状态的数值近似值 $(\\tilde{x}_0, \\tilde{v}_0)$。\n4.  计算相空间往返误差\n$$\n\\varepsilon_{\\text{rt}} = \\max \\left( | \\tilde{x}_0 - x_0 |, | \\tilde{v}_0 - v_0 | \\right).\n$$\n\n误差容差：您必须指定并使用以下基于浮点舍入和后向误差分析的容差。\n- 令 $\\epsilon_{\\mathrm{mach}}$ 表示双精度浮点运算的机器ε。使用可逆性容差\n$$\n\\tau_{\\text{rt}} = \\alpha \\,\\epsilon_{\\mathrm{mach}} \\, \\left( 1 + |x_0| + |v_0| \\right) \\, N,\n$$\n其中 $\\alpha = 200$。如果 $\\varepsilon_{\\text{rt}} \\le \\tau_{\\text{rt}}$，则声明可逆性测试通过。\n- 对于正向轨迹上的能量误差，使用辛积分器对二次哈密顿量的典型标度特性，并设置\n$$\n\\tau_{E} = \\gamma \\, E_0 \\, (\\omega \\Delta t)^2,\n$$\n其中 $\\gamma = 4$。如果 $\\max_{0 \\leq n \\leq N} |E_n - E_0| \\le \\tau_E$，则声明能量测试通过。\n\n单位与角度：所有量都是无量纲化的，因此将 $m$、$k$、$x$、$v$、$\\Delta t$ 和 $E$ 视为无单位量。$\\phi$ 的角度单位为弧度。\n\n稳定性约束：谐振子的蛙跳方案在线性稳定条件 $\\omega \\Delta t  2$ 下是稳定的。确保每个测试用例都满足 $\\omega \\Delta t  2$。\n\n测试套件：使用以下测试用例，每个用例为一个元组 $(m,k,\\Delta t,N,A,\\phi)$。\n- 用例 $\\#1$：$(1, 1, 0.01, 10000, 1.0, 0.0)$。\n- 用例 $\\#2$：$(2, 0.5, 3.99, 100, 0.1, 1.0)$，注意此时 $\\omega = \\sqrt{0.5/2} = 0.5$，因此 $2/\\omega = 4$，而 $\\Delta t = 3.99$ 接近但低于稳定性边界。\n- 用例 $\\#3$：$(1, 4, 0.7, 5000, 0.5, 0.3)$。\n- 用例 $\\#4$：$(1, 1, 1.9, 1000, 0.7, 1.2)$。\n\n要求的最终输出格式：您的程序应生成单行输出，包含一个长度为 $4$ 的列表，其中每个元素对应一个测试用例，并且本身是一个包含两个布尔值的列表 $[\\text{reversibility\\_ok}, \\text{energy\\_ok}]$。输出必须是单行的 Python 风格列表字面量，例如，如果所有测试都通过，则为 $[[\\text{True},\\text{True}],[\\text{True},\\text{True}],[\\text{True},\\text{True}],[\\text{True},\\text{True}]]$。\n\n角度单位说明：所有 $\\phi$ 值均以弧度为单位。不需要其他单位转换。\n\n您的程序必须是一个完整、可运行的程序，实现所推导的蛙跳方案，计算所要求的指标，按规定应用容差，并以要求的精确单行格式打印结果。不允许用户输入；所有值必须如上所述进行硬编码。程序必须使用双精度算术。最终打印的行必须是唯一的输出。",
            "solution": "该问题要求对一维谐振子进行时间可逆蛙跳积分器的推导、实现和验证。该过程始于从哈密顿力学的第一性原理进行推导，随后设计并执行数值实验，以验证算法的时间可逆性和能量守恒属性。\n\n### 对称蛙跳积分器的推导\n\n系统由哈密顿量 $H(x,p) = \\frac{p^2}{2m} + \\frac{k x^2}{2}$ 描述，该哈密顿量可分离为动能部分 $H_T = \\frac{p^2}{2m}$ 和势能部分 $H_V = \\frac{k x^2}{2}$。状态向量 $(x, p)$ 的时间演化由哈密顿方程控制，这可以形式化地用刘维尔算子 $L_H$ 表示为 $\\frac{d}{dt}(x,p) = L_H(x,p)$。在一个时间步长 $\\Delta t$ 上的形式解由演化算子 $e^{\\Delta t L_H}$ 的作用给出。\n\n由于 $H = H_T + H_V$，刘维尔算子也相应分裂：$L_H = L_T + L_V$。\n算子 $L_T$ 对应于仅在哈密顿量动能部分（$k=0$）作用下的运动方程：\n$$\n\\dot{x} = \\frac{p}{m}, \\quad \\dot{p} = 0 \\implies p(t) = \\text{const}, \\quad x(t) = x(0) + \\frac{p(0)}{m}t.\n$$\n算子 $L_V$ 对应于仅在哈密顿量势能部分（$m \\to \\infty$，意味着 $\\dot{x} = p/m \\to 0$）作用下的运动方程：\n$$\n\\dot{x} = 0, \\quad \\dot{p} = -kx \\implies x(t) = \\text{const}, \\quad p(t) = p(0) - kx(0)t.\n$$\n演化算子 $e^{\\Delta t L_T}$ 和 $e^{\\Delta t L_V}$ 分别对应这两个简化系统的精确解。\n\n可以使用 Strang 分裂构建一个二阶精确、对称且时间可逆的积分器，该方法将精确的子解按对称序列组合。在单个时间步长 $\\Delta t$ 内，演化算子近似为：\n$$\ne^{\\Delta t L_H} \\approx e^{\\frac{\\Delta t}{2} L_V} e^{\\Delta t L_T} e^{\\frac{\\Delta t}{2} L_V}\n$$\n这对应于从状态 $(x_n, p_n)$ 到 $(x_{n+1}, p_{n+1})$ 的三步更新：\n1.  **势能半步：** 在 $H_V$ 下演化时间 $\\Delta t/2$。\n    $$\n    p_{n+1/2}' = p_n - k x_n \\frac{\\Delta t}{2}\n    $$\n    $$\n    x_{n+1/2}' = x_n\n    $$\n2.  **动能整步：** 将结果在 $H_T$ 下演化时间 $\\Delta t$。\n    $$\n    x_{n+1} = x_{n+1/2}' + \\frac{p_{n+1/2}'}{m} \\Delta t = x_n + \\frac{p_{n+1/2}'}{m} \\Delta t\n    $$\n    $$\n    p_{n+1/2}'' = p_{n+1/2}'\n    $$\n3.  **势能半步：** 将结果在 $H_V$ 下演化时间 $\\Delta t/2$。\n    $$\n    p_{n+1} = p_{n+1/2}'' - k x_{n+1} \\frac{\\Delta t}{2} = p_{n+1/2}' - k x_{n+1} \\frac{\\Delta t}{2}\n    $$\n    $$\n    x_{n+1} \\text{ 保持不变。}\n    $$\n为了用速度 $v=p/m$ 来表示，我们代入 $p_n = m v_n$ 并定义加速度 $a(x) = F(x)/m = -kx/m$。步骤变为：\n从 $(x_n, v_n)$ 开始：\n1.  使用在 $x_n$ 处的加速度，以半步更新速度：\n    $$v_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}$$\n2.  使用中间步的速度 $v_{n+1/2}$，以整步更新位置：\n    $$x_{n+1} = x_n + v_{n+1/2} \\Delta t$$\n3.  使用在 $x_{n+1}$ 处的新加速度，以第二个半步更新速度：\n    $$v_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}$$\n这就是蛙跳算法的速度-Verlet 形式。其对称结构确保了时间可逆性：在精确算术中，使用时间步长 $-\\Delta t$ 应用相同的算法会精确地逆转一个正向步骤。\n\n### 数值实验\n\n根据问题说明实现并测试了推导出的算法。对每个测试用例执行以下过程：\n1.  **初始化：** 系统在 $t=0$ 时使用振幅 $A$ 和相位 $\\phi$ 的解析解进行初始化：$x_0 = A \\cos(\\phi)$ 和 $v_0 = -A \\omega \\sin(\\phi)$，其中 $\\omega = \\sqrt{k/m}$。初始能量为 $E_0 = \\frac{1}{2}mv_0^2 + \\frac{1}{2}kx_0^2$。\n2.  **正向积分：** 系统以步长 $\\Delta t$ 正向积分 $N$ 步。在此轨迹中，计算数值能量的最大绝对偏差 $\\max_n |E_n - E_0|$。令最终状态为 $(x_N, v_N)$。\n3.  **反向积分：** 从 $(x_N, v_N)$ 开始，系统使用时间步长 $-\\Delta t$ 反向积分 $N$ 步。得到的状态 $(\\tilde{x}_0, \\tilde{v}_0)$ 是初始状态的近似值。\n4.  **误差评估：**\n    *   **往返误差** $\\varepsilon_{\\text{rt}} = \\max(|\\tilde{x}_0 - x_0|, |\\tilde{v}_0 - v_0|)$ 量化了数值可逆性。如果 $\\varepsilon_{\\text{rt}} \\le \\tau_{\\text{rt}}$，则测试通过，其中容差 $\\tau_{\\text{rt}} = \\alpha \\epsilon_{\\mathrm{mach}} (1 + |x_0| + |v_0|) N$ (其中 $\\alpha=200$) 考虑了浮点舍入误差的预期累积。\n    *   **能量守恒误差**通过将最大能量偏差与容差 $\\tau_E = \\gamma E_0 (\\omega \\Delta t)^2$ (其中 $\\gamma=4$) 进行比较来测试。如果 $\\max_n |E_n - E_0| \\le \\tau_E$，则测试通过。此容差基于辛积分器对二次哈密顿量的已知误差行为，其能量误差有界且与 $(\\Delta t)^2$ 成比例。\n\n程序遍历四个指定的测试用例，执行这些计算，并为每个用例确定两个布尔结果：`reversibility_ok` 和 `energy_ok`。最终结果被汇总并以指定格式打印。使用双精度浮点运算（Python 中的 `float`）和 `numpy` 库对于满足精度要求至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a reversible Leapfrog integrator for a 1D harmonic oscillator.\n    Executes a predefined test suite and reports on time reversibility and energy error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, k, dt, N, A, phi)\n        (1.0, 1.0, 0.01, 10000, 1.0, 0.0),\n        (2.0, 0.5, 3.99, 100, 0.1, 1.0),\n        (1.0, 4.0, 0.7, 5000, 0.5, 0.3),\n        (1.0, 1.0, 1.9, 1000, 0.7, 1.2),\n    ]\n\n    results = []\n    \n    # Define constants for error tolerances\n    eps_mach = np.finfo(float).eps\n    alpha = 200.0\n    gamma = 4.0\n\n    def leapfrog_step(x, v, m, k, dt):\n        \"\"\"Performs a single step of the velocity-Verlet algorithm.\"\"\"\n        a = -k * x / m\n        v_half = v + a * dt / 2.0\n        x_new = x + v_half * dt\n        a_new = -k * x_new / m\n        v_new = v_half + a_new * dt / 2.0\n        return x_new, v_new\n\n    for case in test_cases:\n        m, k, dt, N, A, phi = case\n        \n        # 1. Initialization\n        omega = np.sqrt(k / m)\n        \n        # Ensure stability constraint is met (as a sanity check)\n        if omega * abs(dt) >= 2.0:\n            raise ValueError(f\"Stability condition omega*dt  2 not met for case {case}\")\n            \n        x0 = A * np.cos(phi)\n        v0 = -A * omega * np.sin(phi)\n        E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n\n        # 2. Forward integration and energy error tracking\n        x_f, v_f = x0, v0\n        max_energy_deviation = 0.0\n        for _ in range(N):\n            x_f, v_f = leapfrog_step(x_f, v_f, m, k, dt)\n            En = 0.5 * m * v_f**2 + 0.5 * k * x_f**2\n            max_energy_deviation = max(max_energy_deviation, abs(En - E0))\n        \n        xN, vN = x_f, v_f\n\n        # 3. Backward integration\n        x_b, v_b = xN, vN\n        for _ in range(N):\n            x_b, v_b = leapfrog_step(x_b, v_b, m, k, -dt)\n        \n        x_tilde_0, v_tilde_0 = x_b, v_b\n\n        # 4. Compute errors and check against tolerances\n        \n        # Reversibility test\n        err_rt = max(abs(x_tilde_0 - x0), abs(v_tilde_0 - v0))\n        tol_rt = alpha * eps_mach * (1.0 + abs(x0) + abs(v0)) * N\n        reversibility_ok = err_rt = tol_rt\n        \n        # Energy conservation test\n        tol_E = gamma * E0 * (omega * dt)**2\n        if E0 == 0:\n            # If initial energy is zero (trivial case), it must remain exactly zero\n            energy_ok = (max_energy_deviation == 0.0)\n        else:\n            energy_ok = max_energy_deviation = tol_E\n\n        # Append boolean results\n        results.append([reversibility_ok, energy_ok])\n\n    # Final print statement in the exact required format.\n    # The format requires no spaces, e.g., [[True,True],[False,True]]\n    sub_results_str = [str(res_pair).replace(' ', '') for res_pair in results]\n    print(f\"[{','.join(sub_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "像蛙跳算法这样的辛积分器，其真正的威力体现在对非线性系统的长期模拟中。本练习将蛙跳算法与阶数更高但非辛的经典龙格-库塔（RK4）方法进行对比。通过这个对比，你将亲眼见证蛙跳算法在长时间尺度上卓越的能量守恒特性，这对于分子动力学模拟而言是至关重要的 。",
            "id": "3847470",
            "problem": "考虑一个单自由度、保守非线性振子，该振子用于模拟多尺度材料模拟中的粗粒化模式。设位移为 $x(t)$，速度为 $v(t)=\\frac{dx}{dt}$，其动力学由单位质量在势能 $U(x)=\\frac{1}{2}x^{2}+\\frac{\\alpha}{4}x^{4}$ 下的牛顿第二定律决定。运动方程为以下一阶系统\n$$\n\\frac{dx}{dt} = v,\\qquad \\frac{dv}{dt} = a(x) = -\\frac{dU}{dx} = -x - \\alpha x^{3}.\n$$\n哈密顿量（总能量）为\n$$\nH(x,v) = \\frac{1}{2}v^{2} + \\frac{1}{2}x^{2} + \\frac{\\alpha}{4}x^{4},\n$$\n它在连续动力学中是精确守恒的。\n\n您必须实现两种显式时间积分算法，使用均匀的时间步长 $\\Delta t$，在较长的积分时间 $T$ 内将解从 $(x(0),v(0))$推进到 $(x(T),v(T))$：\n- Leapfrog 算法（也称为速度 Verlet），它更新交错的速度，并且是已知的辛算法。\n- 龙格-库塔四阶方法（RK4），它以经典的四阶精度推进耦合一阶系统，但不是辛算法。\n\n对于时间步长为 $\\Delta t$ 的数值方法，在最终时间 $T$ 的全局状态误差定义为\n$$\ne(\\Delta t; T) = \\sqrt{\\left(x_{\\Delta t}(T)-x_{\\mathrm{ref}}(T)\\right)^{2} + \\left(v_{\\Delta t}(T)-v_{\\mathrm{ref}}(T)\\right)^{2}},\n$$\n其中 $(x_{\\mathrm{ref}}(T),v_{\\mathrm{ref}}(T))$ 是使用一个更小的时间步长 $\\Delta t_{\\mathrm{ref}}$ 通过 RK4 方法获得的高精度参考解。\n\n您的程序必须：\n1. 对所有量 $(x,v,t,\\alpha,\\Delta t,T)$ 使用无量纲单位。\n2. 对于下面列出的每个测试用例，使用 $\\Delta t_{\\mathrm{ref}}=\\Delta t_{\\mathrm{base}}/16$ 的 RK4 方法计算参考解，然后对每种方法和每个时间步长 $\\Delta t \\in \\{\\Delta t_{\\mathrm{base}},\\Delta t_{\\mathrm{base}}/2,\\Delta t_{\\mathrm{base}}/4\\}$ 计算全局误差 $e(\\Delta t;T)$。\n3. 对于每种方法和每个测试用例，通过对三个 $\\Delta t$ 值进行 $\\log(e)$ 与 $\\log(\\Delta t)$ 的线性最小二乘拟合，来估计经验误差缩放指数 $s$，使得 $e(\\Delta t;T)\\approx C\\,(\\Delta t)^{s}$。\n4. 对于每种方法，在最粗糙的步长 $\\Delta t=\\Delta t_{\\mathrm{base}}$ 下，计算在时间 $T$ 的相对能量漂移，\n$$\nd = \\frac{\\left|H\\big(x_{\\Delta t}(T),v_{\\Delta t}(T)\\big) - H\\big(x(0),v(0)\\big)\\right|}{H\\big(x(0),v(0)\\big)}.\n$$\n\n测试套件（所有量均为无量纲）：\n- 用例 1：$\\alpha=0.1$, $x(0)=1.0$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.05$。\n- 用例 2：$\\alpha=1.0$, $x(0)=0.5$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.04$。\n- 用例 3：$\\alpha=-0.3$, $x(0)=0.8$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.04$。\n- 用例 4：$\\alpha=0.5$, $x(0)=1.2$, $v(0)=0.0$, $T=192.0$, $\\Delta t_{\\mathrm{base}}=0.03$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例贡献一个包含四个浮点数的子列表，顺序为 $[s_{\\mathrm{Leapfrog}}, s_{\\mathrm{RK4}}, d_{\\mathrm{Leapfrog}}, d_{\\mathrm{RK4}}]$，其中 $s$ 是经验误差缩放指数，$d$ 是在 $\\Delta t=\\Delta t_{\\mathrm{base}}$ 时的相对能量漂移。最终格式为\n$$\n\\text{[}[s_{L,1},s_{R,1},d_{L,1},d_{R,1}],\\ [s_{L,2},s_{R,2},d_{L,2},d_{R,2}],\\ [s_{L,3},s_{R,3},d_{L,3},d_{R,3}],\\ [s_{L,4},s_{R,4},d_{L,4},d_{R,4}]\\text{]},\n$$\n其中每个数字都表示为十进制数。程序必须是自包含的，并且不需要任何输入。确保对于每个用例，$T/\\Delta t$ 和 $T/\\Delta t_{\\mathrm{ref}}$ 都是整数，以便所有积分都能精确达到最终时间 $T$。",
            "solution": "该问题要求为一个保守非线性振子实现并比较两种数值积分算法：Leapfrog（速度 Verlet）方法和经典的四阶龙格-库塔（RK4）方法。比较的依据是全局误差收敛率和长期能量守恒性。该振子是一个单位质量的单自由度系统，其动力学由哈密顿量 $H(x,v)$ 描述。\n\n该系统由位置 $x(t)$ 和速度 $v(t)$ 定义，其势能由 $U(x) = \\frac{1}{2}x^2 + \\frac{\\alpha}{4}x^4$ 给出。运动方程构成一个一阶系统：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = a(x) = -\\frac{dU}{dx} = -x - \\alpha x^3\n$$\n总能量，即哈密顿量，在精确动力学中是一个守恒量：\n$$\nH(x,v) = \\frac{1}{2}v^2 + U(x) = \\frac{1}{2}v^2 + \\frac{1}{2}x^2 + \\frac{\\alpha}{4}x^4\n$$\n我们将使用均匀的时间步长 $\\Delta t$ 对这些方程进行离散化，以将时间 $t_n$ 的状态 $(x_n, v_n)$ 推进到时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $(x_{n+1}, v_{n+1})$。\n\n**Leapfrog（速度 Verlet）算法**\nLeapfrog 算法是一种二阶辛积分器，这一特性使其特别适用于哈密顿系统的长期模拟。其辛性能确保了一个“影子”哈密顿量的守恒，该哈密顿量是真实哈密顿量的一个微扰版本，这导致能量在有界范围内波动，而不是出现系统性漂移。速度 Verlet 格式是一种流行且代数上等价的变体，它在整数时间步长上同步位置和速度。从时间 $t_n$ 到 $t_{n+1}$ 的更新分三步进行：\n\n$1$. 将速度更新半个步长：\n$$\nv_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}\n$$\n$2$. 使用半步速度将位置更新一个完整步长：\n$$\nx_{n+1} = x_n + v_{n+1/2} \\Delta t\n$$\n$3$. 使用新的加速度将速度更新剩余的半个步长：\n$$\nv_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}\n$$\n该算法是时间可逆的，局部截断误差为 $(\\Delta t)^3$ 阶，导致全局误差为 $(\\Delta t)^2$ 阶。因此，我们预期其经验误差缩放指数 $s_{\\mathrm{Leapfrog}}$ 约为 2。\n\n**四阶龙格-库塔（RK4）算法**\n经典的 RK4 方法是一种用于常微分方程的高阶、通用显式求解器。它通过在每个步长中于精心选择的中间点上四次评估导数函数来实现四阶精度。对于状态向量 $\\mathbf{y}(t) = [x(t), v(t)]^T$，系统为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{f}(\\mathbf{y}) = [v, a(x)]^T$。更新规则为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中四个阶段为：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = [v_n, a(x_n)]^T\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n$$\nRK4 的局部截断误差为 $(\\Delta t)^5$ 阶，导致全局误差为 $(\\Delta t)^4$ 阶。我们预期其经验误差缩放指数 $s_{\\mathrm{RK4}}$ 约为 4。然而，RK4 不是辛积分器。对于哈密顿系统，这意味着它不守恒影子哈密顿量，并且数值能量在长时间积分中通常会表现出缓慢的系统性漂移。\n\n**数值分析**\n为了评估这些算法，我们执行以下任务：\n\n$1$. **参考解**：使用 RK4 方法和一个非常小的时间步长 $\\Delta t_{\\mathrm{ref}} = \\Delta t_{\\mathrm{base}}/16$ 计算高精度参考解 $(x_{\\mathrm{ref}}(T), v_{\\mathrm{ref}}(T))$。该解作为真实解析解的代理。\n\n$2$. **全局误差和收敛率**：对于两种算法，在时间步长 $\\Delta t \\in \\{\\Delta t_{\\mathrm{base}}, \\Delta t_{\\mathrm{base}}/2, \\Delta t_{\\mathrm{base}}/4\\}$ 下计算全局误差 $e(\\Delta t; T)$。误差被测量为数值解和参考解在相空间中的欧几里得距离：\n$$\ne(\\Delta t; T) = \\sqrt{\\left(x_{\\Delta t}(T)-x_{\\mathrm{ref}}(T)\\right)^{2} + \\left(v_{\\Delta t}(T)-v_{\\mathrm{ref}}(T)\\right)^{2}}\n$$\n经验收敛阶数 $s$ 由关系式 $e(\\Delta t) \\propto (\\Delta t)^s$ 决定。取对数后，我们得到 $\\log(e) = s \\log(\\Delta t) + \\text{const}$。我们通过对点 $(\\log(\\Delta t_i), \\log(e_i))$ 进行线性最小二乘拟合来找到 $s$。这条线的斜率即为所求的指数 $s$。\n\n$3$. **能量守恒**：通过计算在最终时间 $T$ 和最粗糙时间步长 $\\Delta t_{\\mathrm{base}}$ 下的相对能量漂移 $d$ 来评估积分器的长期稳定性：\n$$\nd = \\frac{\\left|H\\big(x_{\\Delta t}(T),v_{\\Delta t}(T)\\big) - H\\big(x(0),v(0)\\big)\\right|}{\\left|H\\big(x(0),v(0)\\big)\\right|}\n$$\n预期的结果是，在较长的积分时间 $T$ 内，Leapfrog 算法尽管阶数较低，但与会显示出能量漂移的 RK4 相比，将表现出更优越的能量守恒性（较小的 $d$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing Leapfrog and RK4 integrators for a nonlinear oscillator.\n    \"\"\"\n    \n    # Test suite: (alpha, x0, v0, T, dt_base)\n    test_cases = [\n        (0.1, 1.0, 0.0, 200.0, 0.05),\n        (1.0, 0.5, 0.0, 200.0, 0.04),\n        (-0.3, 0.8, 0.0, 200.0, 0.04),\n        (0.5, 1.2, 0.0, 192.0, 0.03),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha, x0, v0, T, dt_base = case\n\n        # Define model-specific functions\n        def acceleration(x, alpha_val):\n            return -x - alpha_val * x**3\n\n        def hamiltonian(x, v, alpha_val):\n            return 0.5 * v**2 + 0.5 * x**2 + 0.25 * alpha_val * x**4\n\n        # Define integrator step functions\n        def leapfrog_step(x, v, dt, alpha_val):\n            v_half = v + acceleration(x, alpha_val) * dt / 2.0\n            x_new = x + v_half * dt\n            v_new = v_half + acceleration(x_new, alpha_val) * dt / 2.0\n            return x_new, v_new\n\n        def rk4_step(x, v, dt, alpha_val):\n            # k1\n            k1_x = v\n            k1_v = acceleration(x, alpha_val)\n            # k2\n            x2 = x + 0.5 * dt * k1_x\n            v2 = v + 0.5 * dt * k1_v\n            k2_x = v2\n            k2_v = acceleration(x2, alpha_val)\n            # k3\n            x3 = x + 0.5 * dt * k2_x\n            v3 = v + 0.5 * dt * k2_v\n            k3_x = v3\n            k3_v = acceleration(x3, alpha_val)\n            # k4\n            x4 = x + dt * k3_x\n            v4 = v + dt * k3_v\n            k4_x = v4\n            k4_v = acceleration(x4, alpha_val)\n\n            x_new = x + (dt / 6.0) * (k1_x + 2.0 * k2_x + 2.0 * k3_x + k4_x)\n            v_new = v + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v)\n            return x_new, v_new\n\n        # Define simulation runner\n        def run_simulation(step_func, x_start, v_start, T_sim, dt_sim, alpha_val):\n            x_curr, v_curr = x_start, v_start\n            num_steps = int(round(T_sim / dt_sim))\n            for _ in range(num_steps):\n                x_curr, v_curr = step_func(x_curr, v_curr, dt_sim, alpha_val)\n            return x_curr, v_curr\n\n        # 1. Compute reference solution\n        dt_ref = dt_base / 16.0\n        x_ref, v_ref = run_simulation(rk4_step, x0, v0, T, dt_ref, alpha)\n\n        # 2. Compute global errors for different dt\n        dts = np.array([dt_base, dt_base / 2.0, dt_base / 4.0])\n        errors_leapfrog = []\n        errors_rk4 = []\n\n        for dt in dts:\n            # Leapfrog error\n            x_L, v_L = run_simulation(leapfrog_step, x0, v0, T, dt, alpha)\n            err_L = np.sqrt((x_L - x_ref)**2 + (v_L - v_ref)**2)\n            errors_leapfrog.append(err_L)\n\n            # RK4 error\n            x_R, v_R = run_simulation(rk4_step, x0, v0, T, dt, alpha)\n            err_R = np.sqrt((x_R - x_ref)**2 + (v_R - v_ref)**2)\n            errors_rk4.append(err_R)\n\n        # 3. Estimate empirical error scaling exponent s\n        log_dts = np.log(dts)\n        log_errors_L = np.log(np.array(errors_leapfrog))\n        log_errors_R = np.log(np.array(errors_rk4))\n        \n        # Use np.polyfit for linear least-squares regression. It returns [slope, intercept].\n        s_leapfrog = np.polyfit(log_dts, log_errors_L, 1)[0]\n        s_rk4 = np.polyfit(log_dts, log_errors_R, 1)[0]\n\n        # 4. Compute relative energy drift d at dt = dt_base\n        H0 = hamiltonian(x0, v0, alpha)\n\n        # Leapfrog drift\n        x_L_final, v_L_final = run_simulation(leapfrog_step, x0, v0, T, dt_base, alpha)\n        H_L_final = hamiltonian(x_L_final, v_L_final, alpha)\n        d_leapfrog = np.abs(H_L_final - H0) / np.abs(H0) if H0 != 0 else 0.0\n\n        # RK4 drift\n        x_R_final, v_R_final = run_simulation(rk4_step, x0, v0, T, dt_base, alpha)\n        H_R_final = hamiltonian(x_R_final, v_R_final, alpha)\n        d_rk4 = np.abs(H_R_final - H0) / np.abs(H0) if H0 != 0 else 0.0\n\n        case_results = [s_leapfrog, s_rk4, d_leapfrog, d_rk4]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    inner_strings = [f\"[{','.join(f'{val:.8f}' for val in res)}]\" for res in all_results]\n    final_output_str = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}