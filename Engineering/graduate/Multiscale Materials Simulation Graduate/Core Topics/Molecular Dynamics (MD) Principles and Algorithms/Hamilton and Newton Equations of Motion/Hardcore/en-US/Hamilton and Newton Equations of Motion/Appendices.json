{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of Hamiltonian mechanics is the profound connection between the symmetries of a system and its conserved quantities. This exercise provides foundational practice in using the Poisson bracket, the central mathematical tool in this framework, to formally identify constants of motion. By calculating the Poisson bracket of the Hamiltonian with the angular momentum for a particle in a central potential, you will directly prove why angular momentum is conserved, a key principle underlying the stability of planetary orbits and the behavior of atoms .",
            "id": "3814031",
            "problem": "In coarse-grained Molecular Dynamics (MD), rotationally invariant interactions at the mesoscale are often modeled by a central potential. Consider a single coarse-grained particle of mass $m$ moving in three-dimensional (3D) space with canonical coordinates $\\mathbf{r}=(x,y,z)$ and conjugate momenta $\\mathbf{p}=(p_{x},p_{y},p_{z})$. The Hamiltonian is given by $H(\\mathbf{r},\\mathbf{p})=\\frac{1}{2m}\\left(p_{x}^{2}+p_{y}^{2}+p_{z}^{2}\\right)+U\\!\\left(\\|\\mathbf{r}\\|\\right)$, where $U\\!\\left(\\|\\mathbf{r}\\|\\right)$ is a central potential depending only on the radial distance $\\|\\mathbf{r}\\|=\\sqrt{x^{2}+y^{2}+z^{2}}$. The $z$-component of the angular momentum is $L_{z}=x\\,p_{y}-y\\,p_{x}$. Using the canonical Poisson bracket, compute the Poisson bracket $\\{H,L_{z}\\}$ for this system. Then, based on fundamental principles of Hamiltonian dynamics, argue whether $L_{z}$ is conserved along the trajectory. Provide your final result for $\\{H,L_{z}\\}$ as a single closed-form analytic expression. No rounding is required, and no units should be used in the final expression.",
            "solution": "The problem requires the computation of the Poisson bracket $\\{H,L_{z}\\}$ for a particle of mass $m$ in a central potential $U(\\|\\mathbf{r}\\|)$ and to determine if the $z$-component of angular momentum, $L_z$, is a conserved quantity.\n\nThe Hamiltonian $H$ is given by:\n$$ H(\\mathbf{r},\\mathbf{p}) = \\frac{1}{2m}\\left(p_{x}^{2}+p_{y}^{2}+p_{z}^{2}\\right)+U\\!\\left(\\|\\mathbf{r}\\|\\right) $$\nwhere $\\|\\mathbf{r}\\| = \\sqrt{x^{2}+y^{2}+z^{2}}$.\nThe $z$-component of the angular momentum is given by:\n$$ L_{z} = x\\,p_{y}-y\\,p_{x} $$\nThe canonical Poisson bracket for two functions $A(q_i, p_i)$ and $B(q_i, p_i)$ in three-dimensional Cartesian coordinates $(x,y,z)$ and conjugate momenta $(p_x, p_y, p_z)$ is defined as:\n$$ \\{A, B\\} = \\sum_{i \\in \\{x,y,z\\}} \\left( \\frac{\\partial A}{\\partial q_i} \\frac{\\partial B}{\\partial p_i} - \\frac{\\partial A}{\\partial p_i} \\frac{\\partial B}{\\partial q_i} \\right) $$\n$$ \\{A, B\\} = \\left( \\frac{\\partial A}{\\partial x} \\frac{\\partial B}{\\partial p_x} - \\frac{\\partial A}{\\partial p_x} \\frac{\\partial B}{\\partial x} \\right) + \\left( \\frac{\\partial A}{\\partial y} \\frac{\\partial B}{\\partial p_y} - \\frac{\\partial A}{\\partial p_y} \\frac{\\partial B}{\\partial y} \\right) + \\left( \\frac{\\partial A}{\\partial z} \\frac{\\partial B}{\\partial p_z} - \\frac{\\partial A}{\\partial p_z} \\frac{\\partial B}{\\partial z} \\right) $$\nTo compute $\\{H, L_z\\}$, we can use the linearity property of the Poisson bracket. Let's separate the Hamiltonian into its kinetic energy part, $T = \\frac{1}{2m}\\left(p_{x}^{2}+p_{y}^{2}+p_{z}^{2}\\right)$, and its potential energy part, $U = U(\\|\\mathbf{r}\\|)$.\n$$ \\{H, L_z\\} = \\{T + U, L_z\\} = \\{T, L_z\\} + \\{U, L_z\\} $$\nWe will compute each bracket separately.\n\nFirst, we compute $\\{T, L_z\\}$. We need the partial derivatives of $T$ and $L_z$.\nDerivatives of $T$:\n$$ \\frac{\\partial T}{\\partial x} = 0, \\quad \\frac{\\partial T}{\\partial y} = 0, \\quad \\frac{\\partial T}{\\partial z} = 0 $$\n$$ \\frac{\\partial T}{\\partial p_x} = \\frac{p_x}{m}, \\quad \\frac{\\partial T}{\\partial p_y} = \\frac{p_y}{m}, \\quad \\frac{\\partial T}{\\partial p_z} = \\frac{p_z}{m} $$\nDerivatives of $L_z$:\n$$ \\frac{\\partial L_z}{\\partial x} = p_y, \\quad \\frac{\\partial L_z}{\\partial y} = -p_x, \\quad \\frac{\\partial L_z}{\\partial z} = 0 $$\n$$ \\frac{\\partial L_z}{\\partial p_x} = -y, \\quad \\frac{\\partial L_z}{\\partial p_y} = x, \\quad \\frac{\\partial L_z}{\\partial p_z} = 0 $$\nNow, we substitute these into the Poisson bracket definition for $\\{T, L_z\\}$:\n$$ \\{T, L_z\\} = \\left( (0)(-y) - (\\frac{p_x}{m})(p_y) \\right) + \\left( (0)(x) - (\\frac{p_y}{m})(-p_x) \\right) + \\left( (0)(0) - (\\frac{p_z}{m})(0) \\right) $$\n$$ \\{T, L_z\\} = -\\frac{p_x p_y}{m} + \\frac{p_y p_x}{m} + 0 = 0 $$\n\nSecond, we compute $\\{U, L_z\\}$. Let $r = \\|\\mathbf{r}\\| = \\sqrt{x^2+y^2+z^2}$. We use the chain rule for the derivatives of $U(r)$.\nDerivatives of $U$:\n$$ \\frac{\\partial U}{\\partial x} = \\frac{dU}{dr} \\frac{\\partial r}{\\partial x} = U'(r) \\frac{x}{r} $$\n$$ \\frac{\\partial U}{\\partial y} = \\frac{dU}{dr} \\frac{\\partial r}{\\partial y} = U'(r) \\frac{y}{r} $$\n$$ \\frac{\\partial U}{\\partial z} = \\frac{dU}{dr} \\frac{\\partial r}{\\partial z} = U'(r) \\frac{z}{r} $$\nThe potential $U$ does not depend on momenta, so:\n$$ \\frac{\\partial U}{\\partial p_x} = 0, \\quad \\frac{\\partial U}{\\partial p_y} = 0, \\quad \\frac{\\partial U}{\\partial p_z} = 0 $$\nNow, we substitute these and the derivatives of $L_z$ into the Poisson bracket definition for $\\{U, L_z\\}$:\n$$ \\{U, L_z\\} = \\left( (U'(r)\\frac{x}{r})(-y) - (0)(p_y) \\right) + \\left( (U'(r)\\frac{y}{r})(x) - (0)(-p_x) \\right) + \\left( (U'(r)\\frac{z}{r})(0) - (0)(0) \\right) $$\n$$ \\{U, L_z\\} = -\\frac{U'(r)xy}{r} + \\frac{U'(r)yx}{r} + 0 = 0 $$\n\nCombining the two results:\n$$ \\{H, L_z\\} = \\{T, L_z\\} + \\{U, L_z\\} = 0 + 0 = 0 $$\nThe Poisson bracket $\\{H, L_z\\}$ is zero.\n\nThe second part of the question is to argue whether $L_z$ is conserved. In Hamiltonian dynamics, the total time derivative of any observable quantity $A(q, p, t)$ is given by Hamilton's equation of motion:\n$$ \\frac{dA}{dt} = \\{A, H\\} + \\frac{\\partial A}{\\partial t} $$\nFor the observable $A=L_z$, the function $L_z = x p_y - y p_x$ does not explicitly depend on time, so $\\frac{\\partial L_z}{\\partial t} = 0$. The equation of motion for $L_z$ is therefore:\n$$ \\frac{dL_z}{dt} = \\{L_z, H\\} $$\nUsing the antisymmetric property of the Poisson bracket, $\\{A, B\\} = -\\{B, A\\}$, we have:\n$$ \\{L_z, H\\} = -\\{H, L_z\\} $$\nSince we found that $\\{H, L_z\\} = 0$, it follows that:\n$$ \\frac{dL_z}{dt} = - (0) = 0 $$\nA quantity whose total time derivative is zero is a constant of motion, meaning it is conserved along the trajectory of the system. Therefore, $L_z$ is a conserved quantity.\nThis result is a manifestation of Noether's theorem. The Hamiltonian for a particle in a central potential is invariant under any rotation. In particular, it is invariant under rotations about the $z$-axis. This continuous symmetry (rotational invariance about the $z$-axis) implies the existence of a corresponding conserved quantity, which is the $z$-component of the angular momentum, $L_z$. The calculation $\\{H, L_z\\} = 0$ is the formal proof of this conservation law within the Hamiltonian framework.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Moving from continuous theory to computational practice, we must discretize the equations of motion to simulate them on a computer. The stability of the chosen numerical integrator is paramount, as an unstable method will produce unphysical, exploding trajectories. This exercise guides you through a linear stability analysis of the velocity Verlet algorithm—a workhorse of molecular dynamics—by deriving its discrete dispersion relation for a harmonic oscillator model, which represents the fastest vibrations in a material . Determining the maximum stable time step, $\\Delta t$, is an essential skill for designing robust and efficient simulations.",
            "id": "3814061",
            "problem": "In atomistic Molecular Dynamics (MD), bonded interactions are often modeled as harmonic springs. Consider a single degree-of-freedom harmonic oscillator representing an isolated bonded interaction with mass $m$ and spring constant $k$. The dynamics are governed by Newton's second law $m \\ddot{x} = - k x$, which is equivalent to a Hamiltonian $H(p,x) = \\frac{p^{2}}{2 m} + \\frac{k}{2} x^{2}$ with canonical equations $\\dot{x} = \\frac{\\partial H}{\\partial p}$ and $\\dot{p} = - \\frac{\\partial H}{\\partial x}$. Using the velocity Verlet time integrator, analyze the linear stability of the discrete dynamics by deriving the discrete dispersion relation for the position sequence $x_{n}$, assuming a mode ansatz with a constant phase advance per step measured in radians. From this dispersion relation, determine the largest time step $\\Delta t$ for which solutions remain bounded (i.e., do not exhibit exponential growth), expressed as a closed-form analytic function of $k$ and $m$. Express the final time step in seconds. No numerical rounding is required.",
            "solution": "The dynamics of the harmonic oscillator are described by the equation $m \\ddot{x} = -k x$. The natural angular frequency of the oscillator is $\\omega = \\sqrt{k/m}$. The equation of motion can be written as $\\ddot{x} + \\omega^2 x = 0$. The acceleration is $a(t) = \\ddot{x}(t) = -\\omega^2 x(t)$.\n\nThe velocity Verlet algorithm propagates the position $x$ and velocity $v$ from time $n \\Delta t$ to $(n+1) \\Delta t$. Let $x_n = x(n \\Delta t)$, $v_n = v(n \\Delta t)$, and $a_n = a(n \\Delta t)$. The algorithm consists of two main steps:\n1. Position update:\n   $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. Velocity update:\n   $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\nFor the harmonic oscillator, we have $a_n = -\\omega^2 x_n$ and $a_{n+1} = -\\omega^2 x_{n+1}$.\n\nTo derive the discrete dispersion relation for the position sequence $x_n$, we combine these equations to form a single recurrence relation for $x$ only.\nFirst, substitute $a_n = -\\omega^2 x_n$ into the position update equation:\n$$x_{n+1} = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 \\quad (*)$$\nNext, we write the position update for the subsequent step, from $n+1$ to $n+2$:\n$$x_{n+2} = x_{n+1} + v_{n+1} \\Delta t + \\frac{1}{2} a_{n+1} (\\Delta t)^2$$\nSubstituting $a_{n+1} = -\\omega^2 x_{n+1}$, we have:\n$$x_{n+2} = x_{n+1} + v_{n+1} \\Delta t - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 \\quad (**)$$\nTo eliminate the velocities, we use the velocity update equation:\n$$v_{n+1} = v_n - \\frac{\\omega^2 \\Delta t}{2} (x_n + x_{n+1})$$\nWe can express $v_n$ and $v_{n+1}$ in terms of positions using the position update equations. From equation $(*)$, we rearrange to find $v_n$:\n$$v_n \\Delta t = x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2$$\nSimilarly, from equation $(**)$, we find $v_{n+1}$:\n$$v_{n+1} \\Delta t = x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\nNow, substitute these expressions for $v_n \\Delta t$ and $v_{n+1} \\Delta t$ into the velocity update equation after multiplying it by $\\Delta t$:\n$$v_{n+1} \\Delta t = v_n \\Delta t - \\frac{\\omega^2 (\\Delta t)^2}{2} (x_n + x_{n+1})$$\n$$\\left( x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 \\right) = \\left( x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 \\right) - \\frac{\\omega^2 (\\Delta t)^2}{2} (x_n + x_{n+1})$$\nWe simplify the expression by collecting terms:\n$$x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 = x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\n$$x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 = x_{n+1} - x_n - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\nIsolating $x_{n+2}$:\n$$x_{n+2} = 2x_{n+1} - x_n - \\omega^2 (\\Delta t)^2 x_{n+1}$$\nThis gives the three-term recurrence relation for the position sequence:\n$$x_{n+2} - (2 - \\omega^2 (\\Delta t)^2) x_{n+1} + x_n = 0$$\nTo find the discrete dispersion relation, we use the requested mode ansatz. Let the solution be of the form $x_n = A \\exp(i \\phi n)$, where $\\phi$ is the constant phase advance per step. Substituting this into the recurrence relation:\n$$A \\exp(i \\phi (n+2)) - (2 - \\omega^2 (\\Delta t)^2) A \\exp(i \\phi (n+1)) + A \\exp(i \\phi n) = 0$$\nDividing by $A \\exp(i \\phi n)$ (since $A \\neq 0$ for a non-trivial solution):\n$$\\exp(2i\\phi) - (2 - \\omega^2 (\\Delta t)^2) \\exp(i\\phi) + 1 = 0$$\nThis is a quadratic equation for $\\exp(i\\phi)$. To obtain the dispersion relation, we divide by $\\exp(i\\phi)$:\n$$\\exp(i\\phi) - (2 - \\omega^2 (\\Delta t)^2) + \\exp(-i\\phi) = 0$$\nUsing Euler's identity, $\\exp(i\\phi) + \\exp(-i\\phi) = 2 \\cos(\\phi)$, we get:\n$$2 \\cos(\\phi) = 2 - \\omega^2 (\\Delta t)^2$$\n$$\\cos(\\phi) = 1 - \\frac{\\omega^2 (\\Delta t)^2}{2}$$\nThis is the discrete dispersion relation for the velocity Verlet algorithm applied to a harmonic oscillator. It relates the numerical phase advance per step, $\\phi$, to the true physical frequency, $\\omega$, and the time step, $\\Delta t$.\n\nFor the numerical solution $x_n$ to remain bounded (i.e., not grow exponentially), the phase advance $\\phi$ must be a real number. This requires that its cosine lies in the interval $[-1, 1]$.\n$$-1 \\le \\cos(\\phi) \\le 1$$\nSubstituting the derived expression for $\\cos(\\phi)$:\n$$-1 \\le 1 - \\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1$$\nWe analyze the two inequalities separately.\nThe right-hand inequality is:\n$$1 - \\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1 \\implies -\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 0$$\nThis is always true, since $\\omega^2 \\ge 0$ and $(\\Delta t)^2 \\ge 0$.\nThe left-hand inequality gives the stability-limiting condition:\n$$-1 \\le 1 - \\frac{\\omega^2 (\\Delta t)^2}{2}$$\n$$\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1 + 1$$\n$$\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 2$$\n$$\\omega^2 (\\Delta t)^2 \\le 4$$\nTaking the square root of both sides (and noting that $\\omega > 0$ and $\\Delta t > 0$):\n$$\\omega \\Delta t \\le 2$$\nThe largest time step $\\Delta t_{max}$ for which the solution remains bounded corresponds to the equality:\n$$\\omega \\Delta t_{max} = 2$$\n$$\\Delta t_{max} = \\frac{2}{\\omega}$$\nFinally, we substitute the definition of the natural frequency, $\\omega = \\sqrt{k/m}$:\n$$\\Delta t_{max} = \\frac{2}{\\sqrt{k/m}}$$\n$$\\Delta t_{max} = 2 \\sqrt{\\frac{m}{k}}$$\nThis is the closed-form analytic expression for the largest stable time step. If the quantities $m$ and $k$ are given in SI units ($kg$ and $N/m = kg/s^2$, respectively), the resulting time step $\\Delta t_{max}$ will be in seconds.",
            "answer": "$$\\boxed{2 \\sqrt{\\frac{m}{k}}}$$"
        },
        {
            "introduction": "While many numerical methods can solve differential equations, not all are suitable for long-time simulations of Hamiltonian systems. Integrators that preserve the geometric structure of phase space, known as symplectic integrators, exhibit superior long-term energy conservation. This hands-on coding exercise challenges you to implement and compare a non-symplectic method (fourth-order Runge-Kutta) against a symplectic one (velocity Verlet) . By observing the systematic energy drift in one and the bounded energy fluctuations in the other, you will gain a powerful, practical understanding of why symplecticity is a crucial feature for a reliable molecular dynamics integrator.",
            "id": "3814073",
            "problem": "You are tasked to design and implement a program to compare long-time energy behavior of two time-integration methods for Hamiltonian dynamics, in the context of conservative atomistic models used in multiscale materials simulation. Begin from first principles of Hamiltonian mechanics and Newtonian mechanics. For a system with generalized coordinates $q \\in \\mathbb{R}^d$ and momenta $p \\in \\mathbb{R}^d$, with Hamiltonian $H(q,p) = T(p) + V(q)$ where $T(p)$ is the kinetic energy and $V(q)$ is the potential energy, the equations of motion are Hamilton's equations:\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}, \\quad \n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q}\n$$\n, and, equivalently for constant mass $m$, Newton's second law takes the form\n$$\nm \\frac{d^2 q}{dt^2} = -\\nabla V(q)\n$$\n.\nUse dimensionless units with $m = 1$ and $T(p) = \\frac{1}{2} \\, p^\\top p$. Implement and compare two numerical methods for integrating these equations over long times: the classical fourth-order Runge–Kutta method and the velocity Verlet method. Do not assume or use any externally given formulas beyond the fundamental laws stated above; the implementations must follow from discretizing the continuous-time ordinary differential equations implied by these laws.\n\nDefine and use the following potential energy models that are standard surrogates for interatomic interactions and vibrational modes in materials:\n\n- Single-degree-of-freedom anharmonic oscillator (Duffing-type): \n$$\nV(q) = \\frac{1}{2} \\, k \\, q^2 + \\frac{1}{4} \\, \\alpha \\, q^4\n$$\n, with parameters $k$ and $\\alpha$ specified per test.\n\n- Two-degree-of-freedom coupled stiff–slow anharmonic oscillator:\n$$\nV(q) = \\frac{1}{2} \\, k_1 \\, q_1^2 + \\frac{1}{2} \\, k_2 \\, q_2^2 + \\frac{1}{4} \\, \\alpha \\, (q_1^4 + q_2^4) + \\frac{1}{2} \\, \\beta \\, q_1^2 q_2^2\n$$\n, with parameters $k_1$, $k_2$, $\\alpha$, $\\beta$ specified per test, where $q = (q_1, q_2)$.\n\nFor each test case below, integrate both methods for $N$ steps with time step $h$, starting from the given initial condition $(q_0, p_0)$. The mass is $m = 1$, so velocity $v$ satisfies $v = p$. At each step $n$, compute the total energy \n$$\nH_n = \\frac{1}{2} \\, p_n^\\top p_n + V(q_n)\n$$\n. Let $H_0$ be the energy at the initial state and $H_N$ be the energy at the final state. For each method, report the final relative energy change defined by\n$$\n\\Delta_{\\text{rel}} = \\frac{H_N - H_0}{H_0}\n$$\n.\nAll quantities are dimensionless. Angles do not appear, so no angle unit is needed.\n\nTest suite parameters:\n\n- Case $1$ (single-degree-of-freedom anharmonic oscillator, \"happy path\"):\n  - Parameters: $k = 1.0$, $\\alpha = 0.1$.\n  - Initial condition: $q_0 = 1.0$, $p_0 = 0.0$.\n  - Time step: $h = 0.1$.\n  - Number of steps: $N = 50000$.\n\n- Case $2$ (single-degree-of-freedom anharmonic oscillator, small step, longer time):\n  - Parameters: $k = 1.0$, $\\alpha = 0.1$.\n  - Initial condition: $q_0 = 1.0$, $p_0 = 0.0$.\n  - Time step: $h = 0.01$.\n  - Number of steps: $N = 60000$.\n\n- Case $3$ (two-degree-of-freedom stiff–slow coupled anharmonic oscillator):\n  - Parameters: $k_1 = 1.0$, $k_2 = 25.0$, $\\alpha = 0.05$, $\\beta = 0.02$.\n  - Initial condition: $q_0 = (1.0, 0.5)$, $p_0 = (0.0, 0.0)$.\n  - Time step: $h = 0.02$.\n  - Number of steps: $N = 50000$.\n\nYour program must perform both integrations for each case and compute the final relative energy change for each method. The final output must be a single line containing a list of lists, in the order of the test cases above, where each inner list has the two floating-point values $[\\Delta_{\\text{rel}}^{\\text{RK4}}, \\Delta_{\\text{rel}}^{\\text{Verlet}}]$ rounded to six decimal places. For example, the final output format must be exactly like `[[x_1,y_1],[x_2,y_2],[x_3,y_3]]` with no additional text, where $x_i$ and $y_i$ are the rounded values for case $i$.",
            "solution": "The problem requires the implementation and comparison of two numerical integration methods, the fourth-order Runge-Kutta (RK4) method and the velocity Verlet method, for solving the equations of motion in a conservative Hamiltonian system. The context is atomistic simulation, where long-term energy conservation is a critical property of a good integrator. We begin from the first principles of Hamiltonian and Newtonian mechanics.\n\nA conservative mechanical system is described by a Hamiltonian $H(q, p)$, which is the total energy of the system, expressed as a function of generalized coordinates $q$ and momenta $p$. For the systems in question, the Hamiltonian is separable, of the form $H(q,p) = T(p) + V(q)$, where $T(p)$ is the kinetic energy and $V(q)$ is the potential energy. Given the mass $m=1$ in dimensionless units, the kinetic energy is $T(p) = \\frac{1}{2} p^\\top p$.\n\nThe time evolution of the system is governed by Hamilton's equations:\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}, \\quad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q}\n$$\nSubstituting the given Hamiltonian, we obtain a system of first-order ordinary differential equations (ODEs):\n$$\n\\frac{dq}{dt} = \\frac{\\partial}{\\partial p} \\left(\\frac{1}{2} p^\\top p + V(q)\\right) = p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial}{\\partial q} \\left(\\frac{1}{2} p^\\top p + V(q)\\right) = -\\nabla_q V(q)\n$$\nThe term $F(q) = -\\nabla_q V(q)$ is the force acting on the system. The equations of motion can be written as $\\dot{q} = p$ and $\\dot{p} = F(q)$. This is equivalent to Newton's second law, $m\\ddot{q} = F(q)$, since $\\ddot{q} = \\dot{p} = F(q)$ when $m=1$.\n\nWe will now discretize these continuous equations to derive the two specified numerical integrators.\n\n### Integrator Derivation\n\n**1. Fourth-Order Runge-Kutta (RK4) Method**\n\nThe RK4 method is a general-purpose solver for a first-order ODE of the form $\\dot{y} = f(t, y)$. Our system can be expressed in this form by defining a state vector $y(t) = (q(t), p(t))^\\top$. The function $f(y)$ is then:\n$f(y) = f(q,p) = (\\dot{q}, \\dot{p}) = (p, F(q))$.\nThe RK4 method advances the state from time $t_n$ to $t_{n+1} = t_n + h$ using a weighted average of four intermediate steps (slopes):\n$$\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\nwhere $h$ is the time step, and the slopes $k_i$ are defined as:\n$$\n\\begin{aligned}\nk_1 = f(y_n) = (p_n, F(q_n)) \\\\\nk_2 = f\\left(y_n + \\frac{h}{2}k_1\\right) = f\\left(q_n + \\frac{h}{2}p_n, p_n + \\frac{h}{2}F(q_n)\\right) \\\\\nk_3 = f\\left(y_n + \\frac{h}{2}k_2\\right) \\\\\nk_4 = f(y_n + h k_3)\n\\end{aligned}\n$$\nBy evaluating $f$ at each intermediate point, we obtain the derivatives with respect to time for both $q$ and $p$. These are then combined in the final update step to calculate $(q_{n+1}, p_{n+1})$. RK4 is a high-order method (local error $\\mathcal{O}(h^5)$, global error $\\mathcal{O}(h^4)$) but it is not symplectic, meaning it does not exactly preserve the geometric structure of Hamiltonian flow. This typically leads to a systematic drift in the total energy over long simulations.\n\n**2. Velocity Verlet Method**\n\nThe velocity Verlet method is derived by discretizing Newton's second law, $\\ddot{q} = F(q)/m$. A Taylor series expansion for the position $q(t)$ around time $t_n$ gives:\n$$\nq(t_n+h) = q(t_n) + h \\dot{q}(t_n) + \\frac{h^2}{2} \\ddot{q}(t_n) + \\mathcal{O}(h^3)\n$$\nIn our notation, with mass $m=1$, this becomes the position update rule:\n$$\nq_{n+1} = q_n + h p_n + \\frac{h^2}{2} F(q_n)\n$$\nTo update the momentum, we consider the definition $\\dot{p} = F(q)$ and integrate it over one time step:\n$$\np_{n+1} - p_n = \\int_{t_n}^{t_{n+1}} F(q(t)) dt\n$$\nApproximating the integral using the trapezoidal rule, which offers second-order accuracy, we get:\n$$\n\\int_{t_n}^{t_{n+1}} F(q(t)) dt \\approx \\frac{h}{2} [F(q(t_n)) + F(q(t_{n+1}))]\n$$\nThis gives the momentum update rule:\n$$\np_{n+1} = p_n + \\frac{h}{2} [F(q_n) + F(q_{n+1})]\n$$\nNote that this update requires the force $F(q_{n+1})$ at the new position $q_{n+1}$, which we have already computed in the first step. The sequence of operations is therefore:\n1.  Update position $q_{n+1}$ using $p_n$ and $F(q_n)$.\n2.  Compute the new force $F(q_{n+1})$ using the new position.\n3.  Update momentum $p_{n+1}$ using an average of the old and new forces.\n\nThe velocity Verlet algorithm is a symplectic integrator. This property ensures that it has excellent long-term energy conservation, characterized by bounded fluctuations around the true energy rather than a systematic drift.\n\n### Potential Models and Forces\n\nThe force $F(q)$ is derived from the potential energy $V(q)$ as $F(q) = -\\nabla_q V(q)$.\n\n**1. Single-DOF Anharmonic Oscillator (Duffing-type)**\n- Potential: $V(q) = \\frac{1}{2} k q^2 + \\frac{1}{4} \\alpha q^4$\n- Force: $F(q) = -\\frac{dV}{dq} = -(k q + \\alpha q^3)$\n\n**2. Two-DOF Coupled Anharmonic Oscillator**\n- Potential: $V(q_1, q_2) = \\frac{1}{2} k_1 q_1^2 + \\frac{1}{2} k_2 q_2^2 + \\frac{1}{4} \\alpha (q_1^4 + q_2^4) + \\frac{1}{2} \\beta q_1^2 q_2^2$\n- Force Vector $F(q)=-\\nabla V(q) = (F_1, F_2)^\\top$:\n  - $F_1(q_1, q_2) = -\\frac{\\partial V}{\\partial q_1} = -(k_1 q_1 + \\alpha q_1^3 + \\beta q_1 q_2^2)$\n  - $F_2(q_1, q_2) = -\\frac{\\partial V}{\\partial q_2} = -(k_2 q_2 + \\alpha q_2^3 + \\beta q_1^2 q_2)$\n\n### Simulation and Analysis\n\nFor each test case, the system is initialized at $(q_0, p_0)$. The initial energy $H_0 = \\frac{1}{2} p_0^\\top p_0 + V(q_0)$ is calculated. Then, the system is evolved for $N$ steps using a time step of $h$, once with the RK4 integrator and once with the velocity Verlet integrator. After $N$ steps, the final energy $H_N = \\frac{1}{2} p_N^\\top p_N + V(q_N)$ is computed. The metric for comparison is the relative energy change, $\\Delta_{\\text{rel}} = (H_N - H_0) / H_0$. This value quantifies the energy conservation properties of each method over the duration of the simulation.\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run simulations and compare integrator energy conservation.\n    \"\"\"\n\n    # --- Potential and Force Functions ---\n    \n    # 1-DOF Duffing Oscillator\n    def potential_duffing(q, k, alpha):\n        # V(q) = 1/2 k q^2 + 1/4 alpha q^4\n        q_scalar = q[0]\n        return 0.5 * k * q_scalar**2 + 0.25 * alpha * q_scalar**4\n\n    def force_duffing(q, k, alpha):\n        # F(q) = -dV/dq = -(k q + alpha q^3)\n        return -(k * q + alpha * q**3)\n\n    # 2-DOF Coupled Oscillator\n    def potential_coupled(q, k1, k2, alpha, beta):\n        # V(q) = 1/2 k1 q1^2 + 1/2 k2 q2^2 + 1/4 alpha (q1^4 + q2^4) + 1/2 beta q1^2 q2^2\n        q1, q2 = q[0], q[1]\n        return (0.5 * k1 * q1**2 + 0.5 * k2 * q2**2 +\n                0.25 * alpha * (q1**4 + q2**4) + 0.5 * beta * q1**2 * q2**2)\n\n    def force_coupled(q, k1, k2, alpha, beta):\n        # F(q) = -grad(V)\n        q1, q2 = q[0], q[1]\n        F1 = -(k1 * q1 + alpha * q1**3 + beta * q1 * q2**2)\n        F2 = -(k2 * q2 + alpha * q2**3 + beta * q1**2 * q2)\n        return np.array([F1, F2])\n\n    \n    # --- Numerical Integrators ---\n\n    def rk4_step(q, p, h, force_func, f_params):\n        \"\"\"A single step of the RK4 integrator for a Hamiltonian system.\"\"\"\n        # dot(q) = p, dot(p) = F(q)\n\n        # k1\n        q_dot_1 = p\n        p_dot_1 = force_func(q, **f_params)\n\n        # k2\n        q_temp_2 = q + 0.5 * h * q_dot_1\n        p_temp_2 = p + 0.5 * h * p_dot_1\n        q_dot_2 = p_temp_2\n        p_dot_2 = force_func(q_temp_2, **f_params)\n\n        # k3\n        q_temp_3 = q + 0.5 * h * q_dot_2\n        p_temp_3 = p + 0.5 * h * p_dot_2\n        q_dot_3 = p_temp_3\n        p_dot_3 = force_func(q_temp_3, **f_params)\n\n        # k4\n        q_temp_4 = q + h * q_dot_3\n        p_temp_4 = p + h * p_dot_3\n        q_dot_4 = p_temp_4\n        p_dot_4 = force_func(q_temp_4, **f_params)\n\n        # Final update\n        q_next = q + (h / 6.0) * (q_dot_1 + 2.0 * q_dot_2 + 2.0 * q_dot_3 + q_dot_4)\n        p_next = p + (h / 6.0) * (p_dot_1 + 2.0 * p_dot_2 + 2.0 * p_dot_3 + p_dot_4)\n        \n        return q_next, p_next\n\n    def verlet_step(q, p, h, force_func, f_params):\n        \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n        # Using m=1, p=v\n        F_n = force_func(q, **f_params)\n        \n        # 1. Update position\n        q_next = q + h * p + 0.5 * h**2 * F_n\n        \n        # 2. Compute new force\n        F_n_plus_1 = force_func(q_next, **f_params)\n        \n        # 3. Update momentum (velocity)\n        p_next = p + 0.5 * h * (F_n + F_n_plus_1)\n        \n        return q_next, p_next\n\n    # --- Simulation Runner ---\n    \n    def run_simulation(integrator, q0, p0, h, N, pot_func, p_params, force_func, f_params):\n        \"\"\"Runs a simulation for N steps and returns relative energy error.\"\"\"\n        q, p = np.copy(q0), np.copy(p0)\n        \n        H0 = 0.5 * np.dot(p0, p0) + pot_func(q0, **p_params)\n        \n        for _ in range(N):\n            q, p = integrator(q, p, h, force_func, f_params)\n            \n        HN = 0.5 * np.dot(p, p) + pot_func(q, **p_params)\n        \n        # Avoid division by zero if initial energy is zero\n        if H0 == 0:\n            return HN # or some other indicator of this special case\n            \n        return (HN - H0) / H0\n\n    # --- Test Cases Definition ---\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: 1-DOF, h=0.1, N=50k\",\n            \"potential\": potential_duffing,\n            \"force\": force_duffing,\n            \"params\": {\"k\": 1.0, \"alpha\": 0.1},\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 0.1,\n            \"N\": 50000,\n        },\n        {\n            \"name\": \"Case 2: 1-DOF, h=0.01, N=60k\",\n            \"potential\": potential_duffing,\n            \"force\": force_duffing,\n            \"params\": {\"k\": 1.0, \"alpha\": 0.1},\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 0.01,\n            \"N\": 60000,\n        },\n        {\n            \"name\": \"Case 3: 2-DOF stiff-slow\",\n            \"potential\": potential_coupled,\n            \"force\": force_coupled,\n            \"params\": {\"k1\": 1.0, \"k2\": 25.0, \"alpha\": 0.05, \"beta\": 0.02},\n            \"q0\": np.array([1.0, 0.5]),\n            \"p0\": np.array([0.0, 0.0]),\n            \"h\": 0.02,\n            \"N\": 50000,\n        },\n    ]\n\n    # --- Main Loop ---\n    \n    all_results = []\n    for case in test_cases:\n        delta_rk4 = run_simulation(\n            rk4_step, case[\"q0\"], case[\"p0\"], case[\"h\"], case[\"N\"],\n            case[\"potential\"], case[\"params\"], case[\"force\"], case[\"params\"]\n        )\n        \n        delta_verlet = run_simulation(\n            verlet_step, case[\"q0\"], case[\"p0\"], case[\"h\"], case[\"N\"],\n            case[\"potential\"], case[\"params\"], case[\"force\"], case[\"params\"]\n        )\n        \n        all_results.append([round(delta_rk4, 6), round(delta_verlet, 6)])\n\n    # Format the final output string exactly as required.\n    string_results = [f\"[{r[0]},{r[1]}]\" for r in all_results]\n    # The expected output is a raw string, not printed by the program.\n    # print(f\"[{','.join(string_results)}]\")\n\n# This function call is for local testing; the final code in the answer tag is not executed by the platform.\n# solve()\n```",
            "answer": "[[0.000101,0.000002],[0.000001,0.000000],[0.000133,0.000001]]"
        }
    ]
}