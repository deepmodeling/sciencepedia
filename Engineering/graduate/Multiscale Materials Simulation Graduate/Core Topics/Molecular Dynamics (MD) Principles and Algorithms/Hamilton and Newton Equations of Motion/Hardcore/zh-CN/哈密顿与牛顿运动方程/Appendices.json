{
    "hands_on_practices": [
        {
            "introduction": "哈密顿力学的一个核心优势是它为识别守恒量提供了一个优雅的框架。这个练习将使用泊松括号这一基本工具，来证明中心势场下角动量的守恒性，这其实是旋转对称性的直接结果。这项实践有助于建立对诺特定理的直观理解，并展示了抽象的数学结构如何揭示深刻的物理原理()。",
            "id": "3814031",
            "problem": "在粗粒化分子动力学 (MD) 中，介观尺度上的旋转不变相互作用通常用中心势来建模。考虑一个质量为 $m$ 的单个粗粒化粒子在三维 $(3\\mathrm{D})$ 空间中运动，其正则坐标为 $\\mathbf{r}=(x,y,z)$，共轭动量为 $\\mathbf{p}=(p_{x},p_{y},p_{z})$。哈密顿量由 $H(\\mathbf{r},\\mathbf{p})=\\frac{1}{2m}\\left(p_{x}^{2}+p_{y}^{2}+p_{z}^{2}\\right)+U\\!\\left(\\|\\mathbf{r}\\|\\right)$ 给出，其中 $U\\!\\left(\\|\\mathbf{r}\\|\\right)$ 是一个仅依赖于径向距离 $\\|\\mathbf{r}\\|=\\sqrt{x^{2}+y^{2}+z^{2}}$ 的中心势。角动量的 $z$ 分量为 $L_{z}=x\\,p_{y}-y\\,p_{x}$。使用正则泊松括号，计算该系统的泊松括号 $\\{H,L_{z}\\}$。然后，根据哈密顿动力学的基本原理，论证 $L_{z}$ 是否沿轨迹守恒。请将 $\\{H,L_{z}\\}$ 的最终结果以单个闭式解析表达式的形式给出。不需要四舍五入，最终表达式中不应使用单位。",
            "solution": "该问题要求计算在中心势 $U(\\|\\mathbf{r}\\|)$ 中运动的质量为 $m$ 的粒子的泊松括号 $\\{H,L_{z}\\}$，并确定角动量的 $z$ 分量 $L_z$ 是否为守恒量。\n\n哈密顿量 $H$ 由下式给出：\n$$ H(\\mathbf{r},\\mathbf{p}) = \\frac{1}{2m}\\left(p_{x}^{2}+p_{y}^{2}+p_{z}^{2}\\right)+U\\!\\left(\\|\\mathbf{r}\\|\\right) $$\n其中 $\\|\\mathbf{r}\\| = \\sqrt{x^{2}+y^{2}+z^{2}}$。\n角动量的 $z$ 分量由下式给出：\n$$ L_{z} = x\\,p_{y}-y\\,p_{x} $$\n对于三维笛卡尔坐标 $(x,y,z)$ 和共轭动量 $(p_x, p_y, p_z)$ 中的两个函数 $A(q_i, p_i)$ 和 $B(q_i, p_i)$，正则泊松括号定义为：\n$$ \\{A, B\\} = \\sum_{i \\in \\{x,y,z\\}} \\left( \\frac{\\partial A}{\\partial q_i} \\frac{\\partial B}{\\partial p_i} - \\frac{\\partial A}{\\partial p_i} \\frac{\\partial B}{\\partial q_i} \\right) $$\n$$ \\{A, B\\} = \\left( \\frac{\\partial A}{\\partial x} \\frac{\\partial B}{\\partial p_x} - \\frac{\\partial A}{\\partial p_x} \\frac{\\partial B}{\\partial x} \\right) + \\left( \\frac{\\partial A}{\\partial y} \\frac{\\partial B}{\\partial p_y} - \\frac{\\partial A}{\\partial p_y} \\frac{\\partial B}{\\partial y} \\right) + \\left( \\frac{\\partial A}{\\partial z} \\frac{\\partial B}{\\partial p_z} - \\frac{\\partial A}{\\partial p_z} \\frac{\\partial B}{\\partial z} \\right) $$\n为了计算 $\\{H, L_z\\}$，我们可以利用泊松括号的线性性质。我们将哈密顿量分解为其动能部分 $T = \\frac{1}{2m}\\left(p_{x}^{2}+p_{y}^{2}+p_{z}^{2}\\right)$ 和势能部分 $U = U(\\|\\mathbf{r}\\|)$。\n$$ \\{H, L_z\\} = \\{T + U, L_z\\} = \\{T, L_z\\} + \\{U, L_z\\} $$\n我们将分别计算每个括号。\n\n首先，我们计算 $\\{T, L_z\\}$。我们需要 $T$ 和 $L_z$ 的偏导数。\n$T$ 的导数：\n$$ \\frac{\\partial T}{\\partial x} = 0, \\quad \\frac{\\partial T}{\\partial y} = 0, \\quad \\frac{\\partial T}{\\partial z} = 0 $$\n$$ \\frac{\\partial T}{\\partial p_x} = \\frac{p_x}{m}, \\quad \\frac{\\partial T}{\\partial p_y} = \\frac{p_y}{m}, \\quad \\frac{\\partial T}{\\partial p_z} = \\frac{p_z}{m} $$\n$L_z$ 的导数：\n$$ \\frac{\\partial L_z}{\\partial x} = p_y, \\quad \\frac{\\partial L_z}{\\partial y} = -p_x, \\quad \\frac{\\partial L_z}{\\partial z} = 0 $$\n$$ \\frac{\\partial L_z}{\\partial p_x} = -y, \\quad \\frac{\\partial L_z}{\\partial p_y} = x, \\quad \\frac{\\partial L_z}{\\partial p_z} = 0 $$\n现在，我们将这些代入 $\\{T, L_z\\}$ 的泊松括号定义中：\n$$ \\{T, L_z\\} = \\left( (0)(-y) - (\\frac{p_x}{m})(p_y) \\right) + \\left( (0)(x) - (\\frac{p_y}{m})(-p_x) \\right) + \\left( (0)(0) - (\\frac{p_z}{m})(0) \\right) $$\n$$ \\{T, L_z\\} = -\\frac{p_x p_y}{m} + \\frac{p_y p_x}{m} + 0 = 0 $$\n\n其次，我们计算 $\\{U, L_z\\}$。设 $r = \\|\\mathbf{r}\\| = \\sqrt{x^2+y^2+z^2}$。我们使用链式法则来求 $U(r)$ 的导数。\n$U$ 的导数：\n$$ \\frac{\\partial U}{\\partial x} = \\frac{dU}{dr} \\frac{\\partial r}{\\partial x} = U'(r) \\frac{x}{r} $$\n$$ \\frac{\\partial U}{\\partial y} = \\frac{dU}{dr} \\frac{\\partial r}{\\partial y} = U'(r) \\frac{y}{r} $$\n$$ \\frac{\\partial U}{\\partial z} = \\frac{dU}{dr} \\frac{\\partial r}{\\partial z} = U'(r) \\frac{z}{r} $$\n势能 $U$ 不依赖于动量，所以：\n$$ \\frac{\\partial U}{\\partial p_x} = 0, \\quad \\frac{\\partial U}{\\partial p_y} = 0, \\quad \\frac{\\partial U}{\\partial p_z} = 0 $$\n现在，我们将这些以及 $L_z$ 的导数代入 $\\{U, L_z\\}$ 的泊松括号定义中：\n$$ \\{U, L_z\\} = \\left( (U'(r)\\frac{x}{r})(-y) - (0)(p_y) \\right) + \\left( (U'(r)\\frac{y}{r})(x) - (0)(-p_x) \\right) + \\left( (U'(r)\\frac{z}{r})(0) - (0)(0) \\right) $$\n$$ \\{U, L_z\\} = -\\frac{U'(r)xy}{r} + \\frac{U'(r)yx}{r} + 0 = 0 $$\n\n结合两个结果：\n$$ \\{H, L_z\\} = \\{T, L_z\\} + \\{U, L_z\\} = 0 + 0 = 0 $$\n泊松括号 $\\{H, L_z\\}$ 为零。\n\n问题的第二部分是论证 $L_z$ 是否守恒。在哈密顿动力学中，任何可观测量 $A(q, p, t)$ 的全时间导数由哈密顿运动方程给出：\n$$ \\frac{dA}{dt} = \\{A, H\\} + \\frac{\\partial A}{\\partial t} $$\n对于可观测量 $A=L_z$，函数 $L_z = x p_y - y p_x$ 不显式依赖于时间，因此 $\\frac{\\partial L_z}{\\partial t} = 0$。$L_z$ 的运动方程因此为：\n$$ \\frac{dL_z}{dt} = \\{L_z, H\\} $$\n使用泊松括号的反对称性质 $\\{A, B\\} = -\\{B, A\\}$，我们有：\n$$ \\{L_z, H\\} = -\\{H, L_z\\} $$\n因为我们已经发现 $\\{H, L_z\\} = 0$，由此得出：\n$$ \\frac{dL_z}{dt} = - (0) = 0 $$\n全时间导数为零的量是一个运动常数，意味着它在系统轨迹上是守恒的。因此，$L_z$ 是一个守恒量。\n这个结果是 Noether 定理的一个体现。在中心势中运动的粒子的哈密顿量在任何旋转下都是不变的。特别是，它在绕 $z$ 轴的旋转下是不变的。这种连续对称性（绕 $z$ 轴的旋转不变性）意味着存在一个相应的守恒量，即角动量的 $z$ 分量 $L_z$。计算 $\\{H, L_z\\} = 0$ 是在哈密顿框架内对该守恒定律的形式证明。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "从连续的运动方程到计算机模拟，必然需要对时间进行离散化，但这会引入数值误差。本练习将深入探讨在分子动力学中广泛应用的速度 Verlet 算法的稳定性。通过分析其在简谐振子模型下的行为，我们可以推导出允许的最大时间步长，这是确保模拟既稳定又高效的关键参数()。",
            "id": "3814061",
            "problem": "在原子尺度的分子动力学（MD）中，键合相互作用通常被建模为谐振弹簧。考虑一个代表孤立键合相互作用的单自由度谐振子，其质量为 $m$，弹簧常数为 $k$。其动力学由牛顿第二定律 $m \\ddot{x} = - k x$ 控制，这等价于一个哈密顿量 $H(p,x) = \\frac{p^{2}}{2 m} + \\frac{k}{2} x^{2}$，及其正则方程 $\\dot{x} = \\frac{\\partial H}{\\partial p}$ 和 $\\dot{p} = - \\frac{\\partial H}{\\partial x}$。使用速度Verlet时间积分器，通过推导位置序列 $x_{n}$ 的离散色散关系，来分析离散动力学的线性稳定性，假设采用一个模态拟设，其每一步具有以弧度为单位的恒定相移。根据此色散关系，确定解保持有界（即不表现出指数增长）的最大时间步长 $\\Delta t$，并将其表示为 $k$ 和 $m$ 的闭式解析函数。最终时间步长以秒为单位表示。无需进行数值取整。",
            "solution": "谐振子的动力学由方程 $m \\ddot{x} = -k x$ 描述。振子的固有角频率为 $\\omega = \\sqrt{k/m}$。运动方程可以写成 $\\ddot{x} + \\omega^2 x = 0$。加速度为 $a(t) = \\ddot{x}(t) = -\\omega^2 x(t)$。\n\n速度Verlet算法将位置 $x$ 和速度 $v$ 从时间 $n \\Delta t$ 推进到 $(n+1) \\Delta t$。令 $x_n = x(n \\Delta t)$，$v_n = v(n \\Delta t)$，以及 $a_n = a(n \\Delta t)$。该算法包括两个主要步骤：\n1. 位置更新：\n   $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. 速度更新：\n   $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n对于谐振子，我们有 $a_n = -\\omega^2 x_n$ 和 $a_{n+1} = -\\omega^2 x_{n+1}$。\n\n为了推导位置序列 $x_n$ 的离散色散关系，我们将这些方程组合起来，形成一个只关于 $x$ 的单一递推关系。\n首先，将 $a_n = -\\omega^2 x_n$ 代入位置更新方程：\n$$x_{n+1} = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 \\quad (*)$$\n接下来，我们写出后续步骤（从 $n+1$到 $n+2$）的位置更新：\n$$x_{n+2} = x_{n+1} + v_{n+1} \\Delta t + \\frac{1}{2} a_{n+1} (\\Delta t)^2$$\n代入 $a_{n+1} = -\\omega^2 x_{n+1}$，我们得到：\n$$x_{n+2} = x_{n+1} + v_{n+1} \\Delta t - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 \\quad (**)$$\n为了消去速度，我们使用速度更新方程：\n$$v_{n+1} = v_n - \\frac{\\omega^2 \\Delta t}{2} (x_n + x_{n+1})$$\n我们可以使用位置更新方程，用位置来表示 $v_n$ 和 $v_{n+1}$。从方程 $(*)$，我们重新整理以求得 $v_n$：\n$$v_n \\Delta t = x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2$$\n类似地，从方程 $(**)$，我们求得 $v_{n+1}$：\n$$v_{n+1} \\Delta t = x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\n现在，将速度更新方程乘以 $\\Delta t$ 后，把 $v_n \\Delta t$ 和 $v_{n+1} \\Delta t$ 的这些表达式代入其中：\n$$v_{n+1} \\Delta t = v_n \\Delta t - \\frac{\\omega^2 (\\Delta t)^2}{2} (x_n + x_{n+1})$$\n$$\\left( x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 \\right) = \\left( x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 \\right) - \\frac{\\omega^2 (\\Delta t)^2}{2} (x_n + x_{n+1})$$\n我们通过合并同类项来简化表达式：\n$$x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 = x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\n$$x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 = x_{n+1} - x_n - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\n分离出 $x_{n+2}$：\n$$x_{n+2} = 2x_{n+1} - x_n - \\omega^2 (\\Delta t)^2 x_{n+1}$$\n这就给出了位置序列的三项递推关系：\n$$x_{n+2} - (2 - \\omega^2 (\\Delta t)^2) x_{n+1} + x_n = 0$$\n为了找到离散色散关系，我们使用所要求的模态拟设。设解的形式为 $x_n = A \\exp(i \\phi n)$，其中 $\\phi$ 是每步的恒定相移。将此代入递推关系：\n$$A \\exp(i \\phi (n+2)) - (2 - \\omega^2 (\\Delta t)^2) A \\exp(i \\phi (n+1)) + A \\exp(i \\phi n) = 0$$\n除以 $A \\exp(i \\phi n)$（因为对于非平凡解，$A \\neq 0$）：\n$$\\exp(2i\\phi) - (2 - \\omega^2 (\\Delta t)^2) \\exp(i\\phi) + 1 = 0$$\n这是一个关于 $\\exp(i\\phi)$ 的二次方程。为了得到色散关系，我们除以 $\\exp(i\\phi)$：\n$$\\exp(i\\phi) - (2 - \\omega^2 (\\Delta t)^2) + \\exp(-i\\phi) = 0$$\n使用欧拉恒等式 $\\exp(i\\phi) + \\exp(-i\\phi) = 2 \\cos(\\phi)$，我们得到：\n$$2 \\cos(\\phi) = 2 - \\omega^2 (\\Delta t)^2$$\n$$\\cos(\\phi) = 1 - \\frac{\\omega^2 (\\Delta t)^2}{2}$$\n这就是应用于谐振子的速度Verlet算法的离散色散关系。它将每步的数值相移 $\\phi$ 与真实的物理频率 $\\omega$ 以及时间步长 $\\Delta t$ 联系起来。\n\n为了使数值解 $x_n$ 保持有界（即不指数增长），相移 $\\phi$ 必须是一个实数。这要求其余弦值位于区间 $[-1, 1]$ 内。\n$$-1 \\le \\cos(\\phi) \\le 1$$\n代入推导出的 $\\cos(\\phi)$ 表达式：\n$$-1 \\le 1 - \\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1$$\n我们分别分析这两个不等式。\n右侧的不等式是：\n$$1 - \\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1 \\implies -\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 0$$\n这个不等式总是成立的，因为 $\\omega^2 \\ge 0$ 且 $(\\Delta t)^2 \\ge 0$。\n左侧的不等式给出了稳定性限制条件：\n$$-1 \\le 1 - \\frac{\\omega^2 (\\Delta t)^2}{2}$$\n$$\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1 + 1$$\n$$\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 2$$\n$$\\omega^2 (\\Delta t)^2 \\le 4$$\n对两边取平方根（并注意 $\\omega > 0$ 且 $\\Delta t > 0$）：\n$$\\omega \\Delta t \\le 2$$\n解保持有界的最大时间步长 $\\Delta t_{max}$ 对应于等式成立的情况：\n$$\\omega \\Delta t_{max} = 2$$\n$$\\Delta t_{max} = \\frac{2}{\\omega}$$\n最后，我们代入固有频率的定义 $\\omega = \\sqrt{k/m}$：\n$$\\Delta t_{max} = \\frac{2}{\\sqrt{k/m}}$$\n$$\\Delta t_{max} = 2 \\sqrt{\\frac{m}{k}}$$\n这就是最大稳定时间步长的闭式解析表达式。如果量 $m$ 和 $k$ 以国际单位制（分别为 $kg$ 和 $N/m = kg/s^2$）给出，则得到的时间步长 $\\Delta t_{max}$ 的单位将是秒。",
            "answer": "$$\\boxed{2 \\sqrt{\\frac{m}{k}}}$$"
        },
        {
            "introduction": "分子动力学模拟的长期准确性在很大程度上取决于所选择的积分算法。这个动手编程练习将对比一个通用的非辛积分器（四阶龙格—库塔法）和一个专为哈密顿体系设计的辛积分器（速度 Verlet 法）。通过观察长期的能量漂移，你将对为何辛方法对于可靠且具有物理意义的分子模拟至关重要，获得一个实践性的理解()。",
            "id": "3814073",
            "problem": "您的任务是设计并实现一个程序，在多尺度材料模拟中使用的保守原子模型的背景下，比较两种哈密顿动力学时间积分方法的长期能量行为。从哈密顿力学和牛顿力学的第一性原理出发。对于一个具有广义坐标 $q \\in \\mathbb{R}^d$ 和动量 $p \\in \\mathbb{R}^d$ 的系统，其哈密顿量为 $H(q,p) = T(p) + V(q)$，其中 $T(p)$ 是动能，$V(q)$ 是势能，运动方程为哈密顿方程：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}, \\quad \n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q},\n$$\n并且，对于恒定质量 $m$，等效的牛顿第二定律形式为\n$$\nm \\frac{d^2 q}{dt^2} = -\\nabla V(q).\n$$\n使用无量纲单位，其中 $m = 1$ 且 $T(p) = \\frac{1}{2} \\, p^\\top p$。实现并比较两种用于对这些方程进行长时间积分的数值方法：经典的四阶龙格-库塔方法和速度 Verlet 方法。除了上述基本定律外，不要假设或使用任何外部给定的公式；实现必须遵循对这些定律所蕴含的连续时间常微分方程进行离散化的过程。\n\n定义并使用以下势能模型，这些模型是材料中原子间相互作用和振动模式的标准替代模型：\n\n- 单自由度非谐振子（Duffing 型）：\n$$\nV(q) = \\frac{1}{2} \\, k \\, q^2 + \\frac{1}{4} \\, \\alpha \\, q^4,\n$$\n其参数 $k$ 和 $\\alpha$ 将在每个测试中指定。\n\n- 双自由度刚性-慢速耦合非谐振子：\n$$\nV(q) = \\frac{1}{2} \\, k_1 \\, q_1^2 + \\frac{1}{2} \\, k_2 \\, q_2^2 + \\frac{1}{4} \\, \\alpha \\, (q_1^4 + q_2^4) + \\frac{1}{2} \\, \\beta \\, q_1^2 q_2^2,\n$$\n其参数 $k_1$、$k_2$、$\\alpha$、$\\beta$ 将在每个测试中指定，其中 $q = (q_1, q_2)$。\n\n对于下述每个测试用例，从给定的初始条件 $(q_0, p_0)$ 开始，使用时间步长 $h$ 对两种方法进行 $N$ 步积分。质量为 $m = 1$，因此速度 $v$ 满足 $v = p$。在每一步 $n$，计算总能量\n$$\nH_n = \\frac{1}{2} \\, p_n^\\top p_n + V(q_n).\n$$\n设 $H_0$ 为初始状态的能量，$H_N$ 为最终状态的能量。对于每种方法，报告由下式定义的最终相对能量变化\n$$\n\\Delta_{\\text{rel}} = \\frac{H_N - H_0}{H_0}.\n$$\n所有量均为无量纲。不涉及角度，因此不需要角度单位。\n\n测试套件参数：\n\n- 用例 $1$（单自由度非谐振子，“标准情况”）：\n  - 参数：$k = 1.0$，$\\alpha = 0.1$。\n  - 初始条件：$q_0 = 1.0$，$p_0 = 0.0$。\n  - 时间步长：$h = 0.1$。\n  - 步数：$N = 50000$。\n\n- 用例 $2$（单自由度非谐振子，小步长，更长时间）：\n  - 参数：$k = 1.0$，$\\alpha = 0.1$。\n  - 初始条件：$q_0 = 1.0$，$p_0 = 0.0$。\n  - 时间步长：$h = 0.01$。\n  - 步数：$N = 60000$。\n\n- 用例 $3$（双自由度刚性-慢速耦合非谐振子）：\n  - 参数：$k_1 = 1.0$，$k_2 = 25.0$，$\\alpha = 0.05$，$\\beta = 0.02$。\n  - 初始条件：$q_0 = (1.0, 0.5)$，$p_0 = (0.0, 0.0)$。\n  - 时间步长：$h = 0.02$。\n  - 步数：$N = 50000$。\n\n您的程序必须为每个用例执行两种积分，并计算每种方法的最终相对能量变化。最终输出必须是单行，包含一个列表的列表，按上述测试用例的顺序排列，其中每个内部列表包含两个浮点数值 $[\\Delta_{\\text{rel}}^{\\text{RK4}}, \\Delta_{\\text{rel}}^{\\text{Verlet}}]$，并四舍五入到六位小数。例如，最终输出格式必须完全如下所示\n$$\n[[x_1,y_1],[x_2,y_2],[x_3,y_3]]\n$$\n且无任何附加文本，其中 $x_i$ 和 $y_i$ 是用例 $i$ 的四舍五入值。",
            "solution": "该问题要求实现并比较两种数值积分方法——四阶龙格-库塔（RK4）方法和速度 Verlet 方法——用于求解保守哈密顿系统中的运动方程。其背景是原子模拟，其中长期能量守恒是优秀积分器的关键特性。我们从哈密顿力学和牛顿力学的第一性原理出发。\n\n一个保守力学系统由哈密顿量 $H(q, p)$ 描述，它是系统的总能量，表示为广义坐标 $q$ 和动量 $p$ 的函数。对于所讨论的系统，哈密顿量是可分离的，形式为 $H(q,p) = T(p) + V(q)$，其中 $T(p)$ 是动能，$V(q)$ 是势能。在无量纲单位下，给定质量 $m=1$，动能为 $T(p) = \\frac{1}{2} p^\\top p$。\n\n系统的时间演化由哈密顿方程决定：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}, \\quad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q}\n$$\n代入给定的哈密顿量，我们得到一个一阶常微分方程组（ODEs）：\n$$\n\\frac{dq}{dt} = \\frac{\\partial}{\\partial p} \\left(\\frac{1}{2} p^\\top p + V(q)\\right) = p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial}{\\partial q} \\left(\\frac{1}{2} p^\\top p + V(q)\\right) = -\\nabla_q V(q)\n$$\n$F(q) = -\\nabla_q V(q)$ 项是作用在系统上的力。运动方程可以写成 $\\dot{q} = p$ 和 $\\dot{p} = F(q)$。这等效于牛顿第二定律 $m\\ddot{q} = F(q)$，因为当 $m=1$ 时，$\\ddot{q} = \\dot{p} = F(q)$。\n\n我们现在将对这些连续方程进行离散化，以推导两种指定的数值积分器。\n\n### 积分器推导\n\n**1. 四阶龙格-库塔（RK4）方法**\n\nRK4 方法是求解形如 $\\dot{y} = f(t, y)$ 的一阶常微分方程的通用求解器。我们的系统可以通过定义状态向量 $y(t) = (q(t), p(t))^\\top$ 来表示成这种形式。函数 $f(y)$ 则为：$f(y) = f(q,p) = (\\dot{q}, \\dot{p}) = (p, F(q))$。\nRK4 方法使用四个中间步骤（斜率）的加权平均，将状态从时间 $t_n$推进到 $t_{n+1} = t_n + h$：\n$$\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中 $h$ 是时间步长，斜率 $k_i$ 定义如下：\n$$\n\\begin{aligned}\nk_1 = f(y_n) = (p_n, F(q_n)) \\\\\nk_2 = f\\left(y_n + \\frac{h}{2}k_1\\right) = f\\left(q_n + \\frac{h}{2}p_n, p_n + \\frac{h}{2}F(q_n)\\right) \\\\\nk_3 = f\\left(y_n + \\frac{h}{2}k_2\\right) \\\\\nk_4 = f(y_n + h k_3)\n\\end{aligned}\n$$\n通过在每个中间点计算 $f$，我们得到 $q$ 和 $p$ 关于时间的导数。然后，在最终的更新步骤中将它们组合起来，以计算 $(q_{n+1}, p_{n+1})$。RK4 是一种高阶方法（局部误差为 $\\mathcal{O}(h^5)$，全局误差为 $\\mathcal{O}(h^4)$），但它不是辛算法，这意味着它不能精确地保持哈密顿流的几何结构。这通常会导致在长时间模拟中总能量出现系统性漂移。\n\n**2. 速度 Verlet 方法**\n\n速度 Verlet 方法是通过离散化牛顿第二定律 $\\ddot{q} = F(q)/m$ 推导出来的。$q(t)$ 在时间 $t_n$ 附近的泰勒级数展开为：\n$$\nq(t_n+h) = q(t_n) + h \\dot{q}(t_n) + \\frac{h^2}{2} \\ddot{q}(t_n) + \\mathcal{O}(h^3)\n$$\n在我们的记法中，当质量 $m=1$ 时，这成为位置更新规则：\n$$\nq_{n+1} = q_n + h p_n + \\frac{h^2}{2} F(q_n)\n$$\n为了更新动量，我们考虑定义 $\\dot{p} = F(q)$ 并将其在一个时间步长上积分：\n$$\np_{n+1} - p_n = \\int_{t_n}^{t_{n+1}} F(q(t)) dt\n$$\n使用提供二阶精度的梯形法则来近似该积分，我们得到：\n$$\n\\int_{t_n}^{t_{n+1}} F(q(t)) dt \\approx \\frac{h}{2} [F(q(t_n)) + F(q(t_{n+1}))]\n$$\n这给出了动量更新规则：\n$$\np_{n+1} = p_n + \\frac{h}{2} [F(q_n) + F(q_{n+1})]\n$$\n请注意，此更新需要新位置 $q_{n+1}$ 处的力 $F(q_{n+1})$，而我们已在第一步中计算了它。因此，操作顺序如下：\n1.  使用 $p_n$ 和 $F(q_n)$ 更新位置 $q_{n+1}$。\n2.  使用新位置计算新力 $F(q_{n+1})$。\n3.  使用旧力和新力的平均值更新动量 $p_{n+1}$。\n\n速度 Verlet 算法是一种辛积分器。此特性确保了其具有出色的长期能量守恒性，表现为能量在真实能量值周围有界波动，而不是系统性漂移。\n\n### 势能模型和力\n\n力 $F(q)$ 由势能 $V(q)$ 推导得出，即 $F(q) = -\\nabla_q V(q)$。\n\n**1. 单自由度非谐振子（Duffing 型）**\n- 势能：$V(q) = \\frac{1}{2} k q^2 + \\frac{1}{4} \\alpha q^4$\n- 力：$F(q) = -\\frac{dV}{dq} = -(k q + \\alpha q^3)$\n\n**2. 双自由度耦合非谐振子**\n- 势能：$V(q_1, q_2) = \\frac{1}{2} k_1 q_1^2 + \\frac{1}{2} k_2 q_2^2 + \\frac{1}{4} \\alpha (q_1^4 + q_2^4) + \\frac{1}{2} \\beta q_1^2 q_2^2$\n- 力矢量 $F(q)=-\\nabla V(q) = (F_1, F_2)^\\top$：\n  - $F_1(q_1, q_2) = -\\frac{\\partial V}{\\partial q_1} = -(k_1 q_1 + \\alpha q_1^3 + \\beta q_1 q_2^2)$\n  - $F_2(q_1, q_2) = -\\frac{\\partial V}{\\partial q_2} = -(k_2 q_2 + \\alpha q_2^3 + \\beta q_1^2 q_2)$\n\n### 模拟与分析\n\n对于每个测试用例，系统在 $(q_0, p_0)$ 处初始化。计算初始能量 $H_0 = \\frac{1}{2} p_0^\\top p_0 + V(q_0)$。然后，使用时间步长 $h$ 将系统演化 $N$ 步，分别使用 RK4 积分器和速度 Verlet 积分器各一次。$N$ 步之后，计算最终能量 $H_N = \\frac{1}{2} p_N^\\top p_N + V(q_N)$。用于比较的度量是相对能量变化 $\\Delta_{\\text{rel}} = (H_N - H_0) / H_0$。该值量化了每种方法在模拟期间的能量守恒特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run simulations and compare integrator energy conservation.\n    \"\"\"\n\n    # --- Potential and Force Functions ---\n    \n    # 1-DOF Duffing Oscillator\n    def potential_duffing(q, k, alpha):\n        # V(q) = 1/2 k q^2 + 1/4 alpha q^4\n        q_scalar = q[0]\n        return 0.5 * k * q_scalar**2 + 0.25 * alpha * q_scalar**4\n\n    def force_duffing(q, k, alpha):\n        # F(q) = -dV/dq = -(k q + alpha q^3)\n        return -(k * q + alpha * q**3)\n\n    # 2-DOF Coupled Oscillator\n    def potential_coupled(q, k1, k2, alpha, beta):\n        # V(q) = 1/2 k1 q1^2 + 1/2 k2 q2^2 + 1/4 alpha (q1^4 + q2^4) + 1/2 beta q1^2 q2^2\n        q1, q2 = q[0], q[1]\n        return (0.5 * k1 * q1**2 + 0.5 * k2 * q2**2 +\n                0.25 * alpha * (q1**4 + q2**4) + 0.5 * beta * q1**2 * q2**2)\n\n    def force_coupled(q, k1, k2, alpha, beta):\n        # F(q) = -grad(V)\n        q1, q2 = q[0], q[1]\n        F1 = -(k1 * q1 + alpha * q1**3 + beta * q1 * q2**2)\n        F2 = -(k2 * q2 + alpha * q2**3 + beta * q1**2 * q2)\n        return np.array([F1, F2])\n\n    \n    # --- Numerical Integrators ---\n\n    def rk4_step(q, p, h, force_func, f_params):\n        \"\"\"A single step of the RK4 integrator for a Hamiltonian system.\"\"\"\n        # dot(q) = p, dot(p) = F(q)\n\n        # k1\n        q_dot_1 = p\n        p_dot_1 = force_func(q, **f_params)\n\n        # k2\n        q_temp_2 = q + 0.5 * h * q_dot_1\n        p_temp_2 = p + 0.5 * h * p_dot_1\n        q_dot_2 = p_temp_2\n        p_dot_2 = force_func(q_temp_2, **f_params)\n\n        # k3\n        q_temp_3 = q + 0.5 * h * q_dot_2\n        p_temp_3 = p + 0.5 * h * p_dot_2\n        q_dot_3 = p_temp_3\n        p_dot_3 = force_func(q_temp_3, **f_params)\n\n        # k4\n        q_temp_4 = q + h * q_dot_3\n        p_temp_4 = p + h * p_dot_3\n        q_dot_4 = p_temp_4\n        p_dot_4 = force_func(q_temp_4, **f_params)\n\n        # Final update\n        q_next = q + (h / 6.0) * (q_dot_1 + 2.0 * q_dot_2 + 2.0 * q_dot_3 + q_dot_4)\n        p_next = p + (h / 6.0) * (p_dot_1 + 2.0 * p_dot_2 + 2.0 * p_dot_3 + p_dot_4)\n        \n        return q_next, p_next\n\n    def verlet_step(q, p, h, force_func, f_params):\n        \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n        # Using m=1, p=v\n        F_n = force_func(q, **f_params)\n        \n        # 1. Update position\n        q_next = q + h * p + 0.5 * h**2 * F_n\n        \n        # 2. Compute new force\n        F_n_plus_1 = force_func(q_next, **f_params)\n        \n        # 3. Update momentum (velocity)\n        p_next = p + 0.5 * h * (F_n + F_n_plus_1)\n        \n        return q_next, p_next\n\n    # --- Simulation Runner ---\n    \n    def run_simulation(integrator, q0, p0, h, N, pot_func, p_params, force_func, f_params):\n        \"\"\"Runs a simulation for N steps and returns relative energy error.\"\"\"\n        q, p = np.copy(q0), np.copy(p0)\n        \n        H0 = 0.5 * np.dot(p0, p0) + pot_func(q0, **p_params)\n        \n        for _ in range(N):\n            q, p = integrator(q, p, h, force_func, f_params)\n            \n        HN = 0.5 * np.dot(p, p) + pot_func(q, **p_params)\n        \n        # Avoid division by zero if initial energy is zero\n        if H0 == 0:\n            return HN # or some other indicator of this special case\n            \n        return (HN - H0) / H0\n\n    # --- Test Cases Definition ---\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: 1-DOF, h=0.1, N=50k\",\n            \"potential\": potential_duffing,\n            \"force\": force_duffing,\n            \"params\": {\"k\": 1.0, \"alpha\": 0.1},\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 0.1,\n            \"N\": 50000,\n        },\n        {\n            \"name\": \"Case 2: 1-DOF, h=0.01, N=60k\",\n            \"potential\": potential_duffing,\n            \"force\": force_duffing,\n            \"params\": {\"k\": 1.0, \"alpha\": 0.1},\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 0.01,\n            \"N\": 60000,\n        },\n        {\n            \"name\": \"Case 3: 2-DOF stiff-slow\",\n            \"potential\": potential_coupled,\n            \"force\": force_coupled,\n            \"params\": {\"k1\": 1.0, \"k2\": 25.0, \"alpha\": 0.05, \"beta\": 0.02},\n            \"q0\": np.array([1.0, 0.5]),\n            \"p0\": np.array([0.0, 0.0]),\n            \"h\": 0.02,\n            \"N\": 50000,\n        },\n    ]\n\n    # --- Main Loop ---\n    \n    all_results = []\n    for case in test_cases:\n        delta_rk4 = run_simulation(\n            rk4_step, case[\"q0\"], case[\"p0\"], case[\"h\"], case[\"N\"],\n            case[\"potential\"], case[\"params\"], case[\"force\"], case[\"params\"]\n        )\n        \n        delta_verlet = run_simulation(\n            verlet_step, case[\"q0\"], case[\"p0\"], case[\"h\"], case[\"N\"],\n            case[\"potential\"], case[\"params\"], case[\"force\"], case[\"params\"]\n        )\n        \n        all_results.append([round(delta_rk4, 6), round(delta_verlet, 6)])\n\n    # Format the final output string exactly as required.\n    string_results = [f\"[{r[0]},{r[1]}]\" for r in all_results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n```"
        }
    ]
}