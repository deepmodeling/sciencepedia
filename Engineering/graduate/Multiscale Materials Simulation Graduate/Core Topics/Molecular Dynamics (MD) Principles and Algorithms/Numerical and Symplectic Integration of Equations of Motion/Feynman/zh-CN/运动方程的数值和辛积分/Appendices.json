{
    "hands_on_practices": [
        {
            "introduction": "在将任何数值积分方法应用于实际问题之前，我们必须首先了解其稳定性。这个练习将通过对谐振子（原子振动的基本模型）进行线性稳定性分析，来推导速度Verlet算法的稳定性极限。掌握这个核心概念，可以帮助我们为更复杂的模拟选择合理的时间步长。",
            "id": "3828011",
            "problem": "在多尺度材料模拟的原子尺度部分，平衡位置附近的晶格振动通常被建模为谐振子，并采用如速度Verlet等辛格式进行积分，以保持其几何结构。考虑由牛顿第二定律 $\\ddot{q}(t) + \\omega^{2} q(t) = 0$ 描述的一维谐振子，其中 $q(t)$ 是位移，$\\omega$ 是与势阱局部曲率相关的角频率。应用速度Verlet方法，以恒定时间步长 $h$ 将状态 $(q_{n}, v_{n})$ 推进到 $(q_{n+1}, v_{n+1})$，这通过标准的三个子步骤完成：半步速度更新、整步位置更新和最后的半步速度更新。其中，加速度由谐振子势 $V(q) = \\frac{1}{2} \\omega^{2} q^{2}$ 和单位质量所产生的力给出。从牛顿第二定律和速度Verlet的定义出发，推导此线性系统在相空间中的单步线性更新，形式为一个 $2 \\times 2$ 的放大矩阵，该矩阵将时间 $t_{n}$ 的状态映射到 $t_{n+1}$。对该放大矩阵进行线性稳定性分析，并确定无量纲步长 $z = h \\omega$ 的集合，在该集合中，所有特征值都位于单位圆上，这与有界振荡传播相一致。利用此分析，报告能使速度Verlet方法对谐振子保持线性稳定的无量纲步长 $z$ 的上确界 $z_{\\max}$。将最终答案表示为单个实数，不要包含单位。",
            "solution": "问题要求推导速度Verlet积分方法在一维谐振子问题上的线性稳定性极限。分析过程分三个主要阶段：首先，将速度Verlet的单步更新表示为矩阵运算；其次，求出该矩阵的特征值；第三，确定在何种条件下这些特征值导致稳定（非发散）的演化。\n\n谐振子的运动方程为 $\\ddot{q}(t) + \\omega^{2} q(t) = 0$。在单位质量（$m=1$）的情况下，牛顿第二定律 $F=ma$ 意味着力为 $F(q) = -\\omega^{2} q$。因此加速度为 $a(q) = -\\omega^{2} q$。系统在离散时间步 $t_n$ 的状态由相空间向量 $(q_n, v_n) = (q(t_n), \\dot{q}(t_n))$ 给出。\n\n速度Verlet算法通过一个时间步长 $h$ 将状态从 $(q_n, v_n)$ 推进到 $(q_{n+1}, v_{n+1})$，过程包括以下三个顺序的更新步骤：\n\n1.  **半步速度更新**：使用当前位置 $q_n$ 的加速度，将速度推进半步。加速度为 $a_n = a(q_n) = -\\omega^2 q_n$。\n    $$v_{n+1/2} = v_n + \\frac{h}{2} a_n = v_n - \\frac{h^2 \\omega^2}{2} q_n$$\n\n2.  **整步位置更新**：使用半步速度 $v_{n+1/2}$，将位置推进一个完整时间步。\n    $$q_{n+1} = q_n + h v_{n+1/2}$$\n    代入第一步中 $v_{n+1/2}$ 的表达式：\n    $$q_{n+1} = q_n + h \\left(v_n - \\frac{h \\omega^2}{2} q_n\\right) = \\left(1 - \\frac{h^2 \\omega^2}{2}\\right) q_n + h v_n$$\n\n3.  **最后的半步速度更新**：使用新位置 $q_{n+1}$ 的加速度，将速度再推进半步。加速度为 $a_{n+1} = a(q_{n+1}) = -\\omega^2 q_{n+1}$。\n    $$v_{n+1} = v_{n+1/2} + \\frac{h}{2} a_{n+1} = v_{n+1/2} - \\frac{h \\omega^2}{2} q_{n+1}$$\n    代入 $v_{n+1/2}$ 和 $q_{n+1}$ 的表达式：\n    $$v_{n+1} = \\left(v_n - \\frac{h \\omega^2}{2} q_n\\right) - \\frac{h \\omega^2}{2} \\left[ \\left(1 - \\frac{h^2 \\omega^2}{2}\\right) q_n + h v_n \\right]$$\n    我们按 $q_n$ 和 $v_n$ 对各项进行分组：\n    $$v_{n+1} = \\left(-\\frac{h \\omega^2}{2} - \\frac{h \\omega^2}{2}\\left(1 - \\frac{h^2 \\omega^2}{2}\\right)\\right) q_n + \\left(1 - \\frac{h^2 \\omega^2}{2}\\right) v_n$$\n    $$v_{n+1} = \\left(-h \\omega^2 + \\frac{h^3 \\omega^4}{4}\\right) q_n + \\left(1 - \\frac{h^2 \\omega^2}{2}\\right) v_n$$\n    $$v_{n+1} = -h \\omega^2 \\left(1 - \\frac{h^2 \\omega^2}{4}\\right) q_n + \\left(1 - \\frac{h^2 \\omega^2}{2}\\right) v_n$$\n\n现在，我们可以将单步更新写成一个矩阵方程，这定义了放大矩阵 $\\mathbf{A}$：\n$$\n\\begin{pmatrix} q_{n+1} \\\\ v_{n+1} \\end{pmatrix} =\n\\begin{pmatrix}\n1 - \\frac{h^2 \\omega^2}{2}  h \\\\\n-h \\omega^2 \\left(1 - \\frac{h^2 \\omega^2}{4}\\right)  1 - \\frac{h^2 \\omega^2}{2}\n\\end{pmatrix}\n\\begin{pmatrix} q_n \\\\ v_n \\end{pmatrix}\n= \\mathbf{A} \\begin{pmatrix} q_n \\\\ v_n \\end{pmatrix}\n$$\n\n为了进行线性稳定性分析，我们研究放大矩阵 $\\mathbf{A}$ 的特征值。系统稳定的充要条件是所有特征值的模都小于或等于1。对于像谐振子这样的保守系统，稳定性要求特征值位于复平面的单位圆上，即 $|\\lambda|=1$。\n\n让我们引入无量纲步长 $z=h\\omega$。矩阵 $\\mathbf{A}$ 可以用 $z$ 表示为：\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\n1 - \\frac{z^2}{2}  \\frac{z}{\\omega} \\\\\n-\\omega z \\left(1 - \\frac{z^2}{4}\\right)  1 - \\frac{z^2}{2}\n\\end{pmatrix}\n$$\n特征值 $\\lambda$ 是特征方程 $\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$ 的根。特征多项式为 $\\lambda^2 - \\mathrm{Tr}(\\mathbf{A})\\lambda + \\det(\\mathbf{A}) = 0$。\n\n让我们计算 $\\mathbf{A}$ 的迹和行列式：\n$$\\mathrm{Tr}(\\mathbf{A}) = \\left(1 - \\frac{z^2}{2}\\right) + \\left(1 - \\frac{z^2}{2}\\right) = 2 - z^2$$\n$$\n\\det(\\mathbf{A}) = \\left(1 - \\frac{z^2}{2}\\right)^2 - \\left(\\frac{z}{\\omega}\\right) \\left(-\\omega z \\left(1 - \\frac{z^2}{4}\\right)\\right)\n= \\left(1 - z^2 + \\frac{z^4}{4}\\right) + z^2 \\left(1 - \\frac{z^2}{4}\\right)\n= 1 - z^2 + \\frac{z^4}{4} + z^2 - \\frac{z^4}{4} = 1\n$$\n$\\det(\\mathbf{A})=1$ 这个事实是像速度Verlet这类辛积分方法的一个标志，因为它意味着线性系统的相空间面积守恒。\n\n特征方程为：\n$$\\lambda^2 - (2 - z^2)\\lambda + 1 = 0$$\n根（特征值）由二次方程求根公式给出：\n$$\\lambda = \\frac{(2 - z^2) \\pm \\sqrt{(2 - z^2)^2 - 4}}{2}$$\n要使特征值位于单位圆上，它们必须是一对共轭复数（或者为实数且等于 $\\pm 1$）。这要求二次方程的判别式为非正：\n$$\\Delta = (2 - z^2)^2 - 4 \\le 0$$\n这个不等式可以解出 $z$：\n$$(2 - z^2)^2 \\le 4$$\n两边取平方根得到：\n$$|2 - z^2| \\le 2$$\n这等价于复合不等式：\n$$-2 \\le 2 - z^2 \\le 2$$\n我们分别分析这两个部分：\n1.  $2 - z^2 \\le 2 \\implies -z^2 \\le 0 \\implies z^2 \\ge 0$。对于实数 $z$ 这总是成立的。\n2.  $-2 \\le 2 - z^2 \\implies z^2 \\le 4$。\n\n由于 $z = h \\omega$ 代表物理上的时间步长和频率，我们必须有 $z \\ge 0$。因此，稳定性的条件是 $0 \\le z \\le 2$。该积分方案对于闭区间 $[0, 2]$ 内的所有无量纲步长 $z$ 都是线性稳定的。\n\n问题要求的是这组无量纲步长的上确界 $z_{\\max}$。区间 $[0, 2]$ 的上确界是 $2$。在边界 $z=2$ 处，特征值为 $\\lambda = \\frac{(2-4) \\pm \\sqrt{0}}{2} = -1$，它在单位圆上，但在实践中可能导致振荡不稳定性。对于任何 $z > 2$，特征值变为实数，其中一个的模大于1，导致指数增长和数值不稳定性。\n\n因此，保持线性稳定的无量纲步长的上确界是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "辛积分器的卓越性能不仅在于其稳定性，更在于其独特的误差结构。本练习旨在通过推导谐振子在Verlet积分下的相位误差，揭示数值轨迹如何精确地跟随一个“影子”哈密顿量，从而产生可预测的频率偏移而非能量漂移。理解这一点是掌握辛几何积分方法精髓的关键。",
            "id": "3828031",
            "problem": "考虑一个代表多尺度材料模拟中原子尺度子域的单个简谐正规模态，该模态被建模为一个位移为 $q(t)$ 的质点，其运动遵循牛顿第二定律 $m\\,\\ddot{q}(t) + k\\,q(t) = 0$，其中 $m  0$ 是质量，$k  0$ 是刚度，$\\omega = \\sqrt{k/m}$ 是自然角频率。该模态使用在分子动力学 (MD) 中常用的速度 Verlet 积分器，以固定的时间步长 $h  0$ 进行时间推进。假设稳定性条件 $0  \\omega h  2$ 成立，并选择 $h$ 使得精确周期 $T = 2\\pi/\\omega$ 是 $h$ 的整数倍，从而 $M = N T / h \\in \\mathbb{N}$ 步恰好对应于 $N \\in \\mathbb{N}$ 个连续周期。\n\n从基本运动方程和速度 Verlet 算法的定义出发，分析离散动力学，以确定控制谐振子数值演化的修正角频率 $\\tilde{\\omega}$。然后，将恰好 $N$ 个连续周期后的累积相位误差定义为 $\\Delta \\phi = \\phi_{\\mathrm{num}} - \\phi_{\\mathrm{exact}}$，其中 $\\phi_{\\mathrm{exact}} = 2\\pi N$ 且 $\\phi_{\\mathrm{num}} = \\tilde{\\omega}\\,N T$，并推导出一个以 $N$、$\\omega$ 和 $h$ 表示的 $\\Delta \\phi$ 的闭式解析表达式。\n\n用弧度表示最终的相位误差。您的最终答案必须是单个闭式解析表达式。",
            "solution": "该问题要求推导使用速度 Verlet 算法积分的谐振子的累积相位误差。推导过程首先确定控制离散动力学的修正角频率 $\\tilde{\\omega}$，然后用它计算在指定周期数后相对于精确解的相位差。\n\n简谐振子的运动方程为：\n$$\nm\\,\\ddot{q}(t) + k\\,q(t) = 0\n$$\n其中 $q(t)$ 是位移，$m$ 是质量，$k$ 是刚度。两边除以 $m$ 并定义自然角频率 $\\omega = \\sqrt{k/m}$，我们得到标准形式：\n$$\n\\ddot{q}(t) = -\\omega^2 q(t)\n$$\n在时间 $t$ 的加速度是 $a(t) = \\ddot{q}(t) = -\\omega^2 q(t)$。\n\n速度 Verlet 算法在时间间隔 $h$ 内，将位置 $q$ 和速度 $v = \\dot{q}$ 从时间步 $n$ 推进到 $n+1$。更新规则如下：\n1.  更新位置：$q_{n+1} = q_n + v_n h + \\frac{1}{2} a_n h^2$\n2.  更新速度：$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) h$\n\n这里，$q_n = q(t_n)$，$v_n = v(t_n)$，$a_n = a(t_n)$。对于谐振子，我们可以代入 $a_n = -\\omega^2 q_n$ 和 $a_{n+1} = -\\omega^2 q_{n+1}$。\n\n让我们将该算法重写为状态向量 $\\begin{pmatrix} q_n \\\\ v_n \\end{pmatrix}$ 的一个线性映射。\n首先，将 $a_n = -\\omega^2 q_n$ 代入位置更新公式：\n$$\nq_{n+1} = q_n + v_n h - \\frac{1}{2} \\omega^2 q_n h^2 = \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right)q_n + h\\,v_n\n$$\n接下来，将 $a_n = -\\omega^2 q_n$ 和 $a_{n+1} = -\\omega^2 q_{n+1}$ 代入速度更新公式：\n$$\nv_{n+1} = v_n - \\frac{1}{2} \\omega^2 h (q_n + q_{n+1})\n$$\n现在，将 $q_{n+1}$ 的表达式代入 $v_{n+1}$ 的方程中：\n$$\nv_{n+1} = v_n - \\frac{1}{2} \\omega^2 h \\left[q_n + \\left(\\left(1 - \\frac{1}{2}\\omega^2 h^2\\right)q_n + h\\,v_n\\right)\\right]\n$$\n$$\nv_{n+1} = v_n - \\frac{1}{2} \\omega^2 h \\left[\\left(2 - \\frac{1}{2}\\omega^2 h^2\\right)q_n + h\\,v_n\\right]\n$$\n$$\nv_{n+1} = \\left[-\\omega^2 h\\left(1 - \\frac{1}{4}\\omega^2 h^2\\right)\\right]q_n + \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right)v_n\n$$\n我们现在可以将离散演化写成矩阵形式 $\\begin{pmatrix} q_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\mathbf{A} \\begin{pmatrix} q_n \\\\ v_n \\end{pmatrix}$：\n$$\n\\begin{pmatrix} q_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 h^2  h \\\\ -\\omega^2 h\\left(1 - \\frac{1}{4}\\omega^2 h^2\\right)  1 - \\frac{1}{2}\\omega^2 h^2 \\end{pmatrix} \\begin{pmatrix} q_n \\\\ v_n \\end{pmatrix}\n$$\n这个矩阵 $\\mathbf{A}$ 是一个时间步的转移矩阵。数值动力学由其特征值 $\\lambda$ 决定。特征方程为 $\\det(\\mathbf{A} - \\lambda\\mathbf{I}) = 0$：\n$$\n\\left(1 - \\frac{1}{2}\\omega^2 h^2 - \\lambda\\right)^2 + \\omega^2 h^2 \\left(1 - \\frac{1}{4}\\omega^2 h^2\\right) = 0\n$$\n展开此式，我们得到一个关于 $\\lambda$ 的二次方程：\n$$\n\\lambda^2 - 2\\left(1 - \\frac{1}{2}\\omega^2 h^2\\right)\\lambda + \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right)^2 + \\omega^2 h^2 - \\frac{1}{4}\\omega^4 h^4 = 0\n$$\n$$\n\\lambda^2 - \\left(2 - \\omega^2 h^2\\right)\\lambda + \\left(1 - \\omega^2 h^2 + \\frac{1}{4}\\omega^4 h^4\\right) + \\omega^2 h^2 - \\frac{1}{4}\\omega^4 h^4 = 0\n$$\n$$\n\\lambda^2 - \\left(2 - \\omega^2 h^2\\right)\\lambda + 1 = 0\n$$\n转移矩阵的迹为 $\\mathrm{Tr}(\\mathbf{A}) = 2 - \\omega^2 h^2$。对于一个稳定的振荡系统，其数值解也应该是振荡的，对应于单位圆上的特征值 $\\lambda = e^{\\pm i \\tilde{\\omega} h}$，其中 $\\tilde{\\omega}$ 是修正角频率。这个旋转的矩阵表示的迹为 $e^{i\\tilde{\\omega}h} + e^{-i\\tilde{\\omega}h} = 2\\cos(\\tilde{\\omega}h)$。\n令这两个关于迹的表达式相等，可得：\n$$\n2\\cos(\\tilde{\\omega}h) = 2 - \\omega^2 h^2\n$$\n$$\n\\cos(\\tilde{\\omega}h) = 1 - \\frac{1}{2}(\\omega h)^2\n$$\n稳定性条件 $0  \\omega h  2$ 确保了余弦函数的自变量在 $-1$ 和 $1$ 之间，因此存在一个实数 $\\tilde{\\omega}$。我们可以直接解出 $\\tilde{\\omega}$，但使用半角恒等式 $\\cos(\\theta) = 1 - 2\\sin^2(\\theta/2)$ 可以得到一个更简洁的表达式。\n$$\n1 - 2\\sin^2\\left(\\frac{\\tilde{\\omega}h}{2}\\right) = 1 - \\frac{1}{2}(\\omega h)^2\n$$\n$$\n\\sin^2\\left(\\frac{\\tilde{\\omega}h}{2}\\right) = \\frac{(\\omega h)^2}{4}\n$$\n$$\n\\sin\\left(\\frac{\\tilde{\\omega}h}{2}\\right) = \\frac{\\omega h}{2}\n$$\n我们取正根，因为对于小的 $h$，$\\omega \\approx \\tilde{\\omega}$，所以 $\\tilde{\\omega}h/2$ 是一个小的正角。稳定性条件 $0  \\omega h  2$ 意味着 $0  \\omega h/2  1$，这是反正弦函数 $\\arcsin$ 得到主值在 $(0, \\pi/2)$ 区间内的定义域。\n解出 $\\tilde{\\omega}$：\n$$\n\\frac{\\tilde{\\omega}h}{2} = \\arcsin\\left(\\frac{\\omega h}{2}\\right)\n$$\n$$\n\\tilde{\\omega} = \\frac{2}{h}\\arcsin\\left(\\frac{\\omega h}{2}\\right)\n$$\n这是修正角频率的闭式表达式。\n\n现在，我们可以计算在时间 $t_{final} = N T$ 后的累积相位误差 $\\Delta \\phi$，其中 $T = 2\\pi/\\omega$ 是精确周期，$N$ 是一个整数。\n累积的精确总相位为：\n$$\n\\phi_{\\mathrm{exact}} = \\omega t_{final} = \\omega (N T) = \\omega N \\frac{2\\pi}{\\omega} = 2\\pi N\n$$\n在相同时间段内累积的数值总相位为：\n$$\n\\phi_{\\mathrm{num}} = \\tilde{\\omega} t_{final} = \\tilde{\\omega} (N T)\n$$\n代入 $\\tilde{\\omega}$ 和 $T$ 的表达式：\n$$\n\\phi_{\\mathrm{num}} = \\left(\\frac{2}{h}\\arcsin\\left(\\frac{\\omega h}{2}\\right)\\right) N \\left(\\frac{2\\pi}{\\omega}\\right) = \\frac{4\\pi N}{\\omega h}\\arcsin\\left(\\frac{\\omega h}{2}\\right)\n$$\n相位误差 $\\Delta\\phi$ 定义为数值相位与精确相位之差：\n$$\n\\Delta\\phi = \\phi_{\\mathrm{num}} - \\phi_{\\mathrm{exact}} = \\frac{4\\pi N}{\\omega h}\\arcsin\\left(\\frac{\\omega h}{2}\\right) - 2\\pi N\n$$\n提出公因式 $2\\pi N$ 得到累积相位误差的最终闭式表达式：\n$$\n\\Delta\\phi = 2\\pi N \\left(\\frac{2}{\\omega h}\\arcsin\\left(\\frac{\\omega h}{2}\\right) - 1\\right)\n$$\n此表达式仅取决于给定的参数 $N$、$\\omega$ 和 $h$。$T/h$ 是整数的条件确保了比较是在精确系统完成整数个周期时进行的，但对于公式本身而言，这个条件并非必要。",
            "answer": "$$\\boxed{2\\pi N \\left( \\frac{2}{\\omega h} \\arcsin\\left(\\frac{\\omega h}{2}\\right) - 1 \\right)}$$"
        },
        {
            "introduction": "理论分析最终需要通过实际计算来验证。在这个实践中，您将为多尺度材料模拟中常用的Lennard-Jones势实现速度Verlet算法。通过模拟长时间的动力学过程并监测总能量，您将亲眼见证辛积分器在抑制长期能量漂移方面的卓越能力。",
            "id": "3828000",
            "problem": "考虑一个双粒子系统，该系统采用约化单位，代表了多尺度材料模拟中使用的粗粒化原子相互作用。两个质量为 $m$ 的相同粒子通过 Lennard-Jones 对势 $U(r)=4\\epsilon\\left[(\\sigma/r)^{12}-(\\sigma/r)^6\\right]$相互作用，其中 $r$ 是标量分离距离（径向坐标），$\\epsilon$ 设定能量尺度，$\\sigma$ 设定长度尺度。在适用于两个相同质量的相对坐标描述中，动力学简化为由约化质量 $\\mu = m/2$ 的牛顿第二定律所控制的单自由度系统，\n$$\n\\mu\\,\\ddot{r}(t) = -\\frac{dU}{dr}(r(t)),\n$$\n其中 $r(t)0$。总能量为\n$$\nE(t) = \\frac{1}{2}\\mu\\,\\dot{r}(t)^2 + U(r(t))。\n$$\n从上述基本定律以及长时间材料模拟中时间可逆性和相空间体积守恒的要求出发，推导该单自由度系统的速度 Verlet 积分器，并实现一个显式时间步进更新，该更新将 $(r,v)$（其中 $v=\\dot{r}$）推进一个时间步长 $h$。使用此积分器，估算在指定时间步长 $h$ 下，经过 $N=10^6$ 步后的长时间能量漂移。\n\n使用以下在约化 Lennard-Jones 单位下科学上合理且自洽的设置：\n- 参数：$m=1$，$\\mu = 1/2$，$\\epsilon=1$，$\\sigma=1$。\n- 初始条件：$r(0)=1.3\\,\\sigma$ 且 $v(0)=0$。\n- 源于势的力：$F(r) = -\\frac{dU}{dr}(r)$，径向作用；使用从给定 $U(r)$ 推导出的 $F(r)=24\\,\\epsilon\\left[2\\,\\sigma^{12}r^{-13}-\\sigma^6 r^{-7}\\right]$。\n- 需监控的能量：如上定义的 $E(t)$。\n\n任务：\n1. 从牛顿第二定律和给定的势函数出发，推导速度 Verlet 方法对 $(r,v)$ 的更新规则，并解释为何对于可分离的哈密顿量，该方法是辛守恒和时间可逆的。\n2. 实现单步速度 Verlet 更新，并迭代使用 $N=10^6$ 步来推进系统。\n3. 对于提供的测试套件中的每个时间步长，计算能量漂移 $\\Delta E = E(Nh) - E(0)$，并以 $\\epsilon$ 为单位，以浮点数形式报告。\n\n测试套件：\n- 情况 1（理想情况）：$h=0.002$。\n- 情况 2（较大步长，接近此设置的稳定性边界）：$h=0.02$。\n\n此处不涉及角度单位。能量漂移值以 $\\epsilon$ 为单位，用十进制浮点数表示。您的程序应生成单行输出，包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2]”）。结果的顺序应与上面列出的测试套件情况相对应。",
            "solution": "我们从约化坐标下的二体问题的牛顿第二定律开始。对于两个质量为 $m$ 的相同粒子，质心运动解耦，相对坐标 $r$ 的演化由约化质量 $\\mu=m/2$ 决定。其控制方程为\n$$\n\\mu\\,\\ddot{r}(t) = -\\frac{dU}{dr}(r(t)),\n$$\n其中 Lennard-Jones 势为\n$$\nU(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]。\n$$\n对 $r$ 求导可得径向力\n$$\nF(r) = -\\frac{dU}{dr}(r) = 24\\epsilon\\left[2 \\frac{\\sigma^{12}}{r^{13}} - \\frac{\\sigma^6}{r^7}\\right],\n$$\n且加速度 $a(r)$ 满足\n$$\na(r) = \\ddot{r} = \\frac{F(r)}{\\mu}。\n$$\n总能量是精确动力学下的一个运动守恒量，其表达式为\n$$\nE(t) = \\frac{1}{2}\\mu\\,\\dot{r}(t)^2 + U(r(t))。\n$$\n\n为了设计用于材料模拟中长时间稳定性的数值积分器，我们依赖于基本的哈密顿原理。对于形式为 $H(p,q) = T(p) + V(q)$ 的可分离哈密顿量，其中 $T(p) = p^2/(2\\mu)$ 且 $V(q) = U(q)$，其精确流保持辛二形式不变且时间可逆。一种遵循这些性质的方法通常可以避免能量的长期增长。速度 Verlet 方法是通过将半步动量更新与全步位置更新相结合而推导出来的，这是将哈密顿量分解为动能和势能部分，并应用 Lie-Trotter 或 Strang 分解的结果。具体来说，记 $r_n \\approx r(t_n)$ 和 $v_n \\approx \\dot{r}(t_n)$，且 $t_{n+1} = t_n + h$。速度 Verlet 的更新规则是\n$$\nr_{n+1} = r_n + h\\,v_n + \\frac{h^2}{2} a(r_n),\n$$\n$$\na_{n} = \\frac{F(r_n)}{\\mu}, \\quad a_{n+1} = \\frac{F(r_{n+1})}{\\mu},\n$$\n$$\nv_{n+1} = v_n + \\frac{h}{2}\\left[a(r_n) + a(r_{n+1})\\right]。\n$$\n该格式是时间可逆的：如果使用 $h$ 进行更新，然后反转速度并使用 $-h$ 进行更新，则可以恢复到原始状态。它是辛守恒的，因为它可以被解释为在 $T(p)$ 和 $V(q)$ 下精确流的组合，其中每个流都是辛的，并且这种组合保持了辛性。对于光滑势，该方法的状态全局误差为 $\\mathcal{O}(h^2)$，并表现出有界的振荡能量误差，这与后向误差分析一致：数值轨迹精确地守恒一个修正的哈密顿量 $H_h$，它与原始哈密顿量 $H$ 相差 $\\mathcal{O}(h^2)$。\n\n算法实现如下：\n1. 以约化单位初始化参数：$m=1$，因此 $\\mu=1/2$，$\\epsilon=1$，$\\sigma=1$。选择初始条件 $r(0)=1.3\\sigma$ 和 $v(0)=0$，该位置点位于势能最低点 $r_m = 2^{1/6}\\sigma$ 附近，同时避免了在非常小的 $r$ 处的强排斥核心。\n2. 计算初始加速度 $a_0 = F(r_0)/\\mu$ 和初始能量 $E_0 = \\frac{1}{2}\\mu v_0^2 + U(r_0)$。\n3. 对于给定的时间步长 $h$，迭代速度 Verlet 更新 $N=10^6$ 步：\n   - 使用 $r_n$、$v_n$ 和 $a_n$ 更新 $r_{n+1}$。\n   - 计算 $a_{n+1} = F(r_{n+1})/\\mu$。\n   - 使用平均加速度更新 $v_{n+1}$。\n4. 计算最终能量 $E_N = \\frac{1}{2}\\mu v_N^2 + U(r_N)$ 和能量漂移 $\\Delta E = E_N - E_0$。\n5. 对测试套件中的时间步长 $h=0.002$ 和 $h=0.02$ 重复以上步骤。\n\n由于速度 Verlet 方法是辛守恒和时间可逆的，只要 $h$ 低于由 $U(r)$ 在工作区域附近的局部刚度（曲率）设定的稳定性阈值，$\\Delta E$ 在长时间内预计会很小，并表现为有界振荡而非系统性漂移。较大的时间步长测试了系统对该阈值的接近程度，此时能量偏差会增加，但如果保持稳定，则应保持有界。\n\n计算方面的考虑：\n- 每一步的操作是恒定的：在约化单位中，计算 $F(r)$ 和 $U(r)$ 仅包含少数几次乘法和通过重复乘法实现的幂运算，避免了昂贵的函数调用。\n- 对于 $N=10^6$ 步，在紧凑循环中迭代更新对于两个测试用例是可行的。\n- 所有报告的能量漂移都是以 $\\epsilon$ 为单位的无量纲值。\n\n程序实现了所述算法，并输出一行包含指定 $h$ 值的能量漂移结果，按给定顺序排列，并用方括号括起。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lennard_jones_force(r, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute the radial Lennard-Jones force F(r) = -dU/dr for r > 0.\n    F(r) = 24*epsilon * [ 2*(sigma^12)/r^13 - (sigma^6)/r^7 ].\n    Uses reduced units by default: epsilon = 1, sigma = 1.\n    \"\"\"\n    # Guard against non-positive r to avoid division by zero; reflect minimally.\n    if r = 0.0:\n        # If r is non-positive due to numerical error, gently push it positive.\n        r = abs(r) if r != 0.0 else np.finfo(float).tiny\n    inv_r = 1.0 / r\n    s_over_r = sigma * inv_r\n    s_over_r2 = s_over_r * s_over_r\n    s_over_r6 = s_over_r2 * s_over_r2 * s_over_r2  # (sigma/r)^6\n    s_over_r12 = s_over_r6 * s_over_r6             # (sigma/r)^12\n    # F = 24*epsilon * ( 2*s_over_r12/r - s_over_r6/r )\n    return 24.0 * epsilon * inv_r * (2.0 * s_over_r12 - s_over_r6)\n\ndef lennard_jones_potential(r, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute the Lennard-Jones potential U(r) = 4*epsilon * [ (sigma/r)^12 - (sigma/r)^6 ].\n    \"\"\"\n    if r = 0.0:\n        r = abs(r) if r != 0.0 else np.finfo(float).tiny\n    inv_r = 1.0 / r\n    s_over_r = sigma * inv_r\n    s_over_r2 = s_over_r * s_over_r\n    s_over_r6 = s_over_r2 * s_over_r2 * s_over_r2\n    s_over_r12 = s_over_r6 * s_over_r6\n    return 4.0 * epsilon * (s_over_r12 - s_over_r6)\n\ndef simulate_energy_drift(h_values, N_steps, r0, v0, m=1.0, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Simulate the relative-coordinate LJ system for each time step in h_values\n    using velocity Verlet for N_steps, and return a list of energy drifts\n    DeltaE = E_final - E_initial in units of epsilon.\n    \"\"\"\n    mu = 0.5 * m  # reduced mass for two identical particles\n\n    # Initialize states and accelerations for each h\n    states = []\n    for h in h_values:\n        r = float(r0)\n        v = float(v0)\n        a = lennard_jones_force(r, epsilon, sigma) / mu\n        E0 = 0.5 * mu * v * v + lennard_jones_potential(r, epsilon, sigma)\n        states.append([h, r, v, a, E0])\n\n    # Tight integration loop\n    for _ in range(N_steps):\n        # Update each state using velocity Verlet\n        # Unroll loop for performance when small number of h_values\n        if len(states) == 1:\n            h, r, v, a, E0 = states[0]\n            r_new = r + h * v + 0.5 * h * h * a\n            a_new = lennard_jones_force(r_new, epsilon, sigma) / mu\n            v_new = v + 0.5 * h * (a + a_new)\n            states[0][1] = r_new\n            states[0][2] = v_new\n            states[0][3] = a_new\n        elif len(states) == 2:\n            # First state\n            h0, r0s, v0s, a0s, E00 = states[0]\n            r0_new = r0s + h0 * v0s + 0.5 * h0 * h0 * a0s\n            a0_new = lennard_jones_force(r0_new, epsilon, sigma) / mu\n            v0_new = v0s + 0.5 * h0 * (a0s + a0_new)\n            states[0][1] = r0_new\n            states[0][2] = v0_new\n            states[0][3] = a0_new\n            # Second state\n            h1, r1s, v1s, a1s, E01 = states[1]\n            r1_new = r1s + h1 * v1s + 0.5 * h1 * h1 * a1s\n            a1_new = lennard_jones_force(r1_new, epsilon, sigma) / mu\n            v1_new = v1s + 0.5 * h1 * (a1s + a1_new)\n            states[1][1] = r1_new\n            states[1][2] = v1_new\n            states[1][3] = a1_new\n        else:\n            # General case\n            for i in range(len(states)):\n                h, r, v, a, E0 = states[i]\n                r_new = r + h * v + 0.5 * h * h * a\n                a_new = lennard_jones_force(r_new, epsilon, sigma) / mu\n                v_new = v + 0.5 * h * (a + a_new)\n                states[i][1] = r_new\n                states[i][2] = v_new\n                states[i][3] = a_new\n\n    # Compute energy drifts\n    drifts = []\n    for h, r, v, a, E0 in states:\n        E_final = 0.5 * mu * v * v + lennard_jones_potential(r, epsilon, sigma)\n        drifts.append(E_final - E0)\n    return drifts\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Two time steps to test: happy path and near-stability boundary.\n    h_values = [0.002, 0.02]\n    N_steps = 1_000_000\n    # Initial conditions in reduced units\n    r0 = 1.3  # sigma = 1\n    v0 = 0.0  # starting at rest\n    # Run simulation and collect energy drifts in units of epsilon.\n    results = simulate_energy_drift(h_values, N_steps, r0, v0, m=1.0, epsilon=1.0, sigma=1.0)\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}