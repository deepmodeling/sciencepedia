{
    "hands_on_practices": [
        {
            "introduction": "理解一个算法的最好方法就是亲手实现它。这个练习将指导你为一个简单的谐振子系统实现核心的可逆参考系统传播算法（r-RESPA），该系统具有快慢两种振动模式。通过将数值解与精确解析解进行比较，我们可以直接量化多时间步长积分的局部误差，并将其与标准的单步长Verlet积分器进行对比，从而深入理解该方法的工作原理和精度特性。",
            "id": "3843761",
            "problem": "考虑一个单自由度的哈密顿系统，该系统代表一个具有慢和快两个力分量的多尺度材料模型。设哈密顿量定义为\n$$\nH(q,p) = T(p) + V_{\\text{s}}(q) + V_{\\text{f}}(q),\n$$\n其中动能为\n$$\nT(p) = \\frac{p^2}{2m},\n$$\n慢势能为\n$$\nV_{\\text{s}}(q) = \\frac{1}{2} k_{\\text{s}} q^2 = \\frac{1}{2} m \\omega_{\\text{s}}^2 q^2,\n$$\n快势能为\n$$\nV_{\\text{f}}(q) = \\frac{1}{2} k_{\\text{f}} q^2 = \\frac{1}{2} m \\omega_{\\text{f}}^2 q^2,\n$$\n其中 $m$ 为质量，$q$ 为位置坐标，$p$ 为动量，$k_{\\text{s}} = m \\omega_{\\text{s}}^2$，$k_{\\text{f}} = m \\omega_{\\text{f}}^2$，且 $\\omega_{\\text{f}} \\gg \\omega_{\\text{s}}$。\n\n从哈密顿方程出发，\n$$\n\\dot{q} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial}{\\partial q}\\left(V_{\\text{s}}(q) + V_{\\text{f}}(q)\\right) = -(k_{\\text{s}} + k_{\\text{f}})q,\n$$\n实现可逆参考系统传播子算法 (r-RESPA) 多时间步进的一个宏观步，每个慢步包含 $M$ 个快子步。使用对称分裂方法，通过半步慢力踢来包夹一个仅含快力的速度 Verlet 子步循环。\n\n- 定义慢力分量 $F_{\\text{s}}(q) = -k_{\\text{s}} q$ 和快力分量 $F_{\\text{f}}(q) = -k_{\\text{f}} q$。\n- 对于宏观时间步长 $h$ 和整数 $M \\ge 1$ 个快子步，定义 $h_{\\text{f}} = h/M$。\n- 从 $(q,p)$ 到 $(q',p')$ 的 r-RESPA 宏观步如下：\n  1. 慢力半步踢：$p \\leftarrow p + \\frac{h}{2} F_{\\text{s}}(q)$。\n  2. 重复 $M$ 次仅含快力的速度 Verlet 子步：\n     - 快力半步踢：$p \\leftarrow p + \\frac{h_{\\text{f}}}{2} F_{\\text{f}}(q)$。\n     - 漂移：$q \\leftarrow q + \\frac{h_{\\text{f}}}{m} p$。\n     - 快力半步踢：$p \\leftarrow p + \\frac{h_{\\text{f}}}{2} F_{\\text{f}}(q)$。\n  3. 慢力半步踢：$p \\leftarrow p + \\frac{h}{2} F_{\\text{s}}(q)$。\n\n同样，使用全力 $F(q) = -(k_{\\text{s}} + k_{\\text{f}}) q$ 和相同的宏观步长 $h$ 实现单速率速度 Verlet 积分器：\n- 半步踢：$p \\leftarrow p + \\frac{h}{2} F(q)$。\n- 漂移：$q \\leftarrow q + \\frac{h}{m} p$。\n- 半步踢：$p \\leftarrow p + \\frac{h}{2} F(q)$。\n\n为了建立局部误差参考，使用组合谐振子的精确解，其总角频率为\n$$\n\\omega = \\sqrt{\\omega_{\\text{s}}^2 + \\omega_{\\text{f}}^2},\n$$\n该解满足 $q''(t) + \\omega^2 q(t) = 0$。给定初始条件 $(q(0), p(0)) = (q_0, p_0)$，在时间 $t=h$ 时的精确解为\n$$\nq_{\\text{exact}}(h) = q_0 \\cos(\\omega h) + \\frac{p_0}{m \\omega} \\sin(\\omega h),\n$$\n$$\np_{\\text{exact}}(h) = -m \\omega q_0 \\sin(\\omega h) + p_0 \\cos(\\omega h).\n$$\n\n对于下方的每个测试用例，计算 r-RESPA 和单速率速度 Verlet 两种方法在一个宏观步 $h$ 后 $q$ 和 $p$ 的绝对局部误差，定义如下\n$$\n\\varepsilon_q^{\\text{r}} = \\left| q_{\\text{r-RESPA}}(h) - q_{\\text{exact}}(h) \\right|, \\quad\n\\varepsilon_p^{\\text{r}} = \\left| p_{\\text{r-RESPA}}(h) - p_{\\text{exact}}(h) \\right|,\n$$\n$$\n\\varepsilon_q^{\\text{v}} = \\left| q_{\\text{Verlet}}(h) - q_{\\text{exact}}(h) \\right|, \\quad\n\\varepsilon_p^{\\text{v}} = \\left| p_{\\text{Verlet}}(h) - p_{\\text{exact}}(h) \\right|.\n$$\n\n使用国际单位制 (SI) 基本单位：位置 $q$ 的单位为米，动量 $p$ 的单位为千克·米/秒，质量 $m$ 的单位为千克，时间 $h$ 的单位为秒，角频率 $\\omega_{\\text{s}}$ 和 $\\omega_{\\text{f}}$ 的单位为弧度/秒。输出的数值使用这些单位表示（打印输出中不含单位标签）。角度以弧度为单位。\n\n测试套件：\n- 用例 1 (正常路径): $m = 1$, $\\omega_{\\text{s}} = 50$, $\\omega_{\\text{f}} = 2500$, $h = 0.001$, $M = 25$, $q_0 = 0.01$, $p_0 = 0.005$。\n- 用例 2 (边界, $M=1$): $m = 1$, $\\omega_{\\text{s}} = 50$, $\\omega_{\\text{f}} = 2500$, $h = 0.001$, $M = 1$, $q_0 = 0.01$, $p_0 = 0.005$。\n- 用例 3 (边缘, 非常刚性的快模态): $m = 1$, $\\omega_{\\text{s}} = 100$, $\\omega_{\\text{f}} = 100000$, $h = 0.001$, $M = 200$, $q_0 = 0.01$, $p_0 = 0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序 $\\left[\\varepsilon_q^{\\text{r}}, \\varepsilon_p^{\\text{r}}, \\varepsilon_q^{\\text{v}}, \\varepsilon_p^{\\text{v}}\\right]$ 追加四个浮点数。将所有测试用例的结果聚合到一个扁平列表中；例如，在一行上输出 $\\left[\\text{case1\\_four},\\text{case2\\_four},\\text{case3\\_four}\\right]$。",
            "solution": "该问题在科学上和数学上都是合理的。它提出了计算物理学中一个定义明确的任务，要求实现并比较两种标准的哈密顿系统数值积分方案与其已知的精确解。所有参数、算法和误差度量都得到了充分详细和清晰的说明，从而能够得出一个唯一且可验证的解。因此，该问题被视为有效，并立即提供完整解答。\n\n任务是模拟一个单自由度谐振子的动力学，其状态由位置 $q$ 和动量 $p$ 描述。系统的总能量由哈密顿量给出：\n$$\nH(q,p) = T(p) + V_{\\text{s}}(q) + V_{\\text{f}}(q) = \\frac{p^2}{2m} + \\frac{1}{2} k_{\\text{s}} q^2 + \\frac{1}{2} k_{\\text{f}} q^2\n$$\n在此表达式中，$m$ 是质量，$k_{\\text{s}} = m \\omega_{\\text{s}}^2$ 是与慢势 $V_{\\text{s}}(q)$ 相关联的弹簧常数，$k_{\\text{f}} = m \\omega_{\\text{f}}^2$ 是快势 $V_{\\text{f}}(q)$ 的弹簧常数。条件 $\\omega_{\\text{f}} \\gg \\omega_{\\text{s}}$ 表示时间尺度分离，这是诸如可逆参考系统传播子算法 (r-RESPA) 等多时间步进算法旨在利用的特征。\n\n哈密顿运动方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = -\\partial H / \\partial q$ 给出：\n$$\n\\dot{q} = \\frac{p}{m}\n$$\n$$\n\\dot{p} = -(k_{\\text{s}} + k_{\\text{f}})q\n$$\n作用在粒子上的力为 $F(q) = \\dot{p}$。这个总力可以加性分解为一个慢分量 $F_{\\text{s}}(q) = -\\frac{\\partial V_{\\text{s}}}{\\partial q} = -k_{\\text{s}} q$ 和一个快分量 $F_{\\text{f}}(q) = -\\frac{\\partial V_{\\text{f}}}{\\partial q} = -k_{\\text{f}} q$。\n\n整个系统是一个简谐振子，其总有效弹簧常数为 $k = k_{\\text{s}} + k_{\\text{f}}$，总角频率为 $\\omega = \\sqrt{k/m} = \\sqrt{\\omega_{\\text{s}}^2 + \\omega_{\\text{f}}^2}$。\n\n**精确解**\n给定初始条件 $(q(0), p(0)) = (q_0, p_0)$，系统在稍后时间 $h$ 的精确状态由二阶常微分方程 $q''(t) + \\omega^2 q(t) = 0$ 的解给出。该解为：\n$$\nq_{\\text{exact}}(h) = q_0 \\cos(\\omega h) + \\frac{p_0}{m \\omega} \\sin(\\omega h)\n$$\n$$\np_{\\text{exact}}(h) = m \\dot{q}(h) = -m \\omega q_0 \\sin(\\omega h) + p_0 \\cos(\\omega h)\n$$\n这些精确值提供了计算数值积分器局部误差的基准真相。\n\n**单速率速度 Verlet 积分器**\n速度 Verlet 算法是一种标准的、时间可逆的、辛的积分器，广泛应用于分子动力学。它使用全力 $F(q) = F_{\\text{s}}(q) + F_{\\text{f}}(q)$ 将系统演化一个时间步 $h$。从时间 $t_n$ 的状态 $(q_n, p_n)$ 开始，时间 $t_n+h$ 的状态 $(q_{n+1}, p_{n+1})$ 按以下方式计算：\n1. **第一次半步踢：** 使用当前位置的力更新动量。\n$$\np_{n+1/2} = p_n + \\frac{h}{2} F(q_n) = p_n - \\frac{h}{2} (k_{\\text{s}} + k_{\\text{f}}) q_n\n$$\n2. **漂移：** 使用新计算的中间动量更新位置。\n$$\nq_{n+1} = q_n + \\frac{h}{m} p_{n+1/2}\n$$\n3. **第二次半步踢：** 再次更新动量，这次使用在新位置 $q_{n+1}$ 处计算的力。\n$$\np_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{h}{2} (k_{\\text{s}} + k_{\\text{f}}) q_{n+1}\n$$\n一个宏观步之后的状态是 $(q_{\\text{Verlet}}(h), p_{\\text{Verlet}}(h)) = (q_{n+1}, p_{n+1})$。\n\n**可逆参考系统传播子算法 (r-RESPA)**\nr-RESPA 方法通过对不同的力分量使用不同的时间步长来解决系统的刚性问题。与哈密顿量相关的演化算子被对称地分裂。从 $(q_n, p_n)$ 开始，一个大小为 $h$ 的宏观步按以下方式计算：\n\n1. **第一次慢力半步踢：** 仅在慢力的影响下，将动量推进半步 $h/2$。\n$$\np^{(1)} = p_n + \\frac{h}{2} F_{\\text{s}}(q_n)\n$$\n2. **快力子循环：** 然后系统以大小为 $h_{\\text{f}} = h/M$ 的步长演化 $M$ 个子步。在每个子步中，仅使用快力 $F_{\\text{f}}$ 执行一个完整的速度 Verlet 步。设进入子步 $k$（$k$ 从 $1$ 到 $M$）的状态为 $(q_{k-1}^{\\text{f}}, p_{k-1}^{\\text{f}})$，起始状态为 $(q_0^{\\text{f}}, p_0^{\\text{f}}) = (q_n, p^{(1)})$。\n- 快力半步踢：$p_{k-1/2}^{\\text{f}} = p_{k-1}^{\\text{f}} + \\frac{h_{\\text{f}}}{2} F_{\\text{f}}(q_{k-1}^{\\text{f}})$\n- 漂移：$q_{k}^{\\text{f}} = q_{k-1}^{\\text{f}} + \\frac{h_{\\text{f}}}{m} p_{k-1/2}^{\\text{f}}$\n- 快力半步踢：$p_{k}^{\\text{f}} = p_{k-1/2}^{\\text{f}} + \\frac{h_{\\text{f}}}{2} F_{\\text{f}}(q_{k}^{\\text{f}})$\n经过 $M$ 次迭代后，离开循环时的状态是 $(q_M^{\\text{f}}, p_M^{\\text{f}})$。我们将其记为 $(q^{(2)}, p^{(2)})$。\n\n3. **第二次慢力半步踢：** 使用在最终位置 $q^{(2)}$ 处的慢力进行最终的动量更新。\n$$\np_{n+1} = p^{(2)} + \\frac{h}{2} F_{\\text{s}}(q^{(2)})\n$$\n一个 r-RESPA 宏观步之后的状态是 $(q_{\\text{r-RESPA}}(h), p_{\\text{r-RESPA}}(h)) = (q^{(2)}, p_{n+1})$。注意 $q_{n+1} = q^{(2)}$。\n\n**误差计算**\n将数值解与精确解进行比较，以确定它们在一个步长 $h$ 之后的局部绝对误差。误差定义为：\n$$\n\\varepsilon_q^{\\text{r}} = \\left| q_{\\text{r-RESPA}}(h) - q_{\\text{exact}}(h) \\right|, \\quad\n\\varepsilon_p^{\\text{r}} = \\left| p_{\\text{r-RESPA}}(h) - p_{\\text{exact}}(h) \\right|\n$$\n$$\n\\varepsilon_q^{\\text{v}} = \\left| q_{\\text{Verlet}}(h) - q_{\\text{exact}}(h) \\right|, \\quad\n\\varepsilon_p^{\\text{v}} = \\left| p_{\\text{Verlet}}(h) - p_{\\text{exact}}(h) \\right|\n$$\n该实现将包含每个积分器和精确解的函数，并将它们应用于每个测试用例以计算这四个误差度量。",
            "answer": "```python\nimport numpy as np\n\ndef r_respa_step(m, ks, kf, h, M, q0, p0):\n    \"\"\"\n    Performs one macro-step of the r-RESPA algorithm.\n    \"\"\"\n    hf = h / M\n    \n    q = q0\n    p = p0\n    \n    # 1. First slow half-kick\n    p = p + (h / 2.0) * (-ks * q)\n    \n    # 2. Fast sub-cycling loop (M velocity Verlet steps with fast force)\n    for _ in range(M):\n        # Fast half-kick\n        p = p + (hf / 2.0) * (-kf * q)\n        # Drift\n        q = q + (hf / m) * p\n        # Fast half-kick\n        p = p + (hf / 2.0) * (-kf * q)\n        \n    # 3. Second slow half-kick (using the final position from the loop)\n    p = p + (h / 2.0) * (-ks * q)\n    \n    return q, p\n\ndef verlet_step(m, ks, kf, h, q0, p0):\n    \"\"\"\n    Performs one step of the single-rate velocity Verlet algorithm.\n    \"\"\"\n    k_total = ks + kf\n    \n    q = q0\n    p = p0\n    \n    # 1. First half-kick (using total force)\n    p_half = p + (h / 2.0) * (-k_total * q)\n    \n    # 2. Drift\n    q = q + (h / m) * p_half\n    \n    # 3. Second half-kick (using total force at new position)\n    p = p_half + (h / 2.0) * (-k_total * q)\n    \n    return q, p\n\ndef exact_solution(m, ws, wf, h, q0, p0):\n    \"\"\"\n    Calculates the exact solution for the harmonic oscillator.\n    \"\"\"\n    omega = np.sqrt(ws**2 + wf**2)\n    \n    cos_oh = np.cos(omega * h)\n    sin_oh = np.sin(omega * h)\n    \n    q_exact = q0 * cos_oh + (p0 / (m * omega)) * sin_oh\n    p_exact = -m * omega * q0 * sin_oh + p0 * cos_oh\n    \n    return q_exact, p_exact\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # (m, ws, wf, h, M, q0, p0)\n        (1.0, 50.0, 2500.0, 0.001, 25, 0.01, 0.005),\n        (1.0, 50.0, 2500.0, 0.001, 1, 0.01, 0.005),\n        (1.0, 100.0, 100000.0, 0.001, 200, 0.01, 0.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m, ws, wf, h, M, q0, p0 = case\n        \n        # Calculate derived spring constants\n        ks = m * ws**2\n        kf = m * wf**2\n        \n        # Get exact solution as the reference\n        q_ex, p_ex = exact_solution(m, ws, wf, h, q0, p0)\n        \n        # Get r-RESPA numerical solution\n        q_r, p_r = r_respa_step(m, ks, kf, h, M, q0, p0)\n        \n        # Get single-rate Verlet numerical solution\n        q_v, p_v = verlet_step(m, ks, kf, h, q0, p0)\n        \n        # Calculate absolute local errors for both methods\n        err_q_r = abs(q_r - q_ex)\n        err_p_r = abs(p_r - p_ex)\n        err_q_v = abs(q_v - q_ex)\n        err_p_v = abs(p_v - p_ex)\n        \n        all_results.extend([err_q_r, err_p_r, err_q_v, err_p_v])\n\n    # Print the flattened list of results in the specified format\n    print(f\"[{','.join(map(lambda x: f'{x:.16g}', all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本实现之后，下一步是将其应用于一个更真实的物理模型，并评估其长期性能。本练习使用在材料科学中常见的核-壳模型，该模型天然地分离了快的壳层弛豫运动和慢的核-核相互作用。你的任务是实现一个辛多时间步长积分器，并测量长时间模拟过程中的总能量漂移，这直接展示了辛积分器在维持长期稳定性方面的关键优势，而这正是它们在模拟中被广泛应用的核心原因。",
            "id": "3843733",
            "problem": "考虑一个由$N$个相同晶格格点组成的一维周期性链，在核壳模型中代表一种铁电材料。每个格点 $i \\in \\{0,\\ldots,N-1\\}$ 包含一个位置为 $q_i^{\\mathrm{c}}$、动量为 $p_i^{\\mathrm{c}}$ 的核，以及一个位置为 $q_i^{\\mathrm{s}}$、动量为 $p_i^{\\mathrm{s}}$ 的壳。设核的质量为 $m_{\\mathrm{c}}$，壳的质量为 $m_{\\mathrm{s}}$。系统哈密顿量为\n$$\nH = T + V_{\\mathrm{fast}} + V_{\\mathrm{slow}},\n$$\n其中动能为\n$$\nT = \\sum_{i=0}^{N-1} \\left( \\frac{\\left(p_i^{\\mathrm{c}}\\right)^2}{2 m_{\\mathrm{c}}} + \\frac{\\left(p_i^{\\mathrm{s}}\\right)^2}{2 m_{\\mathrm{s}}} \\right),\n$$\n快势能（描述刚性壳层弛豫和短程壳层耦合）为\n$$\nV_{\\mathrm{fast}} = \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}} - q_i^{\\mathrm{c}}\\right)^2 + \\frac{1}{2} k_{\\mathrm{ss}} \\left(q_{i+1}^{\\mathrm{s}} - q_i^{\\mathrm{s}}\\right)^2 \\right),\n$$\n以及慢势能（描述软核-核耦合）为\n$$\nV_{\\mathrm{slow}} = \\sum_{i=0}^{N-1} \\frac{1}{2} k_{\\mathrm{cc}} \\left(q_{i+1}^{\\mathrm{c}} - q_i^{\\mathrm{c}}\\right)^2,\n$$\n其中假设采用周期性边界条件，因此 $q_N^{\\mathrm{c}} \\equiv q_0^{\\mathrm{c}}$ 且 $q_N^{\\mathrm{s}} \\equiv q_0^{\\mathrm{s}}$。运动方程由哈密顿方程（Hamilton’s equations）导出。\n\n您的任务是构建一个辛多时间步长（MTS）积分器，该积分器使用一个小的内时间步长处理 $V_{\\mathrm{fast}}$，并使用一个大的外时间步长处理 $V_{\\mathrm{slow}}$。请使用以下规范。\n\n- 按如下方式定义MTS划分：使用大小为 $\\delta t$ 的内辛速度Verlet步积分参考（快）哈密顿量 $H_{\\mathrm{ref}} = T + V_{\\mathrm{fast}}$，每个外时间步重复 $M$ 次；在演化参考系统 $\\Delta t$ 时间之前和之后，使用大小为 $\\Delta t/2$ 的辛“踢”来积分慢势能部分 $V_{\\mathrm{slow}}$。因此，一个大小为 $\\Delta t$ 的外时间步包括：慢半“踢”，$M$ 个大小为 $\\delta t = \\Delta t / M$ 的快内步，以及慢半“踢”。\n\n- 力由 $F = -\\nabla V$ 定义。对于作用于核的慢力，这会产生离散拉普拉斯算子 $F_i^{\\mathrm{slow,c}} = k_{\\mathrm{cc}} \\left(q_{i+1}^{\\mathrm{c}} - 2 q_i^{\\mathrm{c}} + q_{i-1}^{\\mathrm{c}}\\right)$。对于快力，使用 $F_i^{\\mathrm{fast,c}} = k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}} - q_i^{\\mathrm{c}}\\right)$ 和 $F_i^{\\mathrm{fast,s}} = -k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}} - q_i^{\\mathrm{c}}\\right) + k_{\\mathrm{ss}} \\left(q_{i+1}^{\\mathrm{s}} - 2 q_i^{\\mathrm{s}} + q_{i-1}^{\\mathrm{s}}\\right)$，所有力都采用周期性边界条件。\n\n- 用小振幅正弦核位移初始化位置，壳层初始时弛豫到核的位置：\n$$\nq_i^{\\mathrm{c}}(0) = A \\sin\\left( \\frac{2\\pi i}{N} \\right), \\quad q_i^{\\mathrm{s}}(0) = q_i^{\\mathrm{c}}(0),\n$$\n并将所有动量初始化为零，$p_i^{\\mathrm{c}}(0) = 0$ 和 $p_i^{\\mathrm{s}}(0) = 0$。\n\n使用MTS积分器模拟总物理时间 $T_{\\mathrm{tot}}$。在每个外时间步对总能量 $H(t)$ 进行采样，并使用最小二乘法计算关系式 $H(t) \\approx a t + b$ 中的最佳拟合线性漂移率 $a$。报告每个测试用例的 $a$。漂移率以无量纲能量/单位时间表示。\n\n使用任意现代编程语言，采用双精度浮点数实现该程序。角度以弧度为单位。使用以下测试套件，它涵盖了不同的尺度分离和步长比率。\n\n- 案例1（理想情况，强分离）：$N=16$, $m_{\\mathrm{c}}=1.0$, $m_{\\mathrm{s}}=0.1$, $k_{\\mathrm{cs}}=400.0$, $k_{\\mathrm{ss}}=5.0$, $k_{\\mathrm{cc}}=1.0$, $\\Delta t=0.02$, $M=8$, $T_{\\mathrm{tot}}=40.0$, $A=0.05$。\n\n- 案例2（更大的外时间步，更少的内时间步）：$N=16$, $m_{\\mathrm{c}}=1.0$, $m_{\\mathrm{s}}=0.1$, $k_{\\mathrm{cs}}=400.0$, $k_{\\mathrm{ss}}=5.0$, $k_{\\mathrm{cc}}=1.0$, $\\Delta t=0.05$, $M=5$, $T_{\\mathrm{tot}}=40.0$, $A=0.05$。\n\n- 案例3（减弱的分离和更强的慢耦合）：$N=16$, $m_{\\mathrm{c}}=1.0$, $m_{\\mathrm{s}}=0.1$, $k_{\\mathrm{cs}}=200.0$, $k_{\\mathrm{ss}}=5.0$, $k_{\\mathrm{cc}}=2.0$, $\\Delta t=0.05$, $M=4$, $T_{\\mathrm{tot}}=40.0$, $A=0.05$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含案例1、2和3的三个漂移率（例如，形如[result1,result2,result3]的一行）。",
            "solution": "我们从一个复合系统的哈密顿方程（Hamilton’s equations）出发，该系统具有坐标 $q = \\left(q^{\\mathrm{c}}, q^{\\mathrm{s}}\\right)$ 和动量 $p = \\left(p^{\\mathrm{c}}, p^{\\mathrm{s}}\\right)$，由哈密顿量 $H = T + V_{\\mathrm{fast}} + V_{\\mathrm{slow}}$ 控制。其基本定律是哈密顿方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = -\\partial H / \\partial q$，这意味着时间演化由刘维尔算子（Liouville operator） $L_H$ 生成。对于可分离的哈密顿量，辛算子分裂法通过组合 $H$ 各部分的精确流来构造时间可逆、保体积的映射。一种经过充分检验的构造是可逆参考系统传播算法（Reversible Reference System Propagator Algorithm, RESPA），它将系统分裂为一个由不频繁的“踢”处理的慢分量，以及一个由频繁的内步处理的参考（快）分量。\n\n我们选择分裂方式为 $H = H_{\\mathrm{ref}} + V_{\\mathrm{slow}}$，其中 $H_{\\mathrm{ref}} = T + V_{\\mathrm{fast}}$。在一个外时间步 $\\Delta t$ 内，辛二阶组合为\n$$\ne^{\\Delta t L_H} \\approx e^{\\frac{\\Delta t}{2} L_{V_{\\mathrm{slow}}}} \\left( e^{\\delta t L_{H_{\\mathrm{ref}}}} \\right)^M e^{\\frac{\\Delta t}{2} L_{V_{\\mathrm{slow}}}},\n$$\n其中 $\\delta t = \\Delta t / M$。映射 $e^{\\frac{\\Delta t}{2} L_{V_{\\mathrm{slow}}}}$ 仅对核施加动量“踢”，因为 $V_{\\mathrm{slow}}$ 仅依赖于 $q^{\\mathrm{c}}$。具体来说，慢半“踢”通过 $p^{\\mathrm{c}} \\leftarrow p^{\\mathrm{c}} + \\frac{\\Delta t}{2} F^{\\mathrm{slow,c}}(q^{\\mathrm{c}})$ 来更新核的动量，其中 $F^{\\mathrm{slow,c}} = -\\nabla_{q^{\\mathrm{c}}} V_{\\mathrm{slow}}$。壳层不受 $V_{\\mathrm{slow}}$ 的影响。\n\n对于 $H_{\\mathrm{ref}} = T + V_{\\mathrm{fast}}$ 的参考流，我们使用速度Verlet积分器，它是辛的且为二阶精度。一个大小为 $\\delta t$ 的内步执行以下操作：\n- 计算快力 $F^{\\mathrm{fast,c}}(q^{\\mathrm{c}}, q^{\\mathrm{s}})$ 和 $F^{\\mathrm{fast,s}}(q^{\\mathrm{c}}, q^{\\mathrm{s}})$，\n- 半“踢”：$p^{\\mathrm{c}} \\leftarrow p^{\\mathrm{c}} + \\frac{\\delta t}{2} F^{\\mathrm{fast,c}}$，$p^{\\mathrm{s}} \\leftarrow p^{\\mathrm{s}} + \\frac{\\delta t}{2} F^{\\mathrm{fast,s}}$，\n- 漂移：$q^{\\mathrm{c}} \\leftarrow q^{\\mathrm{c}} + \\delta t \\, p^{\\mathrm{c}} / m_{\\mathrm{c}}$，$q^{\\mathrm{s}} \\leftarrow q^{\\mathrm{s}} + \\delta t \\, p^{\\mathrm{s}} / m_{\\mathrm{s}}$，\n- 在新位置重新计算快力，\n- 半“踢”：$p^{\\mathrm{c}} \\leftarrow p^{\\mathrm{c}} + \\frac{\\delta t}{2} F^{\\mathrm{fast,c}}$，$p^{\\mathrm{s}} \\leftarrow p^{\\mathrm{s}} + \\frac{\\delta t}{2} F^{\\mathrm{fast,s}}$。\n\n因为慢半“踢”和内速度Verlet步都是辛的，它们的对称组合也是辛的且时间可逆，这对于控制长期能量漂移至关重要。由于离散化误差，漂移并非精确为零，但对于时间尺度分离足够的情况，$a$（总能量 $H(t)$ 随时间变化的最佳拟合线性斜率）应该很小，并且通常与 $\\Delta t$ 和 $\\delta t$ 的高阶函数成比例。\n\n现在我们从给定的势能推导出力。在周期性边界条件下，离散梯度得出\n$$\nF_i^{\\mathrm{slow,c}} = -\\frac{\\partial}{\\partial q_i^{\\mathrm{c}}} \\left( \\frac{1}{2} \\sum_j k_{\\mathrm{cc}} \\left(q_{j+1}^{\\mathrm{c}} - q_j^{\\mathrm{c}}\\right)^2 \\right) = k_{\\mathrm{cc}} \\left(q_{i+1}^{\\mathrm{c}} - 2 q_i^{\\mathrm{c}} + q_{i-1}^{\\mathrm{c}}\\right).\n$$\n对于快力，\n$$\n-\\frac{\\partial}{\\partial q_i^{\\mathrm{c}}} \\left( \\frac{1}{2} k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}} - q_i^{\\mathrm{c}}\\right)^2 \\right) = k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}} - q_i^{\\mathrm{c}}\\right) = F_i^{\\mathrm{fast,c}},\n$$\n以及\n$$\n-\\frac{\\partial}{\\partial q_i^{\\mathrm{s}}} \\left( \\frac{1}{2} k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}} - q_i^{\\mathrm{c}}\\right)^2 + \\frac{1}{2} k_{\\mathrm{ss}} \\left(q_{i+1}^{\\mathrm{s}} - q_i^{\\mathrm{s}}\\right)^2 \\right) = -k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}} - q_i^{\\mathrm{c}}\\right) + k_{\\mathrm{ss}} \\left(q_{i+1}^{\\mathrm{s}} - 2 q_i^{\\mathrm{s}} + q_{i-1}^{\\mathrm{s}}\\right) = F_i^{\\mathrm{fast,s}}.\n$$\n\n在时间 $t$ 的总能量计算如下\n$$\nH(t) = \\sum_{i=0}^{N-1} \\left( \\frac{\\left(p_i^{\\mathrm{c}}(t)\\right)^2}{2 m_{\\mathrm{c}}} + \\frac{\\left(p_i^{\\mathrm{s}}(t)\\right)^2}{2 m_{\\mathrm{s}}} \\right) + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} k_{\\mathrm{cs}} \\left(q_i^{\\mathrm{s}}(t) - q_i^{\\mathrm{c}}(t)\\right)^2 + \\frac{1}{2} k_{\\mathrm{ss}} \\left(q_{i+1}^{\\mathrm{s}}(t) - q_i^{\\mathrm{s}}(t)\\right)^2 \\right) + \\sum_{i=0}^{N-1} \\frac{1}{2} k_{\\mathrm{cc}} \\left(q_{i+1}^{\\mathrm{c}}(t) - q_i^{\\mathrm{c}}(t)\\right)^2.\n$$\n我们使用在外时间步 $t_n = n \\Delta t$ 采样的 $\\{(t_n, H_n)\\}$，通过最小二乘法拟合一条直线 $H(t) \\approx a t + b$，并报告斜率 $a$。\n\n算法设计细节：\n- 对 $q^{\\mathrm{c}}$、$q^{\\mathrm{s}}$、$p^{\\mathrm{c}}$、$p^{\\mathrm{s}}$ 使用双精度数组。\n- 通过索引滚动操作实现周期性边界条件：对于任意数组 $x$，让 $x_{i+1}$ 和 $x_{i-1}$ 通过循环移位实现。\n- 初始化 $q^{\\mathrm{c}}(0)$ 为 $q_i^{\\mathrm{c}}(0) = A \\sin(2 \\pi i / N)$，$q^{\\mathrm{s}}(0) = q^{\\mathrm{c}}(0)$，且所有动量为零。\n- 对于每个案例，计算 $n_{\\mathrm{outer}} = \\lfloor T_{\\mathrm{tot}}/\\Delta t \\rfloor$ 个外时间步，在每个外时间步（包括初始时间）收集 $H(t)$。\n- 对 $H$ 与 $t$ 进行最小二乘拟合以获得 $a$，其单位为无量纲能量/单位时间。\n\n测试套件的覆盖范围说明：\n- 案例1中 $k_{\\mathrm{cs}}$ 具有强刚度，$\\Delta t$ 较小且 $M$ 适中，表现出良好的稳定性和低漂移。\n- 案例2增大了 $\\Delta t$ 并减小了 $M$，对尺度分离提出了考验，并可能增加漂移。\n- 案例3减小了 $k_{\\mathrm{cs}}$ 并增大了 $k_{\\mathrm{cc}}$，减弱了快慢过程之间的分离，对积分器提出了进一步的考验。\n\n程序输出单行，包含一个由三个浮点数漂移率 $[a_1,a_2,a_3]$ 组成的列表，分别对应三个案例，以无量纲能量/单位时间表示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef roll_plus(x):\n    return np.roll(x, -1)\n\ndef roll_minus(x):\n    return np.roll(x, 1)\n\ndef forces_fast(qc, qs, k_cs, k_ss):\n    # Fast forces from core-shell springs and shell-shell coupling (periodic)\n    # Core fast force: k_cs * (qs - qc)\n    fc = k_cs * (qs - qc)\n    # Shell fast force: -k_cs*(qs - qc) + k_ss*(qs_{i+1} - 2*qs_i + qs_{i-1})\n    lap_s = roll_plus(qs) - 2.0 * qs + roll_minus(qs)\n    fs = -k_cs * (qs - qc) + k_ss * lap_s\n    return fc, fs\n\ndef forces_slow(qc, k_cc):\n    # Slow core-core force: k_cc * (qc_{i+1} - 2*qc_i + qc_{i-1})\n    return k_cc * (roll_plus(qc) - 2.0 * qc + roll_minus(qc))\n\ndef potential_fast(qc, qs, k_cs, k_ss):\n    # 0.5*k_cs*(qs - qc)^2 + 0.5*k_ss*(qs_{i+1} - qs_i)^2\n    cs = 0.5 * k_cs * np.sum((qs - qc) ** 2)\n    dq = roll_plus(qs) - qs\n    ss = 0.5 * k_ss * np.sum(dq ** 2)\n    return cs + ss\n\ndef potential_slow(qc, k_cc):\n    dq = roll_plus(qc) - qc\n    return 0.5 * k_cc * np.sum(dq ** 2)\n\ndef kinetic(pc, ps, m_c, m_s):\n    return np.sum(pc**2) / (2.0 * m_c) + np.sum(ps**2) / (2.0 * m_s)\n\ndef velocity_verlet_ref(qc, qs, pc, ps, m_c, m_s, k_cs, k_ss, dt, inner_steps):\n    # Integrate reference system H_ref = T + V_fast for time inner_steps*dt\n    for _ in range(inner_steps):\n        fc, fs = forces_fast(qc, qs, k_cs, k_ss)\n        pc += 0.5 * dt * fc\n        ps += 0.5 * dt * fs\n        qc += dt * (pc / m_c)\n        qs += dt * (ps / m_s)\n        fc, fs = forces_fast(qc, qs, k_cs, k_ss)\n        pc += 0.5 * dt * fc\n        ps += 0.5 * dt * fs\n    return qc, qs, pc, ps\n\ndef simulate_case(N, m_c, m_s, k_cs, k_ss, k_cc, Dt, M, T_total, A):\n    # Initialize positions and momenta\n    idx = np.arange(N, dtype=np.float64)\n    qc = A * np.sin(2.0 * np.pi * idx / N)\n    qs = qc.copy()\n    pc = np.zeros(N, dtype=np.float64)\n    ps = np.zeros(N, dtype=np.float64)\n\n    n_outer = int(np.floor(T_total / Dt))\n    dt_inner = Dt / M\n\n    times = [0.0]\n    Hs = [kinetic(pc, ps, m_c, m_s) + potential_fast(qc, qs, k_cs, k_ss) + potential_slow(qc, k_cc)]\n\n    for step in range(n_outer):\n        # Slow half-kick on cores\n        fslow = forces_slow(qc, k_cc)\n        pc += 0.5 * Dt * fslow\n\n        # Reference system integration for Dt using M inner steps\n        qc, qs, pc, ps = velocity_verlet_ref(qc, qs, pc, ps, m_c, m_s, k_cs, k_ss, dt_inner, M)\n\n        # Slow half-kick on cores\n        fslow = forces_slow(qc, k_cc)\n        pc += 0.5 * Dt * fslow\n\n        # Record energy at the end of the outer step\n        t = (step + 1) * Dt\n        H = kinetic(pc, ps, m_c, m_s) + potential_fast(qc, qs, k_cs, k_ss) + potential_slow(qc, k_cc)\n        times.append(t)\n        Hs.append(H)\n\n    # Linear least squares fit H(t) ~ a*t + b\n    t_arr = np.array(times, dtype=np.float64)\n    H_arr = np.array(Hs, dtype=np.float64)\n    # Center times to improve conditioning\n    t_mean = t_arr.mean()\n    A_mat = np.vstack([t_arr - t_mean, np.ones_like(t_arr)]).T\n    coeffs, _, _, _ = np.linalg.lstsq(A_mat, H_arr, rcond=None)\n    a = coeffs[0]  # slope\n    return float(a)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, m_c, m_s, k_cs, k_ss, k_cc, Dt, M, T_total, A)\n    test_cases = [\n        (16, 1.0, 0.1, 400.0, 5.0, 1.0, 0.02, 8, 40.0, 0.05),\n        (16, 1.0, 0.1, 400.0, 5.0, 1.0, 0.05, 5, 40.0, 0.05),\n        (16, 1.0, 0.1, 200.0, 5.0, 2.0, 0.05, 4, 40.0, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m_c, m_s, k_cs, k_ss, k_cc, Dt, M, T_total, A = case\n        drift = simulate_case(N, m_c, m_s, k_cs, k_ss, k_cc, Dt, M, T_total, A)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "掌握了实现技巧后，我们将挑战转向更具概念性的设计层面。在真实的模拟中，我们经常需要处理复杂的相互作用，例如使用粒子网格Ewald（PME）方法计算的长程静电相互作用。这项练习要求你运用对时间尺度的理解，为PME设计一个高效且准确的多时间步长（MTS）方案。你需要在降低计算成本（主要是快速傅里叶变换的计算次数）与因不频繁更新长程力而引入的误差之间做出明智的权衡。",
            "id": "3843722",
            "problem": "考虑一个边长为 $L = 3\\,\\mathrm{nm}$ 的周期性立方晶胞，其中包含 $N$ 个带电粒子，温度为 $T = 300\\,\\mathrm{K}$。库仑相互作用通过 Ewald 方法处理，其高斯屏蔽参数 $\\alpha$ 的选择使得在实空间截断半径 $r_c = 1.0\\,\\mathrm{nm}$ 处，互补误差函数的被忽略的尾部很小。势能通过标准的 Ewald 分解被分解为短程和长程部分，\n$$\nV(\\mathbf{q}) \\;=\\; V_{\\mathrm{sr}}(\\mathbf{q};\\alpha) \\;+\\; V_{\\mathrm{lr}}(\\mathbf{q};\\alpha),\n$$\n其中 $V_{\\mathrm{sr}}$ 包含 $r_c$ 范围内的实空间对项 $v_{\\mathrm{sr}}(r_{ij}) = \\frac{1}{4\\pi\\epsilon_0}\\frac{q_i q_j\\,\\mathrm{erfc}(\\alpha r_{ij})}{r_{ij}}$，而 $V_{\\mathrm{lr}}$ 通过在 $24^3$ 个点的规则网格（网格间距 $a_g = L/24$）上，使用 Particle Mesh Ewald (PME) 加速的倒易空间求和进行计算，并采用 $p=4$ 阶 B-spline 插值。使用快速傅里叶变换 (FFT) 来计算 $V_{\\mathrm{lr}}$ 及其力。\n\n你需要为哈密顿量 $H = T(\\mathbf{p}) + V_{\\mathrm{sr}}(\\mathbf{q};\\alpha) + V_{\\mathrm{lr}}(\\mathbf{q};\\alpha)$ 设计一个属于可逆参考系统传播子算法 (r-RESPA) 类型的辛多时间步 (MTS) 方案。该方案使用一个内部时间步长 $h$ 来积分快速变化的短程力 $\\mathbf{F}_{\\mathrm{sr}} = -\\nabla V_{\\mathrm{sr}}$，以及一个外部时间步长 $H = m h$ 来更新缓慢变化的长程倒易空间力 $\\mathbf{F}_{\\mathrm{lr}} = -\\nabla V_{\\mathrm{lr}}$，后者仅每 $m$ 个内部步长通过 PME 和 FFT 更新一次。\n\n假设以下科学上符合实际的背景：\n- 在 $T = 300\\,\\mathrm{K}$ 时，最轻物种的均方根速率为 $v_{\\mathrm{rms}} \\approx 2.7\\,\\mathrm{nm}/\\mathrm{ps}$，并使用一个保守的上限 $v_{\\max} \\approx 3.0\\,\\mathrm{nm}/\\mathrm{ps}$ 来估计在一个外部时间间隔内的最坏情况位移。\n- 由于倒易空间中的高斯滤波器 $\\exp(-k^2/4\\alpha^2)$，长程 PME 力场在网格尺度上是空间平滑的，因此其最强的变化发生于当粒子平流通过一小部分网格间距 $a_g = L/24 = 0.125\\,\\mathrm{nm}$ 时。\n- 一个平衡的方案应将在两次 PME 更新之间保持 $\\mathbf{F}_{\\mathrm{lr}}$ 不变所产生的相对误差控制在短程力误差的约 $10\\%$ 以下，同时尽可能减少单位物理时间内的平均 FFT 次数。\n\n根据哈密顿量分解和 Ewald 屏蔽引起的平滑性的基本原理，确定以下哪种 r-RESPA 方案最恰当地平衡了长程力更新误差与 FFT 成本。每种方案都隐含地使用一个对称的“踢-漂移-踢”组合来保持辛结构。\n\nA. 选择 $h = 1\\,\\mathrm{fs}$，并每 $m=8$ 个内部步长更新一次 $\\mathbf{F}_{\\mathrm{lr}}$（因此 $H = 8\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$ 插值，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。\n\nB. 选择 $h = 1\\,\\mathrm{fs}$，并每步都更新 $\\mathbf{F}_{\\mathrm{lr}}$（$m=1$，因此 $H = 1\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。\n\nC. 选择 $h = 1\\,\\mathrm{fs}$，并每 $m=20$ 个内部步长更新一次 $\\mathbf{F}_{\\mathrm{lr}}$（因此 $H = 20\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。\n\nD. 为 $\\mathbf{F}_{\\mathrm{sr}}$ 选择 $h = 4\\,\\mathrm{fs}$，并每步都更新 $\\mathbf{F}_{\\mathrm{lr}}$（$m=1$，因此 $H = 4\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。\n\n选择最能满足所述准确性与效率平衡的选项，并从控制方程、力变化的定量估计和计算规模缩放方面证明你的选择是合理的。",
            "solution": "在进行求解之前，需要对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- 系统类型：周期性立方晶胞\n- 边长：$L = 3\\,\\mathrm{nm}$\n- 粒子数：$N$\n- 温度：$T = 300\\,\\mathrm{K}$\n- 相互作用方法：Ewald 方法，使用高斯屏蔽参数 $\\alpha$\n- 实空间截断半径：$r_c = 1.0\\,\\mathrm{nm}$\n- 势能分解：$V(\\mathbf{q}) = V_{\\mathrm{sr}}(\\mathbf{q};\\alpha) + V_{\\mathrm{lr}}(\\mathbf{q};\\alpha)$\n- 短程对势：$v_{\\mathrm{sr}}(r_{ij}) = \\frac{1}{4\\pi\\epsilon_0}\\frac{q_i q_j\\,\\mathrm{erfc}(\\alpha r_{ij})}{r_{ij}}$\n- 长程方法：使用快速傅里叶变换 (FFT) 加速的 Particle Mesh Ewald (PME)\n- PME 网格维度：$24^3$\n- PME 网格间距：$a_g = L/24 = 3\\,\\mathrm{nm} / 24 = 0.125\\,\\mathrm{nm}$\n- PME B-spline 插值阶数：$p = 4$\n- 积分器：辛多时间步 (MTS) 的 r-RESPA 类型\n- 哈密顿量：$H = T(\\mathbf{p}) + V_{\\mathrm{sr}}(\\mathbf{q};\\alpha) + V_{\\mathrm{lr}}(\\mathbf{q};\\alpha)$\n- 内部时间步长：$h$，用于短程力 $\\mathbf{F}_{\\mathrm{sr}} = -\\nabla V_{\\mathrm{sr}}$\n- 外部时间步长：$H = m h$，用于长程力 $\\mathbf{F}_{\\mathrm{lr}} = -\\nabla V_{\\mathrm{lr}}$\n- 假设的最大粒子速率：$v_{\\max} \\approx 3.0\\,\\mathrm{nm}/\\mathrm{ps}$\n- $\\mathbf{F}_{\\mathrm{lr}}$ 的平滑性假设：当粒子移动一小部分网格间距 $a_g$ 时，出现最强的变化。\n- 优化目标：平衡长程力更新误差与 FFT 的成本。\n\n### 第2步：使用提取的已知条件进行验证\n该问题描述了使用 PME 方法处理长程静电相互作用的带电粒子分子动力学模拟的一个标准设置。参数（$L$、$T$、$r_c$、PME 网格）对于模拟水中的生物分子或离子液体等体系是符合实际的。实施多时间步方案 (r-RESPA) 以利用短程力和长程力的不同时间尺度，是提高计算效率的一种成熟且科学上合理的技术。哈密顿量分解是该方法的标准做法。最大粒子速度的估计与 $300\\,\\mathrm{K}$ 下轻原子（如氢）的均方根速率一致。关于长程力在 PME 网格尺度上是平滑的描述是该方法的一个基本性质。该问题有科学依据，是适定的（要求基于明确标准在选项中做出最佳选择），客观，并包含足够的信息以进行有原则的分析。未发现任何缺陷。\n\n### 第3步：结论与行动\n问题陈述有效。将推导解决方案。\n\n### 基于原理的推导\nr-RESPA 方法基于将哈密顿量分解为在不同时间尺度上演化的多个分量。在此问题中，哈密顿量被分解为 $H = H_{fast} + H_{slow}$，其中\n$$\nH_{fast} = T(\\mathbf{p}) + V_{\\mathrm{sr}}(\\mathbf{q};\\alpha)\n$$\n$$\nH_{slow} = V_{\\mathrm{lr}}(\\mathbf{q};\\alpha)\n$$\n总时间步长 $H$ 的传播子被对称地构造，例如：\n$$\ne^{H\\mathcal{L}} = e^{\\frac{H}{2}\\mathcal{L}_{slow}} \\left( e^{h\\mathcal{L}_{fast}} \\right)^m e^{\\frac{H}{2}\\mathcal{L}_{slow}}\n$$\n其中 $\\mathcal{L}$、$\\mathcal{L}_{fast}$ 和 $\\mathcal{L}_{slow}$ 分别是对应于 $H$、$H_{fast}$ 和 $H_{slow}$ 的刘维尔算符，且 $H = m h$。项 $e^{h\\mathcal{L}_{fast}}$ 表示在一个内部时间步长 $h$ 内对动量和短程力进行积分，通常使用速度 Verlet 型算法完成。项 $e^{\\frac{H}{2}\\mathcal{L}_{slow}}$ 表示使用长程力 $\\mathbf{F}_{\\mathrm{lr}}$ 对动量进行半步“踢”，该力在整个外部步长 $H$ 内保持恒定。\n\n误差的主要来源是使用步长 $h$ 对快力进行积分和使用步长 $H$ 对慢力进行积分。一个平衡的方案可确保这些误差处于相似的量级，或者如题目所指定，慢力积分的误差是快力误差的一个次要部分。\n\n**1. 内部时间步长 ($h$):**\n短程力 $\\mathbf{F}_{\\mathrm{sr}}$ 变化迅速，尤其是在粒子间距离 $r_{ij}$ 变得很小的粒子碰撞期间。这些力的数值积分的稳定性决定了允许的最大内部时间步长 $h$。对于在 $T=300\\,\\mathrm{K}$ 下包含氢等轻原子的系统，最高的振动频率和最快的碰撞动力学通常要求 $h \\le 2\\,\\mathrm{fs}$ 以实现稳定和准确的积分。$h=1\\,\\mathrm{fs}$ 的选择非常普遍且保守。$h=4\\,\\mathrm{fs}$ 的时间步长通常被认为过大，并且可能导致快力积分的数值不稳定或灾难性的精度损失，除非像与氢的共价键这样非常刚性的自由度被约束（这一点并未说明）。\n\n**2. 外部时间步长 ($H$):**\n与外部步长相关的误差源于假设 $\\mathbf{F}_{\\mathrm{lr}}$ 在时间间隔 $H$ 内是恒定的。只有当 $\\mathbf{F}_{\\mathrm{lr}}$ 变化缓慢时，这个近似才有效。$\\mathbf{F}_{\\mathrm{lr}}$ 的空间变化被 PME 算法平滑；其特征长度尺度是网格间距 $a_g = 0.125\\,\\mathrm{nm}$。粒子穿过此网格时所经历的力场会发生变化。\n力的变化率取决于粒子的速度。为了保持低误差，在一个外部时间步长 $H$ 内，粒子移动的距离不应是特征长度尺度 $a_g$ 的一个很大比例。\n我们来量化一下。粒子在时间 $H$ 内的最大位移是 $\\Delta x_{\\max} = v_{\\max} H$。维持精度的经验法则是，该位移应为网格间距的一小部分，例如 $\\Delta x_{\\max} \\lesssim a_g/4$。\n使用给定值：\n$$\nH \\lesssim \\frac{a_g/4}{v_{\\max}} = \\frac{0.125\\,\\mathrm{nm} / 4}{3.0\\,\\mathrm{nm/ps}} = \\frac{0.03125\\,\\mathrm{nm}}{3.0\\,\\mathrm{nm/ps}} \\approx 0.0104\\,\\mathrm{ps} = 10.4\\,\\mathrm{fs}\n$$\n这个计算表明，外部时间步长 $H$ 不应显著超过约 $10\\,\\mathrm{fs}$。目标是在此精度约束下，使 $m = H/h$ 尽可能大，以减少昂贵的 FFT 计算次数。\n\n### 逐项分析\n\n**A. 选择 $h = 1\\,\\mathrm{fs}$，并每 $m=8$ 个内部步长更新一次 $\\mathbf{F}_{\\mathrm{lr}}$（因此 $H = 8\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$ 插值，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。**\n- 内部步长 $h = 1\\,\\mathrm{fs}$：对于快速变化的短程力，这是一个安全且合适的选择。\n- 外部步长 $H = 8\\,\\mathrm{fs}$：这个值与我们的估计一致。$H=8\\,\\mathrm{fs}  10.4\\,\\mathrm{fs}$。最大位移为 $\\Delta x_{\\max} = (3.0\\,\\mathrm{nm/ps}) \\times (0.008\\,\\mathrm{ps}) = 0.024\\,\\mathrm{nm}$。这对应的位移为 $0.024\\,\\mathrm{nm} / 0.125\\,\\mathrm{nm} \\approx 0.19$，小于网格间距的五分之一。在此时间间隔内假设 $\\mathbf{F}_{\\mathrm{lr}}$ 为常数是合理的。\n- 效率：与每步更新相比，FFT 计算次数减少了 $m=8$ 倍。这带来了显著的性能提升。\n- 平衡性：该方案提供了良好的平衡。内部步长是准确的，外部步长足够大以获得显著的效率提升，但又足够小以保持长程力的良好精度。\n- 结论：**正确**。\n\n**B. 选择 $h = 1\\,\\mathrm{fs}$，并每步都更新 $\\mathbf{F}_{\\mathrm{lr}}$（$m=1$，因此 $H = 1\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。**\n- 内部步长 $h = 1\\,\\mathrm{fs}$：这是一个安全的选择。\n- 外部步长 $H = 1\\,\\mathrm{fs}$：由于 $m=1$，$\\mathbf{F}_{\\mathrm{lr}}$ 与 $\\mathbf{F}_{\\mathrm{sr}}$ 在每个时间步都一起更新。这不是一个 MTS 方案；它等同于一个 $1\\,\\mathrm{fs}$ 步长的标准速度 Verlet 积分器，其中所有力在每一步都进行计算。\n- 效率：该方案没有通过多时间步带来任何计算节省。它未能实现“尽可能减少单位物理时间内的平均 FFT 次数”的目标。\n- 平衡性：该方案准确但效率极低。它不代表一种“恰当的”平衡。\n- 结论：**不正确**。\n\n**C. 选择 $h = 1\\,\\mathrm{fs}$，并每 $m=20$ 个内部步长更新一次 $\\mathbf{F}_{\\mathrm{lr}}$（因此 $H = 20\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。**\n- 内部步长 $h = 1\\,\\mathrm{fs}$：这是一个安全的选择。\n- 外部步长 $H = 20\\,\\mathrm{fs}$：这个值远大于我们约 $10\\,\\mathrm{fs}$ 的估计值。最大位移为 $\\Delta x_{\\max} = (3.0\\,\\mathrm{nm/ps}) \\times (0.020\\,\\mathrm{ps}) = 0.06\\,\\mathrm{nm}$。这对应的位移为 $0.06\\,\\mathrm{nm} / 0.125\\,\\mathrm{nm} \\approx 0.48$，几乎是网格间距的一半。在如此大的位移上，平滑但非恒定的 PME 力场将发生显著变化。将其固定 $20\\,\\mathrm{fs}$ 会引入很大的误差，很可能主导总积分误差，并可能导致能量守恒性差。\n- 效率：该方案在 FFT 成本上提供了极好的降低（减少了 $20$ 倍）。\n- 平衡性：该方案过分强调效率，而严重牺牲了准确性。它不代表一种平衡的方法。\n- 结论：**不正确**。\n\n**D. 为 $\\mathbf{F}_{\\mathrm{sr}}$ 选择 $h = 4\\,\\mathrm{fs}$，并每步都更新 $\\mathbf{F}_{\\mathrm{lr}}$（$m=1$，因此 $H = 4\\,\\mathrm{fs}$），在 $24^3$ 网格上使用 PME 和 $p=4$，同时保持 $r_c = 1.0\\,\\mathrm{nm}$。**\n- 内部步长 $h = 4\\,\\mathrm{fs}$：如前所述，对于在 $T=300\\,\\mathrm{K}$ 下的一个典型的全原子系统，这个时间步长对于积分刚性的短程相互作用来说太大了。这极有可能导致数值不稳定和模拟崩溃。\n- 外部步长 $H = 4\\,\\mathrm{fs}$：由于 $m=1$，这不是一个 MTS 方案。所有力都每 $4\\,\\mathrm{fs}$ 更新一次。\n- 平衡性：由于不稳定的内部时间步长，该方案存在根本性缺陷。积分 $\\mathbf{F}_{\\mathrm{sr}}$ 产生的误差将是巨大的，使得整个模拟不可靠，无论 $\\mathbf{F}_{\\mathrm{lr}}$ 如何处理。\n- 结论：**不正确**。\n\n### 结论\n基于在 PME 和 r-RESPA 背景下积分器稳定性和准确性的基本原理，选项 A 提出了在物理上和计算上最合理的方案。它为快力使用了一个安全的内部时间步长，同时外部时间步长既足够大以产生显著的性能增益，又足够保守，通过尊重长程 PME 力场的特征长度尺度来保持准确性。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}