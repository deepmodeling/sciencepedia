{
    "hands_on_practices": [
        {
            "introduction": "现代电子结构计算的核心是计算效率，而克莱因曼-拜兰德（Kleinman-Bylander, KB）分离形式是实现这一效率的关键技术。它将计算成本较高的半局域赝势算符转化为一个可分离的形式，极大地加速了计算过程。这项实践将指导你从基本原理出发，为给定的半局域赝势构建其KB形式，通过推导和实现径向投影函数和耦合强度，最终计算非局域能量的贡献 。这个练习能让你深入理解密度泛函理论（DFT）计算程序内部，赝势是如何被高效处理的。",
            "id": "3836291",
            "problem": "您的任务是在多尺度材料模拟的背景下，使用 Kleinman-Bylander (KB) 表示法，为球对称半局域算符实现非局域赝势的可分离形式。请严格遵循适用于原子单位下量子力学的基本原理，推导出所需的计算流程，然后将其实现为一个完整的程序。\n\n考虑作用于三维波函数上的半局域赝势算符。对于中心势，角动量分解会产生由轨道角动量量子数 $l$ 标记的通道，每个通道具有径向部分 $V_l(r)$ 和由球谐函数 $Y_{lm}(\\theta,\\phi)$ 投影的角向部分。Kleinman-Bylander (KB) 可分离形式引入了一个投影算符，该投影算符由每个通道选定的参考赝径向函数导出，并选择一个耦合强度，使得该可分离算符在参考态上的作用能够重现半局域算符的作用。\n\n使用以下基本基底和构造：\n- 三维内积由体积分定义，其测度为 $d^3\\mathbf{r} = r^2 dr \\, d\\Omega$，其中 $d\\Omega$ 是立体角元。\n- 球谐函数 $Y_{lm}(\\theta,\\phi)$ 在单位球面上是标准正交的，满足 $\\int d\\Omega \\, Y_{lm}(\\theta,\\phi) Y_{l'm'}^{\\ast}(\\theta,\\phi) = \\delta_{ll'} \\delta_{mm'}$。\n- 径向函数相对于测度 $r^2 dr$ 是归一化的，即一个归一化的径向函数 $R(r)$ 满足 $\\int_0^{\\infty} dr \\, r^2 \\, |R(r)|^2 = 1$。\n- 每个通道 $l$ 的参考赝径向函数形式为 $R^{\\mathrm{ref}}_l(r) = \\mathcal{N}_l \\, r^l \\, e^{-\\alpha_l r}$，需要在径向测度下进行归一化。测试态径向函数具有相同的形式 $R^{\\psi}_L(r) = \\mathcal{N}_{\\psi} \\, r^{L} \\, e^{-\\alpha_{\\psi} r}$，测试态角向函数为 $Y_{L0}(\\theta,\\phi)$。所有角度均以弧度为单位。归一化常数 $\\mathcal{N}$ 必须从归一化条件推导得出。\n- 每个半局域通道的径向势由 $V_l(r) = V_{0,l} \\, \\exp\\left[-(r/r_{c,l})^2\\right]$ 给出，它是球对称的，并且仅依赖于 $r$。\n\n基于以上信息，构造每个通道的 KB 投影算符径向函数，\n- 径向投影算符由该通道的半局域势和参考赝径向函数构造。推导出与 KB 可分离算符表示和球对称性相符的适当形式。\n\n定义每个通道的 KB 耦合强度 $D_l$，使得可分离算符能够重现半局域算符在该通道中选定的参考赝态上的作用。利用球谐函数的标准正交性和径向函数的归一化，推导测试态 $\\psi$ 的非局域能量贡献表达式，\n- 非局域能量贡献 $\\langle \\psi | V_{\\mathrm{nl}} | \\psi \\rangle$ 应表示为测试态与 KB 投影算符之间的重叠以及耦合强度的函数。使用球谐函数标准正交性所蕴含的角动量选择定则。\n\n数值实现要求：\n- 使用原子单位：长度以玻尔半径 $a_0$ 为单位，能量以哈特里（Hartree）为单位。最终能量以哈特里表示，并四舍五入到六位小数。\n- 在步长为 $\\Delta r$ 的均匀网格 $r \\in [0, R_{\\max}]$ 上离散化径向坐标。使用数值积分来近似所有径向积分，并使用正确的 $r^2$ 测度。\n- 您的程序必须实现参考态和测试态的归一化径向函数的构造，为每个半局域通道组装径向投影算符，计算耦合强度，并最终评估每个测试用例的非局域能量。\n\n测试套件：\n提供一个程序，为以下四个测试用例计算 $\\langle \\psi | V_{\\mathrm{nl}} | \\psi \\rangle$。在每个用例中，所有角度均以弧度为单位，长度以玻尔半径 $a_0$ 为单位，能量以哈特里为单位。\n\n- 用例 1 (正常路径，$s$ 通道):\n  - 网格: $R_{\\max} = 20.0$, $\\Delta r = 0.001$。\n  - 通道: 单个 $l=0$ 通道，其中 $V_{0,0} = -2.0$, $r_{c,0} = 1.2$, $\\alpha_0 = 1.0$。\n  - 测试态: $L=0$, $\\alpha_{\\psi} = 0.8$。\n- 用例 2 (正常路径，$p$ 通道):\n  - 网格: $R_{\\max} = 20.0$, $\\Delta r = 0.001$。\n  - 通道: 单个 $l=1$ 通道，其中 $V_{0,1} = 3.0$, $r_{c,1} = 1.0$, $\\alpha_1 = 1.2$。\n  - 测试态: $L=1$, $\\alpha_{\\psi} = 1.0$。\n- 用例 3 (边界情况，弱势):\n  - 网格: $R_{\\max} = 20.0$, $\\Delta r = 0.001$。\n  - 通道: 单个 $l=1$ 通道，其中 $V_{0,1} = 1.0 \\times 10^{-4}$, $r_{c,1} = 1.0$, $\\alpha_1 = 1.2$。\n  - 测试态: $L=1$, $\\alpha_{\\psi} = 0.8$。\n- 用例 4 (边缘情况，角动量不匹配):\n  - 网格: $R_{\\max} = 20.0$, $\\Delta r = 0.001$。\n  - 通道: 两个通道：\n    - $l=0$ 通道，其中 $V_{0,0} = -1.0$, $r_{c,0} = 1.5$, $\\alpha_0 = 1.0$,\n    - $l=1$ 通道，其中 $V_{0,1} = 2.0$, $r_{c,1} = 1.2$, $\\alpha_1 = 1.1$。\n  - 测试态: $L=2$, $\\alpha_{\\psi} = 1.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表条目必须是四个用例的非局域能量，以哈特里为单位，四舍五入到六位小数，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$。",
            "solution": "该问题要求为球对称体系实现非局域赝势的 Kleinman-Bylander (KB) 可分离形式。解决方案涉及从第一性原理推导必要的表达式，然后构建一个数值程序来评估几个测试用例的非局域能量贡献。所有数学实体均按要求使用 LaTeX 渲染。\n\n**1. 理论公式**\n\n赝势的非局域部分，以其半局域形式，作用于特定角动量通道内的波函数 $|\\psi\\rangle$。半局域算符 $\\hat{V}_{\\mathrm{sl}}$ 由下式给出：\n$$ \\hat{V}_{\\mathrm{sl}} = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} |Y_{lm}\\rangle V_l(r) \\langle Y_{lm}| $$\n其中 $|Y_{lm}\\rangle \\langle Y_{lm}|$ 是到角动量通道 $(l,m)$ 上的投影算符，$V_l(r)$ 是该通道的径向势。问题给出了函数形式 $V_l(r) = V_{0,l} \\exp\\left[-(r/r_{c,l})^2\\right]$。内积使用测度 $d^3\\mathbf{r} = r^2 dr \\, d\\Omega$ 定义。\n\nKleinman-Bylander (KB) 方案将此算符替换为一个计算上高效的可分离算符：\n$$ \\hat{V}_{\\mathrm{KB}} = \\sum_{l,m} |\\chi_{lm}\\rangle D_l \\langle \\chi_{lm}| $$\n该形式是使用一组归一化的参考赝波函数构建的，每个通道 $l$ 一个，由 $|\\phi^{\\mathrm{ref}}_{lm}\\rangle = R^{\\mathrm{ref}}_l(r) Y_{lm}(\\theta, \\phi)$ 给出。\n\n**1.1. 径向函数的归一化**\n\n参考态的径向函数 $R^{\\mathrm{ref}}_l(r)$ 和测试态的径向函数 $R^{\\psi}_L(r)$ 都具有形式 $R(r) = \\mathcal{N} r^k e^{-\\alpha r}$。归一化要求 $\\int_0^{\\infty} dr \\, r^2 \\, |R(r)|^2 = 1$。\n$$ \\int_0^{\\infty} dr \\, r^2 \\left( \\mathcal{N} r^k e^{-\\alpha r} \\right)^2 = \\mathcal{N}^2 \\int_0^{\\infty} dr \\, r^{2k+2} e^{-2\\alpha r} = 1 $$\n这是一个与 Gamma 函数相关的标准积分，$\\int_0^{\\infty} x^n e^{-ax} dx = n!/a^{n+1}$。通过设置 $n=2k+2$ 和 $a=2\\alpha$，我们得到：\n$$ \\mathcal{N}^2 \\frac{(2k+2)!}{(2\\alpha)^{2k+3}} = 1 $$\n这给出了解析归一化常数：\n$$ \\mathcal{N}_k = \\sqrt{\\frac{(2\\alpha)^{2k+3}}{(2k+2)!}} $$\n对于角动量为 $l$ 的参考态，我们使用 $k=l$ 和 $\\alpha=\\alpha_l$。对于角动量为 $L$ 的测试态，我们使用 $k=L$ 和 $\\alpha=\\alpha_{\\psi}$。\n\n**1.2. KB 投影算符和耦合强度**\n\nKB 投影函数 $|\\chi_{lm}\\rangle$ 由半局域势对参考态的作用定义：\n$$ |\\chi_{lm}\\rangle = \\hat{V}_{\\mathrm{sl}} |\\phi^{\\mathrm{ref}}_{lm}\\rangle = V_l(r) |\\phi^{\\mathrm{ref}}_{lm}\\rangle = V_l(r) R^{\\mathrm{ref}}_l(r) Y_{lm}(\\theta, \\phi) $$\n这表明投影函数也是可分离的，其径向部分为 $\\chi_l(r) = V_l(r) R^{\\mathrm{ref}}_l(r)$，角向部分与参考态相同，为 $Y_{lm}(\\theta, \\phi)$。\n\n耦合强度 $D_l$ 由以下条件确定：KB 算符必须重现半局域算符在参考态自身上的作用，即 $\\hat{V}_{\\mathrm{KB}}|\\phi^{\\mathrm{ref}}_{lm}\\rangle = \\hat{V}_{\\mathrm{sl}}|\\phi^{\\mathrm{ref}}_{lm}\\rangle$。这意味着：\n$$ D_l \\langle \\chi_{lm} | \\phi^{\\mathrm{ref}}_{lm} \\rangle = 1 $$\n从而得到：\n$$ D_l = \\frac{1}{\\langle \\phi^{\\mathrm{ref}}_{lm} | \\hat{V}_{\\mathrm{sl}} | \\phi^{\\mathrm{ref}}_{lm} \\rangle} $$\n分母是半局域势相对于参考态的期望值。由于 $V_l(r)$ 的球对称性和 $Y_{lm}$ 的标准正交性，该值与 $m$ 无关：\n$$ \\langle \\phi^{\\mathrm{ref}}_{lm} | \\hat{V}_{\\mathrm{sl}} | \\phi^{\\mathrm{ref}}_{lm} \\rangle = \\int_0^{\\infty} dr \\, r^2 \\, V_l(r) \\left[R^{\\mathrm{ref}}_l(r)\\right]^2 $$\n\n**1.3. 非局域能量贡献**\n\n测试态 $|\\psi\\rangle$ 的非局域能量是期望值 $E_{\\mathrm{nl}} = \\langle \\psi | \\hat{V}_{\\mathrm{KB}} | \\psi \\rangle$。\n$$ E_{\\mathrm{nl}} = \\langle \\psi | \\left( \\sum_{l,m} |\\chi_{lm}\\rangle D_l \\langle \\chi_{lm}| \\right) | \\psi \\rangle = \\sum_{l,m} D_l |\\langle \\chi_{lm} | \\psi \\rangle|^2 $$\n测试态由 $|\\psi\\rangle = R^{\\psi}_L(r) Y_{L0}(\\theta, \\phi)$ 给出。我们计算重叠积分 $\\langle \\chi_{lm} | \\psi \\rangle$：\n$$ \\langle \\chi_{lm} | \\psi \\rangle = \\int d^3\\mathbf{r} \\, \\left[\\chi_l(r) Y_{lm}(\\theta, \\phi)\\right]^* \\left[R^{\\psi}_L(r) Y_{L0}(\\theta, \\phi)\\right] $$\n使用体元 $d^3\\mathbf{r} = r^2 dr \\, d\\Omega$ 并分离积分：\n$$ \\langle \\chi_{lm} | \\psi \\rangle = \\left( \\int_0^{\\infty} dr \\, r^2 \\, \\chi_l(r) R^{\\psi}_L(r) \\right) \\left( \\int d\\Omega \\, Y_{lm}^*(\\Omega) Y_{L0}(\\Omega) \\right) $$\n由于球谐函数的标准正交性，角向积分的结果为 $\\delta_{lL} \\delta_{m0}$。这是一个关键的选择定则：只有当赝势中存在一个通道 $l$ 与测试态的角动量 $L$ 相匹配时，才会有能量贡献。此外，由于测试态的磁量子数 $m_{\\psi}=0$，只有投影算符求和中 $m=0$ 的分量有贡献。\n\n对 $l,m$ 的求和会塌缩。如果在赝势定义中存在 $l=L$ 的通道，其贡献为：\n$$ E_{\\mathrm{nl}}(L) = D_L |\\langle \\chi_{L0} | \\psi \\rangle|^2 $$\n代入 $D_L$ 和 $\\langle \\chi_{L0} | \\psi \\rangle$ 的表达式，我们得到非局域能量的最终公式：\n$$ E_{\\mathrm{nl}} = \\frac{\\left( \\int_0^\\infty dr \\, r^2 \\, V_L(r) R^{\\mathrm{ref}}_L(r) R^{\\psi}_L(r) \\right)^2}{\\int_0^\\infty dr \\, r^2 \\, V_L(r) \\left[R^{\\mathrm{ref}}_L(r)\\right]^2} $$\n如果没有定义 $l=L$ 的通道，角动量选择定则确保 $E_{\\mathrm{nl}} = 0$。\n\n**2. 计算流程**\n\n实现直接遵循推导出的公式，使用数值方法在离散网格上评估积分。\n\n1.  **网格离散化**：定义一个从 $r=0$ 到 $r=R_{\\max}$，间距为 $\\Delta r$ 的均匀径向网格 $r_i$。所有径向函数都表示为它们在该网格上的值的数组。\n\n2.  **数值积分**：所有形式为 $\\int_0^{R_{\\max}} dr \\, r^2 f(r)$ 的函数 $f(r)$ 的径向积分都使用梯形法则进行近似，对于足够精细的网格，该方法是数值稳定且准确的。这可以通过 `numpy` 中的 `numpy.trapz(f * r**2, r)` 高效实现。\n\n3.  **径向函数归一化**：为了在归一化和后续的能量积分之间保持最大的一致性，径向函数在离散网格上进行数值归一化。对于一个未归一化的函数 $u(r) = r^k e^{-\\alpha r}$，归一化常数 $\\mathcal{N}$ 计算为 $\\mathcal{N} = 1/\\sqrt{\\int_0^{R_{\\max}} dr \\, r^2 [u(r)]^2}$，其中积分是数值计算的。归一化后的函数为 $R(r) = \\mathcal{N} u(r)$。\n\n4.  **能量计算算法**：对于每个由其网格、通道和测试态参数定义的测试用例：\n    a. 设置径向网格 $r$。\n    b. 初始化总非局域能量 $E_{\\mathrm{nl}} = 0$。\n    c. 使用其参数 $L$ 和 $\\alpha_{\\psi}$ 生成归一化的测试态径向函数 $R^{\\psi}_L(r)$。\n    d. 遍历每个定义的赝势通道 $(l, V_{0,l}, r_{c,l}, \\alpha_l)$。\n    e. **应用选择定则**：如果 $l \\neq L$，重叠积分为零，因此贡献为 $0$。算法继续处理下一个通道。\n    f. **如果 $l = L$**：\n        i. 为此通道生成归一化的参考径向函数 $R^{\\mathrm{ref}}_l(r)$。\n        ii. 生成径向势 $V_l(r)$。\n        iii. 计算分子积分：$I_{\\mathrm{num}} = \\int dr \\, r^2 V_l(r) R^{\\mathrm{ref}}_l(r) R^{\\psi}_L(r)$。\n        iv. 计算分母积分：$I_{\\mathrm{den}} = \\int dr \\, r^2 V_l(r) [R^{\\mathrm{ref}}_l(r)]^2$。\n        v. 如果 $|I_{\\mathrm{den}}|$ 不可忽略，则计算该通道的能量贡献 $E_l = I_{\\mathrm{num}}^2 / I_{\\mathrm{den}}$ 并将其加到 $E_{\\mathrm{nl}}$ 上。\n    g. 测试用例的最终结果是 $E_{\\mathrm{nl}}$ 的累积值。用例 4 是对选择定则的一个特定测试，因为测试态的角动量 $L=2$ 与任何可用通道（$l=0, 1$）都不匹配，正确地得出能量为 $0$。\n\n此流程在提供的 Python 代码中实现，该代码为每个指定的测试用例计算非局域能量。",
            "answer": "```python\nimport numpy as np\n\n# Although scipy is permitted, it is not strictly necessary for this implementation.\n# np.trapz and np.power are sufficient.\n\ndef get_normalized_radial_function(k, alpha, r_grid):\n    \"\"\"\n    Computes a normalized radial function of the form N * r^k * exp(-alpha*r).\n\n    The function is normalized numerically on the given grid using the trapezoidal rule,\n    such that integral(dr * r^2 * |R(r)|^2) = 1.\n\n    Args:\n        k (int): The power of r (angular momentum quantum number).\n        alpha (float): The exponent in the exponential decay.\n        r_grid (np.ndarray): The radial grid points.\n\n    Returns:\n        np.ndarray: The array of normalized radial function values on the grid.\n    \"\"\"\n    # Using np.power handles the case of 0**0 = 1 correctly.\n    unnormalized_wf = np.power(r_grid, k) * np.exp(-alpha * r_grid)\n\n    # The integrand for the normalization integral includes the r^2 measure.\n    integrand_norm = unnormalized_wf**2 * r_grid**2\n    \n    # Integrate using the trapezoidal rule.\n    norm_sq = np.trapz(integrand_norm, r_grid)\n    \n    # Avoid division by zero if the norm is zero.\n    if norm_sq  1e-30:\n        return np.zeros_like(r_grid)\n\n    normalization_constant = 1.0 / np.sqrt(norm_sq)\n    \n    return normalization_constant * unnormalized_wf\n\ndef calculate_nonlocal_energy(R_max, dr, channels, L, alpha_psi):\n    \"\"\"\n    Calculates the Kleinman-Bylander nonlocal energy contribution.\n\n    Args:\n        R_max (float): The maximum radius for the radial grid.\n        dr (float): The step size for the radial grid.\n        channels (list of tuples): A list of pseudopotential channels.\n                                   Each tuple is (l, V0, rc, alpha_l).\n        L (int): The angular momentum of the test state.\n        alpha_psi (float): The exponent for the test state.\n\n    Returns:\n        float: The calculated nonlocal energy in Hartrees.\n    \"\"\"\n    # 1. Set up the radial grid.\n    r_grid = np.arange(0, R_max + dr, dr)\n    \n    total_energy = 0.0\n    \n    # 2. Generate the normalized test state radial function.\n    R_psi = get_normalized_radial_function(L, alpha_psi, r_grid)\n    \n    # 3. Loop over the provided pseudopotential channels.\n    for channel in channels:\n        l, V0, rc, alpha_l = channel\n        \n        # 4. Apply the angular momentum selection rule.\n        #    A contribution exists only if the channel's 'l' matches the test state's 'L'.\n        if l != L:\n            continue\n            \n        # 5. If l == L, calculate the energy contribution.\n        #    Generate the normalized reference radial function for the channel.\n        R_ref_l = get_normalized_radial_function(l, alpha_l, r_grid)\n        \n        # 6. Generate the channel potential V_l(r).\n        #    Handle potential division by zero for rc, though not in test cases.\n        if rc == 0:\n            V_l = np.zeros_like(r_grid) # Or handle as an error\n        else:\n            V_l = V0 * np.exp(-(r_grid / rc)**2)\n        \n        # 7. Calculate the numerator and denominator integrals for the energy expression.\n        #    The expression is E_nl = (Integral_num)^2 / Integral_den.\n        \n        # Numerator integral:"
        },
        {
            "introduction": "尽管赝势方法功能强大，但其构建过程必须非常谨慎，否则可能引入被称为“鬼态”（ghost states）的严重问题。这些是由于不恰当的非局域投影算符过于吸引而产生的非物理、深度束缚的电子态，会导致计算收敛失败或得出错误的物理结论。本练习通过一个简化的以为模型，让你亲手构建一个包含有缺陷的有效核心势（ECP）的哈密顿量，并诊断鬼态的存在 。这提供了一个关于赝势验证和质量控制的宝贵实践课，突显了在科学研究中批判性地评估计算工具的重要性。",
            "id": "2454657",
            "problem": "考虑一个单电子模型，该模型旨在说明一个不当构建的有效核势 (ECP) 如何能够产生称为“鬼态”的赝束缚解。在原子单位制下进行计算，其中电子质量、基本电荷、约化普朗克常数和库仑常数均为 $1$。在此模型中，电子在坐标为 $x \\in [-L,L]$ 的一维线段上运动，并满足狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$。不含时薛定谔方程为\n$$\n\\hat{H}\\,\\psi(x) \\;=\\; E\\,\\psi(x),\n$$\n哈密顿量为\n$$\n\\hat{H} \\;=\\; -\\frac{1}{2}\\frac{d^2}{dx^2} \\;+\\; V_{\\mathrm{loc}}(x) \\;+\\; \\hat{V}_{\\mathrm{nl}}.\n$$\n局域部分模拟了来自有效核的软库仑吸引和一个旨在模拟核态排斥的短程排斥核芯凸起：\n$$\nV_{\\mathrm{loc}}(x) \\;=\\; -\\frac{Z_{\\mathrm{eff}}}{\\sqrt{x^2+a^2}} \\;+\\; B\\,\\exp\\!\\left(-\\frac{x^2}{r_c^2}\\right),\n$$\n其中 $Z_{\\mathrm{eff}}$ 是有效核电荷，$a$ 是软化长度，$B$ 是凸起振幅，$r_c$ 是凸起范围。非局域ECP分量采用一个秩为1的投影算符\n$$\n\\hat{V}_{\\mathrm{nl}} \\;=\\; W\\,|g\\rangle\\langle g|,\n$$\n其中 $W$ 是一个实标量强度，而 $|g\\rangle$ 是一个由归一化高斯函数定义的局域“投影”函数\n$$\ng(x) \\;=\\; \\frac{1}{(\\pi\\,\\sigma^2)^{1/4}}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right),\n$$\n宽度参数为 $\\sigma0$，归一化条件为 $\\int_{-\\infty}^{\\infty} |g(x)|^2\\,dx = 1$。算符 $\\hat{V}_{\\mathrm{nl}}$ 作用于波函数 $\\psi(x)$ 的方式为\n$$\n(\\hat{V}_{\\mathrm{nl}}\\psi)(x) \\;=\\; W\\,g(x)\\int_{-L}^{L} g(y)\\,\\psi(y)\\,dy.\n$$\n\n您必须计算基态能量 $E_0$ 并为几组参数集诊断鬼态是否存在。当且仅当以下两个条件同时成立时，定义为存在“鬼态”：\n- 计算出的基态能量满足 $E_0  E_{\\mathrm{ghost}}$，其中 $E_{\\mathrm{ghost}} = -2.0$ (哈特里)。\n- 归一化的基态本征函数 $\\psi_0(x)$ 与投影函数 $g(x)$ 之间的重叠平方，计算公式为\n$$\n\\mathcal{O} \\;=\\; \\left|\\int_{-L}^{L} g(x)\\,\\psi_0(x)\\,dx\\right|^2,\n$$\n满足 $\\mathcal{O} > \\mathcal{O}_{\\mathrm{thr}}$，其中 $\\mathcal{O}_{\\mathrm{thr}} = 0.8$。\n\n所有积分都应在有限区间 $[-L,L]$ 上计算。使用以下固定常数：\n- 域半长 $L = 10$ (玻尔)。\n- 网格点数 $N = 1201$ (在端点使用狄利克雷边界条件)。\n- 有效核电荷 $Z_{\\mathrm{eff}} = 1.0$ (无量纲)。\n- 软化长度 $a = 0.8$ (玻尔)。\n- 核芯凸起振幅 $B = 5.0$ (哈特里)。\n- 核芯凸起范围 $r_c = 0.4$ (玻尔)。\n- 鬼态能量阈值 $E_{\\mathrm{ghost}} = -2.0$ (哈特里)。\n- 重叠阈值 $\\mathcal{O}_{\\mathrm{thr}} = 0.8$ (无量纲)。\n\n在所述域上，使用上述 $V_{\\mathrm{loc}}(x)$ 和 $\\hat{V}_{\\mathrm{nl}}$ (其中 $g(x)$ 在 $[-L,L]$ 上重新归一化，使得 $\\int_{-L}^{L} |g(x)|^2\\,dx = 1$) 构建哈密顿量，并计算最低本征值 $E_0$ 和对应的归一化本征函数 $\\psi_0(x)$ (相对于积分 $\\int_{-L}^{L} |\\psi_0(x)|^2\\,dx = 1$ 进行归一化)。所有能量均以哈特里表示。不要近似角度；不涉及任何角度量。\n\n测试套件。为实现覆盖，请评估以下四种情况，每种情况由数对 $(W,\\sigma)$ 指定：\n- 情况 A (标称吸引非局域): $(W,\\sigma) = (-1.0,\\,0.5)$。\n- 情况 B (强吸引非局域；可能出现鬼态): $(W,\\sigma) = (-30.0,\\,0.5)$。\n- 情况 C (极强且窄的投影算符；极端鬼态): $(W,\\sigma) = (-80.0,\\,0.2)$。\n- 情况 D (无非局域项): $(W,\\sigma) = (0.0,\\,0.5)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，按顺序聚合四个案例的结果，格式如下\n$$\n[\\;E_0^{\\mathrm{A}},\\;\\mathrm{ghost}^{\\mathrm{A}},\\;E_0^{\\mathrm{B}},\\;\\mathrm{ghost}^{\\mathrm{B}},\\;E_0^{\\mathrm{C}},\\;\\mathrm{ghost}^{\\mathrm{C}},\\;E_0^{\\mathrm{D}},\\;\\mathrm{ghost}^{\\mathrm{D}}\\;].\n$$\n所有能量必须以哈特里表示并四舍五入到六位小数。布尔值必须是无引号的字面量。整个列表必须打印在单行上。",
            "solution": "所提出的问题要求构建一个基于第一性原理的模型哈密顿量，该哈密顿量包含一个已知能产生鬼态的非局域有效核势 (ECP) 项，然后从第一性原理诊断这些态。其基本定律是不含时薛定谔方程\n$$\n\\hat{H}\\psi(x) \\;=\\; E\\psi(x),\n$$\n在原子单位制下，其动能算符为 $-\\frac{1}{2}\\frac{d^2}{dx^2}$。局域离子场通过一个软库仑势 $-\\frac{Z_{\\mathrm{eff}}}{\\sqrt{x^2+a^2}}$ （在 $x=0$ 处有限且模拟长程吸引）和一个排斥性高斯凸起 $B\\exp\\!\\left(-\\frac{x^2}{r_c^2}\\right)$ （抑制类核芯振幅）来建模。非局域ECP是一个秩为1的投影算符，\n$$\n\\hat{V}_{\\mathrm{nl}} \\;=\\; W\\,|g\\rangle\\langle g|,\n$$\n其中 $W0$ 会在由 $|g\\rangle$ 张成的子空间中产生一个集中的吸引相互作用。如果 $|W|$ 过大或 $g(x)$ 过于局域（$\\sigma$ 小），能谱中会获得一个赝深束缚态，其本征函数与 $g(x)$ 高度对齐；这就是鬼态。\n\n我们在区间 $[-L,L]$ 上的一个具有 $N$ 个点的均匀网格上离散化该问题，并施加狄利克雷边界条件。设网格间距为\n$$\nh \\;=\\; \\frac{2L}{N-1},\n$$\n并在 $N-2$ 个内部点上进行计算，以便动能算符由标准的二阶中心有限差分拉普拉斯算子表示。作用于内部未知量的动能矩阵的主对角线元素为\n$$\n\\frac{1}{h^2}\n$$\n第一副对角线元素为\n$$\n-\\frac{1}{2h^2},\n$$\n这源于将 $-\\frac{1}{2}\\frac{d^2}{dx^2}$ 应用于三点格式 $(\\psi_{i+1}-2\\psi_i+\\psi_{i-1})/h^2$。\n\n局域势是对角的，其元素为 $V_{\\mathrm{loc}}(x_i)$。非局域算符通过将连续作用\n$$\n(\\hat{V}_{\\mathrm{nl}}\\psi)(x) \\;=\\; W\\,g(x)\\int_{-L}^{L} g(y)\\psi(y)\\,dy\n$$\n用黎曼和\n$$\n(\\hat{V}_{\\mathrm{nl}}\\boldsymbol{\\psi})_i \\;\\approx\\; W\\,g_i \\left(h\\sum_j g_j \\psi_j\\right),\n$$\n来离散化实现，其中 $g_i=g(x_i)$ 是内部网格上的采样点。为确保该算符与连续定义匹配，$g(x)$ 在有限域上重新归一化，使得\n$$\nh\\sum_j g_j^2 \\;=\\; 1.\n$$\n根据此约定，离散的非局域算符具有秩-1形式\n$$\n\\mathbf{V}_{\\mathrm{nl}} \\;=\\; W\\,h\\,\\mathbf{g}\\,\\mathbf{g}^{\\mathsf{T}},\n$$\n其对向量的作用为 $(\\mathbf{V}_{\\mathrm{nl}}\\boldsymbol{\\psi}) = W\\,\\mathbf{g}\\,(h\\,\\mathbf{g}^{\\mathsf{T}}\\boldsymbol{\\psi})$。\n\n因此，作用于内部网格值的总哈密顿矩阵为\n$$\n\\mathbf{H} \\;=\\; \\mathbf{T} \\;+\\; \\mathrm{diag}\\!\\left(V_{\\mathrm{loc}}(x_i)\\right) \\;+\\; W\\,h\\,\\mathbf{g}\\,\\mathbf{g}^{\\mathsf{T}},\n$$\n它是实对称的。通过求解\n$$\n\\mathbf{H}\\,\\boldsymbol{\\psi}_0 \\;=\\; E_0\\,\\boldsymbol{\\psi}_0.\n$$\n来计算最低本征对 $(E_0,\\boldsymbol{\\psi}_0)$。\n为了评估鬼态判据，首先将 $\\boldsymbol{\\psi}_0$ 相对于连续内积归一化至单位 $L^2$ 范数：\n$$\n\\boldsymbol{\\psi}_0 \\;\\leftarrow\\; \\frac{\\boldsymbol{\\psi}_0}{\\sqrt{h\\sum_j \\psi_{0,j}^2}}.\n$$\n计算重叠\n$$\n\\mathcal{O} \\;=\\; \\left|h\\sum_j g_j \\psi_{0,j}\\right|^2.\n$$\n当 $E_0  E_{\\mathrm{ghost}}$（其中 $E_{\\mathrm{ghost}}=-2.0$）且 $\\mathcal{O} > \\mathcal{O}_{\\mathrm{thr}}$（其中 $\\mathcal{O}_{\\mathrm{thr}}=0.8$）时，宣告存在鬼态。\n\n物理诠释：对于适度负值的 $W$（情况 A），非局域吸引力轻微扰动了类价束缚态；$E_0$ 保持在软库仑势预期的浅束缚能附近，且 $\\mathcal{O}$ 不会过大。在强吸引情况（情况 B 和 C）下，投影算符会创造一个基本上等于 $g(x)$ 的人为的态，其能量 $E_0$ 被推到远低于物理合理值的水平，并且 $\\mathcal{O}\\approx 1$，从而满足鬼态判据。当 $W=0$ 时（情况 D），能谱仅由局域势决定；存在一个具有中等束缚能以及与 $g(x)$ 有较小到中等重叠的类价束缚态，不满足鬼态判据。\n\n数值输出：程序使用固定参数 $L=10$、$N=1201$、$Z_{\\mathrm{eff}}=1.0$、$a=0.8$、$B=5.0$、$r_c=0.4$ 构建网格和算符，然后评估四个 $(W,\\sigma)$ 对。对于每一种情况，它计算 $E_0$ 和鬼态诊断，将能量四舍五入到六位小数（哈特里），并以所需的聚合列表格式在单行上输出\n$$\n[\\;E_0^{\\mathrm{A}},\\;\\mathrm{ghost}^{\\mathrm{A}},\\;E_0^{\\mathrm{B}},\\;\\mathrm{ghost}^{\\mathrm{B}},\\;E_0^{\\mathrm{C}},\\;\\mathrm{ghost}^{\\mathrm{C}},\\;E_0^{\\mathrm{D}},\\;\\mathrm{ghost}^{\\mathrm{D}}\\;].\n$$\n这从第一性原理上展示了过强的吸引性非局域ECP项如何能诱导出一个对于价电子问题而言非物理的、虚假的、深受束缚且由投影函数主导的本征态，该本征态即构成“鬼态”。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import eigsh\nfrom math import sqrt, pi\n\ndef build_operators(L, N, Z_eff, a_soft, B_core, r_c, W, sigma):\n    \"\"\"\n    Build the components needed to apply the Hamiltonian H = T + V_loc + V_nl\n    on the interior grid points with Dirichlet boundaries at x = +-L.\n\n    Returns:\n        x (np.ndarray): interior grid points (size M = N-2)\n        h (float): grid spacing\n        T (scipy.sparse.csr_matrix): kinetic operator\n        Vloc (np.ndarray): local potential evaluated at interior points\n        g (np.ndarray): normalized projector samples on the grid (L2 norm on [-L,L] equals 1)\n        W (float): projector strength (returned for convenience)\n    \"\"\"\n    # Grid\n    h = 2.0 * L / (N - 1)\n    x_full = np.linspace(-L, L, N)\n    # Interior points (Dirichlet at boundaries)\n    x = x_full[1:-1]\n    M = x.size\n\n    # Kinetic operator (finite-difference, Dirichlet boundaries)\n    inv_h2 = 1.0 / (h * h)\n    main_diag = np.full(M, inv_h2)\n    off_diag = np.full(M - 1, -0.5 * inv_h2)\n    T = diags([off_diag, main_diag, off_diag], offsets=[-1, 0, 1], format='csr')\n\n    # Local potential: soft Coulomb + Gaussian core bump\n    V_soft = -Z_eff / np.sqrt(x * x + a_soft * a_soft)\n    V_core = B_core * np.exp(-(x / r_c) ** 2)\n    Vloc = V_soft + V_core\n\n    # Projector g(x): normalized Gaussian on [-L, L] with integral norm 1\n    g_unnorm = (1.0 / (pi * sigma * sigma)) ** 0.25 * np.exp(-0.5 * (x / sigma) ** 2)\n    # Normalize with respect to integral inner product on the discrete grid\n    norm_g = np.sqrt(h * np.dot(g_unnorm, g_unnorm))\n    if norm_g == 0.0:\n        # Should never happen, but guard against division by zero\n        g = np.zeros_like(g_unnorm)\n    else:\n        g = g_unnorm / norm_g\n\n    return x, h, T, Vloc, g, W\n\ndef apply_hamiltonian_factory(T, Vloc, g, W, h):\n    \"\"\"\n    Returns a function that applies H to a vector v:\n    H v = T v + Vloc * v + W * g * (h * g^T v)\n    \"\"\"\n    def H_mv(v):\n        # Kinetic term\n        Tv = T.dot(v)\n        # Local potential term\n        Vv = Vloc * v\n        # Nonlocal projector term: W * g * (h * g^T v)\n        proj_coeff = h * np.dot(g, v)\n        Vnl_v = W * g * proj_coeff\n        return Tv + Vv + Vnl_v\n    return H_mv\n\ndef ground_state_energy_and_ghost(L, N, Z_eff, a_soft, B_core, r_c, W, sigma,\n                                  E_ghost_thr=-2.0, overlap_thr=0.8):\n    \"\"\"\n    Compute ground-state energy and ghost-state diagnostic for given parameters.\n    \"\"\"\n    # Build operators\n    x, h, T, Vloc, g, W = build_operators(L, N, Z_eff, a_soft, B_core, r_c, W, sigma)\n    M = x.size\n\n    # Build a LinearOperator via function for efficient eigensolve\n    from scipy.sparse.linalg import LinearOperator\n    H_mv = apply_hamiltonian_factory(T, Vloc, g, W, h)\n    H = LinearOperator((M, M), matvec=H_mv, dtype=np.float64)\n\n    # Compute the smallest algebraic eigenvalue (ground state) and eigenvector\n    # Use eigsh with k=1 and which='SA' for smallest algebraic\n    E_vals, E_vecs = eigsh(H, k=1, which='SA', tol=1e-10, maxiter=5000)\n    E0 = float(E_vals[0])\n    psi0 = E_vecs[:, 0]\n\n    # Normalize psi0 with respect to integral inner product\n    norm_int = np.sqrt(h * np.dot(psi0, psi0))\n    if norm_int != 0.0:\n        psi0_int = psi0 / norm_int\n    else:\n        psi0_int = psi0.copy()\n\n    # Overlap with projector g\n    overlap = h * float(np.dot(g, psi0_int))\n    O_sq = overlap * overlap\n\n    # Ghost diagnostic\n    is_ghost = (E0  E_ghost_thr) and (O_sq > overlap_thr)\n\n    # Round energy to six decimals as requested\n    E0_rounded = round(E0, 6)\n\n    return E0_rounded, is_ghost\n\ndef solve():\n    # Fixed parameters (atomic units)\n    L = 10.0\n    N = 1201\n    Z_eff = 1.0\n    a_soft = 0.8\n    B_core = 5.0\n    r_c = 0.4\n\n    # Ghost criteria thresholds\n    E_ghost_thr = -2.0\n    overlap_thr = 0.8\n\n    # Test suite: (W, sigma)\n    test_cases = [\n        (-1.0, 0.5),   # Case A: nominal\n        (-30.0, 0.5),  # Case B: strong attractive nonlocal; likely ghost\n        (-80.0, 0.2),  # Case C: very strong and narrow; extreme ghost\n        (0.0, 0.5),    # Case D: no nonlocal term\n    ]\n\n    results = []\n    for W, sigma in test_cases:\n        E0, is_ghost = ground_state_energy_and_ghost(\n            L, N, Z_eff, a_soft, B_core, r_c, W, sigma,\n            E_ghost_thr=E_ghost_thr, overlap_thr=overlap_thr\n        )\n        results.append(E0)\n        results.append(is_ghost)\n\n    # Final print statement in the exact required format.\n    # Ensure booleans are printed as literals and floats as numbers.\n    out_str_elems = []\n    for val in results:\n        if isinstance(val, bool):\n            out_str_elems.append(\"True\" if val else \"False\")\n        else:\n            # Float formatting with 6 decimals\n            out_str_elems.append(f\"{val:.6f}\")\n    print(f\"[{','.join(out_str_elems)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "掌握了赝势的构建和验证之后，最后一步是在实际的模拟中使用它。在平面波计算中，一个至关重要的参数是动能截断能$E_{\\mathrm{cut}}$，它决定了计算的精度和成本。这项实践提供了一个在简化的硅晶胞模型中，使用赝势进行总能量和力收敛性测试的动手经验 。通过系统地改变$E_{\\mathrm{cut}}$并分析结果的收敛行为，你将学会如何确保从DFT模拟中获得的能量和力是可靠且精确的，这是进行任何严肃计算材料研究之前必须掌握的基本技能。",
            "id": "3836286",
            "problem": "考虑一个受密度泛函理论（DFT）启发的平面波表示法中，一个小的硅晶胞的简化周期性模型。完全在原子单位制下进行计算，其中约化普朗克常数为 $1$，电子质量为 $1$，基本电荷为 $1$。该晶胞是一个边长为 $L$ 的立方体，其中 $L = 10.26$（玻尔），包含两个原子，位置分别为 $\\mathbf{R}_1 = (0,0,0)$ 和 $\\mathbf{R}_2 = (L/4,L/4,L/4)$，这近似于金刚石结构的基矢。定义 $\\mathbf{d} = \\mathbf{R}_2 - \\mathbf{R}_1$，并令 $\\hat{\\mathbf{d}} = \\mathbf{d} / \\|\\mathbf{d}\\|$ 表示沿键合方向的单位向量。\n\n设每个原子的电子赝密度由倒易空间中宽度参数为 $\\sigma$ 的归一化高斯函数建模，局域的保范赝势由倒易空间中的平滑高斯形式因子建模。具体来说，使用\n$$\\tilde{\\rho}_{\\text{atom}}(\\mathbf{G}) = \\exp\\left(-\\frac{\\sigma^2 \\|\\mathbf{G}\\|^2}{2}\\right), \\quad \\tilde{V}(\\mathbf{G}) = V_0 \\exp\\left(-\\beta \\|\\mathbf{G}\\|^2\\right),$$\n其中 $\\sigma = 0.3$（玻尔），$V_0 = -0.5$（哈特里），以及 $\\beta = 0.01$（玻尔$^2$）。总的赝密度结构因子为\n$$\\tilde{\\rho}(\\mathbf{G}) = \\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})\\left(e^{-i \\mathbf{G}\\cdot \\mathbf{R}_1} + e^{-i \\mathbf{G}\\cdot \\mathbf{R}_2}\\right)。$$\n\n倒易晶格矢量为 $\\mathbf{G} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$，其中整数 $n_x, n_y, n_z \\in \\mathbb{Z}$。引入平面波动能截断值 $E_{\\mathrm{cut}}$（哈特里），并在倒易空间中定义相应的模长截断值 $G_{\\mathrm{cut}} = \\sqrt{2 E_{\\mathrm{cut}}}$。下面的所有求和都遍历满足 $0  \\|\\mathbf{G}\\| \\le G_{\\mathrm{cut}}$ 的倒易晶格矢量 $\\mathbf{G}$。每个晶胞的局域赝势能为\n$$E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{1}{\\Omega} \\sum_{0\\|\\mathbf{G}\\|\\le G_{\\mathrm{cut}}} \\tilde{V}(\\mathbf{G}) \\left|\\tilde{\\rho}(\\mathbf{G})\\right|^2,$$\n其中 $\\Omega = L^3$ 是晶胞体积。位于 $\\mathbf{R}_2$ 处的原子所受的力定义为能量相对于 $\\mathbf{R}_2$ 的负梯度，\n$$\\mathbf{F}_2(E_{\\mathrm{cut}}) = -\\frac{\\partial E_{\\text{loc}}(E_{\\mathrm{cut}})}{\\partial \\mathbf{R}_2},$$\n其沿键合方向的分量为 $F_{\\parallel}(E_{\\mathrm{cut}}) = \\mathbf{F}_2(E_{\\mathrm{cut}})\\cdot \\hat{\\mathbf{d}}$。能量以哈特里表示，力以哈特里每玻尔表示。\n\n从基本的周期性傅里叶表示和上述定义出发，推导通过对倒易晶格矢量求和至截断值 $G_{\\mathrm{cut}}$ 来计算 $E_{\\text{loc}}(E_{\\mathrm{cut}})$ 和 $F_{\\parallel}(E_{\\mathrm{cut}})$ 的算法。通过使用一个非常大的截断能 $E_{\\mathrm{ref}} = 200$（哈特里）来估计参考值 $E_{\\text{loc}}^{\\text{ref}}$ 和 $F_{\\parallel}^{\\text{ref}}$，该值可作为无限基组极限的代理。\n\n使用此模型，确定能量和沿键合方向的力的截断误差相对于 $E_{\\mathrm{cut}}$ 的渐近收敛速率。将最大三个截断值下的误差 $\\left|E_{\\text{loc}}(E_{\\mathrm{cut}}) - E_{\\text{loc}}^{\\text{ref}}\\right|$ 和 $\\left|F_{\\parallel}(E_{\\mathrm{cut}}) - F_{\\parallel}^{\\text{ref}}\\right|$ 拟合到两个模型：\n- 指数模型 $A \\exp(-c E_{\\mathrm{cut}})$，报告速率参数 $c$。\n- 幂律模型 $B E_{\\mathrm{cut}}^{-p}$，报告速率参数 $p$。\n通过比较拟合优度（例如，决定系数），判断哪个模型更好地描述了渐近区域，并报告相应的速率参数和所选模型的指示符。\n\n测试套件：\n- 使用以下截断能值（哈特里）：$[5.0, 10.0, 20.0, 40.0, 80.0]$。\n- 使用参数 $L = 10.26$，$\\sigma = 0.3$，$V_0 = -0.5$，和 $\\beta = 0.01$，以及如上定义的原子位置 $\\mathbf{R}_1$ 和 $\\mathbf{R}_2$。\n- 参考截断能为 $E_{\\mathrm{ref}} = 200.0$（哈特里）。\n\n你的程序应计算：\n- 能量列表 $[E_{\\text{loc}}(5.0), E_{\\text{loc}}(10.0), E_{\\text{loc}}(20.0), E_{\\text{loc}}(40.0), E_{\\text{loc}}(80.0)]$，单位为哈特里。\n- 沿键合方向的力列表 $[F_{\\parallel}(5.0), F_{\\parallel}(10.0), F_{\\parallel}(20.0), F_{\\parallel}(40.0), F_{\\parallel}(80.0)]$，单位为哈特里每玻尔。\n- 能量的估计渐近速率参数，以及一个指示是否为能量选择了指数模型的布尔值。\n- 力的估计渐近速率参数，以及一个指示是否为力选择了指数模型的布尔值。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，能量和力为嵌套列表。例如，它应打印\n$$\\left[\\left[E_1,E_2,E_3,E_4,E_5\\right],\\left[F_1,F_2,F_3,F_4,F_5\\right],r_E,b_E,r_F,b_F\\right],$$\n其中 $E_i$ 是能量（哈特里），$F_i$ 是力（哈特里每玻尔），$r_E$ 和 $r_F$ 是拟合的速率参数（浮点数），$b_E$ 和 $b_F$ 是布尔值，分别指示是否为能量和力选择了指数模型。所有能量必须以哈特里表示，所有力必须以哈特里每玻尔表示。",
            "solution": "该任务旨在计算一个简化硅模型中的局域能量 $E_{\\text{loc}}$ 和沿键方向的力分量 $F_{\\parallel}$，并分析它们关于平面波截断能 $E_{\\text{cut}}$ 的收敛性。解决方案包括推导倒易空间中这些量的解析表达式，然后进行数值实现。\n\n**1. 局域能量($E_{\\text{loc}}$)的推导**\n\n局域能量由以下公式给出：\n$$E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{1}{\\Omega} \\sum_{0\\|\\mathbf{G}\\|\\le G_{\\mathrm{cut}}} \\tilde{V}(\\mathbf{G}) \\left|\\tilde{\\rho}(\\mathbf{G})\\right|^2$$\n首先，我们简化密度结构因子项 $|\\tilde{\\rho}(\\mathbf{G})|^2$。给定 $\\mathbf{R}_1 = \\mathbf{0}$，总赝密度为 $\\tilde{\\rho}(\\mathbf{G}) = \\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})(1 + e^{-i\\mathbf{G}\\cdot\\mathbf{R}_2})$。其模的平方为：\n$$|\\tilde{\\rho}(\\mathbf{G})|^2 = |\\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})|^2 |1 + e^{-i\\mathbf{G}\\cdot\\mathbf{R}_2}|^2$$\n原子密度项为 $|\\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})|^2 = |\\exp(-\\frac{\\sigma^2 G^2}{2})|^2 = \\exp(-\\sigma^2 G^2)$，其中 $G = \\|\\mathbf{G}\\|$。结构因子项为：\n$$|1 + e^{-i\\mathbf{G}\\cdot\\mathbf{R}_2}|^2 = (1 + \\cos(\\mathbf{G}\\cdot\\mathbf{R}_2))^2 + (-\\sin(\\mathbf{G}\\cdot\\mathbf{R}_2))^2 = 2 + 2\\cos(\\mathbf{G}\\cdot\\mathbf{R}_2) = 4\\cos^2\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)$$\n将这些与势 $\\tilde{V}(\\mathbf{G}) = V_0 \\exp(-\\beta G^2)$ 结合，得到能量求和的最终表达式：\n$$E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{4V_0}{\\Omega} \\sum_{0\\|\\mathbf{G}\\|\\le G_{\\mathrm{cut}}} \\exp\\left(-(\\beta+\\sigma^2)G^2\\right) \\cos^2\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)$$\n\n**2. 力分量($F_{\\parallel}$)的推导**\n\n原子2上的力是能量相对于其位置 $\\mathbf{R}_2$ 的负梯度：\n$$\\mathbf{F}_2 = -\\nabla_{\\mathbf{R}_2} E_{\\text{loc}} = -\\frac{1}{\\Omega} \\sum_{\\mathbf{G}} \\tilde{V}(\\mathbf{G}) |\\tilde{\\rho}_{\\text{atom}}|^2 \\nabla_{\\mathbf{R}_2} |1+e^{-i\\mathbf{G}\\cdot\\mathbf{R}_2}|^2$$\n结构因子项的梯度为：\n$$\\nabla_{\\mathbf{R}_2} \\left(2 + 2\\cos(\\mathbf{G}\\cdot\\mathbf{R}_2)\\right) = -2\\sin(\\mathbf{G}\\cdot\\mathbf{R}_2)\\mathbf{G}$$\n将此代入力表达式：\n$$\\mathbf{F}_2 = \\frac{2}{\\Omega} \\sum_{\\mathbf{G}} \\tilde{V}(\\mathbf{G}) |\\tilde{\\rho}_{\\text{atom}}|^2 \\sin(\\mathbf{G}\\cdot\\mathbf{R}_2)\\mathbf{G}$$\n力沿键方向 $\\hat{\\mathbf{d}}$ 的分量是 $F_{\\parallel} = \\mathbf{F}_2 \\cdot \\hat{\\mathbf{d}}$。这得到力分量求和的最终表达式：\n$$F_{\\parallel}(E_{\\mathrm{cut}}) = \\frac{2V_0}{\\Omega} \\sum_{0\\|\\mathbf{G}\\|\\le G_{\\mathrm{cut}}} \\exp\\left(-(\\beta+\\sigma^2)G^2\\right) \\sin(\\mathbf{G}\\cdot\\mathbf{R}_2) (\\mathbf{G}\\cdot\\hat{\\mathbf{d}})$$\n\n**3. 数值实现与收敛性分析**\n\n计算流程如下：\n1.  **生成G矢量**：对于给定的 $E_{\\text{cut}}$，确定所需的最大整数索引 $(n_x, n_y, n_z)$ 以生成所有在截断球 $\\|\\mathbf{G}\\|^2 \\le 2E_{\\text{cut}}$ 内的 $\\mathbf{G}$ 矢量。\n2.  **求和**：遍历所有在范围内的整数三元组 $(n_x, n_y, n_z)$。对于每个得到的 $\\mathbf{G}$ 矢量（不包括 $\\mathbf{G}=\\mathbf{0}$），检查它是否在截断球内。如果是，计算相应的能量和力的项，并将它们加到运行总和中。\n3.  **计算最终值**：将总和乘以它们各自的前置因子（能量为 $4V_0/\\Omega$，力为 $2V_0/\\Omega$），得到该 $E_{\\text{cut}}$ 下的 $E_{\\text{loc}}$ 和 $F_{\\parallel}$。\n4.  **参考计算**：使用一个非常高的参考截断能 $E_{\\text{ref}} = 200$ 进行计算，以获得 $E_{\\text{loc}}^{\\text{ref}}$ 和 $F_{\\parallel}^{\\text{ref}}$。\n5.  **收敛性分析**：\n    a. 对于测试集中的三个最大截断能（$20, 40, 80$ 哈特里），计算能量和力的绝对误差（相对于参考值）。\n    b. 使用线性回归，将误差的对数分别对 $E_{\\text{cut}}$（指数模型）和 $\\log(E_{\\text{cut}})$（幂律模型）进行拟合。\n    c. 比较两种拟合的决定系数（$R^2$）。$R^2$ 值较高的模型被认为是渐近收敛更好的描述。\n    d. 从最佳拟合模型中报告相应的速率参数（$c$ 或 $p$）。该速率从线性回归的斜率中提取。\n\n这个过程在提供的Python代码中实现，它系统地评估了每个截断能下的能量和力，计算了参考值，并执行了所描述的曲线拟合以确定收敛行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the pseudopotential convergence problem as specified.\n    \"\"\"\n    # Define physical and model parameters in atomic units.\n    L = 10.26  # Bohr\n    sigma = 0.3  # Bohr\n    V0 = -0.5  # Hartree\n    beta = 0.01  # Bohr^2\n\n    # Define geometric properties of the unit cell.\n    R2 = np.array([L/4, L/4, L/4])\n    d_hat = R2 / np.linalg.norm(R2)\n    Omega = L**3\n\n    # Define the set of energy cutoffs for the main calculation and reference.\n    test_ecuts = [5.0, 10.0, 20.0, 40.0, 80.0]\n    ref_ecut = 200.0\n    all_ecuts = test_ecuts + [ref_ecut]\n\n    # Dictionaries to store results.\n    energies = {}\n    forces = {}\n\n    prefactor_E = 4 * V0 / Omega\n    prefactor_F = 2 * V0 / Omega\n    exp_decay_const = beta + sigma**2\n    g_vec_factor = (2 * np.pi / L)**2\n    g_dot_r2_factor = np.pi / 2\n    g_dot_dhat_factor = (2 * np.pi) / (L * np.sqrt(3))\n\n    # Main calculation loop over all energy cutoffs.\n    for e_cut in all_ecuts:\n        g_cut_sq = 2 * e_cut\n        \n        # Determine the maximum integer indices for the loops.\n        n_max = int(np.floor(np.sqrt(g_cut_sq / g_vec_factor)))\n\n        energy_sum = 0.0\n        force_sum = 0.0\n\n        # Loop over reciprocal lattice vectors within the cutoff sphere.\n        for nx in range(-n_max, n_max + 1):\n            for ny in range(-n_max, n_max + 1):\n                for nz in range(-n_max, n_max + 1):\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n                    \n                    G_sq = g_vec_factor * (nx**2 + ny**2 + nz**2)\n\n                    if G_sq > g_cut_sq:\n                        continue\n                    \n                    # Pre-calculate sums of indices for efficiency.\n                    n_sum = nx + ny + nz\n                    \n                    # Calculate terms for the summation expressions.\n                    exp_term = np.exp(-exp_decay_const * G_sq)\n                    \n                    # Energy summand\n                    G_dot_R2 = g_dot_r2_factor * n_sum\n                    cos_sq_term = np.cos(G_dot_R2 / 2)**2\n                    energy_sum += exp_term * cos_sq_term\n                    \n                    # Force summand\n                    sin_term = np.sin(G_dot_R2)\n                    G_dot_dhat = g_dot_dhat_factor * n_sum\n                    force_sum += exp_term * sin_term * G_dot_dhat\n    \n        # Final energy and force for the current cutoff.\n        energies[e_cut] = prefactor_E * energy_sum\n        forces[e_cut] = prefactor_F * force_sum\n\n    # Extract results for the test cutoffs.\n    E_list = [energies[e] for e in test_ecuts]\n    F_list = [forces[e] for e in test_ecuts]\n    \n    # Get reference values calculated with the high cutoff.\n    E_ref = energies[ref_ecut]\n    F_ref = forces[ref_ecut]\n    \n    # --- Convergence Analysis ---\n    analysis_ecuts = np.array([20.0, 40.0, 80.0])\n\n    def analyze_convergence(data, ref_value, ecuts):\n        \"\"\"\n        Fits error data to exponential and power-law models and determines the best fit.\n        \"\"\"\n        errors = np.abs(np.array(data) - ref_value)\n        # Avoid log(0) issues, though unlikely for this problem.\n        if np.any(errors = 0):\n            return 0.0, False\n\n        log_errors = np.log(errors)\n        log_ecuts = np.log(ecuts)\n\n        # Power-law fit: ln(err) = ln(B) - p * ln(E_cut)\n        lr_power = linregress(log_ecuts, log_errors)\n        r2_power = lr_power.rvalue**2\n        p_rate = -lr_power.slope\n        \n        # Exponential fit: ln(err) = ln(A) - c * E_cut\n        lr_exp = linregress(ecuts, log_errors)\n        r2_exp = lr_exp.rvalue**2\n        c_rate = -lr_exp.slope\n\n        is_exponential_fit = r2_exp > r2_power\n        best_rate = c_rate if is_exponential_fit else p_rate\n        \n        return best_rate, is_exponential_fit\n\n    # Analyze convergence for energy.\n    analysis_energies = [energies[e] for e in analysis_ecuts]\n    rate_E, is_exp_E = analyze_convergence(analysis_energies, E_ref, analysis_ecuts)\n    \n    # Analyze convergence for force.\n    analysis_forces = [forces[e] for e in analysis_ecuts]\n    rate_F, is_exp_F = analyze_convergence(analysis_forces, F_ref, analysis_ecuts)\n    \n    # Format the final output as a Python list.\n    final_output = [E_list, F_list, rate_E, is_exp_E, rate_F, is_exp_F]\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}