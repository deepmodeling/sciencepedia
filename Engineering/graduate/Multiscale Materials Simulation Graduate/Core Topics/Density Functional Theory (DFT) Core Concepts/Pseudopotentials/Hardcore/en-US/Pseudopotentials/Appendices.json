{
    "hands_on_practices": [
        {
            "introduction": "In any plane-wave based electronic structure calculation, the basis set is truncated at a finite kinetic energy cutoff, $E_{\\mathrm{cut}}$. The accuracy of calculated properties, such as total energy and interatomic forces, is critically dependent on this parameter. This exercise provides fundamental, hands-on practice with the essential task of performing a convergence study, allowing you to quantify how the choice of $E_{\\mathrm{cut}}$ affects numerical precision and to understand the rate at which key physical observables converge toward the infinite-basis limit. ",
            "id": "3836286",
            "problem": "Consider a simplified periodic model of a small silicon unit cell within a plane-wave representation inspired by Density Functional Theory (DFT). Work entirely in atomic units where the reduced Planck constant is $1$, the electron mass is $1$, and the elementary charge is $1$. The unit cell is a cube of side length $L$ with $L = 10.26$ (in Bohr), containing two atoms at positions $\\mathbf{R}_1 = (0,0,0)$ and $\\mathbf{R}_2 = (L/4,L/4,L/4)$, which approximate the diamond structure basis. Define $\\mathbf{d} = \\mathbf{R}_2 - \\mathbf{R}_1$, and let $\\hat{\\mathbf{d}} = \\mathbf{d} / \\|\\mathbf{d}\\|$ denote the unit vector along the bond direction.\n\nLet the electron pseudo-density for each atom be modeled by a normalized Gaussian in reciprocal space with width parameter $\\sigma$, and let the local norm-conserving pseudopotential be modeled by a smooth Gaussian form factor in reciprocal space. Specifically, use\n$$\\tilde{\\rho}_{\\text{atom}}(\\mathbf{G}) = \\exp\\left(-\\frac{\\sigma^2 \\|\\mathbf{G}\\|^2}{2}\\right), \\quad \\tilde{V}(\\mathbf{G}) = V_0 \\exp\\left(-\\beta \\|\\mathbf{G}\\|^2\\right),$$\nwith $\\sigma = 0.3$ (in Bohr), $V_0 = -0.5$ (in Hartree), and $\\beta = 0.01$ (in Bohr$^2$). The total pseudo-density structure factor is\n$$\\tilde{\\rho}(\\mathbf{G}) = \\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})\\left(e^{-i \\mathbf{G}\\cdot \\mathbf{R}_1} + e^{-i \\mathbf{G}\\cdot \\mathbf{R}_2}\\right).$$\n\nThe reciprocal lattice vectors are $\\mathbf{G} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$ for integers $n_x$, $n_y$, $n_z \\in \\mathbb{Z}$. Introduce a plane-wave kinetic energy cutoff $E_{\\mathrm{cut}}$ (in Hartree), and define the corresponding magnitude cutoff in reciprocal space as $G_{\\mathrm{cut}} = \\sqrt{2 E_{\\mathrm{cut}}}$. All sums below run over reciprocal lattice vectors $\\mathbf{G}$ with $0 < \\|\\mathbf{G}\\| \\le G_{\\mathrm{cut}}$. The local pseudopotential energy per unit cell is\n$$E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{1}{\\Omega} \\sum_{0<\\|\\mathbf{G}\\|\\le G_{\\mathrm{cut}}} \\tilde{V}(\\mathbf{G}) \\left|\\tilde{\\rho}(\\mathbf{G})\\right|^2,$$\nwhere $\\Omega = L^3$ is the cell volume. The force on the atom at $\\mathbf{R}_2$ is defined by the negative gradient of the energy with respect to $\\mathbf{R}_2$,\n$$\\mathbf{F}_2(E_{\\mathrm{cut}}) = -\\frac{\\partial E_{\\text{loc}}(E_{\\mathrm{cut}})}{\\partial \\mathbf{R}_2},$$\nand the component along the bond is $F_{\\parallel}(E_{\\mathrm{cut}}) = \\mathbf{F}_2(E_{\\mathrm{cut}})\\cdot \\hat{\\mathbf{d}}$. Express energies in Hartree and forces in Hartree per Bohr.\n\nStarting from the fundamental periodic Fourier representation and the definitions above, derive the algorithm to compute $E_{\\text{loc}}(E_{\\mathrm{cut}})$ and $F_{\\parallel}(E_{\\mathrm{cut}})$ by summing over reciprocal lattice vectors up to the cutoff $G_{\\mathrm{cut}}$. Estimate the reference values $E_{\\text{loc}}^{\\text{ref}}$ and $F_{\\parallel}^{\\text{ref}}$ by using a very large cutoff $E_{\\mathrm{ref}} = 200$ (in Hartree), which serves as a proxy for the infinite-basis limit.\n\nUsing this model, determine the asymptotic convergence rate of the truncation error with respect to $E_{\\mathrm{cut}}$ for both the energy and the bond-aligned force. Fit the errors $\\left|E_{\\text{loc}}(E_{\\mathrm{cut}}) - E_{\\text{loc}}^{\\text{ref}}\\right|$ and $\\left|F_{\\parallel}(E_{\\mathrm{cut}}) - F_{\\parallel}^{\\text{ref}}\\right|$ over the largest three cutoff values to two models:\n- An exponential model $A \\exp(-c E_{\\mathrm{cut}})$, reporting the rate parameter $c$.\n- A power-law model $B E_{\\mathrm{cut}}^{-p}$, reporting the rate parameter $p$.\nDecide which model better describes the asymptotic regime by comparing goodness-of-fit (for instance, the coefficient of determination), and report the corresponding rate parameter and an indicator of the chosen model.\n\nTest Suite:\n- Use the following cutoff energy values (in Hartree): $[5.0, 10.0, 20.0, 40.0, 80.0]$.\n- Use the parameters $L = 10.26$, $\\sigma = 0.3$, $V_0 = -0.5$, and $\\beta = 0.01$, with positions $\\mathbf{R}_1$ and $\\mathbf{R}_2$ as defined above.\n- The reference cutoff energy is $E_{\\mathrm{ref}} = 200.0$ (in Hartree).\n\nYour program should compute:\n- The list of energies $[E_{\\text{loc}}(5.0), E_{\\text{loc}}(10.0), E_{\\text{loc}}(20.0), E_{\\text{loc}}(40.0), E_{\\text{loc}}(80.0)]$ in Hartree.\n- The list of bond-aligned forces $[F_{\\parallel}(5.0), F_{\\parallel}(10.0), F_{\\parallel}(20.0), F_{\\parallel}(40.0), F_{\\parallel}(80.0)]$ in Hartree per Bohr.\n- The estimated asymptotic rate parameter for the energy, and a boolean indicating whether the exponential model was selected for the energy.\n- The estimated asymptotic rate parameter for the force, and a boolean indicating whether the exponential model was selected for the force.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with nested lists for the energies and forces. For example, it should print\n$$\\left[\\left[E_1,E_2,E_3,E_4,E_5\\right],\\left[F_1,F_2,F_3,F_4,F_5\\right],r_E,b_E,r_F,b_F\\right],$$\nwhere $E_i$ are energies (Hartree), $F_i$ are forces (Hartree per Bohr), $r_E$ and $r_F$ are the fitted rate parameters (floats), and $b_E$ and $b_F$ are booleans indicating whether the exponential model was selected for energy and force, respectively. All energies must be expressed in Hartree and all forces must be expressed in Hartree per Bohr.",
            "solution": "The problem is first subjected to a rigorous validation process to ensure its scientific soundness, consistency, and completeness before a solution is attempted.\n\n### Step 1: Extract Givens\nThe problem provides the following data, definitions, and conditions:\n- **System**: A cubic unit cell of side length $L = 10.26$ Bohr.\n- **Atomic Positions**: Two atoms at $\\mathbf{R}_1 = (0,0,0)$ and $\\mathbf{R}_2 = (L/4,L/4,L/4)$.\n- **Vectors**: $\\mathbf{d} = \\mathbf{R}_2 - \\mathbf{R}_1$, and the unit vector $\\hat{\\mathbf{d}} = \\mathbf{d} / \\|\\mathbf{d}\\|$.\n- **Reciprocal Lattice**: Vectors are given by $\\mathbf{G} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$ for integers $n_x, n_y, n_z \\in \\mathbb{Z}$.\n- **Atomic Pseudo-density (Reciprocal Space)**: $\\tilde{\\rho}_{\\text{atom}}(\\mathbf{G}) = \\exp\\left(-\\frac{\\sigma^2 \\|\\mathbf{G}\\|^2}{2}\\right)$, with $\\sigma = 0.3$ Bohr.\n- **Local Pseudopotential (Reciprocal Space)**: $\\tilde{V}(\\mathbf{G}) = V_0 \\exp\\left(-\\beta \\|\\mathbf{G}\\|^2\\right)$, with $V_0 = -0.5$ Hartree and $\\beta = 0.01$ Bohr$^2$.\n- **Total Pseudo-density Structure Factor**: $\\tilde{\\rho}(\\mathbf{G}) = \\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})\\left(e^{-i \\mathbf{G}\\cdot \\mathbf{R}_1} + e^{-i \\mathbf{G}\\cdot \\mathbf{R}_2}\\right)$.\n- **Energy and Force Cutoffs**: A kinetic energy cutoff $E_{\\mathrm{cut}}$ defines a reciprocal space cutoff radius $G_{\\mathrm{cut}} = \\sqrt{2 E_{\\mathrm{cut}}}$. Summations run over vectors $\\mathbf{G}$ satisfying $0 < \\|\\mathbf{G}\\| \\le G_{\\mathrm{cut}}$.\n- **Local Energy**: $E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{1}{\\Omega} \\sum_{0<\\|\\mathbf{G}\\|\\le G_{\\mathrm{cut}}} \\tilde{V}(\\mathbf{G}) \\left|\\tilde{\\rho}(\\mathbf{G})\\right|^2$, where $\\Omega = L^3$.\n- **Force on Atom 2**: $\\mathbf{F}_2(E_{\\mathrm{cut}}) = -\\frac{\\partial E_{\\text{loc}}(E_{\\mathrm{cut}})}{\\partial \\mathbf{R}_2}$.\n- **Bond-aligned Force**: $F_{\\parallel}(E_{\\mathrm{cut}}) = \\mathbf{F}_2(E_{\\mathrm{cut}})\\cdot \\hat{\\mathbf{d}}$.\n- **Test Suite**: $E_{\\mathrm{cut}} \\in [5.0, 10.0, 20.0, 40.0, 80.0]$ Hartree.\n- **Reference Cutoff**: $E_{\\mathrm{ref}} = 200.0$ Hartree.\n- **Convergence Models**: An exponential model $A \\exp(-c E_{\\mathrm{cut}})$ and a power-law model $B E_{\\mathrm{cut}}^{-p}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated based on the established criteria:\n- **Scientifically Grounded**: The problem is well-grounded in the principles of solid-state physics and computational materials science, specifically using concepts from Density Functional Theory (DFT) like pseudopotentials, plane-wave basis sets, and reciprocal space representations. The use of Gaussian forms for potentials and densities is a common and valid simplification. The relation $E_{\\mathrm{cut}} = \\frac{1}{2} G_{\\mathrm{cut}}^2$ is correct in atomic units ($\\hbar=1, m_e=1$).\n- **Well-Posed**: The problem is mathematically well-posed. All required parameters are provided, and the functions and objectives are defined unambiguously. The summation over a finite set of reciprocal lattice vectors guarantees a computable, unique result for any given $E_{\\mathrm{cut}}$.\n- **Objective**: The problem statement is quantitative and objective, free from subjective or speculative claims.\n- **Completeness and Consistency**: The problem is self-contained and internally consistent. No information is missing or contradictory. The units (atomic units) are consistent throughout.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It represents a well-defined computational task based on a simplified but physically meaningful model. We may therefore proceed with the derivation of the solution.\n\n### Algorithmic Derivation\n\nThe core of the task is to compute the local energy $E_{\\text{loc}}$ and the bond-aligned force $F_{\\parallel}$ by summing over reciprocal lattice vectors.\n\n#### 1. Derivation of the Local Energy Expression\nThe local energy is given by:\n$$E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{1}{\\Omega} \\sum_{0<\\|\\mathbf{G}\\|\\le G_{\\mathrm{cut}}} \\tilde{V}(\\mathbf{G}) \\left|\\tilde{\\rho}(\\mathbf{G})\\right|^2$$\nWe first simplify the term $|\\tilde{\\rho}(\\mathbf{G})|^2$. Given $\\mathbf{R}_1 = \\mathbf{0}$, the total pseudo-density is $\\tilde{\\rho}(\\mathbf{G}) = \\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})(1 + e^{-i\\mathbf{G}\\cdot\\mathbf{R}_2})$.\nThe squared magnitude is:\n$$\\left|\\tilde{\\rho}(\\mathbf{G})\\right|^2 = \\left|\\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})\\right|^2 \\left|1 + e^{-i\\mathbf{G}\\cdot\\mathbf{R}_2}\\right|^2$$\nThe atomic density term is $\\left|\\tilde{\\rho}_{\\text{atom}}(\\mathbf{G})\\right|^2 = \\left|\\exp\\left(-\\frac{\\sigma^2 \\|\\mathbf{G}\\|^2}{2}\\right)\\right|^2 = \\exp(-\\sigma^2 \\|\\mathbf{G}\\|^2)$.\nThe structure factor term is:\n$$\\left|1 + e^{-i\\mathbf{G}\\cdot\\mathbf{R}_2}\\right|^2 = (1 + \\cos(\\mathbf{G}\\cdot\\mathbf{R}_2))^2 + (-\\sin(\\mathbf{G}\\cdot\\mathbf{R}_2))^2 = 2 + 2\\cos(\\mathbf{G}\\cdot\\mathbf{R}_2) = 4\\cos^2\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)$$\nCombining these, we get:\n$$\\left|\\tilde{\\rho}(\\mathbf{G})\\right|^2 = 4 \\exp(-\\sigma^2 \\|\\mathbf{G}\\|^2) \\cos^2\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)$$\nSubstituting this and the expression for $\\tilde{V}(\\mathbf{G})$ into the energy formula, with $G = \\|\\mathbf{G}\\|$:\n$$E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{1}{\\Omega} \\sum_{0<G\\le G_{\\mathrm{cut}}} \\left(V_0 \\exp(-\\beta G^2)\\right) \\left(4 \\exp(-\\sigma^2 G^2) \\cos^2\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)\\right)$$\n$$E_{\\text{loc}}(E_{\\mathrm{cut}}) = \\frac{4V_0}{\\Omega} \\sum_{0<G\\le G_{\\mathrm{cut}}} \\exp(-(\\beta+\\sigma^2)G^2) \\cos^2\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)$$\nThis is the final expression for the energy to be computed.\n\n#### 2. Derivation of the Force Expression\nThe force on atom $2$ is the negative gradient of the energy with respect to its position $\\mathbf{R}_2$:\n$$\\mathbf{F}_2 = -\\frac{\\partial E_{\\text{loc}}}{\\partial \\mathbf{R}_2}$$\nWe differentiate the energy expression term-by-term. The only part of the summand that depends on $\\mathbf{R}_2$ is $\\cos^2(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2})$. Using the chain rule $\\nabla_{\\mathbf{r}}f(\\mathbf{k}\\cdot\\mathbf{r}) = \\mathbf{k}f'(\\mathbf{k}\\cdot\\mathbf{r})$:\n$$\\frac{\\partial}{\\partial \\mathbf{R}_2} \\cos^2\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right) = \\mathbf{G} \\cdot \\left[ 2\\cos\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)\\left(-\\sin\\left(\\frac{\\mathbf{G}\\cdot\\mathbf{R}_2}{2}\\right)\\right)\\frac{1}{2} \\right] = -\\frac{1}{2}\\sin(\\mathbf{G}\\cdot\\mathbf{R}_2)\\mathbf{G}$$\nSubstituting this into the derivative of the energy expression:\n$$\\frac{\\partial E_{\\text{loc}}}{\\partial \\mathbf{R}_2} = \\frac{4V_0}{\\Omega} \\sum_{0<G\\le G_{\\mathrm{cut}}} \\exp(-(\\beta+\\sigma^2)G^2) \\left(-\\frac{1}{2}\\sin(\\mathbf{G}\\cdot\\mathbf{R}_2)\\mathbf{G}\\right)$$\nThe force vector is then:\n$$\\mathbf{F}_2(E_{\\mathrm{cut}}) = \\frac{2V_0}{\\Omega} \\sum_{0<G\\le G_{\\mathrm{cut}}} \\exp(-(\\beta+\\sigma^2)G^2) \\sin(\\mathbf{G}\\cdot\\mathbf{R}_2)\\mathbf{G}$$\nThe component of the force along the bond direction $\\hat{\\mathbf{d}}$ is found by taking the dot product with $\\hat{\\mathbf{d}} = \\mathbf{R}_2 / \\|\\mathbf{R}_2\\|$:\n$$F_{\\parallel}(E_{\\mathrm{cut}}) = \\mathbf{F}_2 \\cdot \\hat{\\mathbf{d}} = \\frac{2V_0}{\\Omega} \\sum_{0<G\\le G_{\\mathrm{cut}}} \\exp(-(\\beta+\\sigma^2)G^2) \\sin(\\mathbf{G}\\cdot\\mathbf{R}_2)(\\mathbf{G}\\cdot\\hat{\\mathbf{d}})$$\nThis provides the final expression for the bond-aligned force.\n\n#### 3. Numerical Implementation\n- The calculation requires iterating through reciprocal lattice vectors $\\mathbf{G} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$ for integer triples $(n_x, n_y, n_z)$.\n- For each $E_{\\mathrm{cut}}$, the corresponding $G_{\\mathrm{cut}}^2 = 2E_{\\mathrm{cut}}$ defines the summation boundary. The integer indices $(n_x, n_y, n_z)$ are iterated within a cubic box large enough to contain the sphere of radius $G_{\\mathrm{cut}}$, i.e., $|n_i| \\le N_{\\max} = \\lfloor \\frac{L G_{\\mathrm{cut}}}{2\\pi} \\rfloor$.\n- Inside the loop, we check two conditions: $(n_x,n_y,n_z) \\neq (0,0,0)$ and $\\|\\mathbf{G}\\|^2 \\le G_{\\mathrm{cut}}^2$.\n- The dot products in the formulae can be simplified:\n  - $\\mathbf{G}\\cdot\\mathbf{R}_2 = \\frac{2\\pi}{L}(n_x, n_y, n_z) \\cdot \\frac{L}{4}(1,1,1) = \\frac{\\pi}{2}(n_x+n_y+n_z)$.\n  - $\\hat{\\mathbf{d}} = \\frac{(L/4)(1,1,1)}{L\\sqrt{3}/4} = \\frac{1}{\\sqrt{3}}(1,1,1)$.\n  - $\\mathbf{G}\\cdot\\hat{\\mathbf{d}} = \\frac{2\\pi}{L}(n_x, n_y, n_z) \\cdot \\frac{1}{\\sqrt{3}}(1,1,1) = \\frac{2\\pi}{L\\sqrt{3}}(n_x+n_y+n_z)$.\n- These simplified forms are used to compute the summands for energy and force, which are then accumulated.\n\n#### 4. Convergence Analysis\n- After computing $E_{\\text{loc}}$ and $F_{\\parallel}$ for all specified $E_{\\mathrm{cut}}$ values and for the reference $E_{\\text{ref}}$, we calculate the absolute errors $\\Delta E = |E_{\\text{loc}}(E_{\\mathrm{cut}}) - E_{\\text{loc}}^{\\text{ref}}|$ and $\\Delta F = |F_{\\parallel}(E_{\\mathrm{cut}}) - F_{\\parallel}^{\\text{ref}}|$ for the three largest cutoffs ($E_{\\mathrm{cut}} \\in [20.0, 40.0, 80.0]$).\n- To fit the exponential model, $\\Delta = A e^{-c E_{\\mathrm{cut}}}$, we perform a linear regression on the transformed data: $\\ln(\\Delta) = \\ln(A) - c E_{\\mathrm{cut}}$. The slope of the line fit to $(\\ln(\\Delta) \\text{ vs. } E_{\\mathrm{cut}})$ is $-c$.\n- To fit the power-law model, $\\Delta = B E_{\\mathrm{cut}}^{-p}$, we perform a linear regression on the transformed data: $\\ln(\\Delta) = \\ln(B) - p \\ln(E_{\\mathrm{cut}})$. The slope of the line fit to $(\\ln(\\Delta) \\text{ vs. } \\ln(E_{\\mathrm{cut}}))$ is $-p$.\n- The coefficient of determination, $R^2$, is computed for both linear fits. The model with the higher $R^2$ value is selected as the better fit for the asymptotic behavior. The corresponding rate parameter ($c$ or $p$) is reported.\n- The Gaussian decay term $\\exp(-(\\beta+\\sigma^2)G^2) = \\exp(-(\\beta+\\sigma^2)2E_{\\text{cut}})$ in the summands strongly suggests that the convergence error will follow an exponential decay with respect to $E_{\\mathrm{cut}}$. Thus, the exponential model is expected to provide a superior fit.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the pseudopotential convergence problem as specified.\n    \"\"\"\n    # Define physical and model parameters in atomic units.\n    L = 10.26  # Bohr\n    sigma = 0.3  # Bohr\n    V0 = -0.5  # Hartree\n    beta = 0.01  # Bohr^2\n\n    # Define geometric properties of the unit cell.\n    R2 = np.array([L/4, L/4, L/4])\n    d_hat = R2 / np.linalg.norm(R2)\n    Omega = L**3\n\n    # Define the set of energy cutoffs for the main calculation and reference.\n    test_ecuts = [5.0, 10.0, 20.0, 40.0, 80.0]\n    ref_ecut = 200.0\n    all_ecuts = test_ecuts + [ref_ecut]\n\n    # Dictionaries to store results.\n    energies = {}\n    forces = {}\n\n    prefactor_E = 4 * V0 / Omega\n    prefactor_F = 2 * V0 / Omega\n    exp_decay_const = beta + sigma**2\n    g_vec_factor = (2 * np.pi / L)**2\n    g_dot_r2_factor = np.pi / 2\n    g_dot_dhat_factor = (2 * np.pi) / (L * np.sqrt(3))\n\n    # Main calculation loop over all energy cutoffs.\n    for e_cut in all_ecuts:\n        g_cut_sq = 2 * e_cut\n        \n        # Determine the maximum integer indices for the loops.\n        n_max = int(np.floor(np.sqrt(g_cut_sq / g_vec_factor)))\n\n        energy_sum = 0.0\n        force_sum = 0.0\n\n        # Loop over reciprocal lattice vectors within the cutoff sphere.\n        for nx in range(-n_max, n_max + 1):\n            for ny in range(-n_max, n_max + 1):\n                for nz in range(-n_max, n_max + 1):\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n                    \n                    G_sq = g_vec_factor * (nx**2 + ny**2 + nz**2)\n\n                    if G_sq > g_cut_sq:\n                        continue\n                    \n                    # Pre-calculate sums of indices for efficiency.\n                    n_sum = nx + ny + nz\n                    \n                    # Calculate terms for the summation expressions.\n                    exp_term = np.exp(-exp_decay_const * G_sq)\n                    \n                    # Energy summand\n                    G_dot_R2 = g_dot_r2_factor * n_sum\n                    cos_sq_term = np.cos(G_dot_R2 / 2)**2\n                    energy_sum += exp_term * cos_sq_term\n                    \n                    # Force summand\n                    sin_term = np.sin(G_dot_R2)\n                    G_dot_dhat = g_dot_dhat_factor * n_sum\n                    force_sum += exp_term * sin_term * G_dot_dhat\n    \n        # Final energy and force for the current cutoff.\n        energies[e_cut] = prefactor_E * energy_sum\n        forces[e_cut] = prefactor_F * force_sum\n\n    # Extract results for the test cutoffs.\n    E_list = [energies[e] for e in test_ecuts]\n    F_list = [forces[e] for e in test_ecuts]\n    \n    # Get reference values calculated with the high cutoff.\n    E_ref = energies[ref_ecut]\n    F_ref = forces[ref_ecut]\n    \n    # --- Convergence Analysis ---\n    analysis_ecuts = np.array([20.0, 40.0, 80.0])\n\n    def analyze_convergence(data, ref_value, ecuts):\n        \"\"\"\n        Fits error data to exponential and power-law models and determines the best fit.\n        \"\"\"\n        errors = np.abs(np.array(data) - ref_value)\n        # Avoid log(0) issues, though unlikely for this problem.\n        if np.any(errors = 0):\n            return 0.0, False\n\n        log_errors = np.log(errors)\n        log_ecuts = np.log(ecuts)\n\n        # Power-law fit: ln(err) = ln(B) - p * ln(E_cut)\n        lr_power = linregress(log_ecuts, log_errors)\n        r2_power = lr_power.rvalue**2\n        p_rate = -lr_power.slope\n        \n        # Exponential fit: ln(err) = ln(A) - c * E_cut\n        lr_exp = linregress(ecuts, log_errors)\n        r2_exp = lr_exp.rvalue**2\n        c_rate = -lr_exp.slope\n\n        is_exponential_fit = r2_exp > r2_power\n        best_rate = c_rate if is_exponential_fit else p_rate\n        \n        return best_rate, is_exponential_fit\n\n    # Analyze convergence for energy.\n    analysis_energies = [energies[e] for e in analysis_ecuts]\n    rate_E, is_exp_E = analyze_convergence(analysis_energies, E_ref, analysis_ecuts)\n    \n    # Analyze convergence for force.\n    analysis_forces = [forces[e] for e in analysis_ecuts]\n    rate_F, is_exp_F = analyze_convergence(analysis_forces, F_ref, analysis_ecuts)\n    \n    # Format the final output as a single-line string.\n    # The problem asks for Python boolean representation in the output string\n    # example: `b_E,b_F`, not `\"true\"`.\n    # Let's use Python's default representation for lists.\n    final_output = [E_list, F_list, rate_E, is_exp_E, rate_F, is_exp_F]\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Modern pseudopotentials rely on the separable Kleinman-Bylander (KB) form to render the nonlocal part of the potential computationally efficient. This elegant formulation replaces the semi-local operator with a sum of projectors derived from reference wavefunctions, which dramatically reduces the computational cost of applying the Hamiltonian. By implementing the KB formalism from first principles for a simplified radial problem, you will gain a deep, practical understanding of how this transformation works and how the nonlocal energy contribution is calculated in modern simulation codes. ",
            "id": "3836291",
            "problem": "You are tasked with implementing the separable form of the nonlocal pseudopotential using the Kleinman-Bylander (KB) representation for a spherically symmetric semi-local operator in the context of multiscale materials simulation. Work strictly from fundamental principles appropriate to quantum mechanics in atomic units and derive the computational procedure needed, then implement it in a complete program.\n\nConsider the semi-local pseudopotential operator that acts on a wavefunction in three dimensions. For a central potential, the angular momentum decomposition leads to channels labeled by the orbital angular momentum quantum number $l$, with a radial part $V_l(r)$ and angular part projected by spherical harmonics $Y_{lm}(\\theta,\\phi)$. The Kleinman-Bylander (KB) separable form introduces a projector derived from a chosen reference pseudo-radial function per channel and a coupling strength chosen so that the separable operator reproduces the semi-local action on the reference state.\n\nUse the following fundamental base and constructions:\n- The three-dimensional inner product is defined by the volume integral with measure $d^3\\mathbf{r} = r^2 dr \\, d\\Omega$, where $d\\Omega$ is the solid angle element.\n- Spherical harmonics $Y_{lm}(\\theta,\\phi)$ are orthonormal on the unit sphere, satisfying $\\int d\\Omega \\, Y_{lm}(\\theta,\\phi) Y_{l'm'}^{\\ast}(\\theta,\\phi) = \\delta_{ll'} \\delta_{mm'}$.\n- Radial functions are normalized with respect to the measure $r^2 dr$, that is, a normalized radial function $R(r)$ satisfies $\\int_0^{\\infty} dr \\, r^2 \\, |R(r)|^2 = 1$.\n- The reference pseudo-radial functions per channel $l$ are of the form $R^{\\mathrm{ref}}_l(r) = \\mathcal{N}_l \\, r^l \\, e^{-\\alpha_l r}$, which are to be normalized in the radial measure. The test state radial functions are of the same form $R^{\\psi}_L(r) = \\mathcal{N}_{\\psi} \\, r^{L} \\, e^{-\\alpha_{\\psi} r}$ and the test state angular function is $Y_{L0}(\\theta,\\phi)$. All angles are in radians. The normalization constant $\\mathcal{N}$ must be derived from the normalization condition.\n- Each semi-local channel radial potential is given by $V_l(r) = V_{0,l} \\, \\exp\\left[-(r/r_{c,l})^2\\right]$, which is spherically symmetric and depends only on $r$.\n\nFrom these, construct the KB projector radial function per channel,\n- The radial projector is constructed from the semi-local potential and the reference pseudo-radial function for that channel. Derive the appropriate form consistent with the KB separable operator representation and spherical symmetry.\n\nDefine the KB coupling strength $D_l$ per channel so that the separable operator reproduces the semi-local action on the chosen reference pseudo-state in that channel. Using the orthonormality of spherical harmonics and the normalization of radial functions, derive the expression for the nonlocal energy contribution for a test state $\\psi$,\n- The nonlocal energy contribution $\\langle \\psi | V_{\\mathrm{nl}} | \\psi \\rangle$ should be expressed in terms of overlaps between the test state and the KB projectors and the coupling strengths. Use the angular momentum selection rules implied by spherical harmonics orthonormality.\n\nNumerical implementation requirements:\n- Use atomic units: lengths in Bohr radii $a_0$ and energies in Hartree. Express the final energies in Hartree, rounded to six decimal places.\n- Discretize the radial coordinate on a uniform grid $r \\in [0, R_{\\max}]$ with step size $\\Delta r$. Use numerical quadrature to approximate all radial integrals, with the correct $r^2$ measure.\n- Your program must implement the construction of normalized radial functions for both reference and test states, assemble radial projectors for each semi-local channel, compute the coupling strengths, and finally evaluate the nonlocal energy for each test case.\n\nTest suite:\nProvide a program that computes $\\langle \\psi | V_{\\mathrm{nl}} | \\psi \\rangle$ for the following four test cases. In each case, all angles are in radians, lengths are in Bohr radii $a_0$, and energies are in Hartree.\n\n- Case $1$ (happy path, $s$-channel):\n  - Grid: $R_{\\max} = 20.0$, $\\Delta r = 0.001$.\n  - Channels: single $l=0$ with $V_{0,0} = -2.0$, $r_{c,0} = 1.2$, $\\alpha_0 = 1.0$.\n  - Test state: $L=0$, $\\alpha_{\\psi} = 0.8$.\n- Case $2$ (happy path, $p$-channel):\n  - Grid: $R_{\\max} = 20.0$, $\\Delta r = 0.001$.\n  - Channels: single $l=1$ with $V_{0,1} = 3.0$, $r_{c,1} = 1.0$, $\\alpha_1 = 1.2$.\n  - Test state: $L=1$, $\\alpha_{\\psi} = 1.0$.\n- Case $3$ (boundary case, weak potential):\n  - Grid: $R_{\\max} = 20.0$, $\\Delta r = 0.001$.\n  - Channels: single $l=1$ with $V_{0,1} = 1.0 \\times 10^{-4}$, $r_{c,1} = 1.0$, $\\alpha_1 = 1.2$.\n  - Test state: $L=1$, $\\alpha_{\\psi} = 0.8$.\n- Case $4$ (edge case, angular mismatch):\n  - Grid: $R_{\\max} = 20.0$, $\\Delta r = 0.001$.\n  - Channels: two channels:\n    - $l=0$ with $V_{0,0} = -1.0$, $r_{c,0} = 1.5$, $\\alpha_0 = 1.0$,\n    - $l=1$ with $V_{0,1} = 2.0$, $r_{c,1} = 1.2$, $\\alpha_1 = 1.1$.\n  - Test state: $L=2$, $\\alpha_{\\psi} = 1.0$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list entries must be the nonlocal energies for the four cases, in Hartree, rounded to six decimal places, for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$.",
            "solution": "The problem requires the implementation of the Kleinman-Bylander (KB) separable form of a nonlocal pseudopotential for a spherically symmetric system. The solution involves deriving the necessary expressions from first principles and then constructing a numerical program to evaluate the nonlocal energy contribution for several test cases. All mathematical entities are rendered in LaTeX as required.\n\n**1. Theoretical Formulation**\n\nThe nonlocal part of the pseudopotential, in its semi-local form, acts on a wavefunction $|\\psi\\rangle$ within specific angular momentum channels. The semi-local operator $\\hat{V}_{\\mathrm{sl}}$ is given by:\n$$ \\hat{V}_{\\mathrm{sl}} = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} |Y_{lm}\\rangle V_l(r) \\langle Y_{lm}| $$\nwhere $|Y_{lm}\\rangle \\langle Y_{lm}|$ is the projector onto the angular momentum channel $(l,m)$, and $V_l(r)$ is the radial potential for that channel. The problem provides the functional form $V_l(r) = V_{0,l} \\exp\\left[-(r/r_{c,l})^2\\right]$. The inner product is defined with the measure $d^3\\mathbf{r} = r^2 dr \\, d\\Omega$.\n\nThe Kleinman-Bylander (KB) scheme replaces this operator with a computationally efficient separable operator:\n$$ \\hat{V}_{\\mathrm{KB}} = \\sum_{l,m} |\\chi_{lm}\\rangle D_l \\langle \\chi_{lm}| $$\nThis form is constructed using a set of normalized reference pseudo-wavefunctions, one for each channel $l$, given by $|\\phi^{\\mathrm{ref}}_{lm}\\rangle = R^{\\mathrm{ref}}_l(r) Y_{lm}(\\theta, \\phi)$.\n\n**1.1. Normalization of Radial Functions**\n\nThe radial functions, for both the reference states $R^{\\mathrm{ref}}_l(r)$ and the test state $R^{\\psi}_L(r)$, are of the form $R(r) = \\mathcal{N} r^k e^{-\\alpha r}$. Normalization requires $\\int_0^{\\infty} dr \\, r^2 \\, |R(r)|^2 = 1$.\n$$ \\int_0^{\\infty} dr \\, r^2 \\left( \\mathcal{N} r^k e^{-\\alpha r} \\right)^2 = \\mathcal{N}^2 \\int_0^{\\infty} dr \\, r^{2k+2} e^{-2\\alpha r} = 1 $$\nThis is a standard integral related to the Gamma function, $\\int_0^{\\infty} x^n e^{-ax} dx = n!/a^{n+1}$. By setting $n=2k+2$ and $a=2\\alpha$, we get:\n$$ \\mathcal{N}^2 \\frac{(2k+2)!}{(2\\alpha)^{2k+3}} = 1 $$\nThis yields the analytical normalization constant:\n$$ \\mathcal{N}_k = \\sqrt{\\frac{(2\\alpha)^{2k+3}}{(2k+2)!}} $$\nFor a reference state with angular momentum $l$, we use $k=l$ and $\\alpha=\\alpha_l$. For the test state with angular momentum $L$, we use $k=L$ and $\\alpha=\\alpha_{\\psi}$.\n\n**1.2. The KB Projector and Coupling Strength**\n\nThe KB projector function $|\\chi_{lm}\\rangle$ is defined by the action of the semi-local potential on the reference state:\n$$ |\\chi_{lm}\\rangle = \\hat{V}_{\\mathrm{sl}} |\\phi^{\\mathrm{ref}}_{lm}\\rangle = V_l(r) |\\phi^{\\mathrm{ref}}_{lm}\\rangle = V_l(r) R^{\\mathrm{ref}}_l(r) Y_{lm}(\\theta, \\phi) $$\nThis shows that the projector function is also separable, with a radial part $\\chi_l(r) = V_l(r) R^{\\mathrm{ref}}_l(r)$ and the same angular part $Y_{lm}(\\theta, \\phi)$.\n\nThe coupling strength $D_l$ is determined by the condition that the KB operator must reproduce the action of the semi-local operator on the reference state itself, $\\hat{V}_{\\mathrm{KB}}|\\phi^{\\mathrm{ref}}_{lm}\\rangle = \\hat{V}_{\\mathrm{sl}}|\\phi^{\\mathrm{ref}}_{lm}\\rangle$. This implies:\n$$ D_l \\langle \\chi_{lm} | \\phi^{\\mathrm{ref}}_{lm} \\rangle = 1 $$\nwhich leads to:\n$$ D_l = \\frac{1}{\\langle \\phi^{\\mathrm{ref}}_{lm} | \\hat{V}_{\\mathrm{sl}} | \\phi^{\\mathrm{ref}}_{lm} \\rangle} $$\nThe denominator is the expectation value of the semi-local potential with respect to the reference state. Due to the spherical symmetry of $V_l(r)$ and the orthonormality of $Y_{lm}$, this value is independent of $m$:\n$$ \\langle \\phi^{\\mathrm{ref}}_{lm} | \\hat{V}_{\\mathrm{sl}} | \\phi^{\\mathrm{ref}}_{lm} \\rangle = \\int_0^{\\infty} dr \\, r^2 \\, V_l(r) \\left[R^{\\mathrm{ref}}_l(r)\\right]^2 $$\n\n**1.3. Nonlocal Energy Contribution**\n\nThe nonlocal energy for a test state $|\\psi\\rangle$ is the expectation value $E_{\\mathrm{nl}} = \\langle \\psi | \\hat{V}_{\\mathrm{KB}} | \\psi \\rangle$.\n$$ E_{\\mathrm{nl}} = \\langle \\psi | \\left( \\sum_{l,m} |\\chi_{lm}\\rangle D_l \\langle \\chi_{lm}| \\right) | \\psi \\rangle = \\sum_{l,m} D_l |\\langle \\chi_{lm} | \\psi \\rangle|^2 $$\nThe test state is given as $|\\psi\\rangle = R^{\\psi}_L(r) Y_{L0}(\\theta, \\phi)$. We evaluate the overlap integral $\\langle \\chi_{lm} | \\psi \\rangle$:\n$$ \\langle \\chi_{lm} | \\psi \\rangle = \\int d^3\\mathbf{r} \\, \\left[\\chi_l(r) Y_{lm}(\\theta, \\phi)\\right]^* \\left[R^{\\psi}_L(r) Y_{L0}(\\theta, \\phi)\\right] $$\nUsing the volume element $d^3\\mathbf{r} = r^2 dr \\, d\\Omega$ and separating the integrals:\n$$ \\langle \\chi_{lm} | \\psi \\rangle = \\left( \\int_0^{\\infty} dr \\, r^2 \\, \\chi_l(r) R^{\\psi}_L(r) \\right) \\left( \\int d\\Omega \\, Y_{lm}^*(\\Omega) Y_{L0}(\\Omega) \\right) $$\nThe angular integral evaluates to $\\delta_{lL} \\delta_{m0}$ due to the orthonormality of the spherical harmonics. This is a crucial selection rule: a contribution to the energy only occurs if the pseudopotential has a channel $l$ that matches the test state's angular momentum $L$. Furthermore, since the test state has magnetic quantum number $m_{\\psi}=0$, only the $m=0$ component of the projector sum contributes.\n\nThe sum over $l,m$ collapses. If a channel with $l=L$ exists in the pseudopotential definition, its contribution is:\n$$ E_{\\mathrm{nl}}(L) = D_L |\\langle \\chi_{L0} | \\psi \\rangle|^2 $$\nSubstituting the expressions for $D_L$ and $\\langle \\chi_{L0} | \\psi \\rangle$, we arrive at the final formula for the nonlocal energy:\n$$ E_{\\mathrm{nl}} = \\frac{\\left( \\int_0^\\infty dr \\, r^2 \\, V_L(r) R^{\\mathrm{ref}}_L(r) R^{\\psi}_L(r) \\right)^2}{\\int_0^\\infty dr \\, r^2 \\, V_L(r) \\left[R^{\\mathrm{ref}}_L(r)\\right]^2} $$\nIf no channel with $l=L$ is defined, the angular momentum selection rule ensures that $E_{\\mathrm{nl}} = 0$.\n\n**2. Computational Procedure**\n\nThe implementation follows directly from the derived formula, using numerical methods to evaluate the integrals on a discrete grid.\n\n1.  **Grid Discretization**: A uniform radial grid $r_i$ is defined from $r=0$ to $r=R_{\\max}$ with spacing $\\Delta r$. All radial functions are represented as arrays of their values on this grid.\n\n2.  **Numerical Integration**: All radial integrals of a function $f(r)$ of the form $\\int_0^{R_{\\max}} dr \\, r^2 f(r)$ are approximated using the trapezoidal rule, which is numerically stable and accurate for a sufficiently fine grid. This is implemented efficiently in `numpy` via `numpy.trapz(f * r**2, r)`.\n\n3.  **Radial Function Normalization**: For maximal consistency between the normalization and the subsequent energy integrals, the radial functions are normalized numerically on the discrete grid. For an unnormalized function $u(r) = r^k e^{-\\alpha r}$, the normalization constant $\\mathcal{N}$ is calculated as $\\mathcal{N} = 1/\\sqrt{\\int_0^{R_{\\max}} dr \\, r^2 [u(r)]^2}$, where the integral is computed numerically. The normalized function is then $R(r) = \\mathcal{N} u(r)$.\n\n4.  **Energy Calculation Algorithm**: For each test case defined by its grid, channels, and test state parameters:\n    a. Set up the radial grid $r$.\n    b. Initialize the total nonlocal energy $E_{\\mathrm{nl}} = 0$.\n    c. Generate the normalized test state radial function $R^{\\psi}_L(r)$ using its parameters $L$ and $\\alpha_{\\psi}$.\n    d. Iterate through each defined pseudopotential channel $(l, V_{0,l}, r_{c,l}, \\alpha_l)$.\n    e. **Apply Selection Rule**: If $l \\neq L$, the overlap integral is zero, so the contribution is $0$. The algorithm proceeds to the next channel.\n    f. **If $l = L$**:\n        i. Generate the normalized reference radial function $R^{\\mathrm{ref}}_l(r)$ for this channel.\n        ii. Generate the radial potential $V_l(r)$.\n        iii. Calculate the numerator integral: $I_{\\mathrm{num}} = \\int dr \\, r^2 V_l(r) R^{\\mathrm{ref}}_l(r) R^{\\psi}_L(r)$.\n        iv. Calculate the denominator integral: $I_{\\mathrm{den}} = \\int dr \\, r^2 V_l(r) [R^{\\mathrm{ref}}_l(r)]^2$.\n        v. If $|I_{\\mathrm{den}}|$ is non-negligible, compute the channel's energy contribution $E_l = I_{\\mathrm{num}}^2 / I_{\\mathrm{den}}$ and add it to $E_{\\mathrm{nl}}$.\n    g. The final result for the test case is the accumulated value of $E_{\\mathrm{nl}}$. Case $4$ serves as a specific test of the selection rule, as the test state angular momentum $L=2$ does not match any of the available channels ($l=0, 1$), correctly yielding an energy of $0$.\n\nThis procedure is implemented in the provided Python code, which computes the nonlocal energy for each specified test case.",
            "answer": "```python\nimport numpy as np\n\n# Although scipy is permitted, it is not strictly necessary for this implementation.\n# np.trapz and np.power are sufficient.\n\ndef get_normalized_radial_function(k, alpha, r_grid):\n    \"\"\"\n    Computes a normalized radial function of the form N * r^k * exp(-alpha*r).\n\n    The function is normalized numerically on the given grid using the trapezoidal rule,\n    such that integral(dr * r^2 * |R(r)|^2) = 1.\n\n    Args:\n        k (int): The power of r (angular momentum quantum number).\n        alpha (float): The exponent in the exponential decay.\n        r_grid (np.ndarray): The radial grid points.\n\n    Returns:\n        np.ndarray: The array of normalized radial function values on the grid.\n    \"\"\"\n    # Using np.power handles the case of 0**0 = 1 correctly.\n    unnormalized_wf = np.power(r_grid, k) * np.exp(-alpha * r_grid)\n\n    # The integrand for the normalization integral includes the r^2 measure.\n    integrand_norm = unnormalized_wf**2 * r_grid**2\n    \n    # Integrate using the trapezoidal rule.\n    norm_sq = np.trapz(integrand_norm, r_grid)\n    \n    # Avoid division by zero if the norm is zero.\n    if norm_sq  1e-30:\n        return np.zeros_like(r_grid)\n\n    normalization_constant = 1.0 / np.sqrt(norm_sq)\n    \n    return normalization_constant * unnormalized_wf\n\ndef calculate_nonlocal_energy(R_max, dr, channels, L, alpha_psi):\n    \"\"\"\n    Calculates the Kleinman-Bylander nonlocal energy contribution.\n\n    Args:\n        R_max (float): The maximum radius for the radial grid.\n        dr (float): The step size for the radial grid.\n        channels (list of tuples): A list of pseudopotential channels.\n                                   Each tuple is (l, V0, rc, alpha_l).\n        L (int): The angular momentum of the test state.\n        alpha_psi (float): The exponent for the test state.\n\n    Returns:\n        float: The calculated nonlocal energy in Hartrees.\n    \"\"\"\n    # 1. Set up the radial grid.\n    r_grid = np.arange(0, R_max + dr, dr)\n    \n    total_energy = 0.0\n    \n    # 2. Generate the normalized test state radial function.\n    R_psi = get_normalized_radial_function(L, alpha_psi, r_grid)\n    \n    # 3. Loop over the provided pseudopotential channels.\n    for channel in channels:\n        l, V0, rc, alpha_l = channel\n        \n        # 4. Apply the angular momentum selection rule.\n        #    A contribution exists only if the channel's 'l' matches the test state's 'L'.\n        if l != L:\n            continue\n            \n        # 5. If l == L, calculate the energy contribution.\n        #    Generate the normalized reference radial function for the channel.\n        R_ref_l = get_normalized_radial_function(l, alpha_l, r_grid)\n        \n        # 6. Generate the channel potential V_l(r).\n        #    Handle potential division by zero for rc, though not in test cases.\n        if rc == 0:\n            V_l = np.zeros_like(r_grid) # Or handle as an error\n        else:\n            V_l = V0 * np.exp(-(r_grid / rc)**2)\n        \n        # 7. Calculate the numerator and denominator integrals for the energy expression.\n        #    The expression is E_nl = (Integral_num)^2 / Integral_den.\n        \n        # Numerator integral: chi_l | R_psi_rad = V_l*R_ref | R_psi_rad\n        integrand_num = V_l * R_ref_l * R_psi * r_grid**2\n        integral_num = np.trapz(integrand_num, r_grid)\n        \n        # Denominator integral: chi_l | R_ref_rad = V_l*R_ref | R_ref_rad\n        integrand_den = V_l * (R_ref_l**2) * r_grid**2\n        integral_den = np.trapz(integrand_den, r_grid)\n        \n        # 8. Calculate the energy contribution.\n        #    Avoid division by zero if the denominator integral is negligible.\n        if np.abs(integral_den)  1e-15:\n            energy_contribution = 0.0\n        else:\n            energy_contribution = integral_num**2 / integral_den\n            \n        total_energy += energy_contribution\n        \n    return total_energy\n\ndef solve():\n    \"\"\"\n    Defines the test suite and computes the results for each case.\n    \"\"\"\n    # Test cases are defined as a list of tuples. Each tuple contains\n    # the parameters for one call to calculate_nonlocal_energy.\n    # Format: (R_max, dr, channels, L, alpha_psi)\n    # where channels is a list of tuples: (l, V0, rc, alpha_l)\n    test_cases = [\n        # Case 1 (happy path, s-channel)\n        (20.0, 0.001, [(0, -2.0, 1.2, 1.0)], 0, 0.8),\n        # Case 2 (happy path, p-channel)\n        (20.0, 0.001, [(1, 3.0, 1.0, 1.2)], 1, 1.0),\n        # Case 3 (boundary case, weak potential)\n        (20.0, 0.001, [(1, 1.0e-4, 1.0, 1.2)], 1, 0.8),\n        # Case 4 (edge case, angular mismatch)\n        (20.0, 0.001, [(0, -1.0, 1.5, 1.0), (1, 2.0, 1.2, 1.1)], 2, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        R_max, dr, channels, L, alpha_psi = case\n        energy = calculate_nonlocal_energy(R_max, dr, channels, L, alpha_psi)\n        # Round the result to six decimal places as required.\n        results.append(round(energy, 6))\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While powerful, pseudopotentials must be carefully constructed to avoid unphysical artifacts that can invalidate a simulation. One of the most notorious pitfalls is the \"ghost state,\" a spurious, deeply-bound eigenstate that arises from an overly attractive nonlocal projector. This exercise uses a simplified one-dimensional model to demonstrate precisely how a ghost state emerges, how it traps the ground-state solution at an unphysical energy, and what its characteristic signatures are, providing crucial diagnostic skills for pseudopotential validation. ",
            "id": "2454657",
            "problem": "Consider a one-electron model designed to illustrate how an improperly constructed Effective Core Potential (ECP) can generate spurious bound solutions called \"ghost states.\" Work in atomic units, where the electron mass, elementary charge, reduced Planck constant, and Coulomb constant are all equal to $1$. In this model, the electron moves on a $1$-dimensional line segment with coordinate $x \\in [-L,L]$ and Dirichlet boundary conditions $\\psi(-L)=\\psi(L)=0$. The time-independent Schrödinger equation is\n$$\n\\hat{H}\\,\\psi(x) \\;=\\; E\\,\\psi(x),\n$$\nwith Hamiltonian\n$$\n\\hat{H} \\;=\\; -\\frac{1}{2}\\frac{d^2}{dx^2} \\;+\\; V_{\\mathrm{loc}}(x) \\;+\\; \\hat{V}_{\\mathrm{nl}}.\n$$\nThe local part models a soft Coulomb attraction from an effective nucleus and a short-range repulsive core bump intended to mimic the exclusion of core states:\n$$\nV_{\\mathrm{loc}}(x) \\;=\\; -\\frac{Z_{\\mathrm{eff}}}{\\sqrt{x^2+a^2}} \\;+\\; B\\,\\exp\\!\\left(-\\frac{x^2}{r_c^2}\\right),\n$$\nwhere $Z_{\\mathrm{eff}}$ is the effective nuclear charge, $a$ is the softening length, $B$ is the bump amplitude, and $r_c$ is the bump range. The nonlocal ECP component is taken as a rank-$1$ projector\n$$\n\\hat{V}_{\\mathrm{nl}} \\;=\\; W\\,|g\\rangle\\langle g|,\n$$\nwhere $W$ is a real scalar strength and $|g\\rangle$ is a localized \"projector\" function defined by the normalized Gaussian\n$$\ng(x) \\;=\\; \\frac{1}{(\\pi\\,\\sigma^2)^{1/4}}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right),\n$$\nwith width parameter $\\sigma0$ and normalization $\\int_{-\\infty}^{\\infty} |g(x)|^2\\,dx = 1$. The operator $\\hat{V}_{\\mathrm{nl}}$ acts on a wavefunction $\\psi(x)$ as\n$$\n(\\hat{V}_{\\mathrm{nl}}\\psi)(x) \\;=\\; W\\,g(x)\\int_{-L}^{L} g(y)\\,\\psi(y)\\,dy.\n$$\n\nYou must compute the ground-state energy $E_0$ and diagnose the presence or absence of a ghost state for several parameter sets. Define a \"ghost state\" as present if and only if both of the following conditions hold simultaneously:\n- The computed ground-state energy satisfies $E_0  E_{\\mathrm{ghost}}$, with $E_{\\mathrm{ghost}} = -2.0$ (in hartree).\n- The squared overlap between the normalized ground-state eigenfunction $\\psi_0(x)$ and the projector $g(x)$, computed as\n$$\n\\mathcal{O} \\;=\\; \\left|\\int_{-L}^{L} g(x)\\,\\psi_0(x)\\,dx\\right|^2,\n$$\nsatisfies $\\mathcal{O}  \\mathcal{O}_{\\mathrm{thr}}$, with $\\mathcal{O}_{\\mathrm{thr}} = 0.8$.\n\nAll integrals are to be evaluated over the finite interval $[-L,L]$. Use the following fixed constants:\n- Domain half-length $L = 10$ (in bohr).\n- Grid points $N = 1201$ (use Dirichlet boundary conditions at the endpoints).\n- Effective nuclear charge $Z_{\\mathrm{eff}} = 1.0$ (dimensionless).\n- Softening length $a = 0.8$ (in bohr).\n- Core bump amplitude $B = 5.0$ (in hartree).\n- Core bump range $r_c = 0.4$ (in bohr).\n- Ghost energy threshold $E_{\\mathrm{ghost}} = -2.0$ (in hartree).\n- Overlap threshold $\\mathcal{O}_{\\mathrm{thr}} = 0.8$ (dimensionless).\n\nConstruct the Hamiltonian on the stated domain with the above $V_{\\mathrm{loc}}(x)$ and $\\hat{V}_{\\mathrm{nl}}$ (with $g(x)$ renormalized on $[-L,L]$ so that $\\int_{-L}^{L} |g(x)|^2\\,dx = 1$), and compute the lowest eigenvalue $E_0$ and corresponding normalized eigenfunction $\\psi_0(x)$ (normalized with respect to the integral $\\int_{-L}^{L} |\\psi_0(x)|^2\\,dx = 1$). Express all energies in hartree. Do not approximate angles; no angular quantities are involved.\n\nTest suite. For coverage, evaluate the following four cases, each specified by the pair $(W,\\sigma)$:\n- Case A (nominal attractive nonlocal): $(W,\\sigma) = (-1.0,\\,0.5)$.\n- Case B (strong attractive nonlocal; likely ghost): $(W,\\sigma) = (-30.0,\\,0.5)$.\n- Case C (very strong and narrow projector; extreme ghost): $(W,\\sigma) = (-80.0,\\,0.2)$.\n- Case D (no nonlocal term): $(W,\\sigma) = (0.0,\\,0.5)$.\n\nFor each case, your program must return two items: the ground-state energy $E_0$ (as a floating-point number) and the ghost-state diagnostic (as a boolean that is true if a ghost is present and false otherwise), in that order.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, aggregating the four cases sequentially as\n$$\n[\\;E_0^{\\mathrm{A}},\\;\\mathrm{ghost}^{\\mathrm{A}},\\;E_0^{\\mathrm{B}},\\;\\mathrm{ghost}^{\\mathrm{B}},\\;E_0^{\\mathrm{C}},\\;\\mathrm{ghost}^{\\mathrm{C}},\\;E_0^{\\mathrm{D}},\\;\\mathrm{ghost}^{\\mathrm{D}}\\;].\n$$\nAll energies must be expressed in hartree and rounded to six decimal places. The booleans must be unquoted literals. The entire list must be printed on a single line.",
            "solution": "The posed problem requires building a principled model Hamiltonian that incorporates a nonlocal Effective Core Potential (ECP) term known to be capable of producing ghost states, and then diagnosing those states from first principles. The foundational law is the time-independent Schrödinger equation\n$$\n\\hat{H}\\psi(x) \\;=\\; E\\psi(x),\n$$\nwhich in atomic units has kinetic operator $-\\frac{1}{2}\\frac{d^2}{dx^2}$. The local ionic field is modeled by a soft Coulomb $-\\frac{Z_{\\mathrm{eff}}}{\\sqrt{x^2+a^2}}$, which is finite at $x=0$ and mimics long-range attraction, plus a repulsive Gaussian bump $B\\exp\\!\\left(-\\frac{x^2}{r_c^2}\\right)$ that suppresses core-like amplitude. The nonlocal ECP is a rank-$1$ projector,\n$$\n\\hat{V}_{\\mathrm{nl}} \\;=\\; W\\,|g\\rangle\\langle g|,\n$$\nwhere $W0$ creates an attractive interaction focused in the subspace spanned by $|g\\rangle$. If $|W|$ is too large or $g(x)$ is too localized (small $\\sigma$), the spectrum acquires a spurious deeply bound state with eigenfunction strongly aligned with $g(x)$; this is the ghost state.\n\nWe discretize the problem on a uniform grid on the interval $[-L,L]$ with $N$ points, imposing Dirichlet boundary conditions. Let the grid spacing be\n$$\nh \\;=\\; \\frac{2L}{N-1},\n$$\nand work on the $N-2$ interior points so that the kinetic operator is represented by the standard second-order centered finite-difference Laplacian. The kinetic matrix for the interior unknowns has main diagonal entries\n$$\n\\frac{1}{h^2}\n$$\nand first off-diagonal entries\n$$\n-\\frac{1}{2h^2},\n$$\narising from $-\\frac{1}{2}\\frac{d^2}{dx^2}$ applied to the three-point stencil $(\\psi_{i+1}-2\\psi_i+\\psi_{i-1})/h^2$.\n\nThe local potential is diagonal with entries $V_{\\mathrm{loc}}(x_i)$. The nonlocal operator is implemented in discrete form by approximating the continuum action\n$$\n(\\hat{V}_{\\mathrm{nl}}\\psi)(x) \\;=\\; W\\,g(x)\\int_{-L}^{L} g(y)\\psi(y)\\,dy\n$$\nwith the Riemann sum\n$$\n(\\hat{V}_{\\mathrm{nl}}\\boldsymbol{\\psi})_i \\;\\approx\\; W\\,g_i \\left(h\\sum_j g_j \\psi_j\\right),\n$$\nwhere $g_i=g(x_i)$ are samples on the interior grid. To ensure that the operator matches the continuum definition, $g(x)$ is renormalized on the finite domain so that\n$$\nh\\sum_j g_j^2 \\;=\\; 1.\n$$\nWith this convention, the discrete nonlocal operator has the rank-$1$ form\n$$\n\\mathbf{V}_{\\mathrm{nl}} \\;=\\; W\\,h\\,\\mathbf{g}\\,\\mathbf{g}^{\\mathsf{T}},\n$$\nand its action on a vector is $(\\mathbf{V}_{\\mathrm{nl}}\\boldsymbol{\\psi}) = W\\,\\mathbf{g}\\,(h\\,\\mathbf{g}^{\\mathsf{T}}\\boldsymbol{\\psi})$.\n\nThe total Hamiltonian matrix acting on interior grid values is thus\n$$\n\\mathbf{H} \\;=\\; \\mathbf{T} \\;+\\; \\mathrm{diag}\\!\\left(V_{\\mathrm{loc}}(x_i)\\right) \\;+\\; W\\,h\\,\\mathbf{g}\\,\\mathbf{g}^{\\mathsf{T}},\n$$\nwhich is real symmetric. The lowest eigenpair $(E_0,\\boldsymbol{\\psi}_0)$ is computed by solving\n$$\n\\mathbf{H}\\,\\boldsymbol{\\psi}_0 \\;=\\; E_0\\,\\boldsymbol{\\psi}_0.\n$$\nTo assess the ghost-state criterion, first renormalize $\\boldsymbol{\\psi}_0$ to unit $L^2$ norm with respect to the continuum inner product:\n$$\n\\boldsymbol{\\psi}_0 \\;\\leftarrow\\; \\frac{\\boldsymbol{\\psi}_0}{\\sqrt{h\\sum_j \\psi_{0,j}^2}}.\n$$\nCompute the overlap\n$$\n\\mathcal{O} \\;=\\; \\left|h\\sum_j g_j \\psi_{0,j}\\right|^2.\n$$\nA ghost is declared when $E_0  E_{\\mathrm{ghost}}$ with $E_{\\mathrm{ghost}}=-2.0$ and $\\mathcal{O}  \\mathcal{O}_{\\mathrm{thr}}$ with $\\mathcal{O}_{\\mathrm{thr}}=0.8$.\n\nPhysical interpretation: For modest negative $W$ (Case A), the nonlocal attraction slightly perturbs the valence-like bound state; $E_0$ remains near the expected shallow binding from the soft Coulomb potential, and $\\mathcal{O}$ is not excessively large. In strong-attraction settings (Cases B and C), the projector creates an artificial state essentially equal to $g(x)$, with energy $E_0$ pushed far below physically reasonable values and with $\\mathcal{O}\\approx 1$, thus satisfying the ghost criteria. With $W=0$ (Case D), the spectrum is governed by the local potential only; a valence-like bound state exists with moderate binding energy and small to moderate overlap with $g(x)$, failing the ghost criteria.\n\nNumerical outputs: The program constructs the grid and operators with the fixed parameters $L=10$, $N=1201$, $Z_{\\mathrm{eff}}=1.0$, $a=0.8$, $B=5.0$, $r_c=0.4$, and then evaluates the four $(W,\\sigma)$ pairs. For each, it computes $E_0$ and the ghost diagnostic, rounds energies to six decimal places (hartree), and outputs on a single line in the required aggregated list format\n$$\n[\\;E_0^{\\mathrm{A}},\\;\\mathrm{ghost}^{\\mathrm{A}},\\;E_0^{\\mathrm{B}},\\;\\mathrm{ghost}^{\\mathrm{B}},\\;E_0^{\\mathrm{C}},\\;\\mathrm{ghost}^{\\mathrm{C}},\\;E_0^{\\mathrm{D}},\\;\\mathrm{ghost}^{\\mathrm{D}}\\;].\n$$\nThis demonstrates, from first principles, how an excessively attractive nonlocal ECP term can induce a spurious, deeply bound, projector-dominated eigenstate that is unphysical for the valence problem and constitutes a \"ghost state.\"",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import eigsh\nfrom math import sqrt, pi\n\ndef build_operators(L, N, Z_eff, a_soft, B_core, r_c, W, sigma):\n    \"\"\"\n    Build the components needed to apply the Hamiltonian H = T + V_loc + V_nl\n    on the interior grid points with Dirichlet boundaries at x = +-L.\n\n    Returns:\n        x (np.ndarray): interior grid points (size M = N-2)\n        h (float): grid spacing\n        T (scipy.sparse.csr_matrix): kinetic operator\n        Vloc (np.ndarray): local potential evaluated at interior points\n        g (np.ndarray): normalized projector samples on the grid (L2 norm on [-L,L] equals 1)\n        W (float): projector strength (returned for convenience)\n    \"\"\"\n    # Grid\n    h = 2.0 * L / (N - 1)\n    x_full = np.linspace(-L, L, N)\n    # Interior points (Dirichlet at boundaries)\n    x = x_full[1:-1]\n    M = x.size\n\n    # Kinetic operator (finite-difference, Dirichlet boundaries)\n    inv_h2 = 1.0 / (h * h)\n    main_diag = np.full(M, inv_h2)\n    off_diag = np.full(M - 1, -0.5 * inv_h2)\n    T = diags([off_diag, main_diag, off_diag], offsets=[-1, 0, 1], format='csr')\n\n    # Local potential: soft Coulomb + Gaussian core bump\n    V_soft = -Z_eff / np.sqrt(x * x + a_soft * a_soft)\n    V_core = B_core * np.exp(-(x / r_c) ** 2)\n    Vloc = V_soft + V_core\n\n    # Projector g(x): normalized Gaussian on [-L, L] with integral norm 1\n    g_unnorm = (1.0 / (pi * sigma * sigma)) ** 0.25 * np.exp(-0.5 * (x / sigma) ** 2)\n    # Normalize with respect to integral inner product on the discrete grid\n    norm_g = np.sqrt(h * np.dot(g_unnorm, g_unnorm))\n    if norm_g == 0.0:\n        # Should never happen, but guard against division by zero\n        g = np.zeros_like(g_unnorm)\n    else:\n        g = g_unnorm / norm_g\n\n    return x, h, T, Vloc, g, W\n\ndef apply_hamiltonian_factory(T, Vloc, g, W, h):\n    \"\"\"\n    Returns a function that applies H to a vector v:\n    H v = T v + Vloc * v + W * g * (h * g^T v)\n    \"\"\"\n    def H_mv(v):\n        # Kinetic term\n        Tv = T.dot(v)\n        # Local potential term\n        Vv = Vloc * v\n        # Nonlocal projector term: W * g * (h * g^T v)\n        proj_coeff = h * np.dot(g, v)\n        Vnl_v = W * g * proj_coeff\n        return Tv + Vv + Vnl_v\n    return H_mv\n\ndef ground_state_energy_and_ghost(L, N, Z_eff, a_soft, B_core, r_c, W, sigma,\n                                  E_ghost_thr=-2.0, overlap_thr=0.8):\n    \"\"\"\n    Compute ground-state energy and ghost-state diagnostic for given parameters.\n    \"\"\"\n    # Build operators\n    x, h, T, Vloc, g, W = build_operators(L, N, Z_eff, a_soft, B_core, r_c, W, sigma)\n    M = x.size\n\n    # Build a LinearOperator via function for efficient eigensolve\n    from scipy.sparse.linalg import LinearOperator\n    H_mv = apply_hamiltonian_factory(T, Vloc, g, W, h)\n    H = LinearOperator((M, M), matvec=H_mv, dtype=np.float64)\n\n    # Compute the smallest algebraic eigenvalue (ground state) and eigenvector\n    # Use eigsh with k=1 and which='SA' for smallest algebraic\n    E_vals, E_vecs = eigsh(H, k=1, which='SA', tol=1e-10, maxiter=5000)\n    E0 = float(E_vals[0])\n    psi0 = E_vecs[:, 0]\n\n    # Normalize psi0 with respect to integral inner product\n    norm_int = np.sqrt(h * np.dot(psi0, psi0))\n    if norm_int != 0.0:\n        psi0_int = psi0 / norm_int\n    else:\n        psi0_int = psi0.copy()\n\n    # Overlap with projector g\n    overlap = h * float(np.dot(g, psi0_int))\n    O_sq = overlap * overlap\n\n    # Ghost diagnostic\n    is_ghost = (E0  E_ghost_thr) and (O_sq > overlap_thr)\n\n    # Round energy to six decimals as requested\n    E0_rounded = round(E0, 6)\n\n    return E0_rounded, is_ghost\n\ndef solve():\n    # Fixed parameters (atomic units)\n    L = 10.0\n    N = 1201\n    Z_eff = 1.0\n    a_soft = 0.8\n    B_core = 5.0\n    r_c = 0.4\n\n    # Ghost criteria thresholds\n    E_ghost_thr = -2.0\n    overlap_thr = 0.8\n\n    # Test suite: (W, sigma)\n    test_cases = [\n        (-1.0, 0.5),   # Case A: nominal\n        (-30.0, 0.5),  # Case B: strong attractive nonlocal; likely ghost\n        (-80.0, 0.2),  # Case C: very strong and narrow; extreme ghost\n        (0.0, 0.5),    # Case D: no nonlocal term\n    ]\n\n    results = []\n    for W, sigma in test_cases:\n        E0, is_ghost = ground_state_energy_and_ghost(\n            L, N, Z_eff, a_soft, B_core, r_c, W, sigma,\n            E_ghost_thr=E_ghost_thr, overlap_thr=overlap_thr\n        )\n        results.append(E0)\n        results.append(is_ghost)\n\n    # Final print statement in the exact required format.\n    # Ensure booleans are printed as literals and floats as numbers.\n    out_str_elems = []\n    for val in results:\n        if isinstance(val, bool):\n            out_str_elems.append(\"True\" if val else \"False\")\n        else:\n            # Float formatting with 6 decimals\n            out_str_elems.append(f\"{val:.6f}\")\n    print(f\"[{','.join(out_str_elems)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}