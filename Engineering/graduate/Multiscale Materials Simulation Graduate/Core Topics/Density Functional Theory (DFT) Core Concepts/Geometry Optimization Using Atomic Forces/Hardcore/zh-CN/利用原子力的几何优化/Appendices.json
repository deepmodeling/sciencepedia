{
    "hands_on_practices": [
        {
            "introduction": "几何优化的核心是理解势能、原子间作用力与结构稳定性之间的基本关系。此练习利用经典的 Lennard-Jones 双原子模型，阐明了结构优化的物理基础。通过求解力为零的点来确定平衡键长，并验证能量对距离的二阶导数（曲率）为正值，你将亲手验证一个稳定构型在势能面上对应于一个局部极小值，并将这些数学条件与键长、振动频率等可观测量联系起来。",
            "id": "3811712",
            "problem": "在多尺度材料模拟中，使用诸如兰纳-琼斯势之类的粗粒化对相互作用来模拟原子间力并进行几何优化。考虑一个移除了质心运动的双原子体系（二聚体），其通过兰纳-琼斯势相互作用\n$$\nE(r) = 4 \\varepsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right],\n$$\n其中 $r$ 是原子间距，$\\varepsilon$ 设定能量标度，$\\sigma$ 设定长度标度。原子间力为 $F(r) = -\\frac{dE}{dr}$，一个机械稳定的平衡几何构型对应于 $E(r)$ 的一个具有正曲率的驻点。\n\n仅从牛顿第二定律和势能函数 $E(r)$ 的定义出发，完成以下任务：\n- 通过求解 $\\frac{dE}{dr}=0$ 来确定平衡间距 $r_{\\mathrm{eq}}$，并验证在 $r_{\\mathrm{eq}}$ 处的曲率 $\\frac{d^{2}E}{dr^{2}}$ 为正，这表明存在一个适合使用原子间力进行几何优化的局域最小值。\n- 利用从 $E(r)$ 的泰勒展开得到的谐振近似，对 $r_{\\mathrm{eq}}$ 附近的相对运动进行线性化，并以双原子体系的约化质量 $\\mu$ 和在 $r_{\\mathrm{eq}}$ 处的曲率来推导二聚体的小振幅振动角频率 $\\omega$。\n\n将您的最终结果表示为无量纲行向量\n$$\n\\left( \\frac{r_{\\mathrm{eq}}}{\\sigma} \\;\\; , \\;\\; \\frac{\\omega}{\\sqrt{\\varepsilon/(\\mu \\sigma^{2})}} \\right),\n$$\n以便不需要进行单位转换。您必须提供一个单一的闭式解析表达式。不要对您的结果进行四舍五入或近似。",
            "solution": "第一个任务是确定平衡间距 $r_{\\mathrm{eq}}$ 并验证该平衡的稳定性。该双原子体系的势能由兰纳-琼斯势给出：\n$$\nE(r) = 4 \\varepsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right] = 4 \\varepsilon \\left[ \\sigma^{12}r^{-12} - \\sigma^{6}r^{-6} \\right]\n$$\n当作用在原子上的净力为零时，体系处于平衡位置。力 $F(r)$ 是势能的负梯度，即 $F(r) = -\\frac{dE}{dr}$。因此，平衡条件为 $\\frac{dE}{dr} = 0$。\n\n我们计算 $E(r)$ 对 $r$ 的一阶导数：\n$$\n\\frac{dE}{dr} = 4 \\varepsilon \\left[ \\sigma^{12}(-12)r^{-13} - \\sigma^{6}(-6)r^{-7} \\right] = 4 \\varepsilon \\left[ -12\\sigma^{12}r^{-13} + 6\\sigma^{6}r^{-7} \\right]\n$$\n将此导数设为零以求得平衡间距 $r_{\\mathrm{eq}}$：\n$$\n4 \\varepsilon \\left[ -12\\sigma^{12}r_{\\mathrm{eq}}^{-13} + 6\\sigma^{6}r_{\\mathrm{eq}}^{-7} \\right] = 0\n$$\n由于 $4\\varepsilon \\neq 0$，括号中的项必须为零：\n$$\n12\\sigma^{12}r_{\\mathrm{eq}}^{-13} = 6\\sigma^{6}r_{\\mathrm{eq}}^{-7}\n$$\n两边同除以 $6\\sigma^{6}r_{\\mathrm{eq}}^{-13}$ (假设 $r_{\\mathrm{eq}} \\neq 0$，$\\sigma \\neq 0$)：\n$$\n2\\sigma^{6} = r_{\\mathrm{eq}}^{6}\n$$\n解出 $r_{\\mathrm{eq}}$ 可得：\n$$\nr_{\\mathrm{eq}} = (2\\sigma^{6})^{1/6} = 2^{1/6}\\sigma\n$$\n所求无量纲向量的第一个分量是 $\\frac{r_{\\mathrm{eq}}}{\\sigma}$，即：\n$$\n\\frac{r_{\\mathrm{eq}}}{\\sigma} = 2^{1/6}\n$$\n接下来，我们必须通过检查在 $r = r_{\\mathrm{eq}}$ 处势能的曲率（二阶导数） $\\frac{d^{2}E}{dr^{2}}$ 是否为正来验证该平衡是稳定的。我们将 $\\frac{dE}{dr}$ 对 $r$ 求导：\n$$\n\\frac{d^{2}E}{dr^{2}} = 4 \\varepsilon \\left[ -12\\sigma^{12}(-13)r^{-14} + 6\\sigma^{6}(-7)r^{-8} \\right] = 4 \\varepsilon \\left[ 156\\sigma^{12}r^{-14} - 42\\sigma^{6}r^{-8} \\right]\n$$\n在 $r = r_{\\mathrm{eq}}$ 处计算该表达式的值，并使用关系式 $r_{\\mathrm{eq}}^{6} = 2\\sigma^{6}$：\n$$\n\\frac{d^{2}E}{dr^{2}}\\bigg|_{r=r_{\\mathrm{eq}}} = 4 \\varepsilon \\left[ 156\\sigma^{12} (r_{\\mathrm{eq}}^{-14}) - 42\\sigma^{6} (r_{\\mathrm{eq}}^{-8}) \\right] = 4 \\varepsilon \\left[ 156\\sigma^{12} (r_{\\mathrm{eq}}^{6})^{-7/3} - 42\\sigma^{6} (r_{\\mathrm{eq}}^{6})^{-4/3} \\right]\n$$\n$$\n= 4 \\varepsilon \\left[ 156\\sigma^{12}(2\\sigma^{6})^{-7/3} - 42\\sigma^{6}(2\\sigma^{6})^{-4/3} \\right] = 4 \\varepsilon \\left[ 156\\sigma^{12}2^{-7/3}\\sigma^{-14} - 42\\sigma^{6}2^{-4/3}\\sigma^{-8} \\right]\n$$\n$$\n= 4 \\varepsilon \\left[ \\frac{156}{\\sigma^2 2^{7/3}} - \\frac{42}{\\sigma^2 2^{4/3}} \\right] = \\frac{4 \\varepsilon}{\\sigma^{2} 2^{4/3}} \\left[ \\frac{156}{2} - 42 \\right] = \\frac{4 \\varepsilon}{\\sigma^{2} 2^{4/3}} [78 - 42] = \\frac{4 \\varepsilon \\cdot 36}{\\sigma^{2} 2^{4/3}}\n$$\n由于 $\\varepsilon > 0$，曲率为正，证实了 $r_{\\mathrm{eq}}$ 对应一个稳定的能量极小值点。\n\n第二个任务是求出小振幅振动角频率 $\\omega$。在谐振近似下，运动方程为 $\\mu \\ddot{x} = -kx$，其中 $x=r-r_{\\mathrm{eq}}$ 是位移，$\\mu$ 是约化质量，劲度系数 $k$ 是势能在平衡点的曲率。\n$$\nk = \\frac{d^{2}E}{dr^{2}}\\bigg|_{r=r_{\\mathrm{eq}}} = \\frac{144 \\varepsilon}{\\sigma^{2} 2^{4/3}} = \\frac{36 \\cdot 2^2 \\varepsilon}{\\sigma^2 2^{4/3}} = 36 \\cdot 2^{2-4/3} \\frac{\\varepsilon}{\\sigma^2} = 36 \\cdot 2^{2/3} \\frac{\\varepsilon}{\\sigma^2}\n$$\n简谐振子的角频率 $\\omega$ 由下式给出：\n$$\n\\omega = \\sqrt{\\frac{k}{\\mu}} = \\sqrt{\\frac{36 \\cdot 2^{2/3} \\varepsilon}{\\mu\\sigma^{2}}} = 6 \\cdot (2^{2/3})^{1/2} \\sqrt{\\frac{\\varepsilon}{\\mu\\sigma^{2}}} = 6 \\cdot 2^{1/3} \\sqrt{\\frac{\\varepsilon}{\\mu\\sigma^{2}}}\n$$\n所求无量纲向量的第二个分量是 $\\frac{\\omega}{\\sqrt{\\varepsilon/(\\mu \\sigma^{2})}}$：\n$$\n\\frac{\\omega}{\\sqrt{\\varepsilon/(\\mu \\sigma^{2})}} = 6 \\cdot 2^{1/3}\n$$\n将这两个无量纲结果组合成指定的行向量，我们得到：\n$$\n\\left( \\frac{r_{\\mathrm{eq}}}{\\sigma} \\;\\; , \\;\\; \\frac{\\omega}{\\sqrt{\\varepsilon/(\\mu \\sigma^{2})}} \\right) = \\left( 2^{1/6} \\;\\; , \\;\\; 6 \\cdot 2^{1/3} \\right)\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2^{1/6}  6 \\cdot 2^{1/3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在确定了优化的目标（势能极小点）之后，我们需要掌握如何高效地找到它，但在高维势能面上寻找极小值并非易事。此练习通过一个典型的鞍点势能面模型，深入剖析了不同优化算法（如最速下降法、牛顿法、L-BFGS）的行为差异。通过分析这些算法在鞍点附近的表现，你将理解为何简单的梯度下降法可能会失效，以及为何在真实的材料模拟中，必须采用更复杂的策略来避免被“困”在过渡态上。",
            "id": "3811750",
            "problem": "考虑一个在多尺度材料模拟中，针对一对耦合的原子自由度，在过渡态区域附近建构的局域二次近似玩具二维势能面 (PES)，其由 $$E(x,y)=x^{2}-y^{2}+\\alpha\\, x\\, y,$$ 给出，其中 $\\alpha\\in\\mathbb{R}$ 控制模式间的耦合。基于原子力的几何优化使用 $\\mathbf{F}=-\\nabla E$ 来移动坐标以朝向更低的能量。请仅从基本定义出发，分析常见优化方案在原点驻点邻域内的行为，并提出在最小化过程中避免鞍点陷阱的策略。选择所有正确的陈述。\n\nA. 对于由 $$\\dot{\\mathbf{r}}=-\\nabla E(\\mathbf{r}),\\quad \\mathbf{r}=(x,y),$$ 定义的连续最速下降动力学，原点是一个鞍式平衡点：在与 Hessian 矩阵负曲率相关的方向上，轨迹通常会偏离原点。因此，纯粹的最速下降动力学不会被困在原点。\n\nB. 对于满足 $$0\\eta\\frac{2}{\\sqrt{\\alpha^{2}+4}}$$ 的固定步长 $\\eta$ 的离散梯度下降法，原点在所有方向上都是一个吸引不动点；因此，在这些步长条件下，梯度下降法会被鞍点捕获。\n\nC. 用于最小化的精确牛顿法，其步长为 $$\\mathbf{x}_{k+1}=\\mathbf{x}_{k}-\\mathbf{H}^{-1}\\nabla E(\\mathbf{x}_{k}),$$ 其中 $\\mathbf{H}$ 是在 $\\mathbf{x}_{k}$ 处的 Hessian 矩阵，该方法在这个二次 PES 上会将任何起始点在单次迭代中送到原点，从而收敛到鞍点，并且除非进行修改，否则对于最小化是不安全的。\n\nD. 一种信赖域修正的牛顿策略，该策略求解局域二次模型 $$\\min_{p:\\ \\|p\\|\\le \\Delta}\\ m(p)=g^{\\top}p+\\tfrac{1}{2}p^{\\top}\\mathbf{H}p,$$ 并且当 $\\mathbf{H}$ 是不定矩阵时，用 $\\mathbf{H}+\\mu \\mathbf{I}$ 替换 $\\mathbf{H}$ (选择足够大的 $\\mu0$ 以使 $\\mathbf{H}+\\mu \\mathbf{I}$ 为正定矩阵)，该策略将会产生一个下降步，并避免被鞍点吸引。\n\nE. 限制内存的 Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) 方法，配合强制执行强 Wolfe 条件的线搜索，会维持一个正定的逆 Hessian 矩阵近似，因此会生成下降方向；在这个 PES 上，对于通常的初始化，它不会收敛到鞍点。\n\nF. 基于一个将力重新缩放为 $\\mathbf{M}^{-1}\\nabla E$ 的正定矩阵 $\\mathbf{M}$ 的质量加权预处理，总可以被选择来使得有效 Hessian 矩阵 $\\mathbf{M}^{-1}\\mathbf{H}$ 为正定矩阵，从而消除鞍点行为。\n\n选择所有正确的选项。",
            "solution": "首先，我们分析给定的势能面 (PES) $E(x,y) = x^2 - y^2 + \\alpha xy$。其梯度 $\\nabla E$ 和黑森矩阵 (Hessian) $\\mathbf{H}$ 为：\n$$\n\\nabla E = \\begin{pmatrix} 2x + \\alpha y \\\\ \\alpha x - 2y \\end{pmatrix}, \\quad \\mathbf{H} = \\nabla^2 E = \\begin{pmatrix} 2  \\alpha \\\\ \\alpha  -2 \\end{pmatrix}\n$$\n令梯度为零，$\\nabla E = \\mathbf{0}$，得到唯一的驻点为原点 $(0,0)$。为了确定该驻点的性质，我们计算Hessian矩阵 $\\mathbf{H}$ 的特征值。特征方程为 $\\det(\\mathbf{H} - \\lambda\\mathbf{I}) = (2-\\lambda)(-2-\\lambda) - \\alpha^2 = \\lambda^2 - 4 - \\alpha^2 = 0$。解得特征值为 $\\lambda = \\pm \\sqrt{4 + \\alpha^2}$。由于存在一个正特征值和一个负特征值，Hessian矩阵是不定的，因此原点是一个鞍点。\n\n现在我们逐一分析每个选项：\n\n**A. 正确。** 连续最速下降动力学由方程 $\\dot{\\mathbf{r}} = -\\nabla E(\\mathbf{r}) = -\\mathbf{H}\\mathbf{r}$ 描述。该线性动力学系统的行为由矩阵 $-\\mathbf{H}$ 的特征值决定，其特征值为 $\\mp\\sqrt{4 + \\alpha^2}$。由于存在一个正特征值 ($\\sqrt{4 + \\alpha^2}$)，系统在对应的特征向量方向（不稳定流形）上会发散。除非起始点恰好位于稳定流形（一条线）上，否则轨迹将偏离原点。因此，该动力学通常不会被鞍点捕获。\n\n**B. 不正确。** 离散梯度下降的更新规则是 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\eta \\nabla E(\\mathbf{x}_k) = (\\mathbf{I} - \\eta \\mathbf{H}) \\mathbf{x}_k$。要使原点成为吸引不动点，迭代矩阵 $\\mathbf{J} = \\mathbf{I} - \\eta \\mathbf{H}$ 的所有特征值的模必须都小于1。$\\mathbf{J}$ 的特征值为 $1 - \\eta\\lambda_i$，即 $1 - \\eta\\sqrt{4+\\alpha^2}$ 和 $1 + \\eta\\sqrt{4+\\alpha^2}$。由于 $\\eta > 0$ 且 $\\sqrt{4+\\alpha^2} > 0$，第二个特征值 $1 + \\eta\\sqrt{4+\\alpha^2}$ 总是大于1。因此，在对应方向上迭代会发散，原点是一个不稳定的不动点，而不是吸引不动点。\n\n**C. 正确。** 对于二次势能面 $E(\\mathbf{x}) = E_0 + \\mathbf{g}_0^\\top \\mathbf{x} + \\frac{1}{2}\\mathbf{x}^\\top \\mathbf{H} \\mathbf{x}$，梯度为 $\\nabla E(\\mathbf{x}) = \\mathbf{g}_0 + \\mathbf{H} \\mathbf{x}$。牛顿步旨在寻找使梯度为零的点，即求解 $\\mathbf{g}_0 + \\mathbf{H} \\mathbf{x}_{k+1} = \\mathbf{0}$。更准确地说，是求解二次模型的极小点，即 $\\nabla E(\\mathbf{x}_k) + \\mathbf{H}(\\mathbf{x}_{k+1}-\\mathbf{x}_k) = 0$。对于常数Hessian，这简化为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\mathbf{H}^{-1}\\nabla E(\\mathbf{x}_k)$。代入 $\\nabla E(\\mathbf{x}_k) = \\mathbf{H}\\mathbf{x}_k$ (相对于原点)，得到 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\mathbf{H}^{-1}(\\mathbf{H}\\mathbf{x}_k) = \\mathbf{x}_k - \\mathbf{x}_k = \\mathbf{0}$。因此，牛顿法在一次迭代中就收敛到驻点（鞍点）。这对寻找能量最小值是不安全的。\n\n**D. 正确。** 信赖域方法通过求解一个约束的二次子问题来寻找步长。当Hessian矩阵 $\\mathbf{H}$ 不定时（如在鞍点），通过修正（例如 Levenberg-Marquardt 方法，用 $\\mathbf{H}+\\mu\\mathbf{I}$ 代替 $\\mathbf{H}$ 并选择足够大的 $\\mu > |\\lambda_{\\min}|$）可以确保修正后的Hessian矩阵为正定。这保证了计算出的步长方向是下降方向（即 $(\\nabla E)^\\top \\mathbf{p}  0$）。因此，算法会沿着能量下降的路径离开鞍点，而不会被其捕获。\n\n**E. 正确。** L-BFGS等准牛顿方法通过迭代更新来近似逆Hessian矩阵。一个关键特性是，如果初始近似矩阵是正定的，并且线搜索满足Wolfe条件，那么后续的所有近似矩阵都会保持正定。由于 Hessian 近似是正定的，所产生的搜索方向总是下降方向。这使得算法能够有效地沿能量下降的路径移动，从而在通常情况下避开鞍点。\n\n**F. 不正确。** 预处理的目标是改变优化问题的几何形态。有效Hessian矩阵为 $\\mathbf{M}^{-1}\\mathbf{H}$。要使其为正定，其所有特征值必须为正，这也要求其行列式为正。然而，$\\det(\\mathbf{M}^{-1}\\mathbf{H}) = \\det(\\mathbf{M}^{-1})\\det(\\mathbf{H})$。由于 $\\mathbf{M}$ 是正定的，$\\det(\\mathbf{M}^{-1}) > 0$。但我们已经知道 $\\det(\\mathbf{H}) = -4-\\alpha^2  0$。因此，$\\det(\\mathbf{M}^{-1}\\mathbf{H})  0$。一个行列式为负的矩阵不可能为正定矩阵。所以该陈述是错误的。",
            "answer": "$$\\boxed{ACDE}$$"
        },
        {
            "introduction": "从理论分析到实际应用，我们需要一个能够在真实模拟环境中（即离散时间步和含噪声的力）稳健工作的优化器。此编程练习将引导你动手实现并测试一种先进的几何优化算法——快速惯性弛豫引擎 (FIRE)。通过模拟一个含噪声的体系，你将获得宝贵的第一手经验，理解像 FIRE 这样的现代优化器是如何巧妙地结合物理直觉（牛顿第二定律）和自适应启发式方法，从而在复杂的实际条件下高效、可靠地完成结构优化任务。",
            "id": "3811703",
            "problem": "考虑在多尺度材料模拟环境中使用原子间力进行几何优化，其更新规则基于牛顿第二定律和动量对齐启发式方法。设二维欧几里得空间中一个点状原子的能量由四次势给出：$$V(\\mathbf{r})=\\frac{k}{4}\\lVert \\mathbf{r}\\rVert^4,$$ 其中 $\\mathbf{r}\\in\\mathbb{R}^2$，$k0$ 是一个刚度参数。精确原子间力由基本关系定义：$$\\mathbf{F}_{\\text{true}}(\\mathbf{r})=-\\nabla V(\\mathbf{r}).$$ 在实际模拟中，梯度会受到测量或离散化噪声的污染；通过一个观测梯度来对此建模：$$\\nabla V(\\mathbf{r})+\\boldsymbol{\\xi},$$ 其中 $\\boldsymbol{\\xi}\\sim\\mathcal{N}(\\mathbf{0},\\sigma^2\\mathbf{I})$ 是一个高斯随机向量，其分量独立且方差为 $\\sigma^2$，在每次迭代中独立采样。动力学计算中使用的观测力为：$$\\mathbf{F}(\\mathbf{r})=-(\\nabla V(\\mathbf{r})+\\boldsymbol{\\xi}) = \\mathbf{F}_{\\text{true}}(\\mathbf{r})-\\boldsymbol{\\xi}.$$\n\n从牛顿第二定律 $$m\\frac{d\\mathbf{v}}{dt}=\\mathbf{F}(\\mathbf{r}),\\quad \\frac{d\\mathbf{r}}{dt}=\\mathbf{v},$$ 出发，考虑一个时间步长为 $dt$、质量为 $m0$ 的离散时间方案。每次迭代的更新规则基于显式时间步进与快速惯性弛豫引擎（Fast Inertial Relaxation Engine, FIRE）混合相结合。在迭代 $t$，设 $\\mathbf{r}_t$ 和 $\\mathbf{v}_t$ 分别为位置和速度。计算 $\\mathbf{F}_t=\\mathbf{F}(\\mathbf{r}_t)$，然后执行显式更新：$$\\mathbf{v}_{t+\\frac{1}{2}}=\\mathbf{v}_t+\\frac{dt}{m}\\mathbf{F}_t,\\quad \\mathbf{r}_{t+1}=\\mathbf{r}_t+dt\\,\\mathbf{v}_{t+\\frac{1}{2}}.$$ 定义功率 $$P_t=\\mathbf{v}_{t+\\frac{1}{2}}\\cdot \\mathbf{F}_t.$$ 对 $\\mathbf{v}_{t+\\frac{1}{2}}$ 应用FIRE对齐步骤如下。维护一个混合参数 $\\alpha$ 和一个整数计数器 $n_{\\text{pos}}$，初始化为 $\\alpha=\\alpha_0$ 和 $n_{\\text{pos}}=0$。如果 $P_t0$，更新 $$\\mathbf{v}_{t+1}=(1-\\alpha)\\,\\mathbf{v}_{t+\\frac{1}{2}}+\\alpha\\,\\frac{\\lVert \\mathbf{v}_{t+\\frac{1}{2}}\\rVert}{\\lVert \\mathbf{F}_t\\rVert}\\,\\mathbf{F}_t,$$ 通过 $$dt\\leftarrow \\min(f_{\\mathrm{inc}}\\cdot dt,\\,dt_{\\max})$$ 增加时间步长，将计数器递增 $n_{\\text{pos}}\\leftarrow n_{\\text{pos}}+1$，并且当 $n_{\\text{pos}}N_{\\mathrm{delay}}$ 时，通过 $$\\alpha\\leftarrow \\alpha\\cdot \\alpha_{\\mathrm{decay}}$$ 减小 $\\alpha$。如果 $P_t\\le 0$，设置 $$\\mathbf{v}_{t+1}=\\mathbf{0},$$ 通过 $$dt\\leftarrow f_{\\mathrm{dec}}\\cdot dt$$ 减小时间步长，并重置 $$\\alpha\\leftarrow \\alpha_0,\\quad n_{\\text{pos}}\\leftarrow 0.$$\n\n使用上述方案从初始状态 $\\mathbf{r}_0$ 和 $\\mathbf{v}_0=\\mathbf{0}$ 开始模拟 $N$ 次迭代。对于每次模拟，将 $N$ 次迭代后梯度范数的收缩率定义为比率 $$C=\\frac{\\mathbb{E}[\\lVert \\nabla V(\\mathbf{r}_N)\\rVert]}{\\lVert \\nabla V(\\mathbf{r}_0)\\rVert},$$ 其中期望是针对所有迭代中的高斯噪声 $\\boldsymbol{\\xi}$ 计算的。通过对 $M$ 次独立重复实验进行平均来估计 $\\mathbb{E}[\\lVert \\nabla V(\\mathbf{r}_N)\\rVert]$，并使用以种子 $42$ 初始化的固定伪随机数生成器以确保可复现性。请注意，$C$ 是无量纲的；该问题以无量纲单位提出。\n\n实现该算法并为以下测试套件计算 $C$。在所有情况下，均采用二维系统（$\\mathbf{r}\\in\\mathbb{R}^2$），设置初始速度 $\\mathbf{v}_0=\\mathbf{0}$，并执行 $M$ 次独立重复实验。将每个 $C$ 报告为四舍五入到六位小数的浮点数。\n\n测试套件：\n- 情况1（无噪声基线；理想路径）：$k=1$, $m=1$, $\\sigma=0$, $\\mathbf{r}_0=[2,0]$, $dt_0=0.1$, $dt_{\\max}=0.5$, $f_{\\mathrm{inc}}=1.1$, $f_{\\mathrm{dec}}=0.5$, $\\alpha_0=0.1$, $\\alpha_{\\mathrm{decay}}=0.99$, $N_{\\mathrm{delay}}=5$, $N=50$, $M=300$。\n- 情况2（中等噪声）：$k=1$, $m=1$, $\\sigma=0.1$, $\\mathbf{r}_0=[2,0]$, $dt_0=0.1$, $dt_{\\max}=0.5$, $f_{\\mathrm{inc}}=1.1$, $f_{\\mathrm{dec}}=0.5$, $\\alpha_0=0.1$, $\\alpha_{\\mathrm{decay}}=0.99$, $N_{\\mathrm{delay}}=5$, $N=50$, $M=300$。\n- 情况3（高噪声；鲁棒性边缘情况）：$k=1$, $m=1$, $\\sigma=0.5$, $\\mathbf{r}_0=[2,0]$, $dt_0=0.1$, $dt_{\\max}=0.5$, $f_{\\mathrm{inc}}=1.1$, $f_{\\mathrm{dec}}=0.5$, $\\alpha_0=0.1$, $\\alpha_{\\mathrm{decay}}=0.99$, $N_{\\mathrm{delay}}=5$, $N=50$, $M=300$。\n- 情况4（接近静止的起始；小梯度边界）：$k=1$, $m=1$, $\\sigma=0.1$, $\\mathbf{r}_0=[0.2,-0.2]$, $dt_0=0.05$, $dt_{\\max}=0.5$, $f_{\\mathrm{inc}}=1.1$, $f_{\\mathrm{dec}}=0.5$, $\\alpha_0=0.1$, $\\alpha_{\\mathrm{decay}}=0.99$, $N_{\\mathrm{delay}}=5$, $N=50$, $M=300$。\n\n你的程序应产生单行输出，其中包含四种情况的收缩率结果，形式为逗号分隔的列表并包含在方括号中，按上述顺序列出，例如 $$[c_1,c_2,c_3,c_4],$$ 其中每个 $c_i$ 是四舍五入后的浮点数。本问题不使用角度。输出中不要包含任何额外文本。所有结果均为无量纲数。",
            "solution": "该问题要求实现一种称为快速惯性弛豫引擎（Fast Inertial Relaxation Engine, FIRE）的几何优化算法，以找到二维四次势 $V(\\mathbf{r})=\\frac{k}{4}\\lVert \\mathbf{r}\\rVert^4$ 的最小值。模拟中加入了随机噪声以模拟测量或离散化误差。目标是计算在多个测试案例中，经过固定次数迭代后的梯度范数收缩率 $C$。\n\n首先，我们确定势梯度的解析形式，这对于计算力至关重要。势能由 $V(\\mathbf{r})=\\frac{k}{4}\\lVert \\mathbf{r}\\rVert^4$ 给出，其中 $\\mathbf{r}=[x, y]^T \\in \\mathbb{R}^2$。势可以写为 $V(x,y) = \\frac{k}{4}(x^2+y^2)^2$。梯度 $\\nabla V$ 可以用向量表示法紧凑地表示为：\n$$\n\\nabla V(\\mathbf{r}) = k \\lVert \\mathbf{r} \\rVert^2 \\mathbf{r}\n$$\n真实的物理力 $\\mathbf{F}_{\\text{true}}$ 是势梯度的负值：\n$$\n\\mathbf{F}_{\\text{true}}(\\mathbf{r}) = -\\nabla V(\\mathbf{r}) = -k \\lVert \\mathbf{r} \\rVert^2 \\mathbf{r}\n$$\n模拟中使用的力是带噪声的观测值，建模为 $\\mathbf{F}(\\mathbf{r}) = \\mathbf{F}_{\\text{true}}(\\mathbf{r}) - \\boldsymbol{\\xi}$，其中 $\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2\\mathbf{I})$ 是每次迭代独立采样的二维高斯噪声。\n\n模拟的核心是FIRE算法，它是一种基于牛顿第二定律 $m\\ddot{\\mathbf{r}} = \\mathbf{F}$ 的离散时间积分方案。算法迭代进行，每次迭代从位置 $\\mathbf{r}_t$ 和速度 $\\mathbf{v}_t$ 开始，更新遵循两个主要阶段：\n\n1.  **修改的速度Verlet积分**：首先，使用一种显式时间步进方案来更新位置和一个半步速度。给定时间步长 $dt$ 和质量 $m$，更新如下：\n    $$\n    \\mathbf{v}_{t+\\frac{1}{2}}=\\mathbf{v}_t+\\frac{dt}{m}\\mathbf{F}_t\n    $$\n    $$\n    \\mathbf{r}_{t+1}=\\mathbf{r}_t+dt\\,\\mathbf{v}_{t+\\frac{1}{2}}\n    $$\n    其中 $\\mathbf{F}_t = \\mathbf{F}(\\mathbf{r}_t)$。\n\n2.  **FIRE启发式方法**：第二阶段调整下一个完整步长的速度 $\\mathbf{v}_{t+1}$，并自适应调整模拟参数 $dt$ 和 $\\alpha$。此阶段由功率 $P_t = \\mathbf{v}_{t+\\frac{1}{2}} \\cdot \\mathbf{F}_t$ 的符号控制。\n\n    -   如果 $P_t > 0$：表示运动方向与力方向一致，算法加速。\n        -   通过将 $\\mathbf{v}_{t+\\frac{1}{2}}$ 与一个大小相同但与力 $\\mathbf{F}_t$ 对齐的向量混合来更新速度：\n            $$\n            \\mathbf{v}_{t+1}=(1-\\alpha)\\,\\mathbf{v}_{t+\\frac{1}{2}}+\\alpha\\,\\frac{\\lVert \\mathbf{v}_{t+\\frac{1}{2}}\\rVert}{\\lVert \\mathbf{F}_t\\rVert}\\,\\mathbf{F}_t\n            $$\n        -   增加时间步长以加快进程，上限为 $dt_{\\max}$：$dt \\leftarrow \\min(f_{\\mathrm{inc}} \\cdot dt, dt_{\\max})$。\n        -   记录连续正功率步数的计数器 $n_{\\text{pos}}$ 递增。若 $n_{\\text{pos}} > N_{\\mathrm{delay}}$，则减小混合参数 $\\alpha \\leftarrow \\alpha \\cdot \\alpha_{\\mathrm{decay}}$，使转向不那么激进。\n\n    -   如果 $P_t \\le 0$：表示粒子可能越过了最小值点或正在“上坡”。算法进行强力修正。\n        -   通过重置速度来完全停止运动：$\\mathbf{v}_{t+1} = \\mathbf{0}$。\n        -   时间步长被急剧减小：$dt \\leftarrow f_{\\mathrm{dec}} \\cdot dt$。\n        -   状态被重置：$n_{\\text{pos}} \\leftarrow 0$，$ \\alpha \\leftarrow \\alpha_0$。\n\n模拟从初始位置 $\\mathbf{r}_0$ 和零初始速度 $\\mathbf{v}_0 = \\mathbf{0}$ 开始，运行 $N$ 次迭代。性能指标是收缩率 $C$：\n$$\nC=\\frac{\\mathbb{E}[\\lVert \\nabla V(\\mathbf{r}_N)\\rVert]}{\\lVert \\nabla V(\\mathbf{r}_0)\\rVert}\n$$\n期望 $\\mathbb{E}[\\cdot]$ 通过蒙特卡洛方法进行估计，即对 $M$ 次独立模拟重复实验的最终梯度范数 $\\lVert \\nabla V(\\mathbf{r}_N)\\rVert$ 进行平均。为确保可复现性，所有重复实验都使用以固定种子初始化的单个伪随机数生成器运行。\n\n实现包含一个主函数，该函数遍历所有测试案例。对于每个案例，它计算恒定的分母 $\\lVert \\nabla V(\\mathbf{r}_0)\\rVert$。然后，它运行 $M$ 次包含 $N$ 步的FIRE模拟重复实验。对于每次重复实验，它重新初始化状态变量并运行迭代算法。计算并存储最终的真实梯度范数。所有重复实验完成后，计算这些范数的平均值以估计 $\\mathbb{E}[\\lVert \\nabla V(\\mathbf{r}_N)\\rVert]$。最后，计算并格式化 $C$。在实现中，为避免除以零，对力的范数 $\\lVert \\mathbf{F}_t \\rVert$ 使用了一个小的容差。",
            "answer": "```python\nimport numpy as np\n\ndef grad_V(r: np.ndarray, k: float) - np.ndarray:\n    \"\"\"Computes the gradient of the potential V(r) = k/4 * ||r||^4.\"\"\"\n    r_norm_sq = np.dot(r, r)\n    return k * r_norm_sq * r\n\ndef run_single_replicate(params: dict, rng: np.random.Generator) - np.ndarray:\n    \"\"\"\n    Runs a single simulation replicate for N iterations.\n    \"\"\"\n    # Unpack parameters\n    k = params['k']\n    m = params['m']\n    sigma = params['sigma']\n    r0 = np.array(params['r0'], dtype=float)\n    dt0 = params['dt0']\n    dt_max = params['dt_max']\n    f_inc = params['f_inc']\n    f_dec = params['f_dec']\n    alpha0 = params['alpha0']\n    alpha_decay = params['alpha_decay']\n    N_delay = params['N_delay']\n    N = params['N']\n\n    # Initialize state for the replicate\n    r = r0.copy()\n    v = np.zeros_like(r0)\n    dt = dt0\n    alpha = alpha0\n    n_pos = 0\n\n    for _ in range(N):\n        # Calculate force with noise\n        grad = grad_V(r, k)\n        noise = rng.normal(scale=sigma, size=r.shape)\n        F = -(grad + noise)\n\n        # Modified Velocity-Verlet step\n        v_half = v + (dt / m) * F\n        r = r + dt * v_half\n\n        # FIRE heuristic\n        P = np.dot(v_half, F)\n\n        if P  0:\n            F_norm = np.linalg.norm(F)\n            v_half_norm = np.linalg.norm(v_half)\n            \n            # Velocity mixing/steering\n            if F_norm  1e-15:  # Numerical stability\n                v_steered = (v_half_norm / F_norm) * F\n                v = (1 - alpha) * v_half + alpha * v_steered\n            else:\n                # This case is unlikely if P  0, but as a safeguard\n                v = (1 - alpha) * v_half\n            \n            # Adapt dt and alpha\n            dt = min(f_inc * dt, dt_max)\n            n_pos += 1\n            if n_pos  N_delay:\n                alpha *= alpha_decay\n        else: # P = 0\n            # Halt and reset\n            v = np.zeros_like(r)\n            dt = f_dec * dt\n            alpha = alpha0\n            n_pos = 0\n            \n    return r\n\ndef compute_contraction(params: dict) - float:\n    \"\"\"\n    Computes the contraction ratio C by averaging over M replicates.\n    \"\"\"\n    k = params['k']\n    r0 = np.array(params['r0'], dtype=float)\n    M = params['M']\n\n    # Calculate initial gradient norm (denominator of C)\n    grad_V_r0 = grad_V(r0, k)\n    norm_grad_V_r0 = np.linalg.norm(grad_V_r0)\n\n    # If initial gradient is already zero, the problem is trivial or ill-defined.\n    if norm_grad_V_r0  1e-15:\n        return 0.0\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed=42)\n    \n    final_grad_norms = []\n    for _ in range(M):\n        # Run one full simulation from r0\n        r_final = run_single_replicate(params, rng)\n        \n        # Calculate and store the norm of the true gradient at the final position\n        grad_V_r_final = grad_V(r_final, k)\n        norm_grad_V_r_final = np.linalg.norm(grad_V_r_final)\n        final_grad_norms.append(norm_grad_V_r_final)\n    \n    # Compute the expectation by averaging over replicates\n    avg_final_grad_norm = np.mean(final_grad_norms)\n\n    # Compute and return the contraction ratio\n    C = avg_final_grad_norm / norm_grad_V_r0\n    return C\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'k': 1, 'm': 1, 'sigma': 0, 'r0': [2.0, 0.0], 'dt0': 0.1, 'dt_max': 0.5, 'f_inc': 1.1, 'f_dec': 0.5, 'alpha0': 0.1, 'alpha_decay': 0.99, 'N_delay': 5, 'N': 50, 'M': 300},\n        {'k': 1, 'm': 1, 'sigma': 0.1, 'r0': [2.0, 0.0], 'dt0': 0.1, 'dt_max': 0.5, 'f_inc': 1.1, 'f_dec': 0.5, 'alpha0': 0.1, 'alpha_decay': 0.99, 'N_delay': 5, 'N': 50, 'M': 300},\n        {'k': 1, 'm': 1, 'sigma': 0.5, 'r0': [2.0, 0.0], 'dt0': 0.1, 'dt_max': 0.5, 'f_inc': 1.1, 'f_dec': 0.5, 'alpha0': 0.1, 'alpha_decay': 0.99, 'N_delay': 5, 'N': 50, 'M': 300},\n        {'k': 1, 'm': 1, 'sigma': 0.1, 'r0': [0.2, -0.2], 'dt0': 0.05, 'dt_max': 0.5, 'f_inc': 1.1, 'f_dec': 0.5, 'alpha0': 0.1, 'alpha_decay': 0.99, 'N_delay': 5, 'N': 50, 'M': 300},\n    ]\n\n    results = []\n    for params in test_cases:\n        contraction_ratio = compute_contraction(params)\n        results.append(f\"{contraction_ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}