{
    "hands_on_practices": [
        {
            "introduction": "The Generalized Gradient Approximation (GGA) improves upon the Local Density Approximation by incorporating information about the spatial variation of the electron density. This is achieved through the reduced density gradient, $s(\\mathbf{r})$, a dimensionless quantity that measures local inhomogeneity. This foundational exercise () provides hands-on practice in deriving $s(\\mathbf{r})$ for an analytically solvable model, helping to build a concrete intuition for how it connects the electron density's shape to the core of a GGA functional.",
            "id": "3811143",
            "problem": "In multiscale materials simulation, the Generalized Gradient Approximation (GGA) for exchange-correlation within Density Functional Theory (DFT) refines the Local Density Approximation by incorporating spatial variations of the electron density. Consider a spherically symmetric, localized electron density representative of a mesoscopic embedding region around a defect, modeled as a Gaussian $n(\\mathbf{r}) = n_0 \\exp(-\\alpha r^2)$, where $r = |\\mathbf{r}|$, $n_0 > 0$ is the peak density, and $\\alpha > 0$ sets the localization scale.\n\nStarting from foundational definitions appropriate to GGA, including the Fermi wavevector $k_{\\mathrm{F}}$ of the homogeneous electron gas and the reduced density gradient used to characterize inhomogeneity, derive the explicit closed-form expression for the reduced density gradient $s(\\mathbf{r})$ for the given $n(\\mathbf{r})$. Then, within the same derivation, analyze how $s$ varies with $r$ and $\\alpha$, including the limiting behavior for small $r$ and large $r$.\n\nExpress the final answer as a single closed-form analytic expression for $s(r)$ in terms of $r$, $n_0$, and $\\alpha$. No rounding is required, and no units should be included in the final expression.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard derivation within the framework of Density Functional Theory.\n\nThe task is to derive the expression for the reduced density gradient, $s(\\mathbf{r})$, for a given spherically symmetric electron density, $n(\\mathbf{r}) = n_0 \\exp(-\\alpha r^2)$.\n\nThe derivation proceeds from the foundational definitions used in the Generalized Gradient Approximation (GGA). The reduced density gradient, $s(\\mathbf{r})$, is a dimensionless quantity that measures the local inhomogeneity of the electron gas. It is defined as:\n$$\ns(\\mathbf{r}) = \\frac{|\\nabla n(\\mathbf{r})|}{2 k_{\\mathrm{F}}(\\mathbf{r}) n(\\mathbf{r})}\n$$\nwhere $\\nabla n(\\mathbf{r})$ is the gradient of the electron density $n(\\mathbf{r})$, and $k_{\\mathrm{F}}(\\mathbf{r})$ is the local Fermi wavevector.\n\nThe local Fermi wavevector, $k_{\\mathrm{F}}(\\mathbf{r})$, is defined by treating the electron gas at position $\\mathbf{r}$ as a homogeneous electron gas with density $n(\\mathbf{r})$. For a three-dimensional system, its expression is:\n$$\nk_{\\mathrm{F}}(\\mathbf{r}) = (3\\pi^2 n(\\mathbf{r}))^{1/3}\n$$\nSubstituting this definition of $k_{\\mathrm{F}}(\\mathbf{r})$ into the expression for $s(\\mathbf{r})$ yields:\n$$\ns(\\mathbf{r}) = \\frac{|\\nabla n(\\mathbf{r})|}{2 (3\\pi^2 n(\\mathbf{r}))^{1/3} n(\\mathbf{r})} = \\frac{|\\nabla n(\\mathbf{r})|}{2 (3\\pi^2)^{1/3} n(\\mathbf{r})^{4/3}}\n$$\nNext, we must compute the gradient of the given electron density, $n(\\mathbf{r}) = n_0 \\exp(-\\alpha r^2)$, where $r = |\\mathbf{r}|$. Due to the spherical symmetry of $n$, the gradient vector will point in the radial direction, $\\hat{\\mathbf{r}}$. We can write the gradient as $\\nabla n(\\mathbf{r}) = \\frac{d n(r)}{dr} \\hat{\\mathbf{r}}$.\nWe compute the derivative with respect to $r$:\n$$\n\\frac{d n(r)}{dr} = \\frac{d}{dr} \\left( n_0 \\exp(-\\alpha r^2) \\right) = n_0 \\exp(-\\alpha r^2) (-2\\alpha r)\n$$\nRecognizing that $n_0 \\exp(-\\alpha r^2)$ is the density $n(r)$ itself, we have:\n$$\n\\frac{d n(r)}{dr} = -2\\alpha r n(r)\n$$\nThe gradient vector is therefore $\\nabla n(\\mathbf{r}) = -2\\alpha r n(r) \\hat{\\mathbf{r}}$. The magnitude of the gradient is:\n$$\n|\\nabla n(\\mathbf{r})| = |-2\\alpha r n(r)| = 2\\alpha r n(r)\n$$\nsince the parameters $\\alpha$ and $n_0$ are positive, and $r \\ge 0$.\n\nNow, we substitute this expression for $|\\nabla n(\\mathbf{r})|$ into our equation for $s(\\mathbf{r})$:\n$$\ns(\\mathbf{r}) = \\frac{2\\alpha r n(r)}{2 (3\\pi^2)^{1/3} n(r)^{4/3}}\n$$\nSimplifying this expression by canceling the factor of $2$ and combining the terms involving $n(r)$:\n$$\ns(r) = \\frac{\\alpha r}{(3\\pi^2)^{1/3} n(r)^{1/3}}\n$$\nThe dependence is only on the radial distance $r$, as expected from spherical symmetry. The final step is to substitute the explicit form of $n(r)$:\n$$\nn(r)^{1/3} = \\left( n_0 \\exp(-\\alpha r^2) \\right)^{1/3} = n_0^{1/3} \\exp\\left(-\\frac{\\alpha r^2}{3}\\right)\n$$\nInserting this into the expression for $s(r)$:\n$$\ns(r) = \\frac{\\alpha r}{(3\\pi^2)^{1/3} n_0^{1/3} \\exp\\left(-\\frac{\\alpha r^2}{3}\\right)}\n$$\nThis can be written in a more compact closed form by combining constants and moving the exponential term to the numerator:\n$$\ns(r) = \\frac{\\alpha r}{\\left(3 \\pi^2 n_0\\right)^{1/3}} \\exp\\left(\\frac{\\alpha r^2}{3}\\right)\n$$\nThis is the final closed-form expression for the reduced density gradient.\n\nAnalysis of the behavior of $s(r)$:\n$1$. Dependence on $r$:\nFor small $r$ ($r \\to 0$): The term $\\exp(\\frac{\\alpha r^2}{3})$ approaches $1$. Therefore, $s(r) \\approx \\frac{\\alpha r}{(3 \\pi^2 n_0)^{1/3}}$. The reduced gradient starts at $s(0)=0$ and increases linearly with $r$. This is physically correct, as at the center of a symmetric distribution, the gradient is zero, implying zero inhomogeneity.\nFor large $r$ ($r \\to \\infty$): Both the linear term $r$ and the exponential term $\\exp(\\frac{\\alpha r^2}{3})$ go to infinity. The exponential term dominates, causing $s(r)$ to grow extremely rapidly. This indicates that the tail of the electron distribution is a region of very high inhomogeneity, where the density changes rapidly on the scale of the local Fermi wavelength.\n\n$2$. Dependence on $\\alpha$: The parameter $\\alpha$ controls the localization of the density; a larger $\\alpha$ corresponds to a more sharply peaked, localized distribution. For any fixed radius $r > 0$, the function $s(r)$ is an increasing function of $\\alpha$. This is because both the prefactor $\\alpha$ and the argument of the exponential, $\\frac{\\alpha r^2}{3}$, increase with $\\alpha$. This aligns with the physical intuition that a more rapidly changing density profile (larger $\\alpha$) corresponds to a greater degree of inhomogeneity.\n\n$3$. Dependence on $n_0$: The quantity $s(r)$ is proportional to $n_0^{-1/3}$. Increasing the peak density $n_0$ while keeping the shape parameter $\\alpha$ fixed leads to a decrease in the reduced gradient $s$ at all points $r$. This reflects the fact that in regions of higher electron density, the system behaves more like a homogeneous electron gas, and thus the same absolute gradient $|\\nabla n|$ is considered less significant.",
            "answer": "$$\n\\boxed{\\frac{\\alpha r \\exp\\left(\\frac{\\alpha r^2}{3}\\right)}{\\left(3 \\pi^2 n_0\\right)^{1/3}}}\n$$"
        },
        {
            "introduction": "Translating the continuous equations of Density Functional Theory into a working computer program requires careful consideration of numerical algorithms and boundary conditions. This exercise () challenges you to think like a code developer, outlining a robust procedure for evaluating the GGA exchange-correlation energy and potential on a discrete grid. Successfully navigating this problem demonstrates an understanding of the crucial link between the formal theory of functional derivatives and their practical, numerically stable implementation.",
            "id": "3811195",
            "problem": "In Kohn–Sham Density Functional Theory (DFT), the exchange–correlation energy functional in the Generalized Gradient Approximation (GGA) depends on the local electron number density $n(\\mathbf{r})$ and its gradient $\\nabla n(\\mathbf{r})$. For a spin-unpolarized system discretized on a uniform, three-dimensional real-space grid with either periodic or non-periodic boundary conditions, the objective is to evaluate the GGA exchange–correlation energy $E_{xc}[n]$ and, when needed, the corresponding exchange–correlation potential $v_{xc}(\\mathbf{r})$ obtained from a functional derivative that includes a divergence term of the form $\\nabla\\cdot(\\cdot)$. The reduced gradient for exchange $s(\\mathbf{r})$ and the correlation variable $t(\\mathbf{r})$ are dimensionless measures based on local scales set by the Fermi wavevector and the Thomas–Fermi screening wavevector; their precise definitions must be consistent with widely used GGA constructions. Consider the need for scientific consistency, numerical stability, and correct treatment of boundary terms implied by integration by parts in the functional derivative.\n\nWhich option outlines a scientifically consistent and numerically robust algorithm to evaluate $E_{xc}[n]$ on a real-space grid, including the computation of $\\nabla n$, $s$, and $t$, and provides proper boundary handling for the $\\nabla\\cdot$ term in $v_{xc}(\\mathbf{r})$?\n\nA. Initialize $n_i = n(\\mathbf{r}_i)$ at all grid sites $i$. Compute $\\nabla n$ using second-order centered finite differences at all interior points and periodic wrap-around at boundaries. Define $k_F(\\mathbf{r}_i) = (3\\pi^2 n_i)^{1/3}$ and $k_s(\\mathbf{r}_i) = \\sqrt{4 k_F(\\mathbf{r}_i)/\\pi}$. Set $s_i = \\dfrac{|\\nabla n|_i}{2 k_F(\\mathbf{r}_i) n_i}$ and $t_i = \\dfrac{|\\nabla n|_i}{2 k_s(\\mathbf{r}_i) n_i}$ for the spin-unpolarized case. Evaluate the local exchange–correlation energy density $\\varepsilon_{xc}(n_i, s_i, t_i)$ using a chosen GGA and integrate with an appropriate quadrature to obtain $E_{xc} = \\sum_i w_i\\, n_i\\, \\varepsilon_{xc}(n_i, s_i, t_i)$. For $v_{xc}$, compute $v_{xc}(\\mathbf{r}) = \\dfrac{\\partial (n\\varepsilon_{xc})}{\\partial n} - \\nabla\\cdot\\!\\left(\\dfrac{\\partial (n\\varepsilon_{xc})}{\\partial (\\nabla n)}\\right)$ using the same centered-difference stencil for both $\\nabla$ and $\\nabla\\cdot$, applying periodic wrap so that the net surface term cancels by translational invariance. For non-periodic domains, enforce homogeneous Neumann boundary conditions for the flux $\\dfrac{\\partial (n\\varepsilon_{xc})}{\\partial (\\nabla n)}\\cdot \\hat{\\mathbf{n}} = 0$ or use ghost cells consistent with the physical boundary, thereby ensuring that the surface integral from integration by parts is treated consistently.\n\nB. Initialize $n_i$. Compute $\\nabla n$ everywhere using first-order forward differences, switching to backward differences at the last grid point. Define $s_i = \\dfrac{|\\nabla n|_i}{n_i}$ and $t_i = \\nabla^2 n_i$. Evaluate $\\varepsilon_{xc}(n_i, s_i, t_i)$ and set $E_{xc} = \\sum_i n_i \\varepsilon_{xc}(n_i, s_i, t_i) \\Delta V$. For $v_{xc}$, approximate $\\nabla\\cdot(\\cdot)$ by forward differences at all boundaries and assume the boundary term vanishes regardless of boundary conditions.\n\nC. Initialize $n_i$. Compute $\\nabla n$ via Fourier differentiation (Fast Fourier Transform) assuming periodic boundary conditions. Define $k_F(\\mathbf{r}_i) = (3\\pi^2 n_i)^{1/3}$ and set $s_i = \\dfrac{|\\nabla n|_i}{2 k_F(\\mathbf{r}_i) n_i}$ and $t_i = \\dfrac{|\\nabla n|_i}{2 k_F(\\mathbf{r}_i) n_i}$. Evaluate $\\varepsilon_{xc}(n_i, s_i, t_i)$ and integrate to get $E_{xc}$. For $v_{xc}$, compute the divergence term with FFTs in the bulk but impose zero Dirichlet boundary conditions $v_{xc}=0$ on non-periodic boundaries without adjusting the flux term, since periodic differentiation already ensures consistency.\n\nD. Initialize $n_i$. Use second-order centered differences for $\\nabla n$ in the interior and one-sided second-order differences at boundaries with no wrap-around. Define $s_i = \\dfrac{|\\nabla n|_i}{2 k_F(\\mathbf{r}_i) n_i}$ with $k_F(\\mathbf{r}_i) = (3\\pi^2 n_i)^{1/3}$, and set $t_i = \\dfrac{|\\nabla n|_i}{2 \\sqrt{n_i}\\, n_i}$. Evaluate $\\varepsilon_{xc}(n_i, s_i, t_i)$ and integrate $E_{xc}$. For $v_{xc}$, rewrite the divergence term as a Laplacian of $n$ and compute it with centered differences, assuming the surface term is negligible for any boundary condition.\n\nSelect the single best option that is correct in its entirety. Provide no partial credit.",
            "solution": "The problem asks to identify the most scientifically consistent and numerically robust algorithm for evaluating the Generalized Gradient Approximation (GGA) exchange-correlation energy $E_{xc}[n]$ and potential $v_{xc}(\\mathbf{r})$ on a real-space grid. This requires a correct understanding of the GGA functional form, the definition of its variables, the numerical methods for differentiation, and the proper treatment of boundary terms in the functional derivative.\n\nLet us first establish the fundamental principles.\n\n1.  **GGA Energy Functional**: The exchange-correlation energy in the GGA for a spin-unpolarized system is an integral over all space of an energy density function that depends on the local electron density $n(\\mathbf{r})$ and its gradient $\\nabla n(\\mathbf{r})$:\n    $$ E_{xc}[n] = \\int \\mathcal{E}_{xc}(n(\\mathbf{r}), \\nabla n(\\mathbf{r})) \\, d^3\\mathbf{r} = \\int n(\\mathbf{r}) \\varepsilon_{xc}(n(\\mathbf{r}), |\\nabla n(\\mathbf{r})|) \\, d^3\\mathbf{r} $$\n    Here, $\\varepsilon_{xc}$ is the exchange-correlation energy per particle. To construct a functional that satisfies known scaling properties and physical limits, $\\varepsilon_{xc}$ is typically expressed in terms of dimensionless variables.\n\n2.  **Dimensionless Variables**: The key dimensionless variable is the reduced density gradient, $s$. For a spin-unpolarized system, it is defined as:\n    $$ s(\\mathbf{r}) = \\frac{|\\nabla n(\\mathbf{r})|}{2 k_F(\\mathbf{r}) n(\\mathbf{r})} $$\n    where $k_F(\\mathbf{r}) = (3\\pi^2 n(\\mathbf{r}))^{1/3}$ is the local Fermi wavevector. This variable compares the length scale of density variation, $n/|\\nabla n|$, to the local Fermi wavelength, $1/k_F$. The factor of $2$ is a common convention (e.g., in the PBE functional).\n    \n    Many correlation functionals use an additional dimensionless variable, often denoted $t$, which is related to the Thomas-Fermi screening wavevector $k_s(\\mathbf{r})$. A standard definition is:\n    $$ t(\\mathbf{r}) = \\frac{|\\nabla n(\\mathbf{r})|}{2 k_s(\\mathbf{r}) n(\\mathbf{r})} $$\n    where $k_s(\\mathbf{r}) = \\sqrt{4 k_F(\\mathbf{r})/\\pi}$.\n\n3.  **GGA Potential**: The corresponding exchange-correlation potential $v_{xc}(\\mathbf{r})$ is the functional derivative of the energy with respect to the density:\n    $$ v_{xc}(\\mathbf{r}) = \\frac{\\delta E_{xc}[n]}{\\delta n(\\mathbf{r})} $$\n    Applying the Euler-Lagrange equation to the functional $E_{xc}[n] = \\int \\mathcal{E}_{xc}(n, \\nabla n) \\, d^3\\mathbf{r}$ yields:\n    $$ v_{xc}(\\mathbf{r}) = \\frac{\\partial \\mathcal{E}_{xc}}{\\partial n} - \\nabla \\cdot \\left( \\frac{\\partial \\mathcal{E}_{xc}}{\\partial (\\nabla n)} \\right) $$\n    where $\\mathcal{E}_{xc} = n\\varepsilon_{xc}$. The term $\\nabla \\cdot (\\dots)$ arises from integration by parts of the term involving $\\delta(\\nabla n) = \\nabla(\\delta n)$. This derivation assumes that the boundary term from integration by parts, $\\oint (\\partial\\mathcal{E}_{xc}/\\partial(\\nabla n))\\cdot\\hat{\\mathbf{n}}\\,\\delta n\\, dS$, vanishes. This is true for periodic systems or for systems where the density (and thus $\\delta n$ and the flux term $\\partial\\mathcal{E}_{xc}/\\partial(\\nabla n)$) vanishes at the boundary.\n\n4.  **Numerical Implementation**: On a discrete grid, the integral for $E_{xc}$ becomes a sum. The derivatives must be computed numerically, for example, using finite differences or Fourier transforms. It is crucial for numerical stability and accuracy that the discretization of the divergence operator $\\nabla\\cdot$ is consistent with the discretization of the gradient operator $\\nabla$. For instance, they should be adjoints of each other in the discrete sense. The boundary conditions must be handled carefully to correctly represent the vanishing surface term.\n\nNow, we evaluate each option against these principles.\n\n**Analysis of Option A**\n- **Derivatives**: Proposes second-order centered finite differences for $\\nabla n$. This is a standard and robust choice, balancing accuracy and computational cost.\n- **Variables**: The definitions provided, $k_F(\\mathbf{r}_i) = (3\\pi^2 n_i)^{1/3}$, $k_s(\\mathbf{r}_i) = \\sqrt{4 k_F(\\mathbf{r}_i)/\\pi}$, $s_i = \\dfrac{|\\nabla n|_i}{2 k_F(\\mathbf{r}_i) n_i}$, and $t_i = \\dfrac{|\\nabla n|_i}{2 k_s(\\mathbf{r}_i) n_i}$, are all standard and correct for spin-unpolarized systems.\n- **Energy**: The expression $E_{xc} = \\sum_i w_i\\, n_i\\, \\varepsilon_{xc}(n_i, s_i, t_i)$ correctly represents the numerical integration of the energy density $n\\varepsilon_{xc}$, where $\\varepsilon_{xc}$ is the energy per particle and $w_i$ is the grid point volume element.\n- **Potential and Boundary Conditions**: The option correctly states the formula for $v_{xc}$. It proposes using the same centered-difference stencil for both $\\nabla$ and $\\nabla\\cdot$, which is a consistent numerical practice. The treatment of boundary conditions is excellent: for periodic systems, wrap-around correctly handles the cancellation of boundary terms. For non-periodic systems, it correctly identifies the need to enforce the physical boundary condition on the flux term, $\\dfrac{\\partial (n\\varepsilon_{xc})}{\\partial (\\nabla n)}\\cdot \\hat{\\mathbf{n}} = 0$, to ensure the surface integral from integration by parts vanishes. This is the physically correct and numerically sound procedure for isolated systems.\n- **Verdict**: This option is scientifically consistent, numerically robust, and entirely correct in all its details.\n\n**Analysis of Option B**\n- **Derivatives**: Proposes first-order differences. This is a low-accuracy scheme and not considered \"numerically robust\" for high-precision calculations.\n- **Variables**: The definitions $s_i = \\dfrac{|\\nabla n|_i}{n_i}$ and $t_i = \\nabla^2 n_i$ are incorrect. The variable $s$ is not properly non-dimensionalized according to standard GGA convention (it is missing the factor of $1/k_F \\propto 1/n^{1/3}$). The variable $t$ is incorrectly identified as the Laplacian; it should be a dimensionless gradient-based quantity like $s$, but with different scaling. Some meta-GGAs use the Laplacian, but this option confuses the standard variables.\n- **Boundary Conditions**: The statement `assume the boundary term vanishes regardless of boundary conditions` is a critical error. The boundary term from integration by parts does not vanish automatically for non-periodic systems and ignoring it leads to an incorrect potential and breaks energy conservation.\n- **Verdict**: This option is incorrect due to low-accuracy numerics, incorrect definitions of the fundamental variables $s$ and $t$, and a fatally flawed treatment of boundary conditions.\n\n**Analysis of Option C**\n- **Derivatives**: Proposes Fourier differentiation (FFT), which is an excellent method for periodic systems.\n- **Variables**: The definition of $s_i$ is correct. However, it defines $t_i = \\dfrac{|\\nabla n|_i}{2 k_F(\\mathbf{r}_i) n_i}$, which means $t_i = s_i$. This is incorrect. While some functionals may only depend on $s$, the problem implies two distinct variables, with $t$ based on $k_s$, not $k_F$. This definition is inconsistent with the standard construction of many important correlation functionals (e.g., LYP).\n- **Boundary Conditions**: The handling of non-periodic boundaries is contradictory and scientifically unsound. It suggests using FFTs (inherently periodic) for a non-periodic problem and then imposing an arbitrary and unphysical boundary condition ($v_{xc}=0$). The claim that \"periodic differentiation already ensures consistency\" is false in a non-periodic context; it ignores the fundamental mismatch between the method and the problem's topology.\n- **Verdict**: This option is incorrect due to the flawed definition of the variable $t$ and, more severely, its nonsensical and inconsistent treatment of non-periodic boundary conditions.\n\n**Analysis of Option D**\n- **Variables**: The definition of $s_i$ is correct. The definition of $t_i = \\dfrac{|\\nabla n|_i}{2 \\sqrt{n_i}\\, n_i}$ is incorrect. The scaling with density, $n^{-3/2}$ in the denominator, does not match the standard Thomas-Fermi scaling, which would be $k_s n \\propto n^{1/6} n = n^{7/6}$.\n- **Potential**: It incorrectly claims the divergence term in $v_{xc}$ can be rewritten as a Laplacian of $n$. The general term is $\\nabla \\cdot [g(n, |\\nabla n|) \\nabla n]$, which is not proportional to $\\nabla^2 n$ because the factor $g(n, |\\nabla n|) = 2n \\frac{\\partial \\varepsilon_{xc}}{\\partial(|\\nabla n|^2)}$ is not a constant. This is a fundamental mathematical error.\n- **Boundary Conditions**: Similar to option B, it makes the false assumption that the surface term is negligible for any boundary condition.\n- **Verdict**: This option is incorrect due to a flawed definition of the variable $t$, a fundamental misunderstanding of the structure of the GGA potential, and an incorrect treatment of boundary terms.\n\n**Conclusion**\nOption A is the only one that provides a completely correct and robust description of the numerical procedure for evaluating GGA functionals on a real-space grid. It correctly specifies the variable definitions, numerical schemes, and the critical handling of boundary conditions for both periodic and non-periodic systems.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The final step in mastering a computational method is to implement it yourself. This coding exercise () brings together the concepts from the previous practices into a tangible computational task: calculating the PBE-GGA exchange energy for a test system. By comparing results from numerical gradients of varying accuracy to a semi-analytic benchmark, you will gain firsthand experience with the critical process of code verification and understanding the sources of numerical error in DFT simulations.",
            "id": "3811149",
            "problem": "You are to implement and analyze the discretization error in the generalized gradient approximation exchange energy for a three-dimensional periodic test electron density. The goal is to compare exchange energies computed using finite-difference gradients of varying order against energies computed using analytic derivatives of the same test density. All energies must be expressed in atomic units (Hartree).\n\nStart from the foundational base of Density Functional Theory (DFT), where the exchange energy in the generalized gradient approximation (GGA) is defined by an integral of an energy density that depends on both the electron density and its gradient. Use the following fundamental definitions:\n\n- The exchange energy in the generalized gradient approximation (GGA) is\n$$\nE_{x}^{\\mathrm{GGA}} = \\int_{\\Omega} \\varepsilon_{x}^{\\mathrm{LDA}}(n(\\mathbf{r})) \\, F(s(\\mathbf{r})) \\, d^3\\mathbf{r},\n$$\nwhere $\\Omega$ is the simulation domain, $\\varepsilon_{x}^{\\mathrm{LDA}}(n) = -C_x \\, n^{4/3}$ is the local density approximation exchange energy density with the constant $C_x = \\frac{3}{4}\\left(\\frac{3}{\\pi}\\right)^{1/3}$ in atomic units, and $F(s)$ is the exchange enhancement factor of the generalized gradient approximation.\n\n- Use the canonical Perdew–Burke–Ernzerhof (PBE) exchange enhancement factor with parameters $\\mu = 0.21951$ and $\\kappa = 0.804$:\n$$\nF(s) = 1 + \\kappa - \\frac{\\kappa}{1 + (\\mu/\\kappa)\\, s^2}.\n$$\n\n- The reduced gradient $s(\\mathbf{r})$ is defined by\n$$\ns(\\mathbf{r}) = \\frac{|\\nabla n(\\mathbf{r})|}{2 k_F(\\mathbf{r}) n(\\mathbf{r})}, \\quad k_F(\\mathbf{r}) = \\left(3 \\pi^2 n(\\mathbf{r})\\right)^{1/3}.\n$$\n\nUse a three-dimensional periodic cubic domain $\\Omega = [0,L]^3$ with periodic boundary conditions and a uniform grid with $N$ points per dimension, grid spacing $h = L/N$, and cell volume $\\Delta V = h^3$. Define the test electron density by\n$$\nn(x,y,z) = n_0 \\left[ 1 + a \\cos(k_x x) \\cos(k_y y) \\cos(k_z z) \\right],\n$$\nwhere $n_0 > 0$, $0 < a < 1$, and the wave vectors are $k_x = \\frac{2\\pi m_x}{L}$, $k_y = \\frac{2\\pi m_y}{L}$, $k_z = \\frac{2\\pi m_z}{L}$ with integer mode numbers $m_x, m_y, m_z \\ge 0$. This choice ensures $n(x,y,z) > 0$ everywhere provided $n_0 (1 - a) > 0$, and the density is compatible with periodic boundary conditions.\n\nCompute two versions of the exchange energy:\n1. An \"analytic-gradient\" reference energy $E_{x}^{\\mathrm{ref}}$ by evaluating $|\\nabla n|$ from analytic derivatives of the density (from calculus), substituting into the above $E_{x}^{\\mathrm{GGA}}$ integrand on the grid, and integrating via the uniform Riemann sum over the grid points.\n2. A \"finite-difference\" energy $E_{x}^{\\mathrm{FD}}$ by approximating $|\\nabla n|$ using central finite differences of order $p \\in \\{2,4,6\\}$ for first derivatives, with periodic boundary conditions and the following one-dimensional stencils applied independently along each axis:\n   - Order $p = 2$:\n   $$\n   f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}.\n   $$\n   - Order $p = 4$:\n   $$\n   f'(x) \\approx \\frac{-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)}{12h}.\n   $$\n   - Order $p = 6$:\n   $$\n   f'(x) \\approx \\frac{f(x-3h) - 9f(x-2h) + 45f(x-h) - 45f(x+h) + 9f(x+2h) - f(x+3h)}{60h}.\n   $$\n\nFor each case, define the discretization error as the absolute difference\n$$\n\\Delta E = \\left| E_{x}^{\\mathrm{FD}} - E_{x}^{\\mathrm{ref}} \\right|.\n$$\n\nYour program must implement the above definitions and produce $\\Delta E$ for a set of test cases that explore resolution, derivative order, and spectral content. Use the following test suite, where each tuple is $(N, p, L, n_0, a, m_x, m_y, m_z)$:\n\n- Case $1$ (happy path): $(64, 2, 10.0, 0.05, 0.30, 2, 3, 4)$.\n- Case $2$ (higher-order on same grid): $(64, 4, 10.0, 0.05, 0.30, 2, 3, 4)$.\n- Case $3$ (coarse grid, moderate modes): $(16, 2, 10.0, 0.05, 0.30, 2, 2, 2)$.\n- Case $4$ (coarse grid, higher-order): $(16, 6, 10.0, 0.05, 0.30, 2, 2, 2)$.\n- Case $5$ (higher spectral content near the grid limit): $(48, 4, 10.0, 0.05, 0.20, 12, 11, 10)$.\n\nAll lengths $L$ are in bohr, all densities $n_0$ are in bohr$^{-3}$, and the final energies $E_{x}^{\\mathrm{ref}}$, $E_{x}^{\\mathrm{FD}}$, and errors $\\Delta E$ must be in Hartree.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should contain the five $\\Delta E$ values (in Hartree) corresponding to the five test cases, in the same order as listed above, for example, $[e_1,e_2,e_3,e_4,e_5]$. No other text should be printed.",
            "solution": "The problem is valid. It presents a well-defined computational task rooted in the standard formulation of Density Functional Theory (DFT), specifically using a Generalized Gradient Approximation (GGA) for the exchange functional. All provided equations, constants, and parameters are scientifically sound, complete, and mutually consistent. The task is to implement the specified physics and numerical methods to calculate the discretization error of a finite-difference approximation against a semi-analytic reference.\n\nThe objective is to compute the absolute error $\\Delta E = |E_{x}^{\\mathrm{FD}} - E_{x}^{\\mathrm{ref}}|$ between the exchange energy calculated with a finite-difference gradient, $E_{x}^{\\mathrm{FD}}$, and a reference energy calculated with an analytic gradient, $E_{x}^{\\mathrm{ref}}$.\n\nThe GGA exchange energy is given by the integral:\n$$\nE_{x}^{\\mathrm{GGA}} = \\int_{\\Omega} \\varepsilon_{x}^{\\mathrm{LDA}}(n(\\mathbf{r})) \\, F(s(\\mathbf{r})) \\, d^3\\mathbf{r}\n$$\nThe calculation is performed on a periodic cubic domain $\\Omega = [0,L]^3$, discretized into a uniform grid of $N \\times N \\times N$ points. The grid spacing is $h = L/N$ and the volume element for numerical integration is $\\Delta V = h^3$.\n\nThe components of the integrand are:\n1.  The Local Density Approximation (LDA) exchange energy density:\n    $$\n    \\varepsilon_{x}^{\\mathrm{LDA}}(n) = -C_x \\, n^{4/3}, \\quad \\text{with } C_x = \\frac{3}{4}\\left(\\frac{3}{\\pi}\\right)^{1/3}\n    $$\n2.  The Perdew–Burke–Ernzerhof (PBE) exchange enhancement factor, which modifies the LDA energy based on the local gradient of the density:\n    $$\n    F(s) = 1 + \\kappa - \\frac{\\kappa}{1 + (\\mu/\\kappa)\\, s^2}\n    $$\n    using the given parameters $\\mu = 0.21951$ and $\\kappa = 0.804$.\n3.  The reduced density gradient $s(\\mathbf{r})$, a dimensionless measure of the density's variation:\n    $$\n    s(\\mathbf{r}) = \\frac{|\\nabla n(\\mathbf{r})|}{2 k_F(\\mathbf{r}) n(\\mathbf{r})}\n    $$\n    where $k_F(\\mathbf{r}) = (3 \\pi^2 n(\\mathbf{r}))^{1/3}$ is the local Fermi wavevector.\n\nThe test electron density $n(\\mathbf{r})$ is defined on the grid coordinates $(x,y,z)$ as:\n$$\nn(x,y,z) = n_0 \\left[ 1 + a \\cos(k_x x) \\cos(k_y y) \\cos(k_z z) \\right]\n$$\nwith wave vectors $k_i = 2\\pi m_i/L$ for $i \\in \\{x,y,z\\}$.\n\nThe numerical implementation proceeds as follows:\n\n**Step 1: Grid and Density Generation**\nFor each test case $(N, p, L, n_0, a, m_x, m_y, m_z)$, a 3D grid of coordinates is generated. We use `numpy.meshgrid` to create coordinate arrays $x, y, z$ spanning the domain $[0, L)$ with $N$ points along each axis. The test density $n(\\mathbf{r})$ is then evaluated at each point on this grid, yielding a 3D array `n_grid`.\n\n**Step 2: Reference Energy Calculation ($E_{x}^{\\mathrm{ref}}$)**\nThis calculation uses the exact, analytical gradient of the test density. The partial derivatives are:\n$$\n\\frac{\\partial n}{\\partial x} = -n_0 a k_x \\sin(k_x x) \\cos(k_y y) \\cos(k_z z) \\\\\n\\frac{\\partial n}{\\partial y} = -n_0 a k_y \\cos(k_x x) \\sin(k_y y) \\cos(k_z z) \\\\\n\\frac{\\partial n}{\\partial z} = -n_0 a k_z \\cos(k_x x) \\cos(k_y y) \\sin(k_z z)\n$$\nThese derivatives are evaluated on the grid to form three arrays. The magnitude of the gradient, $|\\nabla n|_{\\mathrm{ref}} = \\sqrt{(\\partial n/\\partial x)^2 + (\\partial n/\\partial y)^2 + (\\partial n/\\partial z)^2}$, is then computed pointwise.\nWith both $n(\\mathbf{r})$ and $|\\nabla n|_{\\mathrm{ref}}$ available on the grid, we compute the arrays for $k_F(\\mathbf{r})$, $s(\\mathbf{r})$, $F(s(\\mathbf{r}))$, and $\\varepsilon_{x}^{\\mathrm{LDA}}(n(\\mathbf{r}))$. The integrand for the reference energy is the product $\\varepsilon_{x}^{\\mathrm{LDA}} \\cdot F(s)$. The integral is then computed as a Riemann sum over all grid points:\n$$\nE_{x}^{\\mathrm{ref}} = \\Delta V \\sum_{i,j,k} \\left( \\varepsilon_{x}^{\\mathrm{LDA}} F(s) \\right)_{i,j,k}\n$$\n\n**Step 3: Finite-Difference Energy Calculation ($E_{x}^{\\mathrm{FD}}$)**\nThe procedure for $E_{x}^{\\mathrm{FD}}$ is identical to that for $E_{x}^{\\mathrm{ref}}$, with the crucial exception that the gradient magnitude, $|\\nabla n|_{\\mathrm{FD}}$, is computed using numerical finite differences. We implement the specified central difference stencils of order $p \\in \\{2, 4, 6\\}$ to approximate the partial derivatives $(\\partial n/\\partial x, \\partial n/\\partial y, \\partial n/\\partial z)$. Periodic boundary conditions are handled efficiently by using `numpy.roll` to shift the `n_grid` array. For a given axis, the derivative is computed by applying the one-dimensional stencil. For example, for order $p=2$, the derivative along $x$ (axis $0$) is:\n$$\n\\frac{\\partial n}{\\partial x} \\approx \\frac{\\text{roll}(n, -1, \\text{axis}=0) - \\text{roll}(n, 1, \\text{axis}=0)}{2h}\n$$\nAfter computing the three partial derivative arrays, the gradient magnitude $|\\nabla n|_{\\mathrm{FD}}$ is found, and the subsequent calculation of $s(\\mathbf{r})$, $F(s)$, the integrand, and finally $E_{x}^{\\mathrm{FD}}$ follows the same path as in Step 2.\n\n**Step 4: Error Calculation**\nThe final discretization error for each test case is the absolute difference between the two computed energies: $\\Delta E = |E_{x}^{\\mathrm{FD}} - E_{x}^{\\mathrm{ref}}|$.\n\nThis entire process is encapsulated in a function that is called for each of the five test cases, and the resulting $\\Delta E$ values are collected.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the calculation of discretization error for GGA exchange energy.\n    \"\"\"\n    # Define physical and PBE constants in atomic units\n    C_x = (3.0 / 4.0) * (3.0 / np.pi)**(1.0 / 3.0)\n    mu = 0.21951\n    kappa = 0.804\n\n    def finite_difference_gradient(n_grid, h, p):\n        \"\"\"\n        Computes the gradient of a 3D field using periodic finite differences.\n        \"\"\"\n        grad_components = []\n        for axis in range(3):  # 0 for x, 1 for y, 2 for z\n            if p == 2:\n                # Order p=2 stencil: [f(x+h) - f(x-h)] / 2h\n                num = (np.roll(n_grid, -1, axis=axis) - np.roll(n_grid, 1, axis=axis))\n                den = 2.0 * h\n            elif p == 4:\n                # Order p=4 stencil: [-f(x+2h)+8f(x+h)-8f(x-h)+f(x-2h)] / 12h\n                num = (-np.roll(n_grid, -2, axis=axis) + 8 * np.roll(n_grid, -1, axis=axis) -\n                       8 * np.roll(n_grid, 1, axis=axis) + np.roll(n_grid, 2, axis=axis))\n                den = 12.0 * h\n            elif p == 6:\n                # Order p=6 stencil from problem statement\n                num = (np.roll(n_grid, 3, axis=axis) - 9 * np.roll(n_grid, 2, axis=axis) +\n                       45 * np.roll(n_grid, 1, axis=axis) - 45 * np.roll(n_grid, -1, axis=axis) +\n                       9 * np.roll(n_grid, -2, axis=axis) - np.roll(n_grid, -3, axis=axis))\n                den = 60.0 * h\n            else:\n                raise ValueError(f\"Unsupported finite difference order p={p}\")\n            \n            grad_components.append(num / den)\n        \n        return grad_components[0], grad_components[1], grad_components[2]\n\n    def calculate_energy(n, grad_n_mag, delta_V):\n        \"\"\"\n        Calculates the PBE exchange energy given density and its gradient magnitude.\n        \"\"\"\n        # Ensure n > 0 to avoid numerical issues\n        n = np.maximum(n, 1e-12)\n        \n        # Fermi wavevector\n        kF = (3 * np.pi**2 * n)**(1.0/3.0)\n        \n        # Reduced gradient s\n        # Denominator is 2*kF*n = 2*(3*pi^2)^(1/3)*n^(4/3), safe for n>0\n        s = grad_n_mag / (2 * kF * n)\n        \n        # PBE enhancement factor F(s)\n        F_s = 1.0 + kappa - kappa / (1.0 + (mu / kappa) * s**2)\n        \n        # LDA exchange energy density\n        eps_x_lda = -C_x * n**(4.0 / 3.0)\n        \n        # Integrand\n        integrand = eps_x_lda * F_s\n        \n        # Integrate via Riemann sum\n        energy = np.sum(integrand) * delta_V\n        \n        return energy\n\n    def compute_error_for_case(N, p, L, n0, a, mx, my, mz):\n        \"\"\"\n        Main computation for a single test case.\n        \"\"\"\n        # 1. Setup grid and parameters\n        h = L / float(N)\n        delta_V = h**3\n        grid_1d = np.linspace(0, L, N, endpoint=False)\n        x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n        \n        kx = 2.0 * np.pi * mx / L\n        ky = 2.0 * np.pi * my / L\n        kz = 2.0 * np.pi * mz / L\n\n        # 2. Evaluate density on the grid\n        cos_x = np.cos(kx * x)\n        cos_y = np.cos(ky * y)\n        cos_z = np.cos(kz * z)\n        n_grid = n0 * (1.0 + a * cos_x * cos_y * cos_z)\n\n        # 3. Reference energy (using analytic gradient)\n        sin_x = np.sin(kx * x)\n        sin_y = np.sin(ky * y)\n        sin_z = np.sin(kz * z)\n        \n        dn_dx_ref = -n0 * a * kx * sin_x * cos_y * cos_z\n        dn_dy_ref = -n0 * a * ky * cos_x * sin_y * cos_z\n        dn_dz_ref = -n0 * a * kz * cos_x * cos_y * sin_z\n        \n        grad_n_mag_ref = np.sqrt(dn_dx_ref**2 + dn_dy_ref**2 + dn_dz_ref**2)\n        E_ref = calculate_energy(n_grid, grad_n_mag_ref, delta_V)\n\n        # 4. Finite-difference energy\n        dn_dx_fd, dn_dy_fd, dn_dz_fd = finite_difference_gradient(n_grid, h, p)\n        grad_n_mag_fd = np.sqrt(dn_dx_fd**2 + dn_dy_fd**2 + dn_dz_fd**2)\n        E_fd = calculate_energy(n_grid, grad_n_mag_fd, delta_V)\n\n        # 5. Compute absolute error\n        return np.abs(E_fd - E_ref)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, p, L, n0, a, mx, my, mz)\n        (64, 2, 10.0, 0.05, 0.30, 2, 3, 4),\n        (64, 4, 10.0, 0.05, 0.30, 2, 3, 4),\n        (16, 2, 10.0, 0.05, 0.30, 2, 2, 2),\n        (16, 6, 10.0, 0.05, 0.30, 2, 2, 2),\n        (48, 4, 10.0, 0.05, 0.20, 12, 11, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_error_for_case(*case)\n        results.append(f\"{error:.10e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}