{
    "hands_on_practices": [
        {
            "introduction": "将理论付诸实践的第一步是将布里渊区上的连续积分替换为一组离散k点上的求和。这个练习旨在通过一个简单的可解析求解的例子，帮助你理解计算成本（k点网格密度）与数值精度之间的权衡。通过亲手实现一个均匀网格上的积分并分析其收敛行为，你将对数值积分误差的来源和特性建立起直观的认识。",
            "id": "3793467",
            "problem": "你需要实现一个程序，为倒易空间中的一个光滑周期性测试函数计算数值布里渊区（BZ）平均值，并估计其求积误差。单位晶格常数的简单立方晶格的布里渊区（BZ）是倒易空间中由 $[-\\pi,\\pi]^3$ 定义的立方体，其中分量 $k_x$、$k_y$ 和 $k_z$ 以弧度为单位。\n\n从基本定义出发，函数 $g(\\mathbf{k})$ 的BZ平均值是归一化积分\n$$\n\\langle g \\rangle \\equiv \\frac{1}{V_{\\mathrm{BZ}}} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} g(k_x,k_y,k_z)\\, \\mathrm{d}k_x\\, \\mathrm{d}k_y\\, \\mathrm{d}k_z,\n$$\n其中 $V_{\\mathrm{BZ}}$ 是BZ体积。对于此处考虑的简单立方BZ，$V_{\\mathrm{BZ}}= (2\\pi)^3$。\n\n测试函数为 $g(\\mathbf{k}) = \\cos(k_x) + \\cos(k_y) + \\cos(k_z)$，所有余弦函数的参数均以弧度为单位。\n\n你必须使用一个在 $[-\\pi,\\pi]$ 上每个维度有 $N$ 个点的均匀网格来近似 $\\langle g \\rangle$，对于 $N>1$ 的情况，网格包括两个端点。具体来说，对于 $N>1$，一维网格点为\n$$\nk_i = -\\pi + i \\frac{2\\pi}{N-1}, \\quad i \\in \\{0,1,\\dots,N-1\\},\n$$\n对于边界情况 $N=1$，定义退化网格点为 $k_0 = 0$。三维网格是 $k_x$、$k_y$ 和 $k_z$ 的一维网格的笛卡尔积。数值BZ平均值定义为 $g(\\mathbf{k})$ 在所有网格点上的算术平均值，\n$$\n\\langle g \\rangle_N \\equiv \\frac{1}{N^3} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\sum_{l=0}^{N-1} g(k_i,k_j,k_l).\n$$\n\n对于给定的 $N$，将求积误差定义为数值平均值与精确解析平均值之间的绝对差，\n$$\nE(N) \\equiv \\left| \\langle g \\rangle_N - \\langle g \\rangle \\right|.\n$$\n\n使用以上定义，实现一个程序，该程序：\n- 对每个指定的 $N$ 计算 $\\langle g \\rangle_N$。\n- 利用精确解析平均值 $\\langle g \\rangle$ 可由余弦函数在对称区间上的基本性质确定这一事实来计算 $E(N)$。\n- 通过在所有严格正误差值的测试用例上，对 $\\log E(N)$ 与 $\\log N$ 进行最小二乘拟合，来估计模型 $E(N) \\approx C N^{-p}$ 中求积误差相对于 $N$ 的经验收敛率 $p$。如果严格正误差值少于两个，则设 $p$ 为 $0$。\n\n角度单位必须是弧度。所有输出均为无量纲实数。\n\n测试套件：\n使用以下网格密度（每个维度的点数）：$[1,2,3,4,5,6,7,8,10,13]$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，前 $10$ 个条目是给定顺序的测试套件的求积误差 $E(N)$，最后一个条目是如上所述估计的经验收敛率 $p$。例如，输出格式必须完全是\n$[\\text{E}(1),\\text{E}(2),\\text{E}(3),\\text{E}(4),\\text{E}(5),\\text{E}(6),\\text{E}(7),\\text{E}(8),\\text{E}(10),\\text{E}(13),p]$。",
            "solution": "该问题要求计算给定测试函数的数值布里渊区（BZ）平均值，确定其相对于精确解析平均值的求积误差，并估计误差的收敛率。\n\n首先，我将验证问题陈述。给定条件如下：\n- 布里渊区（BZ）是由 $[-\\pi,\\pi]^3$ 定义的立方体。\n- BZ体积为 $V_{\\mathrm{BZ}}= (2\\pi)^3$。\n- 函数 $g(\\mathbf{k})$ 的解析BZ平均值为 $\\langle g \\rangle \\equiv \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} g(\\mathbf{k})\\, \\mathrm{d}^3k$。\n- 测试函数为 $g(\\mathbf{k}) = \\cos(k_x) + \\cos(k_y) + \\cos(k_z)$。\n- 对于维度 $N > 1$，数值网格由点 $k_i = -\\pi + i \\frac{2\\pi}{N-1}$（$i \\in \\{0,1,\\dots,N-1\\}$）组成。对于 $N=1$，网格是单点 $k_0 = 0$。\n- 数值BZ平均值为 $\\langle g \\rangle_N \\equiv \\frac{1}{N^3} \\sum_{i,j,l=0}^{N-1} g(k_i,k_j,k_l)$。\n- 求积误差为 $E(N) \\equiv \\left| \\langle g \\rangle_N - \\langle g \\rangle \\right|$。\n- 收敛率 $p$ 通过模型 $E(N) \\approx C N^{-p}$，对所有 $E(N) > 0$ 的情况，通过对 $\\log E(N)$ 与 $\\log N$ 进行最小二乘拟合来估计。如果这样的点少于两个，则 $p=0$。\n- $N$ 的测试套件是 $[1,2,3,4,5,6,7,8,10,13]$。\n\n该问题在科学上植根于固态物理和数值分析，是计算材料科学中的一个标准练习。所有术语都以数学精度定义，没有信息缺失或矛盾。问题是适定的、客观的，其解是可验证的。因此，该问题被认为是有效的。\n\n求解过程包括三个主要部分：\n1. 计算精确解析平均值 $\\langle g \\rangle$。\n2. 计算数值平均值 $\\langle g \\rangle_N$ 和误差 $E(N)$。\n3. 估计收敛率 $p$。\n\n**1. 解析BZ平均值 $\\langle g \\rangle$**\n\n精确平均值 $\\langle g \\rangle$ 由下式给出：\n$$\n\\langle g \\rangle = \\frac{1}{(2\\pi)^3} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} \\left( \\cos(k_x) + \\cos(k_y) + \\cos(k_z) \\right) \\, \\mathrm{d}k_x\\, \\mathrm{d}k_y\\, \\mathrm{d}k_z\n$$\n由于积分的线性性质，我们可以分离各项：\n$$\n\\langle g \\rangle = \\frac{1}{(2\\pi)^3} \\left( \\int_{\\mathrm{BZ}} \\cos(k_x)\\, \\mathrm{d}^3k + \\int_{\\mathrm{BZ}} \\cos(k_y)\\, \\mathrm{d}^3k + \\int_{\\mathrm{BZ}} \\cos(k_z)\\, \\mathrm{d}^3k \\right)\n$$\n让我们计算第一项。对 $k_y$ 和 $k_z$ 的积分是可分离的：\n$$\n\\int_{\\mathrm{BZ}} \\cos(k_x)\\, \\mathrm{d}^3k = \\left( \\int_{-\\pi}^{\\pi} \\cos(k_x) \\, \\mathrm{d}k_x \\right) \\left( \\int_{-\\pi}^{\\pi} \\mathrm{d}k_y \\right) \\left( \\int_{-\\pi}^{\\pi} \\mathrm{d}k_z \\right)\n$$\n余弦函数在对称区间 $[-\\pi, \\pi]$ 上的积分为：\n$$\n\\int_{-\\pi}^{\\pi} \\cos(k_x) \\, \\mathrm{d}k_x = [\\sin(k_x)]_{-\\pi}^{\\pi} = \\sin(\\pi) - \\sin(-\\pi) = 0 - 0 = 0\n$$\n因为这个积分为 $0$，所以整个第一项为 $0$。根据对称性，涉及 $\\cos(k_y)$ 和 $\\cos(k_z)$ 的另外两项也为 $0$。\n因此，精确解析平均值为 $\\langle g \\rangle = 0$。\n\n**2. 数值BZ平均值 $\\langle g \\rangle_N$ 和求积误差 $E(N)$**\n\n数值平均值定义为：\n$$\n\\langle g \\rangle_N = \\frac{1}{N^3} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\sum_{l=0}^{N-1} \\left( \\cos(k_i) + \\cos(k_j) + \\cos(k_l) \\right)\n$$\n通过求和的线性性质，这可以被简化。让我们分析对 $\\cos(k_i)$ 的求和：\n$$\n\\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\sum_{l=0}^{N-1} \\cos(k_i) = \\left( \\sum_{i=0}^{N-1} \\cos(k_i) \\right) \\left( \\sum_{j=0}^{N-1} 1 \\right) \\left( \\sum_{l=0}^{N-1} 1 \\right) = N^2 \\sum_{i=0}^{N-1} \\cos(k_i)\n$$\n由于 $k_x$、$k_y$ 和 $k_z$ 的网格是相同的，所以对 $\\cos(k_j)$ 和 $\\cos(k_l)$ 的求和具有相同的值。设 $S_N = \\sum_{i=0}^{N-1} \\cos(k_i)$。平均值的表达式变为：\n$$\n\\langle g \\rangle_N = \\frac{1}{N^3} \\left( N^2 S_N + N^2 S_N + N^2 S_N \\right) = \\frac{3 N^2 S_N}{N^3} = \\frac{3 S_N}{N}\n$$\n现在，我们必须计算和 $S_N$。\n\n情况 $N=1$：网格为 $k_0=0$。$S_1 = \\cos(0) = 1$。\n$\\langle g \\rangle_1 = \\frac{3(1)}{1} = 3$。\n\n情况 $N=2$：网格为 $\\{-\\pi, \\pi\\}$。$S_2 = \\cos(-\\pi) + \\cos(\\pi) = -1 + (-1) = -2$。\n$\\langle g \\rangle_2 = \\frac{3(-2)}{2} = -3$。\n\n情况 $N \\ge 3$：网格点为 $k_i = -\\pi + i d$，步长 $d = \\frac{2\\pi}{N-1}$。和为 $S_N = \\sum_{i=0}^{N-1} \\cos(-\\pi + i\\,\\frac{2\\pi}{N-1})$。这是一个标准的和，可以用等差级数中余弦求和的公式来计算：$\\sum_{i=0}^{n-1} \\cos(a+id) = \\frac{\\cos(a+(n-1)d/2)\\sin(nd/2)}{\\sin(d/2)}$。\n这里，$a=-\\pi$，$d=\\frac{2\\pi}{N-1}$，$n=N$。这适用于 $d/2 \\neq m\\pi$（$m$为整数），这对 $N>2$ 成立。\n分子的余弦项参数是 $a + (n-1)d/2 = -\\pi + (N-1)\\frac{\\pi}{N-1} = 0$。所以 $\\cos(0)=1$。\n分子的正弦项参数是 $nd/2 = N\\frac{\\pi}{N-1} = \\frac{(N-1+1)\\pi}{N-1} = \\pi + \\frac{\\pi}{N-1}$。\n所以 $\\sin(N\\frac{\\pi}{N-1}) = \\sin(\\pi + \\frac{\\pi}{N-1}) = -\\sin(\\frac{\\pi}{N-1})$。\n和变为 $S_N = \\frac{1 \\cdot (-\\sin(\\frac{\\pi}{N-1}))}{\\sin(\\frac{\\pi}{N-1})} = -1$。\n所以，对于所有 $N \\ge 3$，$S_N = -1$。\n这得到 $\\langle g \\rangle_N = \\frac{3(-1)}{N} = -\\frac{3}{N}$，对于 $N \\ge 3$。\n\n求积误差为 $E(N) = |\\langle g \\rangle_N - \\langle g \\rangle| = |\\langle g \\rangle_N - 0| = |\\langle g \\rangle_N|$。\n- 对于 $N=1$：$E(1) = |\\langle g \\rangle_1| = |3| = 3$。\n- 对于 $N=2$：$E(2) = |\\langle g \\rangle_2| = |-3| = 3$。\n- 对于 $N \\ge 3$：$E(N) = |-\\frac{3}{N}| = \\frac{3}{N}$。\n\n**3. 估计收敛率 $p$**\n\n模型为 $E(N) \\approx C N^{-p}$。取自然对数得到 $\\ln E(N) \\approx \\ln C - p \\ln N$。这是一个 $y \\approx b + mx$ 形式的线性关系，其中 $y=\\ln E(N)$，$x=\\ln N$，斜率为 $m=-p$，截距为 $b=\\ln C$。我们需要对测试套件中所有 $N$ 的点 $(\\ln N, \\ln E(N))$ 进行最小二乘线性回归，因为所有先验计算的误差都是严格为正的。\n\n测试套件是 $N \\in [1, 2, 3, 4, 5, 6, 7, 8, 10, 13]$。所有 $10$ 个点都将用于拟合。我们将计算点对 $(\\ln N, \\ln E(N))$ 并找到最佳拟合线的斜率 $m$。然后收敛率将为 $p = -m$。将使用标准的数值库函数，如 `numpy.polyfit`，进行回归。\n\n算法计划如下：\n1.  创建一个包含 $N$ 的测试值的列表。\n2.  对于每个 $N$，使用上面推导的解析公式计算 $E(N)$：$E(1)=3$，$E(2)=3$，以及对于 $N \\ge 3$ 的 $E(N)=3/N$。存储这些误差。\n3.  由于所有误差都是正的，为线性拟合准备两个列表：一个包含测试套件中所有 $N$ 的 $\\ln N$，另一个包含 $\\ln E(N)$。\n4.  在这些列表上使用 `numpy.polyfit` 并设定阶数为 $1$，以找到斜率 $m$。\n5.  计算 $p = -m$。\n6.  构建并打印最终的输出字符串，其中包含误差列表，后跟计算出的 $p$ 值。\n\n这种方法计算效率高且精确，完全符合问题的要求。",
            "answer": "```python\nimport numpy as np\n\ndef get_numerical_average(N):\n    \"\"\"Calculates the numerical BZ average based on the analytical derivation in the solution.\"\"\"\n    if N == 1:\n        return 3.0\n    if N == 2:\n        return -3.0\n    # For N >= 3\n    return -3.0 / N\n\ndef solve():\n    \"\"\"\n    Computes Brillouin Zone integration errors and the empirical convergence rate.\n    \"\"\"\n    test_suite_N = [1, 2, 3, 4, 5, 6, 7, 8, 10, 13]\n    errors = []\n    log_N_values = []\n    log_E_values = []\n\n    # The exact analytical average is 0, as shown in the solution.\n    exact_average = 0.0\n\n    for N in test_suite_N:\n        numerical_average = get_numerical_average(N)\n        error = abs(numerical_average - exact_average)\n        errors.append(error)\n        \n        # The problem states to use all strictly positive error values for the fit.\n        # In this case, all errors for N in the test suite are > 0.\n        if error > 0:\n            log_N_values.append(np.log(N))\n            log_E_values.append(np.log(error))\n    \n    # Estimate the convergence rate p.\n    p = 0.0\n    # The problem states to perform a least-squares fit if there are two or more points.\n    if len(log_N_values) >= 2:\n        # Model: log(E) = log(C) - p * log(N). The slope is -p.\n        slope, _ = np.polyfit(log_N_values, log_E_values, 1)\n        p = -slope\n\n    # Format the final output string.\n    result_list = errors + [p]\n    print(f\"[{','.join(map(str, result_list))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的材料计算中，我们处理的晶格很少是理想的立方结构，这意味着其倒易空间也具有各向异性。本练习将我们从理想化的立方体系推进到更实际的正交晶格，解决如何构建一个在各个方向上都具有近似均匀采样精度的k点网格的挑战。掌握这项技能对于建立可靠的、可比较的材料模拟至关重要。",
            "id": "3793488",
            "problem": "考虑一个正交晶体，其实空间原胞基矢相互正交，长度分别为 $a$、$b$ 和 $c$。设倒易晶格由实空间晶格和倒易晶格之间的标准关系定义，第一布里渊区使用 Monkhorst-Pack (MP) 方案进行采样。在布里渊区积分中，通常需要在波矢空间中进行近似各向同性的采样，以平衡不同方向上的误差；假设目标采样分辨率是沿每个倒易轴实现的均匀波矢间距 $\\Delta k$。从正交晶胞的倒易晶格的基本定义以及第一布里渊区沿每个倒易轴的几何范围出发，推导 MP 划分的最小整数三元组 $(N_x,N_y,N_z)$ 的表达式，该表达式确保沿三个倒易轴的间距不超过 $\\Delta k$ 且近似各向同性。将最终结果表示为以 $a$、$b$、$c$ 和 $\\Delta k$ 表示的封闭形式符号表达式。如果需要任何取底或取顶运算来强制整数性，请明确包含它们。请使用 LaTeX 行矩阵约定，将您的最终答案表示为有序三元组。不需要进行数值近似，最终的方框答案中不应包含任何物理单位。",
            "solution": "所述问题具有科学依据，提法恰当且客观。它提出了计算固态物理学中一个标准的、可形式化的任务。所有必要信息均已提供，不存在内部矛盾或歧义。因此，该问题被认为是有效的，可以推导出解决方案。\n\n目标是确定正交晶体的最小整数 Monkhorst-Pack (MP) 网格划分 $(N_x, N_y, N_z)$，以实现沿每个倒易轴的波矢间距不超过目标分辨率 $\\Delta k$。\n\n我们首先定义正交晶胞的实空间原胞基矢。按照惯例，选择它们相互正交并与笛卡尔坐标系对齐：\n$$ \\mathbf{a}_1 = (a, 0, 0) $$\n$$ \\mathbf{a}_2 = (0, b, 0) $$\n$$ \\mathbf{a}_3 = (0, 0, c) $$\n其中 $a$、$b$ 和 $c$ 是晶格常数。\n\n倒易晶格矢量 $\\mathbf{b}_i$ 由关系式 $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$ 定义，其中 $\\delta_{ij}$ 是克罗内克 δ。倒易矢量的一般公式为：\n$$ \\mathbf{b}_1 = 2\\pi \\frac{\\mathbf{a}_2 \\times \\mathbf{a}_3}{V}, \\quad \\mathbf{b}_2 = 2\\pi \\frac{\\mathbf{a}_3 \\times \\mathbf{a}_1}{V}, \\quad \\mathbf{b}_3 = 2\\pi \\frac{\\mathbf{a}_1 \\times \\mathbf{a}_2}{V} $$\n其中 $V = \\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)$ 是实空间原胞的体积。\n\n对于正交晶系，体积就是 $V = abc$。叉积为：\n$$ \\mathbf{a}_2 \\times \\mathbf{a}_3 = (0, b, 0) \\times (0, 0, c) = (bc, 0, 0) $$\n$$ \\mathbf{a}_3 \\times \\mathbf{a}_1 = (0, 0, c) \\times (a, 0, 0) = (0, ac, 0) $$\n$$ \\mathbf{a}_1 \\times \\mathbf{a}_2 = (a, 0, 0) \\times (0, b, 0) = (0, 0, ab) $$\n\n将这些代入倒易矢量的定义中，得到：\n$$ \\mathbf{b}_1 = 2\\pi \\frac{(bc, 0, 0)}{abc} = \\left(\\frac{2\\pi}{a}, 0, 0\\right) $$\n$$ \\mathbf{b}_2 = 2\\pi \\frac{(0, ac, 0)}{abc} = \\left(0, \\frac{2\\pi}{b}, 0\\right) $$\n$$ \\mathbf{b}_3 = 2\\pi \\frac{(0, 0, ab)}{abc} = \\left(0, 0, \\frac{2\\pi}{c}\\right) $$\n倒易晶格也是正交的。\n\n第一布里渊区 (BZ) 是倒易晶格的维格纳-赛兹原胞。对于正交倒易晶格，第一布里渊区是一个长方体。布里渊区沿倒易轴的完整范围由倒易晶格矢量的大小给出：\n$$ |\\mathbf{b}_1| = \\frac{2\\pi}{a} $$\n$$ |\\mathbf{b}_2| = \\frac{2\\pi}{b} $$\n$$ |\\mathbf{b}_3| = \\frac{2\\pi}{c} $$\n\nMonkhorst-Pack 方案生成一个跨越第一布里渊区的均匀 $k$ 点网格。一个具有 $N_x \\times N_y \\times N_z$ 划分的网格，其沿各个倒易轴（$k_x$, $k_y$, $k_z$）的相邻 $k$ 点之间的间距由下式给出：\n$$ \\Delta k_x = \\frac{|\\mathbf{b}_1|}{N_x} = \\frac{2\\pi}{a N_x} $$\n$$ \\Delta k_y = \\frac{|\\mathbf{b}_2|}{N_y} = \\frac{2\\pi}{b N_y} $$\n$$ \\Delta k_z = \\frac{|\\mathbf{b}_3|}{N_z} = \\frac{2\\pi}{c N_z} $$\n\n问题要求沿每个轴的间距不超过目标分辨率 $\\Delta k$。这引入了以下不等式组：\n$$ \\Delta k_x \\le \\Delta k \\implies \\frac{2\\pi}{a N_x} \\le \\Delta k $$\n$$ \\Delta k_y \\le \\Delta k \\implies \\frac{2\\pi}{b N_y} \\le \\Delta k $$\n$$ \\Delta k_z \\le \\Delta k \\implies \\frac{2\\pi}{c N_z} \\le \\Delta k $$\n\n我们需要找到满足这些条件的最小正整数 $N_x$、$N_y$ 和 $N_z$。我们可以重新整理每个不等式来求解 $N_i$：\n$$ N_x \\ge \\frac{2\\pi}{a \\Delta k} $$\n$$ N_y \\ge \\frac{2\\pi}{b \\Delta k} $$\n$$ N_z \\ge \\frac{2\\pi}{c \\Delta k} $$\n\n由于 $N_x$、$N_y$ 和 $N_z$ 必须是整数，因此每个的最小整数值可以通过对不等式右侧取顶得到。取顶函数 $\\lceil x \\rceil$ 给出大于或等于 $x$ 的最小整数。\n\n因此，最小整数划分为：\n$$ N_x = \\left\\lceil \\frac{2\\pi}{a \\Delta k} \\right\\rceil $$\n$$ N_y = \\left\\lceil \\frac{2\\pi}{b \\Delta k} \\right\\rceil $$\n$$ N_z = \\left\\lceil \\frac{2\\pi}{c \\Delta k} \\right\\rceil $$\n\n这种选择确保了每个方向上的 k 点间距尽可能接近但不超过期望值 $\\Delta k$，从而在尊重网格划分的整数性质的同时，满足了近似各向同性采样分辨率的条件。\n\n得到的 MP 划分的有序三元组为 $(N_x, N_y, N_z)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left\\lceil \\frac{2\\pi}{a \\Delta k} \\right\\rceil  \\left\\lceil \\frac{2\\pi}{b \\Delta k} \\right\\rceil  \\left\\lceil \\frac{2\\pi}{c \\Delta k} \\right\\rceil\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "对于金属体系，展宽技术是保证计算收敛性所必需的，但它也引入了一个人为的电子温度，使得计算结果偏离真实的零温基态。本练习介绍了一种在专业计算中广泛使用的技术，即通过在多个展宽宽度 $\\sigma$ 下进行计算，并利用其误差随 $\\sigma$ 变化的已知规律，来精确外推出零展宽极限下的物理量。我们将看到，不同展宽方案的数学特性如何允许我们实现这种强大的误差消除策略。",
            "id": "3793477",
            "problem": "您的任务是实现一个协议，通过组合在多个电子展宽宽度下进行的计算，将金属体系中的原子力与应力分量外推至零展宽极限。外推方法必须基于布里渊区积分的解析性以及 Fermi-Dirac 分布和相关展宽分布的低温展开。其基本原理是，在 Mermin 有限温密度泛函理论 (DFT) 中，由占据数因子加权的能量解析函数的积分，可以按电子温度（与展宽宽度成正比）的偶次幂进行 Sommerfeld 型展开。因此，对于足够小的展宽宽度 $\\sigma$，诸如能量导出的物理量（力和应力）等可观测量可以建模为 $\\sigma$ 的偶次幂级数，其主导指数取决于所选的展宽方案。\n\n具体来说，假设三种广泛使用的展宽方案具有以下主导误差标度：\n- Fermi-Dirac 展宽：主导修正项与 $\\sigma^{2}$ 成比例，因此模型包含直至 $\\sigma^{4}$ 的项。\n- Marzari-Vanderbilt 冷展宽：主导修正项与 $\\sigma^{4}$ 成比例，因此模型包含直至 $\\sigma^{6}$ 的项。\n- $p$ 阶 Methfessel-Paxton 展宽：主导修正项与 $\\sigma^{2p+2}$ 成比例，因此对于 $p=1$ 的情况，模型包含直至 $\\sigma^{6}$ 的项。\n\n您必须实现一个程序，在每个测试案例中，针对指定的展宽方案，对测量的可观测量 $y(\\sigma)$ 与相应的 $\\sigma$ 的偶次幂基组进行线性回归，并返回外推的零展宽值 $y_{0}$（即 $\\sigma^{0}$ 项的系数）。使用与已知主导标度一致的最小多项式基，并包含一个更高阶的偶次幂项以捕捉次主导修正。在每种情况下，都必须对力分量和应力分量分别独立执行外推。\n\n所有物理单位都必须明确处理：\n- 力以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位提供，且必须以此单位返回。\n- 应力以 $\\mathrm{GPa}$ 为单位提供，且必须以此单位返回。\n- 展宽宽度 $\\sigma$ 以 $\\mathrm{eV}$ 为单位提供。\n\n您的程序必须实现以下测试套件。对于每个案例，使用从方案推断出的指定展宽指数，对力分量和应力分量分别进行一次回归。测量值是无噪声的，并且与偶次幂模型一致：\n\n- 案例 A (Fermi-Dirac 展宽)：\n  - 基组指数：$\\{0,2,4\\}$。\n  - 展宽宽度：$\\sigma \\in \\{0.05, 0.10, 0.15\\}\\,\\mathrm{eV}$。\n  - 以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位的力测量值：$y_{F}(\\sigma) \\in \\{0.253996875, 0.26595, 0.285746875\\}$。\n  - 以 $\\mathrm{GPa}$ 为单位的应力测量值：$y_{S}(\\sigma) \\in \\{4.925625, 4.71, 4.376\\}$。\n\n- 案例 B (Marzari-Vanderbilt 冷展宽)：\n  - 基组指数：$\\{0,4,6\\}$。\n  - 展宽宽度：$\\sigma \\in \\{0.05, 0.12, 0.20\\}\\,\\mathrm{eV}$。\n  - 以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位的力测量值：$y_{F}(\\sigma) \\in \\{-0.109980015625, -0.109339433984, -0.104944\\}$。\n  - 以 $\\mathrm{GPa}$ 为单位的应力测量值：$y_{S}(\\sigma) \\in \\{-1.50012421875, -1.5039979008, -1.5288\\}$。\n\n- 案例 C ($p=1$ 阶 Methfessel-Paxton 展宽)：\n  - 基组指数：$\\{0,4,6\\}$。\n  - 展宽宽度：$\\sigma \\in \\{0.0, 0.06, 0.12\\}\\,\\mathrm{eV}$。\n  - 以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位的力测量值：$y_{F}(\\sigma) \\in \\{0.035, 0.035012983328, 0.035208852992\\}$。\n  - 以 $\\mathrm{GPa}$ 为单位的应力测量值：$y_{S}(\\sigma) \\in \\{0.25, 0.2525733376, 0.2902776064\\}$。\n\n算法要求：\n- 对每个案例，构造一个设计矩阵 $X$，其元素为 $X_{ij} = \\sigma_{i}^{e_{j}}$，其中 $\\{\\sigma_{i}\\}$ 是展宽宽度，$\\{e_{j}\\}$ 是由展宽方案指定的基组指数。\n- 在最小二乘意义上求解线性系统，以获得最能拟合 $y(\\sigma) \\approx \\sum_{j} c_{e_{j}} \\sigma^{e_{j}}$ 的系数向量 $\\mathbf{c} = (c_{0}, c_{e_{1}}, c_{e_{2}})^{\\top}$。\n- 外推的零展宽值为 $y_{0} = c_{0}$。\n\n输出规范：\n- 您的程序必须生成单行输出，其中按以下顺序包含外推的零展宽值：$[F_{A},S_{A},F_{B},S_{B},F_{C},S_{C}]$，其中 $F_{\\cdot}$ 是以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位的力，$S_{\\cdot}$ 是以 $\\mathrm{GPa}$ 为单位的应力。\n- 每个条目必须是浮点数。\n- 不得打印任何额外的文本或行。\n\n您的程序必须是自包含的，不得要求任何用户输入，并且必须在 Python $3.12$ 环境下运行，仅使用 NumPy 库和 Python 标准库。最终输出必须以指定的单位表示，并严格按照要求的聚合格式打印。",
            "solution": "用户要求提供一种协议，用于将在金属体系中使用密度泛函理论 (DFT) 计算的原子力与应力外推至零展宽极限。此过程基于有限电子温度下布里渊区积分已广为接受的理论性质。\n\n基本原理源于 Mermin 的有限温 DFT 和 Sommerfeld 展开。在金属的电子结构计算中，电子态的占据由一个展宽函数描述，最常用的是 Fermi-Dirac 分布，$f((\\epsilon - \\mu)/\\sigma)$，其中 $\\epsilon$ 是能态能量，$\\mu$ 是化学势，$\\sigma$ 是展宽宽度，它与电子温度 ($T$) 成正比。物理可观测量，如总自由能 $F$、原子力 $\\mathbf{F} = -\\nabla_{\\mathbf{R}} F$ 和应力张量 $\\mathbf{\\tau} = (1/V) \\partial F / \\partial \\boldsymbol{\\epsilon}$，是通过在布里渊区上积分来计算的。这些积分涉及按占据函数加权的能态求和。\n\n对于从涉及占据函数的积分中导出的一般可观测量 $Y$，Sommerfeld 展开指出，对于小的展宽宽度 $\\sigma$，$Y(\\sigma)$ 可以表示为 $\\sigma$ 的偶次幂级数：\n$$\nY(\\sigma) = Y_0 + c_2 \\sigma^2 + c_4 \\sigma^4 + c_6 \\sigma^6 + \\mathcal{O}(\\sigma^8)\n$$\n值 $Y_0$ 代表真实的基态可观测量，对应于极限 $\\sigma \\to 0$（或零电子温度）。系数 $c_{2n}$ 取決于具体的可观测量和电子能带结构的细节。此展开中的主导误差项取决于所使用的具体展宽函数。问题描述指明了以下行为：\n-   **Fermi-Dirac (FD) 展宽**：主导误差与 $\\sigma^2$ 成正比。一个合适的模型包含直至 $\\sigma^4$ 的项：$Y(\\sigma) \\approx c_0 + c_2\\sigma^2 + c_4\\sigma^4$。\n-   **Marzari-Vanderbilt (MV) 冷展宽**：这种“冷展宽”技术旨在消除 $\\sigma^2$ 项，从而使得主导误差与 $\\sigma^4$ 成正比。模型包含下一个更高阶的项：$Y(\\sigma) \\approx c_0 + c_4\\sigma^4 + c_6\\sigma^6$。\n-   **$p=1$ 阶 Methfessel-Paxton (MP) 展宽**：此方法同样消除了低阶误差。对于 $p=1$ 阶，主导误差与 $\\sigma^{2p+2} = \\sigma^4$ 成正比。其模型与 MV 情况相同：$Y(\\sigma) \\approx c_0 + c_4\\sigma^4 + c_6\\sigma^6$。\n\n任务是通过对一组计算出的数据点 $\\{(\\sigma_i, y_i)\\}$ 进行线性回归来确定外推值 $Y_0 = c_0$。对于每个案例，我们都给出了3个数据点和一个包含3个未知系数的模型。这构成了一个恰定线性方程组。\n\n设给定案例的模型为 $y(\\sigma) = \\sum_{j=0}^{n-1} c_{e_j} \\sigma^{e_j}$，其中 $\\{e_j\\}$ 是指定的指数集合（例如，对于 FD 是 $\\{0, 2, 4\\}$）。对于一组 $m=n$ 个测量值 $(y_i, \\sigma_i)$，我们可以将该线性方程组写成矩阵形式：\n$$\n\\mathbf{y} = X\\mathbf{c}\n$$\n其中：\n-   $\\mathbf{y} = [y_1, y_2, \\dots, y_m]^\\top$ 是可观测量测量值的向量。\n-   $\\mathbf{c} = [c_{e_0}, c_{e_1}, \\dots, c_{e_{n-1}}]^\\top$ 是未知系数的向量。期望的外推值是 $c_{e_0}$，它对应于指数 $e_0=0$。\n-   $X$ 是 $m \\times n$ 的设计矩阵，其元素为 $X_{ij} = \\sigma_i^{e_j}$。\n\n对于问题中的每个测试案例，我们有3个数据点和一个3参数模型，因此设计矩阵 $X$ 是一个 $3 \\times 3$ 的方阵。\n$$\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\sigma_1^{e_0}  \\sigma_1^{e_1}  \\sigma_1^{e_2} \\\\\n\\sigma_2^{e_0}  \\sigma_2^{e_1}  \\sigma_2^{e_2} \\\\\n\\sigma_3^{e_0}  \\sigma_3^{e_1}  \\sigma_3^{e_2}\n\\end{pmatrix}\n\\begin{pmatrix}\nc_{e_0} \\\\\nc_{e_1} \\\\\nc_{e_2}\n\\end{pmatrix}\n$$\n由于每个案例中提供的 $\\sigma_i$ 值都是不同的，矩阵 $X$ 是非奇异的，因此系数向量 $\\mathbf{c}$ 的系统有唯一解。这个解可以通过求解线性系统找到，例如使用 `numpy.linalg.solve`。外推的零展宽值是所得解向量 $\\mathbf{c}$ 的第一个元素，对应于 $\\sigma^0$ 项的系数。\n\n此过程独立应用于六个子问题（案例 A、B 和 C 的力和应力）中的每一个。对于案例 C，其中一个数据点是在 $\\sigma_3=0$ 处给出的，设计矩阵中的相应行变为 $(1, 0, 0)$，因为 $0^0=1$ 且对于 $k0$ 有 $0^k=0$。这正确地得出 $c_{e_0} = y_3$，证实了如果在零展宽处有测量值，那么根据定义它就是外推值。算法必须能正确处理这种情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef extrapolate_to_zero_smearing(sigmas, values, exponents):\n    \"\"\"\n    Performs a linear regression to extrapolate an observable to zero smearing width.\n\n    The function sets up and solves a system of linear equations y = Xc, where y are\n    the observable values, X is the design matrix derived from smearing widths and\n    model exponents, and c are the model coefficients. The extrapolated value is\n    the coefficient corresponding to the zero-power term.\n\n    Args:\n        sigmas (list or np.ndarray): A sequence of smearing widths, σ.\n        values (list or np.ndarray): A sequence of corresponding observable values, y(σ).\n        exponents (list or np.ndarray): The powers of sigma to use in the polynomial model.\n\n    Returns:\n        float: The extrapolated value at σ = 0, which is the coefficient c_0.\n    \"\"\"\n    num_points = len(sigmas)\n    num_coeffs = len(exponents)\n\n    # For the problem as specified, the number of data points equals the\n    # number of model coefficients, resulting in an exactly determined system.\n    if num_points != num_coeffs:\n        raise ValueError(\n            \"The number of data points must equal the number of model parameters for this problem.\"\n        )\n\n    # Construct the design matrix X, where X[i, j] = sigmas[i]**exponents[j].\n    # In Python, 0.0**0 is correctly evaluated as 1.0.\n    X = np.zeros((num_points, num_coeffs))\n    for i in range(num_points):\n        for j in range(num_coeffs):\n            X[i, j] = sigmas[i] ** exponents[j]\n\n    # Convert the values list to a NumPy column vector for the solver.\n    y = np.array(values)\n\n    # Solve the linear system X * c = y for the coefficients c.\n    # np.linalg.solve is appropriate for square, non-singular systems.\n    coefficients = np.linalg.solve(X, y)\n\n    # The first exponent is specified as 0, so the first coefficient\n    # is the extrapolated value at sigma=0.\n    zero_smearing_value = coefficients[0]\n    \n    return zero_smearing_value\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the extrapolation for each,\n    and print the aggregated results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Fermi-Dirac smearing\n        {\n            \"exponents\": [0, 2, 4],\n            \"sigmas\": [0.05, 0.10, 0.15],\n            \"forces\": [0.253996875, 0.26595, 0.285746875],   # eV/Angstrom\n            \"stresses\": [4.925625, 4.71, 4.376],           # GPa\n        },\n        # Case B: Marzari-Vanderbilt cold smearing\n        {\n            \"exponents\": [0, 4, 6],\n            \"sigmas\": [0.05, 0.12, 0.20],\n            \"forces\": [-0.109980015625, -0.109339433984, -0.104944],\n            \"stresses\": [-1.50012421875, -1.5039979008, -1.5288],\n        },\n        # Case C: Methfessel-Paxton smearing of order p=1\n        {\n            \"exponents\": [0, 4, 6],\n            \"sigmas\": [0.0, 0.06, 0.12],\n            \"forces\": [0.035, 0.035012983328, 0.035208852992],\n            \"stresses\": [0.25, 0.2525733376, 0.2902776064],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extrapolate the force component\n        force_extrapolated = extrapolate_to_zero_smearing(\n            case[\"sigmas\"], case[\"forces\"], case[\"exponents\"]\n        )\n        results.append(force_extrapolated)\n\n        # Extrapolate the stress component\n        stress_extrapolated = extrapolate_to_zero_smearing(\n            case[\"sigmas\"], case[\"stresses\"], case[\"exponents\"]\n        )\n        results.append(stress_extrapolated)\n\n    # The final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}