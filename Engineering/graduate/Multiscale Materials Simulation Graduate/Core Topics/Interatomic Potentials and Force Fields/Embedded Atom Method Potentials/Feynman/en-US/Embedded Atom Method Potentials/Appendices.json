{
    "hands_on_practices": [
        {
            "introduction": "The host electron density, $\\rho_i$, is the cornerstone of the Embedded Atom Method, representing the local electronic environment that determines an atom's embedding energy. This first exercise provides fundamental practice in calculating this crucial quantity directly from its definition. By applying the EAM formalism to a perfect face-centered cubic (fcc) crystal, you will connect the abstract formula to concrete crystallographic concepts like coordination numbers and neighbor shells, building a solid foundation for more complex EAM calculations .",
            "id": "3754290",
            "problem": "Consider a monatomic crystal with face-centered cubic (fcc) structure and conventional cubic lattice parameter $a$. In the Embedded Atom Method (EAM), the host electron density at atom $i$ is defined as $\\rho_i = \\sum_{j \\neq i} f(r_{ij})$, where $r_{ij}$ is the scalar distance between atoms $i$ and $j$, and $f(r)$ is a spherically decaying electron cloud contribution from atom $j$ to atom $i$. Assume $f(r) = \\rho_s \\exp(-\\alpha r)$, where $\\rho_s$ is a constant amplitude and $\\alpha > 0$ is the decay rate. \n\nStarting from the definition of the electron density and the geometric structure of an fcc lattice, do the following:\n\n1. Determine, from first principles of the fcc geometry, the distances and coordination numbers for the first three neighbor shells around a given atom. Use these to construct the truncated host electron density $\\rho_i^{(3)}(\\alpha,a)$ that includes only contributions from the first three shells. Express $\\rho_i^{(3)}(\\alpha,a)$ in a closed form in terms of $a$, $\\alpha$, and $\\rho_s$.\n\n2. Define the shell contributions $C_k(\\alpha,a)$ for $k=1,2,3$ as the partial sums from the $k$-th shell alone. Analyze qualitatively and quantitatively how the relative weights $w_k(\\alpha,a) = C_k(\\alpha,a)\\big/\\sum_{m=1}^{3}C_m(\\alpha,a)$ vary with $\\alpha$, including their limiting behavior as $\\alpha \\to 0^{+}$ and as $\\alpha \\to +\\infty$.\n\n3. To quantify when the first shell “dominates,” enforce the constraint that the second and third shell contributions are each no more than $5\\%$ of the first-shell contribution, i.e., $C_2(\\alpha,a) \\leq 0.05\\,C_1(\\alpha,a)$ and $C_3(\\alpha,a) \\leq 0.05\\,C_1(\\alpha,a)$. Derive the minimal decay rate $\\alpha^{\\ast}(a)$ that satisfies both constraints simultaneously, and provide $\\alpha^{\\ast}(a)$ as a single, closed-form analytical expression.\n\nProvide the final answer as a single analytical expression for $\\alpha^{\\ast}(a)$, with no numerical rounding. No units are required because the answer must be expressed symbolically in terms of $a$.",
            "solution": "We begin from the Embedded Atom Method (EAM) definition of host electron density at site $i$,\n$$\n\\rho_i \\;=\\; \\sum_{j \\neq i} f(r_{ij}),\n$$\nwith $f(r) = \\rho_s \\exp(-\\alpha r)$, where $\\rho_s$ is a constant amplitude and $\\alpha > 0$ is the decay parameter. For a perfect face-centered cubic (fcc) crystal with conventional cubic lattice parameter $a$, the distances to neighbors occur in discrete shells determined by the lattice geometry. We will construct the first three shells from geometric considerations and then build $\\rho_i^{(3)}(\\alpha,a)$.\n\nFirst, we recall the geometry of the fcc lattice. In the conventional cubic cell of edge length $a$, the lattice points are at the cube corners and the face centers. Equivalently, relative position vectors connecting a site at the origin to another lattice site can be expressed with components that are either integers or half-integers, subject to fcc parity constraints. The neighbor shells are characterized by distances determined by these vectors.\n\nWe now enumerate the first three shells:\n\n1. Nearest neighbors ($k=1$): A nearest neighbor is located at a face-centered position relative to the origin. Representative vectors are $\\left(0,\\frac{a}{2},\\frac{a}{2}\\right)$ and permutations with sign. The distance is\n$$\nr_1 \\;=\\; \\sqrt{\\left(\\frac{a}{2}\\right)^{2}+\\left(\\frac{a}{2}\\right)^{2}} \\;=\\; \\frac{a}{\\sqrt{2}}.\n$$\nThere are $12$ such nearest neighbors in fcc, so the coordination number is $z_1 = 12$.\n\n2. Second neighbors ($k=2$): These lie along the cubic axes, e.g., $(a,0,0)$, $(0,a,0)$, $(0,0,a)$ and their negatives. The distance is\n$$\nr_2 \\;=\\; a,\n$$\nand there are $6$ such neighbors, so $z_2 = 6$.\n\n3. Third neighbors ($k=3$): A representative vector for the third shell is $\\left(a,\\frac{a}{2},\\frac{a}{2}\\right)$ and permutations with appropriate signs, which yields a distance\n$$\nr_3 \\;=\\; \\sqrt{a^{2}+\\left(\\frac{a}{2}\\right)^{2}+\\left(\\frac{a}{2}\\right)^{2}} \\;=\\; a\\sqrt{\\frac{3}{2}}.\n$$\nThere are $24$ such neighbors in this shell, so $z_3 = 24$.\n\nGiven $f(r) = \\rho_s \\exp(-\\alpha r)$, the shell contributions $C_k(\\alpha,a)$ and the truncated electron density $\\rho_i^{(3)}(\\alpha,a)$ are\n$$\nC_1(\\alpha,a) \\;=\\; z_1\\,\\rho_s \\exp\\!\\left(-\\alpha r_1\\right) \\;=\\; 12\\,\\rho_s \\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right),\n$$\n$$\nC_2(\\alpha,a) \\;=\\; z_2\\,\\rho_s \\exp\\!\\left(-\\alpha r_2\\right) \\;=\\; 6\\,\\rho_s \\exp(-\\alpha a),\n$$\n$$\nC_3(\\alpha,a) \\;=\\; z_3\\,\\rho_s \\exp\\!\\left(-\\alpha r_3\\right) \\;=\\; 24\\,\\rho_s \\exp\\!\\left(-\\alpha a\\sqrt{\\frac{3}{2}}\\right),\n$$\nand hence\n$$\n\\rho_i^{(3)}(\\alpha,a) \\;=\\; C_1(\\alpha,a) + C_2(\\alpha,a) + C_3(\\alpha,a) \\;=\\; \\rho_s\\left[12\\,\\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right) + 6\\,\\exp(-\\alpha a) + 24\\,\\exp\\!\\left(-\\alpha a\\sqrt{\\frac{3}{2}}\\right)\\right].\n$$\n\nWe define the relative weights $w_k(\\alpha,a)$ over the first three shells by\n$$\nw_k(\\alpha,a) \\;=\\; \\frac{C_k(\\alpha,a)}{C_1(\\alpha,a)+C_2(\\alpha,a)+C_3(\\alpha,a)}.\n$$\nQualitative and quantitative dependence on $\\alpha$ follows from monotonicity of the exponential. As $\\alpha$ increases, $\\exp(-\\alpha r)$ decays faster with $r$, so nearer neighbors contribute relatively more, meaning $w_1(\\alpha,a)$ increases while $w_2(\\alpha,a)$ and $w_3(\\alpha,a)$ decrease. In the limit $\\alpha \\to 0^{+}$, $\\exp(-\\alpha r)\\to 1$, so shell weights are proportional only to coordination numbers:\n$$\n\\lim_{\\alpha\\to 0^{+}}w_1 \\;=\\; \\frac{12}{12+6+24} \\;=\\; \\frac{12}{42} \\;=\\; \\frac{2}{7},\n$$\n$$\n\\lim_{\\alpha\\to 0^{+}}w_2 \\;=\\; \\frac{6}{42} \\;=\\; \\frac{1}{7},\n$$\n$$\n\\lim_{\\alpha\\to 0^{+}}w_3 \\;=\\; \\frac{24}{42} \\;=\\; \\frac{4}{7}.\n$$\nIn the opposite limit $\\alpha \\to +\\infty$, $\\exp(-\\alpha r)$ suppresses all but the shortest distance, yielding\n$$\n\\lim_{\\alpha\\to +\\infty}w_1 \\;=\\; 1,\\qquad \\lim_{\\alpha\\to +\\infty}w_2 \\;=\\; 0,\\qquad \\lim_{\\alpha\\to +\\infty}w_3 \\;=\\; 0.\n$$\n\nWe now quantify the condition under which the first shell “dominates” by imposing $C_2(\\alpha,a) \\leq 0.05\\, C_1(\\alpha,a)$ and $C_3(\\alpha,a) \\leq 0.05\\, C_1(\\alpha,a)$. These two inequalities yield lower bounds on $\\alpha$; the minimal $\\alpha$ satisfying both is the maximum of these bounds.\n\nFirst, compare shell $2$ to shell $1$:\n$$\n\\frac{C_2}{C_1} \\;=\\; \\frac{6\\,\\rho_s \\exp(-\\alpha a)}{12\\,\\rho_s \\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right)} \\;=\\; \\frac{1}{2}\\,\\exp\\!\\left(-\\alpha\\left[a - \\frac{a}{\\sqrt{2}}\\right]\\right).\n$$\nThe constraint $\\frac{C_2}{C_1} \\leq 0.05$ gives\n$$\n\\frac{1}{2}\\,\\exp\\!\\left(-\\alpha a\\left[1 - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; 0.05 \n\\quad\\Longrightarrow\\quad\n\\exp\\!\\left(-\\alpha a\\left[1 - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; 0.1 \n\\quad\\Longrightarrow\\quad\n\\alpha \\;\\geq\\; \\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}.\n$$\n\nSecond, compare shell $3$ to shell $1$:\n$$\n\\frac{C_3}{C_1} \\;=\\; \\frac{24\\,\\rho_s \\exp\\!\\left(-\\alpha a\\sqrt{\\frac{3}{2}}\\right)}{12\\,\\rho_s \\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right)} \\;=\\; 2\\,\\exp\\!\\left(-\\alpha a\\left[\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right]\\right).\n$$\nThe constraint $\\frac{C_3}{C_1} \\leq 0.05$ gives\n$$\n2\\,\\exp\\!\\left(-\\alpha a\\left[\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; 0.05 \n\\quad\\Longrightarrow\\quad\n\\exp\\!\\left(-\\alpha a\\left[\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; \\frac{0.05}{2} \\;=\\; 0.025 \n\\quad\\Longrightarrow\\quad\n\\alpha \\;\\geq\\; \\frac{\\ln\\!\\left(\\frac{40}{1}\\right)}{a\\left(\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right)} \\;=\\; \\frac{\\ln(40)}{a\\left(\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right)}.\n$$\n\nTherefore, the minimal decay rate $\\alpha^{\\ast}(a)$ that guarantees both constraints is\n$$\n\\alpha^{\\ast}(a) \\;=\\; \\max\\!\\left\\{\\, \\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}\\,,\\, \\frac{\\ln(40)}{a\\left(\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right)} \\right\\}.\n$$\nWe can determine which bound is larger without numerical rounding by comparing the two denominators and numerators. Observe that $a\\left(\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right) \\;=\\; \\frac{a}{\\sqrt{2}}\\left(\\sqrt{3}-1\\right)$ is larger than $a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)$ because $\\sqrt{3}-1 > 1 - \\frac{1}{\\sqrt{2}}$; meanwhile $\\ln(40) > \\ln(10)$. Computing the exact values of the ratios reveals\n$$\n\\frac{\\ln(10)}{1 - \\frac{1}{\\sqrt{2}}} \\;>\\; \\frac{\\ln(40)}{\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}},\n$$\nand thus the first term dominates the maximum. Consequently, the minimal decay rate is\n$$\n\\alpha^{\\ast}(a) \\;=\\; \\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}.\n$$\nThis closed-form expression provides the symbolic dependence of the threshold decay rate on the lattice parameter $a$ that ensures each of the second and third shell contributions is no more than $5\\%$ of the first-shell contribution, thereby establishing first-shell dominance over the first three shells.",
            "answer": "$$\\boxed{\\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}}$$"
        },
        {
            "introduction": "While the EAM formalism is elegant in theory, its practical implementation in computer simulations requires careful treatment of the potential's finite range, typically enforced with a cutoff radius $r_c$. This exercise explores the critical consequences of how a potential is terminated, revealing that a simple truncation leads to unphysical discontinuities in forces and stresses. You will derive the mathematical conditions for a smooth taper function that guarantees continuity for the energy, forces, and virial stress, a crucial technique used in virtually all modern simulation software .",
            "id": "3754243",
            "problem": "Consider a metal modeled with the Embedded Atom Method (EAM), whose total energy for a configuration of atoms at positions $\\{\\mathbf{r}_i\\}$ is defined by\n$$\nE = \\sum_{i} F(\\rho_i) + \\frac{1}{2} \\sum_{i \\neq j} \\phi(r_{ij}), \\quad \\rho_i = \\sum_{j \\neq i} g(r_{ij}),\n$$\nwhere $r_{ij} = |\\mathbf{r}_i - \\mathbf{r}_j|$, $F(\\rho)$ is the embedding energy as a function of the host electron density $\\rho_i$, $\\phi(r)$ is a pair interaction, and $g(r)$ is the electron density contribution from an atom at separation $r$. In practice, each radial function is truncated at a finite cutoff radius $r_c$ to maintain computational efficiency. A naive truncation $f(r) \\mapsto f(r) \\,\\Theta(r_c - r)$, with $\\Theta$ the Heaviside step function and $f \\in \\{\\phi,g\\}$, can induce discontinuities in forces and in the virial-based stress when atom pairs cross $r_c$ during dynamics or when the configuration is subjected to an infinitesimal homogeneous strain.\n\nTo eliminate these artifacts, one replaces $f(r)$ by a tapered form $f(r) s(r)$, where $s(r)$ transitions smoothly from $1$ to $0$ in an interval $[r_s, r_c]$ with $r_s < r_c$, and is constant outside the interval. Starting from the EAM energy definition, the force definition $\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E$, and the virial (Irving–Kirkwood) stress definition for pairwise central forces, argue how the differentiability of $s(r)$ near $r_c$ impacts the continuity of forces and virials, and determine the minimal smoothness requirements on $s(r)$ at $r = r_c$ and at $r = r_s$ so that both the forces and the virial are continuous functions of the atomic positions and of an infinitesimal homogeneous strain parameter.\n\nThen, constrained by these smoothness requirements and by $s(r)$ being constant outside $[r_s,r_c]$, construct the lowest-degree polynomial taper $s(r)$ on the interval $[r_s, r_c]$ that satisfies the boundary conditions implied by your analysis. Express your final result as a single closed-form analytic expression for $s(r)$ valid for $r \\in [r_s, r_c]$ in terms of $r$, $r_s$, and $r_c$ only. No numerical approximation is required for the final answer.",
            "solution": "The analysis proceeds in two parts. First, we determine the minimal smoothness requirements on the taper function $s(r)$. Second, we construct the specific polynomial form of $s(r)$ that satisfies these requirements.\n\nLet the modified, tapered potential functions be $\\tilde{\\phi}(r) = \\phi(r)s(r)$ and $\\tilde{g}(r) = g(r)s(r)$. The total energy is then:\n$$\nE = \\sum_{i} F\\left( \\sum_{j \\neq i} \\tilde{g}(r_{ij}) \\right) + \\frac{1}{2} \\sum_{i \\neq j} \\tilde{\\phi}(r_{ij})\n$$\n\n**1. Continuity of Forces**\n\nThe force on atom $k$ is the negative gradient of the total energy with respect to its position $\\mathbf{r}_k$:\n$$\n\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E = -\\nabla_{\\mathbf{r}_k} \\left( \\sum_i F(\\rho_i) + \\frac{1}{2}\\sum_{i \\neq j} \\tilde{\\phi}(r_{ij}) \\right)\n$$\nwhere $\\rho_i = \\sum_{j \\neq i} \\tilde{g}(r_{ij})$.\nLet's evaluate the gradient term by term. The gradient of the pair term is:\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\frac{1}{2}\\sum_{i \\neq j} \\tilde{\\phi}(r_{ij}) \\right) = -\\sum_{j \\neq k} \\frac{d\\tilde{\\phi}(r_{kj})}{dr_{kj}} \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = -\\sum_{j \\neq k} \\tilde{\\phi}'(r_{kj}) \\hat{\\mathbf{r}}_{kj}\n$$\nwhere $\\hat{\\mathbf{r}}_{kj} = (\\mathbf{r}_k - \\mathbf{r}_j) / r_{kj}$.\n\nThe gradient of the embedding energy term is more complex:\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\sum_i F(\\rho_i) \\right) = - \\sum_i \\frac{dF}{d\\rho_i} \\nabla_{\\mathbf{r}_k} \\rho_i = -\\sum_i F'(\\rho_i) \\nabla_{\\mathbf{r}_k} \\left( \\sum_{j \\neq i} \\tilde{g}(r_{ij}) \\right)\n$$\nThe gradient $\\nabla_{\\mathbf{r}_k} \\rho_i$ is non-zero only when the sum for $\\rho_i$ involves atom $k$. This occurs when $i=k$ or $j=k$.\n-   For $i=k$: $\\nabla_{\\mathbf{r}_k} \\rho_k = \\nabla_{\\mathbf{r}_k} \\sum_{j \\neq k} \\tilde{g}(r_{kj}) = \\sum_{j \\neq k} \\tilde{g}'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}$.\n-   For $j=k$ (in the sum for $\\rho_i$, with $i \\neq k$): $\\nabla_{\\mathbf{r}_k} \\tilde{g}(r_{ik}) = \\tilde{g}'(r_{ik}) \\frac{\\mathbf{r}_k - \\mathbf{r}_i}{r_{ik}}$.\n\nCombining these, the embedding force on atom $k$ is:\n$$\n-F'(\\rho_k) \\sum_{j \\neq k} \\tilde{g}'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} - \\sum_{i \\neq k} F'(\\rho_i) \\tilde{g}'(r_{ik}) \\frac{\\mathbf{r}_k - \\mathbf{r}_i}{r_{ik}}\n$$\nBy relabeling the index $i$ to $j$ in the second sum, we can combine terms:\n$$\n-\\sum_{j \\neq k} \\left[ F'(\\rho_k) \\tilde{g}'(r_{kj}) + F'(\\rho_j) \\tilde{g}'(r_{jk}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\nThe total force on atom $k$ is the sum of the pair and embedding contributions:\n$$\n\\mathbf{F}_k = - \\sum_{j \\neq k} \\left[ \\tilde{\\phi}'(r_{kj}) + F'(\\rho_k)\\tilde{g}'(r_{kj}) + F'(\\rho_j)\\tilde{g}'(r_{kj}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\nFor the force $\\mathbf{F}_k$ to be a continuous function of atomic positions, the terms $\\tilde{\\phi}'(r)$ and $\\tilde{g}'(r)$ must be continuous functions of $r$. The derivative of $\\tilde{\\phi}(r) = \\phi(r)s(r)$ is $\\tilde{\\phi}'(r) = \\phi'(r)s(r) + \\phi(r)s'(r)$. Assuming the base functions $\\phi(r)$ and $\\phi'(r)$ are smooth, continuity of $\\tilde{\\phi}'(r)$ across the boundaries $r_s$ and $r_c$ requires that both $s(r)$ and $s'(r)$ be continuous. This means $s(r)$ must be continuously differentiable, i.e., $s(r) \\in C^1$.\nThe required boundary conditions for $C^1$ continuity are:\n-   $s(r)$ must be continuous: $s(r_s) = 1$ and $s(r_c) = 0$.\n-   $s'(r)$ must be continuous: $s'(r_s) = 0$ (since $s'(r)=0$ for $r < r_s$) and $s'(r_c) = 0$ (since $s'(r)=0$ for $r > r_c$).\n\n**2. Continuity of Virial Stress and its Derivatives**\n\nThe virial tensor, which is related to the stress tensor, can be expressed as a sum over pairs of atoms. For the EAM potential, it is given by:\n$$\n\\mathcal{V}_{\\alpha\\beta} = \\frac{1}{2} \\sum_{i \\neq j} r_{ij, \\alpha} F_{ij, \\beta}\n$$\nwhere $F_{ij, \\beta}$ is the $\\beta$-component of the force on atom $i$ due to atom $j$. By symmetrizing the force expression, the virial can be written as:\n$$\n\\boldsymbol{\\mathcal{V}} = -\\frac{1}{2} \\sum_{i \\neq j} \\frac{1}{r_{ij}} \\left[ \\tilde{\\phi}'(r_{ij}) + (F'(\\rho_i)+F'(\\rho_j))\\tilde{g}'(r_{ij}) \\right] \\mathbf{r}_{ij} \\otimes \\mathbf{r}_{ij}\n$$\nContinuity of the virial tensor itself as a function of atomic positions requires the coefficient in the brackets to be continuous, which in turn requires $\\tilde{\\phi}'(r)$ and $\\tilde{g}'(r)$ to be continuous. This is the same $C^1$ requirement for $s(r)$ as derived for the forces.\n\nHowever, the problem requires continuity with respect to an \"infinitesimal homogeneous strain parameter\". This implies that physical quantities derived from strain derivatives of the energy, such as the elastic constants, must also be continuous. The elastic constant tensor is $C_{\\alpha\\beta\\mu\\nu} = \\frac{1}{V} \\frac{\\partial^2 E}{\\partial \\epsilon_{\\alpha\\beta} \\partial \\epsilon_{\\mu\\nu}}$. For the elastic constants to be continuous functions as atom pairs cross the cutoff boundaries, the second derivatives of the effective potentials, $\\tilde{\\phi}''(r)$ and $\\tilde{g}''(r)$, must be continuous.\n\nLet's examine the second derivative of $\\tilde{\\phi}(r)$:\n$$\n\\tilde{\\phi}''(r) = \\frac{d}{dr}\\left[\\phi'(r)s(r) + \\phi(r)s'(r)\\right] = \\phi''(r)s(r) + 2\\phi'(r)s'(r) + \\phi(r)s''(r)\n$$\nAssuming the base functions $\\phi(r)$ and its derivatives are smooth, continuity of $\\tilde{\\phi}''(r)$ across $r_s$ and $r_c$ requires $s(r)$, $s'(r)$, and $s''(r)$ to be continuous. Therefore, the minimal smoothness requirement for a physically robust potential that yields continuous forces, stresses, and elastic constants is that the taper function $s(r)$ must be twice continuously differentiable, i.e., $s(r) \\in C^2$.\n\nThis imposes two additional boundary conditions:\n-   $s''(r)$ must be continuous: $s''(r_s) = 0$ and $s''(r_c) = 0$.\n\nIn summary, we have six boundary conditions for $s(r)$ on the interval $[r_s, r_c]$:\n1.  $s(r_s) = 1$\n2.  $s(r_c) = 0$\n3.  $s'(r_s) = 0$\n4.  $s'(r_c) = 0$\n5.  $s''(r_s) = 0$\n6.  $s''(r_c) = 0$\n\n**3. Construction of the Polynomial Taper**\n\nTo satisfy these six conditions with the lowest-degree polynomial, we need a polynomial of degree $5$ (a quintic polynomial). Let's define a normalized variable $x = \\frac{r - r_s}{r_c - r_s}$, so that $x \\in [0, 1]$ as $r \\in [r_s, r_c]$. Let our polynomial be $s(r) = P(x)$.\nThe boundary conditions in terms of $P(x)$ are:\n-   $P(0) = 1$\n-   $P(1) = 0$\n-   $P'(0) = 0$ (since $s' \\propto P'$)\n-   $P'(1) = 0$\n-   $P''(0) = 0$ (since $s'' \\propto P''$)\n-   $P''(1) = 0$\n\nLet $P(x) = a x^5 + b x^4 + c x^3 + d x^2 + e x + f$.\n-   $P(0)=1 \\implies f=1$.\n-   $P'(x) = 5ax^4 + 4bx^3 + 3cx^2 + 2dx + e$. $P'(0)=0 \\implies e=0$.\n-   $P''(x) = 20ax^3 + 12bx^2 + 6cx + 2d$. $P''(0)=0 \\implies d=0$.\n\nSo the polynomial simplifies to $P(x) = ax^5 + bx^4 + cx^3 + 1$. Now apply the conditions at $x=1$:\n1.  $P(1) = a+b+c+1 = 0$\n2.  $P'(1) = 5a+4b+3c = 0$\n3.  $P''(1) = 20a+12b+6c = 0$, which simplifies to $10a+6b+3c = 0$.\n\nWe solve this system of three linear equations.\nFrom (1), $c = -1 - a - b$. Substituting into (2) and (3):\n-   $5a+4b+3(-1-a-b) = 0 \\implies 2a+b=3$\n-   $10a+6b+3(-1-a-b) = 0 \\implies 7a+3b=3$\n\nFrom $2a+b=3$, we have $b=3-2a$. Substituting this into the second equation:\n$7a+3(3-2a)=3 \\implies 7a+9-6a=3 \\implies a = -6$.\nThen, $b = 3-2(-6) = 15$.\nFinally, $c = -1 - (-6) - 15 = -10$.\n\nThe coefficients are $a=-6, b=15, c=-10, d=0, e=0, f=1$. The polynomial in the normalized coordinate is:\n$$\nP(x) = -6x^5 + 15x^4 - 10x^3 + 1\n$$\nSubstituting back $x = \\frac{r - r_s}{r_c - r_s}$, we obtain the final expression for the taper function $s(r)$ on the interval $[r_s, r_c]$.",
            "answer": "$$\n\\boxed{-6 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^5 + 15 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^4 - 10 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^3 + 1}\n$$"
        },
        {
            "introduction": "Having explored the analytical foundations of the EAM, this final practice transitions from theory to computation, a vital skill for any modeler. You will design and implement an efficient, $O(N)$ algorithm to compute the electron density $\\rho_i$ for all atoms in a system, based on a tabulated potential function and a neighbor list. This exercise emphasizes the practical details of writing simulation code, including correct interpolation, handling unique neighbor pairs with symmetric updates to prevent double counting, and organizing data for efficient memory access .",
            "id": "3754216",
            "problem": "You are given the definition of the Embedded Atom Method (EAM) electron density for each atom as follows: for an atom indexed by $i$, the scalar electron density $\\rho_i$ is defined by the sum of pairwise contributions over its neighbors,\n$$\n\\rho_i = \\sum_{j \\neq i} f\\!\\left(r_{ij}\\right),\n$$\nwhere $f(r)$ is a scalar-valued radial function tabulated at discrete sample radii, and $r_{ij}$ is the distance between atom $i$ and atom $j$. In a neighbor-list formulation, each neighbor pair $(i,j)$ represents an unordered interaction between two distinct atoms. The neighbor list is assumed to be unique (for example, only pairs with $j > i$ are listed), so that no pair appears more than once. The goal is to compute all $\\rho_i$ while achieving a single-pass, $O(N)$ algorithm under the assumption of a bounded average neighbor count per atom, minimizing cache misses by using contiguous arrays and locality-preserving iteration, and avoiding double counting by updating symmetric contributions once per pair.\n\nFundamental basis and assumptions:\n- The electron density definition above is the starting point. No higher-level EAM energy expression involving embedding energies is required in this task.\n- The function $f(r)$ is provided as a tabulation at radial points. Interpolation between tabulated points must be performed using piecewise-linear interpolation. Explicitly:\n  - If $r \\le r_{\\min}$, then $f(r) = f(r_{\\min})$.\n  - If $r \\ge r_{\\max}$, then $f(r) = 0$.\n  - Otherwise, $f(r)$ is the linear interpolation between the two nearest tabulated radii surrounding $r$.\n- The neighbor list contains unique unordered pairs $(i,j)$ with associated distances $r_{ij}$, and no periodic boundary conditions are required. There is no need to infer distances from positions; distances are provided directly in the neighbor list. All atoms are indexed from $0$ to $N-1$.\n\nAlgorithmic requirements:\n- Design an in-place accumulation algorithm that iterates over the neighbor list exactly once. For each pair $(i,j)$ with distance $r_{ij}$, compute $f(r_{ij})$ and add this contribution to both $\\rho_i$ and $\\rho_j$.\n- Use structure-of-arrays organization for the pair indices and distances, and sort pairs by the first index $i$ before accumulation to enhance spatial locality and reduce cache misses.\n- Prove that under a fixed maximum neighbor count per atom, the total runtime scales as $O(N)$.\n- Ensure no double counting occurs by never traversing both $(i,j)$ and $(j,i)$; instead, traverse the unique pair list and update both atoms in one step.\n\nTabulated function for all test cases:\n- Radii samples: $r$ equal to $0.0$, $1.0$, $2.0$, $3.0$, $3.5$.\n- Function samples: $f(r)$ equal to $1.0$, $0.8$, $0.3$, $0.1$, $0.0$.\n\nTest suite:\n- Test case $1$ (happy path): $N = 4$ atoms. Neighbor pairs with distances:\n  - $(0,1,1.0)$,\n  - $(0,2,2.0)$,\n  - $(1,2,1.0)$,\n  - $(2,3,2.0)$.\n- Test case $2$ (boundary: no neighbors): $N = 3$ atoms. Neighbor pairs list is empty.\n- Test case $3$ (interpolation coverage): $N = 5$ atoms. Neighbor pairs with distances:\n  - $(0,1,0.5)$,\n  - $(0,2,1.5)$,\n  - $(1,3,2.75)$,\n  - $(2,4,1.5)$,\n  - $(3,4,0.5)$.\n- Test case $4$ (exact endpoint at $r_{\\max}$): $N = 2$ atoms. Neighbor pairs with distance:\n  - $(0,1,3.5)$.\n\nUnits:\n- Distances $r$ are in arbitrary length units, and $f(r)$ and $\\rho_i$ are dimensionless. No physical unit conversion is required.\n\nYour task:\n- Implement the algorithm described above in a single, self-contained program that constructs the tabulated function and the test suite, performs piecewise-linear interpolation, computes all $\\rho_i$ using a single pass over unique pairs while minimizing cache misses and avoiding double counting, and prints the resulting electron densities for each test case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of floats in the order of atom indices from $0$ to $N-1$. For example, the output must look like $[[\\rho_{0}^{(1)},\\rho_{1}^{(1)},\\dots],\\,[\\rho_{0}^{(2)},\\rho_{1}^{(2)},\\dots],\\,\\dots]$ without any additional text.",
            "solution": "The problem requires the implementation of an algorithm to compute the Embedded Atom Method (EAM) electron density $\\rho_i$ for a system of $N$ atoms. The electron density for an atom $i$ is defined as the sum of contributions from its neighboring atoms $j$:\n$$\n\\rho_i = \\sum_{j \\neq i} f(r_{ij})\n$$\nwhere $r_{ij}$ is the distance between atom $i$ and atom $j$, and $f(r)$ is a radial pair function. The problem provides a tabulated form of $f(r)$ and specifies a piecewise-linear interpolation scheme to evaluate it at arbitrary distances. The core of the task is to design and implement an efficient, single-pass algorithm that correctly computes all $\\rho_i$ values for a given set of unique neighbor pairs $(i,j)$.\n\nThe algorithm must adhere to several key principles for correctness and efficiency:\n1.  **Symmetric Update**: The neighbor list is composed of unique, unordered pairs $(i,j)$. The contribution of this pair to the total system is based on $f(r_{ij})$. This single value must be added to the density of atom $i$ and, symmetrically, to the density of atom $j$. An algorithm that iterates through this unique list and performs this dual update for each pair guarantees that every interaction is counted exactly once and that the final sums for $\\rho_i$ are correct.\n2.  **Data Locality**: For large-scale simulations, memory access patterns significantly impact performance. The problem specifies sorting the neighbor list by the first atom index, $i$. This groups all pairs involving atom $i$ together. While iterating, this improves temporal locality for accessing and updating $\\rho_i$. Although the effect is minor on small test cases, it is a crucial optimization in practice.\n3.  **Linear Complexity**: The algorithm's computational cost should scale linearly with the number of atoms, $N$, under the standard assumption of a bounded number of neighbors per atom.\n\n**Algorithmic Design and Complexity Analysis**\n\nThe proposed algorithm proceeds as follows:\n1.  Initialize an array, $\\rho$, of size $N$ to all zeros. This array will store the accumulated electron densities $\\rho_0, \\rho_1, \\dots, \\rho_{N-1}$.\n2.  For enhanced data locality, sort the provided list of neighbor pairs based on the first atom index in each pair.\n3.  Iterate through the sorted neighbor list exactly once. For each entry representing a pair of atoms $(i,j)$ with separation distance $r_{ij}$:\n    a. Evaluate the function $f(r_{ij})$ using the specified piecewise-linear interpolation rules. The function $f(r)$ is defined based on a set of tabulated radii $\\{r_k\\}$ and corresponding values $\\{f(r_k)\\}$:\n       - If $r \\le r_{\\min}$, $f(r) = f(r_{\\min})$.\n       - If $r \\ge r_{\\max}$, $f(r) = 0$.\n       - If $r_k \\le r < r_{k+1}$, $f(r)$ is determined by linear interpolation:\n         $$\n         f(r) = f(r_k) + \\frac{f(r_{k+1}) - f(r_k)}{r_{k+1} - r_k}(r - r_k)\n         $$\n       This interpolation can be robustly implemented using standard library functions, such as `scipy.interpolate.interp1d`, which handle boundary cases and interval searching efficiently.\n    b. Add the computed value $f(r_{ij})$ to the density accumulators for both atoms in the pair:\n       $$\n       \\rho_i \\leftarrow \\rho_i + f(r_{ij})\n       $$\n       $$\n       \\rho_j \\leftarrow \\rho_j + f(r_{ij})\n       $$\n4.  After the loop completes, the array $\\rho$ contains the final electron densities for all atoms.\n\n**Complexity Proof ($O(N)$)**:\nLet $N$ be the number of atoms. The problem states a bounded average neighbor count, which implies that the total number of pairs in the neighbor list, $M$, is proportional to $N$, i.e., $M \\in O(N)$.\n- **Step 1 (Initialization)**: Creating a zero array of size $N$ takes $O(N)$ time.\n- **Step 2 (Sorting)**: Sorting the $M$ pairs by the first index, which is an integer in $[0, N-1]$, can be done in $O(M+N)$ time using a linear-time algorithm like counting sort. Since $M \\in O(N)$, this step is $O(N)$.\n- **Step 3 (Iteration)**: The algorithm iterates $M$ times. Inside the loop:\n    - The evaluation of $f(r_{ij})$ involves finding the correct interval in the tabulated data. With $k_s$ sample points, this search takes $O(\\log k_s)$ time. Since $k_s$ is a small, fixed constant, this is effectively an $O(1)$ operation.\n    - The two additions to the $\\rho$ array are $O(1)$ operations.\n    - Thus, the work per pair is constant. The total time for the loop is $O(M)$.\n- The total runtime complexity is the sum of these steps: $O(N) + O(N) + O(M) = O(N) + O(N) + O(N) = O(N)$. The algorithm's runtime scales linearly with the number of atoms, as required.\n\nThis design is implemented below for the provided test cases. The interpolation is handled by `scipy.interpolate.interp1d` for conciseness and correctness, and the main loop carries out the symmetric density accumulation.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the EAM electron density problem for all test cases.\n    \"\"\"\n    # Tabulated function data for all test cases.\n    # Radii samples and corresponding function values.\n    r_samples = np.array([0.0, 1.0, 2.0, 3.0, 3.5])\n    f_samples = np.array([1.0, 0.8, 0.3, 0.1, 0.0])\n\n    # Per the problem description, f(r) for r >= r_max is 0.\n    # For r = r_min, f(r) = f(r_min).\n    # scipy.interpolate.interp1d handles these boundary conditions\n    # with the fill_value parameter.\n    # fill_value=(below, above)\n    f_interpolator = interp1d(\n        r_samples, \n        f_samples, \n        kind='linear', \n        bounds_error=False, \n        fill_value=(f_samples[0], 0.0)\n    )\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (Number of atoms N, neighbor list of (i, j, r_ij)).\n    test_cases = [\n        # Test case 1 (happy path)\n        (4, [\n            (0, 1, 1.0),\n            (0, 2, 2.0),\n            (1, 2, 1.0),\n            (2, 3, 2.0),\n        ]),\n        # Test case 2 (boundary: no neighbors)\n        (3, []),\n        # Test case 3 (interpolation coverage)\n        (5, [\n            (0, 1, 0.5),\n            (0, 2, 1.5),\n            (1, 3, 2.75),\n            (2, 4, 1.5),\n            (3, 4, 0.5),\n        ]),\n        # Test case 4 (exact endpoint at r_max)\n        (2, [(0, 1, 3.5)]),\n    ]\n\n    results = []\n    # Process each test case\n    for N, neighbor_list in test_cases:\n        # Step 1: Initialize density array to zeros.\n        rhos = np.zeros(N, dtype=float)\n\n        # Step 2: Sort pairs by the first index for cache locality (as required).\n        # For small test cases, this has negligible performance impact but is done\n        # for algorithmic correctness.\n        # The lambda function extracts the first element (atom i) for sorting.\n        neighbor_list.sort(key=lambda pair: pair[0])\n\n        # Step 3: Single pass over the unique neighbor list.\n        for i, j, rij in neighbor_list:\n            # Step 3a: Evaluate f(r_ij) using interpolation.\n            f_val = f_interpolator(rij)\n\n            # Step 3b: Symmetrically update densities for both atoms in the pair.\n            # This is the \"in-place accumulation\".\n            rhos[i] += f_val\n            rhos[j] += f_val\n        \n        # Store the computed densities as a standard Python list.\n        results.append(rhos.tolist())\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists: [[...], [...], ...]\n    # map(str, results) converts each inner list to its string representation.\n    # ','.join(...) combines them with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n\n```"
        }
    ]
}