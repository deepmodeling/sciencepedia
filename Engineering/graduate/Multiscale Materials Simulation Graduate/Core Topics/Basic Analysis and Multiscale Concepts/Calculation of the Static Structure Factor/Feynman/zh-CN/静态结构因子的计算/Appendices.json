{
    "hands_on_practices": [
        {
            "introduction": "计算静态结构因子的最直接方法是从分子模拟产生的原始粒子坐标出发。本练习将引导您从微观密度傅里叶变换的基本定义开始，通过运用遍历性假设，使用对模拟轨迹的时间平均来近似系综平均。这项实践旨在巩固从第一性原理到具体计算算法的联系，这是分子模拟中的一项基本技能 。",
            "id": "3795189",
            "problem": "您的任务是设计并实现一个程序，该程序使用时间平均法，从模拟轨迹中估算粒子系统的静态结构因子。估算必须与从微观数密度及其空间傅里叶变换导出的定义一致，并且必须避免使用这些定义之外的任何预设公式。\n\n此任务的基础是：\n- 微观数密度场定义为 $\\,\\rho(\\mathbf{r},t) = \\sum_{j=1}^{N}\\delta(\\mathbf{r}-\\mathbf{r}_j(t))\\,$, 其中 $\\,\\delta(\\cdot)\\,$ 是狄拉克δ函数, $\\,\\mathbf{r}_j(t)\\,$ 是粒子在时间 $\\,t\\,$ 的位置, $\\,N\\,$ 是粒子数。\n- 波数为 $\\,\\mathbf{k}\\,$ 的数密度的空间傅里叶变换是 $\\,\\rho_{\\mathbf{k}}(t) = \\int_{\\Omega} \\rho(\\mathbf{r},t)\\,e^{-\\,\\mathrm{i}\\,\\mathbf{k}\\cdot\\mathbf{r}}\\,\\mathrm{d}\\mathbf{r}\\,$, 其中 $\\,\\Omega\\,$ 是模拟域的体积, $\\,\\mathrm{i}\\,$ 是虚数单位。\n- 对于非零的 $\\,\\mathbf{k}\\,$, 静态结构因子在物理上定义为波数 $\\,\\mathbf{k}\\,$ 处密度涨落强度的度量。您的估算器必须通过结合上述定义与以下假设来导出：对平稳轨道的长时间平均近似于系综平均（遍历性），并使用一个能够消除与 $\\,N\\,$ 的平凡标度的归一化。\n- 模拟域是周期性的。允许的非零波矢与周期性盒子的大小兼容，即在一维空间中为 $\\,k = 2\\pi m/L\\,$（其中 $\\,m\\,$ 为整数，域长度为 $\\,L\\,$），在二维空间中为 $\\,\\mathbf{k} = (2\\pi m_x/L_x,\\,2\\pi m_y/L_y)\\,$（其中 $\\,m_x\\,$ 和 $\\,m_y\\,$ 为整数，域长度为 $\\,L_x\\,$ 和 $\\,L_y\\,$）。指数参数 $\\,\\mathbf{k}\\cdot\\mathbf{r}\\,$ 必须使用弧度制角度进行计算。\n\n您的程序必须：\n- 针对指定的非零波矢，使用对所提供帧的时间平均和与 $\\,N\\,$ 无关的归一化，实现一个一致的静态结构因子估算器。\n- 使用下面测试套件中给出的粒子轨迹，其中位置以纳米（$\\,\\mathrm{nm}\\,$）表示，波矢以反纳米（$\\,\\mathrm{nm}^{-1}\\,$）表示。\n- 在所有计算中排除 $\\,\\mathbf{k}=\\mathbf{0}\\,$。\n- 为静态结构因子的值生成无量纲的浮点数输出。不允许任何其他单位或文本输出。\n\n测试套件（所有位置单位为 $\\,\\mathrm{nm}\\,$，所有波矢分量单位为 $\\,\\mathrm{nm}^{-1}\\,$，指数中的角度单位为弧度）：\n\n- 情况 A（一维，周期性盒子）：\n  - 域长度 $\\,L = 1\\,\\mathrm{nm}\\,$。\n  - 帧数 $\\,T = 4\\,$；每帧粒子数 $\\,N = 12\\,$。\n  - 粒子位置帧 $\\,x_j(t)\\,$，对于 $\\,t = 1,2,3,4\\,$：\n    - 帧 $\\,1\\,$: $[\\,0.031,\\,0.203,\\,0.567,\\,0.891,\\,0.412,\\,0.754,\\,0.125,\\,0.642,\\,0.379,\\,0.959,\\,0.285,\\,0.498\\,]$.\n    - 帧 $\\,2\\,$: $[\\,0.072,\\,0.229,\\,0.553,\\,0.847,\\,0.438,\\,0.713,\\,0.166,\\,0.619,\\,0.351,\\,0.988,\\,0.306,\\,0.471\\,]$.\n    - 帧 $\\,3\\,$: $[\\,0.015,\\,0.190,\\,0.581,\\,0.873,\\,0.449,\\,0.721,\\,0.142,\\,0.607,\\,0.333,\\,0.971,\\,0.292,\\,0.482\\,]$.\n    - 帧 $\\,4\\,$: $[\\,0.048,\\,0.217,\\,0.564,\\,0.860,\\,0.425,\\,0.730,\\,0.132,\\,0.630,\\,0.345,\\,0.976,\\,0.299,\\,0.495\\,]$.\n  - 目标波矢 $\\,k \\in \\{\\,2\\pi,\\,4\\pi\\,\\}\\,$.\n\n- 情况 B（一维边界情况，周期性盒子）：\n  - 域长度 $\\,L = 1\\,\\mathrm{nm}\\,$。\n  - 帧数 $\\,T = 3\\,$；每帧粒子数 $\\,N = 1\\,$。\n  - 粒子位置帧：\n    - 帧 $\\,1\\,$: $[\\,0.420\\,]$.\n    - 帧 $\\,2\\,$: $[\\,0.420\\,]$.\n    - 帧 $\\,3\\,$: $[\\,0.420\\,]$.\n  - 目标波矢 $\\,k \\in \\{\\,2\\pi,\\,4\\pi\\,\\}\\,$.\n\n- 情况 C（二维正方形晶格，周期性盒子）：\n  - 域长度 $\\,L_x = 1\\,\\mathrm{nm}\\,$ 和 $\\,L_y = 1\\,\\mathrm{nm}\\,$。\n  - 帧数 $\\,T = 1\\,$；每帧粒子数 $\\,N = 9\\,$。\n  - 单帧粒子位置 $\\,\\{(x_j,y_j)\\}\\,$ 形成一个间距为 $\\,1/3\\,\\mathrm{nm}\\,$ 的 $\\,3\\times 3\\,$ 晶格：$\\,\\{\\,(\\,0,\\,0\\,),\\,(\\,0,\\,1/3\\,),\\,(\\,0,\\,2/3\\,),\\,(\\,1/3,\\,0\\,),\\,(\\,1/3,\\,1/3\\,),\\,(\\,1/3,\\,2/3\\,),\\,(\\,2/3,\\,0\\,),\\,(\\,2/3,\\,1/3\\,),\\,(\\,2/3,\\,2/3\\,)\\,\\}\\,$.\n  - 目标波矢 $\\,\\mathbf{k}\\,$：\n    - $\\,\\mathbf{k}_1 = (\\,2\\pi\\cdot 3,\\,0\\,)\\,$.\n    - $\\,\\mathbf{k}_2 = (\\,2\\pi\\cdot 2,\\,0\\,)\\,$.\n    - $\\,\\mathbf{k}_3 = (\\,2\\pi\\cdot 3,\\,2\\pi\\cdot 3\\,)\\,$.\n\n输出规格：\n- 按上面列出的顺序为每个指定的波矢计算静态结构因子：情况 $\\,\\mathrm{A}\\,$ 两个值，情况 $\\,\\mathrm{B}\\,$ 两个值，情况 $\\,\\mathrm{C}\\,$ 三个值。\n- 您的程序应生成单行输出，其中包含七个结果，形式为方括号内的逗号分隔列表，例如 $\\,[\\,r_1,\\,r_2,\\,r_3,\\,r_4,\\,r_5,\\,r_6,\\,r_7\\,]\\,$，每个 $\\,r_i\\,$ 是一个无量纲浮点数。不允许有多余的空格或文本。",
            "solution": "从粒子轨迹数据估算静态结构因子 $S(\\mathbf{k})$ 是分子模拟分析中的一项基础任务。该问题陈述在科学上是合理的、内部一致的且适定的，为进行严谨的求解提供了所有必要的定义和数据。我们将首先从所提供的第一性原理推导 $S(\\mathbf{k})$ 的计算估算器，然后概述其计算算法。\n\n**1. 静态结构因子估算器的推导**\n\n问题提供了以下基本定义：\n- 位于位置 $\\mathbf{r}$ 和时间 $t$ 的微观数密度场：\n$$ \\rho(\\mathbf{r},t) = \\sum_{j=1}^{N}\\delta(\\mathbf{r}-\\mathbf{r}_j(t)) $$\n其中 $N$ 是粒子数，$\\mathbf{r}_j(t)$ 是粒子 $j$ 在时间 $t$ 的位置，$\\delta(\\cdot)$ 是狄拉克δ函数。\n\n- 波矢为 $\\mathbf{k}$ 的数密度的空间傅里叶变换：\n$$ \\rho_{\\mathbf{k}}(t) = \\int_{\\Omega} \\rho(\\mathbf{r},t)\\,e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}}\\,\\mathrm{d}\\mathbf{r} $$\n其中 $\\Omega$ 是模拟域，$\\mathrm{i}$ 是虚数单位。\n\n为了推导 $\\rho_{\\mathbf{k}}(t)$ 的可计算表达式，我们将 $\\rho(\\mathbf{r},t)$ 的定义代入其傅里叶变换中：\n$$ \\rho_{\\mathbfk}(t) = \\int_{\\Omega} \\left( \\sum_{j=1}^{N}\\delta(\\mathbf{r}-\\mathbf{r}_j(t)) \\right) e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}}\\,\\mathrm{d}\\mathbf{r} $$\n利用积分的线性性质，我们可以交换积分和求和。然后，利用狄拉克δ函数的筛选性质，即 $\\int f(x)\\delta(x-a)dx = f(a)$，我们得到密度的微观傅里叶分量：\n$$ \\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j(t)} $$\n\n静态结构因子 $S(\\mathbf{k})$ 在物理上定义为密度涨落强度的度量。对于均匀系统和非零波矢（$\\mathbf{k} \\neq \\mathbf{0}$），密度涨落的系综平均值 $\\langle \\rho_{\\mathbf{k}} \\rangle$ 为零。因此，强度由方差或模平方的系综平均值 $\\langle |\\rho_{\\mathbf{k}}|^2 \\rangle$ 来捕获。$S(\\mathbf{k})$ 的标准定义包含一个归一化因子 $1/N$，以确保其为强度量（即，在热力学极限下，其对于典型流体的值不随系统大小 $N$ 而变化），其形式为：\n$$ S(\\mathbf{k}) = \\frac{1}{N} \\langle |\\rho_{\\mathbf{k}}|^2 \\rangle = \\frac{1}{N} \\left\\langle \\left| \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j} \\right|^2 \\right\\rangle $$\n问题要求使用对有限数量的模拟帧 $T$ 的时间平均来估算此系综平均 $\\langle \\cdot \\rangle$。这基于遍历性假说，这是统计力学中的一个常见假设，即足够长轨迹上的时间平均等价于系综平均。\n\n因此，我们表示为 $\\hat{S}(\\mathbf{k})$ 的静态结构因子估算器是瞬时归一化值的时间平均：\n$$ \\hat{S}(\\mathbf{k}) = \\frac{1}{T} \\sum_{t=1}^{T} \\left( \\frac{1}{N} |\\rho_{\\mathbf{k}}(t)|^2 \\right) $$\n将其与我们对 $\\rho_{\\mathbf{k}}(t)$ 的表达式结合，得出最终的计算公式：\n$$ \\hat{S}(\\mathbf{k}) = \\frac{1}{NT} \\sum_{t=1}^{T} \\left| \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j(t)} \\right|^2 $$\n该公式与问题的要求一致，它是从第一性原理推导出来的，并包含了指定的与 $N$ 无关的归一化。指数的参数 $\\mathbf{k}\\cdot\\mathbf{r}_j(t)$ 是一个无量纲的标量，按要求使用弧度制角度进行计算。\n\n**2. 算法实现**\n\n计算每个测试案例的 $\\hat{S}(\\mathbf{k})$ 的算法如下：\n1. 对于给定的测试案例，确定粒子数 $N$、帧数 $T$、粒子位置 $\\{\\mathbf{r}_j(t)\\}$（其中 $j=1,\\ldots,N$，$t=1,\\ldots,T$）以及目标波矢集 $\\{\\mathbf{k}\\}$。\n2. 对于每个目标波矢 $\\mathbf{k}$：\n    a. 初始化一个运行和 `total_squared_magnitude` 为 $0$。\n    b. 从 $t=1$ 到 $T$ 遍历每一帧：\n        i. 获取当前帧的粒子位置 $\\{\\mathbf{r}_j(t)\\}$。\n        ii. 计算复数和 $\\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j(t)}$。在数值上，这是通过对所有粒子 $j$ 求和复数 $\\cos(\\mathbf{k}\\cdot\\mathbf{r}_j(t)) - \\mathrm{i}\\sin(\\mathbf{k}\\cdot\\mathbf{r}_j(t))$ 来实现的。\n        iii. 计算此复数和的模平方 $|\\rho_{\\mathbf{k}}(t)|^2$。如果 $\\rho_{\\mathbf{k}}(t) = A + \\mathrm{i}B$，那么其模平方为 $A^2 + B^2$。\n        iv. 将此值加到 `total_squared_magnitude`。\n    c. 遍历所有帧后，通过归一化总和来计算最终估计值：$\\hat{S}(\\mathbf{k}) = \\text{total\\_squared\\_magnitude} / (N \\cdot T)$。\n3. 按规定顺序收集所有指定波矢的计算出的 $\\hat{S}(\\mathbf{k})$ 值。\n\n现在将这个有原则的算法应用于提供的测试案例。\n\n- **情况 A**：一个包含 $N=12$ 个粒子和 $T=4$ 帧的一维系统。位置是 $x_j(t)$，波矢是 $k \\in \\{2\\pi, 4\\pi\\}$。点积 $\\mathbf{k}\\cdot\\mathbf{r}$ 简化为标量积 $k x_j(t)$。将对两个 $k$ 值分别进行计算。\n\n- **情况 B**：一个包含 $N=1$ 个粒子和 $T=3$ 帧的一维系统。粒子静止在 $x_1 = 0.420$。对于任何 $k$ 和任何帧 $t$，$\\rho_k(t) = e^{-\\mathrm{i}kx_1}$。模平方为 $|e^{-\\mathrm{i}kx_1}|^2=1$。在 $T=3$ 帧上的总和是 $1+1+1=3$。估算器为 $\\hat{S}(k) = \\frac{1}{NT} \\sum_t |\\rho_k(t)|^2 = \\frac{1}{1 \\cdot 3} \\cdot 3 = 1.0$。对于单粒子系统，这个结果是预期的，并且对于两个目标波矢都将是 $1.0$。\n\n- **情况 C**：一个包含 $N=9$ 个粒子、位于完美晶格上且只有 $T=1$ 帧的二维系统。估算器简化为 $\\hat{S}(\\mathbf{k}) = \\frac{1}{N}|\\rho_{\\mathbf{k}}|^2$。\n    - 对于 $\\mathbf{k}_1 = (6\\pi, 0)$，这是实空间晶格的一个倒易晶格矢量。和 $\\sum_j e^{-\\mathrm{i}\\mathbf{k}_1\\cdot\\mathbf{r}_j}$ 的计算结果为 $N=9$。因此， $|\\rho_{\\mathbf{k}_1}|^2 = 9^2 = 81$，且 $\\hat{S}(\\mathbf{k}_1) = \\frac{81}{9} = 9.0$。\n    - 对于 $\\mathbf{k}_2 = (4\\pi, 0)$，它不是一个倒易晶格矢量，和 $\\sum_j e^{-\\mathrm{i}\\mathbf{k}_2\\cdot\\mathbf{r}_j}$ 的计算结果为 $0$。因此，$\\hat{S}(\\mathbf{k}_2) = 0.0$。\n    - 对于 $\\mathbf{k}_3 = (6\\pi, 6\\pi)$，这是另一个倒易晶格矢量，和的计算结果同样为 $N=9$。因此，$\\hat{S}(\\mathbf{k}_3) = \\frac{81}{9} = 9.0$。\n这些解析性检查证实了所推导公式的正确性及其物理诠释。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the static structure factor problem by implementing a time-averaging\n    estimator derived from first principles.\n    \"\"\"\n\n    def calculate_s_k(positions, wavevectors, N, T):\n        \"\"\"\n        Calculates the static structure factor S(k) for a set of wavevectors.\n\n        Args:\n            positions (np.ndarray): Particle positions. Shape (T, N) for 1D\n                                     or (T, N, D) for D-dimensional systems.\n            wavevectors (np.ndarray): Target wavevectors. Shape (num_k,) for 1D\n                                      or (num_k, D) for D-dimensional systems.\n            N (int): Number of particles.\n            T (int): Number of time frames.\n\n        Returns:\n            list: A list of S(k) values for each target wavevector.\n        \"\"\"\n        results_for_case = []\n        is_1d = (positions.ndim == 2)\n        \n        for k_vec in wavevectors:\n            total_squared_magnitude = 0.0\n            for t in range(T):\n                # positions_t is of shape (N,) or (N, D)\n                positions_t = positions[t]\n                \n                # Calculate the dot product k_vec . r_j for all particles j\n                if is_1d:\n                    # k_vec is a scalar, positions_t has shape (N,)\n                    # dot_products has shape (N,)\n                    dot_products = k_vec * positions_t\n                else:\n                    # k_vec has shape (D,), positions_t has shape (N, D)\n                    # dot_products has shape (N,)\n                    dot_products = np.dot(positions_t, k_vec)\n\n                # Calculate rho_k(t) = sum(exp(-i * k.r_j))\n                rho_k_t = np.sum(np.exp(-1j * dot_products))\n                \n                # Add the squared magnitude to the total\n                total_squared_magnitude += np.abs(rho_k_t)**2\n            \n            # Normalize to get the final S(k) estimate\n            s_k = total_squared_magnitude / (N * T)\n            results_for_case.append(s_k)\n            \n        return results_for_case\n\n    # Test suite definition\n    # Case A\n    case_A_N = 12\n    case_A_T = 4\n    case_A_positions = np.array([\n        [0.031, 0.203, 0.567, 0.891, 0.412, 0.754, 0.125, 0.642, 0.379, 0.959, 0.285, 0.498],\n        [0.072, 0.229, 0.553, 0.847, 0.438, 0.713, 0.166, 0.619, 0.351, 0.988, 0.306, 0.471],\n        [0.015, 0.190, 0.581, 0.873, 0.449, 0.721, 0.142, 0.607, 0.333, 0.971, 0.292, 0.482],\n        [0.048, 0.217, 0.564, 0.860, 0.425, 0.730, 0.132, 0.630, 0.345, 0.976, 0.299, 0.495]\n    ])\n    case_A_wavevectors = np.array([2 * np.pi, 4 * np.pi])\n\n    # Case B\n    case_B_N = 1\n    case_B_T = 3\n    case_B_positions = np.array([\n        [0.420],\n        [0.420],\n        [0.420]\n    ])\n    case_B_wavevectors = np.array([2 * np.pi, 4 * np.pi])\n\n    # Case C\n    case_C_N = 9\n    case_C_T = 1\n    case_C_positions_list = [\n        (0, 0), (0, 1/3), (0, 2/3),\n        (1/3, 0), (1/3, 1/3), (1/3, 2/3),\n        (2/3, 0), (2/3, 1/3), (2/3, 2/3)\n    ]\n    # Reshape to (T, N, D) = (1, 9, 2)\n    case_C_positions = np.array(case_C_positions_list).reshape((1, case_C_N, 2))\n    case_C_wavevectors = np.array([\n        [2 * np.pi * 3, 0],\n        [2 * np.pi * 2, 0],\n        [2 * np.pi * 3, 2 * np.pi * 3]\n    ])\n\n    # Calculate results for all cases\n    results = []\n    \n    # Case A\n    results.extend(calculate_s_k(case_A_positions, case_A_wavevectors, case_A_N, case_A_T))\n\n    # Case B\n    results.extend(calculate_s_k(case_B_positions, case_B_wavevectors, case_B_N, case_B_T))\n\n    # Case C\n    results.extend(calculate_s_k(case_C_positions, case_C_wavevectors, case_C_N, case_C_T))\n\n    # Format and print the final output\n    # Round to a reasonable number of decimal places for consistent output\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "对于像液体这样的各向同性体系，静态结构因子也可以通过实空间中的关联函数来确定。本练习探讨了静态结构因子 $S(k)$ 与径向分布函数 $g(r)$ 之间深刻的傅里叶变换关系，利用各向同性假设将三维傅里叶积分简化为一维形式。掌握这种联系对于将模拟结果与实验散射数据联系起来，以及更深入地理解液体在实空间和倒易空间中的结构至关重要 。",
            "id": "3795203",
            "problem": "您的任务是在多尺度材料模拟中，使用径向表示法推导并实现各向同性液体静态结构因子的计算。请从微观数密度和两点关联函数的基本定义出发。考虑一个宏观上均匀、各向同性的液体，其数密度为 $\\rho$，在体积 $V$ 中有 $N$ 个粒子，并设径向分布函数 (RDF) $g(r)$ 用于量化仅依赖于标量间距 $r$ 的对关联。您的推导必须仅使用给定的基本定义和对称性论证，将静态结构因子的一般三维公式简化为适用于各向同性系统的一维积分，而不能凭记忆套用目标公式。\n\n完成推导后，请实现一个程序，使用推导出的径向表示法，为指定的波数 $k$ 计算静态结构因子的值。该程序必须接受一个径向网格 $r$ 和在该网格上给定的函数 $g(r)$，并为给定的 $k$ 返回一个无量纲的静态结构因子值 $S(k)$ 的列表。程序必须在有限网格上执行数值稳定的积分，假定当 $r$ 超出最大网格值时 $g(r)=1$，并通过采用角平均所蕴含的连续性极限来处理 $k=0$ 的情况。所有物理量必须按照下述单位统一使用，输出必须是无量纲的实数（浮点数）。您必须将每个输出值四舍五入到六位小数。\n\n物理单位：\n- 径向距离 $r$ 的单位为埃（$\\mathrm{\\AA}$）。\n- 数密度 $\\rho$ 的单位为埃$^{-3}$（$\\mathrm{\\AA}^{-3}$）。\n- 波数 $k$ 的单位为埃$^{-1}$（$\\mathrm{\\AA}^{-1}$）。\n\n角度单位：角度积分隐含在各向同性平均中，不需要外部角度单位；在您的推导中引入任何角度时，都必须以弧度为单位。\n\n您的程序必须生成单行输出，其中包含一个以逗号分隔的列表，并用方括号括起，作为所有测试用例的结果。其中每个元素本身也是一个以逗号分隔的计算出的 $S(k)$ 值的列表，并用方括号括起，且不含空格。例如：$[ [s_{1,1}, s_{1,2}], [s_{2,1}, s_{2,2}] ]$ 必须打印为 \"[[s11,s12],[s21,s22]]\"，其中每个 $s_{i,j}$ 都四舍五入到六位小数。\n\n测试套件：\n实现并评估以下四个测试用例，以涵盖一般情况、边界行为、有限窗口效应以及低密度下的数值稳定性。在所有情况下，网格都是均匀间隔的。\n\n- 测试用例 $1$ (理想气体基准)：\n  - 数密度：$\\rho = 0.033\\,\\mathrm{\\AA}^{-3}$。\n  - 径向网格：$r \\in [0,12]\\,\\mathrm{\\AA}$，有 $N=1201$ 个点。\n  - 径向分布函数：对所有 $r$，$g(r)=1$。\n  - 波数：$k \\in \\{0,1,5\\}\\,\\mathrm{\\AA}^{-1}$。\n  - 预期定性行为：对所有 $k$，$S(k)$ 等于1。\n\n- 测试用例 $2$ (具有硬核和阻尼振荡的结构化液体)：\n  - 数密度：$\\rho = 0.033\\,\\mathrm{\\AA}^{-3}$。\n  - 径向网格：$r \\in [0,12]\\,\\mathrm{\\AA}$，有 $N=1201$ 个点。\n  - 参数：$\\sigma=1.0\\,\\mathrm{\\AA}$ (硬核直径)，$r_0=1.2\\,\\mathrm{\\AA}$，$\\sigma_g=0.15\\,\\mathrm{\\AA}$，$A=0.5$ (振幅)，$\\omega=10\\,\\mathrm{\\AA}^{-1}$。\n  - 径向分布函数：\n    - 对于 $r\\sigma$，$g(r)=0$。\n    - 对于 $r\\ge \\sigma$，$g(r)=1 + A \\exp\\!\\left(-\\dfrac{(r-r_0)^2}{2\\sigma_g^2}\\right)\\cos\\!\\left(\\omega(r-r_0)\\right)$，随后将小于0的值截断为0以强制非负性。\n  - 波数：$k \\in \\{0,2,6,10\\}\\,\\mathrm{\\AA}^{-1}$。\n  - 预期定性行为：$S(k)$ 在中等 $k$ 值处呈现一个主峰。\n\n- 测试用例 $3$ (有限窗口 $g(r)$ 且尾部假定为1)：\n  - 数密度：$\\rho = 0.033\\,\\mathrm{\\AA}^{-3}$。\n  - 径向网格：$r \\in [0,6]\\,\\mathrm{\\AA}$，有 $N=301$ 个点。\n  - 径向分布函数：$g(r)=1 + 0.2 \\exp\\!\\left(-\\dfrac{(r-2.5)^2}{2\\times 0.4^2}\\right) - 0.1 \\exp\\!\\left(-\\dfrac{(r-4.0)^2}{2\\times 0.3^2}\\right)$，随后将小于0的值截断为0；假定对于 $r6\\,\\mathrm{\\AA}$，$g(r)=1$。\n  - 波数：$k \\in \\{0,1,3,8\\}\\,\\mathrm{\\AA}^{-1}$。\n  - 预期定性行为：有限窗口效应对低 $k$ 值有影响；随着 $k$ 的增大，$S(k)$ 趋向于1。\n\n- 测试用例 $4$ (近零密度稳定性)：\n  - 数密度：$\\rho = 10^{-6}\\,\\mathrm{\\AA}^{-3}$。\n  - 径向网格：$r \\in [0,12]\\,\\mathrm{\\AA}$，有 $N=1201$ 个点。\n  - 径向分布函数：函数形式和参数与测试用例 $2$ 相同。\n  - 波数：$k \\in \\{0,5\\}\\,\\mathrm{\\AA}^{-1}$。\n  - 预期定性行为：对所有 $k$，$S(k)$ 都非常接近1。\n\n您的程序必须计算每个测试用例的 $S(k)$，并打印一行，将所有用例聚合为一个列表的列表，其中每个内部列表包含该用例的 $S(k)$ 值，按指定的 $k$ 集合排序并四舍五入到六位小数，格式完全如上所述。",
            "solution": "我们从基本定义开始。设 $N$ 个粒子位于体积 $V$ 中的位置 $\\{\\mathbf{R}_i\\}_{i=1}^N$ 处，数密度为 $\\rho = N/V$。定义微观数密度场为\n$$\n\\hat{\\rho}(\\mathbf{r}) = \\sum_{i=1}^N \\delta(\\mathbf{r}-\\mathbf{R}_i).\n$$\n定义微观密度的傅里叶分量为\n$$\n\\hat{\\rho}_{\\mathbf{k}} = \\int \\mathrm{d}^3 r \\, e^{-i\\mathbf{k}\\cdot \\mathbf{r}} \\hat{\\rho}(\\mathbf{r}) = \\sum_{i=1}^N e^{-i\\mathbf{k}\\cdot \\mathbf{R}_i}.\n$$\n静态结构因子 $S(\\mathbf{k})$ 定义为倒易空间中密度涨落的归一化方差：\n$$\nS(\\mathbf{k}) = \\frac{1}{N} \\left\\langle \\hat{\\rho}_{\\mathbf{k}} \\hat{\\rho}_{-\\mathbf{k}} \\right\\rangle,\n$$\n其中 $\\langle \\cdot \\rangle$ 表示系综平均。展开乘积可得\n$$\n\\hat{\\rho}_{\\mathbf{k}} \\hat{\\rho}_{-\\mathbf{k}} = \\sum_{i,j} e^{-i\\mathbf{k}\\cdot (\\mathbf{R}_i - \\mathbf{R}_j)} = N + \\sum_{i\\neq j} e^{-i\\mathbf{k}\\cdot (\\mathbf{R}_i - \\mathbf{R}_j)}.\n$$\n根据统计均匀性和各向同性，对关联仅依赖于标量间距 $r = \\lvert \\mathbf{r}\\rvert$。对关联函数为 $g(r)$，我们定义总关联函数 $h(r) = g(r) - 1$。使用将不同粒子对的求和与均匀系统中两粒子分布的积分联系起来的标准处理方法，可以得到\n$$\nS(\\mathbf{k}) = 1 + \\rho \\int \\mathrm{d}^3 r \\, h(r)\\, e^{-i \\mathbf{k}\\cdot \\mathbf{r}}.\n$$\n这是一个经过充分检验的表达式，通过三维傅里叶变换将 $S(\\mathbf{k})$ 与 $h(r)$ 联系起来。\n\n对于各向同性液体，$h(r)$ 仅依赖于 $r$，而 $S$ 仅依赖于大小 $k = \\lvert \\mathbf{k} \\rvert$。在 $\\mathbf{r}$ 中引入球坐标，其中 $r \\in [0,\\infty)$，极角 $\\theta \\in [0,\\pi]$，方位角 $\\phi \\in [0,2\\pi)$。不失一般性，将 $\\mathbf{k}$ 与 $z$ 轴对齐，使得 $\\mathbf{k}\\cdot \\mathbf{r} = k r \\cos\\theta$。角度积分变为\n$$\n\\int e^{-i \\mathbf{k}\\cdot \\mathbf{r}} \\mathrm{d}\\Omega = \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^\\pi \\mathrm{d}\\theta \\, \\sin\\theta \\, e^{-i k r \\cos\\theta} = 2\\pi \\int_{-1}^1 \\mathrm{d}(\\cos\\theta) \\, e^{-i k r \\cos\\theta} = 4\\pi \\frac{\\sin(kr)}{kr},\n$$\n其中 $\\mathrm{d}\\Omega$ 是立体角元，我们使用了恒等式 $\\int_{-1}^1 e^{-i a u} \\mathrm{d}u = 2 \\, \\frac{\\sin a}{a}$。因此，各向同性（径向）表示为\n$$\nS(k) = 1 + 4\\pi \\rho \\int_0^\\infty \\mathrm{d}r \\, r^2 \\, h(r) \\, \\frac{\\sin(kr)}{kr}.\n$$\n当 $k \\to 0$ 时，球贝塞尔因子的极限为\n$$\n\\lim_{k\\to 0} \\frac{\\sin(kr)}{kr} = 1,\n$$\n因此\n$$\nS(0) = 1 + 4\\pi \\rho \\int_0^\\infty \\mathrm{d}r \\, r^2 \\, h(r).\n$$\n\n数值算法设计：\n- 在均匀网格 $r_n$（$n=0,\\dots,N-1$，其中 $r_0=0$ 且 $r_{N-1}=r_{\\max}$）上离散化径向域。在实践中，测量或建模的 $g(r)$ 可用至 $r_{\\max}$。我们在网格上设 $h(r_n) = g(r_n) - 1$，并假设对于 $rr_{\\max}$，$h(r)=0$（等价于 $g(r)=1$），这对于足够大的 $r$ 在物理上是一致的。\n- 对于每个目标 $k$，计算球贝塞尔因子。对于 $k0$，\n$$\nj_0(kr_n) = \\frac{\\sin(k r_n)}{k r_n},\n$$\n对于 $k=0$，使用连续性极限 $j_0(0)=1$。在 $r=0$ 处，即使 $k0$，该因子也趋于 $1$，但由于被积函数包含 $r^2$，在 $r=0$ 处的贡献恒为 $0$，一个数值安全的实现可以设置 $j_0(0)=1$。\n- 构造被积函数\n$$\nI_n(k) = r_n^2 \\, h(r_n) \\, j_0(k r_n).\n$$\n- 使用梯形法则近似径向积分：\n$$\n\\int_0^{r_{\\max}} \\mathrm{d}r \\, r^2 h(r) j_0(kr) \\approx \\sum_{n=0}^{N-2} \\frac{I_n(k) + I_{n+1}(k)}{2} \\Delta r,\n$$\n其中 $\\Delta r = r_{n+1} - r_n$。\n- 计算\n$$\nS(k) \\approx 1 + 4\\pi \\rho \\sum_{n=0}^{N-2} \\frac{I_n(k) + I_{n+1}(k)}{2} \\Delta r.\n$$\n\n单位与量纲分析：$r$ 的单位为埃 ($\\mathrm{\\AA}$)，$k$ 的单位为埃$^{-1}$ ($\\mathrm{\\AA}^{-1}$)，$\\rho$ 的单位为埃$^{-3}$ ($\\mathrm{\\AA}^{-3}$)，这意味着 $r^2 h(r) j_0(kr)$ 的单位是 $\\mathrm{\\AA}^2$（因为 $h(r)$ 和 $j_0(kr)$ 是无量纲的），积分的贡献是 $\\mathrm{\\AA}^3$，乘以 $4\\pi \\rho$（单位为 $\\mathrm{\\AA}^{-3}$）后得到一个无量纲的 $S(k)$，符合要求。\n\n测试用例设计和预期行为：\n- 测试用例 1：对所有 $r$，$h(r)=0$ 意味着对所有 $k$，$S(k)=1$，用于测试基准和积分的中性。\n- 测试用例 2：硬核（对于 $r\\sigma$，$g(r)=0$）和阻尼振荡在中等 $k$ 值处产生一个真实的 $S(k)$ 第一峰，用于测试角平均和振荡被积函数。\n- 测试用例 3：一个有限窗口，当 $rr_{\\max}$ 时 $g(r)\\to 1$，用于探究对不完整径向支持的敏感性，并确保算法正确地强制当 $rr_{\\max}$ 时 $h(r)=0$。\n- 测试用例 4：非常小的 $\\rho$ 用于测试实现的数值稳定性以及 $S(k)\\to 1$ 的正确行为。\n\n实现细节：\n- 根据每个用例的指定，构造具有指定 $N$ 和端点的径向网格 $r$，并计算 $g(r)$，按要求将小于0的值截断。\n- 使用向量化操作以提高效率和数值稳定性，特别是在处理 $k=0$ 和 $r=0$ 时。\n- 将每个 $S(k)$ 四舍五入到六位小数以用于最终输出。\n- 输出格式为 \"[[s11,s12,...],[s21,s22,...],...]\" 的单行，不含空格，且每个用例中的 $S(k)$ 值按指定的 $k$ 值顺序排列。\n\n这种有原则的推导和算法确保了其正确性植根于静态结构因子和各向同性的定义，并且实现遵循了多尺度材料模拟的物理和数值约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spherical_bessel_j0(k, r):\n    \"\"\"\n    Compute j0(kr) = sin(kr)/(kr) with careful handling of k=0 and r=0.\n    Vectorized for numpy arrays r; k is a scalar.\n    \"\"\"\n    if k == 0.0:\n        # Limit as k->0 is 1 for all r\n        return np.ones_like(r)\n    kr = k * r\n    # Use where to avoid division by zero; at r=0, sin(0)/0 -> 1\n    j0 = np.where(kr != 0.0, np.sin(kr) / kr, 1.0)\n    return j0\n\ndef compute_Sk(r, g, rho, k_values):\n    \"\"\"\n    Compute S(k) = 1 + 4*pi*rho * integral_0^rmax r^2 (g(r)-1) j0(kr) dr\n    using the trapezoidal rule on the provided r grid.\n    \"\"\"\n    h = g - 1.0\n    results = []\n    # Precompute dr assuming uniform grid\n    # For robustness, use np.diff and mean in case of floating precision jitters.\n    dr = np.mean(np.diff(r))\n    # Compute for each k\n    for k in k_values:\n        j0 = spherical_bessel_j0(k, r)\n        integrand = (r ** 2) * h * j0\n        # Trapezoidal integration over r\n        integral = np.trapz(integrand, r)\n        S = 1.0 + 4.0 * np.pi * rho * integral\n        results.append(S)\n    return results\n\ndef case1():\n    # Test Case 1: Ideal gas baseline\n    rho = 0.033  # 1/Angstrom^3\n    r = np.linspace(0.0, 12.0, 1201)  # Angstrom\n    g = np.ones_like(r)\n    k_values = [0.0, 1.0, 5.0]  # 1/Angstrom\n    return compute_Sk(r, g, rho, k_values)\n\ndef case2():\n    # Test Case 2: Structured liquid with hard core and damped oscillations\n    rho = 0.033  # 1/Angstrom^3\n    r = np.linspace(0.0, 12.0, 1201)  # Angstrom\n    sigma = 1.0\n    r0 = 1.2\n    sigma_g = 0.15\n    A = 0.5\n    omega = 10.0\n    g = np.ones_like(r)\n    # Hard core region\n    g = np.where(r  sigma, 0.0, g)\n    # Add damped oscillatory bump for r >= sigma\n    bump = A * np.exp(-((r - r0) ** 2) / (2.0 * sigma_g ** 2)) * np.cos(omega * (r - r0))\n    g = np.where(r >= sigma, 1.0 + bump, g)\n    # Enforce nonnegativity\n    g = np.clip(g, 0.0, None)\n    k_values = [0.0, 2.0, 6.0, 10.0]  # 1/Angstrom\n    return compute_Sk(r, g, rho, k_values)\n\ndef case3():\n    # Test Case 3: Finite-window g(r) and tail assumed unity\n    rho = 0.033  # 1/Angstrom^3\n    r = np.linspace(0.0, 6.0, 301)  # Angstrom\n    g = 1.0 + 0.2 * np.exp(-((r - 2.5) ** 2) / (2.0 * (0.4 ** 2))) - 0.1 * np.exp(-((r - 4.0) ** 2) / (2.0 * (0.3 ** 2)))\n    g = np.clip(g, 0.0, None)\n    k_values = [0.0, 1.0, 3.0, 8.0]  # 1/Angstrom\n    return compute_Sk(r, g, rho, k_values)\n\ndef case4():\n    # Test Case 4: Near-zero density stability\n    rho = 1e-6  # 1/Angstrom^3\n    r = np.linspace(0.0, 12.0, 1201)  # Angstrom\n    sigma = 1.0\n    r0 = 1.2\n    sigma_g = 0.15\n    A = 0.5\n    omega = 10.0\n    g = np.ones_like(r)\n    g = np.where(r  sigma, 0.0, g)\n    bump = A * np.exp(-((r - r0) ** 2) / (2.0 * sigma_g ** 2)) * np.cos(omega * (r - r0))\n    g = np.where(r >= sigma, 1.0 + bump, g)\n    g = np.clip(g, 0.0, None)\n    k_values = [0.0, 5.0]  # 1/Angstrom\n    return compute_Sk(r, g, rho, k_values)\n\ndef format_nested_results(results):\n    \"\"\"\n    Format list of lists of floats into the exact required string:\n    [[x11,x12,...],[x21,x22,...],...]\n    with each number rounded to six decimal places and no spaces.\n    \"\"\"\n    inner_strs = []\n    for sub in results:\n        nums = \",\".join(f\"{v:.6f}\" for v in sub)\n        inner_strs.append(f\"[{nums}]\")\n    return f\"[{','.join(inner_strs)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases_funcs = [case1, case2, case3, case4]\n    results = []\n    for func in test_cases_funcs:\n        case_result = func()\n        results.append(case_result)\n    # Final print statement in the exact required format.\n    print(format_nested_results(results))\n\nsolve()\n```"
        },
        {
            "introduction": "任何从有限模拟中计算出的物理量都不可避免地带有统计误差。这项实践从计算单一的“点估计”值，转向了不确定性量化的核心任务。通过分析一组独立的模拟快照，您不仅将计算 $S(k)$ 的平均值，还将计算其方差和严格的置信区间。本练习旨在介绍严谨的统计分析方法，这是可靠地报告模拟结果并确保结论具有统计显著性的关键一步 。",
            "id": "3795201",
            "problem": "考虑一个 $d$ 维空间中的周期性模拟盒子，其边长为 $\\mathbf{L} = (L_1,\\dots,L_d)$，包含 $N$ 个粒子，其位置为 $\\{\\mathbf{r}_j\\}_{j=1}^N$，其中 $\\mathbf{r}_j \\in [0,L_1) \\times \\cdots \\times [0,L_d)$。微观数密度定义为 $\\rho(\\mathbf{r}) = \\sum_{j=1}^N \\delta(\\mathbf{r} - \\mathbf{r}_j)$，其在波矢 $\\mathbf{k}$ 处的傅里叶分量定义为 $\\rho_{\\mathbf{k}} = \\int_{V} \\rho(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r}$，其中 $V = L_1 \\cdots L_d$ 是体积，角度以弧度为单位。静态结构因子 $S(\\mathbf{k})$ 量化了波矢 $\\mathbf{k}$ 处的平衡密度涨落，并由这些定义构建而成。\n\n给定 $M$ 个统计独立的粒子位置快照，每个快照包含相同周期性盒子中的 $N$ 个粒子。从上述基本定义出发，为单个快照构建一个 $S(\\mathbf{k})$ 的一致估计量，然后将其扩展到 $M$ 个快照。实现一个程序，为每个测试用例计算：\n- $M$ 个快照中瞬时 $S(\\mathbf{k})$ 值的样本均值。\n- $M$ 个快照中瞬时 $S(\\mathbf{k})$ 值的无偏样本方差。\n- $M$ 个快照中 $S(\\mathbf{k})$ 均值的双侧置信区间，置信水平为 $0.95$，假设快照独立，并使用适用于 $M-1$ 个自由度的 Student’s $t$ 分位数。\n\n所有量——$S(\\mathbf{k})$、其样本均值、方差和置信区间——都必须以无量纲数的形式报告。粒子位置必须以纳米 (nm) 为单位处理，波矢以反纳米 (nm$^{-1}$) 为单位，角度以弧度为单位。如果 $M$ 个快照的无偏样本方差为零，或者 $M=1$，则将置信区间报告为退化区间 $[\\mu,\\mu]$，其中 $\\mu$ 是样本均值。\n\n您的程序必须实现以下测试套件。在以下所有情况中，除非另有说明，快照都是独立的，并且必须使用指定的整数种子确定性地生成伪随机数。\n\n- 测试用例 1（一维均匀流体，“理想路径”）：\n  - $d = 1$，$N = 128$，$M = 60$，$L_1 = 12.8$ nm，种子 $= 1001$。\n  - 每个快照中的粒子位置都是独立的，并在 $[0,L_1)$ 上均匀分布。\n  - 波矢 $\\mathbf{k} = (2\\pi \\cdot 3 / L_1)$ nm$^{-1}$。\n\n- 测试用例 2（一维均匀流体，$\\mathbf{k}=\\mathbf{0}$ 处的边界情况）：\n  - $d = 1$，$N = 128$，$M = 60$，$L_1 = 12.8$ nm，种子 $= 1002$。\n  - 每个快照中的粒子位置都是独立的，并在 $[0,L_1)$ 上均匀分布。\n  - 波矢 $\\mathbf{k} = (0)$ nm$^{-1}$。\n\n- 测试用例 3（一维完美晶格，布拉格峰）：\n  - $d = 1$，$N = 64$，$M = 20$，$L_1 = 6.4$ nm（因此晶格间距 $a = L_1/N = 0.1$ nm），种子被忽略，因为快照是同一晶格的相同副本。\n  - 对于每个快照，粒子位置精确位于 $\\{j a\\}_{j=0}^{N-1}$。\n  - 波矢 $\\mathbf{k} = (2\\pi / a)$ nm$^{-1}$。\n\n- 测试用例 4（一维完美晶格，消光条件）：\n  - $d = 1$，$N = 64$，$M = 20$，$L_1 = 6.4$ nm（晶格间距 $a = 0.1$ nm），与测试用例 3 中的晶格位置相同，种子被忽略。\n  - 波矢 $\\mathbf{k} = (\\pi / a)$ nm$^{-1}$。\n\n- 测试用例 5（二维均匀流体，各向异性盒子）：\n  - $d = 2$，$N = 256$，$M = 50$，$(L_1,L_2) = (10.0, 5.0)$ nm，种子 $= 1405$。\n  - 每个快照中的粒子位置都是独立的，并在 $[0,L_1) \\times [0,L_2)$ 上均匀分布。\n  - 波矢 $\\mathbf{k} = (2\\pi / L_1, 0)$ nm$^{-1}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按测试用例顺序（$1$ 到 $5$）排列的结果。每个元素都必须是对应测试用例的四元列表 $[\\text{mean}, \\text{variance}, \\text{lower}, \\text{upper}]$。例如，输出必须看起来像 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$，位于单行上，其中所有数字都是无量纲的，角度以弧度为单位。",
            "solution": "该问题要求根据模拟的粒子构型计算静态结构因子 $S(\\mathbf{k})$，以及其样本均值、方差和置信区间。此过程始于根据所提供的基本定义进行形式推导。\n\n### 1. $S(\\mathbf{k})$ 估计量的推导\n\n在体积 $V$ 中，$N$ 个粒子位置为 $\\{\\mathbf{r}_j\\}$ 的微观数密度由下式给出：\n$$ \\rho(\\mathbf{r}) = \\sum_{j=1}^N \\delta(\\mathbf{r} - \\mathbf{r}_j) $$\n该密度在特定波矢 $\\mathbf{k}$ 处的傅里叶分量定义为积分变换：\n$$ \\rho_{\\mathbf{k}} = \\int_{V} \\rho(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r} $$\n将 $\\rho(\\mathbf{r})$ 的定义代入积分中：\n$$ \\rho_{\\mathbf{k}} = \\int_{V} \\left( \\sum_{j=1}^N \\delta(\\mathbf{r} - \\mathbf{r}_j) \\right) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r} $$\n根据积分的线性性质，我们可以互换求和与积分的顺序：\n$$ \\rho_{\\mathbf{k}} = \\sum_{j=1}^N \\int_{V} \\delta(\\mathbf{r} - \\mathbf{r}_j) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r} $$\n利用 Dirac delta 函数的筛选性质，即 $\\int f(x) \\delta(x-a) dx = f(a)$，积分的计算结果为在粒子位置 $\\mathbf{r}_j$ 处的指数项。假设所有粒子都在积分体积 $V$ 内，这得到：\n$$ \\rho_{\\mathbf{k}} = \\sum_{j=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} $$\n此表达式表示单个瞬时粒子构型的密度傅里叶分量。\n\n在统计力学中，静态结构因子 $S(\\mathbf{k})$ 的基本定义是密度涨落的归一化相关性：\n$$ S(\\mathbf{k}) = \\frac{1}{N} \\langle \\rho_{\\mathbf{k}} \\rho_{-\\mathbf{k}} \\rangle $$\n其中 $\\langle \\cdot \\rangle$ 表示对热力学平衡中所有可能粒子构型的系综平均。$\\rho_{-\\mathbf{k}}$ 是在波矢 $-\\mathbf{k}$ 处的傅里叶分量：\n$$ \\rho_{-\\mathbf{k}} = \\sum_{l=1}^N e^{-i (-\\mathbf{k}) \\cdot \\mathbf{r}_l} = \\sum_{l=1}^N e^{i \\mathbf{k} \\cdot \\mathbf{r}_l} = \\left( \\sum_{l=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_l} \\right)^* = \\rho_{\\mathbf{k}}^* $$\n其中 $^*$ 表示复共轭。因此，乘积 $\\rho_{\\mathbf{k}} \\rho_{-\\mathbf{k}}$ 等价于模的平方 $|\\rho_{\\mathbf{k}}|^2$。$S(\\mathbf{k})$ 的定义变为：\n$$ S(\\mathbf{k}) = \\frac{1}{N} \\langle |\\rho_{\\mathbf{k}}|^2 \\rangle = \\frac{1}{N} \\left\\langle \\left| \\sum_{j=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2 \\right\\rangle $$\n对于单个粒子位置快照，我们无法计算系综平均。从单个快照中获得 $S(\\mathbf{k})$ 的最直接估计量是“瞬时”值，通过去掉系综平均得到：\n$$ S_{\\text{inst}}(\\mathbf{k}) = \\frac{1}{N} \\left| \\sum_{j=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2 $$\n这就是题目陈述所要求的一致估计量。\n\n### 2. 多个快照的统计分析\n\n给定一组 $M$ 个统计独立的快照，我们可以为每个快照 $m \\in \\{1, \\dots, M\\}$ 计算一个瞬时结构因子 $S_m(\\mathbf{k})$。集合 $\\{S_m(\\mathbf{k})\\}_{m=1}^M$ 构成了 $S_{\\text{inst}}(\\mathbf{k})$ 分布的一个样本。从这个样本中，我们可以估计该分布的矩。\n\n样本均值 $\\mu_S$ 是对真实系综平均 $\\langle S(\\mathbf{k}) \\rangle$ 的估计：\n$$ \\mu_S = \\frac{1}{M} \\sum_{m=1}^M S_m(\\mathbf{k}) $$\n无偏样本方差 $\\sigma_S^2$ 是对 $S_m(\\mathbf{k})$ 值方差的估计，由下式给出：\n$$ \\sigma_S^2 = \\frac{1}{M-1} \\sum_{m=1}^M (S_m(\\mathbf{k}) - \\mu_S)^2 $$\n请注意分母中使用 $M-1$，这提供了无偏估计。对于 $M=1$ 的情况，无偏方差通常定义为 $0$。\n\n基于 Central Limit Theorem，构建 $S(\\mathbf{k})$ 真实均值的双侧置信区间 (CI)。对于大小为 $M$ 的样本，在置信水平为 $1-\\alpha$（此处为 $0.95$，因此 $\\alpha=0.05$）下的置信区间为：\n$$ \\text{CI} = \\left[ \\mu_S - t_{1-\\alpha/2, \\nu} \\frac{\\sigma_S}{\\sqrt{M}}, \\, \\mu_S + t_{1-\\alpha/2, \\nu} \\frac{\\sigma_S}{\\sqrt{M}} \\right] $$\n其中 $\\nu = M-1$ 是自由度，$\\sigma_S = \\sqrt{\\sigma_S^2}$ 是样本标准差，$t_{1-\\alpha/2, \\nu}$ 是 Student's t 分布的上尾临界值。对于 $\\alpha=0.05$，这是 $0.975$ 分位数。如果 $M \\le 1$ 或者样本方差 $\\sigma_S^2$ 为零，则均值标准误为零，置信区间退化为一个点 $[\\mu_S, \\mu_S]$。\n\n### 3. 实现策略\n\n程序将遍历每个测试用例，执行以下步骤：\n1.  初始化用例参数：维度 ($d$)、粒子数 ($N$)、快照数 ($M$)、盒子边长 ($\\mathbf{L}$)、波矢 ($\\mathbf{k}$) 以及随机数生成器的种子。\n2.  生成粒子位置。对于均匀流体情况，使用带种子的 `numpy.random.Generator` 从均匀分布中抽取位置。对于完美晶格情况，所有快照的位置是确定且相同的。\n3.  对于 $M$ 个快照中的每一个：\n    a. 计算所有 $N$ 个粒子的点积数组 $\\mathbf{k} \\cdot \\mathbf{r}_j$。\n    b. 计算复数和 $\\rho_{\\mathbf{k}} = \\sum_j \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}_j)$。\n    c. 计算瞬时 $S_m(\\mathbf{k}) = \\frac{1}{N} |\\rho_{\\mathbf{k}}|^2$。\n4.  存储所有 $M$ 个 $S_m(\\mathbf{k})$ 的值。\n5.  从存储的值中计算样本均值 $\\mu_S$ 和无偏样本方差 $\\sigma_S^2$。对于 $M \\le 1$ 的情况需要特别处理，此时方差设为 $0$。\n6.  使用 `scipy.stats.t.ppf` 函数找到合适的 t 分位数，以计算 $95\\%$ 置信区间。按规定处理退化区间情况。\n7.  为每个测试用例格式化并收集四个结果数字（$\\mu_S, \\sigma_S^2$，CI 下界，CI 上界）。\n8.  最后，以指定的单行列表之列表格式打印汇总结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Computes the static structure factor S(k) and its statistics for several test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"d\": 1, \"N\": 128, \"M\": 60, \"L\": np.array([12.8]),\n            \"k\": np.array([2 * np.pi * 3 / 12.8]), \"seed\": 1001\n        },\n        {\n            \"d\": 1, \"N\": 128, \"M\": 60, \"L\": np.array([12.8]),\n            \"k\": np.array([0.0]), \"seed\": 1002\n        },\n        {\n            \"d\": 1, \"N\": 64, \"M\": 20, \"L\": np.array([6.4]),\n            \"k\": np.array([2 * np.pi / (6.4 / 64)]), \"seed\": None  # Lattice\n        },\n        {\n            \"d\": 1, \"N\": 64, \"M\": 20, \"L\": np.array([6.4]),\n            \"k\": np.array([np.pi / (6.4 / 64)]), \"seed\": None  # Lattice\n        },\n        {\n            \"d\": 2, \"N\": 256, \"M\": 50, \"L\": np.array([10.0, 5.0]),\n            \"k\": np.array([2 * np.pi / 10.0, 0.0]), \"seed\": 1405\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d = case[\"d\"]\n        N = case[\"N\"]\n        M = case[\"M\"]\n        L = case[\"L\"]\n        k = case[\"k\"]\n        seed = case[\"seed\"]\n\n        s_k_values = np.zeros(M)\n        \n        # Pre-calculate positions for deterministic cases\n        positions_snapshot = None\n        if seed is None:\n            if d == 1:\n                a = L[0] / N\n                positions_snapshot = np.arange(N).reshape(N, 1) * a\n            # Extend for other deterministic cases if needed\n        else:\n            rng = np.random.default_rng(seed)\n\n        for m in range(M):\n            # Generate or retrieve particle positions for the current snapshot\n            if positions_snapshot is not None:\n                positions = positions_snapshot\n            else:\n                # Generate random positions: shape (N, d)\n                # Each coordinate r_i is in [0, L_i)\n                positions = rng.random(size=(N, d)) * L\n\n            # Calculate k . r for all particles. Shape: (N,)\n            k_dot_r = positions @ k\n            \n            # Calculate rho_k = sum_j exp(-i * k.r_j)\n            rho_k = np.sum(np.exp(-1j * k_dot_r))\n            \n            # Calculate instantaneous S(k) = (1/N) * |rho_k|^2\n            s_k_inst = (1.0 / N) * np.abs(rho_k)**2\n            s_k_values[m] = s_k_inst\n\n        # Calculate sample mean\n        mean_s_k = np.mean(s_k_values)\n\n        # Calculate unbiased sample variance\n        if M > 1:\n            var_s_k = np.var(s_k_values, ddof=1)\n        else:\n            var_s_k = 0.0\n\n        # Calculate 95% confidence interval for the mean\n        if M = 1 or var_s_k == 0.0:\n            lower_ci = mean_s_k\n            upper_ci = mean_s_k\n        else:\n            # Degrees of freedom for t-distribution\n            df = M - 1\n            # Standard error of the mean\n            sem = np.sqrt(var_s_k) / np.sqrt(M)\n            # 97.5th percentile for a two-sided 95% CI\n            t_quantile = t.ppf(0.975, df)\n            # Margin of error\n            margin_of_error = t_quantile * sem\n            \n            lower_ci = mean_s_k - margin_of_error\n            upper_ci = mean_s_k + margin_of_error\n            \n        results.append([mean_s_k, var_s_k, lower_ci, upper_ci])\n\n    # Format output as a single-line string representation of a list of lists\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    results_str = ','.join([f\"[{','.join(map(str, r))}]\" for r in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n\n```"
        }
    ]
}