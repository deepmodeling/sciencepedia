{
    "hands_on_practices": [
        {
            "introduction": "The rate of a point defect hop is determined by the energy barrier it must overcome. This practice introduces the Nudged Elastic Band (NEB) method, a cornerstone of computational materials science for finding the minimum energy path (MEP) and the associated saddle point energy between two stable defect configurations . By implementing a simplified NEB algorithm, you will gain hands-on experience with the mechanics of locating transition states on a potential energy surface, a critical skill for predicting kinetic properties of materials.",
            "id": "3833685",
            "problem": "A single migrating atom in a crystalline host can be modeled as a point moving in two spatial dimensions under the influence of fixed lattice sites and an obstacle. The total potential energy is defined as the sum of two attractive Morse potentials centered at two lattice sites and one short-range repulsive exponential potential centered at an obstacle. Let the atom position be $\\mathbf{R} = (x,y)$ in a plane, the left lattice site be at $\\mathbf{R}_{\\mathrm{L}} = (-a,0)$, the right lattice site be at $\\mathbf{R}_{\\mathrm{R}} = (a,0)$, and the central obstacle be at $\\mathbf{R}_{\\mathrm{O}} = (0,0)$. The total potential energy is\n$$\nE(\\mathbf{R}) = V_{\\mathrm{Morse}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}|) + V_{\\mathrm{Morse}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}|) + V_{\\mathrm{rep}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}|),\n$$\nwhere the Morse attraction is\n$$\nV_{\\mathrm{Morse}}(r) = D_e \\left(\\left(1 - e^{-\\alpha (r - r_0)}\\right)^2 - 1\\right),\n$$\nand the repulsive obstacle is\n$$\nV_{\\mathrm{rep}}(r) = A e^{-\\beta r}.\n$$\nAll distances are to be treated in angstroms, denoted $\\mathrm{\\AA}$, and all energies in electronvolts, denoted $\\mathrm{eV}$.\n\nYou must implement the Nudged Elastic Band (NEB) method to compute the migration barrier for the atom moving from an initial minimum near the left site to a final minimum near the right site. Use the following physically motivated setup:\n- The initial atom position is $\\mathbf{R}_{\\mathrm{start}} = (-a + r_0, 0)$ and the final atom position is $\\mathbf{R}_{\\mathrm{end}} = (a - r_0, 0)$, approximating local minima at a distance $r_0$ from each lattice site along the line connecting them.\n- Construct an initial path of $N$ images by linear interpolation in Cartesian coordinates between $\\mathbf{R}_{\\mathrm{start}}$ and $\\mathbf{R}_{\\mathrm{end}}$. The endpoints are fixed throughout optimization.\n- The NEB force on an interior image $i$ combines the true force perpendicular to the local path tangent and a spring force along the tangent. Let $\\mathbf{F}_i^{\\mathrm{true}} = -\\nabla E(\\mathbf{R}_i)$ be the true force at image $i$, and let the tangent $\\boldsymbol{\\tau}_i$ be defined by an energy-weighted scheme using adjacent images $i-1$ and $i+1$:\n  - Define $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$, $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$, $E_{i-1} = E(\\mathbf{R}_{i-1})$, $E_i = E(\\mathbf{R}_i)$, $E_{i+1} = E(\\mathbf{R}_{i+1})$.\n  - If $E_{i+1} > E_i > E_{i-1}$, set $\\boldsymbol{\\tau}_i$ to the unit vector along $\\Delta \\mathbf{R}_i^+$.\n  - If $E_{i+1}  E_i  E_{i-1}$, set $\\boldsymbol{\\tau}_i$ to the unit vector along $\\Delta \\mathbf{R}_i^-$.\n  - Otherwise, set $\\boldsymbol{\\tau}_i \\propto \\max(E_{i+1} - E_i, 0)\\,\\Delta \\mathbf{R}_i^+ + \\max(E_{i-1} - E_i, 0)\\,\\Delta \\mathbf{R}_i^-$ and normalize to unit length. If the resulting vector is zero, use $\\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^-$ normalized.\n- The NEB force on non-climbing images is\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\mathrm{spring}},\n$$\nwhere the perpendicular component is $\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\mathrm{true}} - (\\mathbf{F}_i^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_i)\\,\\boldsymbol{\\tau}_i$, and the spring force is $\\mathbf{F}_i^{\\mathrm{spring}} = k_s \\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right) \\boldsymbol{\\tau}_i$, with $k_s$ a constant spring constant in units of $\\mathrm{eV}/\\mathrm{\\AA}^2$.\n- Apply the climbing image modification by identifying at each iteration the interior image $m$ with the largest energy and replacing its force with\n$$\n\\mathbf{F}_m^{\\mathrm{CI}} = \\mathbf{F}_m^{\\mathrm{true}} - 2\\,(\\mathbf{F}_m^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_m)\\,\\boldsymbol{\\tau}_m,\n$$\nremoving any spring contribution for that image.\n\nUse a simple explicit update rule for interior images:\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\eta\\,\\mathbf{F}_i,\n$$\nwhere $\\eta$ is a user-specified step size with units $\\mathrm{\\AA}^2/\\mathrm{eV}$, and $\\mathbf{F}_i$ is $\\mathbf{F}_i^{\\mathrm{NEB}}$ for non-climbing images or $\\mathbf{F}_i^{\\mathrm{CI}}$ for the climbing image. The endpoints are fixed and not updated.\n\nConverge the NEB optimization when the maximum magnitude of the NEB force among interior images satisfies $\\max_i \\|\\mathbf{F}_i\\|  \\varepsilon$, where $\\varepsilon$ is a tolerance in units of $\\mathrm{eV}/\\mathrm{\\AA}$, or when a maximum number of iterations is reached. After convergence, compute the migration barrier as\n$$\nE_{\\mathrm{barrier}} = E(\\mathbf{R}_m) - E(\\mathbf{R}_{\\mathrm{start}}),\n$$\nexpressed in $\\mathrm{eV}$, where $\\mathbf{R}_m$ is the converged climbing image coordinate.\n\nYour program must implement the above and produce results for the following test suite, each case specified as a tuple of parameters $(a, D_e, \\alpha, r_0, A, \\beta, N, k_s, \\text{max\\_iter}, \\eta, \\varepsilon)$ with units indicated:\n- Case $1$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 2000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n- Case $2$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 3, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 3000, 0.02\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n- Case $3$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.02\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 3000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n- Case $4$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 1.0\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 2000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[x_1, x_2, x_3, x_4]$, where each $x_i$ is the migration barrier $E_{\\mathrm{barrier}}$ in $\\mathrm{eV}$, rounded to six decimal places.",
            "solution": "The problem is subjected to validation and is confirmed to be **valid**. It is scientifically grounded in established principles of computational materials science, mathematically well-posed, objective, and provides a complete and consistent set of parameters and instructions for implementing the Nudged Elastic Band (NEB) method. The potential energy model and the NEB algorithm are standard tools in the field. The provided parameters and units are physically consistent and computationally feasible.\n\nThe solution proceeds by implementing the specified algorithm. The core components of the implementation are the potential energy surface, the NEB optimization loop, and the final barrier calculation.\n\n### 1. Potential Energy Surface and Force Calculation\n\nThe total potential energy $E(\\mathbf{R})$ for an atom at position $\\mathbf{R}=(x,y)$ is the sum of three potentials: two attractive Morse potentials from lattice sites at $\\mathbf{R}_{\\mathrm{L}}=(-a,0)$ and $\\mathbf{R}_{\\mathrm{R}}=(a,0)$, and one repulsive potential from an obstacle at $\\mathbf{R}_{\\mathrm{O}}=(0,0)$.\n\n$$\nE(\\mathbf{R}) = V_{\\mathrm{Morse}}(r_L) + V_{\\mathrm{Morse}}(r_R) + V_{\\mathrm{rep}}(r_O)\n$$\n\nwhere $r_L = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}|$, $r_R = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}|$, and $r_O = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}|$. The Morse potential is $V_{\\mathrm{Morse}}(r) = D_e \\left(\\left(1 - e^{-\\alpha (r - r_0)}\\right)^2 - 1\\right)$ and the repulsive potential is $V_{\\mathrm{rep}}(r) = A e^{-\\beta r}$.\n\nThe \"true\" force on the atom is the negative gradient of the potential energy, $\\mathbf{F}^{\\mathrm{true}} = -\\nabla E(\\mathbf{R})$. Using the chain rule, $\\nabla V(r(\\mathbf{R})) = \\frac{dV}{dr} \\nabla r$, the gradient of the total potential is:\n\n$$\n\\nabla E(\\mathbf{R}) = \\frac{d V_{\\mathrm{Morse}}}{dr}(r_L) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}}{r_L} + \\frac{d V_{\\mathrm{Morse}}}{dr}(r_R) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}}{r_R} + \\frac{d V_{\\mathrm{rep}}}{dr}(r_O) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}}{r_O}\n$$\n\nThe required derivatives of the potential functions are:\n$$\n\\frac{d V_{\\mathrm{Morse}}}{dr} = 2\\alpha D_e \\left(e^{-\\alpha (r - r_0)} - e^{-2\\alpha (r - r_0)}\\right)\n$$\n$$\n\\frac{d V_{\\mathrm{rep}}}{dr} = -\\beta A e^{-\\beta r}\n$$\n\nThese expressions allow for the analytical computation of the energy and force at any point $\\mathbf{R}$.\n\n### 2. Nudged Elastic Band (NEB) with Climbing Image\n\nThe NEB method finds the minimum energy path (MEP) between two local minima, $\\mathbf{R}_{\\mathrm{start}}$ and $\\mathbf{R}_{\\mathrm{end}}$. The path is discretized into a series of $N$ images, $\\{\\mathbf{R}_0, \\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-1}\\}$, where $\\mathbf{R}_0 = \\mathbf{R}_{\\mathrm{start}}$ and $\\mathbf{R}_{N-1} = \\mathbf{R}_{\\mathrm{end}}$.\n\n#### Path Initialization\nThe initial path is created by linear interpolation between the start and end points:\n$\\mathbf{R}_{\\mathrm{start}} = (-a + r_0, 0)$ and $\\mathbf{R}_{\\mathrm{end}} = (a - r_0, 0)$.\nFor $i = 0, \\ldots, N-1$, the initial position of image $i$ is:\n$$\n\\mathbf{R}_i = \\mathbf{R}_{\\mathrm{start}} + \\frac{i}{N-1} (\\mathbf{R}_{\\mathrm{end}} - \\mathbf{R}_{\\mathrm{start}})\n$$\n\n#### Iterative Optimization\nThe interior images ($\\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-2}$) are relaxed iteratively towards the MEP. The endpoints $\\mathbf{R}_0$ and $\\mathbf{R}_{N-1}$ remain fixed. At each iteration, a specific NEB force is calculated for each interior image, and its position is updated using an explicit Euler step:\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\eta\\,\\mathbf{F}_i \\quad \\text{for } i=1, \\ldots, N-2\n$$\nwhere $\\eta$ is the step size and $\\mathbf{F}_i$ is the calculated NEB force.\n\n#### Tangent and Force Calculation\nThe force on each interior image $i$ depends on the local path tangent $\\boldsymbol{\\tau}_i$. The tangent is defined using an energy-weighted scheme to ensure it points \"uphill\" from the current image. Let $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ and $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$. The tangent vector $\\boldsymbol{\\tau}_i$ is determined by the relative energies of adjacent images, as specified in the problem statement.\n\nFor most images, the NEB force is a sum of the perpendicular component of the true force and a parallel spring force:\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\mathrm{spring}}\n$$\nwhere:\n- $\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\mathrm{true}} - (\\mathbf{F}_i^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_i)\\,\\boldsymbol{\\tau}_i$ is the component of the true force perpendicular to the path. This component drives the path towards the MEP.\n- $\\mathbf{F}_i^{\\mathrm{spring}} = k_s \\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right) \\boldsymbol{\\tau}_i$ is a spring force along the tangent that ensures equal spacing of images. $k_s$ is the spring constant.\n\nTo accurately locate the saddle point (the maximum along the MEP), the climbing image (CI) modification is used. At each iteration, the interior image $m$ with the highest potential energy, $E(\\mathbf{R}_m) = \\max_{j=1..N-2} E(\\mathbf{R}_j)$, is identified. The force for this image is modified to push it towards the true saddle point:\n$$\n\\mathbf{F}_m^{\\mathrm{CI}} = \\mathbf{F}_m^{\\mathrm{true}} - 2\\,(\\mathbf{F}_m^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_m)\\,\\boldsymbol{\\tau}_m\n$$\nThis force inverts the component of the true force parallel to the path, while still minimizing the perpendicular component, effectively driving the image \"uphill\" along the path to the saddle point.\n\n#### Convergence\nThe iterative process continues until the maximum magnitude of the force on any interior image falls below a threshold $\\varepsilon$, i.e., $\\max_{i=1..N-2} \\|\\mathbf{F}_i\\|  \\varepsilon$, or a maximum number of iterations is reached.\n\n### 3. Migration Barrier Calculation\nAfter the path has converged, the migration energy barrier is the difference between the energy of the saddle point and the energy of the initial state. The saddle point energy is taken as the maximum energy among all images on the converged path.\n$$\nE_{\\mathrm{barrier}} = \\left( \\max_{i=0..N-1} E(\\mathbf{R}_i) \\right) - E(\\mathbf{R}_{\\mathrm{start}})\n$$\nThis value gives the minimum energy required for the atom to migrate from the initial to the final lattice site.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that sets up and runs the NEB calculations for all test cases.\n    \"\"\"\n\n    # Helper function to normalize a vector, handling the zero-norm case.\n    def normalize(v):\n        norm = np.linalg.norm(v)\n        if norm  1e-12:  # A small tolerance to avoid division by zero\n            return np.zeros_like(v)\n        return v / norm\n\n    # Potential energy functions\n    def V_morse(r, De, alpha, r0):\n        return De * ((1 - np.exp(-alpha * (r - r0)))**2 - 1)\n\n    def V_rep(r, A, beta):\n        return A * np.exp(-beta * r)\n\n    # Derivatives of potentials w.r.t. distance r\n    def dV_morse_dr(r, De, alpha, r0):\n        exp1 = np.exp(-alpha * (r - r0))\n        # To avoid overflow with large negative r-r0, we can cap the exponent\n        # but with current parameters it is not an issue.\n        exp2 = np.exp(-2 * alpha * (r - r0))\n        return 2 * alpha * De * (exp1 - exp2)\n\n    def dV_rep_dr(r, A, beta):\n        return -beta * A * np.exp(-beta * r)\n\n    # Total potential energy function\n    def total_potential(R, a, De, alpha, r0, A, beta):\n        R_L = np.array([-a, 0.0])\n        R_R = np.array([a, 0.0])\n        R_O = np.array([0.0, 0.0])\n        \n        r_L = np.linalg.norm(R - R_L)\n        r_R = np.linalg.norm(R - R_R)\n        r_O = np.linalg.norm(R - R_O)\n        \n        E = V_morse(r_L, De, alpha, r0) + \\\n            V_morse(r_R, De, alpha, r0) + \\\n            V_rep(r_O, A, beta)\n        return E\n\n    # True force function (-gradient of potential)\n    def true_force(R, a, De, alpha, r0, A, beta):\n        R_L = np.array([-a, 0.0])\n        R_R = np.array([a, 0.0])\n        R_O = np.array([0.0, 0.0])\n\n        r_L = np.linalg.norm(R - R_L)\n        r_R = np.linalg.norm(R - R_R)\n        r_O = np.linalg.norm(R - R_O)\n        \n        # Add a small epsilon to distance to avoid division by zero in gradient calculation\n        # if R coincides with a center (r=0).\n        eps = 1e-12\n        \n        grad_r_L = (R - R_L) / (r_L + eps)\n        grad_r_R = (R - R_R) / (r_R + eps)\n        grad_r_O = (R - R_O) / (r_O + eps)\n\n        grad_E = dV_morse_dr(r_L, De, alpha, r0) * grad_r_L + \\\n                 dV_morse_dr(r_R, De, alpha, r0) * grad_r_R + \\\n                 dV_rep_dr(r_O, A, beta) * grad_r_O\n                 \n        return -grad_E\n\n    def solve_case(params):\n        \"\"\"\n        Executes the CI-NEB algorithm for a single set of parameters.\n        \"\"\"\n        a, De, alpha, r0, A, beta, N, ks, max_iter, eta, epsilon = params\n        \n        # 1. Initialize path by linear interpolation\n        R_start = np.array([-a + r0, 0.0])\n        R_end = np.array([a - r0, 0.0])\n        \n        path = np.zeros((N, 2))\n        path[0] = R_start\n        path[-1] = R_end\n        if N  1:\n            for i in range(1, N - 1):\n                path[i] = R_start + i * (R_end - R_start) / (N - 1)\n\n        # Encapsulate potential parameters for easy passing\n        potential_params = (a, De, alpha, r0, A, beta)\n        \n        # 2. Main NEB optimization loop\n        for _ in range(max_iter):\n            # Calculate energies of all images on the current path\n            energies = np.array([total_potential(R, *potential_params) for R in path])\n            \n            # There are no interior images to optimize if N  3\n            if N  3:\n                break\n            \n            # Calculate true forces on interior images (indices 1 to N-2)\n            forces_true = np.array([true_force(path[i], *potential_params) for i in range(1, N - 1)])\n            \n            # Identify the climbing image (image with the highest energy)\n            interior_energies = energies[1:-1]\n            climbing_image_idx = np.argmax(interior_energies) + 1\n            \n            neb_forces = np.zeros_like(forces_true)\n            \n            # Loop over interior images (from path index 1 to N-2)\n            for i in range(1, N - 1):\n                # Get energies and positions of adjacent images\n                E_prev, E_curr, E_next = energies[i-1], energies[i], energies[i+1]\n                R_prev, R_curr, R_next = path[i-1], path[i], path[i+1]\n                \n                dR_plus = R_next - R_curr\n                dR_minus = R_curr - R_prev\n                \n                # Tangent calculation based on the problem's energy-weighted scheme\n                if E_next  E_curr and E_curr  E_prev:\n                    tangent_vec = dR_plus\n                elif E_next  E_curr and E_curr  E_prev:\n                    tangent_vec = dR_minus\n                else:\n                    dE_plus = E_next - E_curr\n                    dE_minus = E_prev - E_curr\n                    tangent_vec = max(0, dE_plus) * dR_plus + max(0, dE_minus) * dR_minus\n                    if np.linalg.norm(tangent_vec)  1e-12:\n                        tangent_vec = dR_plus + dR_minus\n                \n                tau = normalize(tangent_vec)\n                \n                # Retrieve the true force for the current image (i)\n                # Note: forces_true is indexed from 0, so image i corresponds to index i-1\n                F_true_i = forces_true[i-1]\n\n                # Calculate the final force (CI or regular NEB)\n                if i == climbing_image_idx:\n                    # Climbing image force: invert force component parallel to the tangent\n                    force = F_true_i - 2 * np.dot(F_true_i, tau) * tau\n                else:\n                    # Regular NEB force\n                    F_perp = F_true_i - np.dot(F_true_i, tau) * tau\n                    F_spring = ks * (np.linalg.norm(dR_plus) - np.linalg.norm(dR_minus)) * tau\n                    force = F_perp + F_spring\n                \n                neb_forces[i-1] = force\n                \n            # Check for convergence\n            max_force_mag = np.max(np.linalg.norm(neb_forces, axis=1))\n            if max_force_mag  epsilon:\n                break\n                \n            # Update interior image positions using explicit Euler\n            path[1:-1] += eta * neb_forces\n\n        # 3. Calculate migration barrier from the converged path\n        final_energies = np.array([total_potential(R, *potential_params) for R in path])\n        \n        # Saddle point energy is the maximum a-long the path\n        E_saddle = np.max(final_energies)\n        E_start = final_energies[0]\n        E_barrier = E_saddle - E_start\n        \n        return round(E_barrier, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, De, alpha, r0, A, beta, N, ks, max_iter, eta, epsilon)\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 9, 0.1, 2000, 0.05, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 3, 0.1, 3000, 0.02, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 9, 0.02, 3000, 0.05, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 1.0, 3.0, 9, 0.1, 2000, 0.05, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While methods like NEB can determine the rate of a single atomic jump, simulating the cumulative effect of billions of such jumps over seconds or hours requires a different approach. This practice delves into Kinetic Monte Carlo (KMC), a powerful simulation technique that bridges the timescale gap between individual atomic events and macroscopic diffusion . You will build a KMC model to simulate a defect's random walk, deriving the tracer diffusivity from first principles and validating it against an analytical model.",
            "id": "2784754",
            "problem": "You are asked to build a complete, runnable program that parameterizes a Kinetic Monte Carlo (KMC) model for point defect diffusion in a crystalline solid using Density Functional Theory (DFT)-derived energy barriers and attempt frequencies, and validates the predicted diffusivities against an Arrhenius-form experimental dataset. The physical setting is a point defect (either a vacancy or an interstitial) performing thermally activated nearest-neighbor hops on a simple cubic lattice. The derivation and implementation must start from fundamental principles that are standard for nanomechanics and surface and interface science.\n\nAssume the following foundational base:\n- Under harmonic Transition State Theory (hTST), the transition rate for a single activated hop is given by $k = \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$, where $k$ is the rate in $\\mathrm{s}^{-1}$, $\\nu$ is the attempt frequency in $\\mathrm{s}^{-1}$, $E_\\mathrm{a}$ is the activation energy in electron volts (eV), $k_\\mathrm{B}$ is the Boltzmann constant, and $T$ is the absolute temperature in $\\mathrm{K}$. Use $k_\\mathrm{B} = 8.617\\,333\\,262\\,145\\times 10^{-5}\\ \\mathrm{eV/K}$.\n- A simple cubic lattice has $z = 6$ equivalent nearest neighbors, separated by the lattice parameter $a$ (the jump length) expressed in meters.\n- Kinetic Monte Carlo with the residence-time algorithm advances time by random increments drawn from an exponential distribution with mean $1/R_\\mathrm{tot}$, where $R_\\mathrm{tot}$ is the total rate of leaving the current state. For $z$ equivalent neighbors, $R_\\mathrm{tot} = z k$. Directional choices among equivalent neighbors are sampled with probabilities proportional to their individual rates.\n\nUsing these bases, you must:\n- Derive a simulation-consistent estimator for the tracer diffusivity $D$ of the point defect in $d = 3$ spatial dimensions, by expressing $D$ in terms of the mean-squared displacement over the total elapsed time, i.e., using the Einstein relation and properties of a continuous-time, nearest-neighbor random walk. Your derivation must proceed from the definitions above and standard random-walk theory, without invoking any pre-tabulated shortcut formulas for the diffusion coefficient.\n- Construct a KMC algorithm that, for a given parameter set $(a, T, E_\\mathrm{a}, \\nu, z)$, performs $n$ hops, accumulates the total physical time advanced by the residence-time algorithm, and samples random jump directions among the $z$ equivalent neighbors to generate the trajectory of the defect in $3$ dimensions. Your algorithm must then compute the tracer diffusivity estimate $D_{\\text{KMC}}$ in $\\mathrm{m}^2/\\mathrm{s}$ from that trajectory.\n- Validate $D_{\\text{KMC}}$ against an experimental Arrhenius model $D_{\\text{exp}}(T) = D_0 \\exp\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$ at the same temperature $T$, where $D_0$ and $Q$ are provided for each test case. For the purposes of this problem, the “experimental” parameters are internally consistent with the underlying DFT parameters but are to be treated as given experimental values.\n\nUnits and numerical outputs:\n- All lengths must be in meters, energies in electron volts, temperature in Kelvin, time in seconds, and diffusivity in $\\mathrm{m}^2/\\mathrm{s}$.\n- Your program must output diffusivities in $\\mathrm{m}^2/\\mathrm{s}$.\n- The validation criterion is defined as a boolean pass/fail per test case: a case passes if the absolute relative error $\\left|D_{\\text{KMC}} - D_{\\text{exp}}\\right|/D_{\\text{exp}} \\le \\epsilon$, where $\\epsilon = 0.2$.\n\nTest suite:\nImplement your program to run exactly the following three test cases, each specified by $(a, T, E_\\mathrm{a}, \\nu, z, D_0, Q)$, where $D_0$ and $Q$ parameterize the Arrhenius-form experimental reference $D_{\\text{exp}}$.\n\n- Case A (vacancy-like, moderate barrier, “happy path”):\n  - $a = 3.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $T = 900\\ \\mathrm{K}$,\n  - $E_\\mathrm{a} = 0.6\\ \\mathrm{eV}$,\n  - $\\nu = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$,\n  - $z = 6$,\n  - $D_0 = a^2 \\nu$,\n  - $Q = E_\\mathrm{a}$.\n- Case B (interstitial-like, low barrier, faster diffusion):\n  - $a = 2.86\\times 10^{-10}\\ \\mathrm{m}$,\n  - $T = 600\\ \\mathrm{K}$,\n  - $E_\\mathrm{a} = 0.2\\ \\mathrm{eV}$,\n  - $\\nu = 5.0\\times 10^{12}\\ \\mathrm{s}^{-1}$,\n  - $z = 6$,\n  - $D_0 = a^2 \\nu$,\n  - $Q = E_\\mathrm{a}$.\n- Case C (edge case, very high barrier, extremely slow diffusion):\n  - $a = 3.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $T = 300\\ \\mathrm{K}$,\n  - $E_\\mathrm{a} = 2.0\\ \\mathrm{eV}$,\n  - $\\nu = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$,\n  - $z = 6$,\n  - $D_0 = a^2 \\nu$,\n  - $Q = E_\\mathrm{a}$.\n\nAlgorithmic constraints and guidance:\n- Use the residence-time algorithm with total rate $R_{\\text{tot}} = z \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$ and equal-probability selection among the $z$ directions at each hop.\n- To ensure statistical stability while remaining efficient, you may choose a fixed number of hops $n$ (shared or per-case) large enough that the relative error criterion can be meaningfully tested. Use any scientifically sound method to sample the residence times and the sequence of directions consistent with the above physics.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of length $3$, enclosed in square brackets, where each element is itself a list of length $3$ in the form $[D_{\\text{KMC}}, D_{\\text{exp}}, \\mathrm{pass}]$. For example: $[[D_1,D_1^\\ast,\\mathrm{True}],[D_2,D_2^\\ast,\\mathrm{False}],[D_3,D_3^\\ast,\\mathrm{True}]]$.\n- Each $D_{\\text{KMC}}$ and $D_{\\text{exp}}$ must be provided in $\\mathrm{m}^2/\\mathrm{s}$. The boolean $\\mathrm{pass}$ must be $\\mathrm{True}$ if $\\left|D_{\\text{KMC}} - D_{\\text{exp}}\\right|/D_{\\text{exp}} \\le \\epsilon$ with $\\epsilon = 0.2$, and $\\mathrm{False}$ otherwise.",
            "solution": "The provided problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Transition Rate**: The rate for a single activated hop follows harmonic Transition State Theory (hTST): $k = \\nu \\exp\\!\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$.\n- **Constants**: Boltzmann constant $k_\\mathrm{B} = 8.617\\,333\\,262\\,145\\times 10^{-5}\\ \\mathrm{eV/K}$.\n- **Lattice**: Simple cubic with coordination number $z = 6$. The nearest-neighbor jump length is the lattice parameter, $a$.\n- **KMC Algorithm**: The simulation must use the residence-time algorithm. The time increment $\\Delta t$ is drawn from an exponential distribution with mean $1/R_\\mathrm{tot}$. The total rate of escape is $R_\\mathrm{tot} = z k$.\n- **Diffusivity Definition**: The tracer diffusivity $D$ in $d=3$ dimensions is defined by the Einstein relation, derived from the mean-squared displacement (MSD).\n- **Experimental Reference**: Diffusivity follows an Arrhenius form, $D_\\mathrm{exp}(T) = D_0 \\exp\\!\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$.\n- **Validation Criterion**: The simulation result $D_\\mathrm{KMC}$ for a given test case is considered valid if the absolute relative error with respect to $D_\\mathrm{exp}$ is at most $\\epsilon = 0.2$, i.e., $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le 0.2$.\n- **Test Cases**: Three cases are provided, each defined by a set of parameters $(a, T, E_\\mathrm{a}, \\nu, z, D_0, Q)$. For all cases, $z=6$, and the experimental parameters are defined as $D_0 = a^2 \\nu$ and $Q = E_\\mathrm{a}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is impeccably grounded in the standard principles of statistical mechanics and computational materials science, specifically the theories of thermally activated processes (hTST), stochastic simulation (KMC), and random walks (Einstein relation). These are textbook concepts in the field.\n- **Well-Posedness**: The problem is well-posed. It provides all necessary physical parameters and constants, a clear objective (derive, implement, and validate), and a quantitative, unambiguous criterion for validation. The stochastic nature of the KMC output is acknowledged, and the need for a statistically significant number of simulation steps is implied, which is a standard aspect of such problems, not a flaw.\n- **Objectivity**: The problem is stated in objective, formal language, free of any subjectivity or non-scientific claims.\n- **Internal Consistency**: A critical check for consistency is required. The problem specifies the parameters for the \"experimental\" model $D_\\mathrm{exp}$ in terms of the microscopic simulation parameters. A theoretical derivation must connect the two. As will be shown, the problem is constructed to be perfectly self-consistent, where the theoretical prediction for diffusivity derived from microscopic parameters exactly matches the provided \"experimental\" form.\n\n### Step 3: Verdict and Action\nThe problem is assessed as **valid**. It is a standard, well-defined problem in computational physics that tests fundamental understanding and implementation skills. I will now proceed with the solution.\n\n### Derivation of the Tracer Diffusivity\n\nThe tracer diffusivity $D$ is defined by the Einstein relation in $d=3$ dimensions:\n$$\nD = \\lim_{t\\to\\infty} \\frac{\\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle}{2dt} = \\lim_{t\\to\\infty} \\frac{\\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle}{6t}\n$$\nHere, $\\langle \\cdot \\rangle$ denotes an ensemble average over many trajectories. Let the defect start at the origin, $\\mathbf{r}(0) = \\mathbf{0}$. After $n$ hops, the position is $\\mathbf{r}_n = \\sum_{i=1}^{n} \\Delta\\mathbf{r}_i$, where $\\Delta\\mathbf{r}_i$ is the displacement vector for the $i$-th hop.\n\nThe mean-squared displacement (MSD) after $n$ hops is:\n$$\n\\langle |\\mathbf{r}_n|^2 \\rangle = \\left\\langle \\left(\\sum_{i=1}^{n} \\Delta\\mathbf{r}_i\\right) \\cdot \\left(\\sum_{j=1}^{n} \\Delta\\mathbf{r}_j\\right) \\right\\rangle = \\sum_{i=1}^{n} \\langle |\\Delta\\mathbf{r}_i|^2 \\rangle + \\sum_{i \\neq j} \\langle \\Delta\\mathbf{r}_i \\cdot \\Delta\\mathbf{r}_j \\rangle\n$$\nFor a random walk on a lattice, successive hops are uncorrelated. On a centrosymmetric lattice like simple cubic, the average displacement of a single hop is zero, and hops in different directions are equally likely, leading to $\\langle \\Delta\\mathbf{r}_i \\cdot \\Delta\\mathbf{r}_j \\rangle = \\langle \\Delta\\mathbf{r}_i \\rangle \\cdot \\langle \\Delta\\mathbf{r}_j \\rangle = 0$ for $i \\neq j$.\nThe jump length is fixed at the nearest-neighbor distance $a$, so $|\\Delta\\mathbf{r}_i|^2 = a^2$ for all $i$. The MSD simplifies to:\n$$\n\\langle |\\mathbf{r}_n|^2 \\rangle = n a^2\n$$\nThe total time elapsed after $n$ hops, $t_n$, is the sum of $n$ individual time increments: $t_n = \\sum_{i=1}^{n} \\Delta t_i$. In the residence-time algorithm, each $\\Delta t_i$ is a random variable drawn from an exponential distribution with rate parameter $R_\\mathrm{tot}$. The expected value of each time step is $\\langle \\Delta t \\rangle = 1/R_\\mathrm{tot}$. By the law of large numbers, for a large number of hops $n$, the total time $t_n$ approximates its expected value:\n$$\nt_n \\approx n \\langle \\Delta t \\rangle = \\frac{n}{R_\\mathrm{tot}}\n$$\nSubstituting the expressions for MSD and total time into the Einstein relation, we obtain the theoretical diffusivity $D_\\mathrm{theory}$:\n$$\nD_\\mathrm{theory} = \\frac{\\langle |\\mathbf{r}_n|^2 \\rangle}{6 t_n} = \\frac{n a^2}{6 (n/R_\\mathrm{tot})} = \\frac{a^2 R_\\mathrm{tot}}{6}\n$$\nThe total rate $R_\\mathrm{tot}$ is the sum of rates for all possible escape paths. For a simple cubic lattice with $z=6$ identical nearest-neighbor sites, $R_\\mathrm{tot} = z k$. Substituting the expression for the hop rate $k$:\n$$\nD_\\mathrm{theory} = \\frac{a^2 (z k)}{6} = \\frac{z a^2}{6} \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)\n$$\nFor the specific case of a simple cubic lattice where $z=6$, this becomes:\n$$\nD_\\mathrm{theory} = \\frac{6 a^2}{6} \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right) = a^2 \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)\n$$\nNow, we compare this with the provided experimental form, $D_\\mathrm{exp}(T) = D_0 \\exp\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$. The problem states that for all test cases, $D_0 = a^2 \\nu$ and $Q = E_\\mathrm{a}$. Therefore, the analytical form of the experimental data is identical to our derived theoretical diffusivity: $D_\\mathrm{theory} = D_\\mathrm{exp}$.\nThis confirms the internal consistency of the problem. The KMC simulation, being a numerical realization of the theoretical model, should yield a diffusivity $D_\\mathrm{KMC}$ that converges to this analytical value $D_\\mathrm{exp}$ in the limit of a large number of hops. Any deviation will be due to statistical noise inherent in the stochastic simulation.\n\n### Kinetic Monte Carlo Algorithm Design\n\nThe algorithm to be implemented will simulate the trajectory of a single point defect and compute its diffusivity.\n1.  **Initialization**: For each test case, retrieve the parameters $(a, T, E_\\mathrm{a}, \\nu, z)$.\n    - Set the initial position of the defect to the origin, $\\mathbf{r} = [0, 0, 0]$.\n    - Set the total elapsed time to zero, $t_\\mathrm{total} = 0$.\n    - Define the set of $z=6$ possible jump vectors: $\\{(\\pm a, 0, 0), (0, \\pm a, 0), (0, 0, \\pm a)\\}$.\n2.  **Rate Calculation**: Compute the single hop rate $k = \\nu \\exp(-E_\\mathrm{a} / (k_\\mathrm{B} T))$ and the total escape rate $R_\\mathrm{tot} = z k$. The mean residence time is $\\tau = 1/R_\\mathrm{tot}$.\n3.  **Simulation Loop**: Iterate for a fixed, large number of hops, $n_{hops}$. A value of $n_{hops} = 10000$ is chosen. This is large enough to ensure that statistical fluctuations in the final computed diffusivity are small, allowing for a meaningful comparison against the validation tolerance of $\\epsilon=0.2$, while remaining computationally inexpensive.\n    - **Time Advancement**: Draw a random number $u$ from a uniform distribution $U(0, 1)$ and advance the simulation time by $\\Delta t = -\\ln(u) / R_\\mathrm{tot}$. This is equivalent to drawing from an exponential distribution with mean $\\tau$. Update $t_\\mathrm{total} = t_\\mathrm{total} + \\Delta t$.\n    - **Jump Selection**: Since all $z=6$ neighboring sites are equivalent, select one of the six jump vectors with uniform probability $1/6$.\n    - **Position Update**: Add the selected jump vector to the current position $\\mathbf{r}$.\n4.  **Diffusivity Calculation**: After $n_{hops}$ are completed, the final position is $\\mathbf{r}_\\mathrm{final}$ and the total time is $t_\\mathrm{total}$. The KMC-estimated diffusivity is calculated using the endpoint data, consistent with the Einstein relation:\n    $$\n    D_\\mathrm{KMC} = \\frac{|\\mathbf{r}_\\mathrm{final}|^2}{6 t_\\mathrm{total}}\n    $$\n5.  **Validation**: Calculate the \"experimental\" value $D_\\mathrm{exp} = (a^2 \\nu) \\exp(-E_\\mathrm{a} / (k_\\mathrm{B} T))$. Determine if the pass condition $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le 0.2$ is met.\nThis procedure will be implemented for each of the three test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a Kinetic Monte Carlo (KMC) simulation for point defect\n    diffusion, validating the results against an analytical Arrhenius-form model.\n    \"\"\"\n\n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Number of hops for the KMC simulation.\n    # Chosen to be large enough for statistical convergence.\n    n_hops = 10000\n\n    # Tolerance for validation\n    epsilon = 0.2\n\n    # Test cases as specified in the problem statement.\n    # (a, T, E_a, nu, z, D0_formula, Q_formula)\n    # D0 and Q are given as formulas a^2*nu and E_a, respectively.\n    test_cases = [\n        # Case A: Vacancy-like, moderate barrier\n        {'a': 3.0e-10, 'T': 900.0, 'E_a': 0.6, 'nu': 1.0e13, 'z': 6},\n        # Case B: Interstitial-like, low barrier\n        {'a': 2.86e-10, 'T': 600.0, 'E_a': 0.2, 'nu': 5.0e12, 'z': 6},\n        # Case C: Edge case, very high barrier\n        {'a': 3.0e-10, 'T': 300.0, 'E_a': 2.0, 'nu': 1.0e13, 'z': 6},\n    ]\n\n    results = []\n\n    # Use a fixed seed for reproducibility of the stochastic simulation\n    np.random.seed(42)\n\n    for case in test_cases:\n        a = case['a']\n        T = case['T']\n        E_a = case['E_a']\n        nu = case['nu']\n        z = case['z']\n\n        # --- Theoretical/Experimental Calculation ---\n        # The problem states D0 = a^2 * nu and Q = E_a.\n        # This is consistent with the derivation for a simple cubic lattice (z=6).\n        D_exp = (a**2 * nu) * np.exp(-E_a / (k_B * T))\n\n        # --- KMC Simulation ---\n        # 1. Initialization\n        position = np.zeros(3)\n        total_time = 0.0\n\n        # Define the jump vectors for a simple cubic lattice\n        jump_vectors = a * np.array([\n            [1, 0, 0], [-1, 0, 0],\n            [0, 1, 0], [0, -1, 0],\n            [0, 0, 1], [0, 0, -1]\n        ])\n\n        # 2. Rate Calculation\n        k_hop = nu * np.exp(-E_a / (k_B * T))\n        R_tot = z * k_hop\n        \n        # Mean time step (scale for exponential distribution)\n        # Handle R_tot=0 case to avoid division by zero, though not expected here.\n        tau = 1.0 / R_tot if R_tot  0 else float('inf')\n\n        # 3. Simulation Loop\n        # Advance time by drawing from exponential distribution\n        time_steps = np.random.exponential(scale=tau, size=n_hops)\n        total_time = np.sum(time_steps)\n        \n        # Select jump directions uniformly\n        jump_indices = np.random.randint(0, z, size=n_hops)\n        \n        # Sum up all jump vectors to get the final position\n        # This is more efficient than a Python loop for position updates\n        final_position = np.sum(jump_vectors[jump_indices], axis=0)\n        \n        # 4. Diffusivity Calculation\n        # Mean squared displacement from origin\n        msd = np.dot(final_position, final_position)\n        \n        # Einstein relation in 3D\n        D_kmc = msd / (6.0 * total_time)\n\n        # 5. Validation\n        relative_error = np.abs(D_kmc - D_exp) / D_exp\n        passed = relative_error = epsilon\n\n        results.append([D_kmc, D_exp, passed])\n\n    # Format the final output string to match the specified format `[[d,d_exp,pass],...]`\n    # without any spaces.\n    results_str_parts = []\n    for res in results:\n        # Format each sublist manually to control spacing\n        # res[2] is a bool, str(res[2]) gives 'True'/'False'\n        part = f\"[{res[0]},{res[1]},{res[2]}]\"\n        results_str_parts.append(part)\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The diffusion coefficient can describe different physical processes, such as the random walk of a single tagged atom (tracer diffusion) or the collective motion of charge carriers (ionic conductivity). This practice explores the subtle but crucial differences between these quantities, which arise from correlated ionic movements in a dense system . By deriving the Haven ratio from the fundamental Green-Kubo relations, you will uncover how inter-particle correlations reduce the efficiency of charge transport compared to the random walk of a single tracer ion.",
            "id": "3833719",
            "problem": "An ionic conductor consists of $N$ monovalent cations of charge $q$ moving on a three-dimensional periodic lattice of volume $V$ at temperature $T$. The number density is $n = N/V$. The tracer diffusion coefficient $D^{*}$ of a tagged ion is defined by the Einstein relation for self-diffusion and its Green–Kubo (Green–Kubo (GK)) equivalent as\n\n$$\nD^{*} \\equiv \\lim_{t \\to \\infty} \\frac{1}{6 t} \\left\\langle \\left|\\mathbf{r}_{i}(t) - \\mathbf{r}_{i}(0)\\right|^{2} \\right\\rangle \\;=\\; \\frac{1}{3} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{i}(t) \\right\\rangle,\n$$\n\nwhere $\\mathbf{r}_{i}(t)$ and $\\mathbf{v}_{i}(t)$ are the position and velocity of a tagged cation $i$, and $\\langle \\cdot \\rangle$ denotes an equilibrium ensemble average. The ionic conductivity $\\sigma$ of the same system is given by the Green–Kubo relation\n\n$$\n\\sigma \\;=\\; \\frac{1}{3 V k_{B} T} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{J}(0)\\cdot \\mathbf{J}(t) \\right\\rangle,\\qquad \\mathbf{J}(t) \\equiv q \\sum_{i=1}^{N} \\mathbf{v}_{i}(t),\n$$\n\nwith $k_{B}$ the Boltzmann constant. Define the conductivity diffusion coefficient $D_{\\sigma}$ by $\\sigma \\equiv n q^{2} D_{\\sigma}/(k_{B} T)$. The Haven ratio is $H \\equiv D_{\\sigma}/D^{*}$. Introduce the dimensionless collective correlation parameter\n\n$$\n\\Xi \\;\\equiv\\; \\frac{1}{N}\\,\\frac{\\displaystyle \\sum_{i\\neq j}\\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{j}(t) \\right\\rangle}{\\displaystyle \\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{i}(t) \\right\\rangle},\n$$\n\nwhere the numerator contains only distinct-particle $(i\\neq j)$ velocity cross-correlation integrals and the denominator is the self velocity autocorrelation integral of a single ion.\n\nTasks:\n- Starting only from the definitions above and fundamental statistical mechanical identities, express the Haven ratio $H$ explicitly in terms of $\\Xi$ and explain the physical origin of the sign of $\\Xi$ for a dense monovalent ionic conductor.\n- A molecular dynamics calculation of a monovalent halide at $T = 800\\,\\mathrm{K}$ yields $\\Xi = -0.38$. Compute the numerical value of the Haven ratio $H$. Round your answer to $3$ significant figures. Report $H$ as a dimensionless number.",
            "solution": "The task is to derive the relationship between the Haven ratio $H$ and the collective correlation parameter $\\Xi$, explain the physical origin of the sign of $\\Xi$, and compute a numerical value for $H$.\n\nFirst, we will establish the relationship between $H$ and $\\Xi$. We begin with the definition of the conductivity diffusion coefficient, $D_{\\sigma}$, given by the relation $\\sigma \\equiv n q^{2} D_{\\sigma}/(k_{B} T)$. We can solve for $D_{\\sigma}$:\n$$\nD_{\\sigma} = \\frac{\\sigma k_{B} T}{n q^{2}}\n$$\nHere, $n=N/V$ is the number density of the cations. Substituting this and the Green–Kubo formula for conductivity $\\sigma$ yields:\n$$\nD_{\\sigma} = \\frac{k_{B} T}{(N/V) q^{2}} \\left( \\frac{1}{3 V k_{B} T} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{J}(0)\\cdot \\mathbf{J}(t) \\right\\rangle \\right)\n$$\nSimplifying the expression by canceling terms $k_{B} T$ and $V$:\n$$\nD_{\\sigma} = \\frac{1}{N q^{2}} \\frac{1}{3} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{J}(0)\\cdot \\mathbf{J}(t) \\right\\rangle\n$$\nNext, we substitute the definition of the total ionic current, $\\mathbf{J}(t) = q \\sum_{i=1}^{N} \\mathbf{v}_{i}(t)$, into the current-current correlation function:\n$$\n\\left\\langle \\mathbf{J}(0)\\cdot \\mathbf{J}(t) \\right\\rangle = \\left\\langle \\left( q \\sum_{i=1}^{N} \\mathbf{v}_{i}(0) \\right) \\cdot \\left( q \\sum_{j=1}^{N} \\mathbf{v}_{j}(t) \\right) \\right\\rangle = q^{2} \\left\\langle \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{j}(t) \\right\\rangle\n$$\nSubstituting this back into the expression for $D_{\\sigma}$, the charge $q^{2}$ cancels out:\n$$\nD_{\\sigma} = \\frac{1}{N q^{2}} \\frac{1}{3} \\int_{0}^{\\infty} \\mathrm{d}t\\, q^{2} \\left\\langle \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{j}(t) \\right\\rangle = \\frac{1}{3N} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{j}(t) \\right\\rangle\n$$\nWe now decompose the double summation over indices $i$ and $j$ into two parts: the \"self\" part where $i=j$, and the \"distinct\" part where $i \\neq j$:\n$$\nD_{\\sigma} = \\frac{1}{3N} \\left[ \\sum_{i=1}^{N} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{i}(t) \\right\\rangle + \\sum_{i\\neq j} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{j}(t) \\right\\rangle \\right]\n$$\nFor a system in thermodynamic equilibrium, the time integral of the velocity autocorrelation function for any particle $i$ is identical to that of any other particle. Therefore, the first sum contains $N$ identical terms:\n$$\n\\sum_{i=1}^{N} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{i}(t) \\right\\rangle = N \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{i}(t) \\right\\rangle\n$$\nThe first term in the expression for $D_{\\sigma}$ becomes:\n$$\n\\frac{1}{3N} \\left( N \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{i}(t) \\right\\rangle \\right) = \\frac{1}{3} \\int_{0}^{\\infty} \\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{i}(t) \\right\\rangle\n$$\nBy definition, this is precisely the tracer diffusion coefficient $D^{*}$. Thus, the first term is $D^{*}$.\n\nNow we analyze the second term, which represents the cross-correlations. From the definition of the collective correlation parameter $\\Xi$:\n$$\n\\Xi = \\frac{1}{N}\\,\\frac{\\displaystyle \\sum_{i\\neq j}\\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{j}(t) \\right\\rangle}{\\displaystyle \\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{i}(t) \\right\\rangle}\n$$\nWe can rearrange this to express the sum of cross-correlation integrals:\n$$\n\\sum_{i\\neq j}\\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{j}(t) \\right\\rangle = N \\Xi \\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{i}(t) \\right\\rangle\n$$\nWe also know from the definition of $D^{*}$ that $\\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{i}(t) \\right\\rangle = 3 D^{*}$. Substituting this, we get:\n$$\n\\sum_{i\\neq j}\\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{j}(t) \\right\\rangle = N \\Xi (3 D^{*})\n$$\nInserting this into the second term of the expression for $D_{\\sigma}$:\n$$\n\\frac{1}{3N} \\left( N \\Xi (3 D^{*}) \\right) = \\Xi D^{*}\n$$\nCombining both terms, we find the expression for $D_{\\sigma}$:\n$$\nD_{\\sigma} = D^{*} + \\Xi D^{*} = D^{*}(1 + \\Xi)\n$$\nThe Haven ratio is defined as $H \\equiv D_{\\sigma}/D^{*}$. Substituting our result for $D_{\\sigma}$:\n$$\nH = \\frac{D^{*}(1 + \\Xi)}{D^{*}} = 1 + \\Xi\n$$\nThis is the desired relation between the Haven ratio and the collective correlation parameter.\n\nThe physical origin of the sign of $\\Xi$ in a dense monovalent ionic conductor stems from the correlated nature of ionic transport. In such systems, ions typically move via a hopping mechanism, such as vacancy diffusion. When a tagged ion $i$ hops into an adjacent vacant site at time $t=0$, its velocity $\\mathbf{v}_{i}(0)$ is non-zero. This hop leaves a vacancy at the ion's original position. For a brief period afterward, there is an increased probability that a neighboring ion, say ion $j$, will hop into this newly created vacancy. This subsequent hop by ion $j$ occurs in a direction that is, on average, opposite to the initial hop of ion $i$. This phenomenon is known as a backward-correlation effect. As a result, the velocities $\\mathbf{v}_{i}(0)$ and $\\mathbf{v}_{j}(t)$ are anti-correlated, making the dot product $\\mathbf{v}_{i}(0) \\cdot \\mathbf{v}_{j}(t)$ negative on average for short times $t$. The time integral $\\int_{0}^{\\infty}\\mathrm{d}t\\, \\left\\langle \\mathbf{v}_{i}(0)\\cdot \\mathbf{v}_{j}(t) \\right\\rangle$ is therefore negative. The denominator in the definition of $\\Xi$ is proportional to $D^{*}$ and is positive definite. Since the numerator is a sum of negative terms, the overall sign of $\\Xi$ is negative. This negative correlation signifies that the collective displacement of charge (measured by $D_{\\sigma}$) is less effective than what would be expected from uncorrelated individual ionic random walks (measured by $D^{*}$).\n\nFinally, we compute the numerical value of the Haven ratio $H$ for a monovalent halide at $T = 800\\,\\mathrm{K}$ given $\\Xi = -0.38$.\nUsing the derived formula:\n$$\nH = 1 + \\Xi = 1 + (-0.38) = 0.62\n$$\nThe problem requires the answer to be rounded to $3$ significant figures.\n$$\nH = 0.620\n$$",
            "answer": "$$\n\\boxed{H = 1 + \\Xi = 0.620}\n$$"
        }
    ]
}