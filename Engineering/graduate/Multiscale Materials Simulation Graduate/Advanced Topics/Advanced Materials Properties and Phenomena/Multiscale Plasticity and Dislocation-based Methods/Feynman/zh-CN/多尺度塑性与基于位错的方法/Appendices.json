{
    "hands_on_practices": [
        {
            "introduction": "在计算塑性力学中，径向返回算法是求解弹塑性本构关系的基石，广泛应用于有限元软件。这个练习将引导你从第一性原理出发，在一个简化的单轴加载场景下，推导并实现这一核心算法。通过这个实践，你将掌握如何通过隐式后向欧拉积分和塑性一致性条件来精确更新应力状态，为理解和开发更复杂的多维材料模型打下坚实基础。",
            "id": "3825969",
            "problem": "实现一个具有线性各向同性硬化的小应变单轴弹塑性应力更新，该更新使用隐式后向欧拉步和特化到一维的径向返回映射逻辑，并计算更新后的 Cauchy 应力。从率无关伴随塑性的第一性原理出发，推导更新方程，然后在一个评估指定测试套件的程序中实现它们。所有应力以帕斯卡 (Pa) 表示，所有应变均为无量纲量。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个条目都是一个以帕斯卡为单位、四舍五入到六位小数的浮点数。\n\n使用以下基本原理。\n- 运动学：对于小应变，总应变满足加法分解 $ \\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}} $。\n- 弹性力学：在单轴形式下，Cauchy 应力为 $ \\sigma = E \\, \\varepsilon^{\\mathrm{e}} $，其中 $ E $ 是杨氏模量。\n- 屈服准则：使用特化到一维的 von Mises (也称 $ J_2 $) 准则， $ f(\\sigma, \\alpha) = |\\sigma| - \\left( \\sigma_{y0} + H \\, \\alpha \\right) \\le 0 $，其中 $ \\sigma_{y0} $ 是初始屈服应力，$ H $ 是线性各向同性硬化模量，$ \\alpha $ 是与一维塑性应变度量一致的累积硬化变量。\n- 流动法则和硬化定律：假设伴随流动，$ \\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma} \\, \\operatorname{sgn}(\\sigma) $ 和 $ \\dot{\\alpha} = \\dot{\\gamma} $，其中 $ \\dot{\\gamma} \\ge 0 $。一致性条件为 $ f \\le 0 $、$ \\dot{\\gamma} \\ge 0 $ 和 $ \\dot{\\gamma} \\, f = 0 $。\n- 时间积分：在一个应变增量 $ \\Delta \\varepsilon $ 上，对非弹性演化方程应用隐式后向欧拉更新。\n\n给定材料参数 $ E $、$ \\sigma_{y0} $ 和 $ H $，以及在时间 $ t_n $ 的先前状态 $ \\sigma_n $ 和 $ \\alpha_n $，以及从 $ t_n $ 到 $ t_{n+1} $ 的总应变增量 $ \\Delta \\varepsilon $，请从上述基本原理出发，推导一个特化到一维的鲁棒径向返回更新算法，用以计算更新后的 Cauchy 应力 $ \\sigma_{n+1} $ (以帕斯卡为单位) 和更新后的硬化变量 $ \\alpha_{n+1} $。然后实现该算法，为以下每个测试用例计算 $ \\sigma_{n+1} $。\n\n使用以下测试套件。对于每个情况，所有应力以帕斯卡 (Pa) 为单位，所有应变均为无量纲量，输出必须是更新后的 Cauchy 应力 $ \\sigma_{n+1} $，以帕斯卡 (Pa) 为单位，四舍五入到六位小数。\n- 情况 1 (弹性加载)：$ E = 210 \\times 10^{9} $，$ \\sigma_{y0} = 250 \\times 10^{6} $，$ H = 1 \\times 10^{9} $，$ \\sigma_{n} = 200 \\times 10^{6} $，$ \\alpha_{n} = 0 $，$ \\Delta \\varepsilon = 1 \\times 10^{-4} $。\n- 情况 2 (屈服开始)：$ E = 210 \\times 10^{9} $，$ \\sigma_{y0} = 250 \\times 10^{6} $，$ H = 1 \\times 10^{9} $，$ \\sigma_{n} = 200 \\times 10^{6} $，$ \\alpha_{n} = 0 $，$ \\Delta \\varepsilon = \\dfrac{50 \\times 10^{6}}{210 \\times 10^{9}} $。\n- 情况 3 (带硬化的塑性加载)：$ E = 210 \\times 10^{9} $，$ \\sigma_{y0} = 250 \\times 10^{6} $，$ H = 1 \\times 10^{9} $，$ \\sigma_{n} = 200 \\times 10^{6} $，$ \\alpha_{n} = 0 $，$ \\Delta \\varepsilon = 5 \\times 10^{-4} $。\n- 情况 4 (理想塑性极限)：$ E = 210 \\times 10^{9} $，$ \\sigma_{y0} = 250 \\times 10^{6} $，$ H = 0 $，$ \\sigma_{n} = 200 \\times 10^{6} $，$ \\alpha_{n} = 0 $，$ \\Delta \\varepsilon = 5 \\times 10^{-4} $。\n- 情况 5 (硬化后的弹性反向加载)：$ E = 210 \\times 10^{9} $，$ \\sigma_{y0} = 250 \\times 10^{6} $，$ H = 2 \\times 10^{9} $，$ \\sigma_{n} = 260 \\times 10^{6} $，$ \\alpha_{n} = 1 \\times 10^{-2} $，$ \\Delta \\varepsilon = -1 \\times 10^{-4} $。\n- 情况 6 (塑性压缩)：$ E = 210 \\times 10^{9} $，$ \\sigma_{y0} = 250 \\times 10^{6} $，$ H = 1 \\times 10^{9} $，$ \\sigma_{n} = 0 $，$ \\alpha_{n} = 0 $，$ \\Delta \\varepsilon = -2 \\times 10^{-3} $。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果按情况 1 到情况 6 的顺序排列，例如 $[\\text{result1},\\text{result2},\\dots]$。每个条目必须是以帕斯卡为单位、四舍五入到六位小数的浮点数。",
            "solution": "该问题陈述经评估有效。它在科学上基于已建立的率无关连续介质塑性力学理论，在数学上是适定的，并以客观、明确的方式呈现。所有必要的参数和条件都已提供，可为每个测试用例确定唯一解。该问题要求推导和实现计算固体力学中的一个标准、典型的算法。\n\n任务是为一个具有线性各向同性硬化的一维小应变弹塑性模型推导并实现一个应力更新算法。本构方程在一个有限时间步上的积分是使用隐式后向欧拉格式进行的，这引出了径向返回映射算法。\n\n在时间 $t_n$ 时材料的状态是已知的，由 Cauchy 应力 $\\sigma_n$ 和累积硬化变量 $\\alpha_n$ 定义。在时间间隔 $[t_n, t_{n+1}]$ 内，材料承受一个总应变增量 $\\Delta \\varepsilon$。目标是计算更新后的应力 $\\sigma_{n+1}$ 和硬化变量 $\\alpha_{n+1}$。\n\n该过程分为三个主要步骤：弹性试探、屈服检查和可能的塑性修正步。\n\n**1. 弹性试探步**\n\n首先，我们假设整个应变增量 $\\Delta \\varepsilon$ 是纯弹性的。这意味着在此增量期间塑性状态变量没有变化。\n$$ \\Delta \\varepsilon^{\\mathrm{p}} = 0 \\implies \\varepsilon_{n+1}^{\\mathrm{p}} = \\varepsilon_n^{\\mathrm{p}} $$\n$$ \\Delta \\alpha = 0 \\implies \\alpha_{n+1} = \\alpha_n $$\n在时间 $t_{n+1}$ 的总应变为 $\\varepsilon_{n+1} = \\varepsilon_n + \\Delta \\varepsilon$。使用应变的加法分解 $\\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}}$，在 $t_{n+1}$ 的试探弹性应变为：\n$$ \\varepsilon_{n+1}^{\\mathrm{e, trial}} = \\varepsilon_{n+1} - \\varepsilon_{n+1}^{\\mathrm{p}} = (\\varepsilon_n^{\\mathrm{e}} + \\varepsilon_n^{\\mathrm{p}}) + \\Delta \\varepsilon - \\varepsilon_n^{\\mathrm{p}} = \\varepsilon_n^{\\mathrm{e}} + \\Delta \\varepsilon $$\n试探应力 $\\sigma_{n+1}^{\\mathrm{trial}}$ 使用线弹性定律 $\\sigma = E \\varepsilon^{\\mathrm{e}}$ 计算：\n$$ \\sigma_{n+1}^{\\mathrm{trial}} = E \\, \\varepsilon_{n+1}^{\\mathrm{e, trial}} = E (\\varepsilon_n^{\\mathrm{e}} + \\Delta \\varepsilon) $$\n因为 $\\sigma_n = E \\varepsilon_n^{\\mathrm{e}}$，这可以简化为从先前应力状态的直接更新：\n$$ \\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta \\varepsilon $$\n\n**2. 屈服检查**\n\n只有当产生的试探应力状态不违反屈服条件时，弹性试探假设才有效。屈服函数由 $f(\\sigma, \\alpha) = |\\sigma| - \\sigma_y(\\alpha)$ 给出，其中当前屈服应力为 $\\sigma_y(\\alpha) = \\sigma_{y0} + H \\alpha$。我们在试探状态 $(\\sigma_{n+1}^{\\mathrm{trial}}, \\alpha_n)$ 下评估屈服函数：\n$$ f^{\\mathrm{trial}} = f(\\sigma_{n+1}^{\\mathrm{trial}}, \\alpha_n) = |\\sigma_{n+1}^{\\mathrm{trial}}| - (\\sigma_{y0} + H \\alpha_n) $$\n有两种可能性：\n- 如果 $f^{\\mathrm{trial}} \\le 0$，则试探状态位于屈服面内部或表面上。弹性变形的假设是正确的。最终更新的状态即为试探状态：\n  $$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} $$\n  $$ \\alpha_{n+1} = \\alpha_n $$\n- 如果 $f^{\\mathrm{trial}} > 0$，则试探状态位于屈服面之外，这在物理上是不可接受的。弹性假设不正确，必定发生了塑性变形。需要一个塑性修正步将应力状态返回到更新后的屈服面上。\n\n**3. 塑性修正步 (径向返回)**\n\n当 $f^{\\mathrm{trial}} > 0$ 时，发生塑性流动。$t_{n+1}$ 时刻的状态必须满足使用隐式后向欧拉格式积分的全套本构方程。塑性应变和硬化变量的增量为：\n$$ \\Delta \\varepsilon^{\\mathrm{p}} = \\varepsilon_{n+1}^{\\mathrm{p}} - \\varepsilon_n^{\\mathrm{p}} = \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1}) $$\n$$ \\Delta \\alpha = \\alpha_{n+1} - \\alpha_n = \\Delta\\gamma $$\n其中 $\\Delta\\gamma \\ge 0$ 是有限时间步的一致性参数或塑性乘子增量。\n\n在 $t_{n+1}$ 的应力-应变关系为：\n$$ \\sigma_{n+1} = E \\varepsilon_{n+1}^{\\mathrm{e}} = E(\\varepsilon_{n+1} - \\varepsilon_{n+1}^{\\mathrm{p}}) = E(\\varepsilon_n + \\Delta\\varepsilon - (\\varepsilon_n^{\\mathrm{p}} + \\Delta\\varepsilon^{\\mathrm{p}})) $$\n$$ \\sigma_{n+1} = E(\\varepsilon_n^{\\mathrm{e}} + \\Delta\\varepsilon - \\Delta\\varepsilon^{\\mathrm{p}}) = \\sigma_n + E\\Delta\\varepsilon - E\\Delta\\varepsilon^{\\mathrm{p}} $$\n识别出试探应力项 $\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta \\varepsilon$，我们得到：\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\varepsilon^{\\mathrm{p}} $$\n代入流动法则：\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1}) $$\n这个方程表明，最终应力 $\\sigma_{n+1}$ 是通过从试探应力 $\\sigma_{n+1}^{\\mathrm{trial}}$ 进行“返回”得到的。对于塑性步，最终状态必须位于扩展后的屈服面上，满足一致性条件 $f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$：\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H \\alpha_{n+1}) = 0 $$\n代入硬化定律 $\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma$：\n$$ |\\sigma_{n+1}| = \\sigma_{y0} + H(\\alpha_n + \\Delta\\gamma) = (\\sigma_{y0} + H\\alpha_n) + H\\Delta\\gamma $$\n\n我们现在有一个由两个方程组成的系统，用于求解两个未知数 $\\sigma_{n+1}$ 和 $\\Delta\\gamma$。一个关键的观察是，返回路径不改变应力的符号，所以 $\\operatorname{sgn}(\\sigma_{n+1}) = \\operatorname{sgn}(\\sigma_{n+1}^{\\mathrm{trial}})$。对映力返回方程取绝对值（并注意 $|\\operatorname{sgn}(\\sigma_{n+1})| = 1$）：\n$$ |\\sigma_{n+1}| = |\\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1})| = |\\sigma_{n+1}^{\\mathrm{trial}}| - E \\Delta\\gamma $$\n将此与屈服条件相等：\n$$ |\\sigma_{n+1}^{\\mathrm{trial}}| - E \\Delta\\gamma = (\\sigma_{y0} + H\\alpha_n) + H\\Delta\\gamma $$\n求解 $\\Delta\\gamma$：\n$$ |\\sigma_{n+1}^{\\mathrm{trial}}| - (\\sigma_{y0} + H\\alpha_n) = (E+H)\\Delta\\gamma $$\n左边的项恰好是试探屈服函数值 $f^{\\mathrm{trial}}$。因此，塑性乘子被确定为：\n$$ \\Delta\\gamma = \\frac{f^{\\mathrm{trial}}}{E+H} $$\n由于我们处于塑性情况，$f^{\\mathrm{trial}} > 0$。因为 $E > 0$ 且 $H \\ge 0$，所以 $\\Delta\\gamma > 0$，这与其定义一致。\n\n在已知 $\\Delta\\gamma$ 的情况下，可以计算最终的状态变量。\n更新后的应力为：\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1}^{\\mathrm{trial}}) $$\n更新后的硬化变量为：\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\gamma $$\n\n**算法摘要**\n对于给定的状态 $(\\sigma_n, \\alpha_n)$、材料参数 $(E, \\sigma_{y0}, H)$ 和应变增量 $\\Delta \\varepsilon$：\n1. 计算试探应力：$\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta \\varepsilon$。\n2. 计算增量开始时的屈服应力：$\\sigma_y(\\alpha_n) = \\sigma_{y0} + H \\alpha_n$。\n3. 通过评估试探屈服函数检查屈服：$f^{\\mathrm{trial}} = |\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_y(\\alpha_n)$。\n4. 如果 $f^{\\mathrm{trial}} \\le 0$ (弹性步)：\n    -   $\\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}}$\n    -   $\\alpha_{n+1} = \\alpha_n$\n5. 如果 $f^{\\mathrm{trial}} > 0$ (塑性步)：\n    -   计算塑性乘子：$\\Delta\\gamma = f^{\\mathrm{trial}} / (E+H)$。\n    -   更新应力：$\\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\operatorname{sgn}(\\sigma_{n+1}^{\\mathrm{trial}})$。\n    -   更新硬化变量：$\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma$。\n该算法被实现用于评估所提供的测试套件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the updated Cauchy stress for a series of uniaxial elastoplastic\n    test cases using a 1D radial return mapping algorithm.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary of parameters.\n    test_cases = [\n        # Case 1 (elastic loading)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 1e-4},\n        # Case 2 (onset of yielding)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 50e6 / 210e9},\n        # Case 3 (plastic loading with hardening)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 5e-4},\n        # Case 4 (perfect plasticity limit)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 0, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 5e-4},\n        # Case 5 (elastic reverse loading after hardening)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 2e9, \"sigma_n\": 260e6, \"alpha_n\": 1e-2, \"delta_eps\": -1e-4},\n        # Case 6 (plastic compression)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 0, \"alpha_n\": 0, \"delta_eps\": -2e-3},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        E = case[\"E\"]\n        sigma_y0 = case[\"sigma_y0\"]\n        H = case[\"H\"]\n        sigma_n = case[\"sigma_n\"]\n        alpha_n = case[\"alpha_n\"]\n        delta_eps = case[\"delta_eps\"]\n\n        # Step 1: Elastic Trial Step\n        # Compute the trial stress\n        sigma_trial = sigma_n + E * delta_eps\n\n        # Step 2: Yield Check\n        # Compute the current yield stress based on the state at step n\n        sigma_y_n = sigma_y0 + H * alpha_n\n        \n        # Evaluate the yield function at the trial state\n        f_trial = abs(sigma_trial) - sigma_y_n\n\n        # Step 3  4: Determine Final State (Elastic or Plastic)\n        if f_trial = 0:\n            # Elastic step: The trial state is the final state.\n            sigma_np1 = sigma_trial\n            # alpha_np1 = alpha_n # No change in hardening variable\n        else:\n            # Plastic step: Apply plastic corrector (radial return)\n            # The denominator (E+H) can be zero if E=-H, which is not physically\n            # realistic for this model. For H=0 (perfect plasticity), E+H=E > 0.\n            # Handle the case where H is zero to prevent division by zero if E were zero.\n            # However, E > 0 is a physical requirement for elastic materials.\n            if E + H == 0:\n                raise ValueError(\"E + H must be positive.\")\n\n            # Calculate the plastic multiplier increment\n            delta_gamma = f_trial / (E + H)\n\n            # Update stress using the radial return formula\n            sigma_np1 = sigma_trial - E * delta_gamma * np.sign(sigma_trial)\n            \n            # Update the hardening variable\n            # alpha_np1 = alpha_n + delta_gamma\n\n        # Round the final stress to six decimal places as required\n        rounded_result = round(sigma_np1, 6)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在各向同性塑性模型的基础上，单晶塑性模型能够更真实地反映材料在微观尺度上的物理行为，将宏观变形分解到特定的晶体滑移系上。这个练习要求你为一个受单轴拉伸的单晶实现一个隐式应力更新算法，处理多个滑移系的激活和相互作用。掌握此方法对于准确预测晶体材料的各向异性响应和织构演化至关重要，是连接位错理论与工程应用的关键一环。",
            "id": "3825960",
            "problem": "您的任务是为一个在单轴拉伸下的小应变、率无关单晶塑性模型实现一个隐式应力更新，其中可能有两个晶体滑移系被激活。从第一性原理和核心定义出发，计算满足屈服和一致性条件的滑移增量。假设一个线性、各向同性的弹性响应和具有恒定临界分切应力的理想塑性。\n\n基本基础如下：\n\n- 小应变运动学将总应变分解为弹性和塑性部分，即 $\\,\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^{e} + \\boldsymbol{\\varepsilon}^{p}\\,$，其中塑性应变定义为 $\\,\\boldsymbol{\\varepsilon}^{p} = \\sum_{a=1}^{2} \\gamma_{a} \\boldsymbol{P}_{a}\\,$，此处 $\\,\\gamma_{a}\\,$ 是滑移系 $\\,a \\in \\{1,2\\}\\,$ 上的滑移量，$\\,\\boldsymbol{P}_{a} = \\mathrm{sym}(\\boldsymbol{s}_{a} \\otimes \\boldsymbol{m}_{a})\\,$ 是由单位滑移方向 $\\,\\boldsymbol{s}_{a}\\,$ 和单位滑移面法向 $\\,\\boldsymbol{m}_{a}\\,$ 构建的 Schmid 张量。\n\n- 线性弹性本构律为 $\\,\\boldsymbol{\\sigma} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}^{e})\\,\\boldsymbol{I} + 2 \\mu \\,\\boldsymbol{\\varepsilon}^{e}\\,$，其中 $\\,\\lambda\\,$ 和 $\\,\\mu\\,$ 是拉梅参数，$\\,\\mu = \\dfrac{E}{2(1+\\nu)}\\,$ 和 $\\,\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}\\,$，用杨氏模量 $\\,E\\,$ 和泊松比 $\\,\\nu\\,$ 表示。这里 $\\,\\boldsymbol{I}\\,$ 是单位张量，$\\,\\mathrm{tr}(\\cdot)\\,$ 表示迹，$\\,\\boldsymbol{\\sigma}\\,$ 是 Cauchy 应力。\n\n- 滑移系 $\\,a\\,$ 上的分切应力为 $\\,\\tau_{a} = \\boldsymbol{P}_{a} : \\boldsymbol{\\sigma}\\,$，其中 $\\,:\\,$ 表示双点积。\n\n- 每个滑移系的屈服函数为 $\\,f_{a} = |\\tau_{a}| - g \\le 0\\,$，其中 $\\,g  0\\,$ 为恒定的临界分切应力。\n\n- 率无关一致性条件 (Kuhn–Tucker 条件) 为 $\\,\\Delta \\gamma_{a} \\ge 0\\,$, $\\,f_{a} \\le 0\\,$ 和 $\\,\\Delta \\gamma_{a} \\, f_{a} = 0\\,$，且激活系上的流动方向与分切应力的符号一致。\n\n您必须在从初始状态 $\\,\\boldsymbol{\\varepsilon}^{p}_{n} = \\boldsymbol{0}\\,$ 开始的单个应变增量上执行一次隐式后向欧拉更新。应变增量是单轴的：$\\,\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(\\Delta \\varepsilon_{11}, 0, 0)\\,$。试探弹性应变为 $\\,\\boldsymbol{\\varepsilon}^{e,\\mathrm{tr}} = \\boldsymbol{\\varepsilon}_{n} + \\Delta \\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}^{p}_{n} = \\Delta \\boldsymbol{\\varepsilon}\\,$，试探应力为 $\\,\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}^{e,\\mathrm{tr}})\\,\\boldsymbol{I} + 2 \\mu \\,\\boldsymbol{\\varepsilon}^{e,\\mathrm{tr}}\\,$，试探分切应力为 $\\,\\tau_{a}^{\\mathrm{tr}} = \\boldsymbol{P}_{a} : \\boldsymbol{\\sigma}^{\\mathrm{tr}}\\,$。后向欧拉更新旨在求解 $\\,\\Delta \\gamma_{a}\\,$，使得更新后的应力 $\\,\\boldsymbol{\\sigma} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}^{e})\\,\\boldsymbol{I} + 2 \\mu \\,\\boldsymbol{\\varepsilon}^{e}\\,$（其中 $\\,\\boldsymbol{\\varepsilon}^{e} = \\boldsymbol{\\varepsilon}^{e,\\mathrm{tr}} - \\sum_{a} \\Delta \\gamma_{a} \\boldsymbol{P}_{a}\\,$）满足激活滑移系的屈服和一致性条件。更新必须强制 $\\,\\Delta \\gamma_{a} \\ge 0\\,$，并且对于激活系，$\\,|\\tau_{a}| = g\\,$，且 $\\,\\tau_{a}\\,$ 的符号与 $\\,\\mathrm{sign}(\\tau_{a}^{\\mathrm{tr}})\\,$ 匹配。\n\n实现一个算法，该算法：\n- 基于试探状态确定激活集。\n- 使用一个隐式一致性更新求解滑移增量 $\\,\\Delta \\gamma_{a}\\,$，该更新强制激活系上的屈服等式和 $\\,\\Delta \\gamma_{a}\\,$ 的非负性。\n- 确保更新后未激活系满足 $\\,|\\tau_{a}| \\le g\\,$。\n\n科学和数值要求：\n- 使用帕斯卡 (Pa) 作为 $\\,E\\,$ 的单位，$\\,\\nu\\,$ 是无量纲的，$\\,g\\,$ 的单位是帕斯卡 (Pa)，应变是无量纲的。角度不是必需的。\n- 所有矢量方向 $\\,\\boldsymbol{s}_{a}\\,$ 和平面法向 $\\,\\boldsymbol{m}_{a}\\,$ 必须是 $\\,\\mathbb{R}^{3}$ 中的单位矢量，并且在每个滑移系内是正交的，即 $\\,\\boldsymbol{s}_{a} \\cdot \\boldsymbol{m}_{a} = 0\\,$。\n- 对于每个测试用例，您的程序必须生成列表 $\\,[\\Delta \\gamma_{1}, \\Delta \\gamma_{2}]\\,$.\n\n测试套件：\n为以下四个参数集提供输出。每个测试用例指定为 $\\,(\\,E,\\,\\nu,\\,g,\\,\\boldsymbol{s}_{1},\\,\\boldsymbol{m}_{1},\\,\\boldsymbol{s}_{2},\\,\\boldsymbol{m}_{2},\\,\\Delta \\varepsilon_{11}\\,)\\,$。\n\n- 情况 $\\,A\\,$ (不屈服，两个滑移系均低于阈值)：\n  - $\\,E = 120 \\times 10^{9}\\,$ Pa, $\\,\\nu = 0.33\\,$, $\\,g = 50 \\times 10^{6}\\,$ Pa。\n  - 滑移系 $\\,1\\,$: $\\,\\boldsymbol{s}_{1} = \\dfrac{1}{\\sqrt{2}}[1,-1,0]^{\\top}\\,$, $\\,\\boldsymbol{m}_{1} = \\dfrac{1}{\\sqrt{3}}[1,1,1]^{\\top}\\,$。\n  - 滑移系 $\\,2\\,$: $\\,\\boldsymbol{s}_{2} = \\dfrac{1}{\\sqrt{2}}[1,0,-1]^{\\top}\\,$, $\\,\\boldsymbol{m}_{2} = \\dfrac{1}{\\sqrt{3}}[1,1,1]^{\\top}\\,$。\n  - $\\,\\Delta \\varepsilon_{11} = 1.0 \\times 10^{-3}\\,$。\n\n- 情况 $\\,B\\,$ (仅滑移系 $\\,1\\,$ 激活)：\n  - $\\,E = 120 \\times 10^{9}\\,$ Pa, $\\,\\nu = 0.33\\,$, $\\,g = 50 \\times 10^{6}\\,$ Pa。\n  - 滑移系 $\\,1\\,$: $\\,\\boldsymbol{s}_{1} = \\dfrac{1}{\\sqrt{2}}[1,-1,0]^{\\top}\\,$, $\\,\\boldsymbol{m}_{1} = \\dfrac{1}{\\sqrt{3}}[1,1,1]^{\\top}\\,$。\n  - 滑移系 $\\,2\\,$: $\\,\\boldsymbol{s}_{2} = [0,1,0]^{\\top}\\,$, $\\,\\boldsymbol{m}_{2} = [1,0,0]^{\\top}\\,$。\n  - $\\,\\Delta \\varepsilon_{11} = 1.5 \\times 10^{-3}\\,$。\n\n- 情况 $\\,C\\,$ (两个滑移系均激活)：\n  - $\\,E = 120 \\times 10^{9}\\,$ Pa, $\\,\\nu = 0.33\\,$, $\\,g = 50 \\times 10^{6}\\,$ Pa。\n  - 滑移系 $\\,1\\,$: $\\,\\boldsymbol{s}_{1} = \\dfrac{1}{\\sqrt{2}}[1,-1,0]^{\\top}\\,$, $\\,\\boldsymbol{m}_{1} = \\dfrac{1}{\\sqrt{3}}[1,1,1]^{\\top}\\,$。\n  - 滑移系 $\\,2\\,$: $\\,\\boldsymbol{s}_{2} = \\dfrac{1}{\\sqrt{2}}[1,0,-1]^{\\top}\\,$, $\\,\\boldsymbol{m}_{2} = \\dfrac{1}{\\sqrt{3}}[1,1,1]^{\\top}\\,$。\n  - $\\,\\Delta \\varepsilon_{11} = 2.0 \\times 10^{-3}\\,$。\n\n- 情况 $\\,D\\,$ (边界一致性，试探状态下两个共面滑移系恰好达到屈服)：\n  - $\\,E = 120 \\times 10^{9}\\,$ Pa, $\\,\\nu = 0.33\\,$, $\\,g = 50 \\times 10^{6}\\,$ Pa。\n  - 滑移系 $\\,1\\,$: $\\,\\boldsymbol{s}_{1} = \\dfrac{1}{\\sqrt{2}}[1,-1,0]^{\\top}\\,$, $\\,\\boldsymbol{m}_{1} = \\dfrac{1}{\\sqrt{3}}[1,1,1]^{\\top}\\,$。\n  - 滑移系 $\\,2\\,$: $\\,\\boldsymbol{s}_{2} = \\dfrac{1}{\\sqrt{2}}[1,0,-1]^{\\top}\\,$, $\\,\\boldsymbol{m}_{2} = \\dfrac{1}{\\sqrt{3}}[1,1,1]^{\\top}\\,$。\n  - $\\,\\Delta \\varepsilon_{11} = 1.356 \\times 10^{-3}\\,$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，用方括号括起来，其中每个元素是相应测试用例的滑移增量列表，顺序与上面相同。例如：$\\,[[\\Delta \\gamma_{1}^{A},\\Delta \\gamma_{2}^{A}],[\\Delta \\gamma_{1}^{B},\\Delta \\gamma_{2}^{B}],\\ldots]\\,$。所有滑移增量必须报告为无量纲浮点数。请确保您的实现和结果具有科学真实性和内部一致性。不允许外部输入；所有常量必须在您的程序中定义。",
            "solution": "该问题要求为一个承受单轴拉伸的率无关、小应变单晶塑性模型实现一个隐式应力更新算法。该模型考虑了两个滑移系，并假定线性各向同性弹性和理想塑性。解决方案从第一性原理推导，并被表述为一个标准的回映算法。\n\n首先，我们建立基本的运动学和本构关系。总应变张量 $\\boldsymbol{\\varepsilon}$ 被加法分解为一个弹性部分 $\\boldsymbol{\\varepsilon}^{e}$ 和一个塑性部分 $\\boldsymbol{\\varepsilon}^{p}$：\n$$\n\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^{e} + \\boldsymbol{\\varepsilon}^{p}\n$$\n塑性应变是所有激活滑移系上剪切的总和。对于所考虑的两个滑移系，这表示为：\n$$\n\\boldsymbol{\\varepsilon}^{p} = \\sum_{a=1}^{2} \\gamma_{a} \\boldsymbol{P}_{a}\n$$\n其中 $\\gamma_{a}$ 是滑移系 $a$ 上的塑性滑移量，$\\boldsymbol{P}_{a}$ 是对称的 Schmid 张量，由滑移方向单位矢量 $\\boldsymbol{s}_{a}$ 和滑移面法向单位矢量 $\\boldsymbol{m}_{a}$ 定义：\n$$\n\\boldsymbol{P}_{a} = \\frac{1}{2} (\\boldsymbol{s}_{a} \\otimes \\boldsymbol{m}_{a} + \\boldsymbol{m}_{a} \\otimes \\boldsymbol{s}_{a})\n$$\n问题陈述指出，对于每个滑移系，$\\boldsymbol{s}_{a} \\cdot \\boldsymbol{m}_{a} = 0$，这意味着 Schmid 张量是无迹的，即 $\\mathrm{tr}(\\boldsymbol{P}_{a}) = 0$。\n\n应力-应变关系由线性各向同性弹性本构律（胡克定律）决定：\n$$\n\\boldsymbol{\\sigma} = \\mathbb{C} : \\boldsymbol{\\varepsilon}^{e} = \\lambda \\mathrm{tr}(\\boldsymbol{\\varepsilon}^{e})\\boldsymbol{I} + 2 \\mu \\boldsymbol{\\varepsilon}^{e}\n$$\n其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\mathbb{C}$ 是四阶弹性张量，$\\boldsymbol{I}$ 是二阶单位张量，$\\lambda$ 和 $\\mu$ 是拉梅参数。它们通过杨氏模量 $E$ 和泊松比 $\\nu$ 相关联：\n$$\n\\mu = \\frac{E}{2(1+\\nu)}, \\quad \\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}\n$$\n当滑移系上的分切应力 $\\tau_{a}$ 达到临界值 $g$ 时，塑性滑移开始。分切应力是 Cauchy 应力在滑移系上的投影：\n$$\n\\tau_{a} = \\boldsymbol{\\sigma} : \\boldsymbol{P}_{a}\n$$\n每个滑移系的屈服条件由 Schmid 型屈服函数 $f_a$ 给出：\n$$\nf_{a} = |\\tau_{a}| - g \\le 0\n$$\n对于率无关材料，塑性滑移的演化由离散时间/载荷增量 $\\Delta t$ 上的 Kuhn-Tucker 一致性条件决定：\n$$\n\\Delta \\gamma_{a} \\ge 0, \\quad f_{a} \\le 0, \\quad \\Delta \\gamma_{a} f_{a} = 0\n$$\n其中 $\\Delta \\gamma_a$ 是滑移增量。这些条件表明，塑性流动（$\\Delta \\gamma_a  0$）仅当滑移系处于屈服状态（$f_a = 0$）时才能发生；如果滑移系低于屈服状态（$f_a  0$），则不发生塑性流动（$\\Delta \\gamma_a = 0$）。\n\n该问题使用隐式后向欧拉时间积分方案求解，该方案对于此类问题在数值上是稳健的。该算法包括一个弹性预测步和一个塑性修正步，也称为回映算法。\n\n假设增量开始时（步骤 $n$）的状态是已知的。问题指定了一个初始状态，塑性应变为零，即 $\\boldsymbol{\\varepsilon}^{p}_{n} = \\boldsymbol{0}$。施加一个总应变增量 $\\Delta \\boldsymbol{\\varepsilon}$。\n\n1.  **弹性预测步**：假设整个应变增量是弹性的。计算试探状态：\n    - 试探弹性应变：$\\boldsymbol{\\varepsilon}^{e,\\mathrm{tr}} = \\boldsymbol{\\varepsilon}_{n}^{e} + \\Delta \\boldsymbol{\\varepsilon} = \\Delta \\boldsymbol{\\varepsilon}$（因为我们从一个无应力状态开始，其中 $\\boldsymbol{\\varepsilon}_{n}^{e}=\\boldsymbol{0}$）。\n    - 试探应力：$\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\mathbb{C} : \\boldsymbol{\\varepsilon}^{e,\\mathrm{tr}}$。\n    - 试探分切应力：$\\tau_{a}^{\\mathrm{tr}} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} : \\boldsymbol{P}_{a}$，对于 $a \\in \\{1, 2\\}$。\n\n2.  **屈服检查**：检查试探状态是否违反任何滑移系的屈服条件。\n    - 如果对于所有 $a$，都有 $|\\tau_{a}^{\\mathrm{tr}}| \\le g$，则试探状态是容许的。该步骤是纯弹性的。最终状态即为试探状态，滑移增量为零：$\\Delta \\gamma_{1} = 0$, $\\Delta \\gamma_{2} = 0$。\n    - 如果至少有一个滑移系 $a$ 满足 $|\\tau_{a}^{\\mathrm{tr}}|  g$，则试探状态是不可容许的。必须发生塑性变形，以将应力状态拉回到屈服面上。这需要进行塑性修正步。\n\n3.  **塑性修正步（回映算法）**：我们需要找到滑移增量 $\\Delta \\gamma_{a} \\ge 0$，使得最终应力 $\\boldsymbol{\\sigma}_{n+1}$ 满足一致性条件。增量结束时（步骤 $n+1$）的更新应力为：\n    $$\n    \\boldsymbol{\\sigma}_{n+1} = \\mathbb{C} : \\boldsymbol{\\varepsilon}^{e}_{n+1} = \\mathbb{C} : (\\boldsymbol{\\varepsilon}^{e, \\mathrm{tr}} - \\sum_{b=1}^{2} \\Delta \\gamma_{b} \\boldsymbol{P}_{b}) = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\sum_{b=1}^{2} \\Delta \\gamma_{b} (\\mathbb{C} : \\boldsymbol{P}_{b})\n    $$\n    对于各向同性弹性和无迹的 Schmid 张量（$\\mathrm{tr}(\\boldsymbol{P}_b)=0$），我们有 $\\mathbb{C}:\\boldsymbol{P}_b = 2\\mu\\boldsymbol{P}_b$。表达式简化为：\n    $$\n    \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2 \\mu \\sum_{b=1}^{2} \\Delta \\gamma_{b} \\boldsymbol{P}_{b}\n    $$\n    于是，任何滑移系 $a$ 上的分切应力为：\n    $$\n    \\tau_{a, n+1} = \\boldsymbol{\\sigma}_{n+1} : \\boldsymbol{P}_{a} = \\tau_{a}^{\\mathrm{tr}} - \\sum_{b=1}^{2} (2 \\mu \\, \\boldsymbol{P}_{a} : \\boldsymbol{P}_{b}) \\Delta \\gamma_{b}\n    $$\n    我们定义一个相互作用矩阵 $\\boldsymbol{H}$，其分量为 $H_{ab} = 2 \\mu (\\boldsymbol{P}_{a} : \\boldsymbol{P}_{b})$。注意 $H_{aa} = 2 \\mu (\\boldsymbol{P}_a : \\boldsymbol{P}_a) = 2 \\mu (\\frac{1}{2}) = \\mu$。方程组变为：\n    $$\n    \\tau_{a, n+1} = \\tau_{a}^{\\mathrm{tr}} - \\sum_{b=1}^{2} H_{ab} \\Delta \\gamma_{b}\n    $$\n    对于每个激活的滑移系 $a$（即我们寻求 $\\Delta \\gamma_a  0$ 的滑移系），最终应力必须位于屈服面上，因此 $|\\tau_{a, n+1}| = g$。塑性流动的方向沿着分切应力的方向，因此我们强制 $\\tau_{a, n+1} = g \\cdot \\mathrm{sign}(\\tau_{a}^{\\mathrm{tr}})$。这为激活滑移系集合 $\\mathcal{A}$ 中的未知滑移增量 $\\Delta \\gamma_b$ 导出一个线性方程组：\n    $$\n    \\sum_{b \\in \\mathcal{A}} H_{ab} \\Delta \\gamma_{b} = \\tau_{a}^{\\mathrm{tr}} - g \\cdot \\mathrm{sign}(\\tau_{a}^{\\mathrm{tr}}) = |\\tau_{a}^{\\mathrm{tr}}| - g \\quad \\forall a \\in \\mathcal{A}\n    $$\n    找到正确的激活集和相应滑移的算法如下：\n    - **a)** 假设所有满足 $|\\tau_{a}^{\\mathrm{tr}}|  g$ 的滑移系都被激活。构建并求解关于 $[\\Delta \\gamma_1, \\Delta \\gamma_2]^\\top$ 的线性系统。\n    - **b)** 检查一致性：\n        - 如果 $\\Delta \\gamma_1 \\ge 0$ 且 $\\Delta \\gamma_2 \\ge 0$，则接受该解。\n        - 如果一个增量为负（例如 $\\Delta \\gamma_2  0$），则假设滑移系 2 被激活是错误的。必须重新求解系统，假设只有滑移系 1 被激活。问题简化为单个方程：$H_{11} \\Delta \\gamma_1 = |\\tau_1^{\\mathrm{tr}}| - g$，这给出 $\\Delta \\gamma_1 = (|\\tau_1^{\\mathrm{tr}}| - g) / \\mu$ 和 $\\Delta \\gamma_2 = 0$。\n    - **c)** 在找到具有非负滑移的候选解后，我们必须验证任何被假定为非激活的滑移系（例如滑移系 $k$）确实保持在屈服之下：$|\\tau_{k,n+1}| \\le g$。如果此条件被违反，则该滑移系也必须被包含在激活集中，算法返回到步骤 (a) 并使用一个扩展的激活集。对于双滑移系问题，这意味着如果单滑移假设导致另一个滑移系屈服，则需要一个双滑移解。\n\n这个关于激活集的迭代过程会收敛到唯一的正确解。实现将系统地检查以下情况：无滑移、仅滑移系1滑移、仅滑移系2滑移以及双滑移，确保最终满足所有 Kuhn-Tucker 条件。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the single-crystal plasticity problem for all test cases.\n    \"\"\"\n\n    def compute_stress_update(E, nu, g, s1, m1, s2, m2, delta_eps11):\n        \"\"\"\n        Computes the slip increments for a single-crystal plasticity model.\n\n        This function implements an implicit backward-Euler return-mapping algorithm\n        for a small-strain, rate-independent plasticity model with two slip systems.\n        \"\"\"\n        \n        # 1. Calculate elastic constants\n        mu = E / (2 * (1 + nu))\n        lambda_lame = E * nu / ((1 + nu) * (1 - 2 * nu))\n\n        # 2. Construct tensors\n        # Strain increment tensor\n        delta_eps = np.zeros((3, 3))\n        delta_eps[0, 0] = delta_eps11\n\n        # Schmid tensors for the two slip systems\n        s1, m1 = np.array(s1), np.array(m1)\n        s2, m2 = np.array(s2), np.array(m2)\n        P1 = 0.5 * (np.outer(s1, m1) + np.outer(m1, s1))\n        P2 = 0.5 * (np.outer(s2, m2) + np.outer(m2, s2))\n        \n        # 3. Trial Step\n        # Trial stress\n        tr_delta_eps = np.trace(delta_eps)\n        sigma_tr = lambda_lame * tr_delta_eps * np.identity(3) + 2 * mu * delta_eps\n\n        # Trial resolved shear stresses\n        tau1_tr = np.sum(sigma_tr * P1)\n        tau2_tr = np.sum(sigma_tr * P2)\n        \n        # Initialize slip increments\n        d_gamma = np.zeros(2)\n\n        # 4. Yield Check and Return Mapping\n        is_active1 = abs(tau1_tr) > g\n        is_active2 = abs(tau2_tr) > g\n\n        if not is_active1 and not is_active2:\n            # Fully elastic step\n            return d_gamma.tolist()\n\n        # Build interaction matrix H\n        H = np.zeros((2, 2))\n        H[0, 0] = mu\n        H[1, 1] = mu\n        H[0, 1] = H[1, 0] = 2 * mu * np.sum(P1 * P2)\n\n        if is_active1 and not is_active2:\n            # Case: Only system 1 is potentially active\n            d_gamma1 = (abs(tau1_tr) - g) / H[0, 0]\n            \n            # Consistency check for system 2\n            tau2_final = tau2_tr - H[1, 0] * d_gamma1\n            if abs(tau2_final) = g:\n                d_gamma[0] = d_gamma1\n                return d_gamma.tolist()\n            else:\n                # Both systems become active, proceed to two-slip case\n                is_active2 = True\n\n        if not is_active1 and is_active2:\n            # Case: Only system 2 is potentially active\n            d_gamma2 = (abs(tau2_tr) - g) / H[1, 1]\n\n            # Consistency check for system 1\n            tau1_final = tau1_tr - H[0, 1] * d_gamma2\n            if abs(tau1_final) = g:\n                d_gamma[1] = d_gamma2\n                return d_gamma.tolist()\n            else:\n                # Both systems become active, proceed to two-slip case\n                is_active1 = True\n\n        if is_active1 and is_active2:\n            # Case: Both systems are potentially active\n            rhs = np.array([abs(tau1_tr) - g, abs(tau2_tr) - g])\n            \n            # Check if H is singular\n            if abs(np.linalg.det(H))  1e-12 * (mu**2):\n                 # This case of linearly dependent slip systems requires special handling\n                 # Not expected for the given test cases.\n                 # If tau1_tr/H[0,1] and tau2_tr/H[1,1] are consistent, solve one, otherwise issue.\n                 # Simplified handling: if H is singular, likely one system dominates.\n                 if rhs[0]/H[0,0] > rhs[1]/H[1,1]: # A simplification\n                    d_gamma[0] = rhs[0] / H[0,0]\n                 else:\n                    d_gamma[1] = rhs[1] / H[1,1]\n                 return d_gamma.tolist()\n            \n            d_gamma_sol = np.linalg.solve(H, rhs)\n\n            if d_gamma_sol[0] >= 0 and d_gamma_sol[1] >= 0:\n                # Both slips are positive, solution is valid\n                return d_gamma_sol.tolist()\n            elif d_gamma_sol[0]  0:\n                # System 1 is not active, resolve for system 2 only\n                d_gamma[1] = (abs(tau2_tr) - g) / H[1, 1]\n                return d_gamma.tolist()\n            else: # d_gamma_sol[1]  0\n                # System 2 is not active, resolve for system 1 only\n                d_gamma[0] = (abs(tau1_tr) - g) / H[0, 0]\n                return d_gamma.tolist()\n\n        return d_gamma.tolist() # Fallback, should not be reached\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case A (no yield)\n        (120e9, 0.33, 50e6, \n         (1/np.sqrt(2)) * np.array([1, -1, 0]), \n         (1/np.sqrt(3)) * np.array([1, 1, 1]),\n         (1/np.sqrt(2)) * np.array([1, 0, -1]), \n         (1/np.sqrt(3)) * np.array([1, 1, 1]),\n         1.0e-3),\n        # Case B (one system active)\n        (120e9, 0.33, 50e6, \n         (1/np.sqrt(2)) * np.array([1, -1, 0]), \n         (1/np.sqrt(3)) * np.array([1, 1, 1]),\n         np.array([0, 1, 0]), \n         np.array([1, 0, 0]),\n         1.5e-3),\n        # Case C (both systems active)\n        (120e9, 0.33, 50e6, \n         (1/np.sqrt(2)) * np.array([1, -1, 0]), \n         (1/np.sqrt(3)) * np.array([1, 1, 1]),\n         (1/np.sqrt(2)) * np.array([1, 0, -1]), \n         (1/np.sqrt(3)) * np.array([1, 1, 1]),\n         2.0e-3),\n        # Case D (boundary consistency)\n        (120e9, 0.33, 50e6, \n         (1/np.sqrt(2)) * np.array([1, -1, 0]), \n         (1/np.sqrt(3)) * np.array([1, 1, 1]),\n         (1/np.sqrt(2)) * np.array([1, 0, -1]), \n         (1/np.sqrt(3)) * np.array([1, 1, 1]),\n         1.356e-3)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_stress_update(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "多尺度建模的核心挑战在于如何在不同尺度之间建立联系，而代表性体积单元（RVE）的概念为此提供了理论基础。本练习将指导你通过一个完整的计算流程，为具有随机微观结构的材料确定RVE尺寸。你将学习如何生成统计上真实的微观结构，计算其均质化响应，并分析响应的统计方差随体积变化的规律，这是连接微观材料物理与宏观工程应用的关键实践。",
            "id": "3825950",
            "problem": "您的任务是构建一个计算程序，通过量化均匀化响应的方差如何随着采样体积尺寸的增加而减小，来确定塑性代表性体积单元（RVE）的尺寸。此过程使用多个微观结构实现。背景设定为一个在单轴应变下的二维域，其具有标量弹塑性行为，且局部塑性屈服由基于位错的定律控制。基本原理包括线性弹性的胡克定律、线性各向同性硬化法则、泰勒位错强化关系以及标准的均匀化定义。\n\n从以下原理和定义开始：\n- 胡克定律（线性弹性，一维）：对于局部应变 $\\,\\varepsilon\\,$ 和局部弹性模量 $\\,E\\,$，局部应力 $\\,\\sigma\\,$ 为 $\\,\\sigma = E\\,\\varepsilon\\,$，直到发生屈服。\n- 线性各向同性硬化：屈服后，局部应力演变为 $\\,\\sigma = \\sigma_y + H\\left(\\varepsilon - \\sigma_y / E\\right)\\,$，其中 $\\,H\\,$ 是恒定的塑性切线模量，$\\,\\sigma_y\\,$ 是局部屈服应力。\n- 泰勒位错强化关系：局部屈服应力为 $\\,\\sigma_y = \\alpha\\,G\\,b\\,\\sqrt{\\rho}\\,$，其中 $\\,\\alpha\\,$ 是一个无量纲常数，$\\,G\\,$ 是剪切模量，$\\,b\\,$ 是伯格斯矢量的大小，$\\,\\rho\\,$ 是局部位错密度。\n- Voigt 均匀化（均匀应变假设）：在施加的宏观应变 $\\,\\bar{\\varepsilon}\\,$ 下，宏观应力 $\\,\\bar{\\sigma}\\,$ 是局部应力的空间平均值，即 $\\,\\bar{\\sigma} = \\langle \\sigma \\rangle\\,$。\n- 代表性体积单元（RVE）：使得在独立微观结构实现上，均匀化响应的变异系数低于预设容差 $\\,\\epsilon_{\\mathrm{tol}}\\,$ 的最小域尺寸 $\\,L\\,$，即 $\\,\\mathrm{COV}(L) = s(L)/m(L) \\le \\epsilon_{\\mathrm{tol}}\\,$，其中 $\\,m(L)\\,$ 和 $\\,s(L)\\,$ 是在给定域尺寸 $\\,L\\,$ 下，跨多个实现的 $\\,\\bar{\\sigma}\\,$ 的样本均值和样本标准差（自由度差 $\\,\\mathrm{ddof}=1\\,$）。\n\n微观结构模型：\n- 局部位错密度 $\\,\\rho(\\mathbf{x})\\,$ 被建模为一个平稳对数正态随机场，该随机场源自一个相关高斯场 $\\,g(\\mathbf{x})\\sim\\mathcal{N}(0,1)\\,$，其高斯协方差的相关长度为 $\\,\\ell\\,$。令 $\\,\\rho(\\mathbf{x}) = \\rho_0\\,\\exp\\!\\left(\\sigma_g\\,g(\\mathbf{x}) - \\tfrac{1}{2}\\sigma_g^2 \\right)\\,$，从而使得 $\\,\\mathbb{E}[\\rho] = \\rho_0\\,$。该相关高斯场是通过对白噪声进行谱滤波生成的，其中在波数空间中使用宽度为 $\\,\\ell\\,$ 的高斯滤波器。\n\n在施加的宏观应变 $\\,\\bar{\\varepsilon}\\,$ 下的局部本构响应：\n- 对于每个具有局部 $\\,\\sigma_y\\,$ 的单元，计算 $\\,\\varepsilon_y = \\sigma_y / E\\,$。然后，局部应力为\n$$\n\\sigma(\\mathbf{x};\\bar{\\varepsilon}) = \n\\begin{cases}\nE\\,\\bar{\\varepsilon},  \\bar{\\varepsilon} \\le \\varepsilon_y(\\mathbf{x}),\\\\\n\\sigma_y(\\mathbf{x}) + H\\big(\\bar{\\varepsilon} - \\varepsilon_y(\\mathbf{x})\\big),  \\bar{\\varepsilon}  \\varepsilon_y(\\mathbf{x}).\n\\end{cases}\n$$\n宏观应力是空间平均值 $\\,\\bar{\\sigma} = \\langle \\sigma(\\mathbf{x};\\bar{\\varepsilon}) \\rangle\\,$。\n\n计算程序：\n- 对于每个候选域尺寸 $\\,L\\,$（边长为L的正方形域），将其均匀离散化为网格间距为 $\\,\\Delta x\\,$ 的网格，因此每边有 $\\,N = \\lfloor L / \\Delta x \\rfloor\\,$ 个单元。对于每个实现：\n    1. 通过将其离散傅里叶变换乘以 $\\,\\exp\\!\\big(-\\tfrac{1}{2}\\ell^2\\,\\|\\mathbf{k}\\|^2\\big)\\,$，使用谱滤波方法对白噪声进行处理，以生成一个相关高斯场 $\\,g(\\mathbf{x})\\,$。其中 $\\,\\mathbf{k}\\,$ 是波数矢量，$\\,\\ell\\,$ 的长度单位与 $\\,\\Delta x\\,$ 相同。\n    2. 通过上述的对数正态映射构建位错密度 $\\,\\rho(\\mathbf{x})\\,$。\n    3. 计算 $\\,\\sigma_y(\\mathbf{x}) = \\alpha\\,G\\,b\\,\\sqrt{\\rho(\\mathbf{x})}\\,$.\n    4. 使用带有 $\\,E\\,$ 和 $\\,H\\,$ 的分段线性法则，在 $\\,\\bar{\\varepsilon}\\,$ 下平均局部应力以计算 $\\,\\bar{\\sigma}\\,$。\n- 在 $\\,n_{\\mathrm{real}}\\,$ 个实现上，计算样本均值 $\\,m(L)\\,$ 和样本标准差 $\\,s(L)\\,$，并构成 $\\,\\mathrm{COV}(L) = s(L)/m(L)\\,$。\n- RVE 尺寸是所提供的候选列表中满足 $\\,\\mathrm{COV}(L) \\le \\epsilon_{\\mathrm{tol}}\\,$ 的最小 $\\,L\\,$。如果没有候选尺寸满足该准则，则返回 -1。\n\n物理单位和输出：\n- 内部应力计算使用帕斯卡（Pa），但报告的 RVE 尺寸单位为微米（$\\mu$m）。应变 $\\,\\bar{\\varepsilon}\\,$ 是无量纲的。伯格斯矢量 $\\,b\\,$ 必须以纳米（nm）为单位提供，并转换为米（m）。剪切模量 $\\,G\\,$、弹性模量 $\\,E\\,$ 和硬化模量 $\\,H\\,$ 以吉帕斯卡（GPa）为单位提供，并在计算时转换为帕斯卡（Pa）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\text{结果1},\\text{结果2},\\text{结果3}]$。每个结果必须是所选的 RVE 尺寸（以 $\\mu$m 为单位的浮点数），如果没有任何候选尺寸满足容差，则为整数 -1。\n\n测试套件：\n评估以下四个测试案例。每个测试案例以指定单位的有序参数元组形式给出。程序必须嵌入这些参数并产生所需的输出。\n\n- 测试案例 1（典型非均匀性，中等相关性）：\n    - $\\,\\Delta x = 1.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 2.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.5\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 1.0\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - 候选尺寸 $\\,L \\in [5.0,\\,10.0,\\,20.0,\\,40.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 20\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.02\\,$,\n    - 随机种子 $\\,s = 12345\\,$.\n\n- 测试案例 2（更强的非均匀性，大相关性）：\n    - $\\,\\Delta x = 2.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 10.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.8\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 2.0\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - 候选尺寸 $\\,L \\in [20.0,\\,40.0,\\,80.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 30\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.03\\,$,\n    - 随机种子 $\\,s = 2468\\,$.\n\n- 测试案例 3（严格的容差，有限的实现；可能无法满足准则）：\n    - $\\,\\Delta x = 1.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 5.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.9\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 1.5\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - 候选尺寸 $\\,L \\in [5.0,\\,10.0,\\,15.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 10\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.01\\,$,\n    - 随机种子 $\\,s = 13579\\,$.\n\n- 测试案例 4（弱非均匀性，短相关性）：\n    - $\\,\\Delta x = 0.5\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 0.5\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.4\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 1.0\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - 候选尺寸 $\\,L \\in [2.0,\\,4.0,\\,8.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 25\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.02\\,$,\n    - 随机种子 $\\,s = 9876\\,$.\n\n您的程序必须精确实现上述程序，并在单行输出中返回四个测试案例中各自选定的RVE尺寸，格式为 $[r_1,r_2,r_3,r_4]$，其中每个 $\\,r_i\\,$ 是一个以 $\\mu$m 为单位的浮点数，如果没有任何候选尺寸满足准则，则为整数 -1。",
            "solution": "该问题是有效的，因为它基于连续介质力学和计算材料科学的原理，具有科学依据；它也是适定的，有明确的目标和一套完整的参数，并使用客观、正式的语言。确定代表性体积单元（RVE）尺寸的程序是多尺度建模中的一种标准方法。\n\n该解决方案是通过执行一个计算程序构建的，该程序模拟空间非均匀材料的力学响应，并分析其均匀化属性的统计收敛性。核心目标是找到最小的域尺寸，即RVE，在该尺寸下材料的有效响应在统计上具有代表性。这是通过要求在多个独立的微观结构实现中，均匀化应力的变异系数（COV）低于预设容差 $\\epsilon_{\\mathrm{tol}}$ 来量化的。\n\n该程序的基本步骤如下：\n\n1.  **材料非均匀性建模：** 非均匀性的来源是局部塑性屈服应力 $\\sigma_y(\\mathbf{x})$ 的空间变化。这种变化在物理上源于晶体缺陷（特别是位错）的非均匀分布。局部屈服应力由泰勒位错强化关系决定：\n    $$\n    \\sigma_y(\\mathbf{x}) = \\alpha G b \\sqrt{\\rho(\\mathbf{x})}\n    $$\n    其中 $\\alpha$ 是一个几何常数， $G$ 是剪切模量， $b$ 是伯格斯矢量的大小，而 $\\rho(\\mathbf{x})$ 是局部位错密度。位错密度本身被建模为一个平稳对数正态随机场。这种选择确保 $\\rho(\\mathbf{x})$ 始终为正值。使用了特定的形式：\n    $$\n    \\rho(\\mathbf{x}) = \\rho_0 \\exp\\left(\\sigma_g g(\\mathbf{x}) - \\frac{1}{2}\\sigma_g^2\\right)\n    $$\n    这里，$g(\\mathbf{x})$ 是一个标准化的、相关的零均值单位方差高斯随机场，$g(\\mathbf{x}) \\sim \\mathcal{N}(0,1)$。参数 $\\sigma_g$ 控制波动的幅度，表达式的形式被选择以使位错密度的期望值为 $\\mathbb{E}[\\rho] = \\rho_0$。\n\n2.  **生成相关随机场：** 空间相关的 高斯场 $g(\\mathbf{x})$ 是使用谱方法在数值上生成的。这种标准技术涉及在傅里叶（波数）域中对白噪声进行滤波。\n    - 在空间域中生成一个从标准正态分布中抽取的、不相关的随机数网格。这代表白噪声。\n    - 使用二维快速傅里叶变换（FFT）将该网格转换到波数域。\n    - 在此域中，应用一个乘性高斯滤波器：\n      $$\n      F(\\mathbf{k}) = \\exp\\left(-\\frac{1}{2}\\ell^2 \\|\\mathbf{k}\\|^2\\right)\n      $$\n      其中 $\\mathbf{k}$ 是波数矢量，$\\ell$ 是相关长度，它决定了微观结构特征的典型尺寸。\n    - 使用逆快速傅里叶变换将滤波后的场转换回空间域。取结果的实部。\n    - 为确保该场正确地表示 $g(\\mathbf{x}) \\sim \\mathcal{N}(0,1)$ 的一个实现，通过减去样本均值并除以样本标准差来对其值进行经验标准化。\n\n3.  **本构响应与均匀化：** 材料的整体行为是通过假设一个均匀应变场（Voigt 均匀化）来确定的，即域中的每个点都承受相同的宏观应变 $\\bar{\\varepsilon}$。然后，基于分段线性本构律计算局部应力 $\\sigma(\\mathbf{x})$。\n    - 首先，找到局部弹性应变极限：$\\varepsilon_y(\\mathbf{x}) = \\sigma_y(\\mathbf{x}) / E$，其中 $E$ 是弹性模量。\n    - 如果施加的应变 $\\bar{\\varepsilon}$ 小于或等于局部屈服应变，则响应是纯弹性的（胡克定律）：$\\sigma(\\mathbf{x}) = E \\bar{\\varepsilon}$。\n    - 如果施加的应变超过局部屈服应变，该点的材料会发生塑性变形，应力由线性各向同性硬化法则给出：$\\sigma(\\mathbf{x}) = \\sigma_y(\\mathbf{x}) + H(\\bar{\\varepsilon} - \\varepsilon_y(\\mathbf{x}))$，其中 $H$ 是塑性切线模量。\n    - 宏观应力 $\\bar{\\sigma}$ 是局部应力场的体积平均值：\n      $$\n      \\bar{\\sigma} = \\langle \\sigma(\\mathbf{x}; \\bar{\\varepsilon}) \\rangle = \\frac{1}{V} \\int_V \\sigma(\\mathbf{x}; \\bar{\\varepsilon}) \\, dV\n      $$\n      对于离散网格，该积分变为简单的算术平均值。\n\n4.  **通过统计分析确定RVE：** RVE尺寸是通过评估 $\\bar{\\sigma}$ 作为域尺寸 $L$ 的函数的统计稳定性来确定的。\n    - 对于给定列表中的每个候选尺寸 $L$，将域离散化为 $N \\times N$ 个单元的网格，其中 $N = \\lfloor L / \\Delta x \\rfloor$ 且 $\\Delta x$ 是固定的网格间距。\n    - 生成一组 $n_{\\mathrm{real}}$ 个独立的微观结构实现。对于每个实现，按上述方法计算相应的宏观应力 $\\bar{\\sigma}$。\n    - 这为域尺寸 $L$ 提供了一个包含 $n_{\\mathrm{real}}$ 个 $\\bar{\\sigma}$ 值的样本。计算样本均值 $m(L)$ 和样本标准差 $s(L)$（使用除数 $n_{\\mathrm{real}}-1$，或 $\\mathrm{ddof}=1$）。\n    - 计算变异系数：$\\mathrm{COV}(L) = s(L)/m(L)$。\n    - RVE尺寸被确定为列表中满足 $\\mathrm{COV}(L) \\le \\epsilon_{\\mathrm{tol}}$ 的最小候选尺寸 $L$。如果没有候选尺寸满足此准则，则结论是在测试范围内未达到RVE尺寸。\n\n所有带单位的物理量（模量、长度）在计算前都被转换为一致的国际单位制（SI）基本单位系统（帕斯卡、米）以确保正确性。最终报告的RVE尺寸被转换回指定的单位微米。为每个测试案例使用固定的随机种子可确保结果的计算可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_single_realization_stress(L, dx, ell, sigma_g, rho_0, alpha, G, b, E, H, bar_epsilon, rng):\n    \"\"\"\n    Computes the homogenized stress for a single microstructure realization.\n    All length units are handled in micrometers for grid setup and passed as SI for calculation.\n    All stress/modulus units are handled in GPa and passed as SI for calculation.\n    \"\"\"\n    # 1. Unit conversions to base SI\n    L_m = L * 1e-6\n    dx_m = dx * 1e-6\n    ell_m = ell * 1e-6\n    G_pa = G * 1e9\n    b_m = b * 1e-9\n    E_pa = E * 1e9\n    H_pa = H * 1e9\n\n    # 2. Grid setup\n    N = int(np.floor(L / dx))\n    if N == 0:\n        return np.nan\n\n    # 3. Generate correlated Gaussian random field g(x)\n    # 3a. Wavenumber grid\n    freq = np.fft.fftfreq(N, d=dx_m)  # Frequencies in cycles/meter\n    kx_grid, ky_grid = np.meshgrid(freq, freq)\n    k_grid_sq = (2 * np.pi * kx_grid)**2 + (2 * np.pi * ky_grid)**2\n\n    # 3b. Gaussian filter in Fourier space\n    gaussian_filter = np.exp(-0.5 * (ell_m**2) * k_grid_sq)\n    \n    # 3c. Generate field from white noise\n    white_noise = rng.standard_normal(size=(N, N))\n    fft_white_noise = np.fft.fft2(white_noise)\n    \n    fft_filtered = fft_white_noise * gaussian_filter\n    g_field_raw = np.fft.ifft2(fft_filtered).real\n\n    # 3d. Normalize the field to have zero mean and unit variance\n    g_field_mean = np.mean(g_field_raw)\n    g_field_std = np.std(g_field_raw)\n    if g_field_std  1e-15:\n        g_field = np.zeros((N, N))\n    else:\n        g_field = (g_field_raw - g_field_mean) / g_field_std\n\n    # 4. Construct dislocation density field rho(x) via lognormal mapping\n    rho_field = rho_0 * np.exp(sigma_g * g_field - 0.5 * sigma_g**2)\n\n    # 5. Compute local yield stress field sigma_y(x) using Taylor relation\n    sigma_y_field = alpha * G_pa * b_m * np.sqrt(rho_field)\n\n    # 6. Compute local stress sigma(x) under imposed strain bar_epsilon\n    epsilon_y_field = sigma_y_field / E_pa\n    \n    sigma_field = np.where(bar_epsilon = epsilon_y_field,\n                           E_pa * bar_epsilon,\n                           sigma_y_field + H_pa * (bar_epsilon - epsilon_y_field))\n\n    # 7. Compute homogenized stress (Voigt average)\n    bar_sigma = np.mean(sigma_field)\n    \n    return bar_sigma\n\ndef find_rve_size(params):\n    \"\"\"\n    Finds the RVE size for a single test case by iterating through candidate sizes.\n    \"\"\"\n    (dx, ell, sigma_g, rho_0, alpha, G, b, E, H, \n     bar_epsilon, L_candidates, n_real, epsilon_tol, seed) = params\n    \n    rng = np.random.default_rng(seed)\n\n    for L in L_candidates:\n        homogenized_stresses = []\n        for _ in range(n_real):\n            bar_sigma = compute_single_realization_stress(\n                L, dx, ell, sigma_g, rho_0, alpha, G, b, E, H, bar_epsilon, rng\n            )\n            homogenized_stresses.append(bar_sigma)\n        \n        homogenized_stresses = np.array(homogenized_stresses)\n        \n        if np.isnan(homogenized_stresses).any():\n            continue\n            \n        # Compute sample mean and sample standard deviation (ddof=1)\n        m_L = np.mean(homogenized_stresses)\n        s_L = np.std(homogenized_stresses, ddof=1)\n        \n        cov_L = s_L / m_L if np.abs(m_L) > 1e-9 else np.inf\n        \n        if cov_L = epsilon_tol:\n            return float(L)\n            \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the RVE analysis, and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'dx': 1.0, 'ell': 2.0, 'sigma_g': 0.5, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 1.0, 'bar_epsilon': 0.005,\n         'L_candidates': [5.0, 10.0, 20.0, 40.0], 'n_real': 20, 'epsilon_tol': 0.02,\n         'seed': 12345},\n        # Test case 2\n        {'dx': 2.0, 'ell': 10.0, 'sigma_g': 0.8, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 2.0, 'bar_epsilon': 0.005,\n         'L_candidates': [20.0, 40.0, 80.0], 'n_real': 30, 'epsilon_tol': 0.03,\n         'seed': 2468},\n        # Test case 3\n        {'dx': 1.0, 'ell': 5.0, 'sigma_g': 0.9, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 1.5, 'bar_epsilon': 0.005,\n         'L_candidates': [5.0, 10.0, 15.0], 'n_real': 10, 'epsilon_tol': 0.01,\n         'seed': 13579},\n        # Test case 4\n        {'dx': 0.5, 'ell': 0.5, 'sigma_g': 0.4, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 1.0, 'bar_epsilon': 0.005,\n         'L_candidates': [2.0, 4.0, 8.0], 'n_real': 25, 'epsilon_tol': 0.02,\n         'seed': 9876},\n    ]\n\n    results = []\n    for case in test_cases:\n        params_tuple = (\n            case['dx'], case['ell'], case['sigma_g'], case['rho_0'], case['alpha'],\n            case['G'], case['b'], case['E'], case['H'], case['bar_epsilon'],\n            case['L_candidates'], case['n_real'], case['epsilon_tol'], case['seed']\n        )\n        result = find_rve_size(params_tuple)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}