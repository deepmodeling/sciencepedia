{
    "hands_on_practices": [
        {
            "introduction": "在深入研究连续空间中的反应坐标之前，我们首先在离散状态空间中建立对“提交者 (committor)”的直观理解。马尔可夫状态模型（Markov State Models, MSMs）是将复杂系统动力学粗粒化为一组离散状态及其转移概率的强大工具。本练习将引导你从第一性原理出发，为离散时间的马尔可夫过程推导并求解提交者函数，最终该问题将归结为一个线性方程组的求解，从而加深对提交者作为“前向转移概率”这一定义的理解。",
            "id": "3796686",
            "problem": "考虑一个粗粒化动力学系统，它被建模为一个离散时间马尔可夫状态模型 (MSM)，由一个有限状态集 $\\{0,1,\\dots,N-1\\}$ 和一个行随机转移概率矩阵 $P \\in \\mathbb{R}^{N \\times N}$ 定义。该矩阵的元素 $P_{ij} \\ge 0$ 并且对于每个状态 $i$ 都满足 $\\sum_{j=0}^{N-1} P_{ij} = 1$。在过渡路径理论 (TPT) 中，前向提交者函数 $q$ 为每个状态 $i$ 赋予一个概率 $q_i \\in [0,1]$，该概率表示从 $i$ 开始的轨迹在首次到达指定的反应物集 $A$ 之前到达指定的产物集 $B$ 的可能性。其中 $A$ 和 $B$ 是 $\\{0,1,\\dots,N-1\\}$ 的不相交子集。\n\n从离散时间马尔可夫过程的第一性原理以及前向提交者的定义 $q_i = \\mathbb{P}(\\tau_B  \\tau_A \\mid X_0 = i)$ 出发，在边界条件 $q_i = 0$ (对于 $i \\in A$) 和 $q_i = 1$ (对于 $i \\in B$) 下，仅使用马尔可夫性质和全概率定律，推导出确定内部值 $q_i$ (对于 $i \\notin A \\cup B$) 所必需的线性系统。基于此推导，编写一个程序，为以下每个测试用例计算离散提交者向量 $q$。\n\n您必须将所有最终数值输出表示为四舍五入到六位小数的浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个元素对应一个测试用例，并且本身也是一个列表，按状态索引顺序包含该测试用例的完整提交者向量 $q$（例如，$[ [q_0^{(1)}, q_1^{(1)}, \\dots], [q_0^{(2)}, \\dots], \\dots ]$)，该行中任何地方都不能有空格。\n\n测试套件：\n\n$1.$ 具有一个内部状态的三状态系统：\n$$\nP^{(1)} =\n\\begin{pmatrix}\n1.0  0.0  0.0 \\\\\n0.3  0.4  0.3 \\\\\n0.0  0.0  1.0\n\\end{pmatrix},\n\\quad\nA^{(1)} = \\{0\\},\n\\quad\nB^{(1)} = \\{2\\}.\n$$\n\n$2.$ 具有两个内部状态的五状态系统：\n$$\nP^{(2)} =\n\\begin{pmatrix}\n1.0  0.0  0.0  0.0  0.0 \\\\\n1.0  0.0  0.0  0.0  0.0 \\\\\n0.4  0.1  0.3  0.2  0.0 \\\\\n0.1  0.2  0.2  0.3  0.2 \\\\\n0.0  0.0  0.0  0.0  1.0\n\\end{pmatrix},\n\\quad\nA^{(2)} = \\{0,1\\},\n\\quad\nB^{(2)} = \\{4\\}.\n$$\n\n$3.$ 内部没有直接通往 $B$ 的路径的四状态系统：\n$$\nP^{(3)} =\n\\begin{pmatrix}\n1.0  0.0  0.0  0.0 \\\\\n0.6  0.4  0.0  0.0 \\\\\n0.5  0.5  0.0  0.0 \\\\\n0.0  0.0  0.0  1.0\n\\end{pmatrix},\n\\quad\nA^{(3)} = \\{0\\},\n\\quad\nB^{(3)} = \\{3\\}.\n$$\n\n要求：\n\n$1.$ 仅使用离散时间马尔可夫链中提交者的定义、马尔可夫性质和全概率定律作为基本依据，来推导控制线性方程组。\n\n$2.$ 实现一个稳健的数值过程，在给定 $P$、$A$ 和 $B$ 的情况下，构建并求解内部状态的线性系统，并组合成遵循边界条件且确保 $q_i \\in [0,1]$ 的完整提交者向量 $q$。\n\n$3.$ 对于每个测试用例，按状态索引升序输出完整的提交者向量 $q$，表示为四舍五入到六位小数的浮点数。\n\n$4.$ 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果都打印为六位小数浮点数的列表，且不含任何空格，例如 $[[0.000000,0.500000,1.000000],[\\dots],[\\dots]]$。\n\n所有答案都是无量纲的概率；不需要物理单位。",
            "solution": "目标是为离散时间马尔可夫状态模型推导控制前向提交者函数 $q$ 的线性系统，然后实现一个程序来为几个测试用例求解该系统。\n\n设系统由状态集 $\\{0, 1, \\dots, N-1\\}$ 和行随机转移概率矩阵 $P \\in \\mathbb{R}^{N \\times N}$ 定义。给定反应物集 $A$ 和产物集 $B$，它们是状态空间的不相交子集。前向提交者 $q_i$ 定义为从状态 $i$ 开始的轨迹在到达集合 $A$ 之前到达集合 $B$ 的概率。形式上，$q_i = \\mathbb{P}(\\tau_B  \\tau_A \\mid X_0 = i)$，其中 $\\tau_S = \\min\\{n \\ge 0 \\mid X_n \\in S\\}$ 是到达集合 $S$ 的首次到达时间。\n\n根据这个定义，集合 $A$ 和 $B$ 内状态的提交者值由边界条件固定。如果一条轨迹从 $A$ 中开始，它在时间 $0$ 就已经到达了 $A$，所以 $\\tau_A = 0$。由于 $A$ 和 $B$ 不相交，它不可能先到达 $B$，因此 $\\tau_B > 0$。所以，对于任何状态 $i \\in A$，$\\tau_A \\le \\tau_B$，条件 $\\tau_B  \\tau_A$ 为假。其概率为零：\n$$ q_i = 0 \\quad \\text{for all } i \\in A $$\n相反，如果一条轨迹从 $B$ 中开始，它在时间 $0$ 就已经到达了 $B$，所以 $\\tau_B = 0$。由于它尚未访问过 $A$，$\\tau_A > 0$（或者只有在 $A \\cap B \\neq \\emptyset$ 时 $\\tau_A=0$，这种情况已被排除）。因此，$\\tau_B  \\tau_A$ 为真，其概率为一：\n$$ q_i = 1 \\quad \\text{for all } i \\in B $$\n\n我们的任务是确定所有其他状态的 $q_i$ 值，我们称这些状态为内部状态。设内部状态集为 $I = \\{0, 1, \\dots, N-1\\} \\setminus (A \\cup B)$。\n\n对于任何内部状态 $i \\in I$，我们可以使用第一步分析法来找到 $q_i$ 的方程，该方法依赖于全概率定律和马尔可夫性质。我们以过程第一步的结果 $X_1$ 为条件来分析事件 $\\tau_B  \\tau_A$。\n全概率定律给出：\n$$ q_i = \\mathbb{P}(\\tau_B  \\tau_A \\mid X_0 = i) = \\sum_{j=0}^{N-1} \\mathbb{P}(\\tau_B  \\tau_A \\mid X_1 = j, X_0 = i) \\cdot \\mathbb{P}(X_1 = j \\mid X_0 = i) $$\n\n项 $\\mathbb{P}(X_1 = j \\mid X_0 = i)$ 就是从状态 $i$ 到状态 $j$ 的转移概率，由矩阵元素 $P_{ij}$ 给出。\n\n项 $\\mathbb{P}(\\tau_B  \\tau_A \\mid X_1 = j, X_0 = i)$ 是在过程于时间 $1$ 处于状态 $j$ 的条件下该事件发生的概率。根据马尔可夫性质，过程的未来演化仅取决于其当前状态 ($X_1=j$)，而不取决于其过去状态 (如 $X_0=i$)。因此：\n$$ \\mathbb{P}(\\tau_B  \\tau_A \\mid X_1 = j, X_0 = i) = \\mathbb{P}(\\tau_B'  \\tau_A' \\mid X'_0 = j) $$\n其中撇号表示一个从时间 $0$ 重新开始的过程。这恰好是状态 $j$ 的提交者 $q_j$ 的定义。\n\n将这些分量代回方程，我们得到对任何内部状态 $i \\in I$ 的基本关系：\n$$ q_i = \\sum_{j=0}^{N-1} P_{ij} q_j $$\n这表明提交者函数是关于内部状态集上的转移算子 $P$ 的一个调和函数。\n\n为了将其转化为一个可解的线性系统，我们将对所有状态 $j$ 的求和分为三部分，根据 $j$ 是否在 $A$、$B$ 或 $I$ 中：\n$$ q_i = \\sum_{j \\in A} P_{ij} q_j + \\sum_{j \\in B} P_{ij} q_j + \\sum_{j \\in I} P_{ij} q_j $$\n\n现在，我们代入已知的 $q_j$ 边界值：\n$$ q_i = \\sum_{j \\in A} P_{ij} (0) + \\sum_{j \\in B} P_{ij} (1) + \\sum_{j \\in I} P_{ij} q_j $$\n这可以简化为：\n$$ q_i = \\sum_{j \\in B} P_{ij} + \\sum_{j \\in I} P_{ij} q_j $$\n\n我们可以重新整理这个方程，将所有未知变量（即 $k \\in I$ 的 $q_k$）归到左侧：\n$$ q_i - \\sum_{j \\in I} P_{ij} q_j = \\sum_{j \\in B} P_{ij} $$\n\n这是对每个 $i \\in I$ 的一个线性方程。我们有一个包含 $|I|$ 个未知数的 $|I|$ 个线性方程组。让我们用矩阵形式来写这个系统。设 $q_I$ 是 $I$ 中状态的未知提交者值的列向量。设 $I$ 中的状态从 $1$ 到 $m=|I|$ 进行索引。对于 $I$ 中的第 $k$ 个状态 $i_k$，方程是：\n$$ q_{i_k} - \\sum_{l=1}^{m} P_{i_k, i_l} q_{i_l} = \\sum_{j \\in B} P_{i_k, j} $$\n这可以表示为：\n$$ \\sum_{l=1}^{m} (\\delta_{kl} - P_{i_k, i_l}) q_{i_l} = \\sum_{j \\in B} P_{i_k, j} $$\n其中 $\\delta_{kl}$ 是克罗内克 (Kronecker) delta。\n\n设 $L$ 是一个 $m \\times m$ 矩阵，其元素为 $L_{kl} = \\delta_{kl} - P_{i_k, i_l}$。这个矩阵可以写成 $L = I_m - P_{II}$，其中 $I_m$ 是 $m \\times m$ 单位矩阵，$P_{II}$ 是 $P$ 中对应于内部状态*之间*转移的子矩阵。\n设 $b$ 是一个大小为 $m$ 的列向量，其中第 $k$ 个元素是 $b_k = \\sum_{j \\in B} P_{i_k, j}$。这个向量表示从每个内部状态一步直接转移到产物集 $B$ 的总概率。\n\n待求解的内部提交者值 $q_I$ 的线性系统是：\n$$ (I_m - P_{II}) q_I = b $$\n解由 $q_I = (I_m - P_{II})^{-1} b$ 给出，前提是矩阵 $(I_m - P_{II})$ 是可逆的。如果每个内部状态最终到达 $A$ 或 $B$ 的概率都非零，那么可逆性就得到保证。\n\n总体算法如下：\n1. 识别内部状态 $I$。\n2. 构建 $P$ 中状态在 $I$ 之间转移的子矩阵 $P_{II}$。\n3. 构建矩阵 $L = I_m - P_{II}$。\n4. 构建右侧向量 $b$，其中每个元素 $b_k$ 是从内部状态 $i_k$ 转移到 $B$ 中任何状态的概率之和。\n5. 求解线性系统 $L q_I = b$ 以找到内部状态的提交者值。\n6. 将计算出的值 $q_I$ 与边界条件 $q_A=0$ 和 $q_B=1$ 组合起来，构成大小为 $N$ 的完整提交者向量 $q$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_committor(P, A, B):\n    \"\"\"\n    Computes the forward committor vector for a discrete-time Markov State Model.\n\n    Args:\n        P (np.ndarray): The transition probability matrix.\n        A (set): The set of reactant state indices.\n        B (set): The set of product state indices.\n\n    Returns:\n        np.ndarray: The full committor vector q.\n    \"\"\"\n    num_states = P.shape[0]\n    all_states = set(range(num_states))\n    \n    # Identify interior states\n    interior_states = sorted(list(all_states - A - B))\n    num_interior = len(interior_states)\n    \n    # Initialize the full committor vector\n    q = np.zeros(num_states, dtype=float)\n    \n    # Apply boundary conditions\n    for state in A:\n        q[state] = 0.0\n    for state in B:\n        q[state] = 1.0\n        \n    if num_interior > 0:\n        # Construct the linear system L*q_I = b\n        # L = I - P_II\n        P_II = P[np.ix_(interior_states, interior_states)]\n        L = np.identity(num_interior) - P_II\n        \n        # Construct the right-hand side vector b\n        b = np.zeros(num_interior)\n        b = P[np.ix_(interior_states, list(B))].sum(axis=1)\n\n        # Solve for the interior committor values\n        try:\n            q_I = np.linalg.solve(L, b)\n        except np.linalg.LinAlgError:\n            # This case happens if L is singular, e.g., if there are trapping\n            # interior states that can't reach A or B.\n            # In such a scenario, more advanced methods might be needed,\n            # but for the given problems, linalg.solve is sufficient.\n            # Here we can return NaNs or raise an error.\n            # For this problem, let's assume the system is solvable.\n            raise\n            \n        # Place the solved interior values into the full committor vector\n        for i, val in enumerate(q_I):\n            q[interior_states[i]] = val\n            \n    # Ensure all probabilities are in [0, 1] by clamping.\n    # This can handle potential small numerical precision errors.\n    np.clip(q, 0.0, 1.0, out=q)\n    \n    return q\n\ndef solve():\n    \"\"\"\n    Defines and solves the test cases for committor calculation.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [1.0, 0.0, 0.0],\n                [0.3, 0.4, 0.3],\n                [0.0, 0.0, 1.0]\n            ]),\n            {0},\n            {2}\n        ),\n        (\n            np.array([\n                [1.0, 0.0, 0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0, 0.0, 0.0],\n                [0.4, 0.1, 0.3, 0.2, 0.0],\n                [0.1, 0.2, 0.2, 0.3, 0.2],\n                [0.0, 0.0, 0.0, 0.0, 1.0]\n            ]),\n            {0, 1},\n            {4}\n        ),\n        (\n            np.array([\n                [1.0, 0.0, 0.0, 0.0],\n                [0.6, 0.4, 0.0, 0.0],\n                [0.5, 0.5, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 1.0]\n            ]),\n            {0},\n            {3}\n        )\n    ]\n\n    results = []\n    for P, A, B in test_cases:\n        q_vector = compute_committor(P, A, B)\n        # Format each number to six decimal places\n        formatted_q = [f\"{x:.6f}\" for x in q_vector]\n        results.append(f\"[{','.join(formatted_q)}]\")\n\n    # Print the final result in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "将离散框架中的概念推广到连续系统，提交者函数 $q(x)$ 成为一个偏微分方程——即“后向科尔莫戈罗夫方程 (backward Kolmogorov equation)”的解。对于一维系统，这个微分方程存在一个精确的积分形式解析解，这为我们提供了深刻的洞察力。本练习聚焦于如何通过数值积分实现该解析解，并让你亲身体验在小噪声（即稀有事件）极限下为保证计算稳定性所需应对的数值挑战。",
            "id": "3796696",
            "problem": "考虑一个反应坐标$x(t)$的一维过阻尼随机动力学，它在平滑势能函数$V(x)$和强度为$\\varepsilon  0$的加性噪声下演化。该过程由过阻尼朗之万方程建模\n$$\ndx(t) = -\\partial_x V(x(t))\\, dt + \\sqrt{2 \\varepsilon}\\, dW_t,\n$$\n其中$W_t$是一个标准维纳过程。在实线上定义两个不相交的集合$A$和$B$，其阈值为$a  b$，解释为$A = \\{ x \\le a \\}$和$B = \\{ x \\ge b \\}$。提交函数 (committor function) $q(x)$是从$x$开始的轨迹在到达集合$A$之前先到达集合$B$的概率。根据此动力学的后向Kolmogorov公式，开区间$(a,b)$上的提交函数$q(x)$解以下边值问题\n$$\n\\mathcal{L} q(x) = 0 \\quad \\text{for } x \\in (a,b), \\quad q(a) = 0, \\quad q(b) = 1,\n$$\n其中过阻尼过程的生成元$\\mathcal{L}$是二阶微分算子\n$$\n\\mathcal{L} f(x) = -\\partial_x V(x)\\, \\partial_x f(x) + \\varepsilon\\, \\partial_{xx} f(x).\n$$\n这个提交函数在稀有事件算法中至关重要，因为它可作为最优反应坐标：它在等提交值曲面上是恒定的，并且在过渡路径理论（TPT）中最小化了概率通量失配，同时在加权系综（WE）方案中驱动高效的分层。\n\n您的任务是编写一个完整的程序，对于给定的势$V(x)$、阈值$a$和$b$以及噪声强度$\\varepsilon$，通过以数学上一致的方式求解上述边值问题，计算指定起始点$x_0 \\in [a,b]$的$q(x_0)$。所有计算都是无量纲的；最终输出是概率，必须表示为十进制浮点数。如果$x_0 = a$或$x_0 = b$，则严格执行边界条件$q(a) = 0$和$q(b) = 1$。\n\n您必须实现一种基于控制方程的方法。推导必须从生成元$\\mathcal{L}$和边值问题开始，并且计算必须遵循边界条件。确保数值稳定性和准确性，以适应稀有事件的高级研究生水平分析。\n\n测试套件：\n为以下六种情况中的每一种计算$q(x_0)$。所有结果必须以四舍五入到八位小数的十进制浮点数形式打印。势函数是下面定义的光滑多项式。由于问题是无量纲的，因此不需要物理单位。\n\n- 情况1（对称双阱，中等噪声，中心起始）：\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$，\n  - $a = -0.9$, $b = 0.9$，\n  - $\\varepsilon = 0.05$，\n  - $x_0 = 0.0$。\n\n- 情况2（倾斜双阱，中等噪声，中心起始）：\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4} + \\alpha x$，其中$\\alpha = 0.2$，\n  - $a = -0.9$, $b = 0.9$，\n  - $\\varepsilon = 0.05$，\n  - $x_0 = 0.0$。\n\n- 情况3（对称双阱，小噪声，偏离中心起始；稀有事件机制）：\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$，\n  - $a = -0.9$, $b = 0.9$，\n  - $\\varepsilon = 0.01$，\n  - $x_0 = -0.5$。\n\n- 情况4（对称双阱，在$A$处边界起始）：\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$，\n  - $a = -0.9$, $b = 0.9$，\n  - $\\varepsilon = 0.05$，\n  - $x_0 = a$。\n\n- 情况5（对称双阱，在$B$处边界起始）：\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$，\n  - $a = -0.9$, $b = 0.9$，\n  - $\\varepsilon = 0.05$，\n  - $x_0 = b$。\n\n- 情况6（弱倾斜双阱，小噪声，偏离中心起始）：\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4} + \\alpha x$，其中$\\alpha = -0.1$，\n  - $a = -0.9$, $b = 0.9$，\n  - $\\varepsilon = 0.02$，\n  - $x_0 = 0.3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个结果，以逗号分隔并用方括号括起来，每个结果四舍五入到八位小数，例如：\n$$\n[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5},\\text{result6}]\n$$",
            "solution": "问题陈述被评估为**有效**。其科学基础扎实，问题设定良好且客观。该问题要求计算一维过阻尼朗之万动力学的提交函数$q(x)$，这是统计力学和随机过程理论中一个标准且定义明确的问题。控制方程$\\mathcal{L} q(x) = 0$（其中$\\mathcal{L}$是后向Kolmogorov算子）及其相关的边界条件$q(a)=0$和$q(b)=1$构成了一个适定的边值问题。所有参数和函数都已明确定义，且前提与已建立的科学原理一致。该问题不违反任何无效性标准。\n\n任务是找到从$x_0 \\in [a,b]$开始的粒子的提交函数值$q(x_0)$。函数$q(x)$被定义为以下边值问题的解：\n$$\n\\varepsilon \\frac{d^2q}{dx^2}(x) - \\frac{dV}{dx}(x) \\frac{dq}{dx}(x) = 0, \\quad \\text{for } x \\in (a,b)\n$$\n边界条件为$q(a)=0$和$q(b)=1$。\n\n这是一个二阶线性常微分方程（ODE）。我们可以通过先降阶来求解。设$p(x) = \\frac{dq}{dx}(x)$。该ODE变为一个关于$p(x)$的一阶ODE：\n$$\n\\varepsilon \\frac{dp}{dx}(x) = \\frac{dV}{dx}(x) p(x)\n$$\n这是一个可分离方程：\n$$\n\\frac{dp}{p} = \\frac{1}{\\varepsilon} \\frac{dV}{dx} dx\n$$\n对两边积分得到：\n$$\n\\ln(p(x)) = \\frac{V(x)}{\\varepsilon} + C_0\n$$\n其中$C_0$是积分常数。对两边取指数得到：\n$$\np(x) = e^{C_0} e^{V(x)/\\varepsilon} = C_1 e^{V(x)/\\varepsilon}\n$$\n其中$C_1$是任意常数。由于$p(x) = \\frac{dq}{dx}(x)$，我们可以通过对$p(x)$关于$x$积分来找到$q(x)$：\n$$\nq(x) = \\int p(y) dy + C_2 = C_1 \\int e^{V(y)/\\varepsilon} dy + C_2\n$$\n为了处理积分常数，我们将其写成从边界$a$开始的定积分：\n$$\nq(x) = C_1 \\int_a^x e^{V(y)/\\varepsilon} dy + C_2\n$$\n现在，我们应用边界条件来确定常数$C_1$和$C_2$。\n$1$。在$x=a$处，我们有$q(a)=0$：\n$$\nq(a) = C_1 \\int_a^a e^{V(y)/\\varepsilon} dy + C_2 = C_1 \\cdot 0 + C_2 = 0 \\implies C_2 = 0\n$$\n$2$。在$x=b$处，我们有$q(b)=1$：\n$$\nq(b) = C_1 \\int_a^b e^{V(y)/\\varepsilon} dy = 1 \\implies C_1 = \\frac{1}{\\int_a^b e^{V(y)/\\varepsilon} dy}\n$$\n将$C_1$和$C_2$的表达式代回$q(x)$的方程，我们得到精确解析解：\n$$\nq(x) = \\frac{\\int_a^x e^{V(y)/\\varepsilon} dy}{\\int_a^b e^{V(y)/\\varepsilon} dy}\n$$\n该公式为任意点$x \\in [a,b]$提供了提交概率$q(x)$。对于特定的起始点$x_0$的计算，只需设$x=x_0$即可。如果$x_0=a$，分子积分为零，因此$q(a)=0$。如果$x_0=b$，分子和分母的积分相同，因此$q(b)=1$。这些结果与边界条件相符，符合预期。\n\n对于一般的势$V(x)$，这些积分必须进行数值计算。当噪声强度$\\varepsilon$很小时，数值计算会遇到一个重大挑战。在这种情况下，指数中的项$V(y)/\\varepsilon$会变得非常大，导致计算$e^{V(y)/\\varepsilon}$时出现数值溢出错误。为确保数值稳定性，我们可以重新缩放被积函数。设$V_{max} = \\max_{y \\in [a,b]} V(y)$。我们可以通过提出因子$e^{V_{max}/\\varepsilon}$来重写$q(x)$的表达式：\n$$\nq(x) = \\frac{\\int_a^x e^{(V(y) - V_{max})/\\varepsilon} e^{V_{max}/\\varepsilon} dy}{\\int_a^b e^{(V(y) - V_{max})/\\varepsilon} e^{V_{max}/\\varepsilon} dy} = \\frac{e^{V_{max}/\\varepsilon} \\int_a^x e^{(V(y) - V_{max})/\\varepsilon} dy}{e^{V_{max}/\\varepsilon} \\int_a^b e^{(V(y) - V_{max})/\\varepsilon} dy}\n$$\n常数因子被消去，从而得到一个数值稳定的公式：\n$$\nq(x) = \\frac{\\int_a^x e^{(V(y) - V_{max})/\\varepsilon} dy}{\\int_a^b e^{(V(y) - V_{max})/\\varepsilon} dy}\n$$\n在这种形式下，指数的参数始终小于或等于零，因此被积函数的最大值为$1$，从而防止了溢出。\n\n因此，实现将遵循以下步骤：\n$1$。对于给定的情况$(V(x), a, b, \\varepsilon, x_0)$，首先检查$x_0$是否在边界上（$x_0=a$或$x_0=b$），并相应地返回$0$或$1$。\n$2$。对于$x_0 \\in (a,b)$，找到势$V(y)$在区间$[a,b]$上的最大值$V_{max}$。由于给定的势$V(x) = \\frac{(x^2-1)^2}{4} + \\alpha x$是多项式，其导数$V'(x)=x^3-x+\\alpha$也是多项式。$V(x)$在$[a,b]$上的最大值出现在端点$a, b$或导数$V'(x_c)=0$的临界点$x_c \\in (a,b)$处。我们数值求解$V'(x)$的根，筛选出$(a,b)$内的实根，并在这些点以及$a, b$处计算$V(x)$以找到$V_{max}$。\n$3$。定义稳定化的被积函数$f(y) = e^{(V(y) - V_{max})/\\varepsilon}$。\n$4$。使用高精度数值积分程序，例如`scipy.integrate.quad`，计算分子积分$I_{num} = \\int_a^{x_0} f(y) dy$和分母积分$I_{den} = \\int_a^b f(y) dy$。\n$5$。最终结果是比率$q(x_0) = I_{num} / I_{den}$。\n这个过程稳健、准确，并直接实现了推导出的解析解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the committor problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (symmetric double-well, moderate noise, central start):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': 0.0},\n        # Case 2 (tilted double-well, moderate noise, central start):\n        {'alpha': 0.2, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': 0.0},\n        # Case 3 (symmetric double-well, small noise, off-center start; rare-event regime):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.01, 'x0': -0.5},\n        # Case 4 (symmetric double-well, boundary start at A):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': -0.9},\n        # Case 5 (symmetric double-well, boundary start at B):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': 0.9},\n        # Case 6 (weakly tilted double-well, small noise, off-center start):\n        {'alpha': -0.1, 'a': -0.9, 'b': 0.9, 'epsilon': 0.02, 'x0': 0.3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_committor(\n            case['alpha'], case['a'], case['b'], case['epsilon'], case['x0']\n        )\n        results.append(result)\n\n    # Format the final output string as required.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n\ndef compute_committor(alpha, a, b, epsilon, x0):\n    \"\"\"\n    Computes the committor probability q(x0) for a given potential and parameters.\n\n    The committor q(x) is the solution to the ODE:\n    epsilon * q''(x) - V'(x) * q'(x) = 0\n    with boundary conditions q(a)=0 and q(b)=1.\n\n    The analytical solution is q(x) = Integral[a, x](exp(V(y)/epsilon) dy) / Integral[a, b](exp(V(y)/epsilon) dy).\n\n    Args:\n        alpha (float): The tilt parameter for the potential V(x).\n        a (float): The boundary for state A.\n        b (float): The boundary for state B.\n        epsilon (float): The noise intensity.\n        x0 (float): The starting point.\n\n    Returns:\n        float: The committor probability q(x0).\n    \"\"\"\n    # Handle the boundary conditions directly.\n    if np.isclose(x0, a):\n        return 0.0\n    if np.isclose(x0, b):\n        return 1.0\n\n    # Define the potential V(x) = (x^2 - 1)^2 / 4 + alpha * x\n    V = lambda x: (x**2 - 1)**2 / 4 + alpha * x\n    \n    # To ensure numerical stability, we find the maximum of V(x) on [a, b].\n    # The derivative is V'(x) = x^3 - x + alpha.\n    # The coefficients for the polynomial V'(x) are [1, 0, -1, alpha].\n    V_prime_coeffs = [1, 0, -1, alpha]\n    \n    # Find the roots of the derivative polynomial.\n    crit_points_all = np.roots(V_prime_coeffs)\n    \n    # Filter for real roots that lie within the open interval (a, b).\n    real_crit_points_in_interval = [\n        p.real for p in crit_points_all if np.isclose(p.imag, 0) and a  p.real  b\n    ]\n    \n    # The maximum of V(x) on [a, b] must occur at the endpoints or at a critical point.\n    candidate_points = [a, b] + real_crit_points_in_interval\n    V_values = [V(p) for p in candidate_points]\n    V_max = np.max(V_values)\n\n    # Define the numerically stabilized integrand: exp((V(y) - V_max) / epsilon).\n    # This prevents overflow by ensuring the exponent is non-positive.\n    integrand = lambda y: np.exp((V(y) - V_max) / epsilon)\n\n    # Compute the numerator integral from a to x0.\n    numerator_integral, num_err = quad(integrand, a, x0, limit=200)\n    \n    # Compute the denominator integral from a to b.\n    denominator_integral, den_err = quad(integrand, a, b, limit=200)\n\n    # The committor is the ratio of the two integrals.\n    # A zero denominator is highly unlikely given the strictly positive integrand\n    # unless a=b, which is not the case. It could underflow for extremely small epsilon.\n    if np.isclose(denominator_integral, 0):\n        # Physical interpretation: If the total probability mass underflows to zero,\n        # the probability of reaching any x > a is effectively zero.\n        return 0.0\n        \n    return numerator_integral / denominator_integral\n\nsolve()\n```"
        },
        {
            "introduction": "尽管积分形式的解析解非常优雅，但在更高维度或更复杂的情况下，这种解通常难以获得。一种更通用、更强大的方法是使用数值方法直接求解后向科尔莫戈罗夫偏微分方程 (PDE)。本练习将指导你构建一个基于有限差分法的提交者方程求解器，这是一种计算科学中的基本技能。通过解决一维和二维的示例，你将学会如何处理不同的势能面和边界条件，为分析更真实的复杂系统打下基础。",
            "id": "3796690",
            "problem": "考虑一个材料自由度的过阻尼布朗动力学，该动力学在一个有界域中通过一个随机微分方程 (SDE) 进行建模，其漂移项由一个势函数产生，并具有一个恒定的扩散系数。提交函数被定义为从某给定点开始的轨迹在到达反应物集之前首先到达指定产物集的概率，它是在多尺度材料模拟中识别反应坐标的核心对象。从提交函数的定义和SDE的生成元出发，推导其控制性的稳态边值问题（反向Kolmogorov公式），然后构建一个二阶有限差分法离散格式，该格式在反应物集和产物集上施加狄利克雷边界条件，并在适用之处施加反射（诺伊曼）条件。\n\n你的程序必须使用有限差分法，在科学合理的网格分辨率下，对以下测试案例集数值求解提交函数的边值问题。所有量均为无量纲，所有输出必须以浮点数形式报告，并四舍五入到六位小数。最终输出必须是单行文本，包含一个由方括号括起来的逗号分隔列表，其顺序和格式如下文规定。\n\n推导所用的基本原理：\n- 针对光滑势和恒定扩散的过阻尼朗之万动力学SDE及其生成元。\n- 提交函数作为两个不相交边界集之间的首达概率的定义。\n- 首达概率与带有适当边界条件（在到达集上为狄利克雷条件，在反射边界上为诺伊曼条件）的反向Kolmogorov方程的稳态解之间的对应关系。\n\n任务详情：\n1. 一维双阱漂移情况：\n   - 域：$x \\in [-1,1]$。\n   - 势函数：$U(x) = \\frac{x^{4}}{4} - \\frac{x^{2}}{2}$。\n   - 漂移项：$b(x) = -\\frac{dU}{dx} = -(x^{3} - x)$。\n   - 扩散系数：$D = 0.05$。\n   - 边界集：反应物集 $A$ 是左端点 $x=-1$，产物集 $B$ 是右端点 $x=1$。\n   - 边界条件：$q(-1)=0$ 和 $q(1)=1$。\n   - 网格：在 $[-1,1]$ 上使用 $N=1001$ 个均匀分布的点。\n   - 需报告的量：在 $x=0$ 处计算的提交函数 $q(x)$ 值。\n\n2. 一维无漂移情况（区间上的调和提交函数）：\n   - 域：$x \\in [0,1]$。\n   - 漂移项：$b(x) = 0$。\n   - 扩散系数：$D = 0.1$。\n   - 边界集：$A$ 是 $x=0$，$B$ 是 $x=1$。\n   - 边界条件：$q(0)=0$ 和 $q(1)=1$。\n   - 网格：在 $[0,1]$ 上使用 $N=501$ 个均匀分布的点。\n   - 需报告的量：在 $x=0.3$ 处计算的提交函数 $q(x)$ 值。\n\n3. 带混合边界条件的二维无漂移矩形：\n   - 域：$(x,y) \\in [-1,1] \\times [0,1]$。\n   - 漂移项：$\\mathbf{b}(x,y) = (0,0)$。\n   - 扩散系数：$D = 1.0$。\n   - 边界集和条件：在左边界 $x=-1$（反应物）上施加狄利克雷条件 $q=0$，在右边界 $x=1$（产物）上施加狄利克雷条件 $q=1$。在顶部和底部边界 $y=1$ 和 $y=0$ 上施加反射（诺伊曼）边界条件，强制法向导数 $\\partial q / \\partial y = 0$。\n   - 网格：在 $[-1,1]$ 上使用 $N_{x}=81$ 个均匀分布的点，在 $[0,1]$ 上使用 $N_{y}=61$ 个均匀分布的点。\n   - 需报告的量：在 $(x,y)=(0.2,0.7)$ 处计算的提交函数 $q(x,y)$ 值。\n\n算法要求：\n- 推导与域内SDE生成元相关的稳态反向Kolmogorov方程，并在反应物集上强制 $q=0$，在产物集上强制 $q=1$。在指定位置使用反射边界条件。\n- 使用二阶中心有限差分对空间导数进行离散化。对于诺伊曼边界，使用鬼点反射法施加零法向导数条件。\n- 使用鲁棒的稀疏线性求解器组合并求解得到的线性系统。\n- 在计算出的网格上，使用适当的插值方法（一维情况下使用线性插值，二维情况下使用双线性插值）来评估指定查询点处的提交函数值。\n\n测试集和输出规范：\n- 按案例顺序列出并计算上述三个标量值。你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，结果四舍五入到六位小数（例如，“[0.500000,0.300000,0.600000]”）。\n\n不允许外部输入。所有计算必须是自包含的，并且在给定上述规范的情况下是可复现的。最终答案必须是无量纲单位，并以浮点数形式报告，四舍五入到六位小数。",
            "solution": "用户提供了一个具有科学依据、良定且客观的问题。这是一个计算物理和化学领域中标准但并非微不足道的数值问题，适合用于测试关于反应坐标的数学基础以及求解椭圆偏微分方程的数值方法的知识。该问题是有效的。\n\n核心任务是求解提交函数 $q(\\mathbf{x})$，该函数对于分析稀有事件和识别复杂系统中的最优反应坐标至关重要。提交函数 $q(\\mathbf{x})$ 定义为从状态 $\\mathbf{x}$ 开始的随机过程轨迹在到达反应物状态集 $A$ 之前，首先到达预定义的产物状态集 $B$ 的概率。\n\n系统的动力学由状态向量 $\\mathbf{X}_t$ 的过阻尼朗之万随机微分方程 (SDE) 描述：\n$$\nd\\mathbf{X}_t = \\mathbf{b}(\\mathbf{X}_t) dt + \\sqrt{2D} d\\mathbf{W}_t\n$$\n在此，$\\mathbf{b}(\\mathbf{x})$ 是漂移项，在我们的案例中，它由势函数 $U(\\mathbf{x})$ 导出，即 $\\mathbf{b}(\\mathbf{x}) = -\\nabla U(\\mathbf{x})$。$D$ 是一个恒定的标量扩散系数，$\\mathbf{W}_t$ 代表一个由独立维纳过程组成的向量。\n\n此SDE的生成元，记作 $\\mathcal{L}$，作用于一个适当光滑的函数 $f(\\mathbf{x})$，并由下式给出：\n$$\n\\mathcal{L}f(\\mathbf{x}) = \\mathbf{b}(\\mathbf{x}) \\cdot \\nabla f(\\mathbf{x}) + D \\nabla^2 f(\\mathbf{x})\n$$\n随机过程的一个基本定理指出，提交函数 $q(\\mathbf{x})$ 是在集合 $A$ 和 $B$ 之间的域 $\\Omega$ 内稳态反向Kolmogorov方程 $\\mathcal{L}q = 0$ 的解。该方程为：\n$$\n\\mathbf{b}(\\mathbf{x}) \\cdot \\nabla q(\\mathbf{x}) + D \\nabla^2 q(\\mathbf{x}) = 0 \\quad \\text{for } \\mathbf{x} \\in \\Omega\n$$\n这是一个椭圆偏微分方程 (PDE)。为了获得唯一解，我们必须指定边界条件。根据其定义，提交函数必须满足：\n- 对于所有 $\\mathbf{x} \\in A$，$q(\\mathbf{x}) = 0$（在反应物集上的狄利克雷边界条件）。\n- 对于所有 $\\mathbf{x} \\in B$，$q(\\mathbfx) = 1$（在产物集上的狄利克雷边界条件）。\n- 在域的任何其他反射边界上（即轨迹不会从这些边界逸出），我们施加一个无通量条件，这对于反向Kolmogorov方程而言，转化为一个零法向导数（齐次诺伊曼）边界条件：$\\mathbf{n} \\cdot \\nabla q(\\mathbf{x}) = 0$，其中 $\\mathbf{n}$ 是边界的单位法向量。\n\n我们将使用二阶有限差分法对三个指定案例求解此边值问题。该方法包括在网格上离散化域，在每个网格点上近似导数，并求解得到的线性代数方程组。\n\n**案例1：一维双阱漂移情况**\n- 域：$x \\in [-1,1]$。\n- 偏微分方程（PDE）：$b(x) \\frac{dq}{dx} + D \\frac{d^2q}{dx^2} = 0$，其中 $b(x) = x - x^3$ 且 $D = 0.05$。\n- 边界条件（BCs）：$q(-1) = 0$, $q(1) = 1$。\n我们将域离散为 $N=1001$ 个点 $x_i = -1 + i\\Delta x$ ，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，间距为 $\\Delta x = 2 / (N-1)$。对于每个内部点 $x_i$ （$i \\in \\{1, \\dots, N-2\\}$），我们使用二阶中心差分来近似导数：\n$$\n\\frac{dq}{dx}\\bigg|_{x_i} \\approx \\frac{q_{i+1} - q_{i-1}}{2\\Delta x}, \\quad \\frac{d^2q}{dx^2}\\bigg|_{x_i} \\approx \\frac{q_{i+1} - 2q_i + q_{i-1}}{(\\Delta x)^2}\n$$\n将这些近似代入PDE并重新整理，得到每个 $q_i$ 的线性方程：\n$$\n\\left(\\frac{D}{(\\Delta x)^2} - \\frac{b(x_i)}{2\\Delta x}\\right) q_{i-1} - \\left(\\frac{2D}{(\\Delta x)^2}\\right) q_i + \\left(\\frac{D}{(\\Delta x)^2} + \\frac{b(x_i)}{2\\Delta x}\\right) q_{i+1} = 0\n$$\n这为未知的内部值 $\\{q_1, \\dots, q_{N-2}\\}$ 形成了一个包含 $N-2$ 个线性方程的三对角系统。已知边界值 $q_0=0$ 和 $q_{N-1}=1$ 分别被并入 $q_1$ 和 $q_{N-2}$ 的方程中。涉及 $q_0$ 的项为零，而涉及 $q_{N-1}$ 的项被移到 $q_{N-2}$ 方程的右侧。值得注意的是，由于势函数 $U(x)$、域和边界条件的对称性，其解析解为 $q(x) = (\\int_{-1}^{x} e^{U(s)/D} ds) / (\\int_{-1}^{1} e^{U(s)/D} ds)$，计算得出 $q(0)=0.5$。我们的数值结果应与此值非常接近。\n\n**案例2：一维无漂移情况**\n- 域：$x \\in [0,1]$。\n- 偏微分方程（PDE）：$D \\frac{d^2q}{dx^2} = 0$，因为 $b(x)=0$。当 $D=0.1$ 时，方程简化为 $\\frac{d^2q}{dx^2} = 0$。\n- 边界条件（BCs）：$q(0)=0$, $q(1)=1$。\n其解析解显然是 $q(x) = x$，所以我们期望 $q(0.3) = 0.3$。尽管如此，我们还是会在一个包含 $N=501$ 个点的网格上对其进行数值求解。离散化方法与案例1相同，但 $b(x_i) = 0$。每个内部点 $q_i$ 的线性方程为：\n$$\n\\frac{D}{(\\Delta x)^2} q_{i-1} - \\frac{2D}{(\\Delta x)^2} q_i + \\frac{D}{(\\Delta x)^2} q_{i+1} = 0 \\quad \\implies \\quad q_{i-1} - 2q_i + q_{i+1} = 0\n$$\n这是零二阶导数的标准有限差分近似。我们求解得到的三对角系统。\n\n**案例3：二维无漂移矩形**\n- 域：$(x,y) \\in [-1,1] \\times [0,1]$。\n- 偏微分方程（PDE）：$D(\\frac{\\partial^2 q}{\\partial x^2} + \\frac{\\partial^2 q}{\\partial y^2}) = 0$，由于 $\\mathbf{b}(x,y)=(0,0)$，这是拉普拉斯方程。\n- 边界条件（BCs）：$q(-1,y)=0$ (狄利克雷), $q(1,y)=1$ (狄利克雷), $\\frac{\\partial q}{\\partial y}(x,0)=0$ (诺伊曼), $\\frac{\\partial q}{\\partial y}(x,1)=0$ (诺伊曼)。\n我们使用一个 $N_x=81$ 乘以 $N_y=61$ 的网格。未知数是那些不在狄利克雷边界上的网格点 $(x_i, y_j)$ 处的提交函数值 $q_{i,j}$。这包括诺伊曼边界上的点。因此，未知数为 $q_{i,j}$，其中 $i \\in \\{1, \\dots, N_x-2\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。\n对于一个内部点 $(x_i, y_j)$ （其中 $j \\in \\{1, \\dots, N_y-2\\}$），离散化的拉普拉斯方程是经典的五点差分格式：\n$$\n\\frac{q_{i+1,j} - 2q_{i,j} + q_{i-1,j}}{(\\Delta x)^2} + \\frac{q_{i,j+1} - 2q_{i,j} + q_{i,j-1}}{(\\Delta y)^2} = 0\n$$\n对于诺伊曼边界，我们使用鬼点法。对于底部边界 $j=0$，条件 $\\frac{\\partial q}{\\partial y}|_{j=0}=0$ 近似为 $\\frac{q_{i,1} - q_{i,-1}}{2\\Delta y} = 0$，这意味着鬼点值为 $q_{i,-1} = q_{i,1}$。将此代入 $j=0$ 处的五点差分格式，得到：\n$$\n\\frac{q_{i+1,0} - 2q_{i,0} + q_{i-1,0}}{(\\Delta x)^2} + \\frac{2q_{i,1} - 2q_{i,0}}{(\\Delta y)^2} = 0\n$$\n对于顶部边界 $j=N_y-1$ 可以推导出类似的方程。所有这些方程被组合成一个大型稀疏线性系统 $M\\mathbf{q} = \\mathbf{r}$，其中 $\\mathbf{q}$ 是未知网格值的扁平化向量。由于在 $y$ 方向上是诺伊曼条件，解析解不依赖于 $y$，为 $q(x,y) = (x+1)/2$。因此，我们期望 $q(0.2, 0.7) = (0.2+1)/2 = 0.6$。\n\n**求解策略**\n对每个案例，我们将构建线性系统的稀疏矩阵和右侧向量。我们将使用 `scipy` 库中的稀疏线性代数求解器，它对于此类问题非常高效。在网格上获得解之后，我们将使用插值（一维使用线性插值，二维使用双线性插值）来找到指定查询点处的提交函数值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_case_1():\n    \"\"\"\n    Solves the 1D double-well committor problem.\n    PDE: b(x)q'(x) + Dq''(x) = 0\n    Domain: x in [-1, 1]\n    BCs: q(-1) = 0, q(1) = 1\n    \"\"\"\n    N = 1001\n    D = 0.05\n    x_domain = [-1.0, 1.0]\n\n    x_grid = np.linspace(x_domain[0], x_domain[1], N)\n    dx = (x_domain[1] - x_domain[0]) / (N - 1)\n\n    # Interior points are indexed 1 to N-2\n    num_unknowns = N - 2\n    \n    # Use LIL matrix for efficient construction\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b_vec = np.zeros(num_unknowns)\n\n    # Drift function b(x) = -dU/dx = -(x^3 - x) = x - x^3\n    def drift(x):\n        return x - x**3\n\n    # Populate matrix A and vector b\n    for i in range(1, N - 1):\n        idx = i - 1  # Matrix index for grid point i\n        xi = x_grid[i]\n        b_x = drift(xi)\n\n        # Coefficients from central difference scheme\n        c_minus = D / (dx**2) - b_x / (2 * dx)\n        c_zero = -2 * D / (dx**2)\n        c_plus = D / (dx**2) + b_x / (2 * dx)\n        \n        A[idx, idx] = c_zero\n        if i > 1:\n            A[idx, idx - 1] = c_minus\n        if i  N - 2:\n            A[idx, idx + 1] = c_plus\n\n        # Apply boundary conditions\n        if i == 1:\n            # q_0 = 0, so c_minus * q_0 term is zero\n            pass\n        if i == N - 2:\n            # q_{N-1} = 1\n            b_vec[idx] = -c_plus * 1.0\n    \n    # Convert to CSC format for fast solving\n    A_csc = A.tocsc()\n    \n    # Solve the linear system\n    q_interior = spsolve(A_csc, b_vec)\n    \n    # Reconstruct full solution\n    q_sol = np.zeros(N)\n    q_sol[0] = 0.0\n    q_sol[N-1] = 1.0\n    q_sol[1:-1] = q_interior\n    \n    # Interpolate to find q(0)\n    query_x = 0.0\n    result = np.interp(query_x, x_grid, q_sol)\n    \n    return result\n\ndef solve_case_2():\n    \"\"\"\n    Solves the 1D driftless committor problem.\n    PDE: Dq''(x) = 0\n    Domain: x in [0, 1]\n    BCs: q(0) = 0, q(1) = 1\n    \"\"\"\n    N = 501\n    D = 0.1\n    x_domain = [0.0, 1.0]\n\n    x_grid = np.linspace(x_domain[0], x_domain[1], N)\n    dx = (x_domain[1] - x_domain[0]) / (N - 1)\n\n    num_unknowns = N - 2\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b_vec = np.zeros(num_unknowns)\n\n    # Drift is zero for this case\n    b_x = 0.0\n    c_minus = D / (dx**2) - b_x / (2 * dx)\n    c_zero = -2 * D / (dx**2)\n    c_plus = D / (dx**2) + b_x / (2 * dx)\n    \n    for i in range(1, N - 1):\n        idx = i - 1\n        A[idx, idx] = c_zero\n        if i > 1:\n            A[idx, idx - 1] = c_minus\n        if i  N - 2:\n            A[idx, idx + 1] = c_plus\n            \n        if i == N - 2:\n            b_vec[idx] = -c_plus * 1.0\n\n    A_csc = A.tocsc()\n    q_interior = spsolve(A_csc, b_vec)\n    \n    q_sol = np.zeros(N)\n    q_sol[0] = 0.0\n    q_sol[N-1] = 1.0\n    q_sol[1:-1] = q_interior\n    \n    query_x = 0.3\n    result = np.interp(query_x, x_grid, q_sol)\n    \n    return result\n\ndef solve_case_3():\n    \"\"\"\n    Solves the 2D driftless committor problem with mixed BCs.\n    PDE: D * (d^2q/dx^2 + d^2q/dy^2) = 0\n    Domain: (x,y) in [-1,1] x [0,1]\n    BCs: q(-1,y)=0, q(1,y)=1, dq/dy(x,0)=0, dq/dy(x,1)=0\n    \"\"\"\n    Nx, Ny = 81, 61\n    D = 1.0\n    x_domain = [-1.0, 1.0]\n    y_domain = [0.0, 1.0]\n\n    x_grid = np.linspace(x_domain[0], x_domain[1], Nx)\n    y_grid = np.linspace(y_domain[0], y_domain[1], Ny)\n    dx = (x_domain[1] - x_domain[0]) / (Nx - 1)\n    dy = (y_domain[1] - y_domain[0]) / (Ny - 1)\n\n    # Unknowns are interior in x, all points in y\n    num_unknowns = (Nx - 2) * Ny\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b_vec = np.zeros(num_unknowns)\n\n    # Coefficients for Laplace's equation\n    ax = D / (dx**2)\n    ay = D / (dy**2)\n\n    def get_k(i, j):\n        # Map (i, j) grid index to flattened index k\n        # i is in [1, Nx-2], j is in [0, Ny-1]\n        return (i - 1) * Ny + j\n\n    for i in range(1, Nx - 1):\n        for j in range(Ny):\n            k = get_k(i, j)\n            \n            # Diagonal term (contribution of q_{i,j})\n            A[k, k] = -2 * (ax + ay)\n            \n            # x-direction neighbors\n            # q_{i-1,j}\n            if i == 1: # Left Dirichlet boundary q=0\n                pass # Contribution is zero\n            else:\n                A[k, get_k(i - 1, j)] = ax\n            # q_{i+1,j}\n            if i == Nx - 2: # Right Dirichlet boundary q=1\n                b_vec[k] -= ax * 1.0\n            else:\n                A[k, get_k(i + 1, j)] = ax\n\n            # y-direction neighbors\n            if j == 0: # Bottom Neumann boundary\n                A[k, get_k(i, j + 1)] = 2 * ay\n            elif j == Ny - 1: # Top Neumann boundary\n                A[k, get_k(i, j - 1)] = 2 * ay\n            else: # Interior in y\n                A[k, get_k(i, j - 1)] = ay\n                A[k, get_k(i, j + 1)] = ay\n\n    A_csc = A.tocsc()\n    q_flat = spsolve(A_csc, b_vec)\n    \n    q_unknowns = q_flat.reshape((Nx - 2, Ny))\n    \n    q_full = np.zeros((Nx, Ny))\n    q_full[0, :] = 0.0   # Left Dirichlet BC\n    q_full[-1, :] = 1.0  # Right Dirichlet BC\n    q_full[1:-1, :] = q_unknowns\n\n    # Bilinear interpolation\n    query_x, query_y = 0.2, 0.7\n    \n    x_idx_float = (query_x - x_grid[0]) / dx\n    y_idx_float = (query_y - y_grid[0]) / dy\n    \n    i = int(x_idx_float)\n    j = int(y_idx_float)\n    \n    t = x_idx_float - i\n    u = y_idx_float - j\n    \n    q11 = q_full[i, j]\n    q21 = q_full[i + 1, j]\n    q12 = q_full[i, j + 1]\n    q22 = q_full[i + 1, j + 1]\n    \n    result = (1 - t) * (1 - u) * q11 + t * (1 - u) * q21 + (1 - t) * u * q12 + t * u * q22\n    \n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    result1 = solve_case_1()\n    result2 = solve_case_2()\n    result3 = solve_case_3()\n    \n    # Format the output as a comma-separated list of floats with 6 decimal places.\n    output_str = f\"[{result1:.6f},{result2:.6f},{result3:.6f}]\"\n    print(output_str)\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}