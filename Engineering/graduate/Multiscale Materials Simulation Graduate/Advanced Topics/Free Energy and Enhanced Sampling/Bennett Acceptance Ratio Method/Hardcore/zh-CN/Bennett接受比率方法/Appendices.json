{
    "hands_on_practices": [
        {
            "introduction": "掌握一个新方法的最好方式之一就是亲手实现它。这个练习将指导您完成一个完整的Bennett接受率（BAR）计算流程。我们将从一个二维玩具模型开始，其中一个带“电荷”的粒子在电场中的行为会发生改变，您需要为这个系统的两个状态生成模拟数据，并利用BAR方法计算它们之间的自由能差。通过这个练习，您将全面体验从模拟采样到最终求解BAR方程的全过程。",
            "id": "2463503",
            "problem": "考虑一个在二维构型空间中运动的单粒子，其位置矢量为 $\\mathbf{r} = (x,y)$。对于给定的标量参数 $q$，其约化势能（即势能乘以逆热能，其中逆温度为 $\\beta$）定义为\n$$\nu(q;\\mathbf{r}) \\equiv \\beta U(q;\\mathbf{r}) = \\tfrac{1}{2} k \\left(x^2 + y^2\\right) - q \\, \\mathbf{E} \\cdot \\mathbf{r},\n$$\n其中 $k$ 是一个正标量弹簧常数，$\\mathbf{E} = (E_x, E_y)$ 是一个固定的电场矢量。整个计算过程完全使用约化的无量纲单位，并设 $\\beta = 1$，因此所有能量都是无量纲的；不使用也不需要任何物理单位。\n\n定义两个热力学状态 $A$ 和 $B$，它们仅在标量参数 $q$ 的取值上有所不同，分别记为 $q_A$ 和 $q_B$。相应的约化势能为 $u_A(\\mathbf{r}) = u(q_A;\\mathbf{r})$ 和 $u_B(\\mathbf{r}) = u(q_B;\\mathbf{r})$。令约化自由能差 $\\Delta f_{BA}$ 定义为\n$$\n\\Delta f_{BA} \\equiv f_B - f_A = -\\ln Z_B + \\ln Z_A,\n$$\n其中 $Z_A$ 和 $Z_B$ 分别是状态 $A$ 和 $B$ 的约化配分函数。\n\n给定从正比于 $\\exp\\{-u_A(\\mathbf{r})\\}$ 的归一化玻尔兹曼分布中抽取的独立同分布样本 $\\{\\mathbf{r}_i^{(A)}\\}_{i=1}^{N_A}$，以及从正比于 $\\exp\\{-u_B(\\mathbf{r})\\}$ 的归一化玻尔兹曼分布中抽取的独立同分布样本 $\\{\\mathbf{r}_j^{(B)}\\}_{j=1}^{N_B}$，Bennett 接受率 (BAR) 方法将 $\\Delta f_{BA}$ 定义为以下方程的唯一解：\n$$\n\\frac{1}{N_A} \\sum_{i=1}^{N_A} \\frac{1}{1+\\exp\\left(\\Delta u(\\mathbf{r}_i^{(A)}) - \\Delta f_{BA} - c\\right)} \\;=\\; \\frac{1}{N_B} \\sum_{j=1}^{N_B} \\frac{1}{1+\\exp\\left(-\\Delta u(\\mathbf{r}_j^{(B)}) + \\Delta f_{BA} - c\\right)},\n$$\n其中 $\\Delta u(\\mathbf{r}) \\equiv u_B(\\mathbf{r}) - u_A(\\mathbf{r})$ 且 $c \\equiv \\ln\\!\\left(\\frac{N_B}{N_A}\\right)$。\n\n你的任务是编写一个完整的、可运行的程序，该程序能够：\n- 对下面指定的每个测试用例，使用指定的随机数生成器种子以确保可复现性，从对应于 $u_A(\\mathbf{r})$ 和 $u_B(\\mathbf{r})$ 的精确玻尔兹曼分布中生成所需的独立样本。\n- 通过求解上述 BAR 定义方程来计算约化自由能差 $\\Delta f_{BA}$。\n- 将所有测试用例的最终结果输出到单行中，格式严格按照本问题陈述末尾的规定。\n\n所有计算都必须在约化的无量纲单位中进行。不涉及角度。所需的输出值为实数，并且必须报告为精确到小数点后六位的浮点值。\n\n测试套件：\n对于每个用例，给定参数 $(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed})$。\n\n- 用例 1：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.0, 1.0, 0.8, -0.4, 20000, 20000, 12345)$。\n- 用例 2：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.7, 0.7, 1.2, -0.3, 15000, 15000, 54321)$。\n- 用例 3：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.5, 0.9, 1.0, 1.0, 5000, 20000, 2023)$。\n- 用例 4：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (2.0, -0.6, 0.4, 0.0, 0.0, 10000, 10000, 777)$。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含按上述用例顺序排列的四个 $\\Delta f_{BA}$ 的 BAR 估计值列表，形式为用方括号括起来的逗号分隔列表。每个值必须精确到小数点后六位。例如，输出必须具有以下形式：\n\"[v1,v2,v3,v4]\"\n其中每个 $v_i$ 是一个精确到小数点后六位的浮点值。",
            "solution": "该问题要求使用 Bennett 接受率 (BAR) 方法计算两个热力学状态 $A$ 和 $B$ 之间的约化自由能差 $\\Delta f_{BA}$。系统由一个在二维势场中的单粒子组成。在进行数值实现之前，必须对底层的物理模型和数值方法进行严格的分析。\n\n首先，我们分析势能函数。由参数 $q$ 定义的状态的约化势能由下式给出：\n$$\nu(q;\\mathbf{r}) = \\tfrac{1}{2} k \\left(x^2 + y^2\\right) - q \\, \\mathbf{E} \\cdot \\mathbf{r}\n$$\n其中 $\\mathbf{r}=(x,y)$，$k>0$ 且 $\\mathbf{E}=(E_x, E_y)$。为了理解系统的统计特性，我们必须确定玻尔兹曼分布 $p(\\mathbf{r}) \\propto \\exp(-u(q;\\mathbf{r}))$ 的形式。我们可以通过对 $x$ 和 $y$ 坐标进行配方来重写势能：\n$$\n\\begin{aligned}\nu(q;\\mathbf{r}) = \\left(\\tfrac{1}{2} k x^2 - q E_x x\\right) + \\left(\\tfrac{1}{2} k y^2 - q E_y y\\right) \\\\\n= \\tfrac{k}{2} \\left[x^2 - \\tfrac{2qE_x}{k} x\\right] + \\tfrac{k}{2} \\left[y^2 - \\tfrac{2qE_y}{k} y\\right] \\\\\n= \\tfrac{k}{2} \\left[\\left(x - \\tfrac{qE_x}{k}\\right)^2 - \\left(\\tfrac{qE_x}{k}\\right)^2\\right] + \\tfrac{k}{2} \\left[\\left(y - \\tfrac{qE_y}{k}\\right)^2 - \\left(\\tfrac{qE_y}{k}\\right)^2\\right] \\\\\n= \\tfrac{k}{2} \\left(x - \\tfrac{qE_x}{k}\\right)^2 + \\tfrac{k}{2} \\left(y - \\tfrac{qE_y}{k}\\right)^2 - \\tfrac{q^2}{2k}(E_x^2 + E_y^2)\n\\end{aligned}\n$$\n因此，概率密度函数为：\n$$\np(q;\\mathbf{r}) \\propto \\exp\\left\\{ -\\tfrac{k}{2} \\left[\\left(x - \\tfrac{qE_x}{k}\\right)^2 + \\left(y - \\tfrac{qE_y}{k}\\right)^2\\right] \\right\\}\n$$\n这是一个二元正态（高斯）分布 $\\mathcal{N}(\\boldsymbol{\\mu}(q), \\boldsymbol{\\Sigma})$ 的核。通过将指数与标准形式 $-\\frac{1}{2}(\\mathbf{r}-\\boldsymbol{\\mu})^T \\boldsymbol{\\Sigma}^{-1} (\\mathbf{r}-\\boldsymbol{\\mu})$进行比较，可以确定均值向量 $\\boldsymbol{\\mu}(q)$ 和协方差矩阵 $\\boldsymbol{\\Sigma}$。\n均值向量为：\n$$\n\\boldsymbol{\\mu}(q) = \\begin{pmatrix} \\mu_x(q) \\\\ \\mu_y(q) \\end{pmatrix} = \\begin{pmatrix} qE_x/k \\\\ qE_y/k \\end{pmatrix} = \\frac{q}{k}\\mathbf{E}\n$$\n逆协方差矩阵为 $\\boldsymbol{\\Sigma}^{-1} = k \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。因此，协方差矩阵为：\n$$\n\\boldsymbol{\\Sigma} = \\frac{1}{k}\\mathbf{I} = \\begin{pmatrix} 1/k  0 \\\\ 0  1/k \\end{pmatrix}\n$$\n此分析证明了粒子的位置 $(x,y)$ 服从一个二元正态分布，其分量不相关，且每个分量的方差为 $\\sigma^2 = 1/k$。为了生成状态 $A$ 和 $B$ 所需的样本，必须分别从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_A), \\boldsymbol{\\Sigma})$ 和 $\\mathcal{N}(\\boldsymbol{\\mu}(q_B), \\boldsymbol{\\Sigma})$ 中进行抽样。\n\n接下来，我们来处理 BAR 方程本身。该方程需要计算势能差 $\\Delta u(\\mathbf{r})$：\n$$\n\\Delta u(\\mathbf{r}) = u_B(\\mathbf{r}) - u_A(\\mathbf{r}) = u(q_B;\\mathbf{r}) - u(q_A;\\mathbf{r})\n$$\n$$\n\\Delta u(\\mathbf{r}) = \\left(\\tfrac{1}{2} k r^2 - q_B \\mathbf{E} \\cdot \\mathbf{r}\\right) - \\left(\\tfrac{1}{2} k r^2 - q_A \\mathbf{E} \\cdot \\mathbf{r}\\right) = -(q_B - q_A) \\mathbf{E} \\cdot \\mathbf{r}\n$$\n令 $\\Delta q = q_B - q_A$。则 $\\Delta u(\\mathbf{r}) = -\\Delta q \\, (\\mathbf{E} \\cdot \\mathbf{r})$。\n$\\Delta f_{BA}$ 的 BAR 方程为：\n$$\n\\left\\langle \\frac{1}{1+\\exp\\left(\\Delta u(\\mathbf{r}) - \\Delta f_{BA} - c\\right)} \\right\\rangle_A = \\left\\langle \\frac{1}{1+\\exp\\left(-\\Delta u(\\mathbf{r}) + \\Delta f_{BA} - c\\right)} \\right\\rangle_B\n$$\n其中 $\\langle \\cdot \\rangle_X$ 表示对从状态 $X$ 抽取的构型进行的样本平均，且 $c = \\ln(N_B/N_A)$。这是一个关于未知数 $\\Delta f_{BA}$ 的非线性方程。我们可以定义一个目标函数 $g(\\Delta f)$，其根即为所求的解：\n$$\ng(\\Delta f) = \\frac{1}{N_A} \\sum_{i=1}^{N_A} \\frac{1}{1+e^{\\Delta u(\\mathbf{r}_i^{(A)}) - \\Delta f - c}} - \\frac{1}{N_B} \\sum_{j=1}^{N_B} \\frac{1}{1+e^{-\\Delta u(\\mathbf{r}_j^{(B)}) + \\Delta f - c}}\n$$\n函数 $g(\\Delta f)$ 关于 $\\Delta f$ 是连续且严格单调递增的。当 $\\Delta f \\to -\\infty$ 时，$g(\\Delta f) \\to -1$。当 $\\Delta f \\to +\\infty$ 时，$g(\\Delta f) \\to 1$。因此，保证存在一个唯一的根使得 $g(\\Delta f) = 0$。这个根必须使用数值求根算法（例如 Brent 方法）来找到。\n\n对于这个特定问题，自由能差存在解析解，这可以作为对数值结果的关键检验。\n约化配分函数 $Z(q)$ 为：\n$$\nZ(q) = \\int e^{-u(q;\\mathbf{r})} d\\mathbf{r} = e^{\\frac{q^2 E^2}{2k}} \\int \\int e^{-\\frac{k}{2}(x-\\mu_x)^2} e^{-\\frac{k}{2}(y-\\mu_y)^2} dx dy\n$$\n其中 $E^2 = |\\mathbf{E}|^2$。每个积分都是一个标准的高斯积分，其值为 $\\sqrt{2\\pi/k}$。\n$$\nZ(q) = e^{\\frac{q^2 E^2}{2k}} \\left(\\frac{2\\pi}{k}\\right)\n$$\n约化自由能为 $f(q) = -\\ln Z(q) = -\\frac{q^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)$。因此，精确的自由能差为：\n$$\n\\Delta f_{BA} = f(q_B) - f(q_A) = \\left[-\\frac{q_B^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)\\right] - \\left[-\\frac{q_A^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)\\right] = -\\frac{(q_B^2 - q_A^2)E^2}{2k}\n$$\n使用有限数量的样本通过 BAR 方程数值估算出的 $\\Delta f_{BA}$ 应该是这个精确理论值的统计估计。\n\n计算步骤如下：\n1. 对每个测试用例，设置参数 $(k, q_A, q_B, \\mathbf{E}, N_A, N_B)$ 和随机数生成器种子。\n2. 从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_A), \\boldsymbol{\\Sigma})$ 中生成 $N_A$ 个样本 $\\mathbf{r}_i^{(A)}$，并从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_B), \\boldsymbol{\\Sigma})$ 中生成 $N_B$ 个样本 $\\mathbf{r}_j^{(B)}$。\n3. 对每组样本计算势能差数组：$\\Delta u_i^{(A)} = -\\Delta q (\\mathbf{E} \\cdot \\mathbf{r}_i^{(A)})$ 和 $\\Delta u_j^{(B)} = -\\Delta q (\\mathbf{E} \\cdot \\mathbf{r}_j^{(B)})$。\n4. 数值求解方程 $g(\\Delta f) = 0$ 以得到 $\\Delta f$，从而找到 $\\Delta f_{BA}$ 的 BAR 估计值。\n5. 对所有测试用例重复以上步骤，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the Bennett Acceptance Ratio (BAR) problem for a series of test cases.\n    For each case, it generates samples from the specified Boltzmann distributions,\n    then numerically solves the BAR equation to find the reduced free energy difference.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, q_A, q_B, E_x, E_y, N_A, N_B, seed)\n        (1.0, 0.0, 1.0, 0.8, -0.4, 20000, 20000, 12345),\n        (1.0, 0.7, 0.7, 1.2, -0.3, 15000, 15000, 54321),\n        (1.0, 0.5, 0.9, 1.0, 1.0, 5000, 20000, 2023),\n        (2.0, -0.6, 0.4, 0.0, 0.0, 10000, 10000, 777),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, q_A, q_B, E_x, E_y, N_A, N_B, seed = case\n\n        # Initialize the random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 1. Define system parameters.\n        E = np.array([E_x, E_y])\n        sigma = 1.0 / np.sqrt(k)\n\n        # 2. Generate samples for states A and B from their respective normal distributions.\n        mu_A = (q_A / k) * E\n        samples_A = rng.normal(loc=mu_A, scale=sigma, size=(N_A, 2))\n        \n        mu_B = (q_B / k) * E\n        samples_B = rng.normal(loc=mu_B, scale=sigma, size=(N_B, 2))\n\n        # 3. Calculate potential energy differences for the samples.\n        delta_q = q_B - q_A\n        du_samples_from_A = -delta_q * np.dot(samples_A, E)\n        du_samples_from_B = -delta_q * np.dot(samples_B, E)\n        \n        # 4. Solve the BAR equation for the free energy difference delta_f_BA.\n        c = np.log(N_B / N_A)\n\n        def bar_objective_function(delta_f):\n            # Calculate the two terms of the BAR equation, averaged per sample.\n            # Numerically stable evaluation of the logistic function is implicitly handled by numpy.\n            arg_A = du_samples_from_A - delta_f - c\n            term_A = 1.0 / (1.0 + np.exp(arg_A))\n            \n            arg_B = -du_samples_from_B + delta_f - c\n            term_B = 1.0 / (1.0 + np.exp(arg_B))\n            \n            return np.mean(term_A) - np.mean(term_B)\n\n        # Numerically find the root of the objective function.\n        try:\n            sol = root_scalar(bar_objective_function, bracket=[-100.0, 100.0], method='brentq')\n            delta_f_bar = sol.root\n        except ValueError:\n            # This fallback is for robustness, in case the root is not in the bracket.\n            delta_f_bar = np.nan\n        \n        results.append(delta_f_bar)\n\n    # Format the final results to six decimal places and print in the required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在成功实现BAR方法之后，下一步是探索其作为统计估计量的性质。这个练习将引导您进行一个“数值实验”，以研究BAR估计量在小样本量下的偏差。通过使用一个具有已知精确解的一维谐振子模型，您可以直接量化单次模拟得到的估计值与真实值之间的差异，从而对有限样本效应建立直观的理解。",
            "id": "2463439",
            "problem": "设有两种经典一维谐振子态，分别表示为态 $\\mathrm{A}$ 和态 $\\mathrm{B}$。对于构型 $x \\in \\mathbb{R}$，其在态 $\\mathrm{A}$ 中的约化势能（以玻尔兹曼常数与温度的乘积 $k_{\\mathrm{B}}T$ 为单位）为 $u_{\\mathrm{A}}(x) = \\tfrac{1}{2} k_{\\mathrm{A}} (x - \\mu_{\\mathrm{A}})^{2}$，在态 $\\mathrm{B}$ 中为 $u_{\\mathrm{B}}(x) = \\tfrac{1}{2} k_{\\mathrm{B}} (x - \\mu_{\\mathrm{B}})^{2}$。假设逆温度为 $\\beta = 1$，因此所有能量均以 $k_{\\mathrm{B}}T$ 为单位，是无量纲的。对于此类谐振子，态 $\\mathrm{X} \\in \\{\\mathrm{A},\\mathrm{B}\\}$ 的经典构型配分函数为 $Z_{\\mathrm{X}} = \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-u_{\\mathrm{X}}(x)\\right)\\,\\mathrm{d}x = \\sqrt{\\tfrac{2\\pi}{k_{\\mathrm{X}}}}$，约化自由能为 $F_{\\mathrm{X}} = -\\ln Z_{\\mathrm{X}}$。因此，精确的约化自由能差为 $\\Delta F_{\\mathrm{exact}} = F_{\\mathrm{B}} - F_{\\mathrm{A}} = \\tfrac{1}{2}\\ln\\!\\left(\\tfrac{k_{\\mathrm{B}}}{k_{\\mathrm{A}}}\\right)$。\n\n假设您从态 $\\mathrm{A}$ 的正则分布中独立采样 $N_{\\mathrm{A}}$ 个构型 $\\{x_{i}\\}_{i=1}^{N_{\\mathrm{A}}}$，并从态 $\\mathrm{B}$ 的正则分布中独立采样 $N_{\\mathrm{B}}$ 个构型 $\\{y_{j}\\}_{j=1}^{N_{\\mathrm{B}}}$。对于在 $\\beta=1$ 下，势能为 $u_{\\mathrm{X}}(x) = \\tfrac{1}{2} k_{\\mathrm{X}} (x - \\mu_{\\mathrm{X}})^{2}$ 的一维谐振子，其在态 $\\mathrm{X}$ 中 $x$ 的平衡分布是均值为 $\\mu_{\\mathrm{X}}$、方差为 $1/k_{\\mathrm{X}}$ 的高斯分布。定义约化能量差为 $\\Delta u_{i} = u_{\\mathrm{B}}(x_{i}) - u_{\\mathrm{A}}(x_{i})$（对于 $i \\in \\{1,\\dots,N_{\\mathrm{A}}\\}$）和 $\\Delta u'_{j} = u_{\\mathrm{A}}(y_{j}) - u_{\\mathrm{B}}(y_{j})$（对于 $j \\in \\{1,\\dots,N_{\\mathrm{B}}\\}$）。\n\nBennett 接受率 (BAR) 估计方法将约化自由能差 $\\Delta F$ 的估计值 $\\widehat{\\Delta f}$ 定义为以下方程的唯一解：\n$$\n\\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u_{i} - \\widehat{\\Delta f} + \\ln\\!\\left(\\tfrac{N_{\\mathrm{A}}}{N_{\\mathrm{B}}}\\right)\\right)} \\;=\\;\n\\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u'_{j} + \\widehat{\\Delta f} - \\ln\\!\\left(\\tfrac{N_{\\mathrm{A}}}{N_{\\mathrm{B}}}\\right)\\right)} \\, .\n$$\n对于单次样本实现，将偏差定义为 $b = \\widehat{\\Delta f} - \\Delta F_{\\mathrm{exact}}$。\n\n你的任务是为以下每个测试用例计算偏差 $b$。所有量都是无量纲的（以 $k_{\\mathrm{B}}T$ 为单位）。对于每个用例，使用指定的随机种子从指定的高斯平衡分布中抽取独立样本，从上面的 BAR 方程计算 $\\widehat{\\Delta f}$，并报告四舍五入到 $6$ 位小数的偏差 $b$。\n\n测试套件（每个元组为 $(k_{\\mathrm{A}}, \\mu_{\\mathrm{A}}, k_{\\mathrm{B}}, \\mu_{\\mathrm{B}}, N_{\\mathrm{A}}, N_{\\mathrm{B}}, \\text{seed})$）：\n- 用例 1：$(1.0, 0.0, 2.0, 0.0, 8, 8, 12345)$\n- 用例 2：$(1.0, 0.0, 1.0, 3.0, 5, 5, 54321)$\n- 用例 3：$(0.5, -1.0, 5.0, 1.0, 4, 4, 2024)$\n- 用例 4：$(1.0, 0.0, 3.0, 0.0, 2, 9, 777)$\n- 用例 5：$(1.0, 0.0, 1.0, 0.0, 1, 1, 999)$\n\n你的程序必须产生单行输出，其中包含一个按用例顺序排列的、由五个偏差组成的逗号分隔列表，并用方括号括起来，例如 $[\\text{bias}_{1},\\text{bias}_{2},\\text{bias}_{3},\\text{bias}_{4},\\text{bias}_{5}]$，每个 $\\text{bias}_{i}$ 都四舍五入到 $6$ 位小数。输出值是无量纲的。不应打印任何其他文本。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在统计力学领域提出了一个适定且有科学依据的计算问题。模型系统（经典一维谐振子）和所用方法（Bennett 接受率，BAR）均为标准方法且描述正确。所有参数和流程都已明确定义，确保了问题的自洽性，并允许得到一个唯一的、可验证的解。我们将着手进行计算。\n\n任务是为五个不同的用例计算 BAR 自由能估计量的偏差 $b = \\widehat{\\Delta f} - \\Delta F_{\\mathrm{exact}}$。估计值 $\\widehat{\\Delta f}$ 是从模拟数据中计算出的自由能差，而 $\\Delta F_{\\mathrm{exact}}$ 是其解析值。\n\n首先，我们确定解析量。两个态 $\\mathrm{A}$ 和 $\\mathrm{B}$ 的约化势能由以下公式给出：\n$$\nu_{\\mathrm{A}}(x) = \\frac{1}{2} k_{\\mathrm{A}} (x - \\mu_{\\mathrm{A}})^{2}\n$$\n$$\nu_{\\mathrm{B}}(x) = \\frac{1}{2} k_{\\mathrm{B}} (x - \\mu_{\\mathrm{B}})^{2}\n$$\n这些态之间的精确约化自由能差为：\n$$\n\\Delta F_{\\mathrm{exact}} = F_{\\mathrm{B}} - F_{\\mathrm{A}} = \\frac{1}{2}\\ln\\!\\left(\\frac{k_{\\mathrm{B}}}{k_{\\mathrm{A}}}\\right)\n$$\n该公式由谐振子的经典配分函数推导得出，并将用作计算偏差的参考值。\n\n计算过程涉及生成有限的构型样本。对于态 $\\mathrm{A}$，从其正则分布中抽取 $N_{\\mathrm{A}}$ 个构型 $\\{x_i\\}_{i=1}^{N_{\\mathrm{A}}}$。对于谐振子，该分布是均值为 $\\mu_{\\mathrm{A}}$、方差为 $\\sigma^2_{\\mathrm{A}} = 1/k_{\\mathrm{A}}$ 的高斯分布。类似地，对于态 $\\mathrm{B}$，从均值为 $\\mu_{\\mathrm{B}}$、方差为 $\\sigma^2_{\\mathrm{B}} = 1/k_{\\mathrm{B}}$ 的高斯分布中抽取 $N_{\\mathrm{B}}$ 个构型 $\\{y_j\\}_{j=1}^{N_{\\mathrm{B}}}$。为保证可复现性，将使用指定的种子生成随机样本。\n\n获得样本后，我们计算功值。正向功值是在态 $\\mathrm{A}$ 的样本上计算的能量差：\n$$\n\\Delta u_{i} = u_{\\mathrm{B}}(x_{i}) - u_{\\mathrm{A}}(x_{i}), \\quad i = 1, \\dots, N_{\\mathrm{A}}\n$$\n反向功值是在态 $\\mathrm{B}$ 的样本上计算的：\n$$\n\\Delta u'_{j} = u_{\\mathrm{A}}(y_{j}) - u_{\\mathrm{B}}(y_{j}), \\quad j = 1, \\dots, N_{\\mathrm{B}}\n$$\n\n自由能差的 BAR 估计值 $\\widehat{\\Delta f}$ 是以下隐式方程的解：\n$$\n\\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u_{i} - \\widehat{\\Delta f} + C \\right)} = \\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u'_{j} + \\widehat{\\Delta f} - C \\right)}\n$$\n其中 $C = \\ln(N_{\\mathrm{A}}/N_{\\mathrm{B}})$。为了求得 $\\widehat{\\Delta f}$，我们将方程的左侧 (LHS) 与右侧 (RHS) 之差定义为一个函数 $G(\\widehat{\\Delta f})$，该函数必须等于零：\n$$\nG(\\widehat{\\Delta f}) = \\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u_{i} - \\widehat{\\Delta f} + C \\right)} - \\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u'_{j} + \\widehat{\\Delta f} - C \\right)} = 0\n$$\n函数 $G(\\widehat{\\Delta f})$ 是严格单调的。它对 $\\widehat{\\Delta f}$ 的一阶导数为：\n$$\n\\frac{dG}{d\\widehat{\\Delta f}} = \\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{\\exp(\\dots)}{(1+\\exp(\\dots))^2} + \\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{\\exp(\\dots)}{(1+\\exp(\\dots))^2}\n$$\n其中指数的参数与 $G(\\widehat{\\Delta f})$ 定义中的相同。由于该导数是严格正项之和，所以 $G(\\widehat{\\Delta f})$ 是 $\\widehat{\\Delta f}$ 的一个严格递增函数。这一性质，以及当 $\\widehat{\\Delta f} \\to -\\infty$ 时 $G(\\widehat{\\Delta f})$ 渐近于 $-N_{\\mathrm{B}}$、当 $\\widehat{\\Delta f} \\to +\\infty$ 时渐近于 $N_{\\mathrm{A}}$ 的事实，保证了根的唯一性。我们将使用一个稳健的数值算法来求解这个根，具体而言是 Brent-Dekker 方法（来自 SciPy 库的 `brentq` 函数），该方法对于求解有界单调函数的根是高效且可靠的。\n\n对于每个测试用例，将通过编程执行以下步骤：\n1.  设置随机数生成器种子。\n2.  从 $N(\\mu_{\\mathrm{A}}, 1/k_{\\mathrm{A}})$ 生成 $N_{\\mathrm{A}}$ 个样本，从 $N(\\mu_{\\mathrm{B}}, 1/k_{\\mathrm{B}})$ 生成 $N_{\\mathrm{B}}$ 个样本。\n3.  计算 $\\Delta u_i$ 和 $\\Delta u'_j$ 的数组。\n4.  数值求解 $G(\\widehat{\\Delta f}) = 0$ 以得到 $\\widehat{\\Delta f}$。\n5.  计算 $\\Delta F_{\\mathrm{exact}} = \\frac{1}{2} \\ln(k_{\\mathrm{B}}/k_{\\mathrm{A}})$。\n6.  计算偏差 $b = \\widehat{\\Delta f} - \\Delta F_{\\mathrm{exact}}$。\n7.  每个用例的最终结果按要求四舍五入到 $6$ 位小数。然后将整套结果格式化为指定的列表格式。此系统化过程将在提供的 Python 脚本中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the bias of the Bennett Acceptance Ratio (BAR) estimator for a series of test cases\n    involving one-dimensional harmonic oscillators.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kA, muA, kB, muB, NA, NB, seed)\n        (1.0, 0.0, 2.0, 0.0, 8, 8, 12345),\n        (1.0, 0.0, 1.0, 3.0, 5, 5, 54321),\n        (0.5, -1.0, 5.0, 1.0, 4, 4, 2024),\n        (1.0, 0.0, 3.0, 0.0, 2, 9, 777),\n        (1.0, 0.0, 1.0, 0.0, 1, 1, 999)\n    ]\n\n    results = []\n    for case in test_cases:\n        kA, muA, kB, muB, NA, NB, seed = case\n\n        # Set up random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Generate samples from equilibrium distributions\n        # State A: Gaussian with mean muA, variance 1/kA\n        std_dev_A = np.sqrt(1.0 / kA)\n        samples_A = rng.normal(loc=muA, scale=std_dev_A, size=NA)\n\n        # State B: Gaussian with mean muB, variance 1/kB\n        std_dev_B = np.sqrt(1.0 / kB)\n        samples_B = rng.normal(loc=muB, scale=std_dev_B, size=NB)\n\n        # Define reduced potential energy functions\n        def uA(x):\n            return 0.5 * kA * (x - muA)**2\n        \n        def uB(x):\n            return 0.5 * kB * (x - muB)**2\n\n        # Calculate energy differences (work values)\n        delta_u_fwd = uB(samples_A) - uA(samples_A)\n        delta_u_rev = uA(samples_B) - uB(samples_B)\n        \n        # Constant term in the BAR equation exponent\n        log_N_ratio = np.log(NA / NB)\n\n        # Define the function whose root is the BAR estimate df_hat\n        def bar_equation(df_hat):\n            \"\"\"\n            Represents the BAR equation in the form G(df_hat) = 0.\n            \"\"\"\n            # Term for forward samples (A -> B)\n            arg_fwd = delta_u_fwd - df_hat + log_N_ratio\n            sum_fwd = np.sum(1.0 / (1.0 + np.exp(arg_fwd)))\n            \n            # Term for reverse samples (B -> A)\n            arg_rev = delta_u_rev + df_hat - log_N_ratio\n            sum_rev = np.sum(1.0 / (1.0 + np.exp(arg_rev)))\n            \n            return sum_fwd - sum_rev\n\n        # Solve for df_hat using a numerical root finder.\n        # A wide bracket [-100, 100] is safe as the function is monotonic\n        # and crosses zero within this range for any reasonable inputs.\n        try:\n            df_hat = brentq(bar_equation, -100.0, 100.0)\n        except ValueError:\n            # This should not be reached due to the function's monotonic properties.\n            # Included for robustness in principle.\n            df_hat = np.nan\n\n        # Calculate exact free energy difference\n        df_exact = 0.5 * np.log(kB / kA)\n\n        # Calculate the bias\n        bias = df_hat - df_exact\n        \n        # Round to 6 decimal places and append to results list\n        results.append(round(bias, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将理论公式转化为稳健的计算机代码，需要对数值计算的细节有充分的认识。这个练习聚焦于BAR方程中的一个核心部分——费米函数。您将学习如何通过巧妙的代数变换来处理直接计算可能导致的浮点数溢出问题，这是确保科学计算结果可靠性的关键一步，也是一项重要的编程实践。",
            "id": "2463465",
            "problem": "给定在计算化学中用于计算自由能差的贝内特接受率方法（BAR, Bennett acceptance ratio method）中出现的费米函数 $f(x)$ 的定义：\n$$\nf(x) = \\frac{1}{1 + e^{x}}.\n$$\n在标准的双精度浮点运算中，直接计算 $e^{x}$ 会在 $x$ 为大的正数时导致上溢，在 $x$ 为大的负数时导致严重的下溢。您的任务是使用双精度运算，为所有实数 $x$ 实现一个数值稳定的 $f(x)$ 计算方法。对于所有的实数输入 $x$，您的实现必须返回一个在 $[0,1]$ 区间内的有限结果。\n\n实现一个程序，该程序：\n- 在双精度运算下，使用数值稳定的方案计算上述定义的 $f(x)$。\n- 将此计算应用于以下有序的输入测试集：\n  - $x \\in \\{-1000,\\,-745,\\,-100,\\,-50,\\,-10^{-12},\\,0,\\,10^{-12},\\,50,\\,100,\\,709,\\,710,\\,1000\\}$。\n- 以与输入完全相同的顺序生成 $f(x)$ 的结果。\n\n要求和输出规范：\n- 所有计算均使用双精度运算。\n- 最终的程序输出必须是单行，包含一个用方括号括起来的逗号分隔的结果列表，其中的值按测试输入的顺序排列。例如，要求的格式如“[result1,result2,result3,...]”。\n- 输出是实数（浮点值）。此问题不涉及物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。",
            "solution": "问题陈述已提交以供验证。\n\n步骤1：提取已知信息\n-   函数定义：费米函数为 $f(x) = \\frac{1}{1 + e^{x}}$。\n-   数值挑战：对 $e^{x}$ 进行标准双精度计算会在 $x$ 为大的正数时导致上溢，在 $x$ 为大的负数时导致下溢。\n-   任务：实现一个数值稳定的方法来计算所有实数 $x$ 的 $f(x)$，并返回一个在区间 $[0, 1]$ 内的有限值。\n-   测试输入：$x \\in \\{-1000,\\,-745,\\,-100,\\,-50,\\,-10^{-12},\\,0,\\,10^{-12},\\,50,\\,100,\\,709,\\,710,\\,1000\\}$。\n-   计算精度：双精度运算。\n-   输出格式：单行输出，结果为用方括号括起来的逗号分隔列表。\n\n步骤2：使用提取的已知信息进行验证\n对问题进行严格审查。\n-   **科学依据**：该问题在数值分析和计算科学领域有坚实的基础。费米函数（或逻辑S型函数）是基础函数，其直接计算中可能出现的浮点数上溢和下溢是科学计算中的一个经典且无争议的问题。指定的输入值（如 $709$ 和 $710$）被正确选择，用以探测标准64位双精度运算中 $e^x$ 的上溢边界，其中上溢阈值约为 $x \\approx 709.78$。\n-   **适定性**：该问题是适定的。它要求实现一个算法来克服一个特定且明确定义的数值不稳定性。通过标准的数值技术可以获得唯一且稳定的解。\n-   **客观性**：该问题以精确、客观且无歧义的术语陈述。它不含任何主观或基于意见的内容。\n\n步骤3：结论与行动\n该问题被判定为**有效的**。这是一个数值编程的标准练习，既科学合理又明确规定。开始进行求解。\n\n一个鲁棒的解法需要分析函数的行为以及浮点运算的局限性。该函数由下式给出：\n$$\nf(x) = \\frac{1}{1 + e^{x}}\n$$\n我们针对输入变量 $x$ 的不同区间，分析该表达式的数值稳定性。\n\n情况1：$x$ 为大的正数。\n对于大的正数 $x$，$e^x$ 项会指数增长。在标准的 IEEE $754$ 双精度运算中，可表示的最大有限值约为 $1.8 \\times 10^{308}$。当 $x > \\ln(1.8 \\times 10^{308}) \\approx 709.78$ 时，指数函数 $e^x$ 将发生上溢。对于像 $710$ 或 $1000$ 这样的 $x$ 值进行直接计算会导致一个中间的无穷大值，这是一种不良的数值实践，即使浮点单元根据其对 `inf` 的处理规则最终能正确地解析出结果 $0$。\n\n为了创建一个稳定的算法，我们必须重构表达式以避免在 $x$ 为正数时计算 $e^x$。我们可以将分子和分母同乘以 $e^{-x}$：\n$$\nf(x) = \\frac{1}{1 + e^{x}} = \\frac{e^{-x}}{e^{-x}(1 + e^{x})} = \\frac{e^{-x}}{e^{-x} + 1}\n$$\n在这种替代形式中，如果 $x$ 是正数，那么 $-x$ 就是负数。计算 $e^{-x}$ 将得到一个介于 $0$ 和 $1$ 之间的值，从而防止上溢。对于 $x \\ge 0$，这种形式是数值稳定的。\n\n情况2：$x$ 为大的负数。\n对于大的负数 $x$，$e^x$ 项趋近于 $0$。在双精度下，当 $x  \\ln(2.2 \\times 10^{-308}) \\approx -708.4$ 时，$e^x$ 将下溢为精确的 $0$。在这种情况下，直接计算 $f(x) = \\frac{1}{1 + e^x}$ 变为 $\\frac{1}{1 + 0} = 1$。这个计算是数值稳定的，并能给出正确的极限值。没有上溢或灾难性抵消的风险。\n\n情况3：$x$ 接近 $0$。\n对于 $x=0$，两种形式都得到 $f(0) = \\frac{1}{1+e^0} = \\frac{1}{2}$，这是稳定的。\n\n基于此分析，一个根据 $x$ 的符号选择适当公式的混合算法，可在整个实数轴上提供完全的数值稳定性。\n\n提出的稳定算法如下：\n-   如果 $x  0$，使用原始形式：$f(x) = \\frac{1}{1 + e^x}$。指数函数的参数为负，确保了稳定性。\n-   如果 $x \\ge 0$，使用代数等价形式：$f(x) = \\frac{e^{-x}}{1 + e^{-x}}$。指数函数的参数为非正数，同样确保了稳定性。\n\n该策略保证了传递给指数函数的参数总是小于或等于零，从而鲁棒地防止上溢，并为任何实数输入 $x$ 产生有限结果。现在将此实现应用于提供的测试输入集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Fermi function f(x) = 1/(1 + exp(x)) for a given set of\n    test inputs using a numerically stable scheme. The final results are\n    printed in the specified format.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        -1000.0,\n        -745.0,\n        -100.0,\n        -50.0,\n        -1.0e-12,\n        0.0,\n        1.0e-12,\n        50.0,\n        100.0,\n        709.0,\n        710.0,\n        1000.0\n    ]\n\n    def stable_fermi(x: float) -> float:\n        \"\"\"\n        Calculates the Fermi function f(x) = 1 / (1 + exp(x)) in a\n        numerically stable manner.\n\n        The method switches between two algebraically equivalent forms of the\n        function based on the sign of x to prevent floating-point overflow.\n\n        Args:\n            x: A real number (float).\n\n        Returns:\n            The value of f(x) as a float.\n        \"\"\"\n        # For x < 0, the argument to exp(x) is negative, so the direct\n        # evaluation is stable and does not risk overflow.\n        if x < 0.0:\n            return 1.0 / (1.0 + np.exp(x))\n        else:\n            # For x >= 0, exp(x) can overflow for large x.\n            # We use the equivalent form f(x) = exp(-x) / (1 + exp(-x)).\n            # The argument to the exponential, -x, is non-positive,\n            # which prevents overflow.\n            exp_neg_x = np.exp(-x)\n            return exp_neg_x / (1.0 + exp_neg_x)\n\n    # Calculate the results for all test cases.\n    results = [stable_fermi(x) for x in test_cases]\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) is used to format numbers without trailing zeros\n    # for cleaner representation, though standard float conversion is sufficient.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}