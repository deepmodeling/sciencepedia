{
    "hands_on_practices": [
        {
            "introduction": "驻留时间算法的核心是其坚实的概率论基础。本练习将引导你从第一性原理出发，通过分析竞争性的泊松过程，推导系统在当前状态的驻留时间 ($\\Delta t$) 的概率分布。完成这个推导将使你深刻理解为何 KMC 模拟中的时间步长是从一个总速率为 $R_{\\text{tot}}$ 的指数分布中抽取的，这是掌握该算法的基石。",
            "id": "3851130",
            "problem": "考虑一个晶体表面的动力学蒙特卡洛（KMC）模拟，在任何时刻都可能发生三个独立的基本过程：空位跳跃、吸附原子脱附和近邻交换。假设每个过程都被建模为一个独立的泊松过程，其速率分别为恒定的 $r_{1}$、$r_{2}$ 和 $r_{3}$，并且模拟使用驻留时间算法将时钟推进到下一个事件，时间增量为 $\\Delta t$。驻留时间算法所依据的物理假设是，下一个事件的时间是这些独立泊松过程中的首次到达时间，并且该过程是马尔可夫过程。\n\n从事件的独立性以及生存函数 $S(t)$（即到时间 $t$ 为止没有事件发生的概率）的定义出发，推导 $\\Delta t$ 的概率密度函数 $f_{\\Delta t}(t)$，并用总速率 $R_{\\text{tot}}=\\sum_{i=1}^{3} r_{i}$ 表示。然后，利用这个 $f_{\\Delta t}(t)$，计算期望值 $\\mathbb{E}[\\Delta t]$ 和方差 $\\mathrm{Var}[\\Delta t]$，并将它们表示为 $R_{\\text{tot}}$ 的函数。\n\n最后，将速率实例化为 $r_{1}=3\\,\\mathrm{s}^{-1}$、$r_{2}=5\\,\\mathrm{s}^{-1}$ 和 $r_{3}=2\\,\\mathrm{s}^{-1}$，并计算 $\\mathbb{E}[\\Delta t]$（以秒为单位）和 $\\mathrm{Var}[\\Delta t]$（以秒的平方为单位）的数值。提供精确的数值；无需四舍五入。按 $\\mathbb{E}[\\Delta t]$、$\\mathrm{Var}[\\Delta t]$ 的顺序报告最终的数值对。",
            "solution": "首先将根据所需标准对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 三个独立的基本过程：空位跳跃、吸附原子脱附、近邻交换。\n- 每个过程被建模为独立的泊松过程，速率分别为恒定的 $r_{1}$、$r_{2}$ 和 $r_{3}$。\n- 模拟使用驻留时间算法将时钟推进时间 $\\Delta t$ 到下一个事件。\n- 物理假设：$\\Delta t$ 是独立泊松过程中的首次到达时间。该过程是马尔可夫过程。\n- 出发点：生存函数 $S(t)$ 是到时间 $t$ 为止没有事件发生的概率。\n- 总速率定义为 $R_{\\text{tot}}=\\sum_{i=1}^{3} r_{i}$。\n- 目标1：推导 $\\Delta t$ 的概率密度函数 $f_{\\Delta t}(t)$，并用 $R_{\\text{tot}}$ 表示。\n- 目标2：计算期望值 $\\mathbb{E}[\\Delta t]$ 和方差 $\\mathrm{Var}[\\Delta t]$，并将它们表示为 $R_{\\text{tot}}$ 的函数。\n- 目标3：将速率实例化为 $r_{1}=3\\,\\mathrm{s}^{-1}$、$r_{2}=5\\,\\mathrm{s}^{-1}$ 和 $r_{3}=2\\,\\mathrm{s}^{-1}$。\n- 目标4：计算 $\\mathbb{E}[\\Delta t]$ 和 $\\mathrm{Var}[\\Delta t]$ 的数值，并按指定顺序报告。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行审查。\n\n- **科学性（关键）**：该问题坚实地建立在随机过程理论之上，特别是泊松过程和指数分布。驻留时间算法（也称为 BKL 算法或标准 KMC）是计算材料科学和化学中一个基础且广泛使用的方法。其假设（独立的泊松过程、马尔可夫行为）是此类模型的标准假设。该问题在科学上是合理的。\n- **适定性**：该问题提供了推导所求量所需的所有必要信息。在概率论的框架内，速率、概率和时间演化之间的关系被明确定义。存在唯一且有意义的解。\n- **客观性（关键）**：语言精确、量化，没有任何主观或含糊的术语。任务是明确陈述的数学目标。\n\n### 步骤3：结论与行动\n该问题是**有效的**。它是统计力学和模拟理论中一个标准的、适定的问题。现在开始求解过程。\n\n### 解题推导\n\n设 $T_i$ 为第 $i$ 个过程的等待时间，其中 $i \\in \\{1, 2, 3\\}$。由于每个过程都是速率为 $r_i$ 的泊松过程，等待时间 $T_i$ 是一个服从参数为 $r_i$ 的指数分布的随机变量。$T_i$ 的概率密度函数（PDF）为 $f_{T_i}(t) = r_i \\exp(-r_i t)$（当 $t \\ge 0$），累积分布函数（CDF）为 $F_{T_i}(t) = P(T_i \\le t) = 1 - \\exp(-r_i t)$。\n\n第 $i$ 个过程的生存函数 $S_i(t)$ 是指到时间 $t$ 为止过程 $i$ 尚未发生的概率。它由下式给出：\n$$S_i(t) = P(T_i  t) = 1 - F_{T_i}(t) = \\exp(-r_i t)$$\n\nKMC 模拟中到下一个事件发生的时间 $\\Delta t$ 是所有可能的独立过程的等待时间中的最小值。\n$$\\Delta t = \\min(T_1, T_2, T_3)$$\n\n根据问题陈述，$\\Delta t$ 的生存函数记为 $S(t)$，表示到下一个事件发生的时间大于 $t$ 的概率。这等价于到时间 $t$ 为止三个事件均未发生的概率。\n$$S(t) = P(\\Delta t  t) = P(\\min(T_1, T_2, T_3)  t)$$\n\n要使几个随机变量的最小值大于 $t$，每个单独的随机变量都必须大于 $t$。\n$$S(t) = P(T_1  t \\text{ and } T_2  t \\text{ and } T_3  t)$$\n\n由于这些过程是独立的，其联合概率是各个概率的乘积：\n$$S(t) = P(T_1  t) P(T_2  t) P(T_3  t) = S_1(t) S_2(t) S_3(t)$$\n\n代入各个生存函数的表达式：\n$$S(t) = \\exp(-r_1 t) \\exp(-r_2 t) \\exp(-r_3 t) = \\exp(-(r_1 + r_2 + r_3)t)$$\n\n使用总速率的定义 $R_{\\text{tot}} = r_1 + r_2 + r_3$，生存函数变为：\n$$S(t) = \\exp(-R_{\\text{tot}} t)$$\n\n概率密度函数 $f_{\\Delta t}(t)$ 可以通过对生存函数关于 $t$ 求负导数得到。\n$$f_{\\Delta t}(t) = -\\frac{d}{dt}S(t) = -\\frac{d}{dt}\\left(\\exp(-R_{\\text{tot}} t)\\right) = -(-R_{\\text{tot}} \\exp(-R_{\\text{tot}} t))$$\n$$f_{\\Delta t}(t) = R_{\\text{tot}} \\exp(-R_{\\text{tot}} t) \\quad \\text{for } t \\ge 0$$\n这是一个速率参数为 $R_{\\text{tot}}$ 的指数分布的概率密度函数。\n\n接下来，我们计算期望值 $\\mathbb{E}[\\Delta t]$ 和方差 $\\mathrm{Var}[\\Delta t]$。\n根据定义计算期望值：\n$$\\mathbb{E}[\\Delta t] = \\int_{0}^{\\infty} t f_{\\Delta t}(t) dt = \\int_{0}^{\\infty} t (R_{\\text{tot}} \\exp(-R_{\\text{tot}} t)) dt$$\n我们使用分部积分法 $\\int u \\, dv = uv - \\int v \\, du$，令 $u = t$ 且 $dv = R_{\\text{tot}} \\exp(-R_{\\text{tot}} t) dt$。可得 $du = dt$ 和 $v = -\\exp(-R_{\\text{tot}} t)$。\n$$\\mathbb{E}[\\Delta t] = \\left[ -t \\exp(-R_{\\text{tot}} t) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} (-\\exp(-R_{\\text{tot}} t)) dt$$\n第一项的值为 $0$，因为当 $R_{\\text{tot}}  0$ 时，$\\lim_{t\\to\\infty} t \\exp(-R_{\\text{tot}} t) = 0$。\n$$\\mathbb{E}[\\Delta t] = \\int_{0}^{\\infty} \\exp(-R_{\\text{tot}} t) dt = \\left[ -\\frac{1}{R_{\\text{tot}}} \\exp(-R_{\\text{tot}} t) \\right]_{0}^{\\infty} = 0 - \\left(-\\frac{1}{R_{\\text{tot}}}\\right) = \\frac{1}{R_{\\text{tot}}}$$\n\n为了求方差，我们首先计算二阶矩 $\\mathbb{E}[(\\Delta t)^2]$。\n$$\\mathbb{E}[(\\Delta t)^2] = \\int_{0}^{\\infty} t^2 f_{\\Delta t}(t) dt = \\int_{0}^{\\infty} t^2 (R_{\\text{tot}} \\exp(-R_{\\text{tot}} t)) dt$$\n再次使用分部积分法，令 $u = t^2$ 且 $dv = R_{\\text{tot}} \\exp(-R_{\\text{tot}} t) dt$。可得 $du = 2t \\, dt$ 和 $v = -\\exp(-R_{\\text{tot}} t)$。\n$$\\mathbb{E}[(\\Delta t)^2] = \\left[ -t^2 \\exp(-R_{\\text{tot}} t) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} (-\\exp(-R_{\\text{tot}} t))(2t) dt$$\n第一项为 $0$。\n$$\\mathbb{E}[(\\Delta t)^2] = 2 \\int_{0}^{\\infty} t \\exp(-R_{\\text{tot}} t) dt$$\n我们可以看出这个积分与期望值的计算有关。由 $\\mathbb{E}[\\Delta t] = R_{\\text{tot}} \\int_{0}^{\\infty} t \\exp(-R_{\\text{tot}} t) dt = \\frac{1}{R_{\\text{tot}}}$，我们知道 $\\int_{0}^{\\infty} t \\exp(-R_{\\text{tot}} t) dt = \\frac{1}{R_{\\text{tot}}^2}$。\n$$\\mathbb{E}[(\\Delta t)^2] = 2 \\left( \\frac{1}{R_{\\text{tot}}^2} \\right) = \\frac{2}{R_{\\text{tot}}^2}$$\n\n方差由 $\\mathrm{Var}[\\Delta t] = \\mathbb{E}[(\\Delta t)^2] - (\\mathbb{E}[\\Delta t])^2$ 给出。\n$$\\mathrm{Var}[\\Delta t] = \\frac{2}{R_{\\text{tot}}^2} - \\left(\\frac{1}{R_{\\text{tot}}}\\right)^2 = \\frac{1}{R_{\\text{tot}}^2}$$\n\n最后，我们代入给定的速率数值：\n$r_{1}=3\\,\\mathrm{s}^{-1}$、$r_{2}=5\\,\\mathrm{s}^{-1}$ 和 $r_{3}=2\\,\\mathrm{s}^{-1}$。\n总速率 $R_{\\text{tot}}$ 为：\n$$R_{\\text{tot}} = r_1 + r_2 + r_3 = 3\\,\\mathrm{s}^{-1} + 5\\,\\mathrm{s}^{-1} + 2\\,\\mathrm{s}^{-1} = 10\\,\\mathrm{s}^{-1}$$\n\n现在我们可以计算期望值和方差：\n$$\\mathbb{E}[\\Delta t] = \\frac{1}{R_{\\text{tot}}} = \\frac{1}{10\\,\\mathrm{s}^{-1}} = 0.1\\,\\mathrm{s}$$\n$$\\mathrm{Var}[\\Delta t] = \\frac{1}{R_{\\text{tot}}^2} = \\frac{1}{(10\\,\\mathrm{s}^{-1})^2} = \\frac{1}{100\\,\\mathrm{s}^{-2}} = 0.01\\,\\mathrm{s}^2$$\n\n所要求的数值为期望值 $0.1$ 和方差 $0.01$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.1  0.01 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了基本原理之后，下一步是将驻留时间算法应用于一个更接近真实物理系统的复杂模型。本练习提出了一个耦合了内部状态切换的一维扩散模型，要求你推导其均方位移的解析解，并构建 KMC 模拟来验证你的理论结果。这项综合性任务将全面锻炼你连接理论分析与计算模拟的能力，是检验 KMC 应用水平的试金石。",
            "id": "3851178",
            "problem": "考虑一个间距为 $a$（单位：米）的一维晶格。一个点状粒子通过对称的最近邻跳跃在该晶格上移动，并具有一个内部双通道状态 $S(t) \\in \\{A,B\\}$。跳跃速率和通道切换速率取决于当前通道。具体来说，当 $S(t)=A$ 时，粒子以 $r_A/2$ 的速率（单位：$\\mathrm{s}^{-1}$）尝试向左和向右跳跃，因此在通道 $A$ 中的总跳跃速率为 $r_A$；并以 $k_{AB}$ 的速率（单位：$\\mathrm{s}^{-1}$）从通道 $A$ 切换到通道 $B$。类似地，当 $S(t)=B$ 时，向左和向右的跳跃速率各为 $r_B/2$，因此在通道 $B$ 中的总跳跃速率为 $r_B$，且从通道 $B$ 切换到通道 $A$ 的速率为 $k_{BA}$（单位：$\\mathrm{s}^{-1}$）。设初始时处于通道 $A$ 的概率为 $p_A(0)$，则 $p_B(0)=1-p_A(0)$，初始位置为 $x(0)=0$。\n\n您需要 (i) 从连续时间马尔可夫链和泊松跳跃过程的第一性原理出发，解析求解此耦合跳跃-切换过程的均方位移 $\\mathbb{E}[x(t)^2]$（单位：$\\mathrm{m}^2$），以及 (ii) 使用驻留时间算法（Residence Time Algorithm, RTA）实现一个动力学蒙特卡洛（Kinetic Monte Carlo, KMC）模拟，以生成轨迹并在指定的最终时间 $t_{\\mathrm{end}}$（单位：秒）凭经验估算均方位移。您的 KMC 模拟应如下处理当前状态的事件：从通道 $A$ 出发，事件集为 $\\{ \\text{以速率 } r_A/2 \\text{ 向左跳跃}, \\text{以速率 } r_A/2 \\text{ 向右跳跃}, \\text{以速率 } k_{AB} \\text{ 切换到 } B \\}$，总速率为 $R_A = r_A + k_{AB}$；从通道 $B$ 出发，事件集为 $\\{ \\text{以速率 } r_B/2 \\text{ 向左跳跃}, \\text{以速率 } r_B/2 \\text{ 向右跳跃}, \\text{以速率 } k_{BA} \\text{ 切换到 } A \\}$，总速率为 $R_B = r_B + k_{BA}$。在每个 KMC 步中，从状态 $S$ 出发，从速率为 $R_S$ 的指数分布中抽取驻留时间 $\\Delta t$，即 $\\Delta t = -\\ln u / R_S$，其中 $u \\in (0,1)$ 是一个均匀分布的随机数，然后通过抽取另一个均匀分布的随机变量并根据事件速率成比例地选择事件。\n\n从根据 $p_A(0)$ 和 $p_B(0)$ 抽取的 $S(0)$ 开始，位置 $x(t)$ 仅在跳跃事件发生时改变 $\\pm a$。您必须通过丢弃任何预定时间超过 $t_{\\mathrm{end}}$ 的事件来在 $t_{\\mathrm{end}}$ 停止每个 KMC 轨迹（即，位置在事件之间是分段常数）。\n\n请仅使用以下基本原理，推导一个用 $a$、$r_A$、$r_B$、$k_{AB}$、$k_{BA}$、$p_A(0)$ 和 $t$ 表示的 $\\mathbb{E}[x(t)^2]$ 的解析表达式：\n- 用于描述通道占据的连续时间双态马尔可夫链，其生成元由 $k_{AB}$ 和 $k_{BA}$ 决定，以及其状态概率 $p_A(t)$ 和 $p_B(t)$ 的解。\n- 在以通道占据过程为条件的情况下，对称跳跃分别以速率 $r_A$ 和 $r_B$ 作为通道 $A$ 和 $B$ 中的独立泊松过程发生的性质。\n- 关于跳跃事件数的全期望定律以及独立、零均值增量之和的方差。\n\n不要使用任何未从这些原理推导出的简便公式。使用 LaTeX 表示所有数学实体。\n\n您将通过计算下面测试套件中每个参数集的绝对误差 $|\\mathbb{E}_{\\mathrm{KMC}}[x(t_{\\mathrm{end}})^2] - \\mathbb{E}_{\\mathrm{analytic}}[x(t_{\\mathrm{end}})^2]|$（单位：$\\mathrm{m}^2$）来验证 KMC-RTA 实现与解析结果的一致性。\n\n物理单位和输出要求：\n- 使用 $a$ 的单位为米，所有速率的单位为 $\\mathrm{s}^{-1}$，时间的单位为秒。\n- 报告最终的均方位移，单位为 $\\mathrm{m}^2$。\n- 您的程序必须为每个测试用例运行 $N=5000$ 条独立轨迹，并使用固定的随机种子 $12345$ 来估算 $\\mathbb{E}_{\\mathrm{KMC}}[x(t_{\\mathrm{end}})^2]$。\n- 最终输出必须是一行，包含一个用方括号括起来的逗号分隔列表，其中包含五个测试用例的绝对误差（单位：$\\mathrm{m}^2$），按所列顺序排列。例如：\"[e1,e2,e3,e4,e5]\"。\n\n测试套件（五个案例，共同探讨一般情况、等通道速率、从两种初始状态出发的无切换边界，以及快速切换极限）：\n1. 一般情况：$a=2\\times 10^{-10}$, $r_A=3\\times 10^{6}$, $r_B=1\\times 10^{6}$, $k_{AB}=8\\times 10^{5}$, $k_{BA}=4\\times 10^{5}$, $p_A(0)=1.0$, $t_{\\mathrm{end}}=5\\times 10^{-6}$。\n2. 相等通道跳跃速率：$a=5\\times 10^{-10}$, $r_A=2\\times 10^{6}$, $r_B=2\\times 10^{6}$, $k_{AB}=1\\times 10^{6}$, $k_{BA}=3\\times 10^{6}$, $p_A(0)=0.25$, $t_{\\mathrm{end}}=4\\times 10^{-6}$。\n3. 无切换，从 A 开始：$a=3\\times 10^{-10}$, $r_A=1.5\\times 10^{6}$, $r_B=0.5\\times 10^{6}$, $k_{AB}=0$, $k_{BA}=0$, $p_A(0)=1.0$, $t_{\\mathrm{end}}=6\\times 10^{-6}$。\n4. 无切换，从 B 开始：$a=1\\times 10^{-10}$, $r_A=1.5\\times 10^{6}$, $r_B=0.5\\times 10^{6}$, $k_{AB}=0$, $k_{BA}=0$, $p_A(0)=0.0$, $t_{\\mathrm{end}}=6\\times 10^{-6}$。\n5. 快速切换：$a=2.5\\times 10^{-10}$, $r_A=1.0\\times 10^{7}$, $r_B=1.0\\times 10^{6}$, $k_{AB}=5.0\\times 10^{7}$, $k_{BA}=5.0\\times 10^{7}$, $p_A(0)=0.5$, $t_{\\mathrm{end}}=2\\times 10^{-6}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如：\"[result1,result2,result3,result4,result5]\"）。",
            "solution": "该问题被认为是有效的。它在统计物理学和计算材料模拟领域是一个有科学依据、定义明确且客观的问题。该设置描述了离散晶格上的连续时间马尔可夫过程，这是原子扩散等现象的标准模型。该任务要求从第一性原理推导均方位移（MSD），并使用驻留时间算法（RTA）通过动力学蒙特卡洛（KMC）模拟对其进行验证。解析方法和数值方法都是标准的，并且适用于该问题。参数和条件在物理上是现实的、完整的和一致的。\n\n均方位移 $\\mathbb{E}[x(t)^2]$ 的解析推导按规定从第一性原理开始。粒子在时间 $t$ 的位置由 $x(t) = a \\sum_{i=1}^{N_j(t)} \\sigma_i$ 给出，其中 $a$ 是晶格间距，$N_j(t)$ 是到时间 $t$ 为止的总跳跃次数，$\\sigma_i \\in \\{-1, +1\\}$ 是第 $i$ 次跳跃的方向。由于跳跃是对称的最近邻跳跃，向左跳跃的概率等于向右跳跃的概率。因此，跳跃方向的期望值为 $\\mathbb{E}[\\sigma_i] = 0$。跳跃方向是独立的随机变量，因此对于 $i \\neq j$，有 $\\mathbb{E}[\\sigma_i \\sigma_j] = \\mathbb{E}[\\sigma_i]\\mathbb{E}[\\sigma_j] = 0$。此外，$\\sigma_i^2 = (\\pm 1)^2 = 1$。那么，均方位移为：\n$$ \\mathbb{E}[x(t)^2] = \\mathbb{E}\\left[\\left(a \\sum_{i=1}^{N_j(t)} \\sigma_i\\right)^2\\right] = a^2 \\mathbb{E}\\left[\\sum_{i,j=1}^{N_j(t)} \\sigma_i \\sigma_j\\right] = a^2 \\mathbb{E}\\left[\\sum_{i=1}^{N_j(t)} \\sigma_i^2 + \\sum_{i \\neq j} \\sigma_i \\sigma_j\\right] $$\n使用全期望定律，以 $N_j(t)$ 为条件，交叉项的期望为零。这将表达式简化为：\n$$ \\mathbb{E}[x(t)^2] = a^2 \\mathbb{E}\\left[\\sum_{i=1}^{N_j(t)} 1\\right] = a^2 \\mathbb{E}[N_j(t)] $$\n这个结果依赖于独立、零均值增量之和的方差原理。因此，问题简化为求总跳跃次数的期望值 $\\mathbb{E}[N_j(t)]$。\n\n跳跃过程是一个双重随机过程，或称为考克斯过程（Cox process），其速率本身是一个依赖于通道状态 $S(t') \\in \\{A, B\\}$ 的随机过程 $r(S(t'))$。通过在时间区间 $[0, t]$ 上对期望瞬时跳跃速率进行积分，可以得到期望跳跃次数，这是全期望定律的应用：\n$$ \\mathbb{E}[N_j(t)] = \\mathbb{E}\\left[\\int_0^t r(S(t')) dt'\\right] = \\int_0^t \\mathbb{E}[r(S(t'))] dt' $$\n在时间 $t'$ 的期望速率为 $\\mathbb{E}[r(S(t'))] = r_A p_A(t') + r_B p_B(t')$，其中 $p_A(t')$ 和 $p_B(t')$ 分别是处于通道 $A$ 和 $B$ 的概率。\n\n通道占据情况遵循一个速率为 $k_{AB}$ 和 $k_{BA}$ 的双态连续时间马尔可夫链。概率的演化由主方程控制：\n$$ \\frac{dp_A(t)}{dt} = -k_{AB} p_A(t) + k_{BA} p_B(t) $$\n使用约束条件 $p_A(t) + p_B(t) = 1$，我们得到关于 $p_A(t)$ 的一阶线性常微分方程：\n$$ \\frac{dp_A(t)}{dt} + (k_{AB} + k_{BA}) p_A(t) = k_{BA} $$\n令 $k = k_{AB} + k_{BA}$。对于 $k \\neq 0$ 的情况，具有初始条件 $p_A(0)$ 的解是：\n$$ p_A(t) = p_A(0)e^{-kt} + \\frac{k_{BA}}{k}(1 - e^{-kt}) $$\n这可以重写为以稳态概率 $p_A^{\\infty} = \\lim_{t \\to \\infty} p_A(t) = k_{BA}/k$ 表示的形式：$p_A(t) = (p_A(0) - p_A^{\\infty})e^{-kt} + p_A^{\\infty}$。\n\n现在我们通过对期望速率积分来计算 $\\mathbb{E}[N_j(t)]$：\n$$ \\mathbb{E}[N_j(t)] = \\int_0^t [r_A p_A(t') + r_B (1 - p_A(t'))] dt' = \\int_0^t [(r_A - r_B)p_A(t') + r_B] dt' $$\n$$ \\int_0^t p_A(t') dt' = \\int_0^t \\left[(p_A(0) - p_A^{\\infty})e^{-kt'} + p_A^{\\infty}\\right] dt' = \\frac{p_A(0) - p_A^{\\infty}}{k}(1-e^{-kt}) + p_A^{\\infty}t $$\n将此积分代回，我们得到：\n$$ \\mathbb{E}[N_j(t)] = (r_A - r_B) \\left[ \\frac{p_A(0) - p_A^{\\infty}}{k}(1-e^{-kt}) + p_A^{\\infty}t \\right] + r_B t $$\n$$ \\mathbb{E}[N_j(t)] = (r_A p_A^{\\infty} + r_B p_B^{\\infty})t + \\frac{r_A - r_B}{k}(p_A(0) - p_A^{\\infty})(1 - e^{-kt}) $$\n其中 $p_B^{\\infty} = 1 - p_A^{\\infty} = k_{AB}/k$。对于 $k = k_{AB} + k_{BA} \\neq 0$ 的 MSD 最终表达式为：\n$$ \\mathbb{E}[x(t)^2] = a^2 \\left\\{ (r_A p_A^{\\infty} + r_B p_B^{\\infty})t + \\frac{r_A - r_B}{k}(p_A(0) - p_A^{\\infty})(1 - e^{-kt}) \\right\\} $$\n\n对于 $k = k_{AB} + k_{BA} = 0$ 的特殊情况，这意味着 $k_{AB}=0$ 和 $k_{BA}=0$，没有通道切换。通道概率是恒定的：$p_A(t) = p_A(0)$。期望跳跃次数简化为：\n$$ \\mathbb{E}[N_j(t)] = \\int_0^t (r_A p_A(0) + r_B p_B(0)) dt' = (r_A p_A(0) + r_B(1-p_A(0)))t $$\n因此，对于 $k=0$：\n$$ \\mathbb{E}[x(t)^2] = a^2 (r_A p_A(0) + r_B p_B(0))t $$\n\nKMC 模拟使用驻留时间算法（RTA），这是对底层连续时间马尔可夫过程的直接实现。系统的状态是元组 $(x, S)$，即位置和通道。在每一步中：\n1. 根据当前通道状态 $S \\in \\{A, B\\}$，计算总离开速率 $R_S$。对于 $S=A$，$R_A = r_A + k_{AB}$。对于 $S=B$，$R_B = r_B + k_{BA}$。\n2. 从速率为 $R_S$ 的指数分布中抽取当前状态的驻留时间 $\\Delta t$：$\\Delta t = -\\ln(u_1)/R_S$，其中 $u_1$ 是 $(0,1)$ 中的一个均匀分布随机数。\n3. 模拟时间推进 $\\Delta t$。如果新时间超过指定的最终时间 $t_{\\mathrm{end}}$，则轨迹终止，并记录该被拒绝步骤开始时的位置值。\n4. 如果时间步被接受，则根据其相对速率选择一个事件。抽取第二个均匀分布随机数 $u_2 \\in (0,1)$。对于状态 $A$，如果 $u_2  (r_A/2)/R_A$，发生向左跳跃 ($x \\to x-a$)。如果 $(r_A/2)/R_A \\le u_2  r_A/R_A$，发生向右跳跃 ($x \\to x+a$)。否则，发生通道切换 ($S \\to B$)。类似的逻辑适用于状态 $B$。\n5. 系统状态 $(x, S)$ 被更新，然后重复此过程。\n最终估计值 $\\mathbb{E}_{\\mathrm{KMC}}[x(t_{\\mathrm{end}})^2]$ 是在大量 $N$ 个此类独立模拟轨迹上对 $x(t_{\\mathrm{end}})^2$ 取的平均值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the analytical MSD and comparing it\n    to a KMC simulation for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # 1. General case\n        {'a': 2e-10, 'r_A': 3e6, 'r_B': 1e6, 'k_AB': 8e5, 'k_BA': 4e5, 'p_A0': 1.0, 't_end': 5e-6},\n        # 2. Equal channel jump rates\n        {'a': 5e-10, 'r_A': 2e6, 'r_B': 2e6, 'k_AB': 1e6, 'k_BA': 3e6, 'p_A0': 0.25, 't_end': 4e-6},\n        # 3. No switching, start in A\n        {'a': 3e-10, 'r_A': 1.5e6, 'r_B': 0.5e6, 'k_AB': 0.0, 'k_BA': 0.0, 'p_A0': 1.0, 't_end': 6e-6},\n        # 4. No switching, start in B\n        {'a': 1e-10, 'r_A': 1.5e6, 'r_B': 0.5e6, 'k_AB': 0.0, 'k_BA': 0.0, 'p_A0': 0.0, 't_end': 6e-6},\n        # 5. Fast switching\n        {'a': 2.5e-10, 'r_A': 1.0e7, 'r_B': 1.0e6, 'k_AB': 5.0e7, 'k_BA': 5.0e7, 'p_A0': 0.5, 't_end': 2e-6},\n    ]\n\n    N = 5000  # Number of trajectories\n    seed = 12345\n    \n    absolute_errors = []\n\n    for params in test_cases:\n        analytic_result = calculate_analytic_msd(**params)\n        kmc_result = run_kmc_simulation(N=N, seed=seed, **params)\n        error = abs(kmc_result - analytic_result)\n        absolute_errors.append(error)\n\n    print(f\"[{','.join(f'{err:.6e}' for err in absolute_errors)}]\")\n\ndef calculate_analytic_msd(a, r_A, r_B, k_AB, k_BA, p_A0, t_end):\n    \"\"\"\n    Calculates the analytical mean-squared displacement.\n    \"\"\"\n    k = k_AB + k_BA\n    \n    if k == 0:\n        p_B0 = 1.0 - p_A0\n        expected_jumps = (r_A * p_A0 + r_B * p_B0) * t_end\n    else:\n        p_A_inf = k_BA / k\n        p_B_inf = k_AB / k\n        \n        avg_rate_inf = r_A * p_A_inf + r_B * p_B_inf\n        term1 = avg_rate_inf * t_end\n        \n        prefactor = (r_A - r_B) / k\n        p_A_diff = p_A0 - p_A_inf\n        exp_term = 1.0 - np.exp(-k * t_end)\n        \n        term2 = prefactor * p_A_diff * exp_term\n        \n        expected_jumps = term1 + term2\n        \n    msd = a**2 * expected_jumps\n    return msd\n\ndef run_kmc_simulation(N, seed, a, r_A, r_B, k_AB, k_BA, p_A0, t_end):\n    \"\"\"\n    Runs the KMC simulation to estimate the mean-squared displacement.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    squared_displacements = np.zeros(N)\n\n    # Pre-calculate rates for each channel\n    R_A = r_A + k_AB\n    R_B = r_B + k_BA\n\n    # Probabilities for event selection in channel A\n    if R_A > 0:\n        p_A_jump_left = (r_A / 2) / R_A\n        p_A_jump_right = r_A / R_A\n    \n    # Probabilities for event selection in channel B\n    if R_B > 0:\n        p_B_jump_left = (r_B / 2) / R_B\n        p_B_jump_right = r_B / R_B\n\n    for i in range(N):\n        time = 0.0\n        position = 0.0\n        \n        # Initialize channel state\n        if rng.random()  p_A0:\n            channel = 'A'\n        else:\n            channel = 'B'\n\n        while time  t_end:\n            if channel == 'A':\n                R_S = R_A\n            else: # channel == 'B'\n                R_S = R_B\n\n            if R_S == 0:\n                break # Trapped state, no more events can occur\n\n            # Draw time step from exponential distribution\n            u1 = rng.random()\n            dt = -np.log(u1) / R_S\n            \n            if time + dt > t_end:\n                break # Event occurs after t_end, so discard it and stop\n\n            time += dt\n            \n            # Select and execute event\n            u2 = rng.random()\n            if channel == 'A':\n                if u2  p_A_jump_left:\n                    position -= a\n                elif u2  p_A_jump_right:\n                    position += a\n                else:\n                    channel = 'B'\n            else: # channel == 'B'\n                if u2  p_B_jump_left:\n                    position -= a\n                elif u2  p_B_jump_right:\n                    position += a\n                else:\n                    channel = 'A'\n        \n        squared_displacements[i] = position**2\n        \n    return np.mean(squared_displacements)\n\nsolve()\n```"
        },
        {
            "introduction": "任何模拟的可靠性都取决于其底层模型的准确性，而一个不完整的事件目录是 KMC 模拟中常见的误差来源。本练习聚焦于 KMC 的一个关键实践环节：模型验证。你将学习并实现一种基于概率积分变换和 Kolmogorov-Smirnov 检验的强大统计诊断方法，用于判断事件目录是否可能遗漏了重要的物理过程，这对于确保模拟结果的物理真实性至关重要。",
            "id": "3851111",
            "problem": "考虑动力学蒙特卡洛（KMC）中的一个固定构型，也称为连续时间马尔可夫链（CTMC）。在驻留时间算法中，系统会等待一段随机时间，直到下一个事件发生。在固定的构型下，事件目录列出了所有可能的跃迁及其速率。该构型下的总风险是目录中所有速率的总和。当事件目录是完备的且速率是时不变的时，由于独立事件发生的泊松性质，驻留时间分布必须是指数分布。\n\n从“具有恒定风险的独立事件发生会产生指数分布的等待时间”以及“指数分布具有无记忆性”这一基本原理出发，推导一个诊断方法。该方法通过检验观测到的驻留时间是否偏离了事件目录所隐含的指数统计特性，来判断在一个固定构型下事件目录是否不完备。\n\n您的诊断方法必须基于以下要素：\n- 设该构型下目录中的事件速率为 $\\{r_k\\}_{k=1}^m$，其物理单位为 $\\mathrm{s}^{-1}$。\n- 设 $\\lambda_{\\text{catalog}} = \\sum_{k=1}^m r_k$ 为目录中的总风险速率，单位为 $\\mathrm{s}^{-1}$。\n- 设在该构型下观测到的驻留时间为 $\\{t_i\\}_{i=1}^n$，以秒为单位。\n- 在目录完备且速率恒定的情况下，理论生存函数为 $S(t) = \\exp(-\\lambda_{\\text{catalog}} t)$，累积分布函数为 $F(t) = 1 - \\exp(-\\lambda_{\\text{catalog}} t)$。\n- 使用概率积分变换将每个观测时间映射为 $u_i = F(t_i) = 1 - \\exp(-\\lambda_{\\text{catalog}} t_i)$。在目录完备且速率恒定的零假设下，$\\{u_i\\}$ 应为在 $[0,1]$ 上服从均匀分布的独立同分布样本。\n- 对 $\\{u_i\\}$ 在给定的显著性水平 $\\alpha$（表示为 $[0,1]$ 内的小数）下，执行针对 Uniform$(0,1)$ 分布的单样本 Kolmogorov–Smirnov (KS) 检验。如果得到的 $p$ 值小于 $\\alpha$，则判定该构型的事件目录不完备；否则，判定其并非不完备。\n\n您的程序必须实现上述诊断方法，并将其应用于以下测试套件。程序必须使用指定种子的伪随机数生成器来合成观测到的驻留时间。所有驻留时间以秒为单位；所有速率以 $\\mathrm{s}^{-1}$ 为单位；显著性水平 $\\alpha$ 是无量纲的。\n\n测试套件（每个案例提供 $(\\text{种子}, \\{r_k\\}, n, \\text{生成规则}, \\alpha)$）：\n- 案例 A（理想情况，目录完备，样本量适中）：$(\\; \\text{seed}=1, \\{r_k\\}=[1.0, 2.0], n=200, \\text{生成 } t_i \\sim \\text{Exponential}(\\lambda=3.0), \\alpha=0.05 \\;)$。\n- 案例 B（目录不完备，偏差显著）：$(\\; \\text{seed}=2, \\{r_k\\}=[0.5, 0.5], n=200, \\text{生成 } t_i \\sim \\text{Exponential}(\\lambda=2.0), \\alpha=0.05 \\;)$。\n- 案例 C（边界条件，样本量极小）：$(\\; \\text{seed}=3, \\{r_k\\}=[0.1], n=5, \\text{生成 } t_i \\sim \\text{Exponential}(\\lambda=0.1), \\alpha=0.05 \\;)$。\n- 案例 D（边缘情况，因速率异质性导致非指数分布）：$(\\; \\text{seed}=4, \\{r_k\\}=[2.0], n=200, \\text{生成 } t_i \\text{ 作为混合分布：以 } 0.5 \\text{ 的概率使用 } \\text{Exponential}(\\lambda=1.0) \\text{，以 } 0.5 \\text{ 的概率使用 } \\text{Exponential}(\\lambda=3.0), \\alpha=0.05 \\;)$。\n\n这里 $\\text{Exponential}(\\lambda)$ 表示指数分布，其概率密度函数为 $f(t) = \\lambda \\exp(-\\lambda t)$（$t \\ge 0$），其中 $\\lambda$ 的单位是 $\\mathrm{s}^{-1}$，$t$ 的单位是秒。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result_A,result_B,result_C,result_D]”），每个条目是一个布尔值，如果该案例的目录被诊断为不完备，则为 True，否则为 False。不允许有其他输出。",
            "solution": "该问题要求制定并实现一种统计诊断方法，用以评估动力学蒙特卡洛（KMC）模拟中固定系统构型下事件目录的完备性。该诊断方法基于连续时间马尔可夫链（CTMC）的基本原理，而CTMC是KMC的理论基础。\n\n该理论的一个核心原则是，如果一个系统处于特定状态，并且存在多个从该状态出发的独立、可能的跃迁（事件），每个跃迁都以恒定的风险速率发生，那么系统在当前状态停留的时间——即驻留时间——是一个服从指数分布的随机变量。这个指数分布的速率参数 $\\lambda$ 是所有可能跃迁的单个风险速率之和。这是该过程是泊松过程的直接结果。\n\n该诊断程序利用这一原理来检验一个零假设。\n\n**1. 零假设的构建**\n\n设固定构型下已知事件的目录与一组恒定速率 $\\{r_k\\}_{k=1}^m$ 相关联。目录中的总速率或总风险为 $\\lambda_{\\text{catalog}} = \\sum_{k=1}^m r_k$。速率的单位是时间的倒数，例如 $\\mathrm{s}^{-1}$。\n\n零假设 $H_0$ 假定该目录是完备的。如果 $H_0$ 为真，那么所有事件的真实总速率 $\\lambda_{\\text{true}}$ 等于目录速率 $\\lambda_{\\text{catalog}}$。因此，观测到的驻留时间 $\\{t_i\\}_{i=1}^n$ 构成了一个从速率参数为 $\\lambda_{\\text{catalog}}$ 的指数分布中抽取的样本。其概率密度函数（PDF）为 $f(t) = \\lambda_{\\text{catalog}} \\exp(-\\lambda_{\\text{catalog}} t)$（$t \\ge 0$），累积分布函数（CDF）为 $F(t) = 1 - \\exp(-\\lambda_{\\text{catalog}} t)$。\n\n备择假设 $H_1$ 是目录不完备。这可能意味着存在未知的事件，使得 $\\lambda_{\\text{true}} > \\lambda_{\\text{catalog}}$，或者底层过程不是一个简单的泊松过程（例如，速率并非真正恒定），导致驻留时间分布偏离目录所预测的指数形式。\n\n**2. 概率积分变换 (PIT)**\n\n概率积分变换是统计学中的一个基本结论，它指出如果一个连续随机变量 $T$ 的累积分布函数为 $F_T(t)$，那么变换后的随机变量 $U = F_T(T)$ 服从区间 $[0, 1]$ 上的标准均匀分布。\n\n我们将此变换应用于观测到的驻留时间 $\\{t_i\\}_{i=1}^n$，使用从零假设推导出的累积分布函数 $F(t; \\lambda_{\\text{catalog}})$。这将产生一组新值 $\\{u_i\\}_{i=1}^n$：\n$$\nu_i = F(t_i; \\lambda_{\\text{catalog}}) = 1 - \\exp(-\\lambda_{\\text{catalog}} t_i)\n$$\n如果零假设 $H_0$ 为真，集合 $\\{u_i\\}$ 将是来自 $\\text{Uniform}(0,1)$ 分布的独立同分布随机变量样本。如果 $H_0$ 为假，$\\{u_i\\}$ 的分布将系统性地偏离均匀性。例如，如果 $\\lambda_{\\text{true}} > \\lambda_{\\text{catalog}}$，观测时间 $t_i$ 将倾向于比 $H_0$ 下预期的要小。应用变换 $F(t; \\lambda_{\\text{catalog}})$ 会将这些较小的时间映射到偏向 $[0, 1]$ 区间低端的值，从而破坏了均匀性。\n\n**3. Kolmogorov-Smirnov (KS) 检验**\n\n为了检验样本 $\\{u_i\\}$ 是否从 $\\text{Uniform}(0,1)$ 分布中抽取，我们采用单样本 Kolmogorov-Smirnov (KS) 检验。这种非参数检验将样本的经验累积分布函数（ECDF）$\\hat{F}_n(u)$ 与假设分布的理论累积分布函数进行比较。对于 $\\text{Uniform}(0,1)$，理论累积分布函数就是 $G(u) = u$（对于 $u \\in [0, 1]$）。\n\nKS 检验统计量 $D_n$ 是经验累积分布函数和理论累积分布函数在所有可能值上的最大绝对差：\n$$\nD_n = \\sup_{u} |\\hat{F}_n(u) - G(u)|\n$$\n其中 $\\hat{F}_n(u) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}_{u_i \\le u}$ 是样本 $\\{u_i\\}$ 的经验累积分布函数。KS 检验提供一个 $p$ 值，它是在假设 $H_0$ 为真的情况下，观测到至少这么大的 $D_n$ 统计量的概率。\n\n**4. 决策规则**\n\n一个预定的显著性水平 $\\alpha$ 被用作决策的阈值。$\\alpha$ 的一个典型值是 $0.05$。\n- 如果 $p\\text{-值}  \\alpha$：我们拒绝零假设 $H_0$。观测数据在统计上与目录完备的假设不一致。我们得出结论，目录是不完备的。\n- 如果 $p\\text{-值} \\ge \\alpha$：我们未能拒绝零假设 $H_0$。没有足够的统计证据来声称目录是不完备的。\n\n**应用于测试案例：**\n\n- **案例 A（理想情况）：** 目录速率为 $\\lambda_{\\text{catalog}} = 1.0 + 2.0 = 3.0 \\;\\mathrm{s}^{-1}$。数据由 $\\lambda_{\\text{true}} = 3.0 \\;\\mathrm{s}^{-1}$ 生成。由于 $\\lambda_{\\text{true}} = \\lambda_{\\text{catalog}}$，零假设为真。在 $n=200$ 的充足样本量下，预期 $p$ 值将大于 $\\alpha=0.05$，从而得出目录并非不完备的结论。\n\n- **案例 B（目录不完备）：** 目录速率为 $\\lambda_{\\text{catalog}} = 0.5 + 0.5 = 1.0 \\;\\mathrm{s}^{-1}$。数据由 $\\lambda_{\\text{true}} = 2.0 \\;\\mathrm{s}^{-1}$ 生成。这里，$\\lambda_{\\text{true}}  \\lambda_{\\text{catalog}}$，所以目录确实不完备。观测到的驻留时间将系统性地短于目录的预测。变换后的值 $\\{u_i\\}$ 将不呈均匀分布，KS 检验预期会产生一个小于 $\\alpha=0.05$ 的 $p$ 值，从而正确地将该目录标记为不完备。\n\n- **案例 C（小样本量）：** 目录速率为 $\\lambda_{\\text{catalog}} = 0.1 \\;\\mathrm{s}^{-1}$，数据由 $\\lambda_{\\text{true}} = 0.1 \\;\\mathrm{s}^{-1}$ 生成。零假设为真。然而，样本量非常小（$n=5$）。虽然我们预期不会拒绝 $H_0$，但值得注意的是，对于小样本，统计检验的功效较低，即使存在与零假设的真实偏差也很难检测到。\n\n- **案例 D（非指数数据）：** 目录速率为 $\\lambda_{\\text{catalog}} = 2.0 \\;\\mathrm{s}^{-1}$。数据由两个指数分布的混合生成。这意味着底层的数据生成过程不是一个具有单一速率的简单泊松过程。驻留时间分布不是速率为 $\\lambda=2.0$ 的指数分布。零假设为假。KS 检验对分布形状的差异很敏感，因此预期它会检测到这种不匹配，产生一个小的 $p$ 值（$ 0.05$），并正确地识别出目录指定的模型与数据不一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest\n\ndef solve():\n    \"\"\"\n    Implements a statistical diagnostic to validate KMC event catalogs\n    and applies it to a suite of test cases.\n    \"\"\"\n    # Test suite format: \n    # (case_id, seed, catalog_rates_rk, sample_size_n, generation_spec, alpha)\n    # generation_spec defines how the \"observed\" residence times are created.\n    # ('exp', lambda_true) -> Exponential(lambda_true)\n    # ('mix', p1, lambda1, p2, lambda2) -> p1*Exp(lambda1) + p2*Exp(lambda2)\n    test_cases = [\n        ('A', 1, [1.0, 2.0], 200, ('exp', 3.0), 0.05),\n        ('B', 2, [0.5, 0.5], 200, ('exp', 2.0), 0.05),\n        ('C', 3, [0.1], 5, ('exp', 0.1), 0.05),\n        ('D', 4, [2.0], 200, ('mix', 0.5, 1.0, 0.5, 3.0), 0.05),\n    ]\n\n    results = []\n    for _, seed, r_k, n, gen_spec, alpha in test_cases:\n        # Step 1: Calculate the total cataloged hazard rate\n        lambda_catalog = np.sum(r_k)\n        \n        # Initialize a pseudo-random number generator with the specified seed\n        rng = np.random.default_rng(seed)\n        \n        # Step 2: Generate the synthetic \"observed\" residence times\n        t_obs = None\n        gen_type = gen_spec[0]\n        \n        if gen_type == 'exp':\n            # Generate from a single exponential distribution.\n            # numpy.random.exponential uses scale = 1/lambda.\n            lambda_true = gen_spec[1]\n            scale_true = 1.0 / lambda_true\n            t_obs = rng.exponential(scale=scale_true, size=n)\n            \n        elif gen_type == 'mix':\n            # Generate from a mixture of two exponential distributions.\n            p1, lambda1, _, lambda2 = gen_spec[1:]\n            scale1 = 1.0 / lambda1\n            scale2 = 1.0 / lambda2\n            \n            # Generate choices based on probability p1\n            choices = rng.uniform(size=n)  p1\n            \n            # Generate samples from both distributions\n            samples1 = rng.exponential(scale=scale1, size=n)\n            samples2 = rng.exponential(scale=scale2, size=n)\n            \n            # Combine them based on the choices\n            t_obs = np.where(choices, samples1, samples2)\n            \n        # Step 3: Apply the Probability Integral Transform (PIT)\n        # Under the null hypothesis H0, the times t_i follow Exp(lambda_catalog).\n        # The CDF is F(t) = 1 - exp(-lambda_catalog * t).\n        # The transformed variable u_i = F(t_i) should be Uniform(0,1).\n        u_transformed = 1.0 - np.exp(-lambda_catalog * t_obs)\n        \n        # Step 4: Perform a one-sample Kolmogorov-Smirnov test for uniformity\n        # The `scipy.stats.kstest` function can test against a named distribution.\n        # 'uniform' corresponds to the standard Uniform(0,1) distribution.\n        ks_result = kstest(u_transformed, 'uniform')\n        p_value = ks_result.pvalue\n        \n        # Step 5: Make a decision based on the significance level alpha\n        # If p-value  alpha, we reject H0 and declare the catalog incomplete.\n        is_incomplete = p_value  alpha\n        results.append(is_incomplete)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}