{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of multiscale modeling is the ability to derive continuum-level properties from the underlying atomistic physics. This exercise guides you through a foundational example: deriving the elastic tensor of a crystalline material from a simple interatomic potential using the Cauchy-Born assumption. By working through this derivation, you will gain hands-on experience in bridging the atomistic and continuum scales, a critical skill for understanding how macroscopic material response emerges from microscopic interactions .",
            "id": "3799940",
            "problem": "Consider a two-dimensional triangular Bravais lattice with one atom per primitive cell and nearest-neighbor separation $a$. Under the Cauchy-Born assumption, a homogeneous small strain $\\,\\boldsymbol{\\varepsilon}\\,$ maps each reference bond vector $\\mathbf{R}$ to $\\mathbf{r} = (\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{R}$, where $\\mathbf{I}$ is the identity tensor. The per-atom energy is modeled by a central pair potential $\\phi(r)$, with the total energy per atom given by the sum over all distinct neighbor bonds. Assume only the six nearest neighbors contribute and adopt the harmonic form $\\phi(r) = \\tfrac{1}{2} k (r - a)^{2}$, where $k$ is a bond stiffness parameter inferred from a data-driven regression on atomistic simulations.\n\nLet the coordinate axes be chosen so that one of the six nearest-neighbor directions is aligned with the $x$-axis. The six unit direction vectors are\n$$\n\\mathbf{n}_{1} = \\begin{pmatrix}1 \\\\ 0\\end{pmatrix},\\quad\n\\mathbf{n}_{2} = \\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{\\sqrt{3}}{2}\\end{pmatrix},\\quad\n\\mathbf{n}_{3} = \\begin{pmatrix}-\\tfrac{1}{2} \\\\ \\tfrac{\\sqrt{3}}{2}\\end{pmatrix},\\quad\n\\mathbf{n}_{4} = \\begin{pmatrix}-1 \\\\ 0\\end{pmatrix},\\quad\n\\mathbf{n}_{5} = \\begin{pmatrix}-\\tfrac{1}{2} \\\\ -\\tfrac{\\sqrt{3}}{2}\\end{pmatrix},\\quad\n\\mathbf{n}_{6} = \\begin{pmatrix}\\tfrac{1}{2} \\\\ -\\tfrac{\\sqrt{3}}{2}\\end{pmatrix}.\n$$\nEach reference bond is $\\mathbf{R}_{m} = a\\,\\mathbf{n}_{m}$ for $m = 1,\\dots,6$. The primitive cell area is $A_{0} = \\tfrac{\\sqrt{3}}{2} a^{2}$, so the atomic number density is $\\rho_{\\mathrm{atom}} = \\tfrac{1}{A_{0}} = \\tfrac{2}{\\sqrt{3}\\,a^{2}}$.\n\nStarting from the definition of strain energy density and the Cauchy-Born mapping, derive the continuum elastic tensor $C_{ijkl}$ in terms of lattice sums over the nearest-neighbor directions and fundamental quantities. Then, using the provided directions, evaluate $C_{1111}$ explicitly.\n\nFinally, given the data-driven parameter $k = 45\\,\\text{N/m}$ and $a = 2.50 \\times 10^{-10}\\,\\text{m}$, compute the numerical value of $C_{1111}$ for this lattice. Express your final answer in $\\text{N/m}$ and round to four significant figures.",
            "solution": "The starting point is the strain energy density per unit area, $W(\\boldsymbol{\\varepsilon})$, obtained from the per-atom energy under the Cauchy-Born assumption. For a central pair potential $\\phi(r)$ and a homogeneous small strain $\\boldsymbol{\\varepsilon}$, each reference bond vector $\\mathbf{R}$ of magnitude $a$ and unit direction $\\mathbf{n}$ is mapped to\n$$\n\\mathbf{r} = (\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{R} = a\\,(\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{n}.\n$$\nTo leading order in $\\boldsymbol{\\varepsilon}$, the stretched bond length is\n$$\nr = \\|\\mathbf{r}\\| = a\\,\\left\\|(\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{n}\\right\\| \\approx a \\left( 1 + \\mathbf{n}^{\\mathsf{T}} \\boldsymbol{\\varepsilon}\\, \\mathbf{n} \\right),\n$$\nso the first-order change in bond length is\n$$\n\\delta r \\equiv r - a \\approx a\\,\\mathbf{n}^{\\mathsf{T}} \\boldsymbol{\\varepsilon}\\, \\mathbf{n} = a\\, n_{i}\\,\\varepsilon_{ij}\\,n_{j},\n$$\nwhere the Einstein summation convention is used.\n\nThe per-atom energy for a pair potential is\n$$\nE_{\\mathrm{atom}} = \\tfrac{1}{2}\\sum_{m} \\phi(r_{m}),\n$$\nwhere the factor $\\tfrac{1}{2}$ prevents double counting of pairs. For the harmonic $\\phi(r) = \\tfrac{1}{2}k (r - a)^{2}$ and small strain, the change in per-atom energy to second order is\n$$\n\\Delta E_{\\mathrm{atom}} = \\tfrac{1}{2} \\sum_{m} \\tfrac{1}{2} k\\, (\\delta r_{m})^{2}\n= \\tfrac{k}{4} \\sum_{m} \\left( a\\, n^{(m)}_{i}\\,\\varepsilon_{ij}\\,n^{(m)}_{j} \\right)^{2}\n= \\tfrac{k a^{2}}{4} \\sum_{m} \\varepsilon_{ij}\\,\\varepsilon_{kl}\\, n^{(m)}_{i} n^{(m)}_{j} n^{(m)}_{k} n^{(m)}_{l}.\n$$\nMultiplying by the atomic number density $\\rho_{\\mathrm{atom}}$ gives the strain energy density per unit area:\n$$\n\\Delta W(\\boldsymbol{\\varepsilon}) = \\rho_{\\mathrm{atom}}\\,\\Delta E_{\\mathrm{atom}}\n= \\tfrac{k a^{2}}{4}\\,\\rho_{\\mathrm{atom}} \\sum_{m} \\varepsilon_{ij}\\,\\varepsilon_{kl}\\, n^{(m)}_{i} n^{(m)}_{j} n^{(m)}_{k} n^{(m)}_{l}.\n$$\nBy definition of the elastic tensor,\n$$\n\\Delta W(\\boldsymbol{\\varepsilon}) = \\tfrac{1}{2} C_{ijkl}\\, \\varepsilon_{ij}\\, \\varepsilon_{kl}.\n$$\nMatching coefficients of $\\varepsilon_{ij}\\varepsilon_{kl}$, we obtain\n$$\nC_{ijkl} = \\tfrac{k a^{2}}{2}\\,\\rho_{\\mathrm{atom}} \\sum_{m} n^{(m)}_{i} n^{(m)}_{j} n^{(m)}_{k} n^{(m)}_{l}.\n$$\n\nWe now evaluate $C_{1111}$ for the triangular lattice using the six given unit vectors. Writing $n_{1}^{(m)}$ for the $x$-component of $\\mathbf{n}_{m}$, we have\n$$\nC_{1111} = \\tfrac{k a^{2}}{2}\\,\\rho_{\\mathrm{atom}} \\sum_{m=1}^{6} \\left(n_{1}^{(m)}\\right)^{4}.\n$$\nThe six $x$-components are $1,\\,\\tfrac{1}{2},\\,-\\tfrac{1}{2},\\,-1,\\,-\\tfrac{1}{2},\\,\\tfrac{1}{2}$, so\n$$\n\\sum_{m=1}^{6} \\left(n_{1}^{(m)}\\right)^{4} = 1^{4} + \\left(\\tfrac{1}{2}\\right)^{4} + \\left(-\\tfrac{1}{2}\\right)^{4} + (-1)^{4} + \\left(-\\tfrac{1}{2}\\right)^{4} + \\left(\\tfrac{1}{2}\\right)^{4}\n= 2 + 4 \\times \\tfrac{1}{16} = 2 + \\tfrac{1}{4} = \\tfrac{9}{4}.\n$$\nThe atomic number density is\n$$\n\\rho_{\\mathrm{atom}} = \\tfrac{1}{A_{0}} = \\tfrac{2}{\\sqrt{3}\\,a^{2}}.\n$$\nTherefore,\n$$\nC_{1111} = \\tfrac{k a^{2}}{2} \\cdot \\tfrac{2}{\\sqrt{3}\\,a^{2}} \\cdot \\tfrac{9}{4} = \\tfrac{9}{4\\sqrt{3}}\\,k.\n$$\n\nSubstituting $k = 45\\,\\text{N/m}$ and $a = 2.50 \\times 10^{-10}\\,\\text{m}$ (which cancels, as shown), we obtain\n$$\nC_{1111} = \\tfrac{9}{4\\sqrt{3}} \\times 45 \\,\\text{N/m}.\n$$\nUsing $\\sqrt{3} \\approx 1.7320508076$,\n$$\n\\tfrac{9}{4\\sqrt{3}} \\approx \\tfrac{9}{6.9282032303} \\approx 1.299038105,\n$$\nand thus\n$$\nC_{1111} \\approx 1.299038105 \\times 45 \\,\\text{N/m} \\approx 58.4567147 \\,\\text{N/m}.\n$$\nRounded to four significant figures and expressed in $\\text{N/m}$, the result is $58.46\\,\\text{N/m}$.",
            "answer": "$$\\boxed{58.46}$$"
        },
        {
            "introduction": "While data-driven surrogates offer tremendous flexibility in modeling complex material behavior, they must not violate fundamental physical principles. This practice confronts this challenge directly by asking you to verify the thermodynamic consistency of a data-driven viscoplastic model . By applying the Clausius-Duhem inequality, you will ensure the model's predictions respect the second law of thermodynamics, reinforcing the critical importance of building physics-informed data-driven models.",
            "id": "3799880",
            "problem": "Consider an isothermal, small-strain, one-dimensional viscoplastic material modeled by a data-driven surrogate for the plastic strain rate. Let the Helmholtz free energy per unit volume be given by $\\psi(\\varepsilon,\\varepsilon^{p}) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2}$, where $\\varepsilon$ is the total axial strain, $\\varepsilon^{p}$ is the plastic strain, and $E$ is the Young’s modulus. The Cauchy stress is obtained from the standard hyperelastic relation $\\sigma = \\dfrac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\varepsilon^{p}\\right)$. The plastic strain rate is provided by a data-driven surrogate $\\dot{\\varepsilon}^{p} = g(\\sigma)$ constructed from positive-stress data pairs and extended to all stresses by odd symmetry. The fundamental thermodynamic requirement is the Clausius–Duhem inequality for isothermal processes, expressed per unit volume as $\\mathcal{D}(t) = \\sigma(t)\\,\\dot{\\varepsilon}(t) - \\dfrac{d}{dt}\\psi\\left(\\varepsilon(t),\\varepsilon^{p}(t)\\right) \\ge 0$ for all $t$, where $\\mathcal{D}(t)$ is the instantaneous dissipation rate density.\n\nTask: Starting only from the above fundamental laws and definitions, derive an algorithmic scheme that computes the total dissipation over one prescribed strain cycle and verifies nonnegativity. Use the following requirements:\n\n- The constitutive free-energy definition $\\psi(\\varepsilon,\\varepsilon^{p}) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2}$ and the stress definition $\\sigma = E\\left(\\varepsilon - \\varepsilon^{p}\\right)$ are mandatory. The data-driven surrogate must be treated as a rate potential for plastic flow: $\\dot{\\varepsilon}^{p} = g(\\sigma)$, with $g$ specified by interpolation of provided data pairs for positive $\\sigma$ and extended to negative $\\sigma$ by odd symmetry $g(-\\sigma) = -g(\\sigma)$. For $\\sigma$ beyond the largest provided data, use linear extrapolation with the slope of the last segment.\n- The loading is a prescribed sinusoidal strain history $\\varepsilon(t) = \\varepsilon_{0} \\sin\\left(2\\pi f t\\right)$ over exactly one period $T = 1/f$, with known derivative $\\dot{\\varepsilon}(t) = 2\\pi f \\varepsilon_{0} \\cos\\left(2\\pi f t\\right)$.\n- Time integration must proceed with a uniform time step $\\Delta t$, using an explicit forward-Euler update $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\dot{\\varepsilon}^{p}_{n} \\Delta t$, with the stress evaluated as $\\sigma_{n} = E\\left(\\varepsilon_{n} - \\varepsilon^{p}_{n}\\right)$ at each step. Compute the instantaneous dissipation rate density as $\\mathcal{D}_{n} = \\sigma_{n}\\,\\dot{\\varepsilon}^{p}_{n}$ and numerically integrate over the cycle using a consistent quadrature to obtain the total dissipation per unit volume $\\mathcal{D}_{\\text{tot}} = \\int_{0}^{T} \\mathcal{D}(t)\\,dt$.\n- Express the total dissipation per unit volume in joules per cubic meter, rounded to the nearest integer.\n\nImplement a complete program that computes $\\mathcal{D}_{\\text{tot}}$ for each of the following three test cases. In each case, the surrogate $g(\\sigma)$ is defined for positive $\\sigma$ by the listed $(\\sigma_{i}, \\dot{\\varepsilon}^{p}_{i})$ data pairs and extended to all $\\sigma$ by odd symmetry, with linear interpolation between data points and linear extrapolation beyond the last data point using the last-segment slope. Use $\\sigma$ in pascals and $\\dot{\\varepsilon}^{p}$ in inverse seconds.\n\nTest Suite (each case runs for one full cycle and uses the specified parameters):\n\n- Case A:\n  - $E = 2.10\\times 10^{11}\\,\\text{Pa}$.\n  - Data pairs for $g$ on $\\sigma \\ge 0$: $(0, 0)$, $(3.0\\times 10^{8}, 0)$, $(4.5\\times 10^{8}, 5.0\\times 10^{-5})$, $(6.0\\times 10^{8}, 2.0\\times 10^{-4})$.\n  - Strain amplitude and frequency: $\\varepsilon_{0} = 5.0\\times 10^{-3}$, $f = 5.0\\times 10^{-1}\\,\\text{Hz}$.\n  - Time step: $\\Delta t = 1.0\\times 10^{-3}\\,\\text{s}$.\n\n- Case B:\n  - $E = 2.10\\times 10^{11}\\,\\text{Pa}$.\n  - Data pairs for $g$ on $\\sigma \\ge 0$: $(0, 0)$, $(3.0\\times 10^{8}, 0)$, $(4.5\\times 10^{8}, 5.0\\times 10^{-5})$, $(6.0\\times 10^{8}, 2.0\\times 10^{-4})$.\n  - Strain amplitude and frequency: $\\varepsilon_{0} = 5.0\\times 10^{-4}$, $f = 5.0\\times 10^{-1}\\,\\text{Hz}$.\n  - Time step: $\\Delta t = 1.0\\times 10^{-3}\\,\\text{s}$.\n\n- Case C:\n  - $E = 7.0\\times 10^{10}\\,\\text{Pa}$.\n  - Data pairs for $g$ on $\\sigma \\ge 0$: $(0, 0)$, $(1.0\\times 10^{8}, 0)$, $(2.0\\times 10^{8}, 1.0\\times 10^{-4})$, $(4.0\\times 10^{8}, 1.5\\times 10^{-4})$.\n  - Strain amplitude and frequency: $\\varepsilon_{0} = 4.0\\times 10^{-3}$, $f = 1.0\\,\\text{Hz}$.\n  - Time step: $\\Delta t = 5.0\\times 10^{-4}\\,\\text{s}$.\n\nOutput specification:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $[\\mathcal{D}_{\\text{tot}}^{A},\\mathcal{D}_{\\text{tot}}^{B},\\mathcal{D}_{\\text{tot}}^{C}]$, where each entry is the total dissipation per unit volume for the corresponding case, in joules per cubic meter, rounded to the nearest integer.",
            "solution": "The problem is well-posed and scientifically sound, resting on the fundamental principles of continuum mechanics and thermodynamics for inelastic materials. We shall first derive the expression for the rate of dissipation and then construct the numerical algorithm to compute the total dissipation over a prescribed strain cycle.\n\n**1. Thermodynamic Foundation and Dissipation Rate**\n\nThe analysis begins with the Clausius–Duhem inequality for isothermal processes, which is a statement of the second law of thermodynamics. Per unit volume, it is given as:\n$$\n\\mathcal{D}(t) = \\sigma(t)\\,\\dot{\\varepsilon}(t) - \\dot{\\psi}\\left(\\varepsilon(t),\\varepsilon^{p}(t)\\right) \\ge 0\n$$\nwhere $\\mathcal{D}(t)$ is the instantaneous rate of dissipation, $\\sigma(t)$ is the Cauchy stress, $\\dot{\\varepsilon}(t)$ is the total strain rate, and $\\dot{\\psi}$ is the material time derivative of the Helmholtz free energy density $\\psi$.\n\nThe Helmholtz free energy density $\\psi$ is a function of the state variables, which for this model are the total strain $\\varepsilon$ and the plastic strain $\\varepsilon^{p}$. Its material time derivative is found by applying the chain rule:\n$$\n\\dot{\\psi} = \\frac{d\\psi}{dt} = \\frac{\\partial\\psi}{\\partial\\varepsilon}\\dot{\\varepsilon} + \\frac{\\partial\\psi}{\\partial\\varepsilon^{p}}\\dot{\\varepsilon}^{p}\n$$\nThe constitutive relations for the stress $\\sigma$ and the thermodynamic force conjugate to the plastic strain are derived from the free energy potential:\n$$\n\\sigma = \\frac{\\partial\\psi}{\\partial\\varepsilon} \\quad \\text{and} \\quad \\sigma^{p} = -\\frac{\\partial\\psi}{\\partial\\varepsilon^{p}}\n$$\nwhere $\\sigma^p$ is the back-stress or thermodynamic driving force for plastic flow.\n\nUsing the specific form of the free energy provided, $\\psi(\\varepsilon,\\varepsilon^{p}) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2}$, we compute these derivatives:\n$$\n\\sigma = \\frac{\\partial}{\\partial\\varepsilon} \\left( \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2} \\right) = E (\\varepsilon - \\varepsilon^{p})\n$$\nThis precisely recovers the given definition for stress, confirming consistency. For the back-stress, we find:\n$$\n\\sigma^{p} = -\\frac{\\partial}{\\partial\\varepsilon^{p}} \\left( \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2} \\right) = -E (\\varepsilon - \\varepsilon^{p})(-1) = E (\\varepsilon - \\varepsilon^{p}) = \\sigma\n$$\nThus, the thermodynamic driving force for plastic flow is the Cauchy stress itself. This is a common feature of simple viscoplastic models without kinematic hardening.\n\nSubstituting these derivatives back into the expression for $\\dot{\\psi}$:\n$$\n\\dot{\\psi} = \\sigma\\dot{\\varepsilon} - \\sigma\\dot{\\varepsilon}^{p}\n$$\nNow, we substitute this result for $\\dot{\\psi}$ into the Clausius–Duhem inequality:\n$$\n\\mathcal{D}(t) = \\sigma\\dot{\\varepsilon} - \\left(\\sigma\\dot{\\varepsilon} - \\sigma\\dot{\\varepsilon}^{p}\\right) = \\sigma\\dot{\\varepsilon}^{p}\n$$\nThis derivation confirms that the instantaneous dissipation rate is the product of the stress and the plastic strain rate, as specified in the problem statement.\n\nThe non-negativity of dissipation, $\\mathcal{D}(t) \\ge 0$, is a fundamental requirement. The plastic flow rule is given by $\\dot{\\varepsilon}^{p} = g(\\sigma)$. The provided data for $\\sigma \\ge 0$ shows that $\\dot{\\varepsilon}^{p} \\ge 0$. The rule of odd symmetry, $g(-\\sigma) = -g(\\sigma)$, implies that for $\\sigma  0$, the plastic strain rate $\\dot{\\varepsilon}^{p}$ will be non-positive. Consequently, the product $\\sigma \\dot{\\varepsilon}^{p} = \\sigma g(\\sigma)$ is non-negative for all possible values of $\\sigma$, satisfying the second law of thermodynamics. The total dissipation over a cycle, $\\mathcal{D}_{\\text{tot}} = \\int_{0}^{T} \\mathcal{D}(t)\\,dt$, must therefore also be non-negative.\n\n**2. Algorithmic Scheme for Numerical Integration**\n\nThe problem requires a numerical solution based on a forward-Euler time integration scheme. The state of the material at any time $t$ is described by the plastic strain $\\varepsilon^{p}(t)$. We must solve the initial value problem for the ordinary differential equation governing the evolution of $\\varepsilon^p$:\n$$\n\\dot{\\varepsilon}^{p}(t) = g\\left( E\\left( \\varepsilon(t) - \\varepsilon^{p}(t) \\right) \\right), \\quad \\text{with} \\quad \\varepsilon^{p}(0) = 0\n$$\nThe total strain $\\varepsilon(t)$ is a prescribed function of time, $\\varepsilon(t) = \\varepsilon_{0} \\sin\\left(2\\pi f t\\right)$.\n\nWe discretize the time interval $[0, T]$, where $T=1/f$, into $N$ steps of size $\\Delta t = T/N$. Let $t_n = n\\Delta t$ for $n = 0, 1, \\dots, N$. The discrete values of the variables at time $t_n$ will be denoted by a subscript $n$.\n\nThe algorithm proceeds as follows:\n\n1.  **Initialization**:\n    *   Set the initial plastic strain at time $t_0=0$: $\\varepsilon^{p}_{0} = 0$.\n    *   Set the initial total dissipation: $\\mathcal{D}_{\\text{tot}} = 0$.\n\n2.  **Time-Stepping Loop**: For each time step $n$ from $0$ to $N-1$:\n    a.  **Update Kinematics**: Compute the total strain at the current time $t_n$:\n        $$\n        \\varepsilon_n = \\varepsilon_{0} \\sin\\left(2\\pi f t_n\\right)\n        $$\n    b.  **Compute Stress**: Evaluate the stress using the state variables from the *current* step:\n        $$\n        \\sigma_n = E \\left(\\varepsilon_n - \\varepsilon^{p}_{n}\\right)\n        $$\n    c.  **Evaluate Plastic Strain Rate**: Use the data-driven function $g(\\sigma)$ to find the plastic strain rate:\n        $$\n        \\dot{\\varepsilon}^{p}_{n} = g(\\sigma_n)\n        $$\n        This function $g$ will be implemented using linear interpolation for internal points, linear extrapolation for points beyond the maximum provided stress, and odd symmetry for negative stress values.\n    d.  **Update Total Dissipation**: Compute the instantaneous dissipation rate $\\mathcal{D}_n = \\sigma_n \\dot{\\varepsilon}^{p}_{n}$ and add its contribution to the total dissipation using a rectangular quadrature rule consistent with the forward-Euler scheme:\n        $$\n        \\mathcal{D}_{\\text{tot}} \\leftarrow \\mathcal{D}_{\\text{tot}} + \\mathcal{D}_n \\Delta t\n        $$\n    e.  **Update State Variable**: Apply the explicit forward-Euler update rule to find the plastic strain for the *next* time step, $t_{n+1}$:\n        $$\n        \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\dot{\\varepsilon}^{p}_{n} \\Delta t\n        $$\n\n3.  **Finalization**: After the loop completes ($n=N-1$), the accumulated value of $\\mathcal{D}_{\\text{tot}}$ is the total dissipation per unit volume over one cycle. This final value is then rounded to the nearest integer as required.\n\nThis algorithmic design directly implements the derived physical laws within a discrete time-stepping framework, providing a robust method to solve the problem for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the computation for all test cases.\n    \"\"\"\n\n    # Test Suite Definition\n    test_cases = [\n        # Case A\n        {\n            \"E\": 2.10e11,  # Pa\n            \"g_data\": (\n                np.array([0, 3.0e8, 4.5e8, 6.0e8]),  # sigma (Pa)\n                np.array([0, 0, 5.0e-5, 2.0e-4]),    # edot_p (1/s)\n            ),\n            \"eps0\": 5.0e-3,\n            \"f\": 0.5,      # Hz\n            \"dt\": 1.0e-3,  # s\n        },\n        # Case B\n        {\n            \"E\": 2.10e11,\n            \"g_data\": (\n                np.array([0, 3.0e8, 4.5e8, 6.0e8]),\n                np.array([0, 0, 5.0e-5, 2.0e-4]),\n            ),\n            \"eps0\": 5.0e-4,\n            \"f\": 0.5,\n            \"dt\": 1.0e-3,\n        },\n        # Case C\n        {\n            \"E\": 7.0e10,\n            \"g_data\": (\n                np.array([0, 1.0e8, 2.0e8, 4.0e8]),\n                np.array([0, 0, 1.0e-4, 1.5e-4]),\n            ),\n            \"eps0\": 4.0e-3,\n            \"f\": 1.0,\n            \"dt\": 5.0e-4,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        D_tot = compute_dissipation(\n            E=case[\"E\"],\n            g_data=case[\"g_data\"],\n            eps0=case[\"eps0\"],\n            f=case[\"f\"],\n            dt=case[\"dt\"],\n        )\n        results.append(int(round(D_tot)))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_dissipation(E, g_data, eps0, f, dt):\n    \"\"\"\n    Computes the total dissipation for a single test case using a forward-Euler scheme.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        g_data (tuple): A tuple (sigma_points, edot_p_points) for the surrogate.\n        eps0 (float): Strain amplitude.\n        f (float): Frequency in Hz.\n        dt (float): Time step in s.\n\n    Returns:\n        float: Total dissipation per unit volume in J/m^3.\n    \"\"\"\n    \n    # 1. Setup the data-driven plastic strain rate function g(sigma)\n    sigma_pts, edot_p_pts = g_data\n    max_sigma = sigma_pts[-1]\n    \n    # Calculate slope for linear extrapolation\n    if len(sigma_pts) > 1 and sigma_pts[-1] != sigma_pts[-2]:\n        last_slope = (edot_p_pts[-1] - edot_p_pts[-2]) / (sigma_pts[-1] - sigma_pts[-2])\n    else:\n        last_slope = 0.0\n\n    # Memoization for the recursive g_func\n    memo = {}\n\n    def g_func(s):\n        \"\"\"Calculates plastic strain rate from stress using interpolation,\n           extrapolation, and odd symmetry.\"\"\"\n        if s in memo:\n            return memo[s]\n        \n        if s == 0.:\n            return 0.\n        \n        # Apply odd symmetry using recursion\n        if s  0.:\n            res = -g_func(-s)\n            memo[s] = res\n            return res\n        \n        # Linear extrapolation for sigma > max_sigma\n        if s > max_sigma:\n            res = edot_p_pts[-1] + last_slope * (s - max_sigma)\n            memo[s] = res\n            return res\n            \n        # Linear interpolation\n        res = np.interp(s, sigma_pts, edot_p_pts)\n        memo[s] = res\n        return res\n\n    # 2. Setup simulation parameters\n    T = 1.0 / f\n    num_steps = int(round(T / dt))\n    time_points = np.linspace(0, T, num_steps + 1)[:-1] # Use num_steps points from 0 to T-dt\n\n    # 3. Initialization of state variables and accumulators\n    ep_n = 0.0  # Plastic strain at step n\n    D_total = 0.0  # Total dissipation\n\n    # 4. Time integration loop\n    for n in range(num_steps):\n        t_n = time_points[n]\n        \n        # a. Update kinematics for current step\n        e_n = eps0 * np.sin(2.0 * np.pi * f * t_n)\n        \n        # b. Compute stress at current step\n        sigma_n = E * (e_n - ep_n)\n        \n        # c. Evaluate plastic strain rate\n        edot_p_n = g_func(sigma_n)\n        \n        # d. Update total dissipation (rectangular quadrature)\n        D_n = sigma_n * edot_p_n\n        D_total += D_n * dt\n        \n        # e. Update plastic strain for next step (Forward Euler)\n        ep_n = ep_n + edot_p_n * dt\n        \n    return D_total\n\nsolve()\n```"
        },
        {
            "introduction": "Traditional modeling relies on fitting experimental data to a predefined constitutive law, which can introduce significant modeling error. This exercise introduces you to a powerful alternative paradigm, Data-Driven Computational Mechanics (DDCM), which solves boundary value problems by working directly with the raw material data set . Implementing the core alternating projection algorithm will provide you with a practical understanding of how this state-of-the-art method finds solutions that are simultaneously consistent with physical laws and closest to the measured material behavior.",
            "id": "3799898",
            "problem": "Consider a one-dimensional bar in tension discretized into three serial subdomains (elements) with given lengths and cross-sectional areas. The bar is subjected to a prescribed end displacement under displacement control. You are given a finite set of experimental strain-stress pairs that define the available material data. The task is to implement a Data-Driven Computational Mechanics (DDCM) solver that, for each test case, computes the equilibrium solution under the displacement control and reports the indices of the selected experimental data pairs for each element at convergence.\n\nUse the following foundational principles:\n- Equilibrium in a one-dimensional bar in series requires a uniform stress across all elements, that is, $\\,\\sigma_e = \\sigma\\,$ for all elements $\\,e\\,$.\n- Kinematic compatibility in a one-dimensional bar under an end displacement $\\,u\\,$ requires that the elongations sum to the prescribed displacement, that is, $\\,\\sum_{e=1}^{n} \\varepsilon_e L_e = u\\,$ where $\\,\\varepsilon_e\\,$ is the strain in element $\\,e\\,$ and $\\,L_e\\,$ is its length.\n- The Data-Driven Computational Mechanics (DDCM) approach seeks the state closest to the material data set while satisfying equilibrium and compatibility in a metric that is physically grounded. Use a metric weighted by a reference modulus $\\,E_0\\,$ such that the squared distance for each element $\\,e\\,$ is $\\,E_0 (\\varepsilon_e - \\varepsilon_i)^2 + \\frac{1}{E_0} (\\sigma_e - \\sigma_i)^2\\,$ for any candidate data point $\\,(\\varepsilon_i, \\sigma_i)\\,$.\n\nDefine the geometry and material reference:\n- Number of elements: $\\,n = 3\\,$.\n- Lengths: $\\,L = [0.4, 0.3, 0.3]\\,\\text{m}\\,$.\n- Cross-sectional areas: $\\,A = [1.0 \\times 10^{-4}, 1.0 \\times 10^{-4}, 8.0 \\times 10^{-5}]\\,\\text{m}^2\\,$.\n- Reference modulus: $\\,E_0 = 2.0 \\times 10^{11}\\,\\text{Pa}\\,$.\n- Element weights: use $\\,w_e = A_e L_e\\,$ to account for the contribution of each element to the metric.\n\nMaterial data set (available experimental pairs used identically for all elements):\n- Indices $\\,i = 0, 1, 2, 3, 4, 5, 6\\,$ with pairs $\\,(\\varepsilon_i, \\sigma_i)\\,$ given by:\n  - $\\,i=0:\\,(\\,-1.0 \\times 10^{-3},\\,-2.0 \\times 10^{8}\\,)\\,$\n  - $\\,i=1:\\,(\\,0.0,\\,0.0\\,)\\,$\n  - $\\,i=2:\\,(\\,5.0 \\times 10^{-4},\\,1.0 \\times 10^{8}\\,)\\,$\n  - $\\,i=3:\\,(\\,1.0 \\times 10^{-3},\\,2.0 \\times 10^{8}\\,)\\,$\n  - $\\,i=4:\\,(\\,1.5 \\times 10^{-3},\\,2.05 \\times 10^{8}\\,)\\,$\n  - $\\,i=5:\\,(\\,2.0 \\times 10^{-3},\\,2.10 \\times 10^{8}\\,)\\,$\n  - $\\,i=6:\\,(\\,3.0 \\times 10^{-3},\\,2.20 \\times 10^{8}\\,)\\,$\nAll stresses are in Pascals ($\\,\\text{Pa}\\,$), all strains are dimensionless.\n\nAlgorithmic requirements:\n- Implement an alternating projection algorithm:\n  1. Projection onto the constraint set $\\,\\mathcal{C}\\,$ defined by equilibrium ($\\,\\sigma_e = \\sigma\\,$ for all $\\,e\\,$) and compatibility ($\\,\\sum_e \\varepsilon_e L_e = u\\,$), minimizing the weighted metric with weights $\\,w_e\\,$ and scaling by $\\,E_0\\,$.\n  2. Projection onto the data set $\\,\\mathcal{D}\\,$ for each element, selecting the data pair $\\,(\\varepsilon_i, \\sigma_i)\\,$ that minimizes the metric $\\,E_0 (\\varepsilon_e - \\varepsilon_i)^2 + \\frac{1}{E_0} (\\sigma - \\sigma_i)^2\\,$ for the current element state $\\,(\\varepsilon_e, \\sigma)\\,$.\n  3. Repeat until the selected indices stabilize. If multiple data points have equal distance, select the one with the smallest index.\n- Initialize the algorithm by selecting, for each element, the data point closest to the initial guess $\\,(\\varepsilon^{(0)}, \\sigma^{(0)})\\,$ where $\\,\\varepsilon^{(0)} = u / L_{\\text{tot}}\\,$ and $\\,\\sigma^{(0)} = E_0 \\varepsilon^{(0)}\\,$, with $\\,L_{\\text{tot}} = \\sum_e L_e\\,$.\n\nTest suite:\n- Prescribed displacements $\\,u\\,$ (in meters):\n  - $\\,u_1 = 0.0\\,$\n  - $\\,u_2 = 1.0 \\times 10^{-5}\\,$\n  - $\\,u_3 = 1.0 \\times 10^{-3}\\,$\n  - $\\,u_4 = 3.0 \\times 10^{-3}\\,$\nThese cover a compatibility boundary case, a very small displacement case where data sparsity may lead to zero-strain selection, a typical tension loading near a well-populated data point, and a higher loading case testing selection at the upper end of the data set.\n\nOutput specification:\n- For each prescribed displacement $\\,u_k\\,$, your program must return a list of $\\,n\\,$ integers representing the indices of the selected experimental data pairs for elements $\\,e = 1,2,3\\,$ at convergence.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a list of three integers (e.g., $\\,[[i_{1,1}, i_{1,2}, i_{1,3}], [i_{2,1}, i_{2,2}, i_{2,3}], [i_{3,1}, i_{3,2}, i_{3,3}], [i_{4,1}, i_{4,2}, i_{4,3}]]\\,$).\n\nUnits:\n- Displacement $\\,u\\,$ must be in meters ($\\,\\text{m}\\,$).\n- Stress $\\,\\sigma\\,$ must be in Pascals ($\\,\\text{Pa}\\,$).\n- Strain $\\,\\varepsilon\\,$ is dimensionless.\n\nYour implementation must be purely numerical and must not rely on external solvers beyond standard numerical computations. The test suite is fixed and must be embedded in your program.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of solid mechanics and computational physics, well-posed with a clear objective and constraints, and provides all necessary data for a unique numerical solution. The following is a complete, reasoned solution.\n\nThe core of the Data-Driven Computational Mechanics (DDCM) problem is to find a mechanical state $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$, where $\\boldsymbol{\\varepsilon} = \\{\\varepsilon_e\\}_{e=1}^n$ and $\\boldsymbol{\\sigma} = \\{\\sigma_e\\}_{e=1}^n$, that simultaneously satisfies a set of physical laws (the constraint set $\\mathcal{C}$) and is as close as possible to a set of material data points (the data set $\\mathcal{D}$). The state $(\\boldsymbol{\\varepsilon}^*, \\boldsymbol{\\sigma}^*)$, where $(\\varepsilon_e^*, \\sigma_e^*) \\in \\mathcal{D}$ for each element $e$, represents the chosen data points.\n\nThe problem is formulated as minimizing a total distance functional, $J$, subject to these two sets of constraints:\n$$\n\\min_{(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma}) \\in \\mathcal{C}, (\\boldsymbol{\\varepsilon}^*, \\boldsymbol{\\sigma}^*) \\in \\mathcal{D}^n} J(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma}, \\boldsymbol{\\varepsilon}^*, \\boldsymbol{\\sigma}^*) = \\sum_{e=1}^{n} w_e \\left[ E_0 (\\varepsilon_e - \\varepsilon_e^*)^2 + \\frac{1}{E_0} (\\sigma_e - \\sigma_e^*)^2 \\right]\n$$\nHere, $n=3$ is the number of elements, $w_e = A_e L_e$ is the volume-based weight for element $e$, and $E_0$ is a reference modulus. The constraint set $\\mathcal{C}$ enforces:\n1.  **Equilibrium**: The stress $\\sigma$ is uniform across all elements, i.e., $\\sigma_e = \\sigma$ for $e=1, \\dots, n$.\n2.  **Compatibility**: The total elongation equals the prescribed displacement $u$, i.e., $\\sum_{e=1}^{n} \\varepsilon_e L_e = u$.\n\nThe data set $\\mathcal{D}$ consists of a finite number of discrete strain-stress pairs $(\\varepsilon_i, \\sigma_i)$.\n\nThis minimization problem is solved using an alternating projection algorithm, which iteratively projects the current state onto the constraint set $\\mathcal{C}$ and the data set $\\mathcal{D}$ until convergence.\n\n### Algorithm Description\n\n**1. Initialization**\nFor a given prescribed displacement $u$, an initial guess for the state is formed based on a homogeneous linear elastic assumption.\n- The total length of the bar is $L_{\\text{tot}} = \\sum_{e=1}^n L_e$.\n- The average strain is $\\varepsilon^{(0)} = u / L_{\\text{tot}}$.\n- The initial stress is $\\sigma^{(0)} = E_0 \\varepsilon^{(0)}$.\nThe algorithm begins with a projection of this initial state $(\\varepsilon^{(0)}, \\sigma^{(0)})$ onto the data set $\\mathcal{D}$. For each element $e$, we find the data point $(\\varepsilon_i, \\sigma_i) \\in \\mathcal{D}$ that minimizes the distance metric $d_i^2 = E_0 (\\varepsilon^{(0)} - \\varepsilon_i)^2 + \\frac{1}{E_0} (\\sigma^{(0)} - \\sigma_i)^2$. This gives an initial set of data points $(\\boldsymbol{\\varepsilon}^{*(0)}, \\boldsymbol{\\sigma}^{*(0)})$ and their corresponding indices, which we denote as $\\text{indices}^{(0)}$.\n\n**2. Iterative Projections**\nThe algorithm proceeds in a loop, indexed by $k=0, 1, 2, \\dots$. Each iteration consists of two steps.\n\n**Step A: Projection onto the Constraint Set $\\mathcal{C}$**\nGiven the state from the data set $(\\boldsymbol{\\varepsilon}^{*(k)}, \\boldsymbol{\\sigma}^{*(k)})$, we find the state $(\\boldsymbol{\\varepsilon}^{(k+1/2)}, \\boldsymbol{\\sigma}^{(k+1/2)}) \\in \\mathcal{C}$ that minimizes the weighted sum of squared distances. Incorporating the equilibrium constraint $\\sigma_e = \\sigma$, the minimization problem is:\n$$\n\\min_{\\varepsilon_1, \\dots, \\varepsilon_n, \\sigma} \\sum_{e=1}^{n} w_e \\left[ E_0 (\\varepsilon_e - \\varepsilon_e^{*(k)})^2 + \\frac{1}{E_0} (\\sigma - \\sigma_e^{*(k)})^2 \\right] \\quad \\text{subject to} \\quad \\sum_{e=1}^{n} \\varepsilon_e L_e - u = 0\n$$\nWe solve this using the method of Lagrange multipliers. The Lagrangian is:\n$$\n\\mathcal{L}(\\boldsymbol{\\varepsilon}, \\sigma, \\lambda) = \\sum_{e=1}^{n} \\left( w_e E_0 (\\varepsilon_e - \\varepsilon_e^{*(k)})^2 + w_e \\frac{1}{E_0} (\\sigma - \\sigma_e^{*(k)})^2 \\right) + \\lambda \\left( \\sum_{e=1}^{n} \\varepsilon_e L_e - u \\right)\n$$\nThe first-order necessary conditions for a minimum are $\\frac{\\partial \\mathcal{L}}{\\partial \\varepsilon_e} = 0$, $\\frac{\\partial \\mathcal{L}}{\\partial \\sigma} = 0$, and $\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = 0$.\n\nFrom $\\frac{\\partial \\mathcal{L}}{\\partial \\sigma} = \\sum_{e=1}^{n} 2 w_e \\frac{1}{E_0} (\\sigma - \\sigma_e^{*(k)}) = 0$, we solve for the projected stress $\\sigma^{(k+1/2)}$:\n$$\n\\sigma^{(k+1/2)} = \\frac{\\sum_{e=1}^{n} w_e \\sigma_e^{*(k)}}{\\sum_{e=1}^{n} w_e}\n$$\nThis is a weighted average of the stresses from the current data points.\n\nFrom $\\frac{\\partial \\mathcal{L}}{\\partial \\varepsilon_e} = 2 w_e E_0 (\\varepsilon_e - \\varepsilon_e^{*(k)}) + \\lambda L_e = 0$, we find $\\varepsilon_e = \\varepsilon_e^{*(k)} - \\frac{\\lambda L_e}{2 w_e E_0}$. Substituting this into the compatibility constraint $\\sum_{e=1}^{n} \\varepsilon_e L_e = u$ allows us to solve for the Lagrange multiplier $\\lambda$. With $w_e = A_e L_e$, we get:\n$$\n\\sum_{e=1}^{n} \\left( \\varepsilon_e^{*(k)} - \\frac{\\lambda L_e}{2 (A_e L_e) E_0} \\right) L_e = u \\implies \\sum_{e=1}^{n} \\varepsilon_e^{*(k)} L_e - \\frac{\\lambda}{2 E_0} \\sum_{e=1}^{n} \\frac{L_e}{A_e} = u\n$$\nSolving for $\\lambda$ and substituting back into the expression for $\\varepsilon_e$ yields the projected strains $\\varepsilon_e^{(k+1/2)}$:\n$$\n\\varepsilon_e^{(k+1/2)} = \\varepsilon_e^{*(k)} - \\frac{1}{A_e} \\frac{\\sum_{j=1}^{n} \\varepsilon_j^{*(k)} L_j - u}{\\sum_{j=1}^{n} (L_j/A_j)}\n$$\n\n**Step B: Projection onto the Data Set $\\mathcal{D}$**\nGiven the state $(\\boldsymbol{\\varepsilon}^{(k+1/2)}, \\sigma^{(k+1/2)})$ from Step A, we project it back onto the material data set $\\mathcal{D}$. This is done independently for each element. For each element $e$, we find the index $i_e$ of the data point $(\\varepsilon_i, \\sigma_i) \\in \\mathcal{D}$ that minimizes the unweighted squared distance:\n$$\nd_i^2 = E_0 (\\varepsilon_e^{(k+1/2)} - \\varepsilon_i)^2 + \\frac{1}{E_0} (\\sigma^{(k+1/2)} - \\sigma_i)^2\n$$\nIn case of a tie where multiple data points have the same minimum distance, the one with the smallest index $i$ is chosen. The new state from the data set is then $(\\varepsilon_e^{*(k+1)}, \\sigma_e^{*(k+1)}) = (\\varepsilon_{i_e}, \\sigma_{i_e})$, and we obtain the new list of indices, $\\text{indices}^{(k+1)}$.\n\n**3. Convergence**\nThe iterative process continues until the selected indices no longer change, i.e., $\\text{indices}^{(k+1)} = \\text{indices}^{(k)}$. At this point, the algorithm has converged, and the final list of indices is the solution. A maximum number of iterations is included as a failsafe.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Data-Driven Computational Mechanics (DDCM) solver\n    for a 1D bar and reports the indices of selected data points.\n    \"\"\"\n    # Define geometry and material reference from the problem statement\n    L = np.array([0.4, 0.3, 0.3])  # m\n    A = np.array([1.0e-4, 1.0e-4, 8.0e-5])  # m^2\n    E0 = 2.0e11  # Pa\n    n_elements = 3\n\n    # Define the material data set D = {(strain_i, stress_i)}\n    material_data = np.array([\n        [-1.0e-3, -2.0e8],  # i=0\n        [0.0, 0.0],          # i=1\n        [5.0e-4, 1.0e8],   # i=2\n        [1.0e-3, 2.0e8],   # i=3\n        [1.5e-3, 2.05e8],  # i=4\n        [2.0e-3, 2.10e8],  # i=5\n        [3.0e-3, 2.20e8]   # i=6\n    ])\n\n    # Prescribed displacements for the test suite\n    test_cases = [0.0, 1.0e-5, 1.0e-3, 3.0e-3]\n\n    # Pre-compute constants for the iterative solver\n    L_tot = np.sum(L)\n    w = A * L\n    sum_w = np.sum(w)\n    sum_L_div_A = np.sum(L / A)\n    \n    def run_ddcm_solver(u):\n        \"\"\"\n        Executes the alternating projection algorithm for a given displacement u.\n        \"\"\"\n        # --- Initialization ---\n        # Initial guess based on average strain and reference modulus\n        eps0 = u / L_tot\n        sig0 = E0 * eps0\n        \n        # Initial projection to the data set D\n        initial_state = np.array([eps0, sig0])\n        strains_data = material_data[:, 0]\n        stresses_data = material_data[:, 1]\n        \n        distances_sq = E0 * (initial_state[0] - strains_data)**2 + \\\n                       (1/E0) * (initial_state[1] - stresses_data)**2\n        \n        min_dist_sq = np.min(distances_sq)\n        # Handle ties by choosing the smallest index\n        tied_indices = np.where(np.isclose(distances_sq, min_dist_sq))[0]\n        initial_index = np.min(tied_indices)\n\n        prev_indices = np.full(n_elements, initial_index, dtype=int)\n        \n        eps_star = material_data[prev_indices, 0]\n        sig_star = material_data[prev_indices, 1]\n\n        max_iterations = 100\n        for _ in range(max_iterations):\n            # --- Step A: Projection onto the constraint set C ---\n            # Equilibrium (uniform stress)\n            sig_proj = np.sum(w * sig_star) / sum_w\n            \n            # Compatibility (strain distribution)\n            numerator = np.sum(eps_star * L) - u\n            eps_proj = eps_star - (1/A) * (numerator / sum_L_div_A)\n\n            # --- Step B: Projection onto the data set D ---\n            new_indices = np.zeros(n_elements, dtype=int)\n            for e in range(n_elements):\n                current_state_e = np.array([eps_proj[e], sig_proj])\n                \n                # Calculate squared distances to all data points\n                distances_sq = E0 * (current_state_e[0] - strains_data)**2 + \\\n                               (1/E0) * (current_state_e[1] - stresses_data)**2\n                \n                # Find minimum distance and handle ties\n                min_dist_sq = np.min(distances_sq)\n                tied_indices = np.where(np.isclose(distances_sq, min_dist_sq))[0]\n                best_index = np.min(tied_indices)\n                new_indices[e] = best_index\n            \n            # --- Check for convergence ---\n            if np.array_equal(new_indices, prev_indices):\n                return new_indices.tolist()\n\n            prev_indices = new_indices\n            eps_star = material_data[prev_indices, 0]\n            sig_star = material_data[prev_indices, 1]\n            \n        # Return last state if max iterations are reached (should not happen for this problem)\n        return prev_indices.tolist()\n\n    results = []\n    for u_case in test_cases:\n        converged_indices = run_ddcm_solver(u_case)\n        results.append(converged_indices)\n    \n    # Format the results into a string as per the output specification\n    # e.g., \"[[1,1,1],[1,1,1],[3,3,3],[6,6,6]]\"\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}