{
    "hands_on_practices": [
        {
            "introduction": "这个练习展示了一个基本的多尺度链接：从微观描述（原子间势）推导宏观属性（弹性张量）。我们将使用柯西-玻恩法则 (Cauchy-Born rule)，一个将原子位移与连续介质变形联系起来的经典假设，来观察一个由数据驱动的键刚度参数如何决定材料的弹性响应。这项实践旨在培养自下而上建模的基础技能。",
            "id": "3799940",
            "problem": "考虑一个二维三角布拉菲晶格，每个原胞含一个原子，最近邻间距为 $a$。在柯西-玻恩假设下，一个均匀小应变 $\\,\\boldsymbol{\\varepsilon}\\,$ 将每个参考键矢量 $\\mathbf{R}$ 映射为 $\\mathbf{r} = (\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{R}$，其中 $\\mathbf{I}$ 是单位张量。单原子能量由中心对势 $\\phi(r)$ 建模，每个原子的总能量由对所有不同邻键的求和给出。假设只有六个最近邻有贡献，并采用谐波形式 $\\phi(r) = \\tfrac{1}{2} k (r - a)^{2}$，其中 $k$ 是一个从原子模拟的数据驱动回归中推断出的键刚度参数。\n\n设坐标轴的选择使得六个最近邻方向之一与 $x$ 轴对齐。这六个单位方向矢量为\n$$\n\\mathbf{n}_{1} = \\begin{pmatrix}1 \\\\ 0\\end{pmatrix},\\quad\n\\mathbf{n}_{2} = \\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{\\sqrt{3}}{2}\\end{pmatrix},\\quad\n\\mathbf{n}_{3} = \\begin{pmatrix}-\\tfrac{1}{2} \\\\ \\tfrac{\\sqrt{3}}{2}\\end{pmatrix},\\quad\n\\mathbf{n}_{4} = \\begin{pmatrix}-1 \\\\ 0\\end{pmatrix},\\quad\n\\mathbf{n}_{5} = \\begin{pmatrix}-\\tfrac{1}{2} \\\\ -\\tfrac{\\sqrt{3}}{2}\\end{pmatrix},\\quad\n\\mathbf{n}_{6} = \\begin{pmatrix}\\tfrac{1}{2} \\\\ -\\tfrac{\\sqrt{3}}{2}\\end{pmatrix}.\n$$\n每个参考键为 $\\mathbf{R}_{m} = a\\,\\mathbf{n}_{m}$，其中 $m = 1,\\dots,6$。原胞面积为 $A_{0} = \\tfrac{\\sqrt{3}}{2} a^{2}$，因此原子数密度为 $\\rho_{\\mathrm{atom}} = \\tfrac{1}{A_{0}} = \\tfrac{2}{\\sqrt{3}\\,a^{2}}$。\n\n从应变能密度的定义和柯西-玻恩映射出发，推导连续介质弹性张量 $C_{ijkl}$，用关于最近邻方向和基本量的晶格求和来表示。然后，使用给定的方向，显式计算 $C_{1111}$。\n\n最后，给定数据驱动参数 $k = 45\\,\\text{N/m}$ 和 $a = 2.50 \\times 10^{-10}\\,\\text{m}$，计算该晶格的 $C_{1111}$ 的数值。以 $\\text{N/m}$ 为单位表示您的最终答案，并四舍五入到四位有效数字。",
            "solution": "出发点是单位面积的应变能密度 $W(\\boldsymbol{\\varepsilon})$，它是根据柯西-玻恩假设从单原子能量中获得的。对于中心对势 $\\phi(r)$ 和均匀小应变 $\\boldsymbol{\\varepsilon}$，每个大小为 $a$、单位方向为 $\\mathbf{n}$ 的参考键矢量 $\\mathbf{R}$ 被映射为\n$$\n\\mathbf{r} = (\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{R} = a\\,(\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{n}.\n$$\n在 $\\boldsymbol{\\varepsilon}$ 的主导阶上，拉伸后的键长为\n$$\nr = \\|\\mathbf{r}\\| = a\\,\\left\\|(\\mathbf{I} + \\boldsymbol{\\varepsilon}) \\mathbf{n}\\right\\| \\approx a \\left( 1 + \\mathbf{n}^{\\mathsf{T}} \\boldsymbol{\\varepsilon}\\, \\mathbf{n} \\right),\n$$\n所以键长的一阶变化为\n$$\n\\delta r \\equiv r - a \\approx a\\,\\mathbf{n}^{\\mathsf{T}} \\boldsymbol{\\varepsilon}\\, \\mathbf{n} = a\\, n_{i}\\,\\varepsilon_{ij}\\,n_{j},\n$$\n这里使用了爱因斯坦求和约定。\n\n对于对势，单原子能量为\n$$\nE_{\\mathrm{atom}} = \\tfrac{1}{2}\\sum_{m} \\phi(r_{m}),\n$$\n这里的因子 $\\tfrac{1}{2}$ 是为了防止对偶的重复计算。对于谐波势 $\\phi(r) = \\tfrac{1}{2}k (r - a)^{2}$ 和小应变，单原子能量的二阶变化为\n$$\n\\Delta E_{\\mathrm{atom}} = \\tfrac{1}{2} \\sum_{m} \\tfrac{1}{2} k\\, (\\delta r_{m})^{2}\n= \\tfrac{k}{4} \\sum_{m} \\left( a\\, n^{(m)}_{i}\\,\\varepsilon_{ij}\\,n^{(m)}_{j} \\right)^{2}\n= \\tfrac{k a^{2}}{4} \\sum_{m} \\varepsilon_{ij}\\,\\varepsilon_{kl}\\, n^{(m)}_{i} n^{(m)}_{j} n^{(m)}_{k} n^{(m)}_{l}.\n$$\n乘以原子数密度 $\\rho_{\\mathrm{atom}}$，得到单位面积的应变能密度：\n$$\n\\Delta W(\\boldsymbol{\\varepsilon}) = \\rho_{\\mathrm{atom}}\\,\\Delta E_{\\mathrm{atom}}\n= \\tfrac{k a^{2}}{4}\\,\\rho_{\\mathrm{atom}} \\sum_{m} \\varepsilon_{ij}\\,\\varepsilon_{kl}\\, n^{(m)}_{i} n^{(m)}_{j} n^{(m)}_{k} n^{(m)}_{l}.\n$$\n根据弹性张量的定义，\n$$\n\\Delta W(\\boldsymbol{\\varepsilon}) = \\tfrac{1}{2} C_{ijkl}\\, \\varepsilon_{ij}\\, \\varepsilon_{kl}.\n$$\n匹配 $\\varepsilon_{ij}\\varepsilon_{kl}$ 的系数，我们得到\n$$\nC_{ijkl} = \\tfrac{k a^{2}}{2}\\,\\rho_{\\mathrm{atom}} \\sum_{m} n^{(m)}_{i} n^{(m)}_{j} n^{(m)}_{k} n^{(m)}_{l}.\n$$\n\n现在我们使用给定的六个单位矢量来计算三角晶格的 $C_{1111}$。将 $\\mathbf{n}_{m}$ 的 $x$ 分量记为 $n_{1}^{(m)}$，我们有\n$$\nC_{1111} = \\tfrac{k a^{2}}{2}\\,\\rho_{\\mathrm{atom}} \\sum_{m=1}^{6} \\left(n_{1}^{(m)}\\right)^{4}.\n$$\n这六个 $x$ 分量是 $1,\\,\\tfrac{1}{2},\\,-\\tfrac{1}{2},\\,-1,\\,-\\tfrac{1}{2},\\,\\tfrac{1}{2}$，所以\n$$\n\\sum_{m=1}^{6} \\left(n_{1}^{(m)}\\right)^{4} = 1^{4} + \\left(\\tfrac{1}{2}\\right)^{4} + \\left(-\\tfrac{1}{2}\\right)^{4} + (-1)^{4} + \\left(-\\tfrac{1}{2}\\right)^{4} + \\left(\\tfrac{1}{2}\\right)^{4}\n= 2 + 4 \\times \\tfrac{1}{16} = 2 + \\tfrac{1}{4} = \\tfrac{9}{4}.\n$$\n原子数密度为\n$$\n\\rho_{\\mathrm{atom}} = \\tfrac{1}{A_{0}} = \\tfrac{2}{\\sqrt{3}\\,a^{2}}.\n$$\n因此，\n$$\nC_{1111} = \\tfrac{k a^{2}}{2} \\cdot \\tfrac{2}{\\sqrt{3}\\,a^{2}} \\cdot \\tfrac{9}{4} = \\tfrac{9}{4\\sqrt{3}}\\,k.\n$$\n\n代入 $k = 45\\,\\text{N/m}$ 和 $a = 2.50 \\times 10^{-10}\\,\\text{m}$（如上所示，$a$ 被消掉了），我们得到\n$$\nC_{1111} = \\tfrac{9}{4\\sqrt{3}} \\times 45 \\,\\text{N/m}.\n$$\n使用 $\\sqrt{3} \\approx 1.7320508076$，\n$$\n\\tfrac{9}{4\\sqrt{3}} \\approx \\tfrac{9}{6.9282032303} \\approx 1.299038105,\n$$\n因而\n$$\nC_{1111} \\approx 1.299038105 \\times 45 \\,\\text{N/m} \\approx 58.4567147 \\,\\text{N/m}.\n$$\n四舍五入到四位有效数字并以 $\\text{N/m}$ 为单位表示，结果是 $58.46\\,\\text{N/m}$。",
            "answer": "$$\\boxed{58.46}$$"
        },
        {
            "introduction": "一个功能强大的数据驱动模型如果违反了基本物理定律，那它将毫无用处。本实践旨在解决这一问题，将热力学第二定律（通过克劳修斯-杜亥姆不等式）应用于一个数据驱动的粘塑性代理模型。您将计算在一个加载循环中的能量耗散，以确保其为非负值，这是对任何有物理意义的材料模型进行的关键检验。",
            "id": "3799880",
            "problem": "考虑一个等温、小应变的一维粘塑性材料，其塑性应变率由一个数据驱动的代理模型来建模。设单位体积的 Helmholtz 自由能为 $\\psi(\\varepsilon,\\varepsilon^{p}) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2}$，其中 $\\varepsilon$ 是总轴向应变，$\\varepsilon^{p}$ 是塑性应变，$E$ 是杨氏模量。Cauchy 应力通过标准的超弹性关系 $\\sigma = \\dfrac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\varepsilon^{p}\\right)$ 获得。塑性应变率由一个数据驱动的代理模型 $\\dot{\\varepsilon}^{p} = g(\\sigma)$ 提供，该模型根据正应力数据对构建，并通过奇对称性扩展到所有应力。基本的热力学要求是等温过程的 Clausius–Duhem 不等式，以单位体积表示为 $\\mathcal{D}(t) = \\sigma(t)\\,\\dot{\\varepsilon}(t) - \\dfrac{d}{dt}\\psi\\left(\\varepsilon(t),\\varepsilon^{p}(t)\\right) \\ge 0$ 对所有 $t$ 成立，其中 $\\mathcal{D}(t)$ 是瞬时耗散率密度。\n\n任务：仅从上述基本定律和定义出发，推导出一个算法方案，用于计算在一个指定应变循环内的总耗散，并验证其非负性。使用以下要求：\n\n- 本构自由能定义 $\\psi(\\varepsilon,\\varepsilon^{p}) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2}$ 和应力定义 $\\sigma = E\\left(\\varepsilon - \\varepsilon^{p}\\right)$ 是强制性的。数据驱动的代理模型必须被视为塑性流动的速率势：$\\dot{\\varepsilon}^{p} = g(\\sigma)$，其中 $g$ 函数通过对所提供的正 $\\sigma$ 数据对进行插值来指定，并通过奇对称性 $g(-\\sigma) = -g(\\sigma)$ 扩展到负 $\\sigma$。对于超出所提供最大数据点的 $\\sigma$，使用最后一段的斜率进行线性外推。\n- 载荷是一个指定的正弦应变历史 $\\varepsilon(t) = \\varepsilon_{0} \\sin\\left(2\\pi f t\\right)$，作用于整整一个周期 $T = 1/f$，其导数已知 $\\dot{\\varepsilon}(t) = 2\\pi f \\varepsilon_{0} \\cos\\left(2\\pi f t\\right)$。\n- 时间积分必须以均匀的时间步长 $\\Delta t$ 进行，采用显式前向 Euler 更新 $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\dot{\\varepsilon}^{p}_{n} \\Delta t$，并在每一步中计算应力为 $\\sigma_{n} = E\\left(\\varepsilon_{n} - \\varepsilon^{p}_{n}\\right)$。将瞬时耗散率密度计算为 $\\mathcal{D}_{n} = \\sigma_{n}\\,\\dot{\\varepsilon}^{p}_{n}$，并使用一致的求积方法在整个循环中进行数值积分，以获得单位体积的总耗散 $\\mathcal{D}_{\\text{tot}} = \\int_{0}^{T} \\mathcal{D}(t)\\,dt$。\n- 以焦耳每立方米（joules per cubic meter）为单位表示单位体积的总耗散，并四舍五入到最接近的整数。\n\n实现一个完整的程序，为以下三个测试案例中的每一个计算 $\\mathcal{D}_{\\text{tot}}$。在每个案例中，代理模型 $g(\\sigma)$ 是通过所列出的正 $\\sigma$ 的 $(\\sigma_{i}, \\dot{\\varepsilon}^{p}_{i})$ 数据对定义的，并通过奇对称性扩展到所有 $\\sigma$，数据点之间使用线性插值，超出最后一个数据点则使用最后一段的斜率进行线性外推。$\\sigma$ 的单位是帕斯卡（pascals），$\\dot{\\varepsilon}^{p}$ 的单位是反秒（inverse seconds）。\n\n测试套件（每个案例运行一个完整周期，并使用指定的参数）：\n\n- 案例 A:\n  - $E = 2.10\\times 10^{11}\\,\\text{Pa}$。\n  - $\\sigma \\ge 0$ 时 $g$ 的数据对：$(0, 0)$, $(3.0\\times 10^{8}, 0)$, $(4.5\\times 10^{8}, 5.0\\times 10^{-5})$, $(6.0\\times 10^{8}, 2.0\\times 10^{-4})$。\n  - 应变幅值和频率：$\\varepsilon_{0} = 5.0\\times 10^{-3}$，$f = 5.0\\times 10^{-1}\\,\\text{Hz}$。\n  - 时间步长：$\\Delta t = 1.0\\times 10^{-3}\\,\\text{s}$。\n\n- 案例 B:\n  - $E = 2.10\\times 10^{11}\\,\\text{Pa}$。\n  - $\\sigma \\ge 0$ 时 $g$ 的数据对：$(0, 0)$, $(3.0\\times 10^{8}, 0)$, $(4.5\\times 10^{8}, 5.0\\times 10^{-5})$, $(6.0\\times 10^{8}, 2.0\\times 10^{-4})$。\n  - 应变幅值和频率：$\\varepsilon_{0} = 5.0\\times 10^{-4}$，$f = 5.0\\times 10^{-1}\\,\\text{Hz}$。\n  - 时间步长：$\\Delta t = 1.0\\times 10^{-3}\\,\\text{s}$。\n\n- 案例 C:\n  - $E = 7.0\\times 10^{10}\\,\\text{Pa}$。\n  - $\\sigma \\ge 0$ 时 $g$ 的数据对：$(0, 0)$, $(1.0\\times 10^{8}, 0)$, $(2.0\\times 10^{8}, 1.0\\times 10^{-4})$, $(4.0\\times 10^{8}, 1.5\\times 10^{-4})$。\n  - 应变幅值和频率：$\\varepsilon_{0} = 4.0\\times 10^{-3}$，$f = 1.0\\,\\text{Hz}$。\n  - 时间步长：$\\Delta t = 5.0\\times 10^{-4}\\,\\text{s}$。\n\n输出规范：\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[\\mathcal{D}_{\\text{tot}}^{A},\\mathcal{D}_{\\text{tot}}^{B},\\mathcal{D}_{\\text{tot}}^{C}]$，其中每个条目是对应案例的单位体积总耗散，单位为焦耳每立方米，并四舍五入到最接近的整数。",
            "solution": "该问题提法明确且科学上合理，其基础是非弹性材料的连续介质力学和热力学的基本原理。我们首先将推导耗散率的表达式，然后构建数值算法来计算指定应变循环下的总耗散。\n\n**1. 热力学基础与耗散率**\n\n分析始于等温过程的 Clausius–Duhem 不等式，这是热力学第二定律的一种表述。以单位体积计，其形式为：\n$$\n\\mathcal{D}(t) = \\sigma(t)\\,\\dot{\\varepsilon}(t) - \\dot{\\psi}\\left(\\varepsilon(t),\\varepsilon^{p}(t)\\right) \\ge 0\n$$\n其中 $\\mathcal{D}(t)$ 是瞬时耗散率，$\\sigma(t)$ 是 Cauchy 应力，$\\dot{\\varepsilon}(t)$ 是总应变率，而 $\\dot{\\psi}$ 是 Helmholtz 自由能密度 $\\psi$ 的物质时间导数。\n\nHelmholtz 自由能密度 $\\psi$ 是状态变量的函数，对于该模型，状态变量是总应变 $\\varepsilon$ 和塑性应变 $\\varepsilon^{p}$。其物质时间导数通过应用链式法则求得：\n$$\n\\dot{\\psi} = \\frac{d\\psi}{dt} = \\frac{\\partial\\psi}{\\partial\\varepsilon}\\dot{\\varepsilon} + \\frac{\\partial\\psi}{\\partial\\varepsilon^{p}}\\dot{\\varepsilon}^{p}\n$$\n应力 $\\sigma$ 的本构关系以及与塑性应变共轭的热力学力，均从自由能势中导出：\n$$\n\\sigma = \\frac{\\partial\\psi}{\\partial\\varepsilon} \\quad \\text{和} \\quad \\sigma^{p} = -\\frac{\\partial\\psi}{\\partial\\varepsilon^{p}}\n$$\n其中 $\\sigma^p$ 是背应力或塑性流动的热力学驱动力。\n\n使用所提供的自由能的具体形式 $\\psi(\\varepsilon,\\varepsilon^{p}) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2}$，我们计算这些导数：\n$$\n\\sigma = \\frac{\\partial}{\\partial\\varepsilon} \\left( \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2} \\right) = E (\\varepsilon - \\varepsilon^{p})\n$$\n这精确地恢复了给定的应力定义，证实了其一致性。对于背应力，我们发现：\n$$\n\\sigma^{p} = -\\frac{\\partial}{\\partial\\varepsilon^{p}} \\left( \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{p}\\right)^{2} \\right) = -E (\\varepsilon - \\varepsilon^{p})(-1) = E (\\varepsilon - \\varepsilon^{p}) = \\sigma\n$$\n因此，塑性流动的热力学驱动力就是 Cauchy 应力本身。这是不含随动硬化的简单粘塑性模型的一个共同特征。\n\n将这些导数代回 $\\dot{\\psi}$ 的表达式中：\n$$\n\\dot{\\psi} = \\sigma\\dot{\\varepsilon} - \\sigma\\dot{\\varepsilon}^{p}\n$$\n现在，我们将这个关于 $\\dot{\\psi}$ 的结果代入 Clausius–Duhem 不等式：\n$$\n\\mathcal{D}(t) = \\sigma\\dot{\\varepsilon} - \\left(\\sigma\\dot{\\varepsilon} - \\sigma\\dot{\\varepsilon}^{p}\\right) = \\sigma\\dot{\\varepsilon}^{p}\n$$\n此推导证实了瞬时耗散率是应力与塑性应变率的乘积，与问题陈述中指定的一致。\n\n耗散的非负性 $\\mathcal{D}(t) \\ge 0$ 是一项基本要求。塑性流动法则是 $\\dot{\\varepsilon}^{p} = g(\\sigma)$。对于 $\\sigma \\ge 0$ 所提供的数据显示 $\\dot{\\varepsilon}^{p} \\ge 0$。奇对称性规则 $g(-\\sigma) = -g(\\sigma)$ 意味着当 $\\sigma  0$ 时，塑性应变率 $\\dot{\\varepsilon}^{p}$ 将是非正的。因此，乘积 $\\sigma \\dot{\\varepsilon}^{p} = \\sigma g(\\sigma)$ 对于所有可能的 $\\sigma$ 值都是非负的，从而满足热力学第二定律。因此，在一个周期内的总耗散 $\\mathcal{D}_{\\text{tot}} = \\int_{0}^{T} \\mathcal{D}(t)\\,dt$ 也必须是非负的。\n\n**2. 用于数值积分的算法方案**\n\n该问题要求一个基于前向 Euler 时间积分方案的数值解。材料在任意时刻 $t$ 的状态由塑性应变 $\\varepsilon^{p}(t)$ 描述。我们必须求解控制 $\\varepsilon^p$ 演化的常微分方程的初值问题：\n$$\n\\dot{\\varepsilon}^{p}(t) = g\\left( E\\left( \\varepsilon(t) - \\varepsilon^{p}(t) \\right) \\right), \\quad \\text{with} \\quad \\varepsilon^{p}(0) = 0\n$$\n总应变 $\\varepsilon(t)$ 是一个给定的时间函数，$\\varepsilon(t) = \\varepsilon_{0} \\sin\\left(2\\pi f t\\right)$。\n\n我们将时间区间 $[0, T]$（其中 $T=1/f$）离散化为 $N$ 个步长为 $\\Delta t = T/N$ 的时间步。设 $t_n = n\\Delta t$，其中 $n = 0, 1, \\dots, N$。在时间 $t_n$ 的变量离散值将用下标 $n$ 表示。\n\n该算法流程如下：\n\n1.  **初始化**：\n    *   设置初始时刻 $t_0=0$ 的塑性应变：$\\varepsilon^{p}_{0} = 0$。\n    *   设置初始总耗散：$\\mathcal{D}_{\\text{tot}} = 0$。\n\n2.  **时间步循环**：对从 $0$ 到 $N-1$ 的每个时间步 $n$：\n    a.  **更新运动学**：计算当前时刻 $t_n$ 的总应变：\n        $$\n        \\varepsilon_n = \\varepsilon_{0} \\sin\\left(2\\pi f t_n\\right)\n        $$\n    b.  **计算应力**：使用*当前*步的状态变量评估应力：\n        $$\n        \\sigma_n = E \\left(\\varepsilon_n - \\varepsilon^{p}_{n}\\right)\n        $$\n    c.  **评估塑性应变率**：使用数据驱动函数 $g(\\sigma)$ 来求得塑性应变率：\n        $$\n        \\dot{\\varepsilon}^{p}_{n} = g(\\sigma_n)\n        $$\n        该函数 $g$ 将通过对内部点使用线性插值、对超出所提供最大应力的点使用线性外推、以及对负应力值使用奇对称性来实现。\n    d.  **更新总耗散**：计算瞬时耗散率 $\\mathcal{D}_n = \\sigma_n \\dot{\\varepsilon}^{p}_{n}$，并使用与前向 Euler 方案一致的矩形求积法则将其贡献累加到总耗散中：\n        $$\n        \\mathcal{D}_{\\text{tot}} \\leftarrow \\mathcal{D}_{\\text{tot}} + \\mathcal{D}_n \\Delta t\n        $$\n    e.  **更新状态变量**：应用显式前向 Euler 更新法则来求得*下一个*时间步 $t_{n+1}$ 的塑性应变：\n        $$\n        \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\dot{\\varepsilon}^{p}_{n} \\Delta t\n        $$\n\n3.  **最终处理**：循环完成后（$n=N-1$），$\\mathcal{D}_{\\text{tot}}$ 的累积值即为一个周期内单位体积的总耗散。然后按要求将此最终值四舍五入到最接近的整数。\n\n该算法设计在一个离散时间步框架内直接实现了推导出的物理定律，为解决给定的测试案例提供了一种稳健的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the computation for all test cases.\n    \"\"\"\n\n    # Test Suite Definition\n    test_cases = [\n        # Case A\n        {\n            \"E\": 2.10e11,  # Pa\n            \"g_data\": (\n                np.array([0, 3.0e8, 4.5e8, 6.0e8]),  # sigma (Pa)\n                np.array([0, 0, 5.0e-5, 2.0e-4]),    # edot_p (1/s)\n            ),\n            \"eps0\": 5.0e-3,\n            \"f\": 0.5,      # Hz\n            \"dt\": 1.0e-3,  # s\n        },\n        # Case B\n        {\n            \"E\": 2.10e11,\n            \"g_data\": (\n                np.array([0, 3.0e8, 4.5e8, 6.0e8]),\n                np.array([0, 0, 5.0e-5, 2.0e-4]),\n            ),\n            \"eps0\": 5.0e-4,\n            \"f\": 0.5,\n            \"dt\": 1.0e-3,\n        },\n        # Case C\n        {\n            \"E\": 7.0e10,\n            \"g_data\": (\n                np.array([0, 1.0e8, 2.0e8, 4.0e8]),\n                np.array([0, 0, 1.0e-4, 1.5e-4]),\n            ),\n            \"eps0\": 4.0e-3,\n            \"f\": 1.0,\n            \"dt\": 5.0e-4,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        D_tot = compute_dissipation(\n            E=case[\"E\"],\n            g_data=case[\"g_data\"],\n            eps0=case[\"eps0\"],\n            f=case[\"f\"],\n            dt=case[\"dt\"],\n        )\n        results.append(int(round(D_tot)))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_dissipation(E, g_data, eps0, f, dt):\n    \"\"\"\n    Computes the total dissipation for a single test case using a forward-Euler scheme.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        g_data (tuple): A tuple (sigma_points, edot_p_points) for the surrogate.\n        eps0 (float): Strain amplitude.\n        f (float): Frequency in Hz.\n        dt (float): Time step in s.\n\n    Returns:\n        float: Total dissipation per unit volume in J/m^3.\n    \"\"\"\n    \n    # 1. Setup the data-driven plastic strain rate function g(sigma)\n    sigma_pts, edot_p_pts = g_data\n    max_sigma = sigma_pts[-1]\n    \n    # Calculate slope for linear extrapolation\n    if len(sigma_pts) > 1 and sigma_pts[-1] != sigma_pts[-2]:\n        last_slope = (edot_p_pts[-1] - edot_p_pts[-2]) / (sigma_pts[-1] - sigma_pts[-2])\n    else:\n        last_slope = 0.0\n\n    # Memoization for the recursive g_func\n    memo = {}\n\n    def g_func(s):\n        \"\"\"Calculates plastic strain rate from stress using interpolation,\n           extrapolation, and odd symmetry.\"\"\"\n        if s in memo:\n            return memo[s]\n        \n        if s == 0.:\n            return 0.\n        \n        # Apply odd symmetry using recursion\n        if s  0.:\n            res = -g_func(-s)\n            memo[s] = res\n            return res\n        \n        # Linear extrapolation for sigma > max_sigma\n        if s > max_sigma:\n            res = edot_p_pts[-1] + last_slope * (s - max_sigma)\n            memo[s] = res\n            return res\n            \n        # Linear interpolation for 0  sigma = max_sigma\n        res = np.interp(s, sigma_pts, edot_p_pts)\n        memo[s] = res\n        return res\n\n    # 2. Setup simulation parameters\n    T = 1.0 / f\n    num_steps = int(round(T / dt))\n    time_points = np.linspace(0, T, num_steps + 1)[:-1] # Use num_steps points from 0 to T-dt\n\n    # 3. Initialization of state variables and accumulators\n    ep_n = 0.0  # Plastic strain at step n\n    D_total = 0.0  # Total dissipation\n\n    # 4. Time integration loop\n    for n in range(num_steps):\n        t_n = time_points[n]\n        \n        # a. Update kinematics for current step\n        e_n = eps0 * np.sin(2.0 * np.pi * f * t_n)\n        \n        # b. Compute stress at current step\n        sigma_n = E * (e_n - ep_n)\n        \n        # c. Evaluate plastic strain rate\n        edot_p_n = g_func(sigma_n)\n        \n        # d. Update total dissipation (rectangular quadrature)\n        D_n = sigma_n * edot_p_n\n        D_total += D_n * dt\n        \n        # e. Update plastic strain for next step (Forward Euler)\n        ep_n = ep_n + edot_p_n * dt\n        \n    return D_total\n\nsolve()\n```"
        },
        {
            "introduction": "数据驱动模型在其训练数据域内表现出色，但在外推时可能会出现不可预测的失效。这最后一个实践介绍了一个用于评估此风险的定量框架。通过将输入特征空间中的统计距离度量（马氏距离）与来自集成模型不确定性的度量相结合，您将学习如何识别那些可能不可靠的预测。",
            "id": "3799869",
            "problem": "考虑一个数据驱动的多尺度材料建模场景，其中微观尺度描述符通过一组人工神经网络 (ANN) 映射到宏观尺度响应。令微观尺度特征向量表示为 $\\boldsymbol{\\phi} \\in \\mathbb{R}^{d}$，其包含 $d$ 个无量纲分量（例如，归一化的晶粒尺寸、孔隙率和最大主应变，其中应变为无量纲）。训练特征数据集表示为 $X_{\\text{train}} \\in \\mathbb{R}^{N \\times d}$，其行向量为 $ \\boldsymbol{\\phi}_i^\\top $，$i = 1, \\dots, N$。由 $M$ 个神经代理组成的集成模型产生的预测由 $ \\hat{y}^{(m)} = \\boldsymbol{w}^{(m)\\top} \\boldsymbol{\\phi} $ 给出，$m = 1, \\dots, M$，其中 $ \\boldsymbol{w}^{(m)} \\in \\mathbb{R}^{d} $ 是固定的参数向量，表示每个代理在工作区域附近的线性化局部行为。假设训练特征分布近似为多元正态分布。\n\n您的任务是通过将特征空间中与训练数据的距离标准和基于集成的预测不确定性相结合，来评估指定测试特征的外推风险，同时遵循以下定义和原则：\n\n1. 将特征的训练均值和协方差定义为 $ \\boldsymbol{\\mu} = \\frac{1}{N} \\sum_{i=1}^N \\boldsymbol{\\phi}_i $ 和 $ S = \\frac{1}{N-1} \\sum_{i=1}^N (\\boldsymbol{\\phi}_i - \\boldsymbol{\\mu})(\\boldsymbol{\\phi}_i - \\boldsymbol{\\mu})^\\top $。使用 $S$ 的数值稳定逆矩阵 $ S_\\lambda^{-1} $，其中 $ S_\\lambda = S + \\lambda I_d $，$ \\lambda  0 $ 是一个小的正则化参数，$ I_d $ 是 $d \\times d$ 单位矩阵。\n\n2. 对于测试特征 $ \\boldsymbol{\\phi}_{\\text{test}} $，计算 Mahalanobis 距离的平方 $ D^2 = (\\boldsymbol{\\phi}_{\\text{test}} - \\boldsymbol{\\mu})^\\top S_\\lambda^{-1} (\\boldsymbol{\\phi}_{\\text{test}} - \\boldsymbol{\\mu}) $。在多元正态假设下，统计量 $ D^2 $ 服从自由度为 $ d $ 的 chi-squared 分布。令 $ \\tau_\\chi $ 为 $ \\chi^2_d $ 的 $95\\%$ 上分位数，即 $ \\tau_\\chi = F_{\\chi^2_d}^{-1}(0.95) $。\n\n3. 对于在 $ \\boldsymbol{\\phi}_{\\text{test}} $ 上的集成预测 $ \\{ \\hat{y}^{(m)} \\}_{m=1}^M $，定义集成均值 $ \\bar{y} = \\frac{1}{M} \\sum_{m=1}^M \\hat{y}^{(m)} $ 和集成标准差 $ s = \\sqrt{ \\frac{1}{M-1} \\sum_{m=1}^M \\left( \\hat{y}^{(m)} - \\bar{y} \\right)^2 } $。使用在所有训练特征 $ \\boldsymbol{\\phi}_i $ ($i = 1, \\dots, N$)上计算的集成标准差的经验 $95\\%$ 分位数来校准 $ s $ 的阈值 $ \\tau_s $；也就是说，为每个训练特征计算 $ s_i $，并将 $ \\tau_s $ 设置为集合 $ \\{ s_i \\}_{i=1}^N $ 的经验 $95\\%$ 分位数。\n\n4. 通过 $ R = \\frac{D^2}{\\tau_\\chi} + \\frac{s}{\\tau_s} $ 定义无量纲外推风险指数 $ R $。定义一个布尔外推标志 $ \\mathsf{flag} $，如果 $ D^2  \\tau_\\chi $ 或 $ s  \\tau_s $，则其为 $\\mathsf{True}$，否则为 $\\mathsf{False}$。\n\n仅根据上述定义以及多元正态分布和 chi-squared 分位数的统计特性，实现一个程序，为每个测试案例计算元组 $ [D^2, s, R, \\mathsf{flag}] $。\n\n使用以下具体且科学一致的测试套件。所有特征分量都是无量纲的；不涉及角度。\n\n- 训练特征矩阵 $ X_{\\text{train}} $，$ N = 8 $，$ d = 3 $:\n$$\nX_{\\text{train}} = \\begin{bmatrix}\n0.30  0.08  0.10 \\\\\n0.28  0.09  0.09 \\\\\n0.35  0.07  0.11 \\\\\n0.33  0.10  0.08 \\\\\n0.31  0.06  0.12 \\\\\n0.27  0.11  0.10 \\\\\n0.34  0.05  0.09 \\\\\n0.29  0.12  0.07\n\\end{bmatrix}.\n$$\n\n- 集成大小 $ M = 5 $，参数向量为 $ \\boldsymbol{w}^{(m)} $:\n$$\n\\boldsymbol{w}^{(1)} = \\begin{bmatrix} 300.0 \\\\ -150.0 \\\\ 800.0 \\end{bmatrix}, \\quad\n\\boldsymbol{w}^{(2)} = \\begin{bmatrix} 310.0 \\\\ -140.0 \\\\ 780.0 \\end{bmatrix}, \\quad\n\\boldsymbol{w}^{(3)} = \\begin{bmatrix} 295.0 \\\\ -160.0 \\\\ 820.0 \\end{bmatrix}, \\quad\n\\boldsymbol{w}^{(4)} = \\begin{bmatrix} 305.0 \\\\ -155.0 \\\\ 790.0 \\end{bmatrix}, \\quad\n\\boldsymbol{w}^{(5)} = \\begin{bmatrix} 290.0 \\\\ -150.0 \\\\ 810.0 \\end{bmatrix}.\n$$\n\n这些代理将特征线性映射到单位为兆帕 (MPa) 的宏观尺度响应，但本问题的输出仅为无量纲量和布尔值。\n\n- 正则化参数 $ \\lambda = 10^{-12} $。\n\n- 待评估的三个测试特征 $ \\boldsymbol{\\phi}_{\\text{test}} $:\n$$\n\\boldsymbol{\\phi}_{A} = \\begin{bmatrix} 0.32 \\\\ 0.09 \\\\ 0.10 \\end{bmatrix}, \\quad\n\\boldsymbol{\\phi}_{B} = \\begin{bmatrix} 0.40 \\\\ 0.15 \\\\ 0.12 \\end{bmatrix}, \\quad\n\\boldsymbol{\\phi}_{C} = \\begin{bmatrix} 0.28 \\\\ 0.07 \\\\ 0.25 \\end{bmatrix}.\n$$\n\n测试套件的解释指南：\n- 案例 $A$ 是一个典型的分布内场景。\n- 案例 $B$ 探讨了特征值接近训练分布边缘的边界条件。\n- 案例 $C$ 代表了一个高应变场景，其应变分量要大得多。\n\n您的程序必须为这三个案例中的每一个计算 $ D^2 $、$ s $、$ R $ 和 $ \\mathsf{flag} $，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个案例按 $ [D^2, s, R, \\mathsf{flag}] $ 的顺序列出。例如，最终输出格式应为\n$[ [D^2_A, s_A, R_A, \\mathsf{flag}_A], [D^2_B, s_B, R_B, \\mathsf{flag}_B], [D^2_C, s_C, R_C, \\mathsf{flag}_C] ]$，\n其中每个 $ D^2_* $、$ s_* $ 和 $ R_* $ 是实数，每个 $ \\mathsf{flag}_* $ 是布尔值。",
            "solution": "该问题是有效的，因为它具有科学依据、定义明确且客观。提供了解出唯一解所需的所有数据和定义，并且该方法符合数据驱动建模和不确定性量化的标准实践。我们现在将进行完整、合理的求解。\n\n目标是为三个给定的测试特征向量计算外推风险指数 $R$ 和相应的布尔标志 $\\mathsf{flag}$。这涉及评估一个测试点与训练数据分布的比较情况，既包括在特征空间中的比较，也包括来自集成模型的预测不确定性方面的比较。\n\n指定的量如下：\n- 训练特征矩阵 $X_{\\text{train}} \\in \\mathbb{R}^{N \\times d}$，$N=8$，$d=3$:\n$$\nX_{\\text{train}} = \\begin{bmatrix}\n0.30  0.08  0.10 \\\\\n0.28  0.09  0.09 \\\\\n0.35  0.07  0.11 \\\\\n0.33  0.10  0.08 \\\\\n0.31  0.06  0.12 \\\\\n0.27  0.11  0.10 \\\\\n0.34  0.05  0.09 \\\\\n0.29  0.12  0.07\n\\end{bmatrix}\n$$\n- 由 $M=5$ 个线性模型组成的集成，其权重向量为 $\\boldsymbol{w}^{(m)} \\in \\mathbb{R}^3$，$m=1, \\dots, 5$。我们可以将它们组合成一个权重矩阵 $W \\in \\mathbb{R}^{d \\times M}$：\n$$\nW = \\begin{bmatrix}\n300.0  310.0  295.0  305.0  290.0 \\\\\n-150.0  -140.0  -160.0  -155.0  -150.0 \\\\\n800.0  780.0  820.0  790.0  810.0\n\\end{bmatrix}\n$$\n- 正则化参数 $\\lambda = 10^{-12}$。\n- 三个测试特征向量：\n$$\n\\boldsymbol{\\phi}_{A} = \\begin{bmatrix} 0.32 \\\\ 0.09 \\\\ 0.10 \\end{bmatrix}, \\quad\n\\boldsymbol{\\phi}_{B} = \\begin{bmatrix} 0.40 \\\\ 0.15 \\\\ 0.12 \\end{bmatrix}, \\quad\n\\boldsymbol{\\phi}_{C} = \\begin{bmatrix} 0.28 \\\\ 0.07 \\\\ 0.25 \\end{bmatrix}.\n$$\n\n计算过程分为四个主要步骤：\n1.  计算训练数据分布的统计特性。\n2.  建立用于离群点检测的统计阈值。\n3.  根据这些阈值评估每个测试特征向量。\n4.  计算每个测试案例的最终风险指数和标志。\n\n**步骤 1：计算训练数据统计量**\n\n首先，我们计算训练特征 $X_{\\text{train}}$ 的均值向量 $\\boldsymbol{\\mu}$ 和样本协方差矩阵 $S$。\n均值向量 $\\boldsymbol{\\mu} = \\frac{1}{N} \\sum_{i=1}^N \\boldsymbol{\\phi}_i$ 计算如下：\n$$ \\boldsymbol{\\mu} = \\frac{1}{8} \\sum_{i=1}^8 \\boldsymbol{\\phi}_i = \\begin{bmatrix} 0.30875 \\\\ 0.085 \\\\ 0.095 \\end{bmatrix} $$\n样本协方差矩阵 $S = \\frac{1}{N-1} \\sum_{i=1}^N (\\boldsymbol{\\phi}_i - \\boldsymbol{\\mu})(\\boldsymbol{\\phi}_i - \\boldsymbol{\\mu})^\\top$ 捕捉了特征的分布和相关性。当 $N=8$ 时，分母为 $N-1=7$。计算得出：\n$$ S \\approx \\begin{bmatrix}\n8.125 \\times 10^{-4}  -1.250 \\times 10^{-4}  -4.625 \\times 10^{-4} \\\\\n-1.250 \\times 10^{-4}  5.714 \\times 10^{-4}  -4.214 \\times 10^{-4} \\\\\n-4.625 \\times 10^{-4}  -4.214 \\times 10^{-4}  2.571 \\times 10^{-4}\n\\end{bmatrix} $$\n为确保求逆过程中的数值稳定性，我们添加一个小的正则化项，形成 $S_\\lambda = S + \\lambda I_d$，其中 $\\lambda=10^{-12}$，$I_d$ 是 $3 \\times 3$ 单位矩阵。然后我们计算其逆矩阵 $S_\\lambda^{-1}$。由于 $\\lambda$ 的值很小，$S_\\lambda^{-1} \\approx S^{-1}$。\n\n**步骤 2：建立统计阈值**\n\n我们定义两个阈值 $\\tau_\\chi$ 和 $\\tau_s$，作为分布内行为的边界。\n\n第一个阈值 $\\tau_\\chi$ 适用于 Mahalanobis 距离的平方 $D^2$。在训练数据服从多元正态分布的假设下，从该分布中抽取的点的 $D^2$ 服从自由度为 $d$ 的 chi-squared ($\\chi^2$) 分布。我们将 $\\tau_\\chi$ 设置为 $\\chi^2_d$ 分布的 $95\\%$ 上分位数。当维度 $d=3$ 时，其值为：\n$$ \\tau_\\chi = F_{\\chi^2_3}^{-1}(0.95) \\approx 7.8147 $$\n一个测试点如果其 $D^2  \\tau_\\chi$，则在特征空间中被视为离群点，观测到其与训练分布中心的距离如此之大的概率小于 $5\\%$。\n\n第二个阈值 $\\tau_s$ 适用于集成的预测不确定性，该不确定性由预测值 $\\{ \\hat{y}^{(m)} \\}$ 的标准差 $s$ 来量化。我们根据训练数据本身凭经验确定 $\\tau_s$。\n首先，我们计算 $M=5$ 个模型对 $N=8$ 个训练点中每一个的预测值：$Y_{\\text{train}} = X_{\\text{train}} W^\\top$。然后，对于每个训练点 $\\boldsymbol{\\phi}_i$，我们计算其五个预测值的样本标准差：$s_i = \\sqrt{\\frac{1}{M-1} \\sum_{m=1}^M (\\hat{y}_i^{(m)} - \\bar{y}_i)^2}$。这将得到一组包含 $N=8$ 个标准差值的集合 $\\{s_1, \\dots, s_8\\}$。阈值 $\\tau_s$ 定义为该集合的经验 $95\\%$ 分位数。通过计算可得：\n$$ \\tau_s = \\text{quantile}(\\{s_1, \\dots, s_8\\}, 0.95) \\approx 8.4337 $$\n如果一个测试点产生的集成标准差 $s  \\tau_s$，这表明模型之间的分歧程度超过了它们在 $95\\%$ 的训练数据上的分歧，暗示可能存在外推。\n\n**步骤 3  4：评估测试案例并计算风险**\n\n对于每个测试特征 $\\boldsymbol{\\phi}_{\\text{test}}$，我们计算所需的度量指标。\n\n**案例 A: $\\boldsymbol{\\phi}_{A} = [0.32, 0.09, 0.10]^\\top$**\n该点位于训练数据的均值附近。\n- **Mahalanobis 距离 $D^2$**: $D^2_A = (\\boldsymbol{\\phi}_A - \\boldsymbol{\\mu})^\\top S_\\lambda^{-1} (\\boldsymbol{\\phi}_A - \\boldsymbol{\\mu}) \\approx 0.5517$。由于 $0.5517  \\tau_\\chi \\approx 7.8147$，该点在特征空间中不是离群点。\n- **集成标准差 $s$**: 首先，我们计算预测值 $\\hat{\\mathbf{y}}_A = W^\\top \\boldsymbol{\\phi}_A$。然后我们计算它们的标准差：$s_A \\approx 5.6480$。由于 $5.6480  \\tau_s \\approx 8.4337$，模型集成表现出较低的分歧。\n- **外推标志 $\\mathsf{flag}$**: 由于 $D_A^2  \\tau_\\chi$ 和 $s_A  \\tau_s$ 均不为真，$\\mathsf{flag}_A = \\mathsf{False}$。\n- **风险指数 $R$**: $R_A = \\frac{D_A^2}{\\tau_\\chi} + \\frac{s_A}{\\tau_s} \\approx \\frac{0.5517}{7.8147} + \\frac{5.6480}{8.4337} \\approx 0.0706 + 0.6697 \\approx 0.7403$。\n\n**案例 B: $\\boldsymbol{\\phi}_{B} = [0.40, 0.15, 0.12]^\\top$**\n该点的特征值大于大多数训练点。\n- **Mahalanobis 距离 $D^2$**: $D^2_B = (\\boldsymbol{\\phi}_B - \\boldsymbol{\\mu})^\\top S_\\lambda^{-1} (\\boldsymbol{\\phi}_B - \\boldsymbol{\\mu}) \\approx 15.1554$。由于 $15.1554  \\tau_\\chi \\approx 7.8147$，该点是一个明显的离群点。\n- **集成标准差 $s$**: $s_B \\approx 6.4382$。由于 $6.4382  \\tau_s \\approx 8.4337$，根据我们的标准，该集成的分歧不被认为是过度的。\n- **外推标志 $\\mathsf{flag}$**: 由于 $D_B^2  \\tau_\\chi$，满足外推条件，因此 $\\mathsf{flag}_B = \\mathsf{True}$。\n- **风险指数 $R$**: $R_B = \\frac{D_B^2}{\\tau_\\chi} + \\frac{s_B}{\\tau_s} \\approx \\frac{15.1554}{7.8147} + \\frac{6.4382}{8.4337} \\approx 1.9393 + 0.7634 \\approx 2.7027$。\n\n**案例 C: $\\boldsymbol{\\phi}_{C} = [0.28, 0.07, 0.25]^\\top$**\n该点的第三个特征分量远大于训练集中的任何值。\n- **Mahalanobis 距离 $D^2$**: $D^2_C = (\\boldsymbol{\\phi}_C - \\boldsymbol{\\mu})^\\top S_\\lambda^{-1} (\\boldsymbol{\\phi}_C - \\boldsymbol{\\mu}) \\approx 79.2272$。该值远大于 $\\tau_\\chi \\approx 7.8147$，表明在特征空间中存在极端外推。\n- **集成标准差 $s$**: $s_C \\approx 17.7623$。这个值也远大于阈值 $\\tau_s \\approx 8.4337$，表明模型存在高度分歧。\n- **外推标志 $\\mathsf{flag}$**: 由于 $D_C^2  \\tau_\\chi$ 和 $s_C  \\tau_s$ 均成立，所以标志为 $\\mathsf{flag}_C = \\mathsf{True}$。\n- **风险指数 $R$**: $R_C = \\frac{D_C^2}{\\tau_\\chi} + \\fracs_C}{\\tau_s} \\approx \\frac{79.2272}{7.8147} + \\frac{17.7623}{8.4337} \\approx 10.1382 + 2.1060 \\approx 12.2442$。\n\n**结果摘要**\n为每个案例计算出的元组 $[D^2, s, R, \\mathsf{flag}]$ 如下：\n- 案例 A: $[\\approx 0.5517, \\approx 5.6480, \\approx 0.7403, \\mathsf{False}]$\n- 案例 B: $[\\approx 15.1554, \\approx 6.4382, \\approx 2.7027, \\mathsf{True}]$\n- 案例 C: $[\\approx 79.2272, \\approx 17.7623, \\approx 12.2442, \\mathsf{True}]$\n这些数值结果将由以下程序生成。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here-\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Computes an extrapolation risk index and flag for a series of test cases based on\n    Mahalanobis distance to training data and predictive uncertainty from an ensemble of models.\n    \"\"\"\n    \n    # Define the training feature matrix from the problem statement.\n    X_train = np.array([\n        [0.30, 0.08, 0.10],\n        [0.28, 0.09, 0.09],\n        [0.35, 0.07, 0.11],\n        [0.33, 0.10, 0.08],\n        [0.31, 0.06, 0.12],\n        [0.27, 0.11, 0.10],\n        [0.34, 0.05, 0.09],\n        [0.29, 0.12, 0.07]\n    ])\n\n    # Define the ensemble parameter vectors and assemble them into a weight matrix W.\n    w1 = np.array([300.0, -150.0, 800.0])\n    w2 = np.array([310.0, -140.0, 780.0])\n    w3 = np.array([295.0, -160.0, 820.0])\n    w4 = np.array([305.0, -155.0, 790.0])\n    w5 = np.array([290.0, -150.0, 810.0])\n    # W has shape (d, M) where d=3, M=5\n    W = np.stack([w1, w2, w3, w4, w5], axis=1)\n\n    # Define constants and test cases from the problem statement.\n    lambda_reg = 1e-12\n    N, d = X_train.shape\n    \n    phi_A = np.array([0.32, 0.09, 0.10])\n    phi_B = np.array([0.40, 0.15, 0.12])\n    phi_C = np.array([0.28, 0.07, 0.25])\n    test_cases = [phi_A, phi_B, phi_C]\n\n    # Step 1: Compute training data statistics (mean, covariance, and regularized inverse).\n    mu = np.mean(X_train, axis=0)\n    # Use ddof=1 for the unbiased sample covariance matrix (denominator N-1).\n    S = np.cov(X_train, rowvar=False, ddof=1)\n    S_lambda = S + lambda_reg * np.identity(d)\n    S_lambda_inv = np.linalg.inv(S_lambda)\n\n    # Step 2: Establish statistical thresholds tau_chi and tau_s.\n    \n    # tau_chi: 95% upper quantile of the chi-squared distribution with d degrees of freedom.\n    tau_chi = chi2.ppf(0.95, df=d)\n\n    # tau_s: Empirical 95% quantile of ensemble standard deviations over training data.\n    # Ensemble predictions on training data, Y_train has shape (N, M).\n    Y_train = X_train @ W\n    # Ensemble std dev for each training point, using ddof=1 for sample std dev.\n    s_train = np.std(Y_train, axis=1, ddof=1)\n    tau_s = np.quantile(s_train, 0.95)\n    \n    # Step 3  4: Process each test case.\n    results = []\n    for phi_test in test_cases:\n        # Compute squared Mahalanobis distance D^2.\n        delta = phi_test - mu\n        D2 = delta.T @ S_lambda_inv @ delta\n\n        # Compute ensemble standard deviation s.\n        y_test_predictions = phi_test @ W # Shape (M,) vector of predictions.\n        s = np.std(y_test_predictions, ddof=1)\n\n        # Compute extrapolation flag.\n        flag = (D2 > tau_chi) or (s > tau_s)\n\n        # Compute risk index R.\n        R = D2 / tau_chi + s / tau_s\n\n        results.append([D2, s, R, bool(flag)])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) method correctly formats a list of lists into the target string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}