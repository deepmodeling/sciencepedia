{
    "hands_on_practices": [
        {
            "introduction": "Machine Learning Interatomic Potentials (MLPs) begin by transforming the complex 3D arrangement of atoms around a central atom into a fixed-length feature vector, or descriptor. These descriptors must adhere to fundamental physical symmetries, being invariant to translation, rotation, and the permutation of identical atoms. This exercise provides direct practice in calculating the value of a Behler-Parrinello radial symmetry function for a simple cubic lattice, bridging the gap between the abstract mathematical definition and a concrete atomic structure .",
            "id": "90953",
            "problem": "In the field of machine learning interatomic potentials, Behler-Parrinello symmetry functions are a cornerstone for creating robust and accurate models of atomic interactions. These functions describe the local chemical environment of an atom in a way that is invariant to rotation, translation, and permutation of like atoms.\n\nA common type of radial symmetry function, denoted as $G^i(\\eta, R_s)$, quantifies the radial distribution of neighboring atoms $j$ around a central atom $i$. It is defined as:\n$$\nG^i(\\eta, R_s) = \\sum_{j \\neq i} e^{-\\eta (R_{ij} - R_s)^2} f_c(R_{ij})\n$$\nHere, $R_{ij}$ is the distance between atoms $i$ and $j$. The parameter $\\eta$ controls the width of the Gaussian functions, and $R_s$ defines the radial distance at which the Gaussian is centered. The sum runs over all neighbors $j$ within a cutoff radius $R_c$. This cutoff is enforced by the cutoff function $f_c(R_{ij})$, which smoothly brings the contribution of each neighbor to zero as its distance approaches $R_c$. A frequently used form for $f_c(R_{ij})$ is the cosine cutoff function:\n$$\nf_c(R_{ij}) = \\begin{cases}\n\\frac{1}{2} \\left( \\cos\\left(\\frac{\\pi R_{ij}}{R_c}\\right) + 1 \\right) & \\text{if } R_{ij} \\le R_c \\\\\n0 & \\text{if } R_{ij} > R_c\n\\end{cases}\n$$\n\nConsider a single atom of an element arranged in an ideal simple cubic (SC) crystal lattice with a lattice constant $a$. For the atom located at the origin of this lattice, derive an analytical expression for the value of the radial symmetry function $G^i(\\eta, R_s)$. Use a cutoff radius of $R_c = \\frac{7}{4}a$. Your final expression should be in terms of the lattice constant $a$ and the symmetry function parameters $\\eta$ and $R_s$.",
            "solution": "1. The radial symmetry function is defined by  \n$$\nG^i(\\eta,R_s)=\\sum_{j\\neq i}e^{-\\eta\\bigl(R_{ij}-R_s\\bigr)^2}f_c(R_{ij})\\,,\n$$\nwith the cosine cutoff  \n$$\nf_c(R)=\\begin{cases}\n\\frac12\\bigl(\\cos(\\pi R/R_c)+1\\bigr)&R\\le R_c,\\\\\n0&R>R_c.\n\\end{cases}\n$$\n\n2. In a simple cubic lattice of constant $a$, atom $i$ at the origin has neighbors at positions $(n_x,n_y,n_z)a$, $n_x,n_y,n_z\\in\\mathbb Z\\setminus\\{0\\}$. Their distances are  \n$$\nR_{n_x,n_y,n_z}=a\\sqrt{n_x^2+n_y^2+n_z^2}\\,.\n$$\n\n3. With cutoff $R_c=\\tfrac74a$, only shells with $n_x^2+n_y^2+n_z^2\\le3$ contribute:\n- $n^2=1$: 6 atoms at $R=a$,\n- $n^2=2$: 12 atoms at $R=a\\sqrt2$,\n- $n^2=3$: 8 atoms at $R=a\\sqrt3$.\n\n4. Thus\n$$\nG^i=\\;6\\,e^{-\\eta(a-R_s)^2}f_c(a)\n\\;+\\;12\\,e^{-\\eta(a\\sqrt2-R_s)^2}f_c(a\\sqrt2)\n\\;+\\;8\\,e^{-\\eta(a\\sqrt3-R_s)^2}f_c(a\\sqrt3).\n$$\n\n5. Compute the cutoff factors, e.g.  \n$$\nf_c(a)=\\tfrac12\\bigl(\\cos(\\tfrac{\\pi a}{R_c})+1\\bigr)\n=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi}{7})+1\\bigr),\n$$\nand similarly\n$$\nf_c(a\\sqrt2)=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi\\sqrt2}{7})+1\\bigr),\\quad\nf_c(a\\sqrt3)=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi\\sqrt3}{7})+1\\bigr).\n$$\n\n6. Substituting and combining factors of $\\tfrac12$ gives  \n$$\nG^i\n=3\\,e^{-\\eta(a-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi}{7})+1\\bigr)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi\\sqrt2}{7})+1\\bigr)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi\\sqrt3}{7})+1\\bigr).\n$$",
            "answer": "$$\\boxed{3\\,e^{-\\eta(a-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi}{7}+1\\bigr)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi\\sqrt2}{7}+1\\bigr)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi\\sqrt3}{7}+1\\bigr)}$$"
        },
        {
            "introduction": "A cornerstone of quantum and classical mechanics is that identical particles are indistinguishable. Any valid physical model, including an MLP, must respect this principle, known as permutation invariance, meaning the system's total energy cannot change if we merely swap the labels of two identical atoms. This practice vividly demonstrates the unphysical consequences, such as artificial energy splitting, that arise when a model violates this symmetry by using parameters that depend on an atom's index rather than its environment . By quantifying the errors of a deliberately flawed model, you will gain a concrete appreciation for why enforcing permutation invariance is non-negotiable for building reliable potentials.",
            "id": "3886545",
            "problem": "You are asked to formalize and quantify the consequences of violating permutation invariance among identical atoms in Machine Learning (ML) interatomic potentials within computational catalysis and chemical engineering. The goal is to construct a scenario in which index-dependent features cause artificial energy splitting and to quantify the resulting prediction errors against a physically grounded reference. Start from a physically motivated, permutation-invariant reference energy and use it to analyze a deliberately permutation-variant surrogate model. Your program must produce a single line containing the aggregated numerical results for a test suite of configurations in dimensionless reduced units, rounded to eight decimal places.\n\nFundamental base:\n- Identical atoms are indistinguishable in classical mechanics and quantum mechanics; the total energy must be invariant under any permutation of atom labels. Formally, if there are $N$ identical atoms and a configuration is described by the set of pairwise distances $\\{r_{ij}\\}$, any permutation $\\pi$ in the symmetric group $S_N$ of indices must satisfy $E(\\{r_{ij}\\}) = E(\\{r_{\\pi(i)\\pi(j)}\\})$.\n- A standard, well-tested pairwise energy function for nonbonded interactions is the Lennard-Jones (LJ) potential. In reduced units where the characteristic energy and length scales are set to unity, the total energy for a configuration is computed as\n$$\nE_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i < j \\leq N} 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^6\\right],\n$$\nwith $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$, $\\varepsilon$ and $\\sigma$ the energy and length scales, and where the sum over unordered pairs ensures permutation invariance. Use reduced units with $\\varepsilon = 1$ and $\\sigma = 1$, so that energies and distances are dimensionless.\n\nIndex-dependent surrogate model:\n- Define per-atom descriptors that depend on local distances,\n$$\nd_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\exp\\left(-\\frac{r_{ij}}{\\sigma}\\right), \\quad e_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\frac{r_{ij}}{\\sigma}.\n$$\n- Construct a deliberately permutation-variant surrogate energy by using index-dependent weights,\n$$\nE_{\\text{bad}}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_i \\, d_i + b_i \\, e_i\\right],\n$$\nwhere $\\mathbf{a} = (a_1, \\dots, a_N)$ and $\\mathbf{b} = (b_1, \\dots, b_N)$ depend on the atom index. Under a permutation $\\pi \\in S_N$ of labels, the predicted energy becomes\n$$\nE_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right],\n$$\nwhich can differ for identical atoms if the $d_i$ and $e_i$ are not all equal.\n- For comparison, construct a permutation-invariant surrogate with shared weights,\n$$\nE_{\\text{good}}(\\mathbf{R}; a, b) = \\sum_{i=1}^{N} \\left[a \\, d_i + b \\, e_i\\right].\n$$\n\nQuantities to compute per test case:\n- Artificial energy splitting magnitude across a set of label permutations $\\mathcal{P}$,\n$$\n\\Delta_{\\text{split}} = \\max_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - \\min_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}).\n$$\n- Maximum absolute prediction error of the index-dependent model across $\\mathcal{P}$, relative to the LJ energy,\n$$\n\\text{Err}_{\\text{bad,max}} = \\max_{\\pi \\in \\mathcal{P}} \\left|E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n- Absolute prediction error of the permutation-invariant surrogate (shared weights),\n$$\n\\text{Err}_{\\text{good}} = \\left|E_{\\text{good}}(\\mathbf{R}; a, b) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n\nAngle units are irrelevant because only distances are used. All energies and distances must be expressed in dimensionless reduced units with $\\varepsilon = 1$ and $\\sigma = 1$. Round all outputs to eight decimal places.\n\nTest suite:\n- Use the following four configuration cases. Coordinates are given as Cartesian positions in $3$-dimensional space, in reduced units. Use $\\varepsilon = 1$ and $\\sigma = 1$. For each case, apply the set of permutations $\\mathcal{P}$ consisting of the identity and the reverse-index permutation. Shared weights are $a = 0.9$, $b = -0.15$.\n\nCase $1$ (non-symmetric linear triatomic, happy path):\n- $N = 3$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.2, 0.0, 0.0\\right)$, $\\left(2.5, 0.0, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$.\n\nCase $2$ (equilateral triangle, symmetry boundary condition):\n- $N = 3$,\n- side length: $L = 1.6$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(L, 0.0, 0.0\\right)$, $\\left(\\frac{L}{2}, \\frac{\\sqrt{3}}{2} L, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$.\n\nCase $3$ (diatomic pair, edge case):\n- $N = 2$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.1, 0.0, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (1.2, 0.7)$, $\\mathbf{b} = (-0.25, 0.05)$.\n\nCase $4$ (four atoms in a non-symmetric rectangular layout):\n- $N = 4$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.4, 0.0, 0.0\\right)$, $\\left(0.0, 2.2, 0.0\\right)$, $\\left(2.1, 2.3, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (0.7, 1.1, 0.6, 1.5)$, $\\mathbf{b} = (-0.2, 0.25, -0.05, 0.3)$.\n\nRequired final output format:\n- For each case, compute the triple $\\left[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}\\right]$ as floats. Your program should produce a single line of output containing the list of these per-case triples, rounded to eight decimal places, as a comma-separated list of Python-style lists enclosed in square brackets, for example, $\\left[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots\\right]$.",
            "solution": "The user-provided problem is assessed as **valid**. It is scientifically grounded, well-posed, and objective. The problem statement provides a clear, self-contained set of definitions, data, and constraints that permit a unique and meaningful solution. It establishes a pedagogically valuable exercise in computational chemistry by formalizing the consequences of violating a fundamental physical principle—permutation invariance—in the context of machine learning interatomic potentials. All required data for the four test cases are provided, and the quantities to be computed are mathematically unambiguous.\n\nProceeding with the solution, the core of the problem is to quantify the errors introduced by a machine learning model that fails to respect the physical indistinguishability of identical atoms. This principle, permutation invariance, dictates that the total energy of a system of $N$ identical atoms must remain unchanged regardless of how we label them. Mathematically, for any permutation $\\pi$ of the atom indices $\\{1, \\dots, N\\}$, the energy function $E$ must satisfy $E(\\{\\mathbf{r}_i\\}) = E(\\{\\mathbf{r}_{\\pi(i)}\\})$.\n\nThe solution is structured as follows:\n1.  A reference, physically correct energy is calculated using the Lennard-Jones (LJ) potential. This serves as the \"ground truth.\" In the specified reduced units where the characteristic energy $\\varepsilon=1$ and length $\\sigma=1$, the LJ potential is:\n    $$E_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i < j \\leq N} 4 \\left(r_{ij}^{-12} - r_{ij}^{-6}\\right)$$\n    where $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ is the distance between atoms $i$ and $j$. This formulation, summing over unique pairs, is inherently permutation-invariant.\n\n2.  Two surrogate models are constructed based on local atomic environment descriptors. For each atom $i$, we define descriptors $d_i$ and $e_i$ that summarize its neighborhood:\n    $$d_i = \\sum_{j \\neq i} \\exp(-r_{ij})$$\n    $$e_i = \\sum_{j \\neq i} r_{ij}$$\n    These descriptors are themselves permutation-invariant in the sense that they are a property of the local geometry around a point in space, regardless of the label assigned to the atom at that point.\n\n3.  The first surrogate model, $E_{\\text{good}}$, is constructed to be permutation-invariant by assigning the same weights, $a$ and $b$, to the descriptors of every atom:\n    $$E_{\\text{good}}(\\mathbf{R}; a, b) = \\sum_{i=1}^{N} \\left(a \\, d_i + b \\, e_i\\right)$$\n    Under a permutation of atom labels, the set of descriptor values $\\{d_i, e_i\\}$ is merely reordered, but their sum over all atoms remains constant, ensuring $E_{\\text{good}}$ is invariant.\n\n4.  The second surrogate model, $E_{\\text{bad}}$, is deliberately constructed to violate permutation invariance by assigning index-dependent weights, $a_i$ and $b_i$:\n    $$E_{\\text{bad}}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left(a_i \\, d_i + b_i \\, e_i\\right)$$\n    If we permute the atom labels according to a permutation $\\pi$, atom $i$ (with its fixed descriptors $d_i, e_i$) is now assigned the label $\\pi(i)$ and thus receives weights $a_{\\pi(i)}$ and $b_{\\pi(i)}$. The energy under this new labeling, as defined in the problem, is:\n    $$E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left(a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right)$$\n    If the atomic environments (and thus descriptors $d_i, e_i$) are not all identical, this energy will in general depend on the permutation $\\pi$, which is unphysical.\n\nThe algorithmic procedure for each test case is as follows:\nFirst, the $N \\times N$ matrix of pairwise distances $r_{ij}$ is computed from the given atomic coordinates. Using these distances, the reference energy $E_{\\text{LJ}}$ is calculated. Then, the descriptor vectors $\\mathbf{d}=(d_1, \\dots, d_N)$ and $\\mathbf{e}=(e_1, \\dots, e_N)$ are computed.\n\nTo quantify the violation, we consider two permutations: the identity ($\\pi_{id}(i) = i$) and the reverse-index permutation ($\\pi_{rev}(i) = N-1-i$ for $0$-based indices). The two corresponding energies, $E_{\\text{bad}}^{(\\pi_{id})}$ and $E_{\\text{bad}}^{(\\pi_{rev})}$, are calculated.\n\nFrom these values, we compute the required metrics:\n-   The artificial energy splitting, $\\Delta_{\\text{split}} = |E_{\\text{bad}}^{(\\pi_{id})} - E_{\\text{bad}}^{(\\pi_{rev})}|$. This directly measures the magnitude of the invariance violation. In symmetric configurations (e.g., a diatomic molecule or an equilateral trimer), the descriptors $\\{d_i, e_i\\}$ are identical for all atoms, causing $\\Delta_{\\text{split}}$ to be zero, as expected.\n-   The maximum absolute prediction error of the bad model, $\\text{Err}_{\\text{bad,max}} = \\max(|E_{\\text{bad}}^{(\\pi_{id})} - E_{\\text{LJ}}|, |E_{\\text{bad}}^{(\\pi_{rev})} - E_{\\text{LJ}}|)$. This reflects the worst-case error of the flawed model for the given labelings.\n-   The absolute prediction error of the good model, $\\text{Err}_{\\text{good}} = |E_{\\text{good}}(\\mathbf{R}; a, b) - E_{\\text{LJ}}|$. This isolates the model's intrinsic representational error from the error caused by broken symmetry.\n\nBy computing the triplet $[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}]$ for each case, we systematically analyze and quantify the consequences of violating a core physical principle in a computational model.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes metrics for permutation variance in ML interatomic potentials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {   # Case 1\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.2, 0.0, 0.0], \n                [2.5, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 2\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.6, 0.0, 0.0], \n                [1.6/2, np.sqrt(3)/2 * 1.6, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 3\n            \"N\": 2,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.1, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([1.2, 0.7]),\n            \"b_bad\": np.array([-0.25, 0.05]),\n        },\n        {   # Case 4\n            \"N\": 4,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.4, 0.0, 0.0], \n                [0.0, 2.2, 0.0], \n                [2.1, 2.3, 0.0]\n            ]),\n            \"a_bad\": np.array([0.7, 1.1, 0.6, 1.5]),\n            \"b_bad\": np.array([-0.2, 0.25, -0.05, 0.3]),\n        },\n    ]\n\n    # Shared parameters\n    a_good = 0.9\n    b_good = -0.15\n    epsilon = 1.0\n    sigma = 1.0\n    \n    final_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        positions = case[\"positions\"]\n        a_bad = case[\"a_bad\"]\n        b_bad = case[\"b_bad\"]\n\n        # 1. Calculate the-distance matrix\n        dist_matrix = np.zeros((N, N))\n        if N > 1:\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    dist_matrix[i, j] = dist\n                    dist_matrix[j, i] = dist\n\n        # 2. Calculate Lennard-Jones reference energy (E_LJ)\n        e_lj = 0.0\n        if N > 1:\n            # np.triu_indices gives upper triangle indices to sum over pairs once\n            i_upper, j_upper = np.triu_indices(N, k=1)\n            r_ij = dist_matrix[i_upper, j_upper]\n            \n            # Filter out zero distances to prevent division by zero\n            r_ij_nonzero = r_ij[r_ij > 0]\n            if r_ij_nonzero.size > 0:\n                inv_r6 = (sigma / r_ij_nonzero)**6\n                inv_r12 = inv_r6**2\n                e_lj = np.sum(4 * epsilon * (inv_r12 - inv_r6))\n\n        # 3. Calculate per-atom descriptors\n        d = np.zeros(N)\n        e = np.zeros(N)\n        if N > 1:\n            for i in range(N):\n                # Distances from atom i to all other atoms j\n                r_i_others = dist_matrix[i, np.arange(N) != i]\n                d[i] = np.sum(np.exp(-r_i_others / sigma))\n                e[i] = np.sum(r_i_others / sigma)\n\n        # 4. Calculate E_bad for identity and reverse permutations\n        # Identity permutation\n        e_bad_id = np.sum(a_bad * d + b_bad * e)\n\n        # Reverse-index permutation\n        pi_rev_indices = np.arange(N - 1, -1, -1)\n        a_bad_rev = a_bad[pi_rev_indices]\n        b_bad_rev = b_bad[pi_rev_indices]\n        e_bad_rev = np.sum(a_bad_rev * d + b_bad_rev * e)\n        \n        e_bad_energies = np.array([e_bad_id, e_bad_rev])\n\n        # 5. Calculate artificial energy splitting (Delta_split)\n        delta_split = np.max(e_bad_energies) - np.min(e_bad_energies)\n\n        # 6. Calculate maximum absolute prediction error for E_bad\n        err_bad_max = np.max(np.abs(e_bad_energies - e_lj))\n\n        # 7. Calculate error for the permutation-invariant model (E_good)\n        e_good = a_good * np.sum(d) + b_good * np.sum(e)\n        err_good = np.abs(e_good - e_lj)\n\n        final_results.append([delta_split, err_bad_max, err_good])\n\n    # Format the final output string as specified\n    result_strings = []\n    for res in final_results:\n        # Create string for each sublist, e.g., \"[val1,val2,val3]\"\n        sublist_str = f\"[{res[0]:.8f},{res[1]:.8f},{res[2]:.8f}]\"\n        result_strings.append(sublist_str)\n    \n    # Join sublist strings and wrap in the final brackets\n    final_output_str = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "For computational tractability, MLPs are designed as local models, considering interactions only within a finite cutoff radius, $R_c$. However, the manner in which interactions are terminated at this boundary is critical for simulating system dynamics. This numerical experiment explores how an abrupt, or \"hard,\" cutoff introduces discontinuities in the forces, leading to violations of energy conservation during a Molecular Dynamics (MD) simulation . By comparing the significant energy drift from a hard cutoff to the stability provided by a smooth switching function, this exercise highlights an essential practical aspect of preparing an MLP for reliable and physically meaningful dynamic simulations.",
            "id": "3886593",
            "problem": "Construct a numerical experiment in the context of Machine Learning (ML) interatomic potentials for Computational Catalysis and Chemical Engineering to illustrate how neighbor cutoff boundaries introduce non-physical discontinuities in forces and energy drift during Molecular Dynamics (MD). Use a minimal conservative pair interaction as the base, with forces derived from a potential via Newton’s Second Law and the definition of conservative forces. The fundamental base is: Newton’s Second Law $m \\,\\mathrm{d}^2 \\mathbf{r}/\\mathrm{d}t^2 = \\mathbf{F}$, conservative force $\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$, total energy $E(t) = K(t) + V(t)$, and Velocity Verlet integration. The pair interaction is the Lennard–Jones energy $V_{\\mathrm{LJ}}(r)$ expressed in reduced Lennard–Jones units where $m=\\epsilon=\\sigma=1$ are dimensionless base units, with\n$$\nV_{\\mathrm{LJ}}(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],\n$$\nand the corresponding radial force magnitude\n$$\nF_{\\mathrm{LJ}}(r) = -\\frac{\\mathrm{d}V_{\\mathrm{LJ}}}{\\mathrm{d}r} = \\frac{24\\epsilon}{r}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right].\n$$\nYou will simulate two atoms interacting via $V_{\\mathrm{LJ}}(r)$ under three neighbor cutoff treatments that emulate how MLP local descriptors exclude distant neighbors:\n\n- Hard truncation: $V(r) = V_{\\mathrm{LJ}}(r)$ for $r < r_c$ and $V(r) = 0$ for $r \\ge r_c$, with $F(r)$ inside given by $F_{\\mathrm{LJ}}(r)$ and $F(r)=0$ outside.\n- Energy shift at the cutoff: $V(r) = V_{\\mathrm{LJ}}(r) - V_{\\mathrm{LJ}}(r_c)$ for $r < r_c$ and $V(r) = 0$ for $r \\ge r_c$, with $F(r) = F_{\\mathrm{LJ}}(r)$ for $r<r_c$ and $F(r)=0$ outside.\n- Smooth quintic switching between a switching radius $r_s$ and the cutoff $r_c$: define a dimensionless $x = (r - r_s)/(r_c - r_s)$ on the interval $[0,1]$ and a smooth step $s(x) = 6x^5 - 15x^4 + 10x^3$, then $S(r) = 1$ for $r \\le r_s$, $S(r) = 0$ for $r \\ge r_c$, and $S(r) = 1 - s(x)$ for $r_s < r < r_c$. The modified potential is $V(r)=V_{\\mathrm{LJ}}(r) S(r)$ and the radial force magnitude is $F(r) = -\\frac{\\mathrm{d}}{\\mathrm{d}r}[V_{\\mathrm{LJ}}(r) S(r)] = -V_{\\mathrm{LJ}}'(r) S(r) - V_{\\mathrm{LJ}}(r) S'(r)$ in the switching interval, with $S'(r) = -\\frac{\\mathrm{d}s}{\\mathrm{d}x}\\frac{1}{(r_c - r_s)}$ and $\\frac{\\mathrm{d}s}{\\mathrm{d}x} = 30x^4 - 60x^3 + 30x^2$.\n\nSet up a one-dimensional MD with two atoms of equal mass $m=1$ located initially at $x_1(0)=0$ and $x_2(0)=r_0$, with velocities $v_1(0)=0$ and $v_2(0)=+v_0$ along the $x$ axis, so that the pair separation $r(t)=|x_2(t)-x_1(t)|$ increases and crosses the cutoff $r_c$ during the trajectory. Use Velocity Verlet time stepping from first principles: $v_i(t+\\Delta t/2)=v_i(t)+\\frac{\\Delta t}{2} a_i(t)$, $x_i(t+\\Delta t)=x_i(t)+\\Delta t\\, v_i(t+\\Delta t/2)$, then recompute forces and $a_i(t+\\Delta t)$, and finally $v_i(t+\\Delta t)=v_i(t+\\Delta t/2)+\\frac{\\Delta t}{2} a_i(t+\\Delta t)$. The kinetic energy is $K(t)=\\frac{1}{2} m [v_1(t)^2+v_2(t)^2]$ and potential energy $V(t)$ depends on the chosen cutoff scheme.\n\nQuantify two metrics for each cutoff scheme:\n\n- Force discontinuity at the cutoff: approximate the jump magnitude by sampling the radial force magnitude just inside and just outside the cutoff,\n$$\n\\Delta F = \\left|F(r_c - \\varepsilon) - F(r_c + \\varepsilon)\\right|,\n$$\nwith a small $\\varepsilon$.\n- Energy drift over the MD trajectory: compute\n$$\n\\Delta E = E(T) - E(0),\n$$\nwhere $E(t)=K(t)+V(t)$ and $T=N\\Delta t$ is the total simulated time. Report $\\Delta E$ as a dimensionless float in reduced Lennard–Jones units.\n\nYour program must implement the three cutoff treatments, run the MD for each, compute the two metrics, and output the results aggregated for all test cases in the exact format specified at the end. Use only the prescribed runtime environment.\n\nPhysical and numerical units: Use reduced Lennard–Jones units with $m=1$, $\\epsilon=1$, $\\sigma=1$ so all quantities are dimensionless. Distances are in units of $\\sigma$, time in units of $\\sqrt{m\\sigma^2/\\epsilon}$, energies in units of $\\epsilon$, and forces in units of $\\epsilon/\\sigma$. Express all outputs in these dimensionless units.\n\nAngle units: Not applicable.\n\nPercentages: Not applicable.\n\nTest suite and parameters:\n\n- Case $1$ (happy path, hard truncation): $r_c=2.5$, $\\varepsilon=10^{-6}$, $r_0=2.45$, $v_0=0.20$, $\\Delta t=0.002$, $N=2000$.\n- Case $2$ (remedy with energy shift at cutoff): $r_c=2.5$, $\\varepsilon=10^{-6}$, $r_0=2.45$, $v_0=0.20$, $\\Delta t=0.002$, $N=2000$.\n- Case $3$ (remedy with smooth quintic switch): $r_s=2.0$, $r_c=2.5$, $\\varepsilon=10^{-6}$, $r_0=2.45$, $v_0=0.20$, $\\Delta t=0.002$, $N=2000$.\n\nFinal output format: Your program should produce a single line of output containing the six results aggregated as a comma-separated list enclosed in square brackets in the order\n$$\n[\\Delta F_{\\text{hard}},\\Delta E_{\\text{hard}},\\Delta F_{\\text{shift}},\\Delta E_{\\text{shift}},\\Delta F_{\\text{smooth}},\\Delta E_{\\text{smooth}}].\n$$\nEach element must be a float.",
            "solution": "The problem requires the construction of a numerical experiment to demonstrate how different potential cutoff schemes, commonly used in molecular simulations including those with Machine Learning Interatomic Potentials (MLPs), affect the physical realism of the simulation. Specifically, we will investigate the introduction of discontinuities in interatomic forces and the resulting non-conservation of total energy during a Molecular Dynamics (MD) trajectory. The analysis will be performed on a simple one-dimensional two-atom system, which provides a clear and unambiguous illustration of the core principles.\n\n### Physical and Numerical Model\n\nThe physical system consists of two atoms of equal mass $m=1$ interacting via a pair potential. All quantities are expressed in reduced Lennard-Jones (LJ) units, where the characteristic mass $m$, energy $\\epsilon$, and length $\\sigma$ are set to $1$. The base interaction is the Lennard-Jones potential $V_{\\mathrm{LJ}}(r)$, a fundamental model for van der Waals interactions:\n$$\nV_{\\mathrm{LJ}}(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\nThe corresponding radial force magnitude, derived from the potential via $F(r) = -\\frac{\\mathrm{d}V}{\\mathrm{d}r}$, is:\n$$\nF_{\\mathrm{LJ}}(r) = \\frac{24\\epsilon}{r}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\nA positive value of $F_{\\mathrm{LJ}}(r)$ indicates a repulsive force, while a negative value indicates an attractive force.\n\nThe time evolution of the system is governed by Newton's second law, $m\\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$. We will integrate these equations of motion using the Velocity Verlet algorithm, a time-reversible and symplectic integrator known for its good energy conservation properties in long simulations. For a particle $i$, the algorithm proceeds in steps of size $\\Delta t$:\n1. $v_i(t+\\Delta t/2) = v_i(t) + \\frac{\\Delta t}{2} a_i(t)$\n2. $x_i(t+\\Delta t) = x_i(t) + \\Delta t\\, v_i(t+\\Delta t/2)$\n3. Compute forces $F_i(t+\\Delta t)$ based on new positions $x_i(t+\\Delta t)$, and find accelerations $a_i(t+\\Delta t) = F_i(t+\\Delta t) / m_i$.\n4. $v_i(t+\\Delta t) = v_i(t+\\Delta t/2) + \\frac{\\Delta t}{2} a_i(t+\\Delta t)$\n\nThe initial conditions are set such that the two atoms, starting at a separation $r(0) = r_0$, move apart and their separation $r(t)$ will cross the potential cutoff radius $r_c$.\nThe total energy of the system at any time $t$ is the sum of the kinetic and potential energies, $E(t) = K(t) + V(t)$, where $K(t) = \\frac{1}{2}m(v_1(t)^2 + v_2(t)^2)$.\n\n### Cutoff Schemes\n\nWe investigate three common methods for truncating the long-range part of the potential, a necessary step for computational efficiency in large systems.\n\n1.  **Hard Truncation**: This is the simplest approach. Both the potential $V(r)$ and the force $F(r)$ are abruptly set to zero for separations $r \\ge r_c$.\n    - $V(r) = V_{\\mathrm{LJ}}(r)$ if $r < r_c$, and $V(r)=0$ otherwise.\n    - $F(r) = F_{\\mathrm{LJ}}(r)$ if $r < r_c$, and $F(r)=0$ otherwise.\n    This method introduces a discontinuity in both the potential energy and the force at $r=r_c$, as $V_{\\mathrm{LJ}}(r_c)$ and $F_{\\mathrm{LJ}}(r_c)$ are generally non-zero.\n\n2.  **Energy Shift at Cutoff**: To fix the energy discontinuity, the potential is shifted by a constant value so that it becomes zero at the cutoff.\n    - $V(r) = V_{\\mathrm{LJ}}(r) - V_{\\mathrm{LJ}}(r_c)$ if $r < r_c$, and $V(r)=0$ otherwise.\n    - $F(r) = F_{\\mathrm{LJ}}(r)$ if $r < r_c$, and $F(r)=0$ otherwise.\n    While this makes the potential $V(r)$ continuous at $r_c$, the force $F(r) = -V'(r)$ remains discontinuous because the derivative of the constant shift is zero.\n\n3.  **Smooth Quintic Switching**: This method smoothly turns off the interaction over a range $[r_s, r_c]$. A switching function $S(r)$ is used to taper the potential and its derivatives to zero. The modified potential is $V(r) = V_{\\mathrm{LJ}}(r)S(r)$. The quintic polynomial $s(x) = 6x^5 - 15x^4 + 10x^3$ with $x=(r-r_s)/(r_c-r_s)$ is used to construct $S(r)$ such that $S(r)$ and its first two derivatives are zero at $r_c$ and match the value $1$ and derivatives $0$ at $r_s$. This ensures that the potential, force, and the force's derivative are all continuous, a property known as $C^2$ continuity. The force is calculated via the product rule:\n    $$\n    F(r) = -\\frac{\\mathrm{d}}{\\mathrm{d}r}[V_{\\mathrm{LJ}}(r)S(r)] = F_{\\mathrm{LJ}}(r)S(r) - V_{\\mathrm{LJ}}(r)S'(r)\n    $$\n    where $S'(r)$ is the derivative of the switching function with respect to $r$.\n\n### Metrics for Evaluation\n\nWe will quantify the artifacts introduced by each scheme using two metrics:\n\n1.  **Force Discontinuity ($\\Delta F$)**: This is the magnitude of the jump in the force function at the cutoff radius $r_c$, approximated by $\\Delta F = |F(r_c - \\varepsilon) - F(r_c + \\varepsilon)|$ for a small $\\varepsilon$. A non-zero $\\Delta F$ indicates a non-physical, instantaneous change in acceleration when particles cross the cutoff.\n2.  **Energy Drift ($\\Delta E$)**: This measures the change in the total energy of the system over the entire simulation, $\\Delta E = E(T) - E(0)$. In a perfectly conservative system with a perfect numerical integrator, $\\Delta E$ would be zero. A non-zero $\\Delta E$ indicates a violation of the law of conservation of energy.\n\n### Implementation Strategy\n\nThe solution will be a single Python script that implements the simulation and analysis.\n- Helper functions for the base $V_{\\mathrm{LJ}}(r)$ and $F_{\\mathrm{LJ}}(r)$ are defined.\n- Each of the three cutoff schemes is implemented as a pair of potential and force functions. For the smooth switching scheme, a helper function calculates the switching function $S(r)$ and its derivative $S'(r)$.\n- A generic Molecular Dynamics engine, `run_md`, implements the Velocity Verlet algorithm. It accepts the potential and force functions as arguments, allowing it to simulate any of the three schemes.\n- A function `calculate_force_discontinuity` computes $\\Delta F$ for a given force function.\n- The main part of the script defines the parameters for the three test cases specified in the problem statement. For each case, it calls `calculate_force_discontinuity` and `run_md` to obtain $\\Delta F$ and $\\Delta E$.\n- The aggregated results are then printed to standard output in the specified format.\n\nBased on the theory, we expect the hard truncation to show a large $\\Delta F$ and a significant $\\Delta E$ due to the jump in potential. The shifted scheme should have the same large $\\Delta F$ but a smaller $\\Delta E$ as the potential itself is continuous. The smooth switching scheme is expected to have $\\Delta F \\approx 0$ and a very small $\\Delta E$, with the residual drift attributable solely to the inherent numerical error of the Velocity Verlet integrator over the finite time step $\\Delta t$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical experiment to illustrate the effects of different\n    potential cutoff schemes in Molecular Dynamics simulations.\n    \"\"\"\n\n    # 1. Base Lennard-Jones potential and force functions in reduced units\n    def V_LJ(r, epsilon=1.0, sigma=1.0):\n        \"\"\"Calculates the Lennard-Jones potential.\"\"\"\n        if r <= 0:\n            return float('inf')\n        r_inv = sigma / r\n        r_inv6 = r_inv**6\n        return 4.0 * epsilon * (r_inv6**2 - r_inv6)\n\n    def F_LJ(r, epsilon=1.0, sigma=1.0):\n        \"\"\"Calculates the magnitude of the Lennard-Jones radial force (-dV/dr).\"\"\"\n        if r <= 0:\n            return float('inf')\n        r_inv = sigma / r\n        r_inv6 = r_inv**6\n        return 24.0 * epsilon / r * (2.0 * r_inv6**2 - r_inv6)\n\n    # 2. Implementations for the three cutoff schemes\n    def potential_hard(r, rc):\n        if r >= rc:\n            return 0.0\n        return V_LJ(r)\n\n    def force_hard(r, rc):\n        if r >= rc:\n            return 0.0\n        return F_LJ(r)\n\n    def potential_shift(r, rc):\n        if r >= rc:\n            return 0.0\n        # The potential is shifted to be zero at the cutoff\n        return V_LJ(r) - V_LJ(rc)\n\n    def force_shift(r, rc):\n        # The derivative of a constant shift is zero, so the force is unshifted\n        if r >= rc:\n            return 0.0\n        return F_LJ(r)\n    \n    def quintic_switch_S_and_S_prime(r, rs, rc):\n        \"\"\"Computes the quintic switching function S(r) and its derivative S'(r).\"\"\"\n        if r <= rs:\n            return 1.0, 0.0\n        if r >= rc:\n            return 0.0, 0.0\n        \n        delta_r_inv = 1.0 / (rc - rs)\n        x = (r - rs) * delta_r_inv\n        \n        x2 = x * x\n        x3 = x2 * x\n        \n        s_x = x3 * (10.0 - 15.0 * x + 6.0 * x2)\n        S_r = 1.0 - s_x\n        \n        # ds/dx = 30x^2(1-x)^2\n        ds_dx = 30.0 * x2 * (1.0 - x)**2\n        # S'(r) = -ds/dx * dx/dr\n        S_prime_r = -ds_dx * delta_r_inv\n        \n        return S_r, S_prime_r\n\n    def potential_smooth(r, rs, rc):\n        S_r, _ = quintic_switch_S_and_S_prime(r, rs, rc)\n        if S_r == 0.0:\n            return 0.0\n        return V_LJ(r) * S_r\n\n    def force_smooth(r, rs, rc):\n        S_r, S_prime_r = quintic_switch_S_and_S_prime(r, rs, rc)\n        if S_r == 0.0 and S_prime_r == 0.0:\n            return 0.0\n        \n        # F = -d/dr(V_LJ * S) = -V_LJ'*S - V_LJ*S' = F_LJ*S - V_LJ*S'\n        return F_LJ(r) * S_r - V_LJ(r) * S_prime_r\n\n    # 3. Generic dispatcher functions to select the scheme\n    def potential_dispatcher(r, params):\n        scheme = params['scheme']\n        if scheme == 'hard':\n            return potential_hard(r, params['rc'])\n        elif scheme == 'shift':\n            return potential_shift(r, params['rc'])\n        elif scheme == 'smooth':\n            return potential_smooth(r, params['rs'], params['rc'])\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    def force_dispatcher(r, params):\n        scheme = params['scheme']\n        if scheme == 'hard':\n            return force_hard(r, params['rc'])\n        elif scheme == 'shift':\n            return force_shift(r, params['rc'])\n        elif scheme == 'smooth':\n            return force_smooth(r, params['rs'], params['rc'])\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    # 4. Main computation routines for metrics\n    def calculate_force_discontinuity(params):\n        \"\"\"Calculates the force jump magnitude at the cutoff.\"\"\"\n        rc = params['rc']\n        eps = params['eps']\n        F_inside = force_dispatcher(rc - eps, params)\n        F_outside = force_dispatcher(rc + eps, params)\n        return abs(F_inside - F_outside)\n\n    def run_md(params):\n        \"\"\"Runs a 1D MD simulation for two atoms and returns the energy drift.\"\"\"\n        m = 1.0\n        x1, x2 = 0.0, params['r0']\n        v1, v2 = 0.0, params['v0']\n        dt, N_steps = params['dt'], params['N']\n\n        # Initial conditions\n        r = x2 - x1\n        V_initial = potential_dispatcher(r, params)\n        K_initial = 0.5 * m * (v1**2 + v2**2)\n        E_initial = K_initial + V_initial\n\n        # Initial force and acceleration\n        force_magnitude = force_dispatcher(r, params)\n        a1, a2 = -force_magnitude / m, force_magnitude / m\n\n        # MD loop using Velocity Verlet\n        for _ in range(N_steps):\n            # v(t + dt/2)\n            v1_half = v1 + 0.5 * dt * a1\n            v2_half = v2 + 0.5 * dt * a2\n            # x(t + dt)\n            x1 += dt * v1_half\n            x2 += dt * v2_half\n            # New force and acceleration a(t + dt)\n            r = x2 - x1\n            force_magnitude = force_dispatcher(r, params)\n            a1_new, a2_new = -force_magnitude / m, force_magnitude / m\n            # v(t + dt)\n            v1 = v1_half + 0.5 * dt * a1_new\n            v2 = v2_half + 0.5 * dt * a2_new\n            # Update accelerations for next step\n            a1, a2 = a1_new, a2_new\n\n        # Final energy calculation\n        r_final = x2 - x1\n        V_final = potential_dispatcher(r_final, params)\n        K_final = 0.5 * m * (v1**2 + v2**2)\n        E_final = K_final + V_final\n        \n        return E_final - E_initial\n\n    # 5. Define test cases and run the simulation for each\n    test_cases = [\n        # Case 1: Hard truncation\n        {'scheme': 'hard', 'rc': 2.5, 'eps': 1e-6, 'r0': 2.45, 'v0': 0.20, 'dt': 0.002, 'N': 2000},\n        # Case 2: Energy shift at cutoff\n        {'scheme': 'shift', 'rc': 2.5, 'eps': 1e-6, 'r0': 2.45, 'v0': 0.20, 'dt': 0.002, 'N': 2000},\n        # Case 3: Smooth quintic switch\n        {'scheme': 'smooth', 'rs': 2.0, 'rc': 2.5, 'eps': 1e-6, 'r0': 2.45, 'v0': 0.20, 'dt': 0.002, 'N': 2000}\n    ]\n\n    results = []\n    for params in test_cases:\n        delta_F = calculate_force_discontinuity(params)\n        delta_E = run_md(params)\n        results.extend([delta_F, delta_E])\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}