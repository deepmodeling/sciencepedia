{
    "hands_on_practices": [
        {
            "introduction": "A fundamental challenge in mesoscale modeling is linking the abstract parameters of a simulation to tangible macroscopic properties. This practice focuses on the Lattice Boltzmann Method (LBM) and provides a direct, hands-on method for connecting the mesoscopic relaxation time $\\tau$ to the physical kinematic viscosity $\\nu$. By completing this exercise, you will learn how to set up an LBM simulation to accurately model a fluid flow characterized by a specific Reynolds number, a crucial first step in any practical simulation. ",
            "id": "3824269",
            "problem": "Consider an isothermal, single-relaxation-time Bhatnagar–Gross–Krook Lattice Boltzmann Method (BGK-LBM) on the two-dimensional nine-velocity (D2Q9) lattice to simulate steady laminar flow in a straight microchannel of height $L_{\\mathrm{phys}}$. The lattice sound speed is $c_{s}$, the lattice speed is $c$, and the relaxation time is $\\tau$. Assume the standard D2Q9 relation $c_{s}^{2} = c^{2}/3$ with $c = \\delta x / \\delta t$, where $\\delta x$ is the lattice spacing and $\\delta t$ is the physical time step. The kinematic viscosity $\\nu$ of the fluid emerging from the BGK-LBM under isothermal conditions is related to $\\tau$ via\n$$\n\\nu = c_{s}^{2} \\left(\\tau - \\frac{1}{2}\\right) \\delta t.\n$$\nYou wish to match a target Reynolds number $\\mathrm{Re}$ defined by the conventional continuum relation\n$$\n\\mathrm{Re} = \\frac{U_{\\mathrm{phys}} L_{\\mathrm{phys}}}{\\nu},\n$$\nwhere $U_{\\mathrm{phys}}$ is a characteristic physical speed and $L_{\\mathrm{phys}}$ is the characteristic physical length (take the channel height as the characteristic length). To control compressibility error, you choose the physical time step $\\delta t$ such that the dimensionless lattice velocity\n$$\nU_{\\mathrm{latt}} = \\frac{U_{\\mathrm{phys}} \\, \\delta t}{\\delta x}\n$$\nequals $0.05$. The channel height is discretized with $N_{x}$ points so that $\\delta x = L_{\\mathrm{phys}} / N_{x}$.\n\nStarting from the above definitions and relations, derive an expression for $\\tau$ in terms of $U_{\\mathrm{latt}}$, $L_{\\mathrm{phys}}$, $\\delta x$, and $\\mathrm{Re}$. Then, for the numerical values\n$$\nL_{\\mathrm{phys}} = 1.0 \\times 10^{-3} \\ \\mathrm{m}, \\quad U_{\\mathrm{phys}} = 1.0 \\ \\mathrm{m/s}, \\quad N_{x} = 256, \\quad \\mathrm{Re} = 120, \\quad U_{\\mathrm{latt}} = 0.05,\n$$\ncompute the value of $\\tau$. Express your final answer as a dimensionless number and round your answer to four significant figures.",
            "solution": "The problem asks for the derivation of an expression for the single-relaxation-time parameter $\\tau$ for a BGK-LBM simulation and its numerical value for a specific case. The validation process confirms that the problem is scientifically sound, well-posed, and contains all necessary and consistent information.\n\nFirst, we begin by establishing the connection between the macroscopic fluid properties and the mesoscopic simulation parameters. The target macroscopic system is defined by the Reynolds number, $\\mathrm{Re}$:\n$$\n\\mathrm{Re} = \\frac{U_{\\mathrm{phys}} L_{\\mathrm{phys}}}{\\nu}\n$$\nwhere $U_{\\mathrm{phys}}$ is the characteristic physical velocity, $L_{\\mathrm{phys}}$ is the characteristic physical length (the channel height), and $\\nu$ is the kinematic viscosity of the fluid. We can express the kinematic viscosity from this continuum relation as:\n$$\n\\nu = \\frac{U_{\\mathrm{phys}} L_{\\mathrm{phys}}}{\\mathrm{Re}}\n$$\nThis is the value of viscosity that the simulation must reproduce.\n\nNext, we use the expression for the kinematic viscosity as it emerges from the BGK-LBM model. For a D2Q9 lattice, this is given by:\n$$\n\\nu = c_{s}^{2} \\left(\\tau - \\frac{1}{2}\\right) \\delta t\n$$\nwhere $c_{s}$ is the lattice sound speed, $\\tau$ is the relaxation time, and $\\delta t$ is the physical time step. The problem specifies the standard relations for the D2Q9 lattice: $c_{s}^{2} = c^{2}/3$ and $c = \\delta x / \\delta t$, where $c$ is the lattice speed and $\\delta x$ is the lattice spacing.\n\nSubstituting these relations into the expression for $\\nu$:\n$$\n\\nu = \\frac{c^2}{3} \\left(\\tau - \\frac{1}{2}\\right) \\delta t = \\frac{1}{3} \\left(\\frac{\\delta x}{\\delta t}\\right)^2 \\left(\\tau - \\frac{1}{2}\\right) \\delta t\n$$\nSimplifying this expression yields the mesoscopic viscosity in terms of lattice parameters:\n$$\n\\nu = \\frac{(\\delta x)^2}{3 \\delta t} \\left(\\tau - \\frac{1}{2}\\right)\n$$\nTo ensure the simulation matches the desired physical system, we equate the macroscopic and mesoscopic expressions for the kinematic viscosity:\n$$\n\\frac{U_{\\mathrm{phys}} L_{\\mathrm{phys}}}{\\mathrm{Re}} = \\frac{(\\delta x)^2}{3 \\delta t} \\left(\\tau - \\frac{1}{2}\\right)\n$$\nOur goal is to derive an expression for $\\tau$. We rearrange the equation to solve for the term containing $\\tau$:\n$$\n\\tau - \\frac{1}{2} = \\frac{3 U_{\\mathrm{phys}} L_{\\mathrm{phys}} \\delta t}{\\mathrm{Re} (\\delta x)^2}\n$$\nThe problem statement provides a definition for the dimensionless lattice velocity, $U_{\\mathrm{latt}}$, as $U_{\\mathrm{latt}} = \\frac{U_{\\mathrm{phys}} \\delta t}{\\delta x}$. We can use this definition to simplify the expression. By factoring the right-hand side, we get:\n$$\n\\tau - \\frac{1}{2} = \\frac{3 L_{\\mathrm{phys}}}{\\delta x} \\left(\\frac{U_{\\mathrm{phys}} \\delta t}{\\delta x}\\right) \\frac{1}{\\mathrm{Re}}\n$$\nSubstituting $U_{\\mathrm{latt}}$ gives:\n$$\n\\tau - \\frac{1}{2} = \\frac{3 L_{\\mathrm{phys}}}{\\delta x} \\frac{U_{\\mathrm{latt}}}{\\mathrm{Re}}\n$$\nFurthermore, the problem states that the channel height $L_{\\mathrm{phys}}$ is discretized with $N_{x}$ lattice points, meaning $L_{\\mathrm{phys}} = N_{x} \\delta x$, or equivalently, $N_{x} = L_{\\mathrm{phys}} / \\delta x$. Substituting this into the equation:\n$$\n\\tau - \\frac{1}{2} = \\frac{3 N_{x} U_{\\mathrm{latt}}}{\\mathrm{Re}}\n$$\nFinally, solving for $\\tau$, we obtain the desired expression:\n$$\n\\tau = \\frac{3 N_{x} U_{\\mathrm{latt}}}{\\mathrm{Re}} + \\frac{1}{2}\n$$\nThis expression relates the LBM relaxation time $\\tau$ to the dimensionless numbers $N_x$, $U_{\\mathrm{latt}}$, and $\\mathrm{Re}$. This completes the first part of the task.\n\nFor the second part, we compute the numerical value of $\\tau$ using the provided data:\n$N_{x} = 256$\n$U_{\\mathrm{latt}} = 0.05$\n$\\mathrm{Re} = 120$\n\nSubstituting these values into the derived formula for $\\tau$:\n$$\n\\tau = \\frac{3 \\times 256 \\times 0.05}{120} + \\frac{1}{2}\n$$\nWe calculate the value of the fraction first:\n$$\n\\frac{3 \\times 256 \\times 0.05}{120} = \\frac{768 \\times 0.05}{120} = \\frac{38.4}{120} = 0.32\n$$\nNow, we add the remaining term:\n$$\n\\tau = 0.32 + 0.5 = 0.82\n$$\nThe problem requires the answer to be rounded to four significant figures. Therefore, we express the result as:\n$$\n\\tau = 0.8200\n$$\nThis value is dimensionless, as required. It also satisfies the stability condition for the BGK model, which is $\\tau  0.5$.",
            "answer": "$$\n\\boxed{0.8200}\n$$"
        },
        {
            "introduction": "Beyond just implementing a model, a key task in computational science is verifying its correctness and understanding its limitations. This exercise focuses on Smoothed Particle Hydrodynamics (SPH) and guides you through the process of measuring the numerical convergence order, a fundamental technique for assessing the accuracy of a simulation code. By comparing the performance of different smoothing kernels, you will gain practical insight into how these core algorithmic choices affect the quality of your simulation results. ",
            "id": "3824285",
            "problem": "Consider the one-dimensional periodic domain $[0,1]$ with a smooth, periodic test function $f(x) = \\sin(2\\pi x) + \\tfrac{1}{2}\\sin(6\\pi x)$, where angles are to be interpreted in radians. Smoothed Particle Hydrodynamics (SPH) approximates a function via a kernel-weighted particle summation. For a uniform particle distribution with $N$ particles, particle positions $x_j = \\tfrac{j}{N}$, and spacing $\\Delta x = \\tfrac{1}{N}$, define the periodic distance between two points by $d(x,y) = \\min(|x-y|, 1 - |x-y|)$. The continuous SPH approximation of a function $f(x)$ is \n$$\nf_h(x) = \\int_{\\mathbb{R}} f(y)\\, W(|x-y|, h)\\, \\mathrm{d}y,\n$$ \nwhere $W(r,h)$ is a smoothing kernel of characteristic length $h$ that satisfies the normalization condition $\\int_{\\mathbb{R}} W(r,h)\\, \\mathrm{d}r = 1$ and is nonnegative, radially symmetric, and decays with $r/h$. The discrete SPH interpolation on the uniform periodic lattice is \n$$\nf_h^{\\Delta x}(x_i) = \\sum_{j=0}^{N-1} f(x_j)\\, W\\!\\left(d(x_i,x_j),\\, h\\right)\\, \\Delta x,\n$$ \nwith $x_i = \\tfrac{i}{N}$ for $i=0,\\ldots,N-1$. The error of the SPH interpolation is measured in the $L^2$ norm and the $L^\\infty$ norm over the discrete grid:\n$$\n\\|e\\|_{L^2} = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left( f(x_i) - f_h^{\\Delta x}(x_i) \\right)^2 \\right)^{1/2}, \\quad \\|e\\|_{L^\\infty} = \\max_{0 \\le i \\le N-1} \\left| f(x_i) - f_h^{\\Delta x}(x_i) \\right|.\n$$\nIn this problem, implement the SPH approximation using three kernels:\n- Gaussian kernel: $W_{\\mathrm{G}}(r,h) = \\dfrac{1}{\\sqrt{\\pi}\\, h}\\, \\exp\\!\\left( -\\left(\\dfrac{r}{h}\\right)^2 \\right)$,\n- Cubic spline kernel (compact support $2h$): \n$$\nW_{\\mathrm{CS}}(r,h) = \\frac{2}{3h}\n\\begin{cases}\n1 - \\tfrac{3}{2}q^2 + \\tfrac{3}{4}q^3,  0 \\le q  1,\\\\\n\\tfrac{1}{4}(2 - q)^3,  1 \\le q  2,\\\\\n0,  q \\ge 2,\n\\end{cases}\n\\quad \\text{where } q = \\dfrac{r}{h},\n$$\n- Wendland $C^2$ kernel (compact support $2h$), normalized in one dimension:\n$$\nW_{\\mathrm{W2}}(r,h) = \\frac{3}{4h} \\left(1 - \\frac{q}{2}\\right)^4 (1 + 2q) \\quad \\text{for } 0 \\le q \\le 2, \\text{ and } 0 \\text{ otherwise}, \\quad q = \\dfrac{r}{h}.\n$$\nFor each kernel, choose the smoothing length $h$ proportional to the particle spacing via $h = \\alpha\\, \\Delta x$, where $\\alpha$ is a fixed ratio per test case. Measure the empirical convergence order $p$ by fitting a line to the log-log relationship of the error versus $\\Delta x$:\n$$\n\\log \\|e\\| \\approx p \\log \\Delta x + \\log C,\n$$\nso the slope $p$ is the estimated convergence order. Use least squares linear regression on $\\left( \\log \\Delta x, \\log \\|e\\| \\right)$ pairs.\n\nYour task is to:\n1. Implement the SPH interpolation for the three kernels above on the periodic domain $[0,1]$ using the discrete formulation.\n2. For each test case below, compute the $L^2$ and $L^\\infty$ errors at four resolutions $N \\in \\{50, 100, 200, 400\\}$, with $h = \\alpha \\Delta x$, and estimate the convergence orders $p_{2}$ and $p_{\\infty}$ for the $L^2$ and $L^\\infty$ norms, respectively, using least squares linear regression on the logarithms.\n3. Report the estimated convergence orders as dimensionless floats rounded to three decimal places.\n\nTest suite (each element is a pair $(\\text{kernel}, \\alpha)$):\n- Case A: $(\\text{Gaussian}, 1.0)$,\n- Case B: $(\\text{CubicSpline}, 1.2)$,\n- Case C: $(\\text{WendlandC2}, 1.5)$,\n- Case D (edge case, under-resolved smoothing): $(\\text{Gaussian}, 0.7)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[p_2, p_{\\infty}]$ corresponding to the test cases in the order listed above. For example, the output should look like `[[p2_A,pinf_A],[p2_B,pinf_B],[p2_C,pinf_C],[p2_D,pinf_D]]`. All reported values must be rounded to three decimal places and are dimensionless.",
            "solution": "The problem requires the implementation and analysis of the Smoothed Particle Hydrodynamics (SPH) method for function approximation in a one-dimensional periodic domain. The objective is to determine the empirical order of convergence for three different smoothing kernels by performing a numerical experiment.\n\nThe process is structured as follows:\n1.  Discretize the domain and define the SPH approximation.\n2.  Implement the specified smoothing kernels.\n3.  Calculate the approximation error for a series of spatial resolutions.\n4.  Estimate the convergence order using linear regression on the log-log plot of error versus resolution.\n\n**1. SPH Formulation and Discretization**\n\nThe problem is defined on a one-dimensional periodic domain of length $L=1$, specifically $[0,1]$. This domain is discretized using $N$ uniformly distributed particles. The position of the $j$-th particle is given by $x_j = j/N$ for $j = 0, 1, \\ldots, N-1$. The uniform particle spacing is $\\Delta x = 1/N$.\n\nThe SPH approximation of a function $f(x)$ at a particle location $x_i$ is a summation over all particles, weighted by a smoothing kernel $W$. The formula for the discrete SPH interpolation is:\n$$\nf_h^{\\Delta x}(x_i) = \\sum_{j=0}^{N-1} f(x_j)\\, W(d(x_i, x_j), h)\\, \\Delta x\n$$\nHere, $f(x_j)$ is the exact value of the function at particle $x_j$. The term $\\Delta x$ represents the one-dimensional volume associated with each particle. The function $d(x,y)$ calculates the periodic distance, essential for problems on a periodic domain, defined as:\n$$\nd(x, y) = \\min(|x - y|, 1 - |x - y|)\n$$\nThe smoothing length, $h$, determines the range of influence of the kernel and is set proportional to the particle spacing, $h = \\alpha \\Delta x$, where $\\alpha$ is a given constant.\n\nThe target function to be approximated is $f(x) = \\sin(2\\pi x) + \\frac{1}{2}\\sin(6\\pi x)$.\n\n**2. Smoothing Kernels**\n\nThe problem specifies three distinct smoothing kernels, each with its own properties regarding smoothness and support.\n\n- **Gaussian Kernel**: This kernel is infinitely differentiable ($C^\\infty$) and has infinite support. Its one-dimensional form is:\n$$\nW_{\\mathrm{G}}(r, h) = \\frac{1}{\\sqrt{\\pi}\\, h}\\, \\exp\\left( -\\left(\\frac{r}{h}\\right)^2 \\right)\n$$\n\n- **Cubic Spline Kernel**: This kernel is a piecewise polynomial with compact support of radius $2h$. It is a standard choice in SPH, offering a balance between computational cost and accuracy. With $q = r/h$, it is defined as:\n$$\nW_{\\mathrm{CS}}(r, h) = \\frac{2}{3h}\n\\begin{cases}\n1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3,  0 \\le q  1, \\\\\n\\frac{1}{4}(2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2\n\\end{cases}\n$$\n\n- **Wendland $C^2$ Kernel**: This is a compactly supported polynomial kernel specifically constructed to have a certain degree of smoothness (in this case, $C^2$ continuous). Its one-dimensional form is:\n$$\nW_{\\mathrm{W2}}(r, h) = \\frac{3}{4h} \\left(1 - \\frac{q}{2}\\right)^4 (1 + 2q), \\quad \\text{for } 0 \\le q \\le 2, \\text{ and } 0 \\text{ otherwise, where } q = \\frac{r}{h}\n$$\n\n**3. Error Estimation**\n\nTo quantify the accuracy of the SPH approximation, we compute the error $e_i = f(x_i) - f_h^{\\Delta x}(x_i)$ at each particle location. The overall error is measured using two discrete norms:\n\n- **$L^2$ Norm**: This norm computes a root-mean-square error over the grid.\n$$\n\\|e\\|_{L^2} = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left( f(x_i) - f_h^{\\Delta x}(x_i) \\right)^2 \\right)^{1/2}\n$$\n\n- **$L^\\infty$ Norm**: This norm measures the maximum absolute error at any point on the grid.\n$$\n\\|e\\|_{L^\\infty} = \\max_{0 \\le i \\le N-1} \\left| f(x_i) - f_h^{\\Delta x}(x_i) \\right|\n$$\n\n**4. Convergence Analysis**\n\nThe order of convergence, $p$, describes how the error $\\|e\\|$ decreases as the particle spacing $\\Delta x$ approaches zero. This relationship is typically a power law, $\\|e\\| \\approx C (\\Delta x)^p$, where $C$ is a constant. By taking the logarithm of this relationship, we obtain a linear equation:\n$$\n\\log \\|e\\| \\approx p \\log \\Delta x + \\log C\n$$\nThis reveals that the convergence order $p$ is the slope of the line in a log-log plot of error versus particle spacing.\n\nTo estimate $p$, we compute the errors for a sequence of resolutions $N \\in \\{50, 100, 200, 400\\}$, which correspond to particle spacings $\\Delta x \\in \\{1/50, 1/100, 1/200, 1/400\\}$. We then perform a least-squares linear regression on the data pairs $(\\log \\Delta x, \\log \\|e\\|)$. The slope of the resulting regression line provides the estimated convergence order, $p_2$ for the $L^2$ norm and $p_{\\infty}$ for the $L^\\infty$ norm.\n\n**5. Implementation Strategy**\n\nThe numerical procedure is implemented for each of the four test cases $(\\text{kernel}, \\alpha)$.\nFor a given test case and a resolution $N$:\n1.  The particle positions $x_j$ and exact function values $f(x_j)$ are computed.\n2.  A distance matrix $D$ is constructed, where $D_{ij} = d(x_i, x_j)$. Vectorized operations are used for efficiency: given the vector of positions $x$, the matrix of absolute differences $|x_i - x_j|$ is formed, and the periodic distance is found by taking the element-wise minimum of this matrix and $1$ minus this matrix.\n3.  The kernel function $W$ is applied to the distance matrix $D$ and the smoothing length $h = \\alpha \\Delta x$ to generate a kernel matrix $W_{ij} = W(D_{ij}, h)$.\n4.  The SPH approximation $f_h^{\\Delta x}$ is calculated as a matrix-vector product: $f_h^{\\Delta x} = (W \\cdot f) \\Delta x$, where $f$ is the vector of exact function values.\n5.  Errors are computed and their logarithms are stored along with the logarithm of $\\Delta x$.\n\nAfter iterating through all resolutions for a test case, `numpy.polyfit` with degree $1$ is used to perform the linear regression and extract the slope, yielding the convergence orders $p_2$ and $p_{\\infty}$. The results for all test cases are then collected and formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the SPH convergence problem.\n    \"\"\"\n\n    # Define the smooth, periodic test function\n    def f_exact(x):\n        return np.sin(2 * np.pi * x) + 0.5 * np.sin(6 * np.pi * x)\n\n    # --- Kernel Function Implementations ---\n\n    def gaussian_kernel(r, h):\n        \"\"\"Gaussian smoothing kernel.\"\"\"\n        return 1.0 / (np.sqrt(np.pi) * h) * np.exp(-(r / h)**2)\n\n    def cubic_spline_kernel(r, h):\n        \"\"\"Cubic Spline (M4) smoothing kernel.\"\"\"\n        q = r / h\n        factor = 2.0 / (3.0 * h)\n        \n        # Initialize result array\n        res = np.zeros_like(q)\n        \n        # Mask for 0 = q  1\n        mask1 = q  1\n        q1 = q[mask1]\n        res[mask1] = 1.0 - 1.5 * q1**2 + 0.75 * q1**3\n        \n        # Mask for 1 = q  2\n        mask2 = (q = 1)  (q  2)\n        q2 = q[mask2]\n        res[mask2] = 0.25 * (2.0 - q2)**3\n        \n        return factor * res\n\n    def wendland_c2_kernel(r, h):\n        \"\"\"Wendland C2 smoothing kernel, normalized in 1D.\"\"\"\n        q = r / h\n        factor = 3.0 / (4.0 * h)\n        \n        # Initialize result array\n        res = np.zeros_like(q)\n\n        # Mask for 0 = q = 2\n        mask = q = 2\n        q_masked = q[mask]\n        \n        term1 = (1.0 - q_masked / 2.0)**4\n        term2 = (1.0 + 2.0 * q_masked)\n        res[mask] = term1 * term2\n        \n        return factor * res\n\n    # --- Problem Setup ---\n\n    # Test suite: (kernel_name, alpha)\n    test_cases = [\n        ('gaussian', 1.0),\n        ('cubicspline', 1.2),\n        ('wendlandc2', 1.5),\n        ('gaussian', 0.7)\n    ]\n\n    kernel_map = {\n        'gaussian': gaussian_kernel,\n        'cubicspline': cubic_spline_kernel,\n        'wendlandc2': wendland_c2_kernel\n    }\n    \n    # Resolutions for convergence study\n    resolutions = np.array([50, 100, 200, 400])\n    \n    final_results = []\n\n    # --- Main Loop over Test Cases ---\n    for kernel_name, alpha in test_cases:\n        kernel_func = kernel_map[kernel_name]\n        \n        log_delta_x = []\n        log_l2_errors = []\n        log_linf_errors = []\n\n        # Loop over resolutions to gather error data\n        for N in resolutions:\n            delta_x = 1.0 / N\n            h = alpha * delta_x\n            \n            # Create particle grid and evaluate exact function\n            x = np.arange(N) / N\n            f_vals = f_exact(x)\n            \n            # --- SPH Approximation Calculation ---\n            \n            # Construct periodic distance matrix using broadcasting\n            x_col = x[:, np.newaxis]\n            x_row = x[np.newaxis, :]\n            abs_diff = np.abs(x_col - x_row)\n            d_matrix = np.minimum(abs_diff, 1.0 - abs_diff)\n            \n            # Evaluate kernel on the distance matrix\n            W_matrix = kernel_func(d_matrix, h)\n            \n            # Compute SPH sum via matrix-vector product\n            f_sph = np.dot(W_matrix, f_vals) * delta_x\n            \n            # --- Error Calculation ---\n            \n            error = f_vals - f_sph\n            \n            # L2 norm of the error\n            l2_error = np.sqrt(delta_x * np.sum(error**2))\n            \n            # L-infinity norm of the error\n            linf_error = np.max(np.abs(error))\n            \n            # Store log of values for regression\n            log_delta_x.append(np.log(delta_x))\n            log_l2_errors.append(np.log(l2_error))\n            log_linf_errors.append(np.log(linf_error))\n\n        # --- Convergence Order Estimation ---\n        \n        # Use numpy.polyfit to perform linear regression (degree 1)\n        # The slope (first element of the returned array) is the convergence order\n        p2, _ = np.polyfit(log_delta_x, log_l2_errors, 1)\n        p_inf, _ = np.polyfit(log_delta_x, log_linf_errors, 1)\n\n        # Append results for this test case\n        final_results.append([p2, p_inf])\n\n    # --- Format and Print Final Output ---\n    \n    # Build the output string to match the specified format precisely\n    # e.g., [[p2_A,pinf_A],[p2_B,pinf_B],...] with no spaces\n    results_str_list = [f\"[{p2:.3f},{pinf:.3f}]\" for p2, pinf in final_results]\n    output_str = f\"[{','.join(results_str_list)}]\"\n    \n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "This advanced practice bridges the gap between microscopic model inputs and macroscopic thermodynamic and transport properties in Dissipative Particle Dynamics (DPD). Rather than simply applying established formulas, this problem challenges you to derive the mapping from first principles, including the virial equation of state and Green-Kubo relations for transport coefficients. This process builds a deep, fundamental understanding of how DPD parameters are systematically chosen to reproduce the behavior of a specific target fluid. ",
            "id": "3824322",
            "problem": "Consider a coarse-grained fluid modeled by Dissipative Particle Dynamics (DPD), where particles interact via three pairwise terms: a conservative force, a dissipative force, and a random force. Work in three spatial dimensions, with reduced DPD units such that the particle mass is $m=1$, the cutoff distance is $r_c$ (explicitly provided per case), and lengths, energies, and times are nondimensionalized consistently with $r_c$, $m$, and the thermal energy $k_B T$. Assume a uniform, isotropic fluid with number density $\\rho$ and a pair distribution function $g(r)=1$ for $0 \\le r \\le r_c$.\n\nYou must map the DPD model parameters—the conservative force amplitude $a$, the dissipative coefficient $\\gamma$, and the random force amplitude $\\sigma$—to match specified target thermodynamic and transport properties: target thermal energy $k_B T$, target isothermal compressibility $\\kappa_T$, and target shear viscosity $\\eta$. The mapping must be derived from first principles and implemented as a runnable program that outputs the computed $a$, $\\gamma$, and $\\sigma$ for a small test suite.\n\nBase your derivation and algorithm on the following fundamental laws and core definitions, without introducing any shortcut formulas:\n- The virial expression for the equation of state in terms of pairwise forces and the radial distribution $g(r)$.\n- The definition of isothermal compressibility $\\kappa_T$ in terms of the equation of state at fixed temperature.\n- The Green–Kubo relation for shear viscosity as the time integral of the equilibrium shear-stress autocorrelation function.\n- The fluctuation–dissipation relation that ties the random and dissipative force amplitudes in DPD at temperature $T$.\n\nUse the following DPD interaction structure:\n- Conservative weight function $w_C(r)$ satisfies $w_C(r)=1-r/r_c$ for $0 \\le r \\le r_c$ and $w_C(r)=0$ for $rr_c$, and the conservative force is proportional to $a\\,w_C(r)$, acting along the pair separation.\n- Dissipative weight function $w_D(r)$ satisfies $w_D(r)=1-r/r_c$ for $0 \\le r \\le r_c$ and $w_D(r)=0$ for $rr_c$, and the dissipative force is proportional to $\\gamma\\,w_D^2(r)$ times the projection of the pairwise relative velocity along the pair axis.\n- Random force amplitude $\\sigma$ must satisfy the fluctuation–dissipation constraint for DPD at temperature $T$.\n\nAssume $g(r)=1$ and that the dissipative contribution dominates the shear viscosity in the Green–Kubo evaluation for these parameter regimes. Under these assumptions:\n1. Use the virial expression to obtain a pressure equation of state $p(\\rho, T, a)$ for the specified weights.\n2. Use the definition of isothermal compressibility $\\kappa_T$ to solve for the conservative amplitude $a$ that achieves the target $\\kappa_T$ at given $\\rho$ and $T$.\n3. Use the Green–Kubo relation specialized to the dissipative stress contribution to obtain a shear viscosity $\\eta(\\rho, \\gamma)$ and solve for the dissipative coefficient $\\gamma$ that achieves the target $\\eta$ at given $\\rho$.\n4. Use the fluctuation–dissipation relation to compute $\\sigma$ from $\\gamma$ and $T$.\n\nAll answers must be expressed in reduced DPD units consistent with the given $r_c$ values, the unit mass $m=1$, and the specified $k_B T$; no physical unit conversion is required. Angles do not appear in this problem. There are no percentages.\n\nImplement a program that, for each test case listed below, computes and returns the triple $[a,\\gamma,\\sigma]$ as floats. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result itself expressed as a comma-separated triple enclosed in square brackets. For example: \"[[a_1,\\gamma_1,\\sigma_1],[a_2,\\gamma_2,\\sigma_2],...]\". Use the exact parameter values given in the test suite.\n\nTest suite (all quantities are in reduced DPD units):\n- Case 1 (happy path): $r_c=1.0$, $\\rho=3.0$, $k_B T=1.0$, $\\kappa_T=0.2$, $\\eta=0.5$.\n- Case 2 (boundary condition, ideal gas compressibility): $r_c=1.0$, $\\rho=3.0$, $k_B T=1.0$, $\\kappa_T = 1/(\\rho\\,k_B T)$, $\\eta=0.1$.\n- Case 3 (higher density and temperature, smaller cutoff): $r_c=0.9$, $\\rho=4.0$, $k_B T=1.2$, $\\kappa_T=0.15$, $\\eta=1.2$.\n- Case 4 (lower density and temperature, larger cutoff): $r_c=1.1$, $\\rho=2.5$, $k_B T=0.8$, $\\kappa_T=0.25$, $\\eta=0.2$.\n\nYour program must compute $a$, $\\gamma$, and $\\sigma$ for each case, then print a single line in the exact required format: \"[[a_1,\\gamma_1,\\sigma_1],[a_2,\\gamma_2,\\sigma_2],[a_3,\\gamma_3,\\sigma_3],[a_4,\\gamma_4,\\sigma_4]]\". The results must be floats.",
            "solution": "The problem of mapping the microscopic parameters of a Dissipative Particle Dynamics (DPD) model to macroscopic fluid properties is a foundational task in mesoscale simulation. The objective is to determine the conservative force amplitude $a$, the dissipative coefficient $\\gamma$, and the random force amplitude $\\sigma$ that reproduce a target thermal energy $k_B T$, isothermal compressibility $\\kappa_T$, and shear viscosity $\\eta$ for a fluid of number density $\\rho$. The derivation will proceed from first principles as specified, utilizing the virial theorem, the definition of compressibility, the Green-Kubo relation for viscosity, and the fluctuation-dissipation theorem, under the provided modeling assumptions. All calculations are performed in a consistent set of reduced DPD units where the particle mass $m=1$ and the cutoff distance is $r_c$.\n\nThe derivation proceeds in three distinct steps, sequentially determining $a$, $\\gamma$, and $\\sigma$.\n\n**Step 1: Derivation of the Conservative Force Parameter $a$**\n\nThe conservative parameter $a$ governs the equilibrium structure and thermodynamic properties, such as the equation of state. We derive its value from the target isothermal compressibility, $\\kappa_T$.\n\nThe pressure $p$ of a system of particles interacting via pairwise forces is given by the virial theorem. In $3$ dimensions, it is the sum of the ideal gas (kinetic) contribution and the excess (interaction) contribution:\n$$ p = \\rho k_B T + p_{ex} $$\nThe excess pressure $p_{ex}$ arises from interparticle forces. For a system with pairwise central forces, it is given by:\n$$ p_{ex} = \\frac{1}{6V} \\left\\langle \\sum_{ij} r_{ij} F(r_{ij}) \\right\\rangle $$\nwhere $V$ is the system volume, $r_{ij}$ is the distance between particles $i$ and $j$, and $F(r_{ij})$ is the magnitude of the force between them. This sum can be expressed as an integral over the radial distribution function, $g(r)$:\n$$ p_{ex} = \\frac{2\\pi \\rho^2}{3} \\int_0^\\infty r^3 F(r) g(r) dr $$\nIn DPD, the equation of state is determined by the conservative force, $\\vec{F}^C_{ij}$, as the dissipative and random forces have zero average contribution to the static pressure tensor. The magnitude of the conservative force is $F^C(r) = a \\, w_C(r)$, where the weight function is given as $w_C(r) = 1 - r/r_c$ for $0 \\le r \\le r_c$ and $0$ otherwise. The problem states to use the mean-field approximation $g(r)=1$ for $0 \\le r \\le r_c$.\n\nSubstituting these forms into the integral for $p_{ex}$:\n$$ p_{ex} = \\frac{2\\pi a \\rho^2}{3} \\int_0^{r_c} r^3 \\left(1 - \\frac{r}{r_c}\\right) dr $$\nEvaluating the integral:\n$$ \\int_0^{r_c} \\left(r^3 - \\frac{r^4}{r_c}\\right) dr = \\left[ \\frac{r^4}{4} - \\frac{r^5}{5r_c} \\right]_0^{r_c} = \\frac{r_c^4}{4} - \\frac{r_c^4}{5} = \\frac{r_c^4}{20} $$\nThis yields the excess pressure:\n$$ p_{ex} = \\frac{2\\pi a \\rho^2}{3} \\frac{r_c^4}{20} = \\frac{\\pi a \\rho^2 r_c^4}{30} $$\nThe complete equation of state is therefore:\n$$ p(\\rho, T, a) = \\rho k_B T + \\frac{\\pi a \\rho^2 r_c^4}{30} $$\nThe isothermal compressibility $\\kappa_T$ is defined as $\\kappa_T = \\frac{1}{\\rho} \\left(\\frac{\\partial \\rho}{\\partial p}\\right)_T$. It is more convenient to work with its inverse, the isothermal bulk modulus $K_T = 1/\\kappa_T = \\rho \\left(\\frac{\\partial p}{\\partial \\rho}\\right)_T$.\nWe differentiate the equation of state with respect to $\\rho$ at constant temperature $T$:\n$$ \\left(\\frac{\\partial p}{\\partial \\rho}\\right)_T = k_B T + \\frac{2 \\pi a \\rho r_c^4}{30} = k_B T + \\frac{\\pi a \\rho r_c^4}{15} $$\nSubstituting this into the expression for $K_T$:\n$$ \\frac{1}{\\kappa_T} = \\rho \\left( k_B T + \\frac{\\pi a \\rho r_c^4}{15} \\right) = \\rho k_B T + \\frac{\\pi a \\rho^2 r_c^4}{15} $$\nWe can now rearrange this equation to solve for the parameter $a$:\n$$ \\frac{1}{\\kappa_T} - \\rho k_B T = \\frac{\\pi a \\rho^2 r_c^4}{15} $$\n$$ a = \\frac{15}{\\pi \\rho^2 r_c^4} \\left( \\frac{1}{\\kappa_T} - \\rho k_B T \\right) $$\n\n**Step 2: Derivation of the Dissipative Coefficient $\\gamma$**\n\nThe dissipative coefficient $\\gamma$ controls the fluid's transport properties, primarily its shear viscosity $\\eta$. We derive its value from the target $\\eta$ using a simplified form of the Green-Kubo relation.\n\nThe Green-Kubo relations connect macroscopic transport coefficients to the time integrals of equilibrium time correlation functions of microscopic fluctuations. For shear viscosity, the relation is:\n$$ \\eta = \\frac{V}{k_B T} \\int_0^\\infty \\langle P_{xy}(0) P_{xy}(t) \\rangle dt $$\nwhere $P_{xy}$ is an off-diagonal component of the microscopic pressure tensor. The problem states to assume that the contribution from the dissipative force dominates the viscosity. Under this assumption, a simplified expression for the viscosity, equivalent to a kinetic theory result, can be used. This contribution, $\\eta_D$, is given by:\n$$ \\eta \\approx \\eta_D = \\frac{2 \\pi}{15} \\rho^2 \\gamma \\int_0^{r_c} r^4 w_D^2(r) g(r) dr $$\nThe dissipative weight function is $w_D(r) = 1 - r/r_c$, and we again use the assumption $g(r)=1$. Substituting these into the integral:\n$$ \\int_0^{r_c} r^4 \\left(1 - \\frac{r}{r_c}\\right)^2 dr = \\int_0^{r_c} \\left(r^4 - \\frac{2r^5}{r_c} + \\frac{r^6}{r_c^2}\\right) dr $$\nEvaluating the integral:\n$$ \\left[ \\frac{r^5}{5} - \\frac{2r^6}{6r_c} + \\frac{r^7}{7r_c^2} \\right]_0^{r_c} = r_c^5 \\left(\\frac{1}{5} - \\frac{1}{3} + \\frac{1}{7}\\right) = r_c^5 \\left(\\frac{21 - 35 + 15}{105}\\right) = \\frac{r_c^5}{105} $$\nSubstituting this result into the expression for $\\eta$:\n$$ \\eta = \\frac{2 \\pi}{15} \\rho^2 \\gamma \\left(\\frac{r_c^5}{105}\\right) = \\frac{2 \\pi \\rho^2 \\gamma r_c^5}{1575} $$\nRearranging to solve for the dissipative coefficient $\\gamma$:\n$$ \\gamma = \\frac{1575 \\, \\eta}{2 \\pi \\rho^2 r_c^5} $$\n\n**Step 3: Derivation of the Random Force Amplitude $\\sigma$**\n\nThe random force amplitude $\\sigma$ is linked to the dissipative coefficient $\\gamma$ and the temperature $k_B T$ via the fluctuation-dissipation theorem. This theorem ensures that the DPD thermostat correctly maintains the system at the target temperature by balancing the energy removed by the dissipative force with the energy injected by the random force.\n\nFor the standard implementation of DPD, where the weight functions for the random and dissipative forces are related by $w_R(r) = w_D(r)$, the fluctuation-dissipation theorem imposes the following constraint on the force amplitudes:\n$$ \\sigma^2 = 2 \\gamma k_B T $$\nThis directly yields the expression for $\\sigma$:\n$$ \\sigma = \\sqrt{2 \\gamma k_B T} $$\nWith $\\gamma$ determined in the previous step, $\\sigma$ can be calculated.\n\n**Summary of the Algorithm**\n\nThe complete algorithm to map the target properties $(\\kappa_T, \\eta, k_B T)$ to the DPD parameters $(a, \\gamma, \\sigma)$ for a given density $\\rho$ and cutoff $r_c$ is as follows:\n1.  Compute the conservative force amplitude $a$:\n    $$ a = \\frac{15}{\\pi \\rho^2 r_c^4} \\left( \\frac{1}{\\kappa_T} - \\rho k_B T \\right) $$\n2.  Compute the dissipative coefficient $\\gamma$:\n    $$ \\gamma = \\frac{1575 \\, \\eta}{2 \\pi \\rho^2 r_c^5} $$\n3.  Compute the random force amplitude $\\sigma$:\n    $$ \\sigma = \\sqrt{2 \\gamma k_B T} $$\nThese three equations are implemented to solve for the parameters in each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code for solving the DPD parameterization problem.\n# This code adheres to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes DPD parameters (a, gamma, sigma) from target macroscopic properties\n    (compressibility, viscosity, temperature) based on first-principles derivations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (r_c, rho, k_B*T, kappa_T, eta)\n    test_cases = [\n        (1.0, 3.0, 1.0, 0.2, 0.5),\n        (1.0, 3.0, 1.0, 1.0 / (3.0 * 1.0), 0.1),\n        (0.9, 4.0, 1.2, 0.15, 1.2),\n        (1.1, 2.5, 0.8, 0.25, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        rc, rho, kBT, kappa_T, eta = case\n\n        # Step 1: Calculate the conservative force amplitude 'a' from isothermal compressibility.\n        # Formula: a = (15 / (pi * rho^2 * rc^4)) * (1/kappa_T - rho * kBT)\n        a_numerator = 15.0 * (1.0 / kappa_T - rho * kBT)\n        a_denominator = np.pi * rho**2 * rc**4\n        # Handle the case where the denominator might be zero, although unlikely with given inputs.\n        a = a_numerator / a_denominator if a_denominator != 0 else 0.0\n\n        # Step 2: Calculate the dissipative coefficient 'gamma' from shear viscosity.\n        # Formula: gamma = (1575 * eta) / (2 * pi * rho^2 * rc^5)\n        gamma_numerator = 1575.0 * eta\n        gamma_denominator = 2.0 * np.pi * rho**2 * rc**5\n        gamma = gamma_numerator / gamma_denominator if gamma_denominator != 0 else 0.0\n        \n        # Step 3: Calculate the random force amplitude 'sigma' using the fluctuation-dissipation theorem.\n        # Formula: sigma = sqrt(2 * gamma * kBT)\n        # Ensure the argument to sqrt is non-negative.\n        sigma_arg = 2.0 * gamma * kBT\n        sigma = np.sqrt(sigma_arg) if sigma_arg = 0 else 0.0\n\n        # Format the result for this test case as a string \"[a,gamma,sigma]\".\n        results.append(f\"[{a},{gamma},{sigma}]\")\n\n    # Final print statement in the exact required format: \"[[...],[...],...]\".\n    # The `join` method concatenates the list of formatted strings.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function.\nsolve()\n```"
        }
    ]
}