{
    "hands_on_practices": [
        {
            "introduction": "在自适应分辨率模拟 (AdResS) 中，混合区域内原子尺度和粗粒度尺度势能的平滑插值是该方法的核心特征，但这也会引入一种非物理的赝力。本练习将引导您从势能梯度的第一性原理出发，推导这种所谓的“热力学力”，并计算为将其大小控制在可接受的物理极限内所需的最小混合区域宽度。该实践旨在帮助您建立关于多尺度模拟中赝力来源以及如何通过参数选择来控制它的基本直觉 。",
            "id": "3790089",
            "problem": "考虑一个用于多尺度材料模拟的一维自适应分辨率模拟 (AdResS) 设置，其中一个粒子沿空间坐标 $x$ 穿过一个宽度为 $L_{h}$ 的混合区域。该混合区域通过一个与位置相关的混合函数 $w(x)$，平滑地融合了原子级和粗粒化的描述。假设对相互作用采用哈密顿量（基于能量）的插值，使得在分离距离为 $r$ 和位置为 $x$ 的单个相互作用对的有效势能为\n$$\nU_{\\text{eff}}(x,r) = w(x)\\,U_{\\text{AT}}(r) + \\bigl(1 - w(x)\\bigr)\\,U_{\\text{CG}}(r),\n$$\n其中 $U_{\\text{AT}}(r)$ 是原子级对势，$U_{\\text{CG}}(r)$ 是粗粒化对势。由于 $w(x)$ 依赖于位置，沿 $x$ 方向的力包含一个由链式法则产生的附加项。如果该附加项的最大值过大，可能会导致力的不连续性。\n\n设原子级对势为 Lennard-Jones 势\n$$\nU_{\\text{AT}}(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\n其最小值点在 $r_{m} = 2^{1/6}\\sigma$，最小值为 $U_{\\text{AT}}(r_{m}) = -\\varepsilon$。设粗粒化势为 Lennard-Jones 势的 Weeks–Chandler–Andersen (WCA) 截断，\n$$\nU_{\\text{CG}}(r) = \n\\begin{cases}\nU_{\\text{AT}}(r) + \\varepsilon,  r \\le r_{c}, \\\\\n0,  r > r_{c},\n\\end{cases}\n\\quad\\text{其中}\\quad r_{c} = 2^{1/6}\\sigma,\n$$\n因此 $U_{\\text{CG}}(r_{m}) = 0$。混合函数选择为光滑的 $C^{1}$ 函数\n$$\nw(x) = \n\\begin{cases}\n0,  x \\le 0, \\\\\n\\sin^{2}\\!\\left(\\dfrac{\\pi x}{2 L_{h}}\\right),  0  x  L_{h}, \\\\\n1,  x \\ge L_{h}.\n\\end{cases}\n$$\n假设力不连续性的最坏情况发生在混合区域内，一对粒子的分离距离为 $r = r_{m}$，且处于 $w(x)$ 的梯度达到最大值的位置。设 Lennard-Jones 势阱深度为 $\\varepsilon = 2.0\\,\\text{kJ/mol}$，并设沿 $x$ 方向由不连续性引起的力的最大允许值的阈值为 $F_{\\text{thr}} = 1.0 \\times 10^{-11}\\,\\text{N}$。使用阿伏伽德罗常数 $N_{A} = 6.02214076 \\times 10^{23}\\,\\text{mol}^{-1}$。\n\n仅使用基本原理（力是势能的负梯度和标准微积分），确定最小的混合区域宽度 $L_{h}$，以确保由 $w(x)$ 的位置依赖性引起的力不连续性的最大值不超过 $F_{\\text{thr}}$。以纳米为单位表示最终答案，并将结果四舍五入到四位有效数字。",
            "solution": "问题要求在一个自适应分辨率模拟（AdResS）设置中，求出最小的混合区域宽度 $L_{h}$，使得由势能的空间依赖性产生的额外力项的大小不超过给定阈值。\n\n第一步是确定所讨论的力。根据牛顿力学的基本原理，作用在粒子上的力 $\\vec{F}$ 是其势能 $U$ 的负梯度。在一维情况下，沿空间坐标 $x$ 的力分量 $F_x$ 由下式给出\n$$\nF_x = -\\frac{\\partial U}{\\partial x}.\n$$\n问题定义了一对相互作用粒子的有效势能 $U_{\\text{eff}}$。该势不仅取决于粒子间的分离距离 $r$，还通过混合函数 $w(x)$ 依赖于该粒子对的绝对位置 $x$（例如，它们的质心）。有效势为\n$$\nU_{\\text{eff}}(x,r) = w(x)\\,U_{\\text{AT}}(r) + \\bigl(1 - w(x)\\bigr)\\,U_{\\text{CG}}(r).\n$$\n由该势产生的沿 $x$ 方向的力分量可通过对 $U_{\\text{eff}}(x,r)$ 关于 $x$ 求导得到。项 $U_{\\text{AT}}(r)$ 和 $U_{\\text{CG}}(r)$ 仅依赖于分离距离 $r$，而 $r$ 与绝对位置 $x$ 无关。因此，当我们对 $x$ 应用偏导数时，我们对 $w(x)$ 使用链式法则：\n$$\nF_x = -\\frac{\\partial}{\\partial x} \\left[ w(x)\\,U_{\\text{AT}}(r) + U_{\\text{CG}}(r) - w(x)\\,U_{\\text{CG}}(r) \\right].\n$$\n$$\nF_x = -\\left[ \\frac{dw(x)}{dx}\\,U_{\\text{AT}}(r) - \\frac{dw(x)}{dx}\\,U_{\\text{CG}}(r) \\right].\n$$\n这可以被因式分解，得到所谓的“热力学力”的表达式，也就是问题中提到的“引起不连续性的力”：\n$$\nF_{\\text{th}}(x,r) = -\\frac{dw(x)}{dx} \\left[ U_{\\text{AT}}(r) - U_{\\text{CG}}(r) \\right].\n$$\n问题要求我们找到最小的 $L_{h}$，以确保这个力的最大值 $|F_{\\text{th}}(x,r)|_{\\text{max}}$ 不超过阈值 $F_{\\text{thr}}$。最大值由下式给出\n$$\n|F_{\\text{th}}(x,r)|_{\\text{max}} = \\max_{x,r} \\left| -\\frac{dw(x)}{dx} \\left[ U_{\\text{AT}}(r) - U_{\\text{CG}}(r) \\right] \\right| = \\max_x \\left| \\frac{dw(x)}{dx} \\right| \\cdot \\max_r \\left| U_{\\text{AT}}(r) - U_{\\text{CG}}(r) \\right|.\n$$\n问题指定了一个最坏情况，即分离距离固定为 $r = r_m = 2^{1/6}\\sigma$，位置 $x$ 处于 $w(x)$ 梯度最大的地方。因此，我们需要在这些特定条件下评估这两项。\n\n首先，我们评估在 $r = r_m$ 处的势能差。我们已知：\n$U_{\\text{AT}}(r_m) = -\\varepsilon$。\n对于 $r \\le r_c = 2^{1/6}\\sigma$，粗粒化势定义为 $U_{\\text{CG}}(r) = U_{\\text{AT}}(r) + \\varepsilon$。由于 $r_m = r_c$，我们有：\n$U_{\\text{CG}}(r_m) = U_{\\text{AT}}(r_m) + \\varepsilon = -\\varepsilon + \\varepsilon = 0$。\n因此，势能差为：\n$U_{\\text{AT}}(r_m) - U_{\\text{CG}}(r_m) = -\\varepsilon - 0 = -\\varepsilon$。\n这个差的绝对值为 $|-\\varepsilon| = \\varepsilon$。\n\n其次，我们必须找到混合函数梯度的最大值，即 $\\left| \\frac{dw(x)}{dx} \\right|$。在混合区域内部（$0  x  L_h$），混合函数为\n$$\nw(x) = \\sin^{2}\\!\\left(\\dfrac{\\pi x}{2 L_{h}}\\right).\n$$\n它对 $x$ 的导数是：\n$$\n\\frac{dw}{dx} = \\frac{d}{dx} \\left[ \\sin^{2}\\!\\left(\\dfrac{\\pi x}{2 L_{h}}\\right) \\right] = 2\\sin\\left(\\dfrac{\\pi x}{2 L_{h}}\\right)\\cos\\left(\\dfrac{\\pi x}{2 L_{h}}\\right) \\cdot \\frac{\\pi}{2 L_{h}}.\n$$\n使用三角恒等式 $\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)$，我们将导数简化为：\n$$\n\\frac{dw}{dx} = \\frac{\\pi}{2 L_{h}} \\sin\\left(\\frac{\\pi x}{L_{h}}\\right).\n$$\n为了找到这个导数在区间 $x \\in (0, L_h)$ 内的最大值，我们找到正弦函数取最大值的位置。函数 $\\sin(\\theta)$ 的最大值为 $1$。这发生在它的参数为 $\\theta = \\frac{\\pi}{2}$ 时。在这里，参数是 $\\frac{\\pi x}{L_{h}}$，所以最大值发生在：\n$$\n\\frac{\\pi x}{L_{h}} = \\frac{\\pi}{2} \\implies x = \\frac{L_{h}}{2}.\n$$\n这个位置正好在混合区域的中间，这与问题的假设一致。梯度大小的最大值为：\n$$\n\\max_{x \\in (0, L_h)} \\left| \\frac{dw}{dx} \\right| = \\left| \\frac{\\pi}{2 L_{h}} \\sin\\left(\\frac{\\pi}{2}\\right) \\right| = \\frac{\\pi}{2 L_{h}}.\n$$\n现在我们可以整合出力的最大值的表达式：\n$$\n|F_{\\text{th}}|_{\\text{max}} = \\left( \\frac{\\pi}{2 L_{h}} \\right) \\cdot \\varepsilon.\n$$\n问题要求这个最大力不超过阈值 $F_{\\text{thr}}$。最小宽度 $L_h$ 对应于等式：\n$$\n|F_{\\text{th}}|_{\\text{max}} = F_{\\text{thr}} \\implies \\frac{\\pi \\varepsilon}{2 L_{h}} = F_{\\text{thr}}.\n$$\n求解 $L_h$，我们得到：\n$$\nL_{h} = \\frac{\\pi \\varepsilon}{2 F_{\\text{thr}}}.\n$$\n为了计算数值，我们必须确保所有单位一致。能量 $\\varepsilon = 2.0\\,\\text{kJ/mol}$ 是一个摩尔量。我们必须使用阿伏伽德罗常数 $N_A = 6.02214076 \\times 10^{23}\\,\\text{mol}^{-1}$ 将其转换为每个粒子的能量，单位为焦耳。\n$$\n\\varepsilon_{\\text{particle}} = \\frac{2.0\\,\\text{kJ/mol} \\times 1000\\,\\text{J/kJ}}{6.02214076 \\times 10^{23}\\,\\text{mol}^{-1}} = \\frac{2.0 \\times 10^3}{6.02214076 \\times 10^{23}}\\,\\text{J}.\n$$\n力的阈值给出为 $F_{\\text{thr}} = 1.0 \\times 10^{-11}\\,\\text{N}$。将这些值代入 $L_h$ 的表达式中：\n$$\nL_{h} = \\frac{\\pi \\cdot \\left(\\dfrac{2.0 \\times 10^3}{6.02214076 \\times 10^{23}}\\right)\\,\\text{J}}{2 \\cdot (1.0 \\times 10^{-11}\\,\\text{N})}.\n$$\n单位是焦耳每牛顿 ($\\text{J}/\\text{N}$)，这等价于米 ($\\text{m}$)，因为 $1\\,\\text{J} = 1\\,\\text{N}\\cdot\\text{m}$。\n$$\nL_{h} = \\frac{\\pi \\cdot 2.0 \\times 10^3}{2 \\cdot 1.0 \\times 10^{-11} \\cdot 6.02214076 \\times 10^{23}}\\,\\text{m}.\n$$\n$$\nL_{h} = \\frac{\\pi \\times 10^3}{6.02214076 \\times 10^{(23-11)}}\\,\\text{m} = \\frac{\\pi \\times 10^3}{6.02214076 \\times 10^{12}}\\,\\text{m}.\n$$\n$$\nL_{h} = \\frac{\\pi}{6.02214076 \\times 10^9}\\,\\text{m} \\approx 0.5216719 \\times 10^{-9}\\,\\text{m}.\n$$\n问题要求以纳米（$1\\,\\text{nm} = 10^{-9}\\,\\text{m}$）为单位给出结果。\n$$\nL_{h} \\approx 0.5216719\\,\\text{nm}.\n$$\n最后，将结果四舍五入到四位有效数字，得到：\n$$\nL_{h} \\approx 0.5217\\,\\text{nm}.\n$$",
            "answer": "$$\\boxed{0.5217}$$"
        },
        {
            "introduction": "在实际应用中，热力学力的作用不仅仅是估算，更需要主动地被精确确定，以在整个模拟盒子中强制实现期望的宏观性质，例如恒定的密度分布。这项动手编程练习要求您实现一种标准的迭代校正算法，用于数值化地计算该力的空间分布。您将把力学平衡的物理原理转化为有限差分格式，从而在统计力学理论和实际计算实现之间建立直接联系 。",
            "id": "3790145",
            "problem": "在自适应分辨率模拟 (AdResS) 中，一个一维混合区域被离散化为一个间距为 $\\Delta x$ 的均匀点网格。设第 $n$ 次迭代时测得的数密度分布为 $\\rho^{(n)}(x)$，参考均匀数密度为 $\\rho_0$。对于偏离 $\\rho_0$ 的小偏差和等温条件，力学平衡要求压力梯度被一个与位置相关的体力所平衡，该体力作为作用在粒子上的热力学力来实现。等温压缩率 $\\kappa_T$ 将压力变化与围绕 $\\rho_0$ 的密度变化联系起来。从这些原理出发，使用网格上密度梯度的二阶精确有限差分近似和一个参数为 $\\alpha \\in (0,1]$ 的欠松弛方案，推导热力学力场 $f_{\\mathrm{th}}^{(n+1)}(x)$ 的一致离散更新，并应用指定的边界条件之一。除已陈述的基本定律外，不要假设任何捷径。你的程序必须为每个提供的测试用例实现此更新，并返回网格点上下一次迭代的热力学力值。\n\n需使用的定义和约束：\n- 自适应分辨率模拟 (AdResS) 框架通过施加于粒子的热力学力场 $f_{\\mathrm{th}}(x)$ 在混合区域中强制实现力学平衡。\n- 在一维空间中，力学平衡要求 $\\partial_x p(x) + \\rho(x) f_{\\mathrm{th}}(x) = 0$，其中 $p(x)$ 是压力，$\\rho(x)$ 是数密度。\n- 对于偏离 $\\rho_0$ 的小偏差，恒温下的线性化状态方程使用定义为 $\\kappa_T = \\frac{1}{\\rho}\\left(\\frac{\\partial \\rho}{\\partial p}\\right)_T$ 的等温压缩率，将 $\\partial_x p(x)$ 与 $\\rho_0$ 附近的 $\\partial_x \\rho(x)$ 联系起来。\n- 离散化：在均匀网格上使用 $\\partial_x \\rho(x)$ 的二阶精确有限差分近似。对于内部点，使用中心差分。对于边界点，使用单边二阶精确差分。\n- 欠松弛：通过将前一次迭代 $f_{\\mathrm{th}}^{(n)}(x_i)$ 与基于测得的密度梯度使用混合因子 $\\alpha$ 的新估计值混合，来更新力 $f_{\\mathrm{th}}^{(n+1)}(x_i)$。\n- 更新后应用的边界条件：\n  - 狄利克雷 (Dirichlet)：将域两端的 $f_{\\mathrm{th}}^{(n+1)}$ 设置为 $0$。\n  - 诺伊曼 (Neumann)：将域两端的 $\\partial_x f_{\\mathrm{th}}^{(n+1)}$ 设置为 0，通过将相邻内部值复制到边界来实现。\n\n单位：\n- 数密度 $\\rho$ 必须以 $\\mathrm{m}^{-3}$ 为单位。\n- 间距 $\\Delta x$ 必须以 $\\mathrm{m}$ 为单位。\n- 等温压缩率 $\\kappa_T$ 必须以 $\\mathrm{Pa}^{-1}$ 为单位。\n- 热力学力 $f_{\\mathrm{th}}$ 必须表示为每个网格点上每个粒子的牛顿数（$\\mathrm{N}$）。\n\n您的程序必须在没有外部输入的情况下实现该算法，并为每个测试用例生成单行输出，结果为浮点数列表的列表（单位为 $\\mathrm{N}$），使用 Python 默认的浮点字符串格式，并聚合成一个用方括号括起来、用逗号分隔的列表（例如 $\\left[\\text{case}_1,\\text{case}_2,\\dots\\right]$）。每个测试用例必须独立处理。\n\n测试套件：\n- 用例1（理想情况）：\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$，\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$，\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$，\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 1.00,\\ \\rho_0\\times 1.02,\\ \\rho_0\\times 1.05,\\ \\rho_0\\times 1.02,\\ \\rho_0\\times 1.00\\right]$，\n  - $\\alpha = 0.8$，\n  - 边界条件：狄利克雷，\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$。\n- 用例2（均匀密度，边界检查）：\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$，\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$，\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$，\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 1.00,\\ \\rho_0\\times 1.00,\\ \\rho_0\\times 1.00,\\ \\rho_0\\times 1.00,\\ \\rho_0\\times 1.00\\right]$，\n  - $\\alpha = 1.0$，\n  - 边界条件：狄利克雷，\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$。\n- 用例3（诺伊曼边界下的阶跃变化）：\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$，\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$，\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$，\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 0.95,\\ \\rho_0\\times 0.95,\\ \\rho_0\\times 1.10,\\ \\rho_0\\times 1.10,\\ \\rho_0\\times 1.10\\right]$，\n  - $\\alpha = 0.5$，\n  - 边界条件：诺伊曼，\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$。\n- 用例4（诺伊曼边界下的非单调小波动）：\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$，\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$，\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$，\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 1.00,\\ \\rho_0\\times 0.98,\\ \\rho_0\\times 1.02,\\ \\rho_0\\times 1.01,\\ \\rho_0\\times 0.99,\\ \\rho_0\\times 1.00\\right]$，\n  - $\\alpha = 0.7$，\n  - 边界条件：诺伊曼，\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是一个列表，包含相应测试用例的下一次迭代力值（例如 $\\left[[f_{1,1},\\dots,f_{1,N_1}],[f_{2,1},\\dots,f_{2,N_2}],\\dots\\right]$），单位为每个粒子 $\\mathrm{N}$。",
            "solution": "用户希望一位严谨细致的STEM教授来解决一个物理问题。我将首先验证问题陈述。\n\n### 第1步：问题验证\n\n该问题要求推导并实现自适应分辨率模拟 (AdResS) 中热力学力的数值更新规则。\n\n#### 提取的已知条件\n- **框架**：AdResS 中的一维混合区域。\n- **网格**：间距为 $\\Delta x$ 的均匀网格。\n- **状态变量**：第 $n$ 次迭代的数密度为 $\\rho^{(n)}(x)$，参考均匀数密度为 $\\rho_0$。\n- **物理定律**：力学平衡由 $\\partial_x p(x) + \\rho(x) f_{\\mathrm{th}}(x) = 0$ 给出，其中 $p(x)$ 是压力， $f_{\\mathrm{th}}(x)$ 是热力学力。\n- **状态方程**：对于等温条件下的小密度偏差，等温压缩率为 $\\kappa_T = \\frac{1}{\\rho}\\left(\\frac{\\partial \\rho}{\\partial p}\\right)_T$。\n- **数值方案**：\n    1.  **梯度近似**：使用二阶精确有限差分方案近似 $\\partial_x \\rho(x)$。\n        - 内部点：中心差分。\n        - 边界点：单边差分。\n    2.  **迭代更新**：使用混合参数为 $\\alpha \\in (0,1]$ 的欠松弛方案更新力：$f_{\\mathrm{th}}^{(n+1)}(x_i)$ 是 $f_{\\mathrm{th}}^{(n)}(x_i)$ 和从 $\\rho^{(n)}(x)$ 推导出的新估计值的混合。\n- **边界条件 (BCs)**：更新后应用。\n    - **狄利克雷 (Dirichlet)**：两端 $f_{\\mathrm{th}}^{(n+1)} = 0$。\n    - **诺伊曼 (Neumann)**：两端 $\\partial_x f_{\\mathrm{th}}^{(n+1)} = 0$，通过将边界值设置为相邻内部值来实现。\n- **单位**：$\\rho$ 单位为 $\\mathrm{m}^{-3}$，$\\Delta x$ 单位为 $\\mathrm{m}$，$\\kappa_T$ 单位为 $\\mathrm{Pa}^{-1}$， $f_{\\mathrm{th}}$ 单位为 $\\mathrm{N}$。\n- **测试用例**：提供了四个具体的测试用例，包含所有必要的数值和参数。\n\n#### 对照标准进行验证\n- **科学依据**：该问题基于统计力学和流体动力学的基本原理，特别是力学平衡条件（$\\nabla p = -\\rho \\mathbf{F}_{\\text{body}}$）和等温压缩率的定义。AdResS 方法是多尺度材料模拟中的一种标准技术。该问题在科学上是合理的。\n- **良构性**：该问题是良构的。它提供了一个清晰的初始状态（$f_{\\mathrm{th}}^{(n)}$，$\\rho^{(n)}$）和一套确定性的规则来计算下一个状态（$f_{\\mathrm{th}}^{(n+1)}$）。所提供的信息充分且自洽，确保每个测试用例都存在唯一解。\n- **客观性**：该问题以精确、客观的语言陈述。所有术语都有数学或程序上的定义。没有主观或基于意见的陈述。\n\n#### 结论\n该问题是有效的。这是一个计算物理学中明确定义的任务，要求从第一性原理推导算法并进行数值实现。\n\n### 第2步：推导与算法设计\n\n目标是推导热力学力 $f_{\\mathrm{th}}^{(n+1)}(x_i)$ 的离散更新规则。\n\n#### 基于原理的推导\n1.  **从压力梯度求力**：一维力学平衡的条件是：\n    $$\n    \\frac{\\partial p(x)}{\\partial x} + \\rho(x) f_{\\mathrm{th}}(x) = 0\n    $$\n    求解热力学力 $f_{\\mathrm{th}}(x)$ 得：\n    $$\n    f_{\\mathrm{th}}(x) = -\\frac{1}{\\rho(x)} \\frac{\\partial p(x)}{\\partial x}\n    $$\n    问题指定我们考虑密度 $\\rho(x)$ 相对于参考密度 $\\rho_0$ 的小偏差。因此，用 $\\rho_0$ 替换分母中的 $\\rho(x)$ 是一个一致的近似：\n    $$\n    f_{\\mathrm{th}}(x) \\approx -\\frac{1}{\\rho_0} \\frac{\\partial p(x)}{\\partial x}\n    $$\n\n2.  **从密度梯度求压力梯度**：等温压缩率 $\\kappa_T$ 定义为 $\\kappa_T = \\frac{1}{\\rho} \\left(\\frac{\\partial \\rho}{\\partial p}\\right)_T$。我们可以重新排列这个式子来表示压力随密度的变化：\n    $$\n    \\left(\\frac{\\partial p}{\\partial \\rho}\\right)_T = \\frac{1}{\\rho \\kappa_T}\n    $$\n    使用链式法则，压力梯度可以与密度梯度相关联：\n    $$\n    \\frac{\\partial p(x)}{\\partial x} = \\left(\\frac{\\partial p}{\\partial \\rho}\\right)_T \\frac{\\partial \\rho(x)}{\\partial x}\n    $$\n    对于参考状态 $(\\rho_0, p_0)$ 附近的小偏差，我们在 $\\rho_0$ 处评估导数项：\n    $$\n    \\frac{\\partial p(x)}{\\partial x} \\approx \\frac{1}{\\rho_0 \\kappa_T} \\frac{\\partial \\rho(x)}{\\partial x}\n    $$\n\n3.  **目标力表达式**：通过将压力梯度的表达式代入力表达式，我们得到“目标”热力学力，记为 $f_{\\text{target}}(x)$，它将完美平衡由密度分布 $\\rho(x)$ 产生的力：\n    $$\n    f_{\\text{target}}(x) = -\\frac{1}{\\rho_0} \\left( \\frac{1}{\\rho_0 \\kappa_T} \\frac{\\partial \\rho(x)}{\\partial x} \\right) = -\\frac{1}{\\rho_0^2 \\kappa_T} \\frac{\\partial \\rho(x)}{\\partial x}\n    $$\n    在第 $n$ 次迭代，目标力使用测得的密度分布 $\\rho^{(n)}(x)$ 计算：\n    $$\n    f_{\\text{target}}^{(n)}(x) = -\\frac{1}{\\rho_0^2 \\kappa_T} \\frac{\\partial \\rho^{(n)}(x)}{\\partial x}\n    $$\n\n4.  **密度梯度的离散化**：连续函数 $\\rho^{(n)}(x)$ 仅在离散网格点 $x_i$ 上已知，其值为 $\\rho_i^{(n)}$。我们必须使用二阶精确的有限差分公式在每个网格点 $x_i$ 处近似导数 $\\frac{\\partial \\rho^{(n)}(x)}{\\partial x}$。对于一个包含 $N$ 个点（索引为 $i=0, 1, \\dots, N-1$）的网格：\n    -   **内部点 ($1 \\le i \\le N-2$)**：使用二阶中心差分公式：\n        $$\n        \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_i = \\frac{\\rho_{i+1}^{(n)} - \\rho_{i-1}^{(n)}}{2 \\Delta x}\n        $$\n    -   **左边界点 ($i=0$)**：使用二阶向前差分公式：\n        $$\n        \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_0 = \\frac{-3\\rho_0^{(n)} + 4\\rho_1^{(n)} - \\rho_2^{(n)}}{2 \\Delta x}\n        $$\n    -   **右边界点 ($i=N-1$)**：使用二阶向后差分公式：\n        $$\n        \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_{N-1} = \\frac{3\\rho_{N-1}^{(n)} - 4\\rho_{N-2}^{(n)} + \\rho_{N-3}^{(n)}}{2 \\Delta x}\n        $$\n\n5.  **欠松弛更新规则**：下一次迭代的力 $f_{\\mathrm{th}}^{(n+1)}$ 是通过使用松弛参数 $\\alpha$ 将当前力 $f_{\\mathrm{th}}^{(n)}$ 与计算出的目标力 $f_{\\text{target}}^{(n)}$ 混合得到的：\n    $$\n    f_{\\mathrm{th}, i}^{(n+1)} = (1-\\alpha) f_{\\mathrm{th}, i}^{(n)} + \\alpha f_{\\text{target}, i}^{(n)}\n    $$\n    代入离散目标力的表达式，每个网格点 $i$ 的完整更新规则是：\n    $$\n    f_{\\mathrm{th}, i}^{(n+1)} = (1-\\alpha) f_{\\mathrm{th}, i}^{(n)} - \\frac{\\alpha}{\\rho_0^2 \\kappa_T} \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_i\n    $$\n    让我们将使用此规则计算的力场表示为 $\\tilde{f}_{\\mathrm{th}}^{(n+1)}$。\n\n6.  **边界条件的应用**：最后一步是将指定的边界条件应用于计算出的力场 $\\tilde{f}_{\\mathrm{th}}^{(n+1)}$ 以获得最终的 $f_{\\mathrm{th}}^{(n+1)}$。\n    -   **狄利克雷边界条件 (Dirichlet BC)**：边界处的力设置为零。\n        $$\n        f_{\\mathrm{th}, 0}^{(n+1)} = 0\n        $$\n        $$\n        f_{\\mathrm{th}, N-1}^{(n+1)} = 0\n        $$\n        内部点保持不变：$f_{\\mathrm{th}, i}^{(n+1)} = \\tilde{f}_{\\mathrm{th}, i}^{(n+1)}$ 对于 $1 \\le i \\le N-2$。\n    -   **诺伊曼边界条件 (Neumann BC)**：力的导数设置为零，通过从相邻内部点复制值来实现。\n        $$\n        f_{\\mathrm{th}, 0}^{(n+1)} = \\tilde{f}_{\\mathrm{th}, 1}^{(n+1)}\n        $$\n        $$\n        f_{\\mathrm{th}, N-1}^{(n+1)} = \\tilde{f}_{\\mathrm{th}, N-2}^{(n+1)}\n        $$\n        内部点保持不变。\n\n这就完成了待实现算法的推导。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the next-iteration thermodynamic force in an AdResS simulation.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"rho_0\": 3.343e28,  # m^-3\n            \"kappa_T\": 4.5e-10,  # Pa^-1\n            \"delta_x\": 5.0e-10,  # m\n            \"rho_n_factors\": [1.00, 1.02, 1.05, 1.02, 1.00],\n            \"alpha\": 0.8,\n            \"bc_type\": \"Dirichlet\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0],  # N\n        },\n        {\n            \"rho_0\": 3.343e28,\n            \"kappa_T\": 4.5e-10,\n            \"delta_x\": 5.0e-10,\n            \"rho_n_factors\": [1.00, 1.00, 1.00, 1.00, 1.00],\n            \"alpha\": 1.0,\n            \"bc_type\": \"Dirichlet\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n        {\n            \"rho_0\": 3.343e28,\n            \"kappa_T\": 4.5e-10,\n            \"delta_x\": 5.0e-10,\n            \"rho_n_factors\": [0.95, 0.95, 1.10, 1.10, 1.10],\n            \"alpha\": 0.5,\n            \"bc_type\": \"Neumann\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n        {\n            \"rho_0\": 3.343e28,\n            \"kappa_T\": 4.5e-10,\n            \"delta_x\": 5.0e-10,\n            \"rho_n_factors\": [1.00, 0.98, 1.02, 1.01, 0.99, 1.00],\n            \"alpha\": 0.7,\n            \"bc_type\": \"Neumann\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        rho_0 = case[\"rho_0\"]\n        kappa_T = case[\"kappa_T\"]\n        delta_x = case[\"delta_x\"]\n        alpha = case[\"alpha\"]\n        bc_type = case[\"bc_type\"]\n\n        rho_n = np.array(case[\"rho_n_factors\"]) * rho_0\n        f_th_n = np.array(case[\"f_th_n\"])\n        \n        N = len(rho_n)\n        grad_rho = np.zeros(N)\n\n        # Calculate second-order accurate finite differences for the density gradient\n        if N >= 3:\n            # Left boundary (i=0): second-order forward difference\n            grad_rho[0] = (-3 * rho_n[0] + 4 * rho_n[1] - rho_n[2]) / (2 * delta_x)\n            \n            # Right boundary (i=N-1): second-order backward difference\n            grad_rho[N-1] = (3 * rho_n[N-1] - 4 * rho_n[N-2] + rho_n[N-3]) / (2 * delta_x)\n\n            # Interior points: second-order centered difference\n            for i in range(1, N - 1):\n                grad_rho[i] = (rho_n[i+1] - rho_n[i-1]) / (2 * delta_x)\n        else:\n            # For N3, second-order stencils are not defined.\n            # The test cases all have N>=5, so this branch is not taken.\n            pass\n\n        # Calculate the target force based on the density gradient\n        # f_target = - (1 / (rho_0^2 * kappa_T)) * grad_rho\n        prefactor = -1.0 / (rho_0**2 * kappa_T)\n        f_target = prefactor * grad_rho\n\n        # Apply the under-relaxation update rule\n        # f_th_next = (1 - alpha) * f_th_n + alpha * f_target\n        f_th_next = (1.0 - alpha) * f_th_n + alpha * f_target\n\n        # Apply boundary conditions to the updated force field\n        if bc_type == \"Dirichlet\":\n            f_th_next[0] = 0.0\n            f_th_next[N-1] = 0.0\n        elif bc_type == \"Neumann\":\n            if N >= 2:\n                f_th_next[0] = f_th_next[1]\n                f_th_next[N-1] = f_th_next[N-2]\n        \n        results.append(f_th_next.tolist())\n\n    # Format output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一次成功的多尺度模拟需要在精度和计算开销之间取得审慎的平衡。这最后一个练习将让您扮演计算科学家的角色，设计一个最优化的模拟实验。您必须选择一个既能满足给定精度容差，又能实现最低计算成本的混合区域宽度。通过使用基于物理动机的误差和成本模型，您将探索在建立高效、可靠的自适应分辨率模拟时所固有的关键权衡 。",
            "id": "3790123",
            "problem": "在自适应分辨率分子模拟中，一种自适应分辨率模拟 (AdResS) 方法将一个边长为 $L$ 的周期性立方域沿单个笛卡尔轴划分为三个连续的板层：一个长度为 $L_{\\mathrm{A}}$ 的原子区域核心，两个宽度均为 $w$ 的混合过渡板层，以及余下的外部粗粒化区域。对于一个在约化 Lennard-Jones 单位下数密度为 $\\rho$ 的均匀液体，假设存在以下基于牛顿力学和平衡统计力学、具有科学依据且被广泛使用的建模假说：\n\n- 每个时间步的计算成本与自由度数量成线性关系。通过每个区域中单个粒子的成本来近似这种正比关系，总成本可建模为\n$$\nC(w) = c_{\\mathrm{A}} N_{\\mathrm{A}} + c_{\\mathrm{H}} N_{\\mathrm{H}} + c_{\\mathrm{C}} N_{\\mathrm{C}},\n$$\n其中，$N_{\\mathrm{A}} = \\rho V_{\\mathrm{A}}$、$N_{\\mathrm{H}} = \\rho V_{\\mathrm{H}}$ 和 $N_{\\mathrm{C}} = \\rho V_{\\mathrm{C}}$ 是由体积 $V_{\\mathrm{A}} = L_{\\mathrm{A}} L^2$、$V_{\\mathrm{H}} = 2 w L^2$ 和 $V_{\\mathrm{C}} = L^3 - V_{\\mathrm{A}} - V_{\\mathrm{H}}$ 决定的粒子数。\n- 由混合插值引起的原子级可观测量中的结构误差，会随着混合宽度 $w$ 在一个液体相关长度 $\\xi$ 上衰减，这与线性响应理论一致。我们将此贡献建模为\n$$\nE_{\\mathrm{g}}(w) = E_0 \\exp\\!\\left(-\\frac{w}{\\xi}\\right).\n$$\n- 由有限的粗粒化厚度 $L_{\\mathrm{C}}(w) = L - L_{\\mathrm{A}} - 2 w$ 引起的有限区域误差会随着 $L_{\\mathrm{C}}$ 在一个粗粒化区域相关长度 $\\lambda$ 上指数衰减，这反映了对扰动的屏蔽效应：\n$$\nE_{\\mathrm{fs}}(w) = B \\exp\\!\\left(-\\frac{L_{\\mathrm{C}}(w)}{\\lambda}\\right).\n$$\n- 总精度损失保守地近似为以下各项之和\n$$\nE_{\\mathrm{tot}}(w) = E_{\\mathrm{g}}(w) + E_{\\mathrm{fs}}(w).\n$$\n\n对于每个提供的测试用例，您的程序必须在一系列候选宽度上评估 $C(w)$ 和 $E_{\\mathrm{tot}}(w)$，然后根据以下规则推荐一个唯一的最佳宽度：\n\n- 主要可行性规则：在所有满足 $E_{\\mathrm{tot}}(w) \\le \\tau$（给定容差）的 $w$ 中，选择使 $C(w)$ 最小的那个。如果多个宽度的 $C(w)$ 值在 $10^{-12}$ 的绝对差范围内相同，则选择较小的 $w$。\n- 如果没有宽度满足 $E_{\\mathrm{tot}}(w) \\le \\tau$，则选择使 $E_{\\mathrm{tot}}(w)$ 最小化的 $w$。如果 $E_{\\mathrm{tot}}(w)$ 的值在 $10^{-12}$ 的绝对差范围内出现平局，则选择使 $C(w)$ 最小的那个；如果仍然平局，则选择较小的 $w$。\n\n所有量均为无量纲的约化单位。每个测试用例的输出必须是三元组 $[w^\\star, C(w^\\star), E_{\\mathrm{tot}}(w^\\star)]$，其中每个浮点数四舍五入到 $6$ 位小数。\n\n测试套件。对于以下每个案例，候选宽度满足 $2 w + L_{\\mathrm{A}} \\le L$，以确保粗粒化区域具有非负厚度。您的程序必须为每个案例计算出最佳三元组，并按顺序打印一行包含这些三元组的列表，不得包含额外文本。\n\n- 案例 A (理想情况，存在多个可行宽度):\n    - $L = 10$, $L_{\\mathrm{A}} = 4$, $\\rho = 0.8$\n    - 成本: $c_{\\mathrm{A}} = 5$, $c_{\\mathrm{H}} = 7$, $c_{\\mathrm{C}} = 1$\n    - 误差参数: $E_0 = 0.12$, $B = 0.08$, $\\xi = 1.0$, $\\lambda = 1.0$\n    - 容差: $\\tau = 0.05$\n    - 候选: $w \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$\n- 案例 B (严格容差，无可行宽度):\n    - $L = 10$, $L_{\\mathrm{A}} = 4$, $\\rho = 0.8$\n    - 成本: $c_{\\mathrm{A}} = 5$, $c_{\\mathrm{H}} = 7$, $c_{\\mathrm{C}} = 1$\n    - 误差参数: $E_0 = 0.12$, $B = 0.08$, $\\xi = 1.0$, $\\lambda = 1.0$\n    - 容差: $\\tau = 0.02$\n    - 候选: $w \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$\n- 案例 C (较小盒子，不同的液体和成本):\n    - $L = 8$, $L_{\\mathrm{A}} = 3$, $\\rho = 0.85$\n    - 成本: $c_{\\mathrm{A}} = 6$, $c_{\\mathrm{H}} = 8$, $c_{\\mathrm{C}} = 1$\n    - 误差参数: $E_0 = 0.15$, $B = 0.10$, $\\xi = 0.8$, $\\lambda = 0.8$\n    - 容差: $\\tau = 0.04$\n    - 候选: $w \\in \\{0.5, 1.0, 1.5, 2.0\\}$\n- 案例 D (较大盒子，长程结构，中等容差):\n    - $L = 12$, $L_{\\mathrm{A}} = 4$, $\\rho = 0.75$\n    - 成本: $c_{\\mathrm{A}} = 5$, $c_{\\mathrm{H}} = 7$, $c_{\\mathrm{C}} = 1$\n    - 误差参数: $E_0 = 0.10$, $B = 0.05$, $\\xi = 1.2$, $\\lambda = 1.5$\n    - 容差: $\\tau = 0.03$\n    - 候选: $w \\in \\{0.5, 1.0, 2.0, 3.0, 3.5\\}$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，每个内部列表是对应案例的最佳三元组，顺序与上面列出的一致。例如，一个语法正确的输出看起来像\n$[[w_1,C_1,E_1],[w_2,C_2,E_2],[w_3,C_3,E_3],[w_4,C_4,E_4]]$\n其中每个浮点数四舍五入到 $6$ 位小数，且没有额外的空白或文本。",
            "solution": "该问题经评估有效。它在科学上基于多尺度分子模拟的原理，特别是自适应分辨率模拟 (AdResS) 方法。所提供的计算成本和模拟误差模型是公认的、有物理动机的简化模型。该问题是良定的，具备所有必需的参数和清晰、无歧义的优化目标，包括平局打破规则，确保了对于每个测试用例，从给定的候选集合中存在唯一解。语言客观且正式。因此，我将继续提供完整的解决方案。\n\n问题的核心是从一组离散的候选中选择一个最佳的混合板层宽度 $w^\\star$。该选择基于计算成本 $C(w)$ 和总数值误差 $E_{\\mathrm{tot}}(w)$ 之间的权衡。\n\n首先，我们将成本和误差模型形式化为混合宽度 $w$ 的函数。系统是一个边长为 $L$、数密度为 $\\rho$ 的立方域。\n\n计算成本 $C(w)$ 由下式给出：\n$$\nC(w) = c_{\\mathrm{A}} N_{\\mathrm{A}} + c_{\\mathrm{H}} N_{\\mathrm{H}}(w) + c_{\\mathrm{C}} N_{\\mathrm{C}}(w)\n$$\n其中 $c_{\\mathrm{A}}$、$c_{\\mathrm{H}}$ 和 $c_{\\mathrm{C}}$ 分别是原子、混合和粗粒化区域中每个粒子的计算成本。每个区域中的粒子数 $N_i$ 是密度 $\\rho$ 与该区域体积 $V_i$ 的乘积。各区域体积为：\n- 原子区域体积 (恒定): $V_{\\mathrm{A}} = L_{\\mathrm{A}} L^2$\n- 混合区域体积 (依赖于 $w$): $V_{\\mathrm{H}}(w) = 2 w L^2$\n- 粗粒化区域体积 (依赖于 $w$): $V_{\\mathrm{C}}(w) = L^3 - V_{\\mathrm{A}} - V_{\\mathrm{H}}(w) = (L - L_{\\mathrm{A}} - 2w) L^2$\n\n将这些代入成本函数，得到一个关于 $w$ 的线性表达式：\n$$\nC(w) = c_{\\mathrm{A}} (\\rho L_{\\mathrm{A}} L^2) + c_{\\mathrm{H}} (\\rho 2w L^2) + c_{\\mathrm{C}} (\\rho (L - L_{\\mathrm{A}} - 2w) L^2)\n$$\n$$\nC(w) = \\rho L^2 \\left[ c_{\\mathrm{A}} L_{\\mathrm{A}} + c_{\\mathrm{C}}(L - L_{\\mathrm{A}}) \\right] + 2 \\rho L^2 (c_{\\mathrm{H}} - c_{\\mathrm{C}}) w\n$$\n这表明 $C(w)$ 随 $w$ 线性增加或减少，具体取决于 $(c_{\\mathrm{H}} - c_{\\mathrm{C}})$ 的符号。考虑到混合粒子的计算成本高于粗粒化粒子 ($c_{\\mathrm{H}}  c_{\\mathrm{C}}$)，成本 $C(w)$ 是 $w$ 的一个单调递增函数。\n\n总误差 $E_{\\mathrm{tot}}(w)$ 是两个部分的和：\n$$\nE_{\\mathrm{tot}}(w) = E_{\\mathrm{g}}(w) + E_{\\mathrm{fs}}(w)\n$$\n第一项 $E_{\\mathrm{g}}(w)$ 表示来自原子/粗粒化耦合的误差，该误差随过渡区域宽度 $w$ 指数衰减：\n$$\nE_{\\mathrm{g}}(w) = E_0 \\exp\\left(-\\frac{w}{\\xi}\\right)\n$$\n这里，$E_0$ 是误差幅度，$\\xi$ 是一个特征相关长度。\n\n第二项 $E_{\\mathrm{fs}}(w)$ 是由于粗粒化区域厚度有限 ($L_{\\mathrm{C}}(w) = L - L_{\\mathrm{A}} - 2w$) 而产生的有限尺寸误差。该误差也随着粗粒化区域厚度指数衰减：\n$$\nE_{\\mathrm{fs}}(w) = B \\exp\\left(-\\frac{L_{\\mathrm{C}}(w)}{\\lambda}\\right) = B \\exp\\left(-\\frac{L - L_{\\mathrm{A}} - 2w}{\\lambda}\\right)\n$$\n这里，$B$ 是误差幅度，$\\lambda$ 是一个粗粒化区域相关长度。该项可以重写以显示其对 $w$ 的显式依赖性：\n$$\nE_{\\mathrm{fs}}(w) = \\left( B \\exp\\left(-\\frac{L - L_{\\mathrm{A}}}{\\lambda}\\right) \\right) \\exp\\left(\\frac{2w}{\\lambda}\\right)\n$$\n这是 $w$ 的一个指数增长函数。总误差 $E_{\\mathrm{tot}}(w)$ 是一个指数衰减项和一个指数增长项之和，这通常会得到一个具有单一最小值的函数。\n\n优化过程遵循一个双层决策规则：\n\n1.  第一条规则 (可行性驱动)：识别“可行”宽度集合，定义为所有总误差不超过给定容差 $\\tau$ 的候选宽度 $\\{w_i\\}$，即 $E_{\\mathrm{tot}}(w_i) \\le \\tau$。\n    - 如果此可行集非空，则最佳宽度 $w^\\star$ 是该集合中使计算成本 $C(w_i)$ 最小化的那个。\n    - 指定了平局打破规则：如果多个可行宽度的成本在 $10^{-12}$ 的绝对差范围内相同，则选择宽度 $w$ 最小的那个。\n\n2.  第二条规则 (误差驱动)：如果没有候选宽度满足可行性条件 (即，可行集为空)，则目标转为最小化误差。\n    - 最佳宽度 $w^\\star$ 是所有候选中导致最小总误差 $E_{\\mathrm{tot}}(w_i)$ 的那个。\n    - 应用多级平局打破规则：如果多个宽度产生的最小误差在 $10^{-12}$ 的绝对差范围内相同，则选择计算成本 $C(w)$ 较低的那个。如果成本也平局 (在 $10^{-12}$ 范围内)，则选择较小的宽度 $w$。\n\n寻找最佳三元组 $[w^\\star, C(w^\\star), E_{\\mathrm{tot}}(w^\\star)]$ 的算法如下：\n对于每个测试用例：\n1.  对于给定列表中的每个候选宽度 $w$，使用模型方程和给定参数计算相应的成本 $C(w)$ 和总误差 $E_{\\mathrm{tot}}(w)$。将这些结果存储为数据结构的列表，每个结构包含 $(w, C, E)$。\n2.  将此列表分为两组：一个 `feasible` (可行) 组，其中 $E \\le \\tau$；以及一个 `infeasible` (不可行) 组。\n3.  如果 `feasible` 组不为空： a. 在 `feasible` 组的所有候选中找到最小成本 $C_{\\min}$。 b. 选择这些候选中的一个子集，其成本 $C$ 满足 $|C - C_{\\min}| \\le 10^{-12}$。 c. 从该子集中，选择具有最小宽度 $w$ 的候选者。这就是最优解。\n4.  如果 `feasible` 组为空： a. 在所有候选结果 (完整的原始列表) 中找到最小误差 $E_{\\min}$。 b. 选择一个候选子集，其误差 $E$ 满足 $|E - E_{\\min}| \\le 10^{-12}$。 c. 从这个误差平局的子集中，找到最小成本 $C'_{\\min}$。 d. 选择一个更小的子集，其成本 $C$ 满足 $|C - C'_{\\min}| \\le 10^{-12}$。 e. 从这个最终子集中，选择具有最小宽度 $w$ 的候选者。这就是最优解。\n5.  通过将每个浮点数四舍五入到 $6$ 位小数来格式化所得的最佳三元组 $[w^\\star, C(w^\\star), E_{\\mathrm{tot}}(w^\\star)]$。\n6.  将所有测试用例的格式化三元组收集到一个最终列表中。\n\n为所提供的四个测试用例中的每一个都实施了此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adaptive resolution simulation optimization problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"params\": {\n                \"L\": 10.0, \"LA\": 4.0, \"rho\": 0.8,\n                \"cA\": 5.0, \"cH\": 7.0, \"cC\": 1.0,\n                \"E0\": 0.12, \"B\": 0.08, \"xi\": 1.0, \"lambda_\": 1.0,\n                \"tau\": 0.05\n            },\n            \"candidates\": [0.5, 1.0, 1.5, 2.0, 2.5]\n        },\n        {\n            \"name\": \"Case B\",\n            \"params\": {\n                \"L\": 10.0, \"LA\": 4.0, \"rho\": 0.8,\n                \"cA\": 5.0, \"cH\": 7.0, \"cC\": 1.0,\n                \"E0\": 0.12, \"B\": 0.08, \"xi\": 1.0, \"lambda_\": 1.0,\n                \"tau\": 0.02\n            },\n            \"candidates\": [0.5, 1.0, 1.5, 2.0, 2.5]\n        },\n        {\n            \"name\": \"Case C\",\n            \"params\": {\n                \"L\": 8.0, \"LA\": 3.0, \"rho\": 0.85,\n                \"cA\": 6.0, \"cH\": 8.0, \"cC\": 1.0,\n                \"E0\": 0.15, \"B\": 0.10, \"xi\": 0.8, \"lambda_\": 0.8,\n                \"tau\": 0.04\n            },\n            \"candidates\": [0.5, 1.0, 1.5, 2.0]\n        },\n        {\n            \"name\": \"Case D\",\n            \"params\": {\n                \"L\": 12.0, \"LA\": 4.0, \"rho\": 0.75,\n                \"cA\": 5.0, \"cH\": 7.0, \"cC\": 1.0,\n                \"E0\": 0.10, \"B\": 0.05, \"xi\": 1.2, \"lambda_\": 1.5,\n                \"tau\": 0.03\n            },\n            \"candidates\": [0.5, 1.0, 2.0, 3.0, 3.5]\n        }\n    ]\n\n    all_results = []\n    \n    TOL = 1e-12 # Absolute tolerance for float comparisons\n\n    for case in test_cases:\n        params = case['params']\n        candidate_widths = case['candidates']\n        \n        metrics = []\n        for w in candidate_widths:\n            # Calculate cost\n            cost_const_term = params['rho'] * params['L']**2 * (params['cA'] * params['LA'] + params['cC'] * (params['L'] - params['LA']))\n            cost_w_term = 2 * params['rho'] * params['L']**2 * (params['cH'] - params['cC']) * w\n            cost = cost_const_term + cost_w_term\n\n            # Calculate error\n            LC = params['L'] - params['LA'] - 2 * w\n            Eg = params['E0'] * np.exp(-w / params['xi'])\n            Efs = params['B'] * np.exp(-LC / params['lambda_'])\n            error = Eg + Efs\n            \n            metrics.append({'w': w, 'cost': cost, 'error': error})\n\n        # Apply selection logic\n        feasible = [m for m in metrics if m['error'] = params['tau']]\n\n        if feasible:\n            # Primary Rule: Minimize cost from feasible set\n            min_cost = min(m['cost'] for m in feasible)\n            tied_cost_candidates = [m for m in feasible if abs(m['cost'] - min_cost) = TOL]\n            best_candidate = min(tied_cost_candidates, key=lambda m: m['w'])\n        else:\n            # Secondary Rule: Minimize error from all candidates\n            min_error = min(m['error'] for m in metrics)\n            tied_error_candidates = [m for m in metrics if abs(m['error'] - min_error) = TOL]\n            \n            min_cost_in_tie = min(m['cost'] for m in tied_error_candidates)\n            tied_cost_candidates = [m for m in tied_error_candidates if abs(m['cost'] - min_cost_in_tie) = TOL]\n\n            best_candidate = min(tied_cost_candidates, key=lambda m: m['w'])\n            \n        w_star = best_candidate['w']\n        c_star = best_candidate['cost']\n        e_star = best_candidate['error']\n        \n        # Format result triple with 6 decimal places\n        w_str = f\"{round(w_star, 6):.6f}\"\n        c_str = f\"{round(c_star, 6):.6f}\"\n        e_str = f\"{round(e_star, 6):.6f}\"\n        \n        all_results.append(f\"[{w_str},{c_str},{e_str}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}