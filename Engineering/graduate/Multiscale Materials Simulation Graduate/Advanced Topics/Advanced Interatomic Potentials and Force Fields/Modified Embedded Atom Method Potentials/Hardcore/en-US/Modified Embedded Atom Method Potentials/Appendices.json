{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Embedded Atom Method is the concept that each atom is \"embedded\" in a background electron density created by its neighbors. This first practice provides a direct, hands-on calculation of this fundamental quantity for the highly symmetric face-centered cubic (fcc) crystal structure. By focusing on nearest-neighbor contributions, this exercise solidifies the connection between a material's atomic geometry and the primary input to its embedding energy .",
            "id": "3782223",
            "problem": "Consider a perfect monatomic face-centered cubic (fcc) crystal with lattice parameter $a$ at zero temperature. In the Modified Embedded Atom Method (MEAM), the embedding energy of an atom at site $i$ is expressed as a function of a background electron density $\\rho_i$ at that site, which is constructed from contributions of neighboring atoms. Assume the following physically standard conditions:\n\n- The atomic electron density associated with a single isolated atom is spherically symmetric and strictly radially decaying, denoted $\\rho_a(r)$, where $r$ is the scalar separation from the atom.\n- The environment is an ideal fcc lattice without defects or occlusion, so the screening of neighbor contributions is complete and equal to unity, and the spatial symmetry is cubic.\n- Only the nearest-neighbor shell is to be included in the construction of $\\rho_i$, and angular-dependent contributions can be neglected based on the cubic symmetry and the spherically symmetric form of $\\rho_a(r)$.\n\nStarting from the core MEAM concept that the background electron density $\\rho_i$ at site $i$ is constructed by summing spherically symmetric atomic electron density contributions from neighboring atoms, compute the closed-form analytic expression for $\\rho_i$ in terms of $a$ and $\\rho_a(r)$ by using only the nearest-neighbor shell of the fcc lattice. Your final answer must be a single closed-form analytic expression. No numerical approximation is required, and no units need to be reported.",
            "solution": "The problem asks for a closed-form analytic expression for the background electron density, $\\rho_i$, at an atomic site $i$ within a perfect face-centered cubic (fcc) crystal. The calculation is to be performed under the framework of the Modified Embedded Atom Method (MEAM), simplified to include only contributions from the nearest-neighbor shell and neglecting angular-dependent terms.\n\nAccording to the problem statement, the background electron density $\\rho_i$ at site $i$ is constructed by the linear superposition of spherically symmetric atomic electron density contributions, $\\rho_a(r)$, from its neighboring atoms. Given the instruction to consider only the nearest-neighbor shell, the expression for $\\rho_i$ is:\n$$\n\\rho_i = \\sum_{j \\in \\text{NN}(i)} \\rho_a(r_{ij})\n$$\nwhere $\\text{NN}(i)$ is the set of nearest neighbors to atom $i$, and $r_{ij}$ is the distance between atom $i$ and its neighbor $j$.\n\nFor a perfect crystal structure, every atom is in an identical environment. Therefore, we can place our reference atom, $i$, at the origin of a coordinate system without loss of generality. In a perfect lattice, all nearest neighbors are at the same distance, which we will denote as $r_{\\text{NN}}$. The number of these nearest neighbors is the first coordination number of the lattice, which we denote as $Z_{\\text{NN}}$.\n\nThe summation can thus be simplified. Since $\\rho_a(r_{ij}) = \\rho_a(r_{\\text{NN}})$ for all $j \\in \\text{NN}(i)$, the sum becomes a product:\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}})\n$$\nTo proceed, we must determine the values of $Z_{\\text{NN}}$ and $r_{\\text{NN}}$ for the fcc lattice structure in terms of its lattice parameter, $a$.\n\nThe conventional unit cell of an fcc lattice is a cube of side length $a$ with atoms at the $8$ corners and at the center of the $6$ faces. Let's place a reference atom at the origin, coordinates $(0, 0, 0)$. The positions of its neighbors can be identified.\n\nThe atoms at the corners of the cube are at positions like $(a, 0, 0)$, $(0, a, 0)$, etc. The distance to these atoms is $a$.\nThe atoms at the centers of the faces are at positions like $(\\frac{a}{2}, \\frac{a}{2}, 0)$, $(\\frac{a}{2}, 0, \\frac{a}{2})$, $(0, \\frac{a}{2}, \\frac{a}{2})$, and their permutations with signs. The distance from the origin to an atom at $(\\frac{a}{2}, \\frac{a}{2}, 0)$ is:\n$$\nr = \\sqrt{\\left(\\frac{a}{2}\\right)^2 + \\left(\\frac{a}{2}\\right)^2 + 0^2} = \\sqrt{\\frac{a^2}{4} + \\frac{a^2}{4}} = \\sqrt{\\frac{2a^2}{4}} = \\sqrt{\\frac{a^2}{2}} = \\frac{a}{\\sqrt{2}}\n$$\nWe must compare this distance to the distance to the corner atoms, which is $a$. Since $\\frac{1}{\\sqrt{2}} \\approx 0.707$, we have $\\frac{a}{\\sqrt{2}}  a$. Therefore, the face-centered atoms are the nearest neighbors to a corner atom. The nearest-neighbor distance is:\n$$\nr_{\\text{NN}} = \\frac{a}{\\sqrt{2}}\n$$\nNext, we determine the coordination number, $Z_{\\text{NN}}$. For a reference atom at the origin, the nearest neighbors are the atoms on the faces of the cubes that meet at this corner. There are $12$ such face centers at the correct distance. Their coordinates relative to the origin are given by all non-zero permutations of $(\\pm \\frac{a}{2}, \\pm \\frac{a}{2}, 0)$. These are:\n- In the $xy$-plane: $(\\frac{a}{2}, \\frac{a}{2}, 0)$, $(\\frac{a}{2}, -\\frac{a}{2}, 0)$, $(-\\frac{a}{2}, \\frac{a}{2}, 0)$, $(-\\frac{a}{2}, -\\frac{a}{2}, 0)$. This is $4$ neighbors.\n- In the $xz$-plane: $(\\frac{a}{2}, 0, \\frac{a}{2})$, $(\\frac{a}{2}, 0, -\\frac{a}{2})$, $(-\\frac{a}{2}, 0, \\frac{a}{2})$, $(-\\frac{a}{2}, 0, -\\frac{a}{2})$. This is $4$ neighbors.\n- In the $yz$-plane: $(0, \\frac{a}{2}, \\frac{a}{2})$, $(0, \\frac{a}{2}, -\\frac{a}{2})$, $(0, -\\frac{a}{2}, \\frac{a}{2})$, $(0, -\\frac{a}{2}, -\\frac{a}{2})$. This is $4$ neighbors.\n\nSumming these up gives a total of $4 + 4 + 4 = 12$ nearest neighbors. Thus, the first coordination number for the fcc lattice is:\n$$\nZ_{\\text{NN}} = 12\n$$\nNow, we can substitute the derived values for $Z_{\\text{NN}}$ and $r_{\\text{NN}}$ back into our expression for $\\rho_i$:\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}}) = 12 \\cdot \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)\n$$\nThis expression represents the zeroth-order background electron density at any atomic site in a perfect fcc crystal, based on the simplified MEAM assumptions provided. The neglect of angular contributions is justified by the high symmetry of the nearest-neighbor shell in the fcc lattice, which would cause the first-order angularly dependent terms in the full MEAM to sum to zero. The screening factor of unity, while a core MEAM concept, does not enter this particular calculation as it applies to the construction of partial (angular) electron densities, which have been excluded by the problem statement.",
            "answer": "$$\\boxed{12 \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)}$$"
        },
        {
            "introduction": "A key enhancement of the Modified Embedded Atom Method (MEAM) is its explicit inclusion of multi-body screening, where the interaction between two atoms is modulated by the presence of others. This practice uses a simplified one-dimensional chain of atoms to offer a clear and analytical demonstration of how this screening mechanism functions. The exercise reveals the profound impact of geometry, showing how an interposing atom can completely screen the interaction between its neighbors, a crucial feature for accurately modeling metallic systems .",
            "id": "3782093",
            "problem": "Consider the Modified Embedded Atom Method (MEAM) potentials, where pairwise interactions between atoms are multiplicatively screened by the presence of other atoms. In MEAM, the screening factor between atoms $i$ and $j$ is defined as $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$, where each three-body factor $S_{ikj}$ depends on the local geometry around the triplet $(i,k,j)$. For a linear chain of identical atoms lying on the $x$-axis at positions $x_n = n a$ with uniform spacing $a  0$, assume an infinite chain and the following specific continuous and geometrically motivated screening form:\n$$\nS_{ikj} = \\frac{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2}}{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2} + d_{0}^{2}},\n$$\nwhere $r_{pq}$ denotes the Euclidean distance between atoms $p$ and $q$, and $d_{0}  0$ is a characteristic screening softness length scale that regularizes the transition between fully screened and unscreened configurations.\n\nStarting from the MEAM definition $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$ and the geometric distances implied by a one-dimensional chain, derive the screening factors for:\n- nearest neighbors separated by $r_{ij} = a$, and\n- next-nearest neighbors separated by $r_{ij} = 2 a$.\n\nDemonstrate qualitatively why these screening factors differ in a linear chain, and then compute the closed-form analytic expressions for both cases under the given $S_{ikj}$ form. Express your final answer as a two-entry row vector whose first entry is the nearest-neighbor screening factor and whose second entry is the next-nearest neighbor screening factor, in terms of $a$ and $d_{0}$. No numerical rounding is required, and you should provide an exact expression.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Model:** Modified Embedded Atom Method (MEAM).\n- **System:** An infinite linear chain of identical atoms.\n- **Atomic Positions:** $x_n = n a$, where $n$ is an integer and $a  0$ is the uniform spacing.\n- **Distance:** $r_{pq}$ is the Euclidean distance between atoms $p$ and $q$. For the linear chain, $r_{pq} = |p-q|a$.\n- **Total Screening Factor:** $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$.\n- **Three-Body Screening Term:** $S_{ikj} = \\frac{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2}}{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2} + d_{0}^{2}}$, where $d_0  0$.\n- **Task:** Derive the screening factors $S_{ij}$ for:\n    1. Nearest neighbors ($r_{ij} = a$).\n    2. Next-nearest neighbors ($r_{ij} = 2a$).\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding:** The problem is based on the MEAM potential, a widely used semi-empirical model in computational materials science. The specific functional form for $S_{ikj}$ is a simplified, continuous model for screening, but it is mathematically consistent and physically interpretable. The term $r_{ik} + r_{kj} - r_{ij}$ is related to the triangle inequality and correctly captures the geometric concept of collinearity. The problem is scientifically grounded.\n- **Well-Posed:** The problem provides all necessary definitions, the geometry of the system, and the functional forms required to perform the calculation. The objective is clearly stated. A unique solution exists and can be derived from the provided information.\n- **Objective:** The problem is stated in precise, formal language, free of ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-posed problem in theoretical condensed matter physics that can be solved analytically. I will now proceed with the solution.\n\n### Derivation of Screening Factors\n\nThe core of the calculation lies in the three-body screening term $S_{ikj}$, which depends on the quantity $\\Delta_{ikj} = r_{ik} + r_{kj} - r_{ij}$. For a linear chain, atoms are located at integer multiples of the spacing $a$. Let's place atom $i$ at the origin, $x_i=0$, without loss of generality. An arbitrary atom $p$ is at position $x_p = p a$. The distance is $r_{pq} = |p-q|a$.\n\nThe quantity $\\Delta_{ikj}$ becomes:\n$$\n\\Delta_{ikj} = (|k-i|a + |j-k|a - |j-i|a) = (|k| + |j-k| - |j|)a\n$$\nwhere we have set $i=0$. The key insight is that $\\Delta_{ikj} = 0$ if and only if atom $k$ lies on the line segment connecting atoms $i$ and $j$. For our discrete chain, this means an integer $k$ is strictly between the integers representing atoms $i$ and $j$. If $\\Delta_{ikj} = 0$, then $S_{ikj} = \\frac{0^2}{0^2 + d_0^2} = 0$. This implies perfect screening.\n\n#### Case 1: Nearest-Neighbor Screening Factor ($S_{NN}$)\n\nWe consider two nearest-neighbor atoms, say at positions $i=0$ and $j=1$. The distance is $r_{01} = a$. The total screening factor is a product over all other atoms $k \\in \\mathbb{Z}$ where $k \\neq 0$ and $k \\neq 1$.\n$$\nS_{NN} = S_{01} = \\prod_{k \\in \\mathbb{Z} \\setminus \\{0,1\\}} S_{0k1}\n$$\nFor this pair, the quantity $\\Delta_{0k1}$ is:\n$$\n\\Delta_{0k1} = (|k| + |1-k| - |1|)a = (|k| + |1-k| - 1)a\n$$\nThe screening atoms $k$ are integers. There is no integer $k$ such that $0  k  1$. Therefore, no atom lies between atoms $0$ and $1$, and $\\Delta_{0k1}$ can never be zero.\n\nLet's evaluate $\\Delta_{0k1}$ for the screening atoms $k$:\n- For $k  1$ (e.g., $k=2, 3, \\dots$): $\\Delta_{0k1} = (k + (k-1) - 1)a = (2k-2)a = 2(k-1)a$.\n- For $k  0$ (e.g., $k=-1, -2, \\dots$): $\\Delta_{0k1} = (-k + (1-k) - 1)a = (-2k)a$.\n\nThe product for $S_{01}$ can be split into two parts: one for $k  1$ and one for $k  0$.\n$$\nS_{01} = \\left( \\prod_{k=2}^{\\infty} S_{0k1} \\right) \\left( \\prod_{k=-\\infty}^{-1} S_{0k1} \\right)\n$$\nSubstituting the expressions for $\\Delta_{0k1}$:\n$$\nS_{01} = \\left( \\prod_{k=2}^{\\infty} \\frac{(2(k-1)a)^2}{(2(k-1)a)^2 + d_0^2} \\right) \\left( \\prod_{k=-\\infty}^{-1} \\frac{(-2ka)^2}{(-2ka)^2 + d_0^2} \\right)\n$$\nLet's re-index the products. In the first product, let $n = k-1$; $n$ runs from $1$ to $\\infty$. In the second product, let $n = -k$; $n$ also runs from $1$ to $\\infty$.\n$$\nS_{01} = \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right) \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right) = \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right)^2\n$$\nTo evaluate this infinite product, we use the infinite product expansion for the hyperbolic sine function:\n$$\n\\frac{\\sinh(\\pi z)}{\\pi z} = \\prod_{n=1}^{\\infty} \\left(1 + \\frac{z^2}{n^2}\\right)\n$$\nLet's rearrange our product term:\n$$\n\\frac{(2na)^2}{(2na)^2 + d_0^2} = \\frac{1}{1 + \\frac{d_0^2}{(2na)^2}} = \\frac{1}{1 + \\frac{(d_0/(2a))^2}{n^2}}\n$$\nThe product becomes:\n$$\n\\prod_{n=1}^{\\infty} \\frac{1}{1 + \\frac{(d_0/(2a))^2}{n^2}} = \\frac{1}{\\prod_{n=1}^{\\infty} \\left(1 + \\frac{(d_0/(2a))^2}{n^2}\\right)}\n$$\nBy setting $z = \\frac{d_0}{2a}$ in the hyperbolic sine expansion, we get:\n$$\n\\prod_{n=1}^{\\infty} \\left(1 + \\left(\\frac{d_0}{2a}\\right)^2 \\frac{1}{n^2}\\right) = \\frac{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)}{\\frac{\\pi d_0}{2a}}\n$$\nThus, the product inside the parentheses for $S_{01}$ is the reciprocal of this expression:\n$$\n\\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} = \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)}\n$$\nFinally, the nearest-neighbor screening factor is the square of this result:\n$$\nS_{NN} = \\left( \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)} \\right)^2\n$$\n\n#### Case 2: Next-Nearest-Neighbor Screening Factor ($S_{NNN}$)\n\nWe consider two next-nearest-neighbor atoms, say at positions $i=0$ and $j=2$. The distance is $r_{02} = 2a$. The total screening factor is a product over all other atoms $k \\in \\mathbb{Z}$ where $k \\neq 0$ and $k \\neq 2$.\n$$\nS_{NNN} = S_{02} = \\prod_{k \\in \\mathbb{Z} \\setminus \\{0,2\\}} S_{0k2}\n$$\nThis product includes the term for the atom at $k=1$. Let's evaluate the screening contribution $S_{012}$ from this atom. The quantity $\\Delta_{012}$ is:\n$$\n\\Delta_{012} = (|1-0|a + |2-1|a - |2-0|a) = (a + a - 2a) = 0\n$$\nSince $\\Delta_{012}=0$, the corresponding three-body screening term is:\n$$\nS_{012} = \\frac{(\\Delta_{012})^2}{(\\Delta_{012})^2 + d_0^2} = \\frac{0^2}{0^2 + d_0^2} = 0\n$$\nThe total screening factor $S_{02}$ is a product of many terms, one of which is $S_{012}=0$. The entire product is therefore zero.\n$$\nS_{NNN} = S_{02} = S_{0(-1)2} \\cdots S_{012} \\cdots S_{032} \\cdots = 0\n$$\n\n#### Qualitative Comparison\n\nThe screening factors for nearest neighbors and next-nearest neighbors differ fundamentally due to the geometry of the one-dimensional chain.\n- For a **nearest-neighbor** pair (e.g., atoms at $0$ and $a$), there are no other atoms on the line segment connecting them. Consequently, no single atom $k$ can provide \"perfect\" screening ($\\Delta_{ikj} \\neq 0$ for all $k$). The total screening $S_{NN}$ is the result of the cumulative, partial screening from all other atoms in the infinite chain, resulting in a non-zero value that depends on the ratio of the length scales $d_0/a$.\n- For a **next-nearest-neighbor** pair (e.g., atoms at $0$ and $2a$), there is an atom (at $a$) located exactly on the line segment between them. This interposing atom leads to a perfect screening condition ($\\Delta_{012}=0$), making its screening contribution $S_{012}$ equal to zero. Because the total screening factor $S_{NNN}$ is a product of all individual contributions, this single zero-valued term forces the entire screening factor to be zero. This signifies that, in this specific MEAM model, the interaction between next-nearest neighbors is completely screened by the atom situated between them.\n\nThe final answer is a two-entry row vector containing $S_{NN}$ and $S_{NNN}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\left( \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)} \\right)^{2}  0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "A physically realistic interatomic potential must not only reproduce known material properties but also guarantee that the crystal structure it describes is mechanically stable. This advanced practice bridges the gap between the abstract angular parameters $t_k$ of a MEAM potential and the macroscopic elastic constants, which are governed by the Born stability criteria. You will implement a computational workflow to diagnose and correct potential instabilities, a task that mirrors the real-world process of developing and refining robust material models .",
            "id": "3782204",
            "problem": "You are asked to formalize how the Modified Embedded Atom Method (MEAM) parametrization through angular weight parameters can affect mechanical stability, and to construct an algorithmic procedure that automatically adjusts these parameters to restore stability when violations occur. Begin from the following fundamental bases: (i) the total energy of a crystalline solid may be approximated by an interatomic potential that depends on pairwise separations and a local electron density, (ii) under small homogeneous strain, the elastic response of a crystalline solid is defined by the linear relation between stress and strain (Hookeâ€™s law), and (iii) the Born stability criteria for a cubic crystal, which are necessary and sufficient for a positive-definite quadratic elastic energy density, require the following inequalities to hold: $C_{11}-C_{12}0$, $C_{44}0$, and $C_{11}+2C_{12}0$. In MEAM, the local electron density is constructed from radial and angular contributions, with angular weight parameters $t_k$ ($k=1,\\dots,m$) controlling higher-order orientation-dependent terms. Under a small perturbation of the parameters $t_k$ around a calibrated reference, the elastic constants change to first order according to a sensitivity relation of the form\n$$\n\\Delta \\boldsymbol{C} \\approx \\boldsymbol{S}\\,\\Delta \\boldsymbol{t},\n$$\nwhere $\\boldsymbol{C}=[C_{11},C_{12},C_{44}]^{\\top}$, $\\boldsymbol{t}=[t_1,\\dots,t_m]^{\\top}$, and $\\boldsymbol{S}\\in\\mathbb{R}^{3\\times m}$ is a sensitivity matrix that encodes how the elastic constants respond to infinitesimal changes in the MEAM angular weights. Let $\\boldsymbol{C}^{(0)}$ denote the baseline elastic constants at the reference calibration (in the same units as the sensitivity responses), so that for finite deviations one employs the linearized model\n$$\n\\boldsymbol{C}(\\boldsymbol{t}) \\approx \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\,\\boldsymbol{t}.\n$$\nIn this problem you will: (a) demonstrate that ill-chosen values of the MEAM angular weights $t_k$ can violate the Born stability criteria, and (b) implement a procedure that solves the constrained optimization problem\n$$\n\\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 \\quad \\text{subject to} \\quad \\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}, \\quad \\ell_k \\le t_k \\le u_k,\n$$\nwhere $\\boldsymbol{t}^{(0)}$ is the initial choice of MEAM angular weights, $\\boldsymbol{A}$ encodes the linear Born constraints for a cubic crystal,\n$$\n\\boldsymbol{A}=\\begin{bmatrix}1  -1  0\\\\ 0  0  1\\\\ 1  2  0\\end{bmatrix},\n$$\nand $\\ell_k,u_k$ are physically reasonable bounds on $t_k$. Your program must, for each test case, report whether the initial parameters violate the Born stability criteria and whether the adjustment procedure achieves a stable solution within the prescribed bounds.\n\nAll computations of elastic constants must be carried out in a consistent unit system; take the units of the elastic constants to be gigapascals ($\\mathrm{GPa}$). The final program should not take any user input and should only print the required output line described below.\n\nImplement your solution for the following test suite, each case defined by $(\\boldsymbol{C}^{(0)}, \\boldsymbol{S}, \\boldsymbol{t}^{(0)}, \\text{bounds})$:\n\n- Case $1$ (happy path, initially stable):\n  - $\\boldsymbol{C}^{(0)} = [\\,110,\\,60,\\,40\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 10  -5  0  0 \\\\ -8  3  1  0 \\\\ 2  -1  0.5  1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.1,\\,-0.2,\\,0.05,\\,0.0\\,]$,\n  - bounds $t_k\\in[-1,1]$ for all $k$.\n- Case $2$ (initial violation, feasible restoration):\n  - $\\boldsymbol{C}^{(0)} = [\\,100,\\,50,\\,30\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} -20  0  5  0 \\\\ 5  -15  0  0 \\\\ 0  0  -40  10 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,1.0,\\,-0.5\\,]$,\n  - bounds $t_k\\in[-1,1]$ for all $k$.\n- Case $3$ (initial violation, infeasible within bounds):\n  - $\\boldsymbol{C}^{(0)} = [\\,5,\\,6,\\,-2\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 0.5  0.5  0.5  0.5 \\\\ 0.5  0.4  0.3  0.2 \\\\ 0.1  0.1  0.1  0.1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$,\n  - bounds $t_k\\in[-0.3,0.3]$ for all $k$.\n\nYour program must, for each test case, compute $\\boldsymbol{C}(\\boldsymbol{t}^{(0)})$, determine whether the Born criteria are violated, solve the constrained adjustment to get $\\boldsymbol{t}^{\\star}$ if necessary, and then re-check stability with $\\boldsymbol{C}(\\boldsymbol{t}^{\\star})$. The final output must be a single line containing a comma-separated list enclosed in square brackets, where each test case contributes a two-element bracketed list of booleans (with no spaces) of the form $[\\text{initial\\_violation},\\text{restored\\_stability}]$. For example, your output should look like $[[\\text{b}_{1},\\text{b}_{2}],[\\text{b}_{3},\\text{b}_{4}],[\\text{b}_{5},\\text{b}_{6}]]$ where each $\\text{b}_{i}$ is either $\\text{True}$ or $\\text{False}$.",
            "solution": "The present problem requires the development of an algorithmic procedure to analyze and enforce the mechanical stability of a cubic crystal, as described by the Modified Embedded Atom Method (MEAM) potential. The solution involves two main components: (1) checking for violations of the Born stability criteria given an initial set of MEAM angular weight parameters, and (2) if a violation exists, solving a constrained optimization problem to find the minimal adjustment to these parameters that restores stability.\n\n### Principle-Based Design\n\n1.  **Physical Model and Stability Criteria**: The mechanical stability of a material is fundamental. For a cubic crystal under small deformations, its elastic energy density must be positive-definite. This condition is guaranteed if the matrix of elastic constants $\\boldsymbol{C}$ satisfies the Born stability criteria:\n    $$\n    C_{11} - C_{12}  0\n    $$\n    $$\n    C_{44}  0\n    $$\n    $$\n    C_{11} + 2C_{12}  0\n    $$\n    These three linear inequalities can be compactly written in matrix form. Defining the vector of elastic constants as $\\boldsymbol{C} = [C_{11}, C_{12}, C_{44}]^\\top$, the criteria are equivalent to $\\boldsymbol{A}\\boldsymbol{C}  \\boldsymbol{0}$, where the matrix $\\boldsymbol{A}$ is given as:\n    $$\n    \\boldsymbol{A} = \\begin{bmatrix} 1  -1  0 \\\\ 0  0  1 \\\\ 1  2  0 \\end{bmatrix}\n    $$\n\n2.  **Linearized MEAM Model**: The problem provides a linearized model connecting the MEAM angular weight parameters $\\boldsymbol{t}=[t_1, \\dots, t_m]^\\top$ to the elastic constants $\\boldsymbol{C}$:\n    $$\n    \\boldsymbol{C}(\\boldsymbol{t}) = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}\n    $$\n    Here, $\\boldsymbol{C}^{(0)}$ represents the baseline elastic constants, and the sensitivity matrix $\\boldsymbol{S}$ quantifies how each parameter $t_k$ influences the elastic constants. This linear approximation allows for a direct mathematical connection between the adjustable parameters and mechanical stability.\n\n3.  **Formulation as a Constrained Optimization Problem**: When an initial choice of parameters $\\boldsymbol{t}^{(0)}$ leads to a violation of the Born criteria, we seek a corrected set of parameters $\\boldsymbol{t}$ that are as close as possible to the original choice $\\boldsymbol{t}^{(0)}$ while satisfying the stability conditions. This is a classic engineering and scientific problem, formalized as a constrained optimization problem. The objective is to minimize the Euclidean distance (or its square) between the new and initial parameters, which encourages a minimal perturbation. The constraints enforce physical and mechanical requirements.\n    The optimization problem is:\n    $$\n    \\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2\n    $$\n    subject to:\n    1.  **Mechanical Stability**: $\\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}$\n    2.  **Parameter Bounds**: $\\ell_k \\le t_k \\le u_k$ for all $k=1, \\dots, m$.\n\n    Substituting the linearized model into the stability constraint yields:\n    $$\n    \\boldsymbol{A}(\\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}) \\ge \\boldsymbol{0} \\implies (\\boldsymbol{A}\\boldsymbol{S})\\boldsymbol{t} \\ge -\\boldsymbol{A}\\boldsymbol{C}^{(0)}\n    $$\n    This is a system of linear inequalities. The objective function $\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 = \\frac{1}{2}\\sum_k (t_k - t_k^{(0)})^2$ is a strictly convex quadratic function. The constraints (both stability and bounds) are linear. This specific structure defines a **Quadratic Programming (QP)** problem. QP problems are a well-understood class of convex optimization problems, which, if a feasible solution exists, guarantee a unique global minimum.\n\n4.  **Algorithmic Procedure and Numerical Implementation**:\n    The algorithm for each test case proceeds as follows:\n    a.  **Initial Stability Check**: Given an initial parameter set $\\boldsymbol{t}^{(0)}$, calculate the corresponding elastic constants $\\boldsymbol{C}_{initial} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{(0)}$. Then, evaluate the Born stability criteria, $\\boldsymbol{A}\\boldsymbol{C}_{initial}  \\boldsymbol{0}$. For numerical implementation, this is checked as $\\boldsymbol{A}\\boldsymbol{C}_{initial}  \\epsilon$, where $\\epsilon$ is a small positive tolerance (e.g., $10^{-9}$). This check determines the `initial_violation` status.\n    b.  **Conditional Optimization**:\n        - If the initial state is stable (`initial_violation` is false), no action is needed. The state is already stable, so `restored_stability` is true.\n        - If the initial state is unstable (`initial_violation` is true), the QP problem must be solved. We use the Sequential Least Squares Programming (SLSQP) algorithm, available in `scipy.optimize.minimize`, which is well-suited for such problems.\n    c.  **Post-Optimization Analysis**: The outcome of the optimization determines `restored_stability`:\n        - If the optimizer fails to converge (e.g., `success=False`), it implies that no solution exists that satisfies both the stability constraints and the parameter bounds. The problem is infeasible, and stability cannot be restored. Thus, `restored_stability` is false.\n        - If the optimizer converges to a solution $\\boldsymbol{t}^{\\star}$ (`success=True`), the resulting elastic constants $\\boldsymbol{C}_{final} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{\\star}$ are checked again for strict stability ($\\boldsymbol{A}\\boldsymbol{C}_{final}  \\epsilon$). It is a crucial feature of this optimization that if the initial point $\\boldsymbol{t}^{(0)}$ is infeasible, the optimal solution $\\boldsymbol{t}^{\\star}$ will lie on the boundary of the feasible region. This means at least one of the stability constraints will be active (i.e., equal to zero), e.g., $C_{44} = 0$. Such a state is termed marginally stable, not strictly stable. Therefore, the check for strict stability (` \\epsilon`) will fail, and `restored_stability` will be reported as false.\n\nThis rigorous distinction between the numerical feasibility sought by the optimizer ($\\ge 0$) and the physical requirement of strict stability ($ 0$) is central to correctly interpreting the results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a series of MEAM parameter stability problems by checking initial\n    stability and performing constrained optimization if necessary.\n    \"\"\"\n    # Define the constant matrix A for Born stability criteria and a tolerance for strict inequality.\n    A = np.array([\n        [1.0, -1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [1.0, 2.0, 0.0]\n    ])\n    STABILITY_TOLERANCE = 1e-9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, initially stable)\n        {\n            \"C0\": np.array([110.0, 60.0, 40.0]),\n            \"S\": np.array([\n                [10.0, -5.0, 0.0, 0.0],\n                [-8.0, 3.0, 1.0, 0.0],\n                [2.0, -1.0, 0.5, 1.0]\n            ]),\n            \"t0\": np.array([0.1, -0.2, 0.05, 0.0]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 2 (initial violation, feasible restoration)\n        {\n            \"C0\": np.array([100.0, 50.0, 30.0]),\n            \"S\": np.array([\n                [-20.0, 0.0, 5.0, 0.0],\n                [5.0, -15.0, 0.0, 0.0],\n                [0.0, 0.0, -40.0, 10.0]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 1.0, -0.5]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 3 (initial violation, infeasible within bounds)\n        {\n            \"C0\": np.array([5.0, 6.0, -2.0]),\n            \"S\": np.array([\n                [0.5, 0.5, 0.5, 0.5],\n                [0.5, 0.4, 0.3, 0.2],\n                [0.1, 0.1, 0.1, 0.1]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"bounds\": [(-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3)]\n        }\n    ]\n\n    results = []\n\n    def is_stable(C_vector):\n        \"\"\"Checks if a vector of elastic constants satisfies the strict Born stability criteria.\"\"\"\n        born_metrics = A @ C_vector\n        return np.all(born_metrics  STABILITY_TOLERANCE)\n\n    for case in test_cases:\n        C0, S, t0, bounds = case[\"C0\"], case[\"S\"], case[\"t0\"], case[\"bounds\"]\n        \n        # 1. Initial State Analysis\n        C_initial = C0 + S @ t0\n        initial_violation = not is_stable(C_initial)\n\n        restored_stability = False\n        \n        if not initial_violation:\n            # If already stable, the 'restored' status is True as stability is maintained.\n            restored_stability = True\n        else:\n            # 2. Setup and run optimization problem for unstable cases.\n            # Objective function: minimize 0.5 * ||t - t0||^2\n            def objective_fun(t):\n                return 0.5 * np.sum((t - t0)**2)\n\n            # Jacobian of the objective function\n            def objective_jac(t):\n                return t - t0\n\n            # Constraints: A*C(t) = 0 = A*C0 + (A*S)*t = 0\n            # Scipy's 'ineq' constraint type is f(x) = 0.\n            AS = A @ S\n            A_C0 = A @ C0\n            constraints = {\n                'type': 'ineq',\n                'fun': lambda t: A_C0 + AS @ t,\n                'jac': lambda t: AS \n            }\n\n            # Solve the Quadratic Program\n            opt_result = minimize(\n                fun=objective_fun,\n                x0=t0,\n                method='SLSQP',\n                jac=objective_jac,\n                bounds=bounds,\n                constraints=[constraints],\n                options={'ftol': 1e-12, 'disp': False}\n            )\n            \n            # 3. Post-Optimization Analysis\n            if opt_result.success:\n                # If optimizer converges, check if the solution is *strictly* stable.\n                # The solution will lie on the boundary (marginal stability), so this check\n                # for strict stability will fail.\n                t_star = opt_result.x\n                C_final = C0 + S @ t_star\n                if is_stable(C_final):\n                    restored_stability = True\n            # If optimization fails (e.g., infeasible), restored_stability remains False.\n\n        # Store the boolean pair for this case\n        results.append((initial_violation, restored_stability))\n\n    # Final print statement in the exact required format.\n    result_strings = [f\"[{v[0]},{v[1]}]\" for v in results]\n    print(f\"[[{result_strings[0][1:-1]}],[{result_strings[1][1:-1]}],[{result_strings[2][1:-1]}]]\")\n\nsolve()\n```"
        }
    ]
}