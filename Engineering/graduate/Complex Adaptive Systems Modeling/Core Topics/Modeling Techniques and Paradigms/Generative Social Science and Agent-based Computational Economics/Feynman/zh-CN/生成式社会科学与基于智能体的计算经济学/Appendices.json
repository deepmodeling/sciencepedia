{
    "hands_on_practices": [
        {
            "introduction": "在基于代理人的模型中，代理人之间“何时”以及“如何”互动是至关重要的设计选择，而非微不足道的细节。本练习使用一个极简的市场模型，来直观地展示一个看似微小的变化——代理人是根据当前信息还是略微过时的信息做出反应——如何决定市场是能够找到均衡还是会陷入不稳定的螺旋。这突显了信息延迟作为系统性脆弱性来源的核心概念，是生成式建模中的一个关键洞见。",
            "id": "4124559",
            "problem": "考虑一个基于代理的计算经济学（Agent-Based Computational Economics, ACE）中的最小市场模型，其中单个总价格 $p_t$ 在离散时间 $t \\in \\{0,1,2,\\dots\\}$ 内根据一个简单的由超额需求引导的调整规则进行演变。设市场需求为 $D(p) = a - b p$，市场供给为 $S(p) = c + d p$，其中斜率 $b > 0$，$d > 0$ 均为严格正数，且常数 $a, c \\in \\mathbb{R}$。将超额需求定义为 $Z(p) = D(p) - S(p) = (a - c) - (b + d) p$。Walrasian tatonnement 原理指出，当超额需求为正时，价格向上调整；当超额需求为负时，价格向下调整。\n\n此问题的基本基础是 Walrasian tatonnement 规则和经过充分检验的线性供需模型，该模型被广泛用于推导离散时间中的价格动态。市场出清均衡价格 $p^\\star$ 满足 $Z(p^\\star) = 0$，这意味着\n$$\np^\\star = \\frac{a - c}{b + d}.\n$$\n定义 $K = b + d$ 并考虑两种更新机制，它们具有一个共同的正步长参数 $\\alpha > 0$：\n- 同步更新（无延迟）：所有代理根据当前的总超额需求进行更新，\n$$\np_{t+1} = p_t + \\alpha Z(p_t).\n$$\n- 带有一步信息延迟的异步更新：代理根据前一个时间步测量的过时超额需求进行更新，\n$$\np_{t+1} = p_t + \\alpha Z(p_{t-1}).\n$$\n\n您的任务是编写一个完整的程序，对于每个指定的测试用例，从给定的初始条件开始，对两种机制进行固定步数的模拟，并确定在每种机制下价格 $p_t$ 是否收敛到均衡价格 $p^\\star$。收敛的定义是，在模拟的最后 $W$ 步窗口内的所有时间里，绝对偏差 $|p_t - p^\\star|$ 都小于容差 $\\varepsilon$。此问题中没有物理单位，也不出现角度。所有输出都必须是无量纲的。\n\n具体来说，对于每个测试用例，生成一个包含三个布尔值的列表：\n- 第一个布尔值表示同步更新是否收敛。\n- 第二个布尔值表示异步更新是否收敛。\n- 第三个布尔值表示异步更新是否相对于同步更新破坏了均衡，其定义为逻辑条件“同步收敛且异步不收敛”。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，一个有效的输出行是 $[ [\\text{True},\\text{False},\\text{True}], [\\text{True},\\text{True},\\text{False}] ]$。\n\n请使用以下测试套件，它涵盖了正常路径、边界和边缘情况。在每种情况下，模拟 $T$ 步，并使用指定的容差 $\\varepsilon$ 和窗口长度 $W$。对于异步更新，使用一步延迟，并在指定情况下将 $p_{-1}$ 设置为提供的初始条件。\n\n测试用例：\n- 用例 1（正常路径，两种机制均收敛）：\n  参数：$a = 10$, $b = 1$, $c = 2$, $d = 1$, $\\alpha = 0.2$, $T = 200$, $\\varepsilon = 10^{-6}$, $W = 25$, 初始 $p_0 = 1$, 且 $p_{-1} = 1$。\n- 用例 2（异步破坏均衡，而同步收敛）：\n  参数：$a = 10$, $b = 1$, $c = 2$, $d = 1$, $\\alpha = 0.9$, $T = 200$, $\\varepsilon = 10^{-6}$, $W = 25$, 初始 $p_0 = 1$, 且 $p_{-1} = 1$。\n- 用例 3（两种机制均发散）：\n  参数：$a = 10$, $b = 1$, $c = 2$, $d = 1$, $\\alpha = 1.1$, $T = 200$, $\\varepsilon = 10^{-6}$, $W = 25$, 初始 $p_0 = 1$, 且 $p_{-1} = 1$。\n- 用例 4（异步的边界情况：幅度为 1 的振荡，同步收敛）：\n  参数：$a = 10$, $b = 1$, $c = 2$, $d = 1$, $\\alpha = 0.5$, $T = 200$, $\\varepsilon = 10^{-6}$, $W = 25$, 初始 $p_0 = 1$, 且 $p_{-1} = 1$。\n- 用例 5（初始处于均衡状态，两种机制立即收敛）：\n  参数：$a = 10$, $b = 1$, $c = 2$, $d = 1$, $\\alpha = 0.3$, $T = 200$, $\\varepsilon = 10^{-6}$, $W = 25$, 初始 $p_0 = p^\\star$, 且 $p_{-1} = p^\\star$。\n\n您的程序必须实现以上内容，并以指定的单行格式输出结果。",
            "solution": "该问题要求在两种不同的信息机制（同步和异步）下模拟一个离散时间的 Walrasian tatonnement 价格调整模型，并评估它们的收敛特性。解决方案涉及对模型稳定性的理论分析和为验证特定参数集下的行为而进行的数值实现。\n\n### 1. 模型设定与均衡\n\n该模型由线性需求和供给函数定义：\n- 需求：$D(p) = a - b p$\n- 供给：$S(p) = c + d p$\n\n参数 $b$ 和 $d$ 是严格正数（$b > 0$, $d > 0$），确保了需求曲线向下倾斜和供给曲线向上倾斜。超额需求 $Z(p)$ 是需求与供给之差：\n$$Z(p) = D(p) - S(p) = (a - c) - (b + d) p$$\n\n市场出清或 Walrasian 均衡价格，记为 $p^\\star$，是超额需求为零时的价格，即 $Z(p^\\star) = 0$。求解 $p^\\star$ 可得：\n$$(a - c) - (b + d) p^\\star = 0 \\implies p^\\star = \\frac{a - c}{b + d}$$\n让我们定义常数 $K = b + d$，它代表了超额需求的总价格敏感度。那么，$p^\\star = (a-c)/K$ 且 $Z(p) = K(p^\\star - p)$。\n\n对于所提供的测试用例，当 $a = 10$, $b = 1$, $c = 2$, $d = 1$ 时，均衡价格为：\n$$p^\\star = \\frac{10 - 2}{1 + 1} = \\frac{8}{2} = 4$$\n\n### 2. 价格动态的稳定性分析\n\n问题的核心在于分析均衡价格 $p^\\star$ 在两种不同价格调整动态下的稳定性。我们分析其与均衡的偏差 $\\delta_t = p_t - p^\\star$ 的演变。如果当 $t \\to \\infty$ 时 $\\delta_t \\to 0$，则该机制是稳定的。\n\n**2.1. 同步更新机制**\n\n价格根据以下规则更新：\n$$p_{t+1} = p_t + \\alpha Z(p_t)$$\n其中 $\\alpha > 0$ 是调整速度参数。为了分析稳定性，我们用偏差 $\\delta_t$ 来表示这个方程：\n$$p_{t+1} - p^\\star = p_t - p^\\star + \\alpha Z(p_t)$$\n$$\\delta_{t+1} = \\delta_t + \\alpha (K(p^\\star - p_t))$$\n$$\\delta_{t+1} = \\delta_t - \\alpha K (p_t - p^\\star)$$\n$$\\delta_{t+1} = (1 - \\alpha K) \\delta_t$$\n这是一个一阶线性齐次差分方程。其解为 $\\delta_t = (1 - \\alpha K)^t \\delta_0$。价格收敛到 $p^\\star$（即 $\\delta_t \\to 0$）的充要条件是乘数的绝对值小于 1：\n$$|1 - \\alpha K|  1$$\n这个不等式等价于 $-1  1 - \\alpha K  1$，可简化为 $0  \\alpha K  2$。因为 $\\alpha > 0$ 且 $K > 0$，收敛的条件是：\n$$\\alpha  \\frac{2}{K}$$\n\n**2.2. 异步更新机制**\n\n价格更新带有一步信息延迟：\n$$p_{t+1} = p_t + \\alpha Z(p_{t-1})$$\n用与均衡的偏差表示：\n$$p_{t+1} - p^\\star = p_t - p^\\star + \\alpha Z(p_{t-1})$$\n$$\\delta_{t+1} = \\delta_t + \\alpha (K(p^\\star - p_{t-1}))$$\n$$\\delta_{t+1} = \\delta_t - \\alpha K (p_{t-1} - p^\\star)$$\n$$\\delta_{t+1} - \\delta_t + \\alpha K \\delta_{t-1} = 0$$\n这是一个二阶线性齐次差分方程。其稳定性由其特征方程 $r^2 - r + \\alpha K = 0$ 的根决定。系统收敛到均衡的充要条件是所有根 $r$ 的模都小于 1（$|r|  1$）。对于这种形式的二次方程，Jury 稳定性判据（或对根的直接分析）给出了稳定性的充要条件。这里的关键条件是 $\\alpha K  1$。因此，收敛的条件是：\n$$\\alpha  \\frac{1}{K}$$\n\n**2.3. 机制比较**\n\n稳定性分析表明，与同步机制相比，具有一步延迟的异步机制在调整参数 $\\alpha$ 的一个更小范围内是稳定的。具体而言，在区域 $\\frac{1}{K} \\le \\alpha  \\frac{2}{K}$ 内，同步系统将收敛，而异步系统将振荡或发散。这展示了复杂系统中的一个关键原则：信息延迟可能是不稳定性的一个重要来源。\n\n### 3. 算法实现\n\n程序将为每个测试用例执行以下步骤：\n1.  读取参数：$a$、$b$、$c$、$d$、$\\alpha$、$T$、$\\varepsilon$、$W$ 以及初始条件 $p_0$ 和 $p_{-1}$。\n2.  计算均衡价格 $p^\\star = (a - c) / (b + d)$。对于初始条件以 $p^\\star$ 给出的情况，将代入此值。\n3.  定义超额需求函数 $Z(p) = (a - c) - (b + d)p$。\n4.  **同步模拟**：\n    -   初始化一个大小为 $T+1$ 的价格数组 $p_{sync}$，并设 $p_{sync}[0] = p_0$。\n    -   从 $t=0$ 迭代到 $T-1$，应用更新规则 $p_{sync}[t+1] = p_{sync}[t] + \\alpha Z(p_{sync}[t])$。\n5.  **异步模拟**：\n    -   初始化一个大小为 $T+1$ 的价格数组 $p_{async}$，并设 $p_{async}[0] = p_0$。\n    -   对于 $t=0$，计算 $p_{async}[1] = p_{async}[0] + \\alpha Z(p_{-1})$。\n    -   从 $t=1$ 迭代到 $T-1$，应用更新规则 $p_{async}[t+1] = p_{async}[t] + \\alpha Z(p_{async}[t-1])$。\n6.  **收敛性检查**：\n    -   对两种模拟，通过检查条件 $|p_t - p^\\star|  \\varepsilon$ 是否在大小为 $W$ 的最后窗口内的所有时间步 $t$（即 $t \\in \\{T - W + 1, \\dots, T\\}$）都成立来确定收敛性。\n    -   将结果存储为布尔值 `sync_converges` 和 `async_converges`。\n7.  **结果构建**：\n    -   计算第三个布尔值，`breaks_equilibrium = sync_converges and not async_converges`。\n    -   将这三个布尔值编译成当前测试用例的一个列表。\n8.  **最终输出**：将所有测试用例的结果收集到一个主列表中，并将其格式化为指定的单行字符串。\n对于所有测试用例，$K = b+d = 1+1=2$。同步情况的理论稳定性边界是 $\\alpha  1$，异步情况的理论稳定性边界是 $\\alpha  0.5$。模拟结果将从数值上验证这些边界。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating price dynamics for a series of test cases.\n    \"\"\"\n\n    def process_case(a, b, c, d, alpha, T, epsilon, W, p0_spec, p_minus_1_spec):\n        \"\"\"\n        Processes a single test case for price dynamics simulation.\n\n        Args:\n            a, b, c, d (float): Parameters for demand and supply functions.\n            alpha (float): Step-size parameter for price adjustment.\n            T (int): Total number of simulation steps.\n            epsilon (float): Convergence tolerance.\n            W (int): Convergence window size.\n            p0_spec (float or str): Initial price p_0 or 'p_star'.\n            p_minus_1_spec (float or str): Initial price p_{-1} or 'p_star'.\n\n        Returns:\n            list: A list of three booleans: [sync_converges, async_converges, breaks_equilibrium].\n        \"\"\"\n        # 1. Calculate equilibrium price\n        p_star = (a - c) / (b + d)\n\n        # 2. Resolve initial conditions\n        p0 = p_star if p0_spec == 'p_star' else p0_spec\n        p_minus_1 = p_star if p_minus_1_spec == 'p_star' else p_minus_1_spec\n\n        # 3. Define excess demand function\n        K = b + d\n        def Z(p):\n            return (a - c) - K * p\n\n        # 4. Synchronous simulation\n        p_sync = np.zeros(T + 1)\n        p_sync[0] = p0\n        for t in range(T):\n            p_sync[t + 1] = p_sync[t] + alpha * Z(p_sync[t])\n\n        # 5. Check synchronous convergence\n        sync_window = p_sync[T - W + 1 : T + 1]\n        sync_converges = np.all(np.abs(sync_window - p_star)  epsilon)\n\n        # 6. Asynchronous simulation\n        p_async = np.zeros(T + 1)\n        p_async[0] = p0\n        if T >= 1:\n            # Step t=0 needs p_{-1} to calculate p_1\n            p_async[1] = p_async[0] + alpha * Z(p_minus_1)\n        for t in range(1, T):\n            # General step for t > 0\n            p_async[t + 1] = p_async[t] + alpha * Z(p_async[t - 1])\n\n        # 7. Check asynchronous convergence\n        async_window = p_async[T - W + 1 : T + 1]\n        async_converges = np.all(np.abs(async_window - p_star)  epsilon)\n\n        # 8. Determine if asynchronous updating breaks equilibrium\n        breaks_equilibrium = sync_converges and not async_converges\n\n        # Convert numpy.bool_ to Python's native bool for consistent string formatting\n        return [bool(sync_converges), bool(async_converges), bool(breaks_equilibrium)]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, both regimes converge)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.2, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 2 (asynchronous breaks equilibrium)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.9, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 3 (both regimes diverge)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 1.1, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 4 (boundary for asynchronous: oscillation)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.5, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 5 (initial at equilibrium)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.3, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 'p_star', 'p_m1': 'p_star'},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case['a'], case['b'], case['c'], case['d'],\n                              case['alpha'], case['T'], case['eps'], case['W'],\n                              case['p0'], case['p_m1'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Produces a string like \"[[True,False,True],[True,True,False]]\"\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "存量-流量一致性（Stock-flow consistency）是建立可信经济模型的基石。与纸面推导不同，在计算机模拟中，我们很容易在不经意间违反基本的守恒定律（例如货币守恒）。本练习将说明为何必须在代理人规则中强制执行复式记账逻辑，并提供一种动手方法来构建一个“健全性检查”机制，以实时检测模型中“无中生有”的货币创造，从而保证模型的内部一致性。",
            "id": "4124530",
            "problem": "考虑一个基于主体的计算经济学 (Agent-Based Computational Economics, ACE) 模型，其中有限的一组主体（由 $i \\in \\{1,\\dots,N\\}$ 索引）持有货币余额 $B_i(t)$，并在离散时间索引 $t$ 进行双边支付。设 $T_{ij}(t) \\ge 0$ 表示在步骤 $t$ 期间从主体 $i$ 到主体 $j$ 的支付流，且 $T_{ii}(t) = 0$。设 $X_i(t)$ 代表对主体 $i$ 的外生注入（例如，来自政府部门的转移支付），$Z_i(t)$ 代表从主体 $i$ 的外生提取（例如，税收），两者均以相同的货币单位计量。基于规则的交互步骤根据执行支付和外生流的主体规则来更新余额。该模型在私人双边支付方面是封闭的，任何总货币量的净变化都必须归因于外生流。目标是解决以下问题：\n\n用数学术语解释，为什么必须在主体规则中强制执行明确的会计恒等式，以防止虚假货币的产生。具体来说，论证确保每笔记录的支付都表示为付款方的减少和收款方的相应增加的必要性，从而使总货币量在除了已知的外生注入和提取之外保持守恒。然后，设计一个运行时验证测试，在给定步骤 $t$ 的已实现支付 $T_{ij}(t)$ 和外生流 $X_i(t)$ 及 $Z_i(t)$ 的情况下，检测主体规则的执行是否违反了会计恒等式。\n\n您的验证测试必须源于基本的预算约束和存量-流量一致性，而不是来自简便公式。它必须通过计算由该步骤记录的交易和外生流引起的每个主体的余额变化来运行，然后检查总变化是否与一个除了外生流之外的封闭系统相一致。您必须指定并实现一个容差以处理浮点运算，并且您必须选择该容差以稳健地区分真实的违规行为与可忽略的数值漂移。\n\n实现一个完整、可运行的程序，该程序：\n- 为下面套件中的每个测试用例模拟一个清算步骤。\n- 根据指定的故障模式，应用强制执行或故意违反精确复式记账更新的主体规则。\n- 计算已实现规则执行所隐含的总残差，并使用指定的容差将其与已知的净外生流进行比较。\n- 为每个测试用例输出一个布尔值，`True` 表示检测到违规，`False` 表示未检测到。\n\n测试套件。使用以下 $N$、支付矩阵 $T$、外生注入 $X$、外生提取 $Z$、故障模式和容差：\n- 案例 $1$ (正常路径，封闭系统，正确规则)：$N = 3$，\n  $T = \\begin{bmatrix} 0  10  0 \\\\ 0  0  5 \\\\ 7  0  0 \\end{bmatrix}$，\n  $X = [0,0,0]$，$Z = [0,0,0]$，\n  无故障，容差 $ \\varepsilon = 10^{-12} $。\n- 案例 $2$ (单规则违规，封闭系统)：$N = 3$，\n  $T = \\begin{bmatrix} 0  10  0 \\\\ 0  0  5 \\\\ 7  0  0 \\end{bmatrix}$，\n  $X = [0,0,0]$，$Z = [0,0,0]$，\n  在边 $(i=1,j=2)$ 上出现“跳过扣款”故障模式，容差 $ \\varepsilon = 10^{-12} $。\n- 案例 $3$ (近边界数值漂移)：$N = 2$，\n  $T = \\begin{bmatrix} 0  0.1 \\\\ 0.1  0 \\end{bmatrix}$，\n  $X = [0,0]$，$Z = [0,0]$，\n  故障模式“漂移”，向主体 1 的变化量增加 $10^{-12}$，容差 $ \\varepsilon = 10^{-9} $。\n- 案例 $4$ (与规则一致的外生注入)：$N = 4$，\n  $T = \\begin{bmatrix} 0  20  0  0 \\\\ 0  0  15  0 \\\\ 5  0  0  10 \\\\ 0  0  0  0 \\end{bmatrix}$，\n  $X = [100,0,0,0]$，$Z = [0,0,0,0]$，\n  无故障，容差 $ \\varepsilon = 10^{-12} $。\n- 案例 $5$ (外生注入加规则违规)：$N = 4$，\n  $T = \\begin{bmatrix} 0  20  0  0 \\\\ 0  0  15  0 \\\\ 5  0  0  10 \\\\ 0  0  0  0 \\end{bmatrix}$，\n  $X = [100,0,0,0]$，$Z = [0,0,0,0]$，\n  在边 $(i=3,j=4)$ 上出现“跳过扣款”故障模式，容差 $ \\varepsilon = 10^{-12} $。\n\n说明：\n- “在边 $(i,j)$ 上跳过扣款”是指从 $i$ 到 $j$ 的支付中，付款方 $i$ 的余额减少被省略，而收款方 $j$ 的余额增加仍然被应用。\n- “漂移”是指应用于指定主体的、未建模的、微小的余额增量，该增量未被记录为外生流；这用于模拟可忽略的数值误差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots,r_5]$），其中每个 $r_k$ 是上述顺序中第 $k$ 个案例的布尔结果。不涉及物理单位。不适用角度。任何地方都不得使用百分比；如果需要，请将任何比率或分数表示为小数或精确分数。",
            "solution": "核心原则是存量-流量一致性：每一个流量都是存量的变化，在一个封闭的私人双边支付网络中，流量的记录方式必须能在除了明确建模的外生来源外，保持总货币量守恒。在基于主体的计算经济学（ACE）中，执行支付的主体规则必须满足预算约束的复式记账逻辑。对于每笔从主体 $i$ 到主体 $j$ 的金额为 $T_{ij}(t)$ 的支付，必须在 $B_i(t)$ 中有 $T_{ij}(t)$ 的减少，并在 $B_j(t)$ 中有相应的 $T_{ij}(t)$ 的增加。这种强制执行确保了所有主体因私人双边支付而产生的余额变化之和等于 $0$，这反映了在一个封闭的货币流网络中的守恒性。\n\n形式化基础。设 $B_i(t)$ 表示主体 $i$ 在时间 $t$ 的货币余额。设一步内已实现的变化为 $\\Delta B_i(t)$。在任何遵守复式记账和预算约束的模型中，每一步的变化是由收款、付款和外生流引起的。将收款表示为 $R_i(t) = \\sum_{j=1}^{N} T_{ji}(t)$，付款表示为 $P_i(t) = \\sum_{j=1}^{N} T_{ij}(t)$。对于外生注入 $X_i(t)$ 和提取 $Z_i(t)$，主体规则应实现\n$$\n\\Delta B_i(t) = R_i(t) - P_i(t) + X_i(t) - Z_i(t).\n$$\n对所有主体求和，并利用私人双边支付中 $\\sum_{i=1}^{N} R_i(t) = \\sum_{i=1}^{N} P_i(t)$ 这一事实，可得\n$$\n\\sum_{i=1}^{N} \\Delta B_i(t) = \\sum_{i=1}^{N} \\big(X_i(t) - Z_i(t)\\big).\n$$\n这个恒等式编码了一个封闭的私人支付系统下的存量-流量一致性。在规则层面强制执行该恒等式可以防止意外的货币创造（“虚假货币”）：例如，如果付款方的扣款被省略而收款方的增款被应用，那么总的变化量之和将超过净外生流，从而无中生有地创造了货币。\n\n运行时验证。一个稳健的运行时测试必须能够检测在一个步骤中主体规则的实际执行是否遵守了总量恒等式。使用规则执行语义（包括任何故障）构建每个主体的变化量。计算总残差\n$$\n\\rho(t) \\equiv \\sum_{i=1}^{N} \\Delta B_i(t) - \\sum_{i=1}^{N} \\big(X_i(t) - Z_i(t)\\big).\n$$\n如果模型正确地为私人双边支付强制执行了复式记账，那么 $\\rho(t)$ 在浮点数值误差范围内应等于 $0$。验证测试将 $|\\rho(t)|$ 与一个容差 $\\varepsilon > 0$ 进行比较：如果 $|\\rho(t)| > \\varepsilon$，则宣告存在违规；否则，接受为一致。容差 $ \\varepsilon $ 的选择应大于典型的机器舍入误差，同时相对于具有经济意义的流量幅度而言仍然很小；例如，对于 $10^0$ 数量级的流量，$ \\varepsilon = 10^{-12} $，而对于增加了 $10^{-12}$ 数量级微小漂移的情况，$ \\varepsilon = 10^{-9} $。\n\n算法设计。对于每个测试用例：\n- 对所有 $i$ 初始化 $\\Delta B_i(t) = 0$。\n- 对于每个有支付 $T_{ij}(t)$ 的有序对 $(i,j)$：\n  - 将 $T_{ij}(t)$ 加到 $\\Delta B_j(t)$ 中以表示收款方的增量；如果存在“双重贷记”故障，则加两次。\n  - 从 $\\Delta B_i(t)$ 中减去 $T_{ij}(t)$ 以表示付款方的减量；如果为 $(i,j)$ 指定了“跳过扣款”故障，则省略此减法。\n- 处理完所有支付后，将外生注入 $X_i(t)$ 加到每个 $\\Delta B_i(t)$ 中，并减去外生提取 $Z_i(t)$。\n- 如果存在“漂移”故障，则将指定的微小漂移值加到相应的 $\\Delta B_i(t)$ 中，以模拟未建模的数值误差。\n- 通过从 $\\sum_i \\Delta B_i(t)$ 中减去已知的净外生流 $\\sum_i \\big(X_i(t) - Z_i(t)\\big)$ 来计算残差 $\\rho(t)$。\n- 如果 $|\\rho(t)| > \\varepsilon$，则返回 `True`，否则返回 `False`。\n\n与 Leon Walras 定律的联系。在一般均衡理论中，Walras 定律断言，当除一个市场外所有市场都处于均衡状态时，所有市场的超额需求之和为零。在货币流方面，强制执行每个主体的预算恒等式与系统级约束相一致，即总供需失衡在没有外部来源的情况下不能产生净金融资产。因此，在主体规则中实施复式记账约束可确保总货币守恒在封闭系统中成立，而残差测试则验证了该守恒性没有因规则执行错误而受到破坏。\n\n测试用例结果：\n- 案例 $1$：没有外生流的正确规则得出 $\\rho(t) = 0$；$|\\rho(t)| \\le \\varepsilon$；输出 `False`。\n- 案例 $2$：在 $(i=1,j=2)$ 上跳过扣款会增加一个没有外生流支持的净额 $10$，因此 $\\rho(t) = 10$；$|\\rho(t)| > \\varepsilon$；输出 `True`。\n- 案例 $3$：$10^{-12}$ 的漂移产生 $\\rho(t) = 10^{-12}$；当 $\\varepsilon = 10^{-9}$ 时，$|\\rho(t)| \\le \\varepsilon$；输出 `False`。\n- 案例 $4$：净外生注入 $100$ 已被核算；总变化等于净外生流；$\\rho(t) = 0$；输出 `False`。\n- 案例 $5$：存在 $100$ 的外生注入，但在 $(i=3,j=4)$ 上跳过扣款会额外增加 $10$；$\\rho(t) = 10$；$|\\rho(t)| > \\varepsilon$；输出 `True`。\n\n在计算上，由于需要对密集支付矩阵的所有 $T_{ij}(t)$ 条目进行迭代，该算法每步的运行时间为 $O(N^2)$；在稀疏情况下，其运行时间为 $O(E)$，其中 $E$ 是非零支付的数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef detect_violation(n, payments, exog_inj, exog_tax, faults, epsilon):\n    \"\"\"\n    Compute per-agent balance changes Delta B induced by payments and exogenous flows,\n    apply specified faults to emulate rule violations, and detect aggregate identity violation.\n\n    Parameters:\n        n (int): Number of agents.\n        payments (np.ndarray): NxN matrix T where T[i,j] is payment from i to j.\n        exog_inj (np.ndarray): Length-N vector of exogenous injections X.\n        exog_tax (np.ndarray): Length-N vector of exogenous withdrawals Z.\n        faults (dict): Fault specification:\n            - 'skip_deduct': set of (i,j) edges where payer decrement is omitted.\n            - 'double_credit': set of (i,j) edges where receiver increment is applied twice.\n            - 'drift': length-N vector added to Delta B not counted as exogenous flows.\n        epsilon (float): Tolerance for violation detection.\n\n    Returns:\n        bool: True if violation is detected (abs(residual) > epsilon), else False.\n    \"\"\"\n    delta = np.zeros(n, dtype=float)\n\n    # Apply payments with potential faults.\n    # For each payment from i to j, add to receiver, subtract from payer unless skip_deduct fault.\n    skip = faults.get('skip_deduct', set())\n    dblc = faults.get('double_credit', set())\n    drift = faults.get('drift', np.zeros(n, dtype=float))\n\n    # Iterate over all possible edges\n    for i in range(n):\n        for j in range(n):\n            amt = payments[i, j]\n            if amt == 0.0:\n                continue\n            # Receiver increment\n            delta[j] += amt\n            if (i, j) in dblc:\n                delta[j] += amt  # apply double credit fault\n\n            # Payer decrement unless skipped\n            if (i, j) not in skip:\n                delta[i] -= amt\n            # else: skip deduction -> violation potential\n\n    # Add exogenous injections and subtract taxes\n    delta += exog_inj\n    delta -= exog_tax\n\n    # Apply drift fault (unmodeled small changes)\n    delta += drift\n\n    # Aggregate residual should be zero in a closed system except for net exogenous flows.\n    net_exog = float(np.sum(exog_inj) - np.sum(exog_tax))\n    residual = float(np.sum(delta) - net_exog)\n\n    return abs(residual) > epsilon\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1: N=3, closed system, correct rules\n    n1 = 3\n    T1 = np.array([[0.0, 10.0, 0.0],\n                   [0.0, 0.0, 5.0],\n                   [7.0, 0.0, 0.0]], dtype=float)\n    X1 = np.array([0.0, 0.0, 0.0], dtype=float)\n    Z1 = np.array([0.0, 0.0, 0.0], dtype=float)\n    faults1 = {'skip_deduct': set(), 'double_credit': set(), 'drift': np.zeros(n1, dtype=float)}\n    eps1 = 1e-12\n\n    # Case 2: N=3, single-rule violation (skip deduction on edge (0,1))\n    n2 = 3\n    T2 = T1.copy()\n    X2 = X1.copy()\n    Z2 = Z1.copy()\n    faults2 = {'skip_deduct': {(0, 1)}, 'double_credit': set(), 'drift': np.zeros(n2, dtype=float)}\n    eps2 = 1e-12\n\n    # Case 3: N=2, near-boundary numeric drift\n    n3 = 2\n    T3 = np.array([[0.0, 0.1],\n                   [0.1, 0.0]], dtype=float)\n    X3 = np.array([0.0, 0.0], dtype=float)\n    Z3 = np.array([0.0, 0.0], dtype=float)\n    drift3 = np.array([1e-12, 0.0], dtype=float)  # tiny unmodeled drift\n    faults3 = {'skip_deduct': set(), 'double_credit': set(), 'drift': drift3}\n    eps3 = 1e-9\n\n    # Case 4: N=4, exogenous injection consistent with rules\n    n4 = 4\n    T4 = np.array([[0.0, 20.0, 0.0, 0.0],\n                   [0.0, 0.0, 15.0, 0.0],\n                   [5.0, 0.0, 0.0, 10.0],\n                   [0.0, 0.0, 0.0, 0.0]], dtype=float)\n    X4 = np.array([100.0, 0.0, 0.0, 0.0], dtype=float)\n    Z4 = np.array([0.0, 0.0, 0.0, 0.0], dtype=float)\n    faults4 = {'skip_deduct': set(), 'double_credit': set(), 'drift': np.zeros(n4, dtype=float)}\n    eps4 = 1e-12\n\n    # Case 5: N=4, exogenous injection plus rule violation (skip deduction on edge (2,3))\n    n5 = 4\n    T5 = T4.copy()\n    X5 = X4.copy()\n    Z5 = Z4.copy()\n    faults5 = {'skip_deduct': {(2, 3)}, 'double_credit': set(), 'drift': np.zeros(n5, dtype=float)}\n    eps5 = 1e-12\n\n    test_cases = [\n        (n1, T1, X1, Z1, faults1, eps1),\n        (n2, T2, X2, Z2, faults2, eps2),\n        (n3, T3, X3, Z3, faults3, eps3),\n        (n4, T4, X4, Z4, faults4, eps4),\n        (n5, T5, X5, Z5, faults5, eps5),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, T, X, Z, faults, eps = case\n        result = detect_violation(n, T, X, Z, faults, eps)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习旨在连接模拟输出与真实世界的经济指标，填补微观行为与宏观现象之间的鸿沟。在运行了一个能够生成财富分布的有效模型之后，下一步是量化其宏观特征。本练习将提供一个分步指南，指导您如何直接从异质代理人的离散财富数据中，计算出衡量不平等程度的标准指标——基尼系数（Gini coefficient），从而将微观层面的结果转化为有意义的宏观统计量。",
            "id": "4124558",
            "problem": "考虑一个在基于代理人的计算经济学（ACE）框架下，通过基于代理人的模型（ABM）模拟的最小交换经济体。在这个经济体中，一个由 $N$ 个代理人组成的封闭群体以固定的储蓄倾向进行随机双边交易。经过足够长的瞬态过程后，该模型在代理人之间产生了一个稳态的离散财富分布。您观察到 $N=12$ 个代理人在运行结束时的财富（按非递减顺序排序）如下：\n$$\n1,\\; 1,\\; 2,\\; 3,\\; 3,\\; 4,\\; 5,\\; 8,\\; 12,\\; 15,\\; 30,\\; 36.\n$$\n使用分配不平等的第一性原理定义。洛伦兹曲线 $L(p)$ 定义为最底层的 $p \\in [0,1]$ 比例的代理人所持有的总财富份额，而基尼系数 $G$ 则由基于洛伦兹曲线面积的连续公式定义。假设每个代理人具有相同的人口权重，并通过在对应于 $k=0,1,\\dots,N$ 时 $p_k = k/N$ 处的累计份额点之间进行分段线性插值来构建经验洛伦兹曲线。\n\n使用上述定义和假设，从该离散分布中计算基尼系数 $G$。将您的最终答案表示为 $[0,1]$ 范围内的纯数，并四舍五入到四位有效数字。",
            "solution": "该问题要求计算一个由 $N=12$ 个代理人组成的群体的离散财富分布的基尼系数。解题过程必须遵循所提供的定义：基尼系数 $G$ 源自经验洛伦兹曲线 $L(p)$ 下的面积，该曲线通过分段线性插值构建。\n\n首先，我们确立基本定义。洛伦兹曲线 $L(p)$ 代表最底层的 $p$ 比例人口所持有的累计财富份额，其中 $p \\in [0,1]$。基尼系数 $G$ 定义为完全平等线（$y=p$）与洛伦兹曲线 $L(p)$ 之间面积的两倍。该面积由 $\\int_0^1 (p - L(p)) dp = \\int_0^1 p dp - \\int_0^1 L(p) dp = \\frac{1}{2} - \\int_0^1 L(p) dp$ 给出。因此，基尼系数的公式为：\n$$\nG = 2 \\left( \\frac{1}{2} - \\int_0^1 L(p) dp \\right) = 1 - 2 \\int_0^1 L(p) dp\n$$\n问题指明，经验洛伦兹曲线是根据与每个代理人对应的离散数据点构建的。设代理人的财富按非递减顺序排序为 $w_i$，其中 $i=1, 2, \\dots, N$。人口规模为 $N=12$。给定的财富为：\n$w_1=1$, $w_2=1$, $w_3=2$, $w_4=3$, $w_5=3$, $w_6=4$, $w_7=5$, $w_8=8$, $w_9=12$, $w_{10}=15$, $w_{11}=30$, $w_{12}=36$。\n\n人口总财富 $W_{total}$ 是个人财富的总和：\n$$\nW_{total} = \\sum_{i=1}^{N} w_i = 1+1+2+3+3+4+5+8+12+15+30+36 = 120\n$$\n洛伦兹曲线由点 $(p_k, L_k)$ 构成，其中 $p_k$ 是前 $k$ 个代理人的累计人口比例，$L_k$ 是累计财富比例。由于每个代理人具有相同的人口权重，累计人口比例为 $p_k = k/N$，其中 $k=0, 1, \\dots, N$。前 $k$ 个代理人的累计财富为 $C_k = \\sum_{i=1}^k w_i$。累计财富比例为 $L_k = C_k / W_{total}$。\n\n我们构造洛伦兹曲线的点：\n- 对于 $k=0$：$p_0 = 0/12 = 0$。$C_0 = 0$。$L_0 = 0/120 = 0$。\n- 对于 $k=1$：$p_1 = 1/12$。$C_1 = 1$。$L_1 = 1/120$。\n- 对于 $k=2$：$p_2 = 2/12$。$C_2 = 1+1=2$。$L_2 = 2/120$。\n- 对于 $k=3$：$p_3 = 3/12$。$C_3 = 2+2=4$。$L_3 = 4/120$。\n- 对于 $k=4$：$p_4 = 4/12$。$C_4 = 4+3=7$。$L_4 = 7/120$。\n- 对于 $k=5$：$p_5 = 5/12$。$C_5 = 7+3=10$。$L_5 = 10/120$。\n- 对于 $k=6$：$p_6 = 6/12$。$C_6 = 10+4=14$。$L_6 = 14/120$。\n- 对于 $k=7$：$p_7 = 7/12$。$C_7 = 14+5=19$。$L_7 = 19/120$。\n- 对于 $k=8$：$p_8 = 8/12$。$C_8 = 19+8=27$。$L_8 = 27/120$。\n- 对于 $k=9$：$p_9 = 9/12$。$C_9 = 27+12=39$。$L_9 = 39/120$。\n- 对于 $k=10$：$p_{10} = 10/12$。$C_{10} = 39+15=54$。$L_{10} = 54/120$。\n- 对于 $k=11$：$p_{11} = 11/12$。$C_{11} = 54+30=84$。$L_{11} = 84/120$。\n- 对于 $k=12$：$p_{12} = 12/12 = 1$。$C_{12} = 84+36=120$。$L_{12} = 120/120 = 1$。\n\n积分 $\\int_0^1 L(p) dp$ 表示分段线性洛伦兹曲线下的面积。该面积可以计算为 $N$ 个梯形面积之和。第 $k$ 个梯形定义在区间 $[p_{k-1}, p_k]$ 上。其面积 $A_k$ 由下式给出：\n$$\nA_k = \\frac{1}{2} (L_{k-1} + L_k) (p_k - p_{k-1})\n$$\n由于 $p_k - p_{k-1} = (k/N) - ((k-1)/N) = 1/N$，总面积 $A$ 为：\n$$\nA = \\sum_{k=1}^{N} A_k = \\sum_{k=1}^{N} \\frac{1}{2} (L_{k-1} + L_k) \\frac{1}{N} = \\frac{1}{2N} \\sum_{k=1}^{N} (L_{k-1} + L_k)\n$$\n展开求和式：\n$$\nA = \\frac{1}{2N} ( (L_0+L_1) + (L_1+L_2) + \\dots + (L_{N-1}+L_N) ) = \\frac{1}{2N} (L_0 + 2\\sum_{k=1}^{N-1} L_k + L_N)\n$$\n给定 $N=12$, $L_0=0$, 并且 $L_{12}=1$，我们有：\n$$\nA = \\frac{1}{2(12)} (0 + 2\\sum_{k=1}^{11} L_k + 1) = \\frac{1}{24} (1 + 2\\sum_{k=1}^{11} L_k)\n$$\n我们计算累计财富比例之和 $\\sum_{k=1}^{11} L_k$：\n$$\n\\sum_{k=1}^{11} L_k = \\frac{1}{W_{total}} \\sum_{k=1}^{11} C_k = \\frac{1}{120} (1+2+4+7+10+14+19+27+39+54+84)\n$$\n累计财富之和为：\n$$\n\\sum_{k=1}^{11} C_k = 261\n$$\n所以，比例之和为：\n$$\n\\sum_{k=1}^{11} L_k = \\frac{261}{120}\n$$\n现在，将此代入面积 $A$ 的表达式中：\n$$\nA = \\frac{1}{24} \\left(1 + 2 \\times \\frac{261}{120}\\right) = \\frac{1}{24} \\left(1 + \\frac{522}{120}\\right) = \\frac{1}{24} \\left(\\frac{120}{120} + \\frac{522}{120}\\right) = \\frac{1}{24} \\left(\\frac{642}{120}\\right) = \\frac{642}{2880}\n$$\n该分数可以化简。分子和分母都可以被 $6$ 整除：$642/6 = 107$ 且 $2880/6 = 480$。\n$$\nA = \\frac{107}{480}\n$$\n最后，我们计算基尼系数 $G$：\n$$\nG = 1 - 2A = 1 - 2 \\left(\\frac{107}{480}\\right) = 1 - \\frac{214}{480} = 1 - \\frac{107}{240}\n$$\n$$\nG = \\frac{240}{240} - \\frac{107}{240} = \\frac{133}{240}\n$$\n为了给出最终答案，我们将此分数转换为小数，并四舍五入到四位有效数字。\n$$\nG = \\frac{133}{240} \\approx 0.5541666...\n$$\n四舍五入到四位有效数字得到 $0.5542$。",
            "answer": "$$\n\\boxed{0.5542}\n$$"
        }
    ]
}