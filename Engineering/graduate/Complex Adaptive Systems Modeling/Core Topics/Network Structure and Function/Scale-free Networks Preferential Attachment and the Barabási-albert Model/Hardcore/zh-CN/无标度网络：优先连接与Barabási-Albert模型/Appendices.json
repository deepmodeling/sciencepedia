{
    "hands_on_practices": [
        {
            "introduction": "Barabási-Albert模型的魅力不仅在于其能够生成具有特定宏观统计特性的网络，还在于它能精确描述网络中单个节点的动态演化过程。通过运用连续场近似方法，我们可以追踪一个节点自加入网络后的度（degree）增长轨迹。这个练习将引导你分析网络中“最老”的节点——即紧随初始种子网络后第一个加入的节点——其期望度如何随时间演变，从而直观地理解“富者愈富”机制对早期进入者的影响。",
            "id": "4141922",
            "problem": "考虑网络增长的 Barabási-Albert (BA) 模型，其中在每个离散时间步，都会添加一个新节点，该节点与 $m$ 个不同的现有节点创建 $m \\geq 1$ 条边。新边在时间 $t$ 选择现有节点 $i$ 的概率与其当前度 $k_i(t)$ 成正比，即，连接是线性的优先连接：节点 $i$ 的选择概率为 $k_i(t)$ 除以总度 $\\sum_{j} k_j(t)$。该过程在时间 $t = m$ 开始，初始种子网络是一个包含 $m$ 个节点的完全图。将时间 $t$ 定义为该步骤中网络的总节点数。设“最老”的节点是种子网络之后引入的第一个节点，它在时间 $t_i = m + 1$ 诞生，并在诞生时初始度为 $m$，因为它在到达时创建了 $m$ 条边。\n\n使用基于上述定义和事实的连续平均场近似，推导这个最老节点的期望度 $k_{\\mathrm{old}}(t)$ 作为 $t$ 和 $m$ 的函数，并确定其随 $t$ 的渐近标度关系。请以闭合形式给出 $k_{\\mathrm{old}}(t)$ 的最终表达式。不需要进行数值舍入，也无物理单位。",
            "solution": "问题要求解 Barabási-Albert (BA) 网络中最早添加的节点的期望度 $k_{\\mathrm{old}}(t)$，作为时间 $t$ 和参数 $m$ 的函数。“最老”节点被指定为初始种子网络之后添加的第一个节点，在时间 $t_i = m+1$ 引入。\n\n我们将使用连续平均场近似。在此框架中，节点度 $k_i$ 和时间 $t$ 被视为连续变量。节点 $i$ 的期望度的变化率 $\\frac{d k_i}{dt}$ 由新节点添加的边数 $m$ 乘以其中一条边连接到节点 $i$ 的概率 $\\Pi_i$ 给出。由于在每个时间步都会添加一个新节点，因此相对于时间 $t$ 的变化率为：\n$$\n\\frac{d k_i(t)}{dt} = m \\Pi_i(t)\n$$\n优先连接规则指出，新边连接到现有节点 $i$ 的概率 $\\Pi_i(t)$ 与该节点的度 $k_i(t)$ 成正比。\n$$\n\\Pi_i(t) = \\frac{k_i(t)}{\\sum_{j} k_j(t)}\n$$\n此处，求和是对时间 $t$ 时网络中存在的所有节点 $j$ 进行的。总度 $\\sum_{j} k_j(t)$ 等于网络中总边数 $E(t)$ 的 $2$ 倍。\n\n根据问题描述，网络在时间 $t=m$ 开始，初始为一个包含 $m$ 个节点的完全图 $K_m$。$K_m$ 中的边数为 $E(m) = \\frac{m(m-1)}{2}$。在随后的每个时间步 $t' > m$，都会添加一个新节点，并形成 $m$ 条新边。时间变量 $t$ 被定义为网络中的总节点数。因此，在时间 $t$，自开始以来总共添加了 $t-m$ 个节点。在时间 $t$ 的总边数为：\n$$\nE(t) = E(m) + m(t-m) = \\frac{m(m-1)}{2} + m(t-m)\n$$\n在时间 $t$ 网络的总度为：\n$$\n\\sum_j k_j(t) = 2E(t) = 2\\left(\\frac{m(m-1)}{2} + m(t-m)\\right) = m(m-1) + 2m(t-m) = 2mt - m^2 - m\n$$\n对于大的 $t$，特别是 $t \\gg m$，主导项占主导地位：\n$$\n\\sum_j k_j(t) \\approx 2mt\n$$\n这是 BA 模型连续平均场分析中的一个标准近似，我们将采用它。问题中对“渐近标度”的要求进一步证明了关注大 $t$ 时的行为是合理的。\n\n将连接概率和总度的近似值代入速率方程，我们得到节点 $i$ 的期望度的微分方程：\n$$\n\\frac{d k_i(t)}{dt} = m \\frac{k_i(t)}{2mt} = \\frac{k_i(t)}{2t}\n$$\n这是一个可分离的一阶线性常微分方程。我们可以将其重新排列为：\n$$\n\\frac{d k_i}{k_i} = \\frac{dt}{2t}\n$$\n为了求出时间 $t$ 时的度 $k_i(t)$，我们将此方程从节点引入的时间 $t_i$ 积分到当前时间 $t$。初始条件是节点诞生时的度 $k_i(t_i)$。\n$$\n\\int_{k_i(t_i)}^{k_i(t)} \\frac{1}{k'} dk' = \\int_{t_i}^{t} \\frac{1}{2\\tau} d\\tau\n$$\n进行积分得到：\n$$\n\\left[ \\ln(k') \\right]_{k_i(t_i)}^{k_i(t)} = \\frac{1}{2} \\left[ \\ln(\\tau) \\right]_{t_i}^{t}\n$$\n$$\n\\ln(k_i(t)) - \\ln(k_i(t_i)) = \\frac{1}{2} (\\ln(t) - \\ln(t_i))\n$$\n这可以使用对数性质重写为：\n$$\n\\ln\\left(\\frac{k_i(t)}{k_i(t_i)}\\right) = \\ln\\left(\\left(\\frac{t}{t_i}\\right)^{1/2}\\right)\n$$\n对两边取指数，得到任何节点 $i$ 的度演化的一般解：\n$$\nk_i(t) = k_i(t_i) \\left(\\frac{t}{t_i}\\right)^{1/2}\n$$\n现在，我们将此通用解应用于问题中定义的特定“最老”节点。该节点在时间 $t_i = m+1$ 引入。在引入时，它会与现有节点创建 $m$ 个链接。因此，它在诞生时的初始度为 $k_{\\mathrm{old}}(t_i) = k_{\\mathrm{old}}(m+1) = m$。\n\n将这些特定的初始条件 $t_i = m+1$ 和 $k_i(t_i) = m$ 代入通用解，我们得到最老节点的期望度作为 $t$ 和 $m$ 的函数：\n$$\nk_{\\mathrm{old}}(t) = m \\left(\\frac{t}{m+1}\\right)^{1/2}\n$$\n该表达式可以写为：\n$$\nk_{\\mathrm{old}}(t) = \\frac{m}{\\sqrt{m+1}} t^{1/2}\n$$\n从这个闭合形式的表达式中，我们可以确定最老节点的度随时间 $t$ 的渐近标度关系。度与时间的平方根成正比：\n$$\nk_{\\mathrm{old}}(t) \\propto t^{1/2}\n$$\n这样就完成了所要求的推导。$k_{\\mathrm{old}}(t)$ 的最终闭合形式表达式为 $m\\sqrt{\\frac{t}{m+1}}$。",
            "answer": "$$\\boxed{m \\sqrt{\\frac{t}{m+1}}}$$"
        },
        {
            "introduction": "从单个节点的视角转向整个网络的宏观结构，一个核心问题是：优先连接机制最终会塑造出怎样的网络拓扑？此练习旨在从第一性原理出发，通过建立速率方程来推导BA网络在成熟阶段的稳态度分布$P(k)$。你不仅需要推导出这个著名的幂律分布的精确形式，还需要通过计算其归一化总和与平均度，来验证其作为一个合法的概率分布所应具备的基本属性，并加深对网络平均度$\\langle k \\rangle = 2m$这一基本事实的理解。",
            "id": "4141924",
            "problem": "考虑如下定义的 Barabási-Albert (BA) 网络增长模型：从一个包含 $m_{0}$ 个节点的初始连通种子网络开始。在每个离散时间步 $t \\mapsto t+1$，引入一个新节点，并通过 $m$ 条新边将其连接到 $m$ 个现有节点上，其中这 $m$ 个目标节点中的每一个都是独立选择的，其被选择的概率与其当前度数成正比。记 $N_{k}(t)$ 为时间 $t$ 时度为 $k$ 的节点的期望数量，$E(t)$ 为时间 $t$ 时的边数，$P(k)$ 为大时间 $t$ 极限下的稳态度分布，定义为 $P(k) = \\lim_{t \\to \\infty} N_{k}(t)/N(t)$，其中 $N(t)$ 是时间 $t$ 时的节点数。\n\n仅从以下几点出发：\n- 择优连接规则，即在时间 $t$ 时，一个度为 $k_{i}(t)$ 的给定现有节点 $i$ 接收到 $m$ 条新边之一的概率为 $k_{i}(t)/\\sum_{j} k_{j}(t)$，\n- 守恒定律 $\\sum_{j} k_{j}(t) = 2 E(t)$，以及 $E(t)$ 的增长规律 $E(t+1) = E(t) + m$，\n请从第一性原理推导当 $k \\ge m$ 时稳态度分布 $P(k)$ 的闭式表达式。然后，使用您推导出的 $P(k)$，计算以下两个量\n$$S_{1} = \\sum_{k=m}^{\\infty} P(k) \\quad \\text{和} \\quad S_{2} = \\sum_{k=m}^{\\infty} k\\,P(k),$$\n并根据大时间 $t$ 极限下网络的期望平均度 $\\langle k \\rangle$ 来解释 $S_{2}$。\n\n您的最终答案必须是包含 $S_{1}$ 和 $S_{2}$ 的单一解析表达式，排列成一个行矩阵。不需要进行数值取整。",
            "solution": "该问题经验证具有科学依据、问题明确、客观且自洽。它是复杂网络研究中的一个典型问题。我们可以开始求解。\n\nBarabási-Albert (BA) 模型的稳态度分布 $P(k)$ 的推导基于速率方程方法，该方法通常被称为连续介质近似或平均场近似。我们分析度为 $k$ 的节点的期望数量（记为 $N_k(t)$）随时间的变化。\n\n首先，我们确定在大时间 $t$ 时节点的总数 $N(t)$ 和边的总数 $E(t)$。网络在 $t=0$ 时从 $m_0$ 个节点开始。在每个时间步，增加一个新节点。因此，时间 $t$ 时的节点总数为 $N(t) = m_0 + t$。对于大时间 $t$，我们可以近似为 $N(t) \\approx t$。\n在每一步中，会增加 $m$ 条新边。因此，边数的增长规律为 $E(t+1) = E(t) + m$。这意味着对于大时间 $t$，边的总数为 $E(t) \\approx m t$。\n所有节点的度之和由守恒定律 $\\sum_{j} k_j(t) = 2 E(t)$ 给出。使用 $E(t)$ 的大时间 $t$ 近似，我们有 $\\sum_{j} k_j(t) \\approx 2mt$。\n\n一条新边连接到度为 $k_i(t)$ 的特定现有节点 $i$ 的概率 $\\Pi_i$ 由择优连接规则给出：\n$$ \\Pi_i = \\frac{k_i(t)}{\\sum_{j} k_j(t)} \\approx \\frac{k_i(t)}{2mt} $$\n由于我们关心的是某个度的节点的期望数量，我们考虑一条新边连接到*任何*度为 $k$ 的节点的总概率。存在 $N_k(t)$ 个这样的节点。假设所有相同度的节点在统计上是等价的，那么一条特定的新边连接到任何度为 $k$ 的节点的概率是：\n$$ \\Pi(k) = \\sum_{i \\text{ with } k_i=k} \\Pi_i = \\sum_{i \\text{ with } k_i=k} \\frac{k}{2mt} = \\frac{k N_k(t)}{2mt} $$\n在每个时间步，会增加 $m$ 条新边。连接到度为 $k$ 的节点的新边的期望数量是 $m \\times \\Pi(k)$：\n$$ \\Delta N_{\\text{attach}}(k) = m \\frac{k N_k(t)}{2mt} = \\frac{k N_k(t)}{2t} $$\n\n现在，我们可以写出 $N_k(t)$ 的速率方程。度为 $k$ 的节点数量因两个过程而改变：\n1.  一个度为 $k-1$ 的节点获得一条连接，变为度为 $k$ 的节点。这会增加 $N_k(t)$。该过程的速率是度为 $k-1$ 的节点获得连接的速率，即 $\\frac{(k-1) N_{k-1}(t)}{2t}$。\n2.  一个度为 $k$ 的节点获得一条连接，变为度为 $k+1$ 的节点。这会减少 $N_k(t)$。该过程的速率是 $\\frac{k N_k(t)}{2t}$。\n\n对于 $k > m$，速率方程为：\n$$ N_k(t+1) - N_k(t) = \\frac{(k-1) N_{k-1}(t)}{2t} - \\frac{k N_k(t)}{2t} $$\n对于 $k=m$，情况有所不同。在每个时间步，会引入一个度为 $m$ 的新节点。这提供了一个源项 $1$。度为 $m$ 的节点也可以获得连接并变为度 $m+1$。因此，对于 $k=m$：\n$$ N_m(t+1) - N_m(t) = 1 - \\frac{m N_m(t)}{2t} $$\n我们现在采用连续介质近似，将 $t$ 视为连续变量，并用导数 $\\frac{d N_k(t)}{dt}$ 替换差分 $N_k(t+1) - N_k(t)$。\n稳态度分布定义为 $P(k) = \\lim_{t \\to \\infty} \\frac{N_k(t)}{N(t)}$。在大时间 $t$ 极限下，$N(t) \\approx t$，因此我们可以假设一个形式为 $N_k(t) = P(k) N(t) \\approx P(k)t$ 的时不变解。对 $t$ 求导得到 $\\frac{d N_k(t)}{dt} = P(k)$。\n\n将这些代入速率方程：\n对于 $k > m$：\n$$ P(k) = \\frac{(k-1) (t P(k-1))}{2t} - \\frac{k (t P(k))}{2t} $$\n$$ P(k) = \\frac{k-1}{2} P(k-1) - \\frac{k}{2} P(k) $$\n$$ P(k) \\left(1 + \\frac{k}{2}\\right) = \\frac{k-1}{2} P(k-1) $$\n$$ P(k) \\left(\\frac{k+2}{2}\\right) = \\frac{k-1}{2} P(k-1) $$\n这得到了递推关系：\n$$ P(k) = \\frac{k-1}{k+2} P(k-1) \\quad \\text{for } k > m $$\n\n对于 $k=m$：\n$$ P(m) = 1 - \\frac{m (t P(m))}{2t} $$\n$$ P(m) = 1 - \\frac{m}{2} P(m) $$\n$$ P(m) \\left(1 + \\frac{m}{2}\\right) = 1 $$\n$$ P(m) = \\frac{1}{1 + m/2} = \\frac{2}{m+2} $$\n这给出了 $P(m)$ 的值，我们可以用它来解出 $k \\ge m$ 时 $P(k)$ 的递推关系。\n$$ P(k) = P(k-1) \\frac{k-1}{k+2} = P(k-2) \\frac{k-2}{k+1} \\frac{k-1}{k+2} = \\dots = P(m) \\prod_{j=m+1}^{k} \\frac{j-1}{j+2} $$\n让我们计算这个乘积项：\n$$ \\prod_{j=m+1}^{k} \\frac{j-1}{j+2} = \\frac{(m)(m+1)\\dots(k-1)}{(m+3)(m+4)\\dots(k+2)} $$\n这可以用阶乘来表示：\n$$ \\frac{(k-1)!/(m-1)!}{(k+2)!/(m+2)!} = \\frac{(k-1)!}{(m-1)!} \\frac{(m+2)!}{(k+2)!} = \\frac{(m+2)(m+1)m}{k(k+1)(k+2)} $$\n现在，我们代入 $P(m)$ 和该乘积的表达式：\n$$ P(k) = \\left(\\frac{2}{m+2}\\right) \\left(\\frac{m(m+1)(m+2)}{k(k+1)(k+2)}\\right) $$\n$$ P(k) = \\frac{2m(m+1)}{k(k+1)(k+2)} $$\n这就是当 $k \\ge m$ 时稳态度分布的闭式表达式。\n\n现在我们计算 $S_1$ 和 $S_2$。\n$$ S_1 = \\sum_{k=m}^{\\infty} P(k) = \\sum_{k=m}^{\\infty} \\frac{2m(m+1)}{k(k+1)(k+2)} = 2m(m+1) \\sum_{k=m}^{\\infty} \\frac{1}{k(k+1)(k+2)} $$\n我们对和中的项使用部分分式分解：\n$$ \\frac{1}{k(k+1)(k+2)} = \\frac{A}{k} + \\frac{B}{k+1} + \\frac{C}{k+2} $$\n解出系数得到 $A=1/2$, $B=-1$, $C=1/2$。所以：\n$$ \\frac{1}{k(k+1)(k+2)} = \\frac{1}{2k} - \\frac{1}{k+1} + \\frac{1}{2(k+2)} = \\frac{1}{2} \\left[ \\left(\\frac{1}{k} - \\frac{1}{k+1}\\right) - \\left(\\frac{1}{k+1} - \\frac{1}{k+2}\\right) \\right] $$\n令 $h(k) = \\frac{1}{k} - \\frac{1}{k+1}$。该项为 $\\frac{1}{2}[h(k) - h(k+1)]$。这个和变成了一个裂项级数：\n$$ \\sum_{k=m}^{\\infty} \\frac{1}{2}[h(k) - h(k+1)] = \\frac{1}{2} \\left[ (h(m)-h(m+1)) + (h(m+1)-h(m+2)) + \\dots \\right] $$\n该和收敛于 $\\frac{1}{2} h(m)$。\n$$ \\sum_{k=m}^{\\infty} \\frac{1}{k(k+1)(k+2)} = \\frac{1}{2}h(m) = \\frac{1}{2}\\left(\\frac{1}{m} - \\frac{1}{m+1}\\right) = \\frac{1}{2} \\frac{m+1-m}{m(m+1)} = \\frac{1}{2m(m+1)} $$\n将此结果代回 $S_1$ 的表达式中：\n$$ S_1 = 2m(m+1) \\left( \\frac{1}{2m(m+1)} \\right) = 1 $$\n这个结果是符合预期的，因为对于 $k \\ge m$ 的 $P(k)$ 必须是一个正确归一化的概率分布（对于大型网络，度小于 $m$ 的节点数量可以忽略不计）。\n\n接下来，我们计算 $S_2$：\n$$ S_2 = \\sum_{k=m}^{\\infty} k P(k) = \\sum_{k=m}^{\\infty} k \\frac{2m(m+1)}{k(k+1)(k+2)} = 2m(m+1) \\sum_{k=m}^{\\infty} \\frac{1}{(k+1)(k+2)} $$\n我们再次使用部分分式：$\\frac{1}{(k+1)(k+2)} = \\frac{1}{k+1} - \\frac{1}{k+2}$。这会得到另一个裂项级数：\n$$ \\sum_{k=m}^{\\infty} \\left( \\frac{1}{k+1} - \\frac{1}{k+2} \\right) = \\left(\\frac{1}{m+1} - \\frac{1}{m+2}\\right) + \\left(\\frac{1}{m+2} - \\frac{1}{m+3}\\right) + \\dots $$\n这个和收敛于第一项，即 $\\frac{1}{m+1}$。\n将此结果代回 $S_2$ 的表达式中：\n$$ S_2 = 2m(m+1) \\left( \\frac{1}{m+1} \\right) = 2m $$\n\n最后，我们解释 $S_2$。网络的期望平均度定义为 $\\langle k \\rangle = \\sum_{k} k P(k)$。在大时间 $t$ 极限下，度小于 $m$ 的节点（只能是初始种子网络中的节点）的比例变得可以忽略不计。因此，求和可以从 $k=m$ 到 $\\infty$。\n$$ \\langle k \\rangle_{\\text{large-}t} = \\sum_{k=m}^{\\infty} k P(k) = S_2 $$\n所以，$S_2$ 代表了网络在大时间极限下的期望平均度。这可以从第一性原理得到验证。平均度为 $\\langle k \\rangle(t) = \\frac{\\sum_j k_j(t)}{N(t)} = \\frac{2E(t)}{N(t)}$。在大时间 $t$ 极限下，$E(t) \\approx mt$ 且 $N(t) \\approx t$。\n$$ \\lim_{t \\to \\infty} \\langle k \\rangle(t) = \\lim_{t \\to \\infty} \\frac{2mt}{t} = 2m $$\n这证实了我们关于 $S_2 = 2m$ 的计算及其作为网络平均度的解释。\n\n要求的答案是一个包含 $S_1$ 和 $S_2$ 的行矩阵。\n$S_1 = 1$\n$S_2 = 2m$\n最终答案是 $(1, 2m)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2m\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论推导为我们揭示了BA模型的内在规律，而计算机模拟则是验证理论、探索复杂情景不可或缺的工具。本实践任务要求你设计并实现一个高效的算法来生成一个BA网络，其核心挑战在于如何精确且快速地执行与节点度成正比的优先连接抽样。通过完成这个编程练习，你将把抽象的数学模型转化为可运行的代码，并对模型定义的微观生长规则如何一步步构建出宏观网络结构获得具体而深刻的认识。",
            "id": "4141898",
            "problem": "您需要设计并实现一个高效的模拟算法，以生成一个具有优先连接特性的 Barabási–Albert (BA) 网络。BA 网络通过逐一添加节点来增长，每个新节点以与其当前度成正比的概率连接到现有节点。您的任务是编写一个程序，该程序根据指定的参数构建这样一个网络，并为一个小型的测试套件返回可验证的摘要统计数据。\n\n基本原理包括以下标准定义和事实。\n\n- 一个包含 $N$ 个节点的简单无向网络具有一个度序列 $\\{k_i\\}_{i=0}^{N-1}$，其中 $k_i$ 是与节点 $i$ 相关联的边的数量。握手引理指出 $\\sum_{i=0}^{N-1} k_i = 2E$，其中 $E$ 是边的总数。\n- Barabási–Albert 优先连接机制从一个由 $m_0$ 个节点组成的初始连通种子网络开始，逐步增长为一个无向网络。在每个离散时间步 $t \\in \\{m_0, m_0+1, \\dots, N-1\\}$，一个新节点加入网络，并与 $m$ 个不同的现有节点形成 $m$ 条边。新节点连接到现有节点 $i$ 的概率与其当前度 $k_i$ 成正比，即 $P(i) = k_i / \\sum_j k_j$，其中 $j$ 遍历所有现有节点。\n- 为避免初始化时出现退化的零概率分母，并确保初始种子网络是连通的且所有节点度均为正，取 $m_0 = \\max(m, 2)$，并将种子初始化为一个包含 $m_0$ 个节点的团（clique）。初始边的数量为 $E_{\\mathrm{init}} = \\frac{m_0(m_0-1)}{2}$，每个种子节点的初始度为 $m_0 - 1$。\n\n算法要求。\n\n- 实现必须能够以与当前度成正比的概率对现有节点进行动态采样，每次采样的时间复杂度为 $O(\\log N)$。您必须实现一个二进制索引树（BIT；也称为 Fenwick 树）或等效的数据结构，该结构支持以下操作：\n  1. 对节点权重（度）进行点更新，时间复杂度为 $O(\\log N)$。\n  2. 前缀和查询，时间复杂度为 $O(\\log N)$。\n  3. 基于累积权重的逆变换采样：给定一个目标值 $u \\in [0, \\sum_j k_j)$，在 $O(\\log N)$ 时间内找到最小的索引 $i$，使得到 $i$ 的累积和严格大于 $u$。\n- 在为新节点连接 $m$ 条边的单个时间步内，您必须在现有节点中进行无放回抽样。为防止在该步骤内与同一目标节点形成多条边，请在二进制索引树中将被选中的目标的权重临时置零，然后在选定所有 $m$ 个目标后恢复并增加它们的权重。不允许自环。\n\n模拟输入与输出。\n\n- 对于每一对参数 $(N, m)$，其中 $N \\in \\mathbb{Z}_{\\ge 1}$ 且 $m \\in \\mathbb{Z}_{\\ge 1}$，使用上述过程构建网络，并设 $m_0 = \\max(m, 2)$。无需显式存储边；维护度序列 $\\{k_i\\}$ 即可。通过按照测试套件中的规定显式地为伪随机数生成器设置种子，以实现确定性随机。\n- 对每次模拟，计算：\n  1. 总边数 $E$。\n  2. 最大度 $k_{\\max} = \\max_i k_i$。\n  3. 尺度归一化的最大度比率 $r = \\dfrac{k_{\\max}}{m \\sqrt{N}}$，表示为实数。\n  4. 一个布尔标志 $H$，指示所计算的度序列是否严格满足握手引理，即 $\\sum_i k_i = 2E$ 是否成立。\n\n测试套件。\n\n为以下三个测试用例运行您的程序，每个用例都指定了伪随机数种子以确保可复现性。在每个案例中，初始化 $m_0 = \\max(m, 2)$ 并将 $m_0$ 个节点的种子网络初始化为团。\n\n- 案例 A: $(N, m, \\text{seed}) = (1000, 1, 42)$。\n- 案例 B: $(N, m, \\text{seed}) = (5000, 3, 7)$。\n- 案例 C: $(N, m, \\text{seed}) = (3, 3, 123)$。\n\n最终输出格式。\n\n- 您的程序应生成单行输出，其中包含一个由三个列表组成的逗号分隔列表，每个内部列表对应一个测试用例，顺序为 A、B、C。每个内部列表必须采用 $[E, k_{\\max}, r, H]$ 的形式，其中 $E$ 和 $k_{\\max}$ 是整数，$r$ 是一个四舍五入到小数点后六位的实数，$H$ 是一个布尔值。例如，输出行应如下所示：\n  [ [EA,kmaxA,rA,H_A], [EB,kmaxB,rB,H_B], [EC,kmaxC,rC,H_C] ]\n除了有效的 Python 列表格式所需之外，不要使用额外的空白字符。角度不适用，此问题中没有物理单位。所有结果都应按规定以纯数字或布尔值的形式返回。",
            "solution": "该问题要求设计并实现一种算法来模拟 Barabási-Albert (BA) 网络的增长。解决方案必须遵循特定的算法和性能要求，并以优先连接原则为核心。\n\n**基于原则的设计**\n\nBA 模型是一个动态过程，网络一次增长一个节点。其定义性特征是优先连接：新节点更有可能连接到已经具有高度的现有节点。这种“富者愈富”的现象导致了无标度度分布，这是许多现实世界网络的标志。\n\n**1. 算法核心：高效的加权采样**\n\n核心计算挑战在于如何根据连接概率 $P(i) = k_i / \\sum_j k_j$ 高效地对目标节点进行采样。度分布 $\\{k_i\\}$ 在每个时间步都会改变，因此采样机制必须是动态的。创建一个包含所有节点的加权列表并从中采样是一种天真的方法，效率极低，因为该列表在每一步都必须重建。\n\n一种更复杂的方法是逆变换采样。我们可以将所有现有节点 $\\{k_0, k_1, \\dots, k_{t-1}\\}$ 的度概念化为一个离散概率分布。总权重是所有度的总和，即 $\\sum k_j = S$。我们可以从区间 $[0, S)$ 中均匀采样一个值 $u$。所选的目标节点 $i$ 是其度“覆盖”了值 $u$ 的节点；形式上，它是满足 $\\sum_{j=0}^{i} k_j > u$ 的最小索引 $i$。\n\n为了高效地实现这一点，我们需要一个能够实现以下功能的数据结构：\n1.  快速计算度的前缀和 ($\\sum_{j=0}^{i} k_j$)。\n2.  在节点度发生变化时能快速更新。\n3.  高效地找到与给定累积值 $u$ 对应的索引 $i$。\n\n**二进制索引树（BIT）**，或称 Fenwick 树，是完成此任务的理想数据结构。它支持在 $O(\\log N)$ 时间内进行点更新（更改单个 $k_i$）和前缀和查询，其中 $N$ 是最大节点数。\n\n**2. 二进制索引树实现**\n\n将实现一个 BIT 来存储节点的度。其关键操作将是：\n- `update(index, delta)`: 将 `delta` 加到索引为 `index` 的节点的度上，在 $O(\\log N)$ 时间内通过树结构传播此更改。\n- `query(index)`: 在 $O(\\log N)$ 时间内计算从节点 0 到 `index` 的累积度总和。\n- `find_target(u)`: 此函数执行逆变换采样。它在节点索引 $\\{0, \\dots, N-1\\}$ 上使用二分搜索，并在其中调用 `query` 函数，以找到满足累积度总和 `query(i)` 严格大于随机值 $u$ 的最小索引 $i$。此搜索需要 $O(\\log N)$ 次迭代，每次迭代都涉及一次 $O(\\log N)$ 的查询，因此找到单个目标的总复杂度为 $O((\\log N)^2)$。\n\n**3. 模拟算法**\n\n对于给定的参数集 $(N, m)$，模拟过程如下：\n\n**a. 初始化：**\n- 网络从一个包含 $m_0 = \\max(m, 2)$ 个节点的种子网络开始。\n- 我们初始化一个大小为 $N$ 的度数组 `degrees` 和一个同样大小的 BIT。\n- 为形成初始的 $m_0$ 团，我们在前 $m_0$ 个节点的每一对之间建立一条边。\n- 这 $m_0$ 个节点中每个节点的初始度为 $k_i = m_0 - 1$。\n- `degrees` 数组和 BIT 也相应更新：对于每个 $i \\in \\{0, \\dots, m_0-1\\}$，我们设置 `degrees[i] = m_0 - 1` 并调用 `bit.update(i, m_0 - 1)`。\n- 初始边数为 $E = \\frac{m_0(m_0-1)}{2}$。\n\n**b. 网络增长：**\n- 主模拟循环为每个待添加的新节点进行迭代，索引从 $t = m_0$ 到 $N-1$。\n- 在每一步 $t$，我们添加新节点 `t`，并与 $m$ 个不同的现有节点形成 $m$ 条边。\n- **无放回抽样**：为选择 $m$ 个不同的目标，我们遵循问题规定的程序：\n    1.  初始化一个列表 `selected_targets`，用于存储当前步骤中选择的节点。\n    2.  使用一个列表 `temp_modifications` 来跟踪对 BIT 所做的临时更改。\n    3.  我们循环 $m$ 次。在每次迭代中：\n        i.   通过查询 BIT 计算当前的总度数和 $S$：$S = \\text{bit.query}(t-1)$。\n        ii.  生成一个在 $[0, S)$ 区间内均匀分布的随机数 $u$。\n        iii. 使用 `find_target(u)` 函数找到目标节点的索引 `target`。\n        iv.  将 `target` 添加到 `selected_targets` 中。\n        v.   为防止此节点在本步骤中被再次选中，其在 BIT 中的权重被临时置零。我们找到它在 BIT 中的当前权重（可能已受同一步骤中先前选择的影响）并减去它。此操作 `(target, weight_removed)` 存储在 `temp_modifications` 中。\n    4.  选定所有 $m$ 个目标后，我们通过撤销临时修改，将 BIT 恢复到步骤 $t$ 开始时的状态。对于 `temp_modifications` 中的每个 `(target, weight_removed)`，我们调用 `bit.update(target, weight_removed)`。\n    5.  最后，我们应用步骤 $t$ 的永久性更新：\n        - 对于 `selected_targets` 中的每个不同节点 `v`，其度增加一。我们更新 `degrees[v] += 1` 并调用 `bit.update(v, 1)`。\n        - 新节点 `t` 的度为 $m$。我们设置 `degrees[t] = m` 并调用 `bit.update(t, m)`。\n        - 总边数增加 $m$：$E \\leftarrow E + m$。\n\n**c. 最终计算：**\n- 增长循环完成后，`degrees` 数组包含 $N$ 个节点的网络的最终度序列。\n- 总边数 $E$ 在整个模拟过程中都得到了跟踪。\n- 最大度通过 $k_{\\max} = \\max(\\text{degrees})$ 找到。\n- 归一化比率计算为 $r = \\frac{k_{\\max}}{m \\sqrt{N}}$。\n- 通过检查所有计算出的度的总和 $\\sum_{i=0}^{N-1} k_i$ 是否恰好等于 $2E$ 来验证握手引理。结果存储在布尔标志 $H$ 中。\n\n此设计忠实地实现了 Barabási-Albert 模型，同时满足了所有算法和性能要求。使用固定的 PRNG 种子确保了给定测试套件的确定性和可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BIT:\n    \"\"\"Binary Indexed Tree (Fenwick Tree) for 0-indexed arrays.\"\"\"\n    \n    def __init__(self, size):\n        \"\"\"Initializes a BIT of a given size.\"\"\"\n        self.size = size\n        self.tree = np.zeros(size + 1, dtype=np.int64)\n\n    def update(self, index, delta):\n        \"\"\"Adds delta to the element at index.\"\"\"\n        i = index + 1\n        while i = self.size:\n            self.tree[i] += delta\n            i += i  -i\n\n    def query(self, index):\n        \"\"\"Computes the prefix sum up to index (inclusive).\"\"\"\n        if index  0:\n            return 0\n        s = 0\n        i = index + 1\n        while i > 0:\n            s += self.tree[i]\n            i -= i  -i\n        return s\n\n    def get_value(self, index):\n        \"\"\"Gets the exact value at a given index.\"\"\"\n        return self.query(index) - self.query(index - 1)\n\n    def find_target(self, cumulative_freq):\n        \"\"\"\n        Finds the smallest index i such that the cumulative frequency (prefix sum)\n        up to i is strictly greater than cumulative_freq.\n        This is implemented using a binary search over the indices.\n        Complexity: O((log N)^2)\n        \"\"\"\n        low, high = 0, self.size - 1\n        target_index = -1\n        \n        while low = high:\n            mid = (low + high) // 2\n            if self.query(mid) > cumulative_freq:\n                target_index = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return target_index\n\ndef run_simulation(N, m, seed):\n    \"\"\"\n    Runs a single Barabási-Albert network simulation.\n    \n    Args:\n        N (int): Total number of nodes in the final network.\n        m (int): Number of edges each new node adds.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        list: A list containing [E, k_max, r, H].\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    m0 = max(m, 2)\n\n    # Handle the trivial case where N = m0\n    if N = m0:\n        degrees = np.zeros(N, dtype=int)\n        if N > 0:\n            for i in range(N):\n                degrees[i] = N - 1\n        \n        total_edges = N * (N - 1) // 2 if N > 0 else 0\n        max_degree = N - 1 if N > 0 else 0\n        if N > 0 and m > 0:\n             ratio = max_degree / (m * np.sqrt(N))\n        else:\n             ratio = 0.0\n        \n        handshake_holds = (np.sum(degrees) == 2 * total_edges)\n        return [total_edges, int(max_degree), ratio, handshake_holds]\n\n    # ------ Initialization ------\n    degrees = np.zeros(N, dtype=int)\n    bit = BIT(N)\n    \n    # Initialize the m0-clique\n    initial_degree = m0 - 1\n    total_edges = m0 * (m0 - 1) // 2\n    \n    for i in range(m0):\n        degrees[i] = initial_degree\n        bit.update(i, initial_degree)\n        \n    # ------ Network Growth ------\n    for t in range(m0, N): # t is the index of the new node\n        \n        selected_targets = []\n        temp_modifications = []\n        num_existing_nodes = t\n\n        for _ in range(m):\n            total_degree_sum = bit.query(num_existing_nodes - 1)\n            if total_degree_sum == 0:\n                break\n            \n            rand_val = rng.uniform(0, total_degree_sum)\n            target_node = bit.find_target(rand_val)\n            \n            selected_targets.append(target_node)\n            \n            # Temporarily zero out the weight of the selected node\n            weight_in_bit = bit.get_value(target_node)\n            bit.update(target_node, -weight_in_bit)\n            temp_modifications.append((target_node, weight_in_bit))\n\n        # Restore BIT to pre-selection state\n        for node_idx, weight in temp_modifications:\n            bit.update(node_idx, weight)\n        \n        # Apply permanent updates for the current step\n        for target_node in np.unique(selected_targets):\n            degrees[target_node] += 1\n            bit.update(target_node, 1)\n            \n        degrees[t] = m\n        bit.update(t, m)\n        total_edges += m\n\n    # ------ Final Calculations ------\n    max_degree = np.max(degrees) if N > 0 else 0\n    ratio = max_degree / (m * np.sqrt(N))\n    handshake_holds = (np.sum(degrees) == 2 * total_edges)\n\n    return [int(total_edges), int(max_degree), ratio, handshake_holds]\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs simulations, and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        # (N, m, seed)\n        (1000, 1, 42),\n        (5000, 3, 7),\n        (3, 3, 123),\n    ]\n\n    all_results = []\n    for N, m, seed in test_cases:\n        result = run_simulation(N, m, seed)\n        \n        # Format the result list elements\n        E, k_max, r, H = result\n        r_str = f\"{r:.6f}\"\n        H_str = str(H)\n        \n        inner_list_str = f\"[{E},{k_max},{r_str},{H_str}]\"\n        all_results.append(inner_list_str)\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(all_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}