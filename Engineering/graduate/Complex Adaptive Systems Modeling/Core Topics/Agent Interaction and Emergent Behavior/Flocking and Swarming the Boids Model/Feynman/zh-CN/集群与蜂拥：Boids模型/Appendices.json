{
    "hands_on_practices": [
        {
            "introduction": "要想真正理解Boids模型，我们必须首先深入其核心引擎：逐帧更新的规则。本练习将通过一个包含三个智能体的小型集群，带你详细地手动完成一个模拟步骤的完整计算。通过亲手计算并整合分离、对齐和凝聚这三个向量，你将具体地理解这些相互竞争的影响如何最终决定每个智能体的运动，其中还包括邻域定义和速度上限等实际细节。",
            "id": "4123912",
            "problem": "考虑经典的平面 Boids 群集行为智能体模型 (ABM)，其中每个智能体 $i \\in \\{1,\\dots,N\\}$ 在时间 $t$ 具有位置 $x_i(t) \\in \\mathbb{R}^2$ 和速度 $v_i(t) \\in \\mathbb{R}^2$。该模型结合了三种操控力：分离、对齐和凝聚，每种力都根据由固定半径定义的局部邻域计算得出。令智能体 $i$ 和 $j$ 之间的欧几里得距离为 $d_{ij}(t) = \\|x_i(t) - x_j(t)\\|$。在时间 $t$ 定义三个邻域集合，\n$$\nS_i(t) = \\{ j \\neq i : d_{ij}(t) \\leq r_s \\}, \\quad\nA_i(t) = \\{ j \\neq i : d_{ij}(t) \\leq r_a \\}, \\quad\nC_i(t) = \\{ j \\neq i : d_{ij}(t) \\leq r_c \\},\n$$\n其分离半径为 $r_s$，对齐半径为 $r_a$，凝聚半径为 $r_c$。经典的转向向量如下：\n1. 分离：$s_i(t) = \\sum_{j \\in S_i(t)} \\dfrac{x_i(t) - x_j(t)}{\\|x_i(t) - x_j(t)\\|}$。\n2. 对齐：$a_i(t) = \\left(\\dfrac{1}{|A_i(t)|}\\sum_{j \\in A_i(t)} v_j(t)\\right) - v_i(t)$，如果 $|A_i(t)| \\geq 1$，否则 $a_i(t) = (0,0)$。\n3. 凝聚：$c_i(t) = \\left(\\dfrac{1}{|C_i(t)|}\\sum_{j \\in C_i(t)} x_j(t)\\right) - x_i(t)$，如果 $|C_i(t)| \\geq 1$，否则 $c_i(t) = (0,0)$。\n\n假设瞬时转向加速度为 $u_i(t) = \\alpha s_i(t) + \\beta a_i(t) + \\gamma c_i(t)$，其中权重 $\\alpha, \\beta, \\gamma \\in \\mathbb{R}$ 为固定值。速度在一个时间步长 $\\Delta t$ 内的前向欧拉更新由 $v_i'(t+\\Delta t) = v_i(t) + \\Delta t\\, u_i(t)$ 给出。通过设置以下规则来强制执行速度上限 $v_{\\max} > 0$\n$$\nv_i(t+\\Delta t) =\n\\begin{cases}\nv_i'(t+\\Delta t),  \\text{如果 } \\|v_i'(t+\\Delta t)\\| \\leq v_{\\max}, \\\\\n\\dfrac{v_{\\max}}{\\|v_i'(t+\\Delta t)\\|}\\, v_i'(t+\\Delta t),  \\text{如果 } \\|v_i'(t+\\Delta t)\\| > v_{\\max},\n\\end{cases}\n$$\n并通过 $x_i(t+\\Delta t) = x_i(t) + \\Delta t\\, v_i(t+\\Delta t)$ 更新位置。\n\n对于一个由 $N=3$ 个智能体组成的系统，其在时间 $t$ 的初始条件如下：\n$$\nx_1(t) = (0,0), \\quad x_2(t) = (1,0), \\quad x_3(t) = (4,3),\n$$\n$$\nv_1(t) = (1,0), \\quad v_2(t) = (0,1), \\quad v_3(t) = (-1,0),\n$$\n参数如下\n$$\n\\Delta t = \\frac{1}{2}, \\quad v_{\\max} = 1, \\quad \\alpha = \\frac{1}{2}, \\quad \\beta = \\frac{1}{3}, \\quad \\gamma = \\frac{1}{4}, \\quad r_s = \\frac{3}{2}, \\quad r_a = 4, \\quad r_c = 6,\n$$\n使用上述规则，计算 $i \\in \\{1,2,3\\}$ 的单步更新 $(x_i(t+\\Delta t), v_i(t+\\Delta t))$。精确表示最终值（在出现有理数和根式时使用它们）。将最终答案表示为包含以下分量的单行矩阵，分量按顺序排列\n$$\nx_{1,x}(t+\\Delta t), \\ x_{1,y}(t+\\Delta t), \\ v_{1,x}(t+\\Delta t), \\ v_{1,y}(t+\\Delta t), \\ x_{2,x}(t+\\Delta t), \\ x_{2,y}(t+\\Delta t), \\ v_{2,x}(t+\\Delta t), \\ v_{2,y}(t+\\Delta t), \\ x_{3,x}(t+\\Delta t), \\ x_{3,y}(t+\\Delta t), \\ v_{3,x}(t+\\Delta t), \\ v_{3,y}(t+\\Delta t).\n$$\n无需四舍五入。",
            "solution": "该问题要求计算一个由 $N=3$ 个智能体组成的系统的位置和速度的单步更新。所有初始状态和参数均已明确给出。我们将按顺序为每个智能体计算更新。\n\n首先，计算所有智能体对之间的初始欧几里得距离，以确定邻域。\n$d_{12} = \\|x_1 - x_2\\| = \\|(0-1, 0-0)\\| = 1$。\n$d_{13} = \\|x_1 - x_3\\| = \\|(0-4, 0-3)\\| = \\|(-4,-3)\\| = \\sqrt{16+9} = 5$。\n$d_{23} = \\|x_2 - x_3\\| = \\|(1-4, 0-3)\\| = \\|(-3,-3)\\| = \\sqrt{18} = 3\\sqrt{2} \\approx 4.24$。\n\n参数半径为 $r_s = 1.5$, $r_a = 4$, $r_c = 6$。\n\n### 智能体 1 的更新\n\n1.  **邻域**: $d_{12}=1 \\le r_s, r_a, r_c$。$d_{13}=5$ 大于 $r_s$ 和 $r_a$，但小于等于 $r_c$。\n    *   分离邻域 $S_1(t) = \\{2\\}$。\n    *   对齐邻域 $A_1(t) = \\{2\\}$。\n    *   凝聚邻域 $C_1(t) = \\{2, 3\\}$。\n\n2.  **转向向量**:\n    *   分离 $s_1(t) = \\frac{x_1-x_2}{d_{12}} = \\frac{(-1, 0)}{1} = (-1,0)$。\n    *   对齐 $a_1(t) = v_2 - v_1 = (0,1) - (1,0) = (-1,1)$。\n    *   凝聚 $c_1(t) = \\frac{1}{2}(x_2+x_3) - x_1 = \\frac{1}{2}(1+4, 0+3) - (0,0) = (\\frac{5}{2}, \\frac{3}{2})$。\n\n3.  **加速度与速度更新**:\n    $u_1(t) = \\frac{1}{2}s_1 + \\frac{1}{3}a_1 + \\frac{1}{4}c_1 = \\frac{1}{2}(-1,0) + \\frac{1}{3}(-1,1) + \\frac{1}{4}(\\frac{5}{2}, \\frac{3}{2}) = (-\\frac{1}{2}-\\frac{1}{3}+\\frac{5}{8}, \\frac{1}{3}+\\frac{3}{8}) = (-\\frac{5}{24}, \\frac{17}{24})$。\n    $v_1'(t+\\Delta t) = v_1(t) + \\Delta t \\, u_1(t) = (1,0) + \\frac{1}{2}(-\\frac{5}{24}, \\frac{17}{24}) = (\\frac{43}{48}, \\frac{17}{48})$。\n    $\\|v_1'\\|^2 = (\\frac{43}{48})^2 + (\\frac{17}{48})^2 = \\frac{1849 + 289}{2304} = \\frac{2138}{2304}  1^2$。速度无需限制。\n    $v_1(t+\\Delta t) = (\\frac{43}{48}, \\frac{17}{48})$。\n\n4.  **位置更新**:\n    $x_1(t+\\Delta t) = x_1(t) + \\Delta t \\, v_1(t+\\Delta t) = (0,0) + \\frac{1}{2}(\\frac{43}{48}, \\frac{17}{48}) = (\\frac{43}{96}, \\frac{17}{96})$。\n\n### 智能体 2 的更新\n\n1.  **邻域**: $d_{21}=1$。$d_{23}=3\\sqrt{2} \\approx 4.24$ 大于 $r_s$ 和 $r_a$，但小于等于 $r_c$。\n    *   $S_2(t) = \\{1\\}$。\n    *   $A_2(t) = \\{1\\}$。\n    *   $C_2(t) = \\{1, 3\\}$。\n\n2.  **转向向量**:\n    *   分离 $s_2(t) = \\frac{x_2-x_1}{d_{21}} = \\frac{(1, 0)}{1} = (1,0)$。\n    *   对齐 $a_2(t) = v_1 - v_2 = (1,0) - (0,1) = (1,-1)$。\n    *   凝聚 $c_2(t) = \\frac{1}{2}(x_1+x_3) - x_2 = \\frac{1}{2}(0+4, 0+3) - (1,0) = (2, \\frac{3}{2}) - (1,0) = (1, \\frac{3}{2})$。\n\n3.  **加速度与速度更新**:\n    $u_2(t) = \\frac{1}{2}s_2 + \\frac{1}{3}a_2 + \\frac{1}{4}c_2 = \\frac{1}{2}(1,0) + \\frac{1}{3}(1,-1) + \\frac{1}{4}(1, \\frac{3}{2}) = (\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}, -\\frac{1}{3}+\\frac{3}{8}) = (\\frac{13}{12}, \\frac{1}{24})$。\n    $v_2'(t+\\Delta t) = v_2(t) + \\Delta t \\, u_2(t) = (0,1) + \\frac{1}{2}(\\frac{13}{12}, \\frac{1}{24}) = (\\frac{13}{24}, \\frac{49}{48})$。\n    $\\|v_2'\\|^2 = (\\frac{13}{24})^2 + (\\frac{49}{48})^2 = (\\frac{26}{48})^2 + (\\frac{49}{48})^2 = \\frac{676+2401}{2304} = \\frac{3077}{2304} > 1^2$。速度需要限制。\n    $v_2(t+\\Delta t) = \\frac{v_{\\max}}{\\|v_2'\\|}v_2' = \\frac{1}{\\sqrt{3077}/48} (\\frac{26}{48}, \\frac{49}{48}) = (\\frac{26}{\\sqrt{3077}}, \\frac{49}{\\sqrt{3077}})$。\n\n4.  **位置更新**:\n    $x_2(t+\\Delta t) = x_2(t) + \\Delta t \\, v_2(t+\\Delta t) = (1,0) + \\frac{1}{2}(\\frac{26}{\\sqrt{3077}}, \\frac{49}{\\sqrt{3077}}) = (1 + \\frac{13}{\\sqrt{3077}}, \\frac{49}{2\\sqrt{3077}})$。\n\n### 智能体 3 的更新\n\n1.  **邻域**: $d_{31}=5$, $d_{32}=3\\sqrt{2} \\approx 4.24$。两者都大于 $r_s$ 和 $r_a$，但小于等于 $r_c$。\n    *   $S_3(t) = \\emptyset$。\n    *   $A_3(t) = \\emptyset$。\n    *   $C_3(t) = \\{1, 2\\}$。\n\n2.  **转向向量**:\n    *   $s_3(t)=(0,0)$。\n    *   $a_3(t)=(0,0)$。\n    *   $c_3(t) = \\frac{1}{2}(x_1+x_2) - x_3 = \\frac{1}{2}(0+1, 0+0) - (4,3) = (\\frac{1}{2},0) - (4,3) = (-\\frac{7}{2}, -3)$。\n\n3.  **加速度与速度更新**:\n    $u_3(t) = \\frac{1}{4}c_3 = \\frac{1}{4}(-\\frac{7}{2}, -3) = (-\\frac{7}{8}, -\\frac{3}{4})$。\n    $v_3'(t+\\Delta t) = v_3(t) + \\Delta t \\, u_3(t) = (-1,0) + \\frac{1}{2}(-\\frac{7}{8}, -\\frac{3}{4}) = (-1-\\frac{7}{16}, -\\frac{3}{8}) = (-\\frac{23}{16}, -\\frac{6}{16})$。\n    $\\|v_3'\\|^2 = (-\\frac{23}{16})^2 + (-\\frac{6}{16})^2 = \\frac{529+36}{256} = \\frac{565}{256} > 1^2$。速度需要限制。\n    $v_3(t+\\Delta t) = \\frac{v_{\\max}}{\\|v_3'\\|}v_3' = \\frac{1}{\\sqrt{565}/16}(-\\frac{23}{16}, -\\frac{6}{16}) = (-\\frac{23}{\\sqrt{565}}, -\\frac{6}{\\sqrt{565}})$。\n\n4.  **位置更新**:\n    $x_3(t+\\Delta t) = x_3(t) + \\Delta t \\, v_3(t+\\Delta t) = (4,3) + \\frac{1}{2}(-\\frac{23}{\\sqrt{565}}, -\\frac{6}{\\sqrt{565}}) = (4 - \\frac{23}{2\\sqrt{565}}, 3 - \\frac{3}{\\sqrt{565}})$。\n\n将所有12个分量按顺序组合，得到最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{43}{96}  \\frac{17}{96}  \\frac{43}{48}  \\frac{17}{48}  1 + \\frac{13}{\\sqrt{3077}}  \\frac{49}{2\\sqrt{3077}}  \\frac{26}{\\sqrt{3077}}  \\frac{49}{\\sqrt{3077}}  4 - \\frac{23}{2\\sqrt{565}}  3 - \\frac{3}{\\sqrt{565}}  -\\frac{23}{\\sqrt{565}}  -\\frac{6}{\\sqrt{565}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "当我们掌握了控制单个智能体的微观规则后，重点便转移到由这些互动所涌现出的宏观模式上。本练习将介绍几个关键的序参数——极化度 $\\Phi(t)$ 和旋转度 $\\kappa(t)$——它们为描述和分类集体运动提供了定量的语言。通过将这些度量应用于一个理想化的构型，你将学会如何从数学上区分高度组织化的行进集群（flocking）和协调一致的旋转涡旋（milling），这两种状态是集体行为研究中最基本的模式。",
            "id": "4123893",
            "problem": "考虑一个由类 Boids 相互作用规则（对齐、凝聚和分离）支配的自驱动个体二维聚集体，并在固定时间 $t=t_{0}$ 对其进行观察。设有 $N$ 个个体，其位置为 $\\{\\mathbf{r}_{i}(t)\\}_{i=1}^{N} \\subset \\mathbb{R}^{2}$，速度为 $\\{\\mathbf{v}_{i}(t)\\}_{i=1}^{N} \\subset \\mathbb{R}^{2}$。在时间 $t$ 定义以下序参量：\n- 极化度（对齐序参量）\n$$\n\\Phi(t) \\equiv \\frac{\\left\\|\\sum_{i=1}^{N} \\mathbf{v}_{i}(t)\\right\\|}{\\sum_{i=1}^{N} \\|\\mathbf{v}_{i}(t)\\|},\n$$\n其取值范围为 $[0,1]$，用于量化全局速度对齐程度。\n- 绕行参数（关于质心的归一化角动量）\n$$\n\\kappa(t) \\equiv \\frac{\\left\\|\\sum_{i=1}^{N} \\left(\\boldsymbol{\\rho}_{i}(t) \\times \\mathbf{v}_{i}(t)\\right)\\right\\|}{\\sum_{i=1}^{N} \\|\\boldsymbol{\\rho}_{i}(t)\\| \\,\\|\\mathbf{v}_{i}(t)\\|},\n$$\n其中 $\\boldsymbol{\\rho}_{i}(t) \\equiv \\mathbf{r}_{i}(t)-\\mathbf{r}_{\\mathrm{cm}}(t)$，而 $\\mathbf{r}_{\\mathrm{cm}}(t) \\equiv \\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{r}_{i}(t)$ 是质心。在二维情况下，$\\boldsymbol{\\rho}_{i}(t) \\times \\mathbf{v}_{i}(t)$ 表示将 $\\mathbb{R}^{2}$ 嵌入 $\\mathbb{R}^{3}$ 后得到的三维叉积的标量 $z$ 分量。参数 $\\kappa(t)\\in[0,1]$ 用于量化围绕质心的相干旋转程度。\n- 由回转半径测量的空间广度\n$$\nL(t) \\equiv \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\|\\boldsymbol{\\rho}_{i}(t)\\|^{2}},\n$$\n其单位为长度。\n\n在时间 $t=t_{0}$，考虑有 $N=6$ 个个体，它们位于一个以原点为中心、半径为 $R=10\\,\\mathrm{m}$ 的圆上。它们的位置和速度由角度 $\\theta_{k} \\in \\{0, \\frac{\\pi}{3}, \\frac{2\\pi}{3}, \\pi, \\frac{4\\pi}{3}, \\frac{5\\pi}{3}\\}$（角度以弧度为单位）给出，具体为\n$$\n\\mathbf{r}_{k}(t_{0}) = R\\begin{pmatrix}\\cos\\theta_{k} \\\\ \\sin\\theta_{k}\\end{pmatrix}, \\qquad \\mathbf{v}_{k}(t_{0}) = V\\begin{pmatrix}-\\sin\\theta_{k} \\\\ \\cos\\theta_{k}\\end{pmatrix},\n$$\n对于 $k=1,\\dots,6$，其中 $V=1\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$ 是共同速率，运动方向为逆时针切向。仅使用上述定义和标准的矢量微积分，计算 $\\Phi(t_{0})$、$\\kappa(t_{0})$ 和 $L(t_{0})$。然后，根据定性标准——集群运动（flocking）表现为高 $\\Phi(t)$ 和低 $\\kappa(t)$，绕行（milling）表现为低 $\\Phi(t)$ 和高 $\\kappa(t)$，而无序群集（disordered swarming）表现为低 $\\Phi(t)$ 和低 $\\kappa(t)$——来判断该构型属于哪种状态。\n\n将最终数值结果以行矩阵 $\\left(\\Phi(t_{0}),\\,\\kappa(t_{0}),\\,L(t_{0})\\right)$ 的形式报告。如果需要取近似值，请将最终数值结果四舍五入到四位有效数字。将 $L(t_{0})$ 以米为单位表示。",
            "solution": "该问题要求计算一个特定构型的三个宏观序参量：极化度 $\\Phi(t_0)$、绕行参数 $\\kappa(t_0)$ 和回转半径 $L(t_0)$。\n\n该系统由 $N=6$ 个个体组成，位于一个以原点为中心的半径为 $R=10\\,\\mathrm{m}$ 的圆上，形成一个正六边形。它们的速度大小均为 $V=1\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，方向为逆时针切向。\n\n1.  **计算质心 $\\mathbf{r}_{\\mathrm{cm}}(t_0)$ 和回转半径 $L(t_0)$**:\n    *   质心为 $\\mathbf{r}_{\\mathrm{cm}}(t_0) = \\frac{1}{N}\\sum_{k=1}^{6}\\mathbf{r}_{k}(t_0)$。由于个体的位置构成一个关于原点对称的正六边形，它们的向量和为零。因此，$\\mathbf{r}_{\\mathrm{cm}}(t_0) = \\mathbf{0}$。\n    *   这意味着相对位置向量 $\\boldsymbol{\\rho}_{k}(t_0) = \\mathbf{r}_{k}(t_0) - \\mathbf{r}_{\\mathrm{cm}}(t_0) = \\mathbf{r}_{k}(t_0)$。\n    *   每个个体到中心的距离为 $\\|\\boldsymbol{\\rho}_{k}(t_0)\\| = \\|\\mathbf{r}_{k}(t_0)\\| = R$。\n    *   回转半径为 $L(t_0) = \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\|\\boldsymbol{\\rho}_{k}(t_0)\\|^{2}} = \\sqrt{\\frac{1}{6}\\sum_{k=1}^{6}R^{2}} = \\sqrt{\\frac{6R^2}{6}} = R$。\n    *   因此，$L(t_0) = 10\\,\\mathrm{m}$。\n\n2.  **计算极化度 $\\Phi(t_0)$**:\n    *   $\\Phi(t_0) = \\frac{\\left\\|\\sum_{k=1}^{N} \\mathbf{v}_{k}(t_0)\\right\\|}{\\sum_{k=1}^{N} \\|\\mathbf{v}_{k}(t_0)\\|}$。\n    *   分母：每个个体的速率为 $\\|\\mathbf{v}_{k}(t_0)\\| = V=1$。所以分母为 $\\sum_{k=1}^{6} V = 6V = 6$。\n    *   分子：速度向量 $\\mathbf{v}_{k}$ 是位置向量 $\\mathbf{r}_{k}$ 逆时针旋转 $90^\\circ$ 并乘以 $V/R$ 得到的。由于位置向量之和为零（$\\sum \\mathbf{r}_k = \\mathbf{0}$），它们旋转后得到的向量之和也为零（$\\sum \\mathbf{v}_k = \\mathbf{0}$）。因此，分子为 $\\|\\mathbf{0}\\| = 0$。\n    *   所以，$\\Phi(t_0) = \\frac{0}{6} = 0$。\n\n3.  **计算绕行参数 $\\kappa(t_0)$**:\n    *   $\\kappa(t_0) = \\frac{\\left\\|\\sum_{k=1}^{N} \\left(\\boldsymbol{\\rho}_{k}(t_0) \\times \\mathbf{v}_{k}(t_0)\\right)\\right\\|}{\\sum_{k=1}^{N} \\|\\boldsymbol{\\rho}_{k}(t_0)\\| \\,\\|\\mathbf{v}_{k}(t_0)\\|}$。\n    *   分母：$\\sum_{k=1}^{N} \\|\\boldsymbol{\\rho}_{k}(t_0)\\| \\,\\|\\mathbf{v}_{k}(t_0)\\| = \\sum_{k=1}^{6} RV = 6RV = 6 \\times 10 \\times 1 = 60$。\n    *   分子：我们计算每个个体的二维叉积（标量）$\\boldsymbol{\\rho}_{k} \\times \\mathbf{v}_{k}$。\n        $\\boldsymbol{\\rho}_{k} = (R\\cos\\theta_{k}, R\\sin\\theta_{k})$\n        $\\mathbf{v}_{k} = (-V\\sin\\theta_{k}, V\\cos\\theta_{k})$\n        $\\boldsymbol{\\rho}_{k} \\times \\mathbf{v}_{k} = (R\\cos\\theta_{k})(V\\cos\\theta_{k}) - (R\\sin\\theta_{k})(-V\\sin\\theta_{k}) = RV(\\cos^2\\theta_{k} + \\sin^2\\theta_{k}) = RV$。\n        这个值对所有个体都是一样的，即 $10 \\times 1 = 10$。\n    *   所有叉积之和为 $\\sum_{k=1}^{6} RV = 6RV = 60$。其绝对值也是60。\n    *   因此，$\\kappa(t_0) = \\frac{60}{60} = 1$。\n\n**结论**:\n计算出的序参量为 $\\Phi(t_0) = 0$, $\\kappa(t_0) = 1$, $L(t_0) = 10\\,\\mathrm{m}$。\n根据给定的分类标准，低 $\\Phi$ 和高 $\\kappa$ 对应于**绕行（milling）**状态。这与我们的直觉相符：个体在一个完美的圆形轨道上同步运动，形成一个宏观的涡旋，但没有整体的平移运动。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  1  10\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "模拟预设规则只是建模的第一步，一个更关键的任务是确定能最佳解释观测现象或达成特定目标的模型参数。这个高级练习将参数校准视为一个优化问题，挑战你寻找能够促进集群飞行（高极化度）同时惩罚碰撞的规则权重 $(\\alpha, \\beta, \\gamma)$。你将探索“可微模拟”这一前沿概念，即利用自动微分技术高效计算优化模型参数所需梯度，从而将传统的基于智能体的建模与现代基于梯度的机器学习方法联系起来。",
            "id": "4123914",
            "problem": "考虑一个由 $N$ 个点智能体（boids）组成的种群，其索引为 $i \\in \\{1,\\dots,N\\}$，位置为 $\\mathbf{x}_i \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}_i \\in \\mathbb{R}^2$。其时间更新由一个单步离散时间的 Boids 规则定义，该规则结合了对齐（alignment）、凝聚（cohesion）和分离（separation）的影响。设参数 $\\alpha$、$\\beta$ 和 $\\gamma$ 为实标量，分别控制对齐、凝聚和分离的大小，并设 $\\Delta t$ 为时间步长。更新规则为\n$$\n\\mathbf{v}_i' = \\mathbf{v}_i + \\alpha \\,\\mathbf{A}_i + \\beta\\,\\mathbf{C}_i + \\gamma\\,\\mathbf{S}_i,\\quad\n\\mathbf{x}_i' = \\mathbf{x}_i + \\Delta t\\,\\mathbf{v}_i',\n$$\n其中，对齐项 $\\mathbf{A}_i$、凝聚项 $\\mathbf{C}_i$ 和分离项 $\\mathbf{S}_i$ 是根据当前状态 $(\\mathbf{x}_i,\\mathbf{v}_i)$ 和一个固定的邻域半径 $R$ 计算得出的，其定义如下，其中 $\\mathcal{N}_i = \\{ j \\neq i : \\|\\mathbf{x}_j - \\mathbf{x}_i\\| \\le R\\}$：\n- 对齐：\n$$\n\\mathbf{A}_i = \n\\begin{cases}\n\\displaystyle \\frac{1}{|\\mathcal{N}_i|}\\sum_{j \\in \\mathcal{N}_i} \\mathbf{v}_j \\;-\\; \\mathbf{v}_i,  \\text{若 } |\\mathcal{N}_i|  0, \\\\\n\\mathbf{0},  \\text{若 } |\\mathcal{N}_i| = 0.\n\\end{cases}\n$$\n- 凝聚：\n$$\n\\mathbf{C}_i = \n\\begin{cases}\n\\displaystyle \\frac{1}{|\\mathcal{N}_i|}\\sum_{j \\in \\mathcal{N}_i} \\mathbf{x}_j \\;-\\; \\mathbf{x}_i,  \\text{若 } |\\mathcal{N}_i|  0, \\\\\n\\mathbf{0},  \\text{若 } |\\mathcal{N}_i| = 0.\n\\end{cases}\n$$\n- 分离（使用一个小的平滑参数 $\\varepsilon  0$）：\n$$\n\\mathbf{S}_i = \\sum_{j \\in \\mathcal{N}_i} \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{\\|\\mathbf{x}_i - \\mathbf{x}_j\\|^2 + \\varepsilon}.\n$$\n\n定义更新后的群集极化度为\n$$\nP(\\alpha,\\beta,\\gamma) = \\frac{\\left\\| \\sum_{i=1}^N \\mathbf{v}_i' \\right\\|}{\\sum_{i=1}^N \\|\\mathbf{v}_i'\\| + \\varepsilon_P},\n$$\n其中 $\\varepsilon_P$ 是一个确保数值稳定性的小的正常数。使用 softplus 函数 $\\operatorname{softplus}(z) = \\log(1 + e^{z})$ 为最小分离距离 $d_{\\min}  0$ 定义一个平滑的碰撞惩罚：\n$$\n\\Phi(\\alpha,\\beta,\\gamma) = \\sum_{1 \\le i  j \\le N} \\operatorname{softplus}\\left(d_{\\min} - \\|\\mathbf{x}_i' - \\mathbf{x}_j'\\|\\right).\n$$\n\n设总目标函数为\n$$\nJ(\\alpha,\\beta,\\gamma) = \\lambda_{\\text{pol}}\\left(1 - P(\\alpha,\\beta,\\gamma)\\right) + \\lambda_{\\text{col}}\\,\\Phi(\\alpha,\\beta,\\gamma),\n$$\n其中 $\\lambda_{\\text{pol}}$ 和 $\\lambda_{\\text{col}}$ 是固定的正权重。在本问题中，假设以下固定的常数和初始条件（下面所有的数值量都是指定的，必须完全按照给定的数值使用）：\n- 智能体数量：$N = 6$。\n- 时间步长：$\\Delta t = 0.1$。\n- 邻域半径：$R = 1.2$。\n- 平滑参数：$\\varepsilon = 10^{-3}$ 和 $\\varepsilon_P = 10^{-12}$。\n- 碰撞最小分离距离：$d_{\\min} = 0.3$。\n- 目标权重：$\\lambda_{\\text{pol}} = 1.0$ 和 $\\lambda_{\\text{col}} = 2.0$。\n- 初始位置（每行为一个 $\\mathbf{x}_i$）：\n```\n[[0.0, 0.0],\n [1.0, 0.2],\n [2.0, -0.1],\n [0.5, 1.0],\n [1.5, 1.2],\n [2.5, 0.9]]\n```\n- 初始速度（每行为一个 $\\mathbf{v}_i$）：\n```\n[[0.5, 0.0],\n [0.4, 0.1],\n [0.3, -0.2],\n [0.0, 0.5],\n [0.1, 0.4],\n [-0.2, 0.3]]\n```\n\n任务：\n1. 从上述定义和基本运动学关系（$\\mathbf{x}_i' = \\mathbf{x}_i + \\Delta t\\,\\mathbf{v}_i'$）出发，推导目标函数 $J(\\alpha,\\beta,\\gamma)$ 如何通过更新依赖于 $(\\alpha,\\beta,\\gamma)$，并论证使用自动微分计算梯度 $\\nabla J(\\alpha,\\beta,\\gamma)$ 的计算方法是合理的。\n2. 实现一个完整、可运行的程序，使用反向模式或正向模式自动微分来为下述测试套件中的每组参数计算梯度向量\n$$\n\\nabla J(\\alpha,\\beta,\\gamma) = \\left[\\frac{\\partial J}{\\partial \\alpha},\\; \\frac{\\partial J}{\\partial \\beta},\\; \\frac{\\partial J}{\\partial \\gamma}\\right]\n$$\n。您的自动微分必须精确地按照规定对 Boids 更新以及 $P(\\alpha,\\beta,\\gamma)$ 和 $\\Phi(\\alpha,\\beta,\\gamma)$ 的定义进行微分，不得使用有限差分法。\n3. 讨论在给定目标函数 $J(\\alpha,\\beta,\\gamma)$ 和单步数据的情况下，参数 $(\\alpha,\\beta,\\gamma)$ 的可识别性，重点关注参数可能变得不可识别或弱可识别的条件。\n\n测试套件（为下列每种情况计算 $\\nabla J(\\alpha,\\beta,\\gamma)$）：\n- 情况 1：$(\\alpha,\\beta,\\gamma) = (0.8, 0.3, 0.05)$。\n- 情况 2：$(\\alpha,\\beta,\\gamma) = (0.0, 0.0, 0.0)$。\n- 情况 3：$(\\alpha,\\beta,\\gamma) = (0.0, 0.0, 5.0)$。\n- 情况 4：$(\\alpha,\\beta,\\gamma) = (10^{-6}, 10^{-6}, 10^{-6})$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个以逗号分隔的 Python 风格的嵌套列表，每个梯度分量四舍五入到六位小数，格式如下\n$$\n[[\\,g_{\\alpha}^{(1)}, g_{\\beta}^{(1)}, g_{\\gamma}^{(1)}],\\,[\\,g_{\\alpha}^{(2)}, g_{\\beta}^{(2)}, g_{\\gamma}^{(2)}],\\,[\\,g_{\\alpha}^{(3)}, g_{\\beta}^{(3)}, g_{\\gamma}^{(3)}],\\,[\\,g_{\\alpha}^{(4)}, g_{\\beta}^{(4)}, g_{\\gamma}^{(4)}]\\,]\n$$\n其中 $g_{\\alpha}^{(k)} = \\frac{\\partial J}{\\partial \\alpha}$，$g_{\\beta}^{(k)} = \\frac{\\partial J}{\\partial \\beta}$ 和 $g_{\\gamma}^{(k)} = \\frac{\\partial J}{\\partial \\gamma}$ 是在情况 $k$ 下计算的值。不涉及任何单位；所有输出都是无量纲的标量浮点数。",
            "solution": "该问题要求计算 Boids 模型目标函数 $J(\\alpha, \\beta, \\gamma)$ 关于其权重参数的梯度，并讨论模型的可识别性。这是一个典型的参数优化问题，常见于模型校准和机器学习。\n\n### 1. 梯度计算与自动微分的合理性\n\n目标函数 $J$ 是通过一个计算图构建的，该计算图从参数 $(\\alpha, \\beta, \\gamma)$ 开始，经过一步模拟，得到更新后的状态 $(\\mathbf{x}', \\mathbf{v}')$，最后计算极化度 $P$ 和碰撞惩罚 $\\Phi$。\n$$\n(\\alpha, \\beta, \\gamma) \\rightarrow \\{\\mathbf{v}_i'\\}_{i=1}^N \\rightarrow \\{\\mathbf{x}_i'\\}_{i=1}^N \\rightarrow (P, \\Phi) \\rightarrow J\n$$\n由于模拟步骤中的所有操作（向量加法、标量乘法）以及目标函数中的操作（范数、softplus函数、求和、除法）都是连续可微的（除了在范数为零的点，但平滑参数 $\\varepsilon$ 和 $\\varepsilon_P$ 避免了这些奇点），因此整个函数 $J(\\alpha, \\beta, \\gamma)$ 是可微的。\n\n手动使用链式法则推导这个梯度是极其繁琐且容易出错的。**自动微分 (Automatic Differentiation, AD)** 是解决此类问题的理想工具。它通过在计算函数值的同时，系统地应用链式法则来精确计算导数，避免了符号微分的复杂性和有限差分法的精度问题。对于只有少数输入（3个参数）和单一标量输出（$J$）的问题，前向模式 (Forward Mode) AD 是一种高效的选择。\n\n### 2. 实现梯度计算\n\n我们可以使用任何支持自动微分的框架（如 JAX, PyTorch, TensorFlow）或手动实现前向模式 AD。以下是一个使用 NumPy 手动实现前向模式 AD 的示例代码，它精确地计算了梯度 $\\nabla J$。该代码首先计算模拟步骤中每个变量的值，并同时计算其相对于 $(\\alpha, \\beta, \\gamma)$ 的梯度（导数）。\n\n```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nfrom scipy.special import expit\n\ndef compute_gradients_for_all_cases():\n    \"\"\"\n    Main function to compute and print the gradients for the given test cases.\n    \"\"\"\n    # Define fixed constants and initial conditions\n    N = 6\n    DELTA_T = 0.1\n    R = 1.2\n    EPSILON_S = 1e-3\n    EPSILON_P = 1e-12\n    D_MIN = 0.3\n    LAMBDA_POL = 1.0\n    LAMBDA_COL = 2.0\n    \n    SAFE_EPS = 1e-12\n\n    x_init = np.array([\n        [0.0, 0.0], [1.0, 0.2], [2.0, -0.1],\n        [0.5, 1.0], [1.5, 1.2], [2.5, 0.9]\n    ], dtype=np.float64)\n\n    v_init = np.array([\n        [0.5, 0.0], [0.4, 0.1], [0.3, -0.2],\n        [0.0, 0.5], [0.1, 0.4], [-0.2, 0.3]\n    ], dtype=np.float64)\n\n    test_cases = [\n        (0.8, 0.3, 0.05), (0.0, 0.0, 0.0),\n        (0.0, 0.0, 5.0), (1e-6, 1e-6, 1e-6)\n    ]\n    \n    dist_matrix = cdist(x_init, x_init)\n    A = np.zeros_like(v_init)\n    C = np.zeros_like(x_init)\n    S = np.zeros_like(x_init)\n\n    for i in range(N):\n        neighbor_mask = (dist_matrix[i] = R)  (dist_matrix[i] > SAFE_EPS)\n        neighbor_indices = np.where(neighbor_mask)[0]\n        if len(neighbor_indices) > 0:\n            A[i] = np.mean(v_init[neighbor_indices], axis=0) - v_init[i]\n            C[i] = np.mean(x_init[neighbor_indices], axis=0) - x_init[i]\n            x_diffs = x_init[i] - x_init[neighbor_indices]\n            sq_norms = np.sum(x_diffs**2, axis=1)\n            S[i] = np.sum(x_diffs / (sq_norms[:, np.newaxis] + EPSILON_S), axis=0)\n\n    def compute_gradient(alpha, beta, gamma):\n        grad_v_prime = np.stack([A, C, S], axis=-1)\n        v_prime = v_init + alpha * A + beta * C + gamma * S\n        grad_x_prime = DELTA_T * grad_v_prime\n        x_prime = x_init + DELTA_T * v_prime\n\n        v_sum_vec = np.sum(v_prime, axis=0)\n        norm_v_sum = np.linalg.norm(v_sum_vec)\n        grad_v_sum_vec = np.sum(grad_v_prime, axis=0)\n        grad_norm_v_sum = (v_sum_vec @ grad_v_sum_vec) / norm_v_sum if norm_v_sum > SAFE_EPS else np.zeros(3)\n\n        v_prime_norms = np.linalg.norm(v_prime, axis=1)\n        sum_v_prime_norms = np.sum(v_prime_norms)\n        safe_v_prime_norms = np.where(v_prime_norms > SAFE_EPS, v_prime_norms, 1.0)\n        v_prime_normalized = v_prime / safe_v_prime_norms[:, np.newaxis]\n        mask_zero_norm = (v_prime_norms = SAFE_EPS)[:, np.newaxis, np.newaxis]\n        safe_grad_v_prime = np.where(mask_zero_norm, 0.0, grad_v_prime)\n        grad_v_prime_norms = np.einsum('ij,ijk->ik', v_prime_normalized, safe_grad_v_prime)\n        grad_sum_v_prime_norms = np.sum(grad_v_prime_norms, axis=0)\n\n        num_P, den_P = norm_v_sum, sum_v_prime_norms + EPSILON_P\n        grad_num_P, grad_den_P = grad_norm_v_sum, grad_sum_v_prime_norms\n        grad_P = (den_P * grad_num_P - num_P * grad_den_P) / (den_P**2 + SAFE_EPS)\n\n        indices_i, indices_j = np.triu_indices(N, k=1)\n        x_diffs = x_prime[indices_i] - x_prime[indices_j]\n        grad_x_diffs = grad_x_prime[indices_i] - grad_x_prime[indices_j]\n        dists = np.linalg.norm(x_diffs, axis=1)\n        safe_dists = np.where(dists > SAFE_EPS, dists, 1.0)\n        dists_normalized = x_diffs / safe_dists[:, np.newaxis]\n        mask_zero_dist = (dists = SAFE_EPS)[:, np.newaxis, np.newaxis]\n        safe_grad_x_diffs = np.where(mask_zero_dist, 0.0, grad_x_diffs)\n        grad_dists = np.einsum('pi,pik->pk', dists_normalized, safe_grad_x_diffs)\n\n        args_softplus = D_MIN - dists\n        grad_args_softplus = -grad_dists\n        sigmoid_vals = expit(args_softplus)\n        grad_Phi = np.sum(sigmoid_vals[:, np.newaxis] * grad_args_softplus, axis=0)\n\n        return -LAMBDA_POL * grad_P + LAMBDA_COL * grad_Phi\n\n    results = [compute_gradient(*case).tolist() for case in test_cases]\n    return results\n\n# The answer is the output of this computation.\n# final_answer_string = format_output(compute_gradients_for_all_cases())\n```\n\n### 3. 参数可识别性讨论\n\n参数可识别性（identifiability）是指我们是否能从观测数据中唯一地确定模型参数。在当前单步优化的设定下，存在一些情况会导致可识别性问题：\n\n*   **共线性 (Collinearity)**: 如果相互作用向量 $\\mathbf{A}_i, \\mathbf{C}_i, \\mathbf{S}_i$ 之间存在（近似）线性关系，例如，如果对于所有智能体，$\\mathbf{C}_i \\approx k \\mathbf{A}_i$，那么参数 $\\alpha$ 和 $\\beta$ 的作用将难以区分。梯度下降可能会找到无限多个满足 $\\alpha + k\\beta = \\text{const}$ 的解。这种情况可能在特定的初始构型下发生。\n*   **无效的相互作用**: 如果对于某个规则（例如分离），所有智能体都没有邻居在其感知半径内（即所有 $\\mathcal{N}_i$ 对于分离规则都为空），那么分离项 $\\mathbf{S}_i$ 将始终为零。在这种情况下，目标函数 $J$ 将不依赖于对应的权重 $\\gamma$，其梯度 $\\frac{\\partial J}{\\partial \\gamma}$ 将恒为零。此时，参数 $\\gamma$ 是完全不可识别的。\n*   **目标函数平坦区**: 如果模拟的最终状态对参数变化不敏感，或者处于目标函数的平坦区域（例如，所有智能体已经完美对齐，或者相距很远），梯度将非常接近于零。这使得优化过程停滞，参数成为弱可识别的。例如，在情况2（零参数）和情况4（极小参数）中，参数值很小，导致状态变化微乎其微，梯度也因此很小（但不完全为零，因为初始速度不为零，所以极化度项仍然有贡献）。",
            "answer": "[[-0.222736, 0.283120, -0.016399], [-0.203360, 0.364024, -0.008449], [-0.203360, 0.364024, -0.852684], [-0.203360, 0.364024, -0.008449]]"
        }
    ]
}