{
    "hands_on_practices": [
        {
            "introduction": "让我们从最简单的随机过程——独立同分布（IID）过程，或称“无记忆”过程——开始。这个基础练习将向你展示，计算力学的核心量——统计复杂度 $C_{\\mu}$、熵率 $h_{\\mu}$ 和超熵 $\\mathbf{E}$——如何精确地量化一个没有记忆的系统的直观特性。通过完成这个例子 ，你将为理解更复杂的系统打下坚实的基础。",
            "id": "4118511",
            "problem": "考虑一个平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$，它由独立投掷一枚有偏硬币产生，对每个整数 $t$，有 $\\mathbb{P}(X_t = 1) = p$ 和 $\\mathbb{P}(X_t = 0) = 1 - p$，其中 $p \\in (0,1)$。在计算力学的框架内，ε-机是最小的单向预测模型，其状态是基于预测等价关系的半无限过去的等价类。从第一性原理出发——即通过将引出相同未来条件分布的过去进行分组来构造因果态——并仅使用统计复杂度 $C_{\\mu}$、熵率 $h_{\\mu}$ 和超额熵 $\\mathbf{E}$ 分别作为记忆、不可预测性和可预测结构的基本定义，执行以下操作：\n\n- 通过确定此过程的因果态和符号标记的转移结构，推导出其ε-机。\n- 计算所得ε-机的统计复杂度 $C_{\\mu}$，即其因果态上稳态分布的香农熵（以奈特为单位）。\n- 计算熵率 $h_{\\mu}$（以奈特为单位），即在给定半无限过去的条件下，下一个符号的极限条件熵。\n- 计算超额熵 $\\mathbf{E}$（以奈特为单位），即半无限过去与半无限未来之间的互信息。\n- 解释每个度量，说明它捕捉了关于该过程的什么信息。\n\n所有熵量均使用自然对数，并以奈特为单位报告。将最终答案表示为一个单行矩阵，按顺序包含 $C_{\\mu}$、$h_{\\mu}$ 和 $\\mathbf{E}$ 的值，形式为关于 $p$ 的闭合表达式。无需四舍五入。",
            "solution": "问题陈述具有科学依据，提法恰当，客观且完整。它提出了计算力学中的一个标准任务：分析一个独立同分布（IID）的伯努利过程。该问题是有效的，我们可以继续进行求解。\n\n该过程是一个平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$，其中每个随机变量 $X_t$ 都从一个共同分布中独立抽取。字母表为 $\\mathcal{A} = \\{0, 1\\}$，概率为 $\\mathbb{P}(X_t = 1) = p$ 和 $\\mathbb{P}(X_t = 0) = 1 - p$，其中常数 $p \\in (0, 1)$。\n\n**1. ε-机的推导**\n\n计算力学的核心是因果态的概念。因果态是半无限过去的等价类，如果两个过去对未来产生相同的预测，则它们被认为是等价的。\n\n设半无限过去为一个具体实现 $\\overleftarrow{x} = (\\dots, x_{-2}, x_{-1})$，其中每个 $x_t \\in \\mathcal{A}$。设半无限未来为随机变量 $\\overrightarrow{X} = (X_0, X_1, X_2, \\dots)$。\n\n预测等价关系，记为 $\\sim_{\\epsilon}$，定义如下：两个过去 $\\overleftarrow{x}$ 和 $\\overleftarrow{x}'$ 是等价的，当且仅当它们在未来上引出的条件概率分布是相同的。形式上：\n$$ \\overleftarrow{x} \\sim_{\\epsilon} \\overleftarrow{x}' \\iff \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}) = \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}') $$\n因果态是此关系的等价类：$\\mathcal{S} = \\{ s = [\\overleftarrow{x}]_{\\sim_{\\epsilon}} \\}$。\n\n对于给定的过程，随机变量 $\\{X_t\\}$ 是独立同分布的。这意味着任何未来序列的概率独立于任何过去序列。对于任何过去 $\\overleftarrow{x}$，未来的条件概率就是无条件概率：\n$$ \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}) = \\mathbb{P}(\\overrightarrow{X}) $$\n这是因为对于任何有限的未来字符串 $x_0x_1\\dots x_{L-1}$，其概率为 $\\mathbb{P}(X_0=x_0, \\dots, X_{L-1}=x_{L-1}) = \\prod_{t=0}^{L-1} \\mathbb{P}(X_t=x_t)$，这不依赖于过去 $\\overleftarrow{x}$。\n\n由于这对每个可能的过去 $\\overleftarrow{x}$ 都成立，因此对于任意两个过去 $\\overleftarrow{x}$ 和 $\\overleftarrow{x}'$：\n$$ \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}) = \\mathbb{P}(\\overrightarrow{X}) = \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}') $$\n因此，所有可能的半无限过去在预测上都是等价的，并且属于同一个等价类。这意味着只有一个因果态。我们将其表示为 $\\mathcal{S}_A$。\n\n该过程的ε-机是一个单态机器。从状态 $\\mathcal{S}_A$ 出发，过程以概率 $p$ 发出符号 $1$，以概率 $1-p$ 发出符号 $0$。由于只有一个状态，任何转移都必须返回到 $\\mathcal{S}_A$。其转移结构是：\n- 发出 $1$ 时，以概率 $p$ 从 $\\mathcal{S}_A$ 转移到 $\\mathcal{S}_A$。\n- 发出 $0$ 时，以概率 $1-p$ 从 $\\mathcal{S}_A$ 转移到 $\\mathcal{S}_A$。\n\n**2. 统计复杂度 ($C_{\\mu}$)**\n\n统计复杂度 $C_{\\mu}$ 是因果态上稳态分布 $\\pi(\\mathcal{S})$ 的香农熵。它量化了最优预测所需的记忆量（以奈特为单位）。\n$$ C_{\\mu} = H[\\pi] = - \\sum_{s \\in \\mathcal{S}} \\pi(s) \\ln(\\pi(s)) $$\n在这种情况下，因果态的集合是 $\\mathcal{S} = \\{\\mathcal{S}_A\\}$。稳态分布是平凡的，因为过程始终处于单一状态 $\\mathcal{S}_A$。因此，$\\pi(\\mathcal{S}_A) = 1$。\n因此，统计复杂度为：\n$$ C_{\\mu} = - \\pi(\\mathcal{S}_A) \\ln(\\pi(\\mathcal{S}_A)) = -1 \\ln(1) = 0 $$\n解释：统计复杂度为 $0$ 表示该过程没有记忆。过去的知识并不能改善对未来的预测，因此不需要存储任何关于过去的信息。这是无记忆（IID）过程的标志。\n\n**3. 熵率 ($h_{\\mu}$)**\n\n熵率 $h_{\\mu}$ 是在给定半无限过去的条件下，下一个符号的极限条件熵。它衡量了每个时间步过程中不可减少的不确定性或内在的随机性。\n$$ h_{\\mu} = \\lim_{L \\to \\infty} H[X_0 | X_{-1}, X_{-2}, \\dots, X_{-L}] $$\n对于一个 IID 过程，根据定义，下一个符号 $X_0$ 独立于所有过去的符号。因此，条件熵等于单个变量的无条件熵：\n$$ H[X_0 | X_{-1}, \\dots, X_{-L}] = H[X_0] $$\n熵率就是成功概率为 $p$ 的单次伯努利试验的熵。\n$$ h_{\\mu} = H[X_0] = - \\sum_{x \\in \\{0, 1\\}} \\mathbb{P}(X_0 = x) \\ln(\\mathbb{P}(X_0 = x)) $$\n$$ h_{\\mu} = -[\\mathbb{P}(X_0=1)\\ln(\\mathbb{P}(X_0=1)) + \\mathbb{P}(X_0=0)\\ln(\\mathbb{P}(X_0=0))] $$\n$$ h_{\\mu} = -[p \\ln(p) + (1-p) \\ln(1-p)] $$\n解释：熵率 $h_{\\mu}$ 是过程的基本不可预测性。对于一个 IID 过程，这仅仅是与单个事件相关联的不确定性，因为没有可以用于预测的时间相关性。\n\n**4. 超额熵 ($\\mathbf{E}$)**\n\n超额熵 $\\mathbf{E}$ 是半无限过去 $\\overleftarrow{X}$ 和半无限未来 $\\overrightarrow{X}$ 之间的互信息。\n$$ \\mathbf{E} = I[\\overleftarrow{X} ; \\overrightarrow{X}] $$\n它量化了过程中可预测结构的数量，或者说过去和未来共享了多少信息。两个随机变量 $A$ 和 $B$ 之间的互信息 $I[A; B]$ 为零，当且仅当它们是独立的。\n\n对于给定的 IID 过程，任何过去的变量块 $\\overleftarrow{X} = (\\dots, X_{-2}, X_{-1})$ 都独立于任何未来的变量块 $\\overrightarrow{X} = (X_0, X_1, X_2, \\dots)$。\n因此，过去和未来之间的互信息为零。\n$$ \\mathbf{E} = I[\\overleftarrow{X} ; \\overrightarrow{X}] = 0 $$\n解释：超额熵为 $0$ 表明过去和未来之间没有共享的信息。观察整个过去并不能提供任何有助于预测整个未来的信息，除了从过程的基本统计数据中已知的信息。这证实了该过程缺乏时间相关性或结构。\n\n总而言之，对于参数为 $p$ 的 IID 伯努利过程：\n- 统计复杂度 $C_{\\mu} = 0$：该过程是无记忆的。\n- 熵率 $h_{\\mu} = -p \\ln(p) - (1-p) \\ln(1-p)$：该过程的随机性是单次有偏硬币投掷的不确定性。\n- 超额熵 $\\mathbf{E} = 0$：该过程缺乏过去与未来之间的任何时间结构或相关性。\n最终答案是一个包含这三个值的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  -p \\ln(p) - (1-p) \\ln(1-p)  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在无记忆系统之后，我们现在来考虑一个具有隐藏时间结构的过程：一个含噪声的周期性过程。这个练习  挑战你运用因果状态构建的第一性原理来揭示其潜在的生成机制。成功推导出这个过程的ε-机将锻炼你识别过去观测如何为未来预测提供信息的能力，即使在底层动力学不直接可见的情况下也是如此。",
            "id": "4118524",
            "problem": "考虑一个在字母表 $\\{0,1\\}$ 上的平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$，它由一个双态隐源生成，该隐源具有一个内部相位变量 $\\{S_t\\}_{t \\in \\mathbb{Z}}$，取值于 $\\{A,B\\}$。内部相位确定性地交替：$S_{t+1} = \\sigma(S_t)$，其中 $\\sigma(A) = B$ 且 $\\sigma(B) = A$。发射规则如下：\n- 如果 $S_t = A$（“1-相位”），则 $X_t = 1$ 的概率为 $1-p$，$X_t = 0$ 的概率为 $p$。\n- 如果 $S_t = B$（“0-相位”），则 $X_t = 0$ 的概率为 $1$。\n\n假设 $p \\in (0,1)$ 是固定的，并且该过程已经无限期运行，因此处于其平稳状态。该信源实现了一个噪声周期为2的基线，其中符号 $1$ 本应与 $0$ 确定性地交替，但当内部相位为 $A$ 时，会以小概率 $p$ 偶尔翻转为 $0$。\n\n使用计算力学的基本定义，通过将产生相同半无限未来条件分布的半无限过去识别为等价类，来构建最小预测模型——计算力学ε-机。然后，根据信息论的第一性原理，推导观测过程的熵率 $h_{\\mu}$ 作为 $p$ 的函数。\n\n以比特/符号为单位表示 $h_{\\mu}$。请以 $p$ 的单个闭式表达式形式提供最终答案。无需四舍五入。",
            "solution": "用户想要解决这个问题。\n问题验证如下：\n步骤1：提取已知条件。\n- 过程：在字母表 $\\mathcal{A} = \\{0,1\\}$ 上的平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$。\n- 隐源：具有状态 $\\{A,B\\}$ 的双态相位变量 $\\{S_t\\}_{t \\in \\mathbb{Z}}$。\n- 相位动力学：$S_{t+1} = \\sigma(S_t)$，其中 $\\sigma(A) = B$ 且 $\\sigma(B) = A$。\n- 发射概率：\n  - $P(X_t=1 | S_t=A) = 1-p$, $P(X_t=0 | S_t=A) = p$。\n  - $P(X_t=0 | S_t=B) = 1$, $P(X_t=1 | S_t=B) = 0$。\n- 参数：$p \\in (0,1)$。\n- 假设：该过程处于其平稳状态。\n- 任务1：通过识别因果态来构建ε-机。\n- 任务2：推导熵率 $h_{\\mu}$ 作为 $p$ 的函数，单位为比特/符号。\n\n步骤2：使用提取的已知条件进行验证。\n- 科学或事实不健全性：该问题描述了一个具有特定确定性状态转移和随机发射的隐马尔可夫模型 (HMM)。这是随机过程和计算力学研究中的一个明确定义且标准的模型。没有违反任何科学原理。\n- 不可形式化或不相关：该问题是计算力学和信息论原理的直接和标准应用，特别是与ε-机相关的应用。\n- 不完整或矛盾的设置：该过程被完全指定。动力学、发射概率和平稳性假设为分析提供了完整的基础。\n- 不现实或不可行：该模型是一个有效的理论构造，代表一个噪声周期过程。它在物理上并非不可能，在科学上亦非不合理。\n- 不适定或结构不良：寻找因果态和熵率的任务是明确定义的。对于给定的平稳过程，ε-机及其熵率是唯一的，因此存在唯一解。\n- 伪深刻、琐碎或同义反复：该问题需要对因果态的定义进行非平凡的应用以发现最小预测模型，然后进行标准的信息论计算。它并非琐碎问题。\n- 超出科学可验证性：结果是可以通过数学推导和验证的。\n\n步骤3：结论与行动。\n问题是**有效的**。将提供完整解答。\n\n一个因果态是半无限过去 $\\overleftarrow{x}_t = \\dots x_{t-2}x_{t-1}$ 的一个等价类。两个过去 $\\overleftarrow{x}_t$ 和 $\\overleftarrow{x}'_t$ 处于同一个因果态，记作 $\\overleftarrow{x}_t \\sim \\overleftarrow{x}'_t$，当且仅当给定任一过去，所有可能未来的条件概率分布都相同：$P(\\overrightarrow{X}_t|\\overleftarrow{X}_t=\\overleftarrow{x}_t) = P(\\overrightarrow{X}_t|\\overleftarrow{X}_t=\\overleftarrow{x}'_t)$，其中 $\\overrightarrow{X}_t = X_t X_{t+1} \\dots$。\n\n对于给定的过程，观测序列 $\\{X_t\\}$ 的未来演化取决于隐相位 $\\{S_t\\}$ 的未来演化。由于相位动力学 $S_{t+1} = \\sigma(S_t)$ 是确定性的，如果当前相位 $S_t$ 已知，则整个未来相位序列 $\\{S_t, S_{t+1}, \\dots\\}$ 都是已知的。因此，一个过去 $\\overleftarrow{x}_t$ 的预测能力完全由它在当前相位 $S_t$ 上引出的条件概率分布（或称信念）所捕捉，即向量 $(P(S_t=A|\\overleftarrow{x}_t), P(S_t=B|\\overleftarrow{x}_t))$。因果态对应于基于观测过去可以形成的不同的信念分布。\n\n我们寻求识别这些不同的信念分布。关键在于理解一个过去提供了关于 $S_t$ 的什么信息。该过程是平稳的，并且由于 $p \\in (0,1)$，每当相位为 $A$ 时，发射 $1$ 的概率非零。由于相位在 $A$ 和 $B$ 之间交替，系统几乎必然不会产生无限的零序列。因此，在平稳状态下观测到的任何过去，都将以概率 $1$ 包含至少一个符号 $1$。\n\n让我们通过定位符号 $1$ 最近一次出现的位置来分析一个过去 $\\overleftarrow{x}_t$。设这次出现发生在时间 $t-k-1$，其中整数 $k \\ge 0$。因此，该过去的形式为 $\\dots 1 \\underbrace{00\\dots0}_{k}$。\n发射 $X_{t-k-1}=1$ 只能由隐相位 $S_{t-k-1}=A$ 生成。\n使用确定性的相位动力学 $S_{i+1}=\\sigma(S_i)$，我们可以唯一地确定任何后续时间的相位。时间 $t$ 的相位可以通过将转移映射 $\\sigma$ 应用 $t - (t-k-1) = k+1$ 步来找到。\n相位序列是 $S_{t-k-1}=A$, $S_{t-k}=B$, $S_{t-k+1}=A$，依此类推。\n如果 $j-(t-k-1)$ 是偶数，则相位 $S_j$ 是 $A$；如果是奇数，则是 $B$。\n对于当前时间 $t$，差值为 $t-(t-k-1) = k+1$。\n- 如果 $k$ 是偶数，则 $k+1$ 是奇数，这意味着 $S_t = \\sigma(A) = B$。\n- 如果 $k$ 是奇数，则 $k+1$ 是偶数，这意味着 $S_t = A$。\n\n该分析表明，观测任何包含 $1$ 的过去都足以同步我们对隐相位的认知，将我们的信念坍缩为一个确定性事件。我们只有两种可能的信念分布：\n1.  所有以 $10^k$ 结尾的过去，其中 $k$ 是一个奇数（$k=1, 3, 5, \\dots$）。这些过去确定性地意味着当前隐相位是 $A$。我们将这些归入一个单一的因果态 $\\mathcal{C}_A$。对于任何 $\\overleftarrow{x}_t \\in \\mathcal{C}_A$，我们有 $P(S_t=A|\\overleftarrow{x}_t)=1$。\n2.  所有以 $10^k$ 结尾的过去，其中 $k$ 是一个非负偶数（$k=0, 2, 4, \\dots$）。这些过去确定性地意味着当前隐相位是 $B$。我们将这些归入一个单一的因果态 $\\mathcal{C}_B$。对于任何 $\\overleftarrow{x}_t \\in \\mathcal{C}_B$，我们有 $P(S_t=B|\\overleftarrow{x}_t)=1$。\n\n这两个状态 $\\mathcal{C}_A$ 和 $\\mathcal{C}_B$ 构成了ε-机的递归因果态集合。我们现在确定它们之间的转移。设系统在时间 $t$ 处于状态 $\\mathcal{C}_s$。我们观测到符号 $X_t=x$ 并转移到时间 $t+1$ 的状态 $\\mathcal{C}_{s'}$。转移标记为 $x|P(x|\\mathcal{C}_s)$。\n- 如果系统在时间 $t$ 处于 $\\mathcal{C}_A$，我们知道 $S_t=A$。\n  - 它以概率 $1-p$ 发射 $X_t=1$。时间 $t+1$ 的新过去以 $1$ 结尾。这对应于 $k=0$（偶数），所以新状态是 $\\mathcal{C}_B$。转移是 $\\mathcal{C}_A \\xrightarrow{1|(1-p)} \\mathcal{C}_B$。\n  - 它以概率 $p$ 发射 $X_t=0$。之前的过去以 $10^k$（$k$ 为奇数）结尾。新过去以 $10^{k+1}$ 结尾，其中 $k+1$ 现在是偶数。因此，新状态是 $\\mathcal{C}_B$。转移是 $\\mathcal{C}_A \\xrightarrow{0|p} \\mathcal{C}_B$。\n- 如果系统在时间 $t$ 处于 $\\mathcal{C}_B$，我们知道 $S_t=B$。\n  - 它以概率 $1$ 发射 $X_t=0$。之前的过去以 $10^k$（$k$ 为偶数）结尾。新过去以 $10^{k+1}$ 结尾，其中 $k+1$ 现在是奇数。因此，新状态是 $\\mathcal{C}_A$。转移是 $\\mathcal{C}_B \\xrightarrow{0|1} \\mathcal{C}_A$。\n  - 它不能发射 $X_t=1$，因为 $P(X_t=1|S_t=B)=0$。\n\nε-机有两个状态 $\\{\\mathcal{C}_A, \\mathcal{C}_B\\}$，具有以下转移：\n- $\\mathcal{C}_A \\xrightarrow{1|(1-p)} \\mathcal{C}_B$\n- $\\mathcal{C}_A \\xrightarrow{0|p} \\mathcal{C}_B$\n- $\\mathcal{C}_B \\xrightarrow{0|1} \\mathcal{C}_A$\n\n为了找到熵率 $h_\\mu$，我们首先需要这些因果态的平稳概率，记作 $\\pi_A = P(\\mathcal{C}_A)$ 和 $\\pi_B = P(\\mathcal{C}_B)$。设 $\\vec{\\pi} = (\\pi_A, \\pi_B)$ 是平稳分布向量。它必须是状态转移矩阵 $T$ 的特征值为 $1$ 的左特征向量，其中 $T_{ij} = P(\\text{下一状态是 } j | \\text{当前状态是 } i)$。\n$P(\\mathcal{C}_B | \\mathcal{C}_A) = P(X_t=1|\\mathcal{C}_A) + P(X_t=0|\\mathcal{C}_A) = (1-p) + p = 1$。\n$P(\\mathcal{C}_A | \\mathcal{C}_A) = 0$。\n$P(\\mathcal{C}_A | \\mathcal{C}_B) = P(X_t=0|\\mathcal{C}_B) = 1$。\n$P(\\mathcal{C}_B | \\mathcal{C}_B) = 0$。\n转移矩阵是 $T = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$。平稳分布必须满足 $\\vec{\\pi}T = \\vec{\\pi}$，即 $(\\pi_A, \\pi_B) \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} = (\\pi_B, \\pi_A)$。这得出 $\\pi_A = \\pi_B$。结合归一化条件 $\\pi_A + \\pi_B = 1$，我们得到 $\\pi_A = \\pi_B = \\frac{1}{2}$。\n\n由ε-机描述的过程的熵率 $h_{\\mu}$ 是在已知当前因果态的情况下，下一个符号的平均不确定性。该平均值是根据因果态的平稳分布计算的。以比特/符号为单位的公式是：\n$$h_{\\mu} = \\sum_{s \\in \\{\\mathcal{C}_A, \\mathcal{C}_B\\}} \\pi_s H(X|s)$$\n其中 $H(X|s) = -\\sum_{x \\in \\{0,1\\}} P(x|s) \\log_2 P(x|s)$ 是从状态 $s$ 发射分布的香农熵。\n\n我们为每个状态计算 $H(X|s)$：\n- 对于状态 $\\mathcal{C}_A$：\n  发射概率为 $P(X_t=0|\\mathcal{C}_A)=p$ 和 $P(X_t=1|\\mathcal{C}_A)=1-p$。\n  $H(X|\\mathcal{C}_A) = -[p \\log_2(p) + (1-p)\\log_2(1-p)]$。这是二元熵函数 $H_b(p)$。\n- 对于状态 $\\mathcal{C}_B$：\n  发射概率为 $P(X_t=0|\\mathcal{C}_B)=1$ 和 $P(X_t=1|\\mathcal{C}_B)=0$。\n  $H(X|\\mathcal C_B) = -[1 \\log_2(1) + 0 \\cdot \\lim_{q\\to 0} \\log_2(q)] = 0$。从状态 $\\mathcal{C}_B$ 的发射没有不确定性。\n\n将这些部分代入 $h_{\\mu}$ 的公式中：\n$$h_{\\mu} = \\pi_A H(X|\\mathcal{C}_A) + \\pi_B H(X|\\mathcal{C}_B)$$\n$$h_{\\mu} = \\frac{1}{2} H_b(p) + \\frac{1}{2} \\cdot 0$$\n$$h_{\\mu} = \\frac{1}{2} H_b(p) = -\\frac{1}{2} [p \\log_2(p) + (1-p)\\log_2(1-p)]$$\n这就是观测过程的熵率，单位为比特/符号。",
            "answer": "$$\n\\boxed{-\\frac{1}{2}\\left(p \\log_2(p) + (1-p)\\log_2(1-p)\\right)}\n$$"
        },
        {
            "introduction": "在现实世界的情景中，我们通常不知道过程的生成规则，我们只有它产生的数据。这个练习弥合了理论与实践之间的鸿沟。你将实现一个程序 ，使用统计假设检验从有限的数据计数中经验性地推断出近似的因果状态。这个动手编码问题让你具体理解如何从观测中重建ε-机，这是数据驱动的复杂系统分析的基石。",
            "id": "4118473",
            "problem": "你的任务是，基于计算力学（Computational Mechanics）和ε-机（ε-machines），使用有限样本实现一个端到端的近似因果状态归纳程序。在计算力学中，因果状态被定义为产生相同未来预测分布的过去的等价类。在本问题中，我们关注下一符号的预测分布，将其作为一種有限样本近似。对于给定的以每个长度为$L$的过去为条件的下一符号观测值的经验计数集，使用关于分布等价性的假设检验来归纳近似因果状态。\n\n定义与基础：\n- 长度为$L$的过去记为 $\\overleftarrow{x}^{L}$。下一符号记为 $x_{0}$。\n- 对于每个过去 $\\overleftarrow{x}^{L}$，预测分布为 $P(x_{0} \\mid \\overleftarrow{x}^{L})$。在有限样本中，这是通过在大小为$K$的离散字母表上的经验频率来估计的。\n- 基于计算力学等价关系的因果状态定义为：两个过去 $\\overleftarrow{x}^{L}$ 和 $\\overleftarrow{y}^{L}$ 是等价的，当且仅当对于字母表中的所有 $x_{0}$，都有 $P(x_{0} \\mid \\overleftarrow{x}^{L}) = P(x_{0} \\mid \\overleftarrow{y}^{L})$。ε-机是一种最小表示，其节点是因果状态，其边编码了由过程引起的状态转移结构。\n\n待实现的程序：\n1. 对于每对过去 $(i,j)$，使用卡方同质性检验来检验原假设 $H_{0}: P(x_{0} \\mid \\overleftarrow{x}^{L}_{i}) = P(x_{0} \\mid \\overleftarrow{x}^{L}_{j})$ 对所有 $x_{0}$ 成立。根据这两个过去的经验计数构建一个 $2 \\times K$ 的列联表。为在低计数情况下保持稳定性，在检验前对每个单元格加上伪计数 $\\lambda$ 以应用对称狄利克雷平滑。取 $\\lambda = 0.5$。\n2. 对于多重假设检验，使用 Benjamini-Hochberg (BH) 程序在水平 $q$ 上控制错误发现率 (FDR)。Benjamini-Hochberg (BH) 程序对所有成对的 $p$ 值进行排序 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(M)}$，并对于满足 $p_{(k)} \\le \\frac{k}{M} q$ 的最大 $k$，拒绝所有对应的原假设 $H_0$，$M$ 是检验的配对总数。\n3. 在过去索引 $\\{0,1,\\dots,m-1\\}$ 上构建一个无向接受图：如果经 BH 校正的决策未能拒绝配对 $(i,j)$ 的原假设 $H_0$（即它们没有显著差异），则用一条边连接节点 $i$ 和 $j$。\n4. 将此接受图的连通分量作为归纳出的近似因果状态。每个分量代表一个近似因果状态。将每个分量内的索引按升序排序。按每个分量的最小索引对分量列表进行排序。\n\n科学实在论与一致性要求：\n- 使用带有狄利克雷平滑 $\\lambda = 0.5$ 的卡方同质性检验。\n- 在水平 $q$ 上使用 BH 控制。\n- 随着样本量的增加，该程序是一致的，因为卡方检验在区分不等的多项分布时是一致的，且 BH 控制了错误发现率；在标准正则性条件下，随着样本数的增长，取接受图的连通分量会收敛到真实的等价类。\n\n实现与测试套件的输入数据：\n给定三个测试用例。每个用例指定了形状为 $m_{t} \\times K_{t}$ 的计数矩阵 $C^{(t)}$，其中第 $i$ 行包含在字母表类别上 $P(x_{0} \\mid \\overleftarrow{x}^{L}_{i})$ 的计数，以及 BH 水平 $q^{(t)}$。\n\n- 测试用例1：\n  - $C^{(1)} = \\begin{bmatrix}\n  100  50  50 \\\\\n  100  50  50 \\\\\n  150  0  0 \\\\\n  0  0  200 \\\\\n  0  0  200 \\\\\n  150  0  0\n  \\end{bmatrix}$，\n  - $q^{(1)} = 0.1$。\n\n- 测试用例2（低计数边界情况）：\n  - $C^{(2)} = \\begin{bmatrix}\n  1  0  0 \\\\\n  1  0  0 \\\\\n  0  1  0 \\\\\n  0  0  1\n  \\end{bmatrix}$，\n  - $q^{(2)} = 0.1$。\n\n- 测试用例3（接近等价的边界情况）：\n  - $C^{(3)} = \\begin{bmatrix}\n  50  50  0  0 \\\\\n  51  49  0  0 \\\\\n  25  75  0  0 \\\\\n  0  0  40  60 \\\\\n  0  0  38  62\n  \\end{bmatrix}$，\n  - $q^{(3)} = 0.1$。\n\n输出规范：\n- 对于每个测试用例，输出归纳出的划分为一个列表的列表，其中包含从0开始的过去索引，每个内部列表代表一个近似因果状态。\n- 你的程序應生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，且恰好有三个条目对应三个测试用例。例如，格式必须像 $[result_{1},result_{2},result_{3}]$，其中每个 $result_{t}$ 是如上所述的列表的列表。",
            "solution": "我们从计算力学中因果状态的核心定义开始：两个过去 $\\overleftarrow{x}^{L}$ 和 $\\overleftarrow{y}^{L}$ 处于同一因果状态，当且仅当它们对未来的预测分布是相同的。在实践中，我们用下一个符号 $x_0$ 来近似未来，并使用有限样本通过在大小为 $K$ 的离散字母表上的经验计数来估计 $P(x_{0} \\mid \\overleftarrow{x}^{L})$。\n\n有原则的统计检验：\n- 对于任意一对过去 $(i,j)$，将其经验计数向量表示为 $\\mathbf{c}_{i} \\in \\mathbb{N}^{K}$ 和 $\\mathbf{c}_{j} \\in \\mathbb{N}^{K}$。在原假设 $H_{0}: P(x_{0} \\mid \\overleftarrow{x}^{L}_{i}) = P(x_{0} \\mid \\overleftarrow{x}^{L}_{j})$ 下，这两个多项分布是相等的。通过对 $2 \\times K$ 列联表使用卡方统计量进行的同质性检验，是比较多项分布的成熟方法。\n- 低计数和零单元格会使期望计数不稳定。一个标准的补救方法是对称狄利克雷平滑：向每个单元格添加一个伪计数 $\\lambda$，得到 $\\tilde{\\mathbf{c}}_{i} = \\mathbf{c}_{i} + \\lambda \\cdot \\mathbf{1}_{K}$ 和 $\\tilde{\\mathbf{c}}_{j} = \\mathbf{c}_{j} + \\lambda \\cdot \\mathbf{1}_{K}$，其中 $\\lambda = 0.5$ (Jeffreys先验)。这在保持检验一致性的同时提高了数值稳定性。\n\n多重检验控制：\n- 对于 $m$ 个过去，共有 $M = \\frac{m(m-1)}{2}$ 次成对检验。为控制错误发现率（FDR），使用水平为 $q$ 的 Benjamini-Hochberg (BH) 程序。对 $p$ 值进行排序 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(M)}$，并找到满足 $p_{(k)} \\le \\frac{k}{M}q$ 的最大 $k$。拒绝所有秩小于等于 $k$ 的原假设 $H_0$；其余的假设不被拒绝。\n- BH 程序是经过充分检验的，并且在 $p$ 值独立或具有某些正相关结构的情况下，能将 FDR 控制在水平 $q$。在我们的背景下，它适当地平衡了多次成对比较中的第一类和第二类错误。\n\n基于图的近似因果状态归纳：\n- 在顶点集 $\\{0,1,\\dots,m-1\\}$ 上构建一个无向接受图 $G$，如果 BH 决策未能拒绝某对 $(i,j)$ 的原假设 $H_0$，则用一条边连接 $i$ 和 $j$。这条边代表了经验证据，表明在所选的 FDR 水平上，这两个过去的下一符号分布是无法区分的。\n- 通过取 $G$ 的连通分量来归纳近似因果状态。每个连通分量都是一组通过未被拒绝的等价性检验相互关联（可能具有传递性）的过去。对每个分量内的索引进行排序，并按每个分量的最小索引对分量进行排序，可以确定一个规范表示。\n\n一致性：\n- 卡方同质性检验是一致的，这意味着对于任意两个不等的多项分布，随着总计数的增长，检验拒绝 $H_0$ 的概率趋向于 $1$。相反，对于相等的分布，$p$ 值在 $[0,1]$ 上是渐近均匀的，而 BH 控制了 FDR，从而以高概率防止过度合并。\n- 随着样本量的增加，所有真正不等的配对都将被拒绝，而所有真正相等的配对将不会被拒绝（在受控的 FDR 范围内）。接受图收敛于对应真实等价类的团的并集。在大样本极限下，连通分量与这些类别重合。固定 $\\lambda$ 的狄利克雷平滑不改变渐近决策。\n\n算法步骤：\n1. 对于每个测试用例，读取 $C^{(t)}$ 和 $q^{(t)}$。\n2. 对于每对 $(i,j)$，用平滑后的计数（$\\lambda = 0.5$）构建 $2 \\times K$ 列联表，并计算卡方同质性检验的 $p$ 值。\n3. 在水平 $q^{(t)}$ 上应用 BH，将配对分为拒绝和不拒绝两类。\n4. 根据未拒绝的配对构建接受图，并计算连通分量。\n5. 在分量内部对索引排序，并按分量的最小索引对分量排序。\n6. 为每个测试用例输出分量列表。\n\n在给定测试套件上的预期行为：\n- 测试用例1：存在三个具有相同分布的独立组：索引 $\\{0,1\\}$、$\\{2,5\\}$ 和 $\\{3,4\\}$。跨组配对差异显著，会被拒绝；组内配对则被接受。归纳出的划分为 $[[0,1],[2,5],[3,4]]$。\n- 测试用例2：低计数为三个不同类别产生了确定性分布。配对 $\\{0,1\\}$ 是相同的，被接受；其他配对被拒绝。归纳出的划分为 $[[0,1],[2],[3]]$。\n- 测试用例3：$\\{0,1\\}$ 之间以及 $\\{3,4\\}$ 之间接近等价，而 $\\{2\\}$ 明显不同。归纳出的划分为 $[[0,1],[2],[3,4]]$。\n\n最终程序实现了此过程，并按要求格式打印一行包含三个归纳划分的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2_contingency\nimport json\nfrom itertools import combinations\n\ndef benjamini_hochberg(pvals, pairs, q):\n    \"\"\"\n    Benjamini-Hochberg FDR control.\n    Parameters:\n        pvals: list of p-values\n        pairs: list of (i,j) corresponding to pvals\n        q: target FDR level\n    Returns:\n        rejected_pairs: set of pairs (i,j) where H0 is rejected\n    \"\"\"\n    m = len(pvals)\n    if m == 0:\n        return set()\n    # Sort p-values with their pairs\n    sorted_indices = np.argsort(pvals)\n    p_sorted = np.array(pvals)[sorted_indices]\n    pairs_sorted = [pairs[idx] for idx in sorted_indices]\n\n    # Find largest k such that p_(k) = (k/m)*q\n    k_star = 0 # Changed from -1 to 0, as rank is 1-based\n    for rank, p in enumerate(p_sorted, start=1):\n        if p = (rank / m) * q:\n            k_star = rank\n\n    rejected_pairs = set()\n    if k_star > 0:\n        for idx in range(k_star):\n            rejected_pairs.add(pairs_sorted[idx])\n\n    return rejected_pairs\n\ndef induce_states(counts, q, lambda_smooth=0.5):\n    \"\"\"\n    Induce approximate causal states from counts via BH-corrected chi-square tests.\n    Parameters:\n        counts: numpy array of shape (m, K)\n        q: FDR level for BH\n        lambda_smooth: Dirichlet smoothing pseudocount added to each cell\n    Returns:\n        partition: list of lists of indices (each inner list is a connected component)\n    \"\"\"\n    m, K = counts.shape\n    # Prepare all pairwise tests\n    pvals = []\n    pairs = []\n    for i, j in combinations(range(m), 2):\n        # Apply symmetric Dirichlet smoothing\n        row_i = counts[i, :] + lambda_smooth\n        row_j = counts[j, :] + lambda_smooth\n        table = np.vstack([row_i, row_j])\n        # Chi-squared test for homogeneity\n        # correction=False to use Pearson's chi2 without Yates correction\n        chi2, p, dof, expected = chi2_contingency(table, correction=False)\n        # Handle potential numerical issues: ensure p is finite\n        if not np.isfinite(p):\n            # Fallback: if p is nan due to degeneracy, treat as highly different\n            p = 0.0\n        pvals.append(p)\n        pairs.append(tuple(sorted((i, j))))\n\n    # Apply BH to determine which pairs are significantly different\n    rejected_pairs = benjamini_hochberg(pvals, pairs, q)\n\n    # Build acceptance graph: edge if NOT rejected\n    adjacency = {i: set() for i in range(m)}\n    for pair in pairs:\n        if pair not in rejected_pairs:\n            i, j = pair\n            adjacency[i].add(j)\n            adjacency[j].add(i)\n\n    # Connected components via BFS\n    visited = [False] * m\n    components = []\n    for start in range(m):\n        if not visited[start]:\n            queue = [start]\n            visited[start] = True\n            comp = []\n            while queue:\n                u = queue.pop(0)\n                comp.append(u)\n                for v in adjacency.get(u, set()):\n                    if not visited[v]:\n                        visited[v] = True\n                        queue.append(v)\n            comp.sort()\n            components.append(comp)\n\n    # Sort components by their smallest index for canonical ordering\n    components.sort(key=lambda lst: lst[0] if lst else -1)\n    return components\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([\n                [100, 50, 50],\n                [100, 50, 50],\n                [150, 0, 0],\n                [0,   0, 200],\n                [0,   0, 200],\n                [150, 0, 0]\n            ], dtype=float),\n            0.1\n        ),\n        # Test case 2 (low-count edge case)\n        (\n            np.array([\n                [1, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ], dtype=float),\n            0.1\n        ),\n        # Test case 3 (boundary with near-equivalence)\n        (\n            np.array([\n                [50, 50, 0, 0],\n                [51, 49, 0, 0],\n                [25, 75, 0, 0],\n                [0,  0, 40, 60],\n                [0,  0, 38, 62]\n            ], dtype=float),\n            0.1\n        )\n    ]\n\n    results = []\n    for counts, q in test_cases:\n        partition = induce_states(counts, q, lambda_smooth=0.5)\n        results.append(partition)\n\n    # Final print statement in the exact required format: single line, JSON-like with no spaces.\n    print(json.dumps(results, separators=(',', ':')))\n\nsolve()\n```"
        }
    ]
}