{
    "hands_on_practices": [
        {
            "introduction": "我们从最基础的随机过程——独立同分布（IID）过程开始。这个练习以一个有偏硬币为例，要求你从第一性原理出发，推导出其ε-机以及相关的核心信息度量。通过解决这个问题，你将亲身体会到一个“无记忆”和“无结构”的过程在计算力学的框架下是如何被量化和描述的，这为你后续分析更复杂的系统提供了一个不可或缺的基准。",
            "id": "4118511",
            "problem": "考虑一个平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$，它由独立投掷一枚有偏硬币生成，对于每个整数 $t$，有 $\\mathbb{P}(X_t = 1) = p$ 和 $\\mathbb{P}(X_t = 0) = 1 - p$，其中 $p \\in (0,1)$。在计算力学的框架内，ε-机是最小的单线预测模型，其状态是在预测等价关系下的半无限过去的等价类。从第一性原理出发——即通过将引出相同未来条件分布的过去进行分组来构造因果状态——并仅使用统计复杂度 $C_{\\mu}$、熵率 $h_{\\mu}$ 和超额熵 $\\mathbf{E}$ 分别作为记忆、不可预测性和可预测结构的度量的基本定义，执行以下操作：\n\n- 通过识别其因果状态和符号标记的转移结构，推导出此过程的 $\\varepsilon$-机。\n- 计算所得 $\\varepsilon$-机的统计复杂度 $C_{\\mu}$，即其因果状态上稳态分布的香农熵（单位为奈特）。\n- 计算熵率 $h_{\\mu}$（单位为奈特），即在给定半无限过去的条件下，下一个符号的极限条件熵。\n- 计算超额熵 $\\mathbf{E}$（单位为奈特），即半无限过去与半无限未来之间的互信息。\n- 解释每个度量，说明它捕捉了关于过程的什么信息。\n\n所有熵量均使用自然对数，以奈特为单位报告。将最终答案表示为一个单行矩阵，按顺序包含 $C_{\\mu}$、$h_{\\mu}$ 和 $\\mathbf{E}$ 的值，形式为关于 $p$ 的闭式解。不需要四舍五入。",
            "solution": "该问题陈述在科学上是合理的、适定的、客观的和完整的。它提出了计算力学中的一个标准任务：分析一个独立同分布（IID）的伯努利过程。该问题是有效的，我们可以继续进行解答。\n\n该过程是一个平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$，其中每个随机变量 $X_t$ 都是从一个共同的分布中独立抽取的。字母表为 $\\mathcal{A} = \\{0, 1\\}$，对于某个常数 $p \\in (0, 1)$，概率为 $\\mathbb{P}(X_t = 1) = p$ 和 $\\mathbb{P}(X_t = 0) = 1 - p$。\n\n**1. $\\varepsilon$-机的推导**\n\n计算力学的核心是因果状态的概念。因果状态是半无限过去的等价类，其中两个过去如果能引出对未来的相同预测，则被认为是等价的。\n\n设半无限过去是一个具体实现 $\\overleftarrow{x} = (\\dots, x_{-2}, x_{-1})$，其中每个 $x_t \\in \\mathcal{A}$。设半无限未来是随机变量 $\\overrightarrow{X} = (X_0, X_1, X_2, \\dots)$。\n\n预测等价关系，记为 $\\sim_{\\varepsilon}$，定义如下：两个过去 $\\overleftarrow{x}$ 和 $\\overleftarrow{x}'$ 是等价的，当且仅当它们对未来引出的条件概率分布是相同的。形式上：\n$$ \\overleftarrow{x} \\sim_{\\varepsilon} \\overleftarrow{x}' \\iff \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}) = \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}') $$\n因果状态是该关系的等价类：$\\mathcal{S} = \\{ s = [\\overleftarrow{x}]_{\\sim_{\\varepsilon}} \\}$。\n\n对于给定过程，随机变量 $\\{X_t\\}$ 是独立同分布的。这意味着任何未来序列的概率独立于任何过去序列。对于任何过去 $\\overleftarrow{x}$，未来的条件概率就是无条件概率：\n$$ \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}) = \\mathbb{P}(\\overrightarrow{X}) $$\n这是因为对于任何有限的未来字符串 $x_0x_1\\dots x_{L-1}$，其概率为 $\\mathbb{P}(X_0=x_0, \\dots, X_{L-1}=x_{L-1}) = \\prod_{t=0}^{L-1} \\mathbb{P}(X_t=x_t)$，这不依赖于过去 $\\overleftarrow{x}$。\n\n由于这对每个可能的过去 $\\overleftarrow{x}$ 都成立，因此对于任意两个过去 $\\overleftarrow{x}$ 和 $\\overleftarrow{x}'$：\n$$ \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}) = \\mathbb{P}(\\overrightarrow{X}) = \\mathbb{P}(\\overrightarrow{X} | \\overleftarrow{X} = \\overleftarrow{x}') $$\n因此，所有可能的半无限过去在预测上是等价的，并且属于同一个等价类。这意味着只有一个因果状态。我们将其表示为 $\\mathcal{S}_A$。\n\n该过程的 $\\varepsilon$-机是一个单状态机。从状态 $\\mathcal{S}_A$ 出发，过程以概率 $p$ 发出符号 $1$，以概率 $1-p$ 发出符号 $0$。由于只有一个状态，任何转移都必须返回到 $\\mathcal{S}_A$。转移结构是：\n- 在发出符号 $1$ 时，以概率 $p$ 从 $\\mathcal{S}_A$ 转移到 $\\mathcal{S}_A$。\n- 在发出符号 $0$ 时，以概率 $1-p$ 从 $\\mathcal{S}_A$ 转移到 $\\mathcal{S}_A$。\n\n**2. 统计复杂度 ($C_{\\mu}$)**\n\n统计复杂度 $C_{\\mu}$ 是因果状态上稳态分布 $\\pi(\\mathcal{S})$ 的香农熵。它量化了最优预测所需的记忆量（单位为奈特）。\n$$ C_{\\mu} = H[\\pi] = - \\sum_{s \\in \\mathcal{S}} \\pi(s) \\ln(\\pi(s)) $$\n在本例中，因果状态集为 $\\mathcal{S} = \\{\\mathcal{S}_A\\}$。稳态分布是平凡的，因为过程始终处于单一状态 $\\mathcal{S}_A$。因此，$\\pi(\\mathcal{S}_A) = 1$。\n统计复杂度因此为：\n$$ C_{\\mu} = - \\pi(\\mathcal{S}_A) \\ln(\\pi(\\mathcal{S}_A)) = -1 \\ln(1) = 0 $$\n解释：统计复杂度为 $0$ 表示该过程没有记忆。了解过去并不能改善对未来的预测，因此不需要存储任何关于过去的信息。这是无记忆（IID）过程的标志。\n\n**3. 熵率 ($h_{\\mu}$)**\n\n熵率 $h_{\\mu}$ 是在给定半无限过去的条件下，下一个符号的极限条件熵。它衡量了每个时间步过程中不可简化的不确定性或内在随机性。\n$$ h_{\\mu} = \\lim_{L \\to \\infty} H[X_0 | X_{-1}, X_{-2}, \\dots, X_{-L}] $$\n对于一个独立同分布（IID）过程，根据定义，下一个符号 $X_0$ 独立于所有过去的符号。因此，条件熵等于单个变量的无条件熵：\n$$ H[X_0 | X_{-1}, \\dots, X_{-L}] = H[X_0] $$\n熵率就是成功概率为 $p$ 的单次伯努利试验的熵。\n$$ h_{\\mu} = H[X_0] = - \\sum_{x \\in \\{0, 1\\}} \\mathbb{P}(X_0 = x) \\ln(\\mathbb{P}(X_0 = x)) $$\n$$ h_{\\mu} = -[\\mathbb{P}(X_0=1)\\ln(\\mathbb{P}(X_0=1)) + \\mathbb{P}(X_0=0)\\ln(\\mathbb{P}(X_0=0))] $$\n$$ h_{\\mu} = -[p \\ln(p) + (1-p) \\ln(1-p)] $$\n解释：熵率 $h_{\\mu}$ 是过程的基本不可预测性。对于一个独立同分布过程，这仅仅是与单个事件相关的不确定性，因为没有时间相关性可用于预测。\n\n**4. 超额熵 ($\\mathbf{E}$)**\n\n超额熵 $\\mathbf{E}$ 是半无限过去 $\\overleftarrow{X}$ 和半无限未来 $\\overrightarrow{X}$ 之间的互信息。\n$$ \\mathbf{E} = I[\\overleftarrow{X} ; \\overrightarrow{X}] $$\n它量化了过程中可预测结构的数量，或者说过去和未来共享了多少信息。两个随机变量 $A$ 和 $B$ 之间的互信息 $I[A; B]$ 为零，当且仅当它们是独立的。\n\n对于给定的独立同分布（IID）过程，任何过去的变量块 $\\overleftarrow{X} = (\\dots, X_{-2}, X_{-1})$ 都独立于任何未来的变量块 $\\overrightarrow{X} = (X_0, X_1, X_2, \\dots)$。\n因此，过去和未来之间的互信息为零。\n$$ \\mathbf{E} = I[\\overleftarrow{X} ; \\overrightarrow{X}] = 0 $$\n解释：超额熵为 $0$ 表明过去和未来之间没有共享信息。观察整个过去并不能提供任何有助于预测整个未来的信息，超出了从过程的基本统计数据中已知的信息。这证实了缺乏时间相关性或结构。\n\n总之，对于参数为 $p$ 的独立同分布伯努利过程：\n- 统计复杂度 $C_{\\mu} = 0$：该过程是无记忆的。\n- 熵率 $h_{\\mu} = -p \\ln(p) - (1-p) \\ln(1-p)$：该过程的随机性是单次有偏硬币投掷的不确定性。\n- 超额熵 $\\mathbf{E} = 0$：该过程缺乏过去与未来之间的任何时间结构或相关性。\n最终答案是一个包含这三个值的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  -p \\ln(p) - (1-p) \\ln(1-p)  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了无记忆过程的分析之后，我们现在转向一个包含简单时间相关性的系统。这个练习描述了一个带有噪声的周期性过程，你的任务是揭示其背后的隐藏结构。这需要你实践ε-机构建的核心步骤：通过将具有相同未来预测能力的过去历史进行归类，来识别出因果态。这个练习将教会你如何通过推理观测序列与未观测到的隐藏状态之间的关系，来发现最小的预测模型。",
            "id": "4118524",
            "problem": "考虑一个在字母表 $\\{0,1\\}$ 上的平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$，它由一个内部相位变量 $\\{S_t\\}_{t \\in \\mathbb{Z}}$（取值于 $\\{A,B\\}$）的双态隐源生成。内部相位确定性地交替：$S_{t+1} = \\sigma(S_t)$，其中 $\\sigma(A) = B$ 且 $\\sigma(B) = A$。符号产生规则如下：\n- 如果 $S_t = A$（“1-相位”），则 $X_t = 1$ 的概率为 $1-p$，$X_t = 0$ 的概率为 $p$。\n- 如果 $S_t = B$（“0-相位”），则 $X_t = 0$ 的概率为 $1$。\n\n假设 $p \\in (0,1)$ 是固定的，并且该过程已经无限期运行，因此处于其平稳状态。该信源实现了一个带噪声的周期为2的基线，其中符号 $1$ 本应与 $0$ 确定性地交替出现，但在内部相位为 $A$ 时，会以小的概率 $p$ 偶尔翻转为 $0$。\n\n使用计算力学的基本定义，通过将因果状态识别为产生相同半无限未来条件分布的半无限过去的等价类，来构建最小预测模型——计算力学ε-机。然后，根据信息论的第一性原理，推导观测过程的熵率 $h_{\\mu}$ 作为 $p$ 的函数。\n\n将 $h_{\\mu}$ 以比特/符号为单位表示。请以单个关于 $p$ 的闭式表达式给出最终答案。无需四舍五入。",
            "solution": "用户想要解决这个问题。\n问题验证如下：\n步骤1：提取给定条件。\n- 过程：在字母表 $\\mathcal{A} = \\{0,1\\}$ 上的平稳二元随机过程 $\\{X_t\\}_{t \\in \\mathbb{Z}}$。\n- 隐源：状态为 $\\{A,B\\}$ 的双态相位变量 $\\{S_t\\}_{t \\in \\mathbb{Z}}$。\n- 相位动力学：$S_{t+1} = \\sigma(S_t)$，其中 $\\sigma(A) = B$ 且 $\\sigma(B) = A$。\n- 产生概率：\n  - $P(X_t=1 | S_t=A) = 1-p$, $P(X_t=0 | S_t=A) = p$。\n  - $P(X_t=0 | S_t=B) = 1$, $P(X_t=1 | S_t=B) = 0$。\n- 参数：$p \\in (0,1)$。\n- 假设：该过程处于平稳状态。\n- 任务1：通过识别因果状态构建ε-机。\n- 任务2：推导熵率 $h_{\\mu}$ 作为 $p$ 的函数，单位为比特/符号。\n\n步骤2：使用提取的给定条件进行验证。\n- 科学或事实不健全性：该问题描述了一个具有特定确定性状态转移和随机符号产生的隐马尔可夫模型（HMM）。这是随机过程和计算力学研究中一个明确定义且标准的模型。没有违反任何科学原理。\n- 无法形式化或不相关：该问题是计算力学和信息论原理的直接和标准应用，特别与ε-机相关。\n- 不完整或矛盾的设置：过程被完全指定。动力学、产生概率和平稳性假设为分析提供了完整的基础。\n- 不切实际或不可行：该模型是一个有效的理论构造，代表一个带噪声的周期性过程。它在物理上并非不可能，在科学上亦非不合理。\n- 不适定或结构不良：寻找因果状态和熵率的任务是明确定义的。对于给定的平稳过程，ε-机及其熵率是唯一的，因此存在唯一解。\n- 伪深刻、琐碎或同义反复：该问题需要对因果状态的定义进行非平凡的应用，以发现最小预测模型，然后进行标准的信息论计算。它不是琐碎的。\n- 超出科学可验证性范围：结果在数学上是可推导和可验证的。\n\n步骤3：结论与行动。\n问题是 **有效的**。将提供完整解答。\n\n一个因果状态是半无限过去 $\\overleftarrow{x}_t = \\dots x_{t-2}x_{t-1}$ 的一个等价类。两个过去 $\\overleftarrow{x}_t$ 和 $\\overleftarrow{x}'_t$ 处于相同的因果状态，记作 $\\overleftarrow{x}_t \\sim \\overleftarrow{x}'_t$，当且仅当给定任一过去，所有可能未来的条件概率分布都相同：$P(\\overrightarrow{X}_t|\\overleftarrow{X}_t=\\overleftarrow{x}_t) = P(\\overrightarrow{X}_t|\\overleftarrow{X}_t=\\overleftarrow{x}'_t)$，其中 $\\overrightarrow{X}_t = X_t X_{t+1} \\dots$。\n\n对于给定的过程，观测序列 $\\{X_t\\}$ 的未来演化取决于隐相位 $\\{S_t\\}$ 的未来演化。由于相位动力学 $S_{t+1} = \\sigma(S_t)$ 是确定性的，如果当前相位 $S_t$ 已知，则整个未来相位序列 $\\{S_t, S_{t+1}, \\dots\\}$ 也就已知。因此，一个过去 $\\overleftarrow{x}_t$ 的预测能力完全由它在当前相位 $S_t$ 上诱导的条件概率分布（或称信念）所捕获，即向量 $(P(S_t=A|\\overleftarrow{x}_t), P(S_t=B|\\overleftarrow{x}_t))$。因果状态对应于基于观测过去可以形成的不同信念分布。\n\n我们旨在识别这些不同的信念分布。关键是理解一个过去提供了关于 $S_t$ 的什么信息。该过程是平稳的，并且由于 $p \\in (0,1)$，每当相位为 $A$ 时，产生一个 $1$ 的概率非零。随着相位在 $A$ 和 $B$ 之间交替，系统几乎必然不会产生无限的零序列。因此，在平稳状态下观测到的任何过去，都将以概率 $1$ 包含至少一个符号 $1$。\n\n让我们通过定位符号 $1$ 的最近一次出现来分析一个过去 $\\overleftarrow{x}_t$。设这次出现在时间 $t-k-1$（对于某个整数 $k \\ge 0$）。因此，该过去的形式为 $\\dots 1 \\underbrace{00\\dots0}_{k}$。\n符号产生 $X_{t-k-1}=1$ 只能由隐相位 $S_{t-k-1}=A$ 生成。\n使用确定性相位动力学 $S_{i+1}=\\sigma(S_i)$，我们可以唯一地确定任何后续时间的相位。时间 $t$ 的相位可以通过将转移映射 $\\sigma$ 应用 $t - (t-k-1) = k+1$ 步来找到。\n相位序列是 $S_{t-k-1}=A$, $S_{t-k}=B$, $S_{t-k+1}=A$，依此类推。如果 $j-(t-k-1)$ 是偶数，则相位 $S_j$ 为 $A$；如果是奇数，则为 $B$。对于当前时间 $t$，差值为 $t-(t-k-1) = k+1$。\n- 如果 $k$ 是偶数，则 $k+1$ 是奇数，这意味着 $S_t = \\sigma(A) = B$。\n- 如果 $k$ 是奇数，则 $k+1$ 是偶数，这意味着 $S_t = A$。\n\n该分析揭示，观测任何包含 $1$ 的过去都足以同步我们对隐相位的知识，使我们的信念坍缩为确定性。我们只有两种可能的信念分布：\n1.  所有以 $10^k$ 结尾的过去，其中 $k$ 是一个奇数（$k=1, 3, 5, \\dots$）。这些过去确定地意味着当前隐相位是 $A$。我们将这些归入一个单一的因果状态 $\\mathcal{C}_A$。对于任何 $\\overleftarrow{x}_t \\in \\mathcal{C}_A$，我们有 $P(S_t=A|\\overleftarrow{x}_t)=1$。\n2.  所有以 $10^k$ 结尾的过去，其中 $k$ 是一个非负偶数（$k=0, 2, 4, \\dots$）。这些过去确定地意味着当前隐相位是 $B$。我们将这些归入一个单一的因果状态 $\\mathcal{C}_B$。对于任何 $\\overleftarrow{x}_t \\in \\mathcal{C}_B$，我们有 $P(S_t=B|\\overleftarrow{x}_t)=1$。\n\n这两个状态 $\\mathcal{C}_A$ 和 $\\mathcal{C}_B$ 构成了ε-机的递归因果状态集。我们现在确定它们之间的转移。假设系统在时间 $t$ 处于状态 $\\mathcal{C}_s$。我们观测到符号 $X_t=x$，并在时间 $t+1$ 转移到状态 $\\mathcal{C}_{s'}$。该转移被标记为 $x|P(x|\\mathcal{C}_s)$。\n- 如果系统在时间 $t$ 处于 $\\mathcal{C}_A$，我们知道 $S_t=A$。\n  - 系统以概率 $1-p$ 产生 $X_t=1$。在时间 $t+1$ 的新过去以 $1$ 结尾。这对应于 $k=0$（偶数），所以新状态是 $\\mathcal{C}_B$。转移是 $\\mathcal{C}_A \\xrightarrow{1|(1-p)} \\mathcal{C}_B$。\n  - 系统以概率 $p$ 产生 $X_t=0$。之前的过去以 $10^k$ 结尾，其中 $k$ 为奇数。新的过去以 $10^{k+1}$ 结尾，其中 $k+1$ 现在是偶数。因此新状态是 $\\mathcal{C}_B$。转移是 $\\mathcal{C}_A \\xrightarrow{0|p} \\mathcal{C}_B$。\n- 如果系统在时间 $t$ 处于 $\\mathcal{C}_B$，我们知道 $S_t=B$。\n  - 系统以概率 $1$ 产生 $X_t=0$。之前的过去以 $10^k$ 结尾，其中 $k$ 为偶数。新的过去以 $10^{k+1}$ 结尾，其中 $k+1$ 现在是奇数。因此新状态是 $\\mathcal{C}_A$。转移是 $\\mathcal{C}_B \\xrightarrow{0|1} \\mathcal{C}_A$。\n  - 系统不能产生 $X_t=1$，因为 $P(X_t=1|S_t=B)=0$。\n\nε-机有两个状态 $\\{\\mathcal{C}_A, \\mathcal{C}_B\\}$，其转移如下：\n- $\\mathcal{C}_A \\xrightarrow{1|(1-p)} \\mathcal{C}_B$\n- $\\mathcal{C}_A \\xrightarrow{0|p} \\mathcal{C}_B$\n- $\\mathcal{C}_B \\xrightarrow{0|1} \\mathcal{C}_A$\n\n为了求熵率 $h_\\mu$，我们首先需要这些因果状态的平稳概率，记为 $\\pi_A = P(\\mathcal{C}_A)$ 和 $\\pi_B = P(\\mathcal{C}_B)$。设 $\\vec{\\pi} = (\\pi_A, \\pi_B)$ 为平稳分布向量。它必须是状态转移矩阵 $T$ 的特征值为 $1$ 的左特征向量，其中 $T_{ij} = P(\\text{下一状态是 } j | \\text{当前状态是 } i)$。\n$P(\\mathcal{C}_B | \\mathcal{C}_A) = P(X_t=1|\\mathcal{C}_A) + P(X_t=0|\\mathcal{C}_A) = (1-p) + p = 1$。\n$P(\\mathcal{C}_A | \\mathcal{C}_A) = 0$。\n$P(\\mathcal{C}_A | \\mathcal{C}_B) = P(X_t=0|\\mathcal{C}_B) = 1$。\n$P(\\mathcal{C}_B | \\mathcal{C}_B) = 0$。\n转移矩阵是 $T = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$。平稳分布必须满足 $\\vec{\\pi}T = \\vec{\\pi}$，即 $(\\pi_A, \\pi_B) \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} = (\\pi_B, \\pi_A)$。这得出 $\\pi_A = \\pi_B$。结合归一化条件 $\\pi_A + \\pi_B = 1$，我们得到 $\\pi_A = \\pi_B = \\frac{1}{2}$。\n\n由ε-机描述的过程的熵率 $h_{\\mu}$ 是在已知当前因果状态的情况下，下一个符号的平均不确定性。该平均值是对因果状态的平稳分布进行加权平均。其公式（以比特/符号为单位）为：\n$$h_{\\mu} = \\sum_{s \\in \\{\\mathcal{C}_A, \\mathcal{C}_B\\}} \\pi_s H(X|s)$$\n其中 $H(X|s) = -\\sum_{x \\in \\{0,1\\}} P(x|s) \\log_2 P(x|s)$ 是从状态 $s$ 产生的分布的香农熵。\n\n我们为每个状态计算 $H(X|s)$：\n- 对于状态 $\\mathcal{C}_A$：\n  产生概率为 $P(X_t=0|\\mathcal{C}_A)=p$ 和 $P(X_t=1|\\mathcal{C}_A)=1-p$。\n  $H(X|\\mathcal{C}_A) = -[p \\log_2(p) + (1-p)\\log_2(1-p)]$。这是二元熵函数 $H_b(p)$。\n- 对于状态 $\\mathcal{C}_B$：\n  产生概率为 $P(X_t=0|\\mathcal{C}_B)=1$ 和 $P(X_t=1|\\mathcal{C}_B)=0$。\n  $H(X|\\mathcal C_B) = -[1 \\log_2(1) + 0 \\cdot \\lim_{q\\to 0} \\log_2(q)] = 0$。从状态 $\\mathcal{C}_B$ 产生符号没有不确定性。\n\n将这些分量代入 $h_{\\mu}$ 的公式中：\n$$h_{\\mu} = \\pi_A H(X|\\mathcal{C}_A) + \\pi_B H(X|\\mathcal{C}_B)$$\n$$h_{\\mu} = \\frac{1}{2} H_b(p) + \\frac{1}{2} \\cdot 0$$\n$$h_{\\mu} = \\frac{1}{2} H_b(p) = -\\frac{1}{2} [p \\log_2(p) + (1-p)\\log_2(1-p)]$$\n这就是观测过程的熵率，单位是比特/符号。",
            "answer": "$$\n\\boxed{-\\frac{1}{2}\\left(p \\log_2(p) + (1-p)\\log_2(1-p)\\right)}\n$$"
        },
        {
            "introduction": "最后一个练习将理论与现实世界的数据分析连接起来。你将实现一个基于数据的因果态归纳程序，这正是从观测中重构ε-机的核心思想。这个任务要求你处理有限样本、运用统计检验（如卡方检验）来判断分布的等价性，并考虑多重检验校正等实际问题。完成这个练习会让你对如何从经验数据中算法化地重构ε-机有一个具体而深入的理解，这是任何计算力学实践者都应具备的关键技能。",
            "id": "4118473",
            "problem": "您的任务是实现一个端到端的近似因果态归纳程序，该程序基于计算力学和ε-机，并使用有限样本。在计算力学中，因果态被定义为产生相同未来预测分布的过去的等价类。在本问题中，我们仅关注下一个符号的预测分布，作为一种有限样本近似。对于给定的以每个长度为 $L$ 的过去为条件的下一个符号观测的经验计数集，使用关于分布等价性的假设检验来归纳近似因果态。\n\n定义和基础：\n- 长度为 $L$ 的过去表示为 $\\overleftarrow{x}^{L}$。下一个符号表示为 $x_{0}$。\n- 对于每个过去 $\\overleftarrow{x}^{L}$，预测分布为 $P(x_{0} \\mid \\overleftarrow{x}^{L})$。在有限样本中，这是通过在大小为 $K$ 的离散字母表上的经验频率来估计的。\n- 基于计算力学等价关系的因果态定义是：两个过去 $\\overleftarrow{x}^{L}$ 和 $\\overleftarrow{y}^{L}$ 是等价的，当且仅当对于字母表中的所有 $x_{0}$，都有 $P(x_{0} \\mid \\overleftarrow{x}^{L}) = P(x_{0} \\mid \\overleftarrow{y}^{L})$。ε-机是一种最小表示，其节点是因果态，其边编码由过程引起的状态转移结构。\n\n要实现的程序：\n1. 使用同质性卡方检验来检验任意一对过去 $(i,j)$ 之间的零假设 $H_{0}: P(x_{0} \\mid \\overleftarrow{x}^{L}_{i}) = P(x_{0} \\mid \\overleftarrow{x}^{L}_{j})$（对于所有 $x_{0}$）。为这两个过去构建一个 $2 \\times K$ 的列联表，数据来源于经验计数。为了在低计数情况下保持稳定性，在检验前应用对称狄利克雷平滑，伪计数为 $\\lambda$，即为每个单元格加上 $\\lambda$。取 $\\lambda = 0.5$。\n2. 对于多重假设检验，使用 Benjamini-Hochberg (BH) 程序在水平 $q$ 上控制错误发现率 (FDR)。Benjamini-Hochberg (BH) 程序对所有成对的 $p$ 值进行排序 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(M)}$，并拒绝所有满足 $p_{(k)} \\le \\frac{k}{M} q$ 的零假设 $H_{0}$，其中 $k$ 是满足该条件的最大值，$M$ 是检验的对数。\n3. 在过去索引 $\\{0,1,\\dots,m-1\\}$ 上构建一个无向接受图：如果经 BH 校正的决策未能拒绝关于对 $(i,j)$ 的零假设 $H_{0}$（即它们没有显著差异），则用一条边连接节点 $i$ 和 $j$。\n4. 将此接受图的连通分量作为归纳出的近似因果态。每个分量是一个近似因果态。将每个分量内的索引按升序排序。然后按每个分量的最小索引对分量列表进行排序。\n\n科学真实性和一致性要求：\n- 使用同质性卡方检验，并采用狄利克雷平滑 $\\lambda = 0.5$。\n- 在水平 $q$ 上使用 BH 控制。\n- 该程序在样本量增加时具有一致性，因为卡方检验在区分不相等的多项分布时是一致的，并且 BH 控制了错误发现率；在标准正则性条件下，随着样本数的增长，接受图的连通分量会收敛到真实的等价类。\n\n实现和测试套件的输入数据：\n您将获得三个测试用例。每个用例都指定了计数矩阵 $C^{(t)}$（形状为 $m_{t} \\times K_{t}$，其中第 $i$ 行包含关于 $P(x_{0} \\mid \\overleftarrow{x}^{L}_{i})$ 在字母表类别上的计数）和 BH 水平 $q^{(t)}$。\n\n- 测试用例 1：\n  - $C^{(1)} = \\begin{bmatrix}\n  100  50  50 \\\\\n  100  50  50 \\\\\n  150  0  0 \\\\\n  0  0  200 \\\\\n  0  0  200 \\\\\n  150  0  0\n  \\end{bmatrix}$,\n  - $q^{(1)} = 0.1$。\n\n- 测试用例 2（低计数边缘情况）：\n  - $C^{(2)} = \\begin{bmatrix}\n  1  0  0 \\\\\n  1  0  0 \\\\\n  0  1  0 \\\\\n  0  0  1\n  \\end{bmatrix}$,\n  - $q^{(2)} = 0.1$。\n\n- 测试用例 3（近似等价的边界情况）：\n  - $C^{(3)} = \\begin{bmatrix}\n  50  50  0  0 \\\\\n  51  49  0  0 \\\\\n  25  75  0  0 \\\\\n  0  0  40  60 \\\\\n  0  0  38  62\n  \\end{bmatrix}$,\n  - $q^{(3)} = 0.1$。\n\n输出规范：\n- 对于每个测试用例，输出归纳出的分区，格式为由列表组成的列表，其中每个内部列表代表一个近似因果态，包含从 0 开始的过去索引。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表恰好包含与三个测试用例相对应的三个条目。例如，格式必须像 $[result_{1},result_{2},result_{3}]$，其中每个 $result_{t}$ 是上述的列表的列表。",
            "solution": "我们从计算力学中因果态的核心定义开始：两个过去 $\\overleftarrow{x}^{L}$ 和 $\\overleftarrow{y}^{L}$ 处于同一因果态，当且仅当它们对未来的预测分布是相同的。在实践中，我们用下一个符号 $x_{0}$ 来近似未来，并使用有限样本通过在大小为 $K$ 的离散字母表上的经验计数来估计 $P(x_{0} \\mid \\overleftarrow{x}^{L})$。\n\n有原则的统计检验：\n- 对于任意一对过去 $(i,j)$，将其经验计数向量表示为 $\\mathbf{c}_{i} \\in \\mathbb{N}^{K}$ 和 $\\mathbf{c}_{j} \\in \\mathbb{N}^{K}$。在零假设 $H_{0}: P(x_{0} \\mid \\overleftarrow{x}^{L}_{i}) = P(x_{0} \\mid \\overleftarrow{x}^{L}_{j})$ 下，这两个多项分布是相等的。在 $2 \\times K$ 列联表上通过卡方统计量进行的同质性检验是比较多项分布的成熟方法。\n- 低计数和零单元格会使期望计数不稳定。一个标准的解决方法是对称狄利克雷平滑：为每个单元格添加一个伪计数 $\\lambda$，得到 $\\tilde{\\mathbf{c}}_{i} = \\mathbf{c}_{i} + \\lambda \\cdot \\mathbf{1}_{K}$ 和 $\\tilde{\\mathbf{c}}_{j} = \\mathbf{c}_{j} + \\lambda \\cdot \\mathbf{1}_{K}$，其中 $\\lambda = 0.5$（Jeffreys 先验）。这在保持检验一致性的同时提高了数值稳定性。\n\n多重检验控制：\n- 对于 $m$ 个过去，存在 $M = \\frac{m(m-1)}{2}$ 个成对检验。为了控制错误发现率 (FDR)，使用 Benjamini-Hochberg (BH) 程序，水平为 $q$。对 $p$ 值进行排序 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(M)}$，并找到最大的 $k$ 使得 $p_{(k)} \\le \\frac{k}{M}q$。拒绝所有秩 $\\le k$ 的零假设 $H_{0}$；其余的假设则不被拒绝。\n- BH 程序是经过充分检验的，并且在 $p$ 值独立或具有某些正相关结构的情况下，它能将 FDR 控制在水平 $q$。在我们的情境中，它适当地平衡了多次成对比较中的 I 型和 II 型错误。\n\n基于图的近似因果态归纳：\n- 在顶点集 $\\{0,1,\\dots,m-1\\}$ 上构建一个无向接受图 $G$，如果 BH 决策未能拒绝关于某对 $(i, j)$ 的零假设 $H_{0}$，则用一条边连接 $i$ 和 $j$。这条边代表了经验证据，表明在所选的 FDR 水平下，这两个过去的下一个符号分布是不可区分的。\n- 通过取 $G$ 的连通分量来归纳近似因果态。每个连通分量都是一组通过未被拒绝的等价性检验而相互关联（可能具有传递性）的过去。对每个分量内的索引进行排序，并按每个分量的最小索引对分量进行排序，可以确定一个规范的表示形式。\n\n一致性：\n- 同质性卡方检验是一致的，这意味着对于任意两个不相等的多项分布，随着总计数的增长，检验拒绝 $H_{0}$ 的概率趋于 1。反之，对于相等的分布，$p$ 值渐近地在 $[0,1]$ 上均匀分布，而 BH 控制 FDR，从而以高概率防止过度合并。\n- 随着样本量的增加，所有真正不相等的对都将被拒绝，而所有真正相等的对都将不被拒绝（在受控的 FDR 范围内）。接受图收敛于对应于真实等价类的团的并集。在大样本极限下，连通分量与这些等价类重合。使用固定的 $\\lambda$ 进行狄利克雷平滑不会改变渐近决策。\n\n算法步骤：\n1. 对于每个测试用例，读取 $C^{(t)}$ 和 $q^{(t)}$。\n2. 对于每一对 $(i,j)$，使用平滑后的计数 $\\lambda = 0.5$ 形成 $2 \\times K$ 列联表，并计算同质性卡方检验的 $p$ 值。\n3. 在水平 $q^{(t)}$ 上应用 BH，将各对分为拒绝和不拒绝两类。\n4. 从未被拒绝的对构建接受图，并计算连通分量。\n5. 对分量内的索引进行排序，并按分量的最小索引对分量进行排序。\n6. 为每个测试用例输出分量列表。\n\n在提供的测试套件上的预期行为：\n- 测试用例 1：存在三个具有相同分布的不同组：索引 $\\{0,1\\}$、$\\{2,5\\}$ 和 $\\{3,4\\}$。跨组的对差异显著，因此被拒绝；组内的对则被接受。归纳出的分区是 $[[0,1],[2,5],[3,4]]$。\n- 测试用例 2：低计数为三个不同类别产生了确定性分布。对 $\\{0,1\\}$ 是相同的，因此被接受；其他的则被拒绝。归纳出的分区是 $[[0,1],[2],[3]]$。\n- 测试用例 3：$\\{0,1\\}$ 之间以及 $\\{3,4\\}$ 之间近似等价，而 $\\{2\\}$ 明显不同。归纳出的分区是 $[[0,1],[2],[3,4]]$。\n\n最终的程序实现了这一过程，并以所需格式打印一行包含三个归纳分区的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2_contingency\nimport json\nfrom itertools import combinations\n\ndef benjamini_hochberg(pvals, pairs, q):\n    \"\"\"\n    Benjamini-Hochberg FDR control.\n    Parameters:\n        pvals: list of p-values\n        pairs: list of (i,j) corresponding to pvals\n        q: target FDR level\n    Returns:\n        rejected_pairs: set of pairs (i,j) where H0 is rejected\n    \"\"\"\n    m = len(pvals)\n    if m == 0:\n        return set()\n    # Sort p-values with their pairs\n    sorted_indices = np.argsort(pvals)\n    p_sorted = np.array(pvals)[sorted_indices]\n    pairs_sorted = [pairs[idx] for idx in sorted_indices]\n\n    # Find largest k such that p_(k) = (k/m)*q\n    k_star = 0 # rank is 1-based, k_star is 0-based index\n    for rank, p in enumerate(p_sorted, start=1):\n        if p = (rank / m) * q:\n            k_star = rank\n\n    rejected_pairs = set()\n    if k_star > 0:\n        for idx in range(k_star):\n            rejected_pairs.add(pairs_sorted[idx])\n\n    return rejected_pairs\n\ndef induce_states(counts, q, lambda_smooth=0.5):\n    \"\"\"\n    Induce approximate causal states from counts via BH-corrected chi-square tests.\n    Parameters:\n        counts: numpy array of shape (m, K)\n        q: FDR level for BH\n        lambda_smooth: Dirichlet smoothing pseudocount added to each cell\n    Returns:\n        partition: list of lists of indices (each inner list is a connected component)\n    \"\"\"\n    m, K = counts.shape\n    # Prepare all pairwise tests\n    pvals = []\n    pairs = []\n    for i, j in combinations(range(m), 2):\n        # Apply symmetric Dirichlet smoothing\n        row_i = counts[i, :] + lambda_smooth\n        row_j = counts[j, :] + lambda_smooth\n        table = np.vstack([row_i, row_j])\n        # Chi-squared test for homogeneity\n        # correction=False to use Pearson's chi2 without Yates correction\n        chi2, p, dof, expected = chi2_contingency(table, correction=False)\n        # Handle potential numerical issues: ensure p is finite\n        if not np.isfinite(p):\n            # Fallback: if p is nan due to degeneracy, treat as highly different\n            p = 0.0\n        pvals.append(p)\n        pairs.append((i, j))\n\n    # Apply BH to determine which pairs are significantly different\n    rejected_pairs = benjamini_hochberg(pvals, pairs, q)\n\n    # Build acceptance graph: edge if NOT rejected\n    adjacency = {i: set() for i in range(m)}\n    for (i, j), p in zip(pairs, pvals):\n        if (i, j) not in rejected_pairs:\n            adjacency[i].add(j)\n            adjacency[j].add(i)\n\n    # Connected components via BFS\n    visited = [False] * m\n    components = []\n    for start in range(m):\n        if not visited[start]:\n            queue = [start]\n            visited[start] = True\n            comp = []\n            while queue:\n                u = queue.pop(0)\n                comp.append(u)\n                for v in adjacency[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        queue.append(v)\n            comp.sort()\n            components.append(comp)\n\n    # Sort components by their smallest index for canonical ordering\n    components.sort(key=lambda lst: lst[0] if lst else -1)\n    return components\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([\n                [100, 50, 50],\n                [100, 50, 50],\n                [150, 0, 0],\n                [0,   0, 200],\n                [0,   0, 200],\n                [150, 0, 0]\n            ], dtype=float),\n            0.1\n        ),\n        # Test case 2 (low-count edge case)\n        (\n            np.array([\n                [1, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ], dtype=float),\n            0.1\n        ),\n        # Test case 3 (boundary with near-equivalence)\n        (\n            np.array([\n                [50, 50, 0, 0],\n                [51, 49, 0, 0],\n                [25, 75, 0, 0],\n                [0,  0, 40, 60],\n                [0,  0, 38, 62]\n            ], dtype=float),\n            0.1\n        )\n    ]\n\n    results = []\n    for counts, q in test_cases:\n        partition = induce_states(counts, q, lambda_smooth=0.5)\n        results.append(partition)\n\n    # Final print statement in the exact required format: single line, JSON-like with no spaces.\n    print(json.dumps(results, separators=(',', ':')))\n\nsolve()\n```"
        }
    ]
}