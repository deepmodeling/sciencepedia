{
    "hands_on_practices": [
        {
            "introduction": "在验证一个复杂的模型之前，我们必须首先理解其输出不确定性的来源。一个模型通常包含众多参数，但并非所有参数都对输出的不确定性有同等程度的贡献。本练习运用概率论中的基本定理——全方差公式，来分析性地分解模型总输出方差，从而量化不同参数子集所带来的不确定性。通过这项实践，您将学会如何为参数子集的方差贡献推导严格的界限，这有助于您建立一种系统性的敏感性分析方法，为决定哪些参数最需要投入资源进行实证验证提供理论依据。",
            "id": "4127760",
            "problem": "考虑一个复杂自适应系统模型，其随机输出 $Y$ 依赖于一个不确定参数向量 $X = (X_{S}, X_{T})$，其中 $X_{S}$ 是为可能的目标验证而选择的参数子集，$X_{T}$ 表示其余参数。假设以下基本依据：方差的定义 $\\operatorname{Var}(Y) = \\mathbb{E}\\!\\left[(Y - \\mathbb{E}[Y])^{2}\\right]$，条件期望和条件方差 $\\mathbb{E}[Y \\mid X_{S}]$ 与 $\\operatorname{Var}(Y \\mid X_{S})$，以及全方差公式 $\\operatorname{Var}(Y) = \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] + \\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$。\n\n您获得一个科学合理的验证场景：一个大型、已收敛的模拟运行系综产生了一个总输出方差的经验稳定估计值 $\\operatorname{Var}(Y) = 4.50 \\times 10^{2}$。独立的验证实验在一个为 $X_{S}$ 校准的可信集 $\\mathcal{C}$（其中 $\\mathbb{P}(X_{S} \\in \\mathcal{C}) = 1$）上约束了条件方差，并确定对于每一个 $x_{s} \\in \\mathcal{C}$，条件方差满足 $v_{\\min} \\leq \\operatorname{Var}(Y \\mid X_{S} = x_{s}) \\leq v_{\\max}$，其中 $v_{\\min} = 1.40 \\times 10^{2}$ 且 $v_{\\max} = 2.20 \\times 10^{2}$。\n\n仅从这些基本依据出发，推导由 $X_{S}$ 引起的方差贡献（由 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 量化）的严格下界和上界，然后表达 $X_{S}$ 对总输出方差的分数贡献的相应界限，该分数贡献定义为\n$$F_{S} \\equiv \\frac{\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)}{\\operatorname{Var}(Y)}.$$\n使用给定值计算 $F_{S}$ 的两个数值界限，并将结果四舍五入到四位有效数字。使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境将这两个界限表示为一个行矩阵。最后，简要解释这些界限如何从业已减少输出不确定性的角度，为 $X_{S}$ 的目标验证决策提供信息。该解释是您推理的一部分，但不属于最终答案输出规范的一部分。",
            "solution": "该问题陈述具有科学依据、是适定的，并包含了获得唯一解所需的所有信息。其前提基于全方差公式（概率论中的一个标准定理），所描述的场景是不确定性量化和模型验证领域的常规应用。因此，该问题是有效的，我们着手求解。\n\n我们的出发点是全方差公式，它根据一个条件变量（在此例中为参数向量子集 $X_{S}$）来分解随机变量 $Y$ 的总方差。该公式为：\n$$\n\\operatorname{Var}(Y) = \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] + \\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)\n$$\n项 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 表示输出 $Y$ 的方差中可由参数 $X_{S}$ 的不确定性解释的部分。这是我们感兴趣的量。我们可以通过重新整理方程来分离它：\n$$\n\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right) = \\operatorname{Var}(Y) - \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]\n$$\n我们已知总方差 $\\operatorname{Var}(Y) = 4.50 \\times 10^{2}$。为了找到 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 的界限，我们必须首先确定项 $\\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]$ 的界限。\n\n问题指出，独立的验证实验已确定，对于随机向量 $X_{S}$ 在其可信集 $\\mathcal{C}$（其中 $\\mathbb{P}(X_{S} \\in \\mathcal{C}) = 1$）内的任何实现 $x_{s}$，条件方差 $\\operatorname{Var}(Y \\mid X_{S} = x_{s})$ 是有界的。因此，随机变量 $Z \\equiv \\operatorname{Var}(Y \\mid X_{S})$ 几乎必然地满足不等式：\n$$\nv_{\\min} \\leq Z \\leq v_{\\max}\n$$\n这些界限的值已给出，$v_{\\min} = 1.40 \\times 10^{2}$ 且 $v_{\\max} = 2.20 \\times 10^{2}$。\n\n期望算子是单调的。如果一个随机变量 $A$ 被常数 $c_{1}$ 和 $c_{2}$ 所界定，使得 $\\mathbb{P}(c_{1} \\leq A \\leq c_{2}) = 1$，那么它的期望也受同样的常数界定：$c_{1} \\leq \\mathbb{E}[A] \\leq c_{2}$。将此性质应用于随机变量 $Z = \\operatorname{Var}(Y \\mid X_{S})$，我们得到其期望的界限：\n$$\n\\mathbb{E}[v_{\\min}] \\leq \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] \\leq \\mathbb{E}[v_{\\max}]\n$$\n由于 $v_{\\min}$ 和 $v_{\\max}$ 是常数，它们的期望就是它们自身的值。因此：\n$$\nv_{\\min} \\leq \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] \\leq v_{\\max}\n$$\n现在我们可以将这些界限代回到我们关于 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 的表达式中。\n为了获得 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 的下界，我们必须减去 $\\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]$ 的最大可能值，即 $v_{\\max}$：\n$$\n\\left(\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)\\right)_{\\min} = \\operatorname{Var}(Y) - v_{\\max}\n$$\n为了获得上界，我们必须减去 $\\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]$ 的最小可能值，即 $v_{\\min}$：\n$$\n\\left(\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)\\right)_{\\max} = \\operatorname{Var}(Y) - v_{\\min}\n$$\n这就为来自 $X_{S}$ 的方差贡献建立了严格的不等式：\n$$\n\\operatorname{Var}(Y) - v_{\\max} \\leq \\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right) \\leq \\operatorname{Var}(Y) - v_{\\min}\n$$\n问题要求分数贡献 $F_{S}$ 的界限，其定义为：\n$$\nF_{S} \\equiv \\frac{\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)}{\\operatorname{Var}(Y)}\n$$\n由于 $\\operatorname{Var}(Y)$ 是一个正常数，我们可以将整个不等式除以它而不改变不等号的方向：\n$$\n\\frac{\\operatorname{Var}(Y) - v_{\\max}}{\\operatorname{Var}(Y)} \\leq F_{S} \\leq \\frac{\\operatorname{Var}(Y) - v_{\\min}}{\\operatorname{Var}(Y)}\n$$\n这可以简化为：\n$$\n1 - \\frac{v_{\\max}}{\\operatorname{Var}(Y)} \\leq F_{S} \\leq 1 - \\frac{v_{\\min}}{\\operatorname{Var}(Y)}\n$$\n现在，我们代入给定的数值：\n$\\operatorname{Var}(Y) = 4.50 \\times 10^{2} = 450$\n$v_{\\min} = 1.40 \\times 10^{2} = 140$\n$v_{\\max} = 2.20 \\times 10^{2} = 220$\n\n$F_{S}$ 的下界是：\n$$\n(F_{S})_{\\min} = 1 - \\frac{220}{450} = 1 - \\frac{22}{45} = \\frac{23}{45} \\approx 0.51111...\n$$\n四舍五入到四位有效数字，我们得到 $(F_{S})_{\\min} = 0.5111$。\n\n$F_{S}$ 的上界是：\n$$\n(F_{S})_{\\max} = 1 - \\frac{140}{450} = 1 - \\frac{14}{45} = \\frac{31}{45} \\approx 0.68888...\n$$\n四舍五入到四位有效数字，我们得到 $(F_{S})_{\\max} = 0.6889$。\n\n因此，参数 $X_S$ 对总输出方差的分数贡献位于区间 $[0.5111, 0.6889]$ 内。\n\n解释：$F_S$ 的界限为参数子集 $X_S$ 的重要性提供了定量评估。结果表明，$X_S$ 的不确定性至少造成了总输出方差的 $51.11\\%$，至多造成了 $68.89\\%$。这是一个实质性的贡献。如果能通过验证实验完全确定 $X_S$ 中参数的真实值，模型输出的总方差将减少在此范围内的某个量。这为优先投入更多实验和验证资源以减少参数 $X_S$ 的不确定性提供了有力依据，因为这样做保证能显著减少整体模型的不确定性。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.5111 & 0.6889\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "当我们识别出模型不确定性的关键来源后，就需要设计实验（无论是真实世界实验还是计算实验）来将模型与数据进行对比。一个核心问题是：我们需要多少数据才能有信心地检测出模型与现实之间的显著差异？本练习将深入探讨统计功效分析，特别考虑了复杂自适应系统输出的时间序列中普遍存在的自相关性。您将通过编程实现计算统计功效和所需最小模拟运行次数的算法，这将为您提供一个至关重要的实用工具，用以设计高效且有效的验证研究，确保实验既不会因规模过大而浪费资源，也不会因数据不足而无法得出结论。",
            "id": "4127738",
            "problem": "您的任务是开发一个程序，用于计算检测一个突现时间序列中特定差异的统计功效，并为复杂自适应系统建模下的验证实验论证其样本量要求。每次实验运行的突现观测结果是一个时间序列 $\\{Y_{r,t}\\}_{t=1}^{T}$，其中 $r \\in \\{1,\\ldots,R\\}$ 是独立运行的索引。每个序列被假定为通过 $Y_{r,t} = \\mu + \\varepsilon_{r,t}$ 生成，其中 $\\{\\varepsilon_{r,t}\\}$ 是一个平稳的一阶高斯自回归过程（AR(1)），其边际标准差为 $\\sigma$，自相关参数为 $\\rho \\in (-1,1)$。验证实验旨在检测参考模型与经验数据之间长期平均水平的差异 $\\delta$，这通过对两种条件下总均值差异的假设检验来形式化。假设两种条件下的运行是独立同分布的，具有相同的 $\\sigma$、$\\rho$ 和 $T$。使用显著性水平为 $\\alpha$ 的双边检验。\n\n从协方差和中心极限定理（CLT）的基本定义出发，将每次运行的时间平均值 $\\bar{Y}_{r} = \\frac{1}{T}\\sum_{t=1}^{T}Y_{r,t}$ 作为单次运行中均值的基本估计量。利用以下事实：对于平稳过程，时间平均值的方差可以通过自协方差函数表示；对于边际方差为 $\\sigma^{2}$、自相关参数为 $\\rho$ 的AR(1)过程，滞后项之间的自协方差满足 $\\operatorname{Cov}(\\varepsilon_{r,t},\\varepsilon_{r,t+k}) = \\sigma^{2}\\rho^{|k|}$。因此，时间平均值的方差必须包含自相关结构。$R$ 次独立运行的总均值为 $\\bar{M} = \\frac{1}{R}\\sum_{r=1}^{R}\\bar{Y}_{r}$。在两种条件的比较下，考虑总均值的差异，并推导在备择假设（真实均值差异为 $\\delta \\neq 0$）下的统计功效表达式。\n\n您的程序必须：\n- 使用协方差求和恒等式，计算AR(1)过程中每次运行的时间平均值 $\\bar{Y}_{r}$ 的方差。\n- 利用运行和条件间的独立性，计算两种条件下总均值差异的方差。\n- 对于给定的 $(\\sigma,\\rho,T,R)$，计算用于检测特定差异 $\\delta$ 的双边检验（在显著性水平 $\\alpha$ 下）的统计功效（以小数形式表示，而非百分比）。\n- 计算在显著性水平 $\\alpha$ 下检测差异 $\\delta$ 时，为达到至少目标功效 $p_{\\star}$ 所需的最小独立运行次数（整数）$R_{\\min}$（$T$ 固定）。\n\n所有功效值均以小数单位表示（例如，$0.8$），而非百分比。不涉及物理单位，也不涉及角度。\n\n测试套件：\n使用以下参数集，每个参数集表示为 $(\\delta,\\sigma,\\rho,T,R,\\alpha,p_{\\star})$：\n1. $(0.5, 1.0, 0.3, 200, 10, 0.05, 0.8)$\n2. $(0.5, 1.0, 0.8, 10, 10, 0.05, 0.8)$\n3. $(0.1, 1.0, 0.95, 1000, 20, 0.05, 0.9)$\n4. $(0.2, 1.0, 0.0, 100, 5, 0.05, 0.8)$\n5. $(0.01, 1.0, 0.5, 10000, 50, 0.01, 0.9)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个二元列表 $[\\text{power}, R_{\\min}]$，其中 $\\text{power}$ 是给定 $R$ 下的浮点数功效值，$R_{\\min}$ 是在相同 $(\\delta,\\sigma,\\rho,T,\\alpha)$ 条件下达到至少 $p_{\\star}$ 功效所需的最小整数运行次数。输出行的格式示例为 $[[0.812345,9],[0.123456,87],\\ldots]$，其中每个功效值四舍五入到六位小数。",
            "solution": "目标是计算检测复杂自适应系统的时间序列突现均值中差异的统计功效，并从独立运行次数的角度为样本量提供论证。我们从基本依据出发：平稳过程中的协方差定义和中心极限定理（CLT），然后推导单次运行时间平均值的方差，构建两种条件下总均值差异的方差，最后推断备择假设下的统计功效。\n\n考虑单次运行 $r$，其时间序列为 $Y_{r,t} = \\mu + \\varepsilon_{r,t}$（$t = 1,\\ldots,T$），其中 $\\{\\varepsilon_{r,t}\\}$ 是一个平稳的一阶高斯自回归过程（AR(1)），边际方差为 $\\sigma^{2}$，自相关参数为 $\\rho \\in (-1,1)$。每次运行的时间平均值为 $\\bar{Y}_{r} = \\frac{1}{T}\\sum_{t=1}^{T}Y_{r,t}$。由于 $\\varepsilon_{r,t}$ 的均值为零，所以 $\\mathbb{E}[\\bar{Y}_{r}] = \\mu$，且 $\\bar{Y}_{r}$ 的方差取决于自协方差结构。平稳过程的方差恒等式表明\n$$\n\\operatorname{Var}(\\bar{Y}_{r}) \\;=\\; \\operatorname{Var}\\left(\\frac{1}{T}\\sum_{t=1}^{T}Y_{r,t}\\right) \\;=\\; \\frac{1}{T^{2}} \\sum_{i=1}^{T} \\sum_{j=1}^{T} \\operatorname{Cov}(Y_{r,i}, Y_{r,j}).\n$$\n由于 $Y_{r,t}$ 与 $\\varepsilon_{r,t}$ 仅相差一个常数偏移量 $\\mu$，其协方差完全来自 $\\varepsilon_{r,t}$。对于边际方差为 $\\sigma^{2}$ 的 AR(1) 过程，滞后 $k$ 阶的自协方差为 $\\operatorname{Cov}(\\varepsilon_{r,t},\\varepsilon_{r,t+k}) = \\sigma^{2}\\rho^{|k|}$。利用协方差的对称性并按滞后阶数分组，我们得到\n$$\n\\operatorname{Var}(\\bar{Y}_{r}) \\;=\\; \\frac{1}{T^{2}} \\left( T \\cdot \\sigma^{2} + 2 \\sum_{k=1}^{T-1} (T - k) \\cdot \\sigma^{2} \\rho^{k} \\right)\n\\;=\\; \\frac{\\sigma^{2}}{T}\\left( 1 + 2 \\sum_{k=1}^{T-1}\\left(1 - \\frac{k}{T}\\right)\\rho^{k} \\right).\n$$\n该恒等式表明，相对于独立情况（对应于 $\\rho = 0$ 且得出 $\\operatorname{Var}(\\bar{Y}_{r}) = \\sigma^{2}/T$），自相关如何增大了时间平均值的方差。\n\n假设有两个条件，记为 $A$ 和 $B$，每个条件都有 $R$ 次长度为 $T$ 的独立运行，并假定条件 $B$ 的长期均值与条件 $A$ 相差 $\\delta$，因此 $\\mu_{B} = \\mu_{A} + \\delta$。在每个条件下，所有运行的总均值为\n$$\n\\bar{M}_{A} = \\frac{1}{R}\\sum_{r=1}^{R}\\bar{Y}^{(A)}_{r}, \\qquad \\bar{M}_{B} = \\frac{1}{R}\\sum_{r=1}^{R}\\bar{Y}^{(B)}_{r}.\n$$\n根据运行的独立性，当两个条件共享相同的 $\\sigma$、$\\rho$ 和 $T$ 时，$\\operatorname{Var}(\\bar{M}_{A}) = \\operatorname{Var}(\\bar{Y}_{r})/R$ 且 $\\operatorname{Var}(\\bar{M}_{B}) = \\operatorname{Var}(\\bar{Y}_{r})/R$。总均值的差异 $\\hat{\\Delta} = \\bar{M}_{B} - \\bar{M}_{A}$ 的方差为\n$$\n\\operatorname{Var}(\\hat{\\Delta}) \\;=\\; \\operatorname{Var}(\\bar{M}_{B}) + \\operatorname{Var}(\\bar{M}_{A})\n\\;=\\; \\frac{2}{R}\\operatorname{Var}(\\bar{Y}_{r})\n\\;=\\; \\frac{2\\sigma^{2}}{R T}\\left( 1 + 2 \\sum_{k=1}^{T-1}\\left(1 - \\frac{k}{T}\\right)\\rho^{k} \\right).\n$$\n在备择假设下，即真实均值差异为 $\\delta \\neq 0$ 时，基于 $\\hat{\\Delta}$ 及其标准差的标准化统计量，根据适用于跨独立运行的弱相关序列平均值的中心极限定理（CLT），近似服从正态分布。将标准差记为\n$$\ns_{\\Delta} \\;=\\; \\sqrt{\\operatorname{Var}(\\hat{\\Delta})},\n$$\n将非中心化参数记为\n$$\n\\lambda \\;=\\; \\frac{|\\delta|}{s_{\\Delta}}.\n$$\n使用显著性水平为 $\\alpha$ 的双边检验，标准正态检验的临界值为 $z_{1-\\alpha/2}$（标准正态分布的 $(1-\\alpha/2)$-分位数）。在备择假设下，标准化统计量 $Z$ 近似服从 $\\mathcal{N}(\\lambda,1)$，因此统计功效（在备择假设下拒绝原假设的概率）为\n$$\n\\text{Power} \\;=\\; \\mathbb{P}\\left(|Z| > z_{1-\\alpha/2}\\right)\n\\;=\\; \\Phi\\left(-z_{1-\\alpha/2} - \\lambda\\right) + \\left(1 - \\Phi\\left(z_{1-\\alpha/2} - \\lambda\\right)\\right),\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。此形式直接源于双边拒绝域的定义以及 $Z$ 在备择假设下的分布。\n\n为了从独立运行次数的角度论证样本量，注意到 $s_{\\Delta}$ 随 $R$ 单调递减（具体地，其变化趋势如同 $R^{-1/2}$），因此功效随 $R$ 单调递增。因此，对于固定的 $(\\delta,\\sigma,\\rho,T,\\alpha)$ 和目标功效 $p_{\\star}$，存在一个最小整数 $R_{\\min}$，使得在 $R_{\\min}$ 处计算出的功效至少为 $p_{\\star}$。我们通过以下方法高效地计算 $R_{\\min}$：\n- 从 $R=1$ 开始评估功效，并倍增 $R$ 直到功效超过 $p_{\\star}$ 或达到一个预设的较大上限（指数搜索以找到包含解的区间）。\n- 在找到的区间上执行二分搜索，以找到使得功效至少为 $p_{\\star}$ 的最小整数 $R$。\n\n程序中实现的算法步骤：\n1. 使用 AR(1) 协方差求和公式计算 $\\operatorname{Var}(\\bar{Y}_{r})$：\n   $$\n   \\operatorname{Var}(\\bar{Y}_{r}) \\;=\\; \\frac{\\sigma^{2}}{T}\\left( 1 + 2 \\sum_{k=1}^{T-1}\\left(1 - \\frac{k}{T}\\right)\\rho^{k} \\right).\n   $$\n2. 计算 $\\operatorname{Var}(\\hat{\\Delta}) = \\frac{2}{R}\\operatorname{Var}(\\bar{Y}_{r})$ 和 $s_{\\Delta} = \\sqrt{\\operatorname{Var}(\\hat{\\Delta})}$。\n3. 计算 $\\lambda = \\frac{|\\delta|}{s_{\\Delta}}$ 和 $z_{1-\\alpha/2}$，然后通过以下公式评估功效：\n   $$\n   \\text{Power} \\;=\\; \\Phi\\left(-z_{1-\\alpha/2} - \\lambda\\right) + \\left(1 - \\Phi\\left(z_{1-\\alpha/2} - \\lambda\\right)\\right).\n   $$\n4. 对于每个测试用例，计算给定 $R$ 下的功效，并按照所述方法通过指数搜索和二分搜索计算 $R_{\\min}$。功效随 $R$ 的单调性保证了算法的正确性。\n5. 在单行上输出所有测试用例的结果列表 $[\\text{power}, R_{\\min}]$，其中每个功效值四舍五入到六位小数。\n\n此过程基于平稳高斯 AR(1) 过程的标准属性、基于协方差的时间平均值方差公式以及中心极限定理（CLT），从而产生科学上可靠且数值稳定的计算结果，适用于复杂自适应系统中的模型验证与确认。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef var_mean_ar1(T: int, rho: float, sigma: float) -> float:\n    \"\"\"\n    Compute Var(bar{Y}_r) for an AR(1) process with marginal std sigma and autocorrelation rho.\n    Var(bar{Y}_r) = (sigma^2 / T) * [1 + 2 * sum_{k=1}^{T-1} (1 - k/T) * rho^k]\n    \"\"\"\n    if T == 0:\n        raise ValueError(\"T must be a positive integer\")\n    if abs(rho) >= 1.0:\n        raise ValueError(\"rho must be in (-1,1) for stationarity\")\n    # Sum the weighted autocorrelation terms\n    if T == 1:\n        # No autocovariance terms when only one observation\n        return (sigma ** 2) / T\n    k = np.arange(1, T, dtype=np.float64)\n    weights = 1.0 - k / T\n    # Use power with float for stability\n    rho_powers = rho ** k\n    s = np.sum(weights * rho_powers)\n    return (sigma ** 2 / T) * (1.0 + 2.0 * s)\n\ndef two_sided_power(delta: float, sigma: float, rho: float, T: int, R: int, alpha: float) -> float:\n    \"\"\"\n    Compute the two-sided normal-approx power at significance alpha for discrepancy delta,\n    given AR(1) parameters (sigma, rho), time length T, and number of runs R.\n    \"\"\"\n    vmean = var_mean_ar1(T, rho, sigma)\n    vdiff = 2.0 * vmean / float(R)\n    sd = np.sqrt(vdiff)\n    lam = abs(delta) / sd if sd > 0 else np.inf\n    z = norm.ppf(1.0 - alpha / 2.0)\n    # Power = P(|Z| > z) with Z ~ N(lam, 1)\n    power = norm.cdf(-z - lam) + (1.0 - norm.cdf(z - lam))\n    return float(power)\n\ndef minimal_R_for_power(delta: float, sigma: float, rho: float, T: int, alpha: float, target_power: float,\n                        Rmax: int = 1_000_000) -> int:\n    \"\"\"\n    Find the minimal integer R such that two_sided_power(...) >= target_power,\n    using exponential search to bracket and then binary search to refine.\n    \"\"\"\n    # Exponential search to find an upper bound where power >= target_power.\n    upper = 1\n    p_upper = two_sided_power(delta, sigma, rho, T, upper, alpha)\n    if p_upper >= target_power:\n        return upper\n    while p_upper  target_power and upper  Rmax:\n        upper *= 2\n        p_upper = two_sided_power(delta, sigma, rho, T, upper, alpha)\n    if p_upper  target_power and upper >= Rmax:\n        # Could not achieve target within Rmax; return Rmax as a conservative cap.\n        return Rmax\n    lower = upper // 2\n    if lower  1:\n        lower = 1\n    # Binary search for minimal R in [lower, upper]\n    rmin = upper\n    while lower = upper:\n        mid = (lower + upper) // 2\n        p_mid = two_sided_power(delta, sigma, rho, T, mid, alpha)\n        if p_mid >= target_power:\n            rmin = mid\n            upper = mid - 1\n        else:\n            lower = mid + 1\n    return int(rmin)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is (delta, sigma, rho, T, R, alpha, p_star)\n    test_cases = [\n        (0.5, 1.0, 0.3, 200, 10, 0.05, 0.8),\n        (0.5, 1.0, 0.8, 10, 10, 0.05, 0.8),\n        (0.1, 1.0, 0.95, 1000, 20, 0.05, 0.9),\n        (0.2, 1.0, 0.0, 100, 5, 0.05, 0.8),\n        (0.01, 1.0, 0.5, 10000, 50, 0.01, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta, sigma, rho, T, R, alpha, p_star = case\n        power = two_sided_power(delta, sigma, rho, T, R, alpha)\n        Rmin = minimal_R_for_power(delta, sigma, rho, T, alpha, p_star)\n        results.append((power, Rmin))\n\n    # Format the final result exactly as required: [[power,Rmin],...], with power rounded to 6 decimals.\n    formatted_results = \"[\" + \",\".join(\"[\" + f\"{p:.6f},\" + f\"{r}\" + \"]\" for p, r in results) + \"]\"\n    print(formatted_results)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个经过验证的优秀模型不仅应能拟合历史数据，还应对其基本假设和参数的合理变动保持稳健。对于用于预测或政策分析的复杂自适应系统模型而言，这一点尤为重要，因为未来未必是过去的简单重复。本练习介绍“对抗性验证”的概念，这是一种对模型进行“压力测试”的高级方法。我们将系统地在一定范围内扰动模型参数，以找出对关键输出指标的最坏影响，从而量化模型的稳健性。通过这项实践，您将学会评估模型在参数不确定性下的可靠性，并识别其潜在的脆弱点，这超越了基于单一参数估计的传统验证方法。",
            "id": "4127794",
            "problem": "您的任务是为一个简单但重要的基于主体的模型（Agent-Based Model, ABM）设计并实现一个严格的验证程序，该程序需在代理决策规则受到对抗性扰动的情况下进行，并计算关键可观测量对以适当范数量化的有界扰动的敏感度。该ABM包含 $N$ 个代理，其连续动作状态为 $a_i^{(t)} \\in [0,1]$，并在离散时间步 $t \\in \\{0,1,\\dots,T\\}$ 上演化。每个代理 $i$ 拥有一个固定的特征 $x_i \\in \\mathbb{R}$，该特征独立地从标准正态分布中抽取。决策规则是一个确定性的平均场更新：在每个时间步，所有代理根据以下公式同步更新\n$$\na_i^{(t+1)} \\;=\\; \\sigma\\!\\left(\\theta_0 + \\theta_1 \\cdot m^{(t)} + \\theta_2 \\cdot x_i\\right),\n$$\n其中 $\\sigma(z) = \\frac{1}{1+e^{-z}}$ 是逻辑斯谛函数，$\\theta = (\\theta_0,\\theta_1,\\theta_2) \\in \\mathbb{R}^3$ 是待验证的规则参数，而 $m^{(t)} = \\frac{1}{N}\\sum_{j=1}^N a_j^{(t)}$ 是在时间 $t$ 的群体均值。所有代理的初始动作设置为 $a_i^{(0)} = 0.5$，因此 $m^{(0)} = 0.5$。固定一个随机种子以确保特征抽取的复现性。\n\n定义两个待验证的可观测量：\n- 最终平均动作，\n$$\nO_1(\\theta) \\;=\\; m^{(T)}(\\theta).\n$$\n- 动作的时间平均横截面方差，\n$$\nO_2(\\theta) \\;=\\; \n\\begin{cases}\n\\frac{1}{T}\\sum_{t=1}^{T} \\mathrm{Var}\\!\\left(a^{(t)}(\\theta)\\right),  \\text{if } T  0,\\\\\n0.0,  \\text{if } T = 0,\n\\end{cases}\n$$\n其中 $\\mathrm{Var}(a^{(t)}(\\theta)) = \\frac{1}{N}\\sum_{i=1}^N \\left(a_i^{(t)}(\\theta) - m^{(t)}(\\theta)\\right)^2$。\n\n您必须实现一个在规则参数 $\\theta$ 受到对抗性扰动下的验证，扰动在 $L_\\infty$ 范数下有界。具体来说，设 $\\delta \\in \\mathbb{R}^3$ 表示一个扰动向量，并施加边界 $\\|\\delta\\|_\\infty \\le \\varepsilon$，其中 $\\varepsilon  0$ 是给定的。请遵循以下要求：\n\n1. 模型模拟：实现一个ABM的确定性模拟器，在给定 $(N,T,\\theta,\\text{seed})$ 的情况下，返回如上定义的 $O_1(\\theta)$ 和 $O_2(\\theta)$ 的值。特征 $x_i$ 必须使用指定的随机种子从标准正态分布中独立抽取，并且所有初始动作必须为 $0.5$。\n\n2. 敏感度计算：在给定的基准 $\\theta$ 下，对 $k \\in \\{1,2\\}$，使用中心有限差分格式，并为 $\\theta$ 的每个坐标设置一个小的对称步长 $h$，以数值方式估计梯度 $\\nabla O_k(\\theta)$。然后，使用适当的对偶范数推理，计算在所有满足 $\\|\\delta\\|_\\infty \\le \\varepsilon$ 的扰动下，$O_k$ 的最坏情况一阶变化的上界。报告这两个敏感度上界。\n\n3. 对抗性验证：在一组扰动上计算 $O_1$ 和 $O_2$ 的实际最坏情况变化，这组扰动是超立方体 $\\{-\\varepsilon,+\\varepsilon\\}^3$ 的角点，即所有分量等于 $-\\varepsilon$ 或 $+\\varepsilon$ 的 $\\delta$。对每个可观测量 $O_k$，报告最大绝对变化 $\\max_{\\delta \\in \\{-\\varepsilon,+\\varepsilon\\}^3} \\left|O_k(\\theta+\\delta) - O_k(\\theta)\\right|$。\n\n4. 验证决策：给定容差 $\\tau_1  0$ 和 $\\tau_2  0$，如果以下两个不等式都成立，则宣布模型通过验证：\n$$\n\\max_{\\delta \\in \\{-\\varepsilon,+\\varepsilon\\}^3} \\left|O_1(\\theta+\\delta) - O_1(\\theta)\\right| \\le \\tau_1,\n\\qquad\n\\max_{\\delta \\in \\{-\\varepsilon,+\\varepsilon\\}^3} \\left|O_2(\\theta+\\delta) - O_2(\\theta)\\right| \\le \\tau_2.\n$$\n返回一个布尔值，指示通过或失败。\n\n您的程序必须实现上述逻辑，并将其应用于以下测试套件。对于每个测试用例，参数以 $(N,T,\\theta_0,\\theta_1,\\theta_2,\\varepsilon,\\tau_1,\\tau_2,\\text{seed})$ 的形式给出：\n\n- 测试用例 1：$(N=\\;500,\\;T=\\;50,\\;\\theta_0=\\;0.2,\\;\\theta_1=\\;1.1,\\;\\theta_2=\\;0.7,\\;\\varepsilon=\\;0.05,\\;\\tau_1=\\;0.03,\\;\\tau_2=\\;0.02,\\;\\text{seed}=\\;42)$。\n- 测试用例 2：$(N=\\;600,\\;T=\\;20,\\;\\theta_0=\\;-0.1,\\;\\theta_1=\\;0.9,\\;\\theta_2=\\;0.3,\\;\\varepsilon=\\;0.0,\\;\\tau_1=\\;0.0,\\;\\tau_2=\\;0.0,\\;\\text{seed}=\\;123)$。\n- 测试用例 3：$(N=\\;1000,\\;T=\\;100,\\;\\theta_0=\\;0.0,\\;\\theta_1=\\;1.5,\\;\\theta_2=\\;0.5,\\;\\varepsilon=\\;0.5,\\;\\tau_1=\\;0.05,\\;\\tau_2=\\;0.05,\\;\\text{seed}=\\;7)$。\n- 测试用例 4：$(N=\\;300,\\;T=\\;0,\\;\\theta_0=\\;0.4,\\;\\theta_1=\\;1.2,\\;\\theta_2=\\;-0.6,\\;\\varepsilon=\\;0.2,\\;\\tau_1=\\;10^{-6},\\;\\tau_2=\\;10^{-6},\\;\\text{seed}=\\;2025)$。\n- 测试用例 5：$(N=\\;10,\\;T=\\;10,\\;\\theta_0=\\;-0.5,\\;\\theta_1=\\;0.8,\\;\\theta_2=\\;1.1,\\;\\varepsilon=\\;0.01,\\;\\tau_1=\\;0.005,\\;\\tau_2=\\;0.005,\\;\\text{seed}=\\;999)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个测试用例，并且其本身必须是一个包含五个条目的列表：\n$[S_1^{\\text{bound}}, S_1^{\\text{corner}}, S_2^{\\text{bound}}, S_2^{\\text{corner}}, \\text{pass}]$，\n其中 $S_k^{\\text{bound}}$ 是 $O_k$ 的敏感度上界，$S_k^{\\text{corner}}$ 是观测到的 $O_k$ 的最坏情况角点变化，而 $\\text{pass}$ 是一个布尔值。例如，最终输出行应类似于\n$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$\n其中恰好有五个内部列表，每个测试用例一个。不应打印任何其他文本。",
            "solution": "问题陈述已经过评估，并被确定为**有效**。它具有科学依据，定义明确，客观且内部一致。它在复杂自适应系统模型验证领域提出了一个清晰、可形式化的任务。唯一的小歧义是未指定用于有限差分计算的步长 $h$，这是一个标准的实现细节。为此，将使用一个合理的值 $h=10^{-6}$。\n\n解决方案通过实现问题陈述中指定的四个要求来推进。这包括创建一个基于主体的模型（ABM）的确定性模拟，使用此模拟来计算两个关键可观测量对参数扰动的敏感度，并根据观测到的变化与给定容差的对比做出验证决策。\n\n### 1. 模型模拟\n\n首先，设计一个函数来模拟ABM动态。该函数接受代理数量 $N$、时间步数 $T$、参数向量 $\\theta = (\\theta_0, \\theta_1, \\theta_2)$ 和一个随机种子。\n\n- **初始化**：使用提供的种子初始化伪随机数生成器，以确保可复现性。为 $N$ 个代理中的每一个独立地从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取固定特征 $x_i$。所有代理的初始动作状态设置为 $a_i^{(0)} = 0.5$。\n\n- **时间演化**：模拟从 $t=0$ 到 $T-1$ 进行迭代。在每一步中，它对所有代理执行同步更新。\n    1.  计算群体平均动作 $m^{(t)} = \\frac{1}{N}\\sum_{j=1}^N a_j^{(t)}$。\n    2.  根据确定性更新规则计算每个代理 $i$ 在下一个时间步的动作状态 $a_i^{(t+1)}$：\n        $$\n        a_i^{(t+1)} = \\sigma(\\theta_0 + \\theta_1 \\cdot m^{(t)} + \\theta_2 \\cdot x_i)\n        $$\n        其中 $\\sigma(z) = \\frac{1}{1+e^{-z}}$ 是逻辑斯谛sigmoid函数。\n    3.  计算并存储新计算出的动作的横截面方差 $\\mathrm{Var}(a^{(t+1)}(\\theta)) = \\frac{1}{N}\\sum_{i=1}^N (a_i^{(t+1)} - m^{(t+1)})^2$。请注意 $m^{(t+1)} = \\frac{1}{N}\\sum_{j=1}^N a_j^{(t+1)}$。\n\n- **可观测量计算**：在最后一个时间步 $T$ 之后，计算两个可观测量。\n    -   $O_1(\\theta) = m^{(T)}(\\theta)$，在最终时间步 $T$ 的代理动作均值。\n    -   $O_2(\\theta) = \\frac{1}{T}\\sum_{t=1}^{T} \\mathrm{Var}(a^{(t)}(\\theta))$，从时间步 $t=1$ 到 $t=T$ 计算的横截面方差的时间平均值。\n    \n- **边界情况**：需要对 $T=0$ 进行特殊处理。在这种情况下，模拟循环不运行。最终状态即为初始状态，因此 $O_1(\\theta) = 0.5$。根据定义，$O_2(\\theta) = 0.0$。当 $T=0$ 时，两个可观测量都是常数且与 $\\theta$ 无关。\n\n模拟逻辑被封装在一个函数 `run_simulation(N, T, theta, seed)` 中，该函数返回元组 $(O_1(\\theta), O_2(\\theta))$。\n\n### 2. 敏感度上界 ($S_k^{\\text{bound}}$)\n\n可观测量 $O_k$ 对 $\\theta$ 中小扰动的敏感度使用一阶泰勒展开进行分析：$\\Delta O_k \\approx \\nabla O_k(\\theta) \\cdot \\delta$，其中 $\\delta$ 是扰动向量。\n\n- **梯度估计**：对于每个可观测量 $k \\in \\{1, 2\\}$，使用中心有限差分法数值估计梯度 $\\nabla O_k(\\theta) \\in \\mathbb{R}^3$。关于每个参数分量 $\\theta_j$（对于 $j \\in \\{0, 1, 2\\}$）的偏导数近似为：\n    $$\n    \\frac{\\partial O_k}{\\partial \\theta_j} \\approx \\frac{O_k(\\theta + h \\cdot e_j) - O_k(\\theta - h \\cdot e_j)}{2h}\n    $$\n    其中 $e_j$ 是 $\\mathbb{R}^3$ 中的第 $j$ 个标准基向量，$h$ 是一个小的步长，选择为 $h=10^{-6}$。对于每对可观测量，这需要 $2 \\times 3 = 6$ 次调用模拟函数。\n\n- **边界计算**：我们需要找到在所有满足约束 $\\|\\delta\\|_\\infty \\le \\varepsilon$ 的扰动 $\\delta$ 下，变化量 $|\\Delta O_k|$ 的上界。在此约束下，$|\\nabla O_k(\\theta) \\cdot \\delta|$ 的最大值由 $\\varepsilon$ 与梯度的对偶范数的乘积给出。$L_\\infty$ 范数的对偶范数是 $L_1$ 范数。因此，敏感度上界为：\n    $$\n    S_k^{\\text{bound}} = \\max_{\\|\\delta\\|_\\infty \\le \\varepsilon} |\\nabla O_k(\\theta) \\cdot \\delta| = \\varepsilon \\cdot \\|\\nabla O_k(\\theta)\\|_1\n    $$\n    其中 $\\|\\vec{v}\\|_1 = \\sum_j |v_j|$。\n\n### 3. 对抗性角点验证 ($S_k^{\\text{corner}}$)\n\n此步骤通过测试一个特定的、有限的对抗性扰动集合来计算可观测量中的真实最大变化。该扰动集合由 $L_\\infty$ 边界定义的超立方体的角点组成，即 $\\delta \\in \\{-\\varepsilon, +\\varepsilon\\}^3$。这对应于 $2^3=8$ 个扰动，其中每个分量 $\\delta_j$ 要么是 $-\\varepsilon$，要么是 $+\\varepsilon$。\n\n其过程如下：\n1.  计算基准可观测量 $O_k(\\theta)$。\n2.  对于 8 个角点扰动向量 $\\delta$ 中的每一个，计算受扰动的可观测量 $O_k(\\theta + \\delta)$。\n3.  每个可观测量 $O_k$ 的最坏情况角点变化是找到的最大绝对差：\n    $$\n    S_k^{\\text{corner}} = \\max_{\\delta \\in \\{-\\varepsilon, +\\varepsilon\\}^3} \\left|O_k(\\theta+\\delta) - O_k(\\theta)\\right|\n    $$\n\n这需要额外调用 8 次模拟函数。如果 $\\varepsilon=0$，则存在一个特殊情况，此时唯一的扰动是 $\\delta = (0, 0, 0)$，导致 $S_k^{\\text{corner}}=0$。\n\n### 4. 验证决策\n\n最后一步是做出二元验证决策。当且仅当两个可观测量的经验观测最坏情况变化都在其各自指定的容差 $\\tau_1$ 和 $\\tau_2$ 之内时，模型被宣布通过验证。\n$$\n\\text{pass} = \\begin{cases} \\text{True},  \\text{if } S_1^{\\text{corner}} \\le \\tau_1 \\text{ and } S_2^{\\text{corner}} \\le \\tau_2 \\\\ \\text{False},  \\text{otherwise} \\end{cases}\n$$\n最终算法遍历每个测试用例，执行这四个步骤，并将五个结果值——$S_1^{\\text{bound}}$、$S_1^{\\text{corner}}$、$S_2^{\\text{bound}}$、$S_2^{\\text{corner}}$ 和布尔值 'pass'——编译到每个用例的列表中。这些列表的集合构成了最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import expit  # Numerically stable logistic function\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Solves the ABM validation problem for all test cases.\n    \"\"\"\n    \n    # Test cases parameters:\n    # (N, T, theta_0, theta_1, theta_2, epsilon, tau_1, tau_2, seed)\n    test_cases = [\n        (500, 50, 0.2, 1.1, 0.7, 0.05, 0.03, 0.02, 42),\n        (600, 20, -0.1, 0.9, 0.3, 0.0, 0.0, 0.0, 123),\n        (1000, 100, 0.0, 1.5, 0.5, 0.5, 0.05, 0.05, 7),\n        (300, 0, 0.4, 1.2, -0.6, 0.2, 1e-6, 1e-6, 2025),\n        (10, 10, -0.5, 0.8, 1.1, 0.01, 0.005, 0.005, 999),\n    ]\n\n    h = 1e-6 # Step size for central finite difference\n\n    # Cache to avoid re-running simulations with identical parameters\n    simulation_cache = {}\n\n    def run_simulation(N, T, theta_tuple, seed):\n        \"\"\"\n        Runs the ABM simulation for a given set of parameters.\n        \"\"\"\n        # Create a tuple key for caching\n        cache_key = (N, T, theta_tuple, seed)\n        if cache_key in simulation_cache:\n            return simulation_cache[cache_key]\n\n        theta = np.array(theta_tuple)\n        \n        # Handle T=0 edge case\n        if T == 0:\n            o1_final_mean = 0.5\n            o2_avg_var = 0.0\n            simulation_cache[cache_key] = (o1_final_mean, o2_avg_var)\n            return o1_final_mean, o2_avg_var\n\n        # Initialization\n        rng = np.random.default_rng(seed)\n        traits_x = rng.standard_normal(N)\n        actions = np.full(N, 0.5)\n        \n        # Time evolution\n        variances = []\n        for _ in range(T):\n            mean_action = np.mean(actions)\n            z = theta[0] + theta[1] * mean_action + theta[2] * traits_x\n            actions = expit(z)\n            variances.append(np.var(actions))\n\n        # Calculate final observables\n        o1_final_mean = np.mean(actions)\n        o2_avg_var = np.mean(variances)\n        \n        simulation_cache[cache_key] = (o1_final_mean, o2_avg_var)\n        return o1_final_mean, o2_avg_var\n\n    results = []\n    for case in test_cases:\n        N, T, theta0, theta1, theta2, epsilon, tau1, tau2, seed = case\n        theta_base = np.array([theta0, theta1, theta2])\n\n        # Shortcut for T=0: observables are constant, so all changes are 0.\n        if T == 0:\n            s1_bound, s1_corner = 0.0, 0.0\n            s2_bound, s2_corner = 0.0, 0.0\n            passed = (s1_corner = tau1) and (s2_corner = tau2)\n            results.append([s1_bound, s1_corner, s2_bound, s2_corner, passed])\n            continue\n\n        # Shortcut for epsilon=0: no perturbation, so all changes are 0.\n        if epsilon == 0.0:\n            s1_bound, s1_corner = 0.0, 0.0\n            s2_bound, s2_corner = 0.0, 0.0\n            passed = (s1_corner = tau1) and (s2_corner = tau2)\n            results.append([s1_bound, s1_corner, s2_bound, s2_corner, passed])\n            continue\n            \n        # 1. Baseline calculation\n        o1_base, o2_base = run_simulation(N, T, tuple(theta_base), seed)\n\n        # 2. Sensitivity computation (gradient and bounds)\n        grad_o1 = np.zeros(3)\n        grad_o2 = np.zeros(3)\n        for i in range(3):\n            theta_plus = theta_base.copy()\n            theta_plus[i] += h\n            theta_minus = theta_base.copy()\n            theta_minus[i] -= h\n            \n            o1_plus, o2_plus = run_simulation(N, T, tuple(theta_plus), seed)\n            o1_minus, o2_minus = run_simulation(N, T, tuple(theta_minus), seed)\n            \n            grad_o1[i] = (o1_plus - o1_minus) / (2 * h)\n            grad_o2[i] = (o2_plus - o2_minus) / (2 * h)\n        \n        s1_bound = epsilon * np.linalg.norm(grad_o1, ord=1)\n        s2_bound = epsilon * np.linalg.norm(grad_o2, ord=1)\n\n        # 3. Adversarial validation (corner check)\n        max_abs_delta_o1 = 0.0\n        max_abs_delta_o2 = 0.0\n        \n        # Generate 2^3=8 corners of the perturbation hypercube\n        for signs in product([-1, 1], repeat=3):\n            delta = epsilon * np.array(signs)\n            theta_perturbed = theta_base + delta\n            \n            o1_pert, o2_pert = run_simulation(N, T, tuple(theta_perturbed), seed)\n            \n            max_abs_delta_o1 = max(max_abs_delta_o1, abs(o1_pert - o1_base))\n            max_abs_delta_o2 = max(max_abs_delta_o2, abs(o2_pert - o2_base))\n            \n        s1_corner = max_abs_delta_o1\n        s2_corner = max_abs_delta_o2\n        \n        # 4. Validation decision\n        passed = (s1_corner = tau1) and (s2_corner = tau2)\n        \n        results.append([s1_bound, s1_corner, s2_bound, s2_corner, passed])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}