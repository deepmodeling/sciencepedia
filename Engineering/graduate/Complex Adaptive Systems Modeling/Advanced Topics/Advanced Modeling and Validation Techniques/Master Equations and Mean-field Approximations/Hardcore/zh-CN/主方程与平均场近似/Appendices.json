{
    "hands_on_practices": [
        {
            "introduction": "主方程的核心在于其定义了系统在不同状态之间跳转的转移速率。本练习将指导你为一个基本的随机过程——双分子化学反应——推导这些速率，即生成元矩阵的元素或倾向函数。通过这个实践，你将学习如何从第一性原理出发，将微观的随机事件与宏观的反应速率定律联系起来，这是构建任何主方程模型的关键第一步 。",
            "id": "4127088",
            "problem": "考虑一个充分混合、等温、恒容的系统，其中发生单一的不可逆双分子反应 $A+B\\to C$。设系统体积为 $V0$，宏观质量作用速率常数为 $k0$。该系统被建模为一个连续时间马尔可夫链 (CTMC)，其状态为分子数向量 $\\boldsymbol{n}=(n_A,n_B,n_C)\\in\\mathbb{N}_0^3$。状态概率分布的演化由化学主方程 (CME) 描述。该反应的化学计量变化向量为 $\\boldsymbol{\\nu}_r=(-1,-1,+1)$。\n\n从随机质量作用动力学的第一性原理以及 CTMC 生成元作为离散状态间转移速率矩阵的定义出发，推导与此反应相对应的非对角生成元项，并将其表示为关于 $\\boldsymbol{n}$ 和 $\\boldsymbol{n}'$ 的单一闭式解析表达式。你的推导应从基本定义开始：基于计数的质量作用倾向性，其定义为可用反应物组合数量与一个“每组合风险率”的乘积，该风险率与 $k$ 成正比，与 $V$ 成反比；以及由化学计量学引起的状态到状态转移速率的生成元映射。\n\n提供生成元项 $Q_{\\boldsymbol{n},\\boldsymbol{n}'}$ 的最终表达式，该表达式用 $k$、$V$ 以及 $\\boldsymbol{n}$ 和 $\\boldsymbol{n}'$ 的分量来编码此反应的非对角速率。你可以使用克罗内克δ函数来表示整数分量的相等关系。将最终答案表示为单一的闭式解析表达式，且最终表达式中不包含任何单位。无需进行数值近似或舍入。",
            "solution": "设系统的状态由分子数向量 $\\boldsymbol{n} = (n_A, n_B, n_C)$ 描述，其中 $n_A, n_B, n_C \\in \\mathbb{N}_0$ 分别是物种 A、B 和 C 的分子数。该系统在状态空间 $\\mathbb{N}_0^3$ 上作为 CTMC 演化。动力学由生成矩阵 $Q$ 控制，其中当 $\\boldsymbol{n} \\neq \\boldsymbol{n}'$ 时，项 $Q_{\\boldsymbol{n},\\boldsymbol{n}'}$ 表示从状态 $\\boldsymbol{n}$ 到状态 $\\boldsymbol{n}'$ 的转移速率。\n\n系统中发生的单一反应是不可逆双分子反应：\n$$\nA+B \\xrightarrow{k} C\n$$\n问题指出，该反应的化学计量变化向量为 $\\boldsymbol{\\nu}_r = (-1, -1, +1)$。这意味着每次反应发生都会使系统状态从 $\\boldsymbol{n} = (n_A, n_B, n_C)$ 变为新状态 $\\boldsymbol{n}' = (n_A - 1, n_B - 1, n_C + 1)$。这可以简明地写为 $\\boldsymbol{n}' = \\boldsymbol{n} + \\boldsymbol{\\nu}_r$。\n\n此转移的速率由随机倾向性函数给出，记为 $a(\\boldsymbol{n})$。问题要求从第一性原理推导该倾向性，其定义为“可用反应物组合的数量与一个‘每组合风险率’的乘积，该风险率与 $k$ 成正比，与 $V$ 成反比”。\n\n对于反应 $A+B \\to C$，反应物是不同的物种。在状态 $\\boldsymbol{n}$ 下，有 $n_A$ 个物种 A 的分子和 $n_B$ 个物种 B 的分子。一个 A 分子和一个 B 分子的不同配对数量是其分子数的乘积。\n$$\n\\text{反应物组合数} = n_A n_B\n$$\n这里假设为了计算反应对，分子是可区分的。\n\n“每组合风险率”是任意一个特定的 $(A, B)$ 分子对在单位时间内发生反应的概率。这个微观速率被给出为与宏观速率常数 $k$ 成正比，与系统体积 $V$ 成反比。让我们将这个单对反应速率常数记为 $c$。\n$$\nc = \\frac{k}{V}\n$$\n总反应速率，或称倾向性 $a(\\boldsymbol{n})$，是组合数量与每组合风险率的乘积：\n$$\na(\\boldsymbol{n}) = (\\text{反应物组合数}) \\times (\\text{每组合风险率}) = (n_A n_B) \\times \\left(\\frac{k}{V}\\right)\n$$\n因此，该反应的倾向性函数为：\n$$\na(\\boldsymbol{n}) = \\frac{k}{V} n_A n_B\n$$\n这个倾向性 $a(\\boldsymbol{n})$ 是系统从状态 $\\boldsymbol{n}$ 转移到状态 $\\boldsymbol{n} + \\boldsymbol{\\nu}_r$ 的速率。\n\n生成矩阵的非对角元 $Q_{\\boldsymbol{n},\\boldsymbol{n}'}$（对于 $\\boldsymbol{n} \\neq \\boldsymbol{n}'$）被定义为从状态 $\\boldsymbol{n}$ 到状态 $\\boldsymbol{n}'$ 的转移速率。对于这个只有单一反应通道的系统，只有从 $\\boldsymbol{n}$ 到特定状态 $\\boldsymbol{n}' = \\boldsymbol{n} + \\boldsymbol{\\nu}_r$ 的转移是可能的。这个特定转移的速率是 $a(\\boldsymbol{n})$。对于任何其他状态 $\\boldsymbol{n}'' \\neq \\boldsymbol{n} + \\boldsymbol{\\nu}_r$（且 $\\boldsymbol{n}'' \\neq \\boldsymbol{n}$），从 $\\boldsymbol{n}$ 出发的转移速率为零，即 $Q_{\\boldsymbol{n},\\boldsymbol{n}''} = 0$。\n\n我们可以使用克罗内克δ函数将这种条件关系表示为单一的闭式表达式。条件 $\\boldsymbol{n}' = \\boldsymbol{n} + \\boldsymbol{\\nu}_r$ 是一个向量等式，它等价于以下三个标量等式：\n\\begin{enumerate}\n    \\item $n_A' = n_A - 1$\n    \\item $n_B' = n_B - 1$\n    \\item $n_C' = n_C + 1$\n\\end{enumerate}\n克罗内克δ函数的乘积可以同时强制满足这些条件。项 $\\delta_{i,j}$ 在 $i=j$ 时等于 $1$，否则等于 $0$。乘积\n$$\n\\delta_{n_A', n_A-1} \\delta_{n_B', n_B-1} \\delta_{n_C', n_C+1}\n$$\n当且仅当关于 $\\boldsymbol{n}'$ 和 $\\boldsymbol{n}$ 分量的所有三个条件都满足时等于 $1$，否则等于 $0$。\n\n通过将倾向性函数 $a(\\boldsymbol{n})$ 与这个δ函数乘积相乘，我们构建了 $Q_{\\boldsymbol{n},\\boldsymbol{n}'}$ 的一个单一表达式，该表达式仅在目标状态为正确的 $\\boldsymbol{n}'$ 时非零。\n$$\nQ_{\\boldsymbol{n},\\boldsymbol{n}'} = a(\\boldsymbol{n}) \\cdot \\left( \\delta_{n_A', n_A-1} \\delta_{n_B', n_B-1} \\delta_{n_C', n_C+1} \\right)\n$$\n将推导出的 $a(\\boldsymbol{n})$ 表达式代入，得到对应于反应 $A+B\\to C$ 的非对角生成元项的最终表达式：\n$$\nQ_{\\boldsymbol{n},\\boldsymbol{n}'} = \\frac{k}{V} n_A n_B \\delta_{n_A', n_A-1} \\delta_{n_B', n_B-1} \\delta_{n_C', n_C+1}\n$$\n该表达式是源状态 $\\boldsymbol{n}=(n_A, n_B, n_C)$ 和目标状态 $\\boldsymbol{n}'=(n_A', n_B', n_C')$ 的分量以及系统参数 $k$ 和 $V$ 的函数。注意，如果 $n_A=0$ 或 $n_B=0$，该表达式正确地计算为 $0$，因为没有反应可以发生。对于任何无法通过单次反应事件从 $\\boldsymbol{n}$ 到达的状态 $\\boldsymbol{n}'$（包括 $\\boldsymbol{n}'=\\boldsymbol{n}$ 的情况），它也正确地计算为 $0$。",
            "answer": "$$\\boxed{\\frac{k}{V} n_A n_B \\delta_{n_A', n_A-1} \\delta_{n_B', n_B-1} \\delta_{n_C', n_C+1}}$$"
        },
        {
            "introduction": "直接求解主方程通常是不可行的，尤其是在状态空间巨大时，这促使我们寻求近似方法。本练习介绍了一种强大的技术：矩封闭。你将首先推导一个非线性生灭过程中低阶矩（如均值 $m$ 和方差 $V$）的动力学方程，并观察到它们如何依赖于更高阶的矩，从而形成一个无限的层次结构。接着，你将应用高斯封闭假设来截断这个层次，创建一个封闭且可解的方程组，这是均场近似思想的核心体现 。",
            "id": "4127059",
            "problem": "考虑一个在非负整数上的连续时间马尔可夫生灭过程，其状态变量为 $n \\in \\{0,1,2,\\dots\\}$，概率质量函数为 $P_{n}(t)$。该过程具有密度依赖率，由出生率 $b(n) = \\lambda n$ 和死亡率 $d(n) = \\mu n + \\gamma n(n-1)$ 给出，其中 $\\lambda$、$\\mu$ 和 $\\gamma$ 是非负常数。主方程是用于单步过程的标准前向柯尔莫哥洛夫方程。\n\n令 $m(t) \\equiv \\langle n \\rangle$ 表示均值，令 $V(t) \\equiv \\langle (n - m)^{2} \\rangle$ 表示方差。分别定义三阶和四阶中心矩为 $C_{3}(t) \\equiv \\langle (n - m)^{3} \\rangle$ 和 $C_{4}(t) \\equiv \\langle (n - m)^{4} \\rangle$。\n\n从主方程和矩的定义出发，推导出 $m(t)$ 和 $V(t)$ 的精确时间演化方程，并证明这些方程依赖于 $C_{3}(t)$，以及在下一阶上依赖于 $C_{4}(t)$。然后，施加高斯矩封闭假设：假设对于每个 $t$，$n$ 的分布都可以用一个均值为 $m(t)$、方差为 $V(t)$ 的正态分布来很好地近似。\n\n在此高斯封闭下，将 $C_{3}(t)$ 和 $C_{4}(t)$ 仅用 $m(t)$ 和 $V(t)$ 表示。将你的最终答案以单个行向量的形式给出，其中包含用 $m$ 和 $V$ 表示的两个表达式。无需四舍五入，也无需单位。",
            "solution": "一般生灭过程的主方程为：\n$$ \\frac{dP_n(t)}{dt} = b(n-1)P_{n-1}(t) + d(n+1)P_{n+1}(t) - [b(n) + d(n)]P_n(t) $$\n$n$ 的任意函数 $\\langle f(n) \\rangle$ 的期望值的时间演化可以从主方程推导出来。一种方便的方法是使用过程生成元的伴随算子，这会得到以下关于 $\\langle f(n) \\rangle$ 变化率的通用公式：\n$$ \\frac{d\\langle f(n) \\rangle}{dt} = \\langle b(n)(f(n+1) - f(n)) + d(n)(f(n-1) - f(n)) \\rangle $$\n\n我们首先推导均值 $m(t)$ 和方差 $V(t)$ 的方程，以说明矩层次结构。\n\n**均值 $m(t)$ 的时间演化**\n令 $f(n)=n$。那么 $f(n+1)-f(n) = 1$ 且 $f(n-1)-f(n) = -1$。\n$$ \\frac{dm}{dt} = \\frac{d\\langle n \\rangle}{dt} = \\langle b(n)(1) + d(n)(-1) \\rangle = \\langle b(n) - d(n) \\rangle $$\n代入给定的出生率 $b(n) = \\lambda n$ 和死亡率 $d(n) = \\mu n + \\gamma n(n-1)$：\n$$ \\frac{dm}{dt} = \\langle \\lambda n - (\\mu n + \\gamma n(n-1)) \\rangle = \\langle (\\lambda - \\mu)n - \\gamma(n^2 - n) \\rangle = \\langle (\\lambda - \\mu + \\gamma)n - \\gamma n^2 \\rangle $$\n用均值 $m = \\langle n \\rangle$ 和方差 $V = \\langle n^2 \\rangle - m^2$（因此 $\\langle n^2 \\rangle = V + m^2$）来表示：\n$$ \\frac{dm}{dt} = (\\lambda - \\mu + \\gamma)\\langle n \\rangle - \\gamma \\langle n^2 \\rangle = (\\lambda - \\mu + \\gamma)m - \\gamma(V + m^2) $$\n这个方程表明均值 $m$ 的变化率依赖于方差 $V$，即二阶中心矩。\n\n**方差 $V(t)$ 的时间演化**\n方差的时间演化由 $\\frac{dV}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - 2m \\frac{dm}{dt}$ 给出。首先，我们通过设置 $f(n)=n^2$ 来找到 $\\langle n^2 \\rangle$ 的方程。\n$f(n+1)-f(n) = (n+1)^2-n^2 = 2n+1$.\n$f(n-1)-f(n) = (n-1)^2-n^2 = -2n+1$.\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = \\langle b(n)(2n+1) + d(n)(-2n+1) \\rangle = \\langle (b(n)-d(n))(2n) + b(n)+d(n) \\rangle $$\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = 2\\langle n(b(n)-d(n)) \\rangle + \\langle b(n)+d(n) \\rangle $$\n使用 $b(n)$ 和 $d(n)$ 的表达式：\n$b(n)-d(n) = (\\lambda - \\mu + \\gamma)n - \\gamma n^2$.\n$b(n)+d(n) = \\lambda n + \\mu n + \\gamma n(n-1) = (\\lambda + \\mu - \\gamma)n + \\gamma n^2$.\n因此，\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = 2\\langle n((\\lambda - \\mu + \\gamma)n - \\gamma n^2) \\rangle + \\langle (\\lambda + \\mu - \\gamma)n + \\gamma n^2 \\rangle $$\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = 2(\\lambda - \\mu + \\gamma)\\langle n^2 \\rangle - 2\\gamma \\langle n^3 \\rangle + (\\lambda + \\mu - \\gamma)\\langle n \\rangle + \\gamma \\langle n^2 \\rangle $$\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = (\\lambda + \\mu - \\gamma)m + (2\\lambda - 2\\mu + 3\\gamma)(V+m^2) - 2\\gamma\\langle n^3 \\rangle $$\n这个关于 $\\langle n^2 \\rangle$ 的方程依赖于三阶原点矩 $\\langle n^3 \\rangle$。现在我们求解 $\\frac{dV}{dt}$：\n$$ \\frac{dV}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - 2m \\frac{dm}{dt} $$\n$$ \\frac{dV}{dt} = \\left[ (\\lambda + \\mu - \\gamma)m + (2\\lambda - 2\\mu + 3\\gamma)(V+m^2) - 2\\gamma\\langle n^3 \\rangle \\right] - 2m \\left[ (\\lambda - \\mu + \\gamma)m - \\gamma(V+m^2) \\right] $$\n为了显示对中心矩的依赖性，我们将 $\\langle n^3 \\rangle$ 用 $C_3$ 表示：\n$C_3 = \\langle (n-m)^3 \\rangle = \\langle n^3 - 3m n^2 + 3m^2 n - m^3 \\rangle = \\langle n^3 \\rangle - 3m\\langle n^2 \\rangle + 3m^2\\langle n \\rangle - m^3$.\n$\\langle n^3 \\rangle = C_3 + 3m(V+m^2) - 3m^3 + m^3 = C_3 + 3mV + m^3$.\n将此代入 $\\frac{d\\langle n^2 \\rangle}{dt}$ 的方程中，揭示了其对 $C_3$ 的依赖性。因此，$\\frac{dV}{dt}$ 的方程也依赖于 $C_3$。这就产生了一个开放的矩方程层次结构：$k$ 阶矩的方程依赖于 $(k+1)$ 阶矩。类似地，$C_3$ 的方程将依赖于 $C_4$。为了得到关于 $m$ 和 $V$ 的封闭方程组，需要一个矩封闭近似。\n\n**高斯矩封闭**\n问题要求施加高斯矩封闭假设。这意味着我们在任何时刻 $t$ 都用一个具有相同均值 $m(t)$ 和方差 $V(t)$ 的连续正态（高斯）分布来近似离散概率分布 $P_n(t)$。正态分布的中心矩具有众所周知的高斯性质。\n$k$ 阶中心矩定义为 $C_k = \\langle (n-m)^k \\rangle$。\n\n对于正态分布：\n1.  所有奇数阶中心矩均为零。这是由于高斯概率密度函数围绕其均值的对称性。奇数阶中心矩的被积函数是一个（关于 $n-m$ 的）奇函数乘以一个对称函数，其积分为零。因此，三阶中心矩为：\n    $$ C_3(t) = 0 $$\n2.  偶数阶中心矩由公式 $C_{2k} = (2k-1)!! V^k$ 给出，其中 $(2k-1)!! = (2k-1)(2k-3)\\dots1$。对于四阶中心矩（$k=2$）：\n    $$ C_4(t) = (2(2)-1)!! V(t)^2 = 3!! V(t)^2 = (3 \\cdot 1)V(t)^2 $$\n    $$ C_4(t) = 3V(t)^2 $$\n这个结果也可以通过峰度 $\\kappa = \\frac{C_4}{V^2} - 3$ 来表述。根据定义，正态分布的峰度为零，从而得出 $C_4 = 3V^2$。\n\n在高斯封闭近似下，三阶和四阶中心矩仅用方差 $V(t)$（以及不言而喻地，用均值 $m(t)$）表示。为了符号清晰起见，通常省略对时间的依赖性。\n\n所要求的表达式是：\n-   $C_3 = 0$\n-   $C_4 = 3V^2$\n\n这些以单个行向量的形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  3V^2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "任何近似方法都面临一个关键问题：它在何种条件下有效？这个高级练习通过检验“混沌传播”假说来解决这一问题，该假说是均场理论的理论基石。你将设计并实现一个算法，来精确计算一个有限 $N$ 智能体系统中的相关函数，并数值验证随着系统规模的增大，智能体之间的相关性趋于零。这个练习不仅能加深你对均场理论有效性的理解，也为评估模型近似的准确性提供了定量工具 。",
            "id": "4127125",
            "problem": "考虑一个由 $N$ 个二元智能体组成的全连接、可交换的连续时间马尔可夫跳跃系统，其中智能体 $i$ 的状态为 $x_i(t) \\in \\{0,1\\}$，$i \\in \\{1,\\dots,N\\}$。定义经验均值为 $m_N(t) = \\frac{1}{N}\\sum_{i=1}^{N} x_i(t)$。每个智能体根据平均场速率进行翻转：智能体 $i$ 发生 $0 \\to 1$ 转移的瞬时速率为 $a + b \\, m_N(t)$，发生 $1 \\to 0$ 转移的瞬时速率为 $c$，其中 $a0$, $b \\ge 0$, and $c0$ 是与 $N$ 无关的常数。令 $K(t) = \\sum_{i=1}^{N} x_i(t)$ 表示状态为1的智能体总数。由于系统是可交换且全连接的，$K(t)$ 在 $\\{0,1,\\dots,N\\}$ 上作为生灭过程演化，其从 $k$ 到 $k+1$ 的出生率为 $B_k$，从 $k$ 到 $k-1$ 的死亡率为 $D_k$。\n\n任务A（基于第一性原理建模）：从连续时间马尔可夫跳跃过程的 Kolmogorov 前向主方程和上述定义出发，推导过程 $K(t)$ 的出生率 $B_k$ 和死亡率 $D_k$。用 $N$、$k$、$a$、$b$ 和 $c$ 表示 $B_k$ 和 $D_k$，且不援引任何平均场闭合假设。明确指出你所使用的任何可交换性性质。\n\n任务B（稳态测度与相关性）：对于固定的 $N$，假设链是遍历的。利用生灭结构和一维生灭链的细致平衡，以比率 $\\frac{B_r}{D_{r+1}}$（其中 $r \\in \\{0,\\dots,k-1\\}$）的乘积形式构建稳态分布 $\\pi_N(k)$（至归一化常数）。然后将 $\\pi_N$ 归一化为概率分布。利用可交换性和组合恒等式，表示出：\n- 稳态均值 $m_N^\\star = \\mathbb{E}_{\\pi_N}[K]/N$，\n- 稳态对矩 $\\mathbb{E}_{\\pi_N}[x_i x_j]$（对于 $i\\neq j$），\n- 稳态连通两点相关性 $C_2^{(N)} = \\mathbb{E}_{\\pi_N}[x_i x_j] - \\left(\\mathbb{E}_{\\pi_N}[x_i]\\right)^2$，\n用 $\\pi_N$ 和 $N$ 表示。不要先验地假设因子分解成立。\n\n任务C（通过标度评估混沌传播）：在平均场设定中，混沌传播假说预测，在稳态时，对于大的 $N$，连通两点相关性的标度关系为 $C_2^{(N)} = \\mathcal{O}(1/N)$。设计一个算法，对于给定的 $(N,a,b,c)$，使用生灭稳態测度构造法精确计算（在浮点精度内）$\\pi_N(k)$，求出 $C_2^{(N)}$，并返回标度化量 $N \\, C_2^{(N)}$。你的算法对于中等大小的 $N$ 应该是数值稳定的，并能避免上溢或下溢。你必须对有限系统精确计算稳态分布和相关性；不要模拟轨迹。\n\n测试套件和输出规范：\n- 使用下面的参数集。对于每种情况，计算稳态标度相关性 $N \\, C_2^{(N)}$，结果为浮点数。不涉及物理单位。\n- 测试用例（每个用例为 $(N,a,b,c)$）：\n  1. $(20, 0.05, 2.0, 1.0)$,\n  2. $(50, 0.05, 2.0, 1.0)$,\n  3. $(200, 0.05, 2.0, 1.0)$,\n  4. $(20, 0.05, 1.2, 1.0)$,\n  5. $(50, 0.05, 1.2, 1.0)$,\n  6. $(200, 0.05, 1.2, 1.0)$,\n  7. $(2, 0.05, 2.0, 1.0)$.\n- 你的程序应产生单行输出，其中包含一个逗号分隔的列表，用方括号括起来。列表中的每个浮点数都应四舍五入到六位小数，并与测试用例的顺序相同。例如，输出格式必须严格符合 $[r_1,r_2,\\dots,r_7]$ 的形式，其中每个 $r_i$ 是对应测试用例的计算值，并四舍五入到六位小数。\n\n你的实现必须是一个完整、可运行的程序。它不能读取任何输入，也不能访问任何文件或网络。它必须包含上面指定的测试套件，并打印所要求的单行输出。",
            "solution": "### 任务A：出生率和死亡率的推导\n\n给定一个由 $N$ 个智能体组成的系统，其中智能体 $i$ 的状态为 $x_i(t) \\in \\{0, 1\\}$。状态为1的智能体总数为 $K(t) = \\sum_{i=1}^{N} x_i(t)$。$K(t)$ 的演化是状态空间 $\\{0, 1, \\dots, N\\}$ 上的一个生灭过程。我们要求解出生率 $B_k$（从 $k \\to k+1$ 的转移）和死亡率 $D_k$（从 $k \\to k-1$ 的转移）。\n\n让我们考虑系统处于宏观状态 $K(t) = k$ 的情况。这意味着有 $k$ 个智能体处于状态1，有 $N-k$ 个智能体处于状态0。经验均值为 $m_N(t) = K(t)/N = k/N$。\n\n一个出生事件对应于单个智能体从状态0转移到状态1。\n对于任何 $x_i=0$ 的特定智能体 $i$，其转移到 $x_i=1$ 的瞬时速率为 $a + b \\, m_N(t) = a + b(k/N)$。\n由于系统是全连接且可交换的，所有处于状态0的智能体在它们的转移倾向上是相同且独立的。这样的智能体有 $N-k$ 个。\n系统中发生任何 $0 \\to 1$ 转移的总速率是所有处于状态0的智能体各自转移速率的总和。由于可交换性，这简单地等于处于状态0的智能体数量乘以它们共同的转移速率。\n因此，出生率 $B_k$（即从状态 $k$到 $k+1$ 的总转移速率）是：\n$$B_k = (N-k) \\left( a + \\frac{b k}{N} \\right)$$\n此速率对于 $k \\in \\{0, 1, \\dots, N-1\\}$ 有效。当 $k=N$ 时，所有智能体都处于状态1，所以 $B_N = 0$。\n\n一个死亡事件对应于单个智能体从状态1转移到状态0。\n对于任何 $x_i=1$ 的特定智能体 $i$，其转移到 $x_i=0$ 的瞬时速率为常数 $c$。\n在状态 $k$，有 $k$ 个智能体处于状态1。与出生过程类似，可交换性性质意味着所有处于状态1的智能体都是相同的。\n任何 $1 \\to 0$ 转移的总速率是各个速率的总和，即处于状态1的智能体数量乘以它们共同的转移速率。\n因此，死亡率 $D_k$（即从状态 $k$ 到 $k-1$ 的总转移速率）是：\n$$D_k = k \\cdot c$$\n此速率对于 $k \\in \\{1, \\dots, N\\}$ 有效。当 $k=0$ 时，没有智能体处于状态1，所以 $D_0 = 0$。\n\n推导出的速率完全基于问题定义和可交换性性质，没有任何平均场闭合假设。\n\n### 任务B：稳态分布和相关函数\n\n对于一维生灭过程，稳态分布 $\\pi_N(k)$ 必须对所有 $k \\in \\{0, 1, \\dots, N-1\\}$ 满足细致平衡条件：\n$$\\pi_N(k) B_k = \\pi_N(k+1) D_{k+1}$$\n该方程表达了平衡时相邻状态之间的概率流平衡。由此，我们可以建立 $\\pi_N(k+1)$ 的递推关系：\n$$\\pi_N(k+1) = \\pi_N(k) \\frac{B_k}{D_{k+1}}$$\n将此递推关系从 $k=0$ 展开到任意状态 $k$，我们可以用 $\\pi_N(0)$ 来表示 $\\pi_N(k)$：\n$$\\pi_N(k) = \\pi_N(0) \\prod_{r=0}^{k-1} \\frac{B_r}{D_{r+1}}$$\n这给出了稳态分布的结构，只差一个归一化常数 $\\pi_N(0)$。对于 $k=0$，该乘积定义为1。\n\n为了归一化该分布，我们强制条件 $\\sum_{k=0}^{N} \\pi_N(k) = 1$。令 $u_k = \\prod_{r=0}^{k-1} \\frac{B_r}{D_{r+1}}$（对于 $k  0$）且 $u_0 = 1$。那么：\n$$\\pi_N(0) \\sum_{k=0}^{N} u_k = 1 \\implies \\pi_N(0) = \\frac{1}{\\sum_{j=0}^{N} u_j}$$\n完全归一化的稳态分布则为：\n$$\\pi_N(k) = \\frac{u_k}{\\sum_{j=0}^{N} u_j} = \\frac{\\prod_{r=0}^{k-1} \\frac{B_r}{D_{r+1}}}{\\sum_{j=0}^{N} \\left( \\prod_{r=0}^{j-1} \\frac{B_r}{D_{r+1}} \\right)}$$\n使用 $B_r$ 和 $D_{r+1}$ 的表达式：\n$$\\frac{B_r}{D_{r+1}} = \\frac{(N-r)\\left(a + \\frac{br}{N}\\right)}{(r+1)c}$$\n\n现在，我们来表示所要求的稳态量。\n1.  **稳态均值**：状态为1的智能体数量的期望值为 $\\mathbb{E}_{\\pi_N}[K] = \\sum_{k=0}^{N} k \\, \\pi_N(k)$。稳态平均密度为：\n    $$m_N^\\star = \\frac{\\mathbb{E}_{\\pi_N}[K]}{N} = \\frac{1}{N} \\sum_{k=0}^{N} k \\, \\pi_N(k)$$\n    根据可交换性，任何单个智能体 $i$ 处于状态1的概率是相同的，即 $\\mathbb{E}_{\\pi_N}[x_i]$ 与 $i$ 无关。因此，$\\mathbb{E}_{\\pi_N}[K] = \\mathbb{E}_{\\pi_N}[\\sum_{i=1}^{N} x_i] = \\sum_{i=1}^{N} \\mathbb{E}_{\\pi_N}[x_i] = N \\mathbb{E}_{\\pi_N}[x_i]$。由此得出 $\\mathbb{E}_{\\pi_N}[x_i] = m_N^\\star$。\n\n2.  **稳态对矩**：我们需要计算 $i \\neq j$ 时的 $\\mathbb{E}_{\\pi_N}[x_i x_j]$。我们使用 $K$ 的矩。\n    $$K^2 = \\left(\\sum_{i=1}^{N} x_i\\right)^2 = \\sum_{i=1}^{N} x_i^2 + \\sum_{i \\neq j} x_i x_j$$\n    由于 $x_i \\in \\{0, 1\\}$，我们有 $x_i^2 = x_i$。因此：\n    $$K^2 = K + \\sum_{i \\neq j} x_i x_j$$\n    对 $\\pi_N$ 取期望：\n    $$\\mathbb{E}_{\\pi_N}[K^2] = \\mathbb{E}_{\\pi_N}[K] + \\mathbb{E}_{\\pi_N}\\left[\\sum_{i \\neq j} x_i x_j\\right]$$\n    有 $N(N-1)$ 个 $i \\neq j$ 的不同对 $(i,j)$。由于可交换性，$\\mathbb{E}_{\\pi_N}[x_i x_j]$ 对于所有这样的对都是相同的。\n    $$\\mathbb{E}_{\\pi_N}\\left[\\sum_{i \\neq j} x_i x_j\\right] = N(N-1) \\mathbb{E}_{\\pi_N}[x_i x_j]$$\n    重新整理以求解对矩：\n    $$\\mathbb{E}_{\\pi_N}[x_i x_j] = \\frac{\\mathbb{E}_{\\pi_N}[K^2] - \\mathbb{E}_{\\pi_N}[K]}{N(N-1)}$$\n    其中 $\\mathbb{E}_{\\pi_N}[K^2] = \\sum_{k=0}^{N} k^2 \\, \\pi_N(k)$。此表达式在 $N1$ 时有效。\n\n3.  **稳态连通两点相关性**：其定义为 $C_2^{(N)} = \\mathbb{E}_{\\pi_N}[x_i x_j] - (\\mathbb{E}_{\\pi_N}[x_i])^2$（对于 $i \\neq j$）。代入我们求得的表达式：\n    $$C_2^{(N)} = \\frac{\\mathbb{E}_{\\pi_N}[K^2] - \\mathbb{E}_{\\pi_N}[K]}{N(N-1)} - \\left(\\frac{\\mathbb{E}_{\\pi_N}[K]}{N}\\right)^2$$\n\n### 任务C：算法设计\n\n任务是计算标度相关性 $N \\, C_2^{(N)}$。直接计算 $\\pi_N(k)$ 公式中的乘积可能导致数值上溢或下溢，尤其是在 $N$ 为中等到较大值时。一个稳定的算法应该在对数空间中操作。\n\n算法流程如下：\n1.  **计算未归一化的对数概率**：我们计算 $\\log u_k = \\log\\left(\\prod_{r=0}^{k-1} \\frac{B_r}{D_{r+1}}\\right)$。我们不直接进行乘积运算，而是使用对数求和，这在数值上是稳定的。设 $\\text{log_u}[k]$ 是一个存储 $\\log u_k$ 的数组。\n    -   初始化 $\\text{log_u}[0] = 0$。\n    -   对于 $k = 1, \\dots, N$，迭代计算：\n        $$\\log u_k = \\log u_{k-1} + \\log\\left(\\frac{B_{k-1}}{D_k}\\right)$$\n        其中 $\\log\\left(\\frac{B_{k-1}}{D_k}\\right) = \\log\\left(N-(k-1)\\right) + \\log\\left(a + \\frac{b(k-1)}{N}\\right) - \\log(k) - \\log(c)$。\n\n2.  **归一化概率**：为了计算 $\\pi_N(k) = \\frac{\\exp(\\log u_k)}{\\sum_j \\exp(\\log u_j)}$，我们使用一个标准的稳定化技巧。令 $L_{\\max} = \\max_k(\\log u_k)$。\n    $$\\pi_N(k) = \\frac{\\exp(\\log u_k - L_{\\max})}{\\sum_{j=0}^{N} \\exp(\\log u_j - L_{\\max})}$$\n    现在所有指数都小于或等于0，从而防止了上溢。分母可以安全地计算。\n\n3.  **计算矩**：一旦获得归一化概率向量 $\\pi_N$，就可以通过求和计算 $K$ 的前两阶矩：\n    -   $\\mathbb{E}_{\\pi_N}[K] = \\sum_{k=0}^{N} k \\cdot \\pi_N(k)$\n    -   $\\mathbb{E}_{\\pi_N}[K^2] = \\sum_{k=0}^{N} k^2 \\cdot \\pi_N(k)$\n\n4.  **计算标度相关性**：将计算出的矩代入 $N \\, C_2^{(N)}$ 的表达式中：\n    $$N \\, C_2^{(N)} = N \\left( \\frac{\\mathbb{E}_{\\pi_N}[K^2] - \\mathbb{E}_{\\pi_N}[K]}{N(N-1)} - \\left(\\frac{\\mathbb{E}_{\\pi_N}[K]}{N}\\right)^2 \\right)$$\n    $$N \\, C_2^{(N)} = \\frac{\\mathbb{E}_{\\pi_N}[K^2] - \\mathbb{E}_{\\pi_N}[K]}{N-1} - \\frac{(\\mathbb{E}_{\\pi_N}[K])^2}{N}$$\n    这个最终表达式用于实现。对于所有测试用例（其中 $N \\ge 2$），该表达式都是良定的。\n\n该算法设计是鲁棒的，在浮点精度内是精确的，并且如要求所述，避免了模拟。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    This function encapsulates the entire logic as requested.\n    \"\"\"\n\n    # Test cases: (N, a, b, c)\n    test_cases = [\n        (20, 0.05, 2.0, 1.0),\n        (50, 0.05, 2.0, 1.0),\n        (200, 0.05, 2.0, 1.0),\n        (20, 0.05, 1.2, 1.0),\n        (50, 0.05, 1.2, 1.0),\n        (200, 0.05, 1.2, 1.0),\n        (2, 0.05, 2.0, 1.0),\n    ]\n\n    def compute_scaled_correlation(N, a, b, c):\n        \"\"\"\n        Computes the stationary scaled correlation N * C_2^(N) for a finite system.\n\n        Args:\n            N (int): Number of agents.\n            a (float): Base rate for 0 - 1 transition.\n            b (float): Mean-field coupling for 0 - 1 transition.\n            c (float): Rate for 1 - 0 transition.\n\n        Returns:\n            float: The value of N * C_2^(N).\n        \"\"\"\n        if N == 1:\n            # The correlation C_2^(N) involves a sum over pairs i!=j and is\n            # not well-defined for N = 1. The problem's test cases all have N >= 2.\n            # Returning 0.0 for completeness, though this case is not tested.\n            return 0.0\n\n        # Step 1: Compute unnormalized log-probabilities in a stable way.\n        # u_k = prod_{r=0}^{k-1} (B_r / D_{r+1})\n        # log_u[k] = log(u_k)\n        log_u = np.zeros(N + 1)\n        for k in range(1, N + 1):\n            r = k - 1\n            # B_r = (N - r) * (a + b * r / N)\n            # D_k = k * c\n            log_Br = np.log(N - r) + np.log(a + b * r / N)\n            log_Dk = np.log(k) + np.log(c)\n            log_u[k] = log_u[k - 1] + log_Br - log_Dk\n            \n        # Step 2: Normalize probabilities using a stabilization trick to avoid overflow/underflow.\n        log_u_max = np.max(log_u)\n        u_shifted = np.exp(log_u - log_u_max)\n        Z = np.sum(u_shifted)  # Normalization constant\n        pi_N = u_shifted / Z\n\n        # Step 3: Compute the first two moments of K.\n        k_vals = np.arange(N + 1, dtype=np.float64)\n        E_K = np.sum(k_vals * pi_N)\n        E_K2 = np.sum(k_vals**2 * pi_N)\n\n        # Step 4: Calculate the connected two-point correlation C_2^(N) and scale by N.\n        # C_2^(N) = (E[K^2] - E[K]) / (N(N-1)) - (E[K]/N)^2\n        # N * C_2^(N) = (E[K^2] - E[K]) / (N-1) - (E[K])^2 / N\n        scaled_correlation = (E_K2 - E_K) / (N - 1) - (E_K**2) / N\n        \n        return scaled_correlation\n\n    results = []\n    for case in test_cases:\n        N, a, b, c = case\n        result = compute_scaled_correlation(N, a, b, c)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}