{
    "hands_on_practices": [
        {
            "introduction": "贝叶斯推断的“黄金标准”是当我们可以精确推导出后验分布的解析形式时。当似然函数和先验分布构成一个“共轭”对时，这种情况就可能发生，从而简化了校准过程。本练习通过一个泊松-伽马共轭模型来探索这个理想情况，这是一个在复杂系统中对事件计数进行建模的经典场景 。通过推导闭合形式的后验分布，您不仅将掌握共轭更新的基础知识，还将认识到为什么这种方法在面对许多复杂自适应系统模型的固有复杂性时存在局限性，从而为近似方法的必要性奠定基础。",
            "id": "4115316",
            "problem": "考虑在一个复杂自适应系统中校准一个简单的基于计数的子模型，其中在已知暴露量下累积的交互事件数量被用来推断一个潜在的事件率。令 $y_{1},\\dots,y_{n}$ 表示在严格为正的暴露量 $e_{1},\\dots,e_{n}$ 下观测到的非负整数计数。假设在给定率参数 $\\lambda>0$ 的条件下，观测值是条件独立的，并使用带暴露量的泊松抽样模型对数据进行建模：\n$$\np\\left(y_{i}\\mid \\lambda\\right)=\\frac{\\left(\\lambda e_{i}\\right)^{y_{i}}\\exp\\!\\left(-\\lambda e_{i}\\right)}{y_{i}!},\\quad i=1,\\dots,n.\n$$\n为了获得一个解析上易于处理的贝叶斯校准，采用形状-率参数化的Gamma先验分布作为 $\\lambda$ 的先验：\n$$\np\\left(\\lambda\\right)=\\frac{\\beta_{0}^{\\alpha_{0}}}{\\Gamma\\!\\left(\\alpha_{0}\\right)}\\,\\lambda^{\\alpha_{0}-1}\\exp\\!\\left(-\\beta_{0}\\lambda\\right),\\quad \\alpha_{0}>0,\\;\\beta_{0}>0.\n$$\n从贝叶斯定理以及上述似然和先验的定义出发，推导 $\\lambda$ 的闭式后验分布，并用 $\\alpha_{0}$、$\\beta_{0}$、$\\{y_{i}\\}_{i=1}^{n}$ 和 $\\{e_{i}\\}_{i=1}^{n}$ 来表示其参数。然后，用这些符号给出后验均值 $\\mathbb{E}\\!\\left[\\lambda\\mid y_{1},\\dots,y_{n}\\right]$ 的精确闭式解析表达式。你的答案应该是一个单一的解析表达式；无需进行四舍五入。校准后的率参数 $\\lambda$ 的单位是“每个暴露单位的事件数”；不要在你的表达式中包含单位。\n\n简要阐述（无需计算）为什么这种共轭构造对于复杂自适应系统中的校准可能具有局限性，以及在何种情况下，由于似然函数的难解性，近似贝叶斯计算（ABC）会是更优的选择。最终答案必须是后验均值的精确表达式。",
            "solution": "问题陈述经过验证。\n\n### 步骤1：提取已知条件\n-   观测数据：非负整数计数 $y_{1}, \\dots, y_{n}$。\n-   暴露量：严格为正的值 $e_{1}, \\dots, e_{n}$。\n-   目标参数：率参数 $\\lambda > 0$。\n-   抽样模型（似然）：观测值 $y_i$ 在给定 $\\lambda$ 的条件下是条件独立的，并且服从均值为 $\\lambda e_i$ 的泊松分布。单个观测值的概率质量函数为：\n    $$\n    p\\left(y_{i}\\mid \\lambda\\right)=\\frac{\\left(\\lambda e_{i}\\right)^{y_{i}}\\exp\\!\\left(-\\lambda e_{i}\\right)}{y_{i}!}\n    $$\n-   先验分布：$\\lambda$ 的先验是一个形状参数为 $\\alpha_0 > 0$、率参数为 $\\beta_0 > 0$ 的Gamma分布。概率密度函数为：\n    $$\n    p\\left(\\lambda\\right)=\\frac{\\beta_{0}^{\\alpha_{0}}}{\\Gamma\\!\\left(\\alpha_{0}\\right)}\\,\\lambda^{\\alpha_{0}-1}\\exp\\!\\left(-\\beta_{0}\\lambda\\right)\n    $$\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题基于标准的贝叶斯统计理论。对计数数据使用泊松似然和对率参数使用Gamma先验是共轭先验设置的一个典型例子，这是贝叶斯统计中的一个基本主题。\n-   **适定性**：该问题是适定的。它要求在给定完全指定的似然和先验的情况下，推导后验分布及其均值。这种结构确保了存在唯一且有意义的解。\n-   **客观性**：问题使用精确、形式化的数学语言陈述，没有任何主观或模棱两可的术语。\n-   **完整性**：提供了所有必要的信息（似然、先验、数据与参数之间的关系）。\n-   **一致性**：已知条件是内部一致的。变量和参数的定义域（$\\lambda>0$, $y_i \\in \\{0, 1, 2, \\dots\\}$, $e_i>0$, $\\alpha_0>0$, $\\beta_0>0$）都与泊松分布和Gamma分布的定义兼容。\n\n### 步骤3：结论与行动\n问题有效。将提供解答。\n\n推导过程通过应用贝叶斯定理进行，该定理指出后验分布正比于似然和先验分布的乘积。令 $Y = (y_1, \\dots, y_n)$ 表示所有观测值的集合。\n\n$\\lambda$ 的后验分布由下式给出：\n$$\np(\\lambda \\mid Y) \\propto p(Y \\mid \\lambda) \\, p(\\lambda)\n$$\n首先，我们构建似然函数 $p(Y \\mid \\lambda)$。由于观测值 $y_i$ 的条件独立性，联合似然是个体似然的乘积：\n$$\np(Y \\mid \\lambda) = \\prod_{i=1}^{n} p(y_i \\mid \\lambda) = \\prod_{i=1}^{n} \\frac{(\\lambda e_i)^{y_i} \\exp(-\\lambda e_i)}{y_i!}\n$$\n我们可以将依赖于 $\\lambda$ 的项与不依赖的项分开。\n$$\np(Y \\mid \\lambda) = \\left( \\prod_{i=1}^{n} \\frac{e_i^{y_i}}{y_i!} \\right) \\left( \\prod_{i=1}^{n} \\lambda^{y_i} \\exp(-\\lambda e_i) \\right)\n$$\n合并第二个括号内的项：\n$$\n\\prod_{i=1}^{n} \\lambda^{y_i} \\exp(-\\lambda e_i) = \\lambda^{\\sum_{i=1}^{n} y_i} \\exp\\left(-\\lambda \\sum_{i=1}^{n} e_i\\right)\n$$\n由于我们关心 $\\lambda$ 的后验分布的形状，我们可以将任何不涉及 $\\lambda$ 的项视为归一化常数的一部分。因此，似然正比于：\n$$\np(Y \\mid \\lambda) \\propto \\lambda^{\\sum_{i=1}^{n} y_i} \\exp\\left(-\\lambda \\sum_{i=1}^{n} e_i\\right)\n$$\n接下来，我们考虑先验分布，它是一个Gamma分布 $\\text{Gamma}(\\alpha_0, \\beta_0)$：\n$$\np(\\lambda) = \\frac{\\beta_{0}^{\\alpha_{0}}}{\\Gamma(\\alpha_{0})} \\lambda^{\\alpha_{0}-1} \\exp(-\\beta_{0}\\lambda)\n$$\n先验分布的核（依赖于 $\\lambda$ 的部分）是：\n$$\np(\\lambda) \\propto \\lambda^{\\alpha_{0}-1} \\exp(-\\beta_{0}\\lambda)\n$$\n现在，我们将似然核与先验核相乘，以找到后验核：\n$$\np(\\lambda \\mid Y) \\propto \\left( \\lambda^{\\sum_{i=1}^{n} y_i} \\exp\\left(-\\lambda \\sum_{i=1}^{n} e_i\\right) \\right) \\cdot \\left( \\lambda^{\\alpha_{0}-1} \\exp(-\\beta_{0}\\lambda) \\right)\n$$\n通过相加指数来合并项：\n$$\np(\\lambda \\mid Y) \\propto \\lambda^{\\left(\\alpha_{0} - 1\\right) + \\sum_{i=1}^{n} y_i} \\exp\\left(-\\beta_{0}\\lambda - \\lambda \\sum_{i=1}^{n} e_i\\right)\n$$\n$$\np(\\lambda \\mid Y) \\propto \\lambda^{\\left(\\alpha_{0} + \\sum_{i=1}^{n} y_i\\right) - 1} \\exp\\left(-\\left(\\beta_{0} + \\sum_{i=1}^{n} e_i\\right)\\lambda\\right)\n$$\n这个得到的函数形式是一个Gamma分布的核。一个服从形状参数为 $\\alpha$、率参数为 $\\beta$ 的Gamma分布（记作 $X \\sim \\text{Gamma}(\\alpha, \\beta)$）的随机变量X，其概率密度函数正比于 $x^{\\alpha-1}\\exp(-\\beta x)$。\n\n通过将我们的后验核与标准的Gamma核进行比较，我们可以确定后验分布的参数。设后验分布是一个形状参数为 $\\alpha_n$、率参数为 $\\beta_n$ 的Gamma分布。那么：\n$$\n\\alpha_n = \\alpha_0 + \\sum_{i=1}^{n} y_i\n$$\n$$\n\\beta_n = \\beta_0 + \\sum_{i=1}^{n} e_i\n$$\n因此，$\\lambda$ 的后验分布是具有这些更新后参数的Gamma分布：\n$$\n\\lambda \\mid Y \\sim \\text{Gamma}\\left(\\alpha_0 + \\sum_{i=1}^{n} y_i, \\beta_0 + \\sum_{i=1}^{n} e_i\\right)\n$$\n形状参数为 $\\alpha$、率参数为 $\\beta$ 的Gamma分布的均值由比率 $\\frac{\\alpha}{\\beta}$ 给出。因此，$\\lambda$ 的后验均值，记作 $\\mathbb{E}[\\lambda \\mid Y]$，为：\n$$\n\\mathbb{E}[\\lambda \\mid y_1, \\dots, y_n] = \\frac{\\alpha_n}{\\beta_n} = \\frac{\\alpha_0 + \\sum_{i=1}^{n} y_i}{\\beta_0 + \\sum_{i=1}^{n} e_i}\n$$\n\n关于这种共轭构造在复杂自适应系统（CAS）中的局限性：这种方法的前提是能够写出并评估一个解析的似然函数 $p(y \\mid \\lambda)$。在许多CAS模型中，例如基于智能体的模型或大规模网络模拟，模型参数（$\\theta$）与可观测输出（$y$）之间的关系是由一个复杂的、随机的模拟过程定义的。因此，似然函数 $p(y \\mid \\theta)$ 是难解的，意味着它不能以闭式解析形式表示或评估。该模型充当一个黑箱模拟器。\n\n在这种情况下，近似贝叶斯计算（ABC）是首选，正是因为它避免了评估似然函数的需要。ABC通过在不同的参数设置下从模型中模拟合成数据集，并接受那些能生成与观测数据“接近”的合成数据的参数值，来进行“无似然”推断。这使得对那些似然函数难解的模型进行贝叶斯校准成为可能，而这正是复杂自适应系统的一个共同特征。",
            "answer": "$$\n\\boxed{\\frac{\\alpha_{0} + \\sum_{i=1}^{n} y_{i}}{\\beta_{0} + \\sum_{i=1}^{n} e_{i}}}\n$$"
        },
        {
            "introduction": "在获得参数的后验分布后（无论是精确的还是近似的），一个至关重要的步骤是评估校准后的模型在多大程度上能够代表观测数据。本练习介绍后验预测检验，这是一种用于诊断模型失配的强大技术 。通过使用从后验分布中抽取的参数来模拟新数据集，我们可以检验模型是否能生成与我们实际观测到的数据“相似”的数据。这个练习将引导您计算一个关键摘要统计量的后验预测均值和方差，并解释其与观测值的偏差所揭示的模型适用性问题。",
            "id": "4115312",
            "problem": "考虑一个复杂自适应系统中的基于智能体的传染病模型，其中每日新增病例被聚合成一个计数时间序列。设 $y = (y_{1}, \\dots, y_{n})$ 表示在给定一个潜在率参数 $\\lambda$ 的情况下，$n$ 个条件独立的每日计数值，其生成模型为 $y_{i} \\mid \\lambda \\sim \\text{Poisson}(\\lambda)$，其中 $i = 1, \\dots, n$。假设使用近似贝叶斯计算 (ABC) 进行了校准，得到了在给定观测数据 $y^{\\text{obs}}$ 的情况下 $\\lambda$ 的近似贝叶斯后验分布，其形式为 $\\lambda \\mid y^{\\text{obs}} \\sim \\text{Gamma}(\\alpha, \\beta)$（率参数化），密度函数为 $p(\\lambda \\mid y^{\\text{obs}}) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} \\lambda^{\\alpha - 1} \\exp(-\\beta \\lambda)$，其中 $\\lambda > 0$，$\\alpha > 0$，$\\beta > 0$。定义汇总统计量 $s(y) = \\frac{1}{n} \\sum_{i=1}^{n} y_{i}$，即每日平均计数值。\n\n仅使用后验预测分布 $p(y_{\\text{new}} \\mid y^{\\text{obs}}) = \\int p(y_{\\text{new}} \\mid \\theta) p(\\theta \\mid y^{\\text{obs}}) \\, d\\theta$ 的基本定义以及全期望定律和全方差定律，推导出后验预测均值 $\\mu_{s} = \\mathbb{E}[s(Y_{\\text{new}}) \\mid y^{\\text{obs}}]$ 和方差 $\\sigma_{s}^{2} = \\operatorname{Var}(s(Y_{\\text{new}}) \\mid y^{\\text{obs}})$ 关于 $\\alpha$、$\\beta$ 和 $n$ 的闭式解析表达式。然后，解释在后验预测检验中，如果观测到的汇总统计量 $s(y^{\\text{obs}})$ 满足 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s} \\approx 2$，这意味着什么。\n\n最终的解析表达式需精确表示，无需四舍五入。最终答案必须以包含 $\\mu_{s}$ 和 $\\sigma_{s}^{2}$（按此顺序）的双元素行矩阵形式给出。",
            "solution": "### 步骤1：提取已知条件\n- **生成过程**：$n$ 个条件独立的每日计数值 $y = (y_1, \\dots, y_n)$，其中 $y_i \\mid \\lambda \\sim \\text{Poisson}(\\lambda)$，对于 $i=1, \\dots, n$。\n- **观测数据**：$y^{\\text{obs}}$。\n- **近似后验分布**：给定观测数据 $y^{\\text{obs}}$，率参数 $\\lambda$ 的后验分布被近似为 $\\lambda \\mid y^{\\text{obs}} \\sim \\text{Gamma}(\\alpha, \\beta)$（率参数化）。\n- **后验密度**：$p(\\lambda \\mid y^{\\text{obs}}) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} \\lambda^{\\alpha - 1} \\exp(-\\beta \\lambda)$，其中 $\\lambda > 0$，$\\alpha > 0$，$\\beta > 0$。\n- **汇总统计量**：$s(y) = \\frac{1}{n} \\sum_{i=1}^{n} y_{i}$。\n- **后验预测分布定义**：$p(y_{\\text{new}} \\mid y^{\\text{obs}}) = \\int p(y_{\\text{new}} \\mid \\theta) p(\\theta \\mid y^{\\text{obs}}) \\, d\\theta$。\n- **所需工具**：全期望定律和全方差定律。\n- **目标**：\n    1. 推导后验预测均值 $\\mu_{s} = \\mathbb{E}[s(Y_{\\text{new}}) \\mid y^{\\text{obs}}]$ 和方差 $\\sigma_{s}^{2} = \\operatorname{Var}(s(Y_{\\text{new}}) \\mid y^{\\text{obs}})$ 的闭式解析表达式。\n    2. 解释 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s} \\approx 2$ 的含义。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准评估该问题。\n- **科学基础**：该问题在贝叶斯统计和概率论的原理上有坚实的基础。使用泊松模型处理计数数据，使用伽马分布作为率参数的后验分布（它是共轭先验，使其成为一种合理的后验形式），以及后验预测检验的概念，都是现代统计建模的标准元素。\n- **适定性**：该问题是适定的。它提供了所有必要的信息（生成模型、后验形式、汇总统计量）来唯一确定所要求的量（$\\mu_s$ 和 $\\sigma_s^2$）。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有主观论断或歧义。\n- **完整性与一致性**：设置是完整的且内部一致。没有信息缺失或矛盾。\n- **主题相关性**：该问题直接且紧密地定位于*贝叶斯校准与近似贝叶斯计算 (ABC)* 用于*复杂自适应系统建模*的指定主题内。\n\n该问题未表现出验证清单中列出的任何缺陷。\n\n### 步骤3：结论与行动\n该问题有效。现在开始求解过程。\n\n### 后验预测均值和方差的推导\n\n设 $Y_{\\text{new}} = (Y_{\\text{new},1}, \\dots, Y_{\\text{new},n})$ 是从模型中生成的一个新的、重复的数据集，其中 $Y_{\\text{new},i} \\mid \\lambda \\sim \\text{Poisson}(\\lambda)$。这个新数据集的汇总统计量是 $s(Y_{\\text{new}}) = \\frac{1}{n} \\sum_{i=1}^{n} Y_{\\text{new},i}$。我们需要求这个统计量的均值和方差，并在 $\\lambda$ 的后验分布上取平均。对 $y^{\\text{obs}}$ 的条件是隐含在后验 $p(\\lambda \\mid y^{\\text{obs}})$ 的使用中的。\n\n**1. 后验预测均值 $\\mu_s$**\n\n我们使用全期望定律：$\\mathbb{E}[X] = \\mathbb{E}[\\mathbb{E}[X \\mid Z]]$。令 $X = s(Y_{\\text{new}})$ 且 $Z = \\lambda$。\n$$\n\\mu_s = \\mathbb{E}[s(Y_{\\text{new}}) \\mid y^{\\text{obs}}] = \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}} \\left[ \\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda, y^{\\text{obs}}] \\right]\n$$\n给定 $\\lambda$，新数据 $Y_{\\text{new}}$ 的生成独立于观测数据 $y^{\\text{obs}}$。因此，$\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda, y^{\\text{obs}}] = \\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda]$。\n\n首先，我们求以 $\\lambda$ 为条件的内层期望：\n$$\n\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda] = \\mathbb{E}\\left[\\frac{1}{n} \\sum_{i=1}^{n} Y_{\\text{new},i} \\mid \\lambda \\right]\n$$\n根据期望的线性性质：\n$$\n\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda] = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbb{E}[Y_{\\text{new},i} \\mid \\lambda]\n$$\n对于一个泊松随机变量 $Y_{\\text{new},i} \\sim \\text{Poisson}(\\lambda)$，其期望为 $\\mathbb{E}[Y_{\\text{new},i} \\mid \\lambda] = \\lambda$。因此：\n$$\n\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda] = \\frac{1}{n} \\sum_{i=1}^{n} \\lambda = \\frac{n\\lambda}{n} = \\lambda\n$$\n现在，我们对这个结果关于 $\\lambda$ 的后验分布（即 $\\lambda \\mid y^{\\text{obs}} \\sim \\text{Gamma}(\\alpha, \\beta)$）求期望。\n$$\n\\mu_s = \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}[\\lambda]\n$$\n形状参数为 $\\alpha$、率参数为 $\\beta$ 的伽马分布的均值为 $\\frac{\\alpha}{\\beta}$。\n$$\n\\mu_s = \\frac{\\alpha}{\\beta}\n$$\n\n**2. 后验预测方差 $\\sigma_s^2$**\n\n我们使用全方差定律：$\\operatorname{Var}(X) = \\mathbb{E}[\\operatorname{Var}(X \\mid Z)] + \\operatorname{Var}(\\mathbb{E}[X \\mid Z])$。同样，令 $X = s(Y_{\\text{new}})$ 且 $Z = \\lambda$。\n$$\n\\sigma_s^2 = \\operatorname{Var}(s(Y_{\\text{new}}) \\mid y^{\\text{obs}}) = \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}[\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda)] + \\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda])\n$$\n我们需要计算右侧的两项。\n\n对于第一项，我们从以 $\\lambda$ 为条件的内层方差开始：\n$$\n\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda) = \\operatorname{Var}\\left(\\frac{1}{n} \\sum_{i=1}^{n} Y_{\\text{new},i} \\mid \\lambda\\right)\n$$\n由于给定 $\\lambda$ 时 $Y_{\\text{new},i}$ 是条件独立的：\n$$\n\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda) = \\frac{1}{n^2} \\sum_{i=1}^{n} \\operatorname{Var}(Y_{\\text{new},i} \\mid \\lambda)\n$$\n一个泊松随机变量 $Y_{\\text{new},i} \\sim \\text{Poisson}(\\lambda)$ 的方差为 $\\operatorname{Var}(Y_{\\text{new},i} \\mid \\lambda) = \\lambda$。\n$$\n\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda) = \\frac{1}{n^2} \\sum_{i=1}^{n} \\lambda = \\frac{n\\lambda}{n^2} = \\frac{\\lambda}{n}\n$$\n现在我们对这个量关于 $\\lambda$ 的后验分布求期望：\n$$\n\\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}\\left[\\frac{\\lambda}{n}\\right] = \\frac{1}{n} \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}[\\lambda] = \\frac{1}{n} \\frac{\\alpha}{\\beta}\n$$\n这是第一项。\n\n对于第二项，我们需要我们之前求出的条件期望的方差：\n$$\n\\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda]) = \\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\lambda)\n$$\n这恰好是 $\\lambda$ 的后验分布，即 $\\text{Gamma}(\\alpha, \\beta)$ 的方差。形状参数为 $\\alpha$、率参数为 $\\beta$ 的伽马分布的方差是 $\\frac{\\alpha}{\\beta^2}$。\n$$\n\\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\lambda) = \\frac{\\alpha}{\\beta^2}\n$$\n这是第二项。\n\n最后，我们将两项相加得到总的后验预测方差：\n$$\n\\sigma_s^2 = \\frac{\\alpha}{n\\beta} + \\frac{\\alpha}{\\beta^2}\n$$\n通分合并各项：\n$$\n\\sigma_s^2 = \\frac{\\alpha\\beta}{n\\beta^2} + \\frac{\\alpha n}{n\\beta^2} = \\frac{\\alpha\\beta + \\alpha n}{n\\beta^2} = \\frac{\\alpha(n + \\beta)}{n\\beta^2}\n$$\n\n### 后验预测检验的解释\n\n将观测数量与其后验预测分布进行比较的过程称为后验预测检验 (PPC)。这是一种评估贝叶斯模型拟合优度的方法。量 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s}$ 是一个标准化的差异度量。它量化了观测到的汇总统计量 $s(y^{\\text{obs}})$ 距离重复生成的汇总统计量分布的均值 $\\mu_s$ 有多少个标准差。\n\n如果 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s} \\approx 2$，这意味着观测到的每日平均计数值距离该统计量的后验预测分布中心大约有两个标准差。在频率派假设检验中，z-分数 $2$ 通常被认为是统计显著性的阈值（例如，对于双尾检验，在假设近似正态分布的情况下，显著性水平 $\\alpha \\approx 0.05$）。\n\n在贝叶斯背景下，这个结果将被解释为模型与数据之间存在显著的不一致性，尤其是在汇总统计量 $s(y)$ 所捕捉的特征方面。由模型生成的数据（以后验预测分布为特征）通常不会产生像实际数据中观测到的那样极端的均值。观测均值位于预测分布的尾部，表明在拟合的模型下它是一个不太可能发生的结果。\n\n这种差异表明模型设定存在错误。模型未能复现观测数据的一个关键特征。导致这种失败的可能原因包括：\n1.  **错误的生成模型**：泊松假设可能是错误的。例如，真实世界的传染病数据通常表现出过度离散（方差大于均值），而泊松模型（$Var(y) = E[y]$）无法解释这一点。负二项分布模型可能更合适。\n2.  **ABC近似效果不佳**：由ABC算法产生的近似后验分布 $\\text{Gamma}(\\alpha, \\beta)$ 可能不是真实后验分布的忠实表示。\n3.  **先验分布不当**：在贝叶斯分析中使用的先验分布（它隐含地参与了后验的计算）可能不合适，对真实参数值赋予了太小的概率质量。\n\n总之，标准化差异值约为 $2$ 是一个强烈的信号，表明应该对模型进行批判性审查、修正，并可能用一个更合适的模型来替代。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\alpha}{\\beta}  \\frac{\\alpha(n+\\beta)}{n\\beta^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在对复杂系统进行建模时，似然函数通常是难以处理的，而模型本身几乎总是对现实的简化。本练习将带您进入这个真实世界的挑战，解决模型设定错误这一高级诊断问题 。它演示了一种强大的诊断技术：使用不同的摘要统计量集运行近似贝叶斯计算（ABC）；如果由此产生的参数后验分布发生系统性偏移，这便是模型设定错误的强烈信号。这项练习要求您实现一个完整的基于主体的模型和ABC流程，代表了复杂系统建模中一项真正的动手实践挑战。",
            "id": "4115335",
            "problem": "考虑一个复杂自适应系统中的基于智能体的易感-感染-易感模型，该系统包含 $N$ 个智能体，分布在度为 $d=4$ 的环形晶格上（每个智能体与其最近和次近的两个邻居相连）。在时间 $t$，每个智能体要么是易感状态，要么是感染状态。一个有 $m$ 个感染邻居的易感智能体，在下一个时间步以概率 $$1 - (1 - p)^{m}$$, 被感染，而一个感染智能体以概率 $r$ 康复，此过程与其他智能体无关。令 $\\theta = (p, r)$ 表示模型参数。设感染智能体的初始比例为 $f_0$，系统演化 $T$ 个离散时间步。观测数据是随时间变化的感染数量的时间序列，记为 $y_{\\text{obs}} = (I_1, I_2, \\dots, I_T)$，其中 $I_t$ 是时间 $t$ 的感染智能体数量。\n\n贝叶斯校准通过贝叶斯法则 $$p(\\theta \\mid y_{\\text{obs}}) \\propto p(y_{\\text{obs}} \\mid \\theta)\\,p(\\theta)$$, 来寻求后验分布 $p(\\theta \\mid y_{\\text{obs}})$，但对于复杂自适应系统，似然函数 $p(y_{\\text{obs}} \\mid \\theta)$ 通常是难解的。近似贝叶斯计算（ABC）通过比较模拟数据的摘要统计量与观测数据的摘要统计量，并接受那些能产生足够接近的摘要的参数，来近似后验分布。具体来说，令 $S(y)$ 表示数据 $y$ 的摘要统计量向量，并定义观测摘要向量与在 $\\theta$ 下模拟的数据 $y_{\\text{sim}}$ 的摘要向量之间的距离 $d(S(y_{\\text{obs}}), S(y_{\\text{sim}}))$。在容差 $\\epsilon$ 下，ABC 拒绝后验是在先验 $p(\\theta)$ 下，以 $d(S(y_{\\text{obs}}), S(y_{\\text{sim}})) \\le \\epsilon$ 为条件的 $\\theta$ 的分布。\n\n为了诊断模型设定错误，可以比较在不同摘要集下获得的 ABC 后验分布。ABC 后验分布在不同摘要集之间的系统性偏移可能表明，该模型无法联合解释观测数据的不同方面，从而暗示了模型设定错误。\n\n您的任务是通过计算三个备选摘要集下的 ABC 后验分布，并量化其后验均值相对于后验变异性的系统性偏移，来实现一个 ABC 模型设定错误诊断。\n\n使用的基本原理和定义：\n- 贝叶斯法则：$p(\\theta \\mid y) \\propto p(y \\mid \\theta) p(\\theta)$。\n- 近似贝叶斯计算 (ABC)：如果 $d(S(y_{\\text{obs}}), S(y_{\\text{sim}})) \\le \\epsilon$，则接受 $\\theta$，其中 $\\epsilon$ 是一个选定的或数据自适应的容差。\n- 在指定参数域上的均匀先验下的拒绝采样。\n- 如上所述的基于智能体的易感-感染-易感动态。\n\n实现以下内容：\n1. 先验和参数域。对 $\\theta = (p, r)$ 使用均匀先验，其中 $p \\sim \\text{Uniform}[0.05, 0.50]$ 且 $r \\sim \\text{Uniform}[0.05, 0.40]$。\n2. ABC 采样。使用拒绝 ABC 法，从先验中进行 $M = 1200$ 次独立的参数抽取。对每次抽取，模拟模型 $T$ 个时间步，并计算模拟摘要向量与观测摘要向量之间的距离。将容差 $\\epsilon$ 定义为这些距离的经验 $q$-分位数，其中 $q = 0.03$，这样大约会接受最优的 $3\\%$ 的参数抽取。\n3. 用于 ABC 后验计算的模拟模型。ABC 后验必须使用指定的易感-感染-易感动态进行计算，其感染概率为 $1 - (1 - p)^m$，恢复概率为 $r$。\n4. 摘要集。使用以下每个摘要集计算 ABC 后验。对所有摘要，按照指定的方式通过 $N$ 和 $T$ 进行归一化，以使各分量无量纲且可比较：\n   - 摘要集 $\\mathcal{S}_A(y) = \\big[ \\overline{I}/N,\\ \\mathrm{Var}(I)/N^2,\\ \\rho_1 \\big]$，其中 $\\overline{I}$ 是 $I_t$ 在 $t=1,\\dots,T$ 上的均值，$\\mathrm{Var}(I)$ 是 $I_t$ 随时间的样本方差，$\\rho_1$ 是 $I_t$ 随时间的滞后-1 自相关（如果方差为零，则定义 $\\rho_1 = 0$）。\n   - 摘要集 $\\mathcal{S}_B(y) = \\big[ \\max_t I_t/N,\\ t^\\ast/T,\\ (I_{t_0} - I_1)/N \\big]$，其中 $t^\\ast$ 是感染峰值数量的时间索引，$t_0 = \\min\\{5, T\\}$ 是一个用于近似初始斜率的早期小时间索引。\n   - 摘要集 $\\mathcal{S}_C(y) = \\big[ I_T/N,\\ \\sum_{t=1}^T I_t/(N T) \\big]$，即最终感染比例和随时间的平均感染比例。\n5. 距离函数。对于任何摘要向量 $S = (s_1, \\dots, s_k)$，使用欧几里得距离 $$d(S(y_{\\text{obs}}), S(y_{\\text{sim}})) = \\left\\| S(y_{\\text{obs}}) - S(y_{\\text{sim}}) \\right\\|_2.$$\n6. 后验均值和变异性。对每个摘要集，计算 $\\theta$ 的后验均值 $\\mu^{(A)}$, $\\mu^{(B)}$, $\\mu^{(C)}$ 和后验标准差 $\\sigma^{(A)}$, $\\sigma^{(B)}$, $\\sigma^{(C)}$，其中标准差是针对 $p$ 和 $r$ 的分量形式。令 $\\|\\sigma^{(S)}\\|_2$ 表示摘要集 $S$ 的后验标准差向量的欧几里得范数。\n7. 模型设定错误诊断。定义最大成对后验均值距离 $$\\Delta_{\\max} = \\max\\left\\{ \\left\\| \\mu^{(A)} - \\mu^{(B)} \\right\\|_2,\\ \\left\\| \\mu^{(A)} - \\mu^{(C)} \\right\\|_2,\\ \\left\\| \\mu^{(B)} - \\mu^{(C)} \\right\\|_2 \\right\\}.$$ 定义平均后验变异性 $$\\bar{\\sigma} = \\frac{1}{3}\\left( \\|\\sigma^{(A)}\\|_2 + \\|\\sigma^{(B)}\\|_2 + \\|\\sigma^{(C)}\\|_2 \\right).$$ 计算归一化偏移 $$S^\\ast = \\frac{\\Delta_{\\max}}{\\bar{\\sigma}}.$$ 如果 $S^\\ast \\ge \\tau$ 且阈值 $\\tau = 1.25$，则声明模型设定错误。\n8. 随机性控制。使用固定的随机种子，以使结果可复现。\n\n测试套件的观测数据生成：\n- 在设定良好的情景中，使用第 3 项中描述的相同模拟模型，以指定的真实参数且无额外噪声的方式生成 $y_{\\text{obs}}$。\n- 在设定错误的情景中，使用违反 ABC 模拟模型假设的机制生成 $y_{\\text{obs}}$，以引发系统性的、依赖于摘要的后验偏移，具体如下所述。\n- 在弱数据情景中，包含观测噪声以降低信息量。\n\n测试套件。对于每个测试案例，使用初始感染比例 $f_0 = 0.10$ 和度 $d=4$。详细的测试案例如下：\n1. 案例 1（设定良好的基线）：$N = 30$, $T = 20$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用指定的易感-感染-易感动态生成，无观测噪声。\n2. 案例 2（阈值设定错误）：$N = 30$, $T = 20$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用 ABC 模拟模型中不存在的阈值传染效应生成：对于易感智能体，如果其感染邻居的比例 $m/d$ 至少为 $\\alpha = 0.30$，则使用感染参数 $p_{\\text{eff}} = p$；否则使用 $p_{\\text{eff}} = 0.20\\,p$。感染概率为 $1 - (1 - p_{\\text{eff}})^{m}$，恢复概率仍为 $r$。\n3. 案例 3（弱信息数据）：$N = 20$, $T = 12$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用指定的易感-感染-易感动态生成，并对每个 $I_t$ 应用标准差为 $\\sigma = 2$ 的加性零均值高斯观测噪声，然后四舍五入到最近的整数，并裁剪到区间 $[0, N]$ 内。\n4. 案例 4（外生冲击设定错误）：$N = 30$, $T = 20$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用指定的易感-感染-易感动态生成，并在时间 $t = 8$ 和 $t = 15$ 发生外生冲击，这些冲击在那些时刻瞬时感染 $k = 4$ 个随机选择的易感智能体；此机制在 ABC 模拟模型中不存在。\n\n算法要求：\n- 实现具有向量化更新的基于智能体的模拟，以提高计算效率。\n- 对所有摘要集和测试案例使用相同的 ABC 采样过程，并采用上述指定的先验、$M$、$q$ 和容差规则。\n- 使用固定的随机种子以保证可复现性。\n\n输出规范：\n- 对 4 个测试案例中的每一个，计算模型设定错误诊断的布尔值：如果 $S^\\ast \\ge \\tau$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 1 到 4 的顺序排列结果。例如，输出格式为 $\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\big]$，其中每个 $\\text{result}_i$ 为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "该问题要求使用近似贝叶斯计算（ABC）为基于智能体的模型实现一个模型设定错误诊断。该诊断依赖于量化当使用不同摘要统计量集进行近似时，后验参数估计中的系统性偏移。一个大的、统计上显著的偏移表明模型设定错误，因为它不能一致地复现数据的不同可观测特征。\n\n对问题陈述的验证确认了其科学基础扎实、问题设定良好且内容完整。它描述了一个标准的基于智能体的易感-感染-易感（SIS）模型，并使用了计算统计学（ABC）和模型检验中的既定方法。所有参数、算法和测试案例都得到了明确无歧义的定义，从而可以进行直接且可验证的实现。\n\n解决方案首先按照规定构建必要的计算组件，然后将它们应用于四个测试案例。核心组件包括：\n1.  SIS 模型的基于智能体的模拟。\n2.  用于计算三个不同摘要统计量集的函数。\n3.  一个用于近似后验分布 $p(\\theta \\mid y_{\\text{obs}})$ 的 ABC 拒绝采样算法。\n4.  一个用于计算模型设定错误诊断 $S^\\ast$ 的程序。\n\n**1. 基于智能体的 SIS 模拟模型**\n\n该系统由 $N$ 个智能体组成，排列在一个环形晶格上，每个智能体与其 $d=4$ 个邻居（每侧各两个）相连。每个智能体 $i$ 在离散时间 $t$ 的状态，记为 $s_i(t)$，可以是易感（$s_i(t)=0$）或感染（$s_i(t)=1$）。系统动态由两个随机过程控制：感染和恢复。\n\n-   **感染**：一个易感智能体 $i$（$s_i(t)=0$）有 $m_i(t)$ 个感染邻居。它在时间 $t+1$ 以概率 $P_{\\text{inf}} = 1 - (1 - p)^{m_i(t)}$ 被感染，其中 $p$ 是每次接触的传播概率。此公式假设感染可以独立地从任何一个感染邻居发生。\n-   **恢复**：一个感染智能体 $i$（$s_i(t)=1$）在时间 $t+1$ 以恒定概率 $r$ 恢复并再次变为易感。\n\n因此，模型参数是向量 $\\theta = (p, r)$。模拟从一个初始比例为 $f_0$ 的随机选择的感染智能体开始，并演化 $T$ 个时间步。为了效率，该模拟使用向量化操作实现。邻里结构被预先计算为一个邻接矩阵 $\\mathbf{A}$，其中如果智能体 $i$ 和 $j$ 是邻居，则 $\\mathbf{A}_{ij} = 1$，否则为 $0$。在每个时间步 $t$，所有智能体的感染邻居计数向量计算为 $\\mathbf{m}(t) = \\mathbf{A}\\mathbf{s}(t)$，其中 $\\mathbf{s}(t)$ 是所有智能体的状态向量。基于时间 $t$ 的状态执行同步更新，以确定时间 $t+1$ 的状态。\n\n为了在设定错误和有噪声的情景中生成观测数据 $y_{\\text{obs}}$，根据测试案例的规范对这个核心模拟进行了修改：\n-   **案例 2（阈值设定错误）**：感染参数 $p$ 被一个有效参数 $p_{\\text{eff}}$ 替代，该参数取决于局部感染密度。如果一个智能体的感染邻居比例 $m/d \\ge \\alpha=0.30$，则 $p_{\\text{eff}}=p$；否则，$p_{\\text{eff}} = 0.20p$。然而，ABC 推断算法不知道此机制，而是使用更简单的标准 SIS 模型。\n-   **案例 3（弱信息数据）**：真实的感染数 $I_t$ 被均值为 $0$、标准差为 $\\sigma=2$ 的加性高斯噪声所污染。结果值被四舍五入到最近的整数，并被限制在有效范围 $[0, N]$ 内。\n-   **案例 4（外生冲击设定错误）**：在指定的时间 $t \\in \\{8, 15\\}$，固定数量的 $k=4$ 个易感智能体被瞬时随机选择并变为感染状态。这种外部影响不属于用于 ABC 的标准 SIS 模型。\n\n**2. 摘要统计量和距离度量**\n\n似然函数 $p(y_{\\text{obs}} \\mid \\theta)$ 是难解的，这使得 ABC 方法成为必要。这涉及用一个低维的摘要统计向量 $S(y)$ 来替代完整的数据向量 $y = (I_1, \\dots, I_T)$。使用三个不同的摘要统计量集来探究系统动态的不同方面：\n\n-   $\\mathcal{S}_A(y) = \\big[ \\overline{I}/N,\\ \\mathrm{Var}(I)/N^2,\\ \\rho_1 \\big]$：捕捉感染数目的中心趋势、变异性和时间相关性。$\\overline{I}$ 是时间均值，$\\mathrm{Var}(I)$ 是样本方差，$\\rho_1$ 是滞后-1 自相关。\n-   $\\mathcal{S}_B(y) = \\big[ \\max_t I_t/N,\\ t^\\ast/T,\\ (I_{t_0} - I_1)/N \\big]$：关注流行病峰值的特征（幅度和时间）以及初始增长动态。$t^\\ast$ 是峰值时间，$t_0 = \\min\\{5, T\\}$。\n-   $\\mathcal{S}_C(y) = \\big[ I_T/N,\\ \\sum_{t=1}^T I_t/(N T) \\big]$：捕捉最终状态和总体患病率。\n\n观测摘要向量 $S(y_{\\text{obs}})$ 和模拟摘要向量 $S(y_{\\text{sim}})$ 之间的距离是欧几里得距离：$d(S_{\\text{obs}}, S_{\\text{sim}}) = \\| S_{\\text{obs}} - S_{\\text{sim}} \\|_2$。\n\n**3. ABC 拒绝采样**\n\n为了近似每个摘要集的后验分布，采用了一种拒绝采样算法。步骤如下：\n1.  从均匀先验分布中总共抽取 $M=1200$ 个参数向量 $\\theta_i = (p_i, r_i)$：$p_i \\sim \\text{Uniform}[0.05, 0.50]$ 和 $r_i \\sim \\text{Uniform}[0.05, 0.40]$。\n2.  对于每个 $\\theta_i$，模拟标准 SIS 模型以生成一个合成数据集 $y_{\\text{sim}}^{(i)}$。\n3.  为模拟数据计算摘要统计量 $S(y_{\\text{sim}}^{(i)})$。\n4.  计算距离 $d_i = \\| S(y_{\\text{obs}}) - S(y_{\\text{sim}}^{(i)}) \\|_2$。\n5.  在所有 $M$ 次模拟之后，将接受容差 $\\epsilon$ 确定为计算出的距离 $\\{d_1, \\dots, d_M\\}$ 的经验 $q=0.03$ 分位数。\n6.  构成近似后验样本的接受参数集是 $\\{\\theta_i \\mid d_i \\le \\epsilon\\}$。\n\n对三个摘要集 $\\mathcal{S}_A$、$\\mathcal{S}_B$ 和 $\\mathcal{S}_C$ 中的每一个独立重复此过程。\n\n**4. 模型设定错误诊断**\n\n有了三个近似后验样本，我们为每个摘要集 $S \\in \\{A, B, C\\}$ 计算后验均值向量 $\\mu^{(S)}$ 和后验分量标准差向量 $\\sigma^{(S)}$。后验均值之间相对于后验不确定性的显著偏移表明模型设定错误。这由诊断指标 $S^\\ast$ 来量化。\n\n-   首先，我们找到后验均值之间的最大成对欧几里得距离：\n    $$ \\Delta_{\\max} = \\max\\left\\{ \\left\\| \\mu^{(A)} - \\mu^{(B)} \\right\\|_2,\\ \\left\\| \\mu^{(A)} - \\mu^{(C)} \\right\\|_2,\\ \\left\\| \\mu^{(B)} - \\mu^{(C)} \\right\\|_2 \\right\\} $$\n-   接下来，我们通过平均标准差向量的欧几里得范数来计算平均后验变异性的度量：\n    $$ \\bar{\\sigma} = \\frac{1}{3}\\left( \\|\\sigma^{(A)}\\|_2 + \\|\\sigma^{(B)}\\|_2 + \\|\\sigma^{(C)}\\|_2 \\right) $$\n-   归一化偏移是这两个量的比率：\n    $$ S^\\ast = \\frac{\\Delta_{\\max}}{\\bar{\\sigma}} $$\n-   如果 $S^\\ast$ 超过预定义的阈值 $\\tau=1.25$，则模型被声明为设定错误。这个阈值意味着后验位置之间的最大偏移至少是后验不确定性平均尺度的 $1.25$ 倍。\n\n此程序应用于四个测试案例中的每一个。一个固定的随机种子确保了观测数据的生成和 ABC 算法内部的随机性是可复现的，从而为每个案例产生一个确定性的最终结果。预期的结果是，设定良好的案例（案例 1）和弱数据案例（案例 3）不会触发诊断，而两个设定错误的案例（案例 2 和 4）会触发诊断。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the ABC misspecification diagnostic for all test cases.\n    \"\"\"\n    RANDOM_SEED = 42\n    np.random.seed(RANDOM_SEED)\n\n    def build_lattice_adjacency(N, d):\n        \"\"\"Builds the adjacency matrix for a ring lattice.\"\"\"\n        adj_matrix = np.zeros((N, N), dtype=int)\n        for i in range(N):\n            for j in range(1, d // 2 + 1):\n                adj_matrix[i, (i - j) % N] = 1\n                adj_matrix[i, (i + j) % N] = 1\n        return adj_matrix\n\n    def run_sis_model(N, T, p, r, f0, adj_matrix, d=4, scenario_params=None):\n        \"\"\"\n        Simulates the SIS agent-based model.\n        Flexibly handles different data-generating scenarios.\n        \"\"\"\n        if scenario_params is None:\n            scenario_params = {}\n        \n        # Initial states\n        states = np.zeros(N, dtype=int)\n        num_initial_infected = round(N * f0)\n        initial_infected_indices = np.random.choice(N, num_initial_infected, replace=False)\n        states[initial_infected_indices] = 1\n        \n        infected_counts = np.zeros(T, dtype=int)\n        \n        for t in range(T):\n            # Exogenous shocks (for y_obs generation in Case 4)\n            if scenario_params.get('type') == 'shock' and t in scenario_params['times']:\n                susceptible_indices = np.where(states == 0)[0]\n                if len(susceptible_indices)  0:\n                    k = scenario_params['k']\n                    num_to_infect = min(k, len(susceptible_indices))\n                    shocked_indices = np.random.choice(susceptible_indices, num_to_infect, replace=False)\n                    states[shocked_indices] = 1\n\n            old_states = states.copy()\n            infected_neighbors = adj_matrix @ old_states\n            \n            # Determine infection probability\n            p_eff = p\n            if scenario_params.get('type') == 'threshold':\n                alpha = scenario_params['alpha']\n                m_frac = infected_neighbors / d\n                p_eff_vec = np.full(N, 0.2 * p)\n                p_eff_vec[m_frac = alpha] = p\n                prob_infection = 1 - (1 - p_eff_vec)**infected_neighbors\n            else:\n                prob_infection = 1 - (1 - p_eff)**infected_neighbors\n\n            # Stochastic updates\n            rand_inf = np.random.rand(N)\n            rand_rec = np.random.rand(N)\n\n            newly_infected = (old_states == 0)  (rand_inf  prob_infection)\n            newly_recovered = (old_states == 1)  (rand_rec  r)\n\n            states[newly_infected] = 1\n            states[newly_recovered] = 0\n            \n            infected_counts[t] = np.sum(states)\n\n        # Observation noise (for y_obs generation in Case 3)\n        if scenario_params.get('type') == 'noise':\n            noise_std = scenario_params['sigma']\n            noise = np.random.normal(0, noise_std, T)\n            infected_counts = np.round(infected_counts + noise).astype(int)\n            infected_counts = np.clip(infected_counts, 0, N)\n            \n        return infected_counts\n\n    def compute_summaries(y, N, T):\n        \"\"\"Computes the three sets of summary statistics for a given time series y.\"\"\"\n        len_y = len(y)\n        if len_y == 0:\n          y = np.zeros(1)\n        \n        # S_A: Mean, Variance, Autocorrelation\n        mean_I = np.mean(y)\n        var_I = np.var(y, ddof=1) if len_y  1 else 0.0\n        rho1 = 0.0\n        if var_I  0 and len_y  1:\n            rho1 = np.corrcoef(y[:-1], y[1:])[0, 1]\n            if np.isnan(rho1): rho1 = 0.0\n        \n        S_A = np.array([mean_I / N, var_I / (N**2), rho1])\n\n        # S_B: Peak, Time-to-peak, Initial slope\n        max_I = np.max(y) if len_y  0 else 0.0\n        t_star = (np.argmax(y) + 1) if len_y  0 else 0.0\n        t0 = min(5, T)\n        initial_slope = (y[t0 - 1] - y[0]) / N if len_y = t0 else 0.0\n        \n        S_B = np.array([max_I / N, t_star / T, initial_slope])\n\n        # S_C: Final state, Total prevalence\n        final_I = y[-1] if len_y  0 else 0.0\n        total_I = np.sum(y)\n\n        S_C = np.array([final_I / N, total_I / (N * T)])\n\n        return S_A, S_B, S_C\n\n    test_cases = [\n        {'id': 1, 'N': 30, 'T': 20, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'well_spec'}},\n        {'id': 2, 'N': 30, 'T': 20, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'threshold', 'alpha': 0.30}},\n        {'id': 3, 'N': 20, 'T': 12, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'noise', 'sigma': 2.0}},\n        {'id': 4, 'N': 30, 'T': 20, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'shock', 'times': [8, 15], 'k': 4}}\n    ]\n    \n    f0 = 0.10\n    d = 4\n    M = 1200\n    q = 0.03\n    tau = 1.25\n    prior_p_range = [0.05, 0.50]\n    prior_r_range = [0.05, 0.40]\n\n    results = []\n\n    for case in test_cases:\n        N, T = case['N'], case['T']\n        p_true, r_true = case['theta_true']\n        adj_matrix = build_lattice_adjacency(N, d)\n        \n        # 1. Generate observed data y_obs\n        y_obs = run_sis_model(N, T, p_true, r_true, f0, adj_matrix, d, case['scenario_params'])\n        S_obs_A, S_obs_B, S_obs_C = compute_summaries(y_obs, N, T)\n        \n        # 2. Run ABC sampling\n        prior_draws = np.random.rand(M, 2)\n        prior_draws[:, 0] = prior_draws[:, 0] * (prior_p_range[1] - prior_p_range[0]) + prior_p_range[0]\n        prior_draws[:, 1] = prior_draws[:, 1] * (prior_r_range[1] - prior_r_range[0]) + prior_r_range[0]\n        \n        distances_A, distances_B, distances_C = [], [], []\n\n        for i in range(M):\n            p_sim, r_sim = prior_draws[i]\n            y_sim = run_sis_model(N, T, p_sim, r_sim, f0, adj_matrix, d)\n            S_sim_A, S_sim_B, S_sim_C = compute_summaries(y_sim, N, T)\n            \n            distances_A.append(np.linalg.norm(S_obs_A - S_sim_A, 2))\n            distances_B.append(np.linalg.norm(S_obs_B - S_sim_B, 2))\n            distances_C.append(np.linalg.norm(S_obs_C - S_sim_C, 2))\n\n        distances_A = np.array(distances_A)\n        distances_B = np.array(distances_B)\n        distances_C = np.array(distances_C)\n            \n        # 3. Compute posterior statistics for each summary set\n        posterior_stats = {}\n        for S_name, distances in [('A', distances_A), ('B', distances_B), ('C', distances_C)]:\n            epsilon = np.quantile(distances, q)\n            # Handle cases where epsilon is 0 and no samples are accepted\n            if epsilon == 0:\n                accepted_mask = distances == 0\n                if not np.any(accepted_mask): # if still nothing, take the first M*q samples\n                    accepted_mask = np.argsort(distances)[:int(M*q)]\n            else:\n                accepted_mask = distances = epsilon\n\n            accepted_thetas = prior_draws[accepted_mask]\n            \n            if len(accepted_thetas)  1:\n                mu = np.mean(accepted_thetas, axis=0)\n                sigma = np.std(accepted_thetas, axis=0)\n            elif len(accepted_thetas) == 1:\n                mu = accepted_thetas[0]\n                sigma = np.zeros(2)\n            else: # No samples accepted, shouldn't happen with quantile method but as a fallback\n                mu = np.zeros(2)\n                sigma = np.zeros(2)\n            \n            posterior_stats[S_name] = {'mu': mu, 'sigma': sigma}\n\n        # 4. Compute misspecification diagnostic S*\n        mu_A, mu_B, mu_C = posterior_stats['A']['mu'], posterior_stats['B']['mu'], posterior_stats['C']['mu']\n        sigma_A, sigma_B, sigma_C = posterior_stats['A']['sigma'], posterior_stats['B']['sigma'], posterior_stats['C']['sigma']\n        \n        dist_AB = np.linalg.norm(mu_A - mu_B, 2)\n        dist_AC = np.linalg.norm(mu_A - mu_C, 2)\n        dist_BC = np.linalg.norm(mu_B - mu_C, 2)\n        \n        delta_max = max(dist_AB, dist_AC, dist_BC)\n        \n        norm_sigma_A = np.linalg.norm(sigma_A, 2)\n        norm_sigma_B = np.linalg.norm(sigma_B, 2)\n        norm_sigma_C = np.linalg.norm(sigma_C, 2)\n        \n        sigma_bar = (norm_sigma_A + norm_sigma_B + norm_sigma_C) / 3.0\n        \n        S_star = delta_max / sigma_bar if sigma_bar  0 else 0.0\n        \n        results.append(S_star = tau)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}