{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的计算方法之前，至关重要的是在简单的分析环境中掌握贝叶斯更新的基本原理。本练习将引导你使用共轭先验-似然配对，来推导一个闭式后验分布。通过这个过程，你不仅能掌握贝叶斯推断的核心机制，还能深刻理解为何这类解析解在复杂自适应系统中如此罕见，从而为近似贝叶斯计算（ABC）等方法的学习铺平道路。",
            "id": "4115316",
            "problem": "考虑在一个复杂自适应系统中校准一个简单的基于计数的子模型，其中，在已知暴露量下累积的交互事件数量被用来推断一个潜在的事件率。设 $y_{1},\\dots,y_{n}$ 表示在严格为正的暴露量 $e_{1},\\dots,e_{n}$ 下观测到的非负整数计数。假设在给定率参数 $\\lambda>0$ 的条件下，观测值是条件独立的，并使用带暴露量的泊松抽样模型对数据进行建模：\n$$\np\\left(y_{i}\\mid \\lambda\\right)=\\frac{\\left(\\lambda e_{i}\\right)^{y_{i}}\\exp\\!\\left(-\\lambda e_{i}\\right)}{y_{i}!},\\quad i=1,\\dots,n.\n$$\n为了获得一个解析上易于处理的贝叶斯校准，对 $\\lambda$ 采用形状-率参数化的伽马先验：\n$$\np\\left(\\lambda\\right)=\\frac{\\beta_{0}^{\\alpha_{0}}}{\\Gamma\\!\\left(\\alpha_{0}\\right)}\\,\\lambda^{\\alpha_{0}-1}\\exp\\!\\left(-\\beta_{0}\\lambda\\right),\\quad \\alpha_{0}>0,\\;\\beta_{0}>0.\n$$\n从贝叶斯定理以及上述似然和先验的定义出发，推导 $\\lambda$ 的闭式后验分布，并用 $\\alpha_{0}$、$\\beta_{0}$、$\\{y_{i}\\}_{i=1}^{n}$ 和 $\\{e_{i}\\}_{i=1}^{n}$ 来确定其参数。然后，用这些符号给出后验均值 $\\mathbb{E}\\!\\left[\\lambda\\mid y_{1},\\dots,y_{n}\\right]$ 的精确闭式解析表达式。您的答案应该是一个单一的解析表达式；不需要四舍五入。校准后的率参数 $\\lambda$ 的单位是“事件数/暴露单位”；请勿在表达式中包含单位。\n\n简要说明（无需计算）为什么这种共轭结构对于复杂自适应系统中的校准可能具有局限性，以及何时由于似然函数的难解性而倾向于使用近似贝叶斯计算（ABC）。最终答案必须是后验均值的精确表达式。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   观测数据：非负整数计数 $y_{1}, \\dots, y_{n}$。\n-   暴露量：严格为正的值 $e_{1}, \\dots, e_{n}$。\n-   感兴趣的参数：率参数 $\\lambda > 0$。\n-   抽样模型（似然）：给定 $\\lambda$，观测值 $y_i$ 条件独立，并服从均值为 $\\lambda e_i$ 的泊松分布。单个观测值的概率质量函数为：\n    $$\n    p\\left(y_{i}\\mid \\lambda\\right)=\\frac{\\left(\\lambda e_{i}\\right)^{y_{i}}\\exp\\!\\left(-\\lambda e_{i}\\right)}{y_{i}!}\n    $$\n-   先验分布：$\\lambda$ 的先验是一个伽马分布，其形状参数 $\\alpha_0 > 0$，率参数 $\\beta_0 > 0$。其概率密度函数为：\n    $$\n    p\\left(\\lambda\\right)=\\frac{\\beta_{0}^{\\alpha_{0}}}{\\Gamma\\!\\left(\\alpha_{0}\\right)}\\,\\lambda^{\\alpha_{0}-1}\\exp\\!\\left(-\\beta_{0}\\lambda\\right)\n    $$\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题基于标准的贝叶斯统计理论。对计数数据使用泊松似然和对率参数使用伽马先验是共轭先验设置的一个典型例子，这是贝叶斯统计中的一个基本主题。\n-   **适定性**：该问题是适定的。它要求在给定完全指定的似然和先验的情况下，推导后验分布及其均值。这种结构确保了唯一且有意义的解的存在。\n-   **客观性**：问题陈述使用了精确、形式化的数学语言，没有任何主观或模糊的术语。\n-   **完整性**：所有必要的信息（似然、先验、数据与参数之间的关系）都已提供。\n-   **一致性**：已知条件是内部一致的。变量和参数的定义域（$\\lambda>0$，$y_i \\in \\{0, 1, 2, \\dots\\}$，$e_i>0$，$\\alpha_0>0$，$\\beta_0>0$）都与泊松分布和伽马分布的定义相兼容。\n\n### 步骤 3：结论与行动\n问题有效。将提供解答。\n\n推导过程通过应用贝叶斯定理进行，该定理指出后验分布正比于似然函数与先验分布的乘积。设 $Y = (y_1, \\dots, y_n)$ 表示所有观测值的集合。\n\n$\\lambda$ 的后验分布由下式给出：\n$$\np(\\lambda \\mid Y) \\propto p(Y \\mid \\lambda) \\, p(\\lambda)\n$$\n首先，我们构造似然函数 $p(Y \\mid \\lambda)$。由于观测值 $y_i$ 的条件独立性，联合似然是各单个似然的乘积：\n$$\np(Y \\mid \\lambda) = \\prod_{i=1}^{n} p(y_i \\mid \\lambda) = \\prod_{i=1}^{n} \\frac{(\\lambda e_i)^{y_i} \\exp(-\\lambda e_i)}{y_i!}\n$$\n我们可以将依赖于 $\\lambda$ 的项与不依赖于 $\\lambda$ 的项分开。\n$$\np(Y \\mid \\lambda) = \\left( \\prod_{i=1}^{n} \\frac{e_i^{y_i}}{y_i!} \\right) \\left( \\prod_{i=1}^{n} \\lambda^{y_i} \\exp(-\\lambda e_i) \\right)\n$$\n合并第二个括号内的项：\n$$\n\\prod_{i=1}^{n} \\lambda^{y_i} \\exp(-\\lambda e_i) = \\lambda^{\\sum_{i=1}^{n} y_i} \\exp\\left(-\\lambda \\sum_{i=1}^{n} e_i\\right)\n$$\n由于我们关心的是 $\\lambda$ 的后验分布的形状，我们可以将任何不涉及 $\\lambda$ 的项视为归一化常数的一部分。因此，似然函数正比于：\n$$\np(Y \\mid \\lambda) \\propto \\lambda^{\\sum_{i=1}^{n} y_i} \\exp\\left(-\\lambda \\sum_{i=1}^{n} e_i\\right)\n$$\n接下来，我们考虑先验分布，它是一个伽马分布 $\\text{Gamma}(\\alpha_0, \\beta_0)$：\n$$\np(\\lambda) = \\frac{\\beta_{0}^{\\alpha_{0}}}{\\Gamma(\\alpha_{0})} \\lambda^{\\alpha_{0}-1} \\exp(-\\beta_{0}\\lambda)\n$$\n先验分布的核（依赖于 $\\lambda$ 的部分）是：\n$$\np(\\lambda) \\propto \\lambda^{\\alpha_{0}-1} \\exp(-\\beta_{0}\\lambda)\n$$\n现在，我们将似然核与先验核相乘以求得后验核：\n$$\np(\\lambda \\mid Y) \\propto \\left( \\lambda^{\\sum_{i=1}^{n} y_i} \\exp\\left(-\\lambda \\sum_{i=1}^{n} e_i\\right) \\right) \\cdot \\left( \\lambda^{\\alpha_{0}-1} \\exp(-\\beta_{0}\\lambda) \\right)\n$$\n通过相加指数来合并项：\n$$\np(\\lambda \\mid Y) \\propto \\lambda^{\\left(\\alpha_{0} - 1\\right) + \\sum_{i=1}^{n} y_i} \\exp\\left(-\\beta_{0}\\lambda - \\lambda \\sum_{i=1}^{n} e_i\\right)\n$$\n$$\np(\\lambda \\mid Y) \\propto \\lambda^{\\left(\\alpha_{0} + \\sum_{i=1}^{n} y_i\\right) - 1} \\exp\\left(-\\left(\\beta_{0} + \\sum_{i=1}^{n} e_i\\right)\\lambda\\right)\n$$\n这个结果的函数形式是一个伽马分布的核。一个服从形状参数为 $\\alpha$ 和率参数为 $\\beta$ 的伽马分布的随机变量 $X$，记作 $X \\sim \\text{Gamma}(\\alpha, \\beta)$，其概率密度函数正比于 $x^{\\alpha-1}\\exp(-\\beta x)$。\n\n通过将我们的后验核与标准伽马核进行比较，我们可以确定后验分布的参数。设后验分布是一个形状参数为 $\\alpha_n$ 和率参数为 $\\beta_n$ 的伽马分布。那么：\n$$\n\\alpha_n = \\alpha_0 + \\sum_{i=1}^{n} y_i\n$$\n$$\n\\beta_n = \\beta_0 + \\sum_{i=1}^{n} e_i\n$$\n因此，$\\lambda$ 的后验分布是一个具有这些更新后参数的伽马分布：\n$$\n\\lambda \\mid Y \\sim \\text{Gamma}\\left(\\alpha_0 + \\sum_{i=1}^{n} y_i, \\beta_0 + \\sum_{i=1}^{n} e_i\\right)\n$$\n形状参数为 $\\alpha$、率参数为 $\\beta$ 的伽马分布的均值由比率 $\\frac{\\alpha}{\\beta}$ 给出。因此，$\\lambda$ 的后验均值，记作 $\\mathbb{E}[\\lambda \\mid Y]$，是：\n$$\n\\mathbb{E}[\\lambda \\mid y_1, \\dots, y_n] = \\frac{\\alpha_n}{\\beta_n} = \\frac{\\alpha_0 + \\sum_{i=1}^{n} y_i}{\\beta_0 + \\sum_{i=1}^{n} e_i}\n$$\n\n关于这种共轭结构对于复杂自适应系统（CAS）的局限性：这种方法的前提是能够写出并评估一个解析的似然函数 $p(y \\mid \\lambda)$。在许多 CAS 模型中，例如基于主体的模型或大规模网络模拟，模型参数（$\\theta$）与可观测输出（$y$）之间的关系是由一个复杂的、随机的模拟过程定义的。因此，似然函数 $p(y \\mid \\theta)$ 是难解的，意味着它不能以闭式解析形式表达或评估。该模型充当一个黑箱模拟器。\n\n在这种情况下，近似贝叶斯计算（ABC）之所以更受青睐，正是因为它避免了评估似然函数的需要。ABC 通过在不同的参数设置下从模型中模拟合成数据集，并接受那些能生成与观测数据“接近”的合成数据的参数值，来进行“无似然”推断。这使得对那些似然函数难解的模型进行贝叶斯校准成为可能，而这正是复杂自适应系统的一个共同特征。",
            "answer": "$$\n\\boxed{\\frac{\\alpha_{0} + \\sum_{i=1}^{n} y_{i}}{\\beta_{0} + \\sum_{i=1}^{n} e_{i}}}\n$$"
        },
        {
            "introduction": "获得后验分布并非分析的终点；我们还必须检验模型是否充分描述了观测数据。本练习介绍了一种强大的模型批判工具——后验预测检验（PPC）。通过推导一个摘要统计量的预测分布，你将学会如何量化和解释模型预测与实际观测之间的差异，这是评估和改进模型的关键一步。",
            "id": "4115312",
            "problem": "考虑一个复杂自适应系统中的基于智能体的传染病模型，其中每日新增病例被汇总为计数时间序列。令 $y = (y_{1}, \\dots, y_{n})$ 表示在给定一个潜在速率参数 $\\lambda$ 的情况下，$n$ 个条件独立的每日计数值，其生成模型为 $y_{i} \\mid \\lambda \\sim \\text{Poisson}(\\lambda)$，其中 $i = 1, \\dots, n$。假设使用近似贝叶斯计算 (Approximate Bayesian Computation, ABC) 进行了校准，得到了在给定观测数据 $y^{\\text{obs}}$ 的情况下 $\\lambda$ 的近似贝叶斯后验，其形式为比率参数化的 $\\lambda \\mid y^{\\text{obs}} \\sim \\text{Gamma}(\\alpha, \\beta)$，密度为 $p(\\lambda \\mid y^{\\text{obs}}) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} \\lambda^{\\alpha - 1} \\exp(-\\beta \\lambda)$，其中 $\\lambda > 0$，$\\alpha > 0$ 且 $\\beta > 0$。定义汇总统计量 $s(y) = \\frac{1}{n} \\sum_{i=1}^{n} y_{i}$，即每日平均计数值。\n\n仅使用后验预测分布 $p(y_{\\text{new}} \\mid y^{\\text{obs}}) = \\int p(y_{\\text{new}} \\mid \\theta) p(\\theta \\mid y^{\\text{obs}}) \\, d\\theta$ 的基本定义以及全期望定律和全方差定律，推导后验预测均值 $\\mu_{s} = \\mathbb{E}[s(Y_{\\text{new}}) \\mid y^{\\text{obs}}]$ 和方差 $\\sigma_{s}^{2} = \\operatorname{Var}(s(Y_{\\text{new}}) \\mid y^{\\text{obs}})$ 关于 $\\alpha$、$\\beta$ 和 $n$ 的闭式解析表达式。然后，在后验预测检查下，解释如果观测到的汇总统计量 $s(y^{\\text{obs}})$ 满足 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s} \\approx 2$ 意味着什么。\n\n精确表达最终的解析表达式，无需四舍五入。最终答案必须以包含 $\\mu_{s}$ 和 $\\sigma_{s}^{2}$ 的双元素行矩阵形式给出，并按此顺序排列。",
            "solution": "### 第 1 步：提取已知条件\n- **生成过程**：$n$ 个条件独立的每日计数值 $y = (y_1, \\dots, y_n)$，其中 $y_i \\mid \\lambda \\sim \\text{Poisson}(\\lambda)$，$i=1, \\dots, n$。\n- **观测数据**：$y^{\\text{obs}}$。\n- **近似后验分布**：给定观测数据 $y^{\\text{obs}}$，速率参数 $\\lambda$ 的后验分布近似为 $\\lambda \\mid y^{\\text{obs}} \\sim \\text{Gamma}(\\alpha, \\beta)$ (比率参数化)。\n- **后验密度**：$p(\\lambda \\mid y^{\\text{obs}}) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} \\lambda^{\\alpha - 1} \\exp(-\\beta \\lambda)$，其中 $\\lambda > 0$，$\\alpha > 0$，$\\beta > 0$。\n- **汇总统计量**：$s(y) = \\frac{1}{n} \\sum_{i=1}^{n} y_{i}$。\n- **后验预测分布定义**：$p(y_{\\text{new}} \\mid y^{\\text{obs}}) = \\int p(y_{\\text{new}} \\mid \\theta) p(\\theta \\mid y^{\\text{obs}}) \\, d\\theta$。\n- **所需工具**：全期望定律和全方差定律。\n- **目标**：\n    1.  推导后验预测均值 $\\mu_{s} = \\mathbb{E}[s(Y_{\\text{new}}) \\mid y^{\\text{obs}}]$ 和方差 $\\sigma_{s}^{2} = \\operatorname{Var}(s(Y_{\\text{new}}) \\mid y^{\\text{obs}})$ 的闭式解析表达式。\n    2.  解释 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s} \\approx 2$ 的含义。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准评估此问题。\n- **科学依据**：该问题很好地植根于贝叶斯统计和概率论的原理。对计数数据使用泊松模型，使用伽马分布作为速率参数的后验分布（它是共轭先验，使其成为一种合理的后验形式），以及后验预测检查的概念，这些都是现代统计建模的标准元素。\n- **适定性**：该问题是适定的。它提供了所有必要的信息（生成模型、后验形式、汇总统计量），以唯一确定所要求的量（$\\mu_s$ 和 $\\sigma_s^2$）。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有主观论断或歧义。\n- **完整性与一致性**：设置是完整的且内部一致。没有信息缺失或相互矛盾。\n- **主题相关性**：该问题直接且相关地定位于*复杂自适应系统建模*的*贝叶斯校准与近似贝叶斯计算 (ABC)*这一特定主题内。\n\n该问题未表现出验证清单中列出的任何缺陷。\n\n### 第 3 步：结论与行动\n该问题有效。现在开始求解过程。\n\n### 后验预测均值与方差的推导\n\n令 $Y_{\\text{new}} = (Y_{\\text{new},1}, \\dots, Y_{\\text{new},n})$ 为一个从模型生成的新复制数据集，其中 $Y_{\\text{new},i} \\mid \\lambda \\sim \\text{Poisson}(\\lambda)$。这个新数据集的汇总统计量是 $s(Y_{\\text{new}}) = \\frac{1}{n} \\sum_{i=1}^{n} Y_{\\text{new},i}$。我们需要求出这个统计量在 $\\lambda$ 的后验分布下的均值和方差。对 $y^{\\text{obs}}$ 的条件是隐含在使用后验 $p(\\lambda \\mid y^{\\text{obs}})$ 中的。\n\n**1. 后验预测均值 $\\mu_s$**\n\n我们使用全期望定律：$\\mathbb{E}[X] = \\mathbb{E}[\\mathbb{E}[X \\mid Z]]$。令 $X = s(Y_{\\text{new}})$ 且 $Z = \\lambda$。\n$$\n\\mu_s = \\mathbb{E}[s(Y_{\\text{new}}) \\mid y^{\\text{obs}}] = \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}} \\left[ \\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda, y^{\\text{obs}}] \\right]\n$$\n给定 $\\lambda$，新数据 $Y_{\\text{new}}$ 的生成与观测数据 $y^{\\text{obs}}$ 无关。因此，$\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda, y^{\\text{obs}}] = \\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda]$。\n\n首先，我们求出以 $\\lambda$ 为条件的内部期望：\n$$\n\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda] = \\mathbb{E}\\left[\\frac{1}{n} \\sum_{i=1}^{n} Y_{\\text{new},i} \\mid \\lambda \\right]\n$$\n根据期望的线性性质：\n$$\n\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda] = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbb{E}[Y_{\\text{new},i} \\mid \\lambda]\n$$\n对于一个泊松随机变量 $Y_{\\text{new},i} \\sim \\text{Poisson}(\\lambda)$，其期望为 $\\mathbb{E}[Y_{\\text{new},i} \\mid \\lambda] = \\lambda$。因此：\n$$\n\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda] = \\frac{1}{n} \\sum_{i=1}^{n} \\lambda = \\frac{n\\lambda}{n} = \\lambda\n$$\n现在，我们对这个结果关于 $\\lambda$ 的后验分布（即 $\\lambda \\mid y^{\\text{obs}} \\sim \\text{Gamma}(\\alpha, \\beta)$）求期望。\n$$\n\\mu_s = \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}[\\lambda]\n$$\n形状为 $\\alpha$、速率为 $\\beta$ 的伽马分布的均值为 $\\frac{\\alpha}{\\beta}$。\n$$\n\\mu_s = \\frac{\\alpha}{\\beta}\n$$\n\n**2. 后验预测方差 $\\sigma_s^2$**\n\n我们使用全方差定律：$\\operatorname{Var}(X) = \\mathbb{E}[\\operatorname{Var}(X \\mid Z)] + \\operatorname{Var}(\\mathbb{E}[X \\mid Z])$。同样，令 $X = s(Y_{\\text{new}})$ 且 $Z = \\lambda$。\n$$\n\\sigma_s^2 = \\operatorname{Var}(s(Y_{\\text{new}}) \\mid y^{\\text{obs}}) = \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}[\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda)] + \\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda])\n$$\n我们需要计算右侧的两项。\n\n对于第一项，我们从以 $\\lambda$ 为条件的内部方差开始：\n$$\n\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda) = \\operatorname{Var}\\left(\\frac{1}{n} \\sum_{i=1}^{n} Y_{\\text{new},i} \\mid \\lambda\\right)\n$$\n由于给定 $\\lambda$，$Y_{\\text{new},i}$ 是条件独立的：\n$$\n\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda) = \\frac{1}{n^2} \\sum_{i=1}^{n} \\operatorname{Var}(Y_{\\text{new},i} \\mid \\lambda)\n$$\n泊松随机变量 $Y_{\\text{new},i} \\sim \\text{Poisson}(\\lambda)$ 的方差是 $\\operatorname{Var}(Y_{\\text{new},i} \\mid \\lambda) = \\lambda$。\n$$\n\\operatorname{Var}(s(Y_{\\text{new}}) \\mid \\lambda) = \\frac{1}{n^2} \\sum_{i=1}^{n} \\lambda = \\frac{n\\lambda}{n^2} = \\frac{\\lambda}{n}\n$$\n现在我们对这个量关于 $\\lambda$ 的后验分布求期望：\n$$\n\\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}\\left[\\frac{\\lambda}{n}\\right] = \\frac{1}{n} \\mathbb{E}_{\\lambda \\mid y^{\\text{obs}}}[\\lambda] = \\frac{1}{n} \\frac{\\alpha}{\\beta}\n$$\n这是第一项。\n\n对于第二项，我们需要我们之前求出的条件期望的方差：\n$$\n\\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\mathbb{E}[s(Y_{\\text{new}}) \\mid \\lambda]) = \\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\lambda)\n$$\n这恰好是 $\\lambda$ 的后验分布 $\\text{Gamma}(\\alpha, \\beta)$ 的方差。形状为 $\\alpha$、速率为 $\\beta$ 的伽马分布的方差是 $\\frac{\\alpha}{\\beta^2}$。\n$$\n\\operatorname{Var}_{\\lambda \\mid y^{\\text{obs}}}(\\lambda) = \\frac{\\alpha}{\\beta^2}\n$$\n这是第二项。\n\n最后，我们将两项相加得到总的后验预测方差：\n$$\n\\sigma_s^2 = \\frac{\\alpha}{n\\beta} + \\frac{\\alpha}{\\beta^2}\n$$\n通分合并：\n$$\n\\sigma_s^2 = \\frac{\\alpha\\beta}{n\\beta^2} + \\frac{\\alpha n}{n\\beta^2} = \\frac{\\alpha\\beta + \\alpha n}{n\\beta^2} = \\frac{\\alpha(n + \\beta)}{n\\beta^2}\n$$\n\n### 后验预测检查的解释\n\n将观测数量与其后验预测分布进行比较的过程称为后验预测检查 (posterior predictive check, PPC)。这是一种评估贝叶斯模型拟合优度的方法。数量 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s}$ 是一个标准化的差异度量。它量化了观测到的汇总统计量 $s(y^{\\text{obs}})$ 偏离复制的汇总统计量分布均值 $\\mu_s$ 的标准差倍数。\n\n如果 $|s(y^{\\text{obs}}) - \\mu_{s}| / \\sigma_{s} \\approx 2$，这意味着观测到的每日平均计数值大约偏离该统计量的后验预测分布中心两个标准差。在频率派假设检验中，z-score 为 2 通常被认为是统计显著性的一个阈值（例如，在双尾检验中，假设分布近似正态，显著性水平 $\\alpha \\approx 0.05$）。\n\n在贝叶斯背景下，这个结果将被解释为模型与数据之间存在显著的不一致，这种不一致是相对于汇总统计量 $s(y)$ 所捕捉的特征而言的。由后验预测分布表征的模型生成数据，通常不会产生像实际数据中观测到的那样极端的均值。观测到的均值位于预测分布的尾部，表明在拟合模型下它是一个不太可能出现的结果。\n\n这种差异表明模型可能存在设定错误。模型未能复制观测数据的一个关键特征。导致这种失败的可能原因包括：\n1.  **错误的生成模型**：泊松分布的假设可能是错误的。例如，现实世界的传染病数据经常表现出过度离散（方差大于均值），而泊松模型（$Var(y) = E[y]$）无法解释这一点。负二项模型可能更合适。\n2.  **糟糕的 ABC 近似**：由 ABC 算法产生的近似后验 $\\text{Gamma}(\\alpha, \\beta)$ 可能不是真实后验分布的忠实表示。\n3.  **不充分的先验**：贝叶斯分析中使用的先验分布（它隐含地成为导致后验计算的一部分）可能不合适，对真实参数值赋予了过少的概率质量。\n\n总之，标准化差异值约为 2 是一个强烈的信号，表明应严格审查、修正模型，并可能用一个更合适的模型来替代它。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\alpha}{\\beta} & \\frac{\\alpha(n+\\beta)}{n\\beta^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "最后的这项实践将所有概念应用于一个真实场景：校准一个似然函数难以处理的基于主体的模型（ABM）。你将亲手实现一个ABC算法，并运用一种精密的诊断技术——比较由不同摘要统计量得出的后验分布——来探查模型的设定错误。这项练习将让你在校准和批判复杂自适应系统模型的完整工作流程中，获得宝贵的实践经验。",
            "id": "4115335",
            "problem": "考虑一个复杂自适应系统中的基于主体的易感-感染-易感模型，该系统包含一个环形格点上的 $N$ 个主体，格点度 $d=4$（每个主体与其两个最近邻和两个次近邻相连）。在时间 $t$，每个主体要么是易感状态，要么是感染状态。一个有 $m$ 个受感染邻居的易感主体在下一个时间步以概率 $$1 - (1 - p)^{m}$$ 被感染，而一个受感染的主体以概率 $r$ 恢复，且恢复事件相互独立。令 $\\theta = (p, r)$ 表示模型参数。令初始感染主体比例为 $f_0$，系统演化 $T$ 个离散时间步。观测数据是随时间变化的感染数量的时间序列，表示为 $y_{\\text{obs}} = (I_1, I_2, \\dots, I_T)$，其中 $I_t$ 是时间 $t$ 的感染主体数量。\n\n贝叶斯校准通过贝叶斯法则寻求后验分布 $p(\\theta \\mid y_{\\text{obs}})$：$$p(\\theta \\mid y_{\\text{obs}}) \\propto p(y_{\\text{obs}} \\mid \\theta)\\,p(\\theta),$$ 但对于复杂自适应系统，似然函数 $p(y_{\\text{obs}} \\mid \\theta)$ 通常是难以处理的。近似贝叶斯计算 (ABC) 通过比较模拟数据的摘要统计量与观测数据的摘要统计量来近似后验分布，并接受那些能产生足够接近的摘要统计量的参数。具体来说，令 $S(y)$ 表示数据 $y$ 的摘要统计量向量，并定义观测摘要向量与在参数 $\\theta$ 下模拟的数据 $y_{\\text{sim}}$ 的摘要向量之间的距离 $d(S(y_{\\text{obs}}), S(y_{\\text{sim}}))$。给定一个容差 $\\epsilon$，ABC拒绝后验是在先验 $p(\\theta)$ 下，以 $d(S(y_{\\text{obs}}), S(y_{\\text{sim}})) \\le \\epsilon$ 为条件的 $\\theta$ 的分布。\n\n为了诊断模型设定错误，可以比较在不同摘要统计量集下获得的ABC后验分布。ABC后验分布在不同摘要统计量集之间的系统性偏移可能表明模型未能共同解释观测数据的不同方面，从而暗示了模型设定错误。\n\n你的任务是通过计算三种不同摘要统计量集下的ABC后验分布，并量化其后验均值之间相对于后验变异性的系统性偏移，来实现一个ABC模型设定错误诊断。\n\n使用的基本原理和定义：\n- 贝叶斯法则：$p(\\theta \\mid y) \\propto p(y \\mid \\theta) p(\\theta)$。\n- 近似贝叶斯计算 (ABC)：如果对于一个选定的或数据自适应的容差 $\\epsilon$，满足 $d(S(y_{\\text{obs}}), S(y_{\\text{sim}})) \\le \\epsilon$，则接受 $\\theta$。\n- 在指定参数域上的均匀先验下的拒绝采样。\n- 如上所述的基于主体的易感-感染-易感动态。\n\n实现以下内容：\n1. 先验和参数域。对 $\\theta = (p, r)$ 使用均匀先验，其中 $p \\sim \\text{Uniform}[0.05, 0.50]$ 且 $r \\sim \\text{Uniform}[0.05, 0.40]$。\n2. ABC采样。使用拒绝ABC法，从先验中进行 $M = 1200$ 次独立参数抽取。对于每次抽取，模拟模型 $T$ 步，并计算模拟摘要向量与观测摘要向量之间的距离。将容差 $\\epsilon$ 定义为距离的经验 $q$-分位数，其中 $q = 0.03$，以便大约接受最好的 $3\\%$ 的参数抽取。\n3. 用于ABC后验计算的模拟模型。ABC后验必须使用指定的易感-感染-易感动态进行计算，其感染概率为 $1 - (1 - p)^m$，恢复概率为 $r$。\n4. 摘要统计量集。使用以下每个摘要统计量集计算ABC后验。对于所有摘要统计量，按规定用 $N$ 和 $T$ 进行归一化，以使各分量无量纲且可比较：\n   - 摘要统计量集 $\\mathcal{S}_A(y) = \\big[ \\overline{I}/N,\\ \\mathrm{Var}(I)/N^2,\\ \\rho_1 \\big]$，其中 $\\overline{I}$ 是 $I_t$ 在 $t=1,\\dots,T$ 上的均值，$\\mathrm{Var}(I)$ 是 $I_t$ 随时间的样本方差，$\\rho_1$ 是 $I_t$ 随时间的滞后1阶自相关（如果方差为零，则定义 $\\rho_1 = 0$）。\n   - 摘要统计量集 $\\mathcal{S}_B(y) = \\big[ \\max_t I_t/N,\\ t^\\ast/T,\\ (I_{t_0} - I_1)/N \\big]$，其中 $t^\\ast$ 是感染峰值计数的时间索引，$t_0 = \\min\\{5, T\\}$ 是一个用于近似初始斜率的早期小时间索引。\n   - 摘要统计量集 $\\mathcal{S}_C(y) = \\big[ I_T/N,\\ \\sum_{t=1}^T I_t/(N T) \\big]$，即最终感染比例和随时间的平均感染比例。\n5. 距离函数。对于任何摘要向量 $S = (s_1, \\dots, s_k)$，使用欧几里得距离 $$d(S(y_{\\text{obs}}), S(y_{\\text{sim}})) = \\left\\| S(y_{\\text{obs}}) - S(y_{\\text{sim}}) \\right\\|_2.$$\n6. 后验均值和变异性。对于每个摘要统计量集，计算 $\\theta$ 的后验均值 $\\mu^{(A)}$、$\\mu^{(B)}$、$\\mu^{(C)}$ 和后验标准差 $\\sigma^{(A)}$、$\\sigma^{(B)}$、$\\sigma^{(C)}$，其中标准差是针对 $p$ 和 $r$ 分量计算的。令 $\\|\\sigma^{(S)}\\|_2$ 表示摘要集 $S$ 的后验标准差向量的欧几里得范数。\n7. 模型设定错误诊断。定义最大成对后验均值距离 $$\\Delta_{\\max} = \\max\\left\\{ \\left\\| \\mu^{(A)} - \\mu^{(B)} \\right\\|_2,\\ \\left\\| \\mu^{(A)} - \\mu^{(C)} \\right\\|_2,\\ \\left\\| \\mu^{(B)} - \\mu^{(C)} \\right\\|_2 \\right\\}.$$ 定义平均后验变异性 $$\\bar{\\sigma} = \\frac{1}{3}\\left( \\|\\sigma^{(A)}\\|_2 + \\|\\sigma^{(B)}\\|_2 + \\|\\sigma^{(C)}\\|_2 \\right).$$ 计算归一化偏移 $$S^\\ast = \\frac{\\Delta_{\\max}}{\\bar{\\sigma}}.$$ 如果 $S^\\ast \\ge \\tau$ 且阈值 $\\tau = 1.25$，则声明模型设定错误。\n8. 随机性控制。使用固定的随机种子，以确保结果是可复现的。\n\n测试套件的观测数据生成：\n- 在设定正确的场景中，使用第3项中描述的相同模拟模型，以指定的真实参数生成 $y_{\\text{obs}}$，且不添加额外噪声。\n- 在设定错误的场景中，使用违反ABC模拟模型假设的机制生成 $y_{\\text{obs}}$，以引发依赖于摘要统计量的系统性后验偏移，具体如下所述。\n- 在弱数据场景中，包含观测噪声以降低信息量。\n\n测试套件。对于每个测试用例，使用初始感染比例 $f_0 = 0.10$ 和度 $d=4$。详细的测试用例是：\n1. 案例1（设定正确的基准）：$N = 30$, $T = 20$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用指定的易感-感染-易感动态生成，无观测噪声。\n2. 案例2（阈值设定错误）：$N = 30$, $T = 20$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用ABC模拟模型中不存在的阈值传染效应生成：对于一个易感主体，如果其受感染邻居的比例 $m/d$ 至少为 $\\alpha = 0.30$，则使用感染参数 $p_{\\text{eff}} = p$；否则使用 $p_{\\text{eff}} = 0.20\\,p$。感染概率为 $1 - (1 - p_{\\text{eff}})^{m}$，恢复概率仍为 $r$。\n3. 案例3（弱信息数据）：$N = 20$, $T = 12$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用指定的易感-感染-易感动态生成，并对每个 $I_t$ 应用附加的零均值高斯观测噪声，标准差为 $\\sigma = 2$，然后四舍五入到最近的整数并裁剪到区间 $[0, N]$ 内。\n4. 案例4（外源性冲击设定错误）：$N = 30$, $T = 20$，真实参数 $\\theta^\\dagger = (0.25, 0.15)$。观测数据使用指定的易感-感染-易感动态生成，并在时间 $t = 8$ 和 $t = 15$ 时引入外源性冲击，这些冲击在那些时刻瞬间感染 $k = 4$ 个随机选择的易感主体；此机制在ABC模拟模型中不存在。\n\n算法要求：\n- 实现基于主体的模拟，并对主体进行向量化更新以提高计算效率。\n- 对所有摘要统计量集和测试用例使用相同的ABC采样过程，并采用上述指定的先验、$M$、$q$ 和容差规则。\n- 使用固定的随机种子以保证可复现性。\n\n输出规范：\n- 对于4个测试用例中的每一个，计算模型设定错误诊断的布尔值：如果 $S^\\ast \\ge \\tau$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例1到4的顺序排列结果。例如，输出格式为 $\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\big]$，其中每个 $\\text{result}_i$ 为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "该问题要求使用近似贝叶斯计算（ABC）为一个基于主体的模型实现模型设定错误诊断。该诊断依赖于量化当使用不同摘要统计量集进行近似时，后验参数估计中的系统性偏移。一个大的、统计上显著的偏移表明模型设定有误，因为它无法一致地再现数据的不同可观测特征。\n\n对问题陈述的验证确认了其科学性、良定性和完整性。它描述了一个标准的基于主体的易感-感染-易感（SIS）模型，并使用了计算统计学（ABC）和模型检验中的既定方法。所有参数、算法和测试用例都得到了明确无误的定义，从而可以进行直接且可验证的实现。\n\n解决方案首先按规定构建必要的计算组件，然后将它们应用于四个测试用例。核心组件是：\n1.  一个SIS模型的基于主体的模拟。\n2.  用于计算三个不同摘要统计量集的函数。\n3.  一个ABC拒绝采样算法，用于近似后验分布 $p(\\theta \\mid y_{\\text{obs}})$。\n4.  一个计算模型设定错误诊断 $S^\\ast$ 的程序。\n\n**1. 基于主体的SIS模拟模型**\n\n该系统由 $N$ 个主体组成，它们排列在一个环形格点上，每个主体都与其 $d=4$ 个邻居（每侧两个）相连。每个主体 $i$ 在离散时间 $t$ 的状态 $s_i(t)$ 可以是易感 ($s_i(t)=0$) 或感染 ($s_i(t)=1$)。系统动态由两个随机过程控制：感染和恢复。\n\n-   **感染：** 一个易感主体 $i$（$s_i(t)=0$）有 $m_i(t)$ 个受感染的邻居。它在时间 $t+1$ 以概率 $P_{\\text{inf}} = 1 - (1 - p)^{m_i(t)}$ 被感染，其中 $p$ 是每次接触的传播概率。该公式假设感染可以独立地从任何一个受感染的邻居发生。\n-   **恢复：** 一个感染主体 $i$（$s_i(t)=1$）在时间 $t+1$ 以恒定的概率 $r$ 恢复并再次变为易感状态。\n\n因此，模型参数是向量 $\\theta = (p, r)$。模拟从一个初始比例为 $f_0$ 的随机选择的感染主体开始，并演化 $T$ 个时间步。为了提高效率，模拟使用向量化操作实现。邻里结构被预先计算为一个邻接矩阵 $\\mathbf{A}$，其中如果主体 $i$ 和 $j$ 是邻居，则 $\\mathbf{A}_{ij} = 1$，否则为 $0$。在每个时间步 $t$，所有主体的受感染邻居计数的向量通过 $\\mathbf{m}(t) = \\mathbf{A}\\mathbf{s}(t)$ 计算得出，其中 $\\mathbf{s}(t)$ 是所有主体的状态向量。基于时间 $t$ 的状态执行同步更新以确定时间 $t+1$ 的状态。\n\n为了在设定错误和有噪声的场景中生成观测数据 $y_{\\text{obs}}$，根据测试用例的规范对这个核心模拟进行了修改：\n-   **案例2（阈值设定错误）：** 感染参数 $p$ 被一个有效参数 $p_{\\text{eff}}$ 替代，该参数取决于局部感染密度。如果一个主体的受感染邻居比例 $m/d \\ge \\alpha=0.30$，则 $p_{\\text{eff}}=p$；否则，$p_{\\text{eff}} = 0.20p$。然而，ABC推断算法并不知道这一机制，而是使用更简单的标准SIS模型。\n-   **案例3（弱信息数据）：** 真实的感染计数 $I_t$ 被均值为 $0$、标准差为 $\\sigma=2$ 的附加高斯噪声所破坏。结果值被四舍五入到最近的整数，并被裁剪到有效范围 $[0, N]$ 内。\n-   **案例4（外源性冲击设定错误）：** 在指定的时间 $t \\in \\{8, 15\\}$，瞬间随机选择固定数量 $k=4$ 的易感主体变为感染状态。这种外部影响不属于用于ABC的标准SIS模型。\n\n**2. 摘要统计量和距离度量**\n\n似然函数 $p(y_{\\text{obs}} \\mid \\theta)$ 是难以处理的，这使得ABC方法成为必要。这涉及到用一个低维的摘要统计量向量 $S(y)$ 来替代完整的数据向量 $y = (I_1, \\dots, I_T)$。使用三个不同的摘要统计量集来探究系统动态的不同方面：\n\n-   $\\mathcal{S}_A(y) = \\big[ \\overline{I}/N,\\ \\mathrm{Var}(I)/N^2,\\ \\rho_1 \\big]$：捕捉感染计数的中心趋势、变异性和时间相关性。$\\overline{I}$ 是时间均值，$\\mathrm{Var}(I)$ 是样本方差，$\\rho_1$ 是滞后1阶自相关。\n-   $\\mathcal{S}_B(y) = \\big[ \\max_t I_t/N,\\ t^\\ast/T,\\ (I_{t_0} - I_1)/N \\big]$：关注流行病峰值的特征（幅度和时间）以及初始增长动态。$t^\\ast$ 是峰值时间，$t_0 = \\min\\{5, T\\}$。\n-   $\\mathcal{S}_C(y) = \\big[ I_T/N,\\ \\sum_{t=1}^T I_t/(N T) \\big]$：捕捉最终状态和总体患病率。\n\n观测摘要向量 $S(y_{\\text{obs}})$ 与模拟摘要向量 $S(y_{\\text{sim}})$ 之间的距离是欧几里得距离：$d(S_{\\text{obs}}, S_{\\text{sim}}) = \\| S_{\\text{obs}} - S_{\\text{sim}} \\|_2$。\n\n**3. ABC拒绝采样**\n\n为了近似每个摘要统计量集的后验分布，采用了一种拒绝采样算法。步骤如下：\n1.  从均匀先验分布中总共抽取 $M=1200$ 个参数向量 $\\theta_i = (p_i, r_i)$：$p_i \\sim \\text{Uniform}[0.05, 0.50]$ 和 $r_i \\sim \\text{Uniform}[0.05, 0.40]$。\n2.  对于每个 $\\theta_i$，模拟标准SIS模型以生成一个合成数据集 $y_{\\text{sim}}^{(i)}$。\n3.  为模拟数据计算摘要统计量 $S(y_{\\text{sim}}^{(i)})$。\n4.  计算距离 $d_i = \\| S(y_{\\text{obs}}) - S(y_{\\text{sim}}^{(i)}) \\|_2$。\n5.  在所有 $M$ 次模拟之后，将接受容差 $\\epsilon$确定为计算出的距离集合 $\\{d_1, \\dots, d_M\\}$ 的经验 $q=0.03$ 分位数。\n6.  构成近似后验样本的被接受参数集合是 $\\{\\theta_i \\mid d_i \\le \\epsilon\\}$。\n\n对三个摘要统计量集 $\\mathcal{S}_A$、$\\mathcal{S}_B$ 和 $\\mathcal{S}_C$ 中的每一个独立重复此过程。\n\n**4. 模型设定错误诊断**\n\n利用三个近似后验样本，我们为每个摘要集 $S \\in \\{A, B, C\\}$ 计算后验均值向量 $\\mu^{(S)}$ 和后验分量标准差向量 $\\sigma^{(S)}$。后验均值之间的显著偏移（相对于后验不确定性而言）表明模型设定错误。这通过诊断指标 $S^\\ast$ 来量化。\n\n-   首先，我们找到后验均值之间的最大成对欧几里得距离：\n    $$ \\Delta_{\\max} = \\max\\left\\{ \\left\\| \\mu^{(A)} - \\mu^{(B)} \\right\\|_2,\\ \\left\\| \\mu^{(A)} - \\mu^{(C)} \\right\\|_2,\\ \\left\\| \\mu^{(B)} - \\mu^{(C)} \\right\\|_2 \\right\\} $$\n-   接下来，我们通过平均标准差向量的欧几里得范数来计算平均后验变异性的度量：\n    $$ \\bar{\\sigma} = \\frac{1}{3}\\left( \\|\\sigma^{(A)}\\|_2 + \\|\\sigma^{(B)}\\|_2 + \\|\\sigma^{(C)}\\|_2 \\right) $$\n-   归一化偏移是这两个量的比值：\n    $$ S^\\ast = \\frac{\\Delta_{\\max}}{\\bar{\\sigma}} $$\n-   如果 $S^\\ast$ 超过预定义阈值 $\\tau=1.25$，则模型被判定为设定错误。这个阈值意味着后验位置之间的最大偏移至少是后验不确定性平均尺度的1.25倍。\n\n此程序应用于四个测试用例中的每一个。固定的随机种子确保了观测数据的生成和ABC算法内部的随机性是可复现的，从而为每个案例产生一个确定的最终结果。预期的结果是，设定正确的案例（案例1）和弱数据案例（案例3）不会触发诊断，而两个设定错误的案例（案例2和4）会触发诊断。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the ABC misspecification diagnostic for all test cases.\n    \"\"\"\n    RANDOM_SEED = 42\n    np.random.seed(RANDOM_SEED)\n\n    def build_lattice_adjacency(N, d):\n        \"\"\"Builds the adjacency matrix for a ring lattice.\"\"\"\n        adj_matrix = np.zeros((N, N), dtype=int)\n        for i in range(N):\n            for j in range(1, d // 2 + 1):\n                adj_matrix[i, (i - j) % N] = 1\n                adj_matrix[i, (i + j) % N] = 1\n        return adj_matrix\n\n    def run_sis_model(N, T, p, r, f0, adj_matrix, d=4, scenario_params=None):\n        \"\"\"\n        Simulates the SIS agent-based model.\n        Flexibly handles different data-generating scenarios.\n        \"\"\"\n        if scenario_params is None:\n            scenario_params = {}\n        \n        # Initial states\n        states = np.zeros(N, dtype=int)\n        num_initial_infected = round(N * f0)\n        initial_infected_indices = np.random.choice(N, num_initial_infected, replace=False)\n        states[initial_infected_indices] = 1\n        \n        infected_counts = np.zeros(T, dtype=int)\n        \n        for t in range(T):\n            # Exogenous shocks (for y_obs generation in Case 4)\n            if scenario_params.get('type') == 'shock' and t in scenario_params['times']:\n                susceptible_indices = np.where(states == 0)[0]\n                if len(susceptible_indices) > 0:\n                    k = scenario_params['k']\n                    num_to_infect = min(k, len(susceptible_indices))\n                    shocked_indices = np.random.choice(susceptible_indices, num_to_infect, replace=False)\n                    states[shocked_indices] = 1\n\n            old_states = states.copy()\n            infected_neighbors = adj_matrix @ old_states\n            \n            # Determine infection probability\n            if scenario_params.get('type') == 'threshold':\n                alpha = scenario_params['alpha']\n                m_frac = infected_neighbors / d\n                p_eff_vec = np.full(N, 0.2 * p)\n                p_eff_vec[m_frac >= alpha] = p\n                prob_infection = 1 - (1 - p_eff_vec)**infected_neighbors\n            else:\n                p_eff = p\n                prob_infection = 1 - (1 - p_eff)**infected_neighbors\n\n            # Stochastic updates\n            rand_inf = np.random.rand(N)\n            rand_rec = np.random.rand(N)\n\n            newly_infected = (old_states == 0)  (rand_inf  prob_infection)\n            newly_recovered = (old_states == 1)  (rand_rec  r)\n\n            states[newly_infected] = 1\n            states[newly_recovered] = 0\n            \n            infected_counts[t] = np.sum(states)\n\n        # Observation noise (for y_obs generation in Case 3)\n        if scenario_params.get('type') == 'noise':\n            noise_std = scenario_params['sigma']\n            noise = np.random.normal(0, noise_std, T)\n            infected_counts = np.round(infected_counts + noise).astype(int)\n            infected_counts = np.clip(infected_counts, 0, N)\n            \n        return infected_counts\n\n    def compute_summaries(y, N, T):\n        \"\"\"Computes the three sets of summary statistics for a given time series y.\"\"\"\n        len_y = len(y)\n        if len_y == 0:\n          y = np.zeros(1)\n        \n        # S_A: Mean, Variance, Autocorrelation\n        mean_I = np.mean(y)\n        var_I = np.var(y, ddof=1) if len_y > 1 else 0.0\n        rho1 = 0.0\n        if var_I > 0 and len_y > 1:\n            rho1 = np.corrcoef(y[:-1], y[1:])[0, 1]\n            if np.isnan(rho1): rho1 = 0.0\n        \n        S_A = np.array([mean_I / N, var_I / (N**2), rho1])\n\n        # S_B: Peak, Time-to-peak, Initial slope\n        max_I = np.max(y) if len_y > 0 else 0.0\n        t_star = (np.argmax(y) + 1) if len_y > 0 else 0.0\n        t0 = min(5, T)\n        initial_slope = (y[t0 - 1] - y[0]) / N if len_y >= t0 else 0.0\n        \n        S_B = np.array([max_I / N, t_star / T, initial_slope])\n\n        # S_C: Final state, Total prevalence\n        final_I = y[-1] if len_y > 0 else 0.0\n        total_I = np.sum(y)\n\n        S_C = np.array([final_I / N, total_I / (N * T)])\n\n        return S_A, S_B, S_C\n\n    test_cases = [\n        {'id': 1, 'N': 30, 'T': 20, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'well_spec'}},\n        {'id': 2, 'N': 30, 'T': 20, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'threshold', 'alpha': 0.30}},\n        {'id': 3, 'N': 20, 'T': 12, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'noise', 'sigma': 2.0}},\n        {'id': 4, 'N': 30, 'T': 20, 'theta_true': (0.25, 0.15), 'scenario_params': {'type': 'shock', 'times': [8, 15], 'k': 4}}\n    ]\n    \n    f0 = 0.10\n    d = 4\n    M = 1200\n    q = 0.03\n    tau = 1.25\n    prior_p_range = [0.05, 0.50]\n    prior_r_range = [0.05, 0.40]\n\n    results = []\n\n    for case in test_cases:\n        N, T = case['N'], case['T']\n        p_true, r_true = case['theta_true']\n        adj_matrix = build_lattice_adjacency(N, d)\n        \n        # 1. Generate observed data y_obs\n        y_obs = run_sis_model(N, T, p_true, r_true, f0, adj_matrix, d, case['scenario_params'])\n        S_obs_A, S_obs_B, S_obs_C = compute_summaries(y_obs, N, T)\n        \n        # 2. Run ABC sampling\n        prior_draws = np.random.rand(M, 2)\n        prior_draws[:, 0] = prior_draws[:, 0] * (prior_p_range[1] - prior_p_range[0]) + prior_p_range[0]\n        prior_draws[:, 1] = prior_draws[:, 1] * (prior_r_range[1] - prior_r_range[0]) + prior_r_range[0]\n        \n        distances_A, distances_B, distances_C = [], [], []\n\n        for i in range(M):\n            p_sim, r_sim = prior_draws[i]\n            y_sim = run_sis_model(N, T, p_sim, r_sim, f0, adj_matrix, d)\n            S_sim_A, S_sim_B, S_sim_C = compute_summaries(y_sim, N, T)\n            \n            distances_A.append(np.linalg.norm(S_obs_A - S_sim_A, 2))\n            distances_B.append(np.linalg.norm(S_obs_B - S_sim_B, 2))\n            distances_C.append(np.linalg.norm(S_obs_C - S_sim_C, 2))\n\n        distances_A = np.array(distances_A)\n        distances_B = np.array(distances_B)\n        distances_C = np.array(distances_C)\n            \n        # 3. Compute posterior statistics for each summary set\n        posterior_stats = {}\n        for S_name, distances in [('A', distances_A), ('B', distances_B), ('C', distances_C)]:\n            epsilon = np.quantile(distances, q)\n            # Handle cases where epsilon is 0 and no samples are accepted\n            if epsilon == 0:\n                accepted_mask = distances == 0\n                if not np.any(accepted_mask): # if still nothing, take the first M*q samples\n                    accepted_mask = np.argsort(distances)[:int(M*q)]\n            else:\n                accepted_mask = distances = epsilon\n\n            accepted_thetas = prior_draws[accepted_mask]\n            \n            if len(accepted_thetas) > 1:\n                mu = np.mean(accepted_thetas, axis=0)\n                sigma = np.std(accepted_thetas, axis=0)\n            elif len(accepted_thetas) == 1:\n                mu = accepted_thetas[0]\n                sigma = np.zeros(2)\n            else: # No samples accepted, shouldn't happen with quantile method but as a fallback\n                mu = np.zeros(2)\n                sigma = np.zeros(2)\n            \n            posterior_stats[S_name] = {'mu': mu, 'sigma': sigma}\n\n        # 4. Compute misspecification diagnostic S*\n        mu_A, mu_B, mu_C = posterior_stats['A']['mu'], posterior_stats['B']['mu'], posterior_stats['C']['mu']\n        sigma_A, sigma_B, sigma_C = posterior_stats['A']['sigma'], posterior_stats['B']['sigma'], posterior_stats['C']['sigma']\n        \n        dist_AB = np.linalg.norm(mu_A - mu_B, 2)\n        dist_AC = np.linalg.norm(mu_A - mu_C, 2)\n        dist_BC = np.linalg.norm(mu_B - mu_C, 2)\n        \n        delta_max = max(dist_AB, dist_AC, dist_BC)\n        \n        norm_sigma_A = np.linalg.norm(sigma_A, 2)\n        norm_sigma_B = np.linalg.norm(sigma_B, 2)\n        norm_sigma_C = np.linalg.norm(sigma_C, 2)\n        \n        sigma_bar = (norm_sigma_A + norm_sigma_B + norm_sigma_C) / 3.0\n        \n        S_star = delta_max / sigma_bar if sigma_bar > 0 else 0.0\n        \n        results.append(S_star >= tau)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}