{
    "hands_on_practices": [
        {
            "introduction": "在遗传编程中，确保生成的程序（即智能体规则）在语法上有效至关重要。强类型遗传编程（STGP）通过为函数和终端分配数据类型来强制执行此约束，但标准的遗传算子（如变异）可能会破坏这种类型正确性。本练习将指导您通过一个具体的计算，来量化一个“盲”点突变算子在不破坏程序类型结构的情况下产生有效后代的概率，从而加深您对类型感知算子重要性的理解。",
            "id": "4125248",
            "problem": "考虑一个强类型遗传编程（GP）系统，它在一个多类型域中演化智能体决策规则，其类型集为 $\\{\\mathsf{R}, \\mathsf{B}, \\mathsf{U}\\}$，其中 $\\mathsf{R}$ 表示实数值，$\\mathsf{B}$ 表示布尔值，$\\mathsf{U}$ 表示动作。函数和终结符库由其元数和类型签名定义如下。\n\n- 元数为 $0$ 的终结符（每个终结符只有一个输出类型）：有 $5$ 个类型为 $\\mathsf{R}$ 的终结符，$2$ 个类型为 $\\mathsf{B}$ 的终结符，以及 $3$ 个类型为 $\\mathsf{U}$ 的终结符。\n- 元数为 $1$ 的函数（每个函数有一个输入类型和一个输出类型）：有 $4$ 个签名为 $\\mathsf{R} \\to \\mathsf{R}$ 的函数，$2$ 个签名为 $\\mathsf{B} \\to \\mathsf{B}$ 的函数，$1$ 个签名为 $\\mathsf{U} \\to \\mathsf{R}$ 的函数，$1$ 个签名为 $\\mathsf{U} \\to \\mathsf{B}$ 的函数，以及 $1$ 个签名为 $\\mathsf{R} \\to \\mathsf{B}$ 的函数。\n- 元数为 $2$ 的函数（每个函数有两个有序输入和一个输出类型）：有 $3$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$ 的函数，$2$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}$ 的函数，$3$ 个签名为 $(\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$ 的函数，$1$ 个签名为 $(\\mathsf{U},\\mathsf{R}) \\to \\mathsf{U}$ 的函数，以及 $1$ 个签名为 $(\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$ 的函数。\n- 元数为 $3$ 的函数（每个函数有三个有序输入和一个输出类型）：有 $1$ 个签名为 $(\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$ 的函数，$1$ 个签名为 $(\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$ 的函数，以及 $1$ 个签名为 $(\\mathsf{B},\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$ 的函数。\n\n一个特定的类型正确的程序树（智能体规则）有 $12$ 个节点，每个节点具有以下上下文，其中每个节点的上下文由其元数 $k$、其子节点输出类型的有序元组以及其自身的输出类型组成（该输出类型与原始类型正确的树中父节点在该位置期望的输入类型匹配，如果该节点是根节点，则与程序的输出类型匹配）：\n\n- 节点 $1$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{U},\\mathsf{U})$，输出 $\\mathsf{U}$。\n- 节点 $2$：$k=1$，子节点 $(\\mathsf{U})$，输出 $\\mathsf{B}$。\n- 节点 $3$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{B}$。\n- 节点 $4$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n- 节点 $5$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{R}$。\n- 节点 $6$：$k=0$，输出 $\\mathsf{U}$。\n- 节点 $7$：$k=0$，输出 $\\mathsf{R}$。\n- 节点 $8$：$k=0$，输出 $\\mathsf{B}$。\n- 节点 $9$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n- 节点 $10$：$k=2$，子节点 $(\\mathsf{B},\\mathsf{B})$，输出 $\\mathsf{B}$。\n- 节点 $11$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{B}$。\n- 节点 $12$：$k=0$，输出 $\\mathsf{R}$。\n\n点突变定义如下：从 $12$ 个节点中均匀随机地选择一个节点，并将其符号替换为从具有相同元数 $k$ 的符号的全局库中均匀随机抽取的一个符号。树的形状以及该节点子节点的子树保持不变。该突变算子不是类型感知的；通常，替换的符号可能与子节点和父节点期望的类型兼容，也可能不兼容。\n\n使用树的强类型基础属性——全局类型正确性得以保持，当且仅当在突变节点处，替换符号的输入类型与子节点的输出类型按顺序完全匹配，并且其输出类型与父节点在该位置期望的类型（如果该节点是根节点，则为程序的输出类型）匹配——计算单次均匀随机点突变（如定义）产生一个类型正确的树的确切概率。\n\n将您的最终答案表示为一个简化的精确分数。不要四舍五入。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知信息\n\n- **类型集**：$\\{\\mathsf{R}, \\mathsf{B}, \\mathsf{U}\\}$，表示实数、布尔和动作类型。\n- **函数和终结符库**：\n    - **元数 0（终结符）**：\n        - $5$ 个类型为 $\\mathsf{R}$。\n        - $2$ 个类型为 $\\mathsf{B}$。\n        - $3$ 个类型为 $\\mathsf{U}$。\n    - **元数 1（函数）**：\n        - $4$ 个签名为 $\\mathsf{R} \\to \\mathsf{R}$。\n        - $2$ 个签名为 $\\mathsf{B} \\to \\mathsf{B}$。\n        - $1$ 个签名为 $\\mathsf{U} \\to \\mathsf{R}$。\n        - $1$ 个签名为 $\\mathsf{U} \\to \\mathsf{B}$。\n        - $1$ 个签名为 $\\mathsf{R} \\to \\mathsf{B}$。\n    - **元数 2（函数）**：\n        - $3$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n        - $2$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}$。\n        - $3$ 个签名为 $(\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$。\n        - $1$ 个签名为 $(\\mathsf{U},\\mathsf{R}) \\to \\mathsf{U}$。\n        - $1$ 个签名为 $(\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$。\n    - **元数 3（函数）**：\n        - $1$ 个签名为 $(\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$。\n        - $1$ 个签名为 $(\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n        - $1$ 个签名为 $(\\mathsf{B},\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$。\n- **程序树结构**：一个包含 $12$ 个节点的树，其上下文如下（元数 $k$，子节点的输出类型，自身的输出类型）：\n    - 节点 $1$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{U},\\mathsf{U})$，输出 $\\mathsf{U}$。\n    - 节点 $2$：$k=1$，子节点 $(\\mathsf{U})$，输出 $\\mathsf{B}$。\n    - 节点 $3$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{B}$。\n    - 节点 $4$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n    - 节点 $5$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{R}$。\n    - 节点 $6$：$k=0$，输出 $\\mathsf{U}$。\n    - 节点 $7$：$k=0$，输出 $\\mathsf{R}$。\n    - 节点 $8$：$k=0$，输出 $\\mathsf{B}$。\n    - 节点 $9$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n    - 节点 $10$：$k=2$，子节点 $(\\mathsf{B},\\mathsf{B})$，输出 $\\mathsf{B}$。\n    - 节点 $11$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{B}$。\n    - 节点 $12$：$k=0$，输出 $\\mathsf{R}$。\n- **突变算子**：\n    - 从 $12$ 个节点中均匀随机地选择一个节点。\n    - 其符号被另一个从全局库中包含所有相同元数 $k$ 的符号的子集中均匀随机抽取的符号所替换。\n- **有效性条件**：一个突变后的树是类型正确的，当且仅当替换符号的输入类型与子节点的输出类型匹配，且其输出类型与父节点期望的类型匹配。\n- **目标**：计算单次此类突变产生一个类型正确的树的确切概率。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n- **科学依据**：该问题设置在遗传编程（GP）的背景下，GP是演化计算和人工智能的一个子领域。强类型GP和点突变是该领域的标准概念。该问题是基于这些概念的一个定义明确的组合概率练习。它不含伪科学和推测。\n- **定义明确**：该问题提供了所有必要信息：完整的类型集、可用的遗传算子（终结符和函数）及其类型签名的完整清单、程序树的结构，以及对突变操作和成功（类型正确）结果条件的精确定义。这使得计算一个唯一的、精确的概率成为可能。\n- **客观性**：该问题以计算机科学和数学中常见的精确、形式化的语言陈述。它不含主观论断或歧义。\n\n该问题是概率论应用于计算机科学中特定算法的一个标准、自洽且一致的练习。它满足所有有效性标准。\n\n### 步骤 3：结论与行动\n\n问题有效。将提供解答。\n\n## 解答\n\n问题要求计算在特定的 $12$ 节点程序树上进行单次点突变后，得到一个类型正确的树的概率。突变过程涉及两个均匀随机选择：首先，从 $N=12$ 个节点中选择一个进行突变；其次，从与所选节点具有相同元数的所有符号集合中选择一个替换符号。\n\n设 $E$ 为突变产生类型正确的树的事件，设 $C_i$ 为选择节点 $i$ 进行突变的事件，其中 $i \\in \\{1, 2, \\dots, 12\\}$。由于节点是均匀随机选择的，选择任何特定节点 $i$ 的概率为 $P(C_i) = \\frac{1}{12}$。\n\n一次有效突变的总概率是每个节点上发生有效突变的概率之和，并按选择该节点的概率加权。根据全概率公式：\n$$P(E) = \\sum_{i=1}^{12} P(E | C_i) P(C_i)$$\n由于对所有 $i$ 都有 $P(C_i) = \\frac{1}{12}$，上式可简化为：\n$$P(E) = \\frac{1}{12} \\sum_{i=1}^{12} P(E | C_i)$$\n这里，$P(E | C_i)$ 是在节点 $i$ 上的突变是类型正确的概率。这种情况发生于随机选择的替换符号的类型签名与节点 $i$ 的上下文匹配时。替换符号是从库中与节点 $i$ 具有相同元数的所有符号中均匀选择的。\n\n我们首先为每个元数 $k$ 统计可用符号的总数。设 $N_k$ 为元数为 $k$ 的符号总数。\n- 元数 $k=0$：$N_0 = 5 (\\text{类型 }\\mathsf{R}) + 2 (\\text{类型 }\\mathsf{B}) + 3 (\\text{类型 }\\mathsf{U}) = 10$。\n- 元数 $k=1$：$N_1 = 4 (\\mathsf{R} \\to \\mathsf{R}) + 2 (\\mathsf{B} \\to \\mathsf{B}) + 1 (\\mathsf{U} \\to \\mathsf{R}) + 1 (\\mathsf{U} \\to \\mathsf{B}) + 1 (\\mathsf{R} \\to \\mathsf{B}) = 9$。\n- 元数 $k=2$：$N_2 = 3 ((\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}) + 2 ((\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}) + 3 ((\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}) + 1 ((\\mathsf{U},\\mathsf{R}) \\to \\mathsf{U}) + 1 ((\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}) = 10$。\n- 元数 $k=3$：$N_3 = 1 ((\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}) + 1 ((\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}) + 1 ((\\mathsf{B},\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}) = 3$。\n\n现在我们为每个节点 $i=1, \\dots, 12$ 计算 $P_i = P(E|C_i)$。$P_i$ 是具有所需类型签名的符号数量与相同元数的符号总数之比。\n\n- **节点 1**：$k=3$，签名 $(\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$。\n库中有 $1$ 个具有此签名的函数。元数为 $3$ 的函数总数为 $N_3=3$。\n$P_1 = \\frac{1}{3}$。\n\n- **节点 2**：$k=1$，签名 $\\mathsf{U} \\to \\mathsf{B}$。\n库中有 $1$ 个具有此签名的函数。元数为 $1$ 的函数总数为 $N_1=9$。\n$P_2 = \\frac{1}{9}$。\n\n- **节点 3**：$k=2$，签名 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}$。\n库中有 $2$ 个具有此签名的函数。元数为 $2$ 的函数总数为 $N_2=10$。\n$P_3 = \\frac{2}{10} = \\frac{1}{5}$。\n\n- **节点 4**：$k=2$，签名 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n库中有 $3$ 个具有此签名的函数。元数为 $2$ 的函数总数为 $N_2=10$。\n$P_4 = \\frac{3}{10}$。\n\n- **节点 5**：$k=1$，签名 $\\mathsf{R} \\to \\mathsf{R}$。\n库中有 $4$ 个具有此签名的函数。元数为 $1$ 的函数总数为 $N_1=9$。\n$P_5 = \\frac{4}{9}$。\n\n- **节点 6**：$k=0$，输出类型 $\\mathsf{U}$。\n库中有 $3$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_6 = \\frac{3}{10}$。\n\n- **节点 7**：$k=0$，输出类型 $\\mathsf{R}$。\n库中有 $5$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_7 = \\frac{5}{10} = \\frac{1}{2}$。\n\n- **节点 8**：$k=0$，输出类型 $\\mathsf{B}$。\n库中有 $2$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_8 = \\frac{2}{10} = \\frac{1}{5}$。\n\n- **节点 9**：$k=3$，签名 $(\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n库中有 $1$ 个具有此签名的函数。元数为 $3$ 的函数总数为 $N_3=3$。\n$P_9 = \\frac{1}{3}$。\n\n- **节点 10**：$k=2$，签名 $(\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$。\n库中有 $3$ 个具有此签名的函数。元数为 $2$ 的函数总数为 $N_2=10$。\n$P_{10} = \\frac{3}{10}$。\n\n- **节点 11**：$k=1$，签名 $\\mathsf{R} \\to \\mathsf{B}$。\n库中有 $1$ 个具有此签名的函数。元数为 $1$ 的函数总数为 $N_1=9$。\n$P_{11} = \\frac{1}{9}$。\n\n- **节点 12**：$k=0$，输出类型 $\\mathsf{R}$。\n库中有 $5$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_{12} = \\frac{5}{10} = \\frac{1}{2}$。\n\n现在，我们将这些概率相加：\n$$ \\sum_{i=1}^{12} P_i = P_1 + P_2 + P_3 + P_4 + P_5 + P_6 + P_7 + P_8 + P_9 + P_{10} + P_{11} + P_{12} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{1}{3} + \\frac{1}{9} + \\frac{1}{5} + \\frac{3}{10} + \\frac{4}{9} + \\frac{3}{10} + \\frac{1}{2} + \\frac{1}{5} + \\frac{1}{3} + \\frac{3}{10} + \\frac{1}{9} + \\frac{1}{2} $$\n将具有相同分母的项分组：\n$$ \\sum_{i=1}^{12} P_i = \\left(\\frac{1}{3}+\\frac{1}{3}\\right) + \\left(\\frac{1}{9}+\\frac{4}{9}+\\frac{1}{9}\\right) + \\left(\\frac{1}{5}+\\frac{1}{5}\\right) + \\left(\\frac{3}{10}+\\frac{3}{10}+\\frac{3}{10}\\right) + \\left(\\frac{1}{2}+\\frac{1}{2}\\right) $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{2}{3} + \\frac{6}{9} + \\frac{2}{5} + \\frac{9}{10} + \\frac{2}{2} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{2}{3} + \\frac{2}{3} + \\frac{2}{5} + \\frac{9}{10} + 1 $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{4}{3} + \\frac{2}{5} + \\frac{9}{10} + 1 $$\n为了对这些分数求和，我们找到一个公分母，即 $\\text{lcm}(3, 5, 10) = 30$。\n$$ \\sum_{i=1}^{12} P_i = \\frac{4 \\times 10}{3 \\times 10} + \\frac{2 \\times 6}{5 \\times 6} + \\frac{9 \\times 3}{10 \\times 3} + \\frac{30}{30} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{40}{30} + \\frac{12}{30} + \\frac{27}{30} + \\frac{30}{30} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{40 + 12 + 27 + 30}{30} = \\frac{109}{30} $$\n最后，我们计算总概率 $P(E)$：\n$$ P(E) = \\frac{1}{12} \\sum_{i=1}^{12} P_i = \\frac{1}{12} \\times \\frac{109}{30} $$\n$$ P(E) = \\frac{109}{12 \\times 30} = \\frac{109}{360} $$\n数字 $109$ 是一个质数，所以这个分数已是最简形式。",
            "answer": "$$\\boxed{\\frac{109}{360}}$$"
        },
        {
            "introduction": "评估智能体规则的性能通常依赖于随机模拟，这会导致评估结果带有噪声，从而影响我们比较不同规则优劣的可靠性。本练习将向您介绍一种强大的方差缩减技术——通用随机数（Common Random Numbers, CRN），它能显著提高模拟实验的统计效率。您将从理论上推导其优势，并学习如何设计更可靠、更高效的计算实验来对智能体策略进行比较。",
            "id": "4125227",
            "problem": "考虑一个复杂自适应系统中的两条智能体规则。对于每次运行，环境会生成外生的随机输入，建模为一个随机向量 $\\boldsymbol{\\xi}$。每条智能体规则将 $\\boldsymbol{\\xi}$ 转换为一个标量性能结果：规则 $A$ 产生 $Y_A(\\boldsymbol{\\xi})$，规则 $B$ 产生 $Y_B(\\boldsymbol{\\xi})$。假设 $Y_A(\\boldsymbol{\\xi})$ 和 $Y_B(\\boldsymbol{\\xi})$ 是具有有限方差的平方可积随机变量。目标是估计平均性能差异 $\\Delta = \\mathbb{E}[Y_A(\\boldsymbol{\\xi})] - \\mathbb{E}[Y_B(\\boldsymbol{\\xi})]$。\n\n您将比较两种实验设计：\n- 独立运行：为 $A$ 和 $B$ 使用独立的伪随机数流，从而产生 $Y_A$ 和 $Y_B$ 的独立样本。\n- 公共随机数 (CRN)：使用共享的伪随机数流，以便在每次配对运行中，$A$ 和 $B$ 都看到相同的 $\\boldsymbol{\\xi}$。\n\n仅从期望、方差、协方差、独立性的基本定义以及均值的蒙特卡洛估计器出发，推导在独立设计和 CRN 设计下均值差估计器的方差。然后，用边际方差和 CRN 设计下的相关系数，将 CRN 相对于独立运行的方差减少量表示为一个分数。您的推导必须从 $\\mathbb{E}[\\cdot]$、$\\operatorname{Var}[\\cdot]$ 和 $\\operatorname{Cov}[\\cdot]$ 的定义开始，并且必须假设在 CRN 下有 $n$ 次独立同分布的配对运行（或在独立设计下每条规则有 $n$ 次独立运行）。\n\n为了可复现性和科学真实性，请为这些智能体规则提出一种 CRN 设计，该设计能够对齐伪随机数生成器的调用，从而在每次配对运行中，$A$ 和 $B$ 之间的环境中微观层面的随机事件是同步的。您的提议必须确保当规则对 $\\boldsymbol{\\xi}$ 的反应相似时，$Y_A(\\boldsymbol{\\xi})$ 和 $Y_B(\\boldsymbol{\\xi})$ 能够实现明确定义的非负相关。\n\n您的程序必须计算并报告每个测试用例中 CRN 相对于独立运行的理论方差减少分数，定义为 $R = 1 - \\frac{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}]}{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}]}$, 以小数形式表示（不带百分号）。使用参数化 $(\\sigma_A^2, \\sigma_B^2, \\rho, n)$，其中 $\\sigma_A^2 = \\operatorname{Var}[Y_A(\\boldsymbol{\\xi})]$，$\\sigma_B^2 = \\operatorname{Var}[Y_B(\\boldsymbol{\\xi})]$，$\\rho$ 是 CRN 设计下的相关系数 $\\rho = \\frac{\\operatorname{Cov}[Y_A(\\boldsymbol{\\xi}), Y_B(\\boldsymbol{\\xi})]}{\\sigma_A \\sigma_B}$，而 $n$ 是配对运行的次数。您的程序应计算每个用例的 $R$ 值，并输出包含在方括号中的逗号分隔列表的单行。将每个结果四舍五入到 $6$ 位小数。\n\n使用以下参数值测试套件以涵盖典型和边界行为：\n- 案例 1 (正相关，等方差，典型情况): $(\\sigma_A^2 = 4.0, \\sigma_B^2 = 4.0, \\rho = 0.8, n = 100)$。\n- 案例 2 (完全正相关，等方差，边界情况): $(\\sigma_A^2 = 9.0, \\sigma_B^2 = 9.0, \\rho = 1.0, n = 50)$。\n- 案例 3 (负相关，非对称方差，边缘情况): $(\\sigma_A^2 = 1.0, \\sigma_B^2 = 4.0, \\rho = -0.5, n = 200)$。\n- 案例 4 (零相关，非对称方差，基线情况): $(\\sigma_A^2 = 2.25, \\sigma_B^2 = 1.0, \\rho = 0.0, n = 1000)$。\n- 案例 5 (高正相关，高度非对称方差): $(\\sigma_A^2 = 16.0, \\sigma_B^2 = 1.0, \\rho = 0.9, n = 300)$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是为案例 $i$ 计算并四舍五入的方差减少分数。",
            "solution": "该问题要求对两种实验设计——独立运行和公共随机数 (CRN)——下均值差估计器的方差进行形式化推导，然后给出 CRN 的方差减少表达式。它还要求在基于智能体的模拟背景下提出一个实现 CRN 的方案，并最终为几个测试用例计算方差减少量。\n\n我们首先建立基本定义和感兴趣量的估计器。\n智能体规则 $A$ 和 $B$ 的性能结果分别是随机变量 $Y_A(\\boldsymbol{\\xi})$ 和 $Y_B(\\boldsymbol{\\xi})$。为简单起见，我们将其表示为 $Y_A$ 和 $Y_B$。目标是估计它们期望性能的差异，$\\Delta = \\mathbb{E}[Y_A] - \\mathbb{E}[Y_B]$。设 $\\mu_A = \\mathbb{E}[Y_A]$ 和 $\\mu_B = \\mathbb{E}[Y_B]$。方差由 $\\operatorname{Var}[Y_A] = \\sigma_A^2$ 和 $\\operatorname{Var}[Y_B] = \\sigma_B^2$ 给出。\n\n使用蒙特卡洛方法进行估计。基于 $n$ 次模拟运行，我们为每个规则获得样本。设规则 $A$ 的结果为 $\\{Y_{A,1}, Y_{A,2}, \\dots, Y_{A,n}\\}$，规则 $B$ 的结果为 $\\{Y_{B,1}, Y_{B,2}, \\dots, Y_{B,n}\\}$。单个均值的估计器为：\n$$ \\hat{\\mu}_A = \\frac{1}{n} \\sum_{i=1}^{n} Y_{A,i} \\quad \\text{和} \\quad \\hat{\\mu}_B = \\frac{1}{n} \\sum_{i=1}^{n} Y_{B,i} $$\n差异 $\\Delta$ 的估计器自然是 $\\hat{\\Delta} = \\hat{\\mu}_A - \\hat{\\mu}_B$。我们可以将其写作：\n$$ \\hat{\\Delta} = \\frac{1}{n} \\sum_{i=1}^{n} (Y_{A,i} - Y_{B,i}) $$\n我们的目标是求出该估计器在两种不同实验设计下的方差 $\\operatorname{Var}[\\hat{\\Delta}]$。\n\n**独立运行下估计器的方差**\n\n在独立运行设计中，用于生成 $\\{Y_{A,i}\\}$ 的随机数集与用于生成 $\\{Y_{B,i}\\}$ 的随机数集在统计上是独立的。这意味着对于所有 $i,j \\in \\{1, \\dots, n\\}$，$Y_{A,i}$ 与 $Y_{B,j}$ 都是独立的。因此，估计器 $\\hat{\\mu}_A$ 和 $\\hat{\\mu}_B$ 是独立的随机变量。\n\n两个独立随机变量之和的方差等于它们方差之和。因此，估计器 $\\hat{\\Delta}_{\\mathrm{ind}}$ 的方差是：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}] = \\operatorname{Var}[\\hat{\\mu}_A - \\hat{\\mu}_B] = \\operatorname{Var}[\\hat{\\mu}_A] + \\operatorname{Var}[-\\hat{\\mu}_B] = \\operatorname{Var}[\\hat{\\mu}_A] + (-1)^2 \\operatorname{Var}[\\hat{\\mu}_B] = \\operatorname{Var}[\\hat{\\mu}_A] + \\operatorname{Var}[\\hat{\\mu}_B] $$\n现在，我们推导 $\\hat{\\mu}_A$ 的方差。样本 $Y_{A,1}, \\dots, Y_{A,n}$ 是独立同分布 (i.i.d.) 的，方差为 $\\sigma_A^2$。\n$$ \\operatorname{Var}[\\hat{\\mu}_A] = \\operatorname{Var}\\left[\\frac{1}{n} \\sum_{i=1}^{n} Y_{A,i}\\right] $$\n使用属性 $\\operatorname{Var}[cX] = c^2\\operatorname{Var}[X]$：\n$$ \\operatorname{Var}[\\hat{\\mu}_A] = \\frac{1}{n^2} \\operatorname{Var}\\left[\\sum_{i=1}^{n} Y_{A,i}\\right] $$\n由于 $Y_{A,i}$ 是独立的，它们的和的方差是它们方差的和：\n$$ \\operatorname{Var}[\\hat{\\mu}_A] = \\frac{1}{n^2} \\sum_{i=1}^{n} \\operatorname{Var}[Y_{A,i}] = \\frac{1}{n^2} (n \\sigma_A^2) = \\frac{\\sigma_A^2}{n} $$\n通过相同的推理，$\\operatorname{Var}[\\hat{\\mu}_B] = \\frac{\\sigma_B^2}{n}$。\n将这些代入 $\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}]$ 的表达式中，得到：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}] = \\frac{\\sigma_A^2}{n} + \\frac{\\sigma_B^2}{n} = \\frac{\\sigma_A^2 + \\sigma_B^2}{n} $$\n\n**公共随机数 (CRN) 下估计器的方差**\n\n在 CRN 设计中，对于每次配对运行 $i \\in \\{1, \\dots, n\\}$，两条规则都使用相同的随机数序列进行模拟，即相同的外生输入 $\\boldsymbol{\\xi}_i$。这在 $Y_{A,i}$ 和 $Y_{B,i}$ 之间引入了相关性。对 $(Y_{A,i}, Y_{B,i})$ 在 $i=1, \\dots, n$ 上是独立同分布的。\n设 $Z_i = Y_{A,i} - Y_{B,i}$。那么估计器是 $\\hat{\\Delta}_{\\mathrm{CRN}} = \\frac{1}{n} \\sum_{i=1}^{n} Z_i$。由于对 $(Y_{A,i}, Y_{B,i})$ 是独立同分布的，差值 $Z_i$ 也是独立同分布的。\n估计器的方差是：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}] = \\operatorname{Var}\\left[\\frac{1}{n} \\sum_{i=1}^{n} Z_i\\right] = \\frac{1}{n^2} \\sum_{i=1}^{n} \\operatorname{Var}[Z_i] = \\frac{n \\operatorname{Var}[Z_1]}{n^2} = \\frac{\\operatorname{Var}[Z_1]}{n} $$\n我们现在需要求 $\\operatorname{Var}[Z_1] = \\operatorname{Var}[Y_{A,1} - Y_{B,1}]$。两个相关随机变量之差的方差由以下恒等式给出：\n$$ \\operatorname{Var}[X - Y] = \\operatorname{Var}[X] + \\operatorname{Var}[Y] - 2\\operatorname{Cov}[X, Y] $$\n应用此恒等式，我们得到：\n$$ \\operatorname{Var}[Z_1] = \\operatorname{Var}[Y_{A,1}] + \\operatorname{Var}[Y_{B,1}] - 2\\operatorname{Cov}[Y_{A,1}, Y_{B,1}] $$\n边际方差 $\\operatorname{Var}[Y_{A,1}]$ 和 $\\operatorname{Var}[Y_{B,1}]$ 仍然是 $\\sigma_A^2$ 和 $\\sigma_B^2$。协方差项 $\\operatorname{Cov}[Y_{A,1}, Y_{B,1}]$（我们记为 $\\operatorname{Cov}[Y_A, Y_B]$）在 CRN 下通常不为零。\n因此，CRN 下估计器的方差是：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}] = \\frac{\\sigma_A^2 + \\sigma_B^2 - 2\\operatorname{Cov}[Y_A, Y_B]}{n} $$\n\n**方差减少分数**\n\n方差减少分数 $R$ 定义为 $R = 1 - \\frac{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}]}{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}]}$。代入推导出的表达式：\n$$ R = 1 - \\frac{(\\sigma_A^2 + \\sigma_B^2 - 2\\operatorname{Cov}[Y_A, Y_B])/n}{(\\sigma_A^2 + \\sigma_B^2)/n} $$\n样本量 $n$ 被消掉，表明相对方差减少量与运行次数无关：\n$$ R = 1 - \\frac{\\sigma_A^2 + \\sigma_B^2 - 2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} $$\n$$ R = 1 - \\left( \\frac{\\sigma_A^2 + \\sigma_B^2}{\\sigma_A^2 + \\sigma_B^2} - \\frac{2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} \\right) = 1 - \\left( 1 - \\frac{2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} \\right) $$\n$$ R = \\frac{2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} $$\n最后，我们用相关系数 $\\rho = \\frac{\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A \\sigma_B}$ 来表示它，其中 $\\sigma_A = \\sqrt{\\sigma_A^2}$ 和 $\\sigma_B = \\sqrt{\\sigma_B^2}$ 是标准差。根据此定义，$\\operatorname{Cov}[Y_A, Y_B] = \\rho \\sigma_A \\sigma_B$。\n将此代入 $R$ 的表达式中：\n$$ R = \\frac{2 \\rho \\sigma_A \\sigma_B}{\\sigma_A^2 + \\sigma_B^2} $$\n这是理论方差减少分数的最终表达式。正相关 ($\\rho > 0$) 导致正的方差减少 ($R > 0$)，而负相关 ($\\rho < 0$) 导致方差增加 ($R < 0$)。如果 $\\rho=0$，与独立设计相比，方差没有变化。\n\n**CRN 设计方案**\n\n为了在基于智能体的模型中有效实施 CRN，目标是在每次配对运行中，同步规则 $A$ 和规则 $B$ 下智能体所经历的随机事件。这确保了观察到的任何性能差异更有可能是由规则本身引起的，而不是随机运气的差异。\n\n一个科学上稳健的 CRN 设计可以按如下方式构建：\n1.  **重复播种 (Replication Seeding)**：模拟进行 $n$ 次配对重复。应生成一个包含 $n$ 个不同种子 $\\{S_1, S_2, \\dots, S_n\\}$ 的主序列。对于每次重复 $i$，规则 $A$ 模拟的伪随机数生成器 (PRNG) 和规则 $B$ 模拟的 PRNG 都使用相同的种子 $S_i$ 进行初始化。\n2.  **随机数流的同步 (Synchronization of Random Number Streams)**：CRN 的核心在于确保在规则 $A$ 的模拟中请求的第 $k$ 个随机数与其在规则 $B$ 模拟中用于相同逻辑目的的第 $k$ 个随机数相匹配。\n    - 例如，如果第一个随机事件是确定资源的初始位置，两个模拟都应使用它们同步流中的第一个随机数 $U_1$ 来完成此目的。如果第二个事件是确定智能体的通信尝试是否成功，两者都应使用 $U_2$。\n    - 当规则 A 和规则 B 的逻辑决定了不同数量的随机数抽取时，一个关键的挑战就出现了。例如，如果规则 A 导致一个需要 3 个随机数的操作，而规则 B 导致一个只需要 1 个随机数的操作，那么对于所有后续事件，流将失去同步。\n3.  **通过多流实现的稳健同步 (Robust Synchronization via Multiple Streams)**：一种减轻失步的更优方法是使用多个独立的 PRNG 流，每个流专用于模型中特定的随机性来源。例如：\n    - 流 1：用于初始智能体布局。\n    - 流 2：用于随机环境变化（例如，资源补充）。\n    - 流 3：用于智能体行动成功概率（例如，觅食成功率）。\n    每个流都是公共随机数包的一部分；对于重复 $i$，规则 $A$ 模拟中的流 $j$ 与规则 $B$ 模拟中的流 $j$ 是同步的。这样，如果规则 $A$ 因其特有逻辑需要额外抽取随机数，它可以从规则 $B$ 不使用的专用流中抽取，从而保持公共流的同步。\n4.  **实现非负相关 (Achieving Non-negative Correlation)**：通过同步底层的随机事件，我们确保两条规则在给定的运行中面临相同的“有利”或“不利”条件。如果智能体规则 $A$ 和 $B$ 在结构上相似（例如，是某个基础启发式算法的变体），它们很可能以类似的方式对这些条件做出反应。一组有利的随机事件（例如，资源丰富、风险低）可能会为两者都带来高性能（$Y_A$ 和 $Y_B$ 都高），而不利的事件则会导致两者表现不佳（$Y_A$ 和 $Y_B$ 都低）。$Y_A$ 和 $Y_B$ 这种同向变动的趋势导致了正的协方差，$\\operatorname{Cov}[Y_A, Y_B] > 0$，从而产生正相关 $\\rho > 0$。这种正相关是方差减少的来源。\n\n这种结构化设计确保了 CRN 技术的正确应用，从而在智能体规则之间进行统计上高效的比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the theoretical variance reduction fraction of Common Random Numbers (CRN)\n    relative to independent runs for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_A^2, sigma_B^2, rho, n)\n    # sigma_A^2: Variance of outcome for rule A\n    # sigma_B^2: Variance of outcome for rule B\n    # rho: Correlation coefficient between Y_A and Y_B under CRN\n    # n: Number of paired runs (note: n is not used in the final formula for R)\n    test_cases = [\n        (4.0, 4.0, 0.8, 100),\n        (9.0, 9.0, 1.0, 50),\n        (1.0, 4.0, -0.5, 200),\n        (2.25, 1.0, 0.0, 1000),\n        (16.0, 1.0, 0.9, 300)\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma_A_sq, sigma_B_sq, rho, _ = case\n        \n        # The theoretical variance reduction fraction is given by the formula:\n        # R = (2 * rho * sigma_A * sigma_B) / (sigma_A^2 + sigma_B^2)\n        \n        # Calculate the standard deviations\n        sigma_A = np.sqrt(sigma_A_sq)\n        sigma_B = np.sqrt(sigma_B_sq)\n        \n        # Numerator of the fraction R\n        numerator = 2 * rho * sigma_A * sigma_B\n        \n        # Denominator of the fraction R\n        denominator = sigma_A_sq + sigma_B_sq\n        \n        # The problem statement gives positive variances, so no division by zero is expected.\n        result = numerator / denominator\n        \n        # Round the result to 6 decimal places as required.\n        results.append(round(result, 6))\n\n    # Format the final output as a comma-separated list in square brackets.\n    # The map(str, ...) is necessary to handle potential negative signs and floating point representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver function.\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的智能体任务通常涉及相互冲突的目标，例如在效率和公平性之间取得平衡。本练习探讨了处理此类多目标问题的常用方法：加权和标量化。通过分析不同候选规则的排名如何随权重参数 $\\alpha$ 的变化而改变，您将能更深刻地理解帕累托前沿（Pareto front）的概念，并体会到在多维性能空间中定义单一“最优”规则所面临的挑战。",
            "id": "4125258",
            "problem": "考虑一个在复杂自适应系统内评估的候选智能体规则群体。在遗传编程（GP）中，选择作用于一个标量适应度，此处该适应度由两个目标的加权和标量化定义：一个效率指标和一个公平性惩罚。对于每个具有效率 $E_i \\in \\mathbb{R}$ 和公平性惩罚 $G_i \\in \\mathbb{R}$ 的候选规则 $i$，将标量化适应度定义为 $f_i(\\alpha) = \\alpha E_i - (1 - \\alpha) G_i$，其中权重参数 $\\alpha \\in [0,1]$。假设标量化适应度 $f_i(\\alpha)$ 需要被最大化。目标是分析由 $f_i(\\alpha)$ 导出的规则排序对 $\\alpha$ 变化的敏感性。\n\n从多目标优化的基本定义出发，不使用任何快捷公式，为每个测试用例执行以下操作：\n\n- 给定 $n$ 个具有指标 $\\{E_i\\}_{i=1}^n$ 和 $\\{G_i\\}_{i=1}^n$ 的候选规则，确定所有在 $[0,1]$ 区间内的临界值 $\\alpha$，在这些值上由 $f_i(\\alpha)$ 决定的规则排序可能发生改变。这些临界点发生在对于某个 $i \\neq j$ 有 $f_i(\\alpha) = f_j(\\alpha)$ 时。使用数值容差 $\\varepsilon = 10^{-9}$ 来稳健地处理近似相等的情况。将端点 $\\alpha = 0$ 和 $\\alpha = 1$ 作为分析的边界。\n- 通过已排序的唯一临界值 $\\alpha$ 对区间 $[0,1]$ 进行划分，以获得排序保持不变的区域。报告这些区域的数量。\n- 计算在 $\\alpha = 0$ 和 $\\alpha = 1$ 处的排序之间的肯德尔等级相关系数（Kendall tau），以量化排序的极值敏感性。使用统计软件中实现的 Kendall tau 的标准定义。当出现平局时，为了稳定性，通过升序索引 $i$ 来确定性地打破平局。\n- 报告排名第一的规则（具有最大适应度的规则）的身份是否在 $\\alpha = 0$ 到 $\\alpha = 1$ 之间发生变化。\n- 提供在 $[0,1]$ 区间内的所有临界 $\\alpha$ 值的列表（包括由容差合并的重复值），按升序排列。将所有 $\\alpha$ 值表示为四舍五入到六位小数的小数。\n\n您的程序必须实现此分析，并为以下测试套件生成结果。对于每个测试用例，输入是 $E_i$ 和 $G_i$ 的列表：\n\n- 测试用例1（一般交叉情况）：$E = \\{0.80, 0.60, 0.90, 0.50\\}$ 和 $G = \\{0.30, 0.20, 0.60, 0.10\\}$。\n- 测试用例2（边界相交与平局）：$E = \\{1.00, 0.50, 0.50\\}$ 和 $G = \\{0.40, 0.40, 0.10\\}$。\n- 测试用例3（退化平行线）：$E = \\{0.70, 0.50, 0.90\\}$ 和 $G = \\{0.30, 0.50, 0.10\\}$。\n- 测试用例4（高维敏感性）：$E = \\{0.92, 0.81, 0.74, 0.66, 0.59, 0.52\\}$ 和 $G = \\{0.12, 0.28, 0.21, 0.33, 0.27, 0.38\\}$。\n\n角度单位不适用，也不涉及任何物理单位；所有量均为无量纲实数。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身就是一个形式为 $[N_\\text{regions}, \\tau_{0,1}, \\text{top\\_changed}, [\\text{breakpoints}]]$ 的列表。这里，$N_\\text{regions}$ 是一个整数，$\\tau_{0,1}$ 是一个浮点数（四舍五入到六位小数），$\\text{top\\_changed}$ 是一个布尔值，而 $[\\text{breakpoints}]$ 是一个浮点数列表（每个都四舍五入到六位小数）。例如，最终输出格式应类似于 $[[2,0.333333,True,[0.000000,1.000000]],\\dots]$，行内没有任何空格。",
            "solution": "用户提供的问题已经过评估，并被确定为 **有效**。这是一个在多目标优化领域内，特别是使用加权和方法进行标量化的问题，它提法明确且具有科学依据。该问题是自包含的，提供了所有必要的数据和定义。因此，我们可以着手进行推导和求解。\n\n问题的核心是分析一组 $n$ 个候选规则的排序敏感性，该排序由标量适应度函数 $f_i(\\alpha)$ 决定。规则 $i$ 的适应度由下式给出：\n$$f_i(\\alpha) = \\alpha E_i - (1 - \\alpha) G_i$$\n其中 $E_i$ 是效率，$G_i$ 是公平性惩罚，而 $\\alpha \\in [0,1]$ 是一个权重参数。优化目标是最大化 $f_i(\\alpha)$。\n\n规则的排序是其索引的列表，按其适应度值 $f_i(\\alpha)$ 的降序排列。此排序仅当两个不同规则的适应度值变得相等时才会改变。这些情况定义了 $\\alpha$ 的临界值。让我们考虑两个不同的规则 $i$ 和 $j$，其中 $i \\neq j$。当它们的适应度值相等时，就会出现一个 $\\alpha$ 的临界值：\n$$f_i(\\alpha) = f_j(\\alpha)$$\n代入适应度函数的定义：\n$$\\alpha E_i - (1 - \\alpha) G_i = \\alpha E_j - (1 - \\alpha) G_j$$\n我们可以重新整理这个方程来求解 $\\alpha$。展开各项：\n$$\\alpha E_i - G_i + \\alpha G_i = \\alpha E_j - G_j + \\alpha G_j$$\n将含有 $\\alpha$ 的项归到一边，常数项归到另一边：\n$$\\alpha E_i + \\alpha G_i - \\alpha E_j - \\alpha G_j = G_i - G_j$$\n提出因子 $\\alpha$：\n$$\\alpha (E_i + G_i - E_j - G_j) = G_i - G_j$$\n这可以使用 $\\Delta E = E_i - E_j$ 和 $\\Delta G = G_i - G_j$ 重写为：\n$$\\alpha (\\Delta E + \\Delta G) = \\Delta G$$\n如果分母不为零，则规则 $i$ 和 $j$ 具有相同适应度的临界值 $\\alpha_{ij}$ 为：\n$$\\alpha_{ij} = \\frac{G_i - G_j}{(E_i + G_i) - (E_j + G_j)}$$\n一个临界值 $\\alpha_{ij}$ 仅当其落在区间 $[0,1]$ 内时，才与我们的分析相关。\n\n当分母为零时，即 $(E_i + G_i) - (E_j + G_j) = 0$，会出现一种特殊情况。这意味着函数 $f_i(\\alpha)$ 和 $f_j(\\alpha)$（它们是关于 $\\alpha$ 的线性函数）具有相同的斜率。\n- 如果分子 $G_i - G_j$ 也为零，则这两条线是相同的，意味着对于所有 $\\alpha$ 都有 $f_i(\\alpha) = f_j(\\alpha)$。此时，规则 $i$ 和 $j$ 的相对顺序完全由平局打破规则（按索引）确定，并且永远不会改变。\n- 如果分子不为零，则这两条线是平行且不重合的。它们永不相交，因此规则 $i$ 和 $j$ 之间的相对排序对于所有 $\\alpha$ 都保持不变。\n在这两种平行情况下，都不会产生新的临界点。\n\n每个测试用例的总体算法如下：\n\n1.  **识别临界点**：遍历所有唯一的规则对 $(i, j)$（其中 $i < j$）。对于每一对，计算分母 $D = (E_i + G_i) - (E_j + G_j)$。如果 $|D|$ 大于一个小的容差 $\\varepsilon = 10^{-9}$，则计算临界值 $\\alpha_{ij} = (G_i - G_j)/D$。收集所有位于区间 $[0,1]$ 内的此类 $\\alpha_{ij}$。\n\n2.  **划分区间**：通过将第1步中收集的所有临界点与边界 $\\alpha=0$ 和 $\\alpha=1$ 合并，创建一个断点集合。对这些点进行排序，并使用容差 $\\varepsilon$ 来合并近似相同的值以消除重复。排序保持不变的区域数量 $N_\\text{regions}$ 比唯一断点的数量少一。\n\n3.  **分析边界排序**：\n    a. 确定在 $\\alpha=0$ 时的排序。适应度为 $f_i(0) = -G_i$。通过根据 $-G_i$ 的降序值对规则索引进行排序来获得排序。\n    b. 确定在 $\\alpha=1$ 时的排序。适应度为 $f_i(1) = E_i$。通过根据 $E_i$ 的降序值对规则索引进行排序来获得排序。\n    c. 在这两种情况下，适应度值的平局通过选择具有较小原始索引 $i$ 的规则来打破。\n\n4.  **计算敏感性指标**：\n    a. **排名第一的规则变化**：将在 $\\alpha=0$ 时排名第一的规则的索引与在 $\\alpha=1$ 时排名第一的规则的索引进行比较。这将产生一个布尔值 `top_changed`。\n    b. **Kendall Tau 相关性**：使用从 $\\alpha=0$ 和 $\\alpha=1$ 得到的完整排序，计算肯德尔等级相关系数 $\\tau$。该系数衡量两个排序之间的序数关联。$\\tau=1$ 表示排序相同，$\\tau=-1$ 表示排序完全相反，而 $\\tau=0$ 表示没有相关性。问题陈述允许为此使用标准库实现，例如 `scipy.stats.kendalltau`。公式为 $\\tau = (N_c - N_d) / (N_c + N_d)$，其中 $N_c$ 是两个排序之间的一致对数，$N_d$ 是不一致对数。\n\n5.  **格式化和报告**：将结果——$N_\\text{regions}$、计算出的 $\\tau$ 值、`top_changed` 布尔值以及排序后的唯一断点列表——组合成指定的输出格式。所有浮点数（$\\tau$ 和断点）必须四舍五入到六位小数。\n\n此程序按要求提供了对排序敏感性的完整而严谨的分析。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kendalltau\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (general crossing case)\n        (\n            [0.80, 0.60, 0.90, 0.50],\n            [0.30, 0.20, 0.60, 0.10]\n        ),\n        # Test Case 2 (boundary intersections and ties)\n        (\n            [1.00, 0.50, 0.50],\n            [0.40, 0.40, 0.10]\n        ),\n        # Test Case 3 (degenerate parallel lines)\n        (\n            [0.70, 0.50, 0.90],\n            [0.30, 0.50, 0.10]\n        ),\n        # Test Case 4 (higher-dimensional sensitivity)\n        (\n            [0.92, 0.81, 0.74, 0.66, 0.59, 0.52],\n            [0.12, 0.28, 0.21, 0.33, 0.27, 0.38]\n        )\n    ]\n\n    all_results_str = []\n    \n    for E_list, G_list in test_cases:\n        E = np.array(E_list, dtype=float)\n        G = np.array(G_list, dtype=float)\n        n = len(E)\n        epsilon = 1e-9\n\n        # --- Step 1: Identify Critical Points ---\n        critical_alphas = []\n        slopes = E + G\n        for i in range(n):\n            for j in range(i + 1, n):\n                denominator = slopes[i] - slopes[j]\n                \n                if abs(denominator) > epsilon:\n                    numerator = G[i] - G[j]\n                    alpha_ij = numerator / denominator\n                    \n                    if -epsilon = alpha_ij = 1 + epsilon:\n                        # Clamp to [0, 1] for floating point inaccuracies near boundaries\n                        alpha_ij = max(0.0, min(1.0, alpha_ij))\n                        critical_alphas.append(alpha_ij)\n\n        # --- Step 2: Partition the Interval ---\n        breakpoints = [0.0, 1.0] + critical_alphas\n        breakpoints.sort()\n        \n        unique_breakpoints = []\n        if breakpoints:\n            unique_breakpoints.append(breakpoints[0])\n            for i in range(1, len(breakpoints)):\n                if breakpoints[i] - unique_breakpoints[-1] > epsilon:\n                    unique_breakpoints.append(breakpoints[i])\n        \n        N_regions = len(unique_breakpoints) - 1\n        \n        # Helper for ranking\n        def get_ranking(alpha, E_vec, G_vec):\n            fitness = alpha * E_vec - (1 - alpha) * G_vec\n            # Sort by -fitness (desc), then by index (asc) for tie-breaking\n            indexed_fitness = sorted(enumerate(fitness), key=lambda x: (-x[1], x[0]))\n            return [index for index, fit in indexed_fitness]\n\n        # --- Step 3: Analyze Boundary Rankings ---\n        ranking_at_0 = get_ranking(0.0, E, G)\n        ranking_at_1 = get_ranking(1.0, E, G)\n        \n        # --- Step 4: Compute Sensitivity Metrics ---\n        # Top-ranked rule change\n        top_changed = ranking_at_0[0] != ranking_at_1[0]\n        \n        # Kendall Tau\n        # We need to compute ranks for kendalltau. The rank of item i is its position in the ranking list.\n        # rank_vec[i] = position_of_i\n        rank_vec_0 = np.zeros(n, dtype=int)\n        rank_vec_1 = np.zeros(n, dtype=int)\n        for rank, index in enumerate(ranking_at_0):\n            rank_vec_0[index] = rank\n        for rank, index in enumerate(ranking_at_1):\n            rank_vec_1[index] = rank\n            \n        tau, _ = kendalltau(rank_vec_0, rank_vec_1)\n\n        # --- Step 5: Format and Report ---\n        bp_list_str = f\"[{','.join([f'{bp:.6f}' for bp in unique_breakpoints])}]\"\n        result_str = (\n            f\"[{N_regions},{tau:.6f},{str(top_changed)},{bp_list_str}]\"\n        )\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        }
    ]
}