{
    "hands_on_practices": [
        {
            "introduction": "我们将从分析最简单的情景入手：一个不存在任何基因相互作用（$K=0$）的适应度景观。这项练习  将帮助我们建立适应度分布的统计基线，这对于理解之后上位效应如何引入复杂性和崎岖性至关重要。通过这个推导，你将掌握分析随机景观系综（ensemble）的基本统计工具。",
            "id": "4148453",
            "problem": "考虑NK适应度景观模型，特别是没有上位相互作用的加性情况，即 $K=0$。存在 $N$ 个位点，每个位点具有 $\\{0,1\\}$ 中的二元等位基因。对每个位点 $i \\in \\{1,\\dots,N\\}$，定义一个查找函数 $f_i:\\{0,1\\}\\to \\mathbb{R}$。假设以下生成性假设成立：\n- 对于每个 $i$，两个表项 $f_i(0)$ 和 $f_i(1)$ 是从一个均值为 $\\mu$、方差为 $\\sigma^{2}$ 的共同分布中抽取的独立同分布样本。\n- 对于不同的位点 $i$，所有表项是相互独立的。\n- 一个基因型 $X=(X_1,\\dots,X_N)\\in\\{0,1\\}^N$ 是独立于所有查找表项、均匀随机抽样得到的。\n\n在加性情况下，基因型 $x\\in\\{0,1\\}^N$ 的适应度定义为\n$$\nF(x) \\equiv \\frac{1}{N}\\sum_{i=1}^{N} f_i(x_i).\n$$\n令 $F \\equiv F(X)$ 表示在上述随机生成的加性景观下，一个均匀随机基因型 $X$ 的适应度。仅使用期望、方差、期望的线性性、独立随机变量和的方差以及全期望定律和全方差定律这些概率论的核心定义，推导在基因型和景观的联合随机性下的均值 $\\mathbb{E}[F]$ 和方差 $\\mathrm{Var}(F)$ 的闭式表达式。\n\n请以单行矩阵 $\\begin{pmatrix}\\mathbb{E}[F]  \\mathrm{Var}(F)\\end{pmatrix}$ 的形式给出你的最终答案。不要进行近似或四舍五入；你的答案必须是使用 $\\mu$、$\\sigma^{2}$ 和 $N$ 表示的精确符号表达式。",
            "solution": "该问题陈述已经过验证，被认为是具有科学依据、适定、客观且内部一致的。它代表了适应度景观统计分析中的一个标准理论练习。我们着手进行求解。\n\n我们关心的随机变量是适应度 $F = F(X)$，其定义为\n$$\nF \\equiv \\frac{1}{N}\\sum_{i=1}^{N} f_i(X_i)\n$$\n$F$ 中的随机性来自两个独立的来源：\n$1.$ 景观的随机生成，它由所有查找表项的集合 $\\{f_i(a) \\mid i \\in \\{1,\\dots,N\\}, a \\in \\{0,1\\}\\}$ 组成。我们用下标 $\\mathcal{L}$ 表示对此随机性的期望和方差。每个 $f_i(a)$ 是一个独立同分布的随机变量，其均值为 $\\mathbb{E}_{\\mathcal{L}}[f_i(a)] = \\mu$，方差为 $\\mathrm{Var}_{\\mathcal{L}}(f_i(a)) = \\sigma^2$。\n$2.$ 从空间 $\\{0,1\\}^N$ 中均匀随机抽样一个基因型 $X=(X_1,\\dots,X_N)$。我们用下标 $X$ 表示对此随机性的期望和方差。均匀抽样意味着对每个位点 $i$，$\\mathbb{P}(X_i = 0) = \\mathbb{P}(X_i = 1) = \\frac{1}{2}$，并且变量 $X_1, \\dots, X_N$ 是相互独立的。\n\n我们寻求在景观和基因型的联合概率空间上的总期望 $\\mathbb{E}[F]$ 和总方差 $\\mathrm{Var}(F)$。\n\n**均值 $\\mathbb{E}[F]$ 的计算**\n\n我们将使用全期望定律，也称为迭代期望定律：$\\mathbb{E}[Y] = \\mathbb{E}_A[\\mathbb{E}_B[Y|A]]$。我们可以选择先对景观或基因型取条件。事实证明，对基因型 $X$ 取条件更为直接。\n$$\n\\mathbb{E}[F] = \\mathbb{E}_{X}[\\mathbb{E}_{\\mathcal{L}}[F | X]]\n$$\n首先，我们计算内层期望，即在一个固定的基因型 $x \\in \\{0,1\\}^N$ 下，对景观的随机系综计算的期望适应度。\n$$\n\\mathbb{E}_{\\mathcal{L}}[F | X=x] = \\mathbb{E}_{\\mathcal{L}}\\left[\\frac{1}{N}\\sum_{i=1}^{N} f_i(x_i)\\right]\n$$\n根据期望的线性性，我们可以将期望算子移到求和号内部：\n$$\n\\mathbb{E}_{\\mathcal{L}}[F | X=x] = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbb{E}_{\\mathcal{L}}[f_i(x_i)]\n$$\n根据问题陈述，对任意位点 $i$ 和任意等位基因选择 $x_i \\in \\{0,1\\}$，项 $f_i(x_i)$ 是从一个均值为 $\\mu$ 的分布中抽取的随机变量。因此，$\\mathbb{E}_{\\mathcal{L}}[f_i(x_i)] = \\mu$。\n将此代入求和中得到：\n$$\n\\mathbb{E}_{\\mathcal{L}}[F | X=x] = \\frac{1}{N}\\sum_{i=1}^{N} \\mu = \\frac{1}{N}(N\\mu) = \\mu\n$$\n给定一个特定基因型 $x$ 时，$F$ 的条件期望就是 $\\mu$，这是一个不依赖于基因型本身的常数值。\n\n现在，我们计算关于基因型 $X$ 的随机选择的外层期望：\n$$\n\\mathbb{E}[F] = \\mathbb{E}_{X}[\\mu] = \\mu\n$$\n常数的期望就是其本身。因此，平均适应度为 $\\mu$。\n\n**方差 $\\mathrm{Var}(F)$ 的计算**\n\n我们使用全方差定律，该定律表明：\n$$\n\\mathrm{Var}(F) = \\mathbb{E}_{X}[\\mathrm{Var}_{\\mathcal{L}}(F | X)] + \\mathrm{Var}_{X}(\\mathbb{E}_{\\mathcal{L}}[F | X])\n$$\n我们来分析右侧的两项。\n\n第二项 $\\mathrm{Var}_{X}(\\mathbb{E}_{\\mathcal{L}}[F | X])$ 是我们之前计算的条件期望的方差。因为我们发现 $\\mathbb{E}_{\\mathcal{L}}[F | X] = \\mu$ 是一个常数，所以它关于 $X$ 的方差为零：\n$$\n\\mathrm{Var}_{X}(\\mathbb{E}_{\\mathcal{L}}[F | X]) = \\mathrm{Var}_{X}(\\mu) = 0\n$$\n这将全方差定律简化为：\n$$\n\\mathrm{Var}(F) = \\mathbb{E}_{X}[\\mathrm{Var}_{\\mathcal{L}}(F | X)]\n$$\n现在我们必须计算内层项 $\\mathrm{Var}_{\\mathcal{L}}(F | X=x)$，即对于一个固定的基因型 $x$，在景观系综上计算的适应度方差。\n$$\n\\mathrm{Var}_{\\mathcal{L}}(F | X=x) = \\mathrm{Var}_{\\mathcal{L}}\\left(\\frac{1}{N}\\sum_{i=1}^{N} f_i(x_i)\\right)\n$$\n使用方差的性质 $\\mathrm{Var}(cY) = c^2\\mathrm{Var}(Y)$，其中 $c = \\frac{1}{N}$：\n$$\n\\mathrm{Var}_{\\mathcal{L}}(F | X=x) = \\frac{1}{N^2}\\mathrm{Var}_{\\mathcal{L}}\\left(\\sum_{i=1}^{N} f_i(x_i)\\right)\n$$\n求和中的各项 $f_1(x_1), f_2(x_2), \\dots, f_N(x_N)$ 是对应于不同位点适应度贡献的随机变量。根据问题的生成性假设，所有表项都是相互独立的。由于每个 $f_i(x_i)$ 是不同位点 $i$ 的一个表项，因此这些变量是相互独立的。对于独立随机变量之和，和的方差等于方差的和：\n$$\n\\mathrm{Var}_{\\mathcal{L}}\\left(\\sum_{i=1}^{N} f_i(x_i)\\right) = \\sum_{i=1}^{N} \\mathrm{Var}_{\\mathcal{L}}(f_i(x_i))\n$$\n对于任意位点 $i$ 和任意等位基因选择 $x_i \\in \\{0,1\\}$，项 $f_i(x_i)$ 是从一个方差为 $\\sigma^2$ 的分布中抽取的随机变量。因此，$\\mathrm{Var}_{\\mathcal{L}}(f_i(x_i)) = \\sigma^2$。将此代入求和中：\n$$\n\\sum_{i=1}^{N} \\mathrm{Var}_{\\mathcal{L}}(f_i(x_i)) = \\sum_{i=1}^{N} \\sigma^2 = N\\sigma^2\n$$\n将条件方差的所有部分整合起来：\n$$\n\\mathrm{Var}_{\\mathcal{L}}(F | X=x) = \\frac{1}{N^2}(N\\sigma^2) = \\frac{\\sigma^2}{N}\n$$\n这个结果也是一个常数，不依赖于特定的基因型 $x$。\n\n最后，我们计算关于随机基因型 $X$ 的外层期望：\n$$\n\\mathrm{Var}(F) = \\mathbb{E}_{X}\\left[\\frac{\\sigma^2}{N}\\right] = \\frac{\\sigma^2}{N}\n$$\n常数的期望就是其本身。因此，适应度的总方差为 $\\frac{\\sigma^2}{N}$。\n\n总而言之，适应度分布的均值为 $\\mu$，方差为 $\\frac{\\sigma^2}{N}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\mu  \\frac{\\sigma^{2}}{N}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在为平滑的加性景观建立了基线之后，我们现在来探讨相互作用（$K>0$）如何产生崎岖性。这项针对一个小型 $N=2$ 系统的动手计算 ，将让你能够直接观察并量化不同形式的上位效应，例如互反符号上位性（reciprocal sign epistasis）。这是理解适应度景观中多个峰值来源的关键一步。",
            "id": "4148370",
            "problem": "考虑复杂自适应系统中的NK模型适应度景观，其中基因型由长度为 $N$ 的二进制字符串表示，每个位点的适应度贡献取决于其自身状态以及 $K$ 个相互作用位点的状态。对于 $N=2$ 和 $K=1$，假设每个位点都与另一个位点相互作用。设总适应度是各位点特定贡献的算术平均值。形式上，对于基因型 $\\mathbf{x}=(x_{1},x_{2})\\in\\{0,1\\}^{2}$，适应度定义为\n$$\nW(\\mathbf{x})=\\frac{1}{2}\\left[w_{1}(x_{1},x_{2})+w_{2}(x_{2},x_{1})\\right],\n$$\n其中 $w_{1}$ 是位点1的贡献，$w_{2}$ 是位点2的贡献。\n\n通过为所有等位基因组合指定贡献表 $w_{1}$ 和 $w_{2}$，构建两个明确的NK实例。对于实例A，使用\n$$\nw_{1}(0,0)=2.0,\\quad w_{1}(1,0)=3.2,\\quad w_{1}(0,1)=3.5,\\quad w_{1}(1,1)=2.6,\n$$\n$$\nw_{2}(0,0)=2.0,\\quad w_{2}(0,1)=3.5,\\quad w_{2}(1,0)=2.8,\\quad w_{2}(1,1)=3.4.\n$$\n对于实例B，使用\n$$\nw_{1}(0,0)=3.8,\\quad w_{1}(1,0)=2.7,\\quad w_{1}(0,1)=2.9,\\quad w_{1}(1,1)=4.7,\n$$\n$$\nw_{2}(0,0)=4.2,\\quad w_{2}(0,1)=2.1,\\quad w_{2}(1,0)=2.3,\\quad w_{2}(1,1)=4.3.\n$$\n\n任务：\n1. 仅使用上述模型定义，计算每个实例的适应度值 $W(0,0)$、 $W(1,0)$、 $W(0,1)$ 和 $W(1,1)$。\n2. 根据定义——当单位点突变的适应度效应的符号取决于另一位点的状态时，发生符号上位性；当两个位点相对于彼此都表现出这种符号变化时，发生互反符号上位性——确定每个实例表现出哪种类型的上位性。\n3. 通过标准上位性偏差来量化非加性\n$$\n\\varepsilon \\equiv W(0,0)+W(1,1)-W(0,1)-W(1,0).\n$$\n计算每个实例的 $\\varepsilon$。\n\n以单行矩阵的精确形式报告有序对 $\\left(\\varepsilon_{\\text{A}},\\varepsilon_{\\text{B}}\\right)$。无需四舍五入，不涉及单位。",
            "solution": "首先将验证该问题，以确保其具有科学依据、良构且客观。\n\n### 步骤1：提取已知条件\n- **模型**：NK模型\n- **基因型**：长度为 $N=2$ 的二进制字符串，$\\mathbf{x}=(x_{1},x_{2})\\in\\{0,1\\}^{2}$\n- **相互作用**：$K=1$，每个位点与另一个位点相互作用。\n- **适应度函数**：$W(\\mathbf{x})=\\frac{1}{2}\\left[w_{1}(x_{1},x_{2})+w_{2}(x_{2},x_{1})\\right]$\n- **实例A贡献值**：\n  $w_{1}(0,0)=2.0$, $w_{1}(1,0)=3.2$, $w_{1}(0,1)=3.5$, $w_{1}(1,1)=2.6$\n  $w_{2}(0,0)=2.0$, $w_{2}(0,1)=3.5$, $w_{2}(1,0)=2.8$, $w_{2}(1,1)=3.4$\n- **实例B贡献值**：\n  $w_{1}(0,0)=3.8$, $w_{1}(1,0)=2.7$, $w_{1}(0,1)=2.9$, $w_{1}(1,1)=4.7$\n  $w_{2}(0,0)=4.2$, $w_{2}(0,1)=2.1$, $w_{2}(1,0)=2.3$, $w_{2}(1,1)=4.3$\n- **任务1**：计算每个实例的 $W(0,0)$, $W(1,0)$, $W(0,1)$, $W(1,1)$。\n- **任务2**：确定上位性的类型（符号上位性，互反符号上位性）。\n- **任务3**：计算每个实例的上位性偏差 $\\varepsilon \\equiv W(0,0)+W(1,1)-W(0,1)-W(1,0)$。\n- **最终输出**：以单行矩阵形式报告有序对 $\\left(\\varepsilon_{\\text{A}},\\varepsilon_{\\text{B}}\\right)$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它基于 Stuart Kauffman 提出的标准NK模型，该模型是复杂自适应系统理论的基石。适应度、上位性的定义以及数学框架在理论生物学和演化计算领域都是标准且成熟的。该问题是良构的，提供了执行所需计算的所有必要数值数据和明确公式。语言客观而精确。该问题是自洽和一致的，没有矛盾或信息缺失。没有违反科学原理或逻辑之处。\n\n### 步骤3：结论与行动\n该问题被判定为有效。将提供解答。\n\n### 解题过程推导\n\n解题过程通过执行问题陈述中指定的三个任务来进行。\n\n#### 任务1：适应度计算\n\n基因型 $\\mathbf{x}=(x_1, x_2)$ 的总适应度由 $W(\\mathbf{x})=\\frac{1}{2}\\left[w_{1}(x_{1},x_{2})+w_{2}(x_{2},x_{1})\\right]$ 给出。我们将此公式应用于实例A和实例B的所有四种可能的基因型。\n\n**实例A：**\n四种基因型的适应度值为：\n$W_A(0,0) = \\frac{1}{2}\\left[w_{1}(0,0) + w_{2}(0,0)\\right] = \\frac{1}{2}(2.0 + 2.0) = \\frac{1}{2}(4.0) = 2.0$\n$W_A(1,0) = \\frac{1}{2}\\left[w_{1}(1,0) + w_{2}(0,1)\\right] = \\frac{1}{2}(3.2 + 3.5) = \\frac{1}{2}(6.7) = 3.35$\n$W_A(0,1) = \\frac{1}{2}\\left[w_{1}(0,1) + w_{2}(1,0)\\right] = \\frac{1}{2}(3.5 + 2.8) = \\frac{1}{2}(6.3) = 3.15$\n$W_A(1,1) = \\frac{1}{2}\\left[w_{1}(1,1) + w_{2}(1,1)\\right] = \\frac{1}{2}(2.6 + 3.4) = \\frac{1}{2}(6.0) = 3.0$\n\n**实例B：**\n四种基因型的适应度值为：\n$W_B(0,0) = \\frac{1}{2}\\left[w_{1}(0,0) + w_{2}(0,0)\\right] = \\frac{1}{2}(3.8 + 4.2) = \\frac{1}{2}(8.0) = 4.0$\n$W_B(1,0) = \\frac{1}{2}\\left[w_{1}(1,0) + w_{2}(0,1)\\right] = \\frac{1}{2}(2.7 + 2.1) = \\frac{1}{2}(4.8) = 2.4$\n$W_B(0,1) = \\frac{1}{2}\\left[w_{1}(0,1) + w_{2}(1,0)\\right] = \\frac{1}{2}(2.9 + 2.3) = \\frac{1}{2}(5.2) = 2.6$\n$W_B(1,1) = \\frac{1}{2}\\left[w_{1}(1,1) + w_{2}(1,1)\\right] = \\frac{1}{2}(4.7 + 4.3) = \\frac{1}{2}(9.0) = 4.5$\n\n#### 任务2：上位性分析\n\n如果一个位点上突变的适应度效应的符号根据另一位点上的等位基因而改变，则存在符号上位性。当两个位点的突变都如此时，发生互反符号上位性。\n\n**实例A：**\n位点1上突变（$0 \\to 1$）的效应：\n- 在背景 $x_2=0$ 下：$\\Delta W_{1|0} = W_A(1,0) - W_A(0,0) = 3.35 - 2.0 = 1.35$（正）\n- 在背景 $x_2=1$ 下：$\\Delta W_{1|1} = W_A(1,1) - W_A(0,1) = 3.0 - 3.15 = -0.15$（负）\n由于符号不同，位点1存在符号上位性。\n\n位点2上突变（$0 \\to 1$）的效应：\n- 在背景 $x_1=0$ 下：$\\Delta W_{2|0} = W_A(0,1) - W_A(0,0) = 3.15 - 2.0 = 1.15$（正）\n- 在背景 $x_1=1$ 下：$\\Delta W_{2|1} = W_A(1,1) - W_A(1,0) = 3.0 - 3.35 = -0.35$（负）\n由于符号不同，位点2存在符号上位性。\n由于两个位点都表现出符号上位性，**实例A表现出互反符号上位性**。\n\n**实例B：**\n位点1上突变（$0 \\to 1$）的效应：\n- 在背景 $x_2=0$ 下：$\\Delta W_{1|0} = W_B(1,0) - W_B(0,0) = 2.4 - 4.0 = -1.6$（负）\n- 在背景 $x_2=1$ 下：$\\Delta W_{1|1} = W_B(1,1) - W_B(0,1) = 4.5 - 2.6 = 1.9$（正）\n由于符号不同，位点1存在符号上位性。\n\n位点2上突变（$0 \\to 1$）的效应：\n- 在背景 $x_1=0$ 下：$\\Delta W_{2|0} = W_B(0,1) - W_B(0,0) = 2.6 - 4.0 = -1.4$（负）\n- 在背景 $x_1=1$ 下：$\\Delta W_{2|1} = W_B(1,1) - W_B(1,0) = 4.5 - 2.4 = 2.1$（正）\n由于符号不同，位点2存在符号上位性。\n由于两个位点都表现出符号上位性，**实例B也表现出互反符号上位性**。\n\n#### 任务3：上位性偏差计算\n\n上位性偏差 $\\varepsilon$ 使用公式 $\\varepsilon = W(0,0) + W(1,1) - W(0,1) - W(1,0)$ 计算。\n\n**实例A：**\n使用任务1中计算的适应度值：\n$\\varepsilon_A = W_A(0,0) + W_A(1,1) - W_A(0,1) - W_A(1,0)$\n$\\varepsilon_A = 2.0 + 3.0 - 3.15 - 3.35 = 5.0 - 6.5 = -1.5$\n\n**实例B：**\n使用任务1中计算的适应度值：\n$\\varepsilon_B = W_B(0,0) + W_B(1,1) - W_B(0,1) - W_B(1,0)$\n$\\varepsilon_B = 4.0 + 4.5 - 2.6 - 2.4 = 8.5 - 5.0 = 3.5$\n\n问题要求报告有序对 $(\\varepsilon_A, \\varepsilon_B)$。结果为 $(-1.5, 3.5)$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -1.5  3.5 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理论结果提供了强有力的预测，但通过模拟来验证它们能深化我们的理解。在此实践中 ，你将编写程序来构建 NK 景观并以计算方式找到其局部最大值。这将使你能够数值化地检验关于简单加性（$K=0$）模型和最大化复杂的“纸牌屋”（$K=N-1$）模型的经典理论预测。",
            "id": "4148406",
            "problem": "考虑NK适应度景观模型，其中基因型是长度为 $N$ 的二进制字符串，基因型 $\\mathbf{x} \\in \\{0,1\\}^N$ 的适应度 $F(\\mathbf{x})$ 是 $N$ 个局部贡献函数的平均值，每个函数依赖于 $K+1$ 个比特位。对于每个基因座 $i \\in \\{0,\\dots,N-1\\}$，令 $\\mathcal{N}_i$ 为其大小为 $K+1$ 的邻域（我们将使用环上的相邻邻域：$\\mathcal{N}_i = \\{i,i+1,\\dots,i+K\\}$，索引对 $N$ 取模）。每个贡献函数 $f_i:\\{0,1\\}^{K+1}\\to \\mathbb{R}$ 都是从一个连续分布中独立抽取的。基因型 $\\mathbf{x}$ 的适应度定义为\n$$\nF(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i\\left(\\mathbf{x}_{\\mathcal{N}_i}\\right),\n$$\n其中 $\\mathbf{x}_{\\mathcal{N}_i}$ 表示 $\\mathbf{x}$ 在 $\\mathcal{N}_i$ 中的索引上按固定顺序排列的子串。\n\n如果一个基因型 $\\mathbf{x}$ 的适应度 $F(\\mathbf{x})$ 大于所有与 $\\mathbf{x}$ 汉明距离为 1 的 $\\mathbf{y}$ 的适应度（即所有单比特邻居），则该基因型是一个局部最大值。\n\n你的任务是编写一个程序，对于较小的 $N$ 和 $K$，枚举特定实例的所有基因型和局部最大值，并从数值上验证从第一性原理推导出的理论预测。你必须实现以下测试套件，每个案例都需产生一个量化的结果。\n\n定义和约束：\n- 基因型枚举必须包括所有 $2^N$ 个二进制字符串。\n- 邻域必须如 NK 模型中所述，在环上是相邻的。\n- 随机值必须使用每个测试的固定种子从 $[0,1]$ 上的连续均匀分布中抽取，以确保可复现性。\n- 在 $K=N-1$ 的特殊“纸牌屋”极限情况下，将每个基因型 $\\mathbf{x}$ 的适应度值 $F(\\mathbf{x})$ 视为独立的同分布连续随机变量。\n\n测试套件：\n1. 加性景观案例 ($K=0$)：\n   - 参数：$N=5$，$K=0$，随机种子 $s=12345$。\n   - 构建：对于每个基因座 $i$，独立抽取 $f_i(0)$ 和 $f_i(1)$，并设置 $F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i(x_i)$。\n   - 输出规格：返回一个列表，其中包含单个实例中找到的局部最大值的整数计数、加性案例的整数理论预测值以及一个指示两者是否相等的布尔值。\n\n2. “纸牌屋”极限：\n   - 参数：$N=8$，$K=7$，独立实例数 $R=3000$，随机种子 $s=67890$。\n   - 构建：对于每个实例，将所有 $2^N$ 个基因型的 $F(\\mathbf{x})$ 赋值为在 $[0,1]$ 上的独立均匀随机抽样值，然后通过完全枚举和邻居比较来计算局部最大值。\n   - 输出规格：返回一个列表，其中包含 $R$ 个实例中局部最大值的浮点数平均比例、浮点数理论比例以及经验平均值与理论值之间的浮点数绝对差。\n\n3. “纸牌屋”极限（小边界情况）：\n   - 参数：$N=2$，$K=1$，独立实例数 $R=50000$，随机种子 $s=13579$。\n   - 构建：与“纸牌屋”案例一样，为每个基因型和实例独立分配 $F(\\mathbf{x})$，计算局部最大值，并计算各实例中该比例的平均值。\n   - 输出规格：返回一个列表，其中包含 $R$ 个实例中局部最大值的浮点数平均比例、浮点数理论比例以及浮点数绝对差。\n\n4. 加性景观案例（平凡边界）：\n   - 参数：$N=1$，$K=0$，随机种子 $s=24680$。\n   - 构建：与加性案例一样，抽取 $f_0(0)$ 和 $f_0(1)$ 并设置 $F(\\mathbf{x}) = f_0(x_0)$。\n   - 输出规格：返回一个列表，其中包含局部最大值的整数计数、加性案例的整数理论预测值以及一个指示两者是否相等的布尔值。\n\n需要数值验证的理论预测：\n- 对于加性景观 ($K=0$)，预测局部最大值的确切数量。\n- 对于“纸牌屋”极限 ($K=N-1$)，预测局部最大值的期望比例以及期望数量（作为 $N$ 的函数）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的输出本身就是上述指定格式的列表。例如： \"[[result_case1],[result_case2],[result_case3],[result_case4]]\"。\n- 所有返回的值必须是以下类型之一：布尔值、整数、浮点数或这些类型的列表。不允许有其他输出。",
            "solution": "用户提供的问题已经过验证，被确定为来自复杂自适应系统领域的、一个适定且有科学依据的问题。它要求对NK适应度景观模型的理论特性进行数值验证。问题陈述提供了所有必要的定义、参数和约束，足以得出一个唯一且有意义的解决方案。\n\n解决方案分为两部分：首先，推导在指定模型极限下局部最大值数量的理论预测；其次，描述用于生成数值结果以进行比较的计算算法。\n\n**理论预测**\n\nNK模型将基因型 $\\mathbf{x} \\in \\{0,1\\}^N$ 的适应度定义为 $N$ 个局部贡献函数的平均值，$F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i\\left(\\mathbf{x}_{\\mathcal{N}_i}\\right)$。如果一个基因型 $\\mathbf{x}$ 的适应度严格大于其所有 $N$ 个单比特翻转邻居的适应度，则该基因型是一个局部最大值。我们分析所要求的两种特殊情况。\n\n1.  **加性景观 ($K=0$)**\n\n    当上位性参数 $K=0$ 时，每个基因座 $i$ 的邻域就是其自身，$\\mathcal{N}_i = \\{i\\}$。适应度函数简化为加性形式：\n    $$F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i(x_i)$$\n    其中 $f_i(x_i)$ 是基因座 $i$ 上等位基因 $x_i$ 的适应度贡献。\n\n    令 $\\mathbf{y}^{(j)}$ 为通过翻转 $\\mathbf{x}$ 的第 $j$ 个比特位得到的基因型。适应度差异为：\n    $$F(\\mathbf{x}) - F(\\mathbf{y}^{(j)}) = \\frac{1}{N}\\left(f_j(x_j) - f_j(1-x_j)\\right)$$\n    为使 $\\mathbf{x}$ 成为局部最大值，必须对所有 $j \\in \\{0, \\dots, N-1\\}$ 满足 $F(\\mathbf{x}) > F(\\mathbf{y}^{(j)})$。这意味着对于每个基因座 $j$，条件 $f_j(x_j) > f_j(1-x_j)$ 必须成立。\n\n    对于每个基因座 $j$，值 $f_j(0)$ 和 $f_j(1)$ 是从一个连续分布中抽取的。因此，其中一个值大于另一个的概率为 1。\n    - 如果 $f_j(0) > f_j(1)$，则只有当 $x_j=0$ 时条件才成立。\n    - 如果 $f_j(1) > f_j(0)$，则只有当 $x_j=1$ 时条件才成立。\n\n    无论在哪种情况下，对于每个基因座 $j$，都有一个唯一的等位基因值可以最大化局部适应度贡献 $f_j$。由于该条件必须对所有 $N$ 个基因座独立成立，因此有且仅有一个基因型能同时满足所有 $N$ 个条件。这个基因型是通过在每个基因座上选择优势等位基因来构建的。\n\n    因此，对于加性案例 ($K=0$)，且适应度贡献是从连续分布中抽取的情况，恰好有 1 个局部最大值。\n\n2.  **“纸牌屋”极限 ($K=N-1$)**\n\n    在 $K=N-1$ 的极限下，这被称为“纸牌屋”(HoC)模型，所有 $2^N$ 个基因型的适应度值 $F(\\mathbf{x})$ 被假定为独立同分布(i.i.d.)的随机变量。问题指定从 $[0,1]$ 上的连续均匀分布中抽取这些值。\n\n    对于一个给定的基因型 $\\mathbf{x}$ 要成为局部最大值，其适应度 $F(\\mathbf{x})$ 必须大于其所有 $N$ 个邻居的适应度值。设邻居为 $\\mathbf{y}_1, \\dots, \\mathbf{y}_N$。条件是对于所有 $k \\in \\{1, \\dots, N\\}$，有 $F(\\mathbf{x}) > F(\\mathbf{y}_k)$。\n\n    适应度值集合 $\\{F(\\mathbf{x}), F(\\mathbf{y}_1), \\dots, F(\\mathbf{y}_N)\\}$ 由从连续分布中抽取的 $N+1$ 个独立同分布样本组成。由于独立同分布的特性，这些值的秩的任何排列都是等可能的。因此，任何特定值（在此情况下为 $F(\\mathbf{x})$）是该集合中最大值的概率为 $\\frac{1}{N+1}$。\n\n    这代表了任何单个基因型是局部最大值的概率。根据期望的线性性，在整个包含 $2^N$ 个基因型的景观中，局部最大值的期望数量是基因型总数乘以这个概率：\n    $$E[\\text{Number of Local Maxima}] = 2^N \\times \\frac{1}{N+1} = \\frac{2^N}{N+1}$$\n    作为局部最大值的基因型的期望*比例*就是这个概率：\n    $$E[\\text{Fraction of Local Maxima}] = \\frac{1}{N+1}$$\n    我们对案例 2 和 3 的数值模拟将验证这个理论比例。对于 $N=8$，理论比例是 $\\frac{1}{9}$。对于 $N=2$，它是 $\\frac{1}{3}$。\n\n**算法设计与实现**\n\n该验证通过实现与两种模型变体相对应的两个不同的模拟程序来执行。\n\n**加性景观 ($K=0$) 模拟 (案例 1 和 4)**\n\n1.  **初始化**：对于给定的 $N$ 和随机种子 $s$，初始化一个随机数生成器。\n2.  **适应度景观构建**：创建一个大小为 $N \\times 2$ 的适应度贡献表。每个条目 $f_{i,b}$（对于基因座 $i$ 和等位基因 $b \\in \\{0, 1\\}$）都是从 $U[0,1]$ 中独立抽取的。\n3.  **适应度评估**：枚举整个包含 $2^N$ 个基因型的景观。对于每个基因型 $\\mathbf{x}=(x_0, \\dots, x_{N-1})$，其适应度计算为 $F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_{i, x_i}$。所有基因型的适应度值都被存储起来。\n4.  **局部最大值识别**：测试每个基因型 $\\mathbf{x}$ 是否为局部最优。将其适应度 $F(\\mathbf{x})$ 与其 $N$ 个邻居的预计算适应度值进行比较。如果 $F(\\mathbf{x})$ 严格大于所有邻居的适应度，则局部最大值计数器加一。\n5.  **输出**：该过程返回一个列表，其中包含局部最大值的最终整数计数、理论预测值 1，以及一个指示经验计数是否与理论匹配的布尔值。\n\n**“纸牌屋” ($K=N-1$) 模拟 (案例 2 和 3)**\n\n1.  **初始化**：对于给定的 $N$、重复次数 $R$ 和种子 $s$，初始化一个随机数生成器。准备一个空列表以存储每个实例的最大值比例。\n2.  **蒙特卡洛循环**：模拟迭代 $R$ 次。在每次迭代中：\n    a.  **适应度景观构建**：通过从 $U[0,1]$ 中抽取 i.i.d. 样本，生成一个包含 $2^N$ 个适应度值的数组。每个基因型（由其从 $0$ 到 $2^N-1$ 的整数索引表示）被赋予这些随机适应度值之一。\n    b.  **局部最大值识别**：算法遍历每个基因型索引 $i \\in \\{0, \\dots, 2^N-1\\}$。将适应度 $F_i$ 与其 $N$ 个邻居的适应度进行比较。基因型 $i$ 的一个邻居由索引 $i \\oplus 2^j$（按位异或）标识，其中 $j \\in \\{0, \\dots, N-1\\}$。如果 $F_i$ 是这个集合中的严格最大值，则当前实例的计数器加一。\n    c.  **比例计算**：计算该实例的局部最大值比例为（计数值 / $2^N$）并存储。\n3.  **结果聚合**：在所有 $R$ 个实例完成后，计算存储比例的平均值。\n4.  **输出**：该过程返回一个列表，其中包含局部最大值的平均比例、理论比例 $\\frac{1}{N+1}$，以及这两个值之间的绝对差。\n\n提供的 Python 代码实现了这些算法，以生成四个测试用例的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve_additive_case(N, seed):\n    \"\"\"\n    Solves for the K=0 additive landscape case.\n    - Constructs the landscape based on per-locus contributions.\n    - Enumerates all genotypes and finds local maxima.\n    - Returns the empirical count, theoretical count, and a boolean for equality.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # f_table[i, b] is the fitness contribution f_i(b) for locus i and bit b.\n    f_table = rng.uniform(size=(N, 2))\n    \n    num_genotypes = 1  N\n    genotypes = []\n    # Generate all 2^N genotypes as tuples of (0,1)\n    for i in range(num_genotypes):\n        genotype = tuple((i >> (N - 1 - j))  1 for j in range(N))\n        genotypes.append(genotype)\n\n    # Calculate and store fitness for all genotypes\n    fitness_map = {}\n    for g in genotypes:\n        fitness = np.sum(f_table[i, g[i]] for i in range(N)) / N\n        fitness_map[g] = fitness\n\n    # Count local maxima\n    local_maxima_count = 0\n    for g in genotypes:\n        current_fitness = fitness_map[g]\n        is_local_max = True\n        for i in range(N):\n            neighbor_list = list(g)\n            neighbor_list[i] = 1 - neighbor_list[i]\n            neighbor = tuple(neighbor_list)\n            if current_fitness = fitness_map[neighbor]:\n                is_local_max = False\n                break\n        if is_local_max:\n            local_maxima_count += 1\n            \n    theoretical_count = 1\n    return [local_maxima_count, theoretical_count, local_maxima_count == theoretical_count]\n\ndef solve_hoc_case(N, R, seed):\n    \"\"\"\n    Solves for the K=N-1 House-of-Cards limit case.\n    - Runs R independent simulations.\n    - In each simulation, fitness values are i.i.d. draws.\n    - Returns the average fraction of maxima, theoretical fraction, and absolute difference.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    num_genotypes = 1  N\n    \n    fractions = []\n    for _ in range(R):\n        # For each instance, generate a new random landscape\n        fitness_values = rng.uniform(size=num_genotypes)\n        \n        instance_maxima_count = 0\n        for i in range(num_genotypes):\n            current_fitness = fitness_values[i]\n            is_local_max = True\n            for j in range(N):\n                # Neighbor's index is found by flipping the j-th bit\n                neighbor_idx = i ^ (1  j)\n                if current_fitness = fitness_values[neighbor_idx]:\n                    is_local_max = False\n                    break\n            if is_local_max:\n                instance_maxima_count += 1\n        \n        fractions.append(instance_maxima_count / num_genotypes)\n\n    avg_fraction = np.mean(fractions)\n    theoretical_fraction = 1.0 / (N + 1)\n    abs_diff = np.abs(avg_fraction - theoretical_fraction)\n    \n    return [avg_fraction, theoretical_fraction, abs_diff]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_suite = [\n        # 1. Additive landscape case ($K=0$)\n        {'func': solve_additive_case, 'params': {'N': 5, 'seed': 12345}},\n        # 2. House-of-Cards limit\n        {'func': solve_hoc_case, 'params': {'N': 8, 'R': 3000, 'seed': 67890}},\n        # 3. House-of-Cards limit (small boundary case)\n        {'func': solve_hoc_case, 'params': {'N': 2, 'R': 50000, 'seed': 13579}},\n        # 4. Additive landscape case (trivial boundary)\n        {'func': solve_additive_case, 'params': {'N': 1, 'seed': 24680}},\n    ]\n\n    results = []\n    for test in test_suite:\n        result = test['func'](**test['params'])\n        results.append(result)\n\n    # The spec requires a specific print format. The Python default for a list\n    # includes spaces, which we will use as per the provided template code.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}