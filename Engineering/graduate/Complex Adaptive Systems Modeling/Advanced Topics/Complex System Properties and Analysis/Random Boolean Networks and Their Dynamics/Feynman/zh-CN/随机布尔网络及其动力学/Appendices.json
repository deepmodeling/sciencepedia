{
    "hands_on_practices": [
        {
            "introduction": "在深入研究大型网络的动力学之前，理解单个节点所固有的复杂性至关重要。本练习旨在量化一个节点可能表现出的行为总数。通过推导具有 $K$ 个输入的节点的独立布尔函数的数量，您将揭示一种双指数增长关系，它使得对随机布尔网络“规则空间”的穷举搜索在计算上变得不可行，而这个基本概念也正是许多统计方法在该领域得以发展的动因。",
            "id": "4138464",
            "problem": "考虑一个随机布尔网络（RBN），其定义为一个包含 $N$ 个节点的有向图，其中每个节点根据其 $K$ 个输入的布尔函数同步更新，输入来自 $K$ 个预先指定的入邻居节点的状态。仅使用“一个关于 $K$ 个输入的布尔函数是从笛卡尔积 $\\{0,1\\}^{K}$ 到 $\\{0,1\\}$ 的映射”这一定义，从第一性原理出发，推导一个固定入度为 $K$ 的单个节点可用的不同布尔更新函数的精确数量。以一个关于 $K$ 的封闭形式解析表达式给出最终计数。\n\n然后，从业界规则选择的模型空间复杂性角度，解释该计数如何随 $K$ 缩放，并阐明这种缩放对RBN建模中假设空间大小的影响。除了所要求的封闭形式表达式外，不要计算任何额外的数值。最终答案必须是关于 $K$ 的单个封闭形式表达式，不带单位。",
            "solution": "在尝试解答之前，对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 系统：一个随机布尔网络（RBN）。\n- 节点数：$N$。\n- 更新动态：同步。\n- 节点属性：每个节点有固定的入度 $K$，其输入来自 $K$ 个预先指定的入邻居节点。\n- 每个节点的状态空间：$\\{0, 1\\}$。\n- 布尔更新函数的定义：从笛卡尔积 $\\{0,1\\}^{K}$ 到 $\\{0,1\\}$ 的一个映射。\n- 目标1：从第一性原理出发，推导一个入度为 $K$ 的单个节点可用的不同布尔更新函数的精确数量。\n- 目标2：以一个关于 $K$ 的封闭形式解析表达式给出结果。\n- 目标3：解释该计数随 $K$ 的缩放规律，及其对RBN建模中假设空间大小的影响。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准评估问题的有效性。\n\n- **科学基础**：该问题基于成熟的复杂系统理论，特别是 Stuart Kauffman 引入的随机布尔网络。布尔网络、其组件和布尔函数的定义都是标准的且数学上是正确的。\n- **良定性**：该问题是良定的。它要求基于一个清晰而完整的定义推导一个特定的组合量。该问题导向一个唯一的、可推导的且有意义的解析表达式。\n- **客观性**：该问题以精确、客观的语言陈述，没有歧义或主观断言。\n\n该问题不存在任何无效性缺陷。它是科学合理的、自洽的且可形式化的。因此，该问题被视为**有效**。\n\n### 步骤3：进行求解\n\n一个具有 $K$ 个输入的单个节点的布尔更新函数被形式化地定义为一个函数 $f$，它将所有可能的输入状态集合映射到所有可能的输出状态集合。输入集是笛卡尔积 $\\{0,1\\}^K$，输出集是 $\\{0,1\\}$。因此，我们考虑的是形如 $f: \\{0,1\\}^K \\to \\{0,1\\}$ 的函数。\n\n为了确定这类不同函数的总数，我们首先必须确定定义域的大小，即唯一输入组合的数量。该节点接收 $K$ 个输入，其中每个输入可以独立地取两个值之一，即 $0$ 或 $1$。根据计数中的乘法法则，不同输入组合的总数就是定义域集合 $\\{0,1\\}^K$ 的大小。这个大小由下式给出：\n$$\n|\\{0,1\\}^K| = 2 \\times 2 \\times \\dots \\times 2 \\text{ ($K$ times)} = 2^K\n$$\n让我们将可能的输入配置数量表示为 $M = 2^K$。一个特定的布尔函数由其对这 $M$ 种可能的输入配置中的每一种的输出值来定义。这可以被看作是一个有 $M$ 行的真值表，其中每一行对应于来自 $\\{0,1\\}^K$ 的一个唯一输入向量。对于这 $M$ 行中的每一行，该函数都必须指定一个输出值。输出值可以是 $0$ 或 $1$。\n\n考虑构建一个单一、唯一的布尔函数。\n对于第一个输入配置（真值表的第一行），输出值有 $2$ 种可能的选择（$0$ 或 $1$）。\n对于第二个输入配置，同样有 $2$ 种独立的输出值选择。\n这个模式对所有 $M = 2^K$ 种可能的输入配置都适用。\n\n由于对于任何给定输入配置的输出值的选择都独立于任何其他输入配置的输出值的选择，因此定义该函数的总方式数是每个输入配置选择数的乘积。我们在 $2$ 个选项之间做出选择，并且我们这样做 $M = 2^K$ 次。\n\n因此，不同布尔函数的总数，我们记为 $\\mathcal{F}_K$，是：\n$$\n\\mathcal{F}_K = \\underbrace{2 \\times 2 \\times \\dots \\times 2}_{M \\text{ times}} = 2^M\n$$\n将 $M$ 的表达式代回，我们得到关于 $K$ 个输入的布尔函数的不同数量是：\n$$\n\\mathcal{F}_K = 2^{2^K}\n$$\n这就是一个入度为 $K$ 的节点可用的不同布尔更新函数数量的封闭形式解析表达式。\n\n对这一结果的解释对于理解RBN的复杂性至关重要。数量 $2^{2^K}$ 相对于 $K$ 表现出双指数增长。这是一个极其迅速的增长率。\n- 当 $K=1$ 时，有 $2^{2^1} = 2^2 = 4$ 个函数。\n- 当 $K=2$ 时，有 $2^{2^2} = 2^4 = 16$ 个函数。\n- 当 $K=3$ 时，有 $2^{2^3} = 2^8 = 256$ 个函数。\n- 当 $K=4$ 时，有 $2^{2^4} = 2^{16} = 65,536$ 个函数。\n- 当 $K=5$ 时，有 $2^{2^5} = 2^{32} \\approx 4.3 \\times 10^9$ 个函数。\n\n这种组合爆炸对于RBN建模中假设空间的大小具有深远的影响。在尝试通过拟合RBN来建模一个真实系统（如基因调控网络）时，必须为每个节点指定更新规则（即布尔函数）。所有 $2^{2^K}$ 个函数的集合构成了具有 $K$ 个输入的单个节点行为的可能假设空间。即使对于较小的 $K$，这个空间的巨大规模也使得对“正确”或最优函数的穷举搜索在计算上是不可行的。这是网络推断和系统辨识领域的一个主要挑战。因此，建模工作必须采用策略来管理这种复杂性，例如从函数空间中随机抽样（如 Kauffman 最初的NK模型中那样），将搜索限制在特定的函数子类（例如，渠道化函数或单调函数），或使用启发式优化算法来导航这个巨大的搜索空间。双指数缩放从根本上限制了对可表示为布尔网络的系统的精确动态进行逆向工程的可行性。",
            "answer": "$$\n\\boxed{2^{2^K}}\n$$"
        },
        {
            "introduction": "网络的集体行为与其连接模式或拓扑结构密切相关。这个实践提供了一个清晰具体的例子，说明一个特定的结构基序——正反馈回路——如何从根本上改变网络的动力学。通过比较一个无环网络和一个包含简单反馈回路的网络，您将亲眼看到这些回路如何产生多个稳定状态，这是许多复杂系统中实现记忆和决策的关键机制。",
            "id": "4138458",
            "problem": "考虑一个同步随机布尔网络 (RBN)，它被定义为状态空间 $\\{0,1\\}^{N}$ 上的一个离散时间动力系统，其更新映射 $F:\\{0,1\\}^{N}\\to\\{0,1\\}^{N}$ 通过节点 $x_{i}$（其中 $i\\in\\{1,\\dots,N\\}$）的布尔函数 $f_{i}:\\{0,1\\}^{N}\\to\\{0,1\\}$ 以分量形式指定。不动点是一个状态 $x\\in\\{0,1\\}^{N}$，满足 $F(x)=x$。该网络的有向依赖图为每个 $x_{i}$ 设一个节点，如果 $f_{i}$ 依赖于 $x_{j}$，则存在一条从 $x_{j}$ 到 $x_{i}$ 的有向边。无环依赖图是一个有向无环图 (DAG)，它允许进行拓扑排序。\n\n你将分析在一个原本无环的网络中添加单个正反馈回路如何能产生多个不动点。仅使用上述定义以及有向无环图允许拓扑排序这一事实。不要引用超出此基础范围的任何专门定理。\n\n请研究以下小型说明性示例。设 $N=3$，并考虑一个具有以下更新函数的无环网络：\n$$\nf_{1}(x)=1,\\qquad f_{2}(x)=x_{1},\\qquad f_{3}(x)=x_{2}.\n$$\nA部分：仅使用不动点的定义和有向无环图存在拓扑排序的性质，从第一性原理出发，论证该无环网络有唯一的不动点。明确计算出该不动点。\n\n现在，通过仅修改节点 $x_{1}$ 和 $x_{2}$ 的函数来创建一个正反馈回路，修改为：\n$$\nf_{1}(x)=x_{2},\\qquad f_{2}(x)=x_{1},\n$$\n同时保持 $f_{3}(x)=x_{2}$ 不变。得到的依赖图恰好有一个由 $x_{1}\\leftrightarrow x_{2}$ 形成的环，且没有否定（negation），这是一个正反馈回路。\n\nB部分：仅使用不动点定义 $F(x)=x$ 和给定的更新函数，证明修改后的网络有多个不动点，并明确计算出所有不动点。\n\n答案规范：\n- 你的最终数值答案必须包含在B部分中找到的所有不动点状态的列表，按 $(x_{1},x_{2},x_{3})$ 的字典序排列，其中状态 $x_{1}=x_{2}=x_{3}=0$ 排在最前面。\n- 使用 $\\mathrm{pmatrix}$ 环境将最终答案表示为单个行矩阵，按 $(x_{1},x_{2},x_{3})$ 的顺序串联每个不动点的条目。\n- 无需四舍五入。不涉及单位。",
            "solution": "该问题经验证是自洽的，科学上基于离散动力系统理论，并且是良构的。求解所需的所有定义和条件都已明确给出。\n\n随机布尔网络（RBN）的一个不动点是一个状态 $x = (x_1, x_2, \\dots, x_N) \\in \\{0,1\\}^N$，它在更新映射 $F$ 的作用下保持不变。该条件表示为 $F(x) = x$，等价于以下 $N$ 个联立布尔方程组：\n$$\n\\begin{cases}\nx_1 = f_1(x_1, \\dots, x_N) \\\\\nx_2 = f_2(x_1, \\dots, x_N) \\\\\n\\vdots \\\\\nx_N = f_N(x_1, \\dots, x_N)\n\\end{cases}\n$$\n我们将通过求解该方程组来分析问题中提出的两种情况。\n\nA部分：无环网络\n\n该网络为 $N=3$ 定义，更新函数如下：\n$$\nf_1(x) = 1\n$$\n$$\nf_2(x) = x_1\n$$\n$$\nf_3(x) = x_2\n$$\n不动点条件 $F(x)=x$ 转化为状态向量 $x=(x_1, x_2, x_3)$ 的以下方程组：\n$$\nx_1 = 1\n$$\n$$\nx_2 = x_1\n$$\n$$\nx_3 = x_2\n$$\n该网络的依赖图规则是：如果 $f_i$ 依赖于 $x_j$，则存在一条从 $x_j$ 到 $x_i$ 的有向边。\n- $f_1$ 没有依赖项。\n- $f_2$ 依赖于 $x_1$，所以有一条边 $x_1 \\to x_2$。\n- $f_3$ 依赖于 $x_2$，所以有一条边 $x_2 \\to x_3$。\n得到的图是有向路径 $x_1 \\to x_2 \\to x_3$。这是一个有向无环图（DAG）。\n\n根据前提，有向无环图允许对其节点进行拓扑排序，即一种排序方式，使得对于从节点 $u$到节点 $v$ 的每一条有向边，$u$ 在排序中都位于 $v$ 之前。对于此图，唯一的拓扑排序是 $(x_1, x_2, x_3)$。\n\n我们可以使用此排序来依次求解不动点的值。排序中任何节点的值仅依赖于排在它之前的节点的值。\n\n1. 从拓扑排序中的第一个节点 $x_1$ 开始。$x_1$ 的不动点方程是 $x_1 = 1$。该方程独立于所有其他变量。其解是唯一确定的：$x_1 = 1$。\n\n2. 接着是下一个节点 $x_2$。不动点方程是 $x_2 = x_1$。由于上一步已唯一确定 $x_1$ 的值为 $1$，我们代入此值发现 $x_2$ 也被唯一确定：$x_2 = 1$。\n\n3. 接着是最后一个节点 $x_3$。不动点方程是 $x_3 = x_2$。由于刚刚已唯一确定 $x_2$ 的值为 $1$，我们发现 $x_3$ 也被唯一确定：$x_3 = 1$。\n\n因为该方程组可以按照拓扑顺序依次求解，并且每一步都为相应变量得出了唯一的值，所以解是唯一的。因此，该无环网络只有一个不动点。这个不动点是状态 $(x_1, x_2, x_3) = (1, 1, 1)$。\n\nB部分：带正反馈回路的网络\n\n通过更改 $x_1$ 和 $x_2$ 的更新函数来修改网络：\n$$\nf_1(x) = x_2\n$$\n$$\nf_2(x) = x_1\n$$\n$$\nf_3(x) = x_2\n$$\n不动点条件 $F(x)=x$ 现在对应于以下方程组：\n$$\nx_1 = x_2\n$$\n$$\nx_2 = x_1\n$$\n$$\nx_3 = x_2\n$$\n这个修改后网络的依赖图如下：\n- $f_1$ 依赖于 $x_2$，所以有一条边 $x_2 \\to x_1$。\n- $f_2$ 依赖于 $x_1$，所以有一条边 $x_1 \\to x_2$。\n- $f_3$ 依赖于 $x_2$，所以有一条边 $x_2 \\to x_3$。\n该图包含环 $x_1 \\to x_2 \\to x_1$，因此不是一个有向无环图（DAG）。对所有节点进行拓扑排序是不可能的，我们无法像A部分那样依次求解节点的值。前两个方程 $x_1 = x_2$ 和 $x_2 = x_1$ 是耦合的，必须同时求解。\n\n关于 $x_1$ 和 $x_2$ 的两个方程在逻辑上是等价的。它们都表示约束 $x_1 = x_2$。由于 $x_1$ 和 $x_2$ 是 $\\{0, 1\\}$ 中的布尔变量，该约束不会产生唯一的解。相反，它对 $(x_1, x_2)$ 这对变量有两个可能的解：\n- 情况1：$x_1 = 0$ 且 $x_2 = 0$。\n- 情况2：$x_1 = 1$ 且 $x_2 = 1$。\n\n对于这两种情况中的每一种，我们使用其不动点方程 $x_3 = x_2$ 来确定剩余变量 $x_3$ 的值。\n\n- 在情况1中，$x_1 = 0$ 且 $x_2 = 0$，第三个方程给出 $x_3 = 0$。这得出了不动点状态 $(0, 0, 0)$。我们可以验证这一点：$F(0,0,0) = (f_1(0,0,0), f_2(0,0,0), f_3(0,0,0)) = (0, 0, 0)$，这与状态本身相等。\n\n- 在情况2中，$x_1 = 1$ 且 $x_2 = 1$，第三个方程给出 $x_3 = 1$。这得出了不动点状态 $(1, 1, 1)$。我们可以验证这一点：$F(1,1,1) = (f_1(1,1,1), f_2(1,1,1), f_3(1,1,1)) = (1, 1, 1)$，这与状态本身相等。\n\n我们找到了两个不同的不动点状态：$(0, 0, 0)$ 和 $(1, 1, 1)$。存在多个这样的状态表明修改后的网络有多个不动点。正反馈回路（$x_1$ 激活 $x_2$ 且 $x_2$ 激活 $x_1$）的引入创建了一个双稳态子系统，该子系统可以锁定在全零或全一状态，从而导致整个网络有多个稳定构型。\n\n问题要求最终答案包含B部分中找到的所有不动点状态的列表，并按字典序排列。这两个状态是 $(0,0,0)$ 和 $(1,1,1)$。按字典序，$(0,0,0)$ 在 $(1,1,1)$ 之前。按规定串联这些条目得到序列 $(0, 0, 0, 1, 1, 1)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  1  1  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然复杂网络的某些部分可能表现出丰富且不可预测的动力学行为，但其他部分可能因其输入而被“冻结”在固定状态。这项计算练习将指导您实现一个剪枝算法，以系统地识别这些被决定的组件。这个过程揭示了网络的“活动子网络”，即负责系统复杂行为的核心部分，为简化和分析大规模随机布尔网络提供了一种强有力的方法。",
            "id": "4138419",
            "problem": "考虑一个随机布尔网络 (RBN)，其中一组节点 $\\{0,1,\\dots,N-1\\}$ 通过有向边相互作用，每个节点 $i$ 都有一个相关的布尔更新函数 $f_i:\\{0,1\\}^{k_i}\\rightarrow\\{0,1\\}$，该函数将其 $k_i$ 个输入节点的状态映射到其输出。节点 $i$ 的输入节点以列表形式有序排列为 $I_i=(i_0,i_1,\\dots,i_{k_i-1})$，并且 $f_i$ 的真值表是根据输入比特向量 $(b_0,b_1,\\dots,b_{k_i-1})\\in\\{0,1\\}^{k_i}$ 的字典序指定的，使用的整数索引为 $$j=\\sum_{\\ell=0}^{k_i-1} b_\\ell \\cdot 2^{k_i-1-\\ell}。$$ 没有输入的节点满足 $k_i=0$，其真值表长度为 $1$，这等于 $f_i$ 的一个恒定输出。\n\n定义剪枝过程如下。节点的一个子集可以被固定为集合 $\\{0,1\\}$ 中的值，从而在固定节点的索引集 $\\mathcal{F}\\subseteq\\{0,1,\\dots,N-1\\}$ 上形成一个部分赋值 $A:\\mathcal{F}\\rightarrow\\{0,1\\}$。对于任何节点 $i$，将其输入集 $I_i$ 划分为当前被 $A$ 固定的输入子集 $F_i$ 和未被固定的输入子集 $U_i$。考虑在固定输入 $F_i$ 条件下的受限函数 $f_i$，即对于未固定输入的每一种赋值 $\\beta\\in\\{0,1\\}^{|U_i|}$，该映射都会产生 $f_i(\\alpha,\\beta)$，其中 $\\alpha$ 是由 $A$ 在 $F_i$ 上引出的固定输入赋值。如果存在一个常数 $c\\in\\{0,1\\}$，使得 $$f_i(\\alpha,\\beta)=c\\quad\\text{对于所有}\\quad \\beta\\in\\{0,1\\}^{|U_i|},$$ 那么节点 $i$ 就由固定输入所确定，其输出被固定为 $c$。此剪枝过程通过固定这些已确定节点的输出并迭代此确定步骤来进行，直到没有其他节点能被确定为止。余下的节点被称为活动子网络。\n\n仅根据上述基本定义和指定的真值表索引方式，实现一个程序，将此迭代剪枝过程执行到底，并计算最终活动子网络的大小，该大小定义为剪枝终止后未被固定的节点数量。\n\n您的实现必须使用以下测试套件，每个案例都由节点数 $N$、每个节点 $i$ 的有序输入列表 $I_i$、每个 $f_i$ 按字典序排列的真值表以及表示为数对 $(i,v)$（其中 $v\\in\\{0,1\\}$）集合的初始固定赋值 $A$ 完全指定。\n\n测试用例 1 (通过渠道化和常数进行传播的顺利路径):\n- $N=5$。\n- 有序输入列表:\n  - 节点 $0$: $I_0=()$。\n  - 节点 $1$: $I_1=()$。\n  - 节点 $2$: $I_2=(0,1)$。\n  - 节点 $3$: $I_3=(2)$。\n  - 节点 $4$: $I_4=(3,1)$。\n- 真值表:\n  - 节点 $0$: $[0]$。\n  - 节点 $1$: $[1]$。\n  - 节点 $2$ (逻辑或 $\\mathrm{OR}$): $[0,1,1,1]$，对应输入 $(0,0),(0,1),(1,0),(1,1)$。\n  - 节点 $3$ (恒等): $[0,1]$，对应输入 $(0),(1)$。\n  - 节点 $4$ (异或 $\\mathrm{XOR}$): $[0,1,1,0]$，对应输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_3,b_1)$。\n- 初始固定赋值 $A=\\varnothing$。\n\n测试用例 2 (无常数且存在环的边界情况):\n- $N=3$。\n- 有序输入列表:\n  - 节点 $0$: $I_0=(1)$。\n  - 节点 $1$: $I_1=(2)$。\n  - 节点 $2$: $I_2=(0)$。\n- 真值表:\n  - 节点 $0$ (逻辑非 $\\mathrm{NOT}$): $[1,0]$，对应输入 $(0),(1)$。\n  - 节点 $1$ (恒等): $[0,1]$，对应输入 $(0),(1)$。\n  - 节点 $2$ (恒等): $[0,1]$，对应输入 $(0),(1)$。\n- 初始固定赋值 $A=\\varnothing$。\n\n测试用例 3 (渠道化函数在网络中进行剪枝):\n- $N=4$。\n- 有序输入列表:\n  - 节点 $0$: $I_0=()$。\n  - 节点 $1$: $I_1=(0,2)$。\n  - 节点 $2$: $I_2=(1)$。\n  - 节点 $3$: $I_3=(1,2)$。\n- 真值表:\n  - 节点 $0$: $[1]$。\n  - 节点 $1$ (对第一个输入进行渠道化：若第一个输入为 $1$，输出恒为 $0$；否则，输出等于第二个输入): $[0,1,0,0]$，对应输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_0,b_2)$。\n  - 节点 $2$ (恒等): $[0,1]$，对应输入 $(0),(1)$。\n  - 节点 $3$ (逻辑与 $\\mathrm{AND}$): $[0,0,0,1]$，对应输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_1,b_2)$。\n- 初始固定赋值 $A=\\varnothing$。\n\n测试用例 4 (部分剪枝因未固定的环而留下一个活动核心):\n- $N=6$。\n- 有序输入列表:\n  - 节点 $0$: $I_0=()$。\n  - 节点 $1$: $I_1=()$。\n  - 节点 $2$: $I_2=(0,1)$。\n  - 节点 $3$: $I_3=(2,4)$。\n  - 节点 $4$: $I_4=(5)$。\n  - 节点 $5$: $I_5=(3)$。\n- 真值表:\n  - 节点 $0$: $[0]$。\n  - 节点 $1$: $[1]$。\n  - 节点 $2$ (异或 $\\mathrm{XOR}$): $[0,1,1,0]$，对应输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_0,b_1)$。\n  - 节点 $3$ (异或 $\\mathrm{XOR}$): $[0,1,1,0]$，对应输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_2,b_4)$。\n  - 节点 $4$ (恒等): $[0,1]$，对应输入 $(0),(1)$。\n  - 节点 $5$ (恒等): $[0,1]$，对应输入 $(0),(1)$。\n- 初始固定赋值 $A=\\varnothing$。\n\n您的程序必须为每个测试用例计算剪枝完成后活动子网络的大小。最终输出必须是单行，包含四个测试用例的结果，形式为方括号内以逗号分隔的列表，即 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个整数。此问题不涉及物理单位、角度单位或百分比，因此数值答案是无单位的纯整数。您的程序应生成单行输出，包含以方括号括起、逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$）。",
            "solution": "该问题要求在随机布尔网络（RBN）上实现一个迭代剪枝过程，以找出剩余活动子网络的大小。这个过程是一种逻辑约束传播，其中固定某些节点的状态可以在逻辑上确定其他节点的状态。这种传播会一直持续，直到达到一个稳定状态，即没有更多的节点可以被确定。\n\n核心原则是设计一个不动点迭代算法。系统的状态可以用一个长度为 $N$ 的向量 $\\mathbf{s}$ 来表示，其中每个元素 $\\mathbf{s}_i$ 表示节点 $i$ 的状态。我们可以用值 $-1$ 来表示一个未固定的节点，用 $0$ 或 $1$ 表示一个被固定到相应布尔值的节点。该算法分轮进行，迭代更新 $\\mathbf{s}$ 直至其不再改变。\n\n该过程首先根据初始固定赋值 $A$ 初始化状态向量 $\\mathbf{s}$。然后，迭代剪枝开始。在每次迭代中，我们检查每个未固定的节点 $i$（其中 $\\mathbf{s}_i = -1$），看它是否已被当前固定的节点所确定。\n\n一个具有 $k_i$ 个输入（由有序列表 $I_i = (i_0, i_1, \\dots, i_{k_i-1})$ 指定）和更新函数 $f_i$ 的节点 $i$，如果其输出对于其当前未固定输入的所有可能布尔组合都为常数，则该节点变为已确定状态。为了检查这一点，我们必须确定其哪些输入是固定的，哪些不是。设 $I_i$ 内固定输入的索引集为 $\\mathcal{L}_F$，未固定输入的索引集为 $\\mathcal{L}_U$。\n\n$f_i$ 的真值表是一个包含 $2^{k_i}$ 个输出的列表，由对应于输入向量 $(b_0, b_1, \\dots, b_{k_i-1})$ 的整数 $j$ 索引，其中 $b_\\ell$ 是输入 $i_\\ell$ 的状态。索引 $j$ 由公式 $j=\\sum_{\\ell=0}^{k_i-1} b_\\ell \\cdot 2^{k_i-1-\\ell}$ 给出。\n\n当一些输入被固定时，可访问的真值表索引集合会减小。我们可以将索引 $j$ 表示为来自固定输入和未固定输入的贡献之和：\n$$ j = \\sum_{\\ell \\in \\mathcal{L}_F} \\mathbf{s}_{i_\\ell} \\cdot 2^{k_i-1-\\ell} + \\sum_{\\ell \\in \\mathcal{L}_U} b_\\ell \\cdot 2^{k_i-1-\\ell} $$\n第一项对于给定的网络状态是一个常数，我们可以称之为 `base_index`。第二项随着未固定的输入比特 $b_\\ell$ 取遍 $\\{0,1\\}$ 中的所有可能值而变化。这第二项的所有可能值的集合等价于数集 $\\{2^{k_i-1-\\ell} \\mid \\ell \\in \\mathcal{L}_U\\}$ 的子集的所有可能和的集合。\n\n因此，对于每个未固定的节点 $i$，我们计算所有可访问的真值表索引的集合。然后我们从节点的真值表中检索相应的输出值。如果所有这些输出值都与一个常数 $c \\in \\{0,1\\}$相同，则节点 $i$ 是已确定的，其状态将被固定为 $c$。\n\n算法必须仔细处理更新以确保确定性的结果。对所有未固定的节点进行一次完整的遍历，并收集一个新确定的节点的临时列表。只有在这次遍历完成后，才在主状态向量 $\\mathbfs$ 中更新这些节点的状态。这种批量更新可以防止在当前轮次中固定的节点影响同一轮次中另一个节点的确定过程，从而确保结果与节点迭代顺序无关。\n\n重复这整个过程。由于节点只能从未固定状态转变为固定状态，并且节点总数 $N$ 是有限的，这个迭代过程保证在最多 $N$ 轮内终止。当一次完整的迭代没有确定任何新节点时，终止条件即满足。\n\n终止时，活动子网络的大小就是保持在未固定状态的节点数量（即最终状态向量 $\\mathbf{s}$ 中 $-1$ 的数量）。这个计数就是每个测试用例的最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the RBN pruning problem.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 5,\n            \"inputs\": [(), (), (0, 1), (2,), (3, 1)],\n            \"truth_tables\": [[0], [1], [0, 1, 1, 1], [0, 1], [0, 1, 1, 0]],\n            \"initial_fixed\": []\n        },\n        {\n            \"N\": 3,\n            \"inputs\": [(1,), (2,), (0,)],\n            \"truth_tables\": [[1, 0], [0, 1], [0, 1]],\n            \"initial_fixed\": []\n        },\n        {\n            \"N\": 4,\n            \"inputs\": [(), (0, 2), (1,), (1, 2)],\n            \"truth_tables\": [[1], [0, 1, 0, 0], [0, 1], [0, 0, 0, 1]],\n            \"initial_fixed\": []\n        },\n        {\n            \"N\": 6,\n            \"inputs\": [(), (), (0, 1), (2, 4), (5,), (3,)],\n            \"truth_tables\": [[0], [1], [0, 1, 1, 0], [0, 1, 1, 0], [0, 1], [0, 1]],\n            \"initial_fixed\": []\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_active_subnetwork_size(\n            case[\"N\"],\n            case[\"inputs\"],\n            case[\"truth_tables\"],\n            case[\"initial_fixed\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_active_subnetwork_size(N, inputs, truth_tables, initial_fixed):\n    \"\"\"\n    Computes the size of the active subnetwork after iterative pruning.\n\n    Args:\n        N (int): The number of nodes.\n        inputs (list of tuples): A list where inputs[i] is a tuple of input node indices for node i.\n        truth_tables (list of lists): A list where truth_tables[i] is the truth table for node i.\n        initial_fixed (list of tuples): A list of (node_index, value) pairs for initially fixed nodes.\n\n    Returns:\n        int: The number of nodes not fixed after pruning terminates.\n    \"\"\"\n    # Use -1 to represent an unfixed node.\n    fixed_states = np.full(N, -1, dtype=int)\n    \n    # Apply initial fixed assignment\n    for node_idx, value in initial_fixed:\n        fixed_states[node_idx] = value\n\n    while True:\n        newly_fixed_in_iteration = []\n        \n        # Iterate over all nodes to check for newly determined ones\n        for i in range(N):\n            if fixed_states[i] != -1:\n                # Node is already fixed\n                continue\n\n            node_inputs = inputs[i]\n            k = len(node_inputs)\n            \n            # Nodes with no inputs are constants and are determined in the first round.\n            if k == 0:\n                determined_value = truth_tables[i][0]\n                newly_fixed_in_iteration.append((i, determined_value))\n                continue\n\n            base_index = 0\n            unfixed_powers = []\n\n            for l in range(k):\n                input_node_idx = node_inputs[l]\n                input_node_state = fixed_states[input_node_idx]\n                \n                power_of_2 = 2**(k - 1 - l)\n\n                if input_node_state != -1:\n                    base_index += input_node_state * power_of_2\n                else:\n                    unfixed_powers.append(power_of_2)\n\n            # Generate all possible truth table indices based on varying the unfixed inputs\n            indices_to_check = {base_index}\n            for power in unfixed_powers:\n                indices_to_check.update({idx + power for idx in indices_to_check})\n            \n            # Check if all corresponding outputs in the truth table are the same\n            it = iter(indices_to_check)\n            first_idx = next(it)\n            first_output = truth_tables[i][first_idx]\n            is_constant = all(truth_tables[i][idx] == first_output for idx in it)\n            \n            if is_constant:\n                newly_fixed_in_iteration.append((i, first_output))\n\n        # If no new nodes were fixed in this entire pass, the process has converged\n        if not newly_fixed_in_iteration:\n            break\n            \n        # Apply the newly fixed nodes for the next iteration (batch update)\n        for node_idx, value in newly_fixed_in_iteration:\n            fixed_states[node_idx] = value\n\n    # The size of the active subnetwork is the number of remaining unfixed nodes\n    active_nodes_count = np.sum(fixed_states == -1)\n    return int(active_nodes_count)\n\nsolve()\n```"
        }
    ]
}