{
    "hands_on_practices": [
        {
            "introduction": "随机布尔网络（RBN）的动力学核心在于其吸引子，特别是固定点。这个练习将通过一个清晰的动手实例，展示一个基本原理：网络拓扑，特别是正反馈回路的存在，是系统出现多重稳定性（multistability）和多个固定点的必要条件。通过对比一个无环网络（具有唯一的固定点）和一个包含简单回路的网络，你将亲身体会到结构如何决定动力学行为 。",
            "id": "4138458",
            "problem": "考虑一个同步随机布尔网络 (RBN)，它被定义为在状态空间 $\\{0,1\\}^{N}$ 上的一个离散时间动力系统，其更新映射 $F:\\{0,1\\}^{N}\\to\\{0,1\\}^{N}$ 由针对节点 $x_{i}$ 的布尔函数 $f_{i}:\\{0,1\\}^{N}\\to\\{0,1\\}$ 以分量形式指定，其中 $i\\in\\{1,\\dots,N\\}$。不动点是一个状态 $x\\in\\{0,1\\}^{N}$，满足 $F(x)=x$。该网络的有向依赖图为每个 $x_{i}$ 设一个节点，如果 $f_{i}$ 依赖于 $x_{j}$，则存在一条从 $x_{j}$ 到 $x_{i}$ 的有向边。无环依赖图是一个有向无环图 (DAG)，它容许拓扑排序。\n\n您将分析在一个原本无环的网络中添加单个正反馈回路如何能产生多个不动点。请仅使用上述定义以及有向无环图容许拓扑排序这一事实。不要援引超出此基本基础的任何专门定理。\n\n请研究以下小型说明性例子。设 $N=3$，并考虑具有以下更新函数的无环网络\n$$\nf_{1}(x)=1,\\qquad f_{2}(x)=x_{1},\\qquad f_{3}(x)=x_{2}.\n$$\nA部分：仅使用不动点的定义和有向无环图存在拓扑排序的性质，从第一性原理出发，论证此无环网络具有唯一的不动点。请明确地计算出该不动点。\n\n现在，通过仅修改节点 $x_{1}$ 和 $x_{2}$ 的函数来创建一个单正反馈回路：\n$$\nf_{1}(x)=x_{2},\\qquad f_{2}(x)=x_{1},\n$$\n同时保持 $f_{3}(x)=x_{2}$ 不变。得到的依赖图恰好有一个由 $x_{1}\\leftrightarrow x_{2}$ 形成的环路，其中没有否定运算，这是一个正反馈回路。\n\nB部分：仅使用不动点定义 $F(x)=x$ 和给定的更新函数，证明修改后的网络有多个不动点，并明确地计算出所有这些不动点。\n\n答案规格：\n- 您的最终数值答案必须包含在B部分中找到的所有不动点状态的列表，按 $(x_{1},x_{2},x_{3})$ 的字典序排列，其中状态 $x_{1}=x_{2}=x_{3}=0$ 列在最前面。\n- 使用 $\\mathrm{pmatrix}$ 环境将最终答案表示为单个行矩阵，按顺序 $(x_{1},x_{2},x_{3})$ 连接每个不动点的各项。\n- 无需四舍五入。不涉及单位。",
            "solution": "该问题经检验是自洽的，在离散动力系统理论中有科学依据，并且是适定的。解答所需的所有定义和条件都已明确给出。\n\n随机布尔网络 (RBN) 的不动点是一个状态 $x = (x_1, x_2, \\dots, x_N) \\in \\{0,1\\}^N$，它在更新映射 $F$ 的作用下保持不变。该条件表示为 $F(x) = x$，等价于以下 $N$ 个联立布尔方程组：\n$$\n\\begin{cases}\nx_1 = f_1(x_1, \\dots, x_N) \\\\\nx_2 = f_2(x_1, \\dots, x_N) \\\\\n\\vdots \\\\\nx_N = f_N(x_1, \\dots, x_N)\n\\end{cases}\n$$\n我们将通过求解这个方程组来分析问题中提出的两种情况。\n\nA部分：无环网络\n\n网络定义为 $N=3$，其更新函数为：\n$$\nf_1(x) = 1\n$$\n$$\nf_2(x) = x_1\n$$\n$$\nf_3(x) = x_2\n$$\n不动点条件 $F(x)=x$ 转化为关于状态向量 $x=(x_1, x_2, x_3)$ 的以下方程组：\n$$\nx_1 = 1\n$$\n$$\nx_2 = x_1\n$$\n$$\nx_3 = x_2\n$$\n此网络的依赖图规则是：若 $f_i$ 依赖于 $x_j$，则存在一条从 $x_j$ 到 $x_i$ 的有向边。\n- $f_1$ 没有依赖项。\n- $f_2$ 依赖于 $x_1$，因此有一条边 $x_1 \\to x_2$。\n- $f_3$ 依赖于 $x_2$，因此有一条边 $x_2 \\to x_3$。\n得到的图是一条有向路径 $x_1 \\to x_2 \\to x_3$。这是一个有向无环图 (DAG)。\n\n根据前提，有向无环图容许其节点进行拓扑排序，这是一种排序方式，对于每条从节点 $u$ 到节点 $v$ 的有向边， $u$ 都排在 $v$ 之前。对于这个图，唯一的拓扑排序是 $(x_1, x_2, x_3)$。\n\n我们可以利用这个排序来顺序求解不动点的值。排序中任何节点的值仅依赖于排在它之前的节点的值。\n\n1. 从拓扑序中的第一个节点 $x_1$ 开始。$x_1$ 的不动点方程是 $x_1 = 1$。该方程独立于所有其他变量。其解是唯一确定的：$x_1 = 1$。\n\n2. 接着处理下一个节点 $x_2$。不动点方程是 $x_2 = x_1$。由于上一步已唯一确定 $x_1$ 的值为 $1$，我们代入此值，发现 $x_2$ 也被唯一确定：$x_2 = 1$。\n\n3. 接着处理最后一个节点 $x_3$。不动点方程是 $x_3 = x_2$。由于刚刚已唯一确定 $x_2$ 的值为 $1$，我们发现 $x_3$ 也被唯一确定：$x_3 = 1$。\n\n因为该方程组可以按照拓扑序顺序求解，并且每一步都为相应变量得出了一个唯一的值，所以解是唯一的。因此，该无环网络恰好有一个不动点。这个不动点是状态 $(x_1, x_2, x_3) = (1, 1, 1)$。\n\nB部分：带有正反馈回路的网络\n\n通过改变 $x_1$ 和 $x_2$ 的更新函数来修改网络：\n$$\nf_1(x) = x_2\n$$\n$$\nf_2(x) = x_1\n$$\n$$\nf_3(x) = x_2\n$$\n不动点条件 $F(x)=x$ 现在对应于以下方程组：\n$$\nx_1 = x_2\n$$\n$$\nx_2 = x_1\n$$\n$$\nx_3 = x_2\n$$\n这个修改后网络的依赖图如下：\n- $f_1$ 依赖于 $x_2$，因此有一条边 $x_2 \\to x_1$。\n- $f_2$ 依赖于 $x_1$，因此有一条边 $x_1 \\to x_2$。\n- $f_3$ 依赖于 $x_2$，因此有一条边 $x_2 \\to x_3$。\n该图包含环路 $x_1 \\to x_2 \\to x_1$，因此不是一个有向无环图。对所有节点进行拓扑排序是不可能的，我们无法像A部分那样顺序求解节点的值。前两个方程 $x_1 = x_2$ 和 $x_2 = x_1$ 是耦合的，必须同时求解。\n\n$x_1$ 和 $x_2$ 的这两个方程在逻辑上是等价的。它们都表示约束条件 $x_1 = x_2$。由于 $x_1$ 和 $x_2$ 是 $\\{0, 1\\}$ 中的布尔变量，这个约束不会产生唯一的解。相反，它容许对 $(x_1, x_2)$ 有两种可能的解：\n- 情况1：$x_1 = 0$ 且 $x_2 = 0$。\n- 情况2：$x_1 = 1$ 且 $x_2 = 1$。\n\n对于这两种情况中的每一种，我们使用其不动点方程 $x_3 = x_2$ 来确定剩余变量 $x_3$ 的值。\n\n- 在情况1中，当 $x_1 = 0$ 且 $x_2 = 0$ 时，第三个方程给出 $x_3 = 0$。这得出了不动点状态 $(0, 0, 0)$。我们可以验证这一点：$F(0,0,0) = (f_1(0,0,0), f_2(0,0,0), f_3(0,0,0)) = (0, 0, 0)$，这与状态本身相等。\n\n- 在情况2中，当 $x_1 = 1$ 且 $x_2 = 1$ 时，第三个方程给出 $x_3 = 1$。这得出了不动点状态 $(1, 1, 1)$。我们可以验证这一点：$F(1,1,1) = (f_1(1,1,1), f_2(1,1,1), f_3(1,1,1)) = (1, 1, 1)$，这与状态本身相等。\n\n我们找到了两个不同的不动点状态：$(0, 0, 0)$ 和 $(1, 1, 1)$。存在一个以上这样的状态证明了修改后的网络有多个不动点。正反馈回路（$x_1$ 激活 $x_2$ 且 $x_2$ 激活 $x_1$）的引入创建了一个双稳态子系统，该子系统可以锁定在全零或全一状态，从而导致整个网络有多个稳定构型。\n\n问题要求最终答案包含B部分中找到的所有不动点状态的列表，并按字典序排列。这两个状态是 $(0,0,0)$ 和 $(1,1,1)$。按字典序，$(0,0,0)$ 在 $(1,1,1)$ 之前。按规定连接各项，得到序列 $(0, 0, 0, 1, 1, 1)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  1  1  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了固定点的概念之后，一个更普遍的问题是网络如何响应微小的扰动。这个练习引入了“损伤传播”（damage spreading）的关键概念，并使用“退火近似”（annealed approximation）——一种在统计物理学中非常强大的分析工具——来推导一个关键参数。这个参数决定了网络是处于稳定（有序）状态还是不稳定（混沌）状态 。",
            "id": "4138428",
            "problem": "考虑一个随机布尔网络 (RBN)，其中 $N$ 个节点中的每一个都根据一个布尔函数同步更新，该函数具有从 $N$ 个节点中均匀随机选择的恰好 $K$ 个输入。布尔函数是从一个偏置为 $p \\in (0,1)$ 的系综中独立抽样的，这意味着对于每个输入配置，输出为 $1$ 的概率为 $p$，为 $0$ 的概率为 $1-p$，并且在真值表的所有 $2^{K}$ 个条目中是独立的。初始化两个完全相同的网络副本，使得在时间 $t$ 有一小部分比例 $d_{t}$ 的节点状态不同，如果在那个时间点一个节点在两个副本中的状态不同，则称该节点在时间 $t$ 是“受损”的。在退火近似下，连接和更新函数在每个时间步都独立地重新抽样，并且每个节点的输入状态被视为独立同分布的。在 $N \\to \\infty$ 和 $d_{t} \\to 0$ 的极限下进行分析，使得受损节点影响之间的重叠可以忽略不计。\n\n仅使用上述定义和适用于复杂自适应系统建模的第一性原理，推导一个解析表达式，表示在时间 $t+1$ 时，每个当前在时间 $t$ 受损的节点所产生的预期新增受损节点数。将最终答案表示为 $p$ 和 $K$ 的闭式函数。不需要数值近似或四舍五入。",
            "solution": "我们从一个随机布尔网络 (RBN) 的结构定义开始，该网络有 $N$ 个节点，每个节点有恰好 $K$ 个随机选择的输入。每个节点通过对其输入应用一个布尔函数来同步更新。布尔函数系综由一个偏置 $p \\in (0,1)$ 定义，具有以下性质：对于 $2^{K}$ 个输入配置中的每一个，函数的输出为 $1$ 的概率为 $p$，为 $0$ 的概率为 $1-p$，并且在所有配置中是独立的。\n\n我们考虑两个网络副本，它们在时间 $t$ 有一小部分比例 $d_{t}$ 的节点状态不同。如果在那个时间点一个节点在两个副本中的状态不同，则该节点是“受损”的。我们被要求计算在时间 $t+1$ 时，每个当前在时间 $t$ 受损的节点所产生的预期新增受损节点数，计算在 $N \\to \\infty$ 和 $d_{t} \\to 0$ 的极限下进行，因此多个受损输入同时影响同一节点的概率可以忽略不计。\n\n我们分两步进行：(i) 计算在下一个时间步，单个受损节点通过网络连接影响的节点的预期数量；(ii) 计算在偏置系综下，翻转一个节点的单个输入会改变该节点输出的概率。\n\n步骤 (i)：通过连接产生的预期影响。该网络有 $N$ 个节点，每个节点的入度为 $K$，因此有向边的总数为 $N K$。因为输入是均匀随机分配的，所以节点的出度分布近似为均值为 $K$ 的二项分布，并且在 $N \\to \\infty$ 的极限下，随机选择的节点的预期出度等于 $K$。在退火近似下，在时间 $t$ 的每个受损节点，在时间 $t+1$ 平均是 $K$ 个目标节点的输入。因此，对于每个受损节点，仅由于该节点而接收到翻转输入的预期目标节点数为 $K$。\n\n步骤 (ii)：单个输入翻转改变输出的概率。考虑一个具有 $K$ 个输入的单个目标节点，其布尔函数从偏置系综中抽样。任意固定其他 $K-1$ 个输入的值。令 $x \\in \\{0,1\\}$ 表示在一个副本中焦点输入的值，令 $x' \\in \\{0,1\\}$ 表示在另一个副本中的值，其中 $x' \\neq x$（单个输入翻转）。对于这两个输入赋值，由于系综的定义，函数的输出是参数为 $p$ 的独立伯努利随机变量：对于任何给定的输入配置，输出为 $1$ 的概率为 $p$，且与其他配置无关。用 $y$ 和 $y'$ 表示输出，其中 $y \\sim \\mathrm{Bernoulli}(p)$ 对应于焦点输入为 $x$ 的配置，而 $y' \\sim \\mathrm{Bernoulli}(p)$ 对应于焦点输入为 $x'$ 的配置，且与 $y$ 独立。\n\n两个副本之间的输出不同当且仅当 $y \\neq y'$。因为 $y$ 和 $y'$ 是独立的，且有 $\\mathbb{P}(y=1)=p$ 和 $\\mathbb{P}(y=0)=1-p$，所以出现差异的概率是\n$$\n\\mathbb{P}(y \\neq y') \\;=\\; \\mathbb{P}(y=1,y'=0) \\;+\\; \\mathbb{P}(y=0,y'=1)\n\\;=\\; p(1-p) \\;+\\; (1-p)p \\;=\\; 2p(1-p).\n$$\n这个计算对于其他 $K-1$ 个输入的任何固定赋值都成立，并且由于真值表条目之间的独立性，该概率对于所有这些赋值都是相同的。因此，对于一个节点的单个翻转输入，该节点的输出在下一个时间步在两个网络副本之间不同的概率是 $2p(1-p)$。\n\n在 $d_{t} \\to 0$ 的极限下结合 (i) 和 (ii) 可确保不同的受损输入很少汇集到同一个目标上，并且其贡献在期望上是线性相加的。因此，在时间 $t$ 由单个受损节点产生的预期新增受损节点数，是它影响的预期目标节点数与单个输入翻转改变目标输出的概率的乘积：\n$$\nK \\times 2p(1-p) \\;=\\; 2p(1-p)K.\n$$\n因此，在时间 $t+1$ 的预期新增受损节点数等于 $2p(1-p)K$ 乘以在时间 $t$ 的当前受损节点数，所求的每个受损节点的乘数是\n$$\n2p(1-p)K.\n$$",
            "answer": "$$\\boxed{2p(1-p)K}$$"
        },
        {
            "introduction": "在大型网络中，并非所有节点都同样活跃。由于其更新规则的逻辑以及其输入节点的恒定状态，网络的某些部分可能会被“冻结”或固定。这个练习将我们从分析理论带入计算算法的领域，要求你实现一个模拟这种冻结现象的“剪枝”过程。通过这个过程，你将能够识别出网络的“活动子网络”（active subnetwork）——即系统中保持动态的核心部分 。",
            "id": "4138419",
            "problem": "考虑一个随机布尔网络 (RBN)，其中一组节点 $\\{0,1,\\dots,N-1\\}$ 通过有向边相互作用，每个节点 $i$ 都有一个关联的布尔更新函数 $f_i:\\{0,1\\}^{k_i}\\rightarrow\\{0,1\\}$，该函数将其 $k_i$ 个输入节点的状态映射到其输出。节点 $i$ 的输入节点以列表 $I_i=(i_0,i_1,\\dots,i_{k_i-1})$ 的形式排序，而 $f_i$ 的真值表是根据输入位向量 $(b_0,b_1,\\dots,b_{k_i-1})\\in\\{0,1\\}^{k_i}$ 的字典序指定的，使用整数索引 $$j=\\sum_{\\ell=0}^{k_i-1} b_\\ell \\cdot 2^{k_i-1-\\ell}.$$ 一个没有输入的节点其 $k_i=0$，其真值表长度为 $1$，这等于 $f_i$ 的一个常量输出。\n\n定义一个剪枝过程如下。一部分节点可以被固定为集合 $\\{0,1\\}$ 中的值，从而在固定节点索引集 $\\mathcal{F}\\subseteq\\{0,1,\\dots,N-1\\}$ 上形成一个部分赋值 $A:\\mathcal{F}\\rightarrow\\{0,1\\}$。对于任何节点 $i$，将其输入集 $I_i$ 划分为当前由 $A$ 固定的输入子集 $F_i$ 和未固定的输入子集 $U_i$。考虑在固定输入 $F_i$ 下的受限函数 $f_i$，即对于未固定输入的每个赋值 $\\beta\\in\\{0,1\\}^{|U_i|}$，该映射产生 $f_i(\\alpha,\\beta)$，其中 $\\alpha$ 是由 $A$ 在 $F_i$ 上引出的固定输入赋值。如果存在一个常量 $c\\in\\{0,1\\}$ 使得 $$f_i(\\alpha,\\beta)=c\\quad\\text{for all}\\quad \\beta\\in\\{0,1\\}^{|U_i|},$$ 那么节点 $i$ 就由固定输入确定，其输出被固定为 $c$。剪枝过程通过固定这些已确定节点的输出并迭代此确定步骤，直到没有额外的节点变为已确定状态。剩余的节点被称为活跃子网络。\n\n仅根据上述基本定义和指定的真值表索引，实现一个程序，将此迭代剪枝过程执行至完成，并计算生成的活跃子网络的大小，该大小定义为剪枝终止后未被固定的节点数量。\n\n您的实现必须使用以下测试套件，其中每个案例都由节点数 $N$、每个节点 $i$ 的有序输入列表 $I_i$、每个 $f_i$ 按字典序排列的真值表，以及表示为一对 $(i,v)$（其中 $v\\in\\{0,1\\}$）集合的初始固定赋值 $A$ 完全指定。\n\n测试用例 1 (通过渠道化和常量进行传播的理想情况)：\n- $N=5$。\n- 有序输入列表：\n  - 节点 $0$：$I_0=()$。\n  - 节点 $1$：$I_1=()$。\n  - 节点 $2$：$I_2=(0,1)$。\n  - 节点 $3$：$I_3=(2)$。\n  - 节点 $4$：$I_4=(3,1)$。\n- 真值表：\n  - 节点 $0$：$[0]$。\n  - 节点 $1$：$[1]$。\n  - 节点 $2$ (逻辑 $\\mathrm{OR}$): 对于输入 $(0,0),(0,1),(1,0),(1,1)$，为 $[0,1,1,1]$。\n  - 节点 $3$ (恒等): 对于输入 $(0),(1)$，为 $[0,1]$。\n  - 节点 $4$ (异或 (XOR)): 对于输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_3,b_1)$，为 $[0,1,1,0]$。\n- 初始固定赋值 $A=\\varnothing$。\n\n测试用例 2 (没有常量且存在环的边界情况)：\n- $N=3$。\n- 有序输入列表：\n  - 节点 $0$：$I_0=(1)$。\n  - 节点 $1$：$I_1=(2)$。\n  - 节点 $2$：$I_2=(0)$。\n- 真值表：\n  - 节点 $0$ (逻辑 $\\mathrm{NOT}$): 对于输入 $(0),(1)$，为 $[1,0]$。\n  - 节点 $1$ (恒等): 对于输入 $(0),(1)$，为 $[0,1]$。\n  - 节点 $2$ (恒等): 对于输入 $(0),(1)$，为 $[0,1]$。\n- 初始固定赋值 $A=\\varnothing$。\n\n测试用例 3 (渠道化函数在网络中进行剪枝)：\n- $N=4$。\n- 有序输入列表：\n  - 节点 $0$：$I_0=()$。\n  - 节点 $1$：$I_1=(0,2)$。\n  - 节点 $2$：$I_2=(1)$。\n  - 节点 $3$：$I_3=(1,2)$。\n- 真值表：\n  - 节点 $0$：$[1]$。\n  - 节点 $1$ (对第一个输入进行渠道化：如果第一个输入为 $1$，则输出始终为 $0$；否则，输出等于第二个输入): 对于输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_0,b_2)$，为 $[0,1,0,0]$。\n  - 节点 $2$ (恒等): 对于输入 $(0),(1)$，为 $[0,1]$。\n  - 节点 $3$ (逻辑 $\\mathrm{AND}$): 对于输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_1,b_2)$，为 $[0,0,0,1]$。\n- 初始固定赋值 $A=\\varnothing$。\n\n测试用例 4 (部分剪枝因未固定的环而留下一个活跃核心)：\n- $N=6$。\n- 有序输入列表：\n  - 节点 $0$：$I_0=()$。\n  - 节点 $1$：$I_1=()$。\n  - 节点 $2$：$I_2=(0,1)$。\n  - 节点 $3$：$I_3=(2,4)$。\n  - 节点 $4$：$I_4=(5)$。\n  - 节点 $5$：$I_5=(3)$。\n- 真值表：\n  - 节点 $0$：$[0]$。\n  - 节点 $1$：$[1]$。\n  - 节点 $2$ (异或 (XOR)): 对于输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_0,b_1)$，为 $[0,1,1,0]$。\n  - 节点 $3$ (异或 (XOR)): 对于输入 $(0,0),(0,1),(1,0),(1,1)$，顺序为 $(b_2,b_4)$，为 $[0,1,1,0]$。\n  - 节点 $4$ (恒等): 对于输入 $(0),(1)$，为 $[0,1]$。\n  - 节点 $5$ (恒等): 对于输入 $(0),(1)$，为 $[0,1]$。\n- 初始固定赋值 $A=\\varnothing$。\n\n您的程序必须为每个测试用例计算剪枝完成后活跃子网络的大小。最终输出必须是单行，包含四个测试用例的结果，形式为方括号内以逗号分隔的列表，即 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个整数。此问题不涉及物理单位、角度单位或百分比，因此数值答案是纯整数，不带单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4]$）。",
            "solution": "该问题要求在一个随机布尔网络（RBN）上实现一个迭代剪枝过程，以找出剩余活跃子网络的大小。这个过程是一种逻辑约束传播的形式，其中固定一些节点的状态可以在逻辑上确定其他节点的状态。这种传播持续进行，直到达到一个稳定状态，即没有更多节点可以被确定。\n\n核心原则是设计一个不动点迭代算法。我们可以用一个状态数组来表示节点的状态，其中一个特殊值（例如-1）表示未固定的节点，而0或1表示固定到该布尔值的节点。算法分轮次进行，迭代更新这个状态数组直到它不再改变。\n\n该过程首先根据初始固定赋值初始化状态数组。然后，开始迭代剪枝。在每次迭代中，我们检查每个未固定的节点，看它是否已被当前固定的节点所确定。\n\n一个具有$k_i$个输入（由有序列表$I_i = (i_0, i_1, \\dots, i_{k_i-1})$指定）和更新函数$f_i$的节点$i$，如果其输出对于其当前未固定输入的所有可能布尔组合都是恒定的，则该节点变为已确定。为了检查这一点，我们必须遍历该节点真值表中与当前固定输入相一致的所有条目。\n\n具体来说，对于一个未固定的节点$i$，我们首先确定其输入中有哪些是固定的，哪些不是。然后，我们生成所有与当前固定输入兼容的完整输入向量。这相当于遍历所有对未固定输入的赋值组合。对于每种组合，我们根据问题中给出的公式计算真值表索引$j$，并查找对应的输出。如果所有这些输出值都与一个常量$c \\in \\{0,1\\}$相同，则节点$i$被确定，其状态将被固定为$c$。\n\n算法必须小心处理更新以确保确定性的结果。一个稳健的方法是，对所有未固定的节点进行一次完整的遍历，并收集一个新确定的节点的临时列表。只有在这次遍历完成后，这些新确定的节点的状态才会在主状态数组中被更新。这种批量更新可以防止在当前轮次中固定的节点影响同一轮次中另一个节点的确定过程，从而确保结果与节点迭代的顺序无关。\n\n整个过程会重复进行。由于节点只能从未固定状态转换到固定状态，并且总节点数$N$是有限的，这个迭代过程保证在最多$N$轮内终止。当一次完整的迭代完成而没有新的节点被确定时，终止条件就达成了。终止后，活跃子网络的大小就是保持在未固定状态的节点数量。这个计数就是每个测试用例的最终结果。",
            "answer": "$$\\boxed{\\text{[0, 3, 0, 3]}}$$"
        }
    ]
}