{
    "hands_on_practices": [
        {
            "introduction": "层次聚类是从数据中揭示嵌套结构的基本方法。本练习将让您直接实践应用平均链接算法，这是一种将成对的相异性度量转化为具体层次结构的关键技术，帮助您理解系统层次性是如何从组件间的关系中以算法方式构建的。",
            "id": "4126046",
            "problem": "考虑一个由五个相互作用的模块 $M_{1}, M_{2}, M_{3}, M_{4}, M_{5}$ 组成的复杂适应系统。假设模块间的非相似性已通过一个源于长期行为差异、并经过科学验证的度量标准进行量化，得到如下对称距离矩阵 $D$（矩阵元素无量纲，对角线元素为 $0$）：\n$$\nD=\\begin{pmatrix}\n0  0.18  0.55  0.60  0.40 \\\\\n0.18  0  0.58  0.59  0.42 \\\\\n0.55  0.58  0  0.22  0.45 \\\\\n0.60  0.59  0.22  0  0.47 \\\\\n0.40  0.42  0.45  0.47  0\n\\end{pmatrix}.\n$$\n根据复杂适应系统中层次组织的基本原理，使用平均链接层次聚类的核心定义：两个簇 $U$ 和 $V$ 之间的距离是所有满足 $i \\in U$ 和 $j \\in V$ 的点对 $(i,j)$ 的 $D(i,j)$ 值的平均值。从将每个模块视为一个单例簇开始，并迭代地合并簇间距离最小的两个簇。执行恰好三次合并，并报告树状图的合并高度，该高度定义为每次合并时的簇间距离。将这三个高度表示为一个行矩阵，并提供精确的小数值。无需四舍五入，且这些值是无量纲的。",
            "solution": "任务是使用平均链接法对给定的模块执行凝聚型层次聚类。我们从基本定义开始：在平均链接聚类中，对于任意两个簇 $U$ 和 $V$，簇间距离为\n$$\nd(U,V) = \\frac{1}{|U|\\,|V|} \\sum_{i \\in U} \\sum_{j \\in V} D(i,j),\n$$\n其中 $|U|$ 和 $|V|$ 分别表示簇 $U$ 和 $V$ 中的元素数量。每个凝聚步骤中的树状图合并高度，是在该步骤中被合并的簇对 $U$ 和 $V$ 的 $d(U,V)$ 值。\n\n我们从五个单例簇开始：$\\{M_{1}\\}$, $\\{M_{2}\\}$, $\\{M_{3}\\}$, $\\{M_{4}\\}$, $\\{M_{5}\\}$。对于单例簇，簇间距离等于矩阵 $D$ 中的相应条目。\n\n步骤 $1$：找出所有单例簇对中的最小距离。通过检查矩阵 $D$，我们发现最小值为 $D(1,2) = 0.18$。因此，我们在高度 $0.18$ 处合并 $\\{M_{1}\\}$ 和 $\\{M_{2}\\}$。第一个树状图合并高度是 $0.18$。现在我们有簇 $\\{M_{1},M_{2}\\}$, $\\{M_{3}\\}$, $\\{M_{4}\\}$, $\\{M_{5}\\}$。\n\n我们使用平均链接法计算从新簇 $\\{M_{1},M_{2}\\}$到其他单例簇的距离：\n- $d(\\{M_{1},M_{2}\\},\\{M_{3}\\}) = \\frac{D(1,3) + D(2,3)}{2} = \\frac{0.55 + 0.58}{2} = 0.565$,\n- $d(\\{M_{1},M_{2}\\},\\{M_{4}\\}) = \\frac{D(1,4) + D(2,4)}{2} = \\frac{0.60 + 0.59}{2} = 0.595$,\n- $d(\\{M_{1},M_{2}\\},\\{M_{5}\\}) = \\frac{D(1,5) + D(2,5)}{2} = \\frac{0.40 + 0.42}{2} = 0.41$.\n\n步骤 $2$：在所有当前的簇间距离中（包括 $\\{M_{3}\\}, \\{M_{4}\\}, \\{M_{5}\\}$ 之间的距离），最小值为 $D(3,4) = 0.22$。因此，我们在高度 $0.22$ 处合并 $\\{M_{3}\\}$ 和 $\\{M_{4}\\}$。第二个树状图合并高度是 $0.22$。现在我们有簇 $\\{M_{1},M_{2}\\}$, $\\{M_{3},M_{4}\\}$, $\\{M_{5}\\}$。\n\n步骤 $3$：计算当前三个簇之间的平均链接距离：\n- $d(\\{M_{1},M_{2}\\},\\{M_{5}\\}) = 0.41$ (已计算),\n- $d(\\{M_{3},M_{4}\\},\\{M_{5}\\}) = \\frac{D(3,5) + D(4,5)}{2} = \\frac{0.45 + 0.47}{2} = 0.46$,\n- $d(\\{M_{1},M_{2}\\},\\{M_{3},M_{4}\\}) = \\frac{D(1,3) + D(1,4) + D(2,3) + D(2,4)}{4} = \\frac{0.55 + 0.60 + 0.58 + 0.59}{4} = 0.58$.\n最小值为 $0.41$，对应于 $\\{M_{1},M_{2}\\}$ 和 $\\{M_{5}\\}$ 之间的距离。因此，我们在高度 $0.41$ 处合并这两个簇。第三个树状图合并高度是 $0.41$。\n\n将这三个合并高度按出现顺序列出，我们得到高度的行矩阵：\n$$\n\\begin{pmatrix}\n0.18  0.22  0.41\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}0.18  0.22  0.41\\end{pmatrix}}$$"
        },
        {
            "introduction": "本练习将视角从静态结构转向系统动力学，探讨模块化分区在何种条件下能使系统行为得到一致的简化。通过检验精确可集总性 (exact lumpability) 并推导宏观层面的转移矩阵，您将深入理解微观动力学如何被粗粒化，这是多尺度建模中的一个核心概念。",
            "id": "4126084",
            "problem": "考虑一个在大小为 $6$ 的微观状态空间上的离散时间马尔可夫链，其转移矩阵为 $P \\in \\mathbb{R}^{6 \\times 6}$。该系统被分层地组织成 $3$ 个模块（宏观状态），每个模块恰好包含 $2$ 个微观状态：模块 $1$ 包含微观状态 $\\{1,2\\}$，模块 $2$ 包含微观状态 $\\{3,4\\}$，模块 $3$ 包含微观状态 $\\{5,6\\}$。令划分矩阵 $S \\in \\mathbb{R}^{3 \\times 6}$ 对此分组进行编码，如果微观状态 $i$ 属于模块 $g$，则 $S_{g,i} = 1$，否则 $S_{g,i} = 0$。假设使用 Moore–Penrose 伪逆 (MPPI) $S^{\\dagger} \\in \\mathbb{R}^{6 \\times 3}$ 从微观动力学构造一个宏观动力学算子。\n\n微观层面的转移矩阵 $P$ 由下式给出\n$$\nP = \n\\begin{pmatrix}\n0.25  0.25  0.15  0.15  0.10  0.10 \\\\\n0.25  0.25  0.15  0.15  0.10  0.10 \\\\\n0.10  0.10  0.25  0.25  0.15  0.15 \\\\\n0.10  0.10  0.25  0.25  0.15  0.15 \\\\\n0.15  0.15  0.10  0.10  0.25  0.25 \\\\\n0.15  0.15  0.10  0.10  0.25  0.25\n\\end{pmatrix}.\n$$\n\n仅使用马尔可夫链中可集聚性的基本定义以及通过 Moore–Penrose 伪逆由一个划分导出的宏观动力学的标准构造，完成以下任务：\n\n- 判断该链相对于给定的划分是否是精确可集聚的；也就是说，是否存在一个宏观层面的转移矩阵 $P' \\in \\mathbb{R}^{3 \\times 3}$，使得宏观动力学通过该划分以精确可集聚性所要求的意义与微观动力学交织在一起。\n- 如果它是可集聚的，使用 $S$ 和 $S^{\\dagger}$，从聚合的第一性原理出发推导宏观层面的转移矩阵，不假设任何快捷公式。\n\n将宏观层面转移矩阵中对应于从模块 1 到模块 3 的转移的单个元素，即 $P'$ 的 $(1,3)$ 元素，作为你的最终答案。将你的最终答案表示为最简分数。不需要单位，也不需要四舍五入。",
            "solution": "我们从离散时间马尔可夫链的定义开始，其转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 通过左乘来推进微观状态上的概率分布。将微观状态空间划分为 $m$ 个不相交的模块，该划分由一个划分矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 编码，其行是模块的指示向量。对于相对于该划分的精确可集聚性，其充要条件是：对于同一模块 $g$ 中的任意两个微观状态 $i$ 和 $j$，从 $i$ 和 $j$ 到任何其他模块 $h$ 的聚合转移概率都相同。这确保了存在一个宏观层面的转移矩阵 $P' \\in \\mathbb{R}^{m \\times m}$，它控制着聚合的模块级概率的演化，并满足一个与该划分一致的、介于微观和宏观动力学之间的交织关系。\n\n具体来说，令模块为 $G_{1} = \\{1,2\\}$、$G_{2} = \\{3,4\\}$ 和 $G_{3} = \\{5,6\\}$。划分矩阵 $S \\in \\mathbb{R}^{3 \\times 6}$ 是\n$$\nS = \n\\begin{pmatrix}\n1  1  0  0  0  0 \\\\\n0  0  1  1  0  0 \\\\\n0  0  0  0  1  1\n\\end{pmatrix}.\n$$\n对于这样的划分，Moore–Penrose 伪逆 $S^{\\dagger} \\in \\mathbb{R}^{6 \\times 3}$ 简化为在模块内进行平均。由于每个模块恰好包含 $2$ 个微观状态，模块大小的对角矩阵是 $D = \\operatorname{diag}(2,2,2)$，并且可以验证：\n$$\nS^{\\dagger} = D^{-1} S^{\\top} = \\frac{1}{2} S^{\\top} =\n\\frac{1}{2}\n\\begin{pmatrix}\n1  0  0 \\\\\n1  0  0 \\\\\n0  1  0 \\\\\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n\n为了检验精确可集聚性，我们检查对于任意 $i,j \\in G_{g}$，从 $i$ 和 $j$ 到一个模块 $h$ 的转移概率之和是否相等。定义，对于 $i \\in \\{1,\\dots,6\\}$ 和 $h \\in \\{1,2,3\\}$，\n$$\n\\pi(i \\to G_{h}) := \\sum_{k \\in G_{h}} P_{i,k}.\n$$\n我们使用给定的 $P$ 为每个微观状态计算这些模块求和概率：\n\n- 对于 $i \\in G_{1}$（$P$ 的第 1 行和第 2 行），我们有\n$$\n\\pi(1 \\to G_{1}) = 0.25 + 0.25 = 0.50,\\quad \\pi(1 \\to G_{2}) = 0.15 + 0.15 = 0.30,\\quad \\pi(1 \\to G_{3}) = 0.10 + 0.10 = 0.20,\n$$\n并且根据对称性，第 2 行是相同的。\n\n- 对于 $i \\in G_{2}$（$P$ 的第 3 行和第 4 行），我们有\n$$\n\\pi(3 \\to G_{1}) = 0.10 + 0.10 = 0.20,\\quad \\pi(3 \\to G_{2}) = 0.25 + 0.25 = 0.50,\\quad \\pi(3 \\to G_{3}) = 0.15 + 0.15 = 0.30,\n$$\n对于第 4 行也类似。\n\n- 对于 $i \\in G_{3}$（$P$ 的第 5 行和第 6 行），我们有\n$$\n\\pi(5 \\to G_{1}) = 0.15 + 0.15 = 0.30,\\quad \\pi(5 \\to G_{2}) = 0.10 + 0.10 = 0.20,\\quad \\pi(5 \\to G_{3}) = 0.25 + 0.25 = 0.50,\n$$\n对于第 6 行也类似。\n\n对于每个模块 $g$，向量 $\\big(\\pi(i \\to G_{1}), \\pi(i \\to G_{2}), \\pi(i \\to G_{3})\\big)$ 对于所有 $i \\in G_{g}$ 都是相同的。这验证了相对于由 $S$ 定义的划分的精确可集聚性的充要条件。因此，存在一个宏观层面的转移矩阵 $P' \\in \\mathbb{R}^{3 \\times 3}$。\n\n接下来，我们使用 $S$ 和 $S^{\\dagger}$ 从聚合的第一性原理出发推导宏观层面的转移矩阵。聚合过程如下：首先通过左乘 $S$ 对模块内的微观层面概率求和，然后通过右乘 $S^{\\dagger}$ 在模块内均匀地重新分配，这实现了对模块成员的平均。具体来说，\n$$\nP' = S P S^{\\dagger}.\n$$\n我们通过对 $P$ 的相应行求和来计算 $S P$：\n$$\nS P =\n\\begin{pmatrix}\n\\text{row}_{1}(P) + \\text{row}_{2}(P) \\\\\n\\text{row}_{3}(P) + \\text{row}_{4}(P) \\\\\n\\text{row}_{5}(P) + \\text{row}_{6}(P)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0.50  0.50  0.30  0.30  0.20  0.20 \\\\\n0.20  0.20  0.50  0.50  0.30  0.30 \\\\\n0.30  0.30  0.20  0.20  0.50  0.50\n\\end{pmatrix}.\n$$\n乘以 $S^{\\dagger} = \\frac{1}{2} S^{\\top}$ 会对每个模块对应的列对进行平均：\n$$\nP' = S P S^{\\dagger}\n= \\frac{1}{2}\n\\begin{pmatrix}\n0.50 + 0.50  & 0.30 + 0.30  & 0.20 + 0.20 \\\\\n0.20 + 0.20  & 0.50 + 0.50  & 0.30 + 0.30 \\\\\n0.30 + 0.30  & 0.20 + 0.20  & 0.50 + 0.50\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0.50  0.30  0.20 \\\\\n0.20  0.50  0.30 \\\\\n0.30  0.20  0.50\n\\end{pmatrix}.\n$$\n因此，从模块 1 到模块 3 的宏观层面转移是 $P'$ 的 $(1,3)$ 元素，即 $0.20$。作为最简分数，该元素是\n$$\n\\frac{1}{5}.\n$$",
            "answer": "$$\\boxed{\\frac{1}{5}}$$"
        },
        {
            "introduction": "在许多现实场景中，模块化结构并非预先给定的，而需要被发现。本练习将引导您执行一遍 Louvain 方法的计算，这是一种通过优化模块度 ($Q$) 指标来检测社群的强大启发式算法，让您亲身体验在复杂网络中发现模块的优化逻辑。",
            "id": "4126110",
            "problem": "考虑一个带权无向玩具网络，该网络有 $6$ 个标记为 $\\{1,2,3,4,5,6\\}$ 的节点，其邻接矩阵 $\\mathbf{A}$ 为\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  0  0.1  0 \\\\\n1  1  0  0.1  0  0 \\\\\n0  0  0.1  0  1  1 \\\\\n0  0.1  0  1  0  1 \\\\\n0  0  0  1  1  0 \\\\\n\\end{pmatrix}.\n$$\n所有权重都是对称的，且初始时没有自环。令 $m$ 表示总边权（无向边上的权重之和），令 $k_i$ 为节点 $i$ 的加权度。\n\n您将执行一轮Louvain启发式算法，从每个节点自成一个社区的初始划分开始。使用带权无向网络的模块度标准定义，分辨率参数 $\\gamma = 1$，并按以下步骤进行。\n\n- 局部移动阶段：按节点索引递增顺序 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$ 访问节点。对于一个节点 $i$，考虑将其移动到与 $i$ 相邻的每个邻居 $j$ 的社区中（基于 $\\mathbf{A}$），并计算在当前划分下每次候选移动的模块度变化量 $\\Delta Q$。如果所有候选的 $\\Delta Q \\leq 0$，则将节点 $i$ 保留在其当前社区中。如果存在任何候选的 $\\Delta Q > 0$，则将 $i$ 移动到能产生最大 $\\Delta Q$ 的邻居社区中。如果 $\\Delta Q$ 出现平局，选择与 $i$ 连接的边权最大的邻居（如果仍然平局，则选择索引最小的邻居）。执行扫描，直到完整的一次扫描中没有任何节点移动，这表示局部移动阶段已收敛。\n- 聚合阶段：将局部移动阶段结束时找到的社区聚合成超节点。超节点上自环的权重等于该社区内所有内部边的权重之和，两个超节点之间的权重等于原始图中这两个社区之间所有边的权重之和。\n\n从模块度的定义出发，推导出在此网络上执行局部移动阶段所需的相应 $\\Delta Q$ 表达式，根据上述规则评估候选移动，并在收敛后确定最终的社区。然后构建聚合网络，并计算由局部移动阶段找到的划分的改进模块度 $Q$。将最终模块度表示为一个最简分数。不允许四舍五入。您的最终答案必须是 $Q$ 的一个单一封闭形式值。",
            "solution": "Louvain方法通过迭代优化模块度 $Q$ 来寻找社区。将一个孤立节点 $i$ 移入社区 $C$ 的模块度变化 $\\Delta Q$ 为：\n$$ \\Delta Q = \\frac{k_{i,C}}{m} - \\frac{\\Sigma_{tot}^{(C)} k_i}{2m^2} $$\n其中 $m$ 是总边权，$k_i$ 是节点 $i$ 的加权度，$k_{i,C}$ 是从节点 $i$ 到社区 $C$ 的总边权，$\\Sigma_{tot}^{(C)}$ 是社区 $C$ 中所有节点的加权度之和。\n\n首先，计算网络属性：\n- 节点加权度: $k_1=2, k_2=2.1, k_3=2.1, k_4=2.1, k_5=2.1, k_6=2$。\n- 总边权: $m = \\frac{1}{2}\\sum k_i = 6.2$。\n\n**局部移动阶段**\n我们从每个节点自成一个社区的初始划分开始，按顺序 $1 \\to 6$ 遍历节点。\n1.  **节点 1:** 移至邻居 2 的社区产生最大的正 $\\Delta Q$。新划分为 $\\{\\{1,2\\}, \\{3\\}, \\{4\\}, \\{5\\}, \\{6\\}\\}$。\n2.  **节点 2:** 在其社区 $\\{1,2\\}$ 中保持不动，因为移动到任何邻居社区的 $\\Delta Q \\le 0$。\n3.  **节点 3:** 移至社区 $\\{1,2\\}$ 产生正的 $\\Delta Q$。新划分为 $\\{\\{1,2,3\\}, \\{4\\}, \\{5\\}, \\{6\\}\\}$。\n4.  **节点 4:** 移至邻居 6 的社区产生最大的正 $\\Delta Q$。新划分为 $\\{\\{1,2,3\\}, \\{4,6\\}, \\{5\\}\\}$。\n5.  **节点 5:** 移至社区 $\\{4,6\\}$ 产生正的 $\\Delta Q$。新划分为 $\\{\\{1,2,3\\}, \\{4,5,6\\}\\}$。\n6.  **节点 6:** 在其社区 $\\{4,5,6\\}$ 中保持不动。\n\n第一轮扫描后，划分为 $C_A = \\{1,2,3\\}$ 和 $C_B = \\{4,5,6\\}$。第二轮扫描确认没有节点移动可以增加模块度，因此算法收敛。\n\n**模块度计算**\n对于最终划分 $\\{\\{1,2,3\\}, \\{4,5,6\\}\\}$，模块度 $Q$ 的计算公式为：\n$$ Q = \\sum_{C} \\left[ \\frac{\\Sigma_{in}^{(C)}}{m} - \\left( \\frac{\\Sigma_{tot}^{(C)}}{2m} \\right)^2 \\right] $$\n- 社区 $C_A$: 内部总权重 $\\Sigma_{in}^{(A)} = A_{12}+A_{13}+A_{23} = 3$。社区总度数 $\\Sigma_{tot}^{(A)} = k_1+k_2+k_3=6.2$。\n- 社区 $C_B$: 内部总权重 $\\Sigma_{in}^{(B)} = A_{45}+A_{46}+A_{56} = 3$。社区总度数 $\\Sigma_{tot}^{(B)} = k_4+k_5+k_6=6.2$。\n\n最终模块度 $Q$ 为：\n$$ Q = \\left[ \\frac{3}{6.2} - \\left( \\frac{6.2}{12.4} \\right)^2 \\right] + \\left[ \\frac{3}{6.2} - \\left( \\frac{6.2}{12.4} \\right)^2 \\right] = 2 \\times \\left( \\frac{3}{6.2} - \\frac{1}{4} \\right) $$\n$$ Q = \\frac{6}{6.2} - \\frac{1}{2} = \\frac{30}{31} - \\frac{1}{2} = \\frac{60 - 31}{62} = \\frac{29}{62} $$",
            "answer": "$$\\boxed{\\frac{29}{62}}$$"
        }
    ]
}