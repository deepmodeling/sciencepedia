{
    "hands_on_practices": [
        {
            "introduction": "在测量和应用预警信号之前，我们必须首先从理论上理解它们为何会出现。本练习将通过分析奥恩斯坦-乌伦贝克过程（Ornstein–Uhlenbeck process），这一描述系统在稳定平衡点附近波动的基本模型，来从第一性原理出发进行推导。通过这个练习，你将亲手揭示当系统稳定性减弱时，其状态方差为何会系统性地增大，从而为临界慢化（critical slowing down）现象建立坚实的数学基础。",
            "id": "4121027",
            "problem": "在对复杂自适应系统中临界转变的早期预警信号的研究中，围绕一个稳定平衡点的随机涨落通常可以由一个线性的伊藤随机微分方程来近似，这个方程被称为奥恩斯坦-乌伦贝克（Ornstein–Uhlenbeck, OU）过程。考虑由以下随机微分方程定义的OU过程：$$dx=\\alpha x\\,dt+\\sigma\\,dW_t,$$ 其中 $x$ 是状态变量，$t$ 是时间，$W_t$ 是标准布朗运动（也称为维纳过程），$\\alpha0$ 是一个常数漂移参数，代表平衡点的局部线性稳定性，而 $\\sigma>0$ 是一个常数噪声振幅。假设采用自然边界条件，从而当 $\\alpha0$ 时存在一个平稳概率密度。从伊藤积分和福克-普朗克方程的基本定义出发，推导在平稳分布下 $x$ 的平稳方差 $\\mathrm{Var}[x]$。然后，在临界转变早期预警信号的背景下，解释当 $\\alpha\\to 0^{-}$ 时 $\\mathrm{Var}[x]$ 的行为。将你的最终答案表示为平稳方差关于 $\\alpha$ 和 $\\sigma$ 的闭式解析表达式。无需四舍五入，也无需单位。",
            "solution": "问题陈述被认为是有效的，因为它科学地基于已建立的随机过程和复杂系统理论，问题设定良好并提供了所有必要信息，且使用客观、明确的语言表达。因此，我们可以进行推导和分析。\n\n系统由奥恩斯坦-乌伦贝克过程描述，这是一个线性的伊藤随机微分方程（SDE），形式如下：\n$$\ndx = \\alpha x \\, dt + \\sigma \\, dW_t\n$$\n在这里，$x$ 是状态变量，$\\alpha  0$ 是指示稳定性的漂移参数，$\\sigma > 0$ 是恒定的噪声强度，$W_t$ 是标准的维纳过程。我们的任务是求出 $x$ 的平稳方差并解释当 $\\alpha \\to 0^{-}$ 时其行为。\n\n我们的主要工具是福克-普朗克方程（FPE），它描述了状态变量的概率密度函数 $p(x, t)$ 的时间演化。对于一个形如 $dX_t = f(X_t, t) \\, dt + g(X_t, t) \\, dW_t$ 的一般SDE，其FPE为：\n$$\n\\frac{\\partial p(x, t)}{\\partial t} = -\\frac{\\partial}{\\partial x} [f(x, t) p(x, t)] + \\frac{1}{2} \\frac{\\partial^2}{\\partial x^2} [g(x, t)^2 p(x, t)]\n$$\n在我们的具体案例中，漂移函数是 $f(x) = \\alpha x$，扩散函数是 $g(x) = \\sigma$。两者都与时间无关。将这些代入通用的FPE，得到奥恩斯坦-乌伦贝克过程的FPE：\n$$\n\\frac{\\partial p(x, t)}{\\partial t} = -\\frac{\\partial}{\\partial x} [\\alpha x p(x, t)] + \\frac{1}{2} \\frac{\\partial^2}{\\partial x^2} [\\sigma^2 p(x, t)]\n$$\n我们寻求平稳概率密度 $p_s(x)$，它被定义为概率密度不再随时间变化的解。因此，我们设 $\\frac{\\partial p_s(x)}{\\partial t} = 0$:\n$$\n0 = -\\frac{d}{dx} [\\alpha x p_s(x)] + \\frac{1}{2} \\frac{d^2}{dx^2} [\\sigma^2 p_s(x)]\n$$\n由于 $\\sigma$ 是一个常数，我们可以写成：\n$$\n0 = -\\frac{d}{dx} [\\alpha x p_s(x)] + \\frac{\\sigma^2}{2} \\frac{d^2 p_s(x)}{d x^2}\n$$\n这个方程可以用概率流 $J(x)$ 来表示：\n$$\n\\frac{dJ(x)}{dx} = 0 \\quad \\text{其中} \\quad J(x) = \\alpha x p_s(x) - \\frac{\\sigma^2}{2} \\frac{d p_s(x)}{d x}\n$$\n条件 $\\frac{dJ(x)}{dx} = 0$ 意味着概率流 $J(x)$ 是一个常数。对于一个具有平稳分布的过程，我们必须施加自然边界条件，即当 $x \\to \\pm\\infty$ 时，$p_s(x) \\to 0$。这在物理上意味着在无穷远处找到粒子的概率为零。在这些条件下，概率流必须处处为零，即 $J(x) = 0$。这给了我们一个关于 $p_s(x)$ 的一阶常微分方程：\n$$\n\\alpha x p_s(x) - \\frac{\\sigma^2}{2} \\frac{d p_s(x)}{d x} = 0\n$$\n重新整理各项以求解 $p_s(x)$：\n$$\n\\frac{d p_s(x)}{d x} = \\frac{2\\alpha}{\\sigma^2} x p_s(x)\n$$\n这是一个可分离的微分方程：\n$$\n\\frac{1}{p_s(x)} \\, dp_s(x) = \\frac{2\\alpha}{\\sigma^2} x \\, dx\n$$\n对两边积分：\n$$\n\\int \\frac{1}{p_s(x)} \\, dp_s(x) = \\int \\frac{2\\alpha}{\\sigma^2} x \\, dx\n$$\n$$\n\\ln(p_s(x)) = \\frac{\\alpha}{\\sigma^2} x^2 + C_0\n$$\n其中 $C_0$ 是积分常数。对两边取指数，得到平稳分布的形式：\n$$\np_s(x) = C \\exp\\left(\\frac{\\alpha x^2}{\\sigma^2}\\right)\n$$\n其中 $C = \\exp(C_0)$ 是归一化常数。我们可以将其识别为高斯（正态）分布的概率密度函数。一个均值为 $\\mu$、方差为 $\\Sigma^2$ 的一般高斯分布的密度函数形式为：\n$$\np(x) = \\frac{1}{\\sqrt{2\\pi\\Sigma^2}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\Sigma^2}\\right)\n$$\n通过将我们得到的 $p_s(x)$ 解的指数部分与标准高斯形式进行比较，我们可以确定均值和方差。指数中缺少 $x$ 的线性项意味着均值为 $\\mu=0$。然后我们可以令二次项相等：\n$$\n\\frac{\\alpha x^2}{\\sigma^2} = -\\frac{x^2}{2\\Sigma^2}\n$$\n由此，我们推导出平稳分布的方差 $\\Sigma^2$：\n$$\n\\frac{\\alpha}{\\sigma^2} = -\\frac{1}{2\\Sigma^2} \\implies \\Sigma^2 = -\\frac{\\sigma^2}{2\\alpha}\n$$\n因此，状态变量 $x$ 的平稳方差，记为 $\\mathrm{Var}[x]$，是：\n$$\n\\mathrm{Var}[x] = \\Sigma^2 = -\\frac{\\sigma^2}{2\\alpha}\n$$\n注意，由于 $\\alpha  0$ 且 $\\sigma > 0$，方差保证为正，符合要求。\n\n现在，我们来解释当 $\\alpha \\to 0^{-}$ 时此方差的行为。参数 $\\alpha$ 代表将系统状态 $x$ 拉回到稳定平衡点 $x=0$ 的线性恢复力的强度。一个绝对值大的 $\\alpha$ 值（即非常负）对应于一个强的恢复力和一个非常稳定的平衡。当一个系统接近临界转变（或称临界点）时，其平衡态的稳定性会减弱。在这个线性化模型中，这种稳定性的丧失表现为恢复力的减弱，这对应于参数 $\\alpha$ 从负侧趋近于零，即 $\\alpha \\to 0^{-}$。这种现象被称为“临界慢化”，因为返回平衡的特征时间尺度（与 $1/|\\alpha|$ 成正比）会发散。\n\n考察平稳方差的表达式 $\\mathrm{Var}[x] = -\\frac{\\sigma^2}{2\\alpha}$，我们可以取其在 $\\alpha \\to 0^{-}$ 时的极限：\n$$\n\\lim_{\\alpha \\to 0^{-}} \\mathrm{Var}[x] = \\lim_{\\alpha \\to 0^{-}} \\left(-\\frac{\\sigma^2}{2\\alpha}\\right) = +\\infty\n$$\n这个结果表明，随着系统稳定性的降低（$\\alpha \\to 0^{-}$），即使在噪声水平 $\\sigma$ 恒定的情况下，围绕平衡点的随机涨落的方差也会发散到无穷大。直观地看，随着恢复力的减弱，来自噪声项的随机“踢动”能够将系统推离其平衡点更远的位置，然后才被拉回。这种方差的急剧增加，是即将发生临界转变的一个关键的、通用的早期预警信号。因此，随时间测量系统输出的方差可以为其接近临界点提供一个指标。",
            "answer": "$$\\boxed{-\\frac{\\sigma^2}{2\\alpha}}$$"
        },
        {
            "introduction": "掌握了预警信号的理论基础后，下一步是将其应用于实际的时间序列数据中。本练习将指导你完成一个完整的计算流程：从使用欧拉-丸山法（Euler–Maruyama scheme）模拟一个接近分岔点的动力系统，到对生成的时间序列进行去趋势化处理，并最终在滚动窗口中计算关键的统计指标。通过这个实践，你将把抽象的理论转化为可操作的数据分析技能。",
            "id": "4120962",
            "problem": "考虑一个一维随机动力学系统，该系统由于一个缓慢变化的控制参数而经历状态转换。设状态为一个标量时间序列 $P(t)$，由鞍-结正规形中的随机微分方程（SDE）生成，并带有加性噪声，\n$$\n\\mathrm{d}P = \\left(\\mu(t) - P^2\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}W_t,\n$$\n其中 $\\mu(t)$ 是一个缓慢变化的控制参数，$\\sigma$ 是一个非负常数噪声振幅，$W_t$ 是一个标准维纳过程（布朗运动）。假设 $\\mu(t)$ 随时间线性递减，$\\mu(t) = \\mu_0 - v t$，其中 $\\mu_0 > 0$ 且 $v \\ge 0$。当稳定平衡点在 $\\mu(t_c) = 0$ 时消失，即在 $t_c = \\mu_0 / v$ 时（如果 $v > 0$），发生状态转换。\n\n您将使用欧拉-丸山（Euler–Maruyama）格式（一种SDE的一阶方法）构建一个离散时间近似，时间步长为 $\\Delta t > 0$：\n$$\nP_{t+1} = P_t + \\Delta t\\left(\\mu(t) - P_t^2\\right) + \\sigma \\sqrt{\\Delta t}\\,\\xi_t,\n$$\n其中 $\\xi_t \\sim \\mathcal{N}(0,1)$ 是独立的标准正态随机变量。在确定性平衡点 $P_0 = \\sqrt{\\mu_0}$ 处进行初始化。\n\n为了评估预警信号，请对临界转换前的数据段实施去趋势处理，然后计算滑动窗口指标。使用宽度为 $w_d$ 的移动平均来估计趋势，\n$$\n\\widehat{m}(t) = \\frac{1}{w_d}\\sum_{j = t - \\lfloor w_d/2 \\rfloor}^{t + \\lfloor w_d/2 \\rfloor} P(j),\n$$\n并进行适当的边界处理，然后计算去趋势序列\n$$\nX(t) = P(t) - \\widehat{m}(t).\n$$\n在宽度为 $w$、结束时间为 $t$ 的滑动窗口上，对每个窗口内的去趋势数据计算以下指标：\n- 带有贝塞尔（Bessel）校正的样本方差，\n$$\n\\operatorname{Var}_w(t) = \\frac{1}{w - 1}\\sum_{j = t-w+1}^{t} \\left(X(j) - \\overline{X}_{w}(t)\\right)^2, \\quad \\text{其中} \\quad \\overline{X}_{w}(t) = \\frac{1}{w}\\sum_{j = t-w+1}^{t} X(j).\n$$\n- 滞后-$1$自相关，\n$$\n\\rho_1^{(w)}(t) = \\frac{\\sum_{j = t-w+1}^{t-1} \\left(X(j) - \\overline{X}_{w}(t)\\right)\\left(X(j+1) - \\overline{X}_{w}(t)\\right)}{\\sum_{j = t-w+1}^{t} \\left(X(j) - \\overline{X}_{w}(t)\\right)^2}.\n$$\n\n通过使用肯德尔（Kendall）等级相关系数（KRCC），通常称为肯德尔tau系数，评估这些指标在临界转换前窗口 $t \\in \\{w, w+1, \\dots, t_c - L\\}$ 内的单调趋势。其中 $L$ 是一个小的整数余量，以确保分析排除分岔点附近的近奇异邻域。令 $\\tau_{\\mathrm{var}}$ 和 $p_{\\mathrm{var}}$ 分别表示 $\\operatorname{Var}_w(t)$ 与 $t$ 之间的肯德尔tau系数及其双边 $p$ 值，令 $\\tau_{\\mathrm{ac1}}$ 和 $p_{\\mathrm{ac1}}$ 表示 $\\rho_1^{(w)}(t)$ 与 $t$ 之间的这些量。定义一个带有阈值 $\\tau_{\\min}$ 和显著性水平 $\\alpha$ 的检测规则：\n- 如果 $\\tau_{\\mathrm{var}} \\ge \\tau_{\\min}$ 且 $p_{\\mathrm{var}}  \\alpha$，并且 $\\tau_{\\mathrm{ac1}} \\ge \\tau_{\\min}$ 且 $p_{\\mathrm{ac1}}  \\alpha$，则宣布检测到预警信号。\n\n目标是实现一个完整的、确定性的程序，该程序：\n1. 根据指定的参数集，按照欧拉-丸山格式模拟时间序列 $P(t)$。\n2. 使用宽度为 $w_d$ 的移动平均对序列进行去趋势处理，并计算临界转换前窗口（直到 $t_c - L$）的滑动窗口指标 $\\operatorname{Var}_w(t)$ 和 $\\rho_1^{(w)}(t)$。\n3. 在窗口结束时间集合上，计算每个指标相对于时间的肯德尔tau系数及其 $p$ 值。\n4. 应用带有给定 $\\tau_{\\min}$ 和 $\\alpha$ 的检测规则，为每个测试用例返回一个布尔结果。\n\n使用以下测试套件（每个用例都包含一个固定的随机种子以保证可复现性）：\n- 用例 $1$（理想路径，状态转换前有明显预警）：$N = 2500$, $\\Delta t = 1$, $\\mu_0 = 1.0$, $v = 5\\times 10^{-4}$, $\\sigma = 0.05$, $w_d = 101$, $w = 200$, $L = 25$, $\\tau_{\\min} = 0.6$, $\\alpha = 0.01$, seed $= 42$.\n- 用例 $2$（无状态转换，平稳基线）：$N = 2500$, $\\Delta t = 1$, $\\mu_0 = 1.0$, $v = 0$, $\\sigma = 0.05$, $w_d = 101$, $w = 200$, $L = 25$, $\\tau_{\\min} = 0.6$, $\\alpha = 0.01$, seed $= 7$.\n- 用例 $3$（高噪声，检测具有挑战性）：$N = 2500$, $\\Delta t = 1$, $\\mu_0 = 1.0$, $v = 5\\times 10^{-4}$, $\\sigma = 0.4$, $w_d = 101$, $w = 200$, $L = 25$, $\\tau_{\\min} = 0.6$, $\\alpha = 0.01$, seed $= 123$.\n- 用例 $4$（小窗口，指标可靠性的边缘情况）：$N = 2500$, $\\Delta t = 1$, $\\mu_0 = 1.0$, $v = 5\\times 10^{-4}$, $\\sigma = 0.05$, $w_d = 51$, $w = 50$, $L = 25$, $\\tau_{\\min} = 0.6$, $\\alpha = 0.01$, seed $= 99$.\n\n对于 $v = 0$ 的用例，将 $t_c$ 视为超出模拟范围（即，使用 $t_c = N\\Delta t$），因此临界转换前窗口为整个序列。确保至少存在 $10$ 个滑动窗口；否则，该用例返回布尔值 $False$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个布尔值，指示相应测试用例是否满足预警检测规则。",
            "solution": "用户在复杂系统分析领域提供了一个定义明确的问题，具体涉及临界转换的预警信号（EWS）检测。该问题在科学上是合理的，数学上是精确的，并且在计算上是可验证的。因此，它被认为是有效的。\n\n问题的核心在于分析一个从接近分岔的随机模型生成的时间序列。“临界慢化”现象预测，在此类转换点附近，系统从微小扰动中恢复的速度会变得越来越慢。这表现为系统涨落的方差和时间自相关性的增加。任务是实现一个标准处理流程来检测这些统计特征。\n\n解决方案的结构如下：\n1.  **系统模拟**：生成一个代表系统状态随时间变化的时间序列。\n2.  **信号处理**：对时间序列进行去趋势处理，以分离出围绕系统缓慢变化的平衡点的涨落。\n3.  **指标计算**：在去趋势的涨落数据上，计算滑动窗口方差和滞后-1自相关。\n4.  **趋势检测**：使用肯德尔等级相关系数，量化当系统接近分岔点时这些指标的单调趋势。\n5.  **假设检验**：根据观测到趋势的强度和统计显著性应用决策规则，以判断是否检测到预警。\n\n**步骤 1：使用欧拉-丸山格式进行模拟**\n系统状态 $P(t)$ 的演化遵循鞍-结分岔的随机微分方程（SDE）：\n$$\n\\mathrm{d}P = (\\mu(t) - P^2)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}W_t\n$$\n控制参数 $\\mu(t) = \\mu_0 - v t$ 缓慢下降，驱动系统走向一个临界转换点 $\\mu(t_c) = 0$，在该点，稳定平衡点 $P = \\sqrt{\\mu}$ 与不稳定平衡点 $P = -\\sqrt{\\mu}$ 合并并消失。\n\n我们使用离散时间的欧拉-丸山近似，以时间步长 $\\Delta t$ 来模拟这个连续时间过程：\n$$\nP_{i+1} = P_i + f(P_i, t_i)\\Delta t + g(P_i, t_i)\\sqrt{\\Delta t}\\,\\xi_i\n$$\n这里，$t_i = i \\Delta t$，$P_i \\approx P(t_i)$，漂移项为 $f(P_i, t_i) = \\mu(t_i) - P_i^2 = (\\mu_0 - v t_i) - P_i^2$，扩散项为 $g(P_i, t_i) = \\sigma$，而 $\\xi_i$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立随机变量。模拟在 $t=0$ 时的稳定平衡点 $P_0 = \\sqrt{\\mu(0)} = \\sqrt{\\mu_0}$ 处初始化。\n\n**步骤 2：去趋势**\n随着控制参数 $\\mu(t)$ 的漂移，系统的稳定平衡状态也随之漂移。因此，所生成的时间序列 $P(t)$ 既包含这种缓慢的趋势，也包含围绕该趋势的涨落。为了分析涨落的特性，必须首先估计并移除趋势。问题指定使用宽度为 $w_d$ 的中心移动平均来实现此目的：\n$$\n\\widehat{m}(i) = \\frac{1}{w_d} \\sum_{j = i - \\lfloor w_d/2 \\rfloor}^{i + \\lfloor w_d/2 \\rfloor} P_j\n$$\n这提供了一个局部均值的估计。对于窗口超出数据范围的索引 $i$，通过用最近的边界值扩展时间序列来处理边界条件。去趋势后的序列为：\n$$\nX_i = P_i - \\widehat{m}(i)\n$$\n\n**步骤 3：滑动窗口指标**\n临界慢化理论预测，当 $\\mu(t) \\to 0^+$ 时，涨落 $X_t$ 的方差和滞后-1自相关将增加。为了追踪这些变化，我们在固定宽度 $w$ 的滑动窗口上计算它们的样本估计值。对于一个在时间索引 $t$ 结束，覆盖从 $X_{t-w+1}$ 到 $X_t$ 的数据的窗口：\n\n- **样本方差（带贝塞尔校正）**：方差衡量涨落的幅度。贝塞尔校正（使用 $1/(w-1)$ 而非 $1/w$）提供了一个无偏估计。\n$$\n\\operatorname{Var}_w(t) = \\frac{1}{w - 1}\\sum_{j = t-w+1}^{t} \\left(X_j - \\overline{X}_{w}(t)\\right)^2\n$$\n\n- **滞后-1自相关**：这衡量了涨落中的“记忆”或时间相关性。记忆增强是临界慢化的直接后果。\n$$\n\\rho_1^{(w)}(t) = \\frac{\\sum_{j = t-w+1}^{t-1} \\left(X_j - \\overline{X}_{w}(t)\\right)\\left(X_{j+1} - \\overline{X}_{w}(t)\\right)}{\\sum_{j = t-w+1}^{t} \\left(X_j - \\overline{X}_{w}(t)\\right)^2}\n$$\n这些指标在临界转换前分析窗口内的每个时间步 $t$ 进行计算，从而创建两个新的时间序列：$\\operatorname{Var}_w(t)$ 和 $\\rho_1^{(w)}(t)$。\n\n**步骤 4：使用肯德尔tau系数进行趋势分析**\n为确认预警信号的存在，我们必须检测到当系统接近分岔时，两个指标都存在统计上显著的递增趋势。问题指定使用肯德尔等级相关系数 $\\tau$，这是一种衡量两个变量之间单调关系的非参数度量。我们在临界转换前分析窗口（由时间索引 $t \\in \\{w, w+1, \\dots, t_{c,idx} - L\\}$ 定义，其中 $t_{c,idx} = \\lfloor (\\mu_0/v)/\\Delta t \\rfloor$ 是临界点的索引，$L$ 提供了一个安全余量）上，计算每个指标序列相对于时间的 $\\tau$。这会产生两个相关系数 $\\tau_{\\mathrm{var}}$ 和 $\\tau_{\\mathrm{ac1}}$，以及它们对应的双边 $p$ 值 $p_{\\mathrm{var}}$ 和 $p_{\\mathrm{ac1}}$。$p$ 值量化了在没有趋势的原假设下，观测到至少与测量到的趋势一样强的趋势的概率。\n\n**步骤 5：检测规则**\n当且仅当两个指标都显示出既足够强又具有统计显著性的正向趋势时，才正式检测到预警信号。具体条件是：\n1.  $\\tau_{\\mathrm{var}} \\ge \\tau_{\\min}$ 且 $p_{\\mathrm{var}}  \\alpha$\n2.  $\\tau_{\\mathrm{ac1}} \\ge \\tau_{\\min}$ 且 $p_{\\mathrm{ac1}}  \\alpha$\n\n这两个条件必须同时满足。阈值 $\\tau_{\\min}$ 和 $\\alpha$ 控制着灵敏度（检测真实预警）和特异性（避免假警报）之间的权衡。整个过程被封装在一个确定性函数中，该函数在给定一组参数和随机种子的情况下，返回一个表示此检测规则结果的布尔值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import kendalltau\nfrom scipy.ndimage import uniform_filter1d\n\ndef run_analysis(N, dt, mu0, v, sigma, w_d, w, L, tau_min, alpha, seed):\n    \"\"\"\n    Runs the full simulation and early warning signal analysis for a single test case.\n    \"\"\"\n    # 1. Setup and Simulation\n    np.random.seed(seed)\n    \n    # Time vector and parameter vector\n    t_sim = np.arange(N) * dt\n    mu_t = mu0 - v * t_sim\n\n    # Initialize state vector and set initial condition\n    P = np.zeros(N)\n    if mu0 >= 0:\n        P[0] = np.sqrt(mu0)\n    else:\n        # Should not happen with given test cases, but for robustness\n        P[0] = 0.0\n\n    # Generate random increments for SDE\n    xi = np.random.randn(N - 1)\n\n    # Euler-Maruyama simulation loop\n    for i in range(N - 1):\n        drift = mu_t[i] - P[i]**2\n        diffusion = sigma * np.sqrt(dt) * xi[i]\n        P[i+1] = P[i] + dt * drift + diffusion\n\n    # 2. Pre-transition window definition\n    if v > 0:\n        tc_val = mu0 / v\n        tc_idx = int(tc_val / dt)\n    else: # v = 0, no bifurcation within simulation time\n        tc_val = N * dt\n        tc_idx = N\n\n    # The analysis will be on indicator values computed for these time indices\n    analysis_indices = np.arange(w, tc_idx - L)\n    \n    if len(analysis_indices)  10:\n        return False\n\n    # 3. Detrending\n    # Use uniform_filter1d for a centered moving average. mode='nearest' handles boundaries.\n    trend = uniform_filter1d(P, size=w_d, mode='nearest')\n    X = P - trend\n\n    # 4. Rolling-window indicators\n    variances = []\n    autocorrs = []\n    \n    for t_idx in analysis_indices:\n        # Window of detrended data X ending at t_idx\n        window_X = X[t_idx - w + 1 : t_idx + 1]\n        \n        # Calculate sample variance with Bessel's correction (ddof=1)\n        var = np.var(window_X, ddof=1)\n        variances.append(var)\n        \n        # Calculate lag-1 autocorrelation\n        mean_X = np.mean(window_X)\n        devs = window_X - mean_X\n        # The sum in the denominator covers the full window (w elements)\n        # The sum in the numerator covers w-1 pairs\n        numerator = np.sum(devs[:-1] * devs[1:])\n        denominator = np.sum(devs**2)\n        \n        if denominator == 0:\n            ac1 = np.nan # Avoid division by zero, will be ignored by kendalltau\n        else:\n            ac1 = numerator / denominator\n        autocorrs.append(ac1)\n\n    # 5. Trend analysis with Kendall's Tau and Detection\n    variances = np.array(variances)\n    autocorrs = np.array(autocorrs)\n    \n    # Filter out any NaNs that might have occurred\n    valid_mask_var = ~np.isnan(variances)\n    valid_mask_ac1 = ~np.isnan(autocorrs)\n\n    if np.sum(valid_mask_var)  2 or np.sum(valid_mask_ac1)  2:\n        # Not enough data for correlation\n        return False\n\n    tau_var, p_var = kendalltau(analysis_indices[valid_mask_var], variances[valid_mask_var])\n    tau_ac1, p_ac1 = kendalltau(analysis_indices[valid_mask_ac1], autocorrs[valid_mask_ac1])\n    \n    # Detection Rule\n    warning_detected = (tau_var >= tau_min and p_var  alpha and\n                        tau_ac1 >= tau_min and p_ac1  alpha)\n                        \n    return warning_detected\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1: happy path, clear early warning\n        {'N': 2500, 'dt': 1, 'mu0': 1.0, 'v': 5e-4, 'sigma': 0.05, 'w_d': 101, 'w': 200, 'L': 25, 'tau_min': 0.6, 'alpha': 0.01, 'seed': 42},\n        # Case 2: no regime shift, stationary baseline\n        {'N': 2500, 'dt': 1, 'mu0': 1.0, 'v': 0, 'sigma': 0.05, 'w_d': 101, 'w': 200, 'L': 25, 'tau_min': 0.6, 'alpha': 0.01, 'seed': 7},\n        # Case 3: high noise, challenging detection\n        {'N': 2500, 'dt': 1, 'mu0': 1.0, 'v': 5e-4, 'sigma': 0.4, 'w_d': 101, 'w': 200, 'L': 25, 'tau_min': 0.6, 'alpha': 0.01, 'seed': 123},\n        # Case 4: small window, edge case\n        {'N': 2500, 'dt': 1, 'mu0': 1.0, 'v': 5e-4, 'sigma': 0.05, 'w_d': 51, 'w': 50, 'L': 25, 'tau_min': 0.6, 'alpha': 0.01, 'seed': 99},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_analysis(\n            N=case['N'], dt=case['dt'], mu0=case['mu0'], v=case['v'], \n            sigma=case['sigma'], w_d=case['w_d'], w=case['w'], L=case['L'],\n            tau_min=case['tau_min'], alpha=case['alpha'], seed=case['seed']\n        )\n        results.append(result)\n\n    # Format output as a comma-separated list of lowercase booleans in brackets\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在计算出预警指标（如方差）的上升趋势后，一个至关重要的问题是：这个趋势是否具有统计显著性，抑或仅仅是随机波动的结果？本练习将介绍一种强大的非参数检验方法——移动块自举法（moving-block bootstrap），来构建一个可靠的零假设分布。这个方法能够恰当地处理时间序列中的自相关性，从而让你能够稳健地评估观测到的方差增长是否是一个真正的预警信号。",
            "id": "4121017",
            "problem": "您的任务是构建一个移动块自举（moving-block bootstrap），用于在单变量时间序列中保留短期自相关性，并利用它来检验序列末端观察到的方差增加是否超出了在平稳零假设下偶然预期的范围。该问题的动机源于复杂自适应系统中临界转变的预警信号，其中当恢复速率在分岔点附近减慢时，通常会观察到方差的增加。您的解决方案必须从以下基本基础和定义出发，不得调用任何快捷结果。\n\n基本基础和定义：\n- 如果对于小的整数滞后 $k$，$\\operatorname{Cov}(x_t, x_{t+k}) \\neq 0$，则称单变量时间序列 $\\{x_t\\}_{t=1}^N$ 表现出短期自相关性。一个常用于模拟短期自相关性的模型是一阶自回归过程（AR(1)），定义为 $x_t = \\phi x_{t-1} + \\sigma_t \\varepsilon_t$，其中 $|\\phi|  1$，$\\varepsilon_t \\sim \\mathcal{N}(0,1)$ 是独立同分布的高斯新息，$\\sigma_t > 0$ 是一个时变噪声尺度。具有恒定 $\\sigma_t \\equiv \\sigma$ 的平稳 AR(1) 过程的方差为 $\\operatorname{Var}(x_t) = \\sigma^2/(1-\\phi^2)$。\n- 临界转变的预警信号是方差的增加，在稳定平衡点附近最简单的线性化设定中，这是由线性恢复率的降低以及相应的 Ornstein–Uhlenbeck 过程平稳方差的增加所导致的。\n- 为了检验从序列开始到结束方差是否增加，定义检验统计量 $T = S^2_{\\text{end}} - S^2_{\\text{start}}$，其中 $S^2_{\\text{start}}$ 是对前 $w$ 个观测值计算的无偏样本方差，$S^2_{\\text{end}}$ 是对后 $w$ 个观测值计算的无偏样本方差，两者均使用除数 $(w-1)$。\n- 由于短期自相关使得独立同分布重采样无效，因此构建一个块长度为 $l$ 的循环移动块自举，以在序列具有短程依赖性的零假设下，近似 $T$ 的抽样分布。在一个长度为 $N$ 的循环移动块自举中，从 $\\{1,\\dots,N\\}$ 中均匀独立地抽取起始索引 $s_1, \\dots, s_B$，对于每个起始点 $s$，取连续块 $(x_s, x_{s+1}, \\dots, x_{s+l-1})$，其中索引按模 $N$ 解释。连接足够多的块以获得长度为 $N$ 的自举复制样本，并在必要时进行截断。在适当的混合条件下，此过程在期望上保留了直至块长度 $l$ 的短期自相关性。\n\n检验目标：\n- 对于给定的时间序列实现以及选定的 $w$ 和 $l$，通过以下公式估计 $H_0$（方差无系统性增加）对 $H_A$（最后一个窗口的方差更大）的单侧自举 $p$ 值：\n$$\n\\hat{p} = \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\{T^{(b)} \\ge T_{\\text{obs}}\\}}{B+1},\n$$\n其中 $T_{\\text{obs}}$ 是观察到的统计量，$T^{(b)}$ 是从每个自举复制样本计算出的自举统计量。如果在水平 $\\alpha$ 下 $\\hat{p} \\le \\alpha$，则拒绝 $H_0$。\n\n测试套件的时间序列生成：\n- 对于每个测试用例，使用 $x_0 = 0$、独立的 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$ 以及为 $\\sigma_t$ 指定的分段方案，通过 AR(1) 递归 $x_t = \\phi x_{t-1} + \\sigma_t \\varepsilon_t$ 生成长度为 $N$ 的 $\\{x_t\\}$：\n  - 无变化：对于所有 $t$，$\\sigma_t \\equiv \\sigma$。\n  - 跳跃变化：对于 $1 \\le t \\le N-L$，$\\sigma_t = \\sigma$；对于 $N-L+1 \\le t \\le N$，$\\sigma_t = \\sigma \\cdot f$，其中 $f > 1$ 是最终的乘法因子，$L$ 是高方差尾部的长度。\n  - 斜坡变化：对于 $1 \\le t \\le N-L$，$\\sigma_t = \\sigma$；对于 $N-L+1 \\le t \\le N$，$\\sigma_t = \\sigma \\cdot \\left(1 + (f-1)\\cdot \\frac{t-(N-L)}{L}\\right)$，在最后 $L$ 个点上从 $\\sigma$ 线性增加到 $\\sigma f$。\n\n检验统计量的计算：\n- 使用前 $w$ 个样本 $\\{x_1,\\dots,x_w\\}$ 计算 $S^2_{\\text{start}}$，使用后 $w$ 个样本 $\\{x_{N-w+1},\\dots,x_N\\}$ 计算 $S^2_{\\text{end}}$。使用无偏估计量 $S^2 = \\frac{1}{w-1}\\sum_{i=1}^{w} (x_i - \\bar{x})^2$。\n\n自举过程：\n- 实现块长度为 $l$、自举复制样本数为 $B$ 的循环移动块自举，并按上述定义计算单侧自举 $p$ 值。通过与指定的水平 $\\alpha$ 比较来决定显著性。\n\n您的程序必须：\n- 实现上述生成器、统计量和自举检验。\n- 使用提供的测试套件，每个用例都已完全指定，无外部输入。\n\n测试套件：\n对于每个用例，使用给定的随机种子初始化生成器，然后生成序列并使用指定的参数执行检验。以下所有数字均为精确值，必须按原样使用。\n\n- 用例 1（零假设，中等自相关）：\n  - 种子 $= 123$\n  - $N = 800$, $\\phi = 0.6$, $\\sigma = 1.0$\n  - 变化：无\n  - 窗口大小 $w = 200$\n  - 块长度 $l = 40$\n  - 自举复制样本数 $B = 600$\n  - 显著性水平 $\\alpha = 0.05$\n\n- 用例 2（备择假设，斜坡式方差增加）：\n  - 种子 $= 456$\n  - $N = 800$, $\\phi = 0.6$, $\\sigma = 1.0$\n  - 变化：斜坡，长度 $L = 300$，最终因子 $f = 1.8$\n  - 窗口大小 $w = 200$\n  - 块长度 $l = 40$\n  - 自举复制样本数 $B = 600$\n  - 显著性水平 $\\alpha = 0.05$\n\n- 用例 3（零假设，强自相关）：\n  - 种子 $= 789$\n  - $N = 800$, $\\phi = 0.9$, $\\sigma = 1.0$\n  - 变化：无\n  - 窗口大小 $w = 200$\n  - 块长度 $l = 60$\n  - 自举复制样本数 $B = 700$\n  - 显著性水平 $\\alpha = 0.05$\n\n- 用例 4（备择假设，白噪声伴随方差跳跃）：\n  - 种子 $= 222$\n  - $N = 600$, $\\phi = 0.0$, $\\sigma = 1.0$\n  - 变化：跳跃，长度 $L = 220$，最终因子 $f = 1.7$\n  - 窗口大小 $w = 150$\n  - 块长度 $l = 16$\n  - 自举复制样本数 $B = 700$\n  - 显著性水平 $\\alpha = 0.05$\n\n- 用例 5（备择假设，短序列边界情况伴随跳跃）：\n  - 种子 $= 333$\n  - $N = 220$, $\\phi = 0.5$, $\\sigma = 1.0$\n  - 变化：跳跃，长度 $L = 100$，最终因子 $f = 1.6$\n  - 窗口大小 $w = 80$\n  - 块长度 $l = 16$\n  - 自举复制样本数 $B = 800$\n  - 显著性水平 $\\alpha = 0.05$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的布尔值列表，用方括号括起来，顺序与上述用例一致。例如：“[True,False,True,False,True]”。",
            "solution": "该问题要求实现并应用循环移动块自举，以检验单变量时间序列中方差的显著增加。此过程在复杂系统分析中很常见，其中方差增加可作为即将发生的临界转变（如分岔）的预警信号。解决方案的步骤是：首先根据指定的模型生成时间序列数据，然后计算一个观察到的检验统计量，最后使用自举方法估计该统计量的统计显著性。\n\n首先，我们定义生成时间序列数据的过程。数据 $\\{x_t\\}_{t=1}^N$ 由一阶自回归过程（或称 AR(1) 过程）生成。该模型由以下递推关系定义：\n$$\nx_t = \\phi x_{t-1} + \\sigma_t \\varepsilon_t\n$$\n其中 $t$ 的范围是从 $1$ 到序列长度 $N$。参数 $\\phi$ 是自回归系数，满足 $|\\phi|  1$ 以保证平稳性。项 $\\varepsilon_t$ 表示从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立同分布 (i.i.d.) 随机变量序列。初始条件设置为 $x_0 = 0$。参数 $\\sigma_t > 0$ 表示噪声项的时变标准差。问题指定了三种不同的 $\\sigma_t$ 方案：\n1.  **无变化（零假设）：** $\\sigma_t$ 是常数，对于所有 $t \\in \\{1, \\dots, N\\}$，$\\sigma_t = \\sigma$。这代表一个平稳过程。\n2.  **跳跃变化（备择假设）：** $\\sigma_t$ 在序列末端附近经历一次突增。对于给定的变化长度 $L$ 和因子 $f > 1$，方案为：\n    $$\n    \\sigma_t = \\begin{cases} \\sigma  \\text{若 } 1 \\le t \\le N-L \\\\ \\sigma \\cdot f  \\text{若 } N-L+1 \\le t \\le N \\end{cases}\n    $$\n3.  **斜坡变化（备择假设）：** $\\sigma_t$ 在序列的最后部分线性增加。对于给定的变化长度 $L$ 和因子 $f > 1$，方案为：\n    $$\n    \\sigma_t = \\begin{cases} \\sigma  \\text{若 } 1 \\le t \\le N-L \\\\ \\sigma \\left(1 + (f-1) \\frac{t-(N-L)}{L}\\right)  \\text{若 } N-L+1 \\le t \\le N \\end{cases}\n    $$\n通过为每个测试用例使用特定的种子初始化伪随机数生成器，确保了时间序列生成的可复现性。\n\n其次，我们定义检验统计量 $T$ 来量化时间序列开始和结束之间方差的变化。该统计量是计算于两个大小为 $w$ 的窗口上的样本方差之差：\n$$\nT = S^2_{\\text{end}} - S^2_{\\text{start}}\n$$\n$S^2_{\\text{start}}$ 是前 $w$ 个数据点 $\\{x_1, \\dots, x_w\\}$ 的无偏样本方差，$S^2_{\\text{end}}$ 是后 $w$ 个数据点 $\\{x_{N-w+1}, \\dots, x_N\\}$ 的无偏样本方差。对于一组 $w$ 个观测值 $\\{y_1, \\dots, y_w\\}$，其样本均值为 $\\bar{y}$，无偏样本方差由下式给出：\n$$\nS^2 = \\frac{1}{w-1} \\sum_{i=1}^{w} (y_i - \\bar{y})^2\n$$\n观察到的统计量 $T_{\\text{obs}}$ 的一个大的正值表明方差有所增加。\n\n第三，为了确定 $T_{\\text{obs}}$ 是否具有统计显著性，我们必须在零假设 ($H_0$) 下评估其偶然发生的概率，即基础过程是平稳的（方差没有系统性趋势）。由于数据点是自相关的，假设独立性的标准检验是无效的。因此，我们使用循环移动块自举来构建 $T$ 在 $H_0$ 下的抽样分布。该方法保留了原始序列直至所选块长度 $l$ 的依赖结构。该过程重复 $B$ 次，如下所示：\n1.  对于每个自举复制样本 $b \\in \\{1, \\dots, B\\}$，创建一个长度为 $N$ 的新时间序列 $x^{(b)}$。\n2.  新序列是通过连接 $K = \\lceil N/l \\rceil$ 个长度为 $l$ 的块来构建的。\n3.  这 $K$ 个块中的每一个都从原始时间序列 $\\{x_t\\}_{t=1}^N$ 中抽取。从 $\\{1, \\dots, N\\}$ 中均匀随机地选择一个起始索引 $s$。相应的块由 $l$ 个连续观测值 $(x_s, x_{s+1}, \\dots, x_{s+l-1})$ 组成。索引被循环地解释，因此索引 $j > N$ 被映射到 $j \\pmod N$（或者更精确地，对于基于1的索引，是 $(j-1) \\pmod N + 1$）。\n4.  将连接成的长度为 $K \\cdot l$ 的序列截断到原始长度 $N$，形成自举复制样本 $x^{(b)}$。\n5.  对于每个复制样本 $x^{(b)}$，以与 $T_{\\text{obs}}$ 相同的方式计算检验统计量 $T^{(b)}$。\n\n最后，估计单侧自举 $p$ 值。该值表示在零假设为真的情况下，观察到等于或大于 $T_{\\text{obs}}$ 的检验统计量的概率。其计算公式为：\n$$\n\\hat{p} = \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\{T^{(b)} \\ge T_{\\text{obs}}\\}}{B+1}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果其参数为真则为 $1$，否则为 $0$。在分子和分母上加 $1$ 是一个标准惯例，以防止 $p$ 值为 $0$ 并提供更稳定的估计。如果在显著性水平 $\\alpha$ 下 $\\hat{p} \\le \\alpha$，则拒绝零假设 $H_0$。对于每个测试用例，我们执行这整个过程，并确定是否拒绝 $H_0$，从而得出一个布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_ar1_series(N, phi, sigma_params):\n    \"\"\"\n    Generates a time series from an AR(1) process with a specified sigma_t schedule.\n    x_t = phi * x_{t-1} + sigma_t * epsilon_t\n    \"\"\"\n    change_type = sigma_params.get(\"change\")\n    sigma_base = sigma_params.get(\"sigma\", 1.0)\n    L = sigma_params.get(\"L\")\n    f = sigma_params.get(\"f\")\n\n    # Generate noise schedule sigmas of length N (for t=1..N)\n    sigmas = np.full(N, sigma_base, dtype=float)\n    if change_type == \"jump\":\n        start_idx = N - L\n        sigmas[start_idx:] = sigma_base * f\n    elif change_type == \"ramp\":\n        start_idx = N - L\n        ramp_values = np.linspace(1.0, f, L)\n        sigmas[start_idx:] = sigma_base * ramp_values\n\n    # Generate innovations epsilon_t for t=1..N\n    eps = np.random.randn(N)\n    \n    # Generate the time series x_t for t=1..N using 0-based indexing for arrays\n    x = np.zeros(N)\n    # x[0] corresponds to x_1. Since x_0 = 0, x_1 = sigma_1 * epsilon_1\n    if N > 0:\n        x[0] = sigmas[0] * eps[0]\n        for t in range(1, N):\n            x[t] = phi * x[t-1] + sigmas[t] * eps[t]\n            \n    return x\n\ndef calculate_T_statistic(series, w):\n    \"\"\"\n    Computes the test statistic T = Var(end) - Var(start).\n    \"\"\"\n    if len(series)  w:\n        raise ValueError(\"Series length must be at least window size w.\")\n        \n    start_window = series[:w]\n    end_window = series[-w:]\n    \n    # np.var with ddof=1 computes the unbiased sample variance\n    var_start = np.var(start_window, ddof=1)\n    var_end = np.var(end_window, ddof=1)\n    \n    return var_end - var_start\n\ndef run_bootstrap_test(series, w, l, B, alpha):\n    \"\"\"\n    Performs the circular moving-block bootstrap test.\n    \"\"\"\n    N = len(series)\n    \n    # 1. Calculate the observed statistic\n    T_obs = calculate_T_statistic(series, w)\n    \n    # 2. Perform bootstrap resampling\n    num_blocks_needed = int(np.ceil(N / l))\n    count_ge = 0\n    \n    for _ in range(B):\n        # Create one bootstrap replicate\n        start_indices = np.random.randint(0, N, size=num_blocks_needed)\n        \n        replicate_blocks = []\n        for s in start_indices:\n            block_indices = (np.arange(l) + s) % N\n            replicate_blocks.append(series[block_indices])\n            \n        bootstrap_series = np.concatenate(replicate_blocks)[:N]\n        \n        # Calculate statistic for the replicate\n        T_b = calculate_T_statistic(bootstrap_series, w)\n        \n        if T_b >= T_obs:\n            count_ge += 1\n            \n    # 3. Calculate p-value\n    p_value = (1.0 + count_ge) / (1.0 + B)\n    \n    # 4. Return decision\n    return p_value = alpha\n\ndef solve():\n    test_cases = [\n        # Case 1: null, moderate autocorrelation\n        {'seed': 123, 'N': 800, 'phi': 0.6, 'sigma_params': {'change': 'none', 'sigma': 1.0},\n         'w': 200, 'l': 40, 'B': 600, 'alpha': 0.05},\n        # Case 2: alternative, ramped variance increase\n        {'seed': 456, 'N': 800, 'phi': 0.6, 'sigma_params': {'change': 'ramp', 'sigma': 1.0, 'L': 300, 'f': 1.8},\n         'w': 200, 'l': 40, 'B': 600, 'alpha': 0.05},\n        # Case 3: null, strong autocorrelation\n        {'seed': 789, 'N': 800, 'phi': 0.9, 'sigma_params': {'change': 'none', 'sigma': 1.0},\n         'w': 200, 'l': 60, 'B': 700, 'alpha': 0.05},\n        # Case 4: alternative, white noise with jump in variance\n        {'seed': 222, 'N': 600, 'phi': 0.0, 'sigma_params': {'change': 'jump', 'sigma': 1.0, 'L': 220, 'f': 1.7},\n         'w': 150, 'l': 16, 'B': 700, 'alpha': 0.05},\n        # Case 5: alternative, short series boundary case with jump\n        {'seed': 333, 'N': 220, 'phi': 0.5, 'sigma_params': {'change': 'jump', 'sigma': 1.0, 'L': 100, 'f': 1.6},\n         'w': 80, 'l': 16, 'B': 800, 'alpha': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        np.random.seed(case['seed'])\n        \n        # Generate the time series\n        time_series = generate_ar1_series(case['N'], case['phi'], case['sigma_params'])\n        \n        # Run the test\n        is_significant = run_bootstrap_test(time_series, case['w'], case['l'], case['B'], case['alpha'])\n        results.append(is_significant)\n\n    # Format output as specified\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}