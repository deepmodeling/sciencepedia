{
    "hands_on_practices": [
        {
            "introduction": "掌握自组织临界性模型的最好方法之一就是亲自动手进行模拟。这个基础练习将引导你手动模拟一个沙堆模型中的“雪崩”过程。通过在一个小尺寸的网格上追踪一个沙粒引发的连锁反应，你将对阿贝尔沙堆模型 (Abelian Sandpile Model, ASM) 的核心动力学——包括不稳定、坍塌和稳定化等概念——建立起具体而直观的理解。",
            "id": "4142578",
            "problem": "考虑一个具有开放边界的二维方格上的阿贝尔沙堆模型（ASM）。设晶格为 $3 \\times 3$ 的网格，其上的格点由坐标 $(i,j) \\in \\{-1,0,1\\} \\times \\{-1,0,1\\}$ 索引，原点为 $(0,0)$。每个格点 $(i,j)$ 具有一个整数高度 $h(i,j) \\in \\mathbb{Z}_{\\ge 0}$。如果一个格点的高度至少为 $4$，则该格点是不稳定的。在格点 $(i,j)$ 发生一次坍塌（toppling）会使 $h(i,j)$ 减少 $4$，并使其每个最近邻居（内部最多四个，边界上较少）的高度增加 $1$。在开放边界条件下，任何将被送到 $3 \\times 3$ 网格之外的邻居的沙粒都会耗散并永久离开系统。\n\n从最大稳定初始构型开始，即所有九个格点的高度均为 $h(i,j) = 3$。在原点 $(0,0)$ 添加一粒沙，并通过迭代地坍塌不稳定格点来稳定该构型，直到所有格点都变得稳定。通过明确列出您所应用的坍塌序列并报告所有格点的最终稳定高度来演示稳定化过程。\n\n在此稳定化过程中，所有格点上发生的总坍塌次数是多少？请以单个整数形式提供您的答案。无需四舍五入，不涉及单位。",
            "solution": "问题陈述已经过验证，被认为是复杂自适应系统建模领域内，特别是阿贝尔沙堆模型（ASM）范畴下的一个定义良好、有科学依据的问题。\n\n该系统是一个 $3 \\times 3$ 的格点网格，由坐标 $(i,j)$ 索引，其中 $i, j \\in \\{-1, 0, 1\\}$。每个格点 $(i,j)$ 都有一个整数高度 $h(i,j)$。如果一个格点的高度 $h(i,j) \\ge 4$，则该格点是不稳定的。在格点 $(i,j)$ 发生一次坍塌会导致高度发生如下变化：\n$h(i,j) \\to h(i,j) - 4$\n$h(\\text{neighbors}) \\to h(\\text{neighbors}) + 1$\n系统具有开放边界，因此任何会流向网格外部格点的沙粒都会丢失。\n\n初始状态是最大稳定构型，其中所有格点的高度均为 $3$。我们可以将高度构型表示为一个矩阵 $H$，其中矩阵索引 $(r,c)$（$r,c \\in \\{1,2,3\\}$）对应于网格坐标 $(j-2, 2-r)$。\n初始构型 $H_{init}$ 为：\n$$ H_{init} = \\begin{pmatrix} 3  3  3 \\\\ 3  3  3 \\\\ 3  3  3 \\end{pmatrix} $$\n\n过程始于在原点，即格点 $(0,0)$，添加一粒沙。这对应于网格的中心。$(0,0)$ 处的高度变为 $3+1=4$。现在的构型是：\n$$ H_0 = \\begin{pmatrix} 3  3  3 \\\\ 3  4  3 \\\\ 3  3  3 \\end{pmatrix} $$\n格点 $(0,0)$ 现在是不稳定的。稳定化过程以一系列坍塌的形式进行。ASM 的一个关键特性是，最终构型和总坍塌次数与不稳定格点被坍塌的顺序无关。\n\n**第1步：第一次坍塌**\n唯一不稳定的格点是 $(0,0)$，其高度 $h(0,0)=4$。我们坍塌这个格点。\n- 格点 $(0,0)$ 的高度减少 $4$：$h(0,0) \\to 4-4=0$。\n- 其四个最近邻居 $(0,-1)$、$(0,1)$、$(-1,0)$ 和 $(1,0)$ 的高度各增加 $1$。它们的高度变为 $3+1=4$。\n得到的构型 $H_1$ 是：\n$$ H_1 = \\begin{pmatrix} 3  4  3 \\\\ 4  0  4 \\\\ 3  4  3 \\end{pmatrix} $$\n到目前为止的坍塌次数是 $1$。\n\n**第2步：第二轮坍塌**\n构型 $H_1$ 有四个不稳定的格点：四个边格点 $(0,-1)$、$(0,1)$、$(-1,0)$ 和 $(1,0)$，它们的高度都为 $4$。我们坍塌这四个格点。顺序无关紧要。我们来分析这四次坍塌的集体效应。\n- 这四个格点每个坍塌一次。它们的高度减少 $4$：$h \\to 4-4=0$。\n- 格点 $(0,0)$：它是所有四个坍塌格点的邻居。其高度增加 $4$：$h(0,0) \\to 0+4=4$。\n- 角格点 $(\\pm 1, \\pm 1)$：每个角格点是两个坍塌的边格点的邻居。例如，格点 $(-1,-1)$ 是 $(-1,0)$ 和 $(0,-1)$ 的邻居。因此，每个角格点的高度增加 $2$：$h \\to 3+2=5$。\n得到的构型 $H_2$ 是：\n$$ H_2 = \\begin{pmatrix} 5  0  5 \\\\ 0  4  0 \\\\ 5  0  5 \\end{pmatrix} $$\n这一轮的坍塌次数是 $4$。总坍塌次数现在是 $1+4=5$。\n\n**第3步：最后一轮坍塌**\n构型 $H_2$ 有五个不稳定的格点：四个高度为 $5$ 的角格点和高度为 $4$ 的中心格点。我们接着坍塌这些格点。\n1.  首先，我们坍塌中心格点 $(0,0)$，其高度 $h(0,0)=4$。\n    - 其高度变为 $h(0,0) \\to 4-4=0$。\n    - 它的四个邻居，即边格点，当前高度为 $0$。它们的高度增加 $1$：$h \\to 0+1=1$。\n    这是总共第 $6$ 次坍塌。构型变为：\n    $$ H_{2a} = \\begin{pmatrix} 5  1  5 \\\\ 1  0  1 \\\\ 5  1  5 \\end{pmatrix} $$\n2.  现在，四个角格点 $(\\pm 1, \\pm 1)$ 是不稳定的，高度为 $5$。我们坍塌这四个格点。\n    - 它们的高度减少 $4$：$h \\to 5-4=1$。\n    - 每个角格点在网格上有两个邻居。例如，坍塌 $(-1,-1)$ 会给 $(-1,0)$ 和 $(0,-1)$ 各增加一粒沙。\n    - 让我们看一下对一个边格点的影响，比如 $(-1,0)$。它当前的高度是 $1$。它从 $(-1,-1)$ 和 $(-1,1)$ 的坍塌中各接收一粒沙。其高度变为 $h(-1,0) \\to 1+1+1=3$。\n    - 根据对称性，所有四个边格点的高度都将从 $1$ 变为 $3$。\n这一轮涉及另外 $4$ 次坍塌，每个角格点一次。最终的稳定构型 $H_f$ 是：\n$$ H_f = \\begin{pmatrix} 1  3  1 \\\\ 3  0  3 \\\\ 1  3  1 \\end{pmatrix} $$\n现在所有高度都小于 $4$，因此该构型是稳定的。\n\n**坍塌总结**\n为了求得总坍塌次数，我们将每个阶段的坍塌次数相加：\n- 第1步：格点 $(0,0)$ 发生 $1$ 次坍塌。\n- 第2步：$4$ 次坍塌，四个边格点各发生一次。\n- 第3步：格点 $(0,0)$ 发生 $1$ 次坍塌，四个角格点各发生 $1$ 次坍塌。总共是 $5$ 次坍塌。\n\n总坍塌次数 = $1 + 4 + 5 = 10$。\n\n所有格点 $(i,j)$ 的最终稳定高度为：\n- $h(0,0) = 0$\n- $h(\\pm 1, 0) = h(0, \\pm 1) = 3$\n- $h(\\pm 1, \\pm 1) = 1$\n\n在稳定化过程中发生的总坍塌次数为 $10$。",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "在沙堆模型的状态空间中，并非所有稳定构型都具有相同的地位；有些是瞬态的，而另一些则属于一个核心的“递归”状态集。本练习将介绍 Dhar 的燃烧算法，这是一个强大的工具，用于判断一个构型是否属于这个递归集。通过应用该算法，你将更深入地洞察模型状态空间的结构。",
            "id": "4142584",
            "problem": "考虑一个$2 \\times 2$方形格点上的阿贝尔沙堆模型，该模型具有最近邻连接，并在右上角顶点处有一个指定的汇点。用坐标$(i,j)$标记顶点，其中$i,j \\in \\{1,2\\}$，并将汇点指定为$(2,2)$。非汇点顶点为$(1,1)$、$(1,2)$和$(2,1)$。最近邻之间存在边：$(1,1)$与$(1,2)$和$(2,1)$相邻；$(1,2)$与$(1,1)$和汇点$(2,2)$相邻；$(2,1)$与$(1,1)$和汇点$(2,2)$相邻。每个非汇点顶点的度（计算到汇点的边）为$2$，因此一个稳定构型在每个非汇点顶点处的高度$h(i,j) \\in \\{0,1\\}$。\n\n考虑一个特定的稳定构型，其高度为$h(1,1)=1$，$h(1,2)=1$和$h(2,1)=0$。应用Dhar燃烧算法来检验常返性：首先燃烧汇点；然后在随后的每一轮中，燃烧每个满足$h(v) \\geq d_{U}(v)$的未燃烧顶点$v$，其中$d_{U}(v)$表示从$v$到当前未燃烧顶点的边数。持续此过程，直到没有更多的顶点可以被燃烧。\n\n判断该构型是常返的（所有非汇点顶点最终都燃烧）还是暂态的（至少有一个非汇点顶点在终止时仍未燃烧）。报告指示值$I$，如果构型是常返的，则$I=1$，如果是暂态的，则$I=0$。最终答案必须是单个数字$I$。无需四舍五入。",
            "solution": "题目要求我们应用Dhar燃烧算法来判断一个给定的阿贝尔沙堆模型的稳定构型是常返的还是暂态的。结果用指示值$I$表示，常返构型$I=1$，暂态构型$I=0$。\n\n首先，我们确定所描述系统的组成部分。\n顶点集合为 $V = \\{(1,1), (1,2), (2,1), (2,2)\\}$。\n非汇点顶点为 $V_{ns} = \\{(1,1), (1,2), (2,1)\\}$。\n指定的汇点是顶点 $s = (2,2)$。\n连接关系如下：\n- 顶点$(1,1)$与$(1,2)$和$(2,1)$相连。\n- 顶点$(1,2)$与$(1,1)$和汇点$(2,2)$相连。\n- 顶点$(2,1)$与$(1,1)$和汇点$(2,2)$相连。\n每个非汇点顶点$v$的度$d(v)$为$2$。\n初始高度构型如下：\n- $h(1,1) = 1$\n- $h(1,2) = 1$\n- $h(2,1) = 0$\n\nDhar燃烧算法是一个用于检验常返性的迭代过程。设$U$为未燃烧的非汇点顶点集合，$B$为已燃烧的顶点集合。算法按以下步骤进行：\n1. 通过燃烧汇点来初始化过程。因此，在第$t=0$轮，$B_0 = \\{s\\}$ 且 $U_0 = V_{ns}$。\n2. 在随后的每一轮$t0$中，如果一个顶点$v \\in U_{t-1}$的高度$h(v)$大于或等于其未燃烧邻居的数量$d_{U_{t-1}}(v)$，则该顶点被燃烧。\n3. 当某一轮中没有更多顶点可以被燃烧时，过程终止。\n4. 如果最终的未燃烧顶点集合为空（$U_{final} = \\emptyset$），则该构型是常返的。否则，它是暂态的。\n\n我们现在将此算法应用于给定的构型。\n\n**第0轮（初始化）：**\n汇点$s=(2,2)$被初始燃烧。\n已燃烧顶点的集合为 $B_0 = \\{(2,2)\\}$。\n未燃烧顶点的集合为 $U_0 = \\{(1,1), (1,2), (2,1)\\}$。\n\n**第1轮：**\n我们对每个顶点$v \\in U_0$检查燃烧条件$h(v) \\geq d_{U_0}(v)$。$d_{U_0}(v)$是$v$在$U_0$中的邻居数量。\n\n- 对于$v = (1,1)$：高度为$h(1,1) = 1$。其邻居为$(1,2)$和$(2,1)$。两者都在$U_0$中。因此，$d_{U_0}(1,1) = 2$。条件是$1 \\geq 2$，为假。顶点$(1,1)$不燃烧。\n\n- 对于$v = (1,2)$：高度为$h(1,2) = 1$。其邻居为$(1,1)$和$(2,2)$。邻居$(1,1)$在$U_0$中，但$(2,2)$在$B_0$中。因此，$d_{U_0}(1,2) = 1$。条件是$1 \\geq 1$，为真。顶点$(1,2)$燃烧。\n\n- 对于$v = (2,1)$：高度为$h(2,1) = 0$。其邻居为$(1,1)$和$(2,2)$。邻居$(1,1)$在$U_0$中，但$(2,2)$在$B_0$中。因此，$d_{U_0}(2,1) = 1$。条件是$0 \\geq 1$，为假。顶点$(2,1)$不燃烧。\n\n在第1轮结束时，只有顶点$(1,2)$被新燃烧。\n新的未燃烧顶点集合是$U_1 = U_0 \\setminus \\{(1,2)\\} = \\{(1,1), (2,1)\\}$。\n新的已燃烧顶点集合是$B_1 = B_0 \\cup \\{(1,2)\\} = \\{(2,2), (1,2)\\}$。\n\n**第2轮：**\n我们对每个剩余的未燃烧顶点$v \\in U_1$检查燃烧条件$h(v) \\geq d_{U_1}(v)$。\n\n- 对于$v = (1,1)$：高度为$h(1,1) = 1$。其邻居为$(1,2)$和$(2,1)$。邻居$(1,2)$现在在$B_1$中，而$(2,1)$在$U_1$中。因此，$d_{U_1}(1,1) = 1$。条件是$1 \\geq 1$，为真。顶点$(1,1)$燃烧。\n\n- 对于$v = (2,1)$：高度为$h(2,1) = 0$。其邻居为$(1,1)$和$(2,2)$。邻居$(1,1)$当前在$U_1$中，而$(2,2)$在$B_1$中。因此，$d_{U_1}(2,1) = 1$。条件是$0 \\geq 1$，为假。顶点$(2,1)$不燃烧。\n\n在第2轮结束时，顶点$(1,1)$被新燃烧。\n新的未燃烧顶点集合是$U_2 = U_1 \\setminus \\{(1,1)\\} = \\{(2,1)\\}$。\n新的已燃烧顶点集合是$B_2 = B_1 \\cup \\{(1,1)\\} = \\{(2,2), (1,2), (1,1)\\}$。\n\n**第3轮：**\n我们对唯一剩下的未燃烧顶点$v = (2,1) \\in U_2$检查燃烧条件。\n\n- 对于$v = (2,1)$：高度为$h(2,1) = 0$。其邻居为$(1,1)$和$(2,2)$。两个邻居现在都在$B_2$中。因此，它在$U_2$中没有邻居，所以$d_{U_2}(2,1) = 0$。条件是$0 \\geq 0$，为真。顶点$(2,1)$燃烧。\n\n在第3轮结束时，顶点$(2,1)$被新燃烧。\n新的未燃烧顶点集合是$U_3 = U_2 \\setminus \\{(2,1)\\} = \\emptyset$。\n最终的已燃烧顶点集合是$B_3 = B_2 \\cup \\{(2,1)\\} = \\{(2,2), (1,2), (1,1), (2,1)\\}$，它包括了所有非汇点顶点。\n\n**结论：**\n算法终止，因为未燃烧顶点的集合为空。由于所有非汇点顶点——$(1,1)$、$(1,2)$和$(2,1)$——最终都被燃烧，初始构型被定义为常返的。\n\n根据题目说明，对于常返构型，指示值$I$为$1$。因此，$I=1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "沙堆模型的“阿贝尔”性质是其最引人注目和最基本的特性之一，它保证了最终的稳定状态与坍塌事件的发生顺序无关。这个编程练习要求你从头开始实现该模型，并通过经验验证这一性质。通过证明不同的弛豫方案（顺序与并行）能得到完全相同的结果，你将巩固对这一核心原理的理解。",
            "id": "4142585",
            "problem": "考虑一个具有开放边界条件的有限方格上的 Bak–Tang–Wiesenfeld (BTW) 阿贝尔沙堆模型。设晶格大小为 $L \\times L$，由数对 $(i,j)$ 索引，其中 $i \\in \\{0, \\ldots, L-1\\}$ 且 $j \\in \\{0, \\ldots, L-1\\}$。一个位形是一个非负整数数组 $z \\in \\mathbb{Z}_{\\ge 0}^{L \\times L}$，其中 $z_{i,j}$ 表示格点 $(i,j)$ 上的沙粒数。如果 $z_{i,j} \\ge 4$，则格点 $(i,j)$ 是不稳定的。在格点 $(i,j)$ 上的坍塌操作 $T_{i,j}$ 将位形 $z$ 变换为一个新位形 $z'$，其规则为 $z'_{i,j} = z_{i,j} - 4$，并且对于位于晶格内的四个最近邻 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$，它们的高度各增加 $1$（发送到晶格外邻居的沙粒会流失）。如果对所有 $(i,j)$ 都有 $z_{i,j}  4$，则位形是稳定的。\n\n定义两种弛豫过程，它们重复应用坍塌操作，直到达到稳定位形：\n- 并行弛豫：在每个离散时间步 $t$，同时使每个不稳定格点坍塌恰好一次，即在该步骤中对所有满足 $z_{i,j} \\ge 4$ 的 $(i,j)$ 应用 $T_{i,j}$，然后重复此过程直到稳定。\n- 顺序弛豫：在每一步中，选择字典序最前的不稳定格点（在所有满足 $z_{i,j} \\ge 4$ 的格点中，字典序最小的 $(i,j)$），仅在该格点上应用 $T_{i,j}$，然后重复此过程直到稳定。\n\n从 BTW 模型的基本定义出发，实现这两种弛豫过程，并在一个小的初始位形测试套件上经验性地验证，由并行弛豫和顺序弛豫产生的最终稳定位形是相同的。使用开放边界条件（将被发送到晶格外邻居的沙粒会流失），并在每个格点上使用阈值 $4$（即当 $z_{i,j} \\ge 4$ 时，格点会坍塌）。\n\n您必须硬编码以下初始位形测试套件，并用两种弛豫过程处理每种情况：\n\n- 情况 $1$ ($L = 3$): \n$$\nZ^{(1)} = \\begin{bmatrix}\n0  0  0 \\\\\n0  10  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n\n- 情况 $2$ ($L = 4$):\n$$\nZ^{(2)} = \\begin{bmatrix}\n3  4  0  1 \\\\\n2  5  2  3 \\\\\n0  1  4  0 \\\\\n7  0  0  2\n\\end{bmatrix}\n$$\n\n- 情况 $3$ ($L = 1$):\n$$\nZ^{(3)} = \\begin{bmatrix}\n100\n\\end{bmatrix}\n$$\n\n- 情况 $4$ ($L = 2$):\n$$\nZ^{(4)} = \\begin{bmatrix}\n0  0 \\\\\n0  0\n\\end{bmatrix}\n$$\n\n- 情况 $5$ ($L = 5$):\n$$\nZ^{(5)} = \\begin{bmatrix}\n0  4  0  4  0 \\\\\n4  3  3  3  4 \\\\\n0  3  12  3  0 \\\\\n4  3  3  3  4 \\\\\n0  4  0  4  0\n\\end{bmatrix}\n$$\n\n对于每种情况，计算由并行弛豫产生的最终稳定位形和由顺序弛豫产生的最终稳定位形。比较它们是否完全相等。要求的输出是布尔值，对于每种情况 $k \\in \\{1,2,3,4,5\\}$，指示两个最终位形是否相同。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按情况 1 到 5 的顺序排列，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是 $True$ 或 $False$。不涉及物理单位或角度单位；所有结果都是无量纲的。不需要百分比。",
            "solution": "该问题要求对 Bak–Tang–Wiesenfeld (BTW) 阿贝尔沙堆模型的一个基本性质进行经验性验证。具体来说，我们必须实现两种不同的弛豫过程——一种并行，一种顺序——并确认它们从相同的初始状态产生相同的最终稳定位形。\n\n首先，我们按照描述将模型形式化。系统定义在一个大小为 $L \\times L$ 的方格上，格点由 $(i,j)$ 索引，其中 $i, j \\in \\{0, 1, \\ldots, L-1\\}$。每个格点 $(i,j)$ 拥有非负整数个“沙粒”，记为 $z_{i,j}$。整个系统的位形是矩阵 $Z = \\{z_{i,j}\\}$。\n\n如果一个格点 $(i,j)$ 的高度达到或超过一个临界阈值 $z_{i,j} \\ge z_c$，则该格点被定义为不稳定。对于本问题，所有格点的阈值均为 $z_c = 4$。当一个格点不稳定时，它可以“坍塌”。在格点 $(i,j)$ 上的坍塌操作 $T_{i,j}$ 根据以下规则重新分配其沙粒：\n$$\nz_{i,j} \\rightarrow z_{i,j} - 4\n$$\n$$\nz_{k,l} \\rightarrow z_{k,l} + 1 \\quad \\text{for each nearest neighbor } (k,l) \\text{ of } (i,j)\n$$\n该模型使用开放边界条件，意味着如果晶格边缘的一个格点坍塌，任何将被发送到晶格外不存在的邻居的沙粒都会从系统中流失。如果所有格点都是稳定的，即对所有 $(i,j)$ 都有 $z_{i,j}  4$，则位形是稳定的。\n\n该模型的一个关键定理是其阿贝尔性质。这意味着对于任何初始位形，在所有必要的坍塌事件发生后达到的最终稳定位形是唯一的，并且不依赖于坍塌操作的执行顺序。循环位形的集合构成一个阿贝尔群，模型因此得名。该问题要求我们通过比较两种特定的坍塌序列来验证这一性质：\n\n1.  **顺序弛豫：** 在此过程中，我们重复地按字典序找到第一个不稳定的格点（即通过先行后列扫描），并只让该格点坍塌。重复此过程直到没有不稳定的格点。算法如下：\n    - 步骤 1：用给定的位形 $Z$ 初始化系统。\n    - 步骤 2：扫描晶格以找到所有不稳定格点的集合，其中 $z_{i,j} \\ge 4$。\n    - 步骤 3：如果此集合为空，则位形是稳定的，过程终止。\n    - 步骤 4：如果集合不为空，选择字典序最前的格点 $(i,j)$。\n    - 步骤 5：对位形 $Z$ 应用坍塌操作 $T_{i,j}$。\n    - 步骤 6：返回步骤 2。\n\n2.  **并行弛豫：** 在此过程中，所有不稳定的格点在离散时间步中同时坍塌。这意味着在时间 $t+1$ 的网格状态是由基于时间 $t$ 状态发生的所有坍塌决定的。算法如下：\n    - 步骤 1：用给定的位形 $Z(t=0)$ 初始化系统。\n    - 步骤 2：在每个时间步 $t$，识别所有不稳定格点 $(i,j)$ 的集合 $U_t$，其中 $z_{i,j}(t) \\ge 4$。\n    - 步骤 3：如果 $U_t$ 为空，系统是稳定的，过程终止。\n    - 步骤 4：计算网格位形的变化量 $\\Delta Z(t)$。每个格点 $(i,j) \\in U_t$ 失去 $4$ 个沙粒。每个格点 $(i,j)$ 从其属于 $U_t$ 的每个邻居 $(k,l)$ 处获得一个沙粒。\n    - 步骤 5：新位形是 $Z(t+1) = Z(t) + \\Delta Z(t)$。\n    - 步骤 6：将 $t$ 递增并返回步骤 2。\n\n并行弛豫的实现可以使用向量操作进行优化。更新规则可以表示为：\n$$\nz_{i,j}(t+1) = z_{i,j}(t) - 4 \\cdot \\mathbb{I}((i,j) \\in U_t) + \\sum_{(k,l) \\in N(i,j)} \\mathbb{I}((k,l) \\in U_t)\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，$N(i,j)$ 是 $(i,j)$ 的最近邻集合。求和项是一个离散卷积。如果我们定义一个矩阵 $S_t$，其中当 $(i,j) \\in U_t$ 时 $S_{t, i,j} = 1$，否则为 $0$，则更新可以使用卷积核 $K$ 写成：\n$$\nZ(t+1) = Z(t) - 4 S_t + (S_t * K) \\quad \\text{where} \\quad K = \\begin{pmatrix} 0  1  0 \\\\ 1  0  1 \\\\ 0  1  0 \\end{pmatrix}\n$$\n卷积必须处理开放边界条件，这对应于补零操作。\n\n解决方案将包括实现这两种算法，将它们应用于五个提供的测试用例，并比较最终的稳定矩阵是否相等。基于 BTW 模型的阿贝尔性质，预期在所有测试用例中，两种方法得到的最终位形都将是相同的。输出将是一个布尔值列表，表示每个用例的比较结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef parallel_relaxation(grid: np.ndarray) - np.ndarray:\n    \"\"\"\n    Relaxes a sandpile configuration using parallel updates.\n    In each step, all unstable sites topple simultaneously.\n    \"\"\"\n    # Make a copy to avoid modifying the original array from the test suite\n    grid = grid.copy()\n    L = grid.shape[0]\n    \n    # Kernel for convolution to distribute grains to neighbors\n    kernel = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]], dtype=np.int32)\n    threshold = 4\n\n    while np.any(grid = threshold):\n        # Identify sites that will topple in this step\n        # A site topples once if its height is = threshold\n        unstable_sites = (grid = threshold).astype(np.int32)\n        \n        # Grains lost from each site due to toppling\n        grains_out = threshold * unstable_sites\n        \n        # Grains received by each site from its toppling neighbors\n        # The convolution calculates this sum for all sites at once.\n        # 'fill' boundary condition with fillvalue=0 handles open boundaries.\n        grains_in = signal.convolve2d(unstable_sites, kernel, mode='same', boundary='fill', fillvalue=0)\n        \n        # Apply the net change to the grid\n        grid = grid - grains_out + grains_in\n        \n    return grid\n\ndef sequential_relaxation(grid: np.ndarray) - np.ndarray:\n    \"\"\"\n    Relaxes a sandpile configuration using sequential updates.\n    In each step, the lexicographically first unstable site topples.\n    \"\"\"\n    # Make a copy to avoid modifying the original array from the test suite\n    grid = grid.copy()\n    L = grid.shape[0]\n    threshold = 4\n\n    while True:\n        # np.argwhere finds indices of non-zero elements, which are True for unstable sites.\n        # The result is already in lexicographical (row-major) order.\n        unstable_indices = np.argwhere(grid = threshold)\n        \n        if unstable_indices.shape[0] == 0:\n            # No unstable sites, the configuration is stable\n            break\n        \n        # Get the lexicographically first unstable site\n        i, j = unstable_indices[0]\n        \n        # Perform the toppling operation\n        grid[i, j] -= threshold\n        \n        # Distribute grains to neighbors, checking for boundaries\n        if i  0:\n            grid[i - 1, j] += 1\n        if i  L - 1:\n            grid[i + 1, j] += 1\n        if j  0:\n            grid[i, j - 1] += 1\n        if j  L - 1:\n            grid[i, j + 1] += 1\n            \n    return grid\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify the Abelian property.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0, 0, 0],\n                  [0, 10, 0],\n                  [0, 0, 0]], dtype=np.int32),\n        np.array([[3, 4, 0, 1],\n                  [2, 5, 2, 3],\n                  [0, 1, 4, 0],\n                  [7, 0, 0, 2]], dtype=np.int32),\n        np.array([[100]], dtype=np.int32),\n        np.array([[0, 0],\n                  [0, 0]], dtype=np.int32),\n        np.array([[0, 4, 0, 4, 0],\n                  [4, 3, 3, 3, 4],\n                  [0, 3, 12, 3, 0],\n                  [4, 3, 3, 3, 4],\n                  [0, 4, 0, 4, 0]], dtype=np.int32),\n    ]\n\n    results = []\n    for initial_config in test_cases:\n        # Run parallel relaxation\n        stable_config_parallel = parallel_relaxation(initial_config)\n        \n        # Run sequential relaxation\n        stable_config_sequential = sequential_relaxation(initial_config)\n        \n        # Compare the final stable configurations for equality\n        are_identical = np.array_equal(stable_config_parallel, stable_config_sequential)\n        results.append(are_identical)\n\n    # Format and print the final results as specified.\n    # The expected output is [True,True,True,True,True] due to the Abelian property.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}