{
    "hands_on_practices": [
        {
            "introduction": "We begin with a fundamental analytical exercise to solidify the core concepts of stability and basins of attraction. By analyzing a simple one-dimensional cubic map, you will derive the conditions for bistability—the coexistence of two stable attractors—and precisely calculate the size of their respective basins of attraction. This practice sharpens the essential skills of finding fixed points, assessing their stability via linearization, and understanding how these local properties define the global organization of the state space .",
            "id": "4144213",
            "problem": "Consider the one-dimensional discrete-time cubic map on the real line, defined by $x_{n+1} = f(x_n)$ with $f(x) = r x - x^{3}$ and parameter $r > 0$. Work within the standard state-space framework in complex adaptive systems modeling, where fixed points, their linear stability, and basins of attraction are defined as follows: a fixed point $x^{*}$ satisfies $f(x^{*}) = x^{*}$; linear stability of $x^{*}$ is determined by the magnitude of the derivative $|f'(x^{*})|$; and a basin of attraction of an attractor is the set of initial conditions whose forward trajectories converge to that attractor. \n\nTasks:\n- Derive all fixed points $x^{*}$ of the map as functions of $r$ using the fixed-point equation $f(x^{*}) = x^{*}$.\n- Using the definition of linear stability for discrete-time maps (i.e., stability is characterized by $|f'(x^{*})|  1$ and instability by $|f'(x^{*})| > 1$), determine for which values of $r$ each fixed point is linearly stable.\n- For the parameter range where two stable equilibria coexist, restrict attention to the forward-invariant interval $I_{r} = [-\\sqrt{r}, \\sqrt{r}]$ in the state space. Prove that $I_{r}$ is forward invariant under the map for the relevant parameter range, and use this to determine the Lebesgue measure (length) of the basin of attraction within $I_{r}$ for each of the two coexisting stable fixed points. Justify that the sign of $x_{n}$ is preserved inside $I_{r}$ and use this to characterize the basins.\n- Finally, express the Lebesgue measure (length) of the basin of attraction of the positive stable fixed point $x^{*}_{+}$ within $I_{r}$ as an explicit function of $r$. Express your final answer as a single closed-form analytic expression with no units.\n\nYou must provide complete derivations from the core definitions above. No shortcuts or external formulas are permitted. The final answer must be a single expression.",
            "solution": "The solution follows a step-by-step derivation based on the provided definitions.\n\n**1. Derivation of Fixed Points**\n\nA fixed point $x^*$ satisfies the equation $f(x^*) = x^*$.\n$$r x^* - (x^*)^3 = x^*$$\n$$x^*(r - 1 - (x^*)^2) = 0$$\nThis equation yields three solutions for the fixed points:\n*   $x_0^* = 0$\n*   $(x^*)^2 = r-1 \\implies x_{\\pm}^* = \\pm\\sqrt{r-1}$. These two fixed points are real and distinct from $x_0^*$ only if $r-1 > 0$, i.e., for $r > 1$.\n\n**2. Stability Analysis**\n\nLinear stability is determined by the condition $|f'(x^*)|  1$, where the derivative of the map is $f'(x) = r - 3x^2$.\n\n*   **Stability of $x_0^* = 0$:**\n    $f'(0) = r - 3(0)^2 = r$.\n    Stability requires $|r|  1$. Since the problem specifies $r > 0$, the fixed point at the origin is stable for $0  r  1$. It is unstable for $r > 1$.\n\n*   **Stability of $x_{\\pm}^* = \\pm\\sqrt{r-1}$ (for $r > 1$):**\n    $f'(x_{\\pm}^*) = r - 3(\\pm\\sqrt{r-1})^2 = r - 3(r-1) = r - 3r + 3 = 3 - 2r$.\n    Stability requires $|3 - 2r|  1$, which means:\n    $$-1  3 - 2r  1$$\n    This inequality can be split into two parts:\n    1.  $3 - 2r  1 \\implies 2  2r \\implies r > 1$.\n    2.  $-1  3 - 2r \\implies 2r  4 \\implies r  2$.\n    Combining these, the fixed points $x_{\\pm}^*$ are stable for the parameter range $1  r  2$.\n\n**3. Basin of Attraction for Coexisting Stable Equilibria**\n\nThe problem states that two stable equilibria coexist, which, from our analysis, occurs for $1  r  2$. In this range, the system has two stable fixed points, $x_{+}^* = \\sqrt{r-1}$ and $x_{-}^* = -\\sqrt{r-1}$, and one unstable fixed point, $x_0^* = 0$. The unstable fixed point at the origin acts as the separatrix between the two basins of attraction.\n\nWe are asked to analyze the dynamics within the forward-invariant interval $I_r = [-\\sqrt{r}, \\sqrt{r}]$.\n\n*   **Forward Invariance:** For $x \\in [-\\sqrt{r}, \\sqrt{r}]$, we need to show that $f(x)$ also lies in this interval. The function $f(x) = x(r-x^2)$ has its extrema where $f'(x) = 0$, i.e., at $x = \\pm\\sqrt{r/3}$. The maximum absolute value of the function on the interval occurs at these extrema, $|f(\\pm\\sqrt{r/3})| = \\frac{2r}{3}\\sqrt{\\frac{r}{3}}$. For $I_r$ to be forward-invariant, this value must be less than or equal to $\\sqrt{r}$. This condition, $\\frac{2r\\sqrt{r}}{3\\sqrt{3}} \\le \\sqrt{r}$, simplifies to $r \\le \\frac{3\\sqrt{3}}{2} \\approx 2.598$. Since we are in the range $1  r  2$, this condition holds, and the interval $I_r$ is indeed forward-invariant.\n\n*   **Sign Preservation:** For any $x \\in (-\\sqrt{r}, \\sqrt{r})$, the term $(r - x^2)$ is positive. Thus, the sign of $f(x) = x(r-x^2)$ is the same as the sign of $x$. This means that any positive initial condition in this interval will generate a sequence of positive iterates, and any negative initial condition will generate a sequence of negative iterates.\n\n*   **Basin Characterization:** Since the sign of the trajectory is preserved, any initial condition $x_0 \\in (0, \\sqrt{r}]$ must have a trajectory that remains positive. The only positive attractor in the system is the stable fixed point $x_+^*$. Therefore, the basin of attraction for $x_+^*$ within the interval $I_r$ is $(0, \\sqrt{r}]$. Similarly, the basin for $x_-^*$ is $[-\\sqrt{r}, 0)$. The point $x=0$ is the unstable fixed point that separates them.\n\n**4. Lebesgue Measure of the Basin**\n\nThe task is to find the Lebesgue measure (length) of the basin of attraction of the positive stable fixed point $x_+^*$ within $I_r$. As determined above, this basin is the interval $(0, \\sqrt{r}]$. The length of this interval is:\n$$\\text{Length} = \\sqrt{r} - 0 = \\sqrt{r}$$",
            "answer": "$$\n\\boxed{\\sqrt{r}}\n$$"
        },
        {
            "introduction": "While analytical solutions are invaluable, most complex systems do not permit them. This practice transitions from analytical methods to computational exploration by asking you to estimate the basin of attraction volumes for a two-dimensional system with multiple equilibria. You will implement a grid-sampling Monte Carlo procedure to numerically map the state space and apply statistical methods to quantify the uncertainty in your estimates, a vital skill for any computational modeling endeavor .",
            "id": "4144169",
            "problem": "Consider a deterministic continuous-time dynamical system on the state space $\\mathbb{R}^{2}$ defined by the ordinary differential equation (ODE)\n$$\n\\frac{d}{dt}\\begin{pmatrix}x(t)\\\\y(t)\\end{pmatrix} = \\begin{pmatrix}f_{x}(x(t))\\\\f_{y}(y(t))\\end{pmatrix}, \\quad \\text{with} \\quad f_{x}(x) = -4\\,x\\,(x^{2}-1), \\quad f_{y}(y) = -4\\,y\\,(y^{2}-1).\n$$\nThis system is a gradient flow for the potential function $V(x,y)=(x^{2}-1)^{2}+(y^{2}-1)^{2}$, and it exhibits multiple stable equilibria (attractors) at the points $(-1,-1)$, $(-1,+1)$, $(+1,-1)$, $(+1,+1)$. The basin of attraction for an attractor is the set of initial conditions in $\\mathbb{R}^{2}$ that asymptotically approach that attractor under the flow. Given a bounded rectangular domain $\\Omega=[x_{\\min},x_{\\max}]\\times[y_{\\min},y_{\\max}]$, define the basin volume fraction for attractor $a_{j}$ as the Lebesgue measure of the portion of $\\Omega$ belonging to the basin of $a_{j}$ divided by the Lebesgue measure of $\\Omega$.\n\nYour task is to design and implement a grid-sampling Monte Carlo procedure to estimate the basin volume fractions for the four attractors of the above ODE over specified domains, and to derive confidence intervals for the estimates given a fixed number of samples. Use the following principles and constraints:\n\n- Fundamental base: Use the core definitions of state space, attractors, basins of attraction, and the law of large numbers for unbiased estimation. Treat the sampling inside each grid cell as uniform. For confidence intervals, use binomial proportion inference for each attractor’s fraction, adopting the Wilson score interval at confidence level $1-\\alpha$.\n- Grid-sampling Monte Carlo design: Partition $\\Omega$ into a $G\\times G$ grid of equal-area cells. Draw exactly one initial condition uniformly at random from each cell, using a pseudorandom number generator with a fixed seed to ensure reproducibility. With $G$ fixed, the total number of samples is $N=G^{2}$.\n- Trajectory classification: For each sampled initial condition $(x_{0},y_{0})$, numerically integrate the ODE from $t=0$ to a finite terminal time $T0$. Classification is performed by assigning the terminal state $(x(T),y(T))$ to the nearest attractor in Euclidean distance. You may terminate integration early if the trajectory enters a small neighborhood of radius $\\varepsilon$ around any attractor. Use a solver with reasonable tolerances, and ensure scientific realism by avoiding arbitrary shortcuts that bypass integration.\n- Estimation and confidence intervals: Let $n_{j}$ be the number of samples classified to attractor $a_{j}$, so that the estimator $\\hat{p}_{j}=n_{j}/N$ is the grid-sampling Monte Carlo estimate of the basin volume fraction for $a_{j}$. Derive and implement the Wilson score interval $[\\ell_{j},u_{j}]$ for each $\\hat{p}_{j}$ at confidence level $1-\\alpha$. Use the standard normal quantile $z_{1-\\alpha/2}$.\n- Final output format: For each test case, output a list of four sublists corresponding to the attractors in the fixed order $[(-1,-1),(-1,+1),(+1,-1),(+1,+1)]$. Each sublist must contain three floats $[\\hat{p}_{j},\\ell_{j},u_{j}]$. Aggregate the results of all provided test cases into a single line as a comma-separated list enclosed in square brackets, for example, $[[\\cdots],[\\cdots],[\\cdots]]$.\n\nImplement the program to solve the following test suite. Each test case is a tuple $(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)$ with fixed pseudorandom seed $s=1729$:\n\n- Test Case 1 (happy path): $(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)=(-1.5,0.7,-0.9,1.1,20,5.0,10^{-3},0.05)$. This tests non-symmetric domains crossing separatrices.\n- Test Case 2 (small-$N$ edge case): $(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)=(-1.2,1.2,-1.2,1.2,5,4.0,10^{-3},0.05)$. This tests small sample sizes and wider intervals.\n- Test Case 3 (dominating basin): $(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)=(0.1,1.5,0.2,1.1,10,3.0,10^{-3},0.05)$. This tests near-degenerate multinomial outcomes where one basin is overwhelmingly likely.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[\\hat{p}_{1},\\ell_{1},u_{1},\\ldots],[\\cdots],\\ldots]$ but strictly following the structure of four $[\\hat{p}_{j},\\ell_{j},u_{j}]$ sublists per test case in the specified attractor order and with no other text). All numeric outputs must be floats. No physical units or angles are involved; express all fractions and bounds as decimal floats.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the theory of dynamical systems, providing a well-defined ordinary differential equation (ODE) corresponding to a gradient flow. All parameters for the numerical procedure are specified, ensuring the problem is well-posed and self-contained. The task is to implement a specific, standard computational method (grid-sampling Monte Carlo) to estimate physically meaningful quantities (basin of attraction volume fractions) and to provide statistical confidence intervals (Wilson score intervals), which is a concrete and objective task. The problem does not violate any of the invalidity criteria.\n\nThe core of the problem is to determine which attractor a given initial condition $(x_0, y_0)$ will flow to under the dynamics defined by the ODE system:\n$$\n\\frac{dx}{dt} = -4x(x^2-1)\n$$\n$$\n\\frac{dy}{dt} = -4y(y^2-1)\n$$\nThe system has four stable fixed points (attractors) at $a_1=(-1,-1)$, $a_2=(-1,+1)$, $a_3=(+1,-1)$, and $a_4=(+1,+1)$. The basin of attraction for each $a_j$ is the set of all initial conditions whose trajectories converge to $a_j$ as $t \\to \\infty$. The basin boundaries are the stable manifolds of the saddle points, which in this decoupled system are the lines $x=0$ and $y=0$.\n\nThe solution will be implemented as a Python program structured as follows:\n\n1.  **Main Loop**: A primary function, `solve()`, will iterate through the provided test cases. For each test case, it will orchestrate the simulation and calculations.\n\n2.  **Simulation per Case**: For each set of parameters $(x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}, G, T, \\varepsilon, \\alpha)$, a dedicated function will perform the grid-sampling Monte Carlo estimation.\n    *   **Reproducibility**: A pseudorandom number generator will be initialized with the specified fixed seed, $s=1729$, for each test case to ensure that the results are deterministic and reproducible.\n    *   **Grid and Sampling**: The domain $\\Omega=[x_{\\min}, x_{\\max}]\\times[y_{\\min}, y_{\\max}]$ is partitioned into a $G \\times G$ grid. The total number of samples will be $N=G^2$. For each of the $N$ cells, one initial condition $(x_0, y_0)$ is drawn from a uniform distribution over that cell.\n    *   **Numerical Integration**: For each initial condition, the trajectory is computed by numerically integrating the ODE system using `scipy.integrate.solve_ivp`. The integration runs from $t=0$ up to a maximum time $T$.\n    *   **Early Termination**: Integration is terminated early if the trajectory enters an $\\varepsilon$-neighborhood of any of the four attractors. This is implemented using the `events` feature of `solve_ivp`. An event function is defined that detects when the Euclidean distance to the nearest attractor falls below $\\varepsilon$.\n    *   **Basin Classification**: After integration (either to time $T$ or until an event is triggered), the final state of the trajectory is classified. It is assigned to the basin of the attractor to which it is closest in Euclidean distance. A counter for this attractor, $n_j$, is incremented.\n\n3.  **Estimation and Confidence Intervals**: After all $N$ samples for a test case are processed, the basin volume fraction for each attractor $a_j$ is estimated as $\\hat{p}_j = n_j / N$.\n    *   A $1-\\alpha$ confidence interval for each proportion $p_j$ is calculated using the Wilson score interval formula. Let $z = z_{1-\\alpha/2}$ be the $(1-\\alpha/2)$-quantile of the standard normal distribution. The interval $[\\ell_j, u_j]$ is given by:\n        $$\n        [\\ell_j, u_j] = \\frac{1}{1 + z^2/N} \\left( \\hat{p}_j + \\frac{z^2}{2N} \\mp z \\sqrt{\\frac{\\hat{p}_j(1-\\hat{p}_j)}{N} + \\frac{z^2}{4N^2}} \\right)\n        $$\n    *   The required quantile $z$ is obtained using `scipy.stats.norm.ppf`.\n\n4.  **Output Formatting**: The results for each test case, consisting of four sublists of the form $[\\hat{p}_j, \\ell_j, u_j]$, are aggregated. The final output is a single string representing a list of the results from all test cases, formatted exactly as specified in the problem statement.\n\nThis step-by-step process faithfully implements the requirements, combining principles of dynamical systems, numerical methods, and statistical inference into a cohesive and correct program.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (xmin, xmax, ymin, ymax, G, T, epsilon, alpha)\n        (-1.5, 0.7, -0.9, 1.1, 20, 5.0, 1e-3, 0.05), # Test Case 1\n        (-1.2, 1.2, -1.2, 1.2, 5, 4.0, 1e-3, 0.05),  # Test Case 2\n        (0.1, 1.5, 0.2, 1.1, 10, 3.0, 1e-3, 0.05),   # Test Case 3\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result = run_simulation(*case_params)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list includes spaces, e.g., '[1.0, 2.0]'.\n    # The template `print(f\"[{','.join(map(str, results))}]\")` generates a string\n    # like '[[[...]],[[...]]]', which is a valid representation.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_simulation(x_min, x_max, y_min, y_max, G, T, epsilon, alpha):\n    \"\"\"\n    Performs the grid-sampling Monte Carlo simulation for a single test case.\n    \"\"\"\n    # Fixed parameters\n    seed = 1729\n    attractors = np.array([\n        [-1.0, -1.0],\n        [-1.0, 1.0],\n        [1.0, -1.0],\n        [1.0, 1.0]\n    ])\n\n    # Initialize PRNG for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Define the ODE system\n    def ode_system(t, y):\n        x, y_val = y\n        dxdt = -4.0 * x * (x**2 - 1.0)\n        dydt = -4.0 * y_val * (y_val**2 - 1.0)\n        return np.array([dxdt, dydt])\n\n    # Define the event for early termination\n    def convergence_event(t, y):\n        # Calculate distance to nearest attractor\n        min_dist = np.min([np.linalg.norm(y - a) for a in attractors])\n        return min_dist - epsilon\n    convergence_event.terminal = True\n\n    # Simulation setup\n    N = G * G\n    counts = np.zeros(len(attractors), dtype=int)\n    \n    dx_cell = (x_max - x_min) / G\n    dy_cell = (y_max - y_min) / G\n\n    # Iterate over the grid\n    for i in range(G):\n        for j in range(G):\n            # Define cell boundaries\n            cell_x_min = x_min + i * dx_cell\n            cell_x_max = x_min + (i + 1) * dx_cell\n            cell_y_min = y_min + j * dy_cell\n            cell_y_max = y_min + (j + 1) * dy_cell\n\n            # Sample one initial condition from the cell\n            x0 = rng.uniform(cell_x_min, cell_x_max)\n            y0 = rng.uniform(cell_y_min, cell_y_max)\n            \n            # Integrate the ODE\n            sol = solve_ivp(\n                fun=ode_system,\n                t_span=[0, T],\n                y0=[x0, y0],\n                events=convergence_event,\n                rtol=1e-6,\n                atol=1e-6\n            )\n            \n            # Get the final state\n            final_state = sol.y[:, -1]\n\n            # Classify the trajectory\n            distances = [np.linalg.norm(final_state - a) for a in attractors]\n            closest_attractor_idx = np.argmin(distances)\n            counts[closest_attractor_idx] += 1\n            \n    # Calculate fractions and confidence intervals\n    case_results = []\n    z = norm.ppf(1.0 - alpha / 2.0)\n    \n    for i in range(len(attractors)):\n        n = counts[i]\n        p_hat = n / N\n        \n        # Wilson score interval calculation\n        denominator = 1.0 + z**2 / N\n        center_shifted = p_hat + z**2 / (2.0 * N)\n        spread = z * np.sqrt((p_hat * (1.0 - p_hat)) / N + z**2 / (4.0 * N**2))\n        \n        l_j = (center_shifted - spread) / denominator\n        u_j = (center_shifted + spread) / denominator\n        \n        case_results.append([p_hat, l_j, u_j])\n        \n    return case_results\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "This final exercise addresses a more advanced and practical challenge: precisely locating the tipping points between different dynamical regimes in a classic model of excitability. You will work with the FitzHugh-Nagumo model, which can exhibit both stable fixed points and stable limit cycles as coexisting attractors. The task requires combining equilibrium analysis, numerical integration, and an algorithmic search to pinpoint the basin boundary, demonstrating how to dissect the state space of systems with rich dynamical behavior .",
            "id": "4144135",
            "problem": "Consider the two-dimensional FitzHugh–Nagumo model, a canonical reduction of excitable dynamics in complex adaptive systems, given by the autonomous Ordinary Differential Equation (ODE) system\n$$\n\\dot v = v - \\frac{v^3}{3} - w + I,\\quad \\dot w = \\epsilon\\,(v + a - b\\,w),\n$$\nwhere $v$ and $w$ denote the fast and slow state variables respectively, and $\\epsilon$, $a$, $b$, $I$ are real parameters. In the context of state space analysis for complex adaptive systems modeling, a state space is the set of all possible states $(v,w)$, an attractor is a set in state space towards which trajectories asymptotically evolve (for example, a stable fixed point or a stable limit cycle), and a basin of attraction is the set of initial conditions that asymptotically approach a particular attractor. The boundary between basins of attraction (the basin boundary) partitions the state space into regions converging to different attractors.\n\nStarting from the core definitions of a state space, attractors, and basins of attraction, and using only fundamental properties of continuous-time dynamical systems, design a numerical scheme to approximate the basin boundary between a stable fixed point and a stable limit cycle. Your scheme must be based on first principles, without presupposing any target formulas, and should use a logically sound method to distinguish long-time convergence to a fixed point from long-time convergence to a limit cycle.\n\nYou must implement a complete, runnable program that does the following for each parameter set in the test suite:\n\n1. Determine whether the system admits at least one stable fixed point by solving the equilibrium equations and analyzing local stability via the Jacobian. Specifically, an equilibrium $(v^\\ast, w^\\ast)$ satisfies\n$$\nv^\\ast - \\frac{(v^\\ast)^3}{3} - w^\\ast + I = 0,\\quad w^\\ast = \\frac{v^\\ast + a}{b},\n$$\nand its local stability is determined by the Jacobian matrix\n$$\nJ(v^\\ast,w^\\ast) = \\begin{pmatrix} 1 - (v^\\ast)^2  -1 \\\\ \\epsilon  -\\epsilon\\,b \\end{pmatrix}\n$$\nhaving eigenvalues with strictly negative real parts.\n\n2. If a stable fixed point exists, approximate the basin boundary along a ray that originates at $(v^\\ast, w^\\ast)$ with angle $\\theta$ measured in radians. Parameterize initial conditions on this ray as\n$$\n(v_0, w_0) = (v^\\ast, w^\\ast) + r\\,(\\cos\\theta, \\sin\\theta),\n$$\nwhere $r \\ge 0$ is the radial distance. Use a bracketing-and-bisection procedure over $r \\in [r_{\\min}, r_{\\max}]$ to search for a change in long-time attractor classification from a stable fixed point to a stable limit cycle (or vice versa). The classification must be made by integrating the ODE over a sufficiently long time horizon and applying principled criteria that distinguish fixed points from limit cycles.\n\n3. Output, for each test case, a single real number equal to the approximated critical radius $r_c$ at which the attractor classification changes along the ray, to within the specified tolerance. If your procedure cannot bracket and locate such a change for the given interval $[r_{\\min}, r_{\\max}]$ and time horizon, output the float $-1.0$.\n\nYour implementation must be scientifically sound and numerically self-consistent. Angles must be treated in radians. There are no physical units involved, so no unit conversion is required. The program must produce a single line of output containing all test case results, as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a float as defined above.\n\nTest Suite:\nProvide results for the following four parameter sets, each specified as a tuple $(\\epsilon, a, b, I, \\theta, r_{\\min}, r_{\\max}, \\text{tol}, T)$, where $T$ is the integration time horizon:\n\n- Case $1$ (targeting coexistence of a stable fixed point and a stable limit cycle): $(\\epsilon = 0.01, a = 1.05, b = 0.5, I = 0.5, \\theta = \\pi/4, r_{\\min} = 10^{-3}, r_{\\max} = 4.0, \\text{tol} = 10^{-3}, T = 800)$.\n- Case $2$ (near a transition with slow-fast separation): $(\\epsilon = 0.01, a = 1.05, b = 0.5, I = 0.35, \\theta = \\pi/3, r_{\\min} = 10^{-3}, r_{\\max} = 4.0, \\text{tol} = 10^{-3}, T = 800)$.\n- Case $3$ (typical limit cycle regime with no coexisting stable fixed point): $(\\epsilon = 0.08, a = 0.7, b = 0.8, I = 0.8, \\theta = \\pi/6, r_{\\min} = 10^{-3}, r_{\\max} = 3.0, \\text{tol} = 10^{-3}, T = 600)$.\n- Case $4$ (typical stable fixed point regime): $(\\epsilon = 0.08, a = 0.7, b = 0.8, I = 0.2, \\theta = \\pi/2, r_{\\min} = 10^{-3}, r_{\\max} = 3.0, \\text{tol} = 10^{-3}, T = 600)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$).",
            "solution": "The problem requires the design and implementation of a numerical scheme to approximate the basin boundary between a stable fixed point and a stable limit cycle for the FitzHugh-Nagumo system. The solution is predicated on fundamental principles of continuous-time dynamical systems. The methodology is structured into three main components: identifying stable equilibrium states, classifying long-term trajectory behavior, and systematically searching for the boundary where this behavior changes.\n\nFirst, we address the identification and stability analysis of fixed points. A fixed point, or equilibrium, of the system is a state $(v^\\ast, w^\\ast)$ where the dynamics cease, i.e., where the time derivatives are zero: $\\dot{v} = 0$ and $\\dot{w} = 0$. For the given FitzHugh-Nagumo model,\n$$\n\\dot v = v - \\frac{v^3}{3} - w + I,\n$$\n$$\n\\dot w = \\epsilon\\,(v + a - b\\,w),\n$$\nthe equilibrium conditions are:\n$$\nv^\\ast - \\frac{(v^\\ast)^3}{3} - w^\\ast + I = 0,\n$$\n$$\n\\epsilon\\,(v^\\ast + a - b\\,w^\\ast) = 0.\n$$\nSince $\\epsilon \\neq 0$ for the cases of interest, the second equation simplifies to $v^\\ast + a - b\\,w^\\ast = 0$, which yields the linear relationship $w^\\ast = (v^\\ast + a)/b$. Substituting this into the first equation eliminates $w^\\ast$ and results in a single cubic equation for $v^\\ast$:\n$$\nv^\\ast - \\frac{(v^\\ast)^3}{3} - \\frac{v^\\ast + a}{b} + I = 0.\n$$\nRearranging this into standard polynomial form gives:\n$$\n\\frac{1}{3}(v^\\ast)^3 - \\left(1 - \\frac{1}{b}\\right)v^\\ast + \\left(\\frac{a}{b} - I\\right) = 0.\n$$\nThe real roots of this cubic equation correspond to the $v$-coordinates of the system's fixed points. For each real root $v^\\ast$, the corresponding $w^\\ast$ is determined.\n\nThe local stability of each fixed point $(v^\\ast, w^\\ast)$ is determined by linearizing the system around it. This is achieved by analyzing the eigenvalues of the Jacobian matrix $J$ evaluated at the fixed point:\n$$\nJ(v^\\ast,w^\\ast) = \\begin{pmatrix} \\frac{\\partial \\dot{v}}{\\partial v}  \\frac{\\partial \\dot{v}}{\\partial w} \\\\ \\frac{\\partial \\dot{w}}{\\partial v}  \\frac{\\partial \\dot{w}}{\\partial w} \\end{pmatrix}_{(v^\\ast,w^\\ast)} = \\begin{pmatrix} 1 - (v^\\ast)^2  -1 \\\\ \\epsilon  -\\epsilon\\,b \\end{pmatrix}.\n$$\nA fixed point is locally stable if and only if all eigenvalues of its Jacobian have strictly negative real parts. For a $2 \\times 2$ matrix, the Routh-Hurwitz stability criteria provide a convenient test without explicitly computing the eigenvalues: stability is guaranteed if the trace of the Jacobian is negative ($\\text{Tr}(J)  0$) and the determinant is positive ($\\det(J)  0$).\n$$\n\\text{Tr}(J) = (1 - (v^\\ast)^2) - \\epsilon b  0,\n$$\n$$\n\\det(J) = (1 - (v^\\ast)^2)(-\\epsilon b) - (-1)(\\epsilon) = \\epsilon(1 - b + b(v^\\ast)^2)  0.\n$$\nThe implemented program will first seek a fixed point that satisfies these two inequalities. If no such stable fixed point exists, the premise for the subsequent search is not met, and the procedure for that case terminates.\n\nSecond, a principled method for classifying the long-term attractor of a given trajectory is required. The fundamental distinction between convergence to a fixed point and convergence to a limit cycle is that in the former case, the state variables approach constant values, while in the latter, they continue to oscillate. This can be quantified by numerically integrating the ODEs from a given initial condition $(v_0, w_0)$ over a sufficiently long time horizon $T$ to allow the system to settle onto its attractor. We then analyze the statistical properties of the trajectory over the latter portion of the integration interval, for instance, for time $t \\in [T/2, T]$. The standard deviation of one of the state variables (e.g., $v(t)$) serves as a robust metric:\n$$\n\\sigma_v = \\sqrt{\\frac{1}{N-1}\\sum_{i=1}^{N} (v(t_i) - \\bar{v})^2}.\n$$\nIf the trajectory converges to a stable fixed point, $\\sigma_v$ will approach zero (or a small value dictated by numerical precision). If it converges to a limit cycle, $\\sigma_v$ will be significantly non-zero. A threshold $\\sigma_{crit}$ is established, such that if $\\sigma_v  \\sigma_{crit}$, the attractor is classified as a fixed point; otherwise, it is classified as a limit cycle.\n\nThird, the basin boundary is located using a bisection search algorithm. The search is conducted along a ray originating from a discovered stable fixed point $(v^\\ast, w^\\ast)$ at an angle $\\theta$. Initial conditions on this ray are parameterized by their radial distance $r$:\n$$\n(v_0(r), w_0(r)) = (v^\\ast, w^\\ast) + r(\\cos\\theta, \\sin\\theta).\n$$\nThe search is performed over the interval $r \\in [r_{\\min}, r_{\\max}]$. We first verify that the attractors at the endpoints of the interval are of different types, i.e., one is a fixed point and the other is a limit cycle. This is the bracketing condition. Assuming the attractor for $r_{\\min}$ is the fixed point (as $r_{\\min}$ is small and close to the origin of the ray), we require the attractor for $r_{\\max}$ to be a limit cycle. If this condition is not met, no boundary is bracketed in the given range. If it is met, we iteratively halve the search interval $[r_{low}, r_{high}]$. In each step, we compute the midpoint $r_{mid} = (r_{low} + r_{high})/2$ and classify its attractor. If the attractor at $r_{mid}$ is of the same type as at $r_{low}$, we update $r_{low} = r_{mid}$; otherwise, we update $r_{high} = r_{mid}$. This process continues until the interval width $(r_{high} - r_{low})$ is less than a specified tolerance $\\text{tol}$. The final estimate for the critical radius $r_c$ is the midpoint of the final interval. The procedure returns a value of $-1.0$ if either no stable fixed point is found or the bracketing condition is not satisfied.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Define constants for attractor classification and numerical analysis\nATTRACTOR_FP = 0  # Represents convergence to a fixed point\nATTRACTOR_LC = 1  # Represents convergence to a limit cycle\nCONVERGENCE_STD_THRESHOLD = 1e-4  # Threshold for standard deviation to classify an attractor\n\ndef fhn_ode(t, y, epsilon, a, b, I):\n    \"\"\"\n    Defines the FitzHugh-Nagumo system of ordinary differential equations.\n    \"\"\"\n    v, w = y\n    dv_dt = v - v**3 / 3.0 - w + I\n    dw_dt = epsilon * (v + a - b * w)\n    return [dv_dt, dw_dt]\n\ndef find_stable_fixed_point(epsilon, a, b, I):\n    \"\"\"\n    Finds a stable fixed point of the FitzHugh-Nagumo system for given parameters.\n    Returns the coordinates (v*, w*) of a stable fixed point, or None if none is found.\n    \"\"\"\n    # Define the coefficients of the cubic equation for v*:\n    # (1/3)v^3 - (1 - 1/b)v + (a/b - I) = 0\n    coeffs = [1.0/3.0, 0.0, -(1.0 - 1.0/b), (a/b - I)]\n    roots = np.roots(coeffs)\n    \n    # Filter for real roots, as v* must be real.\n    real_roots = roots[np.isreal(roots)].real\n    \n    for v_star in real_roots:\n        # Check stability using Routh-Hurwitz criteria (Tr  0, Det  0)\n        trace = 1.0 - v_star**2 - epsilon * b\n        determinant = epsilon * (1.0 - b + b * v_star**2)\n        \n        if trace  0 and determinant  0:\n            w_star = (v_star + a) / b\n            return (v_star, w_star) # Return first stable fixed point found\n            \n    return None # No stable fixed point found\n\ndef classify_attractor(initial_conditions, epsilon, a, b, I, T):\n    \"\"\"\n    Classifies the long-term attractor by integrating the ODE and analyzing the trajectory.\n    Returns ATTRACTOR_FP or ATTRACTOR_LC.\n    \"\"\"\n    # Use a dense output to evaluate the solution efficiently at specific times\n    sol = solve_ivp(\n        fhn_ode,\n        t_span=[0, T],\n        y0=initial_conditions,\n        args=(epsilon, a, b, I),\n        method='RK45',\n        dense_output=True \n    )\n    \n    # Analyze the last half of the trajectory to ensure transients have died out\n    eval_times = np.linspace(T / 2.0, T, num=200)\n    trajectory_tail = sol.sol(eval_times)\n    \n    # Use the standard deviation of the v-component as the classification metric\n    v_tail = trajectory_tail[0, :]\n    std_v = np.std(v_tail)\n    \n    if std_v  CONVERGENCE_STD_THRESHOLD:\n        return ATTRACTOR_FP\n    else:\n        return ATTRACTOR_LC\n\ndef solve():\n    \"\"\"\n    Main function to execute the full analysis for each test case.\n    \"\"\"\n    # Test suite parameters:\n    # (epsilon, a, b, I, theta, r_min, r_max, tol, T)\n    test_cases = [\n        (0.01, 1.05, 0.5, 0.5, np.pi/4, 1e-3, 4.0, 1e-3, 800),\n        (0.01, 1.05, 0.5, 0.35, np.pi/3, 1e-3, 4.0, 1e-3, 800),\n        (0.08, 0.7, 0.8, 0.8, np.pi/6, 1e-3, 3.0, 1e-3, 600),\n        (0.08, 0.7, 0.8, 0.2, np.pi/2, 1e-3, 3.0, 1e-3, 600)\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        epsilon, a, b, I, theta, r_min, r_max, tol, T = case\n        \n        # Step 1: Find a stable fixed point to originate the search ray.\n        fp = find_stable_fixed_point(epsilon, a, b, I)\n        \n        if fp is None:\n            # If no stable fixed point, the search cannot be performed as specified.\n            results.append(-1.0)\n            continue\n            \n        v_star, w_star = fp\n        \n        # Define a helper function to classify attractor for a given radius r\n        def get_attractor_type_at_r(r):\n            ic_v = v_star + r * np.cos(theta)\n            ic_w = w_star + r * np.sin(theta)\n            return classify_attractor([ic_v, ic_w], epsilon, a, b, I, T)\n\n        # Step 2: Bracket the boundary.\n        # The search ray originates from the fixed point, so for small r (r_min),\n        # the attractor should be that same fixed point.\n        type_at_rmin = get_attractor_type_at_r(r_min)\n        type_at_rmax = get_attractor_type_at_r(r_max)\n        \n        # If types are the same, no boundary is bracketed in the interval.\n        # Also ensures that the inner point is indeed the fixed point's basin.\n        if type_at_rmin != ATTRACTOR_FP or type_at_rmin == type_at_rmax:\n            results.append(-1.0)\n            continue\n        \n        # Step 3: Perform bisection search.\n        r_low, r_high = r_min, r_max\n        \n        while (r_high - r_low)  tol:\n            r_mid = (r_low + r_high) / 2.0\n            \n            type_at_rmid = get_attractor_type_at_r(r_mid)\n            \n            if type_at_rmid == ATTRACTOR_FP:\n                # Midpoint is still in the fixed point basin, move the lower bound up.\n                r_low = r_mid\n            else:\n                # Midpoint is in the other basin, move the upper bound down.\n                r_high = r_mid\n                \n        critical_radius = (r_low + r_high) / 2.0\n        results.append(critical_radius)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}