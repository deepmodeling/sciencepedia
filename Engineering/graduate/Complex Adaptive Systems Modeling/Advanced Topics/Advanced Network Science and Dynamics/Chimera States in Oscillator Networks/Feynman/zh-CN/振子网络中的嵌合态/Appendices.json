{
    "hands_on_practices": [
        {
            "introduction": "全局Kuramoto序参量 ($R$) 是衡量振子网络同步程度的经典工具。然而，尽管它对于均匀同步或非同步的系统非常有效，但在处理像嵌合态这样具有复杂空间异质性的状态时，它可能会产生误导。本练习 () 将通过一个精心设计的思想实验来揭示这一局限性，你会计算一个典型嵌合态的全局序参量，从而亲身体会为何局部化分析是理解嵌合态现象的关键。",
            "id": "4117505",
            "problem": "考虑一个由$N=1200$个相同的非局域耦合相位振子组成的环形网络，该网络在复杂自适应系统建模的框架下进行研究。某一时刻的相位快照表现出相干与非相干的共存现象：一个连续的相干域和一个互补的非相干域。具体来说，相位由以下划分给出：\n- 对于 $1 \\leq j \\leq 360$，振子锁相于 $\\theta_{j}=0$ (单位为弧度)。\n- 对于 $361 \\leq j \\leq 1200$，振子在单位圆上均匀分布：$\\theta_{j}=\\frac{2\\pi}{840}\\big(j-361\\big)$ (单位为弧度)，这列举了圆上全部840个等间距点。\n\n从全局Kuramoto序参量的核心定义出发，计算复平均值\n$$R\\,\\exp(i\\Psi)=\\frac{1}{N}\\sum_{j=1}^{N}\\exp\\big(i\\theta_{j}\\big),$$\n并以精确有理数的形式返回其模$R$。然后，利用关于单位圆上求平均的基本原理，并且不使用标准定义之外的任何预设诊断公式，解释为什么单一的全局$R$值可能无法分辨嵌合态中通常观察到的相干与非相干共存现象。\n\n将最终的模$R$表示为精确的有理数。角度单位为弧度。最终答案无需单位。",
            "solution": "该问题提法清晰且科学上合理，为进行完整分析提供了所有必要信息。我们需要计算给定相位分布下的全局Kuramoto序参量的模，并解释这一全局度量的局限性。\n\n全局Kuramoto序参量定义为一个复数 $Z = R\\,\\exp(i\\Psi)$，其中 $R$ 是模，$\\Psi$ 是平均相位。它的计算方法是网络中所有振子的相量(phasor)的复平均值：\n$$Z = R\\,\\exp(i\\Psi)=\\frac{1}{N}\\sum_{j=1}^{N}\\exp\\big(i\\theta_{j}\\big)$$\n振子总数为 $N=1200$。该网络被划分为两个不同的子群体。\n\n首先，我们通过将求和分解到两个区域（相干域和非相干域）来计算总和 $\\sum_{j=1}^{N}\\exp(i\\theta_{j})$。\n$$\\sum_{j=1}^{1200}\\exp\\big(i\\theta_{j}\\big) = \\sum_{j=1}^{360}\\exp\\big(i\\theta_{j}\\big) + \\sum_{j=361}^{1200}\\exp\\big(i\\theta_{j}\\big)$$\n\n我们来计算相干域的总和。这个子群体由 $N_c = 360$ 个振子组成，索引从 $j=1$ 到 $j=360$。它们的相位都锁定在 $\\theta_{j}=0$ 弧度。\n$$\\sum_{j=1}^{360}\\exp\\big(i\\theta_{j}\\big) = \\sum_{j=1}^{360}\\exp(i \\cdot 0) = \\sum_{j=1}^{360} 1 = 360$$\n该群体的相量都沿着正实轴对齐，它们的和是一个实数，等于该群体中的振子数量。\n\n接着，我们计算非相干域的总和。这个子群体由 $N_i = 1200 - 360 = 840$ 个振子组成，索引从 $j=361$ 到 $j=1200$。它们的相位由 $\\theta_{j}=\\frac{2\\pi}{840}\\big(j-361\\big)$ 给出。\n为了简化求和，我们引入新索引 $k = j-361$。当 $j=361$ 时，$k=0$。当 $j=1200$ 时，$k=1200-361=839$。总和变为：\n$$\\sum_{j=361}^{1200}\\exp\\left(i\\frac{2\\pi}{840}(j-361)\\right) = \\sum_{k=0}^{839}\\exp\\left(i\\frac{2\\pi k}{840}\\right)$$\n这个求和中的各项，即 $k=0, 1, \\dots, 839$ 时的 $\\exp\\left(i\\frac{2\\pi k}{840}\\right)$，代表了840次单位根的完整集合。从几何上看，它们是840个单位长度的向量，均匀地分布在单位圆周上。由于对称性，这些向量的和为零。\n这可以通过将该和视为一个有限几何级数 $\\sum_{k=0}^{n-1} ar^k = a\\frac{1-r^n}{1-r}$ 来形式化地证明，其中 $a=1$，$n=840$，公比 $r = \\exp\\left(i\\frac{2\\pi}{840}\\right)$。因为 $n=840$，所以 $r \\neq 1$。\n$$\\sum_{k=0}^{839} r^k = \\frac{1-r^{840}}{1-r} = \\frac{1-\\left(\\exp\\left(i\\frac{2\\pi}{840}\\right)\\right)^{840}}{1-\\exp\\left(i\\frac{2\\pi}{840}\\right)} = \\frac{1-\\exp(i2\\pi)}{1-\\exp\\left(i\\frac{2\\pi}{840}\\right)} = \\frac{1-1}{1-\\exp\\left(i\\frac{2\\pi}{840}\\right)} = 0$$\n因此，非相干域上的总和计算结果为 $0$。\n\n现在，我们可以结合两个域的结果来找到总和：\n$$\\sum_{j=1}^{1200}\\exp\\big(i\\theta_{j}\\big) = 360 + 0 = 360$$\n将此结果代入全局序参量的定义中：\n$$Z = \\frac{1}{1200} (360) = \\frac{360}{1200} = \\frac{36}{120} = \\frac{3}{10}$$\n复平均值是一个实数，$Z = \\frac{3}{10}$。模 $R$ 是 $Z$ 的绝对值。\n$$R = \\left|\\frac{3}{10}\\right| = \\frac{3}{10}$$\n\n对于问题的第二部分，我们解释为什么全局序参量 $R$ 对于嵌合态来说是一个不充分的诊断指标。\n全局序参量 $R$ 本质上是一个通过对整个振子群体进行平均而得到的宏观度量。根据其作为平均值的定义，它将所有 $N$ 个振子的详细相位构型简化为一个单一的复数。\n在给定的问题中，系统表现出一种显著的异质结构：一个完全相干的子群体与一个完全非相干的子群体共存。我们可以通过考虑每个子群体的序参量来分析这一点。\n设 $Z_c$ 为包含 $N_c = 360$ 个振子的相干群体的序参量，设 $Z_i$ 为包含 $N_i = 840$ 个振子的非相干群体的序参量。\n$$Z_c = \\frac{1}{N_c}\\sum_{j=1}^{360}\\exp\\big(i\\theta_j\\big) = \\frac{1}{360} \\sum_{j=1}^{360}\\exp(i \\cdot 0) = \\frac{360}{360} = 1$$\n$$Z_i = \\frac{1}{N_i}\\sum_{j=361}^{1200}\\exp\\big(i\\theta_j\\big) = \\frac{1}{840} \\sum_{k=0}^{839}\\exp\\left(i\\frac{2\\pi k}{840}\\right) = \\frac{0}{840} = 0$$\n相干群体的局域序参量的模为 $R_c = |Z_c| = 1$，表示完全的相位同步。对于非相干群体，其模为 $R_i = |Z_i| = 0$，表示完全的异步。\n全局序参量 $Z$ 可以表示为子群体序参量的加权平均：\n$$Z = \\frac{1}{N}\\left(N_c Z_c + N_i Z_i\\right) = \\frac{N_c}{N}Z_c + \\frac{N_i}{N}Z_i$$\n$$Z = \\frac{360}{1200}(1) + \\frac{840}{1200}(0) = \\frac{3}{10}$$\n结果 $R = |Z| = \\frac{3}{10}$ 是一个介于 $0$ 和 $1$ 之间的中间值。全局度量 $R$ 的关键缺陷在于，它无法将这种特定的嵌合态与一个完全不同的、空间均匀的状态区分开来。例如，一个由1200个振子组成的网络可能处于部分同步状态，其中每个振子具有大致相同的相干水平，从而导致全局序参量为 $R = \\frac{3}{10}$。这样的状态在动力学和结构上都与嵌合态截然不同，但它们会产生相同的全局诊断值。\n因此，单一的标量值 $R$ 内在地平均掉并掩盖了关于不同网络区域中不同动力学行为（相干与非相干）共存的空间信息，而这种共存正是嵌合态的定义性特征。要分辨此类状态，需要能够捕捉这种异质性的局域或空间分辨的度量。",
            "answer": "$$\\boxed{\\frac{3}{10}}$$"
        },
        {
            "introduction": "正如上一个练习所揭示的，单一的全局序参量无法捕捉到嵌合态中同步与非同步区域共存的本质特征。为了解决这个问题，我们需要转向局部化的分析方法，通过考察网络中不同位置的动力学行为来绘制一幅更精细的图像。这个实践练习 () 为你提供了分析静态“快照”的实用计算工具，你将学习如何实现局部序参量、空间非相干分数和嵌合指数等关键诊断指标，从而对给定的振子相位分布进行定量分类。",
            "id": "4117507",
            "problem": "给定一维环形网络上振子相位的快照，要求您计算局部相干性、空间非相干分数和嵌合指数，然后根据指定的阈值判断每个快照是否符合嵌合体条件。该环形网络在单个时间点上有 $N$ 个振子，其相位为 $\\theta_i$（单位为弧度），索引为 $i \\in \\{0,1,\\dots,N-1\\}$，并具有周期性边界条件。\n\n使用的定义：\n\n1.  局部 Kuramoto 有序参数。对于每个索引 $i$，给定一个整数邻域半宽 $L \\ge 0$，定义\n    $$\n    r_i = \\left| \\frac{1}{2L+1} \\sum_{j=-L}^{L} e^{\\mathrm{i}\\,\\theta_{(i+j) \\bmod N}} \\right| .\n    $$\n    这衡量了节点 $i$ 周围相位的局部相干性。\n\n2.  空间非相干性。给定一个相干性阈值 $r_{\\mathrm{thr}} \\in [0,1]$，根据以下规则对每个节点进行二元分类：\n    $$\n    \\text{如果 } r_i < r_{\\mathrm{thr}} \\text{，则节点 } i \\text{ 是非相干的，否则是相干的}。\n    $$\n    设如果节点 $i$ 是非相干的，则 $b_i$ 为 $1$，否则为 $0$。空间非相干性则为\n    $$\n    SI = \\frac{1}{N} \\sum_{i=0}^{N-1} b_i .\n    $$\n\n3.  环上的嵌合指数。将嵌合指数 $X$ 定义为环上连续非相干簇的数量。形式上，使用周期性索引，\n    $$\n    X = \n    \\begin{cases}\n    0,  \\text{如果 } SI = 0, \\\\\n    1,  \\text{如果 } SI = 1, \\\\\n    \\sum_{i=0}^{N-1} \\left[ b_i = 1 \\wedge b_{(i-1) \\bmod N} = 0 \\right],  \\text{其他情况},\n    \\end{cases}\n    $$\n    其中 $\\left[\\cdot\\right]$ 表示其内部逻辑条件为真的指示函数。\n\n4.  嵌合体判定。给定阈值 $SI_{\\min}$，$SI_{\\max}$（满足 $0 \\le SI_{\\min} < SI_{\\max} \\le 1$）和一个最小域计数 $X_{\\min} \\in \\mathbb{N}$，当且仅当以下条件成立时，宣布该快照为嵌合体：\n    $$\n    SI_{\\min} < SI < SI_{\\max} \\quad \\text{且} \\quad X \\ge X_{\\min}.\n    $$\n\n角度单位为弧度。没有需要报告的物理单位。对于数值报告，将每个 $r_i$ 和 $SI$ 四舍五入到 $4$ 位小数。每个测试用例的最终输出必须是以下形式的列表：\n$$\n[\\,[r_0,\\dots,r_{N-1}],\\, SI,\\, X,\\, \\text{chimera\\_bool}\\,],\n$$\n其中 $[r_0,\\dots,r_{N-1}]$ 是四舍五入后的局部有序参数列表，$SI$ 是四舍五入后的空间非相干性，$X$ 是整数嵌合指数，而 $\\text{chimera\\_bool}$ 是一个布尔值。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号内以逗号分隔的列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$）。\n\n测试套件。使用以下 $5$ 个测试用例：\n\n-   案例 A (均匀相干):\n    -   $N = 12$, $L = 2$, $r_{\\mathrm{thr}} = 0.95$, $SI_{\\min} = 0.05$, $SI_{\\max} = 0.95$, $X_{\\min} = 1$.\n    -   相位: 对所有 $i$，$\\theta_i = 0$。\n\n-   案例 B (展开态，高非相干阈值):\n    -   $N = 12$, $L = 2$, $r_{\\mathrm{thr}} = 0.8$, $SI_{\\min} = 0.05$, $SI_{\\max} = 0.95$, $X_{\\min} = 1$.\n    -   相位: 对 $i=0,\\dots,N-1$，$\\theta_i = \\frac{2\\pi i}{N}$。\n\n-   案例 C (单个连续非相干域):\n    -   $N = 20$, $L = 2$, $r_{\\mathrm{thr}} = 0.85$, $SI_{\\min} = 0.2$, $SI_{\\max} = 0.8$, $X_{\\min} = 1$.\n    -   相位: 对 $i = 0,\\dots,9$，$\\theta_i = 0$；对 $i=10,\\dots,19$，$\\theta_i = \\frac{2\\pi (i-10)}{10}$。\n\n-   案例 D (由相干岛屿分隔的两个非相干域):\n    -   $N = 24$, $L = 2$, $r_{\\mathrm{thr}} = 0.85$, $SI_{\\min} = 0.3$, $SI_{\\max} = 0.9$, $X_{\\min} = 2$.\n    -   相位: 对 $i \\in \\{0,1,2,3,4,5,12,13,14,15,16,17\\}$，$\\theta_i = 0$；对 $i \\in \\{6,7,8,9,10,11\\}$，$\\theta_i = \\frac{2\\pi (i-6)}{6}$；对 $i \\in \\{18,19,20,21,22,23\\}$，$\\theta_i = \\frac{2\\pi (i-18)}{6}$。\n\n-   案例 E (产生多个边界的交替块):\n    -   $N = 16$, $L = 1$, $r_{\\mathrm{thr}} = 0.7$, $SI_{\\min} = 0.1$, $SI_{\\max} = 0.9$, $X_{\\min} = 2$.\n    -   相位: 四个大小为 $4$ 的块在 $0$ 和局部斜坡之间交替，\n        对 $i \\in \\{0,1,2,3\\}$，$\\theta_i = 0$；对 $i \\in \\{4,5,6,7\\}$，$\\theta_i = \\frac{2\\pi (i-4)}{4}$；对 $i \\in \\{8,9,10,11\\}$，$\\theta_i = 0$；对 $i \\in \\{12,13,14,15\\}$，$\\theta_i = \\frac{2\\pi (i-12)}{4}$。\n\n您的程序必须实现上述定义的计算，并生成仅一行输出，其中包含五个结果的列表，每个结果本身都是一个 $[\\,[r_0,\\dots,r_{N-1}],\\, SI,\\, X,\\, \\text{chimera\\_bool}\\,]$ 形式的列表，并带有指定的四舍五入。",
            "solution": "该问题要求分析一维环形网络上振子相位的几个快照，以确定它们是否代表嵌合体态。此分析涉及计算一组标准度量：局部 Kuramoto 有序参数、空间非相干性和嵌合指数。基于这些度量和一组给定的阈值，做出最终分类。该过程是确定性的，并遵循所提供的数学定义。\n\n分析的基础在于局部同步的概念。Kuramoto 有序参数是相位相关性的标准度量。其局部版本 $r_i$评估了振子 $i$ 特定邻域内的同步程度。$r_i=1$ 的值表示完美的局部相干性（所有相邻相位都相同），而 $r_i=0$ 表示最大的局部非相干性。\n\n这个问题是有效的，因为它在科学上基于复杂系统和非线性动力学的既定理论，在数学上是适定的，具有明确的定义，并提出了一个客观、可验证的计算任务。所有数据和参数均已提供，确保每个测试用例都有唯一的解决方案。\n\n解决每个测试用例问题的算法步骤如下：\n\n**步骤 1：计算局部 Kuramoto 有序参数 $r_i$**\n\n对于每个振子 $i \\in \\{0, 1, \\dots, N-1\\}$，根据其邻居的相位计算局部有序参数 $r_i$。邻域由半宽 $L$ 定义，包括以 $i$ 为中心的 $2L+1$ 个振子。由于环形拓扑结构，索引采用模 $N$ 运算处理。公式为：\n$$\nr_i = \\left| \\frac{1}{2L+1} \\sum_{j=-L}^{L} e^{\\mathrm{i}\\,\\theta_{(i+j) \\bmod N}} \\right|\n$$\n每一项 $e^{\\mathrm{i}\\,\\theta_k}$ 是复平面中的一个相量（单位长度的复数），代表振子 $k$ 的状态。模内的表达式是 $i$ 邻域内相量的复数平均值。这个平均向量的模长 $r_i$ 量化了这些相量的对齐程度。如果它们完全对齐（所有相位相同），平均向量的长度为 $1$。如果它们均匀分布，平均向量的长度接近 $0$。对所有 $N$ 个振子执行此计算，得到一个局部相干性值列表 $[r_0, r_1, \\dots, r_{N-1}]$。根据问题规范，报告时每个 $r_i$ 都四舍五入到 $4$ 位小数。\n\n**步骤 2：节点分类与空间非相干性 $SI$ 的计算**\n\n使用计算出的 $r_i$ 值，每个振子被分类为相干或非相干。阈值 $r_{\\mathrm{thr}}$ 用于此二元分类。如果振子 $i$ 的局部相干性 $r_i$ 小于 $r_{\\mathrm{thr}}$，则认为它是非相干的。我们定义一个二元指示变量 $b_i$：\n$$\nb_i = \\begin{cases} 1  \\text{如果 } r_i < r_{\\mathrm{thr}} \\\\ 0  \\text{如果 } r_i \\ge r_{\\mathrm{thr}} \\end{cases}\n$$\n空间非相干性 $SI$ 是被分类为非相干的振子总数所占的比例。它是二元指示符的平均值：\n$$\nSI = \\frac{1}{N} \\sum_{i=0}^{N-1} b_i\n$$\n$SI$ 的值范围从 $0$（所有振子相干）到 $1$（所有振子非相干）。此值在输出时也四舍五入到 $4$ 位小数。\n\n**步骤 3：计算嵌合指数 $X$**\n\n嵌合指数 $X$ 通过计算不同、连续的非相干簇的数量来量化相干域和非相干域的空间组织。在环上，这等同于计算相干区域和非相干区域之间的界面数量。定义如下：\n$$\nX = \n\\begin{cases}\n0,  \\text{如果 } SI = 0 \\text{ (无非相干节点)} \\\\\n1,  \\text{如果 } SI = 1 \\text{ (所有节点非相干)} \\\\\n\\sum_{i=0}^{N-1} \\left[ b_i = 1 \\wedge b_{(i-1) \\bmod N} = 0 \\right],  \\text{其他情况}\n\\end{cases}\n$$\n一般情况计算的是在环形环上观察时二元序列 $b$ 中“上升沿”的数量，这恰好对应于非相干簇的数量。$SI=0$ 和 $SI=1$ 的特殊情况分别处理完全相干和完全非相干的均匀状态。一个完全非相干的状态被认为具有单个簇。\n\n**步骤 4：嵌合体态判定**\n\n一个状态是否被分类为嵌合体是基于一个两部分的逻辑条件。该条件确保状态表现出非平凡的相干与非相干混合（$SI_{\\min} < SI < SI_{\\max}$），并且这些域被充分组织成最小数量的簇（$X \\ge X_{\\min}$）。布尔变量 `chimera_bool` 由以下公式确定：\n$$\n\\text{chimera\\_bool} = (SI_{\\min} < SI < SI_{\\max}) \\wedge (X \\ge X_{\\min})\n$$\n使用未四舍五入的 $SI$ 值进行此比较，以避免因四舍五入产生的误差。\n\n将此四步过程应用于提供的五个测试用例中的每一个。最终输出是每个案例结果的汇总，并按指定格式进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef stringify(v):\n    \"\"\"\n    Custom function to convert a Python object to a string representation\n    without spaces, as suggested by the problem's output format examples.\n    \"\"\"\n    if isinstance(v, list):\n        return '[' + ','.join(stringify(x) for x in v) + ']'\n    if isinstance(v, bool):\n        return 'True' if v else 'False'\n    return str(v)\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": {\"N\": 12, \"L\": 2, \"r_thr\": 0.95, \"SI_min\": 0.05, \"SI_max\": 0.95, \"X_min\": 1},\n            \"phases_func\": lambda N: np.zeros(N)\n        },\n        {\n            \"params\": {\"N\": 12, \"L\": 2, \"r_thr\": 0.8, \"SI_min\": 0.05, \"SI_max\": 0.95, \"X_min\": 1},\n            \"phases_func\": lambda N: 2 * np.pi * np.arange(N) / N\n        },\n        {\n            \"params\": {\"N\": 20, \"L\": 2, \"r_thr\": 0.85, \"SI_min\": 0.2, \"SI_max\": 0.8, \"X_min\": 1},\n            \"phases_func\": lambda N: np.concatenate([\n                np.zeros(10),\n                2 * np.pi * np.arange(10) / 10\n            ])\n        },\n        {\n            \"params\": {\"N\": 24, \"L\": 2, \"r_thr\": 0.85, \"SI_min\": 0.3, \"SI_max\": 0.9, \"X_min\": 2},\n            \"phases_func\": lambda N: (\n                lambda p: (\n                    p.put(list(range(6, 12)), 2 * np.pi * np.arange(6) / 6),\n                    p.put(list(range(18, 24)), 2 * np.pi * np.arange(6) / 6),\n                    p\n                )[-1]\n            )(np.zeros(N))\n        },\n        {\n            \"params\": {\"N\": 16, \"L\": 1, \"r_thr\": 0.7, \"SI_min\": 0.1, \"SI_max\": 0.9, \"X_min\": 2},\n            \"phases_func\": lambda N: (\n                lambda p: (\n                    p.put(list(range(4, 8)), 2 * np.pi * np.arange(4) / 4),\n                    p.put(list(range(12, 16)), 2 * np.pi * np.arange(4) / 4),\n                    p\n                )[-1]\n            )(np.zeros(N))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        N, L = params[\"N\"], params[\"L\"]\n        r_thr, SI_min, SI_max, X_min = params[\"r_thr\"], params[\"SI_min\"], params[\"SI_max\"], params[\"X_min\"]\n        \n        phases = case[\"phases_func\"](N)\n        \n        # Step 1: Compute local order parameters r_i\n        r_vals_unrounded = []\n        neighborhood_size = 2 * L + 1\n        for i in range(N):\n            indices = (i + np.arange(-L, L + 1)) % N\n            neighborhood_phases = phases[indices]\n            \n            # Sum of phasors e^(i*theta)\n            phasor_sum = np.sum(np.exp(1j * neighborhood_phases))\n            \n            # Magnitude of the mean phasor\n            r_i = np.abs(phasor_sum / neighborhood_size)\n            r_vals_unrounded.append(r_i)\n        \n        r_vals_rounded = [round(r, 4) for r in r_vals_unrounded]\n\n        # Step 2: Compute spatial incoherence SI\n        b = np.array([1 if r  r_thr else 0 for r in r_vals_unrounded])\n        si_unrounded = np.mean(b)\n        si_rounded = round(si_unrounded, 4)\n\n        # Step 3: Compute chimera index X\n        if si_unrounded == 0:\n            X = 0\n        elif si_unrounded == 1:\n            X = 1\n        else:\n            # Count rising edges (0 -> 1) on the ring\n            b_shifted = np.roll(b, 1)\n            X = np.sum((b == 1)  (b_shifted == 0))\n\n        # Step 4: Chimera qualification\n        chimera_bool = (SI_min  si_unrounded  SI_max) and (X = X_min)\n\n        # Assemble result for the case\n        result = [r_vals_rounded, si_rounded, X, chimera_bool]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The custom stringify function ensures a compact representation.\n    print(stringify(results))\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何从静态数据中识别嵌合态之后，下一步自然是探索这些迷人模式是如何从系统的动力学演化中产生的。数值模拟是复杂系统研究的核心工具，它使我们能够观察动力学规则如何催生出复杂的集体行为。这项动手实践 () 将引导你构建一个双种群振子网络的仿真模型，通过探索不同的参数设置，你将亲手发现在何种条件下，一个初始时部分有序、部分无序的系统能够演化并维持一个稳定的嵌合态。",
            "id": "4117497",
            "problem": "您的任务是构建并分析一个双种群相位振子网络，以确定嵌合态出现的条件。从Kuramoto–Sakaguchi模型开始，其中每个振子由其相位表征，并通过带有相位滞后的正弦耦合与自身种群和其它种群中的所有其他振子相互作用。考虑两个由 $\\sigma \\in \\{1,2\\}$ 索引的种群，每个种群包含 $N$ 个振子，其相位为 $\\theta_{\\sigma,i}(t)$，其中 $i \\in \\{1,\\dots,N\\}$。动力学方程为\n$$\n\\frac{d\\theta_{1,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{11}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{1,i} - \\alpha\\big) \\;+\\; \\frac{K_{12}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{1,i} - \\alpha\\big),\n$$\n$$\n\\frac{d\\theta_{2,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{22}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{2,i} - \\alpha\\big) \\;+\\; \\frac{K_{21}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{2,i} - \\alpha\\big),\n$$\n其中 $\\omega$ 是共同的固有频率，$K_{11}$ 和 $K_{22}$ 是种群内耦合强度，$K_{12}$ 和 $K_{21}$ 是种群间耦合强度，$\\alpha$ 是相位滞后。为每个种群定义复序参量\n$$\nZ_{\\sigma}(t) \\;=\\; \\frac{1}{N}\\sum_{j=1}^{N} e^{\\,i\\theta_{\\sigma,j}(t)} \\;=\\; r_{\\sigma}(t)e^{\\,i\\psi_{\\sigma}(t)},\n$$\n其中 $r_{\\sigma}(t) \\in [0,1]$ 是振幅，$\\psi_{\\sigma}(t)$ 是种群 $\\sigma$ 的平均相位。在时间 $t$ 时，种群 $\\sigma$ 中振子 $i$ 的瞬时频率定义为\n$$\n\\Omega_{\\sigma,i}(t) \\;=\\; \\frac{d\\theta_{\\sigma,i}}{dt}(t).\n$$\n\n您的程序必须：\n- 以弧度为角度单位实现动力学，并从明确说明的初始条件开始演化系统。\n- 每个种群使用固定的振子数 $N = 64$，统一的固有频率 $\\omega = 0$，固定的总模拟时间 $T = 80$（无量纲时间单位），以及固定的时间步长 $\\Delta t = 0.02$。\n- 按如下方式初始化相位：对于种群1，从均值为0、标准差为0.1的正态分布中独立设置 $\\theta_{1,i}(0)$；对于种群2，从 $[-\\pi,\\pi]$ 上的均匀分布中独立设置 $\\theta_{2,i}(0)$。为了可复现性，使用固定的伪随机数生成器种子 $12345$。\n- 使用数值稳定的显式方案积分动力学，不依赖于捷径；例如，使用经典的四阶龙格-库塔方法，并在每一步之后将角度包裹到 $[-\\pi,\\pi]$ 区间内。\n- 在积分到时间 $T$ 后，计算 $r_{1}(T)$、$r_{2}(T)$，以及 $\\{\\Omega_{1,i}(T)\\}_{i=1}^{N}$ 和 $\\{\\Omega_{2,i}(T)\\}_{i=1}^{N}$ 各自的标准差 $\\sigma_{\\Omega_1}$ 和 $\\sigma_{\\Omega_2}$，并根据下方的共存准则判断是否存在嵌合态。\n\n嵌合态的共存准则：当且仅当，对于某种种群标记方式，一个种群是相干的而另一个种群是不相干的，则声明存在嵌合态。其中“相干”和“不相干”由以下阈值确定：\n- 相干种群：$r_{\\sigma}(T) \\ge \\rho_{\\text{high}}$ 且 $\\sigma_{\\Omega_\\sigma} \\le \\sigma_{\\text{low}}$，\n- 不相干种群：$r_{\\sigma}(T) \\le \\rho_{\\text{low}}$ 且 $\\sigma_{\\Omega_\\sigma} \\ge \\sigma_{\\text{high}}$，\n固定阈值为 $\\rho_{\\text{high}} = 0.95$，$\\rho_{\\text{low}} = 0.70$，$\\sigma_{\\text{low}} = 0.05$，$\\sigma_{\\text{high}} = 0.15$。请严格按照所述使用这些阈值。\n\n您的程序必须评估以下参数值 $(K_{11},K_{22},K_{12},K_{21},\\alpha)$ 的测试套件：\n- 测试 1：$(1.0, 1.0, 0.2, 0.2, 1.5)$，\n- 测试 2：$(1.0, 1.0, 0.8, 0.8, 1.5)$，\n- 测试 3：$(0.2, 0.2, 0.2, 0.2, 1.5)$，\n- 测试 4：$(1.0, 1.0, 0.5, 0.5, 1.5)$。\n\n对于每个测试用例，计算并返回列表 $[r_1(T), r_2(T), \\sigma_{\\Omega_1}, \\sigma_{\\Omega_2}, \\mathrm{chimera}]$，其中 $r_1(T)$ 和 $r_2(T)$ 是以弧度为单位的浮点数（无量纲），$\\sigma_{\\Omega_1}$ 和 $\\sigma_{\\Omega_2}$ 是浮点数（无量纲），$\\mathrm{chimera}$ 是一个布尔值，指示是否满足共存准则。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例表示为其自己的嵌套列表，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。角度必须以弧度为单位。除了已说明的无量纲时间单位外，不需要其他物理单位。",
            "solution": "问题陈述经评估在科学上是合理的、提法得当且完整的。一个唯一的、可验证的解决方案所需的所有必要组成部分都已提供。因此，我们可以着手进行求解。\n\n该问题要求对一个双种群Kuramoto-Sakaguchi相位振子网络进行数值模拟，以确定支持嵌合态的参数区域。嵌合态是全同振子网络中的一种时空模式，其中一部分振子同步，而其余振子则保持在不相干的、去同步的状态。\n\n该系统由以下关于种群 $\\sigma \\in \\{1,2\\}$ 中振子 $i$ 的相位 $\\theta_{\\sigma,i}(t)$ 的耦合常微分方程组（ODE）描述：\n$$\n\\frac{d\\theta_{1,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{11}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{1,i} - \\alpha\\big) \\;+\\; \\frac{K_{12}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{1,i} - \\alpha\\big)\n$$\n$$\n\\frac{d\\theta_{2,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{22}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{2,i} - \\alpha\\big) \\;+\\; \\frac{K_{21}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{2,i} - \\alpha\\big)\n$$\n\n直接对这些方程进行数值积分，在积分算法的每个子步骤中，都需要为 $2N$ 个振子中的每一个对所有 $N$ 个振子进行求和，这将导致每步的计算复杂度为 $O(N^2)$。为了创建一个更高效的模拟，我们可以使用每个种群 $\\sigma$ 的复序参量来重构方程：\n$$\nZ_{\\sigma}(t) \\;=\\; r_{\\sigma}(t)e^{i\\psi_{\\sigma}(t)} \\;=\\; \\frac{1}{N}\\sum_{j=1}^{N} e^{i\\theta_{\\sigma,j}(t)}\n$$\n使用恒等式 $\\sin(x) = \\text{Im}[e^{ix}]$，可以重写 ODE 中的求和项。例如，对于第一个方程中的第一项：\n$$\n\\frac{1}{N}\\sum_{j=1}^{N}\\sin(\\theta_{1,j} - \\theta_{1,i} - \\alpha) = \\frac{1}{N}\\sum_{j=1}^{N}\\text{Im}[e^{i(\\theta_{1,j} - \\theta_{1,i} - \\alpha)}] = \\text{Im}[e^{-i(\\theta_{1,i} + \\alpha)} \\frac{1}{N}\\sum_{j=1}^{N}e^{i\\theta_{1,j}}]\n$$\n$$\n= \\text{Im}[e^{-i(\\theta_{1,i} + \\alpha)} r_1(t)e^{i\\psi_1(t)}] = r_1(t)\\sin(\\psi_1(t) - \\theta_{1,i} - \\alpha)\n$$\n将此简化应用于所有求和项，ODE 系统变为：\n$$\n\\frac{d\\theta_{1,i}}{dt} = \\omega + K_{11} r_1 \\sin(\\psi_1 - \\theta_{1,i} - \\alpha) + K_{12} r_2 \\sin(\\psi_2 - \\theta_{1,i} - \\alpha)\n$$\n$$\n\\frac{d\\theta_{2,i}}{dt} = \\omega + K_{22} r_2 \\sin(\\psi_2 - \\theta_{2,i} - \\alpha) + K_{21} r_1 \\sin(\\psi_1 - \\theta_{2,i} - \\alpha)\n$$\n这种形式将每个时间步的计算复杂度降低到 $O(N)$，因为它只需要在为所有 $2N$ 个振子计算导数之前计算两个序参量（$Z_1, Z_2$）。\n\n该系统使用经典的四阶龙格-库塔（RK4）方法，以 $\\Delta t=0.02$ 的固定时间步长，从 $t=0$ 到 $t=T=80$ 进行数值积分。系统的状态是一个包含 $2N$ 个相位的向量，$[\\theta_{1,1},\\dots,\\theta_{1,N},\\theta_{2,1},\\dots,\\theta_{2,N}]$。在每个完整的 RK4 步骤之后，将相位包裹到区间 $[-\\pi, \\pi]$ 内，以防止数值溢出并保持一致性。系统参数设置为每个种群 $N=64$ 个振子，共同固有频率 $\\omega=0$。\n\n为了可复现性，使用固定种子 $12345$ 的伪随机数生成器生成初始条件。种群 1 的初始相位从均值为 0、标准差为 0.1 的正态分布中抽取，即 $\\theta_{1,i}(0) \\sim \\mathcal{N}(0, 0.1^2)$。这将第一个种群置于高度相干的状态。种群 2 的初始相位从 $[-\\pi, \\pi]$ 上的均匀分布中抽取，即 $\\theta_{2,i}(0) \\sim \\mathcal{U}[-\\pi, \\pi]$，这对应于一个完全不相干的状态。\n\n在模拟达到最终时间 $T=80$ 后，计算一组度量来对最终状态进行分类。这些度量是序参量的振幅 $r_1(T)$ 和 $r_2(T)$，以及瞬时频率的标准差 $\\sigma_{\\Omega_1}$ 和 $\\sigma_{\\Omega_2}$。瞬时频率 $\\Omega_{\\sigma,i}(T)$ 是通过在最终时间 $T$ 评估 ODE 的右侧来计算的。\n\n嵌合态的识别基于一个严格的共存准则。如果一个种群 $\\sigma$ 的序参量高且频率离散度低（$r_{\\sigma}(T) \\ge \\rho_{\\text{high}}=0.95$ 且 $\\sigma_{\\Omega_\\sigma} \\le \\sigma_{\\text{low}}=0.05$），则该种群是“相干的”。如果一个种群的序参量低且频率离散度高（$r_{\\sigma}(T) \\le \\rho_{\\text{low}}=0.70$ 且 $\\sigma_{\\Omega_\\sigma} \\ge \\sigma_{\\text{high}}=0.15$），则该种群是“不相干的”。当且仅当根据这些确切的阈值，一个种群是相干的而另一个是不相干的时，才声明存在嵌合态。\n\n该算法通过迭代测试套件中提供的每个参数集来进行。对于每个集合，它执行所述的初始化、数值积分和最终分析。将得到的五个值——$[r_1(T), r_2(T), \\sigma_{\\Omega_1}, \\sigma_{\\Omega_2}, \\text{嵌合态状态}]$——进行存储。最后，将所有测试用例的收集结果格式化为表示列表的列表的单个字符串并打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-population Kuramoto-Sakaguchi model to find chimera states.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 64          # Number of oscillators per population\n    omega = 0.0     # Natural frequency\n    T = 80.0        # Total simulation time\n    dt = 0.02       # Time step\n\n    # Chimera detection thresholds\n    rho_high = 0.95\n    rho_low = 0.70\n    sigma_low = 0.05\n    sigma_high = 0.15\n\n    # Test cases: (K11, K22, K12, K21, alpha)\n    test_cases = [\n        (1.0, 1.0, 0.2, 0.2, 1.5),\n        (1.0, 1.0, 0.8, 0.8, 1.5),\n        (0.2, 0.2, 0.2, 0.2, 1.5),\n        (1.0, 1.0, 0.5, 0.5, 1.5),\n    ]\n\n    # --- Helper Functions ---\n\n    def wrap_angles(angles):\n        \"\"\"Wrap angles to the interval [-pi, pi].\"\"\"\n        return (angles + np.pi) % (2 * np.pi) - np.pi\n\n    def derivatives(thetas, N, K11, K22, K12, K21, alpha, omega):\n        \"\"\"\n        Calculates the time derivatives of the phases (d(theta)/dt).\n        \n        This function uses the efficient formulation based on order parameters.\n        \"\"\"\n        thetas1 = thetas[:N]\n        thetas2 = thetas[N:]\n\n        # Calculate complex order parameters\n        Z1 = np.mean(np.exp(1j * thetas1))\n        Z2 = np.mean(np.exp(1j * thetas2))\n\n        # Extract magnitudes (r) and mean phases (psi)\n        r1, psi1 = np.abs(Z1), np.angle(Z1)\n        r2, psi2 = np.abs(Z2), np.angle(Z2)\n\n        # Calculate derivatives for each population\n        d_thetas1 = omega + K11 * r1 * np.sin(psi1 - thetas1 - alpha) \\\n                          + K12 * r2 * np.sin(psi2 - thetas1 - alpha)\n        \n        d_thetas2 = omega + K22 * r2 * np.sin(psi2 - thetas2 - alpha) \\\n                          + K21 * r1 * np.sin(psi1 - thetas2 - alpha)\n        \n        return np.concatenate((d_thetas1, d_thetas2))\n\n    # --- Main Simulation Loop ---\n\n    results = []\n    \n    for case in test_cases:\n        K11, K22, K12, K21, alpha = case\n\n        # Initialize phases with a fixed seed for reproducibility\n        rng = np.random.default_rng(12345)\n        thetas1_0 = rng.normal(loc=0.0, scale=0.1, size=N)\n        thetas2_0 = rng.uniform(low=-np.pi, high=np.pi, size=N)\n        thetas = wrap_angles(np.concatenate((thetas1_0, thetas2_0)))\n\n        # RK4 Integration\n        num_steps = int(T / dt)\n        \n        # Define a closure for the derivative function with fixed parameters for the current case\n        f = lambda th: derivatives(th, N, K11, K22, K12, K21, alpha, omega)\n\n        for _ in range(num_steps):\n            # RK4 substeps\n            k1 = dt * f(thetas)\n            k2 = dt * f(wrap_angles(thetas + 0.5 * k1))\n            k3 = dt * f(wrap_angles(thetas + 0.5 * k2))\n            k4 = dt * f(wrap_angles(thetas + k3))\n            \n            # Update step\n            thetas = wrap_angles(thetas + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0)\n\n        # --- Final Analysis ---\n\n        # Separate final phases\n        thetas1_T = thetas[:N]\n        thetas2_T = thetas[N:]\n\n        # Calculate final order parameter magnitudes\n        r1_T = np.abs(np.mean(np.exp(1j * thetas1_T)))\n        r2_T = np.abs(np.mean(np.exp(1j * thetas2_T)))\n\n        # Calculate final instantaneous frequencies and their standard deviations\n        final_omegas = f(thetas) # This is d(theta)/dt at T\n        omegas1_T = final_omegas[:N]\n        omegas2_T = final_omegas[N:]\n        \n        s_om1 = np.std(omegas1_T)\n        s_om2 = np.std(omegas2_T)\n        \n        # Apply chimera criterion\n        pop1_coherent = (r1_T = rho_high) and (s_om1 = sigma_low)\n        pop1_incoherent = (r1_T = rho_low) and (s_om1 = sigma_high)\n\n        pop2_coherent = (r2_T = rho_high) and (s_om2 = sigma_low)\n        pop2_incoherent = (r2_T = rho_low) and (s_om2 = sigma_high)\n\n        is_chimera = (pop1_coherent and pop2_incoherent) or \\\n                     (pop1_incoherent and pop2_coherent)\n        \n        results.append([r1_T, r2_T, s_om1, s_om2, is_chimera])\n\n    # Final print statement in the exact required format.\n    # The template format print(f\"[{','.join(map(str, results))}]\") is used.\n    # This stringifies each inner list and joins them with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}