{
    "hands_on_practices": [
        {
            "introduction": "A tempting shortcut when analyzing multiplex networks is to simply aggregate the layers into a single graph. This practice, however, can obscure crucial structural features and lead to incorrect conclusions. This exercise  demonstrates this pitfall by showing how the ranking of nodes by eigenvector centrality can be completely inverted when comparing an aggregated network to a proper multiplex representation, highlighting the necessity of layer-aware analysis.",
            "id": "4131650",
            "problem": "Consider a multiplex network with two layers defined on the same node set $\\{1,2,3\\}$. In each layer, the topology is a weighted path: node $1$ is connected to node $2$ with weight $a$, and node $2$ is connected to node $3$ with weight $b$, with no other edges. The adjacency matrix of a single layer with weights $a$ and $b$ is\n$$\nA(a,b) \\;=\\; \\begin{pmatrix}\n0 & a & 0 \\\\\na & 0 & b \\\\\n0 & b & 0\n\\end{pmatrix}.\n$$\nLet layer $1$ have weights $a_{1} = 2.5$ and $b_{1} = 1$, and let layer $2$ have weights $a_{2} = 0.2$ and $b_{2} = 2.6$. Define aggregated eigenvector centrality (EC) as the dominant eigenvector of the aggregated adjacency $A^{\\mathrm{agg}} = A(a_{1},b_{1}) + A(a_{2},b_{2})$, and define multiplex EC as follows: form the supra-adjacency matrix\n$$\n\\mathcal{A}(\\omega) \\;=\\; \\begin{pmatrix}\nA(a_{1},b_{1}) & \\omega I \\\\\n\\omega I & A(a_{2},b_{2})\n\\end{pmatrix},\n$$\nwhere $I$ is the $3 \\times 3$ identity matrix and $\\omega \\ge 0$ is an interlayer coupling parameter. The multiplex EC of node $i$ is the sum of the components of the dominant eigenvector of $\\mathcal{A}(\\omega)$ corresponding to node $i$ across the two layers. Assume the extreme weak-coupling regime $\\omega = 0$.\n\nStarting from the definition of eigenvector centrality (EC) for a symmetric adjacency matrix $A$, which is the positive eigenvector $x$ satisfying $A x = \\lambda x$ for the spectral radius $\\lambda$, derive from first principles the node-wise EC ratios for the path topology. Use these derivations to demonstrate that the aggregated EC can mis-rank nodes relative to the multiplex EC by explicitly comparing the ranking of node $1$ versus node $3$ for the given two-layer network under the definitions above with $\\omega = 0$. Then, compute the inversion factor\n$$\nI \\;=\\; \\left(\\frac{x^{\\mathrm{agg}}_{3}}{x^{\\mathrm{agg}}_{1}}\\right) \\Big/ \\left(\\frac{x^{\\mathrm{mux}}_{3}}{x^{\\mathrm{mux}}_{1}}\\right),\n$$\nwhere $x^{\\mathrm{agg}}_{i}$ denotes the aggregated EC of node $i$ and $x^{\\mathrm{mux}}_{i}$ denotes the multiplex EC of node $i$. Express $I$ as a single exact number. No rounding is required. There are no physical units in this problem.",
            "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information to derive a unique solution. We begin by addressing the components of the problem in sequence.\n\nFirst, we derive the eigenvector centrality (EC) ratios for a general $3$-node path topology with adjacency matrix\n$$\nA(a,b) = \\begin{pmatrix} 0 & a & 0 \\\\ a & 0 & b \\\\ 0 & b & 0 \\end{pmatrix}\n$$\nwhere $a > 0$ and $b > 0$. The eigenvector centrality vector $x = (x_1, x_2, x_3)^T$ is the dominant eigenvector of $A$, which satisfies the equation $A x = \\lambda x$ where $\\lambda$ is the spectral radius of $A$. We start by finding the eigenvalues by solving the characteristic equation $\\det(A - \\lambda I) = 0$.\n$$\n\\det\\begin{pmatrix} -\\lambda & a & 0 \\\\ a & -\\lambda & b \\\\ 0 & b & -\\lambda \\end{pmatrix} = -\\lambda(\\lambda^2 - b^2) - a(-a\\lambda) = -\\lambda^3 + \\lambda b^2 + a^2 \\lambda = -\\lambda(\\lambda^2 - (a^2+b^2)) = 0\n$$\nThe eigenvalues are $\\lambda_1 = \\sqrt{a^2+b^2}$, $\\lambda_2 = 0$, and $\\lambda_3 = -\\sqrt{a^2+b^2}$. The spectral radius is the largest absolute value of the eigenvalues, which is $\\lambda_{\\max} = \\sqrt{a^2+b^2}$.\n\nNow we find the corresponding eigenvector $x$ for $\\lambda = \\lambda_{\\max}$:\n$$\n\\begin{pmatrix} 0 & a & 0 \\\\ a & 0 & b \\\\ 0 & b & 0 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix} = \\lambda_{\\max} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix}\n$$\nThis gives the system of linear equations:\n$1.$ $a x_2 = \\lambda_{\\max} x_1$\n$2.$ $a x_1 + b x_3 = \\lambda_{\\max} x_2$\n$3.$ $b x_2 = \\lambda_{\\max} x_3$\n\nFrom equation (1), we have $x_1 = \\frac{a}{\\lambda_{\\max}} x_2$.\nFrom equation (3), we have $x_3 = \\frac{b}{\\lambda_{\\max}} x_2$.\nBy the Perron-Frobenius theorem for non-negative matrices, the dominant eigenvector can be chosen to have strictly positive components, so $x_2 \\neq 0$. The ratio of the centralities of node $3$ and node $1$ is:\n$$\n\\frac{x_3}{x_1} = \\frac{\\frac{b}{\\lambda_{\\max}} x_2}{\\frac{a}{\\lambda_{\\max}} x_2} = \\frac{b}{a}\n$$\nThis demonstrates that for this path topology, the ratio of the eigenvector centralities of the two end-nodes is equal to the ratio of the weights of their respective links to the central node. The full eigenvector is proportional to $(a, \\lambda_{\\max}, b)^T$, which is $(a, \\sqrt{a^2+b^2}, b)^T$.\n\nNext, we calculate the aggregated eigenvector centrality. The aggregated adjacency matrix $A^{\\mathrm{agg}}$ is the sum of the layer adjacency matrices:\n$$\nA^{\\mathrm{agg}} = A(a_{1},b_{1}) + A(a_{2},b_{2}) = \\begin{pmatrix} 0 & a_1 & 0 \\\\ a_1 & 0 & b_1 \\\\ 0 & b_1 & 0 \\end{pmatrix} + \\begin{pmatrix} 0 & a_2 & 0 \\\\ a_2 & 0 & b_2 \\\\ 0 & b_2 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & a_1+a_2 & 0 \\\\ a_1+a_2 & 0 & b_1+b_2 \\\\ 0 & b_1+b_2 & 0 \\end{pmatrix}\n$$\nThis aggregated matrix is of the form $A(a_{\\mathrm{agg}}, b_{\\mathrm{agg}})$ with $a_{\\mathrm{agg}} = a_1+a_2$ and $b_{\\mathrm{agg}} = b_1+b_2$.\nUsing the given values $a_1 = 2.5$, $b_1 = 1$, $a_2 = 0.2$, and $b_2 = 2.6$:\n$a_{\\mathrm{agg}} = 2.5 + 0.2 = 2.7$\n$b_{\\mathrm{agg}} = 1 + 2.6 = 3.6$\nUsing our derived formula, the ratio of the aggregated ECs for nodes $3$ and $1$ is:\n$$\n\\frac{x^{\\mathrm{agg}}_{3}}{x^{\\mathrm{agg}}_{1}} = \\frac{b_{\\mathrm{agg}}}{a_{\\mathrm{agg}}} = \\frac{3.6}{2.7} = \\frac{36}{27} = \\frac{4}{3}\n$$\nSince $\\frac{4}{3} > 1$, for the aggregated network, $x^{\\mathrm{agg}}_{3} > x^{\\mathrm{agg}}_{1}$, meaning node $3$ is ranked as more central than node $1$.\n\nNow, we calculate the multiplex eigenvector centrality. The supra-adjacency matrix is given by:\n$$\n\\mathcal{A}(\\omega) = \\begin{pmatrix} A(a_{1},b_{1}) & \\omega I \\\\ \\omega I & A(a_{2},b_{2}) \\end{pmatrix}\n$$\nWe are in the extreme weak-coupling regime, $\\omega=0$. The matrix becomes block-diagonal:\n$$\n\\mathcal{A}(0) = \\begin{pmatrix} A(a_{1},b_{1}) & \\mathbf{0} \\\\ \\mathbf{0} & A(a_{2},b_{2}) \\end{pmatrix}\n$$\nThe eigenvalues of a block-diagonal matrix are the union of the eigenvalues of its blocks. Let $\\lambda_{\\max}^{(1)}$ and $\\lambda_{\\max}^{(2)}$ be the spectral radii of $A(a_1,b_1)$ and $A(a_2,b_2)$ respectively.\n$\\lambda_{\\max}^{(1)} = \\sqrt{a_1^2 + b_1^2} = \\sqrt{(2.5)^2 + 1^2} = \\sqrt{6.25 + 1} = \\sqrt{7.25}$\n$\\lambda_{\\max}^{(2)} = \\sqrt{a_2^2 + b_2^2} = \\sqrt{(0.2)^2 + (2.6)^2} = \\sqrt{0.04 + 6.76} = \\sqrt{6.8}$\nThe spectral radius of $\\mathcal{A}(0)$ is $\\lambda_{\\max} = \\max(\\lambda_{\\max}^{(1)}, \\lambda_{\\max}^{(2)}) = \\sqrt{7.25} = \\lambda_{\\max}^{(1)}$.\nThe dominant eigenvector $\\mathbf{x}_{\\mathrm{mux}}$ of $\\mathcal{A}(0)$ has the block structure $\\mathbf{x}_{\\mathrm{mux}} = (x^{(1)}, x^{(2)})^T$. The eigenvector equation $\\mathcal{A}(0)\\mathbf{x}_{\\mathrm{mux}} = \\lambda_{\\max}\\mathbf{x}_{\\mathrm{mux}}$ decouples into:\n$A(a_1, b_1) x^{(1)} = \\lambda_{\\max} x^{(1)} = \\lambda_{\\max}^{(1)} x^{(1)}$\n$A(a_2, b_2) x^{(2)} = \\lambda_{\\max} x^{(2)} = \\lambda_{\\max}^{(1)} x^{(2)}$\nThe first equation means $x^{(1)}$ is the dominant eigenvector of $A(a_1, b_1)$. Since $\\lambda_{\\max}^{(1)} \\neq \\lambda_{\\max}^{(2)}$, $\\lambda_{\\max}^{(1)}$ is not an eigenvalue of $A(a_2,b_2)$, so the only solution to the second equation is $x^{(2)} = \\mathbf{0}$.\nThus, the dominant eigenvector of $\\mathcal{A}(0)$ localizes entirely on layer $1$.\nThe multiplex EC of node $i$, $x_i^{\\mathrm{mux}}$, is the sum of the components corresponding to node $i$ across layers. With $x^{(2)}=\\mathbf{0}$, we have $x_i^{\\mathrm{mux}} = x_i^{(1)} + x_i^{(2)} = x_i^{(1)}$. The multiplex EC is identical to the EC of the dominant layer (layer $1$).\nUsing our general formula for the EC ratio on layer $1$:\n$$\n\\frac{x^{\\mathrm{mux}}_{3}}{x^{\\mathrm{mux}}_{1}} = \\frac{x^{(1)}_{3}}{x^{(1)}_{1}} = \\frac{b_1}{a_1} = \\frac{1}{2.5} = \\frac{2}{5}\n$$\nSince $\\frac{2}{5} < 1$, for the multiplex network, $x^{\\mathrm{mux}}_{1} > x^{\\mathrm{mux}}_{3}$, meaning node $1$ is ranked as more central than node $3$. This is an inversion of the ranking found with the aggregated network.\n\nFinally, we compute the inversion factor $I$:\n$$\nI = \\left(\\frac{x^{\\mathrm{agg}}_{3}}{x^{\\mathrm{agg}}_{1}}\\right) \\Big/ \\left(\\frac{x^{\\mathrm{mux}}_{3}}{x^{\\mathrm{mux}}_{1}}\\right)\n$$\nSubstituting the values we calculated:\n$$\nI = \\frac{4/3}{2/5} = \\frac{4}{3} \\times \\frac{5}{2} = \\frac{20}{6} = \\frac{10}{3}\n$$\nThe value of the inversion factor is an exact rational number.",
            "answer": "$$\n\\boxed{\\frac{10}{3}}\n$$"
        },
        {
            "introduction": "Having established the importance of the supra-graph formalism, the next step is to gain hands-on experience in calculating network properties within this structure. This problem  provides practice in computing betweenness centrality, a path-based measure, on a multiplex supra-graph. The solution requires carefully enumerating shortest paths that may travel both within and between layers, reinforcing the concept of distance in multilayer systems.",
            "id": "4131652",
            "problem": "Consider a multiplex network with two layers, labeled $\\alpha \\in \\{1,2\\}$, over a physical node set $V_{p} = \\{1,2,3\\}$. The supra-graph has vertex set $U = \\{(i,\\alpha) : i \\in V_{p}, \\alpha \\in \\{1,2\\}\\}$ and undirected edges defined as follows. Intra-layer edges in layer $\\alpha=1$ are $E^{(1)} = \\{(1,2),(2,3)\\}$, and intra-layer edges in layer $\\alpha=2$ are $E^{(2)} = \\{(1,2),(2,3),(1,3)\\}$. Interlayer coupling edges connect replicas of the same physical node: for each $i \\in \\{1,2,3\\}$, there is an undirected interlayer edge between $(i,1)$ and $(i,2)$. All edges have unit weight $1$. Treat the supra-graph as undirected.\n\nLet $v = (2,1)$ denote the supra-node corresponding to physical node $2$ in layer $1$. Using the standard definition of node betweenness centrality for undirected graphs, compute the raw betweenness centrality of $v$ on the supra-graph, defined by\n$$\nC_{B}(v) \\;=\\; \\sum_{\\substack{s,t \\in U \\\\ s \\neq t,\\, s \\neq v,\\, t \\neq v,\\, s<t}} \\frac{\\sigma_{st}(v)}{\\sigma_{st}},\n$$\nwhere $\\sigma_{st}$ is the total number of geodesic (shortest) paths between $s$ and $t$ in the supra-graph, $\\sigma_{st}(v)$ is the number of those geodesic paths that pass through $v$, and $s<t$ indicates that unordered pairs are counted once.\n\nIn your derivation, begin from core definitions of multiplex networks, supra-graph construction, geodesic paths, and betweenness centrality, and reason from first principles to enumerate geodesics and their counts. In addition, explain within your solution how the presence of interlayer edges changes geodesic counts relative to a single-layer projection $G^{(1)} \\cup G^{(2)}$ over physical nodes.\n\nProvide the final value of $C_{B}(v)$ as an exact number. No rounding is required, and no physical units are involved.",
            "solution": "The problem requires the computation of the betweenness centrality of a specific node in a two-layer multiplex network. The solution proceeds in three stages: first, a formal construction of the supra-graph representing the multiplex network; second, a systematic enumeration of geodesic paths to calculate the betweenness centrality; and third, an analysis of the role of interlayer edges in shaping network paths.\n\n**1. Supra-graph Construction**\nThe multiplex network consists of two layers, $\\alpha \\in \\{1,2\\}$, defined over a set of $3$ physical nodes, $V_p = \\{1,2,3\\}$. The supra-graph $G_S$ is constructed from this specification.\n\nThe vertex set of the supra-graph, denoted by $U$, is the set of all node-layer pairs. With $3$ physical nodes and $2$ layers, we have $|U| = 3 \\times 2 = 6$ vertices. Let us denote a vertex as $(i,\\alpha)$, where $i \\in V_p$ is the physical node and $\\alpha$ is the layer. The vertices are:\n$U = \\{(1,1), (2,1), (3,1), (1,2), (2,2), (3,2)\\}$.\n\nThe edge set of the supra-graph is the union of intra-layer and inter-layer edges. All edges are undirected and have a unit weight of $1$.\nThe intra-layer edges for layer $\\alpha=1$ are given by $E^{(1)} = \\{(1,2), (2,3)\\}$. In the supra-graph, these correspond to the edges $\\{((1,1),(2,1)), ((2,1),(3,1))\\}$. This layer forms a path graph.\nThe intra-layer edges for layer $\\alpha=2$ are given by $E^{(2)} = \\{(1,2), (2,3), (1,3)\\}$. In the supra-graph, these correspond to the edges $\\{((1,2),(2,2)), ((2,2),(3,2)), ((1,2),(3,2))\\}$. This layer forms a complete graph (a triangle).\nThe interlayer edges connect replicas of the same physical node. For each $i \\in \\{1,2,3\\}$, there is an edge between $(i,1)$ and $(i,2)$. This gives the edge set $\\{((1,1),(1,2)), ((2,1),(2,2)), ((3,1),(3,2))\\}$.\n\n**2. Betweenness Centrality Calculation**\nWe are asked to compute the betweenness centrality $C_B(v)$ for the node $v=(2,1)$. The provided formula is:\n$$C_{B}(v) = \\sum_{\\substack{s,t \\in U \\\\ s \\neq t,\\, s \\neq v,\\, t \\neq v,\\, s<t}} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$$\nwhere $\\sigma_{st}$ is the number of geodesic (shortest) paths between nodes $s$ and $t$, and $\\sigma_{st}(v)$ is the number of those geodesics that pass through $v=(2,1)$. The condition $s<t$ signifies that we sum over all unordered pairs of distinct nodes, neither of which is $v$.\n\nThe set of nodes other than $v=(2,1)$ is $U' = U \\setminus \\{(2,1)\\} = \\{(1,1), (3,1), (1,2), (2,2), (3,2)\\}$.\nThere are $\\binom{5}{2} = 10$ unique pairs of nodes $(s, t)$ from $U'$. We will analyze each pair to determine its contribution to the sum. The distance between two nodes, $d(s,t)$, is the length of a geodesic path.\n\n1.  **Pair $s=(1,1), t=(3,1)$**:\n    - Path 1: $(1,1) \\to (2,1) \\to (3,1)$. The length is $2$. This path passes through $v=(2,1)$.\n    - An alternative path through the other layer would be $(1,1) \\to (1,2) \\to (3,2) \\to (3,1)$. Its length is $1+1+1=3$.\n    - Thus, the geodesic path is unique. $d(s,t)=2$, $\\sigma_{st}=1$.\n    - The number of geodesics passing through $v$ is $\\sigma_{st}(v)=1$.\n    - Contribution: $\\frac{1}{1} = 1$.\n\n2.  **Pair $s=(1,1), t=(1,2)$**:\n    - These nodes are directly connected by an interlayer edge.\n    - $d(s,t)=1$. A geodesic of length $1$ cannot pass through any intermediate node.\n    - Contribution: $\\frac{0}{\\sigma_{st}} = 0$.\n\n3.  **Pair $s=(1,1), t=(2,2)$**:\n    - Path 1: $(1,1) \\to (2,1) \\to (2,2)$. The length is $1+1=2$. This path passes through $v=(2,1)$.\n    - Path 2: $(1,1) \\to (1,2) \\to (2,2)$. The length is $1+1=2$. This path does not pass through $v$.\n    - Both paths are geodesics. $d(s,t)=2$, $\\sigma_{st}=2$.\n    - The number of geodesics passing through $v$ is $\\sigma_{st}(v)=1$.\n    - Contribution: $\\frac{1}{2}$.\n\n4.  **Pair $s=(1,1), t=(3,2)$**:\n    - Path 1: $(1,1) \\to (1,2) \\to (3,2)$. The length is $1+1=2$. This path does not pass through $v$.\n    - Alternative paths, such as $(1,1) \\to (2,1) \\to (2,2) \\to (3,2)$, have length $3$.\n    - The geodesic path is unique. $d(s,t)=2$, $\\sigma_{st}=1$.\n    - The number of geodesics passing through $v$ is $\\sigma_{st}(v)=0$.\n    - Contribution: $\\frac{0}{1} = 0$.\n\n5.  **Pair $s=(3,1), t=(1,2)$**:\n    - Path 1: $(3,1) \\to (3,2) \\to (1,2)$. The length is $1+1=2$. This path does not pass through $v$.\n    - Alternative paths, such as $(3,1) \\to (2,1) \\to (1,1) \\to (1,2)$, have length $3$.\n    - The geodesic path is unique. $d(s,t)=2$, $\\sigma_{st}=1$.\n    - The number of geodesics passing through $v$ is $\\sigma_{st}(v)=0$.\n    - Contribution: $\\frac{0}{1} = 0$.\n\n6.  **Pair $s=(3,1), t=(2,2)$**:\n    - Path 1: $(3,1) \\to (2,1) \\to (2,2)$. The length is $1+1=2$. This path passes through $v$.\n    - Path 2: $(3,1) \\to (3,2) \\to (2,2)$. The length is $1+1=2$. This path does not pass through $v$.\n    - Both paths are geodesics. $d(s,t)=2$, $\\sigma_{st}=2$.\n    - The number of geodesics passing through $v$ is $\\sigma_{st}(v)=1$.\n    - Contribution: $\\frac{1}{2}$.\n\n7.  **Pair $s=(3,1), t=(3,2)$**:\n    - These nodes are directly connected by an interlayer edge. $d(s,t)=1$.\n    - Contribution: $0$.\n\n8.  **Pair $s=(1,2), t=(2,2)$**:\n    - These nodes are directly connected by an intra-layer edge in layer $2$. $d(s,t)=1$.\n    - Contribution: $0$.\n\n9.  **Pair $s=(1,2), t=(3,2)$**:\n    - These nodes are directly connected by an intra-layer edge in layer $2$. $d(s,t)=1$.\n    - Contribution: $0$.\n\n10. **Pair $s=(2,2), t=(3,2)$**:\n    - These nodes are directly connected by an intra-layer edge in layer $2$. $d(s,t)=1$.\n    - Contribution: $0$.\n\nThe total betweenness centrality is the sum of these contributions:\n$$C_B((2,1)) = 1 + 0 + \\frac{1}{2} + 0 + 0 + \\frac{1}{2} + 0 + 0 + 0 + 0 = 2$$\n\n**3. Effect of Interlayer Edges**\nThe problem asks for an explanation of how interlayer edges affect geodesic counts relative to a single-layer projection. The single-layer projection $G_{proj} = G^{(1)} \\cup G^{(2)}$ is a graph on the physical nodes $V_p = \\{1,2,3\\}$ with an edge set $E_{proj} = E^{(1)} \\cup E^{(2)} = \\{(1,2), (2,3)\\} \\cup \\{(1,2), (2,3), (1,3)\\} = \\{(1,2), (2,3), (1,3)\\}$. This projected graph is the complete graph $K_3$.\n\nThe role of interlayer edges in the supra-graph is fundamentally different from the simplification offered by the projection.\nFirst, the interlayer edges are what make the supra-graph connected. Without them, the graph would consist of two disconnected components (layer $1$ and layer $2$), and no path would exist between a node $(i,\\alpha)$ and a node $(j,\\beta)$ if $\\alpha \\neq \\beta$. The number of geodesics $\\sigma_{st}$ would be $0$ for any such pair. The interlayer edges create paths between layers, allowing for communication and influence to spread across the entire multiplex system. For example, for the pair $s=(1,1), t=(2,2)$, the interlayer edges enable two distinct geodesic paths of length $2$, where $\\sigma_{st}$ would otherwise be $0$.\n\nSecond, for nodes within the same layer, interlayer edges provide alternative routes that pass through other layers. These new paths may be shorter, longer, or of equal length to the existing intra-layer paths. If these new paths are also geodesics, they increase the total count $\\sigma_{st}$. If they are shorter than any intra-layer path, they redefine the geodesic distance $d(s,t)$ and become the new sole geodesics. In the specific problem given, for path $(1,1) \\to (3,1)$, the intra-layer path in layer $1$ has length $2$. The alternative path via layer $2$, $(1,1) \\to (1,2) \\to (3,2) \\to (3,1)$, has length $3$. Thus, the interlayer edges do not provide a shorter path or an alternative geodesic in this case.\n\nThe single-layer projection $G_{proj}$ is a lossy representation. It aggregates all connections onto a single set of nodes, ignoring the layer structure. This leads to a different topology and, consequently, different path information. For instance, in $G_{proj}$, the edge $(1,3)$ exists, so the distance $d_{proj}(1,3)=1$ and the geodesic count $\\sigma_{1,3}=1$. In the supra-graph, however, the shortest path between the corresponding nodes in layer $1$, i.e., from $(1,1)$ to $(3,1)$, has a length of $2$. The direct connection $(1,3)$ is only available in layer $2$. To use it, a path starting at $(1,1)$ must first switch to layer $2$ (cost $1$), traverse the edge (cost $1$), and switch back (cost $1$), for a total path length of at least $3$. The supra-graph formalism correctly captures the \"cost\" of traversing layers, a critical detail that is lost in the simple projection. The interlayer edges, with their unit weight, are the mechanism that quantifies this cost.",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "The structural distinctions highlighted so far have profound consequences for dynamic processes unfolding on networks. This final practice  moves from static analysis to the critical topic of system resilience through a computational model of cascading failures. By comparing a cascade on an aggregated graph with one on an interdependent network, you will see how dependencies between layers can create unique vulnerabilities that lead to catastrophic collapse, a phenomenon entirely missed by simpler models.",
            "id": "4131618",
            "problem": "You are given a two-layer multiplex network on a common node set with interdependence. Let the node set be $V = \\{0,1,\\dots,n-1\\}$ and let the two layers be represented by undirected, unweighted, symmetric adjacency matrices $A \\in \\{0,1\\}^{n \\times n}$ and $B \\in \\{0,1\\}^{n \\times n}$, with zero diagonal. Consider two distinct propagation rules:\n\n- Interdependent cascade: The layers are fully interdependent via identity dependencies $D(v)=v$ for all $v \\in V$. Starting from an initial failure set $F_0 \\subseteq V$, define the active set $S_0 = V \\setminus F_0$. For iteration $t \\in \\mathbb{N}$, given $S_t$, compute in each layer $\\ell \\in \\{1,2\\}$ the largest connected component $C_\\ell(S_t)$ of the subgraph induced by $S_t$ in layer $\\ell$ (computed in the standard graph-theoretic sense with edges from the respective adjacency matrix). In case multiple connected components have the same maximum size, select the component whose set of node indices has the smallest lexicographic order when written as an increasing sequence. Define\n$$\nS_{t+1} \\;=\\; S_t \\;\\cap\\; C_1(S_t) \\;\\cap\\; C_2(S_t).\n$$\nIterate until convergence, i.e., until $S_{t+1}=S_t$, and denote the final surviving set by $S_\\ast$. The surviving fraction under interdependence is $|S_\\ast|/|V|$.\n\n- Multiplex-connectivity-only cascade: There is no interdependence. Define the union (logical disjunction) adjacency matrix $U$ by $U_{ij} = \\max(A_{ij}, B_{ij})$ for all $i,j \\in V$, representing the aggregated connectivity across layers. Starting from $S_0 = V \\setminus F_0$, define\n$$\nS_{t+1} \\;=\\; S_t \\;\\cap\\; C_U(S_t),\n$$\nwhere $C_U(S_t)$ is the largest connected component of the subgraph induced by $S_t$ in the union graph (with the same tie-breaking rule as above). Iterate until convergence and denote the final surviving set by $S^\\mathrm{union}_\\ast$. The surviving fraction under multiplex-connectivity-only is $|S^\\mathrm{union}_\\ast|/|V|$.\n\nYour task is to implement both dynamics and compute the final surviving fractions for each of the following test cases. All graphs are undirected, and edges are specified as unordered pairs. In all cases, node labels are integers from $0$ to $n-1$.\n\nTest case $1$ (general asymmetric robustness under interdependence versus multiplex connectivity):\n- $n = 6$.\n- Layer $A$ edges form a $6$-cycle: $(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)$.\n- Layer $B$ edges form a star centered at $0$: $(0,1),(0,2),(0,3),(0,4),(0,5)$.\n- Initial failures $F_0 = \\{0\\}$.\n\nTest case $2$ (boundary case with no initial failures and identical layers):\n- $n = 5$.\n- Layer $A$ edges: $(0,1),(1,2),(3,4)$.\n- Layer $B$ edges: $(0,1),(1,2),(3,4)$.\n- Initial failures $F_0 = \\emptyset$.\n\nTest case $3$ (bridge removal causing collapse under interdependence but not under multiplex connectivity):\n- $n = 5$.\n- Layer $A$ edges: $(0,1),(1,2)$.\n- Layer $B$ edges: $(2,3),(3,4)$.\n- Initial failures $F_0 = \\{2\\}$.\n\nScientific realism constraints and fundamental base:\n- Work from the formal definitions of connected components in undirected graphs, the construction of induced subgraphs, and iterative monotone dynamical processes on sets.\n- For interdependence, enforce the identity dependency $D(v)=v$, which is a commonly studied rule in interdependent networks. For multiplex-connectivity-only, enforce the use of the union graph without cross-layer dependency.\n\nRequired output:\n- For each test case, compute two floating-point numbers: the final surviving fraction under interdependence and under multiplex-connectivity-only, in that order.\n- Aggregate the results for all three test cases into a single list of lists. The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[[x_{11},x_{12}],[x_{21},x_{22}],[x_{31},x_{32}]]$, where each $x_{ij}$ is a floating-point number rounded to exactly $6$ decimal places.\n\nThere are no physical units or angles in this problem. All outputs must be pure numbers. The only permitted rounding is to exactly $6$ decimal places in the final printed line.",
            "solution": "The user has provided a well-defined computational problem from the field of network science. The task is to simulate two different types of cascading failures on a two-layer multiplex network and report the final fraction of surviving nodes for three specific test cases.\n\nThe problem is valid as it is scientifically grounded in established network theory, mathematically well-posed with unambiguous rules ensuring a unique solution, and objectively defined. I will proceed with a full solution.\n\nThe core of the solution involves implementing two iterative algorithms, both of which rely on a subroutine to find the largest connected component (LCC) of a graph.\n\n**Principle-Based Design**\n\n1.  **Graph Representation**: The network layers are defined by adjacency matrices $A$ and $B$. These are naturally represented by $n \\times n$ NumPy arrays, where an entry $(i, j)$ is $1$ if an edge exists between nodes $i$ and $j$, and $0$ otherwise. Given the edge lists, we construct these symmetric matrices by setting both $A_{ij}$ and $A_{ji}$ to $1$ for each edge $(i,j)$ in the list for layer $A$ (and similarly for $B$). The set of active nodes at each step, $S_t$, will be managed using Python's `set` data structure for efficient membership testing and intersection operations.\n\n2.  **Finding the Largest Connected Component (LCC)**: A crucial subroutine is needed to find the LCC of a subgraph induced by a set of active nodes $S$. This is designated as `get_lcc(adj_matrix, active_nodes)`.\n    -   The algorithm systematically finds all connected components within the subgraph defined by `active_nodes` on the graph `adj_matrix`.\n    -   A Breadth-First Search (BFS) is a suitable traversal method. We iterate through each node in `active_nodes`. If a node has not yet been visited, we start a BFS from it to find its entire connected component. All nodes in this component are marked as visited.\n    -   This process is repeated until all nodes in `active_nodes` have been visited, yielding a list of all connected components.\n    -   Once all components are found, we identify the LCC based on the rules. First, we find the maximum component size. Then, we collect all components that have this maximum size.\n    -   If there is only one such component, it is the LCC.\n    -   If there is a tie, the problem specifies a lexicographical tie-breaking rule. Each candidate component (a set of node indices) is converted to a sorted list of integers. These lists are then lexicographically compared, and the one that is \"smallest\" is chosen. For example, the component $[0, 4]$ would be chosen over $[1, 2]$ because the former is lexicographically smaller. The function returns the set of nodes belonging to the LCC.\n\n3.  **Interdependent Cascade Simulation**: This process models failures due to loss of support from another layer.\n    -   The simulation starts with the initial set of active nodes $S_0 = V \\setminus F_0$.\n    -   The process is iterative. At each step $t$, we find the LCC of the subgraph induced by the current active set $S_t$ in layer $A$, denoted $C_1(S_t)$, and in layer $B$, denoted $C_2(S_t)$.\n    -   The set of nodes for the next iteration, $S_{t+1}$, consists of only those nodes that are part of the LCC in *both* layers. This is a strict requirement captured by the set intersection: $S_{t+1} = C_1(S_t) \\cap C_2(S_t)$. The problem statement includes an intersection with $S_t$ ($S_{t+1} = S_t \\cap C_1(S_t) \\cap C_2(S_t)$), which is redundant because $C_1(S_t)$ and $C_2(S_t)$ are by definition subsets of $S_t$.\n    -   The iteration continues until the set of active nodes no longer changes, i.e., $S_{t+1} = S_t$. This is the fixed point, or the final surviving set $S_\\ast$.\n    -   The final surviving fraction is calculated as $|S_\\ast| / |V|$.\n\n4.  **Multiplex-Connectivity-Only Cascade Simulation**: This process models failures based on the aggregated connectivity of the network, ignoring inter-layer dependencies.\n    -   First, we create the union graph adjacency matrix $U$ by taking the element-wise maximum of $A$ and $B$, i.e., $U_{ij} = \\max(A_{ij}, B_{ij})$. An edge exists in $U$ if it exists in either $A$ or $B$ (or both).\n    -   The simulation starts with $S_0 = V \\setminus F_0$.\n    -   At each step $t$, we find the LCC of the subgraph induced by $S_t$ on the union graph $U$, denoted $C_U(S_t)$.\n    -   The next set of active nodes is simply this LCC: $S_{t+1} = C_U(S_t)$. (Again, the intersection with $S_t$ in the problem's formula is redundant).\n    -   The iteration continues until convergence ($S_{t+1}=S_t$), yielding the final set $S^\\mathrm{union}_\\ast$.\n    -   The final surviving fraction is $|S^\\mathrm{union}_\\ast| / |V|$.\n\n5.  **Final Output Formatting**: The program will execute these simulations for each of the three test cases. The results for each case (a pair of floating-point fractions) are collected. Finally, the collected list of lists is formatted into a precise string representation `[[val11,val12],[val21,val22],...]`, where each value is rounded to exactly $6$ decimal places. This requires custom string construction to avoid extra spaces and ensure correct rounding.\n\nThe implementation will follow this structured, principle-based design to ensure correctness and adherence to the problem specification.",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef get_lcc(adj_matrix, active_nodes):\n    \"\"\"\n    Finds the largest connected component (LCC) in the subgraph induced by active_nodes.\n    \n    Args:\n        adj_matrix (np.ndarray): The adjacency matrix of the graph.\n        active_nodes (set): A set of node indices that are currently active.\n\n    Returns:\n        set: The set of nodes in the LCC. Returns an empty set if no nodes are active.\n    \"\"\"\n    if not active_nodes:\n        return set()\n\n    visited = set()\n    components = []\n    \n    # Iterate through all potentially active nodes to find all components\n    sorted_active_nodes = sorted(list(active_nodes))\n\n    for node in sorted_active_nodes:\n        if node in active_nodes and node not in visited:\n            # Start a traversal (BFS) to find a new component\n            current_component = set()\n            q = deque([node])\n            visited.add(node)\n            \n            while q:\n                u = q.popleft()\n                current_component.add(u)\n                \n                # Check neighbors of u\n                # Using np.where is efficient for sparse rows but enumerate is fine for small n\n                neighbors = np.where(adj_matrix[u] == 1)[0]\n                for v in neighbors:\n                    if v in active_nodes and v not in visited:\n                        visited.add(v)\n                        q.append(v)\n            \n            components.append(current_component)\n\n    if not components:\n        return set()\n\n    # Find max component size\n    max_size = 0\n    for comp in components:\n        if len(comp) > max_size:\n            max_size = len(comp)\n            \n    # Collect all components with max size\n    lcc_candidates = [comp for comp in components if len(comp) == max_size]\n    \n    # Apply tie-breaking rule if necessary\n    if len(lcc_candidates) == 1:\n        return lcc_candidates[0]\n    else:\n        # Sort nodes within each candidate component and then sort the components lexicographically\n        sorted_candidates = [sorted(list(c)) for c in lcc_candidates]\n        sorted_candidates.sort()\n        return set(sorted_candidates[0])\n\ndef run_interdependent_cascade(n, A, B, F0):\n    \"\"\"\n    Simulates the interdependent cascade dynamics.\n    \"\"\"\n    S = set(range(n)) - set(F0)\n    \n    while True:\n        S_prev = S.copy()\n        \n        C1 = get_lcc(A, S)\n        C2 = get_lcc(B, S)\n        \n        S = C1.intersection(C2)\n        \n        if S == S_prev:\n            break\n            \n    return len(S) / n if n > 0 else 0.0\n\ndef run_multiplex_cascade(n, A, B, F0):\n    \"\"\"\n    Simulates the multiplex-connectivity-only cascade dynamics.\n    \"\"\"\n    U = np.maximum(A, B)\n    S = set(range(n)) - set(F0)\n    \n    while True:\n        S_prev = S.copy()\n        \n        CU = get_lcc(U, S)\n        S = CU\n        \n        if S == S_prev:\n            break\n            \n    return len(S) / n if n > 0 else 0.0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A_edges\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)],\n            \"B_edges\": [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)],\n            \"F0\": {0}\n        },\n        {\n            \"n\": 5,\n            \"A_edges\": [(0, 1), (1, 2), (3, 4)],\n            \"B_edges\": [(0, 1), (1, 2), (3, 4)],\n            \"F0\": set()\n        },\n        {\n            \"n\": 5,\n            \"A_edges\": [(0, 1), (1, 2)],\n            \"B_edges\": [(2, 3), (3, 4)],\n            \"F0\": {2}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        A_edges = case[\"A_edges\"]\n        B_edges = case[\"B_edges\"]\n        F0 = case[\"F0\"]\n\n        # Build adjacency matrices\n        A = np.zeros((n, n), dtype=int)\n        for u, v in A_edges:\n            A[u, v] = A[v, u] = 1\n        \n        B = np.zeros((n, n), dtype=int)\n        for u, v in B_edges:\n            B[u, v] = B[v, u] = 1\n\n        # Run simulations\n        frac_interdependent = run_interdependent_cascade(n, A, B, F0)\n        frac_multiplex = run_multiplex_cascade(n, A, B, F0)\n        \n        results.append([frac_interdependent, frac_multiplex])\n\n    # Format output string\n    outer_parts = []\n    for res_pair in results:\n        inner_parts = [f\"{val:.6f}\" for val in res_pair]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_string = f\"[{','.join(outer_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}