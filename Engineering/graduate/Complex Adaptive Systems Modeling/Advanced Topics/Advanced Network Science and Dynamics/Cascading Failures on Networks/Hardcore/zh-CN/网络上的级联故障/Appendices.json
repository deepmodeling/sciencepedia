{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导您实现一个基于物理的电力系统级联失效模型。您将使用直流潮流近似法，这是一种在电力系统分析中广泛使用的基本工具，来计算输电线路上的功率流，并模拟因单条线路过载移除而引发的一系列连锁反应。通过这个实践，您将掌握模拟真实世界基础设施中流量重分配导致级联失效的核心技术。",
            "id": "4266617",
            "problem": "考虑一个由 $N$ 个节点和 $E$ 条无向线路组成的网络，每条线路连接一对节点。该网络使用线性化直流（DC）潮流近似进行建模。设净注入功率向量为 $P \\in \\mathbb{R}^N$，其中对于节点 $i$ 上的发电，$P_i$ 为正，对于负荷，$P_i$ 为负。设每条线路 $e$ 具有正电纳 $b_e$ 和热容量限制 $C_e > 0$。直流模型假设线路上 $e$ 的有功功率潮流 $f_e$ 与其两端电压相角之差成正比，并且节点功率平衡由基尔霍夫电流定律强制执行。您将计算潮流，检测过载，按特定规则移除过载线路，并模拟由此产生的连锁故障，直到达到稳定状态。\n\n建模基本原理：\n- 基尔霍夫电流定律：流入节点 $i$ 的潮流代数和等于净注入功率 $P_i$。\n- 线性化直流潮流关系：对于任意线路 $e = (u,v)$，有功功率潮流满足 $f_e = b_e \\left(\\theta_u - \\theta_v\\right)$，其中 $\\theta_i$ 是节点 $i$ 的电压相角。\n- 基于关联矩阵的公式：对于从节点 $u$ 指向节点 $v$ 的线路 $e=(u,v)$，定义一个有向关联矩阵 $A \\in \\mathbb{R}^{E \\times N}$，其中 $A_{e,u} = +1$ 和 $A_{e,v} = -1$（其他位置为零）。这样，基尔霍夫电流定律变为 $A^\\top f = P$，线性化直流关系变为 $f = \\operatorname{diag}(b) \\, A \\, \\theta$，从而在每个连通分量上，在固定一个参考相角后，得到加权拉普拉斯系统 $A^\\top \\operatorname{diag}(b) A \\, \\theta = P$。除非每个分量固定一个参考（平衡）相角，否则加权拉普拉斯矩阵是奇异的。\n\n需实现的连锁过程：\n1. 通过在每个连通分量上求解 $A^\\top \\operatorname{diag}(b) A \\, \\theta = P$ 来计算线路潮流 $f_e$。其中平衡节点选择为该连通分量中索引最小的节点，并将其相角固定为零。当一个连通分量只有一个节点时，该分量内没有潮流。\n2. 为每条活动线路 $e$ 定义利用率 $r_e = \\left|f_e\\right| / C_e$。\n3. 如果存在任何 $r_e > 1$ 的线路，则精确移除一条线路：$r_e$ 值最大的那条线路。如果多条线路的 $r_e$ 值并列最大，则移除线路索引最小的那一条。重新计算连通分量，并从步骤 1 开始重复。\n4. 当所有剩余线路都满足 $r_e \\le 1$ 或没有线路剩下时，终止过程。最终状态被认为是稳定的。\n\n处理孤岛化：\n- 移除线路可能会将网络断开成多个连通分量（孤岛）。在每个孤岛中，将该孤岛内索引最小的节点定义为平衡节点。平衡节点通过固定参考相角来隐式地调整其净注入功率，从而吸收该孤岛中的任何总功率不平衡，这为其他相角提供了一个可解的简化拉普拉斯系统。这种方法纯粹是数学上的，不限制平衡节点的容量。\n\n您的程序必须精确实现此连锁模拟，并为每个测试用例返回一个三元组 $[k, R, M]$，其中：\n- $k$ 是达到最终稳定状态前移除的线路的整数数量，\n- $R$ 是所有剩余线路的最终最大利用率，定义为 $R = \\max_e r_e$，其中 $r_e = \\left|f_e\\right| / C_e$，表示为四舍五入到六位小数的实数，\n- $M$ 是最终网络中连通分量（包括孤立节点）的整数数量。\n\n请使用以下参数值的测试套件。在所有情况下，节点由从 $0$ 开始的整数标记，每条线路通过其 $(u,v)$ 端点、电纳 $b_e$ 和容量 $C_e$ 指定，矩阵 $A$ 的方向是从第一个端点 $u$ 到第二个端点 $v$。\n\n测试用例 1（带弦的环形网络）：\n- $N = 4$\n- 线路：$e_0 = (0,1,b_0=5,C_0=8)$，$e_1 = (1,2,b_1=5,C_1=8)$，$e_2 = (2,3,b_2=5,C_2=8)$，$e_3 = (3,0,b_3=5,C_3=8)$，$e_4 = (1,3,b_4=5,C_4=6)$\n- 净注入功率：$P = [3,-1,-2,0]$\n\n测试用例 2（一个极限紧张的星形网络）：\n- $N = 5$\n- 线路：$e_0 = (0,1,b_0=4,C_0=4)$，$e_1 = (0,2,b_1=4,C_1=4)$，$e_2 = (0,3,b_2=4,C_2=4)$，$e_3 = (0,4,b_3=4,C_3=0.5)$\n- 净注入功率：$P = [4,-1,-1,-1,-1]$\n\n测试用例 3（三角形网络，容量充裕）：\n- $N = 3$\n- 线路：$e_0 = (0,1,b_0=10,C_0=100)$，$e_1 = (1,2,b_1=10,C_1=100)$，$e_2 = (0,2,b_2=10,C_2=100)$\n- 净注入功率：$P = [1,-0.5,-0.5]$\n\n测试用例 4（处于精确极限的链式网络）：\n- $N = 3$\n- 线路：$e_0 = (0,1,b_0=10,C_0=5)$，$e_1 = (1,2,b_1=10,C_1=5)$\n- 净注入功率：$P = [5,0,-5]$\n\n测试用例 5（过载情况需打破平局的链式网络）：\n- $N = 4$\n- 线路：$e_0 = (0,1,b_0=10,C_0=3)$，$e_1 = (1,2,b_1=10,C_1=2)$，$e_2 = (2,3,b_2=10,C_2=100)$\n- 净注入功率：$P = [6,-2,-2,-2]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果为一个子列表 $[k,R,M]$。例如，输出必须类似于 $[[k_1,R_1,M_1],[k_2,R_2,M_2],\\dots]$，其中 $R_i$ 四舍五入到六位小数。",
            "solution": "该问题要求模拟电力网络中的连锁故障，该网络使用线性化直流（DC）潮流近似进行建模。模拟以离散步骤进行，在每一步中，计算潮流，并移除最过载的输电线路，这可能导致网络分裂（孤岛化）和潮流的进一步重新分布，直到达到稳定状态。\n\n模拟的核心在于求解网络中每个连通分量的直流潮流方程。控制方程是一个线性系统，源自基尔霍夫电流定律和有功功率的类欧姆定律关系。\n\n设网络有 $N$ 个节点和 $E$ 条线路。我们定义一个有向关联矩阵 $A \\in \\mathbb{R}^{E \\times N}$，其中对于从节点 $u$ 指向节点 $v$ 的线路 $e$，有 $A_{e,u} = 1$ 和 $A_{e,v} = -1$，该行所有其他条目为 $0$。设 $\\theta \\in \\mathbb{R}^N$ 为节点电压相角向量，$P \\in \\mathbb{R}^N$ 为净注入功率向量，$b \\in \\mathbb{R}^E$ 为线路电纳向量，$f \\in \\mathbb{R}^E$ 为线路潮流向量。\n\n该模型由两个基本关系定义：\n1.  一条电纳为 $b_e$ 的线路 $e=(u,v)$ 上的潮流 $f_e$ 由 $f_e = b_e(\\theta_u - \\theta_v)$ 给出。以矩阵形式表示为 $f = \\mathrm{diag}(b) A \\theta$。\n2.  流入或流出任一节点的潮流总和必须与该节点的净注入功率相平衡。这是基尔霍夫电流定律（KCL），表示为 $A^\\top f = P$。\n\n将第一个方程代入第二个方程，得到相角的系统方程：\n$$\nA^\\top \\left( \\mathrm{diag}(b) A \\theta \\right) = P\n$$\n$$\n(A^\\top \\mathrm{diag}(b) A) \\theta = P\n$$\n这通常写作 $L \\theta = P$，其中 $L = A^\\top \\mathrm{diag}(b) A$ 是网络的加权拉普拉斯矩阵。任何图的拉普拉斯矩阵都是奇异的，这反映了只有相角*差*决定潮流，而非其绝对值的物理现实。为了获得唯一解，我们必须建立一个参考。\n\n问题指定了一个处理这种奇异性和网络潜在分裂的过程：\n1.  **识别连通分量**：使用图遍历算法（如广度优先搜索（BFS）或深度优先搜索（DFS））将网络划分为其连通分量。每个分量被视为一个独立的子问题。\n\n2.  **对每个分量进行求解**：对于每个具有节点集 $\\mathcal{V}_\\mathcal{C}$ 和线路集 $\\mathcal{E}_\\mathcal{C}$ 的连通分量 $\\mathcal{C}$：\n    - 如果 $|\\mathcal{V}_\\mathcal{C}| \\le 1$，则该分量内没有线路，因此不计算潮流。\n    - 如果 $|\\mathcal{V}_\\mathcal{C}| > 1$，必须选择一个参考或“平衡”节点。问题规定选择 $\\mathcal{V}_\\mathcal{C}$ 中索引最小的节点作为平衡节点 $s$，并将其相角固定为 $\\theta_s = 0$。\n    - 令 $\\mathcal{V'}_\\mathcal{C} = \\mathcal{V}_\\mathcal{C} \\setminus \\{s\\}$ 为分量中非平衡节点的集合。我们构建一个简化的线性系统 $L' \\theta' = P'$ 来求解非平衡节点的相角 $\\theta'$。\n    - $L'$ 是通过移除与平衡节点 $s$ 对应的行和列而从分量的拉普拉斯矩阵 $L_\\mathcal{C}$ 中获得的子矩阵。对于一个连通分量，这个简化的矩阵 $L'$ 是可逆的。\n    - $P'$ 是与非平衡节点 $\\mathcal{V'}_\\mathcal{C}$ 对应的功率注入向量 $P$ 的子向量。分量中的功率不平衡 $\\sum_{i \\in \\mathcal{V}_\\mathcal{C}} P_i$ 被平衡节点隐式地吸收了。\n    - 通过求解线性系统找到非平衡节点的相角：$\\theta' = (L')^{-1} P'$。\n    - 在确定了该分量所有节点相角 $\\theta$（包括 $\\theta_s=0$）之后，计算该分量内每条线路 $e=(u,v)$ 上的潮流 $f_e$：$f_e = b_e(\\theta_u - \\theta_v)$。\n\n整体模拟按循环进行：\n\n**第一步：初始化**\n- 模拟从完整的线路集合开始。移除的线路数 $k$ 初始化为 $0$。\n\n**第二步：迭代连锁过程**\n模拟进入一个循环，直到没有线路过载为止。\n- **a) 潮流计算**：对于当前的网络拓扑，执行上述程序（分量识别和按分量求解线性系统）来计算所有线路潮流 $f_e$。\n- **b) 过载评估**：对于每条容量为 $C_e$ 的线路 $e$，计算利用率：$r_e = |f_e| / C_e$。识别出最大比率 $r_{\\max} = \\max_e r_e$。如果没有剩余线路，则 $r_{\\max}$ 取为 $0$。\n- **c) 稳定性检查**：如果 $r_{\\max} \\le 1$，网络是稳定的。模拟终止。\n- **d) 线路移除**：如果 $r_{\\max} > 1$，网络不稳定。必须移除一条线路。要移除的线路 $e^*$ 是具有最大利用率 $r_{e^*} = r_{\\max}$ 的那条。如果存在平局，则选择原始索引最小的线路。从网络中移除线路 $e^*$，将 $k$ 增加 $1$，然后从第二步 a) 重复循环。\n\n**第三步：最终输出**\n终止时，最终状态由以下特征描述：\n- $k$：连锁过程中移除的线路总数。\n- $R$：最终的最大利用率 $r_{\\max}$，四舍五入到六位小数。\n- $M$：最终稳定网络中的连通分量数量。\n\n这个综合算法确定性地模拟了指定的连锁故障过程。它的实现需要用于寻找连通分量的稳健图算法以及用于求解矩阵方程的数值线性代数程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_components(num_nodes, active_lines_indices, lines_def):\n    \"\"\"Finds connected components in the graph using BFS.\"\"\"\n    if num_nodes == 0:\n        return 0, []\n        \n    adj = [[] for _ in range(num_nodes)]\n    for line_idx in active_lines_indices:\n        u, v, _, _, _ = lines_def[line_idx]\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * num_nodes\n    components = []\n    for i in range(num_nodes):\n        if not visited[i]:\n            component_nodes = set()\n            q = [i]\n            visited[i] = True\n            head = 0\n            while head  len(q):\n                u = q[head]\n                head += 1\n                component_nodes.add(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(sorted(list(component_nodes)))\n    return len(components), components\n\ndef solve_cascade(num_nodes, lines, power_injections):\n    \"\"\"\n    Simulates the cascading failure process.\n    \"\"\"\n    lines_def = [(u, v, b, c, idx) for idx, (u, v, b, c) in enumerate(lines)]\n    active_lines_indices = set(range(len(lines_def)))\n    \n    removed_lines_count = 0\n\n    while True:\n        if not active_lines_indices:\n            num_components, _ = find_components(num_nodes, active_lines_indices, lines_def)\n            return removed_lines_count, 0.0, num_components\n\n        num_components, components = find_components(num_nodes, active_lines_indices, lines_def)\n\n        flows = {}  # Using dict to store flows by line index\n\n        for comp_nodes in components:\n            if len(comp_nodes) = 1:\n                continue\n\n            # Map component-local indices to global node indices\n            node_map = {node_idx: i for i, node_idx in enumerate(comp_nodes)}\n            \n            comp_lines = []\n            for line_idx in active_lines_indices:\n                u, v, _, _, _ = lines_def[line_idx]\n                if u in comp_nodes and v in comp_nodes:\n                    comp_lines.append(line_idx)\n            \n            if not comp_lines:\n                continue\n\n            comp_size = len(comp_nodes)\n            laplacian = np.zeros((comp_size, comp_size))\n\n            # Build weighted Laplacian for the component\n            for line_idx in comp_lines:\n                u, v, b, _, _ = lines_def[line_idx]\n                u_comp, v_comp = node_map[u], node_map[v]\n                laplacian[u_comp, u_comp] += b\n                laplacian[v_comp, v_comp] += b\n                laplacian[u_comp, v_comp] -= b\n                laplacian[v_comp, u_comp] -= b\n            \n            # Select slack bus (smallest index in component)\n            slack_node_global = comp_nodes[0]\n            slack_node_comp = node_map[slack_node_global]\n            \n            non_slack_indices_comp = [i for i in range(comp_size) if i != slack_node_comp]\n            non_slack_indices_global = [node for node in comp_nodes if node != slack_node_global]\n            \n            # Reduced system\n            reduced_laplacian = laplacian[np.ix_(non_slack_indices_comp, non_slack_indices_comp)]\n            reduced_p = np.array([power_injections[i] for i in non_slack_indices_global])\n\n            # Solve for non-slack angles\n            try:\n                non_slack_thetas = np.linalg.solve(reduced_laplacian, reduced_p)\n            except np.linalg.LinAlgError:\n                # This can happen if a component is just a line, making L' singular.\n                # It's an issue with how the problem is defined, but we must handle it.\n                # For safety, use pinv if solve fails.\n                non_slack_thetas = np.linalg.pinv(reduced_laplacian) @ reduced_p\n\n            # Reconstruct full theta vector for the component\n            thetas_comp = np.zeros(comp_size)\n            thetas_comp[non_slack_indices_comp] = non_slack_thetas\n            \n            thetas_global = {comp_nodes[i]: thetas_comp[i] for i in range(comp_size)}\n\n            # Calculate flows for lines in this component\n            for line_idx in comp_lines:\n                u, v, b, _, _ = lines_def[line_idx]\n                flow = b * (thetas_global[u] - thetas_global[v])\n                flows[line_idx] = flow\n\n        # Assess overload\n        max_ratio = -1.0\n        line_to_remove = -1\n\n        ratios = []\n        for line_idx in sorted(list(active_lines_indices)):\n            u, v, b, c, _ = lines_def[line_idx]\n            flow_val = flows.get(line_idx, 0.0)\n            ratio = abs(flow_val) / c if c > 0 else float('inf')\n            ratios.append((ratio, line_idx))\n\n        if not ratios:\n            # This case is handled at the loop start, but as a safeguard\n            max_ratio_val = 0.0\n        else:\n            # Sort by ratio (desc), then line index (asc)\n            ratios.sort(key=lambda x: (-x[0], x[1]))\n            max_ratio_val = ratios[0][0]\n            line_to_remove = ratios[0][1]\n\n        if max_ratio_val = 1.0:\n            final_max_ratio = max_ratio_val if ratios else 0.0\n            return removed_lines_count, final_max_ratio, num_components\n        else:\n            active_lines_indices.remove(line_to_remove)\n            removed_lines_count += 1\n\ndef solve():\n    test_cases = [\n        {\n            \"N\": 4,\n            \"lines\": [(0, 1, 5, 8), (1, 2, 5, 8), (2, 3, 5, 8), (3, 0, 5, 8), (1, 3, 5, 6)],\n            \"P\": [3, -1, -2, 0]\n        },\n        {\n            \"N\": 5,\n            \"lines\": [(0, 1, 4, 4), (0, 2, 4, 4), (0, 3, 4, 4), (0, 4, 4, 0.5)],\n            \"P\": [4, -1, -1, -1, -1]\n        },\n        {\n            \"N\": 3,\n            \"lines\": [(0, 1, 10, 100), (1, 2, 10, 100), (0, 2, 10, 100)],\n            \"P\": [1, -0.5, -0.5]\n        },\n        {\n            \"N\": 3,\n            \"lines\": [(0, 1, 10, 5), (1, 2, 10, 5)],\n            \"P\": [5, 0, -5]\n        },\n        {\n            \"N\": 4,\n            \"lines\": [(0, 1, 10, 3), (1, 2, 10, 2), (2, 3, 10, 100)],\n            \"P\": [6, -2, -2, -2]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        k, R, M = solve_cascade(case[\"N\"], case[\"lines\"], case[\"P\"])\n        # Format the result with R rounded to 6 decimal places\n        results.append(f\"[{k},{R:.6f},{M}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现代基础设施的脆弱性不仅源于单个网络内部，更来自于网络之间的相互依赖。本练习将带您超越单个网络的视角，模拟一个相依网络系统中的级联失效过程，其中一个网络的节点失效会导致另一网络中依赖它的节点失效。这种基于连通性和依赖关系的失效机制，揭示了与基于负载的模型截然不同的系统崩溃路径。",
            "id": "4266384",
            "problem": "考虑两个无向网络 $A$ 和 $B$，它们通过双向的一对一依赖对相互依存。设节点集为 $A=\\{a_1,a_2,a_3,a_4,a_5,a_6\\}$ 和 $B=\\{b_1,b_2,b_3,b_4,b_5,b_6,b_7\\}$。边集为\n$$\nE_A=\\{(a_1,a_2),(a_2,a_3),(a_3,a_4),(a_1,a_3),(a_5,a_6)\\}\n$$\n和\n$$\nE_B=\\{(b_1,b_2),(b_2,b_3),(b_1,b_3),(b_4,b_5),(b_5,b_6),(b_6,b_7)\\}.\n$$\n相互依存关系由双向依赖集指定\n$$\nD=\\{(a_1,b_2),(a_2,b_3),(a_3,b_1),(a_4,b_4),(a_5,b_5),(a_6,b_6)\\},\n$$\n因此对于每个 $(a_i,b_j)\\in D$，都有一个对应的 $(b_j,a_i)\\in D$。节点 $b_7$ 没有依赖伙伴，是自主的。\n\n级联失效动力学定义如下，从网络 $A$ 中的一个初始移除开始。在给定阶段，一个节点是功能性的，当且仅当以下两个条件都成立：它属于其自身网络当前活动子图的最大连通分量 (LCC)，并且，如果它在另一个网络中有依赖伙伴，则该伙伴也必须是功能性的。该过程是单调的：一旦一个节点变为非功能性，它将保持非功能性。定义 $S_A^{(t)}$ 和 $S_B^{(t)}$ 为经过 $t$ 轮完整级联后网络 $A$ 和 $B$ 中的功能节点集，其中 $t\\in\\mathbb{N}_0$。初始化为 $S_A^{(0)}=A\\setminus R$ 和 $S_B^{(0)}=B$，其中初始移除集为 $R=\\{a_2\\}$。一轮完整的级联包含以下步骤：\n- 计算由 $S_A^{(t)}$ 在 $A$ 中导出的子图的 LCC；移除 $A$ 中所有不在此 LCC 中的节点，得到中间活动集 $S_{A,\\mathrm{LCC}}^{(t)}$。\n- 将依赖关系传播到 $B$：从 $S_B^{(t)}$ 中移除其在 $A$ 中的依赖伙伴不在 $S_{A,\\mathrm{LCC}}^{(t)}$ 中的任何节点，得到 $S_{B,\\mathrm{dep}}^{(t)}$。\n- 计算由 $S_{B,\\mathrm{dep}}^{(t)}$ 在 $B$ 中导出的子图的 LCC；移除 $B$ 中所有不在此 LCC 中的节点，得到 $S_B^{(t+1)}$。\n- 将依赖关系传播到 $A$：从 $S_{A,\\mathrm{LCC}}^{(t)}$ 中移除其在 $B$ 中的依赖伙伴不在 $S_B^{(t+1)}$ 中的任何节点，然后取剩余子图在 $A$ 中的 LCC；结果为 $S_A^{(t+1)}$。\n\n假设最大连通分量大小出现相同时，通过选择在映射 $a_i\\mapsto i$ 和 $b_j\\mapsto j$ 下节点标签总和最小的分量来确定性地打破僵局。从指定的 $R=\\{a_2\\}$ 开始，执行整整 $2$ 轮完整的级联。将基数 $|S_A^{(2)}|$ 和 $|S_B^{(2)}|$ 作为你的最终答案，格式化为行矩阵。无需四舍五入。",
            "solution": "该问题描述了两个相互依存网络 $A$ 和 $B$ 上的级联失效过程。我们被要求模拟这个过程两轮完整的过程，并确定每个网络中幸存节点的数量。\n\n### 问题验证\n**步骤1：提取给定信息**\n- 网络 $A$ 节点集：$A=\\{a_1, a_2, a_3, a_4, a_5, a_6\\}$\n- 网络 $A$ 边集：$E_A=\\{(a_1,a_2),(a_2,a_3),(a_3,a_4),(a_1,a_3),(a_5,a_6)\\}$\n- 网络 $B$ 节点集：$B=\\{b_1,b_2,b_3,b_4,b_5,b_6,b_7\\}$\n- 网络 $B$ 边集：$E_B=\\{(b_1,b_2),(b_2,b_3),(b_1,b_3),(b_4,b_5),(b_5,b_6),(b_6,b_7)\\}$\n- 双向依赖集：$D=\\{(a_1,b_2),(a_2,b_3),(a_3,b_1),(a_4,b_4),(a_5,b_5),(a_6,b_6)\\}$\n- 自主节点：$b_7$\n- 初始移除集：$R=\\{a_2\\}$\n- 初始功能集：$S_A^{(0)}=A\\setminus R$ 和 $S_B^{(0)}=B$。\n- 级联动力学：从时间 $t$ 到 $t+1$ 的一轮完整级联由四个操作序列定义：\n  1. 找到由 $S_A^{(t)}$ 导出的子图的最大连通分量 (LCC)，得到 $S_{A,\\mathrm{LCC}}^{(t)}$。\n  2. 从 $S_B^{(t)}$ 中移除其依赖伙伴不在 $S_{A,\\mathrm{LCC}}^{(t)}$ 中的节点，得到 $S_{B,\\mathrm{dep}}^{(t)}$。\n  3. 找到由 $S_{B,\\mathrm{dep}}^{(t)}$ 导出的子图的 LCC，得到 $S_B^{(t+1)}$。\n  4. 从 $S_{A,\\mathrm{LCC}}^{(t)}$ 中移除其依赖伙伴不在 $S_B^{(t+1)}$ 中的节点，然后找到剩余子图的 LCC，得到 $S_A^{(t+1)}$。\n- LCC 的平局打破规则：选择节点索引总和最小的分量。\n- 任务：报告 $|S_A^{(2)}|$ 和 $|S_B^{(2)}|$。\n\n**步骤2：使用提取的给定信息进行验证**\n该问题具有科学依据，描述了网络科学中一个著名的模型。问题是适定的，所有组成部分（网络、依赖关系、初始条件、动力学和打破僵局的规则）都得到了清晰明确的定义，确保了唯一、确定性的结果。问题是客观且可形式化的。设置是完整和一致的，没有任何矛盾或缺失的信息。它需要一个过程性模拟，使其不那么简单。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n### 解题过程\n我们将分步模拟两轮级联失效过程。\n\n**初始状态 ($t=0$)**\n过程从网络 $A$ 中移除节点 $a_2$ 开始。\n网络 $A$ 中的初始功能节点集为 $S_A^{(0)} = A \\setminus \\{a_2\\} = \\{a_1, a_3, a_4, a_5, a_6\\}$。\n网络 $B$ 中的初始功能节点集为 $S_B^{(0)} = B = \\{b_1, b_2, b_3, b_4, b_5, b_6, b_7\\}$。\n\n**级联第1轮 ($t=0 \\to t=1$)**\n1.  **网络A中的LCC：** 我们考虑由 $S_A^{(0)} = \\{a_1, a_3, a_4, a_5, a_6\\}$ 导出的 $A$ 的子图。此子图内来自 $E_A$ 的边有 $(a_1, a_3)$、$(a_3, a_4)$ 和 $(a_5, a_6)$。该子图有两个连通分量：大小为3的 $C_{A,1} = \\{a_1, a_3, a_4\\}$ 和大小为2的 $C_{A,2} = \\{a_5, a_6\\}$。最大连通分量 (LCC) 是 $C_{A,1}$。因此，此分量之外的节点失效。 $A$ 中的中间功能节点集为 $S_{A,\\mathrm{LCC}}^{(0)} = \\{a_1, a_3, a_4\\}$。\n\n2.  **向网络B传播依赖关系：** 如果一个 $B$ 中的节点其在 $A$ 中的依赖伙伴不再是功能性的，则该节点失效。现在 $A$ 中所有失效的节点集合是 $\\{a_2\\}$（初始移除）和 $\\{a_5, a_6\\}$（因LCC隔离）。它们在 $B$ 中的依赖伙伴分别是 $\\{b_3\\}$、$\\{b_5\\}$ 和 $\\{b_6\\}$。我们从 $S_B^{(0)}$ 中移除这些节点。\n    $B$ 中的中间功能节点集是 $S_{B,\\mathrm{dep}}^{(0)} = S_B^{(0)} \\setminus \\{b_3, b_5, b_6\\} = \\{b_1, b_2, b_4, b_7\\}$。\n\n3.  **网络B中的LCC：** 我们找到由 $S_{B,\\mathrm{dep}}^{(0)} = \\{b_1, b_2, b_4, b_7\\}$ 导出的 $B$ 的子图的 LCC。此子图内来自 $E_B$ 的唯一边是 $(b_1, b_2)$。这形成了三个连通分量：大小为2的 $C_{B,1}=\\{b_1, b_2\\}$，大小为1的 $C_{B,2}=\\{b_4\\}$，和大小为1的 $C_{B,3}=\\{b_7\\}$。LCC是 $C_{B,1}$。这定义了下一轮的功能集：$S_B^{(1)} = \\{b_1, b_2\\}$。\n\n4.  **向网络A传播依赖关系及最终LCC：** 我们从集合 $S_{A,\\mathrm{LCC}}^{(0)} = \\{a_1, a_3, a_4\\}$ 开始，移除任何其依赖伙伴不在 $S_B^{(1)} = \\{b_1, b_2\\}$ 中的节点。\n    - $a_1$ 的伙伴是 $b_2$，且 $b_2 \\in S_B^{(1)}$。所以，保留 $a_1$。\n    - $a_3$ 的伙伴是 $b_1$，且 $b_1 \\in S_B^{(1)}$。所以，保留 $a_3$。\n    - $a_4$ 的伙伴是 $b_4$，且 $b_4 \\notin S_B^{(1)}$。所以， $a_4$ 失效。\n    剩余的节点集是 $\\{a_1, a_3\\}$。我们现在必须找到由这些节点导出的子图的 LCC。由于边 $(a_1, a_3) \\in E_A$，该子图是连通的。因此，其 LCC就是该集合本身。\n    这定义了下一轮的功能集：$S_A^{(1)} = \\{a_1, a_3\\}$。\n\n在第1轮结束时，功能集为 $S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(1)} = \\{b_1, b_2\\}$。\n\n**级联第2轮 ($t=1 \\to t=2$)**\n我们从功能集 $S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(1)} = \\{b_1, b_2\\}$ 开始。\n\n1.  **网络A中的LCC：** 由 $S_A^{(1)}$ 导出的子图由于边 $(a_1, a_3)$ 的存在是连通的。LCC就是该集合本身。所以，$S_{A,\\mathrm{LCC}}^{(1)} = \\{a_1, a_3\\}$。\n\n2.  **向网络B传播依赖关系：** 我们检查 $S_B^{(1)} = \\{b_1, b_2}\\}$ 中节点的依赖伙伴。\n    - $b_1$ 的伙伴是 $a_3$，它在 $S_{A,\\mathrm{LCC}}^{(1)}$ 中。所以，保留 $b_1$。\n    - $b_2$ 的伙伴是 $a_1$，它在 $S_{A,\\mathrm{LCC}}^{(1)}$ 中。所以，保留 $b_2$。\n    没有节点因依赖关系而失效。中间集合是 $S_{B,\\mathrm{dep}}^{(1)} = \\{b_1, b_2\\}$。\n\n3.  **网络B中的LCC：** 由 $S_{B,\\mathrm{dep}}^{(1)} = \\{b_1, b_2\\}$ 导出的子图由于边 $(b_1, b_2)$ 的存在是连通的。LCC就是该集合本身。因此，$S_B^{(2)} = \\{b_1, b_2\\}$。\n\n4.  **向网络A传播依赖关系及最终LCC：** 我们从 $S_{A,\\mathrm{LCC}}^{(1)} = \\{a_1, a_3\\}$ 开始，并根据 $S_B^{(2)} = \\{b_1, b_2\\}$ 检查依赖关系。\n    - $a_1$ 的伙伴是 $b_2 \\in S_B^{(2)}$。所以，保留 $a_1$。\n    - $a_3$ 的伙伴是 $b_1 \\in S_B^{(2)}$。所以，保留 $a_3$。\n    没有节点因依赖关系而失效。剩余的集合是 $\\{a_1, a_3\\}$。由该集合导出的子图是连通的，所以其LCC就是该集合本身。\n    因此，$S_A^{(2)} = \\{a_1, a_3\\}$。\n\n两轮过后，系统已经稳定，功能集为 $S_A^{(2)} = S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(2)} = S_B^{(1)} = \\{b_1, b_2\\}$。\n基数为 $|S_A^{(2)}| = 2$ 和 $|S_B^{(2)}| = 2$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2  2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在网络安全领域，一个核心问题是如何识别系统最脆弱的部分。本练习将您置于攻击者的视角，任务是在一个遵循局部负载重分配规则的网络中，通过穷举搜索找到能引发最大规模级联失效的初始攻击节点组合。这个过程不仅能让您实现一个具体的级联模型，还将揭示寻找最优攻击策略所面临的组合爆炸挑战以及相关的深刻理论问题。",
            "id": "4266579",
            "problem": "给定一个有限的、带权的、无向的网络，由图 $G = (V, E)$ 表示，其中 $|V| = n$。同时给定一个非负基础负载向量 $\\ell \\in \\mathbb{R}_{\\ge 0}^{n}$，一个非负容量向量 $c \\in \\mathbb{R}_{\\ge 0}^{n}$，以及一个非负对称邻接权重矩阵 $W \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中对所有 $i,j \\in V$ 都有 $W_{ij} = W_{ji}$，且对所有 $i \\in V$ 都有 $W_{ii} = 0$。对于任何节点 $i \\in V$，定义其邻居集合为 $N(i) = \\{ j \\in V : W_{ij} > 0 \\}$。考虑一个具有以下机制的离散时间负载再分配级联过程：\n\n- 负载按轮次演化，并存储于向量 $L \\in \\mathbb{R}_{\\ge 0}^{n}$ 中；初始时 $L = \\ell$。\n- 目标移除策略是一个子集 $S \\subseteq V$，其大小为 $|S| = k$。在第 $t = 0$ 轮，集合 $S$ 中的所有节点都失效（被移除），并且每个此类节点的当前负载将按边的权重比例再分配给其幸存的邻居。\n- 更精确地说，当一个节点 $i$ 在一轮开始时失效，计算其幸存邻居集合 $N_{\\text{surv}}(i) = \\{ j \\in N(i) : j \\text{ 在此轮开始时未失效} \\}$。令 $\\sigma(i) = \\sum_{j \\in N_{\\text{surv}}(i)} W_{ij}$。如果 $\\sigma(i) > 0$，则每个幸存邻居 $j \\in N_{\\text{surv}}(i)$ 在该轮中会收到一个附加负载 $L_i \\cdot \\frac{W_{ij}}{\\sigma(i)}$；如果 $\\sigma(i) = 0$，则负载 $L_i$ 被丢弃（丢失）。\n- 在计算完当前轮次中所有失效节点的负载再分配并应用于 $L$ 后，这些失效节点将被永久移除，并且不再接收任何负载。任何幸存节点 $j$ 如果其负载 $L_j > c_j$，则会在下一轮失效。此同步更新过程将重复进行，直到没有更多失效发生。\n- 定义级联规模函数 $f(S)$ 为从初始移除集合 $S$ 开始，最终失效的节点总数（包括 $S$ 中的节点）。\n\n目标是构建一个给定基数 $k$ 的最坏情况目标移除策略 $S^{\\star}$，该策略在所述的负载再分配规则下能最大化级联规模 $f(S)$。此外，需要通过子模性论证，或通过提供子模性不成立的反例并解释为何在这种情况下需要穷举搜索以获得精确最优解，来证明您所构建策略的最优性。\n\n您的程序必须实现上述级联模型，并对下面的每个测试用例，通过搜索所有大小为 $k$ 的子集 $S \\subseteq V$ 来计算精确的最坏情况移除集 $S^{\\star}$ 和相应的最大级联规模 $f(S^{\\star})$。当 $f(S)$ 出现平局时，应选择节点索引按升序排序后字典序最小的集合 $S$。所有节点索引都是从0开始的整数。\n\n所有答案都是纯数学的且无单位。本问题不涉及角度和物理单位。\n\n测试套件规范：\n\n为以下测试用例提供结果。在每个用例中，网络通过列出非零对称边及其权重，以及基础负载 $\\ell$、容量 $c$ 和移除预算 $k$ 来指定。\n\n- 测试用例 $1$ (正常路径星形级联)：\n  - 节点：$n = 5$，标记为 $0, 1, 2, 3, 4$。\n  - 非零对称边及其权重：$(0,1)$ 权重为 $1$，$(0,2)$ 权重为 $1$，$(0,3)$ 权重为 $1$，$(0,4)$ 权重为 $1$。\n  - 基础负载：$\\ell = [0.80, 0.31, 0.31, 0.31, 0.31]$。\n  - 容量：$c = [1.20, 0.50, 0.50, 0.50, 0.50]$。\n  - 预算：$k = 1$。\n\n- 测试用例 $2$ (边界情况，无移除)：\n  - 节点：$n = 4$，标记为 $0, 1, 2, 3$。\n  - 非零对称边及其权重：$(0,1)$ 权重为 $1$，$(1,2)$ 权重为 $1$，$(2,3)$ 权重为 $1$。\n  - 基础负载：$\\ell = [0.20, 0.20, 0.20, 0.20]$。\n  - 容量：$c = [0.50, 0.50, 0.50, 0.50]$。\n  - 预算：$k = 0$。\n\n- 测试用例 $3$ (边缘情况协同效应与子模性反例)：\n  - 节点：$n = 5$，标记为 $0, 1, 2, 3, 4$。\n  - 非零对称边及其权重：$(0,2)$ 权重为 $1$，$(1,2)$ 权重为 $1$，$(2,3)$ 权重为 $1$，$(2,4)$ 权重为 $1$。\n  - 基础负载：$\\ell = [0.50, 0.50, 0.60, 0.40, 0.40]$。\n  - 容量：$c = [0.60, 0.60, 1.20, 0.50, 0.50]$。\n  - 预算：$k = 2$。\n\n最终输出格式要求：\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个结果必须是一个包含两个元素的列表，其中包含最大级联规模（一个整数）和对应的字典序最小的最大化集合 $S^{\\star}$（一个整数列表）。例如，输出应类似于 $[[f_1, S_1],[f_2, S_2],[f_3, S_3]]$，其中 $f_i$ 是测试用例 $i$ 的最大级联规模，$S_i$ 是最大化该规模的集合。\n\n您的程序不得读取任何输入，并且除了规定的单行输出外，不得打印任何其他文本。",
            "solution": "所提供的问题陈述是网络科学和复杂系统领域中一个有效且适定的问题。它涉及通过选择一个最优的初始失效节点集来最大化网络上的级联规模函数。\n\n该问题具有科学依据，是基于负载的级联失效的形式化表示，这种现象在电力网络和金融网络等情境中得到了研究。其动力学是确定性的，并以数学精度定义，确保了级联规模函数 $f(S)$ 对于任何初始失效集 $S$ 都是良定义的。给定有限数量的节点 $n$ 和固定的移除预算 $k$，最大化 $f(S)$ 的最优集 $S^{\\star}$ 保证存在。问题是完整的，提供了所有必要的参数和规则，并且不包含内部矛盾或歧义。对于测试用例中指定的小网络规模，通过穷举搜索找到精确解的请求在计算上是可行的。\n\n我们将首先形式化级联模型，然后讨论优化方法及其理由，最后概述实现算法。\n\n**1. 级联模型**\n\n在任何离散时间步 $t \\ge 0$，网络的状态可以由负载向量 $L^{(t)} \\in \\mathbb{R}_{\\ge 0}^{n}$ 和失效节点集（我们称之为 $\\mathcal{F}^{(t)} \\subseteq V$）来描述。\n\n*   **初始化 ($t=0$)：**\n    选择一个节点集 $S \\subseteq V$（其中 $|S|=k$）进行初始移除。所有失效节点的集合初始化为 $\\mathcal{F}^{(0)} = S$。初始负载向量是基础负载向量 $L = \\ell$。然而，问题指明 $S$ 中的节点是第一批失效并重新分配其负载的节点。我们可以将其建模为一系列轮次。设 $\\mathcal{F}_{\\text{total}}$ 为截至当前已失效的所有节点的集合，初始化为 $S$。设 $F_0 = S$ 为在第0轮失效的节点集合。\n\n*   **级联轮次 ($t=0, 1, 2, \\dots$)：**\n    级联过程以同步轮次进行。在每一轮 $t$ 中，一个节点集 $F_t$ 会失效。\n\n    1.  如果 $F_t = \\emptyset$，级联终止。过程停止。\n    2.  一个中间负载增量向量 $\\Delta L^{(t)} \\in \\mathbb{R}_{\\ge 0}^{n}$ 被初始化为全零。\n    3.  对于当前轮次中失效的每个节点 $i \\in F_t$，其负载 $L_i$ 必须被重新分配。其尚未失效的邻居集合为 $N_{\\text{surv}}(i) = N(i) \\setminus \\mathcal{F}_{\\text{total}}$。\n    4.  到这些幸存邻居的权重之和为 $\\sigma(i) = \\sum_{j \\in N_{\\text{surv}}(i)} W_{ij}$。\n    5.  如果 $\\sigma(i) > 0$，每个幸存邻居 $j \\in N_{\\text{surv}}(i)$ 都会收到一个附加负载。由于节点 $i$ 的失效，节点 $j$ 的增量为 $L_i \\cdot \\frac{W_{ij}}{\\sigma(i)}$。该值被加到 $\\Delta L_j^{(t)}$ 上。如果 $\\sigma(i)=0$，则负载 $L_i$ 丢失。\n    6.  在计算完来自 $F_t$ 中所有节点的负载增量后，幸存节点的负载被同步更新：对于所有 $j \\notin \\mathcal{F}_{\\text{total}}$，$L_j \\leftarrow L_j + \\Delta L_j^{(t)}$。请注意，失效节点本身的负载不再更新。\n    7.  所有失效节点的集合被更新：$\\mathcal{F}_{\\text{total}} \\leftarrow \\mathcal{F}_{\\text{total}} \\cup F_t$。\n    8.  识别出将在下一轮失效的新节点集 $F_{t+1}$。这些是尚未失效但其新负载超过其容量的节点：\n        $$F_{t+1} = \\{ j \\in V \\setminus \\mathcal{F}_{\\text{total}} : L_j > c_j \\}$$\n    9.  该过程以集合 $F_{t+1}$ 重复进行第 $t+1$ 轮。\n\n对于一个初始集合 $S$，级联的总规模由函数 $f(S) = |\\mathcal{F}_{\\text{final}}|$ 给出，其中 $\\mathcal{F}_{\\text{final}}$ 是过程终止时的集合 $\\mathcal{F}_{\\text{total}}$。\n\n**2. 优化与论证**\n\n目标是找到一个集合 $S^{\\star}$，以解决以下优化问题：\n$$ S^{\\star} = \\underset{S \\subseteq V, |S|=k}{\\text{argmax}} \\; f(S) $$\n当出现平局时，通过选择字典序最小的集合 $S$ 来打破。\n\n这是一个组合优化问题。对于许多此类问题，如果目标函数 $f(S)$ 是子模的，一个简单的贪心算法可以提供一个有性能保证的解。如果一个集合函数 $f$ 表现出“收益递减”的特性，那么它就是子模的。形式上，对于任何集合 $A \\subseteq B \\subseteq V$ 和任何元素 $v \\in V \\setminus B$，必须满足：\n$$ f(A \\cup \\{v\\}) - f(A) \\ge f(B \\cup \\{v\\}) - f(B) $$\n然而，在阈值模型中，级联规模函数通常不是子模的。问题陈述正确地暗示了这种可能性。我们可以使用测试用例3来证明子模性的失效。\n\n令 $f$ 为测试用例3的级联规模函数。\n-   令 $A = \\{0\\}$ 且 $B = \\emptyset$。注意 $B \\subset A$。让我们评估添加节点 $\\{1\\}$ 的边际增益。\n-   $f(\\emptyset) = 0$，因为初始没有节点过载。\n-   $f(\\{0\\})$: 节点0失效。其负载 $L_0=0.5$ 转移给它唯一的邻居节点2。节点2的负载变为 $L_2' = 0.6 + 0.5 = 1.1$。这小于其容量 $c_2 = 1.2$。级联停止。因此，$f(\\{0\\}) = 1$。\n-   $f(\\{1\\})$: 与节点0对称，节点1的失效同样不会引发级联。因此，$f(\\{1\\}) = 1$。\n-   $f(\\{0, 1\\})$: 节点0和1同时失效。它们都将其负载（$L_0=0.5, L_1=0.5$）重新分配给它们共同的邻居节点2。节点2的负载变为 $L_2' = 0.6 + 0.5 + 0.5 = 1.6$。这超过了其容量 $c_2 = 1.2$，所以节点2在下一轮失效。当节点2失效时，其1.6的新负载被重新分配给其幸存的邻居 $\\{3, 4\\}$，每个邻居收到0.8。它们的负载变为 $L_3' = 0.4+0.8=1.2 > c_3=0.5$ 和 $L_4' = 0.4+0.8=1.2 > c_4=0.5$。它们都失效了。整个网络崩溃。因此，$f(\\{0, 1\\}) = 5$。\n\n现在，我们来检验 $A = \\{0\\}$ 和 $B = \\emptyset$（因此 $B \\subseteq A$）以及元素 $v = 1$ 的子模性不等式。该不等式要求 $f(B \\cup \\{v\\}) - f(B) \\ge f(A \\cup \\{v\\}) - f(A)$。\n-   将节点1添加到空集 $B$ 的边际增益：$f(\\{1\\}) - f(\\emptyset) = 1 - 0 = 1$。\n-   将节点1添加到集合 $A=\\{0\\}$ 的边际增益：$f(\\{0,1\\}) - f(\\{0\\}) = 5 - 1 = 4$。\n\n我们得到 $1  4$，这意味着 $f(B \\cup \\{v\\}) - f(B)  f(A \\cup \\{v\\}) - f(A)$。这违反了子模性条件。该函数表现出协同效应，或收益递增，即两个节点失效的联合效应大于它们各自效应的总和。由于缺乏子模性，贪心算法不能保证找到最优解。因此，正如问题陈述所要求的，必须对所有 $\\binom{n}{k}$ 种可能的初始集合进行穷举搜索，以保证最优性。\n\n**3. 算法方法**\n\n该算法将由一个主循环和一个核心函数组成，主循环负责协调搜索，核心函数则为给定的初始集模拟级联过程。\n\n1.  **主程序：** 对于每个测试用例 $(n, W, \\ell, c, k)$：\n    a. 初始化 `max_cascade_size = -1` 和 `optimal_set = []`。\n    b. 生成所有大小为 $k$ 的唯一节点子集 $S$。`itertools.combinations` 函数很适用，因为它会按字典序生成这些子集。\n    c. 对于每个子集 $S$：\n        i. 调用一个模拟函数 `simulate_cascade(S, n, W, l, c)`，该函数返回最终的级联规模 $f(S)$。\n        ii. 如果返回的规模大于 `max_cascade_size`，则将 `max_cascade_size` 更新为这个新规模，并将 `optimal_set` 设置为当前的 $S$。因为我们是按字典序遍历集合，所以第一个达到最大可能规模的集合将是根据平局规则正确的集合。\n    d. 存储该测试用例的最终 (`max_cascade_size`, `optimal_set`) 对。\n\n2.  **`simulate_cascade(S, n, W, l, c)` 函数：**\n    a. 初始化 `loads = copy(l)`，`total_failed = set(S)` 和 `newly_failed = set(S)`。\n    b. 进入一个 `while` 循环，只要 `newly_failed` 不为空就继续。\n    c. 在循环内部，令 `failing_this_round = newly_failed`。将 `newly_failed` 重置为空集。\n    d. 初始化 `load_increments = zeros(n)`。\n    e. 对于 `failing_this_round` 中的每个节点 $i$：\n        i. 确定幸存邻居集 $N_{\\text{surv}}(i) = \\{ j \\mid W_{ij}>0 \\text{ and } j \\notin \\text{total\\_failed} \\}$。\n        ii. 计算 $\\sigma(i) = \\sum_{j \\in N_{\\text{surv}}(i)} W_{ij}$。\n        iii. 如果 $\\sigma(i) > 0$，对于每个 $j \\in N_{\\text{surv}}(i)$，将 $loads[i] \\cdot \\frac{W_{ij}}{\\sigma(i)}$ 加到 `load_increments[j]`。\n    f. 遍历完 `failing_this_round` 中的所有节点后，更新主 `loads` 向量：`loads += load_increments`。\n    g. 更新失效节点总集：`total_failed.update(failing_this_round)`。\n    h. 遍历所有节点 $j \\in \\{0, \\dots, n-1\\}$。如果 $j \\notin \\text{total\\_failed}$ 并且 $loads[j] > c[j]$，则将 $j$ 添加到 `newly_failed` 集合中。\n    i. 循环继续。\n    j. 循环终止后，返回 `len(total_failed)`。\n\n此设计忠实地实现了指定的模型，并执行了所需的穷举搜索，为每个测试用例找到精确的最优解。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the cascading failure problem for a set of predefined test cases.\n    It finds the initial removal set of size k that maximizes the total cascade size.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (happy path star cascade)\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, 1), (0, 2, 1), (0, 3, 1), (0, 4, 1)],\n            \"l\": [0.80, 0.31, 0.31, 0.31, 0.31],\n            \"c\": [1.20, 0.50, 0.50, 0.50, 0.50],\n            \"k\": 1,\n        },\n        # Test Case 2 (boundary, no removals)\n        {\n            \"n\": 4,\n            \"edges\": [(0, 1, 1), (1, 2, 1), (2, 3, 1)],\n            \"l\": [0.20, 0.20, 0.20, 0.20],\n            \"c\": [0.50, 0.50, 0.50, 0.50],\n            \"k\": 0,\n        },\n        # Test Case 3 (edge-case synergy and submodularity counterexample)\n        {\n            \"n\": 5,\n            \"edges\": [(0, 2, 1), (1, 2, 1), (2, 3, 1), (2, 4, 1)],\n            \"l\": [0.50, 0.50, 0.60, 0.40, 0.40],\n            \"c\": [0.60, 0.60, 1.20, 0.50, 0.50],\n            \"k\": 2,\n        },\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        edges = case[\"edges\"]\n        l_vec = np.array(case[\"l\"], dtype=float)\n        c_vec = np.array(case[\"c\"], dtype=float)\n        k = case[\"k\"]\n\n        # Build the weighted adjacency matrix W\n        W = np.zeros((n, n), dtype=float)\n        for i, j, w in edges:\n            W[i, j] = w\n            W[j, i] = w\n\n        max_cascade_size = -1\n        best_s = []\n\n        # Generate all subsets of nodes of size k.\n        # itertools.combinations generates them in lexicographical order.\n        initial_sets = itertools.combinations(range(n), k)\n        \n        for s_tuple in initial_sets:\n            initial_failures = set(s_tuple)\n            \n            # Run the cascade simulation for the current set S\n            loads = np.copy(l_vec)\n            total_failed = set(initial_failures)\n            newly_failed = set(initial_failures)\n\n            while newly_failed:\n                failing_this_round = set(newly_failed)\n                newly_failed = set()\n                \n                # Update total failed set before calculating redistributions\n                # from this round's failures. This is to ensure a node failing\n                # in the same round doesn't receive load from another.\n                current_round_total_failed = total_failed.union(failing_this_round)\n                \n                load_increments = np.zeros(n)\n\n                for i in failing_this_round:\n                    surviving_neighbors = []\n                    weight_sum_surv = 0.0\n                    \n                    # Find surviving neighbors and sum of weights\n                    for j in range(n):\n                        if W[i, j] > 0 and j not in current_round_total_failed:\n                            surviving_neighbors.append(j)\n                            weight_sum_surv += W[i, j]\n\n                    # Redistribute load\n                    if weight_sum_surv > 0:\n                        for j in surviving_neighbors:\n                            load_increments[j] += loads[i] * (W[i, j] / weight_sum_surv)\n                \n                # Synchronous update of loads\n                loads += load_increments\n                \n                # Update total failed set after redistributions are calculated\n                total_failed.update(failing_this_round)\n\n                # Identify nodes failing in the next round\n                for j in range(n):\n                    if j not in total_failed and loads[j] > c_vec[j]:\n                        newly_failed.add(j)\n\n            current_cascade_size = len(total_failed)\n            \n            # Update best result found so far.\n            # Due to lexicographical order of combinations, the first set\n            # that achieves the max size will be the lexicographically smallest.\n            if current_cascade_size > max_cascade_size:\n                max_cascade_size = current_cascade_size\n                best_s = list(s_tuple)\n        \n        # Handle k=0 case which results in no loops\n        if k == 0 and max_cascade_size == -1:\n             max_cascade_size = 0\n             best_s = []\n\n        final_results.append([max_cascade_size, best_s])\n    \n    # Format the final output string exactly as specified.\n    result_str = \",\".join([f\"[{size},{s}]\" for size, s in final_results])\n    print(f\"[{result_str}]\".replace(\" \", \"\"))\n\n\nsolve()\n```"
        }
    ]
}