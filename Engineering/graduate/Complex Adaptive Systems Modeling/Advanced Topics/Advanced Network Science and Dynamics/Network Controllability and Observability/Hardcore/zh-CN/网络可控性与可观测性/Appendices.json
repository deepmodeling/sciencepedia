{
    "hands_on_practices": [
        {
            "introduction": "为了开始我们对网络控制的探索，我们首先回顾线性系统理论的基本原理。对于一个动态特性已知的系统，卡尔曼秩条件为可控性提供了明确的检验标准。本练习将引导您将这个基本的代数测试应用于一个小型生物模型，从而判断一个外部输入原则上是否能够驱动整个系统。",
            "id": "4364519",
            "problem": "为了研究代表药物输注的外部控制输入引起的小信号调节，一个细胞通路中的双基因信号模块在一个稳态平衡点附近被线性化。该线性化状态空间模型是一个单输入线性时不变 (LTI) 系统，由 $\\dot{x}(t)=A x(t)+B u(t)$ 给出，其中 $x(t)\\in\\mathbb{R}^{2}$ 是基因活性与稳态的偏差，而 $u(t)\\in\\mathbb{R}$ 是控制输入。矩阵为\n$$\nA=\\begin{bmatrix}0   1 \\\\ -2   -3\\end{bmatrix},\\qquad B=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}.\n$$\n仅使用线性时不变系统能控性的基本定义，计算与 $\\left(A,B\\right)$ 相关联的能控性矩阵的秩，并判断该线性化基因模块在平衡点附近是否在小信号意义下是能控的。将能控性矩阵的秩 $\\operatorname{rank}\\mathcal{C}$ 作为最终答案，以单个整数形式报告，不带单位。无需四舍五入。",
            "solution": "该问题要求评估一个由线性时不变 (LTI) 状态空间模型描述的线性化双基因信号模块的能控性。该模型由方程 $\\dot{x}(t)=A x(t)+B u(t)$ 给出，其中状态维度为 $n=2$。给定的矩阵为：\n$$\nA=\\begin{bmatrix}0   1 \\\\ -2   -3\\end{bmatrix},\\qquad B=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}\n$$\nLTI 系统的能控性由其能控性矩阵的秩决定，该矩阵记为 $\\mathcal{C}$。对于一个维度为 $n$ 的系统，其能控性矩阵构造如下：\n$$\n\\mathcal{C} = \\begin{bmatrix} B   AB   A^2B   \\cdots   A^{n-1}B \\end{bmatrix}\n$$\n当且仅当能控性矩阵 $\\mathcal{C}$ 满秩时，即 $\\operatorname{rank}(\\mathcal{C}) = n$，该系统是能控的。这被称为能控性的卡尔曼秩条件。\n\n对于给定系统，状态维度为 $n=2$。因此，能控性矩阵由下式给出：\n$$\n\\mathcal{C} = \\begin{bmatrix} B   AB \\end{bmatrix}\n$$\n$\\mathcal{C}$ 的第一列是输入矩阵 $B$ 本身：\n$$\nB = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n$$\n$\\mathcal{C}$ 的第二列是状态矩阵 $A$ 和输入矩阵 $B$ 的乘积。我们计算这个乘积：\n$$\nAB = \\begin{bmatrix}0   1 \\\\ -2   -3\\end{bmatrix} \\begin{bmatrix}0 \\\\ 1\\end{bmatrix} = \\begin{bmatrix} (0)(0) + (1)(1) \\\\ (-2)(0) + (-3)(1) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ -3 \\end{bmatrix}\n$$\n现在，我们可以通过拼接列向量 $B$ 和 $AB$ 来构造能控性矩阵 $\\mathcal{C}$：\n$$\n\\mathcal{C} = \\begin{bmatrix} 0   1 \\\\ 1   -3 \\end{bmatrix}\n$$\n为了确定 $2 \\times 2$ 矩阵 $\\mathcal{C}$ 的秩，我们可以计算其行列式。一个方阵满秩的充要条件是其行列式不为零。\n$$\n\\det(\\mathcal{C}) = (0)(-3) - (1)(1) = 0 - 1 = -1\n$$\n由于 $\\det(\\mathcal{C}) = -1 \\neq 0$，矩阵 $\\mathcal{C}$ 的列是线性无关的。对于一个 $2 \\times 2$ 矩阵，这意味着它的秩为 $2$。\n$$\n\\operatorname{rank}(\\mathcal{C}) = 2\n$$\n根据卡尔曼秩条件，如果 $\\operatorname{rank}(\\mathcal{C})$ 等于状态空间的维度 $n$，则系统是能控的。在本例中，我们已经求得 $\\operatorname{rank}(\\mathcal{C}) = 2$，且状态维度为 $n=2$。由于 $\\operatorname{rank}(\\mathcal{C}) = n$，该系统是完全能控的。这意味着可以使用一个合适的控制输入 $u(t)$，在有限时间内将该线性化基因模块的状态从任意初始状态驱动到任意期望的最终状态。\n\n问题要求能控性矩阵的秩，我们已计算出其值为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在许多现实世界的复杂系统中，我们往往不清楚相互作用的确切强度，但网络的连接图是已知的。结构可控性理论提供了一个强大的框架，仅基于网络拓扑结构来分析其控制特性。本练习将介绍利用图论中的最大匹配方法，来识别确保完全控制所需的最小“驱动节点”集，这是现代网络控制分析的基石。",
            "id": "4364459",
            "problem": "系统生物医学中的一个信号网络在一个稳态工作点附近被线性化，因此其动态特性可以用一个线性时不变 (LTI) 系统来表示，该系统的状态矩阵稀疏性由一个包含七个标记为 $1$ 到 $7$ 的节点的有向图编码。一条边 $i \\to j$ 表示在线性化模型中，节点 $i$ 的状态直接影响节点 $j$ 的状态。有向边如下：\n- $1 \\to 2$\n- $1 \\to 3$\n- $2 \\to 3$\n- $3 \\to 4$\n- $3 \\to 5$\n- $4 \\to 6$\n- $5 \\to 6$\n- $6 \\to 7$\n- $7 \\to 5$\n\n仅使用有向网络结构能控性的基本定义以及有向图的二分图表示上的图论匹配概念，构建一个最大匹配，并根据未匹配的节点推断出最少的驱动节点数。只需报告最少的驱动节点数，结果为一个不带单位的整数。",
            "solution": "问题要求基于结构能控性和图论匹配的原理，求出控制一个给定有向网络所需的最少驱动节点数。\n\n连接结构能控性与图论的基本原理指出，对于一个包含 $N$ 个节点的有向网络，实现完全控制所需的最少驱动节点数 $N_D$ 由以下方程给出：\n$$N_D = N - |M^*|$$\n其中 $|M^*|$ 是该有向图中最大匹配的大小（基数）。驱动节点本身是在最大匹配中未被任何边指向的节点。\n\n首先，我们必须将网络结构形式化为一个有向图 $G = (V, E)$，其中 $V$ 是节点集合，$E$ 是有向边集合。\n根据问题描述，节点集合为 $V = \\{1, 2, 3, 4, 5, 6, 7\\}$，因此节点总数为 $N=7$。\n有向边集合为 $E = \\{(1, 2), (1, 3), (2, 3), (3, 4), (3, 5), (4, 6), (5, 6), (6, 7), (7, 5)\\}$。\n\n为了在有向图 $G$ 中找到一个最大匹配，我们构建一个相应的二分图 $G_B = (V_A \\cup V_B, E')$。该图由两个不相交的顶点集 $V_A$ 和 $V_B$ 组成，每个集合都是原始节点集 $V$ 的一个副本。设 $V_A = \\{x_1, x_2, x_3, x_4, x_5, x_6, x_7\\}$ 和 $V_B = \\{y_1, y_2, y_3, y_4, y_5, y_6, y_7\\}$。对于原始图 $G$ 中的每条有向边 $i \\to j$，我们在 $V_A$ 中的顶点 $x_i$ 和 $V_B$ 中的顶点 $y_j$ 之间添加一条无向边。\n\n因此，二分图 $G_B$ 中的边 $E'$ 如下：\n\\begin{itemize}\n    \\item $(x_1, y_2)$ 来自边 $1 \\to 2$\n    \\item $(x_1, y_3)$ 来自边 $1 \\to 3$\n    \\item $(x_2, y_3)$ 来自边 $2 \\to 3$\n    \\item $(x_3, y_4)$ 来自边 $3 \\to 4$\n    \\item $(x_3, y_5)$ 来自边 $3 \\to 5$\n    \\item $(x_4, y_6)$ 来自边 $4 \\to 6$\n    \\item $(x_5, y_6)$ 来自边 $5 \\to 6$\n    \\item $(x_6, y_7)$ 来自边 $6 \\to 7$\n    \\item $(x_7, y_5)$ 来自边 $7 \\to 5$\n\\end{itemize}\n\n$G_B$ 中的一个匹配 $M$ 是 $E'$ 的一个子集，其中 $M$ 中的任意两条边都不共享同一个顶点。最大匹配 $M^*$ 是一个包含最多可能边数的匹配。我们需要找到这样一个匹配的大小 $|M^*|$。\n\n我们来分析 $G_B$ 的结构。集合 $V_B$ 中的顶点 $y_1$ 没有任何关联边。这是因为在原始图 $G$ 中，节点 $1$ 的入度为 $0$（没有边指向它）。一个没有任何边的顶点不能成为任何匹配的一部分。因此，在任何匹配 $M$ 中，$y_1$ 必定是一个未匹配的顶点。由于匹配由顶点对组成（每对中一个顶点来自 $V_A$，一个来自 $V_B$），任何匹配的最大可能大小受限于可被匹配的顶点数量。由于 $y_1$ 无法被匹配，最大匹配的大小 $|M^*|$ 最多为 $N-1 = 7-1 = 6$。\n\n现在，我们需要确定是否存在一个大小为 $6$ 的匹配。我们可以通过观察来构建这样一个匹配。让我们从 $E'$ 中选择一个包含 $6$ 条没有公共顶点的边的集合。\n考虑以下边的集合，我们称之为 $M_{test}$：\n\\begin{itemize}\n    \\item $(x_1, y_2)$\n    \\item $(x_2, y_3)$\n    \\item $(x_3, y_4)$\n    \\item $(x_7, y_5)$\n    \\item $(x_4, y_6)$\n    \\item $(x_6, y_7)$\n\\end{itemize}\n我们来验证 $M_{test}$ 是否是一个有效的匹配。\n使用的来自 $V_A$ 的顶点是 $\\{x_1, x_2, x_3, x_4, x_6, x_7\\}$。所有顶点都不同。\n使用的来自 $V_B$ 的顶点是 $\\{y_2, y_3, y_4, y_5, y_6, y_7\\}$。所有顶点都不同。\n由于没有顶点被使用超过一次，$M_{test}$ 是一个有效的匹配。这个匹配的大小是 $|M_{test}| = 6$。\n\n既然我们已经确定了匹配的最大可能大小至多为 $6$，并且我们找到了一个大小为 $6$ 的有效匹配，我们可以得出结论，最大匹配的大小为 $|M^*| = 6$。\n\n在此匹配中，未匹配的顶点是来自 $V_A$ 的 $x_5$ 和来自 $V_B$ 的 $y_1$。驱动节点的集合对应于 $V_B$ 中未匹配顶点的集合。在本例中，$V_B$ 中唯一未匹配的顶点是 $y_1$，它对应于原始网络中的节点 $1$。此类节点的数量为 $1$。\n\n最后，我们应用最少驱动节点数的公式：\n$$N_D = N - |M^*|$$\n代入我们求得的值：\n$$N_D = 7 - 6 = 1$$\n确保网络结构能控性所需的最少驱动节点数为 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "超越可控性“是”或“否”的二元答案，我们常常需要量化从不同节点出发，系统在*多大程度上*是可控的。本练习引入了“平均可控性”这一度量，它源于可控性格拉姆矩阵（Gramian），用于衡量在状态空间中导航所需的能量。您将通过一项计算任务，根据节点的控制能力对其进行排序，并研究该排序与节点度、社群结构等关键网络特征之间的关系。",
            "id": "4132646",
            "problem": "给定一个具有 $n$ 个节点的网络上的离散时间线性时不变动力学系统，其状态更新由 $x_{t+1} = A x_t + B u_t$ 定义，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是加权邻接（系统）矩阵，$B \\in \\mathbb{R}^{n \\times m}$ 选择控制输入通道，$u_t \\in \\mathbb{R}^{m}$ 是在 $t$ 时刻的输入。假设 $A$ 的谱半径严格小于 $1$，因此系统是渐近稳定的。无穷时域可控性格拉姆矩阵 $W$ 由收敛级数 $W = \\sum_{t=0}^{\\infty} A^t B B^{\\top} (A^{\\top})^t$ 定义，由 $B$ 表示的输入配置的平均可控性定义为 $\\mathrm{tr}(W)$，即该格拉姆矩阵的迹。\n\n您的任务是编写一个完整的程序，对于一个固定的 $A$ 和每个被选为单驱动输入的节点 $i \\in \\{0,1,\\dots,n-1\\}$（即 $B = e_i$，第 $i$ 个标准基向量），计算平均可控性 $\\mathrm{tr}(W_i)$，根据此值对节点进行排名，并分析节点度和社群结构如何影响排名。分析必须使用经过充分检验的原理进行：离散时间可控性格拉姆矩阵的定义、对于谱半径小于 $1$ 的系统其存在性，以及诸如加权度和社群划分等基本图论属性。\n\n为确保科学真实性和稳定性，您必须通过 $A = s A_{\\text{base}}$ 将每个测试用例的邻接矩阵 $A_{\\text{base}}$ 缩放为一个稳定的 $A$，其中 $s = \\alpha / \\rho(A_{\\text{base}})$，$\\rho(A_{\\text{base}})$ 是 $A_{\\text{base}}$ 的谱半径，$\\alpha \\in (0,1)$ 由每个测试指定。使用这个 $A$ 来计算平均可控性。在进行度-可控性排名分析时，请使用从 $A_{\\text{base}}$（而不是从 $A$）计算的每个节点的加权度。\n\n对于每个测试用例：\n- 对于每个节点 $i$，计算当 $B = e_i$ 时的平均可控性。\n- 按平均可控性降序对节点进行排名；若值相等，则选择索引较小的节点。\n- 计算节点加权度向量（来自 $A_{\\text{base}}$）与平均可控性值向量之间的 Spearman 秩相关性。如果任一秩向量是常数（方差为零），则定义相关性为 $0.0$。\n- 计算每个社群内平均可控性值的平均值，返回一个按社群标签升序排列的社群均值列表。\n- 每个测试用例返回一个结果三元组：$[\\text{top\\_index}, \\text{spearman\\_rho}, \\text{community\\_means}]$，其中 $\\text{top\\_index}$ 是一个整数，$\\text{spearman\\_rho}$ 是一个四舍五入到 $4$ 位小数的浮点数，$\\text{community\\_means}$ 是一个浮点数列表，每个浮点数四舍五入到 $4$ 位小数。\n\n角度单位不适用；没有物理单位。所有结果都是无量纲的，应作为纯数字返回。\n\n要实现的测试套件：\n- 测试用例 1（星形拓扑，两个社群）：\n  - $n = 6$；$A_{\\text{base}}$ 是一个中心在节点 $0$ 的星形网络的对称邻接矩阵：对于 $i \\in \\{1,2,3,4,5\\}$，$A_{\\text{base}}[0,i] = A_{\\text{base}}[i,0] = 1$，所有其他非对角线元素为 $0$。无自环：对角线元素为 $0$。\n  - 社群：$[0,1,1,1,1,1]$。\n  - 稳定性缩放：$\\alpha = 0.9$，因此 $A = \\left(\\frac{0.9}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n- 测试用例 2（具有异构密度和弱桥接的双块社群结构）：\n  - $n = 8$；$A_{\\text{base}}$ 是具有两个块的对称矩阵。对于节点 $0$ 到 $3$，是权重为 $1.0$ 的完全子图。对于节点 $4$ 到 $7$，是权重为 $0.3$ 的完全子图。添加块间边 $A_{\\text{base}}[3,4] = A_{\\text{base}}[4,3] = 0.2$ 和 $A_{\\text{base}}[2,5] = A_{\\text{base}}[5,2] = 0.1$。所有对角线元素为 $0$。\n  - 社群：$[0,0,0,0,1,1,1,1]$。\n  - 稳定性缩放：$\\alpha = 0.95$，因此 $A = \\left(\\frac{0.95}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n- 测试用例 3（环状格点，度规则；交替社群）：\n  - $n = 8$；$A_{\\text{base}}$ 是环形网络的对称邻接矩阵：对于每个节点 $i$，与 $(i-1) \\bmod 8$ 和 $(i+1) \\bmod 8$ 连接，权重为 $1.0$。所有对角线元素为 $0$。\n  - 社群：$[0,1,0,1,0,1,0,1]$。\n  - 稳定性缩放：$\\alpha = 0.95$，因此 $A = \\left(\\frac{0.95}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n- 测试用例 4（接近稳定性边界的星形拓扑）：\n  - 与测试用例 1 相同，但 $\\alpha = 0.999$，因此 $A = \\left(\\frac{0.999}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应于上面列出的一个测试用例，并且其本身也是一个形式为 $[\\text{top\\_index}, \\text{spearman\\_rho}, \\text{community\\_means}]$ 的列表。例如，输出应类似于 $[[a_1,b_1,[c_{1,1},c_{1,2},\\dots]],[a_2,b_2,[\\dots]],[a_3,b_3,[\\dots]],[a_4,b_4,[\\dots]]]$，其中 $a_k$ 是整数，$b_k$、$c_{k,j}$ 是指定格式的浮点数。",
            "solution": "该问题要求分析在具有 $n$ 个节点的网络上定义的离散时间线性时不变（LTI）系统的平均可控性。该系统的动力学由状态空间方程控制：\n$$x_{t+1} = A x_t + B u_t$$\n其中 $x_t \\in \\mathbb{R}^n$ 是 $n$ 个节点在 $t$ 时刻的状态向量，$A \\in \\mathbb{R}^{n \\times n}$ 是表示网络拓扑和交互强度的加权邻接矩阵，$u_t \\in \\mathbb{R}^m$ 是控制输入向量，$B \\in \\mathbb{R}^{n \\times m}$ 是将控制输入映射到特定节点的输入矩阵。\n\n问题指明系统是渐近稳定的。这通过缩放基础邻接矩阵 $A_{\\text{base}}$ 来确保，使得得到的系统矩阵 $A$ 的谱半径 $\\rho(A)$ 严格小于 $1$。缩放定义为 $A = s A_{\\text{base}}$，其中缩放因子为 $s = \\alpha / \\rho(A_{\\text{base}})$，给定参数 $\\alpha \\in (0,1)$。缩放后矩阵的谱半径则为 $\\rho(A) = \\rho(s A_{\\text{base}}) = |s| \\rho(A_{\\text{base}}) = (\\alpha / \\rho(A_{\\text{base}})) \\rho(A_{\\text{base}}) = \\alpha  1$，这保证了稳定性。\n\n本分析的核心度量是平均可控性，定义为无穷时域可控性格拉姆矩阵的迹 $\\mathrm{tr}(W)$。格拉姆矩阵 $W$ 由收敛级数给出：\n$$W = \\sum_{t=0}^{\\infty} A^t B B^{\\top} (A^{\\top})^t$$\n该级数的收敛性由系统的稳定性（$\\rho(A)  1$）保证。一种计算上更有效确定 $W$ 的方法是求解离散时间代数李雅普诺夫方程（DTALE）：\n$$W - A W A^{\\top} = B B^{\\top}$$\n在系统是渐近稳定的前提下，该方程对于 $W$ 存在唯一的、对称的、半正定解。\n\n任务是评估单驱动场景下的平均可控性。对于每个节点 $i \\in \\{0, 1, \\dots, n-1\\}$，我们将其视为唯一的控制输入。这对应于将输入矩阵 $B$ 设置为第 $i$ 个标准基向量 $e_i \\in \\mathbb{R}^{n \\times 1}$。在这种情况下，矩阵 $B B^{\\top}$ 变为 $e_i e_i^{\\top}$，这是一个在第 $(i, i)$ 位置为 1、其余元素均为 0 的矩阵。对于每个节点 $i$，我们必须通过求解李雅普诺夫方程 $W_i - A W_i A^{\\top} = e_i e_i^{\\top}$ 来计算相应的格拉姆矩阵 $W_i$，然后求其迹 $\\mathrm{tr}(W_i)$。\n\n对于每个测试用例，分析分三个阶段进行：\n$1$. **节点排名**：根据节点的平均可控性值 $\\mathrm{tr}(W_i)$ 按降序对节点进行排名。若值相等，则通过选择索引较小的节点来解决。报告排名最高的节点的索引。\n$2$. **相关性分析**：计算平均可控性值向量 $\\{ \\mathrm{tr}(W_i) \\}_{i=0}^{n-1}$ 与加权节点度向量之间的 Spearman 秩相关系数 $\\rho$。加权度是通过对未缩放的基础矩阵 $A_{\\text{base}}$ 的行求和来计算的。如果这两个向量中任意一个表现出零方差（即其所有元素都相同），则相关性定义为 $0.0$。\n$3$. **社群分析**：给定节点到社群的划分，计算每个社群内所有节点的平均可控性值 $\\mathrm{tr}(W_i)$。这些均值以列表形式报告，按社群的升序数字标签排序。\n\n每个测试用例的总体算法如下：\n$1$. 构建基础矩阵 $A_{\\text{base}} \\in \\mathbb{R}^{n \\times n}$。\n$2$. 计算谱半径 $\\rho(A_{\\text{base}}) = \\max_j |\\lambda_j(A_{\\text{base}})|$。\n$3$. 计算缩放因子 $s = \\alpha / \\rho(A_{\\text{base}})$ 并构成稳定的系统矩阵 $A = s A_{\\text{base}}$。\n$4$. 通过对 $A_{\\text{base}}$ 的行求和来计算加权度向量。\n$5$. 对于从 $0$ 到 $n-1$ 的每个节点 $i$：\n    a. 构建矩阵 $Q_i = e_i e_i^{\\top}$。\n    b. 求解离散李雅普诺夫方程 $W_i - A W_i A^{\\top} = Q_i$ 以得到格拉姆矩阵 $W_i$。\n    c. 计算平均可控性 $\\mathrm{tr}(W_i)$ 并存储它。\n$6$. 根据计算出的可控性值对节点索引进行排名，以找到排名最高的节点。\n$7$. 计算度向量和可控性向量之间的 Spearman 相关性，处理零方差情况。\n$8$. 计算每个社群的平均可控性。\n$9$. 整理并按规定四舍五入结果，形成最终的输出三元组。\n此过程将为四个指定的测试用例中的每一个实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_discrete_lyapunov\nfrom scipy.stats import spearmanr\n\ndef format_list_custom(l):\n    \"\"\"\n    Recursively formats a list into a string without spaces after commas.\n    \"\"\"\n    if isinstance(l, list):\n        return f\"[{','.join(map(format_list_custom, l))}]\"\n    return str(l)\n\ndef analyze_system_controllability(A_base, communities, alpha):\n    \"\"\"\n    Performs the complete controllability analysis for a given test case.\n    \"\"\"\n    n = A_base.shape[0]\n\n    # Step 1: Scale the system matrix A for stability\n    if np.all(A_base == 0):\n        # This case is not expected by the problem but is good practice.\n        rho_A_base = 0.0\n    else:\n        eigvals = np.linalg.eigvals(A_base)\n        rho_A_base = np.max(np.abs(eigvals))\n\n    if rho_A_base == 0:\n        A = np.zeros_like(A_base, dtype=float)\n    else:\n        s = alpha / rho_A_base\n        A = s * A_base\n\n    # Step 2: Compute weighted degrees from A_base\n    weighted_degrees = A_base.sum(axis=1)\n\n    # Step 3: Compute average controllability for each node as a driver\n    avg_controllability_values = []\n    for i in range(n):\n        # The RHS of the Lyapunov equation is Q = e_i * e_i^T\n        Q = np.zeros((n, n))\n        Q[i, i] = 1.0\n        \n        # Solve the discrete-time Lyapunov equation: W - A*W*A.T = Q\n        W_i = solve_discrete_lyapunov(A, Q)\n        \n        # Average controllability is the trace of the Gramian\n        avg_cont = np.trace(W_i)\n        avg_controllability_values.append(avg_cont)\n\n    # Step 4: Rank nodes by average controllability\n    # Sort by descending controllability, then ascending index for ties\n    ranked_nodes = sorted(range(n), key=lambda i: (-avg_controllability_values[i], i))\n    top_index = ranked_nodes[0]\n\n    # Step 5: Compute Spearman rank correlation\n    # If either vector is constant (zero variance), set correlation to 0.0\n    if np.var(weighted_degrees) == 0 or np.var(avg_controllability_values) == 0:\n        spearman_rho_val = 0.0\n    else:\n        # spearmanr returns a result object; we need the correlation coefficient\n        spearman_rho_val = spearmanr(weighted_degrees, avg_controllability_values).correlation\n    \n    spearman_rho = round(spearman_rho_val, 4)\n\n    # Step 6: Compute average controllability within each community\n    num_communities = len(set(communities))\n    community_sums = np.zeros(num_communities)\n    community_counts = np.zeros(num_communities, dtype=int)\n\n    for i, comm_label in enumerate(communities):\n        community_sums[comm_label] += avg_controllability_values[i]\n        community_counts[comm_label] += 1\n\n    community_means_raw = [\n        community_sums[c] / community_counts[c] if community_counts[c]  0 else 0.0\n        for c in range(num_communities)\n    ]\n    community_means = [round(m, 4) for m in community_means_raw]\n    \n    return [top_index, spearman_rho, community_means]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for network controllability analysis.\n    \"\"\"\n    # Test Case 1: Star topology, n=6, alpha=0.9\n    A_base1 = np.zeros((6, 6))\n    for i in range(1, 6):\n        A_base1[0, i] = A_base1[i, 0] = 1.0\n    communities1 = [0, 1, 1, 1, 1, 1]\n    alpha1 = 0.9\n\n    # Test Case 2: Two-block community structure, n=8, alpha=0.95\n    A_base2 = np.zeros((8, 8))\n    # Block 1 (nodes 0-3) with weight 1.0\n    for i in range(4):\n        for j in range(i + 1, 4):\n            A_base2[i, j] = A_base2[j, i] = 1.0\n    # Block 2 (nodes 4-7) with weight 0.3\n    for i in range(4, 8):\n        for j in range(i + 1, 8):\n            A_base2[i, j] = A_base2[j, i] = 0.3\n    # Inter-block edges\n    A_base2[3, 4] = A_base2[4, 3] = 0.2\n    A_base2[2, 5] = A_base2[5, 2] = 0.1\n    communities2 = [0, 0, 0, 0, 1, 1, 1, 1]\n    alpha2 = 0.95\n\n    # Test Case 3: Ring lattice, n=8, alpha=0.95\n    n3 = 8\n    A_base3 = np.zeros((n3, n3))\n    for i in range(n3):\n        A_base3[i, (i - 1 + n3) % n3] = 1.0\n        A_base3[i, (i + 1) % n3] = 1.0\n    communities3 = [0, 1, 0, 1, 0, 1, 0, 1]\n    alpha3 = 0.95\n\n    # Test Case 4: Star topology, n=6, alpha=0.999 (near stability boundary)\n    A_base4 = A_base1\n    communities4 = communities1\n    alpha4 = 0.999\n\n    test_cases = [\n        (A_base1, communities1, alpha1),\n        (A_base2, communities2, alpha2),\n        (A_base3, communities3, alpha3),\n        (A_base4, communities4, alpha4),\n    ]\n\n    results = []\n    for A_base, communities, alpha in test_cases:\n        result = analyze_system_controllability(A_base, communities, alpha)\n        results.append(result)\n    \n    # Format the final output string exactly as required, without spaces.\n    formatted_results_str = ','.join([format_list_custom(r) for r in results])\n    print(f\"[{formatted_results_str}]\")\n\nsolve()\n```"
        }
    ]
}