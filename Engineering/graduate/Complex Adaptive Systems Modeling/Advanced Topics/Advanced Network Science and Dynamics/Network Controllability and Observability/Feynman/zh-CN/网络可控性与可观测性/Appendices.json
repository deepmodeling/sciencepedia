{
    "hands_on_practices": [
        {
            "introduction": "我们从网络可控性分析中最基本的问题入手：一个系统是否完全可控？这个练习将引导你应用线性时不变（LTI）系统的Kalman秩条件，这是一个代数测试，用于确定是否可以通过外部输入在有限时间内将系统驱动到任何期望的状态。掌握这个基础工具对于后续更复杂的结构和量化分析至关重要。",
            "id": "4364519",
            "problem": "一个细胞通路中的双基因信号模块在一个稳态平衡点附近被线性化，以研究代表药物输注的外部控制输入的小信号调节作用。该线性化状态空间模型是一个单输入线性时不变 (LTI) 系统，由 $\\dot{x}(t)=A x(t)+B u(t)$ 给出，其中 $x(t)\\in\\mathbb{R}^{2}$ 是基因活性偏离稳态的值，$u(t)\\in\\mathbb{R}$ 是控制输入。矩阵为\n$$\nA=\\begin{bmatrix}0  1 \\\\ -2  -3\\end{bmatrix},\\qquad B=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}.\n$$\n仅使用线性时不变系统能控性的基本定义，计算与 $\\left(A,B\\right)$ 相关的能控性矩阵的秩，并判断该线性化基因模块在平衡点附近是否在小信号意义下是能控的。将你的最终答案报告为能控性矩阵的秩 $\\operatorname{rank}\\mathcal{C}$，形式为一个无单位的整数。无需四舍五入。",
            "solution": "该问题要求评估一个由线性时不变 (LTI) 状态空间模型描述的线性化双基因信号模块的能控性。该模型由方程 $\\dot{x}(t)=A x(t)+B u(t)$ 给出，其中状态维度为 $n=2$。给定的矩阵是：\n$$\nA=\\begin{bmatrix}0  1 \\\\ -2  -3\\end{bmatrix},\\qquad B=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}\n$$\n一个 LTI 系统的能控性由其能控性矩阵的秩决定，该矩阵记为 $\\mathcal{C}$。对于一个维度为 $n$ 的系统，能控性矩阵构造如下：\n$$\n\\mathcal{C} = \\begin{bmatrix} B  AB  A^2B  \\cdots  A^{n-1}B \\end{bmatrix}\n$$\n系统是能控的当且仅当能控性矩阵 $\\mathcal{C}$ 具有满秩，即 $\\operatorname{rank}(\\mathcal{C}) = n$。这被称为能控性的卡尔曼秩条件。\n\n对于给定的系统，状态维度为 $n=2$。因此，能控性矩阵由下式给出：\n$$\n\\mathcal{C} = \\begin{bmatrix} B  AB \\end{bmatrix}\n$$\n$\\mathcal{C}$ 的第一列是输入矩阵 $B$ 本身：\n$$\nB = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n$$\n$\\mathcal{C}$ 的第二列是状态矩阵 $A$ 和输入矩阵 $B$ 的乘积。我们计算这个乘积：\n$$\nAB = \\begin{bmatrix}0  1 \\\\ -2  -3\\end{bmatrix} \\begin{bmatrix}0 \\\\ 1\\end{bmatrix} = \\begin{bmatrix} (0)(0) + (1)(1) \\\\ (-2)(0) + (-3)(1) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ -3 \\end{bmatrix}\n$$\n现在，我们可以通过连接列向量 $B$ 和 $AB$ 来构造能控性矩阵 $\\mathcal{C}$：\n$$\n\\mathcal{C} = \\begin{bmatrix} 0  1 \\\\ 1  -3 \\end{bmatrix}\n$$\n为了确定 $2 \\times 2$ 矩阵 $\\mathcal{C}$ 的秩，我们可以计算其行列式。一个方阵具有满秩的充分必要条件是其行列式不为零。\n$$\n\\det(\\mathcal{C}) = (0)(-3) - (1)(1) = 0 - 1 = -1\n$$\n由于 $\\det(\\mathcal{C}) = -1 \\neq 0$，矩阵 $\\mathcal{C}$ 的列是线性无关的。对于一个 $2 \\times 2$ 矩阵，这意味着它的秩为 $2$。\n$$\n\\operatorname{rank}(\\mathcal{C}) = 2\n$$\n根据卡尔曼秩条件，如果 $\\operatorname{rank}(\\mathcal{C})$ 等于状态空间的维度 $n$，则系统是能控的。在本例中，我们已经求得 $\\operatorname{rank}(\\mathcal{C}) = 2$，而状态维度为 $n=2$。由于 $\\operatorname{rank}(\\mathcal{C}) = n$，该系统是完全能控的。这意味着使用适当的控制输入 $u(t)$，可以在有限时间内将线性化基因模块的状态从任何初始状态驱动到任何期望的最终状态。\n\n题目要求计算能控性矩阵的秩，我们已经计算出其值为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在了解了基于精确系统参数的代数检验方法后，我们转向一个更具扩展性的视角：结构可控性。这种方法忽略了连接权重的具体数值，仅关注网络的“布线图”。通过应用图论中的最大匹配概念，本练习将帮助你确定控制整个网络所需的最小驱动节点数量，这是在设计大规模复杂系统（如生物信号网络）的高效控制策略时的一个核心问题。",
            "id": "4364459",
            "problem": "系统生物医学中的一个信号网络在一个稳定工作点附近被线性化，因此其动力学可以由一个线性时不变 (LTI) 系统表示，该系统的状态矩阵稀疏性由一个包含七个节点（标记为 $1$ 到 $7$）的有向图编码。一条边 $i \\to j$ 表示在线性化模型中，节点 $i$ 的状态直接影响节点 $j$ 的状态。有向边如下：\n- $1 \\to 2$\n- $1 \\to 3$\n- $2 \\to 3$\n- $3 \\to 4$\n- $3 \\to 5$\n- $4 \\to 6$\n- $5 \\to 6$\n- $6 \\to 7$\n- $7 \\to 5$\n\n仅使用有向网络的结构可控性基本定义以及有向图的二分图表示上的图论匹配概念，构建一个最大匹配，并根据未匹配的节点推导出所需的最小驱动节点数。仅报告最小驱动节点数，结果为一个不带单位的整数。",
            "solution": "该问题要求基于结构可控性和图论匹配的原理，求出控制一个给定有向网络所需的最小驱动节点数。\n\n连接结构可控性与图论的基本原理指出，对于一个有 $N$ 个节点的有向网络，实现完全控制所需的最小驱动节点数（记为 $N_D$）由以下方程给出：\n$$N_D = N - |M^*|$$\n其中 $|M^*|$ 是有向图中一个最大匹配的大小（基数）。驱动节点本身是在最大匹配中没有被任何边作为目标的节点。\n\n首先，我们必须将网络结构形式化为一个有向图 $G = (V, E)$，其中 $V$ 是节点集合，$E$ 是有向边集合。\n根据问题描述，节点集合为 $V = \\{1, 2, 3, 4, 5, 6, 7\\}$，因此节点总数 $N=7$。\n有向边集合为 $E = \\{(1, 2), (1, 3), (2, 3), (3, 4), (3, 5), (4, 6), (5, 6), (6, 7), (7, 5)\\}$。\n\n为了在有向图 $G$ 中找到一个最大匹配，我们构建一个相应的二分图 $G_B = (V_A \\cup V_B, E')$。该图由两个不相交的顶点集 $V_A$ 和 $V_B$ 组成，每个集合都是原始节点集 $V$ 的一个副本。设 $V_A = \\{x_1, x_2, x_3, x_4, x_5, x_6, x_7\\}$ 和 $V_B = \\{y_1, y_2, y_3, y_4, y_5, y_6, y_7\\}$。对于原始图 $G$ 中的每条有向边 $i \\to j$，我们在 $V_A$ 中的顶点 $x_i$ 和 $V_B$ 中的顶点 $y_j$ 之间添加一条无向边。\n\n因此，二分图 $G_B$ 中的边 $E'$ 如下：\n\\begin{itemize}\n    \\item $(x_1, y_2)$ 来自边 $1 \\to 2$\n    \\item $(x_1, y_3)$ 来自边 $1 \\to 3$\n    \\item $(x_2, y_3)$ 来自边 $2 \\to 3$\n    \\item $(x_3, y_4)$ 来自边 $3 \\to 4$\n    \\item $(x_3, y_5)$ 来自边 $3 \\to 5$\n    \\item $(x_4, y_6)$ 来自边 $4 \\to 6$\n    \\item $(x_5, y_6)$ 来自边 $5 \\to 6$\n    \\item $(x_6, y_7)$ 来自边 $6 \\to 7$\n    \\item $(x_7, y_5)$ 来自边 $7 \\to 5$\n\\end{itemize}\n\n$G_B$ 中的一个匹配 $M$ 是 $E'$ 的一个子集，使得 $M$ 中没有两条边共享一个公共顶点。最大匹配 $M^*$ 是具有最大可能边数的匹配。我们需要找到该匹配的大小 $|M^*|$。\n\n让我们分析 $G_B$ 的结构。集合 $V_B$ 中的顶点 $y_1$ 没有入射边。这是因为在原始图 $G$ 中，节点 1 的入度为 0（没有边指向它）。没有边的顶点不能成为任何匹配的一部分。因此，$y_1$ 在任何匹配 $M$ 中都必须是一个未匹配的顶点。由于一个匹配由顶点对（一个来自 $V_A$，一个来自 $V_B$）组成，任何匹配的最大可能大小受限于可被匹配的顶点数量。因为 $y_1$ 无法被匹配，所以最大匹配的大小 $|M^*|$ 最多为 $N-1 = 7-1 = 6$。\n\n现在，我们需要确定是否存在一个大小为 6 的匹配。我们可以通过观察来构建这样一个匹配。让我们从 $E'$ 中选择一个由 6 条不共享公共顶点的边组成的集合。\n考虑以下边集，我们称之为 $M_{test}$：\n\\begin{itemize}\n    \\item $(x_1, y_2)$\n    \\item $(x_2, y_3)$\n    \\item $(x_3, y_4)$\n    \\item $(x_7, y_5)$\n    \\item $(x_4, y_6)$\n    \\item $(x_6, y_7)$\n\\end{itemize}\n让我们验证 $M_{test}$ 是否为一个有效的匹配。\n使用的来自 $V_A$ 的顶点是 $\\{x_1, x_2, x_3, x_4, x_6, x_7\\}$。所有顶点都是不同的。\n使用的来自 $V_B$ 的顶点是 $\\{y_2, y_3, y_4, y_5, y_6, y_7\\}$。所有顶点也都是不同的。\n因为没有顶点被使用超过一次，所以 $M_{test}$ 是一个有效的匹配。这个匹配的大小是 $|M_{test}| = 6$。\n\n既然我们已经确定了匹配的最大可能大小最多为 6，并且我们找到了一个大小为 6 的有效匹配，我们可以得出结论：最大匹配的大小为 $|M^*| = 6$。\n\n在此匹配中，未匹配的顶点是来自 $V_A$ 的 $x_5$ 和来自 $V_B$ 的 $y_1$。驱动节点的集合对应于 $V_B$ 中未匹配的顶点集合。在这种情况下，$V_B$ 中唯一未匹配的顶点是 $y_1$，它对应于原始网络中的节点 1。这样的节点数量是 1。\n\n最后，我们应用计算最小驱动节点数的公式：\n$$N_D = N - |M^*|$$\n代入我们已经求出的值：\n$$N_D = 7 - 6 = 1$$\n确保网络结构可控性所需的最小驱动节点数为 1。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "知道了系统是否可控以及需要多少驱动节点后，一个更实际的问题是：哪些节点是“最好”的控制器？本次实践将引入一个量化指标——平均可控性，它通过可控性格拉米安矩阵的迹来衡量。你将通过编程实践，计算并排序各个节点作为单一驱动器时的控制能力，并分析节点的度、社区结构等网络特性如何影响其控制效果，从而将理论概念与数据驱动的网络分析方法联系起来。",
            "id": "4132646",
            "problem": "给定一个具有 $n$ 个节点的网络上的离散时间线性时不变动力学系统，由状态更新方程 $x_{t+1} = A x_t + B u_t$ 定义，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是加权邻接（系统）矩阵，$B \\in \\mathbb{R}^{n \\times m}$ 选择控制输入通道，$u_t \\in \\mathbb{R}^{m}$ 是时间 $t$ 的输入。假设 $A$ 的谱半径严格小于 $1$，因此系统是渐近稳定的。无穷时域可控性格拉米安矩阵 $W$ 由收敛级数 $W = \\sum_{t=0}^{\\infty} A^t B B^{\\top} (A^{\\top})^t$ 定义，由 $B$ 表示的输入配置的平均可控性定义为 $\\mathrm{tr}(W)$，即格拉米安矩阵的迹。\n\n你的任务是编写一个完整的程序，对于一个固定的 $A$ 以及作为单个驱动输入（$B = e_i$，即第 $i$ 个标准基向量）的每个节点 $i \\in \\{0,1,\\dots,n-1\\}$，计算平均可控性 $\\mathrm{tr}(W_i)$，按此值对节点进行排序，并分析节点度和社群结构如何影响排名。分析必须使用经过充分检验的原理：离散时间可控性格拉米安矩阵的定义、其对于谱半径小于 $1$ 的系统的存在性，以及如图论中的加权度和社群划分等基本属性。\n\n为确保科学真实性和稳定性，你必须通过 $A = s A_{\\text{base}}$ 将每个测试用例的邻接矩阵 $A_{\\text{base}}$ 缩放为一个稳定的 $A$，其中 $s = \\alpha / \\rho(A_{\\text{base}})$，$\\rho(A_{\\text{base}})$ 是 $A_{\\text{base}}$ 的谱半径，$\\alpha \\in (0,1)$ 是每个测试指定的参数。使用这个 $A$ 来计算平均可控性。使用从 $A_{\\text{base}}$（而非 $A$）计算的每个节点的加权度来进行度-可控性排名分析。\n\n对于每个测试用例：\n- 计算当 $B = e_i$ 时，每个节点 $i$ 的平均可控性。\n- 按平均可控性的降序对节点进行排名；若值相同，则选择索引较小的节点。\n- 计算节点加权度向量（来自 $A_{\\text{base}}$）与平均可控性值向量之间的斯皮尔曼等级相关性（Spearman rank correlation）。如果任一排名向量为常数（方差为零），则定义相关性为 $0.0$。\n- 计算每个社群内平均可控性值的均值，返回一个按社群标签升序排列的社群均值列表。\n- 每个测试用例返回一个三元组结果：$[\\text{top\\_index}, \\text{spearman\\_rho}, \\text{community\\_means}]$，其中 $\\text{top\\_index}$ 是一个整数，$\\text{spearman\\_rho}$ 是一个四舍五入到 $4$ 位小数的浮点数，$\\text{community\\_means}$ 是一个四舍五入到 $4$ 位小数的浮点数列表。\n\n角度单位不适用；没有物理单位。所有结果都是无量纲的，应以纯数字形式返回。\n\n要实现的测试套件：\n- 测试用例 1（星形拓扑，双社群）：\n  - $n = 6$；$A_{\\text{base}}$ 是一个中心在节点 $0$ 的星形图的对称邻接矩阵：对于 $i \\in \\{1,2,3,4,5\\}$，$A_{\\text{base}}[0,i] = A_{\\text{base}}[i,0] = 1$，所有其他非对角线元素为 $0$。无自环：对角线元素为 $0$。\n  - 社群：$[0,1,1,1,1,1]$。\n  - 稳定性缩放：$\\alpha = 0.9$，所以 $A = \\left(\\frac{0.9}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n- 测试用例 2（具有异构密度和弱桥接的双区块社群结构）：\n  - $n = 8$；$A_{\\text{base}}$ 是具有两个区块的对称矩阵。对于节点 $0$ 到 $3$，是每条边权重为 $1.0$ 的完全子图。对于节点 $4$ 到 $7$，是每条边权重为 $0.3$ 的完全子图。添加区块间边 $A_{\\text{base}}[3,4] = A_{\\text{base}}[4,3] = 0.2$ 和 $A_{\\text{base}}[2,5] = A_{\\text{base}}[5,2] = 0.1$。所有对角线元素为 $0$。\n  - 社群：$[0,0,0,0,1,1,1,1]$。\n  - 稳定性缩放：$\\alpha = 0.95$，所以 $A = \\left(\\frac{0.95}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n- 测试用例 3（环形格，度规则；交替社群）：\n  - $n = 8$；$A_{\\text{base}}$ 是一个环的对称邻接矩阵：对于每个节点 $i$，与 $(i-1) \\bmod 8$ 和 $(i+1) \\bmod 8$ 以权重 $1.0$ 连接。所有对角线元素为 $0$。\n  - 社群：$[0,1,0,1,0,1,0,1]$。\n  - 稳定性缩放：$\\alpha = 0.95$，所以 $A = \\left(\\frac{0.95}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n- 测试用例 4（接近稳定性边界的星形拓扑）：\n  - 与测试用例 1 相同，但 $\\alpha = 0.999$，所以 $A = \\left(\\frac{0.999}{\\rho(A_{\\text{base}})}\\right) A_{\\text{base}}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应于上面列出的一个测试用例，并且其本身是 $[\\text{top\\_index}, \\text{spearman\\_rho}, \\text{community\\_means}]$ 形式的列表。例如，输出应如下所示：$[[a_1,b_1,[c_{1,1},c_{1,2},\\dots]],[a_2,b_2,[\\dots]],[a_3,b_3,[\\dots]],[a_4,b_4,[\\dots]]]$，其中 $a_k$ 是整数，$b_k$ 和 $c_{k,j}$ 是指定格式的浮点数。",
            "solution": "该问题陈述是有效的。它科学地基于线性控制理论和网络科学的原理，问题定义良好，有明确的路径通向唯一解，并以客观、正式的语言表述。因此，我们可以着手推导和实现解决方案。\n\n该问题要求分析一个定义在 $n$ 个节点网络上的离散时间线性时不变（LTI）系统的平均可控性。该系统的动力学由状态空间方程控制：\n$$x_{t+1} = A x_t + B u_t$$\n其中 $x_t \\in \\mathbb{R}^n$ 是 $n$ 个节点在时间 $t$ 的状态向量，$A \\in \\mathbb{R}^{n \\times n}$ 是表示网络拓扑和交互强度的加权邻接矩阵，$u_t \\in \\mathbb{R}^m$ 是控制输入向量，$B \\in \\mathbb{R}^{n \\times m}$ 是将控制输入映射到特定节点的输入矩阵。\n\n问题规定系统是渐近稳定的。这通过缩放一个基础邻接矩阵 $A_{\\text{base}}$ 来确保，使得得到的系统矩阵 $A$ 的谱半径 $\\rho(A)$ 严格小于 $1$。缩放定义为 $A = s A_{\\text{base}}$，其中缩放因子为 $s = \\alpha / \\rho(A_{\\text{base}})$，对于给定的参数 $\\alpha \\in (0,1)$。缩放后矩阵的谱半径则为 $\\rho(A) = \\rho(s A_{\\text{base}}) = |s| \\rho(A_{\\text{base}}) = (\\alpha / \\rho(A_{\\text{base}})) \\rho(A_{\\text{base}}) = \\alpha < 1$，这保证了稳定性。\n\n此分析的核心度量是平均可控性，定义为无穷时域可控性格拉米安矩阵的迹 $\\mathrm{tr}(W)$。格拉米安矩阵 $W$ 由收敛级数给出：\n$$W = \\sum_{t=0}^{\\infty} A^t B B^{\\top} (A^{\\top})^t$$\n该级数的收敛性由系统的稳定性（$\\rho(A) < 1$）保证。一种计算上更有效确定 $W$ 的方法是求解离散时间代数李雅普诺夫方程（DTALE）：\n$$W - A W A^{\\top} = B B^{\\top}$$\n在系统渐近稳定的条件下，该方程对于 $W$ 有一个唯一的、对称的、半正定解。\n\n任务是评估单驱动场景下的平均可控性。对于每个节点 $i \\in \\{0, 1, \\dots, n-1\\}$，我们将其视为唯一的控制输入。这对应于将输入矩阵 $B$ 设置为第 $i$ 个标准基向量 $e_i \\in \\mathbb{R}^{n \\times 1}$。在这种情况下，矩阵 $B B^{\\top}$ 变为 $e_i e_i^{\\top}$，这是一个在第 $(i, i)$ 位置上为 $1$、其余位置均为零的矩阵。对于每个节点 $i$，我们必须通过求解李雅普诺夫方程 $W_i - A W_i A^{\\top} = e_i e_i^{\\top}$ 来计算相应的格拉米安矩阵 $W_i$，然后求其迹 $\\mathrm{tr}(W_i)$。\n\n每个测试用例的分析分三个阶段进行：\n$1$。**节点排名**：根据节点的平均可控性值 $\\mathrm{tr}(W_i)$ 按降序对节点进行排名。通过选择索引较小的节点来解决平局问题。报告排名最高的节点的索引。\n$2$。**相关性分析**：计算平均可控性值向量 $\\{ \\mathrm{tr}(W_i) \\}_{i=0}^{n-1}$ 与加权节点度向量之间的斯皮尔曼等级相关系数 $\\rho$。加权度是通过对未缩放的基础矩阵 $A_{\\text{base}}$ 的行求和来计算的。如果两个向量中的任何一个表现出零方差（即其所有元素都相同），则相关性定义为 $0.0$。\n$3$。**社群分析**：给定节点的社群划分，计算每个社群内所有节点的平均可控性值 $\\mathrm{tr}(W_i)$ 的均值。这些均值以列表形式报告，按社群的数字标签升序排列。\n\n每个测试用例的总体算法如下：\n$1$。构建基础矩阵 $A_{\\text{base}} \\in \\mathbb{R}^{n \\times n}$。\n$2$。计算谱半径 $\\rho(A_{\\text{base}}) = \\max_j |\\lambda_j(A_{\\text{base}})|$。\n$3$。计算缩放因子 $s = \\alpha / \\rho(A_{\\text{base}})$ 并构成稳定的系统矩阵 $A = s A_{\\text{base}}$。\n$4$。通过对 $A_{\\text{base}}$ 的行求和来计算加权度向量。\n$5$。对从 $0$ 到 $n-1$ 的每个节点 $i$：\n    a. 构建矩阵 $Q_i = e_i e_i^{\\top}$。\n    b. 求解离散李雅普诺夫方程 $W_i - A W_i A^{\\top} = Q_i$ 以得到格拉米安矩阵 $W_i$。\n    c. 计算平均可控性 $\\mathrm{tr}(W_i)$ 并存储它。\n$6$。根据计算出的可控性值对节点索引进行排名，以找到排名最高的节点。\n$7$。计算度向量和可控性向量之间的斯皮尔曼相关性，处理零方差情况。\n$8$。计算每个社群的平均可控性。\n$9$。整理并按规定四舍五入结果，以形成最终的输出三元组。\n此过程将为四个指定的测试用例中的每一个实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_discrete_lyapunov\nfrom scipy.stats import spearmanr\n\ndef format_list_custom(l):\n    \"\"\"\n    Recursively formats a list into a string without spaces after commas.\n    \"\"\"\n    if isinstance(l, list):\n        return f\"[{','.join(map(format_list_custom, l))}]\"\n    return str(l)\n\ndef analyze_system_controllability(A_base, communities, alpha):\n    \"\"\"\n    Performs the complete controllability analysis for a given test case.\n    \"\"\"\n    n = A_base.shape[0]\n\n    # Step 1: Scale the system matrix A for stability\n    if np.all(A_base == 0):\n        # This case is not expected by the problem but is good practice.\n        rho_A_base = 0.0\n    else:\n        eigvals = np.linalg.eigvals(A_base)\n        rho_A_base = np.max(np.abs(eigvals))\n\n    if rho_A_base == 0:\n        A = np.zeros_like(A_base, dtype=float)\n    else:\n        s = alpha / rho_A_base\n        A = s * A_base\n\n    # Step 2: Compute weighted degrees from A_base\n    weighted_degrees = A_base.sum(axis=1)\n\n    # Step 3: Compute average controllability for each node as a driver\n    avg_controllability_values = []\n    for i in range(n):\n        # The RHS of the Lyapunov equation is Q = e_i * e_i^T\n        Q = np.zeros((n, n))\n        Q[i, i] = 1.0\n        \n        # Solve the discrete-time Lyapunov equation: W - A*W*A.T = Q\n        W_i = solve_discrete_lyapunov(A, Q)\n        \n        # Average controllability is the trace of the Gramian\n        avg_cont = np.trace(W_i)\n        avg_controllability_values.append(avg_cont)\n\n    # Step 4: Rank nodes by average controllability\n    # Sort by descending controllability, then ascending index for ties\n    ranked_nodes = sorted(range(n), key=lambda i: (-avg_controllability_values[i], i))\n    top_index = ranked_nodes[0]\n\n    # Step 5: Compute Spearman rank correlation\n    # If either vector is constant (zero variance), set correlation to 0.0\n    if np.var(weighted_degrees) == 0 or np.var(avg_controllability_values) == 0:\n        spearman_rho_val = 0.0\n    else:\n        # spearmanr returns a result object; we need the correlation coefficient\n        spearman_rho_val = spearmanr(weighted_degrees, avg_controllability_values).correlation\n    \n    spearman_rho = round(spearman_rho_val, 4)\n\n    # Step 6: Compute average controllability within each community\n    num_communities = len(set(communities))\n    community_sums = np.zeros(num_communities)\n    community_counts = np.zeros(num_communities, dtype=int)\n\n    for i, comm_label in enumerate(communities):\n        community_sums[comm_label] += avg_controllability_values[i]\n        community_counts[comm_label] += 1\n\n    community_means_raw = [\n        community_sums[c] / community_counts[c] if community_counts[c] > 0 else 0.0\n        for c in range(num_communities)\n    ]\n    community_means = [round(m, 4) for m in community_means_raw]\n    \n    return [top_index, spearman_rho, community_means]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for network controllability analysis.\n    \"\"\"\n    # Test Case 1: Star topology, n=6, alpha=0.9\n    A_base1 = np.zeros((6, 6))\n    for i in range(1, 6):\n        A_base1[0, i] = A_base1[i, 0] = 1.0\n    communities1 = [0, 1, 1, 1, 1, 1]\n    alpha1 = 0.9\n\n    # Test Case 2: Two-block community structure, n=8, alpha=0.95\n    A_base2 = np.zeros((8, 8))\n    # Block 1 (nodes 0-3) with weight 1.0\n    for i in range(4):\n        for j in range(i + 1, 4):\n            A_base2[i, j] = A_base2[j, i] = 1.0\n    # Block 2 (nodes 4-7) with weight 0.3\n    for i in range(4, 8):\n        for j in range(i + 1, 8):\n            A_base2[i, j] = A_base2[j, i] = 0.3\n    # Inter-block edges\n    A_base2[3, 4] = A_base2[4, 3] = 0.2\n    A_base2[2, 5] = A_base2[5, 2] = 0.1\n    communities2 = [0, 0, 0, 0, 1, 1, 1, 1]\n    alpha2 = 0.95\n\n    # Test Case 3: Ring lattice, n=8, alpha=0.95\n    n3 = 8\n    A_base3 = np.zeros((n3, n3))\n    for i in range(n3):\n        A_base3[i, (i - 1 + n3) % n3] = 1.0\n        A_base3[i, (i + 1) % n3] = 1.0\n    communities3 = [0, 1, 0, 1, 0, 1, 0, 1]\n    alpha3 = 0.95\n\n    # Test Case 4: Star topology, n=6, alpha=0.999 (near stability boundary)\n    A_base4 = A_base1\n    communities4 = communities1\n    alpha4 = 0.999\n\n    test_cases = [\n        (A_base1, communities1, alpha1),\n        (A_base2, communities2, alpha2),\n        (A_base3, communities3, alpha3),\n        (A_base4, communities4, alpha4),\n    ]\n\n    results = []\n    for A_base, communities, alpha in test_cases:\n        result = analyze_system_controllability(A_base, communities, alpha)\n        results.append(result)\n    \n    # Format the final output string exactly as required, without spaces.\n    formatted_results_str = ','.join([format_list_custom(r) for r in results])\n    print(f\"[{formatted_results_str}]\")\n\nsolve()\n```"
        }
    ]
}