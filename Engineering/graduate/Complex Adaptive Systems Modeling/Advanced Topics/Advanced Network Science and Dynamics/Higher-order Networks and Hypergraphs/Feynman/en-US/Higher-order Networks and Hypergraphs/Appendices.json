{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of higher-order networks, we must begin with their fundamental components. This first exercise focuses on the basic definitions of a hypergraph, such as node degree $d(v)$ and hyperedge size $|e|$. By calculating these properties for a small, concrete example and verifying the fundamental identity $\\sum_{v}d(v)=\\sum_{e}|e|$, you will solidify your grasp of the essential vocabulary and structural properties that underpin all subsequent analysis of higher-order systems .",
            "id": "4126420",
            "problem": "Consider a finite hypergraph model used to encode higher-order interactions in Complex Adaptive Systems (CAS). A hypergraph is defined by a set of nodes $V$ and a set of hyperedges $E$, where each hyperedge is a subset of $V$. The degree $d(v)$ of a node $v \\in V$ is the number of hyperedges in $E$ that contain $v$, and the size $|e|$ of a hyperedge $e \\in E$ is the number of nodes it contains. The incidence matrix counts node-hyperedge memberships, and its total number of nonzero entries can be computed either by summing degrees over nodes or by summing sizes over hyperedges. Starting from these definitions and the incidence matrix viewpoint, justify that these two totals are equal in any finite hypergraph and then evaluate this common total for the specific case given by $V=\\{1,2,3,4\\}$ and $E=\\{\\{1,2,3\\},\\{2,3\\},\\{1,4\\}\\}$. Compute $d(v)$ for each $v \\in V$, compute $|e|$ for each $e \\in E$, and provide the final common total as an exact integer.",
            "solution": "The problem is found to be valid as it is scientifically grounded in the mathematical field of hypergraph theory, well-posed with a clear objective, objective in its language, and contains all necessary information for a complete solution.\n\nThe problem asks for two parts: first, a general justification that for any finite hypergraph, the sum of node degrees equals the sum of hyperedge sizes; second, a calculation of these sums and the common total for a specific example.\n\nLet the hypergraph be denoted by $\\mathcal{H} = (V, E)$, where $V$ is a finite set of nodes and $E$ is a finite set of hyperedges, with each hyperedge $e \\in E$ being a non-empty subset of $V$.\n\nTo justify the equality, we use the concept of the incidence matrix, as suggested by the problem. Let $|V|=n$ and $|E|=m$. The incidence matrix $H$ is an $n \\times m$ matrix where the rows are indexed by the nodes $v \\in V$ and the columns are indexed by the hyperedges $e \\in E$. The entries of the matrix, $H_{ve}$, are defined as:\n$$\nH_{ve} = \\begin{cases} 1 & \\text{if } v \\in e \\\\ 0 & \\text{if } v \\notin e \\end{cases}\n$$\nThe total number of nonzero entries in $H$ is the sum of all its entries, since the entries are either $1$ or $0$. Let us denote this total sum by $S$. We can compute $S$ by summing over its entries in two different orders.\n\nFirst, let's sum over the columns for each row, and then sum the results over all rows. This corresponds to a node-centric view. For a fixed node $v_i \\in V$, the sum of the entries in its corresponding row is:\n$$\n\\sum_{e_j \\in E} H_{v_i e_j}\n$$\nBy the definition of the incidence matrix, $H_{v_i e_j}$ is $1$ if and only if the node $v_i$ is contained in the hyperedge $e_j$. Therefore, this sum counts the number of hyperedges that contain the node $v_i$. This is precisely the definition of the degree of the node $v_i$, denoted by $d(v_i)$.\n$$\nd(v_i) = \\sum_{e_j \\in E} H_{v_i e_j}\n$$\nTo find the total sum $S$, we sum these row-sums over all nodes $v_i \\in V$:\n$$\nS = \\sum_{v_i \\in V} \\left( \\sum_{e_j \\in E} H_{v_i e_j} \\right) = \\sum_{v_i \\in V} d(v_i)\n$$\nSecond, let's sum over the rows for each column, and then sum the results over all columns. This corresponds to a hyperedge-centric view. For a fixed hyperedge $e_j \\in E$, the sum of the entries in its corresponding column is:\n$$\n\\sum_{v_i \\in V} H_{v_i e_j}\n$$\nBy definition, $H_{v_i e_j}$ is $1$ if and only if the node $v_i$ is a member of the hyperedge $e_j$. Therefore, this sum counts the number of nodes contained in the hyperedge $e_j$. This is precisely the definition of the size (or cardinality) of the hyperedge $e_j$, denoted by $|e_j|$.\n$$\n|e_j| = \\sum_{v_i \\in V} H_{v_i e_j}\n$$\nTo find the total sum $S$, we sum these column-sums over all hyperedges $e_j \\in E$:\n$$\nS = \\sum_{e_j \\in E} \\left( \\sum_{v_i \\in V} H_{v_i e_j} \\right) = \\sum_{e_j \\in E} |e_j|\n$$\nSince both calculations compute the same total sum $S$, the two expressions must be equal. This method of proof is known as a double counting argument.\n$$\n\\sum_{v \\in V} d(v) = \\sum_{e \\in E} |e|\n$$\nThis justifies the general principle for any finite hypergraph.\n\nNow, we evaluate this for the specific case given: $V=\\{1,2,3,4\\}$ and $E=\\{e_1, e_2, e_3\\}$ where $e_1=\\{1,2,3\\}$, $e_2=\\{2,3\\}$, and $e_3=\\{1,4\\}$.\n\nWe first compute the degree $d(v)$ for each node $v \\in V$:\n- For node $v=1$: it is contained in $e_1=\\{1,2,3\\}$ and $e_3=\\{1,4\\}$. Thus, $d(1) = 2$.\n- For node $v=2$: it is contained in $e_1=\\{1,2,3\\}$ and $e_2=\\{2,3\\}$. Thus, $d(2) = 2$.\n- For node $v=3$: it is contained in $e_1=\\{1,2,3\\}$ and $e_2=\\{2,3\\}$. Thus, $d(3) = 2$.\n- For node $v=4$: it is contained in $e_3=\\{1,4\\}$. Thus, $d(4) = 1$.\n\nThe sum of the degrees is:\n$$\n\\sum_{v \\in V} d(v) = d(1) + d(2) + d(3) + d(4) = 2 + 2 + 2 + 1 = 7\n$$\nNext, we compute the size $|e|$ for each hyperedge $e \\in E$:\n- For hyperedge $e_1=\\{1,2,3\\}$: its size is the number of nodes it contains, so $|e_1| = 3$.\n- For hyperedge $e_2=\\{2,3\\}$: its size is $|e_2| = 2$.\n- For hyperedge $e_3=\\{1,4\\}$: its size is $|e_3| = 2$.\n\nThe sum of the hyperedge sizes is:\n$$\n\\sum_{e \\in E} |e| = |e_1| + |e_2| + |e_3| = 3 + 2 + 2 = 7\n$$\nBoth sums yield the same value, $7$, as predicted by the theorem. This common total represents the total number of (node, hyperedge) incidence pairs, which is the number of nonzero entries in the corresponding $4 \\times 3$ incidence matrix.\nThe final common total is $7$.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "After mastering the basic structure of a hypergraph, a natural next question is how to quantify the importance or influence of individual nodes within it. This practice moves from local structure to global analysis by contrasting the simple degree centrality with the more sophisticated tensor eigenvector centrality . You will implement a numerical power iteration method to compute this centrality, gaining hands-on experience with the adjacency tensor and appreciating how it captures the recursive principle that a node's influence depends on the influence of its collaborators.",
            "id": "4126430",
            "problem": "Consider a $3$-uniform hypergraph with node set $\\{0,1,\\dots,n-1\\}$ and hyperedge set $\\mathcal{E}$, where each hyperedge is a $3$-element subset of the node set. The goal is to compute node influence via two complementary centralities and to produce a deterministic ranking. The computations must be based on foundational definitions and well-tested principles appropriate for higher-order networks and hypergraphs in complex adaptive systems modeling.\n\nDefinitions and foundations:\n- A $3$-uniform hypergraph is a pair $(V,\\mathcal{E})$ with $V=\\{0,1,\\dots,n-1\\}$ and $\\mathcal{E}\\subseteq \\{e\\subseteq V: |e|=3\\}$.\n- The degree centrality of node $i$ is $d_i$, the count of hyperedges in $\\mathcal{E}$ that contain $i$.\n- The adjacency tensor of a $3$-uniform hypergraph is the order-$3$ symmetric tensor $\\mathcal{A}\\in\\mathbb{R}^{n\\times n\\times n}$ with entries\n$$\n\\mathcal{A}_{ijk}=\\begin{cases}\n\\frac{1}{2} & \\text{if } \\{i,j,k\\}\\in\\mathcal{E} \\text{ and } i,j,k \\text{ are pairwise distinct},\\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\n- The tensor eigenvector centrality uses the $Z$-eigenpair $(\\lambda,x)$ satisfying\n$$\n\\mathcal{A}x^2=\\lambda x,\n$$\nwhere $(\\mathcal{A}x^2)_i=\\sum_{j,k=0}^{n-1}\\mathcal{A}_{ijk}x_j x_k$, $x\\in\\mathbb{R}_{\\ge 0}^n$ and a normalization such as $\\|x\\|_2=1$ is imposed to fix scale. Existence of a nonnegative principal eigenvector for nonnegative, weakly irreducible tensors follows from the Perronâ€“Frobenius theorem (PF) generalized to tensors.\n- A computationally consistent contraction for $3$-uniform hypergraphs that avoids explicit tensor construction is\n$$\n(\\mathcal{A}x^2)_i=\\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x_j x_k,\n$$\nwhich matches the above $\\mathcal{A}$ by symmetry and the factor $\\frac{1}{2}$ summed over permutations.\n\nYour program must, for each supplied test hypergraph:\n1. Compute the degree centrality vector $d\\in\\mathbb{N}^n$ with entries $d_i$.\n2. Compute a nonnegative tensor $Z$-eigenvector centrality $x\\in\\mathbb{R}_{\\ge 0}^n$ by fixed-point iteration derived from $\\mathcal{A}x^2=\\lambda x$:\n   - Initialize $x^{(0)}$ with strictly positive entries and normalize with the Euclidean norm $\\|\\cdot\\|_2$.\n   - Iterate $x^{(t+1)}=\\frac{\\mathcal{A}(x^{(t)})^2}{\\|\\mathcal{A}(x^{(t)})^2\\|_2}$ until convergence in the Euclidean norm, i.e., stop when $\\|x^{(t+1)}-x^{(t)}\\|_2$ is below a tolerance. If $\\|\\mathcal{A}(x^{(t)})^2\\|_2=0$, then the centrality vector is the zero vector.\n   - Report the converged $x$ normalized by $\\|x\\|_2=1$ and provide entries rounded to $6$ decimal places.\n3. Rank nodes by influence using the following total order:\n   - Primary key: descending tensor eigenvector centrality $x_i$,\n   - Secondary key: descending degree centrality $d_i$,\n   - Tertiary key: ascending node index $i$.\n   The ranking must be reported as a list of node indices from most to least influential.\n\nTest suite:\n- Test case $1$ (general case): $n=5$, $\\mathcal{E}=\\{\\{0,1,2\\},\\{0,2,3\\},\\{0,3,4\\},\\{1,2,3\\}\\}$.\n- Test case $2$ (boundary with isolated node): $n=4$, $\\mathcal{E}=\\{\\{0,1,2\\}\\}$; node $3$ is isolated.\n- Test case $3$ (symmetric regular case): $n=6$, $\\mathcal{E}=\\{\\{0,1,2\\},\\{0,3,4\\},\\{1,3,5\\},\\{2,4,5\\}\\}$.\n\nAnswer specification:\n- For each test case, output a triple of lists $[d,x,r]$ where $d$ is the list of integers $d_i$, $x$ is the list of floats $x_i$ each rounded to $6$ decimal places, and $r$ is the list of integers representing the node ranking.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one element per test case, in the exact format\n$$\n[[d^{(1)},x^{(1)},r^{(1)}],[d^{(2)},x^{(2)},r^{(2)}],[d^{(3)},x^{(3)},r^{(3)}]].\n$$\nNo additional text should be printed.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the fields of complex network theory and numerical linear algebra, specifically concerning hypergraphs and tensor eigenvectors. The problem is well-posed, with all definitions, constraints, and objectives clearly and formally stated, leading to a unique, computable solution. All terms are objective and mathematically precise.\n\nThe task is to compute two centrality measures for nodes in a $3$-uniform hypergraph and then to produce a deterministic ranking based on these measures. The specified measures are degree centrality and tensor eigenvector centrality.\n\n### 1. Degree Centrality\n\nDegree centrality is a fundamental measure of a node's importance based on its direct involvement in the network's structure. For a hypergraph, it is the most direct generalization of the concept from simple graphs.\n\n**Definition**: The degree centrality $d_i$ of a node $i$ is defined as the number of hyperedges that contain node $i$. Mathematically, for a hypergraph $(V, \\mathcal{E})$ with node set $V$ and hyperedge set $\\mathcal{E}$,\n$$\nd_i = |\\{e \\in \\mathcal{E} : i \\in e\\}|\n$$\n\n**Computation**: To compute the degree centrality vector $d \\in \\mathbb{N}^n$ for a hypergraph with $n$ nodes, one can initialize a zero vector of size $n$. Then, for each hyperedge $e = \\{v_1, v_2, v_3\\}$ in the set $\\mathcal{E}$, the degree counts for nodes $v_1$, $v_2$, and $v_3$ are incremented by one. This process is repeated for all hyperedges.\n\n### 2. Tensor Eigenvector Centrality\n\nWhile degree centrality captures local influence, eigenvector-based centralities measure a node's influence transitively. A node is important if it is connected to other important nodes. For hypergraphs, this relationship is captured by an adjacency tensor, a higher-order generalization of an adjacency matrix.\n\n**Adjacency Tensor and Eigenvalue Problem**: For a $k$-uniform hypergraph, the interactions are represented by an order-$k$ adjacency tensor. For the given $3$-uniform hypergraph, this is an order-$3$ tensor $\\mathcal{A} \\in \\mathbb{R}^{n \\times n \\times n}$. The problem defines it as\n$$\n\\mathcal{A}_{ijk}=\\begin{cases}\n\\frac{1}{2} & \\text{if } \\{i,j,k\\}\\in\\mathcal{E} \\text{ and } i,j,k \\text{ are pairwise distinct},\\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nThe factor of $1/2$ is a convention related to the number of non-zero entries for a symmetric tensor, which is $3! = 6$. The problem states the total contribution per hyperedge $\\{i,j,k\\}$ is $\\mathcal{A}_{ijk}+\\mathcal{A}_{ikj}+\\mathcal{A}_{jik}+\\mathcal{A}_{jki}+\\mathcal{A}_{kij}+\\mathcal{A}_{kji} = 6 \\times \\frac{1}{2} = 3$. This is a detail of tensor definition; the core computation relies on a more direct contraction.\n\nThe eigenvector centrality vector $x \\in \\mathbb{R}_{\\ge 0}^n$ is derived from the $Z$-eigenvalue equation:\n$$\n\\mathcal{A}x^2 = \\lambda x\n$$\nwhere $(\\mathcal{A}x^2)_i = \\sum_{j,k=0}^{n-1}\\mathcal{A}_{ijk}x_j x_k$. This equation signifies that a node $i$'s centrality, $x_i$, is proportional to the summed influence from pairs of nodes $(j,k)$ with which it forms hyperedges.\n\n**Computational Method via Power Iteration**: Constructing and storing the $n \\times n \\times n$ tensor $\\mathcal{A}$ is computationally expensive. The problem provides a more efficient, equivalent contraction for computing the tensor-vector product $\\mathcal{A}x^2$:\n$$\n(\\mathcal{A}x^2)_i = \\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x_j x_k\n$$\nThis form avoids materializing the tensor by directly iterating over the list of hyperedges.\n\nThe principal eigenvector (the one associated with the largest eigenvalue $\\lambda$) can be found using the fixed-point power iteration method. The existence and uniqueness of a non-negative principal eigenvector are guaranteed for non-negative, irreducible tensors by the Perron-Frobenius theorem for tensors. For reducible tensors, as seen in hypergraphs with isolated components, the method still converges to an eigenvector corresponding to the dominant component.\n\nThe iterative scheme is as follows:\n1.  Initialize a vector $x^{(0)}$ with strictly positive entries (e.g., a vector of ones) and normalize it to have a Euclidean norm of $1$: $\\|x^{(0)}\\|_2 = 1$.\n2.  For $t = 0, 1, 2, \\dots$, compute the next iterate $x^{(t+1)}$:\n    a.  Compute the unnormalized vector $y^{(t+1)}$ where $y^{(t+1)}_i = (\\mathcal{A}(x^{(t)})^2)_i = \\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x^{(t)}_j x^{(t)}_k$.\n    b.  If $\\|y^{(t+1)}\\|_2 = 0$, the centrality vector is the zero vector. This occurs if the hypergraph is empty or the initial vector lies in a nullspace, which is avoided by positive initialization.\n    c.  Normalize to get the next iterate: $x^{(t+1)} = \\frac{y^{(t+1)}}{\\|y^{(t+1)}\\|_2}$.\n3.  The iteration stops when the change between successive vectors is negligible, i.e., $\\|x^{(t+1)} - x^{(t)}\\|_2 < \\epsilon$ for a small tolerance $\\epsilon$. The final $x^{(t+1)}$ is the desired centrality vector.\n\n### 3. Deterministic Node Ranking\n\nTo provide a single, unambiguous influence ranking, a total order on the set of nodes is required. The problem specifies a lexicographical comparison using three keys, which resolves any ties that may arise from using a single metric.\n\n**Ranking Keys**:\n1.  **Primary Key**: The tensor eigenvector centrality score $x_i$, in descending order. Nodes with higher eigenvector centrality are considered more influential.\n2.  **Secondary Key**: The degree centrality $d_i$, in descending order. This is used to break ties among nodes with identical eigenvector centrality.\n3.  **Tertiary Key**: The node index $i$, in ascending order. This is the final tie-breaker, ensuring a unique ranking when both primary and secondary keys are equal.\n\n**Procedure**: The ranking algorithm involves creating a list of tuples for each node $i$, of the form $(x_i, d_i, i)$. This list is then sorted using the specified compound key. The final ranked list of nodes is extracted from the sorted tuples.\n\nBy integrating these three principles, we can construct a robust algorithm to analyze the provided hypergraphs and generate the required output triplets $[d, x, r]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hypergraph centrality and ranking problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case)\n        {'n': 5, 'edges': [[0, 1, 2], [0, 2, 3], [0, 3, 4], [1, 2, 3]]},\n        # Test case 2 (boundary with isolated node)\n        {'n': 4, 'edges': [[0, 1, 2]]},\n        # Test case 3 (symmetric regular case)\n        {'n': 6, 'edges': [[0, 1, 2], [0, 3, 4], [1, 3, 5], [2, 4, 5]]}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n\n        # 1. Compute degree centrality\n        d = compute_degree_centrality(n, edges)\n\n        # 2. Compute tensor eigenvector centrality\n        x = compute_eigenvector_centrality(n, edges)\n\n        # 3. Rank nodes\n        r = rank_nodes(d, x)\n\n        # Format results for output\n        d_list = d.tolist()\n        x_list_rounded = [round(val, 6) for val in x]\n        r_list = r\n\n        all_results.append([d_list, x_list_rounded, r_list])\n\n    # Final print statement in the exact required format.\n    # Custom formatter to avoid spaces in the output string.\n    def format_list(lst, is_float=False):\n        if is_float:\n            return '[' + ','.join(f'{val:.6f}' for val in lst) + ']'\n        return '[' + ','.join(map(str, lst)) + ']'\n\n    results_str = []\n    for d, x, r in all_results:\n        case_str = f\"[{format_list(d)},{format_list(x, is_float=True)},{format_list(r)}]\"\n        results_str.append(case_str)\n    \n    print(f\"[{','.join(results_str)}]\")\n\ndef compute_degree_centrality(n, edges):\n    \"\"\"\n    Computes degree centrality for each node.\n    d_i is the number of hyperedges containing node i.\n    \"\"\"\n    degrees = np.zeros(n, dtype=int)\n    for edge in edges:\n        for node in edge:\n            degrees[node] += 1\n    return degrees\n\ndef compute_eigenvector_centrality(n, edges, tol=1e-9, max_iter=1000):\n    \"\"\"\n    Computes tensor eigenvector centrality using fixed-point power iteration.\n    \"\"\"\n    # 1. Initialize x_t0 with strictly positive entries and normalize\n    x = np.ones(n)\n    x = x / np.linalg.norm(x)\n\n    for _ in range(max_iter):\n        # 2a. Compute the unnormalized next vector y = A(x^2)\n        y = np.zeros(n)\n        for i, j, k in edges:\n            y[i] += x[j] * x[k]\n            y[j] += x[i] * x[k]\n            y[k] += x[i] * x[j]\n        \n        # 2b. Check for zero vector case\n        norm_y = np.linalg.norm(y)\n        if norm_y == 0:\n            return np.zeros(n)\n        \n        # 2c. Normalize to get the next iterate x_t1\n        x_next = y / norm_y\n        \n        # 3. Check for convergence\n        if np.linalg.norm(x_next - x) < tol:\n            return x_next\n        \n        x = x_next\n        \n    return x\n\ndef rank_nodes(d, x):\n    \"\"\"\n    Ranks nodes based on a three-key system:\n    1. Descending eigenvector centrality (x_i)\n    2. Descending degree centrality (d_i)\n    3. Ascending node index (i)\n    \"\"\"\n    n = len(d)\n    # Create a list of tuples (x_i, d_i, i) for sorting\n    nodes_with_metrics = [(x[i], d[i], i) for i in range(n)]\n\n    # Sort using a lambda function that implements the ranking logic\n    # Python's sort is stable. We use negative values for descending order.\n    nodes_with_metrics.sort(key=lambda item: (-item[0], -item[1], item[2]))\n\n    # Extract the ranked node indices\n    ranked_indices = [item[2] for item in nodes_with_metrics]\n    \n    return ranked_indices\n\nsolve()\n\n```"
        },
        {
            "introduction": "Perhaps the most compelling reason to study higher-order networks is their unique ability to model synergistic group dynamics that are lost in traditional pairwise representations. This final practice provides a powerful, concrete demonstration of this principle by exploring a contagion process where group effects are critical . By constructing a scenario where a standard model on a pairwise network projection predicts no contagion, while a higher-order model reveals a global cascade, you will understand firsthand why irreducible triadic interactions are not just a theoretical detail but a crucial driver of complex system behavior.",
            "id": "4126352",
            "problem": "Consider the following construction problem in the setting of higher-order networks and hypergraphs. Let $\\mathcal{H} = (V, E)$ be a $3$-uniform hypergraph with node set $V$ and hyperedge set $E$. Its pairwise projection is the simple graph $G = (V, \\mathcal{E})$ obtained by replacing each hyperedge $e \\in E$ with all pairwise edges among its member nodes, that is, if $e = \\{u,v,w\\}$, then $\\{u,v\\}, \\{v,w\\}, \\{u,w\\} \\in \\mathcal{E}$. Consider two synchronous, discrete-time adoption dynamics starting from an initial seed set $S_0 \\subseteq V$: \n- The Linear Threshold Model (LTM) on $G$, where an inactive node $x$ becomes active at time $t+1$ if and only if at least $m$ of its neighbors in $G$ are active at time $t$, with $m \\in \\mathbb{N}$ an integer threshold.\n- A Higher-Order Cascade Model (HCM) on $\\mathcal{H}$ with triadic synergy, where an inactive node $x$ becomes active at time $t+1$ if and only if there exists some hyperedge $e \\in E$ containing $x$ for which at least $s$ of the other members of $e$ are active at time $t$, with $s \\in \\{1,2\\}$ the triadic synergy threshold (since each $3$-uniform hyperedge has exactly $2$ co-members for any node).\n\nYou are to construct and analyze a counterexample family where the pairwise projection $G$ predicts no cascade under LTM, but the higher-order HCM on $\\mathcal{H}$ exhibits a global cascade driven by triadic synergy. To do so, use the edge-sharing triangle chain hypergraph defined as follows. For any integer length $L \\ge 0$, define $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$ of size $|V| = L+2$, and define the hyperedge set $E = \\{e_i : i = 0,1,\\dots,L-1\\}$ where $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$. Thus, consecutive hyperedges share the edge $\\{v_{i+1}, v_{i+2}\\}$. The initial seed set is $S_0 = \\{v_0, v_1\\}$.\n\nStarting from the core definitions of hypergraph projection, the Linear Threshold Model (LTM), and higher-order triadic synergy HCM given above (and no other shortcut formulas), do the following:\n\n1. Prove, by reasoning from the given definitions, that for any $L \\ge 1$, the LTM on the pairwise projection $G$ with threshold $m = 3$ and seed set $S_0 = \\{v_0, v_1\\}$ does not activate any additional nodes beyond $S_0$. Explain precisely why no inactive node meets the activation condition under LTM in this construction.\n\n2. Prove, by reasoning from the given definitions, that for any $L \\ge 1$, the HCM on the hypergraph $\\mathcal{H}$ with triadic synergy threshold $s = 2$ and seed set $S_0 = \\{v_0, v_1\\}$ activates all nodes, that is, exhibits a global cascade. Provide a clear inductive argument along the chain of edge-sharing triangles showing that each successive non-seed node becomes active.\n\n3. Define the quantitative cascade gap $g(L,m,s)$ as the difference in final active set sizes between the HCM and the LTM on the same construction: \n$$\ng(L,m,s) \\triangleq |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|,\n$$\nwhere $\\mathcal{A}_{\\mathrm{HCM}}(L,s)$ and $\\mathcal{A}_{\\mathrm{LTM}}(L,m)$ denote the respective final (fixed-point) active sets starting from $S_0$. Derive $g(L,m,s)$ for the provided test suite cases below, by applying only the model definitions and your reasoning from steps $1$ and $2$.\n\n4. Implement a program that constructs the hypergraph and its pairwise projection for arbitrary $L$, simulates both dynamics from $S_0$ until the fixed point using the definitions above, and outputs the cascade gap $g(L,m,s)$ for each test case listed below. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$). Each $r_i$ must be an integer. No physical units or angles are involved, and no percentages are expected.\n\nTest suite (each case is $(L,m,s)$):\n- Case $1$: $(L,m,s) = (5,3,2)$.\n- Case $2$: $(L,m,s) = (5,2,2)$.\n- Case $3$: $(L,m,s) = (1,3,2)$.\n- Case $4$: $(L,m,s) = (0,3,2)$.\n- Case $5$: $(L,m,s) = (7,3,1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the cases above (for example, $[r_1,r_2,r_3,r_4,r_5]$).",
            "solution": "The problem presents a valid research question in the modeling of complex systems, comparing contagion dynamics on a hypergraph with dynamics on its pairwise projection. All definitions are mathematically precise, and the proposed construction is well-defined, making the problem scientifically grounded, well-posed, and objective. We can therefore proceed with a formal solution.\n\nThe solution is structured into three parts as requested: first, an analysis of the Linear Threshold Model (LTM) on the pairwise projection; second, an analysis of the Higher-Order Cascade Model (HCM) on the hypergraph; and third, the derivation of the cascade gap $g(L,m,s)$ for the specified test cases.\n\nLet us first establish the structure of the hypergraph $\\mathcal{H} = (V, E)$ and its projection $G = (V, \\mathcal{E})$.\nThe node set is $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$, with $|V| = L+2$.\nThe hyperedge set is $E = \\{e_i : i = 0, \\dots, L-1\\}$, where $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$.\nThe edge set $\\mathcal{E}$ of the projection graph $G$ is formed by taking the union of all pairwise edges from each hyperedge. For each $e_i \\in E$, we add the edges $\\{v_i, v_{i+1}\\}$, $\\{v_i, v_{i+2}\\}$, and $\\{v_{i+1}, v_{i+2}\\}$ to $\\mathcal{E}$. The initial set of active nodes for both dynamics is $S_0 = \\{v_0, v_1\\}$.\n\n**1. Analysis of the Linear Threshold Model (LTM)**\n\nWe are asked to prove that for any $L \\ge 1$ and threshold $m=3$, the LTM cascade starting from $S_0$ does not activate any additional nodes.\n\nThe LTM activates an inactive node $x$ if the number of its active neighbors in $G$, denoted $|N_G(x) \\cap S_t|$, is at least $m$. At time $t=0$, the active set is $S_0 = \\{v_0, v_1\\}$. We must check if any inactive node $v_k \\in V \\setminus S_0$ (where $k \\ge 2$) can be activated.\n\n- **Case for node $v_2$**: The node $v_2$ is present in the hyperedge $e_0 = \\{v_0, v_1, v_2\\}$. The projection of this hyperedge creates a triangle, making $v_0$ and $v_1$ neighbors of $v_2$ in $G$. For $L \\ge 1$, this is the only hyperedge that contains both $v_2$ and any node from $S_0$. Specifically, $e_1 = \\{v_1, v_2, v_3\\}$ (if $L \\ge 2$) also gives $v_1$ as a neighbor of $v_2$, but this is not a new neighbor. No other hyperedge can connect $v_2$ to $v_0$ or $v_1$. Thus, the neighbors of $v_2$ that are in $S_0$ are precisely $\\{v_0, v_1\\}$. The number of active neighbors for $v_2$ at $t=0$ is $|N_G(v_2) \\cap S_0| = |\\{v_0, v_1\\}| = 2$. With a threshold of $m=3$, the condition for activation is not met ($2 < 3$). Therefore, $v_2$ does not become active.\n\n- **Case for nodes $v_k$ where $k \\ge 3$**: An edge $\\{v_j, v_k\\}$ exists in $G$ only if there is a hyperedge $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$ that contains both $v_j$ and $v_k$. For $v_k$ (with $k \\ge 3$) to have a neighbor from $S_0=\\{v_0, v_1\\}$, there must be some hyperedge $e_i$ containing $\\{v_k, v_0\\}$ or $\\{v_k, v_1\\}$. The indices of nodes in any hyperedge $e_i$ are $i, i+1, i+2$. For $e_i$ to contain $v_0$ or $v_1$, its constituent indices must include $0$ or $1$. This occurs only for $e_0 = \\{v_0, v_1, v_2\\}$. However, $e_0$ does not contain any node $v_k$ with $k \\ge 3$. Therefore, for any $k \\ge 3$, the neighborhood $N_G(v_k)$ does not contain $v_0$ or $v_1$. It follows that $|N_G(v_k) \\cap S_0| = 0$. With a threshold $m=3$, these nodes cannot activate.\n\nSince no inactive node meets the activation threshold at $t=0$, the set of active nodes at $t=1$ is unchanged, i.e., $S_1 = S_0$. The system has reached a fixed point. The final active set is $\\mathcal{A}_{\\mathrm{LTM}}(L,3) = S_0 = \\{v_0, v_1\\}$, and its size is $|\\mathcal{A}_{\\mathrm{LTM}}(L,3)| = 2$ for any $L \\ge 1$.\n\n**2. Analysis of the Higher-Order Cascade Model (HCM)**\n\nWe are asked to prove that for any $L \\ge 1$ and triadic synergy threshold $s=2$, the HCM cascade starting from $S_0$ activates all nodes in $V$.\n\nThe HCM activates an inactive node $x$ if there exists a hyperedge $e \\in E$ containing $x$ such that at least $s$ of the other members of $e$ are active. For a $3$-uniform hyperedge $e=\\{x,y,z\\}$ and $s=2$, node $x$ activates if both $y$ and $z$ are active. We prove the global cascade by induction on the node index.\n\n- **Base Case**: At $t=0$, $S_0 = \\{v_0, v_1\\}$. We check the status of inactive node $v_2$ at the next time step, $t=1$. Node $v_2$ is a member of hyperedge $e_0 = \\{v_0, v_1, v_2\\}$. The other members of $e_0$ are $\\{v_0, v_1\\}$. Both of these nodes are in $S_0$ and are therefore active. The count of active co-members is $2$. Since this meets the threshold $s=2$, node $v_2$ becomes active at $t=1$. The active set grows to $S_1 = S_0 \\cup \\{v_2\\} = \\{v_0, v_1, v_2\\}$.\n\n- **Inductive Step**: Assume that at time step $t=k-1$, all nodes up to $v_{k+1}$ are active, i.e., $S_{k-1} = \\{v_0, v_1, \\dots, v_{k+1}\\}$ for $k \\ge 1$. We will show that node $v_{k+2}$ becomes active at time step $t=k$.\nConsider the inactive node $v_{k+2}$. It is a member of the hyperedge $e_k = \\{v_k, v_{k+1}, v_{k+2}\\}$. The other members of this hyperedge are $\\{v_k, v_{k+1}\\}$. By the inductive hypothesis, both $v_k$ and $v_{k+1}$ are in the active set $S_{k-1}$. Thus, $v_{k+2}$ has $2$ active co-members in $e_k$. Since $s=2$, the condition for activation is met, and $v_{k+2}$ becomes active at time $t=k$.\nSimultaneously, no node $v_j$ with $j > k+2$ can activate, as any hyperedge containing $v_j$ has members with indices close to $j$, which are not yet active by the hypothesis.\n\nBy induction, the activation propagates sequentially along the chain: $v_2$ activates at $t=1$, $v_3$ activates at $t=2$, and so on, until the final node $v_{L+1}$ activates at $t=L$. The process terminates when all nodes in $V$ are active. The final active set is $\\mathcal{A}_{\\mathrm{HCM}}(L,2) = V$, and its size is $|\\mathcalA_{\\mathrm{HCM}}(L,2)| = L+2$ for any $L \\ge 1$.\n\n**3. Derivation of the Cascade Gap $g(L,m,s)$**\n\nThe cascade gap is defined as $g(L,m,s) = |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|$. We now calculate this for each test case.\n\n- **Case 1: $(L,m,s) = (5,3,2)$**\n    From Part 1, with $m=3$, the LTM cascade stalls. $|\\mathcal{A}_{\\mathrm{LTM}}(5,3)| = 2$.\n    From Part 2, with $s=2$, the HCM cascade is global. $|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = L+2 = 5+2 = 7$.\n    $g(5,3,2) = 7 - 2 = 5$.\n\n- **Case 2: $(L,m,s) = (5,2,2)$**\n    For LTM with $m=2$: At $t=0$, $S_0=\\{v_0,v_1\\}$. Node $v_2$ has $2$ active neighbors ($v_0, v_1$), which meets the threshold $m=2$. $v_2$ activates, so $S_1=\\{v_0,v_1,v_2\\}$. At $t=1$, node $v_3$ (neighbors $\\{v_1,v_2,v_4\\}$) has $2$ active neighbors ($v_1,v_2$). $v_3$ activates. This continues, with each $v_k$ being activated by its predecessors $v_{k-2}$ and $v_{k-1}$, causing a global cascade. $|\\mathcal{A}_{\\mathrm{LTM}}(5,2)| = L+2 = 7$.\n    For HCM with $s=2$, the cascade is global. $|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = 7$.\n    $g(5,2,2) = 7 - 7 = 0$.\n\n- **Case 3: $(L,m,s) = (1,3,2)$**\n    For $L=1$, $V=\\{v_0,v_1,v_2\\}$ and $E=\\{e_0\\}=\\{v_0,v_1,v_2\\}$.\n    LTM with $m=3$: The graph $G$ is a $3$-clique. Node $v_2$ has $2$ active neighbors from $S_0$. Since $2 < 3$, it does not activate. $|\\mathcal{A}_{\\mathrm{LTM}}(1,3)| = 2$.\n    HCM with $s=2$: Node $v_2$ in $e_0$ has $2$ active co-members from $S_0$. It activates. $|\\mathcal{A}_{\\mathrm{HCM}}(1,2)| = 3$.\n    $g(1,3,2) = 3 - 2 = 1$.\n\n- **Case 4: $(L,m,s) = (0,3,2)$**\n    For $L=0$, $V=\\{v_0,v_1\\}$ and $E=\\emptyset$. The initial set $S_0=V$ contains all nodes. Both dynamics start and end at the same state with all nodes active.\n    $|\\mathcal{A}_{\\mathrm{LTM}}(0,3)| = 2$ and $|\\mathcal{A}_{\\mathrm{HCM}}(0,2)| = 2$.\n    $g(0,3,2) = 2 - 2 = 0$.\n\n- **Case 5: $(L,m,s) = (7,3,1)$**\n    LTM with $m=3$: Cascade stalls. $|\\mathcal{A}_{\\mathrm{LTM}}(7,3)| = 2$.\n    HCM with $s=1$: An inactive node needs only one active co-member in a hyperedge to activate.\n    At $t=0$ with $S_0=\\{v_0,v_1\\}$:\n    Node $v_2$ (in $e_0=\\{v_0,v_1,v_2\\}$) sees $2$ active co-members ($\\{v_0,v_1\\}$). $2 \\ge 1$, so $v_2$ activates.\n    Node $v_3$ (in $e_1=\\{v_1,v_2,v_3\\}$) sees $1$ active co-member ($v_1$). $1 \\ge 1$, so $v_3$ activates.\n    At the next step, $S_1=\\{v_0,v_1,v_2,v_3\\}$, which then allows $v_4$ and $v_5$ to activate, and so on. The cascade is global. $|\\mathcal{A}_{\\mathrm{HCM}}(7,1)| = L+2 = 7+2 = 9$.\n    $g(7,3,1) = 9 - 2 = 7$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cascade gap problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # (L, m, s)\n        (5, 3, 2),\n        (5, 2, 2),\n        (1, 3, 2),\n        (0, 3, 2),\n        (7, 3, 1),\n    ]\n\n    def calculate_gap(L, m, s):\n        \"\"\"\n        Calculates the cascade gap for a given (L, m, s) configuration.\n        \"\"\"\n        num_nodes = L + 2\n        nodes = set(range(num_nodes))\n        \n        # Handle L=0 case: no hyperedges, S0 is the whole set\n        if L < 0: # Technically problem states L>=0, but as a guard\n            return 0\n        \n        hyperedges = []\n        if L >= 1:\n            for i in range(L):\n                hyperedges.append(frozenset({i, i + 1, i + 2}))\n\n        # --- LTM Simulation ---\n        active_ltm = {0, 1}\n        \n        # Build pairwise projection graph G if there are hyperedges\n        adj = {i: set() for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                u, v, w = he\n                adj[u].add(v)\n                adj[v].add(u)\n                adj[u].add(w)\n                adj[w].add(u)\n                adj[v].add(w)\n                adj[w].add(v)\n        \n        while True:\n            newly_activated_ltm = set()\n            inactive_nodes = nodes - active_ltm\n            if not inactive_nodes:\n                break\n                \n            for node in inactive_nodes:\n                active_neighbors_count = len(adj[node].intersection(active_ltm))\n                if active_neighbors_count >= m:\n                    newly_activated_ltm.add(node)\n            \n            if not newly_activated_ltm:\n                break\n            \n            active_ltm.update(newly_activated_ltm)\n        \n        final_size_ltm = len(active_ltm)\n\n        # --- HCM Simulation ---\n        active_hcm = {0, 1}\n        \n        # Pre-build a map from node to its containing hyperedges for efficiency\n        node_to_hyperedges = {i: [] for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                for node in he:\n                    node_to_hyperedges[node].append(he)\n            \n        while True:\n            newly_activated_hcm = set()\n            inactive_nodes = nodes - active_hcm\n            if not inactive_nodes:\n                break\n\n            for node in inactive_nodes:\n                is_activated = False\n                for he in node_to_hyperedges[node]:\n                    co_members = he - {node}\n                    active_co_members_count = len(co_members.intersection(active_hcm))\n                    if active_co_members_count >= s:\n                        is_activated = True\n                        break # Found an activating hyperedge\n                \n                if is_activated:\n                    newly_activated_hcm.add(node)\n\n            if not newly_activated_hcm:\n                break\n            \n            active_hcm.update(newly_activated_hcm)\n            \n        final_size_hcm = len(active_hcm)\n\n        return final_size_hcm - final_size_ltm\n\n    results = []\n    for L, m, s in test_cases:\n        gap = calculate_gap(L, m, s)\n        results.append(gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}