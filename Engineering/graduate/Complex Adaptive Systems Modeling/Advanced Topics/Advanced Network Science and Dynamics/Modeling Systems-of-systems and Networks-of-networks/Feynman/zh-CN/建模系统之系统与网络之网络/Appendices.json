{
    "hands_on_practices": [
        {
            "introduction": "在复杂系统分析中，识别网络中的社区结构是一项基本任务。当我们将此概念扩展到由多个交互层组成的“网络之网络”（network-of-networks）时，一个关键挑战是如何识别在各个层之间保持一致性的社区。本实践将通过推导多层模块度函数与跨层社区稳定性之间的关系，来探索这一挑战。这个练习将揭示层间耦合参数 $\\omega$ 如何作为一种正则化项，鼓励算法发现更加稳定和连贯的跨层社区结构，这是多层系统建模中的一个核心思想。",
            "id": "4130133",
            "problem": "考虑一个被建模为多层图的网络集合，该图有 $L \\geq 2$ 个层，每层有 $N \\geq 2$ 个节点，代表一个相互依存的系统之系统。在每个层 $\\ell \\in \\{1,\\dots,L\\}$ 中，无向的层内拓扑由一个邻接矩阵 $A^{[\\ell]} \\in \\mathbb{R}^{N \\times N}$ 指定，该矩阵具有非负权重、度 $k_{i}^{[\\ell]} = \\sum_{j=1}^{N} A_{ij}^{[\\ell]}$ 和总层内边权重 $m^{[\\ell]} = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} A_{ij}^{[\\ell]}$。对于每个层 $\\ell$ 中的每个节点 $i$，其社群分配由 $g_{i}^{[\\ell]} \\in \\{1,\\dots,K\\}$ 给出，其中 $K$ 不是先验固定的。层 $\\ell$ 中的经典单层模块度定义为\n$$\nQ^{[\\ell]}(g) = \\frac{1}{2 m^{[\\ell]}} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left( A_{ij}^{[\\ell]} - \\gamma^{[\\ell]} \\frac{k_{i}^{[\\ell]} k_{j}^{[\\ell]}}{2 m^{[\\ell]}} \\right) \\delta\\!\\left(g_{i}^{[\\ell]}, g_{j}^{[\\ell]}\\right),\n$$\n其中 $\\gamma^{[\\ell]} > 0$ 是一个分辨率参数，$\\delta(\\cdot,\\cdot)$ 是克罗内克 delta 函数。定义连续层中相同节点之间的层间耦合为一个均匀的非负权重 $\\omega$，使得只有节点对 $(i,\\ell)$ 和 $(i,\\ell+1)$ 以权重 $\\omega$ 耦合，适用于所有 $i \\in \\{1,\\dots,N\\}$ 和 $\\ell \\in \\{1,\\dots,L-1\\}$，并且不存在其他层间边。令归一化常数为\n$$\nM = \\sum_{\\ell=1}^{L} 2 m^{[\\ell]},\n$$\n它与 $\\omega$ 无关。考虑多层质量函数\n$$\nQ(\\omega,g) = \\frac{1}{M} \\left[ \\sum_{\\ell=1}^{L} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left( A_{ij}^{[\\ell]} - \\gamma^{[\\ell]} \\frac{k_{i}^{[\\ell]} k_{j}^{[\\ell]}}{2 m^{[\\ell]}} \\right) \\delta\\!\\left(g_{i}^{[\\ell]}, g_{j}^{[\\ell]}\\right) + \\omega \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right) \\right].\n$$\n将跨层的社群检测稳定性定义为平均持续分数\n$$\nS(g) = \\frac{1}{N(L-1)} \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right).\n$$\n从上述基本定义出发，推导 $Q(\\omega,g)$ 和 $S(g)$ 之间的关系，该关系量化了层间耦合参数 $\\omega$ 如何对跨层的社群持续性进行正则化。具体来说，计算 $\\frac{\\partial Q(\\omega,g)}{\\partial \\omega}$ 关于 $S(g)$、$N$、$L$ 和 $M$ 的闭式表达式。将您的最终答案表示为单个解析表达式。不需要数值近似或四舍五入。此问题中不涉及角度。",
            "solution": "该问题已经过验证，并被确定为一个有效的、适定的科学问题。所有提供的定义在网络科学领域都是标准的，并且内部一致。该任务是基于这些定义的形式化数学推导。\n\n目标是计算多层质量函数 $Q(\\omega,g)$ 关于层间耦合参数 $\\omega$ 的偏导数。多层质量函数由下式给出：\n$$\nQ(\\omega,g) = \\frac{1}{M} \\left[ \\sum_{\\ell=1}^{L} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left( A_{ij}^{[\\ell]} - \\gamma^{[\\ell]} \\frac{k_{i}^{[\\ell]} k_{j}^{[\\ell]}}{2 m^{[\\ell]}} \\right) \\delta\\!\\left(g_{i}^{[\\ell]}, g_{j}^{[\\ell]}\\right) + \\omega \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right) \\right]\n$$\n为了简化求导的表达式，我们可以将括号内的项分为一个与 $\\omega$ 无关的分量和一个与 $\\omega$ 线性相关的分量。我们定义：\n$$\n\\text{Term}_{A} = \\sum_{\\ell=1}^{L} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left( A_{ij}^{[\\ell]} - \\gamma^{[\\ell]} \\frac{k_{i}^{[\\ell]} k_{j}^{[\\ell]}}{2 m^{[\\ell]}} \\right) \\delta\\!\\left(g_{i}^{[\\ell]}, g_{j}^{[\\ell]}\\right)\n$$\n和\n$$\n\\text{Term}_{B} = \\omega \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right)\n$$\n质量函数可以写作：\n$$\nQ(\\omega,g) = \\frac{1}{M} \\left( \\text{Term}_{A} + \\text{Term}_{B} \\right)\n$$\n我们需要计算偏导数 $\\frac{\\partial Q(\\omega,g)}{\\partial \\omega}$。求导是相对于 $\\omega$进行的，在此操作中，社群分配 $g = \\{g_i^{[\\ell]}\\}$ 和所有其他网络参数（$A^{[\\ell]}$、$N$、$L$ 等）均被视为常数。\n\n利用微分算子的线性性质：\n$$\n\\frac{\\partial Q(\\omega,g)}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} \\left[ \\frac{1}{M} \\left( \\text{Term}_{A} + \\text{Term}_{B} \\right) \\right] = \\frac{1}{M} \\left( \\frac{\\partial \\text{Term}_{A}}{\\partial \\omega} + \\frac{\\partial \\text{Term}_{B}}{\\partial \\omega} \\right)\n$$\n首先，我们考虑 $\\text{Term}_{A}$ 的导数。该项代表层内模块度之和。通过观察可知，$\\text{Term}_{A}$ 不包含变量 $\\omega$。因此，它关于 $\\omega$ 的偏导数为零：\n$$\n\\frac{\\partial \\text{Term}_{A}}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} \\left[ \\sum_{\\ell=1}^{L} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left( A_{ij}^{[\\ell]} - \\gamma^{[\\ell]} \\frac{k_{i}^{[\\ell]} k_{j}^{[\\ell]}}{2 m^{[\\ell]}} \\right) \\delta\\!\\left(g_{i}^{[\\ell]}, g_{j}^{[\\ell]}\\right) \\right] = 0\n$$\n接下来，我们计算 $\\text{Term}_{B}$ 的导数。该项代表层间耦合的贡献。\n$$\n\\frac{\\partial \\text{Term}_{B}}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} \\left[ \\omega \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right) \\right]\n$$\n求和项相对于 $\\omega$ 是一个常数。令 $C = \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right)$。表达式变为 $\\frac{\\partial}{\\partial \\omega} (\\omega C)$，结果就是 $C$。因此，\n$$\n\\frac{\\partial \\text{Term}_{B}}{\\partial \\omega} = \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right)\n$$\n将这些结果代回到 $Q(\\omega,g)$ 的导数表达式中：\n$$\n\\frac{\\partial Q(\\omega,g)}{\\partial \\omega} = \\frac{1}{M} \\left( 0 + \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right) \\right) = \\frac{1}{M} \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right)\n$$\n问题要求最终答案用社群检测稳定性 $S(g)$ 来表示，其定义为：\n$$\nS(g) = \\frac{1}{N(L-1)} \\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right)\n$$\n根据这个定义，我们可以将求和项表示为：\n$$\n\\sum_{i=1}^{N} \\sum_{\\ell=1}^{L-1} \\delta\\!\\left(g_{i}^{[\\ell]}, g_{i}^{[\\ell+1]}\\right) = N(L-1) S(g)\n$$\n最后，我们将此式代入我们的导数表达式中：\n$$\n\\frac{\\partial Q(\\omega,g)}{\\partial \\omega} = \\frac{N(L-1)S(g)}{M}\n$$\n这个结果量化了层间耦合参数 $\\omega$ 和社群持续性之间的关系。它表明，多层质量函数相对于 $\\omega$ 的变化率与平均持续分数 $S(g)$ 成正比。因此，在 $\\omega$ 不为零的情况下最大化 $Q$ 会隐式地鼓励那些在各层之间更稳定的解（即划分 $g$）。",
            "answer": "$$\n\\boxed{\\frac{N(L-1)S(g)}{M}}\n$$"
        },
        {
            "introduction": "系统之系统（Systems-of-systems）最引人注目的特性之一是其可能经历灾难性的级联失效，导致系统功能突然崩溃。由于这些过程的非线性特性，通过纯解析方法进行研究往往非常困难，因此计算模拟成为一种不可或缺的工具。本实践要求您构建一个相互依赖网络的级联失效模型。通过模拟，您将亲身体验系统在压力下如何从突然崩溃转变为平稳退化，并量化确定需要多少“加固”节点才能确保系统的韧性，这对于设计稳健的复杂系统至关重要。",
            "id": "4130113",
            "problem": "考虑一个由两个相互依赖的网络层组成的系统，表示为层 $\\mathcal{A}$ 和层 $\\mathcal{B}$，每层都有 $N$ 个节点。层 $\\mathcal{A}$ 中的每个节点都依赖于其在层 $\\mathcal{B}$ 中的对应节点，反之亦然，形成一对一的相互依赖映射。每层中有一部分比例为 $\\rho$ 的节点被指定为增强（自主）节点，它们不需要其相互依赖的对应节点正常工作；所有其余节点都是非增强节点，需要其相互依赖的对应节点的结构功能性。最初，每层中的每个节点都以概率 $1-p$ 被独立移除，其中 $p \\in [0,1]$ 是保留的比例。\n\n层内的结构功能性按以下规则定义：在当前活动的节点中，一个节点是结构功能性的，当且仅当它属于最大连通分量（LCC），或者属于任何包含至少一个活动的增强节点的连通分量。相互依赖功能性定义如下：层 $\\mathcal{A}$ 中的一个节点是功能性活动的，当且仅当它在层 $\\mathcal{A}$ 中是结构功能性的，并且它要么在层 $\\mathcal{A}$ 中是增强节点，要么其在层 $\\mathcal{B}$ 中的对应节点是结构功能性的。相同的规则对称地应用于层 $\\mathcal{B}$。级联过程迭代进行：给定两层中的活动节点集，重新计算结构功能性集，并应用相互依赖规则，直到达到一个不动点。令 $S(p)$ 表示最终的序参量，定义为 $S(p) = \\min\\{ f_{\\mathcal{A}}(p), f_{\\mathcal{B}}(p) \\}$，其中 $f_{\\mathcal{A}}(p)$ 和 $f_{\\mathcal{B}}(p)$ 是级联收敛后层 $\\mathcal{A}$ 和层 $\\mathcal{B}$ 中功能性活动节点的最终比例。\n\n如果在网格中连续的 $p$ 值之间存在一个降幅 $\\Delta S = S(p_{i}) - S(p_{i+1})$ 超过阈值 $\\tau$，则认为发生了突变崩溃。消除突变崩溃所需的最小增强节点比例是最小的 $\\rho$，使得在整个 $p$ 网格上，没有这样的降幅超过 $\\tau$。\n\n从以下基本依据出发：\n- 通过 Configuration Model 进行随机图建模：对于目标度分布 $P(k)$ 和度序列 $\\{k_i\\}_{i=1}^N$，通过匹配“桩”（stubs）来形成边，尽可能避免自环和多重边，从而生成一个近似 $P(k)$ 的无向简单图。\n- 渗流和连通分量：对于一组活动节点，根据上述定义，结构功能性由其是否属于最大连通分量（LCC）或包含至少一个增强节点的连通分量来确定。\n- 迭代的相互依赖级联：通过重复应用结构功能性和依赖性约束，直到不再发生变化，从而达到相互依赖更新规则的不动点。\n\n你的任务是实现一个程序，对每个测试用例，估算最小的增强比例 $\\rho^{\\star}$，使得系统在指定的 $p$ 值网格上，根据阈值 $\\tau$ 不表现出突变崩溃。通过改变每层的度分布来进行关于度异质性的敏感性分析。为保证可复现性，请使用固定的随机种子。\n\n必需的建模细节和数值规格：\n- 每层节点数为 $N = 2000$。\n- 两层对应节点索引之间存在一对一的相互依赖映射。\n- 在每个测试用例中，增强节点在每层中均匀随机选择，两层中的比例 $\\rho$ 相同。\n- 初始随机移除独立应用于两层，保留概率为 $p$。\n- $p$ 网格从 $p=1.0$ 到 $p=0.0$（含两端）均匀分布 $31$ 个点。\n- 突变崩溃阈值为 $\\tau = 0.12$。\n- 最小增强比例 $\\rho^{\\star}$ 必须通过在均匀网格 $\\{0.00, 0.05, 0.10, \\dots, 0.50\\}$ 上扫描 $\\rho$ 来确定，选择能够消除整个 $p$ 网格上任何突变降幅的最小 $\\rho$。如果此网格中没有 $\\rho$ 能消除突变性，则报告扫描的最大值。\n\n度异质性测试套件：\n- 测试用例 1 (happy path)：两层均为泊松度分布，平均度 $\\langle k \\rangle = 3.0$。\n- 测试用例 2 (高异质性)：两层均为截断离散幂律度分布，指数 $\\gamma = 2.3$，最小度 $k_{\\min} = 1$，最大度 $k_{\\max} = 50$。\n- 测试用例 3 (接近连通性阈值的边界条件)：两层均为泊松度分布，平均度 $\\langle k \\rangle = 2.0$。\n\n对于所有测试用例，独立生成具有相同目标度分布但独立实现的两层网络。使用固定的随机种子以确保确定性输出。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素是对应测试用例估算的最小增强比例 $\\rho^{\\star}$，按测试用例 1、测试用例 2 和测试用例 3 的顺序排列，每个都格式化为小数点后三位的小数（例如，$[0.150,0.100,0.250]$）。本问题不涉及物理单位；不涉及角度和百分比。最终输出必须严格遵循此格式且为单行。",
            "solution": "用户提供的问题经评估有效。这是一个在复杂自适应系统建模领域中，关于相互依赖网络渗流问题的适定（well-posed）、有科学依据的问题。问题陈述是自洽的，为计算求解提供了所有必要的参数、定义和约束。它没有歧义、主观断言或科学谬误。\n\n解决方法涉及对一个由两个相互依赖网络组成的系统上所描述的级联失效过程进行直接模拟。目标是确定为防止不同网络拓扑结构下系统发生突变崩溃所需的最小增强节点比例 $\\rho^{\\star}$。突变崩溃被定义为系统序参量 $S(p)$ 在初始节点保留概率 $p$ 的网格上的连续点之间出现的、大于阈值 $\\tau = 0.12$ 的下降。\n\n该方法的核心分为三个主要部分：网络生成、级联模拟以及对 $\\rho^{\\star}$ 的参数搜索。\n\n### 1. 网络生成\n\n问题指定了两个相互依赖的网络层 $\\mathcal{A}$ 和 $\\mathcal{B}$，每层有 $N=2000$ 个节点。每层的拓扑结构都使用基于目标度分布 $P(k)$ 的 Configuration Model 独立生成。\n\n**度序列生成：**\n对每个测试用例，从指定的分布中为每层抽取一个度序列 $\\{k_i\\}_{i=1}^N$。\n- **泊松分布：** 对于平均度 $\\langle k \\rangle$，节点度为 $k$ 的概率由概率质量函数给出：\n$$ P(k) = \\frac{e^{-\\langle k \\rangle} \\langle k \\rangle^k}{k!} $$\n- **截断幂律分布：** 对于指数 $\\gamma$ 和度范围 $[k_{\\min}, k_{\\max}]$，离散概率质量函数为：\n$$ P(k) = C k^{-\\gamma}, \\quad k \\in \\{k_{\\min}, k_{\\min}+1, \\dots, k_{\\max}\\} $$\n其中 $C = \\left(\\sum_{j=k_{\\min}}^{k_{\\max}} j^{-\\gamma}\\right)^{-1}$ 是归一化常数。\n\n为了使 Configuration Model 适用，度之和 $\\sum_{i=1}^N k_i$ 必须为偶数。如果生成了奇数和，则会进行微小修正（例如，将随机选择的一个节点的度增加1）以满足此约束。\n\n**Configuration Model：**\n从度序列 $\\{k_i\\}$ 构建一个无向简单图，步骤如下：\n1. 创建一个“桩”（stubs）列表，其中每个节点 $i$ 出现 $k_i$ 次。\n2. 随机排列这个“桩”列表。\n3. 将排列后的列表中相邻的“桩”（例如，桩 $2j$ 与 $2j+1$）配对以形成边。\n4. 为了满足“尽可能避免自环和多重边”的要求，会对生成的边集进行验证。如果形成了自环（连接节点自身的边）或多重边（重复的边），则重复排列和配对过程，直到获得一个有效的简单图。对于大型网络，此过程预计会很快成功。两个网络层 $\\mathcal{A}$ 和 $\\mathcal{B}$ 是根据相同的度分布参数生成的独立实现。\n\n### 2. 级联模拟\n\n对于给定的一对网络、固定的增强节点比例 $\\rho$ 和初始保留概率 $p$，级联失效模拟如下。\n\n**步骤 0：初始化**\n- 在每层中，均匀随机选择比例为 $\\rho$ 的节点作为“增强”节点。设这些集合为 $\\mathcal{V}_{\\text{reinf},\\mathcal{A}}$ 和 $\\mathcal{V}_{\\text{reinf},\\mathcal{B}}$。\n- 模拟初始随机失效。每层中的每个节点以 $1-p$ 的概率被移除。这定义了初始的活动节点集 $\\mathcal{V}^{(0)}_{\\mathcal{A}}$ 和 $\\mathcal{V}^{(0)}_{\\mathcal{B}}$。\n\n**步骤 1：迭代级联**\n系统状态在离散时间步 $t=0, 1, 2, \\dots$ 中演化，直到达到不动点。在每个步骤中，活动节点集根据两个规则更新：结构功能性和相互依赖性。\n\n**A. 结构功能性：**\n给定活动节点集 $\\mathcal{V}^{(t)}_{\\mathcal{A}}$，分析由这些节点诱导的子图。一个节点 $i \\in \\mathcal{V}^{(t)}_{\\mathcal{A}}$ 被认为是结构功能性的，如果它满足以下至少一个条件：\n1. 节点 $i$ 属于该子图的最大连通分量 (LCC)。\n2. 节点 $i$ 属于一个包含至少一个活动的增强节点的连通分量。也就是说，如果 $C_j$ 是包含 $i$ 的分量，则 $C_j \\cap \\mathcal{V}_{\\text{reinf},\\mathcal{A}} \\cap \\mathcal{V}^{(t)}_{\\mathcal{A}} \\neq \\emptyset$。\n\n此规则定义了每层的结构功能性节点集 $\\mathcal{F}^{(t)}_{\\mathcal{A}}$ 和 $\\mathcal{F}^{(t)}_{\\mathcal{B}}$。这通过首先使用广度优先搜索 (BFS) 或深度优先搜索 (DFS) 算法找到活动子图的所有连通分量来实现。\n\n**B. 相互依赖功能性：**\n下一次迭代的活动节点集 $\\mathcal{V}^{(t+1)}$ 是通过应用相互依赖规则来确定的。层 $\\mathcal{A}$ 中的一个节点 $i$ 保持活动状态，当且仅当它在其自身层中是结构功能性的，并且其支持条件得到满足。支持条件是节点本身是增强的，或者其在层 $\\mathcal{B}$ 中的对应节点是结构功能性的。形式上：\n$$ \\mathcal{V}^{(t+1)}_{\\mathcal{A}} = \\left\\{ i \\in \\mathcal{F}^{(t)}_{\\mathcal{A}} \\mid (i \\in \\mathcal{V}_{\\text{reinf},\\mathcal{A}}) \\lor (i \\in \\mathcal{F}^{(t)}_{\\mathcal{B}}) \\right\\} $$\n一个对称的规则适用于确定 $\\mathcal{V}^{(t+1)}_{\\mathcal{B}}$：\n$$ \\mathcal{V}^{(t+1)}_{\\mathcal{B}} = \\left\\{ i \\in \\mathcal{F}^{(t)}_{\\mathcal{B}} \\mid (i \\in \\mathcal{V}_{\\text{reinf},\\mathcal{B}}) \\lor (i \\in \\mathcal{F}^{(t)}_{\\mathcal{A}}) \\right\\} $$\n\n**C. 收敛：**\n迭代持续进行，直到活动节点集不再变化，即 $\\mathcal{V}^{(t+1)}_{\\mathcal{A}} = \\mathcal{V}^{(t)}_{\\mathcal{A}}$ 且 $\\mathcal{V}^{(t+1)}_{\\mathcal{B}} = \\mathcal{V}^{(t)}_{\\mathcal{B}}$。由于在级联过程中节点只会被移除，这个单调过程保证会收敛到一个唯一的不动点。\n\n**步骤 2：序参量计算**\n收敛后，每层中功能性活动节点的最终比例为 $f_{\\mathcal{A}}(p) = |\\mathcal{V}_{\\text{final},\\mathcal{A}}| / N$ 和 $f_{\\mathcal{B}}(p) = |\\mathcal{V}_{\\text{final},\\mathcal{B}}| / N$。系统的序参量定义为 $S(p) = \\min\\{f_{\\mathcal{A}}(p), f_{\\mathcal{B}}(p)\\}$。\n\n### 3. 最小增强的参数搜索\n\n主要目标是找到能够减轻突变崩溃的最小增强比例 $\\rho^{\\star}$。这通过系统性搜索来实现。\n\n对于三个测试用例中的每一个：\n1. 网络层对 $(\\mathcal{A}, \\mathcal{B})$ 生成一次，并在整个搜索过程中保持不变。\n2. 算法遍历指定的增强比例网格 $\\rho \\in \\{0.00, 0.05, \\dots, 0.50\\}$。对于每个 $\\rho$：\n    a. 选择并固定增强节点集。\n    b. 对其网格中的每个 $p$ 值（从 $p=1.0$ 到 $p=0.0$）计算序参量 $S(p)$。\n    c. 分析得到的 $S(p)$ 对 $p$ 的曲线是否存在突变降幅。对于网格上每对连续的点 $(p_i, S(p_i))$ 和 $(p_{i+1}, S(p_{i+1}))$，计算降幅 $\\Delta S = S(p_i) - S(p_{i+1})$。\n    d. 如果任何降幅 $\\Delta S$ 超过阈值 $\\tau = 0.12$，则认为当前的 $\\rho$ 不足以防止突变崩溃，算法继续处理下一个更高的 $\\rho$ 值。\n    e. 如果遍历了整个 $p$-网格且没有降幅超过 $\\tau$，则该 $\\rho$ 值即为该测试用例的最小增强比例 $\\rho^{\\star}$。由于 $\\rho$ 是按递增顺序扫描的，第一个满足条件的即为最小值。\n3. 如果在搜索完所有直到 $0.50$ 的 $\\rho$ 值后，仍没有一个能防止突变崩溃，则将 $\\rho^{\\star}$ 报告为扫描的最大值 $0.50$。\n\n在整个过程开始时使用固定的随机种子，以确保依赖于图生成和增强节点选择的结果是确定性和可复现的。",
            "answer": "```python\nimport numpy as np\n\ndef generate_degree_sequence(dist_type, params, n_nodes, rng):\n    \"\"\"Generates a degree sequence for a given distribution.\"\"\"\n    if dist_type == 'poisson':\n        # Ensure k_i >= 1 to avoid disconnected nodes from the start\n        degrees = rng.poisson(lam=params['lam'] - 1, size=n_nodes) + 1\n    elif dist_type == 'powerlaw':\n        k_min, k_max, gamma = params['k_min'], params['k_max'], params['gamma']\n        k_range = np.arange(k_min, k_max + 1)\n        probs = k_range**(-gamma)\n        probs /= np.sum(probs)\n        degrees = rng.choice(k_range, size=n_nodes, p=probs)\n    else:\n        raise ValueError(\"Unknown distribution type\")\n\n    # Sum of degrees must be even for the Configuration Model\n    if np.sum(degrees) % 2 != 0:\n        degrees[rng.integers(0, n_nodes)] += 1\n        \n    return degrees\n\ndef generate_config_model_graph(degree_sequence, n_nodes, rng):\n    \"\"\"Generates a graph using the Configuration Model, avoiding self-loops and multi-edges.\"\"\"\n    while True:\n        stubs = np.repeat(np.arange(n_nodes), degree_sequence)\n        rng.shuffle(stubs)\n        \n        edges = set()\n        adj = [[] for _ in range(n_nodes)]\n        is_valid = True\n        \n        for i in range(0, len(stubs), 2):\n            u, v = stubs[i], stubs[i+1]\n            if u == v:\n                is_valid = False\n                break\n            \n            # Ensure order for checking multi-edges\n            edge = tuple(sorted((u, v)))\n            if edge in edges:\n                is_valid = False\n                break\n            edges.add(edge)\n\n        if is_valid:\n            for u, v in edges:\n                adj[u].append(v)\n                adj[v].append(u)\n            return adj\n\ndef find_components(adj, active_nodes, n_nodes):\n    \"\"\"Finds connected components in the subgraph of active nodes using BFS.\"\"\"\n    visited = np.zeros(n_nodes, dtype=bool)\n    components = []\n    for i in range(n_nodes):\n        if active_nodes[i] and not visited[i]:\n            component = set()\n            q = [i]\n            visited[i] = True\n            head = 0\n            while head  len(q):\n                u = q[head]\n                head += 1\n                component.add(u)\n                for v in adj[u]:\n                    if active_nodes[v] and not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(component)\n    return components\n\ndef run_cascade(p_retain, rho, adj_A, adj_B, reinforced_A_nodes, reinforced_B_nodes, n_nodes, rng):\n    \"\"\"Simulates the cascading failure for a given p and returns the final order parameter S(p).\"\"\"\n    \n    # Step 0: Initial random removal\n    active_A = rng.random(size=n_nodes)  p_retain\n    active_B = rng.random(size=n_nodes)  p_retain\n\n    while True:\n        # Store current state to check for convergence\n        prev_active_A = active_A.copy()\n        prev_active_B = active_B.copy()\n        \n        # Step 1A: Find structurally functional nodes in Layer A\n        components_A = find_components(adj_A, active_A, n_nodes)\n        structurally_functional_A = np.zeros(n_nodes, dtype=bool)\n        if components_A:\n            lcc_A = max(components_A, key=len)\n            for node in lcc_A:\n                structurally_functional_A[node] = True\n            for comp in components_A:\n                if comp != lcc_A:\n                    for node in comp:\n                        if reinforced_A_nodes[node] and active_A[node]:\n                            for member in comp:\n                                structurally_functional_A[member] = True\n                            break\n\n        # Step 1B: Find structurally functional nodes in Layer B\n        components_B = find_components(adj_B, active_B, n_nodes)\n        structurally_functional_B = np.zeros(n_nodes, dtype=bool)\n        if components_B:\n            lcc_B = max(components_B, key=len)\n            for node in lcc_B:\n                structurally_functional_B[node] = True\n            for comp in components_B:\n                if comp != lcc_B:\n                    for node in comp:\n                        if reinforced_B_nodes[node] and active_B[node]:\n                            for member in comp:\n                                structurally_functional_B[member] = True\n                            break\n\n        # Step 2: Apply interdependency rules\n        next_active_A = structurally_functional_A  (reinforced_A_nodes | structurally_functional_B)\n        next_active_B = structurally_functional_B  (reinforced_B_nodes | structurally_functional_A)\n        \n        active_A = next_active_A\n        active_B = next_active_B\n\n        # Step 3: Check for convergence\n        if np.array_equal(active_A, prev_active_A) and np.array_equal(active_B, prev_active_B):\n            break\n\n    f_A = np.sum(active_A) / n_nodes\n    f_B = np.sum(active_B) / n_nodes\n    s_p = min(f_A, f_B)\n    \n    return s_p\n\n\ndef solve():\n    \"\"\"Main solver function.\"\"\"\n    N = 2000\n    P_GRID = np.linspace(1.0, 0.0, 31)\n    RHO_GRID = np.arange(0.00, 0.51, 0.05)\n    TAU = 0.12\n    SEED = 42\n\n    rng = np.random.default_rng(SEED)\n\n    test_cases = [\n        {'name': 'Poisson k=3', 'dist_type': 'poisson', 'params': {'lam': 3.0}},\n        {'name': 'PowerLaw', 'dist_type': 'powerlaw', 'params': {'gamma': 2.3, 'k_min': 1, 'k_max': 50}},\n        {'name': 'Poisson k=2', 'dist_type': 'poisson', 'params': {'lam': 2.0}},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Generate graphs for this test case\n        deg_A = generate_degree_sequence(case['dist_type'], case['params'], N, rng)\n        deg_B = generate_degree_sequence(case['dist_type'], case['params'], N, rng)\n        adj_A = generate_config_model_graph(deg_A, N, rng)\n        adj_B = generate_config_model_graph(deg_B, N, rng)\n        \n        rho_star = RHO_GRID[-1] # Default to max if no solution found\n        found_rho_star = False\n        \n        for rho in RHO_GRID:\n            if found_rho_star:\n                break\n\n            # Select reinforced nodes\n            n_reinforced = int(rho * N)\n            reinforced_A_indices = rng.choice(N, size=n_reinforced, replace=False)\n            reinforced_B_indices = rng.choice(N, size=n_reinforced, replace=False)\n            \n            reinforced_A_nodes = np.zeros(N, dtype=bool)\n            reinforced_B_nodes = np.zeros(N, dtype=bool)\n            reinforced_A_nodes[reinforced_A_indices] = True\n            reinforced_B_nodes[reinforced_B_indices] = True\n            \n            s_values = []\n            for p in P_GRID:\n                # Use a new RNG state for each cascade to ensure initial removals are independent\n                cascade_rng = np.random.default_rng(rng.integers(2**32))\n                s_p = run_cascade(p, rho, adj_A, adj_B, reinforced_A_nodes, reinforced_B_nodes, N, cascade_rng)\n                s_values.append(s_p)\n            \n            is_abrupt = False\n            for i in range(len(s_values) - 1):\n                # P_GRID is from 1.0 down to 0.0, so S(p_i) - S(p_{i+1}) is correct\n                delta_s = s_values[i] - s_values[i+1]\n                if delta_s > TAU:\n                    is_abrupt = True\n                    break\n            \n            if not is_abrupt:\n                rho_star = rho\n                found_rho_star = True\n        \n        results.append(f\"{rho_star:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在对复杂的网络之网络进行建模时，一个核心任务是从不同子系统或数据源中整合信息。这个过程中，局部约束之间可能存在冲突，导致无法形成一个全局一致的系统状态描述。本实践介绍了一种源于代数拓扑学的先进形式化方法——同调论，用于检测此类数据冲突。您将通过计算第一上同调群（first cohomology group）来实现一个一致性检查算法，并学习如何将一个非平凡的上同调类（nontrivial cohomology class）解释为阻碍全局一致性的“拓扑障碍”，这为复杂系统的数据融合和模型验证提供了强有力的数学工具。",
            "id": "4130131",
            "problem": "给定一个形式化设定，该设定将网络之网络中跨层的数据集成建模为一个附带有线性限制约束的有限单纯复形。目标是构建一个一致性检查算法，该算法计算一阶上同调群以检测跨层的数据冲突，并将非平凡上同调类解释为全局一致性的阻碍。\n\n基本根据与定义：\n- 一个有限单纯复形由一组 $0$-单纯形（节点）、$1$-单纯形（有向边）和 $2$-单纯形（有向三角形）指定，每个三角形由恰好三个具有选定方向的有向边作为边界。\n- 对于像实数 $\\mathbb{R}$ 这样的域，上链空间为 $C^{0} \\cong \\mathbb{R}^{n_{0}}$、$C^{1} \\cong \\mathbb{R}^{n_{1}}$ 和 $C^{2} \\cong \\mathbb{R}^{n_{2}}$，其中 $n_{0}$ 是节点数，$n_{1}$ 是边数，$n_{2}$ 是三角形数。\n- 上边缘（上链微分）映射 $\\delta^{0}: C^{0} \\to C^{1}$ 和 $\\delta^{1}: C^{1} \\to C^{2}$ 是满足上链复形性质 $\\delta^{1} \\circ \\delta^{0} = 0$ 的线性映射。具体来说，如果一条边 $e=(i \\to j)$ 的方向是从节点 $i$ 指向节点 $j$，那么对于一个 $0$-上链 $x \\in \\mathbb{R}^{n_{0}}$，其值 $(\\delta^{0} x)(e)$ 为 $x_{j} - x_{i}$。对于一个由三条边构成的有向边界的三角形 $t$，将 $\\delta^{1}$ 应用于一个 $1$-上链，会计算 $t$ 的有向边界上带符号的边值的总和。\n- 一阶上同调群为 $H^{1} := Z^{1} / B^{1}$，其中 $Z^{1} = \\ker(\\delta^{1})$ 是 $1$-上循环空间，$B^{1} = \\operatorname{im}(\\delta^{0})$ 是 $1$-上边缘空间。对于 $\\mathbb{R}$ 上的有限复形，其维数由 $\\dim H^{1} = \\dim \\ker(\\delta^{1}) - \\operatorname{rank}(\\delta^{0})$ 给出。\n- 边上的数据分配由一个 $1$-上链 $d \\in \\mathbb{R}^{n_{1}}$ 表示。当且仅当 $\\delta^{1} d = 0$ 时，该分配在每个 $2$-单纯形上是局部一致的。当且仅当存在一个 $0$-上链 $x \\in \\mathbb{R}^{n_{0}}$ 使得 $d = \\delta^{0} x$ 时，它在整个网络之网络中是全局一致的。一个非平凡的上同调类 $[d] \\in H^{1}$ 表示一个全局一致性的阻碍，即使 $d$ 是局部一致的（即 $d \\in Z^{1}$ 但 $d \\notin B^{1}$），也无法通过任何 $x$ 的选择来解决。\n\n任务：\n- 实现一个程序，在给定一个有限单纯复形和一个边数据上链 $d$ 的规格说明后，计算：\n  1. 整数维数 $\\dim H^{1}$，通过 $\\dim \\ker(\\delta^{1}) - \\operatorname{rank}(\\delta^{0})$ 计算。\n  2. 一个布尔值，指示 $d$ 是否为上循环，即 $\\delta^{1} d = 0$ 是否成立。\n  3. 一个布尔值，指示 $d$ 是否为平凡上同调类（即 $d \\in \\operatorname{im}(\\delta^{0})$ 是否成立），这对应于边数据在层间和层内的完全全局一致性。\n\n表示细节：\n- 节点索引为 $0,1,\\ldots,n_{0}-1$。\n- 有向边是序对 $(i,j)$，表示 $i \\to j$，索引为 $0,1,\\ldots,n_{1}-1$。\n- 有向三角形是带有相关符号的边索引三元组 $(e_{a}, s_{a}), (e_{b}, s_{b}), (e_{c}, s_{c})$，其中 $s_{k} \\in \\{+1,-1\\}$ 编码了所列边的方向是与三角形方向一致（$+1$）还是相反（$-1$）。\n- $1$-上链 $d$ 是 $\\mathbb{R}^{n_{1}}$ 中的一个向量，为每条有向边分配一个实数值，可解释为跨该边的必需差异约束。例如，一条层间边 $i \\to j$ 及其上的值 $d_{e}$ 建模了一个必须与其他约束相协调的约束 $x_{j} - x_{i} = d_{e}$。\n\n数值约定：\n- 在检查与零相等以进行一致性判断和秩计算时，使用 $10^{-9}$ 的数值容差。\n- 所有输出均为无单位的实数和布尔值；不涉及物理单位。\n\n测试套件：\n提供四个覆盖不同方面的测试案例：\n- 案例 A（理想路径，三角形，一致）：$n_{0} = 3$，边 $e_{0}=(0 \\to 1)$、$e_{1}=(1 \\to 2)$、$e_{2}=(2 \\to 0)$，三角形 $t_{0}=[(e_{0},+1),(e_{1},+1),(e_{2},+1)]$，$d = [1,2,-3]$。\n- 案例 B（局部冲突，三角形，不一致）：与案例 A 相同的复形，但 $d = [1,2,-2]$。\n- 案例 C（全局阻碍，循环图，无三角形）：$n_{0} = 4$，边 $e_{0}=(0 \\to 1)$、$e_{1}=(1 \\to 2)$、$e_{2}=(2 \\to 3)$、$e_{3}=(3 \\to 0)$，无三角形，$d = [1,1,1,1]$。\n- 案例 D（分层的网络之网络，跨层三角形存在一个局部不一致）：$n_{0} = 4$，其中两层可解释为层 A 中的节点 $0,1$ 和层 B 中的节点 $2,3$，边 $e_{0}=(0 \\to 1)$（层 A 内）、$e_{1}=(2 \\to 3)$（层 B 内）、层间边 $e_{2}=(0 \\to 2)$、$e_{3}=(1 \\to 3)$ 和跨层边 $e_{4}=(3 \\to 0)$。三角形 $t_{0}=[(e_{0},+1),(e_{3},+1),(e_{4},+1)]$ 表示有向环 $0 \\to 1 \\to 3 \\to 0$，以及 $t_{1}=[(e_{2},+1),(e_{1},+1),(e_{4},+1)]$ 表示 $0 \\to 2 \\to 3 \\to 0$。令 $d = [1,1,0,2,-3]$，使得 $t_{0}$ 局部一致而 $t_{1}$ 不一致。\n\n每个案例的必需输出：\n- 一个整数 $\\dim H^{1}$。\n- 一个表示 $d$ 的上循环状态的布尔值。\n- 一个表示 $d$ 的平凡类状态的布尔值。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个逗号分隔的列表，列表被方括号包围，其中每个案例产生一个形如 $[\\dim H^{1}, \\text{is\\_cocycle}, \\text{is\\_trivial}]$ 的列表。输出字符串中任何位置都不能有空格。对于以上四个案例，要求的格式是：\n$[[r_{A,1},r_{A,2},r_{A,3}],[r_{B,1},r_{B,2},r_{B,3}],[r_{C,1},r_{C,2},r_{C,3}],[r_{D,1},r_{D,2},r_{D,3}]]$,\n其中每个 $r_{*,*}$ 是由您的程序计算出的整数或布尔值。",
            "solution": "该问题要求实现一个算法，用于检查网络之网络模型中的数据一致性。该模型表示为一个有限单纯复形，并使用代数拓扑的工具，特别是一阶上同调群 $H^1$ 来分析一致性。解决方案涉及将上链空间和上边缘映射的抽象定义转化为对矩阵和向量的具体线性代数运算。\n\n该方法的核心是将上边缘算子 $\\delta^0: C^0 \\to C^1$ 和 $\\delta^1: C^1 \\to C^2$ 表示为矩阵。$k$-上链空间 $C^k$ 是 $\\mathbb{R}$ 上的有限维向量空间，同构于 $\\mathbb{R}^{n_k}$，其中 $n_k$ 是 $k$-单纯形的数量。\n\n令 $n_0$ 为节点（$0$-单纯形）的数量，$n_1$ 为有向边（$1$-单纯形）的数量，$n_2$ 为有向三角形（$2$-单纯形）的数量。\n\n第一个上边缘算子 $\\delta^0: \\mathbb{R}^{n_0} \\to \\mathbb{R}^{n_1}$ 由一个 $n_1 \\times n_0$ 的矩阵表示，我们将其记为 $D_0$。对于一条方向从节点 $i$ 指向节点 $j$ 的边 $e_k$（我们索引中的第 $k$ 条边），矩阵 $D_0$ 的第 $k$ 行被构造用来计算节点上值的差异。该行在第 $i$ 列为 $-1$，在第 $j$ 列为 $+1$，所有其他项均为 $0$。如果 $x \\in \\mathbb{R}^{n_0}$ 是一个 $0$-上链（为每个节点分配一个值），矩阵向量乘积 $D_0 x$ 会产生一个 $1$-上链，其第 $k$ 个分量为 $(\\delta^0 x)(e_k) = x_j - x_i$。\n\n第二个上边缘算子 $\\delta^1: \\mathbb{R}^{n_1} \\to \\mathbb{R}^{n_2}$ 由一个 $n_2 \\times n_1$ 的矩阵表示，记为 $D_1$。对于一个三角形 $t_k$（第 $k$ 个三角形），其有向边界由边 $\\{e_{i_1}, e_{i_2}, e_{i_3}\\}$ 及相应符号 $\\{s_1, s_2, s_3\\}$（其中 $s_j \\in \\{-1, +1\\}$）组成，$D_1$ 的第 $k$ 行编码了这种关系。该行将在第 $i_j$ 列具有值 $s_j$（对于 $j \\in \\{1,2,3\\}$），其他位置为 $0$。如果 $d \\in \\mathbb{R}^{n_1}$ 是一个 $1$-上链（给定的边数据），矩阵向量乘积 $D_1 d$ 计算每个三角形周围带符号数据的总和，即 $(\\delta^1 d)(t_k)$。\n\n有了这些矩阵表示，所需的三个量可以如下计算：\n\n1.  **一阶上同调群的维数 $\\dim H^1$**：\n    一阶上同调群定义为 $H^1 = Z^1 / B^1$，其中 $Z^1 = \\ker(\\delta^1)$ 是 $1$-上循环空间，$B^1 = \\operatorname{im}(\\delta^0)$ 是 $1$-上边缘空间。对于 $\\mathbb{R}$ 上的向量空间，其维数由 $\\dim H^1 = \\dim(Z^1) - \\dim(B^1)$ 给出。\n    用我们的矩阵表示，$\\dim(Z^1) = \\dim(\\ker(D_1))$，即 $D_1$ 的零化度。根据秩-零化度定理，$\\operatorname{nullity}(D_1) = n_1 - \\operatorname{rank}(D_1)$。\n    上边缘空间的维数是 $\\dim(B^1) = \\dim(\\operatorname{im}(D_0))$，即 $D_0$ 的秩。\n    因此，要实现的公式是 $\\dim H^1 = (n_1 - \\operatorname{rank}(D_1)) - \\operatorname{rank}(D_0)$。\n    矩阵的秩是通过计算大于指定数值容差（此处为 $10^{-9}$）的奇异值的数量来稳健地计算的。这通过奇异值分解（SVD）实现。\n\n2.  **边数据 $d$ 的上循环状态**：\n    边数据上链 $d \\in \\mathbb{R}^{n_1}$ 是一个上循环，如果它位于 $\\delta^1$ 的核中，即 $\\delta^1 d = 0$。这对应于局部一致性，即数据值在每个三角形周围的总和为零。在矩阵形式下，条件是 $D_1 d = 0$。我们计算向量 $v = D_1 d$ 并检查其所有分量是否在数值上接近于零，即对所有 $i$ 都有 $|v_i|  10^{-9}$。\n\n3.  **边数据 $d$ 的平凡类状态**：\n    如果一个上链 $d$ 是一个上边缘，即它位于 $\\delta^0$ 的像中（$d \\in \\operatorname{im}(\\delta^0)$），那么它代表一个平凡上同调类。这对应于全局一致性，因为它意味着存在一个 $0$-上链 $x \\in \\mathbb{R}^{n_0}$（节点上的全局势函数），使得 $d = \\delta^0 x$。\n    上链复形的一个基本性质是 $\\delta^1 \\circ \\delta^0 = 0$，这意味着 $\\operatorname{im}(\\delta^0) \\subseteq \\ker(\\delta^1)$（$B^1 \\subseteq Z^1$）。因此，$d$ 成为一个上边缘的必要条件是它必须首先是一个上循环。如果 $d$ 不是一个上循环，它就不可能是一个上边缘，因此不能代表一个平凡类。\n    如果 $d$ 是一个上循环，我们接着检查线性系统 $D_0 x = d$ 是否有解 $x$。根据线性代数，该系统有解当且仅当增广矩阵 $[D_0 | d]$ 的秩等于矩阵 $D_0$ 的秩。我们再次使用基于 SVD 的秩计算来执行此检查。\n\n算法的流程是首先从单纯复形的输入规格中构建矩阵 $D_0$ 和 $D_1$。然后，它计算这些矩阵的秩以求得 $\\dim H^1$。最后，它执行上述的矩阵向量乘法和秩检验，以确定给定数据上链 $d$ 的上循环状态和平凡类状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    \n    # Numerical tolerance for equality checks.\n    TOL = 1e-9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"n0\": 3,\n            \"edges\": [(0, 1), (1, 2), (2, 0)],\n            \"triangles\": [[(0, 1), (1, 1), (2, 1)]],\n            \"d\": [1, 2, -3],\n        },\n        {\n            \"n0\": 3,\n            \"edges\": [(0, 1), (1, 2), (2, 0)],\n            \"triangles\": [[(0, 1), (1, 1), (2, 1)]],\n            \"d\": [1, 2, -2],\n        },\n        {\n            \"n0\": 4,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 0)],\n            \"triangles\": [],\n            \"d\": [1, 1, 1, 1],\n        },\n        {\n            \"n0\": 4,\n            \"edges\": [(0, 1), (2, 3), (0, 2), (1, 3), (3, 0)],\n            \"triangles\": [[(0, 1), (3, 1), (4, 1)], [(2, 1), (1, 1), (4, 1)]],\n            \"d\": [1, 1, 0, 2, -3],\n        },\n    ]\n\n    def get_rank(matrix, tol):\n        \"\"\"Computes matrix rank using SVD by counting singular values above tolerance.\"\"\"\n        if matrix.size == 0:\n            return 0\n        s = np.linalg.svd(matrix, compute_uv=False)\n        return np.sum(s > tol)\n\n    def compute_cohomology_properties(n0, edges, triangles, d, tol):\n        \"\"\"\n        Computes the required cohomology properties for a given simplicial complex and data cochain.\n        \n        Returns:\n            A list [dim_H1, is_cocycle, is_trivial]\n        \"\"\"\n        n1 = len(edges)\n        n2 = len(triangles)\n        d_vec = np.array(d, dtype=float)\n\n        # 1. Construct the coboundary matrices D0 and D1.\n        D0 = np.zeros((n1, n0))\n        for k, edge in enumerate(edges):\n            i, j = edge\n            D0[k, i] = -1\n            D0[k, j] = 1\n\n        D1 = np.zeros((n2, n1))\n        for k, triangle in enumerate(triangles):\n            for edge_idx, sign in triangle:\n                D1[k, edge_idx] = sign\n\n        # 2. Compute dim H^1 = (n1 - rank(D1)) - rank(D0).\n        rank_D0 = get_rank(D0, tol)\n        rank_D1 = get_rank(D1, tol)\n        nullity_D1 = n1 - rank_D1\n        dim_H1 = nullity_D1 - rank_D0\n\n        # 3. Check if d is a cocycle (d in ker(D1), i.e., D1*d = 0).\n        if n2 == 0:\n            is_cocycle = True\n        else:\n            cocycle_check_vector = D1 @ d_vec\n            is_cocycle = np.all(np.abs(cocycle_check_vector)  tol)\n\n        # 4. Check if d is a trivial class (d in im(D0)).\n        is_trivial = False\n        # A necessary condition for d to be a coboundary is that it must be a cocycle.\n        if is_cocycle:\n            # Check if D0 @ x = d has a solution by comparing ranks.\n            # A solution exists iff rank([D0 | d]) == rank(D0).\n            d_col = d_vec.reshape(-1, 1)\n            augmented_D0 = np.hstack([D0, d_col])\n            rank_augmented = get_rank(augmented_D0, tol)\n            if rank_D0 == rank_augmented:\n                is_trivial = True\n\n        return [int(dim_H1), is_cocycle, is_trivial]\n\n    results = []\n    for case in test_cases:\n        result = compute_cohomology_properties(\n            case[\"n0\"], case[\"edges\"], case[\"triangles\"], case[\"d\"], TOL\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[0,True,True],[0,False,False],...]\n    result_strings = []\n    for r in results:\n        # Booleans need to be capitalized as `True`/`False` as per Python's str()\n        result_strings.append(f\"[{r[0]},{r[1]},{r[2]}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}