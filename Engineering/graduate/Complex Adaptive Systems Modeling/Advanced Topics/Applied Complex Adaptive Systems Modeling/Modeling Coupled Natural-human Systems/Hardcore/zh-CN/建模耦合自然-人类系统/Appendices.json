{
    "hands_on_practices": [
        {
            "introduction": "在耦合自然-人类系统中，决策往往涉及在经济、社会和环境等多个冲突目标之间进行权衡。本练习将介绍一种结构化方法——多标准决策分析（MCDA），通过该方法可以量化这些权衡，并根据明确的价值判断（权重）来选择最优策略 。通过这个练习，你将学会如何将复杂的决策问题分解为可管理的组成部分，并理解权重选择对最终政策建议的规范性影响。",
            "id": "4129000",
            "problem": "一个区域性流域管理局正在评估一项针对耦合自然-人类系统的政策，该系统共同影响农业生计和生态系统服务。该管理局考虑了3个候选政策，分别表示为$P_1$、$P_2$和$P_3$。每个政策都由在流域尺度上、为期10年的四个绩效指标来描述：以标准化单位计量的每户农业利润（越高越好）、生物多样性指数（越高越好）、作为概率的年洪水风险（越低越好）以及源自收入分配的公平指数（越高越好）。原始指标值如下：\n- $P_1$：利润$80$，生物多样性$0.60$，洪水风险$0.10$，公平性$0.70$。\n- $P_2$：利润$70$，生物多样性$0.80$，洪水风险$0.12$，公平性$0.82$。\n- $P_3$：利润$90$，生物多样性$0.50$，洪水风险$0.18$，公平性$0.60$。\n\n为了比较这些政策，该管理局使用了一种与多标准决策分析（MCDA）中可分离偏好一致的线性标量化方法。对于每个指标，通过对$\\{P_1,P_2,P_3\\}$进行最小-最大归一化，构建一个在$[0,1]$范围内的效益得分，使得得分越高越好。对于三个“优良”指标（利润、生物多样性、公平性），政策$P$的归一化效益定义为\n$$\nb^{\\text{good}}(P) \\equiv \\frac{x(P)-x_{\\min}}{x_{\\max}-x_{\\min}},\n$$\n其中$x_{\\min}$和$x_{\\max}$是该指标在三个政策中的最小值和最大值。对于“不良”指标（洪水风险），归一化效益定义为\n$$\nb^{\\text{bad}}(P) \\equiv \\frac{x_{\\max}-x(P)}{x_{\\max}-x_{\\min}},\n$$\n这样，较大的值仍然表示更好的性能。政策$P$的综合得分为\n$$\nU(P) \\equiv \\sum_{k=1}^{4} w_k\\, b_k(P),\n$$\n其中权重$\\mathbf{w}=(w_1,w_2,w_3,w_4)$严格为正且总和为$1$，分别代表管理局在利润、生物多样性、洪水风险和公平性之间的权衡判断。假设管理局采用的权重为$\\mathbf{w} = (0.4,\\,0.3,\\,0.2,\\,0.1)$。\n\n根据线性标量化的第一性原理和上述定义，回答以下问题。关于在所述权重下选定的政策，以及权重选择对政策建议和模型透明度的规范性影响，哪个选项的描述最为准确？\n\nA. 在给定的权重和归一化方法下，$P_2$使$U(P)$最大化。此外，权重的选择嵌入了不可通约目标之间的规范性权衡；不披露权重和归一化方法会损害透明度；在合理的备选权重下，排名可能会改变；线性加权和假设了标准间的完全可补偿性，这是一个应被明确说明的规范性立场。\n\nB. 在给定的权重和归一化方法下，$P_1$使$U(P)$最大化。此外，由于权重之和为$1$，无论选择何种权重，分析都是透明的，且排名对归一化方案不敏感。\n\nC. 在给定的权重和归一化方法下，$P_3$使$U(P)$最大化。此外，如果权重是从利益相关者处征求而来，则分析变得无价值判断，且能免受政策俘获的影响，因此模型透明度不再依赖于记录权重或归一化方法。\n\nD. 在给定的权重和归一化方法下，$P_2$使$U(P)$最大化。此外，任何前沿（凸或非凸）上的任何帕累托有效政策都可以通过线性加权和中的某个严格为正的权重向量来恢复；省略对“不良”指标的反转不影响排名，因为权重编码了该偏好方向。",
            "solution": "将首先验证用户提供的问题，以确保其具有科学依据、问题适定且客观。\n\n### 步骤1：提取给定信息\n- **政策**：三个候选政策，$P_1$、$P_2$和$P_3$。\n- **绩效指标**：\n    1. 利润（$x_1$）：越高越好。\n    2. 生物多样性（$x_2$）：越高越好。\n    3. 洪水风险（$x_3$）：越低越好。\n    4. 公平性（$x_4$）：越高越好。\n- **政策的指标值**：\n    - $P_1$：（利润$80$，生物多样性$0.60$，洪水风险$0.10$，公平性$0.70$）\n    - $P_2$：（利润$70$，生物多样性$0.80$，洪水风险$0.12$，公平性$0.82$）\n    - $P_3$：（利润$90$，生物多样性$0.50$，洪水风险$0.18$，公平性$0.60$）\n- **归一化方法（最小-最大）**：\n    - 对于“优良”指标（利润、生物多样性、公平性）：效益得分 $b^{\\text{good}}(P) = \\frac{x(P)-x_{\\min}}{x_{\\max}-x_{\\min}}$。\n    - 对于“不良”指标（洪水风险）：效益得分 $b^{\\text{bad}}(P) = \\frac{x_{\\max}-x(P)}{x_{\\max}-x_{\\min}}$。\n- **综合得分函数**：$U(P) = \\sum_{k=1}^{4} w_k\\, b_k(P)$。\n- **权重**：$\\mathbf{w} = (w_1, w_2, w_3, w_4) = (0.4, 0.3, 0.2, 0.1)$，分别对应利润、生物多样性、洪水风险和公平性。权重严格为正（$w_k  0$）且总和为$1$。\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学依据**：该问题使用了多标准决策分析（MCDA）中的标准方法，特别是线性加权和模型，这是一种用于包括环境管理在内的复杂系统决策支持的常用且有充分文献记录的技术。这些指标对于一个流域系统是合理的。归一化公式是标准实践。该问题在科学上是合理的。\n- **问题适定**：所有必要的数据（指标值、权重、归一化公式）都已提供，可以为每个政策计算出唯一的综合得分。问题清晰，可以根据所提供的信息进行回答。该问题是适定的。\n- **客观性**：该问题是作为一个应用特定MCDA技术的形式化练习提出的。语言精确且无偏见。它是客观的。\n\n### 步骤3：结论与行动\n该问题有效。解题过程将首先计算每个政策的综合得分，然后评估每个选项。\n\n### 解题过程\n第一步是计算每个政策$P \\in \\{P_1, P_2, P_3\\}$和每个指标$k \\in \\{1, 2, 3, 4\\}$的归一化效益得分$b_k(P)$。\n\n**1. 利润（指标$k=1$，“优良”）**\n- 值：$\\{80, 70, 90\\}$。$x_{\\min}=70$，$x_{\\max}=90$。\n- $b_1(P_1) = \\frac{80-70}{90-70} = \\frac{10}{20} = 0.5$\n- $b_1(P_2) = \\frac{70-70}{90-70} = \\frac{0}{20} = 0$\n- $b_1(P_3) = \\frac{90-70}{90-70} = \\frac{20}{20} = 1$\n\n**2. 生物多样性（指标$k=2$，“优良”）**\n- 值：$\\{0.60, 0.80, 0.50\\}$。$x_{\\min}=0.50$，$x_{\\max}=0.80$。\n- $b_2(P_1) = \\frac{0.60-0.50}{0.80-0.50} = \\frac{0.10}{0.30} = \\frac{1}{3}$\n- $b_2(P_2) = \\frac{0.80-0.50}{0.80-0.50} = \\frac{0.30}{0.30} = 1$\n- $b_2(P_3) = \\frac{0.50-0.50}{0.80-0.50} = \\frac{0}{0.30} = 0$\n\n**3. 洪水风险（指标$k=3$，“不良”）**\n- 值：$\\{0.10, 0.12, 0.18\\}$。$x_{\\min}=0.10$，$x_{\\max}=0.18$。\n- $b_3(P_1) = \\frac{0.18-0.10}{0.18-0.10} = \\frac{0.08}{0.08} = 1$\n- $b_3(P_2) = \\frac{0.18-0.12}{0.18-0.10} = \\frac{0.06}{0.08} = 0.75$\n- $b_3(P_3) = \\frac{0.18-0.18}{0.18-0.10} = \\frac{0}{0.08} = 0$\n\n**4. 公平性（指标$k=4$，“优良”）**\n- 值：$\\{0.70, 0.82, 0.60\\}$。$x_{\\min}=0.60$，$x_{\\max}=0.82$。\n- $b_4(P_1) = \\frac{0.70-0.60}{0.82-0.60} = \\frac{0.10}{0.22} = \\frac{5}{11}$\n- $b_4(P_2) = \\frac{0.82-0.60}{0.82-0.60} = \\frac{0.22}{0.22} = 1$\n- $b_4(P_3) = \\frac{0.60-0.60}{0.82-0.60} = \\frac{0}{0.22} = 0$\n\n接下来，使用权重$\\mathbf{w} = (0.4, 0.3, 0.2, 0.1)$计算每个政策的综合得分$U(P)$。\n\n- **$P_1$的得分**：\n$$U(P_1) = w_1 b_1(P_1) + w_2 b_2(P_1) + w_3 b_3(P_1) + w_4 b_4(P_1)$$\n$$U(P_1) = (0.4)(0.5) + (0.3)\\left(\\frac{1}{3}\\right) + (0.2)(1) + (0.1)\\left(\\frac{5}{11}\\right)$$\n$$U(P_1) = 0.2 + 0.1 + 0.2 + \\frac{0.5}{11} = 0.5 + \\frac{1}{22} \\approx 0.5 + 0.04545 = 0.54545...$$\n\n- **$P_2$的得分**：\n$$U(P_2) = w_1 b_1(P_2) + w_2 b_2(P_2) + w_3 b_3(P_2) + w_4 b_4(P_2)$$\n$$U(P_2) = (0.4)(0) + (0.3)(1) + (0.2)(0.75) + (0.1)(1)$$\n$$U(P_2) = 0 + 0.3 + 0.15 + 0.1 = 0.55$$\n\n- **$P_3$的得分**：\n$$U(P_3) = w_1 b_1(P_3) + w_2 b_2(P_3) + w_3 b_3(P_3) + w_4 b_4(P_3)$$\n$$U(P_3) = (0.4)(1) + (0.3)(0) + (0.2)(0) + (0.1)(0)$$\n$$U(P_3) = 0.4$$\n\n比较得分：$U(P_2) = 0.55$，$U(P_1) \\approx 0.545$，$U(P_3) = 0.4$。\n最高分是$U(P_2)$，因此选择政策$P_2$。\n\n### 逐项分析选项\n\n**A. 在给定的权重和归一化方法下，$P_2$使$U(P)$最大化。此外，权重的选择嵌入了不可通约目标之间的规范性权衡；不披露权重和归一化方法会损害透明度；在合理的备选权重下，排名可能会改变；线性加权和假设了标准间的完全可补偿性，这是一个应被明确说明的规范性立场。**\n- **计算**：“`$P_2$使$U(P)$最大化`”。根据以上推导，这是正确的（$U(P_2)=0.55$）。\n- **规范性影响**：\n    - “`权重的选择嵌入了不可通约目标之间的规范性权衡`”：正确。权重（$w_k$）代表了关于不同、不可互换目标（例如，利润与生物多样性）相对重要性的价值判断。\n    - “`不披露权重和归一化方法会损害透明度`”：正确。为了使结果可审查且合法，包括权重和归一化在内的方法论必须公开。\n    - “`在合理的备选权重下，排名可能会改变`”：正确。排名对权重敏感。一套不同的社会或政治优先事项会产生不同的权重向量，并可能导致不同的最优政策。\n    - “`线性加权和假设了标准间的完全可补偿性，这是一个应被明确说明的规范性立场`”：正确。加法形式$\\sum w_k b_k$意味着一个标准的损失可以被另一个标准的增益完全补偿，这是一个强烈且具有重大后果的价值判断（例如，环境损害可以用经济收益“支付”）。\n- **结论**：正确。此陈述的所有部分都是准确的，既反映了正确的计算，也反映了对MCDA原则的深刻理解。\n\n**B. 在给定的权重和归一化方法下，$P_1$使$U(P)$最大化。此外，由于权重之和为$1$，无论选择何种权重，分析都是透明的，且排名对归一化方案不敏感。**\n- **计算**：“`$P_1$使$U(P)$最大化`”。错误。$U(P_1) \\approx 0.545$，而$U(P_2) = 0.55$。\n- **规范性影响**：\n    - “`由于权重之和为$1$，分析都是透明的`”：错误。透明度要求披露具体的权重值，而不仅仅是它们的和。约束$\\sum w_k = 1$是一个惯例；实际的数值才编码了权衡关系。\n    - “`排名对归一化方案不敏感`”：错误。不同的归一化方法（例如，z-score、除以最大值）将产生不同的效益得分，并很容易导致不同的政策排名。\n- **结论**：错误。计算是错误的，关于透明度和归一化的断言是虚假的。\n\n**C. 在给定的权重和归一化方法下，$P_3$使$U(P)$最大化。此外，如果权重是从利益相关者处征求而来，则分析变得无价值判断，且能免受政策俘获的影响，因此模型透明度不再依赖于记录权重或归一化方法。**\n- **计算**：“`$P_3$使$U(P)$最大化`”。错误。$P_3$的得分最低（$U(P_3)=0.4$）。\n- **规范性影响**：\n    - “`如果权重是从利益相关者处征求而来，则分析变得无价值判断`”：错误。从利益相关者那里征求权重，是明确地将他们的价值观融入模型中。分析变得价值负载（负载着利益相关者的价值观），而不是无价值判断。\n    - “`能免受政策俘获的影响`”：错误。利益相关者参与的过程本身就可能受到强大势力的操纵或主导，这是一种政策俘获的形式。\n    - “`透明度不再依赖于记录权重`”：错误。透明度至关重要。记录如何从哪些利益相关者那里征求权重，对于过程的合法性至关重要。\n- **结论**：错误。计算是错误的，关于MCDA过程的陈述是根本性错误的。\n\n**D. 在给定的权重和归一化方法下，$P_2$使$U(P)$最大化。此外，任何前沿（凸或非凸）上的任何帕累托有效政策都可以通过线性加权和中的某个严格为正的权重向量来恢复；省略对“不良”指标的反转不影响排名，因为权重编码了该偏好方向。**\n- **计算**：“`$P_2$使$U(P)$最大化`”。正确。\n- **规范性影响**：\n    - “`任何前沿（凸或非凸）上的任何帕累托有效政策都可以通过某个严格为正的权重向量来恢复`”：错误。这是线性加权和方法的一个众所周知的局限性。它只能找到帕累托前沿的*凸*部分上的点。该方法无法发现前沿的非凸（凹入）区域中的点。\n    - “`省略对“不良”指标的反转不影响排名，因为权重编码了该偏好方向`”：错误。权重反映的是重要性，而不是偏好方向。归一化公式编码了方向（越高越好）。省略对洪水风险的反转会错误地奖励风险更高的政策，完全改变该标准的效益得分，并且几乎肯定会改变最终排名。\n- **结论**：错误。尽管计算是正确的，但随后的理论主张是错误的。\n\n基于以上分析，选项A是唯一完全正确的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "当决策者不仅要处理多个目标，还要面对未来的“深度不确定性”——即我们无法为未来情景分配合理的概率时，决策会变得更加复杂。本练习将指导你应用稳健决策（RDM）框架，该框架旨在寻找在多种可能的未来情景下都表现尚可，而不是在单一“最可能”的未来中表现最优的策略 。你将通过最小化最大遗憾（minimax regret）准则，学习如何识别和选择对不确定性具有韧性的“稳健”策略。",
            "id": "4129008",
            "problem": "你的任务是为一个风格化的耦合自然-人类水系统，在深度不确定性下实现一个鲁棒决策 (RDM) 算法。该耦合系统由一个人类需求部分和一个自然供给部分表示，它们之间的相互作用决定了实际消耗量和社会福利。不确定性由探索性情景表示，你必须根据给定的参数范围构建这些情景。然后，你必须评估一组有限的候选策略，并选择在所有情景中最小化最大遗憾的策略。\n\n你推导算法所必须依据的基本基础由以下定义和广泛使用的建模原语给出：\n\n- 一个策略在一个情景下的遗憾被定义为在该情景下可实现的最佳福利与该策略在该情景下实现的福利之间的差值。\n- 最小化最大遗憾策略是在所有情景中最小化最大遗憾的策略。\n\n使用以下风格化且科学上合理的模型来表示耦合的自然-人类系统：\n\n- 情景参数（深度不确定性）：\n  - 气候干旱参数 $a \\in [0,1]$，减少可再生水供给。\n  - 经济需求增长参数 $g$，它以乘法方式缩放基线需求。\n  - 行为价格弹性参数 $e \\ge 0$，它控制需求对定价策略的敏感性。\n\n- 策略向量 $(x,u)$:\n  - 价格乘数 $x \\ge 0$，增加有效价格（无量纲）。\n  - 供给增加投资 $u \\ge 0$，以边际收益递减的方式增加供给，并产生类似二次方的成本。\n\n- 基线常数（无量纲）：\n  - 基线需求 $d_0$，基线供给 $s_0$，效益参数 $\\alpha$ 和 $\\beta$，稀缺损失系数 $\\phi$，供给增加效能 $r$，以及投资成本系数 $c_u$。\n\n- 需求函数：\n  $$D(d_0,g,e,x) = d_0 \\,(1+g)\\,\\max\\left(0,\\,1 - e\\,x\\right).$$\n\n- 供给函数（供给增加的边际收益递减）：\n  $$S(s_0,a,r,u) = s_0\\,(1 - a) + r\\,\\sqrt{u}.$$\n\n- 实际消耗量（受可用供给限制）：\n  $$Q(D,S) = \\min\\left(D,\\,S\\right).$$\n\n- 稀缺（未满足的需求）：\n  $$\\Delta(D,S) = \\max\\left(0,\\,D - S\\right).$$\n\n- 福利函数（无量纲），结合了凹性的消费效益、凸性的稀缺损失和投资成本：\n  $$W(\\alpha,\\beta,\\phi,c_u; Q, \\Delta, u) = \\alpha\\,Q - \\frac{1}{2}\\,\\beta\\,Q^2 - \\phi\\,\\Delta^2 - c_u\\,u.$$\n\n- 在情景 $\\theta = (a,g,e)$ 下，策略 $\\pi = (x,u)$ 的遗憾：\n  $$R(\\theta,\\pi) = W^*(\\theta) - W(\\theta,\\pi),$$\n  其中\n  $$W^*(\\theta) = \\max_{\\pi' \\in \\Pi} W(\\theta,\\pi')$$\n  且 $\\Pi$ 是候选策略的有限集合。\n\n你的程序必须为每个测试用例执行以下操作：\n- 通过取 $a$、$g$ 和 $e$ 的指定离散值的笛卡尔积来构建情景集。\n- 对于给定的策略集 $\\Pi$ 中的每个情景 $\\theta$ 和策略 $\\pi$，评估 $W(\\theta,\\pi)$。\n- 对于所有 $\\theta \\in \\Theta$ 和 $\\pi \\in \\Pi$，计算 $R(\\theta,\\pi)$，其中 $\\Theta$ 是情景集。\n- 计算每个策略的最大遗憾：\n  $$R_{\\max}(\\pi) = \\max_{\\theta \\in \\Theta} R(\\theta,\\pi).$$\n- 选择最小化最大遗憾策略：\n  $$\\pi^{\\text{MMR}} = \\arg\\min_{\\pi \\in \\Pi} R_{\\max}(\\pi).$$\n  如果出现平局，通过选择所提供策略列表中索引最小的策略来打破平局。\n\n对于每个测试用_例，返回最小化最大遗憾策略的索引（第一个策略从 $0$ 开始）及其最大遗憾值 $R_{\\max}$。\n\n所有量都是无量纲的。不需要物理单位。不涉及角度。所有数值输出必须是浮点数或整数。每个测试用例的最终输出必须是一个双元素列表 $[i, r]$，其中 $i$ 是一个整数策略索引，$r$ 是一个等于 $R_{\\max}$ 并四舍五入到六位小数的浮点数。\n\n你的程序应该产生单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且是一个双元素列表 $[i, r]$。例如：$[[0,0.000000],[2,0.123456],[1,0.654321]]$。\n\n测试套件：\n\n- 测试用例 $1$（理想情况，多个情景和策略）：\n  - 常数: $d_0 = 1.0$, $s_0 = 1.0$, $\\alpha = 1.6$, $\\beta = 0.9$, $\\phi = 1.2$, $r = 0.6$, $c_u = 0.4$。\n  - 策略（按顺序索引）：\n    - $0$: $(x,u) = (0.0,\\,0.0)$\n    - $1$: $(x,u) = (0.3,\\,0.0)$\n    - $2$: $(x,u) = (0.6,\\,0.0)$\n    - $3$: $(x,u) = (0.2,\\,0.25)$\n    - $4$: $(x,u) = (0.4,\\,0.25)$\n  - 情景（笛卡尔积）：\n    - $a \\in \\{0.1,\\,0.3,\\,0.5\\}$\n    - $g \\in \\{0.0,\\,0.3\\}$\n    - $e \\in \\{0.4,\\,0.8\\}$\n\n- 测试用例 $2$（边界情况：单个情景；最佳策略的遗憾为零）：\n  - 常数: $d_0 = 1.0$, $s_0 = 1.0$, $\\alpha = 1.5$, $\\beta = 1.0$, $\\phi = 1.0$, $r = 0.5$, $c_u = 0.3$。\n  - 策略（按顺序索引）：\n    - $0$: $(x,u) = (0.0,\\,0.0)$\n    - $1$: $(x,u) = (0.3,\\,0.0)$\n    - $2$: $(x,u) = (0.0,\\,0.2)$\n  - 情景：\n    - 单个情景，$a = 0.2$, $g = 0.0$, $e = 0.5$。\n\n- 测试用例 $3$（极端情况：极端干旱和高增长；展示权衡）：\n  - 常数: $d_0 = 1.0$, $s_0 = 1.0$, $\\alpha = 1.7$, $\\beta = 1.0$, $\\phi = 1.3$, $r = 0.7$, $c_u = 0.5$。\n  - 策略（按顺序索引）：\n    - $0$: $(x,u) = (0.0,\\,0.0)$\n    - $1$: $(x,u) = (0.4,\\,0.0)$\n    - $2$: $(x,u) = (0.2,\\,0.3)$\n    - $3$: $(x,u) = (0.4,\\,0.3)$\n    - $4$: $(x,u) = (0.2,\\,0.5)$\n    - $5$: $(x,u) = (0.4,\\,0.5)$\n  - 情景（笛卡尔积）：\n    - $a \\in \\{0.6,\\,0.8\\}$\n    - $g \\in \\{0.4,\\,0.6\\}$\n    - $e \\in \\{0.2\\}$\n\n实现要求：\n- 完全按照上述定义计算 $Q$、$\\Delta$ 和 $W$。\n- 使用遗憾和最小化最大遗憾的定义来选择策略。\n- 将每个报告的 $R_{\\max}$ 四舍五入到六位小数。\n- 无用户输入；仅使用给定的测试套件。\n- 最终输出格式：单行包含一个Python风格的列表，该列表包含三个元素（每个测试用例一个），每个元素是一个双元素列表 $[i, r]$，其中 $i$ 是整数，$r$ 是浮点数，四舍五入到六位小数，例如：$[[0,0.000000],[2,0.123456],[1,0.654321]]$。",
            "solution": "用户提供了一个问题陈述，要求为一个风格化的耦合自然-人类水系统实现一个鲁棒决策（RDM）算法。核心任务是确定在未来一系列不确定情景中，能够最小化最大遗憾的策略。\n\n首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n问题提供了以下定义、模型和数据：\n\n- **情景参数（不确定性）$\\theta = (a,g,e)$**：\n  - 气候干旱参数: $a \\in [0,1]$\n  - 经济需求增长参数: $g$\n  - 行为价格弹性参数: $e \\ge 0$\n\n- **策略向量 $\\pi = (x,u)$**：\n  - 价格乘数: $x \\ge 0$\n  - 供给增加投资: $u \\ge 0$\n\n- **基线常数**：$d_0$、 $s_0$、 $\\alpha$、 $\\beta$、 $\\phi$、 $r$、 $c_u$。\n\n- **系统模型方程**：\n  - 需求函数: $D(d_0,g,e,x) = d_0 \\,(1+g)\\,\\max\\left(0,\\,1 - e\\,x\\right)$\n  - 供给函数: $S(s_0,a,r,u) = s_0\\,(1 - a) + r\\,\\sqrt{u}$\n  - 实际消耗量: $Q(D,S) = \\min\\left(D,\\,S\\right)$\n  - 稀缺: $\\Delta(D,S) = \\max\\left(0,\\,D - S\\right)$\n  - 福利函数: $W(\\alpha,\\beta,\\phi,c_u; Q, \\Delta, u) = \\alpha\\,Q - \\frac{1}{2}\\,\\beta\\,Q^2 - \\phi\\,\\Delta^2 - c_u\\,u$\n\n- **决策框架定义**：\n  - 遗憾: $R(\\theta,\\pi) = W^*(\\theta) - W(\\theta,\\pi)$\n  - 每个情景的最优福利: $W^*(\\theta) = \\max_{\\pi' \\in \\Pi} W(\\theta,\\pi')$, 其中 $\\Pi$ 是候选策略的有限集合。\n  - 每个策略的最大遗憾: $R_{\\max}(\\pi) = \\max_{\\theta \\in \\Theta} R(\\theta,\\pi)$, 其中 $\\Theta$ 是情景的有限集合。\n  - 最小化最大遗憾策略: $\\pi^{\\text{MMR}} = \\arg\\min_{\\pi \\in \\Pi} R_{\\max}(\\pi)$。\n  - 平局打破规则：如果多个策略共享相同的最小最大遗憾值，选择索引最低的那个。\n\n- **测试用例**：提供了三个不同的测试用例，每个都有一套完整的常数、候选策略和情景参数的离散值。\n\n**步骤2：使用提取的给定条件进行验证**\n\n- **科学依据**：该问题基于复杂自适应系统建模的成熟领域，特别是关于耦合的自然-人类系统。该模型虽然是风格化的，但使用了标准的经济学和水文学原语：需求弹性、边际收益递减的供给增加、受供给与需求最小值限制的消耗量，以及由凹性效益和凸性损失组成的福利函数。利用最小化最大遗憾的RDM框架是处理深度不确定性下决策的标准且备受推崇的方法。该模型在科学上是合理的。\n- **适定性**：该问题是适定的。任务涉及从一个有限且明确列出的集合 $\\Pi$ 中搜索最优策略。不确定性集合 $\\Theta$ 也是有限的，由离散参数值的笛卡尔积构成。这种结构保证了每个策略-情景对都存在一个福利值，每个情景都存在一个最大福利 $W^*$，每个策略都存在一个最大遗憾 $R_{\\max}$，并且这些最大遗憾中存在一个最小值。平局打破规则确保了解决方案的唯一性。\n- **客观性**：问题以精确、客观和数学的语言表述。所有函数都已明确定义，测试用例的所有参数均已提供。没有主观或含糊的陈述。\n- **缺陷检查表**：该问题没有违反任何指定的缺陷条件。它在科学上是合理的、可形式化的、完整的、内部一致的，并且需要大量的计算来解决。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。将根据提供的规范开发一个解决方案。\n\n### 算法解决方案\n\n该解决方案是鲁棒决策（RDM）工作流的实现。对于每个测试用例，我们系统地评估一组候选策略对抗一组合理的未来情景，以找到对不确定性最鲁棒的策略，其定义为最小化最大遗憾准则。\n\n对于每个测试用例，算法按以下步骤进行：\n\n1.  **情景生成**：通过取所提供的参数 $a$、$g$ 和 $e$ 的离散值的笛卡尔积，来构建不确定情景的集合 $\\Theta$。如果 $N_a$、$N_g$ 和 $N_e$ 分别是每个参数的值的数量，则情景总数为 $N_\\theta = N_a \\times N_g \\times N_e$。\n\n2.  **福利矩阵计算**：构建一个“收益”或福利矩阵，记为 $\\mathbf{W}$。该矩阵的行对应于情景 $\\theta \\in \\Theta$，列对应于策略 $\\pi \\in \\Pi$。矩阵的每个元素 $W_{ij}$ 表示在实施策略 $\\pi_j$ 时，在情景 $\\theta_i$ 下实现的福利。\n    要计算 $W_{ij}$，我们首先为给定的情景 $\\theta_i = (a_i, g_i, e_i)$ 和策略 $\\pi_j = (x_j, u_j)$ 计算中间量：\n    -   需求: $D_{ij} = d_0 \\,(1+g_i)\\,\\max\\left(0,\\,1 - e_i\\,x_j\\right)$\n    -   供给: $S_{ij} = s_0\\,(1 - a_i) + r\\,\\sqrt{u_j}$\n    -   消耗量: $Q_{ij} = \\min\\left(D_{ij},\\,S_{ij}\\right)$\n    -   稀缺: $\\Delta_{ij} = \\max\\left(0,\\,D_{ij} - S_{ij}\\right)$\n    -   福利: $W_{ij} = \\alpha\\,Q_{ij} - \\frac{1}{2}\\,\\beta\\,Q_{ij}^2 - \\phi\\,\\Delta_{ij}^2 - c_u\\,u_j$\n\n3.  **遗憾矩阵计算**：首先，对于每个情景 $\\theta_i$（即福利矩阵 $\\mathbf{W}$ 的每一行），我们找到最大可能福利 $W_i^*$。这是在该情景下，给定可用策略选项可实现的最佳结果：\n    $$W_i^* = \\max_j W_{ij}$$\n    接下来，计算一个与 $\\mathbf{W}$ 维度相同的遗憾矩阵 $\\mathbf{R}$。每个元素 $R_{ij}$ 是策略 $\\pi_j$ 在情景 $\\theta_i$ 下的遗憾，定义为与最佳可能结果的差距：\n    $$R_{ij} = W_i^* - W_{ij}$$\n\n4.  **最小化最大遗憾策略选择**：对于每个策略 $\\pi_j$（即遗憾矩阵 $\\mathbf{R}$ 的每一列），我们通过找到它在所有情景中产生的最大遗憾来确定其最坏情况下的表现：\n    $$R_{\\max}(\\pi_j) = \\max_i R_{ij}$$\n    这将产生一个最大遗憾的向量，每个策略对应一个值。RDM算法指导我们选择最小化这个最大遗憾的策略。因此，最小化最大遗憾策略 $\\pi^{\\text{MMR}}$ 是：\n    $$\\pi^{\\text{MMR}} = \\arg\\min_j R_{\\max}(\\pi_j)$$\n    记录此策略的索引，以及其关联的最小化最大遗憾值 $R_{\\max}(\\pi^{\\text{MMR}})$。根据问题的平局打破规则，如果多个策略产生相同的最小最大遗憾值，则选择索引最小的那个。\n\n5.  **输出格式化**：每个测试用例的最终结果是一个双元素列表，包含所选策略 $\\pi^{\\text{MMR}}$ 的整数索引及其对应的最大遗憾值，四舍五入到六位小数。\n\n这整个过程被封装在一个程序中，该程序迭代遍历提供的测试用例，并生成一个单行列表的列表作为最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the Robust Decision Making (RDM) algorithm\n    for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: happy path, multiple scenarios and policies\n        {\n            \"constants\": (1.0, 1.0, 1.6, 0.9, 1.2, 0.6, 0.4), # d0, s0, alpha, beta, phi, r, cu\n            \"policies\": [(0.0, 0.0), (0.3, 0.0), (0.6, 0.0), (0.2, 0.25), (0.4, 0.25)], # (x, u)\n            \"scenario_params\": ({0.1, 0.3, 0.5}, {0.0, 0.3}, {0.4, 0.8}) # a, g, e\n        },\n        # Test Case 2: boundary case: single scenario; best policy has zero regret\n        {\n            \"constants\": (1.0, 1.0, 1.5, 1.0, 1.0, 0.5, 0.3), # d0, s0, alpha, beta, phi, r, cu\n            \"policies\": [(0.0, 0.0), (0.3, 0.0), (0.0, 0.2)], # (x, u)\n            \"scenario_params\": ({0.2}, {0.0}, {0.5}) # a, g, e\n        },\n        # Test Case 3: edge case: extreme dryness and high growth\n        {\n            \"constants\": (1.0, 1.0, 1.7, 1.0, 1.3, 0.7, 0.5), # d0, s0, alpha, beta, phi, r, cu\n            \"policies\": [(0.0, 0.0), (0.4, 0.0), (0.2, 0.3), (0.4, 0.3), (0.2, 0.5), (0.4, 0.5)], # (x, u)\n            \"scenario_params\": ({0.6, 0.8}, {0.4, 0.6}, {0.2}) # a, g, e\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        result_pair = run_rdm_analysis(\n            case[\"constants\"], case[\"policies\"], case[\"scenario_params\"]\n        )\n        # Append the [index, value] pair, with value rounded as required.\n        final_results.append([result_pair[0], round(result_pair[1], 6)])\n\n    # Print the final result in the exact specified format.\n    print(str(final_results).replace(\" \", \"\"))\n\ndef run_rdm_analysis(constants, policies, scenario_params):\n    \"\"\"\n    Performs the RDM calculation for a single test case.\n\n    Args:\n        constants (tuple): A tuple of the baseline constants.\n        policies (list): A list of policy tuples (x, u).\n        scenario_params (tuple): A tuple of sets for a, g, and e values.\n\n    Returns:\n        list: A two-item list [policy_index, min_max_regret].\n    \"\"\"\n    d0, s0, alpha, beta, phi, r_const, cu = constants\n    a_vals, g_vals, e_vals = scenario_params\n\n    # Step 1: Generate scenarios from the Cartesian product of parameter values\n    scenarios = []\n    for a in sorted(list(a_vals)):\n        for g in sorted(list(g_vals)):\n            for e in sorted(list(e_vals)):\n                scenarios.append((a, g, e))\n\n    num_scenarios = len(scenarios)\n    num_policies = len(policies)\n\n    # Step 2: Compute the welfare matrix\n    welfare_matrix = np.zeros((num_scenarios, num_policies))\n\n    for i, (a, g, e) in enumerate(scenarios):\n        for j, (x, u) in enumerate(policies):\n            # Demand calculation\n            demand = d0 * (1 + g) * max(0, 1 - e * x)\n            # Supply calculation\n            supply = s0 * (1 - a) + r_const * np.sqrt(u)\n            \n            # Consumption and scarcity\n            Q = min(demand, supply)\n            Delta = max(0, demand - supply)\n\n            # Welfare calculation\n            welfare = alpha * Q - 0.5 * beta * Q**2 - phi * Delta**2 - cu * u\n            welfare_matrix[i, j] = welfare\n\n    # Step 3: Compute the regret matrix\n    # Find the maximum welfare for each scenario (row)\n    w_star_per_scenario = np.max(welfare_matrix, axis=1)\n\n    # Regret is the difference between optimal welfare and actual welfare.\n    # We use broadcasting to subtract the w_star vector from each column.\n    regret_matrix = w_star_per_scenario[:, np.newaxis] - welfare_matrix\n\n    # Step 4: Find the minimax regret policy\n    # Find the maximum regret for each policy (column)\n    max_regret_per_policy = np.max(regret_matrix, axis=0)\n\n    # Find the policy that minimizes the maximum regret\n    min_max_regret = np.min(max_regret_per_policy)\n    # np.argmin() breaks ties by returning the first (lowest) index\n    best_policy_index = np.argmin(max_regret_per_policy)\n\n    return [int(best_policy_index), min_max_regret]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "我们用于决策支持的模型的可靠性至关重要，因为错误的模型可能导致灾难性的政策选择。本练习将介绍贝叶斯后验预测检验，这是一种强大的模型诊断技术，用于评估模型的基本假设是否与观测数据一致 。你将通过生成和比较模拟数据与真实数据，学习如何系统地诊断模型中可能存在的缺陷，例如忽略了重要变量或错误地假设了误差结构。",
            "id": "4129002",
            "problem": "您的任务是为一个简化的、耦合的自然-人类渔业系统的线性高斯模型执行贝叶斯后验预测检验。观测结果是捕捞量的对数，记为 $y_t$，它由人类捕捞努力程度 $H_t$ 和自然环境指数 $N_t$ 驱动。该模型是预测变量的线性模型，带有高斯噪声，并且系数服从高斯先验。您的程序必须通过从后验预测分布中生成重复数据，并计算用于诊断模型与观测值之间系统性失配来源的差异度量，来实现后验预测检验。目标是识别是否存在方差失配、残差自相关以及被忽略的延迟人类响应。\n\n基本假设：\n- 观测模型是线性高斯模型：对于时间 $t = 1, \\dots, T$，数据满足\n$$ y_t = \\beta_0 + \\beta_1 H_t + \\beta_2 N_t + \\varepsilon_t, \\quad \\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2), $$\n其中 $H_t$ 代表人类捕捞努力程度（单位：船-天），$N_t$ 代表自然驱动因素（无量纲指数），而 $y_t$ 是捕捞量的对数（单位：吨的自然对数）。三角函数中使用的角度以弧度为单位。\n- 系数的先验是高斯分布： $$ \\boldsymbol{\\beta} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_3), $$ 其中 $\\boldsymbol{\\beta} = (\\beta_0, \\beta_1, \\beta_2)^\\top$，$\\mathbf{I}_3$ 是 $3 \\times 3$ 的单位矩阵。\n- 方差 $\\sigma^2$ 和先验方差 $\\tau^2$ 是已知的。\n\n后验预测检验：\n- 给定设计矩阵 $\\mathbf{X} \\in \\mathbb{R}^{T \\times 3}$，其行为 $\\mathbf{x}_t = (1, H_t, N_t)$，似然为 $p(\\mathbf{y} | \\boldsymbol{\\beta}) = \\mathcal{N}(\\mathbf{X} \\boldsymbol{\\beta}, \\sigma^2 \\mathbf{I}_T)$，先验为 $p(\\boldsymbol{\\beta}) = \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_3)$。后验是高斯分布。从后验中抽取样本 $\\boldsymbol{\\beta}^{(m)}$（其中 $m = 1, \\dots, M$），并为每次抽取生成一个后验预测复制\n$$ \\mathbf{y}_{\\text{rep}}^{(m)} = \\mathbf{X} \\boldsymbol{\\beta}^{(m)} + \\boldsymbol{\\varepsilon}^{(m)}, \\quad \\boldsymbol{\\varepsilon}^{(m)} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_T). $$\n- 定义以下差异函数：\n    1. 方差差异：\n    $$ s^2(\\mathbf{y}) = \\frac{1}{T-1} \\sum_{t=1}^{T} \\left(y_t - \\bar{y}\\right)^2, \\quad \\bar{y} = \\frac{1}{T} \\sum_{t=1}^T y_t. $$\n    2. 残差一阶滞后自相关差异：\n    $$ a_1(\\mathbf{r}) = \\text{corr}(r_{2:T}, r_{1:(T-1)}), \\quad \\mathbf{r} = \\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta}, $$\n    使用相同的后验抽取 $\\boldsymbol{\\beta}^{(m)}$ 分别为观测残差和复制残差计算。\n    3. 残差与滞后人类努力程度的相关性差异：\n    $$ r_{H\\text{lag}}(\\mathbf{r}, \\mathbf{H}) = \\text{corr}(r_{2:T}, H_{1:(T-1)}). $$\n- 使用蒙特卡洛方法估计贝叶斯尾部概率（贝叶斯 $p$-值）：\n    - 方差： $$ p_{\\text{var}} = \\frac{1}{M} \\sum_{m=1}^M \\mathbb{I}\\left\\{ s^2\\left(\\mathbf{y}_{\\text{rep}}^{(m)}\\right) \\ge s^2(\\mathbf{y}) \\right\\}. $$\n    - 残差自相关： $$ p_{\\text{acf1}} = \\frac{1}{M} \\sum_{m=1}^M \\mathbb{I}\\left\\{ a_1\\left(\\mathbf{r}_{\\text{rep}}^{(m)}\\right) \\ge a_1(\\mathbf{r}^{(m)}) \\right\\}. $$\n    - 残差-滞后-努力程度： $$ p_{\\text{reslag}} = \\frac{1}{M} \\sum_{m=1}^M \\mathbb{I}\\left\\{ r_{H\\text{lag}}\\left(\\mathbf{r}_{\\text{rep}}^{(m)}, \\mathbf{H}\\right) \\ge r_{H\\text{lag}}(\\mathbf{r}^{(m)}, \\mathbf{H}) \\right\\}. $$\n- 如果对应的贝叶斯 $p$-值是极端的：$p \\le 0.1$ 或 $p \\ge 0.9$（用小数表示的双尾极端性准则），则标记该差异为失配。\n\n测试套件和模型配置：\n实现以下三个测试用例，以探究模型充分性的不同方面。对于每个用例，使用指定的系数和种子生成 $\\mathbf{H}$、$\\mathbf{N}$ 和 $\\mathbf{y}$。三角函数必须使用弧度。在所有情况下，用一个截距、$\\mathbf{H}$ 和 $\\mathbf{N}$ 来构建 $\\mathbf{X}$。\n\n- 用例 A（良定，“理想路径”）：\n    - 长度：$T = 30$。\n    - 随机种子：将生成器种子设置为 $123$。\n    - 努力程度： $$ H_t = 2 + 0.3\\frac{t}{T} + 0.5 \\sin\\left(\\frac{2\\pi t}{12}\\right) + \\eta_t, \\quad \\eta_t \\sim \\mathcal{N}(0, 0.2^2). $$\n    - 自然驱动因素： $$ N_t = 0.8 \\sin\\left(\\frac{2\\pi t}{6}\\right) + \\xi_t, \\quad \\xi_t \\sim \\mathcal{N}(0, 0.2^2). $$\n    - 用于生成观测数据的系数：$\\beta_0 = 1.0$，$\\beta_1 = 0.8$，$\\beta_2 = 0.5$。\n    - 观测噪声：$\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$，其中 $\\sigma^2 = 0.3^2$。\n    - 先验方差：$\\tau^2 = 10$。\n- 用例 B（忽略延迟的人类响应和过度离散）：\n    - 长度：$T = 30$。\n    - 随机种子：将生成器种子设置为 $456$。\n    - 努力程度：与用例 A 形式相同，但 $\\eta_t \\sim \\mathcal{N}(0, 0.2^2)$ 独立。\n    - 自然驱动因素：与用例 A 形式相同，但 $\\xi_t \\sim \\mathcal{N}(0, 0.2^2)$ 独立。\n    - 用于生成观测数据的系数：$\\beta_0 = 1.0$，$\\beta_1 = 0.8$，$\\beta_2 = 0.5$，加上一个延迟的努力程度效应 $\\gamma = 0.8$，其中\n    $$ y_t = \\beta_0 + \\beta_1 H_t + \\beta_2 N_t + \\gamma H_{t-1} + \\varepsilon_t, \\quad \\text{for } t \\ge 2, $$\n    对于 $t=1$ 使用 $y_1 = \\beta_0 + \\beta_1 H_1 + \\beta_2 N_1 + \\varepsilon_1$。\n    - 观测噪声：$\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$，其中 $\\sigma^2 = 0.6^2$（相对于模型的过度离散）。\n    - 先验方差：$\\tau^2 = 10$。\n- 用例 C（来自自然-人类动态的残差自相关）：\n    - 长度：$T = 20$。\n    - 随机种子：将生成器种子设置为 $789$。\n    - 努力程度和自然驱动因素：与用例 A 形式相同，但 $\\eta_t \\sim \\mathcal{N}(0, 0.2^2)$ 和 $\\xi_t \\sim \\mathcal{N}(0, 0.2^2)$ 独立。\n    - 用于生成观测数据的系数：$\\beta_0 = 1.0$，$\\beta_1 = 0.8$，$\\beta_2 = 0.5$。\n    - 观测噪声：参数为 $\\phi = 0.7$ 且新息为 $u_t \\sim \\mathcal{N}(0, 0.25^2)$ 的一阶自回归（AR(1)）\n    $$ \\varepsilon_t = \\phi \\varepsilon_{t-1} + u_t, \\quad \\varepsilon_1 = u_1, $$\n    因此，模型的独立误差假设被违反。\n    - 在拟合的模型中，设置 $\\sigma^2 = 0.25^2$ 和先验方差 $\\tau^2 = 10$。\n\n后验抽样细节：\n- 通过完成贝叶斯法则所蕴含的配方法来计算 $\\boldsymbol{\\beta}$ 的高斯后验。设 $\\mathbf{X} \\in \\mathbb{R}^{T \\times 3}$ 和 $\\mathbf{y} \\in \\mathbb{R}^T$。后验协方差和均值为\n$$ \\mathbf{S} = \\left( \\frac{1}{\\sigma^2} \\mathbf{X}^\\top \\mathbf{X} + \\frac{1}{\\tau^2} \\mathbf{I}_3 \\right)^{-1}, \\quad \\mathbf{m} = \\mathbf{S} \\left( \\frac{1}{\\sigma^2} \\mathbf{X}^\\top \\mathbf{y} \\right). $$\n- 抽取 $M$ 个样本 $\\boldsymbol{\\beta}^{(m)} \\sim \\mathcal{N}(\\mathbf{m}, \\mathbf{S})$，并为每次抽取生成一个复制 $\\mathbf{y}_{\\text{rep}}^{(m)}$。\n\n实现要求：\n- 每个测试用例使用 $M = 2000$ 次后验抽取和复制。\n- 所有三角计算均使用弧度。\n- 对于相关性计算，使用带无偏样本中心化的皮尔逊相关系数；如果方差在数值上为零，则使用一个小的常数进行正则化（例如，在分母上加上 $10^{-12}$）。\n- 您的程序应生成单行输出，其中按顺序包含用例 A、然后用例 B、然后用例 C 的三个差异（方差、残差一阶滞后自相关、残差-滞后-努力程度相关）的失配标志，形式为方括号内以逗号分隔的列表。每个标志必须是一个布尔值。要求的最终输出格式为：\n\"[caseA_var_flag,caseA_acf1_flag,caseA_reslag_flag,caseB_var_flag,caseB_acf1_flag,caseB_reslag_flag,caseC_var_flag,caseC_acf1_flag,caseC_reslag_flag]\"。",
            "solution": "该问题要求为一个简化的渔业系统线性高斯模型实现贝叶斯后验预测检验。首先评估问题陈述的有效性。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **观测模型**：$y_t = \\beta_0 + \\beta_1 H_t + \\beta_2 N_t + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$，对于 $t = 1, \\dots, T$。\n*   **先验分布**：$\\boldsymbol{\\beta} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_3)$，其中 $\\boldsymbol{\\beta} = (\\beta_0, \\beta_1, \\beta_2)^\\top$。\n*   **已知参数**：待拟合模型的误差方差 $\\sigma^2$ 和先验方差 $\\tau^2$ 是已知的。\n*   **设计矩阵**：$\\mathbf{X} \\in \\mathbb{R}^{T \\times 3}$ 的行为 $\\mathbf{x}_t = (1, H_t, N_t)$。\n*   **后验分布**：$\\boldsymbol{\\beta}$ 的后验分布是高斯分布 $\\mathcal{N}(\\mathbf{m}, \\mathbf{S})$，其均值 $\\mathbf{m} = \\mathbf{S} ( \\frac{1}{\\sigma^2} \\mathbf{X}^\\top \\mathbf{y} )$，协方差 $\\mathbf{S} = ( \\frac{1}{\\sigma^2} \\mathbf{X}^\\top \\mathbf{X} + \\frac{1}{\\tau^2} \\mathbf{I}_3 )^{-1}$。\n*   **后验预测复制**：对于一个后验样本 $\\boldsymbol{\\beta}^{(m)}$，生成一个复制 $\\mathbf{y}_{\\text{rep}}^{(m)} = \\mathbf{X} \\boldsymbol{\\beta}^{(m)} + \\boldsymbol{\\varepsilon}^{(m)}$，其中 $\\boldsymbol{\\varepsilon}^{(m)} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_T)$。需使用 $M = 2000$ 个样本。\n*   **差异度量**：\n    1.  方差：$s^2(\\mathbf{y}) = \\frac{1}{T-1} \\sum_{t=1}^{T} (y_t - \\bar{y})^2$。\n    2.  残差一阶滞后自相关：$a_1(\\mathbf{r}) = \\text{corr}(r_{2:T}, r_{1:(T-1)})$，对于残差 $\\mathbf{r} = \\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta}$。\n    3.  残差与滞后人类努力程度的相关性：$r_{H\\text{lag}}(\\mathbf{r}, \\mathbf{H}) = \\text{corr}(r_{2:T}, H_{1:(T-1)})$。\n*   **贝叶斯P值**：\n    1.  $p_{\\text{var}} = \\frac{1}{M} \\sum_{m=1}^M \\mathbb{I}\\{ s^2(\\mathbf{y}_{\\text{rep}}^{(m)}) \\ge s^2(\\mathbf{y}) \\}$。\n    2.  $p_{\\text{acf1}} = \\frac{1}{M} \\sum_{m=1}^M \\mathbb{I}\\{ a_1(\\mathbf{r}_{\\text{rep}}^{(m)}) \\ge a_1(\\mathbf{r}^{(m)}) \\}$。\n    3.  $p_{\\text{reslag}} = \\frac{1}{M} \\sum_{m=1}^M \\mathbb{I}\\{ r_{H\\text{lag}}(\\mathbf{r}_{\\text{rep}}^{(m)}, \\mathbf{H}) \\ge r_{H\\text{lag}}(\\mathbf{r}^{(m)}, \\mathbf{H}) \\}$。\n*   **失配准则**：如果贝叶斯 p 值 $p$ 满足 $p \\le 0.1$ 或 $p \\ge 0.9$，则标记为失配。\n*   **测试用例**：定义了三个用例（A、B、C），具有特定的种子、数据生成过程和模型参数。\n    *   **用例 A**：$T = 30$，种子=$123$，良定模型，数据生成和模型拟合均使用 $\\sigma^2 = 0.3^2$，$\\tau^2 = 10$。\n    *   **用例 B**：$T = 30$，种子=$456$，数据由一个省略的预测变量（$H_{t-1}$）和更大的噪声方差（$\\sigma^2_{\\text{true}} = 0.6^2$）生成。待拟合的模型是简单的线性模型。模型假定的 $\\sigma^2$ 没有明确说明。\n    *   **用例 C**：$T = 20$，种子=$789$，数据由 AR(1) 误差（$\\phi=0.7$，新息方差 $0.25^2$）生成，而模型假定误差是独立同分布（i.i.d.）的，其方差 $\\sigma^2 = 0.25^2$，$\\tau^2 = 10$。\n*   **实现说明**：使用皮尔逊相关系数，分母加上 $10^{-12}$ 正则化。\n\n**步骤2：使用提取的已知条件进行验证**\n\n该问题具有科学依据，采用了标准的贝叶斯方法进行模型检验。问题定义明确，为唯一的、可计算的解决方案提供了足够的细节。语言客观而精确。\n\n用例 B 中存在一个微小的模糊之处，即没有明确指定拟合模型的观测噪声方差，而真实数据生成方差被给定为 $\\sigma^2_{\\text{true}} = 0.6^2$。用例 A 在数据生成和模型拟合中使用了相同的 $\\sigma^2$。用例 C 明确地将它们解耦。用例 B 的意图似乎是测试一个在两方面存在错误设定的模型：一个被忽略的预测变量和一个关于误差方差的错误假设（数据相对于模型存在过度离散）。在这种情况下，最合乎逻辑和标准的解释是，用例 B 中测试的模型与用例 A 中的“基础”模型相同，即假设 $\\sigma^2 = 0.3^2$。这个假设使得用例 B 成为一个定义明确的模型不充分性测试。\n\n**步骤3：结论与行动**\n\n在对用例 B 的模型设定进行合理解释的情况下，该问题是**有效的**。解决方案将继续执行指定的程序。\n\n### 解决方案\n\n对于每个测试用例，该过程包括三个主要阶段：(1) 根据特定用例的过程生成合成观测数据；(2) 在给定这些数据的情况下，推导模型参数的后验分布；(3) 通过从模型中模拟重复数据，并使用指定的差异度量将其与观测数据进行比较，来执行后验预测检验。\n\n**1. 理论框架**\n\n分析的基础是贝叶斯定理，它将参数的先验分布 $p(\\boldsymbol{\\beta})$ 与给定参数下数据的似然 $p(\\mathbf{y}|\\boldsymbol{\\beta})$ 相结合，得到后验分布 $p(\\boldsymbol{\\beta}|\\mathbf{y})$。\n$$\np(\\boldsymbol{\\beta}|\\mathbf{y}, \\mathbf{X}, \\sigma^2, \\tau^2) \\propto p(\\mathbf{y}|\\boldsymbol{\\beta}, \\mathbf{X}, \\sigma^2) \\, p(\\boldsymbol{\\beta}|\\tau^2)\n$$\n给定高斯似然 $\\mathbf{y} \\sim \\mathcal{N}(\\mathbf{X}\\boldsymbol{\\beta}, \\sigma^2\\mathbf{I}_T)$ 和高斯先验 $\\boldsymbol{\\beta} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2\\mathbf{I}_3)$，得到的后验分布也是高斯分布 $\\boldsymbol{\\beta}|\\mathbf{y} \\sim \\mathcal{N}(\\mathbf{m}, \\mathbf{S})$。后验均值 $\\mathbf{m}$ 和协方差 $\\mathbf{S}$ 由以下公式给出：\n$$\n\\mathbf{S} = \\left( \\frac{1}{\\sigma^2} \\mathbf{X}^\\top \\mathbf{X} + \\frac{1}{\\tau^2} \\mathbf{I}_3 \\right)^{-1}\n$$\n$$\n\\mathbf{m} = \\mathbf{S} \\left( \\frac{1}{\\sigma^2} \\mathbf{X}^\\top \\mathbf{y} \\right)\n$$\n这些方程代表了在观测到数据 $\\mathbf{y}$ 之后关于参数 $\\boldsymbol{\\beta}$ 的更新知识状态。\n\n**2. 后验预测检验**\n\n后验预测检验是一种评估模型拟合度的方法，它通过检验模型能否生成与我们实际观测到的数据相似的数据。一个后验预测复制 $\\mathbf{y}_{\\text{rep}}$ 是从后验预测分布中生成的模拟数据集，\n$$\np(\\mathbf{y}_{\\text{rep}} | \\mathbf{y}) = \\int p(\\mathbf{y}_{\\text{rep}} | \\boldsymbol{\\beta}) \\, p(\\boldsymbol{\\beta} | \\mathbf{y}) \\, d\\boldsymbol{\\beta}\n$$\n在操作上，我们首先从后验分布 $\\mathcal{N}(\\mathbf{m}, \\mathbf{S})$ 中抽取一个参数向量 $\\boldsymbol{\\beta}^{(m)}$。然后，我们通过使用该参数值从似然函数中抽样来生成一个复制数据集：$\\mathbf{y}_{\\text{rep}}^{(m)} \\sim \\mathcal{N}(\\mathbf{X}\\boldsymbol{\\beta}^{(m)}, \\sigma^2\\mathbf{I}_T)$。\n\n然后我们定义差异度量 $T(\\mathbf{y}, \\boldsymbol{\\beta})$，它们是数据以及潜在参数的函数。选择这些度量是为了探查模型的特定潜在缺陷。我们将根据复制数据计算出的差异分布 $T(\\mathbf{y}_{\\text{rep}}, \\boldsymbol{\\beta})$ 与根据观测数据计算出的差异 $T(\\mathbf{y}, \\boldsymbol{\\beta})$ 进行比较。这两个分布之间的系统性差异表明模型存在失配。贝叶斯 p 值量化了这种比较。\n\n**3. 各用例的实现**\n\n对于三个测试用例中的每一个，都执行以下操作序列。\n\n**阶段 A：数据生成**\n使用特定用例的种子初始化一个随机数生成器。生成人类努力程度 $H_t$ 和自然驱动因素 $N_t$ 的时间序列。然后，根据该用例特定的线性模型生成观测结果 $y_t$，该模型可能包含拟合模型中不存在的结构性错误设定。\n\n*   **用例 A（良定）**：数据从将要拟合的精确模型生成，其中 $\\sigma^2 = 0.3^2$。\n*   **用例 B（忽略变量和过度离散）**：数据生成时带有一个额外的滞后努力项 $\\gamma H_{t-1}$，并具有更大的误差方差 $\\sigma^2_{\\text{true}} = 0.6^2$。如前所述，将要拟合的模型是简单模型（忽略滞后项），并将假定 $\\sigma^2 = 0.3^2$。\n*   **用例 C（自相关误差）**：数据是用 AR($1$) 误差生成的，违反了模型的独立性假设。模型将假设独立同分布（i.i.d.）误差进行拟合，其方差为 $\\sigma^2 = 0.25^2$，等于真实 AR($1$) 过程的新息方差。\n\n**阶段 B：后验抽样**\n设计矩阵 $\\mathbf{X}$ 由 $H_t$ 和 $N_t$ 构建。使用生成的数据 $\\mathbf{y}$ 和每个用例中为拟合指定的模型参数（$\\sigma^2$, $\\tau^2$），计算后验均值 $\\mathbf{m}$ 和协方差 $\\mathbf{S}$。然后，从该后验分布 $\\mathcal{N}(\\mathbf{m}, \\mathbf{S})$ 中抽取 $M=2000$ 个 $\\boldsymbol{\\beta}^{(m)}$ 样本。\n\n**阶段 C：差异计算和 P 值估计**\n一个循环运行 $m = 1, \\dots, M$ 次。在每次迭代中：\n1.  使用抽取的 $\\boldsymbol{\\beta}^{(m)}$ 生成一个后验预测复制 $\\mathbf{y}_{\\text{rep}}^{(m)}$。\n2.  计算差异度量。请注意，对于基于残差的差异（$a_1$ 和 $r_{H\\text{lag}}$），“观测”值通过残差 $\\mathbf{r}^{(m)} = \\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}^{(m)}$ 依赖于当前的参数抽取 $\\boldsymbol{\\beta}^{(m)}$。\n    *   $s^2(\\mathbf{y}_{\\text{rep}}^{(m)})$ 与固定值 $s^2(\\mathbf{y})$ 进行比较。\n    *   $a_1(\\mathbf{r}_{\\text{rep}}^{(m)})$ 与 $a_1(\\mathbf{r}^{(m)})$ 进行比较。\n    *   $r_{H\\text{lag}}(\\mathbf{r}_{\\text{rep}}^{(m)}, \\mathbf{H})$ 与 $r_{H\\text{lag}}(\\mathbf{r}^{(m)}, \\mathbf{H})$ 进行比较。\n3.  基于这些比较，指示函数递增。\n\n循环结束后，通过将指示函数的总和除以 $M$ 来计算贝叶斯 p 值（$p_{\\text{var}}$，$p_{\\text{acf1}}$，$p_{\\text{reslag}}$）。最后，根据极端性准则（$p \\le 0.1$ 或 $p \\ge 0.9$）检查每个 p 值，以确定布尔失配标志。然后将三个用例的九个标志合并到最终输出中。\n\n实现了一个自定义的皮尔逊相关函数来处理数值稳定性所需的正则化。\n这个全面的过程允许在不同条件下对模型的充分性进行严格诊断，突出显示了假设的模型结构未能很好地捕捉数据的哪些方面。",
            "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef custom_corr(x, y, reg=1e-12):\n    \"\"\"\n    Computes the Pearson correlation coefficient with a regularization term.\n    \"\"\"\n    if x.ndim != 1 or y.ndim != 1 or len(x) != len(y):\n        raise ValueError(\"Inputs must be 1D arrays of the same length.\")\n\n    x_mean, y_mean = np.mean(x), np.mean(y)\n    x_c, y_c = x - x_mean, y - y_mean\n    \n    numerator = np.sum(x_c * y_c)\n    \n    denom_x_sq = np.sum(x_c**2)\n    denom_y_sq = np.sum(y_c**2)\n    \n    denominator = np.sqrt(denom_x_sq * denom_y_sq) + reg\n    \n    if denominator == 0:\n        return 0.0\n    \n    return numerator / denominator\n\ndef run_posterior_predictive_check(case_params):\n    \"\"\"\n    Runs the full posterior predictive check for a given test case.\n    \"\"\"\n    \n    T = case_params['T']\n    seed = case_params['seed']\n    gen_coeffs = case_params['gen_coeffs']\n    model_sigma2 = case_params['model_sigma2']\n    tau2 = case_params['tau2']\n    M = case_params['M']\n    \n    rng = np.random.default_rng(seed)\n\n    # Stage 1: Generate synthetic data\n    t_vals = np.arange(1, T + 1)\n    \n    # Generate predictors H and N\n    eta = rng.normal(0, np.sqrt(0.2**2), T)\n    H_t = 2 + 0.3 * (t_vals / T) + 0.5 * np.sin(2 * np.pi * t_vals / 12) + eta\n    \n    xi = rng.normal(0, np.sqrt(0.2**2), T)\n    N_t = 0.8 * np.sin(2 * np.pi * t_vals / 6) + xi\n    \n    # Design matrix\n    X = np.vstack([np.ones(T), H_t, N_t]).T\n    \n    # Generate observed outcome y_t based on case\n    # Case A: Well-specified\n    if case_params['name'] == 'A':\n        gen_sigma2 = 0.3**2\n        eps = rng.normal(0, np.sqrt(gen_sigma2), T)\n        y_obs = X @ gen_coeffs + eps\n    \n    # Case B: Omitted variable and overdispersion\n    elif case_params['name'] == 'B':\n        gen_sigma2 = 0.6**2\n        gamma = 0.8\n        H_lag = np.roll(H_t, 1)\n        H_lag[0] = 0 # No lagged effect for t=1\n        eps = rng.normal(0, np.sqrt(gen_sigma2), T)\n        \n        y_obs = X @ gen_coeffs + gamma * H_lag + eps\n        \n    # Case C: Autocorrelated errors\n    elif case_params['name'] == 'C':\n        phi = 0.7\n        u = rng.normal(0, np.sqrt(0.25**2), T)\n        eps = np.zeros(T)\n        eps[0] = u[0]\n        for t in range(1, T):\n            eps[t] = phi * eps[t-1] + u[t]\n        y_obs = X @ gen_coeffs + eps\n\n    # Stage 2: Compute posterior distribution\n    # S = (1/sigma^2 * X.T @ X + 1/tau^2 * I)^-1\n    # m = S @ (1/sigma^2 * X.T @ y)\n    S_inv = (1 / model_sigma2) * (X.T @ X) + (1 / tau2) * np.identity(3)\n    S_post = np.linalg.inv(S_inv)\n    m_post = S_post @ ((1 / model_sigma2) * (X.T @ y_obs))\n\n    # Stage 3: Posterior predictive checks\n    beta_samples = rng.multivariate_normal(m_post, S_post, size=M)\n    \n    # Discrepancy for observed data that does not depend on beta\n    s2_obs = np.var(y_obs, ddof=1)\n    \n    # Placeholders for counts\n    var_count = 0\n    acf1_count = 0\n    reslag_count = 0\n    \n    for m in range(M):\n        beta_m = beta_samples[m]\n        \n        # Generate replicated data\n        eps_rep = rng.normal(0, np.sqrt(model_sigma2), T)\n        y_rep = X @ beta_m + eps_rep\n        \n        # 1. Variance discrepancy\n        s2_rep = np.var(y_rep, ddof=1)\n        if s2_rep >= s2_obs:\n            var_count += 1\n            \n        # Residuals depend on beta_m\n        r_obs_m = y_obs - X @ beta_m\n        r_rep_m = y_rep - X @ beta_m\n        \n        # 2. Residual lag-1 autocorrelation discrepancy\n        a1_obs_m = custom_corr(r_obs_m[1:], r_obs_m[:-1])\n        a1_rep_m = custom_corr(r_rep_m[1:], r_rep_m[:-1])\n        if a1_rep_m >= a1_obs_m:\n            acf1_count += 1\n            \n        # 3. Residual lagged human effort correlation discrepancy\n        H_lag_pred = H_t[:-1]\n        r_obs_m_sliced = r_obs_m[1:]\n        r_rep_m_sliced = r_rep_m[1:]\n        \n        rh_lag_obs_m = custom_corr(r_obs_m_sliced, H_lag_pred)\n        rh_lag_rep_m = custom_corr(r_rep_m_sliced, H_lag_pred)\n        if rh_lag_rep_m >= rh_lag_obs_m:\n            reslag_count += 1\n            \n    # Compute Bayesian p-values\n    p_var = var_count / M\n    p_acf1 = acf1_count / M\n    p_reslag = reslag_count / M\n    \n    # Determine flags based on p-values\n    var_flag = p_var = 0.1 or p_var >= 0.9\n    acf1_flag = p_acf1 = 0.1 or p_acf1 >= 0.9\n    reslag_flag = p_reslag = 0.1 or p_reslag >= 0.9\n    \n    return [var_flag, acf1_flag, reslag_flag]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    base_params = {\n        'tau2': 10.0,\n        'M': 2000,\n    }\n    \n    case_A_params = {\n        'name': 'A',\n        'T': 30,\n        'seed': 123,\n        'gen_coeffs': np.array([1.0, 0.8, 0.5]),\n        'model_sigma2': 0.3**2,\n        **base_params\n    }\n    \n    case_B_params = {\n        'name': 'B',\n        'T': 30,\n        'seed': 456,\n        'gen_coeffs': np.array([1.0, 0.8, 0.5]),\n        'model_sigma2': 0.3**2, # Model assumes this, but data has 0.6^2\n        **base_params\n    }\n    \n    case_C_params = {\n        'name': 'C',\n        'T': 20,\n        'seed': 789,\n        'gen_coeffs': np.array([1.0, 0.8, 0.5]),\n        'model_sigma2': 0.25**2, # Model assumes this, true process is AR(1)\n        **base_params\n    }\n\n    results = []\n    \n    results.extend(run_posterior_predictive_check(case_A_params))\n    results.extend(run_posterior_predictive_check(case_B_params))\n    results.extend(run_posterior_predictive_check(case_C_params))\n    \n    # Format the boolean results for printing\n    formatted_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}