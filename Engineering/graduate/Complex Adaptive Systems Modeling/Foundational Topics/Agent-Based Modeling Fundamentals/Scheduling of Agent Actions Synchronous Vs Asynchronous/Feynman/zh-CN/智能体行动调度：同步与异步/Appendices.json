{
    "hands_on_practices": [
        {
            "introduction": "异步调度的一个核心特征是其结果可能依赖于主体更新的顺序。本练习通过一个由三个主体组成的极简循环网络，直接展示了这种“路径依赖”现象。你将看到，仅仅改变主体更新的微观顺序，就会导致系统演化到截然不同的宏观状态，这揭示了非交换性更新在复杂系统中引发的深刻后果。",
            "id": "4142152",
            "problem": "考虑一个包含 $3$ 个主体（标记为 $A$、$B$ 和 $C$）的基于主体的模型 (ABM)，这些主体排列成一个有向循环 $A \\to B \\to C \\to A$。每个主体 $i \\in \\{A,B,C\\}$ 都有一个二元状态 $x_i \\in \\{0,1\\}$，并根据一个仅依赖于其单个入邻居的局部阈值规则来更新其状态。令 $H:\\mathbb{R}\\to\\{0,1\\}$ 表示 Heaviside 阶跃函数，定义为：当 $u>0$ 时 $H(u)=1$，当 $u \\le 0$ 时 $H(u)=0$。局部更新规则为\n$$\nx_A \\leftarrow H\\!\\big(x_C - \\theta\\big), \\quad x_B \\leftarrow H\\!\\big(x_A - \\theta\\big), \\quad x_C \\leftarrow H\\!\\big(x_B - \\theta\\big),\n$$\n阈值为 $\\theta = 0.5$。在一个短时间窗口开始时的初始状态为\n$$\n\\boldsymbol{x}^{(0)} = \\begin{pmatrix} x_A^{(0)} \\\\ x_B^{(0)} \\\\ x_C^{(0)} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}.\n$$\n\n在一个短时间窗口内，同步更新调度使用窗口前的状态同时更新所有三个主体，而异步更新调度则使用最近更新的值，一次一个地原位更新主体。考虑由排列 $\\pi_1=(A,B,C)$ 和 $\\pi_2=(B,C,A)$ 表示的两种异步更新调度，每种调度在时间窗口内对每个主体恰好应用一次局部更新。\n\n将路径依赖量级定义为两个窗口后状态之差的 1-范数，\n$$\nD \\equiv \\left\\| \\boldsymbol{x}^{(\\pi_1)} - \\boldsymbol{x}^{(\\pi_2)} \\right\\|_1,\n$$\n其中 $\\boldsymbol{x}^{(\\pi)}$ 表示在窗口内执行排列 $\\pi$ 所得到的状态向量。\n\n从 $\\boldsymbol{x}^{(0)}$ 出发，使用上述更新规则，计算 $D$。将您的最终结果表示为一个精确整数。无需四舍五入。不涉及物理单位。",
            "solution": "首先验证问题，以确保其具有科学依据、是良定的且客观的。\n给定条件是：\n- $3$ 个主体的集合 $\\{A, B, C\\}$，其状态为 $x_A, x_B, x_C \\in \\{0, 1\\}$。\n- 一个有向网络拓扑：$A \\to B \\to C \\to A$。\n- 一个 Heaviside 阶跃函数 $H(u)$，定义为当 $u > 0$ 时为 $1$，当 $u \\le 0$ 时为 $0$。\n- 局部更新规则：$x_A \\leftarrow H(x_C - \\theta)$，$x_B \\leftarrow H(x_A - \\theta)$，$x_C \\leftarrow H(x_B - \\theta)$。\n- 一个固定的阈值 $\\theta = 0.5$。\n- 在时间 $t=0$ 时的初始状态向量：$\\boldsymbol{x}^{(0)} = \\begin{pmatrix} x_A^{(0)} \\\\ x_B^{(0)} \\\\ x_C^{(0)} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n- 两种异步更新调度（排列）：$\\pi_1=(A,B,C)$ 和 $\\pi_2=(B,C,A)$。\n- 路径依赖量级的定义：$D \\equiv \\left\\| \\boldsymbol{x}^{(\\pi_1)} - \\boldsymbol{x}^{(\\pi_2)} \\right\\|_1$。\n\n该问题是离散动力系统中的一个定义明确的练习，特别是布尔网络，这是复杂系统建模中的一个标准课题。所有术语都有形式化定义，初始条件和规则足以计算出唯一解。因此，该问题是有效的。\n\n求解过程是通过计算每个异步更新调度下的最终状态向量 $\\boldsymbol{x}^{(\\pi_1)}$ 和 $\\boldsymbol{x}^{(\\pi_2)}$，然后计算它们差值的 1-范数。异步更新是“原位”的，意味着一个主体的状态被立即更新，并且这个新值会被更新序列中的任何后续主体使用。\n\n令状态向量为 $\\boldsymbol{x} = \\begin{pmatrix} x_A \\\\ x_B \\\\ x_C \\end{pmatrix}$。\n初始状态为 $\\boldsymbol{x}^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n阈值为 $\\theta = 0.5$。\n\n首先，我们计算调度 $\\pi_1 = (A,B,C)$ 的最终状态 $\\boldsymbol{x}^{(\\pi_1)}$。\n更新按顺序执行：先 $A$，然后 $B$，再然后 $C$。\n\n1.  更新主体 $A$：规则是 $x_A \\leftarrow H(x_C - \\theta)$。当前状态为 $(x_A, x_B, x_C) = (0, 0, 1)$。$A$ 的输入是 $x_C=1$。\n    $$x_A' = H(1 - 0.5) = H(0.5) = 1$$\n    状态向量变为 $\\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n\n2.  更新主体 $B$：规则是 $x_B \\leftarrow H(x_A - \\theta)$。当前状态为 $(x_A, x_B, x_C) = (1, 0, 1)$。$B$ 的输入是新更新的状态 $x_A=1$。\n    $$x_B' = H(1 - 0.5) = H(0.5) = 1$$\n    状态向量变为 $\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n\n3.  更新主体 $C$：规则是 $x_C \\leftarrow H(x_B - \\theta)$。当前状态为 $(x_A, x_B, x_C) = (1, 1, 1)$。$C$ 的输入是新更新的状态 $x_B=1$。\n    $$x_C' = H(1 - 0.5) = H(0.5) = 1$$\n    状态向量变为 $\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n\n执行调度 $\\pi_1$ 后的最终状态为 $\\boldsymbol{x}^{(\\pi_1)} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n\n接下来，我们计算调度 $\\pi_2 = (B,C,A)$ 的最终状态 $\\boldsymbol{x}^{(\\pi_2)}$。\n更新按顺序执行：先 $B$，然后 $C$，再然后 $A$。系统从初始状态 $\\boldsymbol{x}^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$ 重新开始。\n\n1.  更新主体 $B$：规则是 $x_B \\leftarrow H(x_A - \\theta)$。当前状态为 $(x_A, x_B, x_C) = (0, 0, 1)$。$B$ 的输入是初始状态 $x_A=0$。\n    $$x_B' = H(0 - 0.5) = H(-0.5) = 0$$\n    状态向量保持为 $\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n\n2.  更新主体 $C$：规则是 $x_C \\leftarrow H(x_B - \\theta)$。当前状态为 $(x_A, x_B, x_C) = (0, 0, 1)$。$C$ 的输入是新更新的状态 $x_B=0$。\n    $$x_C' = H(0 - 0.5) = H(-0.5) = 0$$\n    状态向量变为 $\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n\n3.  更新主体 $A$：规则是 $x_A \\leftarrow H(x_C - \\theta)$。当前状态为 $(x_A, x_B, x_C) = (0, 0, 0)$。$A$ 的输入是新更新的状态 $x_C=0$。\n    $$x_A' = H(0 - 0.5) = H(-0.5) = 0$$\n    状态向量保持为 $\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n\n执行调度 $\\pi_2$ 后的最终状态为 $\\boldsymbol{x}^{(\\pi_2)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n\n最后，我们计算路径依赖量级 $D$。\n$$D = \\left\\| \\boldsymbol{x}^{(\\pi_1)} - \\boldsymbol{x}^{(\\pi_2)} \\right\\|_1$$\n差分向量是：\n$$\\boldsymbol{x}^{(\\pi_1)} - \\boldsymbol{x}^{(\\pi_2)} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$$\n1-范数是向量各分量绝对值之和：\n$$D = |1| + |1| + |1| = 1 + 1 + 1 = 3$$\n路径依赖量级为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "同步调度虽然通过让所有主体基于同一过去状态快照进行更新来避免路径依赖，但它也引入了其自身特有的挑战，即冲突解决。本练习将引导你量化一个经典的空间主体模型问题：当所有主体同时尝试移动到邻近单元时，预期会发生多少次“碰撞”。通过这个计算，你将深入理解在并行系统中资源竞争的数学模型。",
            "id": "4142125",
            "problem": "考虑一个由 $M$ 个单元格组成的二维环形网格（周期性边界条件），其中每个单元格根据一个固定的对称邻域恰好有 $z$ 个相邻单元格（例如，冯·诺伊曼邻域为 $z=4$ 或摩尔邻域为 $z=8$）。每个单元格最多只能容纳一个智能体，初始占用情况是独立同分布的（IID），占用概率（智能体密度）为 $\\rho \\in [0,1]$，因此智能体的期望数量为 $N=\\rho M$。在同步调度下，每个智能体同时从其 $z$ 个邻居中均匀随机地选择一个相邻单元格，并向该选定的单元格发出单个移动请求。碰撞定义为在同一个同步步骤中收到至少两个移动请求的任何单元格。仅使用伯努利试验和二项分布的基本定义，推导出一个关于智能体密度 $\\rho$、邻域大小 $z$ 和单元格数量 $M$ 的碰撞单元格期望数量的闭式解析表达式。将你的最终答案表示为单个闭式表达式，不要进行任何四舍五入。",
            "solution": "问题要求在一个环形网格上的同步智能体模型中，计算碰撞单元格的期望数量。设 $C$ 为代表碰撞单元格总数的随机变量。目标是计算 $C$ 的期望，记为 $E[C]$。\n\n我们可以利用期望的线性性质来解决这个问题。将网格的单元格从 $j=1$ 索引到 $M$。我们定义一组指示随机变量 $\\{I_j\\}_{j=1}^{M}$，其中如果单元格 $j$ 是一个碰撞单元格，则 $I_j=1$，否则 $I_j=0$。碰撞单元格的总数是这些指示变量的总和：\n$$C = \\sum_{j=1}^{M} I_j$$\n根据期望的线性性质，碰撞单元格的总期望数量是各个指示变量期望的总和：\n$$E[C] = E\\left[\\sum_{j=1}^{M} I_j\\right] = \\sum_{j=1}^{M} E[I_j]$$\n指示变量的期望等于它所指示事件的概率。因此，$E[I_j] = P(I_j=1)$，即单元格 $j$ 成为碰撞单元格的概率。\n\n问题陈述，网格具有周期性边界条件（它是一个环面），邻域结构对每个单元格都是对称且相同的，并且初始智能体分布是独立同分布的（IID）。由于这种系统性的同质性，任何给定单元格 $j$ 成为碰撞单元格的概率对于所有的 $j$ 都是相同的。我们用 $P_{coll}$ 来表示这个常数概率。\n$$E[I_j] = P(I_j=1) = P_{coll} \\quad \\forall j \\in \\{1, 2, \\dots, M\\}$$\n因此，碰撞单元格的期望数量简化为：\n$$E[C] = \\sum_{j=1}^{M} P_{coll} = M \\cdot P_{coll}$$\n问题现在简化为计算一个任意单元格的 $P_{coll}$。让我们关注一个单一的、任意的单元格，我们可以将其标记为单元格 $j$。\n\n碰撞被定义为一个单元格在单个同步步骤中收到至少两个移动请求。设 $K_j$ 为单元格 $j$ 收到的移动请求数量的随机变量。如果事件 $\\{K_j \\ge 2\\}$ 发生，则在单元格 $j$ 处发生碰撞。因此，\n$$P_{coll} = P(K_j \\ge 2)$$\n通常使用补集法则计算这个概率会更容易：\n$$P_{coll} = 1 - P(K_j  2) = 1 - P(K_j = 0) - P(K_j = 1)$$\n对单元格 $j$ 的移动请求只能由居住在其相邻单元格之一的智能体发出。问题规定每个单元格恰好有 $z$ 个邻居。设 $\\mathcal{N}(j)$ 为单元格 $j$ 的 $z$ 个邻居的集合。\n\n现在，我们通过将 $\\mathcal{N}(j)$ 中的每个邻居视为一个潜在请求的来源来为请求数量 $K_j$ 建模。对于每个邻居 $k \\in \\mathcal{N}(j)$，如果满足以下两个条件，则会向单元格 $j$ 发送一个请求：\n1.  单元格 $k$ 被一个智能体占据。此事件的概率即为智能体密度 $\\rho$。\n2.  如果单元格 $k$ 处的智能体存在，它会选择移动到单元格 $j$。由于每个智能体从其 $z$ 个邻居中均匀随机地选择一个，并且邻域是对称的（如果 $k \\in \\mathcal{N}(j)$，那么 $j \\in \\mathcal{N}(k)$），这个选择的概率是 $\\frac{1}{z}$。\n\n智能体位于单元格 $k$ 的事件与其移动选择是独立的。因此，一个特定的邻居 $k \\in \\mathcal{N}(j)$ 向单元格 $j$ 发送请求的概率是这些概率的乘积。我们将此概率称为 $p$：\n$$p = P(\\text{claim from } k) = P(\\text{agent at } k) \\times P(\\text{agent at } k \\text{ moves to } j) = \\rho \\cdot \\frac{1}{z} = \\frac{\\rho}{z}$$\n问题陈述，初始智能体占用是独立同分布的。不同智能体的移动决策也是独立事件。因此，单元格 $j$ 是否从一个邻居收到请求，与它是否从任何其他邻居收到请求是独立的事件。这就建立了一个包含 $z$ 次独立伯努利试验的序列，其中每次试验对应一个邻居，“成功”对应于该邻居向单元格 $j$ 发送一个请求。每次试验成功的概率是 $p = \\frac{\\rho}{z}$。\n\n请求的总数 $K_j$ 是这 $z$ 次试验中成功的总次数。这遵循一个参数为 $n=z$ 和 $p=\\frac{\\rho}{z}$ 的二项分布。我们将其写作 $K_j \\sim \\text{Binomial}(n=z, p=\\frac{\\rho}{z})$。\n\n二项分布的概率质量函数由 $P(K_j=k) = \\binom{n}{k} p^k (1-p)^{n-k}$ 给出。我们现在可以计算 $K_j=0$ 和 $K_j=1$ 的概率：\n对于 $K_j=0$：\n$$P(K_j=0) = \\binom{z}{0} \\left(\\frac{\\rho}{z}\\right)^0 \\left(1 - \\frac{\\rho}{z}\\right)^{z-0} = 1 \\cdot 1 \\cdot \\left(1 - \\frac{\\rho}{z}\\right)^z = \\left(1 - \\frac{\\rho}{z}\\right)^z$$\n对于 $K_j=1$：\n$$P(K_j=1) = \\binom{z}{1} \\left(\\frac{\\rho}{z}\\right)^1 \\left(1 - \\frac{\\rho}{z}\\right)^{z-1} = z \\cdot \\frac{\\rho}{z} \\cdot \\left(1 - \\frac{\\rho}{z}\\right)^{z-1} = \\rho \\left(1 - \\frac{\\rho}{z}\\right)^{z-1}$$\n现在，我们可以将这些结果代入 $P_{coll}$ 的表达式中：\n$$P_{coll} = 1 - P(K_j=0) - P(K_j=1) = 1 - \\left(1 - \\frac{\\rho}{z}\\right)^z - \\rho \\left(1 - \\frac{\\rho}{z}\\right)^{z-1}$$\n最后，我们将 $P_{coll}$ 的这个表达式代回到我们关于碰撞单元格总期望数量的方程 $E[C] = M \\cdot P_{coll}$ 中：\n$$E[C] = M \\left[ 1 - \\left(1 - \\frac{\\rho}{z}\\right)^z - \\rho \\left(1 - \\frac{\\rho}{z}\\right)^{z-1} \\right]$$\n这就是关于智能体密度 $\\rho$、邻域大小 $z$ 和单元格数量 $M$ 的碰撞单元格期望数量的闭式解析表达式。",
            "answer": "$$\\boxed{M \\left[ 1 - \\left(1 - \\frac{\\rho}{z}\\right)^z - \\rho \\left(1 - \\frac{\\rho}{z}\\right)^{z-1} \\right]}$$"
        },
        {
            "introduction": "在分别探讨了异步和同步调度的挑战之后，我们来探索一种能够调和这两种范式的精密技术。本练习旨在研究如何通过精心设计的并行异步调度，来精确复现完全同步更新的结果。你将推导出实现这种等效性的条件，并发现它与图论中的一个基本概念——顶点着色——之间深刻的内在联系。",
            "id": "4142171",
            "problem": "考虑一个复杂自适应系统（CAS），它由 $n$ 个智能体组成，这些智能体由一个无向简单图 $G=(V,E)$ 的顶点集 $V$ 索引。在离散时间 $t \\in \\mathbb{Z}_{\\ge 0}$，每个智能体 $i \\in V$ 都有一个状态 $x_i(t) \\in \\mathbb{R}$。智能体 $i$ 的局部更新规则是一个确定性函数 $F_i$，它仅依赖于 $i$ 的当前状态及其邻居的当前状态，即，\n$$x_i(t+1)=F_i\\!\\Big(x_i(t),\\{x_j(t):j\\in N(i)\\}\\Big),$$ \n其中 $N(i)=\\{j\\in V:(i,j)\\in E\\}$ 是 $i$ 的开邻域。同步调度在时间 $t$ 同时应用所有局部更新规则，一步从 $x(t)$ 生成 $x(t+1)$。异步调度并行地对智能体的子集进行更新，并可能将多个这样的并行子集串联起来，以完成从 $t$ 到 $t+1$ 的一个宏观步骤。\n\n要求您从依赖图和局部更新语义的第一性原理出发，推导在何种条件下，一个限制在 $G$ 的独立集（没有内部边的顶点集）上的异步调度能够为一个宏观步骤精确模拟同步调度，同时避免写-写和读-写冲突。具体而言：\n\n- 推导关于图 $G$、局部更新函数族 $\\{F_i\\}_{i\\in V}$ 以及异步调度协议的充分必要条件，使得在构成 $G$ 的正常着色的颜色类 $C_1,\\dots,C_m$ 上执行并行更新，对于所有初始状态 $x(t)$，都能产生与同步调度相同的 $x(t+1)$。\n\n- 您的推导必须从核心定义开始：邻域局部性、图中的独立性，以及从时间 $t$ 的快照读取并向时间 $(t+1)$ 的缓冲区写入的语义。除了这些基础概念之外，不要假设或引用任何快捷公式。\n\n在建立这些条件之后，计算为以下特定交互图 $G$ 形成此类无冲突并行更新集所需的最少颜色数：\n- 顶点集为 $V=\\{1,2,3,4,5,6,7,8,9,10\\}$。\n- 边集 $E$ 由以下边对组成 \n$$\\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4),(1,5),(2,5),(2,6),(3,6),(3,7),(4,7),(4,8),(1,8),(1,9),(3,9),(2,10),(4,10)\\}.$$\n\n将边解释为无向邻接关系。最终答案必须是根据您推导的条件，能够使并行独立集更新模拟同步更新的 $G$ 的正常着色所需的最少颜色数。最终答案表示为单个整数。无需四舍五入，不涉及物理单位。",
            "solution": "问题要求两个主要部分：首先，推导在何种充分必要条件下，一个特定的异步更新调度可以为一个图上的一般复杂自适应系统（CAS）精确模拟同步调度；其次，应用这些发现来计算给定图 $G$ 的一个特定属性。\n\n### 第一部分：条件的推导\n\n设系统由图 $G=(V,E)$ 定义，在离散时间 $t \\in \\mathbb{Z}_{\\ge 0}$，智能体状态为 $x(t) = (x_i(t))_{i \\in V}$。\n\n**1. 同步调度的语义**\n\n在同步更新中，所有智能体的下一个状态都是基于系统在当前时间 $t$ 的完整状态计算的。对于每个智能体 $i \\in V$，新状态 $x_i(t+1)_{\\text{sync}}$ 由下式给出：\n$$x_i(t+1)_{\\text{sync}} = F_i\\Big(x_i(t), \\{x_j(t) : j \\in N(i)\\}\\Big)$$\n关键原则是整个系统中的每个函数 $F_i$ 都从状态向量 $x(t)$ 的同一个“时间-$t$ 快照”中读取。所有结果 $\\{x_i(t+1)_{\\text{sync}}\\}_{i \\in V}$ 的集合构成了新的状态向量 $x(t+1)$。这可以被概念化为一个双缓冲过程：\n- 一个`读`缓冲区包含 $x(t)$，并且在更新步骤中不被修改。\n- 一个`写`缓冲区初始为空，用新的状态 $x_i(t+1)$ 填充。\n所有计算完成后，`写`缓冲区包含完整的状态向量 $x(t+1)$。\n\n**2. 异步调度的语义**\n\n所提议的异步调度将顶点集 $V$ 划分成不相交的独立集 $C_1, C_2, \\dots, C_m$，它们是正常顶点着色的颜色类。该调度按顺序遍历这些类别，对给定类别内的所有智能体执行并行更新。我们来分析数据依赖关系。\n\n为了精确模拟同步调度，异步协议必须产生一个最终状态 $x(t+1)_{\\text{async}}$，使得对于所有 $i \\in V$、任意初始状态 $x(t)$ 和任意有效的局部更新函数集 $\\{F_i\\}$，都有 $x_i(t+1)_{\\text{async}} = x_i(t+1)_{\\text{sync}}$。\n\n这意味着对于每个智能体 $i$，提供给其更新函数 $F_i$ 的参数必须与同步情况下的参数完全相同。也就是说，对智能体 $i$ 的更新计算必须使用来自时间 $t$ 快照的智能体 $i$ 及其邻居 $N(i)$ 的状态。\n\n我们来考虑异步协议的两种可能实现方式。\n\n**情况A：就地更新（单缓冲）**\n如果更新是“就地”执行的，那么智能体的状态一旦计算出来就会被覆盖。设 $x^{(k)}$ 是 $C_k$ 中智能体更新后的状态向量，其中 $x^{(0)} = x(t)$。当更新一个智能体 $i \\in C_p$（其中 $p1$）时，计算将是：\n$$x_i' = F_i\\Big(x_i^{(p-1)}, \\{x_j^{(p-1)} : j \\in N(i)\\}\\Big)$$\n为了使其与同步更新相匹配，我们要求对于 $F_i$ 输入集中的所有 $k$，即对于 $k \\in \\{i\\} \\cup N(i)$，都有 $x_k^{(p-1)} = x_k(t)$。\n- 智能体 $i$ 在 $C_p$ 中，因此它在步骤 $1, \\dots, p-1$ 中没有被更新。因此，$x_i^{(p-1)} = x_i(t)$ 自动满足。\n- 然而，对于一个邻居 $j \\in N(i)$，如果 $j$ 属于一个颜色类 $C_k$ 且 $k  p$，它的状态就已经被更新了，这意味着通常情况下 $x_j^{(p-1)} \\neq x_j(t)$。这相对于同步语义来说是一种写后读（read-after-write）风险。\n- 为了防止这种情况，必须要求对于任何 $i \\in C_p$，其邻居 $j \\in N(i)$ 都不属于任何 $k  p$ 的颜色类 $C_k$。这将导致一个荒谬的条件，即每个智能体都必须在所有邻居之前更新，这在循环图中是不可能的。因此，就地更新通常不能精确模拟同步调度。\n\n**情况B：双缓冲更新**\n现在，考虑一个明确使用双缓冲的异步协议。协议如下：\n1.  在宏观步骤开始时，存在一个包含 $x(t)$ 的只读状态快照。\n2.  对于每个颜色类 $C_k$（从 $k=1$ 到 $m$）：\n    -   对于该类中的每个智能体 $i \\in C_k$，并行计算其新状态 $x_i' = F_i\\Big(x_i(t), \\{x_j(t) : j \\in N(i)\\}\\Big)$。所有这些计算都只从时间 $t$ 的快照中读取。\n    -   将计算出的新状态 $x_i'$ 写入一个单独的 $x(t+1)$ 缓冲区。\n3.  在所有颜色类都处理完毕后，$x(t+1)$ 缓冲区包含完整的下一状态，并且宏观步骤完成。\n\n在这个协议下，对于每个智能体 $i \\in V$，无论它属于哪个颜色类 $C_k$，它的更新计算都严格使用来自时间 $t$ 的值。这正是同步调度的定义。\n$$x_i(t+1)_{\\text{async}} = x_i' = F_i\\Big(x_i(t), \\{x_j(t) : j \\in N(i)\\}\\Big) = x_i(t+1)_{\\text{sync}}$$\n因此，这种双缓冲异步调度精确地模拟了同步调度。那么，关于颜色类的条件是什么呢？\n-   **写-写冲突**：在任何并行更新步骤中（即在单个颜色类 $C_k$ 内），两个不同的智能体 $i, j \\in C_k$ 不能同时写入同一内存位置。由于每个智能体 $i$ 只更新自己的状态 $x_i$，只要 $i \\neq j$，就不会有写-写冲突。这是保证的，因为我们处理的是不同的智能体。\n-   **读-写冲突**：在并行更新 $C_k$ 时，一个智能体 $i$ 的更新不能读取另一个同时更新的智能体 $j$ 正在写入的值。我们的双缓冲协议通过设计防止了这一点。\n-   **并行化效率**：虽然双缓冲解决了正确性问题，但并行更新一个独立集（颜色类）具有实际优势。在更新 $C_k$ 中的所有智能体时，由于没有 $i, j \\in C_k$ 使得 $(i,j) \\in E$，所以更新 $i$ 所需的邻居状态 $\\{x_j(t) : j \\in N(i)\\}$ 不包含任何其他当前正在更新的智能体的状态。这简化了数据局部性和缓存管理。\n\n**结论**：\n为了使按颜色类顺序进行的并行异步调度精确模拟同步调度，**充分必要条件**是：\n1.  该调度必须在逻辑上等同于双缓冲方案：宏观步骤内所有局部更新函数的计算都必须从宏观步骤开始时的状态快照（时间 $t$）中读取其所有输入。\n2.  为了使调度能够被组织成无冲突的并行子步骤，顶点集 $V$ 必须被划分为不相交的子集 $C_1, \\dots, C_m$，其中每个子集 $C_k$ 都是图 $G$ 的一个**独立集**。\n将这两个条件结合起来，就意味着划分 $V = C_1 \\cup \\dots \\cup C_m$ 必须是图 $G$ 的一个**正常顶点着色**。\n\n### 第二部分：计算给定图的最少颜色数\n\n问题现在简化为计算给定图 $G$ 的**色数** $\\chi(G)$。\n$V = \\{1, \\dots, 10\\}$\n$E = \\{(1,2), (1,3), (1,4), (2,3), (2,4), (3,4), (1,5), (2,5), (2,6), (3,6), (3,7), (4,7), (4,8), (1,8), (1,9), (3,9), (2,10), (4,10)\\}$\n\n1.  **寻找下界**：首先，识别图中的最大团（clique）。边集 `{(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)}` 表明顶点 $\\{1, 2, 3, 4\\}$ 构成一个大小为 4 的团（$K_4$）。任何包含 $K_4$ 子图的图都需要至少 4 种颜色。因此，$\\chi(G) \\ge 4$。\n\n2.  **尝试 4-着色（上界）**：我们尝试用 4 种颜色（我们称之为 1, 2, 3, 4）为图着色。如果成功，我们将证明 $\\chi(G)=4$。\n    -   首先为 $K_4$ 团着色，这是强制的：\n        -   `color(1) = 1`\n        -   `color(2) = 2`\n        -   `color(3) = 3`\n        -   `color(4) = 4`\n    -   现在，我们为其余的顶点 $\\{5, 6, 7, 8, 9, 10\\}$ 着色，确保没有邻居共享同一种颜色。\n        -   **顶点 5**：邻居是 $\\{1, 2\\}$。它们的颜色是 $\\{1, 2\\}$。所以 `color(5)` 可以是 `3` 或 `4`。我们选择 `color(5) = 3`。\n        -   **顶点 6**：邻居是 $\\{2, 3\\}$。它们的颜色是 $\\{2, 3\\}$。所以 `color(6)` 可以是 `1` 或 `4`。我们选择 `color(6) = 1`。\n        -   **顶点 7**：邻居是 $\\{3, 4\\}$。它们的颜色是 $\\{3, 4\\}$。所以 `color(7)` 可以是 `1` 或 `2`。我们选择 `color(7) = 1`。\n        -   **顶点 8**：邻居是 $\\{1, 4\\}$。它们的颜色是 $\\{1, 4\\}$。所以 `color(8)` 可以是 `2` 或 `3`。我们选择 `color(8) = 2`。\n        -   **顶点 9**：邻居是 $\\{1, 3\\}$。它们的颜色是 $\\{1, 3\\}$。所以 `color(9)` 可以是 `2` 或 `4`。我们选择 `color(9) = 2`。\n        -   **顶点 10**：邻居是 $\\{2, 4\\}$。它们的颜色是 $\\{2, 4\\}$。所以 `color(10)` 可以是 `1` 或 `3`。我们选择 `color(10) = 1`。\n\n3.  **验证着色**：我们已经为所有顶点分配了颜色。现在需要检查新顶点之间是否存在冲突。根据边列表，没有边连接 $\\{5, 6, 7, 8, 9, 10\\}$ 中的任何两个顶点。但是，我们必须检查具有相同颜色的顶点之间是否有边。\n    -   颜色 1：$\\{1, 6, 7, 10\\}$。没有边连接这些顶点。\n    -   颜色 2：$\\{2, 8, 9\\}$。没有边连接这些顶点。\n    -   颜色 3：$\\{3, 5\\}$。没有边连接这些顶点。\n    -   颜色 4：$\\{4\\}$。\n    我们已经成功地用 4 种颜色为图 $G$ 进行了正常顶点着色。\n\n由于我们证明了 $\\chi(G) \\ge 4$ 并且找到了一个有效的 4-着色，我们可以得出结论，所需的最少颜色数是 4。\n\n最终答案是能够使并行独立集更新模拟同步更新的 $G$ 的正常着色所需的最少颜色数，即 $\\chi(G)$。这个值是 4。",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}