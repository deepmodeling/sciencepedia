{
    "hands_on_practices": [
        {
            "introduction": "在预测一个随机系统的长期行为之前，我们必须首先理解其内在结构。这项练习旨在训练如何将马尔可夫链的状态空间分解为其基本组成部分：瞬时状态和闭合通信类 。掌握这项技能使我们能够识别出系统中哪些状态是暂时的，哪些代表了可能的长期“陷阱”或稳定状态，这是分析复杂适应性系统动态的基础。",
            "id": "4144500",
            "problem": "考虑一个离散时间马尔可夫链 (MC)，它模拟了一个具有有限状态空间 $\\mathcal{S} = \\{1,2,3,4,5,6,7,8\\}$ 的复杂自适应系统中的机制转换。转移由一个有向图指定，其标记边表示一步转移概率。从每个状态出发的转移概率之和为 $1$。转移结构如下：\n- 从状态 $1$ 出发：以概率 $0.6$ 转移到 $1$；以概率 $0.4$ 转移到 $2$。\n- 从状态 $2$ 出发：以概率 $0.5$ 转移到 $1$；以概率 $0.5$ 转移到 $3$。\n- 从状态 $3$ 出发：以概率 $0.3$ 转移到 $1$；以概率 $0.7$ 转移到 $2$。\n- 从状态 $4$ 出发：以概率 $1$ 转移到 $5$。\n- 从状态 $5$ 出发：以概率 $1$ 转移到 $4$。\n- 从状态 $6$ 出发：以概率 $1$ 转移到 $6$。\n- 从状态 $7$ 出发：以概率 $0.5$ 转移到 $1$；以概率 $0.5$ 转移到 $4$。\n- 从状态 $8$ 出发：以概率 $0.2$ 转移到 $8$；以概率 $0.4$ 转移到 $7$；以概率 $0.4$ 转移到 $6$。\n\n基于适用于复杂自适应系统建模中随机过程和马尔可夫链的基本原理进行分析：\n\n- 使用以下定义：如果既有 $i \\to j$ 又有 $j \\to i$，则状态 $i$ 和 $j$ 互通，其中 $i \\to j$ 表示从 $i$ 到 $j$ 存在一条概率为正的路径。\n- 互通类是所有状态都互相连通的一个极大集合。如果不存在从类 $\\mathcal{C}$ 到 $\\mathcal{S} \\setminus \\mathcal{C}$ 的转移，则该类 $\\mathcal{C}$ 是封闭的。不包含在任何封闭互通类中的状态是暂态的。\n- 状态 $i$ 的周期定义为 $d(i) = \\gcd\\{n \\ge 1 : P^{n}(i,i) > 0\\}$（对于 $n$ 步返回概率为正的返回时间的最大公约数 (GCD)）。对于一个封闭互通类，所有状态共享相同的周期。如果一个类的周期等于 $1$，则该类是非周期的。\n\n任务：\n1. 将状态空间 $\\mathcal{S}$ 划分为暂态和封闭互通类。\n2. 对每个封闭互通类，判断其是否为非周期的。\n3. 令 $\\Theta$ 定义为所有非周期的封闭互通类的大小之和，再加上暂态的数量。计算 $\\Theta$ 的值。\n\n你的最终答案必须是单个实数 $\\Theta$。不需要四舍五入，也不涉及单位。",
            "solution": "该问题要求分析一个定义在状态空间 $\\mathcal{S} = \\{1, 2, 3, 4, 5, 6, 7, 8\\}$ 上的离散时间马尔可夫链。任务是：将此状态空间划分为暂态和封闭互通类，确定每个封闭类的周期性，并计算一个量 $\\Theta$。\n\n解题过程按问题陈述分为三个步骤。\n\n**1. 状态空间的划分**\n\n首先，我们识别马尔可夫链的互通类。如果从状态 $i$ 到 $j$ 存在一条概率为正的路径（$i \\to j$），并且从状态 $j$ 到 $i$ 也存在一条概率为正的路径（$j \\to i$），则称状态 $i$ 和 $j$ 互通，记作 $i \\leftrightarrow j$。互通类是所有状态都互相连通的一个极大集合。\n\n-   **状态 $1, 2, 3$**：\n    -   $1 \\to 2$ ($P(1,2)=0.4 > 0$) 且 $2 \\to 1$ ($P(2,1)=0.5 > 0$)。因此，$1 \\leftrightarrow 2$。\n    -   $2 \\to 3$ ($P(2,3)=0.5 > 0$) 且 $3 \\to 2$ ($P(3,2)=0.7 > 0$)。因此，$2 \\leftrightarrow 3$。\n    -   根据互通关系的传递性，$1 \\leftrightarrow 3$。我们验证这一点：$1 \\to 2 \\to 3$ 建立了 $1 \\to 3$，而 $3 \\to 1$ 是直接的（$P(3,1)=0.3 > 0$）。\n    -   因此，$\\{1, 2, 3\\}$ 是一个互通类。我们称之为 $\\mathcal{C}_1$。\n\n-   **状态 $4, 5$**：\n    -   $4 \\to 5$ ($P(4,5)=1 > 0$) 且 $5 \\to 4$ ($P(5,4)=1 > 0$)。\n    -   因此，$4 \\leftrightarrow 5$。\n    -   因此，$\\{4, 5\\}$ 是一个互通类，我们将其标记为 $\\mathcal{C}_2$。\n\n-   **状态 $6$**：\n    -   从状态 $6$ 的唯一转移是到其自身（$P(6,6)=1 > 0$）。它不能到达任何其他状态，也没有其他状态能到达它。\n    -   因此，$\\{6\\}$ 是一个互通类，标记为 $\\mathcal{C}_3$。\n\n-   **状态 $7$**：\n    -   状态 $7$ 可以转移到状态 $1$ 和状态 $4$。然而，没有从 $\\{1,2,3\\}$ 或 $\\{4,5\\}$ 返回到 $7$ 的路径。所以，$7$ 不与任何其他状态互通。\n    -   因此，$\\{7\\}$ 是一个单元素互通类。\n\n-   **状态 $8$**：\n    -   状态 $8$ 可以转移到状态 $6$、$7$ 及其自身。没有从状态 $6$ 或 $7$ 返回到 $8$ 的路径。\n    -   因此，$\\{8\\}$ 是一个单元素互通类。\n\n互通类是 $\\mathcal{C}_1=\\{1, 2, 3\\}$、$\\mathcal{C}_2=\\{4, 5\\}$、$\\mathcal{C}_3=\\{6\\}$、$\\{7\\}$ 和 $\\{8\\}$。\n\n接下来，我们确定哪些类是封闭的。如果不存在从类 $\\mathcal{C}$ 中的状态到 $\\mathcal{C}$ 之外任何状态的转移，则该类是封闭的。\n\n-   **类 $\\mathcal{C}_1 = \\{1, 2, 3\\}$**：从状态 $1$、$2$ 和 $3$ 的所有转移都指向 $\\{1, 2, 3\\}$ 内部的状态。这个类是封闭的。\n-   **类 $\\mathcal{C}_2 = \\{4, 5\\}$**：从 $4$ 的转移到 $5$，从 $5$ 的转移到 $4$。所有转移都保持在 $\\{4, 5\\}$ 内部。这个类是封闭的。\n-   **类 $\\mathcal{C}_3 = \\{6\\}$**：从状态 $6$ 的唯一转移是到其自身。这个类是封闭的。\n-   **类 $\\{7\\}$**：从 $7$ 的转移到 $1$ 和 $4$，这些状态在 $\\{7\\}$ 之外。这个类不是封闭的。\n-   **类 $\\{8\\}$**：从 $8$ 的转移到 $6$ 和 $7$，这些状态在 $\\{8\\}$ 之外。这个类不是封闭的。\n\n封闭互通类是 $\\mathcal{C}_1$、$\\mathcal{C}_2$ 和 $\\mathcal{C}_3$。包含在这些类中的状态 $\\{1, 2, 3, 4, 5, 6\\}$ 是常返的。\n\n根据所给定义，不包含在任何封闭互通类中的状态是暂态的。不在 $\\mathcal{C}_1 \\cup \\mathcal{C}_2 \\cup \\mathcal{C}_3 = \\{1, 2, 3, 4, 5, 6\\}$ 中的状态是 $7$ 和 $8$。\n因此，暂态集是 $T=\\{7, 8\\}$。\n\n**2. 封闭互通类的周期性**\n\n状态 $i$ 的周期 $d(i)$ 是从 $i$ 返回到 $i$ 的所有可能路径长度的最大公约数 (GCD)。一个互通类中的所有状态共享相同的周期。如果一个类的周期为 $1$，则该类是非周期的。\n\n-   **类 $\\mathcal{C}_1=\\{1, 2, 3\\}$**：\n    -   我们考察状态 $1$ 的周期。因为 $P(1,1)=0.6 > 0$，所以在 $n=1$ 步内返回状态 $1$ 是可能的。\n    -   可能的返回时间集合是 $\\{n \\ge 1 : P^{n}(1,1) > 0\\}$。由于 $1$ 在这个集合中，最大公约数必须是 $1$。\n    -   $d(1) = \\gcd(1, \\dots) = 1$。\n    -   因此，类 $\\mathcal{C}_1$ 是非周期的。\n\n-   **类 $\\mathcal{C}_2=\\{4, 5\\}$**：\n    -   让我们求状态 $4$ 的周期。\n    -   要返回状态 $4$，必须遵循路径 $4 \\to 5 \\to 4$。此路径的长度为 $n=2$。$P^2(4,4) = P(4,5)P(5,4) = 1 \\times 1 = 1 > 0$。\n    -   没有自环，所以不可能在 $n=1$ 步内返回。\n    -   从 $4$ 到 $4$ 的任何路径都必须由一系列 $4 \\to 5 \\to 4$ 循环组成。这些路径的长度是 $2, 4, 6, \\dots$。\n    -   返回时间的集合是 $\\{2, 4, 6, \\dots\\}$。\n    -   $d(4) = \\gcd(\\{2, 4, 6, \\dots\\}) = 2$。\n    -   因此，类 $\\mathcal{C}_2$ 是周期的，周期为 $2$。\n\n-   **类 $\\mathcal{C}_3=\\{6\\}$**：\n    -   对于状态 $6$，存在一个自环 $P(6,6)=1 > 0$。在 $n=1$ 步内返回是可能的。\n    -   $d(6) = \\gcd(1, \\dots) = 1$。\n    -   因此，类 $\\mathcal{C}_3$ 是非周期的。\n\n**3. $\\Theta$的计算**\n\n值 $\\Theta$ 定义为所有非周期的封闭互通类的大小之和，加上暂态的数量。\n\n-   非周期的封闭互通类是 $\\mathcal{C}_1=\\{1, 2, 3\\}$ 和 $\\mathcal{C}_3=\\{6\\}$。\n-   $\\mathcal{C}_1$ 的大小是 $|\\mathcal{C}_1| = 3$。\n-   $\\mathcal{C}_3$ 的大小是 $|\\mathcal{C}_3| = 1$。\n-   这些类的大小之和是 $3 + 1 = 4$。\n\n-   暂态集是 $T=\\{7, 8\\}$。\n-   暂态的数量是 $|T| = 2$。\n\n-   $\\Theta$ 的值是这两个量的和：\n    $$ \\Theta = (|\\mathcal{C}_1| + |\\mathcal{C}_3|) + |T| $$\n    $$ \\Theta = (3 + 1) + 2 $$\n    $$ \\Theta = 4 + 2 = 6 $$\n\n最终值为 $6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "许多复杂系统都存在“锁定”事件或吸收状态，系统一旦进入就无法离开。本练习将介绍一种强大的技术——一步分析法，用于计算系统在进入一个吸收状态而非另一个吸收状态之前的概率 。这对于分析市场主导地位的形成、物种灭绝或共识达成等现象至关重要。",
            "id": "4144532",
            "problem": "在一个复杂自适应系统的协调粗粒度模型中，大量的智能体通过局部交互和偶然的锁定事件来自适应地更新其行为。该群体宏观状态被建模为一个在有限状态空间 $\\{0,1,2,3,4,5\\}$ 上的时间齐次马尔可夫链。状态 $4$ 和 $5$ 分别表示锁定到行为 $\\mathcal{A}$ 和锁定到行为 $\\mathcal{B}$。一步更新的转移动态如下：\n- 从状态 $0$ 出发：以概率 $\\frac{1}{3}$ 转移到状态 $1$，以概率 $\\frac{1}{3}$ 转移到状态 $2$，以概率 $\\frac{1}{3}$ 转移到状态 $5$。\n- 从状态 $1$ 出发：以概率 $\\frac{1}{4}$ 转移到状态 $0$，以概率 $\\frac{1}{4}$ 转移到状态 $2$，以概率 $\\frac{1}{4}$ 转移到状态 $3$，以概率 $\\frac{1}{4}$ 转移到状态 $4$。\n- 从状态 $2$ 出发：以概率 $\\frac{1}{2}$ 转移到状态 $1$，以概率 $\\frac{1}{4}$ 转移到状态 $3$，以概率 $\\frac{1}{4}$ 转移到状态 $5$。\n- 从状态 $3$ 出发：以概率 $\\frac{1}{3}$ 转移到状态 $2$，以概率 $\\frac{1}{3}$ 转移到状态 $4$，以概率 $\\frac{1}{3}$ 转移到状态 $5$。\n- 状态 $4$ 是吸收态，即以概率 $1$ 转移到状态 $4$。\n- 状态 $5$ 是吸收态，即以概率 $1$ 转移到状态 $5$。\n\n令 $\\mathcal{A}=\\{4\\}$ 且 $\\mathcal{B}=\\{5\\}$。定义首达时间 $T_{\\mathcal{A}}=\\inf\\{t\\ge 0: X_t\\in \\mathcal{A}\\}$ 和 $T_{\\mathcal{B}}=\\inf\\{t\\ge 0: X_t\\in \\mathcal{B}\\}$，其中 $\\{X_t\\}_{t\\ge 0}$ 是该马尔可夫链。使用时间齐次马尔可夫链的基本定义和基于全期望定律的首步分析法，推导出刻画函数 $h(i)=\\mathbb{P}_i(T_{\\mathcal{A}}  T_{\\mathcal{B}})$ 的线性方程组，并计算从状态 $0$ 开始，系统在锁定到行为 $\\mathcal{B}$ 之前锁定到行为 $\\mathcal{A}$ 的概率，即 $h(0)$。",
            "solution": "问题要求计算一个时间齐次马尔可夫链在进入吸收态 $5$ 之前进入吸收态 $4$ 的概率，前提是它从状态 $0$ 开始。令状态空间为 $S = \\{0, 1, 2, 3, 4, 5\\}$。目标集合为 $\\mathcal{A}=\\{4\\}$ 和 $\\mathcal{B}=\\{5\\}$。待求的量是 $h(i) = \\mathbb{P}_i(T_{\\mathcal{A}}  T_{\\mathcal{B}})$，其中 $T_{\\mathcal{A}} = \\inf\\{t \\ge 0 : X_t \\in \\mathcal{A}\\}$ 和 $T_{\\mathcal{B}} = \\inf\\{t \\ge 0 : X_t \\in \\mathcal{B}\\}$ 分别是到达集合 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的首达时间，且 $\\mathbb{P}_i(\\cdot) = \\mathbb{P}(\\cdot | X_0 = i)$。\n\n状态 $4$ 和 $5$ 是吸收态，而状态 $S_T = \\{0, 1, 2, 3\\}$ 是暂留态。函数 $h(i)$ 表示从状态 $i$ 出发，在被集合 $\\mathcal{B}$ 吸收之前被集合 $\\mathcal{A}$ 吸收的概率。\n\n首先，我们为吸收态建立边界条件。\n如果过程从状态 $i=4$ 开始，那么在时间 $t=0$ 时它已经处于集合 $\\mathcal{A}$ 中。因此，$T_{\\mathcal{A}} = 0$。由于状态 $4 \\notin \\mathcal{B}$，过程在 $t=0$ 时不在 $\\mathcal{B}$ 中，所以 $T_{\\mathcal{B}} > 0$。因此，条件 $T_{\\mathcal{A}}  T_{\\mathcal{B}}$ 必然满足。其概率为 $1$。\n$$h(4) = \\mathbb{P}_4(T_{\\mathcal{A}}  T_{\\mathcal{B}}) = 1$$\n如果过程从状态 $i=5$ 开始，那么在时间 $t=0$ 时它已经处于集合 $\\mathcal{B}$ 中。因此，$T_{\\mathcal{B}} = 0$。由于状态 $5 \\notin \\mathcal{A}$，$T_{\\mathcal{A}} > 0$。条件 $T_{\\mathcal{A}}  T_{\\mathcal{B}}$ 不满足。其概率为 $0$。\n$$h(5) = \\mathbb{P}_5(T_{\\mathcal{A}}  T_{\\mathcal{B}}) = 0$$\n\n对于暂留态 $i \\in S_T = \\{0, 1, 2, 3\\}$，我们使用首步分析法。通过应用全期望定律并以时间 $t=1$ 时的状态为条件，我们得到：\n$$h(i) = \\mathbb{E}_i[\\mathbb{I}(T_{\\mathcal{A}}  T_{\\mathcal{B}})] = \\sum_{j \\in S} \\mathbb{P}(X_1=j | X_0=i) \\mathbb{P}(T_{\\mathcal{A}}  T_{\\mathcal{B}} | X_1=j)$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。根据时间齐次马尔可夫性质，$\\mathbb{P}(T_{\\mathcal{A}}  T_{\\mathcal{B}} | X_1=j) = \\mathbb{P}_j(T_{\\mathcal{A}}  T_{\\mathcal{B}}) = h(j)$。\n因此，方程组由 $h(i) = \\sum_{j \\in S} p_{ij} h(j)$ 给出，其中 $i \\in \\{0, 1, 2, 3\\}$，$p_{ij}$ 是给定的转移概率。\n\n让我们明确地写出这个方程组：\n对于 $i=0$：\n$h(0) = p_{01}h(1) + p_{02}h(2) + p_{05}h(5) = \\frac{1}{3}h(1) + \\frac{1}{3}h(2) + \\frac{1}{3}(0)$\n$$3h(0) = h(1) + h(2) \\quad (1)$$\n对于 $i=1$：\n$h(1) = p_{10}h(0) + p_{12}h(2) + p_{13}h(3) + p_{14}h(4) = \\frac{1}{4}h(0) + \\frac{1}{4}h(2) + \\frac{1}{4}h(3) + \\frac{1}{4}(1)$\n$$4h(1) = h(0) + h(2) + h(3) + 1 \\quad (2)$$\n对于 $i=2$：\n$h(2) = p_{21}h(1) + p_{23}h(3) + p_{25}h(5) = \\frac{1}{2}h(1) + \\frac{1}{4}h(3) + \\frac{1}{4}(0)$\n$$4h(2) = 2h(1) + h(3) \\quad (3)$$\n对于 $i=3$：\n$h(3) = p_{32}h(2) + p_{34}h(4) + p_{35}h(5) = \\frac{1}{3}h(2) + \\frac{1}{3}(1) + \\frac{1}{3}(0)$\n$$3h(3) = h(2) + 1 \\quad (4)$$\n\n这是一个关于4个未知数 $h(0)$, $h(1)$, $h(2)$ 和 $h(3)$ 的4元线性方程组。在有限状态吸收马尔可夫链中，这样一个关于吸收概率的方程组有唯一解。这是因为从任何暂留态出发，到达某个吸收态的概率非零，这确保了矩阵 $(I-Q)$ (其中 $Q$ 是暂留态之间的转移概率子矩阵) 是可逆的。\n\n我们现在来解这个方程组。我们使用代入法，将 $h(1)$, $h(2)$ 和 $h(3)$ 用一个变量表示，并最终求出 $h(0)$。\n从方程 $(4)$，我们将 $h(3)$ 用 $h(2)$ 表示：\n$$h(3) = \\frac{1}{3}h(2) + \\frac{1}{3}$$\n将这个 $h(3)$ 的表达式代入方程 $(3)$：\n$4h(2) = 2h(1) + \\left(\\frac{1}{3}h(2) + \\frac{1}{3}\\right)$\n$4h(2) - \\frac{1}{3}h(2) = 2h(1) + \\frac{1}{3}$\n$\\frac{11}{3}h(2) = 2h(1) + \\frac{1}{3}$\n两边乘以 $3$ 得到 $11h(2) = 6h(1) + 1$，由此我们将 $h(1)$ 用 $h(2)$ 表示：\n$$h(1) = \\frac{11h(2) - 1}{6}$$\n现在，将 $h(1)$ 和 $h(3)$ 的表达式代入方程 $(2)$：\n$4\\left(\\frac{11h(2) - 1}{6}\\right) = h(0) + h(2) + \\left(\\frac{1}{3}h(2) + \\frac{1}{3}\\right) + 1$\n$\\frac{2(11h(2) - 1)}{3} = h(0) + \\frac{4}{3}h(2) + \\frac{4}{3}$\n两边乘以 $3$：\n$22h(2) - 2 = 3h(0) + 4h(2) + 4$\n$18h(2) - 6 = 3h(0)$\n$$h(0) = 6h(2) - 2$$\n最后，我们将 $h(0)$ 和 $h(1)$ 的表达式代入方程 $(1)$：\n$3(6h(2) - 2) = \\left(\\frac{11h(2) - 1}{6}\\right) + h(2)$\n$18h(2) - 6 = \\frac{11h(2) - 1 + 6h(2)}{6}$\n$6(18h(2) - 6) = 17h(2) - 1$\n$108h(2) - 36 = 17h(2) - 1$\n$108h(2) - 17h(2) = 36 - 1$\n$91h(2) = 35$\n$$h(2) = \\frac{35}{91} = \\frac{5 \\times 7}{13 \\times 7} = \\frac{5}{13}$$\n现在我们得到了 $h(2)$ 的值，就可以求出所需的 $h(0)$ 的值：\n$h(0) = 6h(2) - 2 = 6\\left(\\frac{5}{13}\\right) - 2 = \\frac{30}{13} - \\frac{26}{13}$\n$$h(0) = \\frac{4}{13}$$\n从状态 $0$ 开始，在进入状态 $5$ 之前被状态 $4$ 吸收的概率是 $\\frac{4}{13}$。",
            "answer": "$$\\boxed{\\frac{4}{13}}$$"
        },
        {
            "introduction": "对于那些不会永久“陷入”某个状态的系统，我们通常关心其长期的均衡行为。这项计算练习旨在寻找平稳分布，它描述了系统在长期内停留在每个状态的时间比例 。你还将通过编程验证系统向这一均衡收敛的过程，并观察不同类型的系统结构（如非周期性与周期性）如何影响收敛性。",
            "id": "4144541",
            "problem": "考虑一个离散时间有限状态马尔可夫链 (MC)，其状态空间大小为 $m$，转移矩阵为一个行随机矩阵 $P \\in \\mathbb{R}^{m \\times m}$，其中每一行的非负项之和为 $1$。状态上的概率分布表示为一个行向量 $\\mu \\in \\mathbb{R}^{1 \\times m}$，其非负项之和为 $1$。分布的单步演化由马尔可夫动力学的基本定律给出：下一步的分布等于当前分布通过转移机制传播得到的结果。在复杂自适应系统建模中，这种随机过程在重复交互下的渐近行为捕捉了长期的聚合行为，而在动力学的单步作用下保持不变同时保持总概率质量的不变概率分布起着核心作用。\n\n你的任务是编写一个程序，为每个提供的测试用例：\n- 计算一个在单步转移动态下不变且经过适当归一化的概率向量。\n- 将给定的初始分布向前传播指定的步数，并评估传播后的分布是否在全变分范数（等于 $\\ell_{1}$ 范数的一半）下，在规定的容差范围内足够接近不变向量。因为全变分范数是 $\\ell_{1}$ 范数的一半，所以对于给定的容差，直接检查 $\\ell_{1}$ 距离就足够了。\n\n使用以下基础理论：\n- 分布通过重复应用转移机制进行演化。\n- 不变分布在一步动态下保持不变，并且必须是一个经过适当归一化的概率向量。\n- 对于有限状态空间上的不可约且非周期的转移机制，存在唯一的不变分布，并且随着步数的增加，演化后的分布会收敛到该不变分布；对于周期性机制，演化分布不一定会收敛。\n\n对于下方的每个测试用例，你的程序必须：\n1. 计算一个与转移机制和归一化条件一致的不变概率向量。\n2. 从给定的初始分布开始，计算指定步数后的演化分布。\n3. 计算演化分布与不变分布之间的 $\\ell_{1}$ 距离。\n4. 返回一个布尔值，指示演化分布与不变分布的 $\\ell_{1}$ 距离是否在指定的容差范围内。\n\n将所有数值输出表示为浮点数，并四舍五入到六位小数。每个测试用例的最终输出必须是一个列表，其第一个元素是不变分布（一个浮点数列表，四舍五入到六位小数），第二个元素是一个布尔值，指示是否在容差范围内观察到收敛。\n\n测试套件：\n- 测试用例 $1$ (不可约且非周期, $m=4$):\n  - 转移矩阵 $P_1$:\n    $$\n    P_1=\\begin{bmatrix}\n    0.3  0.2  0.4  0.1 \\\\\n    0.1  0.5  0.2  0.2 \\\\\n    0.25  0.25  0.25  0.25 \\\\\n    0.4  0.2  0.1  0.3\n    \\end{bmatrix}\n    $$\n  - 初始分布 $\\mu_1 = [0.05,\\,0.45,\\,0.25,\\,0.25]$。\n  - 步数 $n_1 = 50$。\n  - 容差 $\\varepsilon_1 = 10^{-6}$。\n- 测试用例 $2$ (不可约但周期性, $m=2$):\n  - 转移矩阵 $P_2$:\n    $$\n    P_2=\\begin{bmatrix}\n    0  1 \\\\\n    1  0\n    \\end{bmatrix}\n    $$\n  - 初始分布 $\\mu_2 = [1,\\,0]$。\n  - 步数 $n_2 = 50$。\n  - 容差 $\\varepsilon_2 = 10^{-6}$。\n- 测试用例 $3$ (慢混合但非周期, $m=2$):\n  - 转移矩阵 $P_3$:\n    $$\n    P_3=\\begin{bmatrix}\n    0.001  0.999 \\\\\n    0.999  0.001\n    \\end{bmatrix}\n    $$\n  - 初始分布 $\\mu_3 = [1,\\,0]$。\n  - 步数 $n_3 = 3000$。\n  - 容差 $\\varepsilon_3 = 10^{-2}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素按顺序对应一个测试用例，并且其本身必须是上述形式的列表。例如，输出应如下所示\n$$\n[\\,[\\text{invariant\\_1},\\text{boolean\\_1}],\\,[\\text{invariant\\_2},\\text{boolean\\_2}],\\,[\\text{invariant\\_3},\\text{boolean\\_3}]\\,]\n$$\n打印行中没有空格。",
            "solution": "该问题要求分析几个离散时间有限状态马尔可夫链。对于每个给定的测试用例，我们必须计算不变概率分布，模拟给定初始分布在指定步数内的演化，并评估其向不变分布的收敛情况。解决方案源于马尔可夫链理论的基本原理。\n\n### 第 1 步：计算不变分布 ($\\pi$)\n\n不变概率分布，通常用行向量 `$\\pi \\in \\mathbb{R}^{1 \\times m}$` 表示，是在马尔可夫动力学单步演化后保持不变的分布。在数学上，它满足方程：\n$$\n\\pi P = \\pi\n$$\n其中 `$P \\in \\mathbb{R}^{m \\times m}$` 是行随机转移矩阵。此外，`$\\pi$` 必须是有效的概率分布，意味着其分量 `$\\pi_i$` 是非负的，且总和为 `$1$`：\n$$\n\\sum_{i=1}^{m} \\pi_i = 1 \\quad \\text{and} \\quad \\pi_i \\ge 0 \\text{ for all } i \\in \\{1, \\dots, m\\}\n$$\n方程 `$\\pi P = \\pi$` 可以重写为 `$\\pi (P - I) = 0$`，其中 `$I$` 是 `$m \\times m$` 的单位矩阵。这表明 `$\\pi$` 是矩阵 `$P$` 对应于特征值 `$\\lambda = 1$` 的左特征向量。\n\n根据线性代数，矩阵 `$P$` 的左特征向量是其转置矩阵 `$P^T$` 的右特征向量的转置。设 `$v = \\pi^T$` 是对应于 `$\\pi$` 的列向量。对特征向量方程取转置可得：\n$$\n(\\pi P)^T = \\pi^T \\implies P^T \\pi^T = \\pi^T \\implies P^T v = v\n$$\n这表明 `$v = \\pi^T$` 是 `$P^T$` 关联于特征值 `$\\lambda = 1$` 的右特征向量。对于任何不可约的有限状态马尔可夫链，Perron-Frobenius 定理保证特征值 `$1$` 是单根的，并且存在一个唯一的（在缩放意义上）对应的特征向量，其所有分量均为正。\n\n计算过程如下：\n1.  计算转移矩阵的转置 `$P^T$`。\n2.  找到 `$P^T$` 的特征值和右特征向量。\n3.  识别对应于特征值 `$\\lambda = 1$` 的特征向量 `$v$`。\n4.  归一化该特征向量，确保其分量之和为 `$1$`。得到的向量是 `$\\pi^T$`。具体来说，如果 `$v = [v_1, v_2, \\dots, v_m]^T$`，则 `$\\pi$` 的分量由 `$\\pi_i = v_i / \\sum_{j=1}^{m} v_j$` 给出。\n5.  得到的行向量 `$\\pi$` 就是所求的不变分布。\n\n### 第 2 步：状态分布的演化\n\n在时间步 `$t$` 的概率分布 `$\\mu_t$` 通过与转移矩阵相乘演化为下一步的分布 `$\\mu_{t+1}$`：\n$$\n\\mu_{t+1} = \\mu_t P\n$$\n从初始分布 `$\\mu_0$` 开始，通过重复应用此规则可以找到 `$n$` 步后的分布 `$\\mu_n$`：\n$$\n\\mu_n = \\mu_0 P^n\n$$\n其中 `$P^n$` 是矩阵 `$P$` 的 `$n$` 次幂。这可以使用诸如平方求幂之类的数值方法高效计算，该方法在标准科学计算库中均有实现。\n\n### 第 3 步：收敛性评估\n\n问题要求我们确定演化后的分布 `$\\mu_n$` 是否“足够接近”不变分布 `$\\pi$`。这通过两个向量之间的 `$\\ell_1$` 距离来量化：\n$$\n\\|\\mu_n - \\pi\\|_1 = \\sum_{i=1}^{m} |\\mu_{n,i} - \\pi_i|\n$$\n问题为每个测试用例指定了一个容差 `$\\varepsilon$`。如果此距离在容差范围内，则认为演化分布已收敛：\n$$\n\\|\\mu_n - \\pi\\|_1 \\le \\varepsilon\n$$\n此比较得出一个布尔值（`True` 或 `False`）。\n\n对于有限状态空间上的不可约且非周期的马尔可夫链，无论初始分布 `$\\mu_0$`如何，分布 `$\\mu_n$` 都保证在 `$n \\to \\infty$` 时收敛到唯一的不变分布 `$\\pi$`。然而，如果链是周期性的（如测试用例 `$2$` 中所示），`$\\mu_n$` 不保证收敛到 `$\\pi$`；分布可能会在一组分布之间循环。\n\n### 算法摘要\n对于由 `$(P, \\mu_0, n, \\varepsilon)$` 定义的每个测试用例：\n1.  通过找到 `$P$` 的对应于特征值 `$\\lambda=1$` 的归一化左特征向量来计算不变分布 `$\\pi$`。这是通过找到 `$P^T$` 对应于 `$\\lambda=1$` 的右特征向量来完成的。\n2.  使用矩阵幂运算计算演化分布 `$\\mu_n = \\mu_0 P^n$`。\n3.  计算 `$\\ell_1$` 距离 `$\\|\\mu_n - \\pi\\|_1$`。\n4.  将此距离与容差 `$\\varepsilon$` 进行比较，以获得一个布尔结果。\n5.  将 `$\\pi$` 的分量四舍五入到六位小数进行格式化。\n6.  将测试用例的最终输出组装成一个列表，其中包含四舍五入后的不变分布和布尔收敛结果。\n\n此过程被系统地应用于所有提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Markov chain problems as described.\n    \"\"\"\n\n    def solve_case(P, mu0, n, tol):\n        \"\"\"\n        Solves a single test case for a Markov chain.\n\n        Args:\n            P (np.ndarray): The m x m transition matrix.\n            mu0 (np.ndarray): The 1 x m initial distribution row vector.\n            n (int): The number of steps to evolve the distribution.\n            tol (float): The tolerance for the L1 distance convergence check.\n\n        Returns:\n            list: A list containing [invariant_distribution, is_converged].\n                  The invariant_distribution is a list of floats rounded to 6 decimal places.\n                  is_converged is a boolean.\n        \"\"\"\n        m = P.shape[0]\n\n        # 1. Compute the invariant distribution pi\n        # This corresponds to the left eigenvector of P for eigenvalue 1.\n        # We find the right eigenvector of P.T for eigenvalue 1.\n        P_T = P.T\n        eigenvalues, eigenvectors = np.linalg.eig(P_T)\n\n        # Find the index of the eigenvalue that is close to 1\n        one_idx = np.isclose(eigenvalues, 1)\n\n        # Extract the corresponding eigenvector (it's a column in eigenvectors)\n        stationary_vec_T = eigenvectors[:, one_idx]\n\n        # Eigenvector can be complex, take the real part. For a stochastic matrix,\n        # the eigenvector for eigenvalue 1 can be chosen to be real-valued.\n        stationary_vec_T = np.real(stationary_vec_T)\n\n        # Normalize the eigenvector so that its components sum to 1\n        pi_T = stationary_vec_T / np.sum(stationary_vec_T)\n\n        # pi is a row vector, so we transpose and flatten to a 1D array\n        pi = pi_T.T.flatten()\n\n        # 2. Compute the evolved distribution mu_n = mu_0 * P^n\n        P_n = np.linalg.matrix_power(P, n)\n        mu_n = mu0 @ P_n\n\n        # 3. Compute the L1 distance between mu_n and pi\n        l1_dist = np.sum(np.abs(mu_n - pi))\n\n        # 4. Return boolean indicating if the distance is within tolerance\n        is_converged = l1_dist = tol\n\n        # Format the invariant distribution as a list of floats rounded to six decimal places\n        pi_rounded = [round(x, 6) for x in pi]\n\n        return [pi_rounded, is_converged]\n\n    # Test case 1: Irreducible and aperiodic\n    P1 = np.array([\n        [0.3, 0.2, 0.4, 0.1],\n        [0.1, 0.5, 0.2, 0.2],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.4, 0.2, 0.1, 0.3]\n    ])\n    mu1 = np.array([0.05, 0.45, 0.25, 0.25])\n    n1 = 50\n    tol1 = 1e-6\n\n    # Test case 2: Irreducible but periodic\n    P2 = np.array([\n        [0.0, 1.0],\n        [1.0, 0.0]\n    ])\n    mu2 = np.array([1.0, 0.0])\n    n2 = 50\n    tol2 = 1e-6\n\n    # Test case 3: Slow mixing but aperiodic\n    P3 = np.array([\n        [0.001, 0.999],\n        [0.999, 0.001]\n    ])\n    mu3 = np.array([1.0, 0.0])\n    n3 = 3000\n    tol3 = 1e-2\n    \n    test_cases = [\n        (P1, mu1, n1, tol1),\n        (P2, mu2, n2, tol2),\n        (P3, mu3, n3, tol3),\n    ]\n\n    results = []\n    for P, mu0, n, tol in test_cases:\n        result = solve_case(P, mu0, n, tol)\n        results.append(result)\n\n    # Final print statement must be a single line with no spaces\n    # Example: [[list1,bool1],[list2,bool2]]\n    final_output_str = str(results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}