{
    "hands_on_practices": [
        {
            "introduction": "Understanding the fundamental geometric differences between Moore and von Neumann neighborhoods is the first step in mastering two-dimensional cellular automata. This exercise guides you through a first-principles derivation to quantify how these two common neighborhood types scale with increasing radius $r$. By calculating the exact number of neighbors and analyzing the ratio, you will gain a concrete appreciation for the difference in local connectivity and information density, which has profound implications for pattern formation and computational complexity in CA models .",
            "id": "4150733",
            "problem": "Consider a two-dimensional cellular automaton (CA) on the infinite integer lattice $\\mathbb{Z}^{2}$. For a fixed central cell at the origin, define two radius-$r$ neighborhoods for an integer $r \\geq 1$ based on standard norms:\n- The Moore neighborhood of radius $r$ consists of all lattice sites $\\{(i,j) \\in \\mathbb{Z}^{2} : \\max(|i|,|j|) \\leq r\\}$.\n- The von Neumann neighborhood of radius $r$ consists of all lattice sites $\\{(i,j) \\in \\mathbb{Z}^{2} : |i| + |j| \\leq r\\}$.\n\nIn cellular automaton modeling, a cell’s neighborhood is traditionally taken to exclude the cell itself. Using only the core definitions above and first-principles counting arguments on $\\mathbb{Z}^{2}$ (without invoking any pre-derived formulas), derive the exact number of neighbors in each neighborhood as a function of $r$, form the ratio of the Moore neighbor count to the von Neumann neighbor count, and analyze its asymptotic behavior as $r \\to \\infty$. Report the final result as a single exact real number that captures both the ratio and its asymptotic limit. No rounding is required.",
            "solution": "The problem is first validated against the specified criteria.\n\n### Step 1: Extract Givens\n- Domain: A two-dimensional cellular automaton on the infinite integer lattice $\\mathbb{Z}^{2}$.\n- Central cell: Positioned at the origin $(0,0)$.\n- Radius parameter: $r$ is an integer such that $r \\geq 1$.\n- Moore neighborhood of radius $r$ (including the central cell): The set of all lattice sites $\\{(i,j) \\in \\mathbb{Z}^{2} : \\max(|i|,|j|) \\leq r\\}$.\n- von Neumann neighborhood of radius $r$ (including the central cell): The set of all lattice sites $\\{(i,j) \\in \\mathbb{Z}^{2} : |i| + |j| \\leq r\\}$.\n- Definition of neighbors: The neighborhood of a cell excludes the cell itself.\n- Task: Derive the number of neighbors for each neighborhood type as a function of $r$, find the ratio of the Moore count to the von Neumann count, and determine the asymptotic limit of this ratio as $r \\to \\infty$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem uses standard, well-established definitions of Moore and von Neumann neighborhoods in the context of cellular automata theory. These definitions correspond to balls of radius $r$ under the Chebyshev ($L_\\infty$) and Manhattan ($L_1$) norms, respectively. The concepts are fundamental to discrete mathematics and complex systems modeling. The problem is scientifically sound.\n- **Well-Posed:** The problem provides clear, unambiguous definitions and a precise set of tasks. The constraints are self-consistent, and a unique, meaningful solution is derivable from the provided information.\n- **Objective:** The problem is stated in formal mathematical language, free of any subjectivity or opinion.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is scientifically grounded, well-posed, and objective. The solution process may proceed.\n\n### Derivation of the Number of Neighbors\n\nLet $N_M(r)$ be the number of neighbors in the Moore neighborhood of radius $r$, and let $N_V(r)$ be the number of neighbors in the von Neumann neighborhood of radius $r$. The problem specifies that the neighborhood excludes the central cell.\n\n**1. Moore Neighborhood Count**\n\nThe Moore neighborhood *including* the central cell is the set of points $(i,j) \\in \\mathbb{Z}^{2}$ such that $\\max(|i|, |j|) \\leq r$. This condition is equivalent to requiring both $|i| \\leq r$ and $|j| \\leq r$.\nThis means the coordinate $i$ can take any integer value from $-r$ to $r$, and similarly for the coordinate $j$.\nThe number of possible integer values for $i$ is $r - (-r) + 1 = 2r+1$.\nThe number of possible integer values for $j$ is also $2r+1$.\nThe total number of cells in the Moore neighborhood including the center is the total number of combinations of these coordinates, which forms a square grid on the lattice.\nTotal cells (including center) = $(2r+1)(2r+1) = (2r+1)^{2}$.\n\nTo find the number of neighbors, $N_M(r)$, we subtract the central cell $(0,0)$.\n$$N_M(r) = (2r+1)^{2} - 1$$\n$$N_M(r) = (4r^{2} + 4r + 1) - 1$$\n$$N_M(r) = 4r^{2} + 4r$$\n\n**2. von Neumann Neighborhood Count**\n\nThe von Neumann neighborhood *including* the central cell is the set of points $(i,j) \\in \\mathbb{Z}^{2}$ such that $|i| + |j| \\leq r$. To count these points from first principles, we can sum the number of points on concentric \"diamond-shaped\" shells defined by $|i| + |j| = k$ for integer values of $k$ from $0$ to $r$.\n\nFor $k=0$, the only solution to $|i| + |j| = 0$ is $(i,j)=(0,0)$. This gives $1$ cell (the center).\n\nFor any $k > 0$, we count the number of integer points satisfying $|i| + |j| = k$.\nLet's consider the first quadrant where $i > 0$ and $j > 0$. The equation is $i+j=k$. The solutions are $(1, k-1), (2, k-2), \\dots, (k-1, 1)$. There are $k-1$ such points.\nBy symmetry, there are $k-1$ points in each of the four open quadrants. This gives $4(k-1)$ points.\nAdditionally, there are points on the axes. These are $(\\pm k, 0)$ and $(0, \\pm k)$. There are $4$ such points.\nThe total number of points on the shell for a given $k>0$ is $4(k-1) + 4 = 4k - 4 + 4 = 4k$.\n\nThe total number of cells in the von Neumann neighborhood including the center is the sum of the counts for each shell from $k=0$ to $k=r$.\nTotal cells (including center) = (count for $k=0$) + $\\sum_{k=1}^{r}$ (count for shell $k$)\n$$ \\text{Total cells} = 1 + \\sum_{k=1}^{r} 4k $$\nUsing the formula for the sum of the first $r$ integers, $\\sum_{k=1}^{r} k = \\frac{r(r+1)}{2}$:\n$$ \\text{Total cells} = 1 + 4 \\left( \\frac{r(r+1)}{2} \\right) = 1 + 2r(r+1) = 1 + 2r^{2} + 2r $$\nTo find the number of neighbors, $N_V(r)$, we subtract the central cell.\n$$ N_V(r) = (1 + 2r^{2} + 2r) - 1 $$\n$$ N_V(r) = 2r^{2} + 2r $$\n\n**3. Ratio and Asymptotic Analysis**\n\nNow, we form the ratio $R(r)$ of the Moore neighbor count to the von Neumann neighbor count, for $r \\geq 1$.\n$$ R(r) = \\frac{N_M(r)}{N_V(r)} = \\frac{4r^{2} + 4r}{2r^{2} + 2r} $$\nFor $r \\geq 1$, the denominator $2r^{2} + 2r = 2r(r+1)$ is non-zero. We can factor both the numerator and the denominator:\n$$ R(r) = \\frac{4r(r+1)}{2r(r+1)} $$\nSince $r \\geq 1$, both $r$ and $r+1$ are non-zero, allowing cancellation:\n$$ R(r) = \\frac{4}{2} = 2 $$\nThe ratio is exactly $2$ for all integers $r \\geq 1$.\n\nFinally, we analyze the asymptotic behavior of this ratio as $r \\to \\infty$. Since the ratio is a constant function $R(r)=2$ for all $r \\geq 1$, its limit is simply the constant value.\n$$ \\lim_{r \\to \\infty} R(r) = \\lim_{r \\to \\infty} 2 = 2 $$\nThis result can also be obtained by analyzing the leading terms of the polynomials:\n$$ \\lim_{r \\to \\infty} \\frac{4r^{2} + 4r}{2r^{2} + 2r} = \\lim_{r \\to \\infty} \\frac{r^{2}(4 + \\frac{4}{r})}{r^{2}(2 + \\frac{2}{r})} = \\frac{4+0}{2+0} = 2 $$\nThe problem asks for a single exact real number that captures both the ratio and its asymptotic limit. Since the ratio is constant for all $r \\geq 1$ and is equal to its limit, that number is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While theoretical models often assume an infinite lattice, practical simulations must operate on finite grids, introducing the critical concept of boundary conditions. This practice explores how reflective boundaries alter the local neighborhood structure, a non-trivial effect that must be handled correctly in any simulation. By analyzing how neighborhood offsets are mapped at the corners and edges of the grid, you will uncover the notion of neighbor multiplicity and learn how to derive effective weights for a local rule, ensuring your CA implementation is accurate even at its boundaries .",
            "id": "4150687",
            "problem": "A two-dimensional Cellular Automaton (CA) is defined on a finite rectangular lattice of size $N \\times M$ with site indices $(i,j)$ where $i \\in \\{0,1,\\dots,N-1\\}$ and $j \\in \\{0,1,\\dots,M-1\\}$. The local interaction is given by the Moore neighborhood of radius $r=1$, which collects the $8$ offsets $(\\Delta i,\\Delta j) \\in \\{-1,0,1\\} \\times \\{-1,0,1\\} \\setminus \\{(0,0)\\}$. The boundary condition is reflective (mirror): given a tentative neighbor coordinate $(i+\\Delta i,j+\\Delta j)$, the boundary mapping $\\rho$ acts independently on each coordinate by reflecting it into the valid range, that is,\n$$\n\\rho_N(k) = \n\\begin{cases}\n0, & k < 0,\\\\\nk, & 0 \\leq k \\leq N-1,\\\\\nN-1, & k \\geq N,\n\\end{cases}\n\\qquad\n\\rho_M(\\ell) = \n\\begin{cases}\n0, & \\ell < 0,\\\\\n\\ell, & 0 \\leq \\ell \\leq M-1,\\\\\nM-1, & \\ell \\geq M,\n\\end{cases}\n$$\nand the mapped neighbor index is $\\big(\\rho_N(i+\\Delta i),\\rho_M(j+\\Delta j)\\big)$. Under this mapping, multiple distinct offsets $(\\Delta i,\\Delta j)$ may map to the same lattice index, which induces multiplicities in the neighborhood when evaluating any local rule.\n\nStarting from the above definitions, compute the number of distinct neighbor indices (i.e., the cardinality of the set of mapped neighbor indices) at a corner site, at a non-corner edge site, and at an interior site, for the $r=1$ Moore neighborhood with reflective boundaries. Report your final result in the ordered form $(\\text{corner},\\ \\text{edge},\\ \\text{interior})$.\n\nAdditionally, describe how the application of a general local rule that aggregates neighbor states via a kernel $w_{\\Delta i,\\Delta j}$ should be modified to correctly account for the reflective boundary mapping, by expressing an effective weight $\\widehat{w}_{p,q}$ on each distinct mapped neighbor index $(p,q)$ in terms of the original kernel $w_{\\Delta i, \\Delta j}$. Then specialize your description to the uniform Moore kernel in which $w_{\\Delta i,\\Delta j}=1$ for all $8$ offsets, and specify the multiplicity pattern for the $r=1$ case at a corner and at a non-corner edge.\n\nNo rounding is required. The final reported counts must be given as a single row matrix as specified in the answer rules.",
            "solution": "The problem statement is meticulously validated and found to be self-contained, scientifically grounded in the theory of cellular automata, and mathematically well-posed. All definitions for the lattice, neighborhood, and boundary conditions are provided with sufficient clarity and precision to permit a unique and verifiable solution. We assume the lattice dimensions $N$ and $M$ are sufficiently large (e.g., $N \\ge 3$ and $M \\ge 3$) to ensure the existence of all three specified site types: corner, non-corner edge, and interior.\n\nThe core of the problem is to determine the cardinality of the set of mapped neighbor indices for a site $(i,j)$, which is given by $\\mathcal{V}_{i,j} = \\{(\\rho_N(i+\\Delta i), \\rho_M(j+\\Delta j)) \\mid (\\Delta i, \\Delta j) \\in \\mathcal{N}\\}$, where $\\mathcal{N} = \\{-1,0,1\\}^2 \\setminus \\{(0,0)\\}$. We evaluate this for the three site types.\n\n**Part 1: Number of Distinct Neighbor Indices**\n\n**1. Interior Site:**\nAn interior site $(i,j)$ satisfies $0 < i < N-1$ and $0 < j < M-1$. For any offset $(\\Delta i, \\Delta j) \\in \\mathcal{N}$, the tentative neighbor coordinates $(i+\\Delta i, j+\\Delta j)$ are always within the lattice boundaries.\nSpecifically, $i+\\Delta i \\in \\{i-1, i, i+1\\}$, and since $1 \\le i \\le N-2$, we have $0 \\le i-1 \\le i+\\Delta i \\le N-1$.\nSimilarly, $0 \\le j+\\Delta j \\le M-1$.\nTherefore, the boundary mapping acts as the identity: $\\rho_N(k)=k$ and $\\rho_M(\\ell)=\\ell$.\nThe mapped neighbor index is simply $(i+\\Delta i, j+\\Delta j)$. Since the $8$ offsets in $\\mathcal{N}$ are all distinct, they map to $8$ distinct neighbor indices.\nThe number of distinct neighbors for an interior site is $8$.\n\n**2. Non-Corner Edge Site:**\nLet's consider a site on the bottom edge, $(i,0)$, where $0 < i < N-1$. The analysis is symmetric for other edges.\nThe $i$-coordinate of any tentative neighbor, $i+\\Delta i$, remains within the bounds $[0, N-1]$ as for an interior site, so $\\rho_N(i+\\Delta i) = i+\\Delta i$.\nThe $j$-coordinate of a tentative neighbor is $j+\\Delta j = 0+\\Delta j$.\nThe boundary mapping $\\rho_M$ affects the $j$-coordinate:\n- For $\\Delta j = 1$, $0+1=1$, so $\\rho_M(1)=1$.\n- For $\\Delta j = 0$, $0+0=0$, so $\\rho_M(0)=0$.\n- For $\\Delta j = -1$, $0-1=-1$, so $\\rho_M(-1)=0$.\n\nWe list the mapping for each of the $8$ offsets $(\\Delta i, \\Delta j)$:\n- Row $\\Delta j = 1$: $(-1,1) \\to (i-1,1)$; $(0,1) \\to (i,1)$; $(1,1) \\to (i+1,1)$. This gives $3$ distinct neighbors.\n- Row $\\Delta j = 0$: $(-1,0) \\to (i-1,0)$; $(1,0) \\to (i+1,0)$. This gives $2$ distinct neighbors.\n- Row $\\Delta j = -1$: $(-1,-1) \\to (i-1,0)$; $(0,-1) \\to (i,0)$; $(1,-1) \\to (i+1,0)$. These map to neighbors that are already potentially listed.\n\nThe set of distinct mapped neighbor indices is:\n$\\{(i-1,1), (i,1), (i+1,1), (i-1,0), (i+1,0), (i,0)\\}$.\nThe index $(i-1,0)$ is the image of both $(-1,0)$ and $(-1,-1)$.\nThe index $(i+1,0)$ is the image of both $(1,0)$ and $(1,-1)$.\nThe index $(i,0)$ (the site itself) is the image of $(0,-1)$.\nThe total count of distinct indices is $3+2+1 = 6$.\nThe number of distinct neighbors for a non-corner edge site is $6$.\n\n**3. Corner Site:**\nLet's consider the corner site $(0,0)$. The analysis is symmetric for other corners.\nA tentative neighbor is $(\\Delta i, \\Delta j)$. The mapping is applied to both coordinates: $(\\rho_N(\\Delta i), \\rho_M(\\Delta j))$.\n- For $\\Delta i \\in \\{-1,0,1\\}$: $\\rho_N(-1)=0, \\rho_N(0)=0, \\rho_N(1)=1$.\n- For $\\Delta j \\in \\{-1,0,1\\}$: $\\rho_M(-1)=0, \\rho_M(0)=0, \\rho_M(1)=1$.\n\nWe list the mapping for each of the $8$ offsets:\n- $(-1,1) \\to (\\rho_N(-1),\\rho_M(1))=(0,1)$\n- $(0,1) \\to (\\rho_N(0),\\rho_M(1))=(0,1)$\n- $(1,1) \\to (\\rho_N(1),\\rho_M(1))=(1,1)$\n- $(-1,0) \\to (\\rho_N(-1),\\rho_M(0))=(0,0)$\n- $(1,0) \\to (\\rho_N(1),\\rho_M(0))=(1,0)$\n- $(-1,-1) \\to (\\rho_N(-1),\\rho_M(-1))=(0,0)$\n- $(0,-1) \\to (\\rho_N(0),\\rho_M(-1))=(0,0)$\n- $(1,-1) \\to (\\rho_N(1),\\rho_M(-1))=(1,0)$\n\nThe set of distinct mapped neighbor indices is $\\{(0,1), (1,1), (0,0), (1,0)\\}$.\nThe cardinality of this set is $4$.\nThe number of distinct neighbors for a corner site is $4$.\n\nIn summary, the number of distinct neighbors for a corner, non-corner edge, and interior site is $(4, 6, 8)$.\n\n**Part 2: Modification of Local Rule and Multiplicity Patterns**\n\nA local rule update for cell $(i,j)$ depending on the states $S$ of its neighbors with weights $w_{\\Delta i, \\Delta j}$ can be written as:\n$$\nS'_{i,j} = f\\left( \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}} w_{\\Delta i, \\Delta j} S(\\rho_N(i+\\Delta i), \\rho_M(j+\\Delta j)) \\right)\n$$\nTo express this sum in terms of an effective weight $\\widehat{w}_{p,q}$ for each distinct mapped neighbor $(p,q)$, we group the terms in the sum by their target index. Let $\\mathcal{V}_{i,j}$ be the set of distinct mapped neighbors for site $(i,j)$. Let $\\mathcal{N}_{i,j}(p,q)$ be the set of offsets that map to a specific neighbor $(p,q) \\in \\mathcal{V}_{i,j}$:\n$$\n\\mathcal{N}_{i,j}(p,q) = \\{ (\\Delta i', \\Delta j') \\in \\mathcal{N} \\mid (\\rho_N(i+\\Delta i'), \\rho_M(j+\\Delta j')) = (p,q) \\}\n$$\nThe sum can then be rewritten as:\n$$\n\\sum_{(p,q) \\in \\mathcal{V}_{i,j}} \\left( \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}_{i,j}(p,q)} w_{\\Delta i, \\Delta j} \\right) S(p,q)\n$$\nBy comparing this to the form $\\sum_{(p,q) \\in \\mathcal{V}_{i,j}} \\widehat{w}_{p,q} S(p,q)$, we identify the effective weight on neighbor $(p,q)$ as:\n$$\n\\widehat{w}_{p,q} = \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}_{i,j}(p,q)} w_{\\Delta i, \\Delta j}\n$$\nThis effective weight is the sum of the original weights of all offsets that are mapped to the same neighbor index $(p,q)$.\n\nFor the specialized uniform Moore kernel, $w_{\\Delta i, \\Delta j}=1$ for all $(\\Delta i, \\Delta j) \\in \\mathcal{N}$. The effective weight becomes the multiplicity of the mapped neighbor $(p,q)$:\n$$\n\\widehat{w}_{p,q} = \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}_{i,j}(p,q)} 1 = |\\mathcal{N}_{i,j}(p,q)|\n$$\n\nUsing the mappings derived in Part 1, we determine the multiplicity patterns:\n\n**Corner Site $(0,0)$ Multiplicity Pattern:**\nThe distinct neighbors are $(0,0), (0,1), (1,0), (1,1)$.\n- $\\widehat{w}_{0,0}$: Mapped from $(-1,0), (-1,-1), (0,-1)$. Multiplicity is $3$.\n- $\\widehat{w}_{0,1}$: Mapped from $(-1,1), (0,1)$. Multiplicity is $2$.\n- $\\widehat{w}_{1,0}$: Mapped from $(1,0), (1,-1)$. Multiplicity is $2$.\n- $\\widehat{w}_{1,1}$: Mapped from $(1,1)$. Multiplicity is $1$.\nThe sum of multiplicities is $3+2+2+1=8$.\n\n**Non-Corner Edge Site $(i,0)$ Multiplicity Pattern:**\nThe distinct neighbors are $\\{(i-1,1), (i,1), (i+1,1), (i-1,0), (i+1,0), (i,0)\\}$.\n- Neighbors \"away from the boundary\" (row $j=1$):\n  - $\\widehat{w}_{i-1,1}$: Mapped from $(-1,1)$. Multiplicity is $1$.\n  - $\\widehat{w}_{i,1}$: Mapped from $(0,1)$. Multiplicity is $1$.\n  - $\\widehat{w}_{i+1,1}$: Mapped from $(1,1)$. Multiplicity is $1$.\n- Neighbors \"on the boundary\" (row $j=0$):\n  - $\\widehat{w}_{i-1,0}$: Mapped from $(-1,0), (-1,-1)$. Multiplicity is $2$.\n  - $\\widehat{w}_{i+1,0}$: Mapped from $(1,0), (1,-1)$. Multiplicity is $2$.\n  - $\\widehat{w}_{i,0}$: Mapped from $(0,-1)$. Multiplicity is $1$.\nThe sum of multiplicities is $1+1+1+2+2+1=8$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4 & 6 & 8\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Translating the abstract definition of a cellular automaton rule into efficient, scalable code is a key skill for any modeler. This exercise bridges the gap between theory and high-performance implementation by exploring a powerful vectorized technique for outer-totalistic rules, such as Conway's Game of Life. You will derive and implement a method that uses bitwise operations and integer arithmetic to evaluate the birth and survival conditions for all cells simultaneously, a significant optimization over naive iterative approaches that is essential for large-scale simulations .",
            "id": "4150707",
            "problem": "Consider a two-dimensional binary Cellular Automaton (CA), where the state at discrete time $t$ is a matrix $X^{(t)} \\in \\{0,1\\}^{H \\times W}$, with $H$ and $W$ positive integers. The update is outer-totalistic: the next state at site $(i,j)$ depends on the current state $X^{(t)}_{i,j}$ and the total count of live neighbors $S^{(t)}_{i,j}$ according to birth and survival sets. Use the following fundamental base: the definition of outer-totalistic two-dimensional CA, the definition of Moore and von Neumann neighborhoods, and discrete convolution with finite kernels.\n\nDefinitions:\n- The Moore neighborhood of radius $1$ comprises the $8$ surrounding sites in a $3 \\times 3$ block centered at $(i,j)$. The associated binary kernel is\n$$\nK_{\\mathrm{M}} = \\begin{bmatrix}\n1 & 1 & 1 \\\\\n1 & 0 & 1 \\\\\n1 & 1 & 1\n\\end{bmatrix}.\n$$\n- The von Neumann neighborhood of radius $1$ comprises the $4$ cardinal neighbors. The associated binary kernel is\n$$\nK_{\\mathrm{V}} = \\begin{bmatrix}\n0 & 1 & 0 \\\\\n1 & 0 & 1 \\\\\n0 & 1 & 0\n\\end{bmatrix}.\n$$\n- The neighbor count $S^{(t)}$ is the discrete convolution of $X^{(t)}$ with one of the above kernels, evaluated with a specified boundary condition. For a kernel $K$ and state $X^{(t)}$, the neighbor count satisfies\n$$\nS^{(t)} = X^{(t)} * K,\n$$\nwhere $*$ denotes two-dimensional discrete convolution, and boundary handling is either periodic (wrap-around) or zero-fill (outside values equal to $0$).\n\nOuter-totalistic update rule:\n- Let $\\mathcal{B} \\subset \\mathbb{N}$ be the birth set, and $\\mathcal{S} \\subset \\mathbb{N}$ be the survival set. The next state is defined by\n$$\nX^{(t+1)}_{i,j} =\n\\begin{cases}\n1, & \\text{if } \\big(X^{(t)}_{i,j} = 0 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{B}\\big) \\text{ or } \\big(X^{(t)}_{i,j} = 1 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{S}\\big), \\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\n\nTask:\n1. Derive the expression of the outer-totalistic update using only integer arithmetic by encoding $\\mathcal{B}$ and $\\mathcal{S}$ as bit masks. Specifically, define integers\n$$\nm_{\\mathcal{B}} = \\sum_{k \\in \\mathcal{B}} 2^k,\n\\quad\nm_{\\mathcal{S}} = \\sum_{k \\in \\mathcal{S}} 2^k,\n$$\nand show that for each site $(i,j)$, membership tests $S^{(t)}_{i,j} \\in \\mathcal{B}$ and $S^{(t)}_{i,j} \\in \\mathcal{S}$ can be implemented via bitwise operations using the per-site value $b^{(t)}_{i,j} = 2^{S^{(t)}_{i,j}}$.\n2. Using the above, write a complete program that:\n   - Computes $S^{(t)}$ via discrete convolution with $K_{\\mathrm{M}}$ or $K_{\\mathrm{V}}$ using integer arithmetic, honoring specified boundary conditions: periodic wrap-around, or zero-fill.\n   - Updates the CA state for a specified number of steps using only vectorized integer operations: bitwise AND, bitwise OR, integer shifts, and integer comparisons converted to binary indicators.\n   - Returns, for each provided test case, the total count of live cells (sum of entries of $X^{(T)}$) after $T$ steps.\n\nBoundary conditions:\n- Periodic wrap-around: indices beyond borders wrap modulo $H$ for rows and modulo $W$ for columns.\n- Zero-fill: any access outside the domain yields $0$.\n\nAngle units and physical units are not applicable, and no physical quantities are involved.\n\nTest suite:\nImplement the following test cases. For each case, the program must compute the total live-cell count after the specified number of steps $T$.\n\n- Case $1$ (general Moore, periodic):\n  - Neighborhood: Moore ($K_{\\mathrm{M}}$).\n  - Boundary: periodic wrap-around.\n  - Rule: Conway’s Game of Life birth/survival, $\\mathcal{B} = \\{3\\}$, $\\mathcal{S} = \\{2,3\\}$.\n  - Grid size: $6 \\times 6$.\n  - Initial state: a glider placed away from edges with live cells at coordinates $(1,2)$, $(2,3)$, $(3,1)$, $(3,2)$, $(3,3)$; all other sites $0$.\n  - Steps: $T = 4$.\n\n- Case $2$ (boundary sensitivity, Moore, zero-fill):\n  - Neighborhood: Moore ($K_{\\mathrm{M}}$).\n  - Boundary: zero-fill.\n  - Rule: $\\mathcal{B} = \\{3\\}$, $\\mathcal{S} = \\{2,3\\}$.\n  - Grid size: $6 \\times 6$.\n  - Initial state: a glider near the corner with live cells at $(0,1)$, $(1,2)$, $(2,0)$, $(2,1)$, $(2,2)$; all other sites $0$.\n  - Steps: $T = 4$.\n\n- Case $3$ (von Neumann, local growth):\n  - Neighborhood: von Neumann ($K_{\\mathrm{V}}$).\n  - Boundary: periodic wrap-around.\n  - Rule: $\\mathcal{B} = \\{1\\}$, $\\mathcal{S} = \\{1\\}$.\n  - Grid size: $7 \\times 7$.\n  - Initial state: a single live cell at the center $(3,3)$; all other sites $0$.\n  - Steps: $T = 2$.\n\n- Case $4$ (empty invariance):\n  - Neighborhood: Moore ($K_{\\mathrm{M}}$).\n  - Boundary: periodic wrap-around.\n  - Rule: $\\mathcal{B} = \\{3\\}$, $\\mathcal{S} = \\{2,3\\}$.\n  - Grid size: $5 \\times 5$.\n  - Initial state: all sites $0$.\n  - Steps: $T = 3$.\n\n- Case $5$ (full extinction under Game of Life):\n  - Neighborhood: Moore ($K_{\\mathrm{M}}$).\n  - Boundary: periodic wrap-around.\n  - Rule: $\\mathcal{B} = \\{3\\}$, $\\mathcal{S} = \\{2,3\\}$.\n  - Grid size: $4 \\times 4$.\n  - Initial state: all sites $1$.\n  - Steps: $T = 2$.\n\n- Case $6$ (von Neumann, symmetric pattern):\n  - Neighborhood: von Neumann ($K_{\\mathrm{V}}$).\n  - Boundary: periodic wrap-around.\n  - Rule: $\\mathcal{B} = \\{2\\}$, $\\mathcal{S} = \\{2\\}$.\n  - Grid size: $5 \\times 5$.\n  - Initial state: a plus shape centered at $(2,2)$ with live cells at $(2,2)$, $(1,2)$, $(3,2)$, $(2,1)$, $(2,3)$; all other sites $0$.\n  - Steps: $T = 1$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,\\dots,r_6]$, where each $r_k$ is the integer total live-cell count after the specified number of steps for Case $k$ in the exact order listed above. No extra text is permitted in the output.",
            "solution": "The problem is valid as it is scientifically grounded in the theory of cellular automata, well-posed with all necessary parameters specified, and articulated using objective, formal language. It presents a standard computational task with specific implementation constraints that are a meaningful test of understanding.\n\nThe solution is divided into two parts as per the task requirements: a derivation of the integer-arithmetic update rule, followed by a description of the algorithmic implementation that will be provided in the final answer.\n\n### Part 1: Derivation of the Bitwise Integer-Arithmetic Update Rule\n\nThe state of a cell at site $(i,j)$ and time $t+1$, denoted $X^{(t+1)}_{i,j}$, is determined by its current state $X^{(t)}_{i,j} \\in \\{0, 1\\}$ and the sum of its live neighbors, $S^{(t)}_{i,j}$. The update is governed by a birth set $\\mathcal{B}$ and a survival set $\\mathcal{S}$:\n$$\nX^{(t+1)}_{i,j} =\n\\begin{cases}\n1, & \\text{if } \\big(X^{(t)}_{i,j} = 0 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{B}\\big) \\text{ or } \\big(X^{(t)}_{i,j} = 1 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{S}\\big), \\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\nThis can be expressed using logical operators. Let $C_B$ be the condition for birth ($X^{(t)}_{i,j} = 0 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{B}$) and $C_S$ be the condition for survival ($X^{(t)}_{i,j} = 1 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{S}$). Since a cell cannot be simultaneously dead ($X^{(t)}_{i,j} = 0$) and alive ($X^{(t)}_{i,j} = 1$), the conditions $C_B$ and $C_S$ are mutually exclusive. Therefore, the next state is $1$ if $C_B \\lor C_S$ is true, and $0$ otherwise.\n\nOur goal is to implement these logical conditions using only integer arithmetic and bitwise operations. The problem introduces bit masks for the sets $\\mathcal{B}$ and $\\mathcal{S}$:\n$$\nm_{\\mathcal{B}} = \\sum_{k \\in \\mathcal{B}} 2^k, \\quad m_{\\mathcal{S}} = \\sum_{k \\in \\mathcal{S}} 2^k.\n$$\nAn integer $m$ constructed this way has its $k$-th bit set to $1$ if and only if $k$ is an element of the corresponding set. For instance, if $\\mathcal{B} = \\{3\\}$, then $m_{\\mathcal{B}} = 2^3 = 8$, which is `1000` in binary. If $\\mathcal{S} = \\{2, 3\\}$, then $m_{\\mathcal{S}} = 2^2 + 2^3 = 4 + 8 = 12$, which is `1100` in binary.\n\nThe membership test $s \\in \\mathcal{B}$ can be checked by testing if the $s$-th bit of $m_{\\mathcal{B}}$ is set. Let $s = S^{(t)}_{i,j}$. We can construct an integer that has only its $s$-th bit set: $b = 2^s$. This is efficiently computed using a bit shift operation: $1 \\ll s$.\nThe bitwise AND operation, denoted by `&`, between $b$ and $m_{\\mathcal{B}}$ will yield a non-zero result if and only if the $s$-th bit is set in both numbers. Since $b$ only has the $s$-th bit set, this is equivalent to checking if the $s$-th bit is set in $m_{\\mathcal{B}}$.\nThus, the membership test $s \\in \\mathcal{B}$ is equivalent to the integer expression $( (1 \\ll s) \\ \\& \\ m_{\\mathcal{B}} ) \\neq 0$.\n\nLet's define two indicator functions, which evaluate to $1$ if true and $0$ if false:\n-   Indicator for birth eligibility: $I_{\\mathcal{B}}(s) = ((1 \\ll s) \\ \\& \\ m_{\\mathcal{B}}) \\neq 0$\n-   Indicator for survival eligibility: $I_{\\mathcal{S}}(s) = ((1 \\ll s) \\ \\& \\ m_{\\mathcal{S}}) \\neq 0$\n\nThe logical conditions $C_B$ and $C_S$ can now be written using arithmetic operations on the integer states $\\{0,1\\}$. A cell is dead if its state is $0$, which can be indicated by $(1 - X^{(t)}_{i,j})$. A cell is alive if its state is $1$, indicated by $X^{(t)}_{i,j}$.\n\n-   Birth condition: A dead cell is born if its neighbor count is in $\\mathcal{B}$.\n    $C_B \\equiv (1 - X^{(t)}_{i,j}) \\cdot I_{\\mathcal{B}}(S^{(t)}_{i,j})$\n-   Survival condition: An alive cell survives if its neighbor count is in $\\mathcal{S}$.\n    $C_S \\equiv X^{(t)}_{i,j} \\cdot I_{\\mathcal{S}}(S^{(t)}_{i,j})$\n\nSince $C_B$ and $C_S$ are mutually exclusive, the next state $X^{(t+1)}_{i,j}$ is their sum:\n$$\nX^{(t+1)}_{i,j} = (1 - X^{(t)}_{i,j}) \\cdot I_{\\mathcal{B}}(S^{(t)}_{i,j}) + X^{(t)}_{i,j} \\cdot I_{\\mathcal{S}}(S^{(t)}_{i,j})\n$$\nThis expression uses only standard integer arithmetic (addition, subtraction, multiplication) and the bitwise operations hidden within the indicator functions. This formulation is directly translatable to vectorized operations on entire matrices, enabling efficient computation.\n\n### Part 2: Algorithm Design\n\nThe program implements a cellular automaton simulator according to the derived integer-arithmetic rule. The core of the algorithm consists of an iterative process that updates the grid state for a specified number of steps.\n\n1.  **Initialization**: For each test case, the program initializes a two-dimensional integer array $X^{(0)}$ of size $H \\times W$ representing the grid's initial state. The birth and survival sets, $\\mathcal{B}$ and $\\mathcal{S}$, are used to compute their corresponding integer bit masks, $m_{\\mathcal{B}}$ and $m_{\\mathcal{S}}$. The appropriate neighborhood kernel, $K_{\\mathrm{M}}$ or $K_{\\mathrm{V}}$, is selected.\n\n2.  **Neighbor Counting**: In each step $t$, the neighbor sum matrix $S^{(t)}$ is computed. This is achieved by performing a two-dimensional discrete convolution of the current state matrix $X^{(t)}$ with the chosen kernel $K$. The `scipy.signal.convolve2d` function is used for this purpose. The function's `mode` parameter is set to `'same'` to ensure the output matrix $S^{(t)}$ has the same dimensions as $X^{(t)}$. The boundary conditions are handled by the `boundary` parameter: `'wrap'` for periodic boundaries and `'fill'` with `fillvalue=0` for zero-fill boundaries.\n\n3.  **State Update**: The state matrix is updated from $X^{(t)}$ to $X^{(t+1)}$ using the derived bitwise rule, applied element-wise across the entire grid in a vectorized manner using `numpy`. The sequence of operations is as follows:\n    a. Compute the neighbor count matrix $S = S^{(t)}$.\n    b. Compute the bit-position matrix $B = 2^S$ using the vectorized bit shift operation `1 << S`.\n    c. Evaluate the birth condition for all sites simultaneously: `is_birth = ((B & m_B) != 0)`.\n    d. Evaluate the survival condition for all sites: `is_survival = ((B & m_S) != 0)`.\n    e. Compute the next state matrix $X_{next}$ by combining the conditions with the current state $X=X^{(t)}$. A logically transparent approach is:\n    `born = (X == 0) & is_birth`\n    `survived = (X == 1) & is_survival`\n    `X_next = born | survived`\n    This can be cast to an integer matrix for the next iteration.\n\n4.  **Iteration**: The process of neighbor counting and state update is repeated $T$ times, where $T$ is the specified number of steps for the test case. The state matrix $X$ is updated to $X_{next}$ at the end of each iteration.\n\n5.  **Final Calculation**: After $T$ steps, the final state matrix $X^{(T)}$ is obtained. The required result is the total number of live cells, which is computed by summing all elements of $X^{(T)}$.\n\nThis algorithm is executed for each of the six test cases provided, and the resulting live-cell counts are collected and formatted into the specified output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the cellular automata problem for all test cases.\n    \"\"\"\n\n    # Define neighborhood kernels.\n    K_M = np.array([\n        [1, 1, 1],\n        [1, 0, 1],\n        [1, 1, 1]\n    ], dtype=np.int8)\n\n    K_V = np.array([\n        [0, 1, 0],\n        [1, 0, 1],\n        [0, 1, 0]\n    ], dtype=np.int8)\n\n    kernels = {\n        'Moore': K_M,\n        'von Neumann': K_V\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'name': 'Case 1 (general Moore, periodic)',\n            'neighborhood': 'Moore',\n            'boundary': 'periodic',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (6, 6),\n            'initial_live_cells': [(1, 2), (2, 3), (3, 1), (3, 2), (3, 3)],\n            'steps': 4\n        },\n        {\n            'name': 'Case 2 (boundary sensitivity, Moore, zero-fill)',\n            'neighborhood': 'Moore',\n            'boundary': 'zero-fill',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (6, 6),\n            'initial_live_cells': [(0, 1), (1, 2), (2, 0), (2, 1), (2, 2)],\n            'steps': 4\n        },\n        {\n            'name': 'Case 3 (von Neumann, local growth)',\n            'neighborhood': 'von Neumann',\n            'boundary': 'periodic',\n            'rule_b': {1},\n            'rule_s': {1},\n            'grid_size': (7, 7),\n            'initial_live_cells': [(3, 3)],\n            'steps': 2\n        },\n        {\n            'name': 'Case 4 (empty invariance)',\n            'neighborhood': 'Moore',\n            'boundary': 'periodic',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (5, 5),\n            'initial_live_cells': [],\n            'steps': 3\n        },\n        {\n            'name': 'Case 5 (full extinction under Game of Life)',\n            'neighborhood': 'Moore',\n            'boundary': 'periodic',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (4, 4),\n            'initial_live_cells': 'all',\n            'steps': 2\n        },\n        {\n            'name': 'Case 6 (von Neumann, symmetric pattern)',\n            'neighborhood': 'von Neumann',\n            'boundary': 'periodic',\n            'rule_b': {2},\n            'rule_s': {2},\n            'grid_size': (5, 5),\n            'initial_live_cells': [(2, 2), (1, 2), (3, 2), (2, 1), (2, 3)],\n            'steps': 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        H, W = case['grid_size']\n        \n        # Initialize the state grid\n        if case['initial_live_cells'] == 'all':\n            X = np.ones((H, W), dtype=np.int8)\n        else:\n            X = np.zeros((H, W), dtype=np.int8)\n            for r, c in case['initial_live_cells']:\n                X[r, c] = 1\n\n        # Get simulation parameters\n        kernel = kernels[case['neighborhood']]\n        T = case['steps']\n\n        # Create bit masks for birth and survival rules\n        m_B = sum(1 << k for k in case['rule_b'])\n        m_S = sum(1 << k for k in case['rule_s'])\n\n        # Set convolution boundary parameters\n        boundary_mode = 'wrap' if case['boundary'] == 'periodic' else 'fill'\n        fill_value = 0 if case['boundary'] == 'zero-fill' else None\n\n        # Run simulation for T steps\n        for _ in range(T):\n            # 1. Compute neighbor sum S via convolution\n            S = signal.convolve2d(X, kernel, mode='same', boundary=boundary_mode, fillvalue=fill_value)\n\n            # 2. Compute the per-site bit value b = 2^S\n            # Use a sufficiently large integer type to prevent overflow from 1 << S\n            # S can be at most 8, so 2^8=256. np.uint16 is safe.\n            B = (1 << S.astype(np.uint16))\n\n            # 3. Determine which cells are born or survive using bitwise operations\n            # A dead cell at (i,j) is born if S[i,j] is in the birth set B.\n            # (X == 0) & ((B & m_B) != 0)\n            birth_mask = (B & m_B) != 0\n            born = (1 - X) & birth_mask\n\n            # An alive cell at (i,j) survives if S[i,j] is in the survival set S.\n            # (X == 1) & ((B & m_S) != 0)\n            survival_mask = (B & m_S) != 0\n            survived = X & survival_mask\n\n            # 4. Compute the next state\n            X = born | survived\n\n        # Calculate the total number of live cells\n        total_live_cells = np.sum(X)\n        results.append(total_live_cells)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}