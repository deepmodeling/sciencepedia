{
    "hands_on_practices": [
        {
            "introduction": "元胞自动机的核心在于其简单的局部规则如何产生复杂的全局行为。在深入研究复杂现象之前，我们必须掌握一项基本技能：如何将期望的系统行为转化为精确的元胞自动机规则。本练习将引导你从一个具体的功能需求出发，通过逻辑推理构建出对应的规则表，并最终确定其沃尔夫兰代码（Wolfram code），这是将抽象模型付诸实践的第一步。",
            "id": "1666385",
            "problem": "考虑基于基本元胞自动机（ECA）原理设计一个一维数字滤波器。一个 ECA 由一行元胞组成，每个元胞可以处于两种状态之一，指定为 1（激活）或 0（非激活）。在下一个时间步，每个元胞的状态由其当前状态及其直接的左、右邻居的状态决定。这三个元胞的集合构成一个“邻域”。\n\n该滤波器需要在一个时间步内根据以下逻辑实现一个特定的变换：\n1.  一个激活元胞（状态 1），如果它是一个激活元胞对或更大的连续激活元胞块的一部分，则必须转变为非激活状态（状态 0）。这意味着，如果一个元胞是激活的，并且其至少一个直接邻居也是激活的，它就会变为非激活。\n2.  一个“孤立”的激活元胞，即其两个直接邻居都是非激活的，必须保持激活状态。\n3.  一个非激活元胞（状态 0）在下一个时间步必须始终保持非激活状态，无论其邻居的状态如何，以确保背景稳定性。\n\nECA 规则由一个从 0 到 255 的数字指定，称为 Wolfram 编码。该编码是一个 8 位二进制字符串的十进制表示，其中每一位对应 8 种可能的邻域配置之一的输出状态。这些配置的顺序为从“111”、“110”、“101”、“100”、“011”、“010”、“001”到“000”。该二进制字符串的第一位给出“111”邻域的输出，第二位给出“110”的输出，依此类推，最后一位给出“000”的输出。\n\n确定实现此滤波逻辑的基本元胞自动机的 Wolfram 编码。",
            "solution": "设时间步 $t$ 的邻域为 $(L,C,R) \\in \\{0,1\\}^{3}$，其中 $L$ 为左邻居，$C$ 为中心元胞，$R$ 为右邻居。更新规则 $f:\\{0,1\\}^{3}\\to\\{0,1\\}$ 必须实现：\n- 如果 $C=1$ 并且 $L$ 或 $R$ 中至少有一个为 $1$，则下一状态为 $0$。\n- 如果 $C=1$ 且 $L=0$ 且 $R=0$，则下一状态为 $1$。\n- 如果 $C=0$，则下一状态始终为 $0$。\n\n这可以简明地写成\n$$\nf(L,C,R)=\n\\begin{cases}\n1,  \\text{if } (L,C,R)=(0,1,0),\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n\n根据 Wolfram 编码的约定，我们按照邻域顺序 111, 110, 101, 100, 011, 010, 001, 000 列出输出。定义位 $b_{7},b_{6},\\dots,b_{0}$ 为 $b_{7}=f(1,1,1)$，$b_{6}=f(1,1,0)$，$b_{5}=f(1,0,1)$，$b_{4}=f(1,0,0)$，$b_{3}=f(0,1,1)$，$b_{2}=f(0,1,0)$，$b_{1}=f(0,0,1)$，$b_{0}=f(0,0,0)$。应用该规则：\n$$\n\\begin{aligned}\nb_{7}=f(1,1,1)=0,\\\\\nb_{6}=f(1,1,0)=0,\\\\\nb_{5}=f(1,0,1)=0,\\\\\nb_{4}=f(1,0,0)=0,\\\\\nb_{3}=f(0,1,1)=0,\\\\\nb_{2}=f(0,1,0)=1,\\\\\nb_{1}=f(0,0,1)=0,\\\\\nb_{0}=f(0,0,0)=0.\n\\end{aligned}\n$$\n\n因此，8 位输出字符串为 $00000100$。Wolfram 编码 $W$ 是其十进制值\n$$\nW=\\sum_{k=0}^{7} b_{k} 2^{k}=b_{2} 2^{2}=1\\cdot 2^{2}=4.\n$$",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "设计好规则后，下一步便是将其付诸于计算机模拟。为了高效、标准化地实现这一点，我们需要一套通用的规则编码和执行系统。本练习旨在通过编程实践，让你掌握基本一维元胞自动机（ECA）的核心实现机制，包括根据沃尔夫兰编码方案（Wolfram code）对规则进行编码和解码，以及在周期性边界条件下模拟其随时间的演化。 这是一个基础但至关重要的练习，它为你构建更复杂的元胞自动机模型奠定了坚实的编程基础。",
            "id": "3104964",
            "problem": "您需要实现一维初等元胞自动机（CA）规则的编码和解码，并通过在具有周期性边界条件的有限格子上模拟更新来验证该实现。请从以下定义开始。一个初等元胞自动机是一个动力系统，它具有一个由 $L$ 个元胞组成的一维格子，每个元胞在离散时间 $t\\in\\{0,1,2,\\dots\\}$ 具有一个二元状态 $s_i(t)\\in\\{0,1\\}$。所有元胞根据一个局部规则同步更新，该规则依赖于半径为 $1$ 的邻域，即三元组 $(s_{i-1}(t),s_i(t),s_{i+1}(t))$。该规则由一个规则表指定，该表为 $2^3=8$ 个邻域中的每一个给出下一个状态。在 Stephen Wolfram 的编码中，通过将这 $8$ 个输出解释为 $R$ 的比特位，规则表被映射到一个整数编码 $R\\in\\{0,1,\\dots,255\\}$。令“规则表向量”为一个长度为 $8$ 的列表 $v$，其中 $v[k]\\in\\{0,1\\}$ 等于邻域 $(a,b,c)$ 的输出，其索引 $k$ 为 $k=4a+2b+c$。该索引按二进制升序从 $k=0$ 处的 $(0,0,0)$ 到 $k=7$ 处的 $(1,1,1)$。Wolfram 的整数编码 $R$ 随之定义为 $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k}.$$ 反之，给定 $R$，通过读取其二进制展开可恢复规则表向量： $$v[k]=\\left\\lfloor \\frac{R}{2^k}\\right\\rfloor \\bmod 2 \\quad\\text{对于}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ 要在具有周期性边界条件的长度为 $L$ 的格子上模拟元胞自动机的一个时间步，对每个索引 $i\\in\\{0,1,\\dots,L-1\\}$，计算邻域 $(s_{i-1}(t),s_i(t),s_{i+1}(t))$（其中索引对 $L$ 取模），构成索引 $k=4s_{i-1}(t)+2s_i(t)+s_{i+1}(t)$，并设置 $s_i(t+1)$ 等于比特位 $v[k]$。等效地，可以直接通过 $R$ 计算该比特位： $$s_i(t+1)=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2.$$ 您的任务是实现与这些定义一致的函数，并为一组测试套件生成指定的输出：\n- 实现一个编码器，将给定的规则表向量 $v$ 映射到整数编码 $R$。\n- 实现一个解码器，将给定的整数编码 $R$ 映射到规则表向量 $v$。\n- 实现一个模拟器，在给定 $R$、一个二元初始状态 $x^{(0)}\\in\\{0,1\\}^L$ 和一个非负整数步数 $T$ 的情况下，返回在周期性边界条件下最终构型 $x^{(T)}$ 中状态为 $1$ 的元胞数量。\n\n为达到科学真实性，设计需要与上述定义严格一致。不允许使用其他启发式方法。仅使用整数算术进行状态更新。不涉及角度，也不需要物理单位。\n\n测试套件。您的程序必须为以下参数集计算输出：\n- 情况 A（编码）：$v=[0,1,1,0,1,0,0,1]$。\n- 情况 B（编码）：$v=[1,0,1,0,1,0,1,0]$。\n- 情况 C（解码）：$R=30$。\n- 情况 D（解码）：$R=255$。\n- 情况 E（模拟）：$R=110$，$L=15$，$T=10$，初始状态 $x^{(0)}$ 是在索引 $\\left\\lfloor L/2\\right\\rfloor$ 处为单个 $1$，其他位置为 $0$。\n- 情况 F（模拟，边界边缘情况）：$R=0$，$L=1$，$T=5$，初始状态 $x^{(0)}=[1]$。\n- 情况 G（模拟，零步）：$R=90$，$L=2$，$T=0$，初始状态 $x^{(0)}=[1,0]$。\n\n所需输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。情况 A 的元素必须是编码后的整数 $R$。情况 B 的元素必须是编码后的整数 $R$。情况 C 和情况 D 的元素必须是解码后的规则表向量 $v$，按索引升序 $k=0,1,2,3,4,5,6,7$ 排列。情况 E、情况 F 和情况 G 的元素必须是 $x^{(T)}$ 中状态为 $1$ 的元胞的整数计数。因此，最终输出应为一个包含 $7$ 个元素的列表：两个整数，两个长度为 $8$ 的列表，以及三个整数。",
            "solution": "本解法从一维初等元胞自动机（CA）的核心定义、Wolfram 编码映射和同步局部更新规则出发，然后构建直接实现这些原理的算法。\n\n基本原理和定义。一个初等元胞自动机由一维格子上的二元状态 $s_i(t)\\in\\{0,1\\}$ 和一个仅依赖于最近邻及当前元胞的确定性局部更新规则指定。在位置 $i$ 时间 $t$ 的邻域是 $(s_{i-1}(t),s_i(t),s_{i+1}(t))$。因为每个分量都是二元的，所以有 $2^3=8$ 种可能的邻域。因此，规则的完整规范是一个规则表，为这 $8$ 个邻域中的每一个分配一个下一状态的输出。Stephen Wolfram 的编码将这 $8$ 个输出映射到一个整数 $R\\in\\{0,1,\\dots,255\\}$ 的比特位，使得 $R$ 的二进制展开对输出进行编码。为确保邻域三元组和比特位位置之间的精确映射，用 $k=4a+2b+c$ 对邻域进行索引，其中 $(a,b,c)\\in\\{0,1\\}^3$ 被解释为一个二进制数，而 $a$ 是最高有效位。那么，“规则表向量” $v$ 的长度为 $8$，其条目 $v[k]\\in\\{0,1\\}$ 等于邻域索引 $k$ 的输出。在此约定下，整数编码为 $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k},$$ 逆映射为 $$v[k]=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2 \\quad\\text{对于}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ 这种双射关系是整数二进制表示基本原理的直接结果。\n\n编码的算法设计。给定一个在 $\\{0,1\\}$ 中有 $8$ 个条目的 $v$，使用上述求和公式计算 $R$。用算法的术语来说，就是迭代 $k$ 从 $0$ 到 $7$，并累加 $v[k]\\cdot 2^k$。这保证会产生一个在 $\\{0,1,\\dots,255\\}$ 范围内的整数，因为每一项 $v[k]\\cdot 2^k$ 要么是 $0$，要么是 $2^k$，而不同2的幂次之和会产生一个有效的二进制表示。\n\n解码的算法设计。给定一个在 $\\{0,1,\\dots,255\\}$ 范围内的整数 $R$，通过整数除法和取模运算读取位置 $k$ 的比特位来恢复 $v$：$v[k]=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$。在编程上，可以等效地使用位移和掩码操作 $v[k]=\\left((R\\gg k)\\  \\ 1\\right)$，这在使用标准整数算术时是完全相同的计算。这将产生一个长度为 $8$ 的列表，其中邻域 $(0,0,0)$ 对应于 $k=0$，而 $(1,1,1)$ 对应于 $k=7$。\n\n模拟的算法设计。对于一个长度为 $L$ 且具有周期性边界条件的格子，邻域索引会环绕，使得 $i-1$ 和 $i+1$ 对 $L$ 取模。要从 $x^{(t)}$ 计算 $x^{(t+1)}$，对每个位置 $i\\in\\{0,1,\\dots,L-1\\}$ 执行以下操作：\n- 读取 $a=s_{(i-1)\\bmod L}(t)$，$b=s_i(t)$ 和 $c=s_{(i+1)\\bmod L}(t)$。\n- 构成邻域索引 $k=4a+2b+c$。\n- 计算下一状态 $s_i(t+1)=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$。\n将此过程迭代 $T$ 次以获得 $x^{(T)}$。$x^{(T)}$ 中 $1$ 的计数为 $\\sum_{i=0}^{L-1} s_i(T)$，这是一个在 $\\{0,1,\\dots,L\\}$ 范围内的整数。\n\n测试套件的覆盖范围和边界情况。编码测试检验了从已知规则表向量到 $R$ 的映射。对于情况 A，向量 $v=[0,1,1,0,1,0,0,1]$ 对应于三个邻域比特的奇偶性（和模 $2$），编码产生 $R=150$，因为 $150$ 的二进制展开在位置 $k=1$、$k=2$、$k=4$ 和 $k=7$ 处为 $1$。对于情况 B，交替向量 $v=[1,0,1,0,1,0,1,0]$ 编码为 $R=85$，因为 $85$ 在偶数比特位置 $k\\in\\{0,2,4,6\\}$ 处为 $1$。解码测试从给定的 $R$ 重构向量：情况 C 中 $R=30$ 产生等于 $30$ 在位置 $k=0,1,\\dots,7$ 处比特位的 $v$，即 $[0,1,1,1,1,0,0,0]$，因为 $30=2+4+8+16$。情况 D 中 $R=255$ 产生全 $1$ 向量 $[1,1,1,1,1,1,1,1]$。模拟测试验证了周期性边界条件下的动力学和特殊情况：情况 E 探索了对于 $R=110$，从长度为 $L=15$ 的格子上一个单独的 $1$ 开始，经过 $T=10$ 步的非平凡增长；情况 F 测试了 $L=1$ 和 $R=0$ 的边界边缘情况，保证了最终的消亡，因此在任意正数步数后最终计数为 $0$；情况 G 测试了 $T=0$ 的情况，此时最终构型即为初始构型，计数的 $1$ 的数量应等于初始总和，对于 $[1,0]$ 来说是 $1$。\n\n最终输出格式。程序将七个结果汇总到一个单行的 Python 风格列表中，元素以逗号分隔且无空格，遵循格式要求。元素按顺序为：情况 A 和 B 的两个编码整数，情况 C 和 D 的两个解码向量，以及情况 E、F 和 G 模拟后 $1$ 的计数的三个整数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef encode_rule(v):\n    \"\"\"\n    Encode an elementary cellular automaton rule table vector into Wolfram's integer code.\n    v: list of 8 integers (0 or 1), where v[k] is the output for neighborhood index k = 4a + 2b + c\n       with (a,b,c) in {0,1}^3 and k ranging from 0 (000) to 7 (111).\n    Returns: integer R in [0,255].\n    \"\"\"\n    if len(v) != 8 or any(x not in (0, 1) for x in v):\n        raise ValueError(\"Rule table vector must be length 8 with binary entries.\")\n    R = 0\n    for k in range(8):\n        R += (v[k]  k)\n    return R\n\ndef decode_rule(R):\n    \"\"\"\n    Decode Wolfram's integer code R into the rule table vector v of length 8.\n    v[k] is the output for neighborhood index k = 4a + 2b + c with (a,b,c) in {0,1}^3.\n    \"\"\"\n    if not (0 = R = 255):\n        raise ValueError(\"Rule code R must be in [0, 255].\")\n    v = [(R >> k)  1 for k in range(8)]\n    return v\n\ndef simulate_rule(R, init_state, steps):\n    \"\"\"\n    Simulate the elementary CA with rule code R on a periodic lattice.\n    R: integer in [0,255]\n    init_state: list of length L with entries 0 or 1\n    steps: nonnegative integer T\n    Returns: integer count of ones in the final state after T steps.\n    \"\"\"\n    L = len(init_state)\n    if L == 0:\n        return 0\n    if steps  0:\n        raise ValueError(\"Steps must be nonnegative.\")\n    \n    curr = init_state[:]\n    if steps == 0:\n        return sum(curr)\n    \n    # Decode rule once for convenience\n    v = decode_rule(R)\n    \n    for _ in range(steps):\n        nxt = [0] * L\n        for i in range(L):\n            a = curr[(i - 1) % L]\n            b = curr[i]\n            c = curr[(i + 1) % L]\n            k = (a  2) | (b  1) | c\n            nxt[i] = v[k]\n        curr = nxt\n    return sum(curr)\n\ndef format_result(obj):\n    \"\"\"\n    Format the result into a string with no spaces, supporting nested lists.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_result(x) for x in obj) + \"]\"\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: encode v = [0,1,1,0,1,0,0,1]\n    v_A = [0,1,1,0,1,0,0,1]\n    # Case B: encode v = [1,0,1,0,1,0,1,0]\n    v_B = [1,0,1,0,1,0,1,0]\n    # Case C: decode R = 30\n    R_C = 30\n    # Case D: decode R = 255\n    R_D = 255\n    # Case E: simulate R=110, L=15, T=10, initial single 1 at floor(L/2)\n    R_E = 110\n    L_E = 15\n    T_E = 10\n    init_E = [0] * L_E\n    init_E[L_E // 2] = 1\n    # Case F: simulate R=0, L=1, T=5, init [1]\n    R_F = 0\n    L_F = 1\n    T_F = 5\n    init_F = [1]\n    # Case G: simulate R=90, L=2, T=0, init [1,0]\n    R_G = 90\n    L_G = 2\n    T_G = 0\n    init_G = [1, 0]\n\n    results = []\n    # Case A\n    results.append(encode_rule(v_A))\n    # Case B\n    results.append(encode_rule(v_B))\n    # Case C\n    results.append(decode_rule(R_C))\n    # Case D\n    results.append(decode_rule(R_D))\n    # Case E\n    results.append(simulate_rule(R_E, init_E, T_E))\n    # Case F\n    results.append(simulate_rule(R_F, init_F, T_F))\n    # Case G\n    results.append(simulate_rule(R_G, init_G, T_G))\n\n    # Final print statement in the exact required format (no spaces).\n    print(\"[\" + \",\".join(format_result(r) for r in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对元胞自动机的研究不止于观察单一初始条件下的演化，更深层次的理解来自于分析其整个状态空间的动态结构。对于一个有限尺寸的系统，其所有可能的演化路径可以被一个“状态转移图”完整地描述。本练习将引导你进入高级分析领域，通过构建并分析这个图，你将能够量化系统的长期行为，例如识别所有的极限环（limit cycles）和吸引域（basins of attraction），从而对该规则的动力学特性有一个全局性和系统性的认识。",
            "id": "4267302",
            "problem": "考虑一个一维的二进制基本元胞自动机 (ECA)，它定义在一个大小为 $n$、带有周期性边界条件的环上。在离散时间 $t \\in \\mathbb{N}$，每个位点 $i \\in \\{0,1,\\dots,n-1\\}$ 持有一个状态 $x_i(t) \\in \\{0,1\\}$。局部更新规则仅依赖于该位点及其最近邻，形成一个宽度为 3 的半径为 1 的邻域：三元组 $\\left(x_{i-1}(t), x_i(t), x_{i+1}(t)\\right)$，其中索引对 $n$ 取模。全局更新是同步的。\n\n采用基本元胞自动机 (ECA) 的标准 Wolfram 规则编码，其中规则编号 $R \\in \\{0,1,\\dots,255\\}$ 为每种邻域模式指定输出比特。对于一个邻域模式 $\\left(b_2,b_1,b_0\\right) \\in \\{0,1\\}^3$，定义模式索引 $p = 4 b_2 + 2 b_1 + b_0$。当且仅当 $R$ 的第 $p$ 位为 $1$ 时（等价于 $\\left\\lfloor R / 2^p \\right\\rfloor \\bmod 2 = 1$），局部规则输出 $1$，否则输出 $0$。全局映射 $f_R:\\{0,1\\}^n \\to \\{0,1\\}^n$ 在周期性边界条件下同时对每个位点应用局部规则。\n\n将规则 $R$ 在大小为 $n$ 的环上的状态转移图定义为有向图 $G_{R,n}=(V,E)$，其中 $V=\\{0,1\\}^n$，且每个 $x \\in V$ 都有一条指向 $f_R(x)$ 的出边。这是一个函数图。$G_{R,n}$ 中的一个有向环即为一个极限环。对于任意状态 $x \\in V$，将其瞬态长度 $\\tau(x)$ 定义为使得 $f_R^t(x)$ 位于 $G_{R,n}$ 的一个极限环上的最小非负整数 $t$；等价地，如果 $x$ 位于一个极限环上，则 $\\tau(x)=0$，否则 $\\tau(x)0$ 且 $f_R^{\\tau(x)}(x)$ 是沿唯一前向轨迹到达的第一个环状态。\n\n仅从上述 ECA 和函数图的基本定义出发，编写一个完整的程序，对下面指定的每个测试用例，构建由 $f_R$ 在 $\\{0,1\\}^n$ 上所蕴含的状态转移图，并计算：\n- 不同极限环的数量；\n\n- 极限环长度的多重集，以排序整数列表形式表示；\n\n- 最大瞬态长度 $\\max_{x \\in \\{0,1\\}^n} \\tau(x)$；\n\n- 平均瞬态长度 $\\frac{1}{2^n} \\sum_{x \\in \\{0,1\\}^n} \\tau(x)$，以十进制浮点值表示。\n\n您的程序必须在周期性边界条件下将状态视为 $\\{0,1\\}^n$ 的元素，并严格按照定义应用全局映射 $f_R$。用长度为 $n$ 的二进制字符串或逻辑上等价的表示法来表示每个状态。\n\n测试套件：\n- 情况 1：$R=0$，$n=5$。\n- 情况 2：$R=150$，$n=1$。\n- 情况 3：$R=90$，$n=10$。\n- 情况 4：$R=30$，$n=10$。\n- 情况 5：$R=110$，$n=8$。\n\n对于每个测试用例，所需的输出是一个形如 $[C,L,M,A]$ 的列表，其中 $C$ 是极限环数量（整数），$L$ 是排序后的环长度列表（整数），$M$ 是最大瞬態长度（整数），$A$ 是平均瞬态长度（浮点数）。将所有测试用例的结果聚合到单行输出中，该行包含一个由方括号括起来的、以逗号分隔的结果列表，例如 $\\left[ [C_1,L_1,M_1,A_1], [C_2,L_2,M_2,A_2], \\dots \\right]$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表（例如 $\\left[ \\text{result}_1,\\text{result}_2,\\text{result}_3 \\right]$）。不涉及物理单位或角度；所有量都是无量纲的。测试用例的最终输出类型必须是布尔值、整数、浮点数或这些类型的列表。",
            "solution": "用户的请求是复杂系统领域中一个定义明确的计算问题，具体涉及一维基本元胞自动机 (ECA)。该问题具有科学依据，逻辑上一致，并且所有术语和参数都得到了足够严格的定义。此问题被验证为有效，因此有必要提供解决方案。\n\n该解决方案首先通过算法为给定的规则 $R$ 和格点大小 $n$ 构建状态转移图，然后分析此图以提取所需的动力学特性。\n\n### 1. 系统表示与图的构建\n\n一个在大小为 $n$ 的环上的基本元胞自动机拥有一个大小为 $|V|=2^n$ 的有限状态空间 $V = \\{0,1\\}^n$。我们可以在长度为 $n$ 的二进制字符串与集合 $\\{0, 1, \\dots, 2^n-1\\}$ 中的整数之间建立一个双射。一个状态 $x = (x_{n-1}, \\dots, x_1, x_0)$ 被识别为整数 $k = \\sum_{i=0}^{n-1} x_i 2^i$。\n\n全局更新映射 $f_R: \\{0,1\\}^n \\to \\{0,1\\}^n$ 是确定性的。它定义了一个有向图 $G_{R,n}=(V,E)$，称为函数图，其中顶点是 $2^n$ 个可能的状态，边由 $E = \\{(k, f_R(k)) \\mid k \\in V\\}$ 给出。在此图中，每个顶点都恰好有一条出边。\n\n算法的第一步是显式地构建这个图。这通过创建一个大小为 $2^n$ 的后继状态数组来实现，我们可以将其表示为 `successors`。对于每个状态整数 $k \\in \\{0, 1, \\dots, 2^n-1\\}$，我们计算它的像 $f_R(k)$，并将其存储在数组的索引 $k$ 处。\n\n计算 $f_R(k)$ 涉及同时对每个位点 $i \\in \\{0, \\dots, n-1\\}$ 应用局部规则。对于给定的位点 $i$，其状态为 $x_i = (k \\gg i) \\land 1$。由于周期性边界条件，其邻居的状态为 $x_{i-1} = (k \\gg ((i-1+n) \\pmod n)) \\land 1$ 和 $x_{i+1} = (k \\gg ((i+1) \\pmod n)) \\land 1$。\n\n局部邻域状态 $(x_{i-1}, x_i, x_{i+1})$ 被解释为一个 3 比特数，构成模式索引 $p = 4x_{i-1} + 2x_i + x_{i+1}$。位点 $i$ 的新状态，记为 $x'_i$，由规则编号 $R$ 的第 $p$ 位给出，可以通过位运算 $(R \\gg p) \\land 1$ 提取。\n\n新的全局状态 $k' = f_R(k)$ 是新构型 $(x'_{n-1}, \\dots, x'_1, x'_0)$ 的整数表示，计算为 $k' = \\sum_{i=0}^{n-1} x'_i 2^i$。对所有 $k \\in \\{0, 1, \\dots, 2^n-1\\}$ 重复此过程，以完全填充 `successors` 数组。\n\n### 2. 用于环和瞬态分析的图遍历\n\n一个有限函数图的结构是若干不相交分量的集合。每个分量由一个单独的有向环和一或多个有向树组成，这些树的路径终结于环的顶点上。任务是识别这些分量并描述其结构。具体来说，我们需要找到所有的环以及通向它们的瞬态路径。\n\n我们采用一种图遍历算法。使用一个大小为 $2^n$ 的辅助数组 `transient_lengths` 来存储每个状态 $k$ 的瞬态长度 $\\tau(k)$。此数组用一个哨兵值（例如-1）初始化，以表示一个状态尚未被访问和分析。\n\n该算法遍历每个状态 $s \\in \\{0, \\dots, 2^n-1\\}$。如果 $s$ 已被访问过（即 `transient_lengths[s]` 不是哨兵值），那么它属于一个已被分析过的分量，所以我们跳过它。否则，我们从 $s$ 开始启动一次遍历。\n\n遍历通过重复应用 `successors` 映射来跟随唯一路径 $s, f_R(s), f_R^2(s), \\dots$。在遍历过程中，我们在一个有序列表 `path` 中记录访问过的状态序列，并使用一个哈希映射 `path_map` 来存储当前路径中的每个状态及其步数（距离 $s$ 的步数）。这样可以高效地检测重访状态。\n\n当遍历遇到一个状态 `curr_node` 时终止，该状态要么在当前路径中出现过（`curr_node` 在 `path_map` 中），要么在之前的遍历中已被分析过（`transient_lengths[curr_node]` 不是哨兵值）。\n\n1.  检测到新环：如果在 `path_map` 中找到 `curr_node`，则发现了一个新环。从 `curr_node` 首次出现到路径结束的那些状态构成了这个环。环的长度是当前步数与首次遇到 `curr_node` 时的步数之差。路径中在环开始之前出现的状态构成了一条通向该环的瞬态路径。对于这条瞬态路径上的每个状态 $k$，其瞬态长度 $\\tau(k)$ 是它到环起点的距离。对于环内的所有状态 $k$，$\\tau(k)=0$。记录环的长度，并将该环添加到我们发现的环的集合中。\n\n2.  检测到通往已知分量的路径：如果遍历遇到一个状态 `curr_node`，其瞬态长度 $\\tau(\\text{curr\\_node})$ 已知，则当前路径是一条汇入先前已分析分量的瞬态路径。然后我们可以通过从 `curr_node` 向后推导，计算当前路径中所有状态的瞬态长度。对于路径中的每个状态 $k$，其瞬态长度由递归关系 $\\tau(k) = 1 + \\tau(f_R(k))$ 给出。\n\n此过程持续进行，直到空间 $\\{0, \\dots, 2^n-1\\}$ 中的每个状态都已被访问并计算出其瞬态长度。\n\n### 3. 最终指标计算\n\n遍历算法完成后，所有必要信息都已收集完毕。最终指标计算如下：\n\n-   环的数量 ($C$)：这是遍历期间发现的唯一环的总数。\n-   环的长度 ($L$)：这是所有发现的环的长度的多重集，以排序整数列表的形式呈现。\n-   最大瞬态长度 ($M$)：这是在已填充的 `transient_lengths` 数组中找到的最大值，即 $\\max_{k \\in V} \\tau(k)$。\n-   平均瞬态长度 ($A$)：这是所有瞬态长度的算术平均值，计算为 $\\frac{1}{2^n} \\sum_{k=0}^{2^n-1} \\tau(k)$。\n\n在计算能力的限制内，这种全面的两阶段方法保证了对任何给定的 ECA 规则 $R$ 和大小 $n$ 的状态转移图进行正确和完整的表征。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the Elementary Cellular Automaton analysis problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (0, 5),   # Case 1\n        (150, 1), # Case 2\n        (90, 10), # Case 3\n        (30, 10), # Case 4\n        (110, 8), # Case 5\n    ]\n\n    results = []\n    for R, n in test_cases:\n        result = analyze_eca_dynamics(R, n)\n        results.append(result)\n\n    def format_result(res):\n        C, L, M, A = res\n        l_str = '[' + ','.join(map(str, L)) + ']'\n        return f\"[{C},{l_str},{M},{A}]\"\n\n    final_output_str = f\"[{','.join(map(format_result, results))}]\"\n    print(final_output_str)\n\ndef analyze_eca_dynamics(R, n):\n    \"\"\"\n    Constructs and analyzes the state transition graph for an ECA.\n    \"\"\"\n    num_states = 1  n\n\n    # Phase 1: Construct the successor array for the state transition graph\n    successors = [0] * num_states\n    for state_int in range(num_states):\n        next_state_int = 0\n        for i in range(n):\n            left_neighbor_val = (state_int >> ((i - 1 + n) % n))  1\n            center_val = (state_int >> i)  1\n            right_neighbor_val = (state_int >> ((i + 1) % n))  1\n            \n            pattern_index = (left_neighbor_val  2) | (center_val  1) | right_neighbor_val\n            \n            new_bit = (R >> pattern_index)  1\n            \n            if new_bit == 1:\n                next_state_int |= (1  i)\n        \n        successors[state_int] = next_state_int\n\n    # Phase 2: Traverse the graph to find cycles and transients\n    transient_lengths = [-1] * num_states\n    cycles = {}\n    cycle_id_counter = 0\n\n    for start_node in range(num_states):\n        if transient_lengths[start_node] != -1:\n            continue\n\n        path = []\n        path_map = {}\n        curr_node = start_node\n        step = 0\n        \n        while transient_lengths[curr_node] == -1 and curr_node not in path_map:\n            path_map[curr_node] = step\n            path.append(curr_node)\n            curr_node = successors[curr_node]\n            step += 1\n\n        if curr_node in path_map:\n            cycle_start_step = path_map[curr_node]\n            cycle_len = step - cycle_start_step\n            \n            cycles[cycle_id_counter] = cycle_len\n            cycle_id_counter += 1\n            \n            for i in range(cycle_start_step):\n                transient_lengths[path[i]] = cycle_start_step - i\n            \n            for i in range(cycle_start_step, step):\n                transient_lengths[path[i]] = 0\n                \n        else:\n            for i in range(len(path) - 1, -1, -1):\n                node = path[i]\n                next_node = successors[node]\n                transient_lengths[node] = 1 + transient_lengths[next_node]\n\n    # Phase 3: Compute final metrics\n    C = len(cycles)\n    L = sorted(list(cycles.values()))\n    \n    M = 0\n    total_transient_len = 0\n    if num_states > 0:\n        M = max(transient_lengths)\n        total_transient_len = sum(transient_lengths)\n    \n    A = float(total_transient_len) / num_states if num_states > 0 else 0.0\n\n    return [C, L, M, A]\n\nsolve()\n```"
        }
    ]
}