{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any cellular automaton is its local rule, which dictates the behavior of the entire system. This exercise  provides hands-on practice in the essential skill of \"rule engineering,\" translating a desired system behavior from a qualitative description into a precise, formal rule table. Mastering this process allows you to design automata that model specific phenomena, making it a cornerstone of applied CA modeling.",
            "id": "1666385",
            "problem": "Consider the design of a one-dimensional digital filter based on the principles of Elementary Cellular Automata (ECA). An ECA consists of a line of cells, where each cell can be in one of two states, designated as 1 (active) or 0 (inactive). The state of each cell at the next time step is determined by its current state and the states of its immediate left and right neighbors. This collection of three cells forms a 'neighborhood'.\n\nThe filter is required to implement a specific transformation in a single time step based on the following logic:\n1.  An active cell (state 1) that is part of a pair or larger contiguous block of active cells must transition to the inactive state (state 0). This means if a cell is active and at least one of its immediate neighbors is also active, it becomes inactive.\n2.  An active cell that is 'isolated', meaning both of its immediate neighbors are inactive, must remain in the active state.\n3.  An inactive cell (state 0) must always remain inactive in the next time step, regardless of the states of its neighbors, to ensure background stability.\n\nThe ECA rule is specified by a number from 0 to 255, known as the Wolfram code. This code is the decimal representation of an 8-bit binary string, where each bit corresponds to the output state for one of the 8 possible neighborhood configurations. The configurations are ordered from '111', '110', '101', '100', '011', '010', '001', down to '000'. The first bit of the binary string gives the output for the '111' neighborhood, the second for '110', and so on, with the last bit giving the output for '000'.\n\nDetermine the Wolfram code for the elementary cellular automaton that implements this filtering logic.",
            "solution": "Let the neighborhood at time step $t$ be $(L,C,R) \\in \\{0,1\\}^{3}$ with $L$ the left neighbor, $C$ the center cell, and $R$ the right neighbor. The update rule $f:\\{0,1\\}^{3}\\to\\{0,1\\}$ must implement:\n- If $C=1$ and at least one of $L$ or $R$ is $1$, then the next state is $0$.\n- If $C=1$ and $L=0$ and $R=0$, then the next state is $1$.\n- If $C=0$, then the next state is always $0$.\n\nThis can be written succinctly as\n$$\nf(L,C,R)=\n\\begin{cases}\n1, & \\text{if } (L,C,R)=(0,1,0),\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n\nAccording to the Wolfram code convention, we list the outputs in the order of neighborhoods: 111, 110, 101, 100, 011, 010, 001, 000. Define bits $b_{7},b_{6},\\dots,b_{0}$ by $b_{7}=f(1,1,1)$, $b_{6}=f(1,1,0)$, $b_{5}=f(1,0,1)$, $b_{4}=f(1,0,0)$, $b_{3}=f(0,1,1)$, $b_{2}=f(0,1,0)$, $b_{1}=f(0,0,1)$, $b_{0}=f(0,0,0)$. Applying the rule:\n$$\n\\begin{aligned}\nb_{7}&=f(1,1,1)=0,\\\\\nb_{6}&=f(1,1,0)=0,\\\\\nb_{5}&=f(1,0,1)=0,\\\\\nb_{4}&=f(1,0,0)=0,\\\\\nb_{3}&=f(0,1,1)=0,\\\\\nb_{2}&=f(0,1,0)=1,\\\\\nb_{1}&=f(0,0,1)=0,\\\\\nb_{0}&=f(0,0,0)=0.\n\\end{aligned}\n$$\n\nThus the 8-bit output string is $00000100$. The Wolfram code $W$ is the decimal value\n$$\nW=\\sum_{k=0}^{7} b_{k} 2^{k}=b_{2} 2^{2}=1\\cdot 2^{2}=4.\n$$",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "Once a rule is designed, the next step is to observe its evolution. This practice  guides you through the implementation of a complete one-dimensional elementary cellular automaton simulator, from rule encoding to dynamic simulation. Building the core functions to run a CA is a fundamental skill that bridges the gap between abstract rules and the emergent patterns they generate.",
            "id": "3104964",
            "problem": "You are to implement the encoding and decoding of one-dimensional elementary Cellular Automata (CA) rules and verify the implementation by simulating updates on finite lattices with periodic boundary conditions. Begin from the following definitions. An elementary CA is a dynamical system with a one-dimensional lattice of $L$ cells, each having a binary state $s_i(t)\\in\\{0,1\\}$ at discrete time $t\\in\\{0,1,2,\\dots\\}$. All cells update synchronously according to a local rule that depends on a neighborhood of radius $1$, namely the triple $(s_{i-1}(t),s_i(t),s_{i+1}(t))$. The rule is specified by a rule table that gives the next state for each of the $2^3=8$ neighborhoods. In Stephen Wolfram’s encoding, the rule table is mapped to an integer code $R\\in\\{0,1,\\dots,255\\}$ by interpreting the $8$ outputs as bits of $R$. Let a \"rule table vector\" be a list $v$ of length $8$ where $v[k]\\in\\{0,1\\}$ equals the output for the neighborhood $(a,b,c)$ whose index $k$ is $k=4a+2b+c$. This index runs in ascending binary order from $(0,0,0)$ at $k=0$ up to $(1,1,1)$ at $k=7$. Wolfram’s integer code $R$ is then defined by $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k}.$$ Conversely, given $R$, the rule table vector is recovered by reading its binary expansion: $$v[k]=\\left\\lfloor \\frac{R}{2^k}\\right\\rfloor \\bmod 2 \\quad\\text{for}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ To simulate one time step of the CA on a lattice of length $L$ with periodic boundary conditions, compute for each index $i\\in\\{0,1,\\dots,L-1\\}$ the neighborhood $(s_{i-1}(t),s_i(t),s_{i+1}(t))$ where indices are taken modulo $L$, form the index $k=4s_{i-1}(t)+2s_i(t)+s_{i+1}(t)$, and set $s_i(t+1)$ equal to the bit $v[k]$. Equivalently, one may compute the bit directly from $R$ via $$s_i(t+1)=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2.$$ Your task is to implement functions consistent with these definitions and produce specified outputs for a test suite:\n- Implement an encoder that maps a given rule table vector $v$ to the integer code $R$.\n- Implement a decoder that maps a given integer code $R$ to the rule table vector $v$.\n- Implement a simulator that, given $R$, a binary initial state $x^{(0)}\\in\\{0,1\\}^L$, and a nonnegative integer number of steps $T$, returns the number of cells in state $1$ in the final configuration $x^{(T)}$ under periodic boundary conditions.\n\nDesign for scientific realism requires strict consistency with the definitions above. No other heuristics are allowed. Use only integer arithmetic for state updates. Angles are not involved, and no physical units are required.\n\nTest suite. Your program must compute outputs for the following parameter sets:\n- Case A (encoding): $v=[0,1,1,0,1,0,0,1]$.\n- Case B (encoding): $v=[1,0,1,0,1,0,1,0]$.\n- Case C (decoding): $R=30$.\n- Case D (decoding): $R=255$.\n- Case E (simulation): $R=110$, $L=15$, $T=10$, initial state $x^{(0)}$ is a single $1$ at index $\\left\\lfloor L/2\\right\\rfloor$ and $0$ elsewhere.\n- Case F (simulation, boundary edge): $R=0$, $L=1$, $T=5$, initial state $x^{(0)}=[1]$.\n- Case G (simulation, zero steps): $R=90$, $L=2$, $T=0$, initial state $x^{(0)}=[1,0]$.\n\nRequired output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). The element for Case A must be the encoded integer $R$. The element for Case B must be the encoded integer $R$. The elements for Case C and Case D must be the decoded rule table vectors $v$ in ascending index order $k=0,1,2,3,4,5,6,7$. The elements for Case E, Case F, and Case G must be the integer counts of cells in state $1$ in $x^{(T)}$. The final output should therefore be a list of $7$ elements: two integers, two lists of length $8$, and three integers.",
            "solution": "The solution proceeds from the core definitions of one-dimensional elementary Cellular Automata (CA), the Wolfram code mapping, and the synchronous local update rule, and then constructs algorithms that directly implement these principles.\n\nFirst principles and definitions. An elementary CA is specified by the binary state $s_i(t)\\in\\{0,1\\}$ on a one-dimensional lattice and a deterministic local update rule that depends only on the nearest neighbors and the current cell. The neighborhood at site $i$ at time $t$ is $(s_{i-1}(t),s_i(t),s_{i+1}(t))$. Because each component is binary, there are $2^3=8$ possible neighborhoods. A complete specification of the rule is therefore a rule table assigning a next-state output to each of the $8$ neighborhoods. Stephen Wolfram’s encoding maps those $8$ outputs to bits of an integer $R\\in\\{0,1,\\dots,255\\}$ such that the binary expansion of $R$ encodes the outputs. To ensure a precise mapping between neighborhood triples and bit positions, index the neighborhoods by $k=4a+2b+c$ where $(a,b,c)\\in\\{0,1\\}^3$ is interpreted as a binary number with $a$ as the most significant bit. Then the \"rule table vector\" $v$ is of length $8$ with entries $v[k]\\in\\{0,1\\}$ equal to the output for neighborhood index $k$. Under this convention, the integer code is $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k},$$ and the inverse mapping is $$v[k]=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2 \\quad\\text{for}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ This bijection is a direct consequence of the fundamental representation of integers in base $2$.\n\nAlgorithmic design for encoding. Given $v$ with $8$ entries in $\\{0,1\\}$, compute $R$ using the above sum. In algorithmic terms, iterate $k$ from $0$ to $7$ and accumulate $v[k]\\cdot 2^k$. This is guaranteed to produce an integer in $\\{0,1,\\dots,255\\}$ because each term $v[k]\\cdot 2^k$ is either $0$ or $2^k$, and the sum of distinct powers of $2$ yields a valid base-$2$ representation.\n\nAlgorithmic design for decoding. Given an integer $R$ in $\\{0,1,\\dots,255\\}$, recover $v$ by reading the bit at position $k$ via integer division and modulo: $v[k]=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$. Programmatically, one may equivalently use the bitwise shift and mask operation $v[k]=\\left((R\\gg k)\\ &\\ 1\\right)$, which is exactly the same computation using standard integer arithmetic. This produces a length-$8$ list where the neighborhood $(0,0,0)$ corresponds to $k=0$ and $(1,1,1)$ to $k=7$.\n\nAlgorithmic design for simulation. For a lattice of length $L$ with periodic boundary conditions, the neighborhood indices wrap around such that $i-1$ and $i+1$ are taken modulo $L$. To compute $x^{(t+1)}$ from $x^{(t)}$, do the following for each site $i\\in\\{0,1,\\dots,L-1\\}$:\n- Read $a=s_{(i-1)\\bmod L}(t)$, $b=s_i(t)$, and $c=s_{(i+1)\\bmod L}(t)$.\n- Form the neighborhood index $k=4a+2b+c$.\n- Compute the next state $s_i(t+1)=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$.\nIterate this $T$ times to obtain $x^{(T)}$. The count of ones in $x^{(T)}$ is $\\sum_{i=0}^{L-1} s_i(T)$, which is an integer in $\\{0,1,\\dots,L\\}$.\n\nCoverage and edge cases in the test suite. The encoding tests exercise the mapping from a known rule table vector to $R$. For Case A, the vector $v=[0,1,1,0,1,0,0,1]$ corresponds to the parity of the three neighborhood bits (sum modulo $2$), and encoding yields $R=150$ because $150$ has binary expansion with ones at positions $k=1$, $k=2$, $k=4$, and $k=7$. For Case B, the alternating vector $v=[1,0,1,0,1,0,1,0]$ encodes to $R=85$ because $85$ has ones at even bit positions $k\\in\\{0,2,4,6\\}$. The decoding tests reconstruct vectors from given $R$: Case C with $R=30$ yields $v$ equal to the bits of $30$ at positions $k=0,1,\\dots,7$, which is $[0,1,1,1,1,0,0,0]$ because $30=2+4+8+16$. Case D with $R=255$ yields the all-ones vector $[1,1,1,1,1,1,1,1]$. The simulation tests validate dynamics under periodic boundary conditions and special cases: Case E explores nontrivial growth for $R=110$ starting from a single $1$ on a lattice of length $L=15$ for $T=10$ steps; Case F tests the boundary edge with $L=1$ and $R=0$, guaranteeing eventual extinction so the final count is $0$ after any positive number of steps; Case G tests the $T=0$ path where the final configuration is the initial one and the counted ones should equal the initial sum, which is $1$ for $[1,0]$.\n\nFinal output format. The program aggregates the seven results in a single Python-style list printed on one line with comma-separated elements and no spaces, adhering to the format requirement. The elements are, in order: the two encoded integers for Cases A and B, the two decoded vectors for Cases C and D, and the three integers equal to the counts of ones after simulation for Cases E, F, and G.",
            "answer": "[150,85,[0,1,1,1,1,0,0,0],[1,1,1,1,1,1,1,1],15,0,1]"
        },
        {
            "introduction": "A single simulation reveals one possible trajectory, but the complete behavior of a finite system is captured by its state transition graph. This advanced practice  challenges you to map this entire landscape of possibilities, identifying limit cycles and their basins of attraction. This exercise moves beyond simple simulation to a holistic analysis of a system's emergent, long-term dynamics, a central task in the study of complex adaptive systems.",
            "id": "4267302",
            "problem": "Consider a one-dimensional, binary Elementary Cellular Automaton (ECA), defined on a ring of size $n$ with periodic boundary conditions. Each site $i \\in \\{0,1,\\dots,n-1\\}$ holds a state $x_i(t) \\in \\{0,1\\}$ at discrete time $t \\in \\mathbb{N}$. The local update rule depends only on the site and its nearest neighbors, forming a radius-$1$ neighborhood of width $3$: the triplet $\\left(x_{i-1}(t), x_i(t), x_{i+1}(t)\\right)$ with indices taken modulo $n$. The global update is synchronous.\n\nAdopt the standard Wolfram rule encoding for Elementary Cellular Automata (ECA), where a rule number $R \\in \\{0,1,\\dots,255\\}$ specifies the output bit for each neighborhood pattern. For a neighborhood pattern $\\left(b_2,b_1,b_0\\right) \\in \\{0,1\\}^3$, define the pattern index $p = 4 b_2 + 2 b_1 + b_0$. The local rule outputs $1$ if and only if the $p$-th bit of $R$ is $1$ (equivalently, if $\\left\\lfloor R / 2^p \\right\\rfloor \\bmod 2 = 1$), and otherwise outputs $0$. The global map $f_R:\\{0,1\\}^n \\to \\{0,1\\}^n$ applies the local rule at each site simultaneously under periodic boundary conditions.\n\nDefine the state transition graph for rule $R$ on ring size $n$ as the directed graph $G_{R,n}=(V,E)$ where $V=\\{0,1\\}^n$ and there is exactly one outgoing edge from each $x \\in V$ to $f_R(x)$. This is a functional graph. A limit cycle is a directed cycle in $G_{R,n}$. For any state $x \\in V$, define its transient length $\\tau(x)$ as the smallest nonnegative integer $t$ such that $f_R^t(x)$ lies on a limit cycle of $G_{R,n}$;\nequivalently, $\\tau(x)=0$ if $x$ lies on a limit cycle, and $\\tau(x)>0$ otherwise with $f_R^{\\tau(x)}(x)$ the first cycle state reached along the unique forward trajectory.\n\nStarting only from the foregoing fundamental definitions of ECA and functional graphs, write a complete program that, for each test case specified below, constructs the state transition graph implied by $f_R$ on $\\{0,1\\}^n$, and computes:\n- the number of distinct limit cycles;\n\n- the multiset of limit cycle lengths as a sorted list of integers;\n\n- the maximum transient length $\\max_{x \\in \\{0,1\\}^n} \\tau(x)$;\n\n- the average transient length $\\frac{1}{2^n} \\sum_{x \\in \\{0,1\\}^n} \\tau(x)$ expressed as a decimal float value.\n\nYour program must treat states as elements of $\\{0,1\\}^n$ under periodic boundary conditions, with the global map $f_R$ applied exactly as defined. Represent each state by a binary string of length $n$ or an equivalent representation that is logically identical.\n\nTest suite:\n- Case $1$: $R=0$, $n=5$.\n- Case $2$: $R=150$, $n=1$.\n- Case $3$: $R=90$, $n=10$.\n- Case $4$: $R=30$, $n=10$.\n- Case $5$: $R=110$, $n=8$.\n\nFor each test case, the required output is a list of the form $[C,L,M,A]$, where $C$ is the integer number of limit cycles, $L$ is the sorted list of cycle lengths (integers), $M$ is the integer maximum transient length, and $A$ is the average transient length as a float. Aggregate all test case results into a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[ [C_1,L_1,M_1,A_1], [C_2,L_2,M_2,A_2], \\dots \\right]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\text{result}_1,\\text{result}_2,\\text{result}_3 \\right]$). No physical units or angles are involved;\nall quantities are dimensionless. The final outputs for the test cases must be types among boolean, integer, float, or lists of these.",
            "solution": "The user's request is a well-defined computational problem in the domain of complex systems, specifically concerning one-dimensional Elementary Cellular Automata (ECA). The problem is scientifically grounded, logically consistent, and all terms and parameters are defined with sufficient rigor. The problem is validated as valid and a solution is therefore warranted.\n\nThe solution proceeds by first algorithmically constructing the state transition graph for a given rule $R$ and lattice size $n$, and then analyzing this graph to extract the required dynamical properties.\n\n### 1. System Representation and Graph Construction\n\nAn Elementary Cellular Automaton on a ring of size $n$ has a finite state space $V = \\{0,1\\}^n$ of size $|V| = 2^n$. We can establish a bijective mapping between the binary strings of length $n$ and the integers in the set $\\{0, 1, \\dots, 2^n-1\\}$. A state $x = (x_{n-1}, \\dots, x_1, x_0)$ is identified with the integer $k = \\sum_{i=0}^{n-1} x_i 2^i$.\n\nThe global update map $f_R: \\{0,1\\}^n \\to \\{0,1\\}^n$ is deterministic. It defines a directed graph $G_{R,n}=(V,E)$, known as a functional graph, where the vertices are the $2^n$ possible states and the edges are given by $E = \\{(k, f_R(k)) \\mid k \\in V\\}$. In this graph, every vertex has exactly one outgoing edge.\n\nThe first step of the algorithm is to construct this graph explicitly. This is achieved by creating a successor array, which we can denote as `successors`, of size $2^n$. For each state integer $k \\in \\{0, 1, \\dots, 2^n-1\\}$, we compute its image $f_R(k)$ and store it at index $k$ of the array.\n\nThe computation of $f_R(k)$ involves applying the local rule at each site $i \\in \\{0, \\dots, n-1\\}$ simultaneously. For a given site $i$, its state is $x_i = (k \\gg i) \\land 1$. Due to the periodic boundary conditions, the states of its neighbors are $x_{i-1} = (k \\gg ((i-1+n) \\pmod n)) \\land 1$ and $x_{i+1} = (k \\gg ((i+1) \\pmod n)) \\land 1$.\n\nThe local neighborhood state $(x_{i-1}, x_i, x_{i+1})$ is interpreted as a $3$-bit number, forming the pattern index $p = 4x_{i-1} + 2x_i + x_{i+1}$. The new state for site $i$, denoted $x'_i$, is given by the $p$-th bit of the rule number $R$, which can be extracted via the bitwise operation $(R \\gg p) \\land 1$.\n\nThe new global state $k' = f_R(k)$ is the integer representation of the new configuration $(x'_{n-1}, \\dots, x'_1, x'_0)$, calculated as $k' = \\sum_{i=0}^{n-1} x'_i 2^i$. This procedure is repeated for all $k \\in \\{0, 1, \\dots, 2^n-1\\}$ to fully populate the `successors` array.\n\n### 2. Graph Traversal for Cycle and Transient Analysis\n\nThe structure of a finite functional graph is a collection of disjoint components. Each component consists of a single directed cycle with one or more directed trees whose paths terminate on the cycle's vertices. The task is to identify these components and characterize their structure. Specifically, we need to find all cycles and the transient paths leading to them.\n\nWe employ a graph traversal algorithm. An auxiliary array, `transient_lengths`, of size $2^n$ is used to store the transient length $\\tau(k)$ for each state $k$. This array is initialized with a sentinel value (e.g., $-1$) to indicate that a state has not yet been visited and analyzed.\n\nThe algorithm iterates through each state $s \\in \\{0, \\dots, 2^n-1\\}$. If $s$ has already been visited (i.e., `transient_lengths[s]` is not the sentinel value), it is part of a component that has already been analyzed, so we skip it. Otherwise, we initiate a traversal starting from $s$.\n\nThe traversal follows the unique path $s, f_R(s), f_R^2(s), \\dots$ by repeatedly applying the `successors` mapping. During the traversal, we record the sequence of visited states in an ordered list, `path`, and also use a hash map, `path_map`, to store each state in the current path and its step number (distance from $s$). This allows for efficient detection of revisited states.\n\nThe traversal terminates when it encounters a state `curr_node` that has either been seen before in the current path (`curr_node` is in `path_map`) or has already been analyzed in a previous traversal (`transient_lengths[curr_node]` is not the sentinel).\n\n1.  **New Cycle Detected**: If `curr_node` is found in `path_map`, a new cycle has been discovered. The states on the path from the first occurrence of `curr_node` to the end of the path form this cycle. The length of the cycle is the difference between the current step number and the step number at which `curr_node` was first encountered. The states that appeared in the path before the cycle starts form a transient path leading to it. For each state $k$ on this transient path, its transient length $\\tau(k)$ is its distance to the start of the cycle. For all states $k$ within the cycle, $\\tau(k)=0$. The lengths are recorded, and the cycle is added to our collection of discovered cycles.\n\n2.  **Path to Known Component Detected**: If the traversal encounters a state `curr_node` whose transient length $\\tau(\\text{curr\\_node})$ is already known, the current path is a transient feeding into a previously analyzed component. We can then compute the transient lengths for all states in the current path by working backward from `curr_node`. For each state $k$ in the path, its transient length is given by the recursive relation $\\tau(k) = 1 + \\tau(f_R(k))$.\n\nThis process continues until every state in the space $\\{0, \\dots, 2^n-1\\}$ has been visited and its transient length computed.\n\n### 3. Final Metric Calculation\n\nAfter the traversal algorithm completes, all necessary information has been gathered. The final metrics are computed as follows:\n\n-   **Number of cycles ($C$)**: This is the total count of unique cycles discovered during the traversal.\n-   **Cycle lengths ($L$)**: This is the multiset of the lengths of all discovered cycles, presented as a sorted list of integers.\n-   **Maximum transient length ($M$)**: This is the maximum value found in the populated `transient_lengths` array, $\\max_{k \\in V} \\tau(k)$.\n-   **Average transient length ($A$)**: This is the arithmetic mean of all transient lengths, calculated as $\\frac{1}{2^n} \\sum_{k=0}^{2^n-1} \\tau(k)$.\n\nThis comprehensive, two-phase approach guarantees the correct and complete characterization of the state transition graph for any given ECA rule $R$ and size $n$, within computational limits.",
            "answer": "[[1,[1],1,0.96875],[2,[1,1],0,0.0],[4,[2,2,4,4],8,3.203125],[2,[2,88],10,3.3125],[5,[2,2,6,12,30],5,1.75]]"
        }
    ]
}