{
    "hands_on_practices": [
        {
            "introduction": "The smoothing kernel is the heart of the Smoothed-Particle Hydrodynamics (SPH) method, acting as the weighting function that interpolates properties among neighboring particles. To ensure that fundamental physical quantities like mass are conserved, the kernel must satisfy a normalization condition. This analytical exercise  takes you back to first principles, requiring you to derive the normalization constant for a commonly used kernel, solidifying your understanding of the mathematical foundations upon which the entire SPH framework is built.",
            "id": "3994546",
            "problem": "In Smoothed-Particle Hydrodynamics (SPH), a kernel function $W(\\mathbf{r},h)$ of smoothing length $h$ must satisfy the normalization condition $\\int_{\\mathbb{R}^{3}} W(\\mathbf{r},h)\\,d\\mathbf{r} = 1$ to preserve mass and ensure consistency of the interpolation operator. Consider the isotropic $3$-dimensional cubic spline kernel with compact support of radius $2h$. Let $r = \\|\\mathbf{r}\\|$ and $q = r/h$. The kernel is defined by\n$$\nW(r,h) = \\frac{\\alpha}{h^{3}}\\,w(q),\n$$\nwhere the dimensionless function $w(q)$ is given piecewise by\n$$\nw(q) = \n\\begin{cases}\n1 - \\frac{3}{2}q^{2} + \\frac{3}{4}q^{3},  0 \\le q  1 \\\\\n\\frac{1}{4}(2 - q)^{3},  1 \\le q  2 \\\\\n0,  q \\ge 2\n\\end{cases}\n$$\nStarting from the normalization requirement and first principles (coordinate transformations and radial symmetry), derive the value of the normalization constant $\\alpha$ such that $\\int_{\\mathbb{R}^{3}} W(\\mathbf{r},h)\\,d\\mathbf{r} = 1$. Provide the final value of $\\alpha$ as a single closed-form analytic expression. No rounding is required, and no units are associated with $\\alpha$.",
            "solution": "The goal is to find the normalization constant $\\alpha$ by enforcing the condition that the integral of the kernel over all of 3D space is unity.\n$$\n\\int_{\\mathbb{R}^3} W(\\mathbf{r}, h) dV = 1\n$$\nSubstitute the definition of the kernel $W(\\mathbf{r}, h) = \\frac{\\alpha}{h^3} w(q)$, where $q = \\|\\mathbf{r}\\|/h$:\n$$\n\\int_{\\mathbb{R}^3} \\frac{\\alpha}{h^3} w(\\|\\mathbf{r}\\|/h) dV = 1\n$$\nTo evaluate the integral over $\\mathbb{R}^3$, we switch to spherical coordinates. The volume element is $dV = 4\\pi r^2 dr$, where $r = \\|\\mathbf{r}\\|$. The integral becomes:\n$$\n\\frac{\\alpha}{h^3} \\int_0^\\infty w(r/h) 4\\pi r^2 dr = 1\n$$\nWe perform a change of variables from $r$ to the dimensionless distance $q=r/h$. This implies $r = qh$ and $dr = h dq$. The integration limits change accordingly. Since the kernel has compact support up to $r=2h$, the upper limit for $q$ is 2.\n$$\n\\frac{4\\pi\\alpha}{h^3} \\int_0^2 w(q) (qh)^2 (h dq) = 1\n$$\n$$\n\\frac{4\\pi\\alpha}{h^3} \\int_0^2 w(q) q^2 h^3 dq = 1\n$$\n$$\n4\\pi\\alpha \\int_0^2 q^2 w(q) dq = 1\n$$\nNow we must evaluate the integral $I = \\int_0^2 q^2 w(q) dq$. The function $w(q)$ is piecewise, so we split the integral:\n$$\nI = \\int_0^1 q^2 \\left(1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3\\right) dq + \\int_1^2 q^2 \\left(\\frac{1}{4}(2-q)^3\\right) dq\n$$\nLet's calculate the first part, $I_1$:\n$$\nI_1 = \\int_0^1 \\left(q^2 - \\frac{3}{2}q^4 + \\frac{3}{4}q^5\\right) dq = \\left[\\frac{q^3}{3} - \\frac{3q^5}{10} + \\frac{3q^6}{24}\\right]_0^1 = \\frac{1}{3} - \\frac{3}{10} + \\frac{1}{8}\n$$\n$$\nI_1 = \\frac{40 - 36 + 15}{120} = \\frac{19}{120}\n$$\nNow let's calculate the second part, $I_2$. We use the substitution $u=2-q$, which means $q=2-u$ and $dq=-du$. The limits change: $q=1 \\implies u=1$ and $q=2 \\implies u=0$.\n$$\nI_2 = \\int_1^2 \\frac{1}{4} q^2 (2-q)^3 dq = \\int_1^0 \\frac{1}{4} (2-u)^2 u^3 (-du) = \\frac{1}{4} \\int_0^1 (4 - 4u + u^2) u^3 du\n$$\n$$\nI_2 = \\frac{1}{4} \\int_0^1 (4u^3 - 4u^4 + u^5) du = \\frac{1}{4} \\left[u^4 - \\frac{4}{5}u^5 + \\frac{1}{6}u^6\\right]_0^1 = \\frac{1}{4} \\left(1 - \\frac{4}{5} + \\frac{1}{6}\\right)\n$$\n$$\nI_2 = \\frac{1}{4} \\left(\\frac{30 - 24 + 5}{30}\\right) = \\frac{1}{4} \\left(\\frac{11}{30}\\right) = \\frac{11}{120}\n$$\nThe total integral is the sum of the two parts:\n$$\nI = I_1 + I_2 = \\frac{19}{120} + \\frac{11}{120} = \\frac{30}{120} = \\frac{1}{4}\n$$\nFinally, we substitute this result back into the normalization equation:\n$$\n4\\pi\\alpha \\left(\\frac{1}{4}\\right) = 1\n$$\n$$\n\\pi\\alpha = 1\n$$\n$$\n\\alpha = \\frac{1}{\\pi}\n$$",
            "answer": "$$\n\\boxed{\\frac{1}{\\pi}}\n$$"
        },
        {
            "introduction": "Moving from theory to practice, the next step in SPH is to accurately approximate spatial derivatives, which are essential for solving the governing equations of fluid dynamics. This computational exercise  challenges you to implement a discrete SPH gradient operator and test its accuracy using the Method of Manufactured Solutions. By measuring the convergence rate of your approximation, you will gain practical skills in numerical verification and a deeper appreciation for the factors that influence the accuracy of SPH simulations.",
            "id": "3994498",
            "problem": "Consider the manufactured vector field $\\mathbf{v}(x,y) = (x^2, y^2)$ defined on the unit square domain $[0,1] \\times [0,1]$. In Smoothed-Particle Hydrodynamics (SPH), the continuous field is represented by particles of uniform mass and density. Let the particle layout be a uniform Cartesian grid with spacing $\\Delta x$ in both directions, uniform density $\\rho = 1$ (nondimensional), and particle mass $m = \\Delta x^2$. The smoothing length is $h = \\alpha \\Delta x$, where $\\alpha$ is a positive constant. Use the classical cubic spline SPH kernel in two spatial dimensions with compact support $2h$, given by\n$$\nW(q;h) =\n\\begin{cases}\n\\dfrac{\\sigma}{h^2} \\left(1 - \\dfrac{3}{2} q^2 + \\dfrac{3}{4} q^3 \\right),  0 \\le q  1, \\\\\n\\dfrac{\\sigma}{h^2} \\left(\\dfrac{1}{4} (2 - q)^3 \\right),  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\nwith $q = r/h$, $r = \\|\\mathbf{r}\\|$, and normalization constant $\\sigma = \\dfrac{10}{7\\pi}$ for two dimensions. The kernel gradient is $\\nabla W(\\mathbf{r};h) = \\dfrac{\\partial W}{\\partial r} \\dfrac{\\mathbf{r}}{r}$, where $\\dfrac{\\partial W}{\\partial r} = \\dfrac{\\sigma}{h^3} \\dfrac{d \\Phi}{d q}(q)$ and\n$$\n\\dfrac{d \\Phi}{d q}(q) =\n\\begin{cases}\n-3 q + \\dfrac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\dfrac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\nStart from the continuous SPH interpolation perspective that a scalar field $f(\\mathbf{x})$ can be approximated by a kernel-weighted integral and its gradient by differentiating under the integral sign. Use this fundamental base to derive a consistent discrete SPH gradient operator for each scalar component of $\\mathbf{v}$, expressed in terms of particle masses, densities, and kernel gradients. Implement your derived discrete operator to approximate the Jacobian matrix $\\nabla \\mathbf{v}$ component-wise at particle locations.\n\nTo avoid boundary truncation of the kernel support, restrict error evaluation to the set of \"interior\" particles whose distance from every domain boundary is at least $2h$. For each interior particle at position $(x_i,y_i)$, compute the approximate Jacobian\n$$\n\\nabla \\mathbf{v}(\\mathbf{x}_i) \\approx\n\\begin{pmatrix}\n\\partial_x (x^2)  \\partial_y (x^2) \\\\\n\\partial_x (y^2)  \\partial_y (y^2)\n\\end{pmatrix}_{\\text{SPH}},\n$$\nand compare it to the exact Jacobian\n$$\n\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) =\n\\begin{pmatrix}\n2x_i  0 \\\\\n0  2y_i\n\\end{pmatrix}.\n$$\nMeasure the error at each interior particle by the Frobenius norm of the difference between the approximate and exact Jacobians, and aggregate the error over all interior particles by the root-mean-square (RMS)\n$$\nE(\\Delta x, \\alpha) = \\sqrt{\\dfrac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} \\left\\| \\nabla \\mathbf{v}_{\\text{SPH}}(\\mathbf{x}_i) - \\nabla \\mathbf{v}_{\\text{exact}}(\\mathbf{x}_i) \\right\\|_F^2 },\n$$\nwhere $N_{\\text{int}}$ is the number of interior particles. For a fixed $\\alpha$, assess convergence of the SPH gradient approximation as $\\Delta x$ decreases by fitting a line to $(\\log \\Delta x, \\log E)$ and extracting the slope $p$, which serves as the observed order of accuracy defined by $E \\propto (\\Delta x)^p$.\n\nImplement the program to compute $E$ for each $\\Delta x$ in the following test suites and report the observed order $p$ for each suite using least-squares regression over all provided $\\Delta x$ values:\n\n- Test Case 1 (happy path): $\\alpha = 1.0$, $\\Delta x \\in \\{0.2, 0.1, 0.05\\}$.\n- Test Case 2 (kernel variation): $\\alpha = 0.8$, $\\Delta x \\in \\{0.2, 0.1, 0.05\\}$.\n- Test Case 3 (boundary-limited interior, edge case): $\\alpha = 1.0$, $\\Delta x \\in \\{0.25, 0.125, 0.0625\\}$.\n\nAll computations are nondimensional. Angles do not appear in this problem, so no angle unit is required. Your program should produce a single line of output containing the three observed orders as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places (e.g., \"[p1,p2,p3]\").",
            "solution": "The problem is subjected to validation and is found to be valid. It is scientifically grounded in the principles of Smoothed-Particle Hydrodynamics (SPH), a standard numerical method. The problem is well-posed, providing all necessary definitions, constants, and parameters to compute a unique, meaningful result. The language is objective and unambiguous, and the setup is internally consistent.\n\nThe core of the task is to derive and implement a discrete SPH gradient operator to approximate the Jacobian of a given vector field and to subsequently assess the numerical convergence of this approximation.\n\n**1. Derivation of the SPH Gradient Operator**\n\nThe SPH methodology begins with the continuous integral representation of a scalar field $f(\\mathbf{x})$ using a smoothing kernel $W$ with a characteristic smoothing length $h$:\n$$\nf(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\nThe gradient of this field, $\\nabla f(\\mathbf{x})$, is found by applying the gradient operator to the integral representation. Assuming the field $f$ and kernel $W$ are sufficiently well-behaved, the differentiation can be moved inside the integral:\n$$\n\\nabla f(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\nwhere $\\nabla_{\\mathbf{x}}$ denotes the gradient with respect to the coordinates $\\mathbf{x}$.\n\nTo transition to a discrete particle-based formulation, the domain $\\Omega$ is represented by a set of particles. The integral is replaced by a summation over these particles. Each particle $j$, located at position $\\mathbf{x}_j$, has a mass $m_j$ and density $\\rho_j$. Its associated volume element is $d\\mathbf{x}' \\approx V_j = m_j/\\rho_j$. The gradient at the position of particle $i$, $\\mathbf{x}_i$, is thus approximated by the summation:\n$$\n\\nabla f(\\mathbf{x}_i) \\approx \\sum_j f(\\mathbf{x}_j) \\nabla_i W(\\mathbf{x}_i - \\mathbf{x}_j, h) V_j\n$$\nwhere $\\nabla_i W_{ij} \\equiv \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h)|_{\\mathbf{x}=\\mathbf{x}_i, \\mathbf{x}'=\\mathbf{x}_j}$.\n\nThe problem requires the derivation of a \"consistent\" discrete operator. A fundamental consistency requirement is that the gradient of a constant field must be zero. The direct discretization shown above does not guarantee this property. A more robust formulation is obtained using the product rule identity $\\nabla f = \\frac{1}{\\rho} \\nabla(\\rho f) - \\frac{f}{\\rho} \\nabla \\rho$. Applying the SPH discretization to the gradients of $\\rho f$ and $\\rho$ leads to:\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\left( \\sum_j (\\rho_j f_j) \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right) - \\frac{f_i}{\\rho_i} \\left( \\sum_j \\rho_j \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right)\n$$\nSimplifying and combining the sums gives the \"difference form\" of the SPH gradient operator:\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\sum_j m_j (f_j - f_i) \\nabla_i W_{ij}\n$$\nThis form inherently satisfies the condition that the gradient of a constant field ($f_j = f_i$) is exactly zero. As the problem specifies a uniform density $\\rho=1$ and uniform particle mass $m = \\Delta x^2$, the operator we will implement is:\n$$\n\\nabla f_i = \\sum_j m \\left( f_j - f_i \\right) \\nabla_i W_{ij}\n$$\nwhere the sum is over all neighboring particles $j$ within the kernel's support radius of particle $i$.\n\n**2. Jacobian Matrix Approximation**\n\nThe Jacobian matrix of the vector field $\\mathbf{v}(x,y) = (v_x, v_y)$ is given by $\\nabla \\mathbf{v} = \\begin{pmatrix} \\partial_x v_x  \\partial_y v_x \\\\ \\partial_x v_y  \\partial_y v_y \\end{pmatrix}$. Each component of this matrix is the partial derivative of a scalar field, which we approximate using the SPH gradient operator derived above. For a particle $i$, the SPH-approximated Jacobian is:\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}\n$$\nwhere $\\otimes$ denotes the outer product. This results in the matrix:\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m\n\\begin{pmatrix}\n(v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial y_i} \\\\\n(v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial y_i}\n\\end{pmatrix}\n$$\nFor the given field $\\mathbf{v}(x,y) = (x^2, y^2)$, we have $v_x = x^2$ and $v_y = y^2$.\n\nThe kernel gradient $\\nabla_i W_{ij}$ is calculated using the provided formula $\\nabla W(\\mathbf{r};h) = \\frac{\\partial W}{\\partial r} \\frac{\\mathbf{r}}{r}$, where $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_j$. Let $r_{ij} = \\|\\mathbf{r}\\|$.\n$$\n\\nabla_i W_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} \\frac{\\partial W}{\\partial r}(r_{ij}; h) = \\frac{\\mathbf{x}_i - \\mathbfx_j}{r_{ij}} \\left( \\frac{\\sigma}{h^3} \\frac{d\\Phi}{dq}(q_{ij}) \\right)\n$$\nwith $q_{ij} = r_{ij}/h$, $\\sigma = 10/(7\\pi)$, and $\\frac{d\\Phi}{dq}$ given by the piecewise function in the problem statement.\n\n**3. Algorithmic Procedure**\n\nThe overall algorithm to compute the error and convergence order is as follows:\n\n1.  **Particle Generation**: For a given spacing $\\Delta x$, create a uniform Cartesian grid of particles over the domain $[0,1] \\times [0,1]$. Particle positions are $\\mathbf{x}_{k,l} = (k \\Delta x, l \\Delta x)$ for integers $k,l$ such that the domain is covered.\n\n2.  **Identify Interior Particles**: The analysis is restricted to \"interior\" particles to avoid errors from kernel truncation at the boundaries. A particle at position $(x_i, y_i)$ is interior if its distance to all four boundaries ($x=0, x=1, y=0, y=1$) is at least the kernel support radius, $2h$. That is, $x_i \\in [2h, 1-2h]$ and $y_i \\in [2h, 1-2h]$, where $h=\\alpha \\Delta x$.\n\n3.  **Jacobian and Error Calculation**:\n    For each interior particle $i$:\n    a. Initialize the SPH Jacobian matrix $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$ to zeros.\n    b. Iterate through all other particles $j$ to find neighbors. A particle $j$ is a neighbor if the distance $r_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$ is in the range $(0, 2h)$. The condition $r_{ij}  0$ excludes the particle itself.\n    c. For each neighbor $j$, calculate the kernel gradient $\\nabla_i W_{ij}$ and the vector field difference $\\mathbf{v}_j - \\mathbf{v}_i$.\n    d. Compute the contribution to the Jacobian, $m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}$, and add it to $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$.\n    e. After summing over all neighbors, calculate the exact Jacobian at $\\mathbf{x}_i$: $\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) = \\begin{pmatrix} 2x_i  0 \\\\ 0  2y_i \\end{pmatrix}$.\n    f. Compute the squared Frobenius norm of the error matrix: $E_i^2 = \\| (\\nabla \\mathbf{v}_{\\text{SPH}})_i - (\\nabla \\mathbf{v}_{\\text{exact}})_i \\|_F^2$.\n\n4.  **Aggregate RMS Error**: Sum the squared errors over all $N_{\\text{int}}$ interior particles and compute the Root-Mean-Square (RMS) error:\n    $$\n    E(\\Delta x, \\alpha) = \\sqrt{\\frac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} E_i^2}\n    $$\n\n5.  **Convergence Order Analysis**: For each test suite, we obtain a set of error values $E$ corresponding to a set of grid spacings $\\Delta x$. The order of accuracy, $p$, is defined by the relationship $E \\propto (\\Delta x)^p$. Taking the logarithm of both sides gives $\\log E = p \\log \\Delta x + C$. Thus, $p$ is the slope of a line fitted to the data points $(\\log \\Delta x, \\log E)$. This slope is computed using linear least-squares regression for each test case.\n\nThe implementation will follow this procedure for each of the three test cases specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to execute the SPH convergence study as per the problem statement.\n    \"\"\"\n\n    test_cases = [\n        {\"alpha\": 1.0, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 0.8, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 1.0, \"dx_values\": [0.25, 0.125, 0.0625]},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        dx_values = case[\"dx_values\"]\n        \n        errors = []\n        \n        for dx in dx_values:\n            error = compute_rms_error(dx, alpha)\n            errors.append(error)\n\n        log_dx = np.log(dx_values)\n        log_E = np.log(errors)\n        \n        # Perform linear regression to find the slope (order of accuracy)\n        slope, _, _, _, _ = stats.linregress(log_dx, log_E)\n        orders_of_accuracy.append(slope)\n\n    # Format the final output\n    formatted_results = [f\"{p:.6f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef get_dPhi_dq(q):\n    \"\"\"\n    Computes the derivative of the cubic spline kernel shape function Phi w.r.t. q.\n    \"\"\"\n    if 0.0 = q  1.0:\n        return -3.0 * q + 2.25 * q**2\n    elif 1.0 = q  2.0:\n        return -0.75 * (2.0 - q)**2\n    else:\n        return 0.0\n\ndef compute_rms_error(dx, alpha):\n    \"\"\"\n    Computes the RMS error of the SPH Jacobian approximation for a given dx and alpha.\n    \"\"\"\n    h = alpha * dx\n    m = dx**2\n    sigma = 10.0 / (7.0 * np.pi)\n    support_radius = 2.0 * h\n\n    # Generate particle grid\n    # Add a small epsilon to the range to ensure the endpoint 1.0 is included\n    coords = np.arange(0, 1.0 + dx/2, dx)\n    x_coords, y_coords = np.meshgrid(coords, coords)\n    particles = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n    \n    # Identify interior particles\n    interior_mask = (particles[:, 0] = support_radius)  \\\n                    (particles[:, 0] = 1.0 - support_radius)  \\\n                    (particles[:, 1] = support_radius)  \\\n                    (particles[:, 1] = 1.0 - support_radius)\n    \n    interior_indices = np.where(interior_mask)[0]\n    \n    if len(interior_indices) == 0:\n        # This can happen if 2h  0.5. The problem setup avoids this.\n        # It's good practice to handle it.\n        return np.nan\n        \n    total_squared_frobenius_norm = 0.0\n\n    for i in interior_indices:\n        xi = particles[i]\n        vi = xi**2  # Vector (xi^2, yi^2)\n        \n        sph_jacobian = np.zeros((2, 2))\n        \n        # Loop over all other particles to find neighbors\n        for j in range(len(particles)):\n            # Exclude self-interaction\n            if i == j:\n                continue\n\n            r_vec = xi - particles[j]\n            r_norm = np.linalg.norm(r_vec)\n\n            if 0.0  r_norm  support_radius:\n                q = r_norm / h\n                dPhi_dq_val = get_dPhi_dq(q)\n                \n                # Grad W_ij = (r_vec / r_norm) * (sigma / h^3) * dPhi_dq\n                # This can be rewritten to avoid division by r_norm if r_norm is very small\n                # but for this problem, r_norm is always = dx, which is safe.\n                grad_W_factor = (sigma / (h**3 * r_norm)) * dPhi_dq_val\n                grad_W = r_vec * grad_W_factor\n\n                vj = particles[j]**2\n                v_diff = vj - vi\n                \n                # Accumulate Jacobian contribution: m * outer(v_diff, grad_W)\n                sph_jacobian += m * np.outer(v_diff, grad_W)\n\n        # Exact Jacobian at xi\n        exact_jacobian = np.array([[2.0 * xi[0], 0.0], [0.0, 2.0 * xi[1]]])\n        \n        # Error matrix\n        error_matrix = sph_jacobian - exact_jacobian\n        \n        # Squared Frobenius norm\n        total_squared_frobenius_norm += np.sum(error_matrix**2)\n\n    # RMS Error\n    rms_error = np.sqrt(total_squared_frobenius_norm / len(interior_indices))\n    return rms_error\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "While powerful, the standard SPH method faces challenges in certain complex applications, particularly in multiphase flows with large density ratios, such as the interface between air and water. This scenario often produces unphysical pressure oscillations that can compromise simulation stability and accuracy. This hands-on practice  guides you through a numerical investigation of this important phenomenon, providing critical insight into the limitations of the basic summation density approach and highlighting why advanced SPH formulations are often necessary for tackling real-world multiphysics problems.",
            "id": "3194363",
            "problem": "You are asked to examine pressure oscillations at a material interface in a simplified one-dimensional smoothed-particle hydrodynamics (SPH) setting with a large density ratio, as a proxy for the air–water problem. Start from conservation of mass and the definition of kernel-based interpolation in SPH, and from a compressible equation of state with a pressure shift to enforce a common ambient pressure. Use these principles to design, implement, and execute a program that quantifies the spurious pressure oscillations across the interface caused by the summation density in a static, two-fluid configuration.\n\nBase assumptions and definitions to use, which are well-established in the literature and serve as the starting point:\n\n- Conservation of mass under particle discretization implies the SPH summation density at particle index $i$ is\n$$\n\\rho_i \\;=\\; \\sum_{j} m_j \\, W\\!\\left(\\lvert x_i - x_j \\rvert, h\\right),\n$$\nwhere $x_i$ is position, $m_j$ is particle mass, $h$ is the smoothing length, and $W$ is the smoothing kernel.\n\n- Use the standard one-dimensional cubic spline kernel $W(r,h)$ with $q = r/h$ given by\n$$\nW(r,h) \\;=\\;\n\\begin{cases}\n\\dfrac{1}{h}\\left(\\dfrac{2}{3} - q^2 + \\dfrac{1}{2}q^3\\right),  0 \\le q  1 \\\\\n\\dfrac{1}{6h}\\left(2 - q\\right)^3,  1 \\le q  2 \\\\\n0,  q \\ge 2\n\\end{cases}\n$$\n\n- Use a Tait-type equation of state with a pressure shift to impose a common ambient pressure $p_0$, namely\n$$\np_i \\;=\\; p_0 \\;+\\; B_i \\left[\\left(\\dfrac{\\rho_i}{\\rho_{0,i}}\\right)^{\\gamma_i} - 1\\right],\n$$\nwith\n$$\nB_i \\;=\\; \\dfrac{c_0^2 \\, \\rho_{0,i}}{\\gamma_i},\n$$\nwhere $\\rho_{0,i}$ is the rest density of the phase at particle $i$, $\\gamma_i$ is the polytropic exponent of that phase, and $c_0$ is a chosen artificial speed of sound such that $\\left.\\dfrac{\\partial p}{\\partial \\rho}\\right|_{\\rho=\\rho_{0,i}} = c_0^2$.\n\nScenario:\n\n- Consider a one-dimensional domain of length $L$ in meters with a uniform grid of $N$ particles at positions $x_i$ covering $[0,L]$ with spacing $\\Delta x = L/(N-1)$. Place an interface at $x = L/2$. Particles with $x_i  L/2$ belong to phase A (“water-like”), and particles with $x_i \\ge L/2$ belong to phase B (“air-like”).\n\n- Assign rest densities $\\rho_{0,\\mathrm{w}}$ for phase A and $\\rho_{0,\\mathrm{a}}$ for phase B. Assign polytropic exponents $\\gamma_{\\mathrm{w}}$ and $\\gamma_{\\mathrm{a}}$. Use a single artificial speed of sound $c_0$ for both phases. The ambient pressure is $p_0$ in Pascals.\n\n- Set particle masses by $m_i = \\rho_{0,i} \\, \\Delta x$ so that the discrete mass corresponds to the phase’s rest density and uniform spacing.\n\n- Compute the summation density $\\rho_i$ using the kernel above and then the pressure $p_i$ using the stated equation of state.\n\n- Define an “interface window” set $\\mathcal{S} = \\{ i \\,:\\, \\lvert x_i - L/2 \\rvert \\le 3h \\}$, where $h$ is the smoothing length used in the kernel. Measure the oscillation amplitude within this window as\n$$\nE \\;=\\; \\max_{i \\in \\mathcal{S}} \\left\\lvert p_i - p_0 \\right\\rvert.\n$$\n\n- Report the dimensionless quantity $E/p_0$ as the robustness metric for each test case.\n\nConstants to use in all test cases:\n\n- Domain length $L = 1\\,\\mathrm{m}$.\n- Number of particles $N = 201$.\n- Ambient pressure $p_0 = 100000\\,\\mathrm{Pa}$.\n- Artificial speed of sound $c_0 = 50\\,\\mathrm{m/s}$.\n- Polytropic exponent for phase A (“water-like”) $\\gamma_{\\mathrm{w}} = 7$.\n- Polytropic exponent for phase B (“air-like”) $\\gamma_{\\mathrm{a}} = 1.4$.\n\nTest suite:\n\nEach test case is specified by $(\\rho_{0,\\mathrm{w}}, \\rho_{0,\\mathrm{a}}, \\alpha)$, where $h = \\alpha \\,\\Delta x$.\n\n- Case $1$ (happy path, moderate density ratio): $(1000,\\,100,\\,1.2)$.\n- Case $2$ (large density ratio): $(1000,\\,1,\\,1.2)$.\n- Case $3$ (edge case, minimal smoothing): $(1000,\\,1,\\,1.0)$.\n- Case $4$ (edge case, heavy smoothing): $(1000,\\,1,\\,2.0)$.\n\nWhat to implement:\n\n- Discretize the domain and assign particle properties as above.\n- Implement the one-dimensional cubic spline kernel exactly as stated.\n- Compute $\\rho_i$ via summation density and then $p_i$ via the equation of state.\n- Compute $E/p_0$ within the interface window for each test case.\n\nAngle units are not applicable. Express the final results as dimensionless decimal numbers, one per test case, in the exact order listed above.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), where each $r_k$ is the computed $E/p_0$ for case $k$.",
            "solution": "We begin from conservation of mass and kernel-based interpolation, which in Smoothed-Particle Hydrodynamics (SPH) yields the summation density for particle index $i$:\n$$\n\\rho_i \\;=\\; \\sum_{j} m_j \\, W\\!\\left(\\lvert x_i - x_j \\rvert, h\\right),\n$$\nwhere $m_j$ is the mass of particle $j$, $x_i$ denotes particle positions on the line, and $W$ is a smoothing kernel of compact support with smoothing length $h$. This expression is a discrete approximation to the convolution of the mass density with the kernel and follows from enforcing that mass is carried by particles and distributed by the kernel shape.\n\nFor the kernel, we use the standard one-dimensional cubic spline, defined by $q = r/h$,\n$$\nW(r,h) \\;=\\;\n\\begin{cases}\n\\dfrac{1}{h}\\left(\\dfrac{2}{3} - q^2 + \\dfrac{1}{2}q^3\\right),  0 \\le q  1 \\\\\n\\dfrac{1}{6h}\\left(2 - q\\right)^3,  1 \\le q  2 \\\\\n0,  q \\ge 2\n\\end{cases}\n$$\nThis kernel is non-negative, normalized, and compactly supported on $[0,2h)$, and is widely used due to good smoothness and accuracy properties.\n\nTo close the system and compute pressure from density in a weakly compressible formulation, we use a Tait-type equation of state with a pressure shift. The pressure shift ensures that both phases are initialized at a common ambient pressure $p_0$ when $\\rho_i = \\rho_{0,i}$. The Tait law reads\n$$\np_i \\;=\\; p_0 \\;+\\; B_i \\left[ \\left(\\dfrac{\\rho_i}{\\rho_{0,i}}\\right)^{\\gamma_i} - 1 \\right].\n$$\nThe coefficient $B_i$ is chosen so that the local compressibility is set by a common artificial speed of sound $c_0$:\n$$\n\\left.\\dfrac{\\partial p}{\\partial \\rho}\\right|_{\\rho = \\rho_{0,i}} \\;=\\; \\dfrac{B_i \\gamma_i}{\\rho_{0,i}} \\;=\\; c_0^2,\n\\quad\\Rightarrow\\quad\nB_i \\;=\\; \\dfrac{c_0^2 \\, \\rho_{0,i}}{\\gamma_i}.\n$$\nThis choice constrains density fluctuations and yields numerically manageable pressure changes for small deviations around $\\rho_{0,i}$.\n\nWe construct a one-dimensional domain of length $L$ with $N$ uniformly spaced particles at positions $x_i$ covering $[0,L]$ with spacing $\\Delta x = L/(N-1)$. We place the interface at $x=L/2$. Particles with $x_i  L/2$ are assigned to phase A (“water-like”) with rest density $\\rho_{0,\\mathrm{w}}$ and polytropic exponent $\\gamma_{\\mathrm{w}}$, and particles with $x_i \\ge L/2$ are assigned to phase B (“air-like”) with rest density $\\rho_{0,\\mathrm{a}}$ and polytropic exponent $\\gamma_{\\mathrm{a}}$. The masses are $m_i = \\rho_{0,i} \\, \\Delta x$, ensuring the discrete mass integrates the rest density. The smoothing length is chosen as $h = \\alpha \\Delta x$, with factor $\\alpha$ given per test case. The constants are $L=1\\,\\mathrm{m}$, $N=201$, $p_0=100000\\,\\mathrm{Pa}$, $c_0=50\\,\\mathrm{m/s}$, $\\gamma_{\\mathrm{w}}=7$, and $\\gamma_{\\mathrm{a}}=1.4$.\n\nThe algorithm is:\n- Compute positions $x_i$ for $i=1,\\dots,N$.\n- Determine phase membership for each $x_i$ relative to $L/2$ and assign $\\rho_{0,i}$ and $\\gamma_i$ accordingly.\n- Compute $m_i = \\rho_{0,i} \\Delta x$.\n- Form all pairwise distances $r_{ij} = \\lvert x_i - x_j \\rvert$.\n- Evaluate $W(r_{ij}, h)$ using the cubic spline definition. Because $W$ is zero beyond $2h$, the sum is effectively local, but for $N=201$ direct summation is efficient and simple.\n- Compute $\\rho_i = \\sum_j m_j W(r_{ij}, h)$ for all $i$.\n- Compute $B_i = c_0^2 \\rho_{0,i} / \\gamma_i$ and then $p_i = p_0 + B_i [ (\\rho_i/\\rho_{0,i})^{\\gamma_i} - 1 ]$.\n- Define the interface window $\\mathcal{S} = \\{ i : \\lvert x_i - L/2 \\rvert \\le 3h \\}$, which captures the region most affected by cross-phase kernel overlap.\n- Compute the oscillation amplitude $E = \\max_{i \\in \\mathcal{S}} \\lvert p_i - p_0 \\rvert$.\n- Report the dimensionless ratio $E/p_0$.\n\nScientific rationale:\n- The summation density is the discrete expression of mass conservation under kernel interpolation; deviations near discontinuities such as a material interface are expected because kernel averaging blends properties across the interface.\n- With very different particle masses $m_i$ implied by $\\rho_{0,\\mathrm{w}} \\gg \\rho_{0,\\mathrm{a}}$ and uniform $\\Delta x$, the density near the interface on the low-density side is dominated by contributions from the high-density side due to kernel support overlap. This leads to $\\rho_i \\gg \\rho_{0,\\mathrm{a}}$ and, through the Tait law, to $p_i \\gg p_0$ on the light-fluid side; conversely, on the heavy-fluid side next to the interface, $\\rho_i  \\rho_{0,\\mathrm{w}}$ may occur, producing $p_i  p_0$. The resulting $E$ quantifies these spurious oscillations.\n- The smoothing length $h$ affects the width of the averaging region. Small $h$ reduces cross-interface contamination but can under-resolve the kernel; large $h$ increases averaging and can exacerbate oscillations.\n\nTest coverage:\n- Case $1$ probes a moderate density ratio to establish a baseline response.\n- Case $2$ probes a very large density ratio, typical of air–water, to assess robustness.\n- Case $3$ reduces smoothing to the minimal scale $h=\\Delta x$ (narrow support) to examine edge behavior.\n- Case $4$ increases smoothing to $h=2\\Delta x$ (broad support) to test sensitivity to over-smoothing.\n\nThe program implements these definitions directly, ensuring reproducible and verifiable computation of $E/p_0$ for each test case, producing a single-line list output in the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cubic_spline_W(r, h):\n    \"\"\"\n    One-dimensional cubic spline kernel W(r,h).\n    q = r/h\n    W = (1/h)*(2/3 - q^2 + 0.5*q^3) for 0 = q  1\n        (1/(6h))*(2 - q)^3          for 1 = q  2\n        0                            otherwise\n    \"\"\"\n    q = r / h\n    W = np.zeros_like(q)\n    # Region 0 = q  1\n    mask1 = (q = 0)  (q  1)\n    q1 = q[mask1]\n    W[mask1] = (1.0 / h) * (2.0/3.0 - q1**2 + 0.5*q1**3)\n    # Region 1 = q  2\n    mask2 = (q = 1)  (q  2)\n    q2 = q[mask2]\n    W[mask2] = (1.0 / (6.0*h)) * (2.0 - q2)**3\n    return W\n\ndef compute_oscillation_ratio(rho_w, rho_a, h_factor,\n                              L=1.0, N=201, p0=100000.0, c0=50.0,\n                              gamma_w=7.0, gamma_a=1.4):\n    \"\"\"\n    Compute E/p0 for a static two-phase 1D SPH configuration:\n    - Phase A (\"water-like\"): x  L/2, rho0 = rho_w, gamma = gamma_w\n    - Phase B (\"air-like\"):   x = L/2, rho0 = rho_a, gamma = gamma_a\n    - Masses m_i = rho0_i * dx\n    - Smoothing length h = h_factor * dx\n    \"\"\"\n    # Discretize domain\n    x = np.linspace(0.0, L, N)\n    dx = x[1] - x[0]\n    h = h_factor * dx\n    interface_x = 0.5 * L\n\n    # Assign phase properties\n    is_water = x  interface_x\n    rho0 = np.where(is_water, rho_w, rho_a)\n    gamma = np.where(is_water, gamma_w, gamma_a)\n    m = rho0 * dx\n\n    # Pairwise distances\n    r = np.abs(x[:, None] - x[None, :])\n    # Kernel matrix\n    W = cubic_spline_W(r, h)\n    # Summation density\n    rho = W @ m\n\n    # Equation of state parameters and pressure\n    B = (c0**2) * rho0 / gamma\n    # Avoid division by zero in case rho0 has zeros (should not happen by construction)\n    ratio = rho / rho0\n    # Pressures\n    p = p0 + B * (np.power(ratio, gamma) - 1.0)\n\n    # Interface window: |x - L/2| = 3h\n    mask_window = np.abs(x - interface_x) = (3.0 * h)\n    if not np.any(mask_window):\n        # If window is empty due to extreme parameters, fall back to nearest-neighbor inclusion\n        # This is extremely unlikely for the given test suite.\n        nearest_idx = np.argmin(np.abs(x - interface_x))\n        mask_window = np.zeros_like(x, dtype=bool)\n        mask_window[nearest_idx] = True\n\n    E = np.max(np.abs(p[mask_window] - p0))\n    return E / p0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple is (rho_w, rho_a, h_factor)\n    test_cases = [\n        (1000.0, 100.0, 1.2),  # Case 1: moderate density ratio\n        (1000.0, 1.0,   1.2),  # Case 2: large density ratio\n        (1000.0, 1.0,   1.0),  # Case 3: minimal smoothing\n        (1000.0, 1.0,   2.0),  # Case 4: heavy smoothing\n    ]\n\n    results = []\n    for rho_w, rho_a, h_factor in test_cases:\n        result = compute_oscillation_ratio(\n            rho_w=rho_w,\n            rho_a=rho_a,\n            h_factor=h_factor,\n            L=1.0,\n            N=201,\n            p0=100000.0,\n            c0=50.0,\n            gamma_w=7.0,\n            gamma_a=1.4\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}