{
    "hands_on_practices": [
        {
            "introduction": "Before quantifying the impact of physical uncertainties, it is crucial to verify that our numerical simulation is trustworthy. This practice focuses on quantifying and systematically reducing the discretization error inherent in any CFD simulation. By performing a grid convergence study, you will derive and apply the method of Richardson extrapolation to estimate the grid-independent solution and the observed order of accuracy of your numerical scheme .",
            "id": "4002936",
            "problem": "Aerospace Computational Fluid Dynamics (CFD) simulations of compressible viscous flow around a two-dimensional airfoil are performed to estimate a scalar output quantity of engineering interest, denoted by $Q$, such as the lift coefficient. In the asymptotic grid-converged regime, the discretization error is modeled by the leading-order term of the truncation error so that the output on a grid of characteristic cell size $h$ obeys\n$$\nQ(h) \\;=\\; Q_{0} \\;+\\; C\\, h^{p},\n$$\nwhere $Q_{0}$ is the continuum (grid-independent) value, $C$ is an unknown constant dependent on the solution and scheme, and $p$ is the formal order of accuracy of the numerical method for the output $Q$.\n\nYou run the solver on three systematically refined, geometrically similar grids with characteristic sizes $h_{1} > h_{2} > h_{3}$ and a uniform refinement ratio $r$ such that $r = h_{1}/h_{2} = h_{2}/h_{3} > 1$. Denote the computed outputs $Q_{1} = Q(h_{1})$, $Q_{2} = Q(h_{2})$, and $Q_{3} = Q(h_{3})$.\n\nStarting only from the error model $Q(h) = Q_{0} + C\\, h^{p}$ and the definition of uniform refinement ratio $r$, perform the following:\n\n- Derive the Richardson extrapolation expression for $Q_{0}$ using two consecutive grid levels $h$ and $h/r$, expressed in terms of $Q(h)$, $Q(h/r)$, $p$, and $r$.\n- Derive a closed-form expression to estimate the order $p$ using the three grid levels $h_{1}$, $h_{2}$, $h_{3}$ and the corresponding outputs $Q_{1}$, $Q_{2}$, $Q_{3}$ and the known refinement ratio $r$.\n- Combine these results to obtain a closed-form expression for $Q_{0}$ in terms of $Q_{1}$, $Q_{2}$, and $Q_{3}$ alone, eliminating $C$ and $p$ explicitly.\n\nProvide your final answer as a single row matrix with entries $\\left[ Q_{0},\\, p \\right]$ written as closed-form analytic expressions in terms of $Q_{1}$, $Q_{2}$, $Q_{3}$, and $r$. Do not evaluate numerically. No rounding is required, and no units should be included in the final expressions.",
            "solution": "The problem statement has been critically examined and found to be valid. It is scientifically grounded in the well-established principles of numerical analysis, specifically the method of Richardson extrapolation for estimating discretization error in computational simulations. The problem is well-posed, objective, and provides all necessary information to perform the requested derivations. It contains no scientific flaws, ambiguities, or contradictions.\n\nThe analysis proceeds by algebraically manipulating the given error model, $Q(h) = Q_{0} + C h^{p}$, for the three specified grid levels.\n\nFirst, we address the derivation of the general Richardson extrapolation expression for the continuum value $Q_{0}$ using two solutions, $Q(h)$ and $Q(h/r)$, obtained on two grids with a refinement ratio $r$.\nThe error model provides two equations for these two grids:\n$$\nQ(h) = Q_{0} + C h^{p} \\quad (1)\n$$\n$$\nQ(h/r) = Q_{0} + C (h/r)^{p} = Q_{0} + \\frac{C h^{p}}{r^{p}} \\quad (2)\n$$\nOur goal is to eliminate the unknown term $C h^{p}$. From equation $(1)$, we can express this term as:\n$$\nC h^{p} = Q(h) - Q_{0}\n$$\nSubstituting this into equation $(2)$ yields:\n$$\nQ(h/r) = Q_{0} + \\frac{Q(h) - Q_{0}}{r^{p}}\n$$\nWe now solve this equation for $Q_{0}$. Multiplying through by $r^{p}$ gives:\n$$\nr^{p} Q(h/r) = r^{p} Q_{0} + Q(h) - Q_{0}\n$$\nRearranging the terms to isolate $Q_{0}$:\n$$\nr^{p} Q(h/r) - Q(h) = Q_{0} (r^{p} - 1)\n$$\nThis gives the Richardson extrapolation formula for $Q_{0}$:\n$$\nQ_{0} = \\frac{r^{p} Q(h/r) - Q(h)}{r^{p} - 1}\n$$\nThis expression can also be written as $Q_{0} = Q(h/r) + \\frac{Q(h/r) - Q(h)}{r^{p} - 1}$. This completes the first required derivation.\n\nSecond, we derive a closed-form expression for the observed order of accuracy, $p$, using the three solutions $Q_{1}$, $Q_{2}$, and $Q_{3}$. We write the error model for each of the three grids:\n$$\nQ_{1} = Q(h_{1}) = Q_{0} + C h_{1}^{p} \\quad (3)\n$$\n$$\nQ_{2} = Q(h_{2}) = Q_{0} + C h_{2}^{p} \\quad (4)\n$$\n$$\nQ_{3} = Q(h_{3}) = Q_{0} + C h_{3}^{p} \\quad (5)\n$$\nWe consider the differences between solutions on consecutive grids to eliminate $Q_{0}$:\n$$\nQ_{1} - Q_{2} = (Q_{0} + C h_{1}^{p}) - (Q_{0} + C h_{2}^{p}) = C (h_{1}^{p} - h_{2}^{p})\n$$\n$$\nQ_{2} - Q_{3} = (Q_{0} + C h_{2}^{p}) - (Q_{0} + C h_{3}^{p}) = C (h_{2}^{p} - h_{3}^{p})\n$$\nUsing the definition of the uniform refinement ratio, $r = h_{1}/h_{2} = h_{2}/h_{3}$, we can write $h_{1} = r h_{2}$ and $h_{2} = r h_{3}$. Substituting these into the difference equations:\n$$\nQ_{1} - Q_{2} = C ((r h_{2})^{p} - h_{2}^{p}) = C h_{2}^{p} (r^{p} - 1)\n$$\n$$\nQ_{2} - Q_{3} = C (h_{2}^{p} - (h_{2}/r)^{p}) = C \\frac{h_{2}^{p}}{r^{p}} (r^{p} - 1)\n$$\nNow, we take the ratio of these two differences to eliminate both $C$ and the term $(r^{p}-1)$:\n$$\n\\frac{Q_{1} - Q_{2}}{Q_{2} - Q_{3}} = \\frac{C h_{2}^{p} (r^{p} - 1)}{C \\frac{h_{2}^{p}}{r^{p}} (r^{p} - 1)}\n$$\nAssuming $C \\neq 0$, $r^{p} \\neq 1$, and $Q_{2} \\neq Q_{3}$, the terms cancel, leaving:\n$$\n\\frac{Q_{1} - Q_{2}}{Q_{2} - Q_{3}} = r^{p}\n$$\nTo solve for $p$, we take the natural logarithm of both sides:\n$$\n\\ln\\left(\\frac{Q_{1} - Q_{2}}{Q_{2} - Q_{3}}\\right) = \\ln(r^{p}) = p \\ln(r)\n$$\nThus, the expression for the observed order of accuracy is:\n$$\np = \\frac{\\ln\\left(\\frac{Q_{1} - Q_{2}}{Q_{2} - Q_{3}}\\right)}{\\ln(r)}\n$$\nThis completes the second required derivation.\n\nThird, we combine the previous results to obtain a closed-form expression for $Q_{0}$ in terms of $Q_{1}$, $Q_{2}$, and $Q_{3}$ alone. We use the Richardson extrapolation formula derived earlier, applied to the two finest grids, with $h=h_{2}$ and $h/r=h_{3}$. In this case, $Q(h) = Q_{2}$ and $Q(h/r) = Q_{3}$:\n$$\nQ_{0} = \\frac{r^{p} Q_{3} - Q_{2}}{r^{p} - 1}\n$$\nWe now substitute the expression for $r^{p}$ that we found during the derivation of $p$:\n$$\nr^{p} = \\frac{Q_{1} - Q_{2}}{Q_{2} - Q_{3}}\n$$\nSubstituting this into the equation for $Q_{0}$:\n$$\nQ_{0} = \\frac{\\left(\\frac{Q_{1} - Q_{2}}{Q_{2} - Q_{3}}\\right) Q_{3} - Q_{2}}{\\left(\\frac{Q_{1} - Q_{2}}{Q_{2} - Q_{3}}\\right) - 1}\n$$\nTo simplify this complex fraction, we multiply the numerator and the denominator by $(Q_{2} - Q_{3})$:\n$$\nQ_{0} = \\frac{(Q_{1} - Q_{2}) Q_{3} - Q_{2} (Q_{2} - Q_{3})}{(Q_{1} - Q_{2}) - (Q_{2} - Q_{3})}\n$$\nExpanding the terms in the numerator and denominator:\n$$\nQ_{0} = \\frac{Q_{1} Q_{3} - Q_{2} Q_{3} - Q_{2}^{2} + Q_{2} Q_{3}}{Q_{1} - 2 Q_{2} + Q_{3}}\n$$\nThe term $Q_{2} Q_{3}$ cancels in the numerator, yielding the final compact expression for the continuum value $Q_{0}$:\n$$\nQ_{0} = \\frac{Q_{1} Q_{3} - Q_{2}^{2}}{Q_{1} - 2 Q_{2} + Q_{3}}\n$$\nThis completes the final required derivation. The results for $p$ and $Q_0$ are provided as the final answer.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{Q_1 Q_3 - Q_2^2}{Q_1 - 2Q_2 + Q_3} & \\frac{\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right)}{\\ln(r)} \\end{pmatrix}}$$"
        },
        {
            "introduction": "A primary challenge in UQ for CFD is the prohibitive computational cost of running thousands of simulations for a Monte Carlo analysis. This exercise introduces a powerful solution: building a surrogate model using a Polynomial Chaos Expansion (PCE). You will practice the non-intrusive spectral projection method to compute the PCE coefficients, effectively translating a complex CFD model into a simple polynomial that can be analyzed almost instantly .",
            "id": "4002899",
            "problem": "Consider a two-dimensional aerospace Computational Fluid Dynamics (CFD) uncertainty quantification problem for a transonic airfoil, where the quantity of interest $u$ (for example, a section lift coefficient from a Reynolds-Averaged Navier-Stokes (RANS) solver) depends on two independent random inputs $\\xi_{1}$ and $\\xi_{2}$ representing standardized variations of angle of attack and freestream Mach number. Assume $\\xi_{1} \\sim \\mathcal{N}(0,1)$, $\\xi_{2} \\sim \\mathcal{N}(0,1)$, and $\\xi_{1}$ and $\\xi_{2}$ are independent. A local polynomial surrogate for the CFD response is given by\n$$\nu(\\xi_{1},\\xi_{2}) \\;=\\; 0.32 \\;+\\; 0.12\\,\\xi_{1} \\;-\\; 0.08\\,\\xi_{2} \\;+\\; 0.05\\,\\xi_{1}^{2} \\;+\\; 0.09\\,\\xi_{1}\\xi_{2} \\;-\\; 0.04\\,\\xi_{2}^{2}.\n$$\nConstruct a Polynomial Chaos Expansion (PCE) of $u$ up to total order $2$ using the orthonormal basis formed by tensor products of probabilists’ Hermite polynomials normalized by factorials, that is, in one dimension $\\psi_{0}(\\xi)=1$, $\\psi_{1}(\\xi)=\\xi$, and $\\psi_{2}(\\xi)=\\frac{\\xi^{2}-1}{\\sqrt{2}}$, and in two dimensions $\\psi_{\\alpha}(\\xi_{1},\\xi_{2})=\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\alpha_{2}}(\\xi_{2})$ for multi-index $\\alpha=(\\alpha_{1},\\alpha_{2})$. Using nonintrusive spectral projection, compute the six coefficients up to total order $2$, corresponding to $\\alpha \\in \\{(0,0),(1,0),(0,1),(2,0),(1,1),(0,2)\\}$.\n\nTo approximate the expectations defining the spectral projection, use tensor-product Gauss–Hermite quadrature of order $3$ in each dimension adapted to the standard normal weight. For each one-dimensional standard normal variable, use the nodes and weights\n$$\n\\xi \\in \\{-\\sqrt{3},\\,0,\\,\\sqrt{3}\\}, \\quad w \\in \\left\\{\\tfrac{1}{6},\\,\\tfrac{2}{3},\\,\\tfrac{1}{6}\\right\\},\n$$\nand take tensor products to form the two-dimensional rule with product weights. Express your final answer as the row vector of PCE coefficients\n$$\n\\left(c_{00},\\,c_{10},\\,c_{01},\\,c_{20},\\,c_{11},\\,c_{02}\\right),\n$$\nwith no units. No rounding is required; provide exact values.",
            "solution": "The user wants me to critically validate the provided problem statement and, if valid, solve it.\n\n### Step 1: Extract Givens\n-   **Quantity of Interest**: A CFD response $u(\\xi_{1},\\xi_{2})$ given by the polynomial surrogate model:\n    $$u(\\xi_{1},\\xi_{2}) = 0.32 + 0.12\\xi_{1} - 0.08\\xi_{2} + 0.05\\xi_{1}^{2} + 0.09\\xi_{1}\\xi_{2} - 0.04\\xi_{2}^{2}$$\n-   **Random Inputs**: Two independent random variables $\\xi_{1}$ and $\\xi_{2}$, both following the standard normal distribution, i.e., $\\xi_{1} \\sim \\mathcal{N}(0,1)$ and $\\xi_{2} \\sim \\mathcal{N}(0,1)$.\n-   **Task**: Construct a Polynomial Chaos Expansion (PCE) of $u$ up to total order $2$.\n-   **PCE Basis**: Orthonormal basis formed by tensor products of 1D probabilists' Hermite polynomials.\n    -   1D basis: $\\psi_{0}(\\xi)=1$, $\\psi_{1}(\\xi)=\\xi$, $\\psi_{2}(\\xi)=\\frac{\\xi^{2}-1}{\\sqrt{2}}$.\n    -   2D basis: $\\psi_{\\alpha}(\\xi_{1},\\xi_{2})=\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\alpha_{2}}(\\xi_{2})$ for multi-index $\\alpha=(\\alpha_{1},\\alpha_{2})$.\n-   **Coefficients to Compute**: The six coefficients $c_{\\alpha}$ for multi-indices $\\alpha$ with total order $|\\alpha| = \\alpha_1+\\alpha_2 \\le 2$: $\\alpha \\in \\{(0,0),(1,0),(0,1),(2,0),(1,1),(0,2)\\}$.\n-   **Methodology**: \"nonintrusive spectral projection\".\n-   **Numerical Integration**: Tensor-product Gauss–Hermite quadrature of order $3$ in each dimension.\n    -   1D nodes: $\\xi \\in \\{-\\sqrt{3},\\,0,\\,\\sqrt{3}\\}$.\n    -   1D weights (for standard normal measure): $w \\in \\left\\{\\frac{1}{6},\\,\\frac{2}{3},\\,\\frac{1}{6}\\right\\}$.\n-   **Final Answer Format**: A row vector of the six coefficients $(c_{00},\\,c_{10},\\,c_{01},\\,c_{20},\\,c_{11},\\,c_{02})$ as exact values.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is a standard application of Polynomial Chaos Expansions for uncertainty quantification, a well-established method in computational science and engineering. The use of Hermite polynomials for Gaussian random variables is the theoretically correct choice. The problem is sound.\n2.  **Well-Posed**: The problem is clearly stated. The goal is to find the coefficients of the PCE. The function, the probability distributions of the inputs, the basis polynomials, and the method for calculating the coefficients are all explicitly defined.\n3.  **Objective**: The problem is stated in objective, mathematical language. No subjective or ambiguous terms are used.\n4.  **Completeness**: All necessary information is provided. The surrogate model for $u$ is given, as are the distributions for $\\xi_1$ and $\\xi_2$, the basis functions, and the specific numerical quadrature rule. There are no contradictions.\n5.  **Consistency Check**: The problem specifies a 3-point Gauss-Hermite quadrature rule. A 1D $N$-point Gauss-Hermite rule is exact for polynomials up to degree $2N-1$. Here $N=3$, so the 1D rule is exact for polynomials up to degree $2(3)-1=5$. The tensor-product rule is correspondingly exact for polynomials in $(\\xi_1, \\xi_2)$ where the maximum degree of each variable is at most $5$. The coefficients are calculated by integrating $u \\cdot \\psi_{\\alpha}$. The highest degree of any variable in any integrand is $4$ (e.g., in $u \\cdot \\psi_{20}$, the term $\\xi_1^2 \\cdot \\xi_1^2 = \\xi_1^4$ appears). Since $4 \\le 5$, the prescribed quadrature rule is exact for all the required integrals. This makes the problem perfectly consistent and well-posed.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. I will proceed with the solution.\n\nThe Polynomial Chaos Expansion of $u(\\xi_1, \\xi_2)$ is given by\n$$u(\\xi_1, \\xi_2) = \\sum_{\\alpha \\in \\mathbb{N}_0^2} c_{\\alpha} \\psi_{\\alpha}(\\xi_1, \\xi_2)$$\nwhere $\\psi_{\\alpha}$ are the orthonormal basis polynomials. The coefficients $c_{\\alpha}$ are determined using nonintrusive spectral projection, which relies on the orthogonality of the basis functions:\n$$c_{\\alpha} = \\mathbb{E}[u(\\xi_1, \\xi_2) \\psi_{\\alpha}(\\xi_1, \\xi_2)] = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} u(\\xi_1, \\xi_2) \\psi_{\\alpha}(\\xi_1, \\xi_2) \\frac{1}{2\\pi} \\exp\\left(-\\frac{\\xi_1^2+\\xi_2^2}{2}\\right) d\\xi_1 d\\xi_2$$\nAs established in the validation, the specified 3-point tensor-product Gauss-Hermite quadrature is exact for these integrals. An equivalent and more direct method is to compute these expectations analytically using the moments of the standard normal distribution, which also yields the exact result.\n\nThe random variables $\\xi_1$ and $\\xi_2$ are independent and standard normal, $\\mathcal{N}(0,1)$. Their moments are:\n- $\\mathbb{E}[\\xi_i] = 0$\n- $\\mathbb{E}[\\xi_i^2] = 1$\n- $\\mathbb{E}[\\xi_i^3] = 0$\n- $\\mathbb{E}[\\xi_i^4] = 3$\n- For $i \\neq j$, $\\mathbb{E}[\\xi_i^m \\xi_j^n] = \\mathbb{E}[\\xi_i^m]\\mathbb{E}[\\xi_j^n]$ due to independence.\n\nThe basis polynomials for total order up to $2$ are:\n- $\\psi_{(0,0)}(\\xi_1,\\xi_2) = \\psi_0(\\xi_1)\\psi_0(\\xi_2) = 1 \\cdot 1 = 1$\n- $\\psi_{(1,0)}(\\xi_1,\\xi_2) = \\psi_1(\\xi_1)\\psi_0(\\xi_2) = \\xi_1 \\cdot 1 = \\xi_1$\n- $\\psi_{(0,1)}(\\xi_1,\\xi_2) = \\psi_0(\\xi_1)\\psi_1(\\xi_2) = 1 \\cdot \\xi_2 = \\xi_2$\n- $\\psi_{(2,0)}(\\xi_1,\\xi_2) = \\psi_2(\\xi_1)\\psi_0(\\xi_2) = \\frac{\\xi_1^2 - 1}{\\sqrt{2}}$\n- $\\psi_{(1,1)}(\\xi_1,\\xi_2) = \\psi_1(\\xi_1)\\psi_1(\\xi_2) = \\xi_1 \\xi_2$\n- $\\psi_{(0,2)}(\\xi_1,\\xi_2) = \\psi_0(\\xi_1)\\psi_2(\\xi_2) = \\frac{\\xi_2^2 - 1}{\\sqrt{2}}$\n\nWe now compute each coefficient by taking the expectation.\n\n**Coefficient $c_{00}$:**\n$c_{00} = \\mathbb{E}[u \\cdot \\psi_{(0,0)}] = \\mathbb{E}[u] = \\mathbb{E}[0.32 + 0.12\\xi_1 - 0.08\\xi_2 + 0.05\\xi_1^2 + 0.09\\xi_1\\xi_2 - 0.04\\xi_2^2]$\nUsing linearity of expectation:\n$c_{00} = 0.32 + 0.12\\mathbb{E}[\\xi_1] - 0.08\\mathbb{E}[\\xi_2] + 0.05\\mathbb{E}[\\xi_1^2] + 0.09\\mathbb{E}[\\xi_1]\\mathbb{E}[\\xi_2] - 0.04\\mathbb{E}[\\xi_2^2]$\n$c_{00} = 0.32 + 0.12(0) - 0.08(0) + 0.05(1) + 0.09(0)(0) - 0.04(1) = 0.32 + 0.05 - 0.04 = 0.33$\n\n**Coefficient $c_{10}$:**\n$c_{10} = \\mathbb{E}[u \\cdot \\psi_{(1,0)}] = \\mathbb{E}[u \\xi_1] = \\mathbb{E}[(0.32 + 0.12\\xi_1 - 0.08\\xi_2 + 0.05\\xi_1^2 + 0.09\\xi_1\\xi_2 - 0.04\\xi_2^2)\\xi_1]$\n$c_{10} = \\mathbb{E}[0.32\\xi_1 + 0.12\\xi_1^2 - 0.08\\xi_1\\xi_2 + 0.05\\xi_1^3 + 0.09\\xi_1^2\\xi_2 - 0.04\\xi_1\\xi_2^2]$\nOnly terms with even powers of each variable have non-zero expectation. The only such term is $0.12\\xi_1^2$.\n$c_{10} = 0.12\\mathbb{E}[\\xi_1^2] = 0.12(1) = 0.12$\n\n**Coefficient $c_{01}$:**\n$c_{01} = \\mathbb{E}[u \\cdot \\psi_{(0,1)}] = \\mathbb{E}[u \\xi_2] = \\mathbb{E}[(0.32 + 0.12\\xi_1 - 0.08\\xi_2 + 0.05\\xi_1^2 + 0.09\\xi_1\\xi_2 - 0.04\\xi_2^2)\\xi_2]$\n$c_{01} = \\mathbb{E}[0.32\\xi_2 + 0.12\\xi_1\\xi_2 - 0.08\\xi_2^2 + 0.05\\xi_1^2\\xi_2 + 0.09\\xi_1\\xi_2^2 - 0.04\\xi_2^3]$\nThe only term with non-zero expectation is $-0.08\\xi_2^2$.\n$c_{01} = -0.08\\mathbb{E}[\\xi_2^2] = -0.08(1) = -0.08$\n\n**Coefficient $c_{20}$:**\n$c_{20} = \\mathbb{E}[u \\cdot \\psi_{(2,0)}] = \\mathbb{E}\\left[u \\frac{\\xi_1^2 - 1}{\\sqrt{2}}\\right] = \\frac{1}{\\sqrt{2}}(\\mathbb{E}[u\\xi_1^2] - \\mathbb{E}[u])$\nWe already found $\\mathbb{E}[u] = c_{00} = 0.33$. We need $\\mathbb{E}[u\\xi_1^2]$.\n$\\mathbb{E}[u\\xi_1^2] = \\mathbb{E}[(0.32 + 0.12\\xi_1 - 0.08\\xi_2 + 0.05\\xi_1^2 + 0.09\\xi_1\\xi_2 - 0.04\\xi_2^2)\\xi_1^2]$\n$\\mathbb{E}[u\\xi_1^2] = \\mathbb{E}[0.32\\xi_1^2 + 0.05\\xi_1^4 - 0.04\\xi_1^2\\xi_2^2]$ (keeping only terms with even powers)\n$\\mathbb{E}[u\\xi_1^2] = 0.32\\mathbb{E}[\\xi_1^2] + 0.05\\mathbb{E}[\\xi_1^4] - 0.04\\mathbb{E}[\\xi_1^2]\\mathbb{E}[\\xi_2^2]$\n$\\mathbb{E}[u\\xi_1^2] = 0.32(1) + 0.05(3) - 0.04(1)(1) = 0.32 + 0.15 - 0.04 = 0.43$\n$c_{20} = \\frac{1}{\\sqrt{2}}(0.43 - 0.33) = \\frac{0.1}{\\sqrt{2}} = \\frac{0.1\\sqrt{2}}{2} = 0.05\\sqrt{2}$\n\n**Coefficient $c_{11}$:**\n$c_{11} = \\mathbb{E}[u \\cdot \\psi_{(1,1)}] = \\mathbb{E}[u \\xi_1 \\xi_2] = \\mathbb{E}[(0.32 + 0.12\\xi_1 - 0.08\\xi_2 + 0.05\\xi_1^2 + 0.09\\xi_1\\xi_2 - 0.04\\xi_2^2)\\xi_1\\xi_2]$\n$c_{11} = \\mathbb{E}[0.09\\xi_1^2\\xi_2^2]$ (keeping only the term with even powers for both variables)\n$c_{11} = 0.09\\mathbb{E}[\\xi_1^2]\\mathbb{E}[\\xi_2^2] = 0.09(1)(1) = 0.09$\n\n**Coefficient $c_{02}$:**\n$c_{02} = \\mathbb{E}[u \\cdot \\psi_{(0,2)}] = \\mathbb{E}\\left[u \\frac{\\xi_2^2 - 1}{\\sqrt{2}}\\right] = \\frac{1}{\\sqrt{2}}(\\mathbb{E}[u\\xi_2^2] - \\mathbb{E}[u])$\nWe have $\\mathbb{E}[u] = 0.33$. We need $\\mathbb{E}[u\\xi_2^2]$.\n$\\mathbb{E}[u\\xi_2^2] = \\mathbb{E}[(0.32 + 0.12\\xi_1 - 0.08\\xi_2 + 0.05\\xi_1^2 + 0.09\\xi_1\\xi_2 - 0.04\\xi_2^2)\\xi_2^2]$\n$\\mathbb{E}[u\\xi_2^2] = \\mathbb{E}[0.32\\xi_2^2 + 0.05\\xi_1^2\\xi_2^2 - 0.04\\xi_2^4]$ (keeping only terms with even powers)\n$\\mathbb{E}[u\\xi_2^2] = 0.32\\mathbb{E}[\\xi_2^2] + 0.05\\mathbb{E}[\\xi_1^2]\\mathbb{E}[\\xi_2^2] - 0.04\\mathbb{E}[\\xi_2^4]$\n$\\mathbb{E}[u\\xi_2^2] = 0.32(1) + 0.05(1)(1) - 0.04(3) = 0.32 + 0.05 - 0.12 = 0.25$\n$c_{02} = \\frac{1}{\\sqrt{2}}(0.25 - 0.33) = \\frac{-0.08}{\\sqrt{2}} = -\\frac{0.08\\sqrt{2}}{2} = -0.04\\sqrt{2}$\n\nThe computed coefficients are:\n$c_{00} = 0.33$\n$c_{10} = 0.12$\n$c_{01} = -0.08$\n$c_{20} = 0.05\\sqrt{2}$\n$c_{11} = 0.09$\n$c_{02} = -0.04\\sqrt{2}$\n\nThese are collected into the requested row vector $(c_{00},\\,c_{10},\\,c_{01},\\,c_{20},\\,c_{11},\\,c_{02})$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.33 & 0.12 & -0.08 & 0.05\\sqrt{2} & 0.09 & -0.04\\sqrt{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "In practical aerospace engineering, we often have a hierarchy of models, from simplified analytical formulas to full-fidelity CFD. This hands-on coding exercise demonstrates how to leverage this hierarchy to perform UQ efficiently using a multifidelity control variate framework. You will implement an algorithm that optimally combines a few expensive, high-fidelity results with many cheap, low-fidelity results to dramatically accelerate the estimation of statistical moments for a quantity of interest .",
            "id": "4002827",
            "problem": "You are to design and implement a multifidelity uncertainty quantification framework that couples a simplified chemistry model with a full Computational Fluid Dynamics (CFD) model to estimate the uncertainty in wall heat flux predictions for a supersonic, reacting boundary layer. The goal is to estimate the mean and standard deviation of the wall heat flux under input uncertainty using a variance-reducing multifidelity control variate strategy. Your final program must be a complete, runnable Python script that computes the required outputs for a specified test suite and prints the results in the exact required format.\n\nYou must base your derivation and algorithm on the following fundamental principles and core definitions:\n\n- The compressible flow energy balance implies that the wall heat flux is given by Fourier’s law, $q'' = -k \\frac{\\partial T}{\\partial n} \\rvert_{\\text{wall}}$, where $k$ is the thermal conductivity and $\\frac{\\partial T}{\\partial n}$ is the wall-normal temperature gradient. For engineering closure, it is common to express the wall heat flux as $q'' = h (T_{r} - T_{w})$, where $h$ is a convective heat transfer coefficient, $T_{r}$ is a recovery-like temperature characterizing the incoming boundary layer, and $T_{w}$ is the wall temperature.\n- In high-speed turbulent boundary layers, recovery temperature is often described using a recovery factor depending on the turbulent Prandtl number. Chemical heat release can augment the recovery temperature by a chemistry-induced temperature rise.\n- Uncertainty quantification seeks to estimate the statistical moments (mean and variance) of outputs under input uncertainty by computing expectations, $\\mathbb{E}[\\cdot]$, and variances, $\\mathbb{V}[\\cdot]$.\n- Multifidelity control variates exploit correlation between a low-cost, biased model and a high-cost, accurate model to reduce estimator variance without changing the target expectation.\n\nDefine the following high-fidelity (CFD with detailed chemistry) and low-fidelity (CFD with simplified chemistry) models for the wall heat flux $q''$ in $\\mathrm{W/m^2}$ as functions of uncertain inputs. The models are engineered surrogates that encode well-tested qualitative physics relationships, not shortcut formulas for the estimator:\n\n1) High-fidelity model $q_{H}''(A,E,Pr_{t})$:\n- Constants: $T_{e} = 1200 \\,\\mathrm{K}$, $T_{w} = 600 \\,\\mathrm{K}$, $\\gamma = 1.4$, $M = 2$, $R = 8.314 \\,\\mathrm{J/(mol \\cdot K)}$, $A_{\\mathrm{ref}} = 10^{6} \\,\\mathrm{s^{-1}}$, $H_{0} = 350 \\,\\mathrm{W/(m^{2}\\cdot K)}$, $S = 500 \\,\\mathrm{K}$, $\\kappa = 5 \\times 10^{4}$ (dimensionless).\n- Turbulent recovery factor: $r = Pr_{t}^{1/3}$.\n- Chemistry-induced temperature rise:\n$$ \\Delta T_{\\mathrm{chem},H} = S \\, \\ln\\!\\left(1 + \\kappa \\, \\frac{A}{A_{\\mathrm{ref}}} \\, \\exp\\!\\left(- \\frac{E}{R T_{e}}\\right)\\right) $$\n- Recovery-like temperature:\n$$ T_{r,H} = T_{e}\\left(1 + r \\, \\frac{\\gamma - 1}{2} \\, M^{2}\\right) + \\Delta T_{\\mathrm{chem},H} $$\n- Heat transfer coefficient: $h = H_{0} \\, Pr_{t}^{-2/3}$.\n- Wall heat flux: $q_{H}'' = h \\, (T_{r,H} - T_{w})$ in $\\mathrm{W/m^{2}}$.\n\n2) Low-fidelity model $q_{L}''(A,E,Pr_{t}; \\alpha, s)$ parameterized by mismatch parameters $\\alpha$ and $s$:\n- Constants: same $T_{e}$, $T_{w}$, $\\gamma$, $M$, $R$, $A_{\\mathrm{ref}}$, $H_{0}$ as above, and $\\kappa_{L} = 0.8 \\, \\kappa$.\n- Recovery factor: $r = Pr_{t}^{1/3}$.\n- Simplified chemistry rise:\n$$ \\Delta T_{\\mathrm{chem},L} = s \\, S \\, \\ln\\!\\left(1 + \\kappa_{L} \\, \\left(\\frac{A}{A_{\\mathrm{ref}}}\\right)^{\\alpha} \\, \\exp\\!\\left(- \\frac{E}{R T_{e}}\\right)\\right) $$\n- Recovery-like temperature:\n$$ T_{r,L} = T_{e}\\left(1 + r \\, \\frac{\\gamma - 1}{2} \\, M^{2}\\right) + \\Delta T_{\\mathrm{chem},L} $$\n- Heat transfer coefficient: $h = H_{0} \\, Pr_{t}^{-2/3}$.\n- Wall heat flux: $q_{L}'' = h \\, (T_{r,L} - T_{w})$ in $\\mathrm{W/m^{2}}$.\n\nThe input uncertainties are independent with the following distributions:\n- Reaction pre-exponential factor $A$ in $\\mathrm{s^{-1}}$: $\\ln A \\sim \\mathcal{N}(\\ln(10^{6}),\\, 0.5^{2})$.\n- Activation energy $E$ in $\\mathrm{J/mol}$: $E \\sim \\mathcal{N}(8 \\times 10^{4},\\, (1 \\times 10^{4})^{2})$.\n- Turbulent Prandtl number $Pr_{t}$ (dimensionless): $\\ln Pr_{t} \\sim \\mathcal{N}(\\ln(0.9),\\, 0.2^{2})$.\n\nLet the quantity of interest be the random wall heat flux $Q = q_{H}''(A,E,Pr_{t})$. You must estimate its mean $\\mu = \\mathbb{E}[Q]$ and standard deviation $\\sigma = \\sqrt{\\mathbb{V}[Q]}$ using a multifidelity control variate framework that leverages $q_{L}''$ as a low-fidelity model correlated with $q_{H}''$. You must design, from first principles, an estimator for $\\mathbb{E}[Q]$ that combines a small set of paired high/low-fidelity evaluations with a larger set of low-fidelity-only evaluations. To estimate $\\mathbb{V}[Q]$, you must estimate $\\mathbb{E}[Q^{2}]$ using an analogous multifidelity construction and then compute $\\sigma = \\sqrt{\\max\\{ \\mathbb{E}[Q^{2}] - (\\mathbb{E}[Q])^{2}, 0\\}}$. You must ensure numerical stability in the presence of very small sample variances by using a minimal positive regularization constant when needed.\n\nNumerical and implementation requirements:\n- Use standard Monte Carlo sampling with a fixed random seed of $2025$ for reproducibility.\n- Angles are not involved; no angle units are required.\n- Express the final estimated mean and standard deviation in $\\mathrm{W/m^{2}}$, with each floating-point number rounded to exactly $6$ decimal places in the printed output.\n- No external input shall be read; no external files or network access are permitted.\n\nTest suite:\nFor each test case, use the specified low-fidelity mismatch parameters $(\\alpha, s)$ and sampling budgets. In each case, $M$ denotes the number of paired high/low-fidelity samples and $N$ denotes the total number of low-fidelity samples (including the $M$ paired samples). All $N - M$ low-fidelity-only samples must be independent of the $M$ paired samples.\n\n- Case $1$: $(\\alpha, s) = (1.0, 1.0)$, $M = 40$, $N = 4000$.\n- Case $2$: $(\\alpha, s) = (0.9, 0.85)$, $M = 40$, $N = 4000$.\n- Case $3$: $(\\alpha, s) = (0.6, 0.6)$, $M = 40$, $N = 4000$.\n- Case $4$ (boundary condition with very few high-fidelity samples): $(\\alpha, s) = (0.8, 0.9)$, $M = 2$, $N = 4000$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the estimated mean and standard deviation (both in $\\mathrm{W/m^{2}}$) for each test case, concatenated across the four cases:\n[$\\mu_{1}$, $\\sigma_{1}$, $\\mu_{2}$, $\\sigma_{2}$, $\\mu_{3}$, $\\sigma_{3}$, $\\mu_{4}$, $\\sigma_{4}$]\nEach number must be rounded to exactly $6$ decimal places and printed without units, where $\\mu_{i}$ and $\\sigma_{i}$ are the multifidelity estimates for case $i$ in $\\mathrm{W/m^{2}}$.",
            "solution": "The user-provided problem is valid. It is a well-posed and scientifically grounded problem in the field of uncertainty quantification for aerospace CFD. The physical models, while simplified, are representative of engineering approximations for reacting boundary-layer heat transfer and are mathematically consistent. The statistical framework, based on multifidelity control variates, is a standard and appropriate technique for the stated goal. All necessary constants, model definitions, input uncertainties, and numerical requirements are provided, making the problem self-contained and solvable.\n\n### Theoretical Framework and Derivation\n\nThe primary objective is to estimate the mean $\\mu = \\mathbb{E}[Q_H]$ and standard deviation $\\sigma = \\sqrt{\\mathbb{V}[Q_H]}$ of a high-fidelity quantity of interest, $Q_H = q_{H}''(A,E,Pr_{t})$, which is computationally expensive to evaluate. To accelerate this estimation, we leverage a computationally cheap, but less accurate, low-fidelity model $Q_L = q_{L}''(A,E,Pr_{t}, \\alpha, s)$. The multifidelity control variate (MF-CV) method is employed for this purpose.\n\n#### 1. Multifidelity Control Variate Estimator for the Mean\n\nThe core idea of a control variate is to use a correlated variable with a known (or cheaply estimated) mean to reduce the variance of an estimator. The standard control variate estimator for $\\mathbb{E}[Q_H]$ is:\n$$ \\hat{Q}_{H,CV} = Q_H - \\beta (Q_L - \\mathbb{E}[Q_L]) $$\nwhere $\\beta$ is a coefficient chosen to minimize the variance of $\\hat{Q}_{H,CV}$. The expectation of this estimator is $\\mathbb{E}[\\hat{Q}_{H,CV}] = \\mathbb{E}[Q_H] = \\mu$, so it is unbiased.\n\nIn practice, the true mean $\\mathbb{E}[Q_L]$ is unknown and must be estimated. The MF-CV framework uses a small number of high-fidelity evaluations and a larger number of low-fidelity evaluations. We are given a budget of $M$ paired evaluations, $\\{(Q_H^{(i)}, Q_L^{(i)})\\}_{i=1}^M$, and a total budget of $N$ low-fidelity evaluations, where the additional $N-M$ evaluations are on an independent set of input samples.\n\nThe MF-CV estimator for the mean, $\\hat{\\mu}_{H, MF}$, is constructed as follows:\n$$ \\hat{\\mu}_{H, MF} = \\hat{\\mu}_{H, M} + \\beta (\\hat{\\mu}_{L, N} - \\hat{\\mu}_{L, M}) $$\nwhere:\n- $\\hat{\\mu}_{H, M} = \\frac{1}{M} \\sum_{i=1}^{M} Q_H^{(i)}$ is the standard Monte Carlo estimate of the high-fidelity mean using the $M$ expensive samples.\n- $\\hat{\\mu}_{L, M} = \\frac{1}{M} \\sum_{i=1}^{M} Q_L^{(i)}$ is the estimate of the low-fidelity mean from the same $M$ samples.\n- $\\hat{\\mu}_{L, N} = \\frac{1}{N} \\sum_{j=1}^{N} Q_L^{(j)}$ is a more accurate estimate of the low-fidelity mean using all $N$ inexpensive samples.\n- $\\beta$ is the control variate coefficient.\n\nThe optimal coefficient $\\beta^*$ that minimizes the variance of the estimator is given by:\n$$ \\beta^* = \\frac{\\mathrm{Cov}(Q_H, Q_L)}{\\mathbb{V}[Q_L]} $$\nSince the true covariance and variance are unknown, we estimate them from the $M$ paired samples:\n$$ \\hat{\\beta} = \\frac{\\widehat{\\mathrm{Cov}}(Q_H, Q_L)}{\\widehat{\\mathbb{V}}[Q_L]} = \\frac{\\sum_{i=1}^{M} (Q_H^{(i)} - \\hat{\\mu}_{H, M})(Q_L^{(i)} - \\hat{\\mu}_{L, M})}{\\sum_{i=1}^{M} (Q_L^{(i)} - \\hat{\\mu}_{L, M})^2} $$\nFor numerical stability, especially when $M$ is small, the denominator can be close to zero. We introduce a small regularization constant $\\epsilon > 0$ to prevent division by a very small number:\n$$ \\hat{\\beta} = \\frac{\\widehat{\\mathrm{Cov}}(Q_H, Q_L)}{\\widehat{\\mathbb{V}}[Q_L] + \\epsilon} $$\n\nThe final estimator for the mean is:\n$$ \\hat{\\mu}_{H, MF} = \\hat{\\mu}_{H, M} + \\hat{\\beta} (\\hat{\\mu}_{L, N} - \\hat{\\mu}_{L, M}) $$\n\n#### 2. Estimator for the Standard Deviation\n\nThe standard deviation is $\\sigma = \\sqrt{\\mathbb{V}[Q_H]}$, where the variance is defined as $\\mathbb{V}[Q_H] = \\mathbb{E}[Q_H^2] - (\\mathbb{E}[Q_H])^2$. We have already derived an estimator for $\\mathbb{E}[Q_H]$. To estimate $\\mathbb{V}[Q_H]$, we need an estimator for the second moment, $\\mathbb{E}[Q_H^2]$.\n\nAs per the problem description, we construct an analogous MF-CV estimator for $\\mathbb{E}[Q_H^2]$. Let us define two new random variables: $Y_H = Q_H^2$ and $Y_L = Q_L^2$. We now seek to estimate $\\mathbb{E}[Y_H]$. We apply the same MF-CV procedure:\n$$ \\widehat{\\mathbb{E}[Y_H]}_{MF} = \\hat{\\mu}_{Y_H, M} + \\hat{\\beta}_Y (\\hat{\\mu}_{Y_L, N} - \\hat{\\mu}_{Y_L, M}) $$\nwhere:\n- The means $\\hat{\\mu}_{Y_H, M}$, $\\hat{\\mu}_{Y_L, M}$, and $\\hat{\\mu}_{Y_L, N}$ are sample averages of the squared quantities, analogous to the mean estimators.\n- The coefficient $\\hat{\\beta}_Y$ is estimated from the $M$ paired samples of the squared quantities:\n$$ \\hat{\\beta}_Y = \\frac{\\widehat{\\mathrm{Cov}}(Y_H, Y_L)}{\\widehat{\\mathbb{V}}[Y_L] + \\epsilon} = \\frac{\\widehat{\\mathrm{Cov}}(Q_H^2, Q_L^2)}{\\widehat{\\mathbb{V}}[Q_L^2] + \\epsilon} $$\n\nWith the estimators for the first and second moments, the variance is estimated as:\n$$ \\widehat{\\mathbb{V}}[Q_H] = \\widehat{\\mathbb{E}[Y_H]}_{MF} - (\\hat{\\mu}_{H, MF})^2 $$\nTo ensure a non-negative variance, which can be violated due to sampling error, we take the maximum of this value and zero:\n$$ \\widehat{\\mathbb{V}}[Q_H] = \\max\\{0, \\widehat{\\mathbb{E}[Y_H]}_{MF} - (\\hat{\\mu}_{H, MF})^2 \\} $$\nFinally, the estimated standard deviation is the square root of the estimated variance:\n$$ \\hat{\\sigma}_{H, MF} = \\sqrt{\\widehat{\\mathbb{V}}[Q_H]} $$\n\n### Algorithmic Implementation\n\nThe solution is implemented by following these steps for each test case:\n\n1.  **Initialize**: Set up a single random number generator with the specified seed `2025` to ensure reproducibility across all test cases.\n\n2.  **Sample Generation**: For a given case with parameters $(M, N)$, generate two independent sets of input samples from their specified distributions:\n    - A set of $M$ samples for the uncertain inputs $(A, E, Pr_t)$ to be used for paired high- and low-fidelity model evaluations.\n    - A set of $N-M$ samples for $(A, E, Pr_t)$ to be used for low-fidelity-only evaluations.\n    The distributions are:\n    - $A \\sim \\text{LogNormal}(\\mu=\\ln(10^{6}), \\sigma=0.5)$\n    - $E \\sim \\mathcal{N}(\\mu=8 \\times 10^{4}, \\sigma=1 \\times 10^{4})$\n    - $Pr_t \\sim \\text{LogNormal}(\\mu=\\ln(0.9), \\sigma=0.2)$\n\n3.  **Model Evaluation**:\n    - Evaluate $Q_H$ and $Q_L$ on the $M$ paired samples, yielding arrays $Q_{H,M}$ and $Q_{L,M}$.\n    - Evaluate $Q_L$ on the $N-M$ independent samples, yielding $Q_{L, \\text{rest}}$.\n    - Construct the full set of $N$ low-fidelity evaluations: $Q_{L,N}$ is the concatenation of $Q_{L,M}$ and $Q_{L, \\text{rest}}$.\n\n4.  **Mean Estimation**:\n    - Calculate the sample means $\\hat{\\mu}_{H, M}$, $\\hat{\\mu}_{L, M}$, and $\\hat{\\mu}_{L, N}$ from the evaluation arrays.\n    - Compute the sample covariance $\\widehat{\\mathrm{Cov}}(Q_H, Q_L)$ and variance $\\widehat{\\mathbb{V}}[Q_L]$ using the $M$ paired samples.\n    - Calculate the coefficient $\\hat{\\beta}$ with regularization.\n    - Compute the final estimate $\\hat{\\mu}_{H, MF}$.\n\n5.  **Standard Deviation Estimation**:\n    - Square the elements of the evaluation arrays to obtain $Q_{H,M}^2$, $Q_{L,M}^2$, and $Q_{L,N}^2$.\n    - Repeat the procedure from Step 4 using these squared quantities to find $\\widehat{\\mathbb{E}[Q_H^2]}_{MF}$.\n    - Calculate the estimated variance $\\widehat{\\mathbb{V}}[Q_H]$ and then the standard deviation $\\hat{\\sigma}_{H, MF}$.\n\n6.  **Output**: Store the computed mean and standard deviation, rounded to $6$ decimal places. After processing all test cases, print the collated results in the specified list format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a multifidelity uncertainty quantification framework\n    to estimate mean and standard deviation of wall heat flux in a supersonic,\n    reacting boundary layer.\n    \"\"\"\n\n    # --- Constants ---\n    T_e = 1200.0        # K\n    T_w = 600.0         # K\n    gamma = 1.4\n    Mach = 2.0\n    R = 8.314           # J/(mol*K)\n    A_ref = 1.0e6       # s^-1\n    H_0 = 350.0         # W/(m^2*K)\n    S = 500.0           # K\n    kappa = 5.0e4\n    kappa_L = 0.8 * kappa\n    REG_EPSILON = 1e-12 # Regularization constant\n\n    # --- Model Definitions ---\n    def q_H(A, E, Pr_t):\n        \"\"\"High-fidelity model for wall heat flux.\"\"\"\n        r = Pr_t**(1/3)\n        delta_T_chem_H = S * np.log(1 + kappa * (A / A_ref) * np.exp(-E / (R * T_e)))\n        T_r_H = T_e * (1 + r * (gamma - 1) / 2 * Mach**2) + delta_T_chem_H\n        h = H_0 * Pr_t**(-2/3)\n        return h * (T_r_H - T_w)\n\n    def q_L(A, E, Pr_t, alpha, s):\n        \"\"\"Low-fidelity model for wall heat flux.\"\"\"\n        r = Pr_t**(1/3)\n        delta_T_chem_L = s * S * np.log(1 + kappa_L * (A / A_ref)**alpha * np.exp(-E / (R * T_e)))\n        T_r_L = T_e * (1 + r * (gamma - 1) / 2 * Mach**2) + delta_T_chem_L\n        h = H_0 * Pr_t**(-2/3)\n        return h * (T_r_L - T_w)\n\n    def get_mf_estimates(Q_H_m, Q_L_m, Q_L_rest):\n        \"\"\"\n        Computes the multifidelity estimates for the mean and second moment.\n        \"\"\"\n        M = len(Q_H_m)\n        N = M + len(Q_L_rest)\n        \n        Q_L_n = np.concatenate((Q_L_m, Q_L_rest))\n        \n        # --- Estimate Mean of Q ---\n        mu_H_m = np.mean(Q_H_m)\n        mu_L_m = np.mean(Q_L_m)\n        mu_L_n = np.mean(Q_L_n)\n\n        # Handle M=2 case for np.cov ddof=1 which requires M > 1\n        if M > 1:\n            cov_matrix_Q = np.cov(Q_H_m, Q_L_m, ddof=1)\n            cov_Q = cov_matrix_Q[0, 1]\n            var_Q_L_m = cov_matrix_Q[1, 1]\n        else: # M=1; variance/covariance are poorly defined. Use 0\n            cov_Q = 0.0\n            var_Q_L_m = 0.0\n\n        beta_Q = cov_Q / (var_Q_L_m + REG_EPSILON)\n        est_mean = mu_H_m + beta_Q * (mu_L_n - mu_L_m)\n\n        # --- Estimate Mean of Q^2 ---\n        Y_H_m = Q_H_m**2\n        Y_L_m = Q_L_m**2\n        Y_L_n = Q_L_n**2\n\n        mu_Y_H_m = np.mean(Y_H_m)\n        mu_Y_L_m = np.mean(Y_L_m)\n        mu_Y_L_n = np.mean(Y_L_n)\n\n        if M > 1:\n            cov_matrix_Y = np.cov(Y_H_m, Y_L_m, ddof=1)\n            cov_Y = cov_matrix_Y[0, 1]\n            var_Y_L_m = cov_matrix_Y[1, 1]\n        else:\n            cov_Y = 0.0\n            var_Y_L_m = 0.0\n\n        beta_Y = cov_Y / (var_Y_L_m + REG_EPSILON)\n        est_mean_sq = mu_Y_H_m + beta_Y * (mu_Y_L_n - mu_Y_L_m)\n        \n        return est_mean, est_mean_sq\n\n    # --- Test Suite ---\n    test_cases = [\n        # (alpha, s, M, N)\n        (1.0, 1.0, 40, 4000),\n        (0.9, 0.85, 40, 4000),\n        (0.6, 0.6, 40, 4000),\n        (0.8, 0.9, 2, 4000),\n    ]\n\n    # Use a single random number generator for reproducibility of the entire script\n    rng = np.random.default_rng(2025)\n    \n    final_results = []\n\n    for alpha, s, M, N in test_cases:\n        N_rest = N - M\n        \n        # --- Sample Generation ---\n        # Paired samples (M)\n        A_m = rng.lognormal(mean=np.log(1e6), sigma=0.5, size=M)\n        E_m = rng.normal(loc=8e4, scale=1e4, size=M)\n        Pr_t_m = rng.lognormal(mean=np.log(0.9), sigma=0.2, size=M)\n        \n        # Low-fidelity only samples (N-M)\n        A_rest = rng.lognormal(mean=np.log(1e6), sigma=0.5, size=N_rest)\n        E_rest = rng.normal(loc=8e4, scale=1e4, size=N_rest)\n        Pr_t_rest = rng.lognormal(mean=np.log(0.9), sigma=0.2, size=N_rest)\n        \n        # --- Model Evaluations ---\n        Q_H_m = q_H(A_m, E_m, Pr_t_m)\n        Q_L_m = q_L(A_m, E_m, Pr_t_m, alpha, s)\n        Q_L_rest = q_L(A_rest, E_rest, Pr_t_rest, alpha, s)\n\n        # --- Estimation ---\n        est_mean, est_mean_sq = get_mf_estimates(Q_H_m, Q_L_m, Q_L_rest)\n        \n        est_var = max(0, est_mean_sq - est_mean**2)\n        est_std = np.sqrt(est_var)\n\n        # Append results rounded to 6 decimal places\n        final_results.append(f\"{est_mean:.6f}\")\n        final_results.append(f\"{est_std:.6f}\")\n    \n    # --- Final Output ---\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}