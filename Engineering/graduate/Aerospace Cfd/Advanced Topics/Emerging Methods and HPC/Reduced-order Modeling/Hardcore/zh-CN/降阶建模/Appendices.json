{
    "hands_on_practices": [
        {
            "introduction": "本征正交分解（POD）面临一个基本问题：如何选择降阶模型的维度 $r$。这个选择需要在模型紧凑性和准确性之间进行权衡。本练习将指导你实现最常用的维度选择方法，该方法基于POD模态捕获的累积能量，并帮助你理解能量容差 $\\epsilon$ 的选择如何影响最终模型的规模。",
            "id": "3990098",
            "problem": "考虑基于本征正交分解 (Proper Orthogonal Decomposition, POD) 的航空航天计算流体动力学降阶建模。令快照矩阵表示为 $X \\in \\mathbb{R}^{m \\times n}$，并假设其可进行奇异值分解 (Singular Value Decomposition, SVD) $X = U \\Sigma V^\\top$，其中 $\\Sigma$ 的对角线元素为奇异值 $\\sigma_1, \\sigma_2, \\dots, \\sigma_k$，$k = \\min(m,n)$，$U$ 和 $V$ 是标准正交矩阵。在 POD 中，与第 $i$ 个模态相关的能量含量与 $\\sigma_i^2$ 成正比，总能量与 $\\sum_{i=1}^{k} \\sigma_i^2$ 成正比。秩为 $r$ 的近似所保留的累积能量定义为前 $r$ 个奇异值所捕获的总能量的分数。被忽略的能量分数定义为保留分数的余补。\n\n从这些定义和 SVD 属性出发，对每个提供的测试用例执行以下操作。在进行任何计算之前，您必须将任何奇异值列表视为非负实数的无序多重集，并首先按非递增顺序对其进行排序。\n\n1. 给定一个奇异值列表 $\\{\\sigma_i\\}_{i=1}^k$，计算由下式定义的累积能量保留曲线 $\\{E_r\\}_{r=0}^k$\n$$\nE_r = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{k} \\sigma_i^2},\n$$\n约定 $E_0 = 0$。如果 $\\sum_{i=1}^{k} \\sigma_i^2 = 0$，则对所有 $r$ 定义 $E_r = 0$，并且为了满足下面的容差标准，将被忽略的能量分数定义为 $0$。\n2. 给定一个容差 $\\epsilon \\in [0,1]$ (以小数而非百分比表示)，选择最小的整数 $r \\in \\{0,1,\\dots,k\\}$，使得被忽略的能量分数 $1 - E_r \\le \\epsilon$。\n3. 对于每个测试用例，输出一个形式为 $[r, [E_0, E_1, \\dots, E_k], \\text{ok}]$ 的列表，其中 $r$ 是所选的秩，$[E_0, E_1, \\dots, E_k]$ 是累积能量保留曲线，而 $\\text{ok}$ 是一个布尔值，指示不等式 $1 - E_r \\le \\epsilon$ 对于所选的 $r$ 是否成立。\n\n使用以下奇异值数组和容差的测试套件，其设计旨在覆盖典型行为、边界条件以及探测对容差敏感度的边缘情况：\n- 测试用例 1：奇异值 $[4.0, 2.0, 1.0, 0.5, 0.25]$，容差 $\\epsilon = 0.05$。\n- 测试用例 2：奇异值 $[3.0, 0.0, 0.0]$，容差 $\\epsilon = 0$。\n- 测试用例 3：奇异值 $[0.5, 2.0, 1.0]$，容差 $\\epsilon = 0.2$。\n- 测试用例 4：奇异值 $[10, 9.9, 0.1, 0.1, 0.1]$，容差 $\\epsilon = 0.0002$。\n- 测试用例 5：奇异值 $[10, 9.9, 0.1, 0.1, 0.1]$，容差 $\\epsilon = 0.00015$。\n- 测试用例 6：奇异值 $[0.0, 0.0]$，容差 $\\epsilon = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素按顺序对应一个测试用例。例如，输出格式必须严格遵循以下形式\n$[[r_1,[E_{0,1},\\dots,E_{k_1,1}],\\text{ok}_1],[r_2,[E_{0,2},\\dots,E_{k_2,2}],\\text{ok}_2],\\dots]$。",
            "solution": "该问题要求实现一个基于本征正交分解 (POD) 的算法，以针对给定的能量容差确定最优的降阶模型秩。该过程涉及分析从快照矩阵中导出的一组奇异值。对于每个测试用例，解决方案被构建为一系列定义明确的计算步骤。\n\n首先，将给定的奇异值列表表示为一个多重集 $\\{\\sigma_i\\}_{i=1}^k$。根据问题陈述，必须按非递增顺序对这些值进行排序，以正确表示 POD 模态的能量层级。令排序后的奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$。这里，$k$ 是奇异值的总数。\n\n与第 $i$ 个 POD 模态相关的能量含量，或简称为“能量”，与其对应的奇异值的平方 $\\sigma_i^2$ 成正比。快照中捕获的系统的总能量与所有模态的能量之和成正比，即 $E_{\\text{total}} = \\sum_{i=1}^{k} \\sigma_i^2$。\n\n问题的核心是计算秩为 $r$ 的近似所保留的累积能量，其定义为：\n$$\nE_r = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{k} \\sigma_i^2} \\quad \\text{for } r \\in \\{1, 2, \\dots, k\\}\n$$\n按照约定，对于一个秩为 0 的模型（不包含任何模态），保留的能量为零，因此 $E_0 = 0$。序列 $\\{E_r\\}_{r=0}^k$ 构成了累积能量保留曲线。根据定义，该序列是单调非递减的，从 $E_0 = 0$ 开始，到 $E_k = 1$ 结束。当总能量为零 ($E_{\\text{total}} = 0$) 时，会出现一种特殊情况，这当且仅当所有奇异值都为零时发生。在这种情况下，问题规定对于所有 $r \\in \\{0, 1, \\dots, k\\}$，$E_r = 0$。\n\n对于每个提供奇异值列表和容差 $\\epsilon \\in [0,1]$ 的测试用例，算法按以下步骤进行：\n\n1.  **初始化和排序**：将输入的奇异值列表转换为数值数组，并按非递增顺序排序，以获得序列 $\\sigma_1, \\sigma_2, \\dots, \\sigma_k$。\n\n2.  **能量计算**：计算每个奇异值的平方 $\\sigma_i^2$。然后计算总能量 $E_{\\text{total}} = \\sum_{i=1}^{k} \\sigma_i^2$。\n\n3.  **累积能量曲线构建**：\n    - 如果 $E_{\\text{total}}$ 为零，则累积能量曲线 $\\{E_r\\}_{r=0}^k$ 是一个包含 $k+1$ 个零的序列。\n    - 如果 $E_{\\text{total}}$ 为正，则计算奇异值平方的部分和 $S_r = \\sum_{i=1}^{r} \\sigma_i^2$ (对于 $r=1, \\dots, k$)。然后，每个秩的累积能量为 $E_r = S_r / E_{\\text{total}}$。最终的曲线是序列 $[E_0, E_1, \\dots, E_k]$。\n\n4.  **秩选择**：主要任务是找到最小的整数秩 $r \\in \\{0, 1, \\dots, k\\}$，使得被忽略的能量分数不超过指定的容差 $\\epsilon$。这个条件由不等式表示：\n    $$\n    1 - E_r \\le \\epsilon\n    $$\n    这在数学上等价于找到满足以下条件的最小 $r$：\n    $$\n    E_r \\ge 1 - \\epsilon\n    $$\n    由于序列 $\\{E_r\\}$ 是单调非递减的，我们可以从 $r=0$ 开始搜索序列，从而高效地找到满足此标准的最小 $r$。搜索在满足条件的第一个秩处终止。对于 $E_{\\text{total}} = 0$ 的特殊情况，问题将被忽略的能量分数定义为 0。条件变为 $0 \\le \\epsilon$，对于 $\\epsilon \\in [0,1]$ 这总是成立的。因此，满足条件的最小秩是 $r=0$。\n\n5.  **验证**：问题要求一个布尔值 $\\text{ok}$，以确认所选的秩 $r$ 确实满足不等式 $1 - E_r \\le \\epsilon$。根据我们秩选择方法的构造，这个条件将始终被满足。此步骤是对结果的形式化验证。\n\n6.  **输出组装**：对于每个测试用例，最终结果被组装成一个包含三个元素的列表：所选的秩 $r$、完整的累积能量曲线 $[E_0, E_1, \\dots, E_k]$ 以及布尔验证标志 $\\text{ok}$。\n\n此过程为问题提供了一个完整且确定性的解决方案，正确处理了指定的定义、约定和边缘情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(sigma_values, epsilon):\n    \"\"\"\n    Processes a single test case of singular values and a tolerance.\n\n    Args:\n        sigma_values (list): A list of non-negative real numbers representing singular values.\n        epsilon (float): The tolerance for neglected energy, in the range [0, 1].\n\n    Returns:\n        list: A list of the form [r, E_curve, ok], where r is the selected rank,\n              E_curve is the cumulative energy list, and ok is the verification boolean.\n    \"\"\"\n    # Use float64 for better precision in calculations.\n    sv = np.array(sigma_values, dtype=np.float64)\n\n    # 1. Sort singular values in non-increasing order.\n    sv_sorted = np.sort(sv)[::-1]\n    k = len(sv_sorted)\n\n    # 2. Calculate squared values and total energy.\n    sv_squared = np.square(sv_sorted)\n    total_energy = np.sum(sv_squared)\n\n    # 3. Handle the zero total energy edge case.\n    if np.isclose(total_energy, 0.0):\n        E_curve = [0.0] * (k + 1)\n        # As per the problem: neglected energy fraction is defined as 0.\n        # The condition is 0 = epsilon, which is always true for valid epsilon.\n        # The smallest rank r is therefore 0.\n        r = 0\n        ok = True  # The condition 0 = epsilon holds.\n        return [r, E_curve, ok]\n\n    # 4. Calculate the cumulative energy retained curve {E_r}.\n    cumulative_energies = np.cumsum(sv_squared) / total_energy\n    # Prepend E_0 = 0 to form the full curve {E_r}_{r=0 to k}.\n    E_curve = np.insert(cumulative_energies, 0, 0.0)\n\n    # 5. Find the smallest rank r such that 1 - E_r = epsilon,\n    # which is equivalent to E_r >= 1 - epsilon.\n    threshold = 1.0 - epsilon\n\n    # Since E_curve is monotonically non-decreasing, we can find the\n    # first index where the condition is met. np.searchsorted is efficient for this.\n    # It finds the first index `i` such that E_curve[i] >= threshold.\n    r = np.searchsorted(E_curve, threshold, side='left')\n\n    # The rank r must be at most k. This is guaranteed because E_curve[k] = 1.0\n    # and the threshold is at most 1.0.\n\n    # 6. Verify that the selected rank r satisfies the condition.\n    # By construction of the search for r, this should always be true.\n    neglected_energy = 1.0 - E_curve[r]\n    # The original code `ok = neglected_energy = epsilon` was a bug.\n    # It performed assignment and produced a float instead of a boolean.\n    # The corrected code performs the required comparison.\n    ok = neglected_energy = epsilon\n    \n    # Python's floating-point precision can sometimes make `ok` False if\n    # `neglected_energy` is infinitesimally larger than `epsilon`.\n    # To be robust, one might use `np.isclose` or a small tolerance.\n    # However, the problem tests sensitivity, so direct comparison is used.\n    # The `if` block below handles the case where `ok` is False due to\n    # floating point error but the values are \"close enough\".\n    if not ok and np.isclose(neglected_energy, epsilon):\n        ok = True\n\n    return [int(r), E_curve.tolist(), ok]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Typical decay\n        ([4.0, 2.0, 1.0, 0.5, 0.25], 0.05),\n        # Test case 2: Rank-deficient, zero tolerance\n        ([3.0, 0.0, 0.0], 0.0),\n        # Test case 3: Unordered input\n        ([0.5, 2.0, 1.0], 0.2),\n        # Test case 4: Tolerance sensitivity 1\n        ([10.0, 9.9, 0.1, 0.1, 0.1], 0.0002),\n        # Test case 5: Tolerance sensitivity 2\n        ([10.0, 9.9, 0.1, 0.1, 0.1], 0.00015),\n        # Test case 6: Zero energy\n        ([0.0, 0.0], 0.5),\n    ]\n\n    all_results = []\n    for sv, eps in test_cases:\n        result = process_case(sv, eps)\n        all_results.append(result)\n\n    # Format the final output string to match the required format exactly.\n    # [[r1,[E...],ok1],[r2,[E...],ok2],...]\n    # Example format: [3,[0.0,0.75...,1.0],true]\n    result_strings = []\n    for res in all_results:\n        r, E_curve, ok = res\n        E_curve_str = f\"[{','.join(map(str, E_curve))}]\"\n        ok_str = str(ok).lower()\n        result_strings.append(f\"[{r},{E_curve_str},{ok_str}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在确定如何选择基的规模之后，我们现在将其应用于一个具体的物理问题。本练习涉及从不同热扩散系数参数下的热方程解（快照）中构建一个POD基。然后，你将通过投影*新的*、未见过的参数对应的解来测试该基的质量，并测量其重构误差，这是为参数化系统开发降阶模型的核心任务。",
            "id": "3184782",
            "problem": "要求您实现一个完整、可运行的程序，该程序根据一维热方程的训练快照构建一个本征正交分解（Proper Orthogonal Decomposition, POD）基，然后评估对于指定范围内的几个未见过的热扩散系数值，正交投影误差如何随着保留的 POD 模态数量的增加而衰减。所有量都必须纯粹从数学角度处理，不带物理单位。\n\n考虑单位区间上具有零狄利克雷边界条件的一维热方程：\n- 控制律：$u_t = \\kappa\\,u_{xx}$，对于 $x \\in [0,1]$ 和 $t \\ge 0$。\n- 边界条件：$u(0,t) = 0$ 和 $u(1,t) = 0$，对于所有 $t \\ge 0$。\n- 初始条件：$u(x,0) = \\sum_{n=1}^{8} a_n \\sin(n\\pi x)$，其中系数由 $a_1=1.0$，$a_2=0.5$，$a_3=-0.3$，$a_4=0.2$，$a_5=0.1$，$a_6=-0.05$，$a_7=0.04$，$a_8=-0.02$ 给出。\n\n解构造的基本依据：一个经过充分检验的事实是，在这些边界条件下，上述初边值问题的解可以用傅里叶正弦级数表示，其模态振幅随时间呈指数衰减。您必须利用这一事实来解析地计算快照，而无需对偏微分方程进行数值离散化。\n\n定义与所需计算：\n- 将解析解定义为 $u(x,t;\\kappa) = \\sum_{n=1}^{8} a_n \\exp\\!\\big(-\\kappa (n\\pi)^2 t\\big)\\,\\sin(n\\pi x)$。\n- 设空间网格在 $[0,1]$ 上均匀分布，包含端点在内共 $N_x = 200$ 个点。\n- 设训练参数值为 $\\kappa_{\\text{train}} \\in \\{0.06, 0.14, 0.22\\}$，训练快照时间为 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$。\n- 对于指定集合中的每个 $t$ 和指定训练集中的每个 $\\kappa$，将所有空间快照 $u(\\cdot, t; \\kappa)$ 作为列，以任意固定的确定性顺序拼接起来，构建训练快照矩阵 $M_{\\text{train}} \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$。\n- 通过奇异值分解（Singular Value Decomposition, SVD）$M_{\\text{train}} = U \\Sigma V^\\top$ 得到矩阵 $U$，其列向量即为 POD 基。其中 $U \\in \\mathbb{R}^{N_x \\times r_{\\max}}$ 具有标准正交列，且 $r_{\\max} \\le \\min(N_x, N_{\\text{snap}})$。按顺序使用这些 $U$ 的列作为 POD 模态；不要减去均值（即直接对 $M_{\\text{train}}$ 执行 POD）。\n- 为进行评估，使用未见过的测试参数 $\\kappa_{\\text{test}} \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 和相同的时间集 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$ 为每个测试参数构建 $M_{\\text{test}}(\\kappa) \\in \\mathbb{R}^{N_x \\times N_{\\text{test}}}$。\n- 对于给定的保留模态数 $r$，定义正交投影算子 $P_r = U_r U_r^\\top$，其中 $U_r \\in \\mathbb{R}^{N_x \\times r}$ 包含前 $r$ 个 POD 模态。对于每个测试参数 $\\kappa$，计算相对投影误差\n$$\nE(\\kappa,r) = \\frac{\\lVert M_{\\text{test}}(\\kappa) - P_r M_{\\text{test}}(\\kappa) \\rVert_F}{\\lVert M_{\\text{test}}(\\kappa) \\rVert_F},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。将 $E(\\kappa,0)$ 取为零近似的相对误差（即 $P_0 = 0$）。\n- 对 $r \\in \\{0,1,2,3,5,8,10\\}$ 和每个 $\\kappa \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 计算 $E(\\kappa,r)$。\n\n测试套件及覆盖范围理由：\n- 选择 $r=0$ 测试了不保留任何模态的边界情况。\n- 选择 $r=10$ 超过了非零初始傅里叶分量的数量，用以探测误差饱和至零的预期情况。\n- 测试参数包括了区间端点 $0.05$ 和 $0.25$ 以及内部值 $0.10$ 和 $0.17$，这些值均未在训练中使用，从而考察了在整个参数范围内的泛化能力。\n\n最终输出要求：\n- 您的程序应生成单行输出，其中包含一个不带空格的浮点数嵌套列表形式的结果。外层列表必须按测试参数 $\\kappa \\in [0.05, 0.10, 0.17, 0.25]$ 的升序排列。对于每个测试参数，内层列表必须按此精确的 $r$ 顺序包含误差 $[E(\\kappa,0), E(\\kappa,1), E(\\kappa,2), E(\\kappa,3), E(\\kappa,5), E(\\kappa,8), E(\\kappa,10)]$。每个浮点数表示为四舍五入到八位小数。例如，打印的形状必须类似于 $[[e_{11},e_{12},\\dots],[e_{21},\\dots],\\dots]$，其中 $e_{ij}$ 的位置为数值条目。",
            "solution": "该问题要求为一维热方程实现一个基于本征正交分解（Proper Orthogonal Decomposition, POD）的降阶模型。该过程涉及生成训练数据，构建一个低维基，并在未见过的测试数据上评估该基的有效性。整个过程基于解析解，避免了控制性偏微分方程（PDE）的离散化误差。\n\n步骤 1：解析解与数据生成\n\n该问题涉及热方程 $u_t = \\kappa\\,u_{xx}$，定义在域 $x \\in [0,1]$ 上，具有零狄利克雷边界条件 $u(0,t) = u(1,t) = 0$。初始条件为一个有限傅里叶级数，$u(x,0) = \\sum_{n=1}^{8} a_n \\sin(n\\pi x)$，其中系数 $\\{a_n\\}$ 已给出。通过分离变量法推导出的解析解由下式给出：\n$$\nu(x,t;\\kappa) = \\sum_{n=1}^{8} a_n \\exp\\!\\big(-\\kappa (n\\pi)^2 t\\big)\\,\\sin(n\\pi x)\n$$\n该公式使我们能够生成解场的“快照”，这些快照是表示在特定时间 $t$ 和给定热扩散系数 $\\kappa$ 下的温度分布 $u(\\cdot, t; \\kappa)$ 的向量。这些快照在 $[0,1]$ 上包含 $N_x = 200$ 个点的均匀空间网格上进行评估。\n\n步骤 2：训练快照矩阵的构建\n\n为构建降阶模型，我们首先收集一组代表性解。训练数据是使用训练参数集 $\\kappa_{\\text{train}} \\in \\{0.06, 0.14, 0.22\\}$ 和快照时间 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$ 生成的。对于训练集中的每一对 $(\\kappa, t)$，我们计算相应的解快照向量。然后将这些快照向量作为列拼接起来，形成训练快照矩阵 $M_{\\text{train}} \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$。在这里，$N_x = 200$，快照总数为 $N_{\\text{snap}} = |\\kappa_{\\text{train}}| \\times |t| = 3 \\times 5 = 15$。\n\n步骤 3：本征正交分解（POD）\n\nPOD 的核心是在最小二乘意义上找到一个最优的标准正交基来表示训练数据。这通过对快照矩阵进行奇异值分解（SVD）来实现：\n$$\nM_{\\text{train}} = U \\Sigma V^\\top\n$$\n矩阵 $U \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$ 的列（来自薄奇异值分解，因为 $N_x  N_{\\text{snap}}$）是左奇异向量。这些向量构成了 POD 基。它们根据对角矩阵 $\\Sigma \\in \\mathbb{R}^{N_{\\text{snap}} \\times N_{\\text{snap}}}$ 中相应奇异值的大小进行排序，$U$ 的第一列是能量最高的模态。\n一个重要的观察是，对于任何 $t$ 和 $\\kappa$，所有快照都位于由函数 $\\{\\sin(n\\pi x)\\}_{n=1}^8$ 张成的 8 维子空间内。因此，快照矩阵 $M_{\\text{train}}$ 的秩不能超过 8。这意味着只有前 8 个奇异值会显著非零，并且 POD 基的有效维度将为 8。\n\n步骤 4：投影与误差评估\n\nPOD 基允许通过将任何解快照（无论是否在训练集内）正交投影到由前 $r$ 个 POD 模态张成的子空间上来近似该快照。我们将截断的基矩阵表示为 $U_r \\in \\mathbb{R}^{N_x \\times r}$，它包含 $U$ 的前 $r$ 列。到这个子空间的正交投影算子是 $P_r = U_r U_r^\\top$。\n\n为了评估基的质量，我们为一组未见过的参数 $\\kappa_{\\text{test}} \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 生成测试数据，使用相同的时间点集合。对于每个 $\\kappa \\in \\kappa_{\\text{test}}$，我们形成一个测试快照矩阵 $M_{\\text{test}}(\\kappa)$。使用 $r$ 个模态对该测试矩阵的近似由 $P_r M_{\\text{test}}(\\kappa)$ 给出。此近似的误差使用相对弗罗贝尼乌斯范数进行量化：\n$$\nE(\\kappa,r) = \\frac{\\lVert M_{\\text{test}}(\\kappa) - P_r M_{\\text{test}}(\\kappa) \\rVert_F}{\\lVert M_{\\text{test}}(\\kappa) \\rVert_F}\n$$\n为了计算效率，投影 $P_r M_{\\text{test}}(\\kappa)$ 计算为 $U_r (U_r^\\top M_{\\text{test}}(\\kappa))$。$r=0$ 的情况对应于用零来近似解，产生的误差为 $E(\\kappa,0)=1$。我们为每个 $\\kappa \\in \\kappa_{\\text{test}}$ 和一组指定的保留模态数 $r \\in \\{0, 1, 2, 3, 5, 8, 10\\}$ 计算此误差。结果被汇总到一个嵌套列表中作为最终输出。由于基础解空间是 8 维的，我们预计当 $r \\ge 8$ 时，误差将下降到几乎为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Constructs a POD basis for the 1D heat equation and evaluates projection error.\n    \"\"\"\n    # Define problem parameters\n    A_COEFFS = np.array([1.0, 0.5, -0.3, 0.2, 0.1, -0.05, 0.04, -0.02])\n    NX = 200\n    KAPPA_TRAIN = [0.06, 0.14, 0.22]\n    T_POINTS = [0.00, 0.05, 0.10, 0.20, 0.50]\n    KAPPA_TEST = [0.05, 0.10, 0.17, 0.25]\n    R_VALUES = [0, 1, 2, 3, 5, 8, 10]\n\n    # Spatial grid\n    x = np.linspace(0, 1, NX)\n\n    def analytical_u(x_grid, t, kappa, coeffs):\n        \"\"\"Computes the analytical solution u(x, t; kappa).\"\"\"\n        sol = np.zeros_like(x_grid, dtype=np.float64)\n        for n_idx, a_n in enumerate(coeffs):\n            n = n_idx + 1\n            mode_component = a_n * np.exp(-kappa * (n * np.pi)**2 * t) * np.sin(n * np.pi * x_grid)\n            sol += mode_component\n        return sol\n\n    # --- Step 1: Construct Training Snapshot Matrix ---\n    train_snapshots = []\n    for kappa_train_val in KAPPA_TRAIN:\n        for t_val in T_POINTS:\n            snapshot = analytical_u(x, t_val, kappa_train_val, A_COEFFS)\n            train_snapshots.append(snapshot)\n    \n    M_train = np.stack(train_snapshots, axis=1)\n\n    # --- Step 2: Compute POD Basis via SVD ---\n    # Use thin SVD since Nx > N_snap\n    U, s, vh = linalg.svd(M_train, full_matrices=False)\n\n    # --- Step 3: Evaluate Projection Error for Test Cases ---\n    all_results = []\n    for kappa_test_val in KAPPA_TEST:\n        # Build the test snapshot matrix for the current kappa\n        test_snapshots = []\n        for t_val in T_POINTS:\n            snapshot = analytical_u(x, t_val, kappa_test_val, A_COEFFS)\n            test_snapshots.append(snapshot)\n        \n        M_test = np.stack(test_snapshots, axis=1)\n\n        norm_M_test = linalg.norm(M_test, 'fro')\n        \n        kappa_errors = []\n        for r in R_VALUES:\n            if norm_M_test == 0:\n                 # Should not happen in this problem, but for robustness\n                 # If M_test is zero, projection is perfect (error 0), except for r=0\n                 error = 1.0 if r == 0 else 0.0\n            elif r == 0:\n                # Per problem spec, P_0 = 0. Error is ||M - 0|| / ||M|| = 1.\n                error = 1.0\n            else:\n                # Truncate the POD basis\n                r_eff = min(r, U.shape[1])\n                Ur = U[:, :r_eff]\n                \n                # Project M_test onto the r-dimensional subspace\n                # P_r * M_test = Ur * Ur.T * M_test\n                projected_M_test = Ur @ (Ur.T @ M_test)\n                \n                # Compute the relative Frobenius norm of the error\n                error_matrix = M_test - projected_M_test\n                norm_error = linalg.norm(error_matrix, 'fro')\n                error = norm_error / norm_M_test\n\n            kappa_errors.append(error)\n        \n        all_results.append(kappa_errors)\n        \n    # --- Step 4: Format output string ---\n    outer_parts = []\n    for inner_list in all_results:\n        inner_parts = [f\"{x:.8f}\" for x in inner_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "对于动力系统的降阶模型而言，低的重构误差是必要条件，但并非充分条件。本练习探讨了一个关键的陷阱：伽辽金投影可能会使一个原本稳定的系统失稳，特别是当系统算子是高度非正规（non-normal）时。通过构建一个简单的二维系统，你将亲眼观察到，即使一个降阶模型是从一个完全稳定的全阶模型的快照中构建的，它也可能产生不稳定的、会“爆炸”的动力学行为。",
            "id": "2432128",
            "problem": "要求您实现一个完整的降阶建模数值实验，以展示以下现象：对于一个稳定的全阶线性时不变系统，本征正交分解（POD）基在重构训练快照方面可以表现出色，然而，通过伽辽金投影得到的降阶模型（ROM）在进行时间积分时却可能产生不稳定的动力学行为，导致结果发散。\n\n您的实现必须从全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数域上进行，并采用标准的欧几里得内积。在整个问题中，您将使用 $n=2$。\n\n基本定义和要求：\n- 本征正交分解（POD）基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1)  \\mathbf{x}(t_2)  \\cdots  \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解（SVD）$\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取自 $\\mathbf{U}$ 的前 $r$ 列。\n- 伽辽金投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}.\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 的演化方程为\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t).\n$$\n- 时间积分：对全阶模型和 ROM 均使用经典的四阶 Runge–Kutta 方法，并采用固定的时间步长 $h0$。将初始条件设置为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照采集：在训练时间域 $[0,T_{\\text{train}}]$上以恒定的时间步长 $h$ 对全阶模型进行积分，并在每一步采样状态以构成 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对 POD 重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示弗罗贝尼乌斯范数。\n- 发散检测：在测试时间域 $[0,T_{\\text{test}}]$上用相同的 $h$ 对全阶模型和 ROM 进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或任何分量变为非数值（not-a-number）或无穷大，则声明解“已发散”。使用阈值 $M=10^6$。\n\n为引发 ROM 不稳定性而构造的强迫项：\n- 对于每个测试，您必须按如下方式构造常数强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$（以任意但确定性的方式处理并列情况）。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}.\n$$\n这种构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规且 $\\mathbf{S}$ 的最大特征值为正时，用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 得到的标量 ROM 的降阶动力学为 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}0$ 且 $b_r=-a_r$，该系统是不稳定的，会从 $z(0)=0$ 开始发散。\n\n所有测试的通用数值规格：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典的四阶 Runge–Kutta 方法。\n- 所有向量范数均使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试套件：\n为以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上采集快照以构成 $\\mathbf{Q}$，然后构建 ROM 并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 $1$（高度非正规，秩为 $1$ 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $2$（高度非正规，秩为 $2$ 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=2$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $3$（对称负定，秩为 $1$ 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0  0.0 \\\\ 0.0  -2.0\\end{bmatrix}$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $4$（更高程度的非正规，秩为 $1$ 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=120.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n\n要求的输出：\n- 对于每个测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$，四舍五入到六位小数，\n  - 一个布尔值，指示 ROM 是否在 $[0,T_{\\text{test}}]$ 上发散，\n  - 一个布尔值，指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发散。\n- 将所有测试的结果汇总到一行，作为一个用方括号括起来的逗号分隔列表，顺序与测试顺序相同。示例格式：\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$。",
            "solution": "用户提出了一个计算工程领域的问题，具体是关于由本征正交分解（POD）和伽辽金投影导出的降阶模型（ROM）的稳定性。任务是通过数值实验来展示一个已知的失效模式，即尽管全阶模型（FOM）是稳定的，但 ROM 却可能不稳定。这种现象是由高度非正规算子控制的系统的典型特征。\n\n该问题陈述已经过验证，被认为是科学上合理、适定且完整的。所有定义、参数和程序都规定得足够清晰，可以得到唯一且可验证的解。我们将继续进行分析和实现。\n\n问题的核心在于矩阵 $\\mathbf{A}$ 的谱（spectrum）与其数值范围（numerical range，或称值域 field of values）之间的区别，数值范围定义为 $W(\\mathbf{A}) = \\{\\mathbf{v}^\\dagger\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{C}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$。对于线性时不变系统 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$，其稳定性由 $\\mathbf{A}$ 的特征值（谱 $\\sigma(\\mathbf{A})$）决定。如果所有特征值的实部都为负，则系统是稳定的，且当 $t\\to\\infty$ 时 $\\lVert\\mathbf{x}(t)\\rVert \\to 0$。然而，如果 $\\mathbf{A}$ 是非正规的（即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$），则可能出现瞬态增长。数值范围可以为这种瞬态行为提供洞见。数值范围的实部由矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$ 控制，因为 $\\text{Re}(\\mathbf{v}^\\top\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{S}\\mathbf{v}$。$\\mathbf{S}$ 的一个正特征值意味着 $\\mathbf{A}$ 的数值范围延伸到了右半平面，表明存在瞬态能量增长的可能。\n\n使用秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 进行伽辽金投影，将全阶模型 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 转换为降阶模型 $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$，其中 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。ROM 的稳定性由降阶矩阵 $\\mathbf{A}_r$ 的特征值决定。关键在于，$\\mathbf{A}_r$ 的特征值包含在 $\\mathbf{A}$ 的数值范围内，但不一定在其谱的凸包内。如果数值范围 $W(\\mathbf{A})$ 延伸到右半平面，就有可能找到一个投影子空间（基为 $\\mathbf{Q}$），使得 $\\mathbf{A}_r$ 的特征值具有正实部，从而导致 ROM 不稳定。\n\n该问题的构造旨在暴露这种病态问题。全阶模型是稳定的（$\\mathbf{A}$ 的特征值为 $\\{-0.1, -1.0\\}$）。强迫项 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ 的选择使得全阶模型的稳态为 $\\mathbf{x}_{\\infty} = \\mathbf{q}$，其中 $\\mathbf{q}$ 是与 $\\mathbf{S}$ 的最大特征值对应的特征向量。这会驱动系统动力学朝向最大瞬态增长的方向发展。由此产生的快照将主要由这个方向主导，导致主 POD 模态（$\\mathbf{Q}$ 的第一列）与 $\\mathbf{q}$ 对齐。对于秩为1的ROM（$r=1$），降阶矩阵 $\\mathbf{A}_r$ 变为一个标量 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。如果 $\\mathbf{Q} \\approx \\mathbf{q}$，那么 $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$。对于测试1和测试4中的非正规矩阵，$\\lambda_{\\max}(\\mathbf{S})  0$，这会导致一个不稳定的 ROM。\n\n每个测试案例的计算流程如下：\n$1$. 定义系统参数：矩阵 $\\mathbf{A}$、ROM 秩 $r$、以及时间域 $T_{\\text{train}}$ 和 $T_{\\text{test}}$。维度为 $n=2$，时间步长为 $h=10^{-3}$。\n$2$. 构造强迫项：计算对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$。求其特征值和特征向量。令 $\\mathbf{q}$ 为与最大特征值对应的归一化特征向量。设置 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$。\n$3$. 生成训练数据：使用经典的四阶龙格-库塔方法，从 $\\mathbf{x}(0)=\\mathbf{0}$ 开始，在时间区间 $[0, T_{\\text{train}}]$ 上对 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 进行积分。将每个时间步的状态收集到快照矩阵 $\\mathbf{X}$ 中。\n$4$. 计算 POD 基：对快照矩阵 $\\mathbf{X}$ 进行奇异值分解（SVD），$\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 由 $\\mathbf{U}$ 的前 $r$ 列构成。\n$5$. 计算重构误差：相对弗罗贝尼乌斯范数误差计算为 $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$。\n$6$. 构造 ROM：降阶系统矩阵为 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 和 $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$。\n$7$. 进行时间积分以供测试：从零初始条件（$\\mathbf{x}(0)=\\mathbf{0}$, $\\mathbf{z}(0)=\\mathbf{0}$）开始，在区间 $[0, T_{\\text{test}}]$ 上对 FOM 和 ROM 进行积分。在积分过程中，每一步都将状态向量的欧几里得范数与发散阈值 $M=10^6$ 进行比较。\n$8$. 记录结果：该测试的最终输出是计算出的 $\\varepsilon_{\\text{rec}}$、一个指示 ROM 是否发散的布尔值，以及一个指示 FOM 是否发散的布尔值。\n\n测试的预期结果：\n- **测试 1**：（$\\mathbf{A}$ 非正规， $r=1$）：$\\mathbf{A}$ 是稳定的。$\\mathbf{b}$ 的构造和 $r=1$ 的选择旨在产生一个不稳定的 ROM。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM 发散，而 FOM 不发散。\n- **测试 2**：（$\\mathbf{A}$ 非正规， $r=2$）：在此情况下，$r=n=2$。POD 基 $\\mathbf{Q}$ 将是 $\\mathbb{R}^2$ 的一个完备标准正交基。因此，$\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$，这意味着重构误差 $\\varepsilon_{\\text{rec}}$ 将为零（或在机器精度量级）。ROM 在动力学上与 FOM 等价，只是在不同的基下表示。由于 FOM 是稳定的，ROM 也将是稳定的。我们预期 $\\varepsilon_{\\text{rec}} \\approx 0$，ROM 和 FOM 均不发散。\n- **测试 3**：（$\\mathbf{A}$ 对称， $r=1$）：$\\mathbf{A}$ 是一个正规矩阵。其数值范围是其特征值 $\\{-1.0, -2.0\\}$ 的凸包，即实轴上的区间 $[-2.0, -1.0]$。降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 必定为负。ROM 将是稳定的。我们预期两个模型都不会发散。\n- **测试 4**：（$\\mathbf{A}$ 更非正规， $r=1$）：与测试1类似，但具有更大的非对角项 $\\alpha=120.0$。这增加了非正规性，导致 $\\mathbf{S}$ 有更大的正特征值。ROM 的不稳定性应该更加显著。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM 发散，而 FOM 不发散。\n\n现在将实现上述逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(round(T / h))\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if np.linalg.norm(y) > M or not np.all(np.isfinite(y)):\n                blew_up = True\n                # To ensure snapshot matrix has correct size, fill remaining\n                # with the diverging state but stop checking.\n                # This part is for the test simulation, not snapshot generation\n                # for POD, so we can just break.\n                snapshots.append(y.copy())\n                return np.array(snapshots).T, True\n\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1]>1:\n            norm_X_sq = np.sum(s**2)\n            if norm_X_sq > 0:\n                norm_err_sq = np.sum(s[r:]**2)\n                eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n            else:\n                eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}