{
    "hands_on_practices": [
        {
            "introduction": "本章节的第一个实践是奠基性的。我们将为一个简单的一维对流扩散问题实现离散伴随方法。本练习的主要目标是通过将解析推导的伴随灵敏度与有限差分得到的数值近似值进行比较，来验证实现的正确性，这是开发可靠的计算流体力学（CFD）代码的一项关键技能。",
            "id": "3941772",
            "problem": "考虑一个一维定常线性对流扩散模型，该模型在计算流体动力学（CFD, Computational Fluid Dynamics）中通常用作研究基于伴随的网格加密程序的简化设定。在单位区间域上的连续模型由作用于状态变量 $u(x)$ 的微分算子给出，\n$$\n-\\frac{d}{dx}\\left(\\kappa \\frac{du}{dx}\\right) + a \\frac{du}{dx} = s(x), \\quad x \\in (0,1),\n$$\n边界条件为狄利克雷边界条件 $u(0)=u_L$ 和 $u(1)=u_R$，其中 $\\kappa>0$ 是扩散系数，$a$ 是一个恒定的对流速度，$s(x)$ 是一个源项。在离散设置中，考虑一个包含 $N$ 个内部节点的均匀网格，其间距为 $\\Delta x = \\frac{1}{N+1}$，并设未知量向量为 $\\mathbf{u} \\in \\mathbb{R}^N$，表示内部节点 $x_i = i \\Delta x$（其中 $i=1,2,\\dots,N$）处的状态。\n\n对扩散项使用二阶中心差分，对对流项使用一阶迎风差分（对于所有测试用例，假设 $a>0$）。内部节点 $i$ 的离散残差为\n$$\nR_i(\\mathbf{u}) = -\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + a \\frac{u_i - u_{i-1}}{\\Delta x} - s_i,\n$$\n其中 $u_0 = u_L$ 和 $u_{N+1} = u_R$ 是已知的边界值。这产生了一个线性系统\n$$\n\\mathbf{A}\\,\\mathbf{u} = \\mathbf{s}_{\\text{eff}},\n$$\n其中 $\\mathbf{A} \\in \\mathbb{R}^{N \\times N}$ 是残差相对于 $\\mathbf{u}$ 的雅可比矩阵，而 $\\mathbf{s}_{\\text{eff}} \\in \\mathbb{R}^N$ 是包含物理源向量 $\\mathbf{s}$ 和边界贡献的有效源。\n\n定义一个目标泛函\n$$\nJ(\\mathbf{u}) = \\frac{1}{2} \\sum_{i=1}^{N} \\alpha_i \\, u_i^2 \\, \\Delta x,\n$$\n其中 $\\alpha_i = \\alpha(x_i)$ 是一个指定的非负权重。离散伴随状态 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^N$ 由以下线性系统定义\n$$\n\\mathbf{A}^\\top \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{u}},\n$$\n其中梯度 $\\frac{\\partial J}{\\partial \\mathbf{u}}$ 的分量为 $\\left(\\frac{\\partial J}{\\partial u_i}\\right) = \\alpha_i u_i \\Delta x$。对于以 $-\\mathbf{s}$ 形式进入残差的参数化源 $\\mathbf{s}$，根据离散伴随恒等式和链式法则，由于 $\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{s}} = -\\mathbf{I}$，$J$ 相对于 $\\mathbf{s}$ 的灵敏度为\n$$\n\\frac{dJ}{d\\mathbf{s}} = \\boldsymbol{\\lambda}。\n$$\n\n您的任务如下：\n- 对于上述对流扩散离散化，在正对流速度 $a>0$ 的情况下，构建 $\\mathbf{A}$，并组装包含狄利克雷边界条件 $u_L$ 和 $u_R$ 的 $\\mathbf{s}_{\\text{eff}}$。\n- 求解原始系统 $\\mathbf{A}\\,\\mathbf{u} = \\mathbf{s}_{\\text{eff}}$ 以获得 $\\mathbf{u}$。\n- 根据 $J$ 的定义，解析地计算梯度 $\\frac{\\partial J}{\\partial \\mathbf{u}}$。\n- 通过有限差分近似验证 $\\frac{\\partial J}{\\partial \\mathbf{u}}$ 的实现：对于施加到 $\\mathbf{u}$ 各分量上的微小扰动 $\\varepsilon$，将 $\\left(\\frac{\\partial J}{\\partial u_i}\\right)$ 近似为\n$$\n\\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} \\approx \\frac{J(\\mathbf{u} + \\varepsilon \\mathbf{e}_i) - J(\\mathbf{u})}{\\varepsilon},\n$$\n其中 $\\mathbf{e}_i$ 是 $\\mathbb{R}^N$ 中的第 $i$ 个标准基向量。\n- 求解离散伴随系统 $\\mathbf{A}^\\top \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{u}}$ 以获得 $\\boldsymbol{\\lambda}$。\n- 通过有限差分验证伴随法导出的 $J$ 相对于源 $\\mathbf{s}$ 的灵敏度：对于施加到 $\\mathbf{s}_{\\text{eff}}$ 各分量上的微小扰动 $\\delta$，将 $\\left(\\frac{dJ}{ds_j}\\right)$ 近似为\n$$\n\\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} \\approx \\frac{J(\\mathbf{u}^{(j,+)}) - J(\\mathbf{u})}{\\delta},\n$$\n其中 $\\mathbf{u}^{(j,+)}$ 是 $\\mathbf{A}\\,\\mathbf{u}^{(j,+)} = \\mathbf{s}_{\\text{eff}} + \\delta\\,\\mathbf{e}_j$ 的解。\n\n为每个测试用例报告一个标量结果，该结果定义为两个绝对误差度量的最大值：\n$$\nE_{\\text{grad}} = \\max_{i} \\left| \\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} - \\left(\\frac{\\partial J}{\\partial u_i}\\right) \\right|, \\quad\nE_{\\text{sens}} = \\max_{j} \\left| \\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} - \\lambda_j \\right|,\n$$\n最终报告值为 $\\max\\{E_{\\text{grad}}, E_{\\text{sens}}\\}$。\n\n所有量纲均为无量纲。不涉及角度。您的程序必须是一个完整的、可在指定环境中运行的程序，并且必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。数值扰动必须选择得足够小以准确近似导数，但又要足够大以避免灾难性舍入误差；所有测试用例使用相同的 $\\varepsilon$ 和 $\\delta$。\n\n使用以下测试套件：\n- 测试用例 1：$N=20$, $a=1.0$, $\\kappa=0.05$, $u_L=1.0$, $u_R=0.0$, $\\alpha(x) = \\exp\\left(-\\left(\\frac{x-0.5}{0.2}\\right)^2\\right)$，以及对所有 $i$ 都有 $s_i=0$。\n- 测试用例 2：$N=10$, $a=2.0$, $\\kappa=0.01$, $u_L=0.0$, $u_R=1.0$, $\\alpha(x) = 1$，以及对所有 $i$ 都有 $s_i=0$。\n- 测试用例 3：$N=50$, $a=0.5$, $\\kappa=0.10$, $u_L=0.2$, $u_R=0.2$, $\\alpha(x) = \\sin^2(\\pi x)$，以及对所有 $i$ 都有 $s_i=0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例列表中的顺序一致：例如 $[E_1,E_2,E_3]$，其中每个 $E_k$ 是为测试用例 $k$ 计算的标量 $\\max\\{E_{\\text{grad}}, E_{\\text{sens}}\\}$。",
            "solution": "该问题是有效的。它在偏微分方程数值分析和基于伴随的灵敏度分析等成熟领域具有科学依据。该问题是适定的、自包含的，并提供了构建唯一数值解所需的所有信息。下面我们对计算过程进行详细的推导和描述。\n\n### 1. 原始问题：离散化与系统组装\n\n控制方程是一个在域 $x \\in (0,1)$ 上的一维定常线性对流扩散方程：\n$$\n-\\frac{d}{dx}\\left(\\kappa \\frac{du}{dx}\\right) + a \\frac{du}{dx} = s(x)\n$$\n其中扩散系数 $\\kappa > 0$，对流速度 $a > 0$，源项为 $s(x)$。该域受狄利克雷边界条件 $u(0) = u_L$ 和 $u(1) = u_R$ 的约束。\n\n我们在一个具有 $N$ 个内部节点 $x_i = i \\Delta x$（$i=1, \\dots, N$）的均匀网格上离散化该方程，其中网格间距为 $\\Delta x = \\frac{1}{N+1}$。设 $u_i \\approx u(x_i)$ 为节点 $i$ 处的离散解。\n\n扩散项使用二阶中心差分格式进行离散化：\n$$\n-\\frac{d}{dx}\\left(\\kappa \\frac{du}{dx}\\right) \\bigg|_{x_i} \\approx -\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}\n$$\n\n对流项使用一阶迎风格式进行离散化。由于 $a > 0$，信息从左向右流动，因此我们使用后向差分：\n$$\na \\frac{du}{dx} \\bigg|_{x_i} \\approx a \\frac{u_i - u_{i-1}}{\\Delta x}\n$$\n\n结合这些离散化方法，内部节点 $i$ 的离散残差方程为 $R_i(\\mathbf{u}) = 0$，其中：\n$$\nR_i(\\mathbf{u}) = -\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + a \\frac{u_i - u_{i-1}}{\\Delta x} - s_i\n$$\n这里，$s_i = s(x_i)$。重新排列各项以对未知数 $u_j$ 进行分组，我们得到：\n$$\n\\left(-\\frac{\\kappa}{\\Delta x^2} - \\frac{a}{\\Delta x}\\right)u_{i-1} + \\left(\\frac{2\\kappa}{\\Delta x^2} + \\frac{a}{\\Delta x}\\right)u_i + \\left(-\\frac{\\kappa}{\\Delta x^2}\\right)u_{i+1} = s_i\n$$\n该方程对 $i = 1, \\dots, N$ 成立。边界值 $u_0 = u_L$ 和 $u_{N+1} = u_R$ 是已知的。我们将涉及这些已知值的项移到方程的右侧。这导出了一个线性方程组 $\\mathbf{A} \\mathbf{u} = \\mathbf{s}_{\\text{eff}}$。\n\n矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times N}$ 是一个三对角矩阵，其非零元素如下：\n- 主对角线 ($j=i$):\n$$A_{ii} = \\frac{2\\kappa}{\\Delta x^2} + \\frac{a}{\\Delta x}$$\n- 下对角线 ($j=i-1$):\n$$A_{i,i-1} = -\\frac{\\kappa}{\\Delta x^2} - \\frac{a}{\\Delta x}$$\n- 上对角线 ($j=i+1$):\n$$A_{i,i+1} = -\\frac{\\kappa}{\\Delta x^2}$$\n\n有效源向量 $\\mathbf{s}_{\\text{eff}} \\in \\mathbb{R}^N$ 包含了物理源 $s_i$ 和边界贡献：\n- 对于第一个节点 ($i=1$):\n$$(\\mathbf{s}_{\\text{eff}})_1 = s_1 - \\left(-\\frac{\\kappa}{\\Delta x^2} - \\frac{a}{\\Delta x}\\right)u_0 = s_1 + \\left(\\frac{\\kappa}{\\Delta x^2} + \\frac{a}{\\Delta x}\\right)u_L$$\n- 对于中间节点 ($1  i  N$):\n$$(\\mathbf{s}_{\\text{eff}})_i = s_i$$\n- 对于最后一个节点 ($i=N$):\n$$(\\mathbf{s}_{\\text{eff}})_N = s_N - \\left(-\\frac{\\kappa}{\\Delta x^2}\\right)u_{N+1} = s_N + \\frac{\\kappa}{\\Delta x^2}u_R$$\n\n通过求解该线性系统来求解状态向量 $\\mathbf{u}$，从而解决原始问题。\n\n### 2. 伴随问题与灵敏度分析\n\n目标泛函定义为：\n$$\nJ(\\mathbf{u}) = \\frac{1}{2} \\sum_{i=1}^{N} \\alpha_i u_i^2 \\Delta x\n$$\n其中 $\\alpha_i = \\alpha(x_i)$ 是一个非负权重。$J$ 相对于状态向量 $\\mathbf{u}$ 各分量的梯度可以直接计算：\n$$\n\\frac{\\partial J}{\\partial u_i} = \\frac{1}{2} \\alpha_i (2u_i) \\Delta x = \\alpha_i u_i \\Delta x\n$$\n\n离散伴随状态 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^N$ 是以下线性系统的解：\n$$\n\\mathbf{A}^\\top \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{u}}\n$$\n其中 $\\mathbf{A}^\\top$ 是原始系统矩阵的转置，右侧是上面导出的梯度分量向量。\n\n离散伴随方法的一个关键结果是，泛函 $J$ 相对于物理源项向量 $\\mathbf{s}$ 的灵敏度等于伴随状态向量 $\\boldsymbol{\\lambda}$。这是成立的，因为残差的定义包含项 $-\\mathbf{s}$，这意味着 $\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{s}} = -\\mathbf{I}$。推导表明 $\\frac{dJ}{d\\mathbf{s}} = \\boldsymbol{\\lambda}$。\n\n### 3. 通过有限差分进行验证\n\n为确保我们实现的正确性，我们使用有限差分近似来验证解析梯度和伴随法导出的灵敏度。\n\n**梯度验证：** 将解析梯度 $\\frac{\\partial J}{\\partial \\mathbf{u}}$ 与前向有限差分近似进行比较。对每个分量 $i$，我们计算：\n$$\n\\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} = \\frac{J(\\mathbf{u} + \\varepsilon \\mathbf{e}_i) - J(\\mathbf{u})}{\\varepsilon}\n$$\n其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量，$\\varepsilon$ 是一个微小扰动（例如 $\\varepsilon=10^{-7}$）。误差通过所有分量上的最大绝对差来量化：\n$$\nE_{\\text{grad}} = \\max_{i} \\left| \\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} - \\left(\\frac{\\partial J}{\\partial u_i}\\right) \\right|\n$$\n\n**灵敏度验证：** 将伴随法导出的灵敏度 $\\boldsymbol{\\lambda}$ 与 $J$ 相对于源项 $\\mathbf{s}$ 的灵敏度的有限差分近似进行比较。对每个分量 $j$，我们计算：\n$$\n\\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} = \\frac{J(\\mathbf{u}^{(j,+)}) - J(\\mathbf{u})}{\\delta}\n$$\n这里，$\\delta$ 是一个微小扰动（例如 $\\delta=10^{-7}$），而 $\\mathbf{u}^{(j,+)}$ 是源被扰动后的原始系统的解：$\\mathbf{A}\\,\\mathbf{u}^{(j,+)} = \\mathbf{s}_{\\text{eff}} + \\delta\\,\\mathbf{e}_j$。于是误差为：\n$$\nE_{\\text{sens}} = \\max_{j} \\left| \\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} - \\lambda_j \\right|\n$$\n\n每个测试用例的最终报告值是这两个误差度量的最大值，即 $\\max\\{E_{\\text{grad}}, E_{\\text{sens}}\\}$。该结果的数值较小，表明原始系统和伴随系统的实现都是正确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for the given test cases.\n    It sets up the test cases, iterates through them, calls a helper\n    function to process each one, and prints the final results.\n    \"\"\"\n\n    def process_case(params):\n        \"\"\"\n        Processes a single test case for the 1D advection-diffusion problem.\n        It assembles and solves the primal system, computes the goal functional\n        and its gradient, solves the adjoint system, and validates the results\n        using finite differences to compute the final error metric.\n        \"\"\"\n        N, a, kappa, u_L, u_R, alpha_func = params\n        s_vec = np.zeros(N)\n\n        # 0. Setup mesh and perturbation parameters\n        delta_x = 1.0 / (N + 1)\n        x_nodes = np.linspace(delta_x, 1.0 - delta_x, N)\n        \n        epsilon = 1e-7  # Perturbation for gradient validation\n        delta = 1e-7    # Perturbation for sensitivity validation\n\n        # 1. Assemble the primal system matrix A and effective source s_eff\n        diag_main = (2.0 * kappa / delta_x**2 + a / delta_x) * np.ones(N)\n        diag_upper = (-kappa / delta_x**2) * np.ones(N - 1)\n        diag_lower = (-kappa / delta_x**2 - a / delta_x) * np.ones(N - 1)\n        \n        A = np.diag(diag_main) + np.diag(diag_upper, k=1) + np.diag(diag_lower, k=-1)\n        \n        s_eff = np.copy(s_vec)\n        s_eff[0] += (kappa / delta_x**2 + a / delta_x) * u_L\n        s_eff[-1] += (kappa / delta_x**2) * u_R\n\n        # 2. Solve the primal system for the state vector u\n        u = solve_linear_system(A, s_eff)\n\n        # 3. Compute goal functional and its analytical gradient\n        alpha_vec = alpha_func(x_nodes)\n\n        def J_func(u_vec):\n            return 0.5 * np.sum(alpha_vec * u_vec**2 * delta_x)\n\n        grad_J_analytic = alpha_vec * u * delta_x\n        J_base = J_func(u)\n\n        # 4. Validate the gradient via finite differences\n        grad_J_fd = np.zeros(N)\n        for i in range(N):\n            u_pert = np.copy(u)\n            u_pert[i] += epsilon\n            J_pert = J_func(u_pert)\n            grad_J_fd[i] = (J_pert - J_base) / epsilon\n\n        E_grad = np.max(np.abs(grad_J_fd - grad_J_analytic))\n\n        # 5. Solve the discrete adjoint system for the adjoint vector\n        A_T = A.T\n        adjoint_vec = solve_linear_system(A_T, grad_J_analytic)\n\n        # 6. Validate the adjoint sensitivity via finite differences\n        sens_J_fd = np.zeros(N)\n        for j in range(N):\n            s_eff_pert = np.copy(s_eff)\n            s_eff_pert[j] += delta\n            u_pert_sens = solve_linear_system(A, s_eff_pert)\n            J_pert_sens = J_func(u_pert_sens)\n            sens_J_fd[j] = (J_pert_sens - J_base) / delta\n        \n        E_sens = np.max(np.abs(sens_J_fd - adjoint_vec))\n\n        # 7. Compute the final result for the test case\n        return max(E_grad, E_sens)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a, kappa, u_L, u_R, alpha_func)\n        (20, 1.0, 0.05, 1.0, 0.0, lambda x: np.exp(-((x - 0.5) / 0.2)**2)),\n        (10, 2.0, 0.01, 0.0, 1.0, lambda x: np.ones_like(x)),\n        (50, 0.5, 0.10, 0.2, 0.2, lambda x: np.sin(np.pi * x)**2)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在一维案例的基础上，这个实践将问题扩展到二维，并聚焦于误差估计。我们将使用制造解方法（Method of Manufactured Solutions, MMS）来验证基本的误差表达公式，该公式指出，对于线性问题，伴随加权的残差精确等于输出泛函的误差。这个练习展示了伴随方法如何为量化数值误差提供一个精确的工具。",
            "id": "3941740",
            "problem": "考虑单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上的稳态、线性、二维对流-扩散方程，其狄利克雷边界条件由一个构造的精确解给出。控制方程为\n$$\n-\\nabla\\cdot\\left(\\kappa \\nabla u\\right) + \\mathbf{a}\\cdot\\nabla u = q \\quad \\text{in } \\Omega,\n$$\n边界条件为 $\\partial \\Omega$ 上 $u = u^{\\star}$，其中 $\\kappa  0$ 是扩散系数，$\\mathbf{a} = (a_x, a_y)$ 是恒定对流速度，而 $q$ 是一个源项，其选择是为了使指定的平滑函数 $u^{\\star}$ 成为该连续偏微分方程的精确解。令构造的精确解为\n$$\nu^{\\star}(x,y) = \\sin(\\pi x)\\sin(\\pi y).\n$$\n根据梯度、散度和拉普拉斯算子的基本定义，计算源项 $q(x,y)$，使得 $u^{\\star}$ 满足该连续方程。使用一个均匀的笛卡尔网格，该网格具有 $N\\times N$ 个内部点，网格间距为 $h=\\frac{1}{N+1}$，坐标为 $x_i=(i+1)h, y_j=(j+1)h$，其中 $i,j\\in\\{0,\\dots,N-1\\}$。\n\n使用二阶中心差分对扩散项进行离散化，使用一阶迎风差分对对流项进行离散化。组装得到的线性系统\n$$\nA_h \\mathbf{u}_h = \\mathbf{b}_h,\n$$\n其中 $A_h$ 是离散的对流-扩散算子，$\\mathbf{u}_h$ 是内部节点上的未知量向量，$\\mathbf{b}_h$ 是离散的右端项，由在内部节点上计算的构造源项加上由离散格式引入的狄利克雷边界值贡献组成。将标量输出泛函定义为场量的域积分，\n$$\nJ(u) = \\int_{\\Omega} u(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y.\n$$\n在内部网格上使用以单元为中心的黎曼和来近似 $J$，\n$$\nJ_h(\\mathbf{u}_h) = \\mathbf{g}_h^\\top \\mathbf{u}_h, \\quad \\text{where} \\quad \\mathbf{g}_h = h^2\\,\\mathbf{1},\n$$\n其中 $\\mathbf{1}$ 是与 $\\mathbf{u}_h$ 大小相同的全1向量。\n\n通过求解转置系统来定义离散伴随 $\\boldsymbol{\\psi}_h$\n$$\nA_h^\\top \\boldsymbol{\\psi}_h = \\mathbf{g}_h.\n$$\n令精确解在内部网格上的限制为 $\\mathbf{u}^{\\star}_h$，通过在内部网格点上对 $u^{\\star}$ 进行采样获得。计算离散截断残差\n$$\n\\boldsymbol{\\tau}_h = A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h,\n$$\n以及基于伴随的输出误差指示子\n$$\n\\eta_h = \\boldsymbol{\\psi}_h^\\top \\boldsymbol{\\tau}_h.\n$$\n计算实际离散输出误差\n$$\n\\varepsilon_h = J_h(\\mathbf{u}^{\\star}_h) - J_h(\\mathbf{u}_h) = \\mathbf{g}_h^\\top (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h).\n$$\n从离散原始问题和伴随问题的线性代数表示以及输出泛函的定义出发，根据第一性原理推导在这种线性设定下 $\\eta_h$ 和 $\\varepsilon_h$ 之间的关系。然后，实现所描述的离散化和计算，通过报告比值\n$$\nr = \\frac{\\eta_h}{\\varepsilon_h}\n$$\n来数值验证基于伴随的指示子与实际输出误差成线性关系，对以下测试套件中的每种情况进行计算，并证明该比值在不同网格细化和参数变化下近似为常数。\n\n使用以下参数值 $(N,\\kappa,a_x,a_y)$ 的测试套件：\n- 案例1（一般对流-扩散，中等网格）：$(16,\\,0.05,\\,1.0,\\,0.4)$。\n- 案例2（混合符号对流，中等网格）：$(16,\\,0.05,\\,-0.7,\\,1.3)$。\n- 案例3（强对流，更细网格）：$(32,\\,0.01,\\,2.0,\\,-1.0)$。\n- 案例4（纯垂直对流，粗网格）：$(8,\\,0.1,\\,0.0,\\,1.0)$。\n\n所有计算都是无量纲的，因此不需要物理单位。你的程序应产生单行输出，包含四个案例的比值 $r$，形式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4]”）。输出必须以浮点数形式报告。",
            "solution": "问题陈述经评估有效。这是一个来自偏微分方程数值分析领域的适定且自洽的问题。其科学基础在于有限差分法和基于伴随的误差估计理论，并使用标准的构造解方法进行验证。所有参数、方程和数值方法都得到了清晰明确的定义。\n\n求解过程分三个阶段：\n1.  推导构造解所需的源项 $q(x,y)$。\n2.  解析推导实际输出误差 $\\varepsilon_h$ 与基于伴随的误差指示子 $\\eta_h$ 之间的关系。\n3.  详细说明要实现的数值离散格式。\n\n**1. 源项推导**\n\n连续控制方程为 $-\\nabla\\cdot\\left(\\kappa \\nabla u\\right) + \\mathbf{a}\\cdot\\nabla u = q$。我们给定常数扩散系数 $\\kappa  0$、常数对流速度矢量 $\\mathbf{a} = (a_x, a_y)$ 以及在域 $\\Omega = [0,1]\\times[0,1]$ 上的构造解 $u^{\\star}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。我们必须找到使 $u^{\\star}$ 成为精确解的源项 $q(x,y)$。\n\n首先，我们计算 $u^{\\star}$ 的必要导数：\n$u^{\\star}$ 的梯度为：\n$$\n\\nabla u^{\\star}(x,y) = \\begin{pmatrix} \\frac{\\partial u^{\\star}}{\\partial x} \\\\ \\frac{\\partial u^{\\star}}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} \\pi \\cos(\\pi x)\\sin(\\pi y) \\\\ \\pi \\sin(\\pi x)\\cos(\\pi y) \\end{pmatrix}\n$$\n对流项是 $\\mathbf{a}$ 和 $\\nabla u^{\\star}$ 的点积：\n$$\n\\mathbf{a} \\cdot \\nabla u^{\\star} = a_x \\pi \\cos(\\pi x)\\sin(\\pi y) + a_y \\pi \\sin(\\pi x)\\cos(\\pi y)\n$$\n扩散项涉及拉普拉斯算子 $\\nabla^2 u^{\\star} = \\nabla \\cdot \\nabla u^{\\star}$。对于常数 $\\kappa$，该项为 $-\\nabla\\cdot\\left(\\kappa \\nabla u^{\\star}\\right) = -\\kappa \\nabla^2 u^{\\star}$。二阶偏导数为：\n$$\n\\frac{\\partial^2 u^{\\star}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\frac{\\partial^2 u^{\\star}}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\n$$\n拉普拉斯算子是这些导数的和：\n$$\n\\nabla^2 u^{\\star} = \\frac{\\partial^2 u^{\\star}}{\\partial x^2} + \\frac{\\partial^2 u^{\\star}}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u^{\\star}(x,y)\n$$\n因此，扩散项为：\n$$\n-\\kappa \\nabla^2 u^{\\star} = 2\\kappa\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\n$$\n将这些代入控制方程，我们求解 $q$：\n$$\nq(x,y) = -\\kappa \\nabla^2 u^{\\star} + \\mathbf{a}\\cdot\\nabla u^{\\star} = 2\\kappa\\pi^2 \\sin(\\pi x)\\sin(\\pi y) + a_x \\pi \\cos(\\pi x)\\sin(\\pi y) + a_y \\pi \\sin(\\pi x)\\cos(\\pi y)\n$$\n这就是所要求的源项。\n\n**2. $\\varepsilon_h$ 和 $\\eta_h$ 之间的解析关系**\n\n这个问题的核心是从第一性原理出发，推导实际输出误差 $\\varepsilon_h$ 与基于伴随的误差指示子 $\\eta_h$ 之间的关系。\n\n离散原始问题由以下线性系统给出：\n$$\nA_h \\mathbf{u}_h = \\mathbf{b}_h\n$$\n其中 $\\mathbf{u}_h$ 是数值解向量。\n\n实际离散输出误差 $\\varepsilon_h$ 是用投影到网格上的精确解 $\\mathbf{u}^{\\star}_h$ 和数值解 $\\mathbf{u}_h$ 分别计算泛函所得值的差：\n$$\n\\varepsilon_h = J_h(\\mathbf{u}^{\\star}_h) - J_h(\\mathbf{u}_h) = \\mathbf{g}_h^\\top \\mathbf{u}^{\\star}_h - \\mathbf{g}_h^\\top \\mathbf{u}_h = \\mathbf{g}_h^\\top (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h)\n$$\n离散伴随问题由转置系统定义：\n$$\nA_h^\\top \\boldsymbol{\\psi}_h = \\mathbf{g}_h\n$$\n通过对该方程进行转置，我们可以用伴随解 $\\boldsymbol{\\psi}_h$ 和系统矩阵 $A_h$ 来表示泛函的梯度 $\\mathbf{g}_h^\\top$：\n$$\n\\mathbf{g}_h^\\top = (\\boldsymbol{A}_h^\\top \\boldsymbol{\\psi}_h)^\\top = \\boldsymbol{\\psi}_h^\\top A_h\n$$\n现在，将 $\\mathbf{g}_h^\\top$ 的这个表达式代入误差 $\\varepsilon_h$ 的方程中：\n$$\n\\varepsilon_h = (\\boldsymbol{\\psi}_h^\\top A_h) (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h)\n$$\n利用矩阵-向量乘法的结合律，我们重新组合这些项：\n$$\n\\varepsilon_h = \\boldsymbol{\\psi}_h^\\top [A_h (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h)] = \\boldsymbol{\\psi}_h^\\top (A_h \\mathbf{u}^{\\star}_h - A_h \\mathbf{u}_h)\n$$\n我们知道 $A_h \\mathbf{u}_h = \\mathbf{b}_h$，因此可以将其代入表达式中：\n$$\n\\varepsilon_h = \\boldsymbol{\\psi}_h^\\top (A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h)\n$$\n括号中的项 $A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h$ 正是离散截断残差 $\\boldsymbol{\\tau}_h$ 的定义。该残差衡量了精确解满足离散方程的程度。\n$$\n\\boldsymbol{\\tau}_h = A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h\n$$\n因此，我们得到：\n$$\n\\varepsilon_h = \\boldsymbol{\\psi}_h^\\top \\boldsymbol{\\tau}_h\n$$\n基于伴随的输出误差指示子定义为 $\\eta_h = \\boldsymbol{\\psi}_h^\\top \\boldsymbol{\\tau}_h$。因此，我们已经证明，对于这个线性和具有指定定义的问题：\n$$\n\\varepsilon_h = \\eta_h\n$$\n这是基于伴随的误差分析中的一个基本结果，通常称为“误差表示公式”。它表明，伴随加权残差为我们所关心的线性泛函的误差提供了一个精确的度量。因此，比值 $r = \\frac{\\eta_h}{\\varepsilon_h}$ 必须等于 $1$（在浮点精度误差范围内）。\n\n**3. 离散格式**\n\n数值实现需要构建矩阵 $A_h$ 和右端向量 $\\mathbf{b}_h$。$N \\times N$ 个内部网格点被映射到一个大小为 $N^2$ 的一维向量。一种常见的映射是行主序或列主序的字典序。设网格点由 $(i,j)$ 索引，其中 $i,j \\in \\{0, \\dots, N-1\\}$。到单个索引 $k$ 的一个映射可以是 $k = i + jN$。\n\n内部节点 $(i,j)$ 处的离散算子是通过对扩散项和对流项的贡献求和形成的。\n在点 $(x_i, y_j)$ 处，扩散项 $-\\kappa \\nabla^2 u$ 的二阶中心差分格式为：\n$$\n-\\kappa \\left( \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\right)\n$$\n在点 $(x_i, y_j)$ 处，对流项 $\\mathbf{a}\\cdot\\nabla u$ 的一阶迎风差分取决于速度分量 $a_x$ 和 $a_y$ 的符号。令 $a_x^+ = \\max(a_x, 0)$，$a_x^- = \\min(a_x, 0)$，$a_y^+ = \\max(a_y, 0)$ 及 $a_y^- = \\min(a_y, 0)$。其离散化形式为：\n$$\na_x \\frac{\\partial u}{\\partial x} \\approx a_x^+ \\frac{u_{i,j} - u_{i-1,j}}{h} + a_x^- \\frac{u_{i+1,j} - u_{i,j}}{h}\n$$\n$$\na_y \\frac{\\partial u}{\\partial y} \\approx a_y^+ \\frac{u_{i,j} - u_{i,j-1}}{h} + a_y^- \\frac{u_{i,j+1} - u_{i,j}}{h}\n$$\n\n结合这些格式，我们可以确定矩阵 $A_h$ 的元素。对于对应于节点 $k=i+jN$ 的行，非零元素为：\n- 对角线元素（$u_{i,j}$ 的系数）：$A_{k,k} = \\frac{4\\kappa}{h^2} + \\frac{a_x^+ - a_x^-}{h} + \\frac{a_y^+ - a_y^-}{h} = \\frac{4\\kappa}{h^2} + \\frac{|a_x|}{h} + \\frac{|a_y|}{h}$\n- 对应 $u_{i-1,j}$ 的非对角线元素（如果 $i > 0$）：$A_{k,k-1} = -\\frac{\\kappa}{h^2} - \\frac{a_x^+}{h}$\n- 对应 $u_{i+1,j}$ 的非对角线元素（如果 $i  N-1$）：$A_{k,k+1} = -\\frac{\\kappa}{h^2} + \\frac{a_x^-}{h}$\n- 对应 $u_{i,j-1}$ 的非对角线元素（如果 $j > 0$）：$A_{k,k-N} = -\\frac{\\kappa}{h^2} - \\frac{a_y^+}{h}$\n- 对应 $u_{i,j+1}$ 的非对角线元素（如果 $j  N-1$）：$A_{k,k+N} = -\\frac{\\kappa}{h^2} + \\frac{a_y^-}{h}$\n由于构造解 $u^\\star$ 在边界上为零，离散化中涉及边界值的项都为零。因此，右端向量 $\\mathbf{b}_h$ 仅由在内部节点 $(x_i, y_j)$ 处计算的源项 $q(x,y)$ 组成。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_ratio(N, kappa, ax, ay):\n    \"\"\"\n    Computes the ratio of the adjoint-based error indicator to the actual output error\n    for the 2D convection-diffusion problem.\n\n    Args:\n        N (int): The number of interior grid points in each dimension.\n        kappa (float): The diffusion coefficient.\n        ax (float): The convection velocity in the x-direction.\n        ay (float): The convection velocity in the y-direction.\n\n    Returns:\n        float: The ratio eta_h / eps_h.\n    \"\"\"\n    # 1. Grid and problem setup\n    h = 1.0 / (N + 1)\n    n_nodes = N * N\n\n    # Create coordinate arrays for interior points\n    i = np.arange(N)\n    x = (i + 1) * h\n    y = (i + 1) * h\n    X, Y = np.meshgrid(x, y)\n\n    # Define manufactured solution and source term functions\n    def u_star(x_val, y_val):\n        return np.sin(np.pi * x_val) * np.sin(np.pi * y_val)\n\n    def q_source(x_val, y_val, k, a_x, a_y):\n        term1 = 2 * k * np.pi**2 * np.sin(np.pi * x_val) * np.sin(np.pi * y_val)\n        term2 = a_x * np.pi * np.cos(np.pi * x_val) * np.sin(np.pi * y_val)\n        term3 = a_y * np.pi * np.sin(np.pi * x_val) * np.cos(np.pi * y_val)\n        return term1 + term2 + term3\n\n    # 2. Assemble the discrete system A_h * u_h = b_h\n    # Using LIL format for efficient assembly\n    A_h = lil_matrix((n_nodes, n_nodes), dtype=np.float64)\n    b_h = np.zeros(n_nodes, dtype=np.float64)\n    \n    # Pre-calculate upwind coefficients\n    ax_pos = max(ax, 0)\n    ax_neg = min(ax, 0)\n    ay_pos = max(ay, 0)\n    ay_neg = min(ay, 0)\n\n    # Loop over all interior nodes (i, j)\n    for j in range(N):\n        for i in range(N):\n            # Map 2D (i, j) index to 1D k index\n            k = i + j * N\n            \n            # Source term at node (i, j)\n            b_h[k] = q_source(x[i], y[j], kappa, ax, ay)\n\n            # Assemble matrix A_h row by row\n            # Diagonal coefficient\n            diag_coeff = (4 * kappa / h**2) + (abs(ax) / h) + (abs(ay) / h)\n            A_h[k, k] = diag_coeff\n\n            # Off-diagonal coefficients for neighbors\n            # Left neighbor (i-1, j)\n            if i > 0:\n                A_h[k, k - 1] = -kappa / h**2 - ax_pos / h\n            # Right neighbor (i+1, j)\n            if i  N - 1:\n                A_h[k, k + 1] = -kappa / h**2 + ax_neg / h\n            # Bottom neighbor (i, j-1)\n            if j > 0:\n                A_h[k, k - N] = -kappa / h**2 - ay_pos / h\n            # Top neighbor (i, j+1)\n            if j  N - 1:\n                A_h[k, k + N] = -kappa / h**2 + ay_neg / h\n\n    # Boundary condition contributions to b_h are zero because u_star = 0 on the boundary.\n    # Convert matrix to CSC format for efficient solves\n    A_h_csc = A_h.tocsc()\n\n    # 3. Solve primal and adjoint systems\n    u_h = spsolve(A_h_csc, b_h)\n    \n    g_h = h**2 * np.ones(n_nodes)\n    psi_h = spsolve(A_h_csc.T, g_h)\n\n    # 4. Compute errors and indicators\n    # Exact solution on the grid (flattened)\n    u_star_h = u_star(X, Y).flatten()\n\n    # Truncation residual: tau_h = A_h * u_star_h - b_h\n    tau_h = A_h_csc @ u_star_h - b_h\n    \n    # Adjoint-based error indicator: eta_h = psi_h^T * tau_h\n    eta_h = psi_h.dot(tau_h)\n\n    # Actual discrete output error: eps_h = g_h^T * (u_star_h - u_h)\n    eps_h = g_h.dot(u_star_h - u_h)\n    \n    # 5. Compute the ratio\n    # The ratio should be 1.0 up to machine precision.\n    # Avoid division by zero if error is extremely small.\n    if abs(eps_h)  1e-15:\n        return 1.0 if abs(eta_h)  1e-15 else np.nan\n    \n    r = eta_h / eps_h\n    return r\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, kappa, a_x, a_y)\n        (16, 0.05, 1.0, 0.4),\n        (16, 0.05, -0.7, 1.3),\n        (32, 0.01, 2.0, -1.0),\n        (8, 0.1, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, kappa, ax, ay = case\n        result = compute_ratio(N, kappa, ax, ay)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个实践探讨了“先离散后微分”（离散伴随）与“先微分后离散”（连续伴随）方法之间一个微妙但至关重要的区别。通过构建一个带有非光滑泛函的案例，我们将展示一个朴素的离散伴随方法如何可能无法为网格加密提供任何有用的信息，而连续伴随方法仍能产生有意义的指导。这突显了在基于伴随的流程中，对泛函进行审慎定义的重要性。",
            "id": "3941736",
            "problem": "考虑在单位区间上具有恒定正速度的稳态一维线性平流方程，\n$$\na \\frac{d u}{d x} = s(x), \\quad x \\in (0,1), \\quad a  0,\n$$\n其入口边界条件为\n$$\nu(0) = 0.\n$$\n假设所有物理量均为无量纲。设源项为分段常数，\n$$\ns(x) = \\begin{cases}\ns_0,  x \\in [x_s,1], \\\\\n0,  x \\in [0,x_s),\n\\end{cases}\n$$\n其中 $s_0  0$ 和 $x_s \\in (0,1)$ 为固定参数。其精确连续解为\n$$\nu(x) = \\int_0^x \\frac{s(\\xi)}{a} \\, d\\xi.\n$$\n定义一个旨在对出口附近进行加密的目标泛函，\n$$\nJ[u] = \\int_0^1 w(x) \\, H_\\varepsilon(u(x) - u_c) \\, dx,\n$$\n其中 $w(x)$ 是一个有界权重函数，当 $x \\in [x_w,1]$ 时 $w(x) = 1$，当 $x \\in [0,x_w)$ 时 $w(x) = 0$；$H_\\varepsilon$ 是 Heaviside 阶跃函数的光滑近似；$\\varepsilon  0$ 是一个正则化宽度；$u_c$ 是一个阈值。一个常见的光滑近似是\n$$\nH_\\varepsilon(z) = \\tfrac{1}{2} \\left( 1 + \\tanh\\left( \\frac{z}{\\varepsilon} \\right) \\right),\n$$\n其导数为\n$$\n\\frac{d}{dz} H_\\varepsilon(z) = \\tfrac{1}{2\\varepsilon} \\operatorname{sech}^2\\!\\left(\\frac{z}{\\varepsilon}\\right).\n$$\n\n基于连续伴随的网格加密过程是通过原始方程的弱形式和 $J[u]$ 的 Gateaux 导数来推导连续伴随 $p(x)$。从平流算子 $L[u] = a \\frac{d u}{d x}$ 开始，其形式 $L^2$-伴随为 $L^*[p] = - a \\frac{d p}{d x}$。对于上述 $J[u]$，连续伴随方程为\n$$\n- a \\frac{d p}{d x} = q(x), \\quad \\text{with} \\quad q(x) = w(x) \\frac{d}{du} H_\\varepsilon(u(x) - u_c),\n$$\n以及出口边界条件\n$$\np(1) = 0,\n$$\n该条件由 $u(x)$ 的入口边界条件和标准的平流伴随边界条件约定得出。一个局部的基于连续伴随的加密指示器可以取为\n$$\nI_{\\mathrm{cont}}(x) = \\left| p(x) \\right| \\, \\eta(x),\n$$\n其中 $\\eta(x)$ 是局部离散误差的后验估计子，例如一个基于离散解的二阶差分的光滑度传感器。\n\n基于离散伴随的加密从选定的离散化方法开始。考虑一个采用均匀网格间距 $\\Delta x = 1/N$ 的单元中心有限体积法，单元中心为 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$（$i = 0,1,\\dots,N-1$），并对 $a0$ 使用一阶迎风格式通量，得到离散稳态残差\n$$\nR_i(\\mathbf{u}) = \\frac{a}{\\Delta x} \\left( u_i - u_{i-1} \\right) - s(x_i), \\quad i=0,\\dots,N-1,\n$$\n其中 $u_{-1} = u(0)$ 由边界条件给定。离散雅可比矩阵 $\\mathbf{J} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}}$ 是下双对角矩阵：\n$$\n\\frac{\\partial R_i}{\\partial u_i} = \\frac{a}{\\Delta x}, \\quad \\frac{\\partial R_i}{\\partial u_{i-1}} = -\\frac{a}{\\Delta x}.\n$$\n定义离散泛函\n$$\nJ_d(\\mathbf{u}) = \\sum_{i=0}^{N-1} w(x_i) \\, H(u_i - u_c) \\, \\Delta x,\n$$\n其中 $H$ 是精确（非光滑）的 Heaviside 函数。离散伴随向量 $\\boldsymbol{\\psi}$ 求解\n$$\n\\mathbf{J}^\\top \\boldsymbol{\\psi} = \\nabla_{\\mathbf{u}} J_d(\\mathbf{u}),\n$$\n一个基于离散伴随的指示器可以是\n$$\nI_{\\mathrm{disc}}(x_i) = \\left| \\psi_i \\right| \\, \\eta(x_i).\n$$\n然而，由于 $H(z)$ 几乎处处是平的（其导数除了在阈值穿越点外都为零），因此在任何网格中，如果没有单元值 $u_i$ 恰好等于阈值 $u_c$，离散梯度 $\\nabla_{\\mathbf{u}} J_d(\\mathbf{u})$ 就是零向量。在这种情况下，离散伴随 $\\boldsymbol{\\psi}$ 求解一个齐次线性系统，其解为零向量，因此对所有 $i$ 都有 $I_{\\mathrm{disc}}(x_i) = 0$。\n\n您的任务是构建一个反例，展示在一个区域中，基于连续伴随的指示器 $I_{\\mathrm{cont}}(x)$ 发出了加密信号，而基于离散伴随的指示器 $I_{\\mathrm{disc}}(x)$ 却没有，然后分析导致这种差异的离散化特征。使用上述设置和以下算法步骤：\n\n1. 将 $(0,1)$ 离散为 $N$ 个均匀单元。令 $a = 1$ 且 $u(0) = 0$。\n2. 如上定义 $s(x)$，参数为 $s_0$ 和 $x_s$，并通过迎风递推式计算离散原始解 $\\{u_i\\}_{i=0}^{N-1}$\n   $$\n   u_i = u_{i-1} + \\frac{\\Delta x}{a} s(x_i), \\quad u_{-1} = 0.\n   $$\n3. 将 $w(x)$ 设置为 $[x_w,1]$ 的指示函数，其中 $x_w \\in (0,1)$。\n4. 计算连续伴随的右端项\n   $$\n   q_i = w(x_i) \\cdot \\tfrac{1}{2\\varepsilon} \\operatorname{sech}^2\\!\\left(\\frac{u_i - u_c}{\\varepsilon}\\right).\n   $$\n5. 在单元中心上近似 $p(x)$\n   $$\n   p_i \\approx \\frac{\\Delta x}{a} \\sum_{k=i}^{N-1} q_k.\n   $$\n6. 使用二阶差分估计局部离散误差，\n   $$\n   \\eta_i = \\frac{1}{\\Delta x} \\left| u_i - 2 u_{i-1} + u_{i-2} \\right|, \\quad \\text{with} \\quad \\eta_0 = \\eta_1 = 0.\n   $$\n7. 计算 $I_{\\mathrm{cont},i} = |p_i| \\eta_i$，并且对于使用非光滑 $J_d$ 的离散伴随情况，设置 $\\boldsymbol{\\psi} = \\mathbf{0}$，因此对所有 $i$ 都有 $I_{\\mathrm{disc},i} = 0$。\n8. 标记 $I_{\\mathrm{cont},i}$ 超过阈值 $\\tau$ 的单元，并分别标记 $I_{\\mathrm{disc},i}$ 超过相同阈值 $\\tau$ 的单元。使用 $\\tau = 0.5 \\cdot \\max_i I_{\\mathrm{cont},i}$，如果 $\\max_i I_{\\mathrm{cont},i}$ 为零，则两个标记集均为空。\n\n为以下测试套件提供结果，每个套件由参数 $(N, s_0, x_s, x_w, u_c, \\varepsilon)$ 指定：\n\n- 测试用例 A（理想情况，阈值穿越在加权窗口内）：$(128, 1.0, 0.4, 0.7, 0.5, 0.01)$。\n- 测试用例 B（边界条件导致在 $(0,1)$ 内没有穿越发生）：$(128, 1.0, 0.4, 0.7, 0.7, 0.01)$。\n- 测试用例 C（边缘情况，使用更宽的正则化，拓宽了连续伴随的敏感度）：$(128, 1.0, 0.4, 0.7, 0.5, 0.10)$。\n\n您的程序应生成单行输出，其中包含所有测试用例的汇总结果，形式为方括号内以逗号分隔的列表。每个测试用例的结果必须是一个双元素列表：连续伴随指示器的标记索引列表和离散伴随指示器的标记索引列表。例如，输出格式为\n$$\n[\\,[\\text{cont\\_A},\\text{disc\\_A}],\\,[\\text{cont\\_B},\\text{disc\\_B}],\\,[\\text{cont\\_C},\\text{disc\\_C}]\\,],\n$$\n其中每个占位符都是一个整数列表。",
            "solution": "该问题对一维线性平流问题的连续和离散伴随网格加密指示器进行了对比分析。其目标是构建一个场景，在该场景中，连续伴随方法能正确识别需要加密的区域，而一个朴素的离散伴随方法却无法做到这一点。这种差异源于目标泛函的选择，并揭示了在生成基于伴随的误差估计时，“先微分后离散”（连续）和“先离散后微分”（离散）这两种范式之间的关键概念区别。\n\n该物理系统由具有恒定正速度 $a  0$ 的稳态线性平流方程控制：\n$$\na \\frac{d u}{d x} = s(x), \\quad x \\in (0,1)\n$$\n其入口边界条件为 $u(0) = 0$。源项 $s(x)$ 是一个分段常数函数，在 $x=x_s$ 处引入了解 $u(x)$ 导数的不连续性。精确解是源项的积分，$u(x) = \\int_0^x (s(\\xi)/a) d\\xi$，这导致 $u(x)$ 呈现分段线性剖面。\n\n该分析依赖于两种不同的推导加密指示器的方法。\n\n**连续伴随方法：**\n此方法从连续公式开始。目标泛函 $J[u]$ 使用 Heaviside 函数的光滑近似 $H_\\varepsilon$ 来定义：\n$$\nJ[u] = \\int_0^1 w(x) \\, H_\\varepsilon(u(x) - u_c) \\, dx\n$$\n$H_\\varepsilon$ 的导数是一个光滑的钟形函数，$\\frac{d}{dz} H_\\varepsilon(z) = \\frac{1}{2\\varepsilon} \\operatorname{sech}^2(\\frac{z}{\\varepsilon})$。首先推导连续伴随方程，得到伴随变量 $p(x)$ 的后向平流方程：\n$$\n- a \\frac{d p}{d x} = q(x) = w(x) \\frac{d}{du} H_\\varepsilon(u(x) - u_c) \\quad \\text{with} \\quad p(1) = 0\n$$\n伴随方程的源项 $q(x)$ 仅在权重函数 $w(x)$ 为非零且解 $u(x)$ 接近阈值 $u_c$（在由 $\\varepsilon$ 决定的范围内）的区域非零。伴随解 $p(x) = \\int_x^1 (q(\\xi)/a) d\\xi$ 有效地将此敏感度信息“向上游”（沿 $x$ 减小的方向）传递。\n加密指示器 $I_{\\mathrm{cont}}(x) = |p(x)| \\eta(x)$ 将此敏感度信息 $p(x)$ 与局部误差估计子 $\\eta(x)$ 相结合。所选的估计子 $\\eta_i = \\frac{1}{\\Delta x} | u_i - 2 u_{i-1} + u_{i-2} |$ 是解的二阶导数的有限差分近似，即 $|u''|\\Delta x^2 / \\Delta x = |u''|\\Delta x$。它旨在检测非光滑特征，如导数的扭折或跳跃。该指示器仅在影响目标量（大的 $|p|$）的位置存在显著离散误差（大的 $\\eta$）时才会较大。\n\n**离散伴随方法：**\n此方法从离散化问题开始。离散泛函 $J_d$ 使用非光滑的精确 Heaviside 函数 $H(z)$ 来定义：\n$$\nJ_d(\\mathbf{u}) = \\sum_{i=0}^{N-1} w(x_i) \\, H(u_i - u_c) \\, \\Delta x\n$$\n该问题凸显了一个关键缺陷：$H(z)$ 的导数除了在 $z=0$ 外处处为零。因此，对于任何网格，只要没有单元中心值 $u_i$ 恰好落在阈值 $u_c$ 上，离散泛函的梯度 $\\nabla_{\\mathbf{u}} J_d$ 就是零向量。求解 $\\mathbf{J}^\\top \\boldsymbol{\\psi} = \\nabla_{\\mathbf{u}} J_d$ 的离散伴随向量 $\\boldsymbol{\\psi}$ 也将是零向量。即使某个值 $u_i$ 完美匹配 $u_c$，由此产生的伴随对网格或参数的无穷小扰动也极为敏感，使其成为一个不稳定且不可靠的指示器。该问题指导我们通过在所有情况下将离散伴随 $\\boldsymbol{\\psi}$ 及其对应的指示器 $I_{\\mathrm{disc}}$ 设置为零来模拟这种失败。\n\n**算法执行：**\n该问题要求执行一系列计算步骤来展示这一现象。\n1. 在 $x \\in (0,1)$ 上定义一个均匀网格。\n2. 使用一阶迎风格式计算原始解向量 $\\mathbf{u} = \\{u_i\\}$，这相当于对源项进行累积求和。\n3. 使用得到的 $u_i$ 在每个单元中心计算连续伴随源项 $q_i$。\n4. 通过从出口 $x=1$ 处向后数值积分 $q_i$ 来近似连续伴随解 $p_i$。\n5. 从离散解 $\\mathbf{u}$ 的二阶差分计算局部误差传感器 $\\eta_i$。由于精确解是分段线性的，二阶导数除了在 $x=x_s$ 处的扭折点外处处为零。因此，我们的离散传感器 $\\eta_i$ 仅在对应于 $x_s$ 的单元的紧邻区域内非零。\n6. 计算连续指示器 $I_{\\mathrm{cont},i} = |p_i| \\eta_i$。它仅在 $|p_i|$ 和 $\\eta_i$ 都非零的地方非零。\n7. 根据问题的设定，将离散指示器 $I_{\\mathrm{disc},i}$ 设置为 $0$。\n8. 如果单元的指示器值超过最大指示器值的 $50\\%$，则标记该单元以进行加密。\n\n**测试用例分析：**\n\n*   **测试用例 A ($u_c = 0.5, \\varepsilon = 0.01$)：** 原始解 $u(x)$ 在 $x=0.9$ 处穿过阈值 $u_c=0.5$。此位置在加权窗口 $[x_w, 1] = [0.7, 1]$ 内。因此，伴随源 $q(x)$ 在 $x=0.9$ 附近有一个强而窄的峰值。因此，伴随解 $p(x)$ 对所有 $x  0.9$ 都非零。误差估计子 $\\eta(x)$ 在源不连续点 $x_s=0.4$ 处有一个尖峰。由于 $p(0.4)$ 和 $\\eta(0.4)$ 都非零，连续指示器 $I_{\\mathrm{cont}}$ 将正确标记 $x_s=0.4$ 附近的区域进行加密。离散指示器保持为零。\n*   **测试用例 B ($u_c = 0.7, \\varepsilon = 0.01$)：** 原始解的最大值是 $u(1) \\approx 0.6$。解永远不会达到阈值 $u_c=0.7$。$\\operatorname{sech}^2$ 函数的参数始终远离零，使得伴随源 $q(x)$ 处处可忽略不计。因此，连续伴随 $p(x)$ 实际上为零，指示器 $I_{\\mathrm{cont}}$ 也为零，没有单元被标记。这是正确的行为，因为 $x_s$ 处的误差对一个对解剖面不敏感的泛函没有影响。\n*   **测试用例 C ($u_c = 0.5, \\varepsilon = 0.10$)：** 这个用例与 A 类似，但正则化参数 $\\varepsilon$ 更大。阈值穿越发生在相同的位置。较大的 $\\varepsilon$ 导致伴随源 $q(x)$ 更宽、更“弥散”，但其中心仍在 $x=0.9$。伴随解 $p(x)$ 在 $x_s=0.4$ 处仍然非零。因此，连续指示器将再次标记高离散误差的区域，展示了连续伴随方法相对于正则化参数的鲁棒性。离散指示器再次为零。\n\n该分析证明了连续伴随公式在鲁棒地识别与特定工程量相关的误差源方面的效用，而这是一个使用非光滑泛函的朴素离散伴随公式明显失败的任务。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adjoint-based mesh refinement problem for three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, s0, xs, xw, uc, eps)\n        (128, 1.0, 0.4, 0.7, 0.5, 0.01),  # Test Case A\n        (128, 1.0, 0.4, 0.7, 0.7, 0.01),  # Test Case B\n        (128, 1.0, 0.4, 0.7, 0.5, 0.10),  # Test Case C\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, s0, xs, xw, uc, eps = case\n        a = 1.0\n        dx = 1.0 / N\n        \n        # Step 1: Define cell centers\n        x_centers = (np.arange(N) + 0.5) * dx\n        \n        # Step 2: Compute discrete primal solution {u_i}\n        s = np.where(x_centers >= xs, s0, 0.0)\n        u = np.zeros(N)\n        # Recurrence: u_i = u_{i-1} + (dx/a) * s(x_i), with u_{-1} = 0\n        u_prev = 0.0 \n        for i in range(N):\n            u[i] = u_prev + (dx / a) * s[i]\n            u_prev = u[i]\n            \n        # Step 3: Define weight function w(x)\n        w = np.where(x_centers >= xw, 1.0, 0.0)\n\n        # Step 4: Compute continuous adjoint right-hand side q_i\n        sech_arg = (u - uc) / eps\n        # Using sech(z) = 1/cosh(z)\n        q = w * (1.0 / (2.0 * eps)) * (1.0 / np.cosh(sech_arg))**2\n\n        # Step 5: Approximate continuous adjoint solution p(x)\n        # p_i approx (dx/a) * sum_{k=i}^{N-1} q_k\n        # This is a cumulative sum of the reversed array\n        p = (dx / a) * np.cumsum(q[::-1])[::-1]\n\n        # Step 6: Estimate local discretization error eta_i\n        eta = np.zeros(N)\n        # According to the problem, eta_0 and eta_1 are 0.\n        # Loop from i=2 to N-1\n        for i in range(2, N):\n            eta[i] = (1.0 / dx) * np.abs(u[i] - 2.0 * u[i-1] + u[i-2])\n\n        # Step 7: Compute I_cont,i and I_disc,i\n        I_cont = np.abs(p) * eta\n        # I_disc,i = 0 for all i, as per problem statement\n        \n        # Step 8: Flag cells\n        max_I_cont = np.max(I_cont)\n        \n        cont_flagged_indices = []\n        # If max_I_cont is zero (or very close to it), tau is zero, and no cells are flagged.\n        if max_I_cont > 1e-15: # Use a small tolerance for floating point comparison\n            tau = 0.5 * max_I_cont\n            cont_flagged_indices = np.where(I_cont > tau)[0].tolist()\n            \n        # The discrete adjoint indicator is 0, so no cells are flagged.\n        disc_flagged_indices = []\n        \n        all_results.append([cont_flagged_indices, disc_flagged_indices])\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists in Python might have spaces.\n    # The problem implies a compact, no-space format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}