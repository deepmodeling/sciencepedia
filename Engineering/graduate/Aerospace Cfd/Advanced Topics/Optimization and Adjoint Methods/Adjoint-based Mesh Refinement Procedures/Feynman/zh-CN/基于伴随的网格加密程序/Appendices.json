{
    "hands_on_practices": [
        {
            "introduction": "在任何基于伴随方法的分析中，验证伴随求解器的正确性都是至关重要的一步。本练习将指导你通过一个一维对流-扩散模型，将伴随方法计算出的灵敏度与有限差分近似值进行比较，从而验证离散伴随求解器的实现。掌握这项基本技能是开发可靠的计算流体力学（CFD）伴随代码的基础。",
            "id": "3941772",
            "problem": "考虑一个一维、稳态、线性平流-扩散模型。该模型在计算流体动力学 (CFD, Computational Fluid Dynamics) 中常被用作研究基于伴随的网格加密程序的简化设定。单位区间域上的连续模型由作用于状态变量 $u(x)$ 的微分算子给出，\n$$\n-\\frac{d}{dx}\\left(\\kappa \\frac{du}{dx}\\right) + a \\frac{du}{dx} = s(x), \\quad x \\in (0,1),\n$$\n边界条件为狄利克雷边界条件 $u(0)=u_L$ 和 $u(1)=u_R$，其中 $\\kappa>0$ 是扩散系数，$a$ 是一个恒定的平流速度，$s(x)$ 是一个源项。在离散设置中，考虑一个包含 $N$ 个内部节点的均匀网格，节点间距为 $\\Delta x = \\frac{1}{N+1}$。令未知量向量为 $\\mathbf{u} \\in \\mathbb{R}^N$，代表内部节点 $x_i = i \\Delta x$（$i=1,2,\\dots,N$）处的状态。\n\n对扩散项使用二阶中心差分，对平流项使用一阶迎风差分（假设所有测试用例中 $a>0$）。内部节点 $i$ 的离散残差为\n$$\nR_i(\\mathbf{u}) = -\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + a \\frac{u_i - u_{i-1}}{\\Delta x} - s_i,\n$$\n其中，$u_0 = u_L$ 和 $u_{N+1} = u_R$ 是已知的边界值。这产生了一个线性系统\n$$\n\\mathbf{A}\\,\\mathbf{u} = \\mathbf{s}_{\\text{eff}},\n$$\n其中 $\\mathbf{A} \\in \\mathbb{R}^{N \\times N}$ 是残差关于 $\\mathbf{u}$ 的雅可比矩阵，而 $\\mathbf{s}_{\\text{eff}} \\in \\mathbb{R}^N$ 是包含物理源向量 $\\mathbf{s}$ 和边界贡献的等效源。\n\n定义一个目标泛函\n$$\nJ(\\mathbf{u}) = \\frac{1}{2} \\sum_{i=1}^{N} \\alpha_i \\, u_i^2 \\, \\Delta x,\n$$\n其中 $\\alpha_i = \\alpha(x_i)$ 是一个给定的非负权重。离散伴随状态 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^N$ 由线性系统\n$$\n\\mathbf{A}^\\top \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{u}},\n$$\n定义，其中梯度 $\\frac{\\partial J}{\\partial \\mathbf{u}}$ 的分量为 $\\left(\\frac{\\partial J}{\\partial u_i}\\right) = \\alpha_i u_i \\Delta x$。对于以 $-\\mathbf{s}$ 形式进入残差的参数化源 $\\mathbf{s}$，根据离散伴随恒等式和链式法则，$J$ 相对于 $\\mathbf{s}$ 的敏感度为\n$$\n\\frac{dJ}{d\\mathbf{s}} = \\boldsymbol{\\lambda},\n$$\n因为 $\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{s}} = -\\mathbf{I}$。\n\n您的任务如下：\n- 根据上述平流-扩散离散化方法（平流速度 $a>0$），构造矩阵 $\\mathbf{A}$，并组装包含狄利克雷边界条件 $u_L$ 和 $u_R$ 的等效源 $\\mathbf{s}_{\\text{eff}}$。\n- 求解原系统 $\\mathbf{A}\\,\\mathbf{u} = \\mathbf{s}_{\\text{eff}}$ 以获得 $\\mathbf{u}$。\n- 根据 $J$ 的定义，解析地计算梯度 $\\frac{\\partial J}{\\partial \\mathbf{u}}$。\n- 通过有限差分近似验证 $\\frac{\\partial J}{\\partial \\mathbf{u}}$ 的实现：对于施加到 $\\mathbf{u}$ 各分量上的小扰动 $\\varepsilon$，通过下式近似 $\\left(\\frac{\\partial J}{\\partial u_i}\\right)$：\n$$\n\\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} \\approx \\frac{J(\\mathbf{u} + \\varepsilon \\mathbf{e}_i) - J(\\mathbf{u})}{\\varepsilon},\n$$\n其中 $\\mathbf{e}_i$ 是 $\\mathbb{R}^N$ 中的第 $i$ 个标准基向量。\n- 求解离散伴随系统 $\\mathbf{A}^\\top \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{u}}$ 以获得 $\\boldsymbol{\\lambda}$。\n- 通过有限差分验证伴随法推导的 $J$ 相对于源 $\\mathbf{s}$ 的敏感度：对于施加到 $\\mathbf{s}_{\\text{eff}}$ 各分量上的小扰动 $\\delta$，通过下式近似 $\\left(\\frac{dJ}{ds_j}\\right)$：\n$$\n\\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} \\approx \\frac{J(\\mathbf{u}^{(j,+)}) - J(\\mathbf{u})}{\\delta},\n$$\n其中 $\\mathbf{u}^{(j,+)}$ 是 $\\mathbf{A}\\,\\mathbf{u}^{(j,+)} = \\mathbf{s}_{\\text{eff}} + \\delta\\,\\mathbf{e}_j$ 的解。\n\n对于每个测试用例，报告一个标量结果，该结果定义为两个绝对误差度量的最大值：\n$$\nE_{\\text{grad}} = \\max_{i} \\left| \\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} - \\left(\\frac{\\partial J}{\\partial u_i}\\right) \\right|, \\quad\nE_{\\text{sens}} = \\max_{j} \\left| \\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} - \\lambda_j \\right|,\n$$\n最终报告的值是 $\\max\\{E_{\\text{grad}}, E_{\\text{sens}}\\}$。\n\n所有量都是无量纲的。不出现角度。您的程序必须是在指定环境中完整、可运行的程序，并且必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。数值扰动必须选择得足够小以精确近似导数，但又要足够大以避免灾难性的舍入误差；所有测试用例使用相同的 $\\varepsilon$ 和 $\\delta$。\n\n使用以下测试套件：\n- 测试用例1：$N=20$, $a=1.0$, $\\kappa=0.05$, $u_L=1.0$, $u_R=0.0$, $\\alpha(x) = \\exp\\left(-\\left(\\frac{x-0.5}{0.2}\\right)^2\\right)$, 且对所有 $i$ 都有 $s_i=0$。\n- 测试用例2：$N=10$, $a=2.0$, $\\kappa=0.01$, $u_L=0.0$, $u_R=1.0$, $\\alpha(x) = 1$, 且对所有 $i$ 都有 $s_i=0$。\n- 测试用例3：$N=50$, $a=0.5$, $\\kappa=0.10$, $u_L=0.2$, $u_R=0.2$, $\\alpha(x) = \\sin^2(\\pi x)$, 且对所有 $i$ 都有 $s_i=0$。\n\n您的程序应生成单行输出，其中包含按测试用例列出顺序列出的、用方括号括起来的逗号分隔的结果列表：例如，$[E_1,E_2,E_3]$，其中每个 $E_k$ 是为测试用例 $k$ 计算的标量 $\\max\\{E_{\\text{grad}}, E_{\\text{sens}}\\}$。",
            "solution": "该问题是有效的。它在偏微分方程数值分析和基于伴随的敏感度分析等成熟领域具有科学依据。该问题是适定的、自洽的，并提供了构建唯一数值解所需的所有必要信息。我们接下来将进行详细的推导和计算过程描述。\n\n### 1. 原问题：离散化与系统组装\n\n控制方程是在域 $x \\in (0,1)$ 上的一维、稳态、线性平流-扩散方程：\n$$\n-\\frac{d}{dx}\\left(\\kappa \\frac{du}{dx}\\right) + a \\frac{du}{dx} = s(x)\n$$\n其中扩散系数 $\\kappa > 0$，平流速度 $a > 0$，源项为 $s(x)$。该域满足狄利克雷边界条件 $u(0) = u_L$ 和 $u(1) = u_R$。\n\n我们在一个均匀网格上对此方程进行离散化，该网格有 $N$ 个内部节点 $x_i = i \\Delta x$（$i=1, \\dots, N$），网格间距为 $\\Delta x = \\frac{1}{N+1}$。设 $u_i \\approx u(x_i)$ 为节点 $i$ 处的离散解。\n\n扩散项使用二阶中心差分格式进行离散化：\n$$\n-\\frac{d}{dx}\\left(\\kappa \\frac{du}{dx}\\right) \\bigg|_{x_i} \\approx -\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}\n$$\n\n平流项使用一阶迎风格式进行离散化。由于 $a > 0$，信息从左向右流动，因此我们使用后向差分：\n$$\na \\frac{du}{dx} \\bigg|_{x_i} \\approx a \\frac{u_i - u_{i-1}}{\\Delta x}\n$$\n\n结合这些离散化方法，内部节点 $i$ 的离散残差方程为 $R_i(\\mathbf{u}) = 0$，其中：\n$$\nR_i(\\mathbf{u}) = -\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + a \\frac{u_i - u_{i-1}}{\\Delta x} - s_i\n$$\n此处，$s_i = s(x_i)$。重新整理各项以对未知数 $u_j$ 进行分组，我们得到：\n$$\n\\left(-\\frac{\\kappa}{\\Delta x^2} - \\frac{a}{\\Delta x}\\right)u_{i-1} + \\left(\\frac{2\\kappa}{\\Delta x^2} + \\frac{a}{\\Delta x}\\right)u_i + \\left(-\\frac{\\kappa}{\\Delta x^2}\\right)u_{i+1} = s_i\n$$\n此方程对 $i = 1, \\dots, N$ 成立。边界值 $u_0 = u_L$ 和 $u_{N+1} = u_R$ 是已知的。我们将涉及这些已知值的项移到方程右侧。这就得到了一个线性方程组 $\\mathbf{A} \\mathbf{u} = \\mathbf{s}_{\\text{eff}}$。\n\n矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times N}$ 是一个三对角矩阵，其非零元素如下：\n- 主对角线 ($j=i$):\n$$A_{ii} = \\frac{2\\kappa}{\\Delta x^2} + \\frac{a}{\\Delta x}$$\n- 下对角线 ($j=i-1$):\n$$A_{i,i-1} = -\\frac{\\kappa}{\\Delta x^2} - \\frac{a}{\\Delta x}$$\n- 上对角线 ($j=i+1$):\n$$A_{i,i+1} = -\\frac{\\kappa}{\\Delta x^2}$$\n\n等效源向量 $\\mathbf{s}_{\\text{eff}} \\in \\mathbb{R}^N$ 包含了物理源 $s_i$ 和边界贡献：\n- 对于第一个节点 ($i=1$):\n$$(\\mathbf{s}_{\\text{eff}})_1 = s_1 - \\left(-\\frac{\\kappa}{\\Delta x^2} - \\frac{a}{\\Delta x}\\right)u_0 = s_1 + \\left(\\frac{\\kappa}{\\Delta x^2} + \\frac{a}{\\Delta x}\\right)u_L$$\n- 对于中间节点 ($1 < i < N$):\n$$(\\mathbf{s}_{\\text{eff}})_i = s_i$$\n- 对于最后一个节点 ($i=N$):\n$$(\\mathbf{s}_{\\text{eff}})_N = s_N - \\left(-\\frac{\\kappa}{\\Delta x^2}\\right)u_{N+1} = s_N + \\frac{\\kappa}{\\Delta x^2}u_R$$\n\n通过求解这个线性系统，可以解出状态向量 $\\mathbf{u}$，即完成了原问题的求解。\n\n### 2. 伴随问题与敏感度分析\n\n目标泛函定义为：\n$$\nJ(\\mathbf{u}) = \\frac{1}{2} \\sum_{i=1}^{N} \\alpha_i u_i^2 \\Delta x\n$$\n其中 $\\alpha_i = \\alpha(x_i)$ 是一个非负权重。$J$ 相对于状态向量 $\\mathbf{u}$ 各分量的梯度可以直接计算得出：\n$$\n\\frac{\\partial J}{\\partial u_i} = \\frac{1}{2} \\alpha_i (2u_i) \\Delta x = \\alpha_i u_i \\Delta x\n$$\n\n离散伴随状态 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^N$ 是以下线性系统的解：\n$$\n\\mathbf{A}^\\top \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{u}}\n$$\n其中 $\\mathbf{A}^\\top$ 是原系统矩阵的转置，右侧是上面推导出的梯度分量向量。\n\n离散伴随法的一个关键结果是，泛函 $J$ 相对于物理源项向量 $\\mathbf{s}$ 的敏感度等于伴随状态向量 $\\boldsymbol{\\lambda}$。这是因为残差被定义为包含项 $-\\mathbf{s}$，这意味着 $\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{s}} = -\\mathbf{I}$。推导表明 $\\frac{dJ}{d\\mathbf{s}} = \\boldsymbol{\\lambda}$。\n\n### 3. 通过有限差分进行验证\n\n为确保我们实现的正确性，我们使用有限差分近似来验证解析梯度和伴随法推导的敏感度。\n\n**梯度验证：** 将解析梯度 $\\frac{\\partial J}{\\partial \\mathbf{u}}$ 与前向有限差分近似进行比较。对每个分量 $i$，我们计算：\n$$\n\\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} = \\frac{J(\\mathbf{u} + \\varepsilon \\mathbf{e}_i) - J(\\mathbf{u})}{\\varepsilon}\n$$\n其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量，$\\varepsilon$ 是一个小的扰动（例如 $\\varepsilon=10^{-7}$）。误差通过所有分量上的最大绝对差来量化：\n$$\nE_{\\text{grad}} = \\max_{i} \\left| \\left(\\frac{\\partial J}{\\partial u_i}\\right)_{\\text{FD}} - \\left(\\frac{\\partial J}{\\partial u_i}\\right) \\right|\n$$\n\n**敏感度验证：** 将伴随法推导的敏感度 $\\boldsymbol{\\lambda}$ 与 $J$ 相对于源项 $\\mathbf{s}$ 的敏感度的有限差分近似进行比较。对每个分量 $j$，我们计算：\n$$\n\\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} = \\frac{J(\\mathbf{u}^{(j,+)}) - J(\\mathbf{u})}{\\delta}\n$$\n此处，$\\delta$ 是一个小的扰动（例如 $\\delta=10^{-7}$），$\\mathbf{u}^{(j,+)}$ 是带有扰动源的原系统的解：$\\mathbf{A}\\,\\mathbf{u}^{(j,+)} = \\mathbf{s}_{\\text{eff}} + \\delta\\,\\mathbf{e}_j$。误差则为：\n$$\nE_{\\text{sens}} = \\max_{j} \\left| \\left(\\frac{dJ}{ds_j}\\right)_{\\text{FD}} - \\lambda_j \\right|\n$$\n\n每个测试用例最终报告的值是这两个误差度量的最大值，即 $\\max\\{E_{\\text{grad}}, E_{\\text{sens}}\\}$。该结果的数值较小表明原系统和伴随系统的实现都是正确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for the given test cases.\n    It sets up the test cases, iterates through them, calls a helper\n    function to process each one, and prints the final results.\n    \"\"\"\n\n    def process_case(params):\n        \"\"\"\n        Processes a single test case for the 1D advection-diffusion problem.\n        It assembles and solves the primal system, computes the goal functional\n        and its gradient, solves the adjoint system, and validates the results\n        using finite differences to compute the final error metric.\n        \"\"\"\n        N, a, kappa, u_L, u_R, alpha_func = params\n        s_vec = np.zeros(N)\n\n        # 0. Setup mesh and perturbation parameters\n        delta_x = 1.0 / (N + 1)\n        x_nodes = np.linspace(delta_x, 1.0 - delta_x, N)\n        \n        epsilon = 1e-7  # Perturbation for gradient validation\n        delta = 1e-7    # Perturbation for sensitivity validation\n\n        # 1. Assemble the primal system matrix A and effective source s_eff\n        diag_main = (2.0 * kappa / delta_x**2 + a / delta_x) * np.ones(N)\n        diag_upper = (-kappa / delta_x**2) * np.ones(N - 1)\n        diag_lower = (-kappa / delta_x**2 - a / delta_x) * np.ones(N - 1)\n        \n        A = np.diag(diag_main) + np.diag(diag_upper, k=1) + np.diag(diag_lower, k=-1)\n        \n        s_eff = np.copy(s_vec)\n        s_eff[0] += (kappa / delta_x**2 + a / delta_x) * u_L\n        s_eff[-1] += (kappa / delta_x**2) * u_R\n\n        # 2. Solve the primal system for the state vector u\n        u = solve_linear_system(A, s_eff)\n\n        # 3. Compute goal functional and its analytical gradient\n        alpha_vec = alpha_func(x_nodes)\n\n        def J_func(u_vec):\n            return 0.5 * np.sum(alpha_vec * u_vec**2 * delta_x)\n\n        grad_J_analytic = alpha_vec * u * delta_x\n        J_base = J_func(u)\n\n        # 4. Validate the gradient via finite differences\n        grad_J_fd = np.zeros(N)\n        for i in range(N):\n            u_pert = np.copy(u)\n            u_pert[i] += epsilon\n            J_pert = J_func(u_pert)\n            grad_J_fd[i] = (J_pert - J_base) / epsilon\n\n        E_grad = np.max(np.abs(grad_J_fd - grad_J_analytic))\n\n        # 5. Solve the discrete adjoint system for the adjoint vector\n        A_T = A.T\n        adjoint_vec = solve_linear_system(A_T, grad_J_analytic)\n\n        # 6. Validate the adjoint sensitivity via finite differences\n        sens_J_fd = np.zeros(N)\n        for j in range(N):\n            s_eff_pert = np.copy(s_eff)\n            s_eff_pert[j] += delta\n            u_pert_sens = solve_linear_system(A, s_eff_pert)\n            J_pert_sens = J_func(u_pert_sens)\n            sens_J_fd[j] = (J_pert_sens - J_base) / delta\n        \n        E_sens = np.max(np.abs(sens_J_fd - adjoint_vec))\n\n        # 7. Compute the final result for the test case\n        return max(E_grad, E_sens)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a, kappa, u_L, u_R, alpha_func)\n        (20, 1.0, 0.05, 1.0, 0.0, lambda x: np.exp(-((x - 0.5) / 0.2)**2)),\n        (10, 2.0, 0.01, 0.0, 1.0, lambda x: np.ones_like(x)),\n        (50, 0.5, 0.10, 0.2, 0.2, lambda x: np.sin(np.pi * x)**2)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们拥有一个经过验证的求解器后，便可以将其应用于其主要目标：面向特定目标的误差估计。本练习使用“精确解方法”（method of manufactured solutions）来揭示一个强大的理论结果：对于线性问题，伴随加权的残差能够精确地衡量目标泛函的误差。你将通过一个二维问题对该误差表达公式进行数值验证，从而深刻理解伴随方法是如何精确定位误差来源的。",
            "id": "3941740",
            "problem": "考虑在单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上的稳态、线性、二维对流-扩散方程，其狄利克雷边界条件由一个构造的精确解给出。控制方程为\n$$\n-\\nabla\\cdot\\left(\\kappa \\nabla u\\right) + \\mathbf{a}\\cdot\\nabla u = q \\quad \\text{in } \\Omega,\n$$\n边界条件为在 $\\partial \\Omega$ 上 $u = u^{\\star}$，其中 $\\kappa > 0$ 是扩散系数，$\\mathbf{a} = (a_x, a_y)$ 是恒定对流速度，而 $q$ 是一个源项，其选择使得指定的平滑函数 $u^{\\star}$ 成为该连续偏微分方程的精确解。设构造的精确解为\n$$\nu^{\\star}(x,y) = \\sin(\\pi x)\\sin(\\pi y).\n$$\n根据梯度、散度和拉普拉斯算子的基本定义，计算源项 $q(x,y)$，使得 $u^{\\star}$ 满足该连续方程。使用一个包含 $N\\times N$ 个内部点的均匀笛卡尔网格，网格间距为 $h=\\frac{1}{N+1}$，坐标为 $x_i=(i+1)h$, $y_j=(j+1)h$，其中 $i,j\\in\\{0,\\dots,N-1\\}$。\n\n使用二阶中心差分格式离散化扩散项，使用一阶迎风差分格式离散化对流项，从而对算子进行离散化。组装得到的线性系统\n$$\nA_h \\mathbf{u}_h = \\mathbf{b}_h,\n$$\n其中 $A_h$ 是离散对流-扩散算子，$\\mathbf{u}_h$ 是内部节点上的未知量向量，$\\mathbf{b}_h$ 是离散右端项，由在内部节点上计算的构造源项以及由离散格式引入的狄利克雷边界值贡献组成。将标量输出泛函定义为场量的域积分，\n$$\nJ(u) = \\int_{\\Omega} u(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y.\n$$\n在内部网格上使用单元中心黎曼和来近似 $J$，\n$$\nJ_h(\\mathbf{u}_h) = \\mathbf{g}_h^\\top \\mathbf{u}_h, \\quad \\text{where} \\quad \\mathbf{g}_h = h^2\\,\\mathbf{1},\n$$\n其中 $\\mathbf{1}$ 是与 $\\mathbf{u}_h$ 大小相同的全一向量。\n\n通过求解转置系统来定义离散伴随 $\\boldsymbol{\\psi}_h$\n$$\nA_h^\\top \\boldsymbol{\\psi}_h = \\mathbf{g}_h.\n$$\n设精确解在内部网格上的限制为 $\\mathbf{u}^{\\star}_h$，通过在内部网格点上对 $u^{\\star}$ 进行采样得到。计算离散截断余项\n$$\n\\boldsymbol{\\tau}_h = A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h,\n$$\n以及基于伴随的输出误差指示子\n$$\n\\eta_h = \\boldsymbol{\\psi}_h^\\top \\boldsymbol{\\tau}_h.\n$$\n计算实际离散输出误差\n$$\n\\varepsilon_h = J_h(\\mathbf{u}^{\\star}_h) - J_h(\\mathbf{u}_h) = \\mathbf{g}_h^\\top (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h).\n$$\n从离散原始问题和伴随问题的线性代数表示以及输出泛函的定义出发，根据第一性原理推导在线性情况下 $\\eta_h$ 与 $\\varepsilon_h$ 之间的关系。然后，实现所述的离散化和计算，通过报告以下测试套件中每个案例的比率\n$$\nr = \\frac{\\eta_h}{\\varepsilon_h}\n$$\n来数值验证基于伴随的指示子与实际输出误差成线性关系，并证明该比率在不同网格细化和参数变化下近似恒定。\n\n使用以下参数值 $(N,\\kappa,a_x,a_y)$ 的测试套件：\n- 案例1（一般对流-扩散，中等网格）：$(16,\\,0.05,\\,1.0,\\,0.4)$。\n- 案例2（混合符号对流，中等网格）：$(16,\\,0.05,\\,-0.7,\\,1.3)$。\n- 案例3（更强对流，更细网格）：$(32,\\,0.01,\\,2.0,\\,-1.0)$。\n- 案例4（纯垂直对流，粗网格）：$(8,\\,0.1,\\,0.0,\\,1.0)$。\n\n所有计算都是无量纲的，因此不需要物理单位。您的程序应生成单行输出，其中包含四个案例的比率 $r$，格式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4]”）。输出必须以浮点数形式报告。",
            "solution": "该问题陈述被评估为有效。这是一个来自偏微分方程数值分析领域的适定且自洽的问题。它在科学上基于有限差分法和伴随误差估计理论，并使用标准的构造解方法进行验证。所有参数、方程和数值方法都得到了清晰明确的定义。\n\n求解过程分为三个阶段：\n1.  推导构造解所需的源项 $q(x,y)$。\n2.  解析推导实际输出误差 $\\varepsilon_h$ 与基于伴随的误差指示子 $\\eta_h$ 之间的关系。\n3.  详细说明待实现的数值离散化格式。\n\n**1. 源项推导**\n\n连续控制方程为 $-\\nabla\\cdot\\left(\\kappa \\nabla u\\right) + \\mathbf{a}\\cdot\\nabla u = q$。给定常数扩散系数 $\\kappa > 0$、恒定对流速度向量 $\\mathbf{a} = (a_x, a_y)$ 以及在域 $\\Omega = [0,1]\\times[0,1]$ 上的一个构造解 $u^{\\star}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。我们必须找到使 $u^{\\star}$ 成为精确解的源项 $q(x,y)$。\n\n首先，我们计算 $u^{\\star}$ 的必要导数：\n$u^{\\star}$ 的梯度为：\n$$\n\\nabla u^{\\star}(x,y) = \\begin{pmatrix} \\frac{\\partial u^{\\star}}{\\partial x} \\\\ \\frac{\\partial u^{\\star}}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} \\pi \\cos(\\pi x)\\sin(\\pi y) \\\\ \\pi \\sin(\\pi x)\\cos(\\pi y) \\end{pmatrix}\n$$\n对流项是 $\\mathbf{a}$ 与 $\\nabla u^{\\star}$ 的点积：\n$$\n\\mathbf{a} \\cdot \\nabla u^{\\star} = a_x \\pi \\cos(\\pi x)\\sin(\\pi y) + a_y \\pi \\sin(\\pi x)\\cos(\\pi y)\n$$\n扩散项涉及拉普拉斯算子 $\\nabla^2 u^{\\star} = \\nabla \\cdot \\nabla u^{\\star}$。对于常数 $\\kappa$，该项为 $-\\nabla\\cdot\\left(\\kappa \\nabla u^{\\star}\\right) = -\\kappa \\nabla^2 u^{\\star}$。二阶偏导数为：\n$$\n\\frac{\\partial^2 u^{\\star}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\frac{\\partial^2 u^{\\star}}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\n$$\n拉普拉斯算子是它们的和：\n$$\n\\nabla^2 u^{\\star} = \\frac{\\partial^2 u^{\\star}}{\\partial x^2} + \\frac{\\partial^2 u^{\\star}}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u^{\\star}(x,y)\n$$\n因此，扩散项为：\n$$\n-\\kappa \\nabla^2 u^{\\star} = 2\\kappa\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\n$$\n将这些代入控制方程，我们求解 $q$：\n$$\nq(x,y) = -\\kappa \\nabla^2 u^{\\star} + \\mathbf{a}\\cdot\\nabla u^{\\star} = 2\\kappa\\pi^2 \\sin(\\pi x)\\sin(\\pi y) + a_x \\pi \\cos(\\pi x)\\sin(\\pi y) + a_y \\pi \\sin(\\pi x)\\cos(\\pi y)\n$$\n这就是所需的源项。\n\n**2. $\\varepsilon_h$ 与 $\\eta_h$ 之间的解析关系**\n\n这个问题的核心是根据第一性原理推导实际输出误差 $\\varepsilon_h$ 与基于伴随的误差指示子 $\\eta_h$ 之间的关系。\n\n离散原始问题由以下线性系统给出：\n$$\nA_h \\mathbf{u}_h = \\mathbf{b}_h\n$$\n其中 $\\mathbf{u}_h$ 是数值解向量。\n\n实际离散输出误差 $\\varepsilon_h$ 是用投影到网格上的精确解 $\\mathbf{u}^{\\star}_h$ 和数值解 $\\mathbf{u}_h$ 计算的泛函值之差：\n$$\n\\varepsilon_h = J_h(\\mathbf{u}^{\\star}_h) - J_h(\\mathbf{u}_h) = \\mathbf{g}_h^\\top \\mathbf{u}^{\\star}_h - \\mathbf{g}_h^\\top \\mathbf{u}_h = \\mathbf{g}_h^\\top (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h)\n$$\n离散伴随问题由转置系统定义：\n$$\nA_h^\\top \\boldsymbol{\\psi}_h = \\mathbf{g}_h\n$$\n对此方程进行转置，我们可以用伴随解 $\\boldsymbol{\\psi}_h$ 和系统矩阵 $A_h$ 来表示泛函的梯度 $\\mathbf{g}_h^\\top$：\n$$\n\\mathbf{g}_h^\\top = (\\boldsymbol{A}_h^\\top \\boldsymbol{\\psi}_h)^\\top = \\boldsymbol{\\psi}_h^\\top A_h\n$$\n现在，将 $\\mathbf{g}_h^\\top$ 的这个表达式代入误差 $\\varepsilon_h$ 的方程中：\n$$\n\\varepsilon_h = (\\boldsymbol{\\psi}_h^\\top A_h) (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h)\n$$\n利用矩阵向量乘法的结合律，我们重新组合这些项：\n$$\n\\varepsilon_h = \\boldsymbol{\\psi}_h^\\top [A_h (\\mathbf{u}^{\\star}_h - \\mathbf{u}_h)] = \\boldsymbol{\\psi}_h^\\top (A_h \\mathbf{u}^{\\star}_h - A_h \\mathbf{u}_h)\n$$\n我们知道 $A_h \\mathbf{u}_h = \\mathbf{b}_h$，所以我们可以将其代入表达式中：\n$$\n\\varepsilon_h = \\boldsymbol{\\psi}_h^\\top (A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h)\n$$\n括号中的项 $A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h$ 正是离散截断余项 $\\boldsymbol{\\tau}_h$ 的定义。该余项衡量了精确解在多大程度上满足离散方程。\n$$\n\\boldsymbol{\\tau}_h = A_h \\mathbf{u}^{\\star}_h - \\mathbf{b}_h\n$$\n因此，我们得到：\n$$\n\\varepsilon_h = \\boldsymbol{\\psi}_h^\\top \\boldsymbol{\\tau}_h\n$$\n基于伴随的输出误差指示子定义为 $\\eta_h = \\boldsymbol{\\psi}_h^\\top \\boldsymbol{\\tau}_h$。因此，我们证明了对于此线性问题和给定的定义：\n$$\n\\varepsilon_h = \\eta_h\n$$\n这是伴随误差分析中的一个基本结果，通常称为“误差表示公式”。它表明，伴随加权的余项为所关心的线性泛函的误差提供了一个精确的度量。因此，比率 $r = \\frac{\\eta_h}{\\varepsilon_h}$ 必然等于 $1$，误差仅来自于浮点精度。\n\n**3. 离散化格式**\n\n数值实现需要构建矩阵 $A_h$ 和右端向量 $\\mathbf{b}_h$。$N \\times N$ 个内部网格点被映射到一个大小为 $N^2$ 的单一向量。一种常见的映射是行主序或列主序的字典序。设网格点由 $(i,j)$ 索引，其中 $i,j \\in \\{0, \\dots, N-1\\}$。到单个索引 $k$ 的映射可以是 $k = i + jN$。\n\n内部节点 $(i,j)$ 处的离散算子是通过对扩散项和对流项的贡献求和形成的。\n在点 $(x_i, y_j)$ 处，扩散项 $-\\kappa \\nabla^2 u$ 的二阶中心差分格式是：\n$$\n-\\kappa \\left( \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\right)\n$$\n在点 $(x_i, y_j)$ 处，对流项 $\\mathbf{a}\\cdot\\nabla u$ 的一阶迎风差分格式取决于速度分量 $a_x$ 和 $a_y$ 的符号。设 $a_x^+ = \\max(a_x, 0)$, $a_x^- = \\min(a_x, 0)$, $a_y^+ = \\max(a_y, 0)$ 和 $a_y^- = \\min(a_y, 0)$。离散格式为：\n$$\na_x \\frac{\\partial u}{\\partial x} \\approx a_x^+ \\frac{u_{i,j} - u_{i-1,j}}{h} + a_x^- \\frac{u_{i+1,j} - u_{i,j}}{h}\n$$\n$$\na_y \\frac{\\partial u}{\\partial y} \\approx a_y^+ \\frac{u_{i,j} - u_{i,j-1}}{h} + a_y^- \\frac{u_{i,j+1} - u_{i,j}}{h}\n$$\n\n结合这些差分格式，我们可以确定矩阵 $A_h$ 的元素。对于对应于节点 $k=i+jN$ 的行，非零元素是：\n- 对角线元素（$u_{i,j}$ 的系数）：$A_{k,k} = \\frac{4\\kappa}{h^2} + \\frac{a_x^+ - a_x^-}{h} + \\frac{a_y^+ - a_y^-}{h} = \\frac{4\\kappa}{h^2} + \\frac{|a_x|}{h} + \\frac{|a_y|}{h}$\n- $u_{i-1,j}$ 的非对角线元素（如果 $i>0$）：$A_{k,k-1} = -\\frac{\\kappa}{h^2} - \\frac{a_x^+}{h}$\n- $u_{i+1,j}$ 的非对角线元素（如果 $i<N-1$）：$A_{k,k+1} = -\\frac{\\kappa}{h^2} + \\frac{a_x^-}{h}$",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_ratio(N, kappa, ax, ay):\n    \"\"\"\n    Computes the ratio of the adjoint-based error indicator to the actual output error\n    for the 2D convection-diffusion problem.\n\n    Args:\n        N (int): The number of interior grid points in each dimension.\n        kappa (float): The diffusion coefficient.\n        ax (float): The convection velocity in the x-direction.\n        ay (float): The convection velocity in the y-direction.\n\n    Returns:\n        float: The ratio eta_h / eps_h.\n    \"\"\"\n    # 1. Grid and problem setup\n    h = 1.0 / (N + 1)\n    n_nodes = N * N\n\n    # Create coordinate arrays for interior points\n    i = np.arange(N)\n    x = (i + 1) * h\n    y = (i + 1) * h\n    X, Y = np.meshgrid(x, y)\n\n    # Define manufactured solution and source term functions\n    def u_star(x_val, y_val):\n        return np.sin(np.pi * x_val) * np.sin(np.pi * y_val)\n\n    def q_source(x_val, y_val, k, a_x, a_y):\n        term1 = 2 * k * np.pi**2 * np.sin(np.pi * x_val) * np.sin(np.pi * y_val)\n        term2 = a_x * np.pi * np.cos(np.pi * x_val) * np.sin(np.pi * y_val)\n        term3 = a_y * np.pi * np.sin(np.pi * x_val) * np.cos(np.pi * y_val)\n        return term1 + term2 + term3\n\n    # 2. Assemble the discrete system A_h * u_h = b_h\n    # Using LIL format for efficient assembly\n    A_h = lil_matrix((n_nodes, n_nodes), dtype=np.float64)\n    b_h = np.zeros(n_nodes, dtype=np.float64)\n    \n    # Pre-calculate upwind coefficients\n    ax_pos = max(ax, 0)\n    ax_neg = min(ax, 0)\n    ay_pos = max(ay, 0)\n    ay_neg = min(ay, 0)\n\n    # Loop over all interior nodes (i, j)\n    for j in range(N):\n        for i in range(N):\n            # Map 2D (i, j) index to 1D k index\n            k = i + j * N\n            \n            # Source term at node (i, j)\n            b_h[k] = q_source(x[i], y[j], kappa, ax, ay)\n\n            # Assemble matrix A_h row by row\n            # Diagonal coefficient\n            diag_coeff = (4 * kappa / h**2) + (abs(ax) / h) + (abs(ay) / h)\n            A_h[k, k] = diag_coeff\n\n            # Off-diagonal coefficients for neighbors\n            # Left neighbor (i-1, j)\n            if i > 0:\n                A_h[k, k - 1] = -kappa / h**2 - ax_pos / h\n            # Right neighbor (i+1, j)\n            if i  N - 1:\n                A_h[k, k + 1] = -kappa / h**2 + ax_neg / h\n            # Bottom neighbor (i, j-1)\n            if j > 0:\n                A_h[k, k - N] = -kappa / h**2 - ay_pos / h\n            # Top neighbor (i, j+1)\n            if j  N - 1:\n                A_h[k, k + N] = -kappa / h**2 + ay_neg / h\n\n    # Boundary condition contributions to b_h are zero because u_star = 0 on the boundary.\n    # Convert matrix to CSC format for efficient solves\n    A_h_csc = A_h.tocsc()\n\n    # 3. Solve primal and adjoint systems\n    u_h = spsolve(A_h_csc, b_h)\n    \n    g_h = h**2 * np.ones(n_nodes)\n    psi_h = spsolve(A_h_csc.T, g_h)\n\n    # 4. Compute errors and indicators\n    # Exact solution on the grid (flattened)\n    u_star_h = u_star(X, Y).flatten()\n\n    # Truncation residual: tau_h = A_h * u_star_h - b_h\n    tau_h = A_h_csc @ u_star_h - b_h\n    \n    # Adjoint-based error indicator: eta_h = psi_h^T * tau_h\n    eta_h = psi_h.dot(tau_h)\n\n    # Actual discrete output error: eps_h = g_h^T * (u_star_h - u_h)\n    eps_h = g_h.dot(u_star_h - u_h)\n    \n    # 5. Compute the ratio\n    # The ratio should be 1.0 up to machine precision.\n    # Avoid division by zero if error is extremely small.\n    if abs(eps_h)  1e-15:\n        return 1.0 if abs(eta_h)  1e-15 else np.nan\n    \n    r = eta_h / eps_h\n    return r\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, kappa, a_x, a_y)\n        (16, 0.05, 1.0, 0.4),\n        (16, 0.05, -0.7, 1.3),\n        (32, 0.01, 2.0, -1.0),\n        (8, 0.1, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, kappa, ax, ay = case\n        result = compute_ratio(N, kappa, ax, ay)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "获得伴随信息只是任务的一半，真正的挑战在于如何有效地利用它来指导网格自适应。本练习模拟了一个实际应用场景，你必须根据伴随权重和局部解的特征，在不同类型的网格加密（$h$-型与$p$-型）之间做出选择。通过实现一个贪心算法，你将在固定的计算预算下探索优化网格加密所需的策略性决策过程。",
            "id": "3941845",
            "problem": "考虑一个通过欧拉方程建模的跨音速翼型上的二维无粘可压缩流，以及一个对应于阻力系数的标量泛函，记为 $J(\\boldsymbol{u}) = C_D$，其中 $\\boldsymbol{u}$ 表示状态向量（密度、动量分量、能量）。在基于伴随的误差估计框架中，$J$ 由于离散化而产生的误差可以通过一个基于在离散解上评估的 $J$ 的 Fréchet 导数的伴随加权残差表示来近似。这产生了一个形式如下的估计\n$$\n\\Delta J \\approx \\sum_{i=1}^{N_{\\text{el}}} w_i R_i,\n$$\n其中 $N_{\\text{el}}$ 是单元数量，$w_i$ 是单元 $i$ 的一个非负标量伴随权重，表示 $J$ 对局部扰动的敏感度，而 $R_i$ 是从主离散化中获得的单元 $i$ 的一个非负标量残差大小。\n\n基于伴随的网格加密程序试图通过根据伴随权重 $w_i$ 和局部解的正则性来分配加密，从而减小 $\\Delta J$。考虑两种加密类型：\n\n- $h$-加密：通过用更小的单元替换一个单元（减小局部尺寸），我们将其建模为将特征单元尺寸减半。假设初始尺寸已归一化，单次 $h$ 操作将尺寸减半。对于单元 $i$，定义一个平滑度参数 $s_i \\in [0,1]$，其中 $s_i = 1$ 表示局部解析/平滑流，而 $s_i = 0$ 表示强烈的非平滑特征（例如，激波或接触间断）。一次 $h$ 操作的建模残差减小因子为\n$$\n\\phi_h(s_i) = 2^{-\\left(r_s s_i + r_n (1 - s_i)\\right)},\n$$\n其中 $r_s  0$ 和 $r_n  0$ 分别代表在平滑和非平滑区域的有效收敛率。在单元 $i$ 上进行一次 $h$ 操作对应的预测阻力误差减少量为\n$$\n\\Delta e_{i,h} = w_i R_i \\left(1 - \\phi_h(s_i)\\right).\n$$\n\n- $p$-加密：将局部多项式阶数增加一。对于当前阶数为 $p_i \\in \\mathbb{N}$ 的单元 $i$，一次 $p$ 操作的建模残差减小因子为\n$$\n\\phi_p(s_i, p_i) = s_i e^{-\\alpha} + (1 - s_i) \\left(1 - \\frac{\\mu}{p_i + 1}\\right),\n$$\n其中 $\\alpha  0$ 参数化平滑区域的指数收敛，$\\mu \\in (0,1)$ 捕捉了 $p$-加密在非平滑区域的有限效果。在单元 $i$ 上进行一次 $p$ 操作对应的预测阻力误差减少量为\n$$\n\\Delta e_{i,p} = w_i R_i \\left(1 - \\phi_p(s_i, p_i)\\right).\n$$\n\n我们根据自由度的增加来对每个加密操作的计算成本进行建模。在二维情况下，假设在单元 $i$ 上进行一次 $h$ 操作的成本为\n$$\nc_{i,h} = \\eta_h (p_i + 1)^2,\n$$\n在单元 $i$ 上进行一次 $p$ 操作的成本为\n$$\nc_{i,p} = \\eta_p \\left( (p_i + 2)^2 - (p_i + 1)^2 \\right) = \\eta_p \\left( 2 p_i + 3 \\right),\n$$\n其中 $\\eta_h  0$ 和 $\\eta_p  0$ 是比例系数。给定一个总预算 $B$（以自由度单位衡量），我们寻求在伴随引导下，$h$ 和 $p$ 操作的最佳组合，以最小化预测的阻力误差\n$$\nE_{\\text{final}} = \\sum_{i=1}^{N_{\\text{el}}} w_i R_i \\psi_i,\n$$\n其中，如果单元 $i$ 接受 $h$ 操作，则 $\\psi_i = \\phi_h(s_i)$；如果单元 $i$ 接受 $p$ 操作，则 $\\psi_i = \\phi_p(s_i, p_i)$；如果单元 $i$ 未接受任何操作，则 $\\psi_i = 1$。对于此问题，限制为每个单元最多选择一个操作。\n\n您的任务是实现一个程序，对于每个测试用例，使用贪心策略来选择操作，以最大化单位成本的边际伴随加权残差减少量，同时受预算约束和每个单元最多一个操作的限制：\n- 对于每个单元 $i$，计算两个候选操作（$h$ 和 $p$），它们的预测减少量 $\\Delta e_{i,h}$、$\\Delta e_{i,p}$ 和成本 $c_{i,h}$、$c_{i,p}$。\n- 形成一个包含所有单元的所有候选操作的列表，每个操作都带有其效益成本比 $\\rho = \\Delta e / c$。\n- 按 $\\rho$ 的降序对操作进行排序，并贪心地选择操作，跳过任何已对其执行操作的单元的操作，直到如果采取下一个操作，总成本将超过预算 $B$。\n- 报告最终预测的阻力误差 $E_{\\text{final}}$（无量纲）和所选操作中 $p$-加密的比例，定义为 $f_p = N_p / (N_p + N_h)$，其中 $N_p$ 和 $N_h$ 分别是所选 $p$ 和 $h$ 操作的计数。如果未选择任何操作，则 $f_p = 0$。\n\n将 $E_{\\text{final}}$ 表示为无量纲浮点数，$f_p$ 表示为 $[0,1]$ 中的浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果，每个测试用例报告为一个二元列表 $[E_{\\text{final}}, f_p]$，每个浮点数必须四舍五入到六位小数。\n\n对所有测试用例使用以下参数：\n- $r_s = 2.0$, $r_n = 1.0$, $\\alpha = 1.0$, $\\mu = 0.5$, $\\eta_h = 1.0$, $\\eta_p = 1.0$。\n\n测试套件：\n- 案例 A（混合跨音速特征）：$N_{\\text{el}} = 8$，预算 $B = 60$，单元数据\n    - $s = [\\,0.1,\\,0.2,\\,0.9,\\,0.8,\\,0.5,\\,0.1,\\,0.95,\\,0.6\\,]$\n    - $w = [\\,1.5,\\,1.0,\\,0.7,\\,0.6,\\,0.8,\\,1.2,\\,0.4,\\,0.5\\,]$\n    - $R = [\\,0.08,\\,0.06,\\,0.03,\\,0.02,\\,0.025,\\,0.07,\\,0.015,\\,0.02\\,]$\n    - $p = [\\,3,\\,3,\\,4,\\,3,\\,2,\\,3,\\,4,\\,2\\,]$\n- 案例 B（零预算）：$N_{\\text{el}} = 5$，预算 $B = 0$，单元数据\n    - $s = [\\,0.4,\\,0.6,\\,0.5,\\,0.7,\\,0.3\\,]$\n    - $w = [\\,0.9,\\,0.7,\\,1.1,\\,0.8,\\,1.0\\,]$\n    - $R = [\\,0.04,\\,0.03,\\,0.05,\\,0.02,\\,0.06\\,]$\n    - $p = [\\,3,\\,2,\\,3,\\,4,\\,2\\,]$\n- 案例 C（主要为平滑流）：$N_{\\text{el}} = 6$，预算 $B = 50$，单元数据\n    - $s = [\\,0.95,\\,0.9,\\,0.85,\\,0.92,\\,0.88,\\,0.93\\,]$\n    - $w = [\\,0.6,\\,0.7,\\,0.5,\\,0.8,\\,0.65,\\,0.55\\,]$\n    - $R = [\\,0.025,\\,0.03,\\,0.02,\\,0.028,\\,0.026,\\,0.022\\,]$\n    - $p = [\\,3,\\,3,\\,2,\\,4,\\,3,\\,2\\,]$\n- 案例 D（主要为非平滑，激波主导）：$N_{\\text{el}} = 6$，预算 $B = 50$，单元数据\n    - $s = [\\,0.05,\\,0.1,\\,0.08,\\,0.12,\\,0.02,\\,0.15\\,]$\n    - $w = [\\,1.2,\\,1.0,\\,0.9,\\,1.1,\\,1.3,\\,0.95\\,]$\n    - $R = [\\,0.06,\\,0.055,\\,0.05,\\,0.065,\\,0.07,\\,0.045\\,]$\n    - $p = [\\,3,\\,2,\\,3,\\,4,\\,3,\\,2\\,]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含案例 A-D 的四个结果，作为用方括号括起来的逗号分隔列表，其中每个结果都是一个二元列表 $[E_{\\text{final}}, f_p]$，两个浮点数都四舍五入到六位小数。例如，格式应为\n$$\n[\\,[E_A, f_{p,A}],\\,[E_B, f_{p,B}],\\,[E_C, f_{p,C}],\\,[E_D, f_{p,D}]\\,].\n$$\n所有报告的 $E_{\\text{final}}$ 值都是纯无量纲量，所有 $f_p$ 值都是 $[0,1]$ 中的无量纲分数。",
            "solution": "用户提供了一个定义明确的计算问题，涉及计算流体动力学中基于伴随的网格加密。任务是实现一个指定的贪心算法，以在给定的计算预算内选择能够最优地减少预测误差泛函的网格加密操作。\n\n该问题被构建为一个约束优化任务。我们的目标是最大化总预测误差减少量 $\\Delta E_{total} = \\sum_{i \\in \\text{selected}} \\Delta e_i$，同时满足总成本约束 $\\sum_{i \\in \\text{selected}} c_i \\le B$ 和一个结构性约束，即任何给定单元最多只能应用一次加密操作。这是背包问题的一个变体，具体来说是多重选择背包问题，其中对于每个单元（“物品组”），我们可以从三个选项中选择一个：不操作、$h$-加密或 $p$-加密。\n\n问题指定了一种贪心启发式算法来寻找近似解。这种方法计算效率高，并且对于背包类问题通常是有效的。该策略的核心是优先考虑那些提供最大“性价比”的操作，这里用效益成本比来量化。\n\n此贪心算法的逐步实现如下：\n\n1.  **候选生成**：对于网格中的 $N_{\\text{el}}$ 个单元中的每一个，考虑两种潜在的加密操作：一种 $h$-加密和一种 $p$-加密。对于这 $2 \\times N_{\\text{el}}$ 个候选操作中的每一个，我们根据提供的公式计算三个关键指标：\n    *   **效益**：预测的误差减少量 $\\Delta e_i$。这是为 $h$- 和 $p$-加密类型计算的，公式为 $\\Delta e = w_i R_i (1 - \\phi)$，其中 $\\phi$ 是各自的残差减少因子（$\\phi_h$ 或 $\\phi_p$）。\n    *   **成本**：计算成本 $c_i$，以自由度为单位。成本 $c_{i,h}$ 和 $c_{i,p}$ 由单元当前的多项式阶数 $p_i$ 决定。\n    *   **效率**：效益成本比 $\\rho = \\Delta e / c$。该指标通过实现它所需的资源来标准化误差减少量，使其成为贪心选择的核心标准。\n\n2.  **贪心选择**：将生成的包含 $2 \\times N_{\\text{el}}$ 个候选操作的列表按其效率比 $\\rho$ 的降序排序。然后，算法遍历这个排序后的列表，首先考虑最有效的操作。对于列表中的每个操作，检查两个条件：\n    *   **预算约束**：该操作的成本不能导致所有已选操作的累计成本超过总预算 $B$。\n    *   **唯一性约束**：与该操作对应的单元之前不得被选择用于任何其他加密操作。\n\n    如果两个条件都满足，则选择该操作。其成本被加到运行总计中，其效益被累积，并且该单元被标记为“已加密”，以防止对其进行进一步操作。此过程持续进行，直到已评估完整个候选操作的排序列表。\n\n3.  **最终输出计算**：选择过程完成后，计算总初始误差为 $E_{\\text{initial}} = \\sum_{i=1}^{N_{\\text{el}}} w_i R_i$。从这个初始误差中减去已选操作实现的总误差减少量 $\\Delta E_{\\text{total}}$，得到最终的预测误差 $E_{\\text{final}} = E_{\\text{initial}} - \\Delta E_{\\text{total}}$。此外，计算所选操作中 $p$-类型的比例 $f_p = N_p / (N_p + N_h)$，其中 $N_p$ 和 $N_h$ 分别是所选 $p$-和 $h$-加密的总数。如果没有选择任何操作（例如，由于预算为零），则 $f_p$ 定义为 $0$。\n\n此过程独立应用于提供的每个测试用例，并以指定的格式报告最终结果 $E_{\\text{final}}$ 和 $f_p$。使用 NumPy 可以高效地、向量化地计算单元级属性。\n\n模型中提供的参数，例如收敛率（$r_s, r_n$）和成本因子（$\\eta_h, \\eta_p$），至关重要，因为它们实例化了在不同流动区域（平滑与非平滑）中 $h$- 和 $p$-加密策略的有效性和成本之间的权衡，这是偏微分方程高级数值方法中的一个核心主题。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a greedy algorithm for adjoint-based mesh refinement.\n    \"\"\"\n    # Global parameters for all test cases\n    r_s = 2.0\n    r_n = 1.0\n    alpha = 1.0\n    mu = 0.5\n    eta_h = 1.0\n    eta_p = 1.0\n\n    # Test suite data\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"B\": 60.0,\n            \"s\": np.array([0.1, 0.2, 0.9, 0.8, 0.5, 0.1, 0.95, 0.6]),\n            \"w\": np.array([1.5, 1.0, 0.7, 0.6, 0.8, 1.2, 0.4, 0.5]),\n            \"R\": np.array([0.08, 0.06, 0.03, 0.02, 0.025, 0.07, 0.015, 0.02]),\n            \"p\": np.array([3, 3, 4, 3, 2, 3, 4, 2]),\n        },\n        {\n            \"name\": \"Case B\",\n            \"B\": 0.0,\n            \"s\": np.array([0.4, 0.6, 0.5, 0.7, 0.3]),\n            \"w\": np.array([0.9, 0.7, 1.1, 0.8, 1.0]),\n            \"R\": np.array([0.04, 0.03, 0.05, 0.02, 0.06]),\n            \"p\": np.array([3, 2, 3, 4, 2]),\n        },\n        {\n            \"name\": \"Case C\",\n            \"B\": 50.0,\n            \"s\": np.array([0.95, 0.9, 0.85, 0.92, 0.88, 0.93]),\n            \"w\": np.array([0.6, 0.7, 0.5, 0.8, 0.65, 0.55]),\n            \"R\": np.array([0.025, 0.03, 0.02, 0.028, 0.026, 0.022]),\n            \"p\": np.array([3, 3, 2, 4, 3, 2]),\n        },\n        {\n            \"name\": \"Case D\",\n            \"B\": 50.0,\n            \"s\": np.array([0.05, 0.1, 0.08, 0.12, 0.02, 0.15]),\n            \"w\": np.array([1.2, 1.0, 0.9, 1.1, 1.3, 0.95]),\n            \"R\": np.array([0.06, 0.055, 0.05, 0.065, 0.07, 0.045]),\n            \"p\": np.array([3, 2, 3, 4, 3, 2]),\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        s, w, R, p, B = case[\"s\"], case[\"w\"], case[\"R\"], case[\"p\"], case[\"B\"]\n        N_el = len(s)\n        \n        # Calculate initial total error\n        wR = w * R\n        E_initial = np.sum(wR)\n\n        # Generate all candidate actions\n        candidate_actions = []\n        \n        # h-refinement actions\n        phi_h = 2**(-(r_s * s + r_n * (1 - s)))\n        delta_e_h = wR * (1 - phi_h)\n        c_h = eta_h * (p + 1)**2\n        # Avoid division by zero, although c_h > 0 for p >= 0\n        rho_h = np.divide(delta_e_h, c_h, out=np.zeros_like(delta_e_h), where=c_h!=0)\n\n        # p-refinement actions\n        phi_p = s * np.exp(-alpha) + (1 - s) * (1 - mu / (p + 1))\n        delta_e_p = wR * (1 - phi_p)\n        c_p = eta_p * (2 * p + 3)\n        # Avoid division by zero, although c_p > 0 for p >= 0\n        rho_p = np.divide(delta_e_p, c_p, out=np.zeros_like(delta_e_p), where=c_p!=0)\n\n        for i in range(N_el):\n            candidate_actions.append({\n                \"rho\": rho_h[i], \"benefit\": delta_e_h[i], \"cost\": c_h[i], \n                \"index\": i, \"type\": 'h'\n            })\n            candidate_actions.append({\n                \"rho\": rho_p[i], \"benefit\": delta_e_p[i], \"cost\": c_p[i], \n                \"index\": i, \"type\": 'p'\n            })\n            \n        # Sort actions by benefit-cost ratio in descending order\n        candidate_actions.sort(key=lambda x: x[\"rho\"], reverse=True)\n\n        # Greedy selection process\n        total_cost_used = 0.0\n        total_benefit = 0.0\n        N_h, N_p = 0, 0\n        element_refined = np.zeros(N_el, dtype=bool)\n\n        for action in candidate_actions:\n            idx = action[\"index\"]\n            cost = action[\"cost\"]\n            \n            if not element_refined[idx] and total_cost_used + cost = B:\n                total_cost_used += cost\n                total_benefit += action[\"benefit\"]\n                element_refined[idx] = True\n                if action[\"type\"] == 'h':\n                    N_h += 1\n                else: # 'p'\n                    N_p += 1\n        \n        # Calculate final results\n        E_final = E_initial - total_benefit\n        \n        if N_p + N_h > 0:\n            f_p = N_p / (N_p + N_h)\n        else:\n            f_p = 0.0\n            \n        all_results.append((E_final, f_p))\n\n    # Format the final output string\n    formatted_results = []\n    for e_final, fp in all_results:\n        formatted_results.append(f\"[{e_final:.6f},{fp:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}