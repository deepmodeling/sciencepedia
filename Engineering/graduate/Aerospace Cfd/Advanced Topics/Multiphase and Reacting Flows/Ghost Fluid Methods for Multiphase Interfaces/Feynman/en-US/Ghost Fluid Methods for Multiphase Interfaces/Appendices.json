{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of the Ghost Fluid Method is its ability to sharply enforce jump conditions at an interface. This first practice provides a direct implementation of this principle for a classic multiphase problem: a static, circular droplet in equilibrium. You will solve a Poisson equation for pressure, embedding the Young-Laplace pressure jump directly into the numerical scheme, and verify the accuracy of your GFM implementation .",
            "id": "4022595",
            "problem": "Implement a two-dimensional Ghost Fluid Method (GFM) to impose a pressure jump across a material interface due to surface tension and verify accuracy using a static droplet test. Consider a square computational domain of side length $L$ in meters, discretized on a Cartesian grid of $N \\times N$ nodes with uniform spacing $\\Delta x = \\Delta y = L/(N-1)$. A circular droplet of radius $R$ (in meters) is centered at $\\left(x_c, y_c\\right)=\\left(L/2,L/2\\right)$. Let $\\phi(x,y)$ be the signed distance level-set function, $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$, with $\\phi \\lt 0$ inside the droplet and $\\phi \\gt 0$ outside.\n\nAssume static equilibrium in each phase, so the pressure field $p(x,y)$ is piecewise harmonic: $\\nabla^2 p = 0$ in both regions, with a jump at the interface given by the Young–Laplace condition $\\Delta p = \\gamma \\kappa$, where $\\gamma$ is the surface tension (in $\\mathrm{N/m}$) and $\\kappa$ is the curvature (in $\\mathrm{m^{-1}}$). For a two-dimensional circular interface representing a planar cross-section of a cylindrical droplet, the curvature is $\\kappa = 1/R$. Impose homogeneous Dirichlet boundary conditions $p=0$ on the domain boundary to represent a reference ambient pressure. Use the five-point finite-difference stencil for the discrete Laplacian and implement the Ghost Fluid Method to enforce the jump condition across grid edges cut by the interface.\n\nGhost Fluid Method directive: For a grid node $(i,j)$, write the discrete Laplace equation as $4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}$. For each neighbor $(i',j')$ of $(i,j)$ such that $\\phi_{i,j}\\cdot\\phi_{i',j'} \\lt 0$ (the interface crosses the edge), add a jump contribution to the right-hand side:\n- If $\\phi_{i,j} \\lt 0$ and $\\phi_{i',j'} \\gt 0$, then $b_{i,j} \\leftarrow b_{i,j} + \\Delta p$.\n- If $\\phi_{i,j} \\gt 0$ and $\\phi_{i',j'} \\lt 0$, then $b_{i,j} \\leftarrow b_{i,j} - \\Delta p$.\nHere $\\Delta p = \\gamma \\kappa$ with $\\kappa = 1/R$. Apply $p=0$ strongly on the domain boundary nodes.\n\nVerification metric: For each test case, compute the infinity-norm error away from the interface as follows. Define inside mask $\\mathcal{M}^{-} = \\{(i,j): \\phi_{i,j} \\lt -\\tau\\}$ and outside mask $\\mathcal{M}^{+} = \\{(i,j): \\phi_{i,j} \\gt \\tau\\}$ with buffer $\\tau = 1.5 \\Delta x$. Let $p_{\\text{th}}^{-} = \\Delta p$ and $p_{\\text{th}}^{+} = 0$. Compute $E^{-}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{-}} \\left| p_{i,j} - p_{\\text{th}}^{-} \\right|$ and $E^{+}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{+}} \\left| p_{i,j} - p_{\\text{th}}^{+} \\right|$. Report $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$.\n\nPhysical units requirement: Express all errors $E_{\\infty}$ in pascals (Pa) as floating-point numbers.\n\nTest suite: Use the following parameter sets to exercise the method:\n1. $L=0.01$ m, $N=64$, $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$.\n2. $L=0.01$ m, $N=32$ (coarse grid), $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$.\n3. $L=0.01$ m, $N=128$ (fine grid), $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$.\n4. $L=0.01$ m, $N=128$, $R=0.0005$ m (small droplet), $\\gamma=0.072$ $\\mathrm{N/m}$.\n5. $L=0.01$ m, $N=128$, $R=0.0015$ m, $\\gamma=0.050$ $\\mathrm{N/m}$.\n\nFinal output format: Your program should produce a single line of output containing the errors for all five test cases as a comma-separated list enclosed in square brackets (e.g., \"[e1,e2,e3,e4,e5]\"), where each $e_k$ is a float in pascals (Pa).",
            "solution": "The user has provided a valid, well-posed, and scientifically grounded problem statement. The problem requires the implementation and verification of a two-dimensional Ghost Fluid Method (GFM) for a static droplet test case. The core of the problem is to solve for a piecewise harmonic pressure field with a sharp jump at a circular interface, governed by the Young-Laplace equation.\n\nThe problem is to find the pressure field $p(x,y)$ in a square domain of side length $L$. The domain contains a circular droplet of a different fluid, centered at $(L/2, L/2)$ with radius $R$. The interface between the two fluids is represented by the zero-contour of a signed distance function, $\\phi(x,y) = \\sqrt{(x-L/2)^2 + (y-L/2)^2} - R$, where $\\phi \\lt 0$ is inside the droplet and $\\phi \\gt 0$ is outside. In static equilibrium and neglecting body forces, the pressure in each fluid is constant, which satisfies the condition of being harmonic, $\\nabla^2 p = 0$. At the interface, there is a pressure jump dictated by the Young-Laplace equation, $\\Delta p = p_{\\text{inside}} - p_{\\text{outside}} = \\gamma \\kappa$. Here, $\\gamma$ is the surface tension and $\\kappa$ is the interface curvature. For a two-dimensional circular-cross section, the curvature is $\\kappa = 1/R$. The pressure on the domain boundary is fixed at a reference value of $p=0$. The theoretical solution is therefore a piecewise constant pressure field: $p(x,y) = \\Delta p$ for $\\phi < 0$ and $p(x,y) = 0$ for $\\phi > 0$.\n\nThe problem is discretized on a uniform $N \\times N$ Cartesian grid with spacing $\\Delta x = \\Delta y = L/(N-1)$. The Laplace operator is approximated using the standard five-point finite-difference stencil:\n$$\n\\nabla^2 p \\approx \\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4 p_{i,j}}{\\Delta x^2}\n$$\nThe problem specifies a rearrangement of this stencil into the form of a linear equation for each grid node $(i,j)$:\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}\n$$\nThis is equivalent to setting $-\\Delta x^2 (\\nabla^2_h p)_{i,j} = b_{i,j}$, where $\\nabla^2_h$ is the discrete Laplacian. For nodes away from the interface, the governing equation is $\\nabla^2 p = 0$, so the right-hand side $b_{i,j}$ is $0$. The pressure jump condition is enforced by defining non-zero values for $b_{i,j}$ for nodes adjacent to the interface, which is the essence of this particular Ghost Fluid Method.\n\nThe GFM models the pressure discontinuity by adding source terms to the right-hand side of the discrete equations for nodes whose stencils cross the interface. The directive states that for a node $(i,j)$ and its neighbor $(i',j')$, if the interface lies between them (i.e., $\\phi_{i,j} \\cdot \\phi_{i',j'} < 0$), a contribution is added to $b_{i,j}$.\nLet us analyze this directive. Consider a node $(i,j)$ in the liquid phase ($\\phi_{i,j} < 0$) and its neighbor $(i+1,j)$ in the gas phase ($\\phi_{i+1,j} > 0$). A rigorous GFM would define a ghost pressure at the location of $(i+1,j)$ by extrapolating from the gas-phase pressure. A first-order GFM defines this ghost pressure as $p_{i+1,j}^{\\text{ghost}} = p_{i+1,j} + \\Delta p$, where $p_{i+1,j}$ is the real pressure at the neighboring node. Substituting this into the stencil for node $(i,j)$:\n$$\n4 p_{i,j} - p_{i+1,j}^{\\text{ghost}} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\n$$\n4 p_{i,j} - (p_{i+1,j} + \\Delta p) - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\nRearranging this to match the problem's specified form gives:\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = \\Delta p\n$$\nThis implies that for node $(i,j)$, the RHS term $b_{i,j}$ should receive a contribution of $+\\Delta p$. This matches the directive: if $\\phi_{i,j} < 0$ and $\\phi_{i',j'} > 0$, $b_{i,j}$ is increased by $\\Delta p$.\nConversely, for the gas-phase node $(i+1,j)$, the jump is $p_{\\text{inside}} - p_{\\text{outside}} = \\Delta p$, which means $p_{\\text{outside}} - p_{\\text{inside}} = -\\Delta p$. The ghost pressure at the location of node $(i,j)$ is $p_{i,j}^{\\text{ghost}} = p_{i,j} - \\Delta p$. The stencil at $(i+1,j)$ becomes:\n$$\n4 p_{i+1,j} - p_{i+2,j} - p_{i,j}^{\\text{ghost}} - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\n$$\n4 p_{i+1,j} - p_{i+2,j} - (p_{i,j} - \\Delta p) - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\nThis gives a RHS contribution of $-\\Delta p$ for node $(i+1,j)$, which also matches the directive. The total RHS value $b_{i,j}$ for any node is the sum of contributions from all of its neighbors that are across the interface.\n\nThe complete set of discrete equations for all $N \\times N$ nodes forms a large, sparse linear system of the form $A \\mathbf{p} = \\mathbf{b}$. The vector $\\mathbf{p}$ contains the unknown pressure values, flattened from the 2D grid. The matrix $A$ is the coefficient matrix. For an internal node $(i,j)$, row $k=iN+j$ of $A$ contains the coefficients of the 5-point stencil: $4$ on the diagonal, and $-1$ for its four neighbors. For a boundary node, the Dirichlet condition $p=0$ is enforced strongly by setting the corresponding row of $A$ to be an identity row (i.e., $A_{k,k}=1$, $A_{k,l}=0$ for $l \\ne k$) and setting $b_k=0$. The vector $\\mathbf{b}$ contains the GFM source terms, which are non-zero only for nodes adjacent to the interface.\n\nThis sparse linear system is solved to obtain the numerical pressure field $p_{i,j}$. To verify accuracy, the numerical solution is compared against the known theoretical solution ($p_{\\text{th}}^{-} = \\Delta p$, $p_{\\text{th}}^{+} = 0$). The error is quantified using the infinity norm, computed away from the interface in regions defined by a buffer distance $\\tau = 1.5 \\Delta x$. The inside error $E^{-}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{-}|$ is computed for all nodes where $\\phi_{i,j} < -\\tau$, and the outside error $E^{+}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{+}|$ is computed for all nodes where $\\phi_{i,j} > \\tau$. The final reported error is $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$.\n\nThe algorithm is implemented in Python. Grid and field data are stored in `numpy` arrays. The large, sparse matrix $A$ is constructed using `scipy.sparse.lil_matrix` and the linear system is solved efficiently using `scipy.sparse.linalg.spsolve`. The procedure is executed for each of the five test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, R, gamma)\n        (0.01, 64, 0.002, 0.072),\n        (0.01, 32, 0.002, 0.072),\n        (0.01, 128, 0.002, 0.072),\n        (0.01, 128, 0.0005, 0.072),\n        (0.01, 128, 0.0015, 0.050),\n    ]\n\n    results = []\n    for L, N, R, gamma in test_cases:\n        error = solve_one_case(L, N, R, gamma)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(L, N, R, gamma):\n    \"\"\"\n    Implements the Ghost Fluid Method for a single static droplet test case.\n\n    Args:\n        L (float): Domain side length in meters.\n        N (int): Number of grid nodes in each dimension.\n        R (float): Droplet radius in meters.\n        gamma (float): Surface tension in N/m.\n\n    Returns:\n        float: The infinity-norm error E_inf in Pascals.\n    \"\"\"\n    # 1. Grid and Level-Set Setup\n    dx = L / (N - 1)\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    xx, yy = np.meshgrid(x, y)\n    \n    xc, yc = L / 2.0, L / 2.0\n    phi = np.sqrt((xx - xc)**2 + (yy - yc)**2) - R\n    \n    # 2. System Assembly (A p = b)\n    n_nodes = N * N\n    A = lil_matrix((n_nodes, n_nodes), dtype=np.float64)\n    b = np.zeros(n_nodes, dtype=np.float64)\n    \n    # Pressure jump and theoretical pressures\n    delta_p = gamma / R\n\n    # Iterate over all grid points to build matrix A and vector b\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j  # Flattened 1D index\n\n            # Strong enforcement of Dirichlet boundary conditions p=0\n            if i == 0 or i == N - 1 or j == 0 or j == N - 1:\n                A[k, k] = 1.0\n                b[k] = 0.0\n                continue\n\n            # Internal nodes: 5-point stencil for the Laplacian\n            A[k, k] = 4.0\n            A[k, k + 1] = -1.0  # Neighbor (i, j+1)\n            A[k, k - 1] = -1.0  # Neighbor (i, j-1)\n            A[k, k + N] = -1.0  # Neighbor (i+1, j)\n            A[k, k - N] = -1.0  # Neighbor (i-1, j)\n\n            # GFM: Add source terms to RHS for nodes adjacent to the interface\n            # Check right neighbor (i, j+1)\n            if phi[i, j] * phi[i, j + 1] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n            \n            # Check left neighbor (i, j-1)\n            if phi[i, j] * phi[i, j - 1] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n            \n            # Check top neighbor (i+1, j)\n            if phi[i, j] * phi[i + 1, j] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n\n            # Check bottom neighbor (i-1, j)\n            if phi[i, j] * phi[i - 1, j] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n    \n    # 3. Solve the Linear System\n    # Convert matrix to a more efficient format for solving\n    A_csc = A.tocsc()\n    p_flat = spsolve(A_csc, b)\n    p_sol = p_flat.reshape((N, N))\n\n    # 4. Error Verification\n    tau = 1.5 * dx\n    p_th_minus = delta_p\n    p_th_plus = 0.0\n\n    mask_inside = phi < -tau\n    mask_outside = phi > tau\n\n    p_values_inside = p_sol[mask_inside]\n    p_values_outside = p_sol[mask_outside]\n\n    err_inside = 0.0\n    if p_values_inside.size > 0:\n        err_inside = np.max(np.abs(p_values_inside - p_th_minus))\n\n    err_outside = 0.0\n    if p_values_outside.size > 0:\n        err_outside = np.max(np.abs(p_values_outside - p_th_plus))\n        \n    E_inf = max(err_inside, err_outside)\n    \n    return E_inf\n\nsolve()\n\n```"
        },
        {
            "introduction": "The accuracy of a GFM simulation often hinges on the quality of the geometric information provided to it, especially the interface curvature $\\kappa$. This exercise drills down into this critical component, asking you to quantify the numerical error in curvature computed from a level-set function. By exploring how perturbations in the level-set field affect the calculated curvature, you will gain crucial insight into a primary source of error in multiphase simulations .",
            "id": "3966953",
            "problem": "You are tasked with implementing a program to quantify the numerical error in the curvature-induced pressure jump imposed by the Ghost Fluid Method (GFM) for a static two-dimensional droplet, and to analyze how this error depends on the accuracy of the interface representation. The physical basis is the Young–Laplace law for capillarity: for a two-dimensional static droplet (representing the cross-section of an infinite cylinder), the pressure jump across the interface is given by $\\Delta p = \\sigma \\kappa$, where $\\sigma$ is the surface tension coefficient and $\\kappa$ is the curvature of the interface. For a perfect circle of radius $R$, the exact curvature is $\\kappa_{\\text{exact}} = 1/R$, and the exact pressure jump is $\\Delta p_{\\text{exact}} = \\sigma / R$. In the Ghost Fluid Method (GFM), jump conditions like $\\llbracket p \\rrbracket = \\sigma \\kappa$ are imposed at the interface using values of $\\kappa$ computed from an interface representation such as a level set function. Your goal is to compute the numerical error that arises from approximating the curvature and, consequently, the pressure jump, and to explore its dependence on the fidelity of the interface representation.\n\nConstruct a uniform Cartesian grid on the square domain $[0,1] \\times [0,1]$ with $N \\times N$ grid points, grid spacing $h = 1/(N-1)$, and place the circular droplet centered at $(x_c,y_c) = (0.5, 0.5)$ with radius $R$. Represent the interface implicitly using a level set function $\\phi(x,y)$ whose zero level set corresponds to the interface. Use the following baseline and perturbed interface representations:\n- Baseline (exact signed-distance) level set: $\\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R$.\n- Anisotropically scaled level set (zero level unchanged but off-interface values distorted): $\\phi(x,y) = \\phi_{\\text{exact}}(x,y)\\left(1 + \\varepsilon \\cos(m \\theta)\\right)$, where $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$, $\\varepsilon \\ge 0$, and integer $m \\ge 0$.\n- Oscillatory level set perturbation (zero level preserved but near-interface values modified): $\\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y)$, where $\\varepsilon \\ge 0$.\n\nFrom $\\phi$, compute the curvature numerically via the level set identity $\\kappa = \\nabla \\cdot \\left(\\nabla \\phi / |\\nabla \\phi|\\right)$. Use second-order central differences for spatial derivatives in the interior and consistent one-sided differences at boundaries. Identify all grid edges (both horizontal and vertical) that are cut by the interface, i.e., where $\\phi$ changes sign between the two end nodes. For each cut edge, linearly interpolate along the edge to locate the zero crossing and compute the curvature at that crossing by linearly interpolating the nodal curvature values at the two edge endpoints. Interpret the Ghost Fluid Method (GFM) as imposing a pressure jump $\\Delta p_{\\text{GFM}} = \\sigma \\kappa$ locally at each interface crossing, and thus define the error in the jump at that crossing as $|\\Delta p_{\\text{GFM}} - \\Delta p_{\\text{exact}}| = \\left|\\sigma \\kappa - \\sigma/R\\right|$. Aggregate the per-crossing errors over all cut edges by computing the root-mean-square error\n$$\nE_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2},\n$$\nwhere $M$ is the number of cut edges and $\\kappa_e$ is the interpolated curvature at crossing $e$.\n\nAll quantities are nondimensional; no physical units are to be used. Angles, such as $\\theta$, must be in radians. Your code must perform the above computations for the following test suite, each defined by a tuple $(N, R, \\sigma, \\text{mode}, \\varepsilon, m)$ where $\\text{mode} \\in \\{\\text{\"exact\"}, \\text{\"anisotropic\"}, \\text{\"oscillatory\"}\\}$ selects the interface representation, and $m$ is used only for the anisotropic mode:\n\n- Test $1$ (well-resolved, exact interface): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"exact\"}, 0.0, 0)$.\n- Test $2$ (well-resolved, anisotropic distortion): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"anisotropic\"}, 0.2, 6)$.\n- Test $3$ (under-resolved droplet, exact interface): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (64, 0.05, 1.0, \\text{\"exact\"}, 0.0, 0)$.\n- Test $4$ (well-resolved, oscillatory perturbation): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"oscillatory\"}, 0.5, 0)$.\n\nYour program should:\n1. Construct $\\phi$ according to the selected mode and parameters for each test.\n2. Compute the numerical curvature field $\\kappa$ from $\\phi$ as described.\n3. Detect interface crossings on grid edges and compute the interpolated curvature at each crossing.\n4. Compute $E_{\\text{RMS}}$ for $\\Delta p$ using the formula above with $\\Delta p_{\\text{exact}} = \\sigma/R$.\n5. Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$e_1,e_2,e_3,e_4$]\"), where each $e_i$ is the floating-point value of $E_{\\text{RMS}}$ for Test $i$.\n\nNo user input is required. The program must be completely deterministic. The final outputs are floats without any units or percentage signs, and angles are in radians throughout.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of computational fluid dynamics and multiphase flow, specifically the Young-Laplace law and the level-set method. It is well-posed, with all necessary parameters and numerical procedures clearly defined, ensuring a unique, deterministic solution. The language is objective and unambiguous. The proposed task constitutes a standard numerical analysis exercise to evaluate the accuracy of a numerical scheme, and it is free from any of the invalidating flaws outlined in the validation protocol.\n\nThe solution proceeds by implementing the specified numerical algorithm. The core of the problem is to compute the curvature $\\kappa$ of an interface defined by a level-set function $\\phi$, and then to quantify the error of a numerically-derived pressure jump against its analytical value.\n\nThe steps are as follows:\n1.  **Grid and Level-Set Function Generation**: A uniform Cartesian grid is established over the domain $[0, 1] \\times [0, 1]$. The grid consists of $N \\times N$ points, with grid spacing $h = 1/(N-1)$. The coordinates of the grid points are $(x_i, y_j) = (i h, j h)$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$. The circular interface is centered at $(x_c, y_c) = (0.5, 0.5)$ with radius $R$. The interface is represented by the zero contour of a level-set function, $\\phi(x,y) = 0$.\n\n    For each test case, the appropriate level-set function $\\phi$ is constructed on the grid:\n    -   The baseline representation is the exact signed distance function:\n        $$ \\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R $$\n    -   The anisotropically scaled level-set is:\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) \\left(1 + \\varepsilon \\cos(m \\theta)\\right) $$\n        where $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$. This modification preserves the zero level-set but alters the function's gradient field away from the interface.\n    -   The oscillatory perturbed level-set is:\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y) $$\n        This also preserves the zero level-set but introduces high-frequency oscillations, which challenges the accuracy of numerical differentiation.\n\n2.  **Numerical Curvature Calculation**: The curvature $\\kappa$ is computed from the level-set function using the divergence formula:\n    $$ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) = \\nabla \\cdot \\mathbf{n} $$\n    where $\\mathbf{n}$ is the unit normal vector field. The computation is performed in three stages at each grid node:\n    -   **Gradient of $\\phi$**: The gradient $\\nabla\\phi = (\\phi_x, \\phi_y) = (\\frac{\\partial\\phi}{\\partial x}, \\frac{\\partial\\phi}{\\partial y})$ is computed using finite differences. We employ second-order central differences for interior nodes and first-order one-sided differences for boundary nodes.\n    -   **Normal Vector Field**: The unit normal vector field $\\mathbf{n} = (n_x, n_y)$ is computed by normalizing the gradient:\n        $$ n_x = \\frac{\\phi_x}{\\sqrt{\\phi_x^2 + \\phi_y^2}}, \\quad n_y = \\frac{\\phi_y}{\\sqrt{\\phi_x^2 + \\phi_y^2}} $$\n        A small tolerance $\\epsilon_{\\text{mach}}$ is added to the denominator to prevent division by zero in regions where the gradient might vanish numerically (e.g., far from the interface).\n    -   **Divergence of $\\mathbf{n}$**: The curvature $\\kappa$ is the divergence of the normal field, $\\kappa = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y}$. The derivatives of the components of $\\mathbf{n}$ are computed using the same finite difference scheme (second-order central, first-order boundary).\n\n3.  **Interface Crossing Detection and Interpolation**: The algorithm identifies all horizontal and vertical grid edges that are intersected by the interface. An edge connecting two nodes, $A$ and $B$, is considered 'cut' if the level-set function has opposite signs at its endpoints, i.e., $\\phi_A \\cdot \\phi_B < 0$.\n    For each cut edge $e$, we perform two linear interpolations:\n    -   First, we find the fractional distance $\\alpha \\in (0,1)$ of the interface crossing from node $A$ along the edge:\n        $$ \\alpha = \\frac{|\\phi_A|}{|\\phi_A| + |\\phi_B|} $$\n    -   Second, we interpolate the nodal curvature values, $\\kappa_A$ and $\\kappa_B$, to estimate the curvature $\\kappa_e$ at the crossing point:\n        $$ \\kappa_e = (1-\\alpha)\\kappa_A + \\alpha\\kappa_B $$\n\n4.  **Error Quantification**: The error in the pressure jump is calculated for each crossing. The exact pressure jump is given by the Young-Laplace equation for a 2D circle: $\\Delta p_{\\text{exact}} = \\sigma / R$. The numerical pressure jump at a crossing $e$ is $\\Delta p_{\\text{GFM}} = \\sigma \\kappa_e$. The root-mean-square (RMS) error is aggregated over all $M$ cut edges:\n    $$ E_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2} $$\n    This metric provides a single value quantifying the overall accuracy of the curvature-induced pressure jump for a given test case.\n\nThe implementation of these steps for the specified test cases will produce the required list of $E_{\\text{RMS}}$ values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rms_error(N, R, sigma, mode, epsilon, m):\n    \"\"\"\n    Computes the RMS error in the GFM pressure jump for a static 2D droplet.\n    \"\"\"\n    # 1. Grid and Level-Set Function Generation\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    # Use 'ij' indexing for consistency with matrix row/column conventions\n    XX, YY = np.meshgrid(x, y, indexing='ij')\n\n    x_c, y_c = 0.5, 0.5\n    phi_exact = np.sqrt((XX - x_c)**2 + (YY - y_c)**2) - R\n\n    if mode == \"exact\":\n        phi = phi_exact\n    elif mode == \"anisotropic\":\n        theta_grid = np.arctan2(YY - y_c, XX - x_c)\n        phi = phi_exact * (1.0 + epsilon * np.cos(m * theta_grid))\n    elif mode == \"oscillatory\":\n        phi = phi_exact * (1.0 + epsilon * h * np.sin(2 * np.pi * XX) * np.sin(2 * np.pi * YY))\n    else:\n        raise ValueError(\"Unknown mode.\")\n\n    # 2. Numerical Curvature Calculation\n    # np.gradient uses 2nd-order central differences in the interior and\n    # 1st-order forward/backward differences at the boundaries.\n    # It returns derivatives with respect to each axis (axis 0, axis 1, ...).\n    # With 'ij' indexing, axis 0 is x and axis 1 is y.\n    phi_x, phi_y = np.gradient(phi, h, h)\n\n    # Normalize the gradient to get the normal vector field.\n    # Add a small machine epsilon to avoid division by zero.\n    norm_grad_phi = np.sqrt(phi_x**2 + phi_y**2) + np.finfo(float).eps\n    nx = phi_x / norm_grad_phi\n    ny = phi_y / norm_grad_phi\n\n    # Compute divergence of the normal field to get curvature.\n    nx_x, _ = np.gradient(nx, h, h)\n    _, ny_y = np.gradient(ny, h, h)\n    kappa = nx_x + ny_y\n    \n    # 3. Interface Crossing Detection and Interpolation\n    squared_errors = []\n    \n    # Horizontal edges (connecting (i,j) and (i+1,j))\n    for i in range(N - 1):\n        for j in range(N):\n            phi1 = phi[i, j]\n            phi2 = phi[i + 1, j]\n            if phi1 * phi2 < 0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i + 1, j]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Vertical edges (connecting (i,j) and (i,j+1))\n    for i in range(N):\n        for j in range(N - 1):\n            phi1 = phi[i, j]\n            phi2 = phi[i, j + 1]\n            if phi1 * phi2 < 0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i, j + 1]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Compute final RMS error\n    if not squared_errors:\n        return 0.0\n    \n    E_RMS = np.sqrt(np.mean(squared_errors))\n    return E_RMS\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, sigma, mode, epsilon, m)\n        (128, 0.25, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"anisotropic\", 0.2, 6),\n        (64, 0.05, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"oscillatory\", 0.5, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_error = calculate_rms_error(*case)\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The power of the GFM lies in its general applicability to different physical phenomena governed by interface jump conditions. Moving beyond static surface tension, this practice applies the GFM philosophy to the dynamic problem of acoustic wave propagation across a material boundary. By enforcing continuity of pressure and normal velocity, you will derive the reflection and transmission of waves and verify the fundamental principle of energy conservation at the interface .",
            "id": "3962467",
            "problem": "You are asked to implement and assess interface conditions used by the Ghost Fluid Method (GFM) for a two-material, one-dimensional, linear acoustics model relevant to Computational Fluid Dynamics (CFD) in aerospace applications. The objective is to verify and validate that enforcing continuity of pressure and normal velocity at a multiphase interface yields physically consistent reflection and transmission of waves across materials with differing acoustic impedances. Your program must compute, for each test case, the fractional energy imbalance implied by the computed reflected and transmitted waves, thereby providing a verification and validation benchmark for the interface operator.\n\nStarting point and physical model: use one-dimensional linear acoustics for each homogeneous material with acoustic impedance $Z$ defined by $Z=\\rho c$, where $\\rho$ is density and $c$ is sound speed. A right-going plane acoustic pressure wave of amplitude $P_i$ has associated normal velocity amplitude $u_i=P_i/Z$. A left-going wave has velocity amplitude $u=-P/Z$ due to propagation direction. At a stationary, inviscid, perfectly bonded interface between two materials, the physically correct interface conditions are continuity of pressure and continuity of normal velocity. For stiffened-gas materials, use the well-tested relationship $c=\\sqrt{\\gamma\\,(p_0+p_{\\infty})/\\rho}$, where $\\gamma$ is the ratio of specific heats, $p_0$ is the base thermodynamic pressure, and $p_{\\infty}$ is the stiffening pressure.\n\nTask specification:\n- For each test case, compute the acoustic impedance $Z$ on the left ($Z_L$) and on the right ($Z_R$).\n- For a given incident side (either left or right), enforce the Ghost Fluid Method interface conditions: continuity of pressure and continuity of normal velocity across the interface. From these conditions, determine the reflected pressure amplitude $P_r$ in the incident medium and the transmitted pressure amplitude $P_t$ in the other medium.\n- Compute the energy flux (also called acoustic intensity) for each wave as $I=P^2/Z$, using the appropriate impedance for each wave. Use $I_i$ for the incident wave, $I_r$ for the reflected wave, and $I_t$ for the transmitted wave.\n- Report the fractional energy imbalance $\\varepsilon=\\lvert I_i-I_r-I_t\\rvert/I_i$ for each test case as a decimal.\n\nUnits and numerical precision:\n- Use International System of Units (SI). Density $\\rho$ must be in $\\mathrm{kg/m^3}$, sound speed $c$ in $\\mathrm{m/s}$, pressure $p$ in $\\mathrm{Pa}$, and intensity $I$ in $\\mathrm{W/m^2}$.\n- Express the final fractional energy imbalance $\\varepsilon$ as a unitless decimal for each case.\n\nAlgorithmic constraints:\n- Derive $P_r$ and $P_t$ from first principles using the stated interface conditions; do not use shortcut formulas introduced without derivation.\n- If a test case specifies that sound speed must be computed via the stiffened-gas relationship, use $c=\\sqrt{\\gamma\\,(p_0+p_{\\infty})/\\rho}$ with the provided parameters; otherwise use the provided sound speeds directly.\n\nTest suite:\nProvide results for the following four test cases. Each case specifies whether to use the stiffened-gas sound speed or the given sound speeds, the material properties on the left and right, the incident pressure amplitude, and which side the wave is incident from.\n\n- Case A (air-to-water, stiffened-gas):\n  - Use stiffened-gas to compute sound speeds: true.\n  - Left material (air): $\\rho_L=1.225$ $\\mathrm{kg/m^3}$, $\\gamma_L=1.4$, $p_{\\infty,L}=0$ $\\mathrm{Pa}$, $p_{0,L}=101325$ $\\mathrm{Pa}$.\n  - Right material (water): $\\rho_R=1000.0$ $\\mathrm{kg/m^3}$, $\\gamma_R=4.4$, $p_{\\infty,R}=6.0\\times 10^{8}$ $\\mathrm{Pa}$, $p_{0,R}=101325$ $\\mathrm{Pa}$.\n  - Incident pressure amplitude: $P_i=1000.0$ $\\mathrm{Pa}$.\n  - Incident from: left.\n\n- Case B (equal impedances, direct sound speeds):\n  - Use stiffened-gas to compute sound speeds: false.\n  - Left: $\\rho_L=1000.0$ $\\mathrm{kg/m^3}$, $c_L=1500.0$ $\\mathrm{m/s}$.\n  - Right: $\\rho_R=500.0$ $\\mathrm{kg/m^3}$, $c_R=3000.0$ $\\mathrm{m/s}$.\n  - Incident pressure amplitude: $P_i=500.0$ $\\mathrm{Pa}$.\n  - Incident from: left.\n\n- Case C (strong mismatch, incident from right, direct sound speeds):\n  - Use stiffened-gas to compute sound speeds: false.\n  - Left: $\\rho_L=800.0$ $\\mathrm{kg/m^3}$, $c_L=300.0$ $\\mathrm{m/s}$.\n  - Right: $\\rho_R=1200.0$ $\\mathrm{kg/m^3}$, $c_R=2000.0$ $\\mathrm{m/s}$.\n  - Incident pressure amplitude: $P_i=750.0$ $\\mathrm{Pa}$.\n  - Incident from: right.\n\n- Case D (moderate mismatch, direct sound speeds):\n  - Use stiffened-gas to compute sound speeds: false.\n  - Left: $\\rho_L=1200.0$ $\\mathrm{kg/m^3}$, $c_L=400.0$ $\\mathrm{m/s}$.\n  - Right: $\\rho_R=1200.0$ $\\mathrm{kg/m^3}$, $c_R=800.0$ $\\mathrm{m/s}$.\n  - Incident pressure amplitude: $P_i=200.0$ $\\mathrm{Pa}$.\n  - Incident from: left.\n\nFinal output format:\nYour program should produce a single line of output containing the energy imbalance results for Case A, Case B, Case C, and Case D, in that order, as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4]$). Each $x_k$ must be the value of $\\varepsilon$ for the corresponding case expressed as a decimal.",
            "solution": "The problem requires the implementation and validation of interface conditions for a one-dimensional, two-material linear acoustics model, which is a foundational element of the Ghost Fluid Method (GFM) in aerospace Computational Fluid Dynamics (CFD). The core task is to verify that the enforcement of continuity of pressure and normal velocity at a material interface leads to energy conservation for incident, reflected, and transmitted acoustic waves. This is achieved by computing the fractional energy imbalance for several test cases.\n\nThe physical model is based on linear acoustics. For a homogeneous medium with density $\\rho$ and sound speed $c$, the acoustic impedance is defined as $Z = \\rho c$. For a right-propagating plane pressure wave of amplitude $P$, the associated particle velocity amplitude is $u = P/Z$. For a left-propagating wave, the velocity is $u = -P/Z$ due to the change in direction relative to the spatial coordinate.\n\nLet the interface between the left material (L) and the right material (R) be located at $x=0$. The material properties for $x<0$ are $\\rho_L$ and $c_L$, yielding an impedance $Z_L = \\rho_L c_L$. For $x>0$, the properties are $\\rho_R$ and $c_R$, with impedance $Z_R = \\rho_R c_R$.\n\nThe fundamental interface conditions for a stationary, inviscid, perfectly bonded interface are:\n$1$. Continuity of pressure: $p_{total, L}(0, t) = p_{total, R}(0, t)$.\n$2$. Continuity of normal velocity: $u_{total, L}(0, t) = u_{total, R}(0, t)$.\n\nWe will derive the amplitudes of the reflected wave ($P_r$) and transmitted wave ($P_t$) from an incident wave ($P_i$) by applying these conditions. The derivation depends on the direction of the incident wave.\n\n**Case 1: Incidence from the Left**\n\nAn incident wave of amplitude $P_i$ propagates from the left ($x<0$) towards the interface. This creates a reflected wave of amplitude $P_r$ propagating back into the left medium and a transmitted wave of amplitude $P_t$ propagating into the right medium.\n\n-   In the left medium ($x<0$): The total pressure is the sum of the incident (right-going) and reflected (left-going) waves, $P_{total, L} = P_i + P_r$. The total velocity is $u_{total, L} = u_i + u_r = P_i/Z_L - P_r/Z_L$.\n-   In the right medium ($x>0$): The total pressure is from the transmitted (right-going) wave, $P_{total, R} = P_t$. The total velocity is $u_{total, R} = u_t = P_t/Z_R$.\n\nApplying the interface conditions at $x=0$:\n$1$. Pressure continuity: $P_i + P_r = P_t$.\n$2$. Velocity continuity: $(P_i - P_r) / Z_L = P_t / Z_R$.\n\nWe now have a system of two linear equations for the two unknowns, $P_r$ and $P_t$. To solve, we can express $P_t$ from the second equation as $P_t = (Z_R/Z_L)(P_i - P_r)$ and substitute it into the first equation:\n$$P_i + P_r = \\frac{Z_R}{Z_L}(P_i - P_r)$$\n$$P_i Z_L + P_r Z_L = P_i Z_R - P_r Z_R$$\n$$P_r(Z_L + Z_R) = P_i(Z_R - Z_L)$$\nThis yields the reflected pressure amplitude:\n$$P_r = \\left(\\frac{Z_R - Z_L}{Z_R + Z_L}\\right) P_i$$\n\nTo find $P_t$, we substitute this result for $P_r$ back into the pressure continuity equation:\n$$P_t = P_i + P_r = P_i + \\left(\\frac{Z_R - Z_L}{Z_R + Z_L}\\right) P_i = P_i \\left(1 + \\frac{Z_R - Z_L}{Z_R + Z_L}\\right) = P_i \\left(\\frac{Z_R + Z_L + Z_R - Z_L}{Z_R + Z_L}\\right)$$\nThis yields the transmitted pressure amplitude:\n$$P_t = \\left(\\frac{2 Z_R}{Z_L + Z_R}\\right) P_i$$\n\n**Case 2: Incidence from the Right**\n\nAn incident wave of amplitude $P_i$ propagates from the right ($x>0$) towards the interface. This creates a reflected wave ($P_r$) propagating back into the right medium and a transmitted wave ($P_t$) propagating into the left medium.\n\n-   In the right medium ($x>0$): The total pressure is $P_{total, R} = P_i + P_r$, where $P_i$ is left-going and $P_r$ is right-going. The total velocity is $u_{total, R} = u_i + u_r = -P_i/Z_R + P_r/Z_R$.\n-   In the left medium ($x<0$): The total pressure is from the transmitted (left-going) wave, $P_{total, L} = P_t$. The total velocity is $u_{total, L} = u_t = -P_t/Z_L$.\n\nApplying the interface conditions at $x=0$:\n$1$. Pressure continuity: $P_t = P_i + P_r$.\n$2$. Velocity continuity: $-P_t / Z_L = (-P_i + P_r) / Z_R$.\n\nSubstitute the first equation into the second:\n$$-(P_i + P_r) / Z_L = (-P_i + P_r) / Z_R$$\n$$-P_i Z_R - P_r Z_R = -P_i Z_L + P_r Z_L$$\n$$P_i(Z_L - Z_R) = P_r(Z_L + Z_R)$$\nThis yields the reflected pressure amplitude:\n$$P_r = \\left(\\frac{Z_L - Z_R}{Z_L + Z_R}\\right) P_i$$\n\nTo find $P_t$, substitute $P_r$ back into the pressure continuity equation:\n$$P_t = P_i + P_r = P_i + \\left(\\frac{Z_L - Z_R}{Z_L + Z_R}\\right) P_i = P_i \\left(1 + \\frac{Z_L - Z_R}{Z_L + Z_R}\\right) = P_i \\left(\\frac{Z_L + Z_R + Z_L - Z_R}{Z_L + Z_R}\\right)$$\nThis yields the transmitted pressure amplitude:\n$$P_t = \\left(\\frac{2 Z_L}{Z_L + Z_R}\\right) P_i$$\n\n**Energy Conservation Verification**\n\nThe problem defines the acoustic intensity (energy flux) of a wave as $I = P^2/Z$. For an incident wave $I_i$, a reflected wave $I_r$, and a transmitted wave $I_t$, the principle of energy conservation requires that the incident energy flux equals the sum of the outgoing energy fluxes: $I_i = I_r + I_t$.\n\nLet's verify this for the case of incidence from the left.\nThe incident and reflected waves are in medium L, so their intensities are $I_i = P_i^2/Z_L$ and $I_r = P_r^2/Z_L$. The transmitted wave is in medium R, so its intensity is $I_t = P_t^2/Z_R$. The conservation equation is:\n$$\\frac{P_i^2}{Z_L} = \\frac{P_r^2}{Z_L} + \\frac{P_t^2}{Z_R}$$\nSubstituting the derived expressions for $P_r$ and $P_t$:\n$$\\frac{P_i^2}{Z_L} = \\frac{1}{Z_L} \\left(\\frac{Z_R - Z_L}{Z_R + Z_L} P_i\\right)^2 + \\frac{1}{Z_R} \\left(\\frac{2 Z_R}{Z_L + Z_R} P_i\\right)^2$$\nDividing by $P_i^2$ and simplifying:\n$$\\frac{1}{Z_L} = \\frac{(Z_R - Z_L)^2}{Z_L (Z_R + Z_L)^2} + \\frac{4 Z_R^2}{Z_R (Z_L + Z_R)^2}$$\n$$\\frac{1}{Z_L} = \\frac{Z_R^2 - 2 Z_L Z_R + Z_L^2}{Z_L (Z_R + Z_L)^2} + \\frac{4 Z_L Z_R}{Z_L (Z_R + Z_L)^2}$$\n$$\\frac{1}{Z_L} = \\frac{Z_R^2 - 2 Z_L Z_R + Z_L^2 + 4 Z_L Z_R}{Z_L (Z_R + Z_L)^2}$$\n$$\\frac{1}{Z_L} = \\frac{Z_R^2 + 2 Z_L Z_R + Z_L^2}{Z_L (Z_R + Z_L)^2} = \\frac{(Z_R + Z_L)^2}{Z_L (Z_R + Z_L)^2} = \\frac{1}{Z_L}$$\nThe identity holds. A similar proof can be constructed for incidence from the right. This confirms analytically that energy is conserved and the fractional energy imbalance, $\\varepsilon=\\lvert I_i-I_r-I_t\\rvert/I_i$, should be identically zero. The numerical computation will therefore serve as a verification test, where any non-zero result for $\\varepsilon$ would be attributable to floating-point precision errors.\n\nFor test cases requiring the stiffened-gas sound speed, the formula $c=\\sqrt{\\gamma(p_0+p_{\\infty})/\\rho}$ is used, where $\\gamma$ is the ratio of specific heats, $p_0$ is the base pressure, and $p_{\\infty}$ is the stiffening pressure.\n\nThe final step is to apply these derived formulas to calculate $\\varepsilon$ for each specified test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_imbalance(case_params):\n    \"\"\"\n    Calculates the fractional energy imbalance for a single test case.\n\n    Args:\n        case_params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The fractional energy imbalance epsilon.\n    \"\"\"\n    # Unpack parameters\n    use_stiffened_gas = case_params[\"use_stiffened_gas\"]\n    left_props = case_params[\"left\"]\n    right_props = case_params[\"right\"]\n    P_i = case_params[\"incident_pressure\"]\n    incident_from = case_params[\"incident_from\"]\n\n    # Calculate sound speeds\n    if use_stiffened_gas:\n        # Left material sound speed\n        rho_L = left_props[\"rho\"]\n        gamma_L = left_props[\"gamma\"]\n        p_inf_L = left_props[\"p_inf\"]\n        p0_L = left_props[\"p0\"]\n        c_L = np.sqrt(gamma_L * (p0_L + p_inf_L) / rho_L)\n\n        # Right material sound speed\n        rho_R = right_props[\"rho\"]\n        gamma_R = right_props[\"gamma\"]\n        p_inf_R = right_props[\"p_inf\"]\n        p0_R = right_props[\"p0\"]\n        c_R = np.sqrt(gamma_R * (p0_R + p_inf_R) / rho_R)\n    else:\n        rho_L = left_props[\"rho\"]\n        c_L = left_props[\"c\"]\n        rho_R = right_props[\"rho\"]\n        c_R = right_props[\"c\"]\n\n    # Calculate acoustic impedances\n    Z_L = rho_L * c_L\n    Z_R = rho_R * c_R\n\n    # Determine reflected and transmitted pressure amplitudes\n    if incident_from == 'left':\n        # Incident wave in medium L, transmitted to R\n        # Reflection coefficient for pressure\n        R_p = (Z_R - Z_L) / (Z_R + Z_L)\n        # Transmission coefficient for pressure\n        T_p = (2 * Z_R) / (Z_L + Z_R)\n        \n        P_r = R_p * P_i\n        P_t = T_p * P_i\n\n        # Calculate intensities\n        I_i = P_i**2 / Z_L\n        I_r = P_r**2 / Z_L\n        I_t = P_t**2 / Z_R\n\n    elif incident_from == 'right':\n        # Incident wave in medium R, transmitted to L\n        # Reflection coefficient for pressure\n        R_p = (Z_L - Z_R) / (Z_L + Z_R)\n        # Transmission coefficient for pressure\n        T_p = (2 * Z_L) / (Z_L + Z_R)\n\n        P_r = R_p * P_i\n        P_t = T_p * P_i\n\n        # Calculate intensities\n        I_i = P_i**2 / Z_R\n        I_r = P_r**2 / Z_R\n        I_t = P_t**2 / Z_L\n    else:\n        raise ValueError(\"Invalid incident_from value. Must be 'left' or 'right'.\")\n\n    # Calculate fractional energy imbalance\n    # This should be zero analytically. Numerically, it will be close to zero.\n    if I_i == 0:\n        return 0.0\n    \n    epsilon = np.abs(I_i - I_r - I_t) / I_i\n    \n    return epsilon\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for all given test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case A (air-to-water, stiffened-gas)\n        {\n            \"use_stiffened_gas\": True,\n            \"left\": {\"rho\": 1.225, \"gamma\": 1.4, \"p_inf\": 0.0, \"p0\": 101325.0},\n            \"right\": {\"rho\": 1000.0, \"gamma\": 4.4, \"p_inf\": 6.0e8, \"p0\": 101325.0},\n            \"incident_pressure\": 1000.0,\n            \"incident_from\": \"left\",\n        },\n        # Case B (equal impedances, direct sound speeds)\n        {\n            \"use_stiffened_gas\": False,\n            \"left\": {\"rho\": 1000.0, \"c\": 1500.0},\n            \"right\": {\"rho\": 500.0, \"c\": 3000.0},\n            \"incident_pressure\": 500.0,\n            \"incident_from\": \"left\",\n        },\n        # Case C (strong mismatch, incident from right, direct sound speeds)\n        {\n            \"use_stiffened_gas\": False,\n            \"left\": {\"rho\": 800.0, \"c\": 300.0},\n            \"right\": {\"rho\": 1200.0, \"c\": 2000.0},\n            \"incident_pressure\": 750.0,\n            \"incident_from\": \"right\",\n        },\n        # Case D (moderate mismatch, direct sound speeds)\n        {\n            \"use_stiffened_gas\": False,\n            \"left\": {\"rho\": 1200.0, \"c\": 400.0},\n            \"right\": {\"rho\": 1200.0, \"c\": 800.0},\n            \"incident_pressure\": 200.0,\n            \"incident_from\": \"left\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_imbalance(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}