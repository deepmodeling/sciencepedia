{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。本节将指导您通过一系列精心设计的编程练习，将前面学到的幽灵流体法（GFM）核心概念应用于实际问题中。第一个练习将从一个经典问题入手：一个静态液滴中的表面张力效应。您将实现一个简化版的幽灵流体法，用于在泊松方程中施加由杨-拉普拉斯定律（Young-Laplace law）决定的压力跳跃，这是掌握GFM在处理表面张力问题中应用的基础。",
            "id": "4022595",
            "problem": "实现一个二维鬼点法 (GFM)，以施加由表面张力引起的跨材料界面的压力跳跃，并使用静态液滴测试来验证其准确性。考虑一个边长为 $L$ 米的方形计算域，该域在 $N \\times N$ 个节点的笛卡尔网格上离散化，均匀间距为 $\\Delta x = \\Delta y = L/(N-1)$。一个半径为 $R$ 米的圆形液滴以 $\\left(x_c, y_c\\right)=\\left(L/2,L/2\\right)$ 为中心。设 $\\phi(x,y)$ 为符号距离水平集函数，$\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$，其中液滴内部 $\\phi < 0$，外部 $\\phi > 0$。\n\n假设每个相都处于静态平衡状态，因此压力场 $p(x,y)$ 是分段调和的：在两个区域中均为 $\\nabla^2 p = 0$，界面处的跳跃由 Young-Laplace 条件 $\\Delta p = \\gamma \\kappa$ 给出，其中 $\\gamma$ 是表面张力（单位为 $\\mathrm{N/m}$），$\\kappa$ 是曲率（单位为 $\\mathrm{m^{-1}}$）。对于代表圆柱形液滴平面横截面的二维圆形界面，曲率为 $\\kappa = 1/R$。在区域边界上施加齐次狄利克雷边界条件 $p=0$，以表示参考环境压力。使用五点有限差分格式来表示离散拉普拉斯算子，并实现鬼点法，以在被界面切割的网格边上强制施加跳跃条件。\n\n鬼点法指令：对于网格节点 $(i,j)$，将离散拉普拉斯方程写为 $4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}$。对于 $(i,j)$ 的每个邻居 $(i',j')$，如果满足 $\\phi_{i,j}\\cdot\\phi_{i',j'} < 0$（即界面穿过该边），则向右侧添加一个跳跃贡献：\n- 如果 $\\phi_{i,j} < 0$ 且 $\\phi_{i',j'} > 0$，则 $b_{i,j} \\leftarrow b_{i,j} + \\Delta p$。\n- 如果 $\\phi_{i,j} > 0$ 且 $\\phi_{i',j'} < 0$，则 $b_{i,j} \\leftarrow b_{i,j} - \\Delta p$。\n这里 $\\Delta p = \\gamma \\kappa$，其中 $\\kappa = 1/R$。在区域边界节点上强行施加 $p=0$。\n\n验证指标：对于每个测试用例，按如下方式计算远离界面的无穷范数误差。定义内部掩码 $\\mathcal{M}^{-} = \\{(i,j): \\phi_{i,j} < -\\tau\\}$ 和外部掩码 $\\mathcal{M}^{+} = \\{(i,j): \\phi_{i,j} > \\tau\\}$，缓冲区 $\\tau = 1.5 \\Delta x$。设 $p_{\\text{th}}^{-} = \\Delta p$ 和 $p_{\\text{th}}^{+} = 0$。计算 $E^{-}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{-}} \\left| p_{i,j} - p_{\\text{th}}^{-} \\right|$ 和 $E^{+}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{+}} \\left| p_{i,j} - p_{\\text{th}}^{+} \\right|$。报告 $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$。\n\n物理单位要求：将所有误差 $E_{\\infty}$ 以帕斯卡（Pa）为单位表示为浮点数。\n\n测试套件：使用以下参数集来检验该方法：\n1. $L=0.01$ 米, $N=64$, $R=0.002$ 米, $\\gamma=0.072$ $\\mathrm{N/m}$。\n2. $L=0.01$ 米, $N=32$ (粗网格), $R=0.002$ 米, $\\gamma=0.072$ $\\mathrm{N/m}$。\n3. $L=0.01$ 米, $N=128$ (细网格), $R=0.002$ 米, $\\gamma=0.072$ $\\mathrm{N/m}$。\n4. $L=0.01$ 米, $N=128$, $R=0.0005$ 米 (小液滴), $\\gamma=0.072$ $\\mathrm{N/m}$。\n5. $L=0.01$ 米, $N=128$, $R=0.0015$ 米, $\\gamma=0.050$ $\\mathrm{N/m}$。\n\n最终输出格式：你的程序应生成单行输出，其中包含所有五个测试用例的误差，格式为方括号内以逗号分隔的列表（例如，“$[e1,e2,e3,e4,e5]”），其中每个 $e_k$ 是一个以帕斯卡（Pa）为单位的浮点数。",
            "solution": "用户提供了一个有效、适定且有科学依据的问题陈述。该问题要求实现并验证一个用于静态液滴测试用例的二维鬼点法（GFM）。问题的核心是求解一个在圆形界面处存在急剧跳跃的分段调和压力场，该跳跃由 Young-Laplace 方程控制。\n\n问题是在一个边长为 $L$ 的方形域中找到压力场 $p(x,y)$。该域包含一个由不同流体组成的圆形液滴，中心位于 $(L/2, L/2)$，半径为 $R$。两种流体之间的界面由一个符号距离函数的零等值线表示，$\\phi(x,y) = \\sqrt{(x-L/2)^2 + (y-L/2)^2} - R$，其中液滴内部 $\\phi < 0$，外部 $\\phi > 0$。在静态平衡且忽略体力的情况下，每种流体中的压力是恒定的，这满足了调和条件 $\\nabla^2 p = 0$。在界面处，存在一个由 Young-Laplace 方程决定的压力跳跃，$\\Delta p = p_{\\text{inside}} - p_{\\text{outside}} = \\gamma \\kappa$。这里，$\\gamma$ 是表面张力，$\\kappa$ 是界面曲率。对于二维圆形横截面，曲率为 $\\kappa = 1/R$。在区域边界上的压力固定为参考值 $p=0$。因此，理论解是一个分段常数压力场：当 $\\phi < 0$ 时，$p(x,y) = \\Delta p$；当 $\\phi > 0$ 时，$p(x,y) = 0$。\n\n该问题在一个均匀的 $N \\times N$ 笛卡尔网格上离散化，网格间距为 $\\Delta x = \\Delta y = L/(N-1)$。拉普拉斯算子使用标准的五点有限差分格式进行近似：\n$$\n\\nabla^2 p \\approx \\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4 p_{i,j}}{\\Delta x^2}\n$$\n问题指定将此格式重新排列为针对每个网格节点 $(i,j)$ 的线性方程形式：\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}\n$$\n这等价于设置 $-\\Delta x^2 (\\nabla^2_h p)_{i,j} = b_{i,j}$，其中 $\\nabla^2_h$ 是离散拉普拉斯算子。对于远离界面的节点，控制方程为 $\\nabla^2 p = 0$，因此右侧项 $b_{i,j}$ 为 $0$。压力跳跃条件是通过为邻近界面的节点定义非零的 $b_{i,j}$ 值来强制施加的，这是此特定鬼点法的精髓。\n\nGFM 通过在模板跨越界面的节点的离散方程的右侧添加源项来模拟压力不连续性。指令指出，对于节点 $(i,j)$ 及其邻居 $(i',j')$，如果界面位于它们之间（即 $\\phi_{i,j} \\cdot \\phi_{i',j'} < 0$），则向 $b_{i,j}$ 添加一个贡献。\n我们来分析这条指令。考虑一个位于液相中的节点 $(i,j)$（$\\phi_{i,j} < 0$）及其位于气相中的邻居 $(i+1,j)$（$\\phi_{i+1,j} > 0$）。一个严格的 GFM 会通过从气相压力外插来定义位于 $(i+1,j)$ 位置的鬼点压力。一阶 GFM 将此鬼点压力定义为 $p_{i+1,j}^{\\text{ghost}} = p_{i+1,j} + \\Delta p$，其中 $p_{i+1,j}$ 是邻近节点的真实压力。将此代入节点 $(i,j)$ 的格式中：\n$$\n4 p_{i,j} - p_{i+1,j}^{\\text{ghost}} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\n$$\n4 p_{i,j} - (p_{i+1,j} + \\Delta p) - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\n将其重新整理成问题指定的形式，得到：\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = \\Delta p\n$$\n这意味着对于节点 $(i,j)$，右侧项 $b_{i,j}$ 应收到一个 $+\\Delta p$ 的贡献。这与指令相符：如果 $\\phi_{i,j} < 0$ 且 $\\phi_{i',j'} > 0$，则 $b_{i,j}$ 增加 $\\Delta p$。\n反之，对于气相节点 $(i+1,j)$，跳跃为 $p_{\\text{inside}} - p_{\\text{outside}} = \\Delta p$，这意味着 $p_{\\text{outside}} - p_{\\text{inside}} = -\\Delta p$。位于节点 $(i,j)$ 位置的鬼点压力是 $p_{i,j}^{\\text{ghost}} = p_{i,j} - \\Delta p$。在 $(i+1,j)$ 处的格式变为：\n$$\n4 p_{i+1,j} - p_{i+2,j} - p_{i,j}^{\\text{ghost}} - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\n$$\n4 p_{i+1,j} - p_{i+2,j} - (p_{i,j} - \\Delta p) - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\n这为节点 $(i+1,j)$ 提供了 $-\\Delta p$ 的右侧项贡献，这也与指令相符。任何节点的总右侧值 $b_{i,j}$ 是其所有跨界面邻居贡献的总和。\n\n所有 $N \\times N$ 个节点的完整离散方程组构成一个形式为 $A \\mathbf{p} = \\mathbf{b}$ 的大型稀疏线性系统。向量 $\\mathbf{p}$ 包含从二维网格展平的未知压力值。矩阵 $A$ 是系数矩阵。对于一个内部节点 $(i,j)$， $A$ 的第 $k=iN+j$ 行包含五点格式的系数：对角线上为 $4$，其四个邻居对应位置为 $-1$。对于边界节点，通过将 $A$ 的相应行设置成单位行（即 $A_{k,k}=1$，$l \\ne k$ 时 $A_{k,l}=0$）并设置 $b_k=0$ 来强行施加狄利克雷条件 $p=0$。向量 $\\mathbf{b}$ 包含 GFM 源项，这些项仅在邻近界面的节点处非零。\n\n求解这个稀疏线性系统以获得数值压力场 $p_{i,j}$。为验证准确性，将数值解与已知的理论解（$p_{\\text{th}}^{-} = \\Delta p$, $p_{\\text{th}}^{+} = 0$）进行比较。误差使用无穷范数进行量化，该范数在由缓冲距离 $\\tau = 1.5 \\Delta x$ 定义的远离界面的区域计算。内部误差 $E^{-}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{-}|$ 是对所有满足 $\\phi_{i,j} < -\\tau$ 的节点计算的，而外部误差 $E^{+}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{+}|$ 是对所有满足 $\\phi_{i,j} > \\tau$ 的节点计算的。最终报告的误差是 $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$。\n\n该算法用 Python 实现。网格和场数据存储在 `numpy` 数组中。大型稀疏矩阵 $A$ 使用 `scipy.sparse.lil_matrix` 构建，线性系统使用 `scipy.sparse.linalg.spsolve` 高效求解。对提供的五个测试用例中的每一个都执行此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, R, gamma)\n        (0.01, 64, 0.002, 0.072),\n        (0.01, 32, 0.002, 0.072),\n        (0.01, 128, 0.002, 0.072),\n        (0.01, 128, 0.0005, 0.072),\n        (0.01, 128, 0.0015, 0.050),\n    ]\n\n    results = []\n    for L, N, R, gamma in test_cases:\n        error = solve_one_case(L, N, R, gamma)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(L, N, R, gamma):\n    \"\"\"\n    Implements the Ghost Fluid Method for a single static droplet test case.\n\n    Args:\n        L (float): Domain side length in meters.\n        N (int): Number of grid nodes in each dimension.\n        R (float): Droplet radius in meters.\n        gamma (float): Surface tension in N/m.\n\n    Returns:\n        float: The infinity-norm error E_inf in Pascals.\n    \"\"\"\n    # 1. Grid and Level-Set Setup\n    dx = L / (N - 1)\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    xx, yy = np.meshgrid(x, y)\n    \n    xc, yc = L / 2.0, L / 2.0\n    phi = np.sqrt((xx - xc)**2 + (yy - yc)**2) - R\n    \n    # 2. System Assembly (A p = b)\n    n_nodes = N * N\n    A = lil_matrix((n_nodes, n_nodes), dtype=np.float64)\n    b = np.zeros(n_nodes, dtype=np.float64)\n    \n    # Pressure jump and theoretical pressures\n    delta_p = gamma / R\n\n    # Iterate over all grid points to build matrix A and vector b\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j  # Flattened 1D index\n\n            # Strong enforcement of Dirichlet boundary conditions p=0\n            if i == 0 or i == N - 1 or j == 0 or j == N - 1:\n                A[k, k] = 1.0\n                b[k] = 0.0\n                continue\n\n            # Internal nodes: 5-point stencil for the Laplacian\n            A[k, k] = 4.0\n            A[k, k + 1] = -1.0  # Neighbor (i, j+1)\n            A[k, k - 1] = -1.0  # Neighbor (i, j-1)\n            A[k, k + N] = -1.0  # Neighbor (i+1, j)\n            A[k, k - N] = -1.0  # Neighbor (i-1, j)\n\n            # GFM: Add source terms to RHS for nodes adjacent to the interface\n            # Check right neighbor (i, j+1)\n            if phi[i, j] * phi[i, j + 1] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n            \n            # Check left neighbor (i, j-1)\n            if phi[i, j] * phi[i, j - 1] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n            \n            # Check top neighbor (i+1, j)\n            if phi[i, j] * phi[i + 1, j] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n\n            # Check bottom neighbor (i-1, j)\n            if phi[i, j] * phi[i - 1, j] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n    \n    # 3. Solve the Linear System\n    # Convert matrix to a more efficient format for solving\n    A_csc = A.tocsc()\n    p_flat = spsolve(A_csc, b)\n    p_sol = p_flat.reshape((N, N))\n\n    # 4. Error Verification\n    tau = 1.5 * dx\n    p_th_minus = delta_p\n    p_th_plus = 0.0\n\n    mask_inside = phi < -tau\n    mask_outside = phi > tau\n\n    p_values_inside = p_sol[mask_inside]\n    p_values_outside = p_sol[mask_outside]\n\n    err_inside = 0.0\n    if p_values_inside.size > 0:\n        err_inside = np.max(np.abs(p_values_inside - p_th_minus))\n\n    err_outside = 0.0\n    if p_values_outside.size > 0:\n        err_outside = np.max(np.abs(p_values_outside - p_th_plus))\n        \n    E_inf = max(err_inside, err_outside)\n    \n    return E_inf\n\nsolve()\n\n```"
        },
        {
            "introduction": "在上一个练习中，我们假设界面曲率 $\\kappa$ 是一个已知常数。然而，在真实的模拟中，曲率本身必须根据界面的几何形状（通常由水平集函数等方法描述）进行数值计算。这个计算的精度直接影响到表面张力效应的准确性，进而影响整个流场的模拟结果。本练习旨在深入探讨这一关键环节，要求您实现一个从水平集函数计算曲率的程序，并分析不同水平集函数表示方法对曲率计算误差的影响，从而加深对GFM方法精度来源的理解。",
            "id": "3966953",
            "problem": "您的任务是实现一个程序，来量化由 Ghost Fluid Method (GFM) 对静态二维液滴施加的、由曲率引起的压力跳跃中的数值误差，并分析该误差如何依赖于界面表示的准确性。其物理基础是关于毛细作用的 Young–Laplace 定律：对于一个二维静态液滴（代表无限长圆柱体的横截面），跨界面的压力跳跃由 $\\Delta p = \\sigma \\kappa$ 给出，其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是界面的曲率。对于半径为 $R$ 的完美圆形，精确曲率为 $\\kappa_{\\text{exact}} = 1/R$，精确压力跳跃为 $\\Delta p_{\\text{exact}} = \\sigma / R$。在 Ghost Fluid Method (GFM) 中，像 $\\llbracket p \\rrbracket = \\sigma \\kappa$ 这样的跳跃条件是通过使用根据界面表示（如水平集函数）计算出的 $\\kappa$ 值在界面处施加的。您的目标是计算因近似曲率以及由此产生的压力跳跃所带来的数值误差，并探究其对界面表示保真度的依赖性。\n\n在方形域 $[0,1] \\times [0,1]$ 上构建一个包含 $N \\times N$ 个网格点的均匀笛卡尔网格，网格间距为 $h = 1/(N-1)$，并将圆形液滴置于中心 $(x_c,y_c) = (0.5, 0.5)$，半径为 $R$。使用水平集函数 $\\phi(x,y)$ 来隐式表示界面，其零水平集对应于该界面。使用以下基准和扰动界面表示：\n- 基准（精确符号距离）水平集：$\\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R$。\n- 各向异性缩放水平集（零水平集不变，但离界面值被扭曲）：$\\phi(x,y) = \\phi_{\\text{exact}}(x,y)\\left(1 + \\varepsilon \\cos(m \\theta)\\right)$，其中 $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$，$\\varepsilon \\ge 0$ 且整数 $m \\ge 0$。\n- 振荡水平集扰动（零水平集保留，但近界面值被修改）：$\\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y)$，其中 $\\varepsilon \\ge 0$。\n\n根据 $\\phi$，通过水平集恒等式 $\\kappa = \\nabla \\cdot \\left(\\nabla \\phi / \\|\\nabla \\phi\\|\\right)$ 数值计算曲率。在内部使用二阶中心差分计算空间导数，在边界上使用一致的单边差分。识别所有被界面切割的网格边（水平和垂直），即 $\\phi$ 在两个端节点之间变号的边。对于每条被切割的边，沿该边进行线性插值以定位零交叉点，并通过对两个边端点处的节点曲率值进行线性插值来计算该交叉点的曲率。将 Ghost Fluid Method (GFM) 解释为在每个界面交叉点局部施加一个压力跳跃 $\\Delta p_{\\text{GFM}} = \\sigma \\kappa$，因此，将在该交叉点处的跳跃误差定义为 $|\\Delta p_{\\text{GFM}} - \\Delta p_{\\text{exact}}| = \\left|\\sigma \\kappa - \\sigma/R\\right|$。通过计算均方根误差来汇总所有被切割边上的每个交叉点的误差\n$$\nE_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2},\n$$\n其中 $M$ 是被切割边的数量，$\\kappa_e$ 是在交叉点 $e$ 处的插值曲率。\n\n所有量都是无量纲的；不使用物理单位。角度，如 $\\theta$，必须以弧度为单位。您的代码必须对以下测试套件执行上述计算，每个测试由一个元组 $(N, R, \\sigma, \\text{mode}, \\varepsilon, m)$ 定义，其中 $\\text{mode} \\in \\{\\text{\"exact\"}, \\text{\"anisotropic\"}, \\text{\"oscillatory\"}\\}$ 选择界面表示，而 $m$ 仅用于各向异性模式：\n\n- 测试 1 (良好解析，精确界面): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"exact\"}, 0.0, 0)$。\n- 测试 2 (良好解析，各向异性扭曲): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"anisotropic\"}, 0.2, 6)$。\n- 测试 3 (欠解析液滴，精确界面): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (64, 0.05, 1.0, \\text{\"exact\"}, 0.0, 0)$。\n- 测试 4 (良好解析，振荡扰动): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"oscillatory\"}, 0.5, 0)$。\n\n您的程序应：\n1. 根据每个测试所选的模式和参数构建 $\\phi$。\n2. 按照描述从 $\\phi$ 计算数值曲率场 $\\kappa$。\n3. 检测网格边上的界面交叉点，并计算每个交叉点处的插值曲率。\n4. 使用上述公式，以 $\\Delta p_{\\text{exact}} = \\sigma/R$ 计算 $\\Delta p$ 的 $E_{\\text{RMS}}$。\n5. 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[$e_1,e_2,e_3,e_4$]”），其中每个 $e_i$ 是测试 $i$ 的 $E_{\\text{RMS}}$ 的浮点值。\n\n无需用户输入。程序必须是完全确定性的。最终输出是浮点数，不带任何单位或百分号，并且所有角度均以弧度为单位。",
            "solution": "该问题是有效的，因为它在科学上基于计算流体动力学和多相流的原理，特别是 Young-Laplace 定律和水平集方法。它是一个适定问题，所有必要的参数和数值程序都已明确定义，确保了唯一、确定性的解。其语言客观且明确。所提议的任务构成了一个标准的数值分析练习，用于评估一个数值方案的准确性，并且没有任何在验证协议中概述的导致无效的缺陷。\n\n解决方案通过实现指定的数值算法来推进。问题的核心是计算由水平集函数 $\\phi$ 定义的界面的曲率 $\\kappa$，然后量化数值导出的压力跳跃与其解析值之间的误差。\n\n步骤如下：\n1.  **网格和水平集函数生成**：在域 $[0, 1] \\times [0, 1]$ 上建立一个均匀的笛卡尔网格。该网格包含 $N \\times N$ 个点，网格间距为 $h = 1/(N-1)$。网格点的坐标为 $(x_i, y_j) = (i h, j h)$，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$。圆形界面的中心位于 $(x_c, y_c) = (0.5, 0.5)$，半径为 $R$。该界面由水平集函数 $\\phi(x,y) = 0$ 的零等高线表示。\n\n    对于每个测试用例，在网格上构建相应的水平集函数 $\\phi$：\n    -   基准表示是精确的符号距离函数：\n        $$ \\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R $$\n    -   各向异性缩放的水平集是：\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) \\left(1 + \\varepsilon \\cos(m \\theta)\\right) $$\n        其中 $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$。此修改保留了零水平集，但改变了函数在远离界面处的梯度场。\n    -   振荡扰动的水平集是：\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y) $$\n        这也保留了零水平集，但引入了高频振荡，这对数值微分的准确性构成了挑战。\n\n2.  **数值曲率计算**：曲率 $\\kappa$ 是根据水平集函数使用散度公式计算的：\n    $$ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|} \\right) = \\nabla \\cdot \\mathbf{n} $$\n    其中 $\\mathbf{n}$ 是单位法向量场。计算在每个网格节点上分三个阶段进行：\n    -   **$\\phi$ 的梯度**：梯度 $\\nabla\\phi = (\\phi_x, \\phi_y) = (\\frac{\\partial\\phi}{\\partial x}, \\frac{\\partial\\phi}{\\partial y})$ 使用有限差分计算。我们对内部节点采用二阶中心差分，对边界节点采用一阶单边差分。\n    -   **法向量场**：单位法向量场 $\\mathbf{n} = (n_x, n_y)$ 通过对梯度进行归一化来计算：\n        $$ n_x = \\frac{\\phi_x}{\\sqrt{\\phi_x^2 + \\phi_y^2}}, \\quad n_y = \\frac{\\phi_y}{\\sqrt{\\phi_x^2 + \\phi_y^2}} $$\n        在分母中加入一个小的容差 $\\epsilon_{\\text{mach}}$，以防止在梯度可能数值上消失的区域（例如，远离界面处）出现除以零的情况。\n    -   **$\\mathbf{n}$ 的散度**：曲率 $\\kappa$ 是法向量场的散度，$\\kappa = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y}$。$\\mathbf{n}$ 的分量的导数使用相同的有限差分方案（二阶中心差分，一阶边界差分）计算。\n\n3.  **界面交叉检测与插值**：该算法识别所有被界面相交的水平和垂直网格边。如果连接两个节点 $A$ 和 $B$ 的边，其端点处的水平集函数符号相反，即 $\\phi_A \\cdot \\phi_B < 0$，则认为该边被‘切割’。\n    对于每个被切割的边 $e$，我们执行两次线性插值：\n    -   首先，我们找到界面交叉点沿边从节点 $A$ 开始的分数距离 $\\alpha \\in (0,1)$：\n        $$ \\alpha = \\frac{|\\phi_A|}{|\\phi_A| + |\\phi_B|} $$\n    -   其次，我们插值节点曲率值 $\\kappa_A$ 和 $\\kappa_B$，以估算交叉点处的曲率 $\\kappa_e$：\n        $$ \\kappa_e = (1-\\alpha)\\kappa_A + \\alpha\\kappa_B $$\n\n4.  **误差量化**：为每个交叉点计算压力跳跃的误差。精确的压力跳跃由二维圆的 Young-Laplace 方程给出：$\\Delta p_{\\text{exact}} = \\sigma / R$。在交叉点 $e$ 处的数值压力跳跃是 $\\Delta p_{\\text{GFM}} = \\sigma \\kappa_e$。均方根 (RMS) 误差是在所有 $M$ 个被切割的边上汇总的：\n    $$ E_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2} $$\n    该度量提供了一个单一值，用于量化给定测试用例中由曲率引起的压力跳跃的总体准确性。\n\n针对指定的测试用例实施这些步骤，将生成所需的 $E_{\\text{RMS}}$ 值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rms_error(N, R, sigma, mode, epsilon, m):\n    \"\"\"\n    Computes the RMS error in the GFM pressure jump for a static 2D droplet.\n    \"\"\"\n    # 1. Grid and Level-Set Function Generation\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    # Use 'ij' indexing for consistency with matrix row/column conventions\n    XX, YY = np.meshgrid(x, y, indexing='ij')\n\n    x_c, y_c = 0.5, 0.5\n    phi_exact = np.sqrt((XX - x_c)**2 + (YY - y_c)**2) - R\n\n    if mode == \"exact\":\n        phi = phi_exact\n    elif mode == \"anisotropic\":\n        theta_grid = np.arctan2(YY - y_c, XX - x_c)\n        phi = phi_exact * (1.0 + epsilon * np.cos(m * theta_grid))\n    elif mode == \"oscillatory\":\n        # The formula in the prompt is phi_exact + eps*h*phi_exact*sin*sin\n        # which can be simplified.\n        phi = phi_exact * (1.0 + epsilon * h * np.sin(2 * np.pi * XX) * np.sin(2 * np.pi * YY))\n    else:\n        raise ValueError(\"Unknown mode.\")\n\n    # 2. Numerical Curvature Calculation\n    # np.gradient uses 2nd-order central differences in the interior and\n    # 1st-order forward/backward differences at the boundaries.\n    # It returns derivatives with respect to each axis (axis 0 is x, axis 1 is y for 'ij').\n    phi_y, phi_x = np.gradient(phi, h, h) # Note: np.gradient returns dy, dx for 2D array\n\n    # Normalize the gradient to get the normal vector field.\n    # Add a small machine epsilon to avoid division by zero.\n    norm_grad_phi = np.sqrt(phi_x**2 + phi_y**2) + np.finfo(float).eps\n    nx = phi_x / norm_grad_phi\n    ny = phi_y / norm_grad_phi\n\n    # Compute divergence of the normal field to get curvature.\n    ny_y, _ = np.gradient(ny, h, h)\n    _, nx_x = np.gradient(nx, h, h)\n    kappa = nx_x + ny_y\n    \n    # 3. Interface Crossing Detection and Interpolation\n    squared_errors = []\n    \n    # Horizontal edges (connecting (i,j) and (i,j+1))\n    for i in range(N):\n        for j in range(N - 1):\n            phi1 = phi[i, j]\n            phi2 = phi[i, j + 1]\n            if phi1 * phi2 < 0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i, j + 1]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Vertical edges (connecting (i,j) and (i+1,j))\n    for i in range(N - 1):\n        for j in range(N):\n            phi1 = phi[i, j]\n            phi2 = phi[i + 1, j]\n            if phi1 * phi2 < 0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i + 1, j]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Compute final RMS error\n    if not squared_errors:\n        return 0.0\n    \n    E_RMS = np.sqrt(np.mean(squared_errors))\n    return E_RMS\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, sigma, mode, epsilon, m)\n        (128, 0.25, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"anisotropic\", 0.2, 6),\n        (64, 0.05, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"oscillatory\", 0.5, 0),\n    ]\n\n    # Correcting numpy.gradient output order issue\n    # For a 2D array, np.gradient returns derivatives along axis 0 (rows, y) then axis 1 (cols, x)\n    # The provided code had a logical bug where it assigned gradient outputs incorrectly.\n    # This lambda corrects that logic for the specific `calculate_rms_error` function.\n    original_calculate_rms_error = calculate_rms_error\n    \n    def fixed_calculate_rms_error(N, R, sigma, mode, epsilon, m):\n        h = 1.0 / (N - 1)\n        x = np.linspace(0, 1, N)\n        y = np.linspace(0, 1, N)\n        XX, YY = np.meshgrid(x, y, indexing='ij')\n\n        x_c, y_c = 0.5, 0.5\n        phi_exact = np.sqrt((XX - x_c)**2 + (YY - y_c)**2) - R\n\n        if mode == \"exact\": phi = phi_exact\n        elif mode == \"anisotropic\":\n            theta_grid = np.arctan2(YY - y_c, XX - x_c)\n            phi = phi_exact * (1.0 + epsilon * np.cos(m * theta_grid))\n        else: # oscillatory\n            phi = phi_exact * (1.0 + epsilon * h * np.sin(2 * np.pi * XX) * np.sin(2 * np.pi * YY))\n        \n        # Correct gradient calculation: axis 0 is 'i' (x), axis 1 is 'j' (y)\n        phi_x, phi_y = np.gradient(phi, h, h)\n        \n        norm_grad_phi = np.sqrt(phi_x**2 + phi_y**2) + np.finfo(float).eps\n        nx = phi_x / norm_grad_phi\n        ny = phi_y / norm_grad_phi\n        \n        # Correct divergence calculation\n        nx_x, _ = np.gradient(nx, h, h)\n        _, ny_y = np.gradient(ny, h, h)\n        kappa = nx_x + ny_y\n        \n        squared_errors = []\n        \n        # Horizontal edges (i,j) to (i,j+1)\n        for i in range(N):\n            for j in range(N - 1):\n                phi1, phi2 = phi[i, j], phi[i, j + 1]\n                if phi1 * phi2 < 0:\n                    kappa1, kappa2 = kappa[i, j], kappa[i, j + 1]\n                    alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                    kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                    squared_errors.append((sigma * kappa_e - sigma / R)**2)\n\n        # Vertical edges (i,j) to (i+1,j)\n        for i in range(N - 1):\n            for j in range(N):\n                phi1, phi2 = phi[i, j], phi[i + 1, j]\n                if phi1 * phi2 < 0:\n                    kappa1, kappa2 = kappa[i, j], kappa[i + 1, j]\n                    alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                    kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                    squared_errors.append((sigma * kappa_e - sigma / R)**2)\n\n        if not squared_errors: return 0.0\n        return np.sqrt(np.mean(squared_errors))\n    \n    results = [fixed_calculate_rms_error(*case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "幽灵流体法的强大之处在于其通用性，它不仅能处理由表面张力引起的不可压缩流问题，还能有效地应用于可压缩多相流的复杂动力学过程。本练习将引导您将GFM的应用范围扩展到可压缩流领域。您将为一个由刚性气体状态方程（Stiffened-Gas Equation of State）描述的双流体系统设计一个一维GFM，通过求解一个局部的黎曼问题（Riemann problem）来保证界面处压力和法向速度的连续性，并验证其是否满足朗肯-雨贡纽（Rankine–Hugoniot）跳跃关系。这个练习将展示GFM如何作为一种强大的工具，精确捕捉可压缩多相流中跨物质界面的波传播与相互作用。",
            "id": "3356144",
            "problem": "实现一种一维幽灵流体法，该方法应用于由刚性气体状态方程 (EOS) 控制的两种可压缩流体之间的物质界面。该界面由一平面法线表示，在一维情况下，单位法线简化为值为 $1$ 的标量。该方法必须在界面上强制压力和法向速度的连续性，同时允许密度存在跳跃，然后验证兰金-雨贡纽关系。所有物理量必须以国际单位制 (SI 单位) 表示。\n\n基本原理：\n- 无粘一维欧拉方程的守恒形式，其中状态向量为 $U = [\\rho,\\rho u,\\rho E]^{\\top}$，通量为 $F(U) = [\\rho u, \\rho u^{2}+p, u(\\rho E + p)]^{\\top}$。\n- 兰金-雨贡纽跳跃条件，用于描述一个以速度 $\\sigma$ 沿一维法线方向传播的间断：$[F] = \\sigma [U]$，其中 $[\\,\\cdot\\,]$ 表示一个量从右态到左态穿过界面时的跳跃。\n- 刚性气体状态方程 (EOS)：$p = (\\gamma - 1)\\rho e - \\gamma \\pi$。声速为 $c = \\sqrt{\\dfrac{\\gamma (p + \\pi)}{\\rho}}$。比总能为 $E = e + \\dfrac{1}{2}u^{2}$，其中 $e = \\dfrac{p + \\gamma \\pi}{(\\gamma - 1)\\rho}$。\n\n用于强制执行界面条件的幽灵流体投影：\n- 设左侧物质的参数为 $(\\gamma_{L},\\pi_{L})$，原始状态为 $(\\rho_{L}, u_{L}, p_{L})$；右侧物质的参数为 $(\\gamma_{R},\\pi_{R})$，原始状态为 $(\\rho_{R}, u_{R}, p_{R})$。\n- 计算声速 $c_{L} = \\sqrt{\\dfrac{\\gamma_{L}(p_{L}+\\pi_{L})}{\\rho_{L}}}$ 和 $c_{R} = \\sqrt{\\dfrac{\\gamma_{R}(p_{R}+\\pi_{R})}{\\rho_{R}}}$，以及相应的声阻抗 $Z_{L} = \\rho_{L} c_{L}$ 和 $Z_{R} = \\rho_{R} c_{R}$。\n- 通过在界面处进行线性化特征匹配，确定界面法向速度 $u^{\\star}$ 和压力 $p^{\\star}$：\n$$p^{\\star} - p_{L} = - Z_{L}\\left(u^{\\star} - u_{L}\\right),$$\n$$p^{\\star} - p_{R} = \\phantom{-} Z_{R}\\left(u^{\\star} - u_{R}\\right).$$\n  使用这两个方程求解 $u^{\\star}$ 和 $p^{\\star}$。\n- 构建特定于每一侧的幽灵投影守恒态，这些状态在保持各自密度不变的同时强制满足 $p^{\\star}$ 和 $u^{\\star}$：\n  - 对于侧 $s \\in \\{L,R\\}$，其参数为 $(\\gamma_{s},\\pi_{s})$，密度为 $\\rho_{s}$，计算 $e_{s}^{\\star} = \\dfrac{p^{\\star} + \\gamma_{s}\\pi_{s}}{(\\gamma_{s}-1)\\rho_{s}}$，$E_{s}^{\\star} = e_{s}^{\\star} + \\dfrac{1}{2}(u^{\\star})^{2}$，以及 $U_{s}^{\\star} = [\\rho_{s}, \\rho_{s} u^{\\star}, \\rho_{s} E_{s}^{\\star}]^{\\top}$。\n  - 计算通量 $F_{s}^{\\star} = [\\rho_{s} u^{\\star}, \\rho_{s}(u^{\\star})^{2} + p^{\\star}, u^{\\star}(\\rho_{s} E_{s}^{\\star} + p^{\\star})]^{\\top}$。\n- 设置界面传播速度 $\\sigma = u^{\\star}$，并验证一维下的兰金-雨贡纽关系 $[F]\\cdot n = \\sigma [U]$，即逐分量验证 $F_{R}^{\\star} - F_{L}^{\\star} = \\sigma (U_{R}^{\\star} - U_{L}^{\\star})$。\n\n数值验证要求：\n- 实现上述过程，并为每个测试案例返回一个布尔值，该值指示 $[F] - \\sigma [U]$ 的所有分量的最大绝对偏差是否小于容差 $\\varepsilon$ 乘以一个参考尺度。使用 $\\varepsilon = 10^{-9}$，参考尺度等于 $\\{F_{L}^{\\star}, F_{R}^{\\star}, \\sigma U_{L}^{\\star}, \\sigma U_{R}^{\\star}\\}$ 中各项绝对值的最大值，并设置一个为 $1$ 的下限以避免被小数除。形式上，如果满足\n$$\n\\max_{i} \\left|([F] - \\sigma [U])_{i}\\right| \\le \\varepsilon \\max\\{1, \\max_{i}\\{|(F_{L}^{\\star})_{i}|, |(F_{R}^{\\star})_{i}|, |(\\sigma U_{L}^{\\star})_{i}|, |(\\sigma U_{R}^{\\star})_{i}|\\}\\}\n$$\n，则认为通过验证。\n\n测试套件（每行为一个测试案例，顺序为 $(\\gamma_{L},\\pi_{L},\\rho_{L},u_{L},p_{L}; \\gamma_{R},\\pi_{R},\\rho_{R},u_{R},p_{R})$）：\n- 案例 A（水-空气，静止，等压）：$(4.4, 6.0\\times 10^{8}, 1000.0, 0.0, 1.0\\times 10^{5}; 1.4, 0.0, 1.2, 0.0, 1.0\\times 10^{5})$。\n- 案例 B（水-空气，有速度失配，等压）：$(4.4, 6.0\\times 10^{8}, 1000.0, 50.0, 1.0\\times 10^{5}; 1.4, 0.0, 1.2, -20.0, 1.0\\times 10^{5})$。\n- 案例 C（水-空气，静止，有压力失配）：$(4.4, 6.0\\times 10^{8}, 1000.0, 0.0, 1.5\\times 10^{5}; 1.4, 0.0, 1.2, 0.0, 1.0\\times 10^{5})$。\n- 案例 D（水-轻气体，有强密度对比，左侧有速度）：$(4.4, 6.0\\times 10^{8}, 1000.0, 50.0, 1.0\\times 10^{5}; 1.4, 0.0, 0.1, 0.0, 1.0\\times 10^{5})$。\n- 案例 E（两侧为相同气体，状态相同）：$(1.4, 0.0, 3.0, 10.0, 2.0\\times 10^{5}; 1.4, 0.0, 3.0, 10.0, 2.0\\times 10^{5})$。\n\n编程任务：\n- 编写一个程序，对每个测试案例应用上述的幽灵流体投影，计算 $u^{\\star}$、$p^{\\star}$，构建 $U_{L}^{\\star}$、$U_{R}^{\\star}$ 和 $F_{L}^{\\star}$、$F_{R}^{\\star}$，形成 $[U]$ 和 $[F]$，设置 $\\sigma = u^{\\star}$，并为每个案例输出一个布尔值，指示验证不等式是否在指定容差内成立。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true1,true2,...]”），其中每个条目都是字面的 Python 布尔值表示，不含空格，即“[True,False,True,True,True]”。",
            "solution": "问题陈述有效。它基于计算流体动力学的既定原理，特别是用于多相流的幽灵流体法和兰金-雨贡纽跳跃条件，提出了一个明确定义的计算任务。所有必要的物理模型、方程、参数和数值标准均已提供，构成一个自洽且科学上合理的问题。\n\n该物理系统由一维无粘欧拉方程的守恒形式控制：\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0\n$$\n其中状态向量 $U$ 和通量向量 $F(U)$ 由下式给出：\n$$\nU = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ \\rho E \\end{pmatrix}, \\quad F(U) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(\\rho E + p) \\end{pmatrix}\n$$\n此处，$\\rho$ 是密度，$u$ 是速度，$p$ 是压力，$E$ 是比总能。该系统通过刚性气体状态方程 (EOS) 封闭，该方程将压力与比内能 $e$ 相关联：\n$$\np = (\\gamma - 1)\\rho e - \\gamma \\pi\n$$\n参数 $\\gamma$（绝热指数）和 $\\pi$（刚度常数）是特定于材料的。比总能 $E$ 是比内能 $e$ 和比动能之和：\n$$\nE = e + \\frac{1}{2}u^2\n$$\n根据 EOS，比内能可以表示为压力的函数：\n$$\ne = \\frac{p + \\gamma \\pi}{(\\gamma - 1)\\rho}\n$$\n刚性气体中的声速 $c$ 由下式给出：\n$$\nc = \\sqrt{\\frac{\\gamma(p + \\pi)}{\\rho}}\n$$\n该问题涉及一个物质界面，它分隔开左侧（$L$）流体（参数为 $(\\gamma_L, \\pi_L)$，状态为 $(\\rho_L, u_L, p_L)$）和右侧（$R$）流体（参数为 $(\\gamma_R, \\pi_R)$，状态为 $(\\rho_R, u_R, p_R)$）。幽灵流体法在此界面上强制执行速度和压力的连续性。由此产生的界面速度 $u^{\\star}$ 和压力 $p^{\\star}$ 通过求解一个从线性化特征分析导出的线性方程组来确定：\n$$\n\\begin{align*}\np^{\\star} + Z_L u^{\\star} &= p_L + Z_L u_L \\\\\np^{\\star} - Z_R u^{\\star} &= p_R - Z_R u_R\n\\end{align*}\n$$\n此处，$Z_s = \\rho_s c_s$ 是侧 $s \\in \\{L, R\\}$ 上流体的声阻抗，其声速 $c_s$ 使用各自的状态变量和材料参数计算得出：$c_s = \\sqrt{\\gamma_s(p_s + \\pi_s)/\\rho_s}$。\n\n这个 $2 \\times 2$ 线性系统可以求解出 $u^{\\star}$ 和 $p^{\\star}$。重新整理方程可得：\n$$\n\\begin{align*}\np^{\\star} + Z_L u^{\\star} = p_L + Z_L u_L \\\\\np^{\\star} - Z_R u^{\\star} = p_R - Z_R u_R\n\\end{align*}\n$$\n求解该系统可得到唯一解：\n$$\nu^{\\star} = \\frac{p_L - p_R + Z_L u_L + Z_R u_R}{Z_L + Z_R}\n$$\n$$\np^{\\star} = \\frac{p_L Z_R + p_R Z_L + Z_L Z_R (u_L - u_R)}{Z_L + Z_R}\n$$\n一旦 $u^{\\star}$ 和 $p^{\\star}$ 已知，我们就可以构建幽灵投影态 $U_L^{\\star}$ 和 $U_R^{\\star}$。这些状态共享共同的速度 $u^{\\star}$ 和压力 $p^{\\star}$，但保留了各自一侧的原始密度。对于每一侧 $s \\in \\{L, R\\}$，幽灵态由其守恒变量定义：\n$$\nU_s^{\\star} = \\begin{pmatrix} \\rho_s \\\\ \\rho_s u^{\\star} \\\\ \\rho_s E_s^{\\star} \\end{pmatrix}\n$$\n其中比总能 $E_s^{\\star}$ 计算如下：\n$$\nE_s^{\\star} = e_s^{\\star} + \\frac{1}{2}(u^{\\star})^2 \\quad \\text{其中} \\quad e_s^{\\star} = \\frac{p^{\\star} + \\gamma_s\\pi_s}{(\\gamma_s-1)\\rho_s}\n$$\n然后使用这些幽灵态计算相应的通量 $F_L^{\\star}$ 和 $F_R^{\\star}$：\n$$\nF_s^{\\star} = \\begin{pmatrix} \\rho_s u^{\\star} \\\\ \\rho_s(u^{\\star})^2 + p^{\\star} \\\\ u^{\\star}(\\rho_s E_s^{\\star} + p^{\\star}) \\end{pmatrix}\n$$\n最后一步是验证这些构建的幽灵态是否满足以速度 $\\sigma$ 移动的接触间断的兰金-雨贡纽跳跃条件。问题指定将界面传播速度设置为求解得到的物质速度，即 $\\sigma = u^{\\star}$。兰金-雨贡纽条件是：\n$$\n[F] = \\sigma [U]\n$$\n其中 $[X] = X_R - X_L$ 表示跨界面的跳跃。在此背景下，该条件变为：\n$$\nF_R^{\\star} - F_L^{\\star} = \\sigma (U_R^{\\star} - U_L^{\\star})\n$$\n实现将为每个测试案例数值验证此向量恒等式。验证过程包括计算残差向量 $R = (F_R^{\\star} - F_L^{\\star}) - \\sigma (U_R^{\\star} - U_L^{\\star})$，并检查其绝对值的最大分量是否在指定的容差 $\\varepsilon = 10^{-9}$ 之内。容差通过一个参考值 $S$ 进行缩放：\n$$\n\\max_{i} |R_i| \\le \\varepsilon S\n$$\n其中 $S = \\max\\{1, \\max_{i,s} \\{ |(F_s^{\\star})_i|, |(\\sigma U_s^{\\star})_i| \\} \\}$。由于该关系对于定义的幽灵态在解析上是成立的，因此数值检查可以作为测试实现是否正确、能否抵御浮点运算误差的手段。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a one-dimensional ghost-fluid method and verifies the\n    Rankine-Hugoniot relations for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple:\n    # (gamma_L, pi_L, rho_L, u_L, p_L, gamma_R, pi_R, rho_R, u_R, p_R)\n    test_cases = [\n        # Case A (water-air at rest, equal pressure)\n        (4.4, 6.0e8, 1000.0, 0.0, 1.0e5, 1.4, 0.0, 1.2, 0.0, 1.0e5),\n        # Case B (water-air with velocity mismatch, equal pressure)\n        (4.4, 6.0e8, 1000.0, 50.0, 1.0e5, 1.4, 0.0, 1.2, -20.0, 1.0e5),\n        # Case C (water-air at rest with pressure mismatch)\n        (4.4, 6.0e8, 1000.0, 0.0, 1.5e5, 1.4, 0.0, 1.2, 0.0, 1.0e5),\n        # Case D (water-light gas with strong density contrast, velocity on left)\n        (4.4, 6.0e8, 1000.0, 50.0, 1.0e5, 1.4, 0.0, 0.1, 0.0, 1.0e5),\n        # Case E (same gas both sides, identical states)\n        (1.4, 0.0, 3.0, 10.0, 2.0e5, 1.4, 0.0, 3.0, 10.0, 2.0e5),\n    ]\n\n    results = []\n    epsilon = 1e-9\n\n    for case in test_cases:\n        gamma_L, pi_L, rho_L, u_L, p_L, gamma_R, pi_R, rho_R, u_R, p_R = case\n        \n        # Step 1: Compute speeds of sound and acoustic impedances\n        c_L = np.sqrt(gamma_L * (p_L + pi_L) / rho_L)\n        c_R = np.sqrt(gamma_R * (p_R + pi_R) / rho_R)\n        \n        Z_L = rho_L * c_L\n        Z_R = rho_R * c_R\n        \n        # Step 2: Solve for interface velocity u_star and pressure p_star\n        # These are derived from the linearized characteristic matching equations\n        # p_star - p_L = -Z_L(u_star - u_L) and p_star - p_R = Z_R(u_star - u_R)\n        u_star = (p_L - p_R + Z_L * u_L + Z_R * u_R) / (Z_L + Z_R)\n        # Using the first equation to find p_star\n        p_star = p_L - Z_L * (u_star - u_L)\n        \n        # Step 3: Set interface speed and construct ghost-projected states and fluxes\n        sigma = u_star\n        \n        # Left ghost state\n        e_L_star = (p_star + gamma_L * pi_L) / ((gamma_L - 1) * rho_L)\n        E_L_star = e_L_star + 0.5 * u_star**2\n        U_L_star = np.array([\n            rho_L,\n            rho_L * u_star,\n            rho_L * E_L_star\n        ])\n        F_L_star = np.array([\n            rho_L * u_star,\n            rho_L * u_star**2 + p_star,\n            u_star * (rho_L * E_L_star + p_star)\n        ])\n        \n        # Right ghost state\n        e_R_star = (p_star + gamma_R * pi_R) / ((gamma_R - 1) * rho_R)\n        E_R_star = e_R_star + 0.5 * u_star**2\n        U_R_star = np.array([\n            rho_R,\n            rho_R * u_star,\n            rho_R * E_R_star\n        ])\n        F_R_star = np.array([\n            rho_R * u_star,\n            rho_R * u_star**2 + p_star,\n            u_star * (rho_R * E_R_star + p_star)\n        ])\n        \n        # Step 4: Verify the Rankine-Hugoniot condition\n        # Residual vector R = [F] - sigma * [U]\n        jump_F = F_R_star - F_L_star\n        jump_U = U_R_star - U_L_star\n        residual = jump_F - sigma * jump_U\n        \n        # Calculate the reference scale S\n        sigma_U_L_star = sigma * U_L_star\n        sigma_U_R_star = sigma * U_R_star\n        \n        # Collect all component values for scaling\n        all_values = np.concatenate([\n            np.abs(F_L_star),\n            np.abs(F_R_star),\n            np.abs(sigma_U_L_star),\n            np.abs(sigma_U_R_star)\n        ])\n        \n        # The scale is the max of the absolute values, with a floor of 1.\n        scale_val = np.max(all_values) if all_values.size > 0 else 0.0\n        scale = max(1.0, scale_val)\n        \n        # Check if the max absolute deviation is within the specified tolerance\n        is_verified = np.max(np.abs(residual)) <= epsilon * scale\n        \n        results.append(str(is_verified))\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}