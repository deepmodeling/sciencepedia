{
    "hands_on_practices": [
        {
            "introduction": "要掌握多温度模型，首先必须理解热力学非平衡状态的演化过程。本练习将引导你分析经典的Landau-Teller振动能弛豫模型，这是描述平动能和振动能之间能量交换的基础。通过推导一个理想化激波后气体团的振动温度随时间的解析解，你将深入理解振动弛豫时间 $\\tau_{v}$ 的物理意义以及能量向平衡态指数趋近的过程。",
            "id": "3977827",
            "problem": "考虑一个空间均匀、静止的高温双原子气团，在计算流体动力学（CFD）中使用双温度框架进行建模，其中平动-转动温度表示为 $T(t)$，振动温度表示为 $T_{v}(t)$。假设化学反应是冻结的，并忽略对流和扩散。设单位质量的振动能为 $e_{v}(t)$，其相对于平动-转动模式的局域热力学平衡值为 $e_{v}^{\\ast}(T(t))$。模式间的振动能交换由一个广泛接受的线性弛豫定律描述，其特征振动弛豫时间为 $\\tau_{v}$：\n$$\n\\frac{d e_{v}}{d t} = \\frac{e_{v}^{\\ast}(T) - e_{v}}{\\tau_{v}} \\quad \\text{for} \\quad t \\ge 0.\n$$\n在时间 $t=0$ 时，一个外部脉冲加热事件瞬时将平动-转动温度从激波前的值 $T(0^{-}) = T_{i}$ 提高到激波后的平台值 $T(t) = T_{f}$（对于所有 $t \\ge 0$）。假设振动温度初始时与激波前状态处于平衡，$T_{v}(0^{-}) = T_{i}$。对于 $t \\ge 0$，取振动弛豫时间为常数 $\\tau_{v} = \\text{const}$，并采用恒定振动比热近似 $c_{v,v} = \\text{const}$，使得\n$$\ne_{v}(t) = c_{v,v} \\, T_{v}(t), \\qquad e_{v}^{\\ast}(T(t)) = c_{v,v} \\, T(t).\n$$\n从给定的能量弛豫定律和这些定义出发，推导控制 $T_{v}(t)$（对于 $t \\ge 0$）的常微分方程（ODE），并针对 $t=0$ 时 $T$ 的阶跃变化对其进行解析求解。使用初始条件 $T_{v}(0)=T_{i}$（对应于 $T$ 发生阶跃之后的瞬间）。将最终答案表示为 $T_{v}(t)$ 关于 $t$、$T_{i}$、$T_{f}$ 和 $\\tau_{v}$ 的单个闭式解析表达式。表达式中无需包含单位；将 $T$ 和 $T_{v}$ 视为以开尔文为单位的温度。无需进行数值计算。",
            "solution": "在进行求解之前，对问题陈述的有效性进行评估。\n\n**步骤1：提取给定条件**\n问题陈述中提供了以下信息：\n- 系统是一个空间均匀、静止的高温双原子气团。\n- 模型是一个双温度框架，包含平动-转动温度 $T(t)$ 和振动温度 $T_v(t)$。\n- 化学反应是冻结的；忽略对流和扩散。\n- 单位质量的振动能为 $e_v(t)$。\n- 局域热力学平衡振动能为 $e_v^{\\ast}(T(t))$。\n- 对于 $t \\ge 0$，振动能弛豫的控制方程为：\n$$ \\frac{d e_{v}}{d t} = \\frac{e_{v}^{\\ast}(T) - e_{v}}{\\tau_{v}} $$\n- 在 $t=0$ 时发生一个脉冲加热事件。\n- 激波前的平动-转动温度为 $T(0^{-}) = T_i$。\n- 激波后的平动-转动温度为 $T(t) = T_f$（对于所有 $t \\ge 0$）。\n- 振动温度的初始条件为 $T_v(0^{-}) = T_i$。\n- 振动弛豫时间为常数：$\\tau_v = \\text{const}$。\n- 振动比热为常数：$c_{v,v} = \\text{const}$。\n- 能量和温度之间的关系为：\n$$ e_{v}(t) = c_{v,v} \\, T_{v}(t) $$\n$$ e_{v}^{\\ast}(T(t)) = c_{v,v} \\, T(t) $$\n- 对于 $t \\ge 0$ 求解的微分方程的初始条件是 $T_v(0) = T_i$。\n\n**步骤2：使用提取的给定条件进行验证**\n该问题定义明确且有科学依据。它描述了非平衡气体动力学中的一个经典问题：气团在经历平动温度突然升高（这是正激波后区域的典型特征）后振动温度的弛豫过程。控制方程是标准的 Landau-Teller 弛豫模型。恒定振动比热和恒定弛豫时间的假设是推导解析解时常用且有效的简化方法。该问题是自洽的，提供了所有必要的方程和初始条件。这是一个一阶常微分方程的适定初值问题，存在唯一、稳定的解。问题陈述中没有科学或事实上的不健全之处，没有矛盾，也没有歧义。\n\n**步骤3：结论与行动**\n该问题被认为是**有效的**。将推导解答。\n\n**解答的推导**\n目标是推导并求解关于振动温度 $T_v(t)$ 的常微分方程（ODE）。\n\n首先，我们将给定的 $e_v$ 和 $e_v^{\\ast}$ 的本构关系代入振动能弛豫方程。\n弛豫定律为：\n$$ \\frac{d e_{v}}{d t} = \\frac{e_{v}^{\\ast}(T) - e_{v}}{\\tau_{v}} $$\n代入 $e_{v}(t) = c_{v,v} T_{v}(t)$ 和 $e_{v}^{\\ast}(T(t)) = c_{v,v} T(t)$：\n$$ \\frac{d}{dt} (c_{v,v} T_{v}) = \\frac{c_{v,v} T - c_{v,v} T_{v}}{\\tau_{v}} $$\n由于 $c_{v,v}$ 是一个常数，它可以从时间导数中提出，并在右侧作为公因子提出：\n$$ c_{v,v} \\frac{d T_{v}}{d t} = \\frac{c_{v,v} (T - T_{v})}{\\tau_{v}} $$\n两边同除以非零常数 $c_{v,v}$，得到关于振动温度 $T_v(t)$（用平动-转动温度 $T(t)$ 表示）的常微分方程：\n$$ \\frac{d T_{v}}{d t} = \\frac{T(t) - T_{v}(t)}{\\tau_{v}} $$\n问题指明，对于 $t \\ge 0$，平动-转动温度恒定为激波后的值 $T(t) = T_f$。将其代入常微分方程得到：\n$$ \\frac{d T_{v}}{d t} = \\frac{T_{f} - T_{v}}{\\tau_{v}} $$\n这是一个一阶线性非齐次常微分方程。可以用分离变量法求解。我们重新整理方程以分离变量 $T_v$ 和 $t$：\n$$ \\frac{d T_{v}}{T_{f} - T_{v}} = \\frac{dt}{\\tau_{v}} $$\n我们对等式两边进行积分。左边的积分是关于 $T_v$ 从其初始值 $T_v(0)$ 到稍后时间的值 $T_v(t)$，右边的积分是关于时间从 $0$ 到 $t$：\n$$ \\int_{T_{v}(0)}^{T_{v}(t)} \\frac{d T'_{v}}{T_{f} - T'_{v}} = \\int_{0}^{t} \\frac{d t'}{\\tau_{v}} $$\n左边的积分得到一个自然对数：\n$$ \\left[ -\\ln(T_{f} - T'_{v}) \\right]_{T_{v}(0)}^{T_{v}(t)} = \\left[ \\frac{t'}{\\tau_{v}} \\right]_{0}^{t} $$\n使用初始条件 $T_v(0) = T_i$：\n$$ -\\ln(T_{f} - T_{v}(t)) - (-\\ln(T_{f} - T_{i})) = \\frac{t}{\\tau_{v}} $$\n$$ \\ln(T_{f} - T_{i}) - \\ln(T_{f} - T_{v}(t)) = \\frac{t}{\\tau_{v}} $$\n使用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$：\n$$ \\ln\\left(\\frac{T_{f} - T_{i}}{T_{f} - T_{v}(t)}\\right) = \\frac{t}{\\tau_{v}} $$\n为了解出 $T_v(t)$，我们对两边取指数：\n$$ \\frac{T_{f} - T_{i}}{T_{f} - T_{v}(t)} = \\exp\\left(\\frac{t}{\\tau_{v}}\\right) $$\n现在，我们进行代数重排以分离出 $T_v(t)$：\n$$ T_{f} - T_{v}(t) = (T_{f} - T_{i}) \\exp\\left(-\\frac{t}{\\tau_{v}}\\right) $$\n$$ T_{v}(t) = T_{f} - (T_{f} - T_{i}) \\exp\\left(-\\frac{t}{\\tau_{v}}\\right) $$\n这个表达式描述了振动温度从其初始值 $T_i$ 开始，以特征时间尺度 $\\tau_v$ 向新的平衡温度 $T_f$ 弛豫的演化过程。\n在 $t=0$ 时，$T_v(0) = T_f - (T_f - T_i)\\exp(0) = T_f - (T_f - T_i) = T_i$，满足初始条件。\n当 $t \\to \\infty$ 时，$T_v(t) \\to T_f - (T_f - T_i)(0) = T_f$，这是预期的平衡状态。\n推导出的表达式是正确的解析解。",
            "answer": "$$\\boxed{T_{v}(t) = T_{f} - (T_{f} - T_{i}) \\exp\\left(-\\frac{t}{\\tau_{v}}\\right)}$$"
        },
        {
            "introduction": "理解了热力学非平衡后，下一步是探究它如何影响化学反应速率。在高温气体中，振动能的激发程度对分子离解等化学过程起着决定性作用，因此反应速率常数需要依赖于一个综合了平动-转动温度 $T$ 和振动温度 $T_v$ 的有效温度 $T^*$。本练习要求你实现并比较两种不同的有效温度模型，并根据一个为教学目的而设计的假设验证数据集来评估它们的预测能力，从而亲身体验物理模型选择对计算结果的重要性。",
            "id": "3977801",
            "problem": "考虑一个高超声速流中的氮气解离过程，该过程采用多温度方法建模，其中平动-转动温度 $T$ 和振动温度 $T_v$ 可以不同。解离速率常数 $k$ 被视为一个有限速率化学过程，使用修正的阿伦尼乌斯定律处理，其中有效温度 $T^{*}$ 用于解释非平衡状态。假设解离为原子的过程采用全局伪一级表示法，因此速率常数的单位为 $\\mathrm{s}^{-1}$。\n\n基本和核心定义：\n- 解离速率的阿伦尼乌斯定律表示为\n$$\nk(T^{*}) \\;=\\; A \\, T^{n} \\, \\exp\\!\\left(-\\frac{E_d}{R\\,T^{*}}\\right),\n$$\n其中 $A$ 是指前因子，单位为 $\\mathrm{s}^{-1}$；$n$ 是无量纲的温度指数；$E_d$ 是摩尔解离能，单位为 $\\mathrm{J/mol}$；$R$ 是普适气体常数，单位为 $\\mathrm{J/(mol\\cdot K)}$。在本问题中，使用 $A = 10^{9}\\ \\mathrm{s}^{-1}$，$n = 0$，$E_d = 9.76\\times 96485\\ \\mathrm{J/mol}$（对应每个分子 $9.76\\ \\mathrm{eV}$），以及 $R = 8.314\\ \\mathrm{J/(mol\\cdot K)}$。\n- 解离起始的定义为：当特征解离时间尺度 $\\tau_d = 1/k$ 小于指定的化学驻留时间 $\\tau_c$ 时，解离发生。在本问题中，使用 $\\tau_c = 10^{-3}\\ \\mathrm{s}$（一毫秒），因此起始条件为 $k \\ge 1/\\tau_c = 10^{3}\\ \\mathrm{s}^{-1}$。预测起始与否的结果是一个布尔值，$\\text{True}$ 表示起始，$\\text{False}$ 表示未起始。\n- Park 的有效温度模型采用 $T$ 和 $T_v$ 的线性混合：\n$$\nT^{*}_{\\text{Park}} \\;=\\; T \\;+\\; s\\,\\big(T_v - T\\big),\n$$\n其中 $s$ 是一个恒定的混合系数。在本问题中，根据氮气解离建模的实践，使用 $s = 0.5$。\n- 一种受更保守的振动加权方法（例如 Marrone–Treviño 类型的方法）启发的替代公式，此处表示为 $T$ 和 $T_v$ 的加权调和平均：\n$$\nT^{*}_{\\text{MT}} \\;=\\; \\left(\\frac{1-w}{T} + \\frac{w}{T_v}\\right)^{-1},\n$$\n其中 $w$ 是一个恒定的权重。在本问题中，使用 $w = 0.5$。当 $T \\neq T_v$ 时，此 $T^{*}_{\\text{MT}}$ 总是小于或等于相应的加权算术平均值，因此产生的起始预测比 $T^{*}_{\\text{Park}}$ 更保守（更晚）。\n\n您的任务：\n- 使用上述常数，实现两种模型，计算 $k(T^{*})$，并为每种情况预测起始布尔值。\n- 将两种模型与同一个验证数据集进行比较，并评估哪个模型能更好地复现观测到的解离起始（见下文）。\n\n验证数据集：\n每个测试用例提供以开尔文为单位的 $(T,\\ T_v)$ 和观测到的起始布尔值 $y$，其中 $\\text{True}$ 表示观测到起始，$\\text{False}$ 表示未观测到起始。请使用以下八个用例：\n1. $(T = 4000\\ \\mathrm{K},\\ T_v = 4000\\ \\mathrm{K},\\ y = \\text{False})$\n2. $(T = 4000\\ \\mathrm{K},\\ T_v = 8000\\ \\mathrm{K},\\ y = \\text{False})$\n3. $(T = 6000\\ \\mathrm{K},\\ T_v = 6000\\ \\mathrm{K},\\ y = \\text{False})$\n4. $(T = 6000\\ \\mathrm{K},\\ T_v = 12000\\ \\mathrm{K},\\ y = \\text{False})$\n5. $(T = 8000\\ \\mathrm{K},\\ T_v = 8000\\ \\mathrm{K},\\ y = \\text{False})$\n6. $(T = 9000\\ \\mathrm{K},\\ T_v = 12000\\ \\mathrm{K},\\ y = \\text{True})$\n7. $(T = 10000\\ \\mathrm{K},\\ T_v = 7000\\ \\mathrm{K},\\ y = \\text{True})$\n8. $(T = 7000\\ \\mathrm{K},\\ T_v = 10000\\ \\mathrm{K},\\ y = \\text{True})$\n\n输出要求：\n- 对于每个测试用例，计算 Park 模型和替代模型的预测起始布尔值。通过将预测与观测到的 $y$进行比较来确定其正确性。\n- 计算 Park 模型和替代模型在所有用例中的总误分类数（整数计数）。\n- 按如下方式确定更优的模型：如果 Park 模型的误分类数较少，输出 $0$；如果替代模型的误分类数较少，输出 $1$；如果两者相等，输出 $2$。\n\n最终输出格式：\n程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含五个元素：\n1. 一个长度为 $8$ 的布尔值列表，表示 Park 模型在每个用例上的正确性。\n2. 一个长度为 $8$ 的布尔值列表，表示替代模型在每个用例上的正确性。\n3. 一个整数：Park 模型的总误分类数。\n4. 一个整数：替代模型的总误分类数。\n5. 一个整数：如上定义的更优模型指标。\n\n例如，您的程序必须以如下确切形式打印一行：\n$$\n[\\,[b_1,\\dots,b_8],\\,[c_1,\\dots,c_8],\\,m_{\\text{Park}},\\,m_{\\text{MT}},\\,w\\,],\n$$\n不含任何额外文本。所有温度单位为开尔文（$\\mathrm{K}$），时间单位为秒（$\\mathrm{s}$），能量单位为 $\\mathrm{J/mol}$。角度不出现。输出中没有百分比。",
            "solution": "此问题经评估有效，因为它在科学上基于高温气体动力学原理，提法明确，定义和数据完整清晰，且表述客观。未检测到不一致、模糊或事实错误。因此，提供完整解答。\n\n该问题要求比较两种多温度模型，用以预测氮气解离的起始。分析过程分为三步：首先，我们为解离起始建立一个定量准则；其次，我们将此准则应用于每个测试用例的两种模型；第三，我们根据模型与所提供的验证数据集的预测准确性来评估模型。\n\n解离速率常数 $k$ 由修正的阿伦尼乌斯定律给出：\n$$\nk(T^{*}) \\;=\\; A \\, T^{n} \\, \\exp\\!\\left(-\\frac{E_d}{R\\,T^{*}}\\right)\n$$\n提供的常数为：\n- 指前因子，$A = 10^9\\ \\mathrm{s}^{-1}$\n- 温度指数，$n = 0$\n- 摩尔解离能，$E_d = 9.76\\times 96485\\ \\mathrm{J/mol} = 941693.6\\ \\mathrm{J/mol}$\n- 普适气体常数，$R = 8.314\\ \\mathrm{J/(mol\\cdot K)}$\n\n当 $n=0$ 时，温度乘数 $T^n$ 变为 $T^0 = 1$，速率定律简化为：\n$$\nk(T^{*}) \\;=\\; A \\, \\exp\\!\\left(-\\frac{E_d}{R\\,T^{*}}\\right)\n$$\n解离起始的定义是：当特征解离时间 $\\tau_d = 1/k$ 小于化学驻留时间 $\\tau_c = 10^{-3}\\ \\mathrm{s}$ 时发生。该条件等价于速率常数 $k$ 超过一个临界值 $k_{\\text{crit}}$：\n$$\nk(T^{*}) \\ge \\frac{1}{\\tau_c} = \\frac{1}{10^{-3}\\ \\mathrm{s}} = 1000\\ \\mathrm{s}^{-1}\n$$\n为简化分析，我们可以确定满足此起始条件的临界有效温度 $T^{*}_{\\text{crit}}$。\n$$\nk_{\\text{crit}} = A \\, \\exp\\!\\left(-\\frac{E_d}{R\\,T^{*}_{\\text{crit}}}\\right) = 10^3\\ \\mathrm{s}^{-1}\n$$\n求解 $T^{*}_{\\text{crit}}$：\n$$\n10^3 = 10^9 \\, \\exp\\!\\left(-\\frac{E_d}{R\\,T^{*}_{\\text{crit}}}\\right)\n$$\n$$\n10^{-6} = \\exp\\!\\left(-\\frac{E_d}{R\\,T^{*}_{\\text{crit}}}\\right)\n$$\n对两边取自然对数：\n$$\n\\ln(10^{-6}) = -\\frac{E_d}{R\\,T^{*}_{\\text{crit}}}\n$$\n$$\n-6 \\ln(10) = -\\frac{E_d}{R\\,T^{*}_{\\text{crit}}}\n$$\n$$\nT^{*}_{\\text{crit}} = \\frac{E_d}{6 R \\ln(10)}\n$$\n代入 $E_d$ 和 $R$ 的值：\n$$\nT^{*}_{\\text{crit}} = \\frac{941693.6\\ \\mathrm{J/mol}}{6 \\times 8.314\\ \\mathrm{J/(mol\\cdot K)} \\times \\ln(10)} \\approx \\frac{941693.6}{6 \\times 8.314 \\times 2.302585} \\approx 8198.2\\ \\mathrm{K}\n$$\n因此，如果给定模型的有效温度 $T^{*}$ 大于或等于 $8198.2\\ \\mathrm{K}$，则预测解离起始。\n\n现在我们为每个测试用例评估两种有效温度模型。\n\n**模型1：Park 模型**\n有效温度是平动-转动温度 $T$ 和振动温度 $T_v$ 的线性混合：\n$$\nT^{*}_{\\text{Park}} = T + s(T_v - T)\n$$\n当混合系数 $s = 0.5$ 时，这简化为算术平均值：\n$$\nT^{*}_{\\text{Park}} = T + 0.5(T_v - T) = 0.5T + 0.5T_v = \\frac{T+T_v}{2}\n$$\n\n**模型2：替代模型（Marrone–Treviño 类型）**\n有效温度是 $T$ 和 $T_v$ 的加权调和平均：\n$$\nT^{*}_{\\text{MT}} = \\left(\\frac{1-w}{T} + \\frac{w}{T_v}\\right)^{-1}\n$$\n当权重 $w = 0.5$ 时，这简化为调和平均值：\n$$\nT^{*}_{\\text{MT}} = \\left(\\frac{0.5}{T} + \\frac{0.5}{T_v}\\right)^{-1} = \\left(\\frac{T_v+T}{2TT_v}\\right)^{-1} = \\frac{2TT_v}{T+T_v}\n$$\n\n对八个验证用例的分析如下，使用阈值 $T^{*}_{\\text{crit}} \\approx 8198.2\\ \\mathrm{K}$。\n\n**用例 1:** $(T=4000\\ \\mathrm{K}, T_v=4000\\ \\mathrm{K}, y=\\text{False})$\n$T^{*}_{\\text{Park}} = (4000+4000)/2 = 4000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n$T^{*}_{\\text{MT}} = 2(4000)(4000)/(4000+4000) = 4000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n\n**用例 2:** $(T=4000\\ \\mathrm{K}, T_v=8000\\ \\mathrm{K}, y=\\text{False})$\n$T^{*}_{\\text{Park}} = (4000+8000)/2 = 6000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n$T^{*}_{\\text{MT}} = 2(4000)(8000)/(4000+8000) \\approx 5333.3\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n\n**用例 3:** $(T=6000\\ \\mathrm{K}, T_v=6000\\ \\mathrm{K}, y=\\text{False})$\n$T^{*}_{\\text{Park}} = (6000+6000)/2 = 6000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n$T^{*}_{\\text{MT}} = 2(6000)(6000)/(6000+6000) = 6000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n\n**用例 4:** $(T=6000\\ \\mathrm{K}, T_v=12000\\ \\mathrm{K}, y=\\text{False})$\n$T^{*}_{\\text{Park}} = (6000+12000)/2 = 9000\\ \\mathrm{K} \\ge T^{*}_{\\text{crit}}$。预测：True。错误。\n$T^{*}_{\\text{MT}} = 2(6000)(12000)/(6000+12000) = 8000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n\n**用例 5:** $(T=8000\\ \\mathrm{K}, T_v=8000\\ \\mathrm{K}, y=\\text{False})$\n$T^{*}_{\\text{Park}} = (8000+8000)/2 = 8000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n$T^{*}_{\\text{MT}} = 2(8000)(8000)/(8000+8000) = 8000\\ \\mathrm{K}  T^{*}_{\\text{crit}}$。预测：False。正确。\n\n**用例 6:** $(T=9000\\ \\mathrm{K}, T_v=12000\\ \\mathrm{K}, y=\\text{True})$\n$T^{*}_{\\text{Park}} = (9000+12000)/2 = 10500\\ \\mathrm{K} \\ge T^{*}_{\\text{crit}}$。预测：True。正确。\n$T^{*}_{\\text{MT}} = 2(9000)(12000)/(9000+12000) \\approx 10285.7\\ \\mathrm{K} \\ge T^{*}_{\\text{crit}}$。预测：True。正确。\n\n**用例 7:** $(T=10000\\ \\mathrm{K}, T_v=7000\\ \\mathrm{K}, y=\\text{True})$\n$T^{*}_{\\text{Park}} = (10000+7000)/2 = 8500\\ \\mathrm{K} \\ge T^{*}_{\\text{crit}}$。预测：True。正确。\n$T^{*}_{\\text{MT}} = 2(10000)(7000)/(10000+7000) \\approx 8235.3\\ \\mathrm{K} \\ge T^{*}_{\\text{crit}}$。预测：True。正确。\n\n**用例 8:** $(T=7000\\ \\mathrm{K}, T_v=10000\\ \\mathrm{K}, y=\\text{True})$\n$T^{*}_{\\text{Park}} = (7000+10000)/2 = 8500\\ \\mathrm{K} \\ge T^{*}_{\\text{crit}}$。预测：True。正确。\n$T^{*}_{\\text{MT}} = 2(7000)(10000)/(7000+10000) \\approx 8235.3\\ \\mathrm{K} \\ge T^{*}_{\\text{crit}}$。预测：True。正确。\n\n我们总结每个用例的正确性和总误分类数。\n\n**Park 模型结果：**\n- 每个用例的正确性：[True, True, True, False, True, True, True, True]\n- 总误分类数 ($m_{\\text{Park}}$)：$1$\n\n**替代模型结果：**\n- 每个用例的正确性：[True, True, True, True, True, True, True, True]\n- 总误分类数 ($m_{\\text{MT}}$)：$0$\n\n**模型比较：**\nPark 模型的误分类数为 $m_{\\text{Park}} = 1$，而替代模型的误分类数为 $m_{\\text{MT}} = 0$。\n由于 $m_{\\text{MT}}  m_{\\text{Park}}$，根据问题的标准，替代模型更优。更优模型的指标是 $1$。\n\n最终输出值为：\n1. Park 模型的正确性列表：`[True, True, True, False, True, True, True, True]`\n2. 替代模型的正确性列表：`[True, True, True, True, True, True, True, True]`\n3. Park 模型的误分类数：$1$\n4. 替代模型的误分类数：$0$\n5. 更优模型指标：$1$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nitrogen dissociation onset prediction problem for two\n    multi-temperature models and evaluates their performance.\n    \"\"\"\n    \n    # Fundamental constants and problem parameters\n    A = 1e9  # s^-1\n    n = 0.0  # dimensionless\n    E_d = 9.76 * 96485  # J/mol\n    R = 8.314  # J/(mol*K)\n    tau_c = 1e-3  # s\n    \n    # Onset condition parameters\n    k_onset = 1.0 / tau_c  # s^-1\n    \n    # Blending coefficients for the two models\n    s_park = 0.5\n    w_mt = 0.5\n    \n    # Validation dataset: (T, T_v, observed_onset)\n    test_cases = [\n        (4000.0, 4000.0, False),\n        (4000.0, 8000.0, False),\n        (6000.0, 6000.0, False),\n        (6000.0, 12000.0, False),\n        (8000.0, 8000.0, False),\n        (9000.0, 12000.0, True),\n        (10000.0, 7000.0, True),\n        (7000.0, 10000.0, True),\n    ]\n\n    # Calculate the critical effective temperature for dissociation onset.\n    # k_onset = A * exp(-E_d / (R * T_crit))\n    # ln(k_onset / A) = -E_d / (R * T_crit)\n    # T_crit = -E_d / (R * ln(k_onset / A))\n    T_crit = -E_d / (R * np.log(k_onset / A))\n\n    park_correctness = []\n    mt_correctness = []\n\n    misclass_park = 0\n    misclass_mt = 0\n\n    for case in test_cases:\n        T, T_v, y_obs = case\n\n        # Park's Model (Arithmetic Mean for s=0.5)\n        T_star_park = T + s_park * (T_v - T)\n        y_pred_park = T_star_park >= T_crit\n        is_correct_park = (y_pred_park == y_obs)\n        park_correctness.append(is_correct_park)\n        if not is_correct_park:\n            misclass_park += 1\n\n        # Alternative Model (Harmonic Mean for w=0.5)\n        # Handle T_v=0 case to avoid division by zero, though not present in test data.\n        if T == 0 or T_v == 0:\n             T_star_mt = 0.0\n        else:\n             T_star_mt = 1.0 / ((1.0 - w_mt) / T + w_mt / T_v)\n\n        y_pred_mt = T_star_mt >= T_crit\n        is_correct_mt = (y_pred_mt == y_obs)\n        mt_correctness.append(is_correct_mt)\n        if not is_correct_mt:\n            misclass_mt += 1\n            \n    # Determine the better model\n    # 0: Park's model is better\n    # 1: Alternative model is better\n    # 2: Tie\n    if misclass_park  misclass_mt:\n        better_model_indicator = 0\n    elif misclass_mt  misclass_park:\n        better_model_indicator = 1\n    else:\n        better_model_indicator = 2\n\n    # Format the final output string exactly as required\n    # [ [bool,...,bool], [bool,...,bool], int, int, int ]\n    # Manually construct string representation of lists to avoid spaces.\n    park_corr_str = f\"[{','.join(str(b).lower() for b in park_correctness)}]\"\n    mt_corr_str = f\"[{','.join(str(b).lower() for b in mt_correctness)}]\"\n    \n    results = [\n        park_corr_str.replace('true', 'True').replace('false', 'False'),\n        mt_corr_str.replace('true', 'True').replace('false', 'False'),\n        str(misclass_park),\n        str(misclass_mt),\n        str(better_model_indicator)\n    ]\n    \n    # Python's default bool to string is 'True'/'False'. The example shows lowercase.\n    # The requirement is ambiguous. Let's assume standard python string representation is fine.\n    # The problem description's example shows `[b_1,...]` which are variables, not literals.\n    # The example code in problem 3 shows floats.\n    # The provided original code does not format bools to lowercase. I will keep it as is.\n    # But wait, my solve function logic is a little different.\n    # I'll stick to the original code's logic.\n    # The original provided code in the prompt is:\n    # `park_corr_str = f\"[{','.join(map(str, park_correctness))}]\"`\n    # This produces \"True\" and \"False\". Let's use that.\n    \n    park_corr_str = f\"[{','.join(map(str, park_correctness))}]\"\n    mt_corr_str = f\"[{','.join(map(str, mt_correctness))}]\"\n    \n    results = [\n        park_corr_str,\n        mt_corr_str,\n        str(misclass_park),\n        str(misclass_mt),\n        str(better_model_indicator)\n    ]\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将多温度物理模型和有限速率化学模型结合后，我们会得到一个由常微分方程（ODEs）组成的耦合系统，该系统通常具有数值“刚性”（stiffness），给求解带来了挑战。本练习将带你进入计算流体力学（CFD）求解器的核心，学习一种处理此类刚性问题的标准技术：点隐式向后欧拉法。通过为物种质量分数和振动温度的演化推导并实现一个线性化的更新格式，你将掌握将复杂的物理方程转化为可计算的数值算法的关键步骤。",
            "id": "3977830",
            "problem": "在计算流体动力学（CFD）中，考虑一个用于高温气体的多温度模型，该模型包含有限速率化学反应。在此模型中，组分质量分数和振动温度通过点隐式积分在时间上进行局部演化。设存在 $N_s$ 个化学组分，其质量分数为 $Y_i$（$i \\in \\{1,\\dots,N_s\\}$），质量密度为 $\\rho$，振动温度为 $T_v$。假设组分质量分数和振动温度满足以下局部常微分方程：\n$$\n\\frac{d Y_i}{dt} = \\frac{\\omega_i(Y_1,\\dots,Y_{N_s},T_v)}{\\rho}, \\quad i = 1,\\dots,N_s,\n$$\n$$\n\\rho \\, c_{v,v} \\, \\frac{d T_v}{dt} = S_v(Y_1,\\dots,Y_{N_s},T_v),\n$$\n其中 $\\omega_i$ 是用于质量生成的有限速率化学源项，$S_v$ 是振动能源项，$c_{v,v}$ 是定容振动比热。\n\n您需要通过在已知状态 $(Y^n, T_v^n)$ 处对源项进行一阶泰勒展开线性化，为未知增量向量 $\\Delta Y_i = Y_i^{n+1} - Y_i^n$ 和 $\\Delta T_v = T_v^{n+1}-T_v^n$ 构建一个后向欧拉、点隐式的更新方案。令 $\\Delta t$ 为时间步长。在时间层 $n$ 定义源项值及其偏导数\n$$\n\\omega_i^n = \\omega_i(Y^n,T_v^n), \\quad \\left.\\frac{\\partial \\omega_i}{\\partial Y_j}\\right|_n, \\quad \\left.\\frac{\\partial \\omega_i}{\\partial T_v}\\right|_n,\n$$\n$$\nS_v^n = S_v(Y^n,T_v^n), \\quad \\left.\\frac{\\partial S_v}{\\partial Y_j}\\right|_n, \\quad \\left.\\frac{\\partial S_v}{\\partial T_v}\\right|_n.\n$$\n使用后向欧拉方法和线性化，推导关于未知增量 $\\Delta Y_i$ 和 $\\Delta T_v$ 的局部线性系统，将其写成矩阵形式，并用 $\\rho$、$\\Delta t$、$c_{v,v}$ 以及在时间层 $n$ 给定的源项值和导数来表示所有矩阵元素和右端项分量的表达式。\n\n然后，实现一个程序，对每个提供的测试用例，构建并求解这个局部线性系统，以获得更新后的值 $Y_i^{n+1}$ 和 $T_v^{n+1}$。\n\n使用以下测试套件，每个用例由 $(N_s, \\rho, \\Delta t, Y^n, T_v^n, \\omega^n, \\partial \\omega/\\partial Y|_n, \\partial \\omega/\\partial T_v|_n, S_v^n, \\partial S_v/\\partial Y|_n, \\partial S_v/\\partial T_v|_n, c_{v,v})$ 指定。所有量均采用国际单位制（SI）；振动温度必须以开尔文报告，组分质量分数是无量纲的。\n\n- 测试用例 1（一般情况）：\n  - $N_s = 2$\n  - $\\rho = 0.5 \\,\\mathrm{kg/m^3}$\n  - $\\Delta t = 1.0\\times 10^{-3} \\,\\mathrm{s}$\n  - $Y^n = [0.8,\\,0.2]$\n  - $T_v^n = 7000 \\,\\mathrm{K}$\n  - $\\omega^n = [-1.0\\times 10^{-3},\\, 1.0\\times 10^{-3}] \\,\\mathrm{kg/(m^3 \\cdot s)}$\n  - $\\left.\\frac{\\partial \\omega}{\\partial Y}\\right|_n = \\begin{bmatrix} -0.2  0.2 \\\\ 0.2  -0.2 \\end{bmatrix} \\,\\mathrm{kg/(m^3 \\cdot s)}$\n  - $\\left.\\frac{\\partial \\omega}{\\partial T_v}\\right|_n = [0.0,\\,0.0] \\,\\mathrm{kg/(m^3 \\cdot s \\cdot K)}$\n  - $S_v^n = -2000 \\,\\mathrm{W/m^3}$\n  - $\\left.\\frac{\\partial S_v}{\\partial Y}\\right|_n = [100,\\,-100] \\,\\mathrm{W/(m^3)}$\n  - $\\left.\\frac{\\partial S_v}{\\partial T_v}\\right|_n = -5000 \\,\\mathrm{W/(m^3 \\cdot K)}$\n  - $c_{v,v} = 1000 \\,\\mathrm{J/(kg \\cdot K)}$\n\n- 测试用例 2（刚性耦合）：\n  - $N_s = 3$\n  - $\\rho = 0.2 \\,\\mathrm{kg/m^3}$\n  - $\\Delta t = 2.0\\times 10^{-5} \\,\\mathrm{s}$\n  - $Y^n = [0.6,\\,0.3,\\,0.1]$\n  - $T_v^n = 9000 \\,\\mathrm{K}$\n  - $\\omega^n = [-1.0\\times 10^{-2},\\, 8.0\\times 10^{-3},\\, 2.0\\times 10^{-3}] \\,\\mathrm{kg/(m^3 \\cdot s)}$\n  - $\\left.\\frac{\\partial \\omega}{\\partial Y}\\right|_n = \\begin{bmatrix} -10.0  8.0  2.0 \\\\ 10.0  -12.0  2.0 \\\\ 0.0  4.0  -4.0 \\end{bmatrix} \\,\\mathrm{kg/(m^3 \\cdot s)}$\n  - $\\left.\\frac{\\partial \\omega}{\\partial T_v}\\right|_n = [0.5,\\,-0.3,\\,-0.2] \\,\\mathrm{kg/(m^3 \\cdot s \\cdot K)}$\n  - $S_v^n = -5.0\\times 10^{5} \\,\\mathrm{W/m^3}$\n  - $\\left.\\frac{\\partial S_v}{\\partial Y}\\right|_n = [1.0\\times 10^{4},\\, -5.0\\times 10^{3},\\, 0.0] \\,\\mathrm{W/(m^3)}$\n  - $\\left.\\frac{\\partial S_v}{\\partial T_v}\\right|_n = -2.0\\times 10^{6} \\,\\mathrm{W/(m^3 \\cdot K)}$\n  - $c_{v,v} = 1500 \\,\\mathrm{J/(kg \\cdot K)}$\n\n- 测试用例 3（源项和导数均为零的边界情况）：\n  - $N_s = 1$\n  - $\\rho = 1.0 \\,\\mathrm{kg/m^3}$\n  - $\\Delta t = 1.0\\times 10^{-2} \\,\\mathrm{s}$\n  - $Y^n = [1.0]$\n  - $T_v^n = 3000 \\,\\mathrm{K}$\n  - $\\omega^n = [0.0] \\,\\mathrm{kg/(m^3 \\cdot s)}$\n  - $\\left.\\frac{\\partial \\omega}{\\partial Y}\\right|_n = \\begin{bmatrix} 0.0 \\end{bmatrix} \\,\\mathrm{kg/(m^3 \\cdot s)}$\n  - $\\left.\\frac{\\partial \\omega}{\\partial T_v}\\right|_n = [0.0] \\,\\mathrm{kg/(m^3 \\cdot s \\cdot K)}$\n  - $S_v^n = 0.0 \\,\\mathrm{W/m^3}$\n  - $\\left.\\frac{\\partial S_v}{\\partial Y}\\right|_n = [0.0] \\,\\mathrm{W/(m^3)}$\n  - $\\left.\\frac{\\partial S_v}{\\partial T_v}\\right|_n = 0.0 \\,\\mathrm{W/(m^3 \\cdot K)}$\n  - $c_{v,v} = 1000 \\,\\mathrm{J/(kg \\cdot K)}$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个列表，包含更新后的组分质量分数，后跟更新后的振动温度。对于数值，将每个数字表示为小数点后六位的小数浮点数。例如，三个用例的输出格式为 $[[Y_1^{n+1},\\dots,Y_{N_s}^{n+1},T_v^{n+1}], [\\dots], [\\dots]]$，所有温度单位为 $\\mathrm{K}$，质量分数无量纲。",
            "solution": "该问题要求推导并实现一个点隐式、后向欧拉更新方案，用于求解描述高温气体中组分质量分数和振动温度演化的常微分方程（ODE）系统。这是计算流体动力学（CFD）中处理与化学反应和能量交换相关的刚性源项的一种常用且基本的技术。\n\n控制性的局部ODE由以下公式给出：\n$$\n\\frac{d Y_i}{dt} = \\frac{\\omega_i(Y_1,\\dots,Y_{N_s},T_v)}{\\rho}, \\quad i = 1,\\dots,N_s\n$$\n$$\n\\rho \\, c_{v,v} \\, \\frac{d T_v}{dt} = S_v(Y_1,\\dots,Y_{N_s},T_v)\n$$\n其中 $Y_i$ 是组分质量分数，$T_v$ 是振动温度，$\\rho$ 是质量密度，$c_{v,v}$ 是定容振动比热，$\\omega_i$ 是组分质量生成源项，$S_v$ 是振动能源项。组分的数量由 $N_s$ 表示。\n\n我们可以将该系统合并为一个单一的向量方程。令状态向量为 $\\vec{U} \\in \\mathbb{R}^{N_s+1}$，定义为 $\\vec{U} = [Y_1, \\dots, Y_{N_s}, T_v]^T$。该ODE系统可以紧凑地写为 $\\frac{d\\vec{U}}{dt} = \\vec{F}(\\vec{U})$，其中源函数 $\\vec{F}$ 的分量为：\n$$\nF_i(\\vec{U}) = \\frac{\\omega_i(\\vec{U})}{\\rho} \\quad \\text{for } i \\in \\{1, \\dots, N_s\\}\n$$\n$$\nF_{N_s+1}(\\vec{U}) = \\frac{S_v(\\vec{U})}{\\rho c_{v,v}}\n$$\n\n后向欧拉方法是一种一阶精度的隐式积分方案，用于在时间上离散化ODE系统：\n$$\n\\frac{\\vec{U}^{n+1} - \\vec{U}^n}{\\Delta t} = \\vec{F}(\\vec{U}^{n+1})\n$$\n其中 $\\vec{U}^n$ 是当前时间层 $n$ 的已知状态，$\\vec{U}^{n+1}$ 是新时间层 $n+1$ 的未知状态，$\\Delta t$ 是时间步长。\n\n该方程代表了一个关于未知状态 $\\vec{U}^{n+1}$ 的非线性代数方程组。为了高效求解，我们使用一阶泰勒级数展开，在已知状态 $\\vec{U}^n$ 附近对源函数 $\\vec{F}(\\vec{U}^{n+1})$ 进行线性化：\n$$\n\\vec{F}(\\vec{U}^{n+1}) \\approx \\vec{F}(\\vec{U}^n) + \\mathbf{J}_F(\\vec{U}^n) (\\vec{U}^{n+1} - \\vec{U}^n)\n$$\n其中 $\\mathbf{J}_F(\\vec{U}^n) = \\left. \\frac{\\partial \\vec{F}}{\\partial \\vec{U}} \\right|_n$ 是源函数 $\\vec{F}$ 的雅可比矩阵，在时间层 $n$ 进行求值。令未知增量向量为 $\\Delta \\vec{U} = \\vec{U}^{n+1} - \\vec{U}^n$。将线性化结果代入后向欧拉公式可得：\n$$\n\\frac{\\Delta \\vec{U}}{\\Delta t} \\approx \\vec{F}(\\vec{U}^n) + \\mathbf{J}_F(\\vec{U}^n) \\Delta \\vec{U}\n$$\n这是一个关于增量向量 $\\Delta \\vec{U}$ 的线性系统。我们将其重排为标准形式 $\\mathbf{A} \\vec{x} = \\vec{b}$：\n$$\n\\left( \\frac{\\mathbf{I}}{\\Delta t} - \\mathbf{J}_F(\\vec{U}^n) \\right) \\Delta \\vec{U} = \\vec{F}(\\vec{U}^n)\n$$\n两边同乘以 $\\Delta t$ 得到局部线性系统的最终形式：\n$$\n\\left( \\mathbf{I} - \\Delta t \\, \\mathbf{J}_F(\\vec{U}^n) \\right) \\Delta \\vec{U} = \\Delta t \\, \\vec{F}(\\vec{U}^n)\n$$\n其中 $\\mathbf{I}$ 是 $(N_s+1) \\times (N_s+1)$ 的单位矩阵。\n\n下一步是根据问题陈述中提供的量，推导系统矩阵的元素和右端向量的显式表达式。系统矩阵为 $\\mathbf{A} = \\mathbf{I} - \\Delta t \\, \\mathbf{J}_F(\\vec{U}^n)$，右端向量为 $\\vec{b} = \\Delta t \\, \\vec{F}(\\vec{U}^n)$。未知向量为 $\\Delta\\vec{U} = [\\Delta Y_1, \\dots, \\Delta Y_{N_s}, \\Delta T_v]^T$。\n\n首先，我们通过对 $\\vec{F}$ 的分量求偏导数来确定雅可比矩阵 $\\mathbf{J}_F$ 的分量：\n对于组分方程（$i \\in \\{1, \\dots, N_s\\}$）：\n$$\n(\\mathbf{J}_F)_{ij} = \\frac{\\partial F_i}{\\partial Y_j} = \\frac{\\partial}{\\partial Y_j} \\left( \\frac{\\omega_i}{\\rho} \\right) = \\frac{1}{\\rho} \\frac{\\partial \\omega_i}{\\partial Y_j} \\quad \\text{for } j \\in \\{1, \\dots, N_s\\}\n$$\n$$\n(\\mathbf{J}_F)_{i, N_s+1} = \\frac{\\partial F_i}{\\partial T_v} = \\frac{\\partial}{\\partial T_v} \\left( \\frac{\\omega_i}{\\rho} \\right) = \\frac{1}{\\rho} \\frac{\\partial \\omega_i}{\\partial T_v}\n$$\n对于振动能方程（第 $N_s+1$ 行）：\n$$\n(\\mathbf{J}_F)_{N_s+1, j} = \\frac{\\partial F_{N_s+1}}{\\partial Y_j} = \\frac{\\partial}{\\partial Y_j} \\left( \\frac{S_v}{\\rho c_{v,v}} \\right) = \\frac{1}{\\rho c_{v,v}} \\frac{\\partial S_v}{\\partial Y_j} \\quad \\text{for } j \\in \\{1, \\dots, N_s\\}\n$$\n$$\n(\\mathbf{J}_F)_{N_s+1, N_s+1} = \\frac{\\partial F_{N_s+1}}{\\partial T_v} = \\frac{\\partial}{\\partial T_v} \\left( \\frac{S_v}{\\rho c_{v,v}} \\right) = \\frac{1}{\\rho c_{v,v}} \\frac{\\partial S_v}{\\partial T_v}\n$$\n所有导数均在已知状态 $\\vec{U}^n$ 下求值。\n\n现在我们可以指定矩阵 $\\mathbf{A}$ 和向量 $\\vec{b}$ 的元素。\n\n**$\\mathbf{A} \\Delta\\vec{U} = \\vec{b}$ 中矩阵 $\\mathbf{A}$ 的元素：**\n矩阵 $\\mathbf{A}$ 的大小为 $(N_s+1) \\times (N_s+1)$。\n\n1.  左上块（$N_s \\times N_s$），对于 $i \\in \\{1, \\dots, N_s\\}$ 和 $j \\in \\{1, \\dots, N_s\\}$：\n    $$\n    A_{ij} = (\\mathbf{I} - \\Delta t \\, \\mathbf{J}_F)_{ij} = \\delta_{ij} - \\Delta t \\, (\\mathbf{J}_F)_{ij} = \\delta_{ij} - \\frac{\\Delta t}{\\rho} \\left. \\frac{\\partial \\omega_i}{\\partial Y_j} \\right|_n\n    $$\n    其中 $\\delta_{ij}$ 是克罗内克δ符号。\n\n2.  右上块（$N_s \\times 1$），与 $\\Delta T_v$ 耦合的列，对于 $i \\in \\{1, \\dots, N_s\\}$：\n    $$\n    A_{i, N_s+1} = -\\Delta t \\, (\\mathbf{J}_F)_{i, N_s+1} = - \\frac{\\Delta t}{\\rho} \\left. \\frac{\\partial \\omega_i}{\\partial T_v} \\right|_n\n    $$\n\n3.  左下块（$1 \\times N_s$），$T_v$ 方程所在的行，对于 $j \\in \\{1, \\dots, N_s\\}$：\n    $$\n    A_{N_s+1, j} = -\\Delta t \\, (\\mathbf{J}_F)_{N_s+1, j} = - \\frac{\\Delta t}{\\rho c_{v,v}} \\left. \\frac{\\partial S_v}{\\partial Y_j} \\right|_n\n    $$\n\n4.  右下块（$1 \\times 1$），$T_v$ 方程的对角项：\n    $$\n    A_{N_s+1, N_s+1} = 1 - \\Delta t \\, (\\mathbf{J}_F)_{N_s+1, N_s+1} = 1 - \\frac{\\Delta t}{\\rho c_{v,v}} \\left. \\frac{\\partial S_v}{\\partial T_v} \\right|_n\n    $$\n\n**右端向量 $\\vec{b}$ 的分量：**\n向量 $\\vec{b}$ 有 $N_s+1$ 个分量。\n\n1.  上部（前 $N_s$ 个分量），对应于组分方程：\n    $$\n    b_i = \\Delta t \\, F_i(\\vec{U}^n) = \\frac{\\Delta t}{\\rho} \\, \\omega_i^n \\quad \\text{for } i \\in \\{1, \\dots, N_s\\}\n    $$\n\n2.  下部（最后一个分量），对应于能量方程：\n    $$\n    b_{N_s+1} = \\Delta t \\, F_{N_s+1}(\\vec{U}^n) = \\frac{\\Delta t}{\\rho c_{v,v}} \\, S_v^n\n    $$\n\n根据时间层 $n$ 的给定数据构建矩阵 $\\mathbf{A}$ 和向量 $\\vec{b}$ 后，我们求解线性系统 $\\mathbf{A} \\Delta\\vec{U} = \\vec{b}$ 以找到增量向量 $\\Delta\\vec{U} = [\\Delta Y_1, \\dots, \\Delta Y_{N_s}, \\Delta T_v]^T$。\n\n最后，将状态变量更新到新的时间层 $n+1$：\n$$\nY_i^{n+1} = Y_i^n + \\Delta Y_i, \\quad i = 1, \\dots, N_s\n$$\n$$\nT_v^{n+1} = T_v^n + \\Delta T_v\n$$\n以下程序为提供的测试用例实现了此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves the point-implicit linear system for each test case\n    to find the updated species mass fractions and vibrational temperature.\n    \"\"\"\n    test_cases = [\n        {\n            \"Ns\": 2,\n            \"rho\": 0.5,\n            \"dt\": 1.0e-3,\n            \"Yn\": [0.8, 0.2],\n            \"Tvn\": 7000,\n            \"omega_n\": [-1.0e-3, 1.0e-3],\n            \"d_omega_d_Y_n\": [[-0.2, 0.2], [0.2, -0.2]],\n            \"d_omega_d_Tv_n\": [0.0, 0.0],\n            \"Sv_n\": -2000,\n            \"d_Sv_d_Y_n\": [100, -100],\n            \"d_Sv_d_Tv_n\": -5000,\n            \"c_vv\": 1000,\n        },\n        {\n            \"Ns\": 3,\n            \"rho\": 0.2,\n            \"dt\": 2.0e-5,\n            \"Yn\": [0.6, 0.3, 0.1],\n            \"Tvn\": 9000,\n            \"omega_n\": [-1.0e-2, 8.0e-3, 2.0e-3],\n            \"d_omega_d_Y_n\": [[-10.0, 8.0, 2.0], [10.0, -12.0, 2.0], [0.0, 4.0, -4.0]],\n            \"d_omega_d_Tv_n\": [0.5, -0.3, -0.2],\n            \"Sv_n\": -5.0e5,\n            \"d_Sv_d_Y_n\": [1.0e4, -5.0e3, 0.0],\n            \"d_Sv_d_Tv_n\": -2.0e6,\n            \"c_vv\": 1500,\n        },\n        {\n            \"Ns\": 1,\n            \"rho\": 1.0,\n            \"dt\": 1.0e-2,\n            \"Yn\": [1.0],\n            \"Tvn\": 3000,\n            \"omega_n\": [0.0],\n            \"d_omega_d_Y_n\": [[0.0]],\n            \"d_omega_d_Tv_n\": [0.0],\n            \"Sv_n\": 0.0,\n            \"d_Sv_d_Y_n\": [0.0],\n            \"d_Sv_d_Tv_n\": 0.0,\n            \"c_vv\": 1000,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters\n        Ns = case[\"Ns\"]\n        rho = case[\"rho\"]\n        dt = case[\"dt\"]\n        Yn = np.array(case[\"Yn\"], dtype=float)\n        Tvn = float(case[\"Tvn\"])\n        omega_n = np.array(case[\"omega_n\"], dtype=float)\n        d_omega_d_Y_n = np.array(case[\"d_omega_d_Y_n\"], dtype=float)\n        d_omega_d_Tv_n = np.array(case[\"d_omega_d_Tv_n\"], dtype=float)\n        Sv_n = float(case[\"Sv_n\"])\n        d_Sv_d_Y_n = np.array(case[\"d_Sv_d_Y_n\"], dtype=float)\n        d_Sv_d_Tv_n = float(case[\"d_Sv_d_Tv_n\"])\n        c_vv = float(case[\"c_vv\"])\n\n        # Initialize the matrix A and vector b\n        system_size = Ns + 1\n        A = np.zeros((system_size, system_size))\n        b = np.zeros(system_size)\n\n        # Populate matrix A\n        # Upper-left block (species-species coupling)\n        A[:Ns, :Ns] = np.identity(Ns) - (dt / rho) * d_omega_d_Y_n\n        # Upper-right block (species-temperature coupling)\n        A[:Ns, Ns] = - (dt / rho) * d_omega_d_Tv_n\n        # Lower-left block (temperature-species coupling)\n        A[Ns, :Ns] = - (dt / (rho * c_vv)) * d_Sv_d_Y_n\n        # Lower-right block (temperature-temperature coupling)\n        A[Ns, Ns] = 1 - (dt / (rho * c_vv)) * d_Sv_d_Tv_n\n\n        # Populate vector b\n        # Upper part (species source terms)\n        b[:Ns] = (dt / rho) * omega_n\n        # Lower part (energy source term)\n        b[Ns] = (dt / (rho * c_vv)) * Sv_n\n\n        # Solve the linear system A * delta_U = b\n        delta_U = np.linalg.solve(A, b)\n\n        # Extract increments\n        delta_Y = delta_U[:Ns]\n        delta_Tv = delta_U[Ns]\n\n        # Update the state\n        Y_np1 = Yn + delta_Y\n        Tv_np1 = Tvn + delta_Tv\n\n        # Store the result for this case\n        case_result = list(Y_np1) + [Tv_np1]\n        results.append(case_result)\n\n    # Format the final output string as per requirements\n    formatted_results = []\n    for res_list in results:\n        formatted_nums = [f\"{num:.6f}\" for num in res_list]\n        formatted_results.append(f\"[{','.join(formatted_nums)}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}