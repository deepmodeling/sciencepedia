{
    "hands_on_practices": [
        {
            "introduction": "对于移动边界问题，精确且守恒地更新边界位置的表示是首要且至关重要的一步。本练习提供了一个动手实践，要求实现一种几何精确且守恒的重映照（remapping）方案 。掌握该技术是构建稳健的移动边界模拟的基础，确保在边界运动过程中，流体体积或质量等关键物理量得到严格守恒。",
            "id": "3966968",
            "problem": "您的任务是推导并实现一个在一维周期性域中移动的浸入边界的保守重映（conservative re-mapping），其中掩码或体积分数场由给定的位移进行平流输运，同时通过切割单元（cut-cell）更新来保证精确守恒。推导必须从局部守恒的有限体积公式出发，基于刚性平移下的测度守恒以及雷诺输运定理，并且不得依赖简便公式。\n\n考虑一个长度为 $L$（单位：米）的一维周期性域，它被离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀有限体积单元。设在时间 $t^n$ 时，有一个刚体段（即浸入边界）占据区间 $[x_a, x_b]$，其中 $0 \\le x_a \\le x_b \\le L$。二元掩码通过一个指示函数来表示固体区域；对于有限体积切割单元处理，我们将单元 $i$ 在时间 $t$ 的流体体积分数定义为流体集合指示函数的单元平均值，记为 $ \\alpha_i(t) \\in [0,1]$，其中对于完全流体单元，$ \\alpha_i(t) = 1$，对于完全固体单元，$ \\alpha_i(t) = 0$。\n\n在时间 $t^n$ 和 $t^{n+1}$ 之间，浸入边界在周期性边界条件下经历了一个位移为 $d$（单位：米）的刚性平移。您的任务是：\n\n- 从第一性原理推导在时间 $t^{n+1}$ 的单元平均流体体积分数 $ \\alpha_i^{n+1}$ 的保守重映，确保在周期性平移下网格上流体测度的精确保守。推导必须从有限体积守恒声明和刚性平移的测度保持性质出发，并且必须解释为什么重映能够保持总流体长度，以及切割单元是如何在没有流体体积损失或增益的情况下更新的。\n\n- 实现一个程序，在给定 $L$、$N$、$(x_a, x_b)$ 和 $d$ 的情况下，使用一种考虑了周期性环绕的、几何一致且严格保守的切割单元更新方法，计算所有单元更新后的流体体积分数 $ \\alpha_i^{n+1}$。该算法必须对非零、零、正、负以及大的位移 $d$ 均有效，并且必须正确处理边界位置与单元面完全对齐（不产生切割单元）或严格位于单元内部（对于单个刚体段，恰好产生两个切割单元）的情况。\n\n对于每个测试用例，计算并报告：\n1. 以米为单位的绝对守恒误差，定义为 $t^{n+1}$ 和 $t^n$ 时刻总流体长度之差的绝对值，即 $ \\left| \\sum_i \\alpha_i^{n+1} \\Delta x - \\sum_i \\alpha_i^{n} \\Delta x \\right|$。\n2. 更新后的切割单元数量，定义为满足 $0  \\alpha_i^{n+1}  1$ 的单元个数。\n\n物理单位要求：守恒误差以米表示。不使用角度。不使用百分比；分数以小数形式报告。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表。该列表必须按下面列出的测试用例顺序，交替包含每个测试用例的守恒误差（浮点数，单位为米）和切割单元数（整数）。例如：\"[err1,cc1,err2,cc2,err3,cc3,err4,cc4,err5,cc5]\"。\n\n实现并评估以下测试套件：\n- 测试用例 1（标准路径，移动后不与单元面对齐）：$L = 1.0$ 米, $N = 16$, $x_a = 0.25$ 米, $x_b = 0.50$ 米, $d = +0.10$ 米。\n- 测试用例 2（边界条件：零位移）：$L = 1.0$ 米, $N = 16$, $x_a = 0.25$ 米, $x_b = 0.50$ 米, $d = 0.0$ 米。\n- 测试用例 3（精确单单元格位移）：$L = 1.0$ 米, $N = 20$, $x_a = 0.10$ 米, $x_b = 0.34$ 米, $d = \\Delta x$（使用此测试的网格计算 $\\Delta x$）。\n- 测试用例 4（带环绕的负位移）：$L = 1.0$ 米, $N = 16$, $x_a = 0.85$ 米, $x_b = 0.95$ 米, $d = -0.20$ 米。\n- 测试用例 5（带多次环绕的大位移）：$L = 1.0$ 米, $N = 100$, $x_a = 0.02$ 米, $x_b = 0.478$ 米, $d = +1.30$ 米。\n\n您的实现必须是自包含的，不得读取任何外部输入，并且必须严格遵守指定的输出格式。",
            "solution": "该问题要求针对包含一个平移刚体的一维周期性域，推导并实现一个用于流体体积分数 $\\alpha_i$ 的保守重映算法。推导必须基于有限体积守恒和刚性平移下测度守恒的原理。\n\n### 从第一性原理推导\n\n设流体域由一个指示函数 $H(x, t)$ 表征，当 $x$ 在时间 $t$ 位于流体中时，$H(x, t) = 1$，当 $x$ 位于固体中时，$H(x, t) = 0$。刚体的运动是速度为 $u$ 的匀速平移。指示函数的演化由线性平流方程决定：\n$$\n\\frac{\\partial H}{\\partial t} + u \\frac{\\partial H}{\\partial x} = 0\n$$\n该方程表明，属性 $H$ 沿着特征线 $x(t) = x_0 + ut$ 是守恒的。\n\n宽度为 $\\Delta x$ 的计算单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$ 中的流体体积分数 $\\alpha_i(t)$ 是 $H(x, t)$ 的单元平均值：\n$$\n\\alpha_i(t) = \\frac{1}{\\Delta x} \\int_{C_i} H(x, t) dx\n$$\n\n为了推导 $\\alpha_i$ 从时间 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的更新法则，我们从守恒律的积分形式出发。该形式是将雷诺输运定理应用于固定控制体积 $C_i$ 中的物理量 $H$ 的直接结果。将平流方程在单元 $C_i$ 上积分：\n$$\n\\int_{C_i} \\left(\\frac{\\partial H}{\\partial t} + \\frac{\\partial(uH)}{\\partial x}\\right) dx = 0\n$$\n由于速度 $u$ 是常数。在一维上应用散度定理，并对第一项交换积分和时间微分的顺序（因为 $C_i$ 是固定的），得到：\n$$\n\\frac{d}{dt} \\int_{C_i} H(x, t) dx + [uH]_{x_{i+1/2}} - [uH]_{x_{i-1/2}} = 0\n$$\n代入 $\\alpha_i(t)$ 的定义，给出单元平均量的精确演化方程：\n$$\n\\frac{d}{dt} (\\alpha_i \\Delta x) + F_{i+1/2} - F_{i-1/2} = 0\n$$\n其中 $F(x, t) = uH(x, t)$ 是指示函数的通量。将此方程在时间区间 $[t^n, t^{n+1}]$ 上积分：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{d}{dt} (\\alpha_i \\Delta x) dt + \\int_{t^n}^{t^{n+1}} (F_{i+1/2} - F_{i-1/2}) dt = 0\n$$\n$$\n\\alpha_i(t^{n+1})\\Delta x - \\alpha_i(t^n)\\Delta x + \\int_{t^n}^{t^{n+1}} (F_{i+1/2} - F_{i-1/2}) dt = 0\n$$\n令 $\\alpha_i^n = \\alpha_i(t^n)$，更新后的体积分数由下式给出：\n$$\n\\alpha_i^{n+1} = \\alpha_i^n - \\frac{1}{\\Delta x} \\int_{t^n}^{t^{n+1}} (F_{i+1/2}(t) - F_{i-1/2}(t)) dt\n$$\n这就是基本的有限体积更新公式。挑战在于如何计算时间积分通量。\n\n对于刚体在时间间隔 $\\Delta t$ 内平移位移 $d$（其中 $d = u \\Delta t$）的特定情况，我们可以精确求解 $\\alpha_i^{n+1}$ 而无需近似通量。平流方程的精确解可以通过特征线法给出：\n$$\nH(x, t^{n+1}) = H(x - u\\Delta t, t^n) = H(x - d, t^n)\n$$\n因此，新的体积分数 $\\alpha_i^{n+1}$ 可以通过将这个精确解在单元 $C_i$ 上平均来直接计算：\n$$\n\\alpha_i^{n+1} = \\frac{1}{\\Delta x} \\int_{C_i} H(x, t^{n+1}) dx = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} H(x - d, t^n) dx\n$$\n这个积分表示了基于初始流体分布平移 $d$ 后，单元 $C_i$ 内的流体分数。这是一个纯粹的几何计算：我们确定固体的新位置 $[x_a+d, x_b+d]$，并计算它与每个单元 $C_i$ 的交集以找到新的固体分数，从而得到流体分数 $\\alpha_i^{n+1}$。该方法通常被称为几何重映或重新初始化。\n\n### 守恒性质\n\n这种几何重映方法是内在地、精确地守恒的。$t^{n+1}$ 时刻的总流体长度（测度）为 $\\mathcal{L}^{n+1} = \\sum_{i=0}^{N-1} \\alpha_i^{n+1} \\Delta x$。代入 $\\alpha_i^{n+1}$ 的表达式：\n$$\n\\mathcal{L}^{n+1} = \\sum_{i=0}^{N-1} \\left( \\int_{x_{i-1/2}}^{x_{i+1/2}} H(x - d, t^n) dx \\right) = \\int_{0}^{L} H(x-d, t^n) dx\n$$\n最后一步是通过对覆盖域 $[0, L]$ 的所有相邻单元的积分求和得到的。我们进行变量替换 $y = x - d$，因此 $dy = dx$。积分限从 $[0, L]$ 变为 $[-d, L-d]$。\n$$\n\\mathcal{L}^{n+1} = \\int_{-d}^{L-d} H(y, t^n) dy\n$$\n由于域和函数 $H(y, t^n)$ 都是周期为 $L$ 的周期函数，周期函数在其周期长度的任何区间上的积分都是一个常数。因此：\n$$\n\\int_{-d}^{L-d} H(y, t^n) dy = \\int_{0}^{L} H(y, t^n) dy\n$$\n这最后的积分即为 $t^n$ 时刻的总流体长度：\n$$\n\\int_{0}^{L} H(y, t^n) dy = \\sum_{i=0}^{N-1} \\int_{C_i} H(y, t^n) dy = \\sum_{i=0}^{N-1} \\alpha_i^n \\Delta x = \\mathcal{L}^n\n$$\n因此，$\\mathcal{L}^{n+1} = \\mathcal{L}^n$。总流体长度是精确保守的，与网格分辨率或位移 $d$ 无关。通过几何相交来更新切割单元保证了没有流体体积的损失或增益，因为它直接计算了新的状态，而如上所证，新状态必须保持总测度守恒。\n\n### 算法实现\n\n算法流程如下：\n1.  将域 $[0, L]$ 离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的单元，定义单元边界为 $x_{i-1/2} = i \\cdot \\Delta x$，其中 $i=0, \\dots, N$。\n2.  定义一个辅助函数 `overlap([a, b], [c, d])`，用于计算两个区间交集的长度，其值为 $\\max(0, \\min(b, d) - \\max(a, c))$。\n3.  对于 $t^n$ 时刻的初始状态，计算固体区间 $[x_a, x_b]$。对每个单元 $i$，计算初始固体长度 $s_i^n$，即单元区间 $[x_{i-1/2}, x_{i+1/2}]$ 与 $[x_a, x_b]$ 的重叠长度。初始流体分数为 $\\alpha_i^n = 1 - s_i^n / \\Delta x$。计算初始总流体长度 $\\mathcal{L}^n = \\sum_i \\alpha_i^n \\Delta x$。\n4.  计算固体的新端点：$x_a' = x_a + d$ 和 $x_b' = x_b + d$。\n5.  处理周期性边界条件。域 $[0, L)$ 中的新固体区域由模运算确定。令 $x_{a, \\text{mod}}' = x_a' \\pmod L$ 和 $x_{b, \\text{mod}}' = x_b' \\pmod L$。假设物体长度 $x_b-x_a \\le L$，存在两种情况：\n    a. 如果 $x_{a, \\text{mod}}' \\le x_{b, \\text{mod}}'$，新的固体形成单个区间 $[x_{a, \\text{mod}}', x_{b, \\text{mod}}']$。\n    b. 如果 $x_{a, \\text{mod}}' > x_{b, \\text{mod}}'$，固体区域已环绕周期性边界，并占据两个区间：$[0, x_{b, \\text{mod}}']$ 和 $[x_{a, \\text{mod}}', L]$。\n6.  对于 $t^{n+1}$ 时刻的最终状态，计算新的流体分数 $\\alpha_i^{n+1}$。对每个单元 $i$，通过将单元区间与步骤5中确定的新固体区间（或多个区间）的重叠长度求和，来计算新的固体长度 $s_i^{n+1}$。最终流体分数为 $\\alpha_i^{n+1} = 1 - s_i^{n+1} / \\Delta x$。\n7.  计算最终总流体长度 $\\mathcal{L}^{n+1} = \\sum_i \\alpha_i^{n+1} \\Delta x$。\n8.  绝对守恒误差为 $|\\mathcal{L}^{n+1} - \\mathcal{L}^n|$。\n9.  切割单元的数量是满足 $0  \\alpha_i^{n+1}  1$ 的单元个数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, non-aligned)\n        {\"L\": 1.0, \"N\": 16, \"xa\": 0.25, \"xb\": 0.50, \"d\": +0.10},\n        # Test case 2 (zero displacement)\n        {\"L\": 1.0, \"N\": 16, \"xa\": 0.25, \"xb\": 0.50, \"d\": 0.0},\n        # Test case 3 (exact one-cell shift)\n        {\"L\": 1.0, \"N\": 20, \"xa\": 0.10, \"xb\": 0.34, \"d\": 1.0 / 20.0},\n        # Test case 4 (negative displacement with wrap-around)\n        {\"L\": 1.0, \"N\": 16, \"xa\": 0.85, \"xb\": 0.95, \"d\": -0.20},\n        # Test case 5 (large displacement with multiple wraps)\n        {\"L\": 1.0, \"N\": 100, \"xa\": 0.02, \"xb\": 0.478, \"d\": +1.30},\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, xa, xb, d = case[\"L\"], case[\"N\"], case[\"xa\"], case[\"xb\"], case[\"d\"]\n        error, cut_cells = compute_remapping(L, N, xa, xb, d)\n        results.extend([error, cut_cells])\n\n    # Format the output as specified in the problem\n    formatted_results = []\n    for i in range(len(results)):\n        if i % 2 == 0:  # Conservation error (float)\n            formatted_results.append(f\"{results[i]:.17g}\")\n        else:  # Number of cut cells (integer)\n            formatted_results.append(str(results[i]))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef compute_remapping(L: float, N: int, xa: float, xb: float, d: float):\n    \"\"\"\n    Computes the updated fluid volume fractions and associated metrics.\n\n    Args:\n        L: Length of the periodic domain.\n        N: Number of finite volume cells.\n        xa: Initial start position of the solid segment.\n        xb: Initial end position of the solid segment.\n        d: Rigid displacement.\n\n    Returns:\n        A tuple containing:\n        - The absolute conservation error in fluid length.\n        - The number of cut-cells after the update.\n    \"\"\"\n    dx = L / N\n    cell_edges = np.linspace(0, L, N + 1)\n    \n    def get_overlap_length(interval1, interval2):\n        \"\"\"Calculates the length of the intersection of two intervals.\"\"\"\n        a1, b1 = interval1\n        a2, b2 = interval2\n        return max(0.0, min(b1, b2) - max(a1, a2))\n\n    def calculate_alphas(solid_intervals):\n        \"\"\"Calculates alpha values for a given set of solid intervals.\"\"\"\n        alphas = np.ones(N)\n        for i in range(N):\n            cell_interval = (cell_edges[i], cell_edges[i+1])\n            solid_length_in_cell = 0.0\n            for solid_interval in solid_intervals:\n                solid_length_in_cell += get_overlap_length(cell_interval, solid_interval)\n            \n            # Use a small tolerance to avoid floating point issues at cell boundaries\n            # In principle, `solid_length_in_cell / dx` should be = 1.0\n            solid_fraction = solid_length_in_cell / dx\n            alphas[i] = 1.0 - solid_fraction\n        return alphas\n\n    # === Initial state (t^n) ===\n    solid_intervals_n = [(xa, xb)]\n    alphas_n = calculate_alphas(solid_intervals_n)\n    total_fluid_length_n = np.sum(alphas_n) * dx\n\n    # === Final state (t^{n+1}) ===\n    xa_new = xa + d\n    xb_new = xb + d\n\n    # Handle periodicity\n    # Python's % operator behaves as a mathematical modulo for negative numbers\n    xa_new_mod = xa_new % L\n    xb_new_mod = xb_new % L\n    \n    solid_intervals_np1 = []\n    if (xb_new - xa_new) = L: # Body is as long or longer than the domain\n        solid_intervals_np1.append((0, L))\n    elif xa_new_mod  xb_new_mod:\n        # Single continuous interval\n        solid_intervals_np1.append((xa_new_mod, xb_new_mod))\n    else:\n        # Wrapped around the boundary, two intervals\n        solid_intervals_np1.append((xa_new_mod, L))\n        solid_intervals_np1.append((0.0, xb_new_mod))\n\n    alphas_np1 = calculate_alphas(solid_intervals_np1)\n    total_fluid_length_np1 = np.sum(alphas_np1) * dx\n\n    # === Calculate final metrics ===\n    conservation_error = abs(total_fluid_length_np1 - total_fluid_length_n)\n    \n    # A cell is a cut-cell if alpha is not exactly 0 or 1.\n    # Use a small tolerance for floating point comparisons.\n    epsilon = 1e-9\n    num_cut_cells = np.sum((alphas_np1  epsilon)  (alphas_np1  1.0 - epsilon))\n    \n    return conservation_error, int(num_cut_cells)\n\nsolve()\n\n```"
        },
        {
            "introduction": "在引入流体动力学后，界面处理的核心挑战之一是表面张力的离散化。当离散的压力梯度和表面张力不平衡时，会产生非物理的“寄生流”，严重影响模拟的准确性。本练习将引导你实现一种“力平衡”公式 ，这是现代多相流求解器中的一项关键技术，并通过量化对比，展示其相对于朴素非平衡方法的显著优势。",
            "id": "3966969",
            "problem": "考虑一个二维静态液滴，在流体体积（VOF）框架内，使用连续表面力（CSF）方法和沉浸边界（IB）界面处理来表示。目标是实现一种力平衡格式，其中离散压力梯度和离散表面张力共享相同的微分算子和空间排列，从而最大限度地减少寄生流。工作在均匀的笛卡尔网格上，并假设使用无量纲变量（不需要物理单位）。推导必须从不可壓縮穩態動量平衡和通过平滑相指示函数对表面张力的标准体积力近似开始。\n\n使用以下基础：\n- 不可压缩动量方程在稳态下简化为 $$\\nabla p = \\mathbf{f}_{\\sigma},$$ 其中 $p$ 是压力，$\\mathbf{f}_{\\sigma}$ 是单位体积的表面张力。\n- CSF 表示法将位于界面上的奇异表面张力近似为 $$\\mathbf{f}_{\\sigma} \\approx \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi),$$ 其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是界面曲率，$H_{\\epsilon}$ 是符号距离函数 $\\phi$ 的平滑Heaviside函数，$\\epsilon$ 是平滑半宽。\n- 对于半径为 $R$ 的圆形液滴，平均曲率是恒定的，等于 $$\\kappa = \\frac{1}{R}。$$\n\n你必须：\n1. 在一个 $N_x \\times N_y$ 的周期性域 $\\Omega = [0,1] \\times [0,1]$ 上实现一个离散格式，其均匀间距为 $$\\Delta x = \\frac{1}{N_x}, \\quad \\Delta y = \\frac{1}{N_y},$$ 单元中心位于 $$x_i = \\left(i+\\frac{1}{2}\\right)\\Delta x, \\quad y_j = \\left(j+\\frac{1}{2}\\right)\\Delta y。$$\n2. 为一个半径为 $R$、中心在 $(c_x,c_y)$ 的液滴构建一个符号距离函数 $$\\phi(x,y) = \\sqrt{(x-c_x)^2 + (y-c_y)^2} - R$$，并定义平滑的Heaviside函数 $$H_{\\epsilon}(\\phi) = \\begin{cases} 0,  \\phi \\le -\\epsilon, \\\\ \\frac{1}{2}\\left[1 + \\frac{\\phi}{\\epsilon} + \\frac{1}{\\pi}\\sin\\left(\\frac{\\pi \\phi}{\\epsilon}\\right)\\right],  |\\phi|  \\epsilon, \\\\ 1,  \\phi \\ge \\epsilon. \\end{cases}$$\n3. 对于任何标量场 $q_{i,j}$，使用带有周期性边界条件的二阶中心差分来实现离散梯度算子，使得 $$\\left(\\nabla q\\right)_{i,j} = \\left(\\frac{q_{i+1,j} - q_{i-1,j}}{2\\Delta x}, \\frac{q_{i,j+1} - q_{i,j-1}}{2\\Delta y}\\right),$$ 其中索引周期性回绕。\n4. 定义力平衡壓力为 $$p = p_0 + \\sigma \\kappa H_{\\epsilon}(\\phi),$$ 其中 $p_0 = 0$，并使用相同的中心差分算子计算两个梯度，从而计算稳态动量平衡的离散残差 $$\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\nabla p。$$\n5. 定义一个故意不平衡的格式，该格式的算子和平滑处理不匹配：计算 $$\\mathbf{R}_{\\text{unbal}} = \\sigma \\kappa \\nabla^{\\text{fwd}} H(\\phi) - \\nabla p,$$ 其中 $H$ 是未平滑的Heaviside函数 $$H(\\phi) = \\begin{cases} 0,  \\phi  0, \\\\ 1,  \\phi \\ge 0, \\end{cases}$$ 且 $\\nabla^{\\text{fwd}}$ 是带有周期性边界条件的一阶向前差分梯度：\n$$\\left(\\nabla^{\\text{fwd}} q\\right)_{i,j} = \\left(\\frac{q_{i+1,j} - q_{i,j}}{\\Delta x}, \\frac{q_{i,j+1} - q_{i,j}}{\\Delta y}\\right)。$$\n6. 通过计算标量残差范数来量化每种情况下的不平衡程度 $$\\|\\mathbf{R}\\|_2 = \\left(\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left(R_x^2 + R_y^2\\right)\\right)^{1/2}。$$\n7. 在你的解答中证明，在上述假设下，并且对两项使用相同的离散梯度算子时，当 $\\kappa$ 为常数时，离散残差 $\\mathbf{R}_{\\text{bal}}$ 恒等于零，从而证明稳态下的离散力平衡。\n\n测试套件：\n对于每种情况，取 $\\epsilon = \\alpha \\Delta x$，其中 $\\alpha$ 为指定值，且 $\\sigma = 1$。\n- 情况1（常规“理想”情况）：$N_x = 64$，$N_y = 64$，$R = 0.20$，$(c_x,c_y) = (0.50,0.50)$，$\\alpha = 1.5$。\n- 情况2（偏离中心靠近边界）：$N_x = 64$，$N_y = 64$，$R = 0.15$，$(c_x,c_y) = (0.35,0.40)$，$\\alpha = 1.5$。\n- 情况3（接近网格分辨率极限）：$N_x = 64$，$N_y = 64$，$R = 2\\Delta x$，$(c_x,c_y) = (0.52,0.47)$，$\\alpha = 1.0$。\n\n对于每种情况，你的程序必须计算并返回两个浮点数：平衡残差范数和不平衡残差范数，两者均为无量纲。你的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来，其中每种情况贡献一个表示为二元列表的对，例如，$$[\\,[r_{1,\\text{bal}}, r_{1,\\text{unbal}}],\\,[r_{2,\\text{bal}}, r_{2,\\text{unbal}}],\\,[r_{3,\\text{bal}}, r_{3,\\text{unbal}}]\\,].$$",
            "solution": "所呈现的问题是计算流体动力学中一个有效且适定的练习，具体涉及静态界面表面张力的数值处理。它科学地基于流体体积（VOF）方法与连续表面力（CSF）模型相结合的原理。其目标是展示“力平衡”离散化的重要性，即离散压力梯度和表面张力算子被一致地构建，以消除被称为寄生流的虚假数值伪影。我们将首先提供离散力平衡的形式化证明，然后描述用于数值验证的算法实现。\n\n所有数学实体，包括变量、符号、算子和数字，都按要求以LaTeX格式呈現。\n\n**基于原理的推导与算法设计**\n\n所考虑的基本状态是处于平衡状态的静态流体液滴。在没有流体运动和外部体力（如重力）的情况下，不可压缩稳态Navier-Stokes动量方程简化为压力梯度力与表面张力之间的平衡：\n$$\n\\nabla p = \\mathbf{f}_{\\sigma}\n$$\n其中`$p$`是压力场，`$\\mathbf{f}_{\\sigma}$`是体积表面张力。连续表面力（CSF）方法通过使用平滑的相指示函数，将物理上局限于界面的力建模为一个连续场。指定的模型是：\n$$\n\\mathbf{f}_{\\sigma} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi)\n$$\n在这里，`$\\sigma$`是恒定的表面张力系数，`$\\kappa$`是界面平均曲率，`$\\phi$`是到界面的符号距离函数（SDF），`$H_{\\epsilon}$`是一个正则化或平滑的Heaviside函数，它在一个厚度为`$2\\epsilon$`的界面上从`$0$`（液滴内）平滑过渡到`$1$`（液滴外）。对于半径为`$R$`的圆形液滴，曲率`$\\kappa = 1/R$`在界面上处处恒定。\n\n**离散力平衡的证明**\n\n力平衡格式的核心原则是确保压力梯度和表面张力的离散近似在静态平衡情况下能够精确地相互抵消。这可以防止产生非零的合力，从而避免错误地引发流体运动。\n\n我们被要求证明平衡格式的离散残差`$\\mathbf{R}_{\\text{bal}}$`恒等于零。该残差定义为：\n$$\n\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\nabla p\n$$\n“平衡”的方面是通过对压力场`$p$`的特定定义引入的。与Young-Laplace方程一致，跨界面的压力跳跃为`$\\Delta p = \\sigma \\kappa$`。在CSF框架中，这是通过使用与表面张力相同的平滑Heaviside函数来定义压力场本身来实现的：\n$$\np = p_0 + \\sigma \\kappa H_{\\epsilon}(\\phi)\n$$\n当参考压力`$p_0$`设为`$0$`时，这简化为`$p = \\sigma \\kappa H_{\\epsilon}(\\phi)$`。\n\n将`$p$`的这个定义代入残差方程，得到：\n$$\n\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\nabla \\left( \\sigma \\kappa H_{\\epsilon}(\\phi) \\right)\n$$\n在连续域中，由于`$\\sigma$`和`$\\kappa$`是常数，它们可以从梯度算子中提出。梯度算子`$\\nabla$`是一个线性算子，意味着对于任何常数标量`$c$`和标量场`$f$`，`$\\nabla(c f) = c \\nabla f$`。因此，\n$$\n\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) = \\mathbf{0}\n$$\n关键步骤是验证这也适用于*离散*算子。令`$\\mathcal{G}$`表示指定的离散二阶中心差分梯度算子。问题指出，在`$\\mathbf{R}_{\\text{bal}}$`中，两项都使用完全相同的算子。在网格单元`$(i,j)$`处的离散残差为：\n$$\n(\\mathbf{R}_{\\text{bal}})_{i,j} = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} - \\mathcal{G}(p)_{i,j}\n$$\n离散压力场在每个单元中心定义为`$p_{i,j} = \\sigma \\kappa (H_{\\epsilon})_{i,j}$`，其中`$(H_{\\epsilon})_{i,j}$`是该单元中心處平滑Heaviside函数的值。将此代入残差：\n$$\n(\\mathbf{R}_{\\text{bal}})_{i,j} = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} - \\mathcal{G}(\\sigma \\kappa H_{\\epsilon})_{i,j}\n$$\n中心差分算子`$\\mathcal{G}$`是一个线性算子。例如，其作用于场`$q$`的x分量是`$\\mathcal{G}_x(q)_{i,j} = (q_{i+1,j} - q_{i-1,j}) / (2\\Delta x)$`。将此应用于`$\\sigma \\kappa H_{\\epsilon}$`：\n$$\n\\mathcal{G}_x(\\sigma \\kappa H_{\\epsilon})_{i,j} = \\frac{(\\sigma \\kappa H_{\\epsilon})_{i+1,j} - (\\sigma \\kappa H_{\\epsilon})_{i-1,j}}{2\\Delta x} = \\sigma \\kappa \\left( \\frac{(H_{\\epsilon})_{i+1,j} - (H_{\\epsilon})_{i-1,j}}{2\\Delta x} \\right) = \\sigma \\kappa \\mathcal{G}_x(H_{\\epsilon})_{i,j}\n$$\n这证明了`$\\mathcal{G}(\\sigma \\kappa H_{\\epsilon}) = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})$`。因此，离散残差变为：\n$$\n(\\mathbf{R}_{\\text{bal}})_{i,j} = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} - \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} = \\mathbf{0}\n$$\n这对域中的每个单元`$(i,j)`都成立。因此，残差的范数`$\\|\\mathbf{R}_{\\text{bal}}\\|_2$`必须恒等于零（或者由于浮点运算而是一个接近机器精度的值）。证明至此完成。\n\n相比之下，不平衡格式\n$$\n\\mathbf{R}_{\\text{unbal}} = \\sigma \\kappa \\nabla^{\\text{fwd}} H(\\phi) - \\nabla p\n$$\n被设计为无法达到这种平衡。不平衡源于两个不同的原因：\n1.  **算子不匹配**：表面张力项使用一阶向前差分（`$\\nabla^{\\text{fwd}}$`）进行离散化，而压力梯度使用二阶中心差分（`$\\nabla$`）。这些算子具有不同的模板和截断误差，因此即使使用相同的函数，`$\\sigma \\kappa \\nabla^{\\text{fwd}} H_{\\epsilon}(\\phi) \\neq \\nabla (\\sigma \\kappa H_{\\epsilon}(\\phi))$`。\n2.  **函数不匹配**：表面张力项使用原始、未平滑的Heaviside函数`$H(\\phi)$`，而压力是使用平滑函数`$H_{\\epsilon}(\\phi)$`定义的。`$H(\\phi)$`的梯度是Dirac delta函数的离散近似，这与`$H_{\\epsilon}(\\phi)$`的光滑、钟形导数有根本不同。\n\n由于这些不一致性，`$\\mathbf{R}_{\\text{unbal}}$`将显著非零，导致数值结果中预期出现较大的残差范数。\n\n**数值实现算法**\n\n为每个测试用例计算残差的数值程序遵循以下步骤：\n1.  **网格设置**：对于给定的分辨率`$N_x, N_y$`，定义域大小`$L_x = 1, L_y = 1$`并计算网格间距`$\\Delta x = L_x/N_x$`和`$\\Delta y = L_y/N_y$`。构造两个`$N_y \\times N_x$`数组，表示单元中心坐标`$x_{i,j} = (i+0.5)\\Delta x$`和`$y_{i,j} = (j+0.5)\\Delta y$`。\n2.  **参数计算**：对于每个测试用例，使用给定的`$R, c_x, c_y, \\alpha$`来确定曲率`$\\kappa = 1/R$`和平滑宽度`$\\epsilon = \\alpha \\Delta x$`。表面张力系数为`$\\sigma = 1$`。\n3.  **场计算**：\n    -   计算符号距离函数场`$\\phi_{i,j} = \\sqrt{(x_{i,j}-c_x)^2 + (y_{i,j}-c_y)^2} - R$`。\n    -   使用提供的分段公式计算平滑Heaviside场`$(H_{\\epsilon})_{i,j}$`。\n    -   计算未平滑Heaviside场`$(H)_{i,j}$`。\n    -   计算压力场`$p_{i,j} = \\sigma \\kappa (H_{\\epsilon})_{i,j}$`。\n4.  **梯度计算**：实现两个处理周期性边界的离散梯度函数。\n    -   `grad_cen(q)`：此函数接受一个二维场`$q$`，并返回中心差分梯度的x和y分量的两个二维场。周期性通过数组滚动操作（例如，`numpy.roll`）来处理。\n    -   `grad_fwd(q)`：类似地，此函数计算向前差分梯度。\n5.  **残差计算**：\n    -   **平衡情况**：\n        -   使用`grad_cen`计算`$(\\nabla H_{\\epsilon})_{i,j}`。\n        -   使用`grad_cen`计算`$(\\nabla p)_{i,j}`。\n        -   计算残差分量：`$R_{\\text{bal},x} = \\sigma \\kappa (\\nabla H_{\\epsilon})_x - (\\nabla p)_x$`和`$R_{\\text{bal},y} = \\sigma \\kappa (\\nabla H_{\\epsilon})_y - (\\nabla p)_y$`。\n    -   **不平衡情况**：\n        -   使用`grad_fwd`计算`$(\\nabla^{\\text{fwd}} H)_{i,j}`。\n        -   压力梯度`$(\\nabla p)_{i,j}`与平衡情况相同（基于中心差分）。\n        -   计算残差分量：`$R_{\\textunbal},x} = \\sigma \\kappa (\\nabla^{\\text{fwd}} H)_x - (\\nabla p)_x$`和`$R_{\\text{unbal},y} = \\sigma \\kappa (\\nabla^{\\text{fwd}} H)_y - (\\nabla p)_y$`。\n6.  **范数计算**：对于`$\\mathbf{R}_{\\text{bal}}$`和`$\\mathbf{R}_{\\text{unbal}}$`，按规定计算均方根范数：`$\\|\\mathbf{R}\\|_2 = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i,j} (R_x^2 + R_y^2)}$`。这可以高效地计算为`np.sqrt(np.mean(R_x**2 + R_y**2))`。\n7.  **迭代**：对测试套件中提供的所有测试用例重复步骤2-6，并按要求格式化生成的范数。",
            "answer": "```python\nimport numpy as np\n\n# Meticulous adherence to the specified execution environment:\n# language: Python 3.12\n# libraries:\n#     - name: numpy, version: 1.23.5\n\ndef solve():\n    \"\"\"\n    Computes balanced and unbalanced force residuals for a static droplet\n    using an Immersed Boundary (CSF) method.\n    \"\"\"\n\n    def grad_cen(q, dx, dy):\n        \"\"\"Computes the 2D gradient using second-order central differences\n        with periodic boundary conditions.\"\"\"\n        grad_x = (np.roll(q, -1, axis=1) - np.roll(q, 1, axis=1)) / (2.0 * dx)\n        grad_y = (np.roll(q, -1, axis=0) - np.roll(q, 1, axis=0)) / (2.0 * dy)\n        return grad_x, grad_y\n\n    def grad_fwd(q, dx, dy):\n        \"\"\"Computes the 2D gradient using first-order forward differences\n        with periodic boundary conditions.\"\"\"\n        grad_x = (np.roll(q, -1, axis=1) - q) / dx\n        grad_y = (np.roll(q, -1, axis=0) - q) / dy\n        return grad_x, grad_y\n\n    def H_eps_func(phi, epsilon):\n        \"\"\"Computes the smoothed Heaviside function H_epsilon(phi).\"\"\"\n        H = np.zeros_like(phi)\n        \n        # Condition: phi = -epsilon\n        mask1 = phi = -epsilon\n        H[mask1] = 0.0\n        \n        # Condition: phi >= epsilon\n        mask2 = phi >= epsilon\n        H[mask2] = 1.0\n\n        # Condition: |phi|  epsilon\n        mask3 = np.abs(phi)  epsilon\n        phi_masked = phi[mask3]\n        \n        term1 = 1.0 + phi_masked / epsilon\n        term2 = (1.0 / np.pi) * np.sin(np.pi * phi_masked / epsilon)\n        H[mask3] = 0.5 * (term1 + term2)\n        \n        return H\n\n    def H_func(phi):\n        \"\"\"Computes the unsmoothed Heaviside function H(phi).\"\"\"\n        H = np.zeros_like(phi)\n        H[phi >= 0] = 1.0\n        return H\n\n    def calculate_residual_norm(Rx, Ry):\n        \"\"\"Computes the L2 norm of the residual vector field.\"\"\"\n        return np.sqrt(np.mean(Rx**2 + Ry**2))\n\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # (Nx, Ny, R, cx, cy, alpha)\n        (64, 64, 0.20, 0.50, 0.50, 1.5),  # Case 1\n        (64, 64, 0.15, 0.35, 0.40, 1.5),  # Case 2\n        (64, 64, 2.0 * (1.0/64), 0.52, 0.47, 1.0), # Case 3 R=2*dx\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Nx, Ny, R, cx, cy, alpha = case\n        \n        # --- 1. Grid and Parameter Setup ---\n        sigma = 1.0\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        \n        # Check for R=0 to avoid division by zero, although not in test cases\n        if R == 0:\n            kappa = np.inf\n        else:\n            kappa = 1.0 / R\n            \n        epsilon = alpha * dx # Assuming dx=dy for simplicity in definition\n\n        x = (np.arange(Nx) + 0.5) * dx\n        y = (np.arange(Ny) + 0.5) * dy\n        X, Y = np.meshgrid(x, y)\n\n        # --- 2. Field Computations ---\n        phi = np.sqrt((X - cx)**2 + (Y - cy)**2) - R\n        \n        H_eps_field = H_eps_func(phi, epsilon)\n        H_field = H_func(phi)\n        \n        p_field = sigma * kappa * H_eps_field\n\n        # --- 3. Balanced Case Calculation ---\n        # Surface tension term using central differences on H_eps\n        f_sigma_x_bal, f_sigma_y_bal = grad_cen(H_eps_field, dx, dy)\n        f_sigma_x_bal *= sigma * kappa\n        f_sigma_y_bal *= sigma * kappa\n        \n        # Pressure gradient term using central differences on p\n        grad_p_x_cen, grad_p_y_cen = grad_cen(p_field, dx, dy)\n\n        # Balanced residual\n        R_bal_x = f_sigma_x_bal - grad_p_x_cen\n        R_bal_y = f_sigma_y_bal - grad_p_y_cen\n        \n        norm_bal = calculate_residual_norm(R_bal_x, R_bal_y)\n\n        # --- 4. Unbalanced Case Calculation ---\n        # Surface tension term using forward differences on H\n        f_sigma_x_unbal, f_sigma_y_unbal = grad_fwd(H_field, dx, dy)\n        f_sigma_x_unbal *= sigma * kappa\n        f_sigma_y_unbal *= sigma * kappa\n\n        # Pressure gradient is the same as before (central difference on p based on H_eps)\n        # grad_p_x_cen, grad_p_y_cen are already computed\n\n        # Unbalanced residual\n        R_unbal_x = f_sigma_x_unbal - grad_p_x_cen\n        R_unbal_y = f_sigma_y_unbal - grad_p_y_cen\n        \n        norm_unbal = calculate_residual_norm(R_unbal_x, R_unbal_y)\n\n        results.append([norm_bal, norm_unbal])\n\n    # --- 5. Final Output Formatting ---\n    # The required format is [[r1_bal, r1_unbal],[r2_bal, r2_unbal],...], which\n    # is a list of lists. The str() of a list of lists gives '[...]', so we join them.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实现了力模型之后，我们需要有效的方法来验证其动态精度。本练习介绍了一种强大的验证技术：通过比较毛细波的数值色散关系与理论解来评估曲率计算的准确性 。这种方法将数值格式的离散误差与它所模拟的物理现象直接联系起来，为评估和改进界面力模型提供了定量的依据。",
            "id": "3966939",
            "problem": "考虑一种二维、无粘性、不可压缩的液体，其密度为 $\\rho$，占据了半空间 $y \\le 0$，其上方是静止的被动气体。自由表面由 $y = \\eta(x,t)$ 给出，其振幅很小，满足 $|\\eta| \\ll 1/k$ 和 $|\\partial_x \\eta| \\ll 1$。设重力被忽略。该液体由不可压缩欧拉方程描述，并在界面处满足运动学和动力学边界条件。表面张力系数为 $\\sigma$ (单位 $\\mathrm{N/m}$)。在线性、小斜率范围和深水极限下，可以从这些基本方程中获得毛细波的色散关系。在采用连续表面力 (CSF) 公式的流体体积 (VOF) 方法中，曲率是根据界面表示计算的。为了分离曲率精度对色散的影响，考虑以下离散曲率模型：在 $x$ 方向上间距为 $\\Delta$ 的均匀网格上，用其高度函数 $\\eta(x,t)$ 表示界面，并将连续曲率（在小斜率极限下）替换为应用于 $\\eta$ 的二阶中心差分算子，即\n$$\nD^2_\\Delta \\eta_j \\equiv \\frac{\\eta_{j+1} - 2 \\eta_j + \\eta_{j-1}}{\\Delta^2}.\n$$\n假设单一傅里叶模态 $x \\mapsto \\eta(x,t) = a \\cos(k x - \\omega t)$，其波数为 $k$ (单位 $\\mathrm{m^{-1}}$)，振幅为 $a$，满足 $a k \\ll 1$。\n\n任务：仅从不可压缩欧拉方程、运动学边界条件以及界面处由表面张力引起的动力学跳跃条件出发，围绕平坦状态进行线性化，并推导出：\n- 在连续介质设置下，小振幅毛细波的色散关系，问题陈述中未指定其最终形式，以及\n- 当表面张力中使用的曲率被替换为应用于均匀网格上高度函数的离散算子 $D^2_\\Delta$ 时，相应的数值色散关系。\n\n使用此结果设计一个测试，通过比较连续波频率和数值波频率来测量曲率引起的色散误差。您的程序必须实现以下步骤：\n- 给定 $(\\rho, \\sigma, k, \\Delta)$，计算连续毛细波频率和由上述离散曲率模型所隐含的数值毛细波频率，两者均以 $\\mathrm{s^{-1}}$ 表示。\n- 计算相对频率误差，定义为无量纲浮点数\n$$\n\\varepsilon \\equiv \\frac{\\omega_{\\text{num}} - \\omega_{\\text{cont}}}{\\omega_{\\text{cont}}}.\n$$\n\n您必须假设三角函数接受的参数以弧度为单位。\n\n您的程序必须输出一行，其中包含一个浮点数列表，每个浮点数精确到小数点后 $10$ 位，对应于下面每个测试用例的相对频率误差 $\\varepsilon$，并按给定顺序排列。不应打印任何其他文本。\n\n测试套件（每个元组为 $(\\rho\\ \\mathrm{kg/m^3}, \\sigma\\ \\mathrm{N/m}, k\\ \\mathrm{m^{-1}}, \\Delta\\ \\mathrm{m})$）：\n- 用例 1：$(1000.0,\\ 0.072,\\ 50.0,\\ 0.001)$\n- 用例 2：$(1000.0,\\ 0.072,\\ 50.0,\\ 0.005)$\n- 用例 3：$(1000.0,\\ 0.072,\\ 300.0,\\ 0.01)$\n- 用例 4：$(1000.0,\\ 0.072,\\ 1400.0,\\ 0.002)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$），其中每个 $\\varepsilon_i$ 都精确到小数点后 $10$ 位。",
            "solution": "该问题要求推导并比较小振幅毛细波的连续和数值色散关系。目标是量化由界面曲率的特定有限差分近似所引入的误差。\n\n**1. 连续色散关系推导**\n\n我们从密度为 $\\rho$ 的无粘性、不可压缩液体在区域 $y \\le \\eta(x,t)$ 中的基本方程开始，其上方是被动气体，且无重力。假设流动从静止开始，因此是无旋的，所以速度场 $\\vec{u}$ 可以由一个速度势 $\\phi$ 描述，使得 $\\vec{u} = \\nabla\\phi$。\n\n势函数 $\\phi(x,y,t)$ 的控制方程是拉普拉斯方程，它源于不可压缩性条件 $\\nabla \\cdot \\vec{u} = 0$：\n$$ \\nabla^2 \\phi = \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = 0 \\quad \\text{for } y  \\eta(x,t) $$\n\n该问题受以下边界条件约束：\n1.  **深水条件**：远离表面的流体是静止的。\n    $$ \\nabla \\phi \\to 0 \\quad \\text{as } y \\to -\\infty $$\n2.  **运动学条件**：在自由表面 $y = \\eta(x,t)$ 上的流体粒子会一直停留在表面上。\n    $$ \\frac{\\partial \\phi}{\\partial y} = \\frac{\\partial \\eta}{\\partial t} + \\frac{\\partial \\phi}{\\partial x} \\frac{\\partial \\eta}{\\partial x} \\quad \\text{at } y = \\eta(x,t) $$\n3.  **动力学条件**：跨界面的压力跳跃由表面张力平衡。\n    $$ p(x, \\eta, t) - p_{\\text{gas}} = \\sigma \\kappa $$\n    其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是界面曲率。气体是被动的，因此我们将其压力 $p_{\\text{gas}}$ 设为常数参考值 $0$。界面处的液体压力 $p$ 由非定常伯努利方程（忽略重力）给出：$\\frac{\\partial \\phi}{\\partial t} + \\frac{1}{2}|\\nabla \\phi|^2 + \\frac{p}{\\rho} = 0$。对于高度函数，曲率为 $\\kappa = \\frac{\\partial^2_x \\eta}{(1 + (\\partial_x \\eta)^2)^{3/2}}$。\n\n我们对静止状态（$\\eta=0, \\phi=0$）周围的小振幅（$|\\eta| \\ll 1/k$）和小斜率（$|\\partial_x \\eta| \\ll 1$）波进行线性化。我们只保留小量（$\\eta, \\phi$ 及其导数）的一阶项。边界条件在平均表面水平 $y=0$ 处进行评估。\n\n在 $y=0$ 处的线性化边界条件变为：\n1.  **线性化运动学边界条件**：\n    $$ \\frac{\\partial \\phi}{\\partial y} = \\frac{\\partial \\eta}{\\partial t} $$\n2.  **线性化动力学边界条件**：压力为 $p \\approx -\\rho \\frac{\\partial \\phi}{\\partial t}$，曲率为 $\\kappa \\approx \\frac{\\partial^2 \\eta}{\\partial x^2}$。\n    $$ -\\rho \\frac{\\partial \\phi}{\\partial t} = \\sigma \\frac{\\partial^2 \\eta}{\\partial x^2} $$\n\n我们寻找以下形式的波状解：\n$$ \\eta(x,t) = \\Re\\{A e^{i(kx - \\omega t)}\\}, \\quad \\phi(x,y,t) = \\Re\\{\\hat{\\phi}(y) e^{i(kx - \\omega t)}\\} $$\n将 $\\phi$ 的形式代入拉普拉斯方程，得到 $\\frac{d^2\\hat{\\phi}}{dy^2} - k^2\\hat{\\phi} = 0$，其通解为 $\\hat{\\phi}(y) = C_1 e^{ky} + C_2 e^{-ky}$。深水条件要求解在 $y \\to -\\infty$ 时衰减，因此对于 $k>0$，我们必须有 $C_2=0$。因此，势函数的形式为：\n$$ \\phi(x,y,t) = \\Re\\{B e^{ky} e^{i(kx - \\omega t)}\\} $$\n其中 $B$ 为某个常数。\n\n将线性化边界条件应用于 $y=0$ 处的复数形式 $\\eta = A e^{i(kx - \\omega t)}$ 和 $\\phi = B e^{ky} e^{i(kx - \\omega t)}$：\n- 来自运动学条件：\n  $$ kB e^{i(kx-\\omega t)} = -i\\omega A e^{i(kx-\\omega t)} \\implies kB = -i\\omega A $$\n- 来自动力学条件：\n  $$ -\\rho(-i\\omega) B e^{i(kx-\\omega t)} = \\sigma(ik)^2 A e^{i(kx-\\omega t)} \\implies i\\rho\\omega B = -\\sigma k^2 A $$\n将第一个方程中的 $B = -i\\omega A/k$ 代入第二个方程：\n$$ i\\rho\\omega \\left(-\\frac{i\\omega}{k} A\\right) = -\\sigma k^2 A \\implies \\frac{\\rho\\omega^2}{k} A = \\sigma k^2 A $$\n这得出了深水毛细波的连续色散关系：\n$$ \\omega_{\\text{cont}}^2 = \\frac{\\sigma k^3}{\\rho} \\implies \\omega_{\\text{cont}} = \\sqrt{\\frac{\\sigma k^3}{\\rho}} $$\n\n**2. 数值色散关系推导**\n\n数值模型将连续曲率项 $\\kappa \\approx \\partial^2_x \\eta$ 替换为其在间距为 $\\Delta$ 的网格上的二阶中心差分近似 $D^2_\\Delta \\eta_j$，其中 $x_j = j\\Delta$。\n$$ \\kappa_{\\text{num}} = D^2_\\Delta \\eta_j = \\frac{\\eta_{j+1} - 2\\eta_j + \\eta_{j-1}}{\\Delta^2} $$\n让我们分析这个离散算子对单一傅里叶模态 $\\eta_j = A e^{i(kx_j - \\omega t)} = A e^{i(kj\\Delta - \\omega t)}$ 的作用。\n$$ \\eta_{j\\pm 1} = A e^{i(k(j\\pm 1)\\Delta - \\omega t)} = \\eta_j e^{\\pm ik\\Delta} $$\n将此代入算子：\n$$ D^2_\\Delta \\eta_j = \\eta_j \\frac{e^{ik\\Delta} - 2 + e^{-ik\\Delta}}{\\Delta^2} = \\eta_j \\frac{2\\cos(k\\Delta) - 2}{\\Delta^2} $$\n使用恒等式 $1 - \\cos\\theta = 2\\sin^2(\\theta/2)$，这变为：\n$$ D^2_\\Delta \\eta_j = \\eta_j \\left( \\frac{-4\\sin^2(k\\Delta/2)}{\\Delta^2} \\right) $$\n因此，数值模型等效于连续模型，只是曲率算子 $\\partial^2_x / \\partial x^2$（其在傅里叶模态上作用为乘以 $-k^2$）被替换为乘以 $\\frac{-4\\sin^2(k\\Delta/2)}{\\Delta^2}$。\n\n数值色散关系的推导过程完全相同，只是线性化的动力学边界条件现在变为：\n$$ -\\rho \\frac{\\partial \\phi}{\\partial t} = \\sigma \\left( \\eta \\frac{-4\\sin^2(k\\Delta/2)}{\\Delta^2} \\right) \\quad \\text{at } y=0 $$\n对 $\\phi$ 和 $\\eta$ 应用傅里叶模态，这变为：\n$$ i\\rho\\omega_{\\text{num}} B = - \\sigma A \\frac{4\\sin^2(k\\Delta/2)}{\\Delta^2} $$\n使用与未改变的运动学条件相同的关系 $B = -i\\omega_{\\text{num}} A/k$：\n$$ \\frac{\\rho\\omega_{\\text{num}}^2}{k} A = \\sigma A \\frac{4\\sin^2(k\\Delta/2)}{\\Delta^2} $$\n这得出了数值色散关系：\n$$ \\omega_{\\text{num}}^2 = \\frac{\\sigma k}{\\rho} \\left(\\frac{2\\sin(k\\Delta/2)}{\\Delta}\\right)^2 \\implies \\omega_{\\text{num}} = \\frac{2|\\sin(k\\Delta/2)|}{\\Delta} \\sqrt{\\frac{\\sigma k}{\\rho}} $$\n\n**3. 色散误差分析**\n\n相对频率误差 $\\varepsilon$ 定义为：\n$$ \\varepsilon = \\frac{\\omega_{\\text{num}} - \\omega_{\\text{cont}}}{\\omega_{\\text{cont}}} = \\frac{\\omega_{\\text{num}}}{\\omega_{\\text{cont}}} - 1 $$\n我们代入 $\\omega_{\\text{num}}$ 和 $\\omega_{\\text{cont}}$ 的表达式。我们假设 $k\\Delta \\in [0, \\pi]$ 以便波被解析且 $\\sin(k\\Delta/2) \\ge 0$。\n$$ \\varepsilon = \\frac{\\frac{2\\sin(k\\Delta/2)}{\\Delta} \\sqrt{\\frac{\\sigma k}{\\rho}}}{k \\sqrt{\\frac{\\sigma k}{\\rho}}} - 1 $$\n物理参数 $\\rho$ 和 $\\sigma$ 消掉了，表明误差纯粹是数值离散化的结果。误差表达式简化为无量纲乘积 $k\\Delta$ 的函数，该乘积表示每个网格单元的波的相位变化（即数值分辨率）。\n$$ \\varepsilon = \\frac{2\\sin(k\\Delta/2)}{k\\Delta} - 1 $$\n此公式将用于计算给定测试用例的误差。对于小的 $k\\Delta$，泰勒展开给出 $\\varepsilon \\approx - (k\\Delta)^2/24$，表明该方案是二阶精度的，并且数值频率低于连续频率（耗散误差）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the curvature-induced relative dispersion error for capillary waves\n    based on a finite-difference approximation for curvature.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (rho in kg/m^3, sigma in N/m, k in m^-1, delta in m)\n    test_cases = [\n        (1000.0, 0.072, 50.0, 0.001),\n        (1000.0, 0.072, 50.0, 0.005),\n        (1000.0, 0.072, 300.0, 0.01),\n        (1000.0, 0.072, 1400.0, 0.002),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters. Note that rho and sigma are not needed for the relative error.\n        _rho, _sigma, k, delta = case\n\n        # The relative frequency error epsilon is derived in the solution as:\n        # epsilon = (omega_num - omega_cont) / omega_cont\n        #\n        # where:\n        # omega_cont = sqrt(sigma * k**3 / rho)\n        # omega_num = (2 * sin(k*delta/2) / delta) * sqrt(sigma * k / rho)\n        #\n        # The ratio omega_num / omega_cont simplifies to:\n        # (2 * sin(k*delta/2)) / (k * delta)\n        #\n        # Therefore, the relative error epsilon simplifies to:\n        # epsilon = (2 * sin(k*delta/2)) / (k*delta) - 1\n        # This expression depends only on the dimensionless product k*delta,\n        # which quantifies the grid resolution of the wave.\n\n        k_delta = k * delta\n\n        # The mathematical expression sin(x)/x approaches 1 as x approaches 0.\n        # In this case, epsilon = 1 - 1 = 0.\n        # This check handles the non-physical but numerically possible case of k*delta = 0.\n        if k_delta == 0.0:\n            epsilon = 0.0\n        else:\n            # The argument to np.sin is in radians, which is consistent with the\n            # dimensionless nature of k*delta.\n            epsilon = (2.0 * np.sin(k_delta / 2.0)) / k_delta - 1.0\n\n        results.append(epsilon)\n\n    # Format the results to exactly 10 decimal places and join them into the\n    # required output string format.\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}