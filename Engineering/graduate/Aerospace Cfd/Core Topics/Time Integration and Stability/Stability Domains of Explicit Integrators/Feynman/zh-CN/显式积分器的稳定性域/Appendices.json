{
    "hands_on_practices": [
        {
            "introduction": "实践始于一个最基本的问题：给定一个系统（由其特征值 $\\lambda_j$ 表示）、一个时间积分方案（由其稳定性函数 $R(z)$ 表示）和一个时间步长（$\\Delta t$），数值模拟是否稳定？本练习将提供一个常见CFD模型（一维对流扩散方程）的特征值，并要求你编写一个程序来直接应用稳定性判据 $|R(\\Delta t \\lambda_j)| \\leq 1$。这是任何使用显式方法的数值分析师都需掌握的基础技能。",
            "id": "3995991",
            "problem": "考虑一个在计算流体力学（CFD）中常见的线性、常系数、周期性、一维半离散平流-扩散算子。设物理域长度为 $L$（单位：$\\mathrm{m}$），用 $N$ 个等距点进行离散化，网格间距为 $h = L/N$（单位：$\\mathrm{m}$），平流速度为 $a$（单位：$\\mathrm{m/s}$），运动粘度为 $\\nu$（单位：$\\mathrm{m^2/s}$）。使用循环差分算子的离散傅里叶变换本征基，作用于离散状态 $u(t)$ 的半离散空间算子 $\\mathcal{L}$ 具有本征对 $\\left(\\lambda_j, \\phi_j\\right)$，其索引为 $j \\in \\{0,1,\\dots,N-1\\}$，特征值由下式给出：\n$$\n\\lambda_j = -a\\,\\mathrm{i}\\,\\frac{\\sin\\left(\\theta_j\\right)}{h} + \\nu\\,\\frac{2\\cos\\left(\\theta_j\\right) - 2}{h^2}, \\quad \\theta_j = \\frac{2\\pi j}{N},\n$$\n其中 $\\mathrm{i}$ 表示虚数单位。这可由周期性网格上的中心差分一阶导数算子和二阶离散拉普拉斯算子的符号推导得出。\n\n将一个显式单步时间积分器应用于线性测试方程 $\\frac{\\mathrm{d}y}{\\mathrm{d}t} = \\lambda y$，通过 $y_{n+1} = R(z)\\,y_n$ 将 $y_{n}$推进到 $y_{n+1}$，其中 $z = \\Delta t\\,\\lambda$，$R(z)$ 是该方法导出的标量稳定性函数。绝对稳定域 $\\mathcal{S}$ 定义为：\n$$\n\\mathcal{S} = \\left\\{z \\in \\mathbb{C} \\;:\\; \\left|R(z)\\right| \\leq 1 \\right\\}.\n$$\n在所选的显式积分器和时间步长 $\\Delta t$（单位：$\\mathrm{s}$）下，半离散系统线性稳定的充分必要条件是，所有缩放后的特征值 $z_j = \\Delta t\\,\\lambda_j$ 都位于 $\\mathcal{S}$ 内。\n\n你的任务是实现一个程序，该程序：\n- 使用上述公式计算周期性平流-扩散算子 $\\mathcal{L}$ 的谱 $\\{\\lambda_j\\}_{j=0}^{N-1}$。\n- 对于给定的显式积分器（从以下经典选项中选择：前向欧拉法、二阶龙格-库塔法、三阶龙格-库塔法和四阶龙格-库塔法），构建并评估相应的稳定性函数 $R(z)$。\n- 通过验证所有 $z_j = \\Delta t\\,\\lambda_j$ 是否满足 $\\left|R(z_j)\\right| \\leq 1$（允许在边界上取等号）来测试线性稳定性。\n- 为每个测试用例报告一个布尔值，指示该配置是否稳定。\n\n所有物理参数使用上述指定的单位表示，所有角度在内部使用弧度。最终输出应为单行，包含一个用方括号括起来的、由逗号分隔的布尔值列表（例如，$[\\mathrm{True},\\mathrm{False}]$）。\n\n使用以下测试套件，它涵盖了一般情况、边界条件和边缘情况。每个测试用例由元组 $(\\text{integrator}, L, N, a, \\nu, \\Delta t)$ 指定：\n- 测试 $1$（扩散，前向欧拉法，预期稳定）：$(\\text{FE},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 0\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 0.02\\,\\mathrm{s})$。\n- 测试 $2$（扩散，前向欧拉法，最高波数处的边界情况）：$(\\text{FE},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 0\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 0.05\\,\\mathrm{s})$。\n- 测试 $3$（平流-扩散，前向欧拉法，因虚数谱预期不稳定）：$(\\text{FE},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 100\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 10^{-4}\\,\\mathrm{s})$。\n- 测试 $4$（平流，四阶龙格-库塔法，对于小的 $\\Delta t$ 预期稳定）：$(\\text{RK4},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 100\\,\\mathrm{m/s},\\; \\nu = 0\\,\\mathrm{m^2/s},\\; \\Delta t = 2\\times 10^{-4}\\,\\mathrm{s})$。\n- 测试 $5$（扩散，二阶龙格-库塔法，对于大的 $\\Delta t$ 预期不稳定）：$(\\text{RK2},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 0\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 0.075\\,\\mathrm{s})$。\n- 测试 $6$（平流-扩散，三阶龙格-库塔法，对于足够小的 $\\Delta t$ 预期稳定）：$(\\text{RK3},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 50\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 10^{-4}\\,\\mathrm{s})$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的结果列表（例如，$[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True},\\mathrm{False},\\mathrm{True}]$）。不应打印任何额外文本。",
            "solution": "用户请求解决一个关于一维平流-扩散方程数值格式线性稳定性的问题。该问题有效、有科学依据且适定。求解方法基于线方法（method of lines），其中空间和时间离散化被分开分析。全离散格式的稳定性取决于半离散空间算子的谱在经时间步长 $\\Delta t$ 缩放后，是否完全位于显式时间积分器的绝对稳定域内。\n\n求解算法步骤如下：\n\n首先，我们定义所提供的每个测试用例的参数：积分器类型、域长度 $L$、网格点数 $N$、平流速度 $a$、运动粘度 $\\nu$ 和时间步长 $\\Delta t$。根据这些参数，计算网格间距 $h = L/N$。\n\n其次，我们计算半离散空间算子 $\\mathcal{L}$ 的谱。问题指出，对于用 $N$ 个点离散化的周期域，其特征值 $\\lambda_j$ 由以下公式给出（对于 $j \\in \\{0, 1, \\dots, N-1\\}$）：\n$$\n\\lambda_j = -a\\,\\mathrm{i}\\,\\frac{\\sin\\left(\\theta_j\\right)}{h} + \\nu\\,\\frac{2\\cos\\left(\\theta_j\\right) - 2}{h^2}\n$$\n其中 $\\theta_j = \\frac{2\\pi j}{N}$ 且 $\\mathrm{i}$ 是虚数单位。第一项 $-a\\,\\mathrm{i}\\,\\frac{\\sin\\left(\\theta_j\\right)}{h}$ 源于平流项 $a\\frac{\\partial u}{\\partial x}$ 的二阶中心差分近似，其特征值为纯虚数。第二项 $\\nu\\,\\frac{2\\cos\\left(\\theta_j\\right) - 2}{h^2}$ 源于扩散项 $\\nu\\frac{\\partial^2 u}{\\partial x^2}$ 的二阶中心差分近似，其特征值为实数且非正。所有特征值的集合 $\\{\\lambda_j\\}_{j=0}^{N-1}$ 在复平面的左半部分形成一个轨迹。\n\n第三，我们为指定的显式时间积分器定义稳定性函数 $R(z)$。这些函数是复变量 $z$ 的多项式，通过将积分器应用于标量测试方程 $\\frac{\\mathrm{d}y}{\\mathrm{d}t} = \\lambda y$ 导出，得到 $y_{n+1} = R(\\Delta t \\lambda) y_n$。对于所指定的经典 $p$ 阶龙格-库塔方法，其稳定性函数是指数函数 $e^z$ 的 $p$ 次泰勒多项式：\n$$\nR_p(z) = \\sum_{k=0}^{p} \\frac{z^k}{k!}\n$$\n具体的函数是：\n-   前向欧拉法 (FE, $p=1$): $R(z) = 1 + z$\n-   二阶龙格-库塔法 (RK2, $p=2$): $R(z) = 1 + z + \\frac{1}{2}z^2$\n-   三阶龙格-库塔法 (RK3, $p=3$): $R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$\n-   四阶龙格-库塔法 (RK4, $p=4$): $R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 + \\frac{1}{24}z^4$\n\n第四，我们确定数值格式的稳定性。对于给定的时间步长 $\\Delta t$，每个特征值 $\\lambda_j$ 都被缩放为 $z_j = \\Delta t \\lambda_j$。当且仅当所有这些缩放后的特征值 $z_j$ 都位于所选积分器的绝对稳定域 $\\mathcal{S}$ 内时，该数值方法才是稳定的。稳定域定义为 $\\mathcal{S} = \\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$。因此，需要验证的稳定性条件是：\n$$\n\\max_{j \\in \\{0, \\dots, N-1\\}} |R(z_j)| \\leq 1\n$$\n其中允许取等号。此检查必须对所有 $N$ 个特征值执行。\n\n对于每个测试用例，程序将计算 $z_j$ 值的数组，为每个元素评估 $|R(z_j)|$，并检查所有得到的模是否小于或等于 $1$。如果此条件成立，则配置是稳定的（True）；否则，它是不稳定的（False）。然后将所有测试用例的布尔结果汇总到一个列表中以供输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stability analysis problem for a semi-discretized 1D advection-diffusion equation.\n    \"\"\"\n    \n    # Define the stability functions for the explicit integrators.\n    def r_fe(z):\n        \"\"\"Stability function for Forward Euler.\"\"\"\n        return 1 + z\n\n    def r_rk2(z):\n        \"\"\"Stability function for 2nd-order Runge-Kutta.\"\"\"\n        return 1 + z + 0.5 * z**2\n\n    def r_rk3(z):\n        \"\"\"Stability function for 3rd-order Runge-Kutta.\"\"\"\n        return 1 + z + 0.5 * z**2 + (1/6) * z**3\n\n    def r_rk4(z):\n        \"\"\"Stability function for 4th-order Runge-Kutta.\"\"\"\n        return 1 + z + 0.5 * z**2 + (1/6) * z**3 + (1/24) * z**4\n    \n    integrator_map = {\n        'FE': r_fe,\n        'RK2': r_rk2,\n        'RK3': r_rk3,\n        'RK4': r_rk4,\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (diffusion, Forward Euler, expected stable)\n        ('FE', 1.0, 100, 0.0, 1e-3, 0.02),\n        # Test 2 (diffusion, Forward Euler, boundary case)\n        ('FE', 1.0, 100, 0.0, 1e-3, 0.05),\n        # Test 3 (advection-diffusion, Forward Euler, expected unstable)\n        ('FE', 1.0, 100, 100.0, 1e-3, 1e-4),\n        # Test 4 (advection, RK4, expected stable)\n        ('RK4', 1.0, 100, 100.0, 0.0, 2e-4),\n        # Test 5 (diffusion, RK2, expected unstable)\n        ('RK2', 1.0, 100, 0.0, 1e-3, 0.075),\n        # Test 6 (advection-diffusion, RK3, expected stable)\n        ('RK3', 1.0, 100, 50.0, 1e-3, 1e-4),\n    ]\n\n    results = []\n    for case in test_cases:\n        integrator_key, L, N, a, nu, dt = case\n        \n        # Calculate grid spacing\n        h = L / N\n        \n        # Create array of indices j\n        j = np.arange(N)\n        \n        # Calculate theta_j values\n        theta = 2 * np.pi * j / N\n        \n        # Compute the spectrum of eigenvalues (lambda_j)\n        # Using 1j for the imaginary unit.\n        lambda_j = -a * 1j * (np.sin(theta) / h) + nu * ((2 * np.cos(theta) - 2) / h**2)\n        \n        # Scale eigenvalues by the time step to get z_j\n        z_j = dt * lambda_j\n        \n        # Get the appropriate stability function\n        R = integrator_map[integrator_key]\n        \n        # Evaluate the stability function for all z_j\n        magnitudes = np.abs(R(z_j))\n        \n        # Check if all magnitudes are less than or equal to 1.0\n        # A small tolerance is used for robustness against floating-point inaccuracies.\n        is_stable = np.all(magnitudes = 1.0 + 1e-12)\n        \n        results.append(is_stable)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The str(bool) conversion will produce 'True'/'False' as required.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在学会检验稳定性的基础上，我们进入一个更高级也更实际的问题：最大允许时间步长 $h_{\\max}$ 是多少？本练习聚焦于广泛使用的四阶龙格-库塔（RK4）方法。你需要首先推导出其稳定性函数，然后实现一个数值算法来描绘其稳定性边界 $|R(z)|=1$。通过理解稳定性域的几何形状，你将能够为任意给定的系统特征值确定精确的时间步长限制，这是优化模拟效率的一项关键技能。",
            "id": "3996033",
            "problem": "考虑线性测试方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$，以及一个由其稳定性函数 $R(z)$ 表征的单步显式积分器，其中 $z = h \\lambda$ 且 $h > 0$ 是时间步长。绝对稳定域定义为 $\\mathcal{S} = \\{ z \\in \\mathbb{C} : |R(z)| \\leq 1 \\}$。在航空航天计算流体力学 (CFD) 中，时间积分格式常被应用于半离散系统，其特征值通过此稳定域决定了允许的时间步长。\n\n从应用于线性测试方程的单步方法的稳定性函数定义出发，推导经典四阶龙格-库塔 (RK4) 方法的稳定性函数 $R(z)$。使用该函数，您必须实现一个程序，该程序：\n1. 通过从原点以在 $[0, 2\\pi)$ 内均匀分布的角度 $\\theta$ 采样射线 $z = r e^{i \\theta}$，计算 RK4 方法由 $|R(z)| = 1$ 定义的边界曲线，并对每个 $\\theta$ 数值确定满足 $|R(r(\\theta) e^{i \\theta})| = 1$ 的最小正半径 $r(\\theta)$。角度必须以弧度为单位处理。\n2. 确定边界曲线与负实轴的交点，表示为一个实数 $x^\\star$，满足 $|R(x^\\star)| = 1$ 且 $x^\\star \\in \\mathbb{R}$ 且 $x^\\star  0$。\n3. 给定一个有限特征值集合 $\\{\\lambda_j\\}_{j=1}^m \\subset \\mathbb{C}$，计算最大允许时间步长 $h_{\\max}$，使得对所有 $j$ 都有 $h_{\\max} \\lambda_j \\in \\mathcal{S}$，即 $\\max_j |R(h_{\\max} \\lambda_j)| \\leq 1$。\n\n本问题中所有量均为无量纲，所有角度必须以弧度处理。\n\n您的实现必须采用稳健的数值区间法和二分法来定位单变量标量函数的根。您必须通过使用能完全覆盖 RK4 稳定域并能可靠终止的适当搜索区间来确保科学真实性。\n\n测试套件：\n- 情况 1 (负实轴上的边界交点)：计算 $x^\\star$，即满足 $|R(x^\\star)| = 1$ 的绝对值最大的负实数。\n- 情况 2 (实特征值，缩放行为)：对于 $\\lambda_1 = -1$ 和 $\\lambda_2 = -10$，计算 $h_{\\max}$，使得对于 $j=1,2$ 均有 $h_{\\max}\\lambda_j \\in \\mathcal{S}$。\n- 情况 3 (复特征值，方向边界)：对于 $\\lambda_3 = -2 + 3 i$，计算 $h_{\\max}$，使得 $h_{\\max}\\lambda_3 \\in \\mathcal{S}$。\n\n答案规格与输出格式：\n- 对于每种情况，答案必须是一个浮点数。\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表 (例如，“[result1,result2,result3]”)。\n- 三个输出必须按 $[x^\\star, \\text{情况 2 的 } h_{\\max}, \\text{情况 3 的 } h_{\\max}]$ 的顺序排列。\n- 每个浮点数必须四舍五入到六位小数。",
            "solution": "该问题要求推导经典四阶龙格-库塔 (RK4) 方法的稳定性函数，并用它来确定给定特征值谱的稳定性极限。该过程包括三个主要部分：推导稳定性函数 $R(z)$，找到负实轴上的稳定性边界，以及为特征值集合计算最大稳定时间步长 $h_{\\max}$。\n\n### 步骤 1：RK4 稳定性函数的推导\n\n当数值单步法应用于线性测试方程 $y'(t) = \\lambda y(t)$ 时，其稳定性函数 $R(z)$ 由关系式 $y_{n+1} = R(z) y_n$ 定义，其中 $z = h \\lambda$，$h$ 为时间步长。\n\n经典四阶龙格-库塔方法由下式给出：\n$$y_{n+1} = y_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)$$\n其中各阶 $k_i$ 计算如下：\n\\begin{align*}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1) \\\\\nk_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2) \\\\\nk_4 = f(t_n + h, y_n + h k_3)\n\\end{align*}\n对于线性测试方程，$f(t, y) = \\lambda y$。将此代入各阶的计算中可得：\n\\begin{align*}\nk_1 = \\lambda y_n \\\\\nk_2 = \\lambda \\left(y_n + \\frac{h}{2}k_1\\right) = \\lambda y_n \\left(1 + \\frac{h\\lambda}{2}\\right) \\\\\nk_3 = \\lambda \\left(y_n + \\frac{h}{2}k_2\\right) = \\lambda y_n \\left(1 + \\frac{h\\lambda}{2} + \\frac{(h\\lambda)^2}{4}\\right) \\\\\nk_4 = \\lambda \\left(y_n + h k_3\\right) = \\lambda y_n \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{4}\\right)\n\\end{align*}\n令 $z = h\\lambda$。各阶可以用 $z$ 改写为：\n\\begin{align*}\nk_1 = \\lambda y_n \\\\\nk_2 = \\lambda y_n \\left(1 + \\frac{z}{2}\\right) \\\\\nk_3 = \\lambda y_n \\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) \\\\\nk_4 = \\lambda y_n \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\n\\end{align*}\n现在，我们将这些表达式代回到 $y_{n+1}$ 的更新公式中：\n$$y_{n+1} = y_n + \\frac{h}{6} \\left[\\lambda y_n + 2\\lambda y_n \\left(1 + \\frac{z}{2}\\right) + 2\\lambda y_n \\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\lambda y_n \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\\right]$$\n提出公因子 $y_n$ 得到关系式 $y_{n+1} = R(z) y_n$：\n$$R(z) = \\frac{y_{n+1}}{y_n} = 1 + \\frac{z}{6} \\left[1 + 2\\left(1 + \\frac{z}{2}\\right) + 2\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\\right]$$\n对括号内的项求和：\n$$R(z) = 1 + \\frac{z}{6} \\left[ (1+2+2+1) + z(1+1+1) + z^2(\\frac{1}{2}+\\frac{1}{2}) + z^3(\\frac{1}{4}) \\right]$$\n$$R(z) = 1 + \\frac{z}{6} \\left(6 + 3z + z^2 + \\frac{z^3}{4}\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$$\n这可以紧凑地写为 $e^z$ 的四阶泰勒级数展开：\n$$R(z) = \\sum_{k=0}^{4} \\frac{z^k}{k!}$$\n绝对稳定域为 $\\mathcal{S} = \\{ z \\in \\mathbb{C} : |R(z)| \\leq 1 \\}$。该域的边界由曲线 $|R(z)| = 1$ 给出。\n\n### 步骤 2：算法方法\n\n该问题要求使用此稳定性函数解决三个相关的任务。一个核心组成部分是数值求根算法。我们将实现二分法来寻找函数 $f(x)$ 在区间 $[a, b]$ 内的根，前提是 $f(a)$ 和 $f(b)$ 的符号相反。\n\n**第 1 部分：负实轴上的边界交点 ($x^\\star$)**\n我们必须找到绝对值最大的负实数 $x^\\star  0$，使得 $|R(x^\\star)|=1$。对于 $z=x \\in \\mathbb{R}$，$R(x)$ 是实数。条件是 $R(x) = 1$ 或 $R(x) = -1$。RK4 稳定性区间的已知边界点在负实轴上由 $R(x)=-1$ 给出。因此，我们必须找到多项式方程 $2 + x + \\frac{x^2}{2} + \\frac{x^3}{6} + \\frac{x^4}{24} = 0$ 的负实根。数值分析表明，该根约等于 $-2.785$。我们可以通过在区间 $[-3, -2.5]$ 内使用二分法来数值确定这个根，即 $x^\\star$。\n\n**第 2 部分：最大允许时间步长 ($h_{\\max}$)**\n给定一个特征值集合 $\\{\\lambda_j\\}$，如果对所有 $j$ 都有 $h\\lambda_j \\in \\mathcal{S}$，则时间步长 $h$ 是稳定的。这等价于对所有 $j$ 都有 $|R(h\\lambda_j)| \\leq 1$。我们寻求满足此条件的最大 $h$，记为 $h_{\\max}$。\n对于每个特征值 $\\lambda_j = |\\lambda_j|e^{i\\theta_j}$，该条件可以写为 $h|\\lambda_j| \\leq r(\\theta_j)$，其中 $r(\\theta_j)$ 是在角度 $\\theta_j$ 处稳定性边界的半径。该半径是方程 $|R(re^{i\\theta_j})|=1$ 的最小正根。\n这为每个特征值给出了对 $h$ 的约束：$h \\leq \\frac{r(\\theta_j)}{|\\lambda_j|}$。为了同时满足所有特征值的条件，$h$ 必须小于或等于这些单个限制的最小值：\n$$h_{\\max} = \\min_{j} \\frac{r(\\theta_j)}{|\\lambda_j|}$$\n为了找到给定 $\\theta_j$ 的 $r(\\theta_j)$，我们求解方程 $g(r) = |R(re^{i\\theta_j})|-1 = 0$ 以获得 $r>0$。对于对应于左半平面 ($\\text{Re}(\\lambda_j)  0$) 中特征值的任何 $\\theta_j$，对于小的 $r>0$，$g(r)$ 将为负，对于大的 $r$，$g(r)$ 将为正。这使得可以使用二分法找到 $r(\\theta_j)$。\n\n**应用于测试案例：**\n\n**情况 1：** 我们寻求 $x^\\star$。\n如上所述，这需要找到 $2 + x + \\frac{x^2}{2} + \\frac{x^3}{6} + \\frac{x^4}{24} = 0$ 在区间 $[-3, -2.5]$ 内的根。\n\n**情况 2：** $\\lambda_1 = -1$，$\\lambda_2 = -10$。\n两个特征值都在负实轴上 ($\\theta = \\pi$)。稳定性边界的半径是 $r(\\pi) = |x^\\star|$。\n各个时间步长的限制是：\n$h_1 = \\frac{r(\\pi)}{|\\lambda_1|} = \\frac{|x^\\star|}{1} = |x^\\star|$\n$h_2 = \\frac{r(\\pi)}{|\\lambda_2|} = \\frac{|x^\\star|}{10}$\n最大允许时间步长是 $h_{\\max} = \\min(h_1, h_2) = \\frac{|x^\\star|}{10}$。\n\n**情况 3：** $\\lambda_3 = -2 + 3i$。\n我们首先计算 $\\lambda_3$ 的极坐标表示：\n$|\\lambda_3| = \\sqrt{(-2)^2 + 3^2} = \\sqrt{13}$\n$\\theta_3 = \\text{atan2}(3, -2)$\n接下来，我们通过使用二分法对 $r$ 数值求解 $|R(re^{i\\theta_3})| - 1 = 0$ 来找到稳定性半径 $r(\\theta_3)$。一个合适的 $r$ 搜索区间是 $[0, 5]$，因为对于大的 $r$，$|R(z)| \\approx |z|^4/24$ 会快速增长。\n最大允许时间步长则为 $h_{\\max} = \\frac{r(\\theta_3)}{|\\lambda_3|}$。\n\n实现将精确地遵循这一逻辑，使用一个二分法求解器和推导出的稳定性函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three test cases related to the stability of the RK4 integrator.\n    \"\"\"\n\n    # --- Numerical Utilities ---\n\n    def bisection(f, a, b, tol=1e-12, max_iter=100):\n        \"\"\"\n        Finds a root of function f in the interval [a, b] using the bisection method.\n        Assumes f(a) and f(b) have opposite signs.\n        \"\"\"\n        fa = f(a)\n        if fa == 0:\n            return a\n        fb = f(b)\n        if fb == 0:\n            return b\n        \n        if np.sign(fa) == np.sign(fb):\n            # Fallback for very narrow intervals where signs might be the same due to precision\n            if abs(fa)  abs(fb): return a\n            if abs(fb)  abs(fa): return b\n            raise ValueError(\"Function has the same sign at the interval endpoints.\")\n\n        for _ in range(max_iter):\n            c = a + (b - a) / 2\n            fc = f(c)\n            if abs(b - a) / 2  tol or fc == 0:\n                return c\n            if np.sign(fc) == np.sign(fa):\n                a = c\n                fa = fc\n            else:\n                b = c\n        return (a + b) / 2\n\n    # --- RK4 Stability Function ---\n\n    def R_rk4(z: complex) -> complex:\n        \"\"\"\n        Computes the stability function for the classical RK4 method.\n        R(z) = 1 + z + z^2/2! + z^3/3! + z^4/4!\n        \"\"\"\n        z2 = z * z\n        z3 = z2 * z\n        z4 = z3 * z\n        return 1 + z + z2 / 2.0 + z3 / 6.0 + z4 / 24.0\n\n    results = []\n\n    # --- Case 1: Boundary intersection on the negative real axis ---\n    \n    # We need to find the root of R(x) = -1 for x  0.\n    # This is equivalent to finding the root of f(x) = R(x) + 1 = 0.\n    def neg_real_boundary_func(x: float) -> float:\n        return R_rk4(x) + 1.0\n\n    # The interval [-3.0, -2.5] brackets the root.\n    # f(-3.0) = 0.625\n    # f(-2.5) = 0.0026...\n    # The root is close to -2.785. A better interval is [-3.0, -2.7].\n    x_star = bisection(neg_real_boundary_func, -3.0, -2.7)\n    results.append(x_star)\n\n    # --- Case 2: Real eigenvalues, scaling behavior ---\n\n    # For eigenvalues lambda_j, h_max = min_j( r(theta_j) / |lambda_j| ).\n    # Lambda = -1 and -10 are on the negative real axis (theta = pi).\n    # The boundary radius r(pi) is |x_star|.\n    # h_max = min( |x_star|/|-1|, |x_star|/|-10| ) = |x_star|/10.\n    \n    hmax_case2 = abs(x_star) / 10.0\n    results.append(hmax_case2)\n\n    # --- Case 3: Complex eigenvalue, directional boundary ---\n\n    # For lambda = -2 + 3i, find h_max.\n    lambda3 = -2.0 + 3.0j\n    abs_lambda3 = np.abs(lambda3)\n    theta3 = np.angle(lambda3)\n\n    # We need to find the radius r(theta3) of the stability boundary.\n    # This is done by solving |R(r * exp(i*theta))| - 1 = 0 for r.\n    def boundary_radius_func(r: float) -> float:\n        z = r * np.exp(1j * theta3)\n        return np.abs(R_rk4(z)) - 1.0\n\n    # For r=0, func=-0. For large r, func>0. The search interval [0, 5] is safe.\n    # Using a small positive lower bound to avoid r=0 being found.\n    r_theta3 = bisection(boundary_radius_func, 1e-9, 5.0)\n    \n    hmax_case3 = r_theta3 / abs_lambda3\n    results.append(hmax_case3)\n\n    # --- Final Output Formatting ---\n    \n    output_str = f\"[{results[0]:.6f},{results[1]:.6f},{results[2]:.6f}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的练习将特征值这一抽象概念与具体的物理问题联系起来。我们已经了解了如何使用特征值来检查稳定性和计算时间步长限制，但这些特征值从何而来？本练习将引导你从第一性原理出发：从二维热方程开始，你将进行空间离散化，并使用离散傅里叶分析来推导所得算子的谱。这将使你能够确定谱半径，并最终推导出最大稳定时间步长的符号表达式，从而将稳定性限制与物理参数（$\\kappa$）和网格参数（$h$）直接联系起来。",
            "id": "3996110",
            "problem": "考虑计算流体动力学（CFD, Computational Fluid Dynamics）中一个方形周期性域上的二维（$2$D）热方程，该方程通过线方法进行离散化。设热扩散系数为 $\\kappa$（单位为 $\\mathrm{m^2/s}$）。在一个两个方向上间距均为 $h$ 的均匀笛卡尔网格上，使用带有周期性边界条件的标准二阶五点有限差分格式来近似拉普拉斯算子 $\\nabla^2$，从而得到一个线性自治半离散系统 $u_{t} = A u$，其中 $A = \\kappa L_{h}$ 且 $L_{h}$ 是离散拉普拉斯矩阵。\n\n仅使用：\n- 周期性均匀网格上离散傅里叶模态的定义，\n- 应用于 $y'=\\lambda y$ 的单步法的绝对稳定性要求 $\\max_{\\lambda \\in \\sigma(A)} |R(\\Delta t\\,\\lambda)| \\le 1$ 这一事实，其中 $R$ 是方法的稳定性函数，$\\sigma(A)$ 是 $A$ 的谱，\n- 以及经典的四阶显式龙格-库塔方法（RK$4$）作为时间积分器，\n\n从第一性原理推导：\n$1)$ 算子 $A=\\kappa L_{h}$ 的谱半径 $\\rho(A)$，以及\n$2)$ 对于 RK$4$，使得 $\\max_{z \\in \\Delta t\\,\\sigma(A)} |R(z)| \\le 1$ 成立的最大稳定显式时间步长 $\\Delta t_{\\max}$。\n\n以 $h$ 和 $\\kappa$ 的单一符号表达式形式报告您的最终答案，其中使用一个四舍五入到四位有效数字的数值常数。最终时间步长以秒为单位表示。",
            "solution": "问题陈述已经过验证，被认为是合理的、适定的且有科学依据的。对于给定的数值格式，最大稳定时间步长的推导从第一性原理出发。\n\n半离散系统由 $u_t = A u$ 给出，其中 $A = \\kappa L_h$。这里，$L_h$ 是在间距为 $h$ 的均匀笛卡尔网格上，拉普拉斯算子 $\\nabla^2$ 的二阶五点有限差分格式的矩阵表示。对于定义在网格点 $(x_i, y_j)$ 上的网格函数 $u_{i,j}$，离散拉普拉斯算子的作用是：\n$$ (L_h u)_{i,j} = \\frac{u_{i+1, j} + u_{i-1, j} + u_{i, j+1} + u_{i, j-1} - 4 u_{i, j}}{h^2} $$\n\n**$1)$ $A$的谱和谱半径的推导**\n\n为了找到算子 $A$ 的特征值，我们分析其在离散傅里叶模态上的作用，这些模态是周期性域上线性常系数算子的特征函数。一个通用的二维离散傅里叶模态由下式给出：\n$$ u_{i,j}^{(k_x, k_y)} = \\exp(I(k_x x_i + k_y y_j)) = \\exp(I(k_x i h + k_y j h)) $$\n其中 $I = \\sqrt{-1}$ 是虚数单位，$k_x$ 和 $k_y$ 分别是 $x$ 和 $y$ 方向上的波数。\n\n将算子 $L_h$ 应用于此模态，得到：\n$$ (L_h u^{(k_x, k_y)})_{i,j} = \\frac{1}{h^2} \\left[ \\exp(I k_x h)u_{i,j}^{(k_x, k_y)} + \\exp(-I k_x h)u_{i,j}^{(k_x, k_y)} + \\exp(I k_y h)u_{i,j}^{(k_x, k_y)} + \\exp(-I k_y h)u_{i,j}^{(k_x, k_y)} - 4 u_{i,j}^{(k_x, k_y)} \\right] $$\n提出项 $u_{i,j}^{(k_x, k_y)}$ 并使用恒等式 $2\\cos(\\theta) = \\exp(I\\theta) + \\exp(-I\\theta)$，我们求出 $L_h$ 的特征值：\n$$ \\lambda_{L_h}(k_x, k_y) = \\frac{1}{h^2} \\left[ 2\\cos(k_x h) + 2\\cos(k_y h) - 4 \\right] = \\frac{2}{h^2} \\left[ \\cos(k_x h) + \\cos(k_y h) - 2 \\right] $$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们可以将其重写为：\n$$ \\lambda_{L_h}(k_x, k_y) = -\\frac{4}{h^2} \\left[ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) \\right] $$\n算子 $A = \\kappa L_h$ 的特征值是 $\\lambda_A = \\kappa \\lambda_{L_h}$：\n$$ \\lambda_A(k_x, k_y) = -\\frac{4\\kappa}{h^2} \\left[ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) \\right] $$\n这些特征值是实数且非正的，这是扩散算子的一个特征。\n\n谱半径 $\\rho(A)$ 是谱 $\\sigma(A)$ 中特征值绝对值的最大值。\n$$ \\rho(A) = \\max_{k_x, k_y} |\\lambda_A(k_x, k_y)| = \\max_{k_x, k_y} \\left| -\\frac{4\\kappa}{h^2} \\left[ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) \\right] \\right| $$\n当正弦项最大化时，达到最大值。当 $\\theta = \\pm\\pi$ 时，项 $\\sin^2(\\theta/2)$ 最大化为 $1$。对于该网格，无量纲波数 $k_x h$ 和 $k_y h$ 的范围在 $[-\\pi, \\pi]$ 内。因此，在最高可分辨频率 $k_x h = \\pi$ 和 $k_y h = \\pi$ 处找到最大值。\n$$ \\rho(A) = \\frac{4\\kappa}{h^2} \\left[ \\sin^2\\left(\\frac{\\pi}{2}\\right) + \\sin^2\\left(\\frac{\\pi}{2}\\right) \\right] = \\frac{4\\kappa}{h^2} [1 + 1] = \\frac{8\\kappa}{h^2} $$\n\n**$2)$ 最大稳定时间步长 $\\Delta t_{\\max}$ 的推导**\n\n单步积分器的稳定性由其稳定性函数 $R(z)$ 决定。为使方法稳定，对于系统矩阵的所有特征值 $\\lambda$，量 $z = \\Delta t \\lambda$ 必须位于该方法的绝对稳定域内。这表示为对于所有 $\\lambda \\in \\sigma(A)$，都有 $|R(\\Delta t \\lambda)| \\le 1$。\n\n对于经典的四阶显式龙格-库塔方法（RK$4$），稳定性函数是指数函数的四阶泰勒多项式：\n$$ R(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n我们的算子 $A$ 的特征值均为实数且为负。因此，我们只需考虑 RK$4$ 在负实轴上的绝对稳定区间。该区间的形式为 $[-S, 0]$，其中 $S>0$ 是稳定边界。这个边界点 $z=-S$ 是通过求解方程 $R(-S)=-1$ 找到的。\n$$ 1 - S + \\frac{S^2}{2} - \\frac{S^3}{6} + \\frac{S^4}{24} = -1 \\implies \\frac{S^4}{24} - \\frac{S^3}{6} + \\frac{S^2}{2} - S + 2 = 0 $$\n解这个四次方程的正实根，得到 $S \\approx 2.7852915 \\ldots$。\n\n稳定性条件要求对于所有特征值 $\\lambda_A \\in \\sigma(A)$，我们必须有 $\\Delta t \\lambda_A \\in [-S, 0]$。由于所有 $\\lambda_A$ 都是非正的，这个条件简化为：\n$$ \\Delta t \\lambda_{\\min} \\ge -S $$\n其中 $\\lambda_{\\min}$ 是 A 的最负特征值。这个特征值对应于谱半径：\n$$ \\lambda_{\\min} = - \\rho(A) = -\\frac{8\\kappa}{h^2} $$\n将此代入稳定性不等式：\n$$ \\Delta t \\left(-\\frac{8\\kappa}{h^2}\\right) \\ge -S $$\n乘以 $-1$ 并反转不等号：\n$$ \\Delta t \\frac{8\\kappa}{h^2} \\le S $$\n当这个不等式取等号时，我们得到最大稳定时间步长 $\\Delta t_{\\max}$：\n$$ \\Delta t_{\\max} = \\frac{S h^2}{8\\kappa} $$\n代入 S 的数值并计算常系数：\n$$ \\Delta t_{\\max} = \\frac{2.7852915 \\ldots}{8} \\frac{h^2}{\\kappa} \\approx 0.3481614 \\frac{h^2}{\\kappa} $$\n按要求将数值常数四舍五入到四位有效数字：\n$$ \\Delta t_{\\max} = 0.3482 \\frac{h^2}{\\kappa} $$\n这个表达式的单位是 $(\\mathrm{m}^2) / (\\mathrm{m}^2/\\mathrm{s}) = \\mathrm{s}$，这与时间步长的单位是一致的。",
            "answer": "$$\\boxed{0.3482 \\frac{h^2}{\\kappa}}$$"
        }
    ]
}