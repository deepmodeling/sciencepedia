{
    "hands_on_practices": [
        {
            "introduction": "理论知识通过动手实践才能真正内化。本章提供了一系列精心设计的练习，旨在将隐式时间积分方案的抽象概念转化为具体的技能。我们将从最基础的隐式方法——后向欧拉法——的稳定性分析入手，通过一个经典的分析练习来揭示其处理刚性问题的能力来源。这个练习  不仅是数值分析课程中的一项标准任务，更是理解所有更高级隐式格式行为的基石。",
            "id": "3967285",
            "problem": "考虑标量线性测试方程 $u'(t)=\\lambda u(t)$，该方程源于计算流体力学（CFD）中线性化可压缩流模型的模态分解。通过向后欧拉离散化构建一个隐式单步法，该方法使用在新时间层上计算的右端项来将解从时间 $t^{n}$ 更新到 $t^{n+1}=t^{n}+\\Delta t$。对于这个线性测试问题，引入无量纲复数 $z=\\lambda\\,\\Delta t$，并通过 $u^{n+1}=G(z)\\,u^{n}$ 定义放大因子 $G(z)$。该方法的绝对稳定区域 $\\mathcal{A}$ 是所有满足 $|G(z)|\\leq 1$ 的 $z\\in\\mathbb{C}$ 的集合。从向后欧拉法和绝对稳定性的基本定义出发，推导 $G(z)$ 并将 $\\mathcal{A}$ 刻画为复平面的一个子集。然后，用一个实参数 $\\theta$ 的单个解析表达式 $z(\\theta)$ 来参数化边界 $\\partial\\mathcal{A}$，当 $\\theta$ 在一个长度为 $2\\pi$ 的区间上变化时，该表达式能完整地描绘出整个边界。你的最终答案必须是 $z(\\theta)$ 的闭式表达式，无需四舍五入，也无需单位。",
            "solution": "我们发现问题陈述是有效的，因为它代表了常微分方程数值分析中的一个标准的、适定的问题，特别地，它涉及向后欧拉法的稳定性。该问题有科学依据、内容自洽且客观。我们着手进行求解。\n\n问题要求推导应用于标量线性测试方程 $u'(t) = \\lambda u(t)$ 的向后欧拉法的放大因子 $G(z)$，刻画绝对稳定区域 $\\mathcal{A}$，并对其边界 $\\partial\\mathcal{A}$ 进行参数化。\n\n首先，我们应用向后欧拉法。这种隐式方法使用一阶有限差分来近似未来时间层 $t^{n+1}$ 处的导数，并在同一未来时间计算常微分方程的右端项。离散化后的方程是：\n$$\n\\frac{u^{n+1} - u^{n}}{\\Delta t} = \\lambda u^{n+1}\n$$\n这里，$u^{n}$ 是在时间 $t^{n}$ 处的数值解，$u^{n+1}$ 是在时间 $t^{n+1} = t^{n}+\\Delta t$ 处的解，而 $\\lambda$ 是一个复常数。我们必须重新整理这个方程，以 $u^{n}$ 来表示 $u^{n+1}$。\n$$\nu^{n+1} - u^{n} = \\lambda \\Delta t u^{n+1}\n$$\n$$\nu^{n+1} - (\\lambda \\Delta t) u^{n+1} = u^{n}\n$$\n在左侧提取公因子 $u^{n+1}$ 可得：\n$$\nu^{n+1} (1 - \\lambda \\Delta t) = u^{n}\n$$\n解出 $u^{n+1}$ 得到更新规则：\n$$\nu^{n+1} = \\frac{1}{1 - \\lambda \\Delta t} u^{n}\n$$\n问题定义了无量纲复数 $z = \\lambda \\Delta t$。将此定义代入方程，我们得到：\n$$\nu^{n+1} = \\frac{1}{1 - z} u^{n}\n$$\n放大因子 $G(z)$ 由关系式 $u^{n+1} = G(z) u^{n}$ 定义。通过与我们推导出的更新规则直接比较，我们发现向后欧拉法的放大因子为：\n$$\nG(z) = \\frac{1}{1 - z}\n$$\n接下来，我们刻画绝对稳定区域 $\\mathcal{A}$，它被定义为所有满足放大因子的模不大于 $1$ 的 $z \\in \\mathbb{C}$ 的集合：\n$$\n\\mathcal{A} = \\{ z \\in \\mathbb{C} \\mid |G(z)| \\leq 1 \\}\n$$\n代入推导出的 $G(z)$ 表达式：\n$$\n\\left| \\frac{1}{1 - z} \\right| \\leq 1\n$$\n利用对于复数 $a$ 和 $b$ 有 $|a/b| = |a|/|b|$ 的性质，我们可以写出：\n$$\n\\frac{|1|}{|1-z|} \\leq 1\n$$\n由于 $|1| = 1$，稳定性条件简化为：\n$$\n1 \\leq |1 - z|\n$$\n为了从几何上解释这个不等式，我们将复数 $z$ 用笛卡尔形式表示为 $z = x + iy$，其中 $x, y \\in \\mathbb{R}$。复数 $1-z$ 则是 $1 - (x + iy) = (1-x) - iy$。它的模是：\n$$\n|1 - z| = \\sqrt{(1-x)^2 + (-y)^2} = \\sqrt{(x-1)^2 + y^2}\n$$\n稳定性条件 $1 \\leq |1 - z|$ 变为 $1 \\leq \\sqrt{(x-1)^2 + y^2}$。由于两边都是非负的，我们可以对它们进行平方而不改变不等式关系：\n$$\n1^2 \\leq (x-1)^2 + y^2\n$$\n$$\n1 \\leq (x-1)^2 + y^2\n$$\n这个不等式描述了复平面上所有与点 $(1,0)$ 的距离的平方大于或等于 $1$ 的点 $(x,y)$ 的集合。这对应于以 $(1,0)$ 为圆心、半径为 $1$ 的圆上及其外部的区域。因此，稳定区域 $\\mathcal{A}$ 是由 $|z-1| \\ge 1$ 定义的开圆盘的外部。\n\n最后，题目要求我们对稳定区域的边界 $\\partial\\mathcal{A}$ 进行参数化。边界是稳定性条件中等号成立的点集：\n$$\n|G(z)| = 1 \\implies |1-z| = 1\n$$\n这个方程 $|z-1|=1$ 描述了复平面上一个以 $z_c = 1 + 0i = 1$ 为圆心、半径 $R=1$ 的圆。一个以 $z_c$ 为圆心、半径为 $R$ 的圆可以使用欧拉公式参数化为 $z(\\theta) = z_c + R e^{i\\theta}$，其中 $\\theta$ 是一个实参数。当 $\\theta$ 在一个长度为 $2\\pi$ 的区间（例如，从 $0$ 到 $2\\pi$）上变化时，该表达式会遍历圆周一次。\n\n对于我们的具体情况，其中 $z_c = 1$ 和 $R=1$，边界 $\\partial\\mathcal{A}$ 的参数化是：\n$$\nz(\\theta) = 1 + 1 \\cdot e^{i\\theta}\n$$\n按照正式数学排版中通常要求的，使用 `exp` 记法来表示指数函数，可得到最终表达式：\n$$\nz(\\theta) = 1 + \\exp(i\\theta)\n$$\n这就是参数化整个稳定区域边界所需的闭式解析表达式。",
            "answer": "$$\n\\boxed{1 + \\exp(i\\theta)}\n$$"
        },
        {
            "introduction": "在理解了后向欧拉法的理论稳定性后，下一个关键步骤是观察其在实际计算中的表现。本练习将通过一个具体的数值算例，展示稳定性与精度之间的重要权衡。我们将使用一个对于显式方法而言时间步长过大的设置来求解一个刚性常微分方程，通过这个练习 ，您将亲身体会到隐式方法在保证计算稳定方面的强大能力，同时也会认识到获得稳定解并不总意味着获得了高精度的解。",
            "id": "3885112",
            "problem": "考虑一个单箱环境系统中示踪剂浓度的无量纲线性衰减模型，其理想化的常微分方程（ODE）为 $y'(t)=\\lambda\\,y(t)$，初始条件为 $y(0)=y_{0}$。该常微分方程源于质量守恒定律，其中包含一个与 $y(t)$ 成正比的线性化汇项，$\\lambda  0$ 代表一个恒定的衰减率。设 $\\lambda=-1000$，$y_{0}=1$，时间步长为 $\\Delta t=0.1$。使用从ODE在一个时间步长上的积分形式推导出的隐式时间积分方案，应用 backward Euler 方法计算单步数值近似值 $y_{1}\\approx y(\\Delta t)$。\n\n另外，通过分离变量法推导该ODE的精确解 $y(t)$，并在 $t=\\Delta t$ 处求值。将绝对单步误差定义为 $E=\\left|y_{1}-y(\\Delta t)\\right|$。将 $E$ 作为一个数字报告，四舍五入到四位有效数字。将答案表示为无量纲量。此计算的目的是将 backward Euler 的结果与精确解进行比较，以说明在环境和地球系统建模中，对于刚性问题，绝对稳定性（A-stability）与准确性之间的权衡。",
            "solution": "首先验证问题，以确保其具有科学依据、良定性和客观性。\n\n### 步骤1：提取已知条件\n- 常微分方程（ODE）：$y'(t)=\\lambda\\,y(t)$\n- 初始条件：$y(0)=y_{0}$\n- 衰减率常数：$\\lambda=-1000$\n- 初始值：$y_{0}=1$\n- 时间步长：$\\Delta t=0.1$\n- 数值方法：Backward Euler\n- 待计算量：单步数值近似值 $y_{1}\\approx y(\\Delta t)$\n- 精确解：待推导的 $y(t)$。\n- 误差定义：绝对单步误差 $E=\\left|y_{1}-y(\\Delta t)\\right|$\n- 最终输出要求：报告 $E$ 并四舍五入至四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题描述了一个标准的一阶线性齐次常微分方程的初值问题（IVP），这是科学和工程中指数衰减过程的基本模型。所提供的参数（$\\lambda=-1000$，$\\Delta t=0.1$）定义了一个数值刚性问题，这是测试和说明像 backward Euler 这样的隐式时间积分方案特性的常见且有意义的场景。该问题是自洽的，提供了所有必要的数据。语言精确且客观。没有科学或事实上的不健全、矛盾或含糊之处。\n\n### 步骤3：结论与行动\n问题有效。将提供完整的解答。\n\n### 使用 Backward Euler 方法推导数值解\n给定的ODE为 $y'(t) = \\lambda y(t)$。Backward Euler 方法是一种求解ODE的隐式单步数值方法。对于形如 $y'(t) = f(t,y)$ 的ODE，将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 的通用公式为：\n$$y_{n+1} = y_n + \\Delta t \\, f(t_{n+1}, y_{n+1})$$\n在这个问题中，函数 $f(t,y)$ 由 $f(t,y) = \\lambda y(t)$ 给出。将其代入 backward Euler 公式可得：\n$$y_{n+1} = y_n + \\Delta t (\\lambda y_{n+1})$$\n由于这是一种隐式方法，我们必须求解未知数 $y_{n+1}$：\n$$y_{n+1} - \\lambda \\Delta t y_{n+1} = y_n$$\n$$y_{n+1} (1 - \\lambda \\Delta t) = y_n$$\n$$y_{n+1} = \\frac{y_n}{1 - \\lambda \\Delta t}$$\n我们需要计算从初始条件 $y_0$ 在 $t_0=0$ 开始的第一步 $y_1$。令 $n=0$：\n$$y_1 = \\frac{y_0}{1 - \\lambda \\Delta t}$$\n问题提供了值 $y_0=1$，$\\lambda=-1000$ 和 $\\Delta t=0.1$。将这些值代入 $y_1$ 的方程中：\n$$y_1 = \\frac{1}{1 - (-1000)(0.1)} = \\frac{1}{1 - (-100)} = \\frac{1}{1+100} = \\frac{1}{101}$$\n\n### 精确解的推导\nODE $y'(t) = \\lambda y(t)$ 可以写成 $\\frac{dy}{dt} = \\lambda y$。这是一个可分离的微分方程。我们可以分离变量 $y$ 和 $t$：\n$$\\frac{dy}{y} = \\lambda \\, dt$$\n对等式两边进行积分：\n$$\\int \\frac{1}{y} \\, dy = \\int \\lambda \\, dt$$\n$$\\ln|y| = \\lambda t + C$$\n其中 $C$ 是积分常数。为了解出 $y$，我们对两边取指数：\n$$|y| = \\exp(\\lambda t + C) = \\exp(C) \\exp(\\lambda t)$$\n令 $A = \\pm\\exp(C)$，我们得到通解：\n$$y(t) = A \\exp(\\lambda t)$$\n为了找到特解，我们应用初始条件 $y(0)=y_0$：\n$$y(0) = A \\exp(\\lambda \\cdot 0) = A \\exp(0) = A \\cdot 1 = A$$\n因此，积分常数为 $A=y_0$。该初值问题的精确解为：\n$$y(t) = y_0 \\exp(\\lambda t)$$\n代入给定值 $y_0=1$ 和 $\\lambda=-1000$：\n$$y(t) = 1 \\cdot \\exp(-1000t) = \\exp(-1000t)$$\n我们需要在时间 $t=\\Delta t=0.1$ 处评估此精确解：\n$$y(\\Delta t) = y(0.1) = \\exp(-1000 \\cdot 0.1) = \\exp(-100)$$\n\n### 绝对误差的计算\n绝对单步误差 $E$ 定义为 $E = |y_1 - y(\\Delta t)|$。代入我们求得的数值解和精确解：\n$$E = \\left| \\frac{1}{101} - \\exp(-100) \\right|$$\n现在，我们计算数值。\n$y_1 = \\frac{1}{101} \\approx 0.009900990099...$\n$y(\\Delta t) = \\exp(-100)$ 的值是一个极小的正数。使用计算器，$\\exp(-100) \\approx 3.72 \\times 10^{-44}$。\n误差为：\n$$E \\approx |0.009900990099 - 3.72 \\times 10^{-44}|$$\n项 $\\exp(-100)$ 比 $\\frac{1}{101}$ 小许多个数量级，其对误差的贡献对于所要求的精度来说可以忽略不计。因此，误差实际上等于 $y_1$：\n$$E \\approx \\frac{1}{101} \\approx 0.009900990099...$$\n问题要求将结果四舍五入到四位有效数字。\n$E$ 的第一个非零数字是千分位上的 $9$。前四位有效数字是 $9$、$9$、$0$、$0$。第五位有效数字是 $9$。由于 $9 \\ge 5$，我们将第四位有效数字向上取整。\n因此，将 $0.00990099...$ 四舍五入到四位有效数字的结果是 $0.009901$。",
            "answer": "$$\\boxed{0.009901}$$"
        },
        {
            "introduction": "最后，我们将理论与实践相结合，探讨隐式方法在真实计算流体力学（CFD）问题中的应用。这个练习将我们带入一个更复杂的场景：一个高度非线性的Spalart-Allmaras湍流模型方程。通过为这个方程实现后向欧拉更新 ，您将直面在复杂物理模型中求解隐式方程的核心挑战，即必须依赖像牛顿法这样的非线性求解器。这项实践是连接学术理论与工业级CFD代码开发的关键桥梁。",
            "id": "3967232",
            "problem": "考虑Spalart-Allmaras (SA)单方程湍流模型的零维形式，该模型用于输运工作变量涡粘性，定义为 $\\tilde{\\nu}$，单位为 $\\mathrm{m^2/s}$。在雷诺平均纳维-斯托克斯 (RANS) 模拟中，空间均匀设定下的SA方程忽略了对流和扩散，只留下产生和破坏机制。从以产生项和破坏项表示的控制常微分方程出发，$\\tilde{\\nu}$ 的时间演化由下式决定\n$$\n\\frac{d\\tilde{\\nu}}{dt} = P(\\tilde{\\nu}) - D(\\tilde{\\nu}),\n$$\n其中，封闭项如下，使用了标准的SA常数和函数：\n$$\nP(\\tilde{\\nu}) = c_{b1}(1 - f_{t2})\\hat{S}\\tilde{\\nu},\n\\qquad\nD(\\tilde{\\nu}) = c_{w1}f_w\\left(\\frac{\\tilde{\\nu}}{d}\\right)^{2}.\n$$\n辅助量定义如下：\n$$\n\\chi = \\frac{\\tilde{\\nu}}{\\nu}, \n\\qquad\nf_{v1} = \\frac{\\chi^{3}}{\\chi^{3} + c_{v1}^{3}},\n\\qquad\nf_{v2} = 1 - \\frac{\\chi}{1 + \\chi f_{v1}},\n\\qquad\nf_{t2} = c_{t3}\\exp(-c_{t4}\\chi^{2}),\n$$\n$$\n\\nu_{t} = \\tilde{\\nu}f_{v1},\n\\qquad\n\\hat{S} = S + \\frac{\\nu_{t}}{\\kappa^{2}d^{2}}f_{v2},\n$$\n$$\nr = \\frac{\\tilde{\\nu}}{\\hat{S}\\kappa^{2}d^{2}},\n\\qquad\ng = r + c_{w2}(r^{6} - r),\n\\qquad\nf_{w} = g\\left(\\frac{1 + c_{w3}^{6}}{g^{6} + c_{w3}^{6}}\\right)^{1/6}.\n$$\n常数为\n$$\nc_{b1} = 0.1355,\\quad c_{b2} = 0.622,\\quad \\sigma = \\frac{2}{3},\\quad \\kappa = 0.41,\\quad c_{v1} = 7.1,\n$$\n$$\nc_{t3} = 1.2,\\quad c_{t4} = 0.5,\\quad c_{w2} = 0.3,\\quad c_{w3} = 2.0,\n$$\n以及\n$$\nc_{w1} = \\frac{c_{b1}}{\\kappa^{2}} + \\frac{1 + c_{b2}}{\\sigma}.\n$$\n您需要使用后向欧拉方法为上述非线性常微分方程实现一个隐式时间步。设 $\\tilde{\\nu}^{n}$ 为已知的先前值，$\\Delta t$ 为时间步长。未知量 $\\tilde{\\nu}^{n+1}$ 必须满足与上述控制律和封闭项一致的后向欧拉更新。您必须计算与此更新相关的非线性残差及其 $\\ell_{2}$ 范数。在这种零维单方程设定中，$\\ell_{2}$ 范数是标量残差的绝对值。由于运动涡粘性的物理意义，数值求解器必须强制 $\\tilde{\\nu}^{n+1} \\ge 0$。\n\n参数需要使用物理单位：$\\tilde{\\nu}$ 和 $\\nu$ 的单位为 $\\mathrm{m^2/s}$，$S$ 的单位为 $\\mathrm{s^{-1}}$，$d$ 的单位为 $\\mathrm{m}$，$\\Delta t$ 的单位为 $\\mathrm{s}$。以 $\\mathrm{m^2/s}$ 为单位表示每个残差范数，并将其与同样以 $\\mathrm{m^2/s}$ 为单位的给定容差 $\\varepsilon$ 进行比较。对于每个测试用例，报告残差范数是否严格小于指定的容差。每个测试用例的答案必须是布尔值。\n\n实现一个适合对给定常微分方程进行后向欧拉离散化的鲁棒非线性求解器，使用基于导数的迭代方法（如牛顿法）并配合适当的全局化策略（例如，回溯线搜索），以确保 $\\tilde{\\nu}^{n+1}$ 的收敛性和非负性。\n\n使用以下测试套件，它提供了四个覆盖典型、刚性、近边界和极端条件的参数集：\n1. 用例 A (正常情况): $\\nu = 1.5\\times 10^{-5}\\,\\mathrm{m^{2}/s},\\; S = 500\\,\\mathrm{s^{-1}},\\; d = 10^{-3}\\,\\mathrm{m},\\; \\Delta t = 10^{-4}\\,\\mathrm{s},\\; \\tilde{\\nu}^{n} = 5\\times 10^{-6}\\,\\mathrm{m^{2}/s},\\; \\varepsilon = 10^{-10}\\,\\mathrm{m^{2}/s}.$\n2. 用例 B (更刚性的动力学): $\\nu = 1.5\\times 10^{-5}\\,\\mathrm{m^{2}/s},\\; S = 5000\\,\\mathrm{s^{-1}},\\; d = 5\\times 10^{-4}\\,\\mathrm{m},\\; \\Delta t = 5\\times 10^{-3}\\,\\mathrm{s},\\; \\tilde{\\nu}^{n} = 2\\times 10^{-5}\\,\\mathrm{m^{2}/s},\\; \\varepsilon = 10^{-9}\\,\\mathrm{m^{2}/s}.$\n3. 用例 C (近壁面小涡粘性): $\\nu = 1.5\\times 10^{-5}\\,\\mathrm{m^{2}/s},\\; S = 200\\,\\mathrm{s^{-1}},\\; d = 10^{-4}\\,\\mathrm{m},\\; \\Delta t = 10^{-3}\\,\\mathrm{s},\\; \\tilde{\\nu}^{n} = 10^{-12}\\,\\mathrm{m^{2}/s},\\; \\varepsilon = 10^{-12}\\,\\mathrm{m^{2}/s}.$\n4. 用例 D (极端参数): $\\nu = 1.5\\times 10^{-5}\\,\\mathrm{m^{2}/s},\\; S = 10^{4}\\,\\mathrm{s^{-1}},\\; d = 10^{-5}\\,\\mathrm{m},\\; \\Delta t = 1\\,\\mathrm{s},\\; \\tilde{\\nu}^{n} = 10^{-4}\\,\\mathrm{m^{2}/s},\\; \\varepsilon = 10^{-20}\\,\\mathrm{m^{2}/s}.$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、按上述测试套件顺序排列的逗号分隔结果列表，例如 $[\\mathrm{result}_{A},\\mathrm{result}_{B},\\mathrm{result}_{C},\\mathrm{result}_{D}]$，其中每个条目为 `True` 或 `False`，表示该用例的残差范数是否严格小于容差。",
            "solution": "用户提供的问题陈述已经过分析和验证。它在科学上是合理的、适定的、客观的且自洽的，没有可识别的缺陷。该问题要求使用后向欧拉方法，为零维Spalart-Allmaras (SA)湍流模型方程实现一个隐式时间步。这是计算流体动力学(CFD)领域中一个标准且定义明确的问题。\n\n输运变量 $\\tilde{\\nu}$ 的控制常微分方程(ODE)为：\n$$\n\\frac{d\\tilde{\\nu}}{dt} = P(\\tilde{\\nu}) - D(\\tilde{\\nu})\n$$\n其中 $P(\\tilde{\\nu})$ 是产生项，$D(\\tilde{\\nu})$ 是破坏项。\n\n应用一阶隐式后向欧拉时间积分格式，我们将该常微分方程离散化为：\n$$\n\\frac{\\tilde{\\nu}^{n+1} - \\tilde{\\nu}^{n}}{\\Delta t} = P(\\tilde{\\nu}^{n+1}) - D(\\tilde{\\nu}^{n+1})\n$$\n此处，$\\tilde{\\nu}^{n}$ 是前一时间步的已知值，$\\tilde{\\nu}^{n+1}$ 是新时间步的未知值，$\\Delta t$ 是时间步长。\n\n为了求解 $\\tilde{\\nu}^{n+1}$，我们构建一个非线性残差函数 $R(\\tilde{\\nu}^{n+1})$，该函数必须等于零。为方便起见，设 $x = \\tilde{\\nu}^{n+1}$。残差为：\n$$\nR(x) = x - \\tilde{\\nu}^{n} - \\Delta t \\left( P(x) - D(x) \\right)\n$$\n我们寻求方程 $R(x) = 0$ 的根。由于产生项 $P(x)$ 和破坏项 $D(x)$ 具有复杂的非线性，需要一种强大的迭代方法。牛顿法是一个合适的选择，因为它对于良好性态的函数具有二次收敛率。\n\n牛顿法迭代由下式给出：\n$$\nx_{k+1} = x_k - \\frac{R(x_k)}{R'(x_k)}\n$$\n其中 $x_k$ 是在第k次迭代时根的估计值，$R'(x_k)$ 是残差函数关于 $x$ 的导数（雅可比矩阵），在 $x_k$ 处求值。\n\n残差函数的导数为：\n$$\nR'(x) = \\frac{dR}{dx} = 1 - \\Delta t \\left( \\frac{dP}{dx} - \\frac{dD}{dx} \\right)\n$$\n计算 $dP/dx$ 和 $dD/dx$ 需要通过SA模型的所有辅助函数，仔细应用乘法法则和链式法则。这些项及其导数的完整表达式是复杂的，涉及如下依赖关系：\n- $P(x)$ 依赖于 $f_{t2}(x)$ 和 $\\hat{S}(x)$。\n- $\\hat{S}(x)$ 依赖于 $\\nu_t(x)$ 和 $f_{v2}(x)$。\n- $\\nu_t(x)$ 依赖于 $f_{v1}(x)$。\n- $D(x)$ 依赖于 $f_w(x)$。\n- $f_w(x)$ 依赖于 $g(x)$，后者依赖于 $r(x)$，而 $r(x)$ 又依赖于 $\\hat{S}(x)$。\n- 所有辅助函数最终都通过变量 $\\chi = x/\\nu$ 依赖于 $x = \\tilde{\\nu}^{n+1}$。\n\n导数计算按以下级联方式进行：\n1.  对于给定的 $x$ 值，计算所有辅助量（$\\chi, f_{v1}, f_{v2}, \\nu_t, \\hat{S}, r, g, f_w, f_{t2}$）。\n2.  使用链式法则计算这些量相对于 $x$ 的导数，例如，$df_{v1}/dx = (df_{v1}/d\\chi) \\cdot (d\\chi/dx)$。这必须按照遵循函数依赖关系的顺序进行。例如，由于 $r'(x)$ 依赖于 $\\hat{S}'(x)$，而 $\\hat{S}'(x)$ 依赖于 $f'_{v1}(x)$ 和 $f'_{v2}(x)$，因此必须首先计算 $f_v$ 函数的导数。\n3.  使用乘法法则组装导数 $dP/dx$ 和 $dD/dx$。\n4.  最后，组装雅可比矩阵 $R'(x) = 1 - \\Delta t (dP/dx - dD/dx)$。\n\n为确保求解器的鲁棒性，特别是在处理刚性情况或大时间步长时，牛顿法会辅以回溯线搜索。这种全局化策略确保每一步都能减小残差的量级，并防止迭代值变为非物理的（负）值。更新变为：\n$$\nx_{k+1} = x_k - \\alpha_k \\frac{R(x_k)}{R'(x_k)}\n$$\n其中选择步长 $\\alpha_k \\in (0, 1]$ 以满足两个条件：\n1.  **正性**：$x_{k+1} > 0$。\n2.  **充分下降（类Armijo条件）**：$|R(x_{k+1})|  |R(x_k)|$。\n\n线搜索从 $\\alpha_k = 1$（完整牛顿步）开始，并迭代地将其减半，直到两个条件都满足。\n\n每个测试用例的总体算法如下：\n1.  用 $x_0 = \\tilde{\\nu}^{n}$ 初始化求解器。\n2.  使用全局化牛顿法进行迭代，直到残差范数 $|R(x_k)|$ 降至严格的内部求解器容差（例如，$10^{-14}$）以下。\n3.  收敛解为 $\\tilde{\\nu}^{n+1} = x_{final}$。\n4.  计算最终残差范数，$||Res||_2 = |R(\\tilde{\\nu}^{n+1})|$。\n5.  将此范数与问题指定的容差 $\\varepsilon$ 进行比较，以确定布尔结果。\n\n常数 $c_{w1}$ 由其他常数计算得出：\n$$\nc_{w1} = \\frac{c_{b1}}{\\kappa^{2}} + \\frac{1 + c_{b2}}{\\sigma} = \\frac{0.1355}{0.41^{2}} + \\frac{1 + 0.622}{2/3} \\approx 3.2390678167757285\n$$\n对所提供的四个测试用例均执行此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Spalart-Allmaras 0D problem for all test cases.\n    \"\"\"\n\n    # Define the constants for the Spalart-Allmaras model\n    CONSTS = {\n        'cb1': 0.1355,\n        'cb2': 0.622,\n        'sigma': 2.0 / 3.0,\n        'kappa': 0.41,\n        'cv1': 7.1,\n        'ct3': 1.2,\n        'ct4': 0.5,\n        'cw2': 0.3,\n        'cw3': 2.0,\n    }\n    # Calculate cw1 from other constants\n    CONSTS['cw1'] = CONSTS['cb1'] / CONSTS['kappa']**2 + (1.0 + CONSTS['cb2']) / CONSTS['sigma']\n\n    def run_case(nu, S, d, dt, nutilde_n, epsilon, consts):\n        \"\"\"\n        Solves a single test case using a robust Newton-Raphson method.\n        \"\"\"\n        \n        def compute_residual_and_jacobian(x):\n            \"\"\"\n            Computes the residual R(x) and its derivative (Jacobian) J(x)\n            for the backward Euler discretization of the SA 0D equation.\n            x is the current guess for nutilde^{n+1}.\n            \"\"\"\n            # Protect against non-physical values\n            x = max(x, 1e-30)\n\n            # Unpack constants\n            cb1, cb2, sigma, kappa, cv1, ct3, ct4, cw2, cw3, cw1 = (\n                consts['cb1'], consts['cb2'], consts['sigma'], consts['kappa'],\n                consts['cv1'], consts['ct3'], consts['ct4'], consts['cw2'],\n                consts['cw3'], consts['cw1']\n            )\n\n            # --- Evaluate auxiliary functions and their derivatives ---\n            # Level 1: chi\n            chi = x / nu\n            dchi_dx = 1.0 / nu\n\n            # Level 2: f_v1, f_v2, f_t2\n            chi2 = chi**2\n            chi3 = chi**3\n            cv1_3 = cv1**3\n            \n            den_fv1 = chi3 + cv1_3\n            fv1 = chi3 / den_fv1\n            dfv1_dchi = 3.0 * chi2 * cv1_3 / (den_fv1**2)\n            dfv1_dx = dfv1_dchi * dchi_dx\n\n            term_fv2_num = chi\n            term_fv2_den = 1.0 + chi * fv1\n            fv2 = 1.0 - term_fv2_num / term_fv2_den\n            d_term_fv2_num_dx = dchi_dx\n            d_term_fv2_den_dx = dchi_dx * fv1 + chi * dfv1_dx\n            dfv2_dx = -(d_term_fv2_num_dx * term_fv2_den - term_fv2_num * d_term_fv2_den_dx) / (term_fv2_den**2)\n            \n            ft2 = ct3 * np.exp(-ct4 * chi2)\n            dft2_dchi = -2.0 * ct4 * chi * ft2\n            dft2_dx = dft2_dchi * dchi_dx\n            \n            # Level 3: nu_t, S_hat\n            nut = x * fv1\n            dnut_dx = fv1 + x * dfv1_dx\n            \n            kappa2_d2 = kappa**2 * d**2\n            S_hat_mod = nut / kappa2_d2 * fv2\n            S_hat = S + S_hat_mod\n            dS_hat_mod_dx = (dnut_dx * fv2 + nut * dfv2_dx) / kappa2_d2\n            dS_hat_dx = dS_hat_mod_dx\n            \n            # Level 4: r, g, f_w\n            # S_hat is guaranteed to be positive for the given test cases.\n            den_r = S_hat * kappa2_d2\n            r = x / den_r if den_r != 0 else 0.0\n            dr_dx = (1.0 * den_r - x * (dS_hat_dx * kappa2_d2)) / den_r**2 if den_r != 0 else 0.0\n            \n            r6 = r**6\n            g = r + cw2 * (r6 - r)\n            dg_dr = (1.0 - cw2) + 6.0 * cw2 * r**5\n            dg_dx = dg_dr * dr_dx\n            \n            cw3_6 = cw3**6\n            g6 = g**6\n            den_fw = g6 + cw3_6\n            fw_factor = ((1.0 + cw3_6) / den_fw)**(1.0/6.0)\n            fw = g * fw_factor\n\n            C_fw_deriv = (1.0 + cw3_6)**(1.0/6.0)\n            dfw_dg = C_fw_deriv * cw3_6 / den_fw**(7.0/6.0)\n            dfw_dx = dfw_dg * dg_dx\n\n            # --- Evaluate Production/Destruction and their derivatives ---\n            P = cb1 * (1.0 - ft2) * S_hat * x\n            dP_dx = cb1 * (\n                -dft2_dx * S_hat * x + \n                (1.0 - ft2) * dS_hat_dx * x + \n                (1.0 - ft2) * S_hat\n            )\n            \n            D = cw1 * fw * (x/d)**2\n            dD_dx = cw1 * (\n                dfw_dx * (x/d)**2 +\n                fw * (2.0 * x / d**2)\n            )\n\n            # --- Final Residual and Jacobian of the Newton system ---\n            R = x - nutilde_n - dt * (P - D)\n            J = 1.0 - dt * (dP_dx - dD_dx)\n\n            return R, J\n\n        # --- Newton's Method with Backtracking Line Search ---\n        x_k = nutilde_n\n        if x_k = 0:  # Start with a small positive value if initial is non-physical\n            x_k = 1e-12\n\n        solver_tol = 1e-14\n        max_iter = 50\n        min_alpha = 1e-8\n\n        for _ in range(max_iter):\n            R, J = compute_residual_and_jacobian(x_k)\n\n            if abs(R)  solver_tol:\n                break\n            \n            if abs(J)  1e-20:  # Jacobian is singular\n                # This indicates a failure in the solver or pathological case\n                return False\n\n            delta_x = R / J\n            \n            # Backtracking Line Search\n            alpha = 1.0\n            while alpha > min_alpha:\n                x_next = x_k - alpha * delta_x\n                \n                if x_next = 0: # Ensure positivity\n                    alpha /= 2.0\n                    continue\n\n                R_next, _ = compute_residual_and_jacobian(x_next)\n                \n                if abs(R_next)  abs(R): # Armijo condition\n                    break\n                \n                alpha /= 2.0\n            \n            if alpha = min_alpha: # Line search failed\n                return False\n\n            x_k = x_k - alpha * delta_x\n        \n        nutilde_np1 = x_k\n        final_residual, _ = compute_residual_and_jacobian(nutilde_np1)\n        \n        return abs(final_residual)  epsilon\n\n\n    test_cases = [\n        # Case A (happy path)\n        (1.5e-5, 500, 1e-3, 1e-4, 5e-6, 1e-10),\n        # Case B (stiffer dynamics)\n        (1.5e-5, 5000, 5e-4, 5e-3, 2e-5, 1e-9),\n        # Case C (near-wall small eddy viscosity)\n        (1.5e-5, 200, 1e-4, 1e-3, 1e-12, 1e-12),\n        # Case D (extreme parameters)\n        (1.5e-5, 1e4, 1e-5, 1.0, 1e-4, 1e-20)\n    ]\n\n    results = []\n    for case_params in test_cases:\n        nu, S, d, dt, nutilde_n, epsilon = case_params\n        result = run_case(nu, S, d, dt, nutilde_n, epsilon, CONSTS)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}