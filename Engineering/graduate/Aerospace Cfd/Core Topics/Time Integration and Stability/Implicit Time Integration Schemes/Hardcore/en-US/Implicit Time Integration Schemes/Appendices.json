{
    "hands_on_practices": [
        {
            "introduction": "Understanding the stability of a numerical scheme is paramount in CFD, especially for stiff problems where eigenvalues of the system Jacobian have large negative real parts. This exercise grounds you in the fundamental technique of stability analysis by applying it to the backward Euler method, a cornerstone implicit scheme. By deriving the amplification factor for the canonical scalar test equation and mapping its stability region, you will develop a concrete, geometric intuition for the property of A-stability.",
            "id": "3967285",
            "problem": "Consider the scalar linear test equation $u'(t)=\\lambda u(t)$ that arises from modal decomposition of linearized compressible flow models in Computational Fluid Dynamics (CFD). An implicit one-step method is formed by the backward Euler discretization, which updates the solution from time $t^{n}$ to $t^{n+1}=t^{n}+\\Delta t$ using the right-hand side evaluated at the new time level. For this linear test problem, introduce the dimensionless complex number $z=\\lambda\\,\\Delta t$ and define the amplification factor $G(z)$ by $u^{n+1}=G(z)\\,u^{n}$. The absolute stability region $\\mathcal{A}$ of the method is the set of all $z\\in\\mathbb{C}$ such that $|G(z)|\\leq 1$. Starting from the fundamental definitions of backward Euler and absolute stability, derive $G(z)$ and characterize $\\mathcal{A}$ as a subset of the complex plane. Then, parameterize the boundary $\\partial\\mathcal{A}$ by a single analytic expression $z(\\theta)$ in terms of a real parameter $\\theta$ that traces the entire boundary once as $\\theta$ varies over an interval of length $2\\pi$. Your final answer must be the closed-form expression for $z(\\theta)$, with no rounding required and no units.",
            "solution": "The problem statement is found to be valid as it represents a standard, well-posed problem in the numerical analysis of ordinary differential equations, specifically concerning the stability of the backward Euler method. It is scientifically grounded, self-contained, and objective. We proceed with the solution.\n\nThe problem asks for a derivation of the amplification factor $G(z)$ for the backward Euler method applied to the scalar linear test equation $u'(t) = \\lambda u(t)$, a characterization of the absolute stability region $\\mathcal{A}$, and a parameterization of its boundary $\\partial\\mathcal{A}$.\n\nFirst, we apply the backward Euler method. This implicit method approximates the derivative at the future time level $t^{n+1}$ using a first-order finite difference, and evaluates the right-hand side of the ODE at this same future time. The discretized equation is:\n$$\n\\frac{u^{n+1} - u^{n}}{\\Delta t} = \\lambda u^{n+1}\n$$\nHere, $u^{n}$ is the numerical solution at time $t^{n}$, $u^{n+1}$ is the solution at time $t^{n+1} = t^{n}+\\Delta t$, and $\\lambda$ is a complex constant. We must rearrange this equation to solve for $u^{n+1}$ in terms of $u^{n}$.\n$$\nu^{n+1} - u^{n} = \\lambda \\Delta t u^{n+1}\n$$\n$$\nu^{n+1} - (\\lambda \\Delta t) u^{n+1} = u^{n}\n$$\nFactoring out $u^{n+1}$ on the left-hand side gives:\n$$\nu^{n+1} (1 - \\lambda \\Delta t) = u^{n}\n$$\nSolving for $u^{n+1}$ yields the update rule:\n$$\nu^{n+1} = \\frac{1}{1 - \\lambda \\Delta t} u^{n}\n$$\nThe problem defines the dimensionless complex number $z = \\lambda \\Delta t$. Substituting this definition into the equation, we get:\n$$\nu^{n+1} = \\frac{1}{1 - z} u^{n}\n$$\nThe amplification factor, $G(z)$, is defined by the relationship $u^{n+1} = G(z) u^{n}$. By direct comparison with our derived update rule, we find the amplification factor for the backward Euler method to be:\n$$\nG(z) = \\frac{1}{1 - z}\n$$\nNext, we characterize the absolute stability region, $\\mathcal{A}$, which is defined as the set of all $z \\in \\mathbb{C}$ where the magnitude of the amplification factor is no greater than $1$:\n$$\n\\mathcal{A} = \\{ z \\in \\mathbb{C} \\mid |G(z)| \\leq 1 \\}\n$$\nSubstituting the derived expression for $G(z)$:\n$$\n\\left| \\frac{1}{1 - z} \\right| \\leq 1\n$$\nUsing the property that for complex numbers $a$ and $b$, $|a/b| = |a|/|b|$, we can write:\n$$\n\\frac{|1|}{|1-z|} \\leq 1\n$$\nSince $|1| = 1$, the condition for stability simplifies to:\n$$\n1 \\leq |1 - z|\n$$\nTo interpret this inequality geometrically, we represent the complex number $z$ in Cartesian form as $z = x + iy$, where $x, y \\in \\mathbb{R}$. The complex number $1-z$ is then $1 - (x + iy) = (1-x) - iy$. Its magnitude is:\n$$\n|1 - z| = \\sqrt{(1-x)^2 + (-y)^2} = \\sqrt{(x-1)^2 + y^2}\n$$\nThe stability condition $1 \\leq |1 - z|$ becomes $1 \\leq \\sqrt{(x-1)^2 + y^2}$. Since both sides are non-negative, we can square them without changing the inequality:\n$$\n1^2 \\leq (x-1)^2 + y^2\n$$\n$$\n1 \\leq (x-1)^2 + y^2\n$$\nThis inequality describes the set of points $(x,y)$ in the complex plane whose squared distance from the point $(1,0)$ is greater than or equal to $1$. This corresponds to the region on and outside the circle of radius $1$ centered at $(1,0)$. Therefore, the stability region $\\mathcal{A}$ is the exterior of the open disk defined by $|z-1|  1$.\n\nFinally, we are asked to parameterize the boundary of the stability region, $\\partial\\mathcal{A}$. The boundary is the set of points where equality holds in the stability condition:\n$$\n|G(z)| = 1 \\implies |1-z| = 1\n$$\nThis equation, $|z-1|=1$, describes a circle in the complex plane with center $z_c = 1 + 0i = 1$ and radius $R=1$. A circle of radius $R$ centered at $z_c$ can be parameterized using Euler's formula as $z(\\theta) = z_c + R e^{i\\theta}$, where $\\theta$ is a real parameter. As $\\theta$ varies over an interval of length $2\\pi$ (e.g., from $0$ to $2\\pi$), the expression traces the circle once.\n\nFor our specific case, with $z_c = 1$ and $R=1$, the parameterization of the boundary $\\partial\\mathcal{A}$ is:\n$$\nz(\\theta) = 1 + 1 \\cdot e^{i\\theta}\n$$\nExpressing the exponential function with the `exp` notation as conventionally required in formal mathematical typesetting yields the final expression:\n$$\nz(\\theta) = 1 + \\exp(i\\theta)\n$$\nThis is the required closed-form analytic expression that parameterizes the entire boundary of the stability region.",
            "answer": "$$\n\\boxed{1 + \\exp(i\\theta)}\n$$"
        },
        {
            "introduction": "While theoretical stability is a prerequisite, its practical consequences for accuracy are just as important. This exercise provides a direct numerical demonstration of the trade-offs involved in using implicit methods for stiff systems. By applying the backward Euler method to a simple but highly stiff decay model, you will observe firsthand how the scheme maintains stability with a large time step but also introduces significant numerical error, perfectly illustrating the quintessential stability-versus-accuracy dilemma in CFD.",
            "id": "3885112",
            "problem": "Consider a non-dimensional linear decay model for a tracer concentration in a one-box environmental system, idealized as the ordinary differential equation (ODE) $y'(t)=\\lambda\\,y(t)$ with initial condition $y(0)=y_{0}$. This ODE arises from the conservation of mass law with a linearized sink proportional to $y(t)$, where $\\lambda0$ represents a constant decay rate. Let $\\lambda=-1000$, $y_{0}=1$, and the time step be $\\Delta t=0.1$. Using an implicit time integration scheme derived from the integral form of the ODE over one time step, apply the backward Euler method to compute the one-step numerical approximation $y_{1}\\approx y(\\Delta t)$.\n\nSeparately, derive the exact solution $y(t)$ of the ODE by separation of variables and evaluate it at $t=\\Delta t$. Define the absolute one-step error as $E=\\left|y_{1}-y(\\Delta t)\\right|$. Report $E$ as a single number, rounded to four significant figures. Express the answer as a dimensionless quantity. The purpose of this calculation is to compare the backward Euler result to the exact solution in order to illustrate the tradeoff between absolute stability (A-stability) and accuracy for stiff problems in environmental and earth system modeling.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- Ordinary Differential Equation (ODE): $y'(t)=\\lambda\\,y(t)$\n- Initial condition: $y(0)=y_{0}$\n- Decay rate constant: $\\lambda=-1000$\n- Initial value: $y_{0}=1$\n- Time step: $\\Delta t=0.1$\n- Numerical method: Backward Euler\n- Quantity to compute: One-step numerical approximation $y_{1}\\approx y(\\Delta t)$\n- Exact solution: $y(t)$ to be derived.\n- Error definition: Absolute one-step error $E=\\left|y_{1}-y(\\Delta t)\\right|$\n- Final output requirement: Report $E$ rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard initial value problem (IVP) for a first-order linear homogeneous ordinary differential equation, a fundamental model for exponential decay processes in science and engineering. The parameters provided ($\\lambda=-1000$, $\\Delta t=0.1$) define a numerically stiff problem, which is a common and meaningful scenario for testing and illustrating the properties of implicit time integration schemes like backward Euler. The problem is self-contained, with all necessary data provided. The language is precise and objective. There are no scientific or factual unsoundness, contradictions, or ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Derivation of the Numerical Solution using Backward Euler Method\nThe given ODE is $y'(t) = \\lambda y(t)$. The backward Euler method is an implicit one-step numerical method for solving ODEs. For an ODE of the form $y'(t) = f(t,y)$, the general formula for advancing the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is:\n$$y_{n+1} = y_n + \\Delta t \\, f(t_{n+1}, y_{n+1})$$\nIn this problem, the function $f(t,y)$ is given by $f(t,y) = \\lambda y(t)$. Substituting this into the backward Euler formula gives:\n$$y_{n+1} = y_n + \\Delta t (\\lambda y_{n+1})$$\nSince this is an implicit method, we must solve for the unknown $y_{n+1}$:\n$$y_{n+1} - \\lambda \\Delta t y_{n+1} = y_n$$\n$$y_{n+1} (1 - \\lambda \\Delta t) = y_n$$\n$$y_{n+1} = \\frac{y_n}{1 - \\lambda \\Delta t}$$\nWe are asked to compute the first step, $y_1$, starting from the initial condition $y_0$ at $t_0=0$. Setting $n=0$:\n$$y_1 = \\frac{y_0}{1 - \\lambda \\Delta t}$$\nThe problem provides the values $y_0=1$, $\\lambda=-1000$, and $\\Delta t=0.1$. Substituting these values into the equation for $y_1$:\n$$y_1 = \\frac{1}{1 - (-1000)(0.1)} = \\frac{1}{1 - (-100)} = \\frac{1}{1+100} = \\frac{1}{101}$$\n\n### Derivation of the Exact Solution\nThe ODE $y'(t) = \\lambda y(t)$ can be written as $\\frac{dy}{dt} = \\lambda y$. This is a separable differential equation. We can separate the variables $y$ and $t$:\n$$\\frac{dy}{y} = \\lambda \\, dt$$\nIntegrating both sides of the equation:\n$$\\int \\frac{1}{y} \\, dy = \\int \\lambda \\, dt$$\n$$\\ln|y| = \\lambda t + C$$\nwhere $C$ is the constant of integration. To solve for $y$, we exponentiate both sides:\n$$|y| = \\exp(\\lambda t + C) = \\exp(C) \\exp(\\lambda t)$$\nLetting $A = \\pm\\exp(C)$, we obtain the general solution:\n$$y(t) = A \\exp(\\lambda t)$$\nTo find the particular solution, we apply the initial condition $y(0)=y_0$:\n$$y(0) = A \\exp(\\lambda \\cdot 0) = A \\exp(0) = A \\cdot 1 = A$$\nThus, the integration constant is $A=y_0$. The exact solution to the IVP is:\n$$y(t) = y_0 \\exp(\\lambda t)$$\nSubstituting the given values $y_0=1$ and $\\lambda=-1000$:\n$$y(t) = 1 \\cdot \\exp(-1000t) = \\exp(-1000t)$$\nWe need to evaluate this exact solution at time $t=\\Delta t=0.1$:\n$$y(\\Delta t) = y(0.1) = \\exp(-1000 \\cdot 0.1) = \\exp(-100)$$\n\n### Calculation of the Absolute Error\nThe absolute one-step error $E$ is defined as $E = |y_1 - y(\\Delta t)|$. Substituting the numerical and exact values we found:\n$$E = \\left| \\frac{1}{101} - \\exp(-100) \\right|$$\nNow, we compute the numerical values.\n$y_1 = \\frac{1}{101} \\approx 0.009900990099...$\nThe value of $y(\\Delta t) = \\exp(-100)$ is an extremely small positive number. Using a calculator, $\\exp(-100) \\approx 3.72 \\times 10^{-44}$.\nThe error is:\n$$E \\approx |0.009900990099 - 3.72 \\times 10^{-44}|$$\nThe term $\\exp(-100)$ is many orders of magnitude smaller than $\\frac{1}{101}$ and its contribution to the error is negligible for the required precision. Therefore, the error is effectively equal to $y_1$:\n$$E \\approx \\frac{1}{101} \\approx 0.009900990099...$$\nThe problem asks for the result to be rounded to four significant figures.\nThe first non-zero digit of $E$ is the $9$ in the thousandths place. The first four significant figures are $9$, $9$, $0$, $0$. The fifth significant figure is $9$. Since $9 \\ge 5$, we round up the fourth significant figure.\nSo, the value $0.00990099...$ rounded to four significant figures is $0.009901$.",
            "answer": "$$\\boxed{0.009901}$$"
        },
        {
            "introduction": "Moving from simple ODEs to the PDEs that govern fluid flow requires integrating spatial discretization with a robust time-stepping scheme. This advanced practice guides you through the implementation of a high-order implicit method for the viscous Burgers' equation, a key model for nonlinear advection and diffusion. You will construct a complete method-of-lines solver using a Singly Diagonally Implicit Runge-Kutta (SDIRK) scheme, tackling the nonlinear algebraic systems at each stage with Newton's method and gaining invaluable experience in building a research-grade computational tool.",
            "id": "3967154",
            "problem": "You are to implement a single implicit time step of a two-stage Singly Diagonally Implicit Runge-Kutta (SDIRK) scheme for the one-dimensional viscous Burgers equation in a dimensionless form on a periodic domain. The governing partial differential equation is\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}u^2\\right) = \\nu \\frac{\\partial^2 u}{\\partial x^2},\n$$\nwhere $u(x,t)$ is the scalar field and $\\nu$ is the dimensionless viscosity. The spatial domain is $[0,1]$ with periodic boundary conditions. The numerical approximation must be constructed on a uniform mesh with $N$ points, grid spacing $\\Delta x = 1/N$, and cell-centered unknowns.\n\nYour implementation must:\n- Derive a semi-discrete form $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u})$ using a conservative finite-volume style discretization with periodic boundary conditions, where the convective flux at cell interfaces is approximated by a Rusanov flux and the diffusive term by a second-order central difference. Specifically, for the convective term use the interface flux constructed from the physical flux $f(u) = \\frac{1}{2}u^2$ and a constant-in-Newton-iteration wave speed at each interface given by the maximum of the absolute values of the adjacent cell-centered velocities. Assemble the residual $\\mathbf{F}(\\mathbf{u})$ in a way that is consistent with this discretization.\n- Implement a $2$-stage SDIRK scheme with diagonal coefficient $\\gamma$ chosen as $\\gamma = 1 - 1/\\sqrt{2}$, stage times $c_1 = \\gamma$, $c_2 = 1$, and weights $b_1 = 1 - \\gamma$, $b_2 = \\gamma$. Let $a_{11} = \\gamma$, $a_{21} = 1 - \\gamma$, and $a_{22} = \\gamma$. For the semi-discrete system $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u})$, the stage equations are defined by the generic SDIRK construction.\n- Formulate for each stage a nonlinear residual that must be driven to zero by Newton's method. Explicitly, define the stage-$1$ unknown $\\mathbf{u}^{(1)}$ and stage-$2$ unknown $\\mathbf{u}^{(2)}$, construct the corresponding stage residuals, and implement Newton iterations that use the exact Jacobian of the stage residual with respect to the stage unknown. The Jacobian must be assembled from the identity matrix and the Jacobian of the spatial operator $\\mathbf{F}(\\mathbf{u})$, which itself comes from differentiating the discretized convective and diffusive operators. During Jacobian construction, treat the interface wave speeds in the Rusanov flux as frozen (constant) with respect to the unknowns within each Newton iteration.\n- Solve the resulting linear systems at each Newton step using a sparse direct solver.\n\nThe initial condition is $u(x,0) = A \\sin(2\\pi x)$. For each test case, perform exactly one time step from $t^n$ to $t^{n+1} = t^n + \\Delta t$ and report the Euclidean norm of the updated solution $\\|\\mathbf{u}^{n+1}\\|_2$.\n\nThere are no physical units in this dimensionless formulation. Angles are not used in the problem. All outputs must be real numbers.\n\nTest Suite:\n- Case $1$: $N = 64$, $\\Delta t = 0.02$, $\\nu = 0.01$, $A = 1.0$.\n- Case $2$: $N = 64$, $\\Delta t = 0.20$, $\\nu = 0.01$, $A = 1.0$.\n- Case $3$: $N = 32$, $\\Delta t = 0.05$, $\\nu = 0.001$, $A = 1.5$.\n- Case $4$: $N = 16$, $\\Delta t = 0.01$, $\\nu = 0.10$, $A = 0.5$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, specifically the list of Euclidean norms of $\\mathbf{u}^{n+1}$ for the four cases in the order above. For example, the output must have the form $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a floating-point number.",
            "solution": "The user wants to solve for the one-dimensional viscous Burgers' equation using a specific Singly Diagonally Implicit Runge-Kutta (SDIRK) method. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The one-dimensional viscous Burgers' equation in dimensionless form is $\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}u^2\\right) = \\nu \\frac{\\partial^2 u}{\\partial x^2}$.\n- **Domain**: Spatial domain $x \\in [0,1]$ with periodic boundary conditions.\n- **Discretization**: Uniform mesh with $N$ points, grid spacing $\\Delta x = 1/N$, and cell-centered unknowns.\n- **Semi-discrete Form**: $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u})$, derived using a conservative finite-volume method.\n- **Convective Flux**: A Rusanov flux for the physical flux $f(u) = \\frac{1}{2}u^2$, with interface wave speed $\\lambda_{i+1/2} = \\max(|u_i|, |u_{i+1}|)$.\n- **Diffusive Flux**: A second-order central difference approximation.\n- **Time Integration**: A $2$-stage SDIRK scheme with parameters:\n    - Diagonal coefficient: $\\gamma = 1 - 1/\\sqrt{2}$.\n    - Stage times: $c_1 = \\gamma$, $c_2 = 1$.\n    - Butcher tableau coefficients: $a_{11} = \\gamma$, $a_{21} = 1 - \\gamma$, $a_{22} = \\gamma$.\n    - Weights: $b_1 = 1 - \\gamma$, $b_2 = \\gamma$.\n- **Nonlinear Solver**: Newton's method for each stage, using the exact Jacobian of the stage residual.\n- **Jacobian Construction**: The interface wave speeds in the Rusanov flux are treated as frozen (constant) with respect to the unknowns within each Newton iteration.\n- **Linear Solver**: A sparse direct solver.\n- **Initial Condition**: $u(x,0) = A \\sin(2\\pi x)$.\n- **Task**: For each test case, perform one time step of size $\\Delta t$ and report the Euclidean norm of the solution vector at the new time, $\\|\\mathbf{u}^{n+1}\\|_2$.\n- **Test Suite**:\n    - Case 1: $N = 64$, $\\Delta t = 0.02$, $\\nu = 0.01$, $A = 1.0$.\n    - Case 2: $N = 64$, $\\Delta t = 0.20$, $\\nu = 0.01$, $A = 1.0$.\n    - Case 3: $N = 32$, $\\Delta t = 0.05$, $\\nu = 0.001$, $A = 1.5$.\n    - Case 4: $N = 16$, $\\Delta t = 0.01$, $\\nu = 0.10$, $A = 0.5$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is grounded in the well-established field of computational fluid dynamics. The viscous Burgers' equation is a canonical model for nonlinear wave propagation and diffusion. The specified numerical methods (finite volume, Rusanov flux, SDIRK, Newton's method) are standard and appropriate for this class of problems.\n- **Well-Posed**: The problem is specified with a high degree of precision. The governing equation, domain, boundary conditions, initial condition, and the complete numerical algorithm are defined unambiguously. A unique, stable solution is expected for the given parameters.\n- **Objective**: The problem statement is entirely objective, using formal mathematical and numerical language. It is free from subjectivity or opinion.\n\nThe problem statement has no discernible flaws. It is not scientifically unsound, incomplete, contradictory, or ill-posed. It represents a non-trivial but well-defined computational task.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. I will proceed to provide a complete solution.\n\n### Principle-Based Solution Design\n\nThe solution is implemented by following a series of structured steps, starting from the spatial discretization of the PDE to the time integration using the specified implicit scheme.\n\n**1. Semi-Discretization**\n\nThe partial differential equation is first converted into a system of ordinary differential equations (ODEs) in time, a process known as semi-discretization. We use a finite-volume method on a uniform grid with $N$ cells, where $u_i(t)$ is the cell-averaged value in the $i$-th cell. The governing equation for each cell average becomes:\n$$\n\\frac{d u_i}{d t} = (\\text{convective term})_i + (\\text{diffusive term})_i\n$$\nThe right-hand side is denoted as $F_i(\\mathbf{u})$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$.\n\n- **Convective Term**: The convective part $\\frac{\\partial}{\\partial x}(\\frac{1}{2}u^2)$ is discretized using a flux-difference approach:\n$$\n(\\text{convective term})_i = -\\frac{1}{\\Delta x} \\left( \\hat{f}_{i+1/2} - \\hat{f}_{i-1/2} \\right)\n$$\nwhere $\\hat{f}_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. We use the Rusanov flux:\n$$\n\\hat{f}_{i+1/2} = \\frac{1}{2} \\left[ f(u_i) + f(u_{i+1}) \\right] - \\frac{1}{2} \\lambda_{i+1/2} (u_{i+1} - u_i)\n$$\nHere, $f(u) = \\frac{1}{2}u^2$ is the physical flux, and $\\lambda_{i+1/2} = \\max(|u_i|, |u_{i+1}|)$ is the local wave speed, providing numerical dissipation.\n\n- **Diffusive Term**: The diffusive term $\\nu \\frac{\\partial^2 u}{\\partial x^2}$ is discretized using a standard second-order central difference stencil, which can also be written in a flux-difference form:\n$$\n(\\text{diffusive term})_i = \\frac{1}{\\Delta x} \\left( \\hat{d}_{i+1/2} - \\hat{d}_{i-1/2} \\right) \\quad \\text{with} \\quad \\hat{d}_{i+1/2} = \\nu \\frac{u_{i+1} - u_i}{\\Delta x}\n$$\nThis simplifies to:\n$$\n(\\text{diffusive term})_i = \\frac{\\nu}{\\Delta x^2} (u_{i+1} - 2u_i + u_{i-1})\n$$\n\nCombining these terms gives the semi-discrete ODE system $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u})$.\n\n**2. SDIRK Time Integration**\n\nThe semi-discrete system is integrated in time using a $2$-stage SDIRK scheme. Given the solution $\\mathbf{u}^n$ at time $t^n$, the goal is to find $\\mathbf{u}^{n+1}$ at $t^{n+1} = t^n + \\Delta t$. The scheme is defined by its Butcher tableau:\n$$\n\\begin{array}{c|cc}\n\\gamma  \\gamma  0 \\\\\n1  1-\\gamma  \\gamma \\\\\n\\hline\n 1-\\gamma  \\gamma\n\\end{array}\n\\quad \\text{where} \\quad \\gamma = 1 - \\frac{1}{\\sqrt{2}}\n$$\nThe stage equations are:\n- **Stage 1**: Find stage unknown $\\mathbf{u}^{(1)}$ by solving the implicit nonlinear equation:\n$$\n\\mathbf{u}^{(1)} = \\mathbf{u}^n + \\Delta t \\, \\gamma \\, \\mathbf{F}(\\mathbf{u}^{(1)})\n$$\n- **Stage 2**: Find stage unknown $\\mathbf{u}^{(2)}$ by solving:\n$$\n\\mathbf{u}^{(2)} = \\mathbf{u}^n + \\Delta t \\, (1-\\gamma) \\, \\mathbf{F}(\\mathbf{u}^{(1)}) + \\Delta t \\, \\gamma \\, \\mathbf{F}(\\mathbf{u}^{(2)})\n$$\nThe vector $\\mathbf{F}(\\mathbf{u}^{(1)})$ is computed using the solution from Stage 1.\nThe scheme is \"stiffly accurate,\" meaning the final solution update is identical to the last stage:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{(2)}\n$$\n\n**3. Newton-Raphson Method for Stage Equations**\n\nEach stage requires solving a nonlinear system of equations of the general form $\\mathbf{u} - \\Delta t \\gamma \\mathbf{F}(\\mathbf{u}) = \\mathbf{c}$, where $\\mathbf{c}$ is a constant vector for that stage. We define a residual function:\n$$\n\\mathbf{R}(\\mathbf{u}) = \\mathbf{u} - \\Delta t \\gamma \\mathbf{F}(\\mathbf{u}) - \\mathbf{c} = \\mathbf{0}\n$$\nThis is solved using Newton's method. Starting with an initial guess $\\mathbf{u}_k$, we find an update $\\Delta \\mathbf{u}$ by solving the linear system:\n$$\nJ(\\mathbf{u}_k) \\Delta \\mathbf{u} = -\\mathbf{R}(\\mathbf{u}_k)\n$$\nand then update the solution: $\\mathbf{u}_{k+1} = \\mathbf{u}_k + \\Delta \\mathbf{u}$. The process is repeated until the norm of the residual $\\|\\mathbf{R}(\\mathbf{u}_k)\\|_2$ falls below a specified tolerance. The Jacobian matrix $J(\\mathbf{u}_k)$ is:\n$$\nJ(\\mathbf{u}_k) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}}\\bigg|_{\\mathbf{u}_k} = \\mathbf{I} - \\Delta t \\gamma \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{u}}\\bigg|_{\\mathbf{u}_k}\n$$\nwhere $\\mathbf{I}$ is the identity matrix and $\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{u}} \\equiv J_F$ is the Jacobian of the spatial operator.\n\n**4. Jacobian of the Spatial Operator ($J_F$)**\n\nThe entries of $J_F$ are $(J_F)_{ij} = \\frac{\\partial F_i}{\\partial u_j}$. As $F_i$ depends only on $u_{i-1}$, $u_i$, and $u_{i+1}$, $J_F$ is a tridiagonal matrix. Due to periodic boundary conditions, it has additional non-zero entries at the corners, making it a circulant matrix. Following the problem specification, the wave speeds $\\lambda$ are held constant during differentiation. The non-zero entries on row $i$ are:\n- **Diagonal ($j=i$)**: $\\frac{\\partial F_i}{\\partial u_i} = -\\frac{1}{2\\Delta x}(\\lambda_{i+1/2} + \\lambda_{i-1/2}) - \\frac{2\\nu}{\\Delta x^2}$\n- **Super-diagonal ($j=i+1$)**: $\\frac{\\partial F_i}{\\partial u_{i+1}} = -\\frac{u_{i+1}}{2\\Delta x} + \\frac{\\lambda_{i+1/2}}{2\\Delta x} + \\frac{\\nu}{\\Delta x^2}$\n- **Sub-diagonal ($j=i-1$)**: $\\frac{\\partial F_i}{\\partial u_{i-1}} = \\frac{u_{i-1}}{2\\Delta x} + \\frac{\\lambda_{i-1/2}}{2\\Delta x} + \\frac{\\nu}{\\Delta x^2}$\n\n**5. Implementation**\n\nThe algorithm is implemented in Python using `numpy` for array operations and `scipy.sparse` for efficient construction of the sparse Jacobian matrices. The linear system at each Newton step is solved using `scipy.sparse.linalg.spsolve`, which is a sparse direct solver. The overall process for a single time step is:\n1. Initialize the grid and solution vector $\\mathbf{u}^n$ from the initial condition.\n2. Solve for $\\mathbf{u}^{(1)}$ using the Newton solver, with initial guess $\\mathbf{u}^{(1)}_0 = \\mathbf{u}^n$.\n3. Compute $\\mathbf{F}(\\mathbf{u}^{(1)})$ and form the constant vector for the second stage.\n4. Solve for $\\mathbf{u}^{(2)}$ using the Newton solver, with a better initial guess $\\mathbf{u}^{(2)}_0 = \\mathbf{u}^{(1)}$.\n5. The final solution is $\\mathbf{u}^{n+1} = \\mathbf{u}^{(2)}$.\n6. Compute and store the Euclidean norm $\\|\\mathbf{u}^{n+1}\\|_2$. This is repeated for all test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_F(u, N, dx, nu):\n    \"\"\"\n    Computes the semi-discrete residual F(u) for the viscous Burgers' equation.\n    F(u) = -d(convective_flux)/dx + d(diffusive_flux)/dx\n    \"\"\"\n    # Roll arrays to get neighbor values for periodic boundaries\n    u_p1 = np.roll(u, -1)\n    u_m1 = np.roll(u, 1)\n\n    # Convective part: Rusanov flux F_c(u) = 1/2 * u^2\n    f_u = 0.5 * u**2\n    f_up1 = 0.5 * u_p1**2\n    \n    # Interface wave speed\n    lambda_ip12 = np.maximum(np.abs(u), np.abs(u_p1))\n    \n    # Numerical convective flux at interface i+1/2\n    flux_conv_ip12 = 0.5 * (f_u + f_up1) - 0.5 * lambda_ip12 * (u_p1 - u)\n    # Numerical convective flux at interface i-1/2 (by rolling)\n    flux_conv_im12 = np.roll(flux_conv_ip12, 1)\n    \n    # Diffusive part: Central difference\n    # Numerical diffusive flux at interface i+1/2\n    flux_diff_ip12 = nu * (u_p1 - u) / dx\n    # Numerical diffusive flux at interface i-1/2 (by rolling)\n    flux_diff_im12 = np.roll(flux_diff_ip12, 1)\n\n    # Assemble the full residual F(u)\n    # F = -(flux_c_ip12 - flux_c_im12)/dx + (flux_d_ip12 - flux_d_im12)/dx\n    F_vec = -(flux_conv_ip12 - flux_conv_im12) / dx + (flux_diff_ip12 - flux_diff_im12) / dx\n    \n    return F_vec\n\ndef compute_J_F(u, N, dx, nu):\n    \"\"\"\n    Computes the Jacobian of the semi-discrete residual F(u).\n    The wave speeds lambda are frozen during differentiation.\n    \"\"\"\n    u_p1 = np.roll(u, -1)\n    u_m1 = np.roll(u, 1)\n\n    # Recompute wave speeds based on current state u\n    lambda_ip12 = np.maximum(np.abs(u), np.abs(u_p1))\n    lambda_im12 = np.roll(lambda_ip12, 1) # This is max(|u_m1|, |u|)\n    \n    #\n    # Derivatives of F_i w.r.t u_{i-1}, u_i, u_{i+1}\n    #\n    \n    # Main diagonal (dF_i / du_i)\n    diag_0 = - (lambda_ip12 + lambda_im12) / (2 * dx) - (2 * nu) / dx**2\n    \n    # Super-diagonal (dF_i / du_{i+1})\n    diag_p1 = - u_p1 / (2 * dx) + lambda_ip12 / (2 * dx) + nu / dx**2\n    \n    # Sub-diagonal (dF_i / du_{i-1})\n    diag_m1 = u_m1 / (2 * dx) + lambda_im12 / (2 * dx) + nu / dx**2\n\n    # Assemble sparse matrix with periodic boundary conditions\n    # Indices for rows and columns\n    i_indices = np.arange(N)\n    # Main diagonal\n    rows = [i_indices]\n    cols = [i_indices]\n    data = [diag_0]\n    # Super-diagonal with wrap-around\n    rows.append(i_indices)\n    cols.append((i_indices + 1) % N)\n    data.append(diag_p1)\n    # Sub-diagonal with wrap-around\n    rows.append(i_indices)\n    cols.append((i_indices - 1 + N) % N)\n    data.append(diag_m1)\n\n    J_F = sparse.csc_matrix((np.concatenate(data), (np.concatenate(rows), np.concatenate(cols))), shape=(N, N))\n    \n    return J_F\n\ndef newton_solver(u_guess, u_base, dt_gamma, N, dx, nu, tol=1e-10, max_iter=20):\n    \"\"\"\n    Solves the nonlinear system for one SDIRK stage:\n    R(u) = u - u_base - dt_gamma * F(u) = 0\n    \"\"\"\n    u_k = u_guess.copy()\n\n    for _ in range(max_iter):\n        # Calculate residual R(u_k)\n        F_k = compute_F(u_k, N, dx, nu)\n        R = u_k - u_base - dt_gamma * F_k\n        \n        norm_res = np.linalg.norm(R)\n        if norm_res  tol:\n            break\n            \n        # Calculate Jacobian of the residual: J_R = I - dt_gamma * J_F\n        J_F_k = compute_J_F(u_k, N, dx, nu)\n        J_stage = sparse.identity(N, format='csc') - dt_gamma * J_F_k\n        \n        # Solve the linear system J_R * delta_u = -R\n        delta_u = spsolve(J_stage, -R, use_umfpack=True)\n        \n        # Update solution\n        u_k += delta_u\n        \n    return u_k\n\ndef run_sdirk_step(N, dt, nu, A):\n    \"\"\"\n    Performs a single time step for the 1D viscous Burgers' equation\n    using the specified 2-stage SDIRK scheme.\n    \"\"\"\n    dx = 1.0 / N\n    # Cell-centered grid\n    x = np.linspace(0, 1.0, N, endpoint=False)\n    # Initial condition at time t^n\n    u_n = A * np.sin(2 * np.pi * x)\n    \n    # SDIRK coefficient\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    \n    # --- Stage 1 ---\n    # Equation: u_stage1 - dt*gamma*F(u_stage1) = u_n\n    u_base_1 = u_n\n    u_stage1 = newton_solver(u_n, u_base_1, dt * gamma, N, dx, nu)\n    \n    # --- Stage 2 ---\n    # Equation: u_stage2 - dt*gamma*F(u_stage2) = u_n + dt*(1-gamma)*F(u_stage1)\n    F_stage1 = compute_F(u_stage1, N, dx, nu)\n    u_base_2 = u_n + dt * (1.0 - gamma) * F_stage1\n    # Use u_stage1 as a better initial guess for the second stage's Newton solver\n    u_stage2 = newton_solver(u_stage1, u_base_2, dt * gamma, N, dx, nu)\n    \n    # The scheme is stiffly accurate, so u^{n+1} = u_stage2\n    u_np1 = u_stage2\n    \n    return np.linalg.norm(u_np1)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (64, 0.02, 0.01, 1.0),\n        (64, 0.20, 0.01, 1.0),\n        (32, 0.05, 0.001, 1.5),\n        (16, 0.01, 0.10, 0.5),\n    ]\n\n    results = []\n    for N, dt, nu, A in test_cases:\n        norm_u_np1 = run_sdirk_step(N, dt, nu, A)\n        results.append(norm_u_np1)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}