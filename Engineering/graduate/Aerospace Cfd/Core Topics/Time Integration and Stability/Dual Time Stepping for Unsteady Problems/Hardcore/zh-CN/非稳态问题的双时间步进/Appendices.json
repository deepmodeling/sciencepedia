{
    "hands_on_practices": [
        {
            "introduction": "在实施任何数值方法之前，理解其数学基础至关重要。第一个练习要求你为广泛使用的二阶向后差分格式（BDF2）推导双时间步残差，这是在非定常模拟中实现高阶精度的基石。这个练习将巩固你对物理时间离散格式如何转化为伪时间迭代目标残差的理解。",
            "id": "3956096",
            "problem": "考虑计算流体动力学 (CFD) 中使用的可压缩Navier–Stokes方程的一种半离散有限体积格式，其产生如下常微分方程：$$\\mathbf{M}\\,\\frac{d\\mathbf{U}}{dt}+\\mathbf{R}(\\mathbf{U})=\\mathbf{0},$$ 其中 $\\mathbf{U}(t)\\in\\mathbb{R}^{N}$ 是守恒单元平均未知量向量，$\\mathbf{M}\\in\\mathbb{R}^{N\\times N}$ 是一个（可能为块对角的）由单元体积和求积产生的质量矩阵，而 $\\mathbf{R}(\\mathbf{U})$ 是包含通量散度和源项的空间残差。为了将解从物理时间 $t^{n}$推进到 $t^{n+1}=t^{n}+\\Delta t$，您采用双时间步法：引入一个伪时间 $\\tau$，并迭代地将对应于 $t^{n+1}$ 处物理时间离散的双时间残差 $\\mathcal{G}(\\mathbf{U})$ 驱动至零。使用二阶向后差分格式（BDF，2阶），假设物理时间步长 $\\Delta t$ 均匀，并将 $\\mathbf{U}^{n}$ 和 $\\mathbf{U}^{n-1}$ 视为已知的过去状态。\n\n仅从半离散非定常平衡方程 $\\mathbf{M}\\,d\\mathbf{U}/dt+\\mathbf{R}(\\mathbf{U})=\\mathbf{0}$ 以及通过多项式插值或泰勒级数相容性定义的二阶向后差分格式出发，推导在形成对 $\\mathbf{U}^{n+1}$ 的更新时，需要通过伪时间迭代驱动至零的双时间残差 $\\mathcal{G}(\\mathbf{U})$ 的闭式表达式。然后，讨论在双时间步法中使用二阶向后差分格式的存储影响，具体涉及跨物理时间步必须保留的解状态向量的最小数量，以及隐式伪时间积分通常需要的任何附加结构。\n\n用一个包含 $\\mathbf{M}$、$\\Delta t$、$\\mathbf{U}$、$\\mathbf{U}^{n}$、$\\mathbf{U}^{n-1}$ 和 $\\mathbf{R}(\\cdot)$ 的单一解析表达式来表示您关于 $\\mathcal{G}(\\mathbf{U})$ 的最终答案。无需进行数值计算。",
            "solution": "基本出发点是半离散守恒律\n$$\n\\mathbf{M}\\,\\frac{d\\mathbf{U}}{dt}+\\mathbf{R}(\\mathbf{U})=\\mathbf{0},\n$$\n其中 $\\mathbf{M}$ 集合了控制体测度，$\\mathbf{R}(\\mathbf{U})$ 代表通量和源项的空间离散。在双时间步法中，我们定义一个伪时间 $\\tau$，并在每个物理时间步求解一个形如下式的伪瞬态问题\n$$\n\\mathbf{M}\\,\\frac{\\partial \\mathbf{U}}{\\partial \\tau} + \\mathcal{G}(\\mathbf{U})=\\mathbf{0},\n$$\n将 $\\mathcal{G}(\\mathbf{U})\\to\\mathbf{0}$ 驱动至零，从而满足在 $t^{n+1}$ 处的物理时间离散平衡方程。因此，$\\mathcal{G}(\\mathbf{U})$ 是与在 $t^{n+1}$ 应用所选物理时间离散格式相关的残差，其中伪时间迭代中的 $\\mathbf{U}$ 代表 $\\mathbf{U}^{n+1}$ 的当前迭代值。\n\n为了构建二阶向后差分格式（2阶BDF）的 $\\mathcal{G}(\\mathbf{U})$，我们使用过去的数值 $\\mathbf{U}^{n}$ 和 $\\mathbf{U}^{n-1}$ 以及当前（未知）的 $\\mathbf{U}^{n+1}$ 来近似 $t^{n+1}$ 处的物理时间导数。设物理时间网格均匀，步长为 $\\Delta t$，因此 $t^{n+1}=t^{n}+\\Delta t$ 且 $t^{n-1}=t^{n}-\\Delta t$。定义 $j\\in\\{0,1,2\\}$ 使得时间点为 $t^{n+1-j}$。我们寻求满足以下条件的系数 $a_{j}$\n$$\n\\frac{d\\mathbf{U}}{dt}\\bigg|_{t^{n+1}} \\approx \\frac{1}{\\Delta t}\\sum_{j=0}^{2} a_{j}\\,\\mathbf{U}^{n+1-j},\n$$\n其相容性条件由围绕 $t^{n+1}$ 的泰勒展开导出。展开\n$$\n\\mathbf{U}^{n+1-j} = \\mathbf{U}^{n+1} + (-j)\\Delta t\\,\\mathbf{U}'(t^{n+1}) + \\frac{(-j)^{2}\\Delta t^{2}}{2}\\,\\mathbf{U}''(t^{n+1}) + \\frac{(-j)^{3}\\Delta t^{3}}{6}\\,\\mathbf{U}'''(t^{n+1}) + \\cdots.\n$$\n我们要求\n$$\n\\sum_{j=0}^{2} a_{j}\\,\\mathbf{U}^{n+1-j} = \\Delta t\\,\\mathbf{U}'(t^{n+1}) + \\mathcal{O}(\\Delta t^{3}),\n$$\n这给出了阶数条件\n$$\n\\sum_{j=0}^{2} a_{j} = 0,\\qquad \\sum_{j=0}^{2} a_{j}(-j) = 1,\\qquad \\sum_{j=0}^{2} a_{j}\\frac{(-j)^{2}}{2} = 0.\n$$\n对 $j\\in\\{0,1,2\\}$ 显式写出这些方程，\n$$\na_{0}+a_{1}+a_{2}=0,\\qquad -a_{1}-2a_{2}=1,\\qquad \\frac{a_{1}+4a_{2}}{2}=0.\n$$\n求解得，\n$$\na_{1}=-4a_{2},\\quad 4a_{2}-2a_{2}=1\\Rightarrow 2a_{2}=1\\Rightarrow a_{2}=\\frac{1}{2},\\quad a_{1}=-2,\\quad a_{0}= -a_{1}-a_{2}=\\frac{3}{2}.\n$$\n因此，\n$$\n\\frac{d\\mathbf{U}}{dt}\\bigg|_{t^{n+1}} \\approx \\frac{1}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}^{n+1}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right).\n$$\n将此近似应用于 $t^{n+1}$ 处的半离散平衡方程，可得\n$$\n\\mathbf{M}\\,\\frac{1}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}^{n+1}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right)+\\mathbf{R}(\\mathbf{U}^{n+1})=\\mathbf{0}.\n$$\n在双时间步法中，伪时间迭代使用 $\\mathbf{U}$ 来表示非线性残差内部对 $\\mathbf{U}^{n+1}$ 的当前近似。因此，需要被驱动至零的双时间残差为\n$$\n\\mathcal{G}(\\mathbf{U}) = \\mathbf{R}(\\mathbf{U}) + \\frac{\\mathbf{M}}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right).\n$$\n\n存储影响：使用二阶向后差分格式需要访问两个历史解状态，即 $\\mathbf{U}^{n}$ 和 $\\mathbf{U}^{n-1}$，以及用于 $\\mathbf{U}^{n+1}$ 的当前迭代值 $\\mathbf{U}$。因此，与仅保留 $\\mathbf{U}^{n}$ 的一阶向后欧拉法相比，2阶BDF将需要保留的最小历史状态数量增加到两个先前的向量。在隐式双时间积分中，通常还会存储一个雅可比矩阵或其近似（例如 $\\partial \\mathcal{G}/\\partial \\mathbf{U}$），以通过牛顿法或拟牛顿法加速收敛，并且，根据具体实现，如果质量矩阵 $\\mathbf{M}$ 不是简单的对角矩阵或不易应用，也需要存储它。对于大规模航空航天CFD，这意味着需要为 $\\mathbf{U}^{n-1}$ 增加一个向量的存储空间，并可能为伪时间迭代中的线性求解增加额外的算子存储，而残差结构本身除了 $\\mathbf{U}^{n}$ 和 $\\mathbf{U}^{n-1}$ 之外，不引入任何更早的历史状态。",
            "answer": "$$\\boxed{\\mathcal{G}(\\mathbf{U})=\\mathbf{R}(\\mathbf{U})+\\frac{\\mathbf{M}}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right)}$$"
        },
        {
            "introduction": "双时间步法的效率在很大程度上取决于内部伪时间迭代的收敛性。这个动手编程练习要求你建立一个简单的一维对流扩散模型，并观察该方法的一个关键行为：增大物理时间步长 $\\Delta t$ 如何使伪时间问题变得更“刚性”，从而降低内循环的收敛速度。通过将测量的迭代次数与基于谱分析的理论估计进行比较，你将对双时间步法的性能特征获得实践性的认识。",
            "id": "3956124",
            "problem": "您需要构建并分析一个一维空间中的刚性线性对流扩散模型，以研究计算流体动力学（CFD）中的双时间步（DTS）方法。从偏微分方程开始\n$$\n\\frac{\\partial u}{\\partial t} = -a\\,\\frac{\\partial u}{\\partial x} + \\nu\\,\\frac{\\partial^2 u}{\\partial x^2},\n$$\n其中 $u(x,t)$ 是传输扩散的标量，$a$ 是对流速度，$\\nu$ 是运动粘度。使用长度为 $L_x$ 的周期性域，其中 $x \\in [0,L_x]$，并采用周期性边界条件。在具有 $N$ 个点和间距 $\\Delta x = L_x/N$ 的均匀网格上离散化空间导数，对流项使用一阶迎风格式，扩散项使用二阶中心差分格式。设离散空间算子为 $N \\times N$ 矩阵 $\\mathbf{L}$，使得半离散系统为\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}\\,\\mathbf{u},\n$$\n其中\n$$\n\\mathbf{L}\\,\\mathbf{u} \\approx -a\\,\\frac{\\mathbf{u}_i - \\mathbf{u}_{i-1}}{\\Delta x} + \\nu\\,\\frac{\\mathbf{u}_{i+1} - 2\\,\\mathbf{u}_i + \\mathbf{u}_{i-1}}{\\Delta x^2},\n$$\n其中索引对 $N$ 取模以强制周期性。使用隐式向后欧拉步长将解在物理时间上从 $t^n$推进到 $t^{n+1}$：\n$$\n\\mathbf{u}^{n+1} - \\mathbf{u}^{n} = \\Delta t\\,\\mathbf{L}\\,\\mathbf{u}^{n+1}.\n$$\n这可以写成非线性残差方程\n$$\n\\mathbf{F}(\\mathbf{u}^{n+1}) = \\mathbf{u}^{n+1} - \\mathbf{u}^n - \\Delta t\\,\\mathbf{L}\\,\\mathbf{u}^{n+1} = \\mathbf{0},\n$$\n其雅可比矩阵为线性矩阵\n$$\n\\mathbf{J} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{u}} = \\mathbf{I} - \\Delta t\\,\\mathbf{L}.\n$$\n在双时间步法中，通过引入伪时间 $\\tau$ 并推进辅助系统来求解 $\\mathbf{F}(\\mathbf{u}^{n+1}) = \\mathbf{0}$\n$$\n\\frac{d\\mathbf{u}}{d\\tau} + \\mathbf{F}(\\mathbf{u}) = \\mathbf{0}.\n$$\n在伪时间内实现前向欧拉法，对于线性残差，这将产生一个类理查森迭代：\n$$\n\\mathbf{u}^{k+1} = \\mathbf{u}^{k} - \\omega\\,\\mathbf{F}(\\mathbf{u}^k), \\quad \\omega > 0,\n$$\n从初始猜测 $\\mathbf{u}^0 = \\mathbf{u}^n$ 开始。根据 $\\mathbf{J}$ 的谱半径估计选择伪时间步长参数 $\\omega$，以促进收敛。测量所需的伪时间迭代次数 $k$，使得残差范数满足\n$$\n\\|\\mathbf{F}(\\mathbf{u}^{k})\\|_2 \\le \\varepsilon\\,\\|\\mathbf{F}(\\mathbf{u}^{0})\\|_2,\n$$\n对于给定的容差 $0  \\varepsilon \\ll 1$。\n\n从第一性原理出发，论证离散算子的刚性是如何随着网格加密而出现的，以及增加物理时间步长 $\\Delta t$ 如何对伪时间迭代中的内收敛构成挑战。使用 $\\mathbf{J}$ 的谱特性来估计迭代的收缩因子，从而预测迭代次数。将这些预测值与测量值进行比较。\n\n科学和数值设置：\n- 使用 $L_x = 1$（米），$N = 64$，$a = 20$（米/秒），以及 $\\nu = 10^{-2}$（平方米/秒）。\n- 使用初始物理状态 $\\mathbf{u}^{n}_i = \\sin\\!\\left(2\\pi x_i\\right)$，其中 $x_i = i\\,\\Delta x$。\n- 残差范数的相对减小采用容差 $\\varepsilon = 10^{-6}$。\n- 所有物理量必须使用指定的单位处理：$L_x$ 以米为单位，$a$ 以米/秒为单位，$\\nu$ 以平方米/秒为单位，$\\Delta t$ 以秒为单位。角度（如果有）必须以弧度为单位。\n\n测试套件：\n- 考虑四个以秒为单位的物理时间步长 $\\Delta t$，用于探究不断增加的刚性和内迭代难度：$\\Delta t \\in \\{5\\times 10^{-4},\\,2\\times 10^{-3},\\,10^{-2},\\,2\\times 10^{-2}\\}$。\n- 对于每个 $\\Delta t$，计算：\n  1. 达到容差所需的测量的伪时间迭代次数。\n  2. 假定一个与谱特性一致的几何误差缩减模型，根据对 $\\mathbf{J}$ 的谱半径和所选 $\\omega$ 的考虑，得出的迭代次数估计值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个元素应为一个双元素整数列表，形式为 $[\\text{measured},\\text{estimated}]$，例如 $[[k_1,\\hat{k}_1],[k_2,\\hat{k}_2],[k_3,\\hat{k}_3],[k_4,\\hat{k}_4]]$。",
            "solution": "该问题的核心是分析和量化一个类理查森迭代求解器在求解由隐式时间步进格式产生的线性系统时的性能。问题的难度由物理时间步长 $\\Delta t$ 控制。\n\n**1. 算子的谱分析与刚性来源**\n由于采用了周期性边界条件和均匀网格，离散空间算子 $\\mathbf{L}$ 是一个循环矩阵。它的特征向量是离散傅里叶模态 $\\mathbf{v}_p$，其分量为 $(\\mathbf{v}_p)_j = \\exp(i k_p x_j)$，其中波数 $k_p = 2\\pi p/L_x$，整数 $p \\in \\{0, 1, \\dots, N-1\\}$。通过将离散算子作用于这些特征向量，可以得到相应的特征值 $\\lambda_L(p)$。设 $\\theta_p = k_p \\Delta x = 2\\pi p/N$，则\n$$ \\lambda_L(p) = -a \\frac{1-e^{-i\\theta_p}}{\\Delta x} + \\nu \\frac{e^{i\\theta_p} - 2 + e^{-i\\theta_p}}{\\Delta x^2} $$\n简化后得到：\n$$ \\lambda_L(p) = -\\left(\\frac{a}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2}\\right)(1-\\cos\\theta_p) - i \\left(\\frac{a}{\\Delta x}\\right)\\sin\\theta_p $$\n所有特征值 $\\lambda_L(p)$ 的实部都非正，这保证了物理系统的稳定性。\n**刚性来源：** 算子 $\\mathbf{L}$ 的谱（特征值集合）的范围决定了系统的刚性。随着网格加密，$\\Delta x \\to 0$，$\\nu/\\Delta x^2$ 项占主导地位，使得特征值的最大模 $|\\lambda_L(p)|_{\\max}$ 迅速增大。特征值的大范围分布（即谱半径与最小非零特征值之比很大）正是系统刚性的体现。\n\n**2. 内迭代的收敛性分析**\n隐式后向欧拉格式产生线性系统 $(\\mathbf{I} - \\Delta t \\mathbf{L})\\mathbf{u}^{n+1} = \\mathbf{u}^n$，即 $\\mathbf{J}\\mathbf{u}^{n+1} = \\mathbf{u}^n$。双时间步法采用的理查森迭代为：\n$$ \\mathbf{u}^{k+1} = \\mathbf{u}^{k} - \\omega (\\mathbf{J}\\mathbf{u}^k - \\mathbf{u}^n) $$\n其误差 $\\mathbf{e}^k = \\mathbf{u}^k - \\mathbf{u}^{n+1}$ 的演化遵循 $\\mathbf{e}^{k+1} = (\\mathbf{I} - \\omega\\mathbf{J})\\mathbf{e}^k$。收敛性由迭代矩阵 $\\mathbf{G} = \\mathbf{I} - \\omega\\mathbf{J}$ 的谱半径 $\\rho_G = \\rho(\\mathbf{G})$ 决定。$\\mathbf{J}$ 的特征值为 $\\lambda_J(p) = 1 - \\Delta t \\lambda_L(p)$。迭代矩阵 $\\mathbf{G}$ 的特征值为 $\\lambda_G(p) = 1 - \\omega\\lambda_J(p)$。\n\n**3. 迭代次数的估计**\n为了估计迭代次数，我们选择松弛参数 $\\omega = 1/\\rho(\\mathbf{J})$，其中 $\\rho(\\mathbf{J}) = \\max_p |\\lambda_J(p)|$ 是雅可比矩阵的谱半径。然后计算理论收敛因子 $\\rho_G = \\max_p |1 - \\lambda_J(p)/\\rho(\\mathbf{J})|$。将残差范数减小 $\\varepsilon$ 倍所需的迭代次数 $k$ 可由 $(\\rho_G)^k \\le \\varepsilon$ 估计。解出 $k$ 可得：\n$$ k_{\\text{est}} = \\left\\lceil \\frac{\\ln(\\varepsilon)}{\\ln(\\rho_G)} \\right\\rceil $$\n**增大物理时间步长 $\\Delta t$ 的挑战：** 随着 $\\Delta t$ 增加，$\\mathbf{J}$ 的特征值 $\\lambda_J(p) = 1 - \\Delta t \\lambda_L(p)$ 在复平面上分布得更广，其谱半径 $\\rho(\\mathbf{J})$ 随之增大。对于零频模式（$p=0$），$\\lambda_L(0)=0$，因此 $\\lambda_J(0)=1$。对应的迭代矩阵特征值为 $\\lambda_G(0) = 1 - \\omega\\lambda_J(0) = 1 - 1/\\rho(\\mathbf{J})$。当 $\\Delta t$ 增大时，$\\rho(\\mathbf{J})$ 变大，$\\lambda_G(0)$ 趋近于 1。这意味着对应于最低频误差分量的收敛因子接近1，收敛变得极其缓慢。因此，增大物理时间步长 $\\Delta t$ 使内迭代问题更具挑战性（更刚性），需要更多的伪时间迭代才能达到收敛。将这些预测值与实际测量的迭代次数进行比较，可以验证这一理论分析。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a stiff linear convection–diffusion model\n    to study Dual Time Stepping (DTS) in aerospace CFD.\n    \"\"\"\n    # Scientific and numerical setup from the problem statement.\n    Lx = 1.0        # meters\n    N = 64          # number of grid points\n    a = 20.0        # m/s\n    nu = 1.0e-2     # m^2/s\n    epsilon = 1.0e-6  # residual reduction tolerance\n\n    # Discretization\n    dx = Lx / N\n    # Grid points x_i = i*dx for i=0..N-1\n    x = np.linspace(0, Lx, N, endpoint=False)\n\n    # Initial physical state u^n\n    u_n = np.sin(2.0 * np.pi * x)\n\n    # Test cases for physical time step\n    delta_t_cases = [5.0e-4, 2.0e-3, 1.0e-2, 2.0e-2]\n\n    # List to store results [measured_k, estimated_k] for each case\n    results = []\n\n    def apply_L(u, dx_val, a_val, nu_val):\n        \"\"\"Applies the discrete spatial operator L to a vector u.\"\"\"\n        # Enforce periodicity using np.roll\n        u_im1 = np.roll(u, 1)  # u_i-1\n        u_ip1 = np.roll(u, -1) # u_i+1\n\n        # First-order upwind for convection (a > 0)\n        conv_term = -a_val * (u - u_im1) / dx_val\n        # Second-order central for diffusion\n        diff_term = nu_val * (u_ip1 - 2.0 * u + u_im1) / dx_val**2\n\n        return conv_term + diff_term\n\n    # Loop over each test case for delta_t\n    for dt in delta_t_cases:\n        # --- Part 1: Theoretical Estimation of Iteration Count ---\n\n        # Wavenumber index for Fourier analysis\n        p = np.arange(N)\n        theta_p = 2.0 * np.pi * p / N\n\n        # Eigenvalues of the spatial operator L\n        term1 = (a / dx + 2.0 * nu / dx**2) * (1.0 - np.cos(theta_p))\n        term2 = (a / dx) * np.sin(theta_p)\n        lambda_L = -term1 - 1j * term2\n        \n        # Eigenvalues of the Jacobian J = I - dt*L\n        lambda_J = 1.0 - dt * lambda_L\n\n        # Spectral radius of J\n        rho_J = np.max(np.abs(lambda_J))\n\n        # Pseudo-time step parameter omega, based on rho(J)\n        omega = 1.0 / rho_J\n\n        # Eigenvalues of the iteration matrix G = I - omega*J\n        lambda_G = 1.0 - omega * lambda_J\n\n        # Contraction factor (spectral radius of G)\n        rho_G = np.max(np.abs(lambda_G))\n\n        # Estimate the number of iterations\n        # k >= log(epsilon) / log(rho_G)\n        k_est = int(np.ceil(np.log(epsilon) / np.log(rho_G)))\n\n        # --- Part 2: Measured Iteration Count from Simulation ---\n\n        k_meas = 0\n        u_k = np.copy(u_n) # Initial guess u^0 = u^n\n\n        def calculate_F(u, dt_val, u_n_val):\n            \"\"\"Residual function F(u) = (I - dt*L)u - u_n\"\"\"\n            return u - dt_val * apply_L(u, dx, a, nu) - u_n_val\n\n        # Initial residual F_0 = F(u^0)\n        F_0 = calculate_F(u_k, dt, u_n)\n        norm_F0 = np.linalg.norm(F_0)\n        \n        # Check for trivial case where initial residual is already zero\n        if norm_F0 == 0:\n            results.append([0, k_est])\n            continue\n\n        target_norm = epsilon * norm_F0\n        \n        F_k = F_0\n        # safety break to prevent pathologically long or infinite loops\n        max_iterations = 3 * k_est if k_est > 0 else 500000 \n        \n        # Pseudo-time iteration loop\n        while np.linalg.norm(F_k) > target_norm:\n            # Richardson-like iteration: u_{k+1} = u_k - omega * F(u_k)\n            u_k -= omega * F_k\n            # Update residual\n            F_k = calculate_F(u_k, dt, u_n)\n            k_meas += 1\n            \n            # Safety break\n            if k_meas > max_iterations:\n                # This indicates divergence or extremely slow convergence\n                # not captured by the simple estimate.\n                k_meas = -1 # Use a sentinel value for failure\n                break\n\n        results.append([k_meas, k_est])\n\n    # Format the final output according to the problem specification\n    formatted_results = [f\"[{m},{e}]\" for m, e in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的CFD计算中，一个关键问题是“多大程度的内循环收敛才算足够？”。这个高级练习超越了简单的收敛性分析，利用一个衰减湍流模型来探讨伪时间残差容差与解的物理精度之间的直接联系。你将推导欠收敛和谱误差之间的关系，然后提出一种先进的容差设置策略，以确保计算出的能谱达到预期的精度水平。",
            "id": "3956111",
            "problem": "考虑无量纲环境下的衰减各向同性湍流。令能量谱表示为 $E(k,t)$，其中 $k$ 是无量纲波数，$t$ 是无量纲时间。从不可压缩 Navier-Stokes 方程推导出的谱能量平衡出发，能量谱演化的粘性贡献由经过充分检验的关系式 $\\,\\partial_t E(k,t) = - 2 \\mu k^2 E(k,t)\\,$ 给出，其中 $\\mu$ 是无量纲运动粘度。为了本次分析，忽略单个物理时间步长内的非线性谱传递，因此一个时间步长内的演化由粘性项主导。使用物理时间步长 $\\Delta t > 0$ 对时间进行从时间层 $n$ 到 $n+1$ 的后向欧拉步进离散化，得到以下形式的半离散方程\n$$\nA_k E_k^{n+1} = E_k^n,\\quad \\text{with}\\quad A_k = 1 + 2 \\mu k^2 \\Delta t,\n$$\n其中 $E_k^n \\equiv E(k,t^n)$ 且 $E_k^{n+1} \\equiv E(k,t^{n+1})$。\n\n在计算流体动力学（CFD）的非定常问题双时间步方法中，使用伪时间内的内迭代通过将残差趋于零来近似满足后向欧拉平衡。将波数 $k$ 的残差定义为\n$$\nR_k(E) = A_k E - E_k^n.\n$$\n如果内迭代提前终止，使得每个模态的最终残差范数满足 $|R_k(E_k^{n+1,\\text{approx}})| \\le \\varepsilon_k$（对于某个给定的残差容差 $\\varepsilon_k$），则会发生欠收敛。这种欠收敛会在时间层 $n+1$ 的谱中引入误差。\n\n您的任务是：\n- 使用上述半离散线性模型，从第一性原理出发，推导谱误差 $\\,\\Delta E_k = E_k^{n+1,\\text{approx}} - E_k^{n+1}\\,$ 作为 $\\,A_k\\,$ 和在欠收敛解处计算的残差 $\\,R_k\\,$ 的函数表达式。\n- 使用该表达式，推导相对谱误差 $\\,\\rho_k = \\left|\\Delta E_k\\right| / \\left|E_k^{n+1}\\right|\\,$，并解释不同的残差容差策略如何影响不同波数的 $\\,\\rho_k\\,$。\n- 提出一种残差容差策略，该策略能保证在指定波数带 $\\,\\mathcal{B}\\,$ 上达到用户指定的光谱精度目标 $\\,\\delta_{\\text{spec}} > 0\\,$，即满足 $\\,\\max_{k \\in \\mathcal{B}} \\rho_k \\le \\delta_{\\text{spec}}\\,$。\n\n数值评估要求：\n- 使用类似 von Kármán 的无量纲初始谱形\n$$\n\\tilde{E}(k; k_p) = k^4 \\exp\\!\\left(-2\\left(\\frac{k}{k_p}\\right)^2\\right),\n$$\n并定义 $\\,E_k^n = C \\,\\tilde{E}(k; k_p)\\,$，其中 $\\,C > 0\\,$ 的选择应使离散能量满足 $\\sum_{k=1}^{K_{\\max}} E_k^n \\,\\Delta k = 1$，且 $\\,\\Delta k = 1\\,$，波数 $\\,k = 1,2,\\dots,K_{\\max}\\,$ 为整数。\n- 计算精确的后向欧拉更新 $\\,E_k^{n+1} = E_k^n / A_k\\,$ 以及一个欠收敛的近似更新 $\\,E_k^{n+1,\\text{approx}}$，该近似更新通过将残差饱和到容差来构造，即设置 $\\,|R_k(E_k^{n+1,\\text{approx}})| = \\varepsilon_k\\,$ 并使用您推导的误差关系来定义 $\\,E_k^{n+1,\\text{approx}}\\,$。\n- 考虑两种容差策略：\n    1. 绝对残差容差：对所有 $\\,k\\,$，$\\,\\varepsilon_k = \\varepsilon_{\\text{abs}}\\,$。\n    2. 相对残差容差：对所有 $\\,k\\,$，$\\,\\varepsilon_k = \\varepsilon_{\\text{rel}}\\,E_k^n\\,$。\n- 对于每种策略，计算每个模态的相对误差 $\\,\\rho_k\\,$，然后在波数带 $\\,\\mathcal{B} = \\{k \\in \\mathbb{Z} : k_{\\min} \\le k \\le k_{\\max}\\}\\,$ 上计算：\n    - 带内相对误差的均方根\n    $$\n    \\rho_{\\text{L2}} = \\sqrt{\\frac{1}{|\\mathcal{B}|}\\sum_{k \\in \\mathcal{B}} \\rho_k^2},\n    $$\n    - 带内最大相对误差\n    $$\n    \\rho_{\\infty} = \\max_{k \\in \\mathcal{B}} \\rho_k.\n    $$\n- 给定一个目标 $\\,\\delta_{\\text{spec}}\\,$，计算保证在 $\\,\\mathcal{B}\\,$ 上 $\\,\\rho_{\\infty} \\le \\delta_{\\text{spec}}\\,$ 的最小绝对容差 $\\,\\varepsilon_{\\text{abs}}^{\\star}\\,$。同时，陈述为保证相同目标而对相对容差 $\\,\\varepsilon_{\\text{rel}}\\,$ 的相应建议。\n- 对于每种情况，报告所提供的 $\\,\\varepsilon_{\\text{abs}}\\,$ 和 $\\,\\varepsilon_{\\text{rel}}\\,$ 是否达到目标，即对于每种策略，在 $\\,\\mathcal{B}\\,$ 中是否 $\\,\\rho_{\\infty} \\le \\delta_{\\text{spec}}\\,$。\n\n测试套件：\n使用以下三组参数集，均为无量纲，且 $\\,\\Delta k = 1\\,$，波数 $\\,k = 1,2,\\dots,K_{\\max}\\,$ 为整数。\n\n- 案例 1（理想情况）：\n    - $K_{\\max} = 64$\n    - $k_p = 8$\n    - $\\mu = 10^{-3}$\n    - $\\Delta t = 5\\times 10^{-2}$\n    - $\\varepsilon_{\\text{abs}} = 10^{-6}$\n    - $\\varepsilon_{\\text{rel}} = 10^{-3}$\n    - 波数带 $\\,\\mathcal{B}\\,$: $k_{\\min} = 4$, $k_{\\max} = 16$\n    - $\\delta_{\\text{spec}} = 10^{-3}$\n- 案例 2（宽松的绝对容差，高 $k$ 波数带）：\n    - $K_{\\max} = 64$\n    - $k_p = 12$\n    - $\\mu = 10^{-3}$\n    - $\\Delta t = 5\\times 10^{-2}$\n    - $\\varepsilon_{\\text{abs}} = 10^{-3}$\n    - $\\varepsilon_{\\text{rel}} = 10^{-2}$\n    - 波数带 $\\,\\mathcal{B}\\,$: $k_{\\min} = 16$, $k_{\\max} = 48$\n    - $\\delta_{\\text{spec}} = 5\\times 10^{-3}$\n- 案例 3（较大的粘度和时间步长）：\n    - $K_{\\max} = 64$\n    - $k_p = 6$\n    - $\\mu = 5\\times 10^{-3}$\n    - $\\Delta t = 2\\times 10^{-1}$\n    - $\\varepsilon_{\\text{abs}} = 10^{-5}$\n    - $\\varepsilon_{\\text{rel}} = 10^{-4}$\n    - 波数带 $\\,\\mathcal{B}\\,$: $k_{\\min} = 2$, $k_{\\max} = 32$\n    - $\\delta_{\\text{spec}} = 10^{-4}$\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含三个案例的结果，格式为逗号分隔的 Python 风格列表的列表，每个内部列表按顺序包含：\n    - $\\,\\rho_{\\text{L2}}$ （对于绝对容差策略），\n    - $\\,\\rho_{\\infty}$ （对于绝对容差策略），\n    - $\\,\\rho_{\\text{L2}}$ （对于相对容差策略），\n    - $\\,\\rho_{\\infty}$ （对于相对容差策略），\n    - $\\,\\varepsilon_{\\text{abs}}^{\\star}$ 作为推荐的绝对容差，以保证在指定波数带上 $\\,\\rho_{\\infty} \\le \\delta_{\\text{spec}}\\,$，\n    - 一个布尔值，指示所提供的 $\\,\\varepsilon_{\\text{abs}}$ 是否达到目标，\n    - 一个布尔值，指示所提供的 $\\,\\varepsilon_{\\text{rel}}$ 是否达到目标。\n例如，输出应类似于单个 Python 列表字符串：$[ [x_1,x_2,x_3,x_4,x_5,b_1,b_2], [\\dots], [\\dots] ]$ 其中每个 $x_i$ 是浮点数，每个 $b_i$ 是布尔值。",
            "solution": "### 1. 谱误差的推导\n设 $E_k^{n+1}$ 为后向欧拉方程的精确解，它满足 $A_k E_k^{n+1} = E_k^n$，其中 $A_k = 1 + 2 \\mu k^2 \\Delta t$。根据定义，精确解的残差为零：$R_k(E_k^{n+1}) = A_k E_k^{n+1} - E_k^n = 0$。\n\n双时间步内迭代提前终止时，得到一个近似解 $E_k^{n+1,\\text{approx}}$，其残差 $R_k^{\\text{approx}}$ 不为零：\n$$R_k^{\\text{approx}} \\equiv R_k(E_k^{n+1,\\text{approx}}) = A_k E_k^{n+1,\\text{approx}} - E_k^n$$\n谱误差 $\\Delta E_k = E_k^{n+1,\\text{approx}} - E_k^{n+1}$。从上述方程中，我们可以分别表示精确解和近似解：\n$$E_k^{n+1} = \\frac{E_k^n}{A_k}$$\n$$E_k^{n+1,\\text{approx}} = \\frac{E_k^n + R_k^{\\text{approx}}}{A_k}$$\n将两者相减，得到谱误差与残差之间的关系：\n$$\\Delta E_k = \\frac{R_k^{\\text{approx}}}{A_k}$$\n\n### 2. 相对谱误差与容差策略分析\n相对谱误差 $\\rho_k$ 定义为 $\\rho_k = |\\Delta E_k| / |E_k^{n+1}|$。由于能量谱 $E(k,t)$ 是非负的，我们可以去掉绝对值符号：\n$$\\rho_k = \\frac{|\\Delta E_k|}{E_k^{n+1}} = \\frac{|R_k^{\\text{approx}} / A_k|}{E_k^n / A_k}$$\n因为 $A_k > 0$，上式简化为：\n$$\\rho_k = \\frac{|R_k^{\\text{approx}}|}{E_k^n}$$\n在最坏情况下，残差饱和到容差极限，即 $|R_k^{\\text{approx}}| = \\varepsilon_k$。因此，$\\rho_k = \\varepsilon_k / E_k^n$。\n\n1.  **绝对残差容差** ($\\varepsilon_k = \\varepsilon_{\\text{abs}}$):\n    此时相对谱误差为 $\\rho_k = \\varepsilon_{\\text{abs}} / E_k^n$。误差与前一时间步的能量成反比。对于能量较低的高波数区域，该策略会导致非常大的相对误差，无法统一控制精度。\n\n2.  **相对残差容差** ($\\varepsilon_k = \\varepsilon_{\\text{rel}} E_k^n$):\n    此时相对谱误差为 $\\rho_k = (\\varepsilon_{\\text{rel}} E_k^n) / E_k^n = \\varepsilon_{\\text{rel}}$。该策略在所有波数上产生恒定的相对谱误差，是确保统一精度的更优选择。\n\n### 3. 保证光谱精度的容差策略\n目标是保证在波数带 $\\mathcal{B}$ 上，$\\max_{k \\in \\mathcal{B}} \\rho_k \\le \\delta_{\\text{spec}}$。\n利用关系式 $\\rho_k = \\varepsilon_k / E_k^n$，我们必须满足：\n$$\\frac{\\varepsilon_k}{E_k^n} \\le \\delta_{\\text{spec}} \\quad \\text{对所有 } k \\in \\mathcal{B}$$\n- **推荐的相对容差**: 最直接的策略是设置与目标精度匹配的相对容差，即对所有 $k$ 设置 $\\varepsilon_k = \\delta_{\\text{spec}} E_k^n$。这对应于选择 $\\varepsilon_{\\text{rel}} = \\delta_{\\text{spec}}$。\n- **推荐的绝对容差**: 如果必须使用常数绝对容差 $\\varepsilon_{\\text{abs}}^{\\star}$，则必须满足 $\\max_{k \\in \\mathcal{B}} (\\varepsilon_{\\text{abs}}^{\\star} / E_k^n) \\le \\delta_{\\text{spec}}$。为确保这一点，必须基于频带内能量最小（即 $1/E_k^n$ 最大）的模式来设定容差。令 $E_{\\min,\\mathcal{B}}^n = \\min_{k \\in \\mathcal{B}} E_k^n$，则条件变为 $\\varepsilon_{\\text{abs}}^{\\star} / E_{\\min,\\mathcal{B}}^n \\le \\delta_{\\text{spec}}$。为找到最宽松（最大）的容差，我们取等号：\n$$\\varepsilon_{\\text{abs}}^{\\star} = \\delta_{\\text{spec}} \\cdot E_{\\min,\\mathcal{B}}^n$$\n这表明，为保证整个频带的精度，绝对容差必须由该频带内最弱的能量模式来决定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(params):\n    \"\"\"\n    Solves for one set of parameters as defined in the problem.\n    \"\"\"\n    K_max = params['K_max']\n    k_p = params['k_p']\n    mu = params['mu']\n    delta_t = params['delta_t']\n    eps_abs = params['eps_abs']\n    eps_rel = params['eps_rel']\n    k_min_band = params['k_min_band']\n    k_max_band = params['k_max_band']\n    delta_spec = params['delta_spec']\n    delta_k = 1.0\n\n    # 1. Setup wavenumbers\n    k_vals = np.arange(1, K_max + 1, dtype=float)\n\n    # 2. Compute initial spectrum E_k^n\n    # Unnormalized spectrum shape\n    E_tilde = k_vals**4 * np.exp(-2.0 * (k_vals / k_p)**2)\n    # Normalization constant C such that sum(C * E_tilde * delta_k) = 1\n    total_energy_unnormalized = np.sum(E_tilde * delta_k)\n    C = 1.0 / total_energy_unnormalized\n    # Normalized spectrum E_k^n\n    E_k_n = C * E_tilde\n\n    # 3. Define the analysis band B\n    band_indices = np.where((k_vals >= k_min_band)  (k_vals = k_max_band))[0]\n    E_k_n_band = E_k_n[band_indices]\n    num_modes_in_band = len(band_indices)\n\n    # 4. Analysis for Absolute Tolerance Policy\n    # Relative error per mode: rho_k = eps_abs / E_k^n\n    rho_k_abs = eps_abs / E_k_n\n    \n    # Filter for the band B\n    rho_k_abs_band = rho_k_abs[band_indices]\n\n    # Compute metrics over the band\n    rho_L2_abs = np.sqrt(np.sum(rho_k_abs_band**2) / num_modes_in_band)\n    rho_inf_abs = np.max(rho_k_abs_band)\n    meets_target_abs = rho_inf_abs = delta_spec\n\n    # 5. Analysis for Relative Tolerance Policy\n    # Relative error per mode: rho_k = (eps_rel * E_k^n) / E_k^n = eps_rel\n    # The relative error is constant for all modes.\n    rho_L2_rel = eps_rel\n    rho_inf_rel = eps_rel\n    meets_target_rel = rho_inf_rel = delta_spec\n    \n    # 6. Compute Optimal Absolute Tolerance eps_abs_star\n    # eps_abs_star = delta_spec * min_{k in B} E_k^n\n    E_min_band = np.min(E_k_n_band)\n    eps_abs_star = delta_spec * E_min_band\n    \n    # 7. Package results\n    return [\n        rho_L2_abs,\n        rho_inf_abs,\n        rho_L2_rel,\n        rho_inf_rel,\n        eps_abs_star,\n        meets_target_abs,\n        meets_target_rel\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            'K_max': 64, 'k_p': 8, 'mu': 1e-3, 'delta_t': 5e-2, \n            'eps_abs': 1e-6, 'eps_rel': 1e-3, \n            'k_min_band': 4, 'k_max_band': 16, \n            'delta_spec': 1e-3\n        },\n        # Case 2 (loose absolute tolerance, high-k band)\n        {\n            'K_max': 64, 'k_p': 12, 'mu': 1e-3, 'delta_t': 5e-2, \n            'eps_abs': 1e-3, 'eps_rel': 1e-2, \n            'k_min_band': 16, 'k_max_band': 48, \n            'delta_spec': 5e-3\n        },\n        # Case 3 (larger viscosity and time step)\n        {\n            'K_max': 64, 'k_p': 6, 'mu': 5e-3, 'delta_t': 2e-1,\n            'eps_abs': 1e-5, 'eps_rel': 1e-4, \n            'k_min_band': 2, 'k_max_band': 32, \n            'delta_spec': 1e-4\n        }\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = run_case(case_params)\n        all_results.append(case_results)\n    \n    # Using a more direct string representation for robustness\n    # This avoids manual formatting issues with scientific notation and booleans\n    output_str = repr(all_results).replace(\" \", \"\")\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}