{
    "hands_on_practices": [
        {
            "introduction": "这项实践旨在建立一个重要的基准。我们将通过分析一个简化的场景——均匀正交网格上的标量扩散问题——来推导单元中心和顶点中心格式产生相同离散算子的条件。这项练习揭示了两种布局在最简单形式下的基本关系，并为理解它们在更复杂情况下的差异奠定了基础。",
            "id": "3947053",
            "problem": "考虑一个在航空航天计算流体力学 (CFD) 中常用的二维标量扩散模型：作用于光滑标量场 $u(x,y)$ 的常系数椭圆算子，\n$$\\mathcal{L}u = \\nabla \\cdot \\left(\\kappa \\nabla u\\right),$$\n其中 $\\kappa$ 是一个正常数，$(x,y)$ 位于一个矩形计算域中。设该域被一个正交、均匀的笛卡尔网格离散化，其网格间距相等，即 $\\Delta x = \\Delta y = h$，并考虑两种离散格式：\n\n- 一种单元中心格式，在矩形控制体上使用算子的积分形式（有限体积），其中面法向通量通过对至多1次的多项式精确的线性重构来近似，并使用每个面上的中点求积进行计算。\n- 一种节点中心格式，在网格节点上使用算子的逐点有限差分近似，采用中心差分，并由与坐标方向对齐的均匀模板构建。\n\n从散度定理和关于一个通用网格位置的泰勒展开出发，在不引入任何额外修正项的情况下，推导使这两种格式产生的离散算子在该网格上变得相同的网格几何条件和重构规则。然后，在这些条件下，将离散拉普拉斯算子在网格位置 $(x,y)$ 的主截断误差定义为局部展开式中的系数 $C$\n$$\\mathcal{L}_h u(x,y) - \\mathcal{L}u(x,y) = C\\,h^{2}\\left(u_{xxxx}(x,y) + u_{yyyy}(x,y)\\right) + \\mathcal{O}\\!\\left(h^{4}\\right),$$\n其中 $\\mathcal{L}_h$ 表示离散算子，$u_{xxxx}$ 和 $u_{yyyy}$ 是 $u$ 的四阶偏导数。计算两种格式的主截断误差常数之差，\n$$C_{\\mathrm{cc}} - C_{\\mathrm{vc}},$$\n其中 $C_{\\mathrm{cc}}$ 对应于单元中心算子，$C_{\\mathrm{vc}}$ 对应于节点中心算子，并以单个实数形式给出最终答案。无需四舍五入。",
            "solution": "该问题要求对均匀笛卡尔网格上扩散算子 $\\mathcal{L}u = \\nabla \\cdot (\\kappa \\nabla u)$ 的两种常见离散化方案进行比较分析。\n\n设网格节点由 $(i,j)$ 索引，对应于物理坐标 $(x_i, y_j) = (i h, j h)$。设 $u_{i,j}$ 表示标量场 $u$ 在该位置的值，即 $u_{i,j} = u(x_i, y_j)$。\n\n**1. 节点中心 (VC) 离散算子的推导**\n\n在节点中心格式中，离散值 $u_{i,j}$ 与网格节点相关联。算子 $\\mathcal{L}_h^{\\mathrm{vc}}$ 是在节点 $(i,j)$ 处对 $\\mathcal{L}u = \\kappa (\\partial^2u/\\partial x^2 + \\partial^2u/\\partial y^2)$ 的逐点近似。使用标准的二阶中心差分公式来表示二阶偏导数：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(i,j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n将这些代入 $\\mathcal{L}u$ 的表达式中，得到离散的节点中心算子：\n$$\n\\mathcal{L}_h^{\\mathrm{vc}} u_{i,j} = \\kappa \\left( \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\right)\n$$\n$$\n\\mathcal{L}_h^{\\mathrm{vc}} u_{i,j} = \\frac{\\kappa}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} \\right)\n$$\n这是拉普拉斯算子著名的五点模板。\n\n**2. 单元中心 (CC) 离散算子的推导**\n\n在单元中心（有限体积）格式中，值 $u_{i,j}$ 与控制体 $V_{i,j}$ 的中心相关联。对于此网格，控制体是一个边长为 $h$、中心位于 $(x_i, y_j)$ 的正方形，定义为 $V_{i,j} = [x_i - h/2, x_i + h/2] \\times [y_j - h/2, y_j + h/2]$。控制体的面积为 $A = h^2$。\n\n有限体积法近似了 $\\mathcal{L}u$ 在单元上的平均值：\n$$\n\\frac{1}{A} \\int_{V_{i,j}} \\mathcal{L}u \\, dA = \\frac{1}{h^2} \\int_{V_{i,j}} \\nabla \\cdot (\\kappa \\nabla u) \\, dA\n$$\n应用散度定理，体积分被转换为在控制体边界面 $\\partial V_{i,j}$ 上的积分：\n$$\n\\frac{1}{h^2} \\oint_{\\partial V_{i,j}} (\\kappa \\nabla u) \\cdot \\mathbf{n} \\, ds\n$$\n其中 $\\mathbf{n}$ 是向外法向量。该积分是流经四个面（东($e$)、西($w$)、北($n$)、南($s$)）的通量之和。\n$$\n\\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{1}{h^2} \\left( F_e - F_w + F_n - F_s \\right)\n$$\n通量由 $F = \\int_{\\text{face}} \\kappa \\nabla u \\cdot \\mathbf{n} \\, ds$ 给出。问题指定使用中点求积，因此通过一个面的通量是该面的长度乘以在面中点处计算的被积函数的值。\n\n- **东面 ($e$)**：中心位于 $(x_{i+1/2}, y_j)$，法向量 $\\mathbf{n}=(1,0)$，长度 $h$。通量 $F_e \\approx h \\left(\\kappa \\frac{\\partial u}{\\partial x}\\right)\\big|_{i+1/2,j}$。\n- **西面 ($w$)**：中心位于 $(x_{i-1/2}, y_j)$，法向量 $\\mathbf{n}=(-1,0)$，长度 $h$。向外通量为 $h \\left(\\kappa \\frac{\\partial u}{\\partial x}\\right)\\big|_{i-1/2,j}$。\n- **北面 ($n$)**：中心位于 $(x_i, y_{j+1/2})$，法向量 $\\mathbf{n}=(0,1)$，长度 $h$。通量 $F_n \\approx h \\left(\\kappa \\frac{\\partial u}{\\partial y}\\right)\\big|_{i,j+1/2}$。\n- **南面 ($s$)**：中心位于 $(x_i, y_{j-1/2})$，法向量 $\\mathbf{n}=(0,-1)$，长度 $h$。向外通量为 $h \\left(\\kappa \\frac{\\partial u}{\\partial y}\\right)\\big|_{i,j-1/2}$。\n\n问题陈述梯度由对1次多项式精确的线性重构来近似。对于均匀网格，这对应于在面中点使用中心差分，该差分使用相邻的单元中心值：\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{i+1/2,j} \\approx \\frac{u_{i+1,j} - u_{i,j}}{h} \\quad , \\quad \\frac{\\partial u}{\\partial x}\\bigg|_{i-1/2,j} \\approx \\frac{u_{i,j} - u_{i-1,j}}{h}\n$$\n$$\n\\frac{\\partial u}{\\partial y}\\bigg|_{i,j+1/2} \\approx \\frac{u_{i,j+1} - u_{i,j}}{h} \\quad , \\quad \\frac{\\partial u}{\\partial y}\\bigg|_{i,j-1/2} \\approx \\frac{u_{i,j} - u_{i,j-1}}{h}\n$$\n将这些代入通量表达式中：\n$$\nF_e \\approx \\kappa h \\frac{u_{i+1,j} - u_{i,j}}{h} = \\kappa(u_{i+1,j} - u_{i,j})\n$$\n$$\nF_w \\approx \\kappa h \\frac{u_{i,j} - u_{i-1,j}}{h} = \\kappa(u_{i,j} - u_{i-1,j})\n$$\n$$\nF_n \\approx \\kappa h \\frac{u_{i,j+1} - u_{i,j}}{h} = \\kappa(u_{i,j+1} - u_{i,j})\n$$\n$$\nF_s \\approx \\kappa h \\frac{u_{i,j} - u_{i,j-1}}{h} = \\kappa(u_{i,j} - u_{i,j-1})\n$$\n则总和为：\n$$\n\\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{1}{h^2} \\left[ \\kappa(u_{i+1,j} - u_{i,j}) - \\kappa(u_{i,j} - u_{i-1,j}) + \\kappa(u_{i,j+1} - u_{i,j}) - \\kappa(u_{i,j} - u_{i,j-1}) \\right]\n$$\n简化此表达式可得：\n$$\n\\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{\\kappa}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} \\right)\n$$\n\n**3. 算子相同的条件**\n\n比较第1部分和第2部分的结果，我们发现 $\\mathcal{L}_h^{\\mathrm{vc}} u_{i,j} = \\mathcal{L}_h^{\\mathrm{cc}} u_{i,j}$。这两个离散算子是相同的。此同一性的条件正是问题陈述中指定的那些条件：\n- 网格必须是均匀、正交的笛卡尔网格。\n- 有限差分格式必须使用标准的二阶中心差分。\n- 有限体积格式必须对通量使用中点求积，并使用基于两个相邻单元中心值的中心差分来近似面法向梯度。\n\n**4. 截断误差分析**\n\n由于 $\\mathcal{L}_h^{\\mathrm{cc}} = \\mathcal{L}_h^{\\mathrm{vc}}$，我们可以将公共离散算子表示为 $\\mathcal{L}_h$。问题要求的是局部截断误差，定义为 $\\tau = \\mathcal{L}_h u(x,y) - \\mathcal{L}u(x,y)$。我们使用 $u$ 在点 $(x_i, y_j)$ 附近的 Taylor 级数展开。设 $u_{xxxx} = \\partial^4 u / \\partial x^4$ 且 $u_{yyyy} = \\partial^4 u / \\partial y^4$。\n\n$u(x_i \\pm h, y_j) = u_{i,j} \\pm h \\frac{\\partial u}{\\partial x} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2} \\pm \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + \\frac{h^4}{24} \\frac{\\partial^4 u}{\\partial x^4} + \\mathcal{O}(h^5)$\n$u(x_i, y_j \\pm h) = u_{i,j} \\pm h \\frac{\\partial u}{\\partial y} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial y^2} \\pm \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial y^3} + \\frac{h^4}{24} \\frac{\\partial^4 u}{\\partial y^4} + \\mathcal{O}(h^5)$\n\n对模板的各项求和：\n$u_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h^4}{12} \\frac{\\partial^4 u}{\\partial x^4} + \\mathcal{O}(h^6)$\n$u_{i,j+1} + u_{i,j-1} = 2u_{i,j} + h^2 \\frac{\\partial^2 u}{\\partial y^2} + \\frac{h^4}{12} \\frac{\\partial^4 u}{\\partial y^4} + \\mathcal{O}(h^6)$\n\n现在将这些代入 $\\mathcal{L}_h u_{i,j}$ 的表达式中：\n$$\n\\mathcal{L}_h u_{i,j} = \\frac{\\kappa}{h^2} \\left[ \\left(2u_{i,j} + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx}\\right) + \\left(2u_{i,j} + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy}\\right) - 4u_{i,j} + \\mathcal{O}(h^6) \\right]\n$$\n$$\n\\mathcal{L}_h u_{i,j} = \\frac{\\kappa}{h^2} \\left[ h^2 (u_{xx} + u_{yy}) + \\frac{h^4}{12} (u_{xxxx} + u_{yyyy}) + \\mathcal{O}(h^6) \\right]\n$$\n$$\n\\mathcal{L}_h u_{i,j} = \\kappa (u_{xx} + u_{yy}) + \\frac{\\kappa h^2}{12} (u_{xxxx} + u_{yyyy}) + \\mathcal{O}(h^4)\n$$\n连续算子是 $\\mathcal{L}u = \\kappa(u_{xx} + u_{yy})$。因此，局部截断误差为：\n$$\n\\tau = \\mathcal{L}_h u_{i,j} - \\mathcal{L}u_{i,j} = \\frac{\\kappa h^2}{12} (u_{xxxx} + u_{yyyy}) + \\mathcal{O}(h^4)\n$$\n问题给出的主截断误差形式为 $C h^2 (u_{xxxx} + u_{yyyy})$。通过比较这两个表达式，我们可以确定常数 $C$：\n$$\nC = \\frac{\\kappa}{12}\n$$\n\n**5. 最终计算**\n\n截断误差的此推导是基于离散算子 $\\mathcal{L}_h$ 的代数形式。由于我们已经证明了 $\\mathcal{L}_h^{\\mathrm{cc}} = \\mathcal{L}_h^{\\mathrm{vc}} = \\mathcal{L}_h$，因此两种格式的主截断误差常数必须相同。\n$$\nC_{\\mathrm{cc}} = \\frac{\\kappa}{12}\n$$\n$$\nC_{\\mathrm{vc}} = \\frac{\\kappa}{12}\n$$\n所求的差值为：\n$$\nC_{\\mathrm{cc}} - C_{\\mathrm{vc}} = \\frac{\\kappa}{12} - \\frac{\\kappa}{12} = 0\n$$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "最后的这项实践从理论推导过渡到计算验证，旨在解决欧拉方程中自由流保持这一核心概念。通过在一个倾斜网格上进行编程练习，你将研究几何守恒律（GCL），并亲眼见证为何几何与通量的一致性公式对保证计算精度至关重要。这揭示了在真实的、非理想条件下，离散化选择对CFD求解器稳健性的深远影响。",
            "id": "3947046",
            "problem": "考虑守恒形式的二维可压缩欧拉方程，其在控制体上写为守恒变量与对流通量的积分平衡形式。从积分守恒律和高斯散度定理出发，其连续性表述为：对于任何具有边界的控制体，通过边界的守恒量净通量等于控制体内守恒量的时间变化率。在有限体积离散化中，一个控制体的离散残差是其所有面上投影通量的总和。自由来流守恒要求均匀状态在任何网格上产生的离散残差为零。离散几何守恒律指出，一个封闭控制体的所有面面积矢量的总和必须为零，并且在重构和通量投影中使用的几何度量必须是一致的。\n\n您必须设计并实现一个计算测试，以在倾斜网格上验证单元中心和顶点中心两种布局的自由来流守恒性，并指明在这两种布局中，重构和通量投影之间必须保持一致的离散操作。\n\n使用的基本原理：\n- 守恒律的积分形式和高斯散度定理：如果几何离散化是一致的，恒定状态应在任何封闭控制体上产生零净通量，即离散残差必须恒等于零。\n- 离散几何守恒律：对于任何封闭控制体，面面积矢量的矢量和必须为零。\n- 有限体积离散残差由面上法向投影通量的总和构成。\n\n采用的定义：\n- 单元中心布局将状态存储在单元形心，并将离散残差计算为使用由顶点坐标派生的面面积矢量的面通量之和。\n- 顶点中心布局将状态存储在网格顶点，并使用围绕顶点的对偶控制体，该对偶控制体由连接到该顶点的边的中点构成的多边形形成（一种常见的中线对偶）。离散残差是对偶多边形边上的通量之和。\n\n通量模型：\n- 使用无粘二维欧拉通量。对于一个均匀自由来流，其密度为 $\\,\\rho\\,$，速度为 $\\,u\\,$ 和 $\\,v\\,$，压力为 $\\,p\\,$，比热比为 $\\,\\gamma\\,$，定义比内能 $\\,e = \\dfrac{p}{(\\gamma - 1)\\rho}\\,$，总比能 $\\,E = e + \\dfrac{1}{2}(u^2 + v^2)\\,$，x方向通量矢量 $\\,\\mathbf{F}\\,$ 和 y方向通量矢量 $\\,\\mathbf{G}\\,$ 如下：\n$$\n\\mathbf{F} = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\n\\rho u v \\\\\n(\\rho E + p) u\n\\end{bmatrix}, \\quad\n\\mathbf{G} = \\begin{bmatrix}\n\\rho v \\\\\n\\rho u v \\\\\n\\rho v^2 + p \\\\\n(\\rho E + p) v\n\\end{bmatrix}.\n$$\n对于一个面积矢量为 $\\,\\mathbf{s}_f = (s_{x,f}, s_{y,f})\\,$ 的面，其离散通量贡献为 $\\,\\mathbf{F}\\, s_{x,f} + \\mathbf{G}\\, s_{y,f}\\,$。对于一个单位法向量为 $\\,\\hat{\\mathbf{n}}_f = (n_{x,f}, n_{y,f})\\,$ 的面，未经长度缩放的投影通量为 $\\,\\mathbf{F}\\, n_{x,f} + \\mathbf{G}\\, n_{y,f}\\,$。\n\n网格生成：\n- 构建一个 $\\,3 \\times 3\\,$ 个顶点和 $\\,2 \\times 2\\,$ 个四边形单元的结构化网格。顶点坐标由 $\\,x(i,j) = i + s\\, j\\,$ 和 $\\,y(i,j) = j\\,$ 给出，其中整数索引 $\\,i \\in \\{0,1,2\\}\\,$ 和 $\\,j \\in \\{0,1,2\\}\\,$，$\\,s\\,$ 是倾斜因子。$\\,s = 0\\,$ 产生正交网格；$\\,s > 0\\,$ 产生倾斜网格。\n- 每个单元由四个顶点按逆时针顺序定义：$\\,[(i,j), (i+1,j), (i+1,j+1), (i,j+1)]\\,$，其中 $\\,i \\in \\{0,1\\}\\,$ 且 $\\,j \\in \\{0,1\\}\\,$。面面积矢量由连续的顶点对 $\\,\\mathbf{e}_k = (x_{k+1}-x_k,\\; y_{k+1}-y_k)\\,$ 计算得出，为 $\\,\\mathbf{s}_k = (e_{y,k},\\, -e_{x,k})\\,$，对于逆时针顺序的单元顶点，该矢量朝外。对于顶点中心的测试，使用内部顶点 $\\, (1,1)\\,$，并通过连接其四个入射边（连接到其正交邻居：左侧 $\\, (0,1)\\,$、右侧 $\\, (2,1)\\,$、底部 $\\, (1,0)\\,$ 和顶部 $\\, (1,2)\\,$）的中点来定义其对偶控制体多边形。将这些中点按围绕顶点的逆时针角度排序以形成多边形，并使用相同的面面积矢量构造方法。\n\n需要编码的离散操作和一致性要求：\n- 面面积矢量和单位法向量必须从相同的顶点几何结构中一致地派生。\n- 用于计算面积矢量的面方向和排序在重构和通量投影中必须相同，以便对于均匀状态，跨面的抵消是精确的。\n- 对于主控制体和对偶控制体，都必须满足控制体封闭性（面积矢量之和 $\\,\\sum_f \\mathbf{s}_f = \\mathbf{0}\\,$）。\n- 对于顶点中心的对偶体，边的中点位置和多边形排序在重构和通量投影之间必须保持一致。\n\n您的程序必须：\n1. 实现均匀自由来流，参数为 $\\,\\rho = 1.225\\,$，$\\,u = 200\\,$，$\\,v = 50\\,$，$\\,p = 101325\\,$，以及 $\\,\\gamma = 1.4\\,$。输出中不需要物理单位，因为最终的度量是无量纲的。\n2. 为指定的倾斜因子 $\\,s\\,$ 构建网格，为单元中心和顶点中心两种布局构造控制体，并通过对面贡献求和来计算每个控制体的离散残差矢量。\n3. 对每个测试计算一个无量纲残差比，定义为 $\\,r = \\dfrac{\\|\\mathbf{R}\\|_2}{\\sum_{\\text{faces}} \\|\\mathbf{F}\\, \\alpha_{x,f} + \\mathbf{G}\\, \\alpha_{y,f}\\|_2}\\,$，其中 $\\,\\mathbf{R}\\,$ 是被评估控制体的总残差矢量，$\\,\\alpha_{x,f}, \\alpha_{y,f}\\,$ 在一致情况下是 $\\,s_{x,f}, s_{y,f}\\,$，在不一致情况下是 $\\,n_{x,f}, n_{y,f}\\,$，$\\,\\|\\cdot\\|_2\\,$ 表示欧几里得范数。该比值是无量纲的，当自由来流守恒时，应接近 $\\,0\\,$。\n4. 评估以下测试套件参数集：\n   - 测试 $\\,1\\,$：单元中心，倾斜度 $\\,s = 0.3\\,$，通量投影中使用一致的面面积矢量。\n   - 测试 $\\,2\\,$：单元中心，倾斜度 $\\,s = 0.3\\,$，使用单位法向量进行不一致的通量投影，未进行长度缩放。\n   - 测试 $\\,3\\,$：顶点中心（内部顶点对偶体），倾斜度 $\\,s = 0.3\\,$，通量投影中使用一致的面积矢量。\n   - 测试 $\\,4\\,$：顶点中心（内部顶点对偶体），倾斜度 $\\,s = 0.3\\,$，使用单位法向量进行不一致的通量投影，未进行长度缩放。\n   - 测试 $\\,5\\,$：单元中心，正交网格，$\\,s = 0.0\\,$，使用单位法向量进行不一致的通量投影，未进行长度缩放（对称性可能意外抵消的边界情况）。\n   - 测试 $\\,6\\,$：顶点中心（内部顶点对偶体），正交网格，$\\,s = 0.0\\,$，使用单位法向量进行不一致的通量投影，未进行长度缩放。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个测试的残差比，形式为逗号分隔的列表并用方括号括起，例如 $\\, [r_1,r_2,r_3,r_4,r_5,r_6]\\,$。不得打印任何额外文本。",
            "solution": "该问题要求设计并实现一个计算验证测试，用于检验有限体积法在倾斜网格上的自由来流守恒特性，并比较单元中心和顶点中心两种格式。此特性对于任何守恒律数值方法的精度都至关重要，因为它确保了平凡的均匀流场不会伪造地产生守恒量的数值源或汇。\n\n此分析的基础是守恒律在控制体 $V$（其边界为 $\\partial V$）上的积分形式：\n$$\n\\frac{d}{dt}\\int_V \\mathbf{U} dV + \\oint_{\\partial V} \\mathbf{F}_n dS = \\mathbf{0}\n$$\n在这里，$\\mathbf{U}$ 是守恒变量矢量，$\\mathbf{F}_n$ 是垂直于边界的 $\\mathbf{U}$ 的通量。对于二维欧拉方程，穿过单位法向量为 $\\hat{\\mathbf{n}} = (n_x, n_y)$ 的边界元的通量矢量由 $\\mathbf{F} n_x + \\mathbf{G} n_y$ 给出，其中 $\\mathbf{F}$ 和 $\\mathbf{G}$ 分别是笛卡尔坐标系 x 和 y 方向的通量矢量。\n\n对于稳态均匀自由来流，状态矢量 $\\mathbf{U}$ 在整个区域内是恒定的。因此，其时间导数为零，通量矢量 $\\mathbf{F}(\\mathbf{U})$ 和 $\\mathbf{G}(\\mathbf{U})$ 也是恒定的。守恒律简化为要求从任何封闭控制体流出的净通量必须为零：\n$$\n\\oint_{\\partial V} (\\mathbf{F} n_x + \\mathbf{G} n_y) dS = \\mathbf{0}\n$$\n有限体积法通过对构成离散控制体边界的不同面 $f$ 上的通量求和来离散化该积分：\n$$\n\\mathbf{R} = \\sum_{f \\in \\partial V} (\\mathbf{F} n_{x,f} + \\mathbf{G} n_{y,f}) L_f\n$$\n其中 $\\mathbf{R}$ 是离散残差，$L_f$ 是面 $f$ 的长度，而 $(n_{x,f}, n_{y,f})$ 是其向外的单位法向量。\n\n一个关键概念是面面积矢量 $\\mathbf{s}_f$，定义为 $\\mathbf{s}_f = (s_{x,f}, s_{y,f}) = (n_{x,f} L_f, n_{y,f} L_f)$。使用此定义，均匀状态的离散残差可以写为：\n$$\n\\mathbf{R} = \\sum_{f} (\\mathbf{F} s_{x,f} + \\mathbf{G} s_{y,f})\n$$\n由于自由来流是均匀的，通量矢量 $\\mathbf{F}$ 和 $\\mathbf{G}$ 是常数，可以从求和中提取出来：\n$$\n\\mathbf{R} = \\mathbf{F} \\left(\\sum_f s_{x,f}\\right) + \\mathbf{G} \\left(\\sum_f s_{y,f}\\right)\n$$\n对于任何封闭的多面体（在本例中为二维多边形），其向外指向的面面积矢量的总和恒等于零。这就是**离散几何守恒律 (GCL)**：\n$$\n\\sum_f \\mathbf{s}_f = \\sum_f \\begin{pmatrix} s_{x,f} \\\\ s_{y,f} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n如果离散几何满足 GCL，则直接推断出均匀自由来流的离散残差 $\\mathbf{R}$ 恒等于零。这就是自由来流守恒的本质。\n\n该问题要求测试两种通量计算情景：\n1. **一致性公式**：通量投影使用面积矢量 $\\mathbf{s}_f$。每个面的贡献是 $\\mathbf{F} s_{x,f} + \\mathbf{G} s_{y,f}$。如上所示，此公式遵循 GCL，并将产生零残差（在机器精度范围内）。\n2. **不一致公式**：通量投影使用单位法向量 $\\hat{\\mathbf{n}}_f = (n_{x,f}, n_{y,f})$，而没有进行面长度缩放。面的贡献是 $\\mathbf{F} n_{x,f} + \\mathbf{G} n_{y,f}$。总残差变为：\n$$\n\\mathbf{R} = \\mathbf{F} \\left(\\sum_f n_{x,f}\\right) + \\mathbf{G} \\left(\\sum_f n_{y,f}\\right)\n$$\n该残差不保证为零。只有当面单位法向量的矢量和 $\\sum_f \\hat{\\mathbf{n}}_f$ 为零时，它才为零。此条件仅在具有特殊对称性的控制体（例如，正交网格上的矩形）上满足，但对于一般的倾斜或不规则单元则不成立。几何封闭性要求（涉及面面积/长度）与通量计算（丢弃了长度）之间的这种不一致性，导致了自由来流守恒性的丧失。\n\n因此，必须保持一致的离散操作是那些定义控制体几何形状的操作和那些计算其边界通量的操作。具体来说：\n- 在**单元中心**布局中，控制体是主网格单元，一个由一组顶点定义的多边形。面面积矢量 $\\mathbf{s}_f$ 从这些顶点坐标派生而来。为保持一致性，通量计算必须使用这些完全相同的面积矢量 $\\mathbf{s}_f$。\n- 在**顶点中心**布局中，控制体是一个对偶多边形，此处通过连接到中心顶点的边的中点形成。面面积矢量 $\\mathbf{s}_f$ 从这些中点的坐标派生而来。一致性要求通量计算使用这些对偶面面积矢量。\n\n实现过程将构建指定的网格和控制体。对于每个测试用例，它将按逆时针顺序定义控制多边形的顶点。然后，它遍历多边形的边，为每个面计算面积矢量 $\\mathbf{s}_f$ 和单位法向量 $\\hat{\\mathbf{n}}_f$。根据测试的一致性要求，它使用 $\\mathbf{s}_f$ 或 $\\hat{\\mathbf{n}}_f$ 计算面通量贡献。将这些贡献相加以求得总残差矢量 $\\mathbf{R}$。最后，计算一个无量纲比率 $r = \\dfrac{\\|\\mathbf{R}\\|_2}{\\sum_{\\text{faces}} \\|\\text{flux contribution}\\|_2}$，以量化违背的程度。\n\n基于理论：\n- 测试 $1$ 和 $3$ 是一致的，无论倾斜度如何，都应产生接近机器精度零的比率 $r$。\n- 测试 $2$ 和 $4$ 在倾斜网格 ($s=0.3$) 上使用不一致的公式。对称性被破坏，因此 $\\sum_f \\hat{\\mathbf{n}}_f \\neq \\mathbf{0}$，导致非零残差和 $r > 0$ 的比率。\n- 测试 $5$ 和 $6$ 在正交网格 ($s=0.0$) 上使用不一致的公式。控制体（主控制体和对偶控制体）都是对称的矩形/正方形。由于这种对称性，相对面的法向量相互抵消，使得 $\\sum_f \\hat{\\mathbf{n}}_f = \\mathbf{0}$。因此，即使是不一致的格式预计也会产生零残差，从而掩盖了其底层的公式错误。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the free-stream preservation tests.\n    \"\"\"\n\n    # 1. Define the uniform free-stream state\n    rho = 1.225  # density\n    u = 200.0    # x-velocity\n    v = 50.0     # y-velocity\n    p = 101325.0 # pressure\n    gamma = 1.4  # ratio of specific heats\n\n    # Calculate derived quantities\n    e = p / ((gamma - 1) * rho)\n    E_total = e + 0.5 * (u**2 + v**2)\n\n    # 2. Define the constant Euler flux vectors F and G\n    F_flux = np.array([\n        rho * u,\n        rho * u**2 + p,\n        rho * u * v,\n        (rho * E_total + p) * u\n    ])\n\n    G_flux = np.array([\n        rho * v,\n        rho * u * v,\n        rho * v**2 + p,\n        (rho * E_total + p) * v\n    ])\n\n    # 3. Define the test suite as specified in the problem\n    test_cases = [\n        # Test 1: cell-centered, skewed, consistent\n        {'type': 'cell', 's': 0.3, 'consistent': True},\n        # Test 2: cell-centered, skewed, inconsistent\n        {'type': 'cell', 's': 0.3, 'consistent': False},\n        # Test 3: vertex-centered, skewed, consistent\n        {'type': 'vertex', 's': 0.3, 'consistent': True},\n        # Test 4: vertex-centered, skewed, inconsistent\n        {'type': 'vertex', 's': 0.3, 'consistent': False},\n        # Test 5: cell-centered, orthogonal, inconsistent\n        {'type': 'cell', 's': 0.0, 'consistent': False},\n        # Test 6: vertex-centered, orthogonal, inconsistent\n        {'type': 'vertex', 's': 0.0, 'consistent': False},\n    ]\n\n    results = []\n    # 4. Execute each test case\n    for params in test_cases:\n        ratio = run_test(params, F_flux, G_flux)\n        results.append(ratio)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_vertices(s):\n    \"\"\"\n    Generates the 3x3 grid of vertex coordinates for a given skew factor s.\n    \"\"\"\n    vertices = np.zeros((3, 3, 2))\n    for j in range(3):\n        for i in range(3):\n            vertices[i, j, 0] = float(i) + s * float(j)\n            vertices[i, j, 1] = float(j)\n    return vertices\n\ndef compute_residual_for_polygon(polygon_vertices, use_consistent_flux, F, G):\n    \"\"\"\n    Computes the discrete residual and the dimensionless ratio for a given\n    closed polygon control volume.\n    \"\"\"\n    total_residual = np.zeros(4)\n    denominator_sum = 0.0\n    num_verts = len(polygon_vertices)\n\n    # Iterate over the faces of the polygon (defined by successive vertices)\n    for i in range(num_verts):\n        p1 = polygon_vertices[i]\n        p2 = polygon_vertices[(i + 1) % num_verts]  # Assumes CCW ordering\n\n        # Compute face geometry from its vertices\n        edge_vec = p2 - p1\n        # Area vector is normal to the edge, pointing outwards for CCW traversal\n        area_vec = np.array([edge_vec[1], -edge_vec[0]])\n        \n        length = np.linalg.norm(area_vec)\n        if length  1e-15:\n            # Should not happen with this problem's geometry\n            unit_normal = np.zeros(2)\n        else:\n            unit_normal = area_vec / length\n\n        # Select the projection vector based on consistency\n        if use_consistent_flux:\n            alpha = area_vec\n        else:\n            alpha = unit_normal\n\n        # Calculate the flux contribution for this face\n        flux_contribution = F * alpha[0] + G * alpha[1]\n        \n        # Accumulate the total residual and the denominator term\n        total_residual += flux_contribution\n        denominator_sum += np.linalg.norm(flux_contribution)\n\n    # Calculate the final dimensionless residual ratio\n    numerator = np.linalg.norm(total_residual)\n    if denominator_sum  1e-15:\n        return 0.0\n    \n    return numerator / denominator_sum\n\ndef run_test(params, F, G):\n    \"\"\"\n    Sets up and runs a single test case.\n    \"\"\"\n    s = params['s']\n    test_type = params['type']\n    is_consistent = params['consistent']\n\n    # Generate the primary 3x3 vertex grid\n    vertices = generate_vertices(s)\n    cv_polygon_verts = []\n\n    if test_type == 'cell':\n        # Select the first cell [0,0] for the test. Its vertices are\n        # (0,0), (1,0), (1,1), (0,1) in the (i,j) index space.\n        cv_polygon_verts = [\n            vertices[0, 0],\n            vertices[1, 0],\n            vertices[1, 1],\n            vertices[0, 1]\n        ]\n    elif test_type == 'vertex':\n        # Construct the dual control volume around the central vertex (1,1).\n        # The dual polygon connects the midpoints of the four incident edges.\n        v_c = vertices[1, 1]  # Central vertex\n        v_r = vertices[2, 1]  # Right neighbor\n        v_t = vertices[1, 2]  # Top neighbor\n        v_l = vertices[0, 1]  # Left neighbor\n        v_b = vertices[1, 0]  # Bottom neighbor\n        \n        # Midpoints forming the dual cell, ordered CCW around v_c to form the polygon\n        m_r = 0.5 * (v_c + v_r)\n        m_t = 0.5 * (v_c + v_t)\n        m_l = 0.5 * (v_c + v_l)\n        m_b = 0.5 * (v_c + v_b)\n        \n        cv_polygon_verts = [m_r, m_t, m_l, m_b]\n    \n    # Compute and return the residual ratio for the constructed control volume\n    return compute_residual_for_polygon(np.array(cv_polygon_verts), is_consistent, F, G)\n\n# Execute the main function\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}