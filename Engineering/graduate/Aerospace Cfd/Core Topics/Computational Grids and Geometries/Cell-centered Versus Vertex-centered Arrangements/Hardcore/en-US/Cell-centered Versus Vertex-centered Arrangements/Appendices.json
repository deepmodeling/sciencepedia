{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of cell-centered and vertex-centered schemes, we begin with a foundational analysis in the simplest possible setting. This practice guides you through a derivation for the scalar diffusion operator on a uniform, orthogonal grid. By demonstrating the conditions under which both arrangements yield algebraically identical discrete operators, this exercise demystifies their relationship and establishes a crucial baseline: in ideal conditions, their core behavior is the same ().",
            "id": "3947053",
            "problem": "Consider a scalar diffusion model in two dimensions commonly used in Aerospace Computational Fluid Dynamics (CFD): the constant-coefficient elliptic operator acting on a smooth scalar field $u(x,y)$,\n$$\\mathcal{L}u = \\nabla \\cdot \\left(\\kappa \\nabla u\\right),$$\nwhere $\\kappa$ is a positive constant and $(x,y)$ lies in a rectangular computational domain. Let the domain be discretized by an orthogonal, uniform Cartesian grid with equal spacings $\\Delta x = \\Delta y = h$, and consider two discrete arrangements:\n\n- A cell-centered arrangement using the integral (finite volume) form of the operator over rectangular control volumes with face-normal fluxes approximated by linear reconstructions that are exact for polynomials up to degree $1$ and evaluated using midpoint quadrature on each face.\n- A vertex-centered arrangement using pointwise finite-difference approximations of the operator at grid vertices with central differences, constructed from uniform stencils aligned with the coordinate directions.\n\nStarting from the divergence theorem and Taylor expansions about a generic grid location, and without introducing any additional correction terms, derive conditions on the grid geometry and the reconstruction rules under which the resulting discrete operators produced by the two arrangements become identical on this grid. Then, under these conditions, define the leading truncation error of the discrete Laplacian operator at a grid location $(x,y)$ as the coefficient $C$ in the local expansion\n$$\\mathcal{L}_h u(x,y) - \\mathcal{L}u(x,y) = C\\,h^{2}\\left(u_{xxxx}(x,y) + u_{yyyy}(x,y)\\right) + \\mathcal{O}\\!\\left(h^{4}\\right),$$\nwhere $\\mathcal{L}_h$ denotes the discrete operator and $u_{xxxx}$, $u_{yyyy}$ are the fourth partial derivatives of $u$. Compute the difference in the leading truncation error constants between the two arrangements,\n$$C_{\\mathrm{cc}} - C_{\\mathrm{vc}},$$\nwhere $C_{\\mathrm{cc}}$ corresponds to the cell-centered operator and $C_{\\mathrm{vc}}$ corresponds to the vertex-centered operator, and provide the final answer as a single real number. No rounding is required.",
            "solution": "The problem requires a comparative analysis of two common discretization schemes for the diffusion operator $\\mathcal{L}u = \\nabla \\cdot (\\kappa \\nabla u)$ on a uniform Cartesian grid with spacing $h$. For constant $\\kappa$, this is $\\mathcal{L}u = \\kappa \\nabla^2 u$.\n\n**1. Vertex-Centered (VC) Finite Difference Operator**\n\nIn the vertex-centered arrangement, the discrete values $u_{i,j}$ are associated with grid vertices. Using standard second-order central differences for the partial derivatives at vertex $(i,j)$ gives:\n$$ \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\nThe discrete operator is the well-known 5-point stencil for the Laplacian:\n$$ \\mathcal{L}_h^{\\mathrm{vc}} u_{i,j} = \\frac{\\kappa}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} \\right) $$\n\n**2. Cell-Centered (CC) Finite Volume Operator**\n\nIn the cell-centered arrangement, values $u_{i,j}$ are at the center of a square control volume $V_{i,j}$. Applying the divergence theorem, the integral of $\\mathcal{L}u$ over $V_{i,j}$ is the sum of fluxes across the four faces (east, west, north, south).\n$$ \\int_{V_{i,j}} \\mathcal{L}u \\, dA = \\oint_{\\partial V_{i,j}} (\\kappa \\nabla u) \\cdot \\mathbf{n} \\, ds = (F_e - F_w) + (F_n - F_s) $$\nThe flux through each face is the face length ($h$) times the normal gradient at the face center. Using a central difference for the gradient (which is exact for linear fields as specified), the flux at the east face (midway between cell $i$ and $i+1$) is:\n$$ F_e \\approx h \\left(\\kappa \\frac{\\partial u}{\\partial x}\\right)\\bigg|_{i+1/2,j} = h \\kappa \\left( \\frac{u_{i+1,j} - u_{i,j}}{h} \\right) = \\kappa(u_{i+1,j} - u_{i,j}) $$\nAssembling the fluxes from all four faces, the average of the operator over the cell volume $h^2$ is:\n$$ \\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{1}{h^2} \\left[ \\kappa(u_{i+1,j} - u_{i,j}) - \\kappa(u_{i,j} - u_{i-1,j}) + \\kappa(u_{i,j+1} - u_{i,j}) - \\kappa(u_{i,j} - u_{i,j-1}) \\right] $$\nThis simplifies to the exact same 5-point stencil:\n$$ \\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{\\kappa}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} \\right) $$\n\n**3. Truncation Error Analysis**\n\nSince the discrete operators are algebraically identical ($\\mathcal{L}_h^{\\mathrm{cc}} = \\mathcal{L}_h^{\\mathrm{vc}} = \\mathcal{L}_h$), their truncation error must also be identical. To find the error, we use Taylor series expansion of $u$ around the point $(x_i, y_j)$:\n$$ u_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx} + \\mathcal{O}(h^6) $$\n$$ u_{i,j+1} + u_{i,j-1} = 2u_{i,j} + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy} + \\mathcal{O}(h^6) $$\nSubstituting these into the discrete operator $\\mathcal{L}_h$:\n$$ \\mathcal{L}_h u_{i,j} = \\frac{\\kappa}{h^2} \\left[ (2u_{i,j} + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx}) + (2u_{i,j} + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy}) - 4u_{i,j} + \\mathcal{O}(h^6) \\right] $$\n$$ \\mathcal{L}_h u_{i,j} = \\kappa (u_{xx} + u_{yy}) + \\frac{\\kappa h^2}{12} (u_{xxxx} + u_{yyyy}) + \\mathcal{O}(h^4) $$\nThe local truncation error is $\\tau = \\mathcal{L}_h u - \\mathcal{L}u$. The leading term is $\\frac{\\kappa h^2}{12} (u_{xxxx} + u_{yyyy})$.\n\nComparing this to the problem's form $C h^2 (u_{xxxx} + u_{yyyy})$, we find the coefficient $C = \\frac{\\kappa}{12}$ for both schemes.\n$$ C_{\\mathrm{cc}} = \\frac{\\kappa}{12} \\quad \\text{and} \\quad C_{\\mathrm{vc}} = \\frac{\\kappa}{12} $$\nTherefore, the difference is $C_{\\mathrm{cc}} - C_{\\mathrm{vc}} = 0$.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Moving from the idealized interior of a domain, we next tackle the practical and critical challenge of implementing boundary conditions. This exercise explores how to formulate a second-order consistent approximation for the normal gradient at a boundary where a Dirichlet condition is specified. You will derive a single, unified expression that applies to both cell-centered schemes using ghost cells and vertex-centered schemes using mirrored nodes, demonstrating how different conceptual frameworks can converge to the same effective implementation at the domain's edge ().",
            "id": "3947000",
            "problem": "Consider a smooth scalar field $\\phi(\\mathbf{x})$ defined in a fluid domain near a planar solid boundary in an advanced aerospace Computational Fluid Dynamics (CFD) setting. The outward unit normal of the boundary is $\\mathbf{n}$, and the centroid of a specific boundary face is located at $\\mathbf{x}_{f}$. Assume the variation of $\\phi(\\mathbf{x})$ along the normal direction is twice continuously differentiable in a neighborhood containing points $\\mathbf{x}_{f} \\pm \\delta_{n}\\,\\mathbf{n}$ for a strictly positive distance $\\delta_{n}$. The boundary imposes a Dirichlet condition $\\phi(\\mathbf{x}_{f})=\\phi_{B}$, where $\\phi_{B}$ is a known continuous function evaluated at $\\mathbf{x}_{f}$.\n\nTwo finite-volume and finite-element style discretization arrangements are considered:\n\n- In a cell-centered arrangement, primary unknowns are stored at cell centers. Let the interior cell center adjacent to the boundary face be located at $\\mathbf{x}_{P}=\\mathbf{x}_{f}+\\delta_{n}\\,\\mathbf{n}$ with stored value $\\phi_{P}=\\phi(\\mathbf{x}_{P})$. To construct a second-order accurate gradient at the boundary face, introduce a ghost cell center at $\\mathbf{x}_{G}=\\mathbf{x}_{f}-\\delta_{n}\\,\\mathbf{n}$ with value $\\phi_{G}$ selected to be consistent with the boundary condition and symmetry about the face.\n\n- In a vertex-centered arrangement, primary unknowns are stored at vertices (nodes). Let the interior vertex adjacent to the boundary face be located at $\\mathbf{x}_{I}=\\mathbf{x}_{f}+\\delta_{n}\\,\\mathbf{n}$ with stored value $\\phi_{I}=\\phi(\\mathbf{x}_{I})$, and the boundary vertex at $\\mathbf{x}_{f}$ has the prescribed value $\\phi_{B}=\\phi(\\mathbf{x}_{f})$. To construct a second-order accurate gradient at the boundary face, introduce a mirrored node at $\\mathbf{x}_{M}=\\mathbf{x}_{f}-\\delta_{n}\\,\\mathbf{n}$ with value $\\phi_{M}$ selected to be consistent with the boundary condition and symmetry about the face.\n\nStarting from the definition of the directional derivative of $\\phi$ along $\\mathbf{n}$ and using only well-tested local Taylor expansions and the Dirichlet boundary condition at $\\mathbf{x}_{f}$, derive a single closed-form expression for the normal component of the gradient at the boundary face centroid $\\mathbf{x}_{f}$, namely $\\nabla \\phi(\\mathbf{x}_{f})\\cdot \\mathbf{n}$, that is second-order consistent for both the cell-centered (ghost cell) and vertex-centered (mirrored node) constructions specified above. Express your final answer in terms of the interior value (either $\\phi_{P}$ or $\\phi_{I}$, which you may denote generically as $\\phi_{I}$), the boundary value $\\phi_{B}$, and the normal separation $\\delta_{n}$. Give your answer as a single analytic expression. No numerical evaluation is required; do not include units in your expression.",
            "solution": "The problem requires deriving a second-order consistent expression for the normal gradient, $\\nabla \\phi \\cdot \\mathbf{n}$, at a boundary face $\\mathbf{x}_f$ where a Dirichlet condition $\\phi(\\mathbf{x}_f) = \\phi_B$ is specified. The expression should be valid for both cell-centered and vertex-centered arrangements as described.\n\nThe key is to use a symmetric, second-order accurate central difference stencil for the gradient at $\\mathbf{x}_f$. This requires values at two points equidistant from the face along the normal vector: an interior point $\\mathbf{x}_I = \\mathbf{x}_f + \\delta_n \\mathbf{n}$ (with value $\\phi_I$) and an exterior \"ghost\" or \"mirrored\" point $\\mathbf{x}_{ext} = \\mathbf{x}_f - \\delta_n \\mathbf{n}$ (with value $\\phi_{ext}$). The central difference formula for the gradient is:\n$$ \\nabla \\phi(\\mathbf{x}_f) \\cdot \\mathbf{n} \\approx \\frac{\\phi_I - \\phi_{ext}}{2\\delta_n} $$\nThis formula is second-order accurate, but it depends on the external value $\\phi_{ext}$, which is not a primary unknown.\n\nTo find $\\phi_{ext}$, we enforce the Dirichlet boundary condition at the face. A second-order accurate way to relate the face value to the surrounding points is to assume linear interpolation, which places the face value at the midpoint:\n$$ \\phi_B = \\phi(\\mathbf{x}_f) \\approx \\frac{\\phi_I + \\phi_{ext}}{2} $$\nSolving for the external value gives the common rule for implementing a Dirichlet condition:\n$$ \\phi_{ext} = 2\\phi_B - \\phi_I $$\nThis construction applies identically to the cell-centered scheme (where $\\phi_I$ is the interior cell value $\\phi_P$, and $\\phi_{ext}$ is the ghost value $\\phi_G$) and the vertex-centered scheme (where $\\phi_I$ is the interior vertex value, and $\\phi_{ext}$ is the mirrored value $\\phi_M$).\n\nFinally, we substitute this expression for $\\phi_{ext}$ back into the central difference formula for the gradient:\n$$ \\nabla \\phi(\\mathbf{x}_f) \\cdot \\mathbf{n} \\approx \\frac{\\phi_I - (2\\phi_B - \\phi_I)}{2\\delta_n} = \\frac{2\\phi_I - 2\\phi_B}{2\\delta_n} = \\frac{\\phi_I - \\phi_B}{\\delta_n} $$\nThis is the final expression. Although it has the form of a first-order forward difference, it is derived from a second-order accurate central difference stencil combined with a second-order accurate implementation of the boundary condition. In the context of finite volume methods, this formulation is considered second-order consistent because it can be shown to preserve the global second-order accuracy of the numerical scheme.",
            "answer": "$$\n\\boxed{\\frac{\\phi_{I} - \\phi_{B}}{\\delta_{n}}}\n$$"
        },
        {
            "introduction": "While the two schemes can appear equivalent on simple grids, their distinct geometric underpinnings become critically important on the non-orthogonal meshes common in aerospace CFD. This hands-on coding practice focuses on a cornerstone principle: the Geometric Conservation Law (GCL) and its role in ensuring free-stream preservation. By designing a computational test (), you will see firsthand how a seemingly minor inconsistency in the flux calculation—using a face's unit normal instead of its full area vector—produces non-physical results on a skewed mesh, powerfully illustrating a key failure mode that developers must rigorously avoid.",
            "id": "3947046",
            "problem": "Consider the two-dimensional compressible Euler equations in conservation form, written over a control volume as the integral balance of conserved variables with convective fluxes. Starting from the integral conservation law and the Gauss divergence theorem, the continuous statement is that for any control volume with boundary, the net flux of the conserved quantities through the boundary equals the time rate of change inside the volume. In a finite volume discretization, the discrete residual for a control volume is the sum of the projected fluxes across its faces. Free-stream preservation requires that a uniform state yields zero discrete residual on any mesh. The discrete geometric conservation law states that the sum of face area vectors of a closed control volume must be zero, and that the geometric metrics used in reconstruction and in flux projection must be consistent.\n\nYou must design and implement a computational test to verify free-stream preservation on a skewed mesh for both cell-centered and vertex-centered arrangements, and specify the discrete operations that must be consistent between reconstruction and flux projection in both arrangements.\n\nFundamental base to use:\n- The integral form of conservation laws and the Gauss divergence theorem: a constant state should yield zero net flux over any closed control volume, i.e., the discrete residual must be identically zero if the geometric discretization is consistent.\n- The discrete geometric conservation law: the vector sum of face area vectors must be zero for any closed control volume.\n- The finite volume discrete residual formed as the sum of face-normal projected fluxes.\n\nDefinitions to adopt:\n- Cell-centered arrangement stores the state at cell centroids and computes the discrete residual as the sum of face fluxes using face area vectors derived from vertex coordinates.\n- Vertex-centered arrangement stores the state at mesh vertices and uses a dual control volume around a vertex formed by the polygon connecting midpoints of edges incident to that vertex (a common median dual). The discrete residual is the sum of fluxes through the dual polygon edges.\n\nFlux model:\n- Use the inviscid two-dimensional Euler fluxes. For a uniform free-stream with density $\\,\\rho\\,$, velocities $\\,u\\,$ and $\\,v\\,$, pressure $\\,p\\,$, and ratio of specific heats $\\,\\gamma\\,$, define the specific internal energy $\\,e = \\dfrac{p}{(\\gamma - 1)\\rho}\\,$, the total specific energy $\\,E = e + \\dfrac{1}{2}(u^2 + v^2)\\,$, the $x$-flux vector $\\,\\mathbf{F}\\,$ and the $y$-flux vector $\\,\\mathbf{G}\\,$ as\n$$\n\\mathbf{F} = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\n\\rho u v \\\\\n(\\rho E + p) u\n\\end{bmatrix}, \\quad\n\\mathbf{G} = \\begin{bmatrix}\n\\rho v \\\\\n\\rho u v \\\\\n\\rho v^2 + p \\\\\n(\\rho E + p) v\n\\end{bmatrix}.\n$$\nFor a face with area vector $\\,\\mathbf{s}_f = (s_{x,f}, s_{y,f})\\,$, the discrete flux contribution is $\\,\\mathbf{F}\\, s_{x,f} + \\mathbf{G}\\, s_{y,f}\\,$. For a face with unit normal $\\,\\hat{\\mathbf{n}}_f = (n_{x,f}, n_{y,f})\\,$, the projected flux without length scaling is $\\,\\mathbf{F}\\, n_{x,f} + \\mathbf{G}\\, n_{y,f}\\,$.\n\nMesh generation:\n- Construct a structured grid of $\\,3 \\times 3\\,$ vertices and $\\,2 \\times 2\\,$ quadrilateral cells. Vertex coordinates are given by $\\,x(i,j) = i + s\\, j\\,$ and $\\,y(i,j) = j\\,$ for integer indices $\\,i \\in \\{0,1,2\\}\\,$ and $\\,j \\in \\{0,1,2\\}\\,$, where $\\,s\\,$ is the skew factor. The case $\\,s = 0\\,$ yields an orthogonal grid; $\\,s > 0\\,$ yields a skewed grid.\n- Each cell is defined by four vertices in counterclockwise order: $\\,[(i,j), (i+1,j), (i+1,j+1), (i,j+1)]\\,$ for $\\,i \\in \\{0,1\\}\\,$ and $\\,j \\in \\{0,1\\}\\,$. Face area vectors are computed from successive vertex pairs $\\,\\mathbf{e}_k = (x_{k+1}-x_k,\\; y_{k+1}-y_k)\\,$ as $\\,\\mathbf{s}_k = (e_{y,k},\\, -e_{x,k})\\,$, which is outward for counterclockwise cell vertex order. For vertex-centered tests, use the interior vertex $\\, (1,1)\\,$ and define its dual control volume polygon by connecting the midpoints of its four incident edges to its orthogonal neighbors: left $\\, (0,1)\\,$, right $\\, (2,1)\\,$, bottom $\\, (1,0)\\,$, and top $\\, (1,2)\\,$. Order the midpoints in counterclockwise angle around the vertex to form the polygon, and use the same face area vector construction.\n\nDiscrete operations and consistency requirements to encode:\n- Face area vectors and unit normals must be derived consistently from the same vertex geometry.\n- The face orientation and ordering used to compute area vectors must be the same in reconstruction and flux projection so that cancellation across faces is exact for a uniform state.\n- The control volume closure must be respected (sum of area vectors $\\,\\sum_f \\mathbf{s}_f = \\mathbf{0}\\,$) for both primal and dual volumes.\n- For vertex-centered duals, the edge midpoint locations and the polygon ordering must be consistent between reconstruction and flux projection.\n\nYour program must:\n1. Implement the uniform free-stream with $\\,\\rho = 1.225\\,$, $\\,u = 200\\,$, $\\,v = 50\\,$, $\\,p = 101325\\,$, and $\\,\\gamma = 1.4\\,$. No physical unit is required in the output because the final metric is dimensionless.\n2. Build meshes for specified skew factors $\\,s\\,$, construct control volumes for both cell-centered and vertex-centered arrangements, and compute the discrete residual vector for each control volume by summing face contributions.\n3. Compute, for each test, a dimensionless residual ratio defined as $\\,r = \\dfrac{\\|\\mathbf{R}\\|_2}{\\sum_{\\text{faces}} \\|\\mathbf{F}\\, \\alpha_{x,f} + \\mathbf{G}\\, \\alpha_{y,f}\\|_2}\\,$, where $\\,\\mathbf{R}\\,$ is the total residual vector for the evaluated control volumes, $\\,\\alpha_{x,f}, \\alpha_{y,f}\\,$ are either $\\,s_{x,f}, s_{y,f}\\,$ in the consistent case or $\\,n_{x,f}, n_{y,f}\\,$ in the inconsistent case, and $\\,\\|\\cdot\\|_2\\,$ denotes the Euclidean norm. This ratio is dimensionless and should be close to $\\,0\\,$ when free-stream is preserved.\n4. Evaluate the following test suite parameter sets:\n   - Test $\\,1\\,$: cell-centered, skew $\\,s = 0.3\\,$, consistent face area vectors in flux projection.\n   - Test $\\,2\\,$: cell-centered, skew $\\,s = 0.3\\,$, inconsistent flux projection using unit normals without length scaling.\n   - Test $\\,3\\,$: vertex-centered (interior vertex dual), skew $\\,s = 0.3\\,$, consistent area vectors in flux projection.\n   - Test $\\,4\\,$: vertex-centered (interior vertex dual), skew $\\,s = 0.3\\,$, inconsistent flux projection using unit normals without length scaling.\n   - Test $\\,5\\,$: cell-centered, orthogonal grid with $\\,s = 0.0\\,$, inconsistent flux projection using unit normals without length scaling (boundary case where symmetry can accidentally cancel).\n   - Test $\\,6\\,$: vertex-centered (interior vertex dual), orthogonal grid with $\\,s = 0.0\\,$, inconsistent flux projection using unit normals without length scaling.\n\nFinal output format:\n- Your program should produce a single line of output containing the residual ratios for the six tests as a comma-separated list enclosed in square brackets, for example $\\, [r_1,r_2,r_3,r_4,r_5,r_6]\\,$. No additional text must be printed.",
            "solution": "The problem requires the design and implementation of a computational verification test for the free-stream preservation property of a finite volume method on skewed meshes, comparing cell-centered and vertex-centered schemes. This property is fundamental to the accuracy of any numerical method for conservation laws, as it ensures that a trivial uniform flow field does not spuriously generate numerical sources or sinks of the conserved quantities.\n\nThe foundation of this analysis rests on the integral form of a conservation law over a control volume $V$ with boundary $\\partial V$:\n$$\n\\frac{d}{dt}\\int_V \\mathbf{U} dV + \\oint_{\\partial V} \\mathbf{F}_n dS = \\mathbf{0}\n$$\nHere, $\\mathbf{U}$ is the vector of conserved variables, and $\\mathbf{F}_n$ is the flux of $\\mathbf{U}$ normal to the boundary. For the two-dimensional Euler equations, the flux vector across a boundary element with unit normal $\\hat{\\mathbf{n}} = (n_x, n_y)$ is given by $\\mathbf{F} n_x + \\mathbf{G} n_y$, where $\\mathbf{F}$ and $\\mathbf{G}$ are the flux vectors in the Cartesian $x$ and $y$ directions, respectively.\n\nFor a steady-state, uniform free-stream, the state vector $\\mathbf{U}$ is constant throughout the domain. Consequently, its time derivative is zero, and the flux vectors $\\mathbf{F}(\\mathbf{U})$ and $\\mathbf{G}(\\mathbf{U})$ are also constant. The conservation law simplifies to the requirement that the net flux out of any closed control volume must be zero:\n$$\n\\oint_{\\partial V} (\\mathbf{F} n_x + \\mathbf{G} n_y) dS = \\mathbf{0}\n$$\nA finite volume method discretizes this integral by summing the fluxes over the distinct faces $f$ that form the boundary of a discrete control volume:\n$$\n\\mathbf{R} = \\sum_{f \\in \\partial V} (\\mathbf{F} n_{x,f} + \\mathbf{G} n_{y,f}) L_f\n$$\nwhere $\\mathbf{R}$ is the discrete residual, $L_f$ is the length of face $f$, and $(n_{x,f}, n_{y,f})$ is its outward unit normal.\n\nA crucial concept is the face area vector, $\\mathbf{s}_f$, defined as $\\mathbf{s}_f = (s_{x,f}, s_{y,f}) = (n_{x,f} L_f, n_{y,f} L_f)$. Using this definition, the discrete residual for a uniform state can be written as:\n$$\n\\mathbf{R} = \\sum_{f} (\\mathbf{F} s_{x,f} + \\mathbf{G} s_{y,f})\n$$\nSince the free-stream is uniform, the flux vectors $\\mathbf{F}$ and $\\mathbf{G}$ are constant and can be factored out of the summation:\n$$\n\\mathbf{R} = \\mathbf{F} \\left(\\sum_f s_{x,f}\\right) + \\mathbf{G} \\left(\\sum_f s_{y,f}\\right)\n$$\nFor any closed polyhedron (a $2$D polygon in this case), the sum of its outward-pointing face area vectors is identically zero. This is the **discrete Geometric Conservation Law (GCL)**:\n$$\n\\sum_f \\mathbf{s}_f = \\sum_f \\begin{pmatrix} s_{x,f} \\\\ s_{y,f} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\nIf the GCL is satisfied by the discrete geometry, it directly follows that the discrete residual $\\mathbf{R}$ for a uniform free-stream is identically zero. This is the essence of free-stream preservation.\n\nThe problem requires testing two scenarios for the flux calculation:\n$1$. **Consistent Formulation**: The flux projection uses the area vector $\\mathbf{s}_f$. The contribution from each face is $\\mathbf{F} s_{x,f} + \\mathbf{G} s_{y,f}$. As shown above, this formulation respects the GCL and will result in a zero residual (to machine precision).\n$2$. **Inconsistent Formulation**: The flux projection uses the unit normal vector $\\hat{\\mathbf{n}}_f = (n_{x,f}, n_{y,f})$ without the face length scaling. The face contribution is $\\mathbf{F} n_{x,f} + \\mathbf{G} n_{y,f}$. The total residual becomes:\n$$\n\\mathbf{R} = \\mathbf{F} \\left(\\sum_f n_{x,f}\\right) + \\mathbf{G} \\left(\\sum_f n_{y,f}\\right)\n$$\nThis residual is not guaranteed to be zero. It will only be zero if the vector sum of the face unit normals, $\\sum_f \\hat{\\mathbf{n}}_f$, is zero. This condition is met only for control volumes with special symmetries (e.g., rectangles on an orthogonal grid) but fails for general skewed or irregular cells. This inconsistency between the geometric closure requirement (which involves face areas/lengths) and the flux calculation (which discards lengths) leads to a loss of free-stream preservation.\n\nThe discrete operations that must be consistent are therefore those that define the geometry of the control volume and those that compute the flux across its boundary. Specifically:\n- In the **cell-centered** arrangement, the control volume is the primary grid cell, a polygon defined by a set of vertices. The face area vectors $\\mathbf{s}_f$ are derived from these vertex coordinates. To maintain consistency, the flux calculation must use these very same area vectors $\\mathbf{s}_f$.\n- In the **vertex-centered** arrangement, the control volume is a dual polygon, formed here by connecting the midpoints of edges incident to the central vertex. The face area vectors $\\mathbf{s}_f$ are derived from the coordinates of these midpoints. Consistency requires that the flux calculation uses these dual face area vectors.\n\nThe implementation will construct the specified meshes and control volumes. For each test case, it will define the vertices of the control polygon in a counter-clockwise order. It then iterates through the polygon's edges, computing the area vector $\\mathbf{s}_f$ and unit normal $\\hat{\\mathbf{n}}_f$ for each face. Based on the test's consistency requirement, it computes the face flux contribution using either $\\mathbf{s}_f$ or $\\hat{\\mathbf{n}}_f$. These contributions are summed to find the total residual vector $\\mathbf{R}$. Finally, a dimensionless ratio, $r = \\dfrac{\\|\\mathbf{R}\\|_2}{\\sum_{\\text{faces}} \\|\\text{flux contribution}\\|_2}$, is computed to quantify the magnitude of the violation.\n\nBased on the theory:\n- Tests $1$ and $3$, being consistent, should yield a ratio $r$ near machine precision zero, regardless of skew.\n- Tests $2$ and $4$ use an inconsistent formulation on a skewed grid ($s=0.3$). The symmetry is broken, so $\\sum_f \\hat{\\mathbf{n}}_f \\neq \\mathbf{0}$, leading to a non-zero residual and a ratio $r > 0$.\n- Tests $5$ and $6$ use an inconsistent formulation on an orthogonal grid ($s=0.0$). The control volumes (both primal and dual) are symmetric rectangles/squares. Due to this symmetry, $\\sum_f \\hat{\\mathbf{n}}_f = \\mathbf{0}$ by cancellation of opposing face normals. Thus, even the inconsistent scheme is expected to produce a zero residual, masking the underlying formulation error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the free-stream preservation tests.\n    \"\"\"\n\n    # 1. Define the uniform free-stream state\n    rho = 1.225  # density\n    u = 200.0    # x-velocity\n    v = 50.0     # y-velocity\n    p = 101325.0 # pressure\n    gamma = 1.4  # ratio of specific heats\n\n    # Calculate derived quantities\n    e = p / ((gamma - 1) * rho)\n    E_total = e + 0.5 * (u**2 + v**2)\n\n    # 2. Define the constant Euler flux vectors F and G\n    F_flux = np.array([\n        rho * u,\n        rho * u**2 + p,\n        rho * u * v,\n        (rho * E_total + p) * u\n    ])\n\n    G_flux = np.array([\n        rho * v,\n        rho * u * v,\n        rho * v**2 + p,\n        (rho * E_total + p) * v\n    ])\n\n    # 3. Define the test suite as specified in the problem\n    test_cases = [\n        # Test 1: cell-centered, skewed, consistent\n        {'type': 'cell', 's': 0.3, 'consistent': True},\n        # Test 2: cell-centered, skewed, inconsistent\n        {'type': 'cell', 's': 0.3, 'consistent': False},\n        # Test 3: vertex-centered, skewed, consistent\n        {'type': 'vertex', 's': 0.3, 'consistent': True},\n        # Test 4: vertex-centered, skewed, inconsistent\n        {'type': 'vertex', 's': 0.3, 'consistent': False},\n        # Test 5: cell-centered, orthogonal, inconsistent\n        {'type': 'cell', 's': 0.0, 'consistent': False},\n        # Test 6: vertex-centered, orthogonal, inconsistent\n        {'type': 'vertex', 's': 0.0, 'consistent': False},\n    ]\n\n    results = []\n    # 4. Execute each test case\n    for params in test_cases:\n        ratio = run_test(params, F_flux, G_flux)\n        results.append(ratio)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_vertices(s):\n    \"\"\"\n    Generates the 3x3 grid of vertex coordinates for a given skew factor s.\n    \"\"\"\n    vertices = np.zeros((3, 3, 2))\n    for j in range(3):\n        for i in range(3):\n            vertices[i, j, 0] = float(i) + s * float(j)\n            vertices[i, j, 1] = float(j)\n    return vertices\n\ndef compute_residual_for_polygon(polygon_vertices, use_consistent_flux, F, G):\n    \"\"\"\n    Computes the discrete residual and the dimensionless ratio for a given\n    closed polygon control volume.\n    \"\"\"\n    total_residual = np.zeros(4)\n    denominator_sum = 0.0\n    num_verts = len(polygon_vertices)\n\n    # Iterate over the faces of the polygon (defined by successive vertices)\n    for i in range(num_verts):\n        p1 = polygon_vertices[i]\n        p2 = polygon_vertices[(i + 1) % num_verts]  # Assumes CCW ordering\n\n        # Compute face geometry from its vertices\n        edge_vec = p2 - p1\n        # Area vector is normal to the edge, pointing outwards for CCW traversal\n        area_vec = np.array([edge_vec[1], -edge_vec[0]])\n        \n        length = np.linalg.norm(area_vec)\n        if length  1e-15:\n            # Should not happen with this problem's geometry\n            unit_normal = np.zeros(2)\n        else:\n            unit_normal = area_vec / length\n\n        # Select the projection vector based on consistency\n        if use_consistent_flux:\n            alpha = area_vec\n        else:\n            alpha = unit_normal\n\n        # Calculate the flux contribution for this face\n        flux_contribution = F * alpha[0] + G * alpha[1]\n        \n        # Accumulate the total residual and the denominator term\n        total_residual += flux_contribution\n        denominator_sum += np.linalg.norm(flux_contribution)\n\n    # Calculate the final dimensionless residual ratio\n    numerator = np.linalg.norm(total_residual)\n    if denominator_sum  1e-15:\n        return 0.0\n    \n    return numerator / denominator_sum\n\ndef run_test(params, F, G):\n    \"\"\"\n    Sets up and runs a single test case.\n    \"\"\"\n    s = params['s']\n    test_type = params['type']\n    is_consistent = params['consistent']\n\n    # Generate the primary 3x3 vertex grid\n    vertices = generate_vertices(s)\n    cv_polygon_verts = []\n\n    if test_type == 'cell':\n        # Select the first cell [0,0] for the test. Its vertices are\n        # (0,0), (1,0), (1,1), (0,1) in the (i,j) index space.\n        cv_polygon_verts = [\n            vertices[0, 0],\n            vertices[1, 0],\n            vertices[1, 1],\n            vertices[0, 1]\n        ]\n    elif test_type == 'vertex':\n        # Construct the dual control volume around the central vertex (1,1).\n        # The dual polygon connects the midpoints of the four incident edges.\n        v_c = vertices[1, 1]  # Central vertex\n        v_r = vertices[2, 1]  # Right neighbor\n        v_t = vertices[1, 2]  # Top neighbor\n        v_l = vertices[0, 1]  # Left neighbor\n        v_b = vertices[1, 0]  # Bottom neighbor\n        \n        # Midpoints forming the dual cell, ordered CCW around v_c to form the polygon\n        m_r = 0.5 * (v_c + v_r)\n        m_t = 0.5 * (v_c + v_t)\n        m_l = 0.5 * (v_c + v_l)\n        m_b = 0.5 * (v_c + v_b)\n        \n        cv_polygon_verts = [m_r, m_t, m_l, m_b]\n    \n    # Compute and return the residual ratio for the constructed control volume\n    return compute_residual_for_polygon(np.array(cv_polygon_verts), is_consistent, F, G)\n\n# Execute the main function\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}