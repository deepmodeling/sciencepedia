{
    "hands_on_practices": [
        {
            "introduction": "一个可靠的有限体积求解器首先必须精确地处理网格的几何信息。本基础实践通过验证几何守恒律，来测试求解器通量计算循环的核心实现。通过在各种复杂形状的单元上证明一个恒定向量场的离散散度为零，您将验证自己对如何正确计算面面积矢量和单元体积的理解，从而确保您的数值格式具备“离散精确性”。",
            "id": "3949241",
            "problem": "在计算流体动力学（CFD）的背景下，考虑一个由平面多边形面组成的三维非结构化控制体。设恒定速度场表示为 $\\boldsymbol{u}$，其分量为 $(u_x, u_y, u_z)$，单位为米/秒（m/s）。散度 $\\nabla \\cdot \\boldsymbol{u}$ 的单位为每秒（$\\mathrm{s}^{-1}$）。从高斯散度定理和基本矢量微积分出发，设计一个面通量循环，对于一个恒定场，该循环对任何具有平面面和朝外面面积矢量的闭合多面体控制体，都能产生恒等于零的离散散度。您的实现必须通过对所有面上的净向外通量求和，并除以控制体体积，来计算恒定矢量场的散度。您必须从第一性原理（问题陈述中不得引用任何捷径或预先推导的公式）推导出每个面和体积所需的几何量，确保科学真实性及与具体单元形状的无关性。\n\n您的要求如下：\n- 根据面顶点为每个平面多边形面构建朝外的面面积矢量。\n- 基于控制体形心，构建一个稳健的面朝向检查和校正机制，以确保所有面面积矢量都一致地指向外部。\n- 使用与面相同的几何构建块计算控制体体积。\n- 实现通量循环并计算恒定场 $\\boldsymbol{u}$ 的离散散度。\n- 验证离散精确性（散度的绝对值必须计算为零），该精确性应与单元形状无关，从而测试通量循环的正确性。\n\n所有空间坐标的单位均为米（m）。所有散度输出的单位必须为每秒（$\\mathrm{s}^{-1}$）。如果内部使用了角度，必须以弧度为单位处理。最终输出必须是数值浮点数。\n\n测试套件：\n使用以下五个单元和恒定场：\n- 恒定速度场：$\\boldsymbol{u} = (3.2, -1.7, 0.5)$，单位 m/s。\n\n单元1（边长为 $2\\,\\mathrm{m}$ 的平移轴对齐立方体）：\n定义顶点\n$v_{000} = (1, 2, 3)$, $v_{100} = (3, 2, 3)$, $v_{010} = (1, 4, 3)$, $v_{110} = (3, 4, 3)$, $v_{001} = (1, 2, 5)$, $v_{101} = (3, 2, 5)$, $v_{011} = (1, 4, 5)$, $v_{111} = (3, 4, 5)$。\n面（每个面表示为顶点标签的有序列表）：\n$[v_{000}, v_{100}, v_{110}, v_{010}]$, $[v_{001}, v_{011}, v_{111}, v_{101}]$, $[v_{000}, v_{010}, v_{011}, v_{001}]$, $[v_{100}, v_{101}, v_{111}, v_{110}]$, $[v_{000}, v_{001}, v_{101}, v_{100}]$, $[v_{010}, v_{110}, v_{111}, v_{011}]$。\n\n单元2（均匀剪切六面体，平面）：\n设平移矢量为 $\\boldsymbol{t} = (-2.2, 0.5, 1.1)$，$x$方向的顶部剪切量为 $\\Delta_x = 0.5$。定义顶点\n$b_{000} = \\boldsymbol{t} + (0.0, 0.0, 0.0)$,\n$b_{100} = \\boldsymbol{t} + (2.0, 0.0, 0.0)$,\n$b_{010} = \\boldsymbol{t} + (0.0, 1.5, 0.0)$,\n$b_{110} = \\boldsymbol{t} + (2.0, 1.5, 0.0)$,\n$b_{001} = \\boldsymbol{t} + (0.5, 0.0, 2.5)$,\n$b_{101} = \\boldsymbol{t} + (2.5, 0.0, 2.5)$,\n$b_{011} = \\boldsymbol{t} + (0.5, 1.5, 2.5)$,\n$b_{111} = \\boldsymbol{t} + (2.5, 1.5, 2.5)$。\n面：\n$[b_{000}, b_{100}, b_{110}, b_{010}]$,\n$[b_{001}, b_{011}, b_{111}, b_{101}]$,\n$[b_{000}, b_{010}, b_{011}, b_{001}]$,\n$[b_{100}, b_{101}, b_{111}, b_{110}]$,\n$[b_{000}, b_{001}, b_{101}, b_{100}]$,\n$[b_{010}, b_{110}, b_{111}, b_{011}]$。\n\n单元3（三角棱柱，顶部平移并有轻微位移）：\n设 $\\boldsymbol{t} = (1.0, -0.3, 4.0)$ 且 $\\boldsymbol{s} = (0.2, -0.1, 1.4)$。\n底部三角形顶点：\n$a_0 = \\boldsymbol{t} + (0.0, 0.0, 0.0)$,\n$b_0 = \\boldsymbol{t} + (1.2, 0.1, 0.0)$,\n$c_0 = \\boldsymbol{t} + (0.3, 1.1, 0.0)$。\n顶部三角形顶点：\n$a_1 = a_0 + \\boldsymbol{s}$,\n$b_1 = b_0 + \\boldsymbol{s}$,\n$c_1 = c_0 + \\boldsymbol{s}$。\n面：\n$[a_0, b_0, c_0]$,\n$[a_1, c_1, b_1]$,\n$[a_0, b_0, b_1, a_1]$,\n$[b_0, c_0, c_1, b_1]$,\n$[c_0, a_0, a_1, c_1]$。\n\n单元4（近简并的薄片四面体）：\n设 $\\boldsymbol{t} = (-0.7, 2.2, -1.3)$。\n顶点：\n$t_0 = \\boldsymbol{t} + (0.0, 0.0, 0.0)$,\n$t_1 = \\boldsymbol{t} + (1.0, 0.0, 0.0)$,\n$t_2 = \\boldsymbol{t} + (2.0, 0.01, 0.0)$,\n$t_3 = \\boldsymbol{t} + (1.0, 0.005, 0.001)$。\n面：\n$[t_0, t_2, t_1]$,\n$[t_0, t_1, t_3]$,\n$[t_1, t_2, t_3]$,\n$[t_2, t_0, t_3]$。\n\n单元5（四棱锥）：\n设 $\\boldsymbol{t} = (3.0, -1.0, 2.0)$。\n底面顶点：\n$s_0 = \\boldsymbol{t} + (0.0, 0.0, 0.0)$,\n$s_1 = \\boldsymbol{t} + (2.0, 0.0, 0.0)$,\n$s_2 = \\boldsymbol{t} + (2.0, 2.0, 0.0)$,\n$s_3 = \\boldsymbol{t} + (0.0, 2.0, 0.0)$。\n顶点：\n$s_4 = \\boldsymbol{t} + (1.0, 1.0, 1.5)$。\n面：\n$[s_0, s_1, s_2, s_3]$,\n$[s_0, s_1, s_4]$,\n$[s_1, s_2, s_4]$,\n$[s_2, s_3, s_4]$,\n$[s_3, s_0, s_4]$。\n\n答案规格：\n- 对于测试套件中的每个单元，使用您推导的几何构造，通过对面通量求和并按体积进行归一化，计算恒定场 $\\boldsymbol{u}$ 的离散散度的绝对值（单位：$\\mathrm{s}^{-1}$）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$），每个条目是上述相应单元的散度绝对值（单位：$\\mathrm{s}^{-1}$）。\n\n覆盖性设计：\n- 轴对齐立方体测试简单几何结构下的理想路径。\n- 均匀剪切六面体测试非正交但为平面的面。\n- 三角棱柱测试带有平移的混合三角形和四边形面。\n- 薄片四面体测试近简并几何形状和数值稳健性。\n- 四棱锥测试混合多边形类型和顶点连通性。\n\n您的解决方案必须是一个完整的、可运行的程序，实现上述要求并输出指定格式。不允许用户输入。",
            "solution": "该问题陈述是计算几何在计算流体动力学（CFD）有限体积法中应用的一个有效练习。它要求实现计算多面体控制体几何特性的基本算法，并利用这些算法来验证数值通量方案的一个关键属性：对恒定场的精确守恒。\n\n待验证的核心原理是高斯散度定理的一个推论，该定理指出，对于一个矢量场 $\\boldsymbol{u}$ 和一个由曲面 $\\partial V$ 包围的体积 $V$，以下关系成立：\n$$ \\int_V (\\nabla \\cdot \\boldsymbol{u}) \\, dV = \\oint_{\\partial V} \\boldsymbol{u} \\cdot d\\boldsymbol{S} $$\n在有限体积法的背景下，体积 $V$ 是一个控制体（或单元），面积分被离散化为对构成单元边界 $\\partial V$ 的平面 $f$ 上的通量求和：\n$$ \\oint_{\\partial V} \\boldsymbol{u} \\cdot d\\boldsymbol{S} \\approx \\sum_{f \\in \\partial V} (\\boldsymbol{u}_f \\cdot \\boldsymbol{A}_f) $$\n其中 $\\boldsymbol{u}_f$ 是面上的速度，$\\boldsymbol{A}_f$ 是面的朝外面积矢量。离散散度随后近似为净通量除以单元体积：\n$$ (\\nabla \\cdot \\boldsymbol{u})_V \\approx \\frac{1}{V} \\sum_{f \\in \\partial V} (\\boldsymbol{u}_f \\cdot \\boldsymbol{A}_f) $$\n问题指定了一个恒定速度场，$\\boldsymbol{u}(\\boldsymbol{r}) = \\boldsymbol{u}_{\\text{const}}$。对于这样的场，其解析散度恒等于零：$\\nabla \\cdot \\boldsymbol{u} = 0$。因此，体积分也为零，根据散度定理，通过任何闭合曲面的净通量也必须为零。要使一个离散格式对于恒定场是“精确”的，其离散散度也必须为零。对于一个恒定场，离散通量和变为：\n$$ \\sum_{f} (\\boldsymbol{u} \\cdot \\boldsymbol{A}_f) = \\boldsymbol{u} \\cdot \\left(\\sum_{f} \\boldsymbol{A}_f\\right) $$\n任何闭合多面体的一个基本几何特性是其所有朝外的面面积矢量之和为零矢量：\n$$ \\sum_{f} \\boldsymbol{A}_f = \\boldsymbol{0} $$\n这个“闭合”特性可以通过将散度定理应用于一个恒定矢量场（例如 $\\boldsymbol{k}=(1,0,0)$）来证明，对于该场 $\\nabla \\cdot \\boldsymbol{k} = 0$。这导致 $\\boldsymbol{k} \\cdot (\\sum_f \\boldsymbol{A}_f) = 0$，表明该和矢量的 $x$ 分量为零。对 $y$ 和 $z$ 方向的单位矢量重复此过程，可以确认该矢量和为 $\\boldsymbol{0}$。\n\n因此，对于恒定场，总通量必须精确为零：$\\boldsymbol{u} \\cdot \\boldsymbol{0} = 0$。因此，离散散度的计算结果应为零，其误差仅受浮点精度限制。任务是实现几何计算以验证此属性。\n\n实现将按以下步骤进行：\n\n**1. 面面积矢量的计算**\n对于一个由 $n$ 个有序顶点 $\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\dots, \\boldsymbol{v}_{n-1}$ 定义的平面多边形，其面积矢量 $\\boldsymbol{A}_f$ 可以使用类似于二维鞋带公式的稳健方法（通常称为 Newell 方法）来计算。面积矢量的分量由以下公式给出：\n$$ A_x = \\frac{1}{2} \\sum_{i=0}^{n-1} (y_i z_{i+1} - z_i y_{i+1}) $$\n$$ A_y = \\frac{1}{2} \\sum_{i=0}^{n-1} (z_i x_{i+1} - x_i z_{i+1}) $$\n$$ A_z = \\frac{1}{2} \\sum_{i=0}^{n-1} (x_i y_{i+1} - y_i x_{i+1}) $$\n其中 $(\\boldsymbol{v}_i)_x = x_i$，索引 $i+1$ 按 $n$ 取模（即 $\\boldsymbol{v}_n = \\boldsymbol{v}_0$）。所得矢量 $\\boldsymbol{A}_f = (A_x, A_y, A_z)$ 的方向由顶点的环绕顺序通过右手定则确定。\n\n**2. 面朝向校正**\n问题中提供的面的顶点顺序可能不一致。因此，我们必须为所有面面积矢量强制一个一致的朝外方向。\n   a. 通过对其所有唯一顶点的坐标求平均，计算控制体的近似几何形心 $\\boldsymbol{c}_V$。对于凸单元，此点保证在内部，对于一般多面体，它也是一个合理的参考点。\n   b. 对于每个面，通过对其顶点的坐标求平均，计算其形心 $\\boldsymbol{c}_f$。\n   c. 形成一个从单元形心指向面形心的矢量 $\\boldsymbol{d} = \\boldsymbol{c}_f - \\boldsymbol{c}_V$。\n   d. 使用初始顶点顺序计算面面积矢量 $\\boldsymbol{A}_f$。\n   e. 如果点积 $\\boldsymbol{A}_f \\cdot \\boldsymbol{d}$ 为负，则表示 $\\boldsymbol{A}_f$ 指向内部。为了校正这一点，我们必须翻转其方向：$\\boldsymbol{A}_f \\leftarrow -\\boldsymbol{A}_f$。为了保持后续计算（如体积计算）的一致性，面的顶点环绕顺序也必须反转。\n\n**3. 控制体体积计算**\n多面体的体积通过将其分解为四面体来计算。我们可以对由每个表面三角形和坐标系原点 $\\boldsymbol{O}$ 形成的四面体的有符号体积求和。\n   a. 首先，每个多边形面 $f$（其顶点顺序现已校正为朝外方向）必须被三角化。对于本问题中的凸平面多边形，从第一个顶点 $\\boldsymbol{v}_0$ 进行扇形三角剖分即可。这些三角形为 $(\\boldsymbol{v}_0, \\boldsymbol{v}_i, \\boldsymbol{v}_{i+1})$，其中 $i=1, \\dots, n-2$。\n   b. 一个具有顶点 $\\boldsymbol{O}, \\boldsymbol{a}, \\boldsymbol{b}, \\boldsymbol{c}$ 的四面体的有符号体积由标量三重积给出：$V_{\\text{tet}} = \\frac{1}{6} \\det([\\boldsymbol{a}, \\boldsymbol{b}, \\boldsymbol{c}]) = \\frac{1}{6} (\\boldsymbol{a} \\cdot (\\boldsymbol{b} \\times \\boldsymbol{c}))$。\n   c. 多面体的总体积 $V$ 是构成其边界的所有三角形的这些有符号体积之和：\n      $$ V = \\sum_{T_j=(\\boldsymbol{a},\\boldsymbol{b},\\boldsymbol{c}) \\in \\partial V} \\frac{1}{6} (\\boldsymbol{a} \\cdot (\\boldsymbol{b} \\times \\boldsymbol{c})) $$\n   该方法是稳健的，源于将散度定理应用于场 $\\boldsymbol{F}(\\boldsymbol{r})=\\boldsymbol{r}/3$。\n\n**4. 离散散度计算**\n在所有几何量都正确计算后，最终的计算就变得简单明了。\n   a. 使用恒定速度场 $\\boldsymbol{u}$ 和校正后的朝外面积矢量 $\\boldsymbol{A}_f$，通过对每个面的贡献求和来计算总通量：\n      $$ \\Phi = \\sum_{f} (\\boldsymbol{u} \\cdot \\boldsymbol{A}_f) $$\n   b. 离散散度是总通量除以单元体积：\n      $$ (\\nabla \\cdot \\boldsymbol{u})_V = \\frac{\\Phi}{V} $$\n根据理论，我们期望 $(\\nabla \\cdot \\boldsymbol{u})_V$ 在浮点误差范围内为零。最终答案将是这个计算出的散度的绝对值。",
            "answer": "```python\nimport numpy as np\n\ndef _get_cell_data():\n    \"\"\"\n    Defines the vertices and face connectivity for the five test cells.\n    Returns a list of tuples, where each tuple is (vertices, faces).\n    \"\"\"\n    \n    # Cell 1: Translated axis-aligned cube\n    v = {\n        '000': (1, 2, 3), '100': (3, 2, 3), '010': (1, 4, 3), '110': (3, 4, 3),\n        '001': (1, 2, 5), '101': (3, 2, 5), '011': (1, 4, 5), '111': (3, 4, 5)\n    }\n    v_map1 = {k: i for i, k in enumerate(v.keys())}\n    vertices1 = [v[k] for k in v.keys()]\n    faces1 = [\n        [v_map1[vk] for vk in ['000', '100', '110', '010']],\n        [v_map1[vk] for vk in ['001', '011', '111', '101']],\n        [v_map1[vk] for vk in ['000', '010', '011', '001']],\n        [v_map1[vk] for vk in ['100', '101', '111', '110']],\n        [v_map1[vk] for vk in ['000', '001', '101', '100']],\n        [v_map1[vk] for vk in ['010', '110', '111', '011']],\n    ]\n    \n    # Cell 2: Uniformly sheared hexahedron\n    t = np.array([-2.2, 0.5, 1.1])\n    b = {\n        '000': t + np.array([0.0, 0.0, 0.0]), '100': t + np.array([2.0, 0.0, 0.0]),\n        '010': t + np.array([0.0, 1.5, 0.0]), '110': t + np.array([2.0, 1.5, 0.0]),\n        '001': t + np.array([0.5, 0.0, 2.5]), '101': t + np.array([2.5, 0.0, 2.5]),\n        '011': t + np.array([0.5, 1.5, 2.5]), '111': t + np.array([2.5, 1.5, 2.5])\n    }\n    b_map2 = {k: i for i, k in enumerate(b.keys())}\n    vertices2 = [b[k] for k in b.keys()]\n    faces2 = [\n        [b_map2[bk] for bk in ['000', '100', '110', '010']],\n        [b_map2[bk] for bk in ['001', '011', '111', '101']],\n        [b_map2[bk] for bk in ['000', '010', '011', '001']],\n        [b_map2[bk] for bk in ['100', '101', '111', '110']],\n        [b_map2[bk] for bk in ['000', '001', '101', '100']],\n        [b_map2[bk] for bk in ['010', '110', '111', '011']],\n    ]\n\n    # Cell 3: Triangular prism\n    t_prism = np.array([1.0, -0.3, 4.0])\n    s_prism = np.array([0.2, -0.1, 1.4])\n    a0 = t_prism + np.array([0.0, 0.0, 0.0])\n    b0 = t_prism + np.array([1.2, 0.1, 0.0])\n    c0 = t_prism + np.array([0.3, 1.1, 0.0])\n    a1 = a0 + s_prism; b1 = b0 + s_prism; c1 = c0 + s_prism\n    vertices3 = [a0, b0, c0, a1, b1, c1]\n    faces3 = [\n        [0, 1, 2], [3, 5, 4], \n        [0, 1, 4, 3], [1, 2, 5, 4], [2, 0, 3, 5]\n    ]\n\n    # Cell 4: Sliver tetrahedron\n    t_tet = np.array([-0.7, 2.2, -1.3])\n    t0 = t_tet + np.array([0.0, 0.0, 0.0])\n    t1 = t_tet + np.array([1.0, 0.0, 0.0])\n    t2 = t_tet + np.array([2.0, 0.01, 0.0])\n    t3 = t_tet + np.array([1.0, 0.005, 0.001])\n    vertices4 = [t0, t1, t2, t3]\n    faces4 = [ [0, 2, 1], [0, 1, 3], [1, 2, 3], [2, 0, 3] ]\n\n    # Cell 5: Square pyramid\n    t_pyr = np.array([3.0, -1.0, 2.0])\n    s0 = t_pyr + np.array([0.0, 0.0, 0.0])\n    s1 = t_pyr + np.array([2.0, 0.0, 0.0])\n    s2 = t_pyr + np.array([2.0, 2.0, 0.0])\n    s3 = t_pyr + np.array([0.0, 2.0, 0.0])\n    s4 = t_pyr + np.array([1.0, 1.0, 1.5])\n    vertices5 = [s0, s1, s2, s3, s4]\n    faces5 = [ [0, 1, 2, 3], [0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4] ]\n    \n    return [\n        (vertices1, faces1), (vertices2, faces2), (vertices3, faces3),\n        (vertices4, faces4), (vertices5, faces5)\n    ]\n\ndef compute_face_area_vector(face_vertices):\n    \"\"\"Computes the area vector of a planar polygon using Newell's method.\"\"\"\n    n = len(face_vertices)\n    area_vec = np.zeros(3)\n    for i in range(n):\n        v_curr = face_vertices[i]\n        v_next = face_vertices[(i + 1) % n]\n        area_vec[0] += (v_curr[1] * v_next[2] - v_next[1] * v_curr[2])\n        area_vec[1] += (v_curr[2] * v_next[0] - v_next[2] * v_curr[0])\n        area_vec[2] += (v_curr[0] * v_next[1] - v_next[0] * v_curr[1])\n    return 0.5 * area_vec\n\ndef compute_discrete_divergence(vertices, faces, velocity_vector):\n    \"\"\"\n    Computes the discrete divergence of a vector field for a single polyhedral cell.\n    \"\"\"\n    vertices_np = [np.array(v) for v in vertices]\n    \n    # 1. Compute approximate cell centroid for orientation checking\n    cell_centroid = np.mean(vertices_np, axis=0)\n    \n    total_flux = 0.0\n    total_volume = 0.0\n\n    for face_indices in faces:\n        # 2. Get vertex coordinates for the current face\n        face_verts = [vertices_np[i] for i in face_indices]\n        \n        # 3. Compute initial face area vector\n        area_vec = compute_face_area_vector(face_verts)\n        \n        # 4. Check and correct orientation\n        face_centroid = np.mean(face_verts, axis=0)\n        vec_to_face = face_centroid - cell_centroid\n        \n        if np.dot(area_vec, vec_to_face) < 0:\n            area_vec = -area_vec\n            # Reverse vertex order to maintain consistent winding for volume calc\n            face_verts.reverse()\n            \n        # 5. Compute flux through this face\n        flux = np.dot(velocity_vector, area_vec)\n        total_flux += flux\n        \n        # 6. Compute volume contribution from this face (triangulate and sum tetrahedra)\n        # Fan triangulation from the first vertex\n        v0 = face_verts[0]\n        for i in range(1, len(face_verts) - 1):\n            v1 = face_verts[i]\n            v2 = face_verts[i+1]\n            # Signed volume of tetrahedron (origin, v0, v1, v2)\n            # using scalar triple product det([v0, v1, v2])\n            tet_vol = np.dot(v0, np.cross(v1, v2))\n            total_volume += tet_vol\n            \n    # Finalize volume calculation (1/6 factor) and compute divergence\n    total_volume /= 6.0\n    \n    if abs(total_volume) < 1e-15:\n        # If volume is zero or near-zero, divergence is undefined or infinite.\n        # However, for a constant field, flux is also zero. We return 0.\n        return 0.0\n        \n    divergence = total_flux / total_volume\n    return abs(divergence)\n\ndef solve():\n    \"\"\"Main solver function.\"\"\"\n    \n    # Define constant velocity field\n    u_const = np.array([3.2, -1.7, 0.5])\n    \n    # Get test case data\n    test_cases = _get_cell_data()\n    \n    results = []\n    for vertices, faces in test_cases:\n        result = compute_discrete_divergence(vertices, faces, u_const)\n        results.append(f\"{result:.8g}\") # Format to avoid excessive precision display\n\n    # Print results in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "沉浸边界法等先进的网格技术虽然功能强大，但也可能产生尺寸差异极大的单元，这对显式数值格式构成了严峻挑战。本练习将深入探讨单元尺寸与Courant–Friedrichs–Lewy (CFL)稳定性条件之间的关系，揭示为何“小切割单元”会因强制使用极小的时间步长而导致模拟效率低下。接着，您将实现一种守恒的单元合并策略，这是一种克服此严重时间步长限制的实用且关键的技术。",
            "id": "3949209",
            "problem": "考虑一个无源标量的线性平流方程的一维有限体积离散化，该离散化建立在可能包含由几何浸入产生的切割单元（cut-cell）的网格上：标量场 $q(x,t)$ 满足积分守恒律\n$$\n\\frac{d}{dt}\\int_{V_i} q \\, dx + \\sum_{f \\in \\partial V_i} F_f = 0,\n$$\n其中 $V_i$ 是第 $i$ 个单元的控制体，$\\partial V_i$ 表示第 $i$ 个单元的边界面的集合，$F_f$ 是通过面 $f$ 的平流通量。在一个空间维度中，对于一个恒定的正输运速度 $u$，通过单元 $i$ 和 $i+1$ 之间交界面的平流通量为 $F_{i+1/2} = u\\, q_{i}^{\\text{up}}$，其中 $q_{i}^{\\text{up}}$ 是与该面相关的迎风状态。对于一个显式单调格式，其稳定性受 Courant–Friedrichs–Lewy (CFL) 条件的约束，该条件基于时间步长与每个控制体特征局部穿越时间之比。\n\n您的任务是从第一性原理出发，以积分守恒律和显式有限体积更新为起点，证明为什么小的切割单元会导致对允许的显式时间步长的严格限制。然后，您必须推导出一个单元合并策略，该策略：\n- 通过消除过小的控制体来维持稳定性，并且\n- 保持通量的守恒性，即合并后控制体上的总质量更新等于其组成的原始控制体上质量更新的总和。\n\n您必须在一个独立的程序中实现以下内容：\n\n1. 从积分守恒律和一个相容的、单调的显式有限体积格式出发，推导出一个数学上合理的稳定时间步长 $\\Delta t$ 的表达式，给定一个恒定的正速度 $u$ 和一维中的一组单元长度 $\\{\\Delta x_i\\}$。除了显式更新的定义和格式必须是守恒和单调的要求外，不要假设任何特殊形式。将 $\\Delta t$ 以秒（$\\mathrm{s}$）表示。\n\n2. 提出并实现一个单元合并策略，该策略接收一个具有单元长度 $\\{\\Delta x_i\\}$ 的网格，并将任何长度 $\\Delta x_i$ 小于阈值 $\\alpha \\ell_{\\mathrm{ref}}$ 的单元 $i$ 进行合并，其中 $\\alpha \\in (0,1)$ 且 $\\ell_{\\mathrm{ref}}$ 是一个根据原始网格计算出的固定参考长度（例如，一个稳健的统计量，如中位数）。您的策略必须：\n   - 选择一个邻居进行合并（对于内部的小单元，您可以选择右邻居；对于边界上的小单元，选择其唯一的内部邻居），\n   - 将合并后的单元长度定义为 $\\Delta x_{\\mathrm{merged}} = \\Delta x_i + \\Delta x_j$，\n   - 为保持质量守恒，将合并后的单元平均值定义为 $q_{\\mathrm{merged}} = \\dfrac{\\Delta x_i q_i + \\Delta x_j q_j}{\\Delta x_i + \\Delta x_j}$，\n   - 迭代合并过程，直到所有单元都满足 $\\Delta x_k \\ge \\alpha \\ell_{\\mathrm{ref}}$，\n   - 在合并过程中保持 $\\ell_{\\mathrm{ref}}$ 不变。\n\n3. 在原始网格和合并后的网格上，使用您推导的稳定性准则计算稳定时间步长 $\\Delta t_{\\mathrm{orig}}$ 和 $\\Delta t_{\\mathrm{merged}}$（以秒 $\\mathrm{s}$ 为单位）。通过报告比率 $r = \\Delta t_{\\mathrm{merged}} / \\Delta t_{\\mathrm{orig}}$ 来展示由小切割单元引起的 CFL 限制的严重性。\n\n4. 通过在原始网格上使用 $\\Delta t_{\\mathrm{orig}}$ 和在合并网格上使用 $\\Delta t_{\\mathrm{merged}}$ 执行一个时间步长的显式迎风更新，来验证通量的守恒性。使用周期性边界条件。使用面通量 $F_{i+1/2} = u q_i$，其中 $u$ 为正（纯迎风）。计算更新前后的总质量，\n$$\nM_{\\mathrm{before}} = \\sum_i q_i \\Delta x_i, \\quad M_{\\mathrm{after}} = \\sum_i q_i^{n+1} \\Delta x_i,\n$$\n并报告两种网格的绝对质量守恒误差 $\\varepsilon = \\left| M_{\\mathrm{after}} - M_{\\mathrm{before}} \\right|$。任何用于三角函数初始化的角度必须以弧度为单位。\n\n为使问题具体且可测试，请使用以下测试套件。对于每种情况，都提供了速度 $u$、阈值参数 $\\alpha$、参考长度 $\\ell_{\\mathrm{ref}}$（计算为原始 $\\{\\Delta x_i\\}$ 的中位数）和库朗数 $\\nu$。单元 $i$ 中的初始标量场应设置为 $q_i = \\sin(2\\pi x_i / L)$，其中 $x_i$ 是单元中心坐标，$L = \\sum_i \\Delta x_i$ 是域长度，角度以弧度为单位。\n\n- 情况 A（有一个小切割单元的理想路径）：\n  - $u = 100\\,\\mathrm{m/s}$, $\\nu = 0.5$, $\\alpha = 0.2$,\n  - $\\{\\Delta x_i\\} = [1,1,1,1,0.001,1,1,1,1,1]\\,\\mathrm{m}$。\n\n- 情况 B（有极小边界切割单元的边缘情况）：\n  - $u = 100\\,\\mathrm{m/s}$, $\\nu = 0.5$, $\\alpha = 0.2$,\n  - $\\{\\Delta x_i\\} = [0.000001,1,1,1,1,1,1,1,1,1]\\,\\mathrm{m}$。\n\n- 情况 C（两个相邻的小切割单元）：\n  - $u = 100\\,\\mathrm{m/s}$, $\\nu = 0.5$, $\\alpha = 0.2$,\n  - $\\{\\Delta x_i\\} = [1,1,1,1,1,0.0005,0.0007,1,1,1]\\,\\mathrm{m}$。\n\n- 情况 D（无切割单元，均匀网格）：\n  - $u = 100\\,\\mathrm{m/s}$, $\\nu = 0.5$, $\\alpha = 0.2$,\n  - $\\{\\Delta x_i\\} = [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5]\\,\\mathrm{m}$。\n\n对于每种情况，您的程序必须按顺序计算并输出以下五个量：\n- $\\Delta t_{\\mathrm{orig}}\\,\\mathrm{(s)}$,\n- $\\Delta t_{\\mathrm{merged}}\\,\\mathrm{(s)}$,\n- $r = \\Delta t_{\\mathrm{merged}} / \\Delta t_{\\mathrm{orig}}$ (无量纲),\n- $\\varepsilon_{\\mathrm{orig}}$,\n- $\\varepsilon_{\\mathrm{merged}}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个列表的列表，每个测试用例一个列表，每个内部列表按上述顺序包含五个浮点数结果，整个输出用方括号括起来。例如，一个有效的输出行格式为\n$$\n[[\\Delta t_{\\mathrm{orig}},\\Delta t_{\\mathrm{merged}},r,\\varepsilon_{\\mathrm{orig}},\\varepsilon_{\\mathrm{merged}}],\\ldots].\n$$",
            "solution": "该问题要求推导非均匀网格上显式有限体积格式的稳定性约束，解释为什么小的“切割单元”会产生问题，设计一种质量守恒的单元合并算法来缓解此问题，并对此方法的属性进行数值验证。\n\n### 第 1 部分：稳定性约束与小单元问题\n\n我们从一维线性平流方程对标量 $q(x,t)$ 在控制体 $V_i = [x_{i-1/2}, x_{i+1/2}]$（长度为 $\\Delta x_i = x_{i+1/2} - x_{i-1/2}$）上的积分形式开始：\n$$\n\\frac{d}{dt}\\int_{x_{i-1/2}}^{x_{i+1/2}} q(x,t) \\, dx + F_{i+1/2} - F_{i-1/2} = 0\n$$\n其中 $F_{i\\pm1/2}$ 表示在单元交界面上的平流通量。令 $q_i(t)$ 为单元平均量，定义为 $q_i(t) = \\frac{1}{\\Delta x_i} \\int_{V_i} q(x,t) \\, dx$。守恒律可以重写为单元平均值的形式：\n$$\n\\Delta x_i \\frac{d q_i}{d t} + F_{i+1/2} - F_{i-1/2} = 0\n$$\n对于恒定的正平流速度 $u > 0$，一阶迎风格式根据紧邻面上游单元中的标量值来定义面上的通量。因此，面 $i+1/2$ 处的通量由单元 $i$ 的状态决定，面 $i-1/2$ 处的通量由单元 $i-1$ 的状态决定：\n$$\nF_{i+1/2} = u \\, q_i(t)\n$$\n$$\nF_{i-1/2} = u \\, q_{i-1}(t)\n$$\n将这些通量代入半离散方程，得到：\n$$\n\\frac{d q_i}{d t} = -\\frac{u}{\\Delta x_i} (q_i - q_{i-1})\n$$\n使用显式向前欧拉法以时间步长 $\\Delta t$ 进行时间离散化，其中 $q_i^n = q_i(n\\Delta t)$，我们得到全离散更新公式：\n$$\n\\frac{q_i^{n+1} - q_i^n}{\\Delta t} = -\\frac{u}{\\Delta x_i} (q_i^n - q_{i-1}^n)\n$$\n整理得到 $q_i^{n+1}$ 的表达式，即单个单元的更新方程：\n$$\nq_i^{n+1} = q_i^n - \\frac{u \\Delta t}{\\Delta x_i} (q_i^n - q_{i-1}^n)\n$$\n我们可以将其表示为前一时间步状态的加权平均：\n$$\nq_i^{n+1} = \\left(1 - \\frac{u \\Delta t}{\\Delta x_i}\\right) q_i^n + \\left(\\frac{u \\Delta t}{\\Delta x_i}\\right) q_{i-1}^n\n$$\n令单元 $i$ 的局部库朗数（Courant number）为 $\\nu_i = \\frac{u \\Delta t}{\\Delta x_i}$。方程变为：\n$$\nq_i^{n+1} = (1 - \\nu_i) q_i^n + \\nu_i q_{i-1}^n\n$$\n为了使一个格式是单调的（这是稳定性的一个充分条件，可以防止产生新的、非物理的振荡），新值 $q_i^{n+1}$ 必须是旧值的凸组合。这要求加权平均中的所有系数都为非负。由于 $u$、$\\Delta t$ 和 $\\Delta x_i$ 均为正，系数 $\\nu_i$ 是非负的。第一个系数要求：\n$$\n1 - \\nu_i \\ge 0 \\implies \\nu_i \\le 1\n$$\n代入 $\\nu_i$ 的定义，我们得到单元 $i$ 的 Courant–Friedrichs–Lewy (CFL) 条件：\n$$\n\\frac{u \\Delta t}{\\Delta x_i} \\le 1 \\implies \\Delta t \\le \\frac{\\Delta x_i}{u}\n$$\n这个条件必须对计算域中的每个单元 $i$ 都成立。因此，全局时间步长 $\\Delta t$ 受到具有最小穿越时间 $\\Delta x_i/u$ 的单元的限制：\n$$\n\\Delta t \\le \\min_{i} \\left(\\frac{\\Delta x_i}{u}\\right) = \\frac{\\min_{i}(\\Delta x_i)}{u}\n$$\n此推导明确地显示了为什么小单元是有问题的。显式格式所允许的最大时间步长与网格中的最小单元尺寸成正比。在涉及浸入边界的应用中，可能会出现体积（或在一维中的长度）比周围常规单元小数个数量级的切割单元。即使只有一个这样的小单元，也会迫使全局时间步长变得过小，从而使模拟在计算上变得不可行。\n\n为了管理这个问题，我们通常使用一个指定的库朗数 $\\nu \\in (0,1)$ 作为安全因子，将稳定时间步长定义为：\n$$\n\\Delta t = \\nu \\cdot \\min_{i} \\left(\\frac{\\Delta x_i}{u}\\right)\n$$\n\n### 第 2 部分：守恒的单元合并策略\n\n为了克服小单元带来的严格时间步长限制，一个常见的策略是将它们与邻近单元合并。合并操作必须是守恒的，这意味着合并后单元中的总质量（或标量总量）必须等于组成单元中质量的总和。\n\n假设单元 $i$ 是一个要与邻近单元 $j$ 合并的小单元。任何单元 $k$ 的总质量 $m_k$ 为 $m_k = q_k \\Delta x_k$。合并的守恒条件是：\n$$\nm_{\\mathrm{merged}} = m_i + m_j\n$$\n新的单元长度就是原始长度之和：$\\Delta x_{\\mathrm{merged}} = \\Delta x_i + \\Delta x_j$。新的单元平均值 $q_{\\mathrm{merged}}$ 则由守恒条件定义：\n$$\nq_{\\mathrm{merged}} \\Delta x_{\\mathrm{merged}} = q_i \\Delta x_i + q_j \\Delta x_j\n$$\n$$\nq_{\\mathrm{merged}} = \\frac{q_i \\Delta x_i + q_j \\Delta x_j}{\\Delta x_{\\mathrm{merged}}} = \\frac{q_i \\Delta x_i + q_j \\Delta x_j}{\\Delta x_i + \\Delta x_j}\n$$\n这定义了一个保持质量的平均值。\n\n合并算法如下：\n1. 确定一个参考长度尺度 $\\ell_{\\mathrm{ref}}$，例如所有原始单元长度的中位数。中位数是一个稳健的统计量，不受小切割单元本身极端值的影响。\n2. 定义一个判断单元是否过小的阈值 $\\Delta x_{\\mathrm{th}} = \\alpha \\ell_{\\mathrm{ref}}$，其中 $\\alpha \\in (0,1)$ 是一个用户定义的参数。\n3. 迭代地扫描网格。如果发现一个单元 $i$ 满足 $\\Delta x_i < \\Delta x_{\\mathrm{th}}$：\n    a. 确定一个邻近单元 $j$ 进行合并。一个一致的规则是与右邻居（$j=i+1$）合并，除非小单元是域中的最后一个单元，此时它与左邻居（$j=i-1$）合并。\n    b. 使用上述公式计算新的单元属性 $\\Delta x_{\\mathrm{merged}}$ 和 $q_{\\mathrm{merged}}$。\n    c. 用单个合并后的单元替换单元 $i$ 和 $j$。\n    d. 从修改后的网格的开头重新开始扫描。\n4. 当对网格的完整扫描没有发现任何小于阈值的单元时，过程终止。最终的网格保证其最小单元尺寸至少为 $\\Delta x_{\\mathrm{th}}$，从而允许一个大得多的时间步长 $\\Delta t_{\\mathrm{merged}}$。\n\n### 第 3 部分：质量守恒的验证\n\n离散更新方程可以乘以 $\\Delta x_i$，以单元质量 $M_i = q_i \\Delta x_i$ 的形式表示：\n$$\nM_i^{n+1} - M_i^n = -\\Delta t (F_{i+1/2}^n - F_{i-1/2}^n)\n$$\n为了检查全局质量守恒，我们将此方程对域中所有 $N$ 个单元（索引从 $i=0$ 到 $N-1$）求和：\n$$\n\\sum_{i=0}^{N-1} M_i^{n+1} - \\sum_{i=0}^{N-1} M_i^n = -\\Delta t \\sum_{i=0}^{N-1} (F_{i+1/2}^n - F_{i-1/2}^n)\n$$\n通量差值的和是一个伸缩级数：\n$$\n\\sum_{i=0}^{N-1} (F_{i+1/2} - F_{i-1/2}) = (F_{1/2} - F_{-1/2}) + (F_{3/2} - F_{1/2}) + \\dots + (F_{N-1/2} - F_{N-3/2}) + (F_{N+1/2} - F_{N-1/2})\n$$\n对于周期性边界条件，单元 $i=0$ 的面 $i-1/2$ 的物理位置与单元 $i=N-1$ 的面 $i+1/2$ 相同。因此，$F_{-1/2} = F_{N-1/2}$ 且 $F_{N+1/2} = F_{1/2}$。该和变为：\n$$\n-F_{-1/2} + F_{N+1/2} = -F_{N-1/2} + F_{1/2}\n$$\n这不完全为零。通量的定义是关键。对于周期性条件，我们必须确保 $i=N-1$ 的 $F_{i+1/2}$ 是流入单元 $0$ 的通量。让我们使用索引 $i$ 和 $i-1$（带回绕）来更新单元 $i$。\n流入单元 $i$ 的通量是 $F_{i-1/2}=u q_{i-1}^n$。流出单元 $i$ 的通量是 $F_{i+1/2}=u q_{i}^n$。净通量为 $u(q_i^n - q_{i-1}^n)$。\n总质量的变化是 $\\Delta M = M_{\\text{after}} - M_{\\text{before}} = \\sum \\Delta x_i (q_i^{n+1} - q_i^n)$。\n$$\n\\Delta M = \\sum_{i=0}^{N-1} \\Delta x_i \\left( -\\frac{u \\Delta t}{\\Delta x_i}(q_i^n-q_{i-1}^n) \\right) = -u \\Delta t \\sum_{i=0}^{N-1} (q_i^n - q_{i-1}^n)\n$$\n该和为 $\\sum_{i=0}^{N-1} q_i^n - \\sum_{i=0}^{N-1} q_{i-1}^n$。在周期性边界下，当 $i=0$ 时，索引 $i-1$ 为 $N-1$。索引集合 $\\{i\\}$ 和 $\\{i-1\\}$ 是相同的，只是进行了移位。因此，这两个和是相等的：\n$$\n\\sum_{i=0}^{N-1} q_i^n = \\sum_{i=0}^{N-1} q_{i-1}^n\n$$\n因此总质量变化 $\\Delta M$ 精确为零。\n$$\n\\Delta M = -u \\Delta t \\cdot 0 = 0\n$$\n这证明了一阶迎风格式在周期性域上是完全守恒的。在数值实现中观察到的任何非零质量守恒误差 $\\varepsilon = |M_{\\text{after}} - M_{\\text{before}}|$，必然是由于浮点表示和算术误差引起的。此分析对原始网格和合并后的网格均成立。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: happy path with one small cut-cell\n        (100.0, 0.5, 0.2, np.array([1, 1, 1, 1, 0.001, 1, 1, 1, 1, 1], dtype=float)),\n        # Case B: edge case with extremely small boundary cut-cell\n        (100.0, 0.5, 0.2, np.array([0.000001, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=float)),\n        # Case C: two adjacent small cut-cells\n        (100.0, 0.5, 0.2, np.array([1, 1, 1, 1, 1, 0.0005, 0.0007, 1, 1, 1], dtype=float)),\n        # Case D: no cut-cells, uniform mesh\n        (100.0, 0.5, 0.2, np.array([0.5]*20, dtype=float))\n    ]\n\n    all_results = []\n    for u, nu, alpha, dx_orig in test_cases:\n        result_tuple = solve_case(u, nu, alpha, dx_orig)\n        all_results.append(list(result_tuple))\n\n    # Final print statement in the exact required format.\n    # The format [[...],[...]] is achieved by using str() on each inner list\n    # and then joining them.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef solve_case(u, nu, alpha, dx_orig):\n    \"\"\"\n    Solves a single test case for the given parameters.\n    \n    Returns a tuple of five values:\n    (dt_orig, dt_merged, r, eps_orig, eps_merged)\n    \"\"\"\n\n    # 1. Initialize original mesh properties\n    L_orig = np.sum(dx_orig)\n    x_centers_orig = np.cumsum(dx_orig) - dx_orig / 2.0\n    q_orig = np.sin(2 * np.pi * x_centers_orig / L_orig)\n    \n    # Derivation: dt = nu * min(dx_i / u). So dt = nu * min(dx_i) / u\n    dt_orig = nu * np.min(dx_orig) / u\n\n    # 2. Cell Merging\n    l_ref = np.median(dx_orig)\n    merge_threshold = alpha * l_ref\n    \n    dx_list = list(dx_orig)\n    q_list = list(q_orig)\n\n    while True:\n        found_small_cell = False\n        # Find the first cell smaller than the threshold\n        for i in range(len(dx_list)):\n            if dx_list[i] < merge_threshold:\n                found_small_cell = True\n                \n                # Determine merge partner: right neighbor, unless it's the last cell\n                if i == len(dx_list) - 1:\n                    j = i - 1\n                else:\n                    j = i + 1\n                \n                # Ensure indices are ordered for easier list manipulation\n                idx1, idx2 = min(i, j), max(i, j)\n                \n                dx1, dx2 = dx_list[idx1], dx_list[idx2]\n                q1, q2 = q_list[idx1], q_list[idx2]\n                \n                # Calculate mass-conservative merged properties\n                dx_merged_val = dx1 + dx2\n                q_merged_val = (q1 * dx1 + q2 * dx2) / dx_merged_val\n                \n                # Update lists: replace element at idx1, remove element at idx2\n                dx_list[idx1] = dx_merged_val\n                q_list[idx1] = q_merged_val\n                dx_list.pop(idx2)\n                q_list.pop(idx2)\n                \n                # Restart the scan since the mesh has changed\n                break\n        \n        if not found_small_cell:\n            break\n            \n    dx_merged = np.array(dx_list)\n    q_merged = np.array(q_list)\n\n    # 3. Compute merged time step and ratio\n    dt_merged = nu * np.min(dx_merged) / u\n    r = dt_merged / dt_orig if dt_orig > 0 else 0\n\n    # 4. Verify conservation on original mesh\n    M_before_orig = np.sum(q_orig * dx_orig)\n    q_new_orig = np.zeros_like(q_orig)\n    n_orig = len(dx_orig)\n    for i in range(n_orig):\n        i_prev = (i - 1 + n_orig) % n_orig # Periodic boundary condition\n        # For u > 0, flux depends on upwind (left) cell\n        F_right = u * q_orig[i]\n        F_left = u * q_orig[i_prev]\n        q_new_orig[i] = q_orig[i] - (dt_orig / dx_orig[i]) * (F_right - F_left)\n    M_after_orig = np.sum(q_new_orig * dx_orig)\n    eps_orig = np.abs(M_after_orig - M_before_orig)\n\n    # 5. Verify conservation on merged mesh\n    M_before_merged = np.sum(q_merged * dx_merged) # Should equal M_before_orig\n    q_new_merged = np.zeros_like(q_merged)\n    n_merged = len(dx_merged)\n    for i in range(n_merged):\n        i_prev = (i - 1 + n_merged) % n_merged # Periodic boundary condition\n        F_right = u * q_merged[i]\n        F_left = u * q_merged[i_prev]\n        q_new_merged[i] = q_merged[i] - (dt_merged / dx_merged[i]) * (F_right - F_left)\n    M_after_merged = np.sum(q_new_merged * dx_merged)\n    eps_merged = np.abs(M_after_merged - M_before_merged)\n    \n    return dt_orig, dt_merged, r, eps_orig, eps_merged\n\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "获得数值解只是工作的一半，评估其可信度同等重要。本实践介绍了计算流体力学验证与确认中的网格收敛指数（Grid Convergence Index, GCI），它提供了一种系统性方法来估计模拟中的离散化误差。通过分析一系列系统加密网格得到的结果，您将学会如何计算观测到的精度阶数并量化解的不确定性，这是任何严谨CFD分析都需具备的关键技能。",
            "id": "3949223",
            "problem": "一个关于对称翼型外流的二维雷诺平均纳维-斯托克斯 (RANS) 计算使用了一族三个系统加密的、拓扑相似的结构化网格。设特征网格间距为 $h_1 < h_2 < h_3$，其恒定的加密比为 $r = 2$。计算得到的阻力系数 $C_D$ 在这三个网格上分别为 $C_D(h_1) = 0.02340$、$C_D(h_2) = 0.02370$ 和 $C_D(h_3) = 0.02490$。\n\n基于 Richardson 外推法的离散误差模型，并假设解处于渐近收敛区域，您的任务是推导并计算最细网格解的网格收敛指数 (GCI)。\n\n推导以下内容：\n1.  观测到的精度阶 $p$ 的表达式，该表达式是解 $Q_1, Q_2, Q_3$ 和加密比 $r$ 的函数。\n2.  使用两个最精细网格上的解（$Q_1, Q_2$）、加密比 $r$ 和您推导出的精度阶 $p$ 来获得的 Richardson 外推连续介质值 $Q^{\\ast}$ 的表达式。\n3.  最细网格 $GCI_{\\text{fine}}$ 的公式，表示为安全因子 $F_s$、加密比 $r$、精度阶 $p$ 以及两个最精细网格上的解 $Q_1, Q_2$ 的函数。\n\n计算最细网格 $GCI_{\\text{fine}}$：\n-   使用给定的 $C_D$ 值作为解量 $Q$。\n-   使用安全因子 $F_s = 1.25$，这对于使用三个或更多网格的情况是推荐值。\n-   您的最终答案应四舍五入到四位有效数字。\n\n给定的网格参数：\n$h_1 = 0.00050$\n$h_2 = 0.00100$\n$h_3 = 0.00200$\n您的最终答案应仅为计算出的 $GCI_{\\text{fine}}$ 的数值，并用 $\\boxed{\\text{}}$ 框起来。",
            "solution": "问题陈述已经过严格审查并被确定为有效。其科学基础是数值分析和计算流体力学的原理，特别是 Richardson 外推法和网格收敛指数 (GCI) 方法。该问题是自洽的、适定的，并且所有提供的数据都是一致和充分的，足以得到唯一解。因此，我们可以进行正式求解。\n\n该问题要求基于从数值模拟中标量 $Q$ 的渐近离散误差模型完成四个连续的任务：\n$$Q(h) = Q^{\\ast} + \\alpha h^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right)$$\n此处，$Q(h)$ 是特征间距为 $h$ 的网格上的解，$Q^{\\ast}$ 是精确的、网格无关的解（连续介质值），$p$ 是数值格式的精度阶，$\\alpha$ 是一个与 $h$ 无关的常数。问题提供了来自三个系统加密网格的数据，其特征间距为 $h_1 < h_2 < h_3$，恒定加密比为 $r = h_2/h_1 = h_3/h_2$。设相应的解为 $Q_1 = Q(h_1)$、$Q_2 = Q(h_2)$ 和 $Q_3 = Q(h_3)$。\n\n**1) 观测到的精度阶 $p$ 的推导**\n\n假设模拟处于渐近范围内，我们可以忽略高阶项，并为三个解写出误差模型：\n$$Q_1 = Q^{\\ast} + \\alpha h_1^{p}$$\n$$Q_2 = Q^{\\ast} + \\alpha h_2^{p}$$\n$$Q_3 = Q^{\\ast} + \\alpha h_3^{p}$$\n使用恒定的加密比 $r$，我们有 $h_2 = r h_1$ 和 $h_3 = r h_2 = r^2 h_1$。将这些代入方程得到：\n$$Q_1 = Q^{\\ast} + \\alpha h_1^{p}$$\n$$Q_2 = Q^{\\ast} + \\alpha (r h_1)^{p} = Q^{\\ast} + \\alpha h_1^{p} r^{p}$$\n$$Q_3 = Q^{\\ast} + \\alpha (r^2 h_1)^{p} = Q^{\\ast} + \\alpha h_1^{p} r^{2p}$$\n为了找到 $p$ 的表达式，我们通过考虑解之间的差值来消去未知量 $Q^{\\ast}$ 和 $\\alpha$：\n中等网格和细网格上解的差值为：\n$$\\epsilon_{21} = Q_2 - Q_1 = (Q^{\\ast} + \\alpha h_1^{p} r^{p}) - (Q^{\\ast} + \\alpha h_1^{p}) = \\alpha h_1^{p} (r^{p} - 1)$$\n粗网格和中等网格上解的差值为：\n$$\\epsilon_{32} = Q_3 - Q_2 = (Q^{\\ast} + \\alpha h_1^{p} r^{2p}) - (Q^{\\ast} + \\alpha h_1^{p} r^{p}) = \\alpha h_1^{p} r^{p} (r^{p} - 1)$$\n现在，我们取这两个差值的比值：\n$$\\frac{\\epsilon_{32}}{\\epsilon_{21}} = \\frac{Q_3 - Q_2}{Q_2 - Q_1} = \\frac{\\alpha h_1^{p} r^{p} (r^{p} - 1)}{\\alpha h_1^{p} (r^{p} - 1)} = r^{p}$$\n为了解出 $p$，我们对方程两边取自然对数：\n$$\\ln\\left(\\frac{Q_3 - Q_2}{Q_2 - Q_1}\\right) = \\ln(r^{p}) = p \\ln(r)$$\n将 $p$ 分离出来，得到观测到的精度阶的所求表达式：\n$$p = \\frac{\\ln\\left(\\frac{Q_3 - Q_2}{Q_2 - Q_1}\\right)}{\\ln(r)}$$\n\n**2) Richardson 外推值 $Q^{\\ast}$ 的推导**\n\n我们寻求使用两个最细网格的解 $Q_1$ 和 $Q_2$、加密比 $r$ 以及观测到的精度阶 $p$ 来估计连续介质值 $Q^{\\ast}$。\n我们再次从 $Q_1$ 和 $Q_2$ 的两个方程开始：\n$$Q_1 = Q^{\\ast} + \\alpha h_1^{p}$$\n$$Q_2 = Q^{\\ast} + \\alpha h_2^{p} = Q^{\\ast} + \\alpha (r h_1)^{p} = Q^{\\ast} + \\alpha h_1^{p} r^{p}$$\n我们的目标是消去项 $\\alpha h_1^p$。从第一个方程，我们有 $\\alpha h_1^{p} = Q_1 - Q^{\\ast}$。将其代入第二个方程得到：\n$$Q_2 = Q^{\\ast} + (Q_1 - Q^{\\ast}) r^{p}$$\n展开右侧：\n$$Q_2 = Q^{\\ast} + Q_1 r^{p} - Q^{\\ast} r^{p}$$\n现在，我们求解 $Q^{\\ast}$：\n$$Q_2 - Q_1 r^{p} = Q^{\\ast}(1 - r^{p})$$\n$$Q^{\\ast} = \\frac{Q_2 - Q_1 r^{p}}{1 - r^{p}} = \\frac{Q_1 r^{p} - Q_2}{r^{p} - 1}$$\n这个表达式可以通过在分子中加上和减去 $Q_1$ 来整理成一个更常见的形式：\n$$Q^{\\ast} = \\frac{Q_1 r^{p} - Q_1 + Q_1 - Q_2}{r^{p} - 1} = \\frac{Q_1(r^{p} - 1)}{r^{p} - 1} + \\frac{Q_1 - Q_2}{r^{p} - 1}$$\n这可以化简为 Richardson 外推法的标准形式：\n$$Q^{\\ast} = Q_1 + \\frac{Q_1 - Q_2}{r^{p} - 1}$$\n或者，使用记法 $Q(h_1)$ 和 $Q(h_2)$：\n$$Q^{\\ast} = Q(h_1) + \\frac{Q(h_1) - Q(h_2)}{r^{p} - 1}$$\n\n**3) 网格收敛指数 (GCI) 的构建**\n\nGCI 是衡量由离散误差引起的数值不确定度的一种方法。它基于对最细网格解中误差的估计。最细网格解的真实误差是 $\\mathcal{E}_1 = Q_1 - Q^{\\ast}$。使用 Richardson 外推值 $Q^{\\ast}$ 作为连续介质值的最佳估计，我们可以找到该误差的近似值，记为 $\\mathcal{E}_a$：\n$$\\mathcal{E}_a = Q_1 - Q^{\\ast} \\approx Q(h_1) - \\left( Q(h_1) + \\frac{Q(h_1) - Q(h_2)}{r^{p} - 1} \\right) = - \\frac{Q(h_1) - Q(h_2)}{r^{p} - 1} = \\frac{Q(h_2) - Q(h_1)}{r^{p} - 1}$$\n问题要求将 GCI 作为 $Q(h_1)$ 的相对不确定度。这被定义为近似相对误差的绝对值乘以一个安全因子 $F_s$。近似相对误差是 $\\mathcal{E}_a / Q(h_1)$。\n$$GCI_{\\text{fine}} = F_s \\left| \\frac{\\mathcal{E}_a}{Q(h_1)} \\right| = F_s \\left| \\frac{ (Q(h_2) - Q(h_1))/(r^{p} - 1) }{Q(h_1)} \\right|$$\n这可以写成：\n$$GCI_{\\text{fine}} = \\frac{F_s}{|r^{p} - 1|} \\left| \\frac{Q(h_2) - Q(h_1)}{Q(h_1)} \\right|$$\n考虑到对于一个收敛方法，$r>1$ 并且我们期望 $p>0$，所以 $r^p - 1 > 0$，因此分母上的绝对值是不必要的。\n$$GCI_{\\text{fine}} = \\frac{F_s}{r^{p} - 1} \\left| \\frac{Q_1 - Q_2}{Q_1} \\right|$$\n这就是所要求的最细网格 GCI 的公式。安全因子 $F_s=1.25$ 用于具有三个或更多网格且表现出单调收敛的情况，本例即是如此。\n\n**4) 最细网格 GCI 的计算**\n\n我们现在将推导出的公式应用于所提供的数据。\n已知条件如下：\n网格间距：$h_1 = 0.00050$, $h_2 = 0.00100$, $h_3 = 0.00200$。\n阻力系数：$C_D(h_1) = Q_1 = 0.02340$, $C_D(h_2) = Q_2 = 0.02370$, $C_D(h_3) = Q_3 = 0.02490$。\n安全因子：$F_s = 1.25$。\n\n首先，我们计算恒定的加密比 $r$：\n$$r = \\frac{h_2}{h_1} = \\frac{0.00100}{0.00050} = 2$$\n我们用另一对数据进行验证：$r = h_3/h_2 = 0.00200 / 0.00100 = 2$。该比率确实是恒定的，$r=2$。\n\n接下来，我们计算观测到的精度阶 $p$：\n$$p = \\frac{\\ln\\left(\\frac{Q_3 - Q_2}{Q_2 - Q_1}\\right)}{\\ln(r)}$$\n解的差值为：\n$$Q_3 - Q_2 = 0.02490 - 0.02370 = 0.00120$$\n$$Q_2 - Q_1 = 0.02370 - 0.02340 = 0.00030$$\n差值的比值为：\n$$\\frac{Q_3 - Q_2}{Q_2 - Q_1} = \\frac{0.00120}{0.00030} = 4$$\n将这些值代入 $p$ 的表达式中：\n$$p = \\frac{\\ln(4)}{\\ln(2)} = \\frac{\\ln(2^2)}{\\ln(2)} = \\frac{2 \\ln(2)}{\\ln(2)} = 2$$\n观测到的精度阶为 $p=2$。\n\n最后，我们使用第 3 部分推导的公式计算最细网格 GCI：\n$$GCI_{\\text{fine}} = \\frac{F_s}{r^{p} - 1} \\left| \\frac{Q_1 - Q_2}{Q_1} \\right|$$\n我们代入已知值：$F_s = 1.25$, $r=2$, $p=2$, $Q_1=0.02340$, and $Q_2=0.02370$。\n$$r^p - 1 = 2^2 - 1 = 4 - 1 = 3$$\n相对差值项为：\n$$\\left| \\frac{Q_1 - Q_2}{Q_1} \\right| = \\left| \\frac{0.02340 - 0.02370}{0.02340} \\right| = \\left| \\frac{-0.00030}{0.02340} \\right| = \\frac{0.00030}{0.02340}$$\n现在，我们计算 GCI：\n$$GCI_{\\text{fine}} = \\frac{1.25}{3} \\times \\frac{0.00030}{0.02340} = \\frac{1.25}{3} \\times \\frac{1}{78} = \\frac{1.25}{234}$$\n进行最后的除法运算：\n$$GCI_{\\text{fine}} = 0.00534188034...$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $5, 3, 4, 1$。下一位数字是 $8$，所以我们将最后一位数字向上进位。\n$$GCI_{\\text{fine}} \\approx 0.005342$$",
            "answer": "$$\\boxed{0.005342}$$"
        }
    ]
}