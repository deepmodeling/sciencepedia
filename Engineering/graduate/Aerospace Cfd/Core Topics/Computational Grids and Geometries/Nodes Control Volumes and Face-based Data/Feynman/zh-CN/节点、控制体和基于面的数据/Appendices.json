{
    "hands_on_practices": [
        {
            "introduction": "在任何有限体积方法中，通量都是通过控制体的边界面计算的。这要求我们精确地确定每个面元的面积和方向，这通常由一个面积矢量 $\\boldsymbol{A}_f$ 来表示。本练习  将通过一个具体的三维三角面元案例，让您亲手实践计算面积矢量，并验证其方向是否与有限体积法中标准的“拥有者-邻居”约定一致，这是所有通量计算的根本前提。",
            "id": "3980526",
            "problem": "在计算流体动力学（CFD）中使用的有限体积离散化中，一个三维空间中的单个三角形面被两个控制体共享。该面由其有序顶点（所有者侧约定）定义，单位为米：\n- $P_1 = (0.2,\\, 0.1,\\, 0.0)$，\n- $P_2 = (1.1,\\, 0.2,\\, 0.3)$，\n- $P_3 = (0.4,\\, 1.0,\\, 0.1)$。\n\n相邻控制体（左侧/所有者和右侧/邻居）的形心为：\n- $C_L = (0.5,\\, 0.5,\\, -0.1)$，\n- $C_R = (0.6,\\, 0.4,\\, 0.6)$。\n\n假设密度和速度场均匀：\n- $\\rho = 0.8\\,\\mathrm{kg/m^3}$，\n- $\\boldsymbol{u} = (12,\\,-3,\\,25)\\,\\mathrm{m/s}$。\n\n仅使用基本几何事实和有限体积法中通量的定义，完成以下任务：\n1. 计算面面积大小 $A_f$、由给定顶点顺序诱导的单位法向量 $\\boldsymbol{n}_f$ 以及面心 $\\boldsymbol{C}_f$。\n2. 通过评估 $\\left(\\boldsymbol{A}_f \\cdot \\boldsymbol{d}\\right)$ 的符号，验证方向与所有者-邻居约定的一致性，其中 $\\boldsymbol{A}_f = A_f \\boldsymbol{n}_f$ 且 $\\boldsymbol{d} = C_R - C_L$。说明存储的方向是否一致。\n3. 使用所有者侧方向一致的面面积向量，计算通过该面的对流质量通量 $\\Phi_m = \\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{A}_f$。\n\n仅提供质量通量的最终值作为您的答案。以 $\\mathrm{kg/s}$ 表示最终质量通量，并将您的答案四舍五入到四位有效数字。",
            "solution": "该问题陈述是向量代数应用于计算流体动力学中有限体积法基本原理的一个适定练习。它具有科学依据，没有矛盾，并包含唯一解所需的所有数据。因此，该问题是有效的。\n\n任务是计算通过一个三角形面的对流质量通量 $\\Phi_m$。质量通量由公式 $\\Phi_m = \\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{A}_f$ 给出，其中 $\\rho$ 是流体密度，$\\boldsymbol{u}$ 是速度向量，$\\boldsymbol{A}_f$ 是方向一致的面面积向量。\n\n给定的数据是：\n- 顶点：$P_1 = (0.2,\\, 0.1,\\, 0.0)$，$P_2 = (1.1,\\, 0.2,\\, 0.3)$，$P_3 = (0.4,\\, 1.0,\\, 0.1)$。所有坐标单位为米。\n- 控制体形心：$C_L = (0.5,\\, 0.5,\\, -0.1)$（所有者）和 $C_R = (0.6,\\, 0.4,\\, 0.6)$（邻居）。\n- 流体属性：$\\rho = 0.8\\,\\mathrm{kg/m^3}$ 和 $\\boldsymbol{u} = (12,\\,-3,\\,25)\\,\\mathrm{m/s}$。\n\n首先，我们根据提供的顶点顺序计算面面积向量 $\\boldsymbol{A}_f$。该向量的方向垂直于面，由应用于有序顶点的右手定则确定，其大小是三角形的面积。我们定义从顶点 $P_1$ 出发的两个边向量：\n$$ \\boldsymbol{v}_1 = P_2 - P_1 = (1.1 - 0.2,\\, 0.2 - 0.1,\\, 0.3 - 0.0) = (0.9,\\, 0.1,\\, 0.3) $$\n$$ \\boldsymbol{v}_2 = P_3 - P_1 = (0.4 - 0.2,\\, 1.0 - 0.1,\\, 0.1 - 0.0) = (0.2,\\, 0.9,\\, 0.1) $$\n\n面积向量由这两个边向量叉积的一半给出：\n$$ \\boldsymbol{A}_f = \\frac{1}{2} (\\boldsymbol{v}_1 \\times \\boldsymbol{v}_2) = \\frac{1}{2} \\begin{vmatrix} \\boldsymbol{i} & \\boldsymbol{j} & \\boldsymbol{k} \\\\ 0.9 & 0.1 & 0.3 \\\\ 0.2 & 0.9 & 0.1 \\end{vmatrix} $$\n$$ \\boldsymbol{A}_f = \\frac{1}{2} \\left[ (0.1 \\cdot 0.1 - 0.3 \\cdot 0.9)\\boldsymbol{i} - (0.9 \\cdot 0.1 - 0.3 \\cdot 0.2)\\boldsymbol{j} + (0.9 \\cdot 0.9 - 0.1 \\cdot 0.2)\\boldsymbol{k} \\right] $$\n$$ \\boldsymbol{A}_f = \\frac{1}{2} \\left[ (0.01 - 0.27)\\boldsymbol{i} - (0.09 - 0.06)\\boldsymbol{j} + (0.81 - 0.02)\\boldsymbol{k} \\right] $$\n$$ \\boldsymbol{A}_f = \\frac{1}{2} (-0.26\\boldsymbol{i} - 0.03\\boldsymbol{j} + 0.79\\boldsymbol{k}) $$\n$$ \\boldsymbol{A}_f = (-0.13,\\, -0.015,\\, 0.395)\\,\\mathrm{m}^2 $$\n\n接下来，我们必须验证 $\\boldsymbol{A}_f$ 的方向是否与有限体积法中规定的所有者-邻居 ($L \\to R$) 约定一致。这通过检查 $\\boldsymbol{A}_f$ 与连接所有者单元形心 $C_L$ 和邻居单元形心 $C_R$ 的向量 $\\boldsymbol{d}$ 的点积的符号来完成。\n$$ \\boldsymbol{d} = C_R - C_L = (0.6 - 0.5,\\, 0.4 - 0.5,\\, 0.6 - (-0.1)) = (0.1,\\, -0.1,\\, 0.7) $$\n\n我们计算点积：\n$$ \\boldsymbol{A}_f \\cdot \\boldsymbol{d} = (-0.13)(0.1) + (-0.015)(-0.1) + (0.395)(0.7) $$\n$$ \\boldsymbol{A}_f \\cdot \\boldsymbol{d} = -0.013 + 0.0015 + 0.2765 = 0.265 $$\n由于 $\\boldsymbol{A}_f \\cdot \\boldsymbol{d} > 0$，由顶点顺序定义的法向量从所有者单元指向邻居单元。因此，存储的方向是一致的。用于从所有者侧计算通量的方向一致的面面积向量就是 $\\boldsymbol{A}_f$ 本身。\n\n最后，我们使用给定的均匀密度 $\\rho$ 和速度场 $\\boldsymbol{u}$ 计算对流质量通量 $\\Phi_m$：\n$$ \\Phi_m = \\rho (\\boldsymbol{u} \\cdot \\boldsymbol{A}_f) $$\n给定 $\\rho = 0.8\\,\\mathrm{kg/m^3}$ 和 $\\boldsymbol{u} = (12,\\, -3,\\, 25)\\,\\mathrm{m/s}$。首先，我们计算体积通量，即点积 $\\boldsymbol{u} \\cdot \\boldsymbol{A}_f$：\n$$ \\boldsymbol{u} \\cdot \\boldsymbol{A}_f = (12,\\, -3,\\, 25) \\cdot (-0.13,\\, -0.015,\\, 0.395) $$\n$$ \\boldsymbol{u} \\cdot \\boldsymbol{A}_f = 12(-0.13) + (-3)(-0.015) + 25(0.395) $$\n$$ \\boldsymbol{u} \\cdot \\boldsymbol{A}_f = -1.56 + 0.045 + 9.875 = 8.36\\,\\mathrm{m^3/s} $$\n\n现在，我们乘以密度得到质量通量：\n$$ \\Phi_m = 0.8\\,\\mathrm{kg/m^3} \\times 8.36\\,\\mathrm{m^3/s} = 6.688\\,\\mathrm{kg/s} $$\n\n问题要求最终答案四舍五入到四位有效数字。计算出的值 $6.688$ 已经有四位有效数字。",
            "answer": "$$\\boxed{6.688}$$"
        },
        {
            "introduction": "理想的网格是正交的，但在处理复杂外形时，非结构网格的非正交性是普遍存在的。这种几何特性会给扩散通量的标准中心差分近似带来误差。本练习  深入探讨了如何从数学上推导并应用一个非正交修正项，以恢复在非正交网格上的计算精度，这对于在实际工程问题中获得可靠的数值解至关重要。",
            "id": "3980499",
            "problem": "考虑在以单元为中心的有限体积法中用于计算流体动力学（CFD）的基于面的扩散离散化。设两个相邻的控制体，其中心分别位于 $\\boldsymbol{x}_P$ 和 $\\boldsymbol{x}_N$ 处，共享一个面积矢量为 $\\boldsymbol{S}_f$ 的公共平面。标量场 $\\phi(\\boldsymbol{x})$ 通过扩散进行输运，其扩散系数 $\\Gamma$ 为无量纲常数。假设该场在空间中线性变化，因此 $\\nabla \\phi$ 是一个常数。基于面的扩散贡献项由守恒的积分形式和散度定理得到，为在面上求值的 $-\\Gamma\\,\\boldsymbol{S}_f \\cdot \\nabla \\phi$ 在所有面上的总和。常用的正交（中心到中心）近似用沿连接中心的直线的方向导数代替面法向梯度，当 $\\boldsymbol{S}_f$ 不平行于中心到中心的矢量时，会引入误差。\n\n从散度定理、梯度的定义以及沿单位方向的方向导数出发，通过投影到连接中心的方向上，推导由非正交性引起的面误差，该误差为精确的面贡献与正交中心到中心近似之间的差值。然后，提出一个必须加到正交近似上的非正交修正项，以恢复线性场的精确面贡献，该修正项以 $\\boldsymbol{S}_f \\cdot \\nabla \\phi$ 分解为一个正交部分和一个非正交部分的形式表示。\n\n最后，根据以下无量纲数据，数值计算非正交修正项对通过面的扩散通量的贡献：\n- $\\boldsymbol{x}_P = (0,\\,0,\\,0)$,\n- $\\boldsymbol{x}_N = (1,\\,0.2,\\,0)$,\n- $\\boldsymbol{S}_f = (0.24,\\,0.18,\\,0)$,\n- $\\nabla \\phi = (2.5,\\,-0.7,\\,1.2)$,\n- $\\Gamma = 2$.\n\n所有量均为无量纲。将您的最终答案（非正交修正项对面向扩散通量的贡献值）四舍五入到四位有效数字。将最终答案表示为一个没有任何单位的纯数字。",
            "solution": "该问题要求推导有限体积法中基于面的扩散通量计算的非正交修正项，并根据给定的一组数据对其进行数值评估。该分析假设标量场 $\\phi(\\boldsymbol{x})$ 是线性的，这意味着其梯度 $\\nabla\\phi$ 是一个常矢量。\n\n我们从控制体 $V$ 上标量 $\\phi$ 的守恒方程的积分形式开始，在没有源项和对流的情况下：\n$$ \\frac{\\partial}{\\partial t} \\int_V \\phi \\,dV + \\int_V \\nabla \\cdot \\boldsymbol{J} \\,dV = 0 $$\n其中 $\\boldsymbol{J}$ 是扩散通量矢量，由菲克定律定义为 $\\boldsymbol{J} = -\\Gamma\\nabla\\phi$，$\\Gamma$ 是常数扩散系数。\n\n对第二项应用散度定理，将体积分转化为包围控制体的各个面 $f$ 上的积分之和：\n$$ \\int_V \\nabla \\cdot \\boldsymbol{J} \\,dV = \\sum_f \\int_f \\boldsymbol{J} \\cdot d\\boldsymbol{S} $$\n对于一个面积矢量为 $\\boldsymbol{S}_f$ 的平面，并假设通量矢量 $\\boldsymbol{J}$ 在整个面上是均匀的（这是成立的，因为 $\\nabla\\phi$ 是常数），积分简化为一个点积：\n$$ \\int_f \\boldsymbol{J} \\cdot d\\boldsymbol{S} = \\boldsymbol{J} \\cdot \\boldsymbol{S}_f = (-\\Gamma\\nabla\\phi) \\cdot \\boldsymbol{S}_f = -\\Gamma(\\boldsymbol{S}_f \\cdot \\nabla\\phi) $$\n这一项 $F_f = -\\Gamma(\\boldsymbol{S}_f \\cdot \\nabla\\phi)$ 代表了通过面 $f$ 的精确扩散通量。离散化问题的核心在于近似 $\\boldsymbol{S}_f \\cdot \\nabla\\phi$ 这一项。\n\n在以单元为中心的有限体积法中，主要变量存储在控制体的中心，这里用 $\\boldsymbol{x}_P$ 和 $\\boldsymbol{x}_N$ 表示两个相邻单元的中心。连接中心的几何矢量是 $\\boldsymbol{d} = \\boldsymbol{x}_N - \\boldsymbol{x}_P$。\n\n通量的正交近似是基于沿中心到中心矢量 $\\boldsymbol{d}$ 的梯度分量。对于线性场，差值 $\\phi_N - \\phi_P$ 与梯度有精确关系 $\\phi_N - \\phi_P = \\nabla\\phi \\cdot (\\boldsymbol{x}_N - \\boldsymbol{x}_P) = \\nabla\\phi \\cdot \\boldsymbol{d}$。通量的最简单近似仅使用这个单元间差值来构造，这隐含地依赖于沿 $\\boldsymbol{d}$ 的梯度分量。\n\n当面面积矢量 $\\boldsymbol{S}_f$ 不平行于中心矢量 $\\boldsymbol{d}$ 时，就会出现网格非正交性。为了系统地处理这个问题，将矢量 $\\boldsymbol{S}_f$ 分解为两个分量：一个平行于 $\\boldsymbol{d}$，一个垂直于 $\\boldsymbol{d}$。设 $\\boldsymbol{e}_d = \\boldsymbol{d}/|\\boldsymbol{d}|$ 为沿中心连接线的单位矢量。\n平行分量，我们称之为面积矢量的“正交”部分，是 $\\boldsymbol{S}_f$ 在 $\\boldsymbol{d}$ 上的投影：\n$$ \\boldsymbol{S}_{f, \\parallel} = (\\boldsymbol{S}_f \\cdot \\boldsymbol{e}_d) \\boldsymbol{e}_d = \\frac{(\\boldsymbol{S}_f \\cdot \\boldsymbol{d})}{|\\boldsymbol{d}|^2}\\boldsymbol{d} $$\n垂直分量，我们称之为“非正交”部分，是剩余的部分：\n$$ \\boldsymbol{S}_{f, \\perp} = \\boldsymbol{S}_f - \\boldsymbol{S}_{f, \\parallel} $$\n根据构造，$\\boldsymbol{S}_{f, \\perp} \\cdot \\boldsymbol{d} = 0$。\n\n使用这个分解，精确项 $\\boldsymbol{S}_f \\cdot \\nabla\\phi$ 可以分为两部分：\n$$ \\boldsymbol{S}_f \\cdot \\nabla\\phi = (\\boldsymbol{S}_{f, \\parallel} + \\boldsymbol{S}_{f, \\perp}) \\cdot \\nabla\\phi = \\underbrace{\\boldsymbol{S}_{f, \\parallel} \\cdot \\nabla\\phi}_{\\text{正交部分}} + \\underbrace{\\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi}_{\\text{非正交部分}} $$\n面通量项的正交近似只考虑第一部分，因为它可以直接与单元中心值 $\\phi_P$ 和 $\\phi_N$ 相关联：\n$$ (\\boldsymbol{S}_f \\cdot \\nabla\\phi)_{\\text{orth approx}} = \\boldsymbol{S}_{f, \\parallel} \\cdot \\nabla\\phi = \\frac{(\\boldsymbol{S}_f \\cdot \\boldsymbol{d})}{|\\boldsymbol{d}|^2}(\\boldsymbol{d} \\cdot \\nabla\\phi) = \\frac{(\\boldsymbol{S}_f \\cdot \\boldsymbol{d})}{|\\boldsymbol{d}|^2}(\\phi_N - \\phi_P) $$\n由非正交性引起的面误差是精确项与此正交近似之间的差值：\n$$ \\text{误差} = (\\boldsymbol{S}_f \\cdot \\nabla\\phi) - (\\boldsymbol{S}_f \\cdot \\nabla\\phi)_{\\text{orth approx}} = \\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi $$\n因此，为了恢复线性场的精确面贡献，必须在正交近似上加上一个等于此误差的非正交修正项。因此，所提出的非正交修正项为 $C_{\\text{non-orth}} = \\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi$。\n\n通过面的总扩散通量则由下式给出：\n$$ F_f = -\\Gamma [(\\boldsymbol{S}_f \\cdot \\nabla\\phi)_{\\text{orth approx}} + C_{\\text{non-orth}}] $$\n非正交修正项对扩散通量的贡献是 $-\\Gamma C_{\\text{non-orth}} = -\\Gamma(\\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi)$。我们被要求数值计算这个量。\n\n给定的无量纲数据是：\n- $\\boldsymbol{x}_P = (0,\\,0,\\,0)$\n- $\\boldsymbol{x}_N = (1,\\,0.2,\\,0)$\n- $\\boldsymbol{S}_f = (0.24,\\,0.18,\\,0)$\n- $\\nabla \\phi = (2.5,\\,-0.7,\\,1.2)$\n- $\\Gamma = 2$\n\n首先，我们计算所需的几何矢量。\n中心到中心的矢量是：\n$$ \\boldsymbol{d} = \\boldsymbol{x}_N - \\boldsymbol{x}_P = (1,\\,0.2,\\,0) - (0,\\,0,\\,0) = (1,\\,0.2,\\,0) $$\n$\\boldsymbol{d}$ 的模长的平方是：\n$$ |\\boldsymbol{d}|^2 = 1^2 + 0.2^2 + 0^2 = 1 + 0.04 = 1.04 $$\n接下来，我们计算面面积矢量和中心矢量的点积：\n$$ \\boldsymbol{S}_f \\cdot \\boldsymbol{d} = (0.24)(1) + (0.18)(0.2) + (0)(0) = 0.24 + 0.036 = 0.276 $$\n现在，我们求面积矢量的非正交分量 $\\boldsymbol{S}_{f, \\perp}$：\n$$ \\boldsymbol{S}_{f, \\perp} = \\boldsymbol{S}_f - \\frac{\\boldsymbol{S}_f \\cdot \\boldsymbol{d}}{|\\boldsymbol{d}|^2}\\boldsymbol{d} $$\n$$ \\boldsymbol{S}_{f, \\perp} = (0.24,\\,0.18,\\,0) - \\frac{0.276}{1.04}(1,\\,0.2,\\,0) $$\n标量分数为 $\\frac{0.276}{1.04} \\approx 0.2653846$。\n$$ \\boldsymbol{S}_{f, \\perp} = (0.24 - 0.2653846, 0.18 - 0.2653846 \\times 0.2, 0) $$\n$$ \\boldsymbol{S}_{f, \\perp} = (-0.0253846, 0.18 - 0.0530769, 0) = (-0.0253846, 0.1269231, 0) $$\n非正交修正项 $C_{\\text{non-orth}}$ 是该矢量与梯度 $\\nabla\\phi$ 的点积：\n$$ C_{\\text{non-orth}} = \\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi = (-0.0253846)(2.5) + (0.1269231)(-0.7) + (0)(1.2) $$\n$$ C_{\\text{non-orth}} = -0.0634615 - 0.08884617 = -0.15230767 \\approx -\\frac{99}{650} $$\n最后，非正交修正项对通过面的扩散通量的贡献是：\n$$ \\text{通量修正} = -\\Gamma C_{\\text{non-orth}} = -2 \\times (-0.15230767) = 0.30461534 \\approx \\frac{99}{325} $$\n四舍五入到四位有效数字，结果是 $0.3046$。",
            "answer": "$$\\boxed{0.3046}$$"
        },
        {
            "introduction": "在有限体积法中，无论是在单元中心还是节点上，我们常常需要梯度信息来构建高阶格式或计算物理量（如粘性应力）。由于变量是离散存储的，梯度必须从周围数据点重构。本练习  将指导您实现广泛应用的最小二乘法来重构梯度，并探索如何通过距离反比加权来提高算法在不规则或拉伸网格上的稳健性和精度。",
            "id": "3980510",
            "problem": "在二维计算流体动力学（CFD）中，特别是在有限体积法（FVM）中，通常需要根据周围控制体中心和基于面的数据来重构节点处的梯度。考虑一个标量场 $\\phi(x,y)$，它在位于位置 $\\boldsymbol{x}_0 = (x_0,y_0)$ 的节点邻域内光滑定义。目标是根据围绕 $\\boldsymbol{x}_0$ 的 $N$ 个位于位置 $\\boldsymbol{x}_i = (x_i,y_i)$ 的相邻样本 $\\{\\phi_i\\}$ 来计算梯度向量 $\\nabla \\phi(\\boldsymbol{x}_0)$，其中一些位置可能对应于相邻的网格单元中心，另一些则对应于面心。\n\n从 $\\phi$ 关于 $\\boldsymbol{x}_0$ 的泰勒展开式出发，并记 $\\boldsymbol{r}_i = \\boldsymbol{x}_i - \\boldsymbol{x}_0$，将节点处的最小二乘梯度定义为二次失配的最小化子 $\\boldsymbol{g}$：\n$$\nJ(\\boldsymbol{g}) = \\sum_{i=1}^{N} w_i \\left(\\phi_i - \\phi_0 - \\boldsymbol{g} \\cdot \\boldsymbol{r}_i \\right)^2,\n$$\n其中 $\\phi_0 = \\phi(\\boldsymbol{x}_0)$ 且 $w_i$ 为非负权重。必须实现两种情况：\n- 无权最小二乘：对所有 $i$，$w_i = 1$。\n- 反距离加权最小二乘：对所有 $i$，$w_i = \\frac{1}{\\lVert \\boldsymbol{r}_i \\rVert}$，其中 $\\lVert \\cdot \\rVert$ 表示欧几里得范数。\n\n使用以下标量场，它代表一个由线性项和弱曲率组成的通用光滑场，以确保测试的非平凡性：\n$$\n\\phi(x,y) = 3 x - 2 y + \\tfrac{1}{2} x^2 + \\tfrac{1}{4} x y.\n$$\n在任意点 $(x,y)$ 的精确梯度为：\n$$\n\\nabla \\phi(x,y) = \\left( 3 + x + \\tfrac{1}{4} y,\\; -2 + \\tfrac{1}{4} x \\right).\n$$\n\n您的程序必须对下面的每个测试用例，计算指定节点处的无权和反距离加权最小二乘梯度近似值，并报告各自相对于精确梯度的相对欧几里得误差，定义为：\n$$\n\\varepsilon = \\frac{\\lVert \\boldsymbol{g}_{\\text{approx}} - \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}{\\lVert \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}.\n$$\n\n如果测试中存在噪声，则将其添加到相邻标量值 $\\phi_i$ 上，但不添加到 $\\phi_0$ 上。不使用角度。不需要物理单位。所有输出均为无量纲。\n\n在一个单一程序中实现该算法，以评估以下相邻点位置的测试套件。在每种情况下，都指定了节点位置 $\\boldsymbol{x}_0$ 和相邻点集 $\\{\\boldsymbol{x}_i\\}_{i=1}^N$：\n\n- 测试用例 1（$\\boldsymbol{x}_0$ 周围的各向同性相邻点，代表一个包含网格单元中心和面中点的形状良好的网格）：\n  - 节点：$\\boldsymbol{x}_0 = (0, 0)$。\n  - 相邻点：\n    - $(1, 0)$, $(-1, 0)$, $(0, 1)$, $(0, -1)$,\n    - $(0.7, 0.7)$, $(-0.7, 0.7)$, $(0.7, -0.7)$, $(-0.7, -0.7)$。\n  - 噪声：无。\n\n- 测试用例 2（$\\boldsymbol{x}_0$ 附近的高度各向异性点簇，带有一个远距离离群点，模拟带有偏远面中心的倾斜控制体邻接关系）：\n  - 节点：$\\boldsymbol{x}_0 = (0, 0)$。\n  - 相邻点：\n    - $(0.05, -0.01)$, $(0.10, 0.00)$, $(0.15, 0.01)$, $(0.20, -0.02)$, $(5.0, 3.0)$。\n  - 噪声：无。\n\n- 测试用例 3（不规则相邻点，在 $\\phi_i$ 上带有少量测量噪声）：\n  - 节点：$\\boldsymbol{x}_0 = (0, 0)$。\n  - 相邻点：\n    - $(0.2, 0.3)$, $(-0.25, 0.1)$, $(0.4, -0.35)$, $(-0.6, -0.2)$, $(1.2, 0.8)$, $(-1.0, 0.9)$。\n  - 相邻点值 $\\phi_i$ 上的附加噪声（与相邻点顺序相同）：$[5 \\times 10^{-4},\\; -4 \\times 10^{-4},\\; 3 \\times 10^{-4},\\; -2 \\times 10^{-4},\\; 1 \\times 10^{-4},\\; -1 \\times 10^{-4}]$。\n  - $\\phi_0$ 上无噪声。\n\n- 测试用例 4（$\\boldsymbol{x}_0$ 周围偏离原点的倾斜相邻点，结合了近似共线的网格单元中心和少数离轴的面点）：\n  - 节点：$\\boldsymbol{x}_0 = (1.0, -0.5)$。\n  - 相邻点：\n    - $(1.05, -0.49)$, $(1.10, -0.51)$, $(1.15, -0.48)$, $(1.20, -0.52)$, $(1.02, -0.30)$, $(0.90, -0.70)$。\n  - 噪声：无。\n\n对每个测试用例，计算：\n- 无权相对误差 $\\varepsilon_{\\text{unw}}$。\n- 反距离加权相对误差 $\\varepsilon_{\\text{w}}$，其中 $w_i = 1 / \\lVert \\boldsymbol{r}_i \\rVert$。\n- 一个布尔标志，指示反距离加权是否改善了结果，即 $\\varepsilon_{\\text{w}}  \\varepsilon_{\\text{unw}}$ 是否成立。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 每个测试用例贡献一个形式为 $[\\varepsilon_{\\text{unw}}, \\varepsilon_{\\text{w}}, \\text{better}]$ 的三元列表，其中 $\\text{better}$ 是一个布尔值，指示加权误差是否严格小于无权误差。\n- 每个测试的两个误差值必须四舍五入到8位小数。\n- 示例格式：$[[0.00123456,0.00098765,\\text{True}],\\ldots]$。\n\n该程序必须是自包含的，并且不需要任何输入。它必须根据给定的 $\\phi(x,y)$ 计算所有相邻点的值 $\\phi_i$，并在指定位置施加噪声。计算应完全采用浮点运算，无需单位转换。目标是通过这些测试用例，展示反距离加权如何通过减少远距离或分布不佳的相邻点在节点最小二乘梯度重构中的影响，从而为不规则网格赋予鲁棒性。",
            "solution": "我们从光滑标量场 $\\phi$ 在点 $\\boldsymbol{x}_0 = (x_0,y_0)$ 附近的泰勒展开式开始，并在相邻位置 $\\boldsymbol{x}_i = (x_i,y_i)$ 进行求值：\n$$\n\\phi(\\boldsymbol{x}_i) = \\phi(\\boldsymbol{x}_0) + \\nabla \\phi(\\boldsymbol{x}_0) \\cdot \\boldsymbol{r}_i + \\mathcal{O}(\\lVert \\boldsymbol{r}_i \\rVert^2),\n$$\n其中 $\\boldsymbol{r}_i = \\boldsymbol{x}_i - \\boldsymbol{x}_0$。如果我们让 $\\boldsymbol{g}$ 表示 $\\nabla \\phi(\\boldsymbol{x}_0)$ 的一个近似值，并定义残差\n$$\n\\delta_i(\\boldsymbol{g}) = \\phi_i - \\phi_0 - \\boldsymbol{g} \\cdot \\boldsymbol{r}_i,\n$$\n那么最小二乘估计就是寻找一个 $\\boldsymbol{g}$ 来最小化 $\\delta_i$ 的平方和。为了引入几何信息，我们引入非负权重 $w_i$ 并最小化\n$$\nJ(\\boldsymbol{g}) = \\sum_{i=1}^{N} w_i \\, \\delta_i(\\boldsymbol{g})^2.\n$$\n令 $A \\in \\mathbb{R}^{N \\times 2}$ 为设计矩阵，其第 $i$ 行为 $A_i = \\boldsymbol{r}_i^\\top$；令 $b \\in \\mathbb{R}^{N}$ 为向量，其元素为 $b_i = \\phi_i - \\phi_0$。令 $W = \\mathrm{diag}(w_1,\\ldots,w_N)$。则\n$$\nJ(\\boldsymbol{g}) = \\lVert W^{1/2}(A \\boldsymbol{g} - b) \\rVert_2^2.\n$$\n一阶最优性条件给出了加权正规方程组：\n$$\n(A^\\top W A)\\, \\boldsymbol{g} = A^\\top W b.\n$$\n当 $A^\\top W A$ 非奇异时，解为：\n$$\n\\boldsymbol{g} = (A^\\top W A)^{-1} A^\\top W b.\n$$\n在数值计算上，避免显式地构造逆矩阵是有利的。可以转而通过构造 $\\tilde{A} = W^{1/2} A$ 和 $\\tilde{b} = W^{1/2} b$ 来求解最小二乘问题，然后使用一个稳健的最小二乘求解器（例如，基于 QR 分解的方法）。在实践中，对于给定的小规模问题，函数 $\\texttt{numpy.linalg.lstsq}$ 可以为 $\\min_{\\boldsymbol{g}} \\lVert \\tilde{A} \\boldsymbol{g} - \\tilde{b} \\rVert_2$ 计算出一个稳定的解。\n\n权重的选择：\n- 无权：$w_i = 1$ 对所有相邻点给予同等重视。\n- 反距离：$w_i = 1 / \\lVert \\boldsymbol{r}_i \\rVert$ 会降低远距离相邻点的影响。这提高了在不规则网格上的鲁棒性，因为来自被忽略的泰勒高阶项的截断误差会随着 $\\lVert \\boldsymbol{r}_i \\rVert^2$ 增长，并且几何各向异性或离群点可能会使拟合产生偏差，除非对远距离样本进行降权。\n\n我们使用标量场进行测试\n$$\n\\phi(x,y) = 3 x - 2 y + \\tfrac{1}{2} x^2 + \\tfrac{1}{4} x y,\n$$\n其梯度为\n$$\n\\nabla \\phi(x,y) = \\left( 3 + x + \\tfrac{1}{4} y,\\; -2 + \\tfrac{1}{4} x \\right).\n$$\n在每个节点 $\\boldsymbol{x}_0$ 处，我们计算 $\\phi_0 = \\phi(\\boldsymbol{x}_0)$，然后组装相邻点的值 $\\phi_i = \\phi(\\boldsymbol{x}_i)$，并可选地添加指定的噪声。然后我们构造 $A$ 和 $b$，在无权和加权两种情况下求解 $\\boldsymbol{g}$，并计算相对欧几里得误差\n$$\n\\varepsilon_{\\text{unw}} = \\frac{\\lVert \\boldsymbol{g}_{\\text{unw}} - \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}{\\lVert \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}, \\quad\n\\varepsilon_{\\text{w}} = \\frac{\\lVert \\boldsymbol{g}_{\\text{w}} - \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}{\\lVert \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}.\n$$\n\n每个测试用例的算法步骤：\n- 步骤 1：计算 $\\phi_0 = \\phi(\\boldsymbol{x}_0)$ 和 $\\phi_i = \\phi(\\boldsymbol{x}_i)$；如果指定，向 $\\phi_i$ 添加噪声，保持 $\\phi_0$ 无噪声。\n- 步骤 2：构造矩阵 $A$，其行为 $\\boldsymbol{r}_i^\\top = (\\Delta x_i,\\Delta y_i)$，其中 $\\Delta x_i = x_i - x_0$ 且 $\\Delta y_i = y_i - y_0$；构造向量 $b$，其元素为 $\\phi_i - \\phi_0$。\n- 步骤 3：对于无权最小二乘，设置 $w_i = 1$，$\\tilde{A} = A$，$\\tilde{b} = b$；通过求解 $\\min \\lVert \\tilde{A} \\boldsymbol{g} - \\tilde{b} \\rVert_2$ 来计算 $\\boldsymbol{g}_{\\text{unw}}$。\n- 步骤 4：对于反距离权重，设置 $w_i = 1/\\lVert \\boldsymbol{r}_i \\rVert$，定义 $\\tilde{A}_i = \\sqrt{w_i} A_i$ 和 $\\tilde{b}_i = \\sqrt{w_i} b_i$，然后类似地计算 $\\boldsymbol{g}_{\\text{w}}$。\n- 步骤 5：计算精确梯度 $\\nabla \\phi(\\boldsymbol{x}_0)$ 并计算 $\\varepsilon_{\\text{unw}}$ 和 $\\varepsilon_{\\text{w}}$。\n- 步骤 6：确定布尔值 $\\text{better}$，以指示 $\\varepsilon_{\\text{w}}  \\varepsilon_{\\text{unw}}$ 是否成立。\n- 步骤 7：将 $\\varepsilon_{\\text{unw}}$ 和 $\\varepsilon_{\\text{w}}$ 四舍五入到 8 位小数，并收集三元组 $[\\varepsilon_{\\text{unw}}, \\varepsilon_{\\text{w}}, \\text{better}]$。\n\n测试用例的解释：\n- 测试 1 具有近乎各向同性的覆盖，因此两种方法都应该表现良好；在这种良态情况下，反距离加权可能带来的优势很小。\n- 测试 2 包含一个远距离离群点；无权最小二乘可能会因该离群点而产生偏差，因为 $\\phi$ 中的高阶项随距离增长，而反距离加权则抑制了离群点的影响，从而提高了鲁棒性。\n- 测试 3 引入了少量测量噪声；反距离加权相对于近处相邻点，减小了带噪声的远距离样本的影响，从而有可能改善估计值。\n- 测试 4 呈现了一个位于非原点节点的倾斜相邻点集；如果没有足够的角度分布，几何结构可能近乎退化，而对更远或信息量更少的方向进行降权有助于稳定重构过程。\n\n该程序直接实现了这些步骤，对加权系统使用 $\\texttt{numpy.linalg.lstsq}$ 以确保数值稳定性。最终打印的行是每个测试的三元组 $[\\varepsilon_{\\text{unw}}, \\varepsilon_{\\text{w}}, \\text{better}]$ 的列表，其中误差已四舍五入到 8 位小数，这展示了反距离加权在不规则网格上的效果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi(x, y):\n    # phi(x,y) = 3x - 2y + 0.5 x^2 + 0.25 x y\n    return 3.0 * x - 2.0 * y + 0.5 * x * x + 0.25 * x * y\n\ndef grad_phi_exact(x, y):\n    # grad phi = [3 + x + 0.25 y, -2 + 0.25 x]\n    return np.array([3.0 + x + 0.25 * y, -2.0 + 0.25 * x], dtype=float)\n\ndef ls_gradient(x0, neighbors, phi_values, weighted):\n    \"\"\"\n    Compute least-squares gradient at node x0 from neighbor coordinates and phi values.\n    Parameters:\n        x0: (2,) ndarray\n        neighbors: (N,2) ndarray of neighbor coords\n        phi_values: (N,) ndarray of phi at neighbors (possibly noisy)\n        weighted: bool, if True use inverse-distance weights\n    Returns:\n        g: (2,) ndarray gradient\n    \"\"\"\n    x0 = np.asarray(x0, dtype=float)\n    X = np.asarray(neighbors, dtype=float)\n    r = X - x0[None, :]\n    N = r.shape[0]\n    A = r  # N x 2\n    phi0 = phi(x0[0], x0[1])\n    b = phi_values - phi0  # N\n    if weighted:\n        # Inverse-distance weights\n        d = np.linalg.norm(r, axis=1)\n        # All distances are nonzero per problem setup.\n        w = 1.0 / d\n        sqrtw = np.sqrt(w)\n        Aw = A * sqrtw[:, None]\n        bw = b * sqrtw\n        g, _, _, _ = np.linalg.lstsq(Aw, bw, rcond=None)\n    else:\n        g, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    return g\n\ndef relative_error(g, g_exact):\n    norm_g_exact = np.linalg.norm(g_exact)\n    if norm_g_exact == 0:\n        return np.linalg.norm(g)\n    return np.linalg.norm(g - g_exact) / norm_g_exact\n\ndef solve():\n    # Define test cases according to the problem statement.\n    test_cases = []\n\n    # Test case 1\n    x0_1 = np.array([0.0, 0.0], dtype=float)\n    neighbors_1 = np.array([\n        [1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0],\n        [0.7, 0.7], [-0.7, 0.7], [0.7, -0.7], [-0.7, -0.7]\n    ], dtype=float)\n    noise_1 = None\n    test_cases.append((x0_1, neighbors_1, noise_1))\n\n    # Test case 2\n    x0_2 = np.array([0.0, 0.0], dtype=float)\n    neighbors_2 = np.array([\n        [0.05, -0.01], [0.10, 0.00], [0.15, 0.01], [0.20, -0.02], [5.0, 3.0]\n    ], dtype=float)\n    noise_2 = None\n    test_cases.append((x0_2, neighbors_2, noise_2))\n\n    # Test case 3\n    x0_3 = np.array([0.0, 0.0], dtype=float)\n    neighbors_3 = np.array([\n        [0.2, 0.3], [-0.25, 0.1], [0.4, -0.35], [-0.6, -0.2], [1.2, 0.8], [-1.0, 0.9]\n    ], dtype=float)\n    noise_3 = np.array([5e-4, -4e-4, 3e-4, -2e-4, 1e-4, -1e-4], dtype=float)\n    test_cases.append((x0_3, neighbors_3, noise_3))\n\n    # Test case 4\n    x0_4 = np.array([1.0, -0.5], dtype=float)\n    neighbors_4 = np.array([\n        [1.05, -0.49], [1.10, -0.51], [1.15, -0.48], [1.20, -0.52],\n        [1.02, -0.30], [0.90, -0.70]\n    ], dtype=float)\n    noise_4 = None\n    test_cases.append((x0_4, neighbors_4, noise_4))\n\n    results = []\n    for x0, Xnbr, noise in test_cases:\n        # Compute phi at neighbors and apply noise if given\n        phi_vals = np.array([phi(x, y) for x, y in Xnbr], dtype=float)\n        if noise is not None:\n            phi_vals = phi_vals + noise\n        # Exact gradient at node\n        g_exact = grad_phi_exact(x0[0], x0[1])\n        # Unweighted gradient\n        g_unw = ls_gradient(x0, Xnbr, phi_vals, weighted=False)\n        # Weighted gradient\n        g_w = ls_gradient(x0, Xnbr, phi_vals, weighted=True)\n        # Relative errors\n        e_unw = relative_error(g_unw, g_exact)\n        e_w = relative_error(g_w, g_exact)\n        # Round to 8 decimals\n        e_unw_r = round(e_unw, 8)\n        e_w_r = round(e_w, 8)\n        better = e_w  e_unw\n        results.append([e_unw_r, e_w_r, bool(better)])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}