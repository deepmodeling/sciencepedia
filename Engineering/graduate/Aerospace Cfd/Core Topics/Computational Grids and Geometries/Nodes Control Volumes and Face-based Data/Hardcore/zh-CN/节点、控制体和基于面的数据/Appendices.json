{
    "hands_on_practices": [
        {
            "introduction": "有限体积法的核心思想是将控制体积边界上的通量进行求和，从而将守恒律的积分形式离散化。这个过程的基础是对网格中的每一个面进行精确的几何和物理量计算。\n\n本练习旨在巩固任何有限体积法实现都必需的基础技能：计算一个面的几何属性（如面积矢量）并用其求出物理通量（如质量通量）。通过这个实践()，你将熟练运用矢量代数，并理解CFD中为保证通量计算方向一致性而采用的几何约定。",
            "id": "3980526",
            "problem": "在计算流体动力学（CFD）中使用的有限体积离散化方法中，一个三维空间中的三角形面被两个控制体所共享。该面由其有序顶点（所有者侧约定）定义，单位为米：\n- $P_1 = (0.2,\\, 0.1,\\, 0.0)$,\n- $P_2 = (1.1,\\, 0.2,\\, 0.3)$,\n- $P_3 = (0.4,\\, 1.0,\\, 0.1)$.\n\n相邻控制体（左/所有者和右/邻居）的质心为：\n- $C_L = (0.5,\\, 0.5,\\, -0.1)$,\n- $C_R = (0.6,\\, 0.4,\\, 0.6)$.\n\n假设密度和速度场是均匀的：\n- $\\rho = 0.8\\,\\mathrm{kg/m^3}$,\n- $\\boldsymbol{u} = (12,\\,-3,\\,25)\\,\\mathrm{m/s}$.\n\n仅使用基本几何事实和有限体积法中通量的定义，完成以下任务：\n1. 计算面面积大小 $A_f$，由给定顶点顺序诱导的单位法向量 $\\boldsymbol{n}_f$，以及面质心 $\\boldsymbol{C}_f$。\n2. 通过评估 $\\left(\\boldsymbol{A}_f \\cdot \\boldsymbol{d}\\right)$ 的符号来验证方向是否与所有者到邻居的约定一致，其中 $\\boldsymbol{A}_f = A_f \\boldsymbol{n}_f$ 且 $\\boldsymbol{d} = C_R - C_L$。说明存储的方向是否一致。\n3. 使用所有者侧方向一致的面面积向量，计算通过该面的对流质量通量 $\\Phi_m = \\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{A}_f$。\n\n仅提供质量通量的最终值作为答案。以 $\\mathrm{kg/s}$ 为单位表示最终质量通量，并将答案四舍五入到四位有效数字。",
            "solution": "该问题陈述是一个将向量代数应用于计算流体动力学中有限体积法基本原理的适定练习。它具有科学依据，没有矛盾，并包含获得唯一解所需的所有数据。因此，该问题是有效的。\n\n任务是计算通过一个三角形面的对流质量通量 $\\Phi_m$。质量通量由公式 $\\Phi_m = \\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{A}_f$ 给出，其中 $\\rho$ 是流体密度，$\\boldsymbol{u}$ 是速度向量，$\\boldsymbol{A}_f$ 是方向一致的面面积向量。\n\n给定数据如下：\n- 顶点：$P_1 = (0.2,\\, 0.1,\\, 0.0)$，$P_2 = (1.1,\\, 0.2,\\, 0.3)$，$P_3 = (0.4,\\, 1.0,\\, 0.1)$。所有坐标单位均为米。\n- 控制体质心：$C_L = (0.5,\\, 0.5,\\, -0.1)$（所有者）和 $C_R = (0.6,\\, 0.4,\\, 0.6)$（邻居）。\n- 流体属性：$\\rho = 0.8\\,\\mathrm{kg/m^3}$ 和 $\\boldsymbol{u} = (12,\\,-3,\\,25)\\,\\mathrm{m/s}$。\n\n首先，我们根据提供的顶点顺序计算面面积向量 $\\boldsymbol{A}_f$。该向量的方向垂直于面，由应用于有序顶点的右手定则确定，其大小是三角形的面积。我们定义两个从顶点 $P_1$ 出发的边向量：\n$$ \\boldsymbol{v}_1 = P_2 - P_1 = (1.1 - 0.2,\\, 0.2 - 0.1,\\, 0.3 - 0.0) = (0.9,\\, 0.1,\\, 0.3) $$\n$$ \\boldsymbol{v}_2 = P_3 - P_1 = (0.4 - 0.2,\\, 1.0 - 0.1,\\, 0.1 - 0.0) = (0.2,\\, 0.9,\\, 0.1) $$\n\n面积向量由这两个边向量叉积的一半给出：\n$$ \\boldsymbol{A}_f = \\frac{1}{2} (\\boldsymbol{v}_1 \\times \\boldsymbol{v}_2) = \\frac{1}{2} \\begin{vmatrix} \\boldsymbol{i} & \\boldsymbol{j} & \\boldsymbol{k} \\\\ 0.9 & 0.1 & 0.3 \\\\ 0.2 & 0.9 & 0.1 \\end{vmatrix} $$\n$$ \\boldsymbol{A}_f = \\frac{1}{2} \\left[ (0.1 \\cdot 0.1 - 0.3 \\cdot 0.9)\\boldsymbol{i} - (0.9 \\cdot 0.1 - 0.3 \\cdot 0.2)\\boldsymbol{j} + (0.9 \\cdot 0.9 - 0.1 \\cdot 0.2)\\boldsymbol{k} \\right] $$\n$$ \\boldsymbol{A}_f = \\frac{1}{2} \\left[ (0.01 - 0.27)\\boldsymbol{i} - (0.09 - 0.06)\\boldsymbol{j} + (0.81 - 0.02)\\boldsymbol{k} \\right] $$\n$$ \\boldsymbol{A}_f = \\frac{1}{2} (-0.26\\boldsymbol{i} - 0.03\\boldsymbol{j} + 0.79\\boldsymbol{k}) $$\n$$ \\boldsymbol{A}_f = (-0.13,\\, -0.015,\\, 0.395)\\,\\mathrm{m}^2 $$\n\n接下来，我们必须验证 $\\boldsymbol{A}_f$ 的方向是否与有限体积法中规定的所有者到邻居（$L \\to R$）的约定一致。这通过检查 $\\boldsymbol{A}_f$ 与连接所有者单元质心 $C_L$ 和邻居单元质心 $C_R$ 的向量 $\\boldsymbol{d}$ 的点积的符号来完成。\n$$ \\boldsymbol{d} = C_R - C_L = (0.6 - 0.5,\\, 0.4 - 0.5,\\, 0.6 - (-0.1)) = (0.1,\\, -0.1,\\, 0.7) $$\n\n我们计算点积：\n$$ \\boldsymbol{A}_f \\cdot \\boldsymbol{d} = (-0.13)(0.1) + (-0.015)(-0.1) + (0.395)(0.7) $$\n$$ \\boldsymbol{A}_f \\cdot \\boldsymbol{d} = -0.013 + 0.0015 + 0.2765 = 0.265 $$\n由于 $\\boldsymbol{A}_f \\cdot \\boldsymbol{d} > 0$，由顶点顺序定义的法向量从所有者单元指向邻居单元。因此，存储的方向是一致的。用于从所有者侧计算通量的方向一致的面面积向量就是 $\\boldsymbol{A}_f$ 本身。\n\n最后，我们使用给定的均匀密度 $\\rho$ 和速度场 $\\boldsymbol{u}$ 来计算对流质量通量 $\\Phi_m$：\n$$ \\Phi_m = \\rho (\\boldsymbol{u} \\cdot \\boldsymbol{A}_f) $$\n给定 $\\rho = 0.8\\,\\mathrm{kg/m^3}$ 和 $\\boldsymbol{u} = (12,\\, -3,\\, 25)\\,\\mathrm{m/s}$。首先，我们计算体积通量，即点积 $\\boldsymbol{u} \\cdot \\boldsymbol{A}_f$：\n$$ \\boldsymbol{u} \\cdot \\boldsymbol{A}_f = (12,\\, -3,\\, 25) \\cdot (-0.13,\\, -0.015,\\, 0.395) $$\n$$ \\boldsymbol{u} \\cdot \\boldsymbol{A}_f = 12(-0.13) + (-3)(-0.015) + 25(0.395) $$\n$$ \\boldsymbol{u} \\cdot \\boldsymbol{A}_f = -1.56 + 0.045 + 9.875 = 8.36\\,\\mathrm{m^3/s} $$\n\n现在，我们乘以密度以获得质量通量：\n$$ \\Phi_m = 0.8\\,\\mathrm{kg/m^3} \\times 8.36\\,\\mathrm{m^3/s} = 6.688\\,\\mathrm{kg/s} $$\n\n问题要求最终答案四舍五入到四位有效数字。计算出的值 $6.688$ 已经有四位有效数字。",
            "answer": "$$\\boxed{6.688}$$"
        },
        {
            "introduction": "在有限体积法中，为了获得比一阶更高的精度，或为了计算扩散通量（它依赖于梯度的精确值），我们需要在单元中心或节点处准确地重构解的梯度。简单的梯度计算方法在面对航空航天应用中常见的拉伸或歪斜网格时，其精度会严重下降。\n\n本练习介绍了一种在非结构网格上稳健重构梯度的强大技术——最小二乘法。通过这个编码实践()，你将探索如何利用节点周围的多个邻近点信息来构建一个超定系统以求解梯度，并了解如何通过逆距离加权来提高梯度重构的准确性和鲁棒性。",
            "id": "3980510",
            "problem": "在二维计算流体动力学（CFD）中，特别是在有限体积法（FVM）中，通常需要根据周围控制体的中心和基于面的数据来重构节点处的梯度。考虑一个标量场 $\\phi(x,y)$，它在一个位于位置 $\\boldsymbol{x}_0 = (x_0,y_0)$ 的节点邻域内光滑定义。目标是根据围绕 $\\boldsymbol{x}_0$ 的 $N$ 个邻近样本 $\\{\\phi_i\\}$（位于位置 $\\boldsymbol{x}_i = (x_i,y_i)$）来计算梯度向量 $\\nabla \\phi(\\boldsymbol{x}_0)$，其中一些位置可能对应于相邻的单元中心，而另一些则对应于面心。\n\n从 $\\phi$ 在 $\\boldsymbol{x}_0$ 处的泰勒展开出发，并记 $\\boldsymbol{r}_i = \\boldsymbol{x}_i - \\boldsymbol{x}_0$，将节点处的最小二乘梯度定义为二次失配的最小化子 $\\boldsymbol{g}$\n$$\nJ(\\boldsymbol{g}) = \\sum_{i=1}^{N} w_i \\left(\\phi_i - \\phi_0 - \\boldsymbol{g} \\cdot \\boldsymbol{r}_i \\right)^2,\n$$\n其中 $\\phi_0 = \\phi(\\boldsymbol{x}_0)$，$w_i$ 是非负权重。必须实现两种情况：\n- 无权最小二乘：对所有 $i$，$w_i = 1$。\n- 反距离加权最小二乘：对所有 $i$，$w_i = \\frac{1}{\\lVert \\boldsymbol{r}_i \\rVert}$，其中 $\\lVert \\cdot \\rVert$ 表示欧几里得范数。\n\n使用以下标量场，它代表一个由线项和弱曲率组成的通用光滑场，以确保测试的非平凡性：\n$$\n\\phi(x,y) = 3 x - 2 y + \\tfrac{1}{2} x^2 + \\tfrac{1}{4} x y.\n$$\n在任意点 $(x,y)$ 处的精确梯度为\n$$\n\\nabla \\phi(x,y) = \\left( 3 + x + \\tfrac{1}{4} y,\\; -2 + \\tfrac{1}{4} x \\right).\n$$\n\n对于下述每个测试用例，您的程序必须计算指定节点处的无权和反距离加权最小二乘梯度近似值，并报告每个近似值相对于精确梯度的相对欧几里得误差，定义为\n$$\n\\varepsilon = \\frac{\\lVert \\boldsymbol{g}_{\\text{approx}} - \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}{\\lVert \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}.\n$$\n\n如果测试中存在噪声，它将被加到邻近标量值 $\\phi_i$ 上，但不加到 $\\phi_0$ 上。不使用角度。不需要物理单位。所有输出都是无量纲的。\n\n在一个单独的程序中实现该算法，以评估以下邻近位置的测试套件。在每种情况下，都指定了节点位置 $\\boldsymbol{x}_0$ 和邻近点集 $\\{\\boldsymbol{x}_i\\}_{i=1}^N$：\n\n- 测试用例 1（$\\boldsymbol{x}_0$ 周围的各向同性邻点，代表一个包含单元中心和面中点的形状良好的网格）：\n  - 节点：$\\boldsymbol{x}_0 = (0, 0)$。\n  - 邻点：\n    - $(1, 0)$, $(-1, 0)$, $(0, 1)$, $(0, -1)$,\n    - $(0.7, 0.7)$, $(-0.7, 0.7)$, $(0.7, -0.7)$, $(-0.7, -0.7)$。\n  - 噪声：无。\n\n- 测试用例 2（$\\boldsymbol{x}_0$ 附近的高度各向异性点簇，带有一个远处离群点，模拟一个带有偏远面心的倾斜控制体邻接关系）：\n  - 节点：$\\boldsymbol{x}_0 = (0, 0)$。\n  - 邻点：\n    - $(0.05, -0.01)$, $(0.10, 0.00)$, $(0.15, 0.01)$, $(0.20, -0.02)$, $(5.0, 3.0)$。\n  - 噪声：无。\n\n- 测试用例 3（不规则邻点，并在 $\\phi_i$ 上带有少量测量噪声）：\n  - 节点：$\\boldsymbol{x}_0 = (0, 0)$。\n  - 邻点：\n    - $(0.2, 0.3)$, $(-0.25, 0.1)$, $(0.4, -0.35)$, $(-0.6, -0.2)$, $(1.2, 0.8)$, $(-1.0, 0.9)$。\n  - 邻点值 $\\phi_i$ 上的附加噪声（顺序与邻点相同）：$[5 \\times 10^{-4},\\; -4 \\times 10^{-4},\\; 3 \\times 10^{-4},\\; -2 \\times 10^{-4},\\; 1 \\times 10^{-4},\\; -1 \\times 10^{-4}]$。\n  - $\\phi_0$ 上无噪声。\n\n- 测试用例 4（$\\boldsymbol{x}_0$ 周围偏离原点的倾斜邻点，结合了近似共线的单元中心和一些离轴的面点）：\n  - 节点：$\\boldsymbol{x}_0 = (1.0, -0.5)$。\n  - 邻点：\n    - $(1.05, -0.49)$, $(1.10, -0.51)$, $(1.15, -0.48)$, $(1.20, -0.52)$, $(1.02, -0.30)$, $(0.90, -0.70)$。\n  - 噪声：无。\n\n对于每个测试用例，计算：\n- 无权相对误差 $\\varepsilon_{\\text{unw}}$。\n- 反距离加权相对误差 $\\varepsilon_{\\text{w}}$，其中 $w_i = 1 / \\lVert \\boldsymbol{r}_i \\rVert$。\n- 一个布尔标志，指示反距离加权是否改善了结果，即 $\\varepsilon_{\\text{w}}  \\varepsilon_{\\text{unw}}$ 是否成立。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 每个测试用例贡献一个形式为 $[\\varepsilon_{\\text{unw}}, \\varepsilon_{\\text{w}}, \\text{better}]$ 的三元素列表，其中 $\\text{better}$ 是一个布尔值，指示加权误差是否严格小于无权误差。\n- 每个测试的两个误差值必须四舍五入到 $8$ 位小数。\n- 格式示例：$[[0.00123456,0.00098765,\\text{True}],\\ldots]$。\n\n程序必须是自包含的，且不需要任何输入。它必须根据给定的 $\\phi(x,y)$ 计算所有邻点值 $\\phi_i$，并在指定位置应用噪声。计算应完全采用浮点运算，无需单位转换。目标是通过这些测试用例，展示反距离加权如何通过减少节点处最小二乘梯度重构中远处或分布不佳的邻点的影响，来增强在不规则网格上的鲁棒性。",
            "solution": "我们从一个光滑标量场 $\\phi$ 在点 $\\boldsymbol{x}_0 = (x_0,y_0)$ 处的泰勒展开开始，并在邻近位置 $\\boldsymbol{x}_i = (x_i,y_i)$ 对其进行求值：\n$$\n\\phi(\\boldsymbol{x}_i) = \\phi(\\boldsymbol{x}_0) + \\nabla \\phi(\\boldsymbol{x}_0) \\cdot \\boldsymbol{r}_i + \\mathcal{O}(\\lVert \\boldsymbol{r}_i \\rVert^2),\n$$\n其中 $\\boldsymbol{r}_i = \\boldsymbol{x}_i - \\boldsymbol{x}_0$。如果我们让 $\\boldsymbol{g}$ 表示 $\\nabla \\phi(\\boldsymbol{x}_0)$ 的一个近似，并定义残差\n$$\n\\delta_i(\\boldsymbol{g}) = \\phi_i - \\phi_0 - \\boldsymbol{g} \\cdot \\boldsymbol{r}_i,\n$$\n那么最小二乘估计就是寻找使 $\\delta_i$ 的平方和最小化的 $\\boldsymbol{g}$。为了结合几何信息，我们引入非负权重 $w_i$ 并最小化\n$$\nJ(\\boldsymbol{g}) = \\sum_{i=1}^{N} w_i \\, \\delta_i(\\boldsymbol{g})^2.\n$$\n令 $A \\in \\mathbb{R}^{N \\times 2}$ 为设计矩阵，其第 $i$ 行为 $A_i = \\boldsymbol{r}_i^\\top$，令 $b \\in \\mathbb{R}^{N}$ 为一个向量，其元素为 $b_i = \\phi_i - \\phi_0$。令 $W = \\mathrm{diag}(w_1,\\ldots,w_N)$。则\n$$\nJ(\\boldsymbol{g}) = \\lVert W^{1/2}(A \\boldsymbol{g} - b) \\rVert_2^2.\n$$\n一阶最优性条件得出加权正规方程\n$$\n(A^\\top W A)\\, \\boldsymbol{g} = A^\\top W b.\n$$\n当 $A^\\top W A$ 非奇异时，解为\n$$\n\\boldsymbol{g} = (A^\\top W A)^{-1} A^\\top W b.\n$$\n在数值计算上，避免显式地构造逆矩阵是有利的。可以转而通过构造 $\\tilde{A} = W^{1/2} A$ 和 $\\tilde{b} = W^{1/2} b$ 来求解最小二乘问题，然后使用一个鲁棒的最小二乘求解器（例如，基于 QR 的方法）。在实践中，对于给定的较小规模，函数 $\\texttt{numpy.linalg.lstsq}$ 可以为 $\\min_{\\boldsymbol{g}} \\lVert \\tilde{A} \\boldsymbol{g} - \\tilde{b} \\rVert_2$ 计算出一个稳定的解。\n\n权重的选择：\n- 无权：$w_i = 1$ 对所有邻点给予同等重视。\n- 反距离：$w_i = 1 / \\lVert \\boldsymbol{r}_i \\rVert$ 降低了远处邻点的影响。这提高了在不规则网格上的鲁棒性，因为被忽略的泰勒展开高阶项所带来的截断误差随 $\\lVert \\boldsymbol{r}_i \\rVert^2$ 增长，而且几何各向异性或离群点可能会使拟合产生偏差，除非对远处的样本进行降权。\n\n我们使用以下标量场进行测试\n$$\n\\phi(x,y) = 3 x - 2 y + \\tfrac{1}{2} x^2 + \\tfrac{1}{4} x y,\n$$\n其梯度为\n$$\n\\nabla \\phi(x,y) = \\left( 3 + x + \\tfrac{1}{4} y,\\; -2 + \\tfrac{1}{4} x \\right).\n$$\n在每个节点 $\\boldsymbol{x}_0$ 处，我们计算 $\\phi_0 = \\phi(\\boldsymbol{x}_0)$，然后汇集邻点值 $\\phi_i = \\phi(\\boldsymbol{x}_i)$，并可选择性地添加指定的噪声。然后我们构造 $A$ 和 $b$，在无权和加权两种情况下求解 $\\boldsymbol{g}$，并计算相对欧几里得误差\n$$\n\\varepsilon_{\\text{unw}} = \\frac{\\lVert \\boldsymbol{g}_{\\text{unw}} - \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}{\\lVert \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}, \\quad\n\\varepsilon_{\\text{w}} = \\frac{\\lVert \\boldsymbol{g}_{\\text{w}} - \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}{\\lVert \\nabla \\phi(\\boldsymbol{x}_0) \\rVert_2}.\n$$\n\n每个测试用例的算法步骤：\n- 步骤 1：计算 $\\phi_0 = \\phi(\\boldsymbol{x}_0)$ 和 $\\phi_i = \\phi(\\boldsymbol{x}_i)$；如果指定，则向 $\\phi_i$ 添加噪声，保持 $\\phi_0$ 无噪声。\n- 步骤 2：构造矩阵 $A$，其行为 $\\boldsymbol{r}_i^\\top = (\\Delta x_i,\\Delta y_i)$，其中 $\\Delta x_i = x_i - x_0$ 且 $\\Delta y_i = y_i - y_0$；构造向量 $b$，其元素为 $\\phi_i - \\phi_0$。\n- 步骤 3：对于无权最小二乘，设置 $w_i = 1$，$\\tilde{A} = A$，$\\tilde{b} = b$；通过求解 $\\min \\lVert \\tilde{A} \\boldsymbol{g} - \\tilde{b} \\rVert_2$ 来计算 $\\boldsymbol{g}_{\\text{unw}}$。\n- 步骤 4：对于反距离权重，设置 $w_i = 1/\\lVert \\boldsymbol{r}_i \\rVert$，定义 $\\tilde{A}_i = \\sqrt{w_i} A_i$ 和 $\\tilde{b}_i = \\sqrt{w_i} b_i$，然后类似地计算 $\\boldsymbol{g}_{\\text{w}}$。\n- 步骤 5：评估精确梯度 $\\nabla \\phi(\\boldsymbol{x}_0)$ 并计算 $\\varepsilon_{\\text{unw}}$ 和 $\\varepsilon_{\\text{w}}$。\n- 步骤 6：确定布尔值 $\\text{better}$，以指示是否 $\\varepsilon_{\\text{w}}  \\varepsilon_{\\text{unw}}$。\n- 步骤 7：将 $\\varepsilon_{\\text{unw}}$ 和 $\\varepsilon_{\\text{w}}$ 四舍五入到 8 位小数，并收集三元组 $[\\varepsilon_{\\text{unw}}, \\varepsilon_{\\text{w}}, \\text{better}]$。\n\n测试用例的解释：\n- 测试 1 的特点是近似各向同性的覆盖，因此两种方法都应表现良好；在这种良态情况下，反距离加权可能几乎没有优势。\n- 测试 2 包含一个远处的离群点；无权最小二乘可能会受到该离群点的偏置影响，因为 $\\phi$ 的高阶项随距离增长，而反距离加权则抑制了离群点的影响，从而提高了鲁棒性。\n- 测试 3 引入了少量测量噪声；反距离加权相对于近邻点减少了有噪声的远处样本的影响，可能改善估计结果。\n- 测试 4 在一个非原点节点处呈现了一个倾斜的邻点集；在没有足够角度扩展的情况下，几何结构可能接近退化，而降低更远或信息量较少的方向的权重有助于稳定重构。\n\n该程序直接实现了这些步骤，为保证数值稳定性，在加权系统上使用了 $\\texttt{numpy.linalg.lstsq}$。最终打印的行是一个列表，其中包含每个测试的三元组 $[\\varepsilon_{\\text{unw}}, \\varepsilon_{\\text{w}}, \\text{better}]$，误差四舍五入到 8 位小数，展示了反距离加权在不规则网格上的效果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi(x, y):\n    # phi(x,y) = 3x - 2y + 0.5 x^2 + 0.25 x y\n    return 3.0 * x - 2.0 * y + 0.5 * x * x + 0.25 * x * y\n\ndef grad_phi_exact(x, y):\n    # grad phi = [3 + x + 0.25 y, -2 + 0.25 x]\n    return np.array([3.0 + x + 0.25 * y, -2.0 + 0.25 * x], dtype=float)\n\ndef ls_gradient(x0, neighbors, phi_values, weighted):\n    \"\"\"\n    Compute least-squares gradient at node x0 from neighbor coordinates and phi values.\n    Parameters:\n        x0: (2,) ndarray\n        neighbors: (N,2) ndarray of neighbor coords\n        phi_values: (N,) ndarray of phi at neighbors (possibly noisy)\n        weighted: bool, if True use inverse-distance weights\n    Returns:\n        g: (2,) ndarray gradient\n    \"\"\"\n    x0 = np.asarray(x0, dtype=float)\n    X = np.asarray(neighbors, dtype=float)\n    r = X - x0[None, :]\n    N = r.shape[0]\n    A = r  # N x 2\n    phi0 = phi(x0[0], x0[1])\n    b = phi_values - phi0  # N\n    if weighted:\n        # Inverse-distance weights\n        d = np.linalg.norm(r, axis=1)\n        # All distances are nonzero per problem setup.\n        w = 1.0 / d\n        sqrtw = np.sqrt(w)\n        Aw = A * sqrtw[:, None]\n        bw = b * sqrtw\n        g, _, _, _ = np.linalg.lstsq(Aw, bw, rcond=None)\n    else:\n        g, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    return g\n\ndef relative_error(g, g_exact):\n    return np.linalg.norm(g - g_exact) / np.linalg.norm(g_exact)\n\ndef solve():\n    # Define test cases according to the problem statement.\n    test_cases = []\n\n    # Test case 1\n    x0_1 = np.array([0.0, 0.0], dtype=float)\n    neighbors_1 = np.array([\n        [1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0],\n        [0.7, 0.7], [-0.7, 0.7], [0.7, -0.7], [-0.7, -0.7]\n    ], dtype=float)\n    noise_1 = None\n    test_cases.append((x0_1, neighbors_1, noise_1))\n\n    # Test case 2\n    x0_2 = np.array([0.0, 0.0], dtype=float)\n    neighbors_2 = np.array([\n        [0.05, -0.01], [0.10, 0.00], [0.15, 0.01], [0.20, -0.02], [5.0, 3.0]\n    ], dtype=float)\n    noise_2 = None\n    test_cases.append((x0_2, neighbors_2, noise_2))\n\n    # Test case 3\n    x0_3 = np.array([0.0, 0.0], dtype=float)\n    neighbors_3 = np.array([\n        [0.2, 0.3], [-0.25, 0.1], [0.4, -0.35], [-0.6, -0.2], [1.2, 0.8], [-1.0, 0.9]\n    ], dtype=float)\n    noise_3 = np.array([5e-4, -4e-4, 3e-4, -2e-4, 1e-4, -1e-4], dtype=float)\n    test_cases.append((x0_3, neighbors_3, noise_3))\n\n    # Test case 4\n    x0_4 = np.array([1.0, -0.5], dtype=float)\n    neighbors_4 = np.array([\n        [1.05, -0.49], [1.10, -0.51], [1.15, -0.48], [1.20, -0.52],\n        [1.02, -0.30], [0.90, -0.70]\n    ], dtype=float)\n    noise_4 = None\n    test_cases.append((x0_4, neighbors_4, noise_4))\n\n    results = []\n    for x0, Xnbr, noise in test_cases:\n        # Compute phi at neighbors and apply noise if given\n        phi_vals = np.array([phi(x, y) for x, y in Xnbr], dtype=float)\n        if noise is not None:\n            phi_vals = phi_vals + noise\n        # Exact gradient at node\n        g_exact = grad_phi_exact(x0[0], x0[1])\n        # Unweighted gradient\n        g_unw = ls_gradient(x0, Xnbr, phi_vals, weighted=False)\n        # Weighted gradient\n        g_w = ls_gradient(x0, Xnbr, phi_vals, weighted=True)\n        # Relative errors\n        e_unw = relative_error(g_unw, g_exact)\n        e_w = relative_error(g_w, g_exact)\n        # Round to 8 decimals\n        e_unw_r = float(f\"{e_unw:.8f}\")\n        e_w_r = float(f\"{e_w:.8f}\")\n        better = e_w  e_unw\n        results.append([e_unw_r, e_w_r, better])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在扩散项的离散化过程中，最简单的格式通常假设网格是正交的，即面法向矢量与相邻单元中心的连线平行。然而，在实际应用的复杂几何体中，网格几乎不可能是完全正交的，这种简化会引入显著的离散误差，影响解的精度。\n\n这个高级练习()深入探讨了非结构网格上有限体积法的一个关键误差来源：网格的非正交性。通过推导并计算一个非正交修正项，你将能更深刻地理解现代CFD代码如何分解通量计算，并引入修正来补偿几何不理想性，从而在复杂网格上保持高精度。",
            "id": "3980499",
            "problem": "考虑在计算流体动力学 (CFD) 中，一种以单元体为中心的有限体积法中的基于面的扩散离散。设两个相邻的控制体，其形心分别位于位置 $\\boldsymbol{x}_P$ 和 $\\boldsymbol{x}_N$，共享一个面积矢量为 $\\boldsymbol{S}_f$ 的公共平面。标量场 $\\phi(\\boldsymbol{x})$ 通过扩散进行输运，其无量纲扩散系数 $\\Gamma$ 为常数，并假设其在空间中线性变化，因此 $\\nabla \\phi$ 是一个常数。基于面的扩散贡献项由守恒方程的积分形式和散度定理得到，其形式为在面上求值的 $-\\Gamma\\,\\boldsymbol{S}_f \\cdot \\nabla \\phi$ 在所有面上的总和。常用的正交（中心到中心）近似将面法向梯度替换为沿连接形心直线的方向导数，当面法向矢量 $\\boldsymbol{S}_f$ 不平行于形心到形心的矢量时，这会引入误差。\n\n从散度定理、梯度的定义以及沿单位方向的方向导数出发，通过投影到连接形心的方向上，推导非正交性引起的面误差，该误差为精确的面贡献与正交的中心到中心近似之间的差值。然后，提出了一个必须加到正交近似上的非正交修正项，以恢复线性场下的精确面贡献。该修正项用 $\\boldsymbol{S}_f \\cdot \\nabla \\phi$ 分解成的正交和非正交部分来表示。\n\n最后，根据以下无量纲数据，数值计算非正交修正项对通过面的扩散通量的贡献：\n- $\\boldsymbol{x}_P = (0,\\,0,\\,0)$，\n- $\\boldsymbol{x}_N = (1,\\,0.2,\\,0)$，\n- $\\boldsymbol{S}_f = (0.24,\\,0.18,\\,0)$，\n- $\\nabla \\phi = (2.5,\\,-0.7,\\,1.2)$，\n- $\\Gamma = 2$。\n\n所有量均为无量纲。将您的最终答案（非正交修正对通过面扩散通量的贡献值）四舍五入到四位有效数字。将最终答案表示为不带任何单位的纯数字。",
            "solution": "该问题要求推导在有限体积法中用于基于面的扩散通量计算的非正交修正项，并根据给定数据对其进行数值计算。分析假设标量场 $\\phi(\\boldsymbol{x})$ 是线性的，这意味着其梯度 $\\nabla\\phi$ 是一个常矢量。\n\n让我们从控制体 $V$ 上标量 $\\phi$ 的守恒方程的积分形式开始，在没有源项和对流的情况下：\n$$ \\frac{\\partial}{\\partial t} \\int_V \\phi \\,dV + \\int_V \\nabla \\cdot \\boldsymbol{J} \\,dV = 0 $$\n其中 $\\boldsymbol{J}$ 是扩散通量矢量，根据菲克定律定义为 $\\boldsymbol{J} = -\\Gamma\\nabla\\phi$，$\\Gamma$ 是恒定的扩散系数。\n\n将散度定理应用于第二项，可将体积分转换为对包围控制体的各个面 $f$ 的面积分之和：\n$$ \\int_V \\nabla \\cdot \\boldsymbol{J} \\,dV = \\sum_f \\int_f \\boldsymbol{J} \\cdot d\\boldsymbol{S} $$\n对于一个面积矢量为 $\\boldsymbol{S}_f$ 的平面，并假设通量矢量 $\\boldsymbol{J}$ 在整个面上是均匀的（因为 $\\nabla\\phi$ 是常数，所以这是成立的），积分简化为点积：\n$$ \\int_f \\boldsymbol{J} \\cdot d\\boldsymbol{S} = \\boldsymbol{J} \\cdot \\boldsymbol{S}_f = (-\\Gamma\\nabla\\phi) \\cdot \\boldsymbol{S}_f = -\\Gamma(\\boldsymbol{S}_f \\cdot \\nabla\\phi) $$\n此项 $F_f = -\\Gamma(\\boldsymbol{S}_f \\cdot \\nabla\\phi)$ 表示通过面 $f$ 的精确扩散通量。离散化问题的核心在于近似项 $\\boldsymbol{S}_f \\cdot \\nabla\\phi$。\n\n在以单元体为中心的有限体积法中，主要变量存储在控制体的形心处，此处用 $\\boldsymbol{x}_P$ 和 $\\boldsymbol{x}_N$ 表示两个相邻单元的形心。连接形心的几何矢量为 $\\boldsymbol{d} = \\boldsymbol{x}_N - \\boldsymbol{x}_P$。\n\n通量的正交近似是基于沿形心到形心矢量 $\\boldsymbol{d}$ 的梯度分量。对于线性场，差值 $\\phi_N - \\phi_P$ 与梯度精确相关，关系式为 $\\phi_N - \\phi_P = \\nabla\\phi \\cdot (\\boldsymbol{x}_N - \\boldsymbol{x}_P) = \\nabla\\phi \\cdot \\boldsymbol{d}$。最简单的通量近似仅使用此单元到单元的差值来构造，这隐含地依赖于沿 $\\boldsymbol{d}$ 的梯度分量。\n\n当面面积矢量 $\\boldsymbol{S}_f$ 不平行于形心矢量 $\\boldsymbol{d}$ 时，就会出现网格非正交性。为了系统地处理这个问题，将矢量 $\\boldsymbol{S}_f$ 分解为两个分量：一个平行于 $\\boldsymbol{d}$，另一个垂直于 $\\boldsymbol{d}$。令 $\\boldsymbol{e}_d = \\boldsymbol{d}/|\\boldsymbol{d}|$ 为沿形心连接线的单位矢量。\n平行分量，我们称之为面积矢量的“正交”部分，是 $\\boldsymbol{S}_f$ 在 $\\boldsymbol{d}$ 上的投影：\n$$ \\boldsymbol{S}_{f, \\parallel} = (\\boldsymbol{S}_f \\cdot \\boldsymbol{e}_d) \\boldsymbol{e}_d = \\frac{(\\boldsymbol{S}_f \\cdot \\boldsymbol{d})}{|\\boldsymbol{d}|^2}\\boldsymbol{d} $$\n垂直分量，我们称之为“非正交”部分，是剩余的部分：\n$$ \\boldsymbol{S}_{f, \\perp} = \\boldsymbol{S}_f - \\boldsymbol{S}_{f, \\parallel} $$\n根据构造，$\\boldsymbol{S}_{f, \\perp} \\cdot \\boldsymbol{d} = 0$。\n\n使用此分解，精确项 $\\boldsymbol{S}_f \\cdot \\nabla\\phi$ 可以分为两部分：\n$$ \\boldsymbol{S}_f \\cdot \\nabla\\phi = (\\boldsymbol{S}_{f, \\parallel} + \\boldsymbol{S}_{f, \\perp}) \\cdot \\nabla\\phi = \\underbrace{\\boldsymbol{S}_{f, \\parallel} \\cdot \\nabla\\phi}_{\\text{正交部分}} + \\underbrace{\\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi}_{\\text{非正交部分}} $$\n面通量项的正交近似只考虑第一部分，因为它可以直接与单元中心值 $\\phi_P$ 和 $\\phi_N$ 相关联：\n$$ (\\boldsymbol{S}_f \\cdot \\nabla\\phi)_{\\text{正交近似}} = \\boldsymbol{S}_{f, \\parallel} \\cdot \\nabla\\phi = \\frac{(\\boldsymbol{S}_f \\cdot \\boldsymbol{d})}{|\\boldsymbol{d}|^2}(\\boldsymbol{d} \\cdot \\nabla\\phi) = \\frac{(\\boldsymbol{S}_f \\cdot \\boldsymbol{d})}{|\\boldsymbol{d}|^2}(\\phi_N - \\phi_P) $$\n非正交性引起的面误差是精确项与此正交近似之间的差值：\n$$ \\text{误差} = (\\boldsymbol{S}_f \\cdot \\nabla\\phi) - (\\boldsymbol{S}_f \\cdot \\nabla\\phi)_{\\text{正交近似}} = \\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi $$\n因此，为了恢复线性场下的精确面贡献，必须在正交近似上加上一个等于此误差的非正交修正项。因此，提出的非正交修正项为 $C_{\\text{非正交}} = \\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi$。\n\n那么通过该面的总扩散通量由下式给出：\n$$ F_f = -\\Gamma [(\\boldsymbol{S}_f \\cdot \\nabla\\phi)_{\\text{正交近似}} + C_{\\text{非正交}}] $$\n来自非正交修正对扩散通量的贡献是 $-\\Gamma C_{\\text{非正交}} = -\\Gamma(\\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi)$。我们需要对这个量进行数值计算。\n\n给定的无量纲数据为：\n- $\\boldsymbol{x}_P = (0,\\,0,\\,0)$\n- $\\boldsymbol{x}_N = (1,\\,0.2,\\,0)$\n- $\\boldsymbol{S}_f = (0.24,\\,0.18,\\,0)$\n- $\\nabla \\phi = (2.5,\\,-0.7,\\,1.2)$\n- $\\Gamma = 2$\n\n首先，我们计算所需的几何矢量。\n形心到形心的矢量是：\n$$ \\boldsymbol{d} = \\boldsymbol{x}_N - \\boldsymbol{x}_P = (1,\\,0.2,\\,0) - (0,\\,0,\\,0) = (1,\\,0.2,\\,0) $$\n$\\boldsymbol{d}$ 的模的平方是：\n$$ |\\boldsymbol{d}|^2 = 1^2 + 0.2^2 + 0^2 = 1 + 0.04 = 1.04 $$\n接下来，我们计算面面积矢量和形心矢量的点积：\n$$ \\boldsymbol{S}_f \\cdot \\boldsymbol{d} = (0.24)(1) + (0.18)(0.2) + (0)(0) = 0.24 + 0.036 = 0.276 $$\n现在，我们求面积矢量的非正交分量 $\\boldsymbol{S}_{f, \\perp}$：\n$$ \\boldsymbol{S}_{f, \\perp} = \\boldsymbol{S}_f - \\frac{\\boldsymbol{S}_f \\cdot \\boldsymbol{d}}{|\\boldsymbol{d}|^2}\\boldsymbol{d} $$\n$$ \\boldsymbol{S}_{f, \\perp} = (0.24,\\,0.18,\\,0) - \\frac{0.276}{1.04}(1,\\,0.2,\\,0) $$\n标量分数为 $\\frac{0.276}{1.04} = \\frac{276}{1040} = \\frac{69}{260}$。\n$$ \\boldsymbol{S}_{f, \\perp} = (0.24,\\,0.18,\\,0) - (\\frac{69}{260}, \\frac{69}{260} \\times 0.2, 0) = (0.24 - \\frac{69}{260}, 0.18 - \\frac{13.8}{260}, 0) $$\n计算各分量：\n$x$ 分量：$0.24 - \\frac{69}{260} = \\frac{6}{25} - \\frac{69}{260} = \\frac{6 \\times 52 - 69 \\times 5}{1300} = \\frac{312 - 345}{1300} = -\\frac{33}{1300}$。\n$y$ 分量：$0.18 - \\frac{13.8}{260} = \\frac{18}{100} - \\frac{13.8}{260} = \\frac{9}{50} - \\frac{69}{1300} = \\frac{9 \\times 26 - 69}{1300} = \\frac{234 - 69}{1300} = \\frac{165}{1300}$。\n所以，非正交矢量分量是：\n$$ \\boldsymbol{S}_{f, \\perp} = \\left(-\\frac{33}{1300}, \\frac{165}{1300}, 0\\right) $$\n非正交修正项 $C_{\\text{非正交}}$ 是此矢量与梯度 $\\nabla\\phi$ 的点积：\n$$ C_{\\text{非正交}} = \\boldsymbol{S}_{f, \\perp} \\cdot \\nabla\\phi = \\left(-\\frac{33}{1300}\\right)(2.5) + \\left(\\frac{165}{1300}\\right)(-0.7) + (0)(1.2) $$\n$$ C_{\\text{非正交}} = \\frac{(-33)(2.5) + (165)(-0.7)}{1300} = \\frac{-82.5 - 115.5}{1300} = \\frac{-198}{1300} = -\\frac{99}{650} $$\n最后，非正交修正对通过面的扩散通量的贡献是：\n$$ \\text{通量修正} = -\\Gamma C_{\\text{非正交}} = -2 \\times \\left(-\\frac{99}{650}\\right) = \\frac{198}{650} = \\frac{99}{325} $$\n为了给出数值答案，我们计算这个分数：\n$$ \\frac{99}{325} \\approx 0.30461538... $$\n四舍五入到四位有效数字，结果是 $0.3046$。",
            "answer": "$$\\boxed{0.3046}$$"
        }
    ]
}