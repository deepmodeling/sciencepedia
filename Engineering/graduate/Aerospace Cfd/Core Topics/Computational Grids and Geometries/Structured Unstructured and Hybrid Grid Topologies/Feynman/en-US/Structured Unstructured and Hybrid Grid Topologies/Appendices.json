{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any unstructured grid solver is its ability to efficiently navigate the mesh topology. This requires a robust representation of cell connectivity, which dictates how information is passed between neighboring control volumes. This exercise challenges you to implement a fundamental algorithm for building a cell adjacency graph from element-vertex data and representing it in the computationally efficient Compressed Sparse Row (CSR) format, a cornerstone of high-performance scientific computing. By tackling cases from simple adjacencies to non-manifold configurations, you will gain practical insight into the data structures that underpin modern CFD codes .",
            "id": "3998385",
            "problem": "You are given multiple unstructured tetrahedral meshes, each defined purely by cell-to-vertex connectivity. For a tetrahedral mesh, a cell is a tetrahedron specified by $4$ distinct vertex indices. Two cells are adjacent if and only if they share a common triangular face, that is, if and only if they share exactly $3$ vertices. Your tasks are:\n- Construct the Compressed Sparse Row (CSR) adjacency representation of the cell adjacency graph for each mesh.\n- Compute the average stencil size, defined as the average number of neighbors per cell, for each mesh.\n\nFundamental definitions to use:\n- A tetrahedron has $4$ triangular faces, each face being a set of $3$ of its $4$ vertices.\n- Define a face in canonical form by sorting its $3$ vertex indices in ascending order.\n- Define the cell adjacency graph as an undirected graph $G = (V, E)$ where $V$ is the set of cell indices and there is an undirected edge between two cells if and only if they share a face.\n- In CSR format for a matrix of size $N \\times N$, the row pointer array has length $N+1$, the column index array has length equal to the number of stored nonzero entries, and the nonzero values array has the same length as the column indices. For an unweighted adjacency, you may take all nonzero values to be $1$.\n\nConstraints and conventions:\n- For each mesh, cells are indexed $0$ through $N-1$, where $N$ is the number of cells.\n- Vertex indices are nonnegative integers.\n- Do not introduce self-adjacency; there must be no self-edges.\n- If more than two cells share the same face (a non-manifold configuration), treat all such cells as mutually adjacent pairwise, and ensure duplicate neighbor entries are removed.\n- If two cells share only an edge (i.e., only $2$ common vertices) or only a vertex (i.e., only $1$ common vertex), they are not adjacent.\n- The CSR arrays to be constructed are: the row pointer array $p$ of length $N+1$, the column index array $j$, and the value array $x$ filled with ones. Although the program will not print the CSR arrays, they must be constructed internally to compute the average stencil size as the average row length.\n- The average stencil size for a mesh with $N$ cells is the scalar\n$$ \\bar{d} \\equiv \\frac{1}{N} \\sum_{i=0}^{N-1} d_i, $$\nwhere $d_i$ is the number of neighbors of cell $i$.\n\nTest suite:\nFor each of the following meshes, compute the average stencil size. The meshes are provided as lists of cells, where each cell is specified by a $4$-tuple of vertex indices:\n- Test $1$ (single isolated cell): $[(0,1,2,3)]$. Expected qualitative behavior: no adjacency, average stencil size equals $0$.\n- Test $2$ (two cells sharing a face): $[(0,1,2,3),(0,1,2,4)]$. Expected qualitative behavior: one adjacency per cell, average stencil size equals $1$.\n- Test $3$ (three cells in a chain via faces): $[(0,1,2,3),(1,2,3,4),(1,3,4,5)]$. Expected qualitative behavior: degrees $[1,2,1]$, average stencil size equals $4/3$.\n- Test $4$ (non-manifold face shared by three cells): $[(0,1,2,3),(0,1,2,4),(0,1,2,5)]$. Expected qualitative behavior: each cell adjacent to the other two, average stencil size equals $2$.\n- Test $5$ (two cells sharing only an edge, not a face): $[(0,1,2,3),(0,1,4,5)]$. Expected qualitative behavior: no adjacency, average stencil size equals $0$.\n\nYour program must:\n- For each test mesh, construct the CSR adjacency representation according to the above, with the row pointer array $p$, the column index array $j$, and the value array $x$ filled with ones.\n- Compute the average stencil size $\\bar{d}$ as defined above, using the CSR structure.\n- Produce a single line of output containing the results for the tests as a comma-separated list enclosed in square brackets, with each average rounded to six decimal places (for example, $[0.000000,1.000000]$).\n\nThere is no user input. The program must run as is and print exactly one line in the specified format. All outputs are unitless real numbers rounded to six decimal places. Angles are not involved, and no percentages are required. The final output must be a list of $5$ floating-point numbers in the order of the tests specified above.",
            "solution": "The problem requires the computation of the average stencil size for several unstructured tetrahedral meshes. The stencil size of a cell is its number of adjacent cells, and the average is taken over all cells in the mesh. This task will be accomplished by first constructing the cell adjacency graph for each mesh and then calculating the average cell degree.\n\nThe fundamental principle for establishing adjacency is that two distinct tetrahedral cells are adjacent if and only if they share a common triangular face. A face is defined by a set of $3$ vertices. The problem is thus reduced to efficiently identifying all pairs of cells that share a face.\n\nA brute-force approach, comparing every pair of cells in a mesh of $N$ cells, would scale as $O(N^2)$, which is inefficient for large meshes. A more scalable, principle-based algorithm is to build a map from faces to the cells that contain them. This approach is as follows:\n\n1.  **Face-to-Cell Mapping**: We process the mesh to build a hash map, which we can denote as $M_{face \\to cell}$. The keys of this map are canonical representations of faces, and the values are lists of the indices of cells that contain each face.\n    - We iterate through each cell $c_i$ in the mesh, for cell index $i \\in \\{0, 1, \\dots, N-1\\}$.\n    - For each tetrahedron, defined by its $4$ vertex indices $\\{v_1, v_2, v_3, v_4\\}$, we generate its $4$ triangular faces. These are the sets of vertices $\\{v_1, v_2, v_3\\}$, $\\{v_1, v_2, v_4\\}$, $\\{v_1, v_3, v_4\\}$, and $\\{v_2, v_3, v_4\\}$.\n    - To uniquely identify each face regardless of vertex ordering, we define a canonical representation. A face with vertex indices $\\{u, v, w\\}$ is canonized by sorting its indices in ascending order, resulting in a tuple, e.g., $(\\min(u,v,w), \\text{median}(u,v,w), \\max(u,v,w))$.\n    - For each canonical face $f$, we append the current cell index $i$ to the list associated with key $f$ in our map $M_{face \\to cell}$.\n\n2.  **Adjacency Graph Construction**: After a single pass through all cells, the $M_{face \\to cell}$ map is fully populated. We then iterate through the values of this map to build the adjacency graph.\n    - A face is shared if its corresponding list of cell indices in $M_{face \\to cell}$ has a length greater than $1$. Let such a list be $[i_1, i_2, \\dots, i_k]$ for a shared face $f_s$.\n    - If $k=2$, the cells $c_{i_1}$ and $c_{i_2}$ are adjacent. This is the standard manifold case.\n    - If $k>2$, the face is non-manifold. The problem specifies that all cells sharing this face are mutually adjacent. This means we must establish a pairwise adjacency between all cells in the list $[i_1, i_2, \\dots, i_k]$.\n    - We construct an adjacency list, which is an array of sets, say `adj`, of size $N$. For each pair of distinct cell indices $(i_a, i_b)$ found to be adjacent, we add $i_b$ to the set `adj`$[i_a]$ and $i_a$ to the set `adj`$[i_b]$. Using sets automatically handles potential duplicate adjacencies without extra logic.\n\n3.  **CSR Representation and Average Stencil Size Calculation**: Once the adjacency list is finalized, we can determine the degree $d_i$ for each cell $i$ as the size of its adjacency set, $d_i = |\\text{adj}[i]|$.\n    - The problem directs us to construct the Compressed Sparse Row (CSR) representation of the $N \\times N$ cell adjacency matrix. The CSR format includes a row pointer array $p$ of length $N+1$, a column indices array $j$, and a values array $x$. For an unweighted graph, all entries in $x$ are $1$.\n    - The row pointer array $p$ is defined by the recurrence:\n    $$ p[0] = 0 $$\n    $$ p[k] = p[k-1] + d_{k-1} \\quad \\text{for } k \\in \\{1, \\dots, N\\} $$\n    This implies that $p[k] = \\sum_{l=0}^{k-1} d_l$.\n    - The total number of non-zero entries in the adjacency matrix, denoted as $\\text{NNZ}$, is the sum of all cell degrees: $\\text{NNZ} = \\sum_{i=0}^{N-1} d_i$. From the definition of the $p$ array, this sum is exactly $p[N]$.\n    - The average stencil size, $\\bar{d}$, is the average cell degree, given by the formula:\n    $$ \\bar{d} = \\frac{1}{N} \\sum_{i=0}^{N-1} d_i $$\n    - By calculating the sum of degrees as $\\sum_{i=0}^{N-1} d_i$, which is equivalent to computing the value of $p[N]$ in the CSR structure, we directly obtain the numerator for the average stencil size. The average is then simply $\\frac{\\text{NNZ}}{N}$. The column index array $j$ and value array $x$ need not be explicitly stored to find this average.\n\nThis algorithm correctly formalizes the provided definitions, handles the specified edge cases such as non-manifold connectivities, and provides a clear path to computing the required average stencil size for each mesh.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (single isolated cell)\n        [(0, 1, 2, 3)],\n        # Test 2 (two cells sharing a face)\n        [(0, 1, 2, 3), (0, 1, 2, 4)],\n        # Test 3 (three cells in a chain via faces)\n        [(0, 1, 2, 3), (1, 2, 3, 4), (1, 3, 4, 5)],\n        # Test 4 (non-manifold face shared by three cells)\n        [(0, 1, 2, 3), (0, 1, 2, 4), (0, 1, 2, 5)],\n        # Test 5 (two cells sharing only an edge)\n        [(0, 1, 2, 3), (0, 1, 4, 5)],\n    ]\n\n    results = []\n    for mesh_cells in test_cases:\n        avg_stencil_size = compute_average_stencil_size(mesh_cells)\n        # Format the result to six decimal places\n        results.append(f\"{avg_stencil_size:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_average_stencil_size(cells):\n    \"\"\"\n    Computes the average stencil size for a given tetrahedral mesh.\n\n    The method involves:\n    1. Mapping each canonical face to the list of cells that contain it.\n    2. Building an adjacency graph based on shared faces.\n    3. Calculating cell degrees and their average.\n    \"\"\"\n    N = len(cells)\n    if N == 0:\n        return 0.0\n\n    # Step 1: Build a map from canonical faces to the cell indices that own them.\n    face_to_cells = defaultdict(list)\n    for i, cell_vertices in enumerate(cells):\n        # A tetrahedron has 4 faces, each being a combination of 3 vertices.\n        for face in combinations(cell_vertices, 3):\n            # A canonical representation is created by sorting vertex indices.\n            # This ensures that the face is identified uniquely, regardless of vertex order.\n            canonical_face = tuple(sorted(face))\n            face_to_cells[canonical_face].append(i)\n\n    # Step 2: Construct the adjacency list from the face-to-cell map.\n    # An adjacency list is represented as a list of sets.\n    adj = [set() for _ in range(N)]\n    for face, sharing_cells in face_to_cells.items():\n        # If more than one cell contains the face, they are adjacent.\n        if len(sharing_cells) > 1:\n            # Per the problem, all cells sharing a face are mutually adjacent.\n            # We generate all unique pairs of cells from the list.\n            for c1, c2 in combinations(sharing_cells, 2):\n                # Add edges to represent adjacency. Using sets handles duplicates automatically.\n                adj[c1].add(c2)\n                adj[c2].add(c1)\n\n    # Step 3: Compute the degrees of all cells. The degree of a cell is its stencil size.\n    degrees = np.array([len(neighbors) for neighbors in adj])\n    \n    # Step 4: Calculate the total number of adjacencies (NNZ in the adjacency matrix).\n    # This sum corresponds to the final entry p[N] of the CSR row pointer array.\n    nnz = np.sum(degrees)\n    \n    # Step 5: Compute the average stencil size.\n    if N > 0:\n        avg_size = nnz / N\n    else:\n        avg_size = 0.0\n        \n    return avg_size\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond simply establishing connectivity, the geometric quality of a mesh profoundly impacts the accuracy and stability of a CFD solution. A key operation where this impact is felt is in the reconstruction of gradients, which are essential for calculating diffusive fluxes and other spatial derivatives. This practice delves into the numerical analysis of the least-squares gradient reconstruction method by framing it as a linear algebra problem, allowing you to quantify how poor local point distributions lead to an ill-conditioned system and amplify numerical errors .",
            "id": "3998372",
            "problem": "Consider a two-dimensional, steady, inviscid scalar field $f(\\boldsymbol{x})$ that is sufficiently smooth to admit a first-order Taylor expansion about a point $\\boldsymbol{x}_{0}$. In the vicinity of $\\boldsymbol{x}_{0}$, suppose the values $f_{i}$ at $m$ neighboring points located at offsets $\\boldsymbol{r}_{i} = \\boldsymbol{x}_{i} - \\boldsymbol{x}_{0}$ are known. The least-squares gradient reconstruction seeks $\\boldsymbol{g} \\approx \\nabla f(\\boldsymbol{x}_{0})$ by minimizing $\\sum_{i=1}^{m} \\left( b_{i} - \\boldsymbol{g} \\cdot \\boldsymbol{r}_{i} \\right)^{2}$, where $b_{i} = f_{i} - f_{0}$ and $f_{0} = f(\\boldsymbol{x}_{0})$. This is a standard approach in Computational Fluid Dynamics (CFD) on unstructured and hybrid grids for gradient estimation.\n\nDefine the $m \\times 2$ design matrix $A$ whose $i$-th row is $\\boldsymbol{r}_{i}^{\\top}$, and consider the unweighted least-squares problem with the $2$-norm. The normal equations are $(A^{\\top} A)\\boldsymbol{g} = A^{\\top} \\boldsymbol{b}$, where $\\boldsymbol{b} = [b_{1}, \\dots, b_{m}]^{\\top}$. Let the $2$-norm condition number of $A$ be $\\kappa_{2}(A) = \\sigma_{\\max}(A)/\\sigma_{\\min}(A)$, where $\\sigma_{\\max}(A)$ and $\\sigma_{\\min}(A)$ are the largest and smallest singular values of $A$. Treat $\\kappa_{2}(A)$ as a mesh-quality metric for gradient reconstruction.\n\nStarting from the Taylor expansion and the least-squares formulation above, derive a normwise bound showing how perturbations $\\delta \\boldsymbol{b}$ in $\\boldsymbol{b}$ can amplify into reconstruction errors $\\delta \\boldsymbol{g}$ in $\\boldsymbol{g}$, and demonstrate explicitly how a larger $\\kappa_{2}(A)$ leads to a larger worst-case amplification factor. Then, for two local point distributions around $\\boldsymbol{x}_{0}$ drawn from different grid topologies:\n\n1. A well-distributed, structured-like patch with neighbors at offsets\n$$\n\\boldsymbol{r}_{1} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix},\\quad\n\\boldsymbol{r}_{2} = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix},\\quad\n\\boldsymbol{r}_{3} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix},\\quad\n\\boldsymbol{r}_{4} = \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}.\n$$\n\n2. A poorly distributed, unstructured/hybrid patch with three nearly collinear neighbors and one near-axial neighbor at offsets\n$$\n\\boldsymbol{r}_{1} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix},\\quad\n\\boldsymbol{r}_{2} = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix},\\quad\n\\boldsymbol{r}_{3} = \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix},\\quad\n\\boldsymbol{r}_{4} = \\begin{pmatrix} 0 \\\\ \\varepsilon \\end{pmatrix},\n$$\nwith $\\varepsilon = 0.2$.\n\nAssuming the same relative level of measurement noise $||\\delta \\boldsymbol{b}||_{2}/||\\boldsymbol{b}||_{2}$ in both patches and neglecting perturbations in $A$, compute the ratio of the worst-case normwise bound on the gradient reconstruction error for the poorly distributed patch to that for the well-distributed patch. Express your final answer as a single real number rounded to four significant figures. No units are needed.",
            "solution": "The problem asks us to first derive a normwise error bound for a least-squares gradient reconstruction problem and then use it to compare the numerical stability of the reconstruction on two different point distributions, representing different grid topologies.\n\nFirst, we address the derivation of the error bound. The problem is to find the gradient $\\boldsymbol{g} \\in \\mathbb{R}^2$ that minimizes the sum of squared residuals, which can be written in matrix form as minimizing $\\|\\boldsymbol{b} - A\\boldsymbol{g}\\|_2^2$. Here, $A$ is the $m \\times 2$ design matrix with rows $\\boldsymbol{r}_i^\\top$, and $\\boldsymbol{b}$ is the vector of function value differences $f_i - f_0$. The solution to this least-squares problem is given by the normal equations:\n$$ (A^\\top A)\\boldsymbol{g} = A^\\top \\boldsymbol{b} $$\nSince we are dealing with spatial distributions of points, for a meaningful gradient to be reconstructed, the points cannot be collinear. This implies that the columns of $A$ are linearly independent, and the $2 \\times 2$ matrix $A^\\top A$ is invertible. Thus, the gradient is found as:\n$$ \\boldsymbol{g} = (A^\\top A)^{-1} A^\\top \\boldsymbol{b} $$\nThe matrix $(A^\\top A)^{-1} A^\\top$ is the Moore-Penrose pseudoinverse of $A$, denoted $A^+$.\n\nNow, let us consider the effect of a perturbation $\\delta\\boldsymbol{b}$ in the measurement vector $\\boldsymbol{b}$. The problem states to neglect perturbations in $A$. The perturbed system yields a new gradient estimate $\\boldsymbol{g} + \\delta\\boldsymbol{g}$:\n$$ \\boldsymbol{g} + \\delta\\boldsymbol{g} = A^+ (\\boldsymbol{b} + \\delta\\boldsymbol{b}) $$\nSubtracting the unperturbed solution $\\boldsymbol{g} = A^+ \\boldsymbol{b}$ from this equation gives the error in the gradient, $\\delta\\boldsymbol{g}$:\n$$ \\delta\\boldsymbol{g} = A^+ \\delta\\boldsymbol{b} $$\nTo find a bound on the magnitude of this error, we take the vector $2$-norm of both sides:\n$$ \\|\\delta\\boldsymbol{g}\\|_2 = \\|A^+ \\delta\\boldsymbol{b}\\|_2 $$\nUsing the property of induced matrix norms, we have:\n$$ \\|\\delta\\boldsymbol{g}\\|_2 \\le \\|A^+\\|_2 \\|\\delta\\boldsymbol{b}\\|_2 $$\nThe $2$-norm of the pseudoinverse, $\\|A^+\\|_2$, is equal to the reciprocal of the smallest singular value of $A$, $\\sigma_{\\min}(A)$. Thus, the absolute error bound is:\n$$ \\|\\delta\\boldsymbol{g}\\|_2 \\le \\frac{1}{\\sigma_{\\min}(A)} \\|\\delta\\boldsymbol{b}\\|_2 $$\nTo find the relative error bound, we need to bound $\\|\\boldsymbol{g}\\|_2$ from below. The least-squares solution $\\boldsymbol{g}$ projects $\\boldsymbol{b}$ onto the column space of $A$. That is, $A\\boldsymbol{g} = \\text{proj}_{\\text{col}(A)}(\\boldsymbol{b})$. It follows that $\\|A\\boldsymbol{g}\\|_2 \\le \\|\\boldsymbol{b}\\|_2$. From the definition of the matrix norm, we have $\\|A\\boldsymbol{g}\\|_2 \\le \\|A\\|_2 \\|\\boldsymbol{g}\\|_2$. The $2$-norm of $A$, $\\|A\\|_2$, is its largest singular value, $\\sigma_{\\max}(A)$. So,\n$$ \\|A\\boldsymbol{g}\\|_2 \\le \\sigma_{\\max}(A) \\|\\boldsymbol{g}\\|_2 \\implies \\|\\boldsymbol{g}\\|_2 \\ge \\frac{\\|A\\boldsymbol{g}\\|_2}{\\sigma_{\\max}(A)} $$\nCombining the bounds for $\\|\\delta\\boldsymbol{g}\\|_2$ and $\\|\\boldsymbol{g}\\|_2$, we get the relative error bound:\n$$ \\frac{\\|\\delta\\boldsymbol{g}\\|_2}{\\|\\boldsymbol{g}\\|_2} \\le \\frac{\\|\\delta\\boldsymbol{b}\\|_2 / \\sigma_{\\min}(A)}{\\|A\\boldsymbol{g}\\|_2 / \\sigma_{\\max}(A)} = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)} \\frac{\\|\\delta\\boldsymbol{b}\\|_2}{\\|A\\boldsymbol{g}\\|_2} $$\nDefining the $2$-norm condition number as $\\kappa_2(A) = \\sigma_{\\max}(A) / \\sigma_{\\min}(A)$, the bound is:\n$$ \\frac{\\|\\delta\\boldsymbol{g}\\|_2}{\\|\\boldsymbol{g}\\|_2} \\le \\kappa_2(A) \\frac{\\|\\delta\\boldsymbol{b}\\|_2}{\\|A\\boldsymbol{g}\\|_2} $$\nThe vector $A\\boldsymbol{g}$ is the component of $\\boldsymbol{b}$ in the column space of $A$. The first-order Taylor expansion gives $b_i = f_i - f_0 \\approx \\nabla f(\\boldsymbol{x}_0) \\cdot \\boldsymbol{r}_i$. If the higher-order terms are negligible, then $\\boldsymbol{b} \\approx A\\boldsymbol{g}$, which implies $\\|A\\boldsymbol{g}\\|_2 \\approx \\|\\boldsymbol{b}\\|_2$. In this case, the bound simplifies to:\n$$ \\frac{\\|\\delta\\boldsymbol{g}\\|_2}{\\|\\boldsymbol{g}\\|_2} \\lesssim \\kappa_2(A) \\frac{\\|\\delta\\boldsymbol{b}\\|_2}{\\|\\boldsymbol{b}\\|_2} $$\nThis shows that $\\kappa_2(A)$ acts as the worst-case amplification factor for the relative error in $\\boldsymbol{b}$ propagating to a relative error in $\\boldsymbol{g}$. A larger $\\kappa_2(A)$ implies a more ill-conditioned problem, where small input errors can lead to large output errors. The ratio of the worst-case bounds for the two patches, assuming the same relative noise level, is therefore the ratio of their respective condition numbers.\n\nNow, we compute this ratio for the two given cases.\n\nCase 1: Well-distributed, structured-like patch.\nThe neighbor offsets are $\\boldsymbol{r}_{1} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$, $\\boldsymbol{r}_{2} = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}$, $\\boldsymbol{r}_{3} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$, $\\boldsymbol{r}_{4} = \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}$.\nThe design matrix $A_1$ is:\n$$ A_1 = \\begin{pmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 0 & 1 \\\\ 0 & -1 \\end{pmatrix} $$\nThe singular values of $A_1$ are the square roots of the eigenvalues of $A_1^\\top A_1$.\n$$ A_1^\\top A_1 = \\begin{pmatrix} 1 & -1 & 0 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 0 & 1 \\\\ 0 & -1 \\end{pmatrix} = \\begin{pmatrix} 1^2 + (-1)^2 & 0 \\\\ 0 & 1^2 + (-1)^2 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix} $$\nThe eigenvalues of $A_1^\\top A_1$ are $\\lambda_1 = 2$ and $\\lambda_2 = 2$.\nThe singular values of $A_1$ are $\\sigma_{\\max}(A_1) = \\sqrt{2}$ and $\\sigma_{\\min}(A_1) = \\sqrt{2}$.\nThe condition number for the well-distributed patch is:\n$$ \\kappa_2(A_1) = \\frac{\\sigma_{\\max}(A_1)}{\\sigma_{\\min}(A_1)} = \\frac{\\sqrt{2}}{\\sqrt{2}} = 1 $$\n\nCase 2: Poorly distributed, unstructured/hybrid patch.\nThe neighbor offsets are $\\boldsymbol{r}_{1} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$, $\\boldsymbol{r}_{2} = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}$, $\\boldsymbol{r}_{3} = \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix}$, $\\boldsymbol{r}_{4} = \\begin{pmatrix} 0 \\\\ \\varepsilon \\end{pmatrix}$, with $\\varepsilon = 0.2$.\nThe design matrix $A_2$ is:\n$$ A_2 = \\begin{pmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 2 & 0 \\\\ 0 & 0.2 \\end{pmatrix} $$\nWe compute $A_2^\\top A_2$:\n$$ A_2^\\top A_2 = \\begin{pmatrix} 1 & -1 & 2 & 0 \\\\ 0 & 0 & 0 & 0.2 \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 2 & 0 \\\\ 0 & 0.2 \\end{pmatrix} = \\begin{pmatrix} 1^2 + (-1)^2 + 2^2 & 0 \\\\ 0 & (0.2)^2 \\end{pmatrix} = \\begin{pmatrix} 1+1+4 & 0 \\\\ 0 & 0.04 \\end{pmatrix} = \\begin{pmatrix} 6 & 0 \\\\ 0 & 0.04 \\end{pmatrix} $$\nThe eigenvalues of $A_2^\\top A_2$ are $\\lambda_1 = 6$ and $\\lambda_2 = 0.04$.\nThe singular values of $A_2$ are $\\sigma_{\\max}(A_2) = \\sqrt{6}$ and $\\sigma_{\\min}(A_2) = \\sqrt{0.04} = 0.2$.\nThe condition number for the poorly distributed patch is:\n$$ \\kappa_2(A_2) = \\frac{\\sigma_{\\max}(A_2)}{\\sigma_{\\min}(A_2)} = \\frac{\\sqrt{6}}{0.2} $$\n\nFinally, we compute the ratio of the worst-case normwise bound for the poorly distributed patch to that for the well-distributed patch. This is the ratio of their condition numbers.\n$$ \\text{Ratio} = \\frac{\\kappa_2(A_2)}{\\kappa_2(A_1)} = \\frac{\\sqrt{6} / 0.2}{1} = \\frac{\\sqrt{6}}{0.2} $$\nNow we calculate the numerical value:\n$$ \\text{Ratio} \\approx \\frac{2.44948974}{0.2} = 12.2474487 $$\nRounding to four significant figures, the ratio is $12.25$. This result quantitatively demonstrates that the gradient reconstruction on the poorly distributed, nearly collinear set of points is over $12$ times more sensitive to noise in the input data than the reconstruction on the well-distributed, orthogonal-like set of points.",
            "answer": "$$ \\boxed{12.25} $$"
        },
        {
            "introduction": "Applying theoretical knowledge to practical design is a crucial skill in aerospace CFD, particularly in the art of hybrid meshing for viscous flows. This problem puts you in the role of a mesh designer tasked with creating a prism layer stack to resolve a turbulent boundary layer, a common and critical requirement for aerodynamic simulations. You will synthesize concepts from fluid dynamics, such as wall units like $y^+$, with numerical meshing constraints like cell growth rates and aspect ratios to build a high-quality near-wall mesh that meets the stringent demands of turbulence modeling .",
            "id": "3998390",
            "problem": "An advanced Computational Fluid Dynamics (CFD) hybrid mesh is to be generated for an incompressible, zero-pressure-gradient turbulent boundary layer (TBL) over a smooth flat plate at a streamwise location $x = 1.0\\,\\mathrm{m}$. The freestream speed is $U_{\\infty} = 100\\,\\mathrm{m/s}$, the air density is $\\rho = 1.2\\,\\mathrm{kg/m^3}$, and the dynamic viscosity is $\\mu = 1.8 \\times 10^{-5}\\,\\mathrm{kg/(m\\,s)}$. The near-wall region will be meshed with stacked prism layers of wall-normal thicknesses that follow a geometric progression with constant growth rate $g$ between adjacent layers. The wall-parallel discretization uses a uniform streamwise spacing within the prism stack equal to the wall value.\n\nThe design targets for wall units are $\\,\\Delta y^{+} = 1.0\\,$ and $\\,\\Delta x^{+} = 40\\,$, and the maximum acceptable cell aspect ratio (defined as wall-parallel length divided by wall-normal thickness) is $\\mathrm{AR}_{\\max} = 150$. The prism layer growth rate is constrained by $g \\leq g_{\\max}$ with $g_{\\max} = 1.20$. The total prism stack height must cover a fraction $f = 0.80$ of the local turbulent boundary layer thickness $\\,\\delta\\,$ at the given $x$.\n\nUse the following widely accepted correlations for a zero-pressure-gradient turbulent flat-plate boundary layer at high Reynolds number:\n- Skin-friction coefficient correlation: $C_{f}(x) = 0.026 \\, \\mathrm{Re}_{x}^{-1/7}$, where $\\mathrm{Re}_{x} = \\frac{\\rho U_{\\infty} x}{\\mu}$.\n- Boundary layer thickness correlation: $\\frac{\\delta}{x} = 0.37 \\, \\mathrm{Re}_{x}^{-1/5}$.\n\nUse the standard definitions of wall units: $y^{+} = \\frac{y \\, u_{\\tau}}{\\nu}$ and $x^{+} = \\frac{x \\, u_{\\tau}}{\\nu}$, where $u_{\\tau} = \\sqrt{\\tau_{w}/\\rho}$ is the friction velocity and $\\nu = \\mu/\\rho$ is the kinematic viscosity. Relate $u_{\\tau}$ to $C_{f}$ via $C_{f} = \\frac{\\tau_{w}}{\\frac{1}{2} \\rho U_{\\infty}^{2}}$.\n\nAssume the worst-case aspect ratio within the prism stack occurs at the first layer (smallest wall-normal thickness), and use $g = g_{\\max}$ to minimize the number of layers while satisfying the growth-rate constraint. Compute the minimal integer number of prism layers $N$ such that:\n- The total prism height $H_{N}$ obtained by summing the geometric progression of layer thicknesses starting from the first-layer height set by $\\,\\Delta y^{+}\\,$ is at least $f \\, \\delta$.\n- The aspect ratio constraint $\\mathrm{AR} \\leq \\mathrm{AR}_{\\max}$ is respected.\n\nReport the minimal integer $N$. Do not round to any number of significant figures; provide the integer value only.",
            "solution": "The problem requires finding the minimal integer number of prism layers, $N$, for a computational fluid dynamics (CFD) mesh in a turbulent boundary layer. The solution involves calculating the physical properties of the boundary layer and then using them to determine the geometric properties of the mesh according to the specified constraints.\n\nFirst, we determine the flow's characteristic non-dimensional number, the Reynolds number, at the specified location $x=1.0\\,\\mathrm{m}$. The kinematic viscosity, $\\nu$, is the ratio of dynamic viscosity, $\\mu$, to density, $\\rho$.\nGiven $\\rho = 1.2\\,\\mathrm{kg/m^3}$ and $\\mu = 1.8 \\times 10^{-5}\\,\\mathrm{kg/(m\\,s)}$:\n$$ \\nu = \\frac{\\mu}{\\rho} = \\frac{1.8 \\times 10^{-5}\\,\\mathrm{kg/(m\\,s)}}{1.2\\,\\mathrm{kg/m^3}} = 1.5 \\times 10^{-5}\\,\\mathrm{m^2/s} $$\nThe Reynolds number at $x$, $\\mathrm{Re}_x$, is calculated using the freestream velocity $U_{\\infty} = 100\\,\\mathrm{m/s}$:\n$$ \\mathrm{Re}_{x} = \\frac{U_{\\infty} x}{\\nu} = \\frac{(100\\,\\mathrm{m/s})(1.0\\,\\mathrm{m})}{1.5 \\times 10^{-5}\\,\\mathrm{m^2/s}} = \\frac{2}{3} \\times 10^7 \\approx 6.67 \\times 10^6 $$\n\nWith the Reynolds number, we can find the boundary layer properties using the provided empirical correlations.\nThe skin-friction coefficient, $C_f$, is:\n$$ C_{f} = 0.026 \\, \\mathrm{Re}_{x}^{-1/7} = 0.026 \\left(\\frac{2}{3} \\times 10^7\\right)^{-1/7} \\approx 0.0027424 $$\nThe wall shear stress, $\\tau_w$, is related to $C_f$ by its definition:\n$$ \\tau_{w} = C_{f} \\cdot \\frac{1}{2} \\rho U_{\\infty}^{2} \\approx 0.0027424 \\times \\frac{1}{2} \\times (1.2\\,\\mathrm{kg/m^3}) \\times (100\\,\\mathrm{m/s})^2 \\approx 16.454\\,\\mathrm{Pa} $$\nFrom $\\tau_w$, we compute the friction velocity, $u_{\\tau}$:\n$$ u_{\\tau} = \\sqrt{\\frac{\\tau_{w}}{\\rho}} = \\sqrt{\\frac{16.454\\,\\mathrm{Pa}}{1.2\\,\\mathrm{kg/m^3}}} \\approx 3.703\\,\\mathrm{m/s} $$\n\nNext, we calculate the boundary layer thickness, $\\delta$, at $x=1.0\\,\\mathrm{m}$:\n$$ \\delta = 0.37 \\, x \\, \\mathrm{Re}_{x}^{-1/5} = 0.37 \\times (1.0\\,\\mathrm{m}) \\times \\left(\\frac{2}{3} \\times 10^7\\right)^{-1/5} \\approx 0.01597\\,\\mathrm{m} $$\nThe total height of the prism layer stack, $H_{target}$, must cover a fraction $f=0.80$ of this thickness:\n$$ H_{target} = f \\cdot \\delta = 0.80 \\times 0.01597\\,\\mathrm{m} \\approx 0.01278\\,\\mathrm{m} $$\n\nNow, we determine the dimensions of the first mesh layer near the wall. The wall-normal thickness of the first layer, $\\Delta y_1$, is derived from the requirement that its height in wall units, $\\Delta y^{+}$, is $1.0$:\n$$ \\Delta y^{+} = \\frac{\\Delta y_1 u_{\\tau}}{\\nu} = 1.0 $$\n$$ \\Delta y_1 = \\frac{1.0 \\cdot \\nu}{u_{\\tau}} = \\frac{1.5 \\times 10^{-5}\\,\\mathrm{m^2/s}}{3.703\\,\\mathrm{m/s}} \\approx 4.051 \\times 10^{-6}\\,\\mathrm{m} $$\n\nWe must check the aspect ratio constraint, $\\mathrm{AR} \\le \\mathrm{AR}_{\\max} = 150$. The wall-parallel cell dimension, $\\Delta x_{cell}$, is set by the requirement $\\Delta x^{+} = 40$:\n$$ \\Delta x^{+} = \\frac{\\Delta x_{cell} u_{\\tau}}{\\nu} = 40 $$\n$$ \\Delta x_{cell} = \\frac{40 \\cdot \\nu}{u_{\\tau}} = 40 \\cdot \\Delta y_1 $$\nThe aspect ratio for the first layer, $\\mathrm{AR}_1$, which is assumed to be the maximum, is:\n$$ \\mathrm{AR}_1 = \\frac{\\Delta x_{cell}}{\\Delta y_1} = \\frac{40 \\cdot \\Delta y_1}{\\Delta y_1} = 40 $$\nSince $40 < 150$, the aspect ratio constraint is satisfied.\n\nFinally, we find the minimum number of layers, $N$. The layer thicknesses follow a geometric progression, $\\Delta y_k = \\Delta y_1 g^{k-1}$, with a growth rate $g = 1.20$. The total height of $N$ layers, $H_N$, is the sum of this series:\n$$ H_N = \\sum_{k=1}^{N} \\Delta y_1 g^{k-1} = \\Delta y_1 \\frac{g^N - 1}{g - 1} $$\nWe must satisfy the condition $H_N \\geq H_{target}$:\n$$ \\Delta y_1 \\frac{g^N - 1}{g - 1} \\geq f \\delta $$\nSubstituting the evaluated quantities:\n$$ (4.051 \\times 10^{-6}\\,\\mathrm{m}) \\frac{1.2^N - 1}{1.2 - 1} \\geq 0.01278\\,\\mathrm{m} $$\n$$ \\frac{1.2^N - 1}{0.2} \\geq \\frac{0.01278}{4.051 \\times 10^{-6}} \\approx 3155 $$\n$$ 1.2^N - 1 \\geq 0.2 \\times 3155 = 631 $$\n$$ 1.2^N \\geq 632 $$\nTo solve for $N$, we apply the natural logarithm to both sides of the inequality:\n$$ N \\ln(1.2) \\geq \\ln(632) $$\n$$ N \\geq \\frac{\\ln(632)}{\\ln(1.2)} \\approx \\frac{6.4489}{0.18232} \\approx 35.37 $$\nSince the number of layers $N$ must be an integer, we take the smallest integer value greater than or equal to $35.37$, which is the ceiling of the result.\n$$ N = \\lceil 35.37 \\rceil = 36 $$\nThus, a minimum of $36$ prism layers are needed to satisfy the specified design criteria.",
            "answer": "$$\\boxed{36}$$"
        }
    ]
}