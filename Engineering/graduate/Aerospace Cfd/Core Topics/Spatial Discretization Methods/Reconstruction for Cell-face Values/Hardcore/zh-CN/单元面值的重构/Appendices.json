{
    "hands_on_practices": [
        {
            "introduction": "为了在有限体积法中实现超越一阶的精度，我们必须估算每个单元内部解的梯度。这个练习将引导您完成一个核心计算任务：使用加权最小二乘法，根据一个非结构化网格单元及其相邻单元的平均值来计算该单元的梯度。掌握这项技能是构建任何二阶或更高阶格式的基础，它让您能从离散的平均值数据中重构出连续的线性分布。",
            "id": "3989902",
            "problem": "在计算流体力学（CFD）的以单元为中心的有限体积法中，标量场的二阶界面重构依赖于围绕单元中心进行泰勒级数展开得到的局部线性近似。考虑一个索引为单元 $i$ 的非结构化三角形控制体，其中心坐标为 $\\boldsymbol{x}_i = (0, 0)$，无量纲标量场的单元平均值为 $\\phi_i = 2$。穿过单元 $i$ 每个面的三个相邻单元的中心和单元平均值由下式给出\n$$\n\\boldsymbol{x}_{j_1} = (1, 0), \\quad \\phi_{j_1} = 5, \\qquad\n\\boldsymbol{x}_{j_2} = (0, 1), \\quad \\phi_{j_2} = 1, \\qquad\n\\boldsymbol{x}_{j_3} = (-1, -1), \\quad \\phi_{j_3} = 0.\n$$\n为了获得一致的线性重构，通过对一阶泰勒展开式进行加权最小二乘拟合来近似单元 $i$ 处的梯度，\n$$\n\\phi(\\boldsymbol{x}_i + \\boldsymbol{r}_j) \\approx \\phi_i + \\nabla \\phi_i \\cdot \\boldsymbol{r}_j,\n$$\n其中 $\\boldsymbol{r}_j = \\boldsymbol{x}_j - \\boldsymbol{x}_i$，权重选择为 $w_j = \\frac{1}{\\|\\boldsymbol{r}_j\\|^2}$。使用此梯度，通过线性关系式\n$$\n\\phi_f \\approx \\phi_i + \\nabla \\phi_i \\cdot (\\boldsymbol{x}_f - \\boldsymbol{x}_i).\n$$\n来重构位于单元 $i$ 某个面上指定界面中心 $\\boldsymbol{x}_f = (0.45, -0.1)$ 处的标量值。\n根据给定数据明确计算重构的界面值 $\\phi_f$。将最终答案表示为一个无量纲数，并四舍五入到四位有效数字。",
            "solution": "目标是计算界面中心 $\\boldsymbol{x}_f = (0.45, -0.1)$ 处的重构标量值 $\\phi_f$。这需要一个两步过程：\n1.  使用加权最小二乘法计算单元 $i$ 中心处的标量场梯度 $\\nabla \\phi_i$。\n2.  在一阶泰勒级数展开式中使用此梯度，将值从单元中心 $\\boldsymbol{x}_i$ 外推到界面中心 $\\boldsymbol{x}_f$。\n\n设单元 $i$ 处的梯度向量表示为 $\\nabla \\phi_i = \\boldsymbol{g} = \\begin{pmatrix} g_x \\\\ g_y \\end{pmatrix}$。相对于单元 $i$，在相邻单元中心 $\\boldsymbol{x}_j$ 处的标量值 $\\phi_j$ 的一阶泰勒展开式为\n$$\n\\phi_j \\approx \\phi_i + \\nabla \\phi_i \\cdot (\\boldsymbol{x}_j - \\boldsymbol{x}_i)\n$$\n整理此式可得到标量值之差的表达式：\n$$\n\\phi_j - \\phi_i \\approx \\boldsymbol{g} \\cdot \\boldsymbol{r}_j\n$$\n其中 $\\boldsymbol{r}_j = \\boldsymbol{x}_j - \\boldsymbol{x}_i$ 是从中心 $i$ 到中心 $j$ 的向量。\n\n加权最小二乘法旨在找到一个梯度 $\\boldsymbol{g}$，使得在 $N=3$ 个相邻单元集合上的加权残差平方和最小。要最小化的目标函数是：\n$$\nS(g_x, g_y) = \\sum_{j=1}^{N} w_j \\left( (\\phi_j - \\phi_i) - (g_x r_{jx} + g_y r_{jy}) \\right)^2\n$$\n其中 $w_j = \\frac{1}{\\|\\boldsymbol{r}_j\\|^2}$ 是指定的权重。\n\n为了最小化 $S$，我们对 $g_x$ 和 $g_y$ 求偏导数并令其为零：\n$$\n\\frac{\\partial S}{\\partial g_x} = 0, \\quad \\frac{\\partial S}{\\partial g_y} = 0\n$$\n这导出了正规方程组，可以写成矩阵形式 $A \\boldsymbol{g} = \\boldsymbol{b}$，其中：\n$$\nA = \\begin{pmatrix} \\sum_{j=1}^N w_j r_{jx}^2 & \\sum_{j=1}^N w_j r_{jx} r_{jy} \\\\ \\sum_{j=1}^N w_j r_{jx} r_{jy} & \\sum_{j=1}^N w_j r_{jy}^2 \\end{pmatrix}, \\quad \\boldsymbol{b} = \\begin{pmatrix} \\sum_{j=1}^N w_j (\\phi_j - \\phi_i) r_{jx} \\\\ \\sum_{j=1}^N w_j (\\phi_j - \\phi_i) r_{jy} \\end{pmatrix}\n$$\n\n首先，我们处理给定的数据。中心单元是 $i$，其 $\\boldsymbol{x}_i = (0, 0)$ 且 $\\phi_i = 2$。令 $\\Delta\\phi_j = \\phi_j - \\phi_i$。\n\n对于相邻单元 $j_1$：\n$\\boldsymbol{x}_{j_1} = (1, 0)$，$\\phi_{j_1} = 5$。\n$\\boldsymbol{r}_{j_1} = \\boldsymbol{x}_{j_1} - \\boldsymbol{x}_i = (1, 0)$。\n$\\Delta\\phi_{j_1} = 5 - 2 = 3$。\n$\\|\\boldsymbol{r}_{j_1}\\|^2 = 1^2 + 0^2 = 1$，所以 $w_{j_1} = \\frac{1}{1} = 1$。\n\n对于相邻单元 $j_2$：\n$\\boldsymbol{x}_{j_2} = (0, 1)$，$\\phi_{j_2} = 1$。\n$\\boldsymbol{r}_{j_2} = \\boldsymbol{x}_{j_2} - \\boldsymbol{x}_i = (0, 1)$。\n$\\Delta\\phi_{j_2} = 1 - 2 = -1$。\n$\\|\\boldsymbol{r}_{j_2}\\|^2 = 0^2 + 1^2 = 1$，所以 $w_{j_2} = \\frac{1}{1} = 1$。\n\n对于相邻单元 $j_3$：\n$\\boldsymbol{x}_{j_3} = (-1, -1)$，$\\phi_{j_3} = 0$。\n$\\boldsymbol{r}_{j_3} = \\boldsymbol{x}_{j_3} - \\boldsymbol{x}_i = (-1, -1)$。\n$\\Delta\\phi_{j_3} = 0 - 2 = -2$。\n$\\|\\boldsymbol{r}_{j_3}\\|^2 = (-1)^2 + (-1)^2 = 2$，所以 $w_{j_3} = \\frac{1}{2}$。\n\n现在，我们构建矩阵 $A$：\n$A_{11} = \\sum w_j r_{jx}^2 = (1)(1^2) + (1)(0^2) + (\\frac{1}{2})(-1)^2 = 1 + 0 + \\frac{1}{2} = \\frac{3}{2}$。\n$A_{22} = \\sum w_j r_{jy}^2 = (1)(0^2) + (1)(1^2) + (\\frac{1}{2})(-1)^2 = 0 + 1 + \\frac{1}{2} = \\frac{3}{2}$。\n$A_{12} = A_{21} = \\sum w_j r_{jx} r_{jy} = (1)(1)(0) + (1)(0)(1) + (\\frac{1}{2})(-1)(-1) = 0 + 0 + \\frac{1}{2} = \\frac{1}{2}$。\n所以，矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix} \\frac{3}{2} & \\frac{1}{2} \\\\ \\frac{1}{2} & \\frac{3}{2} \\end{pmatrix}\n$$\n\n接下来，我们构建向量 $\\boldsymbol{b}$：\n$b_x = \\sum w_j \\Delta\\phi_j r_{jx} = (1)(3)(1) + (1)(-1)(0) + (\\frac{1}{2})(-2)(-1) = 3 + 0 + 1 = 4$。\n$b_y = \\sum w_j \\Delta\\phi_j r_{jy} = (1)(3)(0) + (1)(-1)(1) + (\\frac{1}{2})(-2)(-1) = 0 - 1 + 1 = 0$。\n所以，向量 $\\boldsymbol{b}$ 是：\n$$\n\\boldsymbol{b} = \\begin{pmatrix} 4 \\\\ 0 \\end{pmatrix}\n$$\n\n我们求解线性系统 $A \\boldsymbol{g} = \\boldsymbol{b}$：\n$$\n\\begin{pmatrix} \\frac{3}{2} & \\frac{1}{2} \\\\ \\frac{1}{2} & \\frac{3}{2} \\end{pmatrix} \\begin{pmatrix} g_x \\\\ g_y \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 0 \\end{pmatrix}\n$$\n这代表了以下方程组：\n1.  $\\frac{3}{2}g_x + \\frac{1}{2}g_y = 4$\n2.  $\\frac{1}{2}g_x + \\frac{3}{2}g_y = 0$\n\n从第二个方程，我们得到 $g_x = -3g_y$。将此代入第一个方程：\n$\\frac{3}{2}(-3g_y) + \\frac{1}{2}g_y = 4$\n$-\\frac{9}{2}g_y + \\frac{1}{2}g_y = 4$\n$-\\frac{8}{2}g_y = 4 \\implies -4g_y = 4 \\implies g_y = -1$。\n然后，$g_x = -3(-1) = 3$。\n计算出的梯度为 $\\nabla \\phi_i = \\boldsymbol{g} = \\begin{pmatrix} 3 \\\\ -1 \\end{pmatrix}$。\n\n最后，我们使用线性重构公式在界面中心 $\\boldsymbol{x}_f = (0.45, -0.1)$ 处重构该值：\n$$\n\\phi_f \\approx \\phi_i + \\nabla \\phi_i \\cdot (\\boldsymbol{x}_f - \\boldsymbol{x}_i)\n$$\n由于 $\\boldsymbol{x}_i = (0, 0)$，从单元中心指向界面中心的向量是 $\\boldsymbol{x}_f - \\boldsymbol{x}_i = (0.45, -0.1)$。\n代入已知值：\n$$\n\\phi_f \\approx 2 + \\begin{pmatrix} 3 \\\\ -1 \\end{pmatrix} \\cdot \\begin{pmatrix} 0.45 \\\\ -0.1 \\end{pmatrix}\n$$\n$$\n\\phi_f \\approx 2 + (3)(0.45) + (-1)(-0.1)\n$$\n$$\n\\phi_f \\approx 2 + 1.35 + 0.1\n$$\n$$\n\\phi_f \\approx 3.45\n$$\n问题要求答案四舍五入到四位有效数字。计算的精确结果是 $3.45$。为了用四位有效数字表示这个值，我们将其写为 $3.450$。",
            "answer": "$$\\boxed{3.450}$$"
        },
        {
            "introduction": "虽然高阶重构能提高解的精度，但它也可能在激波或接触间断等陡峭梯度附近引入非物理的振荡。为了解决这个问题，高分辨率格式采用了“斜率限制器”。在这个实践中，您将应用一个经典的单调中心（Monotonized Central, MC）限制器来调整重构斜率，以确保解的总变差不增（Total Variation Diminishing, TVD），从而在保持光滑区域高精度的同时抑制振荡。",
            "id": "3989867",
            "problem": "在计算流体动力学 (CFD) 中，考虑一维线性质量密度平流，该过程由标量守恒律 $ \\partial_t \\rho + a \\, \\partial_x \\rho = 0 $ 控制，其中 $ \\rho(x,t) $ 是质量密度，$ a $ 是恒定的平流速度。在均匀网格上的守恒型有限体积格式中，将宽度为 $ \\Delta x $ 的单元上的单元平均密度记为 $ \\bar{\\rho}_i $。为了获得一致的数值通量所需的高分辨率、无振荡的界面值，采用带有斜率限制器的分段线性重构，该限制器强制实现总变差递减 (TVD) 特性。\n\n使用 Monotonized Central (MC) 限制器，这是一种通过 $\\minmod$ 函数定义的 TVD 限制器。对于任意单元索引 $ i $，通过以下公式定义限制后的斜率 $ \\sigma_i $：\n$$\n\\sigma_i \\;=\\; \\minmod\\!\\Bigg( \\frac{\\bar{\\rho}_{i+1}-\\bar{\\rho}_{i-1}}{2\\,\\Delta x}, \\; \\frac{2\\,(\\bar{\\rho}_{i+1}-\\bar{\\rho}_i)}{\\Delta x}, \\; \\frac{2\\,(\\bar{\\rho}_i-\\bar{\\rho}_{i-1})}{\\Delta x} \\Bigg),\n$$\n其中，三参数的 $\\minmod$ 函数为：\n$$\n\\minmod(\\alpha,\\beta,\\gamma) \\;=\\;\n\\begin{cases}\n\\mathrm{sign}(\\alpha)\\,\\min\\!\\big(|\\alpha|,|\\beta|,|\\gamma|\\big),  &\\text{if } \\mathrm{sign}(\\alpha)=\\mathrm{sign}(\\beta)=\\mathrm{sign}(\\gamma), \\\\\n0,  &\\text{otherwise}.\n\\end{cases}\n$$\n通过分段线性重构，界面 $ x_{i+1/2} $ 处的左右状态为：\n$$\n\\rho_{i+1/2}^{-} \\;=\\; \\bar{\\rho}_i + \\sigma_i\\,\\frac{\\Delta x}{2}, \n\\qquad\n\\rho_{i+1/2}^{+} \\;=\\; \\bar{\\rho}_{i+1} - \\sigma_{i+1}\\,\\frac{\\Delta x}{2}.\n$$\n\n假设均匀网格的 $ \\Delta x = 0.02~\\mathrm{m} $，恒定平流速度 $ a = 240~\\mathrm{m/s} $，以及单元平均密度（单位为 $ \\mathrm{kg/m^3} $）为：\n$$\n\\bar{\\rho}_{i-2} = 1.24, \\quad \\bar{\\rho}_{i-1} = 1.21, \\quad \\bar{\\rho}_{i} = 1.15, \\quad \\bar{\\rho}_{i+1} = 1.10, \\quad \\bar{\\rho}_{i+2} = 1.095.\n$$\n\n从守恒律和界面通量的有限体积解释出发，应用 MC 限制器得到限制后的斜率 $ \\sigma_i $ 和 $ \\sigma_{i+1} $，重构左右界面状态 $ \\rho_{i+1/2}^{-} $ 和 $ \\rho_{i+1/2}^{+} $，然后使用线性平流的 Godunov 迎风通量来计算 $ x_{i+1/2} $ 处的质量通量：\n$$\nF_{i+1/2} \\;=\\; a \\times \n\\begin{cases}\n\\rho_{i+1/2}^{-},  &\\text{if } a > 0, \\\\\n\\rho_{i+1/2}^{+},  &\\text{if } a < 0.\n\\end{cases}\n$$\n\n提供 $ F_{i+1/2} $ 的最终数值，单位为 $ \\mathrm{kg\\,m^{-2}\\,s^{-1}} $。将您的答案四舍五入到四位有效数字。",
            "solution": "目标是计算计算单元 $i$ 和 $i+1$ 之间界面 $x_{i+1/2}$ 处的数值质量通量 $F_{i+1/2}$。这需要对密度场进行高分辨率的分段线性重构，并使用 Monotonized Central (MC) 限制器以确保总变差递减 (TVD) 特性。然后使用 Godunov 迎风格式确定通量。\n\n步骤如下：\n1.  计算单元 $i$ 的限制后斜率 $\\sigma_i$。\n2.  计算单元 $i+1$ 的限制后斜率 $\\sigma_{i+1}$。\n3.  分别重构界面左侧和右侧的密度值 $\\rho_{i+1/2}^{-}$ 和 $\\rho_{i+1/2}^{+}$。\n4.  根据平流速度 $a$ 的符号选择迎风密度。\n5.  计算质量通量 $F_{i+1/2}$。\n\n所提供的数据如下：\n-   单元平均密度：$\\bar{\\rho}_{i-2} = 1.24$, $\\bar{\\rho}_{i-1} = 1.21$, $\\bar{\\rho}_{i} = 1.15$, $\\bar{\\rho}_{i+1} = 1.10$, $\\bar{\\rho}_{i+2} = 1.095$。请注意，所有单位均为 $\\mathrm{kg/m^3}$。\n-   单元宽度：$\\Delta x = 0.02~\\mathrm{m}$。\n-   平流速度：$a = 240~\\mathrm{m/s}$。\n\n**第1步：计算限制后的斜率 $\\sigma_i$**\n\n限制后的斜率 $\\sigma_i$ 由 MC 限制器定义：\n$$\n\\sigma_i = \\minmod(\\alpha_i, \\beta_i, \\gamma_i)\n$$\n其中参数是中心、向前和向后差分斜率（后两者乘以因子 $2$）：\n$$\n\\alpha_i = \\frac{\\bar{\\rho}_{i+1}-\\bar{\\rho}_{i-1}}{2\\,\\Delta x}\n$$\n$$\n\\beta_i = \\frac{2\\,(\\bar{\\rho}_{i+1}-\\bar{\\rho}_i)}{\\Delta x}\n$$\n$$\n\\gamma_i = \\frac{2\\,(\\bar{\\rho}_i-\\bar{\\rho}_{i-1})}{\\Delta x}\n$$\n我们使用给定值计算每个参数：\n-   中心斜率：\n    $$\n    \\alpha_i = \\frac{1.10 - 1.21}{2 \\times 0.02} = \\frac{-0.11}{0.04} = -2.75\n    $$\n-   前偏斜率：\n    $$\n    \\beta_i = \\frac{2\\,(1.10 - 1.15)}{0.02} = \\frac{2\\,(-0.05)}{0.02} = -5.0\n    $$\n-   后偏斜率：\n    $$\n    \\gamma_i = \\frac{2\\,(1.15 - 1.21)}{0.02} = \\frac{2\\,(-0.06)}{0.02} = -6.0\n    $$\n所有三个参数 $\\alpha_i = -2.75$、$\\beta_i = -5.0$ 和 $\\gamma_i = -6.0$ 均为负。因此，它们的符号相同。$\\minmod$ 函数将返回具有最小绝对值的值，并冠以共同的符号。\n$$\n\\sigma_i = \\mathrm{sign}(-2.75) \\times \\min(|\\!-\\!2.75|, |\\!-\\!5.0|, |\\!-\\!6.0|) = -1 \\times \\min(2.75, 5.0, 6.0) = -2.75\n$$\n因此，单元 $i$ 中的限制后斜率为 $\\sigma_i = -2.75~\\mathrm{kg\\,m^{-4}}$。\n\n**第2步：计算限制后的斜率 $\\sigma_{i+1}$**\n\n类似地，我们计算单元 $i+1$ 中 MC 限制器的参数：\n$$\n\\alpha_{i+1} = \\frac{\\bar{\\rho}_{i+2}-\\bar{\\rho}_{i}}{2\\,\\Delta x} = \\frac{1.095 - 1.15}{2 \\times 0.02} = \\frac{-0.055}{0.04} = -1.375\n$$\n$$\n\\beta_{i+1} = \\frac{2\\,(\\bar{\\rho}_{i+2}-\\bar{\\rho}_{i+1})}{\\Delta x} = \\frac{2\\,(1.095 - 1.10)}{0.02} = \\frac{2\\,(-0.005)}{0.02} = -0.5\n$$\n$$\n\\gamma_{i+1} = \\frac{2\\,(\\bar{\\rho}_{i+1}-\\bar{\\rho}_{i})}{\\Delta x} = \\frac{2\\,(1.10 - 1.15)}{0.02} = \\frac{2\\,(-0.05)}{0.02} = -5.0\n$$\n所有三个参数 $\\alpha_{i+1} = -1.375$、$\\beta_{i+1} = -0.5$ 和 $\\gamma_{i+1} = -5.0$ 均为负。它们的符号相同。\n$$\n\\sigma_{i+1} = \\mathrm{sign}(-1.375) \\times \\min(|\\!-\\!1.375|, |\\!-\\!0.5|, |\\!-\\!5.0|) = -1 \\times \\min(1.375, 0.5, 5.0) = -0.5\n$$\n单元 $i+1$ 中的限制后斜率为 $\\sigma_{i+1} = -0.5~\\mathrm{kg\\,m^{-4}}$。\n\n**第3步：重构界面状态**\n\n使用分段线性重构公式，我们求出界面 $x_{i+1/2}$ 左侧和右侧的密度值：\n-   左状态（从单元 $i$ 重构）：\n    $$\n    \\rho_{i+1/2}^{-} = \\bar{\\rho}_i + \\sigma_i\\,\\frac{\\Delta x}{2} = 1.15 + (-2.75) \\times \\frac{0.02}{2} = 1.15 - 2.75 \\times 0.01 = 1.15 - 0.0275 = 1.1225~\\mathrm{kg/m^3}\n    $$\n-   右状态（从单元 $i+1$ 重构）：\n    $$\n    \\rho_{i+1/2}^{+} = \\bar{\\rho}_{i+1} - \\sigma_{i+1}\\,\\frac{\\Delta x}{2} = 1.10 - (-0.5) \\times \\frac{0.02}{2} = 1.10 + 0.5 \\times 0.01 = 1.10 + 0.005 = 1.105~\\mathrm{kg/m^3}\n    $$\n\n**第4步：应用 Godunov 迎风通量**\n\n线性平流的 Godunov 通量是一种迎风通量。界面状态的选择取决于信息传播的方向，而该方向由平流速度 $a$ 的符号决定。\n通量由下式给出：\n$$\nF_{i+1/2} \\;=\\; a \\times \n\\begin{cases}\n\\rho_{i+1/2}^{-},  &\\text{if } a > 0, \\\\\n\\rho_{i+1/2}^{+},  &\\text{if } a < 0.\n\\end{cases}\n$$\n在本问题中，平流速度 $a = 240~\\mathrm{m/s}$，为正值 ($a > 0$)。因此，信息从左向右传播，通量由左状态 $\\rho_{i+1/2}^{-}$ 决定。\n$$\nF_{i+1/2} = a \\times \\rho_{i+1/2}^{-}\n$$\n\n**第5步：最终通量计算**\n\n代入 $a$ 和 $\\rho_{i+1/2}^{-}$ 的数值：\n$$\nF_{i+1/2} = 240~\\mathrm{m/s} \\times 1.1225~\\mathrm{kg/m^3} = 269.4~\\mathrm{kg\\,m^{-2}\\,s^{-1}}\n$$\n题目要求答案四舍五入到四位有效数字。计算出的值 $269.4$ 已经有四位有效数字。",
            "answer": "$$\\boxed{269.4}$$"
        },
        {
            "introduction": "理论分析告诉我们一个数值格式应该是二阶精度的，但我们如何通过实践来验证这一点呢？本练习将指导您设计并实施一个数值收敛性实验，这是计算科学中验证代码正确性的黄金标准。您将通过在一系列加密的网格上运行代码并测量误差，来计算您实现的重构方法的“观测收敛阶”，从而确认其是否达到了理论预期的精度。",
            "id": "3989859",
            "problem": "您需要设计并实现一个一维空间中的数值实验，以在计算流体力学（CFD; Computational Fluid Dynamics）中，从有限体积的观点出发，验证使用光滑标量场重构的单元面通量的二阶收敛性。您的实验必须从基本定义开始，并在不预设目标收敛结果的情况下进行。数学背景设定为一个周期性域和一个光滑的守恒量，具有线性平流通量，以及从单元平均数据重构面值。\n\n从一维空间周期区间 $[0,1]$ 上的标量守恒律开始，\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0,\n$$\n其中 $f(u) = a\\,u$ 是恒速线性平流通量，$a$ 是一个常数。对于一个有限体积划分，设单元 $i$ 的边位于 $x_{i-\\frac{1}{2}}$ 和 $x_{i+\\frac{1}{2}}$，中心位于 $x_i = \\tfrac{1}{2}(x_{i-\\frac{1}{2}} + x_{i+\\frac{1}{2}})$，宽度为 $\\Delta x_i = x_{i+\\frac{1}{2}} - x_{i-\\frac{1}{2}}$。$u$ 的单元平均定义为\n$$\n\\bar{u}_i = \\frac{1}{\\Delta x_i}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x)\\,dx.\n$$\n在面 $x_{i+\\frac{1}{2}}$ 处的面通量为 $f(u(x_{i+\\frac{1}{2}})) = a\\,u(x_{i+\\frac{1}{2}})$。在基于重构的方法中，使用附近的单元数据来近似 $u(x_{i+\\frac{1}{2}})$。在本实验中，通过将 $\\bar{u}_i$ 和 $\\bar{u}_{i+1}$ 视为在 $x_i$ 和 $x_{i+1}$ 处的点采样，并使用基于中心点与面之间距离的几何权重，线性插值到 $x_{i+\\frac{1}{2}}$，从而从单元平均值重构 $u(x_{i+\\frac{1}{2}})$。对于光滑的 $u$，此过程预期会产生二阶精度的面值。\n\n使用光滑周期函数\n$$\nu(x) = \\sin(2\\pi x) + \\tfrac{1}{2}\\cos(4\\pi x),\n$$\n并选择 $a = 1$。为了获得单元平均值，请对每个单元使用精确的积分公式：\n$$\n\\int_{x_L}^{x_R} \\sin(2\\pi x)\\,dx = -\\frac{\\cos(2\\pi x)}{2\\pi}\\Big|_{x_L}^{x_R},\\qquad\n\\int_{x_L}^{x_R} \\tfrac{1}{2}\\cos(4\\pi x)\\,dx = \\frac{\\sin(4\\pi x)}{8\\pi}\\Big|_{x_L}^{x_R},\n$$\n然后除以单元宽度得到 $\\bar{u}_i$。\n\n要使用的网格：\n- $[0,1]$ 上的均匀周期网格，有 $N$ 个单元，面位于 $x_j = j/N$，$j \\in \\{0,1,\\dots,N\\}$。\n- 由单调映射 $x(s) = \\dfrac{e^{k s} - 1}{e^k - 1}$ 定义的光滑拉伸的周期网格，其中 $s \\in [0,1]$，$k=3$，面位于 $s_j = j/N$，$j \\in \\{0,1,\\dots,N\\}$，映射到 $x_j = x(s_j)$。\n\n对于这两种网格族，通过相邻单元中心 $x_i$ 和 $x_{i+1}$ 处的单元平均值的线性插值，并使用基于到面的几何距离的权重，在每个面 $x_{i+\\frac{1}{2}}$ 处构建重构。当面位于 $x=1$（右边界）时，一致地施加周期性，即为了插值权重的计算，将单元 $0$ 的中心解释为位于 $x_0 + 1$；点场值保持周期性，即 $u(x_0 + 1) = u(x_0)$。\n\n在面 $\\{x_j\\}_{j=1}^N$ 处，为通量误差 $e_j = f(u_{\\text{rec}}(x_j)) - f(u(x_j))$ 定义离散的基于面的误差范数：\n$$\n\\|e\\|_{1,\\text{face}} = \\frac{1}{N}\\sum_{j=1}^{N} |e_j|,\\quad\n\\|e\\|_{2,\\text{face}} = \\left(\\frac{1}{N}\\sum_{j=1}^{N} e_j^2\\right)^{1/2},\\quad\n\\|e\\|_{\\infty,\\text{face}} = \\max_{1\\le j\\le N}|e_j|.\n$$\n为了进行收敛性评估，将网格尺寸 $h$ 定义为最大单元宽度，\n$$\nh = \\max_{i}\\Delta x_i.\n$$\n给定一个网格族，其尺寸为 $\\{h_m\\}$，在选定范数下的相应误差为 $\\{E_m\\}$，通过对 $\\log E_m$ 与 $\\log h_m$ 使用线性模型 $\\log E_m \\approx \\alpha + p\\,\\log h_m$ 进行最小二乘拟合来计算观测阶 $p$。\n\n您的程序必须：\n- 构建两种网格族，其中 $N \\in \\{50, 100, 200, 400\\}$。\n- 对于每个 $N$，计算精确的单元平均值、中心点，通过相邻单元平均值的线性插值和几何权重重构面值，使用 $a=1$ 形成通量，并评估三个离散的基于面的误差范数。\n- 在每个网格族中，使用所有四个 $N$ 值，通过最小二乘法为每个范数计算观测阶 $p$。\n\n测试套件规范：\n- 族1（均匀）：$N \\in \\{50, 100, 200, 400\\}$。\n- 族2（拉伸，$k=3$）：$N \\in \\{50, 100, 200, 400\\}$。\n以上内容涵盖了代表性的“理想路径”（均匀加密）、周期性边界处理，以及通过拉伸实现的显著非均匀性边缘情况。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个观测阶，形式为包含在方括号中的逗号分隔列表，顺序如下\n$$\n[\\;p_{1}^{(L1)},\\;p_{1}^{(L2)},\\;p_{1}^{(L\\infty)},\\;p_{2}^{(L1)},\\;p_{2}^{(L2)},\\;p_{2}^{(L\\infty)}\\;],\n$$\n其中 $p_{1}^{(\\cdot)}$ 是均匀网格的观测阶，$p_{2}^{(\\cdot)}$ 是拉伸网格的观测阶。每个条目必须是浮点数。",
            "solution": "问题的核心是评估从相邻单元的平均数据重构单元面上的点值的精度。对于光滑解，这个过程预期是二阶精度的，意味着误差应与网格尺寸的平方 $h^2$ 成比例减小。这一点将在均匀和非均匀（拉伸）网格上进行验证。\n\n对于每个网格族（均匀和拉伸）和一系列加密的网格分辨率（$N \\in \\{50, 100, 200, 400\\}$），整个过程包括以下步骤：\n\n1.  **网格生成**：将一维周期域 $[0, 1]$ 离散化为 $N$ 个单元。这些单元的边界称为“面”。\n    *   对于**均匀网格**，$N+1$ 个面位于 $x_j = j/N$，$j \\in \\{0, 1, \\dots, N\\}$。\n    *   对于**拉伸网格**，使用映射 $x(s) = \\frac{e^{k s} - 1}{e^k - 1}$，其中 $k = 3$。面位于 $x_j = x(s_j)$，其中 $s_j = j/N$，$j \\in \\{0, 1, \\dots, N\\}$。\n    每个单元 $i$（对于 $i=0, \\dots, N-1$）是区间 $[x_i, x_{i+1}]$。其宽度是 $\\Delta x_i = x_{i+1} - x_i$，其中心是 $c_i = (x_i + x_{i+1})/2$。\n\n2.  **单元平均值计算**：对于给定的光滑函数 $u(x) = \\sin(2\\pi x) + \\frac{1}{2}\\cos(4\\pi x)$，计算精确的单元平均值 $\\bar{u}_i$。单元 $i$ 的单元平均值定义为 $\\bar{u}_i = \\frac{1}{\\Delta x_i} \\int_{x_i}^{x_{i+1}} u(x) dx$。使用提供的 $u(x)$ 的反导数，记为 $U(x)$，这可以计算为 $\\bar{u}_i = \\frac{U(x_{i+1}) - U(x_i)}{\\Delta x_i}$。\n\n3.  **面值重构**：使用线性插值来近似每个单元面上的解值。问题规定，单元平均值 $\\bar{u}_i$ 应被视为在单元中心 $c_i$ 处的一个点值。为了找到在单元 $i$ 和单元 $i+1$ 之间的面 $x_{i+1}$ 处的重构值 $u_{\\text{rec}}(x_{i+1})$，构造一条通过点 $(c_i, \\bar{u}_i)$ 和 $(c_{i+1}, \\bar{u}_{i+1})$ 的直线。这个线性插值函数在 $x_{i+1}$ 处的值是：\n    $$\n    u_{\\text{rec}}(x_{i+1}) = \\bar{u}_i + (\\bar{u}_{i+1} - \\bar{u}_i) \\frac{x_{i+1} - c_i}{c_{i+1} - c_i}\n    $$\n    对于周期性边界，最后一个面 $x_N=1$（位于单元 $N-1$ 和单元 $0$ 之间）的重构使用点 $(c_{N-1}, \\bar{u}_{N-1})$ 和单元 $0$ 的一个周期性平移点，即 $(c_0+1, \\bar{u}_0)$。\n\n4.  **误差计算**：在位于 $x_j$（$j=1, \\dots, N$）的 $N$ 个面上计算误差。通量为 $f(u) = a u$，其中恒定平流速度 $a=1$，因此通量误差与重构值 $u$ 的误差相同。在面 $j$ 处的误差是 $e_j = u_{\\text{rec}}(x_j) - u(x_j)$。计算此误差向量的三个离散范数：\n    *   $L_1$ 范数：$\\|e\\|_{1,\\text{face}} = \\frac{1}{N}\\sum_{j=1}^{N} |e_j|$\n    *   $L_2$ 范数：$\\|e\\|_{2,\\text{face}} = \\left(\\frac{1}{N}\\sum_{j=1}^{N} e_j^2\\right)^{1/2}$\n    *   $L_\\infty$ 范数：$\\|e\\|_{\\infty,\\text{face}} = \\max_{1\\le j\\le N}|e_j|$\n\n5.  **收敛性分析**：通过分析误差 $E$ 如何随网格尺寸 $h = \\max_i(\\Delta x_i)$ 缩放来确定收敛阶 $p$。假设存在幂律关系 $E \\approx C h^p$，我们可以取对数得到一个线性方程：$\\log E \\approx \\log C + p \\log h$。通过为一系列网格尺寸 $N \\in \\{50, 100, 200, 400\\}$ 计算误差，我们得到一组数据点 $(\\log h_m, \\log E_m)$。通过这些点的最佳拟合线的斜率 $p$ 给出了观测到的收敛阶。这是通过线性最小二乘回归确定的。对三种误差范数和两种网格族都重复此过程。\n对于应用于光滑函数的这种线性重构方案，预期结果是二阶收敛，即 $p \\approx 2$。数值实验旨在确认这一理论结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical experiment to verify second-order convergence \n    of reconstructed cell-face fluxes for a smooth scalar field in a finite volume context.\n    \"\"\"\n\n    # --- Function Definitions ---\n\n    def u_exact(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the exact solution for the scalar field u(x).\n        u(x) = sin(2*pi*x) + 0.5*cos(4*pi*x)\n        \"\"\"\n        return np.sin(2.0 * np.pi * x) + 0.5 * np.cos(4.0 * np.pi * x)\n\n    def u_integral(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the definite integral (antiderivative) of u(x).\n        Integral(u(x)dx) = -cos(2*pi*x)/(2*pi) + sin(4*pi*x)/(8*pi)\n        \"\"\"\n        return -np.cos(2.0 * np.pi * x) / (2.0 * np.pi) + np.sin(4.0 * np.pi * x) / (8.0 * np.pi)\n\n    def create_grid(N: int, k: float = None) -> np.ndarray:\n        \"\"\"\n        Generates grid face locations for uniform or stretched grids.\n        \n        Args:\n            N: Number of cells.\n            k: Stretching factor. If None, a uniform grid is created.\n\n        Returns:\n            An array of N+1 face locations.\n        \"\"\"\n        if k is None:  # Uniform grid\n            return np.linspace(0.0, 1.0, N + 1)\n        else:  # Stretched grid\n            s = np.linspace(0.0, 1.0, N + 1)\n            return (np.exp(k * s) - 1.0) / (np.exp(k) - 1.0)\n\n    def run_convergence_study(k: float, N_values: list) -> list:\n        \"\"\"\n        Performs the full convergence study for a given grid family.\n        \n        Args:\n            k: Stretching factor for the grid family (None for uniform).\n            N_values: A list of integers representing the number of cells for each run.\n\n        Returns:\n            A list containing the observed convergence orders [p_L1, p_L2, p_Linf].\n        \"\"\"\n        mesh_sizes = []\n        l1_errors = []\n        l2_errors = []\n        linf_errors = []\n\n        for N in N_values:\n            # 1. Generate grid and compute cell properties\n            faces = create_grid(N, k)\n            cell_widths = faces[1:] - faces[:-1]\n            cell_centers = (faces[1:] + faces[:-1]) / 2.0\n            h = np.max(cell_widths)\n            mesh_sizes.append(h)\n\n            # 2. Compute exact cell averages\n            integrals = u_integral(faces[1:]) - u_integral(faces[:-1])\n            u_bar = integrals / cell_widths\n\n            # 3. Reconstruct values at faces\n            u_rec_at_faces = np.zeros(N)\n            faces_for_recon = faces[1:]  # Faces x_1, ..., x_N\n\n            for i in range(N):\n                # i is the index of the cell to the left of the face at faces[i+1]\n                u_left = u_bar[i]\n                center_left = cell_centers[i]\n\n                # Handle periodic boundary for the right neighbor\n                is_periodic_face = (i == N - 1)\n                u_right = u_bar[0] if is_periodic_face else u_bar[i + 1]\n                center_right = (cell_centers[0] + 1.0) if is_periodic_face else cell_centers[i + 1]\n                \n                x_face = faces_for_recon[i]\n\n                # Linear interpolation of cell-averages treated as point values\n                if np.isclose(center_right, center_left):\n                    u_rec_at_faces[i] = u_left\n                else:\n                    u_rec_at_faces[i] = u_left + (u_right - u_left) * \\\n                                      (x_face - center_left) / (center_right - center_left)\n\n            # 4. Compute errors (a=1, so flux error is value error)\n            u_exact_at_faces = u_exact(faces_for_recon)\n            errors = u_rec_at_faces - u_exact_at_faces\n\n            # 5. Compute and store error norms\n            l1_errors.append(np.mean(np.abs(errors)))\n            l2_errors.append(np.sqrt(np.mean(errors**2)))\n            linf_errors.append(np.max(np.abs(errors)))\n\n        # 6. Compute convergence order via least-squares fit on log-log data\n        log_h = np.log(mesh_sizes)\n        p_l1 = np.polyfit(log_h, np.log(l1_errors), 1)[0]\n        p_l2 = np.polyfit(log_h, np.log(l2_errors), 1)[0]\n        p_linf = np.polyfit(log_h, np.log(linf_errors), 1)[0]\n        \n        return [p_l1, p_l2, p_linf]\n\n    # --- Main Execution ---\n    \n    # Define the test cases from the problem statement.\n    Ns_list = [50, 100, 200, 400]\n    \n    # Family 1 (uniform grid)\n    orders_uniform = run_convergence_study(k=None, N_values=Ns_list)\n    \n    # Family 2 (stretched grid)\n    k_stretched = 3.0\n    orders_stretched = run_convergence_study(k=k_stretched, N_values=Ns_list)\n    \n    # Combine results into a single list\n    final_orders = orders_uniform + orders_stretched\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_orders))}]\")\n\nsolve()\n```"
        }
    ]
}