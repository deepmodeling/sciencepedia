{
    "hands_on_practices": [
        {
            "introduction": "Understanding the behavior of slope limiters is central to mastering MUSCL-type schemes. A well-designed limiter should be active in regions of high gradients to prevent oscillations, but it must also 'turn off' in smooth regions to allow the scheme to achieve its formal second-order accuracy. This first practice  provides a focused, analytical exercise to explore this dual role by examining the idealized case of a perfectly linear data profile, where the ratio of successive gradients $r=1$. By calculating the limiter functions and the resulting numerical dissipation, you will verify a fundamental property: for a scheme to be second-order accurate, it must become minimally dissipative in smooth regions.",
            "id": "3978800",
            "problem": "Consider the one-dimensional scalar conservation law $u_{t} + a\\,u_{x} = 0$ with constant advection speed $a > 0$ on a uniform grid of cell centers $\\{x_{i}\\}$ with spacing $\\Delta x$. In a finite-volume discretization, use the Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) high-resolution reconstruction to form piecewise linear states. Let the left and right reconstructed interface states at $x_{i+\\frac{1}{2}}$ be\n$$U_{i+\\frac{1}{2}}^{L} = U_{i} + \\frac{1}{2}\\,s_{i}, \\quad U_{i+\\frac{1}{2}}^{R} = U_{i+1} - \\frac{1}{2}\\,s_{i+1},$$\nwhere the limited slopes $s_{i}$ are given by $s_{i} = \\phi(r_{i})\\,(U_{i} - U_{i-1})$ with the Total Variation Diminishing (TVD) limiter argument $r_{i} = \\dfrac{U_{i+1} - U_{i}}{U_{i} - U_{i-1}}$ and limiter function $\\phi(r)$ chosen from the following well-tested TVD limiters:\n- Minmod: $\\phi_{\\mathrm{MM}}(r) = \\max\\!\\big(0, \\min(1, r)\\big)$,\n- Van Leer: $\\phi_{\\mathrm{VL}}(r) = \\dfrac{r + |r|}{1 + |r|}$,\n- Monotonized Central (MC): $\\phi_{\\mathrm{MC}}(r) = \\max\\!\\Big(0, \\min\\!\\big(2r, \\dfrac{1 + r}{2}, 2\\big)\\Big)$,\n- Superbee: $\\phi_{\\mathrm{SB}}(r) = \\max\\!\\big(0, \\min(2r, 1), \\min(r, 2)\\big)$,\n- Van Albada: $\\phi_{\\mathrm{VA}}(r) = \\dfrac{r^{2} + r}{1 + r^{2}}$.\n\nThe numerical flux is taken to be the Local Lax–Friedrichs (also known as Rusanov) flux,\n$$F_{i+\\frac{1}{2}} = \\frac{a}{2}\\,\\Big(U_{i+\\frac{1}{2}}^{L} + U_{i+\\frac{1}{2}}^{R}\\Big) - \\frac{|a|}{2}\\,\\Big(U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\Big).$$\nDefine the dissipative contribution at the interface $x_{i+\\frac{1}{2}}$ as\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\big|U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\big|.$$\n\nAssume a discrete profile with constant forward and backward differences such that $U_{i+1} - U_{i} = U_{i} - U_{i-1} \\neq 0$, so that $r_{i} = 1$ and $r_{i+1} = 1$. For each limiter listed above, compare the reconstructed interface states $U_{i+\\frac{1}{2}}^{L}$ and $U_{i+\\frac{1}{2}}^{R}$ under the condition $r=1$, and compute the resulting $D_{i+\\frac{1}{2}}$.\n\nExpress the final answer as a single real number. No rounding is required, and no physical units are to be included with the final answer.",
            "solution": "The problem requires the computation of the dissipative contribution, $D_{i+\\frac{1}{2}}$, of the Local Lax-Friedrichs numerical flux for a one-dimensional scalar advection equation. The computation is to be performed under the specific condition of a piecewise linear data profile with a constant gradient, using the MUSCL high-resolution reconstruction method with several common TVD flux limiters.\n\nThe problem defines the left and right reconstructed states at the interface $x_{i+\\frac{1}{2}}$ as:\n$$U_{i+\\frac{1}{2}}^{L} = U_{i} + \\frac{1}{2}\\,s_{i}$$\n$$U_{i+\\frac{1}{2}}^{R} = U_{i+1} - \\frac{1}{2}\\,s_{i+1}$$\nThe limited slopes, $s_i$, are given by $s_{i} = \\phi(r_{i})\\,(U_i - U_{i-1})$, where $\\phi(r)$ is a limiter function and $r_i$ is the ratio of successive gradients:\n$$r_{i} = \\frac{U_{i+1} - U_{i}}{U_{i} - U_{i-1}}$$\nThe dissipative contribution to the flux is defined as:\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\big|U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\big|$$\nwhere $a>0$ is the constant advection speed, so $|a|=a$.\n\nThe key condition provided is that the discrete profile has constant forward and backward differences, such that $U_{i+1} - U_{i} = U_{i} - U_{i-1} \\neq 0$. This directly implies that the limiter argument $r_{i}$ is:\n$$r_{i} = \\frac{U_{i+1} - U_{i}}{U_{i} - U_{i-1}} = 1$$\nThe problem also states that $r_{i+1} = 1$. This is consistent with a profile having a globally constant gradient, since $r_{i+1} = \\frac{U_{i+2} - U_{i+1}}{U_{i+1} - U_{i}} = 1$ implies $U_{i+2} - U_{i+1} = U_{i+1} - U_{i}$.\n\nOur first step is to evaluate each of the specified limiter functions $\\phi(r)$ at $r=1$. This is a necessary condition for a scheme to be second-order accurate in smooth regions of the solution.\n\n1.  **Minmod Limiter:**\n    $$\\phi_{\\mathrm{MM}}(r) = \\max\\!\\big(0, \\min(1, r)\\big)$$\n    For $r=1$:\n    $$\\phi_{\\mathrm{MM}}(1) = \\max\\!\\big(0, \\min(1, 1)\\big) = \\max(0, 1) = 1$$\n\n2.  **Van Leer Limiter:**\n    $$\\phi_{\\mathrm{VL}}(r) = \\frac{r + |r|}{1 + |r|}$$\n    For $r=1$:\n    $$\\phi_{\\mathrm{VL}}(1) = \\frac{1 + |1|}{1 + |1|} = \\frac{1 + 1}{1 + 1} = \\frac{2}{2} = 1$$\n\n3.  **Monotonized Central (MC) Limiter:**\n    $$\\phi_{\\mathrm{MC}}(r) = \\max\\!\\Big(0, \\min\\!\\big(2r, \\frac{1 + r}{2}, 2\\big)\\Big)$$\n    For $r=1$:\n    $$\\phi_{\\mathrm{MC}}(1) = \\max\\!\\Big(0, \\min\\!\\big(2(1), \\frac{1 + 1}{2}, 2\\big)\\Big) = \\max\\!\\big(0, \\min(2, 1, 2)\\big) = \\max(0, 1) = 1$$\n\n4.  **Superbee Limiter:**\n    $$\\phi_{\\mathrm{SB}}(r) = \\max\\!\\big(0, \\min(2r, 1), \\min(r, 2)\\big)$$\n    For $r=1$:\n    $$\\phi_{\\mathrm{SB}}(1) = \\max\\!\\big(0, \\min(2(1), 1), \\min(1, 2)\\big) = \\max\\!\\big(0, \\min(2, 1), \\min(1, 2)\\big) = \\max(0, 1, 1) = 1$$\n\n5.  **Van Albada Limiter:**\n    $$\\phi_{\\mathrm{VA}}(r) = \\frac{r^{2} + r}{1 + r^{2}}$$\n    For $r=1$:\n    $$\\phi_{\\mathrm{VA}}(1) = \\frac{1^{2} + 1}{1 + 1^{2}} = \\frac{1+1}{1+1} = \\frac{2}{2} = 1$$\n\nFor all five specified limiters, we find that $\\phi(1) = 1$. This means the result will be identical regardless of which of these limiters is chosen.\n\nNow, we compute the limited slopes $s_{i}$ and $s_{i+1}$.\nFor slope $s_{i}$:\n$$s_{i} = \\phi(r_{i})\\,(U_{i} - U_{i-1}) = \\phi(1)\\,(U_{i} - U_{i-1}) = 1 \\cdot (U_{i} - U_{i-1}) = U_{i} - U_{i-1}$$\nFor slope $s_{i+1}$, we use the condition $r_{i+1}=1$, which implies $U_{i+2}-U_{i+1} = U_{i+1}-U_i$. The slope is $s_{i+1} = \\phi(r_{i+1})(U_{i+1}-U_i)$.\n$$s_{i+1} = \\phi(1)\\,(U_{i+1} - U_{i}) = 1 \\cdot (U_{i+1} - U_{i}) = U_{i+1} - U_{i}$$\nFrom the condition $U_{i+1} - U_i = U_i - U_{i-1}$, we have $s_i = s_{i+1}$.\n\nNext, we substitute these slopes into the expressions for the reconstructed interface states, $U_{i+\\frac{1}{2}}^{L}$ and $U_{i+\\frac{1}{2}}^{R}$. Let $\\Delta U = U_i - U_{i-1} = U_{i+1} - U_i$.\nFor the left state:\n$$U_{i+\\frac{1}{2}}^{L} = U_{i} + \\frac{1}{2}\\,s_{i} = U_{i} + \\frac{1}{2}\\,(U_{i} - U_{i-1}) = U_i + \\frac{1}{2}\\Delta U$$\nFor the right state:\n$$U_{i+\\frac{1}{2}}^{R} = U_{i+1} - \\frac{1}{2}\\,s_{i+1} = U_{i+1} - \\frac{1}{2}\\,(U_{i+1} - U_{i}) = (U_i + \\Delta U) - \\frac{1}{2}\\Delta U = U_i + \\frac{1}{2}\\Delta U$$\n\nComparing the two reconstructed states, we find:\n$$U_{i+\\frac{1}{2}}^{L} = U_{i+\\frac{1}{2}}^{R}$$\nThe reconstructed values at the interface are identical. This indicates that the piecewise linear representation of the solution is continuous at the cell interface $x_{i+\\frac{1}{2}}$. This is the expected behavior for a second-order accurate reconstruction scheme in a region of smooth, monotonic data.\n\nFinally, we compute the dissipative contribution $D_{i+\\frac{1}{2}}$ using its definition:\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\big|U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\big|$$\nSubstituting the derived states:\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\left| (U_i + \\frac{1}{2}\\Delta U) - (U_i + \\frac{1}{2}\\Delta U) \\right| = \\frac{|a|}{2}\\,|0| = 0$$\nThe dissipative contribution at the interface is exactly zero under the given conditions for all specified limiters. This occurs because in a region of constant gradient, a TVD scheme designed for second-order accuracy reverts to a non-dissipative (or minimally dissipative) centered scheme. For the Rusanov flux, the dissipative term vanishes when the jump in the reconstructed states at the interface is zero.\n\nThe final answer is $0$.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Moving from theoretical analysis to practical application is a critical step in computational science. While the previous exercise explored a key property of limiters in isolation, this practice  challenges you to build a complete finite volume solver from the ground up. You will implement the MUSCL reconstruction and a second-order time integration scheme to simulate the advection of a smooth Gaussian pulse. The ultimate goal is to perform a numerical convergence study, a standard verification technique in CFD, to confirm that the implemented scheme indeed achieves its theoretical second-order rate of accuracy on a smooth solution.",
            "id": "3978860",
            "problem": "Consider the one-dimensional linear advection equation $u_t + a\\,u_x = 0$ posed on the periodic domain $x \\in [0,L]$, with non-dimensional parameters. The initial condition is a smooth Gaussian pulse $u(x,0) = \\exp\\!\\left(-\\dfrac{(x - x_0)^2}{2\\,\\sigma^2}\\right)$, where $x_0 \\in [0,L]$ and $\\sigma > 0$. The exact solution after time $T$ is $u(x,T) = u(x - a\\,T,0)$ under periodic boundary conditions. For $a = 1$ and $T = L$, the solution completes one full period and returns exactly to the initial condition, so $u(x,L) = u(x,0)$.\n\nStarting from the integral conservation form and the definition of a finite volume method on a uniform mesh with $N$ cells of width $\\Delta x = L/N$, derive a second-order accurate semi-discrete update for the cell-average $U_i(t)$ using Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) high-resolution reconstruction. Use a Total Variation Diminishing (TVD) limiter to ensure stability and non-oscillatory behavior. Close the semi-discrete system with a second-order Strong Stability Preserving Runge–Kutta (SSP RK2) time integration. The numerical flux at each cell interface must be upwind consistent with the sign of $a$.\n\nDefine the discrete $L_1$ error norm $E_{1}(N)$ and the discrete $L_2$ error norm $E_{2}(N)$ at $t=T$ for a mesh size $\\Delta x = L/N$ by\n$$\nE_{1}(N) = \\Delta x \\sum_{i=0}^{N-1} \\left| U_i(T) - U_i^{\\text{exact}}(T) \\right|,\n\\qquad\nE_{2}(N) = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left( U_i(T) - U_i^{\\text{exact}}(T) \\right)^2 \\right)^{1/2},\n$$\nwhere $U_i^{\\text{exact}}(T)$ denotes the exact solution sampled as cell averages or point values at cell centers consistent with your discretization. Estimate the observed convergence rates $p_1$ and $p_2$, which correspond to the slopes of a linear fit to $\\log(E_1(N))$ and $\\log(E_2(N))$ versus $\\log(\\Delta x)$, respectively. Verify that the rates are approximately second order on smooth data.\n\nYour task is to write a complete, runnable program that:\n- Implements a uniform finite volume discretization for $u_t + a\\,u_x = 0$ with $a = 1$ on $x \\in [0,L]$, $L = 1$, and periodic boundary conditions.\n- Uses MUSCL high-resolution piecewise-linear reconstruction with a TVD limiter to obtain left and right interface states. The limiter is parameterized by a choice among three canonical options: minmod, van Leer, and Monotonized Central (MC).\n- Advances the solution using second-order SSP RK2 to time $T = L$.\n- Computes the discrete $L_1$ and $L_2$ error norms at final time by comparing to the exact solution (which equals the initial condition for $T = L$).\n- Estimates the observed convergence rates by linear regression on $\\log$–$\\log$ data across the mesh sizes in the test suite.\n\nUse non-dimensional units throughout; no physical units are required.\n\nTest Suite:\n- Case $1$: limiter $=$ minmod, $\\text{CFL} = 0.5$, Gaussian width $\\sigma = 0.05$, $x_0 = 0.25$, mesh sizes $N \\in \\{50, 100, 200, 400\\}$.\n- Case $2$: limiter $=$ van Leer, $\\text{CFL} = 0.8$, Gaussian width $\\sigma = 0.08$, $x_0 = 0.25$, mesh sizes $N \\in \\{50, 100, 200, 400\\}$.\n- Case $3$: limiter $=$ MC, $\\text{CFL} = 0.4$, Gaussian width $\\sigma = 0.03$, $x_0 = 0.25$, mesh sizes $N \\in \\{50, 100, 200, 400\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case returns a two-element list $[p_1, p_2]$ of floating-point values representing the observed $L_1$ and $L_2$ convergence rates. For example, the output must be of the form $\\left[\\left[p_{1,1},p_{1,2}\\right],\\left[p_{2,1},p_{2,2}\\right],\\left[p_{3,1},p_{3,2}\\right]\\right]$.\n\nAll angles, if any, must be in radians, though none are used in this problem. Percentages are not used; whenever a fraction is needed it must be expressed as a decimal or a rational ratio.\n\nNo external input is permitted; all parameters are fixed as specified above, and the program must run to completion and print only the final results in the exact format stated.",
            "solution": "The user provides a valid, well-posed problem statement from the field of computational fluid dynamics. The task is to implement a second-order finite volume scheme for the one-dimensional linear advection equation, verify its convergence rate, and provide the implementation in a complete, runnable program. The following represents a complete, reasoned solution derived from first principles.\n\nThe governing partial differential equation is the linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the conserved quantity, $x \\in [0,L]$ is the spatial coordinate, $t$ is time, and $a$ is the constant wave speed, given as $a=1$. The domain has length $L=1$ with periodic boundary conditions. The initial condition is a Gaussian pulse:\n$$\nu(x,0) = \\exp\\left(-\\frac{(x - x_0)^2}{2\\sigma^2}\\right)\n$$\nThe problem is to be solved up to a final time $T=L=1$. Given $a=1$ and $T=L$, the exact solution propagates exactly one period, so $u(x,T) = u(x,0)$.\n\n**1. Finite Volume Discretization**\n\nWe start from the integral form of the conservation law, obtained by integrating the PDE over a control volume, or cell, $C_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x = x_{i+1/2} - x_{i-1/2}$:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial u}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial (au)}{\\partial x} dx = 0\n$$\nDefining the cell-average of $u$ in cell $i$ as $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$, the equation becomes:\n$$\n\\frac{d U_i}{dt} + \\frac{1}{\\Delta x} \\left[ (au)_{i+1/2} - (au)_{i-1/2} \\right] = 0\n$$\nHere, $(au)_{i\\pm 1/2}$ represents the flux of $u$ at the cell interfaces $x_{i\\pm 1/2}$. In a numerical scheme, these are replaced by a numerical flux function, $F(u_L, u_R)$, which depends on the reconstructed states on the left ($u_L$) and right ($u_R$) of the interface. This gives the semi-discrete finite volume formula:\n$$\n\\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\nFor the linear advection equation with flux $f(u) = au$, the upwind numerical flux is used. Since $a=1 > 0$, the information propagates from left to right. The flux at any interface is determined by the state to its left:\n$$\nF_{i+1/2} = F(U_{i+1/2}^L, U_{i+1/2}^R) = a U_{i+1/2}^L\n$$\nwhere $U_{i+1/2}^L$ is the value of the solution reconstructed at the left side of the interface $x_{i+1/2}$.\n\n**2. MUSCL High-Resolution Reconstruction**\n\nTo achieve second-order spatial accuracy, we use the Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) approach. Within each cell $C_i$, the solution is approximated by a piecewise linear function:\n$$\nu(x) \\approx U_i + s_i \\frac{x - x_i}{\\Delta x} \\quad \\text{for } x \\in [x_{i-1/2}, x_{i+1/2}]\n$$\nwhere $x_i$ is the cell center and $s_i$ is a limited slope. The value at the right interface of cell $i$ (the left side of interface $x_{i+1/2}$) is then found by evaluating this reconstruction at $x = x_{i+1/2} = x_i + \\Delta x/2$:\n$$\nU_{i+1/2}^L = U_i + \\frac{s_i}{2}\n$$\nThe semi-discrete update for cell $i$ requires fluxes $F_{i+1/2}$ and $F_{i-1/2}$. The flux $F_{i-1/2}$ is determined by the reconstruction in cell $i-1$:\n$$\nF_{i-1/2} = a U_{i-1/2}^L = a \\left(U_{i-1} + \\frac{s_{i-1}}{2}\\right)\n$$\nThe full semi-discrete update is thus:\n$$\n\\frac{d U_i}{dt} = -\\frac{a}{\\Delta x} \\left[ \\left(U_i + \\frac{s_i}{2}\\right) - \\left(U_{i-1} + \\frac{s_{i-1}}{2}\\right) \\right]\n$$\n\n**3. TVD Slope Limiters**\n\nTo prevent spurious oscillations and ensure the Total Variation Diminishing (TVD) property, the slope $s_i$ is limited. The slope is computed based on the differences between neighboring cell averages: the backward difference $\\Delta_i^- = U_i - U_{i-1}$ and the forward difference $\\Delta_i^+ = U_{i+1} - U_i$. The limited slope is $s_i = \\text{limiter}(\\Delta_i^-, \\Delta_i^+)$. The problem specifies three options:\n\n- **Minmod Limiter:** This is the most dissipative limiter.\n  $$\n  s_i = \\text{minmod}(\\Delta_i^-, \\Delta_i^+) = \\begin{cases} \\text{sgn}(\\Delta_i^-) \\min(|\\Delta_i^-|, |\\Delta_i^+|) & \\text{if } \\Delta_i^- \\Delta_i^+ > 0 \\\\ 0 & \\text{if } \\Delta_i^- \\Delta_i^+ \\le 0 \\end{cases}\n  $$\n- **Van Leer Limiter:** A smooth limiter that provides a good balance between accuracy and monotonicity.\n  $$\n  s_i = \\begin{cases} \\frac{2 \\Delta_i^- \\Delta_i^+}{\\Delta_i^- + \\Delta_i^+} & \\text{if } \\Delta_i^- \\Delta_i^+ > 0 \\\\ 0 & \\text{if } \\Delta_i^- \\Delta_i^+ \\le 0 \\end{cases}\n  $$\n- **Monotonized Central (MC) Limiter:** This limiter is less dissipative and aims to recover a central-difference slope where possible without introducing oscillations.\n  $$\n  s_i = \\text{minmod}\\left(2\\Delta_i^-, 2\\Delta_i^+, \\frac{\\Delta_i^- + \\Delta_i^+}{2}\\right)\n  $$\n  where the multi-argument minmod function returns the argument with the smallest magnitude if all arguments have the same sign, and zero otherwise.\n\n**4. Temporal Integration: SSP Runge-Kutta 2**\n\nThe semi-discrete system is a set of ordinary differential equations of the form $\\frac{dU}{dt} = L(U)$, where $L(U)$ is the spatial operator (the right-hand side). This system is integrated in time using a second-order Strong Stability Preserving Runge-Kutta (SSP-RK2) method, also known as Heun's method.\n$$\n\\begin{aligned}\nU^{(1)} &= U^n + \\Delta t \\, L(U^n) \\\\\nU^{n+1} &= \\frac{1}{2} U^n + \\frac{1}{2} \\left( U^{(1)} + \\Delta t \\, L(U^{(1)}) \\right)\n\\end{aligned}\n$$\nThe time step $\\Delta t$ is determined by the Courant-Friedrichs-Lewy (CFL) condition for stability:\n$$\n\\Delta t = \\text{CFL} \\frac{\\Delta x}{|a|}\n$$\nwhere the $\\text{CFL}$ number is a user-specified parameter, required to be less than or equal to $1$ for this explicit scheme.\n\n**5. Error Analysis and Convergence Rate Estimation**\n\nThe accuracy of the numerical solution $U_i(T)$ is quantified by measuring the discrete $L_1$ and $L_2$ error norms against the exact solution $U_i^{\\text{exact}}(T) = u(x_i, T)$ evaluated at cell centers $x_i = (i+0.5)\\Delta x$.\n$$\nE_{1}(N) = \\Delta x \\sum_{i=0}^{N-1} \\left| U_i(T) - U_i^{\\text{exact}}(T) \\right|, \\quad E_{2}(N) = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left( U_i(T) - U_i^{\\text{exact}}(T) \\right)^2 \\right)^{1/2}\n$$\nThe order of convergence, $p$, is defined by the relation $E \\propto (\\Delta x)^p$. Taking the logarithm gives $\\log(E) \\approx p \\log(\\Delta x) + \\text{const}$. Thus, $p$ is the slope of a log-log plot of error versus mesh size. A linear regression is performed on the data points $(\\log(\\Delta x_k), \\log(E_k))$ for a sequence of mesh refinements $N_k$, where $\\Delta x_k = L/N_k$. The computed slope of this fit is the estimated order of convergence, which for a second-order scheme on a smooth solution is expected to be approximately 2.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    test_cases = [\n        {\"limiter\": \"minmod\", \"cfl\": 0.5, \"sigma\": 0.05, \"x0\": 0.25, \"N_list\": [50, 100, 200, 400]},\n        {\"limiter\": \"van_leer\", \"cfl\": 0.8, \"sigma\": 0.08, \"x0\": 0.25, \"N_list\": [50, 100, 200, 400]},\n        {\"limiter\": \"mc\", \"cfl\": 0.4, \"sigma\": 0.03, \"x0\": 0.25, \"N_list\": [50, 100, 200, 400]},\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        rates = compute_convergence_rates(case)\n        all_results.append(rates)\n\n    # Format the final output string exactly as required.\n    result_strings = [f\"[{r[0]},{r[1]}]\" for r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef compute_convergence_rates(params):\n    \"\"\"\n    Computes convergence rates for a given set of parameters over a list of mesh sizes.\n    \"\"\"\n    L = 1.0\n    errors_l1 = []\n    errors_l2 = []\n    dx_values = []\n\n    for N in params[\"N_list\"]:\n        dx = L / N\n        U_final = run_simulation(\n            N=N,\n            limiter_type=params[\"limiter\"],\n            cfl=params[\"cfl\"],\n            sigma=params[\"sigma\"],\n            x0=params[\"x0\"]\n        )\n        \n        # Cell centers\n        x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n        \n        # Exact solution at final time T=L (is the same as initial condition)\n        U_exact = np.exp(-((x - params[\"x0\"])**2) / (2 * params[\"sigma\"]**2))\n        \n        # Compute error norms\n        error_l1 = dx * np.sum(np.abs(U_final - U_exact))\n        error_l2 = np.sqrt(dx * np.sum((U_final - U_exact)**2))\n        \n        errors_l1.append(error_l1)\n        errors_l2.append(error_l2)\n        dx_values.append(dx)\n\n    # Convert to log scale for linear regression\n    log_dx = np.log(dx_values)\n    log_e1 = np.log(errors_l1)\n    log_e2 = np.log(errors_l2)\n    \n    # Fit line and get slope. The slope of log(error) vs log(dx) is the rate of convergence.\n    slope1 = linregress(log_dx, log_e1).slope\n    slope2 = linregress(log_dx, log_e2).slope\n    \n    p1 = slope1\n    p2 = slope2\n    \n    return [p1, p2]\n\ndef run_simulation(N, limiter_type, cfl, sigma, x0):\n    \"\"\"\n    Runs a single finite volume simulation.\n    \"\"\"\n    L = 1.0\n    a = 1.0\n    T = 1.0\n    \n    dx = L / N\n    dt = cfl * dx / np.abs(a)\n    num_steps = int(np.ceil(T / dt))\n    dt = T / num_steps  # Adjust dt to hit T exactly\n\n    # Initial condition at cell centers\n    x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n    U = np.exp(-((x - x0)**2) / (2 * sigma**2))\n\n    limiters = {\n        \"minmod\": minmod_limiter,\n        \"van_leer\": van_leer_limiter,\n        \"mc\": mc_limiter\n    }\n    limiter = limiters[limiter_type]\n\n    # Time integration loop (SSP-RK2)\n    for _ in range(num_steps):\n        # Stage 1\n        rhs1 = get_rhs(U, a, dx, limiter)\n        U1 = U + dt * rhs1\n        \n        # Stage 2\n        rhs2 = get_rhs(U1, a, dx, limiter)\n        U = 0.5 * U + 0.5 * (U1 + dt * rhs2)\n        \n    return U\n\ndef get_rhs(U, a, dx, limiter):\n    \"\"\"\n    Calculates the right-hand side of the semi-discrete equation dU/dt = L(U).\n    \"\"\"\n    N = len(U)\n    \n    # Apply periodic boundary conditions using np.roll for vectorization\n    U_m = np.roll(U, 1)  # U_{i-1}\n    U_p = np.roll(U, -1) # U_{i+1}\n    \n    # Compute backward and forward differences for slope calculation\n    delta_m = U - U_m\n    delta_p = U_p - U\n    \n    # Compute limited slopes for all cells\n    s = limiter(delta_m, delta_p)\n    \n    # Slopes from the cell to the left\n    s_m = np.roll(s, 1) # s_{i-1}\n    \n    # Reconstruct values at interfaces (since a>0, we need the left state)\n    # Value at right-side interface of cell i: U_{i+1/2}^L\n    U_L_iphalf = U + s / 2.0\n    \n    # Fluxes at the right interface of each cell\n    F_iphalf = a * U_L_iphalf\n    \n    # Fluxes at the left interface of each cell, which is the right flux of the cell to the left\n    F_imhalf = np.roll(F_iphalf, 1)\n\n    # RHS of the semi-discrete FVM update\n    rhs = -(F_iphalf - F_imhalf) / dx\n    return rhs\n\n# --- TVD Limiter Functions ---\ndef minmod_limiter(a, b):\n    # sgn(a) and sgn(b) are +1, -1, or 0\n    # The term (np.sign(a) + np.sign(b)) / 2 is 1 if both >0, -1 if both 0, 0 otherwise\n    return (np.sign(a) + np.sign(b)) / 2.0 * np.minimum(np.abs(a), np.abs(b))\n\ndef van_leer_limiter(a, b):\n    # This limiter is harmonic mean of the slopes\n    num = 2 * a * b\n    den = a + b\n    # Create result array, default to 0\n    result = np.zeros_like(a)\n    # Mask where denominator is non-zero and signs are the same (a*b > 0)\n    # Add a small epsilon to denominator to prevent division by zero in edge cases\n    mask = (a * b > 0)\n    result[mask] = num[mask] / (den[mask] + 1e-12)\n    return result\n\ndef mc_limiter(a, b):\n    # Monotonized Central limiter\n    # s = minmod(2a, 2b, (a+b)/2)\n    # Implemented by chaining the two-argument minmod\n    c = (a + b) / 2.0\n    return minmod_limiter(minmod_limiter(2 * a, 2 * b), c)\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "High-resolution schemes are prized for their ability to capture sharp discontinuities like shock waves, a ubiquitous feature in aerospace applications. Having verified our scheme's accuracy for smooth flows, we now turn to this more demanding task. This advanced practice  investigates the performance of a MUSCL-Roe scheme on the nonlinear Burgers' equation, focusing on a crucial metric: the accuracy of the numerical shock speed. You will dissect the total error in the shock's propagation speed, decomposing it into components arising from the reconstruction and the numerical flux, providing deep insight into the mechanisms of shock-capturing.",
            "id": "3978835",
            "problem": "Consider the scalar nonlinear conservation law used as a canonical model for shock-capturing analysis in aerospace computational fluid dynamics, the inviscid Burgers equation,\n$$\nu_t + \\left(\\frac{u^2}{2}\\right)_x = 0,\n$$\nwhere $u$ is dimensionless. Let the computational method be a finite volume scheme with Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) high-resolution reconstruction and Roe's approximate Riemann solver (Roe).\n\nFundamental base:\n- Conservation and finite volume update over a cell of width $\\Delta x$ with numerical interface flux $F_{i+1/2}$:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right).\n$$\n- Rankine–Hugoniot condition for a discontinuity moving with speed $s$:\n$$\ns \\left[ u \\right] = \\left[ f(u) \\right], \\quad f(u) = \\frac{u^2}{2},\n$$\nso for a Riemann problem with left state $u_L$ and right state $u_R$, the exact shock speed is\n$$\ns_{\\text{exact}} = \\frac{f(u_R)-f(u_L)}{u_R-u_L} = \\frac{u_L + u_R}{2}.\n$$\n\nMUSCL reconstruction at interface $x_{i+1/2}$ uses limited slopes to build left and right states $u_{i+1/2}^-$ and $u_{i+1/2}^+$. Let the backward and forward differences be\n$$\n\\delta^-_i = \\bar{u}_i - \\bar{u}_{i-1}, \\quad \\delta^+_i = \\bar{u}_{i+1} - \\bar{u}_i,\n$$\nand define the ratio\n$$\nr_i = \\frac{\\delta^+_i}{\\delta^-_i},\n$$\nwith the convention that if $\\delta^-_i = 0$, the limited slope $s_i$ is taken to be 0. A Total Variation Diminishing (TVD) flux limiter $\\phi(r)$ maps $r$ to a slope factor:\n- Minmod limiter:\n$$\n\\phi_{\\text{minmod}}(r) = \\max\\left(0, \\min(1, r)\\right).\n$$\n- Van Leer limiter:\n$$\n\\phi_{\\text{vanleer}}(r) = \\frac{r + |r|}{1 + |r|}.\n$$\n- Monotonized Central (MC) limiter:\n$$\n\\phi_{\\text{mc}}(r) = \\max\\left(0, \\min\\left(\\frac{1+r}{2}, 2, 2r\\right)\\right).\n$$\n- Superbee limiter:\n$$\n\\phi_{\\text{superbee}}(r) = \\max\\left(0, \\min(2r, 1), \\min(r, 2)\\right).\n$$\n\nThe nominal MUSCL slopes are\n$$\ns_i = \\phi(r_i)\\,\\delta^-_i, \\quad s_{i+1} = \\phi(r_{i+1})\\,\\delta^-_{i+1},\n$$\nand a simple reconstruction bias parameter $b \\in [-1,1]$ is used to model asymmetry in reconstruction near shocks:\n$$\n\\tilde{s}_i = (1+b)\\,s_i, \\quad \\tilde{s}_{i+1} = (1-b)\\,s_{i+1}.\n$$\nThe reconstructed interface states are\n$$\nu_{i+1/2}^- = \\bar{u}_i + \\frac{1}{2}\\tilde{s}_i, \\quad u_{i+1/2}^+ = \\bar{u}_{i+1} - \\frac{1}{2}\\tilde{s}_{i+1}.\n$$\n\nRoe’s approximate Riemann solver for the scalar Burgers flux uses the Roe average wave speed\n$$\na = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2},\n$$\nand the dissipation-scaled numerical flux\n$$\n\\hat{F}_{i+1/2} = \\frac{1}{2}\\left(f(u_{i+1/2}^-) + f(u_{i+1/2}^+)\\right) - \\frac{1}{2}\\lambda\\,|a|\\left(u_{i+1/2}^+ - u_{i+1/2}^-\\right),\n$$\nwhere $\\lambda \\in [0,1]$ scales the Roe dissipation magnitude.\n\nAssume a shock located at $x_{i+1/2}$ with left plateau state $\\bar{u}_i = u_L$ and right plateau state $\\bar{u}_{i+1} = u_R$. Using mass balance for the left cell, relate the shock speed to fluxes via\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\frac{s\\,\\Delta t}{\\Delta x}(u_R - u_L) = -\\frac{\\Delta t}{\\Delta x}\\left(\\hat{F}_{i+1/2} - f(u_L)\\right),\n$$\nwhich yields an operational definition of the numerical shock speed\n$$\ns_{\\text{num}} = -\\frac{\\hat{F}_{i+1/2} - f(u_L)}{u_R - u_L}.\n$$\n\nTo isolate contributions, define a reconstruction-bias-only shock speed obtained by substituting reconstructed states into the Rankine–Hugoniot relation,\n$$\ns_{\\text{rb}} = \\frac{f(u_{i+1/2}^+) - f(u_{i+1/2}^-)}{u_{i+1/2}^+ - u_{i+1/2}^-} = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2},\n$$\nand a dissipation magnitude\n$$\nD = \\frac{1}{2}\\lambda\\,|a|\\,\\left|u_{i+1/2}^+ - u_{i+1/2}^-\\right|.\n$$\nThe total numerical shock speed error is\n$$\n\\varepsilon_s = s_{\\text{num}} - s_{\\text{exact}},\n$$\nwhich can be decomposed into the reconstruction-bias component\n$$\n\\varepsilon_{\\text{bias}} = s_{\\text{rb}} - s_{\\text{exact}},\n$$\nand the flux-dissipation-plus-averaging component\n$$\n\\varepsilon_{\\text{flux}} = s_{\\text{num}} - s_{\\text{rb}}.\n$$\n\nTask:\n- Implement a program that, for the provided test suite, computes for each case the list of four floats $[\\varepsilon_s, \\varepsilon_{\\text{bias}}, \\varepsilon_{\\text{flux}}, D]$.\n\nUse the following test suite, where each case specifies $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}, \\text{limiter}, b, \\lambda)$:\n- Case $1$ (strong shock, baseline minmod): $(3, 3, 0, 0, \\text{\"minmod\"}, 0, 1)$.\n- Case $2$ (strong shock, positive bias): $(3, 3, 0, 0, \\text{\"minmod\"}, 0.5, 1)$.\n- Case $3$ (strong shock, van Leer limiter): $(3, 3, 0, 0, \\text{\"vanleer\"}, 0, 1)$.\n- Case $4$ (strong shock, reduced dissipation, MC limiter): $(3, 3, 0, 0, \\text{\"mc\"}, 0, 0.5)$.\n- Case $5$ (stationary shock edge case, superbee): $(1, 1, -1, -1, \\text{\"superbee\"}, 0, 1)$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of the four floats for a case, for example $[[x_{11},x_{12},x_{13},x_{14}],[x_{21},x_{22},x_{23},x_{24}],\\dots]$. The program must use exactly the test suite above and print the single line in the specified format.",
            "solution": "The problem is valid as it is scientifically grounded in the established theory of numerical methods for conservation laws, is well-posed with a complete and consistent set of definitions and data, and is expressed in objective, formal language. We may, therefore, proceed with a solution.\n\nThe core task is to compute components of the numerical shock speed error for a Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) finite volume method applied to the inviscid Burgers equation, $u_t + (\\frac{1}{2}u^2)_x = 0$. The physical flux function is $f(u) = \\frac{1}{2}u^2$. For each test case, we must calculate the total error $\\varepsilon_s$, the reconstruction-bias error $\\varepsilon_{\\text{bias}}$, the flux-dissipation error $\\varepsilon_{\\text{flux}}$, and the dissipation magnitude $D$.\n\nThe computational procedure for each test case $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}, \\text{limiter}, b, \\lambda)$ is as follows:\n\n1.  **Identify Plateau States and Exact Shock Speed:** The problem specifies a shock located at the interface $x_{i+1/2}$, with plateau states $u_L = \\bar{u}_i$ and $u_R = \\bar{u}_{i+1}$. The exact shock speed from the Rankine-Hugoniot condition is:\n    $$\n    s_{\\text{exact}} = \\frac{u_L + u_R}{2}\n    $$\n\n2.  **MUSCL Reconstruction:** The reconstruction provides states $u_{i+1/2}^-$ and $u_{i+1/2}^+$ at the left and right sides of the interface $x_{i+1/2}$. This involves several steps:\n    a.  **Compute differences and ratios:** We need slopes for cells $i$ and $i+1$. The ratio $r_i$ is defined as $r_i = (\\bar{u}_{i+1} - \\bar{u}_i) / (\\bar{u}_i - \\bar{u}_{i-1})$.\n        -   For cell $i$, using stencil $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1})$: $\\delta^-_i = \\bar{u}_i - \\bar{u}_{i-1}$ and $\\delta^+_i = \\bar{u}_{i+1} - \\bar{u}_i$.\n        -   For cell $i+1$, using stencil $(\\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2})$: $\\delta^-_{i+1} = \\bar{u}_{i+1} - \\bar{u}_i$ and $\\delta^+_{i+1} = \\bar{u}_{i+2} - \\bar{u}_{i+1}$.\n    b.  **Apply Flux Limiter:** The specified flux limiter function $\\phi(r)$ is applied to the ratios $r_i$ and $r_{i+1}$ to obtain slope modification factors. Per the problem convention, if the denominator of a ratio is zero, the corresponding slope is set to zero.\n    c.  **Calculate Biased Slopes:** The nominal slopes $s_i = \\phi(r_i)\\delta^-_i$ and $s_{i+1} = \\phi(r_{i+1})\\delta^-_{i+1}$ are computed and then biased using the parameter $b$:\n        $$\n        \\tilde{s}_i = (1+b)s_i, \\quad \\tilde{s}_{i+1} = (1-b)s_{i+1}\n        $$\n    d.  **Determine Interface States:** The reconstructed states are then found:\n        $$\n        u_{i+1/2}^- = \\bar{u}_i + \\frac{1}{2}\\tilde{s}_i, \\quad u_{i+1/2}^+ = \\bar{u}_{i+1} - \\frac{1}{2}\\tilde{s}_{i+1}\n        $$\n\n3.  **Roe's Approximate Riemann Solver:**\n    a.  **Compute Roe Average and Numerical Flux:** The Roe average wave speed for Burgers' equation is $a = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2}$. The numerical flux is:\n        $$\n        \\hat{F}_{i+1/2} = \\frac{1}{2}\\left(f(u_{i+1/2}^-) + f(u_{i+1/2}^+)\\right) - \\frac{1}{2}\\lambda\\,|a|\\left(u_{i+1/2}^+ - u_{i+1/2}^-\\right)\n        $$\n    b.  **Compute Dissipation Magnitude:**\n        $$\n        D = \\frac{1}{2}\\lambda\\,|a|\\,\\left|u_{i+1/2}^+ - u_{i+1/2}^-\\right|\n        $$\n\n4.  **Calculate Numerical Shock Speeds and Errors:**\n    a.  **Reconstruction-Bias Speed:** This speed is derived from the reconstructed states:\n        $$\n        s_{\\text{rb}} = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2} = a\n        $$\n    b.  **Numerical Shock Speed:** This is operationally defined from the finite volume update:\n        $$\n        s_{\\text{num}} = -\\frac{\\hat{F}_{i+1/2} - f(u_L)}{u_R - u_L}\n        $$\n    c.  **Error Components:** The errors are then calculated as:\n        $$\n        \\varepsilon_{\\text{bias}} = s_{\\text{rb}} - s_{\\text{exact}}\n        $$\n        $$\n        \\varepsilon_{\\text{flux}} = s_{\\text{num}} - s_{\\text{rb}}\n        $$\n        $$\n        \\varepsilon_s = s_{\\text{num}} - s_{\\text{exact}} = \\varepsilon_{\\text{bias}} + \\varepsilon_{\\text{flux}}\n        $$\n\nLet us demonstrate the calculation for **Case 1**: $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}) = (3, 3, 0, 0)$, limiter = \"minmod\", $b=0$, $\\lambda=1$.\n\n1.  **Exact Speed:** $u_L = \\bar{u}_i = 3$, $u_R = \\bar{u}_{i+1} = 0$.\n    $s_{\\text{exact}} = (3 + 0) / 2 = 1.5$.\n\n2.  **Reconstruction:**\n    a.  For cell $i$: $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}) = (3, 3, 0)$. $\\delta^-_i = 3 - 3 = 0$. According to the convention, since the denominator of $r_i$ is zero, the slope $s_i$ is 0.\n    b.  For cell $i+1$: $(\\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}) = (3, 0, 0)$. $\\delta^-_{i+1} = 0 - 3 = -3$. $\\delta^+_{i+1} = 0 - 0 = 0$. The ratio is $r_{i+1} = \\delta^+_{i+1} / \\delta^-_{i+1} = 0 / (-3) = 0$.\n    c.  Limiter: $\\phi_{\\text{minmod}}(0) = \\max(0, \\min(1, 0)) = 0$.\n    d.  Slopes: $s_i = 0$. $s_{i+1} = \\phi(r_{i+1})\\delta^-_{i+1} = 0 \\cdot (-3) = 0$. Since $b=0$, $\\tilde{s}_i = 0$ and $\\tilde{s}_{i+1} = 0$.\n    e.  Interface States: $u_{i+1/2}^- = 3 + \\frac{1}{2}(0) = 3$. $u_{i+1/2}^+ = 0 - \\frac{1}{2}(0) = 0$. The reconstruction reverts to first-order (Godunov-type).\n\n3.  **Roe Solver:**\n    a.  $a = (3+0)/2 = 1.5$. $f(u^-) = 3^2/2 = 4.5$, $f(u^+) = 0^2/2 = 0$.\n    b.  $\\hat{F}_{i+1/2} = \\frac{1}{2}(4.5+0) - \\frac{1}{2}(1)|1.5|(0-3) = 2.25 - 0.75(-3) = 2.25+2.25 = 4.5$. This corresponds to the upwind flux $f(u_L)$ for a supersonic shock.\n    c.  $D = \\frac{1}{2}(1)|1.5||0-3| = 2.25$.\n\n4.  **Speeds and Errors:**\n    a.  $s_{\\text{rb}} = a = 1.5$.\n    b.  $f(u_L) = 4.5$. $s_{\\text{num}} = -(4.5 - 4.5)/(0-3) = 0$.\n    c.  $\\varepsilon_{\\text{bias}} = s_{\\text{rb}} - s_{\\text{exact}} = 1.5 - 1.5 = 0$.\n    d.  $\\varepsilon_{\\text{flux}} = s_{\\text{num}} - s_{\\text{rb}} = 0 - 1.5 = -1.5$.\n    e.  $\\varepsilon_s = s_{\\text{num}} - s_{\\text{exact}} = 0 - 1.5 = -1.5$.\n\nThe result for Case 1 is $[\\varepsilon_s, \\varepsilon_{\\text{bias}}, \\varepsilon_{\\text{flux}}, D] = [-1.5, 0.0, -1.5, 2.25]$. A similar procedure is followed for the other test cases. For this data stencil, all limiters produce zero slopes, so the reconstruction error component is zero unless a non-zero bias $b$ is introduced. The final values are computed by implementing this logic in a program.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes numerical shock speed errors for a MUSCL-Roe scheme on the Burgers equation.\n    \"\"\"\n\n    # --- Limiter Functions ---\n    def phi_minmod(r):\n        return np.max([0.0, np.min([1.0, r])])\n\n    def phi_vanleer(r):\n        if np.isclose(1.0 + np.abs(r), 0): return 0.0\n        return (r + np.abs(r)) / (1.0 + np.abs(r))\n\n    def phi_mc(r):\n        return np.max([0.0, np.min([(1.0 + r) / 2.0, 2.0, 2.0 * r])])\n\n    def phi_superbee(r):\n        return np.max([0.0, np.min([2.0 * r, 1.0]), np.min([r, 2.0])])\n\n    limiters = {\n        \"minmod\": phi_minmod,\n        \"vanleer\": phi_vanleer,\n        \"mc\": phi_mc,\n        \"superbee\": phi_superbee\n    }\n\n    # --- Test Suite ---\n    test_cases = [\n        # (u_{i-1}, u_i, u_{i+1}, u_{i+2}), limiter, b, lambda\n        ((3.0, 3.0, 0.0, 0.0), \"minmod\", 0.0, 1.0),\n        ((3.0, 3.0, 0.0, 0.0), \"minmod\", 0.5, 1.0),\n        ((3.0, 3.0, 0.0, 0.0), \"vanleer\", 0.0, 1.0),\n        ((3.0, 3.0, 0.0, 0.0), \"mc\", 0.0, 0.5),\n        ((1.0, 1.0, -1.0, -1.0), \"superbee\", 0.0, 1.0)\n    ]\n\n    results = []\n\n    def physical_flux(u):\n        return 0.5 * u**2\n\n    for case in test_cases:\n        u_stencil, limiter_name, b, lam = case\n        u_im1, u_i, u_ip1, u_ip2 = u_stencil\n\n        # 1. Identify Plateau States and Exact Shock Speed\n        u_L = u_i\n        u_R = u_ip1\n        s_exact = 0.5 * (u_L + u_R)\n\n        # 2. MUSCL Reconstruction\n        phi_func = limiters[limiter_name]\n        \n        # Calculate slope for cell i\n        delta_minus_i = u_i - u_im1\n        delta_plus_i = u_ip1 - u_i\n        if np.isclose(delta_minus_i, 0.0):\n            s_i = 0.0\n        else:\n            r_i = delta_plus_i / delta_minus_i\n            s_i = phi_func(r_i) * delta_minus_i\n            \n        # Calculate slope for cell i+1\n        delta_minus_ip1 = u_ip1 - u_i\n        delta_plus_ip1 = u_ip2 - u_ip1\n        if np.isclose(delta_minus_ip1, 0.0):\n            s_ip1 = 0.0\n        else:\n            r_ip1 = delta_plus_ip1 / delta_minus_ip1\n            s_ip1 = phi_func(r_ip1) * delta_minus_ip1\n\n        # Apply bias\n        s_tilde_i = (1.0 + b) * s_i\n        s_tilde_ip1 = (1.0 - b) * s_ip1\n\n        # Determine Interface States\n        u_minus = u_i + 0.5 * s_tilde_i\n        u_plus = u_ip1 - 0.5 * s_tilde_ip1\n\n        # 3. Roe's Approximate Riemann Solver\n        a = 0.5 * (u_minus + u_plus)\n        f_minus = physical_flux(u_minus)\n        f_plus = physical_flux(u_plus)\n        \n        F_hat = 0.5 * (f_minus + f_plus) - 0.5 * lam * np.abs(a) * (u_plus - u_minus)\n        D = 0.5 * lam * np.abs(a) * np.abs(u_plus - u_minus)\n\n        # 4. Calculate Numerical Shock Speeds and Errors\n        s_rb = a\n        \n        if np.isclose(u_R, u_L):\n            s_num = 0.0\n        else:\n            s_num = -(F_hat - physical_flux(u_L)) / (u_R - u_L)\n\n        eps_bias = s_rb - s_exact\n        eps_flux = s_num - s_rb\n        eps_s = s_num - s_exact\n        \n        results.append([eps_s, eps_bias, eps_flux, D])\n\n    formatted_results = [f\"[{','.join(f'{val:.12g}' for val in res)}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}