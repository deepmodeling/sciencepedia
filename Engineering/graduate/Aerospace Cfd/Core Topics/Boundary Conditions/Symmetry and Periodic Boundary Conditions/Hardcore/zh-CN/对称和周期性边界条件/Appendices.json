{
    "hands_on_practices": [
        {
            "introduction": "在不可压缩流动的计算流体动力学（CFD）求解器中，压力泊松方程是执行无散约束的关键。当在周期性域上求解此方程时，一个重要的问题出现了：并非所有源项都能保证解的存在。这个练习将引导你运用散度定理，推导出一个对于周期性边界条件下的泊松方程可解性至关重要的“相容性条件”。通过这个实践，你将深刻理解边界条件如何直接影响控制偏微分方程的适定性，并学会如何确保数值问题的数学基础是稳固的。",
            "id": "4000231",
            "problem": "在计算流体动力学 (CFD) 中，考虑一个密度恒定的流体在三重周期域 $\\Omega \\subset \\mathbb{R}^{3}$ 上的不可压缩纳维–斯托克斯方程，其在 $x$、$y$ 和 $z$ 方向上的周期长度分别为 $L_{x}$、$L_{y}$ 和 $L_{z}$。设速度场为 $\\boldsymbol{u}(\\boldsymbol{x},t)$，压力为 $p(\\boldsymbol{x},t)$，并假设所有场都具有与域相同的空间周期性。在投影法或分数步长法中，为了强制执行不可压缩性，从动量方程和连续性方程可以得到一个形式如下的压力泊松方程\n$$\n\\nabla^{2} p(\\boldsymbol{x},t) \\;=\\; f(\\boldsymbol{x},t)\n$$\n在周期性边界条件下，未知量 $p$ 的定义可以相差一个任意常数。\n\n仅使用不可压缩性约束、动量方程和场的周期性，推导此泊松方程在周期性边界条件下可解时，源项 $f$ 必须满足的充分必要相容性条件。\n\n然后，为了量化非零均值源的影响，考虑在周期性边界条件的域 $\\Omega = [0,2\\pi]$ 上的一维版本，并设源项为\n$$\nf(x) \\;=\\; a \\;+\\; b \\cos(x) \\;+\\; c \\cos^{2}(x),\n$$\n其中 $a$，$b$ 和 $c$ 是常数。确定为满足您推导的相容性条件，从而使周期性泊松问题可解，必须选择的 $a$ 的唯一值（用 $b$ 和 $c$ 的闭式表示）。将您的最终答案表示为单个无单位的闭式解析表达式。",
            "solution": "该问题分为两部分。第一部分要求推导三重周期域上泊松方程的相容性条件。第二部分要求将此条件应用于一个特定的一维情况以求出参数值。\n\n第 1 部分：相容性条件的推导\n\n给定三重周期域 $\\Omega \\subset \\mathbb{R}^{3}$ 上的压力泊松方程：\n$$\n\\nabla^{2} p(\\boldsymbol{x},t) = f(\\boldsymbol{x},t)\n$$\n该域在 $x$，$y$ 和 $z$ 方向上的周期分别为 $L_x$，$L_y$ 和 $L_z$。场 $p$ 和 $f$ 具有相同的周期性。\n\n为了推导解 $p$ 存在的相容性条件，我们在整个域 $\\Omega$ 上对该方程的两边进行积分：\n$$\n\\int_{\\Omega} \\nabla^{2} p \\,dV = \\int_{\\Omega} f \\,dV\n$$\n这里，$dV$ 是体积微元。\n\n该方程的左侧可以使用散度定理进行变换。散度定理指出，对于矢量场 $\\boldsymbol{F}$，有 $\\int_{V} (\\boldsymbol{\\nabla} \\cdot \\boldsymbol{F}) \\,dV = \\oint_{\\partial V} \\boldsymbol{F} \\cdot \\boldsymbol{n} \\,dS$，其中 $\\partial V$ 是体积 $V$ 的边界，$\\boldsymbol{n}$ 是外向单位法向量。我们将拉普拉斯算子视为梯度的散度，即 $\\nabla^{2} p = \\boldsymbol{\\nabla} \\cdot (\\boldsymbol{\\nabla} p)$。应用散度定理，令 $\\boldsymbol{F} = \\boldsymbol{\\nabla} p$，我们得到：\n$$\n\\int_{\\Omega} \\nabla^{2} p \\,dV = \\int_{\\Omega} \\boldsymbol{\\nabla} \\cdot (\\boldsymbol{\\nabla} p) \\,dV = \\oint_{\\partial \\Omega} (\\boldsymbol{\\nabla} p) \\cdot \\boldsymbol{n} \\,dS\n$$\n周期性盒子 $\\Omega = [0, L_x] \\times [0, L_y] \\times [0, L_z]$ 的边界 $\\partial \\Omega$ 由三对相对的面组成（例如，在 $x=0$ 处的面和在 $x=L_x$ 处的面）。让我们计算其中一对面上的面积分，例如垂直于 $x$ 轴的那对面。在 $x=0$ 处，外向法向量为 $\\boldsymbol{n} = -\\boldsymbol{e}_x$；在 $x=L_x$ 处，外向法向量为 $\\boldsymbol{n} = \\boldsymbol{e}_x$。这对面积分所做的贡献是：\n$$\n\\int_{0}^{L_z} \\int_{0}^{L_y} \\left[ (\\boldsymbol{\\nabla} p)|_{x=L_x} \\cdot \\boldsymbol{e}_x + (\\boldsymbol{\\nabla} p)|_{x=0} \\cdot (-\\boldsymbol{e}_x) \\right] dy \\,dz = \\int_{0}^{L_z} \\int_{0}^{L_y} \\left[ \\frac{\\partial p}{\\partial x}\\bigg|_{x=L_x, y, z} - \\frac{\\partial p}{\\partial x}\\bigg|_{x=0, y, z} \\right] dy \\,dz\n$$\n由于指定的周期性边界条件，$p$ 压力场及其导数在相对边界上必须具有相同的值。因此，对于任意 $(y,z)$：\n$$\n\\frac{\\partial p}{\\partial x}(L_x, y, z) = \\frac{\\partial p}{\\partial x}(0, y, z)\n$$\n这使得上述被积函数处处为零，因此，这对面上的积分为零。同样的道理也适用于 $y$ 和 $z$ 方向上的对面。因此，整个面积分为零：\n$$\n\\oint_{\\partial \\Omega} (\\boldsymbol{\\nabla} p) \\cdot \\boldsymbol{n} \\,dS = 0\n$$\n结合我们的结果，我们有 $\\int_{\\Omega} \\nabla^{2} p \\,dV = 0$。这直接导出了源项 $f$ 的相容性条件：\n$$\n\\int_{\\Omega} f(\\boldsymbol{x},t) \\,dV = 0\n$$\n这是解存在的必要条件。根据 Fredholm 择一性，它也是一个充分条件。带有周期性边界条件的算子 $\\nabla^{2}$ 是自伴的。其零空间是常数函数集。$\\nabla^{2}p = f$ 的解存在的充分必要条件是 $f$ 与伴随算子的零空间正交。对于自伴的拉普拉斯算子，这意味着 $f$ 必须与常数函数正交，这正是条件 $\\int_{\\Omega} f \\cdot 1 \\,dV = 0$。该条件意味着源项在域上的空间平均值必须为零。\n\n第 2 部分：在一维情况下的应用\n\n我们现在考虑在域 $\\Omega = [0, 2\\pi]$ 上具有周期性边界条件的一维 ($1$D) 问题。泊松方程变为：\n$$\n\\frac{d^{2}p}{dx^{2}} = f(x)\n$$\n源项给定为：\n$$\nf(x) = a + b \\cos(x) + c \\cos^{2}(x)\n$$\n其中 $a$，$b$ 和 $c$ 是常数。在第 1 部分推导的相容性条件简化为：\n$$\n\\int_{0}^{2\\pi} f(x) \\,dx = 0\n$$\n我们代入 $f(x)$ 的表达式并计算积分：\n$$\n\\int_{0}^{2\\pi} \\left( a + b \\cos(x) + c \\cos^{2}(x) \\right) dx = 0\n$$\n我们可以逐项积分：\n$$\n\\int_{0}^{2\\pi} a \\,dx + \\int_{0}^{2\\pi} b \\cos(x) \\,dx + \\int_{0}^{2\\pi} c \\cos^{2}(x) \\,dx = 0\n$$\n第一个积分是：\n$$\n\\int_{0}^{2\\pi} a \\,dx = a[x]_{0}^{2\\pi} = 2\\pi a\n$$\n第二个积分是：\n$$\n\\int_{0}^{2\\pi} b \\cos(x) \\,dx = b[\\sin(x)]_{0}^{2\\pi} = b(\\sin(2\\pi) - \\sin(0)) = b(0-0) = 0\n$$\n对于第三个积分，我们使用三角恒等式 $\\cos^{2}(x) = \\frac{1}{2}(1 + \\cos(2x))$：\n$$\n\\int_{0}^{2\\pi} c \\cos^{2}(x) \\,dx = c \\int_{0}^{2\\pi} \\frac{1 + \\cos(2x)}{2} \\,dx = \\frac{c}{2} \\left[ x + \\frac{1}{2}\\sin(2x) \\right]_{0}^{2\\pi}\n$$\n$$\n= \\frac{c}{2} \\left[ \\left(2\\pi + \\frac{1}{2}\\sin(4\\pi)\\right) - \\left(0 + \\frac{1}{2}\\sin(0)\\right) \\right] = \\frac{c}{2} [ (2\\pi + 0) - (0 + 0) ] = c\\pi\n$$\n将这些结果代回相容性条件方程：\n$$\n2\\pi a + 0 + c\\pi = 0\n$$\n现在，我们解出 $a$：\n$$\n2\\pi a = -c\\pi\n$$\n$$\na = -\\frac{c\\pi}{2\\pi} = -\\frac{c}{2}\n$$\n因此，要使周期性泊松问题可解，常数 $a$ 必须等于 $-\\frac{c}{2}$。这一选择确保了源项 $f(x)$ 在周期 $[0, 2\\pi]$ 上的平均值为零。$b$ 的值不影响相容性条件，因为 $\\cos(x)$ 在一个完整周期内的平均值为零。",
            "answer": "$$\\boxed{-\\frac{c}{2}}$$"
        },
        {
            "introduction": "利用对称性可以显著降低CFD模拟的计算成本，但前提是必须为所有求解变量正确地施加对称边界条件。本练习从全局数学约束转向物理模型的局部边界条件，重点关注如何基于物理定义和反射对称原理，为诸如湍动能 $k$ 和耗散率 $\\epsilon$ 等标量湍流量推导恰当的边界条件。这项实践将加深你对如何一致地应用对称性论证的理解，以避免产生非物理效应，例如在对称面上产生虚假湍流。",
            "id": "4000247",
            "problem": "考虑一个不可压缩的统计定常流，该流体在一个三维域内由雷诺平均纳维-斯托克斯 (RANS) 方程控制，且该域关于平面 $y=0$ 镜像对称。设 $\\mathbf{x} = (x,y,z)$，并定义镜像映射 $\\mathcal{R}:(x,y,z)\\mapsto(x,-y,z)$。平均速度场为 $\\mathbf{U}(\\mathbf{x}) = (u(\\mathbf{x}), v(\\mathbf{x}), w(\\mathbf{x}))$，平均压力为 $p(\\mathbf{x})$，标准 $k$–$\\epsilon$ 模型中的湍动能和耗散率分别为 $k(\\mathbf{x})$ 和 $\\epsilon(\\mathbf{x})$。湍动能和耗散率定义为 $k = \\tfrac{1}{2}\\,\\overline{u_{i}'u_{i}'}$ 和 $\\epsilon = \\nu\\,\\overline{\\partial u_{i}'/\\partial x_{j}\\,\\partial u_{i}'/\\partial x_{j}}$，其中 $\\nu$ 是运动粘度，上划线表示雷诺平均，撇号表示脉动量，指标遵循爱因斯坦求和约定。涡粘性封闭采用广泛使用的形式 $\\nu_{t} = C_{\\mu}\\,k^{2}/\\epsilon$，其中常数 $C_{\\mu} > 0$。设平均应变率张量为 $S_{ij} = \\tfrac{1}{2}\\left(\\partial U_{i}/\\partial x_{j} + \\partial U_{j}/\\partial x_{i}\\right)$，并考虑湍流生成项 $P_{k}$。该项通过湍流应力与平均梯度的缩并进入 $k$ 输运方程，在涡粘性封闭中，它与 $S_{ij}S_{ij}$ 成正比，即 $P_{k} = 2\\,\\nu_{t}\\,S_{ij}S_{ij}$。\n\n假设流动、几何形状以及边界和强迫配置使得完整的 RANS-$k$–$\\epsilon$ 系统在镜像映射 $\\mathcal{R}$ 下保持不变，并且平均场在 $y=0$ 处满足镜像对称性，即标量是偶函数，矢量分量根据其在 $\\mathcal{R}$ 下的几何奇偶性进行变换。仅使用上述基本定律和核心定义，并强制控制方程在 $\\mathcal{R}$ 下的不变性，推导在平面 $y=0$ 处对变量 $\\mathbf{U}$、$p$、$k$ 和 $\\epsilon$ 的最小对称性一致边界条件集。这些条件应能保持镜像对称性，并消除在对称面上由法向-切向耦合引起的人为湍流生成。\n\n您的推导必须：\n- 识别镜像不变性所要求的每个场分量的奇偶性（在 $y\\mapsto -y$ 下是偶函数还是奇函数）。\n- 使用这些奇偶性来推导 $y=0$ 处的相应边界条件，用场的值或法向导数表示。\n- 证明在这些边界条件下，所有在 $y=0$ 处的混合法向-切向平均应变分量均为零，从而局部对称性不会通过法向-切向耦合对 $P_{k}$ 产生伪贡献。\n\n将您的最终答案表示为有序向量\n$$\\left[v|_{y=0}\\,,\\,\\frac{\\partial u}{\\partial y}\\bigg|_{y=0}\\,,\\,\\frac{\\partial w}{\\partial y}\\bigg|_{y=0}\\,,\\,\\frac{\\partial p}{\\partial y}\\bigg|_{y=0}\\,,\\,\\frac{\\partial k}{\\partial y}\\bigg|_{y=0}\\,,\\,\\frac{\\partial \\epsilon}{\\partial y}\\bigg|_{y=0}\\right],$$\n其中法向导数理解为在平面 $y=0$ 处的 $\\partial/\\partial y$。没有舍入要求。最终答案中不应包含物理单位。",
            "solution": "首先根据所需标准对问题进行验证。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- **域：** 一个三维域，关于平面 $y=0$ 镜像对称。\n- **镜像映射：** $\\mathcal{R}:(x,y,z)\\mapsto(x,-y,z)$。\n- **控制方程：** 不可压缩统计定常雷诺平均纳维-斯托克斯 (RANS) 方程。\n- **变量：** 平均速度 $\\mathbf{U}(\\mathbf{x}) = (u(\\mathbf{x}), v(\\mathbf{x}), w(\\mathbf{x}))$，平均压力 $p(\\mathbf{x})$，湍动能 $k(\\mathbf{x})$ 和耗散率 $\\epsilon(\\mathbf{x})$。\n- **定义：**\n    - 湍动能：$k = \\tfrac{1}{2}\\,\\overline{u_{i}'u_{i}'}$。\n    - 湍流耗散率：$\\epsilon = \\nu\\,\\overline{\\partial u_{i}'/\\partial x_{j}\\,\\partial u_{i}'/\\partial x_{j}}$。\n    - 涡粘度：$\\nu_{t} = C_{\\mu}\\,k^{2}/\\epsilon$，其中常数 $C_{\\mu} > 0$。\n    - 平均应变率张量：$S_{ij} = \\tfrac{1}{2}\\left(\\partial U_{i}/\\partial x_{j} + \\partial U_{j}/\\partial x_{i}\\right)$。\n    - 湍流生成：$P_{k} = 2\\,\\nu_{t}\\,S_{ij}S_{ij}$。\n- **假设：**\n    - RANS-$k$–$\\epsilon$ 系统在镜像映射 $\\mathcal{R}$ 下不变。\n    - 平均场在 $y=0$ 处满足镜像对称性：标量是偶函数，矢量分量根据其在 $\\mathcal{R}$ 下的几何奇偶性进行变换。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于湍流模拟的标准理论（RANS，$k$–$\\epsilon$ 模型）和流体动力学中对称性原理的应用，这是计算流体动力学（CFD）的核心课题。所用定义和概念均为标准且事实正确。\n- **适定性：** 该问题是适定的。它要求基于明确陈述的对称性假设推导出一组特定的边界条件。预期存在一个唯一的、有意义的解。\n- **客观性：** 该问题以精确、客观和技术性的语言陈述，没有歧义或主观论断。\n\n该问题没有表现出验证清单中列出的任何缺陷（例如，科学上不健全、不完整、矛盾等）。它在指定领域是一个有效且可形式化的问题。\n\n**第3步：结论与行动**\n问题被判定为**有效**。将提供一个完整的、有理有据的解答。\n\n### 解答推导\n\n推导过程首先根据指定的镜像对称性确定每个场变量的奇偶性，然后推导出在对称平面 $y=0$ 处的相应边界条件。最后，证明这些条件消除了由法向-切向应变耦合产生的伪湍流生成。\n\n**1. 场变量的奇偶性**\n\n问题陈述流场关于平面 $y=0$ 镜像对称，其镜像映射为 $\\mathcal{R}:(x,y,z)\\mapsto(x,-y,z)$。假设在此镜像反射下标量是偶函数，矢量分量根据其几何奇偶性进行变换。\n\n设 $\\phi(\\mathbf{x})=\\phi(x,y,z)$ 为一个通用场。\n- 如果一个标量场 $\\phi_{scalar}$ 在镜像反射下不变，即 $\\phi_{scalar}(x,-y,z) = \\phi_{scalar}(x,y,z)$，则称其为**偶函数**。\n- 矢量场 $\\mathbf{U}=(u,v,w)$ 按几何奇偶性变换。镜像映射 $\\mathcal{R}$ 将 $y$ 坐标取反，而保持 $x$ 和 $z$ 不变。因此，垂直于对称平面的矢量分量（$v$）必须是奇函数，而切向分量（$u, w$）必须是偶函数。\n\n将这些规则应用于我们关心的变量：\n- 平均压力 $p(\\mathbf{x})$、湍动能 $k(\\mathbf{x})$ 和耗散率 $\\epsilon(\\mathbf{x})$ 都是标量。因此，它们是关于 $y$ 的偶函数：\n  $$p(x,-y,z) = p(x,y,z)$$\n  $$k(x,-y,z) = k(x,y,z)$$\n  $$\\epsilon(x,-y,z) = \\epsilon(x,y,z)$$\n- 平均速度分量具有以下奇偶性：\n  - $u(x,y,z)$（切向）是**偶函数**：$u(x,-y,z) = u(x,y,z)$。\n  - $v(x,y,z)$（法向）是**奇函数**：$v(x,-y,z) = -v(x,y,z)$。\n  - $w(x,y,z)$（切向）是**偶函数**：$w(x,-y,z) = w(x,y,z)$。\n\n**2. 在 $y=0$ 处边界条件的推导**\n\n在平面 $y=0$ 处的边界条件由奇偶性推导得出。\n\n- 对任何关于 $y$ 的奇函数 $\\phi_{odd}(y)$，我们有 $\\phi_{odd}(-y) = -\\phi_{odd}(y)$。在 $y=0$ 处求值得到 $\\phi_{odd}(0) = -\\phi_{odd}(0)$，这意味着 $2\\phi_{odd}(0)=0$，所以 $\\phi_{odd}(0)=0$。\n- 对任何关于 $y$ 的连续可微偶函数 $\\phi_{even}(y)$，我们有 $\\phi_{even}(-y) = \\phi_{even}(y)$。使用链式法则对 $y$ 求导得到 $-\\phi_{even}'(-y) = \\phi_{even}'(y)$。这表明导数 $\\phi_{even}'(y)$ 是一个奇函数。在 $y=0$ 处求值得到 $-\\phi_{even}'(0) = \\phi_{even}'(0)$，这意味着 $2\\phi_{even}'(0)=0$，所以 $\\phi_{even}'(0)=0$。\n\n将这些数学事实应用于我们在对称平面 $y=0$ 处的场：\n\n- **$v$ 分量：** $v$ 是 $y$ 的奇函数。因此，其在 $y=0$ 处的值必须为零。\n  $$v|_{y=0} = 0$$\n- **$u$ 分量：** $u$ 是 $y$ 的偶函数。因此，它关于 $y$ 的偏导数（法向导数）必须是 $y$ 的奇函数，因而在 $y=0$ 处为零。\n  $$\\frac{\\partial u}{\\partial y}\\bigg|_{y=0} = 0$$\n- **$w$ 分量：** $w$ 是 $y$ 的偶函数。与 $u$ 类似，其法向导数在 $y=0$ 处必须为零。\n  $$\\frac{\\partial w}{\\partial y}\\bigg|_{y=0} = 0$$\n- **压力 $p$：** $p$ 是一个标量，且是 $y$ 的偶函数。因此，其法向导数在 $y=0$ 处必须为零。\n  $$\\frac{\\partial p}{\\partial y}\\bigg|_{y=0} = 0$$\n- **湍动能 $k$：** $k$ 是一个标量，且是 $y$ 的偶函数。其法向导数在 $y=0$ 处必须为零。\n  $$\\frac{\\partial k}{\\partial y}\\bigg|_{y=0} = 0$$\n- **耗散率 $\\epsilon$：** $\\epsilon$ 是一个标量，且是 $y$ 的偶函数。其法向导数在 $y=0$ 处必须为零。\n  $$\\frac{\\partial \\epsilon}{\\partial y}\\bigg|_{y=0} = 0$$\n\n**3. 消除人为的湍流生成**\n\n湍动能的生成项 $P_k$ 由 $P_k = 2\\,\\nu_{t}\\,S_{ij}S_{ij}$ 给出，其中 $S_{ij}$ 是平均应变率张量。我们必须证明上述推导出的边界条件消除了由法向（$y$ 方向，指标为 2）和切向（$x,z$ 方向，指标为 1, 3）速度梯度的耦合所产生的伪生成。\n\n应变率张量的相关分量是混合法向-切向项 $S_{12}$（也记作 $S_{xy}$）和 $S_{23}$（也记作 $S_{yz}$）。\n\n这些分量定义为：\n$$S_{12} = \\frac{1}{2}\\left(\\frac{\\partial U_1}{\\partial x_2} + \\frac{\\partial U_2}{\\partial x_1}\\right) = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right)$$\n$$S_{23} = \\frac{1}{2}\\left(\\frac{\\partial U_2}{\\partial x_3} + \\frac{\\partial U_3}{\\partial x_2}\\right) = \\frac{1}{2}\\left(\\frac{\\partial v}{\\partial z} + \\frac{\\partial w}{\\partial y}\\right)$$\n\n我们在对称平面 $y=0$ 处计算这些分量：\n根据上一节推导的边界条件，我们有：\n$$\\frac{\\partial u}{\\partial y}\\bigg|_{y=0} = 0 \\quad \\text{和} \\quad \\frac{\\partial w}{\\partial y}\\bigg|_{y=0} = 0$$\n\n现在我们必须计算 $v$ 在 $y=0$ 处的切向导数。由于 $v(x,y,z)$ 是 $y$ 的奇函数，我们有 $v(x,y,z) = -v(x,-y,z)$。对一个切向坐标（如 $x$）求偏导数，得到：\n$$\\frac{\\partial v}{\\partial x}(x,y,z) = \\frac{\\partial}{\\partial x}[-v(x,-y,z)] = -\\frac{\\partial v}{\\partial x}(x,-y,z)$$\n这表明 $\\frac{\\partial v}{\\partial x}$ 也是 $y$ 的一个奇函数。如前所述，任何 $y$ 的奇函数在 $y=0$ 处都必须为零。因此：\n$$\\frac{\\partial v}{\\partial x}\\bigg|_{y=0} = 0$$\n通过对 $z$ 导数进行相同的推理：\n$$\\frac{\\partial v}{\\partial z}\\bigg|_{y=0} = 0$$\n\n将这些结果代入 $S_{12}$ 和 $S_{23}$ 在 $y=0$ 处的表达式中：\n$$S_{12}\\bigg|_{y=0} = \\frac{1}{2}\\left(0 + 0\\right) = 0$$\n$$S_{23}\\bigg|_{y=0} = \\frac{1}{2}\\left(0 + 0\\right) = 0$$\n\n由于平均应变率张量的混合法向-切向分量在对称平面上恒为零，它们对生成项 $P_k$（与 $S_{12}^2$ 和 $S_{23}^2$ 成正比）的贡献也为零。这证实了所推导的对称性边界条件正确地防止了在对称平面上因法向-切向应变耦合而产生人为湍流。\n\n因此，最小的对称性一致边界条件集由上述推导出的值给出。最终答案是这些值的有序向量。\n- $v|_{y=0} = 0$\n- $\\frac{\\partial u}{\\partial y}\\big|_{y=0} = 0$\n- $\\frac{\\partial w}{\\partial y}\\big|_{y=0} = 0$\n- $\\frac{\\partial p}{\\partial y}\\big|_{y=0} = 0$\n- $\\frac{\\partial k}{\\partial y}\\big|_{y=0} = 0$\n- $\\frac{\\partial \\epsilon}{\\partial y}\\big|_{y=0} = 0$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  0  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在实际的CFD应用中，周期性界面两侧的网格节点往往无法完美对齐，这给数据交换带来了挑战。这个练习将带你进入一个面向实际应用的编程挑战：开发一个能够处理这种非匹配网格的算法，包括寻找最近邻点并确保通量的守恒性。通过实现一个稳健且守恒的耦合方案，并量化其几何误差，你将获得开发或使用高级CFD求解器所必需的宝贵实践技能。",
            "id": "4000218",
            "problem": "考虑用于计算流体动力学 (CFD) 耦合的两个离散化周期性界面，它们代表了一个恒定半径圆柱体上的施体 (donor) 表面和受体 (receiver) 表面。设施体界面由点集 $\\{(\\theta_i^d, z_i^d)\\}_{i=1}^{N_d}$（半径为 $R$）和一个标量场 $\\{q_i^d\\}_{i=1}^{N_d}$ 定义，该标量场代表一个无量纲的面积分量（例如，无量纲化的单位翼展质量通量）。设受体界面由点集 $\\{(\\theta_j^r, z_j^r)\\}_{j=1}^{N_r}$ 定义，其半径同样为 $R$。角度以弧度表示，所有距离均为无量纲，因为半径 $R$ 被视为单位长度。施体和受体之间的周期性变换由 $(\\Delta\\theta, \\Delta z)$ 指定，这定义了一种螺旋周期性：位于 $(\\theta_j^r, z_j^r)$ 的受体点应与在角坐标上模 $2\\pi$ 运算后，位于 $(\\theta_j^r - \\Delta\\theta, z_j^r - \\Delta z)$ 附近的施体点对齐。\n\n你的任务是实现一个稳健的最近邻搜索，对于每个受体点，该搜索在补偿周期性平移后，选择使欧几里得距离最小化的施体点。搜索必须在三维空间中进行，使用以下坐标：\n$$\nx = R\\cos\\theta, \\quad y = R\\sin\\theta, \\quad z = z,\n$$\n首先将受体坐标平移至：\n$$\n\\theta_j^{r*} = \\operatorname{wrap}_{[0,2\\pi)}(\\theta_j^r - \\Delta\\theta), \\quad z_j^{r*} = z_j^r - \\Delta z,\n$$\n其中 $\\operatorname{wrap}_{[0,2\\pi)}(\\cdot)$ 表示将角度环绕到区间 $[0,2\\pi)$ 内。\n\n对于每个受体索引 $j$，通过最小化欧几里得距离来定义最近邻映射 $i(j)$：\n$$\nd_{ij} = \\sqrt{(x_i^d - x_j^{r*})^2 + (y_i^d - y_j^{r*})^2 + (z_i^d - z_j^{r*})^2},\n$$\n并遵循确定性的平局打破规则：如果多个施体点对于给定的受体点达到相同的最小距离，则选择索引 $i$ 最小的施体点。使用此映射，计算以下指标：\n\n1. 均方根 (RMS) 几何失配\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_r}\\sum_{j=1}^{N_r} d_{i(j),j}^2}.\n$$\n\n2. 最大几何失配\n$$\n\\varepsilon_{\\infty} = \\max_{j=1,\\dots,N_r} d_{i(j),j}.\n$$\n\n3. 最大角度失配\n$$\n\\delta_{\\theta,\\infty} = \\max_{j=1,\\dots,N_r} \\min\\left(|\\theta_{i(j)}^d - \\theta_j^{r*}|,\\, 2\\pi - |\\theta_{i(j)}^d - \\theta_j^{r*}|\\right).\n$$\n\n4. 基于最近邻映射的全局守恒耦合。首先，通过最近邻传递来分配受体场：\n$$\n\\widetilde{q}_j^r = q_{i(j)}^d.\n$$\n然后计算一个全局缩放因子\n$$\ns = \\frac{\\sum_{i=1}^{N_d} q_i^d}{\\sum_{j=1}^{N_r} \\widetilde{q}_j^r},\n$$\n并设置守恒的受体场\n$$\nq_j^{r,\\mathrm{cons}} = s\\,\\widetilde{q}_j^r.\n$$\n最后，报告绝对守恒误差\n$$\n\\Delta_{\\mathrm{cons}} = \\left|\\sum_{j=1}^{N_r} q_j^{r,\\mathrm{cons}} - \\sum_{i=1}^{N_d} q_i^d\\right|.\n$$\n\n所有输出均为无量纲浮点数；角度必须以弧度为单位。所有计算仅使用确定性、可复现的公式实现；不要使用任何随机数。\n\n测试套件。你的程序必须为以下每组参数计算指标 $(\\varepsilon_{\\mathrm{RMS}}, \\varepsilon_{\\infty}, \\Delta_{\\mathrm{cons}}, \\delta_{\\theta,\\infty})$。对于每种情况，按所述定义施体和受体的点及场。\n\n情况 A (一般螺旋周期性，基数不匹配)：\n- $R = 1$.\n- $N_d = 64$，施体角度：$\\theta_i^d = \\frac{2\\pi i}{N_d}$，其中 $i=0,\\dots,N_d-1$；施体轴向位置：$z_i^d = A_d\\sin(k_d \\theta_i^d)$，其中 $A_d = 0.05, k_d = 5$。\n- $N_r = 70$，受体角度：$\\theta_j^r = \\frac{2\\pi j}{N_r} + \\gamma\\sin(\\lambda j)$，其中 $j=0,\\dots,N_r-1$，且 $\\gamma = \\frac{2\\pi}{2N_r^2}, \\lambda = 3$；受体轴向位置：$z_j^r = A_r\\sin(k_r \\theta_j^r)$，其中 $A_r = 0.05, k_r = 6$。\n- 周期性平移：$\\Delta\\theta = \\frac{\\pi}{7}$, $\\Delta z = 0.02$。\n- 施体标量场：$q_i^d = 1 + \\alpha\\sin(m\\,\\theta_i^d) + \\beta\\cos(p\\,z_i^d)$，其中 $\\alpha = 0.1, m = 3, \\beta = 0.05, p = 10$。\n\n情况 B (大角度环绕旋转，基数匹配，零轴向变化)：\n- $R = 1$.\n- $N_d = 8$，施体角度：$\\theta_i^d = \\frac{2\\pi i}{N_d}$；施体轴向位置：$z_i^d = 0$。\n- $N_r = 8$，受体角度：$\\theta_j^r = \\frac{2\\pi j}{N_r}$；受体轴向位置：$z_j^r = 0$。\n- 周期性平移：$\\Delta\\theta = \\frac{15\\pi}{8}$, $\\Delta z = 0$。\n- 施体标量场：$q_i^d = 1 + \\alpha\\sin(m\\,\\theta_i^d)$，其中 $\\alpha = 0.3, m = 4$。\n\n情况 C (平局打破边缘情况，多个受体点与两个施体点等距)：\n- $R = 1$.\n- $N_d = 4$，施体角度：$\\theta_i^d \\in \\{0, \\frac{\\pi}{2}, \\pi, \\frac{3\\pi}{2}\\}$；施体轴向位置：$z_i^d = 0$。\n- $N_r = 8$，受体角度：$\\theta_j^r \\in \\left\\{\\frac{\\pi}{4}, \\frac{3\\pi}{4}, \\frac{5\\pi}{4}, \\frac{7\\pi}{4}, \\frac{\\pi}{4}, \\frac{3\\pi}{4}, \\frac{5\\pi}{4}, \\frac{7\\pi}{4}\\right\\}$；受体轴向位置：$z_j^r = 0$。\n- 周期性平移：$\\Delta\\theta = 0$, $\\Delta z = 0$。\n- 施体标量场：$q_i^d = 1 + \\alpha\\cos(m\\,\\theta_i^d)$，其中 $\\alpha = 0.2, m = 2$。\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含所有情况的结果，格式为逗号分隔的浮点数列表的列表，顺序为情况 A、情况 B、情况 C。每个内部列表必须为 $[\\varepsilon_{\\mathrm{RMS}}, \\varepsilon_{\\infty}, \\Delta_{\\mathrm{cons}}, \\delta_{\\theta,\\infty}]$。单行输出必须采用以下形式：\n$$\n[\\,[\\varepsilon_{\\mathrm{RMS}}^{(A)}, \\varepsilon_{\\infty}^{(A)}, \\Delta_{\\mathrm{cons}}^{(A)}, \\delta_{\\theta,\\infty}^{(A)}], [\\varepsilon_{\\mathrm{RMS}}^{(B)}, \\varepsilon_{\\infty}^{(B)}, \\Delta_{\\mathrm{cons}}^{(B)}, \\delta_{\\theta,\\infty}^{(B)}], [\\varepsilon_{\\mathrm{RMS}}^{(C)}, \\varepsilon_{\\infty}^{(C)}, \\Delta_{\\mathrm{cons}}^{(C)}, \\delta_{\\theta,\\infty}^{(C)}]\\,].\n$$\n角度必须以弧度为单位。距离是无量纲的。守恒误差必须报告为浮点数（无量纲），并且由于全局缩放，其数值预期会接近 $0$。",
            "solution": "我们从计算流体动力学 (CFD) 中受守恒定律约束的周期性边界条件概念开始。基本原理是稳态流经周期性界面时的质量守恒。如果两个表面在对称变换下是周期性等效的，则守恒通量的净积分在该变换下必须是不变的。在离散设置中，这启发了一种能够保持离散化标量场总和的耦合方法。\n\n基础理论：考虑标量通量 $q$ 跨越两个表面 $S_d$ 和 $S_r$ 的积分守恒，这两个表面通过一个由旋转 $\\Delta\\theta$ 和轴向平移 $\\Delta z$ 定义的对称变换 $T_{\\Delta\\theta,\\Delta z}$ 相关联。对于一个在对称性下守恒的量，我们有\n$$\n\\int_{S_d} q\\,\\mathrm{d}A = \\int_{S_r} q\\circ T_{\\Delta\\theta,\\Delta z}^{-1}\\,\\mathrm{d}A.\n$$\n在离散形式中，控制面由点或面表示，守恒耦合旨在实现\n$$\n\\sum_{i=1}^{N_d} q_i^d \\approx \\sum_{j=1}^{N_r} q_j^r,\n$$\n其中从施体数据 $q_i^d$ 到受体数据 $q_j^r$ 的映射遵循周期性对称。当施体和受体的离散化不匹配（$N_d \\neq N_r$）时，挑战就出现了，这需要一种既能几何对齐点又能构造守恒传递的算法。\n\n周期性几何与最近邻原理：施体和受体点集位于半径为 $R$ 的圆上，其角坐标和轴向坐标通过以下方式给出 $(x,y,z)$：\n$$\nx = R\\cos\\theta,\\quad y = R\\sin\\theta,\\quad z = z.\n$$\n为强制执行周期性，受体点通过逆变换平移以在施体坐标中对齐：\n$$\n\\theta_j^{r*} = \\operatorname{wrap}_{[0,2\\pi)}(\\theta_j^r - \\Delta\\theta), \\quad z_j^{r*} = z_j^r - \\Delta z.\n$$\n施体点 $i$ 和平移后的受体点 $j$ 之间的三维空间欧几里得距离是\n$$\nd_{ij} = \\sqrt{(x_i^d - x_j^{r*})^2 + (y_i^d - y_j^{r*})^2 + (z_i^d - z_j^{r*})^2}.\n$$\n对每个 $j$，选择最近邻映射 $i(j)$ 以最小化 $d_{ij}$，并使用最小索引进行确定性平局打破。这种方法是稳健的，因为它在物理空间度量上操作，并通过 $\\operatorname{wrap}_{[0,2\\pi)}(\\cdot)$ 适当地处理角度周期性。\n\n几何失配度量：失配距离 $d_{i(j),j}$ 量化了几何失准。两个范数是相关的：\n\n- 均方根 (RMS) 失配：\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_r}\\sum_{j=1}^{N_r} d_{i(j),j}^2},\n$$\n它对距离的平方进行平均，并对分布式误差敏感。\n\n- 最大失配：\n$$\n\\varepsilon_{\\infty} = \\max_{j=1,\\dots,N_r} d_{i(j),j},\n$$\n它标识了最坏情况下的失准。\n\n此外，角度失配度量了匹配的施体角与平移后的受体角之间的最小周期性角度差：\n$$\n\\delta_{\\theta,\\infty} = \\max_{j=1,\\dots,N_r} \\min\\left(|\\theta_{i(j)}^d - \\theta_j^{r*}|,\\, 2\\pi - |\\theta_{i(j)}^d - \\theta_j^{r*}|\\right).\n$$\n这捕获了与轴向偏移无关的失配角度分量。\n\n通过全局缩放实现守恒耦合：当 $N_d \\neq N_r$ 时，仅靠最近邻分配不能保证守恒，因为多个受体可能映射到同一个施体，或者某些施体可能未被映射。一种直接的守恒修正是使用一个全局缩放因子 $s$ 来强制总和相等：\n$$\n\\widetilde{q}_j^r = q_{i(j)}^d,\\qquad s = \\frac{\\sum_{i=1}^{N_d} q_i^d}{\\sum_{j=1}^{N_r} \\widetilde{q}_j^r},\\qquad q_j^{r,\\mathrm{cons}} = s\\,\\widetilde{q}_j^r.\n$$\n根据构造，\n$$\n\\sum_{j=1}^{N_r} q_j^{r,\\mathrm{cons}} = s\\sum_{j=1}^{N_r} \\widetilde{q}_j^r = \\sum_{i=1}^{N_d} q_i^d,\n$$\n因此绝对守恒误差\n$$\n\\Delta_{\\mathrm{cons}} = \\left|\\sum_{j=1}^{N_r} q_j^{r,\\mathrm{cons}} - \\sum_{i=1}^{N_d} q_i^d\\right|\n$$\n理论上为零（取决于浮点运算中的数值舍入误差）。这种全局重缩放是一种最小的调整，它在确保离散守恒的同时保留了最近邻的局部性。\n\n每个测试用例的算法步骤：\n\n1. 按照规定构造施体角度 $\\theta_i^d$ 和轴向位置 $z_i^d$，计算施体笛卡尔坐标 $(x_i^d,y_i^d,z_i^d)$，并使用提供的确定性公式计算施体场 $q_i^d$。\n\n2. 按照规定构造受体角度 $\\theta_j^r$ 和轴向位置 $z_j^r$。应用周期性逆变换得到 $(\\theta_j^{r*}, z_j^{r*})$ 并计算 $(x_j^{r*}, y_j^{r*}, z_j^{r*})$。\n\n3. 对于每个受体索引 $j$，计算所有距离 $\\{d_{ij}\\}_{i=1}^{N_d}$ 并选择 $i(j) = \\arg\\min_i d_{ij}$，通过最小的 $i$ 打破平局。\n\n4. 从列表 $\\{d_{i(j),j}\\}_{j=1}^{N_r}$ 计算几何失配度量：$\\varepsilon_{\\mathrm{RMS}}$ 和 $\\varepsilon_{\\infty}$。\n\n5. 使用每对 $(\\theta_{i(j)}^d, \\theta_j^{r*})$ 的最小周期差公式计算角度失配 $\\delta_{\\theta,\\infty}$。\n\n6. 构造最近邻受体场 $\\widetilde{q}_j^r = q_{i(j)}^d$ 和守恒场 $q_j^{r,\\mathrm{cons}} = s\\,\\widetilde{q}_j^r$，其中\n$$\ns = \\frac{\\sum_{i=1}^{N_d} q_i^d}{\\sum_{j=1}^{N_r} \\widetilde{q}_j^r}.\n$$\n计算绝对守恒误差 $\\Delta_{\\mathrm{cons}}$。\n\n7. 报告该情况的列表 $[\\varepsilon_{\\mathrm{RMS}}, \\varepsilon_{\\infty}, \\Delta_{\\mathrm{cons}}, \\delta_{\\theta,\\infty}]$。\n\n测试套件覆盖理由：\n\n- 情况 A 练习了一般螺旋周期性，具有不匹配的基数和非平凡的轴向与角向变化，测试了稳健性和典型的 CFD 耦合条件。\n\n- 情况 B 测试了接近环绕的大旋转（$\\Delta\\theta = \\frac{15\\pi}{8}$）、零轴向变化和匹配的基数，探究了角度周期性和边界角度情况的处理。\n\n- 情况 C 在受体中点和相邻施体之间的角距离上构造了精确的平局，保证了相等的欧几里得距离（因为 $z=0$ 且 $R$ 恒定）。确定性平局打破规则确保了可复现性，并测试了算法在对称性引起的简并性下的稳定性。\n\n所有角度均以弧度为单位，所有距离均无量纲。程序必须以指定的嵌套列表格式，在单行中输出所有三种情况的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef wrap_to_2pi(theta):\n    \"\"\"Wrap angle to [0, 2*pi).\"\"\"\n    twopi = 2.0 * np.pi\n    return theta % twopi\n\ndef minimal_angular_diff(a, b):\n    \"\"\"\n    Minimal periodic angular difference between angles a and b in radians.\n    Returns a value in [0, pi].\n    \"\"\"\n    twopi = 2.0 * np.pi\n    diff = np.abs(a - b) % twopi\n    return np.minimum(diff, twopi - diff)\n\ndef build_donor_case_A(Nd, R, Ad, kd, alpha, m, beta, p):\n    i = np.arange(Nd)\n    theta_d = (2.0 * np.pi * i) / Nd\n    z_d = Ad * np.sin(kd * theta_d)\n    x_d = R * np.cos(theta_d)\n    y_d = R * np.sin(theta_d)\n    q_d = 1.0 + alpha * np.sin(m * theta_d) + beta * np.cos(p * z_d)\n    return theta_d, z_d, x_d, y_d, q_d\n\ndef build_receiver_case_A(Nr, R, Ar, kr, gamma, lam):\n    j = np.arange(Nr)\n    theta_r = (2.0 * np.pi * j) / Nr + gamma * np.sin(lam * j)\n    z_r = Ar * np.sin(kr * theta_r)\n    x_r = R * np.cos(theta_r)\n    y_r = R * np.sin(theta_r)\n    return theta_r, z_r, x_r, y_r\n\ndef build_donor_case_B(Nd, R, alpha, m):\n    i = np.arange(Nd)\n    theta_d = (2.0 * np.pi * i) / Nd\n    z_d = np.zeros_like(theta_d)\n    x_d = R * np.cos(theta_d)\n    y_d = R * np.sin(theta_d)\n    q_d = 1.0 + alpha * np.sin(m * theta_d)\n    return theta_d, z_d, x_d, y_d, q_d\n\ndef build_receiver_case_B(Nr, R):\n    j = np.arange(Nr)\n    theta_r = (2.0 * np.pi * j) / Nr\n    z_r = np.zeros_like(theta_r)\n    x_r = R * np.cos(theta_r)\n    y_r = R * np.sin(theta_r)\n    return theta_r, z_r, x_r, y_r\n\ndef build_donor_case_C(R, alpha, m):\n    theta_d = np.array([0.0, 0.5 * np.pi, np.pi, 1.5 * np.pi])\n    z_d = np.zeros_like(theta_d)\n    x_d = R * np.cos(theta_d)\n    y_d = R * np.sin(theta_d)\n    q_d = 1.0 + alpha * np.cos(m * theta_d)\n    return theta_d, z_d, x_d, y_d, q_d\n\ndef build_receiver_case_C(R):\n    base = np.array([0.25 * np.pi, 0.75 * np.pi, 1.25 * np.pi, 1.75 * np.pi])\n    theta_r = np.concatenate([base, base])  # duplicates to enforce tie stress\n    z_r = np.zeros_like(theta_r)\n    x_r = R * np.cos(theta_r)\n    y_r = R * np.sin(theta_r)\n    return theta_r, z_r, x_r, y_r\n\ndef apply_periodic_shift(theta_r, z_r, dtheta, dz):\n    theta_rs = wrap_to_2pi(theta_r - dtheta)\n    z_rs = z_r - dz\n    return theta_rs, z_rs\n\ndef nearest_neighbor_metrics(theta_d, z_d, x_d, y_d, q_d,\n                             theta_r, z_r, x_r, y_r,\n                             dtheta, dz, R):\n    # Shift receiver to donor frame\n    theta_rs, z_rs = apply_periodic_shift(theta_r, z_r, dtheta, dz)\n    x_rs = R * np.cos(theta_rs)\n    y_rs = R * np.sin(theta_rs)\n\n    Nd = theta_d.size\n    Nr = theta_rs.size\n\n    # Compute distances: for each receiver j, compute distances to all donors i.\n    # Use broadcasting: donors (Nd,1), receivers (1,Nr)\n    dx = x_d[:, None] - x_rs[None, :]\n    dy = y_d[:, None] - y_rs[None, :]\n    dz_ = z_d[:, None] - z_rs[None, :]\n    dists = np.sqrt(dx * dx + dy * dy + dz_ * dz_)\n\n    # Argmin along donors for each receiver; numpy.argmin is deterministic and picks smallest index on ties.\n    idx = np.argmin(dists, axis=0)\n    min_dists = dists[idx, np.arange(Nr)]\n\n    # Geometric mismatch metrics\n    eps_rms = float(np.sqrt(np.mean(min_dists**2)))\n    eps_inf = float(np.max(min_dists))\n\n    # Angular mismatch (minimal periodic difference)\n    ang_diff = minimal_angular_diff(theta_d[idx], theta_rs)\n    delta_theta_inf = float(np.max(ang_diff))\n\n    # Nearest-neighbor transfer and global conservative scaling\n    q_tilde = q_d[idx]\n    sum_q_d = float(np.sum(q_d))\n    sum_q_tilde = float(np.sum(q_tilde))\n    # To avoid division by zero in pathological cases, handle sum_q_tilde == 0\n    if sum_q_tilde == 0.0:\n        s = 0.0\n    else:\n        s = sum_q_d / sum_q_tilde\n    q_cons = s * q_tilde\n    delta_cons = float(abs(np.sum(q_cons) - sum_q_d))\n\n    return [eps_rms, eps_inf, delta_cons, delta_theta_inf]\n\ndef solve():\n    results = []\n\n    # Case A parameters\n    R_A = 1.0\n    Nd_A = 64\n    Nr_A = 70\n    Ad_A = 0.05\n    kd_A = 5\n    Ar_A = 0.05\n    kr_A = 6\n    gamma_A = (2.0 * np.pi) / (2.0 * (Nr_A ** 2))\n    lam_A = 3\n    dtheta_A = np.pi / 7.0\n    dz_A = 0.02\n    alpha_A = 0.1\n    m_A = 3\n    beta_A = 0.05\n    p_A = 10\n\n    theta_d_A, z_d_A, x_d_A, y_d_A, q_d_A = build_donor_case_A(\n        Nd_A, R_A, Ad_A, kd_A, alpha_A, m_A, beta_A, p_A\n    )\n    theta_r_A, z_r_A, x_r_A, y_r_A = build_receiver_case_A(\n        Nr_A, R_A, Ar_A, kr_A, gamma_A, lam_A\n    )\n    res_A = nearest_neighbor_metrics(\n        theta_d_A, z_d_A, x_d_A, y_d_A, q_d_A,\n        theta_r_A, z_r_A, x_r_A, y_r_A,\n        dtheta_A, dz_A, R_A\n    )\n    results.append(res_A)\n\n    # Case B parameters\n    R_B = 1.0\n    Nd_B = 8\n    Nr_B = 8\n    dtheta_B = 15.0 * np.pi / 8.0\n    dz_B = 0.0\n    alpha_B = 0.3\n    m_B = 4\n\n    theta_d_B, z_d_B, x_d_B, y_d_B, q_d_B = build_donor_case_B(\n        Nd_B, R_B, alpha_B, m_B\n    )\n    theta_r_B, z_r_B, x_r_B, y_r_B = build_receiver_case_B(\n        Nr_B, R_B\n    )\n    res_B = nearest_neighbor_metrics(\n        theta_d_B, z_d_B, x_d_B, y_d_B, q_d_B,\n        theta_r_B, z_r_B, x_r_B, y_r_B,\n        dtheta_B, dz_B, R_B\n    )\n    results.append(res_B)\n\n    # Case C parameters\n    R_C = 1.0\n    dtheta_C = 0.0\n    dz_C = 0.0\n    alpha_C = 0.2\n    m_C = 2\n\n    theta_d_C, z_d_C, x_d_C, y_d_C, q_d_C = build_donor_case_C(\n        R_C, alpha_C, m_C\n    )\n    theta_r_C, z_r_C, x_r_C, y_r_C = build_receiver_case_C(R_C)\n    res_C = nearest_neighbor_metrics(\n        theta_d_C, z_d_C, x_d_C, y_d_C, q_d_C,\n        theta_r_C, z_r_C, x_r_C, y_r_C,\n        dtheta_C, dz_C, R_C\n    )\n    results.append(res_C)\n\n    # Final print statement in the exact required format.\n    # Ensure floats are printed with full precision as default str for clarity.\n    print(f\"[[{', '.join(map(str, res_A))}], [{', '.join(map(str, res_B))}], [{', '.join(map(str, res_C))}]]\")\n\n# As per problem, the script should be runnable. However, the final output\n# required is a single line string. We call solve() to generate that string.\n# To make the output clean per instructions, we will capture and print only the result.\n# In a real execution environment, the call to solve() would produce the desired line.\n# For the purpose of this file, we present the code and the expected output separately.\n# The expected call is solve(), and it will print the required formatted string to stdout.\n# Since the XML should contain the code, the call to solve() at the end is appropriate.\nsolve()\n```"
        }
    ]
}