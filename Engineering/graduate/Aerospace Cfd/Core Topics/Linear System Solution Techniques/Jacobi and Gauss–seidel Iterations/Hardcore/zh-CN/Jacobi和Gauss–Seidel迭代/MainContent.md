## 引言
在航空航天、气象预报到[结构分析](@entry_id:153861)等众多计算科学与工程领域，求解形如 $A\boldsymbol{x} = \boldsymbol{b}$ 的大型稀疏线性方程组是一项无处不在的核心任务。当问题规模达到数百万甚至数十亿自由度时，传统的高斯消元等直接法因其高昂的计算和存储成本而变得不切实际。这为迭代法开辟了广阔的舞台，它们通过从一个初始猜测出发，逐步逼近真实解，提供了一条高效且可行的求[解路径](@entry_id:755046)。在众多迭代法中，雅可比（Jacobi）法和高斯-赛德尔（Gauss-Seidel）法以其简洁的思想和重要的理论地位，构成了我们理解更高级[数值算法](@entry_id:752770)的基石。

本文旨在系统性地介绍这两种经典的[定常迭代法](@entry_id:144014)。我们将在第一章《原理与机制》中，从矩阵分裂的统一框架出发，详细推导雅可比与[高斯-赛德尔迭代](@entry_id:136271)的数学形式，并深入探讨决定其成败的关键——收敛性理论。随后，在第二章《应用与交叉学科联系》中，我们将视野从核心的[CFD应用](@entry_id:144462)拓展至更广阔的领域，审视这些方法如何通过改进（如红黑着色）克服自身局限，并作为“光滑器”等关键部件融入[多重网格](@entry_id:172017)等先进技术框架中。最后，第三章《动手实践》将提供一系列精心设计的编程练习，引导你将理论付诸实践，在代码中感受迭代收敛的动态过程。通过这三章的学习，你将对这两种基本而强大的数值工具建立起全面而深刻的理解。

## 原理与机制

在上一章中，我们探讨了为何在[计算流体动力学](@entry_id:142614)（CFD）及其他计算工程领域中，求解大型稀疏[线性方程组](@entry_id:148943) $A\boldsymbol{x} = \boldsymbol{b}$ 是一个核心任务。本章将深入探讨一类基础且重要的求解算法：[定常迭代法](@entry_id:144014)（stationary iterative methods）。这些方法不仅是理解更高级求解器的基石，而且在多重网格等先进技术中扮演着关键的“光滑器”（smoother）角色。我们将从基本思想出发，系统地推导两种经典的[定常迭代法](@entry_id:144014)——**雅可比（Jacobi）** 和 **高斯-赛德尔（Gauss-Seidel）** 方法，并分析它们的收敛性、适用条件以及在实际计算中的性能表现。

### [定常迭代法](@entry_id:144014)的基本思想

[求解线性方程组](@entry_id:169069) $A\boldsymbol{x} = \boldsymbol{b}$ 的核心挑战在于，当矩阵 $A$ 的维度 $n$ 极大时（在CFD中可达数百万甚至数十亿），直接求解（如[高斯消元法](@entry_id:153590)）的计算成本和内存开销变得难以承受。[迭代法](@entry_id:194857)通过构造一个序列 $\boldsymbol{x}^{(0)}, \boldsymbol{x}^{(1)}, \boldsymbol{x}^{(2)}, \dots$，并希望该序列能收敛于真实解 $\boldsymbol{x}$，从而提供了一条更为可行的路径。

[定常迭代法](@entry_id:144014)的统一框架源于对矩阵 $A$ 的**分裂（splitting）**。我们将 $A$ 分解为两个矩阵的差：$A = M - N$，其中 $M$ 是一个非奇异且容易求逆的矩阵。基于此分裂，原方程 $A\boldsymbol{x} = \boldsymbol{b}$ 可改写为 $(M - N)\boldsymbol{x} = \boldsymbol{b}$，即 $M\boldsymbol{x} = N\boldsymbol{x} + \boldsymbol{b}$。

这个形式自然地引出一个迭代格式：
$$
M \boldsymbol{x}^{(k+1)} = N \boldsymbol{x}^{(k)} + \boldsymbol{b}
$$
其中 $k$ 是迭代步数。由于我们特意选择了易于求逆的 $M$，我们可以将上式显式地写为：
$$
\boldsymbol{x}^{(k+1)} = M^{-1}N \boldsymbol{x}^{(k)} + M^{-1}\boldsymbol{b}
$$
这便是定常线性[迭代法](@entry_id:194857)的[标准形式](@entry_id:153058)。我们定义**[迭代矩阵](@entry_id:637346)（iteration matrix）** $T = M^{-1}N$ 和**常数向量** $\boldsymbol{c} = M^{-1}\boldsymbol{b}$，迭代过程便可简洁地表示为一个[不动点迭代](@entry_id:749443)：
$$
\boldsymbol{x}^{(k+1)} = T \boldsymbol{x}^{(k)} + \boldsymbol{c}
$$
不同的[迭代法](@entry_id:194857)，如雅可比和高斯-赛德尔，其本质区别就在于选择了不同的矩阵分裂方式，即不同的 $M$ 和 $N$。

### [雅可比方法](@entry_id:270947)：[同步更新](@entry_id:271465)

[雅可比方法](@entry_id:270947)是最直观的迭代法之一。其核心思想是，在计算第 $k+1$ 次迭代的新解 $\boldsymbol{x}^{(k+1)}$ 时，所有分量的计算都**仅**依赖于上一次迭代的旧解 $\boldsymbol{x}^{(k)}$。

为了推导其具体形式，我们首先将矩阵 $A$ 分解为其对角部分 $D$、严格下三角部分 $L$ 和严格上三角部分 $U$ 的和，即 $A = D + L + U$ 。现在，我们将原方程 $A\boldsymbol{x} = \boldsymbol{b}$ 写作 $(D + L + U)\boldsymbol{x} = \boldsymbol{b}$，并把对角项 $D\boldsymbol{x}$ 留在左侧：
$$
D\boldsymbol{x} = \boldsymbol{b} - (L+U)\boldsymbol{x}
$$
这个形式启发了[雅可比迭代](@entry_id:139235)的构造：用旧值 $\boldsymbol{x}^{(k)}$ 计算右端，用易于求逆的对角矩阵 $D$ 求解新值 $\boldsymbol{x}^{(k+1)}$。

从分量形式上看，方程组的第 $i$ 个方程为 $\sum_{j=1}^{n} a_{ij} x_j = b_i$。移项可得：
$$
a_{ii} x_i = b_i - \sum_{j \neq i} a_{ij} x_j
$$
[雅可比法](@entry_id:147508)的更新规则就是将右侧所有 $x_j$ 替换为第 $k$ 步的值，来计算左侧的 $x_i^{(k+1)}$：
$$
x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right), \quad \text{for } i = 1, \dots, n
$$
这个过程可以被视为所有分量**同步更新（simultaneous update）**，因为计算任意一个新分量 $x_i^{(k+1)}$ 时，都不需要用到在同一步（第 $k+1$ 步）已算出的其他新分量。

将上述分量形式[写回](@entry_id:756770)矩阵形式，我们得到：
$$
D \boldsymbol{x}^{(k+1)} = \boldsymbol{b} - (L+U)\boldsymbol{x}^{(k)}
$$
两边同时左乘 $D^{-1}$（假设 $A$ 的对角元素非零，这在大多数[CFD应用](@entry_id:144462)中是成立的），我们便得到了[雅可比迭代](@entry_id:139235)的[矩阵表示](@entry_id:146025) ：
$$
\boldsymbol{x}^{(k+1)} = -D^{-1}(L+U)\boldsymbol{x}^{(k)} + D^{-1}\boldsymbol{b}
$$
与通用形式 $\boldsymbol{x}^{(k+1)} = T \boldsymbol{x}^{(k)} + \boldsymbol{c}$ 对比，我们得到[雅可比法](@entry_id:147508)的迭代矩阵和常数向量为 ：
$$
T_J = -D^{-1}(L+U), \quad \boldsymbol{c}_J = D^{-1}\boldsymbol{b}
$$
这对应于矩阵分裂 $M = D$ 和 $N = -(L+U)$。

### 高斯-赛德尔方法：顺序更新

高斯-赛德尔方法是[雅可比方法](@entry_id:270947)的一个重要改进。它的核心思想是**贪婪地**利用最新信息：在计算第 $k+1$ 次迭代的解时，只要一个分量被更新，就立刻在后续的计算中使用这个新值，而不是等待整个迭代步完成。

假设我们按自然顺序（$i=1, 2, \dots, n$）更新解的分量，这被称为**词典序（lexicographic ordering）**。在计算 $x_i^{(k+1)}$ 时，分量 $x_1^{(k+1)}, \dots, x_{i-1}^{(k+1)}$ 已经计算完毕。高斯-赛德尔方法便利用这些新值来更新 $x_i^{(k+1)}$。其分量形式的更新规则为 ：
$$
x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - \sum_{j=i+1}^{n} a_{ij} x_j^{(k)} \right)
$$
注意，在计算 $x_i^{(k+1)}$ 时，下标小于 $i$ 的项使用的是第 $k+1$ 步的新值，而下标大于 $i$ 的项仍然使用第 $k$ 步的旧值。这种**顺序更新（sequential update）** 的方式引入了[数据依赖](@entry_id:748197)，使得计算 $x_i^{(k+1)}$ 必须在 $x_{i-1}^{(k+1)}$ 完成之后进行。

为了推导其矩阵形式，我们将上式中所有带 $(k+1)$ 上标的项移到等式左边：
$$
a_{ii} x_i^{(k+1)} + \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} = b_i - \sum_{j=i+1}^{n} a_{ij} x_j^{(k)}
$$
将所有 $n$ 个这样的方程组合起来，等式左边恰好是矩阵 $(D+L)$ 与向量 $\boldsymbol{x}^{(k+1)}$ 的乘积，而等式右边则是 $\boldsymbol{b} - U\boldsymbol{x}^{(k)}$。因此，我们得到了[高斯-赛德尔迭代](@entry_id:136271)的矩阵形式 ：
$$
(D+L)\boldsymbol{x}^{(k+1)} = \boldsymbol{b} - U\boldsymbol{x}^{(k)}
$$
由于 $D+L$ 是一个下[三角矩阵](@entry_id:636278)，其逆矩阵可以通过简单的**前向替换（forward substitution）** 高效求得。两边同时左乘 $(D+L)^{-1}$，我们得到：
$$
\boldsymbol{x}^{(k+1)} = -(D+L)^{-1}U\boldsymbol{x}^{(k)} + (D+L)^{-1}\boldsymbol{b}
$$
因此，[高斯-赛德尔法](@entry_id:145727)的迭代矩阵和常数向量为  ：
$$
T_{GS} = -(D+L)^{-1}U, \quad \boldsymbol{c}_{GS} = (D+L)^{-1}\boldsymbol{b}
$$
这对应于矩阵分裂 $M = D+L$ 和 $N = -U$。

值得一提的是，高斯-赛德尔方法可以看作是更广泛的**逐次超松弛（Successive Over-Relaxation, SOR）**方法在[松弛因子](@entry_id:1130825) $\omega=1$ 时的特例  。SOR方法通过引入一个[松弛因子](@entry_id:1130825) $\omega$ 来加速收敛，其[迭代矩阵](@entry_id:637346)为 $T_{SOR} = (D + \omega L)^{-1} \bigl( (1 - \omega) D - \omega U \bigr)$。

### [收敛性分析](@entry_id:151547)

一个迭代方法是否实用，关键在于其产生的序列 $\boldsymbol{x}^{(k)}$ 是否收敛于真实解 $\boldsymbol{x}$。

#### 误差传播与[谱半径](@entry_id:138984)

我们定义第 $k$ 步的误差向量为 $\boldsymbol{e}^{(k)} = \boldsymbol{x}^{(k)} - \boldsymbol{x}$。真实解 $\boldsymbol{x}$ 必然满足[不动点方程](@entry_id:203270) $\boldsymbol{x} = T\boldsymbol{x} + \boldsymbol{c}$。将此式与迭代格式 $\boldsymbol{x}^{(k+1)} = T\boldsymbol{x}^{(k)} + \boldsymbol{c}$ 相减，我们得到误差的传播规律 ：
$$
\boldsymbol{e}^{(k+1)} = \boldsymbol{x}^{(k+1)} - \boldsymbol{x} = (T\boldsymbol{x}^{(k)} + \boldsymbol{c}) - (T\boldsymbol{x} + \boldsymbol{c}) = T(\boldsymbol{x}^{(k)} - \boldsymbol{x}) = T\boldsymbol{e}^{(k)}
$$
通过递推，我们得到 $\boldsymbol{e}^{(k)} = T^k \boldsymbol{e}^{(0)}$。为了使迭代对于任意初始猜测 $\boldsymbol{x}^{(0)}$（即任意初始误差 $\boldsymbol{e}^{(0)}$）都收敛，即 $\lim_{k\to\infty} \boldsymbol{e}^{(k)} = \boldsymbol{0}$，一个充分且必要的条件是 $\lim_{k\to\infty} T^k = 0$（[零矩阵](@entry_id:155836)）。根据[矩阵分析](@entry_id:204325)理论，这个条件等价于迭代矩阵 $T$ 的**[谱半径](@entry_id:138984)（spectral radius）**小于1。

谱半径 $\rho(T)$ 定义为矩阵 $T$ 的所有特征值的模的最大值：
$$
\rho(T) = \max \{|\lambda| : \lambda \text{ is an eigenvalue of } T\}
$$
因此，一个[定常迭代法](@entry_id:144014)收敛的**充分必要条件**是其[迭代矩阵](@entry_id:637346)的[谱半径](@entry_id:138984)严格小于1，即 $\rho(T)  1$ 。

此外，$\rho(T)$ 的值不仅决定了迭代是否收敛，还决定了其**收敛速率**。$\rho(T)$ 越接近0，收敛越快；越接近1，收敛越慢。具体来说，达到一定精度所需的迭代次数大致与 $1 / (1-\rho(T))$ 成正比。因此，比较不同迭代法优劣的一个核心指标就是比较它们迭代矩阵的谱半径。

让我们通过一个具体的例子来感受这一点 。考虑一个由一维泊松问题离散化得到的 $3 \times 3$ 矩阵：
$$
A = \begin{pmatrix} 2  -1  0 \\ -1  2  -1 \\ 0  -1  2 \end{pmatrix}
$$
通过直接计算，我们可以得到其雅可比和[高斯-赛德尔迭代](@entry_id:136271)矩阵的谱半径分别为：
$$
\rho(T_J) = \frac{\sqrt{2}}{2} \approx 0.7071, \quad \rho(T_{GS}) = \frac{1}{2} = 0.5
$$
由于 $\rho(T_{GS})  \rho(T_J)$，对于这个问题，[高斯-赛德尔法](@entry_id:145727)比[雅可比法](@entry_id:147508)收敛得更快。事实上，对于这类由扩散问题生成的对称正定[三对角矩阵](@entry_id:138829)，[谱半径](@entry_id:138984)之间存在一个优美的关系：$\rho(T_{GS}) = (\rho(T_J))^2$，这从理论上证明了高斯-赛德尔方法的收敛优势 。例如，对于一个更小的 $2 \times 2$ 系统，我们可以算出 $\rho(T_{GS}) = 1/4$ 。

#### 收敛的充分条件

虽然[谱半径](@entry_id:138984)是判断收敛的根本准则，但直接计算一个大矩阵的[谱半径](@entry_id:138984)本身就很困难。因此，在实践中，我们更关心是否存在一些容易判断的矩阵属性，能够**保证**迭代法收敛。

一个最重要的条件是**[严格对角占优](@entry_id:154277)（Strictly Diagonally Dominant, SDD）**。如果矩阵 $A$ 的每一行，其对角元素的绝对值都**大于**该行所有非对角元素绝对值之和，即：
$$
|a_{ii}| > \sum_{j \neq i} |a_{ij}|, \quad \text{for all } i=1, \dots, n
$$
则称 $A$ 是[严格对角占优](@entry_id:154277)的。对于这类矩阵，我们可以证明[雅可比迭代](@entry_id:139235)必然收敛 。证明思路是考察迭代矩阵 $T_J$ 的[无穷范数](@entry_id:637586)（最大行和范数）：
$$
\|T_J\|_{\infty} = \max_i \sum_{j \neq i} \left| \frac{-a_{ij}}{a_{ii}} \right| = \max_i \frac{\sum_{j \neq i} |a_{ij}|}{|a_{ii}|}
$$
根据[严格对角占优](@entry_id:154277)的定义，上式中的比值对每一行都小于1，因此其最大值也必然小于1。由于[谱半径](@entry_id:138984)不大于任何[矩阵范数](@entry_id:139520)（$\rho(T) \le \|T\|$），我们有 $\rho(T_J) \le \|T_J\|_{\infty}  1$，从而保证了收敛。可以进一步证明，对于[严格对角占优矩阵](@entry_id:198320)，[高斯-赛德尔法](@entry_id:145727)也同样收敛。

另一个重要的矩阵类别是**[对称正定](@entry_id:145886)（Symmetric Positive-Definite, SPD）**矩阵。这类矩阵在物理问题的离散化中非常常见。一个关键的定理是：如果矩阵 $A$ 是对称正定的，那么[高斯-赛德尔迭代](@entry_id:136271)保证收敛。值得注意的是，对称正定并不要求[对角占优](@entry_id:748380)。例如，矩阵 
$$A = \begin{pmatrix} 1.6  -1  0 \\ -1  1.6  -1 \\ 0  -1  1.6 \end{pmatrix}$$
是[对称正定](@entry_id:145886)的，但其第二行不满足[对角占优](@entry_id:748380)（$|1.6| \ngtr |-1|+|-1|=2$）。然而，通过计算可以发现其[高斯-赛德尔迭代](@entry_id:136271)矩阵的[谱半径](@entry_id:138984)为 $\rho(T_{GS}) = 25/32 \approx 0.7813  1$，迭代依然收敛 。这说明，[对称正定](@entry_id:145886)性是比[对角占优](@entry_id:748380)更广泛的保证收敛的条件之一。

此外，在CFD中，满足特定条件的矩阵，如**[M-矩阵](@entry_id:189121)**（不可约、弱[对角占优](@entry_id:748380)、非对角元素非正），能够保证离散格式满足**[单调性](@entry_id:143760)**或**离散[极值原理](@entry_id:138611)**，这对于获得物理上有意义的、无非物理解振荡的数值解至关重要 。

### 实际实现中的考量

在将这些算法付诸实践时，理论收敛性并非唯一需要考虑的因素。内存占用和[并行计算](@entry_id:139241)性能同样是决定算法适用性的关键。

#### 内存占用：双缓冲 vs. 原地更新

[雅可比方法](@entry_id:270947)要求所有更新都基于上一步的旧值。如果在单线程程序中试图用单个数组来存储解向量并“原地”更新，就会出现**读[后写](@entry_id:756770)（Write-After-Read, WAR）**冲突。当更新一个分量 $x_i^{(k+1)}$ 并覆盖其旧值 $x_i^{(k)}$ 后，计算后续分量 $x_j^{(k+1)}$ ($j>i$) 时，若需要用到 $x_i$ 的值，它读到的将是已更新的 $x_i^{(k+1)}$，而不是[雅可比方法](@entry_id:270947)所要求的 $x_i^{(k)}$。这会破坏算法的数学定义。

为避免此问题，[雅可比方法](@entry_id:270947)的标准实现需要**双缓冲（double buffering）**：使用一个数组存储旧解 $\boldsymbol{x}^{(k)}$，另一个数组存储新解 $\boldsymbol{x}^{(k+1)}$。一次迭代完成后，两个数组的角色互换。相比之下，高斯-赛德尔方法的设计初衷就是利用最新算出的值，因此它天然适合**原地更新（in-place update）**，只需要一个存储数组即可 .

这个差异在处理大规模三维问题时会变得非常显著。例如，对于一个 $512 \times 512 \times 512$ 的网格，使用[双精度](@entry_id:636927)浮点数，[高斯-赛德尔法](@entry_id:145727)存储解向量需要约 1.01 GiB 内存，而[雅可比法](@entry_id:147508)则需要两倍，即约 2.02 GiB 。如果每个网格单元有多个变量（例如，在可压缩流中求解密度、动量和能量），这个内存开销的差距还会随变量数 $m$ [线性增长](@entry_id:157553) 。

#### [并行可扩展性](@entry_id:753141)：[数据依赖](@entry_id:748197)的诅咒与祝福

在现代大规模计算中，我们通常使用[分布式内存并行](@entry_id:748586)计算机（如集群）来求解问题。此时，算法的[并行性能](@entry_id:636399)，特别是跨处理器通信的模式，成为决定性因素。

**[雅可比方法](@entry_id:270947)**的同步更新特性在这里显示出巨大优势。由于计算 $\boldsymbol{x}^{(k+1)}$ 的所有分量仅依赖于 $\boldsymbol{x}^{(k)}$，在区域分解的并行策略下，每个处理器可以在一次迭代开始时，通过一次**“光环”交换（halo exchange）**从邻居处理器获取其边界上的旧值。交换完成后，所有处理器就可以完全独立、无依赖地计算其内部所有点的新值。这种“通信-计算”分离的模式具有极佳的并行性，同步开销小 。

**词典序高斯-赛德尔方法**则恰恰相反。其固有的顺序依赖性在并行环境中会形成一个“计算波前”，从一个角落的处理器开始，斜向传播到对角。处理器 $(p_x, p_y)$ 必须等待来自处理器 $(p_x-1, p_y)$ 和 $(p_x, p_y-1)$ 的新边界值才能开始计算。这种流水线式的计算导致大量处理器处于空闲等待状态，[并行效率](@entry_id:637464)极低 。

为了克服高斯-赛德尔的并行性难题，人们发展出了**红黑着色（red-black coloring）**的更新策略。对于标准的五点或[七点模板](@entry_id:169441)，可以将网格点像棋盘一样染成“红”“黑”两色，使得任意一个红点的邻居都是黑点，反之亦然。一次迭代分为两个阶段：
1.  **红点更新**：所有红点只依赖于黑点的值。因此，所有红点可以像[雅可比方法](@entry_id:270947)一样并行更新。这需要一次光环交换来获取邻居黑点的值。
2.  **黑点更新**：所有黑点只依赖于红点的值。在所有红点更新完毕后，所有黑点可以利用新算出的红点值并行更新。这需要第二次光环交换来分发新的红点边界值。

红黑高斯-赛德尔方法恢复了大规模并行性，但代价是每次迭代需要**两次**同步的光环交换，是[雅可比方法](@entry_id:270947)的两倍 。对于这类问题，红黑高斯-赛德尔方法的谱半径与[雅可比方法](@entry_id:270947)的谱半径通常也存在 $\rho(T_{GS-RB}) = (\rho(T_J))^2$ 的关系 ，这意味着其[收敛速度](@entry_id:636873)通常更快。

因此，在雅可比和高斯-赛德尔之间选择，实际上是在**算法[收敛率](@entry_id:146534)**和**[并行效率](@entry_id:637464)**之间的权衡。[雅可比法](@entry_id:147508)每次迭代的[并行效率](@entry_id:637464)最高，但可能需要更多次迭代；而（红黑）[高斯-赛德尔法](@entry_id:145727)通常迭代次数更少，但每次迭代的[通信开销](@entry_id:636355)（同步次数）更高。在现代[高性能计算](@entry_id:169980)中，通信延迟往往是性能瓶颈，因此[雅可比法](@entry_id:147508)及其变体因其简单的通信模式而仍然具有重要的应用价值，尤其是在作为[多重网格](@entry_id:172017)等更复杂求解器中的光滑器时。