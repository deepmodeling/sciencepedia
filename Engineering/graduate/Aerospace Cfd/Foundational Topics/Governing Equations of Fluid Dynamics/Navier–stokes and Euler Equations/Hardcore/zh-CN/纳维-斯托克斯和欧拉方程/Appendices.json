{
    "hands_on_practices": [
        {
            "introduction": "在计算流体力学中，首要任务是将连续的微分方程转化为离散的代数方程。这一近似过程必然会引入误差。本练习将引导你通过泰勒级数展开，对这种“截断误差”进行量化，从而确定常用有限差分格式的理论精度阶数。",
            "id": "3979200",
            "problem": "考虑一个沿坐标 $x$ 的一维、足够光滑的可压缩流，其密度为 $\\rho(x)$，速度为 $u(x)$。质量通量为 $f(x) = \\rho(x) u(x)$，连续性方程涉及空间导数 $\\partial_x(\\rho u) = \\partial_x f$。在一个点为 $x_i = i \\Delta x$、间距为 $\\Delta x > 0$ 的均匀网格上，用于计算在 $x_i$ 处 $\\partial_x f$ 的两种广泛使用的有限差分近似是：\n\n- 中心差分近似，定义为\n$$\n\\mathcal{D}_{c}[f]_i = \\frac{f_{i+1} - f_{i-1}}{2 \\Delta x}\n$$\n\n- 迎风近似（假设 $u(x_i) > 0$，因此迎风方向是从 $x_{i-1}$ 到 $x_i$），定义为\n$$\n\\mathcal{D}_{u}[f]_i = \\frac{f_i - f_{i-1}}{\\Delta x}\n$$\n\n从导数和光滑函数的基本定义出发，为 $\\partial_x f$ 的有限差分近似提供局部截断误差的精确定义。然后，对于上述两种近似中的每一种，推导在 $x_i$ 处的截断误差，用在 $x_i$ 处求值的 $f(x) = \\rho(x) u(x)$ 的导数来表示，并确定精度阶 $p$，使得当 $\\Delta x \\to 0$ 时 $|\\tau_i(\\Delta x)| = \\mathcal{O}(\\Delta x^p)$。使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境，将您的最终答案表示为行矩阵 $\\begin{pmatrix}p_{\\mathrm{central}}  p_{\\mathrm{upwind}}\\end{pmatrix}$。",
            "solution": "所陈述的问题是有效的。它在科学上基于数值分析和流体动力学的原理，特别是关于守恒律的有限差分格式的分析。该问题是适定的、客观的、自洽的，提供了所有必要的定义和约束，以得出一个唯一的、可验证的解。“足够光滑”流的假设是一个标准且必要的条件，它允许使用泰勒级数展开，这是分析截断误差的基础。\n\n首先，我们必须给出局部截断误差的精确定义。设 $\\mathcal{L}$ 是一个微分算子，$\\mathcal{D}_{\\Delta x}$ 是一个在间距为 $\\Delta x$ 的网格上近似 $\\mathcal{L}$ 的有限差分算子。设 $f(x)$ 是一个足够光滑的函数。局部截断误差，记为 $\\tau(x)$，是将精确的光滑函数 $f(x)$ 代入有限差分近似时得到的余项。它衡量了离散算子 $\\mathcal{D}_{\\Delta x}$ 在特定点 $x$ 处对连续算子 $\\mathcal{L}$ 的近似程度。对于空间导数 $\\mathcal{L} = \\partial_x$，在网格点 $x_i$ 处的截断误差定义为：\n$$\n\\tau_i(\\Delta x) = \\mathcal{D}_{\\Delta x}[f]_i - (\\partial_x f)|_{x=x_i}\n$$\n其中 $(\\partial_x f)|_{x=x_i}$ 是 $f(x)$ 在 $x_i$ 处求值的一阶导数的精确值，我们将其记为 $f'(x_i)$。近似的精度阶是整数 $p$，使得在极限 $\\Delta x \\to 0$ 时，截断误差的量级表现为 $|\\tau_i(\\Delta x)| = \\mathcal{O}((\\Delta x)^p)$。\n\n为了确定每种给定格式的截断误差，我们采用函数 $f(x)$ 在点 $x_i$ 附近的泰勒级数展开。我们将 $f(x_i)$ 记为 $f_i$，$f(x_i+\\Delta x)$ 记为 $f_{i+1}$，以及 $f(x_i-\\Delta x)$ 记为 $f_{i-1}$。流是“足够光滑”的假设保证了 $f(x)$ 具有所需阶数的连续导数。\n\n$f_{i+1}$ 和 $f_{i-1}$ 在 $x_i$ 附近的泰勒级数展开为：\n$$\nf_{i+1} = f(x_i + \\Delta x) = f_i + (\\Delta x) f'(x_i) + \\frac{(\\Delta x)^2}{2!} f''(x_i) + \\frac{(\\Delta x)^3}{3!} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\n$$\nf_{i-1} = f(x_i - \\Delta x) = f_i - (\\Delta x) f'(x_i) + \\frac{(\\Delta x)^2}{2!} f''(x_i) - \\frac{(\\Delta x)^3}{3!} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\n其中 $f'(x_i)$、$f''(x_i)$ 和 $f'''(x_i)$ 是 $f(x)$ 在 $x_i$ 处求值的一阶、二阶和三阶导数。\n\n我们来分析中心差分近似 $\\mathcal{D}_{c}[f]_i$。\n$$\n\\mathcal{D}_{c}[f]_i = \\frac{f_{i+1} - f_{i-1}}{2 \\Delta x}\n$$\n将泰勒级数展开代入此表达式：\n$$\n\\mathcal{D}_{c}[f]_i = \\frac{1}{2 \\Delta x} \\left[ \\left( f_i + \\Delta x f'(x_i) + \\frac{(\\Delta x)^2}{2} f''(x_i) + \\frac{(\\Delta x)^3}{6} f'''(x_i) + \\dots \\right) - \\left( f_i - \\Delta x f'(x_i) + \\frac{(\\Delta x)^2}{2} f''(x_i) - \\frac{(\\Delta x)^3}{6} f'''(x_i) + \\dots \\right) \\right]\n$$\n简化分子中的项：\n$$\nf_{i+1} - f_{i-1} = (f_i - f_i) + (\\Delta x f'(x_i) - (-\\Delta x f'(x_i))) + \\left(\\frac{(\\Delta x)^2}{2} f''(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i)\\right) + \\left(\\frac{(\\Delta x)^3}{6} f'''(x_i) - \\left(-\\frac{(\\Delta x)^3}{6} f'''(x_i)\\right)\\right) + \\dots\n$$\n$$\nf_{i+1} - f_{i-1} = 2 \\Delta x f'(x_i) + \\frac{2 (\\Delta x)^3}{6} f'''(x_i) + \\mathcal{O}((\\Delta x)^5) = 2 \\Delta x f'(x_i) + \\frac{(\\Delta x)^3}{3} f'''(x_i) + \\mathcal{O}((\\Delta x)^5)\n$$\n现在，将此结果代回 $\\mathcal{D}_{c}[f]_i$ 的公式中：\n$$\n\\mathcal{D}_{c}[f]_i = \\frac{1}{2 \\Delta x} \\left[ 2 \\Delta x f'(x_i) + \\frac{(\\Delta x)^3}{3} f'''(x_i) + \\mathcal{O}((\\Delta x)^5) \\right] = f'(x_i) + \\frac{(\\Delta x)^2}{6} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\n中心差分格式的截断误差 $\\tau_{c,i}$ 为：\n$$\n\\tau_{c,i}(\\Delta x) = \\mathcal{D}_{c}[f]_i - f'(x_i) = \\frac{(\\Delta x)^2}{6} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\n主导误差项与 $(\\Delta x)^2$ 成正比。因此，中心差分格式的精度阶为 $p_{\\mathrm{central}} = 2$。\n\n接下来，我们分析迎风近似 $\\mathcal{D}_{u}[f]_i$。\n$$\n\\mathcal{D}_{u}[f]_i = \\frac{f_i - f_{i-1}}{\\Delta x}\n$$\n代入 $f_{i-1}$ 的泰勒级数展开：\n$$\n\\mathcal{D}_{u}[f]_i = \\frac{1}{\\Delta x} \\left[ f_i - \\left( f_i - \\Delta x f'(x_i) + \\frac{(\\Delta x)^2}{2} f''(x_i) - \\frac{(\\Delta x)^3}{6} f'''(x_i) + \\dots \\right) \\right]\n$$\n简化分子中的项：\n$$\nf_i - f_{i-1} = f_i - f_i + \\Delta x f'(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i) + \\frac{(\\Delta x)^3}{6} f'''(x_i) - \\dots\n$$\n$$\nf_i - f_{i-1} = \\Delta x f'(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^3)\n$$\n现在，将此结果代回 $\\mathcal{D}_{u}[f]_i$ 的公式中：\n$$\n\\mathcal{D}_{u}[f]_i = \\frac{1}{\\Delta x} \\left[ \\Delta x f'(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^3) \\right] = f'(x_i) - \\frac{\\Delta x}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^2)\n$$\n迎风格式的截断误差 $\\tau_{u,i}$ 为：\n$$\n\\tau_{u,i}(\\Delta x) = \\mathcal{D}_{u}[f]_i - f'(x_i) = - \\frac{\\Delta x}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^2)\n$$\n主导误差项与 $\\Delta x$ 成正比。因此，迎风格式的精度阶为 $p_{\\mathrm{upwind}} = 1$。\n\n总之，中心差分格式是二阶精度的，而迎风格式是一阶精度的。所要求的答案是这些精度阶的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在将方程离散化之后，我们必须验证我们编写的复杂CFD求解器是否正确地实现了这些方程。“制造解方法”(Method of Manufactured Solutions, MMS)是一种严谨的验证技术，我们通过定义一个解析解，并反向推导使之成为控制方程精确解所必需的源项。本练习将要求你为完整的可压缩Navier-Stokes方程推导这些源项，从而让你对这些方程本身有更深刻的实践理解。",
            "id": "3979186",
            "problem": "您的任务是为可压缩纳维-斯托克斯方程开发一个二维制造解，该解适用于航空航天应用中计算流体力学求解器的验证。请从牛顿可压缩流体的基本质量、动量和能量守恒定律出发，该流体具有傅里叶热传导和理想气体热力学封闭。您必须指定密度、速度和温度的解析场，然后推导使这些场成为控制方程精确解的彻体力源项。您的程序应在指定的时空点和流体属性参数集下计算这些强迫项。\n\n假设存在一个二维笛卡尔域，其空间坐标为 $(x,y)$（单位为米），时间为 $t$（单位为秒）。解析的制造解场如下：\n$$\n\\rho(x,y,t) = \\rho_0\\left[1 + A \\cdot 0.1 \\cdot \\sin(\\pi x)\\cos(\\pi y)\\cdot e^{-\\alpha t}\\right],\n$$\n$$\nu(x,y,t) = U_0 + A \\cdot 0.2 \\cdot \\cos(\\pi x)\\sin(\\pi y)\\cdot e^{-\\alpha t},\n$$\n$$\nv(x,y,t) = V_0 + A \\cdot 0.15 \\cdot \\sin(2\\pi x)\\sin(\\pi y)\\cdot e^{-\\alpha t},\n$$\n$$\nT(x,y,t) = T_0\\left[1 + A \\cdot 0.03 \\cdot \\cos(\\pi x)\\cos(2\\pi y)\\cdot e^{-\\alpha t}\\right].\n$$\n流体遵循理想气体定律和热量关系：\n$$\np = \\rho R T,\\quad c_v = \\frac{R}{\\gamma - 1},\\quad c_p = \\gamma c_v,\n$$\n以及傅里叶热传导，其中常数热导率 $k$ 通过普朗特数 $\\mathrm{Pr}$ 与动力粘度 $\\mu$ 相关联：\n$$\nk = \\frac{\\mu c_p}{\\mathrm{Pr}}.\n$$\n带有斯托克斯假设的牛顿粘性应力张量为：\n$$\n\\boldsymbol{\\tau} = \\mu\\left[\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\mathsf{T}} - \\frac{2}{3}(\\nabla\\cdot \\mathbf{u})\\mathbf{I}\\right].\n$$\n定义单位质量总能量为：\n$$\nE = e + \\frac{1}{2}(u^2 + v^2),\\quad e = c_v T.\n$$\n守恒形式的控制方程为：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla\\cdot(\\rho \\mathbf{u}) = f_\\rho,\n$$\n$$\n\\frac{\\partial (\\rho \\mathbf{u})}{\\partial t} + \\nabla\\cdot\\left(\\rho \\mathbf{u}\\mathbf{u}^{\\mathsf{T}} + p\\mathbf{I}\\right) = \\nabla\\cdot \\boldsymbol{\\tau} + \\mathbf{f}_{\\mathbf{m}},\n$$\n$$\n\\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] = \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) - \\nabla\\cdot \\mathbf{q} + f_E,\n$$\n其中热通量 $\\mathbf{q} = -k\\nabla T$，$f_\\rho$ 是质量源项，$\\mathbf{f}_{\\mathbf{m}}$ 是动量源项（单位为牛顿/立方米），$f_E$ 是能量源项（单位为瓦特/立方米）。您的任务是计算 $f_\\rho$、$\\mathbf{f}_{\\mathbf{m}}$ 的分量和 $f_E$，以使指定的场成为上述方程的精确解。\n\n实现要求：\n- 您必须根据指定的场解析地计算所需的空间和时间导数，严格按照书面形式应用守恒定律和本构关系，并组合强迫项，以使每个方程都逐点满足。\n- 所有量都必须使用国际单位制（SI）计算：密度单位为千克/立方米，速度单位为米/秒，温度单位为开尔文，压力单位为帕斯卡，粘度单位为帕斯卡·秒，热导率单位为瓦特/(米·开尔文)，时间单位为秒。\n- 将最终输出表示为浮点数。质量源项 $f_\\rho$ 的单位必须是 $\\mathrm{kg/(m^3\\cdot s)}$，每个动量源项分量的单位必须是 $\\mathrm{N/m^3}$，能量源项 $f_E$ 的单位必须是 $\\mathrm{W/m^3}$。\n\n测试套件：\n使用以下参数值和评估点集。对于每种情况，计算并返回元组 $\\left[f_\\rho, f_{m,x}, f_{m,y}, f_E\\right]$。\n- 情况1（一般内部点，粘性）：$\\gamma=1.4$, $R=287$, $\\rho_0=1.2$, $U_0=50$, $V_0=-20$, $T_0=300$, $\\mu=1.8\\times 10^{-5}$, $\\mathrm{Pr}=0.72$, $\\alpha=0.5$, $A=1$, 在 $(x,y,t)=(0.3,0.7,1.2)$ 处评估。\n- 情况2（边界点，初始时间，粘性）：参数与情况1相同，在 $(x,y,t)=(0,0,0)$ 处评估。\n- 情况3（欧拉极限，无粘且绝热）：热力学参数与情况1相同，但 $\\mu=0$ 且 $k=0$，即设置 $\\mu=0$ 并视 $\\mathrm{Pr}$ 为无关，在 $(x,y,t)=(1,1,2)$ 处评估。\n- 情况4（常数场，零振幅）：粘性参数与情况1相同，但 $A=0$，在 $(x,y,t)=(0.4,0.6,3)$ 处评估。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个逗号分隔的列表。例如：\n$$\n\\text{[}[f_{\\rho,1},f_{m,x,1},f_{m,y,1},f_{E,1}], [f_{\\rho,2},f_{m,x,2},f_{m,y,2},f_{E,2}], [f_{\\rho,3},f_{m,x,3},f_{m,y,3},f_{E,3}], [f_{\\rho,4},f_{m,x,4},f_{m,y,4},f_{E,4}]\\text{]}\n$$\n确保您的程序严格按照此格式打印一行，每个条目均为数值。",
            "solution": "用户提供了一个有效的问题陈述。任务是推导并计算二维可压缩纳维-斯托克斯方程的源项，这些源项将使给定的一组关于密度、速度和温度的解析函数成为其精确解。这个过程被称为制造解方法（Method of Manufactured Solutions, MMS），是验证数值求解器的一项基石技术。\n\n带有源项 $f_\\rho$、$\\mathbf{f}_{\\mathbf{m}}$ 和 $f_E$ 的守恒形式控制方程如下：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla\\cdot(\\rho \\mathbf{u}) = f_\\rho\n$$\n$$\n\\frac{\\partial (\\rho \\mathbf{u})}{\\partial t} + \\nabla\\cdot\\left(\\rho \\mathbf{u}\\mathbf{u}^\\top + p\\mathbf{I}\\right) = \\nabla\\cdot \\boldsymbol{\\tau} + \\mathbf{f}_{\\mathbf{m}}\n$$\n$$\n\\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] = \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) - \\nabla\\cdot \\mathbf{q} + f_E\n$$\n为了求出源项，我们重新整理这些方程：\n$$\nf_\\rho = \\frac{\\partial \\rho}{\\partial t} + \\nabla\\cdot(\\rho \\mathbf{u})\n$$\n$$\n\\mathbf{f}_{\\mathbf{m}} = \\frac{\\partial (\\rho \\mathbf{u})}{\\partial t} + \\nabla\\cdot\\left(\\rho \\mathbf{u}\\mathbf{u}^\\top + p\\mathbf{I}\\right) - \\nabla\\cdot \\boldsymbol{\\tau}\n$$\n$$\nf_E = \\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] - \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) + \\nabla\\cdot \\mathbf{q}\n$$\n求解过程需要通过对制造解的场函数进行微分，并将它们代入通量和其他派生量的表达式中，从而解析地计算出这些方程右侧的每一项。\n\n制造的场函数给定如下：\n$$\n\\rho(x,y,t) = \\rho_0\\left[1 + 0.1 A \\sin(\\pi x)\\cos(\\pi y) e^{-\\alpha t}\\right]\n$$\n$$\nu(x,y,t) = U_0 + 0.2 A \\cos(\\pi x)\\sin(\\pi y) e^{-\\alpha t}\n$$\n$$\nv(x,y,t) = V_0 + 0.15 A \\sin(2\\pi x)\\sin(\\pi y) e^{-\\alpha t}\n$$\n$$\nT(x,y,t) = T_0\\left[1 + 0.03 A \\cos(\\pi x)\\cos(2\\pi y) e^{-\\alpha t}\\right]\n$$\n从这些函数出发，我们推导出所有需要的关于空间（$x, y$）和时间（$t$）的一阶和二阶偏导数。例如，密度对时间的偏导数是：\n$$\n\\frac{\\partial \\rho}{\\partial t} = \\rho_0 \\left[ 0.1 A \\sin(\\pi x)\\cos(\\pi y) \\cdot (-\\alpha e^{-\\alpha t}) \\right] = -0.1 \\alpha A \\rho_0 \\sin(\\pi x)\\cos(\\pi y) e^{-\\alpha t}\n$$\n密度对 $x$ 的偏导数是：\n$$\n\\frac{\\partial \\rho}{\\partial x} = \\rho_0 \\left[ 0.1 A \\cdot \\pi\\cos(\\pi x)\\cos(\\pi y) e^{-\\alpha t} \\right] = 0.1 \\pi A \\rho_0 \\cos(\\pi x)\\cos(\\pi y) e^{-\\alpha t}\n$$\n对于 $\\rho$、$u$、$v$ 和 $T$ 的所有其他一阶和二阶导数，都可以推导出类似的表达式。\n\n源项的计算过程如下：\n\n**1. 质量源项 ($f_\\rho$)**\n质量源项是连续性方程的残差：\n$$\nf_\\rho = \\underbrace{\\frac{\\partial \\rho}{\\partial t}}_{\\text{时间导数}} + \\underbrace{\\frac{\\partial(\\rho u)}{\\partial x} + \\frac{\\partial(\\rho v)}{\\partial y}}_{\\text{质量通量散度}}\n$$\n使用乘法法则展开散度项，$f_\\rho = \\frac{\\partial \\rho}{\\partial t} + u\\frac{\\partial \\rho}{\\partial x} + \\rho\\frac{\\partial u}{\\partial x} + v\\frac{\\partial \\rho}{\\partial y} + \\rho\\frac{\\partial v}{\\partial y}$。每一项都使用解析导数计算。\n\n**2. 动量源项 ($\\mathbf{f}_{\\mathbf{m}} = [f_{m,x}, f_{m,y}]^\\top$)**\n动量源项是动量方程的残差。对于 $x$ 分量：\n$$\nf_{m,x} = \\frac{\\partial (\\rho u)}{\\partial t} + \\frac{\\partial (\\rho u^2 + p)}{\\partial x} + \\frac{\\partial (\\rho u v)}{\\partial y} - (\\nabla\\cdot \\boldsymbol{\\tau})_x\n$$\n这涉及到几个部分：\n-   **时间导数**：$\\frac{\\partial (\\rho u)}{\\partial t} = u \\frac{\\partial \\rho}{\\partial t} + \\rho \\frac{\\partial u}{\\partial t}$。\n-   **对流项和压力项**：$\\frac{\\partial (\\rho u^2)}{\\partial x} + \\frac{\\partial p}{\\partial x}$ 和 $\\frac{\\partial (\\rho u v)}{\\partial y}$。首先计算压力 $p = \\rho R T$ 及其导数，例如 $\\frac{\\partial p}{\\partial x} = R(T\\frac{\\partial \\rho}{\\partial x} + \\rho\\frac{\\partial T}{\\partial x})$。\n-   **粘性项**：粘性应力张量的散度 $(\\nabla\\cdot \\boldsymbol{\\tau})_x$。对于具有恒定粘度 $\\mu$ 的牛顿流体，此项为：\n    $$\n    (\\nabla\\cdot \\boldsymbol{\\tau})_x = \\mu \\left( \\frac{4}{3}\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{1}{3}\\frac{\\partial^2 v}{\\partial x \\partial y} \\right)\n    $$\n    这需要速度分量的二阶空间导数。\n$y$ 分量 $f_{m,y}$ 的推导与此类似。\n\n**3. 能量源项 ($f_E$)**\n能量源项是总能量方程的残差：\n$$\nf_E = \\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] - \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) + \\nabla\\cdot \\mathbf{q}\n$$\n计算涉及：\n-   **总能量**：$E = c_v T + \\frac{1}{2}(u^2+v^2)$，其中 $c_v = R/(\\gamma - 1)$。\n-   **时间导数**：$\\frac{\\partial (\\rho E)}{\\partial t}$，使用乘法法则展开。\n-   **对流项**：$\\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right]$，即总焓通量的散度。\n-   **粘性功项**：$\\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u})$。这可以展开为两部分：表面牵引力做的功 $(\\nabla\\cdot\\boldsymbol{\\tau})\\cdot\\mathbf{u}$ 和不可逆粘性耗散 $\\boldsymbol{\\tau}:\\nabla\\mathbf{u}$。\n-   **热通量项**：$\\nabla\\cdot\\mathbf{q}$。对于具有恒定热导率 $k$ 的傅里叶定律，$\\mathbf{q} = -k\\nabla T$，此项变为 $\\nabla\\cdot\\mathbf{q} = -k \\nabla^2 T = -k(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2})$。热导率由 $k = \\mu c_p / \\mathrm{Pr}$ 给出，其中 $c_p = \\gamma c_v$。\n\n对于每个测试用例，使用指定的参数（$\\gamma, R, \\rho_0$ 等）和评估点 $(x,y,t)$ 来计算所有导数和中间量的数值，然后将它们组合起来，得到最终的源项向量 $[f_\\rho, f_{m,x}, f_{m,y}, f_E]$。特殊情况，如无粘极限（$\\mu=0$，意味着 $k=0$）和常数场情况（$A=0$），都由相同的公式处理，这些公式会在项变为零时自然简化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sources(gamma, R, rho_0, U_0, V_0, T_0, mu, Pr, alpha, A, x, y, t):\n    \"\"\"\n    Computes the source terms for the compressible Navier-Stokes equations\n    for a given manufactured solution.\n    \"\"\"\n    # 0. Constants and trigonometric/exponential factors\n    pi = np.pi\n    c_v = R / (gamma - 1.0)\n    c_p = gamma * c_v\n    \n    if mu == 0:\n        k = 0.0\n    else:\n        k = mu * c_p / Pr\n        \n    exp_at = np.exp(-alpha * t)\n\n    s_px = np.sin(pi * x)\n    c_px = np.cos(pi * x)\n    s_py = np.sin(pi * y)\n    c_py = np.cos(pi * y)\n    s_2px = np.sin(2 * pi * x)\n    c_2px = np.cos(2 * pi * x)\n    s_2py = np.sin(2 * pi * y)\n    c_2py = np.cos(2 * pi * y)\n\n    # 1. Primitive variables and their derivatives\n    # rho\n    rho = rho_0 * (1 + 0.1 * A * s_px * c_py * exp_at)\n    d_rho_dt = rho_0 * 0.1 * A * s_px * c_py * (-alpha * exp_at)\n    d_rho_dx = rho_0 * 0.1 * A * (pi * c_px) * c_py * exp_at\n    d_rho_dy = rho_0 * 0.1 * A * s_px * (-pi * s_py) * exp_at\n\n    # u\n    u = U_0 + 0.2 * A * c_px * s_py * exp_at\n    d_u_dt = 0.2 * A * c_px * s_py * (-alpha * exp_at)\n    d_u_dx = 0.2 * A * (-pi * s_px) * s_py * exp_at\n    d_u_dy = 0.2 * A * c_px * (pi * c_py) * exp_at\n    d2_u_dx2 = 0.2 * A * (-pi**2 * c_px) * s_py * exp_at\n    d2_u_dy2 = 0.2 * A * c_px * (-pi**2 * s_py) * exp_at\n    d2_u_dxdy = 0.2 * A * (-pi * s_px) * (pi * c_py) * exp_at\n\n    # v\n    v = V_0 + 0.15 * A * s_2px * s_py * exp_at\n    d_v_dt = 0.15 * A * s_2px * s_py * (-alpha * exp_at)\n    d_v_dx = 0.15 * A * (2 * pi * c_2px) * s_py * exp_at\n    d_v_dy = 0.15 * A * s_2px * (pi * c_py) * exp_at\n    d2_v_dx2 = 0.15 * A * (-4 * pi**2 * s_2px) * s_py * exp_at\n    d2_v_dy2 = 0.15 * A * s_2px * (-pi**2 * s_py) * exp_at\n    d2_v_dxdy = 0.15 * A * (2 * pi * c_2px) * (pi * c_py) * exp_at\n\n    # T\n    T = T_0 * (1 + 0.03 * A * c_px * c_2py * exp_at)\n    d_T_dt = T_0 * 0.03 * A * c_px * c_2py * (-alpha * exp_at)\n    d_T_dx = T_0 * 0.03 * A * (-pi * s_px) * c_2py * exp_at\n    d_T_dy = T_0 * 0.03 * A * c_px * (-2 * pi * s_2py) * exp_at\n    d2_T_dx2 = T_0 * 0.03 * A * (-pi**2 * c_px) * c_2py * exp_at\n    d2_T_dy2 = T_0 * 0.03 * A * c_px * (-4 * pi**2 * c_2py) * exp_at\n\n    # 2. Intermediate quantities\n    p = rho * R * T\n    d_p_dx = R * (d_rho_dx * T + rho * d_T_dx)\n    d_p_dy = R * (d_rho_dy * T + rho * d_T_dy)\n    \n    E = c_v * T + 0.5 * (u**2 + v**2)\n\n    div_u = d_u_dx + d_v_dy\n    tau_xx = mu * (2 * d_u_dx - 2/3 * div_u)\n    tau_yy = mu * (2 * d_v_dy - 2/3 * div_u)\n    tau_xy = mu * (d_u_dy + d_v_dx)\n    \n    # 3. Compute source terms\n    # 3.1 Mass source f_rho\n    f_rho = d_rho_dt + (d_rho_dx * u + rho * d_u_dx) + (d_rho_dy * v + rho * d_v_dy)\n\n    # 3.2 Momentum source f_m\n    div_tau_x = mu * ((4/3) * d2_u_dx2 + d2_u_dy2 + (1/3) * d2_v_dxdy)\n    div_tau_y = mu * ((4/3) * d2_v_dy2 + d2_v_dx2 + (1/3) * d2_u_dxdy)\n\n    f_mx_t = d_rho_dt * u + rho * d_u_dt\n    f_mx_conv = (u * u * d_rho_dx + 2 * rho * u * d_u_dx) + (u * v * d_rho_dy + rho * v * d_u_dy + rho * u * d_v_dy)\n    f_mx = f_mx_t + f_mx_conv + d_p_dx - div_tau_x\n    \n    f_my_t = d_rho_dt * v + rho * d_v_dt\n    f_my_conv = (u * v * d_rho_dx + rho * v * d_u_dx + rho * u * d_v_dx) + (v * v * d_rho_dy + 2 * rho * v * d_v_dy)\n    f_my = f_my_t + f_my_conv + d_p_dy - div_tau_y\n\n    # 3.3 Energy source f_E\n    # Time derivative term d(rho*E)/dt\n    dE_dt = c_v * d_T_dt + u * d_u_dt + v * d_v_dt\n    d_rhoE_dt = E * d_rho_dt + rho * dE_dt\n\n    # Convective term div((rho*E+p)*u)\n    dE_dx = c_v * d_T_dx + u * d_u_dx + v * d_v_dx\n    d_rhoE_dx = E * d_rho_dx + rho * dE_dx\n    conv_E_x = (rho * E + p) * d_u_dx + u * (d_rhoE_dx + d_p_dx)\n\n    dE_dy = c_v * d_T_dy + u * d_u_dy + v * d_v_dy\n    d_rhoE_dy = E * d_rho_dy + rho * dE_dy\n    conv_E_y = (rho * E + p) * d_v_dy + v * (d_rhoE_dy + d_p_dy)\n    div_conv_E = conv_E_x + conv_E_y\n\n    # Viscous work term div(tau . u)\n    viscous_dissipation = tau_xx * d_u_dx + tau_yy * d_v_dy + tau_xy * (d_u_dy + d_v_dx)\n    div_tau_dot_u = u * div_tau_x + v * div_tau_y + viscous_dissipation\n\n    # Heat flux term div(q)\n    laplacian_T = d2_T_dx2 + d2_T_dy2\n    div_q = -k * laplacian_T\n\n    f_E = d_rhoE_dt + div_conv_E - div_tau_dot_u + div_q\n\n    return [f_rho, f_mx, f_my, f_E]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: general interior, viscous\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 1.8e-5, 'Pr': 0.72, 'alpha': 0.5, 'A': 1, \n         'x': 0.3, 'y': 0.7, 't': 1.2},\n        # Case 2: boundary point, initial time, viscous\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 1.8e-5, 'Pr': 0.72, 'alpha': 0.5, 'A': 1, \n         'x': 0, 'y': 0, 't': 0},\n        # Case 3: Euler limit, inviscid and adiabatic\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 0.0, 'Pr': 0.72, 'alpha': 0.5, 'A': 1, \n         'x': 1, 'y': 1, 't': 2.0},\n        # Case 4: constant fields, zero amplitude\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 1.8e-5, 'Pr': 0.72, 'alpha': 0.5, 'A': 0, \n         'x': 0.4, 'y': 0.6, 't': 3.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        f_rho, f_mx, f_my, f_E = compute_sources(**case)\n        # Format each result set as a string \"[v1,v2,v3,v4]\"\n        result_str = f\"[{f_rho},{f_mx},{f_my},{f_E}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于那些精确解未知的实际问题，仅仅验证代码的正确性是不够的，我们还必须评估计算结果的准确性。网格收敛性研究是估计离散误差的标准流程。本练习提供了一个实际场景，你将分析来自一系列加密网格的数据，计算观测到的精度阶数，并应用理查森外推法来估计与网格无关的解。",
            "id": "3979183",
            "problem": "考虑一个由欧拉方程或纳维-斯托克斯方程控制的定常、无粘或粘性流动。在计算流体动力学（CFD）中，当网格间距 $h$ 被加密时，对解的一个光滑泛函（例如一个积分量 $Q$，如升力系数、阻力系数或质量流量）进行有限体积（或有限差分）离散化，会产生一个依赖于网格的近似序列 $Q(h)$。在网格加密的条件下，当解足够光滑且格式一致时，主阶离散误差允许一个如下形式的渐近展开：\n$$\nQ(h) \\;=\\; Q^\\star \\;+\\; K\\,h^{p} \\;+\\; \\mathcal{O}(h^{p+1}),\n$$\n其中 $Q^\\star$ 是渐近（网格无关）解，$K$ 是一个与 $h$ 无关的常数，$p$ 是主导误差项的形式精度阶。对于具有特征间距 $h_1  h_2  h_3$ 的三套系统化加密网格，我们得到了三个相应的解 $Q_1, Q_2, Q_3$。\n\n您的任务是推导一个计算过程，以：\n1. 从这三套网格-解对中估计观测精度阶 $p$。\n2. 使用基于两套最密网格（即 $(h_1, Q_1)$ 和 $(h_2, Q_2)$）和推断出的精度阶 $p$ 的两点理查森外推法，估计渐近解 $Q^\\star$。\n3. 估计最密网格上离散误差的大小 $E_1 = |Q^\\star - Q_1|$。\n\n提供一个详细的、分步的推导，阐明获得 $p$, $Q^\\star$ 和 $E_1$ 计算公式的代数步骤。最终，您的任务是编写一个程序，输入三对 $(h, Q)$ 值，并输出包含三个条目 $[p, Q^\\star, E_1]$ 的列表，将结果四舍五入到八位小数。程序应处理四种不同的测试情况。",
            "solution": "所提出的问题是数值模拟验证与确认中的一个标准练习，具体涉及从网格加密研究中估计离散误差和观测精度阶。它在科学上是合理的、适定的，并包含了获得唯一解所需的所有必要信息。我们开始进行推导。\n\n该分析的基础在于，对于一个足够光滑的问题，应用一个一致的数值格式时其离散误差的行为。对于像欧拉或纳维-斯托克斯方程这样的控制性偏微分方程，有限体积或有限差分格式用离散算子 $L_h(U_h)=f_h$ 来近似连续微分算子 $L(u)=f$，其中 $U_h$ 是特征间距为 $h$ 的网格上的离散解。对于一个一致的格式，截断误差 $\\tau_h = L_h(u_{ex}) - f_h$（其中 $u_{ex}$ 是连续问题的精确解投影到网格上的结果）可以通过泰勒级数展开。对于一个 $p$ 阶格式，$\\tau_h = C h^p + \\mathcal{O}(h^{p+1})$。可以证明，在适当的稳定性和光滑性条件下，离散解本身的误差 $e_h = U_h - u_{ex}$，以及因此产生的解的光滑泛函 $Q(h)$ 的误差，都遵循类似的渐近展开。\n\n我们已知计算出的泛函 $Q(h)$ 的主阶渐近误差模型为：\n$$\nQ(h) \\;=\\; Q^\\star \\;+\\; K h^{p} \\;+\\; \\mathcal{O}(h^{p+1})\n$$\n其中 $Q^\\star$ 是泛函的精确、网格无关值，$K$ 是一个常数，$p$ 是形式精度阶，$h$ 是网格间距。在我们的分析中，我们将假设高阶项可以忽略不计，这对于足够小的 $h$ 是一个有效的近似。这将模型简化为：\n$$\nQ(h) \\approx Q^\\star + K h^p\n$$\n给定一个具有特征间距 $h_1  h_2  h_3$ 的三套网格序列及其对应的计算解 $Q_1 = Q(h_1)$、$Q_2 = Q(h_2)$ 和 $Q_3 = Q(h_3)$，我们可以写出一个包含三个未知数（$Q^\\star$, $K$, $p$）的方程组：\n\\begin{align*}\nQ_1 \\approx Q^\\star + K h_1^p \\quad (1) \\\\\nQ_2 \\approx Q^\\star + K h_2^p \\quad (2) \\\\\nQ_3 \\approx Q^\\star + K h_3^p \\quad (3)\n\\end{align*}\n\n**第1步：观测精度阶 $p$ 的推导**\n\n为了确定观测精度阶 $p$，我们必须消去未知数 $Q^\\star$ 和 $K$。我们首先通过对连续方程作差来消去 $Q^\\star$：\n$$\nQ_2 - Q_1 \\approx (Q^\\star + K h_2^p) - (Q^\\star + K h_1^p) = K (h_2^p - h_1^p) \\quad (4)\n$$\n$$\nQ_3 - Q_2 \\approx (Q^\\star + K h_3^p) - (Q^\\star + K h_2^p) = K (h_3^p - h_2^p) \\quad (5)\n$$\n这些方程表示了解随网格间距变化的函数关系。现在，我们可以通过将方程（5）除以方程（4）来消去常数 $K$，前提是 $Q_2 - Q_1 \\neq 0$：\n$$\n\\frac{Q_3 - Q_2}{Q_2 - Q_1} \\approx \\frac{K (h_3^p - h_2^p)}{K (h_2^p - h_1^p)} = \\frac{h_3^p - h_2^p}{h_2^p - h_1^p}\n$$\n这个方程将观测阶 $p$ 与解的值和网格间距联系起来。它对任何网格加密比都成立。令 $\\mathcal{R}_Q = \\frac{Q_3 - Q_2}{Q_2 - Q_1}$。我们接下来必须求解以下关于 $p$ 的非线性方程：\n$$\n\\mathcal{R}_Q = \\frac{h_3^p - h_2^p}{h_2^p - h_1^p}\n$$\n整理后得到我们要求根的函数：\n$$\nf(p) = \\frac{h_3^p - h_2^p}{h_2^p - h_1^p} - \\mathcal{R}_Q = 0\n$$\n这是一个超越方程，通常无法求得 $p$ 的闭式解。根据要求，一个符合原理的计算过程包括使用数值求根算法（如二分法或更复杂的 Brent 方法）来找到满足此方程的 $p$ 值。\n\n在网格加密比恒定的特殊情况下，即 $r = h_2/h_1 = h_3/h_2$，我们有 $h_2 = r h_1$ 和 $h_3 = r^2 h_1$。方程显著简化为：\n$$\n\\frac{Q_3 - Q_2}{Q_2 - Q_1} = \\frac{(r^2 h_1)^p - (r h_1)^p}{(r h_1)^p - h_1^p} = \\frac{h_1^p (r^{2p} - r^p)}{h_1^p (r^p - 1)} = \\frac{r^p(r^p - 1)}{r^p - 1} = r^p\n$$\n在这种情况下，$p$ 可以被解析地求出：$p = \\frac{\\ln\\left(\\frac{Q_3 - Q_2}{Q_2 - Q_1}\\right)}{\\ln(r)}$。然而，问题要求一个通用的过程，因此我们将实现数值求根方法。\n\n**第2步：渐近解 $Q^\\star$ 的推导**\n\n问题指定使用基于两套最密网格（$(h_1, Q_1)$、$(h_2, Q_2)$）和推断出的精度阶 $p$ 的两点 Richardson 外推法。我们使用方程 (1) 和 (2)：\n\\begin{align*}\nQ_1 \\approx Q^\\star + K h_1^p \\\\\nQ_2 \\approx Q^\\star + K h_2^p\n\\end{align*}\n我们的目标是消去 $K$ 并求解 $Q^\\star$。从第一个方程中，我们将 $K$ 表示为 $K \\approx (Q_1 - Q^\\star)/h_1^p$。将其代入第二个方程得到：\n$$\nQ_2 \\approx Q^\\star + \\frac{Q_1 - Q^\\star}{h_1^p} h_2^p = Q^\\star + (Q_1 - Q^\\star) \\left(\\frac{h_2}{h_1}\\right)^p\n$$\n令网格加密比为 $r_{21} = h_2/h_1$。方程变为：\n$$\nQ_2 \\approx Q^\\star + (Q_1 - Q^\\star) r_{21}^p\n$$\n我们现在求解 $Q^\\star$：\n\\begin{align*}\nQ_2 \\approx Q^\\star + Q_1 r_{21}^p - Q^\\star r_{21}^p \\\\\nQ_2 - Q_1 r_{21}^p \\approx Q^\\star (1 - r_{21}^p) \\\\\nQ^\\star \\approx \\frac{Q_2 - Q_1 r_{21}^p}{1 - r_{21}^p} = \\frac{Q_1 r_{21}^p - Q_2}{r_{21}^p - 1}\n\\end{align*}\n这就是用于求解 $Q^\\star$ 的 Richardson 外推公式。一个计算上更直观的形式是将 $Q^\\star$ 表示为对最密网格解 $Q_1$ 的一个加法修正：\n$$\nQ^\\star \\approx Q_1 + \\frac{Q_1 - Q_2}{r_{21}^p - 1}\n$$\n\n**第3步：最密网格上离散误差 $E_1$ 的估计**\n\n最密网格上的离散误差可以估计为外推的、网格无关解 $Q^\\star$ 与最密网格解 $Q_1$ 之间的差值。其大小定义为：\n$$\nE_1 = |Q^\\star - Q_1|\n$$\n使用上一步中 $Q^\\star - Q_1$ 的表达式，我们得到误差估计的直接公式：\n$$\nE_1 = \\left| \\frac{Q_1 - Q_2}{r_{21}^p - 1} \\right|\n$$\n至此，所需计算过程的推导完成。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Main function to process the test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: ((h1, h2, h3), (Q1, Q2, Q3))\n    test_cases = [\n        # Case A\n        ((0.01, 0.02, 0.04), (0.53388, 0.53352, 0.53208)),\n        # Case B\n        ((0.015, 0.03, 0.07), (1.20063448, 1.20205920, 1.20870400)),\n        # Case C\n        ((0.02, 0.04, 0.08), (0.0000008, 0.0000128, 0.0002048)),\n        # Case D\n        ((0.008, 0.01, 0.012), (0.749990284, 0.749984076, 0.74997619)),\n    ]\n\n    all_results = []\n    \n    for h_vals, Q_vals in test_cases:\n        h1, h2, h3 = h_vals\n        Q1, Q2, Q3 = Q_vals\n        \n        # --- Step 1: Compute the observed order of accuracy 'p' ---\n        \n        # Ratio of solution differences\n        # Handle potential division by zero, although not present in test data.\n        # This can happen if the solution is oscillatory or appears converged.\n        q_diff_21 = Q2 - Q1\n        if abs(q_diff_21)  1.0e-15:\n            # If the difference is zero, 'p' is undefined. This indicates an issue\n            # with the data (e.g., convergence has been reached within machine precision).\n            # For this problem, we can assume this won't happen based on the data.\n            p = np.nan\n        else:\n            q_ratio = (Q3 - Q2) / q_diff_21\n\n            # Define the function f(p) = 0 for the root-finding algorithm\n            # f(p) = (h3^p - h2^p) / (h2^p - h1^p) - q_ratio\n            def p_equation(p_val):\n                # Numerically stable evaluation for small p by factoring out h2^p and h1^p\n                term1_num = (h3 / h2)**p_val - 1.0\n                term1_den = 1.0 - (h1 / h2)**p_val\n                # Check for p_val=0, which would lead to 0/0\n                if abs(p_val)  1e-9:\n                    # Use L'Hopital's rule for p -> 0 limit\n                    # d/dp((a^p - 1)/(1 - b^p)) = (a^p log(a)) / (-b^p log(b)) -> log(a)/-log(b)\n                    h_ratio_term = np.log(h3 / h2) / -np.log(h1 / h2)\n                else:\n                    h_ratio_term = term1_num / term1_den\n                \n                return h_ratio_term - q_ratio\n\n            # Use SciPy's root-finding scalar function.\n            # A bracket of [0, 8] is a reasonable search range for order of accuracy.\n            try:\n                # Brent's method is typically used here, it's robust.\n                sol = root_scalar(p_equation, bracket=[0, 8], method='brentq')\n                p = sol.root\n            except ValueError:\n                # This may happen if the function does not cross zero in the bracket,\n                # e.g., for non-monotonic convergence.\n                p = np.nan\n\n        # --- Step 2: Compute the asymptotic solution Q_star ---\n\n        # Grid refinement ratio for the two finest grids\n        r21 = h2 / h1\n        \n        # Richardson extrapolation formula: Q_star = Q1 + (Q1 - Q2) / (r21^p - 1)\n        # Check for p=0 and r21=1, which is not the case here.\n        denominator = r21**p - 1.0\n        if abs(denominator)  1.0e-15:\n            Q_star = np.nan # Undefined extrapolation\n        else:\n            Q_star = Q1 + (Q1 - Q2) / denominator\n        \n        # --- Step 3: Compute the discretization error E1 ---\n        E1 = abs(Q_star - Q1)\n\n        # Store results rounded to 8 decimal places\n        case_result = [round(val, 8) for val in [p, Q_star, E1]]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    result_str = \",\".join([str(res) for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}