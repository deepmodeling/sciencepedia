{
    "hands_on_practices": [
        {
            "introduction": "理论分析告诉我们，一个有限差分格式*应该*具有特定的精度阶数。但是，我们如何确认计算机程序的实际执行确实达到了这个阶数呢？本练习介绍了网格加密研究，这是代码验证的基石。它使我们能够数值化地测量观测到的精度阶数，从而建立对我们模拟结果的信心。",
            "id": "3958504",
            "problem": "在计算流体动力学 (CFD) 中，用于离散化可压缩纳维-斯托克斯方程的空间导数算子，在用于生产模拟之前，必须在光滑的基准场上评估其精度。考虑在区间 $x \\in [0,1]$ 上的一个一维周期性测试场 $u(x)$，它代表了沿翼型剖面的无量纲化光滑壁面切向速度分布。您使用一个三点中心有限差分导数算子，在具有 $N_{1}$、$N_{2}$ 和 $N_{3}$ 个点的三个连续加密的均匀网格上近似 $u^{\\prime}(x)$，其中加密比固定为 $r = \\frac{h_{1}}{h_{2}} = \\frac{h_{2}}{h_{3}} = 2$，其中 $h_{k}$ 表示在第 $k$ 层上的网格间距。在网格点 $x_{i}$ 处的离散误差定义为 $e_{i}(h) = D_{h}u(x_{i}) - u^{\\prime}(x_{i})$，其中 $D_{h}$ 是网格间距为 $h$ 时的离散导数算子。\n\n设计一个系统的网格加密研究，从第一性原理出发，从基于泰勒级数的、针对光滑函数相容有限差分近似的截断误差定义开始，估计该导数算子的观测精度阶。在此基础上，推导适用于 $[0,1]$ 上均匀周期性网格的离散误差范数 $\\|e\\|_{L_{1}}$、$\\|e\\|_{L_{2}}$ 和 $\\|e\\|_{L_{\\infty}}$ 的形式，然后推导一个用加密比 $r$ 和在连续网格上测量的误差范数表示的观测精度阶 $p_{\\text{obs}}$ 的表达式。\n\n最后，将您推导的表达式应用于使用相同导数算子、在加密比 $r = 2$ 的三个网格上获得的以下 $L_{2}$ 范数误差测量值：\n$$\nE_{L_{2}}(h_{1}) = 2.985 \\times 10^{-3}, \\quad\nE_{L_{2}}(h_{2}) = 7.500 \\times 10^{-4}, \\quad\nE_{L_{2}}(h_{3}) = 1.885 \\times 10^{-4}.\n$$\n使用网格对 $(h_{1}, h_{2})$ 计算观测精度阶 $p_{\\text{obs}}$，并将您的最终数值结果四舍五入到四位有效数字。$p_{\\text{obs}}$ 是无量纲的，因此不需要物理单位。",
            "solution": "在计算流体动力学 (CFD) 中，对导数算子进行系统的网格加密研究，必须建立在有限差分分析所要求的相容性和光滑性假设之上。对于一个光滑函数 $u(x)$ 和一个相容的离散导数算子 $D_{h}$，在网格点 $x_{i}$ 处进行泰勒级数展开可以得到局部截断误差。对于一阶导数的三点中心有限差分近似，我们有\n$$\nD_{h}u(x_{i}) = \\frac{u(x_{i+1}) - u(x_{i-1})}{2h}.\n$$\n使用泰勒级数将 $u(x_{i \\pm 1})$ 在 $x_{i}$ 附近展开，并减去精确导数 $u^{\\prime}(x_{i})$，对于光滑的 $u$，可以得到与 $h^{2}$ 成正比的主阶截断误差，即\n$$\nD_{h}u(x_{i}) - u^{\\prime}(x_{i}) = \\frac{h^{2}}{6}u^{(3)}(\\xi_{i}) + \\mathcal{O}(h^{4}),\n$$\n其中 $\\xi_{i}$ 在 $x_{i}$ 的某个邻域内。这意味着在选定的范数下，存在一个渐近误差模型，\n$$\nE(h) = C h^{p} + \\mathcal{O}(h^{p+1}),\n$$\n其中 $C$ 是一个取决于 $u$ 和算子的常数，而 $p$ 是形式精度阶（此处对于光滑函数 $u$ 上的中心差分，预期 $p=2$）。观测精度阶 $p_{\\text{obs}}$ 是通过在连续加密的网格上测量误差，并在解进入渐近区后利用 $h$ 的幂律关系来估计的。\n\n在一个均匀周期性网格 $x_{i} = ih$（其中 $i = 0,1,\\dots,N-1$，间距 $h = 1/N$）上，离散误差样本为 $e_{i}(h) = D_{h}u(x_{i}) - u^{\\prime}(x_{i})$。模拟 $[0,1]$ 上连续 $L_{1}$、$L_{2}$ 和 $L_{\\infty}$ 范数的范数定义如下：\n$$\n\\|e\\|_{L_{1}} = \\int_{0}^{1} |e(x)| \\, dx \\approx h \\sum_{i=0}^{N-1} |e_{i}(h)|,\n$$\n$$\n\\|e\\|_{L_{2}} = \\left( \\int_{0}^{1} e(x)^{2} \\, dx \\right)^{1/2} \\approx \\left( h \\sum_{i=0}^{N-1} e_{i}(h)^{2} \\right)^{1/2},\n$$\n$$\n\\|e\\|_{L_{\\infty}} = \\sup_{x \\in [0,1]} |e(x)| \\approx \\max_{0 \\le i \\le N-1} |e_{i}(h)|.\n$$\n这些离散公式保留了范数作为全域误差度量的解释，并且是在均匀网格上评估离散化误差的标准方法。\n\n假设渐近模型 $E(h) = C h^{p}$ 占主导地位，考虑两个间距分别为 $h$ 和 $h/r$ 的连续网格，其中 $r > 1$ 是加密比。那么\n$$\n\\frac{E(h)}{E(h/r)} \\approx \\frac{C h^{p}}{C (h/r)^{p}} = r^{p}.\n$$\n两边取自然对数，得到\n$$\n\\ln\\!\\left( \\frac{E(h)}{E(h/r)} \\right) \\approx p \\ln(r),\n$$\n由此得出观测精度阶的估计量\n$$\np_{\\text{obs}} \\approx \\frac{\\ln\\!\\left( E(h) / E(h/r) \\right)}{\\ln(r)}.\n$$\n只要误差是在主阶项占主导的渐近范围内测量的，该估计量对任何范数都有效。\n\n我们现在将此应用于给定的 $L_{2}$ 误差，加密比 $r = 2$，网格对为 $(h_{1}, h_{2})$：\n$$\nE_{L_{2}}(h_{1}) = 2.985 \\times 10^{-3}, \\quad E_{L_{2}}(h_{2}) = 7.500 \\times 10^{-4}.\n$$\n计算比值\n$$\n\\frac{E_{L_{2}}(h_{1})}{E_{L_{2}}(h_{2})} = \\frac{2.985 \\times 10^{-3}}{7.500 \\times 10^{-4}} = 3.98.\n$$\n因此，\n$$\np_{\\text{obs}} \\approx \\frac{\\ln(3.98)}{\\ln(2)}.\n$$\n使用 $\\ln(4) = 2 \\ln(2)$ 和 $3.98 = 4 \\times 0.995$，我们有\n$$\n\\ln(3.98) = \\ln(4) + \\ln(0.995) \\approx 2 \\ln(2) - \\left(0.005 + \\frac{0.005^{2}}{2} + \\frac{0.005^{3}}{3} + \\cdots \\right),\n$$\n数值计算给出\n$$\n\\ln(3.98) \\approx 1.381281819, \\quad \\ln(2) \\approx 0.693147181,\n$$\n所以\n$$\np_{\\text{obs}} \\approx \\frac{1.381281819}{0.693147181} \\approx 1.992773\\ldots\n$$\n四舍五入到四位有效数字，\n$$\np_{\\text{obs}} \\approx 1.993.\n$$\n这个结果与中心有限差分导数算子应用于光滑场时的预期二阶行为是一致的。",
            "answer": "$$\\boxed{1.993}$$"
        },
        {
            "introduction": "来自实验的真实世界数据很少是完美平滑的；它几乎总是被噪声所污染。数值微分是一个“不适定”问题，它会显著放大这种噪声，这是信号处理和数据分析中的一个关键挑战。本练习将指导您完成一个实际模拟，以理解、预测和量化有限差分格式如何放大测量噪声，揭示了其与离散化误差之间的根本性权衡。",
            "id": "2392343",
            "problem": "给定一个一维位置关于时间的时序模型，该模型包含加性测量噪声。位置是一个平滑的、已知的时间函数，并在每个采样点上叠加了零均值的独立噪声。您的任务是设计并实现一个程序，该程序针对一组测试用例，构建带噪的位置数据，使用有限差分估计速度和加速度，并定量分析微分算子对测量噪声的放大效应。\n\n请仅基于以下基本定义和事实进行推理：函数的导数是差商的极限，线性算子作用于独立随机变量所产生的输出，其方差根据算子权重的平方进行叠加，以及泰勒级数展开可用于推导有限差分模板的局部截断误差阶。除这些原理外，请勿使用任何其他预先包装好的公式。\n\n使用以下信号模型。无噪声的位置为\n$$\nx(t) = A \\sin(2\\pi f_1 t) + C \\sin(2\\pi f_2 t) + D t^2,\n$$\n参数为\n$$\nA = 1.0\\ \\text{m},\\quad C = 0.5\\ \\text{m},\\quad f_1 = 1.0\\ \\text{Hz},\\quad f_2 = 3.0\\ \\text{Hz},\\quad D = 0.05\\ \\text{m/s}^2.\n$$\n三角函数中的角度以弧度为单位。精确的速度和加速度分别为，\n$$\nv(t) = \\frac{dx}{dt} = 2\\pi f_1 A \\cos(2\\pi f_1 t) + 2\\pi f_2 C \\cos(2\\pi f_2 t) + 2 D t,\n$$\n$$\na(t) = \\frac{d^2 x}{dt^2} = - (2\\pi f_1)^2 A \\sin(2\\pi f_1 t) - (2\\pi f_2)^2 C \\sin(2\\pi f_2 t) + 2 D.\n$$\n\n采样和噪声模型。对于每个测试用例，在以下时间点进行均匀采样\n$$\nt_n = n \\,\\Delta t,\\quad n=0,1,\\dots,N-1,\\quad N = \\left\\lfloor \\frac{T}{\\Delta t}\\right\\rfloor + 1,\\quad T = 10\\ \\text{s},\n$$\n并形成带噪测量值\n$$\nx_n^{\\text{noisy}} = x(t_n) + \\eta_n,\\quad \\eta_n \\sim \\mathcal{N}(0,\\sigma_x^2)\\ \\text{i.i.d.},\n$$\n为保证可复现性，使用一个固定的随机种子，其值为 $12345$。所有距离单位为米，时间单位为秒。\n\n有限差分要求。根据第一性原理，推导并实现用于一阶和二阶导数的二阶精度有限差分格式，具体如下：\n- 对于内部点，使用中心、二阶精度的模板。\n- 在两个边界处，使用单边、二阶精度的模板。\n您的实现必须生成与输入 $x_n$ 等长的数组 $v_n^{\\text{FD}}$ 和 $a_n^{\\text{FD}}$。\n\n噪声放大分析。设索引 $i$ 处的有限差分导数是以下线性组合\n$$\ny_i = \\sum_{j} w_{i,j} x_j,\n$$\n其中 $y_i$ 表示一阶或二阶导数的估计值，$w_{i,j}$ 是有限差分权重除以 $\\Delta t$ 的适当幂。仅使用期望的线性性质和噪声样本的独立性，推导并计算：\n- 一阶导数的经验均方根（RMS）噪声放大，\n$$\ng_v^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( v_i^{\\text{FD}}[x^{\\text{noisy}}] - v_i^{\\text{FD}}[x^{\\text{clean}}]\\right)^2 },\n$$\n以及二阶导数的经验均方根（RMS）噪声放大，\n$$\ng_a^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( a_i^{\\text{FD}}[x^{\\text{noisy}}] - a_i^{\\text{FD}}[x^{\\text{clean}}]\\right)^2 }.\n$$\n- 由权重预测的理论均方根（RMS）噪声放大，\n$$\ng^{\\text{theory}} = \\sigma_x \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\sum_{j} w_{i,j}^2 \\right) }.\n$$\n使用每个索引（包括边界模板）处实际使用的权重计算 $g_v^{\\text{theory}}$ 和 $g_a^{\\text{theory}}$。\n\n性能指标。对于每个测试用例，计算：\n- 速度估计值相对于精确速度的均方根误差，\n$$\nE_v = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( v_i^{\\text{FD}}[x^{\\text{noisy}}] - v(t_i) \\right)^2 } \\ \\text{in m/s}.\n$$\n- 加速度估计值相对于精确加速度的均方根误差，\n$$\nE_a = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( a_i^{\\text{FD}}[x^{\\text{noisy}}] - a(t_i) \\right)^2 } \\ \\text{in m/s}^2.\n$$\n- 比率\n$$\nR_v = \\frac{ g_v^{\\text{emp}} }{ g_v^{\\text{theory}} },\\qquad R_a = \\frac{ g_a^{\\text{emp}} }{ g_a^{\\text{theory}} },\n$$\n这些比率表明经验噪声放大与理论预测的匹配程度。\n\n测试套件。在以下四个测试用例上运行您的程序，这些用例改变了采样间隔和噪声水平：\n- 用例 $1$：$\\Delta t = 0.01\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n- 用例 $2$：$\\Delta t = 0.1\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n- 用例 $3$：$\\Delta t = 0.01\\ \\text{s}$，$\\sigma_x = 0.01\\ \\text{m}$。\n- 用例 $4$：$\\Delta t = 0.001\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的聚合结果。对于从 1 到 4 的每个用例，按以下顺序附加四个浮点数：$E_v$ (单位 m/s)、$E_a$ (单位 m/s$^2$)、$R_v$ (无量纲)、$R_a$ (无量纲)。每个数字必须以包含六位有效数字的科学记数法打印。例如，总输出格式为\n$$\n[\\ E_{v,1},\\ E_{a,1},\\ R_{v,1},\\ R_{a,1},\\ E_{v,2},\\ E_{a,2},\\ R_{v,2},\\ R_{a,2},\\ E_{v,3},\\ E_{a,3},\\ R_{v,3},\\ R_{a,3},\\ E_{v,4},\\ E_{a,4},\\ R_{v,4},\\ R_{a,4}\\ ].\n$$",
            "solution": "我们从第一性原理开始。函数 $x(t)$ 在时间 $t$ 的一阶导数由以下极限定义\n$$\n\\frac{dx}{dt}(t) = \\lim_{\\Delta t \\to 0} \\frac{x(t+\\Delta t) - x(t-\\Delta t)}{2\\Delta t},\n$$\n这表明对于有限但很小的 $\\Delta t$，应使用对称（中心）差商。二阶导数由以下公式定义\n$$\n\\frac{d^2x}{dt^2}(t) = \\lim_{\\Delta t \\to 0} \\frac{x(t+\\Delta t) - 2x(t) + x(t-\\Delta t)}{\\Delta t^2}.\n$$\n使用在 $t_i = i \\Delta t$ 附近的泰勒级数展开，\n$$\nx(t_{i\\pm 1}) = x(t_i) \\pm \\Delta t\\, x'(t_i) + \\frac{\\Delta t^2}{2} x''(t_i) \\pm \\frac{\\Delta t^3}{6} x^{(3)}(t_i) + \\frac{\\Delta t^4}{24} x^{(4)}(t_i) + \\mathcal{O}(\\Delta t^5),\n$$\n我们可以推导出用于内部点的二阶精度中心模板：\n$$\nx'(t_i) = \\frac{x_{i+1} - x_{i-1}}{2\\Delta t} + \\mathcal{O}(\\Delta t^2), \\quad\nx''(t_i) = \\frac{x_{i+1} - 2 x_i + x_{i-1}}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2),\n$$\n其中 $x_i = x(t_i)$。在边界处，无法形成对称差分；作为替代，使用前向点的泰勒展开可以得到单边、二阶精度的模板。对于左边界 $i=0$ 处的一阶导数，\n$$\nx'(t_0) = \\frac{-3 x_0 + 4 x_1 - x_2}{2\\Delta t} + \\mathcal{O}(\\Delta t^2),\n$$\n对于右边界 $i=N-1$ 处，情况类似，\n$$\nx'(t_{N-1}) = \\frac{3 x_{N-1} - 4 x_{N-2} + x_{N-3}}{2\\Delta t} + \\mathcal{O}(\\Delta t^2).\n$$\n对于二阶导数，前向和后向的二阶精度单边模板为\n$$\nx''(t_0) = \\frac{2 x_0 - 5 x_1 + 4 x_2 - x_3}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2), \\quad\nx''(t_{N-1}) = \\frac{2 x_{N-1} - 5 x_{N-2} + 4 x_{N-3} - x_{N-4}}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2).\n$$\n这些公式是通过求解方程组得到的，该方程组逐项匹配泰勒展开式以消除低阶误差项，从而确保二阶精度。\n\n噪声放大分析基于线性性。设将 $\\{x_j\\}$ 映射到导数估计值 $\\{y_i\\}$ 的有限差分算子是线性的：\n$$\ny_i = \\sum_{j} w_{i,j} x_j,\n$$\n其中 $w_{i,j}$ 是算子权重，包括根据导数阶数由 $\\Delta t$ 的适当幂次进行的归一化。假设测量值包含加性零均值独立噪声 $\\eta_j$，其方差为 $\\mathbb{V}[\\eta_j] = \\sigma_x^2$。由于线性和独立性，\n$$\n\\mathbb{E}[y_i] = \\sum_{j} w_{i,j} \\mathbb{E}[x_j], \\quad\n\\mathbb{V}[y_i] = \\sum_{j} w_{i,j}^2 \\,\\mathbb{V}[\\eta_j] = \\sigma_x^2 \\sum_{j} w_{i,j}^2.\n$$\n因此，索引 $i$ 处噪声分量的均方根（RMS）等于\n$$\n\\sqrt{\\mathbb{V}[y_i]} = \\sigma_x \\sqrt{\\sum_{j} w_{i,j}^2}.\n$$\n一个在所有索引上的全局 RMS，与实践中使用的经验 RMS 一致，为\n$$\ng^{\\text{theory}} = \\sigma_x \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left(\\sum_{j} w_{i,j}^2\\right)}.\n$$\n该表达式通过依赖于索引的权重自然地包含了边界效应。\n\n由此得出两个推论：\n- 对于一阶导数，权重与 $1/\\Delta t$ 成比例，因此 $g_v^{\\text{theory}} \\propto \\sigma_x/\\Delta t$；也就是说，如果每个样本的位置噪声水平固定，减小 $\\Delta t$ 会增加速度估计中的噪声放大。\n- 对于二阶导数，权重与 $1/\\Delta t^2$ 成比例，因此 $g_a^{\\text{theory}} \\propto \\sigma_x/\\Delta t^2$，这意味着噪声放大效应更强。\n\n经验均方根（RMS）噪声放大可以通过比较作用于带噪数据和干净数据的微分算子来分离，这会抵消确定性的截断误差：\n$$\ng^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( y_i[x^{\\text{noisy}}] - y_i[x^{\\text{clean}}] \\right)^2 }.\n$$\n因为 $y_i[\\cdot]$ 是线性的且 $x^{\\text{noisy}} = x^{\\text{clean}} + \\eta$，所以差值等于 $y_i[\\eta]$，在大量样本的极限下，其 RMS 与上面推导的理论表达式相匹配。因此，比率\n$$\nR_v = \\frac{g_v^{\\text{emp}}}{g_v^{\\text{theory}}},\\qquad R_a = \\frac{g_a^{\\text{emp}}}{g_a^{\\text{theory}}},\n$$\n当经验平均值具有代表性时，应接近于 $1$。\n\n算法设计：\n- 构建时间样本 $t_i = i \\Delta t$，$i=0,\\dots,N-1$，$T=10$ s。\n- 根据给定的解析表达式计算干净位置 $x(t_i)$、精确速度 $v(t_i)$ 和精确加速度 $a(t_i)$。\n- 使用固定的随机种子生成加性噪声 $\\eta_i \\sim \\mathcal{N}(0,\\sigma_x^2)$ 以确保可复现性，并形成 $x^{\\text{noisy}}_i = x(t_i) + \\eta_i$。\n- 实现用于一阶和二阶导数的二阶精度有限差分估计器，该估计器在内部应用中心模板，在边界应用单边模板，从而对干净和带噪输入都产生 $v^{\\text{FD}}$ 和 $a^{\\text{FD}}$。\n- 计算性能指标：$E_v$ 和 $E_a$ 作为与精确导数之间的 RMS 误差。计算 $g_v^{\\text{emp}}$ 和 $g_a^{\\text{emp}}$ 作为对带噪数据和干净数据应用有限差分输出之间的 RMS 差异。通过在每个索引处对权重的平方求和并取平均值，然后乘以 $\\sigma_x$ 并开方，来计算 $g_v^{\\text{theory}}$ 和 $g_a^{\\text{theory}}$。最后，计算 $R_v$ 和 $R_a$ 作为经验放大与理论放大的比率。\n- 对四个指定的测试用例重复此过程。以要求的单行、方括号括起、逗号分隔的列表形式打印汇总结果，使用科学记数法并保留六位有效数字。\n\n预期趋势：\n- 将 $\\sigma_x$ 增加 10 倍，应该会使 $g^{\\text{emp}}$ 以及 $E_v$ 和 $E_a$ 中由噪声主导的分量增加 10 倍。\n- 增加 $\\Delta t$ 应该会使 $g_v^{\\text{theory}}$ 大致按 $1/\\Delta t$ 减少，使 $g_a^{\\text{theory}}$ 大致按 $1/\\Delta t^2$ 减少；然而，截断误差按 $\\mathcal{O}(\\Delta t^2)$ 增长，因此由于截断误差和噪声放大之间的权衡，$E_v$ 和 $E_a$ 可能不会随 $\\Delta t$ 单调减小。\n- 比率 $R_v$ 和 $R_a$ 应接近 1，这验证了线性噪声放大分析的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef position(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # x(t) in meters\n    return A * np.sin(2*np.pi*f1*t) + C * np.sin(2*np.pi*f2*t) + D * t**2\n\ndef velocity_true(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # v(t) in m/s\n    return 2*np.pi*f1*A * np.cos(2*np.pi*f1*t) + 2*np.pi*f2*C * np.cos(2*np.pi*f2*t) + 2*D*t\n\ndef acceleration_true(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # a(t) in m/s^2\n    return -(2*np.pi*f1)**2 * A * np.sin(2*np.pi*f1*t) - (2*np.pi*f2)**2 * C * np.sin(2*np.pi*f2*t) + 2*D\n\ndef fd_first_derivative(x, dt):\n    \"\"\"\n    Second-order accurate finite difference for first derivative.\n    - One-sided 3-point at boundaries (order 2).\n    - Centered 3-point in interior (order 2).\n    Returns y of same length as x.\n    \"\"\"\n    n = x.size\n    y = np.empty_like(x, dtype=float)\n    if n  3:\n        raise ValueError(\"Need at least 3 points for second-order first derivative\")\n    # Left boundary: (-3 x0 + 4 x1 - x2)/(2 dt)\n    y[0] = (-3.0*x[0] + 4.0*x[1] - 1.0*x[2]) / (2.0*dt)\n    # Interior\n    y[1:-1] = (x[2:] - x[:-2]) / (2.0*dt)\n    # Right boundary: (3 xN-1 - 4 xN-2 + xN-3)/(2 dt)\n    y[-1] = (3.0*x[-1] - 4.0*x[-2] + 1.0*x[-3]) / (2.0*dt)\n    return y\n\ndef fd_second_derivative(x, dt):\n    \"\"\"\n    Second-order accurate finite difference for second derivative.\n    - One-sided 4-point at boundaries (order 2).\n    - Centered 3-point in interior (order 2).\n    Returns y of same length as x.\n    \"\"\"\n    n = x.size\n    y = np.empty_like(x, dtype=float)\n    if n  4:\n        raise ValueError(\"Need at least 4 points for second derivative with second-order accuracy\")\n    # Left boundary: (2 x0 - 5 x1 + 4 x2 - x3)/dt^2\n    y[0] = (2.0*x[0] - 5.0*x[1] + 4.0*x[2] - 1.0*x[3]) / (dt*dt)\n    # Interior\n    y[1:-1] = (x[2:] - 2.0*x[1:-1] + x[:-2]) / (dt*dt)\n    # Right boundary: (2 xN-1 - 5 xN-2 + 4 xN-3 - xN-4)/dt^2\n    y[-1] = (2.0*x[-1] - 5.0*x[-2] + 4.0*x[-3] - 1.0*x[-4]) / (dt*dt)\n    return y\n\ndef weights_sqsum_first(n, dt):\n    \"\"\"\n    For each index i, compute sum_j w_{i,j}^2 for the first derivative operator.\n    Returns an array s of length n with s[i] = sum_j w_{i,j}^2.\n    \"\"\"\n    s = np.zeros(n, dtype=float)\n    inv = 1.0 / (2.0*dt)\n    # Left boundary: (-3, 4, -1)/(2 dt)\n    coeffs = np.array([-3.0, 4.0, -1.0]) * inv\n    s[0] = np.sum(coeffs**2)\n    # Interior: [-1, +1] at i-1 and i+1\n    c = np.array([-1.0, 1.0]) * inv\n    val = np.sum(c**2)\n    s[1:-1] = val\n    # Right boundary: (1, -4, 3)/(2 dt) applied to (i-2, i-1, i)\n    coeffs = np.array([1.0, -4.0, 3.0]) * inv\n    s[-1] = np.sum(coeffs**2)\n    return s\n\ndef weights_sqsum_second(n, dt):\n    \"\"\"\n    For each index i, compute sum_j w_{i,j}^2 for the second derivative operator.\n    Returns an array s of length n with s[i] = sum_j w_{i,j}^2.\n    \"\"\"\n    s = np.zeros(n, dtype=float)\n    inv2 = 1.0 / (dt*dt)\n    # Left boundary: (2, -5, 4, -1)/dt^2\n    coeffs = np.array([2.0, -5.0, 4.0, -1.0]) * inv2\n    s[0] = np.sum(coeffs**2)\n    # Interior: (1, -2, 1)/dt^2\n    c = np.array([1.0, -2.0, 1.0]) * inv2\n    val = np.sum(c**2)\n    s[1:-1] = val\n    # Right boundary: (-1, 4, -5, 2)/dt^2 applied to (i-3, i-2, i-1, i)\n    coeffs = np.array([-1.0, 4.0, -5.0, 2.0]) * inv2\n    s[-1] = np.sum(coeffs**2)\n    return s\n\ndef rms(x):\n    return np.sqrt(np.mean(np.square(x)))\n\ndef format_float(x):\n    # Scientific notation with exactly six significant figures\n    return f\"{x:.6e}\"\n\ndef run_case(dt, sigma_x, rng):\n    T = 10.0\n    N = int(np.floor(T/dt)) + 1\n    t = np.linspace(0.0, dt*(N-1), N)\n    x_clean = position(t)\n    # Generate noise with given sigma\n    noise = rng.normal(loc=0.0, scale=sigma_x, size=N)\n    x_noisy = x_clean + noise\n\n    # True derivatives\n    v_true = velocity_true(t)\n    a_true = acceleration_true(t)\n\n    # Finite difference estimates\n    v_fd_clean = fd_first_derivative(x_clean, dt)\n    a_fd_clean = fd_second_derivative(x_clean, dt)\n    v_fd_noisy = fd_first_derivative(x_noisy, dt)\n    a_fd_noisy = fd_second_derivative(x_noisy, dt)\n\n    # RMS errors against exact\n    E_v = rms(v_fd_noisy - v_true)\n    E_a = rms(a_fd_noisy - a_true)\n\n    # Empirical noise amplification (difference noisy-clean)\n    g_v_emp = rms(v_fd_noisy - v_fd_clean)\n    g_a_emp = rms(a_fd_noisy - a_fd_clean)\n\n    # Theoretical noise amplification from weights\n    s1 = weights_sqsum_first(N, dt)\n    s2 = weights_sqsum_second(N, dt)\n    g_v_theory = sigma_x * np.sqrt(np.mean(s1))\n    g_a_theory = sigma_x * np.sqrt(np.mean(s2))\n\n    # Ratios (avoid division by zero, though here not zero)\n    R_v = g_v_emp / g_v_theory if g_v_theory > 0 else np.nan\n    R_a = g_a_emp / g_a_theory if g_a_theory > 0 else np.nan\n\n    return E_v, E_a, R_v, R_a\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (dt [s], sigma_x [m])\n    test_cases = [\n        (0.01, 0.001),   # Case 1\n        (0.1, 0.001),    # Case 2\n        (0.01, 0.01),    # Case 3\n        (0.001, 0.001),  # Case 4\n    ]\n\n    rng = np.random.default_rng(12345)\n\n    results = []\n    for dt, sigma_x in test_cases:\n        E_v, E_a, R_v, R_a = run_case(dt, sigma_x, rng)\n        results.extend([E_v, E_a, R_v, R_a])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(format_float(x) for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "虽然高阶格式是解析平滑解的强大工具，但当面对不连续性（如激波或材料界面）时，它们的行为会发生巨大变化。本练习探讨了一个类似于吉布斯效应的现象，即高阶有限差分在跳跃点附近会产生伪振荡和过冲。通过对一个简单的方波进行微分，您将量化这些人为现象，并对高阶方法在处理非平滑问题时的局限性获得关键的洞见。",
            "id": "2392401",
            "problem": "您的任务是研究在使用高阶有限差分 (FD) 格式逼近不连续周期函数的空间导数时，出现的类似于吉布斯现象的行为。考虑在 $[0,2\\pi)$ 上的周期函数 $f(x)$，其定义为\n$$\nf(x) = \\operatorname{sgn}(\\sin x),\n$$\n约定 $\\operatorname{sgn}(0)=1$。所有角度必须以弧度为单位。\n\n设 $N$ 为一个偶数。定义一个均匀网格 $x_j = jh$，其中 $j\\in\\{0,1,\\dots,N-1\\}$，间距为 $h = \\frac{2\\pi}{N}$，并施加周期性边界条件，使得索引对 $N$ 取模。对于偶数阶 $p=2m$（其中 $m\\in\\mathbb{N}$），令 $D_h f(x_j)$ 表示在 $x_j$ 处对 $f$ 的一阶导数的 $p$ 阶中心周期性有限差分逼近，该逼近由一个对称的 $(2m+1)$ 点模板构建。也就是说，存在系数 $\\{c_r\\}_{r=-m}^m$（其依赖于 $m$ 但不依赖于 $h$ 或 $j$）使得\n$$\nD_h f(x_j) = \\frac{1}{h}\\sum_{r=-m}^{m} c_r\\, f\\big(x_{(j+r)\\bmod N}\\big),\n$$\n并且对于任何次数至多为 $2m$ 的多项式 $q(x)$，当在单位间距的整数网格上求值时，该逼近满足 $D_h q(0) = q'(0)$。您必须完全按照所述处理周期性边界条件问题。\n\n为每个 $(N,p)$ 定义以下两个无量纲诊断量：\n1. 峰值放大因子\n$$\nA(N,p) = \\frac{\\max_{0\\le j\\le N-1}\\,\\big|D_h f(x_j)\\big|}{2/h}.\n$$\n2. 溢出均方根 (RMS) 归一化幅值\n$$\nE(N,p) = \\frac{\\left(\\frac{1}{|S|}\\sum_{j\\in S}\\big(D_h f(x_j)\\big)^2\\right)^{1/2}}{2/h},\n$$\n其中 $S$ 是所有网格索引 $j$ 的集合，这些索引与每个不连续点索引的循环索引距离严格大于 $1$。不连续点索引为 $j=0$（对应于 $x=0$）和 $j = N/2$（对应于 $x=\\pi$）。索引 $a$ 和 $b$ 之间的循环索引距离定义为 $d(a,b)=\\min\\{|a-b|,\\,N-|a-b|\\}$。因此，$S$ 排除了索引邻域 $\\{N-1,0,1\\}$ 和 $\\{N/2-1,N/2,N/2+1\\}$。\n\n您的程序必须为以下参数对 $(N,p)$ 的测试套件计算 $A(N,p)$ 和 $E(N,p)$：\n- $(64,2)$,\n- $(64,6)$,\n- $(32,8)$,\n- $(16,4)$,\n- $(10,8)$.\n\n所有计算都必须遵循给定的定义。您的最终输出必须是单行文本，包含一个逗号分隔的浮点数扁平列表，顺序为 $[A(64,2),E(64,2),A(64,6),E(64,6),A(32,8),E(32,8),A(16,4),E(16,4),A(10,8),E(10,8)]$。每个数字必须四舍五入到恰好 $6$ 位小数。例如，输出格式必须像这样\n\"[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901,0.789012,0.890123,0.901234,0.012345]\"。",
            "solution": "问题陈述经过严格验证，被认定为 **有效**。这是一个在计算物理和数值分析领域中定义明确、具有科学依据的问题。所有提供的参数、定义和约束都是自洽、一致且数学上精确的，从而可以得到唯一且有意义的解。该问题研究了将高阶有限差分格式应用于不连续函数时出现的类吉布斯现象，这是数值方法研究中的一个经典课题。\n\n解题过程如下。首先，我们确定通用的 $p$ 阶中心有限差分格式的系数。其次，我们在指定网格上对给定函数实施该格式。最后，我们为每个参数对 $(N,p)$ 计算所需的诊断量。\n\n**1. 有限差分系数的确定**\n\n问题指定了一个用于一阶导数的 $p=2m$ 阶中心、对称、$(2m+1)$ 点有限差分逼近，其中 $m \\in \\mathbb{N}$。系数 $\\{c_r\\}_{r=-m}^m$ 是通过要求该逼近对于次数最高为 $p$ 的任何多项式都精确来确定的。这等价于满足一组从函数 $g(x)$ 在点 $x_0$ 附近的泰勒级数展开导出的约束条件。\n该逼近由下式给出：\n$$\nD_h g(x_0) = \\frac{1}{h} \\sum_{r=-m}^{m} c_r g(x_0+rh)\n$$\n将泰勒级数 $g(x_0+rh) = \\sum_{k=0}^{\\infty} \\frac{(rh)^k}{k!} g^{(k)}(x_0)$ 代入公式可得：\n$$\nD_h g(x_0) = \\frac{1}{h} \\sum_{r=-m}^{m} c_r \\sum_{k=0}^{\\infty} \\frac{(rh)^k}{k!} g^{(k)}(x_0) = \\sum_{k=0}^{\\infty} \\left( \\frac{h^{k-1}}{k!} \\sum_{r=-m}^{m} c_r r^k \\right) g^{(k)}(x_0)\n$$\n为了使该式以 $O(h^p)$ 的误差阶逼近 $g'(x_0)$，$g'(x_0)$ 的系数必须为 $1$，而 $g^{(k)}(x_0)$（其中 $k \\in \\{0, 2, 3, \\dots, p\\}$）的系数必须为零。这产生了关于系数 $c_r$ 的以下矩条件系统：\n$$\n\\sum_{r=-m}^{m} c_r r^k = \\delta_{k,1}, \\quad \\text{for } k=0, 1, \\dots, p=2m\n$$\n其中 $\\delta_{k,1}$ 是克罗内克 δ。\n对于逼近一阶导数的中心模板，对称性要求 $c_0=0$ 且当 $r \\neq 0$ 时 $c_r = -c_{-r}$。这种对称性自动满足了所有偶数次幂 $k$ 的条件。\n- 对于 $k=0$，$\\sum c_r = c_0 + \\sum_{r=1}^m (c_r+c_{-r}) = 0$，该条件满足。\n- 对于偶数 $k \\ge 2$，$\\sum c_r r^k = c_0 \\cdot 0^k + \\sum_{r=1}^m (c_r r^k + c_{-r}(-r)^k) = \\sum_{r=1}^m (c_r r^k - c_r r^k) = 0$，该条件满足。\n\n非平凡的约束来自于 $k$ 的奇数次幂：\n$$\n\\sum_{r=-m}^{m} c_r r^k = \\delta_{k,1} \\quad \\text{for odd } k \\in \\{1, 3, \\dots, p-1=2m-1\\}\n$$\n利用对称性，该和式可以简化为：\n$$\n\\sum_{r=1}^m (c_r r^k + c_{-r}(-r)^k) = \\sum_{r=1}^m (c_r r^k - c_r (-1)^k r^k) = 2 \\sum_{r=1}^m c_r r^k = \\delta_{k,1}\n$$\n这就为 $m$ 个未知系数 $c_1, \\dots, c_m$ 产生了一个包含 $m$ 个线性方程的方程组：\n$$\n\\sum_{r=1}^{m} c_r r^{2i-1} = \\frac{1}{2} \\delta_{i,1} \\quad \\text{for } i=1, 2, \\dots, m\n$$\n该系统可以写成矩阵形式 $M\\mathbf{c}=\\mathbf{b}$，其中 $\\mathbf{c} = [c_1, \\dots, c_m]^T$，右侧项为 $\\mathbf{b} = [1/2, 0, \\dots, 0]^T$，矩阵 $M$ 的元素为 $M_{ij} = j^{2i-1}$，其中 $i,j \\in \\{1,\\dots,m\\}$。对于每个所需的阶数 $p$，该系统被数值求解。\n\n**2. 离散化与导数计算**\n\n问题定义在一个周期性域 $[0, 2\\pi)$ 上，有 $N$ 个网格点 $x_j=jh$（其中 $j \\in \\{0, \\dots, N-1\\}$）和网格间距 $h=2\\pi/N$。待微分的函数是 $f(x) = \\operatorname{sgn}(\\sin x)$，且约定 $\\operatorname{sgn}(0)=1$。在离散网格上，其值 $f_j = f(x_j)$ 为：\n- $f_j = 1$ 当 $x_j \\in [0, \\pi]$，对应于索引 $j \\in \\{0, 1, \\dots, N/2\\}$。\n- $f_j = -1$ 当 $x_j \\in (\\pi, 2\\pi)$，对应于索引 $j \\in \\{N/2+1, \\dots, N-1\\}$。\n该函数在 $x=0$（索引 $j=0$）和 $x=\\pi$（索引 $j=N/2$）处有跳跃不连续点。两个跳跃的幅度均为 $2$。\n\n每个网格点 $j$ 处的数值导数 $D_h f(x_j)$ 通过应用有限差分公式计算：\n$$\nD_h f(x_j) = \\frac{1}{h}\\sum_{r=-m}^{m} c_r f_{(j+r)\\bmod N}\n$$\n对索引的取模运算正确地实现了周期性边界条件。\n\n**3. 诊断量的计算**\n\n对于每对 $(N, p)$，从导数值数组 $\\{d_j\\}_{j=0}^{N-1}$（其中 $d_j = D_h f(x_j)$）计算两个无量纲诊断量。两个诊断量的归一化因子均为 $2/h$，它代表函数的跳跃幅度除以网格间距。\n\n- 峰值放大因子 $A(N,p)$ 衡量数值导数的最大过冲，并按特征尺度进行归一化：\n$$\nA(N,p) = \\frac{\\max_{0\\le j  N} |d_j|}{2/h}\n$$\n\n- 溢出均方根归一化幅值 $E(N,p)$ 衡量远离不连续点的伪振荡的能量。它是在一组特定的索引 $S$ 上计算的，这些索引“远离”不连续点 $j=0$ 和 $j=N/2$。如果一个索引 $j$ 与 $0$ 和 $N/2$ 的循环距离均严格大于 $1$，则该索引在 $S$ 中。循环距离为 $d(a,b)=\\min\\{|a-b|,\\,N-|a-b|\\}$。此条件排除了索引邻域 $\\{N-1,0,1\\}$ 和 $\\{N/2-1,N/2,N/2+1\\}$。该诊断量则为：\n$$\nE(N,p) = \\frac{\\sqrt{\\frac{1}{|S|}\\sum_{j\\in S} d_j^2}}{2/h}\n$$\n\n**4. 算法实现**\n\n构建一个 Python 脚本来为给定的测试套件自动化此过程。\n1. 创建一个辅助函数 `get_fd_coeffs(p)` 来求解系数 $c_r$ 的线性系统。它以阶数 $p$ 为输入，计算 $m=p/2$，构造矩阵 $M$ 和向量 $\\mathbf{b}$，求解 $[c_1, \\dots, c_m]$，并返回完整的对称系数集 $\\{c_r\\}_{r=-m}^m$。\n2. 主函数遍历测试用例列表 $(N, p)$。\n3. 对于每个用例，它根据定义初始化网格间距 $h$ 和函数数组 $f$，并使用辅助函数计算系数。\n4. 然后，它通过在每个网格点应用有限差分模板来计算导数数组 $d$，同时遵守周期性边界。\n5. 根据定义计算诊断量 $A(N,p)$ 和 $E(N,p)$。集合 $S$ 是通过对 NumPy 索引数组使用布尔索引来确定的。\n6. 每个用例计算出的 $A$ 和 $E$ 的值被附加到一个列表中。\n7. 最后，将结果列表格式化为单个字符串，其中每个数字都四舍五入到 $6$ 位小数，并打印到标准输出。\n此过程为问题提供了一个完整且可验证的解决方案。",
            "answer": "```python\nimport numpy as np\n\ndef get_fd_coeffs(p: int) - dict[int, float]:\n    \"\"\"\n    Computes the coefficients for a centered, p-th order finite difference\n    approximation of the first derivative.\n    The stencil is symmetric with 2m+1 points, where p = 2m.\n    \"\"\"\n    if p % 2 != 0 or p  2:\n        raise ValueError(\"Order p must be an even integer = 2.\")\n    \n    m = p // 2\n    \n    # We need to solve the linear system M*c = b for c = [c_1, ..., c_m]\n    # M_ij = j^(2i-1) for i,j in {1,...,m}\n    # b = [1/2, 0, ..., 0]\n    \n    M = np.zeros((m, m), dtype=float)\n    for i in range(1, m + 1):\n        for j in range(1, m + 1):\n            power = 2 * i - 1\n            M[i - 1, j - 1] = float(j)**power\n            \n    b = np.zeros(m, dtype=float)\n    b[0] = 0.5\n    \n    # Solve for c_1, ..., c_m\n    c_pos = np.linalg.solve(M, b)\n    \n    # Build the full symmetric coefficient dictionary\n    coeffs = {0: 0.0}\n    for r in range(1, m + 1):\n        coeffs[r] = c_pos[r - 1]\n        coeffs[-r] = -c_pos[r - 1]\n        \n    return coeffs\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (64, 2),\n        (64, 6),\n        (32, 8),\n        (16, 4),\n        (10, 8),\n    ]\n\n    results = []\n    for N, p in test_cases:\n        # 1. Setup grid and function\n        h = 2 * np.pi / N\n        m = p // 2\n        \n        # f(x) = sgn(sin(x)) with sgn(0)=1\n        # f_j = 1 for j in {0, ..., N/2}\n        # f_j = -1 for j in {N/2+1, ..., N-1}\n        f_values = np.ones(N, dtype=float)\n        f_values[N // 2 + 1:] = -1.0\n        \n        # 2. Get FD coefficients\n        coeffs = get_fd_coeffs(p)\n        \n        # 3. Compute the numerical derivative D_h f(x_j)\n        df_values = np.zeros(N, dtype=float)\n        for j in range(N):\n            derivative_sum = 0.0\n            for r in range(-m, m + 1):\n                # Using periodic boundary conditions with modulo operator\n                index = (j + r) % N\n                derivative_sum += coeffs[r] * f_values[index]\n            df_values[j] = derivative_sum / h\n        \n        # 4. Calculate the two diagnostics\n        norm_factor = 2.0 / h\n        \n        # A(N,p): Peak amplification factor\n        max_abs_deriv = np.max(np.abs(df_values))\n        A = max_abs_deriv / norm_factor\n        \n        # E(N,p): Spillover RMS normalized magnitude\n        # S is the set of indices j with cyclic distance  1 from 0 and N/2.\n        # d(j,0)  1  = j  1 and j  N-1\n        # d(j,N/2)  1 = |j-N/2|  1\n        indices = np.arange(N)\n        spillover_mask = (indices > 1)  (indices  N - 1)  (np.abs(indices - N / 2) > 1)\n        \n        df_spillover = df_values[spillover_mask]\n        \n        if df_spillover.size > 0:\n            rms_spillover = np.sqrt(np.mean(df_spillover**2))\n            E = rms_spillover / norm_factor\n        else:\n            E = 0.0 # No spillover points, so RMS error is zero.\n\n        results.extend([A, E])\n\n    # 5. Format and print the final output\n    formatted_results = [f\"{num:.6f}\" for num in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}