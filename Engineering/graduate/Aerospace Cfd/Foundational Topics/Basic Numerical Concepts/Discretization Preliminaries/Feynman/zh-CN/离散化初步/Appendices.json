{
    "hands_on_practices": [
        {
            "introduction": "在设计数值格式时，理论精度是首要目标之一。本练习将通过一个具体例子，展示如何系统地运用泰勒级数展开来消除低阶误差项，从而构建出具有更高阶精度的差分格式。掌握这一技巧是开发高级数值方法的基础，这些方法能够用更少的网格点精确捕捉复杂的流动现象。",
            "id": "3955828",
            "problem": "考虑一个光滑标量场 $u(x)$，它代表了航空航天应用中计算流体动力学（CFD）背景下的一个一维流动变量切片。您的任务是，在一个间距为 $h$ 的均匀网格上，仅使用模板点 $x_{i-2}$、$x_{i-1}$、$x_{i}$、$x_{i+1}$ 和 $x_{i+2}$，构建在网格节点 $x_{i}$ 处对二阶偏导数 $\\partial_{xx} u$ 的中心有限差分近似。从导数的基本定义和 $u(x)$ 在 $x_{i}$ 点的泰勒级数展开出发，推导一个形如下式的线性组合\n$$\n\\frac{1}{h^{2}}\\left(a_{0}\\,u(x_{i}) + a_{1}\\,\\big[u(x_{i+1}) + u(x_{i-1})\\big] + a_{2}\\,\\big[u(x_{i+2}) + u(x_{i-2})\\big]\\right)\n$$\n该组合以四阶精度近似 $\\partial_{xx} u(x_{i})$。通过以下关系式定义主截断误差系数 $C$\n$$\n\\frac{1}{h^{2}}\\left(a_{0}\\,u(x_{i}) + a_{1}\\,\\big[u(x_{i+1}) + u(x_{i-1})\\big] + a_{2}\\,\\big[u(x_{i+2}) + u(x_{i-2})\\big]\\right) \\;=\\; \\partial_{xx} u(x_{i}) \\;+\\; C\\,h^{4}\\,\\partial_{x}^{6}u(x_{i}) \\;+\\; \\mathcal{O}(h^{6}),\n$$\n其中 $\\partial_{x}^{6}u$ 表示 $u$ 对 $x$ 的六阶导数。利用泰勒级数，通过强制要求四阶精度来确定系数 $a_{0}$、$a_{1}$ 和 $a_{2}$，然后计算您的构造所隐含的 $C$ 的精确值。请以精确有理数的形式给出 $C$。最终答案不需要单位。不要四舍五入；请给出最简分数形式。",
            "solution": "所述问题具有科学依据、提法恰当、客观，并包含足够的信息以获得唯一解。这是使用泰勒级数分析推导有限差分格式的一个标准练习。因此，该问题被认为是有效的。\n\n目标是找到在网格节点 $x_i$ 处对二阶导数 $\\partial_{xx} u$ 的一个有限差分近似，其形式为：\n$$\n\\frac{1}{h^{2}}\\left(a_{0}\\,u(x_{i}) + a_{1}\\,\\big[u(x_{i+1}) + u(x_{i-1})\\big] + a_{2}\\,\\big[u(x_{i+2}) + u(x_{i-2})\\big]\\right)\n$$\n该近似必须是四阶精度的，这意味着它的泰勒级数展开必须与 $\\partial_{xx} u(x_i)$ 的泰勒级数展开在达到 $\\mathcal{O}(h^4)$ 阶项之前都相匹配。我们首先写出函数 $u(x)$ 在模板点 $x_{i \\pm 1}$ 和 $x_{i \\pm 2}$ 处围绕中心点 $x_i$ 的泰勒级数展开式。令 $u_j = u(x_j)$ 和 $u_i^{(k)} = \\partial_x^k u(x_i)$。均匀网格间距为 $h$，因此 $x_{i \\pm n} = x_i \\pm n h$。\n\n泰勒级数展开式为：\n$$u_{i+1} = u_i + h u_i^{(1)} + \\frac{h^2}{2!} u_i^{(2)} + \\frac{h^3}{3!} u_i^{(3)} + \\frac{h^4}{4!} u_i^{(4)} + \\frac{h^5}{5!} u_i^{(5)} + \\frac{h^6}{6!} u_i^{(6)} + \\mathcal{O}(h^7)$$\n$$u_{i-1} = u_i - h u_i^{(1)} + \\frac{h^2}{2!} u_i^{(2)} - \\frac{h^3}{3!} u_i^{(3)} + \\frac{h^4}{4!} u_i^{(4)} - \\frac{h^5}{5!} u_i^{(5)} + \\frac{h^6}{6!} u_i^{(6)} + \\mathcal{O}(h^7)$$\n$$u_{i+2} = u_i + (2h) u_i^{(1)} + \\frac{(2h)^2}{2!} u_i^{(2)} + \\frac{(2h)^3}{3!} u_i^{(3)} + \\frac{(2h)^4}{4!} u_i^{(4)} + \\frac{(2h)^5}{5!} u_i^{(5)} + \\frac{(2h)^6}{6!} u_i^{(6)} + \\mathcal{O}(h^7)$$\n$$u_{i-2} = u_i - (2h) u_i^{(1)} + \\frac{(2h)^2}{2!} u_i^{(2)} - \\frac{(2h)^3}{3!} u_i^{(3)} + \\frac{(2h)^4}{4!} u_i^{(4)} - \\frac{(2h)^5}{5!} u_i^{(5)} + \\frac{(2h)^6}{6!} u_i^{(6)} + \\mathcal{O}(h^7)$$\n\n所提出的格式使用了这些点的对称组合。将成对的展开式相加可以消去所有奇数阶导数项：\n$$u_{i+1} + u_{i-1} = 2u_i + 2\\frac{h^2}{2!}u_i^{(2)} + 2\\frac{h^4}{4!}u_i^{(4)} + 2\\frac{h^6}{6!}u_i^{(6)} + \\mathcal{O}(h^8)$$\n$$u_{i+1} + u_{i-1} = 2u_i + h^2 u_i^{(2)} + \\frac{h^4}{12}u_i^{(4)} + \\frac{h^6}{360}u_i^{(6)} + \\mathcal{O}(h^8)$$\n对于更外侧的点：\n$$u_{i+2} + u_{i-2} = 2u_i + 2\\frac{(2h)^2}{2!}u_i^{(2)} + 2\\frac{(2h)^4}{4!}u_i^{(4)} + 2\\frac{(2h)^6}{6!}u_i^{(6)} + \\mathcal{O}(h^8)$$\n$$u_{i+2} + u_{i-2} = 2u_i + 4h^2 u_i^{(2)} + \\frac{16h^4}{12}u_i^{(4)} + \\frac{64h^6}{360}u_i^{(6)} + \\mathcal{O}(h^8)$$\n$$u_{i+2} + u_{i-2} = 2u_i + 4h^2 u_i^{(2)} + \\frac{4}{3}h^4 u_i^{(4)} + \\frac{8}{45}h^6 u_i^{(6)} + \\mathcal{O}(h^8)$$\n\n现在，我们将这些和代入有限差分算子的一般形式。令 $L[u]$ 为该算子。\n$$L[u] = \\frac{1}{h^2} \\left( a_0 u_i + a_1(u_{i+1} + u_{i-1}) + a_2(u_{i+2} + u_{i-2}) \\right)$$\n$$L[u] = \\frac{1}{h^2} \\left[ a_0 u_i + a_1 \\left( 2u_i + h^2 u_i^{(2)} + \\frac{h^4}{12}u_i^{(4)} + \\frac{h^6}{360}u_i^{(6)} \\right) + a_2 \\left( 2u_i + 4h^2 u_i^{(2)} + \\frac{4}{3}h^4 u_i^{(4)} + \\frac{8}{45}h^6 u_i^{(6)} \\right) + \\mathcal{O}(h^8) \\right]$$\n我们根据 $u$ 在 $x_i$ 处的导数阶数收集各项：\n$$L[u] = \\frac{1}{h^2} \\left[ (a_0 + 2a_1 + 2a_2)u_i + (a_1 + 4a_2)h^2 u_i^{(2)} + \\left(\\frac{a_1}{12} + \\frac{4a_2}{3}\\right)h^4 u_i^{(4)} + \\left(\\frac{a_1}{360} + \\frac{8a_2}{45}\\right)h^6 u_i^{(6)} + \\mathcal{O}(h^8) \\right]$$\n$$L[u] = \\frac{(a_0 + 2a_1 + 2a_2)}{h^2} u_i + (a_1 + 4a_2) u_i^{(2)} + \\left(\\frac{a_1}{12} + \\frac{4a_2}{3}\\right)h^2 u_i^{(4)} + \\left(\\frac{a_1}{360} + \\frac{8a_2}{45}\\right)h^4 u_i^{(6)} + \\mathcal{O}(h^6)$$\n为使此表达式成为 $u_i^{(2)} = \\partial_{xx} u(x_i)$ 的四阶精度近似，系数必须满足以下条件：\n1.  $u_i$ 的系数必须为零：$a_0 + 2a_1 + 2a_2 = 0$。\n2.  $u_i^{(2)}$ 的系数必须为一：$a_1 + 4a_2 = 1$。\n3.  $u_i^{(4)}$ 的系数必须为零，以消除 $\\mathcal{O}(h^2)$ 误差项：$\\frac{a_1}{12} + \\frac{4a_2}{3} = 0$。\n\n我们求解这个关于 $a_0$、$a_1$ 和 $a_2$ 的三元线性方程组。由第三个方程可得：\n$$\\frac{a_1}{12} = -\\frac{4a_2}{3} \\implies a_1 = -16a_2$$\n将此代入第二个方程：\n$$-16a_2 + 4a_2 = 1 \\implies -12a_2 = 1 \\implies a_2 = -\\frac{1}{12}$$\n现在，我们求 $a_1$：\n$$a_1 = -16 \\left(-\\frac{1}{12}\\right) = \\frac{16}{12} = \\frac{4}{3}$$\n最后，使用第一个方程，我们求 $a_0$：\n$$a_0 = -2a_1 - 2a_2 = -2\\left(\\frac{4}{3}\\right) - 2\\left(-\\frac{1}{12}\\right) = -\\frac{8}{3} + \\frac{2}{12} = -\\frac{8}{3} + \\frac{1}{6}$$\n$$a_0 = -\\frac{16}{6} + \\frac{1}{6} = -\\frac{15}{6} = -\\frac{5}{2}$$\n系数为 $a_0 = -\\frac{5}{2}$，$a_1 = \\frac{4}{3}$ 以及 $a_2 = -\\frac{1}{12}$。\n\n使用这些系数，$\\mathcal{O}(h^2)$ 误差项消失了。主误差项是展开式中下一个非零项，即与 $h^4 u_i^{(6)}$ 成正比的项。问题将截断误差定义为：\n$$L[u] = \\partial_{xx} u(x_{i}) + C\\,h^{4}\\,\\partial_{x}^{6}u(x_{i}) + \\mathcal{O}(h^{6})$$\n根据我们的展开式，$h^4 u_i^{(6)}$ 的系数是 $C$。我们可以从我们推导出的 $L[u]$ 表达式中确定 $C$：\n$$C = \\frac{a_1}{360} + \\frac{8a_2}{45}$$\n代入 $a_1$ 和 $a_2$ 的值：\n$$C = \\frac{4/3}{360} + \\frac{8(-1/12)}{45} = \\frac{4}{3 \\cdot 360} - \\frac{8}{12 \\cdot 45}$$\n$$C = \\frac{4}{1080} - \\frac{8}{540} = \\frac{1}{270} - \\frac{8}{540}$$\n为了进行减法，我们使用公分母 $540$：\n$$C = \\frac{2}{540} - \\frac{8}{540} = -\\frac{6}{540}$$\n化简该分数即可得到主截断误差系数的最终值：\n$$C = -\\frac{1}{90}$$",
            "answer": "$$\\boxed{-\\frac{1}{90}}$$"
        },
        {
            "introduction": "设计出精确的格式后，我们必须确保其稳定性，否则数值解可能因误差的无限放大而变得毫无意义。本练习将介绍冯·诺依曼稳定性分析，这是一种强大的工具，用于预测误差随时间的演化。通过分析线性平流方程的一阶迎风格式，您将亲手推导出著名的 Courant–Friedrichs–Lewy (CFL) 条件，这是计算流体力学中显式时间推进方法的基石。",
            "id": "3955901",
            "problem": "考虑线性平流（输运）方程 $\\partial_{t} u + a \\partial_{x} u = 0$，其中波速 $a \\in \\mathbb{R}$ 为常数，方程定义在一个无限、均匀的网格上，空间步长为 $\\Delta x$，显式时间步长为 $\\Delta t$。令 $u^{n}_{j}$ 表示在空间节点 $x_{j} = j\\,\\Delta x$ 和时间层 $t^{n} = n\\,\\Delta t$ 上对 $u$ 的数值近似。时间上使用前向欧拉法进行离散，空间上使用一阶迎风差分，根据 $a$ 的符号选择（沿特征线方向迎风）：\n- 如果 $a \\ge 0$，空间上使用后向差分。\n- 如果 $a \\le 0$，空间上使用前向差分。\n定义无量纲的 Courant–Friedrichs–Lewy (CFL) 数 $C = |a|\\,\\Delta t/\\Delta x$。\n\n对此线性常系数格式使用 von Neumann (傅里叶) 稳定性分析，从离散傅里叶模态的定义和更新的线性性质出发：\n- 推导单步放大因子的闭式表达式，该表达式是无量纲波数 $\\theta \\in [-\\pi,\\pi]$ 和带符号的 Courant 数 $\\nu = a\\,\\Delta t/\\Delta x$ 的函数。\n- 从第一性原理出发，确定 $\\nu$ 的必要和充分条件，使得该格式在傅里叶（能量）意义下是稳定的，即放大矩阵的谱半径（等价于 $\\sup_{\\theta} |G(\\theta;\\nu)|$）不超过 $1$。\n- 用 CFL 数 $C$ 表示此稳定性界限，并计算最大允许 CFL 数的精确值\n$$\nC_{\\max} \\equiv \\sup \\{\\, C \\ge 0 \\;:\\; \\sup_{\\theta \\in [-\\pi,\\pi]} |G(\\theta;\\nu)| \\le 1 \\,\\}.\n$$\n\n报告 $C_{\\max}$ 的唯一精确值作为最终答案。CFL 数是无量纲的，不需要单位。不要提供不等式；只提供最大允许值 $C_{\\max}$。",
            "solution": "问题陈述是有限差分格式稳定性分析中的一个标准练习，并且是有效的。它具有科学依据，是适定的、客观的且完整的。我们将按要求进行推导。\n\n控制偏微分方程是线性平流方程：\n$$\n\\partial_{t} u + a \\partial_{x} u = 0\n$$\n其中 $a \\in \\mathbb{R}$ 是恒定波速。\n数值网格由 $x_j = j\\,\\Delta x$ 和 $t^n = n\\,\\Delta t$ 定义，其中 $u^n_j$ 近似于 $u(x_j, t^n)$。时间导数使用一阶前向欧拉格式进行离散：$\\partial_t u \\approx (u_j^{n+1} - u_j^n)/\\Delta t$。空间导数使用一阶迎风格式进行离散，这取决于波速 $a$ 的符号。\n\n我们根据 $a$ 的符号考虑两种情况。\n\n情况 1: $a \\ge 0$ (波沿 $x$ 正方向传播)\n迎风方向来自左侧，因此我们对空间导数使用后向差分：$\\partial_x u \\approx (u_j^n - u_{j-1}^n)/\\Delta x$。有限差分方程 (FDE) 为：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + a \\frac{u_j^n - u_{j-1}^n}{\\Delta x} = 0\n$$\n对 $u_j^{n+1}$ 进行整理，并引入带符号的 Courant 数 $\\nu = a\\,\\Delta t/\\Delta x$（在这种情况下是非负的，$\\nu \\ge 0$），我们得到：\n$$\nu_j^{n+1} = u_j^n - \\nu (u_j^n - u_{j-1}^n)\n$$\n为进行 von Neumann 稳定性分析，我们代入单个傅里叶模态 $u_j^n = \\hat{u}^n \\exp(ij\\theta)$，其中 $\\theta = k\\Delta x$ 是波数为 $k$ 的模态的无量纲波数，$\\hat{u}^n$ 是时间层 $n$ 上的振幅。\n$$\n\\hat{u}^{n+1} \\exp(ij\\theta) = \\hat{u}^n \\exp(ij\\theta) - \\nu (\\hat{u}^n \\exp(ij\\theta) - \\hat{u}^n \\exp(i(j-1)\\theta))\n$$\n放大因子 $G(\\theta; \\nu) = \\hat{u}^{n+1}/\\hat{u}^n$ 可以通过除以 $\\hat{u}^n \\exp(ij\\theta)$ 得到：\n$$\nG(\\theta; \\nu) = 1 - \\nu (1 - \\exp(-i\\theta))\n$$\n为了保证稳定性，对所有 $\\theta \\in [-\\pi, \\pi]$，放大因子的模都不能超过 $1$，即 $|G(\\theta; \\nu)| \\le 1$。我们可以将 $G$ 表示为：\n$$\nG(\\theta; \\nu) = (1 - \\nu) + \\nu \\exp(-i\\theta)\n$$\n这个表达式描述了复平面上的一个圆，其圆心为 $c = 1 - \\nu$，半径为 $r = \\nu$。为使整个圆位于单位圆盘 $|z| \\le 1$ 内，必须满足条件 $|c| + r \\le 1$。\n$$\n|1 - \\nu| + \\nu \\le 1\n$$\n由于我们处于 $\\nu \\ge 0$ 的情况，我们考虑绝对值的两种子情况：\n1. 如果 $0 \\le \\nu \\le 1$，那么 $1 - \\nu \\ge 0$，条件变为 $(1 - \\nu) + \\nu \\le 1$，化简为 $1 \\le 1$。这总是成立的。\n2. 如果 $\\nu  1$，那么 $1 - \\nu  0$，条件变为 $-(1 - \\nu) + \\nu \\le 1$，化简为 $2\\nu - 1 \\le 1$，即 $\\nu \\le 1$。这与假设 $\\nu  1$ 相矛盾。\n因此，对于 $a \\ge 0$，稳定性条件是 $0 \\le \\nu \\le 1$。\n\n情况 2: $a \\le 0$ (波沿 $x$ 负方向传播)\n迎风方向来自右侧，因此我们对空间导数使用前向差分：$\\partial_x u \\approx (u_{j+1}^n - u_j^n)/\\Delta x$。有限差分方程 (FDE) 为：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + a \\frac{u_{j+1}^n - u_j^n}{\\Delta x} = 0\n$$\n同样，引入 $\\nu = a\\,\\Delta t/\\Delta x$（在这种情况下是非正的，$\\nu \\le 0$），我们得到：\n$$\nu_j^{n+1} = u_j^n - \\nu (u_{j+1}^n - u_j^n)\n$$\n代入傅里叶模态 $u_j^n = \\hat{u}^n \\exp(ij\\theta)$:\n$$\n\\hat{u}^{n+1} \\exp(ij\\theta) = \\hat{u}^n \\exp(ij\\theta) - \\nu (\\hat{u}^n \\exp(i(j+1)\\theta) - \\hat{u}^n \\exp(ij\\theta))\n$$\n通过除以 $\\hat{u}^n \\exp(ij\\theta)$ 得到放大因子：\n$$\nG(\\theta; \\nu) = 1 - \\nu (\\exp(i\\theta) - 1)\n$$\n这可以重写为：\n$$\nG(\\theta; \\nu) = (1 + \\nu) - \\nu \\exp(i\\theta)\n$$\n这个表达式描述了复平面上的一个圆，其圆心为 $c = 1 + \\nu$，半径为 $r = |-\\nu| = -\\nu$ (因为 $\\nu \\le 0$)。稳定性条件 $|c| + r \\le 1$ 变为：\n$$\n|1 + \\nu| - \\nu \\le 1\n$$\n由于 $\\nu \\le 0$，我们考虑绝对值的两种子情况：\n1. 如果 $-1 \\le \\nu \\le 0$，那么 $1 + \\nu \\ge 0$，条件是 $(1 + \\nu) - \\nu \\le 1$，化简为 $1 \\le 1$。这总是成立的。\n2. 如果 $\\nu  -1$，那么 $1 + \\nu  0$，条件是 $-(1 + \\nu) - \\nu \\le 1$，化简为 $-1 - 2\\nu \\le 1$，即 $\\nu \\ge -1$。这与假设 $\\nu  -1$ 相矛盾。\n因此，对于 $a \\le 0$，稳定性条件是 $-1 \\le \\nu \\le 0$。\n\n结果总结\n一阶迎风格式的放大因子 $G(\\theta; \\nu)$ 由下式给出：\n$$\nG(\\theta; \\nu) = \n\\begin{cases} \n1 - \\nu (1 - \\exp(-i\\theta))   \\text{若 } \\nu \\ge 0 \\\\\n1 - \\nu (\\exp(i\\theta) - 1)   \\text{若 } \\nu \\le 0 \n\\end{cases}\n$$\n傅里叶稳定性的充要条件 $|G(\\theta; \\nu)| \\le 1$ (对所有 $\\theta$)，可以通过结合两种情况的结果得到：\n$$\n-1 \\le \\nu \\le 1\n$$\n这可以紧凑地写成 $|\\nu| \\le 1$。\n\n问题将（非负的）CFL 数定义为 $C = |a|\\,\\Delta t/\\Delta x$。我们可以将其与带符号的 Courant 数 $\\nu = a\\,\\Delta t/\\Delta x$ 联系起来。注意到 $C = |\\nu|$。\n因此，稳定性条件 $|\\nu| \\le 1$ 等价于：\n$$\nC \\le 1\n$$\n由于 $C$ 根据定义是非负的，所以稳定性界限是 $0 \\le C \\le 1$。\n\n问题要求的是最大允许 CFL 数 $C_{\\max}$，定义为：\n$$\nC_{\\max} \\equiv \\sup \\{\\, C \\ge 0 \\;:\\; \\sup_{\\theta \\in [-\\pi,\\pi]} |G(\\theta;\\nu)| \\le 1 \\,\\}\n$$\n允许的 $C$ 值的集合是区间 $[0, 1]$。这个集合的上确界是 $1$。\n因此，最大允许 CFL 数是 $1$。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "理论分析固然重要，但我们如何验证代码的实际表现是否符合理论预期呢？本练习将指导您完成一个通过网格加密研究进行经验性精度阶验证的完整过程。通过在一系列逐渐加密的网格上将数值解与已知精确解进行比较，您将学会如何度量代码的收敛率，并识别可能影响结果的常见陷阱。",
            "id": "3955888",
            "problem": "考虑一项任务：在计算流体力学 (CFD) 中，凭经验估算空间离散化的精度阶。其理论基础是空间导数的定义以及使用泰勒级数展开来推导有限差分近似。设一个足够光滑的标量场 $u(x)$ 定义在闭区间 $[0,1]$ 上，并考虑一系列具有 $N$ 个网格点、网格间距 $h = \\frac{1}{N-1}$ 和网格节点 $x_i = i h$（其中 $i = 0,1,\\dots,N-1$）的均匀网格。\n\n你的目标是：\n1. 在均匀网格上，为一阶导数 $u'(x)$ 推导并实现二阶精度的有限差分格式：\n   - 对内部节点使用二阶中心差分。\n   - 在边界处使用二阶单边差分。\n   推导必须从泰勒级数展开和 $u'(x)$ 的定义出发，而不是先验地假设目标公式。\n2. 对每个网格，计算 $u'(x)$ 的离散近似，并评估离散 $L^2$ 误差范数\n   $$E(h) = \\left( h \\sum_{i=0}^{N-1} \\left( u'_h(x_i) - u'(x_i) \\right)^2 \\right)^{1/2},$$\n   其中 $u'_h(x_i)$ 表示由你的有限差分格式计算出的节点 $x_i$ 处的数值导数。\n3. 使用具有恒定加密比的网格加密研究，通过对 $\\log E(h)$ 与 $\\log h$ 进行最小二乘拟合来估算经验精度阶 $p$，即求最佳拟合线的斜率\n   $$\\log E(h) \\approx \\alpha + p \\log h.$$\n   经验阶 $p$ 必须从至少三个网格层级计算得出。\n\n在你的解决方案中需要考虑和讨论的陷阱：\n- 在粗网格上的非渐近区域，高阶截断项不可忽略，这可能会扭曲估算出的 $p$ 值。\n- 边界层效应，其中局部陡峭的梯度可能主导全局误差，从而改变表观收敛率，除非网格能充分解析边界层的厚度。\n\n为以下测试套件实现此过程，该套件旨在探究经验阶测量的不同方面：\n\n- 测试用例 A（理想情况，光滑且解析良好）：\n  - 函数 $u(x) = \\sin(2\\pi x)$，其精确导数为 $u'(x) = 2\\pi \\cos(2\\pi x)$。\n  - 网格 $N \\in \\{50, 100, 200\\}$。\n- 测试用例 B（高频内容的非渐近粗略解析）：\n  - 函数 $u(x) = \\sin(12\\pi x)$，其精确导数为 $u'(x) = 12\\pi \\cos(12\\pi x)$。\n  - 网格 $N \\in \\{12, 24, 48\\}$。\n- 测试用例 C（边界层效应）：\n  - 函数 $u(x) = \\tanh\\!\\left(\\frac{x}{\\delta}\\right)$，其精确导数为 $u'(x) = \\frac{1}{\\delta}\\,\\mathrm{sech}^2\\!\\left(\\frac{x}{\\delta}\\right)$，其中 $\\delta = 10^{-2}$。\n  - 网格 $N \\in \\{100, 200, 400\\}$。\n\n你的程序必须：\n- 实现上述从第一性原理推导出的二阶有限差分格式。\n- 对每个测试用例，计算指定网格的误差 $E(h)$，并通过对 $(\\log h, \\log E(h))$ 数据点进行最小二乘法来估算经验阶 $p$。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[p_A, p_B, p_C]$，其中 $p_A$、$p_B$ 和 $p_C$ 是分别表示测试用例 A、B 和 C 的估算经验阶的浮点数。\n\n不涉及物理单位；所有量均为无量纲。三角函数中的角度以弧度为单位。最终输出必须严格符合指定格式，不得包含任何额外文本。",
            "solution": "该问题要求推导并实现一个用于计算一阶导数的二阶精度有限差分格式，然后对三个不同的测试用例进行精度阶的经验性估算。解决方案分几步呈现：数值格式的推导、误差分析方法的描述，以及针对已知的数值分析陷阱对特定测试用例的讨论。\n\n### 1. 二阶有限差分格式的推导\n\n我们的任务是在均匀网格 $x_i = i h$（$i = 0, 1, \\dots, N-1$）上近似一个足够光滑的函数 $u(x)$ 的一阶导数 $u'(x)$，其中网格间距为 $h = 1/(N-1)$。该格式必须是二阶精度的，即截断误差必须为 $O(h^2)$。我们需要为内部节点和边界节点使用不同的公式。\n\n#### 1.1. 内部节点：中心差分格式\n对于一个内部节点 $x_i$（其中 $1 \\le i \\le N-2$），我们可以访问其相邻点 $x_{i-1} = x_i - h$ 和 $x_{i+1} = x_i + h$。我们使用 $u(x)$ 在 $x_i$ 点的泰勒级数展开：\n$$u(x_{i+1}) = u(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)$$\n$$u(x_{i-1}) = u(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)$$\n从第一个展开式中减去第二个展开式，得到：\n$$u(x_{i+1}) - u(x_{i-1}) = 2h u'(x_i) + \\frac{h^3}{3} u'''(x_i) + O(h^5)$$\n对 $u'(x_i)$ 求解：\n$$u'(x_i) = \\frac{u(x_{i+1}) - u(x_{i-1})}{2h} - \\frac{h^2}{6} u'''(x_i) + O(h^4)$$\n有限差分近似 $u'_h(x_i)$ 取为右侧的第一项。截断误差的主项是 $-\\frac{h^2}{6} u'''(x_i)$，这表明该格式是二阶精度的。\n$$u'_h(x_i) = \\frac{u(x_{i+1}) - u(x_{i-1})}{2h}, \\quad \\text{for } i = 1, \\dots, N-2$$\n\n#### 1.2. 边界节点：单边格式\n在边界点 $x_0$ 和 $x_{N-1}$ 处，无法使用中心差分。我们必须使用能保持二阶精度的单边公式。我们使用待定系数法来推导这些公式。\n\n**左边界 ($i=0$)：** 我们寻求一个形如 $u'_h(x_0) \\approx a u(x_0) + b u(x_1) + c u(x_2)$ 的公式。我们将 $u(x_1) = u(x_0+h)$ 和 $u(x_2) = u(x_0+2h)$ 在 $x_0$ 点展开：\n$$u(x_1) = u(x_0) + h u'(x_0) + \\frac{h^2}{2} u''(x_0) + O(h^3)$$\n$$u(x_2) = u(x_0) + 2h u'(x_0) + \\frac{(2h)^2}{2} u''(x_0) + O(h^3) = u(x_0) + 2h u'(x_0) + 2h^2 u''(x_0) + O(h^3)$$\n将这些展开式代入 $u'_h(x_0)$ 的公式，并按 $u$ 在 $x_0$ 点的各阶导数整理各项：\n$$a u_0 + b u_1 + c u_2 = (a+b+c)u(x_0) + (bh + 2ch)u'(x_0) + (b\\frac{h^2}{2} + c\\frac{4h^2}{2})u''(x_0) + \\dots$$\n为使该表达式成为 $u'(x_0)$ 的二阶近似，我们需要满足：\n1.  $u(x_0)$ 的系数为 $0$：$a+b+c=0$\n2.  $u'(x_0)$ 的系数为 $1$：$bh + 2ch=1$\n3.  $u''(x_0)$ 的系数为 $0$：$\\frac{b h^2}{2} + 2 c h^2=0$\n\n从 (3) 式，我们得到 $b/2 + 2c = 0 \\implies b = -4c$。将其代入 (2) 式，得到 $(-4c)h + 2ch = 1 \\implies -2ch=1 \\implies c = -1/(2h)$。因此，$b = 2/h$。最后，从 (1) 式，$a = -b-c = -2/h + 1/(2h) = -3/(2h)$。得到的二阶向前差分公式为：\n$$u'_h(x_0) = \\frac{-3u(x_0) + 4u(x_1) - u(x_2)}{2h}$$\n\n**右边界 ($i=N-1$)：** 使用点 $x_{N-1}$、$x_{N-2}$ 和 $x_{N-3}$ 的类似过程可以得到二阶向后差分公式。通过对称性，我们可以推断出系数，或者求解相应的方程组。该公式为：\n$$u'_h(x_{N-1}) = \\frac{3u(x_{N-1}) - 4u(x_{N-2}) + u(x_{N-3})}{2h}$$\n\n### 2. 误差分析与精度阶\n\n问题指定了离散 $L^2$ 误差范数来量化数值导数 $u'_h(x_i)$ 与精确导数 $u'(x_i)$ 之间的差异：\n$$E(h) = \\left( h \\sum_{i=0}^{N-1} \\left( u'_h(x_i) - u'(x_i) \\right)^2 \\right)^{1/2}$$\n对于一个精度阶为 $p$ 的离散化方法，当 $h$ 足够小（即在渐近收敛区域）时，误差预计表现为 $E(h) \\approx C h^p$，其中 $C$ 是一个常数。为了凭经验确定 $p$，我们可以对这个关系式取对数：\n$$\\log E(h) \\approx \\log C + p \\log h$$\n这表明 $\\log E(h)$ 和 $\\log h$ 之间存在线性关系，其斜率即为精度阶 $p$。给定在一系列网格间距为 $(h_j)$ 的网格上的误差测量值 $(E_j)$，我们可以通过对数据点 $(\\log h_j, \\log E_j)$ 进行线性最小二乘拟合来求得 $p$。\n\n### 3. 测试用例与陷阱讨论\n\n所选的测试用例旨在突出收敛性研究中的重要实践方面。\n\n**测试用例 A：$u(x) = \\sin(2\\pi x)$，网格 $N \\in \\{50, 100, 200\\}$**\n这是一个“理想情况”的用例。函数光滑且周期性，其导数性质良好。网格足够精细，可以解析在定义域 $[0,1]$ 上的单波长变化。我们预计误差将处于渐近区域，估算出的阶数 $p_A$ 应非常接近理论值 $2$。\n\n**测试用例 B：$u(x) = \\sin(12\\pi x)$，网格 $N \\in \\{12, 24, 48\\}$**\n这个用例探究了非渐近区域。该函数频率较高（在 $[0,1]$ 内有6个完整波长）。最粗的网格 $N=12$ 对应的间距为 $h=1/11$。波长为 $\\lambda = 2\\pi/(12\\pi) = 1/6$。每个波长内的点数为 $\\lambda/h \\approx (1/6)/(1/11) \\approx 1.83$，这远低于奈奎斯特-香农采样定理的要求，不足以精确近似导数。在如此粗糙的网格上，截断误差展开中的高阶项（例如 $O(h^4)$）与主导项 $O(h^2)$ 相比是不可忽略的。因此，假设 $E(h) \\approx C h^p$ 在这个网格范围内不成立。对数-对数图的斜率会失真，预计估算出的阶数 $p_B$ 会显著低于 $2$。\n\n**测试用例 C：$u(x) = \\tanh(x/\\delta)$，其中 $\\delta = 10^{-2}$，网格 $N \\in \\{100, 200, 400\\}$**\n这个用例说明了边界层的影响。该函数在 $x=0$ 附近有一个变化非常迅速的区域（一个“层”），其特征厚度为 $\\delta=0.01$。我们格式的截断误差取决于高阶导数，例如 $u'''(x)$。对于这个函数，这些导数在层内可能非常大，其量级与 $1/\\delta^3$ 成比例。这使得误差关系 $E(h) \\approx C h^p$ 中的常数 $C$ 变得极大。全局误差 $E(h)$ 将由这个未被充分解析的层内部的巨大局部误差所主导。网格间距分别为 $h \\approx 1/99, 1/199, 1/399$，对应 $h/\\delta \\approx 1, 0.5, 0.25$。只有最精细的网格才开始在层内布置几个点。由于研究中的所有网格都未能充分解析该层，观测到的收敛可能不会遵循理论速率。我们可能预期 $p_C$ 会偏离理想值 $2$。只有当 $h \\ll \\delta$ 时，收敛才会接近理论速率，这比光滑正弦函数的情况要求苛刻得多。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef compute_second_order_derivative(u_vals, h):\n    \"\"\"\n    Computes the first derivative using second-order accurate finite differences.\n    - Central difference for interior points.\n    - One-sided differences for boundary points.\n    \n    Args:\n        u_vals (np.ndarray): Array of function values on the grid.\n        h (float): The uniform grid spacing.\n\n    Returns:\n        np.ndarray: The numerical approximation of the first derivative.\n    \"\"\"\n    N = len(u_vals)\n    du_dx = np.zeros(N, dtype=float)\n\n    if N  3:\n        raise ValueError(\"Grid must have at least 3 points for second-order boundaries.\")\n\n    # Second-order forward difference at the left boundary (i=0)\n    du_dx[0] = (-3.0 * u_vals[0] + 4.0 * u_vals[1] - u_vals[2]) / (2.0 * h)\n\n    # Second-order central difference for interior points (i=1 to N-2)\n    du_dx[1:-1] = (u_vals[2:] - u_vals[:-2]) / (2.0 * h)\n\n    # Second-order backward difference at the right boundary (i=N-1)\n    du_dx[-1] = (3.0 * u_vals[-1] - 4.0 * u_vals[-2] + u_vals[-3]) / (2.0 * h)\n\n    return du_dx\n\ndef compute_l2_error(u_numeric, u_exact, h):\n    \"\"\"\n    Computes the discrete L2 error norm.\n\n    Args:\n        u_numeric (np.ndarray): Array of numerical values.\n        u_exact (np.ndarray): Array of exact values.\n        h (float): The uniform grid spacing.\n\n    Returns:\n        float: The discrete L2 error.\n    \"\"\"\n    error_sq_sum = np.sum((u_numeric - u_exact)**2)\n    l2_error = np.sqrt(h * error_sq_sum)\n    return l2_error\n\ndef estimate_order_of_accuracy(h_values, E_values):\n    \"\"\"\n    Estimates the order of accuracy p from E(h) vs h data.\n    This is done by a least-squares fit of log(E) vs log(h).\n\n    Args:\n        h_values (list or np.ndarray): List of grid spacings.\n        E_values (list or np.ndarray): List of corresponding L2 errors.\n\n    Returns:\n        float: The estimated order of accuracy, p.\n    \"\"\"\n    log_h = np.log(h_values)\n    log_E = np.log(E_values)\n\n    # Fit a line (polynomial of degree 1) to the log-log data.\n    # The slope of this line is the order of accuracy.\n    p, _ = np.polyfit(log_h, log_E, 1)\n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and compute the empirical orders of accuracy.\n    \"\"\"\n    \n    # Test Case A: Smooth function, well-resolved\n    case_A = {\n        \"u\": lambda x: np.sin(2 * np.pi * x),\n        \"du_dx\": lambda x: 2 * np.pi * np.cos(2 * np.pi * x),\n        \"N_values\": [50, 100, 200]\n    }\n\n    # Test Case B: Higher frequency, coarse resolution\n    case_B = {\n        \"u\": lambda x: np.sin(12 * np.pi * x),\n        \"du_dx\": lambda x: 12 * np.pi * np.cos(12 * np.pi * x),\n        \"N_values\": [12, 24, 48]\n    }\n    \n    # Test Case C: Boundary layer\n    delta_C = 1e-2\n    case_C = {\n        \"u\": lambda x: np.tanh(x / delta_C),\n        \"du_dx\": lambda x: (1.0 / delta_C) * (1.0 / np.cosh(x / delta_C))**2,\n        \"N_values\": [100, 200, 400]\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    results = []\n\n    for case in test_cases:\n        h_values = []\n        E_values = []\n        \n        u_func = case[\"u\"]\n        du_dx_func = case[\"du_dx\"]\n        N_values = case[\"N_values\"]\n\n        for N in N_values:\n            h = 1.0 / (N - 1)\n            x_grid = np.linspace(0.0, 1.0, N)\n            \n            u_on_grid = u_func(x_grid)\n            du_dx_numeric = compute_second_order_derivative(u_on_grid, h)\n            du_dx_exact = du_dx_func(x_grid)\n            \n            error = compute_l2_error(du_dx_numeric, du_dx_exact, h)\n            \n            h_values.append(h)\n            E_values.append(error)\n            \n        p_estimated = estimate_order_of_accuracy(h_values, E_values)\n        results.append(p_estimated)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}