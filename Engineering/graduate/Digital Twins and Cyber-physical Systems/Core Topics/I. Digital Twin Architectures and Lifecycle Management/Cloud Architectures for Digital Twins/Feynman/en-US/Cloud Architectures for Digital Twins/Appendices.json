{
    "hands_on_practices": [
        {
            "introduction": "A primary concern in architecting any cloud-based system, especially a digital twin responsible for monitoring or controlling critical physical assets, is its availability. This exercise provides hands-on practice in quantitatively assessing system reliability. By modeling the digital twin as a pipeline of sequential services, you will calculate the end-to-end availability and then evaluate the substantial improvement gained by introducing active-active redundancy, a common architectural pattern for enhancing fault tolerance .",
            "id": "4208208",
            "problem": "A cloud-hosted digital twin pipeline for a cyber-physical system consists of three sequential services: an ingestion gateway, a stream processing engine, and a visualization and alerting front-end. The twin is considered available if and only if all three services are simultaneously up. Assume the following:\n\n- The steady-state availability of the ingestion gateway is $0.999$, of the stream processor is $0.9995$, and of the visualization front-end is $0.9999$. Steady-state availability is defined as the long-run fraction of time a service is operational, which equals the stationary probability that the service is in its up state under an alternating renewal process model.\n- Service up/down states across services are statistically independent due to disjoint failure domains, and the twin requires the entire sequential path to be operational to serve requests.\n- An architectural change introduces active-active redundancy for the ingestion gateway by deploying two identical, independent instances, each with steady-state availability $0.999$. The twin remains available with respect to the ingestion stage as long as at least one of these two instances is up. Assume negligible switchover and no correlated failure between the two instances.\n\nStarting from the above foundational definitions and assumptions of availability as steady-state up probability and independence of events, compute the original end-to-end availability of the pipeline, compute the new end-to-end availability after introducing active-active redundancy for the ingestion gateway, and then report the improvement factor defined as the ratio of the new end-to-end availability to the original end-to-end availability. Express the final answer as a unitless decimal and round your final answer to six significant figures. Do not use a percentage sign anywhere.",
            "solution": "The problem requires the calculation of an improvement factor in system availability due to an architectural change. We begin by formalizing the system's availability based on the provided definitions.\n\nLet $A_1$, $A_2$, and $A_3$ represent the steady-state availabilities of the ingestion gateway, the stream processing engine, and the visualization front-end, respectively. According to the problem statement, these are given as:\n$A_1 = 0.999$\n$A_2 = 0.9995$\n$A_3 = 0.9999$\n\nThe availability of a component is the probability that it is operational. Let $U_i$ be the event that service $i$ is in its 'up' state. Then, $P(U_i) = A_i$.\n\nFirst, we compute the original end-to-end availability of the pipeline, denoted as $A_{orig}$. The problem states that the pipeline is a sequential system, meaning it is available if and only if all three services are simultaneously operational. The services are also stated to be statistically independent. Therefore, the probability of the entire system being up is the product of the individual service availabilities:\n$$A_{orig} = P(U_1 \\cap U_2 \\cap U_3) = P(U_1) \\times P(U_2) \\times P(U_3)$$\n$$A_{orig} = A_1 \\times A_2 \\times A_3$$\nSubstituting the given values:\n$$A_{orig} = 0.999 \\times 0.9995 \\times 0.9999$$\n\nNext, we consider the architectural change where the ingestion gateway is replaced by two identical, independent instances in an active-active redundant configuration. Let the availability of each gateway instance be $A_{1,inst}$. From the problem, $A_{1,inst} = 0.999$, which is the same as the original $A_1$. The new ingestion stage is available as long as at least one of the two instances is up.\n\nIt is more convenient to calculate the unavailability of this redundant stage. The unavailability of a single instance is $1 - A_{1,inst}$. Since the two instances are independent, the probability that both are simultaneously down (unavailable) is the product of their individual unavailabilities.\n$$P(\\text{ingestion stage is down}) = (1 - A_{1,inst}) \\times (1 - A_{1,inst}) = (1 - A_{1,inst})^2$$\nThe availability of the new ingestion stage, which we denote as $A'_{1}$, is $1$ minus the probability that the stage is down:\n$$A'_{1} = 1 - (1 - A_{1,inst})^2$$\nSubstituting $A_{1,inst} = A_1 = 0.999$:\n$$A'_{1} = 1 - (1 - 0.999)^2 = 1 - (0.001)^2 = 1 - 0.000001 = 0.999999$$\n\nThe new end-to-end availability of the pipeline, $A_{new}$, is then the product of the availabilities of the new ingestion stage, the stream processor, and the front-end. The latter two components remain unchanged.\n$$A_{new} = A'_{1} \\times A_2 \\times A_3$$\n$$A_{new} = (1 - (1 - A_1)^2) \\times A_2 \\times A_3$$\n\nFinally, we need to compute the improvement factor, $F$, which is defined as the ratio of the new end-to-end availability to the original end-to-end availability.\n$$F = \\frac{A_{new}}{A_{orig}}$$\nSubstituting the expressions for $A_{new}$ and $A_{orig}$:\n$$F = \\frac{(1 - (1 - A_1)^2) \\times A_2 \\times A_3}{A_1 \\times A_2 \\times A_3}$$\nThe terms $A_2$ and $A_3$ cancel out, simplifying the expression for the improvement factor significantly:\n$$F = \\frac{1 - (1 - A_1)^2}{A_1}$$\nThis shows that the improvement factor only depends on the availability of the component that was made redundant.\n\nNow, we substitute the numerical value for $A_1$:\n$$F = \\frac{1 - (1 - 0.999)^2}{0.999} = \\frac{1 - (0.001)^2}{0.999} = \\frac{1 - 0.000001}{0.999} = \\frac{0.999999}{0.999}$$\nPerforming the division:\n$$F = 1.001000001001...$$\nThe problem requires the final answer to be rounded to six significant figures. The first six significant figures are $1$, $0$, $0$, $1$, $0$, and $0$. The seventh significant figure is $0$, which is less than $5$, so we round down (i.e., keep the sixth digit as it is).\n$$F \\approx 1.00100$$",
            "answer": "$$\\boxed{1.00100}$$"
        },
        {
            "introduction": "Beyond just being available, a digital twin must maintain a consistent and trustworthy state, especially when its data is replicated across multiple locations for resilience and low latency. This practice delves into the core principles of quorum-based protocols, which provide formal guarantees for data consistency in distributed storage systems. You will use set-theoretic reasoning to derive the famous quorum intersection conditions, such as $R+W \\gt N$, and apply them to design a fault-tolerant configuration that balances read latency against consistency guarantees .",
            "id": "4208249",
            "problem": "A cloud-hosted digital twin orchestrator for cyber-physical assets replicates its command log across $N$ identical storage replicas using a quorum protocol. A write operation commits after acknowledgments from any $W$ distinct replicas, and a read operation returns the value with the highest version after collecting responses from any $R$ distinct replicas. Each operation selects its contacted replicas arbitrarily from the $N$ replicas. The orchestrator must ensure that the command log provides read-after-write visibility and prevents divergent committed writes for actuations on physical systems. Reads are prioritized for low latency; in this model, lowering $R$ reduces read completion time because a read finishes when the $R$-th fastest contacted replica responds.\n\nStarting only from set-theoretic reasoning about intersections of subsets of a finite set and from the operational definitions above, derive necessary and sufficient conditions on $(R,W,N)$ that ensure both of the following properties hold for all executions:\n- Strong write consistency: any two completed writes must have at least one common replica that acknowledged both writes, and\n- Read-after-write consistency: any completed read invoked after a completed write must intersect the replica set that acknowledged that write, so that the read can return its value.\n\nAdditionally, the orchestrator must remain able to complete both reads and writes in the presence of up to $f=1$ replica failure, meaning it must be possible to form both a read quorum and a write quorum out of the surviving replicas when at most one replica is unavailable.\n\nFor the concrete case $N=5$ and $f=1$, determine the minimal integer value of $R$ that satisfies all derived conditions while minimizing read latency. Provide a brief justification that your chosen $R$ is feasible by exhibiting a compatible $W$. Report only the minimal $R$ as your final answer. No rounding is required. Express the answer as an integer.",
            "solution": "The problem requires deriving necessary and sufficient conditions on the read quorum size $R$, the write quorum size $W$, and the total number of replicas $N$ to ensure two types of consistency and one fault-tolerance property. These conditions are then to be applied to a specific case to find a minimal value for $R$.\n\nLet $S$ be the set of all replicas, with $|S| = N$. A write operation is acknowledged by a subset of replicas $Q_W \\subseteq S$ where $|Q_W| = W$. A read operation collects responses from a subset of replicas $Q_R \\subseteq S$ where $|Q_R| = R$.\n\nFirst, we formalize the three required properties using set-theoretic reasoning.\n\n1.  **Strong write consistency:** This property states that any two completed writes must have at least one common replica. Let $Q_{W1}$ and $Q_{W2}$ be the sets of replicas that acknowledged two arbitrary completed writes. The condition is $Q_{W1} \\cap Q_{W2} \\neq \\emptyset$. To guarantee this for any choice of $Q_{W1}$ and $Q_{W2}$, we consider the worst-case scenario where the intersection is minimal. Using the principle of inclusion-exclusion for the union of these two sets:\n    $$|Q_{W1} \\cup Q_{W2}| = |Q_{W1}| + |Q_{W2}| - |Q_{W1} \\cap Q_{W2}|$$\n    Since the union is a subset of the total set of replicas $S$, its size cannot exceed $N$:\n    $$|Q_{W1} \\cup Q_{W2}| \\le N$$\n    Substituting the known sizes, $|Q_{W1}| = W$ and $|Q_{W2}| = W$:\n    $$N \\ge W + W - |Q_{W1} \\cap Q_{W2}|$$\n    Rearranging for the size of the intersection, we get:\n    $$|Q_{W1} \\cap Q_{W2}| \\ge 2W - N$$\n    To guarantee that the intersection is non-empty, its minimum possible size must be at least $1$.\n    $$2W - N \\ge 1 \\implies 2W > N$$\n    This is the necessary and sufficient condition for strong write consistency.\n\n2.  **Read-after-write consistency:** This property requires that any completed read intersects the replica set of any previously completed write. Let $Q_W$ be the replica set for a completed write and $Q_R$ be the replica set for a subsequent read. The condition is $Q_R \\cap Q_W \\neq \\emptyset$. The reasoning is analogous to the strong write consistency case:\n    $$|Q_R \\cup Q_W| = |Q_R| + |Q_W| - |Q_R \\cap Q_W| \\le N$$\n    Substituting $|Q_R| = R$ and $|Q_W| = W$:\n    $$N \\ge R + W - |Q_R \\cap Q_W|$$\n    $$|Q_R \\cap Q_W| \\ge R + W - N$$\n    To guarantee a non-empty intersection, we require:\n    $$R + W - N \\ge 1 \\implies R + W > N$$\n    This is the necessary and sufficient condition for read-after-write consistency.\n\n3.  **Fault tolerance:** The system must be able to complete both read and write operations in the presence of up to $f$ failures. With $f$ failures, the number of available replicas is $N-f$. To be able to form a write quorum, the number of available replicas must be at least $W$. Similarly, to form a read quorum, the number of available replicas must be at least $R$. This gives us two conditions:\n    $$W \\le N - f$$\n    $$R \\le N - f$$\n\nWe are given the concrete case where $N=5$ and $f=1$. The goal is to find the minimal integer value of $R$. We substitute these values into the derived inequalities:\n(i) $2W > 5$\n(ii) $R + W > 5$\n(iii) $W \\le 5 - 1 \\implies W \\le 4$\n(iv) $R \\le 5 - 1 \\implies R \\le 4$\n\nFrom inequality (i), since $W$ must be an integer, we have $W \\ge 3$.\nCombining this with inequality (iii), we find the possible integer values for $W$:\n$$3 \\le W \\le 4$$\nSo, $W$ can be either $3$ or $4$.\n\nThe problem states that read latency is minimized by lowering $R$. We seek the minimal integer $R$ that satisfies all conditions for some valid choice of $W$. We analyze the two possible cases for $W$.\n\nCase 1: $W=3$.\nWe substitute $W=3$ into inequality (ii):\n$$R + 3 > 5 \\implies R > 2$$\nSince $R$ is an integer, this means $R \\ge 3$. Inequality (iv) requires $R \\le 4$. Thus, for $W=3$, the possible values for $R$ are $3$ and $4$. The minimum value for $R$ in this case is $3$. The pair $(R=3, W=3)$ is a valid configuration.\n\nCase 2: $W=4$.\nWe substitute $W=4$ into inequality (ii):\n$$R + 4 > 5 \\implies R > 1$$\nSince $R$ is an integer, this means $R \\ge 2$. Inequality (iv) requires $R \\le 4$. Thus, for $W=4$, the possible values for $R$ are $2$, $3$, and $4$. The minimum value for $R$ in this case is $2$. The pair $(R=2, W=4)$ is a valid configuration.\n\nTo find the overall minimal integer value of $R$, we compare the minimums from both valid cases. The minimum of $\\{3, 2\\}$ is $2$.\nTherefore, the minimal integer value of $R$ that satisfies all conditions is $2$. This is feasible because it can be achieved with a compatible write quorum size, for example, $W=4$. Let's verify the pair $(R=2, W=4)$ with $N=5$ and $f=1$:\n(i) $2(4) > 5 \\implies 8 > 5$. (Satisfied)\n(ii) $2 + 4 > 5 \\implies 6 > 5$. (Satisfied)\n(iii) $4 \\le 5 - 1 \\implies 4 \\le 4$. (Satisfied)\n(iv) $2 \\le 5 - 1 \\implies 2 \\le 4$. (Satisfied)\nAll conditions hold. We must also check that $R=1$ is not possible. If $R=1$, inequality (ii) gives $1+W>5 \\implies W>4$. However, inequality (iii) requires $W \\le 4$. These conditions are contradictory, so $R=1$ is not a feasible solution.\n\nThe minimal integer value of $R$ is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Effective cloud architecture for digital twins often involves navigating a complex web of trade-offs between performance, cost, and resource limitations. This final practice challenges you to synthesize these considerations into a formal optimization problem, deciding where to place computational components in a hybrid edge-cloud environment. By modeling system performance with queuing theory and network latency formulas, you will find the optimal placement strategy that minimizes operational cost while satisfying strict end-to-end latency and resource constraints .",
            "id": "4208217",
            "problem": "You are tasked with designing a placement optimization for components of a Digital Twin (DT) pipeline deployed in a Cyber-Physical System (CPS) using a hybrid Edge–Cloud architecture. Each pipeline is a linear chain of $n$ components that process a stream at an exogenous arrival rate $\\lambda$ (tasks per second). For each component $i \\in \\{1,\\dots,n\\}$, you must decide its placement $x_i \\in \\{0,1\\}$, where $x_i = 0$ denotes placement on the edge and $x_i = 1$ denotes placement on the cloud. The objective is to minimize the total cloud cost \n$$\nC(x) = \\sum_{i=1}^{n} c_i x_i,\n$$\nsubject to end-to-end latency and edge memory constraints.\n\nScientific and engineering bases:\n- For each component $i$, when placed on platform $p \\in \\{\\mathrm{edge},\\mathrm{cloud}\\}$ with service rate $\\mu_{i,p}$ (tasks per second), and for stream arrival rate $\\lambda$ with $\\lambda  \\mu_{i,p}$, the expected response time in a stable $\\mathrm{M/M/1}$ queue is \n$$\nW_{i,p} = \\frac{1}{\\mu_{i,p} - \\lambda} \\quad \\text{seconds}.\n$$\n- The end-to-end latency across the pipeline equals the sum of component response times plus any network transmission latencies induced when data crosses the edge–cloud boundary between adjacent components. For a crossing between component $j$ and $j+1$, with data size $s_j$ in megabytes, one-way propagation delay $p$ in milliseconds, and available bandwidth $B$ in megabytes per second, the crossing latency is \n$$\nL^{\\mathrm{net}}_{j} = p + \\frac{s_j}{B} \\cdot 1000 \\quad \\text{milliseconds}.\n$$\n- The total end-to-end latency (in milliseconds) is\n$$\nL_{\\mathrm{e2e}}(x) = \\left( \\sum_{i=1}^{n} 1000 \\cdot W_{i,p(i)} \\right) + \\left( \\sum_{j=1}^{n-1} \\mathbf{1}\\{x_j \\neq x_{j+1}\\} \\cdot L^{\\mathrm{net}}_{j} \\right),\n$$\nwhere $p(i) = \\mathrm{edge}$ if $x_i = 0$ and $p(i) = \\mathrm{cloud}$ if $x_i = 1$, and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n- The edge memory constraint requires \n$$\n\\sum_{i=1}^{n} m_i \\cdot \\mathbf{1}\\{x_i = 0\\} \\leq M_{\\mathrm{edge,max}},\n$$\nwhere $m_i$ is the memory footprint of component $i$ in gigabytes and $M_{\\mathrm{edge,max}}$ is the edge memory capacity.\n\nOptimization constraints:\n- End-to-end latency constraint: $L_{\\mathrm{e2e}}(x) \\leq L_{\\max}$ with $L_{\\max} = 30\\,\\mathrm{ms}$.\n- Edge memory constraint: $\\sum_{i=1}^{n} m_i \\cdot \\mathbf{1}\\{x_i = 0\\} \\leq 2\\,\\mathrm{GB}$.\n- Stability constraints: For every component $i$, if $x_i = 0$ then $\\lambda  \\mu_{i,\\mathrm{edge}}$, and if $x_i = 1$ then $\\lambda  \\mu_{i,\\mathrm{cloud}}$; otherwise the assignment is infeasible.\n\nYour program must, for each test case, perform an exhaustive search over all $2^n$ binary assignments $x = (x_1,\\dots,x_n)$, compute feasibility under the constraints, and return the minimum cloud cost $C(x)$ and a corresponding assignment achieving that minimum. If no feasible assignment exists, return $-1$ and an empty list.\n\nAll answers involving time must be computed and checked in milliseconds, and memory in gigabytes. Angles are not involved. Costs are unitless scalars.\n\nTest suite:\n- Case A (general trade-off):\n  - $n = 4$,\n  - $\\lambda = 150$,\n  - $\\mu_{\\mathrm{edge}} = [400,\\,330,\\,500,\\,380]$,\n  - $\\mu_{\\mathrm{cloud}} = [800,\\,700,\\,900,\\,750]$,\n  - $m = [0.6,\\,0.4,\\,0.8,\\,0.7]$,\n  - $c = [3.0,\\,1.5,\\,4.0,\\,2.5]$,\n  - $s = [1.5,\\,2.0,\\,1.0]$,\n  - $B = 500$,\n  - $p = 2$,\n  - $M_{\\mathrm{edge,max}} = 2.0$,\n  - $L_{\\max} = 30$.\n- Case B (boundary feasible at the edge):\n  - $n = 3$,\n  - $\\lambda = 120$,\n  - $\\mu_{\\mathrm{edge}} = [350,\\,360,\\,340]$,\n  - $\\mu_{\\mathrm{cloud}} = [700,\\,720,\\,680]$,\n  - $m = [0.8,\\,0.6,\\,0.6]$,\n  - $c = [2.0,\\,3.0,\\,5.0]$,\n  - $s = [1.0,\\,1.0]$,\n  - $B = 800$,\n  - $p = 2$,\n  - $M_{\\mathrm{edge,max}} = 2.0$,\n  - $L_{\\max} = 30$.\n- Case C (infeasible due to instability):\n  - $n = 4$,\n  - $\\lambda = 200$,\n  - $\\mu_{\\mathrm{edge}} = [180,\\,210,\\,190,\\,205]$,\n  - $\\mu_{\\mathrm{cloud}} = [190,\\,220,\\,195,\\,215]$,\n  - $m = [0.6,\\,0.5,\\,0.4,\\,0.4]$,\n  - $c = [1.0,\\,1.0,\\,1.0,\\,1.0]$,\n  - $s = [2.0,\\,2.0,\\,2.0]$,\n  - $B = 400$,\n  - $p = 5$,\n  - $M_{\\mathrm{edge,max}} = 2.0$,\n  - $L_{\\max} = 30$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of the form $[C^\\star, x^\\star]$ with $C^\\star$ the minimum cost (a float, or $-1$ if infeasible) and $x^\\star$ the corresponding assignment as a list of integers ($0$ for edge, $1$ for cloud). For example: $[[2.5,[0,0,0,1]],[0.0,[0,0,0]],[-1,[]]]$.",
            "solution": "The problem is a combinatorial optimization task to find a placement vector $x = (x_1, \\dots, x_n)$ that minimizes the cloud cost function $C(x)$ while satisfying all constraints. Since the number of components $n$ is small in the test cases, an exhaustive search over all $2^n$ possible placements is computationally feasible and guarantees finding the global optimum.\n\nThe algorithm proceeds as follows for each test case:\n1.  Initialize a minimum cost, $C_{min}$, to infinity and the corresponding best assignment, $x^\\star$, to an empty list.\n2.  Iterate through every possible placement vector $x = (x_1, \\dots, x_n)$, where each $x_i \\in \\{0, 1\\}$. This can be done by iterating an integer from $0$ to $2^n-1$ and using its $n$-bit binary representation for $x$.\n3.  For each candidate vector $x$, check its feasibility by evaluating all constraints in sequence:\n    a.  **Stability Constraint**: For each component $i$, check if the arrival rate $\\lambda$ is strictly less than the service rate of the chosen platform. If $x_i=0$, the condition is $\\lambda  \\mu_{i,\\mathrm{edge}}$; if $x_i=1$, it is $\\lambda  \\mu_{i,\\mathrm{cloud}}$. If this is violated for any component, the assignment is infeasible.\n    b.  **Edge Memory Constraint**: Calculate the total memory consumed by components placed on the edge: $M_{\\mathrm{used}} = \\sum_{i=1}^{n} m_i \\cdot \\mathbf{1}\\{x_i = 0\\}$. Check if $M_{\\mathrm{used}} \\leq M_{\\mathrm{edge,max}}$. If not, the assignment is infeasible.\n    c.  **End-to-End Latency Constraint**: Calculate the total latency $L_{\\mathrm{e2e}}(x)$. This is the sum of two parts:\n        i.  The total processing latency: $L_{\\mathrm{proc}} = \\sum_{i=1}^{n} 1000 \\cdot (\\mu_{i,p(i)} - \\lambda)^{-1}$, where $p(i)$ is the platform for component $i$.\n        ii. The total network latency, which is the sum of crossing latencies for each pair of adjacent components $(j, j+1)$ placed on different platforms: $L_{\\mathrm{net}} = \\sum_{j=1}^{n-1} \\mathbf{1}\\{x_j \\neq x_{j+1}\\} \\cdot (p + \\frac{s_j}{B} \\cdot 1000)$.\n        The total end-to-end latency is $L_{\\mathrm{e2e}}(x) = L_{\\mathrm{proc}} + L_{\\mathrm{net}}$. If $L_{\\mathrm{e2e}}(x) > L_{\\max}$, the assignment is infeasible.\n4.  If an assignment $x$ passes all three feasibility checks, calculate its cost: $C(x) = \\sum_{i=1}^{n} c_i x_i$.\n5.  If $C(x)  C_{min}$, update $C_{min} = C(x)$ and $x^{\\star} = x$.\n6.  After checking all $2^n$ assignments, if $C_{min}$ is still infinity, no feasible solution exists. The result is $[-1, []]$. Otherwise, the result is $[C_{min}, x^\\star]$.",
            "answer": "```python\nimport math\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the component placement optimization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (general trade-off)\n        {\n            \"n\": 4, \"lambda\": 150, \"mu_edge\": [400, 330, 500, 380],\n            \"mu_cloud\": [800, 700, 900, 750], \"m\": [0.6, 0.4, 0.8, 0.7],\n            \"c\": [3.0, 1.5, 4.0, 2.5], \"s\": [1.5, 2.0, 1.0], \"B\": 500, \"p\": 2,\n            \"M_edge_max\": 2.0, \"L_max\": 30\n        },\n        # Case B (boundary feasible at the edge)\n        {\n            \"n\": 3, \"lambda\": 120, \"mu_edge\": [350, 360, 340],\n            \"mu_cloud\": [700, 720, 680], \"m\": [0.8, 0.6, 0.6],\n            \"c\": [2.0, 3.0, 5.0], \"s\": [1.0, 1.0], \"B\": 800, \"p\": 2,\n            \"M_edge_max\": 2.0, \"L_max\": 30\n        },\n        # Case C (infeasible due to instability)\n        {\n            \"n\": 4, \"lambda\": 200, \"mu_edge\": [180, 210, 190, 205],\n            \"mu_cloud\": [190, 220, 195, 215], \"m\": [0.6, 0.5, 0.4, 0.4],\n            \"c\": [1.0, 1.0, 1.0, 1.0], \"s\": [2.0, 2.0, 2.0], \"B\": 400, \"p\": 5,\n            \"M_edge_max\": 2.0, \"L_max\": 30\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        n = params[\"n\"]\n        lam = params[\"lambda\"]\n        mu_edge = params[\"mu_edge\"]\n        mu_cloud = params[\"mu_cloud\"]\n        m = params[\"m\"]\n        c = params[\"c\"]\n        s = params[\"s\"]\n        B = params[\"B\"]\n        p = params[\"p\"]\n        M_edge_max = params[\"M_edge_max\"]\n        L_max = params[\"L_max\"]\n\n        min_cost = float('inf')\n        best_assignment = []\n\n        # Exhaustive search over all 2^n assignments\n        for i in range(2**n):\n            # Generate the binary assignment vector x\n            x = [int(digit) for digit in bin(i)[2:].zfill(n)]\n            \n            is_feasible = True\n\n            # 1. Check stability constraint\n            for j in range(n):\n                if x[j] == 0:  # Edge placement\n                    if not (lam  mu_edge[j]):\n                        is_feasible = False\n                        break\n                else:  # Cloud placement\n                    if not (lam  mu_cloud[j]):\n                        is_feasible = False\n                        break\n            if not is_feasible:\n                continue\n\n            # 2. Check edge memory constraint\n            edge_memory_usage = sum(m[j] for j in range(n) if x[j] == 0)\n            if edge_memory_usage > M_edge_max:\n                is_feasible = False\n                continue\n\n            # 3. Check end-to-end latency constraint\n            # Processing latency\n            proc_latency_ms = 0\n            for j in range(n):\n                if x[j] == 0:\n                    response_time_s = 1 / (mu_edge[j] - lam)\n                else:\n                    response_time_s = 1 / (mu_cloud[j] - lam)\n                proc_latency_ms += 1000 * response_time_s\n\n            # Network latency\n            net_latency_ms = 0\n            for j in range(n - 1):\n                if x[j] != x[j+1]:\n                    # Transmission time in ms\n                    transmission_ms = (s[j] / B) * 1000\n                    net_latency_ms += p + transmission_ms\n            \n            total_latency = proc_latency_ms + net_latency_ms\n            if total_latency > L_max:\n                is_feasible = False\n                continue\n\n            # If all checks pass, the assignment is feasible\n            current_cost = sum(c[j] for j in range(n) if x[j] == 1)\n\n            if current_cost  min_cost:\n                min_cost = current_cost\n                best_assignment = x\n\n        if min_cost == float('inf'):\n            all_results.append([-1, []])\n        else:\n            all_results.append([min_cost, best_assignment])\n\n    # Format the final output string exactly as requested\n    results_str = []\n    for res in all_results:\n        cost, assign = res\n        # Format a single result entry, e.g., \"[2.5,[0,0,0,1]]\"\n        entry_str = f\"[{float(cost)},{assign}]\"\n        results_str.append(entry_str)\n    \n    # Join all entries and enclose in brackets, e.g., \"[[...],[...],[...]]\"\n    final_output = f\"[{','.join(results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}