{
    "hands_on_practices": [
        {
            "introduction": "在设计数字孪生系统时，一个首要的实际问题是确保网络基础设施能够处理物理资产产生的海量数据。本练习将引导你通过第一性原理，计算在边缘计算进行数据压缩的情况下，单个资产所能支持的最大原始遥测速率，这项实践是进行系统规模规划和确保数据链路可行性的基本技能。",
            "id": "4214308",
            "problem": "一个信息物理生产线由一个托管在云端的数字孪生进行镜像。在数字孪生生命周期的运行和维护阶段，每个物理资产将遥测数据流式传输到边缘端，边缘端对数据进行预处理和压缩，然后将其转发到云端。考虑一个部署了 $N=100$ 个相同资产的场景。每个资产以每秒 $r$ 千比特的恒定速率发出原始遥测流。边缘端执行无损压缩，压缩比为 $4:1$，这意味着压缩后的比特率等于未压缩比特率除以 $4$。从边缘到云的上行链路具有 $B_{\\uparrow}=5\\,\\mathrm{Mbps}$ 的固定瓶颈容量，专门用于传输压缩后的遥测数据；而从云到边缘的下行链路容量为 $B_{\\downarrow}=10\\,\\mathrm{Mbps}$，用于控制和模型更新，在本场景中，这部分对于容量预算而言可以忽略不计。假设长期流量守恒，无协议开销，并且所有资产都被公平调度，因此在稳态下每个资产的速率相等。\n\n从第一性原理（信息速率在压缩层和链路层之间的守恒以及压缩比的定义）出发，推导与上行链路约束一致的、每个资产的最大可行原始遥测速率 $r_{\\max}$。然后，根据给定参数对 $r_{\\max}$ 进行数值计算。请以千比特每秒（kbps）为单位表示最终答案。除精确计算外，无需进行四舍五入。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、问题明确、客观，并包含得出唯一解所需的所有信息。推导从第一性原理开始。\n\n设 $N$ 为相同资产的数量，$r$ 为每个资产的原始遥测速率（单位：千比特每秒，kbps），$C$ 为压缩因子。问题陈述有 $N=100$ 个资产。\n\n第一性原理是压缩比的定义。$4:1$ 的压缩比意味着压缩后数据的大小是未压缩数据大小的 $1/4$。对于数据速率而言，这意味着压缩后的比特率是原始比特率的 $1/4$。因此，压缩因子为 $C=4$。单个资产压缩后的遥测速率（记作 $r_c$）由下式给出：\n$$r_c = \\frac{r}{C}$$\n\n第二性原理是数据流的聚合。假设公平调度，所有资产对总数据流的贡献相等。来自所有 $N$ 个资产的总压缩遥测速率（记作 $R_{c, total}$）是各个压缩速率之和：\n$$R_{c, total} = \\sum_{i=1}^{N} r_{c,i} = N \\times r_c$$\n代入 $r_c$ 的表达式：\n$$R_{c, total} = N \\times \\frac{r}{C}$$\n\n第三性原理是容量约束，这是流量守恒原理的一个应用。为了使系统能够在不丢失数据或出现无界排队延迟的情况下运行，发送到云端的总聚合数据速率不得超过上行链路的容量。设 $B_{\\uparrow}$ 为上行链路容量。该约束为：\n$$R_{c, total} \\le B_{\\uparrow}$$\n\n问题要求的是每个资产的最大可行原始遥测速率 $r_{\\max}$。当系统完全利用可用的上行链路容量时，可以达到此最大速率，这对应于不等式变为等式的情况：\n$$N \\times \\frac{r_{\\max}}{C} = B_{\\uparrow}$$\n\n现在，我们可以求解该方程以得到 $r_{\\max}$ 的通用符号表达式：\n$$r_{\\max} = \\frac{B_{\\uparrow} \\times C}{N}$$\n\n接下来，我们使用给定的参数对该表达式进行数值计算。参数如下：\n- 资产数量, $N = 100$。\n- 压缩因子, $C = 4$。\n- 上行链路容量, $B_{\\uparrow} = 5\\,\\mathrm{Mbps}$。\n\n一个关键步骤是确保单位一致。$r_{\\max}$ 的期望单位是千比特每秒（kbps）。上行链路容量 $B_{\\uparrow}$ 以兆比特每秒（Mbps）给出。我们使用换算关系 $1\\,\\mathrm{Mbps} = 1000\\,\\mathrm{kbps}$。\n$$B_{\\uparrow} = 5\\,\\mathrm{Mbps} = 5 \\times 1000\\,\\mathrm{kbps} = 5000\\,\\mathrm{kbps}$$\n\n现在，我们将数值代入推导出的 $r_{\\max}$ 表达式中：\n$$r_{\\max} = \\frac{(5000\\,\\mathrm{kbps}) \\times 4}{100}$$\n$$r_{\\max} = \\frac{20000}{100}\\,\\mathrm{kbps}$$\n$$r_{\\max} = 200\\,\\mathrm{kbps}$$\n\n每个资产的最大可行原始遥测速率是 $200$ kbps。关于下行链路容量 $B_{\\downarrow}=10\\,\\mathrm{Mbps}$ 的信息与本计算无关，因为问题指出其使用对于容量预算而言可以忽略不计。",
            "answer": "$$\\boxed{200}$$"
        },
        {
            "introduction": "数据链路的设计不仅要考虑容量，更要关注其时效性，尤其对于执行控制任务的数字孪生而言，数据的及时性至关重要。本练习引入了服务水平目标（Service Level Objective, SLO）这一关键概念，并运用统计学方法来评估系统的通信延迟是否达标，掌握这种评估能力对于保障网络物理系统闭环控制的安全性与稳定性是必不可少的。",
            "id": "4214327",
            "problem": "一个信息物理生产单元通过双向数据链路将其运行状态暴露给一个高保真数字孪生。在数字孪生生命周期的运行阶段，孪生体中的闭环控制器向物理资产发出控制指令，并接收其确认和传感器帧，端到端往返延迟定义为从指令发出到接收到确认之间的时间。为保证安全监控，系统所有者指定了一个服务等级目标 (SLO)，即往返延迟的 $0.99$-分位数不得超过 $30$ 毫秒。\n\n部署稳定后，一次检测活动产生了延迟样本，其分布可以很好地用一个高斯（正态）随机变量来建模，均值为 $15$ 毫秒，标准差为 $5$ 毫秒，这反映了当前负载下序列化延迟、传播延迟和排队抖动的综合影响。\n\n使用分位数和累积分布函数的基本定义，并假设延迟 $X$ 是服从参数为 $\\mu$ 和 $\\sigma$ 的正态分布，确定 $X$ 的 $0.99$-分位数，并计算 SLO 裕度 $\\Delta = L_{\\mathrm{SLO}} - q_{0.99}$，其中 $L_{\\mathrm{SLO}}$ 是 SLO 阈值，$q_{0.99}$ 是 $0.99$-分位数。将 $\\Delta > 0$ 解释为满足 SLO，$\\Delta  0$ 解释为违反 SLO。\n\n将 $\\Delta$ 的最终值四舍五入到四位有效数字，并以毫秒为单位表示。",
            "solution": "首先对问题进行验证，以确保其在科学上成立、适定且客观。\n\n### 步骤 1：提取已知条件\n-   系统：一个带有数字孪生的信息物理生产单元。\n-   数据链路类型：双向。\n-   数字孪生生命周期阶段：运行阶段。\n-   延迟定义：端到端往返延迟，定义为从指令发出到接收到确认之间的时间。\n-   服务等级目标 (SLO)：往返延迟的 $0.99$-分位数不得超过 $30$ 毫秒。这定义了 SLO 阈值，$L_{\\mathrm{SLO}} = 30$ 毫秒。\n-   延迟分布：延迟，表示为随机变量 $X$，被建模为高斯（正态）分布。\n-   分布参数：均值 $\\mu = 15$ 毫秒，标准差 $\\sigma = 5$ 毫秒。因此，$X \\sim \\mathcal{N}(15, 5^2)$。\n-   目标 1：确定 $X$ 的 $0.99$-分位数，记为 $q_{0.99}$。\n-   目标 2：计算 SLO 裕度 $\\Delta = L_{\\mathrm{SLO}} - q_{0.99}$。\n-   解释：$\\Delta > 0$ 意味着 SLO 得到满足；$\\Delta  0$ 意味着 SLO 被违反。\n-   最终答案要求：将 $\\Delta$ 的最终值四舍五入到四位有效数字，并以毫秒表示。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学上成立**：该问题基于概率论和统计学的标准原理，特别是正态分布的性质和分位数的定义。应用这些概念来建模系统延迟并根据服务等级目标进行评估，是系统工程和计算机科学中的一种标准且有效的实践。\n-   **适定性**：问题定义清晰，提供了所有必要的参数（$\\mu$、$\\sigma$、$L_{\\mathrm{SLO}}$ 和分位数水平 $0.99$）。目标明确，可得出一个唯一、稳定且有意义的解。\n-   **客观性**：问题使用了统计学和工程学中精确、标准的术语，没有任何主观或基于观点的陈述。\n\n该问题没有表现出任何缺陷，如科学上不成立、信息缺失或不切实际的假设。所提供的延迟均值和标准差值对于工业控制网络是合理的。\n\n### 步骤 3：结论和行动\n问题是**有效的**。将提供一个完整且有理有据的解答。\n\n### 解\n设往返延迟为一个随机变量 $X$。根据题目陈述，$X$ 服从均值 $\\mu = 15$ 毫秒、标准差 $\\sigma = 5$ 毫秒的正态（高斯）分布。我们可以将其写为 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，其中 $\\mu = 15$ 且 $\\sigma = 5$。\n\n主要目标是找到该分布的 $0.99$-分位数，我们将其记为 $q_{0.99}$。根据定义，一个连续随机变量的 $p$-分位数是值 $x_p$，使得该变量小于或等于 $x_p$ 的概率为 $p$。在数学上，这通过累积分布函数 (CDF) $F_X(x)$ 表示为 $F_X(x_p) = P(X \\le x_p) = p$。\n\n对于我们的问题，我们需要找到值 $q_{0.99}$ 使得：\n$$P(X \\le q_{0.99}) = 0.99$$\n为了对一般正态分布求解，我们首先将随机变量 $X$ 标准化。我们定义一个新的随机变量 $Z$ 为：\n$$Z = \\frac{X - \\mu}{\\sigma}$$\n$Z$ 服从标准正态分布，$Z \\sim \\mathcal{N}(0, 1)$。$Z$ 的累积分布函数通常用 $\\Phi(z)$ 表示。\n\n我们可以用 $Z$ 来重写该概率表达式：\n$$P\\left(\\frac{X - \\mu}{\\sigma} \\le \\frac{q_{0.99} - \\mu}{\\sigma}\\right) = 0.99$$\n$$P\\left(Z \\le \\frac{q_{0.99} - \\mu}{\\sigma}\\right) = 0.99$$\n设 $z_{0.99}$ 为标准正态分布的 $0.99$-分位数。这是满足 $P(Z \\le z_{0.99}) = \\Phi(z_{0.99}) = 0.99$ 的值。$z_{0.99}$ 的值可以从标准统计表中查到，或者通过使用标准正态分布的逆累积分布函数得到，$z_{0.99} = \\Phi^{-1}(0.99)$。\n从上面的方程，我们得到：\n$$\\frac{q_{0.99} - \\mu}{\\sigma} = z_{0.99}$$\n解出 $q_{0.99}$，我们得到表达式：\n$$q_{0.99} = \\mu + z_{0.99} \\sigma$$\n$z_{0.99}$ 的值是统计学中的一个标准常数，约等于 $z_{0.99} \\approx 2.326348$。现在，我们可以代入给定的 $\\mu$ 和 $\\sigma$ 的值：\n$$\\mu = 15$$\n$$\\sigma = 5$$\n$$q_{0.99} \\approx 15 + (2.326348)(5)$$\n$$q_{0.99} \\approx 15 + 11.63174$$\n$$q_{0.99} \\approx 26.63174 \\text{ ms}$$\n这个值表示只有 1% 的时间延迟会超过它。\n\n下一步是计算 SLO 裕度 $\\Delta$，它被定义为 SLO 阈值 $L_{\\mathrm{SLO}}$ 与计算出的 $0.99$-分位数 $q_{0.99}$ 之间的差值：\n$$\\Delta = L_{\\mathrm{SLO}} - q_{0.99}$$\n题目说明 SLO 阈值为 $L_{\\mathrm{SLO}} = 30$ 毫秒。\n$$\\Delta \\approx 30 - 26.63174$$\n$$\\Delta \\approx 3.36826 \\text{ ms}$$\n因为 $\\Delta > 0$，系统满足其服务等级目标。\n\n最后，题目要求将 $\\Delta$ 的值四舍五入到四位有效数字。计算出的值为 $3.36826\\dots$。\n前四位有效数字是 $3$、$3$、$6$ 和 $8$。第五位有效数字是 $2$。由于 $2  5$，我们向下舍入，这意味着我们保持第四位有效数字不变。\n因此，$\\Delta$ 的四舍五入值为 $3.368$。",
            "answer": "$$\n\\boxed{3.368}\n$$"
        },
        {
            "introduction": "当数据能够被可靠且及时地传输后，数字孪生的核心价值便体现在对这些数据进行高级分析与应用上。这个动手编程练习将指导你构建一个核心的系统监控功能：使用主成分分析（Principal Component Analysis, PCA）方法来实时检测系统运行的异常状态。这是数字孪生在运营维护生命周期阶段的一项关键任务，也是双向数据链路价值的直接体现。",
            "id": "4214271",
            "problem": "一个信息物理系统 (CPS) 的数字孪生 (DT) 使用主成分分析 (PCA) 通过双向数据链路监控正常运行，并在新数据偏离已学习的潜在结构时标记异常。假设训练数据是从均值向量为 $\\mu$、协方差矩阵为 $\\Sigma$ 的多元正态分布中抽取的独立同分布样本。所学习的 PCA 模型是通过对从训练数据计算出的样本协方差矩阵进行特征分解得到的。对于一个新的中心化样本 $x_c = x - \\hat{\\mu}$，定义了两个监控统计量：保留主子空间中的 Hotelling’s $T^2$ 统计量和残差子空间中的平方预测误差（SPE，也称为 $Q$ 统计量）。使用经过充分检验的公式，定义两个统计量在 99% 水平下的限值，并判断新样本相对于每个统计量是否异常。\n\n基本原理：\n- 训练数据矩阵 $X \\in \\mathbb{R}^{N \\times p}$ 被建模为来自多元正态分布 $\\mathcal{N}(\\mu, \\Sigma)$ 的样本。\n- 样本均值为 $\\hat{\\mu} = \\frac{1}{N} \\sum_{i=1}^{N} x_i$。\n- 无偏样本协方差矩阵为 $S = \\frac{1}{N - 1} \\sum_{i=1}^{N} (x_i - \\hat{\\mu})(x_i - \\hat{\\mu})^\\top$。\n- $S$ 的特征分解为 $S = P \\Lambda P^\\top$，其中 $P \\in \\mathbb{R}^{p \\times p}$ 是标准正交矩阵，$\\Lambda = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_p)$ 且 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_p \\ge 0$。\n- 对于保留的维度 $A$（其中 $A  p$），定义 $P_A \\in \\mathbb{R}^{p \\times A}$ 和 $\\Lambda_A = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_A)$，以及残差特征值 $\\{\\lambda_{A+1}, \\dots, \\lambda_p\\}$。\n\n监控统计量：\n- 保留子空间中的得分向量为 $t = P_A^\\top x_c$。Hotelling’s $T^2$ 统计量为\n$$\nT^2 = t^\\top \\Lambda_A^{-1} t = \\sum_{a=1}^A \\frac{t_a^2}{\\lambda_a}.\n$$\n- 重构误差为 $e = x_c - P_A P_A^\\top x_c$。平方预测误差为\n$$\n\\mathrm{SPE} = \\|e\\|_2^2 = e^\\top e.\n$$\n\n99% 水平下的控制限：\n- 在有限样本设置下，当未知协方差从 $N$ 个训练样本中估计时，Hotelling’s $T^2$ 控制限使用 F 分布，由下式给出\n$$\nT^2_{\\text{lim}}(0.99) = \\frac{A(N - 1)}{N - A} F_{A,\\, N - A}(0.99),\n$$\n其中 $F_{A, N - A}(0.99)$ 是自由度为 $A$ 和 $N - A$ 的 F 分布的 0.99 分位数。\n- 平方预测误差限使用 Jackson–Mudholkar 近似。令\n$$\n\\theta_1 = \\sum_{i=A+1}^{p} \\lambda_i,\\quad\n\\theta_2 = \\sum_{i=A+1}^{p} \\lambda_i^2,\\quad\n\\theta_3 = \\sum_{i=A+1}^{p} \\lambda_i^3,\n$$\n且\n$$\nh_0 = 1 - \\frac{2\\theta_1 \\theta_3}{3 \\theta_2^2}.\n$$\n如果 $\\theta_2 > 0$，则 99% 限值为\n$$\nQ_{\\text{lim}}(0.99) = \\theta_1 \\left( \\frac{z_{0.99} \\sqrt{2 \\theta_2}\\, h_0}{\\theta_1} + 1 + \\frac{\\theta_2 h_0 (h_0 - 1)}{\\theta_1^2} \\right)^{1/h_0},\n$$\n其中 $z_{0.99}$ 是标准正态分布的 0.99 分位数。\n\n您的任务：\n- 实现一个完整的程序，对每个测试用例，根据提供的训练数据矩阵计算 PCA 模型，为给定的新数据样本评估 Hotelling’s $T^2$ 和 $\\mathrm{SPE}$ 统计量，将它们与 99% 限值进行比较，并输出异常标志：$T^2 > T^2_{\\text{lim}}(0.99)$ 和 $\\mathrm{SPE} > Q_{\\text{lim}}(0.99)$。\n- 每个测试用例的最终输出必须是布尔值。不需要物理单位。\n- 程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例产生一个包含两个元素的列表 $[T2\\_flag, SPE\\_flag]$，总体输出按顺序收集这些列表。例如：$[[\\text{True},\\text{False}],[\\text{False},\\text{False}]]$。\n\n测试套件：\n- 测试用例 1 (正常路径): $N = 12$, $p = 3$, $A = 2$。训练数据矩阵\n$$\nX_1 = \\begin{bmatrix}\n1.0  0.5  1.3\\\\\n0.8  0.7  1.1\\\\\n1.1  0.6  1.4\\\\\n0.9  0.4  1.2\\\\\n1.2  0.9  1.7\\\\\n1.0  0.8  1.5\\\\\n0.7  0.5  1.0\\\\\n1.3  0.7  1.8\\\\\n0.9  0.6  1.2\\\\\n1.1  0.5  1.4\\\\\n0.8  0.4  1.0\\\\\n1.2  0.8  1.6\n\\end{bmatrix},\\quad\nx^{\\text{new}}_1 = \\begin{bmatrix} 1.8  0.2  2.5 \\end{bmatrix}.\n$$\n- 测试用例 2 (保留维度的边界情况): $N = 10$, $p = 4$, $A = 1$。训练数据矩阵\n$$\nX_2 = \\begin{bmatrix}\n10.0  9.8  0.2  0.1\\\\\n9.7  9.6  0.1  0.2\\\\\n10.2  10.0  0.3  0.2\\\\\n9.9  9.7  0.2  0.3\\\\\n10.1  9.9  0.2  0.1\\\\\n9.8  9.7  0.1  0.2\\\\\n10.0  9.8  0.3  0.2\\\\\n9.9  9.6  0.2  0.3\\\\\n10.2  10.1  0.3  0.1\\\\\n9.7  9.6  0.1  0.2\n\\end{bmatrix},\\quad\nx^{\\text{new}}_2 = \\begin{bmatrix} 10.8  10.7  0.5  0.4 \\end{bmatrix}.\n$$\n- 测试用例 3 (小样本边缘情况): $N = 6$, $p = 5$, $A = 2$。训练数据矩阵\n$$\nX_3 = \\begin{bmatrix}\n2.0  1.0  3.0  0.5  1.5\\\\\n1.8  1.1  2.9  0.6  1.4\\\\\n2.1  0.9  3.1  0.4  1.6\\\\\n1.9  1.0  3.0  0.5  1.6\\\\\n2.0  1.2  3.2  0.6  1.7\\\\\n1.8  0.8  2.8  0.4  1.4\n\\end{bmatrix},\\quad\nx^{\\text{new}}_3 = \\begin{bmatrix} 2.5  0.5  3.7  0.2  2.0 \\end{bmatrix}.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式必须完全如下\n$$\n[[T2\\_1,SPE\\_1],[T2\\_2,SPE\\_2],[T2\\_3,SPE\\_3]],\n$$\n其中每个条目都是布尔字面量 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "我们首先假设训练数据矩阵 $X \\in \\mathbb{R}^{N \\times p}$ 来自通过双向数据链路连接到其信息物理系统 (CPS) 的数字孪生 (DT) 的稳定运行状态。这一假设意味着训练数据是从多元正态分布 $\\mathcal{N}(\\mu, \\Sigma)$ 中抽取的样本，这是基于主成分分析 (PCA) 的监控的标准基础。我们计算样本均值 $\\hat{\\mu}$ 和无偏样本协方差 $S$：\n$$\n\\hat{\\mu} = \\frac{1}{N} \\sum_{i=1}^{N} x_i,\\quad\nS = \\frac{1}{N - 1} \\sum_{i=1}^{N} (x_i - \\hat{\\mu})(x_i - \\hat{\\mu})^\\top.\n$$\nPCA 模型通过对 $S$ 进行特征分解得到：\n$$\nS = P \\Lambda P^\\top,\n$$\n其中 $P \\in \\mathbb{R}^{p \\times p}$ 是标准正交矩阵 ($P^\\top P = I$)，$\\Lambda = \\operatorname{diag}(\\lambda_1,\\dots,\\lambda_p)$ 包含按 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_p \\ge 0$ 排序的特征值。我们选择前 $A$ 个主成分，记为 $P_A$ 和 $\\Lambda_A$。\n\n对于任何新的观测值 $x$，我们使用训练均值将其中心化：$x_c = x - \\hat{\\mu}$。在保留子空间上的投影（得分）为\n$$\nt = P_A^\\top x_c,\n$$\nHotelling’s $T^2$ 统计量是二次型\n$$\nT^2 = t^\\top \\Lambda_A^{-1} t = \\sum_{a=1}^{A} \\frac{t_a^2}{\\lambda_a}.\n$$\n这是通过用每个主成分所捕获的方差对得分进行标准化而得出的。从保留子空间重构 $x_c$ 的结果是 $P_A P_A^\\top x_c$，残差为\n$$\ne = x_c - P_A P_A^\\top x_c.\n$$\n平方预测误差（SPE 或 $Q$ 统计量）是残差的平方范数：\n$$\n\\mathrm{SPE} = \\|e\\|_2^2 = e^\\top e.\n$$\n在基于 PCA 的监控中，这两个统计量分别对应于潜在结构偏差 ($T^2$) 和子空间外偏差 ($\\mathrm{SPE}$)。\n\n为了确定 99% 水平下的异常标志，我们需要控制限。对于 Hotelling’s $T^2$，我们从一个经典结果开始：如果协方差已知，则 $T^2$ 服从自由度为 $A$ 的卡方分布。然而，由于 $\\Sigma$ 未知并且是从 $N$ 个样本中估计的，因此适当的阶段 I 或阶段 II 限值使用 F 分布：\n$$\nT^2_{\\text{lim}}(0.99) = \\frac{A(N - 1)}{N - A} F_{A,\\, N - A}(0.99),\n$$\n其中 $F_{A, N - A}(0.99)$ 是自由度为 $A$ 和 $N - A$ 的 F 分布的 0.99 分位数。这包含了估计 $\\Sigma$ 带来的不确定性，并产生更准确的有限样本界。\n\n对于 SPE 限值，我们依赖于 Jackson–Mudholkar 近似，该近似使用残差特征值 $\\lambda_{A+1}, \\dots, \\lambda_p$ 的矩：\n$$\n\\theta_1 = \\sum_{i=A+1}^{p} \\lambda_i,\\quad\n\\theta_2 = \\sum_{i=A+1}^{p} \\lambda_i^2,\\quad\n\\theta_3 = \\sum_{i=A+1}^{p} \\lambda_i^3.\n$$\n定义\n$$\nh_0 = 1 - \\frac{2\\theta_1 \\theta_3}{3 \\theta_2^2}.\n$$\n当 $\\theta_2>0$ 时，SPE 的 99% 控制限为\n$$\nQ_{\\text{lim}}(0.99) = \\theta_1 \\left( \\frac{z_{0.99}\\, \\sqrt{2 \\theta_2}\\, h_0}{\\theta_1} + 1 + \\frac{\\theta_2 h_0 (h_0 - 1)}{\\theta_1^2} \\right)^{1/h_0},\n$$\n其中 $z_{0.99}$ 是标准正态分布的 0.99 分位数。这种近似方法经过了充分检验，并在 PCA 监控文献中广泛用于残差空间检测。\n\n整合这些原理的算法步骤：\n1. 使用无偏估计量从每个训练矩阵 $X$ 计算 $\\hat{\\mu}$ 和 $S$。\n2. 执行特征分解 $S = P \\Lambda P^\\top$，并按降序对特征值和特征向量进行排序。\n3. 选择 $P_A$ 和 $\\Lambda_A$，并计算中心化的新样本 $x_c$。\n4. 计算得分 $t = P_A^\\top x_c$ 和 Hotelling’s $T^2 = \\sum_{a=1}^A t_a^2/\\lambda_a$。\n5. 计算残差 $e = x_c - P_A P_A^\\top x_c$ 和 $\\mathrm{SPE} = e^\\top e$。\n6. 使用自由度为 $A$ 和 $N - A$ 的 F 分布分位数计算 $T^2_{\\text{lim}}(0.99)$：\n$$\nT^2_{\\text{lim}} = \\frac{A(N - 1)}{N - A} F_{A,\\,N - A}(0.99).\n$$\n7. 使用上述的 $\\theta_1, \\theta_2, \\theta_3$, $h_0$ 和 $z_{0.99}$ 计算 $Q_{\\text{lim}}(0.99)$。如果 $\\theta_2 = 0$，则设 $Q_{\\text{lim}}(0) = 0$，因为残差子空间的方差为零。\n8. 确定布尔异常标志：\n$$\n\\text{T2\\_flag} = [T^2 > T^2_{\\text{lim}}(0.99)],\\quad\n\\text{SPE\\_flag} = [\\mathrm{SPE} > Q_{\\text{lim}}(0.99)].\n$$\n\n边缘情况考虑：\n- 如果 $A = 0$，则 $T^2 = 0$ 且限值未定义；但是，测试套件避免了 $A=0$ 的情况。\n- 如果 $N \\le A$，由于自由度的原因，无法计算基于 F 分布的限值；测试套件确保 $N > A$。\n- 如果由于舍入误差出现数值上的微小负特征值，在用于分母之前将其截断为一个小的非负值。\n\n实现：\n- 使用提供的矩阵 $X_1$、$X_2$、$X_3$、它们各自的 $A$ 值以及新样本 $x^{\\text{new}}_1$、$x^{\\text{new}}_2$、$x^{\\text{new}}_3$。\n- 计算每个测试用例的布尔标志，并将其汇总到单行输出中，格式需完全符合要求。\n\n该方法将 PCA 中的异常检测建立在具有统计学依据的阈值之上，适用于信息物理系统中数字孪生生命周期监控和双向数据链路的高级研究生水平分析。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f, norm\n\ndef pca_anomaly_flags(X_train, x_new, A, alpha=0.99):\n    \"\"\"\n    Compute PCA from training data, evaluate Hotelling's T^2 and SPE for x_new,\n    and return boolean anomaly flags at the given alpha level.\n    \"\"\"\n    X = np.array(X_train, dtype=float)\n    x = np.array(x_new, dtype=float)\n    N, p = X.shape\n\n    # Compute sample mean and unbiased covariance\n    mu = X.mean(axis=0)\n    Xc = X - mu\n    # Unbiased sample covariance: (1/(N-1)) Xc^T Xc\n    S = np.cov(X, rowvar=False, bias=False)\n\n    # Eigen-decomposition (S is symmetric). eigh returns ascending eigenvalues.\n    evals, evecs = np.linalg.eigh(S)\n    order = np.argsort(evals)[::-1]  # descending order\n    evals = evals[order]\n    evecs = evecs[:, order]\n\n    # Clip tiny negative eigenvalues due to numerical errors\n    evals = np.clip(evals, 1e-12, None)\n\n    # Retained subspace\n    if A > 0:\n        P_A = evecs[:, :A]\n        lamA = evals[:A]\n    else:\n        # Not used in tests, but for completeness\n        P_A = np.zeros((p, 0))\n        lamA = np.array([])\n\n    # Residual eigenvalues\n    lam_resid = evals[A:] if A  p else np.array([])\n\n    # Center new sample\n    x_c = x - mu\n\n    # Scores and T^2\n    if A > 0:\n        t = x_c @ P_A\n        T2 = np.sum((t ** 2) / lamA)\n    else:\n        T2 = 0.0\n\n    # T^2 limit using F-distribution\n    if A > 0 and (N - A) > 0:\n        Fcrit = f.ppf(alpha, A, N - A)\n        T2_limit = (A * (N - 1) / (N - A)) * Fcrit\n    else:\n        # Degenerate case; mark limit as infinity to avoid false alarms\n        T2_limit = np.inf\n\n    # Residual and SPE\n    if A > 0:\n        e = x_c - P_A @ (P_A.T @ x_c)\n    else:\n        e = x_c.copy()\n    SPE = float(np.dot(e, e))\n\n    # SPE limit via Jackson–Mudholkar approximation\n    theta1 = float(np.sum(lam_resid))\n    theta2 = float(np.sum(lam_resid ** 2))\n    theta3 = float(np.sum(lam_resid ** 3))\n\n    if theta2 > 0 and theta1 > 0:\n        h0 = 1.0 - (2.0 * theta1 * theta3) / (3.0 * (theta2 ** 2))\n        z = norm.ppf(alpha)\n        Q_limit = theta1 * (\n            (z * np.sqrt(2.0 * theta2) * h0) / theta1\n            + 1.0\n            + (theta2 * h0 * (h0 - 1.0)) / (theta1 ** 2)\n        ) ** (1.0 / h0)\n        Q_limit = max(Q_limit, 0.0)\n    else:\n        # No residual variance -> residual space is zero -> limit zero\n        Q_limit = 0.0\n\n    # Flags\n    t2_flag = bool(T2 > T2_limit)\n    spe_flag = bool(SPE > Q_limit)\n\n    return t2_flag, spe_flag\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            [\n                [1.0, 0.5, 1.3],\n                [0.8, 0.7, 1.1],\n                [1.1, 0.6, 1.4],\n                [0.9, 0.4, 1.2],\n                [1.2, 0.9, 1.7],\n                [1.0, 0.8, 1.5],\n                [0.7, 0.5, 1.0],\n                [1.3, 0.7, 1.8],\n                [0.9, 0.6, 1.2],\n                [1.1, 0.5, 1.4],\n                [0.8, 0.4, 1.0],\n                [1.2, 0.8, 1.6],\n            ],\n            [1.8, 0.2, 2.5],\n            2,\n        ),\n        # Test case 2\n        (\n            [\n                [10.0, 9.8, 0.2, 0.1],\n                [9.7, 9.6, 0.1, 0.2],\n                [10.2, 10.0, 0.3, 0.2],\n                [9.9, 9.7, 0.2, 0.3],\n                [10.1, 9.9, 0.2, 0.1],\n                [9.8, 9.7, 0.1, 0.2],\n                [10.0, 9.8, 0.3, 0.2],\n                [9.9, 9.6, 0.2, 0.3],\n                [10.2, 10.1, 0.3, 0.1],\n                [9.7, 9.6, 0.1, 0.2],\n            ],\n            [10.8, 10.7, 0.5, 0.4],\n            1,\n        ),\n        # Test case 3\n        (\n            [\n                [2.0, 1.0, 3.0, 0.5, 1.5],\n                [1.8, 1.1, 2.9, 0.6, 1.4],\n                [2.1, 0.9, 3.1, 0.4, 1.6],\n                [1.9, 1.0, 3.0, 0.5, 1.6],\n                [2.0, 1.2, 3.2, 0.6, 1.7],\n                [1.8, 0.8, 2.8, 0.4, 1.4],\n            ],\n            [2.5, 0.5, 3.7, 0.2, 2.0],\n            2,\n        ),\n    ]\n\n    results = []\n    for X_train, x_new, A in test_cases:\n        t2_flag, spe_flag = pca_anomaly_flags(X_train, x_new, A, alpha=0.99)\n        results.append([t2_flag, spe_flag])\n\n    # Format output exactly as required: no spaces, boolean literals.\n    def format_bool(b):\n        return \"True\" if b else \"False\"\n\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(format_bool(b) for b in pair) + \"]\" for pair in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        }
    ]
}