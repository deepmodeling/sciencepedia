{
    "hands_on_practices": [
        {
            "introduction": "In a complex Service-Oriented Architecture, ensuring that individual services can communicate without protocol errors is a critical first step. This practice introduces Interface Automata, a formal method used to model and verify the compatibility of interacting components. By composing the automata of two services, you will rigorously check for mismatches in their interaction protocol, a crucial step in preventing integration failures in mission-critical Cyber-Physical Systems. ",
            "id": "4245761",
            "problem": "Consider a Service-Oriented Architecture (SOA) design for Cyber-Physical Systems (CPS) in which each service is specified as an Interface Automaton (IA). An IA is a tuple $(S, s_0, \\Sigma^I, \\Sigma^O, \\Sigma^H, \\rightarrow)$ where $S$ is a finite set of states, $s_0 \\in S$ is the initial state, $\\Sigma^I$ is the set of input actions, $\\Sigma^O$ is the set of output actions, $\\Sigma^H$ is the set of internal actions, with $\\Sigma^I$, $\\Sigma^O$, and $\\Sigma^H$ pairwise disjoint, and $\\rightarrow \\subseteq S \\times (\\Sigma^I \\cup \\Sigma^O \\cup \\Sigma^H) \\times S$ is the transition relation. An IA is called input-enabled for an input action $a \\in \\Sigma^I$ at a state $s \\in S$ if there exists at least one transition $(s, a, s') \\in \\rightarrow$. Two IAs $A$ and $B$ compose synchronously on shared actions according to the following fundamental principles: shared actions are those in $(\\Sigma^I_A \\cup \\Sigma^O_A) \\cap (\\Sigma^I_B \\cup \\Sigma^O_B)$, and a shared action synchronizes only if it is an output of exactly one IA and an input of the other IA. A pair state $(p, q) \\in S_A \\times S_B$ is illegal if there exists a shared action $a$ such that either both $A$ and $B$ have $a$ as an output enabled at $(p, q)$, or one IA has $a$ as an output enabled at its component of $(p, q)$ while the other IA is not input-enabled for $a$ at its component of $(p, q)$. Two IAs are compatible if the synchronous product starting from $(s_{0,A}, s_{0,B})$ has no reachable illegal pair states.\n\nYou are given two CPS services with the following IAs:\n\nService $A$: $S_A = \\{s_0, s_1, s_2, s_3\\}$, initial state $s_{0,A} = s_0$, input actions $\\Sigma^I_A = \\{\\text{req}\\}$, output actions $\\Sigma^O_A = \\{\\text{ack}, \\text{data}\\}$, internal actions $\\Sigma^H_A = \\emptyset$, and transitions\n$$\ns_0 \\xrightarrow{\\text{req}} s_1,\\quad\ns_1 \\xrightarrow{\\text{ack}} s_2,\\quad\ns_2 \\xrightarrow{\\text{data}} s_3.\n$$\n\nService $B$: $S_B = \\{t_0, t_1, t_2\\}$, initial state $s_{0,B} = t_0$, input actions $\\Sigma^I_B = \\{\\text{ack}, \\text{data}\\}$, output actions $\\Sigma^O_B = \\{\\text{req}\\}$, internal actions $\\Sigma^H_B = \\emptyset$, and transitions\n$$\nt_0 \\xrightarrow{\\text{req}} t_1,\\quad\nt_1 \\xrightarrow{\\text{ack}} t_2.\n$$\n\nAssume standard synchronous composition semantics for interface automata as described above, including the treatment of shared action labels and input-enabledness. Compute the synchronous composition starting from $(s_0, t_0)$, determine whether the services $A$ and $B$ are compatible, and report the compatibility indicator $c \\in \\{0, 1\\}$, where $c = 1$ denotes compatibility and $c = 0$ denotes incompatibility. Your final answer must be the value of $c$. No rounding is required and no physical units are involved.\n\nAdditionally, in your derivation, explain from first principles how input-enabledness and shared action labels together detect mismatches in this composition, and why they lead to the reported $c$ value.",
            "solution": "The problem is first subjected to a validation process.\n\n**Step 1: Extract Givens**\n- **Interface Automaton (IA) Definition:** An IA is a tuple $(S, s_0, \\Sigma^I, \\Sigma^O, \\Sigma^H, \\rightarrow)$ where $S$ is a finite set of states, $s_0 \\in S$ is the initial state, $\\Sigma^I$ is the set of input actions, $\\Sigma^O$ is the set of output actions, $\\Sigma^H$ is the set of internal actions. $\\Sigma^I, \\Sigma^O, \\Sigma^H$ are pairwise disjoint. $\\rightarrow \\subseteq S \\times (\\Sigma^I \\cup \\Sigma^O \\cup \\Sigma^H) \\times S$ is the transition relation.\n- **Input-Enabledness:** An IA is input-enabled for an input action $a \\in \\Sigma^I$ at a state $s \\in S$ if there exists at least one transition $(s, a, s') \\in \\rightarrow$.\n- **Shared Actions:** For two IAs $A$ and $B$, shared actions are those in $(\\Sigma^I_A \\cup \\Sigma^O_A) \\cap (\\Sigma^I_B \\cup \\Sigma^O_B)$.\n- **Synchronization Condition:** A shared action synchronizes only if it is an output of exactly one IA and an input of the other IA.\n- **Illegal State:** A pair state $(p, q) \\in S_A \\times S_B$ is illegal if for a shared action $a$, either (1) both $A$ and $B$ have $a$ as an enabled output at $(p, q)$, or (2) one IA has $a$ as an enabled output at its component of $(p, q)$ while the other IA is not input-enabled for $a$ at its component of $(p, q)$.\n- **Compatibility:** Two IAs are compatible if the synchronous product starting from $(s_{0,A}, s_{0,B})$ has no reachable illegal pair states.\n- **Service A:**\n    - State set: $S_A = \\{s_0, s_1, s_2, s_3\\}$\n    - Initial state: $s_{0,A} = s_0$\n    - Input actions: $\\Sigma^I_A = \\{\\text{req}\\}$\n    - Output actions: $\\Sigma^O_A = \\{\\text{ack}, \\text{data}\\}$\n    - Internal actions: $\\Sigma^H_A = \\emptyset$\n    - Transitions: $s_0 \\xrightarrow{\\text{req}} s_1$, $s_1 \\xrightarrow{\\text{ack}} s_2$, $s_2 \\xrightarrow{\\text{data}} s_3$\n- **Service B:**\n    - State set: $S_B = \\{t_0, t_1, t_2\\}$\n    - Initial state: $s_{0,B} = t_0$\n    - Input actions: $\\Sigma^I_B = \\{\\text{ack}, \\text{data}\\}$\n    - Output actions: $\\Sigma^O_B = \\{\\text{req}\\}$\n    - Internal actions: $\\Sigma^H_B = \\emptyset$\n    - Transitions: $t_0 \\xrightarrow{\\text{req}} t_1$, $t_1 \\xrightarrow{\\text{ack}} t_2$\n- **Task:** Compute the synchronous composition, determine compatibility, and report the compatibility indicator $c \\in \\{0, 1\\}$, where $c=1$ for compatible and $c=0$ for incompatible.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it uses the well-defined formalism of Interface Automata theory, a standard topic in formal methods for component-based systems and cyber-physical systems. The problem is well-posed, providing all necessary definitions and data for the two automata. The terminology is objective and precise. The setup is complete and self-contained. There are no contradictions; the action sets for each automaton are pairwise disjoint as required. The problem is formal and verifiable by applying the stated rules. Therefore, the problem is deemed valid.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be provided.\n\n**Solution Derivation**\nThe solution requires computing the synchronous product of the two Interface Automata (IAs), $A$ and $B$, and checking for the reachability of any illegal states.\n\nFirst, we identify the set of shared actions, which are the actions common to the alphabets of both automata.\nThe alphabet of $A$ is $\\Sigma_A = \\Sigma^I_A \\cup \\Sigma^O_A = \\{\\text{req}, \\text{ack}, \\text{data}\\}$.\nThe alphabet of $B$ is $\\Sigma_B = \\Sigma^I_B \\cup \\Sigma^O_B = \\{\\text{req}, \\text{ack}, \\text{data}\\}$.\nThe set of shared actions is $\\Sigma_{shared} = \\Sigma_A \\cap \\Sigma_B = \\{\\text{req}, \\text{ack}, \\text{data}\\}$.\n\nNext, we verify the synchronization condition for each shared action. An action can synchronize only if it is an input for one IA and an output for the other.\n- For `req`: $\\text{req} \\in \\Sigma^I_A$ and $\\text{req} \\in \\Sigma^O_B$. This is a valid synchronization ($B$ sends, $A$ receives).\n- For `ack`: $\\text{ack} \\in \\Sigma^O_A$ and $\\text{ack} \\in \\Sigma^I_B$. This is a valid synchronization ($A$ sends, $B$ receives).\n- For `data`: $\\text{data} \\in \\Sigma^O_A$ and $\\text{data} \\in \\Sigma^I_B$. This is a valid synchronization ($A$ sends, $B$ receives).\nAll shared actions correspond to valid communication channels.\n\nNow, we perform a reachability analysis of the composite system, starting from the initial pair state $(s_{0,A}, s_{0,B}) = (s_0, t_0)$. We explore reachable states and check each one for illegality.\n\n1.  **Initial State:** $(s_0, t_0)$.\n    - We check if $(s_0, t_0)$ is an illegal state.\n    - At state $s_0$, automaton $A$ has no enabled outputs.\n    - At state $t_0$, automaton $B$ has one enabled output: `req`.\n    - There are no shared actions that are outputs of both automata.\n    - We check the second condition for illegality: automaton $B$ has an enabled output `req` at $t_0$. Automaton $A$ must be input-enabled for `req` at $s_0$. From the definition of $A$, there exists a transition $s_0 \\xrightarrow{\\text{req}} s_1$. Thus, $A$ is input-enabled for `req` at $s_0$.\n    - Therefore, the state $(s_0, t_0)$ is a legal state.\n    - The only possible transition is the synchronous execution of the shared action `req`.\n    - Transition: $(s_0, t_0) \\xrightarrow{\\text{req}} (s_1, t_1)$. The new reachable state is $(s_1, t_1)$.\n\n2.  **State:** $(s_1, t_1)$.\n    - We check if $(s_1, t_1)$ is an illegal state.\n    - At state $s_1$, automaton $A$ has one enabled output: `ack`.\n    - At state $t_1$, automaton $B$ has no enabled outputs.\n    - There are no shared actions that are outputs of both automata.\n    - We check the second condition: automaton $A$ has an enabled output `ack` at $s_1$. Automaton $B$ must be input-enabled for `ack` at $t_1$. From the definition of $B$, there exists a transition $t_1 \\xrightarrow{\\text{ack}} t_2$. Thus, $B$ is input-enabled for `ack` at $t_1$.\n    - Therefore, the state $(s_1, t_1)$ is a legal state.\n    - The only possible transition is the synchronous execution of the shared action `ack`.\n    - Transition: $(s_1, t_1) \\xrightarrow{\\text{ack}} (s_2, t_2)$. The new reachable state is $(s_2, t_2)$.\n\n3.  **State:** $(s_2, t_2)$.\n    - We check if $(s_2, t_2)$ is an illegal state.\n    - At state $s_2$, automaton $A$ has one enabled output: `data`, as given by the transition $s_2 \\xrightarrow{\\text{data}} s_3$.\n    - At state $t_2$, automaton $B$ has no enabled outputs.\n    - There are no shared actions that are outputs of both automata.\n    - We check the second condition for illegality: automaton $A$ has an enabled output `data` at $s_2$. We must check if automaton $B$ is input-enabled for `data` at $t_2$. The action `data` is in the input alphabet of $B$, i.e., $\\text{data} \\in \\Sigma^I_B$. For $B$ to be input-enabled for `data` at $t_2$, there must exist a transition $(t_2, \\text{data}, t') \\in \\rightarrow_B$ for some state $t' \\in S_B$.\n    - Examining the transitions of $B$, $t_0 \\xrightarrow{\\text{req}} t_1$ and $t_1 \\xrightarrow{\\text{ack}} t_2$, we see there are no outgoing transitions from state $t_2$.\n    - Therefore, automaton $B$ is **not input-enabled** for the action `data` at state $t_2$.\n    - This satisfies the second condition for an illegal state: one IA ($A$) has an output (`data`) enabled at its component state ($s_2$) while the other IA ($B$) is not input-enabled for that action at its component state ($t_2$).\n    - Thus, $(s_2, t_2)$ is an **illegal state**.\n\nSince the illegal state $(s_2, t_2)$ is reachable from the initial state $(s_0, t_0)$ via the sequence of transitions $(s_0, t_0) \\xrightarrow{\\text{req}} (s_1, t_1) \\xrightarrow{\\text{ack}} (s_2, t_2)$, the two IAs, $A$ and $B$, are not compatible.\n\nThe core of the incompatibility lies in a specification mismatch. The composition models a protocol where $B$ requests a resource (`req`), $A$ acknowledges (`ack`), and then $A$ sends the data (`data`). Automaton $A$ is specified to follow this protocol exactly. Automaton $B$ is specified to initiate the request and receive the acknowledgment, transitioning to state $t_2$. However, its specification is incomplete: in state $t_2$, it is not prepared to receive the `data` that $A$ is specified to send. The formalism of Interface Automata, particularly the concept of input-enabledness, is designed to detect precisely this kind of mismatch. The shared action `data` defines a required interaction, but automaton $B$'s state machine has a \"hole\" -- it doesn't specify what to do upon receiving `data` in state $t_2$. The synchronous composition explores the joint behavior and reveals this flaw by reaching the illegal state $(s_2, t_2)$.\n\nAccording to the problem, the compatibility indicator $c$ is $1$ for compatible services and $0$ for incompatible services. Since the services are incompatible, the value of $c$ is $0$.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Beyond protocol compatibility, many CPS services must meet strict timing deadlines for the system to function correctly. This exercise delves into the domain of real-time systems by applying Response Time Analysis (RTA), a fundamental technique for deterministic schedulability analysis. You will calculate the worst-case response time for a service running alongside higher-priority tasks, providing a hard guarantee of its ability to meet its deadline under fixed-priority scheduling. ",
            "id": "4245887",
            "problem": "A cyber-physical system (CPS) for a robotic production cell is implemented using a Service-Oriented Architecture (SOA) on an edge controller. The edge controller executes service tasks on a single processor using Fixed-Priority Preemptive Scheduling (FPPS) with rate-monotonic priority assignment: services with shorter period have higher priority. All services are strictly periodic, independent (no shared resources or self-suspensions), and have no release jitter. Communication and middleware overheads are already included in the worst-case execution times (WCETs). Consider the following services, all mapped to the same processor:\n\n- Sensor preprocessing service: period $T_{1} = 5\\,\\mathrm{ms}$, worst-case execution time $C_{1} = 1\\,\\mathrm{ms}$.\n- Telemetry encoding service: period $T_{2} = 10\\,\\mathrm{ms}$, worst-case execution time $C_{2} = 1.5\\,\\mathrm{ms}$.\n- Actuator watchdog service: period $T_{3} = 20\\,\\mathrm{ms}$, worst-case execution time $C_{3} = 2\\,\\mathrm{ms}$.\n- Digital twin state reconciliation service (the task of interest): period $T_{4} = 40\\,\\mathrm{ms}$, worst-case execution time $C_{4} = 4\\,\\mathrm{ms}$, and relative deadline $D_{4} = 12\\,\\mathrm{ms}$.\n\nYou are to compute the worst-case response time $R_{4}$ of the digital twin state reconciliation service under synchronous release of all higher-priority services, using the foundational busy-window argument for fixed-priority systems and the definition of response time as own execution plus interference from all higher-priority services. Determine whether the service is schedulable with respect to its relative deadline $D_{4}$.\n\nReport your final answer as a two-component vector $(R_{4}, s)$, where $R_{4}$ is the worst-case response time and $s$ is an indicator defined by $s = 1$ if $R_{4} \\leq D_{4}$ and $s = 0$ otherwise. Express $R_{4}$ in milliseconds. Provide the exact value of $R_{4}$ (no rounding).",
            "solution": "The problem is valid as it is scientifically grounded in the principles of real-time systems analysis, well-posed with sufficient and consistent data, and objectively stated. It represents a standard application of Response Time Analysis for fixed-priority preemptive systems.\n\nThe problem requires the calculation of the worst-case response time, $R_4$, for the fourth service (task $\\tau_4$) and a determination of its schedulability. The system employs Fixed-Priority Preemptive Scheduling (FPPS) with a rate-monotonic priority assignment scheme.\n\nFirst, we establish the priority of each service. Under rate-monotonic scheduling, a shorter period corresponds to a higher priority. Let $P_i$ denote the priority of service $\\tau_i$. A smaller numerical value for $P_i$ indicates a higher priority.\nThe periods are $T_1 = 5\\,\\mathrm{ms}$, $T_2 = 10\\,\\mathrm{ms}$, $T_3 = 20\\,\\mathrm{ms}$, and $T_4 = 40\\,\\mathrm{ms}$.\nSince $T_1  T_2  T_3  T_4$, the priorities are assigned as follows:\n- Service $\\tau_1$: Priority $P_1 = 1$ (highest)\n- Service $\\tau_2$: Priority $P_2 = 2$\n- Service $\\tau_3$: Priority $P_3 = 3$\n- Service $\\tau_4$: Priority $P_4 = 4$ (lowest)\n\nThe task of interest is $\\tau_4$. Its worst-case response time, $R_4$, is determined using Response Time Analysis (RTA). The worst case occurs at a critical instant, where $\\tau_4$ is released simultaneously with all higher-priority tasks ($\\tau_1, \\tau_2, \\tau_3$). The response time $R_4$ is the sum of its own worst-case execution time, $C_4$, and the total interference from all higher-priority tasks during the interval $[0, R_4)$. The interference from a higher-priority task $\\tau_j$ is its number of activations in the interval multiplied by its execution time $C_j$. The number of activations of $\\tau_j$ in an interval of length $t$ is given by $\\lceil \\frac{t}{T_j} \\rceil$.\n\nThe response time $R_i$ for a task $\\tau_i$ is the smallest positive value of $t$ that satisfies the equation:\n$$t = C_i + \\sum_{j \\in hp(i)} \\left\\lceil \\frac{t}{T_j} \\right\\rceil C_j$$\nwhere $hp(i)$ is the set of tasks with higher priority than $\\tau_i$.\n\nFor task $\\tau_4$, the set of higher-priority tasks is $hp(4) = \\{\\tau_1, \\tau_2, \\tau_3\\}$. The equation for $R_4$ is:\n$$R_4 = C_4 + \\left\\lceil \\frac{R_4}{T_1} \\right\\rceil C_1 + \\left\\lceil \\frac{R_4}{T_2} \\right\\rceil C_2 + \\left\\lceil \\frac{R_4}{T_3} \\right\\rceil C_3$$\nThis equation is solved using an iterative approach. Let $w$ be the length of the busy window being calculated.\n$$w^{(n+1)} = C_4 + \\sum_{j=1}^{3} \\left\\lceil \\frac{w^{(n)}}{T_j} \\right\\rceil C_j$$\nThe iteration starts with an initial guess, typically $w^{(0)} = C_4$. The iteration converges when $w^{(n+1)} = w^{(n)}$. This fixed point is the worst-case response time, $R_4$.\n\nThe given parameters are:\n- $C_1 = 1\\,\\mathrm{ms}$, $T_1 = 5\\,\\mathrm{ms}$\n- $C_2 = 1.5\\,\\mathrm{ms}$, $T_2 = 10\\,\\mathrm{ms}$\n- $C_3 = 2\\,\\mathrm{ms}$, $T_3 = 20\\,\\mathrm{ms}$\n- $C_4 = 4\\,\\mathrm{ms}$\n\nThe iterative formula becomes:\n$$w^{(n+1)} = 4 + \\left\\lceil \\frac{w^{(n)}}{5} \\right\\rceil(1) + \\left\\lceil \\frac{w^{(n)}}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{w^{(n)}}{20} \\right\\rceil(2)$$\n\nWe start the iteration.\nStep 0: Initialize with $w^{(0)} = C_4 = 4$.\n$$w^{(0)} = 4$$\n\nStep 1: Calculate $w^{(1)}$ using $w^{(0)} = 4$.\n$$w^{(1)} = 4 + \\left\\lceil \\frac{4}{5} \\right\\rceil(1) + \\left\\lceil \\frac{4}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{4}{20} \\right\\rceil(2)$$\n$$w^{(1)} = 4 + (1)(1) + (1)(1.5) + (1)(2) = 4 + 1 + 1.5 + 2 = 8.5$$\n\nStep 2: Calculate $w^{(2)}$ using $w^{(1)} = 8.5$.\n$$w^{(2)} = 4 + \\left\\lceil \\frac{8.5}{5} \\right\\rceil(1) + \\left\\lceil \\frac{8.5}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{8.5}{20} \\right\\rceil(2)$$\n$$w^{(2)} = 4 + \\lceil 1.7 \\rceil(1) + \\lceil 0.85 \\rceil(1.5) + \\lceil 0.425 \\rceil(2)$$\n$$w^{(2)} = 4 + (2)(1) + (1)(1.5) + (1)(2) = 4 + 2 + 1.5 + 2 = 9.5$$\n\nStep 3: Calculate $w^{(3)}$ using $w^{(2)} = 9.5$.\n$$w^{(3)} = 4 + \\left\\lceil \\frac{9.5}{5} \\right\\rceil(1) + \\left\\lceil \\frac{9.5}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{9.5}{20} \\right\\rceil(2)$$\n$$w^{(3)} = 4 + \\lceil 1.9 \\rceil(1) + \\lceil 0.95 \\rceil(1.5) + \\lceil 0.475 \\rceil(2)$$\n$$w^{(3)} = 4 + (2)(1) + (1)(1.5) + (1)(2) = 4 + 2 + 1.5 + 2 = 9.5$$\n\nSince $w^{(3)} = w^{(2)} = 9.5$, the iteration has converged. The worst-case response time for service $\\tau_4$ is $R_4 = 9.5\\,\\mathrm{ms}$.\n\nNext, we must determine if the service is schedulable by comparing its worst-case response time $R_4$ to its relative deadline $D_4$. The problem states that $D_4 = 12\\,\\mathrm{ms}$.\nThe schedulability condition is $R_4 \\le D_4$.\nSubstituting the values, we check if $9.5 \\le 12$. This inequality is true.\nTherefore, the digital twin state reconciliation service is schedulable.\n\nThe problem asks for a two-component vector $(R_4, s)$, where $R_4$ is the worst-case response time and $s$ is an indicator variable. The indicator $s$ is defined as $s=1$ if $R_4 \\le D_4$ and $s=0$ otherwise.\nSince $R_4 = 9.5\\,\\mathrm{ms}$ and $R_4 \\leq D_4$, we have $s=1$.\nThe resulting vector is $(9.5, 1)$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 9.5  1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Worst-case analysis provides guarantees under assumed conditions, but real-world systems must actively manage load to uphold performance. This hands-on coding challenge moves from analysis to enforcement, asking you to implement an admission control algorithm for a critical service. By combining a token-bucket rate limiter with a deadline check, you will simulate a practical mechanism that enforces a Service Level Agreement (SLA) by intelligently throttling requests to preserve timing integrity. ",
            "id": "4245779",
            "problem": "Consider a Cyber-Physical System (CPS) built with a Service-Oriented Architecture (SOA), where a single critical microservice handles control-loop requests issued by a Digital Twin. You must formalize Service Level Agreement (SLA) clauses that constrain timing guarantees and implement a concrete enforcement mechanism that throttles or sheds load to preserve control deadlines.\n\nStart from the following foundational base in queueing and real-time systems. For a single-server, First-In, First-Out (FIFO) system with deterministic service time, the response time of an admitted request equals the sum of its waiting time and its service time. Little's Law relates average number-in-system to throughput and average time-in-system. Admission control must ensure stability and respect deadlines by bounding per-request waiting and service times. A leaky-bucket or token-bucket rate limiter constrains the admitted arrival process by a sustained rate and a finite burst.\n\nYour task is to encode the following SLA clauses and enforce them with an algorithm:\n\n1. Hard deadline clause: For every admitted request indexed by $j$ with arrival time $t_j$, deterministic service time $s$, and per-request hard deadline $D$, the response time $R_j$ must satisfy $R_j \\le D$. Equivalently, the predicted completion time at admission, computed as $\\max(t_j, T_{\\text{free}}) + s$, where $T_{\\text{free}}$ is the current time when the server becomes free, must satisfy $\\max(t_j, T_{\\text{free}}) + s \\le t_j + D$.\n\n2. Throttle clause via token bucket: The admitted arrival process is constrained by a token bucket with parameters bucket capacity $B$ (tokens) and token generation rate $\\rho$ (tokens per second). Tokens accumulate continuously at rate $\\rho$ up to capacity $B$. Each admitted request consumes one token. Requests arriving when fewer than one token is available must be rejected immediately to satisfy the throttle clause. The initial token count is assumed to be $B$ at $t = 0$.\n\n3. Admission rule combining both clauses: Upon each request arrival at time $t$, update the token count by adding $\\rho (t - t_{\\text{last}})$ and capping by $B$, where $t_{\\text{last}}$ is the last token update time. If at least one token is available, compute the predicted finish time $T_{\\text{finish}} = \\max(t, T_{\\text{free}}) + s$. Admit the request if and only if $T_{\\text{finish}} \\le t + D$, then consume one token and update $T_{\\text{free}} \\leftarrow T_{\\text{finish}}$. If no token is available or if $T_{\\text{finish}} > t + D$, reject the request. The scheduling discipline is FIFO with a single server.\n\nAll time quantities must be expressed in seconds. There are no angles. The outcome of interest per test case is the number of admitted requests (an integer), produced by the described enforcement.\n\nImplement a complete, runnable program that, with no input, simulates the four test cases below using the exact algorithm above and outputs a single line containing a comma-separated list enclosed in square brackets of the admitted counts in the same order as the test cases, i.e., $[n_1,n_2,n_3,n_4]$.\n\nUse the following test suite. Each case defines $(\\rho, B, s, D, \\text{arrivals})$, where arrivals is the list of arrival times in seconds.\n\nTest Case $1$ (happy path, sustained rate below service capacity and deadlines loose):\n- $\\rho = 40$ tokens per second.\n- $B = 8$ tokens.\n- $s = 0.02$ seconds.\n- $D = 0.10$ seconds.\n- Arrivals: $30$ arrivals at times $[\\,0.00, 0.025, 0.050, 0.075, 0.100, 0.125, 0.150, 0.175, 0.200, 0.225, 0.250, 0.275, 0.300, 0.325, 0.350, 0.375, 0.400, 0.425, 0.450, 0.475, 0.500, 0.525, 0.550, 0.575, 0.600, 0.625, 0.650, 0.675, 0.700, 0.725\\,]$ seconds.\n\nTest Case $2$ (boundary condition, arrival near capacity, tighter deadlines):\n- $\\rho = 50$ tokens per second.\n- $B = 5$ tokens.\n- $s = 0.02$ seconds.\n- $D = 0.05$ seconds.\n- Arrivals: $60$ arrivals at times $[\\,0.000, 0.016667, 0.033333, 0.050000, 0.066667, 0.083333, 0.100000, 0.116667, 0.133333, 0.150000, 0.166667, 0.183333, 0.200000, 0.216667, 0.233333, 0.250000, 0.266667, 0.283333, 0.300000, 0.316667, 0.333333, 0.350000, 0.366667, 0.383333, 0.400000, 0.416667, 0.433333, 0.450000, 0.466667, 0.483333, 0.500000, 0.516667, 0.533333, 0.550000, 0.566667, 0.583333, 0.600000, 0.616667, 0.633333, 0.650000, 0.666667, 0.683333, 0.700000, 0.716667, 0.733333, 0.750000, 0.766667, 0.783333, 0.800000, 0.816667, 0.833333, 0.850000, 0.866667, 0.883333, 0.900000, 0.916667, 0.933333, 0.950000, 0.966667, 0.983333\\,]$ seconds.\n\nTest Case $3$ (burst load, throttle capacity critical, deadlines moderate):\n- $\\rho = 30$ tokens per second.\n- $B = 10$ tokens.\n- $s = 0.025$ seconds.\n- $D = 0.08$ seconds.\n- Arrivals: $40$ arrivals comprising two bursts, first burst at $[\\,0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19\\,]$ seconds and second burst at $[\\,0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69\\,]$ seconds.\n\nTest Case $4$ (severe overload and tight deadlines, shedding dominates):\n- $\\rho = 60$ tokens per second.\n- $B = 5$ tokens.\n- $s = 0.015$ seconds.\n- $D = 0.03$ seconds.\n- Arrivals: $100$ arrivals at times $[\\,0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.20, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.30, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69, 0.70, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.80, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99\\,]$ seconds.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[n_1,n_2,n_3,n_4]$, where $n_k$ is the integer count of admitted requests for Test Case $k$ computed by your enforcement mechanism. No other output is permitted.",
            "solution": "The problem requires the design and implementation of an admission control algorithm for a single-server queueing system, representing a critical microservice in a Cyber-Physical System. The objective is to enforce Service Level Agreement (SLA) clauses related to hard deadlines and request throttling. The system is modeled as a single-server, First-In, First-Out (FIFO) queue with deterministic service time.\n\nThe state of the system at any given time can be described by three variables:\n1.  $T_{\\text{free}}$: The time at which the single server will become available to process the next request. Initially, at time $t=0$, the server is idle, so $T_{\\text{free}} = 0$.\n2.  $N_{\\text{tokens}}$: The number of available tokens in a token bucket. The bucket has a capacity of $B$ and is refilled at a rate of $\\rho$ tokens per second. Initially, at time $t=0$, the bucket is full, so $N_{\\text{tokens}} = B$.\n3.  $t_{\\text{last}}$: The time of the last event (i.e., the last request arrival) used to calculate token replenishment. Initially, $t_{\\text{last}} = 0$.\n\nThe admission control mechanism is triggered upon the arrival of each request. Let a request arrive at time $t$. The algorithm proceeds in a sequence of checks as specified.\n\nFirst, we update the number of available tokens. The time elapsed since the last update is $\\Delta t = t - t_{\\text{last}}$. During this interval, $\\rho \\cdot \\Delta t$ new tokens have been generated. The number of tokens is updated and capped by the bucket capacity $B$:\n$$N_{\\text{tokens}} \\leftarrow \\min(B, N_{\\text{tokens}} + \\rho \\cdot (t - t_{\\text{last}}))$$\nAfter this update, we set $t_{\\text{last}} \\leftarrow t$ to mark the current arrival time as the new reference for the next update.\n\nThe first admission control filter is the throttle clause. A request can only be considered for admission if at least one token is available to be consumed.\n$$N_{\\text{tokens}} \\ge 1$$\nIf this condition is not met, the request is rejected (shed), and no further checks are performed for this request.\n\nIf sufficient tokens are available, the second filter, the hard deadline clause, is evaluated. For a FIFO system, a new request arriving at time $t$ can begin service no earlier than its arrival time $t$, and no earlier than the time the server becomes free, $T_{\\text{free}}$. Thus, the start time of service for this request, $T_{\\text{start}}$, will be:\n$$T_{\\text{start}} = \\max(t, T_{\\text{free}})$$\nGiven a deterministic service time $s$, the request will complete its execution at time $T_{\\text{finish}}$:\n$$T_{\\text{finish}} = T_{\\text{start}} + s = \\max(t, T_{\\text{free}}) + s$$\nThe hard deadline clause states that the response time for any admitted request must not exceed a duration $D$. The response time is the total duration from arrival to completion, $T_{\\text{finish}} - t$. The admission condition is therefore:\n$$T_{\\text{finish}} - t \\le D \\quad \\iff \\quad T_{\\text{finish}} \\le t + D$$\nSubstituting the expression for $T_{\\text{finish}}$, the check becomes:\n$$\\max(t, T_{\\text{free}}) + s \\le t + D$$\nIf this inequality holds, the request can meet its deadline. If it does not, the request is rejected to prevent a future SLA violation.\n\nA request is admitted if and only if it passes both the token availability check and the deadline check. Upon admission, the system state is updated as follows:\n1.  One token is consumed: $N_{\\text{tokens}} \\leftarrow N_{\\text{tokens}} - 1$.\n2.  The server is now committed to servicing this request, so its next free time is updated to the finish time of this request: $T_{\\text{free}} \\leftarrow T_{\\text{finish}}$.\n\nBy iterating through a time-ordered sequence of request arrivals and applying this logic for each, we can simulate the system's behavior and determine the total number of admitted requests. The simulation will be performed for each of the four test cases provided, using the specified parameters $(\\rho, B, s, D)$ and arrival time sequences. The final output is an integer count of admitted requests for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_admission_control(rho, B, s, D, arrivals):\n    \"\"\"\n    Simulates the admission control logic for a sequence of requests.\n\n    Args:\n        rho (float): Token generation rate (tokens/sec).\n        B (int): Token bucket capacity.\n        s (float): Deterministic service time (sec).\n        D (float): Hard deadline (sec).\n        arrivals (list[float]): A list of request arrival times.\n\n    Returns:\n        int: The total number of admitted requests.\n    \"\"\"\n    \n    # State variables initialization\n    # T_free: The time when the server becomes free.\n    # tokens: The current number of tokens in the bucket.\n    # t_last: The time of the last token update.\n    # admitted_count: The counter for admitted requests.\n    T_free = 0.0\n    tokens = float(B)\n    t_last = 0.0\n    admitted_count = 0\n    \n    # Process each request arrival in sequence.\n    # The arrivals list is assumed to be sorted by time.\n    for t_arrival in arrivals:\n        # Step 1: Update token count based on elapsed time.\n        # Tokens accrue continuously. The number of new tokens is rho * delta_t.\n        # The total is capped at the bucket capacity B.\n        time_elapsed = t_arrival - t_last\n        tokens = min(float(B), tokens + rho * time_elapsed)\n        t_last = t_arrival\n        \n        # Step 2: Check for token availability (Throttle Clause).\n        # A request requires one full token to be considered.\n        if tokens  1.0:\n            # Reject the request due to insufficient tokens.\n            continue\n            \n        # Step 3: Check deadline (Hard Deadline Clause).\n        # Calculate the predicted start and finish times.\n        # A request starts at max(arrival_time, server_free_time).\n        t_start = max(t_arrival, T_free)\n        t_finish = t_start + s\n        \n        # The request is rejected if its finish time exceeds the deadline.\n        # The deadline expires at arrival_time + D.\n        if t_finish > t_arrival + D:\n            # Reject the request due to a predicted deadline miss.\n            continue\n            \n        # Step 4: Admit the request.\n        # The request passed both admission control checks.\n        admitted_count += 1\n        \n        # Update state variables upon admission.\n        # Consume one token.\n        tokens -= 1.0\n        # The server will be busy until the request is finished.\n        T_free = t_finish\n        \n    return admitted_count\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the simulation for each, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case: (rho, B, s, D, arrivals)\n    test_cases = [\n        (\n            40.0, 8, 0.02, 0.10,\n            np.arange(0.00, 0.725 + 1e-9, 0.025).tolist()\n        ),\n        (\n            50.0, 5, 0.02, 0.05,\n            [k * (1.0/60.0) for k in range(60)]\n        ),\n        (\n            30.0, 10, 0.025, 0.08,\n            np.concatenate([\n                np.arange(0.00, 0.19 + 1e-9, 0.01),\n                np.arange(0.50, 0.69 + 1e-9, 0.01)\n            ]).tolist()\n        ),\n        (\n            60.0, 5, 0.015, 0.03,\n            np.arange(0.00, 0.99 + 1e-9, 0.01).tolist()\n        )\n    ]\n\n    results = []\n    for params in test_cases:\n        rho, B, s, D, arrivals = params\n        admitted_count = simulate_admission_control(rho, B, s, D, arrivals)\n        results.append(admitted_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}