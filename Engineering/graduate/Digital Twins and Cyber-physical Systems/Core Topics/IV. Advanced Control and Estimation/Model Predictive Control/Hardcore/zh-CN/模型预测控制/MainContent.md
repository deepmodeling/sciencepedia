## 引言
[模型预测控制](@entry_id:1128006)（MPC）是现代控制理论中的一种先进策略，以其系统性处理多变量、带约束动态系统的卓越能力而闻名。在日益复杂的信息物理系统中，从自动驾驶汽车到智能电网，控制器不仅需要优化性能，还必须严格遵守物理和安全约束，这正是传统控制方法面临的挑战。MPC通过将基于模型的预测、[滚动时域](@entry_id:181425)优化和反馈校正相结合，为解决这一核心问题提供了强大的框架。它不再依赖于一个固定的控制律，而是在线“思考”，为当前状态规划出一条最优的未来路径。

本文旨在为读者提供一份关于MPC的全面而深入的指南。我们将从构成其骨架的基础理论出发，逐步探索其在现实世界中的多样化应用和前沿拓展。在“原理与机制”一章中，您将学习MPC的核心工作流程——[滚动时域控制](@entry_id:270676)，如何构建预测模型，以及如何将控制问题转化为可求解的优化问题，并理解保证其稳定运行的理论基石。接下来，在“应用与交叉学科联系”一章中，我们将展示MPC如何通过技术[扩展适应](@entry_id:170834)实际挑战，并探讨其在经济优化、大规模网络系统以及过程控制、生物医学等多个领域的关键作用。最后，“动手实践”部分将通过具体的编程练习，将理论知识转化为解决实际问题的能力。通过这一结构化的学习路径，您将掌握MPC的精髓，并能够将其应用于自己的研究和工程实践中。

## 原理与机制

本章深入探讨构成[模型预测控制](@entry_id:1128006)（MPC）骨架的基本原理与核心机制。在前一章介绍其背景与应用之后，我们现在将系统地剖析MPC如何实现其控制目标。我们将从其根本的反馈机制——[滚动时域控制](@entry_id:270676)——开始，然后构建用于预测的数学模型，并阐述如何将控制问题转化为可求解的优化问题。最后，我们将详细讨论在实际应用中至关重要的两个主题：如何保证受约束系统的稳定性和可行性，以及如何设计能够应对扰动和不确定性的[鲁棒MPC](@entry_id:174393)。

### [滚动时域控制](@entry_id:270676)：MPC的核心原理

模型预测控制的别称——**[滚动时域控制](@entry_id:270676)**（Receding Horizon Control, RHC）——精辟地概括了其运作方式。在每个控制周期（或采样时刻）$k$，MPC控制器执行一个三步序列：

1.  **测量**：获取被控对象（plant）的当前状态 $x_k$。
2.  **优化**：基于当前状态 $x_k$ 和一个描述系统未来行为的内部**预测模型**，求解一个有限时间**[最优控制](@entry_id:138479)问题**（Optimal Control Problem, OCP）。这个问题的求解范围是一个从当前时刻 $k$ 延伸至未来 $k+N$ 的**[预测时域](@entry_id:261473)**（prediction horizon），其中 $N$ 是时域长度。优化器计算出一系列未来控制输入 $\{u_0^*, u_1^*, \dots, u_{N-1}^*\}$，该序列能在[预测时域](@entry_id:261473)内使一个预定义的**成本函数**（cost function）最小化，同时满足所有系统约束。
3.  **执行**：将计算出的最优控制序列的**第一个元素** $u_0^*$ 应用于被控对象，即令实际控制输入 $u_k = u_0^*$。然后，**丢弃**该序列的其余部分 $\{u_1^*, \dots, u_{N-1}^*\}$。

在下一个控制周期 $k+1$ 到来时，整个过程重复进行：控制器测量新的状态 $x_{k+1}$，并将[预测时域](@entry_id:261473)向前“滚动”一步，再次求解一个从 $k+1$ 到 $k+1+N$ 的全新优化问题。

一个核心问题是，为什么这种重复的开环优化过程会产生一个**闭环反馈**（closed-loop feedback）控制策略？答案在于“测量-再优化”的循环本身。尽管在每个时刻 $k$ 求解的OCP是一个开环问题（即控制序列是预先计算的，不依赖于时域内的状态测量），但最终施加的控制输入 $u_k = u_0^*$ 是以当前测量状态 $x_k$ 作为优化问题初始条件计算得出的。这意味着，最优解 $u_0^*$ 是初始状态 $x_k$ 的一个函数。因此，整个M[PC算法](@entry_id:753280)可以被视为一个隐式的[状态反馈控制器](@entry_id:203349)，其控制律 $u_k = \kappa(x_k)$ 是通过求解一个[参数化](@entry_id:265163)的优化问题来实时计算的。

正是这种反馈机制赋予了MPC应对扰动和模型失配的能力。当一个未预料到的扰动使系统在 $k+1$ 时刻的状态 $x_{k+1}$ 偏离了在 $k$ 时刻所预测的轨迹时，MPC不会盲目执行旧的计划。相反，它会利用新的测量值 $x_{k+1}$ 重新规划，生成一个适应当前实际情况的最优控制动作。这种持续的重新规划是MPC与纯粹[开环控制](@entry_id:262977)的根本区别。

### 线性系统的预测模型

MPC的核心能力源于其对系统未来行为的预测。为了实现这一点，控制器必须内嵌一个数学模型。对于离散时间**[线性时不变](@entry_id:276287)**（Linear Time-Invariant, LTI）系统，其动态特性由以下[状态空间方程](@entry_id:266994)描述：

$x_{k+1} = A x_k + B u_k$

其中，$x_k \in \mathbb{R}^n$ 是[状态向量](@entry_id:154607)，$u_k \in \mathbb{R}^m$ 是控制输入向量，$A \in \mathbb{R}^{n \times n}$ 和 $B \in \mathbb{R}^{n \times m}$ 是常数矩阵。

基于当前状态 $x_k$ 和一个未来的控制输入序列 $\{u_k, u_{k+1}, \dots\}$，我们可以通过递归替换来预测未来的状态。例如，未来一步的状态是 $x_{k+1} = A x_k + B u_k$。未来两步的状态则是：

$x_{k+2} = A x_{k+1} + B u_{k+1} = A(A x_k + B u_k) + B u_{k+1} = A^2 x_k + A B u_k + B u_{k+1}$

通过[数学归纳法](@entry_id:138544)，我们可以推导出未来任意第 $i$ 步的状态 $x_{k+i}$ 的通用表达式 ：

$x_{k+i} = A^i x_k + \sum_{j=0}^{i-1} A^{i-1-j} B u_{k+j}$

这个公式是MPC预测的基础。它明确地将未来[状态表示](@entry_id:141201)为当前状态 $x_k$ （一个已知参数）和未来控制序列 $\{u_{k}, u_{k+1}, \dots, u_{k+i-1}\}$ （优化变量）的线性函数。

为了将整个[预测时域](@entry_id:261473)内的动态约束整合进优化问题，一种强大而标准的技术是构建一个所谓的**[提升模型](@entry_id:909156)**（lifted model）或**堆叠模型**（stacked model）。我们将整个[预测时域](@entry_id:261473)内的状态和输入分别堆叠成两个大的列向量：

$X = \begin{bmatrix} x_{k+1} \\ x_{k+2} \\ \vdots \\ x_{k+N} \end{bmatrix} \in \mathbb{R}^{Nn}, \quad U = \begin{bmatrix} u_{k} \\ u_{k+1} \\ \vdots \\ u_{k+N-1} \end{bmatrix} \in \mathbb{R}^{Nm}$

利用上述的 $i$ 步预测公式，我们可以将堆叠的状态向量 $X$ 写成一个关于当前状态 $x_k$ 和堆叠输入向量 $U$ 的单一线性方程 ：

$X = S_x x_k + S_u U$

其中，预测矩阵 $S_x$ 和 $S_u$ 的结构完全由[系统矩阵](@entry_id:172230) $A$ 和 $B$ 以及[预测时域](@entry_id:261473) $N$ 决定：

$S_x = \begin{bmatrix} A \\ A^2 \\ \vdots \\ A^N \end{bmatrix}, \quad S_u = \begin{bmatrix} B  0  \cdots  0 \\ AB  B  \cdots  0 \\ \vdots  \vdots  \ddots  \vdots \\ A^{N-1}B  A^{N-2}B  \cdots  B \end{bmatrix}$

矩阵 $S_x \in \mathbb{R}^{Nn \times n}$ 捕捉了初始状态 $x_k$ 对未来所有状态的“自由响应”影响。矩阵 $S_u \in \mathbb{R}^{Nn \times Nm}$ 是一个下三角的分块**托普利兹矩阵**（Toeplitz matrix），它捕捉了未来控制输入对状态轨迹的“强制响应”影响。这种形式将一个动态的、序贯的预测问题，转化为了一个静态的代数关系，为将OCP表述为标准优化问题铺平了道路。

### 优化问题：从成本函数到二次规划

MPC的第二个核心组成部分是[在线优化](@entry_id:636729)。对于[LTI系统](@entry_id:271946)，一个常见且极其有效的成本函数是二次形式，它旨在惩罚状态与期望参考值 $r_i$ 的偏差以及控制输入与[期望值](@entry_id:150961) $v_i$ 的偏差（或者输入本身的大小）。一个典型的**二次成本函数** $J$ 定义为：

$J = \sum_{i=0}^{N-1} (x_{k+i}^\top Q x_{k+i} + u_{k+i}^\top R u_{k+i} + 2x_{k+i}^\top S u_{k+i}) + x_{k+N}^\top P x_{k+N}$

这里，$Q, R, P$ 是对称的**权重矩阵**，它们决定了对状态误差、控制能量和终端状态误差的惩罚程度。矩阵 $S$ 用于惩罚状态和输入的交叉项。

利用上一节推导的[提升模型](@entry_id:909156)，我们可以将这个涉及序贯状态和输入的成本函数，完全重写为仅关于优化变量——堆叠输入向量 $U$ ——的函数。这个过程称为**问题凝聚**（condensation）。通过将 $X = S_x x_k + S_u U$（以及 $x_k$ 的类似表达式）代入成本函数 $J$ 并进行代数展开，我们可以将 $J$ 表示为标准的二次型 ：

$J(U) = \frac{1}{2} U^\top H U + f^\top U + c$

在这个表达式中：
*   **Hessian矩阵** $H$ 是一个[对称矩阵](@entry_id:143130)，它捕捉了成本函数关于 $U$ 的曲率。
*   **线性项向量** $f$ 是一个列向量，其系数依赖于当前状态 $x_k$ 和参考轨迹。
*   **常数项** $c$ 包含了所有不依赖于 $U$ 的项。

这些项的具体表达式可以通过[矩阵代数](@entry_id:153824)导出。例如，对于一个包含状态、输入和终端成本的跟踪问题，Hessian矩阵 $H$ 和线性项 $f$ 通常具有如下形式 ：
$H = 2(S_u^\top \bar{Q} S_u + \bar{R})$
$f = 2(S_u^\top \bar{Q} (S_x x_k - \bar{r}) - \bar{R} \bar{v})$
其中 $\bar{Q}$ 和 $\bar{R}$ 是沿[预测时域](@entry_id:261473)堆叠的权重矩阵，$\bar{r}$ 和 $\bar{v}$ 是堆叠的参考轨迹向量。

如果系统的状态和输入受到[线性约束](@entry_id:636966)（例如 $E_x x_i + E_u u_i \le e$），这些约束也可以通过[提升模型](@entry_id:909156)转化为关于 $U$ 的[线性不等式](@entry_id:174297)：$A_{\text{ineq}} U \le b_{\text{ineq}}$。

因此，整个MPC优化问题被转化成了一个**二次规划**（Quadratic Programming, QP）问题：在一个由线性等式和不等式定义的多胞体可行域上，最小化一个二次函数。

为了保证Q[P问题](@entry_id:267898)能够被高效且可靠地求解，得到唯一的全局最优解，该问题必须是**凸**的。由于[线性约束](@entry_id:636966)定义的可行域总是凸的，所以问题的凸性完全取决于目标函数 $J(U)$ 是否为[凸函数](@entry_id:143075)。对于二次函数，这等价于其Hessian矩阵 $H$ 是**半正定**的 ($H \succeq 0$)。

$H$ 的[半正定性](@entry_id:147720)又取决于原始成本函数中的权重矩阵。具体而言，为保证凸性，总成本必须是状态和输入轨迹的[凸函数](@entry_id:143075)。这要求每个阶段成本和终端成本都是凸的，即：
1.  终端[成本矩阵](@entry_id:634848) $P$ 必须是半正定的 ($P \succeq 0$)。
2.  每个阶段成本的Hessian矩阵 $\begin{pmatrix} Q  S \\ S^\top  R \end{pmatrix}$ 必须是半正定的。

使用**[舒尔补](@entry_id:142780)**(Schur complement)引理，后一个条件的一个常见且易于验证的充分条件是 $R$ 为**正定** ($R \succ 0$) 且 $Q - S R^{-1} S^\top$ 为半正定 ($Q - S R^{-1} S^\top \succeq 0$)。 如果这些条件得到满足，MPC问题就简化为一个凸QP，可以通过成熟的[数值算法](@entry_id:752770)在毫秒级时间内求解，从而使其适用于实时控制应用。

### 保证稳定性与可行性：[终端约束](@entry_id:176488)与终端成本

对于受[约束系统](@entry_id:164587)，仅使用有限[预测时域](@entry_id:261473)的一个潜在危险是**短视行为**。控制器可能会为了在短期内获得良好性能而将系统引向一个危险的境地，导致未来输入饱和或违反状态约束，甚至引发不稳定。为了解决这个问题，现代MPC理论引入了**终端成本**（terminal cost）和**[终端约束](@entry_id:176488)**（terminal constraint）的概念。

标准的稳定MPC方案在优化问题中加入了两个关键要素：
1.  **终端成本** $V_f(x_{k+N})$：在[预测时域](@entry_id:261473)末端对状态 $x_{k+N}$ 施加的惩罚。
2.  **[终端约束](@entry_id:176488)集** $\mathcal{X}_f$：要求预测的终端状态必须位于一个特定的集合内，$x_{k+N} \in \mathcal{X}_f$。

这两个元素协同工作，为MPC系统提供了两个至关重要的保证：**[递归可行性](@entry_id:167169)**和**[闭环稳定性](@entry_id:265949)**。

为了理解其原理，我们首先需要区分两种集合[不变性](@entry_id:140168)的概念 ：
*   **受控不变集** (Controlled Invariant Set)：对于集合 $\mathcal{S}$ 中的任意状态 $x$，**存在**一个容许的控制输入 $u \in \mathcal{U}$，使得下一时刻的状态 $f(x, u)$ 仍在 $\mathcal{S}$ 内。这个概念是存在性的。
*   **正不变集** (Positively Invariant Set)：对于一个给定的、固定的控制律 $u=\kappa(x)$，对于集合 $\mathcal{X}_f$ 中的任意状态 $x$，应用该控制律后的下一时刻状态 $f(x, \kappa(x))$ **必定**仍在 $\mathcal{X}_f$ 内。这个概念是全称性的，与特定的控制律绑定。

在稳定MPC的设计中，我们通常使用正[不变集](@entry_id:275226)。其工作原理如下：

**1. 保证[递归可行性](@entry_id:167169)**
[递归可行性](@entry_id:167169)意味着如果MPC问题在时刻 $k$ 有解，那么在未来的所有时刻 $k'>k$ 也必然有解。这是控制器能够长期运行的基本前提。[终端约束](@entry_id:176488)和[终端集](@entry_id:163892)通过一个巧妙的构造论证来保证这一点。假设在时刻 $k$，我们找到了一个最优解，其预测的终端状态为 $x_{k+N|k}^* \in \mathcal{X}_f$。我们选择 $\mathcal{X}_f$ 是一个在某个预先设计的**终端控制器** $u=\kappa(x)$ 下的正不变集，并且在该集合内，控制器满足所有输入和状态约束。

在下一个时刻 $k+1$，我们需要证明优化问题至少有一个[可行解](@entry_id:634783)。我们可以构造这样一个[可行解](@entry_id:634783)：使用上一时刻最优序列的“尾巴” $\{u_{k+1|k}^*, \dots, u_{k+N-1|k}^*\}$ 作为新序列的前 $N-1$ 个输入，并以终端控制器在旧的终端状态处的值 $\kappa(x_{k+N|k}^*)$ 作为最后一个输入。由于 $\mathcal{X}_f$ 的正[不变性](@entry_id:140168)，新的终端状态 $A x_{k+N|k}^* + B \kappa(x_{k+N|k}^*)$ 必定仍在 $\mathcal{X}_f$ 内，并且所有中间的约束也都满足。这就证明了在 $k+1$ 时刻，可行集非空，因此MPC问题始终可解。

**2. 保证[渐近稳定性](@entry_id:149743)**
[渐近稳定性](@entry_id:149743)意味着系统状态最终会收敛到平衡点（通常是原点）。这通过将MPC的最优成本函数 $J_N^*(x)$ 视为系统的**[李雅普诺夫函数](@entry_id:273986)**（Lyapunov function）来证明。终端成本 $V_f(x)$ 和[终端集](@entry_id:163892) $\mathcal{X}_f$ 的设计必须确保 $J_N^*(x)$ 满足[李雅普诺夫函数](@entry_id:273986)的条件，即 $J_N^*(x)$ 是正定的，并且沿闭环轨迹递减。

通过与可行性证明类似的论证，可以证明，如果终端成本 $V_f(x)$ 和终端控制器 $\kappa(x)$ 满足一个关键的**李雅普诺夫递减条件**，即在[终端集](@entry_id:163892) $\mathcal{X}_f$ 内，应用终端控制器所引起的终端成本的减小量大于或等于一个阶段成本，即：
$V_f(A x + B \kappa(x)) - V_f(x) \le -\ell(x, \kappa(x)), \quad \forall x \in \mathcal{X}_f$
那么，整个MPC的最优成本函数将沿闭环轨迹严格递减：$J_N^*(x_{k+1}) - J_N^*(x_k) \le -\ell(x_k, u_k^*)$。这证明了系统的[渐近稳定性](@entry_id:149743)。

**系统化设计：LQR作为终端控制器**
一个系统化的、广受欢迎的设计方法是使用**[线性二次调节器](@entry_id:267871)**（LQR）作为终端控制器。具体步骤如下 ：
1.  为无约束[LTI系统](@entry_id:271946)设计一个[LQR控制器](@entry_id:267871) $u=Kx$。LQR的增益 $K$ 和相关的[成本矩阵](@entry_id:634848) $P$ 来自于求解**[离散代数Riccati方程](@entry_id:168652)**（DARE）。
2.  选择终端控制器为该[LQR控制器](@entry_id:267871)，即 $\kappa(x) = Kx$。
3.  选择终端成本为LQR的成本函数，即 $V_f(x) = x^\top P x$。

这种选择的精妙之处在于，DARE的解 $P$ 天然地满足了李雅普诺夫递减条件（并且是等式）：
$x^\top P x = (Ax+BKx)^\top P (Ax+BKx) + x^\top Q x + (Kx)^\top R (Kx)$
这等价于 $V_f((A+BK)x) - V_f(x) = -\ell(x, Kx)$。

此外，对于无[约束系统](@entry_id:164587)，若终端成本选择为DARE解 $P$，则有限时域MPC的解与无限时域LQR的解完全相同，无论[预测时域](@entry_id:261473) $N$ 多大（只要 $N \ge 1$）。这为MPC和经典[最优控制理论](@entry_id:139992)建立了深刻的联系。

完成此设计后，剩下的挑战就是计算一个满足约束 $x \in \mathcal{X}, Kx \in \mathcal{U}$ 的、在 $u=Kx$ 下的正不变集 $\mathcal{X}_f$。这通常是一个小的、包含原点的[多胞体](@entry_id:635589)。

### [鲁棒模型预测控制](@entry_id:174393)原理

前面的讨论都基于一个完美的、无扰动的预测模型。然而，在现实世界的赛博物理系统中，外部扰动和模型不确定性是普遍存在的。标准的MPC在这种情况下不提供任何性能或安全保证。**[鲁棒模型预测控制](@entry_id:174393)**（Robust MPC）旨在解决这一问题。

**[管MPC](@entry_id:178751)**（Tube-based MPC）是一种主流的[鲁棒MPC](@entry_id:174393)方法。其核心思想是将受扰动的实际状态轨迹 $x_k$ 约束在一个围绕着一个可计算的标称状态轨迹 $\bar{x}_k$ 的“管道”（tube）内。

该方法通过将系统状态分解为两部分来实现 ：
$x_k = \bar{x}_k + e_k$
其中，$\bar{x}_k$ 是**标称状态**，遵循一个无扰动的理想模型；$e_k$ 是**误差状态**，捕捉了实际状态与标称状态之间的偏差。

控制输入也被分解。一个精心设计的**辅助反馈控制器**（ancillary controller）$K$ 用于稳定误差动态，而MPC优化器则在线计算标称控制输入 $\bar{u}_k$。总的控制输入为：
$u_k = \bar{u}_k + K(x_k - \bar{x}_k) = \bar{u}_k + K e_k$

将这个分解代入受扰动的系统动态 $x_{k+1} = A x_k + B u_k + w_k$（其中 $w_k$ 是有界扰动），我们可以得到分离的动态方程：
*   **标称动态**：$\bar{x}_{k+1} = A \bar{x}_k + B \bar{u}_k$
*   **误差动态**：$e_{k+1} = (A+BK)e_k + w_k$

MPC控制器在线上只处理无扰动的标称系统。辅助控制器 $K$ 的作用是抑制扰动对误差的影响，通常选择 $K$ 使得闭环矩阵 $(A+BK)$ 是稳定的（Schur稳定）。

由于扰动 $w_k$ 的存在，误差 $e_k$ 永远不会精确地为零。然而，由于误差动态是稳定的且扰动有界，误差将被限制在一个[紧集](@entry_id:147575)内。这个集合被称为**[鲁棒正不变集](@entry_id:1131086)**（Robust Positive Invariant, RPI set），记为 $\mathcal{Z}$。RPI集的性质是：如果当前误差 $e_k \in \mathcal{Z}$，那么对于任何可能的扰动 $w_k \in \mathcal{W}$，下一个误差 $e_{k+1}$ 也将位于 $\mathcal{Z}$ 内。

为了确保**实际**状态 $x_k$ 和输入 $u_k$ 始终满足原始约束 $x_k \in \mathcal{X}$ 和 $u_k \in \mathcal{U}$，我们必须对**标称**系统施加更严格的**约束收紧**（constraint tightening）。具体来说，标称状态和输入必须满足 ：

$\bar{x}_k \in \mathcal{X} \ominus \mathcal{Z}$
$\bar{u}_k \in \mathcal{U} \ominus K\mathcal{Z}$

这里的 $\ominus$ 符号代表**庞特里亚金集差**（Pontryagin difference），定义为 $\mathcal{A} \ominus \mathcal{B} = \{a \mid a+b \in \mathcal{A}, \forall b \in \mathcal{B}\}$。这个操作的直观含义是，将原始约束集向内“收缩”，收缩的“厚度”正好等于误差可能达到的范围（$\mathcal{Z}$ for state, $K\mathcal{Z}$ for input）。通过让标称轨迹遵守这些收紧的约束，我们可以保证即使在最坏的误差情况下，实际轨迹 $x_k = \bar{x}_k + e_k$ 和 $u_k = \bar{u}_k + K e_k$ 也不会违反原始的 $\mathcal{X}$ 和 $\mathcal{U}$ 约束。

综上所述，[管MPC](@entry_id:178751)将复杂的[鲁棒控制](@entry_id:260994)问题分解为两部分：一个离线设计的辅助控制器 $K$ 和RPI集 $\mathcal{Z}$，用于处理扰动；以及一个在线运行的、针对标称系统的标准MPC，但其作用于收紧的约束集上。这种方法在保持[计算效率](@entry_id:270255)的同时，为受扰动系统提供了严格的可行性和安全性保证。