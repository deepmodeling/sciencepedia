## 引言
在数字孪生和网络物理系统 (Cyber-Physical Systems, CPS) 的宏伟蓝图中，物理世界与数字世界的无缝融合带来了前所未有的机遇，但同时也暴露了一个根本性的安全挑战：如何确保我们所依赖的物理设备本身是可信的？如果作为感知和控制源头的嵌入式设备被攻破，其[数字孪生](@entry_id:171650)也将建立在虚假或被篡改的数据之上，导致错误的决策，甚至引发灾难性后果。因此，建立从硬件层面开始的信任链，即实现[可信启动](@entry_id:751820) (Trusted Boot)，已成为构建安全、可靠系统的基石。

本文旨在系统性地解决这一核心问题，为读者提供一套关于嵌入式设备安全与[可信启动](@entry_id:751820)的完整知识框架。我们将从最底层的[硬件信任根](@entry_id:1125916)出发，逐步揭示信任是如何通过[密码学](@entry_id:139166)机制在引导过程中建立并传递的。读者将不仅理解“是什么”，更会明白“为什么”和“怎么做”。

为实现这一目标，本文分为三个核心部分：
*   **第一章：原理与机制** 将深入剖析信任链、安全引导、可信引导、[远程证明](@entry_id:754241)等核心概念，以及支撑这些机制的硬件（如 TPM、[IOMMU](@entry_id:750812)）和密码学原语。
*   **第二章：应用与跨学科连接** 将展示这些原理如何在工业控制、汽车、医疗设备和[数字孪生](@entry_id:171650)等真实场景中应用，并探讨其与[软件供应链安全](@entry_id:755014)、[机密计算](@entry_id:747674)等领域的交叉。
*   **第三章：动手实践** 将通过具体编程和分析练习，让读者亲手体验和量化[可信启动](@entry_id:751820)中的关键操作与安全风险。

通过本文的学习，您将掌握构建可信嵌入式系统的基础知识，为设计下一代安全的数字孪生和 CPS 应用打下坚实的基础。让我们从信任的源头——[硬件信任根](@entry_id:1125916)开始，踏上这段探索之旅。

## 原理与机制

在网络物理系统 (Cyber-Physical System, CPS) 和[数字孪生](@entry_id:171650) (Digital Twin) 的语境下，确保嵌入式设备的完整性和可信度是整个系统安全与可靠的基石。物理设备是数字孪生感知和控制的源头，如果设备本身被攻破，那么所有上层应用（包括其数字孪生）都将建立在虚假或恶意的数据之上。本章深入探讨了实现嵌入式设备[安全启动](@entry_id:754616)和运行的核心原理与机制，为构建可信的 CPS 奠定理论基础。

### 信任的基础：[硬件信任根](@entry_id:1125916)与[信任链](@entry_id:747264)

系统中的信任并非凭空产生，它必须源于一个无可置疑的起点。这个起点被称为**[硬件信任根](@entry_id:1125916) (Hardware Root of Trust, RoT)**。RoT 是指设备中一组最小化的、在制造后不可更改的硬件组件，它们通过内置的、不可迁移的机密（如密钥）或信任锚（如公钥），为系统提供最初的信任基础。一个典型的 RoT 实例包括处理器在重置时执行的**引导[只读存储器](@entry_id:175074) (Boot ROM)** 以及存储在一次性可编程熔丝 (eFuses) 中的不可变公钥 。其核心特征是**不变性 (Immutability)** 和**最小化 (Minimality)**。[不变性](@entry_id:140168)确保了信任的根基不会被恶意篡改；最小化则减少了需要无条件信任的组件数量，从而缩小了初始的攻击面。

有了信任的根基，系统通过**信任链 (Chain of Trust)** 的方式，将信任从 RoT 逐步传递到后续的软件层。信任链是一个连续的验证过程，其中每一个已获信任的阶段（称为信任的传递者），负责对下一个待加载的阶段（信任的接收者）进行[密码学](@entry_id:139166)验证，确认其完整性和真实性后，才将[执行控制](@entry_id:896024)权移交给它。这个过程被称为**验证执行 (Verified Execution)**。例如，在多阶段引导过程中，不可变的第 0 阶段 ($S_0$) 验证第一阶段[引导加载程序](@entry_id:746922) ($S_1$)，通过验证的 $S_1$ 再去验证第二阶段引导加载程序 ($S_2$)，以此类推。只要信任链中的任何一个环节验证失败，引导过程就会被中止，从而阻止恶意或损坏的软件运行 。

### 核心引导机制：安全引导与可信引导

建立[信任链](@entry_id:747264)主要通过两种核心机制实现：安全引导和可信引导（或称度量引导）。它们的目标不同，提供了互补的安全保障。

#### 安全引导 (Secure Boot)：强制执行策略

**安全引导**的核心目标是**强制执行 (Enforcement)**。它确保只有经过授权和验证的软件才能在设备上运行。在引导过程的每个阶段，[引导加载程序](@entry_id:746922)都会使用预置的公钥来验证下一阶段软件的[数字签名](@entry_id:269311)。形式上，对于待加载的软件镜像 $m$ 及其签名 $\sigma$，只有当验证函数 $\mathrm{Verify}_{pk}(H(m), \sigma)$ 返回值为真（即 $1$）时，系统才会加载并执行 $m$。这里的 $H$ 是一个[密码学哈希函数](@entry_id:274006)，$pk$ 是验证公钥。如果验证失败，引导过程将立即停止。这种机制有效地阻止了未经授权的固件、恶意软件或被篡改的软件在设备启动时获得控制权，从而保护设备免受持久化攻击 。

#### 可信引导 (Measured Boot)：记录与证明

与安全引导不同，**可信引导**（或称度量引导）的核心目标是**记录 (Recording)** 和**证明 (Attestation)**。它不一定阻止未授权软件的执行，而是忠实地记录下[系统启动过程](@entry_id:755769)中加载的每一个软件组件的“指纹”。这个“指纹”通常是软件组件的[密码学哈希](@entry_id:1123262)值。

该机制通常依赖于一个称为**[可信平台模块](@entry_id:756204) (Trusted Platform Module, [TPM](@entry_id:170576))** 的专用安全硬件。[TPM](@entry_id:170576) 内部包含一组特殊的寄存器，称为**平台配置寄存器 (Platform Configuration Registers, PCRs)**。在加载每个软件组件 $m$ 之前，[引导加载程序](@entry_id:746922)会计算其哈希值 $H(m)$，并请求 TPM 使用此哈希值来“扩展”(extend) 某个 PCR。扩展操作是单向的，其定义为：$PCR \leftarrow H(PCR_{\text{current}} \parallel H(m))$，其中 $\parallel$ 表示串联。这意味着 PCR 的新值取决于其旧值和新测量的哈希值。由于[哈希函数](@entry_id:636237)的单向性，攻击者无法伪造或回滚 PCR 的值来掩盖其恶意行为。最终，PCRs 中存储的是整个引导链的累积性[密码学](@entry_id:139166)摘要 。

可信引导的价值在于为**[远程证明](@entry_id:754241) (Remote Attestation)** 提供依据。设备可以向远程验证方（如[数字孪生](@entry_id:171650)）证明其当前的软件状态。这个过程我们将在后续章节详细讨论。

### 信任建立的架构

根据[信任链](@entry_id:747264)建立的时间和方式，可以区分两种主要的[信任根](@entry_id:754420)架构：静态[信任根](@entry_id:754420)和动态[信任根](@entry_id:754420)。

#### 静态可信度量根 (Static Root of Trust for Measurement, SRTM)

SRTM 是最经典的信任模型，它的信任锚点固定在**系统重置 (system reset)** 事件上。当设备上电或重置时，处理器从一个固定的、不可更改的地址开始执行，通常是片上 Boot ROM 中的代码。这个 Boot ROM 及其依赖的不可变数据（如存储在 eFuses 中的公钥）共同构成了 SRTM。整个信任链从这个静态的时间点开始，依次验证和度量后续的[引导加载程序](@entry_id:746922)和操作系统。在 SRTM 模型中，信任边界在系统启动之初就已确立，并且贯穿整个引导过程 。

#### 动态可信度量根 (Dynamic Root of Trust for Measurement, DRTM)

与 SRTM 不同，**动态可信度量根 (DRTM)** 允许系统在运行时的任意时刻，通过一个称为**延迟启动 (late-launch)** 的特殊指令，创建一个全新的、与之前软件状态无关的信任环境。当执行 DRTM 指令时，硬件会[原子性](@entry_id:746561)地执行一系列操作：将指定的 PCRs 重置为一个已知的初始值，然后加载并度量一个极小的、受信任的加载程序（称为安全加载器）。这个过程创建了一个新的信任边界，其可信度不依赖于系统此前的引导过程是否安全。DRTM 的价值在于，即使操作系统或[虚拟机](@entry_id:756518)管理器已被攻破，系统仍然能够启动一个隔离的[可信执行环境](@entry_id:756203)，用于处理敏感任务或进行可靠的[远程证明](@entry_id:754241) 。

#### 信任度量语义的演进：TPM 与 [DIC](@entry_id:171176)E

除了基于 [TPM](@entry_id:170576)/PCR 的传统度量模型，业界还发展出了**设备标识符组合引擎 (Device Identifier Composition Engine, DICE)** 架构，它为轻量级嵌入式设备提供了另一种信任度量和身份证明的语义。

- **[TPM](@entry_id:170576)/PCR 模型**：如前所述，它通过 PCR 的扩展操作创建了一个**对顺序敏感的累积日志**。验证方需要获取 PCR 值和一份详细的事件日志，然后重放日志中的度量过程，以验证最终的 PCR 值是否匹配。其本质是记录“启动了什么”。

- **DICE/CDI 模型**：[DIC](@entry_id:171176)E 的核心思想是**分层派生加密身份**。它从一个设备唯一的秘密（Unique Device Secret, UDS）开始。每一层软件加载时，[DIC](@entry_id:171176)E 硬件引擎会结合上一层的身份密钥（称为复合设备标识符, Compound Device Identifier, CDI）和当前层软件的哈希值，派生出当前层的新 CDI。形式上，$c_{i+1} = H(c_i \parallel h_{i+1})$，其中 $c_i$ 是第 $i$ 层的 CDI，$h_{i+1}$ 是第 $i+1$ 层代码的哈希。每一层的 CDI 都可以通过密钥派生函数 (KDF) 生成该层专属的密钥对，包括用于证明的非对称密钥。因此，DICE 架构生成的不是一个度量日志，而是一系列与固件状态绑定的**加密身份**。其本质是证明“我是什么” 。

### 关键密码学原语及其[安全保证](@entry_id:1131169)

可信引导的安全性依赖于底层密码学原语的强度。理解这些原语提供的具体保证至关重要。

#### 数字签名与消息认证码 (MAC)

在[信任链](@entry_id:747264)中，验证完整性和真实性的工具主要是数字签名和消息认证码。

- **数字签名**：使用非对称加密（公钥/私钥对）。由私钥持有者（如设备制造商）对软件进行签名。任何人持有公钥都可以验证签名的有效性。它不仅能保证**完整性**（软件未被篡改），还能提供**真实性 (Authenticity)** 和**不可否认性**（证明软件确实来源于私钥持有者）。这对于需要公开验证来源的场景至关重要，例如 Boot ROM 验证由厂商签名的第一阶段[引导加载程序](@entry_id:746922) 。

- **消息认证码 (MAC)**：使用对称密钥。只有知道该密钥的双方（发送者和接收者）才能生成和验证 MAC。它能提供**完整性**和**来源认证**（证明消息来源于[共享密钥](@entry_id:261464)的另一方），但无法向不知道密钥的第三方证明来源。例如，在一个设备内部，如果[信任链](@entry_id:747264)的前一阶段已经通过签名验证，那么它可以使用一个仅设备自身知晓的密钥（例如从**[物理不可克隆函数](@entry_id:753421) (Physically Unclonable Function, PUF)** 派生的密钥）来验证下一阶段，这比非对称签名验证更高效 。

#### [哈希函数](@entry_id:636237)的安全性属性

[哈希函数](@entry_id:636237)是可信引导的基石。其安全性依赖于三个核心属性：

1.  **抗[原像](@entry_id:150899)攻击 (Preimage Resistance)**：给定一个哈希值 $y$，在计算上不可行找到任何输入 $x$ 使得 $H(x) = y$。
2.  **抗第二[原像](@entry_id:150899)攻击 (Second-Preimage Resistance)**：给定一个输入 $x$，在计算上不可行找到另一个不同的输入 $x' \neq x$ 使得 $H(x') = H(x)$。
3.  **抗碰撞攻击 (Collision Resistance)**：在计算上不可行找到任意两个不同的输入 $x_1, x_2$ 使得 $H(x_1) = H(x_2)$。

在可信引导的应用场景中，这三个属性的重要性有所不同。假设攻击者的目标是用恶意固件 $m'$ 替换合法的、厂商签名的固件 $m_0$。系统的安全检查是比较当前固件的哈希 $H(m)$ 是否等于一个受信任的参考哈希值 $H(m_0)$。攻击者要成功，就必须找到一个 $m' \neq m_0$，使得 $H(m') = H(m_0)$。

这个攻击场景精确地对应于**第二[原像](@entry_id:150899)攻击**。攻击者并非寻找任意一对碰撞，而是针对一个**特定**的、已知的合法固件 $m_0$ 来寻找碰撞。因此，在实践中，可信引导的完整性保护更直接地依赖于[哈希函数](@entry_id:636237)的**抗第二[原像](@entry_id:150899)攻击**能力 。虽然[抗碰撞性](@entry_id:637794)是一个更强的属性（能抵抗碰撞攻击的[哈希函数](@entry_id:636237)也一定能抵抗第二[原像](@entry_id:150899)攻击），但准确理解威胁模型有助于我们精确评估安全需求。

### 在引导时强制执行安全策略

除了验证软件的完整性和真实性，可信引导过程也是强制执行关键安全策略的理想时机。

#### 反回滚保护 (Anti-Rollback Protection)

一个常见的攻击是**回滚攻击 (Downgrade Attack)**。攻击者将设备固件替换为一个旧的、但经过合法签名的版本。这个旧版本可能存在已知的、后来被修复的安全漏洞。由于签名仍然有效，单纯的安全引导检查会通过，从而使设备重新暴露在已知的风险之下。

为了防止此类攻击，必须引入**反回滚保护**机制。这通常通过一个**单调计数器 (Monotonic Counter)** 实现。单调计数器是一个只能增加、不能减少的数值，它被安全地存储在硬件中（如 [TPM](@entry_id:170576) 的非易失性存储区或 eFuses）。固件的[元数据](@entry_id:275500)中包含一个版本号 $v$。引导时的安全策略扩展为：

1.  验证固件签名是否有效。
2.  检查固件版本号 $v$ 是否不小于当前硬件单调计数器的值 $c_t$，即 $v \ge c_t$。

只有当两个条件都满足时，引导才会继续。成功引导后，系统会用新的版本号 $v$ 更新单调计数器 $c_{t+1} \leftarrow v$。这样，任何试图安装版本号低于当前记录值的固件（即使签名有效）的尝试都将被阻止  。

### 硬件隔离在引导防御中的作用

密码学检查并非万能。如果攻击者能够在物理层面绕过或破坏这些检查，[信任链](@entry_id:747264)就会被打破。一个典型的威胁发生在固件验证之后、执行之前。

#### [TOCTOU](@entry_id:756027) 攻击与 DMA 威胁

一个关键的漏洞窗口是**[检查时-使用时](@entry_id:756030) (Time-of-Check-to-Time-of-Use, [TOCTOU](@entry_id:756027))** 漏洞。在引导过程中，Boot ROM 在 $t_{\text{verify}}$ 时刻验证了固件的完整性，并将其加载到内存区域 $\mathcal{R}$。然而，在 $t_{\text{exec}}$ 时刻处理器跳转到 $\mathcal{R}$ 开始执行之前，存在一个短暂的时间窗口。如果攻击者能在此窗口内篡改内存区域 $\mathcal{R}$ 的内容，那么处理器最终执行的将是被篡改过的恶意代码。

一个强大的攻击向量是利用能够进行**直接内存访问 (Direct Memory Access, DMA)** 的外围设备。例如，一个被攻破的网卡或存储控制器，作为**总线主控 (bus master)**，可以直接读写系统物理内存，而无需经过 CPU。这样的设备可以被用来在 [TOCTOU](@entry_id:756027) 窗口期间向代码区 $\mathcal{R}$ 写入恶意负载，从而完全绕过此前的签名验证 。

#### [内存保护](@entry_id:751877)硬件的角色

为了防御此类物理层攻击，现代 SoC 提供了多种硬件隔离机制：

- **[内存管理单元 (MMU)](@entry_id:751869) / [内存保护单元](@entry_id:751878) (MPU)**：这些是 **CPU 核心内部**的组件，负责管理和保护 CPU 自身的内存访问。MPU 为 CPU 访问的物理内存区域设置权限（读/写/执行），而 MMU 则在虚拟地址和物理地址之间进行转换，并提供更细粒度的页级权限控制。然而，MMU/MPU **只能约束 CPU**，对来自其他总线主控（如 DMA 控制器）的访问无能为力。

- **[输入/输出内存管理单元](@entry_id:750812) ([IOMMU](@entry_id:750812))**：这是防御 DMA 攻击的**关键组件**。[IOMMU](@entry_id:750812) 位于 I/O 总线和[主存](@entry_id:751652)之间，其作用是拦截并管理所有来自外围设备的 DMA 请求。它可以将设备可见的地址（所谓的 "IOVA"）转换为[主存](@entry_id:751652)的物理地址，并像 CPU 的 MMU 一样，强制执行权限检查。

为了有效关闭 [TOCTOU](@entry_id:756027) 漏洞，Boot ROM 必须在将已验证的固件加载到内存**之前**，就配置好 [IOMMU](@entry_id:750812)。正确的防御顺序是：
1.  Boot ROM 启动，并保持所有具有 DMA 能力的外设处于重置或禁用状态。
2.  配置 [IOMMU](@entry_id:750812)（或类似的 DMA 防火墙），为代码区 $\mathcal{R}$ 设置严格的“禁止写入”策略，只允许外设向预先批准的[数据缓冲](@entry_id:173397)区进行 DMA。
3.  加载并验证固件到内存区域 $\mathcal{R}$。
4.  通过 MPU/MMU 将区域 $\mathcal{R}$ 对 CPU 设置为“只读、可执行”。
5.  将控制权移交给新加载的固件。

通过这种方式，[IOMMU](@entry_id:750812) 在物理层面阻止了任何外设对代码区的非法篡改，从而确保了从检查到执行的完整性 。

### 应用：为[数字孪生](@entry_id:171650)同步提供[远程证明](@entry_id:754241)

可信引导建立的信任基础，最终服务于上层应用。在 CPS 与数字孪生的场景中，最重要的应用之一就是**[远程证明](@entry_id:754241) (Remote Attestation, RA)**。

RA 是一个协议，通过它，一个实体（**证明方 (Attester)**，即嵌入式设备）可以向另一个远程实体（**验证方 (Verifier)**，即[数字孪生](@entry_id:171650)）提供其当前内部状态的[密码学](@entry_id:139166)证据。

- **证据 (Evidence)**：这是关于设备状态的原始声明，例如 PCR 的值、已加载固件的度量日志、配置文件等。
- **引用 (Quote)**：为了确保证据的可信度和时效性，证明方（通常借助 [TPM](@entry_id:170576)）会将证据与一个由验证方提供的**随机数 (nonce)** 捆绑在一起，并用一个受[硬件保护](@entry_id:750157)的、不可迁移的**证明密钥 (Attestation Key)** 对其进行签名。这个经过签名的、包含证据和随机数的包就是“引用”。随机数用于防止[重放攻击](@entry_id:1130869)。
- **验证 (Verification)**：验证方接收到引用后，首先用对应的公钥验证签名，然后检查随机数是否匹配。确认无误后，它会将引用中的证据与其自身维护的“黄金策略”（一组已知的、可信的 PCR 值或固件版本）进行比较。如果证据符合策略，验证方就认为证明方处于可信状态 。

在数字孪生同步的场景中，RA 不仅确认了设备的软件完整性，还直接影响到应用层的功能。例如，一个[数字孪生](@entry_id:171650)需要维持其状态估计 $\hat{x}(t)$ 与物理设备真实状态 $x(t)$ 之间的误差 $\left|x(t) - \hat{x}(t)\right|$ 在阈值 $\epsilon$ 之内。假设物理状态的变化率有界，即 $\left|\frac{dx}{dt}\right| \leq \rho$。设备在 $t_q$ 时刻生成包含真实状态 $x(t_q)$ 的证明报告，而数字孪生在 $t_v$ 时刻收到并验证该报告，然后更新其状态为 $\hat{x}(t_v) := x(t_q)$。从测量到更新的延迟为 $t_v - t_q$。在这段时间内，真实物理状态可能发生的最大变化量为 $\rho \cdot (t_v - t_q)$。因此，为了保证同步误差不超过 $\epsilon$，验证方必须强制执行一个**时鲜性 (Freshness)** 策略，要求报告的延迟 $T = t_v - t_q$ 必须满足：
$$ T \leq \frac{\epsilon}{\rho} $$
这个例子清晰地表明，可信引导和[远程证明](@entry_id:754241)提供的安全属性（如时鲜性）与 CPS 的应用级性能指标（如同步精度）是紧密耦合的 。

### 威胁模型与[可信计算基 (TCB)](@entry_id:756202)

设计一个安全的系统，首先需要清晰地界定其信任边界和所面临的威胁。

#### [可信计算基 (TCB)](@entry_id:756202)

**[可信计算基](@entry_id:756201) (Trusted Computing Base, TCB)** 是指系统中所有对执行安全策略至关重要的硬件、固件和软件组件的集合。TCB 内的任何组件如果出现故障或被攻破，都可能导致整个系统的安全策略失效。**最小特权原则 (Principle of Least Privilege)** 是设计 TCB 的核心指导思想：TCB 应该尽可能小。一个庞大的 TCB 意味着更大的攻击面和更难的验证工作。

在一个典型的安全嵌入式控制器中，TCB 应包括：
- **核心[硬件信任根](@entry_id:1125916)**：如 Boot ROM、eFuses 中的密钥哈希、PUF 等。
- **执行验证和隔离的代码**：如 Boot ROM 中的签名验证例程、配置 TrustZone 或 MPU 的安全运行时。
- **防止回滚的硬件**：如单调计数器。

而以下组件则**不应**被包含在 TCB 中，它们是信任的消费者，而非提供者：
- **[操作系统内核](@entry_id:752950)和应用程序**：它们运行在由 TCB 强制执行的隔离环境中。
- **网络协议栈和OTA更新代理**：这些组件处理来自不可信网络的数据，应被视为不可信，并由 TCB 严格审查其行为（例如，审查下载的固件更新包）。

#### 攻击面分类

攻击面是攻击者可以尝试利用系统漏洞的所有入口点的总和。通常可以分为三类：

1.  **网络攻击向量 ($S_N$)**：通过网络接口发起的攻击，如利用 MQTT、HTTPS 或其他网络协议的漏洞。
2.  **物理攻击向量 ($S_P$)**：需要物理接触设备的攻击，如通过 JTAG/SWD 调试端口、探测 SPI/I2C 总线、以及更高级的物理攻击。
3.  **供应链攻击向量 ($S_S$)**：在设备交付给最终用户之前引入的攻击，如使用被篡改的编译器、植入后门的第三方库、或在制造过程中替换伪造的硬件组件 。

#### 物理攻击的深层剖析

物理攻击直接挑战可信引导最根本的硬件假设。主要有三类：

- **物理篡改 (Physical Tamper)**：通过直接干预硬件来改变其状态，例如使用微探针或[聚焦离子束](@entry_id:1125189)来修改 ROM 或 OTP 熔丝中的比特位。这种攻击直接破坏了 RoT 的**[不变性](@entry_id:140168)**假设。

- **[侧信道](@entry_id:754810)泄漏 (Side-Channel Leakage)**：通过被动地测量设备在运算时产生的物理泄露（如功耗、[电磁辐射](@entry_id:152916)、时间差异）来推断其内部的秘密信息。例如，通过对设备进行差分功耗分析 (DPA)，攻击者可能在不改变设备任何状态的情况下，提取出用于签名的设备私钥 $k_{\text{dev}}$。这种攻击破坏了密钥的**机密性**假设。

- **[故障注入](@entry_id:176348) (Fault Injection)**：通过主动向设备引入瞬时物理扰动（如电源或时钟的毛刺、电磁脉冲、激光照射）来诱发计算错误。例如，在 Boot ROM 执行签名验证算法的关键时刻进行一次精确的电压 glitch，可能导致比较指令返回错误结果，使得一个无效的签名被误判为有效。这种攻击破坏了处理器**正确确定性执行**的假设 。

综上所述，嵌入式设备的安全与可信引导是一个多层次、[深度集成](@entry_id:636362)的[系统工程](@entry_id:180583)，它始于一个不可动摇的[硬件信任根](@entry_id:1125916)，通过密码学构建的信任链，利用硬件隔离机制抵御物理攻击，并最终通过[远程证明](@entry_id:754241)等协议为[上层](@entry_id:198114)应用（如[数字孪生](@entry_id:171650)）提供可靠的信任基础。