{
    "hands_on_practices": [
        {
            "introduction": "In resource-constrained embedded systems, every byte of memory counts. This exercise challenges you to perform a detailed memory analysis for a secure bootloader, calculating the peak stack and heap usage required for cryptographic operations like hashing and signature verification . Mastering this skill is fundamental to ensuring that security features can be implemented without compromising the stability and functionality of the device.",
            "id": "4220180",
            "problem": "Consider a secure trusted boot process in a resource-constrained embedded device within a cyber-physical system whose Digital Twin models memory budgets to detect unsafe configurations at boot time. The bootloader performs two sequential phases: streaming hash computation over a firmware image and Elliptic Curve Digital Signature Algorithm (ECDSA) verification of the resulting digest against a manifest resident in non-volatile storage. The system uses a Harvard architecture microcontroller with a $32$-bit word size. The following assumptions define the execution and memory model:\n\n1. Fundamental definitions:\n   - The stack is a last-in-first-out region used for function call frames, automatic (local) variables, and saved registers. At any instant, the required stack memory equals the sum of the active frames and their local storage. The peak stack requirement is the maximum of this sum over the two phases.\n   - The heap is a dynamically managed region used for long-lived objects and buffers allocated by the bootloader prior to the phases. The required heap memory equals the sum of concurrently allocated heap objects.\n\n2. Hashing phase:\n   - The Secure Hash Algorithm $256$ (SHA-256) implementation maintains:\n     - A message schedule array $W$ of $64$ words on the stack.\n     - A chaining state array $H$ of $8$ words on the stack.\n     - $6$ additional $32$-bit temporary words on the stack.\n   - The bootloader main frame stores the final $256$-bit digest ($32$ bytes) on the stack between phases to avoid heap exposure.\n   - Assume a per-frame saved-register overhead of $m$ bytes for the bootloader main, $r_h$ bytes for the hashing function frame, and $r_v$ bytes for the verifier function frame. For this microcontroller, take $m = 64$, $r_h = 64$, and $r_v = 64$.\n\n3. Verification phase:\n   - ECDSA over the NIST P-256 curve uses $256$-bit scalars and coordinates.\n   - The verifier implementation allocates on the stack:\n     - $7$ temporary $256$-bit scalars (each $32$ bytes).\n     - A modular inversion scratch array of $16$ words.\n\n4. Heap allocations:\n   - The bootloader allocates two double-buffered input buffers of size $b$ bytes each for streaming the firmware image.\n   - The signature structure, inclusive of its encoding and metadata, has size $s$ bytes and is allocated on the heap for the duration of both phases.\n\nAssume the hashing phase completes before the verification phase begins (i.e., the hashing function’s frame is not simultaneously active with the verifier’s frame), but the bootloader main frame remains active across both phases while retaining the $32$-byte digest on its stack. Using only these assumptions and standard word-size arithmetic ($1$ word $=$ $4$ bytes), derive from first principles symbolic expressions, in bytes, for:\n\n- The peak stack memory requirement across both phases.\n- The total heap memory requirement across both phases.\n\nExpress the final result as a single row matrix with two entries $\\left[ \\text{stack}, \\text{heap} \\right]$ in bytes. No numerical rounding is required. Use bytes as the unit for any quantities described in the text; do not include units in the final boxed expression.",
            "solution": "The problem requires the derivation of symbolic expressions for the peak stack memory requirement and the total heap memory requirement for a trusted boot process in an embedded device. The process consists of two sequential phases: a hashing phase and a verification phase.\n\nFirst, we establish the fundamental unit conversions based on the problem statement. The microcontroller has a $32$-bit word size, which is equivalent to $4$ bytes.\n$$\n1 \\text{ word} = 32 \\text{ bits} = 4 \\text{ bytes}\n$$\n\nThe final result will be presented as a row matrix $[M_{stack, peak}, M_{heap}]$, where $M_{stack, peak}$ is the peak stack memory and $M_{heap}$ is the total heap memory, both in bytes.\n\n**1. Heap Memory Requirement ($M_{heap}$)**\n\nThe heap is used for objects that persist across both the hashing and verification phases. According to the problem statement, the following objects are allocated on the heap:\n- Two double-buffered input buffers, each of size $b$ bytes.\n- One signature structure of size $s$ bytes.\n\nSince these objects exist concurrently, the total heap memory requirement, $M_{heap}$, is the sum of their sizes.\n$$\nM_{heap} = b + b + s = 2b + s\n$$\n\n**2. Peak Stack Memory Requirement ($M_{stack, peak}$)**\n\nThe stack memory usage changes depending on the execution phase. The bootloader's main function frame is active during both phases, while the hashing function's frame is active only during the hashing phase, and the verifier function's frame is active only during the verification phase. The peak stack requirement is the maximum stack size reached during either of these two phases.\n\nFirst, we calculate the size of the main bootloader's stack frame, $S_{main}$. This frame contains its saved-register overhead, $m$, and the $256$-bit SHA-256 digest, which is stored on the stack between phases.\n- Saved-register overhead, $m = 64$ bytes.\n- Digest size = $256$ bits = $\\frac{256}{8}$ bytes = $32$ bytes.\n\nThe size of the main frame is therefore:\n$$\nS_{main} = m + 32 \\text{ bytes} = 64 + 32 = 96 \\text{ bytes}\n$$\n\nNext, we calculate the total stack usage during each phase.\n\n**Phase 1: Hashing**\n\nDuring the hashing phase, the call stack consists of the main function and the hashing function. The total stack usage, $M_{stack, 1}$, is the sum of the main frame size ($S_{main}$) and the hashing function's frame size ($S_{h, frame}$).\n\nThe hashing function's frame ($S_{h, frame}$) consists of:\n- Saved-register overhead, $r_h = 64$ bytes.\n- SHA-256 message schedule array $W$: $64$ words = $64 \\times 4 = 256$ bytes.\n- SHA-256 chaining state array $H$: $8$ words = $8 \\times 4 = 32$ bytes.\n- Additional temporary variables: $6$ words = $6 \\times 4 = 24$ bytes.\n\nThe size of the hashing frame is:\n$$\nS_{h, frame} = r_h + (64 \\times 4) + (8 \\times 4) + (6 \\times 4) = 64 + 256 + 32 + 24 = 376 \\text{ bytes}\n$$\nThe total stack usage during the hashing phase is:\n$$\nM_{stack, 1} = S_{main} + S_{h, frame} = 96 + 376 = 472 \\text{ bytes}\n$$\n\n**Phase 2: Verification**\n\nDuring the verification phase, the call stack consists of the main function and the verifier function. The total stack usage, $M_{stack, 2}$, is the sum of the main frame size ($S_{main}$) and the verifier function's frame size ($S_{v, frame}$).\n\nThe verifier function's frame ($S_{v, frame}$) consists of:\n- Saved-register overhead, $r_v = 64$ bytes.\n- $7$ temporary $256$-bit scalars: $7 \\times (\\frac{256}{8}) = 7 \\times 32 = 224$ bytes.\n- A modular inversion scratch array: $16$ words = $16 \\times 4 = 64$ bytes.\n\nThe size of the verifier frame is:\n$$\nS_{v, frame} = r_v + (7 \\times 32) + (16 \\times 4) = 64 + 224 + 64 = 352 \\text{ bytes}\n$$\nThe total stack usage during the verification phase is:\n$$\nM_{stack, 2} = S_{main} + S_{v, frame} = 96 + 352 = 448 \\text{ bytes}\n$$\n\n**Peak Stack Calculation**\n\nThe peak stack memory requirement, $M_{stack, peak}$, is the maximum of the stack usage in the two phases.\n$$\nM_{stack, peak} = \\max(M_{stack, 1}, M_{stack, 2}) = \\max(472, 448) = 472 \\text{ bytes}\n$$\n\n**Conclusion**\n\nThe derived expressions are:\n- Peak stack memory requirement: $M_{stack, peak} = 472$ bytes.\n- Total heap memory requirement: $M_{heap} = 2b + s$ bytes.\n\nThe final result is the row matrix $[M_{stack, peak}, M_{heap}]$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n472 & 2b+s\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "For a cyber-physical system, booting securely is not enough; it must also boot quickly to meet real-time operational deadlines. This problem guides you through a latency analysis of a trusted boot sequence, combining deterministic processing times with probabilistic delays to calculate the total expected boot time . Such performance modeling is essential for designing reliable systems where security and timeliness are both non-negotiable.",
            "id": "4220179",
            "problem": "A cyber-physical systems (CPS) device with a digital twin enforces a trusted boot with a strict provisioning deadline to ensure that the digital twin can synchronize state with the physical asset before actuation. The boot process is strictly sequential (no overlap) and consists of four stages: hashing the firmware image, verifying the signature, initializing input/output (I/O), and performing attestation. Assume all random components are independent. Use only fundamental definitions of expected value, linearity of expectation, and rate-throughput-cycle relationships to derive the expected boot latency.\n\nModel each stage as follows.\n\n- Hashing stage: The device hashes a firmware image of size $64$ mebibytes (MiB), where $1$ MiB $= 2^{20}$ bytes. A cryptographic accelerator sustains a throughput of $350$ megabytes per second (MB/s), interpreted as $350 \\times 10^{6}$ bytes per second. A bus arbitration setup time adds an independent exponential delay $X$ with rate $\\lambda_{h} = 500 \\ \\text{s}^{-1}$.\n- Signature verification stage: An Elliptic Curve Digital Signature Algorithm (ECDSA) P-$256$ verification requires $5.2 \\times 10^{6}$ cycles on a $200 \\times 10^{6}$ hertz processor. An additional independent cache jitter $Y$ is exponential with rate $\\lambda_{v} = 1000 \\ \\text{s}^{-1}$.\n- I/O initialization stage: Deterministic sub-steps complete in $17$ milliseconds, $24$ milliseconds, and $12$ milliseconds, respectively.\n- Attestation stage: A Trusted Platform Module (TPM) quote generation time $Z$ is gamma distributed with shape $k = 3$ and scale $\\theta = 0.004$ seconds, and the network round-trip time $W$ is exponential with mean $0.030$ seconds.\n\nLet the hard real-time deadline be $D = 0.30$ seconds. Using first principles, compute the expected total boot latency and then compute the slack $s = \\mathbb{E}[T] - D$. Round your final numerical result for $s$ to four significant figures. Express the final answer in seconds.",
            "solution": "The total boot latency, denoted by the random variable $T$, is the sum of the latencies of the four sequential stages: hashing ($T_h$), signature verification ($T_v$), I/O initialization ($T_{io}$), and attestation ($T_a$).\n$$T = T_h + T_v + T_{io} + T_a$$\nBy the linearity of expectation, the expected total boot latency $\\mathbb{E}[T]$ is the sum of the expected latencies of each stage:\n$$\\mathbb{E}[T] = \\mathbb{E}[T_h] + \\mathbb{E}[T_v] + \\mathbb{E}[T_{io}] + \\mathbb{E}[T_a]$$\nWe will compute the expected latency for each stage individually.\n\n1.  **Expected Hashing Latency $\\mathbb{E}[T_h]$**\n    The hashing stage latency $T_h$ consists of a deterministic time to hash the firmware image and an independent, random bus arbitration delay $X$.\n    $$T_h = T_{h, \\text{det}} + X$$\n    The deterministic time is the ratio of the firmware size to the accelerator's throughput. The firmware size is $64$ MiB, which is $64 \\times 2^{20}$ bytes. The throughput is $350$ MB/s, which is $350 \\times 10^{6}$ bytes/s.\n    $$T_{h, \\text{det}} = \\frac{\\text{Size}}{\\text{Throughput}} = \\frac{64 \\times 2^{20} \\ \\text{bytes}}{350 \\times 10^{6} \\ \\text{bytes/s}}$$\n    The random delay $X$ follows an exponential distribution with rate $\\lambda_{h} = 500 \\ \\text{s}^{-1}$. The expected value of an exponential random variable with rate $\\lambda$ is $1/\\lambda$.\n    $$\\mathbb{E}[X] = \\frac{1}{\\lambda_h} = \\frac{1}{500} \\ \\text{s} = 0.002 \\ \\text{s}$$\n    Therefore, the expected hashing latency is:\n    $$\\mathbb{E}[T_h] = T_{h, \\text{det}} + \\mathbb{E}[X] = \\frac{64 \\times 2^{20}}{350 \\times 10^{6}} \\ \\text{s} + 0.002 \\ \\text{s}$$\n\n2.  **Expected Signature Verification Latency $\\mathbb{E}[T_v]$**\n    The signature verification latency $T_v$ consists of a deterministic time for the CPU computation and an independent, random cache jitter delay $Y$.\n    $$T_v = T_{v, \\text{det}} + Y$$\n    The deterministic time is the ratio of the required processor cycles to the processor's frequency. The number of cycles is $5.2 \\times 10^{6}$ and the frequency is $200 \\times 10^{6}$ Hz (cycles/s).\n    $$T_{v, \\text{det}} = \\frac{\\text{Cycles}}{\\text{Frequency}} = \\frac{5.2 \\times 10^{6} \\ \\text{cycles}}{200 \\times 10^{6} \\ \\text{cycles/s}} = 0.026 \\ \\text{s}$$\n    The random jitter $Y$ follows an exponential distribution with rate $\\lambda_{v} = 1000 \\ \\text{s}^{-1}$.\n    $$\\mathbb{E}[Y] = \\frac{1}{\\lambda_v} = \\frac{1}{1000} \\ \\text{s} = 0.001 \\ \\text{s}$$\n    Therefore, the expected signature verification latency is:\n    $$\\mathbb{E}[T_v] = T_{v, \\text{det}} + \\mathbb{E}[Y] = 0.026 \\ \\text{s} + 0.001 \\ \\text{s} = 0.027 \\ \\text{s}$$\n\n3.  **Expected I/O Initialization Latency $\\mathbb{E}[T_{io}]$**\n    The I/O initialization stage consists of three deterministic sub-steps. Its total latency $T_{io}$ is the sum of their durations. Since the stage is deterministic, its expected value is the value itself.\n    $$T_{io} = 17 \\ \\text{ms} + 24 \\ \\text{ms} + 12 \\ \\text{ms} = 53 \\ \\text{ms} = 0.053 \\ \\text{s}$$\n    $$\\mathbb{E}[T_{io}] = 0.053 \\ \\text{s}$$\n\n4.  **Expected Attestation Latency $\\mathbb{E}[T_a]$**\n    The attestation latency $T_a$ is the sum of the TPM quote generation time $Z$ and the network round-trip time $W$.\n    $$T_a = Z + W$$\n    The time $Z$ is a gamma-distributed random variable with shape parameter $k = 3$ and scale parameter $\\theta = 0.004$ s. The expected value of a gamma distribution is $k\\theta$.\n    $$\\mathbb{E}[Z] = k\\theta = 3 \\times 0.004 \\ \\text{s} = 0.012 \\ \\text{s}$$\n    The time $W$ is an exponential random variable with a given mean of $0.030$ s.\n    $$\\mathbb{E}[W] = 0.030 \\ \\text{s}$$\n    Therefore, the expected attestation latency is:\n    $$\\mathbb{E}[T_a] = \\mathbb{E}[Z] + \\mathbb{E}[W] = 0.012 \\ \\text{s} + 0.030 \\ \\text{s} = 0.042 \\ \\text{s}$$\n\nNow, we sum the expected values of each stage to find the total expected boot latency $\\mathbb{E}[T]$.\n$$\\mathbb{E}[T] = \\mathbb{E}[T_h] + \\mathbb{E}[T_v] + \\mathbb{E}[T_{io}] + \\mathbb{E}[T_a]$$\nLet's first calculate the numerical value for $\\mathbb{E}[T_h]$.\n$$\\mathbb{E}[T_h] = \\frac{64 \\times 1048576}{350 \\times 10^{6}} \\ \\text{s} + 0.002 \\ \\text{s} = \\frac{67108864}{350000000} \\ \\text{s} + 0.002 \\ \\text{s}$$\n$$\\mathbb{E}[T_h] \\approx 0.19173961 \\ \\text{s} + 0.002 \\ \\text{s} = 0.19373961 \\ \\text{s}$$\nSubstituting the numerical values for all stages:\n$$\\mathbb{E}[T] \\approx 0.19373961 \\ \\text{s} + 0.027 \\ \\text{s} + 0.053 \\ \\text{s} + 0.042 \\ \\text{s}$$\n$$\\mathbb{E}[T] \\approx 0.31573961 \\ \\text{s}$$\nThe problem defines the slack $s$ as the difference between the expected total boot latency and the hard real-time deadline $D = 0.30$ s.\n$$s = \\mathbb{E}[T] - D$$\n$$s \\approx 0.31573961 \\ \\text{s} - 0.30 \\ \\text{s} = 0.01573961 \\ \\text{s}$$\nThe problem requires the final numerical result for $s$ to be rounded to four significant figures.\n$$s \\approx 0.01574 \\ \\text{s}$$\nA positive value for $s$ indicates that, on average, the boot process is expected to miss the deadline.",
            "answer": "$$\\boxed{0.01574}$$"
        },
        {
            "introduction": "Even with a trusted boot process, adversaries can exploit physical vulnerabilities to undermine security guarantees, such as by attempting a rollback attack. This practice asks you to model a realistic brownout attack that targets the system's anti-rollback counter, using probability to quantify the risk of a successful exploit over multiple attempts . This type of analysis helps bridge the gap between theoretical security models and the practical realities of physical device vulnerabilities.",
            "id": "4220148",
            "problem": "A cyber-physical system employs a trusted boot mechanism with anti-rollback enforced by a monotonic version counter stored within a Trusted Platform Module (TPM). The anti-rollback rule is: an image is accepted for boot only if its version number is greater than or equal to the monotonic counter value. In a specific embedded device, engineers find that under brownout conditions during power cycling, a hardware race can reset the monotonic counter to zero before the comparison logic runs. A digital twin of the device’s power and clock domains models this event and estimates the following: on any given power cycle during an attack attempt, the probability that the monotonic counter resets to zero is $p$, independently across attempts. A rollback attempt is considered “successful” if the counter reset occurs before the version comparison and thus an older image is accepted. After the first successful rollback, a “tamper lock” bit is set, which prevents any further rollback (so at most one successful rollback can occur across all attempts on a single device). An attacker performs $n$ independent brownout-induced power cycles as rollback attempts on a single device.\n\nStarting only from the axioms of probability (complement and independence) and the definition of expectation for a discrete random variable, derive a closed-form analytic expression for the expected number of successful rollbacks over $n$ attempts as a function of $p$ and $n$. Express your final answer as a single closed-form expression. No rounding is required.",
            "solution": "Let $X$ be the discrete random variable representing the total number of successful rollbacks over the $n$ attempts. The problem states that a \"tamper lock\" mechanism prevents any further rollbacks after the first success. Consequently, the total number of successful rollbacks on a single device can only be $0$ (if no attempt succeeds) or $1$ (if at least one attempt succeeds). Thus, the set of possible values for $X$ is $\\{0, 1\\}$.\n\nThe directive is to derive the expected number of successful rollbacks, $E[X]$, starting from the fundamental definition of expectation for a discrete random variable. This definition is given by:\n$$E[X] = \\sum_{x \\in \\{0,1\\}} x \\cdot P(X=x)$$\nSubstituting the possible values of $X$ into this definition, we obtain:\n$$E[X] = (0 \\cdot P(X=0)) + (1 \\cdot P(X=1)) = P(X=1)$$\nThis demonstrates that the expected number of successful rollbacks is precisely the probability that at least one successful rollback occurs within the $n$ attempts. The event $\\{X=1\\}$ is equivalent to the event of \"at least one success\".\n\nTo find $P(X=1)$, it is more direct to first calculate the probability of its complement event, $\\{X=0\\}$. The event $\\{X=0\\}$ corresponds to the outcome where no successful rollbacks occur in any of the $n$ attempts. This means every single attempt must be a failure. According to the axiom of complements in probability theory:\n$$P(X=1) = 1 - P(X=0)$$\nLet $S_i$ be the event that the $i$-th attempt is a success, for $i \\in \\{1, 2, \\dots, n\\}$. The problem states the probability of success for any single attempt is $P(S_i) = p$. Let $F_i$ be the complement event that the $i$-th attempt is a failure. Using the complement rule, its probability is:\n$$P(F_i) = 1 - P(S_i) = 1 - p$$\nThe event $\\{X=0\\}$ is the occurrence of a failure on the first attempt, and a failure on the second, and so on, up to the $n$-th attempt. This can be expressed as the intersection of the individual failure events:\n$$\\{X=0\\} = F_1 \\cap F_2 \\cap \\dots \\cap F_n$$\nThe problem specifies that the $n$ attempts are independent. By the definition of independence for multiple events, the probability of their intersection is the product of their individual probabilities:\n$$P(X=0) = P(F_1 \\cap F_2 \\cap \\dots \\cap F_n) = \\prod_{i=1}^{n} P(F_i)$$\nSince the probability of failure is the same, $1-p$, for each independent attempt, this product becomes:\n$$P(X=0) = (1-p) \\cdot (1-p) \\cdot \\dots \\cdot (1-p) = (1-p)^{n}$$\nFinally, we substitute this result back into the expression for $E[X]$ that we derived from first principles:\n$$E[X] = P(X=1) = 1 - P(X=0) = 1 - (1-p)^{n}$$\nThis is the closed-form analytic expression for the expected number of successful rollbacks over $n$ attempts, derived strictly from the specified axioms and definitions.",
            "answer": "$$\\boxed{1 - (1-p)^{n}}$$"
        }
    ]
}