{
    "hands_on_practices": [
        {
            "introduction": "可信启动的基石是信任链，它被不可变地记录在基于硬件的可信平台模块 (TPM) 中。这条链是通过依次测量每个软件组件，并用该测量值“扩展”平台配置寄存器 (PCR) 来构建的。该实践 () 提供了对这一核心机制的动手体验。通过使用一个简化的哈希和拼接操作数学模型，您将逐步追踪 PCR 值的演变，从而巩固您对在启动过程中如何累积建立和记录信任的理解。",
            "id": "4220165",
            "problem": "考虑一个可信平台模块（TPM），它在可信启动期间维护一个平台配置寄存器（PCR），用以累积启动状态的度量值。PCR 通过一个抗碰撞的密码学哈希函数，按顺序用每个度量值进行扩展。在本问题中，扩展操作定义在一个数字模型上，其中连接操作符通过算术方式进行编码。具体来说，设两个非负整数 $x$ 和 $y$ 的连接，记作 $x \\,\\|\\, y$，是单射编码 $x \\cdot B + y$，其中 $B = 1000$ 且约束条件为 $0 \\leq y  B$。哈希函数实例化为\n$$H(z) = \\left(\\left(\\alpha z + \\beta \\right) \\bmod M\\right)^{3} \\bmod M,$$\n其中 $M = 101$，$\\alpha = 7$，$\\beta = 13$。假设 $H$ 在所建模的域中是抗碰撞的。对于一个度量值 $m$，PCR 的更新规则定义为 $PCR \\leftarrow H\\!\\left(PCR \\,\\|\\, m\\right)$，并按顺序依次应用于每个度量值。\n\n给定初始寄存器值 $PCR^{(0)} = 42$ 和三个度量值 $m_1 = 317$、$m_2 = 29$ 和 $m_3 = 880$，请根据所述规则和哈希实例化，在执行三次顺序扩展后，计算最终值 $PCR^{(3)}$。请将您的最终答案表示为十进制整数。无需四舍五入。",
            "solution": "这个问题是有效的，因为它提出了一个基于密码学过程数学模型的、定义明确的计算任务。所有必需的数据和规则都已提供，并且在模型的框架内没有内部矛盾或科学上的不准确之处。\n\n任务是计算平台配置寄存器在三次顺序更新后的最终值，记为 $PCR^{(3)}$。该过程从一个初始值 $PCR^{(0)}$ 开始，并依次对三个度量值 $m_1$、$m_2$ 和 $m_3$ 应用扩展操作。\n\n给定的参数如下：\n- 初始 PCR 值：$PCR^{(0)} = 42$\n- 度量值：$m_1 = 317$，$m_2 = 29$，$m_3 = 880$\n- 连接编码基数：$B = 1000$\n- 哈希函数参数：$\\alpha = 7$，$\\beta = 13$，模数 $M = 101$。\n\n对于一个度量值 $m$，PCR 更新规则由 $PCR_{new} \\leftarrow H(PCR_{old} \\,\\|\\, m)$ 给出。连接 $x \\,\\|\\, y$ 的算术定义为 $x \\cdot B + y$。哈希函数为 $H(z) = ((\\alpha z + \\beta) \\bmod M)^{3} \\bmod M$。\n\n我们将分三步进行计算。\n\n### 步骤 1：计算 $PCR^{(1)}$\n第一次更新使用 $PCR^{(0)}$ 和度量值 $m_1$。新的 PCR 值 $PCR^{(1)}$ 由 $H(PCR^{(0)} \\,\\|\\, m_1)$ 给出。\n\n首先，我们计算连接后的值，称其为 $C_1$：\n$$C_1 = PCR^{(0)} \\cdot B + m_1 = 42 \\cdot 1000 + 317 = 42000 + 317 = 42317$$\n\n接下来，我们将哈希函数 $H$ 应用于 $C_1$。这首先需要计算内部表达式 $(\\alpha C_1 + \\beta) \\pmod{M}$：\n$$(\\alpha C_1 + \\beta) \\pmod{M} = (7 \\cdot 42317 + 13) \\pmod{101}$$\n$$7 \\cdot 42317 + 13 = 296219 + 13 = 296232$$\n为了求模 $101$ 的值，我们进行除法运算：\n$$296232 = 2932 \\cdot 101 + 100$$\n所以，$296232 \\equiv 100 \\pmod{101}$。\n\n现在我们通过对该结果求立方并再次取模来计算最终的哈希值：\n$$PCR^{(1)} = (100)^{3} \\pmod{101}$$\n由于 $100 \\equiv -1 \\pmod{101}$，我们可以简化此计算：\n$$PCR^{(1)} \\equiv (-1)^{3} \\pmod{101} \\equiv -1 \\pmod{101} \\equiv 100 \\pmod{101}$$\n因此，第一次扩展后的 PCR 值为 $PCR^{(1)} = 100$。\n\n### 步骤 2：计算 $PCR^{(2)}$\n第二次更新使用 $PCR^{(1)}$ 和度量值 $m_2$。新的 PCR 值 $PCR^{(2)}$ 由 $H(PCR^{(1)} \\,\\|\\, m_2)$ 给出。\n\n首先，我们计算连接后的值 $C_2$：\n$$C_2 = PCR^{(1)} \\cdot B + m_2 = 100 \\cdot 1000 + 29 = 100000 + 29 = 100029$$\n\n接下来，我们将哈希函数 $H$ 应用于 $C_2$。我们计算 $(\\alpha C_2 + \\beta) \\pmod{M}$：\n$$(\\alpha C_2 + \\beta) \\pmod{M} = (7 \\cdot 100029 + 13) \\pmod{101}$$\n我们可以通过先将 $C_2$ 对 $101$ 取模来简化计算：\n$$100029 = 990 \\cdot 101 + 39 \\implies C_2 \\equiv 39 \\pmod{101}$$\n现在将此代入表达式中：\n$$(7 \\cdot 39 + 13) \\pmod{101} = (273 + 13) \\pmod{101} = 286 \\pmod{101}$$\n$$286 = 2 \\cdot 101 + 84 \\implies 286 \\equiv 84 \\pmod{101}$$\n\n现在我们通过对该结果求立方来计算最终的哈希值：\n$$PCR^{(2)} = (84)^{3} \\pmod{101}$$\n由于 $84 \\equiv -17 \\pmod{101}$，我们有：\n$$PCR^{(2)} \\equiv (-17)^{3} \\pmod{101} \\equiv -(17^{3}) \\pmod{101}$$\n我们来计算 $17^3 \\pmod{101}$：\n$$17^{2} = 289 = 2 \\cdot 101 + 87 \\implies 17^{2} \\equiv 87 \\pmod{101}$$\n$$17^{3} = 17^{2} \\cdot 17 \\equiv 87 \\cdot 17 \\pmod{101} = 1479 \\pmod{101}$$\n$$1479 = 14 \\cdot 101 + 65 \\implies 1479 \\equiv 65 \\pmod{101}$$\n代回：\n$$PCR^{(2)} \\equiv -65 \\pmod{101} \\equiv 101 - 65 \\pmod{101} \\equiv 36 \\pmod{101}$$\n因此，第二次扩展后的 PCR 值为 $PCR^{(2)} = 36$。\n\n### 步骤 3：计算 $PCR^{(3)}$\n第三次也是最后一次更新使用 $PCR^{(2)}$ 和度量值 $m_3$。最终的 PCR 值 $PCR^{(3)}$ 由 $H(PCR^{(2)} \\,\\|\\, m_3)$ 给出。\n\n首先，我们计算连接后的值 $C_3$：\n$$C_3 = PCR^{(2)} \\cdot B + m_3 = 36 \\cdot 1000 + 880 = 36000 + 880 = 36880$$\n\n接下来，我们将哈希函数 $H$ 应用于 $C_3$。我们计算 $(\\alpha C_3 + \\beta) \\pmod{M}$：\n$$(\\alpha C_3 + \\beta) \\pmod{M} = (7 \\cdot 36880 + 13) \\pmod{101}$$\n我们首先将 $C_3$ 对 $101$ 取模：\n$$36880 = 365 \\cdot 101 + 15 \\implies C_3 \\equiv 15 \\pmod{101}$$\n现在将此代入表达式中：\n$$(7 \\cdot 15 + 13) \\pmod{101} = (105 + 13) \\pmod{101} = 118 \\pmod{101}$$\n$$118 = 1 \\cdot 101 + 17 \\implies 118 \\equiv 17 \\pmod{101}$$\n\n最后，我们通过对该结果求立方来计算最终的哈希值：\n$$PCR^{(3)} = (17)^{3} \\pmod{101}$$\n我们已在上一步中计算过此值：\n$$17^{3} \\equiv 65 \\pmod{101}$$\n因此，三次扩展后的最终 PCR 值为 $PCR^{(3)} = 65$。",
            "answer": "$$\\boxed{65}$$"
        },
        {
            "introduction": "尽管可信启动的概念模型很优雅，但其在现实世界嵌入式系统中的实现却受到有限资源的制约。从密码学哈希到签名验证的每一个功能都会消耗宝贵的堆栈和堆内存，这些资源必须经过仔细的预算规划。本练习 () 要求您为安全引导加载程序执行详细的内存分析。通过计算峰值堆栈和总堆需求，您将深入了解资源预算这一关键任务，这是设计高效、安全的信息物理系统的基本技能。",
            "id": "4220180",
            "problem": "考虑一个信息物理系统中的资源受限嵌入式设备的安全可信启动过程，该系统的数字孪生对内存预算进行建模，以在启动时检测不安全的配置。引导加载程序执行两个顺序阶段：对固件镜像进行流式哈希计算，以及将生成的摘要与驻留在非易失性存储中的清单进行椭圆曲线数字签名算法 (ECDSA) 验证。该系统使用哈佛架构微控制器，字长为 $32$ 位。以下假设定义了执行和内存模型：\n\n1. 基本定义：\n   - 栈是一个后进先出的区域，用于存放函数调用帧、自动（局部）变量和保存的寄存器。在任何时刻，所需的栈内存等于活跃帧及其局部存储的总和。峰值栈需求是这两个阶段中该总和的最大值。\n   - 堆是一个动态管理的区域，用于存放在这些阶段之前由引导加载程序分配的长生命周期的对象和缓冲区。所需的堆内存等于并发分配的堆对象的总和。\n\n2. 哈希阶段：\n   - 安全哈希算法256 (SHA-256) 的实现维护：\n     - 一个在栈上的消息调度数组 $W$，大小为 $64$ 个字。\n     - 一个在栈上的链式状态数组 $H$，大小为 $8$ 个字。\n     - $6$ 个在栈上的额外 $32$ 位临时字。\n   - 引导加载程序的主函数帧在两个阶段之间将最终的 $256$ 位摘要（$32$ 字节）存储在栈上，以避免堆暴露。\n   - 假设引导加载程序主函数帧、哈希函数帧和验证函数帧每帧保存寄存器的开销分别为 $m$ 字节、$r_h$ 字节和 $r_v$ 字节。对于此微控制器，取 $m = 64$，$r_h = 64$ 和 $r_v = 64$。\n\n3. 验证阶段：\n   - 基于 NIST P-256 曲线的 ECDSA 使用 $256$ 位的标量和坐标。\n   - 验证器的实现在栈上分配：\n     - $7$ 个临时的 $256$ 位标量（每个 $32$ 字节）。\n     - 一个大小为 $16$ 个字的模逆运算暂存数组。\n\n4. 堆分配：\n   - 引导加载程序分配两个大小各为 $b$ 字节的双缓冲输入缓冲区，用于流式传输固件镜像。\n   - 签名结构（包括其编码和元数据）大小为 $s$ 字节，在两个阶段的整个持续时间内都分配在堆上。\n\n假设哈希阶段在验证阶段开始之前完成（即，哈希函数的帧与验证器的帧不是同时活跃的），但引导加载程序的主函数帧在两个阶段都保持活跃，并在其栈上保留 $32$ 字节的摘要。仅使用这些假设和标准的字长算术（$1$ 字 $=$ $4$ 字节），从第一性原理推导出以下各项的符号表达式（以字节为单位）：\n\n- 两个阶段中的峰值栈内存需求。\n- 两个阶段中的总堆内存需求。\n\n将最终结果表示为一个包含两个条目 $\\left[ \\text{stack}, \\text{heap} \\right]$ 的单行矩阵，单位为字节。无需进行数值四舍五入。对文本中描述的任何数量均使用字节作为单位；不要在最终的方框表达式中包含单位。",
            "solution": "问题要求为嵌入式设备中的可信启动过程推导出峰值栈内存需求和总堆内存需求的符号表达式。该过程包括两个顺序阶段：哈希阶段和验证阶段。\n\n首先，我们根据问题陈述建立基本单位转换。该微控制器具有 $32$ 位字长，相当于 $4$ 字节。\n$$\n1 \\text{ word} = 32 \\text{ bits} = 4 \\text{ bytes}\n$$\n\n最终结果将表示为一个行矩阵 $[M_{stack, peak}, M_{heap}]$，其中 $M_{stack, peak}$ 是峰值栈内存，$M_{heap}$ 是总堆内存，两者单位均为字节。\n\n**1. 堆内存需求 ($M_{heap}$)**\n\n堆用于存储在哈希和验证两个阶段都持续存在的对象。根据问题陈述，以下对象被分配在堆上：\n- 两个双缓冲输入缓冲区，每个大小为 $b$ 字节。\n- 一个大小为 $s$ 字节的签名结构。\n\n由于这些对象同时存在，总堆内存需求 $M_{heap}$ 是它们大小的总和。\n$$\nM_{heap} = b + b + s = 2b + s\n$$\n\n**2. 峰值栈内存需求 ($M_{stack, peak}$)**\n\n栈内存使用量根据执行阶段而变化。引导加载程序的主函数帧在两个阶段都处于活跃状态，而哈希函数的帧仅在哈希阶段活跃，验证函数的帧仅在验证阶段活跃。峰值栈需求是在这两个阶段中达到的最大栈大小。\n\n首先，我们计算引导加载程序主函数栈帧的大小 $S_{main}$。该帧包含其保存寄存器的开销 $m$，以及在两个阶段之间存储在栈上的 $256$ 位 SHA-256 摘要。\n- 保存寄存器的开销，$m = 64$ 字节。\n- 摘要大小 = $256$ 位 = $\\frac{256}{8}$ 字节 = $32$ 字节。\n\n因此，主函数帧的大小为：\n$$\nS_{main} = m + 32 \\text{ bytes} = 64 + 32 = 96 \\text{ bytes}\n$$\n\n接下来，我们计算每个阶段的总栈使用量。\n\n**阶段 1：哈希**\n\n在哈希阶段，调用栈由主函数和哈希函数组成。总栈使用量 $M_{stack, 1}$ 是主函数帧大小 ($S_{main}$) 和哈希函数帧大小 ($S_{h, frame}$) 的总和。\n\n哈希函数的帧 ($S_{h, frame}$) 包括：\n- 保存寄存器的开销，$r_h = 64$ 字节。\n- SHA-256 消息调度数组 $W$：$64$ 个字 = $64 \\times 4 = 256$ 字节。\n- SHA-256 链式状态数组 $H$：$8$ 个字 = $8 \\times 4 = 32$ 字节。\n- 额外的临时变量：$6$ 个字 = $6 \\times 4 = 24$ 字节。\n\n哈希帧的大小为：\n$$\nS_{h, frame} = r_h + (64 \\times 4) + (8 \\times 4) + (6 \\times 4) = 64 + 256 + 32 + 24 = 376 \\text{ bytes}\n$$\n哈希阶段的总栈使用量为：\n$$\nM_{stack, 1} = S_{main} + S_{h, frame} = 96 + 376 = 472 \\text{ bytes}\n$$\n\n**阶段 2：验证**\n\n在验证阶段，调用栈由主函数和验证函数组成。总栈使用量 $M_{stack, 2}$ 是主函数帧大小 ($S_{main}$) 和验证函数帧大小 ($S_{v, frame}$) 的总和。\n\n验证函数的帧 ($S_{v, frame}$) 包括：\n- 保存寄存器的开销，$r_v = 64$ 字节。\n- $7$ 个临时的 $256$ 位标量：$7 \\times (\\frac{256}{8}) = 7 \\times 32 = 224$ 字节。\n- 一个模逆运算暂存数组：$16$ 个字 = $16 \\times 4 = 64$ 字节。\n\n验证帧的大小为：\n$$\nS_{v, frame} = r_v + (7 \\times 32) + (16 \\times 4) = 64 + 224 + 64 = 352 \\text{ bytes}\n$$\n验证阶段的总栈使用量为：\n$$\nM_{stack, 2} = S_{main} + S_{v, frame} = 96 + 352 = 448 \\text{ bytes}\n$$\n\n**峰值栈计算**\n\n峰值栈内存需求 $M_{stack, peak}$ 是两个阶段中栈使用量的最大值。\n$$\nM_{stack, peak} = \\max(M_{stack, 1}, M_{stack, 2}) = \\max(472, 448) = 472 \\text{ bytes}\n$$\n\n**结论**\n\n推导出的表达式为：\n- 峰值栈内存需求：$M_{stack, peak} = 472$ 字节。\n- 总堆内存需求：$M_{heap} = 2b + s$ 字节。\n\n最终结果是行矩阵 $[M_{stack, peak}, M_{heap}]$。",
            "answer": "$$\n\\boxed{\n\\begin{bmatrix}\n472  2b+s\n\\end{bmatrix}\n}\n$$"
        },
        {
            "introduction": "一个强大的可信启动机制不仅要验证固件的完整性，还必须防止攻击者将设备恢复到旧的、易受攻击的软件版本。这通常通过单调计数器来实现，但这个计数器本身可能成为硬件级攻击的目标。在这个问题 () 中，您将扮演安全分析师的角色，对掉电引起的“回滚攻击”风险进行建模和量化。通过从第一性原理推导成功攻击的期望次数，您将练习基本的威胁建模技能，并理解物理层漏洞如何破坏逻辑上的安全保障。",
            "id": "4220148",
            "problem": "一个信息物理系统采用了一种可信启动机制，该机制通过存储在可信平台模块（TPM）中的单调版本计数器来强制执行防回滚策略。防回滚规则是：仅当镜像的版本号大于或等于单调计数器的值时，该镜像才被接受启动。在一个特定的嵌入式设备中，工程师发现在电源重启期间的欠压条件下，硬件竞争可能在比较逻辑运行之前将单调计数器重置为零。该设备电源域和时钟域的数字孪生模型对此事件进行建模，并估计出以下情况：在攻击尝试期间的任何给定电源重启中，单调计数器重置为零的概率为 $p$，且每次尝试之间相互独立。如果计数器在版本比较之前发生重置，从而导致一个较旧的镜像被接受，则该回滚尝试被视为“成功”。在第一次成功回滚后，一个“篡改锁定”位将被设置，以防止任何进一步的回滚（因此，在单个设备上的所有尝试中最多只能发生一次成功的回滚）。攻击者在单个设备上执行 $n$ 次独立的、由欠压引起的电源重启作为回滚尝试。\n\n请仅从概率公理（补集和独立性）以及离散随机变量期望的定义出发，推导在 $n$ 次尝试中成功回滚的期望次数的封闭形式解析表达式，该表达式是 $p$ 和 $n$ 的函数。请将您的最终答案表示为单个封闭形式的表达式。无需四舍五入。",
            "solution": "在尝试解决方案之前，问题陈述经过了严格的验证过程。\n\n**步骤1：提取已知条件**\n- 一个信息物理系统采用带有防回滚单调计数器的可信启动机制。\n- 防回滚规则是：如果镜像的版本号大于或等于计数器值，则该镜像被接受。\n- 在欠压条件下，硬件竞争可能将单调计数器重置为零。\n- 在任何给定的电源重启尝试中，计数器重置的概率为 $p$，且各次尝试之间相互独立。\n- 如果计数器发生重置，则回滚尝试被视为“成功”。\n- 在第一次成功回滚后，一个“篡改锁定”位被设置，以防止任何进一步的回滚。最多只能有一次成功的回滚。\n- 攻击者执行 $n$ 次独立的尝试。\n- 目标是仅从概率公理（补集和独立性）以及离散随机变量期望的定义出发，推导在 $n$ 次尝试中成功回滚的期望次数，作为 $p$ 和 $n$ 的函数。\n\n**步骤2：使用提取的已知条件进行验证**\n根据既定的有效性标准对问题进行评估。\n- **科学依据**：该场景是嵌入式系统中一个现实且被充分理解的安全漏洞，涉及可信平台模块（TPM）、单调计数器和欠压攻击。它基于硬件安全和计算机工程的既定原则。该问题在科学上是合理的。\n- **适定性**：所有必要的参数（$p$、$n$）和约束（尝试的独立性、“篡改锁定”机制）都已明确定义。寻找期望值的目标是明确的。存在一个唯一的、稳定的解。\n- **客观性**：问题陈述使用精确、正式的语言，不含主观或基于观点的论断。\n该问题是自洽的、一致的，并且没有违反任何无效性标准。它不是隐喻性的、琐碎的或不适定的。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将按要求推导解决方案。\n\n设 $X$ 为离散随机变量，表示在 $n$ 次尝试中成功回滚的总次数。问题陈述指出，“篡改锁定”机制在第一次成功后会阻止任何进一步的回滚。因此，单个设备上成功回滚的总次数只能是 $0$（如果没有尝试成功）或 $1$（如果至少有一次尝试成功）。因此，$X$ 的可能取值集合是 $\\{0, 1\\}$。\n\n指令要求从离散随机变量期望的基本定义出发，推导成功回滚的期望次数 $E[X]$。该定义如下：\n$$E[X] = \\sum_{x \\in \\{0,1\\}} x \\cdot P(X=x)$$\n将 $X$ 的可能取值代入此定义，我们得到：\n$$E[X] = (0 \\cdot P(X=0)) + (1 \\cdot P(X=1)) = P(X=1)$$\n这表明成功回滚的期望次数恰好是在 $n$ 次尝试中至少有一次成功回滚的概率。事件 $\\{X=1\\}$ 等价于“至少有一次成功”的事件。\n\n为了求出 $P(X=1)$，更直接的方法是先计算其补事件 $\\{X=0\\}$ 的概率。事件 $\\{X=0\\}$ 对应于在 $n$ 次尝试中均未发生成功回滚的结果。这意味着每一次尝试都必须是失败的。根据概率论中的补集公理：\n$$P(X=1) = 1 - P(X=0)$$\n设 $S_i$ 为第 $i$ 次尝试成功的事件，其中 $i \\in \\{1, 2, \\dots, n\\}$。问题陈述中指出，任何单次尝试成功的概率为 $P(S_i) = p$。设 $F_i$ 为第 $i$ 次尝试失败的补事件。使用补集法则，其概率为：\n$$P(F_i) = 1 - P(S_i) = 1 - p$$\n事件 $\\{X=0\\}$ 是指第一次尝试失败，第二次尝试失败，依此类推，直到第 $n$ 次尝试都失败。这可以表示为各个失败事件的交集：\n$$\\{X=0\\} = F_1 \\cap F_2 \\cap \\dots \\cap F_n$$\n问题指明 $n$ 次尝试是独立的。根据多个事件独立性的定义，它们交集的概率是它们各自概率的乘积：\n$$P(X=0) = P(F_1 \\cap F_2 \\cap \\dots \\cap F_n) = \\prod_{i=1}^{n} P(F_i)$$\n由于每次独立尝试的失败概率都相同，为 $1-p$，因此这个乘积变为：\n$$P(X=0) = (1-p) \\cdot (1-p) \\cdot \\dots \\cdot (1-p) = (1-p)^{n}$$\n最后，我们将此结果代回到我们从第一性原理推导出的 $E[X]$ 的表达式中：\n$$E[X] = P(X=1) = 1 - P(X=0) = 1 - (1-p)^{n}$$\n这就是在 $n$ 次尝试中成功回滚次数的封闭形式解析表达式，它是严格根据指定的公理和定义推导出来的。",
            "answer": "$$\\boxed{1 - (1-p)^{n}}$$"
        }
    ]
}