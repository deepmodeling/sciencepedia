{
    "hands_on_practices": [
        {
            "introduction": "Mastering real-time protocols begins with a firm grasp of their foundational guarantees. This first exercise challenges you to apply the core rules of the Priority Ceiling Protocol (PCP) to determine the worst-case blocking experienced by tasks in a system. By both calculating the blocking term $B_i$ and constructing a scenario to illustrate the protocol's behavior, you will develop a robust, dual understanding of PCP's quantitative impact and its qualitative mechanism for preventing unbounded priority inversion .",
            "id": "4244092",
            "problem": "A cyber-physical co-simulation platform for a digital twin operates on a single-core processor under fixed-priority preemptive scheduling. The platform uses the Priority Ceiling Protocol (PCP) for mutual exclusion on shared resources. Consider three periodic tasks, where higher rate implies higher static priority (Rate Monotonic). Let the tasks be denoted by $T_1$, $T_2$, and $T_3$, with periods $P_1 = 10\\,\\mathrm{ms}$, $P_2 = 20\\,\\mathrm{ms}$, and $P_3 = 50\\,\\mathrm{ms}$, respectively. Thus, $T_1$ has the highest static priority, followed by $T_2$, then $T_3$.\n\nThe platform uses three shared resources: $R_x$, $R_y$, and $R_z$. Resource ceilings are defined as the highest static priority of any task that may lock the resource and are given as follows: the ceiling of $R_x$ equals the priority of $T_1$, the ceiling of $R_y$ equals the priority of $T_2$, and the ceiling of $R_z$ equals the priority of $T_3$.\n\nEach critical section duration is the sum of a base service time and the lock/unlock overhead. The lock overhead per lock and per unlock event is $o_{\\ell} = 0.03\\,\\mathrm{ms}$. Hence, any single lock/unlock pair contributes $2 o_{\\ell} = 0.06\\,\\mathrm{ms}$ of overhead. The base critical section times (exclusive of overhead) are:\n- $T_1$ uses $R_x$ for $C_{1x}^{\\mathrm{base}} = 0.15\\,\\mathrm{ms}$.\n- $T_2$ uses $R_y$ for $C_{2y}^{\\mathrm{base}} = 0.18\\,\\mathrm{ms}$.\n- $T_3$ uses $R_x$ for $C_{3x}^{\\mathrm{base}} = 0.35\\,\\mathrm{ms}$, $R_y$ for $C_{3y}^{\\mathrm{base}} = 0.20\\,\\mathrm{ms}$, and $R_z$ for $C_{3z}^{\\mathrm{base}} = 0.45\\,\\mathrm{ms}$.\n\nAssume any additional context-switch or preemption overhead is negligible for the purpose of computing blocking (it does not extend critical sections) and that all accesses are properly nested and well-formed according to PCP.\n\nTask:\n1. Using only the foundational definitions of fixed-priority schedulability with PCP and resource ceilings, compute the blocking term $B_i$ under PCP for each task $T_i$, where $i \\in \\{1,2,3\\}$. Express each $B_i$ in $\\mathrm{ms}$, rounded to four significant figures.\n2. Construct and describe a concrete release pattern that demonstrates and verifies the PCP at-most-one-blocking property for $T_1$ in this system, using the given ceilings and critical-section times. Explain why no chain-blocking beyond a single lower-priority critical section can occur for $T_1$ under PCP in your example.\n\nYour final answer must contain the three blocking terms in a single row matrix in the order $\\left(B_1, B_2, B_3\\right)$, with no units included inside the final answer. Round each entry to four significant figures.",
            "solution": "The problem statement is first validated for scientific soundness, completeness, and consistency before a solution is attempted.\n\n### Problem Validation\n\n**Step 1: Extracted Givens**\n- **System**: Single-core processor, fixed-priority preemptive scheduling, Priority Ceiling Protocol (PCP).\n- **Tasks**: Three periodic tasks, $T_1$, $T_2$, $T_3$.\n- **Priority Scheme**: Rate Monotonic, implying priority $Prio(T_1) > Prio(T_2) > Prio(T_3)$. Let these priorities be denoted by $\\pi_1, \\pi_2, \\pi_3$ respectively, where $\\pi_1 > \\pi_2 > \\pi_3$.\n- **Periods**: $P_1 = 10\\,\\mathrm{ms}$, $P_2 = 20\\,\\mathrm{ms}$, $P_3 = 50\\,\\mathrm{ms}$.\n- **Shared Resources**: $R_x$, $R_y$, $R_z$.\n- **Resource Ceilings**: $Ceiling(R_x) = \\pi_1$, $Ceiling(R_y) = \\pi_2$, $Ceiling(R_z) = \\pi_3$.\n- **Lock/Unlock Overhead**: $o_{\\ell} = 0.03\\,\\mathrm{ms}$ per event. A lock/unlock pair costs $2 o_{\\ell} = 0.06\\,\\mathrm{ms}$.\n- **Base Critical Section Service Times**:\n  - $T_1$ uses $R_x$ for $C_{1x}^{\\mathrm{base}} = 0.15\\,\\mathrm{ms}$.\n  - $T_2$ uses $R_y$ for $C_{2y}^{\\mathrm{base}} = 0.18\\,\\mathrm{ms}$.\n  - $T_3$ uses $R_x$ for $C_{3x}^{\\mathrm{base}} = 0.35\\,\\mathrm{ms}$.\n  - $T_3$ uses $R_y$ for $C_{3y}^{\\mathrm{base}} = 0.20\\,\\mathrm{ms}$.\n  - $T_3$ uses $R_z$ for $C_{3z}^{\\mathrm{base}} = 0.45\\,\\mathrm{ms}$.\n- **Assumptions**: Context-switch overhead is negligible for blocking computation. Resource accesses are properly nested.\n- **Task Requirements**:\n  1. Compute the blocking term $B_i$ for each task $T_i$ for $i \\in \\{1, 2, 3\\}$.\n  2. Construct a concrete scenario demonstrating the at-most-one-blocking property for $T_1$ and explain the underlying PCP mechanism.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is well-grounded in the established theory of real-time systems, specifically fixed-priority scheduling and resource synchronization using the Priority Ceiling Protocol. All concepts are standard in the field.\n- **Well-Posed and Objective**: The problem is stated with clear, objective language and provides all necessary numerical data and protocol specifications to compute the required blocking terms. The questions are unambiguous and lead to a unique set of answers for the blocking terms.\n- **Incomplete or Contradictory Setup**: The setup is complete and consistent. Let's verify the resource ceilings against their formal definition. The ceiling of a resource is the highest priority of any task that may lock it.\n  - Resource $R_x$ is used by $T_1$ (priority $\\pi_1$) and $T_3$ (priority $\\pi_3$). The highest priority is $\\pi_1$. The given $Ceiling(R_x) = \\pi_1$ is correct.\n  - Resource $R_y$ is used by $T_2$ (priority $\\pi_2$) and $T_3$ (priority $\\pi_3$). The highest priority is $\\pi_2$. The given $Ceiling(R_y) = \\pi_2$ is correct.\n  - Resource $R_z$ is used by $T_3$ (priority $\\pi_3$). The highest priority is $\\pi_3$. The given $Ceiling(R_z) = \\pi_3$ is correct.\nThe provided information is internally consistent and complete.\n- **Unrealistic or Infeasible**: The given timing values (periods, execution times, overheads) are within a realistic range for embedded and cyber-physical systems.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Solution\n\nThe solution is divided into two parts as requested by the problem statement.\n\n**1. Computation of Blocking Terms $B_i$**\n\nFirst, we calculate the total duration of each critical section, which is the sum of the base service time and the lock/unlock overhead of $2 o_{\\ell} = 2 \\times 0.03\\,\\mathrm{ms} = 0.06\\,\\mathrm{ms}$.\n- Critical section of $T_1$ on $R_x$: $C_{1x} = C_{1x}^{\\mathrm{base}} + 2 o_{\\ell} = 0.15\\,\\mathrm{ms} + 0.06\\,\\mathrm{ms} = 0.21\\,\\mathrm{ms}$.\n- Critical section of $T_2$ on $R_y$: $C_{2y} = C_{2y}^{\\mathrm{base}} + 2 o_{\\ell} = 0.18\\,\\mathrm{ms} + 0.06\\,\\mathrm{ms} = 0.24\\,\\mathrm{ms}$.\n- Critical section of $T_3$ on $R_x$: $C_{3x} = C_{3x}^{\\mathrm{base}} + 2 o_{\\ell} = 0.35\\,\\mathrm{ms} + 0.06\\,\\mathrm{ms} = 0.41\\,\\mathrm{ms}$.\n- Critical section of $T_3$ on $R_y$: $C_{3y} = C_{3y}^{\\mathrm{base}} + 2 o_{\\ell} = 0.20\\,\\mathrm{ms} + 0.06\\,\\mathrm{ms} = 0.26\\,\\mathrm{ms}$.\n- Critical section of $T_3$ on $R_z$: $C_{3z} = C_{3z}^{\\mathrm{base}} + 2 o_{\\ell} = 0.45\\,\\mathrm{ms} + 0.06\\,\\mathrm{ms} = 0.51\\,\\mathrm{ms}$.\n\nUnder the Priority Ceiling Protocol, the maximum blocking time $B_i$ for a task $T_i$ is the longest duration of any critical section of any lower-priority task $T_j$ ($Prio(T_j)  Prio(T_i)$) that accesses a resource $R_k$ whose priority ceiling is greater than or equal to the priority of task $T_i$ ($Ceiling(R_k) \\ge Prio(T_i)$).\n\n$B_i = \\max \\{C_{jk} \\mid j>i \\text{ and } Ceiling(R_k) \\ge \\pi_i \\text{ for some resource } R_k \\text{ used by } T_j \\}$\n\n**Computation of $B_1$ (for task $T_1$):**\nTask $T_1$ has priority $\\pi_1$. We consider lower-priority tasks, which are $T_2$ and $T_3$. We look for critical sections of $T_2$ or $T_3$ on resources with ceilings greater than or equal to $\\pi_1$.\nThe resource ceilings are $Ceiling(R_x)=\\pi_1$, $Ceiling(R_y)=\\pi_2$, and $Ceiling(R_z)=\\pi_3$.\nThe only resource with a ceiling $\\ge \\pi_1$ is $R_x$.\nWe must find which lower-priority tasks ($T_2, T_3$) use $R_x$. Task $T_2$ does not use $R_x$. Task $T_3$ uses $R_x$.\nTherefore, the blocking on $T_1$ can only be caused by $T_3$'s critical section on $R_x$.\n$$B_1 = C_{3x} = 0.41\\,\\mathrm{ms}$$\n\n**Computation of $B_2$ (for task $T_2$):**\nTask $T_2$ has priority $\\pi_2$. We consider the only lower-priority task, $T_3$. We look for critical sections of $T_3$ on resources with ceilings greater than or equal to $\\pi_2$.\nThe resources with ceilings $\\ge \\pi_2$ are $R_x$ (ceiling $\\pi_1$) and $R_y$ (ceiling $\\pi_2$).\nTask $T_3$ uses both $R_x$ and $R_y$. The possible sources of blocking for $T_2$ are the critical sections $C_{3x}$ and $C_{3y}$. The blocking term $B_2$ is the maximum of these durations.\n$$B_2 = \\max(C_{3x}, C_{3y}) = \\max(0.41\\,\\mathrm{ms}, 0.26\\,\\mathrm{ms}) = 0.41\\,\\mathrm{ms}$$\n\n**Computation of $B_3$ (for task $T_3$):**\nTask $T_3$ is the lowest-priority task. There are no lower-priority tasks that can block it. Therefore, its blocking term due to priority inversion is zero.\n$$B_3 = 0\\,\\mathrm{ms}$$\n\nRounding these values to four significant figures yields:\n$B_1 = 0.4100\\,\\mathrm{ms}$\n$B_2 = 0.4100\\,\\mathrm{ms}$\n$B_3 = 0.0000\\,\\mathrm{ms}$\n\n**2. Scenario Demonstrating the At-Most-One-Blocking Property for $T_1$**\n\nThe at-most-one-blocking property of PCP guarantees that a high-priority task can be blocked by at most one critical section of any lower-priority task. The mechanism preventing further blocking (i.e., chain blocking) relies on the interplay between the system priority ceiling and the priority of tasks requesting resources.\n\nLet us construct a scenario to demonstrate this. The worst-case blocking for $T_1$ occurs when it is released just after a lower-priority task ($T_3$) has locked a resource ($R_x$) that can block $T_1$.\n\n**Concrete Scenario Timeline**\nLet $t$ denote time. Priorities are $\\pi_1 > \\pi_2 > \\pi_3$. The system ceiling, $C_{sys}$, is the maximum of the ceilings of all currently locked resources. Initially, $C_{sys}$ is null (or $0$).\n\n- $t = t_0$: Task $T_3$ is released and begins execution.\n- $t = t_1 > t_0$: $T_3$ requests and locks resource $R_x$. According to PCP rules, a task can acquire a lock if its priority is strictly greater than the current system ceiling. Since $C_{sys}$ was null, the lock is granted. The system ceiling is immediately raised to $Ceiling(R_x) = \\pi_1$. So, now $C_{sys} = \\pi_1$.\n- $t = t_2 > t_1$: Task $T_2$ is released. Since $\\pi_2 > \\pi_3$, $T_2$ preempts $T_3$ and begins execution.\n- $t = t_3 > t_2$: Task $T_2$ attempts to lock resource $R_y$. To be granted the lock, the priority of the requesting task, $\\pi_2$, must be *strictly greater* than the current system ceiling, $C_{sys}$. Here, $C_{sys} = \\pi_1$. Since $\\pi_2$ is not strictly greater than $\\pi_1$ (in fact, $\\pi_2  \\pi_1$), the lock request is denied. Task $T_2$ is blocked. This is known as \"ceiling blocking\". The task that holds the lock causing the high ceiling ($T_3$) resumes execution.\n- $t = t_4 > t_3$: Task $T_1$ is released. Since $\\pi_1 > \\pi_3$, $T_1$ preempts $T_3$ and begins execution.\n- $t = t_5 > t_4$: Task $T_1$ runs for some time and then attempts to lock resource $R_x$. However, $R_x$ is currently held by $T_3$. Thus, $T_1$ blocks. This is \"direct blocking\". At this moment, $T_3$ inherits the priority of the task it is blocking, so $Prio(T_3)$ is elevated to $\\pi_1$.\n- $t_5$ to $t_6$: $T_3$ executes its critical section on $R_x$ with priority $\\pi_1$. Because it runs at the highest priority in the system, it cannot be preempted by any other task, including the now-ready task $T_2$. This guarantees that the critical section completes as quickly as possible.\n- $t = t_6$: $T_3$ unlocks $R_x$. Its priority reverts to $\\pi_3$, and the system ceiling $C_{sys}$ becomes null again. Task $T_1$, which was waiting for $R_x$, is unblocked and made ready.\n- $t_6$ onwards: The scheduler selects the highest-priority ready task, which is $T_1$. $T_1$ acquires the lock on $R_x$ and resumes its execution.\n\n**Explanation of Why Chain-Blocking is Prevented**\nIn this scenario, task $T_1$ was blocked only once, for a duration corresponding to the remaining execution of $T_3$'s critical section on $R_x$. The potential for chain-blocking (e.g., $T_1$ waiting for $T_2$ which in turn waits for $T_3$) was explicitly prevented by the PCP ceiling mechanism.\n\nThe key event occurred at time $t_3$. When $T_3$ locked $R_x$, it raised the system ceiling to $\\pi_1$. This ceiling acted as a protective barrier for task $T_1$. It prevented the intermediate-priority task $T_2$ from acquiring *any* resource ($R_y$ in this case) and entering its own critical section. If $T_2$ had been allowed to lock $R_y$, it would have introduced another blocking factor. By blocking $T_2$ *before* it could acquire a resource, PCP ensures that at the moment $T_1$ becomes active, there is at most one lower-priority task holding a resource that could block $T_1$. Any other lower-priority tasks that might have caused chained blocking have been prevented from entering their critical sections by the high system ceiling established by the very first lock. This mechanism is what guarantees the at-most-one-blocking property for any task under PCP.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0.4100  0.4100  0.0000 \\end{pmatrix} } $$"
        },
        {
            "introduction": "While understanding blocking in isolation is crucial, a full system analysis requires integrating this factor with other sources of delay, such as task interference and operating system overheads. This practice elevates the analysis by guiding you through a complete worst-case response time (WCRT) calculation for a task under PCP . You will learn to augment a task's execution time with realistic overheads for locking and context switching, providing a more accurate and holistic assessment of schedulability in a practical cyber-physical system.",
            "id": "4244081",
            "problem": "A cyber-physical controller executes on a single core under fixed-priority preemptive scheduling with Rate Monotonic (RM) priorities and employs the Priority Ceiling Protocol (PCP) for mutually exclusive resources. There are four periodic tasks $\\tau_{1},\\tau_{2},\\tau_{3},\\tau_{4}$ with periods equal to deadlines, i.e., $D_{i}=T_{i}$, where smaller $T_{i}$ implies higher priority. Each task $\\tau_{i}$ has worst-case execution time $C_{i}$ that includes all application-level computation within critical sections, but excludes operating system overheads such as lock/unlock system call costs and context-switch costs. Two shared resources are used: $R_{\\alpha}$ and $R_{\\beta}$. All critical section durations reported below are included in $C_{i}$ and exclude the lock/unlock overheads.\n\nSystem parameters:\n- Task specifications (all times in milliseconds): $(C_{1},T_{1})=(0.9,6)$, $(C_{2},T_{2})=(1.6,12)$, $(C_{3},T_{3})=(2.5,20)$, $(C_{4},T_{4})=(3.0,50)$.\n- Resource usage per job:\n  - $\\tau_{1}$ enters one critical section on $R_{\\alpha}$ of length $0.2$.\n  - $\\tau_{2}$ enters one critical section on $R_{\\beta}$ of length $0.35$.\n  - $\\tau_{3}$ enters one critical section on $R_{\\alpha}$ of length $0.4$ and one critical section on $R_{\\beta}$ of length $0.25$.\n  - $\\tau_{4}$ enters one critical section on $R_{\\beta}$ of length $0.6$.\n- Operating system overhead model:\n  - Each lock or unlock system call takes $\\ell=0.01$ milliseconds; thus, each critical section incurs $2\\ell$ of overhead.\n  - Each job incurs a fixed release-and-completion overhead of $\\sigma=0.04$ milliseconds (covering its dispatch and final context switch).\n  - Assume no other overheads; in particular, any preemption overhead is accounted for via the preempting job’s fixed overhead.\n\nAssume PCP with immediate ceiling priority. Using only core definitions of fixed-priority response-time analysis and PCP blocking, first determine the maximum lower-priority blocking term $B_{3}$ for $\\tau_{3}$ that is consistent with PCP, including the appropriate lock/unlock overhead within the blocking critical section. Then perform a worst-case response-time analysis for $\\tau_{3}$ that accounts for operating system overhead by augmenting each job’s processor demand with its fixed overhead and lock/unlock costs. Provide the final worst-case response time $R_{3}$ of $\\tau_{3}$.\n\nExpress the final time in milliseconds and round your answer to four significant figures.",
            "solution": "### Solution\nThe solution proceeds in two stages: first, we determine the blocking term $B_3$ for task $\\tau_3$ under PCP, and second, we perform the iterative response-time analysis for $\\tau_3$, accounting for all specified overheads.\n\n**1. Calculation of Blocking Term $B_3$**\n\nFirst, we establish task priorities and resource ceilings. Under Rate Monotonic (RM) scheduling, priority is inversely proportional to the period. With periods $T_1=6  T_2=12  T_3=20  T_4=50$, the priorities are $P_1 > P_2 > P_3 > P_4$.\n\nThe priority ceiling of each resource is the priority of the highest-priority task that uses it:\n-   Resource $R_{\\alpha}$ is used by $\\tau_1$ and $\\tau_3$. The highest priority user is $\\tau_1$. Thus, Ceiling($R_{\\alpha}$) $= P_1$.\n-   Resource $R_{\\beta}$ is used by $\\tau_2$, $\\tau_3$, and $\\tau_4$. The highest priority user is $\\tau_2$. Thus, Ceiling($R_{\\beta}$) $= P_2$.\n\nUnder PCP, the blocking term $B_i$ for a task $\\tau_i$ is the duration of the longest critical section of any lower-priority task $\\tau_k$ that uses a resource $R$ whose ceiling is greater than or equal to the priority of $\\tau_i$.\n\nFor task $\\tau_3$, the only lower-priority task is $\\tau_4$. Task $\\tau_4$ uses resource $R_{\\beta}$. We check if it can block $\\tau_3$: the condition is Ceiling($R_{\\beta}$) $\\ge P_3$. Since Ceiling($R_{\\beta}$) $= P_2$ and $P_2 > P_3$, the condition holds. Therefore, $\\tau_4$ can block $\\tau_3$. The blocking time is the duration of this critical section, including the lock/unlock overhead ($2\\ell$).\n$$B_3 = (\\text{application-level duration of } CS_{4,\\beta}) + 2\\ell$$\n$$B_3 = 0.6\\,\\text{ms} + 2 \\times 0.01\\,\\text{ms} = 0.62\\,\\text{ms}$$\n\n**2. Worst-Case Response Time (WCRT) Analysis for $\\tau_3$**\n\nThe WCRT equation is $R_i = C_i' + B_i + \\sum_{j \\in hp(i)} \\lceil R_i/T_j \\rceil C_j'$, where $C_j'$ is the augmented execution time including overheads. The augmented time for a job of task $\\tau_i$ is its base time $C_i$ plus the release/completion overhead $\\sigma$ plus the overhead for its critical sections ($N_{i,cs} \\times 2\\ell$).\n\n-   Augmented time for $\\tau_1$: $C_1' = C_1 + \\sigma + 1 \\times 2\\ell = 0.9 + 0.04 + 0.02 = 0.96\\,\\text{ms}$.\n-   Augmented time for $\\tau_2$: $C_2' = C_2 + \\sigma + 1 \\times 2\\ell = 1.6 + 0.04 + 0.02 = 1.66\\,\\text{ms}$.\n-   Augmented time for $\\tau_3$: $C_3' = C_3 + \\sigma + 2 \\times 2\\ell = 2.5 + 0.04 + 0.04 = 2.58\\,\\text{ms}$.\n\nThe WCRT equation for $\\tau_3$ is:\n$$R_3 = C_3' + B_3 + \\left\\lceil \\frac{R_3}{T_1} \\right\\rceil C_1' + \\left\\lceil \\frac{R_3}{T_2} \\right\\rceil C_2'$$\n$$R_3 = 2.58 + 0.62 + \\left\\lceil \\frac{R_3}{6} \\right\\rceil (0.96) + \\left\\lceil \\frac{R_3}{12} \\right\\rceil (1.66) = 3.20 + \\left\\lceil \\frac{R_3}{6} \\right\\rceil (0.96) + \\left\\lceil \\frac{R_3}{12} \\right\\rceil (1.66)$$\n\nWe solve iteratively, starting with $R_3^{(0)} = C_3' + B_3 = 3.20\\,\\text{ms}$.\n\n-   **Iteration 1**: $R_3^{(1)} = 3.20 + \\lceil 3.20/6 \\rceil(0.96) + \\lceil 3.20/12 \\rceil(1.66) = 3.20 + 1(0.96) + 1(1.66) = 5.82\\,\\text{ms}$.\n-   **Iteration 2**: $R_3^{(2)} = 3.20 + \\lceil 5.82/6 \\rceil(0.96) + \\lceil 5.82/12 \\rceil(1.66) = 3.20 + 1(0.96) + 1(1.66) = 5.82\\,\\text{ms}$.\n\nThe iteration converges at $R_3 = 5.82\\,\\text{ms}$. The deadline is $D_3 = 20\\,\\text{ms}$. Since $R_3 \\le D_3$, the task is schedulable. The final worst-case response time for $\\tau_3$, rounded to four significant figures, is $5.820\\,\\text{ms}$.",
            "answer": "$$\n\\boxed{5.820}\n$$"
        },
        {
            "introduction": "The theoretical models for scheduling analysis are only as good as the parameters fed into them. This final hands-on practice bridges the gap between theory and empirical measurement by tasking you with analyzing raw execution trace data from a digital twin . By writing a program to parse timestamped events, you will quantify the real-world overheads of context switching, interrupt handling, and priority inversion, learning a critical skill for validating system performance and refining the fidelity of cyber-physical system models.",
            "id": "4244069",
            "problem": "A digital twin of a cyber-physical system records execution traces of a Real-Time Operating System (RTOS). These traces consist of timestamped events corresponding to job releases and completions of tasks, context switch execution segments, interrupt handler execution segments, and segments where tasks are blocked due to priority inversion under a resource-sharing protocol such as the Priority Inheritance Protocol (PIP) or Priority Ceiling Protocol (PCP). Let each task be indexed by an integer identifier $i \\in \\mathbb{N}$, and let each job of task $i$ be indexed by an integer $k \\in \\mathbb{N}$. For each job $(i,k)$, define its active window as the half-open interval $[r_{i,k}, c_{i,k})$, where $r_{i,k}$ is the release time and $c_{i,k}$ is the completion time, both in microseconds ($\\mu$s). \n\nDefine the following per-job overhead components, measured in microseconds:\n- Context switch overhead $C_{i,k}$: the sum of the durations of all context-switch execution segments attributed to task $i$ that intersect $[r_{i,k}, c_{i,k})$.\n- Interrupt overhead $I_{i,k}$: the measure (length) of the union of all interrupt handler execution segments that intersect $[r_{i,k}, c_{i,k})$. Nested or overlapping interrupt segments must be counted only once by taking their union.\n- Priority inversion blocking overhead $P_{i,k}$: the sum of the durations of all blocking segments of task $i$ that are explicitly marked as arising from priority inversion (e.g., due to PIP or PCP) and that intersect $[r_{i,k}, c_{i,k})$.\n\nThe per-task overhead budget is defined as $\\Delta_i = \\max_k \\left( C_{i,k} + I_{i,k} + P_{i,k} \\right)$, the worst-case per-job total overhead observed for task $i$. All durations must be computed as intersection lengths of the relevant segments with the job window and expressed as integers in microseconds.\n\nInput traces are provided as ordered event lists. Each event is a triple $(t,\\ \\text{type},\\ \\text{label})$ where $t$ is a timestamp in microseconds, $\\text{type}$ is one of the following strings:\n- $\\text{JR}$ for a job release,\n- $\\text{JC}$ for a job completion,\n- $\\text{CS\\_B}$ for the beginning of a context-switch overhead segment,\n- $\\text{CS\\_E}$ for the end of a context-switch overhead segment,\n- $\\text{IRQ\\_B}$ for the beginning of an interrupt handler segment,\n- $\\text{IRQ\\_E}$ for the end of an interrupt handler segment,\n- $\\text{PI\\_B}$ for the beginning of a priority inversion blocking segment,\n- $\\text{PI\\_E}$ for the end of a priority inversion blocking segment,\nand $\\text{label}$ is either a task identifier $i$ (for $\\text{JR}$, $\\text{JC}$, $\\text{CS\\_B}$, $\\text{CS\\_E}$, $\\text{PI\\_B}$, $\\text{PI\\_E}$) or a special null label for interrupts (for $\\text{IRQ\\_B}$, $\\text{IRQ\\_E}$). For context-switch and priority inversion segments, begins and ends are properly nested per task. For interrupt segments, begins and ends are properly nested globally and may be nested within each other, requiring unioning when measuring $I_{i,k}$.\n\nYour task is to write a complete program that:\n- Parses each test case’s event list.\n- Constructs job windows $[r_{i,k}, c_{i,k})$ for each task $i$.\n- Constructs the sets of context switch intervals, interrupt intervals, and priority inversion intervals.\n- Computes $C_{i,k}$, $I_{i,k}$, and $P_{i,k}$ for each job using intersection lengths with $[r_{i,k}, c_{i,k})$, with unioning applied to interrupt intervals.\n- Aggregates these into per-task budgets $\\Delta_i$.\n- Produces the specified output format.\n\nAll times and durations must be in microseconds ($\\mu$s) and reported as integers. Angles are not involved. The final output should be a single line containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of per-task results in ascending task identifier order. For each task $i$, report a list $[C^{\\max}_i,\\ I^{\\max}_i,\\ P^{\\max}_i,\\ \\Delta_i]$ where $C^{\\max}_i = \\max_k C_{i,k}$, $I^{\\max}_i = \\max_k I_{i,k}$, $P^{\\max}_i = \\max_k P_{i,k}$. Thus, the program’s output is of the form $[[[C^{\\max}_{i_1},I^{\\max}_{i_1},P^{\\max}_{i_1},\\Delta_{i_1}],\\dots],\\dots]$ in integer microseconds, with no additional text.\n\nTest Suite:\n- Test Case $1$ (happy path, nested interrupts, single job per task):\n  - Tasks: $[1, 2, 3]$.\n  - Events (timestamps in $\\mu$s):\n    - Task $1$: $(0,\\ \\text{JR},\\ 1)$, $(0,\\ \\text{CS\\_B},\\ 1)$, $(5,\\ \\text{CS\\_E},\\ 1)$, $(120,\\ \\text{PI\\_B},\\ 1)$, $(150,\\ \\text{PI\\_E},\\ 1)$, $(200,\\ \\text{JC},\\ 1)$.\n    - Task $2$: $(20,\\ \\text{JR},\\ 2)$, $(20,\\ \\text{CS\\_B},\\ 2)$, $(25,\\ \\text{CS\\_E},\\ 2)$, $(100,\\ \\text{CS\\_B},\\ 2)$, $(105,\\ \\text{CS\\_E},\\ 2)$, $(40,\\ \\text{PI\\_B},\\ 2)$, $(45,\\ \\text{PI\\_E},\\ 2)$, $(150,\\ \\text{JC},\\ 2)$.\n    - Task $3$: $(10,\\ \\text{JR},\\ 3)$, $(10,\\ \\text{CS\\_B},\\ 3)$, $(12,\\ \\text{CS\\_E},\\ 3)$, $(180,\\ \\text{JC},\\ 3)$.\n    - Interrupts: $(50,\\ \\text{IRQ\\_B},\\ \\varnothing)$, $(60,\\ \\text{IRQ\\_B},\\ \\varnothing)$, $(65,\\ \\text{IRQ\\_E},\\ \\varnothing)$, $(70,\\ \\text{IRQ\\_E},\\ \\varnothing)$.\n- Test Case $2$ (multiple jobs per task, cropping of segments at job window boundaries, long interrupts):\n  - Tasks: $[1, 2, 3]$.\n  - Events:\n    - Task $1$: $(0,\\ \\text{JR},\\ 1)$, $(0,\\ \\text{CS\\_B},\\ 1)$, $(4,\\ \\text{CS\\_E},\\ 1)$, $(78,\\ \\text{CS\\_B},\\ 1)$, $(82,\\ \\text{CS\\_E},\\ 1)$, $(30,\\ \\text{PI\\_B},\\ 1)$, $(35,\\ \\text{PI\\_E},\\ 1)$, $(80,\\ \\text{JC},\\ 1)$, $(100,\\ \\text{JR},\\ 1)$, $(100,\\ \\text{CS\\_B},\\ 1)$, $(104,\\ \\text{CS\\_E},\\ 1)$, $(150,\\ \\text{PI\\_B},\\ 1)$, $(160,\\ \\text{PI\\_E},\\ 1)$, $(200,\\ \\text{CS\\_B},\\ 1)$, $(205,\\ \\text{CS\\_E},\\ 1)$, $(210,\\ \\text{JC},\\ 1)$.\n    - Task $2$: $(10,\\ \\text{JR},\\ 2)$, $(10,\\ \\text{CS\\_B},\\ 2)$, $(13,\\ \\text{CS\\_E},\\ 2)$, $(58,\\ \\text{CS\\_B},\\ 2)$, $(62,\\ \\text{CS\\_E},\\ 2)$, $(55,\\ \\text{PI\\_B},\\ 2)$, $(57,\\ \\text{PI\\_E},\\ 2)$, $(60,\\ \\text{JC},\\ 2)$, $(90,\\ \\text{JR},\\ 2)$, $(90,\\ \\text{CS\\_B},\\ 2)$, $(95,\\ \\text{CS\\_E},\\ 2)$, $(140,\\ \\text{JC},\\ 2)$.\n    - Task $3$: $(0,\\ \\text{JR},\\ 3)$, $(0,\\ \\text{CS\\_B},\\ 3)$, $(2,\\ \\text{CS\\_E},\\ 3)$, $(285,\\ \\text{CS\\_B},\\ 3)$, $(295,\\ \\text{CS\\_E},\\ 3)$, $(180,\\ \\text{PI\\_B},\\ 3)$, $(220,\\ \\text{PI\\_E},\\ 3)$, $(300,\\ \\text{JC},\\ 3)$.\n    - Interrupts: $(50,\\ \\text{IRQ\\_B},\\ \\varnothing)$, $(60,\\ \\text{IRQ\\_B},\\ \\varnothing)$, $(70,\\ \\text{IRQ\\_E},\\ \\varnothing)$, $(120,\\ \\text{IRQ\\_E},\\ \\varnothing)$.\n- Test Case $3$ (edge case: zero overhead):\n  - Tasks: $[1, 2, 3]$.\n  - Events:\n    - Task $1$: $(0,\\ \\text{JR},\\ 1)$, $(50,\\ \\text{JC},\\ 1)$.\n    - Task $2$: $(0,\\ \\text{JR},\\ 2)$, $(50,\\ \\text{JC},\\ 2)$.\n    - Task $3$: $(10,\\ \\text{JR},\\ 3)$, $(20,\\ \\text{JC},\\ 3)$.\n    - Interrupts: $(60,\\ \\text{IRQ\\_B},\\ \\varnothing)$, $(80,\\ \\text{IRQ\\_E},\\ \\varnothing)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is a list of $[C^{\\max}_i,\\ I^{\\max}_i,\\ P^{\\max}_i,\\ \\Delta_i]$ for tasks $i$ listed in ascending order. All reported values must be integers in microseconds ($\\mu$s).",
            "solution": "The problem statement has been validated and found to be scientifically sound, well-posed, and objective. It presents a clearly defined computational task rooted in the established principles of real-time operating systems analysis, specifically concerning scheduling overheads in cyber-physical systems. The provided definitions and constraints are self-contained and sufficient for deriving a unique, verifiable solution.\n\nThe solution methodology involves a multi-pass analysis of the event trace for each test case. First, the raw event stream is parsed to construct abstract representations of job execution windows and various overhead-inducing time intervals. Subsequently, for each job of each task, the specified overhead metrics are computed by applying geometric operations (intersection, union) between the job's active window and the relevant overhead intervals. Finally, these per-job metrics are aggregated to determine the worst-case per-task overheads.\n\n**Step 1: Event Trace Parsing and Data Structuring**\n\nThe initial step is to process the chronologically ordered list of events to build structured data representing job lifetimes and overhead intervals. We use dictionaries mapping task identifiers to lists of associated objects.\n\n- **Job Windows**: For each task $i$, we identify all job releases ($\\text{JR}$) and completions ($\\text{JC}$). A job release event $(t_{JR}, \\text{'JR'}, i)$ marks the start time $r_{i,k} = t_{JR}$ of a new job $k$ for task $i$. The subsequent completion event $(t_{JC}, \\text{'JC'}, i)$ for the same task defines the job's completion time $c_{i,k} = t_{JC}$. This forms the half-open active window $[r_{i,k}, c_{i,k})$. These windows are stored, for instance, in a dictionary mapping each task ID $i$ to a list of its job windows.\n\n- **Overhead Intervals**: Similarly, we parse begin/end events for each overhead type.\n    - **Context Switch ($CS$) and Priority Inversion ($PI$) Intervals**: Events of type $\\text{CS\\_B}$/$\\text{CS\\_E}$ and $\\text{PI\\_B}$/$\\text{PI\\_E}$ are task-specific. For each task $i$, we match each begin event $(t_B, \\text{TYPE\\_B}, i)$ with its corresponding end event $(t_E, \\text{TYPE\\_E}, i)$ to form an interval $[t_B, t_E)$. These are stored in per-task lists. The problem statement guarantees proper nesting per task, simplifying the matching process.\n    - **Interrupt ($IRQ$) Intervals**: Interrupts are global and can be nested. An $\\text{IRQ\\_B}$ event at time $t_B$ is pushed onto a stack. An $\\text{IRQ\\_E}$ event at time $t_E$ is matched with the most recent unmatched $\\text{IRQ\\_B}$ time, say $t_B'$, popped from the stack. This defines an interrupt interval $[t_B', t_E)$, which is added to a global list of interrupt intervals.\n\n**Step 2: Per-Job Overhead Calculation**\n\nFor each job $(i,k)$ with active window $[r_{i,k}, c_{i,k})$, we calculate its three overhead components: $C_{i,k}$, $P_{i,k}$, and $I_{i,k}$. This requires calculating the length of the intersection of overhead intervals with the job's active window. For an interval $A = [s, e)$ and a job window $W = [r, c)$, their intersection is $A \\cap W = [\\max(r, s), \\min(c, e))$. The length, or measure, of this intersection is $\\mu(A \\cap W) = \\max(0, \\min(c, e) - \\max(r, s))$.\n\n- **Context Switch Overhead ($C_{i,k}$)**: This is the sum of the intersection lengths of all of task $i$'s context switch intervals with the job window $[r_{i,k}, c_{i,k})$.\n$$ C_{i,k} = \\sum_{j} \\mu \\left( CS_{i,j} \\cap [r_{i,k}, c_{i,k}) \\right) $$\nwhere $CS_{i,j}$ are the context switch intervals for task $i$.\n\n- **Priority Inversion Overhead ($P_{i,k}$)**: This is calculated identically to $C_{i,k}$, but using task $i$'s priority inversion intervals $PI_{i,j}$.\n$$ P_{i,k} = \\sum_{j} \\mu \\left( PI_{i,j} \\cap [r_{i,k}, c_{i,k}) \\right) $$\n\n- **Interrupt Overhead ($I_{i,k}$)**: This calculation is more involved as it requires computing the measure of a union of intervals. First, we find all global interrupt intervals $IRQ_j$ that intersect with the job window. We then clip each of these intervals to the job window: $IRQ'_j = IRQ_j \\cap [r_{i,k}, c_{i,k})$. The overhead $I_{i,k}$ is the measure of the union of all such clipped intervals.\n$$ I_{i,k} = \\mu \\left( \\bigcup_{j} \\left( IRQ_j \\cap [r_{i,k}, c_{i,k}) \\right) \\right) $$\nTo compute the measure of the union of a set of intervals, a standard algorithm is used:\n1. Sort the intervals by their start times.\n2. Initialize a list of merged, disjoint intervals with the first interval.\n3. Iterate through the sorted intervals, merging each with the last interval in the merged list if they overlap or are adjacent. If not, append it as a new disjoint interval.\n4. Sum the lengths of the intervals in the final merged list.\n\n**Step 3: Per-Task Budget Aggregation**\n\nAfter computing the overheads for every job of a given task $i$, we aggregate these values to find the worst-case figures.\n\n- **Maximum Individual Overheads**:\n$$ C^{\\max}_i = \\max_{k} C_{i,k} $$\n$$ I^{\\max}_i = \\max_{k} I_{i,k} $$\n$$ P^{\\max}_i = \\max_{k} P_{i,k} $$\n\n- **Total Overhead Budget ($\\Delta_i$)**: This is the maximum total overhead observed across all jobs of task $i$.\n$$ \\Delta_i = \\max_{k} \\left( C_{i,k} + I_{i,k} + P_{i,k} \\right) $$\n\nThese four values—$C^{\\max}_i$, $I^{\\max}_i$, $P^{\\max}_i$, and $\\Delta_i$—are computed for each task. The final result for a test case is an ordered list of these quadruplets, sorted by task identifier $i$.",
            "answer": "```python\nimport collections\n\n# numpy and scipy are not required for this problem.\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"tasks\": [1, 2, 3],\n            \"events\": [\n                (0, 'JR', 1), (0, 'CS_B', 1), (5, 'CS_E', 1), (120, 'PI_B', 1), (150, 'PI_E', 1), (200, 'JC', 1),\n                (20, 'JR', 2), (20, 'CS_B', 2), (25, 'CS_E', 2), (100, 'CS_B', 2), (105, 'CS_E', 2), (40, 'PI_B', 2), (45, 'PI_E', 2), (150, 'JC', 2),\n                (10, 'JR', 3), (10, 'CS_B', 3), (12, 'CS_E', 3), (180, 'JC', 3),\n                (50, 'IRQ_B', None), (60, 'IRQ_B', None), (65, 'IRQ_E', None), (70, 'IRQ_E', None)\n            ]\n        },\n        {\n            \"tasks\": [1, 2, 3],\n            \"events\": [\n                (0, 'JR', 1), (0, 'CS_B', 1), (4, 'CS_E', 1), (78, 'CS_B', 1), (82, 'CS_E', 1), (30, 'PI_B', 1), (35, 'PI_E', 1), (80, 'JC', 1),\n                (100, 'JR', 1), (100, 'CS_B', 1), (104, 'CS_E', 1), (150, 'PI_B', 1), (160, 'PI_E', 1), (200, 'CS_B', 1), (205, 'CS_E', 1), (210, 'JC', 1),\n                (10, 'JR', 2), (10, 'CS_B', 2), (13, 'CS_E', 2), (58, 'CS_B', 2), (62, 'CS_E', 2), (55, 'PI_B', 2), (57, 'PI_E', 2), (60, 'JC', 2),\n                (90, 'JR', 2), (90, 'CS_B', 2), (95, 'CS_E', 2), (140, 'JC', 2),\n                (0, 'JR', 3), (0, 'CS_B', 3), (2, 'CS_E', 3), (285, 'CS_B', 3), (295, 'CS_E', 3), (180, 'PI_B', 3), (220, 'PI_E', 3), (300, 'JC', 3),\n                (50, 'IRQ_B', None), (60, 'IRQ_B', None), (70, 'IRQ_E', None), (120, 'IRQ_E', None)\n            ]\n        },\n        {\n            \"tasks\": [1, 2, 3],\n            \"events\": [\n                (0, 'JR', 1), (50, 'JC', 1),\n                (0, 'JR', 2), (50, 'JC', 2),\n                (10, 'JR', 3), (20, 'JC', 3),\n                (60, 'IRQ_B', None), (80, 'IRQ_E', None)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case[\"events\"], case[\"tasks\"])\n        results.append(result)\n\n    # Format the final output string to be exactly as required (no spaces).\n    results_str = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\ndef _measure_union(intervals):\n    \"\"\"Calculates the measure (total length) of the union of a list of intervals.\"\"\"\n    if not intervals:\n        return 0\n    \n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = []\n    current_start, current_end = intervals[0]\n    \n    for next_start, next_end in intervals[1:]:\n        if next_start  current_end:\n            current_end = max(current_end, next_end)\n        else:\n            merged.append((current_start, current_end))\n            current_start, current_end = next_start, next_end\n    merged.append((current_start, current_end))\n    \n    total_length = sum(end - start for start, end in merged)\n    return total_length\n\ndef _calculate_intersection_sum(job_window, intervals):\n    \"\"\"Calculates the sum of intersection lengths of intervals with a job window.\"\"\"\n    r, c = job_window\n    total_duration = 0\n    for s, e in intervals:\n        overlap_start = max(r, s)\n        overlap_end = min(c, e)\n        duration = max(0, overlap_end - overlap_start)\n        total_duration += duration\n    return total_duration\n\ndef _calculate_union_measure(job_window, intervals):\n    \"\"\"Calculates the measure of the union of intervals, clipped to a job window.\"\"\"\n    r, c = job_window\n    clipped_intervals = []\n    for s, e in intervals:\n        overlap_start = max(r, s)\n        overlap_end = min(c, e)\n        if overlap_start  overlap_end:\n            clipped_intervals.append((overlap_start, overlap_end))\n    return _measure_union(clipped_intervals)\n\ndef _process_case(events, tasks):\n    \"\"\"Processes a single test case's event list to compute overheads.\"\"\"\n    \n    # Sort events by timestamp to ensure chronological order\n    events.sort(key=lambda x: x[0])\n\n    # Data structures for parsing\n    jobs = collections.defaultdict(list)\n    cs_intervals = collections.defaultdict(list)\n    pi_intervals = collections.defaultdict(list)\n    irq_intervals = []\n\n    # Temporary storage for matching begin/end events\n    open_jr = {}\n    open_cs = collections.defaultdict(list)\n    open_pi = collections.defaultdict(list)\n    open_irq = []\n\n    for t, type, label in events:\n        if type == 'JR':\n            if label not in open_jr:\n                open_jr[label] = []\n            open_jr[label].append(t)\n        elif type == 'JC':\n            r_time = open_jr[label].pop(0)\n            jobs[label].append((r_time, t))\n        elif type == 'CS_B':\n            open_cs[label].append(t)\n        elif type == 'CS_E':\n            s_time = open_cs[label].pop()\n            cs_intervals[label].append((s_time, t))\n        elif type == 'PI_B':\n            open_pi[label].append(t)\n        elif type == 'PI_E':\n            s_time = open_pi[label].pop()\n            pi_intervals[label].append((s_time, t))\n        elif type == 'IRQ_B':\n            open_irq.append(t)\n        elif type == 'IRQ_E':\n            s_time = open_irq.pop()\n            irq_intervals.append((s_time, t))\n    \n    case_results = []\n    for task_id in sorted(tasks):\n        max_c, max_i, max_p, max_delta = 0, 0, 0, 0\n        \n        if task_id not in jobs:\n            case_results.append([0, 0, 0, 0])\n            continue\n            \n        task_jobs = jobs[task_id]\n        task_cs = cs_intervals.get(task_id, [])\n        task_pi = pi_intervals.get(task_id, [])\n\n        for job_window in task_jobs:\n            c_ik = _calculate_intersection_sum(job_window, task_cs)\n            p_ik = _calculate_intersection_sum(job_window, task_pi)\n            i_ik = _calculate_union_measure(job_window, irq_intervals)\n            \n            total_overhead_ik = c_ik + i_ik + p_ik\n            \n            max_c = max(max_c, c_ik)\n            max_i = max(max_i, i_ik)\n            max_p = max(max_p, p_ik)\n            max_delta = max(max_delta, total_overhead_ik)\n            \n        case_results.append([int(max_c), int(max_i), int(max_p), int(max_delta)])\n        \n    return case_results\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}