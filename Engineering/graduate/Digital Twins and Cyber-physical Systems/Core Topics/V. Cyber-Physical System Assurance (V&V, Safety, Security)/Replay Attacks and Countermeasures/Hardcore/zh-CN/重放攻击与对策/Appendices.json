{
    "hands_on_practices": [
        {
            "introduction": "时间戳是抵御重放攻击的常用方法，但其有效性严重依赖于系统的时序参数。本练习旨在引导您推导时钟同步误差的基本限制，从而具体理解系统约束与安全保证之间的权衡。通过分析时钟偏移（$\\delta$）、网络延迟（$\\Delta$）和新鲜度要求（$\\tau$）之间的关系，您将确定一个可行的“新鲜度窗口”$W$存在的条件。",
            "id": "4240578",
            "problem": "一个信息物理系统（CPS）的数字孪生使用基于时间戳的新鲜度来缓解重放攻击。发送方在真实生成时间 $t_{\\mathrm{gen}}$ 从其本地时钟 $C_{s}(t)$ 获取一个时间戳 $t_{s}$ 并附加到数据包上。接收方使用其本地时钟 $C_{r}(t)$，仅当观测到的时间差 $C_{r}(t_{\\mathrm{acc}})-t_{s}$ 小于一个新鲜度窗口 $W$ 时，才接受数据包，其中 $t_{\\mathrm{acc}}$ 是真实接受时间。假设以下基本属性成立，这些属性在 CPS 的时间同步分析中被广泛使用：\n- 时钟经过规整，使其瞬时速率失配在感兴趣的时间尺度上可以忽略不计；主要误差是两个时钟之间有界的偏移（偏斜）。形式上，存在一个界限 $\\delta$，使得对于任何真实时间 $t$，读数之差满足 $|C_{r}(t)-C_{s}(t)|\\leq \\delta$。\n- 单向网络延迟由一个已知的常数 $\\Delta$ 界定，因此任何合法数据包的真实龄期 $A:=t_{\\mathrm{acc}}-t_{\\mathrm{gen}}\\leq \\Delta$。\n- 攻击者可以在稍后的时间重放任何先前观测到的数据包。为确保新鲜度，安全目标是任何真实龄期满足 $A\\geq \\tau$ 的重放包都必须被拒绝。\n\n仅从这些基本定义和界限出发，推导可接受的时钟偏移 $\\delta$（以秒为单位）的最紧张上界，在该上界下存在一个新鲜度窗口 $W$，能够同时保证：\n1. 不会错误地拒绝任何在有界网络延迟 $\\Delta$ 内传输的合法数据包。\n2. 保证拒绝任何龄期超过 $\\tau$ 的重放包。\n\n您的答案必须是关于最大允许 $\\delta$ 的一个单一封闭形式解析表达式，用 $\\tau$ 和 $\\Delta$ 表示。该界限以秒为单位表示。无需进行数值四舍五入。",
            "solution": "该问题要求推导时钟偏移 $\\delta$ 的最紧张上界，该上界允许存在一个新鲜度窗口 $W$ 来区分合法数据包和老化的重放攻击。我们首先将问题陈述中给出的两个主要条件形式化。\n\n安全机制的核心是接收方的检查：当且仅当一个数据包的关联时间差小于新鲜度窗口 $W$ 时，该数据包才被接受。时间差由 $C_{r}(t_{\\mathrm{acc}}) - t_{s}$ 给出，其中 $t_{s}$ 是发送方应用的时间戳，$t_{s} = C_{s}(t_{\\mathrm{gen}})$。因此，接受条件是：\n$$C_{r}(t_{\\mathrm{acc}}) - C_{s}(t_{\\mathrm{gen}})  W$$\n拒绝条件是其否定形式：\n$$C_{r}(t_{\\mathrm{acc}}) - C_{s}(t_{\\mathrm{gen}}) \\geq W$$\n\n我们已知时钟速率是同步的，意味着它们的进展速率与真实时间相匹配，唯一的误差是一个有界的偏移。这可以建模为 $C_{s}(t) = t + o_{s}$ 和 $C_{r}(t) = t + o_{r}$，其中 $o_{s}$ 和 $o_{r}$ 是某个常数偏移。时钟偏移的界限由 $|C_{r}(t) - C_{s}(t)| \\leq \\delta$ 给出，适用于任何真实时间 $t$。这可以简化为 $|(t+o_{r}) - (t+o_{s})| \\leq \\delta$，即 $|o_{r}-o_{s}| \\leq \\delta$。设常数时钟差为 $\\epsilon = o_{r} - o_{s}$。那么 $-\\delta \\leq \\epsilon \\leq \\delta$。\n\n通过加上和减去 $C_{s}(t_{\\mathrm{acc}})$，可以重写时间差项：\n$$C_{r}(t_{\\mathrm{acc}}) - C_{s}(t_{\\mathrm{gen}}) = (C_{r}(t_{\\mathrm{acc}}) - C_{s}(t_{\\mathrm{acc}})) + (C_{s}(t_{\\mathrm{acc}}) - C_{s}(t_{\\mathrm{gen}}))$$\n由于速率同步，第二项是：\n$$C_{s}(t_{\\mathrm{acc}}) - C_{s}(t_{\\mathrm{gen}}) = (t_{\\mathrm{acc}} + o_{s}) - (t_{\\mathrm{gen}} + o_{s}) = t_{\\mathrm{acc}} - t_{\\mathrm{gen}}$$\n这就是数据包的真实龄期，用 $A$ 表示。第一项是常数时钟偏移 $\\epsilon$。\n因此，检查的不等式变为：接受条件是 $\\epsilon + A  W$，拒绝条件是 $\\epsilon + A \\geq W$。\n\n现在，我们分析我们选择的 $W$ 必须满足的两个条件。\n\n**1. 不会错误地拒绝合法数据包**\n这个条件要求所有合法数据包都被接受。一个合法数据包的真实龄期为 $A = t_{\\mathrm{acc}} - t_{\\mathrm{gen}}$，满足 $0 \\leq A \\leq \\Delta$。为保证接受，条件 $\\epsilon + A  W$ 必须对所有对应于合法数据包的 $\\epsilon$ 和 $A$ 的可能值都成立。这意味着 $W$ 必须大于 $\\epsilon + A$ 的最大可能值。\n$\\epsilon$ 的最大值是 $\\delta$。\n一个合法数据包的 $A$ 的最大值是 $\\Delta$。\n因此，一个合法数据包的测量差的最大值是 $\\delta + \\Delta$。\n为确保所有此类数据包都被接受，我们必须选择 $W$ 使得：\n$$W > \\delta + \\Delta$$\n\n**2. 保证拒绝老化的重放包**\n这个条件要求任何真实龄期 $A \\geq \\tau$ 的数据包都必须被拒绝。为保证拒绝，条件 $\\epsilon + A \\geq W$ 必须对所有对应于此类重放包的 $\\epsilon$ 和 $A$ 的可能值都成立。这意味着 $W$ 必须小于或等于 $\\epsilon + A$ 的最小可能值。\n$\\epsilon$ 的最小值是 $-\\delta$。\n一个必须被拒绝的数据包的 $A$ 的最小值是 $\\tau$。\n因此，一个必须被拒绝的数据包的测量差的最小值是 $\\tau - \\delta$。\n为确保所有此类数据包都被拒绝，我们必须选择 $W$ 使得：\n$$W \\leq \\tau - \\delta$$\n\n**推导 $\\delta$ 的界限**\n为了使系统按要求运行，必须存在一个新鲜度窗口 $W$ 的值，该值能同时满足两个推导出的不等式：\n$$\\delta + \\Delta  W \\leq \\tau - \\delta$$\n一个满足这些界限的实数 $W$ 存在的充要条件是下界严格小于上界：\n$$\\delta + \\Delta  \\tau - \\delta$$\n我们重新整理这个不等式来求解 $\\delta$：\n$$2\\delta  \\tau - \\Delta$$\n$$\\delta  \\frac{\\tau - \\Delta}{2}$$\n这个不等式给出了时钟偏移 $\\delta$ 必须满足的条件，在此条件下可以配置一个合适的新鲜度窗口 $W$。问题要求的是 $\\delta$ 的最紧张上界。所有允许的 $\\delta$ 值的集合是区间 $[0, \\frac{\\tau - \\Delta}{2})$。这个集合的上确界，即最小上界，是 $\\frac{\\tau - \\Delta}{2}$。\n\n至关重要的是要注意到，为了存在一个 $\\delta > 0$ 的非平凡解，我们必须有 $\\tau - \\Delta > 0$，这意味着 $\\tau > \\Delta$。这在物理上是直观的：将数据包拒绝为“陈旧”的阈值（$\\tau$）必须大于“新鲜”合法数据包的最大可能传输时间（$\\Delta$）。如果 $\\tau \\leq \\Delta$，那么接受和拒绝的条件将是矛盾的，解也就不存在了。\n\n可接受的时钟偏移 $\\delta$ 的最紧张上界是 $\\frac{\\tau - \\Delta}{2}$。",
            "answer": "$$\\boxed{\\frac{\\tau - \\Delta}{2}}$$"
        },
        {
            "introduction": "除了理论分析，构建稳健的防御措施需要将抽象规则转化为具体实现。本实践将指导您编写一个复杂的滑动窗口机制，该机制能够同时处理消息的乱序和丢失，从而巩固您对基于序列号的防御措施在实践中如何运作的理解。您将实现一个能够容忍最多 $r$ 个位置的乱序和最多 $\\ell$ 个序列号跳跃的方案。",
            "id": "4240564",
            "problem": "信息物理系统 (CPS) 的数字孪生必须通过对带有单调递增序列号的消息执行接受规则来防御重放攻击。发送方生成带有严格递增序列号的消息以表示新鲜度。由于网络抖动，接收方可能会观察到消息乱序到达，并可能由于信道损伤而经历消息丢失。攻击者可能试图注入先前看到的消息或过度推进序列号空间以使状态失步。设计并实现一个使用滑动窗口的序列号接受方案，该方案能容忍最多 $r$ 的乱序和最多 $\\ell$ 的丢失，并明确指定接收方的状态更新和拒绝规则。\n\n基本原理和定义：\n- 重放攻击是重新传输先前有效的消息，以引发错误的状态转换或资源耗尽。单调序列号对已发送的消息强制执行一个全序关系；通过拒绝陈旧或重复的序列号来确保接收方的新鲜度。\n- 接收方跟踪已接受的最高序列号，表示为 $H \\in \\mathbb{N}$，以及一个固定大小的位向量 $B \\in \\{0,1\\}^{W}$ 作为滑动窗口，其中 $W = r + 1$。位 $B[i]$ 表示序列号 $H - i$ 是否已被看到（$1$）或未被看到（$0$），对于 $i \\in \\{0,\\dots,r\\}$。因此，该窗口覆盖区间 $\\{H - r, H - r + 1, \\dots, H\\}$。\n- 最多 $\\ell$ 的丢失容忍度意味着，在当前已接受的最高序列号 $H$ 的基础上，最多向前跳跃 $\\ell$ 是可接受的。\n\n对于序列号为 $S \\in \\mathbb{N}$ 的数据包的接受和拒绝规则：\n1. 如果 $S \\leq H$，计算 $\\Delta = H - S$。\n   - 如果 $\\Delta > r$，则因陈旧（窗口之外）而拒绝。\n   - 如果 $\\Delta \\leq r$ 且 $B[\\Delta] = 1$，则因重放副本（已在窗口内看到）而拒绝。\n   - 如果 $\\Delta \\leq r$ 且 $B[\\Delta] = 0$，则接受并设置 $B[\\Delta] \\leftarrow 1$。\n2. 如果 $S > H$，计算向前跳跃 $L = S - H$。\n   - 如果 $L > \\ell$，则因超出丢失容忍度边界（防御过度跳跃的上限）而拒绝。\n   - 如果 $L \\leq \\ell$，则接受，将窗口前移 $L$，并更新状态：\n     - 设置 $H \\leftarrow S$。\n     - 构建一个新的位向量 $B_{\\text{new}} \\in \\{0,1\\}^{W}$，其中对于所有 $j \\in \\{0,\\dots,r\\}$：\n       $$B_{\\text{new}}[j + L] \\leftarrow B[j] \\quad \\text{if } j + L \\leq r,\\quad \\text{else dropped as it falls outside the window.}$$\n     - 设置 $B_{\\text{new}}[0] \\leftarrow 1$ 以标记 $S$ 已被看到。\n     - 替换 $B \\leftarrow B_{\\text{new}}$。\n\n你的任务是实现这个接受方案，使其成为一个程序。该程序在给定特定的 $(r,\\ell)$ 对和到达序列时，为每个测试用例中的每条消息生成一个布尔值列表，以指示接受（$\\text{True}$）或拒绝（$\\text{False}$）。程序必须是自包含的，并且不得读取输入；它必须在内部定义并运行以下测试套件。不涉及任何物理单位或角度单位。所有输出都必须是确定性的，并以 Python 布尔值列表的形式表示。\n\n测试套件参数和序列（每个测试用例是一个三元组 $(r,\\ell,\\text{sequence})$）：\n- 测试用例 1: $r = 3$, $\\ell = 5$, 序列 $[\\,1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\,]$。\n- 测试用例 2: $r = 3$, $\\ell = 5$, 序列 $[\\,1, 2, 4, 3, 6, 5, 7\\,]$。\n- 测试用例 3: $r = 2$, $\\ell = 5$, 序列 $[\\,1, 2, 3, 4, 5, 2\\,]$。\n- 测试用例 4: $r = 3$, $\\ell = 2$, 序列 $[\\,1, 2, 4\\,]$。\n- 测试用例 5: $r = 3$, $\\ell = 2$, 序列 $[\\,1, 2, 5\\,]$。\n- 测试用例 6: $r = 3$, $\\ell = 10$, 序列 $[\\,1, 2, 3, 3\\,]$。\n- 测试用例 7: $r = 3$, $\\ell = 3$, 序列 $[\\,1, 3, 4, 5, 2\\,]$。\n- 测试用例 8: $r = 3$, $\\ell = 10$, 序列 $[\\,5, 6, 7, 8, 4\\,]$。\n- 测试用例 9: $r = 2$, $\\ell = 3$, 序列 $[\\,1, 4, 2\\,]$。\n- 测试用例 10: $r = 2$, $\\ell = 3$, 序列 $[\\,1, 4, 1\\,]$。\n\n你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的、每个测试用例一个布尔值列表的列表，并用方括号括起来。例如，输出格式必须与 $[\\,\\text{list}_{1},\\text{list}_{2},\\dots,\\text{list}_{10}\\,]$ 完全一样，没有空格，其中每个 $\\text{list}_{i}$ 的形式为 $[\\,\\text{True},\\text{False},\\dots\\,]$，对应于相应的测试用例。",
            "solution": "该问题要求为信息物理系统的数字孪生设计并实现一个基于序列号的重放攻击防御机制。该方案采用滑动窗口来容忍网络乱序和数据包丢失，同时拒绝陈旧或重放的消息。\n\n解决方案的核心是一个状态机，它处理一连串传入的消息，每条消息由一个序列号 $S \\in \\mathbb{N}$ 标识。接收方的状态由两个变量定义：\n1.  $H \\in \\mathbb{N}$：到目前为止已接受的最高序列号。\n2.  $B \\in \\{0,1\\}^{W}$：一个大小为 $W = r + 1$ 的位向量，其中 $r$ 是乱序容忍度。该向量充当滑动窗口。位 $B[i]$ 为 $1$ 表示序列号 $H-i$ 已被接收和接受，而 $0$ 表示尚未接收。因此，该窗口跟踪范围在 $[H-r, H]$ 内的序列号的接收状态。\n\n系统初始化时 $H=0$，位向量 $B$ 全为零。这表示在任何消息被接受之前的状态。\n\n对于每个带有序列号 $S$ 的传入消息，根据一组确定性规则来决定接受或拒绝，这些规则取决于 $S$ 与当前已接受的最高序列号 $H$ 之间的关系。\n\n**情况1：$S \\leq H$（序列号不是新的）**\n\n这种情况处理不比最新消息更靠前的消息。这些可能是延迟到达的乱序数据包，或者是旧数据包的恶意重放。\n\n-   首先，我们计算距离 $\\Delta = H - S$。这个 $\\Delta$ 表示序列号 $S$ 相对于 $H$ 来说是多久以前的。\n-   **陈旧性检查**：如果 $\\Delta > r$，序列号 $S$ 落在了我们滑动窗口的左边界之外（即 $S  H-r$）。这样的消息被认为是陈旧的并被拒绝。此规则为乱序数据包强制执行了有限的内存。\n-   **重放检查**：如果 $\\Delta \\leq r$，序列号 $S$ 在窗口范围内。然后我们检查位向量中对应的索引 $B[\\Delta]$。\n    -   如果 $B[\\Delta] = 1$，这意味着序列号为 $S = H - \\Delta$ 的消息已经被接受。因此，这个传入的消息是一个副本（潜在的重放攻击）并被拒绝。\n    -   如果 $B[\\Delta] = 0$，该消息在可接受的乱序窗口内且之前未被看到。它被接受。为防止将来对同一序列号的重放，我们通过设置 $B[\\Delta] \\leftarrow 1$ 来更新状态。在这种情况下，$H$ 保持不变。\n\n**情况2：$S > H$（序列号是新的）**\n\n这种情况处理推进序列号的消息，表明通信取得了进展。\n\n-   首先，我们计算向前跳跃 $L = S - H$。\n-   **过度跳跃检查**：序列号的巨大跳跃可能表示大规模的数据包丢失，或者是攻击者试图通过将序列号空间推进到遥远的未来以使接收方失步的恶意尝试。为了防范这种情况，我们使用一个防御性上限。如果跳跃 $L$ 超过了预定义的丢失容忍度 $\\ell$（即 $L > \\ell$），则该消息被拒绝。\n-   **接受与状态推进**：如果 $L \\leq \\ell$，则认为该跳跃是可接受的。该消息被接受，并且接收方的状态必须被推进。\n    1.  已接受的最高序列号更新为新值：$H \\leftarrow S$。\n    2.  滑动窗口 $B$ 必须被移动以对应新的范围 $[S-r, S]$。由于 $S = (\\text{旧 } H) + L$，新窗口实际上向前移动了 $L$ 个位置。构造一个大小为 $W$ 的新位向量 $B_{\\text{new}}$。$B$ 中的旧状态位被移动到它们的新位置：对于每个索引 $j \\in \\{0, \\dots, r\\}$，$B[j]$ 的值（代表旧序列号 $H-j$）被移动到 $B_{\\text{new}}[j+L]$（代表相同的序列号，现在是 $S-(j+L)$）。仅当新索引 $j+L$ 仍在窗口内时（即 $j+L \\leq r$），才会进行此复制。旧窗口中会被移出索引 $r$ 之外的位将被丢弃。$B_{\\text{new}}$ 中未被此移位操作填充的任何位置都初始化为 $0$。\n    3.  新的序列号 $S$ 必须被标记为已接收。这通过将新窗口的第一个位设置为 $1$ 来完成：$B_{\\text{new}}[0] \\leftarrow 1$。\n    4.  最后，旧的位向量被新的位向量替换：$B \\leftarrow B_{\\text{new}}$。\n\n这就完成了对单个消息的处理逻辑。对序列中的每条消息重复此过程，状态 $(H, B)$ 从一步传递到下一步。实现部分将这个状态机转换为一个处理给定测试用例的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the sequence-number acceptance scheme.\n    \"\"\"\n\n    test_cases = [\n        (3, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n        (3, 5, [1, 2, 4, 3, 6, 5, 7]),\n        (2, 5, [1, 2, 3, 4, 5, 2]),\n        (3, 2, [1, 2, 4]),\n        (3, 2, [1, 2, 5]),\n        (3, 10, [1, 2, 3, 3]),\n        (3, 3, [1, 3, 4, 5, 2]),\n        (3, 10, [5, 6, 7, 8, 4]),\n        (2, 3, [1, 4, 2]),\n        (2, 3, [1, 4, 1]),\n    ]\n\n    all_results = []\n    for r, l, sequence in test_cases:\n        all_results.append(process_sequence(r, l, sequence))\n\n    stringified_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(stringified_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\ndef process_sequence(r, ell, sequence):\n    \"\"\"\n    Processes a sequence of incoming packets based on the sliding window algorithm.\n\n    Args:\n        r (int): Reordering tolerance.\n        ell (int): Loss tolerance.\n        sequence (list[int]): A list of incoming sequence numbers.\n\n    Returns:\n        list[bool]: A list of booleans indicating acceptance (True) or rejection (False).\n    \"\"\"\n    W = r + 1\n    H = 0\n    B = np.zeros(W, dtype=int)\n    results = []\n\n    for S in sequence:\n        accepted = False\n        if S = 0: # Sequence numbers must be positive integers\n            results.append(False)\n            continue\n            \n        if S = H:\n            delta = H - S\n            if delta > r:\n                # Reject: Stale, outside the window\n                accepted = False\n            elif B[delta] == 1:\n                # Reject: Replay, already seen within the window\n                accepted = False\n            else:  # delta = r and B[delta] == 0\n                # Accept: Within window and not yet seen\n                accepted = True\n                B[delta] = 1\n        else:  # S > H\n            L = S - H\n            if L > ell:\n                # Reject: Excessive leap, exceeds loss tolerance\n                accepted = False\n            else:  # L = ell\n                # Accept: New sequence number within tolerance\n                accepted = True\n                \n                # Advance state\n                H = S\n                \n                # Construct new bit vector by shifting the window\n                B_new = np.zeros(W, dtype=int)\n                \n                # Shift old window contents if they are still within the new window's range\n                if L  W:\n                    num_to_copy = W - L\n                    B_new[L:W] = B[0:num_to_copy]\n                # If L >= W, the old window is entirely shifted out, \n                # so B_new remains all zeros from initialization.\n\n                # Mark the new sequence number S as seen\n                B_new[0] = 1\n                B = B_new\n        \n        results.append(accepted)\n\n    return results\n\nsolve()\n```"
        },
        {
            "introduction": "在信息物理系统中，安全故障可能导致危险的物理后果。本练习将重放攻击与控制理论直接联系起来，要求您确定导致系统不稳定的精确延迟裕度。通过这个分析，您将清晰地看到网络威胁是如何危及物理安全的，这对于理解闭环系统中的攻击影响至关重要。",
            "id": "4240581",
            "problem": "一个带有数字孪生（DT）的信息物理系统（CPS）使用网络化传感器来闭合回路。对传感器数据流的回放攻击在控制器使用的反馈信号中引入了一个有效的恒定测量延迟 $d>0$。考虑由标量系统描述的被控对象动力学线性化的单个主导模式\n$$\\dot{x}(t)=a\\,x(t)+b\\,u(t),\\qquad y(t)=x(t),$$\n其静态输出反馈在数字孪生中实现为\n$$u(t)=-k\\,y(t-d)=-k\\,x(t-d),$$\n其中 $a\\in\\mathbb{R}$，$b0$ 且 $k0$。因此，在回放攻击引起的延迟下的闭环动力学为\n$$\\dot{x}(t)=a\\,x(t)-b\\,k\\,x(t-d)。$$\n从时滞系统的第一性原理出发，即指数试探解 $x(t)=\\exp(s t)$ 和相关的特征方程，使用在 $d=0$ 处的特征值配置和延迟裕度分析（虚轴穿越条件），推导使测量延迟 $d$ 可能降低闭环稳定性的关于 $(a,b,k)$ 的充要条件，然后求出闭环系统失去稳定性时的精确最大容忍延迟 $d^{\\star}$（延迟裕度）。假设 $a0$，$b0$，$k0$，并选择 $k$ 以使零延迟闭环是稳定的。\n\n仅报告用 $a$、$b$ 和 $k$ 表示的 $d^{\\star}$ 的闭式符号表达式。所有角度均使用弧度，并将最终延迟以秒为单位表示。无需四舍五入。",
            "solution": "该问题要求推导一个标量线性时滞系统的稳定性边界。分析从给定的闭环动力学方程开始。\n\n信息物理系统在回放攻击下的闭环动力学由以下一阶时滞微分方程描述：\n$$\n\\dot{x}(t) = a\\,x(t) - b\\,k\\,x(t-d)\n$$\n其中 $a > 0$，$b > 0$，$k > 0$，延迟 $d > 0$。该系统的稳定性由其特征方程的根在复平面上的位置决定。\n\n为求特征方程，我们假设一个形式为 $x(t) = C\\exp(st)$ 的指数试探解，其中 $C$ 是一个常数，$s \\in \\mathbb{C}$ 是一个特征根。将其代入微分方程得到：\n$$\ns C\\exp(st) = a C\\exp(st) - b\\,k C\\exp(s(t-d))\n$$\n两边同除以 $C\\exp(st)$（对于非平凡解，$C \\neq 0$）并化简得到：\n$$\ns = a - b\\,k\\exp(-sd)\n$$\n整理各项，我们得到系统的特征方程：\n$$\ns - a + b\\,k\\exp(-sd) = 0\n$$\n当且仅当该方程的所有根 $s$ 的实部都为负时，即 $\\text{Re}(s)  0$，系统是渐近稳定的。\n\n首先，我们必须遵守题目中明确的约束条件，即系统在零延迟（即 $d=0$）时是稳定的。在这种情况下，特征方程简化为：\n$$\ns - a + b\\,k = 0\n$$\n该方程有唯一的实根 $s = a - b\\,k$。为保证稳定性，该根必须为负：\n$$\na - b\\,k  0 \\implies b\\,k > a\n$$\n根据题目陈述，我们假设控制器增益 $k$ 满足此条件。\n\n当延迟 $d$ 从 $0$ 开始增加时，若有一对共轭复根穿过虚轴，系统就会失去稳定性。为了找到发生这种情况的临界延迟 $d^{\\star}$，我们寻找形式为 $s = j\\omega$ 的解，其中 $\\omega \\in \\mathbb{R}$ 是穿越频率。将 $s = j\\omega$ 代入特征方程：\n$$\nj\\omega - a + b\\,k\\exp(-j\\omega d) = 0\n$$\n使用欧拉恒等式 $\\exp(-j\\omega d) = \\cos(\\omega d) - j\\sin(\\omega d)$，我们得到：\n$$\nj\\omega - a + b\\,k(\\cos(\\omega d) - j\\sin(\\omega d)) = 0\n$$\n我们将这个复数方程分为实部和虚部：\n\\begin{enumerate}\n    \\item 实部：$-a + b\\,k\\cos(\\omega d) = 0 \\implies b\\,k\\cos(\\omega d) = a$\n    \\item 虚部：$\\omega - b\\,k\\sin(\\omega d) = 0 \\implies b\\,k\\sin(\\omega d) = \\omega$\n\\end{enumerate}\n对于非平凡穿越，我们必须有 $\\omega \\neq 0$。由于 $b>0$ 且 $k>0$，这意味着 $\\sin(\\omega d) \\neq 0$。我们可以将两个方程平方后相加，以消去延迟 $d$：\n$$\n(b\\,k\\cos(\\omega d))^2 + (b\\,k\\sin(\\omega d))^2 = a^2 + \\omega^2\n$$\n$$\n(b\\,k)^2(\\cos^2(\\omega d) + \\sin^2(\\omega d)) = a^2 + \\omega^2\n$$\n使用三角恒等式 $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$，我们发现：\n$$\n(b\\,k)^2 = a^2 + \\omega^2\n$$\n这使我们能够求解穿越频率 $\\omega$：\n$$\n\\omega^2 = (b\\,k)^2 - a^2\n$$\n为了存在实数穿越频率 $\\omega$，我们必须有 $\\omega^2 \\ge 0$，这意味着 $(b\\,k)^2 \\ge a^2$。由于 $a, b, k$ 均为正数，这等价于 $b\\,k \\ge a$。$b\\,k = a$ 的情况对应于 $\\omega=0$，这意味着根位于原点，这种情况与临界稳定性的零延迟条件一致。要使延迟从一个稳定状态*降低*稳定性，系统必须在非零频率处穿越虚轴，这要求 $\\omega^2 > 0$。因此，延迟 $d$ 能够引起振荡失稳的关于 $(a,b,k)$ 的充要条件是 $b\\,k > a$。这恰好是系统在零延迟时保持稳定所需的条件，证实了问题的自洽性。\n\n在 $b\\,k > a$ 的条件下，穿越频率由下式给出：\n$$\n\\omega = \\sqrt{(b\\,k)^2 - a^2}\n$$\n我们取 $\\omega$ 的正根而不失一般性，因为负的 $\\omega$ 会对应于共轭根的穿越。\n\n现在，我们可以回到实部和虚部方程来求临界延迟 $d^{\\star}$。将虚部除以实部：\n$$\n\\frac{b\\,k\\sin(\\omega d)}{b\\,k\\cos(\\omega d)} = \\tan(\\omega d) = \\frac{\\omega}{a}\n$$\n从单个方程中我们注意到，由于 $a, b, k, \\omega$ 均为正数，我们必须有 $\\cos(\\omega d) = a/(b\\,k) > 0$ 和 $\\sin(\\omega d) = \\omega/(b\\,k) > 0$。这意味着角 $\\omega d$ 必须位于第一象限。满足此条件的最小正角是反余弦函数的主值。\n$$\n\\omega d = \\arccos\\left(\\frac{a}{b\\,k}\\right)\n$$\n系统将在满足此条件的最小正延迟 $d > 0$ 时失去稳定性。我们寻求的正是这个最小延迟 $d^{\\star}$：\n$$\nd^{\\star} = \\frac{1}{\\omega} \\arccos\\left(\\frac{a}{b\\,k}\\right)\n$$\n最后，代入 $\\omega$ 的表达式，得到最大可容忍延迟：\n$$\nd^{\\star} = \\frac{1}{\\sqrt{(b\\,k)^2 - a^2}} \\arccos\\left(\\frac{a}{b\\,k}\\right)\n$$\n这是延迟裕度的闭式符号表达式，用系统参数 $a, b, k$ 表示。",
            "answer": "$$\\boxed{\\frac{1}{\\sqrt{(bk)^2 - a^2}} \\arccos\\left(\\frac{a}{bk}\\right)}$$"
        }
    ]
}