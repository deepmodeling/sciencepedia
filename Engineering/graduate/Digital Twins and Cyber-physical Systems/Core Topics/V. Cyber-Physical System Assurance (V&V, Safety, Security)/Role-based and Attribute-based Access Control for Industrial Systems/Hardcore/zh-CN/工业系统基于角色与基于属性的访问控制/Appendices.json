{
    "hands_on_practices": [
        {
            "introduction": "信息物理系统（Cyber-physical systems）运行于数字世界与物理世界的交界处，这意味着其决策基于可能带有噪声或不精确的传感器数据。一个简单的访问控制策略可能会因为一个瞬时的错误读数而授权访问，从而导致不安全的状态。本练习  要求您直面这种不确定性，设计一个能够容忍传感器波动的稳健ABAC策略。您将推导出一个安全的“迟滞带”（hysteresis band），以确保即使在最坏的测量误差下，系统的决策也能保持保守和安全。",
            "id": "4241643",
            "problem": "信息物理生产系统中的一个工业机器人装配单元集成了一个数字孪生模型，用于在执行高功率运动前持续评估情境安全性。访问决策结合了基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）：用户必须拥有适当的角色，并且一个由情境衍生的风险指数必须证明安全性。ABAC组件评估一个无量纲的情境风险指数 $R(c)$，该指数由一个包含以下分量的实值属性向量 $c \\in \\mathbb{R}^{3}$ 计算得出：振动幅度 $c_{1}$、工作空间裕度 $c_{2}$ 和关节扭矩负载 $c_{3}$。数字孪生使用线性模型 $R(c) = w^{\\top} c$ 和权重 $w = (0.4,\\,-0.2,\\,0.7)$ 来计算风险指数，其中较高的振动和扭矩会增加风险，而较大的裕度会降低风险。安全要求由一个无量纲阈值 $r_{\\text{safe}} = 1.8$ 表示：只有当真实风险 $R(c)$ 不超过 $r_{\\text{safe}}$ 时，动作才可以继续。\n\n然而，测量到的属性 $\\hat{c}$ 会受到有界传感器误差 $e$ 的影响，该误差满足已知的保证 $\\|e\\|_{\\infty} \\leq \\epsilon$，其中 $\\epsilon = 0.03$（每个属性与其真实值的偏差最多为 0.03），且 $\\hat{c} = c + e$。为了在最坏测量误差情况下容忍小的波动同时防止不安全的动作，您需要为ABAC决策设计一个鲁棒的滞回带，使用两个阈值：\n- 一个“允许”阈值 $\\tau_{\\text{allow}}$，使得如果 $R(\\hat{c}) \\leq \\tau_{\\text{allow}}$，则可以保证 $R(c) \\leq r_{\\text{safe}}$。\n- 一个“拒绝”阈值 $\\tau_{\\text{deny}}$，使得如果 $R(\\hat{c}) \\geq \\tau_{\\text{deny}}$，则可以保证 $R(c) \\geq r_{\\text{safe}}$。\n\n在此带内，系统会延迟决策并请求额外的证据或稳定措施。从范数和风险聚合的基本定义出发，在 $\\|e\\|_{\\infty} \\leq \\epsilon$ 的条件下，推导一个关于 $|R(\\hat{c}) - R(c)|$ 的保守最坏情况界限。然后，利用此界限以及给定的 $w$、$\\epsilon$ 和 $r_{\\text{safe}}$，计算 $\\tau_{\\text{allow}}$ 和 $\\tau_{\\text{deny}}$ 的精确数值。将两个阈值都表示为无量纲值。不需要四舍五入，最终答案必须是这对阈值，以单行矩阵的形式表示。",
            "solution": "该问题要求通过确定“允许”阈值 $\\tau_{\\text{allow}}$ 和“拒绝”阈值 $\\tau_{\\text{deny}}$，为基于属性的访问控制（ABAC）系统设计一个鲁棒的滞回带。这是基于线性风险模型、安全阈值以及已知的传感器测量误差界限来完成的。\n\n第一步是量化真实风险指数 $R(c)$ 与根据测量属性计算出的风险指数 $R(\\hat{c})$ 之间的最大可能偏差。\n\n真实风险由线性模型 $R(c) = w^{\\top} c$ 给出，其中 $c \\in \\mathbb{R}^{3}$ 是真实属性值的向量，$w \\in \\mathbb{R}^{3}$ 是权重向量。\n测量属性为 $\\hat{c} = c + e$，其中 $e \\in \\mathbb{R}^{3}$ 是传感器误差向量。\n因此，根据测量属性计算出的风险为：\n$$R(\\hat{c}) = w^{\\top} \\hat{c} = w^{\\top} (c + e) = w^{\\top} c + w^{\\top} e = R(c) + w^{\\top} e$$\n因此，测量风险与真实风险之间的差值为 $\\Delta R = R(\\hat{c}) - R(c) = w^{\\top} e$。\n\n我们需要找到这个差值的最坏情况（最大绝对）值，记为 $\\Delta R_{\\max}$。误差向量 $e$ 受其无穷范数约束，$\\|e\\|_{\\infty} \\leq \\epsilon$，这意味着对于向量 $e$ 的每个分量 $e_i$，我们有 $|e_i| \\leq \\epsilon$。\n\n风险差的绝对值为 $|w^{\\top} e| = |\\sum_{i=1}^{3} w_i e_i|$。\n使用三角不等式，我们可以界定此表达式：\n$$|\\sum_{i=1}^{3} w_i e_i| \\leq \\sum_{i=1}^{3} |w_i e_i| = \\sum_{i=1}^{3} |w_i| |e_i|$$\n因为我们知道对于所有 $i \\in \\{1, 2, 3\\}$，都有 $|e_i| \\leq \\epsilon$，所以我们可以进一步界定这个和：\n$$\\sum_{i=1}^{3} |w_i| |e_i| \\leq \\sum_{i=1}^{3} |w_i| \\epsilon = \\epsilon \\sum_{i=1}^{3} |w_i|$$\n和 $\\sum_{i=1}^{3} |w_i|$ 是权重向量 $w$ 的 $L_1$ 范数的定义，记为 $\\|w\\|_1$。这个结果是 Hölder 不等式的一个具体应用，该不等式指出对于共轭指数 $p, q$，有 $|x^{\\top}y| \\leq \\|x\\|_p \\|y\\|_q$。这里我们使用 $p=1$ 和 $q=\\infty$。\n\n因此，测量风险与真实风险之间可能的最大绝对差值为：\n$$\\Delta R_{\\max} = \\sup_{\\|e\\|_{\\infty} \\leq \\epsilon} |w^{\\top} e| = \\epsilon \\|w\\|_1$$\n这个界是紧的，因为可以通过选择一个误差向量 $e$，使得对每个 $i$ 都有 $e_i = \\epsilon \\cdot \\text{sgn}(w_i)$ 来达到。\n\n现在，我们计算 $\\Delta R_{\\max}$ 的数值。\n给定的权重向量是 $w = (0.4, -0.2, 0.7)$。其 $L_1$ 范数为：\n$$\\|w\\|_1 = |0.4| + |-0.2| + |0.7| = 0.4 + 0.2 + 0.7 = 1.3$$\n给定的误差界限是 $\\epsilon = 0.03$。\n最大风险偏差是：\n$$\\Delta R_{\\max} = \\epsilon \\|w\\|_1 = 0.03 \\times 1.3 = 0.039$$\n所以，我们有不等式 $|R(c) - R(\\hat{c})| \\leq 0.039$，它等价于：\n$$R(\\hat{c}) - 0.039 \\leq R(c) \\leq R(\\hat{c}) + 0.039$$\n\n接下来，我们推导阈值 $\\tau_{\\text{allow}}$ 和 $\\tau_{\\text{deny}}$。安全要求是 $R(c) \\leq r_{\\text{safe}}$，其中 $r_{\\text{safe}} = 1.8$。\n\n对于“允许”阈值 $\\tau_{\\text{allow}}$，条件是：如果 $R(\\hat{c}) \\leq \\tau_{\\text{allow}}$，则可以保证 $R(c) \\leq r_{\\text{safe}}$。\n为了保证真实风险 $R(c)$ 不超过 $r_{\\text{safe}}$，我们必须确保其最大可能值小于或等于 $r_{\\text{safe}}$。从上面的不等式可知，给定测量值 $\\hat{c}$ 时，$R(c)$ 的最大可能值为 $R(\\hat{c}) + \\Delta R_{\\max}$。\n因此，我们必须强制执行以下条件：\n$$R(\\hat{c}) + \\Delta R_{\\max} \\leq r_{\\text{safe}}$$\n这等价于 $R(\\hat{c}) \\leq r_{\\text{safe}} - \\Delta R_{\\max}$。\n为了使“允许”区域尽可能大，我们将阈值设置为其最大允许值：\n$$\\tau_{\\text{allow}} = r_{\\text{safe}} - \\Delta R_{\\max}$$\n代入数值：\n$$\\tau_{\\text{allow}} = 1.8 - 0.039 = 1.761$$\n\n对于“拒绝”阈值 $\\tau_{\\text{deny}}$，条件是：如果 $R(\\hat{c}) \\geq \\tau_{\\text{deny}}$，则可以保证 $R(c) \\geq r_{\\text{safe}}$。\n为了保证真实风险 $R(c)$ 至少为 $r_{\\text{safe}}$，我们必须确保其最小可能值大于或等于 $r_{\\text{safe}}$。从上面的不等式可知，给定测量值 $\\hat{c}$ 时，$R(c)$ 的最小可能值为 $R(\\hat{c}) - \\Delta R_{\\max}$。\n因此，我们必须强制执行以下条件：\n$$R(\\hat{c}) - \\Delta R_{\\max} \\geq r_{\\text{safe}}$$\n这等价于 $R(\\hat{c}) \\geq r_{\\text{safe}} + \\Delta R_{\\max}$。\n为了使“拒绝”区域仅在必要时触发（即，使滞回带尽可能窄），我们将阈值设置为其最小允许值：\n$$\\tau_{\\text{deny}} = r_{\\text{safe}} + \\Delta R_{\\max}$$\n代入数值：\n$$\\tau_{\\text{deny}} = 1.8 + 0.039 = 1.839$$\n\n推导出的阈值为 $\\tau_{\\text{allow}} = 1.761$ 和 $\\tau_{\\text{deny}} = 1.839$。任何在区间 $(1.761, 1.839)$ 内的测量风险 $R(\\hat{c})$ 都落在滞回带内，此时决策将被延迟。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.761  1.839\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在模块化的ABAC架构中，通常会评估多个独立的子策略来做出单一的访问决策。然而，这种模块化可能导致策略冲突，例如一个规则允许操作，而另一个规则却拒绝。本练习  的任务是选择一个策略组合算法，这是一个解决此类冲突的关键组件。您的目标是选择一个能够保证确定性和失效安全（fail-safe）结果的策略，确保在面对模糊性或系统故障时，系统能默认进入安全状态。",
            "id": "4241686",
            "problem": "在一个用于化工流程生产线的信息物理系统 (CPS) 及其数字孪生 (DT) 中，对远程阀门覆写操作的访问由一个混合的基于角色的访问控制 (RBAC) 和基于属性的访问控制 (ABAC) 层来调节。RBAC (Role-Based Access Control) 通过角色确定粗粒度的资格，而 ABAC (Attribute-Based Access Control) 则使用主体、客体和环境的属性来优化决策。一个策略决策点 (PDP) 为每个请求评估一组固定的子策略，并返回集合 $\\{\\mathsf{Permit}, \\mathsf{Deny}, \\mathsf{NotApplicable}, \\mathsf{Indeterminate}\\}$ 中的单个决策。考虑一个承包商，其属性对于一个在运行中的生产线上发布远程阀门覆写请求导致了以下子策略结果：许可验证为 $\\mathsf{Deny}$，因为承包商的许可昨天已过期；培训时效性为 $\\mathsf{Permit}$，因为承包商本周通过了要求的模块；主管证明为 $\\mathsf{Indeterminate}$，因为证明服务无法访问；环境风险策略为 $\\mathsf{NotApplicable}$，因为风险模型因维护而被禁用。组织规定，数字孪生和物理控制器都必须执行相同的组合决策。\n\n您的任务是为 PDP 选择一种策略组合算法，以使组合决策满足以下基于已确立的安全设计原则和安全工程的基本安全要求：\n\n- 故障安全默认：在缺乏足够证据允许的情况下，返回 $\\mathsf{Deny}$。\n- 安全单调性：添加任何安全负面证据（例如，过期的许可）或不确定性（例如，评估故障）都不能使决策的安全性降低；通俗地说，额外的负面或不确定信息不能将一个 $\\mathsf{Deny}$ 决策翻转为 $\\mathsf{Permit}$。\n- 冲突下的确定性：对于任何子策略决策的多重集，包括冲突的结果（如同时出现 $\\mathsf{Permit}$ 和 $\\mathsf{Deny}$），结果都是唯一确定并偏向于安全的。\n\n假设组合算子应用于决策的多重集之上，并且必须可分布式部署（因此必须对评估顺序和分组不敏感）。鉴于承包商的情况，以下哪种组合算法最能满足此 CPS 和 DT 的上述要求？\n\nA. 具有默认拒绝的保守拒绝优先：在多重集 $M \\subseteq \\{\\mathsf{Permit}, \\mathsf{Deny}, \\mathsf{NotApplicable}, \\mathsf{Indeterminate}\\}$ 上定义 $F$ 为\n$$\nF(M)=\n\\begin{cases}\n\\mathsf{Deny},   \\text{如果 } \\exists d\\in M \\text{ 且 } d=\\mathsf{Deny},\\\\\n\\mathsf{Deny},   \\text{否则如果 } \\exists d\\in M \\text{ 且 } d=\\mathsf{Indeterminate},\\\\\n\\mathsf{Permit},  \\text{否则如果 } \\exists d\\in M \\text{ 且 } d=\\mathsf{Permit},\\\\\n\\mathsf{Deny},   \\text{否则}~(\\text{即所有 } d=\\mathsf{NotApplicable}).\n\\end{cases}\n$$\n\nB. 具有乐观默认的允许优先：如果任何子策略返回 $\\mathsf{Permit}$，则返回 $\\mathsf{Permit}$；仅当所有子策略都返回 $\\mathsf{Deny}$ 时才返回 $\\mathsf{Deny}$；将 $\\mathsf{Indeterminate}$ 视为 $\\mathsf{NotApplicable}$。\n\nC. 固定优先级顺序下的首个适用：按“培训时效性、许可验证、主管证明、环境风险策略”的固定顺序评估子策略；返回第一个不为 $\\mathsf{NotApplicable}$ 的结果。\n\nD. 加权投票聚合器：将 $\\mathsf{Permit}\\mapsto +1$、$\\mathsf{Deny}\\mapsto -1$、$\\mathsf{NotApplicable}\\mapsto 0$、$\\mathsf{Indeterminate}\\mapsto -1$ 进行映射，对分数求和，如果总和大于 $0$ 则返回 $\\mathsf{Permit}$，否则返回 $\\mathsf{Deny}$。\n\n选择最佳选项，并根据所述属性以及工业信息物理系统及其数字孪生的安全背景来证明您的选择。",
            "solution": "我们从安全关键型系统访问控制的基本原则开始。PDP 实现了一个决策函数 $D:\\mathcal{S}\\times \\mathcal{O}\\times \\mathcal{A}\\times \\mathcal{E}\\to \\{\\mathsf{Permit},\\mathsf{Deny},\\mathsf{NotApplicable},\\mathsf{Indeterminate}\\}$，其中 $\\mathcal{S}$、$\\mathcal{O}$、$\\mathcal{A}$ 和 $\\mathcal{E}$ 分别表示主体、客体、操作和环境的属性空间。函数 $D$ 是通过组合子策略的结果来实现的。设计必须遵守两个核心的安全设计原则：故障安全默认（默认拒绝）和最小权限，这在策略组合方面引出了以下约束。\n\n定义决策集 $\\mathcal{D}=\\{\\mathsf{Permit},\\mathsf{Deny},\\mathsf{NotApplicable},\\mathsf{Indeterminate}\\}$。为了安全推理，引入一个在 $\\mathcal{D}$ 上的安全预序 $\\preceq_s$，它编码了 $\\mathsf{Deny}$ 是最安全的，在故障安全设计中 $\\mathsf{Indeterminate}$ 的安全性低于 $\\mathsf{Deny}$ 但高于 $\\mathsf{Permit}$，而 $\\mathsf{NotApplicable}$ 不提供任何证据，且其本身不能提升风险。一个能捕捉此意的保守排序是\n$$\n\\mathsf{Permit} \\;\\prec_s\\; \\mathsf{Indeterminate} \\;\\prec_s\\; \\mathsf{Deny},\n$$\n其中 $\\mathsf{NotApplicable}$ 被视为一个中性元素，既不强制降级也不强制升级，并在聚合前被消除。安全单调性要求，对于任何决策的多重集 $M$ 以及通过添加 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 形成的任何扩展 $M' \\supseteq M$，组合函数 $F$ 必须满足\n$$\nF(M') \\succeq_s F(M).\n$$\n故障安全默认要求 $F(\\varnothing)=\\mathsf{Deny}$，其中 $\\varnothing$ 代表所有子策略均为 $\\mathsf{NotApplicable}$ 或不提供任何证据的情况。确定性和可分发性要求 $F$ 对顺序和分组不敏感，即，对于多重集并集，$F$ 必须是可交换的、可结合的和幂等的，这样即使策略片段以不同顺序组合，数字孪生和物理控制器中的分布式评估也能始终产生相同的结果。\n\n在这些约束下，组合算子必须在丢弃 $\\mathsf{NotApplicable}$ 后，从多重集中选择最保守的结果。此外，在安全关键的 CPS 中，不确定性必须被视为风险，因此 $\\mathsf{Indeterminate}$ 必须被归结为 $\\mathsf{Deny}$，以避免在存在评估故障时出现不安全的允许。形式上，这产生了一个具有默认拒绝的保守拒绝优先规则：如果出现 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$，则返回 $\\mathsf{Deny}$；否则，如果出现任何 $\\mathsf{Permit}$，则返回 $\\mathsf{Permit}$；再否则返回 $\\mathsf{Deny}$。该算子仅依赖于类别的存在，而与其顺序无关，因此是可结合的、可交换的和幂等的。它也满足安全单调性，因为添加 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 不会降低在排序 $\\preceq_s$ 中的安全性。\n\n将承包商场景实例化，结果的多重集是 $M=\\{\\mathsf{Deny},\\mathsf{Permit},\\mathsf{Indeterminate},\\mathsf{NotApplicable}\\}$。一个具有默认拒绝的保守拒绝优先规则会返回 $\\mathsf{Deny}$，这在许可过期和主管证明不确定的情况下，可以防止危险的覆写操作。\n\n现在我们根据所述属性分析每个选项。\n\n选项 A：具有默认拒绝的保守拒绝优先。\n- 形式化定义：如果 $M$ 包含 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$，则 $F(M)=\\mathsf{Deny}$；否则，如果 $M$ 包含 $\\mathsf{Permit}$，则 $F(M)=\\mathsf{Permit}$；再否则 $F(M)=\\mathsf{Deny}$。\n- 故障安全默认：满足，因为 $F(\\varnothing)=\\mathsf{Deny}$ 且 $\\mathsf{NotApplicable}$ 不会产生 $\\mathsf{Permit}$。\n- 安全单调性：满足，因为添加 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 会强制或保持 $\\mathsf{Deny}$；添加 $\\mathsf{Permit}$ 不能覆盖已有的 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$。\n- 确定性和可分发性：满足，因为结果仅依赖于类别的存在，而与顺序无关；等效地，对于多重集并集，$F$ 是可结合的、可交换的和幂等的。\n- 应用于该场景：鉴于 $\\mathsf{Deny}$ 和 $\\mathsf{Indeterminate}$ 的存在，返回 $\\mathsf{Deny}$，这与安全性要求一致。\n- 结论：正确。\n\n选项 B：具有乐观默认的允许优先；将 $\\mathsf{Indeterminate}$ 视为 $\\mathsf{NotApplicable}$。\n- 故障安全默认：通常情况下违反，因为即使其他策略为 $\\mathsf{NotApplicable}$，单个 $\\mathsf{Permit}$ 也会产生 $\\mathsf{Permit}$。\n- 安全单调性：违反，因为向包含 $\\mathsf{Deny}$ 的多重集添加 $\\mathsf{Permit}$ 会将决策翻转为 $\\mathsf{Permit}$，从而降低安全性。在承包商场景中，$\\mathsf{Permit}$ 和 $\\mathsf{Deny}$ 的同时存在会产生 $\\mathsf{Permit}$，这是不安全的。\n- 确定性：该算子是确定性的，但不安全。\n- 结论：不正确。\n\n选项 C：固定优先级顺序下的首个适用。\n- 故障安全默认：不保证；如果顺序中的第一个策略返回 $\\mathsf{Permit}$，则后面的 $\\mathsf{Deny}$ 会被忽略。\n- 安全单调性：违反，因为决策可能仅因重新排序策略而改变，而不是因证据改变，且后面的 $\\mathsf{Deny}$ 不能覆盖前面的 $\\mathsf{Permit}$。这允许在存在负面证据的情况下产生一个较不安全的结果。\n- 确定性和可分发性：确定性依赖于全局顺序；可分发性差，因为分布式片段可能在评估顺序上存在分歧，从而违反了 DT 和控制器必须一致的要求。\n- 应用于该场景：由于培训策略优先，尽管许可已过期，仍返回 $\\mathsf{Permit}$，这是不安全的。\n- 结论：不正确。\n\n选项 D：加权投票聚合器，其中 $\\mathsf{Permit}\\mapsto +1$、$\\mathsf{Deny}\\mapsto -1$、$\\mathsf{NotApplicable}\\mapsto 0$、$\\mathsf{Indeterminate}\\mapsto -1$，如果总和 0 则允许，否则拒绝。\n- 故障安全默认：如果所有策略均为 $\\mathsf{NotApplicable}$，总和为0，产生 $\\mathsf{Deny}$，这与默认拒绝一致，但这仅仅是由于所选的阈值；其他阈值会破坏此属性，即使使用此阈值，在其他组合中安全性也可能被违反。\n- 安全单调性：违反，因为 $\\mathsf{Permit}$ 投票在数量上可以超过单个 $\\mathsf{Deny}$，从而在存在负面证据的情况下允许 $\\mathsf{Permit}$。例如，两个 $\\mathsf{Permit}$ 和一个 $\\mathsf{Deny}$ 的总和为+1，产生 $\\mathsf{Permit}$，这与保守安全性相矛盾。此外，数值求和满足结合律，但映射和阈值处理并不能强制任何 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 成为吸收状态。\n- 确定性：在给定固定权重的情况下是确定性的，但未能满足核心安全属性。\n- 应用于该场景：该多重集映射为：$\\mathsf{Deny}$ 得-1分，$\\mathsf{Permit}$ 得+1分，$\\mathsf{Indeterminate}$ 得-1分，$\\mathsf{NotApplicable}$ 得0分；总和为-1，因此在这种特定情况下结果为 $\\mathsf{Deny}$，但该方法在其他危险组合中可能会允许，从而违反了作为设计原则的安全单调性。\n- 结论：不正确。\n\n通过从故障安全默认、安全单调性和可分发性推导，只有选项A中的具有默认拒绝的保守拒绝优先算子满足要求，并为承包商的冲突属性产生一个确定的 $\\mathsf{Deny}$ 结果，从而保护数字孪生和物理过程在不确定性和许可过期期间免受不安全的覆写操作。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "最小权限原则是安全系统设计的基石，它规定任何实体只应拥有完成其任务所必需的权限。这个原则理论上简单，但在混合了RBAC和ABAC的复杂系统中实施则需要细致入微的分析。在本次实践中 ，您将解决一个在现有工业系统中引入新角色的现实挑战。您的任务是精确计算出满足要求所需的最小用户和权限分配集合，同时还要处理职责分离（Segregation of Duties）等复杂约束。",
            "id": "4241687",
            "problem": "一个用于信息物理工业设施的混合访问控制系统结合了基于角色的访问控制 (RBAC) 和基于属性的访问控制 (ABAC)。基于角色的访问控制 (RBAC) 由一个用户到角色的分配关系 $UA \\subseteq U \\times R$ 和一个权限到角色的分配关系 $PA \\subseteq P \\times R$ 定义。用户 $u \\in U$ 对资源 $r$ 执行操作 $a$ 的请求被允许，当且仅当存在一个角色 $r^{\\star} \\in R$，使得 $(u,r^{\\star}) \\in UA$、对于权限 $p=(a,r)$ 有 $(p,r^{\\star}) \\in PA$，并且一个基于属性的访问控制 (ABAC) 策略谓词对主体和资源属性的评估结果为真。\n\n该设施包含 $12$ 个可编程逻辑控制器 (PLC)，由 $I=\\{1,2,\\dots,12\\}$ 索引。每个 PLC $i \\in I$ 都有一个资源属性签名\n$$\ns(i) = \\big(Z(i), V(i), C(i)\\big) \\in \\{Z_1,Z_2,Z_3\\} \\times \\{A,B\\} \\times \\{0,1\\},\n$$\n其中 $Z(i)$ 是其区域，$V(i)$ 是其供应商，$C(i)$ 是其安全关键标志 ($C(i)=1$ 意味着安全关键)。签名为：\n$$\n\\begin{aligned}\ns(1)=(Z_1,A,0),\\quad s(2)=(Z_1,A,0),\\quad s(3)=(Z_1,B,0),\\quad s(4)=(Z_2,A,0),\\\\\ns(5)=(Z_2,A,0),\\quad s(6)=(Z_2,B,1),\\quad s(7)=(Z_3,A,0),\\quad s(8)=(Z_3,A,0),\\\\\ns(9)=(Z_3,B,0),\\quad s(10)=(Z_3,B,1),\\quad s(11)=(Z_2,B,0),\\quad s(12)=(Z_1,B,1).\n\\end{aligned}\n$$\n\n权限集 $P$ 为每个 $i \\in I$ 包含一个元素 $(\\text{fw\\_upgrade}, i)$，代表在 PLC $i$ 上执行固件升级的权限。必须添加一个新的维护角色 $r_{\\mathrm{new}}$，以仅在指定的子集\n$$\nS=\\{1,2,3,4,5,7,9\\} \\subset I,\n$$\n上启用固件升级，而不在任何其他 PLC 上。ABAC 策略在评估时强制执行以下主体和资源谓词：\n- 主体谓词要求许可级别和区域认证：对于用户 $u$，令 $c(u) \\in \\mathbb{N}$ 表示许可级别，$\\mathrm{cert}(u) \\subseteq \\{Z_1,Z_2,Z_3\\}$ 表示区域认证；主体侧谓词是\n$$\n\\Phi_{\\mathrm{sub}}(u,i) \\equiv \\big(c(u) \\geq 4\\big) \\land \\big(Z(i) \\in \\mathrm{cert}(u)\\big).\n$$\n- 对与 $r_{\\mathrm{new}}$ 关联的权限所允许的资源侧谓词语言仅限于关于 $(Z,V,C)$ 的等式合取；也就是说，一个资源谓词的形式为\n$$\n\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i) \\equiv \\big(Z(i)=Z^\\prime\\big) \\land \\big(V(i)=V^\\prime\\big) \\land \\big(C(i)=0\\big),\n$$\n且不能提及 PLC 标识符 $i$ 或包含析取。然而，RBAC 权限是在特定 PLC 身份 $(\\text{fw\\_upgrade}, i)$ 的粒度上定义的，因此对 $r_{\\mathrm{new}}$ 的权限分配可以是以下任一种：\n- 一种组分配，将 $r_{\\mathrm{new}}$ 链接到所有满足 $\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i)$ 的 $(\\text{fw\\_upgrade}, i)$，计为对 $PA$ 的一次添加，条件是这不会授予对 $S$ 之外任何 PLC 的访问权限；或\n- 一种单个资源分配，将 $r_{\\mathrm{new}}$ 链接到特定 $i$ 的 $(\\text{fw\\_upgrade}, i)$，计为对 $PA$ 的一次添加。\n\n职责分离 (SoD) 约束：已在冲突角色 \"OpsEngineer\" 中的用户不能被分配给 $r_{\\mathrm{new}}$。现有维护用户集为 $U=\\{u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8\\}$，其属性如下\n$$\n\\begin{aligned}\nc(u_1)=4,\\ \\mathrm{cert}(u_1)=\\{Z_1,Z_2\\},\\ \\text{无冲突};\\\\\nc(u_2)=4,\\ \\mathrm{cert}(u_2)=\\{Z_3\\},\\ \\text{无冲突};\\\\\nc(u_3)=3,\\ \\mathrm{cert}(u_3)=\\{Z_1\\},\\ \\text{无冲突};\\\\\nc(u_4)=5,\\ \\mathrm{cert}(u_4)=\\{Z_1,Z_3\\},\\ \\text{冲突 (OpsEngineer)};\\\\\nc(u_5)=4,\\ \\mathrm{cert}(u_5)=\\{Z_2\\},\\ \\text{无冲突};\\\\\nc(u_6)=4,\\ \\mathrm{cert}(u_6)=\\{Z_1\\},\\ \\text{无冲突};\\\\\nc(u_7)=2,\\ \\mathrm{cert}(u_7)=\\{Z_3\\},\\ \\text{无冲突};\\\\\nc(u_8)=5,\\ \\mathrm{cert}(u_8)=\\{Z_2,Z_3\\},\\ \\text{冲突 (OpsEngineer)}.\n\\end{aligned}\n$$\n\n采用以下基本决策规则：一个请求 $(u,\\text{fw\\_upgrade},i)$ 被允许，当且仅当存在 $(u,r_{\\mathrm{new}}) \\in UA$，并且或者对于某个 $(Z^\\prime,V^\\prime)$ 的组分配使得 $\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i)$ 成立，或者在 $PA$ 中存在对 $i$ 的单个资源分配，并且 $\\Phi_{\\mathrm{sub}}(u,i)$ 成立。\n\n在最小权限目标下，将 $\\Delta UA$ 定义为需要添加到 $UA$ 的新用户-角色边的最小集合，该集合恰好在 $S$ 中的 PLC 上启用升级（而不在其他 PLC 上）；将 $\\Delta PA$ 定义为需要添加到 $PA$ 的新权限-角色边的最小集合，该集合满足资源谓词语言以及 $S$ 之外的 PLC 不会因 $r_{\\mathrm{new}}$ 而变得可升级的约束。\n\n计算数对 $\\big(|\\Delta UA|,\\,|\\Delta PA|\\big)$ 作为整数，其中 $|\\cdot|$ 表示集合的基数。以行矩阵形式表示您的最终答案，使用按 $\\big(|\\Delta UA|,\\,|\\Delta PA|\\big)$ 顺序排列的两个条目。无需四舍五入。无需单位。",
            "solution": "问题要求确定所需的最小用户-角色分配数 $|\\Delta UA|$ 和最小权限-角色分配数 $|\\Delta PA|$，以授予新角色 $r_{\\mathrm{new}}$ 在一组特定的可编程逻辑控制器 (PLC) $S=\\{1,2,3,4,5,7,9\\}$ 上执行固件升级的能力，而不在任何其他 PLC 上。\n\n用户 $u$ 对 PLC $i$ 执行操作 'fw\\_upgrade' 的请求的最终决策规则是必须同时满足以下三个条件：\n1. 用户 $u$ 被分配了角色 $r_{\\mathrm{new}}$：$(u, r_{\\mathrm{new}}) \\in UA$。\n2. 权限 $(\\text{fw\\_upgrade}, i)$ 被分配给了角色 $r_{\\mathrm{new}}$：$((\\text{fw\\_upgrade}, i), r_{\\mathrm{new}}) \\in PA$。\n3. 主体侧 ABAC 谓词为真：$\\Phi_{\\mathrm{sub}}(u,i) \\equiv (c(u) \\geq 4) \\land (Z(i) \\in \\mathrm{cert}(u))$。\n\n我们必须找到最小的集合 $\\Delta UA$ 和 $\\Delta PA$ 以对所有 $i \\in S$ 满足这些条件，而对任何 $i \\notin S$ 不满足。\n\n首先，我们确定权限分配的最小集合 $\\Delta PA$。\n对 $r_{\\mathrm{new}}$ 的权限可以通过两种方式分配给 $PA$：\na) 一个组分配，基于一个谓词 $\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i) \\equiv (Z(i)=Z^\\prime) \\land (V(i)=V^\\prime) \\land (C(i)=0)$。这仅在匹配此谓词的所有 PLC 的集合是 $S$ 的一个子集时才有效。这样的规则会向 $\\Delta PA$ 添加 $1$ 个元素。\nb) 对特定 PLC $i$ 的单个资源分配。这也会向 $\\Delta PA$ 添加 $1$ 个元素。\n\n目标是用最少数量的此类分配覆盖 $S=\\{1,2,3,4,5,7,9\\}$ 中的所有 PLC。让我们分析所有 12 个 PLC 的属性：\n$s(1)=(Z_1,A,0)$, $s(2)=(Z_1,A,0)$, $s(3)=(Z_1,B,0)$, $s(4)=(Z_2,A,0)$, $s(5)=(Z_2,A,0)$, $s(6)=(Z_2,B,1)$, $s(7)=(Z_3,A,0)$, $s(8)=(Z_3,A,0)$, $s(9)=(Z_3,B,0)$, $s(10)=(Z_3,B,1)$, $s(11)=(Z_2,B,0)$, $s(12)=(Z_1,B,1)$。\n目标集是 $S=\\{1,2,3,4,5,7,9\\}$。不在 $S$ 中的 PLC 集合是 $I \\setminus S = \\{6,8,10,11,12\\}$。\n\n资源谓词 $\\Phi_{\\mathrm{res}}$ 要求 $C(i)=0$。这立即将 PLC $6、10$ 和 $12$ 从任何组规则的考虑中筛选掉，因为它们的 $C(i)=1$。这是有利的，因为它们都在 $S$ 之外。剩余的 $C(i)=0$ 的 PLC 是 $\\{1,2,3,4,5,7,8,9,11\\}$。\n\n我们可以按它们的 $(Z,V)$ 属性将此集合分区，以识别潜在的组分配：\n- 集合 $G_1 = \\{i \\mid Z(i)=Z_1, V(i)=A, C(i)=0\\} = \\{1,2\\}$。由于 $G_1 \\subseteq S$，一个针对 $(Z_1, A)$ 的组分配是有效的。这用 $1$ 个 PA 条目覆盖了两个 PLC，即 $\\{1,2\\}$。\n- 集合 $G_2 = \\{i \\mid Z(i)=Z_1, V(i)=B, C(i)=0\\} = \\{3\\}$。由于 $G_2 \\subseteq S$，一个针对 $(Z_1, B)$ 的组分配是有效的。它用 $1$ 个 PA 条目覆盖了一个 PLC，即 $\\{3\\}$。一个单个资源分配会达到同样的效果。\n- 集合 $G_3 = \\{i \\mid Z(i)=Z_2, V(i)=A, C(i)=0\\} = \\{4,5\\}$。由于 $G_3 \\subseteq S$，一个针对 $(Z_2, A)$ 的组分配是有效的。它用 $1$ 个 PA 条目覆盖了两个 PLC，即 $\\{4,5\\}$。\n- 集合 $G_4 = \\{i \\mid Z(i)=Z_2, V(i)=B, C(i)=0\\} = \\{11\\}$。由于 $11 \\notin S$，这个组分配对于覆盖 $S$ 中的任何 PLC 都没有用。\n- 集合 $G_5 = \\{i \\mid Z(i)=Z_3, V(i)=A, C(i)=0\\} = \\{7,8\\}$。由于 $8 \\notin S$，这个集合不是 $S$ 的子集。因此，一个针对 $(Z_3, A)$ 的组分配是被禁止的。\n- 集合 $G_6 = \\{i \\mid Z(i)=Z_3, V(i)=B, C(i)=0\\} = \\{9\\}$。由于 $G_6 \\subseteq S$，一个针对 $(Z_3, B)$ 的组分配是有效的。它用 $1$ 个 PA 条目覆盖了一个 PLC，即 $\\{9\\}$。\n\n为了以最少的 PA 条目覆盖 $S=\\{1,2,3,4,5,7,9\\}$ 中的所有 PLC：\n- 对于 $\\{1,2\\}$：使用针对 $(Z_1, A, 0)$ 的组分配。这花费 $1$ 个 PA 条目。\n- 对于 $\\{4,5\\}$：使用针对 $(Z_2, A, 0)$ 的组分配。这花费 $1$ 个 PA 条目。\n- 对于 $\\{3\\}$：一个单个资源分配是必要的。这花费 $1$ 个 PA 条目。（使用针对 $(Z_1, B, 0)$ 的组规则在成本上是等效的）。\n- 对于 $\\{7\\}$：组分配被禁止。需要一个单个资源分配。这花费 $1$ 个 PA 条目。\n- 对于 $\\{9\\}$：一个单个资源分配是必要的。这花费 $1$ 个 PA 条目。（使用针对 $(Z_3, B, 0)$ 的组规则在成本上是等效的）。\n\n将这些加起来，$\\Delta PA$ 中的最小条目数是 $1+1+1+1+1=5$。因此，$|\\Delta PA| = 5$。\n\n接下来，我们确定用户分配的最小集合 $\\Delta UA$。\n我们需要将用户分配给角色 $r_{\\mathrm{new}}$，使得对于每个 PLC $i \\in S$，至少有一个被分配的用户 $u$ 满足主体谓词 $\\Phi_{\\mathrm{sub}}(u,i)$。\n首先，我们从集合 $U=\\{u_1, \\dots, u_8\\}$ 中识别合格的用户。\n- 用户 $u_4$ 和 $u_8$ 有冲突角色 \"OpsEngineer\"，不能被分配给 $r_{\\mathrm{new}}$。\n- 用户 $u_3$ 的许可级别为 $c(u_3)=3$，小于要求的 $4$。所以，$u_3$ 不合格。\n- 用户 $u_7$ 的许可级别为 $c(u_7)=2$，也小于 $4$。所以，$u_7$ 不合格。\n合格用户的集合是 $\\{u_1, u_2, u_5, u_6\\}$。他们与 $\\Phi_{\\mathrm{sub}}$ 相关的属性是：\n- $u_1$：$c=4$，$\\mathrm{cert}=\\{Z_1, Z_2\\}$。可以访问区域 $Z_1$ 和 $Z_2$ 中的 PLC。\n- $u_2$：$c=4$，$\\mathrm{cert}=\\{Z_3\\}$。可以访问区域 $Z_3$ 中的 PLC。\n- $u_5$：$c=4$，$\\mathrm{cert}=\\{Z_2\\}$。可以访问区域 $Z_2$ 中的 PLC。\n- $u_6$：$c=4$，$\\mathrm{cert}=\\{Z_1\\}$。可以访问区域 $Z_1$ 中的 PLC。\n\n$S$ 中的 PLC 位于以下区域：\n- 区域 $Z_1$：PLC $\\{1,2,3\\}$。\n- 区域 $Z_2$：PLC $\\{4,5\\}$。\n- 区域 $Z_3$：PLC $\\{7,9\\}$。\n为了在 $S$ 中的所有 PLC 上启用升级，我们需要分配一组用户，其组合的区域认证覆盖 $\\{Z_1, Z_2, Z_3\\}$。这是一个经典的集合覆盖问题。我们想找到覆盖这三个区域的最小用户数。\n\n- 为了覆盖区域 $Z_3$，我们必须选择用户 $u_2$，因为没有其他合格用户被认证用于 $Z_3$。所以，$(u_2, r_{\\mathrm{new}}) \\in \\Delta UA$。\n- 选择了 $u_2$ 后，我们仍需要覆盖区域 $\\{Z_1, Z_2\\}$。我们可以通过选择用户 $u_1$ 来做到这一点，他同时被认证用于 $\\{Z_1, Z_2\\}$。这将 $(u_1, r_{\\mathrm{new}})$ 添加到 $\\Delta UA$。用户总数为 $2$。\n- 或者，我们可以通过选择用户 $u_6$（用于 $Z_1$）和用户 $u_5$（用于 $Z_2$）来覆盖 $\\{Z_1, Z_2\\}$。这将需要两个额外的用户，总共 $1+2=3$ 个用户。\n最小的选择是选择用户 $\\{u_1, u_2\\}$，这覆盖了所有必需的区域。\n因此，用户-角色分配的最小集合是 $\\Delta UA = \\{(u_1, r_{\\mathrm{new}}), (u_2, r_{\\mathrm{new}})\\}$. 其基数为 $|\\Delta UA| = 2$。\n\n“无其他”的约束得到了保证，因为我们对 $\\Delta PA$ 的构造确保了对 $r_{\\mathrm{new}}$ 的权限仅存在于 $S$ 中的 PLC。因此，即使一个用户对于 $S$ 之外的 PLC（例如 PLC 8）拥有适当的许可级别和认证，该请求也将被拒绝，因为在 $PA$ 中没有针对 $(\\text{fw\\_upgrade}, 8)$ 和角色 $r_{\\mathrm{new}}$ 的相应条目。\n\n最终结果是基数对 $(|\\Delta UA|, |\\Delta PA|)$。\n$|\\Delta UA| = 2$。\n$|\\Delta PA| = 5$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  5\n\\end{pmatrix}\n}\n$$"
        }
    ]
}