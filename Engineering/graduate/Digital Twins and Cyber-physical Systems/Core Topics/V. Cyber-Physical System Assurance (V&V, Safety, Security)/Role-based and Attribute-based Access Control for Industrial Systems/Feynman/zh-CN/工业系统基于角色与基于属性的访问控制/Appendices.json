{
    "hands_on_practices": [
        {
            "introduction": "在复杂的工业系统中，单个访问请求可能会同时触发多条访问控制规则，并可能产生相互矛盾的决策结果。本练习探讨了策略组合算法这一核心概念，它定义了如何解决这些冲突，这直接关系到系统的整体安全性和“故障安全”特性。通过此练习 ，您将像系统架构师一样思考，根据基本安全原则来评估不同的冲突解决方案，以确保在工业控制等安全攸关的环境中，访问决策总是确定且安全的。",
            "id": "4241686",
            "problem": "在一个用于化工生产线的网络物理系统（Cyber-Physical System, CPS）及其数字孪生（Digital Twin, DT）中，对远程阀门覆写操作的访问由一个混合的基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）层来调节。RBAC（Role-Based Access Control）通过角色确定粗粒度的资格，而ABAC（Attribute-Based Access Control）则使用主体、客体和环境的属性来细化决策。一个策略决策点（Policy Decision Point, PDP）为每个请求评估一组固定的子策略，并返回集合 $\\{\\mathsf{Permit}, \\mathsf{Deny}, \\mathsf{NotApplicable}, \\mathsf{Indeterminate}\\}$ 中的单个决策。考虑一个承包商，其属性导致对在运行中的生产线上发出远程阀门覆写的请求产生以下子策略结果：授权验证为 $\\mathsf{Deny}$，因为承包商的授权昨天已过期；培训时效性为 $\\mathsf{Permit}$，因为承包商本周通过了所需模块；主管证明为 $\\mathsf{Indeterminate}$，因为证明服务不可达；环境风险策略为 $\\mathsf{NotApplicable}$，因为风险模型因维护而被禁用。该组织强制要求数字孪生和物理控制器都执行相同的组合决策。\n\n您的任务是为PDP选择一种策略组合算法，以使组合决策满足以下植根于既定安全设计原则和安全工程的基本安全要求：\n\n- 失效安全默认：在没有足够证据允许的情况下，返回 $\\mathsf{Deny}$。\n- 安全单调性：添加任何安全负面证据（例如，过期的授权）或不确定性（例如，评估故障）都不能使决策变得更不安全；通俗地说，额外的负面或不确定信息不能将一个 $\\mathsf{Deny}$ 翻转为 $\\mathsf{Permit}$。\n- 冲突下的确定性：对于任何子策略决策的多重集，包括冲突的结果（如同时出现 $\\mathsf{Permit}$ 和 $\\mathsf{Deny}$），结果都是唯一确定的，并偏向于安全。\n\n假设组合算子应用于一个决策的多重集，并且必须可以分布式部署（因此必须对评估顺序和分组不敏感）。鉴于承包商的情况，以下哪种组合算法最能满足此CPS和DT的上述要求？\n\nA. 保守的拒绝优先并默认拒绝：对多重集 $M \\subseteq \\{\\mathsf{Permit}, \\mathsf{Deny}, \\mathsf{NotApplicable}, \\mathsf{Indeterminate}\\}$ 定义 $F$ 如下\n$$\nF(M)=\n\\begin{cases}\n\\mathsf{Deny},  & \\text{如果 } \\exists d\\in M \\text{ 且 } d=\\mathsf{Deny},\\\\\n\\mathsf{Deny},  & \\text{否则如果 } \\exists d\\in M \\text{ 且 } d=\\mathsf{Indeterminate},\\\\\n\\mathsf{Permit}, & \\text{否则如果 } \\exists d\\in M \\text{ 且 } d=\\mathsf{Permit},\\\\\n\\mathsf{Deny},  & \\text{否则}~(\\text{即所有 } d=\\mathsf{NotApplicable}).\n\\end{cases}\n$$\n\nB. 允许优先并乐观默认：如果任何子策略返回 $\\mathsf{Permit}$，则返回 $\\mathsf{Permit}$；仅当所有子策略都返回 $\\mathsf{Deny}$ 时才返回 $\\mathsf{Deny}$；将 $\\mathsf{Indeterminate}$ 视为 $\\mathsf{NotApplicable}$。\n\nC. 按固定优先级顺序首个适用：按“培训时效性、授权验证、主管证明、环境风险策略”的固定顺序评估子策略；返回第一个不为 $\\mathsf{NotApplicable}$ 的结果。\n\nD. 加权投票聚合器：将 $\\mathsf{Permit}\\mapsto +1$, $\\mathsf{Deny}\\mapsto -1$, $\\mathsf{NotApplicable}\\mapsto 0$, $\\mathsf{Indeterminate}\\mapsto -1$ 进行映射，计算分数总和，如果总和大于 $0$ 则返回 $\\mathsf{Permit}$，否则返回 $\\mathsf{Deny}$。\n\n选择最佳选项，并根据所述属性以及工业网络物理系统及其数字孪生的安全背景来证明您的选择。",
            "solution": "我们从安全关键系统的访问控制基本原则开始。PDP实现一个决策函数 $D:\\mathcal{S}\\times \\mathcal{O}\\times \\mathcal{A}\\times \\mathcal{E}\\to \\{\\mathsf{Permit},\\mathsf{Deny},\\mathsf{NotApplicable},\\mathsf{Indeterminate}\\}$，其中 $\\mathcal{S}$、$\\mathcal{O}$、$\\mathcal{A}$ 和 $\\mathcal{E}$ 分别表示主体、客体、操作和环境的属性空间。函数 $D$ 是通过组合子策略结果来实现的。设计必须遵循两个核心的安全设计原则：失效安全默认（默认拒绝）和最小权限，这在策略组合方面导出以下约束。\n\n定义决策集合 $\\mathcal{D}=\\{\\mathsf{Permit},\\mathsf{Deny},\\mathsf{NotApplicable},\\mathsf{Indeterminate}\\}$。为了进行安全推理，引入一个在 $\\mathcal{D}$ 上的安全预序 $\\preceq_s$，该预序编码了 $\\mathsf{Deny}$ 是最安全的，在一个失效安全的设计中，$\\mathsf{Indeterminate}$ 比 $\\mathsf{Deny}$ 不安全但比 $\\mathsf{Permit}$ 安全，而 $\\mathsf{NotApplicable}$ 不提供任何证据，且其本身不能提升风险。一个能捕捉此意的保守排序是\n$$\n\\mathsf{Permit} \\;\\prec_s\\; \\mathsf{Indeterminate} \\;\\prec_s\\; \\mathsf{Deny},\n$$\n其中 $\\mathsf{NotApplicable}$ 被视为一个中性元素，既不应强制降级也不应强制升级，并且在聚合前被排除。安全单调性要求，对于任何决策的多重集 $M$ 以及通过添加 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 形成的任何扩展 $M' \\supseteq M$，组合函数 $F$ 必须满足\n$$\nF(M') \\succeq_s F(M).\n$$\n失效安全默认要求 $F(\\varnothing)=\\mathsf{Deny}$，其中 $\\varnothing$ 代表所有子策略均为 $\\mathsf{NotApplicable}$ 或不提供证据的情况。确定性和可分布性要求 $F$ 对顺序和分组不敏感，即 $F$ 对于多重集并集操作必须是可交换的、可结合的和幂等的，这样数字孪生和物理控制器中的分布式评估即使策略片段以不同顺序组合，也能始终产生相同的结果。\n\n在这些约束下，组合算子必须在丢弃 $\\mathsf{NotApplicable}$ 后，从多重集中选择最保守的结果。此外，在安全关键的CPS中，不确定性必须被视为风险，因此 $\\mathsf{Indeterminate}$ 必须被归结为 $\\mathsf{Deny}$，以避免在存在评估故障时出现不安全的允许。形式上，这产生了一个保守的拒绝优先并默认拒绝的规则：如果出现 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$，则返回 $\\mathsf{Deny}$；否则，如果出现任何 $\\mathsf{Permit}$，则返回 $\\mathsf{Permit}$；否则返回 $\\mathsf{Deny}$。该算子仅依赖于类别的存在，而不依赖于它们的顺序，因此是可结合的、可交换的和幂等的。它也满足安全单调性，因为在排序 $\\preceq_s$ 中添加 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 不会降低安全性。\n\n将承包商的场景实例化，结果的多重集是 $M=\\{\\mathsf{Deny},\\mathsf{Permit},\\mathsf{Indeterminate},\\mathsf{NotApplicable}\\}$。一个保守的拒绝优先并默认拒绝的规则返回 $\\mathsf{Deny}$，这在授权过期和主管证明不确定的情况下，阻止了危险的覆写操作。\n\n我们现在根据所述属性分析每个选项。\n\n选项 A：保守的拒绝优先并默认拒绝。\n- 形式化定义：如果 $M$ 包含 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$，则 $F(M)=\\mathsf{Deny}$；否则如果 $M$ 包含 $\\mathsf{Permit}$，则 $F(M)=\\mathsf{Permit}$；否则 $F(M)=\\mathsf{Deny}$。\n- 失效安全默认：满足，因为 $F(\\varnothing)=\\mathsf{Deny}$ 且 $\\mathsf{NotApplicable}$ 不会产生 $\\mathsf{Permit}$。\n- 安全单调性：满足，因为添加 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 会强制或保持 $\\mathsf{Deny}$；添加 $\\mathsf{Permit}$ 不能覆盖已有的 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$。\n- 确定性和可分布性：满足，因为结果仅取决于类别的存在，而不取决于顺序；等价地，对于多重集并集，$F$ 是可结合的、可交换的和幂等的。\n- 应用于该场景：鉴于存在 $\\mathsf{Deny}$ 和 $\\mathsf{Indeterminate}$，返回 $\\mathsf{Deny}$，与安全性要求一致。\n结论：正确。\n\n选项 B：允许优先并乐观默认；将 $\\mathsf{Indeterminate}$ 视为 $\\mathsf{NotApplicable}$。\n- 失效安全默认：在一般情况下违反，因为单个 $\\mathsf{Permit}$ 就会产生 $\\mathsf{Permit}$，即使其他策略是 $\\mathsf{NotApplicable}$。\n- 安全单调性：违反，因为向一个包含 $\\mathsf{Deny}$ 的多重集添加一个 $\\mathsf{Permit}$ 可以将决策翻转为 $\\mathsf{Permit}$，从而降低安全性。在承包商的场景中，$\\mathsf{Permit}$ 和 $\\mathsf{Deny}$ 的存在会产生 $\\mathsf{Permit}$，这是不安全的。\n- 确定性：该算子是确定性的，但不安全。\n结论：不正确。\n\n选项 C：按固定优先级顺序首个适用。\n- 失效安全默认：不保证；如果顺序中的第一个策略返回 $\\mathsf{Permit}$，则后面的 $\\mathsf{Deny}$ 会被忽略。\n- 安全单调性：违反，因为决策可能仅因策略重新排序而改变，而不是因证据改变，且后面的 $\\mathsf{Deny}$ 无法覆盖前面的 $\\mathsf{Permit}$。这允许在存在负面证据的情况下出现一个较不安全的结果。\n- 确定性和可分布性：确定性依赖于全局顺序；可分布性差，因为分布式片段可能对评估顺序存在分歧，违反了DT和控制器必须保持一致的要求。\n- 应用于该场景：以培训为先，尽管授权已过期，仍会返回 $\\mathsf{Permit}$，这是不安全的。\n结论：不正确。\n\n选项 D：加权投票聚合器，其中 $\\mathsf{Permit}\\mapsto +1$, $\\mathsf{Deny}\\mapsto -1$, $\\mathsf{NotApplicable}\\mapsto 0$, $\\mathsf{Indeterminate}\\mapsto -1$，如果总和 $>0$ 则允许，否则拒绝。\n- 失效安全默认：如果所有都是 $\\mathsf{NotApplicable}$，总和为 $0$，产生 $\\mathsf{Deny}$，这与默认拒绝一致，但这仅仅是由于选定的阈值；其他阈值会破坏此属性，即使使用此阈值，在其他组合中也可能违反安全性。\n- 安全单调性：违反，因为 $\\mathsf{Permit}$ 投票在数值上可以超过单个 $\\mathsf{Deny}$，从而在存在负面证据的情况下允许 $\\mathsf{Permit}$。例如，两个 $\\mathsf{Permit}$ 和一个 $\\mathsf{Deny}$ 的总和为 $+1$，产生 $\\mathsf{Permit}$，这与保守安全性相矛盾。此外，数值求和满足结合律，但映射和阈值处理并不能强制任何 $\\mathsf{Deny}$ 或 $\\mathsf{Indeterminate}$ 成为吸收状态。\n- 确定性：在权重固定的情况下是确定性的，但未能满足核心安全属性。\n- 应用于该场景：该多重集映射为分数值：$\\mathsf{Deny}$ 为 $-1$，$\\mathsf{Permit}$ 为 $+1$，$\\mathsf{Indeterminate}$ 为 $-1$，$\\mathsf{NotApplicable}$ 为 $0$；总和为 $-1$，因此在这种特定情况下为 $\\mathsf{Deny}$，但该方法会在其他危险组合中允许操作，作为设计原则违反了安全单调性。\n结论：不正确。\n\n通过从失效安全默认、安全单调性和可分布性推导，只有选项 A 中的保守的拒绝优先并默认拒绝算子满足要求，并为承包商的冲突属性产生一个确定的 $\\mathsf{Deny}$，从而保护数字孪生和物理过程在不确定性和授权过期期间免受不安全的覆写操作。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在确定了策略冲突的解决方法后，安全管理员的核心任务是精确地授予权限，同时严格遵守最小权限原则——即仅授予完成任务所必需的最小访问权限。本练习  构建了一个混合了基于角色的访问控制 (RBAC) 和基于属性的访问控制 (ABAC) 的场景，访问决策同时取决于分配的角色和动态的属性。您将通过具体计算，为一个新角色设计最优的用户分配和权限分配方案，以实践如何在复杂的工业安全策略管理中有效实施最小权限原则。",
            "id": "4241687",
            "problem": "一个用于信息物理工业工厂的混合访问控制系统结合了基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）。基于角色的访问控制（RBAC）由一个用户到角色的分配关系 $UA \\subseteq U \\times R$ 和一个权限到角色的分配关系 $PA \\subseteq P \\times R$ 定义。当且仅当存在一个角色 $r^{\\star} \\in R$，使得 $(u,r^{\\star}) \\in UA$、对于权限 $p=(a,r)$ 有 $(p,r^{\\star}) \\in PA$，并且一个基于属性的访问控制（ABAC）策略谓词在主体和资源属性上评估为真时，用户 $u \\in U$ 对资源 $r$ 执行操作 $a$ 的请求才被允许。\n\n该工厂包含 $12$ 个可编程逻辑控制器（PLC），索引为 $I=\\{1,2,\\dots,12\\}$。每个 PLC $i \\in I$ 都有一个资源属性签名\n$$\ns(i) = \\big(Z(i), V(i), C(i)\\big) \\in \\{Z_1,Z_2,Z_3\\} \\times \\{A,B\\} \\times \\{0,1\\},\n$$\n其中 $Z(i)$ 是其区域，$V(i)$ 是其供应商，$C(i)$ 是其安全关键标志（$C(i)=1$ 表示安全关键）。签名为：\n$$\n\\begin{aligned}\ns(1)=(Z_1,A,0),\\quad s(2)=(Z_1,A,0),\\quad s(3)=(Z_1,B,0),\\quad s(4)=(Z_2,A,0),\\\\\ns(5)=(Z_2,A,0),\\quad s(6)=(Z_2,B,1),\\quad s(7)=(Z_3,A,0),\\quad s(8)=(Z_3,A,0),\\\\\ns(9)=(Z_3,B,0),\\quad s(10)=(Z_3,B,1),\\quad s(11)=(Z_2,B,0),\\quad s(12)=(Z_1,B,1).\n\\end{aligned}\n$$\n\n权限集 $P$ 为每个 $i \\in I$ 包含一个元素 $(\\text{fw\\_upgrade}, i)$，代表对 PLC $i$ 执行固件升级的权限。必须添加一个新的维护角色 $r_{\\mathrm{new}}$，以仅在指定的子集\n$$\nS=\\{1,2,3,4,5,7,9\\} \\subset I,\n$$\n上启用固件升级，且不在任何其他 PLC 上启用。ABAC 策略在评估时强制执行以下主体和资源谓词：\n- 主体谓词要求许可级别和区域认证：对于用户 $u$，令 $c(u) \\in \\mathbb{N}$ 表示其许可级别，$\\mathrm{cert}(u) \\subseteq \\{Z_1,Z_2,Z_3\\}$ 表示其区域认证；主体侧谓词是\n$$\n\\Phi_{\\mathrm{sub}}(u,i) \\equiv \\big(c(u) \\geq 4\\big) \\land \\big(Z(i) \\in \\mathrm{cert}(u)\\big).\n$$\n- 与 $r_{\\mathrm{new}}$ 相关联的权限所允许的资源侧谓词语言仅限于对 $(Z,V,C)$ 的等式合取；也就是说，资源谓词的形式为\n$$\n\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i) \\equiv \\big(Z(i)=Z^\\prime\\big) \\land \\big(V(i)=V^\\prime\\big) \\land \\big(C(i)=0\\big),\n$$\n并且不能提及 PLC 标识符 $i$，也不能包含析取。然而，RBAC 权限是在特定 PLC 身份 $(\\text{fw\\_upgrade}, i)$ 的粒度上定义的，因此对 $r_{\\mathrm{new}}$ 的权限分配可以是以下任一形式：\n- 一种组分配，将 $r_{\\mathrm{new}}$ 链接到所有满足 $\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i)$ 的 $(\\text{fw\\_upgrade}, i)$，计为对 $PA$ 的一次添加，前提是这不会授予对 $S$ 之外任何 PLC 的访问权限；或者\n- 一种按资源分配，将 $r_{\\mathrm{new}}$ 链接到特定 $i$ 的 $(\\text{fw\\_upgrade}, i)$，计为对 $PA$ 的一次添加。\n\n职责分离（SoD）约束：已在冲突角色 \"OpsEngineer\" 中的用户不能被分配到 $r_{\\mathrm{new}}$。现有的维护用户集为 $U=\\{u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8\\}$，其属性如下\n$$\n\\begin{aligned}\nu_1: c(u_1)=4,\\ \\mathrm{cert}(u_1)=\\{Z_1,Z_2\\},\\ \\text{无冲突};\\\\\nu_2: c(u_2)=4,\\ \\mathrm{cert}(u_2)=\\{Z_3\\},\\ \\text{无冲突};\\\\\nu_3: c(u_3)=3,\\ \\mathrm{cert}(u_3)=\\{Z_1\\},\\ \\text{无冲突};\\\\\nu_4: c(u_4)=5,\\ \\mathrm{cert}(u_4)=\\{Z_1,Z_3\\},\\ \\text{冲突 (OpsEngineer)};\\\\\nu_5: c(u_5)=4,\\ \\mathrm{cert}(u_5)=\\{Z_2\\},\\ \\text{无冲突};\\\\\nu_6: c(u_6)=4,\\ \\mathrm{cert}(u_6)=\\{Z_1\\},\\ \\text{无冲突};\\\\\nu_7: c(u_7)=2,\\ \\mathrm{cert}(u_7)=\\{Z_3\\},\\ \\text{无冲突};\\\\\nu_8: c(u_8)=5,\\ \\mathrm{cert}(u_8)=\\{Z_2,Z_3\\},\\ \\text{冲突 (OpsEngineer)}.\n\\end{aligned}\n$$\n\n采用以下基本决策规则：一个请求 $(u,\\text{fw\\_upgrade},i)$ 被允许，当且仅当存在 $(u,r_{\\mathrm{new}}) \\in UA$，并且或者存在某个 $(Z^\\prime,V^\\prime)$ 的组分配使得 $\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i)$ 成立，或者存在对 $i$ 的按资源分配在 $PA$ 中，并且 $\\Phi_{\\mathrm{sub}}(u,i)$ 成立。\n\n在最小权限目标下，将 $\\Delta UA$ 定义为需要添加到 $UA$ 中的最小新用户-角色边集合，以确保恰好在 $S$ 中的 PLC（且没有其他 PLC）上启用升级；并将 $\\Delta PA$ 定义为需要添加到 $PA$ 中的最小新权限-角色边集合，该集合需满足资源谓词语言的约束以及 $S$ 之外的 PLC 不会因 $r_{\\mathrm{new}}$ 而变得可升级的约束。\n\n计算整数对 $\\big(|\\Delta UA|,\\,|\\Delta PA|\\big)$，其中 $|\\cdot|$ 表示集合的基数。以行矩阵的形式表示您的最终答案，使用两个条目，顺序为 $\\big(|\\Delta UA|,\\,|\\Delta PA|\\big)$。无需四舍五入。无需单位。",
            "solution": "问题要求确定所需的用户-角色分配的最小数量 $|\\Delta UA|$ 和权限-角色分配的最小数量 $|\\Delta PA|$，以授予新角色 $r_{\\mathrm{new}}$ 在一组特定的可编程逻辑控制器（PLC）$S=\\{1,2,3,4,5,7,9\\}$ 上执行固件升级的能力，并且不能在任何其他 PLC 上执行。\n\n用户 $u$ 对 PLC $i$ 执行操作 'fw\\_upgrade' 的请求的最终决策规则是，必须同时满足以下三个条件：\n1. 用户 $u$ 被分配了角色 $r_{\\mathrm{new}}$：$(u, r_{\\mathrm{new}}) \\in UA$。\n2. 权限 $(\\text{fw\\_upgrade}, i)$ 被分配给了角色 $r_{\\mathrm{new}}$：$((\\text{fw\\_upgrade}, i), r_{\\mathrm{new}}) \\in PA$。\n3. 主体侧 ABAC 谓词为真：$\\Phi_{\\mathrm{sub}}(u,i) \\equiv (c(u) \\geq 4) \\land (Z(i) \\in \\mathrm{cert}(u))$。\n\n我们必须找到最小的集合 $\\Delta UA$ 和 $\\Delta PA$，以满足对所有 $i \\in S$ 的这些条件，并且对任何 $i \\notin S$ 都不满足。\n\n首先，我们确定权限分配的最小集合 $\\Delta PA$。\n对 $r_{\\mathrm{new}}$ 的权限可以通过两种方式分配给 $PA$：\na) 组分配，基于谓词 $\\Phi_{\\mathrm{res}}^{(Z^\\prime,V^\\prime)}(i) \\equiv (Z(i)=Z^\\prime) \\land (V(i)=V^\\prime) \\land (C(i)=0)$。只有当所有匹配此谓词的 PLC 集合是 $S$ 的一个子集时，这才是有效的。这样一条规则会向 $\\Delta PA$ 中添加 $1$ 个元素。\nb) 对特定 PLC $i$ 的按资源分配。这也会向 $\\Delta PA$ 中添加 $1$ 个元素。\n\n目标是用最少数量的此类分配覆盖 $S=\\{1,2,3,4,5,7,9\\}$ 中的所有 PLC。让我们分析所有 $12$ 个 PLC 的属性：\n$s(1)=(Z_1,A,0)$, $s(2)=(Z_1,A,0)$, $s(3)=(Z_1,B,0)$, $s(4)=(Z_2,A,0)$, $s(5)=(Z_2,A,0)$, $s(6)=(Z_2,B,1)$, $s(7)=(Z_3,A,0)$, $s(8)=(Z_3,A,0)$, $s(9)=(Z_3,B,0)$, $s(10)=(Z_3,B,1)$, $s(11)=(Z_2,B,0)$, $s(12)=(Z_1,B,1)$。\n目标集是 $S=\\{1,2,3,4,5,7,9\\}$。不在 $S$ 中的 PLC 集合是 $I \\setminus S = \\{6,8,10,11,12\\}$。\n\n资源谓词 $\\Phi_{\\mathrm{res}}$ 要求 $C(i)=0$。这将 PLC $6$、$10$ 和 $12$ 立即从任何组规则的考虑中排除，因为它们的 $C(i)=1$。这是有利的，因为它们都在 $S$ 之外。剩余的 $C(i)=0$ 的 PLC 是 $\\{1,2,3,4,5,7,8,9,11\\}$。\n\n我们可以根据它们的 $(Z,V)$ 属性对这个集合进行划分，以识别潜在的组分配：\n- 集合 $G_1 = \\{i \\mid Z(i)=Z_1, V(i)=A, C(i)=0\\} = \\{1,2\\}$。由于 $G_1 \\subseteq S$，对 $(Z_1, A)$ 的组分配是有效的。这覆盖了两个 PLC，$\\{1,2\\}$，需要 $1$ 个 PA 条目。\n- 集合 $G_2 = \\{i \\mid Z(i)=Z_1, V(i)=B, C(i)=0\\} = \\{3\\}$。由于 $G_2 \\subseteq S$，对 $(Z_1, B)$ 的组分配是有效的。它覆盖了一个 PLC，$\\{3\\}$，需要 $1$ 个 PA 条目。按资源分配将达到同样的效果。\n- 集合 $G_3 = \\{i \\mid Z(i)=Z_2, V(i)=A, C(i)=0\\} = \\{4,5\\}$。由于 $G_3 \\subseteq S$，对 $(Z_2, A)$ 的组分配是有效的。它覆盖了两个 PLC，$\\{4,5\\}$，需要 $1$ 个 PA 条目。\n- 集合 $G_4 = \\{i \\mid Z(i)=Z_2, V(i)=B, C(i)=0\\} = \\{11\\}$。由于 $11 \\notin S$，这个组分配对于覆盖 $S$ 中的任何 PLC 都没有用。\n- 集合 $G_5 = \\{i \\mid Z(i)=Z_3, V(i)=A, C(i)=0\\} = \\{7,8\\}$。由于 $8 \\notin S$，这个集合不是 $S$ 的子集。因此，对 $(Z_3, A)$ 的组分配是被禁止的。\n- 集合 $G_6 = \\{i \\mid Z(i)=Z_3, V(i)=B, C(i)=0\\} = \\{9\\}$。由于 $G_6 \\subseteq S$，对 $(Z_3, B)$ 的组分配是有效的。它覆盖了一个 PLC，$\\{9\\}$，需要 $1$ 个 PA 条目。\n\n为了用最少的 PA 条目覆盖 $S=\\{1,2,3,4,5,7,9\\}$ 中的所有 PLC：\n- 对于 $\\{1,2\\}$：使用对 $(Z_1, A, 0)$ 的组分配。这需要 $1$ 个 PA 条目。\n- 对于 $\\{4,5\\}$：使用对 $(Z_2, A, 0)$ 的组分配。这需要 $1$ 个 PA 条目。\n- 对于 $\\{3\\}$：必须进行按资源分配。这需要 $1$ 个 PA 条目。（使用对 $(Z_1, B, 0)$ 的组规则成本相同）。\n- 对于 $\\{7\\}$：组分配被禁止。需要进行按资源分配。这需要 $1$ 个 PA 条目。\n- 对于 $\\{9\\}$：必须进行按资源分配。这需要 $1$ 个 PA 条目。（使用对 $(Z_3, B, 0)$ 的组规则成本相同）。\n\n将这些加起来，$\\Delta PA$ 中的最小条目数为 $1+1+1+1+1=5$。因此，$|\\Delta PA| = 5$。\n\n接下来，我们确定用户分配的最小集合 $\\Delta UA$。\n我们需要将用户分配给角色 $r_{\\mathrm{new}}$，使得对于 $S$ 中的每个 PLC $i$，至少有一个被分配的用户 $u$ 满足主体谓词 $\\Phi_{\\mathrm{sub}}(u,i)$。\n首先，我们从集合 $U=\\{u_1, \\dots, u_8\\}$ 中识别出合格的用户。\n- 用户 $u_4$ 和 $u_8$ 拥有冲突角色 \"OpsEngineer\"，不能被分配到 $r_{\\mathrm{new}}$。\n- 用户 $u_3$ 的许可级别为 $c(u_3)=3$，低于要求的 $4$。所以 $u_3$ 不合格。\n- 用户 $u_7$ 的许可级别为 $c(u_7)=2$，也低于 $4$。所以 $u_7$ 不合格。\n合格的用户集合是 $\\{u_1, u_2, u_5, u_6\\}$。他们与 $\\Phi_{\\mathrm{sub}}$ 相关的属性是：\n- $u_1$：$c=4$，$\\mathrm{cert}=\\{Z_1, Z_2\\}$。可以访问区域 $Z_1$ 和 $Z_2$ 中的 PLC。\n- $u_2$：$c=4$，$\\mathrm{cert}=\\{Z_3\\}$。可以访问区域 $Z_3$ 中的 PLC。\n- $u_5$：$c=4$，$\\mathrm{cert}=\\{Z_2\\}$。可以访问区域 $Z_2$ 中的 PLC。\n- $u_6$：$c=4$，$\\mathrm{cert}=\\{Z_1\\}$。可以访问区域 $Z_1$ 中的 PLC。\n\n$S$ 中的 PLC 位于以下区域：\n- 区域 $Z_1$：PLC $\\{1,2,3\\}$。\n- 区域 $Z_2$：PLC $\\{4,5\\}$。\n- 区域 $Z_3$：PLC $\\{7,9\\}$。\n为了在 $S$ 中的所有 PLC 上启用升级，我们需要分配一组用户，他们的组合区域认证覆盖 $\\{Z_1, Z_2, Z_3\\}$。这是一个经典的集合覆盖问题。我们想找到覆盖这三个区域所需的最少用户数。\n\n- 为了覆盖区域 $Z_3$，我们必须选择用户 $u_2$，因为没有其他合格用户获得 $Z_3$ 的认证。所以，$(u_2, r_{\\mathrm{new}}) \\in \\Delta UA$。\n- 选择了 $u_2$ 后，我们仍然需要覆盖区域 $\\{Z_1, Z_2\\}$。我们可以通过选择用户 $u_1$ 来做到这一点，他同时拥有 $\\{Z_1, Z_2\\}$ 的认证。这将 $(u_1, r_{\\mathrm{new}})$ 添加到 $\\Delta UA$ 中。用户总数为 $2$。\n- 或者，我们可以通过选择用户 $u_6$（用于 $Z_1$）和用户 $u_5$（用于 $Z_2$）来覆盖 $\\{Z_1, Z_2\\}$。这将需要两个额外的用户，总共为 $1+2=3$ 个用户。\n最小的选择是选择用户 $\\{u_1, u_2\\}$，这覆盖了所有需要的区域。因此，用户-角色分配的最小集合是 $\\Delta UA = \\{(u_1, r_{\\mathrm{new}}), (u_2, r_{\\mathrm{new}})\\}$。其基数为 $|\\Delta UA| = 2$。\n\n“且没有其他”的约束得到了保证，因为我们对 $\\Delta PA$ 的构建确保了对 $r_{\\mathrm{new}}$ 的权限仅存在于 $S$ 中的 PLC。因此，即使用户对 $S$ 之外的某个 PLC（比如 PLC 8）拥有适当的许可级别和认证，请求也会被拒绝，因为在 $PA$ 中没有针对 $(\\text{fw\\_upgrade}, 8)$ 和角色 $r_{\\mathrm{new}}$ 的相应条目。\n\n最终结果是基数对 $(|\\Delta UA|, |\\Delta PA|)$。\n$|\\Delta UA| = 2$。\n$|\\Delta PA| = 5$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  & 5\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "信息物理系统在现实世界中运行，其传感器的读数往往带有噪声和不确定性。一个忽略了这一现实的访问控制策略可能会做出不安全的决策，从而引发危险。本练习  将鲁棒控制理论的思想应用于访问控制设计，通过对传感器误差进行建模和最坏情况分析，您可以设计出在测量不精确的情况下依然能保证安全的策略。您将通过计算一个决策“滞后环”，学习如何构建一个对物理世界的不确定性具有鲁棒性的策略，以避免因数据噪声而导致的灾难性后果。",
            "id": "4241643",
            "problem": "在一个信息物理生产系统中，一个工业机器人装配单元集成了一个数字孪生模型，用于在执行大功率运动前持续评估情境安全性。访问决策结合了基于角色的访问控制 (RBAC) 和基于属性的访问控制 (ABAC)：用户必须拥有适当的角色，并且一个由情境推导出的风险指数必须证明操作的安全性。ABAC 组件评估一个无量纲的情境风险指数 $R(c)$，该指数由一个包含以下元素的实值属性向量 $c \\in \\mathbb{R}^{3}$ 计算得出：振动幅度 $c_{1}$、工作空间间隙 $c_{2}$ 和关节扭矩负载 $c_{3}$。数字孪生使用线性模型 $R(c) = w^{\\top} c$（权重 $w = (0.4,\\,-0.2,\\,0.7)$）计算风险指数，其中更高的振动和扭矩会增加风险，而更大的间隙会降低风险。安全性要求由一个无量纲阈值 $r_{\\text{safe}} = 1.8$ 表示：只有当真实风险 $R(c)$ 不超过 $r_{\\text{safe}}$ 时，动作才能继续执行。\n\n然而，测量所得的属性 $\\hat{c}$ 受到有界传感器误差 $e$ 的干扰，该误差满足已知的保证条件 $\\|e\\|_{\\infty} \\leq \\epsilon$（其中 $\\epsilon = 0.03$，即每个属性与其真实值的偏差最多为 $0.03$），且 $\\hat{c} = c + e$。为在最坏测量误差情况下容忍小的波动同时防止不安全的动作，您需要为 ABAC 决策设计一个使用两个阈值的鲁棒滞后带：\n- 一个“允许”阈值 $\\tau_{\\text{allow}}$，使得当 $R(\\hat{c}) \\leq \\tau_{\\text{allow}}$ 时，可以保证 $R(c) \\leq r_{\\text{safe}}$。\n- 一个“拒绝”阈值 $\\tau_{\\text{deny}}$，使得当 $R(\\hat{c}) \\geq \\tau_{\\text{deny}}$ 时，可以保证 $R(c) \\geq r_{\\text{safe}}$。\n\n在此带内，系统将推迟决策并请求额外的证据或等待系统稳定。请从范数和风险聚合的基本定义出发，在 $\\|e\\|_{\\infty} \\leq \\epsilon$ 的条件下，推导出 $|R(\\hat{c}) - R(c)|$ 的一个保守最坏情况界限。然后，使用该界限和给定的 $w$、$\\epsilon$ 及 $r_{\\text{safe}}$，计算出 $\\tau_{\\text{allow}}$ 和 $\\tau_{\\text{deny}}$ 的精确数值。将两个阈值均表示为无量纲值。无需四舍五入，最终答案必须是这对阈值组成的单行矩阵。",
            "solution": "本问题要求通过确定一个“允许”阈值 $\\tau_{\\text{allow}}$ 和一个“拒绝”阈值 $\\tau_{\\text{deny}}$，为一个基于属性的访问控制 (ABAC) 系统设计鲁棒滞后带。这需要基于一个线性风险模型、一个安全阈值以及已知的传感器测量误差界限来完成。\n\n第一步是量化真实风险指数 $R(c)$ 与根据测量属性计算出的风险指数 $R(\\hat{c})$ 之间的最大可能偏差。\n\n真实风险由线性模型 $R(c) = w^{\\top} c$ 给出，其中 $c \\in \\mathbb{R}^{3}$ 是真实属性值向量，$w \\in \\mathbb{R}^{3}$ 是权重向量。\n测量属性为 $\\hat{c} = c + e$，其中 $e \\in \\mathbb{R}^{3}$ 是传感器误差向量。\n因此，根据测量属性计算出的风险为：\n$$R(\\hat{c}) = w^{\\top} \\hat{c} = w^{\\top} (c + e) = w^{\\top} c + w^{\\top} e = R(c) + w^{\\top} e$$\n因此，测量风险与真实风险之间的差值为 $\\Delta R = R(\\hat{c}) - R(c) = w^{\\top} e$。\n\n我们需要找到这个差值的最坏情况（最大绝对）值，记为 $\\Delta R_{\\max}$。误差向量 $e$ 受其无穷范数约束，$\\|e\\|_{\\infty} \\leq \\epsilon$，这意味着对于向量 $e$ 的每个分量 $e_i$，我们有 $|e_i| \\leq \\epsilon$。\n\n风险差的绝对值为 $|w^{\\top} e| = |\\sum_{i=1}^{3} w_i e_i|$。\n使用三角不等式，我们可以对该表达式进行放缩：\n$$|\\sum_{i=1}^{3} w_i e_i| \\leq \\sum_{i=1}^{3} |w_i e_i| = \\sum_{i=1}^{3} |w_i| |e_i|$$\n由于我们知道对于所有的 $i \\in \\{1, 2, 3\\}$ 都有 $|e_i| \\leq \\epsilon$，我们可以进一步对该和进行放缩：\n$$\\sum_{i=1}^{3} |w_i| |e_i| \\leq \\sum_{i=1}^{3} |w_i| \\epsilon = \\epsilon \\sum_{i=1}^{3} |w_i|$$\n和 $\\sum_{i=1}^{3} |w_i|$ 是权重向量 $w$ 的 $L_1$-范数的定义，记为 $\\|w\\|_1$。这个结果是 Hölder 不等式的一个具体应用，该不等式表明对于共轭指数 $p, q$，有 $|x^{\\top}y| \\leq \\|x\\|_p \\|y\\|_q$。此处我们使用 $p=1$ 和 $q=\\infty$。\n\n因此，测量风险与真实风险之间的最大可能绝对差值为：\n$$\\Delta R_{\\max} = \\sup_{\\|e\\|_{\\infty} \\leq \\epsilon} |w^{\\top} e| = \\epsilon \\|w\\|_1$$\n这个界是紧的，因为可以通过为每个 $i$ 选择误差向量 $e$ 使其满足 $e_i = \\epsilon \\cdot \\text{sgn}(w_i)$ 来达到。\n\n现在，我们计算 $\\Delta R_{\\max}$ 的数值。\n给定的权重向量为 $w = (0.4, -0.2, 0.7)$。其 $L_1$-范数为：\n$$\\|w\\|_1 = |0.4| + |-0.2| + |0.7| = 0.4 + 0.2 + 0.7 = 1.3$$\n给定的误差界为 $\\epsilon = 0.03$。\n最大风险偏差为：\n$$\\Delta R_{\\max} = \\epsilon \\|w\\|_1 = 0.03 \\times 1.3 = 0.039$$\n所以，我们得到不等式 $|R(c) - R(\\hat{c})| \\leq 0.039$，这等价于：\n$$R(\\hat{c}) - 0.039 \\leq R(c) \\leq R(\\hat{c}) + 0.039$$\n\n接下来，我们推导阈值 $\\tau_{\\text{allow}}$ 和 $\\tau_{\\text{deny}}$。安全性要求为 $R(c) \\leq r_{\\text{safe}}$，其中 $r_{\\text{safe}} = 1.8$。\n\n对于“允许”阈值 $\\tau_{\\text{allow}}$，其条件是：如果 $R(\\hat{c}) \\leq \\tau_{\\text{allow}}$，则可以保证 $R(c) \\leq r_{\\text{safe}}$。\n为保证真实风险 $R(c)$ 不超过 $r_{\\text{safe}}$，我们必须确保其最大可能值小于或等于 $r_{\\text{safe}}$。从上面的不等式可知，对于一个给定的测量值 $\\hat{c}$，$R(c)$ 的最大可能值为 $R(\\hat{c}) + \\Delta R_{\\max}$。\n因此，我们必须强制执行以下条件：\n$$R(\\hat{c}) + \\Delta R_{\\max} \\leq r_{\\text{safe}}$$\n这等价于 $R(\\hat{c}) \\leq r_{\\text{safe}} - \\Delta R_{\\max}$。\n为了使“允许”区域尽可能大，我们将阈值设置为其最大允许值：\n$$\\tau_{\\text{allow}} = r_{\\text{safe}} - \\Delta R_{\\max}$$\n代入数值：\n$$\\tau_{\\text{allow}} = 1.8 - 0.039 = 1.761$$\n\n对于“拒绝”阈值 $\\tau_{\\text{deny}}$，其条件是：如果 $R(\\hat{c}) \\geq \\tau_{\\text{deny}}$，则可以保证 $R(c) \\geq r_{\\text{safe}}$。\n为保证真实风险 $R(c)$ 至少为 $r_{\\text{safe}}$，我们必须确保其最小可能值大于或等于 $r_{\\text{safe}}$。从上面的不等式可知，对于一个给定的测量值 $\\hat{c}$，$R(c)$ 的最小可能值为 $R(\\hat{c}) - \\Delta R_{\\max}$。\n因此，我们必须强制执行以下条件：\n$$R(\\hat{c}) - \\Delta R_{\\max} \\geq r_{\\text{safe}}$$\n这等价于 $R(\\hat{c}) \\geq r_{\\text{safe}} + \\Delta R_{\\max}$。\n为了使“拒绝”区域仅在必要时触发（即，使滞后带尽可能窄），我们将阈值设置为其最小允许值：\n$$\\tau_{\\text{deny}} = r_{\\text{safe}} + \\Delta R_{\\max}$$\n代入数值：\n$$\\tau_{\\text{deny}} = 1.8 + 0.039 = 1.839$$\n\n推导出的阈值为 $\\tau_{\\text{allow}} = 1.761$ 和 $\\tau_{\\text{deny}} = 1.839$。任何位于区间 $(1.761, 1.839)$ 内的测量风险 $R(\\hat{c})$ 都落在滞后带内，决策将被推迟。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.761  & 1.839\n\\end{pmatrix}\n}\n$$"
        }
    ]
}