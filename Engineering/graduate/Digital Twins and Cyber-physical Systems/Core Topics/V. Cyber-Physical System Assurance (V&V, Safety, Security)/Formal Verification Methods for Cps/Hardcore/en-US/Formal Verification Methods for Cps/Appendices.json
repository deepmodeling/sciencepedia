{
    "hands_on_practices": [
        {
            "introduction": "Formal verification begins with precise specification. This exercise introduces Signal Temporal Logic (STL), a powerful formalism for expressing properties of continuous and hybrid systems. You will translate a common safety requirement for a thermal system into an STL formula and then compute its 'robustness,' a quantitative measure of how well the system's behavior satisfies the specification . This practice is key to understanding how formal methods move beyond simple pass/fail verdicts to provide richer, more useful feedback for system design and monitoring.",
            "id": "4223138",
            "problem": "A thermal chamber Cyber-Physical System (CPS) is monitored by a digital twin that checks specifications expressed in Signal Temporal Logic (STL). The monitored signal is the chamber temperature $T(t)$, modeled as a continuous-time trace. The requirement is: “the temperature stays within $[T_{\\min},T_{\\max}]$ until it drops below $T_{\\max}-\\delta$ within $10$ minutes.” Interpret “within $10$ minutes” as a bounded time window of length $600$ seconds starting at the current time $t=0$, and interpret “stays within $[T_{\\min},T_{\\max}]$” as a closed interval constraint on $T(t)$.\n\n1. Write a single STL formula that captures this requirement using the bounded “until” operator and atomic predicates of the form $g(T(t)) \\ge 0$.\n\n2. Using standard quantitative (robust) semantics for STL, compute the robustness of your STL formula at time $t=0$ for the following parameter values and temperature trace:\n- $T_{\\min} = 295$ K, $T_{\\max} = 330$ K, and $\\delta = 3$ K,\n- $T(t) = 329.4 - 0.02t$ for $t \\in [0,600]$ seconds.\n\nState your final robustness value as a single real number and express it in Kelvin. No approximation or rounding is required.",
            "solution": "The user-provided problem is assessed to be valid as it is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution.\n\nThe problem is addressed in two parts. First, a Signal Temporal Logic (STL) formula is constructed to represent the given requirement. Second, the quantitative robustness of this formula is computed for the specified signal trace and parameters.\n\nPart 1: STL Formula Construction\n\nThe requirement is: \"the temperature stays within $[T_{\\min}, T_{\\max}]$ until it drops below $T_{\\max}-\\delta$ within $10$ minutes.\" This structure implies a bounded \"until\" formula, $\\psi_1 \\mathcal{U}_I \\psi_2$. The time interval $I$ is specified as a window of $600$ seconds starting from time $t=0$, so $I=[0, 600]$.\n\nThe sub-formula $\\psi_1$ represents the condition \"the temperature stays within $[T_{\\min}, T_{\\max}]$\". This is a conjunction of two constraints: $T(t) \\ge T_{\\min}$ and $T(t) \\le T_{\\max}$. According to the problem specification, these must be expressed as atomic predicates of the form $g(T(t)) \\ge 0$.\nThe constraint $T(t) \\ge T_{\\min}$ is directly in the form $T(t) - T_{\\min} \\ge 0$. Let this atomic predicate be $\\pi_1$.\nThe constraint $T(t) \\le T_{\\max}$ is equivalent to $T_{\\max} - T(t) \\ge 0$. Let this atomic predicate be $\\pi_2$.\nTherefore, the sub-formula $\\psi_1$ is $\\pi_1 \\land \\pi_2$.\n\nThe sub-formula $\\psi_2$ represents the condition \"it drops below $T_{\\max}-\\delta$\". This corresponds to the inequality $T(t)  T_{\\max} - \\delta$. While strict inequality is not directly of the form $g(T(t)) \\ge 0$, we can formalize this as $T(t) \\le T_{\\max} - \\delta$ to fit the required predicate structure. This yields $(T_{\\max} - \\delta) - T(t) \\ge 0$. This interpretation is standard in robustness analysis, as the quantitative semantics for $g(x) > 0$ and $g(x) \\ge 0$ are identical. Let this atomic predicate be $\\pi_3$.\n\nCombining these components, the full STL formula $\\phi$ is:\n$$ \\phi \\equiv ((T(t) - T_{\\min} \\ge 0) \\land (T_{\\max} - T(t) \\ge 0)) \\mathcal{U}_{[0, 600]} ((T_{\\max} - \\delta) - T(t) \\ge 0) $$\n\nPart 2: Robustness Calculation\n\nThe quantitative (robust) semantics of an STL formula $\\phi$ for a signal $T$ at time $t$, denoted $\\rho(\\phi, T, t)$, measures how strongly the formula is satisfied (positive value) or violated (negative value). We need to compute $\\rho(\\phi, T, 0)$.\n\nThe standard quantitative semantics for the operators are:\n- Atomic predicate $g(T(t)) \\ge 0$: $\\rho(g(T(t)) \\ge 0, T, t) = g(T(t))$.\n- Conjunction $\\psi_a \\land \\psi_b$: $\\rho(\\psi_a \\land \\psi_b, T, t) = \\min(\\rho(\\psi_a, T, t), \\rho(\\psi_b, T, t))$.\n- Bounded until $\\psi_1 \\mathcal{U}_{[a,b]} \\psi_2$: $\\rho(\\psi_1 \\mathcal{U}_{[a,b]} \\psi_2, T, t) = \\sup_{t' \\in t+[a,b]} \\min(\\rho(\\psi_2, T, t'), \\inf_{t'' \\in [t, t']} \\rho(\\psi_1, T, t''))$.\n\nFor our formula $\\phi$ at $t=0$, this becomes:\n$$ \\rho(\\phi, T, 0) = \\sup_{t' \\in [0, 600]} \\min\\left( \\rho(\\pi_3, T, t'), \\inf_{t'' \\in [0, t']} \\rho(\\pi_1 \\land \\pi_2, T, t'') \\right) $$\n\nWe are given the parameters $T_{\\min} = 295$ K, $T_{\\max} = 330$ K, $\\delta = 3$ K, and the temperature trace $T(t) = 329.4 - 0.02t$ for $t \\in [0, 600]$.\n\nFirst, we compute the robustness for each atomic predicate as a function of time $t$:\n- $\\rho(\\pi_1, T, t) = T(t) - T_{\\min} = (329.4 - 0.02t) - 295 = 34.4 - 0.02t$.\n- $\\rho(\\pi_2, T, t) = T_{\\max} - T(t) = 330 - (329.4 - 0.02t) = 0.6 + 0.02t$.\n- $\\rho(\\pi_3, T, t) = (T_{\\max} - \\delta) - T(t) = (330 - 3) - (329.4 - 0.02t) = 327 - 329.4 + 0.02t = -2.4 + 0.02t$.\n\nNext, we compute the robustness of the conjunction $\\psi_1 = \\pi_1 \\land \\pi_2$:\n$$ \\rho(\\psi_1, T, t) = \\min(\\rho(\\pi_1, T, t), \\rho(\\pi_2, T, t)) = \\min(34.4 - 0.02t, 0.6 + 0.02t) $$\nThe function $34.4 - 0.02t$ is decreasing, while $0.6 + 0.02t$ is increasing. They are equal when $34.4 - 0.02t = 0.6 + 0.02t$, which solves to $0.04t = 33.8$, so $t = 845$ s. Since the time interval of interest for $t$ is $[0, 600]$, which is entirely below the crossing point, the term $0.6 + 0.02t$ is smaller throughout this interval.\nThus, for $t \\in [0, 600]$, $\\rho(\\psi_1, T, t) = 0.6 + 0.02t$.\n\nNow we evaluate the inner infimum term, $\\inf_{t'' \\in [0, t']} \\rho(\\psi_1, T, t'')$, for any $t' \\in [0, 600]$.\n$$ \\inf_{t'' \\in [0, t']} (0.6 + 0.02t'') $$\nSince $0.6 + 0.02t''$ is an increasing function, its infimum over the interval $[0, t']$ occurs at the start of the interval, $t''=0$.\nThe value of the infimum is therefore $0.6 + 0.02(0) = 0.6$.\n\nWe substitute this constant value back into the main robustness formula:\n$$ \\rho(\\phi, T, 0) = \\sup_{t' \\in [0, 600]} \\min(\\rho(\\pi_3, T, t'), 0.6) $$\n$$ \\rho(\\phi, T, 0) = \\sup_{t' \\in [0, 600]} \\min(-2.4 + 0.02t', 0.6) $$\n\nLet $f(t') = \\min(-2.4 + 0.02t', 0.6)$. We need to find the supremum of $f(t')$ on the interval $[0, 600]$.\nThe function $-2.4 + 0.02t'$ is increasing. Thus, the function $f(t')$ will increase until it reaches the constant value $0.6$, and then will remain at $0.6$. The point of transition occurs when $-2.4 + 0.02t' = 0.6$, which gives $0.02t' = 3.0$, or $t' = 150$ s.\n- For $t' \\in [0, 150]$, $f(t') = -2.4 + 0.02t'$. The value increases from $f(0) = -2.4$ to $f(150) = 0.6$.\n- For $t' \\in (150, 600]$, $f(t') = 0.6$.\nThe supremum (maximum value) of $f(t')$ on the interval $[0, 600]$ is therefore $0.6$.\n\nThe robustness value is a scalar quantity but inherits the units of the signal, which is temperature in Kelvin (K). Thus, the final robustness is $0.6$ K.",
            "answer": "$$\n\\boxed{0.6}\n$$"
        },
        {
            "introduction": "A core challenge in CPS verification is bridging the gap between continuous physical dynamics and their discrete-time digital models. This practice explores how properties like safety invariance, proven for a continuous system, can be preserved in a discrete-time simulation using the explicit Euler method. By analyzing the one-step error with Taylor's theorem, you will derive a maximum allowable simulation step-size $h_{\\max}$ that guarantees the safety invariant holds for the digital twin, a critical step in building trustworthy simulations .",
            "id": "4223164",
            "problem": "A digital twin monitoring a safety-critical Cyber-Physical System (CPS) simulates the continuous-time plant $\\dot{x}=f(x)$ with an explicit Euler step of size $h$, namely $x_{k+1}=x_k+h f(x_k)$. Let $f:\\mathbb{R}^n\\to\\mathbb{R}^n$ be continuously differentiable, and let $V:\\mathbb{R}^n\\to\\mathbb{R}$ be twice continuously differentiable. Consider the sublevel set $S=\\{x\\in\\mathbb{R}^n: V(x)\\le c\\}$, and assume $S$ is forward invariant for the continuous-time system with a strict boundary margin: for all $x$ such that $V(x)=c$, one has $\\nabla V(x)^{\\top} f(x)\\le -\\sigma$ with $\\sigma>0$. Assume there exists $\\delta>0$ such that for all $x$ with $|V(x)-c|\\le \\delta$, the vector field is bounded by $\\|f(x)\\|\\le F$ and the Hessian operator norm is bounded by $\\|\\nabla^2 V(x)\\|\\le H$, where $F>0$ and $H>0$, and $\\|\\cdot\\|$ denotes the Euclidean norm for vectors and the induced operator norm for matrices. Define the one-step Euler mismatch of the storage function by\n$$\n\\Delta_h V(x)\\coloneqq V\\big(x+h f(x)\\big)-V(x)-h\\,\\nabla V(x)^{\\top} f(x).\n$$\nUsing only the stated assumptions and standard Taylor’s theorem, derive an upper bound on $\\Delta_h V(x)$ that holds uniformly for all $x$ with $|V(x)-c|\\le \\delta$, and then use this bound together with the strict boundary margin to determine the largest step size $h_{\\max}$ such that the Euler-discretized dynamics preserve the forward invariance of $S$. Express your final answer as a single closed-form analytic expression for $h_{\\max}$ in terms of $\\sigma$, $H$, and $F$. Do not provide intermediate inequalities or a set description as your final answer; provide only $h_{\\max}$ as a single expression. No rounding is required.",
            "solution": "The problem requires the determination of the maximum Euler step size $h_{\\max}$ that preserves the forward invariance of a sublevel set $S$ for a discrete-time system obtained from a continuous-time system.\n\nFirst, we perform a validation of the problem statement.\nThe givens are:\n1.  Continuous-time dynamics: $\\dot{x}=f(x)$, where $f:\\mathbb{R}^n\\to\\mathbb{R}^n$ is continuously differentiable.\n2.  Discrete-time dynamics (Explicit Euler): $x_{k+1}=x_k+h f(x_k)$, with step size $h>0$.\n3.  Storage function: $V:\\mathbb{R}^n\\to\\mathbb{R}$ is twice continuously differentiable.\n4.  Invariant set for the continuous system: $S=\\{x\\in\\mathbb{R}^n: V(x)\\le c\\}$.\n5.  Strict boundary margin condition: For all $x$ such that $V(x)=c$, $\\nabla V(x)^{\\top} f(x)\\le -\\sigma$ for some constant $\\sigma>0$.\n6.  Local bounds: There exists $\\delta>0$ such that for all $x$ satisfying $|V(x)-c|\\le \\delta$, the following bounds hold: $\\|f(x)\\|\\le F$ and $\\|\\nabla^2 V(x)\\|\\le H$, for constants $F>0$ and $H>0$. The norm $\\|\\cdot\\|$ is the Euclidean norm for vectors and the induced operator norm (spectral norm) for matrices.\n7.  One-step Euler mismatch definition: $\\Delta_h V(x)\\coloneqq V\\big(x+h f(x)\\big)-V(x)-h\\,\\nabla V(x)^{\\top} f(x)$.\n\nThe problem is scientifically grounded in the fields of control theory and numerical analysis, specifically concerning the stability and safety of discretized systems. It is well-posed, objective, and contains sufficient information to derive a solution. The assumptions are standard in the analysis of hybrid and cyber-physical systems. Therefore, the problem is deemed valid.\n\nThe goal is to find the largest step size $h_{\\max}$ such that the forward invariance of $S$ is preserved under the Euler discretization. That is, if $x_k \\in S$, we must ensure $x_{k+1} \\in S$. In terms of the storage function $V$, this means that if $V(x_k) \\le c$, we must have $V(x_k + h f(x_k)) \\le c$.\n\nThe most challenging case for maintaining invariance occurs at the boundary of the set $S$. If a state can leave the set, it must first cross the boundary. Thus, we analyze the condition for states $x$ where $V(x) = c$. For such states, the invariance condition becomes $V(x+h f(x)) \\le c = V(x)$, which is equivalent to requiring $V(x+h f(x)) - V(x) \\le 0$.\n\nLet's analyze the change $V(x+h f(x)) - V(x)$. From the definition of the mismatch term $\\Delta_h V(x)$, we can write:\n$$\nV(x+h f(x)) - V(x) = h\\,\\nabla V(x)^{\\top} f(x) + \\Delta_h V(x)\n$$\nWe need to find an upper bound for this expression. The first term is bounded by the strict boundary margin condition. For any $x$ such that $V(x)=c$:\n$$\nh\\,\\nabla V(x)^{\\top} f(x) \\le -h\\sigma\n$$\nNext, we derive an upper bound for the mismatch term $\\Delta_h V(x)$. This term represents the remainder of a first-order Taylor expansion of $V$. By Taylor's theorem with Lagrange remainder, for a vector displacement $d$, there exists a point $z$ on the line segment between $x$ and $x+d$ such that:\n$$\nV(x+d) = V(x) + \\nabla V(x)^{\\top}d + \\frac{1}{2}d^{\\top}\\nabla^2 V(z) d\n$$\nLet the displacement be $d = h f(x)$. Then $z = x + \\xi h f(x)$ for some $\\xi \\in (0,1)$. Rearranging the Taylor expansion gives:\n$$\nV(x+h f(x)) - V(x) - \\nabla V(x)^{\\top}(h f(x)) = \\frac{1}{2}(h f(x))^{\\top}\\nabla^2 V(z) (h f(x))\n$$\nThe left-hand side is $\\Delta_h V(x)$. Thus,\n$$\n\\Delta_h V(x) = \\frac{1}{2}h^2 f(x)^{\\top}\\nabla^2 V(z) f(x)\n$$\nTo find an upper bound for $\\Delta_h V(x)$, we use the properties of quadratic forms and the given bounds. The value of a quadratic form $u^{\\top}Au$ is bounded by $\\|A\\|\\|u\\|^2$, where $\\|A\\|$ is the induced operator norm.\n$$\n\\Delta_h V(x) \\le \\frac{1}{2}h^2 \\left| f(x)^{\\top}\\nabla^2 V(z) f(x) \\right| \\le \\frac{1}{2}h^2 \\|\\nabla^2 V(z)\\| \\|f(x)\\|^2\n$$\nThe problem states that for any point $y$ in the region $|V(y)-c| \\le \\delta$, we have $\\|\\nabla^2 V(y)\\| \\le H$ and $\\|f(y)\\| \\le F$. We assume the step size $h$ is small enough such that the point $z$ remains in this region where the bounds are valid. Applying these bounds:\n$$\n\\Delta_h V(x) \\le \\frac{1}{2}h^2 H F^2\n$$\nThis provides a uniform upper bound on the mismatch term for all $x$ in the vicinity of the boundary.\n\nNow, we combine the bounds for both terms to ensure invariance. For any $x$ with $V(x)=c$, we have:\n$$\nV(x+h f(x)) - V(x) = h\\,\\nabla V(x)^{\\top} f(x) + \\Delta_h V(x) \\le -h\\sigma + \\frac{1}{2}h^2 H F^2\n$$\nTo guarantee invariance ($V(x+h f(x)) - V(x) \\le 0$), it is sufficient that this upper bound is non-positive:\n$$\n-h\\sigma + \\frac{1}{2}h^2 H F^2 \\le 0\n$$\nGiven that $h>0$, we can divide the inequality by $h$:\n$$\n-\\sigma + \\frac{1}{2}h H F^2 \\le 0\n$$\nSolving for $h$:\n$$\n\\frac{1}{2}h H F^2 \\le \\sigma\n$$\n$$\nh \\le \\frac{2\\sigma}{H F^2}\n$$\nThis inequality provides the condition on the step size $h$ that guarantees the forward invariance of the set $S$ for the Euler-discretized system. The largest possible value of $h$ that satisfies this condition for any valid choice of system parameters is the maximum allowed step size, $h_{\\max}$.\n\nTherefore, the largest step size is:\n$$\nh_{\\max} = \\frac{2\\sigma}{H F^2}\n$$",
            "answer": "$$\\boxed{\\frac{2\\sigma}{H F^2}}$$"
        },
        {
            "introduction": "Beyond deterministic guarantees, formal verification can provide quantitative assurances about the reliability of systems that operate under uncertainty. This exercise delves into the world of probabilistic model checking by tasking you with analyzing a system with redundant components subject to random failures . You will model the system as a Continuous-Time Markov Chain (CTMC) and implement the core algorithm—solving the Kolmogorov forward equation—to compute the precise probability of system failure within a given mission time, replicating the logic at the heart of tools like PRISM.",
            "id": "4223185",
            "problem": "You are tasked with replicating the quantitative semantics of a reachability query used in the Probabilistic Symbolic Model Checker (PRISM) for a reliability property of a Cyber-Physical System (CPS). A CPS digital twin is modeled as a Continuous-Time Markov Chain (CTMC), with states representing the number of functioning identical and independent redundant components and an absorbing failure state. The property to be checked is the probability that the system reaches the absorbing failure state within a bounded mission time, expressed in Continuous Stochastic Logic (CSL) as $P=?\\,[F_{\\leq T}\\,\\text{failure}]$, where $T$ is the mission time.\n\nModel specification:\n- Consider $n$ identical, independent components operating in parallel without repair. The CTMC has states $\\{0,1,2,\\dots,n\\}$, where state $k$ represents $k$ functioning components, and state $0$ is absorbing (failure).\n- Each functioning component fails with a constant rate $\\lambda$ (in $\\text{s}^{-1}$). Transitions occur only from state $k$ to state $k-1$ with rate $k\\lambda$ for $k \\in \\{1,\\dots,n\\}$.\n- The initial state is $n$ (all components functioning).\n\nFundamental basis and target computation:\n- Use the Kolmogorov forward equation for CTMC transient probabilities, $\\frac{d}{dt}\\,\\mathbf{p}(t) = \\mathbf{p}(t)\\,\\mathbf{Q}$, where $\\mathbf{Q}$ is the infinitesimal generator matrix of the CTMC, and $\\mathbf{p}(t)$ is the row vector of state probabilities at time $t$.\n- The probability of failure within mission time $T$ equals the probability mass in state $0$ at time $T$, given the failure state is absorbing. Compute $\\mathbf{p}(T)$ by solving the forward equation and report $\\mathbf{p}(T)[0]$.\n\nUnit requirements:\n- Express the mission time $T$ in seconds, i.e., $T$ is provided and used in $\\text{s}$.\n- Failure rate $\\lambda$ is given in $\\text{s}^{-1}$.\n- Probabilities are dimensionless; report them as decimal values in $[0,1]$.\n\nTest suite:\n- Implement a single program that computes the probability of failure within mission time for the following parameter sets. Each test case is a tuple $(n,\\lambda,T)$.\n    - Case A (happy path): ($n=2$, $\\lambda=1\\times 10^{-5}\\text{ s}^{-1}$, $T=3600\\text{ s}$)\n    - Case B (high-hazard edge): ($n=3$, $\\lambda=5\\times 10^{-4}\\text{ s}^{-1}$, $T=7200\\text{ s}$)\n    - Case C (boundary condition): ($n=5$, $\\lambda=1\\times 10^{-3}\\text{ s}^{-1}$, $T=0\\text{ s}$)\n    - Case D (extremely reliable, long mission): ($n=4$, $\\lambda=1\\times 10^{-7}\\text{ s}^{-1}$, $T=100000\\text{ s}$)\n\nAlgorithmic requirements:\n- Construct the infinitesimal generator matrix $\\mathbf{Q} \\in \\mathbb{R}^{(n+1)\\times(n+1)}$ with entries $\\mathbf{Q}[k,k-1] = k\\lambda$ for $k \\geq 1$, $\\mathbf{Q}[k,k] = -k\\lambda$ for $k \\geq 1$, and $\\mathbf{Q}[0,0] = 0$, with all other entries $0$.\n- Use the initial distribution $\\mathbf{p}(0)$ with $\\mathbf{p}(0)[n] = 1$ and $\\mathbf{p}(0)[k] = 0$ for $k \\neq n$.\n- Compute $\\mathbf{p}(T)$ and return the failure probability $\\mathbf{p}(T)[0]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above. For example, print $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$, where each entry is the computed decimal probability in $[0,1]$.",
            "solution": "The problem is valid as it presents a scientifically sound, well-posed, and self-contained task in the domain of reliability analysis for Cyber-Physical Systems using Continuous-Time Markov Chains (CTMCs). The problem is to compute the probability of system failure within a specified mission time $T$.\n\nThe system's state is defined by the number of functioning components, $k$, from an initial set of $n$ identical and independent components. The states are thus $\\{n, n-1, \\dots, 1, 0\\}$. State $k$ represents $k$ working components, and state $0$ is the absorbing failure state. Since each of the $k$ components in state $k$ fails independently with a constant rate $\\lambda$, the total rate of transition from state $k$ to state $k-1$ is the sum of the individual failure rates, which is $k\\lambda$. This describes a pure death process.\n\nThe evolution of the probability distribution over the states is governed by the Kolmogorov forward equation, a system of linear first-order ordinary differential equations. For a row vector of state probabilities $\\mathbf{p}(t) = [p_0(t), p_1(t), \\dots, p_n(t)]$, the equation is:\n$$\n\\frac{d}{dt}\\mathbf{p}(t) = \\mathbf{p}(t)\\mathbf{Q}\n$$\nwhere $\\mathbf{Q}$ is the infinitesimal generator matrix. The element $\\mathbf{Q}_{ij}$ (for $i \\neq j$) represents the transition rate from state $i$ to state $j$.\n\nThe states are indexed from $0$ to $n$. The generator matrix $\\mathbf{Q}$ is an $(n+1) \\times (n+1)$ matrix whose elements are defined by the transition rates:\n- A transition from state $k$ to state $k-1$ occurs with rate $k\\lambda$ for $k \\in \\{1, 2, \\dots, n\\}$. This corresponds to the entries $\\mathbf{Q}_{k, k-1} = k\\lambda$.\n- State $0$ is an absorbing state, meaning no transitions occur out of it. Thus, row $0$ of $\\mathbf{Q}$ contains all zeros: $\\mathbf{Q}_{0,j} = 0$ for all $j \\in \\{0, \\dots, n\\}$.\n- The diagonal elements of $\\mathbf{Q}$ are defined such that the sum of each row is zero. Therefore, $\\mathbf{Q}_{k,k} = -\\sum_{j\\neq k} \\mathbf{Q}_{k,j}$. For $k \\in \\{1, \\dots, n\\}$, the only exit transition is to state $k-1$, so $\\mathbf{Q}_{k,k} = -k\\lambda$. For $k=0$, $\\mathbf{Q}_{0,0} = 0$.\n- All other off-diagonal entries are zero as no other transitions are possible.\n\nThe general structure of the $\\mathbf{Q}$ matrix is:\n$$\n\\mathbf{Q} =\n\\begin{pmatrix}\n0  0  0  \\cdots  0  0 \\\\\n\\lambda  -\\lambda  0  \\cdots  0  0 \\\\\n0  2\\lambda  -2\\lambda  \\cdots  0  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  0  \\cdots  n\\lambda  -n\\lambda\n\\end{pmatrix}\n$$\nNote that the states are indexed $\\{0, 1, \\dots, n\\}$ but their functional meaning is reversed: state $n$ is the initial fully-functional state, and state $0$ is the final failure state. The matrix rows and columns are indexed from $0$ to $n$ to correspond to these states. The problem statement refers to state $k$ having $k$ components and a transition to $k-1$, which can lead to index confusion. Mapping state \"number of components\" $k$ to matrix index $k$ results in the matrix above, which is a lower triangular matrix.\n\nThe system starts with all $n$ components functioning. This defines the initial probability distribution $\\mathbf{p}(0)$ as a row vector with a $1$ at the position corresponding to state $n$ and $0$s elsewhere:\n$$\n\\mathbf{p}(0) = [0, 0, \\dots, 0, 1]\n$$\nwhere the $1$ is at index $n$.\n\nThe solution to the Kolmogorov forward equation with the initial condition $\\mathbf{p}(0)$ is given by the matrix exponential:\n$$\n\\mathbf{p}(t) = \\mathbf{p}(0)e^{\\mathbf{Q}t}\n$$\nWe are interested in the probability of being in the failure state (state $0$) at the mission time $T$. This is the element $p_0(T)$ of the vector $\\mathbf{p}(T)$.\n\nTo compute $\\mathbf{p}(T)$, we first calculate the matrix exponential $e^{\\mathbf{Q}T}$. Let $\\mathbf{P}(T) = e^{\\mathbf{Q}T}$. The transient probability vector is then $\\mathbf{p}(T) = \\mathbf{p}(0)\\mathbf{P}(T)$. Since $\\mathbf{p}(0)$ is zero everywhere except for a $1$ at index $n$, the vector $\\mathbf{p}(T)$ is simply the last row (row $n$) of the matrix $\\mathbf{P}(T)$.\n$$\n\\mathbf{p}(T) = [ \\mathbf{P}(T)_{n,0}, \\mathbf{P}(T)_{n,1}, \\dots, \\mathbf{P}(T)_{n,n} ]\n$$\nThe required failure probability, $P(F_{\\leq T}\\,\\text{failure}) = p_0(T)$, is the first element of this vector, which corresponds to the element at row $n$, column $0$ of the matrix $e^{\\mathbf{Q}T}$:\n$$\np_0(T) = \\left(e^{\\mathbf{Q}T}\\right)_{n,0}\n$$\nThis value will be computed for each test case by constructing the appropriate $\\mathbf{Q}$ matrix, calculating the matrix exponential using a numerical library function (`scipy.linalg.expm`), and extracting the specified element.\nFor the boundary case where $T=0\\,\\text{s}$, we have $\\mathbf{p}(0) = \\mathbf{p}(0)e^{\\mathbf{Q} \\cdot 0} = \\mathbf{p}(0)e^{\\mathbf{0}} = \\mathbf{p}(0)\\mathbf{I} = \\mathbf{p}(0)$. Since $\\mathbf{p}(0) = [0, \\dots, 0, 1]$, the probability of being in state $0$ is $p_0(0)=0$, as expected.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the probability of system failure for a CTMC model of a redundant component system.\n    The problem is solved for a suite of test cases.\n    \"\"\"\n\n    # Test suite: Each case is a tuple (n, lambda, T)\n    # n: number of initial components\n    # lambda: failure rate of a single component (in s^-1)\n    # T: mission time (in s)\n    test_cases = [\n        # Case A (happy path)\n        (2, 1e-5, 3600),\n        # Case B (high-hazard edge)\n        (3, 5e-4, 7200),\n        # Case C (boundary condition)\n        (5, 1e-3, 0),\n        # Case D (extremely reliable, long mission)\n        (4, 1e-7, 100000),\n    ]\n\n    results = []\n    for n, lam, T in test_cases:\n        # The CTMC has n+1 states, from 0 (failure) to n (all components working).\n        # We index the states directly, so the matrix size is (n+1)x(n+1).\n        dim = n + 1\n        \n        # Construct the infinitesimal generator matrix Q.\n        # Q[i, j] is the transition rate from state i to state j.\n        Q = np.zeros((dim, dim))\n        \n        for k in range(1, dim):\n            # For state k (k components working), a transition to k-1 occurs\n            # if any of the k components fail.\n            # Transition rate from state k to state k-1 is k*lambda.\n            Q[k, k - 1] = k * lam\n            \n            # The diagonal element Q[k, k] is the negative sum of rates out of state k.\n            Q[k, k] = -k * lam\n            \n        # State 0 is absorbing, so the first row of Q is all zeros, which is\n        # the default from np.zeros.\n\n        # The solution to the Kolmogorov forward equation p'(t) = p(t)Q is\n        # p(t) = p(0) * expm(Q*t), where expm is the matrix exponential.\n        \n        # If T=0, expm(Q*T) is the identity matrix. The probability of failure is 0.\n        # We can handle this as a special case to avoid floating point inaccuracies,\n        # although the numerical computation will also yield a result very close to 0.\n        if T == 0:\n            failure_prob = 0.0\n        else:\n            # Compute the matrix P(T) = expm(Q*T).\n            # The scipy.linalg.expm function is a reliable way to compute this.\n            P_T = expm(Q * T)\n            \n            # The initial state is n (all components working).\n            # The initial probability vector p(0) is [0, 0, ..., 1].\n            # Therefore, the probability vector at time T, p(T), is the n-th row\n            # of the matrix P(T).\n            \n            # The probability of failure is the probability of being in state 0.\n            # This is the 0-th element of the n-th row of P(T).\n            failure_prob = P_T[n, 0]\n            \n        results.append(failure_prob)\n\n    # Format the final output as a comma-separated list in brackets.\n    # Convert each float result to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}