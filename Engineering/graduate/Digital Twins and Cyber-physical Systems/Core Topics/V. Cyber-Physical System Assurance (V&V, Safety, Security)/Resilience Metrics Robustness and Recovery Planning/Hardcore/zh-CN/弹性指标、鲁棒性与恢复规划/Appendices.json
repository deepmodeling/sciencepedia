{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个练习将介绍最基础的韧性度量：随时间累积的性能总损失。通过计算不同干扰情景下性能缺口曲线下方的面积，我们可以具体理解事件的严重程度、持续时间以及恢复速度如何共同影响系统的总体冲击，为后续比较不同事件的严重性奠定了基础。",
            "id": "4240984",
            "problem": "一个信息物理系统（CPS）的数字孪生（DT）持续估计一个归一化的服务水平轨迹 $Q(t)$，其中 $Q(t) \\in [0,1]$，标称基线为 $Q_{\\text{base}}=1$。考虑一个在 $t=0$ 时刻开始的单一干扰事件，此后系统的轨迹是分段的，包括一个恒定损失阶段和一个随后的线性恢复阶段。韧性损失 $A$ 定义为从事件发生到恢复完成的整个事件窗口内，性能亏损（相对于基线）的时间积分，即从事件开始直到 $Q(t)$ 返回到 $1$ 时，$1 - Q(t)$ 曲线下方的面积。\n\n场景1描述为：在 $t=0$ 时，$Q(t)$ 瞬时下降至 $0.4$，在该水平上保持 $3$ 分钟，然后在接下来的 $5$ 分钟内线性恢复至 $Q(t)=1$。场景2描述为：在 $t=0$ 时，$Q(t)$ 瞬时下降至 $0.6$，在该水平上保持 $4$ 分钟，然后在接下来的 $3$ 分钟内线性恢复至 $Q(t)=1$。\n\n使用上述韧性损失的基本定义，分别计算场景1和场景2的韧性损失 $A_1$ 和 $A_2$，并以精确比值 $r = A_1 / A_2$ 的形式报告比较结果。您的最终答案必须是一个无单位、不进行四舍五入的精确数值。",
            "solution": "问题陈述经评估有效。它在科学上基于信息物理系统韧性工程的既定原则，提法恰当，定义和数据清晰完整，并且表述客观。它提出了一个可解的数学问题，没有任何逻辑矛盾、物理上的不可能性或歧义。\n\n韧性损失 $A$ 定义为从事件发生（$t=0$）到系统完全恢复至其基线性能水平 $Q_{\\text{base}}=1$ 的整个事件持续时间内，性能亏损 $1 - Q(t)$ 的时间积分。在数学上，这表示为：\n$$A = \\int_{0}^{t_{\\text{recover}}} (1 - Q(t)) \\,dt$$\n其中 $t_{\\text{recover}}$ 是 $Q(t)$ 返回到 $1$ 的时间。\n\n对于所描述的分段轨迹，它由一个恒定损失阶段和一个随后的线性恢复阶段组成，该积分可以进行几何解释。代表损失的面积由两部分组成：一个对应于恒定损失阶段的矩形和一个对应于线性恢复阶段的直角三角形。\n\n设 $Q_{\\text{min}}$ 为恒定损失阶段的服务水平，$t_d$ 为该阶段的持续时间，$t_r$ 为线性恢复阶段的持续时间。\n恒定损失阶段的性能亏损恒定为 $1 - Q_{\\text{min}}$。损失的矩形部分面积 $A_{\\text{rect}}$ 是该亏损与持续时间 $t_d$ 的乘积：\n$$A_{\\text{rect}} = (1 - Q_{\\text{min}}) \\times t_d$$\n在线性恢复阶段，性能亏损在 $t_r$ 的持续时间内从 $1 - Q_{\\text{min}}$ 线性减小到 $0$。这形成一个直角三角形。损失的这部分三角形面积 $A_{\\text{tri}}$ 是：\n$$A_{\\text{tri}} = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times t_r \\times (1 - Q_{\\text{min}})$$\n总韧性损失 $A$ 是这两个面积之和：\n$$A = A_{\\text{rect}} + A_{\\text{tri}} = (1 - Q_{\\text{min}})t_d + \\frac{1}{2}(1 - Q_{\\text{min}})t_r = (1 - Q_{\\text{min}})\\left(t_d + \\frac{t_r}{2}\\right)$$\n\n我们将此公式应用于每个场景。时间单位一致为分钟，因此它们将在最终的比值中被消去，我们可以直接使用给定的数值进行计算。\n\n对于场景1：\n系统下降至服务水平 $Q_{\\text{min},1} = 0.4$。\n恒定损失阶段的持续时间为 $t_{d,1} = 3$ 分钟。\n线性恢复阶段的持续时间为 $t_{r,1} = 5$ 分钟。\n性能亏损为 $1 - Q_{\\text{min},1} = 1 - 0.4 = 0.6$。\n\n场景1的韧性损失 $A_1$ 计算如下：\n$$A_1 = (1 - 0.4) \\left( 3 + \\frac{5}{2} \\right)$$\n$$A_1 = 0.6 \\left( 3 + 2.5 \\right)$$\n$$A_1 = 0.6 \\times 5.5 = \\frac{6}{10} \\times \\frac{55}{10} = \\frac{3}{5} \\times \\frac{11}{2} = \\frac{33}{10} = 3.3$$\n\n对于场景2：\n系统下降至服务水平 $Q_{\\text{min},2} = 0.6$。\n恒定损失阶段的持续时间为 $t_{d,2} = 4$ 分钟。\n线性恢复阶段的持续时间为 $t_{r,2} = 3$ 分钟。\n性能亏损为 $1 - Q_{\\text{min},2} = 1 - 0.6 = 0.4$。\n\n场景2的韧性损失 $A_2$ 计算如下：\n$$A_2 = (1 - 0.6) \\left( 4 + \\frac{3}{2} \\right)$$\n$$A_2 = 0.4 \\left( 4 + 1.5 \\right)$$\n$$A_2 = 0.4 \\times 5.5 = \\frac{4}{10} \\times \\frac{55}{10} = \\frac{2}{5} \\times \\frac{11}{2} = \\frac{11}{5} = \\frac{22}{10} = 2.2$$\n\n最后，我们计算比值 $r = A_1 / A_2$。\n$$r = \\frac{A_1}{A_2} = \\frac{3.3}{2.2}$$\n为了将其表示为精确分数，我们可以写成：\n$$r = \\frac{33/10}{22/10} = \\frac{33}{22}$$\n将分子和分母除以它们的最大公约数 $11$ 来化简该分数：\n$$r = \\frac{33 \\div 11}{22 \\div 11} = \\frac{3}{2}$$",
            "answer": "$$\\boxed{\\frac{3}{2}}$$"
        },
        {
            "introduction": "韧性不仅关乎系统性能随时间的变化，也体现在其内在结构的鲁棒性。本练习将超越时间序列分析，探索一个源于图论的强大度量——代数连通度，它能够量化网络在遭受破坏时的韧性。通过在一个通信网络中模拟节点移除，您将学习如何衡量这种结构性破坏对系统完整性的影响。",
            "id": "4240958",
            "problem": "一个信息物理系统（CPS）的数字孪生使用代数连通度作为其通信网络的弹性指标。考虑一个具有 $n=10$ 个节点（索引为 $0,1,\\dots,9$）的无向加权环形网络，其连通性由一个对称邻接矩阵 $A \\in \\mathbb{R}^{10 \\times 10}$ 表示。每条边 $(i,(i+1) \\bmod 10)$ 具有一个非负权重 $w_i$，并且不存在其他边。设度矩阵 $D$ 由 $D_{ii} = \\sum_{j=0}^{9} A_{ij}$ 定义，组合图拉普拉斯算子为 $L = D - A$。代数连通度是 $L$ 的第二小特征值 $\\lambda_2$，也称为 Fiedler 值。从网络中移除节点 $k$ 会得到一个新的邻接矩阵 $A'$，该矩阵通过从 $A$ 中删除第 $k$ 行和第 $k$ 列形成，以及在剩余的 $n-1$ 个节点上的相应拉普拉斯算子 $L' = D' - A'$。\n\n基本定义：\n- 对于具有对称邻接矩阵 $A$ 的加权无向图，度矩阵 $D$ 满足 $D_{ii} = \\sum_{j} A_{ij}$，组合拉普拉斯算子为 $L = D - A$。\n- 对于对称的 $L$，其特征值为实数，可以排序为 $0 = \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_n$。代数连通度 $\\lambda_2$ 量化了图在由 $\\dot{x} = -L x$ 控制的扩散或一致性动力学意义上的连接紧密程度。\n- 移除节点 $k$ 对应于删除 $A$ 中相关的行和列，并重新计算 $L'$ 及其谱。\n\n定义弹性指标为代数连通度的变化及其归一化残差：\n- $\\Delta = \\lambda_2^{\\text{post}} - \\lambda_2^{\\text{pre}}$，\n- $r = \\lambda_2^{\\text{post}} / \\lambda_2^{\\text{pre}}$，\n其中 $\\lambda_2^{\\text{pre}}$ 是在移除节点前计算的，而 $\\lambda_2^{\\text{post}}$ 是在移除节点 $k$ 后计算的。将 $r$ 解释为保留的连通度分数；较低的 $r$ 表示较低的弹性。\n\n待实现的任务：\n1. 对于每个测试用例，根据指定的边 $(i,(i+1) \\bmod 10)$ 的权重 $w_i$ 构建 $A$，其中 $A_{i,(i+1) \\bmod 10} = A_{(i+1) \\bmod 10,i} = w_i$，所有其他项为零。计算 $L = D - A$ 和 $\\lambda_2^{\\text{pre}}$。\n2. 移除节点 $k$ 以获得 $A'$（通过删除第 $k$ 行和第 $k$ 列），计算 $L' = D' - A'$ 和 $\\lambda_2^{\\text{post}}$。\n3. 计算如上定义的 $\\Delta$ 和 $r$。\n\n带参数值的测试套件：\n- 情况 1 (理想情况): $n=10$，对于所有 $i \\in \\{0,\\dots,9\\}$，$w_i=1$，移除节点 $k=0$。\n- 情况 2 (不对称性和局部弱点): $n=10$，$w_0=0.2$ 且对于 $i \\in \\{1,\\dots,9\\}$，$w_i=1$，移除节点 $k=0$。\n- 情况 3 (近临界弱连接): $n=10$，$w_4=0.001$ 且对于 $i \\in \\{0,1,2,3,5,6,7,8,9\\}$，$w_i=1$，移除节点 $k=7$。\n\n答案规范：\n- 对于每种情况，输出列表 $[\\lambda_2^{\\text{pre}}, \\lambda_2^{\\text{post}}, \\Delta, r]$，其中每个浮点数四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含结果，格式为这些按情况分类的列表的逗号分隔列表，并用方括号括起来，例如 $[[a,b,c,d],[e,f,g,h],[p,q,r,s]]$。\n- 不涉及物理单位；所有输出都是纯无量纲浮点数。不要使用百分号；将 $r$ 表示为小数。\n- 您的程序必须是自包含的，且不要求任何用户输入。它必须完全按照上述描述实现计算，并以指定的单行格式生成最终的聚合结果。",
            "solution": "我们从核心的图论和动力系统定义中推导出计算和指标。对于一个具有对称邻接矩阵 $A$ 的无向加权图，节点 $i$ 的度为 $d_i = \\sum_{j=0}^{n-1} A_{ij}$，度矩阵为 $D = \\mathrm{diag}(d_0,\\dots,d_{n-1})$。组合拉普拉斯算子为 $L = D - A$。这个 $L$ 是对称且半正定的，这意味着其谱为实数 $0 = \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_n$，其中 $\\lambda_1 = 0$ 对应于全一向量的特征向量。代数连通度 $\\lambda_2$ 是第二小特征值，是衡量连通性的一个基本度量：它可以通过在与全一向量正交的约束下最小化瑞利商来表征，即\n$$\n\\lambda_2 = \\min_{\\substack{x \\in \\mathbb{R}^n \\\\ x \\perp \\mathbf{1},\\, x \\ne 0}} \\frac{x^\\top L x}{x^\\top x}.\n$$\n这种表征将 $\\lambda_2$ 与图在扩散或一致性动力学 $\\dot{x}(t) = -L x(t)$ 方面的“最紧瓶颈”联系起来，因为较大的 $\\lambda_2$ 意味着更快地收敛到一致状态，以及对链路或节点扰动有更强的鲁棒性。\n\n环形网络由边 $(i,(i+1) \\bmod n)$ 定义，其中 $i \\in \\{0,\\dots,n-1\\}$，权重为 $w_i \\ge 0$。邻接矩阵的项满足 $A_{i,(i+1) \\bmod n} = A_{(i+1) \\bmod n,i} = w_i$，所有其他项为零。从 $A$ 计算出 $D$，然后计算 $L = D - A$。通过计算 $L$ 的特征值并按升序排列，可以得到第二小特征值 $\\lambda_2$。\n\n移除节点是一种结构性变化：移除节点 $k$ 会从 $A$ 中删除第 $k$ 行和第 $k$ 列，生成 $A' \\in \\mathbb{R}^{(n-1)\\times(n-1)}$。然后我们计算 $D'$ 和 $L' = D' - A'$，并以类似方式获得 $\\lambda_2^{\\text{post}}$。在环形网络中，移除单个节点会打破循环，在剩余的 $n-1$ 个节点上形成一条路径，只要所有剩余边的权重非零，该路径仍保持连通。因此，$\\lambda_2^{\\text{post}}$ 将严格为正，但通常小于 $\\lambda_2^{\\text{pre}}$，反映了连通性的降低。\n\n弹性指标定义为绝对变化 $\\Delta = \\lambda_2^{\\text{post}} - \\lambda_2^{\\text{pre}}$ 和归一化残差 $r = \\lambda_2^{\\text{post}}/\\lambda_2^{\\text{pre}}$。其解释如下：\n- 如果 $\\Delta  0$ 且 $0  r  1$，则连通性已退化。较小的 $r$ 表示保留的连通性较少，意味着对节点移除的弹性较低。\n- 如果 $r$ 接近 1，则网络对该移除更具鲁棒性。\n\n程序中实现的算法步骤：\n1. 对于每个测试用例，通过设置 $A_{i,(i+1)\\bmod n} = A_{(i+1)\\bmod n,i} = w_i$ 且其他项为零来构建邻接矩阵 $A$。\n2. 通过 $d_i = \\sum_j A_{ij}$ 计算度矩阵 $D$ 并构成 $L = D - A$。\n3. 使用对称特征值例程计算 $L$ 的特征值，并提取第二小特征值作为 $\\lambda_2^{\\text{pre}}$。\n4. 通过从 $A$ 中删除行 $k$ 和列 $k$ 来移除节点 $k$ 以得到 $A'$，计算 $D'$ 和 $L'$，并提取 $\\lambda_2^{\\text{post}}$。\n5. 计算 $\\Delta$ 和 $r$，并将每个值四舍五入到六位小数以供报告。\n6. 将每个用例的结果聚合到单个列表的列表中，并以要求的单行格式打印。\n\n测试套件的覆盖理由：\n- 情况 1 是对称的“理想情况”，其中所有 $w_i=1$，移除节点 $k=0$ 会产生一个均匀路径，说明了当环变为路径时连通度的典型下降。\n- 情况 2 引入了局部弱点 ($w_0=0.2$) 并移除了节点 $k=0$，从而消除了弱边并产生一个均匀路径；这测试了移除前的不对称性如何影响 $\\lambda_2^{\\text{pre}}$ 和保留分数 $r$。\n- 情况 3 设置了一个近临界的弱连接 ($w_4=0.001$) 并移除了节点 $k=7$，导致产生的路径保留了该弱连接。这个边界情况展示了代数连通度的显著下降以及弹性指标对极端局部退化的敏感性。\n\n输出是四舍五入到六位小数的无量纲浮点数，并按规定进行聚合。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_ring_adjacency(n: int, weights: np.ndarray) - np.ndarray:\n    \"\"\"\n    Build the adjacency matrix for a weighted undirected ring.\n    Nodes are 0..n-1. Edge (i, (i+1)%n) has weight weights[i].\n    \"\"\"\n    A = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        j = (i + 1) % n\n        w = weights[i]\n        # Symmetric adjacency for undirected graph\n        A[i, j] = w\n        A[j, i] = w\n    return A\n\ndef laplacian_from_adjacency(A: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the combinatorial Laplacian L = D - A,\n    where D is the diagonal degree matrix with D_ii = sum_j A_ij.\n    \"\"\"\n    degrees = np.sum(A, axis=1)\n    D = np.diag(degrees)\n    L = D - A\n    return L\n\ndef algebraic_connectivity(L: np.ndarray) - float:\n    \"\"\"\n    Compute the second-smallest eigenvalue (algebraic connectivity) of symmetric Laplacian L.\n    \"\"\"\n    # Use eigvalsh for symmetric/hermitian matrices to get sorted eigenvalues\n    evals = np.linalg.eigvalsh(L)\n    # Numerical guard: ensure ordering and non-negativity within tolerance\n    evals_sorted = np.sort(evals)\n    # Second-smallest eigenvalue\n    lam2 = float(evals_sorted[1])\n    # Clip tiny negatives due to round-off\n    if lam2  0 and lam2  -1e-12:\n        lam2 = 0.0\n    return lam2\n\ndef remove_node_adjacency(A: np.ndarray, k: int) - np.ndarray:\n    \"\"\"\n    Remove node k from adjacency matrix A by deleting row k and column k.\n    \"\"\"\n    mask = np.ones(A.shape[0], dtype=bool)\n    mask[k] = False\n    A_reduced = A[np.ix_(mask, mask)]\n    return A_reduced\n\ndef compute_metrics(n: int, weights_list, remove_idx: int):\n    \"\"\"\n    For a given ring configuration and node removal index, compute:\n    lambda2_pre, lambda2_post, delta, ratio\n    \"\"\"\n    weights = np.array(weights_list, dtype=float)\n    A = build_ring_adjacency(n, weights)\n    L = laplacian_from_adjacency(A)\n    lam2_pre = algebraic_connectivity(L)\n\n    A_post = remove_node_adjacency(A, remove_idx)\n    L_post = laplacian_from_adjacency(A_post)\n    lam2_post = algebraic_connectivity(L_post)\n\n    delta = lam2_post - lam2_pre\n    ratio = lam2_post / lam2_pre if lam2_pre  0 else float('nan')\n    return lam2_pre, lam2_post, delta, ratio\n\ndef format_result_tuple(tup):\n    \"\"\"\n    Format a 4-tuple of floats to six decimal places inside a list representation.\n    \"\"\"\n    return \"[\" + \",\".join(f\"{x:.6f}\" for x in tup) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: n=10, all weights 1, remove node 0\n    n1 = 10\n    weights1 = [1.0] * n1\n    remove_idx1 = 0\n\n    # Case 2: n=10, w0=0.2, others 1.0, remove node 0\n    n2 = 10\n    weights2 = [1.0] * n2\n    weights2[0] = 0.2\n    remove_idx2 = 0\n\n    # Case 3: n=10, w4=0.001, others 1.0, remove node 7\n    n3 = 10\n    weights3 = [1.0] * n3\n    weights3[4] = 0.001\n    remove_idx3 = 7\n\n    test_cases = [\n        (n1, weights1, remove_idx1),\n        (n2, weights2, remove_idx2),\n        (n3, weights3, remove_idx3),\n    ]\n\n    results = []\n    for n, weights, remove_idx in test_cases:\n        lam2_pre, lam2_post, delta, ratio = compute_metrics(n, weights, remove_idx)\n        results.append((lam2_pre, lam2_post, delta, ratio))\n\n    # Final print statement in the exact required format: list of per-case lists.\n    formatted = \"[\" + \",\".join(format_result_tuple(r) for r in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的恢复工作充满了不确定性，例如修复时间的可变性。最后一个练习将挑战您从单纯的韧性测量转向主动的韧性规划。您将比较一个为单一“最佳猜测”情景优化的确定性调度，与一个旨在在最坏情况下也能表现良好的鲁棒调度，从而学习到韧性系统设计的一个关键原则。",
            "id": "4240927",
            "problem": "您面临一个针对信息物理系统（CPS）的单一维修团队恢复规划问题，该系统使用数字孪生来模拟不确定性下的调度方案。弹性指标定义为可用性（A），即可用性（A）是在一个固定时域内部件可运行时间的比例。确定性调度假设维修时长为标称值，而鲁棒调度则在一系列不确定性场景中最大化最坏情况下的可用性。您的任务是通过基于场景的优化，计算并比较确定性调度与鲁棒调度的最坏情况可用性。\n\n基本基础与建模假设：\n- 有一个单一的维修团队处理一组有限的任务（部件维修）。每个任务对应一个在已知故障时间发生的部件故障，一旦团队开始处理该任务，它就会被修复。\n- 时间和时长以小时为单位。固定时域长度用 $H$（小时）表示。所有故障时间和维修时长均以小时表示。\n- 对于每个任务 $i \\in \\{1,\\dots,M\\}$，其故障时间为 $t_i \\in [0,H]$（小时）。\n- 在每个不确定性场景 $s \\in \\{1,\\dots,S\\}$ 下，任务 $i$ 的维修时长为 $d_{i}^{(s)} \\ge 0$（小时）。\n- 维修团队遵循一个由 $\\{1,\\dots,M\\}$ 的排列 $\\pi$ 表示的静态调度；团队按 $(\\pi_1,\\pi_2,\\dots,\\pi_M)$ 的顺序处理任务。\n- 团队不能在任务发生故障前进行修复。如果团队空闲下来，但序列中的下一个任务尚未发生故障，团队将空闲等待直到该任务的故障时间。在调度 $\\pi$ 下，场景 $s$ 中任务 $j$ 的开始时间由 $x_{\\pi_j}^{(s)} = \\max\\left(x_{\\pi_{j-1}}^{(s)} + d_{\\pi_{j-1}}^{(s)},\\ t_{\\pi_j}\\right)$ 给出，其中 $x_{\\pi_1}^{(s)} = \\max(0,\\ t_{\\pi_1})$。完成时间为 $c_{\\pi_j}^{(s)} = x_{\\pi_j}^{(s)} + d_{\\pi_j}^{(s)}$。\n- 对于每个任务 $i$，在场景 $s$ 中的停机时间贡献为 $c_{i}^{(s)} - t_i$（小时），因为部件从故障到维修完成期间是不可用的。\n- 在场景 $s$ 中，所有任务的总停机时间为 $D^{(s)}(\\pi) = \\sum_{i=1}^{M} \\left(c_{i}^{(s)} - t_i\\right)$。\n- 调度 $\\pi$ 在场景 $s$ 中的可用性（A）定义为 $A^{(s)}(\\pi) = 1 - \\dfrac{D^{(s)}(\\pi)}{M \\cdot H}$。这将停机时间通过 $M$ 个部件在时域 $H$ 内的最大可能运行时间进行归一化，确保在维修在时域内完成的情况下 $A^{(s)}(\\pi) \\in [0,1]$。\n\n确定性调度与鲁棒调度：\n- 确定性调度：将指定的标称场景 $s_0$ 视为真实的维修时长。选择 $\\pi_{\\mathrm{det}}$，使其在所有排列中最大化 $A^{(s_0)}(\\pi)$。\n- 鲁棒调度：选择 $\\pi_{\\mathrm{rob}}$，使其在所有场景中最大化最坏情况下的可用性，即 $\\pi_{\\mathrm{rob}} \\in \\arg\\max_{\\pi} \\min_{s \\in \\{1,\\dots,S\\}} A^{(s)}(\\pi)$。\n\n所需计算：\n- 计算确定性调度的最坏情况可用性，$\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$。\n- 计算鲁棒调度的最坏情况可用性，$\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}})$。\n- 计算改进量，定义为 $\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}) - \\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$。\n- 所有可用性值必须表示为小数（无单位分数）。所有时间值单位为小时。\n\n算法要求：\n- 枚举所有排列以找到所提供测试用例的 $\\pi_{\\mathrm{det}}$ 和 $\\pi_{\\mathrm{rob}}$。如果在选择调度时出现平局，则通过最大化所有场景的平均可用性 $\\frac{1}{S}\\sum_{s=1}^{S} A^{(s)}(\\pi)$ 来打破平局；如果仍然存在平局，则选择字典序最小的排列。\n- 假设维修可以延伸到时域 $H$ 之外，但停机时间的定义仍然是 $c_i^{(s)} - t_i$；在病态情况下，可用性可能小于 $0$，但给定的测试套件将在科学上是合理的，并将值保持在合理范围内。\n\n测试套件：\n每个测试用例由 $(M, H, \\{t_i\\}_{i=1}^{M}, \\{d_i^{(s)}\\}_{i=1}^{M} \\text{ for } s=1,\\dots,S, s_0)$ 指定，其中 $s_0$ 是用于确定性调度的标称场景索引。时间单位是小时。可用性必须以小数形式输出。\n\n- 测试用例 1（正常路径）：\n  - $M = 4$, $H = 20$。\n  - 故障时间：$t = [0, 2, 5, 7]$（小时）。\n  - 场景 ($S = 3$)：\n    - $s = 1$: $d^{(1)} = [2, 5, 3, 4]$（小时）。\n    - $s = 2$: $d^{(2)} = [3, 6, 6, 3]$（小时）。\n    - $s = 3$: $d^{(3)} = [4, 7, 2, 5]$（小时）。\n  - 标称场景索引：$s_0 = 1$。\n\n- 测试用例 2（边界情况：相同的故障时间和对称的维修时长）：\n  - $M = 4$, $H = 10$。\n  - 故障时间：$t = [0, 0, 0, 0]$（小时）。\n  - 场景 ($S = 3$)：\n    - $s = 1$: $d^{(1)} = [1, 1, 1, 1]$（小时）。\n    - $s = 2$: $d^{(2)} = [2, 2, 2, 2]$（小时）。\n    - $s = 3$: $d^{(3)} = [3, 3, 3, 3]$（小时）。\n  - 标称场景索引：$s_0 = 1$。\n\n- 测试用例 3（边缘情况：交错的故障和一个具有不确定维修时长的重型任务）：\n  - $M = 4$, $H = 24$。\n  - 故障时间：$t = [0, 4, 8, 12]$（小时）。\n  - 场景 ($S = 3$)：\n    - $s = 1$: $d^{(1)} = [5, 1, 1, 1]$（小时）。\n    - $s = 2$: $d^{(2)} = [8, 1, 1, 1]$（小时）。\n    - $s = 3$: $d^{(3)} = [10, 1, 1, 1]$（小时）。\n  - 标称场景索引：$s_0 = 1$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有测试用例的聚合结果，格式为一个逗号分隔的列表，并用方括号括起来，每个测试用例贡献一个包含三个小数的子列表，顺序为 $[\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}}),\\ \\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}),\\ \\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}) - \\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})]$。例如，输出必须如下所示：\n\"[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]\"\n所有可用性值必须是小数。时间值单位为小时。角度单位不适用。",
            "solution": "该问题陈述已经过严格验证，被认为是信息物理系统调度与鲁棒优化领域中一个有效的、良构的、且有科学依据的问题。\n\n该问题要求计算和比较一个单一维修团队系统的确定性维修调度和鲁棒维修调度。性能指标是可用性 $A$，定义为在时域 $H$ 内部件可运行时间的比例。解决方案需要通过枚举所有可能的任务排列来找到最优调度，因为任务数量 $M$ 很小。\n\n问题的核心是在各种不确定性场景 $s \\in \\{1,\\dots,S\\}$ 下，评估给定维修调度 $\\pi$ 的可用性。调度 $\\pi$ 是 $M$ 个任务的一个排列。对于每个任务 $i \\in \\{1, \\dots, M\\}$，其故障时间为 $t_i$，在场景 $s$ 中的维修时长为 $d_i^{(s)}$。\n\n首先，我们必须在给定的调度 $\\pi = (\\pi_1, \\dots, \\pi_M)$ 和场景 $s$ 下，计算每个任务的完成时间。序列中第 $j$ 个任务的开始时间 $x_{\\pi_j}^{(s)}$ 由前一个任务的完成时间和当前任务的故障时间决定。维修团队在时间 $c_{\\pi_{j-1}}^{(s)}$ 完成任务 $\\pi_{j-1}$ 后可用，而任务 $\\pi_j$ 在其故障时间 $t_{\\pi_j}$ 之前不能开始。递推关系为：\n$$\nx_{\\pi_1}^{(s)} = \\max(0,\\ t_{\\pi_1})\n$$\n$$\nx_{\\pi_j}^{(s)} = \\max\\left(c_{\\pi_{j-1}}^{(s)}, t_{\\pi_j}\\right) \\quad \\text{for } j > 1\n$$\n其中 $c_{\\pi_{j-1}}^{(s)} = x_{\\pi_{j-1}}^{(s)} + d_{\\pi_{j-1}}^{(s)}$ 是序列中第 $(j-1)$ 个任务的完成时间。综合这些，可以迭代计算出序列中第 $j$ 个任务的完成时间 $c_{\\pi_j}^{(s)}$。一旦找到所有任务 $i=1,\\dots,M$ 的完成时间 $c_i^{(s)}(\\pi)$，调度 $\\pi$ 在场景 $s$ 中的总停机时间就是各个部件停机时间之和：\n$$\nD^{(s)}(\\pi) = \\sum_{i=1}^{M} \\left(c_{i}^{(s)}(\\pi) - t_i\\right)\n$$\n然后，调度 $\\pi$ 在场景 $s$ 中的可用性由下式给出：\n$$\nA^{(s)}(\\pi) = 1 - \\frac{D^{(s)}(\\pi)}{M \\cdot H}\n$$\n其中 $M \\cdot H$ 是所有部件的总最大运行时间。\n\n定义了评估函数 $A^{(s)}(\\pi)$ 后，我们就可以找到所需的两种调度：\n\n1.  **确定性调度 ($\\pi_{\\mathrm{det}}$)**：此调度对于单一的标称场景 $s_0$ 是最优的。它是在该场景中最大化可用性的排列：\n    $$\n    \\pi_{\\mathrm{det}} \\in \\arg\\max_{\\pi} A^{(s_0)}(\\pi)\n    $$\n\n2.  **鲁棒调度 ($\\pi_{\\mathrm{rob}}$)**：此调度在所有可能场景中提供最佳的保证性能。它是最大化最坏情况（最小）可用性的排列：\n    $$\n    \\pi_{\\mathrm{rob}} \\in \\arg\\max_{\\pi} \\min_{s \\in \\{1,\\dots,S\\}} A^{(s)}(\\pi)\n    $$\n\n问题规定了一个清晰的、分层的打破平局规则。如果多个排列产生相同的最优目标值，则选择在所有场景中具有更高平均可用性 $\\frac{1}{S}\\sum_{s=1}^{S} A^{(s)}(\\pi)$ 的那个。如果平局仍然存在，则选择字典序最小的排列。\n\n解决方案通过对每个测试用例执行以下步骤来实现：\n1.  生成任务索引 $\\{0, \\dots, M-1\\}$ 的所有 $M!$ 个排列。\n2.  对于每个排列 $\\pi$，计算其可用性向量 $[A^{(1)}(\\pi), \\dots, A^{(S)}(\\pi)]$。\n3.  对于每个排列，还要计算其在标称场景下的可用性 $A^{(s_0)}(\\pi)$、其最坏情况（最小）可用性 $\\min_s A^{(s)}(\\pi)$ 以及其平均可用性 $\\frac{1}{S}\\sum_s A^{(s)}(\\pi)$。\n4.  为了找到 $\\pi_{\\mathrm{det}}$，根据一个标准元组对所有排列进行排序，主要和次要目标按降序排列，第三目标按升序排列：$(A^{(s_0)}(\\pi), \\frac{1}{S}\\sum_s A^{(s)}(\\pi), \\pi)$。顶部的条目即为 $\\pi_{\\mathrm{det}}$。\n5.  为了找到 $\\pi_{\\mathrm{rob}}$，使用标准 $(\\min_s A^{(s)}(\\pi), \\frac{1}{S}\\sum_s A^{(s)}(\\pi), \\pi)$ 进行类似排序。顶部的条目即为 $\\pi_{\\mathrm{rob}}$。\n6.  最后，计算所需的值：确定性调度的最坏情况可用性 $\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$；鲁棒调度的最坏情况可用性 $\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}})$；以及两者之差的改进量。\n\n这个过程虽然对于大的 $M$ 来说计算量很大，但保证能为测试套件中指定的小值（$M=4$）找到正确的优化调度。计算使用浮点运算来产生所需的小数输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"M\": 4, \"H\": 20.0,\n            \"t\": [0.0, 2.0, 5.0, 7.0],\n            \"d_scenarios\": [\n                [2.0, 5.0, 3.0, 4.0],\n                [3.0, 6.0, 6.0, 3.0],\n                [4.0, 7.0, 2.0, 5.0]\n            ],\n            \"s0\": 1\n        },\n        # Test case 2\n        {\n            \"M\": 4, \"H\": 10.0,\n            \"t\": [0.0, 0.0, 0.0, 0.0],\n            \"d_scenarios\": [\n                [1.0, 1.0, 1.0, 1.0],\n                [2.0, 2.0, 2.0, 2.0],\n                [3.0, 3.0, 3.0, 3.0]\n            ],\n            \"s0\": 1\n        },\n        # Test case 3\n        {\n            \"M\": 4, \"H\": 24.0,\n            \"t\": [0.0, 4.0, 8.0, 12.0],\n            \"d_scenarios\": [\n                [5.0, 1.0, 1.0, 1.0],\n                [8.0, 1.0, 1.0, 1.0],\n                [10.0, 1.0, 1.0, 1.0]\n            ],\n            \"s0\": 1\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        M, H, t, d_scenarios, s0 = case[\"M\"], case[\"H\"], case[\"t\"], case[\"d_scenarios\"], case[\"s0\"]\n        \n        S = len(d_scenarios)\n        s0_idx = s0 - 1\n        job_indices = range(M)\n        \n        all_perms = list(itertools.permutations(job_indices))\n        \n        eval_results = []\n        for pi in all_perms:\n            # Calculate availability for pi under all scenarios\n            availabilities = []\n            for s in range(S):\n                d_s = d_scenarios[s]\n                completion_times = {}\n                prev_c = 0.0\n                \n                for job_idx in pi:\n                    start_time = max(prev_c, t[job_idx])\n                    completion_time = start_time + d_s[job_idx]\n                    completion_times[job_idx] = completion_time\n                    prev_c = completion_time\n                \n                total_downtime = 0.0\n                for i in range(M):\n                    total_downtime += completion_times[i] - t[i]\n                \n                availability_s = 1.0 - total_downtime / (M * H)\n                availabilities.append(availability_s)\n                \n            min_A = min(availabilities)\n            avg_A = np.mean(availabilities)\n            nominal_A = availabilities[s0_idx]\n            \n            eval_results.append({\n                \"pi\": pi,\n                \"availabilities\": availabilities,\n                \"nominal_A\": nominal_A,\n                \"min_A\": min_A,\n                \"avg_A\": avg_A\n            })\n\n        # Find pi_det using tie-breaking rules\n        # Sort by nominal_A (desc), then avg_A (desc), then pi (asc)\n        det_candidates = sorted(eval_results, key=lambda x: (-x[\"nominal_A\"], -x[\"avg_A\"], x[\"pi\"]))\n        pi_det_result = det_candidates[0]\n\n        # Find pi_rob using tie-breaking rules\n        # Sort by min_A (desc), then avg_A (desc), then pi (asc)\n        rob_candidates = sorted(eval_results, key=lambda x: (-x[\"min_A\"], -x[\"avg_A\"], x[\"pi\"]))\n        pi_rob_result = rob_candidates[0]\n\n        # Calculate required outputs\n        worst_case_A_det = min(pi_det_result[\"availabilities\"])\n        worst_case_A_rob = pi_rob_result[\"min_A\"] # This is the value we maximized\n        improvement = worst_case_A_rob - worst_case_A_det\n\n        all_results.append([worst_case_A_det, worst_case_A_rob, improvement])\n\n    # Format output string to match \"[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]\"\n    inner_results_str = []\n    for res in all_results:\n        # Format each sub-list without spaces\n        inner_results_str.append(f\"[{','.join(map(str, res))}]\")\n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}