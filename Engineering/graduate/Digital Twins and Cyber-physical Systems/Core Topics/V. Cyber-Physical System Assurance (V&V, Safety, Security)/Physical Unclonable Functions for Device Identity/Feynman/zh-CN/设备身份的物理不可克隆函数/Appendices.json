{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在探讨物理不可克隆函数（PUF）最基本的特性：可靠性。由于环境噪声的影响，PUF的响应并非完全可重复。本练习将引导你从第一性原理出发，推导获得无错误响应的概率，从而建立PUF可靠性的核心数学模型。理解此模型是设计能够容忍并纠正这些固有物理变化的鲁棒系统的第一步。",
            "id": "4235123",
            "problem": "一个物理不可克隆函数 (PUF) 被部署用于信息物理系统 (CPS) 的数字孪生 (DT) 中的设备身份认证。在注册时，设备的PUF响应被记录为一个长度为 $n$ 位的参考字符串。在后续的读出操作中，环境噪声导致每一位相对于注册位以概率 $p$ 独立翻转，其中 $0 \\leq p \\leq 1$。设误差向量为 $E \\in \\{0,1\\}^{n}$，其中 $E_{i} = 1$ 表示第 $i$ 位发生翻转，$E_{i} = 0$ 表示没有翻转。误差向量的汉明权重定义为 $H = \\sum_{i=1}^{n} E_{i}$，它计算了翻转位的数量。\n\n仅从以下基本原理出发：\n- 独立伯努利随机变量的定义，\n- 独立事件的乘法法则，\n- 以及对结果的组合计数，\n\n通过显式计算误差汉明权重的分布，推导 $H$ 的概率质量函数。然后，将 $n$ 位响应的可靠性（记为 $\\mathcal{R}(n,p)$）定义为后续读出与注册参考完全匹配的概率（即 $H = 0$）。计算 $\\mathcal{R}(n,p)$，结果表示为关于 $n$ 和 $p$ 的闭式解析表达式。\n\n你的最终答案必须是单一的闭式表达式。不需要数值四舍五入，此概率不涉及物理单位。",
            "solution": "该问题陈述具有科学依据、内容自洽且提法适定。它提出了一个数字系统中位翻转错误的典型模型，该模型可以使用概率论的基本原理进行分析。所有变量和条件都得到了明确定义，从而导出一个唯一且有意义的解。因此，该问题被认为是有效的。\n\n我们有两个任务目标：首先，推导误差汉明权重 $H$ 的概率质量函数 (PMF)；其次，计算可靠性 $\\mathcal{R}(n,p)$，其定义为零错误的概率。推导过程必须按照要求从第一性原理构建。\n\n让我们对PUF响应中每一位的状态进行建模。对于每一位 $i \\in \\{1, 2, \\dots, n\\}$，都有一个相关的误差变量 $E_i$。问题陈述指出，每一位都以概率 $p$ 独立翻转。因此，我们可以将 $E_i$ 定义为一个随机变量，如果第 $i$ 位翻转，则 $E_i=1$，如果第 $i$ 位不翻转，则 $E_i=0$。\n\n根据问题描述，每个 $E_i$ 都是一个独立的伯努利随机变量。每个 $E_i$ 的概率质量函数为：\n$$ P(E_i = 1) = p $$\n$$ P(E_i = 0) = 1 - p $$\n\n误差向量的汉明权重 $H$ 定义为翻转位的总数：\n$$ H = \\sum_{i=1}^{n} E_i $$\n我们旨在求出 $H$ 的概率质量函数，即对于满足 $0 \\le k \\le n$ 的任意整数 $k$ 的概率 $P(H=k)$。事件 $H=k$ 对应于在 $n$ 位中观察到恰好 $k$ 次位翻转和 $n-k$ 次未翻转。\n\n让我们考虑一个导致汉明权重为 $k$ 的特定误差序列。例如，考虑前 $k$ 位翻转而后 $n-k$ 位不翻转的序列。其误差向量将是 $(\\underbrace{1, 1, \\dots, 1}_{k \\text{ 次}}, \\underbrace{0, 0, \\dots, 0}_{n-k \\text{ 次}})$。由于位翻转是独立事件，我们可以使用独立事件的乘法法则来计算这个特定序列发生的概率：\n$$ P(E_1=1, \\dots, E_k=1, E_{k+1}=0, \\dots, E_n=0) = \\left( \\prod_{i=1}^{k} P(E_i=1) \\right) \\left( \\prod_{j=k+1}^{n} P(E_j=0) \\right) $$\n代入伯努利试验的概率，我们得到：\n$$ p^k (1-p)^{n-k} $$\n任何其他包含 $k$ 次翻转和 $n-k$ 次未翻转的特定序列的概率是相同的，因为乘法满足交换律。\n\n接下来，我们必须使用组合计数来确定导致汉明权重为 $k$ 的不同序列的总数。这等价于计算从 $n$ 个可用位位置中选择 $k$ 个位置发生翻转的方式总数。这个数量由二项式系数给出，记作 $\\binom{n}{k}$：\n$$ \\binom{n}{k} = \\frac{n!}{k!(n-k)!} $$\n\n观察到恰好 $k$ 次翻转的总概率 $P(H=k)$ 是所有这些不同序列的概率之和。由于每个序列的概率都相同，为 $p^k(1-p)^{n-k}$，我们可以将这个概率乘以这类序列的数量：\n$$ P(H=k) = \\binom{n}{k} p^k (1-p)^{n-k} $$\n这就是二项分布的概率质量函数，它描述了随机变量 $H \\sim \\text{Binomial}(n,p)$。这完成了推导的第一部分。\n\n任务的第二部分是计算可靠性 $\\mathcal{R}(n,p)$，其定义为读出结果与注册参考完全匹配的概率。这对应于零位翻转的情况，即 $H=0$。我们可以通过在上面推导的概率质量函数中设置 $k=0$ 来计算这个概率：\n$$ \\mathcal{R}(n,p) = P(H=0) $$\n$$ \\mathcal{R}(n,p) = \\binom{n}{0} p^0 (1-p)^{n-0} $$\n现在我们计算这个表达式中的每一项。\n当 $k=0$ 时的二项式系数是：\n$$ \\binom{n}{0} = \\frac{n!}{0!(n-0)!} = \\frac{n!}{1 \\cdot n!} = 1 $$\n这里我们使用了 $0!=1$ 的定义。\n项 $p^0$ 是：\n$$ p^0 = 1 $$\n（这对任何 $p \\in [0,1]$ 都成立，包括边界情况）。\n最后一项是：\n$$ (1-p)^{n-0} = (1-p)^n $$\n结合这些结果，我们得到可靠性的闭式解析表达式：\n$$ \\mathcal{R}(n,p) = 1 \\cdot 1 \\cdot (1-p)^n = (1-p)^n $$\n该表达式给出了在给定独立位翻转概率为 $p$ 的情况下，一个 $n$ 位响应被无差错读出的概率。",
            "answer": "$$\\boxed{(1-p)^n}$$"
        },
        {
            "introduction": "现实世界中的PUF，例如基于SRAM的PUF，由许多稳定性各异的独立组件（单元）构成。PUF设计的一个关键步骤是从庞大的单元群体中识别并挑选出最可靠的单元。这项动手编程实践要求你分析来自SRAM PUF的经验数据，量化每个单元的稳定性，并实现一种选择算法来构建高质量的PUF响应。本练习将抽象的统计学概念与PUF表征和优化的实际工程挑战联系起来。",
            "id": "4235149",
            "problem": "您正在一个具有数字孪生的信息物理系统中，对一个静态随机存取存储器物理不可克隆函数（SRAM PUF）进行建模。SRAM PUF 中的每个单元都被建模为一个独立的伯努利随机变量，每次上电时输出逻辑 $0$ 或逻辑 $1$。设备身份取决于选择一个能够在多次上电周期中可靠地再现其启动值的单元子集。本问题的目的是，从第一性原理出发，推导一种方法，从经验性的启动模式中估计每个单元的偏置，并选择偏置幅度超过某个阈值的单元子集，以在指定的密度约束下最大化可靠性。\n\n基本原理：\n- 参数为 $p$ 的伯努利随机变量以概率 $p$ 输出 $1$，以概率 $1-p$ 输出 $0$。对于独立重复实验，从 $m$ 次观测中计算出的样本均值 $\\hat{p}$ 是 $p$ 的最大似然估计量。\n- 一个总是再现其多数值的单元的启动值可靠性，等效地由函数 $r(p) = \\max(p, 1-p)$ 量化，该函数等于 $1/2 + |p - 1/2|$。\n- Hoeffding 不等式指出，对于在 $[0,1]$ 区间内的独立有界随机变量，如果 $\\hat{p}$ 是 $m$ 次独立伯努利试验的样本均值，其真实均值为 $p$，那么对于任何 $\\epsilon > 0$，有 $\\mathbb{P}\\left(|\\hat{p} - p| \\ge \\epsilon\\right) \\le 2 \\exp(-2 m \\epsilon^2)$。解出 $\\epsilon$ 可得到置信水平为 $1-\\alpha$ 的置信半径 $\\epsilon = \\sqrt{\\ln(2/\\alpha)/(2 m)}$。\n\n定义和推导要求：\n- 对于在 $m$ 次启动中测量的每个单元 $i \\in \\{1,\\dots,n\\}$，定义 $x_{i1},\\dots,x_{im} \\in \\{0,1\\}$ 为经验结果。最大似然估计量为 $\\hat{p}_i = \\frac{1}{m}\\sum_{j=1}^{m} x_{ij}$，估计偏置为 $\\hat{b}_i = \\hat{p}_i - 1/2$。偏置幅度为 $|\\hat{b}_i|$。\n- 对于置信水平 $1-\\alpha$，定义 $\\epsilon = \\sqrt{\\ln(2/\\alpha)/(2 m)}$。对 $|p_i - 1/2|$ 使用三角不等式，并结合 Hoeffding 对 $|p_i - \\hat{p}_i|$ 的置信界，可得可靠性的一个下界 $r_i^{\\mathrm{lb}} = 1/2 + \\max(0, |\\hat{b}_i| - \\epsilon)$，该下界在采样过程中以至少 $1-\\alpha$ 的概率成立。\n- 对于目标选择密度 $d \\in (0,1]$，定义要选择的单元数量为 $k = \\max(1, \\lfloor d n \\rfloor)$。在所有大小为 $k$ 的子集中，能使可靠性下界 $r_i^{\\mathrm{lb}}$ 之和（及平均值）最大化的子集，是通过选择具有最大偏置幅度 $|\\hat{b}_i|$ 的 $k$ 个单元来获得的。等效地，将选择阈值 $\\tau$ 设置为第 $k$ 大的 $|\\hat{b}_i|$ 值，并选择满足 $|\\hat{b}_i| \\ge \\tau$ 的 $k$ 个单元；通过任意但确定性的规则解决平局问题，以确保恰好选择 $k$ 个单元。\n\n您的程序必须：\n- 给定经验启动模式，计算 $\\hat{p}_i$、$\\hat{b}_i$、$|\\hat{b}_i|$、阈值 $\\tau$ 以及所选子集上的平均可靠性下界 $\\bar{r}^{\\mathrm{lb}} = \\frac{1}{k} \\sum_{i \\in S} r_i^{\\mathrm{lb}}$，其中 $S$ 是所选的单元子集。\n- 对于每个测试用例，输出三元组 $[\\tau, \\bar{r}^{\\mathrm{lb}}, k/n]$，其中浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n对于每个测试用例，经验模式由每个单元输出为 1 的次数定义；单元 $i$ 的长度为 $m$ 的经验向量包含 $c_i$ 个 1 和 $m-c_i$ 个 0。每个单元向量中 1 和 0 的顺序是任意的，不影响估计量。\n\n- 案例 $\\mathrm{A}$：$n = 12$，$m = 30$，$d = 0.5$，$\\alpha = 0.05$，计数 $c_{\\mathrm{A}} = (25, 5, 18, 12, 30, 0, 16, 14, 20, 10, 28, 2)$。\n- 案例 $\\mathrm{B}$：$n = 8$，$m = 40$，$d = 0.75$，$\\alpha = 0.01$，计数 $c_{\\mathrm{B}} = (21, 20, 19, 22, 18, 21, 20, 19)$。\n- 案例 $\\mathrm{C}$：$n = 10$，$m = 25$，$d = 0.4$，$\\alpha = 0.1$，计数 $c_{\\mathrm{C}} = (24, 1, 23, 2, 20, 5, 25, 0, 22, 3)$。\n- 案例 $\\mathrm{D}$：$n = 6$，$m = 10$，$d = 1.0$，$\\alpha = 0.05$，计数 $c_{\\mathrm{D}} = (7, 3, 5, 5, 10, 0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例的结果是一个列表 $[\\tau, \\bar{r}^{\\mathrm{lb}}, k/n]$，四舍五入到 $6$ 位小数，并且没有任何空格。例如，程序必须打印一行类似 $[[0.123456,0.987654,0.500000],[\\dots],[\\dots],[\\dots]]$ 的格式。",
            "solution": "该问题是有效的，因为它具有科学依据、定义明确且客观。它基于已建立的统计学原理和静态随机存取存储器（SRAM）物理不可克隆函数（PUF）的标准模型，提供了一套完整、自洽的定义和数据。任务是实现一个明确定义的算法，用于选择可靠的 SRAM 单元并评估其集体性能。解决方案通过系统地应用所提供的定义和公式来推进。\n\n处理每个测试用例的方法如下。一个测试用例由单元数量 $n$、每个单元的启动测量次数 $m$、目标选择密度 $d \\in (0,1]$、置信参数 $\\alpha \\in (0,1)$ 以及 $n$ 个单元观测到的‘1’计数向量 $c = (c_1, c_2, \\dots, c_n)$ 定义。\n\n首先，我们确定为最终 PUF 身份选择的单元数量 $k$。这基于目标密度 $d$ 和总单元数 $n$。公式为 $k = \\max(1, \\lfloor d n \\rfloor)$，确保始终至少选择一个单元。\n\n其次，我们根据 Hoeffding 不等式计算置信半径 $\\epsilon$，它量化了任何单元的经验概率估计与真实基础概率 $p_i$ 之间的最大预期误差。该半径取决于测量次数 $m$ 和期望的置信水平 $1-\\alpha$。其公式为 $\\epsilon = \\sqrt{\\frac{\\ln(2/\\alpha)}{2 m}}$。\n\n第三，对于每个单元 $i \\in \\{1, \\dots, n\\}$，我们根据 $m$ 次试验中出现 1 的次数 $c_i$ 来计算其经验特征。\n启动为 1 的真实概率 $p_i$ 的最大似然估计量（MLE）是样本均值：\n$$ \\hat{p}_i = \\frac{c_i}{m} $$\n单元的偏置 $b_i = p_i - 1/2$ 衡量其偏向 $1$ 或 $0$ 的趋势。偏置为 $0$ 对应一个完全随机的单元 ($p_i=0.5$)，而大的正或负偏置表示一个稳定的单元。我们计算估计偏置 $\\hat{b}_i$ 及其幅度 $|\\hat{b}_i|$：\n$$ \\hat{b}_i = \\hat{p}_i - \\frac{1}{2} $$\n$$ |\\hat{b}_i| = \\left| \\hat{p}_i - \\frac{1}{2} \\right| $$\n偏置幅度 $|\\hat{b}_i|$ 可作为单元估计可靠性的直接度量。接近 $0.5$ 的值表示高稳定性（总是启动为 $0$ 或 $1$），而接近 $0$ 的值表示不稳定性。\n\n第四，我们实施选择策略。为了最大化所选单元子集的整体可靠性，我们选择具有最高估计偏置幅度 $|\\hat{b}_i|$ 的 $k$ 个单元。为此，我们将所有 $n$ 个计算出的偏置幅度按降序排序。选择阈值 $\\tau$ 随后被定义为该排序列表中的第 $k$ 大值。这对应于一个单元被包含在所选集合中所要求的最小偏置幅度。\n\n第五，一旦确定了包含 $k$ 个单元的子集 $S$，我们就评估其质量。对于每个选定的单元 $i \\in S$，我们计算其真实可靠性的下界 $r_i^{\\mathrm{lb}}$，该下界以至少 $1-\\alpha$ 的概率成立。这个保守估计考虑了 $\\hat{p}_i$ 中的统计不确定性。其公式为：\n$$ r_i^{\\mathrm{lb}} = \\frac{1}{2} + \\max(0, |\\hat{b}_i| - \\epsilon) $$\n该表达式从估计的偏置幅度中减去不确定性半径 $\\epsilon$，以确保我们有信心真实可靠性至少达到此高度。\n\n最后，我们计算整个所选子集 $S$ 上的平均可靠性下界 $\\bar{r}^{\\mathrm{lb}}$：\n$$ \\bar{r}^{\\mathrm{lb}} = \\frac{1}{k} \\sum_{i \\in S} r_i^{\\mathrm{lb}} $$\n该指标代表了在指定置信水平下，所选 PUF 质询-响应对机制的保证最小平均可靠性。\n\n每个测试用例的结果是包含计算出的阈值 $\\tau$、平均可靠性下界 $\\bar{r}^{\\mathrm{lb}}$ 和实际选择密度 $k/n$ 的三元组。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SRAM PUF cell selection problem for a given suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, m, d, alpha, counts)\n        (12, 30, 0.5, 0.05, [25, 5, 18, 12, 30, 0, 16, 14, 20, 10, 28, 2]),\n        (8, 40, 0.75, 0.01, [21, 20, 19, 22, 18, 21, 20, 19]),\n        (10, 25, 0.4, 0.1, [24, 1, 23, 2, 20, 5, 25, 0, 22, 3]),\n        (6, 10, 1.0, 0.05, [7, 3, 5, 5, 10, 0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, m, d, alpha, counts = case\n\n        # Step 1: Calculate k, the number of cells to select.\n        k = max(1, int(np.floor(d * n)))\n\n        # Step 2: Calculate the confidence radius epsilon.\n        epsilon = np.sqrt(np.log(2 / alpha) / (2 * m))\n\n        # Step 3: Compute bias magnitude for each cell.\n        counts_arr = np.array(counts, dtype=float)\n        p_hat = counts_arr / m\n        b_hat_mag = np.abs(p_hat - 0.5)\n\n        # Step 4: Determine the selection threshold tau.\n        # Sort bias magnitudes in descending order.\n        b_hat_mag_sorted = np.sort(b_hat_mag)[::-1]\n        \n        # The threshold tau is the k-th largest bias magnitude.\n        # In a 0-indexed array, this is the element at index k-1.\n        tau = b_hat_mag_sorted[k - 1]\n\n        # Step 5: Calculate the average reliability lower bound for the selected subset.\n        # The selected cells are those corresponding to the top k bias magnitudes.\n        selected_b_hat_mag = b_hat_mag_sorted[:k]\n        \n        # Calculate the lower bound on reliability for each selected cell.\n        r_lb_terms = 0.5 + np.maximum(0, selected_b_hat_mag - epsilon)\n        \n        # Calculate the average across the selected cells.\n        r_lb_bar = np.mean(r_lb_terms)\n\n        # Calculate the actual selection density.\n        actual_density = k / float(n)\n\n        # Append the rounded result triple.\n        results.append(\n            f\"[{round(tau, 6):.6f},{round(r_lb_bar, 6):.6f},{round(actual_density, 6):.6f}]\"\n        )\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "即使在选择了最可靠的PUF比特之后，通常仍会存在残余噪声，这使得原始响应不适合直接用作加密密钥。为了确保每次都能生成完全稳定的密钥，需要使用纠错码（Error-Correcting Codes, ECC）。本问题将让你扮演系统设计者的角色，负责选择BCH码的参数，以平衡可靠性与密钥长度之间的权衡——这是基于PUF的密钥生成中的核心挑战。你将确定为满足严格的系统失效率所需的纠错能力，并计算可实现的最大密钥长度。",
            "id": "4235125",
            "problem": "在信息物理系统 (CPS) 中，物理不可克隆函数 (PUF) 用于将其设备身份与其数字孪生 (Digital Twin) 进行绑定。PUF 会产生一个原始二进制响应，该响应注册一次，然后按需重构。相对于已注册的参考值，每个响应比特以比特错误率 (BER) $p$ 独立地发生翻转。为了使重构的密钥在各种操作条件下都具有鲁棒性，系统在 PUF 响应上使用二进制本原窄义 Bose–Chaudhuri–Hocquenghem (BCH) 码作为纠错码 (ECC)。如果噪声响应中的比特错误数量超过了 ECC 的纠错能力，则重构尝试失败。\n\n考虑一种设计，其中原始响应长度固定为 $n = 511$ 比特，因此 BCH 码的长度等于响应长度，其中 $n = 2^{m} - 1$ 且 $m$ 为整数。重构的密钥是 BCH 码的维度 $k$（以比特为单位）。该设计必须确保每次重构尝试的失败概率最多为期望的密钥失效率 $\\delta$。\n\n假设如下：\n- 比特翻转过程是独立同分布的，比特错误率 (BER) $p = 0.02$。\n- 目标密钥失效率为 $\\delta = 10^{-6}$。\n- 失败事件由 $n$ 次试验中比特错误数量的二项分布模型定义。\n- BCH 码族限定为长度为 $n = 511$ 的本原窄义二进制码。\n\n选择纠错能力 $t$ 以使失败概率最多为 $\\delta$，然后选择与此选择一致的相应 BCH 参数 $[n, k, t]$。计算在这些约束条件下可实现的最大重构密钥长度 $k$。以比特表示最终的密钥长度。如果需要任何中间近似，请从第一性原理出发对其进行论证，并使用统计上可靠的近似方法。没有外部数据源可用。最终答案必须是单个数字。",
            "solution": "该问题定义明确，需要应用统计学和编码理论中的标准工程原理。所有提供的数据都是必要且一致的。\n\n第一步是确定为满足指定的密钥失效率所需的最小纠错能力，记为 $t$。长度为 $n$ 的原始响应中的比特错误数 $X$ 服从二项分布，$X \\sim \\mathcal{B}(n, p)$，其参数为 $n=511$ 和 $p=0.02$。\n\n如果错误数 $X$ 超过了码的纠错能力 $t$，则发生重构失败。此事件的概率必须最多为 $\\delta = 10^{-6}$。数学约束为：\n$$P(X > t) \\le \\delta$$\n\n此二项分布尾概率的精确计算在计算上是密集的。我们可以使用近似法。首先，我们计算二项分布的均值 $\\mu$ 和方差 $\\sigma^2$：\n$$\\mu = np = 511 \\times 0.02 = 10.22$$\n$$\\sigma^2 = np(1-p) = 511 \\times 0.02 \\times (1 - 0.02) = 10.22 \\times 0.98 = 10.0156$$\n标准差为 $\\sigma = \\sqrt{10.0156} \\approx 3.1647$。\n\n由于 $n=511$ 很大，且 $np = 10.22 > 5$ 和 $n(1-p) = 500.78 > 5$ 都得到满足，根据棣莫弗-拉普拉斯定理，该二项分布可以被正态分布 $\\mathcal{N}(\\mu, \\sigma^2)$ 精确地近似。\n\n为了提高用连续分布近似离散分布的准确性，我们应用连续性校正。离散变量 $X$ 的事件 $X > t$ 对应于连续近似变量 $Y \\sim \\mathcal{N}(\\mu, \\sigma^2)$ 的事件 $Y > t + 0.5$。约束条件变为：\n$$P(Y > t + 0.5) \\le \\delta$$\n\n我们通过转换为标准正态变量 $Z = \\frac{Y - \\mu}{\\sigma} \\sim \\mathcal{N}(0, 1)$ 来将其标准化：\n$$P\\left(Z > \\frac{(t + 0.5) - \\mu}{\\sigma}\\right) \\le \\delta$$\n令 $\\Phi(z)$ 为标准正态分布的累积分布函数 (CDF)。不等式可写为：\n$$1 - \\Phi\\left(\\frac{t + 0.5 - \\mu}{\\sigma}\\right) \\le \\delta$$\n$$\\Phi\\left(\\frac{t + 0.5 - \\mu}{\\sigma}\\right) \\ge 1 - \\delta$$\n代入 $\\delta = 10^{-6}$，我们需要找到分位数 $z_{\\delta}$ 使得 $\\Phi(z_{\\delta}) \\ge 1 - 10^{-6} = 0.999999$。在无法查阅统计表的情况下，我们必须依赖概率论中的已知值。$10^{-6}$ 的单尾概率对应的 z-score 约为 $z_{\\delta} \\approx 4.753$。\n\n现在我们可以求解 $t$：\n$$\\frac{t + 0.5 - \\mu}{\\sigma} \\ge z_{\\delta}$$\n$$t \\ge \\mu - 0.5 + z_{\\delta}\\sigma$$\n代入数值：\n$$t \\ge 10.22 - 0.5 + (4.753)(3.1647)$$\n$$t \\ge 9.72 + 15.0423$$\n$$t \\ge 24.7623$$\n因为 $t$ 必须是代表可纠正错误数量的整数，所以我们必须选择满足此条件的最小整数，即 $t=25$。\n\n下一步是为具有参数 $[n, k, t]$ 的本原窄义二进制 BCH 码确定最大密钥长度 $k$。码长给定为 $n=511$。对于 BCH 码，其长度形式为 $n = 2^m - 1$，其中 $m$ 是某个整数。\n$$511 = 2^m - 1 \\implies 512 = 2^m \\implies m=9$$\n设计用于纠正 $t$ 个错误的 BCH 码的维度 $k$ 与 $n$ 和 $m$ 相关，其关系由关于奇偶校验比特数 $n-k$ 的 BCH 界给出。所需的奇偶校验比特数最多为 $mt$。为了最大化信息长度 $k$，我们使用该界限为等式的标准构造：\n$$k = n - mt$$\n代入已确定的值 $n=511$、$m=9$ 和 $t=25$：\n$$k = 511 - 9 \\times 25$$\n$$k = 511 - 225$$\n$$k = 286$$\n因此，在给定约束下可实现的最大重构密钥长度为 $286$ 比特。这对应于 BCH 码 $[511, 286, 25]$。",
            "answer": "$$\\boxed{286}$$"
        }
    ]
}