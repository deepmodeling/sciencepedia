{
    "hands_on_practices": [
        {
            "introduction": "攻击树是将复杂安全威胁分解为一系列更简单、可管理攻击步骤的强大图形化工具。通过此练习，您将学习如何系统地构建攻击路径模型，并运用概率论来量化系统的总体风险，这对于确定安全投资的优先级至关重要。",
            "id": "4248547",
            "problem": "一个远程操作的隔离阀是化学过程系统 (CPS) 的一部分，该系统由一个 Digital Twin 进行镜像，后者为监控和预测性维护重现了阀门的物理状态和控制逻辑。工业控制系统 (ICS) 网络包括一个可编程逻辑控制器 (PLC) 和一个人机界面 (HMI)。考虑顶事件“在 $T = 24$ 小时的时间范围内未经授权的阀门开启”。使用攻击树对此顶事件进行建模，其内部节点是逻辑与门和或门，其叶节点代表原子攻击步骤。使用以下科学上合理的结构和参数，并将攻击者行为和防御者控制视为概率上独立的，除非明确说明了条件性。\n\n顶事件分支（所有三个分支在顶事件处为逻辑或关系）：\n- 分支 $\\mathcal{B}_{1}$（远程命令注入）是两个子路径的逻辑或：\n  - 子路径 $\\mathcal{B}_{1a}$ 是叶节点 $L_{1}$（通过网络钓鱼泄露操作员凭证）和叶节点 $L_{2}$（因缺少授权检查而接受远程命令）的逻辑与。\n  - 子路径 $\\mathcal{B}_{1b}$ 是叶节点 $L_{3}$（防火墙规则配置错误允许命令路径）和叶节点 $L_{4}$（PLC零日漏洞利用以实现未经授权的命令）的逻辑与。\n- 分支 $\\mathcal{B}_{2}$（现场篡改）是叶节点 $L_{5}$（对控制器外壳的物理入侵）和叶节点 $L_{6}$（手动超控开关被启动且未被注意到）的逻辑与。$L_{6}$ 的发生以 $L_{5}$ 的发生为条件。\n- 分支 $\\mathcal{B}_{3}$（Digital Twin 去同步）是叶节点 $L_{7}$（孪生数据完整性受损导致错误的“关闭”状态）和叶节点 $L_{8}$（在孪生误报时注入执行器命令）的逻辑与。\n\n对于每个叶节点 $L_{i}$，给定一个基线日发生概率 $p_{i}$（在没有防御者控制的情况下攻击者行动成功的概率）和一个防御者控制阻止概率 $b_{i}$（防御者控制阻止该叶节点事件的概率）。参数如下：\n- $p_{1} = 3.0 \\times 10^{-3}$ 且 $b_{1} = 0.95$，\n- $p_{2} = 1.0 \\times 10^{-3}$ 且 $b_{2} = 0.80$，\n- $p_{3} = 5.0 \\times 10^{-3}$ 且 $b_{3} = 0.90$，\n- $p_{4} = 2.0 \\times 10^{-4}$ 且 $b_{4} = 0.50$，\n- $p_{5} = 4.0 \\times 10^{-3}$ 且 $b_{5} = 0.90$，\n- $p_{6} = 5.0 \\times 10^{-3}$ 且 $b_{6} = 0.60$，\n- $p_{7} = 1.5 \\times 10^{-3}$ 且 $b_{7} = 0.85$，\n- $p_{8} = 8.0 \\times 10^{-4}$ 且 $b_{8} = 0.75$。\n\n使用概率公理和攻击树的标准语义（逻辑与对应于联合发生；逻辑或对应于至少一个子路径的发生），并假设除了明确说明的条件性（如 $L_{6}$ 给定 $L_{5}$）外，叶节点之间相互独立，执行以下操作：\n1. 计算在受到相应防御者控制的情况下，每个叶节点 $L_{i}$ 在 $T$ 时间内的残余可能性。\n2. 按照攻击树的规定，沿逻辑与和逻辑或进行聚合，以获得顶事件在 $T$ 时间内的总体情景可能性。\n\n将最终情景可能性表示为科学记数法的小数，四舍五入至四位有效数字。不需要单位，答案不得为不等式或方程式。",
            "solution": "该问题要求在给定攻击树的逻辑结构和原子攻击步骤（叶节点）概率的情况下，计算顶事件的概率。该问题定义明确，并在定量风险评估和概率建模的原则上具有科学依据。\n\n首先，我们将问题形式化。设 $E_i$ 为对应于叶节点 $L_i$ 的原子攻击成功的事件。问题为每个叶节点提供了基线日发生概率 $p_i$ 和防御者控制阻止概率 $b_i$。攻击步骤 $E_i$ 的成功需要基线攻击发生且相应的防御者控制失败。假设攻击行为和防御者控制是独立事件，则控制失败的概率为 $(1 - b_i)$。因此，每个叶节点事件 $E_i$ 成功的残余可能性（我们表示为 $\\mathcal{L}_i$）由下式给出：\n$$ \\mathcal{L}_i = P(E_i) = p_i (1 - b_i) $$\n时间范围给定为 $T = 24$ 小时，概率 $p_i$ 以“日发生”概率给出，因此它们直接适用于此时间范围。\n\n我们计算每个叶节点 $i=1, \\dots, 8$ 的残余可能性 $\\mathcal{L}_i$：\n- $\\mathcal{L}_1 = p_1(1-b_1) = (3.0 \\times 10^{-3})(1 - 0.95) = (3.0 \\times 10^{-3})(0.05) = 1.5 \\times 10^{-4}$\n- $\\mathcal{L}_2 = p_2(1-b_2) = (1.0 \\times 10^{-3})(1 - 0.80) = (1.0 \\times 10^{-3})(0.20) = 2.0 \\times 10^{-4}$\n- $\\mathcal{L}_3 = p_3(1-b_3) = (5.0 \\times 10^{-3})(1 - 0.90) = (5.0 \\times 10^{-3})(0.10) = 5.0 \\times 10^{-4}$\n- $\\mathcal{L}_4 = p_4(1-b_4) = (2.0 \\times 10^{-4})(1 - 0.50) = (2.0 \\times 10^{-4})(0.50) = 1.0 \\times 10^{-4}$\n- $\\mathcal{L}_5 = p_5(1-b_5) = (4.0 \\times 10^{-3})(1 - 0.90) = (4.0 \\times 10^{-3})(0.10) = 4.0 \\times 10^{-4}$\n- $\\mathcal{L}_6 = p_6(1-b_6) = (5.0 \\times 10^{-3})(1 - 0.60) = (5.0 \\times 10^{-3})(0.40) = 2.0 \\times 10^{-3}$\n- $\\mathcal{L}_7 = p_7(1-b_7) = (1.5 \\times 10^{-3})(1 - 0.85) = (1.5 \\times 10^{-3})(0.15) = 2.25 \\times 10^{-4}$\n- $\\mathcal{L}_8 = p_8(1-b_8) = (8.0 \\times 10^{-4})(1 - 0.75) = (8.0 \\times 10^{-4})(0.25) = 2.0 \\times 10^{-4}$\n\n接下来，我们根据攻击树的结构聚合这些概率。\n顶事件 $TE$ 是三个主分支的并集（逻辑或）：$TE = \\mathcal{B}_1 \\cup \\mathcal{B}_2 \\cup \\mathcal{B}_3$。\n这些分支由涉及不相交叶节点集的事件组成，因此我们可以将 $\\mathcal{B}_1$、$\\mathcal{B}_2$ 和 $\\mathcal{B}_3$ 视为相互独立的事件。它们的并集概率为：\n$$ P(TE) = 1 - (1 - P(\\mathcal{B}_1))(1 - P(\\mathcal{B}_2))(1 - P(\\mathcal{B}_3)) $$\n\n我们计算每个分支的概率。\n**分支 $\\mathcal{B}_1$（远程命令注入）：**\n该分支是两个子路径的并集：$\\mathcal{B}_1 = \\mathcal{B}_{1a} \\cup \\mathcal{B}_{1b}$。\n子路径 $\\mathcal{B}_{1a}$ 是 $E_1$ 和 $E_2$ 的交集（逻辑与）。由于 $E_1$ 和 $E_2$ 是独立的：\n$$ P(\\mathcal{B}_{1a}) = P(E_1 \\cap E_2) = P(E_1)P(E_2) = \\mathcal{L}_1 \\mathcal{L}_2 = (1.5 \\times 10^{-4})(2.0 \\times 10^{-4}) = 3.0 \\times 10^{-8} $$\n子路径 $\\mathcal{B}_{1b}$ 是 $E_3$ 和 $E_4$ 的交集。由于 $E_3$ 和 $E_4$ 是独立的：\n$$ P(\\mathcal{B}_{1b}) = P(E_3 \\cap E_4) = P(E_3)P(E_4) = \\mathcal{L}_3 \\mathcal{L}_4 = (5.0 \\times 10^{-4})(1.0 \\times 10^{-4}) = 5.0 \\times 10^{-8} $$\n子路径 $\\mathcal{B}_{1a}$ 和 $\\mathcal{B}_{1b}$ 涉及不相交的叶节点集，因此是独立的。它们的并集概率为：\n$$ P(\\mathcal{B}_1) = P(\\mathcal{B}_{1a} \\cup \\mathcal{B}_{1b}) = P(\\mathcal{B}_{1a}) + P(\\mathcal{B}_{1b}) - P(\\mathcal{B}_{1a})P(\\mathcal{B}_{1b}) $$\n$$ P(\\mathcal{B}_1) = (3.0 \\times 10^{-8}) + (5.0 \\times 10^{-8}) - (3.0 \\times 10^{-8})(5.0 \\times 10^{-8}) $$\n$$ P(\\mathcal{B}_1) = 8.0 \\times 10^{-8} - 1.5 \\times 10^{-15} = 7.99999985 \\times 10^{-8} $$\n\n**分支 $\\mathcal{B}_2$（现场篡改）：**\n该分支是 $E_5$ 和 $E_6$ 的交集。问题陈述了 $L_6$ 的发生以 $L_5$ 为条件。这证实了与逻辑，即分支的成功需要两个事件都发生。概率为 $P(\\mathcal{B}_2) = P(E_5 \\cap E_6) = P(E_6|E_5)P(E_5)$。在没有其他信息的情况下，所提供的概率 $p_6$ 被解释为与条件事件相关。因此，残余可能性 $\\mathcal{L}_6$ 代表 $P(E_6|E_5 \\text{ 尝试})$。假设只有在 $E_5$ 成功的情况下才会尝试 $E_6$，这导致 $P(\\mathcal{B}_2) = \\mathcal{L}_5 \\mathcal{L}_6$。\n$$ P(\\mathcal{B}_2) = \\mathcal{L}_5 \\mathcal{L}_6 = (4.0 \\times 10^{-4})(2.0 \\times 10^{-3}) = 8.0 \\times 10^{-7} $$\n\n**分支 $\\mathcal{B}_3$（Digital Twin 去同步）：**\n该分支是 $E_7$ 和 $E_8$ 的交集。这些事件是独立的。\n$$ P(\\mathcal{B}_3) = P(E_7 \\cap E_8) = \\mathcal{L}_7 \\mathcal{L}_8 = (2.25 \\times 10^{-4})(2.0 \\times 10^{-4}) = 4.5 \\times 10^{-8} $$\n\n**顶事件可能性：**\n现在我们合并三个主分支的概率。\n$P(\\mathcal{B}_1) = 7.99999985 \\times 10^{-8}$\n$P(\\mathcal{B}_2) = 8.0 \\times 10^{-7}$\n$P(\\mathcal{B}_3) = 4.5 \\times 10^{-8}$\n由于这些概率非常小，其并集的概率可以很好地通过它们的和来近似：\n$P(TE) \\approx P(\\mathcal{B}_1) + P(\\mathcal{B}_2) + P(\\mathcal{B}_3) \\approx (8.0 \\times 10^{-8}) + (8.0 \\times 10^{-7}) + (4.5 \\times 10^{-8}) = 9.25 \\times 10^{-7}$。\n为了更精确的计算，我们使用独立事件并集的公式：\n$$ P(TE) = 1 - (1 - P(\\mathcal{B}_1))(1 - P(\\mathcal{B}_2))(1 - P(\\mathcal{B}_3)) $$\n$$ P(TE) = 1 - (1 - 7.99999985 \\times 10^{-8})(1 - 8.0 \\times 10^{-7})(1 - 4.5 \\times 10^{-8}) $$\n$$ P(TE) = 1 - (0.9999999200000015)(0.9999992)(0.999999955) $$\n$$ P(TE) = 1 - 0.999999075000105... $$\n$$ P(TE) = 9.249998949... \\times 10^{-7} $$\n问题要求最终答案四舍五入至四位有效数字。$9.2499...$ 中的第四位有效数字是 $9$。其后的数字是 $9$，所以我们向上取整。\n$$ P(TE) \\approx 9.250 \\times 10^{-7} $$",
            "answer": "$$\\boxed{9.250 \\times 10^{-7}}$$"
        },
        {
            "introduction": "本练习介绍了一种前沿的、自动化的漏洞发现方法，即安全属性证伪。该方法不再局限于对已知攻击进行建模，而是主动搜索任何可能违反预定义安全规约（此处用信号时序逻辑 $STL$ 定义）的系统行为。通过解决这个问题 ，您将获得将寻找对抗性输入序列构建为一个优化问题的实践经验，从而具体地揭示系统被攻破的路径。",
            "id": "4248482",
            "problem": "一个由数字孪生监控的网络物理系统（CPS）执行基于残差的异常检测。该被控对象被建模为一个离散时间线性时不变系统，其状态更新和输出方程为 $x_{k+1} = A x_k + B u_k$ 和 $y_k = C x_k$，其中 $k$ 是离散时间索引，$x_k$、$u_k$、$y_k$ 分别是状态、控制和输出信号。数字孪生使用相同的已知模型，通过 $\\hat{x}_{k+1} = A \\hat{x}_k + B u_k$ 和 $\\hat{y}_k = C \\hat{x}_k$ 来预测输出 $\\hat{y}_k$，从而产生理想残差 $r_k = y_k - \\hat{y}_k$。一个攻击者在测量输出上注入了加性操纵 $a_k$，因此测量输出变为 $y_k^{m} = y_k + a_k$。数字孪生计算出的残差则为 $r_k = y_k^{m} - \\hat{y}_k$。所有信号都经过归一化且无量纲。\n\n一个安全属性在信号时序逻辑（STL）中被指定，要求残差必须保持有界：该属性是在有限时间域 $[0, T-1]$ 上的“总是”（always）算子，其谓词为 $\\varphi: |r_k| \\le \\gamma$。该 STL 公式为 $\\mathbf{G}_{[0, T-1]} \\varphi$，其在标准 STL 语义下的定量鲁棒性被定义为谓词裕度在时间上的最小值。具体来说，鲁棒性值 $\\rho$ 由“总是”算子的定量语义定义为\n$$\n\\rho = \\min_{k \\in \\{0, 1, \\dots, T-1\\}} \\big(\\gamma - |r_k|\\big).\n$$\n$\\rho$ 的负值表示属性被违反，其绝对值大小量化了违反的严重程度。\n\n攻击者在注入序列 $\\{a_k\\}_{k=0}^{T-1}$ 上受到两个界限的约束：\n- 振幅界限：对于所有 $k$，有 $|a_k| \\le a_{\\max}$。\n- 变化率界限：对于所有 $k \\in \\{0, 1, \\dots, T-2\\}$，有 $|a_{k+1} - a_k| \\le \\Delta_{\\max}$。\n\n初始注入值 $a_0$ 是给定的。假设数字孪生与被控对象完全匹配（两者的 $A$、$B$ 和 $C$ 相同），并且没有外部噪声或建模误差。\n\n任务：\n- 针对测试套件中的每一组参数，设计一个算法，在满足振幅和变化率界限的允许序列 $\\{a_k\\}$ 中进行搜索，以证伪该安全属性，即让 $\\rho$ 尽可能小（如果可能，使其更负）。构建一个在时间域内最小化鲁棒性值 $\\rho$ 的允许序列 $\\{a_k\\}$，并计算相应的 $\\rho$。\n- 您的实现必须是自包含的，并且必须产生确定性的结果。\n\n测试套件：\n- 所有信号都是无量纲的。不涉及角度。不涉及百分比。程序必须处理以下参数集：\n    - 情况 $1$：$T = 10$，$\\gamma = 0.5$，$a_{\\max} = 1.0$，$\\Delta_{\\max} = 0.1$，$a_0 = 0.0$。\n    - 情况 $2$：$T = 8$，$\\gamma = 1.5$，$a_{\\max} = 1.0$，$\\Delta_{\\max} = 0.05$，$a_0 = 0.0$。\n    - 情况 $3$：$T = 5$，$\\gamma = 0.3$，$a_{\\max} = 0.4$，$\\Delta_{\\max} = 0.2$，$a_0 = 0.0$。\n    - 情况 $4$：$T = 1$，$\\gamma = 0.2$，$a_{\\max} = 0.5$，$a_0 = 0.0$ 的情况下，$\\Delta_{\\max} = 0.3$。\n    - 情况 $5$：$T = 12$，$\\gamma = 0.0$，$a_{\\max} = 0.2$，$\\Delta_{\\max} = 0.05$，$a_0 = 0.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result1,result2,result3]$）。\n- 每个结果都必须是一个浮点数，等于上面所列顺序中对应情况的鲁棒性值 $\\rho$。",
            "solution": "目标是找到一个允许的攻击性注入序列 $\\{a_k\\}_{k=0}^{T-1}$，以最小化信号时序逻辑（STL）属性 $\\mathbf{G}_{[0, T-1]} \\varphi$ 的定量鲁棒性 $\\rho$，其中 $\\varphi$ 是谓词 $|r_k| \\le \\gamma$。鲁棒性定义为 $\\rho = \\min_{k \\in \\{0, 1, \\dots, T-1\\}} (\\gamma - |r_k|)$。\n\n首先，我们分析残差信号 $r_k$ 的构成。问题陈述，网络物理系统（被控对象）及其数字孪生具有相同的模型，并且没有建模误差或外部噪声。被控对象的状态更新和输出方程为 $x_{k+1} = A x_k + B u_k$ 和 $y_k = C x_k$。数字孪生的模型为 $\\hat{x}_{k+1} = A \\hat{x}_k + B u_k$ 和 $\\hat{y}_k = C \\hat{x}_k$。\n\n设状态估计误差为 $e_k = x_k - \\hat{x}_k$。该误差的动态特性由下式给出：\n$$\ne_{k+1} = x_{k+1} - \\hat{x}_{k+1} = (A x_k + B u_k) - (A \\hat{x}_k + B u_k) = A(x_k - \\hat{x}_k) = A e_k\n$$\n在此背景下，与“完全匹配”的陈述相一致的一个标准假设是，数字孪生使用被控对象的初始状态进行初始化，即 $\\hat{x}_0 = x_0$。这意味着初始误差为零：$e_0 = x_0 - \\hat{x}_0 = 0$。根据误差动态特性 $e_{k+1} = A e_k$，通过归纳法可得，对于所有离散时间步 $k \\ge 0$，$e_k = 0$。\n\n因此，在所有时间，被控对象的状态和数字孪生的状态都是相同的，$x_k = \\hat{x}_k$。这直接意味着它们各自的输出也是相同的：$y_k = C x_k = C \\hat{x}_k = \\hat{y}_k$。\n\n监控器计算的残差 $r_k$ 基于被操纵的传感器测量值 $y_k^m = y_k + a_k$。\n$$\nr_k = y_k^m - \\hat{y}_k = (y_k + a_k) - \\hat{y}_k\n$$\n将 $y_k = \\hat{y}_k$ 代入此表达式，可得：\n$$\nr_k = (\\hat{y}_k + a_k) - \\hat{y}_k = a_k\n$$\n这个关键的简化揭示了残差信号与攻击性注入信号是相同的。在所述的理想条件下，系统动态（矩阵 $A$、$B$、$C$）和控制输入 $u_k$ 不影响残差。\n\n当 $r_k = a_k$ 时，鲁棒性公式变为：\n$$\n\\rho = \\min_{k \\in \\{0, 1, \\dots, T-1\\}} (\\gamma - |a_k|)\n$$\n此表达式可重写为：\n$$\n\\rho = \\gamma - \\max_{k \\in \\{0, 1, \\dots, T-1\\}} |a_k|\n$$\n为了最小化鲁棒性 $\\rho$，攻击者必须解决在给定约束条件下最大化注入信号峰值幅度 $\\max_{k \\in \\{0, 1, \\dots, T-1\\}} |a_k|$ 的问题：\n$1$. 振幅界限：对所有 $k \\in \\{0, 1, \\dots, T-1\\}$，有 $|a_k| \\le a_{\\max}$。\n$2$. 变化率界限：对所有 $k \\in \\{0, 1, \\dots, T-2\\}$，有 $|a_{k+1} - a_k| \\le \\Delta_{\\max}$。\n$3$. 初始条件：$a_0$ 是给定的。\n\n攻击者的最优策略是尽快使信号的幅度 $|a_k|$ 远离零。这是一种贪心方法。从 $a_0$ 开始，通过在每一步加上或减去 $\\Delta_{\\max}$，直到达到振幅界限 $\\pm a_{\\max}$，可以实现 $a_k$ 的最大可能幅度。\n\n让我们确定在任意时间步 $k$ 时 $a_k$ 的最大可能幅度。$a_k$ 的值必须位于一个由初始值 $a_0$ 和累积变化率所约束的区间内。$a_k$ 能取到的最大正值为 $a_0 + k \\Delta_{\\max}$，并以振幅上限 $a_{\\max}$ 为界。类似地，能取到的最小负值为 $a_0 - k \\Delta_{\\max}$，并以 $-a_{\\max}$ 为下界。\n所以，$a_k$ 的最大可达值为 $\\min(a_0 + k \\Delta_{\\max}, a_{\\max})$，最小可达值为 $\\max(a_0 - k \\Delta_{\\max}, -a_{\\max})$。\n\n攻击者的目标是最大化 $\\max_k |a_k|$。整个时间域内的最大可能幅度是在所有 $k$ 上，每一步 $k$ 可达到的最极值的幅度的最大值。根据对称性，从初始值 $a_0$ 可获得的最大幅度与从 $-a_0$ 可获得的相同。因此，我们可以从 $|a_0|$ 开始分析问题。一个最优策略是始终朝着使其幅度远离 $0$ 的方向改变 $a_k$。$|a_k|$ 的值在每一步最多可以增加 $\\Delta_{\\max}$。\n从 $|a_0|$ 开始，在第 $k$ 步时 $|a_k|$ 的最大值受限于 $|a_0| + k\\Delta_{\\max}$。这个值也受限于 $a_{\\max}$。因此，$a_k$ 的最大可达幅度为 $\\min(|a_0| + k\\Delta_{\\max}, a_{\\max})$。\n\n这个函数 $\\min(|a_0| + k\\Delta_{\\max}, a_{\\max})$ 是关于时间索引 $k$ 的一个非递减函数。因此，它在时间域 $k \\in \\{0, 1, \\dots, T-1\\}$ 上的最大值将出现在最后的时间步，即 $k = T-1$。\n设 $|a|^*$ 为在时间域内可达到的最大幅度。\n$$\n|a|^* = \\max_{k \\in \\{0, \\dots, T-1\\}} \\min(|a_0| + k \\Delta_{\\max}, a_{\\max}) = \\min(|a_0| + (T-1) \\Delta_{\\max}, a_{\\max})\n$$\n请注意，对于 $T=1$ 的特殊情况，时间域仅为 $\\{0\\}$。该公式正确地给出 $|a|^* = \\min(|a_0| + 0 \\cdot \\Delta_{\\max}, a_{\\max}) = |a_0|$，因为 $|a_0| \\le a_{\\max}$ 是一个以 $a_0$ 开始的允许序列的隐含前提条件。\n\n然后，通过将这个最大幅度代回鲁棒性方程，可以找到最小鲁棒性值 $\\rho_{\\min}$：\n$$\n\\rho_{\\min} = \\gamma - |a|^* = \\gamma - \\min(|a_0| + (T-1) \\Delta_{\\max}, a_{\\max})\n$$\n这个公式为任何给定的参数集提供了解决方案。对于所有提供的测试用例，$a_0 = 0.0$。公式简化为：\n$$\n\\rho_{\\min} = \\gamma - \\min((T-1) \\Delta_{\\max}, a_{\\max})\n$$\n\n例如，对于情况 $1$：$T = 10$，$\\gamma = 0.5$，$a_{\\max} = 1.0$，$\\Delta_{\\max} = 0.1$，$a_0 = 0.0$。\n首先，计算最大可达攻击幅度：\n$$\n|a|^* = \\min((10-1) \\times 0.1, 1.0) = \\min(9 \\times 0.1, 1.0) = \\min(0.9, 1.0) = 0.9\n$$\n然后，计算最小鲁棒性：\n$$\n\\rho_{\\min} = 0.5 - 0.9 = -0.4\n$$\n对所有其他测试用例应用相同的过程，以推导出它们各自的最小鲁棒性值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the minimum robustness value for a series of test cases based on \n    a cyber-physical system security problem.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    # Each case is a tuple (T, gamma, a_max, delta_max, a_0).\n    test_cases = [\n        (10, 0.5, 1.0, 0.1, 0.0),  # Case 1\n        (8, 1.5, 1.0, 0.05, 0.0), # Case 2\n        (5, 0.3, 0.4, 0.2, 0.0),  # Case 3\n        (1, 0.2, 0.5, 0.3, 0.0),  # Case 4\n        (12, 0.0, 0.2, 0.05, 0.0)  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        T, gamma, a_max, delta_max, a_0 = case\n\n        # The problem defines the horizon as [0, T-1].\n        # The number of steps for the rate-of-change to accumulate is T-1.\n        # This holds for T >= 1. If T=1, num_steps is 0.\n        if T  1:\n            # Although not in test cases, handle this edge case for robustness.\n            # An empty horizon would have infinite robustness.\n            # A horizon of T1 is not well-defined in the problem context.\n            # Assuming T >= 1 as per the discrete time indices {0, ..., T-1}.\n            num_steps = 0\n        else:\n            num_steps = T - 1\n\n        # The core logic derived from the analysis is that the residual r_k equals\n        # the attack a_k due to the perfect model assumption.\n        # To minimize robustness rho = gamma - max_k(|a_k|), the adversary must\n        # construct a sequence {a_k} that maximizes its peak magnitude.\n\n        # The optimal strategy is a greedy one: ramp up |a_k| from |a_0| at the\n        # maximum rate delta_max, until the amplitude bound a_max is reached.\n        # The maximum magnitude is achieved at the end of the horizon, k = T-1.\n        \n        # Formula for the maximum achievable attack signal magnitude over the horizon:\n        # |a|* = min(|a_0| + (T-1)*delta_max, a_max)\n        max_achievable_a_mag = np.min([np.abs(a_0) + num_steps * delta_max, a_max])\n\n        # Formula for the minimal robustness value:\n        # rho_min = gamma - |a|*\n        rho_min = gamma - max_achievable_a_mag\n        \n        results.append(rho_min)\n\n    # Final print statement in the exact required format: a single line\n    # containing a comma-separated list of results enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在识别与分析威胁之后，下一步关键是进行主动的安全设计。本练习  聚焦于信息物理系统安全设计中的一个核心挑战：如何在增强安全性与保障系统运行性能之间取得平衡。通过将系统抽象为图模型，您将学习如何运用优化技术来做出明智的设计决策，从而在减小攻击面的同时，确保关键功能（如控制回路）的性能不受影响。",
            "id": "4248537",
            "problem": "给定一个使用图分割在控制性能约束下对信息物理系统（CPS）进行信任分区的形式化描述。考虑一个 CPS，其被建模为一个加权无向图 $G = (V, E)$，其中 $V$ 是组件（节点）的集合，$E$ 是双向通信链路（边）的集合。每条边 $(u, v) \\in E$ 都有一个非负权重 $w_{uv}$，表示单位时间内的平均流量，作为暴露风险的代理指标。一个信任分区是一个将节点分配到两个区域的映射 $z: V \\to \\{0, 1\\}$，且这两个区域必须非空，即存在节点 $u$ 和 $v$ 使得 $z(u) = 0$ 和 $z(v) = 1$。目标是在保持控制性能的同时，最小化跨区流量。\n\n定义一个分配方案 $z$ 的跨区流量（切割权重）为\n$$\nW(z) = \\sum_{(u, v) \\in E} w_{uv} \\cdot \\mathbf{1}\\big[z(u) \\neq z(v)\\big],\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。控制性能由一组闭环控制路径建模。每条路径 $p$ 是一个简单环，由一个有序的、不重复的节点列表 $[v_0, v_1, \\dots, v_{m-1}]$ 表示，这意味着一个包含边 $(v_i, v_{i+1})$（对于 $i = 0, \\dots, m-2$）和边 $(v_{m-1}, v_0)$ 的环路。由于安全中介的存在，每次穿越信任区边界会引入 $d_z$ 秒的额外延迟惩罚。每条控制路径 $p$ 都有一个最大允许附加延迟 $L_p^{\\max}$ 秒。对于一个分区方案 $z$，路径 $p$ 上的区域边界穿越次数为\n$$\nC_p(z) = \\sum_{i=0}^{m-1} \\mathbf{1}\\big[z(v_i) \\neq z(v_{(i+1) \\bmod m})\\big].\n$$\n每条路径 $p$ 的控制性能约束为\n$$\nC_p(z) \\le \\left\\lfloor \\frac{L_p^{\\max}}{d_z} \\right\\rfloor,\n$$\n其中 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数。\n\n定义基线暴露面 $S_{\\text{base}}$ 为所有边的权重之和，\n$$\nS_{\\text{base}} = \\sum_{(u, v) \\in E} w_{uv}.\n$$\n在一个分区方案 $z$ 下，分区后的暴露面是切割权重 $S_{\\text{cut}} = W(z)$。暴露面的减少量被量化为分数缩减率\n$$\n\\rho = \\frac{S_{\\text{base}} - S_{\\text{cut}}}{S_{\\text{base}}},\n$$\n表示为一个四舍五入到四位小数的小数。如果没有非平凡（即两个区域都非空）的分区方案满足约束条件，则报告最小化跨区流量为 $-1$，缩减分数为 $-1.0$。\n\n您的任务是实现一个程序，对于下面的每个测试用例，枚举所有非平凡的双区分配方案 $z: V \\to \\{0, 1\\}$，检查每条控制路径的控制性能约束，并找到在约束条件下使 $W(z)$ 最小化的分配方案。通过将一个节点固定在区域 0 中来使用穷举枚举，以避免重复的标签（这减少了对称性）。报告最优有效分配方案 $z^\\star$ 的最小化跨区流量 $W(z^\\star)$ 和缩减分数 $\\rho$。如果没有两个区域都非空的有效分配方案，则该测试用例输出 $-1$ 和 $-1.0$。\n\n所有延迟都必须以秒为单位处理。所有缩减分数都必须是四舍五入到四位小数的小数。\n\n测试套件：\n- 测试用例 1：\n  - 节点：$V = \\{0, 1, 2, 3, 4\\}$。\n  - 带权重的边：$(0,1)$ 权重为 $w_{01} = 5$，$(1,2)$ 权重为 $w_{12} = 4$，$(2,3)$ 权重为 $w_{23} = 3$，$(3,0)$ 权重为 $w_{30} = 2$，$(1,3)$ 权重为 $w_{13} = 1$，$(2,4)$ 权重为 $w_{24} = 2$，$(0,4)$ 权重为 $w_{04} = 1$。\n  - 单个控制路径：$p_1 = [0, 1, 2, 3]$。\n  - 每次穿越的延迟惩罚：$d_z = 0.02$ 秒。\n  - 最大允许附加延迟：$L_{p_1}^{\\max} = 0.06$ 秒。\n- 测试用例 2（边界条件，只允许一次穿越）：\n  - 节点：$V = \\{0, 1, 2, 3\\}$。\n  - 带权重的边：$(0,1)$ 权重为 $w_{01} = 6$，$(1,2)$ 权重为 $w_{12} = 2$，$(2,3)$ 权重为 $w_{23} = 2$，$(3,0)$ 权重为 $w_{30} = 2$，$(0,2)$ 权重为 $w_{02} = 1$。\n  - 单个控制路径：$p_1 = [0, 1, 2, 3]$。\n  - 每次穿越的延迟惩罚：$d_z = 0.05$ 秒。\n  - 最大允许附加延迟：$L_{p_1}^{\\max} = 0.05$ 秒。\n- 测试用例 3（具有不同预算的多个控制回路）：\n  - 节点：$V = \\{0, 1, 2, 3, 4\\}$。\n  - 带权重的边：$(0,1)$ 权重为 $w_{01} = 3$，$(1,2)$ 权重为 $w_{12} = 3$，$(2,0)$ 权重为 $w_{20} = 3$，$(2,3)$ 权重为 $w_{23} = 4$，$(3,4)$ 权重为 $w_{34} = 1$，$(4,2)$ 权重为 $w_{42} = 2$，$(1,3)$ 权重为 $w_{13} = 2$。\n  - 两个控制路径：$p_1 = [0, 1, 2]$，$p_2 = [2, 3, 4]$。\n  - 每次穿越的延迟惩罚：$d_z = 0.01$ 秒。\n  - 最大允许附加延迟：$L_{p_1}^{\\max} = 0.02$ 秒，$L_{p_2}^{\\max} = 0.01$ 秒。\n- 测试用例 4（边缘情况，约束可能使非平凡分区不可行）：\n  - 节点：$V = \\{0, 1, 2, 3\\}$。\n  - 带权重的边：$(0,1)$ 权重为 $w_{01} = 7$，$(1,2)$ 权重为 $w_{12} = 7$，$(2,3)$ 权重为 $w_{23} = 7$，$(3,0)$ 权重为 $w_{30} = 7$，$(0,2)$ 权重为 $w_{02} = 1$，$(1,3)$ 权重为 $w_{13} = 1$。\n  - 单个控制路径：$p_1 = [0, 1, 2, 3]$。\n  - 每次穿越的延迟惩罚：$d_z = 0.03$ 秒。\n  - 最大允许附加延迟：$L_{p_1}^{\\max} = 0.00$ 秒。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个双元素列表 $[W(z^\\star), \\rho]$，其中缩减分数四舍五入到四位小数。例如，总体输出应类似于 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$，其中每个 $a_i$ 是一个整数，每个 $b_i$ 是一个保留四位小数的小数。",
            "solution": "该问题要求我们为一个建模为加权无向图 $G = (V, E)$ 的信息物理系统（CPS）找到一个最优的信任分区。优化目标是将节点集 $V$ 划分为两个非空区域 $\\{0, 1\\}$，使得连接不同区域中节点的边的总权重（即切割权重 $W(z)$）最小化。此最小化过程受一组控制性能约束的限制，这些约束限制了任何指定的控制路径可以穿越区域边界的次数。\n\n该任务是一个带约束的图分割问题，是最小割问题的一个变体。鉴于每个测试用例中的节点数量很少（例如，$|V| \\le 5$），可以通过系统地枚举和评估所有可能的分区来找到精确解。\n\n总体方法如下：\n1.  **枚举分区**：我们必须考虑节点集 $V$ 的所有非平凡二分划。一个二分划是一个分配方案 $z: V \\to \\{0, 1\\}$，其中两个区域集合 $V_0 = \\{v \\in V | z(v) = 0\\}$ 和 $V_1 = \\{v \\in V | z(v) = 1\\}$ 都非空。总分配方案数为 $2^{|V|}$。其中，有两种是平凡的（所有节点都在一个区域）。剩下的 $2^{|V|} - 2$ 个分配方案构成了 $(2^{|V|} - 2) / 2 = 2^{|V|-1} - 1$ 个唯一的非平凡分区，因为交换区域标签 $0$ 和 $1$ 会得到相同的分区。为了系统地、不重复地枚举这些唯一分区，我们可以固定一个节点的区域。让我们将节点 $0$ 固定在区域 $0$ 中，即 $z(0)=0$。然后我们遍历其余 $|V|-1$ 个节点的所有可能分配。这将产生 $2^{|V|-1}$ 种分配。所有其他节点也分配给区域 $0$ 的情况对应于一个平凡分区，因此被排除。这样剩下 $2^{|V|-1} - 1$ 个非平凡分区需要检查，覆盖了整个搜索空间。\n\n2.  **验证约束**：对于 $2^{|V|-1} - 1$ 个候选分区中的每一个，我们都必须验证它是否满足所有控制性能约束。对于每条控制路径 $p$，问题根据延迟预算定义了最大允许边界穿越次数 $C_p^{\\max}$：\n    $$C_p^{\\max} = \\left\\lfloor \\frac{L_p^{\\max}}{d_z} \\right\\rfloor$$\n    对于给定的分区 $z$，我们计算路径 $p = [v_0, v_1, \\dots, v_{m-1}]$ 的实际穿越次数：\n    $$C_p(z) = \\sum_{i=0}^{m-1} \\mathbf{1}\\big[z(v_i) \\neq z(v_{(i+1) \\bmod m})\\big]$$\n    如果对于任何路径 $p$ 有 $C_p(z)  C_p^{\\max}$，则分区 $z$ 无效并被丢弃。一个已知的性质是，简单环在分区平面上的穿越次数必须是偶数。这可以进一步修剪搜索或简化约束；例如，约束 $C_p(z) \\le 1$ 等价于 $C_p(z) = 0$。\n\n3.  **评估目标函数**：如果一个分区 $z$ 是有效的（满足所有约束），我们计算其成本，即跨区流量或切割权重 $W(z)$：\n    $$W(z) = \\sum_{(u, v) \\in E} w_{uv} \\cdot \\mathbf{1}\\big[z(u) \\neq z(v)\\big]$$\n    这是所有连接区域 $0$ 中的节点和区域 $1$ 中的节点的边的权重之和。\n\n4.  **寻找最优解**：我们维护一个初始化为无穷大的变量 $W_{min}$，用于存储在有效分区中迄今找到的最小切割权重。每当找到一个有效分区 $z$ 时，就将其切割权重 $W(z)$ 与 $W_{min}$ 进行比较，如果 $W(z)$ 更小，则更新 $W_{min}$。\n\n5.  **计算最终指标**：在遍历所有分区后，如果没有找到有效分区，我们按照问题规范报告 $W(z^\\star) = -1$ 和 $\\rho = -1.0$。否则，最终的最小化切割权重为 $W(z^\\star) = W_{min}$。然后计算暴露面的分数缩减率 $\\rho$。首先，基线暴露面 $S_{\\text{base}}$ 是图中所有边的权重之和。\n    $$S_{\\text{base}} = \\sum_{(u, v) \\in E} w_{uv}$$\n    缩减分数则为：\n    $$\\rho = \\frac{S_{\\text{base}} - W(z^\\star)}{S_{\\text{base}}}$$\n    该值四舍五入到四位小数。这种穷举搜索保证能找到满足所有指定约束的全局最小切割权重。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the given test cases for constrained graph partitioning.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": 5, \"edges\": [(0, 1, 5), (1, 2, 4), (2, 3, 3), (3, 0, 2), (1, 3, 1), (2, 4, 2), (0, 4, 1)],\n            \"paths\": [[0, 1, 2, 3]], \"dz\": 0.02, \"Lmax\": [0.06]\n        },\n        {\n            \"nodes\": 4, \"edges\": [(0, 1, 6), (1, 2, 2), (2, 3, 2), (3, 0, 2), (0, 2, 1)],\n            \"paths\": [[0, 1, 2, 3]], \"dz\": 0.05, \"Lmax\": [0.05]\n        },\n        {\n            \"nodes\": 5, \"edges\": [(0, 1, 3), (1, 2, 3), (2, 0, 3), (2, 3, 4), (3, 4, 1), (4, 2, 2), (1, 3, 2)],\n            \"paths\": [[0, 1, 2], [2, 3, 4]], \"dz\": 0.01, \"Lmax\": [0.02, 0.01]\n        },\n        {\n            \"nodes\": 4, \"edges\": [(0, 1, 7), (1, 2, 7), (2, 3, 7), (3, 0, 7), (0, 2, 1), (1, 3, 1)],\n            \"paths\": [[0, 1, 2, 3]], \"dz\": 0.03, \"Lmax\": [0.00]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(solve_case(case))\n\n    # Manually building the string to match the exact format '[[a,b],[c,d]]' without spaces.\n    results_str_parts = []\n    for res in results:\n        # Handle float formatting for specific case of -1.0\n        if res[1] == -1.0:\n            rho_str = \"-1.0\"\n        else:\n            rho_str = str(res[1])\n        results_str_parts.append(f\"[{res[0]},{rho_str}]\")\n\n    final_output_str = f\"[{','.join(results_str_parts)}]\"\n    print(final_output_str)\n\n\ndef solve_case(case_data):\n    \"\"\"\n    Solves a single test case of the trust zoning problem.\n    \"\"\"\n    N = case_data[\"nodes\"]\n    edges = case_data[\"edges\"]\n    paths = case_data[\"paths\"]\n    dz = case_data[\"dz\"]\n    Lmax_list = case_data[\"Lmax\"]\n    \n    # 1. Pre-calculations\n    # Adjacency matrix for weights for O(1) weight lookup\n    weights = np.zeros((N, N))\n    s_base = 0\n    for u, v, w in edges:\n        weights[u, v] = w\n        weights[v, u] = w\n        s_base += w\n        \n    # Maximum allowed crossings for each path\n    max_crossings_per_path = [math.floor(Lmax / dz) for Lmax in Lmax_list]\n\n    # 2. Iterate through partitions\n    min_cut_weight = float('inf')\n    found_valid_partition = False\n\n    # Iterate through all 2^(N-1) - 1 non-trivial partitions\n    # by fixing node 0 in zone 0 and assigning other nodes.\n    # The range start at 1 excludes the trivial case where all nodes are in zone 0.\n    for i in range(1, 1  (N - 1)):\n        # Create zone assignment array 'z'\n        # z[k] = 0 or 1, representing the zone of node k\n        z = np.zeros(N, dtype=int)\n        # Node 0 is fixed in zone 0.\n        # Other nodes' assignments are determined by bits of 'i'.\n        for j in range(1, N):\n            if (i >> (j - 1))  1:\n                z[j] = 1\n\n        # 3. Check validity of the partition\n        is_valid = True\n        for path_idx, path in enumerate(paths):\n            path_crossings = 0\n            for k in range(len(path)):\n                u = path[k]\n                v = path[(k + 1) % len(path)]\n                if z[u] != z[v]:\n                    path_crossings += 1\n            \n            if path_crossings > max_crossings_per_path[path_idx]:\n                is_valid = False\n                break\n        \n        if not is_valid:\n            continue\n\n        # If we reach here, the partition is valid.\n        found_valid_partition = True\n        \n        # 4. Calculate cut weight for the valid partition\n        current_cut_weight = 0\n        for u in range(N):\n            for v in range(u + 1, N):\n                if weights[u, v] > 0 and z[u] != z[v]:\n                    current_cut_weight += weights[u, v]\n\n        min_cut_weight = min(min_cut_weight, current_cut_weight)\n\n    # 5. Format and return result\n    if not found_valid_partition:\n        return [-1, -1.0]\n    else:\n        if s_base == 0:\n            rho = 0.0\n        else:\n            rho = (s_base - min_cut_weight) / s_base\n        return [int(min_cut_weight), round(rho, 4)]\n\nsolve()\n```"
        }
    ]
}