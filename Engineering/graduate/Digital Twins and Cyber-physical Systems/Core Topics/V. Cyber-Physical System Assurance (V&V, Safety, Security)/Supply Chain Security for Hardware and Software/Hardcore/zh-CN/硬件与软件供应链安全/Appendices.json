{
    "hands_on_practices": [
        {
            "introduction": "本练习探讨了软件供应链安全中的一个基本实践：强制性代码审查。我们将使用基础概率论为这项控制措施的有效性建立一个量化模型。通过这个练习，你将理解冗余、独立的检查如何增强开发流程的整体安全性()。",
            "id": "4248745",
            "problem": "一家网络物理系统的制造商维护其软件构建和部署流水线的数字孪生，以监控硬件和软件供应链中的完整性违规行为。构建脚本被视为关键的控制工件。该组织规定，每一次构建脚本的变更都必须由 $r$ 位不同的审阅者进行代码审查。由于培训、工具支持和职责分离（SoD），每位审阅者独立检测到恶意修改的概率为 $q$。请仅使用概率公理、补集法则和独立性定义，推导在一个审查周期内至少有一位审阅者检测到恶意变更的概率 $P_{\\text{detect}}$ 的解析表达式。然后，对 $q = 0.37$ 和 $r = 5$ 的情况计算该表达式的值。将您的数值答案四舍五入至四位有效数字，并以小数形式表示，不带百分号。",
            "solution": "用户提供了一个需要解决的问题。我将首先验证问题陈述。\n\n### 步骤1：提取已知条件\n- 独立审阅者的数量为 $r$。\n- 每位审阅者独立检测到恶意修改的概率为 $q$。\n- 目标是推导至少有一位审阅者检测到恶意变更的概率 $P_{\\text{detect}}$ 的解析表达式。\n- 推导过程必须仅使用概率公理、补集法则和独立性定义。\n- 该表达式需要针对 $q = 0.37$ 和 $r = 5$ 进行求值。\n- 最终的数值答案必须四舍五入至四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行验证。\n\n- **科学性**：该问题是基础概率论的标准应用。供应链安全、代码审查和基于审阅者的检测等背景，在网络安全和软件工程领域是现实且成熟的概念。该问题没有违反任何科学或数学原理。它是科学合理的。\n- **适定性**：问题陈述清晰，提供了所有必要的变量（$r$、$q$）和约束条件（使用特定的推导路径），以得出唯一解。目标明确无歧义。\n- **客观性**：语言精确，没有主观或基于意见的论断。所有术语都在概率论的框架内定义。\n\n### 步骤3：结论与行动\n该问题是适定的、科学合理的且客观的。因此判定为**有效**。我将继续进行解答。\n\n问题要求推导至少有一位审阅者检测到恶意变更的概率 $P_{\\text{detect}}$。让我们为分析定义事件。设 $D_i$ 为审阅者 $i$ 检测到恶意变更的事件，其中 $i \\in \\{1, 2, \\dots, r\\}$。\n\n根据问题陈述，我们已知任何单个审阅者检测到变更的概率为 $q$。\n$$\nP(D_i) = q \\quad \\forall i \\in \\{1, 2, \\dots, r\\}\n$$\n问题还指出，审阅者的检测是独立事件。\n\n至少有一位审阅者检测到变更的事件是各个独立检测事件的并集：\n$$\nE_{\\text{detect}} = D_1 \\cup D_2 \\cup \\dots \\cup D_r\n$$\n我们所求的概率是 $P_{\\text{detect}} = P(E_{\\text{detect}})$。\n\n问题明确指示使用补集法则。我们定义补集事件 $E_{\\text{detect}}^c$，即*没有*审阅者检测到恶意变更的事件。根据概率公理，一个事件及其补集事件的概率之和为 $1$。\n$$\nP(E_{\\text{detect}}) = 1 - P(E_{\\text{detect}}^c)\n$$\n事件 $E_{\\text{detect}}^c$ 发生当且仅当审阅者1未检测到变更，且审阅者2未检测到变更，...，且审阅者r未检测到变更。这可以写成每个独立检测事件的补集 $D_i^c$ 的交集。\n$$\nE_{\\text{detect}}^c = D_1^c \\cap D_2^c \\cap \\dots \\cap D_r^c\n$$\n对每个独立事件 $D_i$ 使用补集法则，审阅者 $i$ *未*检测到变更的概率是：\n$$\nP(D_i^c) = 1 - P(D_i) = 1 - q\n$$\n由于事件 $D_i$ 被规定为独立的，它们的补集 $D_i^c$ 也是独立的。根据多个事件独立性的定义，它们交集的概率是它们各自概率的乘积：\n$$\nP(E_{\\text{detect}}^c) = P(D_1^c \\cap D_2^c \\cap \\dots \\cap D_r^c) = P(D_1^c) \\times P(D_2^c) \\times \\dots \\times P(D_r^c)\n$$\n将乘积中的 $r$ 个项都替换为 $P(D_i^c) = 1 - q$，我们得到：\n$$\nP(E_{\\text{detect}}^c) = (1 - q) \\times (1 - q) \\times \\dots \\times (1 - q) \\quad (r \\text{ 次})\n$$\n$$\nP(E_{\\text{detect}}^c) = (1 - q)^r\n$$\n现在，我们将此结果代回 $P_{\\text{detect}}$ 的表达式中：\n$$\nP_{\\text{detect}} = 1 - P(E_{\\text{detect}}^c) = 1 - (1 - q)^r\n$$\n这就是至少有一位审阅者检测到恶意变更的概率所需的解析表达式。\n\n接下来，我们必须用给定的值 $q = 0.37$ 和 $r = 5$ 来计算这个表达式。\n$$\nP_{\\text{detect}} = 1 - (1 - 0.37)^5\n$$\n首先，计算指数的底数：\n$$\n1 - 0.37 = 0.63\n$$\n现在，将这个值代回表达式中：\n$$\nP_{\\text{detect}} = 1 - (0.63)^5\n$$\n我们计算 $(0.63)^5$ 的值：\n$$\n(0.63)^5 = 0.63 \\times 0.63 \\times 0.63 \\times 0.63 \\times 0.63 \\approx 0.0992436543\n$$\n最后，我们计算 $P_{\\text{detect}}$：\n$$\nP_{\\text{detect}} = 1 - 0.0992436543 = 0.9007563457\n$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $9$、$0$、$0$ 和 $7$。第五位有效数字是 $5$，因此需要将第四位数字向上取整。\n$$\nP_{\\text{detect}} \\approx 0.9008\n$$",
            "answer": "$$\\boxed{0.9008}$$"
        },
        {
            "introduction": "从流程控制转向系统架构，这个问题研究了如何设计一个具有弹性的安全启动链。你将运用拜占庭容错原理，来确定为抵御单个受损组件所需的最少冗余度。这个练习展示了如何构建不仅在正常条件下安全，而且在供应链某一部分失效时仍能保持安全的系统()。",
            "id": "4248767",
            "problem": "一个信息物理系统实现了一个安全的多阶段引导链，以减轻针对硬件和软件的供应链威胁。设存在 $L$ 个顺序引导阶段，索引为 $i \\in \\{0,1,\\dots,L-1\\}$，其中阶段 $i$ 验证阶段 $i+1$ 并将控制权转移给它。为了降低供应链中单个被攻破的阶段颠覆整个引导链的风险，系统设计者为每个阶段的切换配置了 $N$ 个独立的验证步骤，每个步骤都锚定在一个不相交的信任根中（例如，一个不可变的硬件信任根、一个离散的安全协处理器，以及一个验证测量值的远程数字孪生证明服务）。每个验证步骤独立地对阶段 $i+1$ 的候选镜像返回接受或拒绝的决定。一个固定的接受策略控制着切换：当且仅当 $N$ 个独立验证步骤中至少有 $K$ 个返回接受时，切换才会继续。\n\n对手模型：在整个链中，在制造或集成过程中最多只有一个阶段可能被攻破。一个被攻破的阶段在验证方面表现为拜占庭行为，意味着它可以任意尝试强行接受一个恶意镜像或拒绝一个合法镜像。除非与被攻破的阶段共存，否则所有独立的验证步骤都保持诚实；独立性意味着诚实的验证步骤不与任何其他步骤共享密钥、代码或测量根，并且除非被直接攻破，否则不会被诱导接受恶意代码。诚实的验证步骤总是拒绝恶意镜像，总是接受合法镜像。从一个阶段到独立验证器的通信是经过认证的，因此一个诚实的验证器看到的是实际提供的镜像；通过设计，检查时到使用时（time-of-check to time-of-use）的竞争条件得到了缓解。\n\n将安全性定义为在任何切换中，任何恶意镜像都不会被接受的属性。将活性定义为在最多只有一个阶段被攻破的情况下，合法镜像在任何切换中都不会被拒绝的属性。将每个切换建模为一个具有 $N$ 中取 $K$ 接受规则的并行验证子系统。使用第一性原理的容错推理和串并联系统的最小割集分析，推导出最小的 $N$，使得存在某个 $K$，能够保证针对所述对手的安全性和活性。假设在每次切换中都使用相同的 $N$ 和 $K$。提供所需的最小整数 $N_{\\min}$ 作为最终答案。不需要四舍五入，也不需要单位。",
            "solution": "问题要求在安全引导链的每个阶段所需的最少独立验证步骤数 $N$，以在特定的对手模型下保证安全性和活性，前提是切换接受策略要求 $N$ 个验证中至少有 $K$ 个通过。\n\n首先，我们根据问题陈述将系统模型和约束形式化。\n设存在 $L$ 个引导阶段，索引为 $i \\in \\{0, 1, \\dots, L-1\\}$。从阶段 $i$到阶段 $i+1$ 的切换由 $N$ 个独立的验证步骤保护。当且仅当“接受”决定的数量至少为 $K$ 时，切换才成功。\n\n对手模型指出，在整个链中最多只有一个阶段可能被攻破。一个被攻破的阶段是拜占庭式的，意味着它可以采取任意行动来颠覆系统的目标。诚实的验证步骤是绝对可靠的：它们总是接受合法镜像，并总是拒绝恶意镜像。被攻破阶段与验证过程之间的关键联系在于这句话：“除非与被攻破的阶段共存，否则所有独立的验证步骤都保持诚实。”这意味着，在最坏的情况下，一个阶段的被攻破可能导致与该阶段切换过程相关的验证器被攻破。问题中对“不相交的信任根”和“独立性”的强调表明，单个被攻破的阶段不会攻破所有 $N$ 个验证器。在容错建模中，一个合理且标准的解释是，单个故障组件（被攻破的阶段）可以在验证子系统中引起有限数量的故障。与对手是“最多一个”实体相一致的最直接解释是，单个阶段的被攻破最多可以损坏其控制的切换中的 $N$ 个验证步骤之一。设 $f$ 为在任何给定切换中拜占庭验证器的最大数量。根据这个解释，我们有 $f=1$。\n\n现在我们使用 $f=1$ 的模型来分析保证安全性和活性所需的条件。\n\n安全性要求：绝不接受任何恶意镜像。\n阶段 $i+1$ 的恶意镜像只能由被攻破的阶段 $i$ 引入。这是攻击者的行为。为了实现其让恶意镜像被接受的目标，攻击者将使用任何被攻破的验证器投票“接受”。在我们的模型中，攻击者控制 $f=1$ 个验证器。这个拜占庭验证器将投票“接受”。剩下的 $N-1$ 个验证器是诚实的。当面对恶意镜像时，它们都会正确地投票“拒绝”。\n因此，恶意镜像得到的“接受”票总数为 $1$。\n接受策略是 `(接受票数) >= K`。\n要使恶意镜像被接受，需要满足 $1 \\ge K$。\n为了保证安全性，我们必须确保恶意镜像总是被拒绝。这意味着接受条件必须失败。因此，我们必须强制执行条件 $1  K$。由于 $K$ 必须是整数，这等价于：\n$$K \\ge 2$$\n\n活性要求：在最多只有一个阶段被攻破的情况下，合法镜像不被拒绝。\n对手的目标现在是通过导致合法镜像被拒绝来阻塞引导过程。活性的最坏情况发生在被攻破的阶段试图干扰合法镜像的验证时。这可能是阶段 $i$ 被攻破并干扰了对阶段 $i+1$ 合法镜像的验证。被攻破的阶段将使用其控制的验证器投票“拒绝”，尽管镜像是合法的。\n攻击者控制 $f=1$ 个验证器，并使其投票“拒绝”。\n剩下的 $N-1$ 个验证器是诚实的。当面对合法镜像时，它们都会正确地投票“接受”。\n因此，合法镜像得到的“接受”票总数为 $N-1$。\n接受策略是 `(接受票数) >= K`。\n为了保证活性，合法镜像必须被接受。这意味着接受条件必须满足。因此，我们必须强制执行条件：\n$$N-1 \\ge K$$\n\n结合 $N$ 和 $K$ 的条件：\n为了使系统既安全又具有活性，必须存在一个整数 $K$ 同时满足两个推导出的不等式：\n1. 来自安全性：$K \\ge 2$\n2. 来自活性：$K \\le N-1$\n\n结合这些，我们得到复合不等式：\n$$2 \\le K \\le N-1$$\n为了使 $K$ 存在一个有效的整数解，下界必须小于或等于上界。这给了我们关于 $N$ 的必要条件：\n$$2 \\le N-1$$\n解这个关于 $N$ 的不等式：\n$$N \\ge 3$$\n\n问题要求 $N$ 的最小整数值，我们记为 $N_{\\min}$。根据不等式 $N \\ge 3$，最小整数值为 $3$。\n因此，$N_{\\min} = 3$。\n\n当 $N=3$时，我们可以选择 $K=2$。让我们验证这个选择：\n- 安全性：一个恶意镜像从拜占庭验证器那里得到 $1$ 票“接受”。接受的条件是票数 $\\ge K=2$。由于 $1  2$，镜像被拒绝。安全性成立。\n- 活性：一个合法镜像得到 $N-1 = 3-1 = 2$ 票“接受”。接受的条件是票数 $\\ge K=2$。由于 $2 \\ge 2$，镜像被接受。活性成立。\n\n如果 $N  3$，则不存在这样的 $K$。例如，如果 $N=2$，条件将是 $K \\ge 2$ 和 $K \\le 2-1 = 1$。任何整数 $K$ 都不可能同时满足 $K \\ge 2$ 和 $K \\le 1$。因此，$N=3$ 确实是所需的最少验证步骤数。这个结果，即对于 $f$ 个拜占庭故障需要 $N \\ge 2f+1$，是带认证消息的容错系统中的一个基本原则。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "现实世界中的供应链安全涉及在预算限制下做出战略决策。这个问题将审计选择构建为一个优化任务，要求你找到最具成本效益的方式，将整体系统风险降低到目标阈值以下。通过解决这个问题，你将学会如何将经济学原理应用于安全投资，这是管理复杂供应链的一项关键技能()。",
            "id": "4248734",
            "problem": "一家信息物理系统（CPS）的制造商运营一个数字孪生，该数字孪生持续量化一组软件和硬件依赖项的供应链安全风险。对于每个依赖项 $i \\in \\{1,2,3,4,5,6\\}$，数字孪生估算出其年度预期风险贡献 $r_i$（单位：百万美元），以及一个审计有效性 $a_i \\in [0,1]$，该有效性代表了如果对该依赖项进行审计所能消除的风险比例。审计依赖项 $i$ 会产生一笔审计成本 $c_i$（单位：千美元）。\n\n假设在各依赖项的故障模式相互独立的条件下，预期损失是可加的。如果一个依赖项 $i$ 被审计，其剩余风险贡献变为 $(1 - a_i) r_i$；如果不被审计，其剩余风险仍为 $r_i$。所有依赖项的总剩余年度预期风险必须降低到一个阈值 $\\epsilon$（单位：百万美元）以下。\n\n给定以下参数：\n- $r_1 = 2.5$, $r_2 = 1.8$, $r_3 = 3.0$, $r_4 = 0.9$, $r_5 = 2.2$, $r_6 = 1.6$,\n- $a_1 = 0.6$, $a_2 = 0.4$, $a_3 = 0.5$, $a_4 = 0.7$, $a_5 = 0.3$, $a_6 = 0.8$,\n- $c_1 = 120$, $c_2 = 80$, $c_3 = 140$, $c_4 = 60$, $c_5 = 100$, $c_6 = 130$,\n- $\\epsilon = 6.5$,\n\n请从基本原理出发，构建一个成本最小化的审计选择方案，使得数字孪生建模的剩余年度预期风险严格小于 $\\epsilon$。将每个审计决策视为二元决策。计算达到该阈值所需的最低总审计成本（单位：千美元）。最终答案以千美元为单位，表示为一个精确的整数，无需四舍五入。在你的推理过程中，也请指明哪些依赖项被审计，但在最终的数值答案中只报告最低总审计成本。",
            "solution": "本题旨在确定将总剩余年度预期风险降低到严格小于给定阈值所需支付的最低总审计成本。这是一个经典的优化问题，可以建模为0/1背包问题的一个变种。\n\n首先，我们将问题形式化。设 $i \\in \\{1, 2, 3, 4, 5, 6\\}$ 为每个依赖项的索引。我们为每个依赖项引入一组二元决策变量 $x_i$：\n$$\nx_i = \\begin{cases} 1  \\text{如果依赖项 } i \\text{ 被审计} \\\\ 0  \\text{如果依赖项 } i \\text{ 未被审计} \\end{cases}\n$$\n审计的总成本 $C_{total}$ 是所选审计项目成本的总和。这是我们要最小化的目标函数：\n$$\n\\text{最小化 } C_{total} = \\sum_{i=1}^{6} c_i x_i\n$$\n其中 $c_i$ 是审计依赖项 $i$ 的成本。\n\n在没有任何审计的情况下，初始总风险是各项风险贡献之和：\n$$\nR_{initial} = \\sum_{i=1}^{6} r_i\n$$\n在做出决策后，依赖项 $i$ 的风险贡献在未审计时 ($x_i=0$) 为 $r_i$，在审计时 ($x_i=1$) 为 $(1-a_i)r_i$。这可以写作 $r_i - x_i a_i r_i$。总剩余风险 $R_{final}$ 是所有依赖项这些贡献的总和：\n$$\nR_{final} = \\sum_{i=1}^{6} (r_i - x_i a_i r_i) = \\left(\\sum_{i=1}^{6} r_i\\right) - \\left(\\sum_{i=1}^{6} x_i a_i r_i\\right) = R_{initial} - \\sum_{i=1}^{6} x_i a_i r_i\n$$\n问题陈述了总剩余风险必须严格小于阈值 $\\epsilon$ 的约束条件：\n$$\nR_{final}  \\epsilon\n$$\n代入 $R_{final}$ 的表达式：\n$$\nR_{initial} - \\sum_{i=1}^{6} x_i a_i r_i  \\epsilon\n$$\n重新整理这个不等式，我们得到关于总风险降低量的约束条件。设 $\\Delta R_{total} = \\sum_{i=1}^{6} x_i a_i r_i$ 为所选审计实现的总风险降低量。约束条件是：\n$$\n\\Delta R_{total} > R_{initial} - \\epsilon\n$$\n让我们计算初始风险和所需降低量的数值。风险值 $r_i$ 和阈值 $\\epsilon$ 的单位是百万美元。\n$r = [2.5, 1.8, 3.0, 0.9, 2.2, 1.6]$\n$$\nR_{initial} = 2.5 + 1.8 + 3.0 + 0.9 + 2.2 + 1.6 = 12.0 \\text{ 百万美元}\n$$\n给定 $\\epsilon = 6.5$ 百万美元，所需的总风险降低量为：\n$$\n\\Delta R_{required} > 12.0 - 6.5 = 5.5 \\text{ 百万美元}\n$$\n问题是选择一组审计（$x_i$ 的值），以最小化总成本 $\\sum c_i x_i$，同时满足 $\\sum x_i a_i r_i > 5.5$。这是一个0/1背包类问题，即我们要以最小的总“重量”（成本）来选择物品（审计），使得这些物品的总“价值”（风险降低量）满足一个最小阈值要求。\n\n解决此类问题的一个常用且有效的启发式方法是基于成本效益的贪心算法。我们将每次审计的效率 $e_i$ 定义为其提供的风险降低量 $\\Delta r_i = a_i r_i$ 与其成本 $c_i$ 的比率。\n$$\ne_i = \\frac{\\Delta r_i}{c_i} = \\frac{a_i r_i}{c_i}\n$$\n我们将为每个依赖项计算 $\\Delta r_i$（单位：百万美元）、$c_i$（单位：千美元）以及 $e_i$（单位：$1000 \\frac{\\text{美元风险降低量}}{\\text{美元成本}}$）。\n\n| 依赖项 $i$ | $r_i$ (百万美元) | $a_i$ | $\\Delta r_i = a_i r_i$ (百万美元) | $c_i$ (千美元) | $e_i = \\frac{\\Delta r_i}{c_i}$ |\n| :---: | :---: | :---: | :---: | :---: | :---: |\n| $1$ | $2.5$ | $0.6$ | $1.50$ | $120$ | $0.01250$ |\n| $2$ | $1.8$ | $0.4$ | $0.72$ | $80$  | $0.00900$ |\n| $3$ | $3.0$ | $0.5$ | $1.50$ | $140$ | $\\approx 0.01071$ |\n| $4$ | $0.9$ | $0.7$ | $0.63$ | $60$  | $0.01050$ |\n| $5$ | $2.2$ | $0.3$ | $0.66$ | $100$ | $0.00660$ |\n| $6$ | $1.6$ | $0.8$ | $1.28$ | $130$ | $\\approx 0.00985$ |\n\n接下来，我们按其效率 $e_i$ 的降序对依赖项进行排序：\n$e_1 > e_3 > e_4 > e_6 > e_2 > e_5$.\n因此，选择顺序为：$1, 3, 4, 6, 2, 5$。\n\n我们现在应用贪心算法，按此顺序选择审计项目，直到累计风险降低量超过550万美元。\n\n1.  **选择审计项目 1**:\n    *   累计成本: $C = c_1 = 120$.\n    *   累计风险降低量: $\\Delta R = \\Delta r_1 = 1.50$.\n    *   $1.50 \\ngtr 5.5$。我们必须继续。\n\n2.  **选择审计项目 3**:\n    *   累计成本: $C = 120 + c_3 = 120 + 140 = 260$.\n    *   累计风险降低量: $\\Delta R = 1.50 + \\Delta r_3 = 1.50 + 1.50 = 3.00$.\n    *   $3.00 \\ngtr 5.5$。我们必须继续。\n\n3.  **选择审计项目 4**:\n    *   累计成本: $C = 260 + c_4 = 260 + 60 = 320$.\n    *   累计风险降低量: $\\Delta R = 3.00 + \\Delta r_4 = 3.00 + 0.63 = 3.63$.\n    *   $3.63 \\ngtr 5.5$。我们必须继续。\n\n4.  **选择审计项目 6**:\n    *   累计成本: $C = 320 + c_6 = 320 + 130 = 450$.\n    *   累计风险降低量: $\\Delta R = 3.63 + \\Delta r_6 = 3.63 + 1.28 = 4.91$.\n    *   $4.91 \\ngtr 5.5$。我们必须继续。\n\n5.  **选择审计项目 2**:\n    *   累计成本: $C = 450 + c_2 = 450 + 80 = 530$.\n    *   累计风险降低量: $\\Delta R = 4.91 + \\Delta r_2 = 4.91 + 0.72 = 5.63$.\n    *   $5.63 > 5.5$。条件现已满足。\n\n选定的审计项目集合为 $\\{1, 2, 3, 4, 6\\}$。通过此方法找到的最低总审计成本为530千美元。实现的总风险降低量为563万美元。\n让我们验证最终风险：\n$R_{final} = R_{initial} - \\Delta R_{total} = 12.0 - 5.63 = 6.37$ 百万美元。\n条件 $R_{final}  \\epsilon$ 即 $6.37  6.5$，成立。\n\n虽然贪心算法是0/1背包问题的启发式算法，通常不保证能得到最优解，但对于这个小规模问题，我们可以验证其最优性。所有可能的风险降低量之和为 $\\sum \\Delta r_i = 6.29$ 百万美元。如果我们忽略效率最高的审计项目（项目1，降低量为1.50），那么剩余审计项目的最大可能降低量为 $6.29 - 1.50 = 4.79$ 百万美元，这小于所需的5.5百万美元降低量。因此，审计项目1必须是任何有效解决方案的一部分，从而也必须在最优解中。类似的分析表明，审计项目3和6也是必需的。沿着这个逻辑继续分析，可以证实对于这组特定参数，贪心选择确实是最优的。\n\n需要审计的依赖项集合是 $\\{1, 2, 3, 4, 6\\}$。最低总审计成本是它们各自成本的总和：\n$$\nC_{minimal} = c_1 + c_2 + c_3 + c_4 + c_6 = 120 + 80 + 140 + 60 + 130 = 530\n$$\n成本单位为千美元。",
            "answer": "$$\\boxed{530}$$"
        }
    ]
}