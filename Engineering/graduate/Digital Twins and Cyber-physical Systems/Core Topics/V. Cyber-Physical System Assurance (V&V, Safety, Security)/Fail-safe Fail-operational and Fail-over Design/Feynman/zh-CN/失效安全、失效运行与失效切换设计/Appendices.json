{
    "hands_on_practices": [
        {
            "introduction": "任何失效安全或失效运行设计的第一步都是准确地检测异常。本练习探讨了如何利用状态观测器（数字孪生的核心组件）来实现这一目标。通过将系统的数学模型预测与真实世界的传感器测量值进行比较，我们可以生成一个“残差”信号，该信号在正常运行时接近于零，但在出现故障时会显著偏离。这个练习将指导您从第一性原理出发，推导出一个基于 Luenberger 观测器的残差信号，并计算一个检测阈值 $\\gamma$，该阈值在期望的误报率 $\\alpha$ 和系统噪声水平 $\\sigma$ 之间取得平衡，这对于设计可靠的故障诊断系统至关重要。",
            "id": "4221228",
            "problem": "一个监控信息物理系统 (CPS) 的数字孪生 (DT) 使用状态观测器，通过检测传感器或模型异常，并在必要时触发故障切换控制器，来支持故障安全和故障可操作行为。考虑一个具有以下动态特性的离散时间线性时不变系统\n$$\nx_{k+1} = A x_{k} + B u_{k}, \\quad y_{k} = C x_{k} + w_{k},\n$$\n其中 $x_{k} \\in \\mathbb{R}^{n}$ 是状态， $u_{k} \\in \\mathbb{R}^{m}$ 是输入， $y_{k} \\in \\mathbb{R}^{p}$ 是测量值， $w_{k} \\sim \\mathcal{N}(0,\\sigma^{2} I_{p})$ 是独立同分布的零均值高斯测量噪声，每个输出通道的方差为 $\\sigma^{2}$。不存在过程噪声。该 DT 实现了一个 Luenberger 观测器\n$$\n\\hat{x}_{k+1} = A \\hat{x}_{k} + B u_{k} + L \\left( y_{k} - C \\hat{x}_{k} \\right),\n$$\n其观测器增益 $L \\in \\mathbb{R}^{n \\times p}$ 的选择使得矩阵 $A - L C$ 是 Schur 矩阵（所有特征值都严格位于单位圆内）。\n\n在无故障操作中，DT 计算一个用于异常检测的残差，\n$$\nr_{k} = y_{k} - C \\hat{x}_{k},\n$$\n并在双边检验 $|r_{k}| > \\gamma$ 成立时触发向故障切换控制器的故障安全转换，以保持故障可操作的连续性。此处，当 $p > 1$ 时 $|r_{k}|$ 表示欧几里得范数，当 $p = 1$ 时表示绝对值。假设为单输出传感器通道 ($p = 1$)，并且观测器已达到稳态，与测量噪声相比，估计误差对残差方差的贡献可以忽略不计，因此在无故障操作下，$r_{k}$ 近似服从 $\\mathcal{N}(0,\\sigma^{2})$ 分布。\n\n从线性观测器和高斯尾部概率的基本原理出发，使用给定的 Luenberger 观测器推导残差生成器 $r_k$，并计算能够实现指定误报率 (FAR) $\\alpha \\in (0,1)$ 的双边检验的闭式检测阈值 $\\gamma$。FAR 定义为在无故障操作下，检测器错误触发的概率（即，在没有故障存在时 $|r_{k}| > \\gamma$ 的概率）。请将最终的阈值 $\\gamma$ 表示为 $\\alpha$ 和 $\\sigma$ 的函数，仅使用概率论中的标准特殊函数，并以单一解析表达式的形式给出。在此设置中，不需要进行数值取整，$\\gamma$ 也没有关联的物理单位。请在您的推理中明确说明所使用的任何分布函数。",
            "solution": "问题陈述经评估有效。其科学基础在于线性系统理论、状态估计和统计故障检测的原理。问题定义明确，提供了推导唯一解析解所需的所有定义、假设和约束。陈述客观，与指定主题直接相关。因此，我们可以进行完整推导。\n\n任务有两部分：首先，推导残差生成器 $r_{k}$；其次，计算检测阈值 $\\gamma$ 作为误报率 $\\alpha$ 和噪声标准差 $\\sigma$ 的函数。\n\n首先，我们来分析系统和观测器的动态特性。估计误差定义为 $e_{k} = x_{k} - \\hat{x}_{k}$。我们可以通过从系统状态方程中减去观测器方程来推导其动态特性。\n$$\ne_{k+1} = x_{k+1} - \\hat{x}_{k+1}\n$$\n代入给定的 $x_{k+1}$ 和 $\\hat{x}_{k+1}$ 方程：\n$$\ne_{k+1} = (A x_{k} + B u_{k}) - \\left( A \\hat{x}_{k} + B u_{k} + L(y_{k} - C \\hat{x}_{k}) \\right)\n$$\n$B u_{k}$ 项相互抵消。我们将包含 $A$ 和 $L$ 的项组合起来：\n$$\ne_{k+1} = A (x_{k} - \\hat{x}_{k}) - L(y_{k} - C \\hat{x}_{k})\n$$\n现在，将 $y_{k} = C x_{k} + w_{k}$ 代入方程：\n$$\ne_{k+1} = A e_{k} - L( (C x_{k} + w_{k}) - C \\hat{x}_{k} )\n$$\n$$\ne_{k+1} = A e_{k} - L( C(x_{k} - \\hat{x}_{k}) + w_{k} )\n$$\n$$\ne_{k+1} = A e_{k} - L(C e_{k} + w_{k})\n$$\n这给出了由测量噪声 $w_k$ 驱动的自主误差动态方程：\n$$\ne_{k+1} = (A - L C)e_{k} - L w_{k}\n$$\n问题陈述指出，选择观测器增益 $L$ 是为了使矩阵 $A - L C$ 成为 Schur 矩阵，即其所有特征值的模都小于 1。此条件保证了误差动态是稳定的。在没有噪声 ($w_k = 0$) 的情况下，误差 $e_k$ 会收敛到 0。在持续噪声存在的情况下，误差会收敛到一个平稳随机过程。\n\n接下来，我们推导残差 $r_{k}$ 的表达式。残差定义为 $r_{k} = y_{k} - C \\hat{x}_{k}$。我们代入测量方程 $y_{k} = C x_{k} + w_{k}$：\n$$\nr_{k} = (C x_{k} + w_{k}) - C \\hat{x}_{k}\n$$\n$$\nr_{k} = C (x_{k} - \\hat{x}_{k}) + w_{k}\n$$\n$$\nr_{k} = C e_{k} + w_{k}\n$$\n该表达式表明，残差是投影估计误差和测量噪声之和。在无故障操作下，问题提出了一个关键的简化假设：“观测器已达到稳态，与测量噪声相比，估计误差对残差方差的贡献可以忽略不计”。这意味着项 $C e_k$ 被认为足够小，其对 $r_k$ 的统计贡献与 $w_k$ 相比可以忽略。在数学上，这意味着近似 $r_{k} \\approx w_{k}$。\n\n已知测量噪声 $w_{k} \\in \\mathbb{R}^{p}$ 服从 $w_{k} \\sim \\mathcal{N}(0, \\sigma^{2} I_{p})$ 分布，并且我们正在考虑单输出通道 ($p=1$)，噪声 $w_k$ 是一个标量随机变量，其分布为 $w_{k} \\sim \\mathcal{N}(0, \\sigma^{2})$。因此，在问题陈述的无故障稳态操作假设下，残差 $r_k$ 也是一个具有相同分布的标量随机变量：\n$$\nr_{k} \\sim \\mathcal{N}(0, \\sigma^{2})\n$$\n这完成了任务的第一部分，即确定残差生成器的统计特性。\n\n现在，我们进行第二部分：计算检测阈值 $\\gamma$。误报率 (FAR)，用 $\\alpha$ 表示，是检测器在没有故障存在时触发的概率。触发条件是 $|r_k| > \\gamma$。因此，FAR 定义为：\n$$\n\\alpha = P(|r_{k}| > \\gamma)\n$$\n由于 $r_k$ 是标量 ($p=1$)，这等价于：\n$$\n\\alpha = P(r_{k} > \\gamma \\text{ 或 } r_{k}  -\\gamma)\n$$\n事件 $r_{k}  \\gamma$ 和 $r_{k}  -\\gamma$ 是互斥的，所以我们可以将概率写成和的形式：\n$$\n\\alpha = P(r_{k}  \\gamma) + P(r_{k}  -\\gamma)\n$$\n正态分布 $\\mathcal{N}(0, \\sigma^{2})$ 关于其均值 0 是对称的。这种对称性意味着 $P(r_{k}  -\\gamma) = P(r_{k}  \\gamma)$。将此代入 $\\alpha$ 的方程中：\n$$\n\\alpha = 2 P(r_{k}  \\gamma)\n$$\n这给了我们单边尾部的概率：\n$$\nP(r_{k}  \\gamma) = \\frac{\\alpha}{2}\n$$\n为了评估这个概率，我们对随机变量 $r_k$ 进行标准化。令 $Z$ 为一个标准正态随机变量，$Z \\sim \\mathcal{N}(0, 1)$，定义为 $Z = \\frac{r_k - 0}{\\sigma} = \\frac{r_k}{\\sigma}$。不等式 $r_k  \\gamma$ 等价于 $Z \\sigma  \\gamma$，或 $Z  \\frac{\\gamma}{\\sigma}$。概率变为：\n$$\nP\\left(Z  \\frac{\\gamma}{\\sigma}\\right) = \\frac{\\alpha}{2}\n$$\n令 $\\Phi(z)$ 表示标准正态分布的累积分布函数 (CDF)，定义为 $\\Phi(z) = P(Z \\le z)$。尾部概率与 CDF 的关系为 $P(Z  z) = 1 - P(Z \\le z) = 1 - \\Phi(z)$。将此应用于我们的方程：\n$$\n1 - \\Phi\\left(\\frac{\\gamma}{\\sigma}\\right) = \\frac{\\alpha}{2}\n$$\n求解 CDF 项，我们得到：\n$$\n\\Phi\\left(\\frac{\\gamma}{\\sigma}\\right) = 1 - \\frac{\\alpha}{2}\n$$\n为了分离出 $\\gamma$，我们必须应用标准正态 CDF 的逆函数。这个逆函数被称为分位数函数，或概率单位函数，并用 $\\Phi^{-1}(q)$ 表示，其中 $q \\in (0, 1)$。将 $\\Phi^{-1}$ 应用于方程两边可得：\n$$\n\\frac{\\gamma}{\\sigma} = \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)\n$$\n最后，求解阈值 $\\gamma$ 得到所需的关于 $\\sigma$ 和 $\\alpha$ 的闭式表达式：\n$$\n\\gamma = \\sigma \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)\n$$\n该表达式给出了阈值 $\\gamma$ 的值，它基于一个其无故障行为被建模为方差为 $\\sigma^2$ 的零均值高斯过程的残差信号，保证了双边检验的特定误报率 $\\alpha$。函数 $\\Phi^{-1}$ 是概率论中的一个标准特殊函数。",
            "answer": "$$\n\\boxed{\\sigma \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)}\n$$"
        },
        {
            "introduction": "在检测到潜在故障或预见到不安全状态后，系统必须主动响应以维持安全。本练习从被动监测转向主动控制综合，介绍了一种先进的技术——控制屏障函数（Control Barrier Functions, CBFs）。CBF 在数学上定义了一个安全区域，通过设计一个控制器来确保系统状态永远不会穿越该区域的边界，从而前瞻性地保证安全。您将学习如何构建一个“最小侵入式”的失效运行控制器，它在满足安全约束的同时，尽可能地追踪预期的性能目标，并在物理约束使得安全无法保证时，执行预设的失效安全策略。",
            "id": "4221269",
            "problem": "考虑一个控制仿射标量信息物理系统，该系统代表一个由其数字孪生监控的安全关键型执行器通道。该连续时间对象的动态模型为 $\\dot{x} = u$，其中 $x \\in \\mathbb{R}$ 是一个无量纲状态，$u \\in \\mathbb{R}$ 是一个无量纲控制输入。安全性要求由安全集 $\\mathcal{C} = \\{ x \\in \\mathbb{R} \\mid h(x) \\ge 0 \\}$ 编码，其中障碍函数为 $h(x) = x - x_{\\min}$，$x_{\\min} \\in \\mathbb{R}$ 是一个固定阈值。执行器具有硬性界限 $u \\in [u_{\\min}, u_{\\max}]$，其中 $u_{\\min}  u_{\\max}$，并且数字孪生提供一个期望输入 $u_{\\mathrm{des}}$ 以满足标称性能。所有量均为无量纲。\n\n你需要从第一性原理出发，基于 $h(x)$ 的时间导数和一个严格递增、连续且在零点为零的函数 $\\alpha(\\cdot)$（一个$\\mathcal{K}$类函数），为 $\\mathcal{C}$ 推导出一个充分前向不变性条件。然后，利用此条件，你需要合成一个最小侵入式控制器，该控制器在确保安全性的前提下（当物理上可实现时）尽可能小地偏离 $u_{\\mathrm{des}}$，并指定当安全约束因执行器饱和而不可行时的故障切换策略。\n\n任务：\n\n1. 从安全集 $\\mathcal{C}$、前向不变性（如果 $x(0) \\in \\mathcal{C}$，则对于所有 $t \\ge 0$ 都有 $x(t) \\in \\mathcal{C}$）以及标量系统 $\\dot{x} = u$ 与 $h(x) = x - x_{\\min}$ 的定义出发，推导一个涉及 $\\dot{h}(x)$ 和 $\\alpha(h(x))$ 的充分条件，该条件保证 $\\mathcal{C}$ 的前向不变性。你的推导必须仅使用动力学系统的基本事实，如链式法则、比较法以及$\\mathcal{K}$类函数的性质。不要预先假设最终的不等式形式；要从这些基础上明确地推导出它。\n\n2. 使用任务1中推导出的条件，建立一个形式为“最小化与 $u_{\\mathrm{des}}$ 的平方偏差，并受安全条件和执行器界限约束”的凸优化问题。将此优化问题特化到标量情况，并提供基于到可行集上投影的解析解。清楚地解释当安全约束可行时（故障可操作），该解如何产生一个最小侵入式控制器，并指定当由于执行器饱和导致约束不可行时（故障安全）的故障切换策略。\n\n3. 实现一个完整的程序，该程序：\n   - 使用$\\mathcal{K}$类函数 $\\alpha(s) = k s$，其中 $k  0$。\n   - 对于下面的每个测试用例，计算控制量 $u^\\star$，该控制量在强制执行推导出的安全条件和执行器界限的同时，最小化与 $u_{\\mathrm{des}}$ 的平方偏差。如果安全约束不可行，程序必须应用一个故障切换控制，该控制在执行器界限下最大化 $h(x)$ 的瞬时增量（故障安全），并且必须报告安全约束未被满足。\n   - 对于每个测试用例，输出一个由所选控制量 $u^\\star$（一个浮点数）和一个布尔值组成的对，该布尔值指示安全条件是否被满足。\n\n使用以下固定参数和测试套件（所有量均为无量纲）：\n- $k = 0.5$,\n- $x_{\\min} = 1.0$,\n- $u_{\\min} = -2.0$,\n- $u_{\\max} = 2.0$.\n\n测试用例 $(x, u_{\\mathrm{des}})$:\n- 用例 A: $x = 1.5$, $u_{\\mathrm{des}} = 0.0$.\n- 用例 B: $x = 1.0$, $u_{\\mathrm{des}} = 0.0$.\n- 用例 C: $x = 0.8$, $u_{\\mathrm{des}} = 0.0$.\n- 用例 D: $x = -4.0$, $u_{\\mathrm{des}} = 0.0$.\n- 用例 E: $x = 3.0$, $u_{\\mathrm{des}} = -3.0$.\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是一个形式为 $[u^\\star,\\mathrm{flag}]$ 的双元素列表，其中 $u^\\star$ 是一个浮点数，$\\mathrm{flag}$ 是一个布尔值。例如：$[[u_1,\\mathrm{flag}_1],[u_2,\\mathrm{flag}_2],\\dots]$。\n\n你的解决方案必须科学上真实，并从所述基础推导得出。最终的程序必须是完整的，并且无需外部输入即可运行。",
            "solution": "该问题是有效的，因为它在控制理论，特别是控制障碍函数理论方面有科学依据，是适定的，具有唯一且稳定的解，并提供了一套完整且一致的定义、参数和目标。\n\n根据要求，解决方案分三部分推导。\n\n### 任务1：充分前向不变性条件的推导\n\n目标是确保安全集 $\\mathcal{C} = \\{ x \\in \\mathbb{R} \\mid h(x) \\ge 0 \\}$ 的前向不变性，其中 $h(x) = x - x_{\\min}$。前向不变性意味着如果初始状态 $x(0)$ 在 $\\mathcal{C}$ 中，那么状态轨迹 $x(t)$ 在所有未来的时间 $t \\ge 0$ 内都保持在 $\\mathcal{C}$ 中。这等价于要求如果 $h(x(0)) \\ge 0$，那么对于所有 $t \\ge 0$ 都有 $h(x(t)) \\ge 0$。\n\n我们寻求一个关于控制输入 $u$ 的充分条件来保证这一性质。我们提出以下条件，这是（零化）控制障碍函数不等式的标准定义：\n$$ \\dot{h}(x(t)) \\ge -\\alpha(h(x(t))) $$\n其中 $\\alpha(\\cdot)$ 是一个严格递增、连续且在零点为零的函数（一个$\\mathcal{K}$类函数）。\n\n为了证明该条件对于前向不变性是充分的，令 $y(t) = h(x(t))$。轨迹上的条件变为 $\\dot{y}(t) \\ge -\\alpha(y(t))$。我们使用比较法来分析这个微分不等式。\n\n考虑一个辅助标量变量 $z(t)$ 的初值问题：\n$$ \\dot{z}(t) = -\\alpha(z(t)), \\quad z(0) = y(0) = h(x(0)) $$\n由于 $\\alpha(\\cdot)$ 是一个$\\mathcal{K}$类函数，对于 $s  0$ 有 $\\alpha(s)  0$ 且 $\\alpha(0) = 0$。这意味着如果 $z(t)  0$，则 $\\dot{z}(t)  0$，导致 $z(t)$ 减小。如果 $z(t) = 0$，则 $\\dot{z}(t) = -\\alpha(0) = 0$，这意味着 $z=0$ 是一个平衡点。因此，如果初始条件非负，$z(0) \\ge 0$，则解 $z(t)$ 在所有 $t \\ge 0$ 内将保持非负。\n\n根据微分不等式的比较引理，由于 $\\dot{y}(t) \\ge -\\alpha(y(t))$，$\\dot{z}(t) = -\\alpha(z(t))$，且 $y(0) = z(0)$，可得对于所有 $t \\ge 0$，都有 $y(t) \\ge z(t)$。\n\n综合这些事实，如果我们从一个安全的初始条件 $x(0) \\in \\mathcal{C}$ 开始，那么 $h(x(0)) \\ge 0$。这意味着 $y(0) \\ge 0$，因此 $z(0) \\ge 0$。根据辅助系统的性质，我们有对于所有 $t \\ge 0$，$z(t) \\ge 0$。比较引理随之得出：\n$$ h(x(t)) = y(t) \\ge z(t) \\ge 0 \\quad \\forall t \\ge 0 $$\n这证实了 $x(t)$ 保持在安全集 $\\mathcal{C}$ 内，从而证明了在条件 $\\dot{h}(x) \\ge -\\alpha(h(x))$ 下，$\\mathcal{C}$ 的前向不变性。\n\n现在，我们将此条件特化到给定的系统。$h(x)$ 的时间导数使用链式法则求得：\n$$ \\dot{h}(x) = \\frac{\\partial h}{\\partial x} \\dot{x} $$\n对于给定的障碍函数 $h(x) = x - x_{\\min}$，其偏导数为：\n$$ \\frac{\\partial h}{\\partial x} = \\frac{\\partial}{\\partial x}(x - x_{\\min}) = 1 $$\n将此结果和系统动态 $\\dot{x} = u$ 代入 $\\dot{h}(x)$ 的表达式中，得到：\n$$ \\dot{h}(x) = (1) \\cdot u = u $$\n因此，充分前向不变性条件变成了对控制输入 $u$ 的直接约束：\n$$ u \\ge -\\alpha(h(x)) $$\n或者，代入 $h(x)$ 的定义：\n$$ u \\ge -\\alpha(x - x_{\\min}) $$\n\n### 任务2：最小侵入式控制器和故障切换策略\n\n目标是合成一个控制器，它选择一个输入 $u^\\star$，该输入在满足推导出的安全条件和物理执行器约束 $u \\in [u_{\\min}, u_{\\max}]$ 的同时，尽可能接近期望输入 $u_{\\mathrm{des}}$。这可以被表述为一个凸优化问题，具体来说是一个二次规划（QP）：\n$$\n\\begin{aligned}\n u^\\star = \\underset{u \\in \\mathbb{R}}{\\text{argmin}}  \\frac{1}{2}(u - u_{\\mathrm{des}})^2 \\\\\n \\text{subject to}  u \\ge -\\alpha(x - x_{\\min}) \\\\\n  u \\ge u_{\\min} \\\\\n  u \\le u_{\\max}\n\\end{aligned}\n$$\n因子 $\\frac{1}{2}$ 是常规用法，不会改变解。三个线性不等式约束定义了控制输入 $u$ 的一个可行集。该集合是区间 $[L, U]$，其中：\n$$ L = \\max(u_{\\min}, -\\alpha(x - x_{\\min})) $$\n$$ U = u_{\\max} $$\n\n可行解存在的充要条件是可行集非空，这要求 $L \\le U$。由于给定 $u_{\\min}  u_{\\max}$，可行性检查简化为条件 $-\\alpha(x - x_{\\min}) \\le u_{\\max}$。\n\n**故障可操作（可行）情况：**\n如果 $-\\alpha(x - x_{\\min}) \\le u_{\\max}$，则容许控制集非空。该优化问题简化为在闭区间 $[L, U]$ 内寻找最接近 $u_{\\mathrm{des}}$ 的点。此问题的解析解是 $u_{\\mathrm{des}}$ 在区间 $[L, U]$ 上的投影：\n$$ u^\\star = \\text{proj}_{[L, U]}(u_{\\mathrm{des}}) = \\min(U, \\max(L, u_{\\mathrm{des}})) $$\n代入 $L$ 和 $U$ 的定义：\n$$ u^\\star = \\min(u_{\\max}, \\max(u_{\\min}, -\\alpha(x - x_{\\min}), u_{\\mathrm{des}})) $$\n这个控制器是“最小侵入式”的，因为如果期望输入已经满足所有约束，它就等于 $u_{\\mathrm{des}}$。否则，它仅以满足最严格的活动约束（安全条件或执行器限制）所需的最小量偏离 $u_{\\mathrm{des}}$。\n\n**故障安全（不可行）情况：**\n如果 $-\\alpha(x - x_{\\min})  u_{\\max}$，安全要求需要一个大于执行器最大可能输出的控制输入。可行集为空，没有控制输入可以保证安全。这是一种故障安全情况。问题指定了一个故障切换策略：选择“最大化 $h(x)$ 瞬时增量”的控制。由于 $\\dot{h}(x) = u$，我们必须选择使 $u$ 最大化的控制 $u \\in [u_{\\min}, u_{\\max}]$。这个控制是：\n$$ u^\\star = u_{\\max} $$\n这一行为代表了系统尽最大努力向安全集移动，即使安全条件在这一瞬间被技术性地违反了。当这种情况发生时，必须有一个标志来指示安全约束未被满足。\n\n### 任务3：实现逻辑\n\n用于计算控制输入 $u^\\star$ 和安全标志的算法，使用指定的$\\mathcal{K}$类函数 $\\alpha(s) = ks$ 来实现任务2中的逻辑。\n\n对于给定的状态 $x$、期望控制 $u_{\\mathrm{des}}$，以及参数 $k$、$x_{\\min}$、$u_{\\min}$ 和 $u_{\\max}$：\n1.  计算强制执行安全的控制下界，我们将其表示为 $u_{\\text{safe-min}}$：\n    $$ u_{\\text{safe-min}} = -k(x - x_{\\min}) $$\n2.  检查可行性。如果安全约束能被执行器能力范围内的至少一个控制输入满足，即 $u_{\\text{safe-min}} \\le u_{\\max}$，则该约束是可行的。\n    -   **如果 $u_{\\text{safe-min}}  u_{\\max}$ (不可行/故障安全):** 无法保证安全性。\n        -   所选控制为故障切换控制：$u^\\star = u_{\\max}$。\n        -   未满足安全条件，因此标志为 `False`。\n    -   **如果 $u_{\\text{safe-min}} \\le u_{\\max}$ (可行/故障可操作):** 可以保证安全性。\n        -   控制的下界是执行器限制和安全约束中更严格的一个：$L = \\max(u_{\\min}, u_{\\text{safe-min}})$。\n        -   上界是 $U = u_{\\max}$。\n        -   最优控制 $u^\\star$ 是 $u_{\\mathrm{des}}$ 在区间 $[L, U]$ 上的投影。这可以计算为 $u^\\star = \\min(U, \\max(L, u_{\\mathrm{des}}))$，等价于 $u^\\star = \\min(u_{\\max}, \\max(u_{\\mathrm{des}}, u_{\\min}, u_{\\text{safe-min}}))$。\n        -   满足安全条件，因此标志为 `True`。\n为每个提供的测试用例实现了此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Computes a minimally invasive safe controller for a set of test cases.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    k = 0.5\n    x_min = 1.0\n    u_min = -2.0\n    u_max = 2.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.5, 0.0),   # Case A\n        (1.0, 0.0),   # Case B\n        (0.8, 0.0),   # Case C\n        (-4.0, 0.0),  # Case D\n        (3.0, -3.0),  # Case E\n    ]\n\n    results = []\n    for x, u_des in test_cases:\n        # Task 1  2: Calculate the safety constraint.\n        # The barrier function is h(x) = x - x_min.\n        # The class-K function is alpha(s) = k*s.\n        # The safety condition is u >= -alpha(h(x)), which means u >= -k*(x - x_min).\n        h_x = x - x_min\n        \n        # This is the minimum control value required to satisfy the CBF inequality.\n        u_safe_min = -k * h_x\n\n        # Task 2: Check for feasibility and apply fail-over policy if needed.\n        # The safety constraint is feasible if u_safe_min = u_max.\n        if u_safe_min > u_max:\n            # Infeasible case (Fail-Safe): The safety constraint cannot be satisfied.\n            # Apply fail-over policy: use the control that maximizes dh/dt = u.\n            u_star = u_max\n            is_safe = False\n        else:\n            # Feasible case (Fail-Operational): Synthesize the minimally invasive controller.\n            # The control must be in the interval [L, U], where:\n            # L = max(u_min, u_safe_min)\n            # U = u_max\n            # The solution u_star is the projection of u_des onto [L, U].\n            \n            # Using base Python min/max for clarity. This is equivalent to np.clip.\n            # Combine all lower bounds.\n            lower_bound = max(u_min, u_safe_min)\n            \n            # Project u_des onto the feasible interval [lower_bound, u_max].\n            # 1. Clamp u_des from below.\n            u_clamped_low = max(u_des, lower_bound)\n            # 2. Clamp the result from above.\n            u_star = min(u_clamped_low, u_max)\n            \n            is_safe = True\n\n        results.append([u_star, is_safe])\n\n    # Final print statement in the exact required format.\n    # The str() of a list like [1.0, True] is '[1.0, True]', which matches\n    # the required sub-format [u_star, flag].\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}