## 引言
随着自动驾驶汽车、[智能电网](@entry_id:1131783)和先进医疗设备等赛博物理系统 (CPS) 的日益复杂，如何确保其安全性和可靠性成为一项前所未有的挑战。传统的物理测试方法成本高昂、耗时漫长，且难以覆盖所有潜在的危险场景，尤其是在系统部署之前。基于仿真的测试方法论应运而生，它利用高保真的[数字孪生](@entry_id:171650)在虚拟世界中进行系统化、可重复且经济高效的测试，从而在设计早期发现并修复缺陷。本文旨在为读者提供一个关于该方法论的全面而深入的指南，弥合了从基础理论到前沿应用的知识鸿沟。

本文将系统地引导读者穿越这一复杂领域。在 **“原理与机制”** 一章中，我们将奠定理论基础，深入探讨[数字孪生](@entry_id:171650)的构建、混成[系统建模](@entry_id:197208)、形式化规约以及[不确定性量化](@entry_id:138597)等核心概念。接下来，在 **“应用与跨学科交叉”** 一章中，我们将展示这些原理如何应用于现实世界的问题，从[自动驾驶](@entry_id:270800)的系统化测试到与因果推断、控制理论和人类行为建模的深度融合。最后，**“动手实践”** 部分提供了一系列精心设计的问题，让读者能够将所学知识付诸实践，加深对关键技术的理解。通过学习本文，读者将不仅掌握一套强大的技术工具，更将建立一种系统性的思维方式，以应对现代工程与科学中复杂系统的保证难题。

## 原理与机制

本章旨在深入探讨基于仿真的测试方法论背后的核心原理与关键机制。我们将从[数字孪生](@entry_id:171650)的基本构成出发，系统性地介绍如何构建、形式化、执行和验证一个用于测试目的的仿真模型。内容将涵盖从模型校准到混成系统动力学，从[数值积分](@entry_id:136578)到[形式化规约语言](@entry_id:1125244)，再到不确定性量化和证据有效性等一系列高级主题。最终，我们将阐述如何将仿真证据整合到更宏大的系统安全论证框架中。

### 数字孪生：物理系统的高保真[计算模型](@entry_id:637456)

基于仿真的测试，其核心是利用一个**数字孪生 (Digital Twin, DT)** 来替代物理实体进行实验。一个数字孪生不仅是一个静态模型，更是一个动态的、与物理资产紧密关联的虚拟对应物。理解其构成是掌握本方法论的第一步。一个功能完备的数字孪生通常包含以下几个关键组成部分 ：

1.  **物理资产 (Physical Asset)**：这是现实世界中存在的赛博物理系统 (Cyber-Physical System, CPS)，例如一辆自动驾驶汽车、一个机器人或一个发电厂。它遵循物理定律演化，其状态 $x(t)$ 由动力学方程 $\dot{x}(t) = f_{\text{real}}(x(t), u(t))$ 描述。

2.  **虚拟模型 (Virtual Model)**：这是对物理资产的计算表征，通常以[参数化](@entry_id:265163)的常微分方程 (ODE)、[偏微分](@entry_id:194612)方程 (PDE) 或混成自动机的形式存在。该模型 $\mathcal{M}_\theta$ 旨在预测物理资产的行为，其仿真状态 $\hat{x}(t)$ 的演化由 $\dot{\hat{x}}(t) = f_{\theta}(\hat{x}(t), u(t))$ 描述。

3.  **双向数据流 (Bidirectional Data Streams)**：这是连接物理世界与虚拟世界的桥梁。数据流将物理资产的传感器测量值 $y(t)$ 和控制输入 $u(t)$ 传输到虚拟模型，用于模型的校准、状态更新和验证。反向数据流则可以将虚拟模型中优化得到的控制策略或[预测性维护](@entry_id:167809)指令发送回物理资产。

4.  **同步机制 (Synchronization Mechanisms)**：由于传感器延迟、异步采样和网络通信延迟的存在，物理资产和虚拟模型的时间轴并非天然对齐。同步机制通过时间戳、[状态估计器](@entry_id:272846)（如卡尔曼滤波器）和[时钟同步](@entry_id:270075)协议来对齐虚拟与物理的时间线和状态。

数字孪生的核心价值在于其**保真度 (fidelity)**，即虚拟模型预测行为与物理资产实际行为的一致性程度。保真度不是一个抽象概念，而是可以通过具体的误差度量来操作化。在考虑了同步延迟 $\alpha(t)$ 和输出映射 $h(\cdot)$ 后，我们可以定义一个有意义的误差度量，例如[均方根误差 (RMSE)](@entry_id:1131101)：
$$
\mathrm{RMSE} = \sqrt{\frac{1}{N} \sum_{k=1}^{N} \left\| y(t_k) - \hat{y}\big(\alpha(t_k)\big) \right\|_2^2 }
$$
其中 $y(t_k)$ 是物理系统的实际测量输出，而 $\hat{y}$ 是[数字孪生](@entry_id:171650)的预测输出。只有在对齐的时间和可比较的物理量上计算误差，保真度评估才具有实际意义。

### 模型的构建与验证：校准、验证与结构充分性

一个高保真度的数字孪生并非一蹴而就。它的构建过程遵循系统辨识和[统计学习](@entry_id:269475)中的严谨流程，主要包括**[模型校准](@entry_id:146456) (model calibration)** 和 **模型验证 (model validation)** 两个阶段。这两个阶段旨在解决两个既有区别又有联系的问题：**[参数估计](@entry_id:139349) (parameter estimation)** 和 **结构模型充分性 (structural model adequacy)** 。

在一个[参数化](@entry_id:265163)的模型族 $\mathcal{M} = \{(f, h; \theta) : \theta \in \Theta\}$ 中，我们首先固定模型的结构，即函数 $f$ 和 $h$ 的形式，这通常基于已知的物理学原理。

- **模型校准**：此阶段的目标是进行参数估计。我们使用一个独立的**校准数据集** $\mathcal{D}_{\mathrm{cal}}$，通过最小化模型预测输出 $\hat{y}_i(\theta)$ 与实际测量输出 $y_i$ 之间的差异（即[损失函数](@entry_id:634569) $\ell(y_i, \hat{y}_i(\theta))$）来寻找最优的参数 $\hat{\theta}$。这个过程可以形式化为一个优化问题：
  $$
  \hat{\theta} = \arg\min_{\theta \in \Theta} J_{\mathrm{cal}}(\theta) = \arg\min_{\theta \in \Theta} \frac{1}{N_{\mathrm{cal}}} \sum_{i=1}^{N_{\mathrm{cal}}} \ell\Big(y_i, \hat{y}_i(\theta)\Big)
  $$

- **[模型验证](@entry_id:141140)**：在找到最优参数 $\hat{\theta}$ 后，我们需要评估校准后模型的泛化能力，即它在未见过的数据上的表现。为此，我们使用一个与校准集完全分离的**验证数据集** $\mathcal{D}_{\mathrm{val}}$。通过[计算模型](@entry_id:637456)在[验证集](@entry_id:636445)上的[经验风险](@entry_id:633993) $R_{\mathrm{val}}(\hat{\theta})$，我们可以评估其预测保真度。如果模型在校准集上误差很小，但在[验证集](@entry_id:636445)上误差很大，则表明发生了**过拟合 (overfitting)**。

这两个过程揭示了参数估计与结构充分性的根本区别。[参数估计](@entry_id:139349)回答的是：“对于**这个特定形式的模型**，最好的参数是什么？”而结构模型充分性则提出了一个更深层次的问题：“我们选择的**模型形式本身**是否足以描述真实系统的物理行为？”如果模型结构存在根本性缺陷（例如，忽略了重要的物理效应），那么无论如何精细地调整参数 $\theta$，模型都无法准确预测真实系统的行为。这种结构性偏差无法仅通过参数估计来弥补，而需要重新审视和修改模型的基本方程 $f$ 和 $h$。

### 混成[系统建模](@entry_id:197208)：形式化CPS动态

许多赛博物理系统本质上是**混成系统 (hybrid systems)**，其行为由连续的物理动态和离散的逻辑事件共同驱动。例如，一个采用滞环控制的飞行器，其飞行状态（高度、速度）是连续变化的，而发动机的启停则由离散的控制模式切换决定。为了精确地仿真这类系统，我们需要一个能够描述这种混合动态的形式化工具，**混成自动机 (hybrid automaton)** 正是为此而生 。

一个混成自动机由以下几个核心部分定义：

- **离散状态 (Modes)**, $Q$：表示系统的不同操作模式，例如飞行器控制中的“上升”($\mathrm{Asc}$) 和“下降”($\mathrm{Desc}$) 模式。

- **[连续状态空间](@entry_id:276130)**, $X$：描述系统的连续变量，例如飞行器的高度 $h$ 和速度 $v$，构成状态向量 $x=(h,v)$。

- **流 (Flows)**, $F$：在每个离散模式下，描述连续状态如何随时间演化的[微分](@entry_id:158422)方程。例如，在 $\mathrm{Asc}$ 模式下，流可以是 $\dot{x} = (v, a_{\max} - c v)$。

- **不变量 (Invariants)**, $\mathrm{Inv}$：定义了在某个离散模式下必须始终保持为真的条件。它限定了在该模式下连续状态的合法范围。例如，一个物理执行器的速度限制 $|v| \le v_{\max}$ 就是一个适合作为不变量的条件。需要注意的是，待测试的**安全属性**（如高度范围 $h(t) \in [h_{\min}, h_{\max}]$）不应被包含在不变量中，否则就无法测试对该属性的违反情况。

- **守卫 (Guards)**, $G$：定义了从一个离散模式跳转到另一个模式的触发条件。这是一个关于连续状态的[布尔表达式](@entry_id:262805)。例如，从 $\mathrm{Asc}$ 模式切换到 $\mathrm{Desc}$ 模式的守卫可以是 $h \ge h_{\mathrm{ref}} + \delta$，即高度超过了滞环控制的上限。

- **重置 (Resets)**, $R$：定义了在发生离散跳转时，连续状态如何瞬时改变。在许多CPS中，模式切换只改变了控制律（即流），而物理状态（如位置、速度）是连续的，此时重置映射为[恒等变换](@entry_id:264671) $R(x)=x$。

混成自动机的**语义 (semantics)** 规定了其执行方式：系统在某个模式下根据其流进行连续演化，直到状态满足某个出向边的守卫条件。此时，系统发生瞬时离散跳转，状态根据重置映射更新，并进入目标模式。这个过程不断重复。

### 仿真引擎：数值积分与事件处理

将混成自动机模型转化为可执行的仿真，需要一个可靠的**仿真引擎**。其核心是**[数值积分器](@entry_id:1128969) (numerical integrator)**，用于求解定义了“流”的[常微分方程](@entry_id:147024) (ODE)。理解不同积分方法的特性对于确保仿真结果的准确性和稳定性至关重要 。

数值方法可大致分为三类：

- **显式方法 (Explicit Methods)**：如**[显式欧拉法](@entry_id:1124769) (explicit Euler)**，$x_{n+1} = x_n + h f(x_n, t_n)$。这类方法直接利用当前时刻 $t_n$ 的信息计算下一时刻 $t_{n+1}$ 的状态，计算简单。然而，它们的**[绝对稳定域](@entry_id:171484)**有限。对于**刚性系统 (stiff systems)**（即系统存在时间尺度差异极大的动态），为保持数值稳定，显式方法被迫采用极小的步长 $h$，导致计算效率低下。

- **[隐式方法](@entry_id:138537) (Implicit Methods)**：如**[隐式欧拉法](@entry_id:1126413) (implicit Euler)**，$x_{n+1} = x_n + h f(x_{n+1}, t_{n+1})$。这类方法在计算 $x_{n+1}$ 时需要求解一个（可能[非线性](@entry_id:637147)的）[代数方程](@entry_id:272665)。虽然每一步的计算成本更高，但它们通常具有更大的稳定域。例如，[隐式欧拉法](@entry_id:1126413)是 **A-稳定 (A-stable)** 的，其稳定域包含整个左半复平面，使其在处理刚性问题时能够采用远大于显式方法所允许的步长，从而在精度满足要求的前提下大幅提升效率。

- **[自适应步长](@entry_id:636271)方法 (Adaptive Step-size Methods)**：这类方法通过在每一步估计**局部截断误差 (Local Truncation Error, LTE)**，并与用户设定的容差进行比较，来动态调整步长 $h$。如果误差过大，则拒绝当前步并减小步长重试；如果误差远小于容差，则可能在下一步增大步长。这种机制旨在以尽可能大的步长达到期望的精度。

在仿真混成系统时，一个关键挑战是**事件处理 (event handling)**。守卫条件被触发是一个“事件”。[数值积分器](@entry_id:1128969)在离散的时间步上前进，很可能错过两个时间步之间发生的精确事件时刻。这会导致仿真结果不准确甚至错误。一个健全的混成系统仿真器必须具备**[事件检测](@entry_id:162810)**和**事件定位**的能力。当检测到守卫函数（如 $g(x) = h - (h_{\mathrm{ref}} + \delta)$）在一步之内改变符号时，仿真器必须通过[求根算法](@entry_id:146357)（如二分法）精确定位事件发生的时刻 $t^*$，积分到该时刻，执行离散跳转，然后从 $t^*$ 开始以新的模式继续积分 。

### 形式化规约：用[信号时序逻辑](@entry_id:1131627)定义测试准则

要进行测试，我们必须首先用一种无[歧义](@entry_id:276744)的、机器可读的方式来定义什么是“正确”的行为，什么是“错误”的行为。**形式化规约 (formal specifications)** 为此提供了语言和语义，充当了**测试预言机 (test oracle)** 的角色。对于处理连续时间、实值信号的CPS，**[信号时序逻辑](@entry_id:1131627) (Signal Temporal Logic, STL)** 是一种极其强大且适用的规约语言 。

STL 扩展了传统的[时序逻辑](@entry_id:181558)，允许对实值信号的性质进行推理。其核心是原子谓词和时序算子：

- **原子谓词 (Atomic Predicates)**：形如 $\mu > c$ 或 $\mu \le c$ 的[布尔表达式](@entry_id:262805)，其中 $\mu$ 是信号 $x(t)$ 的一个函数（通常就是 $x(t)$ 本身），$c$ 是一个常数。例如，$x(t) \le 1$ 就是一个原子谓词。

- **时序算子 (Temporal Operators)**：包括“总会”($\mathbf{G}$)、“最终”($\mathbf{F}$)、“直到”($\mathbf{U}$) 等，并且这些算子都带有时间区间。例如，$\mathbf{G}_{[a,b]} \varphi$ 意为“在时间区间 $[a,b]$ 内，属性 $\varphi$ 总是成立”。

STL 的一个革命性特点是它不仅有**布尔语义 (Boolean semantics)**，还有**定量语义 (quantitative semantics)**，也称为**鲁棒性 (robustness)**。

- **布尔语义**：对于一个给定的信号轨迹 $x(t)$ 和一个STL公式 $\varphi$，布尔语义给出一个真/假的判定，即轨迹是否满足该规约。例如，对于规约 $\varphi := \mathbf{G}_{[0,2]}(x(t) \le 1)$，如果信号 $x(t)$ 在 $[0,2]$ 区间内的最大值超过了 $1$，则布尔语义为假。

- **定量语义**：鲁棒性 $\rho(\varphi, x, t)$ 则提供了一个实数值，它量化了信号“在多大程度上”满足或违反了规约。正的鲁棒性值表示满足，且其大小表示距离违反边界的“安全裕度”；负的鲁棒性值表示违反，且其绝对值表示违规的严重程度。对于原子谓词 $\psi := (x(t) \le 1)$，其鲁棒性定义为 $\rho(\psi, x, t) = 1 - x(t)$。对于“总会”算子，其鲁棒性是其子公式在相应时间区间内的鲁棒性的最小值。例如，$\varphi := \mathbf{G}_{[0,2]}(x(t) \le 1)$ 的鲁棒性为：
  $$
  \rho(\varphi, x, 0) = \inf_{t' \in [0,2]} (1 - x(t')) = 1 - \sup_{t' \in [0,2]} x(t')
  $$
  如果信号在 $[0,2]$ 上的最大值为 $1.2$，则鲁棒性为 $1 - 1.2 = -0.2$。这个负值不仅告诉我们规约被违反了，还量化了最大超调量为 $0.2$ 。鲁棒性在基于优化的测试（即[证伪](@entry_id:260896)）中扮演着至关重要的角色。

### 基于仿真的测试：证伪与反例搜索

有了仿真模型和形式化规约，**[证伪](@entry_id:260896) (falsification)** 成为一种核心的测试活动。与旨在[证明系统](@entry_id:156272)永远正确的验证方法（如穷尽可达性分析）不同，[证伪](@entry_id:260896)的目标是主动地、高效地**寻找一个违反规约的反例 (counterexample)** 。

在形式上，证伪是一个[搜索问题](@entry_id:270436)。给定一个输入信号空间 $\mathcal{U}$ 和一个STL规约 $\varphi$，证伪旨在寻找一个特定的输入信号 $u^\star \in \mathcal{U}$，使得系统在该输入下产生的输出轨迹 $y_{u^\star}$ 不满足规约，即 $y_{u^\star} \not\models \varphi$。这个过程可以看作是在由所有违规输入构成的集合 $V_\varphi = \{ u \mid y_u \not\models \varphi \}$ 中寻找一个元素。

为了使这个搜索过程在计算上可行，通常会将无限维的输入函数空间[参数化](@entry_id:265163)，例如，将输入[信号表示](@entry_id:266189)为分段[常数函数](@entry_id:152060)或[样条](@entry_id:143749)函数，从而将问题转化为在一个有限维[参数空间](@entry_id:178581)上的优化问题。STL的定量语义（鲁棒性）在这里起到了关键作用：它为优化算法提供了一个连续的、可微的成本函数。[证伪](@entry_id:260896)算法的目标就变成了寻找使鲁棒性[函数最小化](@entry_id:138381)（即最小化到负值）的输入参数。

理解证伪的**认知地位 (epistemic role)** 至关重要：

- **证伪对于反驳是健全的 (sound for refutation)**：如果证伪过程成功找到了一个反例 $u^\star$，它就无可辩驳地证明了系统并非对所有输入都满足规约 $\varphi$。一个反例足以推翻一个普遍性的安全声明。

- **[证伪](@entry_id:260896)对于证明是不完备的 (incomplete for proof)**：如果一个[证伪](@entry_id:260896)算法在运行了有限时间后没有找到反例，这**并不意味着**不存在反例。它只表明在算法搜索过的输入空间子集内没有发现反例。因此，[证伪](@entry_id:260896)的失败不能作为系统[绝对安全](@entry_id:262916)的证明。

### [不确定性量化](@entry_id:138597)：[偶然不确定性与认知不确定性](@entry_id:1120923)

任何现实世界的建模和仿真都不可避免地伴随着不确定性。在对仿真结果进行可信度评估时，区分并正确处理不同类型的不确定性是至关重要的。主要的不确定性来源有两种：**[偶然不确定性](@entry_id:634772) (aleatoric uncertainty)** 和 **认知不确定性 (epistemic uncertainty)** 。

- **[偶然不确定性](@entry_id:634772)**：源于系统固有的、不可约减的随机性。例如，传感器噪声、环境中的随机扰动（如阵风）、或不同驾驶员行为的内在变异性。这种不确定性最好用**概率论**来描述。例如，如果系统的某个输入 $X$ 是随机的，我们可以将其建模为一个[随机变量](@entry_id:195330)，其行为由一个概率分布（或定律）$\mu_X$ 刻画。当这个随机输入通过一个确定的仿真模型 $y = f(x, \theta)$ 传播时，输出 $Y$ 也成为一个[随机变量](@entry_id:195330)。其分布 $\mu_Y$ 是输入分布 $\mu_X$ 通过函数 $f$ 的**[前推测度](@entry_id:201640) (pushforward measure)**：
  $$
  \mu_Y(B) = \mu_X(\{x \in \mathcal{X} : f(x, \theta) \in B\})
  $$
  这本质上是通过[蒙特卡洛](@entry_id:144354)仿真来估计的。

- **认知不确定性**：源于我们知识的缺乏或不完整。例如，我们可能不知道模型参数 $\theta$ 的精确值，或者模型结构本身可能存在未建模的动态。这种不确定性原则上是可以通过更多的数据或更好的理论来削减的。对认知不确定性最基本的表示是**非概率的**，例如，将所有可能的参数值限定在一个**集合** $S_\Theta$ 内。其传播是通过计算所有可能输入和参数组合下的输出集合，即**可达集分析 (reachable set analysis)**：
  $$
  Y_S = \{f(x, \theta) : x \in S_\mathcal{X}, \theta \in S_\Theta\}
  $$

当两种不确定性并存时（这是CPS测试中的常态），严谨的处理方式是得到一个**输出测度的族 (family of output measures)**，即 $\{ \mu_Y^\theta : \theta \in S_\Theta \}$。这个集合中的每一个测度 $\mu_Y^\theta$ 都对应于一个可能的参数值 $\theta$，并描述了在该参数下由[偶然不确定性](@entry_id:634772)引起的输出分布。这个“不精确概率”的框架，保留了两种不确定性的本质区别，是进行鲁棒性分析和可信度评估的坚实基础。

### 仿真证据的有效性：从内部有效性到外部有效性

使用数字孪生进行测试的核心挑战在于“仿真到现实”的鸿沟 (sim-to-real gap)。我们如何确保从仿真中获得的结论能够有效地迁移到真实世界？这就引出了**内部有效性 (internal validity)** 和 **外部有效性 (external validity)** 的概念 。

- **内部有效性**：关注于仿真研究**本身**的因果结论是否正确。它回答的是：“在仿真世界中，我们观察到的性能变化是否确实是由我们的控制策略改变引起的，而不是由仿真器自身的缺陷、[数值误差](@entry_id:635587)或未控制的混杂因素造成的？”确保内部有效性是进行任何有意义的仿真测试的先决条件。

- **外部有效性** (或称**可移植性 (transportability)**)：关注于仿真结论能否推广到**目标部署环境**。这在因果推断的框架下有精确的定义。如果仿真环境与真实环境中的**因果机制** $P(Y | X, do(f))$ 是不变的——即给定相同的观测条件 $X$ 和干预 $f$，产生结果 $Y$ 的规律是相同的——那么外部有效性就可能成立。此时，两个环境的差异可能仅仅表现为**[协变量偏移](@entry_id:636196) (covariate shift)**，即观测条件 $X$ 的分布 $P(X)$ 不同。在这种情况下，我们可以通过对仿真结果进行重加权等方法，将结论移植到真实世界。

更广泛的**泛化性 (generalizability)** 则考虑了在更广泛的环境和群体变化下结论的稳定性。例如，**环境泛化**可能只涉及 $P(X)$ 的变化（如不同的天气），而**群体泛化**可能还涉及未观测的[隐变量](@entry_id:150146) $U$ 的[分布变化](@entry_id:915633)（如驾驶员的攻击性），这可能破坏因果机制的不变性，使移植变得更加困难。

为了系统性地建立仿真证据的有效性，我们需要依赖一套严谨的**认知假设 (epistemic assumptions)** 。一个完整的论证链条应包括：
1.  **结构保真度**：模型方程与真实物理过程之间的差异有界。
2.  **[参数辨识](@entry_id:275549)**：模型参数是通过代表性数据估计得来，并且不确定性得到量化。
3.  **数值[求解器验证](@entry_id:1131945)**：仿真器是收敛的，且数值误差有界并可控。
4.  **输入输出等价性**：仿真模型正确复现了真实系统的因果关系和时序特性。
5.  **环境代表性**：测试场景充分覆盖了预期的操作设计域。
6.  **[不确定性量化](@entry_id:138597)与推断**：所有相关的不确定性源都得到表示和传播，并使用健全的统计方法从有限的仿真样本中得出结论。

当这些假设成立时，仿真证据才能被认为是关于真实世界性能声明的有效支持；而当某个假设被违反时，则需要更高层次的测试方法，如[硬件在环](@entry_id:1125914) (HIL) 测试或物理原型测试来弥补。

### 综合论证：在安全案例中集成仿真证据

在安全关键系统的认证中，单一来源的证据往往不足以建立充分的置信度。基于仿真的测试结果必须被整合到一个更广泛的**安全案例 (safety case)** 中。安全案例是一个结构化的、可审计的论证，它由一系列**声明 (claims)**、**论据 (arguments)** 和**证据 (evidence)** 组成，旨在令人信服地表明系统在其预期环境中是可接受地安全的 。

使用**目标结构符号 (Goal Structuring Notation, GSN)** 等结构化论证方法，我们可以清晰地展示从顶层安全声明（例如，“系统碰撞概率低于 $\alpha$”）到各级子声明和底层证据的逻辑联系。在这个框架中，仿真证据与另外两种关键证据——**分析证据 (analytical evidence)** 和 **经验证据 (empirical evidence)**——协同工作。

- **分析证据**：来自[数学证明](@entry_id:137161)，例如使用[控制屏障函数](@entry_id:177928) (CBF) 证明在某些假设下系统永远不会进入[不安全状态](@entry_id:756344)。这种证据提供了强有力的确定性保证，但其有效性严格依赖于其假设的成立。

- **经验证据**：来自物理样机的现场测试。这是关于真实世界性能最直接的证据，但通常成本高昂，且在部署前难以覆盖所有罕见场景。

- **仿真证据**：来自[数字孪生](@entry_id:171650)的测试。它可以经济高效地探索大量场景，特别是危险的边缘情况，但其可信度依赖于模型的保真度和前述的有效性假设。

一个健全的安全案例论证必须以一种原则性的方式**集成 (integrate)** 这三种证据。一个天真的方法，如简单地对各种“通过率”进行加权平均，是严重错误的。一个严谨的方法是采用**贝叶斯推断 (Bayesian inference)**。例如，我们可以为系统的[失效率](@entry_id:266388) $\theta$ 设定一个[先验分布](@entry_id:141376)，然后使用来自仿真、分析和物理测试的证据作为[似然函数](@entry_id:921601)来更新这个分布，得到一个后验分布。这个后验分布综合了所有信息，并量化了我们对系统安全性的最终置信度。

在集成过程中，最关键也最困难的挑战是处理不同证据来源之间的**依赖性 (dependence)**。例如，分析模型和仿真模型可能共享对系统动力学的相同（可能错误的）假设。如果一个假设是错误的，那么这两种证据的价值都会同时被削弱。一个强大的安全案例必须明确识别并处理这些依赖关系，例如通过在贝叶斯模型中对共享假设进行条件化，或在组合相关证据时采取保守的策略。最终，一个令人信服的安全案例通过这种方式，将仿真测试置于一个透明、严谨和可量化的保证框架之中。