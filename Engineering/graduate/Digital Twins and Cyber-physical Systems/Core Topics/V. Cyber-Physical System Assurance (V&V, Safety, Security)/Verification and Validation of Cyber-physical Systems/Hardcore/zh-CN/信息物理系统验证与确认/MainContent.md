## 引言
随着网络物理系统（Cyber-Physical Systems, CPS）在自动驾驶、航空航天和[智能制造](@entry_id:1131785)等关键领域的日益普及，确保其安全、可靠地运行已成为一项至关重要的挑战。传统的测试方法在面对这些系统前所未有的复杂性、自主性以及离散计算与连续物理动态的紧密耦合时，已显得力不从心。此外，工程实践中对“验证”（Verification）与“确认”（Validation）这两个核心概念的混淆，常常导致保障活动缺乏系统性和严谨性，留下了潜在的安全隐患。本文旨在填补这一知识鸿沟，为CPS的验证与确认提供一个全面而深入的框架。

在接下来的内容中，我们将分三步系统地展开讨论。首先，在“原理与机制”一章中，我们将奠定理论基础，深入剖析[验证与确认](@entry_id:1133775)的本质区别，介绍用于精确描述系统需求的形式化语言，并探讨如[可达性](@entry_id:271693)分析和演绎式证明等核心验证机制。随后，在“应用与跨学科连接”一章中，我们将把理论付诸实践，展示这些技术如何应用于从模型在环到[硬件在环](@entry_id:1125914)的整个开发生命周期，如何应对基于学习的组件带来的新挑战，以及如何构建满足行业标准（如[ISO 26262](@entry_id:1126786)）的安全案例。最后，通过“动手实践”部分，您将有机会亲手解决具体的验证问题，将所学知识转化为实践技能。

通过这一结构化的学习路径，读者将能够建立起对[CPS验证](@entry_id:1123177)与确认的系统性理解，掌握从理论到实践的关键方法，从而有能力为下一代智能系统构建可信的基石。

## 原理与机制

### 基本概念：[验证与确认](@entry_id:1133775)的二元性

在网络物理系统（Cyber-Physical Systems, CPS）的生命周期中，确保其按照预期安全、可靠地运行至关重要。这一保证过程的核心是两个既互补又截然不同的活动：**验证（Verification）**与**确认（Validation）**。尽管在日常用语中这两个词经常互换使用，但在[系统工程](@entry_id:180583)和形式化方法中，它们具有精确且截然不同的技术含义。理解它们的区别是掌握CPS可信保障的基石。

一个有效的方法是借助两个经典问题来区分它们：“我们是否正确地构建了系统？”（Are we building the system right?）和“我们是否构建了正确的系统？”（Are we building the right system?）。验证关注前者，而确认关注后者。

为了更深入地理解，我们可以建立一个形式化框架。考虑一个CPS，其组成部分包括物理设备 $P$、其计算控制器实现 $I$、用于设计和分析的设计模型 $M$（例如数字孪生），以及用[时序逻辑](@entry_id:181558)等形式化语言表述的需求规约 $\Sigma$。系统的行为可以用一个语义函数 $\llbracket \cdot \rrbracket$ 映射到行为空间 $\mathcal{B}$ 中。

**验证**是建立系统实现与其规约之间形式符合性的过程。它本质上是一个数学或逻辑活动，旨在[证明系统](@entry_id:156272)内部的正确性。验证活动通常包括两个主要部分：
1.  **模型验证**：证明设计模型 $M$ 满足形式规约 $\Sigma$。这表示为 $M \models \Sigma$，意味着模型的所有可能行为 $\llbracket M \rrbracket$ 都符合规约中定义的属性。
2.  **实现与模型的一致性**：证明实现 $I$ 的行为是模型 $M$ 行为的精确体现或细化。这可以用[一致性关系](@entry_id:157858) $I \preceq M$ 来表示，意味着 $\llbracket I \rrbracket \subseteq \llbracket M \rrbracket$（在适当的抽象映射下）。

成功验证的最终成果是得出诸如 $I \models \Sigma$ 的结论。这是一个**演绎（deductive）**声明：如果前提（例如 $M \models \Sigma$ 和 $I \preceq M$）为真，且[推理规则](@entry_id:273148)无误，那么结论必然为真。然而，验证本身并不对系统在真实世界中的适用性做出任何声明。一个被“验证”为正确的系统，其模型或规约可能完全错误地描述了现实世界的需求。

**确认**则是建立模型对于其预期用途和操作环境的经验充分性的过程。它旨在回答模型是否是现实世界的有效表征。这是一个**归纳（inductive）**活动，根本上依赖于经验数据。我们可以用一个经验充分性关系 $M \approx_D^U$ 来表示，它断言在特定的操作领域 $D$ 和预期用途 $U$ 下，模型 $M$ 相对于真实物理设备 $P$ 的预测误差是有界的。这个过程通常涉及：
1.  从真实系统 $P$ 在部分操作条件 $\Omega \subseteq D$ 下收集数据。
2.  比较模型 $M$ 的预测输出与真实数据。
3.  评估预测误差 $e(\llbracket M \rrbracket, \llbracket P \rrbracket)$ 是否在可接受的容差 $\epsilon$ 之内。
4.  量化与此结论相关的不确定性 $\mathcal{U}$（例如，统计[置信区间](@entry_id:142297)）。

确认得出的结论本质上是统计性的和归纳性的。它从在有限数据集 $\Omega$ 上的观察，推广到更广泛的操作领域 $D$。因此，确认无法提供绝对的保证，其结论总是伴随着量化的置信度。

从逻辑学的角度来看，这种区别更加清晰。验证关注的是在一个封闭的形式世界内，$M$ 的语言 $L(M)$ 是否是规约 $\varphi$ 所允许的语言的子集（即 $M \models \varphi$）。而确认关注的是，真实世界系统的行为 $\mathcal{W}$ 经过观测（可能带有噪声和不完整性）后，其轨迹 $h(\mathcal{W})$ 是否与模型的语言 $L(M)$ 一致。由于真实世界的行为空间 $\mathcal{W}$ 几乎总是无界的，并且观测 $h$ 总是不完美的，确认在逻辑意义上永远无法做到**完备（complete）**。我们永远无法通过有限次的实验来证明模型在所有可能情况下都是准确的。我们最多只能通过统计方法来约束错误率，例如，将确认问题构建为[统计假设检验](@entry_id:274987)，并控制假阳性率 $\alpha$ 和[假阴性率](@entry_id:911094) $\beta$。

总之，验证是在数学世界中寻求确定性证明，而确认是在物理世界中寻求带有[量化不确定性](@entry_id:272064)的证据。一个可信的CPS数字孪生必须同时经过严格的验证和彻底的确认。

### 规约的语言：形式化系统需求

验证的核心前提是存在一个精确、无[歧义](@entry_id:276744)的系统需求规约。口语化的需求（例如“系统应该是安全的”）对于形式化分析是无用的。我们需要一种数学语言来精确描述系统应有的行为和不应有的行为。时序逻辑（Temporal Logics）为此提供了强大的工具。

不同类型的需求需要不同的逻辑来表达。考虑一个自主移动机器人，其控制器以 $0.1$ 秒的周期采样和驱动。我们可以区分以下几类需求：

1.  **功能需求 (Functional Requirement)**：描述系统核心的逻辑功能和因果关系。这类需求通常涉及离散的事件和状态转换。例如，一个功能需求可能是：“每当控制器在采样时刻 $k$ 进入紧急状态（$\mathrm{EMERGENCY}[k]$ 为真）时，驱动器的使能位必须在下一个采样时刻 $k+1$ 被清除（$\mathrm{EN}[k+1]$ 为假）。” 这种需求只关心离散采样时刻的事件顺序，而不关心具体的[时间度](@entry_id:261965)量。**线性[时序逻辑](@entry_id:181558) (Linear Temporal Logic, LTL)** 非常适合描述这类性质。LTL提供了诸如 $G$（总是）、$F$（最终）、$X$（下一个）和 $U$（直到）等算子。上述需求可以精确地形式化为LTL公式：
    $$ G(\mathrm{EMERGENCY} \rightarrow X(\neg \mathrm{EN})) $$
    该公式意为“总是（Globally），如果 $\mathrm{EMERGENCY}$ 为真，则在下一个（Next）状态，$\mathrm{EN}$ 为非（not）真。”

2.  **安全需求 (Safety Requirement)**：断言系统永远不会进入“坏”状态。这类需求通常是“不变性（invariance）”属性。对于CPS，这些坏状态通常与物理世界的连续量有关。例如，一个安全需求可能是：“在所有真实时间 $t \ge 0$，机器人与最近障碍物的距离 $d(t)$ 必须始终保持在 $1.0$ 米以上。” 这里的关键是“始终”和“真实时间”，意味着这个属性必须在采样点之间也成立。LTL无法表达这种对连续时间和实值信号的约束。为此，我们需要**[信号时序逻辑](@entry_id:1131627) (Signal Temporal Logic, STL)**。STL是LTL的扩展，它允许对实值信号进行量化断言，并为其时序算子引入明确的时间界限。上述安全需求可以形式化为STL公式：
    $$ G_{[0, \infty)}(d(t) \ge 1.0) $$
    该公式意为“在时间区间 $[0, \infty)$ 内总是（Globally），信号 $d(t)$ 的值大于等于 $1.0$。”

3.  **性能需求 (Performance Requirement)**：量化系统应如何良好地执行其功能，通常涉及[响应时间](@entry_id:271485)、超调、[稳态误差](@entry_id:271143)等。这类需求本质上是关于连续信号在特定时间窗口内的量化行为。例如，一个性能需求可能是：“在速度参考指令从 $0$ 阶跃到 $1.0$ m/s 后，[跟踪误差](@entry_id:273267) $e(t)$ 必须在 $2$ 秒后保持在 $\pm 0.2$ m/s 内，并且整个过程中速度 $v(t)$ 的超调不得超过 $1.1$ m/s。” 这同样需要STL来形式化。该需求包含两个部分，可以用逻辑合取（$\wedge$）连接：
    $$ G_{[2, \infty)}(|e(t)| \le 0.2) \wedge G_{[0, \infty)}(v(t) \le 1.1) $$
    第一个子句规定了[稳态](@entry_id:139253)性能（在 $t=2$ 之后），第二个子句规定了整个过程中的超调限制。

通过使用LTL和STL等形式化语言，我们可以将模糊的需求转化为可供数学分析和算法验证的精确规约 $\varphi$。

### 面向验证的建模：混成系统

一旦我们有了形式化的规约，我们就需要一个同样形式化的系统模型来进行验证。CPS的显著特征是离散的计算逻辑与连续的物理动态之间的紧密交互。**混成自动机 (Hybrid Automaton)** 是捕捉这种混合动态的经典模型。

让我们通过一个楼宇恒温控制器来理解混成自动机的构成。该系统旨在将房间温度 $x(t)$ 维持在下限 $\theta_\ell$ 和上限 $\theta_h$ 之间。

一个混成自动机 $H$ 由以下组件定义：

*   **离散模式 (Discrete Modes, $Q$)**：表示系统的不同操作状态。在[恒温器](@entry_id:143395)示例中，我们有两个模式：$Q = \{q_h, q_i\}$，分别代表“加热器开启”和“加热器关闭”。

*   **[连续状态空间](@entry_id:276130) (Continuous State Space, $X$)**：由描述系统物理状态的连续变量组成。这里是房间温度 $x$，因此 $X = \mathbb{R}$。

*   **连续动态 (Continuous Dynamics, $f$)**：为每个离散[模式指定](@entry_id:920302)一个常微分方程（ODE），描述连续状态如何随时间演化。当加热器开启时（模式 $q_h$），温度变化遵循 $\dot{x}(t) = -a(x(t) - T_{\mathrm{env}}) + p$（其中 $T_{\mathrm{env}}$ 是环境温度，$a$ 是热[损失系数](@entry_id:276929)，$p$ 是加热功率）。当加热器关闭时（模式 $q_i$），动态为 $\dot{x}(t) = -a(x(t) - T_{\mathrm{env}})$。

*   **不变集 (Invariants, $\mathrm{Inv}$)**：为每个模式定义一个区域，连续状态只能在该区域内演化。这是强制发生离散转换的关键。在[恒温器](@entry_id:143395)中，为了防止温度超过 $\theta_h$，我们规定在“加热器开启”模式 $q_h$ 下，必须始终满足 $x \le \theta_h$。因此，$\mathrm{Inv}(q_h) = \{x \in \mathbb{R} \mid x \le \theta_h\}$。同理，为防止温度低于 $\theta_\ell$，在“加热器关闭”模式 $q_i$ 下，[不变集](@entry_id:275226)为 $\mathrm{Inv}(q_i) = \{x \in \mathbb{R} \mid x \ge \theta_\ell\}$。

*   **转移边 (Edges, $E$) 与守卫 (Guards, $G$)**：边代表从一个模式到另一个模式的离散跳转。守卫是定义在边上的条件，只有当连续状态满足守卫条件时，跳转才可能发生。[恒温器](@entry_id:143395)逻辑规定当温度达到或超过 $\theta_h$ 时关闭加热器，这对应于一条从 $q_h$ 到 $q_i$ 的边 $e_{hi}$，其守卫为 $G(e_{hi}) = \{x \in \mathbb{R} \mid x \ge \theta_h\}$。类似地，当温度达到或低于 $\theta_\ell$ 时开启加热器，对应于一条从 $q_i$ 到 $q_h$ 的边 $e_{ih}$，其守卫为 $G(e_{ih}) = \{x \in \mathbb{R} \mid x \le \theta_\ell\}$。

*   **重置映射 (Reset Maps, $R$)**：定义在离散跳转发生时，连续状态如何被更新。对于具有物理惯性的变量（如温度），状态不能瞬时改变。因此，在[恒温器](@entry_id:143395)示例中，重置映射是[恒等函数](@entry_id:152136)：$R(e, x) = x$。

系统的**执行语义**由**混成轨迹**定义，它是一系列连续流（flow）和离散跳转（jump）的交替序列。在每个模式中，系统状态沿ODE定义的向量场连续演化，直到它到达不变集的边界。此时，如果它同时满足了某条出边的守卫条件，就会发生一个离散跳转，系统切换到新模式，连续状态根据重置映射进行更新，然后开始新的连续演化。

这种混成自动机模型，或其更抽象的泛化形式——**状态标记的转移系统** $\mathcal{M} = (S, S_0, \rightarrow, L)$，为我们提供了一个精确的数学对象，使得验证问题“模型是否满足规约？”（即 $\mathcal{M} \models \varphi$）变得明确可解。

### 核心验证机制

形式化地，验证目标 $\mathcal{M} \models \varphi$ 的含义是：对于模型 $\mathcal{M}$ 的**所有**可能的行为（或称为“运行” $\rho$），其对应的观测轨迹 $w(\rho)$ 都必须满足规约 $\varphi$。这种**全称量化**是验证的核心，即我们必须保证在任何允许的[非确定性](@entry_id:273591)选择下，系统都不会违反规约。为了实现这一目标，发展出了两大类验证技术。

#### 探索式方法：模型检测与[可达性](@entry_id:271693)分析

模型检测（Model Checking）的基本思想是系统性地探索模型的所有可能状态，检查是否有任何状态违反了规约。对于具有无限状态（例如连续状态）的CPS，我们无法穷举所有状态，但我们可以转而探索状态的**集合**。

**可达性分析（Reachability Analysis）**是模型检测的核心机制，尤其适用于安全属性的验证。其目标是计算或过近似（over-approximate）从初始状态集 $X_0$ 出发，系统在所有时间能到达的所有状态的集合。在时间 $\tau$ 的**[可达集](@entry_id:276191)** $R(\tau; X_0)$ 是所有在 $\tau$ 时刻可达的状态的集合。在时间区间 $[0, T]$ 上的**流管（flowpipe）**是该区间内所有可达集的并集，即 $R([0,T]; X_0) = \bigcup_{t \in [0,T]} R(t; X_0)$。如果计算出的流管（或其过近似）与预定义的不安全区域没有交集，那么系统的安全性就得到了证明。

由于精确计算[非线性](@entry_id:637147)或混成系统的可达集通常是不可解的，实际算法依赖于**过近似**。这意味着我们计算一个包含真实[可达集](@entry_id:276191)的更大集合。如果这个过近似集是安全的，那么真实的[可达集](@entry_id:276191)也必然是安全的。这保证了方法的**可靠性（soundness）**。常用的几何表示形式包括：

*   **多胞体 (Polytopes)**：由有限个[半空间](@entry_id:634770)的交集或有限个顶点的[凸包](@entry_id:262864)定义。它们在表达[线性变换](@entry_id:149133)方面表现良好。
*   **带状体 (Zonotopes)**：一种[中心对称的](@entry_id:1122209)特殊[多胞体](@entry_id:635589)，对[线性映射](@entry_id:185132)和[闵可夫斯基和](@entry_id:176841)（Minkowski sum）具有[闭包](@entry_id:148169)性，这使得它们在分析具有有界输入的线性系统时特别高效。
*   **[泰勒模型](@entry_id:203285) (Taylor Models)**：对于[非线性](@entry_id:637147)动态，[泰勒模型](@entry_id:203285)将一个区域的像表示为一个高阶[泰勒多项式](@entry_id:162010)逼近加上一个严格的区间余项。这种方法可以提供对[非线性](@entry_id:637147)流的高精度、有保证的包裹。

#### 演绎式方法：定理证明与抽象

与探索所有状态相反，演绎式方法（Deductive Methods）试图通过逻辑推理来构造一个关于系统属性的[数学证明](@entry_id:137161)。

**壁垒证书 (Barrier Certificates)** 是证明安全[不变性](@entry_id:140168)的强大工具，可被视为[连续系统](@entry_id:178397)中的归纳不变式（inductive invariant）。假设我们的安全集 $\mathcal{S}$ 被定义为一个[连续可微函数](@entry_id:200349) $B(x)$ 的零水平子集，即 $\mathcal{S} = \{x \in \mathbb{R}^n \mid B(x) \le 0\}$。要证明 $\mathcal{S}$ 是前向不变的，即从 $\mathcal{S}$ 内开始的轨迹永远不会离开它，我们只需找到一个满足以下条件的壁垒证书 $B(x)$：
1.  **初始化条件**：所有初始状态都在安全集内，即对于所有 $x \in \mathcal{X}_0$，有 $B(x) \le 0$。
2.  **流条件**：在安全集的边界上（即 $B(x)=0$），系统的向量场 $f(x)$ 不能指向安全集外部。数学上，这意味着在边界上，$B(x)$ 沿 $f(x)$ 的[方向导数](@entry_id:189133)非正：$\nabla B(x) \cdot f(x) \le 0$。
3.  **跳转条件**：任何从安[全集](@entry_id:264200)内部开始的离散跳转，其落点也必须在安[全集](@entry_id:264200)内部。即对于任何满足 $B(x) \le 0$ 的跳转前状态 $x$，跳转后的状态 $g(x)$ 必须满足 $B(g(x)) \le 0$。

如果能找到这样一个函数 $B(x)$，就相当于构造了一个“壁垒”，阻止了[系统轨迹](@entry_id:1132840)逃[逸出](@entry_id:141194)安全区域。

**抽象解释 (Abstract Interpretation)** 为所有基于近似的分析方法提供了统一的理论基础。其核心思想是在一个更简单、更抽象的域（domain）中对系统动态进行分析，并确保抽象分析的结果能可靠地映射回具体的系统。这种关系由一个**伽罗瓦连接 (Galois Connection)** 来形式化，它由一对映射 $(\alpha, \gamma)$ 组成：
*   **抽象函数 $\alpha: C \to A$**：将具体域 $C$（例如，$\mathbb{R}^n$ 的子集）中的[元素映射](@entry_id:157675)到抽象域 $A$（例如，区间、[多胞体](@entry_id:635589)）中的元素。
*   **具体化函数 $\gamma: A \to C$**：将抽象[元素映射](@entry_id:157675)回具体域。

对于用于证明安全性的过[近似分析](@entry_id:160272)，伽罗瓦连接必须满足 $\alpha(c) \sqsubseteq_A a \iff c \subseteq \gamma(a)$，其中 $\sqsubseteq_A$ 是抽象域上的[序关系](@entry_id:138937)。这确保了 $\gamma(\alpha(c))$ 总是包含（过近似）原始具[体元](@entry_id:267802)素 $c$。

抽象解释的可靠性依赖于**抽象算子**的可靠性。例如，一个抽象的后继状态算子 `Post^\#` 必须可靠地过近似具体系统的后继状态算子 `Post`，即满足：$\alpha(\mathrm{Post}(c)) \sqsubseteq_A \mathrm{Post}^\#(\alpha(c))$。可达性分析中使用的各种几何集合（多胞体、带状体等）上的操作，都可以被视为在这个严格的数学框架下的具体实例。

### 规模化验证：基于合约的[组合推理](@entry_id:1122749)

随着系统复杂性的增长，对整个系统进行整体（monolithic）验证变得不可行。**[组合推理](@entry_id:1122749) (Compositional Reasoning)** 提供了一条出路，它允许我们通过验证单个组件并组合其结果来推断整个系统的属性。**[假设-保证合约](@entry_id:1121149) (Assume-Guarantee Contracts)** 是实现[组合推理](@entry_id:1122749)的关键机制。

一个组件的合约 $(A, G)$ 由两部分组成：
*   **假设 (Assumption, $A$)**：对组件所处环境行为的约束。组件只承诺在环境遵守这些假设时才正常工作。
*   **保证 (Guarantee, $G$)**：组件对自身行为的承诺。

一个实现 $I$ 满足合约 $(A, G)$ 的形式化语义是：对于**所有**遵守假设 $A$ 的环境 $E$，实现 $I$ 与环境 $E$ 的组合 $I \,\|\, E$ 必须满足保证 $G$。这可以写作：
$$ \forall E. \; (E \models A) \Rightarrow (I \,\|\, E \models G) $$
这种方法将全局验证[问题分解](@entry_id:272624)为一系列局部的、更易于处理的组件级验证任务，是构建可信的大型CPS的关键策略。

### 连接现实的桥梁：确认中的不确定性

最后，我们必须回到验证与确认的二元性。无论我们的形式化模型和验证过程多么精妙，它们都只是对现实世界的抽象。确认过程旨在量化模型与现实之间的差距，而这种差距的核心来源是**不确定性**。在CPS的V：

1.  **[偶然不确定性](@entry_id:634772) (Aleatoric Uncertainty)**：源于系统固有的、不可避免的随机性。即使我们拥有完美的模型和参数知识，这种不确定性依然存在。典型的例子是传感器的物理噪声 $\varepsilon(t)$。我们也许能通过实验精确地刻画其[统计分布](@entry_id:182030)（例如，均值和方差），但无法消除单次测量中的随机波动。在系统运行层面，环境的随机变化（如室外温度的波动）也属于[偶然不确定性](@entry_id:634772)。这种不确定性是**不可约减的**。

2.  **认知不确定性 (Epistemic Uncertainty)**：源于我们知识的缺乏或不完整。这包括对模型结构的不确定（例如，忽略了某些物理效应）、对模型参数值的不确定（例如，一个未知的执行器增益 $k_a$），或者对初始状态的不确定。原则上，认知不确定性是**可以约减的**——通过更多的实验数据、更精细的系统辨识或改进的模型结构。例如，通过系统辨识实验，我们可以逐步缩小对参数 $k_a$ 的估计范围。

在现代VV流程中，对这两种不确定性进行显式建模和量化是评估系统可信度的关键一环。