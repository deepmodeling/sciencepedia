{
    "hands_on_practices": [
        {
            "introduction": "在联合仿真中，功能模型单元（FMU）在离散的通信点交换数据。然而，在两个通信点之间，接收端 FMU 需要对输入信号进行重构。本练习旨在通过推导不同重构方案（如零阶保持、一阶保持）下的局部截断误差，深入理解这一实践选择对仿真精度的理论影响 ()。",
            "id": "4208494",
            "problem": "两个功能模型单元 (FMU) 之间的协同仿真在通信时刻 $t=0$ 和 $t=h$ 交换输入信号 $u(t)$，其中 $h>0$ 是宏步长。接收端 FMU 实现了一个单输入单输出的线性时不变常微分方程 (ODE)，其连续时间模型为\n$$\n\\frac{d x(t)}{d t} = a\\, x(t) + b\\, u(t),\n$$\n其中参数 $a \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$ 为常数，初始状态 $x(0)$ 已知。在通信点之间，主控算法通过以下时域方案之一在区间 $t \\in [0,h]$ 上重构输入 $u(t)$：\n- 零阶保持 (ZOH)：$u_{\\mathrm{ZOH}}(t) = u(0)$，\n- 一阶保持 (FOH)：$u_{\\mathrm{FOH}}(t)$ 是唯一的仿射函数，满足 $u_{\\mathrm{FOH}}(0) = u(0)$ 且 $u_{\\mathrm{FOH}}(h) = u(h)$，\n- 二次多项式插值：$u_{\\mathrm{QP}}(t)$ 是对 $u(0)$、$u(h/2)$ 和 $u(h)$ 进行插值的唯一的至多二次多项式。\n\n假设 $u(t)$ 在 $t=0$ 的一个邻域上三阶连续可微，其在 $t=0$ 处的泰勒展开式为\n$$\nu(t) = u(0) + u^{(1)}(0)\\, t + \\frac{u^{(2)}(0)}{2}\\, t^{2} + \\frac{u^{(3)}(0)}{6}\\, t^{3} + \\mathcal{O}(t^{4}),\n$$\n其中 $u^{(k)}(0)$ 表示 $u(t)$ 在 $t=0$ 处的 $k$ 阶时间导数。假设对于所提供的输入重构，FMU 的内部积分器是精确的，因此在 $[0,h]$ 上局部截断误差的唯一来源是输入近似。\n\n从线性常微分方程的基本定义和成熟公式出发，推导并比较对于这三种方案，在时刻 $t=h$ 由输入引起的状态局部截断误差（记为 $\\Delta x(h) = x_{\\mathrm{approx}}(h) - x_{\\mathrm{exact}}(h)$）关于 $h$ 的主阶行为。然后，显式计算一阶保持方案下 $\\Delta x(h)$ 的主阶项，用 $a$、$b$、$h$ 和 $u^{(k)}(0)$ 表示。\n\n你的最终答案必须是针对一阶保持情况下 $\\Delta x(h)$ 的主阶项的单个闭式解析表达式。无需四舍五入，最终方框内的表达式不应包含单位。",
            "solution": "该系统由以下线性时不变常微分方程控制\n$$\n\\frac{d x(t)}{d t} = a\\, x(t) + b\\, u(t).\n$$\n对于任意输入 $v(t)$ 和初始条件 $x(0)$，在 $t=h$ 时的精确解可以用常数变易法公式写出：\n$$\nx(h) = \\exp(a h)\\, x(0) + b \\int_{0}^{h} \\exp\\!\\big(a(h - \\tau)\\big)\\, v(\\tau)\\, d\\tau.\n$$\n在我们的设定中，假定内部积分器对于所提供的输入重构是精确的，因此 FMU 在近似输入 $u_{\\mathrm{approx}}(t)$ 下计算出的状态将是\n$$\nx_{\\mathrm{approx}}(h) = \\exp(a h)\\, x(0) + b \\int_{0}^{h} \\exp\\!\\big(a(h - \\tau)\\big)\\, u_{\\mathrm{approx}}(\\tau)\\, d\\tau.\n$$\n使用真实输入 $u(t)$ 的精确状态是\n$$\nx_{\\mathrm{exact}}(h) = \\exp(a h)\\, x(0) + b \\int_{0}^{h} \\exp\\!\\big(a(h - \\tau)\\big)\\, u(\\tau)\\, d\\tau.\n$$\n因此，在 $t=h$ 时由输入引起的局部截断误差为\n$$\n\\Delta x(h) \\equiv x_{\\mathrm{approx}}(h) - x_{\\mathrm{exact}}(h) = b \\int_{0}^{h} \\exp\\!\\big(a(h - \\tau)\\big)\\, \\big(u_{\\mathrm{approx}}(\\tau) - u(\\tau)\\big)\\, d\\tau.\n$$\n\n我们现在分析这三种方案中关于 $h$ 的主阶行为。在整个过程中，我们使用 $u(\\tau)$ 在 $\\tau=0$ 附近的泰勒展开：\n$$\nu(\\tau) = u(0) + u^{(1)}(0)\\, \\tau + \\frac{u^{(2)}(0)}{2}\\, \\tau^{2} + \\frac{u^{(3)}(0)}{6}\\, \\tau^{3} + \\mathcal{O}(\\tau^{4}).\n$$\n我们还将指数因子对小 $h$ 展开为\n$$\n\\exp\\!\\big(a(h - \\tau)\\big) = 1 + a(h - \\tau) + \\frac{a^{2}}{2}(h - \\tau)^{2} + \\mathcal{O}(h^{3}),\n$$\n并且注意到，因为我们的目标是 $\\Delta x(h)$ 中关于 $h$ 的主阶项，指数项中的高阶修正项贡献的 $h$ 的阶数高于由输入重构差异引起的主阶项，因此在确定第一个非零项时可以忽略。\n\n零阶保持 (ZOH)：$u_{\\mathrm{ZOH}}(\\tau) = u(0)$。差值为\n$$\nu_{\\mathrm{ZOH}}(\\tau) - u(\\tau) = - u^{(1)}(0)\\, \\tau - \\frac{u^{(2)}(0)}{2}\\, \\tau^{2} - \\frac{u^{(3)}(0)}{6}\\, \\tau^{3} + \\mathcal{O}(\\tau^{4}).\n$$\n将指数因子取为 $1$ 以提取主阶项，我们有\n$$\n\\Delta x_{\\mathrm{ZOH}}(h) \\approx b \\int_{0}^{h} \\big(- u^{(1)}(0)\\, \\tau - \\frac{u^{(2)}(0)}{2}\\, \\tau^{2}\\big)\\, d\\tau = b \\left( - u^{(1)}(0)\\, \\frac{h^{2}}{2} - \\frac{u^{(2)}(0)}{2}\\, \\frac{h^{3}}{3} \\right) + \\mathcal{O}(h^{4}),\n$$\n所以主阶项是 $h^{2}$ 阶，等于 $- b\\, u^{(1)}(0)\\, h^{2}/2$。\n\n一阶保持 (FOH)：让我们将 $u_{\\mathrm{FOH}}(\\tau)$ 定义为匹配 $u(0)$ 和 $u(h)$ 的仿射函数。用其泰勒展开表示 $u(h)$，\n$$\nu(h) = u(0) + u^{(1)}(0)\\, h + \\frac{u^{(2)}(0)}{2}\\, h^{2} + \\frac{u^{(3)}(0)}{6}\\, h^{3} + \\mathcal{O}(h^{4}),\n$$\n线性插值的斜率为\n$$\ns(h) = \\frac{u(h) - u(0)}{h} = u^{(1)}(0) + \\frac{u^{(2)}(0)}{2}\\, h + \\frac{u^{(3)}(0)}{6}\\, h^{2} + \\mathcal{O}(h^{3}).\n$$\n因此，\n$$\nu_{\\mathrm{FOH}}(\\tau) = u(0) + s(h)\\, \\tau = u(0) + u^{(1)}(0)\\, \\tau + \\frac{u^{(2)}(0)}{2}\\, h\\, \\tau + \\frac{u^{(3)}(0)}{6}\\, h^{2}\\, \\tau + \\mathcal{O}(h^{3}\\tau).\n$$\n减去真实输入，\n$$\nu_{\\mathrm{FOH}}(\\tau) - u(\\tau) = \\frac{u^{(2)}(0)}{2}\\, \\big(h\\, \\tau - \\tau^{2}\\big) + \\frac{u^{(3)}(0)}{6}\\, \\big(h^{2}\\, \\tau - \\tau^{3}\\big) + \\mathcal{O}(h^{3}\\tau, \\tau^{4}).\n$$\n对主阶项使用 $\\exp\\!\\big(a(h - \\tau)\\big) = 1 + \\mathcal{O}(h)$，我们得到\n$$\n\\Delta x_{\\mathrm{FOH}}(h) \\approx b \\int_{0}^{h} \\left[ \\frac{u^{(2)}(0)}{2}\\, \\big(h\\, \\tau - \\tau^{2}\\big) \\right] d\\tau + \\text{高阶项}.\n$$\n该积分计算结果为\n$$\n\\int_{0}^{h} \\big(h\\, \\tau - \\tau^{2}\\big)\\, d\\tau = \\left[ \\frac{h\\, \\tau^{2}}{2} - \\frac{\\tau^{3}}{3} \\right]_{0}^{h} = \\frac{h^{3}}{2} - \\frac{h^{3}}{3} = \\frac{h^{3}}{6}.\n$$\n因此，\n$$\n\\Delta x_{\\mathrm{FOH}}(h) = b\\, \\frac{u^{(2)}(0)}{2}\\, \\frac{h^{3}}{6} + \\mathcal{O}(h^{4}) = b\\, \\frac{u^{(2)}(0)}{12}\\, h^{3} + \\mathcal{O}(h^{4}).\n$$\n我们必须验证，来自指数因子的被忽略的贡献不会改变主阶项。包括一阶修正项，\n$$\n\\exp\\!\\big(a(h - \\tau)\\big) = 1 + a(h - \\tau) + \\mathcal{O}(h^{2}),\n$$\n从而\n$$\n\\int_{0}^{h} a(h - \\tau)\\, \\left[ \\frac{u^{(2)}(0)}{2}\\, \\big(h\\, \\tau - \\tau^{2}\\big) \\right] d\\tau = a\\, \\frac{u^{(2)}(0)}{2} \\left[ h \\int_{0}^{h} \\big(h\\, \\tau - \\tau^{2}\\big) d\\tau - \\int_{0}^{h} \\tau \\big(h\\, \\tau - \\tau^{2}\\big) d\\tau \\right].\n$$\n我们已经计算过 $\\int_{0}^{h} \\big(h\\, \\tau - \\tau^{2}\\big) d\\tau = h^{3}/6$。另外，\n$$\n\\int_{0}^{h} \\tau \\big(h\\, \\tau - \\tau^{2}\\big)\\, d\\tau = \\int_{0}^{h} \\big(h\\, \\tau^{2} - \\tau^{3}\\big)\\, d\\tau = h\\, \\frac{h^{3}}{3} - \\frac{h^{4}}{4} = \\frac{h^{4}}{3} - \\frac{h^{4}}{4} = \\frac{h^{4}}{12}.\n$$\n因此修正项为\n$$\na\\, \\frac{u^{(2)}(0)}{2} \\left[ h \\cdot \\frac{h^{3}}{6} - \\frac{h^{4}}{12} \\right] = a\\, \\frac{u^{(2)}(0)}{2} \\left[ \\frac{h^{4}}{6} - \\frac{h^{4}}{12} \\right] = a\\, \\frac{u^{(2)}(0)}{2} \\cdot \\frac{h^{4}}{12} = \\frac{a\\, u^{(2)}(0)}{24}\\, h^{4},\n$$\n它是 $h^{4}$ 阶的，因此不影响主阶项。因此 FOH 的主阶项最终确定为\n$$\n\\Delta x_{\\mathrm{FOH}}(h) = b\\, \\frac{u^{(2)}(0)}{12}\\, h^{3} + \\mathcal{O}(h^{4}).\n$$\n\n使用节点 $0$、$h/2$ 和 $h$ 的二次多项式插值 (QP)：在点 $\\tau \\in [0,h]$ 处，一个二次拉格朗日插值的插值误差由标准余项公式给出\n$$\nu_{\\mathrm{QP}}(\\tau) - u(\\tau) = \\frac{u^{(3)}(\\xi_{\\tau})}{3!}\\, (\\tau - 0)\\, \\left(\\tau - \\frac{h}{2}\\right)\\, (\\tau - h),\n$$\n对于某个 $\\xi_{\\tau} \\in (0,h)$。因此在 $[0,h]$ 上一致地有 $u_{\\mathrm{QP}}(\\tau) - u(\\tau) = \\mathcal{O}(h^{3})$。对指数因子进行积分，$\\Delta x_{\\mathrm{QP}}(h)$ 的主阶贡献的量级为\n$$\n\\Delta x_{\\mathrm{QP}}(h) = b \\int_{0}^{h} \\exp\\!\\big(a(h - \\tau)\\big)\\, \\mathcal{O}(h^{3})\\, d\\tau = \\mathcal{O}(h^{4}),\n$$\n当在 $0$ 附近展开 $u^{(3)}(\\xi_{\\tau})$ 时，显式的主阶项与 $u^{(3)}(0)\\, h^{4}$ 成正比。\n\n阶数总结：\n- 零阶保持得到 $\\Delta x_{\\mathrm{ZOH}}(h) = - b\\, \\frac{u^{(1)}(0)}{2}\\, h^{2} + \\mathcal{O}(h^{3})$；主阶为 $h^{2}$。\n- 一阶保持得到 $\\Delta x_{\\mathrm{FOH}}(h) = b\\, \\frac{u^{(2)}(0)}{12}\\, h^{3} + \\mathcal{O}(h^{4})$；主阶为 $h^{3}$。\n- 二次多项式插值得到 $\\Delta x_{\\mathrm{QP}}(h) = \\mathcal{O}(h^{4})$，其主阶项与 $u^{(3)}(0)\\, h^{4}$ 成正比。\n\n所要求的一阶保持方案的显式主阶项是\n$$\nb\\, \\frac{u^{(2)}(0)}{12}\\, h^{3}.\n$$",
            "answer": "$$\\boxed{b\\,\\frac{u^{(2)}(0)}{12}\\,h^{3}}$$"
        },
        {
            "introduction": "联合仿真主算法（master）的一项核心任务是选择一个合适的“宏观步长”（macro-step）来推进全局仿真时间。一个关键挑战是确保该步长不会“越过”由单个 FMU 生成的重要离散事件。本练习将演示如何利用 FMI 标准提供的信息（如下一个事件发生时间），并考虑时钟同步误差，来计算最大安全步长，从而保证不错过任何事件 ()。",
            "id": "4208538",
            "problem": "一个数字孪生协同仿真主控使用功能模型接口 (FMI) 来协调四个功能模型单元 (FMU) 的多速率耦合。在多速率设置中，来自不同 FMU 的离散事件发生在不同的时间点，如果一个宏观步长超过了某个 FMU 最早可能发生事件的时间，这些事件就可能会被错过。FMI 标准为每个 FMU 提供了两个相关量以避免错过事件：(i) 用于预定激活（周期性或外部预定）的时间戳，以及 (ii) 在恒定输入假设下，报告 FMU 可能需要离散更新的最早时间的下一事件时间信号。假设时钟同步误差是有界的，并通过从每个 FMU 报告的时间中减去最大偏移量来进行保守计算。\n\n从核心定义出发——离散事件是在宏观步长边界上必须同步的不连续点，时间戳在主控时间上是单调的，并且下一事件时间是在恒定输入下下一个事件的下界——推导出在当前主控时间 $t_0$ 选择的宏观步长 $h$ 必须满足的条件，以确保所有 FMU 的离散事件都不会被错过。然后，将您的推导应用于以下协同仿真快照。\n\n当前主控时间为 $t_0 = 12.500\\ \\mathrm{s}$。各 FMU 报告如下：\n\n- FMU A（带有受保护过零检测的连续对象）：下一事件时间 $t_{\\mathrm{NE},A} = 12.533\\ \\mathrm{s}$；最大时钟偏移量 $\\Delta_A = 0.0015\\ \\mathrm{s}$。\n\n- FMU B（周期性采样控制器）：采样周期 $T_B = 0.008\\ \\mathrm{s}$；上一次采样发生在 $12.496\\ \\mathrm{s}$，因此下一个本地时间戳为 $t_{\\mathrm{stamp},B} = 12.504\\ \\mathrm{s}$；最大时钟偏移量 $\\Delta_B = 0.0005\\ \\mathrm{s}$。\n\n- FMU C（带有预测边界的事件驱动传感器）：下一个事件将发生在本地时间区间 $[12.512\\ \\mathrm{s}, 12.514\\ \\mathrm{s}]$ 内；报告的下一事件时间是下界 $t_{\\mathrm{NE},C} = 12.512\\ \\mathrm{s}$；最大时钟偏移量 $\\Delta_C = 0.0010\\ \\mathrm{s}$。\n\n- FMU D（带有抖动的网络调度器）：下一个本地标称发布时间为 $12.520\\ \\mathrm{s}$，带有 $\\pm 0.003\\ \\mathrm{s}$ 的有界抖动；因此最早的本地发布时间为 $t_{\\mathrm{stamp},D} = 12.517\\ \\mathrm{s}$；最大时钟偏移量 $\\Delta_D = 0.0020\\ \\mathrm{s}$。\n\n使用您推导出的条件，计算在此快照中避免错过任何离散事件的最大安全宏观步长 $h_{\\max}$。将最终步长以秒（$\\mathrm{s}$）表示，并将您的答案四舍五入到四位有效数字。",
            "solution": "目标是确保协同仿真主控选择的宏观步长不会让仿真时间越过任何 FMU 可能触发离散事件的时间点。推导的基本依据如下：\n\n1. 离散事件是在宏观步长边界上必须同步的不连续点，这意味着协同仿真主控必须在所有 FMU 中最早可能发生离散事件的时间或之前结束一个宏观步长。\n\n2. FMU 为预定激活生成的时间戳在主控时间上是单调的，并指示需要进行离散交互的特定时刻。\n\n3. FMU 提供的下一事件时间是在恒定输入下最早下一事件时间的下界。为了在多速率设置中采取保守策略，协同仿真主控必须假设此事件可以在该下界或之后的任何时间发生，而不是更晚。\n\n4. 在时钟同步误差有界的情况下，如果一个 FMU 报告的最早事件或时间戳的本地时间为 $t_i$，且相对于主控时间的最大偏移量为 $\\Delta_i$，那么在主控时间框架下该事件可能发生的最早时间是 $t_i - \\Delta_i$，因为该 FMU 的本地时钟可能比主控时钟快最多 $\\Delta_i$。\n\n设协同仿真主控的当前时间为 $t_0$。对于每个 FMU $i$，将主控时间框架中的保守最早事件视界定义为\n$$\nt_{\\mathrm{safe}, i} = t_i - \\Delta_i,\n$$\n其中 $t_i$ 是 FMU 的下一个时间戳 $t_{\\mathrm{stamp}, i}$（用于周期性或外部驱动的预定事件）或其下一事件时间 $t_{\\mathrm{NE}, i}$（用于内部预测的事件），取两者中适用于最早离散交互要求的那一个。\n\n为避免错过任何离散事件，宏观步长 $h$ 必须满足\n$$\nt_0 + h \\leq \\min_i t_{\\mathrm{safe}, i}.\n$$\n因此，最大安全宏观步长为\n$$\nh_{\\max} = \\min_i t_{\\mathrm{safe}, i} - t_0.\n$$\n\n现在我们将此应用于给定的快照。\n\n- FMU A: $t_{\\mathrm{NE}, A} = 12.533\\ \\mathrm{s}$, $\\Delta_A = 0.0015\\ \\mathrm{s}$。因此，\n$$\nt_{\\mathrm{safe}, A} = 12.533 - 0.0015 = 12.5315\\ \\mathrm{s}.\n$$\n\n- FMU B: 周期性采样周期 $T_B = 0.008\\ \\mathrm{s}$；上一次采样在 $12.496\\ \\mathrm{s}$，所以\n$$\nt_{\\mathrm{stamp}, B} = 12.496 + 0.008 = 12.504\\ \\mathrm{s}.\n$$\n考虑到 $\\Delta_B = 0.0005\\ \\mathrm{s}$，\n$$\nt_{\\mathrm{safe}, B} = 12.504 - 0.0005 = 12.5035\\ \\mathrm{s}.\n$$\n\n- FMU C: 报告的下界 $t_{\\mathrm{NE}, C} = 12.512\\ \\mathrm{s}$，$\\Delta_C = 0.0010\\ \\mathrm{s}$。因此，\n$$\nt_{\\mathrm{safe}, C} = 12.512 - 0.0010 = 12.511\\ \\mathrm{s}.\n$$\n\n- FMU D: 最早本地发布时间 $t_{\\mathrm{stamp}, D} = 12.517\\ \\mathrm{s}$（已考虑抖动），$\\Delta_D = 0.0020\\ \\mathrm{s}$。因此，\n$$\nt_{\\mathrm{safe}, D} = 12.517 - 0.0020 = 12.515\\ \\mathrm{s}.\n$$\n\n计算这些保守视界的最小值：\n$$\n\\min_i t_{\\mathrm{safe}, i} = \\min\\{12.5315,\\ 12.5035,\\ 12.511,\\ 12.515\\} = 12.5035\\ \\mathrm{s}.\n$$\n\n因此，\n$$\nh_{\\max} = 12.5035 - 12.500 = 0.0035\\ \\mathrm{s}.\n$$\n\n将 $0.0035\\ \\mathrm{s}$ 四舍五入到四位有效数字，步长变为\n$$\n3.500 \\times 10^{-3}.\n$$",
            "answer": "$$\\boxed{3.500 \\times 10^{-3}}$$"
        },
        {
            "introduction": "当 FMU 的输出瞬时依赖于其输入时，会形成“代数环”（algebraic loop），这是联合仿真中的一个常见难题。解决代数环需要在单个时间步内进行迭代求解。本练习将探索一种名为“撕裂”（tearing）的强大技术，通过策略性地选择部分变量来打破循环，并通过设计算法寻找最优撕裂集，从而直观地理解其在迭代求解的收敛速度与数值稳定性之间的权衡 ()。",
            "id": "4208462",
            "problem": "给定一个耦合代数系统，该系统源于在功能样机接口（Functional Mock-up Interface, FMI）标准下对协同仿真互联进行的线性化。在此背景下，多个功能样机单元（Functional Mock-up Units, FMUs）在单个宏观步长内交换输入和输出，从而导致代数环路。一种经典方法是执行撕裂（tearing）：选择一个变量子集进行隐式求解，从而打破环路并实现分块迭代求解。考虑一个线性化残差系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$x \\in \\mathbb{R}^{n}$，且 $b \\in \\mathbb{R}^{n}$。一种撕裂策略会选择一个大小为 $k$ 的索引集 $T \\subset \\{0,1,\\dots,n-1\\}$（撕裂变量），其保留集为 $R = \\{0,1,\\dots,n-1\\} \\setminus T$。设矩阵 $A$ 根据 $T$ 在前、$R$ 在后的顺序置换为分块形式：\n$$\nA =\n\\begin{bmatrix}\nA_{TT} & A_{TR} \\\\\nA_{RT} & A_{RR}\n\\end{bmatrix},\n\\quad\nx =\n\\begin{bmatrix}\nx_T \\\\\nx_R\n\\end{bmatrix},\n\\quad\nb =\n\\begin{bmatrix}\nb_T \\\\\nb_R\n\\end{bmatrix}.\n$$\n一个分块 Gauss-Seidel 更新首先计算 $x_T^{(k+1)} = A_{TT}^{-1} \\left( b_T - A_{TR} x_R^{(k)} \\right)$，随后计算 $x_R^{(k+1)} = A_{RR}^{-1} \\left( b_R - A_{RT} x_T^{(k+1)} \\right)$。这导出一个仿射迭代 $x^{(k+1)} = M x^{(k)} + c$，其分块迭代矩阵的非零块为作用于 $x_R^{(k)}$ 的 $S_R = A_{RR}^{-1} A_{RT} A_{TT}^{-1} A_{TR}$。该迭代的数值稳定性和局部收敛速率由谱半径 $\\rho(S_R)$ 控制：根据 Banach 不动点定理，如果存在一个范数，使得其诱导算子范数小于 $1$，则迭代收敛；对于线性映射，一个必要条件是 $\\rho(S_R)  1$，且较小的 $\\rho(S_R)$ 意味着更快的渐近误差衰减。\n\n你的任务是设计并实现一个程序，对于下面指定的每个测试用例，枚举给定大小 $k$ 的所有撕裂集 $T$，筛选掉其中 $A_{TT}$ 或 $A_{RR}$ 是数值奇异或严重病态的撕裂集，为每个有效的 $T$ 计算 $\\rho(S_R)$，选择具有最小 $\\rho(S_R)$ 的撕裂集，然后从初始条件 $x^{(0)} = \\mathbf{1}$（全一向量）开始模拟分块 Gauss-Seidel 迭代，计算达到 $\\| x^{(k+1)} - x^{(k)} \\|_2  \\text{tol}$（使用指定的容差）所需的迭代次数。为了本任务的目的，将条件数视为 $\\kappa(M) = \\|M\\|_2 \\|M^{-1}\\|_2$ 并进行数值近似，并拒绝条件数超过 $10^{10}$ 的分块。所有计算都必须以双精度进行。\n\n测试套件定义：\n\n- 测试用例 $1$：$n = 3$，\n$$\nA_1 =\n\\begin{bmatrix}\n1.0  -0.2  0.0 \\\\\n-0.3  1.0  -0.1 \\\\\n0.0  -0.4  1.0\n\\end{bmatrix},\n\\quad\nb_1 =\n\\begin{bmatrix}\n1.0 \\\\\n1.0 \\\\\n1.0\n\\end{bmatrix},\n\\quad\nk_1 = 1,\n\\quad\n\\text{tol}_1 = 10^{-8},\n\\quad\n\\text{max\\_iter}_1 = 10000.\n$$\n\n- 测试用例 $2$：$n = 4$，\n$$\nA_2 =\n\\begin{bmatrix}\n1.0  -0.9  0.0  0.0 \\\\\n-0.9  1.0  -0.9  0.0 \\\\\n0.0  -0.9  1.0  -0.9 \\\\\n0.0  0.0  -0.9  1.0\n\\end{bmatrix},\n\\quad\nb_2 =\n\\begin{bmatrix}\n1.0 \\\\\n1.0 \\\\\n1.0 \\\\\n1.0\n\\end{bmatrix},\n\\quad\nk_2 = 2,\n\\quad\n\\text{tol}_2 = 10^{-8},\n\\quad\n\\text{max\\_iter}_2 = 10000.\n$$\n\n- 测试用例 $3$：$n = 5$，\n$$\nA_3 =\n\\begin{bmatrix}\n1.0  -0.95  0.0  0.0  0.0 \\\\\n-0.95  1.0  -0.5  0.0  0.0 \\\\\n0.0  -0.5  1.0  -0.5  0.0 \\\\\n0.0  0.0  -0.5  1.0  -0.95 \\\\\n0.0  0.0  0.0  -0.95  1.0\n\\end{bmatrix},\n\\quad\nb_3 =\n\\begin{bmatrix}\n1.0 \\\\\n1.0 \\\\\n1.0 \\\\\n1.0 \\\\\n1.0\n\\end{bmatrix},\n\\quad\nk_3 = 2,\n\\quad\n\\text{tol}_3 = 10^{-8},\n\\quad\n\\text{max\\_iter}_3 = 10000.\n$$\n\n算法要求：\n\n- 对于每个测试用例，枚举大小为 $k$ 的所有索引子集 $T$。\n- 对于每个 $T$，形成 $A_{TT}$、$A_{TR}$、$A_{RT}$、$A_{RR}$ 并计算 $S_R = A_{RR}^{-1} A_{RT} A_{TT}^{-1} A_{TR}$。计算谱半径 $\\rho(S_R)$，即 $S_R$ 的特征值的最大绝对值。\n- 如果 $A_{TT}$ 或 $A_{RR}$ 的条件数超过 $10^{10}$，则拒绝 $T$。\n- 选择具有最小 $\\rho(S_R)$ 的 $T$；如果多个 $T$ 并列，则选择索引列表字典序最小的那个。\n- 使用选定的 $T$，从 $x^{(0)} = \\mathbf{1}$ 开始并使用给定的 $b$，在每次迭代中如上文定义更新 $x_T$ 和 $x_R$，直到满足 $\\| x^{(k+1)} - x^{(k)} \\|_2  \\text{tol}$ 或达到 $\\text{max\\_iter}$ 次迭代。记录执行的迭代次数。\n- 定义一个布尔值稳定性指标 $\\text{stable} = (\\rho(S_R)  1)$。\n\n最终输出格式规范：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个测试用例，并且本身也必须是一个列表，按顺序包含以下元素：选定的撕裂集索引（一个升序排列的整数列表 $T$），谱半径 $\\rho(S_R)$（四舍五入到 $6$ 位小数），达到容差所需的整数迭代次数（如果未收敛则为最大迭代次数），以及作为布尔值的稳定性指标。例如，三个测试用例的格式为 $[[T_1,\\rho_1,\\text{iter}_1,\\text{stable}_1],[T_2,\\rho_2,\\text{iter}_2,\\text{stable}_2],[T_3,\\rho_3,\\text{iter}_3,\\text{stable}_3]]$。",
            "solution": "经评估，用户提供的问题是有效的。这是一个数值线性代数领域中的适定问题，具体涉及求解协同仿真框架（如功能样机接口 FMI）中产生的线性系统的迭代方法。该问题具有科学依据、内部一致，并为获得唯一解提供了所有必要的数据和定义。\n\n任务是确定一个最优的撕裂策略，通过选择一组由集合 $T$ 索引的撕裂变量，以最小化相关的分块 Gauss-Seidel 迭代矩阵的谱半径。然后使用此最优策略迭代求解该系统，并报告收敛所需的迭代次数。\n\n该问题的理论基础在于迭代方法的分析。对于一个基于撕裂集 $T$ 及其补集 $R$ 置换为 $2 \\times 2$ 分块结构的线性系统\n$$\n\\begin{bmatrix}\nA_{TT}  A_{TR} \\\\\nA_{RT}  A_{RR}\n\\end{bmatrix}\n\\begin{bmatrix}\nx_T \\\\\nx_R\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nb_T \\\\\nb_R\n\\end{bmatrix}\n$$\n分块 Gauss-Seidel 迭代由以下相继的更新定义：\n$$\nx_T^{(k+1)} = A_{TT}^{-1} \\left( b_T - A_{TR} x_R^{(k)} \\right)\n$$\n$$\nx_R^{(k+1)} = A_{RR}^{-1} \\left( b_R - A_{RT} x_T^{(k+1)} \\right)\n$$\n将第一个方程代入第二个方程，可得到保留变量 $x_R$ 的仿射迭代：\n$$\nx_R^{(k+1)} = (A_{RR}^{-1} A_{RT} A_{TT}^{-1} A_{TR}) x_R^{(k)} + A_{RR}^{-1}(b_R - A_{RT} A_{TT}^{-1} b_T)\n$$\n其形式为 $x_R^{(k+1)} = S_R x_R^{(k)} + c_R$，其中 $S_R = A_{RR}^{-1} A_{RT} A_{TT}^{-1} A_{TR}$ 是迭代矩阵。如果 $S_R$ 的谱半径（记为 $\\rho(S_R)$）小于 $1$，则该方法的收敛性得到保证。$\\rho(S_R)$ 的值也决定了渐近收敛速率；较小的谱半径意味着更快的收敛速度。\n\n解决此问题的算法流程如下：\n\n1.  **枚举撕裂集**：对于给定的系统大小 $n$ 和撕裂大小 $k$，生成所有可能的撕裂集 $T$。每个 $T$ 都是 $\\{0, 1, \\dots, n-1\\}$ 的一个大小为 $k$ 的子集。这类集合的数量由二项式系数 $\\binom{n}{k}$ 给出。\n\n2.  **评估每个撕裂集**：对于每个候选集 $T$：\n    a.  确定保留集 $R = \\{0, 1, \\dots, n-1\\} \\setminus T$。\n    b.  将矩阵 $A$ 和向量 $b$ 根据索引集 $T$ 和 $R$ 划分成分块 $A_{TT}$、$A_{TR}$、$A_{RT}$、$A_{RR}$、$b_T$ 和 $b_R$。\n    c.  **稳定性检查**：通过计算对角分块的条件数 $\\kappa(A_{TT})$ 和 $\\kappa(A_{RR})$ 来评估数值稳定性。使用 2-范数条件数。如果任一条件数超过指定的阈值 $10^{10}$，则该撕裂集 $T$ 被视为无效并被丢弃。此步骤可防止因对接近奇异的矩阵求逆而产生的数值问题。\n    d.  **谱半径计算**：对于一个有效的撕裂集，计算迭代矩阵 $S_R = A_{RR}^{-1} A_{RT} A_{TT}^{-1} A_{TR}$。为避免显式矩阵求逆（其计算成本更高且稳定性更差），这通过求解线性方程组来计算。首先，我们求解 $A_{TT} X = A_{TR}$ 得到 $X$。然后，我们通过求解 $A_{RR} S_R = A_{RT} X$ 来计算 $S_R$。谱半径 $\\rho(S_R)$ 随后被计算为 $S_R$ 的特征值的最大绝对值。\n\n3.  **最优集合选择**：在评估所有有效的撕裂集后，选择产生最小谱半径 $\\rho_{\\text{min}}$ 的集合 $T_{\\text{opt}}$。如果出现谱半径相同的情况，选择索引字典序最小的集合。\n\n4.  **迭代求解**：使用最优撕裂集 $T_{\\text{opt}}$ 执行分块 Gauss-Seidel 迭代。\n    a.  迭代从初始猜测 $x^{(0)} = \\mathbf{1}$（一个全为一的向量）开始。\n    b.  在每一步 $k$ 中，通过求解线性系统 $A_{TT} x_T^{(k+1)} = b_T - A_{TR} x_R^{(k)}$ 和 $A_{RR} x_R^{(k+1)} = b_R - A_{RT} x_T^{(k+1)}$ 来计算向量 $x_T^{(k+1)}$ 和 $x_R^{(k+1)}$。\n    c.  从其分量中组装完整的解向量 $x^{(k+1)}$。\n    d.  迭代持续进行，直到连续迭代之间的差的 L2-范数 $\\| x^{(k+1)} - x^{(k)} \\|_2$ 低于给定的容差 $\\text{tol}$，或达到最大迭代次数 $\\text{max\\_iter}$。\n\n5.  **结果格式化**：对于每个测试用例，最终结果是一个列表，包含最优撕裂集 $T_{\\text{opt}}$（作为整数列表）、最小谱半径 $\\rho_{\\text{min}}$、执行的迭代次数以及一个表示稳定性的布尔指标（$\\rho_{\\text{min}}  1$）。对所有提供的测试用例重复此整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It processes each case, finds the optimal tearing set, runs the\n    block Gauss-Seidel iteration, and formats the results for output.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([\n                [1.0, -0.2, 0.0],\n                [-0.3, 1.0, -0.1],\n                [0.0, -0.4, 1.0]\n            ]),\n            \"b\": np.array([1.0, 1.0, 1.0]),\n            \"k\": 1,\n            \"tol\": 1e-8,\n            \"max_iter\": 10000,\n        },\n        {\n            \"A\": np.array([\n                [1.0, -0.9, 0.0, 0.0],\n                [-0.9, 1.0, -0.9, 0.0],\n                [0.0, -0.9, 1.0, -0.9],\n                [0.0, 0.0, -0.9, 1.0]\n            ]),\n            \"b\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"k\": 2,\n            \"tol\": 1e-8,\n            \"max_iter\": 10000,\n        },\n        {\n            \"A\": np.array([\n                [1.0, -0.95, 0.0, 0.0, 0.0],\n                [-0.95, 1.0, -0.5, 0.0, 0.0],\n                [0.0, -0.5, 1.0, -0.5, 0.0],\n                [0.0, 0.0, -0.5, 1.0, -0.95],\n                [0.0, 0.0, 0.0, -0.95, 1.0]\n            ]),\n            \"b\": np.array([1.0, 1.0, 1.0, 1.0, 1.0]),\n            \"k\": 2,\n            \"tol\": 1e-8,\n            \"max_iter\": 10000,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(\n            case[\"A\"], case[\"b\"], case[\"k\"], case[\"tol\"], case[\"max_iter\"]\n        )\n        results.append(result)\n\n    # Manual string formatting to match the output specification precisely.\n    # Avoids spaces introduced by standard list-to-string conversion.\n    result_strings = []\n    for T, rho, iters, stable in results:\n        T_str = f'[{\",\".join(map(str, T))}]'\n        # Format rho to 6 decimal places and bool as capitalized True/False\n        item_str = f'[{T_str},{rho:.6f},{iters},{str(stable)}]'\n        result_strings.append(item_str)\n    \n    final_output = f'[{\",\".join(result_strings)}]'\n    print(final_output)\n\ndef process_case(A, b, k, tol, max_iter):\n    \"\"\"\n    Handles the logic for a single test case.\n    \"\"\"\n    n = A.shape[0]\n    indices = list(range(n))\n    \n    best_rho = float('inf')\n    best_T = None\n    \n    cond_threshold = 1e10\n\n    # 1. Enumerate all tearing sets T and find the optimal one\n    for T_tuple in itertools.combinations(indices, k):\n        T = list(T_tuple)\n        R = sorted(list(set(indices) - set(T)))\n        \n        try:\n            # Form block matrices\n            A_TT = A[np.ix_(T, T)]\n            A_TR = A[np.ix_(T, R)]\n            A_RT = A[np.ix_(R, T)]\n            A_RR = A[np.ix_(R, R)]\n            \n            # 2. Check condition numbers\n            cond_A_TT = np.linalg.cond(A_TT) if k > 0 else 1.0\n            cond_A_RR = np.linalg.cond(A_RR) if k  n else 1.0\n            \n            if cond_A_TT > cond_threshold or cond_A_RR > cond_threshold:\n                continue\n\n            # 3. Compute spectral radius of S_R\n            # S_R = inv(A_RR) * A_RT * inv(A_TT) * A_TR\n            # To avoid explicit inverses, solve linear systems\n            if k == 0 or k == n:\n                # If no tearing or full tearing, rho is 0 as there's no coupling term\n                rho = 0.0\n            else:\n                # X = inv(A_TT) * A_TR\n                X = linalg.solve(A_TT, A_TR)\n                # S_R = inv(A_RR) * (A_RT * X)\n                S_R = linalg.solve(A_RR, A_RT @ X)\n                \n                eigenvalues = linalg.eigvals(S_R)\n                rho = np.max(np.abs(eigenvalues))\n\n            # 4. Update best T based on minimal rho (with lexicographical tie-breaking)\n            if rho  best_rho:\n                best_rho = rho\n                best_T = T\n            elif rho == best_rho:\n                # For tie-breaking, current T_tuple is already lexicographically sorted\n                if best_T is None or list(T_tuple)  best_T:\n                    best_T = T\n        \n        except np.linalg.LinAlgError:\n            # This tearing set leads to a singular block, so it's invalid.\n            continue\n            \n    # 5. Perform Block Gauss-Seidel iteration with the optimal T\n    T = best_T\n    R = sorted(list(set(indices) - set(T)))\n    \n    A_TT = A[np.ix_(T, T)]\n    A_TR = A[np.ix_(T, R)]\n    A_RT = A[np.ix_(R, T)]\n    A_RR = A[np.ix_(R, R)]\n    \n    b_T = b[T]\n    b_R = b[R]\n    \n    x = np.ones(n, dtype=float)\n    \n    iter_count = 0\n    for i in range(max_iter):\n        iter_count = i + 1\n        x_prev = x.copy()\n        \n        # Get components from previous iteration\n        x_R_prev = x_prev[R]\n        \n        # Update x_T\n        rhs_T = b_T - A_TR @ x_R_prev\n        x_T_new = linalg.solve(A_TT, rhs_T)\n        \n        # Update x_R using the newly computed x_T\n        rhs_R = b_R - A_RT @ x_T_new\n        x_R_new = linalg.solve(A_RR, rhs_R)\n        \n        # Reconstruct full x vector\n        x[T] = x_T_new\n        x[R] = x_R_new\n        \n        # Check for convergence\n        if np.linalg.norm(x - x_prev, 2)  tol:\n            break\n            \n    is_stable = best_rho  1.0\n\n    return [best_T, best_rho, iter_count, is_stable]\n\nsolve()\n```"
        }
    ]
}