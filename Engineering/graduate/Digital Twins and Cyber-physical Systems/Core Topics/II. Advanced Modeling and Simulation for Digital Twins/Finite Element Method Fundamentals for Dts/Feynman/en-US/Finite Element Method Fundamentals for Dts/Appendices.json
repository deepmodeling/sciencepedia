{
    "hands_on_practices": [
        {
            "introduction": "To truly master the Finite Element Method, one must look beyond commercial software packages and understand how the underlying mathematical machinery works. This first practice guides you through the entire FEM pipeline for a simple yet illustrative one-dimensional problem . By starting with the governing differential equation and systematically deriving the weak form, assembling element matrices, and solving the final system, you will gain a first-principles understanding of the method's core logic, a skill indispensable for building and validating physically-grounded Digital Twins.",
            "id": "4222526",
            "problem": "A Digital Twin (DT) within Cyber-Physical Systems (CPS) requires a numerically stable and physically interpretable surrogate of a one-dimensional diffusion field. Consider the one-dimensional Poisson problem on the domain $[0,1]$ with homogeneous Dirichlet boundary conditions, modeling a normalized, dimensionless field $u(x)$ governed by the strong form $-u''(x)=f(x)$, subject to $u(0)=0$ and $u(1)=0$. Assume a uniform body source $f(x)=1$. The discretization is to be performed using the Finite Element Method (FEM) with piecewise linear basis functions on a uniform mesh suitable for DT deployment.\n\nStarting from the governing differential equation and its weak form, proceed as follows without using any pre-derived shortcut formulas:\n\n- Use the standard Galerkin approach: derive the weak form by multiplying the strong form by a test function $v(x)$ and integrating over $[0,1]$, applying integration by parts and the essential boundary conditions.\n- Construct the piecewise linear finite element basis functions $\\{\\phi_{i}(x)\\}$ over a uniform mesh of $N=4$ elements with nodes $x_{i}=ih$ for $i=0,1,2,3,4$, where $h=1/4$.\n- Derive the element stiffness matrix by evaluating the bilinear form of the weak problem on a single element using the local basis and the mapping from the reference element.\n- Assemble the global stiffness matrix and the global load vector by summing element contributions, and then enforce the Dirichlet boundary conditions using elimination of the constrained degrees of freedom.\n- Solve the resulting linear system for the interior nodal values and determine the discrete FEM approximation at the midpoint $x=1/2$.\n\nExpress the final answer as a pure number (dimensionless). If an exact closed-form is available, provide it in exact form.",
            "solution": "The problem statement has been validated and is deemed valid. It is a well-posed, scientifically grounded problem from computational mechanics that is self-contained and free of contradictions or ambiguities. We may therefore proceed with the solution.\n\nThe governing ordinary differential equation, or strong form, for the one-dimensional field $u(x)$ is given as:\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0, 1) $$\nwith a uniform source term $f(x) = 1$. The problem is subject to homogeneous Dirichlet boundary conditions:\n$$ u(0) = 0 \\quad \\text{and} \\quad u(1) = 0 $$\n\nTo derive the weak form, we follow the Galerkin procedure. We multiply the strong form by a test function $v(x)$ and integrate over the domain $\\Omega = [0,1]$. The test function $v(x)$ must belong to the space of functions where the solution is sought, and must satisfy the homogeneous form of the essential (Dirichlet) boundary conditions, i.e., $v(0)=0$ and $v(1)=0$.\n$$ \\int_{0}^{1} -u''(x) v(x) \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx $$\nApplying integration by parts to the left-hand side term, $\\int u' dv = uv - \\int v du$, where we set $-u'' dx$ as $dv$ and $v$ as $u$, yields:\n$$ \\left[ -u'(x) v(x) \\right]_{0}^{1} + \\int_{0}^{1} u'(x) v'(x) \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx $$\nThe boundary term $[ -u'(x) v(x) ]_{0}^{1}$ evaluates to $-u'(1)v(1) - (-u'(0)v(0))$. Since the test function must satisfy $v(0)=0$ and $v(1)=0$, this boundary term vanishes entirely. The resulting weak form is: Find $u(x)$ such that for all valid test functions $v(x)$,\n$$ \\int_{0}^{1} u'(x) v'(x) \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx $$\nThis can be expressed as a bilinear form $a(u,v)$ and a linear functional $L(v)$:\n$$ a(u, v) = \\int_{0}^{1} u'(x) v'(x) \\, dx $$\n$$ L(v) = \\int_{0}^{1} f(x) v(x) \\, dx $$\n\nFor the Finite Element Method (FEM), we discretize the domain $[0,1]$ into $N=4$ uniform elements. This creates $N+1=5$ nodes at positions $x_i = ih$ for $i \\in \\{0, 1, 2, 3, 4\\}$, where the element size is $h = 1/N = 1/4$. The nodes are located at $x_0=0$, $x_1=1/4$, $x_2=1/2$, $x_3=3/4$, and $x_4=1$.\n\nThe FEM approximation, $u_h(x)$, is represented as a linear combination of piecewise linear basis functions $\\phi_j(x)$:\n$$ u_h(x) = \\sum_{j=0}^{4} U_j \\phi_j(x) $$\nHere, $U_j$ are the unknown nodal values of the field, $U_j = u_h(x_j)$, and $\\phi_j(x)$ are the \"hat\" functions defined such that $\\phi_j(x_i) = \\delta_{ij}$ (the Kronecker delta). For the Galerkin method, we choose the test functions $v(x)$ from the same space as the basis functions, i.e., $v(x) = \\phi_i(x)$ for each internal node $i$.\n\nSubstituting the approximation $u_h(x)$ into the weak form for each basis function $\\phi_i(x)$ yields a system of linear equations $KU=F$, where:\n$$ K_{ij} = a(\\phi_j, \\phi_i) = \\int_{0}^{1} \\phi_j'(x) \\phi_i'(x) \\, dx $$\n$$ F_i = L(\\phi_i) = \\int_{0}^{1} f(x) \\phi_i(x) \\, dx $$\n\nWe first compute the contribution of a single element $\\Omega_e = [x_k, x_{k+1}]$ to the global matrices. We map this element to a reference element $\\hat{\\Omega}=[0,1]$ via the affine mapping $x(\\xi) = x_k + h\\xi$, where $\\xi \\in [0,1]$. The derivative mapping is $\\frac{d}{dx} = \\frac{d\\xi}{dx} \\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$, and the differential element is $dx = h\\,d\\xi$. The local basis functions on the reference element are $\\psi_1(\\xi) = 1-\\xi$ and $\\psi_2(\\xi) = \\xi$, with derivatives $\\psi_1'(\\xi)=-1$ and $\\psi_2'(\\xi)=1$.\n\nThe element stiffness matrix $K^e$ has components $k^e_{mn}$:\n$$ k^e_{mn} = \\int_{0}^{1} \\left(\\frac{1}{h}\\frac{d\\psi_m}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\psi_n}{d\\xi}\\right) (h\\,d\\xi) = \\frac{1}{h}\\int_{0}^{1} \\frac{d\\psi_m}{d\\xi}\\frac{d\\psi_n}{d\\xi}\\,d\\xi $$\nCalculating the components:\n$k^e_{11} = \\frac{1}{h}\\int_{0}^{1} (-1)(-1) \\, d\\xi = \\frac{1}{h}$\n$k^e_{12} = \\frac{1}{h}\\int_{0}^{1} (-1)(1) \\, d\\xi = -\\frac{1}{h}$\n$k^e_{21} = \\frac{1}{h}\\int_{0}^{1} (1)(-1) \\, d\\xi = -\\frac{1}{h}$\n$k^e_{22} = \\frac{1}{h}\\int_{0}^{1} (1)(1) \\, d\\xi = \\frac{1}{h}$\nThus, the element stiffness matrix is:\n$$ K^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\n\nThe element load vector $F^e$ has components $f^e_m$:\n$$ f^e_m = \\int_{0}^{1} f(x(\\xi)) \\psi_m(\\xi) (h\\,d\\xi) $$\nGiven $f(x)=1$, this becomes:\n$$ f^e_m = \\int_{0}^{1} (1) \\psi_m(\\xi) (h\\,d\\xi) = h \\int_{0}^{1} \\psi_m(\\xi) \\,d\\xi $$\n$f^e_1 = h \\int_{0}^{1} (1-\\xi) \\,d\\xi = h [\\xi - \\frac{\\xi^2}{2}]_0^1 = \\frac{h}{2}$\n$f^e_2 = h \\int_{0}^{1} \\xi \\,d\\xi = h [\\frac{\\xi^2}{2}]_0^1 = \\frac{h}{2}$\nThus, the element load vector is:\n$$ F^e = \\frac{h}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n\nAssembling the global matrices for $N=4$ elements and $N+1=5$ nodes ($0,1,2,3,4$):\n$$ K = \\frac{1}{h} \\begin{pmatrix} 1 & -1 & 0 & 0 & 0 \\\\ -1 & 1+1 & -1 & 0 & 0 \\\\ 0 & -1 & 1+1 & -1 & 0 \\\\ 0 & 0 & -1 & 1+1 & -1 \\\\ 0 & 0 & 0 & -1 & 1 \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} 1 & -1 & 0 & 0 & 0 \\\\ -1 & 2 & -1 & 0 & 0 \\\\ 0 & -1 & 2 & -1 & 0 \\\\ 0 & 0 & -1 & 2 & -1 \\\\ 0 & 0 & 0 & -1 & 1 \\end{pmatrix} $$\n$$ F = \\begin{pmatrix} h/2 \\\\ h/2+h/2 \\\\ h/2+h/2 \\\\ h/2+h/2 \\\\ h/2 \\end{pmatrix} = \\begin{pmatrix} h/2 \\\\ h \\\\ h \\\\ h \\\\ h/2 \\end{pmatrix} $$\n\nThe full linear system $KU=F$ is:\n$$ \\frac{1}{h} \\begin{pmatrix} 1 & -1 & 0 & 0 & 0 \\\\ -1 & 2 & -1 & 0 & 0 \\\\ 0 & -1 & 2 & -1 & 0 \\\\ 0 & 0 & -1 & 2 & -1 \\\\ 0 & 0 & 0 & -1 & 1 \\end{pmatrix} \\begin{pmatrix} U_0 \\\\ U_1 \\\\ U_2 \\\\ U_3 \\\\ U_4 \\end{pmatrix} = h \\begin{pmatrix} 1/2 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1/2 \\end{pmatrix} $$\n\nWe now enforce the Dirichlet boundary conditions $u(0)=0 \\implies U_0=0$ and $u(1)=0 \\implies U_4=0$. Using the elimination method, we remove the rows and columns corresponding to the constrained degrees of freedom ($0$ and $4$), leading to a reduced system for the unknown interior nodal values $U_1, U_2, U_3$:\n$$ \\frac{1}{h} \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} \\begin{pmatrix} U_1 \\\\ U_2 \\\\ U_3 \\end{pmatrix} = h \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\nMultiplying by $h$, we get:\n$$ \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} \\begin{pmatrix} U_1 \\\\ U_2 \\\\ U_3 \\end{pmatrix} = h^2 \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\nWith $h=1/4$, we have $h^2=1/16$. The system of equations is:\n1. $2U_1 - U_2 = 1/16$\n2. $-U_1 + 2U_2 - U_3 = 1/16$\n3. $-U_2 + 2U_3 = 1/16$\n\nDue to the symmetry of the problem (uniform mesh, uniform source term, symmetric domain), we can deduce that $U_1 = U_3$. Substituting this into the second equation gives $-2U_1 + 2U_2 = 1/16$. We now have a $2 \\times 2$ system for $U_1$ and $U_2$:\n$2U_1 - U_2 = 1/16$\n$-2U_1 + 2U_2 = 1/16$\nAdding these two equations together yields:\n$$ (2U_1 - U_2) + (-2U_1 + 2U_2) = \\frac{1}{16} + \\frac{1}{16} $$\n$$ U_2 = \\frac{2}{16} = \\frac{1}{8} $$\nSubstituting $U_2 = 1/8$ back into the first equation:\n$$ 2U_1 - \\frac{1}{8} = \\frac{1}{16} \\implies 2U_1 = \\frac{1}{8} + \\frac{1}{16} = \\frac{2}{16} + \\frac{1}{16} = \\frac{3}{16} \\implies U_1 = \\frac{3}{32} $$\nThe nodal solution values are $U_1=3/32$, $U_2=1/8$, and $U_3=3/32$.\n\nThe problem asks for the discrete FEM approximation at the midpoint $x=1/2$. This point corresponds to node $x_2$. The value of the FEM solution at a node is by definition the nodal value itself:\n$$ u_h(x=1/2) = u_h(x_2) = U_2 $$\nTherefore, the desired value is $U_2$.\n\n$$ U_2 = \\frac{1}{8} $$",
            "answer": "$$\\boxed{\\frac{1}{8}}$$"
        },
        {
            "introduction": "Real-world components rarely consist of perfect squares and straight lines, posing a challenge for meshing. The isoparametric mapping is the elegant solution in FEM, allowing distorted elements in physical space to be mapped from a simple, regular 'parent' element. This exercise  delves into the heart of this concept by having you derive the Jacobian matrix of this mapping, which encodes all the geometric information of the element. Understanding how element distortion affects the Jacobian and, consequently, the accuracy of the simulation is a critical skill for creating reliable and high-fidelity Digital Twin models.",
            "id": "4222514",
            "problem": "A Digital Twin (DT) for a Cyber-Physical System (CPS) monitors an elastic membrane using the Finite Element Method (FEM) with a bilinear four-node ($4$-node) quadrilateral isoparametric element. The natural coordinates are $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ with the standard node ordering $1:(-1,-1)$, $2:(1,-1)$, $3:(1,1)$, $4:(-1,1)$. The bilinear shape functions are\n$$\nN_{1}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\nThe isoparametric mapping for the physical coordinates is defined by\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i},\\qquad\ny(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}.\n$$\nConsider a family of geometrically distorted elements parameterized by a distortion amplitude $\\alpha\\in\\mathbb{R}$, with nodal coordinates\n$$\n(x_{1},y_{1})=(0,0),\\quad (x_{2},y_{2})=(L,0),\\quad (x_{3},y_{3})=(L(1+\\alpha),H),\\quad (x_{4},y_{4})=(0,H),\n$$\nwhere $L>0$ and $H>0$ are characteristic lengths in the $x$- and $y$-directions, respectively. Starting from the above fundamental definitions, do the following:\n\n1. Derive the Jacobian matrix of the isoparametric mapping,\n$$\nJ(\\xi,\\eta)=\n\\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\[4pt]\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{pmatrix},\n$$\nexpressed symbolically in terms of the nodal coordinates and shape function derivatives.\n\n2. For the given distorted element, obtain a closed-form expression for the determinant of the Jacobian, $\\det J(\\xi,\\eta)$, as a function of $L$, $H$, $\\alpha$, and $(\\xi,\\eta)$.\n\n3. Using the mapping properties encoded by $J(\\xi,\\eta)$, explain how non-affine distortion (i.e., $\\alpha\\neq 0$) affects the interpolation accuracy of a linear physical field $u(x,y)=a\\,x+b\\,y+c$ under bilinear isoparametric interpolation. Your explanation should reference the variation of the metric induced by $J(\\xi,\\eta)$ and the conditions under which linear fields are reproduced exactly.\n\nSubmit, as your final answer, the analytical expression for $\\det J(\\xi,\\eta)$ from part $2$. No numerical evaluation or rounding is required.",
            "solution": "The problem statement is a well-posed exercise in the fundamentals of the Finite Element Method (FEM), specifically concerning the properties of isoparametric mapping for a bilinear quadrilateral element. All definitions, data, and conditions are provided, scientifically sound, and internally consistent. Therefore, the problem is valid, and a full solution can be derived.\n\nThe solution proceeds in three parts as requested by the problem.\n\n### Part 1: Derivation of the Jacobian Matrix\n\nThe isoparametric mapping relates the physical coordinates $(x, y)$ to the natural coordinates $(\\xi, \\eta)$ via the shape functions $N_i(\\xi, \\eta)$ and the nodal coordinates $(x_i, y_i)$:\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}\n$$\n$$\ny(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}\n$$\nThe Jacobian matrix $J(\\xi, \\eta)$ of this transformation is defined as:\n$$\nJ(\\xi,\\eta)=\n\\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\[4pt]\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{pmatrix}\n$$\nThe components of the Jacobian are found by differentiating the mapping equations with respect to the natural coordinates. Applying the chain rule, we obtain:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i, \\qquad \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} x_i\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} y_i, \\qquad \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} y_i\n$$\nTo proceed, we first compute the partial derivatives of the bilinear shape functions:\n$$\nN_{1}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta) \\quad \\implies \\quad \\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi)\n$$\n$$\nN_{2}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta) \\quad \\implies \\quad \\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_2}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi)\n$$\n$$\nN_{3}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta) \\quad \\implies \\quad \\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1+\\xi)\n$$\n$$\nN_{4}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta) \\quad \\implies \\quad \\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n$$\nSubstituting these into the expressions for the Jacobian components yields the general symbolic form of the Jacobian matrix, expressed in terms of the nodal coordinates $(x_i, y_i)$ and the derivatives of the shape functions.\n\n### Part 2: Determinant of the Jacobian for the Distorted Element\n\nNow we specialize to the element defined by the nodal coordinates:\n$$\n(x_{1},y_{1})=(0,0),\\quad (x_{2},y_{2})=(L,0),\\quad (x_{3},y_{3})=(L(1+\\alpha),H),\\quad (x_{4},y_{4})=(0,H)\n$$\nwith $L>0$ and $H>0$. We compute each component of the Jacobian matrix $J(\\xi, \\eta)$.\n\nComponent $J_{11} = \\frac{\\partial x}{\\partial \\xi}$:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial N_1}{\\partial \\xi}x_1 + \\frac{\\partial N_2}{\\partial \\xi}x_2 + \\frac{\\partial N_3}{\\partial \\xi}x_3 + \\frac{\\partial N_4}{\\partial \\xi}x_4\n$$\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\left(-\\frac{1}{4}(1-\\eta)\\right)(0) + \\left(\\frac{1}{4}(1-\\eta)\\right)(L) + \\left(\\frac{1}{4}(1+\\eta)\\right)(L(1+\\alpha)) + \\left(-\\frac{1}{4}(1+\\eta)\\right)(0)\n$$\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{L}{4} \\left[ (1-\\eta) + (1+\\eta)(1+\\alpha) \\right] = \\frac{L}{4} \\left[ 1 - \\eta + 1 + \\eta + \\alpha + \\alpha\\eta \\right] = \\frac{L}{4}(2+\\alpha+\\alpha\\eta)\n$$\n\nComponent $J_{12} = \\frac{\\partial x}{\\partial \\eta}$:\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial N_1}{\\partial \\eta}x_1 + \\frac{\\partial N_2}{\\partial \\eta}x_2 + \\frac{\\partial N_3}{\\partial \\eta}x_3 + \\frac{\\partial N_4}{\\partial \\eta}x_4\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\left(-\\frac{1}{4}(1-\\xi)\\right)(0) + \\left(-\\frac{1}{4}(1+\\xi)\\right)(L) + \\left(\\frac{1}{4}(1+\\xi)\\right)(L(1+\\alpha)) + \\left(\\frac{1}{4}(1-\\xi)\\right)(0)\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{L}{4} \\left[ -(1+\\xi) + (1+\\xi)(1+\\alpha) \\right] = \\frac{L}{4} (1+\\xi) [-1 + 1+\\alpha] = \\frac{L \\alpha}{4}(1+\\xi)\n$$\n\nComponent $J_{21} = \\frac{\\partial y}{\\partial \\xi}$:\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial N_1}{\\partial \\xi}y_1 + \\frac{\\partial N_2}{\\partial \\xi}y_2 + \\frac{\\partial N_3}{\\partial \\xi}y_3 + \\frac{\\partial N_4}{\\partial \\xi}y_4\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\left(-\\frac{1}{4}(1-\\eta)\\right)(0) + \\left(\\frac{1}{4}(1-\\eta)\\right)(0) + \\left(\\frac{1}{4}(1+\\eta)\\right)(H) + \\left(-\\frac{1}{4}(1+\\eta)\\right)(H)\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{H}{4} (1+\\eta) - \\frac{H}{4} (1+\\eta) = 0\n$$\n\nComponent $J_{22} = \\frac{\\partial y}{\\partial \\eta}$:\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial N_1}{\\partial \\eta}y_1 + \\frac{\\partial N_2}{\\partial \\eta}y_2 + \\frac{\\partial N_3}{\\partial \\eta}y_3 + \\frac{\\partial N_4}{\\partial \\eta}y_4\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\left(-\\frac{1}{4}(1-\\xi)\\right)(0) + \\left(-\\frac{1}{4}(1+\\xi)\\right)(0) + \\left(\\frac{1}{4}(1+\\xi)\\right)(H) + \\left(\\frac{1}{4}(1-\\xi)\\right)(H)\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{H}{4} \\left[ (1+\\xi) + (1-\\xi) \\right] = \\frac{H}{4}(2) = \\frac{H}{2}\n$$\n\nThe Jacobian matrix is thus:\n$$\nJ(\\xi,\\eta)=\n\\begin{pmatrix}\n\\frac{L}{4}(2+\\alpha+\\alpha\\eta) & \\frac{L \\alpha}{4}(1+\\xi) \\\\[4pt]\n0 & \\frac{H}{2}\n\\end{pmatrix}\n$$\nThe determinant of the Jacobian, $\\det J(\\xi,\\eta)$, is:\n$$\n\\det J(\\xi,\\eta) = \\left( \\frac{L}{4}(2+\\alpha+\\alpha\\eta) \\right) \\left( \\frac{H}{2} \\right) - \\left( \\frac{L \\alpha}{4}(1+\\xi) \\right) (0)\n$$\n$$\n\\det J(\\xi,\\eta) = \\frac{LH}{8}(2+\\alpha+\\alpha\\eta)\n$$\n\n### Part 3: Effect of Non-Affine Distortion on Interpolation Accuracy\n\nThe interpolation of a scalar field $u(x,y)$ using the isoparametric formulation is given by $\\hat{u}(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) u_i$, where $u_i = u(x_i, y_i)$.\n\nFor a linear physical field $u(x,y) = a\\,x+b\\,y+c$, the interpolated field $\\hat{u}$ is:\n$$\n\\hat{u}(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) (a\\,x_i+b\\,y_i+c) = a \\sum_{i=1}^4 N_i x_i + b \\sum_{i=1}^4 N_i y_i + c \\sum_{i=1}^4 N_i\n$$\nBy definition of the isoparametric mapping, $\\sum N_i x_i = x(\\xi,\\eta)$ and $\\sum N_i y_i = y(\\xi,\\eta)$. By the partition of unity property, $\\sum N_i = 1$. Therefore,\n$$\n\\hat{u}(\\xi, \\eta) = a\\,x(\\xi,\\eta) + b\\,y(\\xi,\\eta) + c = u(x(\\xi,\\eta), y(\\xi,\\eta))\n$$\nThis demonstrates that the bilinear isoparametric element reproduces any linear field **exactly**, regardless of geometric distortion (i.e., for any $\\alpha$).\n\nThe issue of accuracy arises when considering the *derivatives* (gradient) of the field, which are central to FEM calculations for quantities like strain or heat flux. The true gradient of $u(x,y)$ is constant: $(\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y}) = (a, b)$. The gradient of the interpolated field is computed using the inverse Jacobian:\n$$\n\\begin{pmatrix} \\frac{\\partial \\hat{u}}{\\partial x} \\\\ \\frac{\\partial \\hat{u}}{\\partial y} \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\frac{\\partial \\hat{u}}{\\partial \\xi} \\\\ \\frac{\\partial \\hat{u}}{\\partial \\eta} \\end{pmatrix}\n$$\nSince $\\hat{u}(\\xi,\\eta) = a\\,x(\\xi,\\eta)+b\\,y(\\xi,\\eta)+c$, its derivatives with respect to natural coordinates are $\\frac{\\partial \\hat{u}}{\\partial \\xi} = a\\frac{\\partial x}{\\partial \\xi} + b\\frac{\\partial y}{\\partial \\xi}$ and $\\frac{\\partial \\hat{u}}{\\partial \\eta} = a\\frac{\\partial x}{\\partial \\eta} + b\\frac{\\partial y}{\\partial \\eta}$. In matrix form, this is $(\\frac{\\partial \\hat{u}}{\\partial \\xi}, \\frac{\\partial \\hat{u}}{\\partial \\eta})^T = J^T (a,b)^T$.\nSubstituting this into the gradient formula gives:\n$$\n\\begin{pmatrix} \\frac{\\partial \\hat{u}}{\\partial x} \\\\ \\frac{\\partial \\hat{u}}{\\partial y} \\end{pmatrix} = J^{-1} J^T \\begin{pmatrix} a \\\\ b \\end{pmatrix}\n$$\nFor the gradient to be reproduced exactly, we require the interpolated gradient to equal $(a,b)^T$. This holds if and only if $J^{-1}J^T = I$, the identity matrix, which implies $J^T = J$. The Jacobian matrix must be symmetric.\n\nLet us examine the symmetry of our Jacobian:\n$$\nJ(\\xi,\\eta)=\n\\begin{pmatrix}\n\\frac{L}{4}(2+\\alpha+\\alpha\\eta) & \\frac{L \\alpha}{4}(1+\\xi) \\\\[4pt]\n0 & \\frac{H}{2}\n\\end{pmatrix}\n$$\nSymmetry requires $J_{12} = J_{21}$. This means $\\frac{L \\alpha}{4}(1+\\xi) = 0$. Since $L>0$ and this must hold for all $\\xi \\in [-1,1]$, the condition simplifies to $\\alpha=0$.\n\nIf $\\alpha=0$, the element is a rectangle (an affine mapping from the reference square), $J=\\text{diag}(L/2, H/2)$ is constant and symmetric, and constant gradients are reproduced exactly.\nIf $\\alpha \\neq 0$, the element is a non-parallelogram quadrilateral, representing a non-affine mapping. The Jacobian $J(\\xi,\\eta)$ is not symmetric and is not constant. The matrix $J^{-1}J^T$ is not the identity matrix and its entries depend on $\\xi$ and $\\eta$. Consequently, the computed gradient $(\\frac{\\partial \\hat{u}}{\\partial x}, \\frac{\\partial \\hat{u}}{\\partial y})$ is not constant within the element and is not equal to the true gradient $(a, b)$.\n\nIn conclusion, non-affine distortion ($\\alpha \\neq 0$) causes a loss of interpolation accuracy for the *gradient* of a linear field. This distortion introduces a non-uniform geometric metric (related to $J^T J$) across the element, which means that the mapping warps the geometry non-uniformly. While field values remain exact, the derivatives become functions of position and are thus inexact. This is a fundamental limitation of distorted isoparametric elements.",
            "answer": "$$\n\\boxed{\\frac{LH}{8}(2+\\alpha+\\alpha\\eta)}\n$$"
        },
        {
            "introduction": "While linear models are foundational, most real-world systems exhibit nonlinear behavior, a challenge that any robust Digital Twin must handle. This practice transitions to the nonlinear domain, where solutions are found iteratively using methods like the Newton-Raphson algorithm . You will implement a solver and confront the critical task of computing the tangent stiffness matrix, comparing a traditional finite-difference approximation with the exact matrix obtained via Automatic Differentiation (AD). This coding exercise highlights the superior convergence and robustness offered by AD, a modern technique essential for developing fast and reliable nonlinear models for real-time DT applications.",
            "id": "4222504",
            "problem": "Consider embedding Automatic Differentiation (AD) in a Finite Element Method (FEM) code to compute exact algorithmic tangents for a one-dimensional nonlinear bar model that serves as the constitutive core of a Digital Twin (DT) within a Cyber-Physical System (CPS). The bar occupies an interval of length $L$, has constant cross-sectional area $A$, and is discretized using $n$ linear two-node elements with nodal displacements collected into the vector $u \\in \\mathbb{R}^{n+1}$. The left end is fixed with $u_0 = 0$, and a nonzero external force $P$ is applied at the rightmost node. The material response is characterized by a nonlinear stress-strain relation $\\sigma(\\varepsilon)$ that is monotone and smooth. Your task is to derive and implement from first principles the residual and tangent operators for Newton's method, and then to compare an AD-based exact tangent to a finite-difference tangent in terms of iteration counts and robustness, highlighting implications for reliable DT operation.\n\nUse the following fundamental base:\n- The weak form of equilibrium for a one-dimensional bar under axial load requires that the internal virtual work balance external virtual work. With linear shape functions on each element of length $l_e$, constant strain $\\varepsilon_e$ on each element, and stress $\\sigma(\\varepsilon_e)$, the element internal force vector equals\n$$\nf_e = \\int_{0}^{l_e} B^\\top \\sigma(\\varepsilon_e) A \\, dx = A\\,l_e\\,B^\\top \\sigma(\\varepsilon_e),\n$$\nwhere $B = [-1/l_e,\\;1/l_e]$ is the strain-displacement matrix for the two-node element, and $\\varepsilon_e = (u_j - u_i)/l_e$ for local node indices $i$ and $j$.\n- The global residual $R(u)$ for the free degrees of freedom equals the assembled internal force contributions minus the external force vector $F_{\\text{ext}}$, and the Newton update solves\n$$\nK(u)\\,\\Delta u = -R(u), \\quad u \\leftarrow u + \\Delta u,\n$$\nwhere $K(u)$ is the tangent stiffness matrix defined by the Jacobian $K(u) = \\frac{\\partial R}{\\partial u}$.\n- Automatic Differentiation (AD) can propagate derivatives exactly through arithmetic to compute $K(u)$ without symbolic derivation or finite differences.\n\nAdopt a nondimensionalized constitutive law to focus on algorithmic fundamentals, avoiding physical units: let the stress be given by\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3,\n$$\nwhere $E$ and $\\alpha$ are nondimensional parameters, $\\varepsilon$ is the nondimensional engineering strain, and all variables are dimensionless. The discretization uses $n$ equal segments so $l_e = L/n$.\n\nImplement the following in a complete program:\n1. Assemble the global residual $R(u)$ for the free degrees of freedom using the element formula and boundary conditions. Use the vector of unknowns $u_{\\text{free}} \\in \\mathbb{R}^n$ for nodes $1,\\dots,n$ with $u_0 = 0$ fixed. The external force vector is zero everywhere except the rightmost free node, where it equals $P$.\n2. Implement two tangent operators:\n   - An AD-based exact tangent $K_{\\text{AD}}(u)$ by forward-mode AD over the free degrees of freedom, where each scalar variable carries a derivative vector of length $n$.\n   - A finite-difference tangent $K_{\\text{FD}}(u)$ using central differences with a small perturbation $h$ for each free degree of freedom.\n3. Implement a Newton solver with a backtracking line search that updates $u$ until the residual norm is sufficiently small. Use the same solver structure with either $K_{\\text{AD}}(u)$ or $K_{\\text{FD}}(u)$.\n4. For each test case, report the total number of Newton iterations required for convergence for both the AD and FD tangents, and compute the ratio $\\rho = \\text{iterations}_{\\text{FD}} / \\text{iterations}_{\\text{AD}}$ as a float.\n\nUse the following nondimensional test suite to probe algorithmic behavior:\n- Case A (happy path, linear law): $n = \\,4$, $L = \\,1$, $A = \\,1$, $E = \\,1$, $\\alpha = \\,0$, $P = \\,1$.\n- Case B (mild nonlinearity, moderate mesh): $n = \\,8$, $L = \\,1$, $A = \\,1$, $E = \\,1$, $\\alpha = \\,10$, $P = \\,2$.\n- Case C (stronger nonlinearity, finer mesh): $n = \\,16$, $L = \\,1$, $A = \\,1$, $E = \\,1$, $\\alpha = \\,100$, $P = \\,4$.\n- Case D (stiff response with smaller area, finest mesh): $n = \\,32$, $L = \\,1$, $A = \\,0.5$, $E = \\,1$, $\\alpha = \\,1000$, $P = \\,4$.\n\nAngle units are not applicable in this one-dimensional axial problem. All quantities are nondimensional numbers.\n\nYour program should produce a single line of output containing the ratios $\\rho$ for Cases Aâ€“D as a comma-separated list enclosed in square brackets, for example, $[r_A,r_B,r_C,r_D]$, where each $r_\\cdot$ is a float. No other text should be printed.\n\nThe final outputs are floats and must be aggregated exactly as specified. The program must be completely self-contained, require no user input, and must rely solely on the prescribed libraries and the Python standard library.",
            "solution": "The user provided a valid problem statement.\n\n### Introduction and Principle-Based Formulation\n\nThe problem requires the implementation of a one-dimensional nonlinear Finite Element Method (FEM) solver for a bar element. The goal is to compare the performance of a Newton-Raphson solver when its required tangent stiffness matrix is computed using two different methods: Automatic Differentiation (AD) and Finite Differences (FD). The performance is measured by the number of iterations required for convergence, which has direct implications for the efficiency and reliability of Digital Twins (DTs) in Cyber-Physical Systems (CPS), where rapid and accurate model updates are crucial.\n\nThe physical model is a bar of length $L$ and area $A$, fixed at one end ($u_0=0$) and subjected to a point load $P$ at the other. The material exhibits a nonlinear stress-strain response given by the constitutive law:\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3\n$$\nwhere $\\sigma$ is the nondimensional stress, $\\varepsilon$ is the nondimensional strain, and $E$ and $\\alpha$ are material parameters. The bar is discretized into $n$ linear two-node elements of equal length $l_e = L/n$.\n\n### Residual Vector Assembly\n\nThe equilibrium of the system is expressed by the weak form, which states that the sum of internal forces must balance the external forces. For a set of nodal displacements $u$, the residual vector $R(u)$ represents this imbalance:\n$$\nR(u) = F_{\\text{int}}(u) - F_{\\text{ext}}\n$$\nwhere $F_{\\text{int}}(u)$ is the vector of internal forces assembled from element contributions, and $F_{\\text{ext}}$ is the vector of external applied forces. The system is in equilibrium when $R(u) = 0$.\n\nFor a single element $e$ connecting nodes $i$ and $j$ with displacements $u_i$ and $u_j$, the strain is constant: $\\varepsilon_e = (u_j - u_i) / l_e$. The corresponding stress is $\\sigma_e = \\sigma(\\varepsilon_e)$. The internal force vector for this element is given by:\n$$\nf_e = A\\, \\sigma_e \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\nThis vector represents the forces the element exerts on its nodes. The global internal force vector $F_{\\text{int}}$ is assembled by summing these contributions at each node. For an interior node $k$ connected to element $k-1$ (on its left) and element $k$ (on its right), the internal force is $F_{\\text{int}, k} = A(\\sigma_{k-1} - \\sigma_k)$. For the rightmost free node $n$, it is $F_{\\text{int}, n} = A\\sigma_{n-1}$.\n\nThe external force vector $F_{\\text{ext}}$ for the $n$ free degrees of freedom (nodes $1, \\dots, n$) is zero everywhere except for the last component, which corresponds to node $n$ and has a value of $P$.\n\n### Tangent Stiffness Matrix\n\nThe Newton-Raphson method is an iterative procedure to find the root of $R(u)=0$. It linearizes the system at the current displacement estimate $u_k$ and solves for an update $\\Delta u$:\n$$\nK(u_k) \\, \\Delta u = -R(u_k)\n$$\nThe new displacement is then $u_{k+1} = u_k + s\\,\\Delta u$, where $s$ is a step length determined by a line search. The matrix $K(u)$ is the tangent stiffness matrix, defined as the Jacobian of the residual with respect to the displacements: $K(u) = \\frac{\\partial R(u)}{\\partial u}$.\n\nThe element tangent stiffness matrix $k_e$ is the derivative of the element force vector $f_e$ with respect to the element's nodal displacements $[u_i, u_j]^\\top$:\n$$\nk_e = \\frac{\\partial f_e}{\\partial [u_i, u_j]^\\top} = \\frac{A}{l_e} \\frac{\\partial \\sigma_e}{\\partial \\varepsilon_e} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nThe term $\\frac{\\partial \\sigma_e}{\\partial \\varepsilon_e}$ is the tangent modulus, $E_t = E + 3\\alpha\\varepsilon_e^2$. The global tangent matrix $K(u)$ is assembled from these element matrices $k_e$ analogously to the force vector assembly.\n\n### Algorithmic Tangent Implementations\n\n**1. Automatic Differentiation (AD) Tangent, $K_{\\text{AD}}$**\n\nAD computes exact derivatives of functions specified as computer programs. We use forward-mode AD with vector-valued derivatives. We define a `Dual` number class to represent a value and its derivative simultaneously. A variable $x$ is represented by a pair $(x, \\dot{x})$, where $\\dot{x} = \\frac{\\partial x}{\\partial u_{\\text{free}}}$ is a vector of size $n$. Arithmetic operations are overloaded to propagate derivatives according to the rules of calculus:\n- $(x, \\dot{x}) + (y, \\dot{y}) = (x+y, \\dot{x}+\\dot{y})$\n- $(x, \\dot{x}) \\cdot (y, \\dot{y}) = (xy, x\\dot{y} + y\\dot{x})$\n- $(x, \\dot{x})^c = (x^c, c x^{c-1} \\dot{x})$\n\nTo compute the full Jacobian $K = \\frac{\\partial R}{\\partial u_{\\text{free}}}$ in a single pass, we \"seed\" the input vector $u_{\\text{free}}$. Each component $u_j$ is initialized as a `Dual` number with its value and a derivative vector equal to the $j$-th standard basis vector $e_j \\in \\mathbb{R}^n$.\n$$\nu_{\\text{free}, j} \\rightarrow \\text{Dual}(u_{\\text{free}, j}, e_j)\n$$\nThe residual assembly code is then executed exactly once. Since every operation is overloaded, the output residual vector $R$ will also be a vector of `Dual` numbers. The $i$-th component will be $\\text{Dual}(R_i, \\frac{\\partial R_i}{\\partial u_{\\text{free}}})$. The derivative part of the $i$-th dual number is precisely the $i$-th row of the Jacobian matrix $K_{\\text{AD}}$. This method yields the exact (to machine precision) tangent matrix.\n\n**2. Finite Difference (FD) Tangent, $K_{\\text{FD}}$**\n\nFD approximates derivatives by evaluating the function at perturbed points. The $j$-th column of the tangent matrix can be approximated using a central difference formula:\n$$\nK_{FD, \\cdot j} = \\frac{\\partial R}{\\partial u_j} \\approx \\frac{R(u + h\\,e_j) - R(u - h\\,e_j)}{2h}\n$$\nwhere $h$ is a small perturbation step size (e.g., $10^{-7}$) and $e_j$ is the $j$-th standard basis vector. This approach requires $2n$ evaluations of the residual function to construct the full $n \\times n$ tangent matrix. The accuracy is subject to both truncation error (from the formula) and round-off error (from subtracting nearly equal numbers), and the choice of $h$ is critical.\n\n### Newton Solver and Comparison\n\nA Newton-Raphson solver is implemented with a backtracking line search. The line search reduces the step size $s$ (starting from $s=1$) until the norm of the new residual is smaller than the current one, ensuring progress toward the solution. The solver is run with both $K_{\\text{AD}}$ and $K_{\\text{FD}}$.\n\nFor linear problems (Case A, $\\alpha=0$), both methods should yield an exact tangent and converge in one iteration, giving a ratio $\\rho=1.0$. For nonlinear problems, $K_{\\text{AD}}$ remains exact, preserving the quadratic convergence rate of the Newton method. $K_{\\text{FD}}$ is an approximation, which degrades the convergence to superlinear at best and can require significantly more iterations, especially for strongly nonlinear cases where the tangent stiffness changes rapidly. The ratio $\\rho = \\text{iterations}_{\\text{FD}} / \\text{iterations}_{\\text{AD}}$ is expected to be $\\ge 1$, with larger values indicating the superior robustness and efficiency of the AD-based approach. This robustness is paramount for DTs, which must remain synchronized with their physical counterparts under diverse and possibly extreme operating conditions.",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"A class to represent dual numbers for forward-mode automatic differentiation.\"\"\"\n    def __init__(self, value, derivative):\n        self.value = float(value)\n        self.derivative = np.array(derivative, dtype=float)\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.derivative + other.derivative)\n        return Dual(self.value + other, self.derivative)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.derivative - other.derivative)\n        return Dual(self.value - other, self.derivative)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.derivative)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.value * other.derivative + other.value * self.derivative)\n        return Dual(self.value * other, other * self.derivative)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            val = self.value / other.value\n            der = (self.derivative * other.value - self.value * other.derivative) / (other.value ** 2)\n            return Dual(val, der)\n        val = self.value / other\n        der = self.derivative / other\n        return Dual(val, der)\n\n    def __rtruediv__(self, other):\n        val = other / self.value\n        der = (-other * self.derivative) / (self.value ** 2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        if isinstance(power, (int, float)):\n            return Dual(self.value ** power, power * (self.value ** (power - 1)) * self.derivative)\n        raise NotImplementedError(\"Power for Dual numbers must be a scalar.\")\n\n    def __neg__(self):\n        return Dual(-self.value, -self.derivative)\n\ndef assemble_residual(u_free, n, L, A, E, alpha, P):\n    \"\"\"\n    Assembles the residual vector. Polymorphic to handle both floats and Dual numbers.\n    \"\"\"\n    num_free_dofs = n\n    l_e = L / n\n\n    if num_free_dofs > 0 and isinstance(u_free[0], Dual):\n        is_ad_mode = True\n        derivative_size = len(u_free[0].derivative)\n        zero_val = Dual(0.0, np.zeros(derivative_size))\n        u_full = [zero_val] + list(u_free)\n        F_int_full = [zero_val] * (n + 1)\n    else:\n        is_ad_mode = False\n        u_full = np.concatenate(([0.0], u_free))\n        F_int_full = np.zeros(n + 1)\n\n    for e in range(n):\n        u_i = u_full[e]\n        u_j = u_full[e+1]\n        \n        strain = (u_j - u_i) / l_e\n        stress = E * strain + alpha * strain**3\n        force_scalar = A * stress\n        \n        F_int_full[e] = F_int_full[e] - force_scalar\n        F_int_full[e+1] = F_int_full[e+1] + force_scalar\n\n    F_int_free = F_int_full[1:]\n\n    if is_ad_mode:\n        F_ext_free = [zero_val] * num_free_dofs\n        if P != 0:\n            F_ext_free[-1] = Dual(P, np.zeros(derivative_size))\n        R = [F_int_free[i] - F_ext_free[i] for i in range(num_free_dofs)]\n    else:\n        F_ext_free = np.zeros(num_free_dofs)\n        if P != 0:\n            F_ext_free[-1] = P\n        R = np.array(F_int_free) - F_ext_free\n        \n    return R\n\ndef get_tangent_ad(u_free, n, L, A, E, alpha, P):\n    \"\"\"Computes the residual and exact tangent stiffness matrix using AD.\"\"\"\n    num_free_dofs = len(u_free)\n    u_free_dual = [Dual(u_free[i], np.eye(1, num_free_dofs, i)[0]) for i in range(num_free_dofs)]\n    \n    R_dual = assemble_residual(u_free_dual, n, L, A, E, alpha, P)\n    \n    R_val = np.array([r.value for r in R_dual])\n    K = np.array([r.derivative for r in R_dual])\n    \n    return R_val, K\n\ndef get_tangent_fd(u_free, h, n, L, A, E, alpha, P):\n    \"\"\"Computes the residual and approximate tangent stiffness matrix using FD.\"\"\"\n    num_free_dofs = len(u_free)\n    K = np.zeros((num_free_dofs, num_free_dofs))\n    \n    R0 = assemble_residual(u_free, n, L, A, E, alpha, P)\n\n    for j in range(num_free_dofs):\n        u_plus = u_free.copy()\n        u_minus = u_free.copy()\n        u_plus[j] += h\n        u_minus[j] -= h\n        \n        R_plus = assemble_residual(u_plus, n, L, A, E, alpha, P)\n        R_minus = assemble_residual(u_minus, n, L, A, E, alpha, P)\n        \n        K[:, j] = (R_plus - R_minus) / (2 * h)\n        \n    return R0, K\n\ndef newton_solver(tangent_method, n, L, A, E, alpha, P):\n    \"\"\"\n    Performs Newton-Raphson iteration to solve the nonlinear system.\n    \"\"\"\n    u_free = np.zeros(n)\n    h_fd = 1e-7\n    max_iter = 50\n    tol = 1e-9\n\n    for i in range(max_iter):\n        if tangent_method == 'AD':\n            R, K = get_tangent_ad(u_free, n, L, A, E, alpha, P)\n        else: # 'FD'\n            R, K = get_tangent_fd(u_free, h_fd, n, L, A, E, alpha, P)\n        \n        res_norm = np.linalg.norm(R)\n        if res_norm  tol:\n            return i\n\n        try:\n            delta_u = np.linalg.solve(K, -R)\n        except np.linalg.LinAlgError:\n            return max_iter # Failure to solve\n\n        # Backtracking line search\n        s = 1.0\n        for _ in range(10): # Max 10 line search steps\n            u_try = u_free + s * delta_u\n            R_try = assemble_residual(u_try, n, L, A, E, alpha, P)\n            if np.linalg.norm(R_try)  res_norm:\n                break\n            s *= 0.5\n        \n        u_free = u_free + s * delta_u\n\n    return max_iter\n\ndef solve():\n    test_cases = [\n        (4, 1.0, 1.0, 1.0, 0.0, 1.0),    # Case A\n        (8, 1.0, 1.0, 1.0, 10.0, 2.0),   # Case B\n        (16, 1.0, 1.0, 1.0, 100.0, 4.0), # Case C\n        (32, 1.0, 0.5, 1.0, 1000.0, 4.0),# Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        n, L, A, E, alpha, P = params\n        \n        iterations_ad = newton_solver('AD', n, L, A, E, alpha, P)\n        if iterations_ad == 0: iterations_ad = 1 # Linear problem converges in 1 step from zero guess\n        \n        iterations_fd = newton_solver('FD', n, L, A, E, alpha, P)\n        if iterations_fd == 0: iterations_fd = 1\n\n        ratio = float(iterations_fd) / float(iterations_ad)\n        results.append(ratio)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}