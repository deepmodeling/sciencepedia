{
    "hands_on_practices": [
        {
            "introduction": "数字孪生的仿真精度取决于其对物理组件属性的精确建模，其中惯性张量是描述物体质量分布及其对旋转运动抵抗能力的核心。本练习将通过一个将机器人连杆简化为细长杆的典型场景，从第一性原理出发推导其惯性张量，从而巩固您对这一基本物理量的理解 。",
            "id": "4233387",
            "problem": "一个赛博物理系统（CPS）中机器人连杆的数字孪生（DT）需要一致的惯性参数，以用于多体动力学仿真。考虑一根长度为 $L$、质量为 $m$ 的细长均匀杆，其横截面可忽略不计。其中心线在惯性坐标系 $\\{O\\}$ 中沿 $x$ 轴分布，使得质心（COM）位于 $x=0$ 处，杆的范围为 $x \\in [-L/2, L/2]$。仅使用刚体动力学的基本定义，推导该杆关于 (i) 其质心和 (ii) 原点位于杆端点 $x=+L/2$ 处且坐标轴与 $\\{O\\}$ 平行的坐标系的惯性张量。然后，通过比较关于末端坐标系的直接积分与从质心坐标系进行的变换，验证这些张量之间的平行轴定理关系。最后，推广你的结果：令 $a \\in \\mathbb{R}$ 表示沿 $x$ 方向相对于质心的轴向偏移量（因此 $a=0$ 对应质心，$a=L/2$ 对应端点）。提供一个关于距离质心轴向偏移量为 $a$ 的点的杆的惯性张量 $I(a)$ 的单一、闭式解析表达式，该表达式以 $L$ 和 $m$ 表示，形式为一个 $3 \\times 3$ 矩阵，其坐标轴与沿 $x$ 轴的杆中心线对齐。以符号形式表示你的最终答案；不要四舍五入。",
            "solution": "该问题定义明确，植根于经典刚体动力学的基本原理。它要求在不同坐标系下推导细长均匀杆的惯性张量，验证平行轴定理，并进行最终的推广。我们将按步骤进行求解。\n\n对于一个连续体，其关于给定坐标系的惯性张量 $I$ 是一个对称的 $3 \\times 3$ 矩阵，其分量由以下体积积分给出：\n$$\nI_{ij} = \\int_V \\rho(\\mathbf{r}) \\left( (\\mathbf{r} \\cdot \\mathbf{r}) \\delta_{ij} - r_i r_j \\right) dV\n$$\n其中 $\\rho(\\mathbf{r})$ 是位置 $\\mathbf{r}=(x, y, z)$ 处的质量密度，$\\delta_{ij}$ 是克罗内克δ函数，而 $r_i, r_j$ 是 $\\mathbf{r}$ 的分量。具体来说，对角元素（转动惯量）为：\n$$\nI_{xx} = \\int (y^2 + z^2) dm\n$$\n$$\nI_{yy} = \\int (x^2 + z^2) dm\n$$\n$$\nI_{zz} = \\int (x^2 + y^2) dm\n$$\n而非对角元素（惯性积）为：\n$$\nI_{xy} = I_{yx} = -\\int xy \\, dm\n$$\n$$\nI_{xz} = I_{zx} = -\\int xz \\, dm\n$$\n$$\nI_{yz} = I_{zy} = -\\int yz \\, dm\n$$\n对于指定的长度为 $L$、质量为 $m$ 的细长均匀杆，其中心线位于 $x$ 轴上。我们可以将其建模为一维物体。其线质量密度为常数 $\\lambda = m/L$。一个微分质量元为 $dm = \\lambda \\, dx$。对于杆上的任意一点，其坐标为 $(x, 0, 0)$。\n\n(i) 关于质心的惯性张量（$I_{COM}$）的推导。\n坐标系的原点位于质心（COM），因此杆的范围从 $x = -L/2$ 到 $x = L/2$。任何质量元的坐标均为 $y=0$ 和 $z=0$。\n\n转动惯量为：\n$I_{xx, COM} = \\int_{-L/2}^{L/2} (y^2 + z^2) \\lambda \\, dx = \\int_{-L/2}^{L/2} (0^2 + 0^2) \\lambda \\, dx = 0$。\n$I_{yy, COM} = \\int_{-L/2}^{L/2} (x^2 + z^2) \\lambda \\, dx = \\int_{-L/2}^{L/2} x^2 \\lambda \\, dx = \\lambda \\left[ \\frac{x^3}{3} \\right]_{-L/2}^{L/2}$。\n代入 $\\lambda = m/L$：\n$I_{yy, COM} = \\frac{m}{L} \\left( \\frac{(L/2)^3}{3} - \\frac{(-L/2)^3}{3} \\right) = \\frac{m}{L} \\left( \\frac{L^3}{24} + \\frac{L^3}{24} \\right) = \\frac{m}{L} \\left( \\frac{2L^3}{24} \\right) = \\frac{1}{12} mL^2$。\n根据对称性，$I_{zz, COM} = \\int_{-L/2}^{L/2} (x^2 + y^2) \\lambda \\, dx = I_{yy, COM} = \\frac{1}{12} mL^2$。\n\n惯性积全部为零，因为杆上所有质量元的 $y=0$ 且 $z=0$：\n$I_{xy, COM} = -\\int_{-L/2}^{L/2} x(0) \\lambda \\, dx = 0$。\n$I_{xz, COM} = -\\int_{-L/2}^{L/2} x(0) \\lambda \\, dx = 0$。\n$I_{yz, COM} = -\\int_{-L/2}^{L/2} (0)(0) \\lambda \\, dx = 0$。\n\n因此，关于质心的惯性张量为：\n$$\nI_{COM} = \\begin{pmatrix} 0  & 0 & 0 \\\\ 0 & \\frac{1}{12} mL^2 & 0 \\\\ 0 & 0 & \\frac{1}{12} mL^2 \\end{pmatrix}\n$$\n\n(ii) 关于杆端点的惯性张量（$I_{end}$）的推导。\n我们现在考虑一个新的坐标系，其原点位于杆的端点 $x = +L/2$。设此坐标系中的坐标为 $(x', y', z')$。坐标变换为 $x' = x - L/2$，$y' = y$，$z' = z$。在这个新坐标系中，杆的范围从 $x' = -L$ 到 $x' = 0$。任何质量元的坐标均为 $(x', 0, 0)$。\n\n我们在这个新坐标系中通过直接积分计算惯性张量 $I_{end}$：\n$I_{x'x', end} = \\int_{-L}^{0} (y'^2 + z'^2) \\lambda \\, dx' = \\int_{-L}^{0} (0^2+0^2) \\lambda \\, dx' = 0$。\n$I_{y'y', end} = \\int_{-L}^{0} (x'^2 + z'^2) \\lambda \\, dx' = \\int_{-L}^{0} x'^2 \\lambda \\, dx' = \\lambda \\left[ \\frac{x'^3}{3} \\right]_{-L}^{0}$。\n$I_{y'y', end} = \\frac{m}{L} \\left( \\frac{0^3}{3} - \\frac{(-L)^3}{3} \\right) = \\frac{m}{L} \\left( \\frac{L^3}{3} \\right) = \\frac{1}{3} mL^2$。\n根据对称性，$I_{z'z', end} = I_{y'y', end} = \\frac{1}{3} mL^2$。\n惯性积同样为零。因此，关于杆端点的惯性张量为：\n$$\nI_{end} = \\begin{pmatrix} 0  & 0 & 0 \\\\ 0 & \\frac{1}{3} mL^2 & 0 \\\\ 0 & 0 & \\frac{1}{3} mL^2 \\end{pmatrix}\n$$\n\n平行轴定理的验证。\n平行轴定理将关于任意点 $P$ 的惯性张量 $I_P$ 与关于质心的惯性张量 $I_{COM}$ 联系起来。其分量形式为 $I_{ij, P} = I_{ij, COM} + m( (\\mathbf{d} \\cdot \\mathbf{d}) \\delta_{ij} - d_i d_j )$，其中 $\\mathbf{d}$ 是从质心到点 $P$ 的位移矢量。在本例中，$P$ 是杆的端点，因此从质心（位于原点）到端点（位于 $x=L/2$）的位移矢量为 $\\mathbf{d} = (L/2, 0, 0)$。其分量为 $d_x = L/2$，$d_y = 0$，$d_z = 0$。\n\n我们将该定理应用于每个分量：\n$I_{xx, end} = I_{xx, COM} + m(d_y^2 + d_z^2) = 0 + m(0^2 + 0^2) = 0$。\n$I_{yy, end} = I_{yy, COM} + m(d_x^2 + d_z^2) = \\frac{1}{12} mL^2 + m\\left(\\left(\\frac{L}{2}\\right)^2 + 0^2\\right) = \\frac{1}{12} mL^2 + \\frac{1}{4} mL^2 = \\left(\\frac{1}{12} + \\frac{3}{12}\\right) mL^2 = \\frac{4}{12} mL^2 = \\frac{1}{3} mL^2$。\n$I_{zz, end} = I_{zz, COM} + m(d_x^2 + d_y^2) = \\frac{1}{12} mL^2 + m\\left(\\left(\\frac{L}{2}\\right)^2 + 0^2\\right) = \\frac{1}{3} mL^2$。\n$I_{xy, end} = I_{xy, COM} - m d_x d_y = 0 - m(L/2)(0) = 0$。\n同理，$I_{xz, end} = 0$ 且 $I_{yz, end} = 0$。\n\n通过平行轴定理得到的惯性张量为：\n$$\nI_{end} = \\begin{pmatrix} 0  & 0 & 0 \\\\ 0 & \\frac{1}{3} mL^2 & 0 \\\\ 0 & 0 & \\frac{1}{3} mL^2 \\end{pmatrix}\n$$\n此结果与通过直接积分得到的结果一致，从而验证了该定理在本例中的应用。\n\n惯性张量 $I(a)$ 的推广表达式。\n我们寻求关于距离质心轴向偏移量为 $a$ 的点的惯性张量 $I(a)$，因此位移矢量为 $\\mathbf{d} = (a, 0, 0)$。我们使用平行轴定理，其中 $d_x = a$，$d_y = 0$，$d_z = 0$。\n\n$I_{xx}(a) = I_{xx, COM} + m(d_y^2 + d_z^2) = 0 + m(0^2 + 0^2) = 0$。\n$I_{yy}(a) = I_{yy, COM} + m(d_x^2 + d_z^2) = \\frac{1}{12} mL^2 + ma^2$。\n$I_{zz}(a) = I_{zz, COM} + m(d_x^2 + d_y^2) = \\frac{1}{12} mL^2 + ma^2$。\n所有惯性积均为零：\n$I_{xy}(a) = I_{xy, COM} - m d_x d_y = 0 - m(a)(0) = 0$。\n通过类似计算可得 $I_{xz}(a) = 0$ 且 $I_{yz}(a) = 0$。\n\n因此，作为质心轴向偏移量 $a$ 的函数的广义惯性张量 $I(a)$ 为：\n$$\nI(a) = \\begin{pmatrix} 0  & 0 & 0 \\\\ 0 & \\frac{1}{12} mL^2 + ma^2 & 0 \\\\ 0 & 0 & \\frac{1}{12} mL^2 + ma^2 \\end{pmatrix}\n$$\n通过提取质量因子 $m$，可以将其写得更紧凑：\n$$\nI(a) = \\begin{pmatrix} 0  & 0 & 0 \\\\ 0 & m\\left(\\frac{L^2}{12} + a^2\\right) & 0 \\\\ 0 & 0 & m\\left(\\frac{L^2}{12} + a^2\\right) \\end{pmatrix}\n$$\n这个单一的闭式表达式表示了杆关于其轴线上任意一点（距离其质心为 $a$）的惯性张量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & 0 & 0 \\\\\n0 & m\\left(\\frac{L^2}{12} + a^2\\right) & 0 \\\\\n0 & 0 & m\\left(\\frac{L^2}{12} + a^2\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "精确模拟物体的姿态演化是多体动力学仿真的核心，而四元数因其高效和无奇异点的特性成为标准表示方法。本练习将引导您推导四元数运动学的基本方程，并实现一个数值积分器，这是构建任何数字孪生高保真物理引擎的关键一步 。",
            "id": "4233332",
            "problem": "您正在为信息物理系统（CPS）领域中的数字孪生（DT）的姿态分量设计一个旋转状态积分器。DT的刚体姿态由一个四元数 $q(t) \\in \\mathbb{H}$ 表示，其形式为标量优先 $q = [q_0, q_1, q_2, q_3]$，其中 $q_0 \\in \\mathbb{R}$ 且 $[q_1,q_2,q_3]^\\top \\in \\mathbb{R}^3$。体角速度 $\\omega(t) \\in \\mathbb{R}^3$ 在体坐标系中测量，单位为弧度/秒。目标是从第一性原理推导四元数运动学，并实现一个适用于数字孪生中多体动力学仿真的数值上鲁棒的单步积分器。\n\n仅从基本旋转运动学和基本四元数定义出发，完成以下任务：\n\n1. 在体坐标系角速度输入下，推导与3度特殊正交群 (SO(3)) 上的刚体旋转一致的、控制四元数运动学的常微分方程 (ODE)。从旋转矩阵 $R(t) \\in \\mathrm{SO}(3)$ 的基本旋转运动学 $\\dot{R}(t) = R(t)[\\omega(t)]_\\times$ 出发，其中 $[\\omega]_\\times$ 是由 $\\omega$ 构成的 $3 \\times 3$ 斜对称矩阵。将其与四元数表示联系起来，并以关于 $\\omega$ 和 $q$ 的线性矩阵算子形式表示该四元数ODE。\n\n2. 假设 $\\omega(t)$ 在一个小的时步 $\\Delta t > 0$ 内为常数，为 $q(t)$ 提供一个数学上合理的闭式单步更新，并讨论为什么在有限精度算术中再归一化是必要的。\n\n3. 实现一个程序，该程序：\n   - 使用推导出的单步更新，根据给定的 $q(t)$、$\\omega$ 和 $\\Delta t$ 计算 $q(t+\\Delta t)$。\n   - 将所有角度解释为弧度，时间解释为秒。\n   - 在更新后对四元数强制执行单位长度归一化。\n   - 使用与作为瞬时旋转生成元的体角速度一致的左乘法。\n   - 输出为四舍五入到十位小数的浮点数列表。\n\n定义并求解以下测试套件，每个案例提供 $(q(0),\\ \\omega,\\ \\Delta t)$:\n- 案例1（正常路径，有限旋转）：$q(0) = [1,0,0,0]$, $\\omega = [0,0,1]$ $\\mathrm{rad/s}$, $\\Delta t = \\pi$ $\\mathrm{s}$。\n- 案例2（边界情况，零旋转）：$q(0) = [1,0,0,0]$, $\\omega = [0,0,0]$ $\\mathrm{rad/s}$, $\\Delta t = 1.0$ $\\mathrm{s}$。\n- 案例3（边界情况，极小旋转）：$q(0) = [1,0,0,0]$, $\\omega = [10^{-9},0,0]$ $\\mathrm{rad/s}$, $\\Delta t = 1.0$ $\\mathrm{s}$。\n- 案例4（边界情况，非归一化输入四元数和大角度旋转）：$q(0) = [0,2,0,0]$, $\\omega = [2,0,0]$ $\\mathrm{rad/s}$, $\\Delta t = \\frac{\\pi}{2}$ $\\mathrm{s}$。\n- 案例5（绕同一轴的旋转复合）：$q(0) = [\\sqrt{1/2},0,\\sqrt{1/2},0]$, $\\omega = [0,1,0]$ $\\mathrm{rad/s}$, $\\Delta t = \\frac{\\pi}{2}$ $\\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个结果是对应测试案例更新后的四元数，表示为包含四个浮点小数的列表，四舍五入到十位小数。例如，输出必须如下所示：\n$[ [q_{0,1},q_{1,1},q_{2,1},q_{3,1}], [q_{0,2},q_{1,2},q_{2,2},q_{3,2}], \\dots ]$\n不含任何额外文本。四元数分量是无量纲的。",
            "solution": "该问题被评估为有效。它以刚体运动学原理为科学基础，具有明确的目标和充足的数据，问题本身是适定的，并以客观、正式的语言表述。解答按要求分三部分进行。\n\n### 1. 四元数运动学ODE的推导\n\n刚体的姿态可以由一个旋转矩阵 $R(t) \\in \\mathrm{SO}(3)$ 描述，该矩阵将向量从体固坐标系映射到惯性系。问题陈述了在给定体坐标系中表示的角速度 $\\omega(t)$ 的情况下，该矩阵的基本运动学方程：\n$$ \\dot{R}(t) = R(t)[\\omega(t)]_\\times $$\n其中 $[\\omega]_\\times$ 是叉积算子的斜对称矩阵表示：\n$$ [\\omega]_\\times = \\begin{bmatrix} 0 & -\\omega_3 & \\omega_2 \\\\ \\omega_3 & 0 & -\\omega_1 \\\\ -\\omega_2 & \\omega_1 & 0 \\end{bmatrix} $$\n姿态也可以用单位四元数 $q(t) = [q_0, q_1, q_2, q_3]^\\top = [q_0, \\mathbf{q}_v]^\\top$ 表示，并满足约束 $\\|q\\|^2 = q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$。\n\n为推导四元数ODE，我们考虑一个无穷小旋转的影响。在一个微小时间间隔 $\\Delta t$ 内发生的增量旋转可以用一个四元数 $\\Delta q$ 表示。对于绕单位向量 $\\mathbf{u}$ 定义的轴旋转角度 $\\theta$ 的情况，其四元数为 $[\\cos(\\theta/2), \\sin(\\theta/2)\\mathbf{u}]$。对于假设在 $\\Delta t$ 内恒定的角速度 $\\omega$，旋转角为 $\\theta = \\|\\omega\\| \\Delta t$，旋转轴为 $\\mathbf{u} = \\omega / \\|\\omega\\|$。对于无穷小的 $\\Delta t$，我们有 $\\theta \\to 0$，因此 $\\cos(\\theta/2) \\approx 1$ 且 $\\sin(\\theta/2) \\approx \\theta/2 = \\frac{\\|\\omega\\|\\Delta t}{2}$。增量四元数变为：\n$$ \\Delta q \\approx \\left[1, \\frac{\\Delta t}{2} \\frac{\\omega}{\\|\\omega\\|} \\|\\omega\\|\\right] = \\left[1, \\frac{\\Delta t}{2} \\omega\\right] $$\n由于角速度 $\\omega$ 在体坐标系中，新的姿态 $q(t+\\Delta t)$ 是通过将当前姿态 $q(t)$ 与增量旋转 $\\Delta q$ 进行后乘得到的：\n$$ q(t+\\Delta t) = q(t) \\otimes \\Delta q \\approx q(t) \\otimes \\left[1, \\frac{\\Delta t}{2} \\omega\\right] $$\n其中 $\\otimes$ 表示四元数乘积。四元数 $[1, \\mathbf{0}]$ 和 $[0, \\omega]$ 分别是乘法单位元和表示向量 $\\omega$ 的纯四元数。\n\n四元数的时间导数 $\\dot{q}$ 定义为：\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t+\\Delta t) - q(t)}{\\Delta t} $$\n代入 $q(t+\\Delta t)$ 的表达式：\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left[1, \\frac{\\Delta t}{2} \\omega\\right] - q(t)}{\\Delta t} $$\n使用分配律以及 $q(t) \\otimes [1, \\mathbf{0}] = q(t)$：\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left(\\left[1, \\frac{\\Delta t}{2} \\omega\\right] - [1, \\mathbf{0}]\\right)}{\\Delta t} = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left[0, \\frac{\\Delta t}{2} \\omega\\right]}{\\Delta t} $$\n$$ \\dot{q}(t) = q(t) \\otimes \\lim_{\\Delta t \\to 0} \\frac{\\left[0, \\frac{\\Delta t}{2} \\omega\\right]}{\\Delta t} = q(t) \\otimes \\left[0, \\frac{1}{2}\\omega\\right] $$\n令 $\\omega'$ 表示纯四元数 $[0, \\omega_1, \\omega_2, \\omega_3]$，我们得到运动学ODE：\n$$ \\dot{q}(t) = \\frac{1}{2} q(t) \\otimes \\omega' $$\n为将其表示为所要求的线性矩阵算子形式 $\\dot{q} = \\mathbf{A}(\\omega) q$，我们展开四元数乘积。对于 $p=[p_0, \\mathbf{p}_v]$ 和 $r=[r_0, \\mathbf{r}_v]$，其乘积为 $p \\otimes r = [p_0r_0 - \\mathbf{p}_v\\cdot\\mathbf{r}_v, p_0\\mathbf{r}_v + r_0\\mathbf{p}_v + \\mathbf{p}_v\\times\\mathbf{r}_v]$。\n此处，$p=q$ 且 $r=\\omega'$，所以 $r_0=0$ 且 $\\mathbf{r}_v=\\omega$。乘积 $q \\otimes \\omega'$ 为：\n$$ q \\otimes \\omega' = [ - \\mathbf{q}_v \\cdot \\omega, q_0 \\omega + \\mathbf{q}_v \\times \\omega ] $$\n将 $\\dot{q} = \\frac{1}{2} q \\otimes \\omega'$ 的每个分量写出：\n$$ \\dot{q}_0 = \\frac{1}{2}(-q_1\\omega_1 - q_2\\omega_2 - q_3\\omega_3) $$\n$$ \\dot{q}_1 = \\frac{1}{2}( q_0\\omega_1 + q_2\\omega_3 - q_3\\omega_2) $$\n$$ \\dot{q}_2 = \\frac{1}{2}( q_0\\omega_2 + q_3\\omega_1 - q_1\\omega_3) $$\n$$ \\dot{q}_3 = \\frac{1}{2}( q_0\\omega_3 + q_1\\omega_2 - q_2\\omega_1) $$\n该系统可以写成矩阵形式 $\\dot{q} = \\mathbf{A}(\\omega)q$：\n$$ \\begin{bmatrix} \\dot{q}_0 \\\\ \\dot{q}_1 \\\\ \\dot{q}_2 \\\\ \\dot{q}_3 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 0 & -\\omega_1 & -\\omega_2 & -\\omega_3 \\\\ \\omega_1 & 0 & \\omega_3 & -\\omega_2 \\\\ \\omega_2 & -\\omega_3 & 0 & \\omega_1 \\\\ \\omega_3 & \\omega_2 & -\\omega_1 & 0 \\end{bmatrix} \\begin{bmatrix} q_0 \\\\ q_1 \\\\ q_2 \\\\ q_3 \\end{bmatrix} $$\n这就是所期望的线性矩阵算子形式的ODE。问题中提到的“左乘法”被解释为矩阵算子从左侧作用于状态向量 $q$。此形式与体坐标系角速度输入一致。\n\n### 2. 闭式单步更新与再归一化\n\n推导出的ODE $\\dot{q} = \\mathbf{A}(\\omega)q$ 是一个线性时不变系统，前提是假设角速度 $\\omega$ 在积分时步 $\\Delta t$ 内是常数。精确解由矩阵指数给出：\n$$ q(t+\\Delta t) = e^{\\mathbf{A}(\\omega)\\Delta t} q(t) $$\n矩阵 $\\mathbf{A}(\\omega)$ 是斜对称的。该矩阵族的一个关键属性是其平方是单位矩阵的倍数。令 $\\Omega = \\|\\omega\\|$。那么 $(\\mathbf{A}(\\omega))^2 = -(\\frac{\\Omega}{2})^2 I_{4\\times4}$。\n矩阵指数的泰勒级数展开为：\n$$ e^{\\mathbf{A}\\Delta t} = I + (\\mathbf{A}\\Delta t) + \\frac{(\\mathbf{A}\\Delta t)^2}{2!} + \\frac{(\\mathbf{A}\\Delta t)^3}{3!} + \\dots $$\n令 $\\theta = \\frac{\\Omega\\Delta t}{2}$。那么 $(\\mathbf{A}\\Delta t)^2 = -\\theta^2 I$。分组各项：\n$$ e^{\\mathbf{A}\\Delta t} = I \\left(1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\dots\\right) + \\frac{\\mathbf{A}\\Delta t}{\\theta}\\left(\\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots\\right) $$\n$$ e^{\\mathbf{A}\\Delta t} = I \\cos(\\theta) + \\frac{\\mathbf{A}\\Delta t}{\\theta} \\sin(\\theta) $$\n这个矩阵算子提供了一个闭式传播子。然而，一个更直接且物理上更直观的方法是直接对旋转本身进行积分，而不是对状态空间系统进行积分。在 $\\Delta t$ 内的旋转是绕轴 $\\mathbf{u} = \\omega/\\Omega$ 旋转角度 $\\alpha = \\Omega \\Delta t$。表示此有限旋转的四元数是：\n$$ \\Delta q(\\omega, \\Delta t) = \\left[\\cos\\left(\\frac{\\alpha}{2}\\right), \\sin\\left(\\frac{\\alpha}{2}\\right)\\mathbf{u}\\right] = \\left[\\cos\\left(\\frac{\\Omega\\Delta t}{2}\\right), \\sin\\left(\\frac{\\Omega\\Delta t}{2}\\right)\\frac{\\omega}{\\Omega}\\right] $$\n更新后的姿态是通过将初始姿态与此增量旋转进行复合得到的。对于体坐标系速度，这是一个后乘（四元数乘积）：\n$$ q(t+\\Delta t) = q(t) \\otimes \\Delta q(\\omega, \\Delta t) $$\n这提供了鲁棒的、闭式的单步更新规则。对于 $\\Omega \\to 0$ 的边界情况，我们有 $\\Delta q \\to [1, \\mathbf{0}]$，即单位四元数，正确地得出 $q(t+\\Delta t) = q(t)$。\n\n**再归一化的必要性：**\n理论上，两个单位四元数的乘积是另一个单位四元数。因此，如果 $q(t)$ 和 $\\Delta q$ 是单位四元数，$q(t+\\Delta t)$ 也必须是单位四元数。然而，在有限精度计算机算术（例如，IEEE $754$浮点数）中，计算三角函数和执行乘法时会引入舍入误差。例如，计算出的 $\\Delta q$ 的模长可能是 $1 \\pm \\epsilon$，其中 $\\epsilon$ 是一个微小的误差。经过多次积分步骤，这些微小的误差会累积，导致状态四元数 $q(t)$ 的模长偏离1。一个非单位四元数不再代表纯旋转，并可能在仿真中引入不希望的缩放效应。为了抵消这种数值漂移并保持姿态表示的数学有效性，必须在每个更新步骤后对四元数进行显式再归一化：\n$$ q_{\\text{normalized}} = \\frac{q}{\\|q\\|} $$\n\n### 3. 实现与测试套件解答\n\n实现将遵循闭式乘法规则 $q(t+\\Delta t) = q(t) \\otimes \\Delta q$。非单位四元数的输入（例如，案例4）将在计算前进行归一化，以确保初始状态有效。最终结果将被再归一化，以纠正任何浮点不精确性。\n\n- **案例 1:** $q(0)=[1,0,0,0], \\omega=[0,0,1], \\Delta t=\\pi$。\n  $\\Omega=1$。$\\Delta q = [\\cos(\\pi/2), \\sin(\\pi/2)[0,0,1]] = [0,0,0,1]$。\n  $q(\\pi) = [1,0,0,0] \\otimes [0,0,0,1] = [0,0,0,1]$。\n- **案例 2:** $q(0)=[1,0,0,0], \\omega=[0,0,0], \\Delta t=1.0$。\n  $\\Omega=0$。$\\Delta q = [1,0,0,0]$。\n  $q(1.0) = [1,0,0,0] \\otimes [1,0,0,0] = [1,0,0,0]$。\n- **案例 3:** $q(0)=[1,0,0,0], \\omega=[10^{-9},0,0], \\Delta t=1.0$。\n  $\\Omega=10^{-9}$。$\\theta = 0.5 \\times 10^{-9}$。$\\Delta q \\approx [1, 0.5 \\times 10^{-9}, 0, 0]$。\n  $q(1.0) \\approx [1,0,0,0] \\otimes [1, 0.5 \\times 10^{-9}, 0, 0] = [1, 5 \\times 10^{-10}, 0, 0]$。归一化后，在此精度下结果几乎相同。\n- **案例 4:** $q(0)=[0,2,0,0], \\omega=[2,0,0], \\Delta t=\\pi/2$。\n  归一化 $q(0)$：$[0,1,0,0]$。$\\Omega=2$。$\\Delta q = [\\cos(\\pi/2), \\sin(\\pi/2)[1,0,0]] = [0,1,0,0]$。\n  $q(\\pi/2) = [0,1,0,0] \\otimes [0,1,0,0] = [-1,0,0,0]$。\n- **案例 5:** $q(0)=[\\sqrt{0.5},0,\\sqrt{0.5},0], \\omega=[0,1,0], \\Delta t=\\pi/2$。\n  $\\Omega=1$。$\\Delta q = [\\cos(\\pi/4), \\sin(\\pi/4)[0,1,0]] = [\\sqrt{0.5},0,\\sqrt{0.5},0]$。\n  $q(\\pi/2) = q(0) \\otimes \\Delta q = [\\sqrt{0.5},0,\\sqrt{0.5},0] \\otimes [\\sqrt{0.5},0,\\sqrt{0.5},0] = [0,0,1,0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a single-step quaternion integrator for rigid body dynamics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (q(0), omega, delta_t)\n    test_cases = [\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0], np.pi),\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0], 1.0),\n        ([1.0, 0.0, 0.0, 0.0], [1e-9, 0.0, 0.0], 1.0),\n        ([0.0, 2.0, 0.0, 0.0], [2.0, 0.0, 0.0], np.pi / 2.0),\n        ([np.sqrt(0.5), 0.0, np.sqrt(0.5), 0.0], [0.0, 1.0, 0.0], np.pi / 2.0)\n    ]\n\n    results = []\n    \n    # Define a small tolerance for floating point comparisons of norms.\n    TOLERANCE = 1e-15\n\n    for case in test_cases:\n        q_t, omega_vec, dt = case\n        \n        # Convert inputs to numpy arrays for vectorized operations\n        q_t = np.array(q_t, dtype=np.float64)\n        omega_vec = np.array(omega_vec, dtype=np.float64)\n\n        # Ensure the input quaternion is a unit quaternion\n        # This handles cases like test case 4 and ensures a valid starting state.\n        q_norm = np.linalg.norm(q_t)\n        if abs(q_norm - 1.0) > TOLERANCE :\n            q_t /= q_norm\n            \n        omega_norm = np.linalg.norm(omega_vec)\n\n        # Handle the case of zero angular velocity\n        if omega_norm  TOLERANCE:\n            q_t_plus_dt = q_t\n        else:\n            # Calculate the parameters for the incremental rotation quaternion\n            angle = omega_norm * dt\n            axis = omega_vec / omega_norm\n            \n            # Construct the incremental quaternion: delta_q = [cos(angle/2), sin(angle/2)*axis]\n            half_angle = angle / 2.0\n            delta_q_scalar = np.cos(half_angle)\n            delta_q_vector = np.sin(half_angle) * axis\n            delta_q = np.concatenate(([delta_q_scalar], delta_q_vector))\n            \n            # Perform quaternion multiplication: q(t+dt) = q(t) * delta_q\n            # q = [q0, qv], delta_q = [dq0, dqv]\n            # q_new = [q0*dq0 - qv.dqv, q0*dqv + dq0*qv + qv x dqv]\n            q0, qv = q_t[0], q_t[1:]\n            dq0, dqv = delta_q[0], delta_q[1:]\n            \n            q_new_scalar = q0 * dq0 - np.dot(qv, dqv)\n            q_new_vector = q0 * dqv + dq0 * qv + np.cross(qv, dqv)\n            \n            q_t_plus_dt = np.concatenate(([q_new_scalar], q_new_vector))\n\n        # Re-normalize the resulting quaternion to counteract numerical drift\n        q_final_norm = np.linalg.norm(q_t_plus_dt)\n        if q_final_norm > TOLERANCE:\n            q_t_plus_dt /= q_final_norm\n            \n        # Round the final result to 10 decimal places and convert to a list\n        result_list = np.round(q_t_plus_dt, 10).tolist()\n        results.append(result_list)\n\n    # Final print statement in the exact required format.\n    # Using str() on a list automatically produces the required format '[a, b, c, d]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在多体系统中，维持部件间的运动学约束是确保仿真真实性的关键，但数值积分过程常引入约束漂移。本练习将让您亲手实现坐标投影法，这是一种广泛用于校正误差、强制使仿真状态返回约束流形的实用后处理技术 。",
            "id": "4233339",
            "problem": "考虑一个适用于信息物理系统（Cyber-Physical System, CPS）中数字孪生（Digital Twin, DT）同步的平面双体完整约束系统。设广义坐标为 $q \\in \\mathbb{R}^4$，其中 $q = [x_1, y_1, x_2, y_2]^T$ 表示两个点状质量的笛卡尔位置（单位：米），广义速度为 $\\dot{q} \\in \\mathbb{R}^4$（单位：米/秒）。该系统受两个完整约束：\n1. 两个质量之间长度为 $L$（单位：米）的刚性距离约束：$$\\phi_1(q) = (x_2 - x_1)^2 + (y_2 - y_1)^2 - L^2 = 0.$$\n2. 第一个质量半径为 $R$（单位：米）的圆形路径约束：$$\\phi_2(q) = x_1^2 + y_1^2 - R^2 = 0.$$\n将约束向量定义为 $\\phi(q) = [\\phi_1(q), \\phi_2(q)]^T \\in \\mathbb{R}^2$。设约束雅可比矩阵为 $J(q) = \\frac{\\partial \\phi}{\\partial q} \\in \\mathbb{R}^{2 \\times 4}$，其行由每个约束相对于 $q$ 的梯度给出。在没有显式时间依赖的情况下，约束的时间导数为 $\\dot{\\phi}(q, \\dot{q}) = J(q)\\dot{q}$。\n\n在执行一个无约束的显式欧拉积分步骤后\n$$q^\\ast = q + \\Delta t \\, \\dot{q}, \\quad \\dot{q}^\\ast = \\dot{q},$$\n需要进行坐标投影，以重新强制位置和速度的一致性，从而减轻数字孪生中的约束漂移。通过求解线性化的完整约束修正来实现坐标投影\n$$J(q^\\ast) \\, \\Delta q = -\\phi(q^\\ast)$$\n通过正交三角（QR）分解，并将位置更新为 $q^+ = q^\\ast + \\Delta q$。然后通过求解\n$$J(q^+) \\, \\Delta \\dot{q} = -\\dot{\\phi}(q^+, \\dot{q}^\\ast) = -J(q^+) \\, \\dot{q}^\\ast$$\n来更新速度，通过 QR 分解，并设置 $\\dot{q}^+ = \\dot{q}^\\ast + \\Delta \\dot{q}$。使用由 $J(q)^T$ 的简约 QR 分解所蕴含的最小范数解。\n\n你必须推导并实现一个求解器，用于通过 $J^T$ 的简约 QR 分解来求解 $J \\Delta q = b$。如果 $J^T = Q R$，其中 $Q \\in \\mathbb{R}^{4 \\times 2}$ 具有标准正交列，$R \\in \\mathbb{R}^{2 \\times 2}$ 是上三角矩阵，则求解 $R^T y = b$ 得到 $y \\in \\mathbb{R}^2$，然后设置 $\\Delta q = Q y$。对速度投影应用相同的过程。\n\n对于每个测试用例，在执行单步积分并投影过程后，计算以下两个残差：\n- 位置残差：$$r_q = \\left\\| \\phi(q^+) \\right\\|_2 \\quad \\text{单位：} \\text{m}^2。$$\n- 速度残差：$$r_{\\dot{q}} = \\left\\| J(q^+) \\, \\dot{q}^+ \\right\\|_2 \\quad \\text{单位：} \\text{m}^2/\\text{s}。$$\n\n你的程序必须实现上述逻辑，并为每个测试用例生成保留六位小数的配对 $[r_q, r_{\\dot{q}}]$。将所有测试用例的结果聚合到单行输出中，形式为由方括号括起来的逗号分隔列表，例如 $[[r_{q,1}, r_{\\dot{q},1}],[r_{q,2}, r_{\\dot{q},2}],\\dots]$。\n\n使用以下测试套件，它探测了不同的工作状态：\n1. 具有小漂移的理想情况：\n   - $L = 1.0$ 米, $R = 0.5$ 米, $\\Delta t = 0.01$ 秒,\n   - $q = [0.52, \\, 0.00, \\, 1.48, \\, 0.02]^T$ 米,\n   - $\\dot{q} = [0.00, \\, 0.10, \\, -0.05, \\, 0.00]^T$ 米/秒。\n2. 速度为零的边界情况：\n   - $L = 1.2$ 米, $R = 0.6$ 米, $\\Delta t = 0.02$ 秒,\n   - $q = [0.59, \\, 0.01, \\, 0.00, \\, 1.81]^T$ 米,\n   - $\\dot{q} = [0.00, \\, 0.00, \\, 0.00, \\, 0.00]^T$ 米/秒。\n3. 接近奇异的雅可比几何：\n   - $L = 0.8$ 米, $R = 0.4$ 米, $\\Delta t = 0.015$ 秒,\n   - $q = [0.399, \\, 0.010, \\, 1.17705, \\, 0.0395]^T$ 米,\n   - $\\dot{q} = [-0.02, \\, 0.03, \\, 0.01, \\, -0.01]^T$ 米/秒。\n\n所有角度（如果出现）必须以弧度为单位，但本问题仅使用笛卡尔坐标。所有残差均以指定的物理单位表示。你的程序应生成一行输出，其中包含结果，格式为由方括号括起来的逗号分隔列表，例如 $[[r_{q,1},r_{\\dot{q},1}],[r_{q,2},r_{\\dot{q},2}],[r_{q,3},r_{\\dot{q},3}]]$.",
            "solution": "目标是在积分步骤之后，使用线性化的坐标投影来强制施加完整约束。其基本依据是 Newton 粒子运动定律以及完整约束及其雅可比矩阵的定义。对于完整约束 $\\phi(q) = 0$，约束流形是满足这些方程的 $q$ 的集合。时间积分步骤可能会产生偏离流形的 $q^\\ast$。为修正此问题，可以施加一个通过线性化约束得到的小修正量 $\\Delta q$。使用 $\\phi(q)$ 在 $q^\\ast$ 附近的一阶泰勒展开可得\n$$\\phi(q^\\ast + \\Delta q) \\approx \\phi(q^\\ast) + J(q^\\ast) \\, \\Delta q.$$\n强制 $\\phi(q^\\ast + \\Delta q) = 0$ 会得到线性系统\n$$J(q^\\ast) \\, \\Delta q = -\\phi(q^\\ast).$$\n类似地，对于没有显式时间依赖的约束，将 $\\phi(q(t)) = 0$ 对时间求导可得\n$$\\dot{\\phi}(q, \\dot{q}) = J(q) \\, \\dot{q} = 0.$$\n在无约束更新 $\\dot{q}^\\ast$ 之后，速度可能不满足此条件，因此我们增加一个修正量 $\\Delta \\dot{q}$，使得\n$$J(q^+) \\, \\Delta \\dot{q} = -\\dot{\\phi}(q^+, \\dot{q}^\\ast) = -J(q^+) \\, \\dot{q}^\\ast,$$\n这确保了修正后 $(J(q^+) \\, (\\dot{q}^\\ast + \\Delta \\dot{q})) = 0$。\n\n这些系统通常是欠定的，因为 $J \\in \\mathbb{R}^{m \\times n}$ 且 $m \\le n$。为了物理上的一致性，首选最小范数解，以避免与约束子空间正交的不必要变化。一种原则性的方法是对 $J^T$ 使用正交三角（QR）分解。设 $A = J^T \\in \\mathbb{R}^{n \\times m}$ 并计算其简约 QR 分解：\n$$A = Q R,$$\n其中 $Q \\in \\mathbb{R}^{n \\times m}$ 具有标准正交列（$Q^T Q = I_m$），$R \\in \\mathbb{R}^{m \\times m}$ 是上三角矩阵。对 $A$ 进行转置可得 $J = A^T = R^T Q^T$。为了求解 $J \\, \\Delta q = b$，通过以下关系定义 $y \\in \\mathbb{R}^m$\n$$R^T \\, y = b.$$\n由于如果 $J$ 是行满秩的，则 $R^T$ 是三角矩阵且可逆，因此该系统可以通过回代或直接求解器高效求解。然后，最小范数解可被恢复为\n$$\\Delta q = Q \\, y.$$\n为验证，代入：\n$$J \\, \\Delta q = (R^T Q^T)(Q y) = R^T y = b.$$\n此构造在 $Q$ 的列空间中产生解，这对应于所有可能解中的最小欧几里得范数解。\n\n对于每个测试用例，算法按以下步骤进行：\n1. 初始化参数 $L$（米）、$R$（米）、$\\Delta t$（秒）、$q$（米）和 $\\dot{q}$（米/秒）。\n2. 无约束显式欧拉步骤：\n   $$q^\\ast = q + \\Delta t \\, \\dot{q}, \\quad \\dot{q}^\\ast = \\dot{q}.$$\n3. 计算在 $q^\\ast$ 处的约束值：\n   $$\\phi_1(q^\\ast) = (x_2^\\ast - x_1^\\ast)^2 + (y_2^\\ast - y_1^\\ast)^2 - L^2,$$\n   $$\\phi_2(q^\\ast) = (x_1^\\ast)^2 + (y_1^\\ast)^2 - R^2.$$\n4. 计算雅可比矩阵 $J(q^\\ast)$，其行由下式给出\n   $$\\frac{\\partial \\phi_1}{\\partial q} = [-2(x_2^\\ast - x_1^\\ast), \\, -2(y_2^\\ast - y_1^\\ast), \\, 2(x_2^\\ast - x_1^\\ast), \\, 2(y_2^\\ast - y_1^\\ast)],$$\n   $$\\frac{\\partial \\phi_2}{\\partial q} = [2 x_1^\\ast, \\, 2 y_1^\\ast, \\, 0, \\, 0].$$\n5. 构建 $A = J(q^\\ast)^T$ 并计算其简约 QR 分解 $A = Q R$。\n6. 求解 $R^T \\, y = -\\phi(q^\\ast)$ 得到 $y$ 并设置 $\\Delta q = Q \\, y$。\n7. 更新投影后的位置 $q^+ = q^\\ast + \\Delta q$。\n8. 重新计算 $J(q^+)$ 和速度约束残差 $\\dot{\\phi}(q^+, \\dot{q}^\\ast) = J(q^+) \\, \\dot{q}^\\ast$。\n9. 构建 $A_v = J(q^+)^T$，计算 $A_v = Q_v R_v$，求解 $R_v^T \\, y_v = -\\dot{\\phi}(q^+, \\dot{q}^\\ast)$，并设置 $\\Delta \\dot{q} = Q_v \\, y_v$。\n10. 更新投影后的速度 $\\dot{q}^+ = \\dot{q}^\\ast + \\Delta \\dot{q}$。\n11. 计算残差：\n    $$r_q = \\left\\| \\phi(q^+) \\right\\|_2 \\quad (\\text{m}^2), \\quad r_{\\dot{q}} = \\left\\| J(q^+) \\, \\dot{q}^+ \\right\\|_2 \\quad (\\text{m}^2/\\text{s}).$$\n12. 将 $r_q$ 和 $r_{\\dot{q}}$ 四舍五入至六位小数并记录配对 $[r_q, r_{\\dot{q}}]$。\n\n测试套件的覆盖理由：\n- 理想情况使用小漂移和中等速度，测试 $J$ 条件良好时的标准操作。\n- 边界情况使用零速度，验证速度投影能以最小的调整将速度残差降低到接近机器精度的水平。\n- 接近奇异的情况配置 $q$，使得约束的梯度接近共线，从而产生一个病态但仍保持行满秩的 $J$；基于 QR 的求解器保持了数值稳定性，而无需借助伪逆或奇异值分解（SVD）。\n\n最后，程序将三个 $[r_q, r_{\\dot{q}}]$ 配对聚合为单行，格式化为由方括号括起来的逗号分隔列表，以满足要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi(q, L, R):\n    \"\"\"\n    Compute the constraint vector phi(q) for:\n    phi1 = distance^2 - L^2\n    phi2 = x1^2 + y1^2 - R^2\n    \"\"\"\n    x1, y1, x2, y2 = q\n    dxf = x2 - x1\n    dyf = y2 - y1\n    phi1 = dxf * dxf + dyf * dyf - L * L\n    phi2 = x1 * x1 + y1 * y1 - R * R\n    return np.array([phi1, phi2], dtype=float)\n\ndef J(q):\n    \"\"\"\n    Compute the Jacobian J(q) of the constraints with respect to q = [x1, y1, x2, y2].\n    J is 2x4:\n    Row 1: d(phi1)/dq = [-2(dx), -2(dy), 2(dx), 2(dy)]\n    Row 2: d(phi2)/dq = [2*x1, 2*y1, 0, 0]\n    \"\"\"\n    x1, y1, x2, y2 = q\n    dx = x2 - x1\n    dy = y2 - y1\n    J1 = np.array([-2.0 * dx, -2.0 * dy, 2.0 * dx, 2.0 * dy], dtype=float)\n    J2 = np.array([2.0 * x1, 2.0 * y1, 0.0, 0.0], dtype=float)\n    return np.vstack([J1, J2])\n\ndef qr_min_norm_solve(Jmat, b):\n    \"\"\"\n    Solve J x = b for minimum-norm x using reduced QR of J^T:\n    J^T = Q R, with Q (n x m), R (m x m) upper triangular.\n    Solve R^T y = b, then x = Q y.\n    \"\"\"\n    A = Jmat.T  # shape (n, m)\n    # reduced QR: returns Q (n x m), R (m x m)\n    Q, R = np.linalg.qr(A, mode='reduced')\n    # Solve R^T y = b\n    y = np.linalg.solve(R.T, b)\n    x = Q @ y\n    return x\n\ndef project_step(q, qdot, L, R, dt):\n    \"\"\"\n    Perform one unconstrained explicit Euler step followed by coordinate projection\n    for positions and velocities using QR-based minimum-norm solves.\n    Returns projected (q_plus, qdot_plus) and residuals (rq, rvdot).\n    \"\"\"\n    # Unconstrained step\n    q_star = q + dt * qdot\n    qdot_star = qdot.copy()\n\n    # Position projection\n    J_star = J(q_star)\n    phi_star = phi(q_star, L, R)\n    # Solve J_star * dq = -phi_star\n    dq = qr_min_norm_solve(J_star, -phi_star)\n    q_plus = q_star + dq\n\n    # Velocity projection\n    J_plus = J(q_plus)\n    phidot_plus = J_plus @ qdot_star  # since no explicit time dependence\n    # Solve J_plus * dqd = -phidot_plus\n    dqd = qr_min_norm_solve(J_plus, -phidot_plus)\n    qdot_plus = qdot_star + dqd\n\n    # Residuals\n    rq = np.linalg.norm(phi(q_plus, L, R), ord=2)  # in m^2\n    rvdot = np.linalg.norm(J_plus @ qdot_plus, ord=2)  # in m^2/s\n\n    return q_plus, qdot_plus, rq, rvdot\n\ndef format_pair(rq, rvdot):\n    # Round to six decimal places and format\n    return f\"[{rq:.6f},{rvdot:.6f}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L, R, dt, q, qdot)\n    test_cases = [\n        (1.0, 0.5, 0.01, np.array([0.52, 0.00, 1.48, 0.02], dtype=float), np.array([0.00, 0.10, -0.05, 0.00], dtype=float)),\n        (1.2, 0.6, 0.02, np.array([0.59, 0.01, 0.00, 1.81], dtype=float), np.array([0.00, 0.00, 0.00, 0.00], dtype=float)),\n        (0.8, 0.4, 0.015, np.array([0.399, 0.010, 1.17705, 0.0395], dtype=float), np.array([-0.02, 0.03, 0.01, -0.01], dtype=float)),\n    ]\n\n    results_str_items = []\n    for L, R, dt, q, qdot in test_cases:\n        _, _, rq, rvdot = project_step(q, qdot, L, R, dt)\n        results_str_items.append(format_pair(rq, rvdot))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_items)}]\")\n\nsolve()\n```"
        }
    ]
}