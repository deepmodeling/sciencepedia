{
    "hands_on_practices": [
        {
            "introduction": "To simulate the dynamics of a rigid body, we must first mathematically describe its inertial properties. This practice focuses on the inertia tensor, a crucial matrix that quantifies how a body's mass is distributed and how it resists rotational acceleration. By deriving the inertia tensor for a simple object from first principles, you will gain a concrete understanding of this fundamental concept and verify the powerful parallel axis theorem, which is essential for analyzing complex multibody systems. ",
            "id": "4233387",
            "problem": "A Digital Twin (DT) of a robotic link within a Cyber-Physical System (CPS) requires consistent inertia parameters for multibody dynamics simulation. Consider a slender, uniform rod of length $L$ and mass $m$, with negligible cross-section, whose centerline lies along the $x$-axis in an inertial frame $\\{O\\}$ so that the center of mass (COM) is at $x=0$ and the rod spans $x \\in [-L/2, L/2]$. Using only fundamental definitions from rigid body mechanics, derive the inertia tensor of the rod about (i) its center of mass and (ii) a frame whose origin is at the rod’s end located at $x=+L/2$, with axes parallel to those of $\\{O\\}$. Then, by comparing a direct integral about the end frame to a transformation from the COM frame, verify the parallel axis relationship between these tensors. Finally, generalize your result: let $a \\in \\mathbb{R}$ denote an axial offset along the $x$-direction from the COM (so that $a=0$ gives the COM and $a=L/2$ gives the end). Provide a single, closed-form analytical expression for the inertia tensor $I(a)$ of the rod about the point located at axial offset $a$ from the COM, expressed as a $3 \\times 3$ matrix in terms of $L$ and $m$ with axes aligned to the rod’s centerline along $x$. Express your final answer symbolically; do not round.",
            "solution": "The problem is well-posed and grounded in the fundamental principles of classical rigid body mechanics. It requires the derivation of the inertia tensor for a slender uniform rod under various coordinate systems, verification of the parallel axis theorem, and a final generalization. We shall proceed with the solution.\n\nThe inertia tensor $I$ for a continuous body with respect to a given coordinate system is a symmetric $3 \\times 3$ matrix whose components are given by the volume integrals:\n$$\nI_{ij} = \\int_V \\rho(\\mathbf{r}) \\left( (\\mathbf{r} \\cdot \\mathbf{r}) \\delta_{ij} - r_i r_j \\right) dV\n$$\nwhere $\\rho(\\mathbf{r})$ is the mass density at position $\\mathbf{r}=(x, y, z)$, $\\delta_{ij}$ is the Kronecker delta, and $r_i, r_j$ are the components of $\\mathbf{r}$. Explicitly, the diagonal elements (moments of inertia) are:\n$$\nI_{xx} = \\int (y^2 + z^2) dm\n$$\n$$\nI_{yy} = \\int (x^2 + z^2) dm\n$$\n$$\nI_{zz} = \\int (x^2 + y^2) dm\n$$\nAnd the off-diagonal elements (products of inertia) are:\n$$\nI_{xy} = I_{yx} = -\\int xy \\, dm\n$$\n$$\nI_{xz} = I_{zx} = -\\int xz \\, dm\n$$\n$$\nI_{yz} = I_{zy} = -\\int yz \\, dm\n$$\nFor the specified slender, uniform rod of length $L$ and mass $m$, the centerline lies on the $x$-axis. We can model it as a one-dimensional object. The linear mass density is constant, $\\lambda = m/L$. A differential mass element is $dm = \\lambda \\, dx$. For any point on the rod, the coordinates are $(x, 0, 0)$.\n\n(i) Derivation of the inertia tensor about the center of mass ($I_{COM}$).\nThe origin of the coordinate system is at the center of mass (COM), so the rod extends from $x = -L/2$ to $x = L/2$. The coordinates for any mass element are $y=0$ and $z=0$.\n\nThe moments of inertia are:\n$I_{xx, COM} = \\int_{-L/2}^{L/2} (y^2 + z^2) \\lambda \\, dx = \\int_{-L/2}^{L/2} (0^2 + 0^2) \\lambda \\, dx = 0$.\n$I_{yy, COM} = \\int_{-L/2}^{L/2} (x^2 + z^2) \\lambda \\, dx = \\int_{-L/2}^{L/2} x^2 \\lambda \\, dx = \\lambda \\left[ \\frac{x^3}{3} \\right]_{-L/2}^{L/2}$.\nSubstituting $\\lambda = m/L$:\n$I_{yy, COM} = \\frac{m}{L} \\left( \\frac{(L/2)^3}{3} - \\frac{(-L/2)^3}{3} \\right) = \\frac{m}{L} \\left( \\frac{L^3}{24} + \\frac{L^3}{24} \\right) = \\frac{m}{L} \\left( \\frac{2L^3}{24} \\right) = \\frac{1}{12} mL^2$.\nDue to symmetry, $I_{zz, COM} = \\int_{-L/2}^{L/2} (x^2 + y^2) \\lambda \\, dx = I_{yy, COM} = \\frac{1}{12} mL^2$.\n\nThe products of inertia are all zero because $y=0$ and $z=0$ for all mass elements on the rod:\n$I_{xy, COM} = -\\int_{-L/2}^{L/2} x(0) \\lambda \\, dx = 0$.\n$I_{xz, COM} = -\\int_{-L/2}^{L/2} x(0) \\lambda \\, dx = 0$.\n$I_{yz, COM} = -\\int_{-L/2}^{L/2} (0)(0) \\lambda \\, dx = 0$.\n\nThus, the inertia tensor about the center of mass is:\n$$\nI_{COM} = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{12} mL^2  0 \\\\ 0  0  \\frac{1}{12} mL^2 \\end{pmatrix}\n$$\n\n(ii) Derivation of the inertia tensor about the rod's end ($I_{end}$).\nWe now consider a new frame whose origin is at the end of the rod, $x = +L/2$. Let the coordinates in this frame be $(x', y', z')$. The transformation is $x' = x - L/2$, $y' = y$, $z' = z$. In this new frame, the rod spans from $x' = -L$ to $x' = 0$. The coordinates for any mass element are $(x', 0, 0)$.\n\nWe calculate the inertia tensor $I_{end}$ by direct integration in this new frame:\n$I_{x'x', end} = \\int_{-L}^{0} (y'^2 + z'^2) \\lambda \\, dx' = \\int_{-L}^{0} (0^2+0^2) \\lambda \\, dx' = 0$.\n$I_{y'y', end} = \\int_{-L}^{0} (x'^2 + z'^2) \\lambda \\, dx' = \\int_{-L}^{0} x'^2 \\lambda \\, dx' = \\lambda \\left[ \\frac{x'^3}{3} \\right]_{-L}^{0}$.\n$I_{y'y', end} = \\frac{m}{L} \\left( \\frac{0^3}{3} - \\frac{(-L)^3}{3} \\right) = \\frac{m}{L} \\left( \\frac{L^3}{3} \\right) = \\frac{1}{3} mL^2$.\nBy symmetry, $I_{z'z', end} = I_{y'y', end} = \\frac{1}{3} mL^2$.\nThe products of inertia are again zero. Therefore, the inertia tensor about the rod's end is:\n$$\nI_{end} = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{3} mL^2  0 \\\\ 0  0  \\frac{1}{3} mL^2 \\end{pmatrix}\n$$\n\nVerification of the Parallel Axis Theorem.\nThe parallel axis theorem relates the inertia tensor $I_P$ about an arbitrary point $P$ to the inertia tensor $I_{COM}$ about the center of mass. The component form is $I_{ij, P} = I_{ij, COM} + m( (\\mathbf{d} \\cdot \\mathbf{d}) \\delta_{ij} - d_i d_j )$, where $\\mathbf{d}$ is the displacement vector from the COM to point $P$. In this case, $P$ is the end of the rod, so the displacement vector from the COM (at origin) to the end (at $x=L/2$) is $\\mathbf{d} = (L/2, 0, 0)$. The components are $d_x = L/2$, $d_y = 0$, $d_z = 0$.\n\nLet's apply the theorem to each component:\n$I_{xx, end} = I_{xx, COM} + m(d_y^2 + d_z^2) = 0 + m(0^2 + 0^2) = 0$.\n$I_{yy, end} = I_{yy, COM} + m(d_x^2 + d_z^2) = \\frac{1}{12} mL^2 + m\\left(\\left(\\frac{L}{2}\\right)^2 + 0^2\\right) = \\frac{1}{12} mL^2 + \\frac{1}{4} mL^2 = \\left(\\frac{1}{12} + \\frac{3}{12}\\right) mL^2 = \\frac{4}{12} mL^2 = \\frac{1}{3} mL^2$.\n$I_{zz, end} = I_{zz, COM} + m(d_x^2 + d_y^2) = \\frac{1}{12} mL^2 + m\\left(\\left(\\frac{L}{2}\\right)^2 + 0^2\\right) = \\frac{1}{3} mL^2$.\n$I_{xy, end} = I_{xy, COM} - m d_x d_y = 0 - m(L/2)(0) = 0$.\nSimilarly, $I_{xz, end} = 0$ and $I_{yz, end} = 0$.\n\nThe inertia tensor obtained via the parallel axis theorem is:\n$$\nI_{end} = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{3} mL^2  0 \\\\ 0  0  \\frac{1}{3} mL^2 \\end{pmatrix}\n$$\nThis result matches the one obtained by direct integration, thus verifying the theorem's application for this case.\n\nGeneralized expression for the inertia tensor $I(a)$.\nWe seek the inertia tensor $I(a)$ about a point located at an axial offset $a$ from the COM, so the displacement vector is $\\mathbf{d} = (a, 0, 0)$. We use the parallel axis theorem with $d_x = a$, $d_y = 0$, and $d_z = 0$.\n\n$I_{xx}(a) = I_{xx, COM} + m(d_y^2 + d_z^2) = 0 + m(0^2 + 0^2) = 0$.\n$I_{yy}(a) = I_{yy, COM} + m(d_x^2 + d_z^2) = \\frac{1}{12} mL^2 + m(a^2 + 0^2) = \\frac{1}{12} mL^2 + ma^2$.\n$I_{zz}(a) = I_{zz, COM} + m(d_x^2 + d_y^2) = \\frac{1}{12} mL^2 + m(a^2 + 0^2) = \\frac{1}{12} mL^2 + ma^2$.\nAll products of inertia are zero:\n$I_{xy}(a) = I_{xy, COM} - m d_x d_y = 0 - m(a)(0) = 0$.\n$I_{xz}(a) = 0$ and $I_{yz}(a) = 0$ by similar calculation.\n\nTherefore, the generalized inertia tensor $I(a)$ as a function of the axial offset $a$ from the COM is:\n$$\nI(a) = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{12} mL^2 + ma^2  0 \\\\ 0  0  \\frac{1}{12} mL^2 + ma^2 \\end{pmatrix}\n$$\nThis can be written more compactly by factoring out the mass $m$:\n$$\nI(a) = \\begin{pmatrix} 0  0  0 \\\\ 0  m\\left(\\frac{L^2}{12} + a^2\\right)  0 \\\\ 0  0  m\\left(\\frac{L^2}{12} + a^2\\right) \\end{pmatrix}\n$$\nThis single, closed-form expression represents the inertia tensor of the rod about any point on its axis, a distance $a$ from its center of mass.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0 \\\\\n0  m\\left(\\frac{L^2}{12} + a^2\\right)  0 \\\\\n0  0  m\\left(\\frac{L^2}{12} + a^2\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Once a body's inertial properties are defined, the next task is to simulate its motion through space, with orientation being particularly challenging to handle correctly. This exercise guides you through the derivation and implementation of a quaternion-based integrator, a standard and robust method for updating a body's orientation in 3D space without singularities. This hands-on coding problem is central to building the core of any high-fidelity dynamics simulation or digital twin. ",
            "id": "4233332",
            "problem": "You are designing a rotation state integrator for the orientation component of a Digital Twin (DT) in the domain of Cyber-Physical Systems (CPS). The DT’s rigid body orientation is represented by a quaternion $q(t) \\in \\mathbb{H}$ in scalar-first form $q = [q_0, q_1, q_2, q_3]$, with $q_0 \\in \\mathbb{R}$ and $[q_1,q_2,q_3]^\\top \\in \\mathbb{R}^3$. The body angular velocity $\\omega(t) \\in \\mathbb{R}^3$ is measured in the body frame, with units in radians per second. The goal is to derive the quaternion kinematics from first principles and implement a numerically robust single-step integrator suitable for multibody dynamics simulation in Digital Twins.\n\nStarting exclusively from fundamental rotational kinematics and basic quaternion definitions, do the following:\n\n1. Derive the Ordinary Differential Equation (ODE) governing quaternion kinematics that is consistent with rigid body rotation on the Special Orthogonal Group of degree $3$ (SO(3)) under a body-frame angular velocity input. Begin from the fundamental rotational kinematics $\\dot{R}(t) = R(t)[\\omega(t)]_\\times$ for the rotation matrix $R(t) \\in \\mathrm{SO}(3)$, where $[\\omega]_\\times$ is the $3 \\times 3$ skew-symmetric matrix formed from $\\omega$. Connect this to the quaternion representation and express the quaternion ODE in a linear, matrix-operator form in terms of $\\omega$ and $q$.\n\n2. Provide a mathematically sound, closed-form single-step update for $q(t)$ over a small timestep $\\Delta t  0$ assuming $\\omega(t)$ is constant over this interval, and discuss why renormalization is necessary in finite-precision arithmetic.\n\n3. Implement a program that:\n   - Uses the derived single-step update to compute $q(t+\\Delta t)$ from a given $q(t)$, $\\omega$, and $\\Delta t$.\n   - Interprets all angles in radians and time in seconds.\n   - Enforces unit length normalization on the quaternion after the update.\n   - Uses left-multiplication consistent with the body angular velocity acting as the generator of instantaneous rotation.\n   - Produces outputs as lists of floating-point numbers rounded to ten decimal places.\n\nDefine and solve the following test suite, each case providing $(q(0),\\ \\omega,\\ \\Delta t)$:\n- Case $1$ (happy path, finite rotation): $q(0) = [1,0,0,0]$, $\\omega = [0,0,1]$ $\\mathrm{rad/s}$, $\\Delta t = \\pi$ $\\mathrm{s}$.\n- Case $2$ (edge case, zero rotation): $q(0) = [1,0,0,0]$, $\\omega = [0,0,0]$ $\\mathrm{rad/s}$, $\\Delta t = 1.0$ $\\mathrm{s}$.\n- Case $3$ (boundary case, extremely small rotation): $q(0) = [1,0,0,0]$, $\\omega = [10^{-9},0,0]$ $\\mathrm{rad/s}$, $\\Delta t = 1.0$ $\\mathrm{s}$.\n- Case $4$ (edge case, non-normalized input quaternion and large rotation): $q(0) = [0,2,0,0]$, $\\omega = [2,0,0]$ $\\mathrm{rad/s}$, $\\Delta t = \\frac{\\pi}{2}$ $\\mathrm{s}$.\n- Case $5$ (composition of rotations about same axis): $q(0) = [\\sqrt{1/2},0,\\sqrt{1/2},0]$, $\\omega = [0,1,0]$ $\\mathrm{rad/s}$, $\\Delta t = \\frac{\\pi}{2}$ $\\mathrm{s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is the updated quaternion for the corresponding test case expressed as a list of four decimal floats rounded to ten decimal places. For example, the output must look like:\n$[ [q_{0,1},q_{1,1},q_{2,1},q_{3,1}], [q_{0,2},q_{1,2},q_{2,2},q_{3,2}], \\dots ]$\nwith no extra text. Quaternion components are dimensionless.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of rigid body kinematics, is well-posed with a clear objective and sufficient data, and is expressed in objective, formal language. The solution proceeds in three parts as requested.\n\n### 1. Derivation of the Quaternion Kinematic ODE\n\nThe orientation of a rigid body can be described by a rotation matrix $R(t) \\in \\mathrm{SO}(3)$, which maps vectors from the body-fixed frame to an inertial frame. The problem states the fundamental kinematic equation for this matrix given an angular velocity $\\omega(t)$ expressed in the body frame:\n$$ \\dot{R}(t) = R(t)[\\omega(t)]_\\times $$\nwhere $[\\omega]_\\times$ is the skew-symmetric matrix representation of the cross-product operator:\n$$ [\\omega]_\\times = \\begin{bmatrix} 0  -\\omega_3  \\omega_2 \\\\ \\omega_3  0  -\\omega_1 \\\\ -\\omega_2  \\omega_1  0 \\end{bmatrix} $$\nThe orientation can also be represented by a unit quaternion $q(t) = [q_0, q_1, q_2, q_3]^\\top = [q_0, \\mathbf{q}_v]^\\top$, subject to the constraint $\\|q\\|^2 = q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$.\n\nTo derive the quaternion ODE, we consider the effect of an infinitesimal rotation. An incremental rotation that occurs over a small time interval $\\Delta t$ can be represented by a quaternion $\\Delta q$. For a rotation about an axis defined by the unit vector $\\mathbf{u}$ by an angle $\\theta$, the quaternion is $[\\cos(\\theta/2), \\sin(\\theta/2)\\mathbf{u}]$. For an angular velocity $\\omega$ assumed constant over $\\Delta t$, the rotation angle is $\\theta = \\|\\omega\\| \\Delta t$ and the axis is $\\mathbf{u} = \\omega / \\|\\omega\\|$. For an infinitesimally small $\\Delta t$, we have $\\theta \\to 0$, so $\\cos(\\theta/2) \\approx 1$ and $\\sin(\\theta/2) \\approx \\theta/2 = \\frac{\\|\\omega\\|\\Delta t}{2}$. The incremental quaternion becomes:\n$$ \\Delta q \\approx \\left[1, \\frac{\\Delta t}{2} \\frac{\\omega}{\\|\\omega\\|} \\|\\omega\\|\\right] = \\left[1, \\frac{\\Delta t}{2} \\omega\\right] $$\nSince the angular velocity $\\omega$ is in the body frame, the new orientation $q(t+\\Delta t)$ is obtained by post-multiplying the current orientation $q(t)$ with the incremental rotation $\\Delta q$:\n$$ q(t+\\Delta t) = q(t) \\otimes \\Delta q \\approx q(t) \\otimes \\left[1, \\frac{\\Delta t}{2} \\omega\\right] $$\nwhere $\\otimes$ denotes the quaternion product. The quaternions $[1, \\mathbf{0}]$ and $[0, \\omega]$ are the multiplicative identity and the pure quaternion representing the vector $\\omega$, respectively.\n\nThe time derivative of the quaternion, $\\dot{q}$, is defined as:\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t+\\Delta t) - q(t)}{\\Delta t} $$\nSubstituting the expression for $q(t+\\Delta t)$:\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left[1, \\frac{\\Delta t}{2} \\omega\\right] - q(t)}{\\Delta t} $$\nUsing the distributive property and that $q(t) \\otimes [1, \\mathbf{0}] = q(t)$:\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left(\\left[1, \\frac{\\Delta t}{2} \\omega\\right] - [1, \\mathbf{0}]\\right)}{\\Delta t} = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left[0, \\frac{\\Delta t}{2} \\omega\\right]}{\\Delta t} $$\n$$ \\dot{q}(t) = q(t) \\otimes \\lim_{\\Delta t \\to 0} \\frac{\\left[0, \\frac{\\Delta t}{2} \\omega\\right]}{\\Delta t} = q(t) \\otimes \\left[0, \\frac{1}{2}\\omega\\right] $$\nLetting $\\omega'$ denote the pure quaternion $[0, \\omega_1, \\omega_2, \\omega_3]$, we arrive at the kinematic ODE:\n$$ \\dot{q}(t) = \\frac{1}{2} q(t) \\otimes \\omega' $$\nTo express this in the requested linear matrix-operator form, $\\dot{q} = \\mathbf{A}(\\omega) q$, we expand the quaternion product. For $p=[p_0, \\mathbf{p}_v]$ and $r=[r_0, \\mathbf{r}_v]$, the product is $p \\otimes r = [p_0r_0 - \\mathbf{p}_v\\cdot\\mathbf{r}_v, p_0\\mathbf{r}_v + r_0\\mathbf{p}_v + \\mathbf{p}_v\\times\\mathbf{r}_v]$.\nHere, $p=q$ and $r=\\omega'$, so $r_0=0$ and $\\mathbf{r}_v=\\omega$. The product $q \\otimes \\omega'$ is:\n$$ q \\otimes \\omega' = [ - \\mathbf{q}_v \\cdot \\omega, q_0 \\omega + \\mathbf{q}_v \\times \\omega ] $$\nWriting this out for each component of $\\dot{q} = \\frac{1}{2} q \\otimes \\omega'$:\n$$ \\dot{q}_0 = \\frac{1}{2}(-q_1\\omega_1 - q_2\\omega_2 - q_3\\omega_3) $$\n$$ \\dot{q}_1 = \\frac{1}{2}( q_0\\omega_1 + q_2\\omega_3 - q_3\\omega_2) $$\n$$ \\dot{q}_2 = \\frac{1}{2}( q_0\\omega_2 + q_3\\omega_1 - q_1\\omega_3) $$\n$$ \\dot{q}_3 = \\frac{1}{2}( q_0\\omega_3 + q_1\\omega_2 - q_2\\omega_1) $$\nThis system can be written in the matrix form $\\dot{q} = \\mathbf{A}(\\omega)q$:\n$$ \\begin{bmatrix} \\dot{q}_0 \\\\ \\dot{q}_1 \\\\ \\dot{q}_2 \\\\ \\dot{q}_3 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 0  -\\omega_1  -\\omega_2  -\\omega_3 \\\\ \\omega_1  0  \\omega_3  -\\omega_2 \\\\ \\omega_2  -\\omega_3  0  \\omega_1 \\\\ \\omega_3  \\omega_2  -\\omega_1  0 \\end{bmatrix} \\begin{bmatrix} q_0 \\\\ q_1 \\\\ q_2 \\\\ q_3 \\end{bmatrix} $$\nThis is the desired ODE in a linear, matrix-operator form. The problem's mention of \"left-multiplication\" is interpreted as the matrix operator acting on the state vector $q$ from the left. This form is consistent with a body-frame angular velocity input.\n\n### 2. Closed-Form Single-Step Update and Renormalization\n\nThe derived ODE, $\\dot{q} = \\mathbf{A}(\\omega)q$, is a linear time-invariant system assuming the angular velocity $\\omega$ is constant over the integration timestep $\\Delta t$. The exact solution is given by the matrix exponential:\n$$ q(t+\\Delta t) = e^{\\mathbf{A}(\\omega)\\Delta t} q(t) $$\nThe matrix $\\mathbf{A}(\\omega)$ is skew-symmetric. A key property of this matrix family is that its square is a multiple of the identity matrix. Let $\\Omega = \\|\\omega\\|$. Then $(\\mathbf{A}(\\omega))^2 = -(\\frac{\\Omega}{2})^2 I_{4\\times4}$.\nThe Taylor series expansion of the matrix exponential is:\n$$ e^{\\mathbf{A}\\Delta t} = I + (\\mathbf{A}\\Delta t) + \\frac{(\\mathbf{A}\\Delta t)^2}{2!} + \\frac{(\\mathbf{A}\\Delta t)^3}{3!} + \\dots $$\nLet $\\theta = \\frac{\\Omega\\Delta t}{2}$. Then $(\\mathbf{A}\\Delta t)^2 = -\\theta^2 I$. Grouping terms:\n$$ e^{\\mathbf{A}\\Delta t} = I \\left(1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\dots\\right) + \\frac{\\mathbf{A}\\Delta t}{\\theta}\\left(\\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots\\right) $$\n$$ e^{\\mathbf{A}\\Delta t} = I \\cos(\\theta) + \\frac{\\mathbf{A}\\Delta t}{\\theta} \\sin(\\theta) $$\nThis matrix operator provides a closed-form propagator. However, a more direct and physically intuitive approach is to integrate the rotation itself rather than the state-space system. The rotation over $\\Delta t$ is by an angle $\\alpha = \\Omega \\Delta t$ around the axis $\\mathbf{u} = \\omega/\\Omega$. The quaternion representing this finite rotation is:\n$$ \\Delta q(\\omega, \\Delta t) = \\left[\\cos\\left(\\frac{\\alpha}{2}\\right), \\sin\\left(\\frac{\\alpha}{2}\\right)\\mathbf{u}\\right] = \\left[\\cos\\left(\\frac{\\Omega\\Delta t}{2}\\right), \\sin\\left(\\frac{\\Omega\\Delta t}{2}\\right)\\frac{\\omega}{\\Omega}\\right] $$\nThe updated orientation is found by composing the initial orientation with this incremental rotation. For a body-frame velocity, this is a post-multiplication (quaternion product):\n$$ q(t+\\Delta t) = q(t) \\otimes \\Delta q(\\omega, \\Delta t) $$\nThis provides the robust, closed-form single-step update rule. For the edge case where $\\Omega \\to 0$, we have $\\Delta q \\to [1, \\mathbf{0}]$, the identity quaternion, correctly yielding $q(t+\\Delta t) = q(t)$.\n\n**Necessity of Renormalization:**\nTheoretically, the product of two unit quaternions is another unit quaternion. Therefore, if $q(t)$ and $\\Delta q$ are unit quaternions, $q(t+\\Delta t)$ must also be a unit quaternion. However, in finite-precision computer arithmetic (e.g., IEEE $754$ floating-point), rounding errors are introduced in calculating trigonometric functions and performing products. For example, the computed norm of $\\Delta q$ might be $1 \\pm \\epsilon$, where $\\epsilon$ is a small error. Over many integration steps, these small errors can accumulate, causing the norm of the state quaternion $q(t)$ to drift away from unity. A non-unit quaternion no longer represents a pure rotation and can introduce undesirable scaling effects into the simulation. To counteract this numerical drift and maintain the mathematical validity of the orientation representation, it is essential to explicitly re-normalize the quaternion after each update step:\n$$ q_{\\text{normalized}} = \\frac{q}{\\|q\\|} $$\n\n### 3. Implementation and Test Suite Solution\n\nThe implementation will follow the closed-form multiplication rule $q(t+\\Delta t) = q(t) \\otimes \\Delta q$. Inputs that are not unit quaternions (e.g., Case $4$) will be normalized prior to computation to ensure a valid initial state. The final result will be re-normalized to correct for any floating-point inaccuracies.\n\n- **Case 1:** $q(0)=[1,0,0,0], \\omega=[0,0,1], \\Delta t=\\pi$.\n  $\\Omega=1$. $\\Delta q = [\\cos(\\pi/2), \\sin(\\pi/2)[0,0,1]] = [0,0,0,1]$.\n  $q(\\pi) = [1,0,0,0] \\otimes [0,0,0,1] = [0,0,0,1]$.\n- **Case 2:** $q(0)=[1,0,0,0], \\omega=[0,0,0], \\Delta t=1.0$.\n  $\\Omega=0$. $\\Delta q = [1,0,0,0]$.\n  $q(1.0) = [1,0,0,0] \\otimes [1,0,0,0] = [1,0,0,0]$.\n- **Case 3:** $q(0)=[1,0,0,0], \\omega=[10^{-9},0,0], \\Delta t=1.0$.\n  $\\Omega=10^{-9}$. $\\theta = 0.5 \\times 10^{-9}$. $\\Delta q \\approx [1, 0.5 \\times 10^{-9}, 0, 0]$.\n  $q(1.0) \\approx [1,0,0,0] \\otimes [1, 0.5 \\times 10^{-9}, 0, 0] = [1, 5 \\times 10^{-10}, 0, 0]$. After normalization, the result is practically identical at this precision.\n- **Case 4:** $q(0)=[0,2,0,0], \\omega=[2,0,0], \\Delta t=\\pi/2$.\n  Normalize $q(0)$: $[0,1,0,0]$. $\\Omega=2$. $\\Delta q = [\\cos(\\pi/2), \\sin(\\pi/2)[1,0,0]] = [0,1,0,0]$.\n  $q(\\pi/2) = [0,1,0,0] \\otimes [0,1,0,0] = [-1,0,0,0]$.\n- **Case 5:** $q(0)=[\\sqrt{0.5},0,\\sqrt{0.5},0], \\omega=[0,1,0], \\Delta t=\\pi/2$.\n  $\\Omega=1$. $\\Delta q = [\\cos(\\pi/4), \\sin(\\pi/4)[0,1,0]] = [\\sqrt{0.5},0,\\sqrt{0.5},0]$.\n  $q(\\pi/2) = q(0) \\otimes \\Delta q = [\\sqrt{0.5},0,\\sqrt{0.5},0] \\otimes [\\sqrt{0.5},0,\\sqrt{0.5},0] = [0,0,1,0]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a single-step quaternion integrator for rigid body dynamics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (q(0), omega, delta_t)\n    test_cases = [\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0], np.pi),\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0], 1.0),\n        ([1.0, 0.0, 0.0, 0.0], [1e-9, 0.0, 0.0], 1.0),\n        ([0.0, 2.0, 0.0, 0.0], [2.0, 0.0, 0.0], np.pi / 2.0),\n        ([np.sqrt(0.5), 0.0, np.sqrt(0.5), 0.0], [0.0, 1.0, 0.0], np.pi / 2.0)\n    ]\n\n    results = []\n    \n    # Define a small tolerance for floating point comparisons of norms.\n    TOLERANCE = 1e-15\n\n    for case in test_cases:\n        q_t, omega_vec, dt = case\n        \n        # Convert inputs to numpy arrays for vectorized operations\n        q_t = np.array(q_t, dtype=np.float64)\n        omega_vec = np.array(omega_vec, dtype=np.float64)\n\n        # Ensure the input quaternion is a unit quaternion\n        # This handles cases like test case 4 and ensures a valid starting state.\n        q_norm = np.linalg.norm(q_t)\n        if abs(q_norm - 1.0)  TOLERANCE :\n            q_t /= q_norm\n            \n        omega_norm = np.linalg.norm(omega_vec)\n\n        # Handle the case of zero angular velocity\n        if omega_norm  TOLERANCE:\n            q_t_plus_dt = q_t\n        else:\n            # Calculate the parameters for the incremental rotation quaternion\n            angle = omega_norm * dt\n            axis = omega_vec / omega_norm\n            \n            # Construct the incremental quaternion: delta_q = [cos(angle/2), sin(angle/2)*axis]\n            half_angle = angle / 2.0\n            delta_q_scalar = np.cos(half_angle)\n            delta_q_vector = np.sin(half_angle) * axis\n            delta_q = np.concatenate(([delta_q_scalar], delta_q_vector))\n            \n            # Perform quaternion multiplication: q(t+dt) = q(t) * delta_q\n            # q = [q0, qv], delta_q = [dq0, dqv]\n            # q_new = [q0*dq0 - qv.dqv, q0*dqv + dq0*qv + qv x dqv]\n            q0, qv = q_t[0], q_t[1:]\n            dq0, dqv = delta_q[0], delta_q[1:]\n            \n            q_new_scalar = q0 * dq0 - np.dot(qv, dqv)\n            q_new_vector = q0 * dqv + dq0 * qv + np.cross(qv, dqv)\n            \n            q_t_plus_dt = np.concatenate(([q_new_scalar], q_new_vector))\n\n        # Re-normalize the resulting quaternion to counteract numerical drift\n        q_final_norm = np.linalg.norm(q_t_plus_dt)\n        if q_final_norm  TOLERANCE:\n            q_t_plus_dt /= q_final_norm\n            \n        # Round the final result to 10 decimal places and convert to a list\n        result_list = np.round(q_t_plus_dt, 10).tolist()\n        results.append(result_list)\n\n    # Final print statement in the exact required format.\n    # Using str() on a list automatically produces the required format '[a, b, c, d]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In a multibody system, components are linked by constraints, such as joints or contacts, which must be maintained throughout the simulation. Numerical integration, however, inevitably introduces small errors that cause these constraints to be violated over time, a phenomenon known as constraint drift. This practice introduces coordinate projection, a powerful stabilization technique that corrects these errors after each integration step, ensuring the digital twin remains physically consistent. You will implement this method to enforce geometric constraints in a planar mechanism, a vital skill for developing stable and accurate long-term simulations. ",
            "id": "4233339",
            "problem": "Consider a planar two-body holonomic constraint system suitable for Digital Twin (DT) synchronization in a Cyber-Physical System (CPS). Let the generalized coordinates be $q \\in \\mathbb{R}^4$ with $q = [x_1, y_1, x_2, y_2]^T$ denoting the Cartesian positions of two point masses in meters and generalized velocities $\\dot{q} \\in \\mathbb{R}^4$ in meters per second. The system is subject to two holonomic constraints:\n1. A rigid distance constraint between the two masses of length $L$ (in meters): $$\\phi_1(q) = (x_2 - x_1)^2 + (y_2 - y_1)^2 - L^2 = 0.$$\n2. A circular path constraint for the first mass with radius $R$ (in meters): $$\\phi_2(q) = x_1^2 + y_1^2 - R^2 = 0.$$\nDefine the constraint vector as $\\phi(q) = [\\phi_1(q), \\phi_2(q)]^T \\in \\mathbb{R}^2$. Let the constraint Jacobian be $J(q) = \\frac{\\partial \\phi}{\\partial q} \\in \\mathbb{R}^{2 \\times 4}$ with rows given by the gradients of each constraint with respect to $q$. The time derivative of the constraints under no explicit time dependence is $\\dot{\\phi}(q, \\dot{q}) = J(q)\\dot{q}$.\n\nAfter performing an unconstrained explicit Euler integration step\n$$q^\\ast = q + \\Delta t \\, \\dot{q}, \\quad \\dot{q}^\\ast = \\dot{q},$$\ncoordinate projection is required to re-enforce consistency of positions and velocities to mitigate constraint drift in the DT. Implement the coordinate projection by solving the linearized holonomic correction\n$$J(q^\\ast) \\, \\Delta q = -\\phi(q^\\ast)$$\nvia Orthogonal-Triangular (QR) decomposition, and update positions as $q^+ = q^\\ast + \\Delta q$. Then update velocities by solving\n$$J(q^+) \\, \\Delta \\dot{q} = -\\dot{\\phi}(q^+, \\dot{q}^\\ast) = -J(q^+) \\, \\dot{q}^\\ast$$\nvia QR decomposition, and set $\\dot{q}^+ = \\dot{q}^\\ast + \\Delta \\dot{q}$. Use the minimum-norm solution implied by the reduced QR factorization of $J(q)^T$.\n\nYou must derive and implement the solver for $J \\Delta q = b$ using reduced QR decomposition of $J^T$. If $J^T = Q R$ with $Q \\in \\mathbb{R}^{4 \\times 2}$ having orthonormal columns and $R \\in \\mathbb{R}^{2 \\times 2}$ upper triangular, solve $R^T y = b$ for $y \\in \\mathbb{R}^2$, then set $\\Delta q = Q y$. Apply the same procedure for velocity projection.\n\nFor each test case, after performing the single-step integrate-and-project procedure, compute the following two residuals:\n- Position residual: $$r_q = \\left\\| \\phi(q^+) \\right\\|_2 \\quad \\text{in } \\text{m}^2.$$\n- Velocity residual: $$r_{\\dot{q}} = \\left\\| J(q^+) \\, \\dot{q}^+ \\right\\|_2 \\quad \\text{in } \\text{m}^2/\\text{s}.$$\n\nYour program must implement the above logic and produce, for each test case, the pair $[r_q, r_{\\dot{q}}]$ rounded to six decimal places. Aggregate the results for all test cases into a single line of output as a comma-separated list of lists enclosed in square brackets, for example, $[[r_{q,1}, r_{\\dot{q},1}],[r_{q,2}, r_{\\dot{q},2}],\\dots]$.\n\nUse the following test suite that probes different regimes:\n1. Happy path with small drift:\n   - $L = 1.0$ m, $R = 0.5$ m, $\\Delta t = 0.01$ s,\n   - $q = [0.52, \\, 0.00, \\, 1.48, \\, 0.02]^T$ m,\n   - $\\dot{q} = [0.00, \\, 0.10, \\, -0.05, \\, 0.00]^T$ m/s.\n2. Boundary case with zero velocities:\n   - $L = 1.2$ m, $R = 0.6$ m, $\\Delta t = 0.02$ s,\n   - $q = [0.59, \\, 0.01, \\, 0.00, \\, 1.81]^T$ m,\n   - $\\dot{q} = [0.00, \\, 0.00, \\, 0.00, \\, 0.00]^T$ m/s.\n3. Near-singular Jacobian geometry:\n   - $L = 0.8$ m, $R = 0.4$ m, $\\Delta t = 0.015$ s,\n   - $q = [0.399, \\, 0.010, \\, 1.17705, \\, 0.0395]^T$ m,\n   - $\\dot{q} = [-0.02, \\, 0.03, \\, 0.01, \\, -0.01]^T$ m/s.\n\nAll angles, if any appear, must be in radians, but this problem uses only Cartesian coordinates. Express all residuals in the specified physical units. Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, for example, $[[r_{q,1},r_{\\dot{q},1}],[r_{q,2},r_{\\dot{q},2}],[r_{q,3},r_{\\dot{q},3}]]$.",
            "solution": "The goal is to enforce holonomic constraints after an integration step using linearized coordinate projection. The fundamental base is Newton's Laws of motion for particles and the definition of holonomic constraints and their Jacobians. For holonomic constraints $\\phi(q) = 0$, the constraint manifold is the set of $q$ satisfying these equations. A time integration step may produce $q^\\ast$ that drifts off the manifold. To correct this, one can apply a small correction $\\Delta q$ obtained by linearizing the constraints. Using the first-order Taylor expansion of $\\phi(q)$ around $q^\\ast$ yields\n$$\\phi(q^\\ast + \\Delta q) \\approx \\phi(q^\\ast) + J(q^\\ast) \\, \\Delta q.$$\nEnforcing $\\phi(q^\\ast + \\Delta q) = 0$ gives the linear system\n$$J(q^\\ast) \\, \\Delta q = -\\phi(q^\\ast).$$\nSimilarly, for constraints without explicit time dependence, differentiating $\\phi(q(t)) = 0$ with respect to time gives\n$$\\dot{\\phi}(q, \\dot{q}) = J(q) \\, \\dot{q} = 0.$$\nAfter the unconstrained update $\\dot{q}^\\ast$, velocities may not satisfy this, so we add a correction $\\Delta \\dot{q}$ such that\n$$J(q^+) \\, \\Delta \\dot{q} = -\\dot{\\phi}(q^+, \\dot{q}^\\ast) = -J(q^+) \\, \\dot{q}^\\ast,$$\nwhich ensures $(J(q^+) \\, (\\dot{q}^\\ast + \\Delta \\dot{q})) = 0$ after the correction.\n\nThese systems are generally underdetermined because $J \\in \\mathbb{R}^{m \\times n}$ with $m \\le n$. The minimum-norm solution is preferred for physical consistency, avoiding unnecessary changes orthogonal to the constraint subspace. A principled approach uses Orthogonal-Triangular (QR) decomposition on $J^T$. Let $A = J^T \\in \\mathbb{R}^{n \\times m}$ and compute the reduced QR decomposition:\n$$A = Q R,$$\nwhere $Q \\in \\mathbb{R}^{n \\times m}$ with orthonormal columns ($Q^T Q = I_m$) and $R \\in \\mathbb{R}^{m \\times m}$ is upper triangular. Transposing $A$ gives $J = A^T = R^T Q^T$. To solve $J \\, \\Delta q = b$, define $y \\in \\mathbb{R}^m$ by the relation\n$$R^T \\, y = b.$$\nSince $R^T$ is triangular and invertible if $J$ is full row rank, this system can be solved efficiently by back substitution or a direct solver. Then the minimum-norm solution is recovered as\n$$\\Delta q = Q \\, y.$$\nTo confirm, substitute:\n$$J \\, \\Delta q = (R^T Q^T)(Q y) = R^T y = b.$$\nThis construction produces the solution in the column space of $Q$, which corresponds to the minimum Euclidean norm solution among all possible solutions.\n\nThe algorithm proceeds as follows for each test case:\n1. Initialize parameters $L$ (meters), $R$ (meters), $\\Delta t$ (seconds), $q$ (meters), and $\\dot{q}$ (meters per second).\n2. Unconstrained explicit Euler step:\n   $$q^\\ast = q + \\Delta t \\, \\dot{q}, \\quad \\dot{q}^\\ast = \\dot{q}.$$\n3. Compute the constraint values at $q^\\ast$:\n   $$\\phi_1(q^\\ast) = (x_2^\\ast - x_1^\\ast)^2 + (y_2^\\ast - y_1^\\ast)^2 - L^2,$$\n   $$\\phi_2(q^\\ast) = (x_1^\\ast)^2 + (y_1^\\ast)^2 - R^2.$$\n4. Compute the Jacobian $J(q^\\ast)$ with rows given by\n   $$\\frac{\\partial \\phi_1}{\\partial q} = [-2(x_2^\\ast - x_1^\\ast), \\, -2(y_2^\\ast - y_1^\\ast), \\, 2(x_2^\\ast - x_1^\\ast), \\, 2(y_2^\\ast - y_1^\\ast)],$$\n   $$\\frac{\\partial \\phi_2}{\\partial q} = [2 x_1^\\ast, \\, 2 y_1^\\ast, \\, 0, \\, 0].$$\n5. Form $A = J(q^\\ast)^T$ and compute the reduced QR decomposition $A = Q R$.\n6. Solve $R^T \\, y = -\\phi(q^\\ast)$ for $y$ and set $\\Delta q = Q \\, y$.\n7. Update the projected position $q^+ = q^\\ast + \\Delta q$.\n8. Recompute $J(q^+)$ and the velocity constraint residual $\\dot{\\phi}(q^+, \\dot{q}^\\ast) = J(q^+) \\, \\dot{q}^\\ast$.\n9. Form $A_v = J(q^+)^T$, compute $A_v = Q_v R_v$, solve $R_v^T \\, y_v = -\\dot{\\phi}(q^+, \\dot{q}^\\ast)$, and set $\\Delta \\dot{q} = Q_v \\, y_v$.\n10. Update the projected velocity $\\dot{q}^+ = \\dot{q}^\\ast + \\Delta \\dot{q}$.\n11. Compute the residuals:\n    $$r_q = \\left\\| \\phi(q^+) \\right\\|_2 \\quad (\\text{m}^2), \\quad r_{\\dot{q}} = \\left\\| J(q^+) \\, \\dot{q}^+ \\right\\|_2 \\quad (\\text{m}^2/\\text{s}).$$\n12. Round $r_q$ and $r_{\\dot{q}}$ to six decimal places and record the pair $[r_q, r_{\\dot{q}}]$.\n\nCoverage rationale for the test suite:\n- The happy path uses small drift and moderate velocities, testing standard operation when $J$ is well-conditioned.\n- The boundary case uses zero velocities, verifying that velocity projection reduces the velocity residual to near machine precision with minimal adjustments.\n- The near-singular case configures $q$ such that the gradients of constraints are close to collinear, producing an ill-conditioned $J$ while remaining full row rank; the QR-based solver maintains numerical stability without resorting to pseudoinverses or Singular Value Decomposition (SVD).\n\nFinally, the program aggregates the three $[r_q, r_{\\dot{q}}]$ pairs into a single line formatted as a comma-separated list of lists, enclosed in square brackets, as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi(q, L, R):\n    \"\"\"\n    Compute the constraint vector phi(q) for:\n    phi1 = distance^2 - L^2\n    phi2 = x1^2 + y1^2 - R^2\n    \"\"\"\n    x1, y1, x2, y2 = q\n    dxf = x2 - x1\n    dyf = y2 - y1\n    phi1 = dxf * dxf + dyf * dyf - L * L\n    phi2 = x1 * x1 + y1 * y1 - R * R\n    return np.array([phi1, phi2], dtype=float)\n\ndef J(q):\n    \"\"\"\n    Compute the Jacobian J(q) of the constraints with respect to q = [x1, y1, x2, y2].\n    J is 2x4:\n    Row 1: d(phi1)/dq = [-2(dx), -2(dy), 2(dx), 2(dy)]\n    Row 2: d(phi2)/dq = [2*x1, 2*y1, 0, 0]\n    \"\"\"\n    x1, y1, x2, y2 = q\n    dx = x2 - x1\n    dy = y2 - y1\n    J1 = np.array([-2.0 * dx, -2.0 * dy, 2.0 * dx, 2.0 * dy], dtype=float)\n    J2 = np.array([2.0 * x1, 2.0 * y1, 0.0, 0.0], dtype=float)\n    return np.vstack([J1, J2])\n\ndef qr_min_norm_solve(Jmat, b):\n    \"\"\"\n    Solve J x = b for minimum-norm x using reduced QR of J^T:\n    J^T = Q R, with Q (n x m), R (m x m) upper triangular.\n    Solve R^T y = b, then x = Q y.\n    \"\"\"\n    A = Jmat.T  # shape (n, m)\n    # reduced QR: returns Q (n x m), R (m x m)\n    Q, R = np.linalg.qr(A, mode='reduced')\n    # Solve R^T y = b\n    y = np.linalg.solve(R.T, b)\n    x = Q @ y\n    return x\n\ndef project_step(q, qdot, L, R, dt):\n    \"\"\"\n    Perform one unconstrained explicit Euler step followed by coordinate projection\n    for positions and velocities using QR-based minimum-norm solves.\n    Returns projected (q_plus, qdot_plus) and residuals (rq, rvdot).\n    \"\"\"\n    # Unconstrained step\n    q_star = q + dt * qdot\n    qdot_star = qdot.copy()\n\n    # Position projection\n    J_star = J(q_star)\n    phi_star = phi(q_star, L, R)\n    # Solve J_star * dq = -phi_star\n    dq = qr_min_norm_solve(J_star, -phi_star)\n    q_plus = q_star + dq\n\n    # Velocity projection\n    J_plus = J(q_plus)\n    phidot_plus = J_plus @ qdot_star  # since no explicit time dependence\n    # Solve J_plus * dqd = -phidot_plus\n    dqd = qr_min_norm_solve(J_plus, -phidot_plus)\n    qdot_plus = qdot_star + dqd\n\n    # Residuals\n    rq = np.linalg.norm(phi(q_plus, L, R), ord=2)  # in m^2\n    rvdot = np.linalg.norm(J_plus @ qdot_plus, ord=2)  # in m^2/s\n\n    return q_plus, qdot_plus, rq, rvdot\n\ndef format_pair(rq, rvdot):\n    # Round to six decimal places and format\n    return f\"[{rq:.6f},{rvdot:.6f}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L, R, dt, q, qdot)\n    test_cases = [\n        (1.0, 0.5, 0.01, np.array([0.52, 0.00, 1.48, 0.02], dtype=float), np.array([0.00, 0.10, -0.05, 0.00], dtype=float)),\n        (1.2, 0.6, 0.02, np.array([0.59, 0.01, 0.00, 1.81], dtype=float), np.array([0.00, 0.00, 0.00, 0.00], dtype=float)),\n        (0.8, 0.4, 0.015, np.array([0.399, 0.010, 1.17705, 0.0395], dtype=float), np.array([-0.02, 0.03, 0.01, -0.01], dtype=float)),\n    ]\n\n    results_str_items = []\n    for L, R, dt, q, qdot in test_cases:\n        _, _, rq, rvdot = project_step(q, qdot, L, R, dt)\n        results_str_items.append(format_pair(rq, rvdot))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_items)}]\")\n\nsolve()\n```"
        }
    ]
}