{
    "hands_on_practices": [
        {
            "introduction": "任何多体动力学仿真的第一步都是精确定义每个刚体的物理属性，其中惯性张量是描述其旋转行为的基石。本练习将通过从第一性原理（积分）计算惯性张量，并利用平行轴定理在不同参考系之间进行变换，来巩固您对刚体动力学的理解。这项实践是为数字孪生中的任何刚体组件正确设置仿真参数的一项基本技能 。",
            "id": "4233387",
            "problem": "信息物理系统（CPS）中一个机器人连杆的数字孪生（DT）需要一致的惯性参数以进行多体动力学模拟。考虑一根长度为 $L$、质量为 $m$ 的细长均匀杆，其横截面可忽略不计。在惯性参考系 $\\{O\\}$ 中，该杆的中心线沿 $x$ 轴放置，使得其质心（COM）位于 $x=0$ 处，杆的范围为 $x \\in [-L/2, L/2]$。仅使用刚体动力学的基本定义，推导该杆相对于 (i) 其质心和 (ii) 一个原点位于杆端点 $x=+L/2$ 处且坐标轴与 $\\{O\\}$ 平行的参考系的惯性张量。然后，通过比较关于末端参考系的直接积分与从质心参考系进行的变换，验证这些张量之间的平行轴定理关系。最后，推广您的结果：令 $a \\in \\mathbb{R}$ 表示沿 $x$ 方向相对于质心的轴向偏移量（因此 $a=0$ 对应质心，$a=L/2$ 对应端点）。请提供一个单一的、封闭形式的解析表达式，表示该杆相对于距质心轴向偏移为 $a$ 的点的惯性张量 $I(a)$。该表达式应为一个 $3 \\times 3$ 矩阵，用 $L$ 和 $m$ 表示，且坐标轴与沿 $x$ 轴的杆中心线对齐。请以符号形式表示您的最终答案；不要四舍五入。",
            "solution": "该问题定义明确，且基于经典刚体动力学的基本原理。它要求在不同坐标系下推导细长均匀杆的惯性张量，验证平行轴定理，并进行最终的推广。我们现在开始求解。\n\n对于一个连续体，其相对于给定坐标系的惯性张量 $I$ 是一个对称的 $3 \\times 3$ 矩阵，其分量由以下体积积分给出：\n$$\nI_{ij} = \\int_V \\rho(\\mathbf{r}) \\left( (\\mathbf{r} \\cdot \\mathbf{r}) \\delta_{ij} - r_i r_j \\right) dV\n$$\n其中 $\\rho(\\mathbf{r})$ 是位置 $\\mathbf{r}=(x, y, z)$ 处的质量密度，$\\delta_{ij}$ 是克罗内克δ，$r_i, r_j$ 是 $\\mathbf{r}$ 的分量。具体来说，对角元素（转动惯量）为：\n$$\nI_{xx} = \\int (y^2 + z^2) dm\n$$\n$$\nI_{yy} = \\int (x^2 + z^2) dm\n$$\n$$\nI_{zz} = \\int (x^2 + y^2) dm\n$$\n非对角元素（惯性积）为：\n$$\nI_{xy} = I_{yx} = -\\int xy \\, dm\n$$\n$$\nI_{xz} = I_{zx} = -\\int xz \\, dm\n$$\n$$\nI_{yz} = I_{zy} = -\\int yz \\, dm\n$$\n对于指定的长度为 $L$、质量为 $m$ 的细长均匀杆，其中心线位于 $x$ 轴上。我们可以将其建模为一维物体。其线密度为常数 $\\lambda = m/L$。一个微分质量元为 $dm = \\lambda \\, dx$。对于杆上的任意一点，其坐标为 $(x, 0, 0)$。\n\n(i) 关于质心的惯性张量（$I_{COM}$）的推导。\n坐标系的原点位于质心（COM），因此杆的范围从 $x = -L/2$ 到 $x = L/2$。任何质量元的坐标都是 $y=0$ 和 $z=0$。\n\n转动惯量为：\n$I_{xx, COM} = \\int_{-L/2}^{L/2} (y^2 + z^2) \\lambda \\, dx = \\int_{-L/2}^{L/2} (0^2 + 0^2) \\lambda \\, dx = 0$。\n$I_{yy, COM} = \\int_{-L/2}^{L/2} (x^2 + z^2) \\lambda \\, dx = \\int_{-L/2}^{L/2} x^2 \\lambda \\, dx = \\lambda \\left[ \\frac{x^3}{3} \\right]_{-L/2}^{L/2}$。\n代入 $\\lambda = m/L$：\n$I_{yy, COM} = \\frac{m}{L} \\left( \\frac{(L/2)^3}{3} - \\frac{(-L/2)^3}{3} \\right) = \\frac{m}{L} \\left( \\frac{L^3}{24} + \\frac{L^3}{24} \\right) = \\frac{m}{L} \\left( \\frac{2L^3}{24} \\right) = \\frac{1}{12} mL^2$。\n根据对称性，$I_{zz, COM} = \\int_{-L/2}^{L/2} (x^2 + y^2) \\lambda \\, dx = I_{yy, COM} = \\frac{1}{12} mL^2$。\n\n惯性积均为零，因为杆上所有质量元的 $y=0$ 和 $z=0$：\n$I_{xy, COM} = -\\int_{-L/2}^{L/2} x(0) \\lambda \\, dx = 0$。\n$I_{xz, COM} = -\\int_{-L/2}^{L/2} x(0) \\lambda \\, dx = 0$。\n$I_{yz, COM} = -\\int_{-L/2}^{L/2} (0)(0) \\lambda \\, dx = 0$。\n\n因此，关于质心的惯性张量为：\n$$\nI_{COM} = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{12} mL^2  0 \\\\ 0  0  \\frac{1}{12} mL^2 \\end{pmatrix}\n$$\n\n(ii) 关于杆端点的惯性张量（$I_{end}$）的推导。\n我们现在考虑一个新的参考系，其原点位于杆的端点 $x = +L/2$。设此参考系中的坐标为 $(x', y', z')$。坐标变换为 $x' = x - L/2$, $y' = y$, $z' = z$。在这个新参考系中，杆的范围从 $x' = -L$ 到 $x' = 0$。任何质量元的坐标为 $(x', 0, 0)$。\n\n我们在这个新参考系中通过直接积分计算惯性张量 $I_{end}$：\n$I_{x'x', end} = \\int_{-L}^{0} (y'^2 + z'^2) \\lambda \\, dx' = \\int_{-L}^{0} (0^2+0^2) \\lambda \\, dx' = 0$。\n$I_{y'y', end} = \\int_{-L}^{0} (x'^2 + z'^2) \\lambda \\, dx' = \\int_{-L}^{0} x'^2 \\lambda \\, dx' = \\lambda \\left[ \\frac{x'^3}{3} \\right]_{-L}^{0}$。\n$I_{y'y', end} = \\frac{m}{L} \\left( \\frac{0^3}{3} - \\frac{(-L)^3}{3} \\right) = \\frac{m}{L} \\left( \\frac{L^3}{3} \\right) = \\frac{1}{3} mL^2$。\n根据对称性，$I_{z'z', end} = I_{y'y', end} = \\frac{1}{3} mL^2$。\n惯性积同样为零。因此，关于杆端点的惯性张量为：\n$$\nI_{end} = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{3} mL^2  0 \\\\ 0  0  \\frac{1}{3} mL^2 \\end{pmatrix}\n$$\n\n平行轴定理的验证。\n平行轴定理将关于任意点 $P$ 的惯性张量 $I_P$ 与关于质心的惯性张量 $I_{COM}$ 联系起来。其分量形式为 $I_{ij, P} = I_{ij, COM} + m( (\\mathbf{d} \\cdot \\mathbf{d}) \\delta_{ij} - d_i d_j )$，其中 $\\mathbf{d}$ 是从质心到点 $P$ 的位移矢量。在本例中，$P$ 是杆的端点，因此从质心（位于原点）到端点（位于 $x=L/2$）的位移矢量为 $\\mathbf{d} = (L/2, 0, 0)$。其分量为 $d_x = L/2$，$d_y = 0$，$d_z = 0$。\n\n我们将该定理应用于每个分量：\n$I_{xx, end} = I_{xx, COM} + m(d_y^2 + d_z^2) = 0 + m(0^2 + 0^2) = 0$。\n$I_{yy, end} = I_{yy, COM} + m(d_x^2 + d_z^2) = \\frac{1}{12} mL^2 + m\\left(\\left(\\frac{L}{2}\\right)^2 + 0^2\\right) = \\frac{1}{12} mL^2 + \\frac{1}{4} mL^2 = \\left(\\frac{1}{12} + \\frac{3}{12}\\right) mL^2 = \\frac{4}{12} mL^2 = \\frac{1}{3} mL^2$。\n$I_{zz, end} = I_{zz, COM} + m(d_x^2 + d_y^2) = \\frac{1}{12} mL^2 + m\\left(\\left(\\frac{L}{2}\\right)^2 + 0^2\\right) = \\frac{1}{3} mL^2$。\n$I_{xy, end} = I_{xy, COM} - m d_x d_y = 0 - m(L/2)(0) = 0$。\n同理，$I_{xz, end} = 0$ 且 $I_{yz, end} = 0$。\n\n通过平行轴定理得到的惯性张量为：\n$$\nI_{end} = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{3} mL^2  0 \\\\ 0  0  \\frac{1}{3} mL^2 \\end{pmatrix}\n$$\n此结果与通过直接积分得到的结果一致，从而验证了该定理在本例中的应用。\n\n惯性张量 $I(a)$ 的广义表达式。\n我们寻求关于距离质心轴向偏移为 $a$ 的点的惯性张量 $I(a)$，因此位移矢量为 $\\mathbf{d} = (a, 0, 0)$。我们使用平行轴定理，其中 $d_x = a$，$d_y = 0$，$d_z = 0$。\n\n$I_{xx}(a) = I_{xx, COM} + m(d_y^2 + d_z^2) = 0 + m(0^2 + 0^2) = 0$。\n$I_{yy}(a) = I_{yy, COM} + m(d_x^2 + d_z^2) = \\frac{1}{12} mL^2 + m(a^2 + 0^2) = \\frac{1}{12} mL^2 + ma^2$。\n$I_{zz}(a) = I_{zz, COM} + m(d_x^2 + d_y^2) = \\frac{1}{12} mL^2 + m(a^2 + 0^2) = \\frac{1}{12} mL^2 + ma^2$。\n所有惯性积均为零：\n$I_{xy}(a) = I_{xy, COM} - m d_x d_y = 0 - m(a)(0) = 0$。\n$I_{xz}(a) = 0$ 且 $I_{yz}(a) = 0$ 可通过类似计算得出。\n\n因此，作为距质心轴向偏移量 $a$ 的函数的广义惯性张量 $I(a)$ 为：\n$$\nI(a) = \\begin{pmatrix} 0  0  0 \\\\ 0  \\frac{1}{12} mL^2 + ma^2  0 \\\\ 0  0  \\frac{1}{12} mL^2 + ma^2 \\end{pmatrix}\n$$\n通过提取质量 $m$ 因子，可以更紧凑地写为：\n$$\nI(a) = \\begin{pmatrix} 0  0  0 \\\\ 0  m\\left(\\frac{L^2}{12} + a^2\\right)  0 \\\\ 0  0  m\\left(\\frac{L^2}{12} + a^2\\right) \\end{pmatrix}\n$$\n这个单一的封闭形式表达式表示了杆相对于其轴上任意一点（距离质心为 $a$）的惯性张量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0 \\\\\n0  m\\left(\\frac{L^2}{12} + a^2\\right)  0 \\\\\n0  0  m\\left(\\frac{L^2}{12} + a^2\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "定义了刚体的属性后，我们需要模拟其运动，尤其是在三维空间中表示和更新其姿态是一项关键任务。本练习将指导您推导并实现一个基于四元数的积分器，这是一种在现代物理引擎和数字孪生中广泛使用的数值稳健方法，可以有效避免万向节死锁等问题。通过这项实践，您将获得处理旋转运动学的动手经验 。",
            "id": "4233332",
            "problem": "您正在为信息物理系统 (CPS) 领域中的数字孪生 (DT) 的姿态分量设计一个旋转状态积分器。该 DT 的刚体姿态由一个四元数 $q(t) \\in \\mathbb{H}$ 表示，采用标量优先形式 $q = [q_0, q_1, q_2, q_3]$，其中 $q_0 \\in \\mathbb{R}$ 且 $[q_1,q_2,q_3]^\\top \\in \\mathbb{R}^3$。体角速度 $\\omega(t) \\in \\mathbb{R}^3$ 在体坐标系中测量，单位为弧度/秒。目标是从第一性原理出发推导四元数运动学，并实现一个适用于数字孪生中多体动力学仿真的数值鲁棒的单步积分器。\n\n仅从基本旋转运动学和基本四元数定义出发，完成以下任务：\n\n1. 推导一个常微分方程 (ODE) 来描述四元数运动学，该方程在体坐标系角速度输入下，与 3 阶特殊正交群 (SO(3)) 上的刚体旋转保持一致。从基本旋转运动学方程 $\\dot{R}(t) = R(t)[\\omega(t)]_\\times$ 开始，其中 $R(t) \\in \\mathrm{SO}(3)$ 是旋转矩阵，$[\\omega]_\\times$ 是由 $\\omega$ 构成的 $3 \\times 3$ 斜对称矩阵。将此与四元数表示联系起来，并用 $\\omega$ 和 $q$ 以线性矩阵算子形式表示该四元数 ODE。\n\n2. 假设在一个小时间步长 $\\Delta t  0$ 内 $\\omega(t)$ 保持恒定，为 $q(t)$ 提供一个数学上合理的闭式单步更新公式，并讨论在有限精度算术中为何需要进行再归一化。\n\n3. 实现一个程序，该程序：\n   - 使用推导出的单步更新公式，根据给定的 $q(t)$、$\\omega$ 和 $\\Delta t$ 计算 $q(t+\\Delta t)$。\n   - 将所有角度解释为弧度，时间解释为秒。\n   - 在更新后对四元数强制执行单位长度归一化。\n   - 使用与作为瞬时旋转生成元的体角速度相一致的左乘。\n   - 生成的输出为浮点数列表，四舍五入到十位小数。\n\n定义并求解以下测试套件，每个案例提供 $(q(0),\\ \\omega,\\ \\Delta t)$：\n- 案例 1 (正常路径，有限旋转)：$q(0) = [1,0,0,0]$, $\\omega = [0,0,1]$ $\\mathrm{rad/s}$, $\\Delta t = \\pi$ $\\mathrm{s}$。\n- 案例 2 (边缘情况，零旋转)：$q(0) = [1,0,0,0]$, $\\omega = [0,0,0]$ $\\mathrm{rad/s}$, $\\Delta t = 1.0$ $\\mathrm{s}$。\n- 案例 3 (边界情况，极小旋转)：$q(0) = [1,0,0,0]$, $\\omega = [10^{-9},0,0]$ $\\mathrm{rad/s}$, $\\Delta t = 1.0$ $\\mathrm{s}$。\n- 案例 4 (边缘情况，非归一化输入四元数和大角度旋转)：$q(0) = [0,2,0,0]$, $\\omega = [2,0,0]$ $\\mathrm{rad/s}$, $\\Delta t = \\frac{\\pi}{2}$ $\\mathrm{s}$。\n- 案例 5 (同一轴上的旋转复合)：$q(0) = [\\sqrt{1/2},0,\\sqrt{1/2},0]$, $\\omega = [0,1,0]$ $\\mathrm{rad/s}$, $\\Delta t = \\frac{\\pi}{2}$ $\\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个结果是对应测试案例更新后的四元数，表示为包含四个十位小数的浮点数列表。例如，输出必须如下所示：\n$[ [q_{0,1},q_{1,1},q_{2,1},q_{3,1}], [q_{0,2},q_{1,2},q_{2,2},q_{3,2}], \\dots ]$\n不含任何额外文本。四元数分量是无量纲的。",
            "solution": "经评估，此问题有效。它在科学上基于刚体运动学原理，问题阐述清晰，目标明确，数据充分，并以客观、正式的语言表述。解答将按要求分为三部分进行。\n\n### 1. 四元数运动学 ODE 的推导\n\n刚体的姿态可以由一个旋转矩阵 $R(t) \\in \\mathrm{SO}(3)$ 描述，该矩阵将向量从体固坐标系映射到惯性坐标系。问题陈述了在体坐标系中表示的角速度 $\\omega(t)$ 下，该矩阵的基本运动学方程：\n$$ \\dot{R}(t) = R(t)[\\omega(t)]_\\times $$\n其中 $[\\omega]_\\times$ 是叉乘算子的斜对称矩阵表示：\n$$ [\\omega]_\\times = \\begin{bmatrix} 0  -\\omega_3  \\omega_2 \\\\ \\omega_3  0  -\\omega_1 \\\\ -\\omega_2  \\omega_1  0 \\end{bmatrix} $$\n姿态也可以由单位四元数 $q(t) = [q_0, q_1, q_2, q_3]^\\top = [q_0, \\mathbf{q}_v]^\\top$ 表示，并受约束 $\\|q\\|^2 = q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$ 的限制。\n\n为了推导四元数 ODE，我们考虑一个无穷小旋转的影响。在一个小时间间隔 $\\Delta t$ 内发生的增量旋转可以用一个四元数 $\\Delta q$ 表示。对于绕单位向量 $\\mathbf{u}$ 轴旋转角度 $\\theta$ 的旋转，其四元数为 $[\\cos(\\theta/2), \\sin(\\theta/2)\\mathbf{u}]$。对于在 $\\Delta t$ 内假定恒定的角速度 $\\omega$，旋转角度为 $\\theta = \\|\\omega\\| \\Delta t$，旋转轴为 $\\mathbf{u} = \\omega / \\|\\omega\\|$。对于无穷小的 $\\Delta t$，我们有 $\\theta \\to 0$，因此 $\\cos(\\theta/2) \\approx 1$ 且 $\\sin(\\theta/2) \\approx \\theta/2 = \\frac{\\|\\omega\\|\\Delta t}{2}$。增量四元数变为：\n$$ \\Delta q \\approx \\left[1, \\frac{\\Delta t}{2} \\frac{\\omega}{\\|\\omega\\|} \\|\\omega\\|\\right] = \\left[1, \\frac{\\Delta t}{2} \\omega\\right] $$\n由于角速度 $\\omega$ 在体坐标系中，新的姿态 $q(t+\\Delta t)$ 通过将当前姿态 $q(t)$ 与增量旋转 $\\Delta q$ 进行右乘得到：\n$$ q(t+\\Delta t) = q(t) \\otimes \\Delta q \\approx q(t) \\otimes \\left[1, \\frac{\\Delta t}{2} \\omega\\right] $$\n其中 $\\otimes$ 表示四元数乘积。四元数 $[1, \\mathbf{0}]$ 和 $[0, \\omega]$ 分别是乘法单位元和表示向量 $\\omega$ 的纯四元数。\n\n四元数的时间导数 $\\dot{q}$ 定义为：\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t+\\Delta t) - q(t)}{\\Delta t} $$\n代入 $q(t+\\Delta t)$ 的表达式：\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left[1, \\frac{\\Delta t}{2} \\omega\\right] - q(t)}{\\Delta t} $$\n利用分配律以及 $q(t) \\otimes [1, \\mathbf{0}] = q(t)$：\n$$ \\dot{q}(t) = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left(\\left[1, \\frac{\\Delta t}{2} \\omega\\right] - [1, \\mathbf{0}]\\right)}{\\Delta t} = \\lim_{\\Delta t \\to 0} \\frac{q(t) \\otimes \\left[0, \\frac{\\Delta t}{2} \\omega\\right]}{\\Delta t} $$\n$$ \\dot{q}(t) = q(t) \\otimes \\lim_{\\Delta t \\to 0} \\frac{\\left[0, \\frac{\\Delta t}{2} \\omega\\right]}{\\Delta t} = q(t) \\otimes \\left[0, \\frac{1}{2}\\omega\\right] $$\n令 $\\omega'$ 表示纯四元数 $[0, \\omega_1, \\omega_2, \\omega_3]$，我们得到运动学 ODE：\n$$ \\dot{q}(t) = \\frac{1}{2} q(t) \\otimes \\omega' $$\n为了将其表示为所要求的线性矩阵算子形式 $\\dot{q} = \\mathbf{A}(\\omega) q$，我们展开四元数乘积。对于 $p=[p_0, \\mathbf{p}_v]$ 和 $r=[r_0, \\mathbf{r}_v]$，其乘积为 $p \\otimes r = [p_0r_0 - \\mathbf{p}_v\\cdot\\mathbf{r}_v, p_0\\mathbf{r}_v + r_0\\mathbf{p}_v + \\mathbf{p}_v\\times\\mathbf{r}_v]$。\n这里，$p=q$ 且 $r=\\omega'$，因此 $r_0=0$ 且 $\\mathbf{r}_v=\\omega$。乘积 $q \\otimes \\omega'$ 为：\n$$ q \\otimes \\omega' = [ - \\mathbf{q}_v \\cdot \\omega, q_0 \\omega + \\mathbf{q}_v \\times \\omega ] $$\n将 $\\dot{q} = \\frac{1}{2} q \\otimes \\omega'$ 的每个分量写出：\n$$ \\dot{q}_0 = \\frac{1}{2}(-q_1\\omega_1 - q_2\\omega_2 - q_3\\omega_3) $$\n$$ \\dot{q}_1 = \\frac{1}{2}( q_0\\omega_1 + q_2\\omega_3 - q_3\\omega_2) $$\n$$ \\dot{q}_2 = \\frac{1}{2}( q_0\\omega_2 + q_3\\omega_1 - q_1\\omega_3) $$\n$$ \\dot{q}_3 = \\frac{1}{2}( q_0\\omega_3 + q_1\\omega_2 - q_2\\omega_1) $$\n该系统可以写成矩阵形式 $\\dot{q} = \\mathbf{A}(\\omega)q$：\n$$ \\begin{bmatrix} \\dot{q}_0 \\\\ \\dot{q}_1 \\\\ \\dot{q}_2 \\\\ \\dot{q}_3 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 0  -\\omega_1  -\\omega_2  -\\omega_3 \\\\ \\omega_1  0  \\omega_3  -\\omega_2 \\\\ \\omega_2  -\\omega_3  0  \\omega_1 \\\\ \\omega_3  \\omega_2  -\\omega_1  0 \\end{bmatrix} \\begin{bmatrix} q_0 \\\\ q_1 \\\\ q_2 \\\\ q_3 \\end{bmatrix} $$\n这就是所要求的线性矩阵算子形式的 ODE。问题中提到的“左乘”被解释为矩阵算子从左侧作用于状态向量 $q$。此形式与体坐标系角速度输入一致。\n\n### 2. 闭式单步更新与再归一化\n\n推导出的 ODE $\\dot{q} = \\mathbf{A}(\\omega)q$ 是一个线性时不变系统，前提是假设角速度 $\\omega$ 在积分时间步长 $\\Delta t$ 内是恒定的。其精确解由矩阵指数给出：\n$$ q(t+\\Delta t) = e^{\\mathbf{A}(\\omega)\\Delta t} q(t) $$\n矩阵 $\\mathbf{A}(\\omega)$ 是斜对称的。该矩阵族的一个关键性质是其平方是单位矩阵的倍数。令 $\\Omega = \\|\\omega\\|$。则 $ (\\mathbf{A}(\\omega))^2 = -(\\frac{\\Omega}{2})^2 I_{4 \\times 4} $。\n矩阵指数的泰勒级数展开为：\n$$ e^{\\mathbf{A}\\Delta t} = I + (\\mathbf{A}\\Delta t) + \\frac{(\\mathbf{A}\\Delta t)^2}{2!} + \\frac{(\\mathbf{A}\\Delta t)^3}{3!} + \\dots $$\n令 $\\theta = \\frac{\\Omega\\Delta t}{2}$。则 $(\\mathbf{A}\\Delta t)^2 = -\\theta^2 I$。分组各项：\n$$ e^{\\mathbf{A}\\Delta t} = I \\left(1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\dots\\right) + \\frac{\\mathbf{A}\\Delta t}{\\theta}\\left(\\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots\\right) $$\n$$ e^{\\mathbf{A}\\Delta t} = I \\cos(\\theta) + \\frac{\\mathbf{A}\\Delta t}{\\theta} \\sin(\\theta) $$\n该矩阵算子提供了一个闭式传播算子。然而，一个更直接且物理上更直观的方法是直接对旋转本身进行积分，而不是对状态空间系统进行积分。在 $\\Delta t$ 时间内的旋转是绕轴 $\\mathbf{u} = \\omega/\\Omega$ 旋转角度 $\\alpha = \\Omega \\Delta t$。表示此有限旋转的四元数为：\n$$ \\Delta q(\\omega, \\Delta t) = \\left[\\cos\\left(\\frac{\\alpha}{2}\\right), \\sin\\left(\\frac{\\alpha}{2}\\right)\\mathbf{u}\\right] = \\left[\\cos\\left(\\frac{\\Omega\\Delta t}{2}\\right), \\sin\\left(\\frac{\\Omega\\Delta t}{2}\\right)\\frac{\\omega}{\\Omega}\\right] $$\n更新后的姿态通过将初始姿态与此增量旋转进行复合得到。对于体坐标系速度，这是一个右乘（四元数乘积）：\n$$ q(t+\\Delta t) = q(t) \\otimes \\Delta q(\\omega, \\Delta t) $$\n这提供了鲁棒的闭式单步更新规则。对于 $\\Omega \\to 0$ 的边缘情况，我们有 $\\Delta q \\to [1, \\mathbf{0}]$（单位四元数），正确地得到 $q(t+\\Delta t) = q(t)$。\n\n**再归一化的必要性：**\n理论上，两个单位四元数的乘积仍是单位四元数。因此，如果 $q(t)$ 和 $\\Delta q$ 是单位四元数，那么 $q(t+\\Delta t)$ 也必须是单位四元数。然而，在有限精度计算机算术（例如，IEEE 754 浮点数）中，计算三角函数和执行乘积时会引入舍入误差。例如，计算出的 $\\Delta q$ 的模长可能是 $1 \\pm \\epsilon$，其中 $\\epsilon$ 是一个很小的误差。经过多次积分步骤，这些小误差会累积，导致状态四元数 $q(t)$ 的模长偏离 1。一个非单位四元数不再表示纯旋转，并可能在仿真中引入不希望的缩放效应。为了抵消这种数值漂移并保持姿态表示的数学有效性，必须在每个更新步骤后显式地对四元数进行再归一化：\n$$ q_{\\text{normalized}} = \\frac{q}{\\|q\\|} $$\n\n### 3. 实现与测试套件求解\n\n实现将遵循闭式乘法规则 $q(t+\\Delta t) = q(t) \\otimes \\Delta q$。非单位四元数的输入（例如，案例 4）将在计算前进行归一化，以确保初始状态有效。最终结果将进行再归一化，以校正任何浮点数不精确性。\n\n- **案例 1:** $q(0)=[1,0,0,0], \\omega=[0,0,1], \\Delta t=\\pi$。\n  $\\Omega=1$。$\\Delta q = [\\cos(\\pi/2), \\sin(\\pi/2)[0,0,1]] = [0,0,0,1]$。\n  $q(\\pi) = [1,0,0,0] \\otimes [0,0,0,1] = [0,0,0,1]$。\n- **案例 2:** $q(0)=[1,0,0,0], \\omega=[0,0,0], \\Delta t=1.0$。\n  $\\Omega=0$。$\\Delta q = [1,0,0,0]$。\n  $q(1.0) = [1,0,0,0] \\otimes [1,0,0,0] = [1,0,0,0]$。\n- **案例 3:** $q(0)=[1,0,0,0], \\omega=[10^{-9},0,0], \\Delta t=1.0$。\n  $\\Omega=10^{-9}$。$\\theta = 0.5 \\times 10^{-9}$。$\\Delta q \\approx [1, 0.5 \\times 10^{-9}, 0, 0]$。\n  $q(1.0) \\approx [1,0,0,0] \\otimes [1, 0.5 \\times 10^{-9}, 0, 0] = [1, 5 \\times 10^{-10}, 0, 0]$。归一化后，在此精度下结果几乎相同。\n- **案例 4:** $q(0)=[0,2,0,0], \\omega=[2,0,0], \\Delta t=\\pi/2$。\n  归一化 $q(0)$：$[0,1,0,0]$。$\\Omega=2$。$\\Delta q = [\\cos(\\pi/2), \\sin(\\pi/2)[1,0,0]] = [0,1,0,0]$。\n  $q(\\pi/2) = [0,1,0,0] \\otimes [0,1,0,0] = [-1,0,0,0]$。\n- **案例 5:** $q(0)=[\\sqrt{0.5},0,\\sqrt{0.5},0], \\omega=[0,1,0], \\Delta t=\\pi/2$。\n  $\\Omega=1$。$\\Delta q = [\\cos(\\pi/4), \\sin(\\pi/4)[0,1,0]] = [\\sqrt{0.5},0,\\sqrt{0.5},0]$。\n  $q(\\pi/2) = q(0) \\otimes \\Delta q = [\\sqrt{0.5},0,\\sqrt{0.5},0] \\otimes [\\sqrt{0.5},0,\\sqrt{0.5},0] = [0,0,1,0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a single-step quaternion integrator for rigid body dynamics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (q(0), omega, delta_t)\n    test_cases = [\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0], np.pi),\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0], 1.0),\n        ([1.0, 0.0, 0.0, 0.0], [1e-9, 0.0, 0.0], 1.0),\n        ([0.0, 2.0, 0.0, 0.0], [2.0, 0.0, 0.0], np.pi / 2.0),\n        ([np.sqrt(0.5), 0.0, np.sqrt(0.5), 0.0], [0.0, 1.0, 0.0], np.pi / 2.0)\n    ]\n\n    results = []\n    \n    # Define a small tolerance for floating point comparisons of norms.\n    TOLERANCE = 1e-15\n\n    for case in test_cases:\n        q_t, omega_vec, dt = case\n        \n        # Convert inputs to numpy arrays for vectorized operations\n        q_t = np.array(q_t, dtype=np.float64)\n        omega_vec = np.array(omega_vec, dtype=np.float64)\n\n        # Ensure the input quaternion is a unit quaternion\n        # This handles cases like test case 4 and ensures a valid starting state.\n        q_norm = np.linalg.norm(q_t)\n        if abs(q_norm - 1.0)  TOLERANCE :\n            q_t /= q_norm\n            \n        omega_norm = np.linalg.norm(omega_vec)\n\n        # Handle the case of zero angular velocity\n        if omega_norm  TOLERANCE:\n            q_t_plus_dt = q_t\n        else:\n            # Calculate the parameters for the incremental rotation quaternion\n            angle = omega_norm * dt\n            axis = omega_vec / omega_norm\n            \n            # Construct the incremental quaternion: delta_q = [cos(angle/2), sin(angle/2)*axis]\n            half_angle = angle / 2.0\n            delta_q_scalar = np.cos(half_angle)\n            delta_q_vector = np.sin(half_angle) * axis\n            delta_q = np.concatenate(([delta_q_scalar], delta_q_vector))\n            \n            # Perform quaternion multiplication: q(t+dt) = q(t) * delta_q\n            # q = [q0, qv], delta_q = [dq0, dqv]\n            # q_new = [q0*dq0 - qv.dqv, q0*dqv + dq0*qv + qv x dqv]\n            q0, qv = q_t[0], q_t[1:]\n            dq0, dqv = delta_q[0], delta_q[1:]\n            \n            q_new_scalar = q0 * dq0 - np.dot(qv, dqv)\n            q_new_vector = q0 * dqv + dq0 * qv + np.cross(qv, dqv)\n            \n            q_t_plus_dt = np.concatenate(([q_new_scalar], q_new_vector))\n\n        # Re-normalize the resulting quaternion to counteract numerical drift\n        q_final_norm = np.linalg.norm(q_t_plus_dt)\n        if q_final_norm > TOLERANCE:\n            q_t_plus_dt /= q_final_norm\n            \n        # Round the final result to 10 decimal places and convert to a list\n        result_list = np.round(q_t_plus_dt, 10).tolist()\n        results.append(result_list)\n\n    # Final print statement in the exact required format.\n    # Using str() on a list automatically produces the required format '[a, b, c, d]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从机器人手臂到分子结构，现实世界的系统通常由相互连接的刚体组成，这些连接在仿真中被建模为约束。由于数值积分误差，仿真中的物体可能会逐渐偏离其约束的几何构型。本练习介绍坐标投影法，这是一种强大的后处理稳定技术，用于校正约束漂移，从而确保数字孪生模型的长期稳定性和准确性 。",
            "id": "4233339",
            "problem": "考虑一个适用于信息物理系统 (CPS) 中数字孪生 (DT) 同步的平面双体完整约束系统。设广义坐标为 $q \\in \\mathbb{R}^4$，其中 $q = [x_1, y_1, x_2, y_2]^T$ 表示两个质点在笛卡尔坐标系中的位置（单位为米），广义速度为 $\\dot{q} \\in \\mathbb{R}^4$（单位为米/秒）。该系统受两个完整约束：\n1. 两个质点之间长度为 $L$（单位为米）的刚性距离约束：$$\\phi_1(q) = (x_2 - x_1)^2 + (y_2 - y_1)^2 - L^2 = 0.$$\n2. 第一个质点半径为 $R$（单位为米）的圆形路径约束：$$\\phi_2(q) = x_1^2 + y_1^2 - R^2 = 0.$$\n将约束向量定义为 $\\phi(q) = [\\phi_1(q), \\phi_2(q)]^T \\in \\mathbb{R}^2$。设约束雅可比矩阵为 $J(q) = \\frac{\\partial \\phi}{\\partial q} \\in \\mathbb{R}^{2 \\times 4}$，其行由每个约束相对于 $q$ 的梯度给出。在没有显式时间依赖的情况下，约束的时间导数为 $\\dot{\\phi}(q, \\dot{q}) = J(q)\\dot{q}$。\n\n在执行一个无约束显式 Euler 积分步\n$$q^\\ast = q + \\Delta t \\, \\dot{q}, \\quad \\dot{q}^\\ast = \\dot{q},$$\n后，需要进行坐标投影，以重新强制位置和速度的一致性，从而减轻 DT 中的约束漂移。通过正交三角 (QR) 分解求解线性化完整约束校正\n$$J(q^\\ast) \\, \\Delta q = -\\phi(q^\\ast)$$\n以此实现坐标投影，并更新位置为 $q^+ = q^\\ast + \\Delta q$。然后通过 QR 分解求解\n$$J(q^+) \\, \\Delta \\dot{q} = -\\dot{\\phi}(q^+, \\dot{q}^\\ast) = -J(q^+) \\, \\dot{q}^\\ast$$\n来更新速度，并设置 $\\dot{q}^+ = \\dot{q}^\\ast + \\Delta \\dot{q}$。使用由 $J(q)^T$ 的简约 QR 分解所蕴含的最小范数解。\n\n您必须使用 $J^T$ 的简约 QR 分解推导并实现 $J \\Delta q = b$ 的求解器。如果 $J^T = Q R$，其中 $Q \\in \\mathbb{R}^{4 \\times 2}$ 具有标准正交列，$R \\in \\mathbb{R}^{2 \\times 2}$ 是上三角矩阵，则求解 $R^T y = b$ 得到 $y \\in \\mathbb{R}^2$，然后设置 $\\Delta q = Q y$。对速度投影应用相同的过程。\n\n对于每个测试用例，在执行单步积分并投影的程序后，计算以下两个残差：\n- 位置残差：$$r_q = \\left\\| \\phi(q^+) \\right\\|_2 \\quad \\text{单位为 } \\text{m}^2。$$\n- 速度残差：$$r_{\\dot{q}} = \\left\\| J(q^+) \\, \\dot{q}^+ \\right\\|_2 \\quad \\text{单位为 } \\text{m}^2/\\text{s}。$$\n\n您的程序必须实现上述逻辑，并为每个测试用例生成保留六位小数的配对 $[r_q, r_{\\dot{q}}]$。将所有测试用例的结果聚合到单行输出中，格式为由方括号括起来的列表的逗号分隔列表，例如 $[[r_{q,1}, r_{\\dot{q},1}],[r_{q,2}, r_{\\dot{q},2}],\\dots]$。\n\n使用以下测试套件，它探测了不同的机制：\n1. 具有小漂移的正常路径：\n   - $L = 1.0$ m, $R = 0.5$ m, $\\Delta t = 0.01$ s,\n   - $q = [0.52, \\, 0.00, \\, 1.48, \\, 0.02]^T$ m,\n   - $\\dot{q} = [0.00, \\, 0.10, \\, -0.05, \\, 0.00]^T$ m/s.\n2. 速度为零的边界情况：\n   - $L = 1.2$ m, $R = 0.6$ m, $\\Delta t = 0.02$ s,\n   - $q = [0.59, \\, 0.01, \\, 0.00, \\, 1.81]^T$ m,\n   - $\\dot{q} = [0.00, \\, 0.00, \\, 0.00, \\, 0.00]^T$ m/s.\n3. 近奇异雅可比几何构型：\n   - $L = 0.8$ m, $R = 0.4$ m, $\\Delta t = 0.015$ s,\n   - $q = [0.399, \\, 0.010, \\, 1.17705, \\, 0.0395]^T$ m,\n   - $\\dot{q} = [-0.02, \\, 0.03, \\, 0.01, \\, -0.01]^T$ m/s.\n\n所有角度（如果出现）必须以弧度为单位，但本问题仅使用笛卡尔坐标。以指定的物理单位表示所有残差。您的程序应生成单行输出，其中包含结果，格式为由方括号括起来的列表的逗号分隔列表，例如 $[[r_{q,1},r_{\\dot{q},1}],[r_{q,2},r_{\\dot{q},2}],[r_{q,3},r_{\\dot{q},3}]]$.",
            "solution": "目标是在一个积分步后，通过使用线性化坐标投影来强制施加完整约束。其基本依据是质点运动的 Newton 定律以及完整约束及其雅可比矩阵的定义。对于完整约束 $\\phi(q) = 0$，约束流形是满足这些方程的 $q$ 的集合。时间积分步可能会产生偏离流形的 $q^\\ast$。为了校正这一点，可以通过线性化约束来施加一个小的校正量 $\\Delta q$。使用 $\\phi(q)$ 在 $q^\\ast$ 附近的一阶 Taylor 展开可得\n$$\\phi(q^\\ast + \\Delta q) \\approx \\phi(q^\\ast) + J(q^\\ast) \\, \\Delta q.$$\n强制 $\\phi(q^\\ast + \\Delta q) = 0$ 会得到线性系统\n$$J(q^\\ast) \\, \\Delta q = -\\phi(q^\\ast).$$\n类似地，对于没有显式时间依赖的约束，将 $\\phi(q(t)) = 0$ 对时间求导可得\n$$\\dot{\\phi}(q, \\dot{q}) = J(q) \\, \\dot{q} = 0.$$\n在无约束更新 $\\dot{q}^\\ast$ 之后，速度可能不满足此条件，因此我们增加一个校正量 $\\Delta \\dot{q}$，使得\n$$J(q^+) \\, \\Delta \\dot{q} = -\\dot{\\phi}(q^+, \\dot{q}^\\ast) = -J(q^+) \\, \\dot{q}^\\ast,$$\n这确保了校正后 $(J(q^+) \\, (\\dot{q}^\\ast + \\Delta \\dot{q})) = 0$。\n\n这些系统通常是欠定的，因为 $J \\in \\mathbb{R}^{m \\times n}$ 且 $m \\le n$。为保持物理一致性，首选最小范数解，以避免与约束子空间正交的不必要变化。一种基于原理的方法是对 $J^T$ 使用正交三角 (QR) 分解。设 $A = J^T \\in \\mathbb{R}^{n \\times m}$ 并计算其简约 QR 分解：\n$$A = Q R,$$\n其中 $Q \\in \\mathbb{R}^{n \\times m}$ 具有标准正交列 ($Q^T Q = I_m$)，$R \\in \\mathbb{R}^{m \\times m}$ 是上三角矩阵。$A$ 的转置得到 $J = A^T = R^T Q^T$。为了求解 $J \\, \\Delta q = b$，通过关系式定义 $y \\in \\mathbb{R}^m$\n$$R^T \\, y = b.$$\n由于如果 $J$ 是行满秩的，则 $R^T$ 是三角矩阵且可逆，因此该系统可以通过回代法或直接求解器高效求解。然后，最小范数解可恢复为\n$$\\Delta q = Q \\, y.$$\n为了验证，代入：\n$$J \\, \\Delta q = (R^T Q^T)(Q y) = R^T y = b.$$\n这种构造在 $Q$ 的列空间中产生解，该解对应于所有可能解中的最小欧几里得范数解。\n\n对于每个测试用例，算法按以下步骤进行：\n1. 初始化参数 $L$ (米), $R$ (米), $\\Delta t$ (秒), $q$ (米) 和 $\\dot{q}$ (米/秒)。\n2. 无约束显式 Euler 步：\n   $$q^\\ast = q + \\Delta t \\, \\dot{q}, \\quad \\dot{q}^\\ast = \\dot{q}.$$\n3. 计算在 $q^\\ast$ 处的约束值：\n   $$\\phi_1(q^\\ast) = (x_2^\\ast - x_1^\\ast)^2 + (y_2^\\ast - y_1^\\ast)^2 - L^2,$$\n   $$\\phi_2(q^\\ast) = (x_1^\\ast)^2 + (y_1^\\ast)^2 - R^2.$$\n4. 计算雅可比矩阵 $J(q^\\ast)$，其行由以下给出\n   $$\\frac{\\partial \\phi_1}{\\partial q} = [-2(x_2^\\ast - x_1^\\ast), \\, -2(y_2^\\ast - y_1^\\ast), \\, 2(x_2^\\ast - x_1^\\ast), \\, 2(y_2^\\ast - y_1^\\ast)],$$\n   $$\\frac{\\partial \\phi_2}{\\partial q} = [2 x_1^\\ast, \\, 2 y_1^\\ast, \\, 0, \\, 0].$$\n5. 构造 $A = J(q^\\ast)^T$ 并计算简约 QR 分解 $A = Q R$。\n6. 求解 $R^T \\, y = -\\phi(q^\\ast)$ 得到 $y$，并设置 $\\Delta q = Q \\, y$。\n7. 更新投影后的位置 $q^+ = q^\\ast + \\Delta q$。\n8. 重新计算 $J(q^+)$ 和速度约束残差 $\\dot{\\phi}(q^+, \\dot{q}^\\ast) = J(q^+) \\, \\dot{q}^\\ast$。\n9. 构造 $A_v = J(q^+)^T$，计算 $A_v = Q_v R_v$，求解 $R_v^T \\, y_v = -\\dot{\\phi}(q^+, \\dot{q}^\\ast)$，并设置 $\\Delta \\dot{q} = Q_v \\, y_v$。\n10. 更新投影后的速度 $\\dot{q}^+ = \\dot{q}^\\ast + \\Delta \\dot{q}$。\n11. 计算残差：\n    $$r_q = \\left\\| \\phi(q^+) \\right\\|_2 \\quad (\\text{m}^2), \\quad r_{\\dot{q}} = \\left\\| J(q^+) \\, \\dot{q}^+ \\right\\|_2 \\quad (\\text{m}^2/\\text{s}).$$\n12. 将 $r_q$ 和 $r_{\\dot{q}}$ 四舍五入到六位小数，并记录该配对 $[r_q, r_{\\dot{q}}]$。\n\n测试套件的覆盖理由：\n- 正常路径使用小漂移和中等速度，测试 $J$ 条件良好时的标准操作。\n- 边界情况使用零速度，验证速度投影能以最小的调整将速度残差减小到接近机器精度。\n- 近奇异情况配置的 $q$ 使得约束的梯度接近共线，从而产生一个病态的 $J$，但仍保持行满秩；基于 QR 的求解器保持了数值稳定性，而无需借助伪逆或奇异值分解 (SVD)。\n\n最后，程序按要求将三个 $[r_q, r_{\\dot{q}}]$ 配对聚合为单行，格式为由方括号括起来的列表的逗号分隔列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi(q, L, R):\n    \"\"\"\n    Compute the constraint vector phi(q) for:\n    phi1 = distance^2 - L^2\n    phi2 = x1^2 + y1^2 - R^2\n    \"\"\"\n    x1, y1, x2, y2 = q\n    dxf = x2 - x1\n    dyf = y2 - y1\n    phi1 = dxf * dxf + dyf * dyf - L * L\n    phi2 = x1 * x1 + y1 * y1 - R * R\n    return np.array([phi1, phi2], dtype=float)\n\ndef J(q):\n    \"\"\"\n    Compute the Jacobian J(q) of the constraints with respect to q = [x1, y1, x2, y2].\n    J is 2x4:\n    Row 1: d(phi1)/dq = [-2(dx), -2(dy), 2(dx), 2(dy)]\n    Row 2: d(phi2)/dq = [2*x1, 2*y1, 0, 0]\n    \"\"\"\n    x1, y1, x2, y2 = q\n    dx = x2 - x1\n    dy = y2 - y1\n    J1 = np.array([-2.0 * dx, -2.0 * dy, 2.0 * dx, 2.0 * dy], dtype=float)\n    J2 = np.array([2.0 * x1, 2.0 * y1, 0.0, 0.0], dtype=float)\n    return np.vstack([J1, J2])\n\ndef qr_min_norm_solve(Jmat, b):\n    \"\"\"\n    Solve J x = b for minimum-norm x using reduced QR of J^T:\n    J^T = Q R, with Q (n x m), R (m x m) upper triangular.\n    Solve R^T y = b, then x = Q y.\n    \"\"\"\n    A = Jmat.T  # shape (n, m)\n    # reduced QR: returns Q (n x m), R (m x m)\n    Q, R = np.linalg.qr(A, mode='reduced')\n    # Solve R^T y = b\n    y = np.linalg.solve(R.T, b)\n    x = Q @ y\n    return x\n\ndef project_step(q, qdot, L, R, dt):\n    \"\"\"\n    Perform one unconstrained explicit Euler step followed by coordinate projection\n    for positions and velocities using QR-based minimum-norm solves.\n    Returns projected (q_plus, qdot_plus) and residuals (rq, rvdot).\n    \"\"\"\n    # Unconstrained step\n    q_star = q + dt * qdot\n    qdot_star = qdot.copy()\n\n    # Position projection\n    J_star = J(q_star)\n    phi_star = phi(q_star, L, R)\n    # Solve J_star * dq = -phi_star\n    dq = qr_min_norm_solve(J_star, -phi_star)\n    q_plus = q_star + dq\n\n    # Velocity projection\n    J_plus = J(q_plus)\n    phidot_plus = J_plus @ qdot_star  # since no explicit time dependence\n    # Solve J_plus * dqd = -phidot_plus\n    dqd = qr_min_norm_solve(J_plus, -phidot_plus)\n    qdot_plus = qdot_star + dqd\n\n    # Residuals\n    rq = np.linalg.norm(phi(q_plus, L, R), ord=2)  # in m^2\n    rvdot = np.linalg.norm(J_plus @ qdot_plus, ord=2)  # in m^2/s\n\n    return q_plus, qdot_plus, rq, rvdot\n\ndef format_pair(rq, rvdot):\n    # Round to six decimal places and format\n    return f\"[{rq:.6f},{rvdot:.6f}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L, R, dt, q, qdot)\n    test_cases = [\n        (1.0, 0.5, 0.01, np.array([0.52, 0.00, 1.48, 0.02], dtype=float), np.array([0.00, 0.10, -0.05, 0.00], dtype=float)),\n        (1.2, 0.6, 0.02, np.array([0.59, 0.01, 0.00, 1.81], dtype=float), np.array([0.00, 0.00, 0.00, 0.00], dtype=float)),\n        (0.8, 0.4, 0.015, np.array([0.399, 0.010, 1.17705, 0.0395], dtype=float), np.array([-0.02, 0.03, 0.01, -0.01], dtype=float)),\n    ]\n\n    results_str_items = []\n    for L, R, dt, q, qdot in test_cases:\n        _, _, rq, rvdot = project_step(q, qdot, L, R, dt)\n        results_str_items.append(format_pair(rq, rvdot))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_items)}]\")\n\nsolve()\n```"
        }
    ]
}