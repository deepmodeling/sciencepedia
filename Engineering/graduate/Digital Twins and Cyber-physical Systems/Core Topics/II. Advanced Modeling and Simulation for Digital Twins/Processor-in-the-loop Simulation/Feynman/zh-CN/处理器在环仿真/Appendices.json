{
    "hands_on_practices": [
        {
            "introduction": "在将控制算法部署到目标处理器上之前，我们必须首先确保它能在严格的时间限制内完成计算。本练习提供了一项实时调度分析的基础实践，要求您计算在单个控制周期内，计入所有计算任务和系统开销后剩余的可用“裕量”时间。这是验证处理器在环（PIL）仿真设置可行性的关键第一步，确保控制任务不会超出其最后时限 。",
            "id": "4236201",
            "problem": "在一个信息物理系统的采样数据控制回路的在环处理器（PIL）实验中，一个单一的周期性控制任务以采样周期 $T_{s}$ 执行。该任务在目标处理器上以抢占式固定优先级调度方式运行，并且是实验期间系统中唯一的周期性任务。以下条件成立。\n\n- 控制任务在目标处理器上的最坏情况执行时间（WCET）为 $C$。\n- 每次上下文切换会产生固定的开销 $S$，在任务分派时发生一次，在任务完成时发生一次。\n- 在每个采样周期内，会有一个异步输入/输出（I/O）中断到达并抢占处理器，最坏情况下的持续时间为 $I$；假设为最坏情况相位，以致在每个采样周期内恰好发生一次这样的抢占。\n- 驱动在控制计算结束时执行，并紧随一个可选的驱动后诊断程序，其执行时间为 $D$。如果包含该诊断程序，它也必须在同一个采样周期结束前完成。\n- 不存在重叠或并行；所有的执行和开销都消耗同一个单核处理器资源。\n\n从单个周期性任务的实时调度第一性原理出发，将每个采样周期内的可用裕量定义为计入控制任务的WCET、每个周期的两次上下文切换以及单次最坏情况I/O中断抢占后剩余的时间。然后，推导在同一采样周期内分配了驱动后诊断程序后的剩余裕量边际。\n\n给定数值 $T_{s}=1\\,\\text{ms}$，$C=0.6\\,\\text{ms}$，$S=0.05\\,\\text{ms}$，$I=0.1\\,\\text{ms}$ 和 $D=0.2\\,\\text{ms}$，计算剩余裕量边际。根据剩余边际的符号，说明该裕量是否足够用于诊断程序。以毫秒为单位表示最终的剩余裕量边际。不要对结果进行四舍五入。",
            "solution": "用户希望我解决一个与在环处理器（PIL）实验相关的实时调度问题。\n\n我的计划如下：\n1.  **验证问题**：我将根据我的验证标准仔细检查问题陈述。\n    *   **第1步：提取已知条件**：逐字列出所有提供的变量和值。\n        *   $T_s$: 采样周期。\n        *   $C$: 控制任务的最坏情况执行时间（WCET）。\n        *   $S$: 每次切换的上下文切换开销。\n        *   $I$: 异步I/O中断的最坏情况持续时间。\n        *   $D$: 可选的驱动后诊断程序的执行时间。\n        *   控制任务是周期性的，周期为 $T_s$。\n        *   这是一个采用抢占式固定优先级调度的单周期任务系统。\n        *   每个周期发生两次上下文切换（分派和完成）。\n        *   每个周期恰好发生一次持续时间为 $I$ 的I/O中断抢占。\n        *   所有执行和开销都在单核处理器上。\n        *   如果包含诊断程序，它必须在采样周期内完成。\n        *   数值：$T_s=1\\,\\text{ms}$，$C=0.6\\,\\text{ms}$，$S=0.05\\,\\text{ms}$，$I=0.1\\,\\text{ms}$，$D=0.2\\,\\text{ms}$。\n\n    *   **第2步：使用提取的已知条件进行验证**：\n        *   **科学上是否成立？**：是。该问题使用了实时系统和嵌入式控制的标准概念，例如WCET、采样周期、上下文切换开销和抢占式调度。这些是计算机工程和信息物理系统中的基本主题。\n        *   **问题是否适定？**：是。问题要求进行具体的推导（可用裕量、剩余裕量边际）和基于给定数据的数值计算。似乎有足够的信息来得出一个唯一的解。\n        *   **是否客观？**：是。语言精确且技术性强。没有主观或基于意见的陈述。\n        *   **缺陷检查**：\n            1.  **科学上不健全？**：否。该模型是一个简化模型（例如，固定的开销、最坏情况相位），但这些是入门级实时系统分析中的标准假设。它没有违反任何基本原则。\n            2.  **无法形式化/不相关？**：否。该问题直接关系到在环处理器仿真，这是开发信息物理系统的一项关键技术。它完全可以形式化。\n            3.  **不完整/矛盾？**：否。设置看起来是完整和一致的。我们拥有一个周期内时间消耗的所有必要组成部分和总可用时间。\n            4.  **不切实际/不可行？**：否。这些数值对于基于微控制器的控制系统是合理的。$T_s=1\\,\\text{ms}$ 是一个 $1\\,\\text{kHz}$ 的控制回路，这很常见。执行时间和开销在微秒范围内，这也是现实的。所有单位都是一致的（毫秒）。\n            5.  **不适定？**：否。问题清晰地定义了“可用裕量”和“剩余裕量边际”，指导了解题过程。解应该是唯一且稳定的。\n            6.  **伪深刻/琐碎？**：否。这是调度原理的直接应用，但需要仔细计算所有时间分量。这是一个有效的入门级问题。\n            7.  **无法验证？**：否。推导和计算在数学上是可验证的。\n\n    *   **第3步：结论**：该问题是**有效的**。\n\n2.  **解决问题**：现在我将开始解题。\n\n    *   **原理**：核心原理是，对于一个实时任务而言，要使其可调度（即满足其截止时间），其总的最坏情况响应时间必须小于或等于其截止时间。在这种情况下，截止时间是采样周期的结束，即 $T_s$。一个周期内所有活动消耗的总时间不得超过 $T_s$。\n\n    *   **步骤 A：定义一个周期内的总处理器需求（不包括诊断程序）**\n        *   一个采样周期内的总可用时间为 $T_s$。\n        *   处理器忙于几项活动。我需要将它们的最坏情况持续时间相加。\n        *   **控制任务执行**：这被给出为WCET，即 $C$。\n        *   **上下文切换开销**：问题陈述一个固定的开销 $S$ 在*任务分派时发生一次，任务完成时发生一次*。因此，每个周期的总上下文切换开销为 $2S$。\n        *   **I/O中断抢占**：问题陈述恰好有一个最坏情况持续时间为 $I$ 的中断抢占了该任务。这段时间也被处理器消耗，必须计入。\n        *   **总需求（不含诊断）**，我们称之为 $T_{demand}$：\n            $T_{demand} = C + 2S + I$。这是处理器用于执行控制任务、处理其上下文切换以及服务I/O中断所占用的总时间。\n\n    *   **步骤 B：定义和计算可用裕量**\n        *   问题将“可用裕量”定义为计入控制任务的WCET、两次上下文切换和I/O中断后剩余的时间。\n        *   设可用裕量为 $\\sigma_{avail}$。\n        *   根据第一性原理，裕量是总可用时间减去总消耗时间。\n        *   $\\sigma_{avail} = T_s - T_{demand}$\n        *   $\\sigma_{avail} = T_s - (C + 2S + I)$\n\n    *   **步骤 C：定义和计算剩余裕量边际**\n        *   问题接着要求推导在分配了执行时间为 $D$ 的驱动后诊断程序后的“剩余裕量边际”。\n        *   这个程序消耗额外的处理器时间。剩余裕量是可用裕量减去这个新程序所需的时间。\n        *   设剩余裕量边际为 $\\sigma_{rem}$。\n        *   $\\sigma_{rem} = \\sigma_{avail} - D$\n        *   代入 $\\sigma_{avail}$ 的表达式：\n            $\\sigma_{rem} = (T_s - C - 2S - I) - D$\n        *   所以，$\\sigma_{rem} = T_s - C - 2S - I - D$。\n\n    *   **步骤 D：数值计算**\n        *   现在，我将把给定的数值代入推导出的 $\\sigma_{rem}$ 公式中。\n        *   $T_s = 1\\,\\text{ms}$\n        *   $C = 0.6\\,\\text{ms}$\n        *   $S = 0.05\\,\\text{ms}$\n        *   $I = 0.1\\,\\text{ms}$\n        *   $D = 0.2\\,\\text{ms}$\n        *   $\\sigma_{rem} = 1 - 0.6 - 2(0.05) - 0.1 - 0.2$\n        *   $\\sigma_{rem} = 1 - 0.6 - 0.1 - 0.1 - 0.2$\n        *   $\\sigma_{rem} = 1 - (0.6 + 0.1 + 0.1 + 0.2)$\n        *   $\\sigma_{rem} = 1 - 1.0$\n        *   $\\sigma_{rem} = 0\\,\\text{ms}$\n\n    *   **步骤 E：解释**\n        *   问题要求根据剩余边际的符号说明裕量是否足够用于诊断程序。\n        *   一个非负的剩余裕量边际（$\\sigma_{rem} \\ge 0$）意味着所有任务，包括诊断程序，在最坏情况下都可以在截止时间 $T_s$ 内完成。\n        *   一个负的剩余裕量边际（$\\sigma_{rem}  0$）意味着所需的总执行时间超过了可用时间，因此系统是不可调度的（将会错过截止时间）。\n        *   在这种情况下，$\\sigma_{rem} = 0$。这意味着总的最坏情况先验利用率恰好等于可用时间。系统是可调度的，但裕量为零。裕量恰好足够，不多也不少。\n\n    *   **最终答案的构建**：\n        *   最终数值答案是 $0$。\n        *   问题要求“以毫秒为单位表示最终的剩余裕量边际”。\n        *   结果是 $0$。\n        *   最终答案必须包含在 `$$\\boxed{...}$$` 中。\n        *   所以，最终答案将是 `$$\\boxed{0}$$`。\n\n这似乎是正确的，并且遵循了所有指令。我将再次检查计算和推理。\n$T_s = 1$\n$C = 0.6$\n$2S = 2 \\times 0.05 = 0.1$\n$I = 0.1$\n$D = 0.2$\n包含诊断程序的总消耗时间：$C + 2S + I + D = 0.6 + 0.1 + 0.1 + 0.2 = 1.0$。\n可用时间 = $T_s = 1.0$。\n剩余裕量 = 可用时间 - 总消耗时间 = $1.0 - 1.0 = 0$。\n逻辑是健全的。结果的解释也是正确的。系统是可调度的，但处于临界状态。问题问裕量是否*足够*，如果边际为非负数，则足够。$0$ 是非负数，所以足够。我的完整解释将包括这一点。然而，最终答案框只包含数值结果。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "一个在理论上正确的算法，在真实处理器上的行为也可能与理想化的桌面仿真（软件在环，SIL）有所不同。本练习将揭示诸如单精度浮点运算、编译器优化（如融合乘加 FMA）以及指令延迟等硬件特有因素，如何导致系统状态出现可观测的偏差。通过编写程序来同时模拟 SIL 和 PIL 环境，您将能够量化这些差异，并深刻理解 PIL 对于系统最终验证的必要性 。",
            "id": "4236172",
            "problem": "考虑一个同时以软件在环 (SIL) 和处理器在环 (PIL) 方式实现的信息物理控制回路。SIL 版本在主机上运行，使用双精度算术和理想的零计算时间。PIL 版本在目标处理器上运行，采用单精度算术，并可能通过编译器优化启用融合乘加操作，同时由于处理器特定的指令延迟而产生固定的驱动延迟。您将构建一个最小示例，在该示例中，PIL 运行的结果与 SIL 运行的结果不同，而这种差异完全是由编译器优化和指令延迟引起的。您还需要识别出体现这种差异的可观测变量。\n\n从以下基本依据开始：\n- 一个一阶线性时不变被控对象，其连续时间动态特性由 $\\frac{dx(t)}{dt} = -\\lambda x(t) + \\lambda u(t)$ 给出，其中 $\\lambda  0$。\n- 使用采样周期 $T_s$ 的零阶保持器 (ZOH) 进行离散化，得到离散时间被控对象 $x_{k+1} = a x_k + b u_k$，其中 $a = e^{-\\lambda T_s}$ 且 $b = 1 - e^{-\\lambda T_s}$。\n- 一个比例控制器 $u_k = K(r - x_k)$，其中 $r$ 是一个恒定的参考值。\n\n假设 SIL 回路使用精确调度，计算延迟为零，并采用双精度算术。假设 PIL 回路使用单精度算术，可能通过编译器优化启用了融合乘加，并存在一个固定的驱动延迟，该延迟被建模为 $d$ 步的纯输运延迟，其中 $d = \\lceil L / T_s \\rceil$，$L$ 是处理器特定的指令延迟。两个回路应用相同的离散时间控制律和相同的被控对象模型。SIL 和 PIL 之间唯一的区别在于算术精度、融合乘加效应以及由指令延迟引起的驱动延迟 $d$。\n\n您的任务：\n1. 实现一个程序，该程序针对给定的参数集 $\\{\\lambda, T_s, K, r, x_0, N, L, \\mathrm{fma\\_enabled}\\}$，对 SIL 和 PIL 回路进行 $N$ 步的仿真。对于 SIL，以双精度计算 $x_{k+1} = a x_k + b u_k$，并立即执行驱动。对于 PIL，以单精度计算 $x_{k+1} = a x_k + b u^{\\mathrm{applied}}_k$，其中 $u^{\\mathrm{applied}}_k$ 是 $d$ 步前计算的控制量，即当 $k \\ge d$ 时 $u^{\\mathrm{applied}}_k = u_{k-d}$，当 $k  d$ 时 $u^{\\mathrm{applied}}_k = 0$。当 $\\mathrm{fma\\_enabled}$ 为真时，通过以更高精度计算 $a x_k + b u^{\\mathrm{applied}}_k$ 然后一次性舍入到单精度的方式，来模拟状态更新中的融合乘加操作；当为假时，通过执行乘法和加法并进行独立的单精度舍入，来模拟非融合乘加操作。\n2. 计算 SIL 和 PIL 之间的以下可观测差异变量：\n   - 最大绝对状态差异 $E_x = \\max_{0 \\le k  N} |x_k^{\\mathrm{SIL}} - x_k^{\\mathrm{PIL}}|$ (无量纲)。\n   - 最大绝对应用控制差异 $E_u = \\max_{0 \\le k  N} |u_k^{\\mathrm{applied,SIL}} - u_k^{\\mathrm{applied,PIL}}|$ (无量纲)。\n   - 延迟步数 $d$ (一个整数)。\n3. 使用以下参数集测试套件来评估差异的不同方面。所有时间都必须解释为秒，但要生成的输出是无量纲的浮点数或整数：\n   - 测试用例 A (理想路径，无优化，无延迟)：$\\lambda = 2000$，$T_s = 10^{-5}$，$r = 1$，$x_0 = 0$，$N = 10000$，选择 $K$ 以使期望的闭环离散极点为 $a_{\\mathrm{cl}} = e^{-T_s / \\tau_{\\mathrm{cl}}}$，其中 $\\tau_{\\mathrm{cl}} = 0.05$，$L = 0$，$\\mathrm{fma\\_enabled} = \\mathrm{false}$。\n   - 测试用例 B (仅编译器优化)：与 A 相同，但 $\\mathrm{fma\\_enabled} = \\mathrm{true}$。\n   - 测试用例 C (一步延迟与优化)：与 B 相同，但 $L = T_s$。\n   - 测试用例 D (两步延迟与优化)：与 B 相同，但 $L = 2 T_s$。\n   在所有情况下，计算 $a = e^{-\\lambda T_s}$ 和 $b = 1 - e^{-\\lambda T_s}$，并使用 $K = \\frac{a - a_{\\mathrm{cl}}}{b}$ 计算 $K$。\n4. 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个形如 $[E_x, E_u, d]$ 的列表。例如，最终打印的行应类似于 $[[e_x^{A}, e_u^{A}, d^{A}],[e_x^{B}, e_u^{B}, d^{B}],\\ldots]$，不含空格。\n\n输出 $E_x$ 和 $E_u$ 必须是实数，$d$ 必须是整数。不涉及角度。输入中的所有时间都以秒为单位，但要求的输出是无量纲或整数计数。请通过遵循指定的被控对象和控制器模型，并将延迟严格建模为驱动中的纯输运延迟，来确保科学真实性。",
            "solution": "用户提供的问题陈述是有效的。它在控制理论和计算机算术方面具有科学依据，其参数和定义完整且一致，问题是适定的，并且其表述是客观的。\n\n它提出了一个非凡但可解决的任务，该任务与信息物理系统的研究直接相关，特别是软件在环 (SIL) 和处理器在环 (PIL) 仿真之间的差异。\n\n问题的核心是在两种不同的环境下构建和仿真一个数字控制回路，并量化由此产生的差异。体现差异的可观测变量是被控对象的状态轨迹（表示为 $\\{x_k\\}_{k=0}^{N-1}$）和应用于被控对象的控制信号历史记录（表示为 $\\{u_k^{\\mathrm{applied}}\\}_{k=0}^{N-1}$）。这些差异由度量 $E_x$ 和 $E_u$ 来量化，它们表示在 $N$ 步的仿真时域内，这些相应变量在 SIL 和 PIL 环境之间的最大绝对差。\n\n解决方案的步骤是：首先确定系统参数，然后根据指定的算术精度和时序规则对 SIL 和 PIL 配置的系统动态进行仿真，最后计算指定的差异度量。\n\n首先，我们建立系统的离散时间模型。连续时间被控对象是一个一阶线性时不变 (LTI) 系统，其动态特性为 $\\frac{dx(t)}{dt} = -\\lambda x(t) + \\lambda u(t)$。使用采样周期为 $T_s$ 的零阶保持器 (ZOH) 对该系统进行离散化，得到离散时间状态空间表示：\n$$x_{k+1} = a x_k + b u_k$$\n其中系数 $a$ 和 $b$ 是被控对象参数 $\\lambda$ 和采样周期 $T_s$ 的函数：\n$$a = e^{-\\lambda T_s}$$\n$$b = 1 - e^{-\\lambda T_s} = 1 - a$$\n该系统由一个比例控制器 $u_k = K(r - x_k)$ 控制，其中 $r$ 是参考设定点，$K$ 是比例增益。增益 $K$ 的设计目的是将离散时间闭环极点配置在期望的位置 $a_{\\mathrm{cl}}$。没有任何延迟的闭环系统方程为 $x_{k+1} = a x_k + b K (r-x_k) = (a - bK)x_k + bKr$。因此极点是 $a - bK$。将其设置为 $a_{\\mathrm{cl}}$ 并求解 $K$ 可得：\n$$K = \\frac{a - a_{\\mathrm{cl}}}{b}$$\n期望的极点 $a_{\\mathrm{cl}}$ 是通过一个期望的连续时间闭环时间常数 $\\tau_{\\mathrm{cl}}$ 来指定的，使得 $a_{\\mathrm{cl}} = e^{-T_s / \\tau_{\\mathrm{cl}}}$。对于每个测试用例，首先计算这些参数——$a$，$b$，$a_{\\mathrm{cl}}$ 和 $K$。\n\n软件在环 (SIL) 仿真作为理想化的参考。其特点是：\n1.  **双精度算术**：所有计算都使用 64 位浮点数 (`float64`) 执行，这对应于典型的主机环境。\n2.  **零延迟**：在步骤 $k$ 计算出的控制输出 $u_k$ 在同一步骤内应用于被控对象模型，即 $u_k^{\\mathrm{applied,SIL}} = u_k = K(r - x_k^{\\mathrm{SIL}})$。\n状态轨迹 $\\{x_k^{\\mathrm{SIL}}\\}$ 是通过从初始条件 $x_0^{\\mathrm{SIL}} = x_0$ 开始，对 $k = 0, 1, \\dots, N-2$ 迭代方程 $x_{k+1}^{\\mathrm{SIL}} = a x_k^{\\mathrm{SIL}} + b u_k^{\\mathrm{applied,SIL}}$ 生成的。\n\n处理器在环 (PIL) 仿真模拟了嵌入式处理器的行为。它在两个关键方面与 SIL 仿真不同：\n1.  **单精度算术**：所有计算都使用 32 位浮点数 (`float32`) 执行。这包括所有参数（$a, b, K, r, x_0$）和状态变量。\n2.  **驱动延迟**：一个固定的指令延迟 $L$ 导致 $d = \\lceil L / T_s \\rceil$ 个采样步的输运延迟。在步骤 $k$ 应用的控制信号，表示为 $u_k^{\\mathrm{applied,PIL}}$，是 $d$ 步前计算的那个：$u_k^{\\mathrm{applied,PIL}} = u_{k-d}$。对于初始步骤 $k  d$，没有先前的控制动作可用，因此 $u_k^{\\mathrm{applied,PIL}} = 0$。计算出的控制仍然是 $u_j = K(r - x_j^{\\mathrm{PIL}})$。\n状态更新 $x_{k+1}^{\\mathrm{PIL}} = a x_k^{\\mathrm{PIL}} + b u_k^{\\mathrm{applied,PIL}}$ 是以单精度执行的。这就是编译器优化（$\\mathrm{fma\\_enabled}$）产生影响的地方：\n-   如果 $\\mathrm{fma\\_enabled}$ 是 $\\mathrm{false}$，计算过程将模拟分离的乘法和加法操作。每个算术运算（乘法、加法）都会导致一次到单精度的中间舍入。这通过执行两次乘法，$a \\cdot x_k^{\\mathrm{PIL}}$ 和 $b \\cdot u_k^{\\mathrm{applied,PIL}}$，以及最后的加法来建模，确保始终使用 `float32` 算术。\n-   如果 $\\mathrm{fma\\_enabled}$ 是 $\\mathrm{true}$，将模拟一个融合乘加 (FMA) 操作。和 $a \\cdot x_k^{\\mathrm{PIL}} + b u_k^{\\mathrm{applied,PIL}}$ 以更高的精度（例如 `float64`）计算，然后仅舍入一次到 `float32`。与非 FMA 情况下的多次舍入步骤相比，这单次的舍入步骤可以产生更精确的结果，从而导致不同的数值轨迹。\n\n仿真程序实现了这两个模型。对于每个测试用例，它生成完整的状态轨迹 $\\{x_k^{\\mathrm{SIL}}\\}_{k=0}^{N-1}$ 和 $\\{x_k^{\\mathrm{PIL}}\\}_{k=0}^{N-1}$，以及应用控制历史 $\\{u_k^{\\mathrm{applied,SIL}}\\}_{k=0}^{N-1}$ 和 $\\{u_k^{\\mathrm{applied,PIL}}\\}_{k=0}^{N-1}$。\n\n最后，通过计算在 $N$ 个步骤中对应的 SIL 和 PIL 历史记录之间的最大绝对差来计算差异度量：\n$$E_x = \\max_{0 \\le k  N} |x_k^{\\mathrm{SIL}} - x_k^{\\mathrm{PIL}}|$$\n$$E_u = \\max_{0 \\le k  N} |u_k^{\\mathrm{applied,SIL}} - u_k^{\\mathrm{applied,PIL}}|$$\n每个用例的延迟 $d$ 也会被报告。程序会遍历四个指定的测试用例，为每个用例执行这些计算，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_sil(N, x0, r, K, a, b):\n    \"\"\"\n    Simulates the SIL loop using double-precision arithmetic and zero delay.\n    \"\"\"\n    dtype = np.float64\n    a_d64, b_d64, K_d64, r_d64, x0_d64 = map(dtype, [a, b, K, r, x0])\n\n    x_hist = np.zeros(N, dtype=dtype)\n    u_app_hist = np.zeros(N, dtype=dtype)\n\n    x_hist[0] = x0_d64\n\n    for k in range(N):\n        # Control is computed and applied instantaneously\n        u_k = K_d64 * (r_d64 - x_hist[k])\n        u_app_hist[k] = u_k\n\n        # Update state for next step\n        if k  N - 1:\n            x_hist[k + 1] = a_d64 * x_hist[k] + b_d64 * u_k\n\n    return x_hist, u_app_hist\n\ndef simulate_pil(N, x0, r, K, a, b, d, fma_enabled):\n    \"\"\"\n    Simulates the PIL loop using single-precision arithmetic, latency, and FMA/non-FMA.\n    \"\"\"\n    dtype = np.float32\n    a_f32, b_f32, K_f32, r_f32, x0_f32 = map(dtype, [a, b, K, r, x0])\n\n    x_hist = np.zeros(N, dtype=dtype)\n    u_computed_hist = np.zeros(N, dtype=dtype)\n    u_app_hist = np.zeros(N, dtype=dtype)\n\n    x_hist[0] = x0_f32\n\n    for k in range(N):\n        # 1. Compute control based on current state x_hist[k]\n        u_computed_hist[k] = K_f32 * (r_f32 - x_hist[k])\n\n        # 2. Determine applied control for current step k, based on latency d\n        if k  d:\n            u_app_k = dtype(0.0)\n        else:\n            u_app_k = u_computed_hist[k - d]\n        u_app_hist[k] = u_app_k\n\n        # 3. Update state for next step k+1\n        if k  N - 1:\n            if fma_enabled:\n                # Emulate Fused Multiply-Add: intermediate calculation in higher precision, one rounding\n                x_hist[k + 1] = np.float32(float(a_f32) * float(x_hist[k]) + float(b_f32) * float(u_app_k))\n            else:\n                # Emulate non-FMA: standard float32 arithmetic implies rounding after each operation\n                x_hist[k + 1] = (a_f32 * x_hist[k]) + (b_f32 * u_app_k)\n\n    return x_hist, u_app_hist\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case A: happy path, no optimization, no latency\n        {'lambda_': 2000, 'Ts': 1e-5, 'r': 1, 'x0': 0, 'N': 10000, 'tau_cl': 0.05, 'L': 0, 'fma_enabled': False},\n        # Test Case B: compiler optimization only\n        {'lambda_': 2000, 'Ts': 1e-5, 'r': 1, 'x0': 0, 'N': 10000, 'tau_cl': 0.05, 'L': 0, 'fma_enabled': True},\n        # Test Case C: one-step latency with optimization\n        {'lambda_': 2000, 'Ts': 1e-5, 'r': 1, 'x0': 0, 'N': 10000, 'tau_cl': 0.05, 'L': 1e-5, 'fma_enabled': True},\n        # Test Case D: two-step latency with optimization\n        {'lambda_': 2000, 'Ts': 1e-5, 'r': 1, 'x0': 0, 'N': 10000, 'tau_cl': 0.05, 'L': 2e-5, 'fma_enabled': True},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters\n        lambda_val = case['lambda_']\n        Ts = case['Ts']\n        r = case['r']\n        x0 = case['x0']\n        N = case['N']\n        tau_cl = case['tau_cl']\n        L = case['L']\n        fma_enabled = case['fma_enabled']\n\n        # Calculate derived parameters\n        a = np.exp(-lambda_val * Ts)\n        b = 1.0 - a\n        a_cl = np.exp(-Ts / tau_cl)\n        K = (a - a_cl) / b\n        d = int(np.ceil(L / Ts))\n\n        # Run simulations\n        x_sil, u_app_sil = simulate_sil(N, x0, r, K, a, b)\n        x_pil, u_app_pil = simulate_pil(N, x0, r, K, a, b, d, fma_enabled)\n\n        # Compute discrepancy metrics\n        # Cast PIL results to float64 for stable comparison with SIL results\n        Ex = np.max(np.abs(x_sil - x_pil.astype(np.float64)))\n        Eu = np.max(np.abs(u_app_sil - u_app_pil.astype(np.float64)))\n        \n        results.append([Ex, Eu, d])\n\n    # Format the final output string exactly as required\n    result_str = ','.join([f'[{r[0]},{r[1]},{r[2]}]' for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在识别了 PIL 环境中的挑战后，下一步是设计策略来主动应对它们。本练习将引导您进入一个更高级的领域：我们不再仅仅观察由处理器延迟引起的问题，而是主动设计一个补偿方案。您将构建一个协同仿真模型，其中数字孪生体通过预测物理对象的未来状态来抵消固有的计算延迟，并通过探索寻找最优的预测时间窗口以最小化跟踪误差，从而展示数字孪生体在现代赛博物理系统中的强大应用 。",
            "id": "4236198",
            "problem": "考虑一个单输入、单输出的连续时间线性时不变（LTI）设备，其状态方程为 $ \\dot{x}(t) = a \\, x(t) + b \\, u(t) $，输出为 $ y(t) = x(t) $。一个数字孪生（DT），定义为该设备基于物理的计算复制品，被用于在环处理器（PIL）仿真中预测未来的设备状态，以补偿处理器的计算延迟。执行器指令通过零阶保持器（ZOH）在离散采样时刻 $ t_k = k \\, T_s $ 更新，其中 $ T_s $ 是采样周期。处理器会引入 $ \\tau_p $ 秒的计算延迟，该延迟严格小于采样周期 $ T_s $，即 $ 0 \\le \\tau_p  T_s $。在每个采样时刻 $ t_k $，控制器使用应用于预测时域为 $ h \\in [0, \\tau_p] $ 的DT预测状态的状态反馈律来计算控制输入；由于延迟，新计算出的控制指令将在时间 $ t_k + \\tau_p $ 应用于设备。参考信号为阶跃信号 $ r(t) = r_0 $（对于所有 $ t \\ge 0 $）。\n\n设计一个协同仿真方案，其中：\n- 在ZOH和延迟控制应用下，设备在分段恒定输入下进行连续积分。\n- 在每个采样时间 $ t_k $，DT预测未来时间 $ t_k + h $ 的设备状态，假设在 $ [t_k, t_k + h) $ 上的输入与当前应用于设备的输入保持相等。\n- 控制器使用增益为 $ K $ 的比例状态反馈作用于DT预测的状态来计算 $ u_k $，并计划在 $ t_k + \\tau_p $ 时应用 $ u_k $。\n- 跟踪误差为 $ e(t) = r_0 - y(t) = r_0 - x(t) $。\n\n对于一组固定的参数 $ (a,b,K,T_s,\\tau_p,r_0) $，定义性能指标\n$$\nJ(h) = \\int_{0}^{T_{\\text{end}}} e(t)^2 \\, dt,\n$$\n其中 $ T_{\\text{end}} $ 是一个关注的有限时间范围。您的任务是为每个测试用例计算预测时域 $ h^\\star \\in [0, \\tau_p] $，该时域在所选协同仿真方案下，在闭环响应在整个 $ [0, T_{\\text{end}}] $ 区间内保持稳定的约束下，能最小化 $ J(h) $。如果状态幅值 $ |x(t)| $ 在 $ [0, T_{\\text{end}}] $ 区间内的任何时刻超过一个大的有限阈值，则声明响应不稳定。\n\n您必须在一个完整的、可运行的程序中实现所述的协同仿真，该程序对 $ h \\in [0, \\tau_p] $ 进行网格搜索以逼近 $ h^\\star $，并返回稳定情况下的最小值。如果在 $ h \\in [0, \\tau_p] $ 中没有值能产生稳定响应，则返回一个“非数值”（Not-a-Number）指示符。所有时间量，包括返回的 $ h^\\star $，都必须以秒为单位表示。最终报告的预测时域必须四舍五入到三位小数。\n\n使用以下测试套件，所有量均采用国际单位制（SI单位）：\n1. 案例 $ 1 $ (理想情况): $ a = -2.0 $, $ b = 1.0 $, $ K = 3.0 $, $ T_s = 0.02 $, $ \\tau_p = 0.006 $, $ r_0 = 1.0 $, $ T_{\\text{end}} = 2.0 $.\n2. 案例 $ 2 $ (边界延迟): $ a = -1.0 $, $ b = 1.0 $, $ K = 2.0 $, $ T_s = 0.01 $, $ \\tau_p = 0.0 $, $ r_0 = 1.0 $, $ T_{\\text{end}} = 1.0 $.\n3. 案例 $ 3 $ (接近采样的延迟): $ a = -1.5 $, $ b = 1.0 $, $ K = 2.5 $, $ T_s = 0.02 $, $ \\tau_p = 0.018 $, $ r_0 = 1.0 $, $ T_{\\text{end}} = 2.0 $.\n4. 案例 $ 4 $ (慢速设备): $ a = -0.5 $, $ b = 1.0 $, $ K = 1.0 $, $ T_s = 0.05 $, $ \\tau_p = 0.01 $, $ r_0 = 1.0 $, $ T_{\\text{end}} = 4.0 $.\n\n角度单位不适用。百分比不适用。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$ [h_1^\\star,h_2^\\star,h_3^\\star,h_4^\\star] $），其中每个 $ h_i^\\star $ 是相应案例的最小化预测时域（单位为秒），四舍五入到三位小数。如果某个案例没有稳定的预测时域，则相应的条目必须是写作 $ \\text{nan} $ 的“非数值”指示符。",
            "solution": "该问题提法得当，具有科学依据。它描述了一个带有计算延迟的数字控制系统的标准在环处理器（PIL）协同仿真场景。其中包含的组件，包括线性时不变（LTI）设备、零阶保持器（ZOH）、用于延迟补偿的状态预测以及性能指标，都是控制理论和信息物理系统中的标准概念。任务是在稳定性约束下，找到一个最优预测时域 $h$，以最小化二次误差成本。这可以通过指定的协同仿真和网格搜索方法进行数值求解。\n\n控制律被描述为“对增益为 $K$ 的DT预测状态进行比例状态反馈”。在一个跟踪误差为 $e(t) = r_0 - x(t)$ 的参考跟踪背景下，这被解释为一个作用于预测跟踪误差的比例控制器。因此，在采样时间 $t_k$ 计算的控制输入 $u_k$ 定义为：\n$$\nu_k = K(r_0 - x_{\\text{pred}}(t_k+h))\n$$\n其中 $x_{\\text{pred}}(t_k+h)$ 是数字孪生对设备在时间 $t_k+h$ 的状态的预测。这种形式确保了控制器试图将设备状态 $x$ 驱动到参考值 $r_0$。\n\n求解方法是实现一个详细的协同仿真，该仿真能准确地模拟事件的时间顺序，然后使用此仿真来评估一系列网格化的 $h$ 值对应的性能指标 $J(h)$。最优的 $h^\\star$ 是在所有稳定仿真中产生最小成本的值。\n\n**1. 设备动态与精确解**\n\n设备是一个由以下状态方程描述的一阶LTI系统：\n$$\n\\dot{x}(t) = a \\, x(t) + b \\, u(t)\n$$\n考虑到由于ZOH和延迟应用，控制输入 $u(t)$ 是分段恒定的，我们可以在任何输入为常数 $u_{\\text{const}}$ 的区间 $[t_i, t_f]$ 上找到状态演化的精确解。该解为：\n$$\nx(t_f) = e^{a(t_f-t_i)} x(t_i) + \\int_{t_i}^{t_f} e^{a(t_f-\\tau)} b \\, u_{\\text{const}} \\, d\\tau\n$$\n对该积分求值，我们得到时间步长为 $\\Delta t = t_f - t_i$ 的状态更新方程。对于 $a \\neq 0$：\n$$\nx(t_i + \\Delta t) = e^{a \\Delta t} x(t_i) + \\frac{b}{a} (e^{a \\Delta t} - 1) u_{\\text{const}}\n$$\n该公式将用于在事件之间传播设备状态，从而避免数值积分误差。\n\n**2. 协同仿真算法**\n\n仿真必须捕捉每个采样周期 $T_s$ 内事件的精确顺序。令 $t_k = k T_s$（$k = 0, 1, 2, \\dots$）。在时间 $t_k$ 的状态是 $x(t_k)$。令 $u_{k-1}$ 是在 $t_{k-1}$ 计算并在 $t_{k-1}+\\tau_p$ 之后应用于设备的控制值。\n\n仿真对每个采样区间 $[t_k, t_{k+1})$ 进行迭代：\n\n- **步骤 A：在 $t_k$ 时的控制器动作**\n  1.  **DT预测**：控制器预测未来时间 $t_k+h$ 的设备状态。问题指定此预测使用时间 $t_k$ 的状态，即 $x(t_k)$，并假设在预测时域 $[t_k, t_k+h)$ 内的输入是当前正应用于设备的输入。在时间 $t_k$，有效的设备输入是 $u_{k-1}$。因此，预测状态为：\n      $$\n      x_{\\text{pred}}(t_k+h) = e^{ah} x(t_k) + \\frac{b}{a} (e^{ah} - 1) u_{k-1}\n      $$\n  2.  **控制计算**：使用关于预测误差的比例反馈律计算新的控制值 $u_k$：\n      $$\n      u_k = K(r_0 - x_{\\text{pred}}(t_k+h))\n      $$\n      该值 $u_k$ 被安排在时间 $t_k + \\tau_p$ 应用。\n\n- **步骤 B：设备在 $[t_k, t_{k+1})$ 上的演化**\n  由于延迟的控制应用，设备状态在两个不同的子区间内演化。\n  1.  **区间 $[t_k, t_k + \\tau_p)$**：设备的输入仍然是 $u_{k-1}$。状态从 $x(t_k)$ 演化到 $x(t_k + \\tau_p)$：\n      $$\n      x(t_k + \\tau_p) = e^{a\\tau_p} x(t_k) + \\frac{b}{a} (e^{a\\tau_p} - 1) u_{k-1}\n      $$\n  2.  **区间 $[t_k + \\tau_p, t_{k+1})$**：在时间 $t_k + \\tau_p$，执行器应用新的控制 $u_k$。设备在该新输入下演化，持续时间为 $T_s - \\tau_p$。下一个采样时刻的状态 $x(t_{k+1})$ 为：\n      $$\n      x(t_{k+1}) = e^{a(T_s - \\tau_p)} x(t_k + \\tau_p) + \\frac{b}{a} (e^{a(T_s - \\tau_p)} - 1) u_k\n      $$\n\n仿真从 $t=0$ 开始，初始状态为 $x(0)=0$，初始控制输入为 $u_{-1}=0$。循环继续直到 $t$ 达到 $T_{\\text{end}}$。\n\n**3. 性能指标计算**\n\n性能指标是平方误差的积分：\n$$\nJ(h) = \\int_{0}^{T_{\\text{end}}} e(t)^2 \\, dt = \\int_{0}^{T_{\\text{end}}} (r_0 - x(t))^2 \\, dt\n$$\n为精确计算此积分，我们对每个控制输入 $u$ 为常数的子区间的贡献进行求和。在持续时间为 $\\Delta t$、起始时间为 $t_i$、初始状态为 $x(t_i)$、常数输入为 $u_{\\text{const}}$ 的区间内，状态轨迹为 $x(t) = (x(t_i) - x_{ss}) e^{a(t-t_i)} + x_{ss}$，其中 $x_{ss} = -b/a \\cdot u_{\\text{const}}$ 是该输入对应的稳态值。\n\n令 $\\tau = t - t_i$。误差为 $e(\\tau) = r_0 - x(\\tau) = (r_0 - x_{ss}) - (x(t_i) - x_{ss})e^{a\\tau}$。令 $C_A = r_0 - x_{ss}$ 和 $C_B = -(x(t_i) - x_{ss})$。平方误差在 $[0, \\Delta t]$ 上的积分为：\n$$\n\\int_{0}^{\\Delta t} (C_A + C_B e^{a\\tau})^2 \\, d\\tau = \\int_{0}^{\\Delta t} (C_A^2 + 2C_A C_B e^{a\\tau} + C_B^2 e^{2a\\tau}) \\, d\\tau\n$$\n对于 $a \\neq 0$，该定积分的精确值为：\n$$\n\\left[ C_A^2 \\tau + \\frac{2C_A C_B}{a} e^{a\\tau} + \\frac{C_B^2}{2a} e^{2a\\tau} \\right]_0^{\\Delta t} = C_A^2 \\Delta t + \\frac{2C_A C_B}{a} (e^{a\\Delta t} - 1) + \\frac{C_B^2}{2a} (e^{2a\\Delta t} - 1)\n$$\n总成本 $J(h)$ 是从 $t=0$ 到 $t=T_{\\text{end}}$ 的仿真中为每个子区间计算的这些积分的总和。\n\n**4. 优化与稳定性**\n\n为找到最优预测时域 $h^\\star$，在区间 $h \\in [0, \\tau_p]$ 上执行网格搜索。对于网格中的每个 $h$ 值：\n- 运行从 $t=0$ 到 $t=T_{\\text{end}}$ 的完整协同仿真。\n- 在仿真过程中，监控状态的幅值 $|x(t)|$。如果它超过一个预定义的大阈值（例如 $10^6$），则系统在该 $h$ 值下被声明为不稳定，并且成本被视为无穷大。\n- 如果仿真完成且未出现不稳定，则计算总成本 $J(h)$。\n\n在评估所有 $h$ 值之后，选择对应于最小有限成本的那个作为最优时域 $h^\\star$。如果所有仿真都不稳定，则对于给定的参数不存在解，结果为“非数值”（nan）。",
            "answer": "```python\nimport numpy as np\n\ndef state_update(x_start, u, a, b, dt):\n    \"\"\"\n    Calculates the exact state of the LTI system after a time step dt\n    with constant input u.\n    \"\"\"\n    if dt = 0:\n        return x_start\n    \n    # Handle the case where a is close to zero to avoid division errors.\n    if abs(a)  1e-9:\n        return x_start + b * u * dt\n    else:\n        eadt = np.exp(a * dt)\n        return eadt * x_start + (b / a) * (eadt - 1) * u\n\ndef cost_integral(t_start, t_end, x_start, u, a, b, r0):\n    \"\"\"\n    Calculates the exact integral of the squared error (r0 - x(t))^2\n    over the interval [t_start, t_end].\n    \"\"\"\n    dt = t_end - t_start\n    if dt = 0:\n        return 0.0\n\n    if abs(a)  1e-9:\n        # e(t) = r0 - (x_start + b*u*(t-t_start))\n        # Let tau = t-t_start. e(tau) = (r0 - x_start) - b*u*tau\n        # Integrate (C1 - C2*tau)^2 dtau from 0 to dt\n        c1 = r0 - x_start\n        c2 = b * u\n        term1 = c1**2 * dt\n        term2 = -c1 * c2 * dt**2\n        term3 = (c2**2 / 3.0) * dt**3\n        return term1 + term2 + term3\n    else:\n        x_ss = -b * u / a\n        c_a = r0 - x_ss\n        c_b = -(x_start - x_ss)\n\n        eadt = np.exp(a * dt)\n        \n        term1 = c_a**2 * dt\n        term2 = (2 * c_a * c_b / a) * (eadt - 1)\n        \n        # Handle the case where a is close to zero for the 2a term.\n        # This case is already handled by the outer if, but for robustness:\n        if abs(2 * a)  1e-9:\n             # Taylor expansion of (exp(2*a*dt)-1)/(2a) -> dt\n             term3 = c_b**2 * dt\n        else:\n             e2adt = np.exp(2 * a * dt)\n             term3 = (c_b**2 / (2 * a)) * (e2adt - 1)\n        \n        return term1 + term2 + term3\n\ndef run_simulation(a, b, K, Ts, tau_p, r0, Tend, h):\n    \"\"\"\n    Runs the co-simulation for a given set of parameters and prediction horizon h.\n    \"\"\"\n    instability_threshold = 1e6\n    \n    t = 0.0\n    x = 0.0\n    total_cost = 0.0\n    \n    # u_prev_period represents u_{k-1}. Initially, control before t=0 was 0.\n    u_prev_period = 0.0\n    \n    k = 0\n    while t  Tend:\n        t_k = k * Ts\n        \n        # --- Controller action at t_k ---\n        # 1. Prediction: predict x(t_k + h) using state x(t_k) and input u_{k-1}.\n        x_pred = state_update(x, u_prev_period, a, b, h)\n        \n        # 2. Control computation: compute u_k = K(r0 - x_pred).\n        u_k = K * (r0 - x_pred)\n        \n        # --- Plant evolution over [t_k, t_{k+1}) ---\n        \n        # Sub-interval 1: [t_k, t_k + tau_p). Plant input is u_{k-1}.\n        t_start1 = t_k\n        t_end1 = min(t_k + tau_p, Tend)\n        dt1 = t_end1 - t_start1\n        \n        if dt1 > 1e-12: # Check for non-zero interval\n            total_cost += cost_integral(t_start1, t_end1, x, u_prev_period, a, b, r0)\n            x = state_update(x, u_prev_period, a, b, dt1)\n            t = t_end1\n            \n            if abs(x) > instability_threshold:\n                return np.inf\n            if t >= Tend:\n                break\n                \n        # Sub-interval 2: [t_k + tau_p, t_{k+1}). Plant input is u_k.\n        t_start2 = t_k + tau_p\n        t_end2 = min(t_k + Ts, Tend)\n        dt2 = t_end2 - t_start2\n\n        if dt2 > 1e-12: # Check for non-zero interval\n            total_cost += cost_integral(t_start2, t_end2, x, u_k, a, b, r0)\n            x = state_update(x, u_k, a, b, dt2)\n            t = t_end2\n\n            if abs(x) > instability_threshold:\n                return np.inf\n            if t >= Tend:\n                break\n        \n        # Prepare for next iteration\n        u_prev_period = u_k\n        k += 1\n            \n    return total_cost\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Test cases: (a, b, K, Ts, tau_p, r0, Tend)\n    test_cases = [\n        (-2.0, 1.0, 3.0, 0.02, 0.006, 1.0, 2.0),\n        (-1.0, 1.0, 2.0, 0.01, 0.0, 1.0, 1.0),\n        (-1.5, 1.0, 2.5, 0.02, 0.018, 1.0, 2.0),\n        (-0.5, 1.0, 1.0, 0.05, 0.01, 1.0, 4.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, K, Ts, tau_p, r0, Tend = case\n        \n        # Create a grid of h values to search over.\n        # Use 101 points for adequate resolution.\n        if tau_p == 0.0:\n            h_values = np.array([0.0])\n        else:\n            h_values = np.linspace(0.0, tau_p, 101)\n        \n        costs = []\n        stable_h = []\n\n        for h in h_values:\n            cost = run_simulation(a, b, K, Ts, tau_p, r0, Tend, h)\n            if not np.isinf(cost):\n                costs.append(cost)\n                stable_h.append(h)\n        \n        if not stable_h:\n            results.append('nan')\n        else:\n            min_cost_idx = np.argmin(costs)\n            h_star = stable_h[min_cost_idx]\n            # Format to 3 decimal places. f-string formatting handles rounding.\n            results.append(f\"{h_star:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}