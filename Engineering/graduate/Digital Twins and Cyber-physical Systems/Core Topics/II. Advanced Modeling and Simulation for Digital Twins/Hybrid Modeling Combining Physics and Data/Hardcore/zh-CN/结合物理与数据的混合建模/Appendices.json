{
    "hands_on_practices": [
        {
            "introduction": "在构建混合模型时，一个核心的挑战是如何确保数据驱动的组件（如神经网络）能够遵守已知的物理定律，例如边界条件。本练习探讨了两种主流策略：一种是通过巧妙的架构设计来“硬性”施加约束，确保模型输出在任何情况下都满足边界条件；另一种是“软性”方法，即在损失函数中加入惩罚项来引导模型学习这些约束。通过这个练习 ，你将深入理解这两种方法的原理差异及其对模型优化的影响。",
            "id": "4226906",
            "problem": "一维导热棒的数字孪生（DT）是一个代表性的信息物理系统（CPS），它对空间域 $x \\in [0,1]$ 上的稳态温度场 $u(x)$ 进行建模。该温度场必须满足 Dirichlet 边界条件 $u(0) = 0$ 和 $u(1) = 1$，以及一个本问题无需考虑的物理残差。您正在比较两种混合建模策略，这两种策略通过人工神经网络（ANN）结合物理和数据来表示解的未知分量。\n\n策略 A（通过约束架构进行硬强制）：使用形式为 $u_{\\mathrm{c}}(x;\\theta) = g(x) + s(x)\\,N(x;\\theta)$ 的试验解，其中 $g(x)$ 是一个满足边界条件的固定函数，$s(x)$ 是一个满足 $s(0) = 0$ 和 $s(1) = 0$ 的固定函数，$N(x;\\theta)$ 是一个参数为 $\\theta$ 的人工神经网络。\n\n策略 B（通过损失惩罚进行软强制）：使用一个无约束的人工神经网络 $u_{\\mathrm{u}}(x;\\theta)$，并通过边界惩罚项\n$$\nL_{\\mathrm{bc}}(\\theta) = \\lambda \\left[ \\left(u_{\\mathrm{u}}(0;\\theta) - 0\\right)^{2} + \\left(u_{\\mathrm{u}}(1;\\theta) - 1\\right)^{2} \\right],\n$$\n在损失中惩罚边界违规，其中 $\\lambda > 0$ 是一个固定的标量权重。\n\n对于策略 A，令 $g(x) = x$ 且 $s(x) = x(1-x)$。对于策略 B，采用一个显式的无约束人工神经网络拟设 $u_{\\mathrm{u}}(x;\\theta) = \\theta_{1}\\,\\tanh\\!\\left(\\theta_{2}\\,x\\right)$，其参数向量为 $\\theta = (\\theta_{1},\\theta_{2})$。\n\n任务：\n- 使用边界条件的基本定义以及 $s(0)=0$ 和 $s(1)=0$ 的性质，解释为什么策略 A 对所有 $\\theta$ 值都能强制满足边界条件。\n- 从 $L_{\\mathrm{bc}}(\\theta)$ 的定义和梯度的链式法则出发，针对给定的拟设 $u_{\\mathrm{u}}(x;\\theta) = \\theta_{1}\\,\\tanh\\!\\left(\\theta_{2}\\,x\\right)$，为策略 B 推导精确的解析梯度 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta)$。将您的最终答案表示为关于 $\\lambda$、$\\theta_{1}$ 和 $\\theta_{2}$ 的单个闭式行向量。请勿代入数值。\n- 基于约束优化和平滑惩罚方法的第一性原理，简要讨论策略 A 和 B 在可行性附近的优化景观有何不同。\n\n您的最终答案必须是策略 B 的梯度向量，以单个闭式解析表达式给出。请使用 $\\mathrm{pmatrix}$ 环境将梯度表示为行矩阵。无需四舍五入，也无需单位。",
            "solution": "所述问题在科学上是合理的、适定的和自洽的。它描述了在物理信息机器学习中强制施加边界条件的两种常用技术之间的标准比较：通过架构构造的硬强制和通过损失函数中惩罚项的软强制。所有必要的定义和函数都已提供，任务是数学原理的直接应用。因此，该问题是有效的，可以提供解答。\n\n该问题要求完成三个不同的任务：解释为什么策略 A 满足边界条件，推导策略 B 的边界损失梯度，以及简要讨论由此产生的优化景观。\n\n首先，我们来分析策略 A，它使用试验解 $u_{\\mathrm{c}}(x;\\theta) = g(x) + s(x)\\,N(x;\\theta)$。问题指明函数 $g(x)$ 必须满足 Dirichlet 边界条件，而函数 $s(x)$ 在边界上必须为零。给定的边界条件是 $u(0)=0$ 和 $u(1)=1$。\n对于策略 A，我们给定 $g(x)=x$ 和 $s(x)=x(1-x)$。让我们验证这些辅助函数是否满足其要求。\n对于 $g(x)$，我们有 $g(0)=0$ 和 $g(1)=1$，因此它正确地满足了边界条件。\n对于 $s(x)$，我们有 $s(0)=0(1-0)=0$ 和 $s(1)=1(1-1)=0$，因此它正确地在边界处为零。\n\n现在，我们在边界 $x=0$ 和 $x=1$ 处评估试验解 $u_{\\mathrm{c}}(x;\\theta)$：\n在 $x=0$ 处：\n$$u_{\\mathrm{c}}(0;\\theta) = g(0) + s(0)\\,N(0;\\theta)$$\n代入值 $g(0)=0$ 和 $s(0)=0$：\n$$u_{\\mathrm{c}}(0;\\theta) = 0 + (0) \\cdot N(0;\\theta) = 0$$\n此结果与神经网络输出 $N(0;\\theta)$ 的值无关，因此对任何参数向量 $\\theta$ 都成立。\n\n在 $x=1$ 处：\n$$u_{\\mathrm{c}}(1;\\theta) = g(1) + s(1)\\,N(1;\\theta)$$\n代入值 $g(1)=1$ 和 $s(1)=0$：\n$$u_{\\mathrm{c}}(1;\\theta) = 1 + (0) \\cdot N(1;\\theta) = 1$$\n此结果也与 $N(1;\\theta)$ 的值无关，对任何参数向量 $\\theta$ 都成立。\n因此，通过其本身的构造，策略 A 中的试验解 $u_{\\mathrm{c}}(x;\\theta)$ 对神经网络参数 $\\theta$ 的所有可能选择都严格强制满足 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=1$。\n\n接下来，我们处理策略 B 并推导边界损失函数 $L_{\\mathrm{bc}}(\\theta)$ 的梯度。参数向量为 $\\theta = (\\theta_1, \\theta_2)$。梯度是一个行向量，由 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta) = \\begin{pmatrix} \\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_1}  \\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_2} \\end{pmatrix}$ 给出。\n边界损失定义为：\n$$L_{\\mathrm{bc}}(\\theta) = \\lambda \\left[ \\left(u_{\\mathrm{u}}(0;\\theta) - 0\\right)^{2} + \\left(u_{\\mathrm{u}}(1;\\theta) - 1\\right)^{2} \\right]$$\n无约束人工神经网络的具体拟设为 $u_{\\mathrm{u}}(x;\\theta) = \\theta_{1}\\,\\tanh(\\theta_{2}\\,x)$。\n\n首先，在边界 $x=0$ 和 $x=1$ 处评估该拟设：\n$$u_{\\mathrm{u}}(0;\\theta) = \\theta_{1}\\,\\tanh(\\theta_{2} \\cdot 0) = \\theta_{1}\\,\\tanh(0) = 0$$\n$$u_{\\mathrm{u}}(1;\\theta) = \\theta_{1}\\,\\tanh(\\theta_{2} \\cdot 1) = \\theta_{1}\\,\\tanh(\\theta_{2})$$\n将这些代入损失函数可简化表达式：\n$$L_{\\mathrm{bc}}(\\theta) = \\lambda \\left[ (0)^{2} + (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)^{2} \\right] = \\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)^{2}$$\n\n现在，我们使用链式法则计算关于 $\\theta_1$ 和 $\\theta_2$ 的偏导数。\n对于 $\\theta_1$：\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_1} = \\lambda \\cdot 2 (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\frac{\\partial}{\\partial \\theta_1}(\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)$$\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_1} = 2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\tanh(\\theta_{2})$$\n\n对于 $\\theta_2$：\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_2} = \\lambda \\cdot 2 (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\frac{\\partial}{\\partial \\theta_2}(\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)$$\n我们需要 $\\tanh(z)$ 的导数，即 $\\frac{d}{dz}\\tanh(z) = \\frac{1}{\\cosh^2(z)}$。应用链式法则：\n$$\\frac{\\partial}{\\partial \\theta_2}(\\theta_{1}\\,\\tanh(\\theta_{2})) = \\theta_1 \\cdot \\frac{1}{\\cosh^2(\\theta_2)}$$\n将此代回 $L_{\\mathrm{bc}}$ 的偏导数中：\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_2} = 2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\frac{\\theta_1}{\\cosh^2(\\theta_2)}$$\n\n结合这两个分量，我们得到梯度向量 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta)$：\n$$\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta) = \\begin{pmatrix} 2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)\\tanh(\\theta_{2})  2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)\\frac{\\theta_1}{\\cosh^2(\\theta_2)} \\end{pmatrix}$$\n\n最后，我们简要讨论两种策略在优化景观上的差异。\n在策略 A 中，边界条件的满足是一个硬约束，通过架构强制执行。$\\theta$ 的整个参数空间映射到一个函数空间，其中所有函数相对于边界条件都是可行的。优化算法由物理残差损失（未指定，但假定存在）驱动，在这个可行子空间内进行搜索。优化景观完全由物理损失决定，优化器永远不会被引导去纠正边界违规，因为不可能发生违规。\n\n相比之下，策略 B 通过惩罚方法采用软约束。$\\theta$ 的参数空间映射到一个更大的函数空间，其中大部分是不可行的（即违反边界条件）。边界损失 $L_{\\mathrm{bc}}(\\theta)$ 在总损失景观中创建了一个惩罚“井”或“谷”。此惩罚项的最小值（在 $L_{\\mathrm{bc}}=0$ 时）定义了参数空间中的可行区域。总损失景观是物理损失和此惩罚项的叠加。对于任何有限的惩罚权重 $\\lambda$，总损失的全局最小值很可能是一个边界条件仅被近似满足的点，这代表了在满足物理和满足边界之间的一种折衷。在可行区域附近，惩罚项的梯度 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta)$ 主导搜索方向，将参数拉向满足边界条件的方向。这可能会引入陡峭的梯度和潜在的数值刚度，与策略 A 相比，使优化问题更具挑战性，因为在策略 A 中，搜索被内在地限制在可行集内。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2\\lambda (\\theta_1 \\tanh(\\theta_2) - 1) \\tanh(\\theta_2)  2\\lambda (\\theta_1 \\tanh(\\theta_2) - 1) \\frac{\\theta_1}{\\cosh^2(\\theta_2)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "将物理原理融入模型不仅限于静态约束，更关键的是要保证动态过程的物理属性，例如能量耗散的非负性。这个练习  将带你构建一个单自由度系统的混合模型，其中物理结构（质量和刚度）已知，而一个与速度相关的未知摩擦项则需要从数据中学习。你将通过实施非负最小二乘法来估计摩擦系数，从而从结构上保证模型满足能量耗散定律。",
            "id": "4226933",
            "problem": "考虑一个单自由度信息物理系统，其物理装置和数字孪生共享一个混合模型，该模型将基于物理的结构与数据驱动的摩擦力耦合起来。假设该装置是一个位于线性弹簧上的质点，其阻尼未知且与速度相关。其纵向运动由牛顿第二运动定律和胡克定律描述。其控制物理原理是：合力等于质量乘以加速度。用 $x(t)$ 表示位置（单位：米），$v(t)$ 表示速度（单位：米每秒），$a(t)$ 表示加速度（单位：米每平方秒），$u(t)$ 表示外部驱动力（单位：牛顿），$m$ 表示质量（单位：千克），$k$ 表示线性刚度（单位：牛顿每米），$F_{\\mathrm{fric}}(t)$ 表示摩擦力（单位：牛顿）。基本方程为：\n$$ m \\, a(t) = u(t) - k \\, x(t) - F_{\\mathrm{fric}}(t). $$\n为确保物理上一致的非负能量耗散，我们将摩擦力表示为一个类粘性项，其有效摩擦系数取决于速率（速度大小），因此\n$$ F_{\\mathrm{fric}}(t) = c\\big(|v(t)|\\big)\\, v(t), \\quad c\\big(|v(t)|\\big) \\ge 0, $$\n这会产生瞬时功率耗散\n$$ P_{\\mathrm{diss}}(t) = F_{\\mathrm{fric}}(t)\\, v(t) \\ge 0. $$\n我们采用以下混合建模方案：结构模型（$m$ 和 $k$）从物理学中已知，而有效摩擦系数 $c\\big(|v|\\big)$ 是使用保持正性的最小参数基从数据中学习得到的。具体来说，令\n$$ c\\big(|v|\\big) = \\alpha_0 + \\alpha_1 |v|, $$\n其中未知系数 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$ 将从时间序列数据和物理方程中推断出来。学习目标是在 $\\alpha_0$ 和 $\\alpha_1$ 的非负约束下，找到能最小化测量的外部力 $u(t)$ 与混合模型预测的力之间失配的 $\\alpha_0$ 和 $\\alpha_1$，从而保证 $P_{\\mathrm{diss}}(t) \\ge 0$。对于粘性摩擦随速度增加的润滑接触，该建模假设在科学上是现实的。\n\n您的任务是实现一个程序，该程序：\n- 为指定参数生成合成数据 $(x(t), v(t), a(t), u(t))$，方法是使用已知的运动剖面激励系统，从物理原理计算设计信号，并使用非负最小二乘法（NNLS，即 Non-Negative Least Squares）估计 $(\\alpha_0,\\alpha_1)$。\n- 计算均方根速率\n$$ v_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} v(t_i)^2}, $$\n并报告此速率下的标量有效摩擦系数，\n$$ c_{\\mathrm{eff}} = \\alpha_0 + \\alpha_1 \\, v_{\\mathrm{rms}}, $$\n以 $\\mathrm{N\\cdot s/m}$ 为单位表示。\n- 通过检查所有样本 $t_i$ 的\n$$ P_{\\mathrm{diss}}(t_i) = \\big(\\alpha_0 v(t_i) + \\alpha_1 |v(t_i)| v(t_i)\\big)\\, v(t_i) \\ge 0 $$\n来验证整个数据集上耗散的正性。如果每个样本都满足不等式（在浮点运算范围内，由于系数的非负性和二次非负性，此处计算是精确的），则布尔值应为真，否则为假。\n\n程序应为每个测试用例实现以下数据生成协议：\n- 时间样本 $t_i = i \\, \\Delta t$，其中 $i = 0,1,\\dots,N-1$，并指定 $N$ 和 $\\Delta t$（单位：秒）。\n- 运动剖面 $x(t) = X_0 \\sin(\\omega t)$，其中 $X_0$ 的单位是米，角频率 $\\omega$ 的单位是弧度每秒。则 $v(t) = X_0 \\omega \\cos(\\omega t)$ 且 $a(t) = -X_0 \\omega^2 \\sin(\\omega t)$。\n- 真实摩擦系数 $(\\alpha_0^{\\mathrm{true}}, \\alpha_1^{\\mathrm{true}})$ 产生摩擦力 $F_{\\mathrm{fric}}^{\\mathrm{true}}(t) = \\alpha_0^{\\mathrm{true}} v(t) + \\alpha_1^{\\mathrm{true}} |v(t)| v(t)$。\n- 测量的驱动力为 $u(t) = m a(t) + k x(t) + F_{\\mathrm{fric}}^{\\mathrm{true}}(t) + \\eta(t)$，其中 $\\eta(t)$ 是附加的零均值高斯噪声（单位：牛顿），使用给定的标准差和每个测试用例的固定随机种子生成，以确保可复现性。\n\n估计协议：\n- 使用物理方程，重新整理测量方程以分离出摩擦力的贡献：\n$$ b(t) = u(t) - m a(t) - k x(t) = \\alpha_0 v(t) + \\alpha_1 |v(t)| v(t). $$\n- 通过求解在 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$ 约束下最小化残差平方和的 NNLS 问题，从样本 $\\{b(t_i), v(t_i)\\}_{i=1}^N$ 中估计 $(\\alpha_0,\\alpha_1)$。\n\n单位和输出规范：\n- 质量 $m$ 的单位为 $\\mathrm{kg}$，刚度 $k$ 的单位为 $\\mathrm{N/m}$，位置 $x$ 的单位为 $\\mathrm{m}$，速度 $v$ 的单位为 $\\mathrm{m/s}$，加速度 $a$ 的单位为 $\\mathrm{m/s^2}$，力 $u$ 的单位为 $\\mathrm{N}$，摩擦系数 $\\alpha_0$ 的单位为 $\\mathrm{N\\cdot s/m}$，$\\alpha_1$ 的单位为 $\\mathrm{N\\cdot s^2/m^2}$，以及 $c_{\\mathrm{eff}}$ 的单位为 $\\mathrm{N\\cdot s/m}$。角度单位为弧度。输出中不出现百分比。\n- 对于每个测试用例，程序应输出一个列表 $[c_{\\mathrm{eff}}, \\mathrm{flag}]$，其中 $c_{\\mathrm{eff}}$ 是一个浮点数（单位 $\\mathrm{N\\cdot s/m}$），$\\mathrm{flag}$ 是一个布尔值，指示是否所有样本都满足 $P_{\\mathrm{diss}}(t_i) \\ge 0$。\n- 您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，例如：$[[c_1,\\mathrm{flag}_1],[c_2,\\mathrm{flag}_2],[c_3,\\mathrm{flag}_3]]$。\n\n测试套件：\n- 用例 1（正常路径）：$m = 2.0$, $k = 5.0$, $X_0 = 0.15$, $\\omega = 3.0$, $\\Delta t = 0.01$, $N = 1000$, $\\alpha_0^{\\mathrm{true}} = 0.8$, $\\alpha_1^{\\mathrm{true}} = 0.3$, 噪声标准差 $= 0.05$ 牛顿，随机种子 $= 42$。\n- 用例 2（边界条件：纯粘性）：$m = 1.2$, $k = 8.0$, $X_0 = 0.08$, $\\omega = 2.5$, $\\Delta t = 0.01$, $N = 800$, $\\alpha_0^{\\mathrm{true}} = 1.0$, $\\alpha_1^{\\mathrm{true}} = 0.0$, 噪声标准差 $= 0.02$ 牛顿，随机种子 $= 123$。\n- 用例 3（边缘情况：接近零的速度）：$m = 3.5$, $k = 4.0$, $X_0 = 0.02$, $\\omega = 1.5$, $\\Delta t = 0.01$, $N = 600$, $\\alpha_0^{\\mathrm{true}} = 0.5$, $\\alpha_1^{\\mathrm{true}} = 0.1$, 噪声标准差 $= 0.01$ 牛顿，随机种子 $= 7$。\n\n您的实现必须是确定性的，使用指定的种子，并严格遵守最终的输出格式。",
            "solution": "该问题要求为一个单自由度信息物理系统估计摩擦参数。该系统由一个物理装置（表示为位于刚度为 $k$ 的线性弹簧上的质点 $m$）及其数字孪生组成。解决方案采用一种混合模型，该模型将已知的基于物理的结构与数据驱动的摩擦力分量相结合。\n\n质点的运动控制方程源自牛顿第二定律：\n$$ m \\, a(t) = u(t) - k \\, x(t) - F_{\\mathrm{fric}}(t) $$\n其中 $x(t)$、$v(t)$ 和 $a(t)$ 分别是质点的位置、速度和加速度。项 $u(t)$ 代表外部驱动力，$F_{\\mathrm{fric}}(t)$ 是摩擦力。\n\n摩擦力采用混合方法建模。该模型结构受物理启发，确保摩擦力耗散的瞬时功率 $P_{\\mathrm{diss}}(t) = F_{\\mathrm{fric}}(t)v(t)$ 始终为非负。这通过将摩擦力定义为以下形式来实现：\n$$ F_{\\mathrm{fric}}(t) = c\\big(|v(t)|\\big)\\, v(t) $$\n其中有效摩擦系数 $c\\big(|v(t)|\\big)$ 是速率 $|v(t)|$ 的非负函数。数据驱动部分是该系数的参数化形式，需要从数据中学习：\n$$ c\\big(|v(t)|\\big) = \\alpha_0 + \\alpha_1 |v(t)| $$\n参数 $\\alpha_0$ 和 $\\alpha_1$ 未知，必须进行估计。为确保 $P_{\\mathrm{diss}}(t) = (\\alpha_0 + \\alpha_1 |v(t)|)v(t)^2 \\ge 0$，我们必须强制执行约束条件 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$。\n\n为了估计 $\\alpha_0$ 和 $\\alpha_1$，我们首先重新排列控制方程，以分离出包含未知数的项。这在可测量量和参数之间建立了一个线性关系：\n$$ u(t) - m \\, a(t) - k \\, x(t) = \\alpha_0 v(t) + \\alpha_1 |v(t)| v(t) $$\n该方程构成了线性回归问题的基础。我们定义一个目标变量 $b(t) = u(t) - m \\, a(t) - k \\, x(t)$。给定一组 $N$ 个时间序列测量值 $(x(t_i), v(t_i), a(t_i), u(t_i))$（其中 $i=0, \\dots, N-1$），我们可以构建一个线性方程组：\n$$ \\mathbf{b} \\approx \\mathbf{A} \\boldsymbol{\\alpha} $$\n其中 $\\mathbf{b}$ 是一个大小为 $N$ 的列向量，其元素为 $b(t_i)$；$\\boldsymbol{\\alpha}$ 是参数的列向量 $[\\alpha_0, \\alpha_1]^T$；$\\mathbf{A}$ 是一个 $N \\times 2$ 的设计矩阵，其行是 $[v(t_i), |v(t_i)|v(t_i)]$。近似符号 $\\approx$ 表示 $u(t)$ 中存在测量噪声。\n\n估计任务是在物理约束 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$ 下，找到能够最小化残差平方和 $||\\mathbf{A}\\boldsymbol{\\alpha} - \\mathbf{b}||_2^2$ 的向量 $\\boldsymbol{\\alpha}$。这是一个非负最小二乘法（NNLS）问题。它可以使用标准优化例程（如 `scipy.optimize.nnls`）高效求解。\n\n对于每个测试用例，总体算法流程如下：\n1.  **数据生成**：创建一个合成数据集。\n    -   生成一个时间向量 $t$，包含 $N$ 个样本，时间步长为 $\\Delta t$。\n    -   给定一个正弦运动剖面 $x(t) = X_0 \\sin(\\omega t)$。速度 $v(t)$ 和加速度 $a(t)$ 通过解析微分得到。\n    -   使用给定的真实参数 $(\\alpha_0^{\\mathrm{true}}, \\alpha_1^{\\mathrm{true}})$ 计算真实的摩擦力 $F_{\\mathrm{fric}}^{\\mathrm{true}}(t)$。\n    -   通过计算 $m a(t) + k x(t) + F_{\\mathrm{fric}}^{\\mathrm{true}}(t)$ 并添加具有指定标准差和固定随机种子的零均值高斯噪声来合成“测量”的驱动力 $u(t)$，以确保可复现性。\n\n2.  **参数估计**：\n    -   从生成的数据 $(x, v, a, u)$ 和已知的系统参数 $(m, k)$ 构建目标向量 $\\mathbf{b}$ 和设计矩阵 $\\mathbf{A}$。\n    -   求解 NNLS 问题以获得估计参数 $\\hat{\\alpha}_0$ 和 $\\hat{\\alpha}_1$。\n\n3.  **输出计算**：\n    -   在时间序列上计算均方根速率：$v_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} v(t_i)^2}$。\n    -   计算此速率下的有效摩擦系数：$c_{\\mathrm{eff}} = \\hat{\\alpha}_0 + \\hat{\\alpha}_1 v_{\\mathrm{rms}}$。\n    -   对所有时间样本验证耗散功率 $P_{\\mathrm{diss}}(t_i) = (\\hat{\\alpha}_0 + \\hat{\\alpha}_1 |v(t_i)|) v(t_i)^2 \\ge 0$ 的非负性。由于 NNLS 保证 $\\hat{\\alpha}_0 \\ge 0$ 和 $\\hat{\\alpha}_1 \\ge 0$，并且 $v(t_i)^2 \\ge 0$ 和 $|v(t_i)| \\ge 0$，因此在数学上保证此条件成立。布尔标志用于确认这一理论属性。\n\n4.  **格式化**：将每个用例的最终结果（一个包含 $c_{\\mathrm{eff}}$ 和布尔标志的列表）格式化为字符串。然后将这些字符串聚合为指定的最终列表格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Solves the hybrid modeling problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path\n        (2.0, 5.0, 0.15, 3.0, 0.01, 1000, 0.8, 0.3, 0.05, 42),\n        # Case 2: boundary condition (purely viscous)\n        (1.2, 8.0, 0.08, 2.5, 0.01, 800, 1.0, 0.0, 0.02, 123),\n        # Case 3: edge case (near-zero speeds)\n        (3.5, 4.0, 0.02, 1.5, 0.01, 600, 0.5, 0.1, 0.01, 7),\n    ]\n\n    results_list = []\n    \n    for case in test_cases:\n        m, k, X0, omega, dt, N, alpha0_true, alpha1_true, noise_std, seed = case\n\n        # 1. Generate synthetic data\n        # Time vector\n        t = np.arange(N) * dt\n        \n        # Motion profile\n        x = X0 * np.sin(omega * t)\n        v = X0 * omega * np.cos(omega * t)\n        a = -X0 * omega**2 * np.sin(omega * t)\n        \n        # True friction force\n        F_fric_true = alpha0_true * v + alpha1_true * np.abs(v) * v\n        \n        # Generate reproducible noise\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(loc=0.0, scale=noise_std, size=N)\n        \n        # Synthesize measured actuation force\n        u = m * a + k * x + F_fric_true + noise\n\n        # 2. Set up and solve the NNLS problem\n        # Target vector b(t) = u(t) - m*a(t) - k*x(t)\n        b = u - m * a - k * x\n        \n        # Design matrix A(t) = [v(t), |v(t)|v(t)]\n        A = np.vstack([v, np.abs(v) * v]).T\n        \n        # Solve for alpha = [alpha0, alpha1] using Non-Negative Least Squares\n        alpha_est, _ = nnls(A, b)\n        alpha0_est, alpha1_est = alpha_est\n\n        # 3. Calculate specified outputs\n        # Root-mean-square speed\n        v_rms = np.sqrt(np.mean(v**2))\n        \n        # Effective friction coefficient at v_rms\n        c_eff = alpha0_est + alpha1_est * v_rms\n        \n        # Verify positivity of dissipated power\n        # P_diss = (alpha0*v + alpha1*|v|*v)*v = alpha0*v^2 + alpha1*|v|*v^2\n        # Since alpha0_est, alpha1_est from NNLS are >= 0, and v^2, |v| >=0,\n        # P_diss is guaranteed to be non-negative.\n        dissipated_power = (alpha0_est * v + alpha1_est * np.abs(v) * v) * v\n        dissipation_positive_flag = np.all(dissipated_power >= 0.0)\n\n        # Append result for the current case\n        results_list.append([c_eff, dissipation_positive_flag])\n\n    # Final print statement in the exact required format.\n    # The format [[c1,flag1],[c2,flag2]] is achieved by printing the\n    # string representation of the list of lists and removing spaces.\n    print(str(results_list).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "对于由偏微分方程（PDE）描述的场模型（如流体流动或热传导），守恒律（如质量守恒、能量守恒）是其核心物理内涵。一个优秀的混合模型必须在结构上保持这些守恒性质。本练习  要求你通过数值模拟来验证，一个学习到的修正项是以“保守”的通量形式加入模型，还是以“非保守”的源项形式加入，会对系统的总质量守恒产生截然不同的影响。",
            "id": "4226924",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，该域被离散化为 $N_x$ 个宽度为 $\\Delta x = L / N_x$ 的控制体。令 $u(x,t)$ 表示一个标量场，代表信息物理系统（CPS）数字孪生中的一个守恒量密度。基于物理的基线模型是一个由连续性定律支配的线性平流偏微分方程（PDE），表示为 $\\partial_t u + \\partial_x f_p(u) = 0$，其中 $f_p(u) = c u$，$c$ 为恒定的平流速度。为了提高模型保真度，引入了一个数据驱动的学习校正项。该混合模型为以下两种情况之一：\n- 守恒校正：存在一个通量函数 $g(u)$，使得学习项以散度形式进入方程，即 $\\partial_t u + \\partial_x f_p(u) + \\partial_x g(u) = 0$。\n- 非守恒校正：学习项以源项 $s(u)$ 的形式进入方程，即 $\\partial_t u + \\partial_x f_p(u) = s(u)$。\n\n在周期性边界条件下，如果学习校正是守恒的（通量形式），那么 $u$ 在整个域上的空间积分 $M(t) = \\int_0^L u(x,t) \\, dx$ 必须随时间保持恒定。为了在离散模拟中验证此属性，我们计算总质量与其初始值之间绝对偏差的时间积分：\n$$\nI = \\int_0^T \\left| M(t) - M(0) \\right| \\, dt.\n$$\n一个近似守恒的格式将产生接近于零的 $I$ 值；我们将 $I$ 与指定的容差 $\\varepsilon$ 进行比较，以返回一个布尔判定结果。初始条件中使用的三角函数的角度单位必须是弧度。\n\n离散数值格式要求：\n- 使用有限体积法（FVM）以确保在没有源项的情况下，通量差值可以伸缩求和并保证质量守恒。对于每个索引为 $i \\in \\{0,1,\\dots,N_x-1\\}$ 的控制体，在一个时间步长 $\\Delta t$ 内，使用位于 $i+1/2$ 和 $i-1/2$ 处的面通量将 $u_i^n$ 更新为 $u_i^{n+1}$。这些面通量是物理通量与（若适用）学习通量之和。对于 $c0$ 的线性平流，物理通量使用迎风面通量，学习通量使用中心平均以保证守恒性。对于非守恒情况，在单元中心添加源项。离散格式必须遵循周期性边界条件。所有计算均不带物理单位，任何三角函数求值均使用弧度。\n\n初始条件：\n- 使用 $u(x,0) = u_0(x) = a_0 + a_1 \\sin(2 \\pi x / L)$，其中 $a_0$ 和 $a_1$ 为指定值。由于正弦项的均值为零，积分 $M(0)$ 等于 $a_0 L$。\n\n验证指标和决策规则：\n- 通过在模拟步上进行数值积分来计算 $I$ 的离散近似值：\n$$\nI \\approx \\sum_{n=1}^{N_t} \\Delta t \\, \\left| M^n - M^0 \\right|, \\quad M^n \\approx \\Delta x \\sum_{i=0}^{N_x-1} u_i^n,\n$$\n其中 $N_t$ 是时间步数。\n- 如果 $I \\le \\varepsilon$，则判定学习校正为守恒的，否则为非守恒的。程序必须为每个测试用例输出一个布尔值。\n\n测试套件和参数：\n- 以下测试涵盖了一个典型的守恒学习校正、一个非守恒源项、一个零校正边界情况以及一个粗网格边界情况场景。对于所有情况，使用 $L = 1$（无量纲）、$c  0$ 和周期性边界条件。\n\n1. 理想情况（守恒的学习通量）：\n    - $N_x = 128$，$L = 1$，$c = 1$，$\\Delta t = 0.5 \\, \\Delta x / c$，$T = 0.5$，$a_0 = 0.7$，$a_1 = 0.3$，学习通量 $g(u) = \\alpha u^3$，其中 $\\alpha = 0.2$，容差 $\\varepsilon = 10^{-10}$。\n2. 非守恒源项：\n    - $N_x = 128$，$L = 1$，$c = 1$，$\\Delta t = 0.5 \\, \\Delta x / c$，$T = 0.5$，$a_0 = 0.7$，$a_1 = 0.3$，源项 $s(u) = \\beta u$，其中 $\\beta = 0.05$，容差 $\\varepsilon = 10^{-6}$。\n3. 零学习校正（边界情况）：\n    - $N_x = 256$，$L = 1$，$c = 1$，$\\Delta t = 0.5 \\, \\Delta x / c$，$T = 0.5$，$a_0 = 0.7$，$a_1 = 0.3$，学习通量 $g(u) = \\alpha u^3$，其中 $\\alpha = 0$，容差 $\\varepsilon = 10^{-12}$。\n4. 接近 Courant–Friedrichs–Lewy (CFL) 极限的粗网格（边界情况）：\n    - $N_x = 8$，$L = 1$，$c = 1$，$\\Delta t = \\Delta x / c$，$T = 0.25$，$a_0 = 0.7$，$a_1 = 0.3$，学习通量 $g(u) = \\alpha u^3$，其中 $\\alpha = 5.0$，容差 $\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的布尔结果，形式为方括号内以逗号分隔的列表（例如，“[True,False,True,True]”）。",
            "solution": "该问题是有效的，因为它具有科学依据、问题定义清晰、客观且完整。它提出了一个计算物理领域的明确任务，与混合建模相关，这是信息物理系统研究中的一个前沿课题。该问题基于守恒定律的基本原理及其使用有限体积法（FVM）的数值求解。所有参数和数值格式都已明确定义，从而可以得到唯一且可验证的解。\n\n问题的核心是验证两种混合模型对标量场 $u(x,t)$ 的质量守恒属性。$u$ 的演化由一个偏微分方程（PDE）控制。\n该PDE的一般形式为 $\\partial_t u + \\partial_x F(u) = S(u)$，其中 $F(u)$ 是总通量，$S(u)$ 是源项。\n在本问题中，总通量是基于物理的通量 $f_p(u) = c u$ 和学习得到的校正通量 $g(u)$ 的和。源项用 $s(u)$ 表示。\n- 一个 **守恒** 模型，其校正项以通量形式出现：$F(u) = c u + g(u)$ 且 $S(u)=0$。其PDE为 $\\partial_t u + \\partial_x (c u + g(u)) = 0$。\n- 一个 **非守恒** 模型，其校正项以源项形式出现：$F(u) = c u$ 且 $S(u) = s(u)$。其PDE为 $\\partial_t u + \\partial_x (c u) = s(u)$。\n\n对于长度为 $L$ 的周期性域，质量守恒原理指出，如果控制方程是守恒的，则总质量 $M(t) = \\int_0^L u(x,t) \\, dx$ 是恒定的。这可以通过对守恒PDE在整个域上积分来证明：\n$$ \\frac{dM}{dt} = \\frac{d}{dt} \\int_0^L u \\, dx = \\int_0^L \\partial_t u \\, dx = - \\int_0^L \\partial_x F(u) \\, dx $$\n根据微积分基本定理，这变为：\n$$ \\frac{dM}{dt} = - [F(u(L,t)) - F(u(0,t))] $$\n由于周期性边界条件，$u(L,t) = u(0,t)$，因此 $F(u(L,t)) = F(u(0,t))$。这导致 $\\frac{dM}{dt} = 0$，意味着 $M(t)$ 是恒定的。\n如果存在源项 $S(u)$，则 $\\frac{dM}{dt} = \\int_0^L S(u) \\, dx$，该值通常不为零，因此质量不守恒。\n\n我们将实现一个有限体积法（FVM）格式来数值求解该PDE。对于宽度为 $\\Delta x$ 的控制体 $i$，其半离散FVM形式为：\n$$ \\frac{du_i}{dt} = - \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) + S_i $$\n其中 $u_i$ 是 $u$ 的单元平均值，$F_{i\\pm1/2}$ 是单元面上的数值通量，$S_i$ 是单元平均源项。使用前向欧拉法在一个时间步长 $\\Delta t$ 上进行时间积分：\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) + \\Delta t S_i^n $$\n问题指定了数值通量：\n- 物理通量 $f_p(u) = cu$ ($c0$)：使用迎风格式，因此 $f_{p, i+1/2} = f_p(u_i) = c u_i$。\n- 学习通量 $g(u)$：使用中心平均，因此 $g_{i+1/2} = \\frac{g(u_i) + g(u_{i+1})}{2}$。\n- 面 $i+1/2$ 处的总通量：$F_{i+1/2} = c u_i + \\frac{g(u_i) + g(u_{i+1})}{2}$。\n- 单元 $i$ 处的源项是 $S_i = s(u_i)$。\n\n对于周期性域，FVM的一个关键特性是，如果没有源项，离散总质量 $M^n = \\Delta x \\sum_{i=0}^{N_x-1} u_i^n$ 是精确守恒的。这是因为将更新方程对所有单元 $i$ 求和，在周期性边界条件下，通量差值会形成一个伸缩和，其总和为零：$\\sum_{i=0}^{N_x-1} (F_{i+1/2} - F_{i-1/2}) = 0$。因此，$\\sum_i u_i^{n+1} = \\sum_i u_i^n$，意味着 $M^{n+1} = M^n$。\n\n验证过程涉及计算积分 $I = \\int_0^T |M(t) - M(0)| \\, dt$，其离散近似为 $I \\approx \\sum_{n=1}^{N_t} \\Delta t |M^n - M^0|$。如果格式是守恒的，$M^n$ 应在浮点精度范围内等于 $M^0$，从而使 $I$ 非常接近于零。如果 $I \\le \\varepsilon$，则模型被视为守恒。\n\n实现将通过创建一个仿真函数来进行，该函数接受每个测试用例的参数。该函数将：\n1. 初始化网格和初始条件 $u(x,0) = a_0 + a_1 \\sin(2 \\pi x / L)$。\n2. 计算初始质量 $M^0$。\n3. 进行时间步循环，直到达到最终时间 $T$。在每一步中：\n   a. 计算所有单元面上的数值通量和单元中心的源项，使用 `numpy.roll` 处理周期性边界。\n   b. 使用FVM公式更新解向量 $u$。\n   c. 计算当前质量 $M^n$，并将 $\\Delta t |M^n - M^0|$ 加到累积积分 $I$ 中。\n4. 循环结束后，将最终的 $I$ 与给定的容差 $\\varepsilon$ 进行比较，以返回一个布尔结果。\n\n此过程将应用于指定的四个测试用例。对于守恒情况（1、3、4），预期结果为 `True`，对于非守恒情况（2），预期结果为 `False`，因为FVM格式的数值守恒性与情况4中可能出现的数值稳定性问题无关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def run_simulation(Nx, L, c, cfl, T, a0, a1, alpha, beta, epsilon):\n        \"\"\"\n        Runs a single simulation case for the hybrid model validation.\n\n        Args:\n            Nx (int): Number of control volumes.\n            L (float): Domain length.\n            c (float): Advection speed.\n            cfl (float): CFL number to determine the time step.\n            T (float): Total simulation time.\n            a0 (float): Constant part of initial condition.\n            a1 (float): Amplitude of sine part of initial condition.\n            alpha (float): Coefficient for the learned conservative flux g(u).\n            beta (float): Coefficient for the learned non-conservative source s(u).\n            epsilon (float): Tolerance for the conservation integral.\n\n        Returns:\n            bool: True if the model is conservative (I = epsilon), False otherwise.\n        \"\"\"\n        # 1. Setup discretization and grid\n        dx = L / Nx\n        dt = cfl * dx / c\n        \n        # 2. Initialize the solution field u\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        u = a0 + a1 * np.sin(2 * np.pi * x_centers / L)\n        \n        # 3. Define learned correction functions\n        def g(u_vec):\n            if alpha == 0.0:\n                return 0.0\n            return alpha * u_vec**3\n            \n        def s(u_vec):\n            if beta == 0.0:\n                return 0.0\n            return beta * u_vec\n            \n        # 4. Calculate initial mass and initialize validation integral\n        m0 = np.sum(u) * dx\n        integral_I = 0.0\n        \n        current_time = 0.0\n        \n        # 5. Time-stepping loop\n        while current_time  T:\n            dt_step = min(dt, T - current_time)\n            \n            # --- FVM Update Step ---\n            u_prev = np.roll(u, 1)\n            u_next = np.roll(u, -1)\n            \n            # Physics flux (fp): upwind for c > 0\n            fp_plus = c * u\n            fp_minus = c * u_prev\n            \n            # Learned flux (g): centered average\n            if alpha != 0.0:\n                g_vals = g(u)\n                g_next_vals = np.roll(g_vals, -1)\n                fg_plus = (g_vals + g_next_vals) * 0.5\n                fg_minus = (np.roll(g_vals, 1) + g_vals) * 0.5\n            else:\n                fg_plus = 0.0\n                fg_minus = 0.0\n\n            # Total numerical flux at faces\n            F_plus = fp_plus + fg_plus\n            F_minus = fp_minus + fg_minus\n            \n            # Learned source term (S)\n            S = s(u)\n            \n            # Update solution using Forward Euler FVM\n            u = u - (dt_step / dx) * (F_plus - F_minus) + dt_step * S\n            # --- End of FVM Update Step ---\n            \n            current_time += dt_step\n            \n            # 6. Update the conservation validation integral I\n            m_current = np.sum(u) * dx\n            integral_I += dt_step * np.abs(m_current - m0)\n            \n        # 7. Return the boolean verdict\n        return integral_I = epsilon\n\n    # The test cases specified in the problem statement\n    # Note: for case 4, the problem description implies a CFL number of 1.0.\n    test_case_params = [\n        # 1. Happy path (conservative learned flux)\n        {'Nx': 128, 'L': 1.0, 'c': 1.0, 'cfl': 0.5, 'T': 0.5, 'a0': 0.7, 'a1': 0.3, 'alpha': 0.2, 'beta': 0.0, 'epsilon': 1e-10},\n        # 2. Non-conservative source\n        {'Nx': 128, 'L': 1.0, 'c': 1.0, 'cfl': 0.5, 'T': 0.5, 'a0': 0.7, 'a1': 0.3, 'alpha': 0.0, 'beta': 0.05, 'epsilon': 1e-6},\n        # 3. Zero learned correction (edge case)\n        {'Nx': 256, 'L': 1.0, 'c': 1.0, 'cfl': 0.5, 'T': 0.5, 'a0': 0.7, 'a1': 0.3, 'alpha': 0.0, 'beta': 0.0, 'epsilon': 1e-12},\n        # 4. Coarse grid near CFL limit (boundary case)\n        {'Nx': 8, 'L': 1.0, 'c': 1.0, 'cfl': 1.0, 'T': 0.25, 'a0': 0.7, 'a1': 0.3, 'alpha': 5.0, 'beta': 0.0, 'epsilon': 1e-8},\n    ]\n\n    # Convert dt specifications into CFL numbers for the runner function\n    cfl_values = [0.5, 0.5, 0.5, 1.0]\n    for i, case in enumerate(test_case_params):\n        dx = case['L'] / case['Nx']\n        # The problem statement for dt is ambiguous, but can be inferred as CFL.\n        # dt = 0.5 dx/c -> cfl=0.5\n        # dt = dx/c -> cfl=1.0\n        # The cfl parameter in my runner is consistent with this.\n        pass\n\n    results = []\n    for case in test_case_params:\n        result = run_simulation(**case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}