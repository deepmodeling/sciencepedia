{
    "hands_on_practices": [
        {
            "introduction": "The foundation of modern physics-based simulation, particularly the Finite Element Method, rests on the concept of the weak or variational formulation. This practice guides you through the essential process of converting a strong-form partial differential equation into its weak form, a crucial step that lowers continuity requirements and naturally incorporates certain boundary conditions. By deriving the bilinear and linear forms for a canonical diffusion problem, you will build the mathematical machinery required for robust numerical modeling .",
            "id": "4235369",
            "problem": "Consider a steady diffusion problem representative of a physics-based model within a digital twin of a heterogeneous plate. Let $\\Omega \\subset \\mathbb{R}^2$ be a bounded Lipschitz domain with boundary partitioned into disjoint, measurable parts $\\Gamma_{D}$ and $\\Gamma_{N}$ such that $\\partial \\Omega = \\Gamma_{D} \\cup \\Gamma_{N}$ and $\\Gamma_{D}$ has positive measure. The field $u$ satisfies the Partial Differential Equation (PDE)\n$$\n-\\nabla \\cdot \\big(k \\nabla u\\big) = f \\quad \\text{in } \\Omega,\n$$\nwith mixed boundary conditions\n$$\nu = 0 \\quad \\text{on } \\Gamma_{D}, \\qquad k \\nabla u \\cdot n = g_{N} \\quad \\text{on } \\Gamma_{N},\n$$\nwhere $k \\in L^{\\infty}(\\Omega)$ satisfies $k(x) \\ge k_{\\min} > 0$ almost everywhere, $f \\in L^{2}(\\Omega)$, $g_{N} \\in L^{2}(\\Gamma_{N})$, and $n$ denotes the outward unit normal on $\\partial \\Omega$.\n\nStarting from conservation of flux and Fourier’s law $q = -k \\nabla u$, and using the divergence theorem, derive the weak (variational) formulation by:\n- Stating the appropriate trial and test spaces built from the Sobolev space $H^{1}(\\Omega)$,\n- Identifying the bilinear form and the linear functional that arise from the weak formulation, and\n- Specifying the energy norm used to assess coercivity of the bilinear form on the test space.\n\nThen, for the concrete setting $\\Omega = [0,1] \\times [0,1]$, $\\Gamma_{D} = \\{(x,y) \\in \\partial \\Omega : x = 0 \\text{ or } y = 0\\}$, $\\Gamma_{N} = \\partial \\Omega \\setminus \\Gamma_{D}$, and heterogeneous conductivity $k(x,y) = 1 + x$, evaluate the energy norm of the test function $v(x,y) = x^{2} y$. Express your final answer as a single exact analytical expression. Do not round your result.",
            "solution": "The problem statement is a well-posed and scientifically grounded problem in the field of partial differential equations, specifically concerning the weak formulation of an elliptic boundary value problem. All provided data, conditions, and definitions are mathematically consistent and sufficient for deriving a unique solution. The problem is valid.\n\nThe derivation of the weak (variational) formulation begins with the strong form of the Partial Differential Equation (PDE):\n$$\n-\\nabla \\cdot (k \\nabla u) = f \\quad \\text{in } \\Omega\n$$\nWe multiply this equation by an arbitrary test function $v$ and integrate over the domain $\\Omega$:\n$$\n-\\int_{\\Omega} v (\\nabla \\cdot (k \\nabla u)) \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega\n$$\nThe core of the method is to use a vector calculus identity, which is a generalization of integration by parts known as the divergence theorem or Green's first identity. For a scalar function $v$ and a vector field $\\mathbf{F}$, this identity is $\\int_{\\Omega} v (\\nabla \\cdot \\mathbf{F}) \\, d\\Omega = \\int_{\\partial \\Omega} v (\\mathbf{F} \\cdot n) \\, dS - \\int_{\\Omega} \\nabla v \\cdot \\mathbf{F} \\, d\\Omega$. We identify the flux vector field as $\\mathbf{F} = k \\nabla u$. Applying this identity to the left-hand side of our integrated equation yields:\n$$\n-\\left( \\int_{\\partial \\Omega} v (k \\nabla u \\cdot n) \\, dS - \\int_{\\Omega} \\nabla v \\cdot (k \\nabla u) \\, d\\Omega \\right) = \\int_{\\Omega} f v \\, d\\Omega\n$$\nRearranging the terms, we get:\n$$\n\\int_{\\Omega} k \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega + \\int_{\\partial \\Omega} v (k \\nabla u \\cdot n) \\, dS\n$$\nThe boundary $\\partial \\Omega$ is partitioned into a Dirichlet part $\\Gamma_{D}$ and a Neumann part $\\Gamma_{N}$. We can split the boundary integral accordingly:\n$$\n\\int_{\\partial \\Omega} v (k \\nabla u \\cdot n) \\, dS = \\int_{\\Gamma_D} v (k \\nabla u \\cdot n) \\, dS + \\int_{\\Gamma_N} v (k \\nabla u \\cdot n) \\, dS\n$$\nThe solution $u$ is sought in a space of functions that satisfy the essential (Dirichlet) boundary condition, $u = 0$ on $\\Gamma_D$. The test functions $v$ are chosen from the corresponding vector space of functions that are zero on this part of the boundary. Thus, for any test function $v$, we have $v=0$ on $\\Gamma_D$. This causes the first boundary integral to vanish:\n$$\n\\int_{\\Gamma_D} v (k \\nabla u \\cdot n) \\, dS = 0\n$$\nOn the Neumann boundary $\\Gamma_N$, we apply the natural boundary condition given in the problem, $k \\nabla u \\cdot n = g_N$. This simplifies the second boundary integral:\n$$\n\\int_{\\Gamma_N} v (k \\nabla u \\cdot n) \\, dS = \\int_{\\Gamma_N} v g_N \\, dS\n$$\nSubstituting these results back, we arrive at the weak formulation: Find $u$ such that for all valid test functions $v$, the following holds:\n$$\n\\int_{\\Omega} k \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega + \\int_{\\Gamma_N} g_N v \\, dS\n$$\nHaving derived this equation, we can now address the specific items requested.\n\n**Trial and Test Spaces:**\nThe mathematical setting for this problem is the Sobolev space $H^1(\\Omega) = \\{w \\in L^2(\\Omega) : \\nabla w \\in [L^2(\\Omega)]^2\\}$, which consists of square-integrable functions whose gradients are also square-integrable. To incorporate the homogeneous Dirichlet boundary condition, we define the trial and test space $V$ as a subspace of $H^1(\\Omega)$:\n$$\nV = \\{w \\in H^1(\\Omega) : w|_{\\Gamma_D} = 0\\}\n$$\nwhere the condition $w|_{\\Gamma_D} = 0$ is understood in the sense of traces. The weak formulation is to find a trial function $u \\in V$ such that the integral equation holds for all test functions $v \\in V$.\n\n**Bilinear and Linear Forms:**\nThe weak formulation has the abstract structure $a(u,v) = L(v)$, where $a(\\cdot,\\cdot)$ is a bilinear form and $L(\\cdot)$ is a linear functional.\n- The **bilinear form** $a: V \\times V \\to \\mathbb{R}$ is given by:\n$$\na(u, v) = \\int_{\\Omega} k \\nabla u \\cdot \\nabla v \\, d\\Omega\n$$\n- The **linear functional** $L: V \\to \\mathbb{R}$ is given by:\n$$\nL(v) = \\int_{\\Omega} f v \\, d\\Omega + \\int_{\\Gamma_N} g_N v \\, dS\n$$\n\n**Energy Norm:**\nThe coercivity of the bilinear form, $a(v,v) \\ge C \\|v\\|_{H^1(\\Omega)}^2$ for some constant $C > 0$, ensures the existence and uniqueness of the solution via the Lax-Milgram theorem. This property is typically assessed using a norm induced by the bilinear form itself. The **energy norm** on the space $V$ is defined as $\\|v\\|_E = \\sqrt{a(v,v)}$. Explicitly, for a function $v \\in V$, its squared energy norm is:\n$$\n\\|v\\|_E^2 = a(v,v) = \\int_{\\Omega} k (\\nabla v \\cdot \\nabla v) \\, d\\Omega = \\int_{\\Omega} k |\\nabla v|^2 \\, d\\Omega\n$$\nThe fact that $\\Gamma_D$ has positive measure allows for the use of the Friedrichs-Poincaré inequality, which guarantees that this energy norm is indeed a norm on $V$ and is equivalent to the standard $H^1(\\Omega)$ norm on $V$.\n\n**Evaluation for the Concrete Setting:**\nWe are asked to evaluate the energy norm of the specific test function $v(x,y) = x^2 y$ for the given concrete setting.\n- Domain: $\\Omega = [0,1] \\times [0,1]$.\n- Conductivity: $k(x,y) = 1 + x$.\n- Test function: $v(x,y) = x^2 y$.\nFirst, we verify that $v$ is a valid test function. The Dirichlet boundary is $\\Gamma_D = \\{(x,y) \\in \\partial \\Omega : x = 0 \\text{ or } y = 0\\}$. On the segment where $x=0$, $v(0,y) = 0^2 y = 0$. On the segment where $y=0$, $v(x,0) = x^2 \\cdot 0 = 0$. The function $v$ also belongs to $H^1(\\Omega)$. Thus, $v \\in V$.\n\nWe proceed to calculate the energy norm $\\|v\\|_E$. First, we compute the gradient of $v$:\n$$\n\\nabla v = \\left( \\frac{\\partial v}{\\partial x}, \\frac{\\partial v}{\\partial y} \\right) = \\left( 2xy, x^2 \\right)\n$$\nNext, we find the squared magnitude of the gradient:\n$$\n|\\nabla v|^2 = (2xy)^2 + (x^2)^2 = 4x^2y^2 + x^4\n$$\nNow, we compute the squared energy norm by integrating $k|\\nabla v|^2$ over $\\Omega$:\n$$\n\\|v\\|_E^2 = \\int_{\\Omega} k(x,y) |\\nabla v|^2 \\, d\\Omega = \\int_{0}^{1} \\int_{0}^{1} (1+x)(4x^2y^2 + x^4) \\, dx \\, dy\n$$\nWe expand the integrand:\n$$\n(1+x)(4x^2y^2 + x^4) = 4x^2y^2 + x^4 + 4x^3y^2 + x^5\n$$\nWe now perform the double integration. It is convenient to integrate with respect to $y$ first:\n$$\n\\int_{0}^{1} (4x^2y^2 + x^4 + 4x^3y^2 + x^5) \\, dy = \\left[ 4x^2 \\frac{y^3}{3} + x^4 y + 4x^3 \\frac{y^3}{3} + x^5 y \\right]_{y=0}^{y=1}\n$$\n$$\n= \\left( \\frac{4x^2}{3} + x^4 + \\frac{4x^3}{3} + x^5 \\right) - 0 = x^5 + x^4 + \\frac{4}{3}x^3 + \\frac{4}{3}x^2\n$$\nNow we integrate this result with respect to $x$ from $0$ to $1$:\n$$\n\\|v\\|_E^2 = \\int_{0}^{1} \\left( x^5 + x^4 + \\frac{4}{3}x^3 + \\frac{4}{3}x^2 \\right) dx = \\left[ \\frac{x^6}{6} + \\frac{x^5}{5} + \\frac{4}{3}\\frac{x^4}{4} + \\frac{4}{3}\\frac{x^3}{3} \\right]_{x=0}^{x=1}\n$$\n$$\n= \\left[ \\frac{x^6}{6} + \\frac{x^5}{5} + \\frac{x^4}{3} + \\frac{4x^3}{9} \\right]_{x=0}^{x=1} = \\left( \\frac{1}{6} + \\frac{1}{5} + \\frac{1}{3} + \\frac{4}{9} \\right) - 0\n$$\nTo sum the fractions, we find a common denominator, which is $\\text{lcm}(6,5,3,9) = 90$:\n$$\n\\|v\\|_E^2 = \\frac{15}{90} + \\frac{18}{90} + \\frac{30}{90} + \\frac{40}{90} = \\frac{15+18+30+40}{90} = \\frac{103}{90}\n$$\nThe energy norm is the square root of this value:\n$$\n\\|v\\|_E = \\sqrt{\\frac{103}{90}}\n$$\nThis expression can be simplified by rationalizing the denominator:\n$$\n\\sqrt{\\frac{103}{90}} = \\frac{\\sqrt{103}}{\\sqrt{90}} = \\frac{\\sqrt{103}}{\\sqrt{9 \\cdot 10}} = \\frac{\\sqrt{103}}{3\\sqrt{10}} = \\frac{\\sqrt{103}\\sqrt{10}}{3\\sqrt{10}\\sqrt{10}} = \\frac{\\sqrt{1030}}{30}\n$$\nThis is the final exact analytical expression for the energy norm of the given test function.",
            "answer": "$$\n\\boxed{\\frac{\\sqrt{1030}}{30}}\n$$"
        },
        {
            "introduction": "Building upon the weak formulation, this exercise transitions from theory to a complete computational implementation for a structural dynamics problem. You will discretize an Euler-Bernoulli beam, assemble the global stiffness and mass matrices, and impose various boundary conditions to analyze its vibrational characteristics. This practice is essential for understanding how to construct and solve models that predict the dynamic response of structures, a core task in designing and monitoring cyber-physical systems .",
            "id": "4235351",
            "problem": "Consider a one-dimensional Euler–Bernoulli beam model used within a Digital Twin for a Cyber-Physical System (CPS), in which a structural subsystem is represented by a physics-based finite element discretization. The goal is to assemble the global stiffness and mass matrices for a mesh of beam elements and to impose essential and natural boundary conditions consistently in the weak form. The task culminates in computing the smallest positive natural angular frequency for several boundary condition scenarios.\n\nUse the following fundamental base:\n- Newton’s second law of motion applied to continua and the Euler–Bernoulli kinematic assumption that cross-sections remain orthogonal to the neutral axis, leading to the governing equation for free transverse vibrations, $$E I \\, w''''(x,t) + \\rho A \\, \\ddot{w}(x,t) = 0,$$ where $w(x,t)$ is the transverse displacement, $E$ is the Young’s modulus (in $\\mathrm{Pa}$), $I$ is the second moment of area (in $\\mathrm{m^4}$), $\\rho$ is the mass density (in $\\mathrm{kg/m^3}$), and $A$ is the cross-sectional area (in $\\mathrm{m^2}$).\n- The weak form derived from the principle of virtual work or Hamilton’s principle, invoking suitable test functions and integration by parts, which reveals how essential and natural boundary conditions arise as constraints on trial functions and as boundary terms, respectively.\n\nDiscretize the beam domain of length $L$ into $N_{\\mathrm{e}}$ uniform two-node Euler–Bernoulli beam elements. Each node has two Degrees of Freedom (DOF): the transverse displacement $w$ (in $\\mathrm{m}$) and the rotation $\\theta = \\partial w / \\partial x$ (in radians). Use cubic Hermite interpolation for the element field approximation. Assemble the global stiffness matrix $K$ and the global mass matrix $M$ by summing the element contributions over the mesh. Do not introduce any artificial numerical damping or lumped mass approximations; use the consistent mass matrix derived from the kinetic energy.\n\nImpose boundary conditions as follows:\n- Essential (Dirichlet) boundary conditions are enforced on the global system by restricting the corresponding DOFs (e.g., removing rows and columns associated with constrained DOFs). Examples: clamped support applies $w = 0$ and $\\theta = 0$ at the support; simply supported applies $w = 0$ at the support while the bending moment condition is natural.\n- Natural (Neumann-type) boundary conditions enter through boundary terms in the weak form and, for free vibration without external boundary tractions, result in zero bending moment $M = E I \\, w''$ and zero shear force $V = - E I \\, w'''$ at free boundaries if not otherwise specified. For simply supported ends, the bending moment vanishes naturally.\n\nSolve the generalized eigenvalue problem $$K \\, \\phi = \\lambda \\, M \\, \\phi,$$ where $\\lambda = \\omega^2$ and $\\omega$ is the natural angular frequency (in $\\mathrm{rad/s}$). For each test case, compute the smallest positive $\\omega$.\n\nUse the following test suite, with all quantities in the International System of Units (SI):\n- Case $1$ (Cantilever, steel): $E = 210 \\times 10^9$, $I = 8 \\times 10^{-6}$, $\\rho = 7800$, $A = 3 \\times 10^{-3}$, $L = 2$, $N_{\\mathrm{e}} = 8$. Boundary conditions: clamped at $x = 0$ (essential $w(0)=0$, $\\theta(0)=0$), free at $x = L$ (natural $M(L)=0$, $V(L)=0$).\n- Case $2$ (Simply supported, steel): same $E$, $I$, $\\rho$, $A$, $L$, $N_{\\mathrm{e}}$ as Case $1$. Boundary conditions: simply supported at both $x=0$ and $x=L$ (essential $w(0)=0$, $w(L)=0$), with natural vanishing bending moment at both ends.\n- Case $3$ (Fixed–fixed, steel): same $E$, $I$, $\\rho$, $A$, $L$, $N_{\\mathrm{e}}$ as Case $1$. Boundary conditions: clamped at both $x=0$ and $x=L$ (essential $w(0)=0$, $\\theta(0)=0$, $w(L)=0$, $\\theta(L)=0$).\n- Case $4$ (Simply supported, aluminum, coarse mesh): $E = 70 \\times 10^9$, $I = 1 \\times 10^{-6}$, $\\rho = 2700$, $A = 5 \\times 10^{-4}$, $L = 1$, $N_{\\mathrm{e}} = 2$. Boundary conditions: simply supported at both ends.\n\nAngles must be treated in radians. Express the final angular frequencies in $\\mathrm{rad/s}$, each rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is the smallest positive natural angular frequency for the corresponding case (as a float in $\\mathrm{rad/s}$, rounded to six decimal places).",
            "solution": "The user-provided problem is assessed to be **valid**. It is scientifically grounded in the principles of structural mechanics, specifically Euler-Bernoulli beam theory and the Finite Element Method (FEM). The problem is well-posed, with all necessary parameters, boundary conditions, and material properties defined for each test case, ensuring a unique and meaningful solution can be obtained. The language is objective and unambiguous. We may therefore proceed to a solution.\n\nThe problem requires the computation of the fundamental natural angular frequency, $\\omega$, for a one-dimensional beam under various boundary conditions. This is achieved by solving the generalized eigenvalue problem derived from the finite element discretization of the governing partial differential equation for free transverse vibrations:\n$$\nE I \\frac{\\partial^4 w}{\\partial x^4}(x,t) + \\rho A \\frac{\\partial^2 w}{\\partial t^2}(x,t) = 0\n$$\nwhere $E$ is Young's modulus, $I$ is the second moment of area, $\\rho$ is the mass density, $A$ is the cross-sectional area, and $w(x,t)$ is the transverse displacement. Assuming harmonic motion, $w(x,t) = \\phi(x) e^{i\\omega t}$, the equation becomes an ordinary differential equation:\n$$\nE I \\frac{d^4 \\phi}{dx^4}(x) - \\rho A \\omega^2 \\phi(x) = 0\n$$\nThe Finite Element Method is based on the weak (variational) form of this equation. By multiplying by a test function $\\delta \\phi(x)$ and integrating over the domain length $L$, and then applying integration by parts twice, we obtain the weak form. This process naturally separates the terms into those related to strain energy and kinetic energy, and also reveals the essential (Dirichlet) and natural (Neumann) boundary conditions.\n\nThe domain of length $L$ is discretized into $N_{\\mathrm{e}}$ uniform finite elements, each of length $l_e = L/N_{\\mathrm{e}}$. For a two-node Euler-Bernoulli beam element, each node has two degrees of freedom (DOFs): a transverse displacement, $w$, and a rotation, $\\theta = dw/dx$. The nodal displacement vector for an element is $\\mathbf{d}_e = [w_i, \\theta_i, w_j, \\theta_j]^T$. The displacement field within the element is approximated using cubic Hermite shape functions $\\mathbf{N}(\\xi) = [N_1(\\xi), N_2(\\xi), N_3(\\xi), N_4(\\xi)]$, where $\\xi = x/l_e$ is the natural coordinate varying from $0$ to $1$:\n$$\nw(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}_e\n$$\nFrom the weak form, the element stiffness matrix, $\\mathbf{k}_e$, is derived from the strain energy contribution:\n$$\n\\mathbf{k}_e = \\int_{0}^{l_e} E I \\left( \\frac{d^2\\mathbf{N}}{dx^2} \\right)^T \\left( \\frac{d^2\\mathbf{N}}{dx^2} \\right) dx = \\frac{EI}{l_e^3}\n\\begin{pmatrix}\n12 & 6 l_e & -12 & 6 l_e \\\\\n6 l_e & 4 l_e^2 & -6 l_e & 2 l_e^2 \\\\\n-12 & -6 l_e & 12 & -6 l_e \\\\\n6 l_e & 2 l_e^2 & -6 l_e & 4 l_e^2\n\\end{pmatrix}\n$$\nThe consistent mass matrix, $\\mathbf{M}_e$, is derived from the kinetic energy contribution:\n$$\n\\mathbf{M}_e = \\int_{0}^{l_e} \\rho A \\mathbf{N}^T \\mathbf{N} dx = \\frac{\\rho A l_e}{420}\n\\begin{pmatrix}\n156 & 22 l_e & 54 & -13 l_e \\\\\n22 l_e & 4 l_e^2 & 13 l_e & -3 l_e^2 \\\\\n54 & 13 l_e & 156 & -22 l_e \\\\\n-13 l_e & -3 l_e^2 & -22 l_e & 4 l_e^2\n\\end{pmatrix}\n$$\nThe global stiffness matrix $\\mathbf{K}$ and global mass matrix $\\mathbf{M}$ are constructed by assembling the contributions from all $N_{\\mathrm{e}}$ elements. The total number of DOFs for the system of $N_e+1$ nodes is $N_{dof} = 2(N_e+1)$. The assembly process maps the local DOFs of each element to their corresponding global DOFs.\n\nThis procedure results in the global system of equations for free vibration, which is a generalized eigenvalue problem:\n$$\n\\mathbf{K} \\boldsymbol{\\phi} = \\lambda \\mathbf{M} \\boldsymbol{\\phi}\n$$\nwhere $\\boldsymbol{\\phi}$ is the global vector of nodal displacements and rotations, and $\\lambda = \\omega^2$ are the eigenvalues, representing the squares of the natural angular frequencies.\n\nEssential boundary conditions, such as those for clamped or simply supported ends, are constraints on the displacement or rotation DOFs. These are imposed by removing the rows and columns corresponding to the constrained DOFs from the global matrices $\\mathbf{K}$ and $\\mathbf{M}$. This yields a reduced, but still symmetric and positive-definite, system:\n$$\n\\mathbf{K}_{red} \\boldsymbol{\\phi}_{red} = \\lambda \\mathbf{M}_{red} \\boldsymbol{\\phi}_{red}\n$$\nThis reduced system is then solved numerically. For each case, we identify the constrained DOFs:\n- **Case 1 (Cantilever):** Clamped at $x=0$ (node $0$). DOFs for $w(0)$ and $\\theta(0)$ are constrained. These are global DOFs $0$ and $1$.\n- **Case 2 (Simply supported):** Simply supported at $x=0$ (node $0$) and $x=L$ (node $N_e$). DOFs for $w(0)$ and $w(L)$ are constrained. These are global DOFs $0$ and $2N_e$.\n- **Case 3 (Fixed-fixed):** Clamped at $x=0$ (node $0$) and $x=L$ (node $N_e$). DOFs for $w(0)$, $\\theta(0)$, $w(L)$, and $\\theta(L)$ are constrained. These are global DOFs $0$, $1$, $2N_e$, and $2N_e+1$.\n- **Case 4 (Simply supported):** Same as Case 2. DOFs $0$ and $2N_e$ are constrained.\n\nBy solving the eigenvalue problem for the reduced system, we obtain a set of eigenvalues $\\lambda_i$. The smallest positive eigenvalue, $\\lambda_{min}$, corresponds to the fundamental mode of vibration. The smallest positive natural angular frequency is then calculated as $\\omega = \\sqrt{\\lambda_{min}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_element_matrices(E, I, rho, A, le):\n    \"\"\"\n    Computes the element stiffness and consistent mass matrices for an Euler-Bernoulli beam.\n\n    Args:\n        E (float): Young's modulus.\n        I (float): Second moment of area.\n        rho (float): Mass density.\n        A (float): Cross-sectional area.\n        le (float): Element length.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the (4, 4) element stiffness matrix\n                                       and the (4, 4) element mass matrix.\n    \"\"\"\n    # Element stiffness matrix (ke)\n    c1 = E * I / le**3\n    ke = c1 * np.array([\n        [12, 6 * le, -12, 6 * le],\n        [6 * le, 4 * le**2, -6 * le, 2 * le**2],\n        [-12, -6 * le, 12, -6 * le],\n        [6 * le, 2 * le**2, -6 * le, 4 * le**2]\n    ])\n\n    # Element consistent mass matrix (me)\n    c2 = rho * A * le / 420\n    me = c2 * np.array([\n        [156, 22 * le, 54, -13 * le],\n        [22 * le, 4 * le**2, 13 * le, -3 * le**2],\n        [54, 13 * le, 156, -22 * le],\n        [-13 * le, -3 * le**2, -22 * le, 4 * le**2]\n    ])\n\n    return ke, me\n\ndef solve_beam_vibration(E, I, rho, A, L, Ne, bc_type):\n    \"\"\"\n    Assembles global matrices, applies boundary conditions, and solves for the\n    smallest positive natural angular frequency.\n\n    Args:\n        E (float): Young's modulus.\n        I (float): Second moment of area.\n        rho (float): Mass density.\n        A (float): Cross-sectional area.\n        L (float): Beam length.\n        Ne (int): Number of elements.\n        bc_type (str): Type of boundary condition ('cantilever', 'simply-supported', 'fixed-fixed').\n\n    Returns:\n        float: The smallest positive natural angular frequency in rad/s.\n    \"\"\"\n    # 1. Element properties and matrices\n    le = L / Ne\n    ke, me = get_element_matrices(E, I, rho, A, le)\n\n    # 2. Assembly of global matrices\n    num_nodes = Ne + 1\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    M = np.zeros((num_dofs, num_dofs))\n\n    for i in range(Ne):\n        # Global DOF indices for element i (connecting nodes i and i+1)\n        dof_indices = np.array([2*i, 2*i + 1, 2*(i+1), 2*(i+1) + 1])\n        # Add element matrices to global matrices using np.ix_ for indexing\n        K[np.ix_(dof_indices, dof_indices)] += ke\n        M[np.ix_(dof_indices, dof_indices)] += me\n\n    # 3. Apply boundary conditions\n    all_dofs = np.arange(num_dofs)\n    constrained_dofs = []\n\n    if bc_type == 'cantilever':\n        # Clamped at x=0 (node 0): displacement and rotation are zero.\n        constrained_dofs = [0, 1]\n    elif bc_type == 'simply-supported':\n        # Simply supported at x=0 (node 0) and x=L (node Ne): displacements are zero.\n        constrained_dofs = [0, 2 * Ne]\n    elif bc_type == 'fixed-fixed':\n        # Clamped at x=0 (node 0) and x=L (node Ne): displacements and rotations are zero.\n        constrained_dofs = [0, 1, 2 * Ne, 2 * Ne + 1]\n\n    active_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    \n    K_red = K[np.ix_(active_dofs, active_dofs)]\n    M_red = M[np.ix_(active_dofs, active_dofs)]\n\n    # 4. Solve the generalized eigenvalue problem\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, _ = eigh(K_red, M_red)\n\n    # 5. Find the smallest positive eigenvalue (lambda = omega^2)\n    # Filter out any non-positive values that might arise from numerical error\n    positive_eigenvalues = eigenvalues[eigenvalues > 1e-6]\n    \n    if len(positive_eigenvalues) == 0:\n        # This should not occur for the given non-trivial boundary conditions\n        return 0.0\n\n    lambda_min = positive_eigenvalues[0]\n\n    # 6. Calculate the smallest positive natural angular frequency (omega)\n    omega_min = np.sqrt(lambda_min)\n\n    return omega_min\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (Cantilever, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'cantilever'},\n        # Case 2 (Simply supported, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'simply-supported'},\n        # Case 3 (Fixed-fixed, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'fixed-fixed'},\n        # Case 4 (Simply supported, aluminum, coarse mesh)\n        {'E': 70e9, 'I': 1e-6, 'rho': 2700, 'A': 5e-4, 'L': 1.0, 'Ne': 2, 'bc_type': 'simply-supported'},\n    ]\n\n    results = []\n    for params in test_cases:\n        omega = solve_beam_vibration(**params)\n        # Round and format as a string with 6 decimal places\n        results.append(f\"{omega:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many advanced digital twins must capture the interplay between different physical domains, such as the interaction between a fluid and a structure. This practice delves into the complexities of multiphysics coupling by modeling a simplified fluid-structure interaction (FSI) system using a partitioned approach. You will explore the critical concepts of numerical stability, the added-mass effect, and the use of under-relaxation to achieve convergence in a staggered simulation scheme .",
            "id": "4235330",
            "problem": "Consider a one-dimensional piston-like Fluid–Structure Interaction (FSI) model formulated in the Arbitrary Lagrangian–Eulerian (ALE) frame, where a rigid interface of a linear elastic structure of mass $m_s$ and stiffness $k_s$ moves in the axial direction of a fluid column of length $L$ and cross-sectional area $A$. The fluid has density $\\rho_f$ and is assumed incompressible with spatially uniform axial acceleration induced by the interface motion. Let the interface displacement at the end of the current time step be $u_{n+1}$, and let the previous two displacements be $u_n$ and $u_{n-1}$, respectively. The time step size is $\\Delta t$. The external fluid loading is a uniform far-field pressure $p_0$ producing a net interface force $F_{\\text{ext}} = p_0 A$. The fluid added-mass in this configuration is $M_a = \\rho_f A L$. The interface acceleration is discretized by the standard centered approximation $a(u_{n+1}) = \\dfrac{u_{n+1} - 2 u_n + u_{n-1}}{\\Delta t^2}$ in the ALE frame with mesh motion matching the piston.\n\nThe Dirichlet–Neumann staggered partitioned coupling proceeds in subiterations $k = 0,1,2,\\dots$ per time step as follows: given an interface displacement guess $u^{k}$, solve the fluid subproblem with the Dirichlet boundary condition provided by $u^{k}$ to obtain the interface traction $F_f^{k}$; then solve the structure subproblem with this traction as a Neumann boundary to obtain an updated interface displacement $u_{\\text{struct}}^{k+1}$. Under-relaxation is applied to stabilize the subiterations by setting $u^{k+1} = u^{k} + \\omega \\left(u_{\\text{struct}}^{k+1} - u^{k}\\right)$, with the relaxation factor $\\omega \\in (0,1]$. The subiterations are repeated $m$ times per time step. The coupling is deemed converged when $|u^{m} - u^{\\star}| \\le \\varepsilon$, where $u^{\\star}$ is the monolithic solution of the coupled problem at the end of the time step, and $\\varepsilon$ is a prescribed tolerance.\n\nStarting only from fundamental laws, derive a complete algorithm for one time step that:\n- models the fluid traction based on the uniform fluid added-mass $M_a$ and the ALE acceleration approximation,\n- models the structure dynamics by Newton’s second law and linear elasticity,\n- computes the monolithic coupled solution $u^{\\star}$ for the given time step,\n- implements the Dirichlet–Neumann staggered subiterations with under-relaxation,\n- checks convergence after $m$ subiterations against $u^{\\star}$ with tolerance $\\varepsilon$.\n\nUse the following physical base:\n- Newton’s second law $F = m a$ applied to both the fluid column and the structural degree-of-freedom,\n- incompressible fluid with uniform axial acceleration in a piston-like geometry,\n- linear elasticity with stiffness $k_s$ producing a restoring force $k_s u_{n+1}$,\n- centered acceleration approximation $a(u_{n+1}) = \\dfrac{u_{n+1} - 2 u_n + u_{n-1}}{\\Delta t^2}$.\n\nUnits must be consistent in the International System of Units (SI): express all given quantities in $\\mathrm{kg}$, $\\mathrm{m}$, $\\mathrm{s}$, and $\\mathrm{Pa}$, and compute the displacement in $\\mathrm{m}$. Angles are not used in this problem. The relaxation factor must be a unitless scalar and the convergence tolerance must be a positive scalar.\n\nYour program must implement the derived algorithm and evaluate the following test suite. In all cases use $u_n = 0\\,\\mathrm{m}$ and $u_{n-1} = 0\\,\\mathrm{m}$ and tolerance $\\varepsilon = 10^{-3}\\,\\mathrm{m}$. For clarity, each test case is a tuple $(\\rho_f, A, L, m_s, k_s, \\Delta t, \\omega, m, p_0)$:\n- Test Case $1$ (happy path, light fluid, stiff structure, small time step): $(\\rho_f = 1.2\\,\\mathrm{kg/m^3}, A = 0.01\\,\\mathrm{m^2}, L = 1.0\\,\\mathrm{m}, m_s = 1.0\\,\\mathrm{kg}, k_s = 100\\,\\mathrm{N/m}, \\Delta t = 0.01\\,\\mathrm{s}, \\omega = 1.0, m = 10, p_0 = 1000\\,\\mathrm{Pa})$.\n- Test Case $2$ (moderate fluid–structure density ratio, under-relaxation and many subiterations): $(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 10.0\\,\\mathrm{kg}, k_s = 1000\\,\\mathrm{N/m}, \\Delta t = 0.1\\,\\mathrm{s}, \\omega = 1.0, m = 40, p_0 = 1000\\,\\mathrm{Pa})$.\n- Test Case $3$ (destabilized by added mass, under-relaxation insufficient): $(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 8.0\\,\\mathrm{kg}, k_s = 100\\,\\mathrm{N/m}, \\Delta t = 0.05\\,\\mathrm{s}, \\omega = 0.5, m = 50, p_0 = 1000\\,\\mathrm{Pa})$.\n- Test Case $4$ (stabilized by structural stiffness and larger time step): $(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 10.0\\,\\mathrm{kg}, k_s = 5000\\,\\mathrm{N/m}, \\Delta t = 0.2\\,\\mathrm{s}, \\omega = 1.0, m = 5, p_0 = 1000\\,\\mathrm{Pa})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases. Each result is a boolean indicating whether the coupling converged within the given tolerance after $m$ subiterations, i.e., the format must be exactly like $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$.",
            "solution": "The problem requires the derivation and implementation of a partitioned algorithm for a one-dimensional fluid-structure interaction (FSI) problem, and the validation of its convergence against a monolithic solution for several test cases. The derivation will proceed from the fundamental principles specified.\n\n### 1. Governing Equations\nLet $u(t)$ be the displacement of the solid interface at time $t$. The positive direction is taken along the axis of the fluid column. The problem involves a single time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$. We use the notation $u_{n+1}$, $u_n$, and $u_{n-1}$ for the displacements at times $t_{n+1}$, $t_n$, and $t_{n-1}$ respectively. The interface acceleration at time $t_{n+1}$ is approximated by a second-order centered difference scheme:\n$$a_{n+1} = \\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}$$\n\n#### a. Structure Dynamics\nThe structure is modeled as a linear mass-spring system. According to Newton's second law, the sum of forces on the structural mass $m_s$ equals its mass times acceleration. The forces are the elastic restoring force from the spring, $-k_s u_{n+1}$, and the force exerted by the fluid on the interface, $F_{\\text{fluid}}$.\n$$m_s a_{n+1} + k_s u_{n+1} = F_{\\text{fluid}}$$\nSubstituting the acceleration approximation, we get the discretized equation for the structure:\n$$m_s \\left(\\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u_{n+1} = F_{\\text{fluid}}$$\n\n#### b. Fluid Dynamics\nThe fluid is modeled as a rigid column of mass $M_a = \\rho_f A L$, known as the added mass. The fluid column's acceleration is identical to the interface acceleration, $a_{n+1}$, due to the incompressibility assumption and the piston-like geometry. The net force on the fluid column is the difference between the force at the interface (exerted by the structure) and the force at the far end (from the external pressure $p_0$). By Newton's third law, the force exerted by the structure on the fluid is $-F_{\\text{fluid}}$. The force from the far-field pressure is $p_0 A$. Thus, the net force on the fluid is $p_0 A - F_{\\text{fluid}}$.\n\nApplying Newton's second law to the fluid mass $M_a$:\n$$M_a a_{n+1} = p_0 A - F_{\\text{fluid}}$$\nThis equation can be rearranged to express the fluid force in terms of the system's motion and external pressure:\n$$F_{\\text{fluid}} = p_0 A - M_a a_{n+1}$$\nSubstituting the acceleration approximation:\n$$F_{\\text{fluid}} = p_0 A - M_a \\left(\\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right)$$\n\n### 2. Monolithic (Fully Coupled) Solution $u^{\\star}$\nThe monolithic solution, denoted $u^{\\star}$, is obtained by solving the fluid and structure equations simultaneously, ensuring that the displacement $u_{n+1}$ and the interface force $F_{\\text{fluid}}$ are consistent. We substitute the expression for $F_{\\text{fluid}}$ from the fluid equation into the structure equation:\n$$m_s a_{n+1} + k_s u_{n+1} = p_0 A - M_a a_{n+1}$$\nGrouping terms with acceleration $a_{n+1}$:\n$$(m_s + M_a) a_{n+1} + k_s u_{n+1} = p_0 A$$\nThis is the equation of motion for the fully coupled system. The total inertia is the sum of the structural mass and the fluid added mass, $m_s + M_a$. We now substitute the discrete approximation for acceleration, with $u_{n+1}$ replaced by $u^{\\star}$:\n$$(m_s + M_a) \\left(\\frac{u^{\\star} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u^{\\star} = p_0 A$$\nTo solve for $u^{\\star}$, we rearrange the terms:\n$$u^{\\star} \\left(\\frac{m_s + M_a}{\\Delta t^2} + k_s\\right) = p_0 A + \\frac{m_s + M_a}{\\Delta t^2}(2u_n - u_{n-1})$$\nThe monolithic solution for the displacement at the end of the time step is thus:\n$$u^{\\star} = \\frac{p_0 A + \\frac{m_s + M_a}{\\Delta t^2}(2u_n - u_{n-1})}{\\frac{m_s + M_a}{\\Delta t^2} + k_s}$$\n\n### 3. Dirichlet–Neumann Partitioned Algorithm\nThe partitioned scheme solves the fluid and structure subproblems iteratively within the time step. Let $k$ be the subiteration index.\n\n#### a. Fluid Subproblem (Dirichlet)\nGiven a guess for the interface displacement at subiteration $k$, $u_{n+1}^k$, we solve for the resulting fluid traction $F_f^k$. This is a Dirichlet problem for the fluid, as the boundary motion is prescribed. The fluid traction is defined as the total force exerted on the structure, which includes the external pressure effects transmitted through the fluid. The problem states that the fluid subproblem yields the interface traction $F_f^k$. Based on our derivation, the total force from the fluid on the structure is $F_{\\text{fluid}} = p_0 A - M_a a_{n+1}$. In the partitioned context, we define the fluid traction map as:\n$$F_f^k = p_0 A - M_a \\left(\\frac{u_{n+1}^k - 2u_n + u_{n-1}}{\\Delta t^2}\\right)$$\n\n#### b. Structure Subproblem (Neumann)\nGiven the fluid traction $F_f^k$ from the fluid solve, we solve for the structural displacement $u_{\\text{struct},n+1}^{k+1}$. This is a Neumann problem, as the boundary loading is prescribed.\n$$m_s \\left(\\frac{u_{\\text{struct},n+1}^{k+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u_{\\text{struct},n+1}^{k+1} = F_f^k$$\nSolving for $u_{\\text{struct},n+1}^{k+1}$:\n$$u_{\\text{struct},n+1}^{k+1} = \\frac{F_f^k + \\frac{m_s}{\\Delta t^2}(2u_n - u_{n-1})}{\\frac{m_s}{\\Delta t^2} + k_s}$$\n\n#### c. Under-relaxation\nTo stabilize the subiterations, especially in cases with strong added-mass effects, the updated displacement guess $u_{n+1}^{k+1}$ is computed as a weighted average of the previous guess and the new structural displacement:\n$$u_{n+1}^{k+1} = u_{n+1}^k + \\omega \\left(u_{\\text{struct},n+1}^{k+1} - u_{n+1}^k\\right) = (1-\\omega)u_{n+1}^k + \\omega u_{\\text{struct},n+1}^{k+1}$$\nwhere $\\omega \\in (0, 1]$ is the relaxation factor.\n\n### 4. Algorithm for One Time Step\nBased on the derivations above, the algorithm to be implemented is as follows:\n\n1.  **Inputs**: $\\rho_f, A, L, m_s, k_s, \\Delta t, \\omega, m, p_0$, and previous displacements $u_n, u_{n-1}$. For this problem, $u_n=0$ and $u_{n-1}=0$. The tolerance is $\\varepsilon=10^{-3}$.\n2.  **Initialization**:\n    *   Calculate added mass: $M_a = \\rho_f A L$.\n    *   Calculate external force term: $F_{\\text{ext}} = p_0 A$.\n    *   Define historical displacement term: $U_{\\text{hist}} = 2u_n - u_{n-1}$.\n3.  **Calculate Monolithic Solution**: Compute $u^{\\star}$ using its derived formula.\n$$u^{\\star} = \\frac{p_0 A + \\frac{m_s + M_a}{\\Delta t^2} U_{\\text{hist}}}{\\frac{m_s + M_a}{\\Delta t^2} + k_s}$$\n4.  **Partitioned Subiterations**:\n    *   Initialize the displacement guess: $u_{n+1}^0 = u_n$.\n    *   Loop for $k$ from $0$ to $m-1$:\n        i.  **Fluid Solve**: Compute traction $F_f^k$ using $u_{n+1}^k$.\n            $$F_f^k = F_{\\text{ext}} - M_a \\left(\\frac{u_{n+1}^k - U_{\\text{hist}}}{\\Delta t^2}\\right)$$\n        ii. **Structure Solve**: Compute $u_{\\text{struct},n+1}^{k+1}$ using $F_f^k$.\n            $$u_{\\text{struct},n+1}^{k+1} = \\frac{F_f^k + \\frac{m_s}{\\Delta t^2} U_{\\text{hist}}}{\\frac{m_s}{\\Delta t^2} + k_s}$$\n        iii. **Relaxation**: Update the displacement guess for the next subiteration.\n            $$u_{n+1}^{k+1} = (1-\\omega)u_{n+1}^k + \\omega u_{\\text{struct},n+1}^{k+1}$$\n5.  **Convergence Check**: After $m$ iterations, the final iterated solution is $u_{n+1}^m$. Check if the convergence criterion is met:\n    $$|u_{n+1}^m - u^{\\star}| \\le \\varepsilon$$\n6.  **Output**: Return `True` if the criterion is met, `False` otherwise.\nThis structured algorithm will be implemented for each provided test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_fsi_simulation(params):\n    \"\"\"\n    Solves one time step of a 1D FSI problem using a partitioned scheme\n    and checks for convergence against the monolithic solution.\n\n    Args:\n        params (tuple): A tuple containing the physical and numerical parameters:\n            (rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0, u_n, u_n_minus_1, epsilon)\n\n    Returns:\n        bool: True if the partitioned scheme converged within m iterations, False otherwise.\n    \"\"\"\n    rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0, u_n, u_n_minus_1, epsilon = params\n\n    # 1. Initialization and pre-calculations\n    # Added mass of the fluid column\n    M_a = rho_f * A * L\n    # Total effective mass of the coupled system\n    M_tot = m_s + M_a\n    # External force from far-field pressure\n    F_ext = p_0 * A\n    # Historical displacement term from previous time steps\n    U_hist = 2 * u_n - u_n_minus_1\n    \n    # Coefficients for discretized equations\n    # Inertial coefficient for the total system\n    C_M_tot_dt2 = M_tot / (delta_t**2)\n    # Inertial coefficient for the structure\n    C_ms_dt2 = m_s / (delta_t**2)\n    # Inertial coefficient for the fluid (added mass)\n    C_Ma_dt2 = M_a / (delta_t**2)\n\n    # 2. Compute the monolithic (fully coupled) solution u_star\n    # Denominator of the monolithic solution expression\n    denom_star = C_M_tot_dt2 + k_s\n    # Numerator of the monolithic solution expression\n    num_star = F_ext + C_M_tot_dt2 * U_hist\n    \n    # Handle the case where the denominator is zero to avoid division by zero\n    if denom_star == 0:\n        # This physical configuration would imply an unconstrained system,\n        # which is not expected for the given problems.\n        # But as a safeguard: If numerator is also zero, any displacement is a solution (ill-posed).\n        # If numerator is non-zero, no solution exists. In either case, it's problematic.\n        # For the purpose of this problem, let's treat this as a failure.\n        return False\n        \n    u_star = num_star / denom_star\n\n    # 3. Perform partitioned subiterations\n    # Initialize the displacement guess for the current time step n+1\n    u_k = u_n \n    \n    # Effective stiffness of the structure sub-problem\n    S_s = C_ms_dt2 + k_s\n\n    for _ in range(m):\n        # a. Fluid subproblem: Given u_k, calculate fluid traction F_f_k\n        # This is the force the fluid exerts on the structure.\n        F_f_k = F_ext - C_Ma_dt2 * (u_k - U_hist)\n\n        # b. Structure subproblem: Given F_f_k, calculate new displacement u_struct_k_plus_1\n        # Denominator is the effective stiffness S_s.\n        if S_s == 0:\n            # Another safeguard for a physically unconstrained structural subproblem.\n            return False\n            \n        u_struct_k_plus_1 = (F_f_k + C_ms_dt2 * U_hist) / S_s\n\n        # c. Under-relaxation: Update the displacement guess for the next iteration\n        u_k_plus_1 = (1.0 - omega) * u_k + omega * u_struct_k_plus_1\n        u_k = u_k_plus_1\n        \n        # Check for non-physical divergence (overflow)\n        if not np.isfinite(u_k):\n            return False\n\n    # The final iterated displacement after m subiterations\n    u_m = u_k\n    \n    # 4. Convergence check\n    # Check if the absolute difference between the final iterated solution\n    # and the monolithic solution is within the prescribed tolerance.\n    converged = abs(u_m - u_star) = epsilon\n    \n    return converged\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Common parameters for all test cases\n    u_n = 0.0  # m\n    u_n_minus_1 = 0.0  # m\n    epsilon = 1e-3  # m\n\n    # Test cases: (rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0)\n    test_cases_params = [\n        (1.2, 0.01, 1.0, 1.0, 100, 0.01, 1.0, 10, 1000),  # Case 1\n        (1000, 0.02, 0.8, 10.0, 1000, 0.1, 1.0, 40, 1000), # Case 2\n        (1000, 0.02, 0.8, 8.0, 100, 0.05, 0.5, 50, 1000), # Case 3\n        (1000, 0.02, 0.8, 10.0, 5000, 0.2, 1.0, 5, 1000),  # Case 4\n    ]\n\n    # Append common parameters to each test case tuple\n    test_cases = [params + (u_n, u_n_minus_1, epsilon) for params in test_cases_params]\n\n    results = []\n    for case in test_cases:\n        result = run_fsi_simulation(case)\n        results.append(str(result).lower()) # Convert boolean to lowercase string 'true'/'false'\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}