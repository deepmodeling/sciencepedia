{
    "hands_on_practices": [
        {
            "introduction": "物理建模的第一步通常是将连续介质的控制方程转化为可解的离散系统。本练习将带领您实践这一核心过程，我们将以经典的欧拉-伯努利梁为例，利用有限元方法（FEM）来分析其自由振动特性。通过亲手构建全局刚度矩阵 $K$ 和质量矩阵 $M$，并施加不同的边界条件，您将深入理解结构动力学建模的基本流程，并计算出决定结构动态响应的关键参数——固有频率。",
            "id": "4235351",
            "problem": "考虑一个用于信息物理系统 (CPS) 数字孪生中的一维欧拉-伯努利梁模型，其中结构子系统由基于物理的有限元离散化表示。目标是为梁单元网格组装全局刚度矩阵和质量矩阵，并在弱形式中一致地施加本质边界条件和自然边界条件。该任务最终要求计算几种边界条件情景下的最小正自然角频率。\n\n使用以下基本依据：\n- 将牛顿第二运动定律应用于连续体，并采用欧拉-伯努利运动学假设，即横截面保持与中性轴正交，从而得到自由横向振动的控制方程：$$E I \\, w''''(x,t) + \\rho A \\, \\ddot{w}(x,t) = 0,$$ 其中 $w(x,t)$ 是横向位移，$E$ 是杨氏模量 (单位 $\\mathrm{Pa}$)，$I$ 是面积二次矩 (单位 $\\mathrm{m^4}$)，$\\rho$ 是质量密度 (单位 $\\mathrm{kg/m^3}$)，$A$ 是横截面积 (单位 $\\mathrm{m^2}$)。\n- 源自虚功原理或哈密顿原理的弱形式，通过引入合适的试函数和分部积分，揭示了本质边界条件和自然边界条件如何分别作为对试函数的约束和边界项出现。\n\n将长度为 $L$ 的梁域离散为 $N_{\\mathrm{e}}$ 个均匀的双节点欧拉-伯努利梁单元。每个节点有两个自由度 (DOF)：横向位移 $w$ (单位 $\\mathrm{m}$) 和转角 $\\theta = \\partial w / \\partial x$ (单位 弧度)。使用三次 Hermite 插值进行单元场近似。通过对网格上的单元贡献求和，组装全局刚度矩阵 $K$ 和全局质量矩阵 $M$。不要引入任何人工数值阻尼或集总质量近似；使用从动能导出的一致质量矩阵。\n\n按如下方式施加边界条件：\n- 本质 (Dirichlet) 边界条件通过约束相应的自由度（例如，移除与约束自由度相关的行和列）在全局系统上强制执行。例如：固定支座在支座处施加 $w = 0$ 和 $\\theta = 0$；简支在支座处施加 $w = 0$，而弯矩条件是自然的。\n- 自然 (Neumann 型) 边界条件通过弱形式中的边界项引入，对于没有外部边界牵引力的自由振动，如果在未另行说明的情况下，会导致自由边界处的弯矩 $M = E I \\, w''$ 和剪力 $V = - E I \\, w'''$ 为零。对于简支端，弯矩自然为零。\n\n求解广义特征值问题 $$K \\, \\phi = \\lambda \\, M \\, \\phi,$$ 其中 $\\lambda = \\omega^2$，$\\omega$ 是自然角频率 (单位 $\\mathrm{rad/s}$)。对于每个测试用例，计算最小的正 $\\omega$。\n\n使用以下测试套件，所有量均采用国际单位制 (SI)：\n- 案例 $1$ (悬臂梁, 钢): $E = 210 \\times 10^9$, $I = 8 \\times 10^{-6}$, $\\rho = 7800$, $A = 3 \\times 10^{-3}$, $L = 2$, $N_{\\mathrm{e}} = 8$。边界条件：在 $x = 0$ 处固定 (本质条件 $w(0)=0$, $\\theta(0)=0$)，在 $x = L$ 处自由 (自然条件 $M(L)=0$, $V(L)=0$)。\n- 案例 $2$ (简支梁, 钢): 与案例 $1$ 相同的 $E$, $I$, $\\rho$, $A$, $L$, $N_{\\mathrm{e}}$。边界条件：在 $x=0$ 和 $x=L$ 两端均为简支 (本质条件 $w(0)=0$, $w(L)=0$)，两端的弯矩自然为零。\n- 案例 $3$ (两端固定梁, 钢): 与案例 $1$ 相同的 $E$, $I$, $\\rho$, $A$, $L$, $N_{\\mathrm{e}}$。边界条件：在 $x=0$ 和 $x=L$ 两端均固定 (本质条件 $w(0)=0$, $\\theta(0)=0$, $w(L)=0$, $\\theta(L)=0$)。\n- 案例 $4$ (简支梁, 铝, 粗网格): $E = 70 \\times 10^9$, $I = 1 \\times 10^{-6}$, $\\rho = 2700$, $A = 5 \\times 10^{-4}$, $L = 1$, $N_{\\mathrm{e}} = 2$。边界条件：两端均为简支。\n\n角度必须以弧度处理。最终的角频率以 $\\mathrm{rad/s}$ 表示，每个值四舍五入到小数点后六位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是相应案例的最小正自然角频率（浮点数，单位为 $\\mathrm{rad/s}$，四舍五入到小数点后六位）。",
            "solution": "用户提供的问题经评估为**有效**。它在科学上基于结构力学原理，特别是欧拉-伯努利梁理论和有限元方法 (FEM)。该问题是适定的，为每个测试用例定义了所有必要的参数、边界条件和材料属性，确保可以获得唯一且有意义的解。语言客观且明确。因此，我们可以着手求解。\n\n该问题要求计算一维梁在各种边界条件下的基本自然角频率 $\\omega$。这可以通过求解由自由横向振动的控制偏微分方程经过有限元离散化后得到的广义特征值问题来实现：\n$$\nE I \\frac{\\partial^4 w}{\\partial x^4}(x,t) + \\rho A \\frac{\\partial^2 w}{\\partial t^2}(x,t) = 0\n$$\n其中 $E$ 是杨氏模量，$I$ 是面积二次矩，$\\rho$ 是质量密度，$A$ 是横截面积，$w(x,t)$ 是横向位移。假设简谐运动，$w(x,t) = \\phi(x) e^{i\\omega t}$，方程变为一个常微分方程：\n$$\nE I \\frac{d^4 \\phi}{dx^4}(x) - \\rho A \\omega^2 \\phi(x) = 0\n$$\n有限元方法基于此方程的弱 (变分) 形式。通过乘以一个试函数 $\\delta \\phi(x)$ 并在域长 $L$ 上积分，然后应用两次分部积分，我们得到弱形式。这个过程自然地将各项分离为与应变能和动能相关的项，并揭示了本质 (Dirichlet) 和自然 (Neumann) 边界条件。\n\n长度为 $L$ 的域被离散为 $N_{\\mathrm{e}}$ 个均匀的有限元，每个单元长度为 $l_e = L/N_{\\mathrm{e}}$。对于一个双节点欧拉-伯努利梁单元，每个节点有两个自由度 (DOF)：横向位移 $w$ 和转角 $\\theta = dw/dx$。一个单元的节点位移向量为 $\\mathbf{d}_e = [w_i, \\theta_i, w_j, \\theta_j]^T$。单元内的位移场使用三次 Hermite 形函数 $\\mathbf{N}(\\xi) = [N_1(\\xi), N_2(\\xi), N_3(\\xi), N_4(\\xi)]$ 来近似，其中 $\\xi = x/l_e$ 是从 0 到 1 变化的自然坐标：\n$$\nw(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}_e\n$$\n从弱形式中，单元刚度矩阵 $\\mathbf{k}_e$ 由应变能贡献导出：\n$$\n\\mathbf{k}_e = \\int_{0}^{l_e} E I \\left( \\frac{d^2\\mathbf{N}}{dx^2} \\right)^T \\left( \\frac{d^2\\mathbf{N}}{dx^2} \\right) dx = \\frac{EI}{l_e^3}\n\\begin{pmatrix}\n12 & 6 l_e & -12 & 6 l_e \\\\\n6 l_e & 4 l_e^2 & -6 l_e & 2 l_e^2 \\\\\n-12 & -6 l_e & 12 & -6 l_e \\\\\n6 l_e & 2 l_e^2 & -6 l_e & 4 l_e^2\n\\end{pmatrix}\n$$\n一致质量矩阵 $\\mathbf{M}_e$ 由动能贡献导出：\n$$\n\\mathbf{M}_e = \\int_{0}^{l_e} \\rho A \\mathbf{N}^T \\mathbf{N} dx = \\frac{\\rho A l_e}{420}\n\\begin{pmatrix}\n156 & 22 l_e & 54 & -13 l_e \\\\\n22 l_e & 4 l_e^2 & 13 l_e & -3 l_e^2 \\\\\n54 & 13 l_e & 156 & -22 l_e \\\\\n-13 l_e & -3 l_e^2 & -22 l_e & 4 l_e^2\n\\end{pmatrix}\n$$\n全局刚度矩阵 $\\mathbf{K}$ 和全局质量矩阵 $\\mathbf{M}$ 是通过组装所有 $N_{\\mathrm{e}}$ 个单元的贡献来构建的。对于包含 $N_e+1$ 个节点的系统，总自由度数 (DOFs) 为 $N_{dof} = 2(N_e+1)$。组装过程将每个单元的局部自由度映射到其对应的全局自由度。\n\n这个过程产生了用于自由振动的全局方程组，这是一个广义特征值问题：\n$$\n\\mathbf{K} \\boldsymbol{\\phi} = \\lambda \\mathbf{M} \\boldsymbol{\\phi}\n$$\n其中 $\\boldsymbol{\\phi}$ 是节点位移和转角的全局向量，$\\lambda = \\omega^2$ 是特征值，代表自然角频率的平方。\n\n本质边界条件，例如固定端或简支端的边界条件，是对位移或转角自由度的约束。这些约束通过从全局矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$ 中移除与受约束自由度对应的行和列来施加。这会产生一个缩减但仍对称正定的系统：\n$$\n\\mathbf{K}_{red} \\boldsymbol{\\phi}_{red} = \\lambda \\mathbf{M}_{red} \\boldsymbol{\\phi}_{red}\n$$\n然后对这个缩减后的系统进行数值求解。对于每种情况，我们确定受约束的自由度：\n- **案例 1 (悬臂梁):** 在 $x=0$ (节点 $0$) 处固定。$w(0)$ 和 $\\theta(0)$ 的自由度受到约束。这些是全局自由度 $0$ 和 $1$。\n- **案例 2 (简支梁):** 在 $x=0$ (节点 $0$) 和 $x=L$ (节点 $N_e$) 处简支。$w(0)$ 和 $w(L)$ 的自由度受到约束。这些是全局自由度 $0$ 和 $2N_e$。\n- **案例 3 (两端固定梁):** 在 $x=0$ (节点 $0$) 和 $x=L$ (节点 $N_e$) 处固定。$w(0)$, $\\theta(0)$, $w(L)$, 和 $\\theta(L)$ 的自由度受到约束。这些是全局自由度 $0$, $1$, $2N_e$, 和 $2N_e+1$。\n- **案例 4 (简支梁):** 与案例 2 相同。自由度 $0$ 和 $2N_e$ 受到约束。\n\n通过求解缩减系统的特征值问题，我们得到一组特征值 $\\lambda_i$。最小的正特征值 $\\lambda_{min}$ 对应于振动的基频模式。然后，最小正自然角频率计算为 $\\omega = \\sqrt{\\lambda_{min}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_element_matrices(E, I, rho, A, le):\n    \"\"\"\n    Computes the element stiffness and consistent mass matrices for an Euler-Bernoulli beam.\n\n    Args:\n        E (float): Young's modulus.\n        I (float): Second moment of area.\n        rho (float): Mass density.\n        A (float): Cross-sectional area.\n        le (float): Element length.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the (4, 4) element stiffness matrix\n                                       and the (4, 4) element mass matrix.\n    \"\"\"\n    # Element stiffness matrix (ke)\n    c1 = E * I / le**3\n    ke = c1 * np.array([\n        [12, 6 * le, -12, 6 * le],\n        [6 * le, 4 * le**2, -6 * le, 2 * le**2],\n        [-12, -6 * le, 12, -6 * le],\n        [6 * le, 2 * le**2, -6 * le, 4 * le**2]\n    ])\n\n    # Element consistent mass matrix (me)\n    c2 = rho * A * le / 420\n    me = c2 * np.array([\n        [156, 22 * le, 54, -13 * le],\n        [22 * le, 4 * le**2, 13 * le, -3 * le**2],\n        [54, 13 * le, 156, -22 * le],\n        [-13 * le, -3 * le**2, -22 * le, 4 * le**2]\n    ])\n\n    return ke, me\n\ndef solve_beam_vibration(E, I, rho, A, L, Ne, bc_type):\n    \"\"\"\n    Assembles global matrices, applies boundary conditions, and solves for the\n    smallest positive natural angular frequency.\n\n    Args:\n        E (float): Young's modulus.\n        I (float): Second moment of area.\n        rho (float): Mass density.\n        A (float): Cross-sectional area.\n        L (float): Beam length.\n        Ne (int): Number of elements.\n        bc_type (str): Type of boundary condition ('cantilever', 'simply-supported', 'fixed-fixed').\n\n    Returns:\n        float: The smallest positive natural angular frequency in rad/s.\n    \"\"\"\n    # 1. Element properties and matrices\n    le = L / Ne\n    ke, me = get_element_matrices(E, I, rho, A, le)\n\n    # 2. Assembly of global matrices\n    num_nodes = Ne + 1\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    M = np.zeros((num_dofs, num_dofs))\n\n    for i in range(Ne):\n        # Global DOF indices for element i (connecting nodes i and i+1)\n        dof_indices = np.array([2*i, 2*i + 1, 2*(i+1), 2*(i+1) + 1])\n        # Add element matrices to global matrices using np.ix_ for indexing\n        K[np.ix_(dof_indices, dof_indices)] += ke\n        M[np.ix_(dof_indices, dof_indices)] += me\n\n    # 3. Apply boundary conditions\n    all_dofs = np.arange(num_dofs)\n    constrained_dofs = []\n\n    if bc_type == 'cantilever':\n        # Clamped at x=0 (node 0): displacement and rotation are zero.\n        constrained_dofs = [0, 1]\n    elif bc_type == 'simply-supported':\n        # Simply supported at x=0 (node 0) and x=L (node Ne): displacements are zero.\n        constrained_dofs = [0, 2 * Ne]\n    elif bc_type == 'fixed-fixed':\n        # Clamped at x=0 (node 0) and x=L (node Ne): displacements and rotations are zero.\n        constrained_dofs = [0, 1, 2 * Ne, 2 * Ne + 1]\n\n    active_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    \n    K_red = K[np.ix_(active_dofs, active_dofs)]\n    M_red = M[np.ix_(active_dofs, active_dofs)]\n\n    # 4. Solve the generalized eigenvalue problem\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, _ = eigh(K_red, M_red)\n\n    # 5. Find the smallest positive eigenvalue (lambda = omega^2)\n    # Filter out any non-positive values that might arise from numerical error\n    positive_eigenvalues = eigenvalues[eigenvalues > 1e-6]\n    \n    if len(positive_eigenvalues) == 0:\n        # This should not occur for the given non-trivial boundary conditions\n        return 0.0\n\n    lambda_min = positive_eigenvalues[0]\n\n    # 6. Calculate the smallest positive natural angular frequency (omega)\n    omega_min = np.sqrt(lambda_min)\n\n    return omega_min\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (Cantilever, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'cantilever'},\n        # Case 2 (Simply supported, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'simply-supported'},\n        # Case 3 (Fixed-fixed, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'fixed-fixed'},\n        # Case 4 (Simply supported, aluminum, coarse mesh)\n        {'E': 70e9, 'I': 1e-6, 'rho': 2700, 'A': 5e-4, 'L': 1.0, 'Ne': 2, 'bc_type': 'simply-supported'},\n    ]\n\n    results = []\n    for params in test_cases:\n        omega = solve_beam_vibration(**params)\n        # Round and format as a string with 6 decimal places\n        results.append(f\"{omega:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多复杂的工程系统，如桥梁在风中的振动或动脉中血流与血管壁的相互作用，都涉及流体与结构的耦合。本练习将引导您进入流固耦合（FSI）这一多物理场领域，通过一个简化的活塞模型来模拟流体对结构运动的影响。您将实现一种经典的分区求解算法，即狄利克雷-诺伊曼（Dirichlet–Neumann）交错耦合，并直面和处理因“附加质量效应”而引起的数值不稳定性，这对于开发稳健的多物理场数字孪生至关重要。",
            "id": "4235330",
            "problem": "考虑一个在一维活塞式流固耦合（FSI）模型，该模型在任意拉格朗日-欧拉（ALE）框架中建立。其中，一个质量为 $m_s$、刚度为 $k_s$ 的线性弹性结构的刚性界面，在长度为 $L$、横截面积为 $A$ 的流体柱的轴向方向上移动。流体密度为 $\\rho_f$，并假设为不可压缩，其由界面运动引起的轴向加速度在空间上是均匀的。设当前时间步结束时的界面位移为 $u_{n+1}$，前两个时间步的位移分别为 $u_n$ 和 $u_{n-1}$。时间步长为 $\\Delta t$。外部流体载荷是一个均匀的远场压力 $p_0$，产生一个净界面力 $F_{\\text{ext}} = p_0 A$。在此配置中，流体的附加质量为 $M_a = \\rho_f A L$。在与活塞运动相匹配的网格运动的ALE框架中，界面加速度通过标准中心差分近似 $a(u_{n+1}) = \\dfrac{u_{n+1} - 2 u_n + u_{n-1}}{\\Delta t^2}$ 进行离散化。\n\n狄利克雷-诺伊曼交错分区耦合在每个时间步内按如下子迭代 $k = 0,1,2,\\dots$ 进行：给定一个界面位移猜测值 $u^{k}$，使用 $u^{k}$ 提供的狄利克雷边界条件求解流体子问题，以获得界面牵引力 $F_f^{k}$；然后，将此牵引力作为诺伊曼边界条件求解结构子问题，以获得更新后的界面位移 $u_{\\text{struct}}^{k+1}$。应用欠松弛来稳定子迭代，通过设置 $u^{k+1} = u^{k} + \\omega \\left(u_{\\text{struct}}^{k+1} - u^{k}\\right)$，其中松弛因子 $\\omega \\in (0,1]$。每个时间步重复子迭代 $m$ 次。当 $|u^{m} - u^{\\star}| \\le \\varepsilon$ 时，耦合被视为收敛，其中 $u^{\\star}$ 是耦合问题在时间步结束时的单体解，$\\varepsilon$ 是一个指定的容差。\n\n仅从基本定律出发，推导一个针对单个时间步的完整算法，该算法应：\n- 基于均匀流体附加质量 $M_a$ 和 ALE 加速度近似来建模流体牵引力，\n- 通过牛顿第二定律和线性弹性来建模结构动力学，\n- 计算给定时间步的单体耦合解 $u^{\\star}$，\n- 实现带有欠松弛的狄利克雷-诺伊曼交错子迭代，\n- 在 $m$ 次子迭代后，对照 $u^{\\star}$ 并使用容差 $\\varepsilon$ 检查收敛性。\n\n使用以下物理基础：\n- 牛顿第二定律 $F = m a$，应用于流体柱和结构自由度，\n- 在活塞式几何结构中具有均匀轴向加速度的不可压缩流体，\n- 刚度为 $k_s$ 的线性弹性，产生恢复力 $k_s u_{n+1}$，\n- 中心差分加速度近似 $a(u_{n+1}) = \\dfrac{u_{n+1} - 2 u_n + u_{n-1}}{\\Delta t^2}$。\n\n单位必须在国际单位制（SI）中保持一致：所有给定量的单位用 $\\mathrm{kg}$、$\\mathrm{m}$、$\\mathrm{s}$ 和 $\\mathrm{Pa}$ 表示，位移以 $\\mathrm{m}$ 计算。此问题不使用角度。松弛因子必须是无量纲标量，收敛容差必须是正标量。\n\n您的程序必须实现推导出的算法并评估以下测试套件。在所有情况下，使用 $u_n = 0\\,\\mathrm{m}$ 和 $u_{n-1} = 0\\,\\mathrm{m}$ 以及容差 $\\varepsilon = 10^{-3}\\,\\mathrm{m}$。为清晰起见，每个测试用例都是一个元组 $(\\rho_f, A, L, m_s, k_s, \\Delta t, \\omega, m, p_0)$：\n- 测试用例1（理想情况，轻流体，刚性结构，小时间步）：$(\\rho_f = 1.2\\,\\mathrm{kg/m^3}, A = 0.01\\,\\mathrm{m^2}, L = 1.0\\,\\mathrm{m}, m_s = 1.0\\,\\mathrm{kg}, k_s = 100\\,\\mathrm{N/m}, \\Delta t = 0.01\\,\\mathrm{s}, \\omega = 1.0, m = 10, p_0 = 1000\\,\\mathrm{Pa})$。\n- 测试用例2（中等流固密度比，欠松弛和多次子迭代）：$(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 10.0\\,\\mathrm{kg}, k_s = 1000\\,\\mathrm{N/m}, \\Delta t = 0.1\\,\\mathrm{s}, \\omega = 1.0, m = 40, p_0 = 1000\\,\\mathrm{Pa})$。\n- 测试用例3（因附加质量而不稳定，欠松弛不足）：$(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 8.0\\,\\mathrm{kg}, k_s = 100\\,\\mathrm{N/m}, \\Delta t = 0.05\\,\\mathrm{s}, \\omega = 0.5, m = 50, p_0 = 1000\\,\\mathrm{Pa})$。\n- 测试用例4（通过结构刚度和较大时间步稳定）：$(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 10.0\\,\\mathrm{kg}, k_s = 5000\\,\\mathrm{N/m}, \\Delta t = 0.2\\,\\mathrm{s}, \\omega = 1.0, m = 5, p_0 = 1000\\,\\mathrm{Pa})$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果顺序与测试用例一致。每个结果都是一个布尔值，指示耦合是否在 $m$ 次子迭代后在给定容差内收敛，即格式必须完全像 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$。",
            "solution": "该问题要求针对一维流固耦合（FSI）问题推导并实现一种分区算法，并针对几个测试用例，通过与单体解的对比来验证其收敛性。推导过程将从指定的基本原理出发。\n\n### 1. 控制方程\n设 $u(t)$ 为固体界面在时间 $t$ 的位移。正方向取为沿流体柱轴线方向。问题涉及从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步。我们使用记号 $u_{n+1}$、$u_n$ 和 $u_{n-1}$ 分别表示在时间 $t_{n+1}$、$t_n$ 和 $t_{n-1}$ 的位移。在时间 $t_{n+1}$ 的界面加速度由二阶中心差分格式近似：\n$$a_{n+1} = \\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}$$\n\n#### a. 结构动力学\n结构被建模为一个线性质量-弹簧系统。根据牛顿第二定律，作用在结构质量 $m_s$ 上的合力等于其质量乘以加速度。这些力包括弹簧的弹性恢复力 $-k_s u_{n+1}$ 和流体施加在界面上的力 $F_{\\text{fluid}}$。\n$$m_s a_{n+1} + k_s u_{n+1} = F_{\\text{fluid}}$$\n代入加速度近似，我们得到结构的离散化方程：\n$$m_s \\left(\\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u_{n+1} = F_{\\text{fluid}}$$\n\n#### b. 流体动力学\n流体被建模为一个质量为 $M_a = \\rho_f A L$ 的刚性柱，称为附加质量。由于不可压缩性假设和活塞式几何结构，流体柱的加速度与界面加速度 $a_{n+1}$ 相同。作用在流体柱上的净力是界面处的力（由结构施加）与远端力（来自外部压力 $p_0$）之差。根据牛顿第三定律，结构施加在流体上的力为 $-F_{\\text{fluid}}$。来自远场压力的力为 $p_0 A$。因此，作用在流体上的净力为 $p_0 A - F_{\\text{fluid}}$。\n\n对流体质量 $M_a$ 应用牛顿第二定律：\n$$M_a a_{n+1} = p_0 A - F_{\\text{fluid}}$$\n这个方程可以重新整理，用系统运动和外部压力来表示流体力：\n$$F_{\\text{fluid}} = p_0 A - M_a a_{n+1}$$\n代入加速度近似：\n$$F_{\\text{fluid}} = p_0 A - M_a \\left(\\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right)$$\n\n### 2. 单体（完全耦合）解 $u^{\\star}$\n单体解，记作 $u^{\\star}$，是通过同时求解流体和结构方程得到的，确保位移 $u_{n+1}$ 和界面力 $F_{\\text{fluid}}$ 是一致的。我们将流体方程中 $F_{\\text{fluid}}$ 的表达式代入结构方程：\n$$m_s a_{n+1} + k_s u_{n+1} = p_0 A - M_a a_{n+1}$$\n将含有加速度 $a_{n+1}$ 的项组合在一起：\n$$(m_s + M_a) a_{n+1} + k_s u_{n+1} = p_0 A$$\n这是完全耦合系统的运动方程。总惯量是结构质量和流体附加质量之和，$m_s + M_a$。我们现在代入加速度的离散近似，并将 $u_{n+1}$ 替换为 $u^{\\star}$：\n$$(m_s + M_a) \\left(\\frac{u^{\\star} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u^{\\star} = p_0 A$$\n为了求解 $u^{\\star}$，我们重新整理各项：\n$$u^{\\star} \\left(\\frac{m_s + M_a}{\\Delta t^2} + k_s\\right) = p_0 A + \\frac{m_s + M_a}{\\Delta t^2}(2u_n - u_{n-1})$$\n因此，时间步结束时位移的单体解为：\n$$u^{\\star} = \\frac{p_0 A + \\frac{m_s + M_a}{\\Delta t^2}(2u_n - u_{n-1})}{\\frac{m_s + M_a}{\\Delta t^2} + k_s}$$\n\n### 3. 狄利克雷-诺伊曼分区算法\n分区格式在时间步内迭代地求解流体和结构子问题。设 $k$ 为子迭代索引。\n\n#### a. 流体子问题（狄利克雷）\n在子迭代 $k$ 时，给定界面位移的猜测值 $u_{n+1}^k$，我们求解由此产生的流体牵引力 $F_f^k$。由于边界运动是给定的，这对流体来说是一个狄利克雷问题。流体牵引力定义为施加在结构上的总力，包括通过流体传递的外部压力效应。问题陈述流体子问题产生界面牵引力 $F_f^k$。根据我们的推导，流体对结构的总力为 $F_{\\text{fluid}} = p_0 A - M_a a_{n+1}$。在分区耦合的背景下，我们将流体牵引力映射定义为：\n$$F_f^k = p_0 A - M_a \\left(\\frac{u_{n+1}^k - 2u_n + u_{n-1}}{\\Delta t^2}\\right)$$\n\n#### b. 结构子问题（诺伊曼）\n给定从流体求解中得到的流体牵引力 $F_f^k$，我们求解结构位移 $u_{\\text{struct},n+1}^{k+1}$。由于边界载荷是给定的，这是一个诺伊曼问题。\n$$m_s \\left(\\frac{u_{\\text{struct},n+1}^{k+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u_{\\text{struct},n+1}^{k+1} = F_f^k$$\n求解 $u_{\\text{struct},n+1}^{k+1}$：\n$$u_{\\text{struct},n+1}^{k+1} = \\frac{F_f^k + \\frac{m_s}{\\Delta t^2}(2u_n - u_{n-1})}{\\frac{m_s}{\\Delta t^2} + k_s}$$\n\n#### c. 欠松弛\n为了稳定子迭代，特别是在具有强附加质量效应的情况下，更新的位移猜测值 $u_{n+1}^{k+1}$ 计算为前一个猜测值和新结构位移的加权平均值：\n$$u_{n+1}^{k+1} = u_{n+1}^k + \\omega \\left(u_{\\text{struct},n+1}^{k+1} - u_{n+1}^k\\right) = (1-\\omega)u_{n+1}^k + \\omega u_{\\text{struct},n+1}^{k+1}$$\n其中 $\\omega \\in (0, 1]$ 是松弛因子。\n\n### 4. 单个时间步的算法\n基于以上推导，要实现的算法如下：\n\n1.  **输入**：$\\rho_f, A, L, m_s, k_s, \\Delta t, \\omega, m, p_0$ 以及先前的位移 $u_n, u_{n-1}$。对于此问题，$u_n=0$ 且 $u_{n-1}=0$。容差为 $\\varepsilon=10^{-3}$。\n2.  **初始化**：\n    *   计算附加质量：$M_a = \\rho_f A L$。\n    *   计算外力项：$F_{\\text{ext}} = p_0 A$。\n    *   定义历史位移项：$U_{\\text{hist}} = 2u_n - u_{n-1}$。\n3.  **计算单体解**：使用其推导出的公式计算 $u^{\\star}$。\n$$u^{\\star} = \\frac{p_0 A + \\frac{m_s + M_a}{\\Delta t^2} U_{\\text{hist}}}{\\frac{m_s + M_a}{\\Delta t^2} + k_s}$$\n4.  **分区子迭代**：\n    *   初始化位移猜测值：$u_{n+1}^0 = u_n$。\n    *   从 $k=0$ 到 $m-1$ 循环：\n        i.  **流体求解**：使用 $u_{n+1}^k$ 计算牵引力 $F_f^k$。\n            $$F_f^k = F_{\\text{ext}} - M_a \\left(\\frac{u_{n+1}^k - U_{\\text{hist}}}{\\Delta t^2}\\right)$$\n        ii. **结构求解**：使用 $F_f^k$ 计算 $u_{\\text{struct},n+1}^{k+1}$。\n            $$u_{\\text{struct},n+1}^{k+1} = \\frac{F_f^k + \\frac{m_s}{\\Delta t^2} U_{\\text{hist}}}{\\frac{m_s}{\\Delta t^2} + k_s}$$\n        iii. **松弛**：为下一次子迭代更新位移猜测值。\n            $$u_{n+1}^{k+1} = (1-\\omega)u_{n+1}^k + \\omega u_{\\text{struct},n+1}^{k+1}$$\n5.  **收敛性检查**：经过 $m$ 次迭代后，最终的迭代解为 $u_{n+1}^m$。检查是否满足收敛准则：\n    $$|u_{n+1}^m - u^{\\star}| \\le \\varepsilon$$\n6.  **输出**：如果满足准则，则返回 `True`，否则返回 `False`。\n这个结构化算法将为每个提供的测试用例实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_fsi_simulation(params):\n    \"\"\"\n    Solves one time step of a 1D FSI problem using a partitioned scheme\n    and checks for convergence against the monolithic solution.\n\n    Args:\n        params (tuple): A tuple containing the physical and numerical parameters:\n            (rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0, u_n, u_n_minus_1, epsilon)\n\n    Returns:\n        bool: True if the partitioned scheme converged within m iterations, False otherwise.\n    \"\"\"\n    rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0, u_n, u_n_minus_1, epsilon = params\n\n    # 1. Initialization and pre-calculations\n    # Added mass of the fluid column\n    M_a = rho_f * A * L\n    # Total effective mass of the coupled system\n    M_tot = m_s + M_a\n    # External force from far-field pressure\n    F_ext = p_0 * A\n    # Historical displacement term from previous time steps\n    U_hist = 2 * u_n - u_n_minus_1\n    \n    # Coefficients for discretized equations\n    # Inertial coefficient for the total system\n    C_M_tot_dt2 = M_tot / (delta_t**2)\n    # Inertial coefficient for the structure\n    C_ms_dt2 = m_s / (delta_t**2)\n    # Inertial coefficient for the fluid (added mass)\n    C_Ma_dt2 = M_a / (delta_t**2)\n\n    # 2. Compute the monolithic (fully coupled) solution u_star\n    # Denominator of the monolithic solution expression\n    denom_star = C_M_tot_dt2 + k_s\n    # Numerator of the monolithic solution expression\n    num_star = F_ext + C_M_tot_dt2 * U_hist\n    \n    # Handle the case where the denominator is zero to avoid division by zero\n    if denom_star == 0:\n        # This physical configuration would imply an unconstrained system,\n        # which is not expected for the given problems.\n        # But as a safeguard: If numerator is also zero, any displacement is a solution (ill-posed).\n        # If numerator is non-zero, no solution exists. In either case, it's problematic.\n        # For the purpose of this problem, let's treat this as a failure.\n        return False\n        \n    u_star = num_star / denom_star\n\n    # 3. Perform partitioned subiterations\n    # Initialize the displacement guess for the current time step n+1\n    u_k = u_n \n    \n    # Effective stiffness of the structure sub-problem\n    S_s = C_ms_dt2 + k_s\n\n    for _ in range(m):\n        # a. Fluid subproblem: Given u_k, calculate fluid traction F_f_k\n        # This is the force the fluid exerts on the structure.\n        F_f_k = F_ext - C_Ma_dt2 * (u_k - U_hist)\n\n        # b. Structure subproblem: Given F_f_k, calculate new displacement u_struct_k_plus_1\n        # Denominator is the effective stiffness S_s.\n        if S_s == 0:\n            # Another safeguard for a physically unconstrained structural subproblem.\n            return False\n            \n        u_struct_k_plus_1 = (F_f_k + C_ms_dt2 * U_hist) / S_s\n\n        # c. Under-relaxation: Update the displacement guess for the next iteration\n        u_k_plus_1 = (1.0 - omega) * u_k + omega * u_struct_k_plus_1\n        u_k = u_k_plus_1\n        \n        # Check for non-physical divergence (overflow)\n        if not np.isfinite(u_k):\n            return False\n\n    # The final iterated displacement after m subiterations\n    u_m = u_k\n    \n    # 4. Convergence check\n    # Check if the absolute difference between the final iterated solution\n    # and the monolithic solution is within the prescribed tolerance.\n    converged = abs(u_m - u_star) = epsilon\n    \n    return converged\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Common parameters for all test cases\n    u_n = 0.0  # m\n    u_n_minus_1 = 0.0  # m\n    epsilon = 1e-3  # m\n\n    # Test cases: (rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0)\n    test_cases_params = [\n        (1.2, 0.01, 1.0, 1.0, 100, 0.01, 1.0, 10, 1000),  # Case 1\n        (1000, 0.02, 0.8, 10.0, 1000, 0.1, 1.0, 40, 1000), # Case 2\n        (1000, 0.02, 0.8, 8.0, 100, 0.05, 0.5, 50, 1000), # Case 3\n        (1000, 0.02, 0.8, 10.0, 5000, 0.2, 1.0, 5, 1000),  # Case 4\n    ]\n\n    # Append common parameters to each test case tuple\n    test_cases = [params + (u_n, u_n_minus_1, epsilon) for params in test_cases_params]\n\n    results = []\n    for case in test_cases:\n        result = run_fsi_simulation(case)\n        results.append(str(result).lower()) # Convert boolean to lowercase string 'true'/'false'\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数字孪生的核心挑战之一是在保证精度的前提下实现实时仿真，而高保真度的物理模型往往计算成本高昂。模型降阶（Model Order Reduction, MOR）技术是解决这一矛盾的关键。在本练习中，您将为一个参数化的弹性杆构建一个降阶模型（Reduced Order Model, ROM）。通过实施一个基于残差的贪心算法来自动构建最优的降阶基，您将体验到如何从复杂的全阶模型中萃取出精华，生成一个能够进行快速、实时预测的代理模型，从而赋能数字孪生的在线应用。",
            "id": "4235354",
            "problem": "考虑将一维线弹性杆作为典型的赛博物理系统，为数字孪生建立降阶模型（ROM）。杆占据空间域 $[0,1]$，具有恒定的横截面积 $A=1$，并受到均匀的体力 $q=1$。其静态平衡源于力平衡和线弹性本构关系：柯西应力 $\\sigma$ 满足 $\\frac{d}{dx}\\sigma + b = 0$（其中体力密度 $b=q$），应力-应变关系为 $\\sigma(x) = E(x;\\mu)\\,\\epsilon(x)$（其中应变 $\\epsilon(x) = \\frac{du}{dx}$）。综合以上各式，该边值问题的控制强形式是一个二阶微分方程\n$$\n-\\frac{d}{dx}\\Big(E(x;\\mu)\\,\\frac{du}{dx}\\Big) = q,\\quad x\\in(0,1),\n$$\n边界条件为 $u(0)=0$（本质边界条件）和 $\\sigma(1)=E(1;\\mu)\\,u'(1)=0$（自然无牵引力边界条件）。参数向量 $\\mu=(\\mu_1,\\mu_2)$ 控制分段常数的杨氏模量 $E(x;\\mu)$，使得当 $x\\in[0,0.5]$ 时 $E(x;\\mu)=\\mu_1$，当 $x\\in(0.5,1]$ 时 $E(x;\\mu)=\\mu_2$。所得的离散化算子是对称正定（SPD）的，这使得稳定的模型降阶成为可能。\n\n从基本弱形式出发，寻找 $u\\in V$，使得对于所有测试函数 $v\\in V$，\n$$\n\\int_{0}^{1} E(x;\\mu)\\,\\frac{du}{dx}\\,\\frac{dv}{dx}\\,dx = \\int_{0}^{1} q\\,v\\,dx,\n$$\n其中 $V=\\{v\\in H^1(0,1)\\mid v(0)=0\\}$。在具有节点 $\\{x_i\\}_{i=0}^{N}$（其中 $x_i = i/N$）的 $N$ 个单元的均匀网格上，通过分段线性有限元离散化来近似 $u$，并移除本质边界自由度 $u(0)=0$，以获得一个简化的线性系统\n$$\nA(\\mu)\\,u(\\mu) = f,\n$$\n其中 $A(\\mu)\\in\\mathbb{R}^{n\\times n}$ 是对称正定的，$n=N$，$u(\\mu)\\in\\mathbb{R}^{n}$ 是自由节点位移，$f\\in\\mathbb{R}^{n}$ 是由均匀体力产生的载荷向量。根据 $E(x;\\mu)$ 的空间划分，刚度算子可以进行仿射分解\n$$\nA(\\mu) = \\mu_1\\,K_1 + \\mu_2\\,K_2,\n$$\n其中 $K_1$ 和 $K_2$ 分别是使用标准线性有限元从定义域的左半部分 $[0,0.5]$ 和右半部分 $(0.5,1]$ 组装而成的刚度矩阵。载荷由 $q=1$ 使用与弱形式和所选基函数一致的标准单元载荷向量公式组装而成。\n\n定义降阶模型（ROM）子空间 $V_r = \\operatorname{span}\\{ \\phi_1,\\dots,\\phi_r\\}$，其中 $\\{\\phi_j\\}$ 是通过在训练参数集上使用贪心算法得到的标准正交基向量。对于任意参数 $\\mu$，ROM 解 $\\hat{u}(\\mu)\\in V_r$ 通过求解降阶系统计算得出\n$$\nA_r(\\mu)\\,a(\\mu) = V^\\top f,\\quad A_r(\\mu) = V^\\top A(\\mu)\\,V = \\mu_1\\,K_{1,r} + \\mu_2\\,K_{2,r},\n$$\n其中 $V=[\\phi_1\\,\\cdots\\,\\phi_r]\\in\\mathbb{R}^{n\\times r}$，$K_{1,r}=V^\\top K_1 V$，$K_{2,r}=V^\\top K_2 V$。ROM 状态则为 $\\hat{u}(\\mu)=V\\,a(\\mu)$。贪心算法通过选择使基于残差的后验误差指标最大化的参数来迭代构造 $V$。具体来说，在第 $k$ 次迭代中，使用当前基 $V_k$，对于训练集中的每个 $\\mu$，计算降阶解 $\\hat{u}_k(\\mu)$ 和残差 $r_k(\\mu) = f - A(\\mu)\\,\\hat{u}_k(\\mu)$。选择使 $\\|r_k(\\mu)\\|_2$ 最大化的下一个参数 $\\mu^{(k+1)}$，计算全阶解 $u(\\mu^{(k+1)})$，将其与 $V_k$ 进行标准正交化，并扩充基。\n\n您的任务是实现以下端到端流程：\n- 为所描述的杆组装线性有限元模型，其中 $N=60$ 个单元，$A=1$，$q=1$，并强制执行边界条件 $u(0)=0$ 和在 $x=1$ 处无牵引力。构造仿射刚度分解 $A(\\mu)=\\mu_1 K_1 + \\mu_2 K_2$，其中 $K_1$ 和 $K_2$ 分别对应于定义域的左半部分和右半部分。\n- 定义一个均匀的训练参数网格 $\\mathcal{P}_{\\text{train}} = \\{\\mu_1^i\\}\\times\\{\\mu_2^j\\}$，其中 $\\mu_1^i$ 和 $\\mu_2^j$ 在 $[0.5,5.0]$ 内线性间隔取 8 个点，并在中心参数 $\\mu^{(1)}=(2.75,2.75)$ 处初始化贪心算法。\n- 运行贪心基构造，最多构造 $r_{\\max}=8$ 个基向量，或者直到 $\\mathcal{P}_{\\text{train}}$ 上的最大残差范数低于容差 $\\varepsilon=10^{-8}$。\n- 预计算降阶算子 $K_{1,r}$ 和 $K_{2,r}$，并使用它们通过插值来评估 $A_r(\\mu)$，以实现实时孪生更新。\n- 对于下面的测试套件，计算全阶解 $u(\\mu)$ 和 ROM 解 $\\hat{u}(\\mu)$，并报告相对误差\n$$\ne(\\mu) = \\frac{\\|u(\\mu) - \\hat{u}(\\mu)\\|_2}{\\|u(\\mu)\\|_2}.\n$$\n所有量均为无量纲，范数为标准欧几里得范数。\n\n使用以下参数值的测试套件：\n1. $\\mu=(0.5,0.5)$,\n2. $\\mu=(5.0,5.0)$,\n3. $\\mu=(0.5,5.0)$,\n4. $\\mu=(5.0,0.5)$,\n5. $\\mu=(2.0,3.5)$.\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[e(\\mu^{(1)}),e(\\mu^{(2)}),\\dots]$）。输出必须是与上述五个测试案例相对应的浮点数，并按所列顺序排列。",
            "solution": "该问题要求为一维线弹性杆实现一个降阶建模流程。该过程涉及三个主要阶段：首先，建立高保真有限元模型（FEM）；其次，使用贪心算法构建降阶基；第三，针对测试案例评估所得的降阶模型（ROM）。\n\n### 1. 有限元模型（FEM）组装\n\n杆的静态位移 $u(x)$ 的控制方程是一个二阶边值问题：\n$$\n-\\frac{d}{dx}\\Big(E(x;\\mu)\\,\\frac{du}{dx}\\Big) = q,\\quad x\\in(0,1),\n$$\n边界条件为 $u(0)=0$ 和 $E(1;\\mu)u'(1)=0$。杨氏模量 $E(x;\\mu)$ 是分段常数，由参数向量 $\\mu=(\\mu_1, \\mu_2)$ 控制。\n\n为了进行数值求解，我们首先通过乘以来自空间 $V=\\{v\\in H^1(0,1)\\mid v(0)=0\\}$ 的测试函数 $v(x)$ 并在整个定义域上积分来推导弱形式。使用分部积分法并应用边界条件，我们得到：\n$$\n\\int_{0}^{1} E(x;\\mu)\\,\\frac{du}{dx}\\,\\frac{dv}{dx}\\,dx = \\int_{0}^{1} q\\,v\\,dx, \\quad \\forall v \\in V.\n$$\n定义域 $[0,1]$ 被离散化为 $N=60$ 个长度为 $h=1/N = 1/60$ 的均匀有限元。位移场 $u(x)$ 通过分段线性基函数（帽函数） $N_i(x)$ 的和来近似：$u_h(x) = \\sum_{i=0}^{N} u_i N_i(x)$。由于 $u(0)=0$，自由度 $u_0$ 是固定的，未知解向量由节点位移 $u = [u_1, u_2, \\dots, u_N]^\\top \\in \\mathbb{R}^N$ 组成。\n\n将近似解代入弱形式，得到线性系统 $A(\\mu)u(\\mu)=f$。问题指出，刚度矩阵 $A(\\mu)$ 具有仿射参数依赖性：$A(\\mu) = \\mu_1 K_1 + \\mu_2 K_2$。\n- $K_1$ 是来自定义域左半部分 $x\\in[0,0.5]$ 的刚度矩阵贡献，其中 $E(x;\\mu)=\\mu_1$。\n- $K_2$ 是来自右半部分 $x\\in(0.5,1]$ 的刚度矩阵贡献，其中 $E(x;\\mu)=\\mu_2$。\n\n这些矩阵是使用长度为 $h_e$、单位杨氏模量的标准线性单元刚度矩阵组装而成的，即 $k_e = \\frac{1}{h_e}\\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。此处，$h_e=h=1/60$。\n- $K_1$ 由前 $N/2=30$ 个单元（从节点 0 到 30）组装而成。\n- $K_2$ 由后 $N/2=30$ 个单元（从节点 30 到 60）组装而成。\n系统矩阵的大小为 $n \\times n$，其中 $n=N=60$。\n\n力向量 $f \\in \\mathbb{R}^N$ 由弱形式的右侧 $\\int_0^1 q v dx$ 组装而成。对于均匀载荷 $q=1$，对应于节点 $i$ 的项 $f_i$ 是 $f_i = \\int_0^1 q N_i(x) dx$。对于内部节点 $i \\in \\{1,\\dots,N-1\\}$，$f_i=qh=1/60$。对于自然边界节点 $i=N$，$f_N = qh/2 = 1/120$。\n\n### 2. 用于基构造的贪心算法\n\nROM 的目标是将全阶解 $u(\\mu)$ 近似为少数几个基向量的线性组合，即 $\\hat{u}(\\mu) = V a(\\mu)$，其中 $V \\in \\mathbb{R}^{n \\times r}$ 是一个矩阵，其列 $\\{\\phi_j\\}_{j=1}^r$ 构成了降阶空间的标准正交基，且 $r \\ll n$。基 $V$ 是使用弱贪心算法迭代构建的。\n\n过程如下：\n1.  **初始化**：算法使用参数 $\\mu^{(1)}=(2.75, 2.75)$ 进行初始化。通过求解 $A(\\mu^{(1)})u(\\mu^{(1)})=f$ 来计算全阶解 $u(\\mu^{(1)})$。第一个基向量是归一化后的解：$\\phi_1 = u(\\mu^{(1)}) / \\|u(\\mu^{(1)})\\|_2$。基为 $V_1 = [\\phi_1]$。\n2.  **迭代**：对于每一步 $k=1, \\dots, r_{\\max}-1$：\n    a.  **误差估计**：对于离散训练集 $\\mathcal{P}_{\\text{train}}$ 中的每个参数 $\\mu$，计算 ROM 解 $\\hat{u}_k(\\mu) = V_k (V_k^\\top A(\\mu) V_k)^{-1} V_k^\\top f$。该近似的质量通过残差向量的欧几里得范数来衡量，即 $\\|r_k(\\mu)\\|_2 = \\|f - A(\\mu)\\hat{u}_k(\\mu)\\|_2$。\n    b.  **参数选择**：用于基富集的下一个参数 $\\mu^{(k+1)}$，选择为在训练集上使该残差范数最大化的参数：$\\mu^{(k+1)} = \\arg\\max_{\\mu \\in \\mathcal{P}_{\\text{train}}} \\|r_k(\\mu)\\|_2$。\n    c.  **终止检查**：如果 $\\mathcal{P}_{\\text{train}}$ 上的最大残差范数降至容差 $\\varepsilon=10^{-8}$ 以下，则算法终止。\n    d.  **基扩充**：计算一个“快照”解 $u(\\mu^{(k+1)})$。然后使用修正的 Gram-Schmidt 过程将此快照与 $V_k$ 中现有的基向量正交化：$\\tilde{\\phi}_{k+1} = u(\\mu^{(k+1)}) - V_k V_k^\\top u(\\mu^{(k+1)})$。新的基向量是归一化后的结果：$\\phi_{k+1} = \\tilde{\\phi}_{k+1} / \\|\\tilde{\\phi}_{k+1}\\|_2$。基被扩充为：$V_{k+1} = [V_k, \\phi_{k+1}]$。\n该过程持续进行，直到基的大小达到 $r_{\\max}=8$ 或满足误差容差。训练集 $\\mathcal{P}_{\\text{train}}$ 是参数域 $[\\mu_1, \\mu_2] \\in [0.5, 5.0] \\times [0.5, 5.0]$ 上的一个 $8 \\times 8 = 64$ 个点的均匀网格。\n\n### 3. ROM 评估\n\n一旦构造了大小为 $n \\times r$ 的最终基 $V$，就预先计算降阶算子：\n$$\nK_{1,r} = V^\\top K_1 V \\in \\mathbb{R}^{r \\times r}\n$$\n$$\nK_{2,r} = V^\\top K_2 V \\in \\mathbb{R}^{r \\times r}\n$$\n$$\nf_r = V^\\top f \\in \\mathbb{R}^{r}\n$$\n对于任何新参数 $\\mu_{\\text{test}}$，ROM 都能提供实时解。降阶刚度矩阵可以高效地组装为 $A_r(\\mu_{\\text{test}}) = \\mu_1 K_{1,r} + \\mu_2 K_{2,r}$。求解降阶系统 $A_r(\\mu_{\\text{test}})a(\\mu_{\\text{test}}) = f_r$ 以得到系数 $a(\\mu_{\\text{test}})$，由于其尺寸小（$r \\times r$），计算成本很低。然后将 ROM 解重构为 $\\hat{u}(\\mu_{\\text{test}}) = V a(\\mu_{\\text{test}})$。\n\n对于五个测试参数集中的每一个，都会计算全阶解 $u(\\mu)$ 和降阶解 $\\hat{u}(\\mu)$。ROM 的准确性通过相对欧几里得误差来量化：\n$$\ne(\\mu) = \\frac{\\|u(\\mu) - \\hat{u}(\\mu)\\|_2}{\\|u(\\mu)\\|_2}.\n$$\n该实现计算这五个误差值，并将它们作为最终输出呈现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the end-to-end pipeline for creating and evaluating a\n    Reduced Order Model (ROM) for a 1D elastic rod.\n    \"\"\"\n    # 1. FEM Assembly\n    N = 60\n    q = 1.0\n    h = 1.0 / N\n\n    # Assemble affine stiffness components K1, K2 based on unit modulus.\n    # Element stiffness matrix for E=1, A=1.\n    k_elem = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    # Use (N+1)x(N+1) global matrices for assembly, then slice to apply BC.\n    K1_glob = np.zeros((N + 1, N + 1))\n    N_left = N // 2 # Number of elements in the left half [0, 0.5]\n    for i in range(N_left):\n        K1_glob[i:i+2, i:i+2] += k_elem\n\n    K2_glob = np.zeros((N + 1, N + 1))\n    for i in range(N_left, N):\n        K2_glob[i:i+2, i:i+2] += k_elem\n\n    # Apply essential BC u(0)=0 by removing the first row and column.\n    # The system size becomes n=N for DOFs u_1, ..., u_N.\n    K1 = K1_glob[1:, 1:]\n    K2 = K2_glob[1:, 1:]\n\n    # Assemble force vector f for q=1.\n    # f_i = integral(q * N_i(x) dx), where N_i is the hat function.\n    f = np.ones(N) * q * h\n    f[-1] = q * h / 2.0\n\n    # 2. Greedy Algorithm for Basis Construction\n    r_max = 8\n    epsilon = 1e-8\n\n    # Define training parameter set\n    mu_pts = np.linspace(0.5, 5.0, 8)\n    P_train = [(m1, m2) for m1 in mu_pts for m2 in mu_pts]\n\n    # Initialize with the solution at the center parameter\n    mu_initial = (2.75, 2.75)\n    A_initial = mu_initial[0] * K1 + mu_initial[1] * K2\n    u_initial = np.linalg.solve(A_initial, f)\n    V = (u_initial / np.linalg.norm(u_initial))[:, np.newaxis]\n\n    # Start greedy iterations\n    r = 1\n    while r  r_max:\n        max_res_norm = -1.0\n        mu_next = None\n\n        # Precompute reduced operators for the current basis V\n        K1r = V.T @ K1 @ V\n        K2r = V.T @ K2 @ V\n        fr = V.T @ f\n\n        # Find parameter in training set that maximizes the residual norm\n        for mu_train in P_train:\n            mu1_train, mu2_train = mu_train\n            A_train = mu1_train * K1 + mu2_train * K2\n\n            # Solve the reduced system\n            Ar_train = mu1_train * K1r + mu2_train * K2r\n            \n            try:\n                a_train = np.linalg.solve(Ar_train, fr)\n            except np.linalg.LinAlgError:\n                # Should not happen for SPD matrices, but as a safeguard\n                continue\n\n            u_hat = V @ a_train\n\n            # Compute residual of the full-order system\n            res = f - (A_train @ u_hat)\n            res_norm = np.linalg.norm(res)\n\n            if res_norm > max_res_norm:\n                max_res_norm = res_norm\n                mu_next = mu_train\n\n        # Check for convergence\n        if max_res_norm  epsilon:\n            break\n        \n        # Generate new basis vector from the selected parameter\n        A_next = mu_next[0] * K1 + mu_next[1] * K2\n        u_snap = np.linalg.solve(A_next, f)\n\n        # Orthonormalize snapshot against the current basis\n        u_orth = u_snap - V @ (V.T @ u_snap)\n        norm_u_orth = np.linalg.norm(u_orth)\n        \n        # Add new vector to basis if it's not linearly dependent\n        if norm_u_orth > 1e-10:\n            phi_new = u_orth / norm_u_orth\n            V = np.hstack([V, phi_new[:, np.newaxis]])\n            r += 1\n        else:\n            # The snapshot is already in the basis span, stop.\n            break\n\n    # 3. Evaluation on Test Cases\n    test_cases = [\n        (0.5, 0.5),\n        (5.0, 5.0),\n        (0.5, 5.0),\n        (5.0, 0.5),\n        (2.0, 3.5),\n    ]\n\n    results = []\n\n    # Precompute final reduced operators with the final basis V\n    K1r_final = V.T @ K1 @ V\n    K2r_final = V.T @ K2 @ V\n    fr_final = V.T @ f\n\n    for mu_test in test_cases:\n        mu1_test, mu2_test = mu_test\n\n        # Compute Full-Order Model (FOM) solution\n        A_fom = mu1_test * K1 + mu2_test * K2\n        u_fom = np.linalg.solve(A_fom, f)\n\n        # Compute Reduced-Order Model (ROM) solution\n        Ar_rom = mu1_test * K1r_final + mu2_test * K2r_final\n        a_rom = np.linalg.solve(Ar_rom, fr_final)\n        u_rom = V @ a_rom\n\n        # Calculate relative error\n        error_norm = np.linalg.norm(u_fom - u_rom)\n        fom_norm = np.linalg.norm(u_fom)\n        relative_error = error_norm / fom_norm if fom_norm > 0 else 0.0\n        results.append(relative_error)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}