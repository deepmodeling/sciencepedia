{
    "hands_on_practices": [
        {
            "introduction": "掌握资产管理外壳的第一步是理解其基本结构。这项练习将引导您从第一性原理出发，构建一个最小但完整的AAS实例，重点关注标识符、管理信息以及AAS与其子模型之间的关系。通过这项实践，您将巩固确保AAS成为有效数字表示的核心结构规则。",
            "id": "4206044",
            "problem": "您需要为一个单一的物理资产构建并验证一个最小但结构连贯的资产管理壳 (AAS) 实例，重点是通过显式语义标识符实现语义互操作性。目标是通过身份、可引用性和语义引用的基本原则来形式化构建与验证过程，然后将这些规则实现为一个程序。最终输出必须是一个单行的布尔值列表，表示每个测试用例的有效性。\n\n基本和核心定义：\n- 资产管理壳 (AAS) 是资产的数字表示，捕获其标识、管理信息和子模型。在简化的最小实例中，AAS 被建模为一对可识别元素：AAS 本身和一个子模型 (Submodel)。只有 AAS 和子模型是具有全局唯一标识符的可识别元素。子模型元素 (SubmodelElement)，具体来说是属性 (Property)，是可引用的，但不是可识别的。\n- 全局唯一性由通用唯一标识符 (UUID) 或国际化资源标识符 (IRI) 的标识符来保证。为便于计算，形式为 $\\text{urn:uuid:}\\langle\\text{uuid}\\rangle$ 的 IRI 和形式为 $\\text{http}://\\ldots$ 或 $\\text{https}://\\ldots$ 的 Web IRI 均被视为有效。\n- 语义互操作性要求每个属性 (Property) 都带有一个 $\\text{semanticId}$，该 ID 引用一个全局可解析的概念引用（此处建模为 IRI）。\n\n要构建的最小 JSON 表示：\n- 该实例是一个具有两个顶层成员的 JSON 对象：\n  - $\\text{assetAdministrationShell}$：一个包含字段 $\\text{id}$、$\\text{idShort}$、$\\text{administration}$、$\\text{assetInformation}$ 和 $\\text{submodels}$ 的对象。\n  - $\\text{submodel}$：一个包含字段 $\\text{id}$、$\\text{idShort}$ 和 $\\text{submodelElements}$ 的对象。\n- 字段级结构：\n  - $\\text{assetAdministrationShell.id}$：一个全局唯一标识符（IRI 或带有 UUID 的 URN）。\n  - $\\text{assetAdministrationShell.idShort}$：一个满足命名约束的可引用名称。\n  - $\\text{assetAdministrationShell.administration}$：一个包含 $\\text{version}$ 和 $\\text{revision}$ 作为字符串的对象。\n  - $\\text{assetInformation.globalAssetId}$：底层物理资产的全局唯一标识符。\n  - $\\text{assetAdministrationShell.submodels}$：一个列表，其中包含一个引用对象，该对象的 $\\text{id}$ 字段等于 $\\text{submodel.id}$。\n  - $\\text{submodel.id}$：一个全局唯一标识符，与 $\\text{assetAdministrationShell.id}$ 和 $\\text{assetInformation.globalAssetId}$ 不同。\n  - $\\text{submodel.idShort}$：一个满足命名约束的可引用名称。\n  - $\\text{submodel.submodelElements}$：一个恰好包含 $3$ 个属性 (Property) 对象的列表。\n  - 每个属性 (Property) 对象包含 $\\text{modelType} = \\text{\"Property\"}$、$\\text{idShort}$、$\\text{semanticId}$、$\\text{valueType}$ 和 $\\text{value}$。\n\n根据基本原则定义的命名和类型约束：\n- $\\text{idShort}$ 的可引用命名：\n  - 设 $\\Sigma_{\\text{alnum}}$ 为字母数字字符集，$\\Sigma_{\\_}$ 为下划线。允许的字母表为 $\\Sigma = \\Sigma_{\\text{alnum}} \\cup \\{\\_\\}$。\n  - 名称必须以字母开头。形式上，对于长度为 $\\ell$ 的字符串 $s$，有 $s \\in \\Sigma^\\ell$，$1 \\leq \\ell \\leq 128$，且第一个字符 $s_1 \\in \\{A,\\ldots,Z,a,\\ldots,z\\}$。\n  - 所有后续字符 $s_i \\in \\Sigma$，其中 $i \\in \\{2,\\ldots,\\ell\\}$。\n- 全局标识符有效性：\n  - 一个标识符 $u$ 是有效的，如果它是一个形式为 $\\text{urn:uuid:}\\langle\\text{uuid}\\rangle$ 的 URN（其中 $\\langle\\text{uuid}\\rangle$ 匹配规范的 UUID 版本 4 模式），或者是一个以 $\\text{http}://$ 或 $\\text{https}://$ 开头并后跟非空路径的 Web IRI。\n- 基数约束：\n  - 列表 $\\text{submodel.submodelElements}$ 的长度必须恰好为 $3$：$|\\text{submodel.submodelElements}| = 3$。\n  - 列表 $\\text{assetAdministrationShell.submodels}$ 的长度必须恰好为 $1$：$|\\text{assetAdministrationShell.submodels}| = 1$。\n- 管理信息约束：\n  - $\\text{version}$ 和 $\\text{revision}$ 都必须作为非空字符串存在，且每个字符串只包含数字。形式上，如果 $\\text{version} = v$ 且 $\\text{revision} = r$，那么当 $v$ 和 $r$ 被解释为数字字符串时，有 $v \\in \\{0,1,2,\\ldots\\}$ 和 $r \\in \\{0,1,2,\\ldots\\}$。\n- 属性类型和语义：\n  - 每个属性 (Property) 必须有一个 $\\text{valueType} \\in \\{\\text{\"string\"}, \\text{\"integer\"}, \\text{\"double\"}, \\text{\"boolean\"}\\}$。\n  - 其 $\\text{value}$ 必须是相应的原始类型：字符串、整数、浮点数（对于 $\\text{\"double\"}$）或布尔值。对于 $\\text{\"double\"}$，该值可以是实数；在实践中，这是一个浮点表示。\n  - 每个属性 (Property) 都必须有一个作为有效 IRI（$\\text{http}/\\text{https}$ 或 $\\text{urn:uuid}$）的 $\\text{semanticId}$。\n- 唯一性约束：\n  - 标识符 $\\text{assetAdministrationShell.id}$、$\\text{submodel.id}$ 和 $\\text{assetInformation.globalAssetId}$ 必须两两不同。\n  - 子模型 (Submodel) 中的属性 (Properties) 集合内的 $\\text{idShort}$ 值必须两两不同。\n\n程序要求：\n- 实现一个程序，该程序为每个测试用例构建一个如上所述的最小 AAS 实例 JSON 对象，然后根据上述约束对其进行验证。程序必须为每个测试用例返回一个布尔值，以指示其有效性。\n- 程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表形式的结果（例如 $\\text{[result1,result2,\\ldots]}$）。\n\n测试套件：\n- 共有 $6$ 个测试用例。每个用例都需要构建一个包含一个子模型 (Submodel) 和恰好 $3$ 个属性 (Properties) 的 AAS 实例。\n- 每个测试用例的参数如下：\n  1. 正常路径（预期有效性：true）：\n     - $\\text{AAS.idShort} = \\text{\"AAS\\_Drive\"}$，$\\text{Submodel.idShort} = \\text{\"DriveSM\"}$，$\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性 1：$\\text{idShort} = \\text{\"nominalTorque\"}$，$\\text{valueType} = \\text{\"integer\"}$，$\\text{value} = 120$，$\\text{semanticId} = \\text{\"http://example.org/cd#nominalTorque\"}$。\n     - 属性 2：$\\text{idShort} = \\text{\"ratedSpeed\"}$，$\\text{valueType} = \\text{\"double\"}$，$\\text{value} = 1500.0$，$\\text{semanticId} = \\text{\"http://example.org/cd#ratedSpeed\"}$。\n     - 属性 3：$\\text{idShort} = \\text{\"manufacturerName\"}$，$\\text{valueType} = \\text{\"string\"}$，$\\text{value} = \\text{\"Acme Motors\"}$，$\\text{semanticId} = \\text{\"http://example.org/cd#manufacturerName\"}$。\n     - 所有标识符（$\\text{AAS.id}$、$\\text{Submodel.id}$、$\\text{globalAssetId}$）都是不同的有效 UUID URN。\n  2. 边界命名长度（预期有效性：true）：\n     - $\\text{Submodel.idShort} = \\text{\"DriveSM\"}$，$\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性 1：$\\text{idShort}$ 是一个长度为 128 的字符串，以字母开头，例如，$\\text{\"A\"}$ 后跟 127 个下划线或字母数字字符，其 $\\text{valueType} = \\text{\"string\"}$，$\\text{value} = \\text{\"X\"}$，$\\text{semanticId} = \\text{\"http://example.org/cd#longId\"}$。\n     - 属性 2 和 3 使用与用例 1 类似的有效短名称和语义。\n     - 所有标识符都是不同的有效 UUID URN。\n  3. 无效的子模型可引用名称（预期有效性：false）：\n     - $\\text{Submodel.idShort} = \\text{\"1SubmodelX\"}$（违反了首字母约束），$\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性如用例 1 中一样有效。\n     - 所有标识符都是不同的有效 UUID URN。\n  4. 重复的全局标识符（预期有效性：false）：\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 强制 $\\text{Submodel.id} = \\text{AAS.id}$（违反了两两不同约束），属性如用例 1 中一样有效。\n     - $\\text{globalAssetId}$ 是一个不同的有效 UUID URN。\n  5. 缺失管理字段（预期有效性：false）：\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}\\}$（缺少 $\\text{revision}$）。\n     - 其他字段与用例 1 匹配且在其他方面有效。\n  6. 缺失属性的语义标识符（预期有效性：false）：\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性 1 和 2 如用例 1 中一样有效；属性 3 缺少 $\\text{semanticId}$（例如，$\\text{semanticId} = \\text{null}$ 或被省略）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表形式的结果（例如 $\\text{[true,false,true,\\ldots]}$）。元素必须是小写的布尔值。",
            "solution": "问题陈述经评估为**有效**。它在数字孪生和资产管理壳 (AAS) 规范领域具有科学依据，提法恰当，具有清晰且可形式化的约束，并且语言客观。该任务是根据一套精确的规则为最小 AAS 实例构建一个验证器，并根据给定的测试套件对其进行评估。\n\n解决方案实现为一个以验证器类 `AASValidator` 为中心的 Python 程序。该类封装了根据规定规则验证 AAS 实例所需的所有逻辑。验证器的设计基于分层的、基于原则的方法，确保问题陈述中的每条约束都得到系统地检查。\n\n验证过程被分解为几个逻辑步骤，每个步骤由 `AASValidator` 类中的一个专用方法处理。一个顶层的 `validate` 方法协调整个过程，只有在所有检查都通过时才返回 `True`。为了稳健地处理格式错误的输入，例如缺失的键或不正确的数据结构，主验证逻辑被包含在一个 `try...except` 块中；任何结构性错误都会引发异常，并导致立即返回 `False`，表示实例无效。\n\n验证规则分类并实现如下：\n\n1.  **结构和基数验证**：第一步是验证 JSON 对象的基本结构。验证器在每个层级检查所有必需键的存在性和正确类型（即字典、列表）：根对象（`assetAdministrationShell`、`submodel`）、AAS 对象（`id`、`idShort`、`administration`、`assetInformation`、`submodels`）、子模型对象（`id`、`idShort`、`submodelElements`）等。此处也强制执行基数约束，特别是确保 `submodels` 列表恰好包含一个元素（$|\\text{assetAdministrationShell.submodels}| = 1$），`submodelElements` 列表恰好包含三个元素（$|\\text{submodel.submodelElements}| = 3$）。\n\n2.  **标识符语法验证**：定义了两种类型的标识符：可引用名称（`idShort`）和全局唯一标识符。\n    -   **`idShort` 验证**：一个辅助方法 `_is_valid_idshort` 实现了命名约束。对于给定长度为 $\\ell$ 的 `idShort` 字符串 $s$，它验证 $1 \\le \\ell \\le 128$，第一个字符 $s_1$ 是一个 ASCII 字母，并且所有后续字符都属于字母数字字符集或下划线。这通过使用正则表达式 `^[a-zA-Z][a-zA-Z0-9_]{0,127}$` 得以高效实现。\n    -   **全局标识符验证**：另一个辅助方法 `_is_valid_global_id` 验证全局唯一标识符。它检查标识符字符串是否符合两种模式之一：版本 4 UUID 的 URN（例如 `urn:uuid:...`），使用特定的正则表达式进行验证；或 Web IRI。如果一个 IRI 以 `http://` 或 `https://` 开头，后跟非空的 authority 和 path，则认为其有效，这通过使用 Python 的标准 `urllib.parse.urlparse` 函数进行稳健检查。此检查应用于 `assetAdministrationShell.id`、`submodel.id`、`assetInformation.globalAssetId` 以及每个 `Property` 的 `semanticId`。\n\n3.  **关系约束验证**：此步骤确保 AAS 实例不同部分之间关系的完整性。\n    -   **标识符唯一性**：AAS、子模型 (Submodel) 和物理资产的全局标识符（`assetAdministrationShell.id`、`submodel.id`、`assetInformation.globalAssetId`）必须两两不同。通过将它们收集到一个集合中并检查集合的大小是否等于 $3$ 来进行验证。\n    -   **`idShort` 唯一性**：在 `submodelElements` 列表中，所有 `Property` 元素必须具有唯一的 `idShort` 值。通过将所有属性的 `idShort` 收集到一个列表中，并将其长度与由该列表构造的集合的长度进行比较来检查这一点。\n    -   **引用完整性**：从 AAS 到其子模型 (Submodel) 的引用必须是正确的。验证器确认 `assetAdministrationShell.submodels` 列表中的单个对象内的 `id` 字段与 `submodel.id` 相同。\n\n4.  **语义和内容验证**：这最后阶段检查特定字段的内容和类型。\n    -   **管理信息**：检查 `administration` 对象以确保其包含 `version` 和 `revision` 键，并且它们的值是完全由数字组成的非空字符串。\n    -   **属性级别验证**：`submodelElements` 中的三个 `Property` 对象中的每一个都经过仔细检查。`modelType` 必须是字符串 `\"Property\"`。`semanticId` 必须是有效的全局标识符。`valueType` 必须是允许的字符串之一（`\"string\"`、`\"integer\"`、`\"double\"`、`\"boolean\"`）。至关重要的是，`value` 字段的类型必须与其 `valueType` 相对应。例如，如果 `valueType` 是 `\"integer\"`，则 `value` 必须是 Python `int` 类型（而不是 `bool`，因为 `bool` 是 `int` 的子类）。\n\n为执行测试套件，定义了一个 `build_instance` 函数，用于为每个测试用例以编程方式构建 AAS JSON 结构。主 `solve` 函数遍历这 $6$ 个测试用例，构建每个实例，将其传递给 `AASValidator`，并收集布尔结果。然后将最终的布尔值列表格式化为所需的单行字符串输出。",
            "answer": "```python\nimport re\nimport uuid\nfrom urllib.parse import urlparse\n\nclass AASValidator:\n    \"\"\"\n    Validates a minimal AAS instance against a set of formal rules.\n    \"\"\"\n    def __init__(self):\n        self.uuid_urn_pattern = re.compile(\n            r'^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',\n            re.IGNORECASE\n        )\n        self.idshort_pattern = re.compile(r'^[a-zA-Z][a-zA-Z0-9_]{0,127}$')\n\n    def _is_valid_idshort(self, name: str) -> bool:\n        \"\"\"Validates a referable name (idShort).\"\"\"\n        if not isinstance(name, str):\n            return False\n        return bool(self.idshort_pattern.match(name))\n\n    def _is_valid_global_id(self, identifier: str) -> bool:\n        \"\"\"Validates a globally unique identifier (IRI or URN).\"\"\"\n        if not isinstance(identifier, str):\n            return False\n        \n        # Check for UUID URN\n        if self.uuid_urn_pattern.match(identifier):\n            return True\n        \n        # Check for Web IRI with non-empty path\n        if identifier.startswith(('http://', 'https://')):\n            try:\n                parsed = urlparse(identifier)\n                # Must have scheme, network location, and a non-empty path\n                if parsed.scheme and parsed.netloc and parsed.path:\n                    return True\n            except (ValueError, TypeError):\n                return False\n        \n        return False\n\n    def _validate_administration(self, admin: dict) -> bool:\n        \"\"\"Validates the administration object.\"\"\"\n        if not isinstance(admin, dict): return False\n        version = admin.get('version')\n        revision = admin.get('revision')\n        \n        if not (version and isinstance(version, str) and version.isdigit()):\n            return False\n        if not (revision and isinstance(revision, str) and revision.isdigit()):\n            return False\n        return True\n\n    def _validate_properties(self, props: list) -> bool:\n        \"\"\"Validates the list of submodel elements (Properties).\"\"\"\n        if not isinstance(props, list) or len(props) != 3:\n            return False\n        \n        id_shorts = []\n        for prop in props:\n            if not isinstance(prop, dict): return False\n            \n            if prop.get('modelType') != 'Property': return False\n            \n            id_short = prop.get('idShort')\n            if not self._is_valid_idshort(id_short): return False\n            id_shorts.append(id_short)\n            \n            if not self._is_valid_global_id(prop.get('semanticId')): return False\n            \n            value_type = prop.get('valueType')\n            value = prop.get('value')\n            \n            type_map = {\n                'string': str, 'integer': int, 'double': float, 'boolean': bool\n            }\n            if value_type not in type_map: return False\n            \n            expected_type = type_map[value_type]\n            \n            # The value could be missing. A missing value is not of the expected type.\n            if value is None and expected_type is not type(None):\n                # A special check is needed if 'None' is a valid value, but it is not here.\n                # Here we handle missing 'value' key, which get() returns as None.\n                if 'value' not in prop: return False\n\n            if not isinstance(value, expected_type): return False\n            if value_type == 'integer' and isinstance(value, bool): return False\n\n        if len(set(id_shorts)) != len(id_shorts): return False\n        \n        return True\n\n    def validate(self, instance: dict) -> bool:\n        \"\"\"Performs a full validation of the AAS instance.\"\"\"\n        try:\n            # 1. Root structure and key existence\n            aas = instance['assetAdministrationShell']\n            sm = instance['submodel']\n            \n            aas_id = aas['id']\n            aas_idshort = aas['idShort']\n            aas_admin = aas['administration']\n            aas_asset_info = aas['assetInformation']\n            aas_submodels = aas['submodels']\n            global_asset_id = aas_asset_info['globalAssetId']\n            \n            sm_id = sm['id']\n            sm_idshort = sm['idShort']\n            sm_elements = sm['submodelElements']\n            \n            # 2. Global Identifier validity and uniqueness\n            if not all(map(self._is_valid_global_id, [aas_id, sm_id, global_asset_id])):\n                return False\n            if len({aas_id, sm_id, global_asset_id}) != 3:\n                return False\n\n            # 3. idShort validity\n            if not self._is_valid_idshort(aas_idshort) or not self._is_valid_idshort(sm_idshort):\n                return False\n                \n            # 4. Administration info\n            if not self._validate_administration(aas_admin):\n                return False\n            \n            # 5. Cardinality and References\n            if not isinstance(aas_submodels, list) or len(aas_submodels) != 1:\n                return False\n            if aas_submodels[0].get('id') != sm_id:\n                return False\n                \n            # 6. Properties validation (includes own cardinality check)\n            if not self._validate_properties(sm_elements):\n                return False\n\n        except (KeyError, TypeError, IndexError):\n            return False\n            \n        return True\n\ndef build_instance(\n    aas_idshort=\"AAS_Drive\",\n    sm_idshort=\"DriveSM\",\n    admin_info={'version': '1', 'revision': '0'},\n    aas_id=None,\n    sm_id=None,\n    asset_id=None,\n    properties=None\n):\n    \"\"\"Builds a test AAS instance dictionary.\"\"\"\n    aas_id = aas_id or f\"urn:uuid:{uuid.uuid4()}\"\n    sm_id = sm_id or f\"urn:uuid:{uuid.uuid4()}\"\n    asset_id = asset_id or f\"urn:uuid:{uuid.uuid4()}\"\n\n    if properties is None:\n        properties = [\n            {'modelType': 'Property', 'idShort': 'nominalTorque', 'valueType': 'integer', 'value': 120, 'semanticId': 'http://example.org/cd#nominalTorque'},\n            {'modelType': 'Property', 'idShort': 'ratedSpeed', 'valueType': 'double', 'value': 1500.0, 'semanticId': 'http://example.org/cd#ratedSpeed'},\n            {'modelType': 'Property', 'idShort': 'manufacturerName', 'valueType': 'string', 'value': 'Acme Motors', 'semanticId': 'http://example.org/cd#manufacturerName'}\n        ]\n\n    return {\n        'assetAdministrationShell': {\n            'id': aas_id, 'idShort': aas_idshort, 'administration': admin_info,\n            'assetInformation': {'globalAssetId': asset_id},\n            'submodels': [{'id': sm_id}]\n        },\n        'submodel': {\n            'id': sm_id, 'idShort': sm_idshort, 'submodelElements': properties\n        }\n    }\n\ndef solve():\n    \"\"\"Constructs test cases, validates them, and prints results.\"\"\"\n    test_cases = []\n\n    # Case 1: Happy path\n    test_cases.append(build_instance())\n\n    # Case 2: Boundary naming length\n    props_c2 = [p.copy() for p in build_instance()['submodel']['submodelElements']]\n    props_c2[0] = {'modelType': 'Property', 'idShort': 'A' + '_' * 127, 'valueType': 'string', 'value': 'X', 'semanticId': 'http://example.org/cd#longId'}\n    test_cases.append(build_instance(properties=props_c2))\n\n    # Case 3: Invalid Submodel referable name\n    test_cases.append(build_instance(sm_idshort=\"1SubmodelX\"))\n\n    # Case 4: Duplicate global identifiers\n    dup_id = f\"urn:uuid:{uuid.uuid4()}\"\n    test_cases.append(build_instance(aas_id=dup_id, sm_id=dup_id))\n\n    # Case 5: Missing administrative field\n    test_cases.append(build_instance(admin_info={'version': '1'}))\n\n    # Case 6: Missing Property semantic identifier\n    props_c6 = [p.copy() for p in build_instance()['submodel']['submodelElements']]\n    props_c6[2]['semanticId'] = None\n    test_cases.append(build_instance(properties=props_c6))\n\n    validator = AASValidator()\n    results = [validator.validate(case) for case in test_cases]\n\n    print(f\"[{','.join([str(r).lower() for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个结构有效但数据不可靠的AAS是没有实际价值的。本练习介绍如何使用形状约束语言 (SHACL) 来形式化地定义和执行子模型属性的数据质量规则。通过构建一个验证器，您将学会如何检查单位、数据类型和数值范围的正确性，这是实现稳健的语义互操作性的关键一步。",
            "id": "4205984",
            "problem": "您的任务是在资产管理外壳（AAS）的背景下，使用形状约束语言（SHACL）为状态监控子模型进行验证形式化。目标是构建一个与SHACL等效的形状图，并在一个抽象的资源描述框架（RDF）表示上，以编程形式实现其验证语义。其目的是检测缺失的属性和无效的属性值，通过强制实施一致的数据类型、单位和范围来支持语义互操作性。此验证必须基于形状约束语言（SHACL）、资源描述框架（RDF）以及资产管理外壳（AAS）中子模型概念的核心定义，并且必须能够纯粹地表示为对类型化数据的数学约束。\n\n定义与基本基础：\n- 一个子模型实例表示为一个有限的属性集，每个属性是一个具有以下属性的节点：一个语义标识符、一个测量值、一个声明的数据类型和一个声明的单位。形式上，一个子模型实例是一个有限关系，它将属性名称映射到一个属性元组。令所需属性的集合表示为 $\\mathcal{P} = \\{\\text{vibrationVelocityRMS}, \\text{temperature}, \\text{rotationalSpeed}\\}$。\n- 一个SHACL节点形状定义为对目标节点的一组约束。对于每个属性 $p \\in \\mathcal{P}$，约束包括：最小基数、数据类型、单位一致性（包括允许的转换）和范围界限。令每个属性的规范单位为：振动速度为 $\\text{m/s}$，温度为 $\\text{K}$，转速为 $\\text{rad/s}$。\n- 单位转换函数必须将提供的值映射到规范单位。允许的单位转换为：\n  1. 振动速度：使用 $v_{\\text{m/s}} = v_{\\text{mm/s}} \\times 10^{-3}$ 从 $\\text{mm/s} \\to \\text{m/s}$，以及使用 $v_{\\text{m/s}} = v_{\\text{m/s}}$ 从 $\\text{m/s} \\to \\text{m/s}$。\n  2. 温度：使用 $T_{\\text{K}} = T_{\\text{degC}} + 273.15}$ 从 $\\text{degC} \\to \\text{K}$，以及使用 $T_{\\text{K}} = T_{\\text{K}}$ 从 $\\text{K} \\to \\text{K}$。\n  3. 转速：使用 $\\omega_{\\text{rad/s}} = \\text{RPM} \\cdot \\frac{2\\pi}{60}$ 从 $\\text{RPM} \\to \\text{rad/s}$，以及使用 $\\omega_{\\text{rad/s}} = \\omega_{\\text{rad/s}}$ 从 $\\text{rad/s} \\to \\text{rad/s}$。\n- 范围约束在规范单位中定义：\n  1. 振动速度：$0 \\le v_{\\text{m/s}} \\le 0.05$。\n  2. 温度：$273.15 \\le T_{\\text{K}} \\le 353.15$。\n  3. 转速：$0 \\le \\omega_{\\text{rad/s}} \\le 500$。\n- 基数约束：对于每个 $p \\in \\mathcal{P}$，最小计数为 $1$（必须存在）。\n- 数据类型约束：对于每个属性值 $x$，其Python级别的类型必须对应于一个数值（实数），即 $x \\in \\mathbb{R}$。\n\n您的程序必须：\n1. 构建一个与SHACL等效的形状图作为内部数据结构，该结构为每个属性 $p \\in \\mathcal{P}$ 编码：规范单位、允许的单位转换、数据类型要求（实值）以及包含性范围界限。\n2. 实现一个验证器，该验证器对每个子模型实例执行以下操作：\n   - 检查存在性：如果所需的属性 $p$ 缺失，记录一个违规。\n   - 检查数据类型：如果存在的值不是实数，记录一个违规。\n   - 检查单位：如果声明的单位不在 $p$ 的允许可转换单位之列，记录一个违规。\n   - 使用上述公式执行到规范单位的单位转换，然后检查范围：如果转换后的值落在包含性界限之外，记录一个违规。\n   - 一个子模型实例当且仅当违规总数为 $0$ 时被视为有效。\n3. 将验证器应用于以下子模型实例的测试套件。所有物理量必须按其指定的声明单位进行解释和验证。规范单位如上定义；在范围检查之前必须进行单位转换以产生规范单位。适用时，角度必须以弧度处理。给定的输入包括值和单位；您必须在必要时转换为规范单位。明确地，值应被视为实数，并且必须遵守包含性界限。\n\n测试套件：\n- 测试用例 $1$（正常路径）：\n  - $\\text{vibrationVelocityRMS} = 4.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 310.0$，单位为 $\\text{K}$。\n  - $\\text{rotationalSpeed} = 1800.0$，单位为 $\\text{RPM}$。\n- 测试用例 $2$（缺失属性）：\n  - $\\text{vibrationVelocityRMS} = 2.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature}$ 缺失。\n  - $\\text{rotationalSpeed} = 120.0$，单位为 $\\text{rad/s}$。\n- 测试用例 $3$（无效数据类型）：\n  - $\\text{vibrationVelocityRMS} = 1.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 300.0$，单位为 $\\text{K}$。\n  - $\\text{rotationalSpeed} = \"100\"$（一个字符串），单位为 $\\text{rad/s}$。\n- 测试用例 $4$（无效单位）：\n  - $\\text{vibrationVelocityRMS} = 3.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 100.0$，单位为 $\\text{F}$。\n  - $\\text{rotationalSpeed} = 50.0$，单位为 $\\text{rad/s}$。\n- 测试用例 $5$（边界条件）：\n  - $\\text{vibrationVelocityRMS} = 50.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 273.15$，单位为 $\\text{K}$。\n  - $\\text{rotationalSpeed} = 500.0$，单位为 $\\text{rad/s}$。\n\n答案规范：\n- 对于每个测试用例，生成一个对 $[b, n]$，其中 $b$ 是一个布尔值，指示实例是否有效， $n$ 是检测到的违规整数计数。\n- 您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，且不含空格，例如 $[[\\text{True},0],[\\text{False},2],\\ldots]$。\n\n不允许外部输入。所有常量和转换都必须在程序内部实现。数值结果必须使用上述规则精确计算。输出仅包含布尔值和整数，按指定格式显示，占一行，无额外文本。",
            "solution": "我们首先使用形状约束语言（SHACL）和资源描述框架（RDF）的定义，在资产管理外壳（AAS）的背景下，将验证问题形式化。一个状态监控子模型的实例可以表示为从属性名到属性元组的有限映射。令强制属性集为 $\\mathcal{P} = \\{\\text{vibrationVelocityRMS}, \\text{temperature}, \\text{rotationalSpeed}\\}$。对于每个属性 $p \\in \\mathcal{P}$，SHACL节点形状指定以下约束：(i) 最小基数为 $1$（存在性），(ii) 要求为实值数值类型的数据类型约束，(iii) 在一个允许集合下的单位一致性，该集合提供到规范单位的转换，以及 (iv) 在规范单位下的包含性范围界限。\n\n我们将形状图编码为一个结构化映射。对于每个属性 $p$，我们存储：\n- 规范单位 $u_p$。\n- 一组允许的单位，及其到 $u_p$ 的转换，由形式为 $$y = a \\cdot x + b$$ 的线性变换指定，其中 $x$ 是所提供单位的给定值， $y$ 是转换后规范单位下的值。具体来说：\n  - 对于振动速度，对于 $\\text{mm/s}$，我们使用 $y = 10^{-3} \\cdot x$；对于 $\\text{m/s}$，我们使用 $y = 1 \\cdot x$。规范单位为 $\\text{m/s}$。\n  - 对于温度，对于 $\\text{degC}$，我们使用 $y = 1 \\cdot x + 273.15$；对于 $\\text{K}$，我们使用 $y = 1 \\cdot x$。规范单位为 $\\text{K}$。\n  - 对于转速，对于 $\\text{RPM}$，我们使用 $y = \\frac{2\\pi}{60} \\cdot x$；对于 $\\text{rad/s}$，我们使用 $y = 1 \\cdot x$。规范单位为 $\\text{rad/s}$。\n- 在规范单位下的包含性界限 $[\\ell_p, u_p]$，即：\n  - 振动速度：$[0, 0.05]$，单位为 $\\text{m/s}$。\n  - 温度：$[273.15, 353.15]$，单位为 $\\text{K}$。\n  - 转速：$[0, 500]$，单位为 $\\text{rad/s}$。\n\n验证器源自SHACL语义：\n1. 存在性规则：对于每个 $p \\in \\mathcal{P}$，强制 $\\text{minCount} \\ge 1$。如果属性 $p$ 缺失，记录一个违规。\n2. 数据类型规则：如果属性 $p$ 存在，检查其值 $x$ 是否为实值，即 $x \\in \\mathbb{R}$。如果不是，记录一个违规。在程序中，我们检查Python级别的类型是否对应于数值类型（整数或浮点数）以表示 $\\mathbb{R}$ 的元素。\n3. 单位一致性与转换：如果 $p$ 的声明单位 $u$ 不在允许的集合中，记录一个违规。如果 $u$ 是允许的，应用转换 $y = a \\cdot x + b$ 以获得规范值 $y$。\n4. 范围规则：一旦转换为规范单位，检查包含性界限 $\\ell_p \\le y \\le u_p$。如果不满足，记录一个违规。\n\n一个子模型实例当且仅当违规总数为 $0$ 时有效。这对应于SHACL节点形状语义下所有属性约束的逻辑合取。\n\n我们将此应用于测试套件：\n\n- 测试用例 $1$：\n  - $\\text{vibrationVelocityRMS} = 4.0$ $\\text{mm/s}$ 转换为 $y = 4.0 \\cdot 10^{-3} = 0.004$ $\\text{m/s}$，且 $0 \\le 0.004 \\le 0.05$ 成立。\n  - $\\text{temperature} = 310.0$ $\\text{K}$ 无需转换，且满足 $273.15 \\le 310.0 \\le 353.15$。\n  - $\\text{rotationalSpeed} = 1800.0$ $\\text{RPM}$ 转换为 $y = 1800.0 \\cdot \\frac{2\\pi}{60} = 60\\pi \\approx 188.4955592$ $\\text{rad/s}$，且 $0 \\le 188.4955592 \\le 500$ 成立。\n  - 违规数：$0$。有效：$\\text{True}$。\n\n- 测试用例 $2$：\n  - $\\text{vibrationVelocityRMS} = 2.0$ $\\text{mm/s}$ 转换为 $0.002$ $\\text{m/s}$，在范围内。\n  - $\\text{temperature}$ 缺失，违反了 $\\text{minCount} \\ge 1$。\n  - $\\text{rotationalSpeed} = 120.0$ $\\text{rad/s}$ 在范围内。\n  - 违规数：$1$。有效：$\\text{False}$。\n\n- 测试用例 $3$：\n  - $\\text{vibrationVelocityRMS} = 1.0$ $\\text{mm/s}$ 转换为 $0.001$ $\\text{m/s}$，在范围内。\n  - $\\text{temperature} = 300.0$ $\\text{K}$ 在范围内。\n  - $\\text{rotationalSpeed} = \"\\!100\"$ 不是实值，违反了数据类型约束；单位是允许的，但由于数据类型无效，跳过了转换和范围检查。\n  - 违规数：$1$。有效：$\\text{False}$。\n\n- 测试用例 $4$：\n  - $\\text{vibrationVelocityRMS} = 3.0$ $\\text{mm/s}$ 转换为 $0.003$ $\\text{m/s}$，在范围内。\n  - $\\text{temperature} = 100.0$ 的单位为 $\\text{F}$，不在允许的集合 $\\{\\text{K}, \\text{degC}\\}$ 中，违反了单位一致性（不执行转换）。\n  - $\\text{rotationalSpeed} = 50.0$ $\\text{rad/s}$ 在范围内。\n  - 违规数：$1$。有效：$\\text{False}$。\n\n- 测试用例 $5$：\n  - $\\text{vibrationVelocityRMS} = 50.0$ $\\text{mm/s}$ 转换为 $0.05$ $\\text{m/s}$，恰好在上限，包含性界限允许这种情况。\n  - $\\text{temperature} = 273.15$ $\\text{K}$ 恰好在下限，允许。\n  - $\\text{rotationalSpeed} = 500.0$ $\\text{rad/s}$ 恰好在上限，允许。\n  - 违规数：$0$。有效：$\\text{True}$。\n\n因此，每个测试用例的预期输出为 $[\\text{True}, 0]$、$[\\text{False}, 1]$、$[\\text{False}, 1]$、$[\\text{False}, 1]$ 和 $[\\text{True}, 0]$。最终输出格式为一行，包含这些对的列表，以逗号分隔，并用方括号括起来，不含空格，即 $[[\\text{True},0],[\\text{False},1],[\\text{False},1],[\\text{False},1],[\\text{True},0]]$。\n\n程序按规定构建形状图，根据SHACL语义实现验证器，将其应用于测试套件，并打印单行结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_shape_graph():\n    \"\"\"\n    Construct a SHACL-equivalent shape graph for the Condition Monitoring Submodel.\n    Each property has:\n      - canonical_unit: the unit to which all values are converted\n      - converters: mapping from allowed unit to (factor, offset) for linear conversion y = factor*x + offset\n      - min_value and max_value: inclusive bounds in canonical units\n    \"\"\"\n    shape = {\n        \"vibrationVelocityRMS\": {\n            \"canonical_unit\": \"m/s\",\n            \"converters\": {\n                \"m/s\": (1.0, 0.0),\n                \"mm/s\": (1e-3, 0.0),\n            },\n            \"min_value\": 0.0,\n            \"max_value\": 0.05,\n        },\n        \"temperature\": {\n            \"canonical_unit\": \"K\",\n            \"converters\": {\n                \"K\": (1.0, 0.0),\n                \"degC\": (1.0, 273.15),  # T_K = T_degC + 273.15\n            },\n            \"min_value\": 273.15,\n            \"max_value\": 353.15,\n        },\n        \"rotationalSpeed\": {\n            \"canonical_unit\": \"rad/s\",\n            \"converters\": {\n                \"rad/s\": (1.0, 0.0),\n                \"RPM\": (2.0 * np.pi / 60.0, 0.0),  # omega_rad/s = RPM * 2*pi/60\n            },\n            \"min_value\": 0.0,\n            \"max_value\": 500.0,\n        },\n    }\n    return shape\n\ndef is_real_number(x):\n    \"\"\"Check if x is a real-number type (int or float) excluding booleans.\"\"\"\n    # Booleans are instances of int in Python, so exclude them explicitly.\n    return isinstance(x, (int, float)) and not isinstance(x, bool)\n\ndef validate_submodel(instance, shape):\n    \"\"\"\n    Validate a single submodel instance against the shape.\n    Returns (is_valid: bool, violations_count: int).\n    Rules:\n      - Missing required property => +1 violation\n      - Non-numeric value => +1 violation\n      - Unit not in converters => +1 violation\n      - Converted value outside inclusive [min_value, max_value] => +1 violation\n    \"\"\"\n    violations = 0\n    props = instance.get(\"properties\", {})\n\n    for prop_name, constraints in shape.items():\n        if prop_name not in props:\n            violations += 1\n            continue\n\n        prop = props[prop_name]\n        value = prop.get(\"value\", None)\n        unit = prop.get(\"unit\", None)\n\n        # Datatype validation\n        if not is_real_number(value):\n            violations += 1\n            # Skip further checks for this property since value is invalid\n            # (prevents double-counting due to failed conversion or range)\n            continue\n\n        # Unit conformity\n        converters = constraints[\"converters\"]\n        if unit not in converters:\n            violations += 1\n            # Skip conversion and range check since unit is invalid\n            continue\n\n        factor, offset = converters[unit]\n        canonical_value = factor * float(value) + offset\n\n        # Range check (inclusive)\n        min_v = constraints[\"min_value\"]\n        max_v = constraints[\"max_value\"]\n        if not (min_v = canonical_value = max_v):\n            violations += 1\n\n    is_valid = (violations == 0)\n    return is_valid, violations\n\ndef render_no_spaces(results):\n    \"\"\"\n    Render the results list with no spaces, handling nested lists and booleans/ints.\n    Example: [[True,0],[False,1]] (no spaces).\n    \"\"\"\n    def render_item(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(render_item(x) for x in item) + \"]\"\n        elif isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, (int, float)):\n            # For floats, use default str conversion\n            return str(item)\n        else:\n            # Should not occur; we only expect bool/int/float or lists thereof.\n            return str(item)\n    return \"[\" + \",\".join(render_item(x) for x in results) + \"]\"\n\ndef solve():\n    shape = build_shape_graph()\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 4.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 310.0, \"datatype\": \"xsd:double\", \"unit\": \"K\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 1800.0, \"datatype\": \"xsd:double\", \"unit\": \"RPM\"},\n            },\n        },\n        # Test case 2 (missing temperature)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 2.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                # \"temperature\" missing\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 120.0, \"datatype\": \"xsd:double\", \"unit\": \"rad/s\"},\n            },\n        },\n        # Test case 3 (invalid datatype for rotationalSpeed)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 1.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 300.0, \"datatype\": \"xsd:double\", \"unit\": \"K\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": \"100\", \"datatype\": \"xsd:string\", \"unit\": \"rad/s\"},\n            },\n        },\n        # Test case 4 (invalid unit for temperature)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 3.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 100.0, \"datatype\": \"xsd:double\", \"unit\": \"F\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 50.0, \"datatype\": \"xsd:double\", \"unit\": \"rad/s\"},\n            },\n        },\n        # Test case 5 (boundary conditions)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 50.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 273.15, \"datatype\": \"xsd:double\", \"unit\": \"K\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 500.0, \"datatype\": \"xsd:double\", \"unit\": \"rad/s\"},\n            },\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        is_valid, violations = validate_submodel(case, shape)\n        results.append([is_valid, violations])\n\n    # Final print statement in the exact required format (no spaces).\n    print(render_no_spaces(results))\n\nsolve()\n```"
        }
    ]
}