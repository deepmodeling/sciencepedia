{
    "hands_on_practices": [
        {
            "introduction": "在构建信息物理系统的知识图谱时，首要任务是使用本体（ontology）来创建一个清晰、无歧义的词汇表。网络本体语言（OWL）不仅允许我们通过名称来定义类别，更重要的是，它允许我们根据其成员必须满足的逻辑条件来定义类别，例如它们关系的數量和类型。这项练习  让你亲手实践如何将一个具体需求——传感设备必须至少有一个测量输出——转化为一个使用基数限制（cardinality restrictions）的正式OWL类表达式，这是精确语义建模的基石。",
            "id": "4228925",
            "problem": "您正在信息物理系统（CPS）的知识图谱和语义表示领域工作，专注于设备及其输出的Web本体语言（OWL）类建模。此问题的基础是作为OWL基础的描述逻辑（DL）的模型论语义，其中类被解释为集合，属性被解释为论域上的二元关系。具体来说，请依赖以下基本原理：\n- 一个解释将每个类符号賦值为域的一个子集，并将每个属性符号賦值为域上的一个二元关系。\n- 对属性的基数限制计算在该属性下满足给定类成员资格的不同后继的数量，这与集合论计数和关系组合保持一致。\n\n目标：为必须具有至少一个 Measurement 输出的 SensingDevice 构建 OWL 类表达式，并演示如何使用带有最小基数的 OWL 限制来捕获此要求。然后，实现一个算法，该算法在给定一个由个体类型和属性边组成的有限知识图谱的情况下，判断每个测试实例是否满足限定的最小基数要求。\n\n使用的定义：\n- 令 $\\Delta^{I}$ 表示解释的论域。\n- 令 $P^{I} \\subseteq \\Delta^{I} \\times \\Delta^{I}$ 表示属性的解释。\n- 令 $C^{I} \\subseteq \\Delta^{I}$ 表示类的解释。\n- 对于一个个体 $x \\in \\Delta^{I}$，如果其在 $C^{I}$ 中的不同 $P^{I}$-后继的数量至少为 $n$（其中 $n \\ge 0$ 为某个整数），则称其满足限定最小基数限制。\n\n任务详情：\n1. 使用关于类 “Measurement” 的属性 “hasOutput” 的限定最小基数限制（最小计数 $n = 1$），为“至少有一个 Measurement 输出的 SensingDevice”构建类表达式。不要在问题陈述中直接给出目标公式；相反，您的算法解决方案必须从前述的解释和基数基本原理中推导出它。\n2. 实现一个程序，该程序：\n   - 表示一个包含个体、其类型以及 “hasOutput” 属性邻接结构的小型知识图谱。\n   - 对于每个测试用例设备，通过计算类型为 Measurement 的不同后继的数量，来计算其是否满足“hasOutput 至少 $1$ 个 Measurement”的限定最小基数要求。\n   - 为每个测试用例返回一个布尔值，以指示是否满足要求。\n\n假设：\n- 计数是针对不同的后继进行的，即如果存在指向同一个体的重复边，它们对基数的贡献仅为一次。\n- 仅当 $y$ 的类型为 Measurement 时，边 $(x,y)$ 才会计入总数。\n- 没有属性边则计数为 $0$。\n\n测试套件：\n使用以下六个测试用例。每个用例都是单个设备标识符的类型和属性边的独立配置。关注的属性是 “hasOutput”，目标类是 “Measurement”，限定的最小基数为 $1$。\n\n- 用例 A（正常路径）：设备 $s_1$ 有一个输出 $m_1$；$m_1$ 的类型为 Measurement。\n  - 类型：$s_1 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$\n  - 边：$(s_1, \\text{hasOutput}, m_1)$\n  - 预期布尔值：True\n\n- 用例 B（边界情况：重复的边不会增加基数）：设备 $s_2$ 有两条指向同一输出 $m_1$ 的边；$m_1$ 的类型为 Measurement；不同后继的计数为 $1$。\n  - 类型：$s_2 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$\n  - 边：$(s_2, \\text{hasOutput}, m_1)$ 两次\n  - 预期布尔值：True\n\n- 用例 C（边缘情况：零输出）：设备 $s_3$ 没有输出。\n  - 类型：$s_3 \\mapsto \\{\\text{SensingDevice}\\}$\n  - 边：无\n  - 预期布尔值：False\n\n- 用例 D（失败情况：只有非 Measurement 类型的输出）：设备 $s_4$ 有一个输出 $nm_1$；$nm_1$ 的类型为 NonMeasurement。\n  - 类型：$s_4 \\mapsto \\{\\text{SensingDevice}\\}$, $nm_1 \\mapsto \\{\\text{NonMeasurement}\\}$\n  - 边：$(s_4, \\text{hasOutput}, nm_1)$\n  - 预期布尔值：False\n\n- 用例 E（混合输出）：设备 $s_5$ 有输出 $m_2$ 和 $nm_1$；$m_2$ 的类型为 Measurement；$nm_1$ 的类型为 NonMeasurement；不同的 Measurement 输出计数为 $1$。\n  - 类型：$s_5 \\mapsto \\{\\text{SensingDevice}\\}$, $m_2 \\mapsto \\{\\text{Measurement}\\}$, $nm_1 \\mapsto \\{\\text{NonMeasurement}\\}$\n  - 边：$(s_5, \\text{hasOutput}, m_2)$ 和 $(s_5, \\text{hasOutput}, nm_1)$\n  - 预期布尔值：True\n\n- 用例 F（多个不同的 Measurement 输出）：设备 $s_6$ 有输出 $m_1$ 和 $m_2$；两者类型均为 Measurement；不同后继的计数为 $2 \\ge 1$。\n  - 类型：$s_6 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$, $m_2 \\mapsto \\{\\text{Measurement}\\}$\n  - 边：$(s_6, \\text{hasOutput}, m_1)$ 和 $(s_6, \\text{hasOutput}, m_2)$\n  - 预期布尔值：True\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”），其中每个结果是按顺序对应于用例 A 到 F 的布尔值。",
            "solution": "此问题是有效的。它在科学上植根于描述逻辑（DL）的形式化模型论语义，而描述逻辑是Web本体语言（OWL）的基础。该问题定义明确，提供了清晰的目标、完整的定义和一套无歧义的测试用例。它正确地要求用户将限定基数限制的形式化定义应用于实际的验证算法。\n\n此问题的核心是在知识图谱中对一类对象的陈述进行形式化和验证。该陈述是：“一个 `SensingDevice` 至少有一个作为 `Measurement` 的输出。” 这是为信息物理系统（CPS）设计本体时常见的建模模式，在此类系统中，确保数据完整性和正确的系统组装至关重要。\n\n我们首先使用描述逻辑的概念来形式化该陈述。设基类为 $SensingDevice$，属性为 $hasOutput$，输出的限定类为 $Measurement$。该要求可以表示为一个复杂的类定义，即基类与其属性限制的交集（合取）。\n\n该限制是一个限定最小基数限制。在 DL 语法中，它写作 $(\\ge n \\ P.C)$，其中 $n$ 是连接的最小数量，$P$ 是属性，$C$ 是通过 $P$ 连接的对象的限定类。对于我们的特定情况，属性 $P$ 是 $hasOutput$，限定类 $C$ 是 $Measurement$，连接的最小数量 $n$ 是 $1$。因此，该限制是 $(\\ge 1 \\ hasOutput.Measurement)$。\n\n“至少有一个 Measurement 输出的 SensingDevice”的完整类表达式是基类与此限制的交集：\n$$\nSensingDevice \\sqcap (\\ge 1 \\ hasOutput.Measurement)\n$$\n其中 $\\sqcap$ 表示类交集运算符。\n\n为了理解如何验证此形式化表达式，我们转向所提供的模型论语义。一个解释 $\\mathcal{I} = (\\Delta^{\\mathcal{I}}, \\cdot^{\\mathcal{I}})$ 由一个非空个体域 $\\Delta^{\\mathcal{I}}$ 和一个解释函数 $\\cdot^{\\mathcal{I}}$ 组成，该函数将类名映射到 $\\Delta^{\\mathcal{I}}$ 的子集，将属性名映射到 $\\Delta^{\\mathcal{I}}$ 上的二元关系。\n\n一个个体 $x \\in \\Delta^{\\mathcal{I}}$ 是类表达式 $SensingDevice \\sqcap (\\ge 1 \\ hasOutput.Measurement)$ 的一个实例，当且仅当它满足合取的两个部分：\n$1$. $x \\in (SensingDevice)^{\\mathcal{I}}$\n$2$. $x \\in (\\ge 1 \\ hasOutput.Measurement)^{\\mathcal{I}}$\n\n第一个条件仅意味着个体 $x$ 的类型必须是 $SensingDevice$。第二个条件由限定最小基数限制的语义定义。如果个体 $x$ 通过 $hasOutput$ 属性连接的、同时也是 $Measurement$ 类成员的不同后继集合的基数大于或等于 $1$，则该个体 $x$ 满足此条件。形式化地表示为：\n$$\n|\\{ y \\in \\Delta^{\\mathcal{I}} \\mid (x, y) \\in (hasOutput)^{\\mathcal{I}} \\land y \\in (Measurement)^{\\mathcal{I}} \\}| \\ge 1\n$$\n这里，$(hasOutput)^{\\mathcal{I}}$ 是所有通过 $hasOutput$ 属性关联的对 $(u,v)$ 的集合，而 $(Measurement)^{\\mathcal{I}}$ 是所有类型为 $Measurement$ 的个体的集合。集合 $\\{ y \\in \\Delta^{\\mathcal{I}} \\mid \\dots \\}$ 收集了所有通过 $hasOutput$ 连接到 $x$ 且类型为 $Measurement$ 的不同个体 $y$。运算符 $|\\cdot|$ 计算该集合的大小。\n\n在有限知识图谱中为给定设备验证此条件的算法直接实现了此语义定义。\n$1$. **识别**待检查的**设备（$x$）**，该设备来自测试用例。\n$2$. **检索**通过 $hasOutput$ 属性连接到 $x$ 的所有**后继（$y$）**。这对应于在图中找到所有使得边 $(x, \\text{hasOutput}, y)$ 存在的 $y$。问题规定，没有边则计数为 $0$，如果该集合为空，则自然满足此情况。\n$3$. **确保唯一性**。语义定义计算集合中的元素，因此任何重复的后继必须只计算一次。这通过创建一个后继个体的集合来实现。\n$4$. **按类型筛选**。对于每个不同的后继 $y$，我们检查它是否是 $Measurement$ 类的一个实例。这对应于检查 $y \\in (Measurement)^{\\mathcal{I}}$。\n$5$. **计数和比较**。我们计算满足类型要求的不同后继的数量。设此计数为 $c$。如果 $c \\ge 1$，则条件满足。\n\n这个分步过程应用于所提供的六个测试用例中的每一个，从而产生一个布尔结果，指示每个用例中的设备是否是所定义类的成员。例如，在用例 E 中，设备 $s_5$ 有两个不同的后继，$m_2$ 和 $nm_1$。其中，只有 $m_2$ 的类型是 $Measurement$。因此，符合条件的后继计数为 $1$。由于 $1 \\ge 1$，条件得到满足，结果为 True。在用例 D 中，设备 $s_4$ 有一个后继 $nm_1$，其类型不是 $Measurement$。计数为 $0$。由于 $0  1$，条件未得到满足，结果为 False。此逻辑一致地应用于所有用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Validates devices against a qualified minimum cardinality restriction.\n    \n    The problem asks to implement a check for the Description Logic class expression:\n    SensingDevice ⊓ (≥ 1 hasOutput.Measurement)\n    \n    This means for a device to be valid, it must have at least one distinct\n    successor via the 'hasOutput' property that is of type 'Measurement'.\n    \"\"\"\n\n    # Test suite definition. Each case represents a small knowledge graph\n    # configuration for a single device under test.\n    # Structure: (device_id_to_check, types_dictionary, edges_dictionary)\n    # - types_dictionary: maps individual IDs to a set of their class types.\n    # - edges_dictionary: maps a source ID to a list of target IDs for the\n    #   'hasOutput' property.\n    test_cases = [\n        # Case A: Happy path. s1 has one Measurement output.\n        (\n            's1',\n            {'s1': {'SensingDevice'}, 'm1': {'Measurement'}},\n            {'s1': ['m1']}\n        ),\n        # Case B: Boundary. Duplicate edges to the same output count as one.\n        (\n            's2',\n            {'s2': {'SensingDevice'}, 'm1': {'Measurement'}},\n            {'s2': ['m1', 'm1']}\n        ),\n        # Case C: Edge case. s3 has no outputs.\n        (\n            's3',\n            {'s3': {'SensingDevice'}},\n            {} # No edges for s3\n        ),\n        # Case D: Failure. s4's only output is not a Measurement.\n        (\n            's4',\n            {'s4': {'SensingDevice'}, 'nm1': {'NonMeasurement'}},\n            {'s4': ['nm1']}\n        ),\n        # Case E: Mixed outputs. s5 has one Measurement and one non-Measurement.\n        (\n            's5',\n            {'s5': {'SensingDevice'}, 'm2': {'Measurement'}, 'nm1': {'NonMeasurement'}},\n            {'s5': ['m2', 'nm1']}\n        ),\n        # Case F: Multiple distinct Measurement outputs.\n        (\n            's6',\n            {'s6': {'SensingDevice'}, 'm1': {'Measurement'}, 'm2': {'Measurement'}},\n            {'s6': ['m1', 'm2']}\n        ),\n    ]\n\n    results = []\n    # Parameters for the qualified cardinality restriction\n    target_class = 'Measurement'\n    min_cardinality = 1\n\n    for device_id, types, edges in test_cases:\n        # Retrieve the list of successors for the device via 'hasOutput'.\n        # If the device has no outgoing edges, .get() returns an empty list.\n        successors = edges.get(device_id, [])\n\n        # The semantics require counting *distinct* successors. A set handles this.\n        distinct_successors = set(successors)\n\n        # Count the number of distinct successors that are of the target class.\n        qualified_count = 0\n        for successor_id in distinct_successors:\n            # Get the types of the successor. Default to an empty set if not found.\n            successor_types = types.get(successor_id, set())\n            if target_class in successor_types:\n                qualified_count += 1\n        \n        # Check if the count meets the minimum cardinality requirement.\n        is_satisfied = qualified_count >= min_cardinality\n        results.append(is_satisfied)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str, ...) converts each boolean (True/False) to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个形式化的本体定义了哪些陈述*可能*为真，但我们还需要确保知识图谱中的实际数据是完整且符合业务规则的。形状约束语言（SHACL）正是为此目的而设计的，它允许我们定义数据必须符合的“形状”（shapes），作为图谱之上的数据验证层。这项实践  要求你实现一个SHACL验证器，以检查诸如属性缺失、数据类型错误以及数值超出可接受范围等问题，这对于在信息物理系统中维护高质量知识图谱至关重要。",
            "id": "4228930",
            "problem": "考虑一个在网络物理系统（CPS）背景下，使用形状约束语言（SHACL）对知识图谱（KG）进行的简化验证任务。KG被建模为一个有限的资源描述框架（RDF）图，包含节点、属性和类型化值。你需要实现一个验证器，在给定一个KG片段和一组SHACL形状的情况下，计算违规总数和导致至少一次违规的节点集合。该任务要求基于形式化定义和约束进行精确实现。\n\n基本基础：\n- 资源描述框架（RDF）将三元组定义为 $$(s,p,o) \\in N \\times P \\times (N \\cup L),$$，其中 $N$ 是国际化资源标识符（IRI）的集合，$P$ 是属性（IRI）的集合，$L$ 是类型化字面量的集合。一个类型化字面量是一个对 $(v, d)$，其中 $v$ 是一个值，$d$ 是一个数据类型。\n- 形状约束语言（SHACL）通过形状来定义对节点的约束。一个形状 $S$ 将一个目标类 $C$（由一个IRI标识）与一组属性形状相关联，这些属性形状限制了通过属性路径（IRI）可达的值。属性形状可以约束：最小数量（$\\text{minCount}$）、最大数量（$\\text{maxCount}$）、节点种类（IRI或字面量）、数据类型（例如，整数、浮点数、字符串）以及数值范围（最小包含、最大包含或最小排除）。一个封闭形状也可以限制允许的属性集合。\n\n要实现的验证器语义：\n- 如果一个节点 $n \\in N$ 有一个RDF类型三元组 $(n, \\text{rdf:type}, C)$，其中 $C$ 是形状 $S$ 的目标类，则该节点将根据形状 $S$ 进行验证。\n- 对于每个路径为 $p$ 的属性形状：\n  - 数量约束：如果在节点 $n$ 处属性 $p$ 的值的数量小于 $\\text{minCount}$ 或超过 $\\text{maxCount}$，则为该属性形状记录一次违规。\n  - 节点种类约束：对于 $p$ 的每个值，如果一个值不是预期的种类（IRI或字面量），则为每个违规值记录一次违规。\n  - 数据类型约束：对于 $p$ 的每个字面量值，如果其数据类型与预期的数据类型不匹配，则为每个违规值记录一次违规。\n  - 数值范围：对于每个数值型字面量值（视情况为整数或浮点数），如果它违反了某个范围（小于 $\\text{minInclusive}$，大于 $\\text{maxInclusive}$，或不严格大于 $\\text{minExclusive}$），则为每个违规值记录一次违规。\n- 对于一个封闭形状，如果一个节点有任何不在允许集合中的属性，则为每个多余的属性记录一次违规（无论其基数如何）。\n- 违规总数是所有形状和节点上记录的所有违规的总和。如果一个节点在任何适用的形状下有至少一次记录的违规，则该节点被认为是“导致”违规的。\n\n缩略语：\n- 知识图谱 (KG)\n- 资源描述框架 (RDF)\n- 形状约束语言 (SHACL)\n- 网络物理系统 (CPS)\n\n所有测试用例中使用的形状：\n- 传感器形状，目标类IRI为 \"ex:Sensor\"：\n  - 属性 \"ex:hasSamplingPeriod\"：节点种类为字面量，数据类型为整数，$\\text{minCount} = 1$，$\\text{minInclusive} = 1$，$\\text{maxInclusive} = 60$。\n  - 属性 \"ex:connectedTo\"：节点种类为IRI，$\\text{minCount} = 1$。\n- 执行器形状，目标类IRI为 \"ex:Actuator\"：\n  - 属性 \"ex:hasPowerRating\"：节点种类为字面量，数据类型为浮点数，$\\text{minExclusive} = 0$。\n  - 属性 \"ex:controlledBy\"：节点种类为IRI，$\\text{minCount} = 1$，$\\text{maxCount} = 1$。\n- 控制器形状，目标类IRI为 \"ex:Controller\"：\n  - 属性 \"ex:controls\"：节点种类为IRI，$\\text{minCount} = 2$。\n  - 封闭形状：除了总是被允许的 $\\{\\text{rdf:type}\\}$ 外，只允许在允许集合 $\\{\\text{ex:controls}\\}$ 中的属性。\n\nKG表示：\n- 每个节点都是从属性IRI到值列表的映射。\n- 一个值可以是IRI或字面量。字面量由一个Python值和一个数据类型IRI表示。数值型字面量适当地使用Python整数或浮点数。\n\n你的任务：\n- 根据上述语义实现验证器。\n- 将其应用于下面的测试套件。\n- 对于每个测试用例，输出一个由违规总数和导致至少一次违规的节点IRI的排序列表组成的对。\n\n测试套件：\n- 测试用例 $1$ (一般情况)：\n  - 节点：\n    - \"ex:S1\": \n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 值为 $0$ 的整数字面量\n      - \"ex:connectedTo\": 不存在\n    - \"ex:S2\":\n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 值为 $10$ 的整数字面量\n      - \"ex:connectedTo\": [\"ex:A1\"]\n    - \"ex:A1\":\n      - \"rdf:type\": [\"ex:Actuator\"]\n      - \"ex:hasPowerRating\": 值为 $-5.0$ 的浮点数字面量\n      - \"ex:controlledBy\": [\"ex:C1\"]\n    - \"ex:C1\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": [\"ex:S2\", \"ex:A1\"]\n      - \"ex:hasExtraProperty\": 值为 \"foo\" 的字符串字面量\n    - \"ex:U1\":\n      - \"rdf:type\": [\"ex:Unknown\"]\n      - \"ex:random\": 值为 \"bar\" 的字符串字面量\n- 测试用例 $2$ (除一个严格边界外，边界条件均满足)：\n  - 节点：\n    - \"ex:S3\":\n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 值为 $60$ 的整数字面量\n      - \"ex:connectedTo\": [\"ex:A2\"]\n    - \"ex:A2\":\n      - \"rdf:type\": [\"ex:Actuator\"]\n      - \"ex:hasPowerRating\": 值为 $0.0$ 的浮点数字面量\n      - \"ex:controlledBy\": [\"ex:C2\"]\n    - \"ex:C2\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": [\"ex:S3\", \"ex:A2\"]\n- 测试用例 $3$ (数据类型和节点种类不匹配以及数量违规的边缘情况)：\n  - 节点：\n    - \"ex:S4\":\n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 值为 \"ten\" 的字符串字面量\n      - \"ex:connectedTo\": 值为 \"ex:C3\" 的字符串字面量\n    - \"ex:A3\":\n      - \"rdf:type\": [\"ex:Actuator\"]\n      - \"ex:hasPowerRating\": 值为 $10.0$ 的浮点数字面量\n      - \"ex:controlledBy\": [\"ex:C3\", \"ex:C4\"]\n    - \"ex:C3\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": []\n    - \"ex:C4\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": [\"ex:S4\"]\n\n最终输出规范：\n- 你的程序应该生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个结果的形式为 $[v, L]$，其中 $v$ 是一个整数违规计数，$L$ 是一个导致违规的节点IRI的排序列表。例如，输出应如下所示：$$[[v_1, L_1],[v_2, L_2],[v_3, L_3]]$$，除了列表格式固有的空格外，没有其他空格。在每个 $L$ 中，节点IRI应按升序字典序排序。",
            "solution": "用户提供了一个问题，要求基于形状约束语言（SHACL）的一个子集，为知识图谱（KG）实现一个验证器。该问题定义明确，科学地基于RDF和SHACL的原则，并提供了一套清晰的规则和测试用例。因此，该问题被认为是有效的。\n\n解决方案将通过首先使用Python数据结构对KG和SHACL形状进行建模，然后创建一个系统地应用指定规则的验证函数来实现。\n\n**1. 数据表示**\n\n*   **知识图谱（KG）：** KG将表示为一个字典，将节点IRI（字符串）映射到其属性。每个属性又是一个字典，将属性IRI（字符串）映射到一个值列表。\n*   **值：** 一个值可以是国际化资源标识符（IRI）或字面量。\n    *   IRI由Python `str`表示。\n    *   字面量由Python `tuple`表示，形式为 `(value, datatype_iri)`，其中 `value` 是字面量的值（例如 `int`、`float` 或 `str`），`datatype_iri` 是标识数据类型的 `str`（例如 `\"integer\"`、`\"float\"`）。\n*   **SHACL形状：** 形状集将表示为一个字典，其键是目标类IRI（字符串）。每个值都是一个字典，定义了该形状的约束，包括属性形状和该形状是否封闭。\n\n**2. 验证器设计**\n\n解决方案的核心是一个 `validate_kg` 函数，它接受KG和形状定义作为输入。它将返回违规总数和导致至少一次违规的节点集合。\n\n对于KG中的每个节点，验证过程如下进行：\n1.  **识别适用形状：** 验证器检查节点的 `rdf:type` 属性。对于与形状定义中的目标类匹配的每个类型，相应形状的约束将应用于该节点。\n2.  **初始化违规计数：** 当前节点的局部违规计数器初始化为 $0$。\n3.  **应用形状约束：** 对于每个适用的形状，执行以下检查：\n    *   **封闭形状约束：** 如果形状被定义为封闭 (`closed: true`)，验证器会遍历节点的所有属性。对于不在形状允许属性集中的每个属性，都会计入一次违规。属性 `rdf:type` 被隐式允许。\n    *   **属性形状约束：** 验证器遍历主形状中定义的每个属性形状。对于每个属性形状，它将以下约束应用于节点上相应属性的值：\n        *   **基数约束 (`minCount`, `maxCount`)：** 计算属性的值的数量。如果此计数小于 `minCount` 或大于 `maxCount`，则为基数约束记录一次违规。\n        *   **值级约束：** 然后，验证器遍历属性的每个单独值并应用进一步的检查：\n            *   **节点种类约束 (`nodeKind`)：** 它验证值是否为预期的种类（IRI或字面量）。为每个不匹配所需种类的价值记录一次违规。如果种类不正确，则跳过对此值的进一步检查（数据类型、数值范围），因为它们不适用。\n            *   **数据类型约束 (`datatype`)：** 对于字面量值，它检查字面量的数据类型IRI是否与属性形状中指定的IRI匹配。为每个不匹配项记录一次违规。如果数据类型不正确，则跳过后续的数值范围检查。\n            *   **数值范围约束 (`minInclusive`, `maxInclusive`, `minExclusive`)：** 对于具有正确数据类型的数值字面量，验证器检查该值是否遵守给定的范围。为每个未满足的范围记录一次违规。\n\n4.  **聚合结果：** 在检查完一个节点的所有适用形状后，如果该节点的局部违规计数器大于 $0$，则将此计数加到全局总违规计数器中，并将该节点的IRI添加到违规节点集合中。\n\n5.  **最终输出：** 处理完KG中的所有节点后，函数返回总违规计数和违规节点IRI的集合。然后主程序按要求对违规节点列表进行字典序排序。\n\n这种系统化的规则应用确保了所有约束都得到正确检查，并且违规计数按照问题陈述中的规定进行聚合。\n\n实现将把这些步骤转化为Python代码。将使用辅助函数 `is_iri` 和 `is_literal` 来根据其Python表示（`str` vs `tuple`）来区分这两种类型的值。问题陈述中提供的测试用例将使用这些数据结构进行编码，并传递给验证器以生成最终结果。\n\n让我们以 `测试用例 1` 中的节点 `ex:C1` 为例进行追踪：\n*   **节点：** `ex:C1` 的 `rdf:type` 是 `ex:Controller`。\n*   **适用形状：** `ex:Controller` 形状。\n*   **验证：**\n    1.  **封闭形状约束：** 该形状是封闭的，允许的属性为 `{\"ex:controls\", \"rdf:type\"}`。该节点有一个属性 `ex:hasExtraProperty`，它不在允许的集合中。这会产生 $1$ 次违规。\n    2.  **属性形状 `ex:controls`：** 该形状要求 `minCount = 2` 且 `nodeKind = IRI`。\n        *   **基数：** 该节点有两个 `ex:controls` 的值：`[\"ex:S2\", \"ex:A1\"]`。数量为 $2$，满足 `minCount = 2`。无违规。\n        *   **值级：** `\"ex:S2\"` 和 `\"ex:A1\"` 都是字符串，因此被正确识别为IRI。无违规。\n*   **`ex:C1` 的总计：** 该节点有 $1$ 次违规。它被添加到违规节点列表中。\n\n这个详细的、基于规则的过程将被实现于所有节点和所有测试用例，以产生所需的输出。",
            "answer": "```python\n# No other libraries are permitted, as per the rules.\n\ndef solve():\n    \"\"\"\n    Main function to define shapes, test cases, run validation, and print results.\n    \"\"\"\n\n    # SHACL shapes definition as per the problem statement.\n    # The datatypes 'integer', 'float', 'string' are used as simplified IRIs.\n    shapes = {\n        \"ex:Sensor\": {\n            \"properties\": {\n                \"ex:hasSamplingPeriod\": {\n                    \"nodeKind\": \"Literal\",\n                    \"datatype\": \"integer\",\n                    \"minCount\": 1,\n                    \"minInclusive\": 1,\n                    \"maxInclusive\": 60,\n                },\n                \"ex:connectedTo\": {\n                    \"nodeKind\": \"IRI\",\n                    \"minCount\": 1,\n                },\n            },\n            \"closed\": False,\n        },\n        \"ex:Actuator\": {\n            \"properties\": {\n                \"ex:hasPowerRating\": {\n                    \"nodeKind\": \"Literal\",\n                    \"datatype\": \"float\",\n                    \"minExclusive\": 0.0,\n                },\n                \"ex:controlledBy\": {\n                    \"nodeKind\": \"IRI\",\n                    \"minCount\": 1,\n                    \"maxCount\": 1,\n                },\n            },\n            \"closed\": False,\n        },\n        \"ex:Controller\": {\n            \"properties\": {\n                \"ex:controls\": {\n                    \"nodeKind\": \"IRI\",\n                    \"minCount\": 2,\n                },\n            },\n            \"closed\": True,\n            \"allowedProperties\": {\"rdf:type\", \"ex:controls\"},\n        },\n    }\n\n    # Test suite definition. Literals are represented as (value, datatype_iri) tuples.\n    # IRIs are represented as strings.\n    test_cases = [\n        # Test Case 1\n        {\n            \"ex:S1\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(0, \"integer\")],\n            },\n            \"ex:S2\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(10, \"integer\")],\n                \"ex:connectedTo\": [\"ex:A1\"],\n            },\n            \"ex:A1\": {\n                \"rdf:type\": [\"ex:Actuator\"],\n                \"ex:hasPowerRating\": [(-5.0, \"float\")],\n                \"ex:controlledBy\": [\"ex:C1\"],\n            },\n            \"ex:C1\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [\"ex:S2\", \"ex:A1\"],\n                \"ex:hasExtraProperty\": [(\"foo\", \"string\")],\n            },\n            \"ex:U1\": {\n                \"rdf:type\": [\"ex:Unknown\"],\n                \"ex:random\": [(\"bar\", \"string\")],\n            },\n        },\n        # Test Case 2\n        {\n            \"ex:S3\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(60, \"integer\")],\n                \"ex:connectedTo\": [\"ex:A2\"],\n            },\n            \"ex:A2\": {\n                \"rdf:type\": [\"ex:Actuator\"],\n                \"ex:hasPowerRating\": [(0.0, \"float\")],\n                \"ex:controlledBy\": [\"ex:C2\"],\n            },\n            \"ex:C2\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [\"ex:S3\", \"ex:A2\"],\n            },\n        },\n        # Test Case 3\n        {\n            \"ex:S4\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(\"ten\", \"string\")],\n                \"ex:connectedTo\": [(\"ex:C3\", \"string\")],\n            },\n            \"ex:A3\": {\n                \"rdf:type\": [\"ex:Actuator\"],\n                \"ex:hasPowerRating\": [(10.0, \"float\")],\n                \"ex:controlledBy\": [\"ex:C3\", \"ex:C4\"],\n            },\n            \"ex:C3\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [],\n            },\n            \"ex:C4\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [\"ex:S4\"],\n            },\n        },\n    ]\n\n    results = []\n    for kg in test_cases:\n        total_violations, violating_nodes = validate_kg(kg, shapes)\n        results.append([total_violations, sorted(list(violating_nodes))])\n        \n    # Format the final output string precisely as required.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\n\ndef is_iri(value):\n    \"\"\"Checks if a value represents an IRI (is a string).\"\"\"\n    return isinstance(value, str)\n\ndef is_literal(value):\n    \"\"\"Checks if a value represents a Literal (is a (value, type) tuple).\"\"\"\n    return isinstance(value, tuple) and len(value) == 2 and isinstance(value[1], str)\n\ndef validate_kg(kg, shapes):\n    \"\"\"\n    Validates a Knowledge Graph against a set of SHACL shapes.\n    \n    Args:\n        kg (dict): The Knowledge Graph to validate.\n        shapes (dict): The SHACL shapes definition.\n        \n    Returns:\n        tuple: A pair (total_violations, violating_nodes_set).\n    \"\"\"\n    total_violations = 0\n    violating_nodes = set()\n\n    for node_iri, node_data in kg.items():\n        node_violations = 0\n        node_types = node_data.get(\"rdf:type\", [])\n        \n        for node_type in node_types:\n            if node_type not in shapes:\n                continue\n            \n            shape = shapes[node_type]\n            \n            # --- Closed Shape Validation ---\n            if shape.get(\"closed\", False):\n                allowed_props = shape.get(\"allowedProperties\", set())\n                for prop in node_data.keys():\n                    if prop not in allowed_props:\n                        node_violations += 1\n\n            # --- Property Shape Validation ---\n            for prop_iri, prop_shape in shape.get(\"properties\", {}).items():\n                values = node_data.get(prop_iri, [])\n                num_values = len(values)\n\n                # Count Constraints\n                if \"minCount\" in prop_shape and num_values  prop_shape[\"minCount\"]:\n                    node_violations += 1\n                if \"maxCount\" in prop_shape and num_values > prop_shape[\"maxCount\"]:\n                    node_violations += 1\n                \n                # Value-level Constraints\n                for value in values:\n                    # Node Kind Constraint\n                    if \"nodeKind\" in prop_shape:\n                        kind = prop_shape[\"nodeKind\"]\n                        if kind == \"IRI\" and not is_iri(value):\n                            node_violations += 1\n                            continue\n                        if kind == \"Literal\" and not is_literal(value):\n                            node_violations += 1\n                            continue\n                    \n                    if is_literal(value):\n                        lit_val, lit_type = value\n                        \n                        # Datatype Constraint\n                        if \"datatype\" in prop_shape and lit_type != prop_shape[\"datatype\"]:\n                            node_violations += 1\n                            continue\n                        \n                        # Numeric Bounds Constraints (only for numeric Python types)\n                        if isinstance(lit_val, (int, float)):\n                            if \"minInclusive\" in prop_shape and lit_val  prop_shape[\"minInclusive\"]:\n                                node_violations += 1\n                            if \"maxInclusive\" in prop_shape and lit_val > prop_shape[\"maxInclusive\"]:\n                                node_violations += 1\n                            if \"minExclusive\" in prop_shape and lit_val = prop_shape[\"minExclusive\"]:\n                                node_violations += 1\n\n        if node_violations > 0:\n            total_violations += node_violations\n            violating_nodes.add(node_iri)\n            \n    return total_violations, violating_nodes\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}