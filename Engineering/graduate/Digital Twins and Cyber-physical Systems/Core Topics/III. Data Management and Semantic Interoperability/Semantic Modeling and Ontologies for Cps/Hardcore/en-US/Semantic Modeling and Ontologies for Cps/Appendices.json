{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of semantic modeling is translating system requirements into formal, machine-readable rules. This practice focuses on that translation, guiding you to construct a fundamental constraint for a Cyber-Physical System using Description Logic (DL) axioms. By ensuring every sensor is correctly associated with a quantity it measures, you will develop a validator that enforces data integrity, a critical function for any reliable Digital Twin .",
            "id": "4245038",
            "problem": "You are tasked with formalizing and checking a semantic constraint in the context of Cyber-Physical Systems (CPS). The goal is to construct an axiom in Description Logic (DL) using the Web Ontology Language (OWL) functional syntax that enforces that every instance of a class $Sensor$ must be related, via an object property $measures$, to some instance of a class $QuantityKind$ using an existential restriction $\\exists$. You must then implement a program that, given a set of individuals, class assertions, and property assertions, determines whether the axiom is satisfied under a closed-world validation regime for several test cases. The program should treat subclass axioms as inferential support, meaning instances of subclasses of $QuantityKind$ count as satisfying the existential restriction.\n\nFundamental base to use includes the standard model-theoretic semantics of Description Logic: given an interpretation $\\mathcal{I}$ with domain $\\Delta^\\mathcal{I}$, a class $C$ is interpreted as a subset $C^\\mathcal{I} \\subseteq \\Delta^\\mathcal{I}$, and an object property $p$ is interpreted as a binary relation $p^\\mathcal{I} \\subseteq \\Delta^\\mathcal{I} \\times \\Delta^\\mathcal{I}$. The existential restriction is interpreted as $$(\\exists p.C)^\\mathcal{I} = \\{ x \\in \\Delta^\\mathcal{I} \\mid \\exists y \\in \\Delta^\\mathcal{I} \\text{ such that } (x,y) \\in p^\\mathcal{I} \\text{ and } y \\in C^\\mathcal{I} \\}.$$ The subclass relation is interpreted as $A \\sqsubseteq B$ meaning $A^\\mathcal{I} \\subseteq B^\\mathcal{I}$.\n\nConstruct the following OWL functional syntax axiom set that captures the intended DL constraint:\n\n- Use a base prefix $: = \\langle http://example.org/cps\\# \\rangle$.\n- Declare the relevant classes and object property:\n  - $Declaration(Class(:Sensor))$\n  - $Declaration(Class(:QuantityKind))$\n  - $Declaration(ObjectProperty(:measures))$\n- State the subclass axiom enforcing the existential restriction:\n  - $SubClassOf(:Sensor\\ ObjectSomeValuesFrom(:measures\\ :QuantityKind))$\n- You may include additional class declarations such as $:Temperature$, $:Pressure$, $:Actuator$, and $:Unit$ as needed for the test suite, and subclass axioms like $SubClassOf(:Temperature\\ :QuantityKind)$ and $SubClassOf(:Pressure\\ :QuantityKind)$.\n\nYour program must implement closed-world validation for the above axiom over a set of test datasets. For a given dataset, the program must check whether for every individual $x$ asserted to be of type $Sensor$, there exists at least one $y$ such that $(x,y)$ is asserted via $measures$ and $y$ is asserted to be of type $QuantityKind$ or of a class $C$ where a provided subclass axiom $C \\sqsubseteq QuantityKind$ holds (including chains of subclass relationships). If any $Sensor$ individual fails this, the dataset’s result is $False$; otherwise, it is $True$.\n\nPhysical units do not apply. Angles do not apply. Percentages do not apply.\n\nTest Suite and Parameters:\nYour program must hard-code and evaluate the following $6$ datasets. Each dataset consists of:\n- A finite set of class declarations (names only).\n- A set of subclass axioms as ordered pairs $(A, B)$ meaning $A \\sqsubseteq B$.\n- A mapping from individuals to a set of asserted classes.\n- A set of $measures$ edges as ordered pairs $(subject, object)$.\n\nDatasets to evaluate:\n- Dataset $1$ (happy path): classes $\\{Sensor, QuantityKind\\}$; subclass axioms $\\emptyset$; types $\\{s1 \\mapsto \\{Sensor\\}, q1 \\mapsto \\{QuantityKind\\}\\}$; edges $\\{(s1, q1)\\}$; expected result $True$.\n- Dataset $2$ (subclass satisfaction): classes $\\{Sensor, QuantityKind, Temperature\\}$; subclass axioms $\\{(Temperature, QuantityKind)\\}$; types $\\{s2 \\mapsto \\{Sensor\\}, t1 \\mapsto \\{Temperature\\}\\}$; edges $\\{(s2, t1)\\}$; expected result $True$.\n- Dataset $3$ (violation: no measurement): classes $\\{Sensor, QuantityKind\\}$; subclass axioms $\\emptyset$; types $\\{s3 \\mapsto \\{Sensor\\}\\}$; edges $\\emptyset$; expected result $False$.\n- Dataset $4$ (violation: wrong target type): classes $\\{Sensor, QuantityKind, Actuator\\}$; subclass axioms $\\emptyset$; types $\\{s4 \\mapsto \\{Sensor\\}, a1 \\mapsto \\{Actuator\\}\\}$; edges $\\{(s4, a1)\\}$; expected result $False$.\n- Dataset $5$ (multiple measures with one valid): classes $\\{Sensor, QuantityKind, Unit, Pressure\\}$; subclass axioms $\\{(Pressure, QuantityKind)\\}$; types $\\{s5 \\mapsto \\{Sensor\\}, u1 \\mapsto \\{Unit\\}, p1 \\mapsto \\{Pressure\\}\\}$; edges $\\{(s5, u1), (s5, p1)\\}$; expected result $True$.\n- Dataset $6$ (violation: unknown target type): classes $\\{Sensor, QuantityKind\\}$; subclass axioms $\\emptyset$; types $\\{s6 \\mapsto \\{Sensor\\}, e4 \\mapsto \\emptyset\\}$; edges $\\{(s6, e4)\\}$; expected result $False$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for datasets $1$ through $6$ as a comma-separated list enclosed in square brackets, such as $[result_1,result_2,\\dots,result_6]$, where each $result_i$ is a boolean $True$ or $False$ computed as specified. No other text should be printed.",
            "solution": "The user has provided a problem that is scientifically grounded, well-posed, and complete. It is based on standard principles of Description Logic (DL) and its application in semantic modeling using the Web Ontology Language (OWL), which are core topics in computer science and knowledge representation. The problem is to formalize a constraint and then implement a validation checker for it.\n\nThe problem is valid.\n\nThe core task is to validate a set of assertions against a semantic axiom under a closed-world assumption. The axiom to be enforced is that every instance of the class `$Sensor$` must be related via the object property `$measures$` to at least one instance of the class `$QuantityKind$`. In Description Logic, this is expressed as a subclass axiom:\n$$\nSensor \\sqsubseteq \\exists measures.QuantityKind\n$$\nThis axiom states that the class `$Sensor$` is a subclass of the class of things that measure some `$QuantityKind$`. The semantics of the existential restriction, $(\\exists p.C)^\\mathcal{I}$, is the set of individuals $\\{ x \\in \\Delta^\\mathcal{I} \\mid \\exists y \\in \\Delta^\\mathcal{I} \\text{ such that } (x,y) \\in p^\\mathcal{I} \\text{ and } y \\in C^\\mathcal{I} \\}$. Applying this to the axiom, for any individual $x \\in Sensor^\\mathcal{I}$, it must be that $x \\in (\\exists measures.QuantityKind)^\\mathcal{I}$. This means there must exist an individual $y$ such that $(x,y) \\in measures^\\mathcal{I}$ and $y \\in QuantityKind^\\mathcal{I}$.\n\nThe problem specifies that subclass relationships must be considered. An axiom of the form $A \\sqsubseteq B$ means that any instance of class $A$ is also an instance of class $B$, i.e., $A^\\mathcal{I} \\subseteq B^\\mathcal{I}$. This relationship is transitive. Therefore, if an individual $y$ is an instance of a class $C$, and there exists a chain of subclass axioms $C \\sqsubseteq D_1$, $D_1 \\sqsubseteq D_2$, ..., $D_n \\sqsubseteq QuantityKind$, then $y$ is also considered an instance of $QuantityKind$.\n\nThe validation must be performed under a closed-world assumption. This means that we only consider the facts explicitly stated in each dataset (class assertions, property assertions, and subclass axioms). If a fact is not stated, it is assumed to be false.\n\nThe algorithm to validate a given dataset proceeds as follows:\n\n1.  **Identify Valid Target Classes**: First, we must determine the complete set of classes that can satisfy the right-hand side of the `$measures$` property. This set, let's call it $V_{QK}$, includes `$QuantityKind$` itself and all classes that are transitively defined as subclasses of `$QuantityKind$`. The subclass axioms, which are pairs of the form $(A, B)$ representing $A \\sqsubseteq B$, can be modeled as a directed graph where an edge exists from $A$ to $B$. A class $C$ is in $V_{QK}$ if there is a path in this graph from $C$ to `$QuantityKind$`. This can be determined for any given class $C$ by performing a graph traversal (e.g., Breadth-First or Depth-First Search) starting from node $C$ to see if `$QuantityKind$` is reachable.\n\n2.  **Identify Sensor Individuals**: From the provided type assertions, we compile a list of all individuals that are explicitly declared as instances of the class `$Sensor$`.\n\n3.  **Iterate and Verify Each Sensor**: For each individual $s$ identified as a `$Sensor$`, we must verify that it satisfies the condition. The validation for a single sensor $s$ is as follows:\n    a.  Find all property assertions of the form $(s, y)$ for the property `$measures$`. Let the set of all such target individuals be $Y_s$.\n    b.  If the set $Y_s$ is empty, the sensor $s$ fails the validation, as there is no existential fulfillment ($\\neg \\exists y$). The entire dataset is therefore invalid, and the result is `$False$`.\n    c.  If $Y_s$ is not empty, we must check if at least one individual $y \\in Y_s$ is an instance of a valid target class. For each $y \\in Y_s$, we retrieve its asserted classes from the type mappings. Let this set of classes be $C_y$.\n    d.  We then check if any class $c \\in C_y$ is a member of the set of valid target classes, $V_{QK}$, as determined in Step 1.\n    e.  If we find at least one $y \\in Y_s$ for which at least one of its classes $c \\in C_y$ is a valid target class, the sensor $s$ satisfies the axiom. We can then proceed to the next sensor.\n    f. If, after checking all $y \\in Y_s$ for a given sensor $s$, no such valid target individual is found, then sensor $s$ violates the axiom. The entire dataset is invalid, and the result is `$False$`.\n\n4.  **Final Result**: If all individuals of class `$Sensor$` successfully pass the verification in Step 3, the dataset is considered valid, and the result is `$True$`. The failure of even a single sensor individual results in a `$False$` verdict for the entire dataset.\n\nThis algorithm correctly implements the closed-world validation of the specified DL axiom, including support for transitive subclass hierarchies, as required by the problem statement. The provided test cases can be systematically evaluated using this procedure to derive the expected boolean outcomes. For instance, in Dataset $2$, an individual of type `$Temperature$` is a valid target because the axiom `$Temperature \\sqsubseteq QuantityKind$` is provided. In Dataset $5$, the sensor measures two things, an instance of `$Unit$` and an instance of `$Pressure$`. Since `$Pressure \\sqsubseteq QuantityKind$` is given, the measurement of the `$Pressure$` instance is sufficient to satisfy the axiom for that sensor, even though the measurement of the `$Unit$` instance is not valid.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n\n    # Test Suite and Parameters\n    # Each dataset is a tuple: (class_declarations, subclass_axioms, type_assertions, measures_edges)\n    test_cases = [\n        # Dataset 1 (happy path)\n        (\n            {'Sensor', 'QuantityKind'},\n            set(),\n            {'s1': {'Sensor'}, 'q1': {'QuantityKind'}},\n            {('s1', 'q1')}\n        ),\n        # Dataset 2 (subclass satisfaction)\n        (\n            {'Sensor', 'QuantityKind', 'Temperature'},\n            {('Temperature', 'QuantityKind')},\n            {'s2': {'Sensor'}, 't1': {'Temperature'}},\n            {('s2', 't1')}\n        ),\n        # Dataset 3 (violation: no measurement)\n        (\n            {'Sensor', 'QuantityKind'},\n            set(),\n            {'s3': {'Sensor'}},\n            set()\n        ),\n        # Dataset 4 (violation: wrong target type)\n        (\n            {'Sensor', 'QuantityKind', 'Actuator'},\n            set(),\n            {'s4': {'Sensor'}, 'a1': {'Actuator'}},\n            {('s4', 'a1')}\n        ),\n        # Dataset 5 (multiple measures with one valid)\n        (\n            {'Sensor', 'QuantityKind', 'Unit', 'Pressure'},\n            {('Pressure', 'QuantityKind')},\n            {'s5': {'Sensor'}, 'u1': {'Unit'}, 'p1': {'Pressure'}},\n            {('s5', 'u1'), ('s5', 'p1')}\n        ),\n        # Dataset 6 (violation: unknown target type)\n        (\n            {'Sensor', 'QuantityKind'},\n            set(),\n            {'s6': {'Sensor'}, 'e4': set()},\n            {('s6', 'e4')}\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(validate_dataset(*case))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_dataset(classes, subclass_axioms, types, edges):\n    \"\"\"\n    Validates a single dataset against the semantic constraint.\n\n    Args:\n        classes (set): Set of class names.\n        subclass_axioms (set): Set of (subclass, superclass) tuples.\n        types (dict): Mapping from individual name to a set of its class names.\n        edges (set): Set of (subject, object) tuples for the 'measures' property.\n\n    Returns:\n        bool: True if the dataset is valid, False otherwise.\n    \"\"\"\n    # Build a graph-like structure for subclass relationships for efficient lookup.\n    # The map stores {subclass: [list of direct superclasses]}.\n    subclass_map = {}\n    for sub, sup in subclass_axioms:\n        if sub not in subclass_map:\n            subclass_map[sub] = []\n        subclass_map[sub].append(sup)\n\n    # Memoization cache for is_subclass_of checks to avoid re-computation.\n    memo = {}\n    def is_subclass_of(child, parent):\n        if (child, parent) in memo:\n            return memo[(child, parent)]\n        \n        if child == parent:\n            memo[(child, parent)] = True\n            return True\n\n        # BFS to find a path from child to parent in the subclass graph.\n        q = [child]\n        visited = {child}\n        while q:\n            current = q.pop(0)\n            if current == parent:\n                memo[(child, parent)] = True\n                return True\n            for superclass in subclass_map.get(current, []):\n                if superclass not in visited:\n                    visited.add(superclass)\n                    q.append(superclass)\n        \n        memo[(child, parent)] = False\n        return False\n\n    def is_valid_target_type(cls):\n        \"\"\"Checks if a class is QuantityKind or a subclass thereof.\"\"\"\n        return is_subclass_of(cls, 'QuantityKind')\n\n    # Find all individuals asserted to be of type 'Sensor'.\n    sensor_individuals = {ind for ind, ind_types in types.items() if 'Sensor' in ind_types}\n    \n    if not sensor_individuals:\n        return True # Vacuously true if there are no sensors.\n\n    # Create a mapping from subject to a list of objects for 'measures' edges.\n    measures_map = {}\n    for subj, obj in edges:\n        if subj not in measures_map:\n            measures_map[subj] = []\n        measures_map[subj].append(obj)\n\n    # For each sensor, check if the axiom is satisfied.\n    for sensor in sensor_individuals:\n        measured_individuals = measures_map.get(sensor, [])\n\n        if not measured_individuals:\n            return False # Fails if sensor measures nothing.\n\n        is_satisfied = False\n        for measured_ind in measured_individuals:\n            target_types = types.get(measured_ind, set())\n            \n            # Check if any type of the target individual is a valid type.\n            for t_type in target_types:\n                if is_valid_target_type(t_type):\n                    is_satisfied = True\n                    break # Found a valid measurement, no need to check other types.\n            if is_satisfied:\n                break # Found a valid measured individual, move to the next sensor.\n\n        if not is_satisfied:\n            return False # This sensor fails to satisfy the axiom.\n\n    return True # All sensors satisfied the axiom.\n\nsolve()\n```"
        },
        {
            "introduction": "Once a semantic model is populated with data, its true power is unlocked through querying. This exercise moves from defining rules to extracting insights using SPARQL, the standard query language for RDF data. You will construct a query that goes beyond simple data retrieval, performing intelligent filtering and on-the-fly unit normalization by leveraging the structure of established ontologies like SOSA and QUDT .",
            "id": "4244964",
            "problem": "You are given a conceptual cyber-physical system featuring sensors modeled using the Resource Description Framework (RDF) and the Sensor, Observation, Sample, and Actuator (SOSA) ontology together with the Quantities, Units, Dimensions and Data (QUDT) schema for quantities and units. Construct a SPARQL Protocol and RDF Query Language (SPARQL) query that selects distinct sensors that measure the property Temperature and whose recorded measurement values, when normalized to the International System of Units (SI) base unit Kelvin, are strictly greater than a threshold $T_{max}$ within a specified inclusive time window $[t_{\\text{start}}, t_{\\text{end}}]$. The normalization must ensure unit-aware comparison across Kelvin, degree Celsius, and degree Fahrenheit readings. The threshold $T_{max}$ is provided in Kelvin and must be interpreted as an $xsd:double$. The time window endpoints $t_{\\text{start}}$ and $t_{\\text{end}}$ are provided as $xsd:dateTime$ literals and must be applied inclusively.\n\nUse the following vocabulary and structure:\n- Observations conform to SOSA: each observation links to the observing sensor via $sosa{:}madeBySensor$, to the observed property via $sosa{:}observedProperty$, to the time of the result via $sosa{:}resultTime$, and to a quantity value via $sosa{:}hasResult$.\n- Quantity values conform to QUDT: the result node provides a numeric literal via $qudt{:}numericValue$ and a unit via $qudt{:}unit$.\n- Units to consider are Kelvin, degree Celsius, and degree Fahrenheit. The SPARQL query must be written so that only these recognized units are converted; observations with unrecognized or missing units must be excluded from the result to ensure scientific soundness.\n\nYour program must:\n1. Construct a parameterized SPARQL query that:\n   - Selects $?sensor$.\n   - Ensures $sosa{:}observedProperty$ is Temperature.\n   - Normalizes the numeric value to Kelvin before comparing against $T_{max}$.\n   - Applies the inclusive time window $[t_{\\text{start}}, t_{\\text{end}}]$.\n   - Returns distinct sensors.\n2. Simulate evaluation of this query over the following dataset, modeled as a set of observations. Each observation is a tuple $(\\text{sensor IRI}, \\text{property IRI}, \\text{numeric value}, \\text{unit code}, \\text{ISO 8601 time})$. Units appear as codes \"K\" for Kelvin, \"C\" for degree Celsius, \"F\" for degree Fahrenheit, and \"UNKNOWN\" if the unit is not recognized. Property IRIs use \"http://example.org/property/Temperature\" for Temperature and \"http://example.org/property/Humidity\" for Humidity. Sensor IRIs follow \"http://example.org/sensor/sensorX\". The time is an ISO 8601 string in Coordinated Universal Time with a trailing \"Z\". The data are:\n   - $(\\text{\"http://example.org/sensor/sensorA\"}, \\text{\"http://example.org/property/Temperature\"}, 36.5, \\text{\"C\"}, \\text{\"2023-09-15T10:30:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorA\"}, \\text{\"http://example.org/property/Temperature\"}, 309.15, \\text{\"K\"}, \\text{\"2023-09-15T12:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorB\"}, \\text{\"http://example.org/property/Temperature\"}, 100.0, \\text{\"F\"}, \\text{\"2023-09-15T11:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorC\"}, \\text{\"http://example.org/property/Temperature\"}, 310.0, \\text{\"K\"}, \\text{\"2023-09-15T10:59:59Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorD\"}, \\text{\"http://example.org/property/Temperature\"}, -10.0, \\text{\"C\"}, \\text{\"2023-09-15T10:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorE\"}, \\text{\"http://example.org/property/Temperature\"}, 37.0, \\text{\"C\"}, \\text{\"2023-09-15T11:30:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorF\"}, \\text{\"http://example.org/property/Temperature\"}, 310.0, \\text{\"UNKNOWN\"}, \\text{\"2023-09-15T11:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorG\"}, \\text{\"http://example.org/property/Humidity\"}, 0.50, \\text{\"UNKNOWN\"}, \\text{\"2023-09-15T11:00:00Z\"})$\n3. Evaluate the constructed query logic against the dataset for each of the following test cases. For each test case, compute the number of distinct sensors selected by the query.\n   - Test Case 1 (happy path): $T_{max} = 310.0$ K, $t_{\\text{start}} = \\text{\"2023-09-15T10:00:00Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T12:00:00Z\"}$.\n   - Test Case 2 (time boundary inclusivity and strict threshold): $T_{max} = 310.0$ K, $t_{\\text{start}} = \\text{\"2023-09-15T10:59:59Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T11:00:00Z\"}$.\n   - Test Case 3 (low threshold with multiple selections): $T_{max} = 300.0$ K, $t_{\\text{start}} = \\text{\"2023-09-15T10:00:00Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T12:00:00Z\"}$.\n   - Test Case 4 (narrow time window at a single instant): $T_{max} = 309.7$ K, $t_{\\text{start}} = \\text{\"2023-09-15T11:30:00Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T11:30:00Z\"}$.\n\nRules and constraints to apply:\n- Only observations of the Temperature property are eligible.\n- Only units in the set $\\{\\text{Kelvin}, \\text{degree Celsius}, \\text{degree Fahrenheit}\\}$ are recognized for normalization; any other unit must be excluded from consideration.\n- The comparison must be strictly greater than $T_{max}$.\n- The time window $[t_{\\text{start}}, t_{\\text{end}}]$ is inclusive of both endpoints.\n- All numeric quantities and thresholds are in Kelvin after normalization; $T_{max}$ is provided in Kelvin and must be handled as an $xsd{:}double$ literal in the SPARQL query.\n- Angle units are not involved.\n- The final output for the program must be a single line containing a comma-separated list enclosed in square brackets, where each element is an integer equal to the number of distinct sensors selected for the corresponding test case, in the order listed above. For example: $[\\text{result1}, \\text{result2}, \\text{result3}, \\text{result4}]$.\n\nYour task is to build the SPARQL query string with appropriate unit normalization and time filtering, and implement a simulation of its evaluation over the provided dataset to produce the requested integer counts for the test suite.",
            "solution": "The problem is deemed valid as it is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of requirements, data, and constraints to construct a formal solution. The task involves designing a SPARQL query and simulating its logic, a standard practice in working with semantic web technologies and knowledge graphs, which is directly relevant to modeling cyber-physical systems.\n\nThe solution involves two main components: the conceptual design of a SPARQL query and a Python-based simulation to evaluate the query logic against the provided dataset and test cases.\n\nFirst, we design the SPARQL query. The query must select distinct sensors meeting several criteria. The structure of such a query is as follows:\n\n1.  **Prefixes**: To shorten the query, we define prefixes for the ontologies used: `sosa` for the Sensor, Observation, Sample, and Actuator ontology, `qudt` for the Quantities, Units, Dimensions, and Data schema, and `xsd` for XML Schema Datatypes.\n2.  **Selection Clause**: The query must return distinct sensors, which is accomplished using `SELECT DISTINCT ?sensor`.\n3.  **Graph Pattern Matching**: The `WHERE` clause defines the graph pattern to find relevant observations. We traverse from an observation (`?obs`) to its associated sensor (`?sensor`), observed property, result time (`?time`), and result (`?result`). The result node is further traversed to find its numeric value (`?value`) and unit (`?unitCode`).\n    -   `?obs sosa:madeBySensor ?sensor .`\n    -   `?obs sosa:observedProperty <http://example.org/property/Temperature> .` This filters for observations of the \"Temperature\" property only.\n    -   `?obs sosa:resultTime ?time .`\n    -   `?obs sosa:hasResult ?result .`\n    -   `?result qudt:numericValue ?value .`\n    -   `?result qudt:unit ?unitCode .`\n4.  **Unit Filtering and Normalization**: The problem requires handling three specific units—Kelvin ($K$), degree Celsius ($C$), and degree Fahrenheit ($F$)—and ignoring all others. A `FILTER` clause is used to restrict the query to observations with these recognized units. Subsequently, a `BIND` clause with nested `IF` statements is employed to compute a normalized temperature, `?valueInK`, in the SI base unit Kelvin. The conversion formulas are:\n    -   For degree Celsius ($C$): $T_K = T_C + 273.15$\n    -   For degree Fahrenheit ($F$): $T_K = (T_F - 32) \\times \\frac{5}{9} + 273.15$\n    -   For Kelvin ($K$), no conversion is needed: $T_K = T_K$\n    The use of floating-point numbers in the division (e.g., $5.0/9.0$) is crucial in SPARQL to ensure correct arithmetic.\n5.  **Data Filtering**: Three `FILTER` conditions are applied to the matched and normalized data:\n    -   A time window filter: `?time >= t_start` and `?time <= t_end`, where $t_{\\text{start}}$ and $t_{\\text{end}}$ are `xsd:dateTime` literals. The use of `>=` and `<=` ensures the time window is inclusive.\n    -   A value threshold filter: `?valueInK > T_max`, where $T_{max}$ is an `xsd:double` literal. The comparison is strictly greater, as specified.\n\nThe second part of the solution is to implement a simulation in Python that executes this logic. The simulation proceeds as follows for each test case:\n\n1.  An empty set, `selected_sensors`, is initialized to store the IRIs of sensors that meet the criteria, automatically ensuring uniqueness.\n2.  Each record in the provided dataset is processed sequentially.\n3.  **Property Check**: The observation's property is checked. If it is not \"Temperature,\" the record is skipped.\n4.  **Unit Check**: The unit code is checked. If it is not one of `\"K\"`, `\"C\"`, or `\"F\"`, the record is skipped.\n5.  **Time Window Check**: The observation's timestamp is parsed and compared against the inclusive window $[t_{\\text{start}}, t_{\\text{end}}]$ for the current test case. If it falls outside this range, the record is skipped.\n6.  **Value Normalization**: If the record has passed the checks so far, its numeric value is normalized to Kelvin using the standard conversion formulas mentioned above.\n7.  **Threshold Check**: The normalized Kelvin value is compared against the threshold $T_{max}$. If it is strictly greater than $T_{max}$, the sensor's IRI is added to the `selected_sensors` set.\n8.  After iterating through all records, the final result for the test case is the size of the `selected_sensors` set.\n\nThis process is repeated for each of the four test cases, and the resulting counts are collected into a list, which is then formatted as the final output. This simulation faithfully reproduces the logic of a real SPARQL engine evaluating the designed query.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nfrom datetime import datetime, timezone\n\ndef solve():\n    \"\"\"\n    Constructs and simulates a SPARQL query to find sensors reporting high temperatures.\n    \"\"\"\n    \n    # Dataset modeled as a list of tuples:\n    # (sensor IRI, property IRI, numeric value, unit code, ISO 8601 time)\n    dataset = [\n        (\"http://example.org/sensor/sensorA\", \"http://example.org/property/Temperature\", 36.5, \"C\", \"2023-09-15T10:30:00Z\"),\n        (\"http://example.org/sensor/sensorA\", \"http://example.org/property/Temperature\", 309.15, \"K\", \"2023-09-15T12:00:00Z\"),\n        (\"http://example.org/sensor/sensorB\", \"http://example.org/property/Temperature\", 100.0, \"F\", \"2023-09-15T11:00:00Z\"),\n        (\"http://example.org/sensor/sensorC\", \"http://example.org/property/Temperature\", 310.0, \"K\", \"2023-09-15T10:59:59Z\"),\n        (\"http://example.org/sensor/sensorD\", \"http://example.org/property/Temperature\", -10.0, \"C\", \"2023-09-15T10:00:00Z\"),\n        (\"http://example.org/sensor/sensorE\", \"http://example.org/property/Temperature\", 37.0, \"C\", \"2023-09-15T11:30:00Z\"),\n        (\"http://example.org/sensor/sensorF\", \"http://example.org/property/Temperature\", 310.0, \"UNKNOWN\", \"2023-09-15T11:00:00Z\"),\n        (\"http://example.org/sensor/sensorG\", \"http://example.org/property/Humidity\", 0.50, \"UNKNOWN\", \"2023-09-15T11:00:00Z\"),\n    ]\n\n    # Test cases: (T_max in Kelvin, t_start string, t_end string)\n    test_cases = [\n        (310.0, \"2023-09-15T10:00:00Z\", \"2023-09-15T12:00:00Z\"),\n        (310.0, \"2023-09-15T10:59:59Z\", \"2023-09-15T11:00:00Z\"),\n        (300.0, \"2023-09-15T10:00:00Z\", \"2023-09-15T12:00:00Z\"),\n        (309.7, \"2023-09-15T11:30:00Z\", \"2023-09-15T11:30:00Z\"),\n    ]\n\n    results = []\n\n    # Constants and recognized values\n    TEMPERATURE_PROPERTY_IRI = \"http://example.org/property/Temperature\"\n    RECOGNIZED_UNITS = {\"K\", \"C\", \"F\"}\n\n    for t_max, t_start_str, t_end_str in test_cases:\n        selected_sensors = set()\n\n        # Parse time boundaries once per test case\n        t_start_dt = datetime.fromisoformat(t_start_str)\n        t_end_dt = datetime.fromisoformat(t_end_str)\n\n        for sensor_iri, prop_iri, num_val, unit, time_str in dataset:\n            # 1. Filter by property\n            if prop_iri != TEMPERATURE_PROPERTY_IRI:\n                continue\n\n            # 2. Filter by recognized units\n            if unit not in RECOGNIZED_UNITS:\n                continue\n\n            # 3. Filter by time window (inclusive)\n            obs_time_dt = datetime.fromisoformat(time_str)\n            if not (t_start_dt <= obs_time_dt <= t_end_dt):\n                continue\n            \n            # 4. Normalize value to Kelvin\n            value_in_k = 0.0\n            if unit == \"C\":\n                value_in_k = num_val + 273.15\n            elif unit == \"F\":\n                value_in_k = (num_val - 32.0) * 5.0 / 9.0 + 273.15\n            elif unit == \"K\":\n                value_in_k = num_val\n            \n            # 5. Filter by threshold (strictly greater)\n            if value_in_k > t_max:\n                selected_sensors.add(sensor_iri)\n        \n        # The result is the number of distinct sensors found\n        results.append(len(selected_sensors))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "As ontologies grow in complexity, logical inconsistencies can emerge, threatening the integrity of the entire model. This practice addresses the essential skill of ontology debugging, where you will act as a system diagnostician. By analyzing a set of conflicting axioms and data assertions, you will learn to pinpoint the minimal sources of contradiction and compute the minimal repair sets needed to restore the model's logical consistency .",
            "id": "4244997",
            "problem": "Consider a fragment of a Cyber-Physical System (CPS) ontology specified in Description Logic (DL), intended for use in Digital Twin models. Let the classes be $\\mathsf{Sensor}$, $\\mathsf{Actuator}$, $\\mathsf{Device}$, $\\mathsf{TemperatureSensor}$, $\\mathsf{ValveActuator}$, $\\mathsf{SenseRole}$, and $\\mathsf{ActRole}$. Let the object property be $\\mathsf{hasRole}$. The TBox axioms are:\n1. $\\mathsf{TemperatureSensor} \\sqsubseteq \\mathsf{Sensor}$,\n2. $\\mathsf{ValveActuator} \\sqsubseteq \\mathsf{Actuator}$,\n3. $\\mathsf{Sensor} \\sqsubseteq \\mathsf{Device}$,\n4. $\\mathsf{Actuator} \\sqsubseteq \\mathsf{Device}$,\n5. $\\mathsf{Sensor} \\sqcap \\mathsf{Actuator} \\sqsubseteq \\bot$,\n6. $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$,\n7. $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$.\n\nConsider the ABox with individuals $x_1$, $x_2$, $x_3$, $r_1$, $r_2$ and the following assertions:\n- $\\mathsf{hasRole}(x_1, r_1)$, $r_1 : \\mathsf{SenseRole}$,\n- $\\mathsf{hasRole}(x_1, r_2)$, $r_2 : \\mathsf{ActRole}$,\n- $\\mathsf{hasRole}(x_2, r_2)$, $x_2 : \\mathsf{TemperatureSensor}$,\n- $\\mathsf{hasRole}(x_3, r_1)$, $x_3 : \\mathsf{ValveActuator}$.\n\nAssume standard first-order semantics of Description Logic and the Open World Assumption, as in the Web Ontology Language (OWL). Using only the foundational semantics of DL (class interpretation, role interpretation, subsumption, and disjointness), first determine whether the ontology $\\mathcal{O}$ is consistent. Then, restrict repairs to ABox deletion only (no TBox changes permitted), so that all three individuals $x_1$, $x_2$, and $x_3$ no longer violate the disjointness axiom.\n\nDefine a minimal ABox-deletion repair set as a set of ABox assertions whose removal yields a consistent ontology and is inclusion-minimal and of smallest possible cardinality. Compute the number $N$ of distinct minimal ABox-deletion repair sets for $\\mathcal{O}$. Report only $N$ as your final answer. No rounding is required; express the final answer as an integer without units.",
            "solution": "The problem asks for the number $N$ of distinct minimal ABox-deletion repair sets for a given ontology $\\mathcal{O}$. An ontology is consistent if it has a model. An inconsistency arises if the axioms logically lead to a contradiction, such as an individual being an instance of a class and its complement. The TBox of $\\mathcal{O}$ contains the disjointness axiom $\\mathsf{Sensor} \\sqcap \\mathsf{Actuator} \\sqsubseteq \\bot$, which asserts that no individual can be an instance of both the class $\\mathsf{Sensor}$ and the class $\\mathsf{Actuator}$. We must first determine if the ontology is consistent by checking if any individual violates this axiom.\n\nThe TBox axioms are:\n$1.$ $\\mathsf{TemperatureSensor} \\sqsubseteq \\mathsf{Sensor}$\n$2.$ $\\mathsf{ValveActuator} \\sqsubseteq \\mathsf{Actuator}$\n$3.$ $\\mathsf{Sensor} \\sqsubseteq \\mathsf{Device}$\n$4.$ $\\mathsf{Actuator} \\sqsubseteq \\mathsf{Device}$\n$5.$ $\\mathsf{Sensor} \\sqcap \\mathsf{Actuator} \\sqsubseteq \\bot$\n$6.$ $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$\n$7.$ $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$\n\nThe ABox contains the following $8$ assertions, which we label for clarity:\n$\\mathcal{A}_1: \\mathsf{hasRole}(x_1, r_1)$\n$\\mathcal{A}_2: r_1 : \\mathsf{SenseRole}$\n$\\mathcal{A}_3: \\mathsf{hasRole}(x_1, r_2)$\n$\\mathcal{A}_4: r_2 : \\mathsf{ActRole}$\n$\\mathcal{A}_5: \\mathsf{hasRole}(x_2, r_2)$\n$\\mathcal{A}_6: x_2 : \\mathsf{TemperatureSensor}$\n$\\mathcal{A}_7: \\mathsf{hasRole}(x_3, r_1)$\n$\\mathcal{A}_8: x_3 : \\mathsf{ValveActuator}$\n\n**Step 1: Check for Inconsistency**\n\nWe analyze the class memberships of each individual $x_1$, $x_2$, and $x_3$.\n\nFor individual $x_1$:\n- From ABox assertions $\\mathcal{A}_1: \\mathsf{hasRole}(x_1, r_1)$ and $\\mathcal{A}_2: r_1 : \\mathsf{SenseRole}$, we can infer that $x_1$ is an instance of the class $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole}$.\n- From TBox axiom $6$, $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$, we conclude $x_1 : \\mathsf{Sensor}$.\n- From ABox assertions $\\mathcal{A}_3: \\mathsf{hasRole}(x_1, r_2)$ and $\\mathcal{A}_4: r_2 : \\mathsf{ActRole}$, we can infer that $x_1$ is an instance of the class $\\exists \\mathsf{hasRole}.\\mathsf{ActRole}$.\n- From TBox axiom $7$, $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$, we conclude $x_1 : \\mathsf{Actuator}$.\nSince $x_1$ is an instance of both $\\mathsf{Sensor}$ and $\\mathsf{Actuator}$, this violates the disjointness axiom $5$. Thus, the ontology is inconsistent, and $x_1$ is a source of the contradiction.\n\nFor individual $x_2$:\n- From ABox assertion $\\mathcal{A}_6: x_2 : \\mathsf{TemperatureSensor}$ and TBox axiom $1$, $\\mathsf{TemperatureSensor} \\sqsubseteq \\mathsf{Sensor}$, we conclude $x_2 : \\mathsf{Sensor}$.\n- From ABox assertions $\\mathcal{A}_5: \\mathsf{hasRole}(x_2, r_2)$ and $\\mathcal{A}_4: r_2 : \\mathsf{ActRole}$, we infer $x_2 : \\exists \\mathsf{hasRole}.\\mathsf{ActRole}$.\n- From TBox axiom $7$, $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$, we conclude $x_2 : \\mathsf{Actuator}$.\nSince $x_2$ is an instance of both $\\mathsf{Sensor}$ and $\\mathsf{Actuator}$, this violates axiom $5$. Individual $x_2$ is also a source of contradiction.\n\nFor individual $x_3$:\n- From ABox assertions $\\mathcal{A}_7: \\mathsf{hasRole}(x_3, r_1)$ and $\\mathcal{A}_2: r_1 : \\mathsf{SenseRole}$, we infer $x_3 : \\exists \\mathsf{hasRole}.\\mathsf{SenseRole}$.\n- From TBox axiom $6$, $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$, we conclude $x_3 : \\mathsf{Sensor}$.\n- From ABox assertion $\\mathcal{A}_8: x_3 : \\mathsf{ValveActuator}$ and TBox axiom $2$, $\\mathsf{ValveActuator} \\sqsubseteq \\mathsf{Actuator}$, we conclude $x_3 : \\mathsf{Actuator}$.\nSince $x_3$ is an instance of both $\\mathsf{Sensor}$ and $\\mathsf{Actuator}$, this violates axiom $5$. Individual $x_3$ is also a source of contradiction.\n\n**Step 2: Identify Minimal Causes (Conflict Sets)**\n\nTo repair the ontology by only deleting ABox assertions, we must identify the minimal sets of ABox assertions that cause each inconsistency. These are known as conflict sets (or justifications).\n\n- For $x_1$, the inconsistency arises from the combination of assertions that lead to $x_1:\\mathsf{Sensor}$ and $x_1:\\mathsf{Actuator}$. The minimal set of ABox assertions is $\\{\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3, \\mathcal{A}_4\\}$. Let this be the conflict set $C_1$. Removal of any single assertion from $C_1$ resolves the contradiction for $x_1$.\n\n- For $x_2$, the inconsistency is caused by the assertions leading to $x_2:\\mathsf{Sensor}$ and $x_2:\\mathsf{Actuator}$. The minimal set is $\\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\}$. Let this be the conflict set $C_2$.\n\n- For $x_3$, the inconsistency is caused by the assertions leading to $x_3:\\mathsf{Sensor}$ and $x_3:\\mathsf{Actuator}$. The minimal set is $\\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\}$. Let this be the conflict set $C_3$.\n\nSo we have the collection of conflict sets:\n$C_1 = \\{\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3, \\mathcal{A}_4\\}$\n$C_2 = \\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\}$\n$C_3 = \\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\}$\n\n**Step 3: Compute Minimal Repair Sets**\n\nA repair set is a set of ABox assertions whose removal makes the ontology consistent. To resolve all three contradictions, the repair set must \"hit\" every conflict set. That is, a repair set $R$ must have a non-empty intersection with each of $C_1$, $C_2$, and $C_3$. Such a set is called a hitting set for the collection $\\{C_1, C_2, C_3\\}$.\n\nThe problem defines a \"minimal ABox-deletion repair set\" as being \"inclusion-minimal and of smallest possible cardinality\". A hitting set of smallest possible cardinality is, by definition, a minimum hitting set. Any minimum hitting set is also inclusion-minimal. Thus, we need to find the number of minimum-cardinality hitting sets for $\\{C_1, C_2, C_3\\}$.\n\nFirst, we determine the minimum cardinality.\n- Cardinality $1$: Is there a single assertion that hits all three sets? This would require an element in the intersection $C_1 \\cap C_2 \\cap C_3 = \\{\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3, \\mathcal{A}_4\\} \\cap \\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\} \\cap \\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\} = \\emptyset$. Since the intersection is empty, no single assertion can repair all three inconsistencies. The minimum cardinality is greater than $1$.\n\n- Cardinality $2$: Can we find a hitting set of size $2$? A set $\\{\\alpha, \\beta\\}$ is a hitting set if it intersects with $C_1$, $C_2$, and $C_3$. This is possible if one element hits two conflict sets, and the other element hits the third. Let's examine the pairwise intersections of the conflict sets:\n  - $C_1 \\cap C_2 = \\{\\mathcal{A}_4\\}$. If we select $\\mathcal{A}_4$ for our repair set, we have hit $C_1$ and $C_2$. To hit the remaining set $C_3 = \\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\}$, we can add any of its elements. This gives us three possible repair sets of size $2$: $\\{\\mathcal{A}_4, \\mathcal{A}_2\\}$, $\\{\\mathcal{A}_4, \\mathcal{A}_7\\}$, and $\\{\\mathcal{A}_4, \\mathcal{A}_8\\}$.\n  - $C_1 \\cap C_3 = \\{\\mathcal{A}_2\\}$. If we select $\\mathcal{A}_2$, we have hit $C_1$ and $C_3$. To hit the remaining set $C_2 = \\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\}$, we can add any of its elements. This gives us three possible repair sets of size $2$: $\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$, $\\{\\mathcal{A}_2, \\mathcal{A}_5\\}$, and $\\{\\mathcal{A}_2, \\mathcal{A}_6\\}$.\n  - $C_2 \\cap C_3 = \\emptyset$. There is no single element that hits both $C_2$ and $C_3$.\n\nSince we have found repair sets of size $2$, the smallest possible cardinality for a repair set is $2$.\n\n**Step 4: Count the Distinct Minimal Repair Sets**\n\nWe now list all distinct repair sets of cardinality $2$:\nFrom the analysis of $C_1 \\cap C_2$:\n$1.$ $\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$\n$2.$ $\\{\\mathcal{A_4}, \\mathcal{A}_7\\}$\n$3.$ $\\{\\mathcal{A}_4, \\mathcal{A}_8\\}$\n\nFrom the analysis of $C_1 \\cap C_3$:\n$4.$ $\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$ (This is the same as set $1$)\n$5.$ $\\{\\mathcal{A}_2, \\mathcal{A}_5\\}$\n$6.$ $\\{\\mathcal{A}_2, \\mathcal{A}_6\\}$\n\nCombining these lists and removing duplicates, we obtain the following distinct minimal repair sets:\n$1.$ $\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$\n$2.$ $\\{\\mathcal{A}_4, \\mathcal{A}_7\\}$\n$3.$ $\\{\\mathcal{A}_4, \\mathcal{A}_8\\}$\n$4.$ $\\{\\mathcal{A}_2, \\mathcal{A}_5\\}$\n$5.$ $\\{\\mathcal{A}_2, \\mathcal{A}_6\\}$\n\nThere are $5$ distinct minimal ABox-deletion repair sets. Each set is of cardinality $2$, which is the minimum possible, and is inclusion-minimal. Therefore, the number $N$ is $5$.",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}