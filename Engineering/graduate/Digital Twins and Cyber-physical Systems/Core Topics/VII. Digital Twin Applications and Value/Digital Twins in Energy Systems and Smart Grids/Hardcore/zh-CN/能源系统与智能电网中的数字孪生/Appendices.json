{
    "hands_on_practices": [
        {
            "introduction": "数字孪生在智能电网中的核心职责之一是实现高效经济的运行。本实践将引导您解决经典的经济调度问题，即在满足系统负荷需求和发电机运行限制的前提下，如何分配各发电机的出力以最小化总发电成本。通过实施一个基于拉格朗日乘子法的迭代算法，您将亲手构建数字孪生优化引擎的一个基本模块，并深入理解保证电网经济性的基本原则。",
            "id": "4216903",
            "problem": "一个智能电网聚合商的数字孪生为一组火力发电机组执行稳态经济调度，这些发电机组通过二次燃料成本函数进行建模。该数字孪生维持供需之间的有功功率平衡约束，并强制执行发电机运行限制。考虑由 $i \\in \\{1,2,3\\}$ 索引的三个发电机组，每个机组都有一个凸二次成本函数 $C_i(P_i) = a_i + b_i P_i + c_i P_i^2$ 和运行限制 $P_i^{\\min} \\le P_i \\le P_i^{\\max}$。其中，$P_i$ 是以兆瓦 (MW) 为单位的有功功率输出，$a_i$ 是以美元/小时 ($/h$) 为单位的固定小时成本，$b_i$ 是以美元/兆瓦时 ($/(MW \\cdot h)$) 为单位的线性成本系数，$c_i$ 是以美元/兆瓦平方时 ($/(MW^2 \\cdot h)$) 为单位的二次成本系数。系统负荷 $P_D$ (单位为 MW) 必须由发电机输出的总和精确满足。传输损耗被忽略，从而得出单一等式约束 $\\sum_{i=1}^{3} P_i = P_D$。\n\n该问题的基本依据是：\n- 稳态下的物理功率平衡定律 $\\sum_{i=1}^{3} P_i = P_D$。\n- 由于 $c_i > 0$，每个发电机的成本函数 $C_i(P_i)$ 具有凸性，这意味着在可行的情况下，经济调度目标存在唯一的全局最小值点。\n- 用于凸优化的 Karush-Kuhn-Tucker (KKT) 条件，包括平稳性、原始可行性、对偶可行性以及互补松弛性，这些条件应用于在等式约束和边界约束下最小化 $\\sum_{i=1}^{3} C_i(P_i)$ 的问题。\n\n您的任务是编写一个完整的、可运行的程序，该程序针对每个测试用例，计算出经济调度设定点 $P_1$、$P_2$ 和 $P_3$ (单位为 MW)，以在满足约束条件 $\\sum_{i=1}^{3} P_i = P_D$ 和 $P_i^{\\min} \\le P_i \\le P_i^{\\max}$ 的情况下，最小化总成本 $\\sum_{i=1}^{3} C_i(P_i)$。如果负荷不可行（即 $P_D  \\sum_{i=1}^{3} P_i^{\\min}$ 或 $P_D > \\sum_{i=1}^{3} P_i^{\\max}$），程序必须返回一个布尔值以指示不可行性。\n\n程序必须实现一个从基本依据推导出的基于原理的算法，并且不得依赖临时的捷径。对于可行的用例，计算出的输出必须是四舍五入到三位小数的浮点数，并表示以 MW 为单位的功率和以美元/小时 ($/h$) 为单位的总成本。此问题不涉及角度。对于任何不可行的测试用例，程序必须输出布尔值 $false$ 而不是数值结果。\n\n使用以下具有指定参数值的测试套件：\n- 测试用例 1 (预期为内部解的一般可行情况)：\n  - 发电机 1：$a_1 = 100$, $b_1 = 18$, $c_1 = 0.035$, $P_1^{\\min} = 40$, $P_1^{\\max} = 200$。\n  - 发电机 2：$a_2 = 120$, $b_2 = 16$, $c_2 = 0.040$, $P_2^{\\min} = 30$, $P_2^{\\max} = 150$。\n  - 发电机 3：$a_3 = 150$, $b_3 = 20$, $c_3 = 0.030$, $P_3^{\\min} = 50$, $P_3^{\\max} = 180$。\n  - 负荷：$P_D = 320$。\n- 测试用例 2 (在最小总输出下的边界情况)：\n  - 发电机与测试用例 1 相同。\n  - 负荷：$P_D = 120$ (等于 $\\sum_{i=1}^{3} P_i^{\\min}$)。\n- 测试用例 3 (在最大总输出下的边界情况)：\n  - 发电机与测试用例 1 相同。\n  - 负荷：$P_D = 530$ (等于 $\\sum_{i=1}^{3} P_i^{\\max}$)。\n- 测试用例 4 (不可行的高负荷)：\n  - 发电机与测试用例 1 相同。\n  - 负荷：$P_D = 600$ (超过 $\\sum_{i=1}^{3} P_i^{\\max}$)。\n- 测试用例 5 (接近最小值的可行情况，其中一些发电机可能达到其下限)：\n  - 发电机与测试用例 1 相同。\n  - 负荷：$P_D = 160$。\n\n输出规范：\n- 对于每个可行的测试用例，返回一个列表 $[P_1, P_2, P_3, \\text{total\\_cost}]$，其中 $P_1$、$P_2$ 和 $P_3$ 的单位是 MW，$\\text{total\\_cost}$ 的单位是 $/h$，所有值都四舍五入到三位小数。\n- 对于每个不可行的测试用例，返回布尔值 $false$。\n- 您的程序应生成单行输出，其中包含所有测试用例的聚合结果，格式为方括号内以逗号分隔的列表，例如 $[result_1, result_2, \\dots]$，其中每个 $result_k$ 是按规定格式的列表或布尔值 $false$。",
            "solution": "所提出的问题是电力系统工程中一个经典的、适定的、有科学依据的问题，称为经济调度。它是一个约束优化问题，其有效性基于以下分析得到确认。获得唯一解所需的所有数据均已提供，成本函数是凸的，约束是线性的，这保证了在存在可行解的情况下，存在唯一的全局最小值。该问题没有矛盾、歧义和事实错误。因此，我们可以进行形式化的求解。\n\n目标是最小化总发电成本 $J$，即各个发电机成本的总和：\n$$\n\\text{Minimize } J = \\sum_{i=1}^{3} C_i(P_i) = \\sum_{i=1}^{3} (a_i + b_i P_i + c_i P_i^2)\n$$\n受两种类型的约束：\n\n1.  **功率平衡约束**：总发电功率必须精确满足系统负荷需求 $P_D$。传输损耗被忽略，从而得到等式约束：\n    $$\n    \\sum_{i=1}^{3} P_i = P_D\n    $$\n\n2.  **发电机运行限制**：每个发电机 $i$ 都有最小和最大功率输出，形成一组不等式约束（箱式约束）：\n    $$\n    P_i^{\\min} \\le P_i \\le P_i^{\\max} \\quad \\text{for } i \\in \\{1, 2, 3\\}\n    $$\n\n这是一个凸优化问题，因为目标函数是凸二次函数的和（由于所有 $c_i > 0$），并且约束定义了一个凸可行域。通过应用 Karush-Kuhn-Tucker (KKT) 条件，可以系统地找到解。\n\n我们构建拉格朗日函数 $\\mathcal{L}$，它整合了目标函数和所有约束：\n$$\n\\mathcal{L} = \\sum_{i=1}^{3} C_i(P_i) + \\lambda \\left(P_D - \\sum_{i=1}^{3} P_i\\right) + \\sum_{i=1}^{3} \\mu_i (P_i - P_i^{\\max}) + \\sum_{i=1}^{3} \\nu_i (P_i^{\\min} - P_i)\n$$\n其中 $\\lambda$ 是功率平衡等式约束的拉格朗日乘子，$\\mu_i$ 和 $\\nu_i$ 分别是上、下限不等式约束的 KKT 乘子。$\\lambda$ 项具有关键的经济解释，即系统的能量增量成本，通常称为系统边际价格，单位为美元/兆瓦时 ($/(MW \\cdot h)$)。\n\n通过将拉格朗日函数对每个决策变量 $P_i$ 的偏导数设为零，可以找到最优性的一阶必要条件（平稳性）：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial P_i} = \\frac{d C_i(P_i)}{d P_i} - \\lambda + \\mu_i - \\nu_i = 0\n$$\n由于 $\\frac{dC_i}{dP_i} = b_i + 2 c_i P_i$，这是发电机 $i$ 的增量成本 ($IC_i$)，我们有：\n$$\nIC_i(P_i) = b_i + 2 c_i P_i = \\lambda - \\mu_i + \\nu_i\n$$\nKKT 条件还包括原始可行性（必须满足原始约束）、对偶可行性（$\\mu_i \\ge 0$, $\\nu_i \\ge 0$）和互补松弛性（$\\mu_i (P_i - P_i^{\\max}) = 0$ 和 $\\nu_i (P_i^{\\min} - P_i) = 0$）。\n\n这些条件导出了一个清晰的调度逻辑：\n- 如果一个发电机严格在其限制范围内运行（$P_i^{\\min}  P_i  P_i^{\\max}$），那么其乘子 $\\mu_i$ 和 $\\nu_i$ 必须为零。这将平稳性条件简化为 $IC_i(P_i) = \\lambda$。这就是“等增量成本准则”：所有未达到其限制的发电机必须以相同的增量成本运行，该成本等于系统边际价格 $\\lambda$。\n- 如果一个发电机处于其上限（$P_i = P_i^{\\max}$），那么 $\\nu_i = 0$ 且 $\\mu_i \\ge 0$，这意味着 $IC_i(P_i^{\\max}) \\le \\lambda$。\n- 如果一个发电机处于其下限（$P_i = P_i^{\\min}$），那么 $\\mu_i = 0$ 且 $\\nu_i \\ge 0$，这意味着 $IC_i(P_i^{\\min}) \\ge \\lambda$。\n\n这个框架为寻找最优调度提供了一个基于原理的算法。问题的核心是找到唯一的 $\\lambda$ 值，使得由此产生的功率输出总和恰好与负荷 $P_D$ 相匹配。\n\n**算法：使用二分法搜索的 Lambda 迭代法**\n\n1.  **可行性检查**：首先，我们验证负荷 $P_D$ 是否可满足。\n    - 计算总最小容量：$P_{\\text{total}}^{\\min} = \\sum_{i=1}^{3} P_i^{\\min}$。\n    - 计算总最大容量：$P_{\\text{total}}^{\\max} = \\sum_{i=1}^{3} P_i^{\\max}$。\n    - 如果 $P_D  P_{\\text{total}}^{\\min}$ 或 $P_D > P_{\\text{total}}^{\\max}$，则不存在可行解。该问题被判定为不可行。\n\n2.  **迭代搜索 $\\lambda$**：对于一个可行的负荷，我们必须找到最优的 $\\lambda$。我们可以将每个 $P_i$ 表示为 $\\lambda$ 和发电机限制的函数。从 $b_i + 2 c_i P_i = \\lambda$，我们得到无约束功率 $P_i^{\\text{unconstrained}} = (\\lambda - b_i) / (2c_i)$。考虑到限制，实际的调度量为：\n    $$\n    P_i(\\lambda) = \\max(P_i^{\\min}, \\min(P_i^{\\max}, \\frac{\\lambda - b_i}{2c_i}))\n    $$\n    目标是求解方程 $f(\\lambda) = \\sum_{i=1}^{3} P_i(\\lambda) - P_D = 0$。由于 $f(\\lambda)$ 是关于 $\\lambda$ 的单调非减函数，我们可以使用像二分法搜索这样的鲁棒数值方法来找到它的根。\n    a.  **建立搜索边界**：我们需要为 $\\lambda$ 设定一个搜索区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$。可以选择一个安全的、足够宽的范围（例如 $[0, 1000]$），因为算法无论如何都会收敛。\n    b.  **迭代**：二分法通过重复地将搜索区间减半来进行：\n        i.  计算中点 $\\lambda_{\\text{mid}} = (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$。\n        ii. 计算此 $\\lambda_{\\text{mid}}$ 下的总调度功率：$P_{\\text{total}} = \\sum_{i=1}^{3} P_i(\\lambda_{\\text{mid}})$。\n        iii. 如果 $P_{\\text{total}}  P_D$，这意味着我们的增量成本 $\\lambda_{\\text{mid}}$ 太低，不足以激励足够的发电量。我们更新 $\\lambda_{\\text{low}} = \\lambda_{\\text{mid}}$。\n        iv. 如果 $P_{\\text{total}} > P_D$，我们的 $\\lambda_{\\text{mid}}$ 太高。我们更新 $\\lambda_{\\text{high}} = \\lambda_{\\text{mid}}$。\n    c.  **终止**：迭代持续固定的步数，或者直到区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 足够小，从而保证 $\\lambda$ 的一个精确值。\n\n3.  **最终计算**：一旦找到最优的 $\\lambda$，就使用 $P_i(\\lambda)$ 公式计算每个发电机的最终调度量 $[P_1, P_2, P_3]$。然后将这些功率值代回成本函数的总和 $\\sum C_i(P_i)$ 中，计算出最小总成本。最后按规定对结果进行四舍五入。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the economic dispatch problem for all test cases.\n    \"\"\"\n\n    # Generator parameters: (a, b, c, P_min, P_max)\n    gen_params = [\n        (100, 18, 0.035, 40, 200),  # Gen 1\n        (120, 16, 0.040, 30, 150),  # Gen 2\n        (150, 20, 0.030, 50, 180)   # Gen 3\n    ]\n\n    # Test cases: Load P_D in MW\n    test_cases_pd = [320, 120, 530, 600, 160]\n\n    results = []\n    for p_d in test_cases_pd:\n        result = calculate_dispatch(gen_params, p_d)\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = []\n    for res in results:\n        if isinstance(res, bool):\n            formatted_results.append(str(res).lower())\n        else:\n            # Format list to string '[v1, v2, ...]' without extra spaces\n            formatted_list = f\"[{','.join(f'{v:.3f}' for v in res)}]\"\n            formatted_results.append(formatted_list)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_dispatch(generators, p_d):\n    \"\"\"\n    Calculates the economic dispatch for a set of generators and a given load.\n\n    Args:\n        generators (list of tuples): Each tuple contains (a, b, c, p_min, p_max).\n        p_d (float): The total load demand in MW.\n\n    Returns:\n        list: A list [P1, P2, P3, total_cost] for a feasible solution, \n              rounded to three decimal places.\n        bool: False if the load is infeasible.\n    \"\"\"\n    p_mins = np.array([g[3] for g in generators])\n    p_maxs = np.array([g[4] for g in generators])\n    \n    p_total_min = np.sum(p_mins)\n    p_total_max = np.sum(p_maxs)\n\n    # Step 1: Feasibility Check\n    if not (p_total_min = p_d = p_total_max):\n        return False\n\n    # Special boundary cases for efficiency\n    if p_d == p_total_min:\n        powers = p_mins\n    elif p_d == p_total_max:\n        powers = p_maxs\n    else:\n        # Step 2: Iterative Search for lambda using Bisection\n        b_coeffs = np.array([g[1] for g in generators])\n        c_coeffs = np.array([g[2] for g in generators])\n        \n        lambda_low = 0.0\n        lambda_high = 200.0  # A sufficiently large upper bound for lambda\n        tolerance = 1e-7\n        max_iterations = 100\n\n        for _ in range(max_iterations):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            \n            # Calculate power from each generator for the current lambda\n            # P_i = (lambda - b_i) / (2 * c_i)\n            # Clip is used to enforce generator limits P_min = P_i = P_max\n            current_powers = np.clip((lambda_mid - b_coeffs) / (2 * c_coeffs), p_mins, p_maxs)\n            \n            power_total = np.sum(current_powers)\n            power_mismatch = power_total - p_d\n            \n            if abs(power_mismatch)  tolerance:\n                break\n            \n            if power_mismatch  0:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        final_lambda = (lambda_low + lambda_high) / 2.0\n        powers = np.clip((final_lambda - b_coeffs) / (2 * c_coeffs), p_mins, p_maxs)\n\n    # Step 3: Final Calculation\n    total_cost = 0.0\n    for i, p_i in enumerate(powers):\n        a, b, c, _, _ = generators[i]\n        total_cost += a + b * p_i + c * p_i**2\n        \n    return [powers[0], powers[1], powers[2], total_cost]\n\nsolve()\n```"
        },
        {
            "introduction": "除了经济性，可靠性是电网运行的生命线，而数字孪生是保障可靠性的强大工具。本练习模拟了一种真实的数字孪生工作流程：利用快速的直流潮流近似模型进行快速的故障筛选，然后对标记出的高风险情况使用更精确的交流潮流模型进行详细分析。这项实践将让您掌握在数字孪生中应用多保真度模型的价值，并获得处理最广泛使用的潮流计算方法的实践经验。",
            "id": "4217031",
            "problem": "一家电力公司运营着一个智能电网的三母线区段，该区段配备了一个高保真数字孪生（一个由相量测量单元（PMU）数据驱动的虚拟副本）。该数字孪生支持事故分析，通过使用直流（DC）潮流近似法快速筛选潜在的线路过载，然后利用测量的电压幅值，通过交流（AC）潮流校核对标记出的情况进行精化。\n\n考虑标记为 $1$、$2$ 和 $3$ 的母线，其中母线 $3$ 作为平衡节点（参考相角）。该网络由无损线路组成，其串联电抗分别为 $X_{12}$、$X_{23}$ 和 $X_{13}$，且没有并联元件。系统基准容量为 $100 \\, \\mathrm{MVA}$。数字孪生报告了事故前的净有功功率注入（以 $100 \\, \\mathrm{MVA}$ 为基准的标幺值）为 $P_{1} = 0.6$，$P_{2} = -0.1$，以及用于平衡其余功率的 $P_{3}$。线路参数如下：\n- $X_{12} = 0.1$（因此 $b_{12} = 1/X_{12} = 10$），\n- $X_{23} = 0.2$（因此 $b_{23} = 1/X_{23} = 5$），\n- $X_{13} = 0.125$（因此 $b_{13} = 1/X_{13} = 8$）。\n\n线路 $(1,2)$ 的热稳定极限为 $55 \\, \\mathrm{MW}$。电力公司考虑线路 $(1,3)$ 跳闸的单一事故。\n\n从无损线路 $(i,j)$ 上的交流有功潮流出发，\n$$\nP_{ij} = V_{i} V_{j} |Y_{ij}| \\sin(\\theta_{i} - \\theta_{j}),\n$$\n以及节点有功功率平衡方程，\n$$\nP_{i} = \\sum_{j \\in \\mathcal{N}(i)} V_{i} V_{j} |Y_{ij}| \\sin(\\theta_{i} - \\theta_{j}),\n$$\n推导一种使用直流潮流近似（即，$V_{i} \\approx 1$，$\\sin(\\theta_{i} - \\theta_{j}) \\approx \\theta_{i} - \\theta_{j}$，线路为纯电抗性，因此 $|Y_{ij}| = b_{ij} = 1/X_{ij}$）的快速筛选方法，以计算事故后的母线电压相角，并判断线路 $(1,2)$ 是否可能违反其极限。然后，利用数字孪生在母线 $1$ 和 $2$ 处测得的事故后电压幅值（即 $V_{1} = 0.98$ 和 $V_{2} = 1.02$），结合为跳闸后拓扑结构通过直流法计算出的相角差，进行一次交流精化计算。使用\n$$\nP_{12}^{\\mathrm{AC}} = V_{1} V_{2} b_{12} \\sin(\\theta_{1} - \\theta_{2})\n$$\n进行精化校核。\n\n提供线路 $(1,2)$ 上经过交流精化计算的最终事故后有功潮流值，以 $100$ MVA 为基准，单位为 $\\mathrm{MW}$，并将答案四舍五入至四位有效数字。假设在直流解中母线 $3$ 的相角为 $0$，并且为跳闸后拓扑计算出的直流相角足够精确，可用于交流精化计算中的正弦函数求值。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、提法得当、客观且完整。所有数据和条件均与电力系统分析的既定原则相符。该问题描述了数字孪生在事故分析中应用的一个现实场景，提供了推导唯一解所需的所有必要参数和假设。因此，该问题被认为是有效的。\n\n解题过程按要求分两个阶段进行：首先，使用直流（DC）潮流近似法进行快速筛选，以计算事故后的母线电压相角；然后，使用交流（AC）公式和测量的电压幅值进行精化的潮流计算。\n\n首先，我们从给定的交流潮流方程建立直流潮流模型。无损线路 $(i,j)$ 上的交流有功潮流由下式给出\n$$\nP_{ij} = V_{i} V_{j} |Y_{ij}| \\sin(\\theta_{i} - \\theta_{j})\n$$\n对于高压输电网络，直流近似依赖于以下三个假设：\n1.  电压幅值近似为额定值：对于所有母线 $i$，$V_{i} \\approx 1$ 标幺值。\n2.  线路两端的相角差很小，因此 $\\sin(\\theta_{i} - \\theta_{j}) \\approx \\theta_{i} - \\theta_{j}$（相角以弧度为单位）。\n3.  输电线路主要是电抗性的，因此线路阻抗为 $Z_{ij} = jX_{ij}$，线路导纳幅值为 $|Y_{ij}| = 1/X_{ij} = b_{ij}$，其中 $b_{ij}$ 是线路电纳。\n\n应用这些近似，可得到线路的直流潮流公式：\n$$\nP_{ij} \\approx (1)(1) b_{ij} (\\theta_{i} - \\theta_{j}) = b_{ij}(\\theta_{i} - \\theta_{j})\n$$\n母线 $i$ 的节点有功功率平衡为 $P_{i} = \\sum_{j} P_{ij}$，可变为：\n$$\nP_{i} \\approx \\sum_{j} b_{ij}(\\theta_{i} - \\theta_{j})\n$$\n这构成了一个线性方程组，可以写成矩阵形式 $P = B \\theta$，其中 $P$ 是节点功率注入向量，$B$ 是网络的电纳矩阵，$\\theta$ 是母线电压相角向量。\n\n问题指定了一个线路 $(1,3)$ 跳闸的事故。我们必须分析事故后的系统。假设非平衡节点（$1$ 和 $2$）的功率注入保持其事故前的值不变：$P_{1} = 0.6$ 标幺值，$P_{2} = -0.1$ 标幺值。母线 $3$ 是平衡节点，因此其相角为参考值，$\\theta_{3} = 0$。\n\n在事故后网络中，线路 $(1,3)$ 被移除。剩余的连接是线路 $(1,2)$，其 $X_{12} = 0.1$ 标幺值（$b_{12} = 10$ 标幺值），以及线路 $(2,3)$，其 $X_{23} = 0.2$ 标幺值（$b_{23} = 5$ 标幺值）。我们为非平衡节点（$1$ 和 $2$）构建降阶电纳矩阵 $B'$。\n\n$B'$ 矩阵的元素为：\n$B'_{11} = \\sum_{j \\neq 1} b_{1j} = b_{12} = 10$\n$B'_{22} = \\sum_{j \\neq 2} b_{2j} = b_{21} + b_{23} = b_{12} + b_{23} = 10 + 5 = 15$\n$B'_{12} = B'_{21} = -b_{12} = -10$\n\n事故后状态的直流潮流矩阵方程为：\n$$\n\\begin{pmatrix} P_{1} \\\\ P_{2} \\end{pmatrix} = B' \\begin{pmatrix} \\theta_{1} \\\\ \\theta_{2} \\end{pmatrix}\n$$\n代入已知值：\n$$\n\\begin{pmatrix} 0.6 \\\\ -0.1 \\end{pmatrix} = \\begin{pmatrix} 10  -10 \\\\ -10  15 \\end{pmatrix} \\begin{pmatrix} \\theta_{1} \\\\ \\theta_{2} \\end{pmatrix}\n$$\n为了求解相角 $\\theta_{1}$ 和 $\\theta_{2}$，我们求 $B'$ 矩阵的逆矩阵。其行列式为 $\\det(B') = (10)(15) - (-10)(-10) = 150 - 100 = 50$。\n逆矩阵为：\n$$\n(B')^{-1} = \\frac{1}{50} \\begin{pmatrix} 15  10 \\\\ 10  10 \\end{pmatrix} = \\begin{pmatrix} 0.3  0.2 \\\\ 0.2  0.2 \\end{pmatrix}\n$$\n现在，我们可以求解相角向量：\n$$\n\\begin{pmatrix} \\theta_{1} \\\\ \\theta_{2} \\end{pmatrix} = (B')^{-1} \\begin{pmatrix} P_{1} \\\\ P_{2} \\end{pmatrix} = \\begin{pmatrix} 0.3  0.2 \\\\ 0.2  0.2 \\end{pmatrix} \\begin{pmatrix} 0.6 \\\\ -0.1 \\end{pmatrix}\n$$\n计算各个相角：\n$$\n\\theta_{1} = (0.3)(0.6) + (0.2)(-0.1) = 0.18 - 0.02 = 0.16 \\text{ 弧度}\n$$\n$$\n\\theta_{2} = (0.2)(0.6) + (0.2)(-0.1) = 0.12 - 0.02 = 0.10 \\text{ 弧度}\n$$\n线路 $(1,2)$ 上的事故后直流潮流为 $P_{12}^{\\mathrm{DC}} = b_{12}(\\theta_{1} - \\theta_{2}) = 10(0.16 - 0.10) = 10(0.06) = 0.6$ 标幺值。在 $100$ MVA 基准下，这相当于 $0.6 \\times 100 = 60$ MW。由于这超过了 $55$ MW 的热稳定极限，因此有必要进行更精确的交流精化计算。\n\n对于交流精化计算，我们使用所提供的公式和数字孪生测量的事故后电压幅值，$V_{1} = 0.98$ 标幺值和 $V_{2} = 1.02$ 标幺值。我们按照规定，使用从直流模型计算出的相角差 $\\Delta\\theta = \\theta_{1} - \\theta_{2} = 0.06$ 弧度。\n线路 $(1,2)$ 上经过交流精化的潮流为：\n$$\nP_{12}^{\\mathrm{AC}} = V_{1} V_{2} b_{12} \\sin(\\theta_{1} - \\theta_{2})\n$$\n代入数值：\n$$\nP_{12}^{\\mathrm{AC}} = (0.98)(1.02)(10) \\sin(0.06)\n$$\n首先，计算电压的乘积：$V_{1} V_{2} = 0.98 \\times 1.02 = 0.9996$。\n以标幺值表示的潮流为：\n$$\nP_{12}^{\\mathrm{AC}}[\\text{p.u.}] = (0.9996)(10) \\sin(0.06) = 9.996 \\sin(0.06)\n$$\n使用计算器计算 $\\sin(0.06)$（以弧度为单位）：\n$$\n\\sin(0.06) \\approx 0.059964006\n$$\n$$\nP_{12}^{\\mathrm{AC}}[\\text{p.u.}] \\approx 9.996 \\times 0.059964006 \\approx 0.599400199\n$$\n为将此值以 MW 表示，我们将其乘以系统基准 MVA：\n$$\nP_{12}^{\\mathrm{AC}}[\\mathrm{MW}] = P_{12}^{\\mathrm{AC}}[\\text{p.u.}] \\times 100 \\text{ MVA} \\approx 0.599400199 \\times 100 = 59.9400199 \\text{ MW}\n$$\n将最终答案四舍五入到四位有效数字，我们得到 $59.94$ MW。",
            "answer": "$$\\boxed{59.94}$$"
        },
        {
            "introduction": "现代数字孪生越来越多地采用数据驱动的代理模型进行快速预测，但理解这些复杂模型的决策依据是一个关键挑战。本实践将向您介绍如何使用源于合作博弈论的沙普利值（Shapley values），来解释代理模型对电网电压的预测结果。通过这项前沿练习，您将探索人工智能、模型可解释性与电力系统交叉领域的最新应用，并了解数字孪生如何提供超越单纯预测的深刻洞察。",
            "id": "4217006",
            "problem": "您正在开发一个智能电网中配电馈线的数字孪生（Digital Twin, DT），其中 DT 使用代理模型来预测监测母线电压的标幺值（per-unit, pu）大小。在此信息物理背景下，您需要使用合作博弈论中的 Shapley 值来计算代理模型电压限值预测的特征归因，并解释其操作含义。请从基本定义开始。具体来说，考虑以下确定性代理模型，该模型将系统特征映射到预测的电压幅值：\n$$\nf(\\mathbf{x}) = v_0 + s_1\\big(x_1 - b_1\\big) + s_2\\big(x_2 - b_2\\big) + s_3\\big(x_3 - b_3\\big) + s_4\\big(x_4 - b_4\\big) + s_{12}\\big(x_1 - b_1\\big)\\big(x_2 - b_2\\big),\n$$\n其中 $f(\\mathbf{x})$ 是以标幺值表示的电压幅值，$\\mathbf{x} = [x_1,x_2,x_3,x_4]$ 是特征，$\\mathbf{b} = [b_1,b_2,b_3,b_4]$ 是基准特征值，$v_0$ 是监测母线处的基准电压幅值，$s_i$ 是线性灵敏度，$s_{12}$ 是一个双线性相互作用灵敏度，用于捕捉净负荷和分布式发电之间的相互作用。这些特征是：\n- $x_1$：监测节点处的净负荷，单位为千瓦（$\\mathrm{kW}$），\n- $x_2$：光伏分布式发电输出功率，单位为千瓦（$\\mathrm{kW}$），\n- $x_3$：电容器组注入的无功功率，单位为千伏安无功（$\\mathrm{kVAr}$），\n- $x_4$：变压器分接头位置偏移量（无量纲分接头步长）。\n\n使用以下科学上合理的参数值：\n- $v_0 = 1.00$ (pu),\n- $s_1 = -0.0002$ (pu per $\\mathrm{kW}$),\n- $s_2 = +0.00015$ (pu per $\\mathrm{kW}$),\n- $s_3 = +0.00005$ (pu per $\\mathrm{kVAr}$),\n- $s_4 = +0.01$ (pu per tap step),\n- $s_{12} = -1\\times 10^{-7}$ (pu per $\\mathrm{kW}^2$),\n- $\\mathbf{b} = [500,\\,100,\\,0,\\,0]$，单位如上对齐。\n\n定义运行电压范围，其下限为 $v_{\\mathrm{L}} = 0.95$ (pu)，上限为 $v_{\\mathrm{U}} = 1.05$ (pu)。如果预测电压 $f(\\mathbf{x})  v_{\\mathrm{L}}$ 或 $f(\\mathbf{x}) > v_{\\mathrm{U}}$，则表示超出限值。\n\n合作博弈论中的 Shapley 值通过对每个特征在所有特征联盟上的边际贡献进行平均，将预测差值 $f(\\mathbf{x}) - f(\\mathbf{b})$ 归因于每个特征。使用代理模型正式定义联盟值，其中缺失的特征设置为其基准值。通过枚举所有联盟并为每种联盟大小使用适当的阶乘权重，从定义出发实现精确的 Shapley 计算。\n\n测试套件：\n为以下特征向量 $\\mathbf{x}$ 计算 Shapley 值，顺序为 $[x_1,x_2,x_3,x_4]$，单位为 $[\\mathrm{kW},\\mathrm{kW},\\mathrm{kVAr},\\text{tap steps}]$：\n- 情况 A：$\\mathbf{x} = [450,\\,300,\\,200,\\,1]$，\n- 情况 B：$\\mathbf{x} = [700,\\,50,\\,0,\\,0]$，\n- 情况 C：$\\mathbf{x} = [500,\\,100,\\,0,\\,3]$，\n- 情况 D：$\\mathbf{x} = [500,\\,100,\\,0,\\,0]$，\n- 情况 E：$\\mathbf{x} = [400,\\,400,\\,500,\\,2]$。\n\n对于每种情况，计算：\n- Shapley 归因向量 $\\boldsymbol{\\phi} = [\\phi_1,\\phi_2,\\phi_3,\\phi_4]$，单位为标幺值 (pu)，\n- 预测电压 $f(\\mathbf{x})$，单位为标幺值 (pu)，\n- 限值违规布尔值，其中 $f(\\mathbf{x})  v_{\\mathrm{L}}$ 或 $f(\\mathbf{x}) > v_{\\mathrm{U}}$。\n\n将所有 Shapley 值和预测电压以标幺值 (pu) 表示，并四舍五入到恰好六位小数。布尔值必须表示为布尔值（True 或 False）。您的程序应生成单行输出，其中包含一个包含五个子列表的逗号分隔列表，每个子列表对应一种情况，格式如下：\n$$\n[\\phi_1,\\phi_2,\\phi_3,\\phi_4,f(\\mathbf{x}),\\text{violation}]\n$$\n例如，最终输出格式必须为：\n$$\n[[\\ldots],[\\ldots],[\\ldots],[\\ldots],[\\ldots]]\n$$\n除了这一行之外，不得有额外的空格或文本。\n\n覆盖设计：\n- 情况 A 是一个典型的日间场景，其中光伏发电和电容支持可能将电压推高至接近或超过上限。\n- 情况 B 是一个高负荷、低发电量的场景，用于测试接近下限的情况。\n- 情况 C 隔离了变压器分接头操作的主导效应。\n- 情况 D 是基准工作点，用于验证 Shapley 值是否为零以及电压是否等于基准值。\n- 情况 E 是一个极高发电量、高无功、低负荷的场景，对上限构成压力。\n\n您的实现必须是精确的，并且对于如上定义的 $M = 4$ 个特征具有通用性，使用联盟枚举定义。输出必须遵循指定的单行格式，标幺值四舍五入到六位小数。",
            "solution": "该问题陈述已经过严格验证，并被确定为是合理的。它在科学上基于电力系统工程和合作博弈论的原理，在数学上是适定的，并提供了一套完整、明确的数据和指令。任务是使用 Shapley 值的精确定义，为给定的智能电网组件代理模型计算特征归因。\n\n问题的核心是将预测母线电压与其基准值的偏差归因于贡献的系统特征。这是模型可解释性中的一个经典问题，此处应用于电力分配系统的数字孪生。\n\n首先，我们定义所提供的模型组件。特征集，即合作博弈中的参与者，是 $N = \\{1, 2, 3, 4\\}$。电压幅值 $f(\\mathbf{x})$ 的代理模型由下式给出：\n$$\nf(\\mathbf{x}) = v_0 + \\sum_{i=1}^{4} s_i(x_i - b_i) + s_{12}(x_1 - b_1)(x_2 - b_2)\n$$\n其中 $\\mathbf{x} = [x_1, x_2, x_3, x_4]$ 是特征向量，$\\mathbf{b} = [b_1, b_2, b_3, b_4]$ 是基准特征值向量。让我们将每个特征与其基准的偏差表示为 $\\delta_i = x_i - b_i$。模型可以更紧凑地写为：\n$$\nf(\\mathbf{x}) = v_0 + s_1\\delta_1 + s_2\\delta_2 + s_3\\delta_3 + s_4\\delta_4 + s_{12}\\delta_1\\delta_2\n$$\n基准预测是 $f(\\mathbf{b}) = v_0$，因为当 $\\mathbf{x} = \\mathbf{b}$ 时，所有 $\\delta_i$ 都为零。需要归因的总预测变化是 $\\Delta f = f(\\mathbf{x}) - f(\\mathbf{b})$。\n\n特征 $i$ 的 Shapley 值 $\\phi_i$ 是其对所有可能的特征联盟的平均边际贡献。联盟是所有特征集合 $N$ 的任何子集 $S$。联盟 $S$ 的价值，记为 $v(S)$，定义为当只有 $S$ 中的特征处于活动状态（即取自 $\\mathbf{x}$ 的值），而不在 $S$ 中的特征保持其基准值（取自 $\\mathbf{b}$）时模型的预测。令 $\\mathbf{x}_S$ 为一个特征向量，其第 $j$ 个分量是 $x_j$（如果 $j \\in S$）和 $b_j$（如果 $j \\notin S$）。那么，$v(S) = f(\\mathbf{x}_S) - f(\\mathbf{b})$。空联盟的价值 $v(\\emptyset)$ 是 $f(\\mathbf{b}) - f(\\mathbf{b}) = 0$。\n\n特征 $i$ 的 Shapley 值的公式是：\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|! (|N| - |S| - 1)!}{|N|!} \\left[ v(S \\cup \\{i\\}) - v(S) \\right]\n$$\n这里， $|N|=4$。项 $v(S \\cup \\{i\\}) - v(S)$ 是特征 $i$ 对联盟 $S$ 的边际贡献。该公式对所有不包含 $i$ 的可能联盟 $S$ 的这些边际贡献进行加权平均，权重由一个组合因子确定。\n\n要实现这一点，我们必须创建一个严格遵循此定义的计算过程。对于每个特征 $i \\in \\{1, 2, 3, 4\\}$，我们必须遍历其他特征的所有 $2^{|N|-1} = 2^3 = 8$ 个子集 $S$。对于每个这样的联盟 $S$，我们计算价值函数 $v(S)$ 和 $v(S \\cup \\{i\\})$。\n\n对于任何联盟 $C \\subseteq N$，其价值函数 $v(C)$ 为：\n$$\nv(C) = \\sum_{j \\in C} s_j \\delta_j + \\begin{cases} s_{12} \\delta_1 \\delta_2  \\text{if } \\{1, 2\\} \\subseteq C \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n计算算法将按以下步骤进行：\n1. 对于每个测试用例向量 $\\mathbf{x}$，首先计算偏差 $\\delta_i = x_i - b_i$。\n2. 初始化 Shapley 值向量 $\\boldsymbol{\\phi} = [0, 0, 0, 0]$。\n3. 对于每个特征 $i \\in \\{1, 2, 3, 4\\}$：\n    a. 定义其他特征的集合 $N' = N \\setminus \\{i\\}$。\n    b. 遍历 $N'$ 的所有子集 $S$。这可以通过循环一个从 $0$ 到 $2^{3}-1$ 的整数并使用其位表示来形成联盟 $S$ 来完成。\n    c. 对于每个 $S$，计算边际贡献 $\\Delta_i(S) = v(S \\cup \\{i\\}) - v(S)$。\n    d. 计算权重 $W(|S|) = \\frac{|S|! (3 - |S|)!}{4!}$。\n    e. 将加权贡献加到特征 $i$ 的总和中：$\\phi_i = \\phi_i + W(|S|) \\times \\Delta_i(S)$。\n4. 在遍历所有特征的所有联盟后，向量 $\\boldsymbol{\\phi}$ 将包含完整的 Shapley 归因。\n\n对于这个特定的多项式模型，可以推导出 Shapley 值的解析表达式。线性项的贡献完全分配给各自的特征，而交互项的贡献在相互作用的特征之间平均分配。这得出：\n$$\n\\phi_1 = s_1\\delta_1 + \\frac{1}{2}s_{12}\\delta_1\\delta_2 \\\\\n\\phi_2 = s_2\\delta_2 + \\frac{1}{2}s_{12}\\delta_1\\delta_2 \\\\\n\\phi_3 = s_3\\delta_3 \\\\\n\\phi_4 = s_4\\delta_4\n$$\n虽然这些公式为验证结果提供了方便的方法，但问题明确要求基于联盟枚举的实现。因此，提供的代码将执行此枚举。解析结果可作为代码正确性的独立验证。\n\n最后，对于每个测试用例，我们计算预测电压 $f(\\mathbf{x})$、Shapley 向量 $\\boldsymbol{\\phi}$ 和布尔电压限值违规，如果 $f(\\mathbf{x})  0.95$ 或 $f(\\mathbf{x}) > 1.05$，则为 `True`。所有数值结果按要求四舍五入到六位小数。最终输出是一个单行字符串，表示一个包含所有五个测试用例结果的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing Shapley values for a smart grid surrogate model.\n    \"\"\"\n\n    # Define model parameters and constants\n    params = {\n        'v0': 1.00,\n        's1': -0.0002,\n        's2': +0.00015,\n        's3': +0.00005,\n        's4': +0.01,\n        's12': -1e-7\n    }\n    b = np.array([500.0, 100.0, 0.0, 0.0]) # Baseline feature vector\n    v_L = 0.95\n    v_U = 1.05\n    M = 4 # Number of features\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([450.0, 300.0, 200.0, 1.0]),  # Case A\n        np.array([700.0, 50.0, 0.0, 0.0]),    # Case B\n        np.array([500.0, 100.0, 0.0, 3.0]),    # Case C\n        np.array([500.0, 100.0, 0.0, 0.0]),    # Case D\n        np.array([400.0, 400.0, 500.0, 2.0]),  # Case E\n    ]\n\n    def surrogate_model(x_vec: np.ndarray) -> float:\n        \"\"\"\n        Computes the predicted voltage using the surrogate model.\n        \n        Args:\n            x_vec: A numpy array of features [x1, x2, x3, x4].\n        \n        Returns:\n            The predicted voltage magnitude in per-unit.\n        \"\"\"\n        delta = x_vec - b\n        \n        term1 = params['s1'] * delta[0]\n        term2 = params['s2'] * delta[1]\n        term3 = params['s3'] * delta[2]\n        term4 = params['s4'] * delta[3]\n        term12 = params['s12'] * delta[0] * delta[1]\n        \n        return params['v0'] + term1 + term2 + term3 + term4 + term12\n\n    def calculate_shapley_values(x_vec: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the exact Shapley values by enumerating all coalitions.\n        \n        Args:\n            x_vec: The feature vector for which to compute attributions.\n            \n        Returns:\n            A numpy array containing the Shapley values [phi1, phi2, phi3, phi4].\n        \"\"\"\n        \n        def value_function(coalition: list, current_x: np.ndarray) -> float:\n            \"\"\"\n            Calculates the value of a coalition of features.\n            v(S) = f(x_S) - f(b)\n            \"\"\"\n            x_S = np.copy(b)\n            for feature_idx in coalition:\n                x_S[feature_idx] = current_x[feature_idx]\n            \n            # Since f(b) = v0, the value is f(x_S) - v0.\n            return surrogate_model(x_S) - params['v0']\n\n        phis = np.zeros(M)\n        factorials = [math.factorial(i) for i in range(M + 1)]\n        \n        feature_indices = list(range(M))\n\n        for i in range(M):\n            shapley_i = 0.0\n            other_features = [j for j in feature_indices if j != i]\n            \n            for k in range(len(other_features) + 1):\n                for S_tuple in combinations(other_features, k):\n                    S = list(S_tuple)\n                    \n                    # Marginal contribution of feature i to coalition S\n                    # v(S U {i}) - v(S)\n                    marginal_contrib = value_function(S + [i], x_vec) - value_function(S, x_vec)\n                    \n                    # Weight for this coalition size\n                    s_cardinality = len(S)\n                    weight = (factorials[s_cardinality] * factorials[M - 1 - s_cardinality]) / factorials[M]\n                    \n                    shapley_i += weight * marginal_contrib\n                    \n            phis[i] = shapley_i\n            \n        return phis\n\n    results = []\n    for x_case in test_cases:\n        # Calculate Shapley values, predicted voltage, and violation status\n        phi_vector = calculate_shapley_values(x_case)\n        voltage = surrogate_model(x_case)\n        violation = not (v_L = voltage = v_U)\n        \n        # Format the results according to the specification\n        phi_str_list = [f\"{p:.6f}\" for p in phi_vector]\n        voltage_str = f\"{voltage:.6f}\"\n        violation_str = str(violation)\n        \n        sublist_items = phi_str_list + [voltage_str, violation_str]\n        sublist_str = f\"[{','.join(sublist_items)}]\"\n        results.append(sublist_str)\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}