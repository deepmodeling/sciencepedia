{
    "hands_on_practices": [
        {
            "introduction": "为了实现有效的人机回圈协作，自主系统必须能够理解或预测人类的行为。本练习将演示一种基础方法：通过观测数据为人类操作员建立数学模型，这一过程称为系统辨识。你将学习如何校准一个经典的人类控制模型，并验证其预测能力，这是构建智能人机交互系统的关键一步。",
            "id": "4226720",
            "problem": "考虑一个在单自由度跟踪任务的数字孪生中的带人在环的共享自主场景。人类操作员和自主助手共同产生一个控制动作以减少一个标量跟踪误差信号。数字孪生提供跟踪误差和执行的控制动作的同步时间序列。目标是仅使用下述基本假设和定义，从数据中标定一个参数化的人类控制模型，并在一个留出数据集上进行验证。\n\n基本建模假设：\n1) 人类产生的控制动作被建模为对经过滤波的内部误差感知的带噪声线性反馈。连续时间内部感知 $s(t)$ 满足一阶线性微分方程 $\\tau \\, \\frac{d s(t)}{d t} + s(t) = e(t)$，其中 $e(t)$ 是外部可测量的跟踪误差，$\\tau  0$ 是人类时间常数。人类控制信号是 $u_{\\mathrm{h}}(t) = K_{\\mathrm{h}} \\, s(t) + w(t)$，其中 $K_{\\mathrm{h}}$ 是人类反馈增益，$w(t)$ 是方差为 $\\sigma^2$ 的零均值高斯白噪声。\n2) 自主系统应用一个已知的线性反馈 $u_{\\mathrm{a}}(t) = -K_{\\mathrm{a}} \\, e(t)$，其中 $K_{\\mathrm{a}}$ 是已知的正数。执行的控制指令是一个凸混合 $u(t) = \\alpha \\, u_{\\mathrm{h}}(t) + (1 - \\alpha) \\, u_{\\mathrm{a}}(t)$，其中混合系数 $\\alpha \\in (0,1]$ 是已知的。\n3) 数字孪生以固定采样周期 $\\Delta t  0$ 提供离散时间样本。内部感知的离散近似使用应用于连续时间模型的前向欧拉法，对于样本索引 $k \\in \\{0,1,\\dots\\}$，得到 $s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}\\,(e_k - s_k)$，初始条件为 $s_0 = 0$。三角函数中使用的所有角度均以弧度为单位。\n\n标定目标：\n给定 $N$ 对 $(e_k, u_k)$（$k = 0,1,\\dots,N-1$），以及已知的 $\\Delta t$、$\\alpha$ 和 $K_{\\mathrm{a}}$，通过在零均值独立高斯噪声模型下最大化似然来估计人类参数 $\\tau$、 $K_{\\mathrm{h}}$ 和 $\\sigma^2$。您必须将 $\\tau$ 视为非线性参数，将 $K_{\\mathrm{h}}$ 视为线性参数。对 $\\tau$ 在约束 $\\tau \\in [\\tau_{\\min}, \\tau_{\\max}]$ 内使用均匀网格进行网格搜索，对于每个 $\\tau$ 计算 $K_{\\mathrm{h}}$ 的闭式最小二乘估计，然后计算 $\\sigma^2$ 的最大似然估计。选择使负对数似然最小的 $\\tau$。\n\n验证目标：\n给定一个长度为 $N_{\\mathrm{val}}$ 的留出数据集 $(e^{\\mathrm{val}}_k, u^{\\mathrm{val}}_k)$，通过使用标定的 $\\hat{\\tau}$ 和 $\\hat{K}_{\\mathrm{h}}$（无噪声）运行相同的前向欧拉递归来计算单步前向预测 $\\hat{u}^{\\mathrm{val}}_k$。评估归一化均方根误差，其定义为 $\\mathrm{NRMSE} = \\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\hat{u}^{\\mathrm{val}}_k\\right)^2} \\Big/ \\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\bar{u}^{\\mathrm{val}}\\right)^2}$，其中 $\\bar{u}^{\\mathrm{val}}$ 是 $u^{\\mathrm{val}}_k$ 的样本均值。归一化均方根误差是无量纲的。所有时间常数必须以秒为单位表示。\n\n数据生成（须由您的程序严格按照规定实现）：\n- 对于任何给定的 $\\Delta t$、$N$ 以及频率 $f_1, f_2$（单位赫兹），定义 $t_k = k \\, \\Delta t$ 和激励误差序列 $e_k = \\sin(2\\pi f_1 t_k) + 0.5 \\, \\sin(2\\pi f_2 t_k)$，其中 $k = 0,1,\\dots,N-1$。验证误差序列使用相同的公式，但频率为 $f_1^{\\mathrm{val}}$ 和 $f_2^{\\mathrm{val}}$。\n- 执行的指令序列由带人在环模型生成：首先，递归计算 $s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}\\,(e_k - s_k)$，其中 $s_0 = 0$；然后计算 $u_{\\mathrm{h},k} = K_{\\mathrm{h}} \\, s_k + w_k$，其中 $w_k \\sim \\mathcal{N}(0,\\sigma^2)$；自主指令是 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} \\, e_k$；执行的指令是 $u_k = \\alpha \\, u_{\\mathrm{h},k} + (1 - \\alpha)\\, u_{\\mathrm{a},k}$。相同的无噪声递归用于验证预测 $\\hat{u}^{\\mathrm{val}}_k$；测量的验证指令 $u^{\\mathrm{val}}_k$ 包含如上抽样的噪声。\n- 随机性必须是可复现的。对于每个数据集，为伪随机数生成器使用独立的固定种子来抽取 $\\{w_k\\}$。\n\n估计方法（须由您的程序严格按照规定实现）：\n- 对于一个候选的 $\\tau$，通过运行 $s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}\\,(e_k - s_k)$（其中 $s_0 = 0$）并计算 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} e_k$ 来形成确定性回归器序列。定义混合的自主补偿响应 $z_k = u_k - (1 - \\alpha)\\, u_{\\mathrm{a},k}$ 和回归器 $\\phi_k = \\alpha \\, s_k$。$K_{\\mathrm{h}}$ 的最小二乘估计是 $\\hat{K}_{\\mathrm{h}}(\\tau) = \\frac{\\sum_{k=0}^{N-1} \\phi_k z_k}{\\sum_{k=0}^{N-1} \\phi_k^2}$。残差是 $r_k(\\tau) = z_k - \\phi_k \\, \\hat{K}_{\\mathrm{h}}(\\tau)$，噪声方差的最大似然估计是 $\\hat{\\sigma}^2(\\tau) = \\frac{1}{N} \\sum_{k=0}^{N-1} r_k(\\tau)^2$。负对数似然（不计与参数无关的加性常数）为 $J(\\tau) = \\frac{N}{2} \\log\\left(\\hat{\\sigma}^2(\\tau)\\right)$。选择在网格上使 $J(\\tau)$ 最小的 $\\hat{\\tau}$，并设置 $\\hat{K}_{\\mathrm{h}} = \\hat{K}_{\\mathrm{h}}(\\hat{\\tau})$ 和 $\\hat{\\sigma}^2 = \\hat{\\sigma}^2(\\hat{\\tau})$。\n\n网格规格：\n- 对于每个测试案例，在 $\\tau \\in [\\tau_{\\min}, \\tau_{\\max}]$ 上使用一个包含 $M = 300$ 个点的均匀网格，其中 $\\tau_{\\min} = \\max\\{0.55 \\, \\Delta t, 0.02\\}$ 且 $\\tau_{\\max} = 0.6$。这确保了前向欧拉递归是稳定的，因为 $0  \\frac{\\Delta t}{\\tau}  2$。\n\n测试套件：\n使用以下参数实现三个独立的标定和验证任务。所有时间常数和采样周期以秒为单位；频率以赫兹为单位；增益是无量纲的；噪声标准差的单位与控制指令的单位相同；三角函数中的角度以弧度为单位。为每个案例生成训练数据集和验证数据集。\n\n案例 A：\n- $\\Delta t = 0.02$, $\\alpha = 0.7$, $K_{\\mathrm{a}} = 0.9$, $K_{\\mathrm{h}} = 1.1$, $\\tau = 0.15$, $\\sigma = 0.05$,\n- $N = 1500$, $N_{\\mathrm{val}} = 800$,\n- $f_1 = 0.3$, $f_2 = 0.7$, $f_1^{\\mathrm{val}} = 0.45$, $f_2^{\\mathrm{val}} = 1.1$,\n- 训练种子 $= 12345$, 验证种子 $= 54321$。\n\n案例 B：\n- $\\Delta t = 0.05$, $\\alpha = 0.9$, $K_{\\mathrm{a}} = 1.0$, $K_{\\mathrm{h}} = 0.8$, $\\tau = 0.03$, $\\sigma = 0.02$,\n- $N = 1200$, $N_{\\mathrm{val}} = 600$,\n- $f_1 = 0.2$, $f_2 = 0.5$, $f_1^{\\mathrm{val}} = 0.35$, $f_2^{\\mathrm{val}} = 0.9$,\n- 训练种子 $= 22222$, 验证种子 $= 33333$。\n\n案例 C：\n- $\\Delta t = 0.01$, $\\alpha = 0.6$, $K_{\\mathrm{a}} = 1.2$, $K_{\\mathrm{h}} = 1.8$, $\\tau = 0.25$, $\\sigma = 0.08$,\n- $N = 2000$, $N_{\\mathrm{val}} = 1000$,\n- $f_1 = 0.4$, $f_2 = 0.95$, $f_1^{\\mathrm{val}} = 0.25$, $f_2^{\\mathrm{val}} = 0.6$,\n- 训练种子 $= 44444$, 验证种子 $= 55555$。\n\n所需输出：\n- 对于每个案例，使用上述程序计算标定后的元组 $(\\hat{\\tau}, \\hat{K}_{\\mathrm{h}}, \\hat{\\sigma}^2)$，并根据留出数据集计算验证 $\\mathrm{NRMSE}$。按此顺序将所有四个值报告为实数。\n- 单位：以秒为单位报告 $\\hat{\\tau}$；其他量与模型单位一致，其中 $\\hat{K}_{\\mathrm{h}}$ 和 $\\mathrm{NRMSE}$ 是无量纲的，而 $\\hat{\\sigma}^2$ 的单位是控制指令单位的平方。\n- 数值格式：将报告的每个数字四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个含三个列表的列表，每个案例一个，其中每个内部列表为 $[\\hat{\\tau}, \\hat{K}_{\\mathrm{h}}, \\hat{\\sigma}^2, \\mathrm{NRMSE}]$，每个值都四舍五入到六位小数，并且行中没有任何空格。例如：\"[[0.123456,1.234567,0.012345,0.345678],[...],[...]]\"。程序不得读取任何输入，也不得打印任何其他内容。",
            "solution": "该问题要求在一个带人在环的共享自主系统中，对人类操作员控制行为的参数化模型进行标定和验证。任务是从综合生成的跟踪误差和控制动作的时间序列中，估计人类的感知时间常数 $\\tau$、反馈增益 $K_{\\mathrm{h}}$ 和噪声方差 $\\sigma^2$，然后在另一个独立的数据集上验证标定好的模型。\n\n解决方案主要分为三个阶段：(1) 数据生成，(2) 模型标定，和 (3) 模型验证。\n\n**1. 数据生成**\n\n问题规定了生成训练和验证数据集的精确流程。\n- 跟踪误差信号 $e_k$ 是两个正弦波的确定性总和：$e_k = \\sin(2\\pi f_1 t_k) + 0.5 \\sin(2\\pi f_2 t_k)$，其中 $t_k = k \\Delta t$。\n- 人类操作员对误差的内部感知 $s_k$ 被建模为误差 $e_k$ 的一阶低通滤波版本。其离散时间动态由连续时间模型 $\\tau \\dot{s} + s = e$ 的前向欧拉近似给出：\n$$s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}(e_k - s_k)$$\n初始条件为 $s_0 = 0$。\n- 人类的控制动作 $u_{\\mathrm{h},k}$ 是对该内部状态的带噪声线性反馈：\n$$u_{\\mathrm{h},k} = K_{\\mathrm{h}} s_k + w_k$$\n其中 $w_k$ 是来自方差为 $\\sigma^2$ 的零均值高斯分布的独立样本，即 $w_k \\sim \\mathcal{N}(0, \\sigma^2)$。\n- 自主助手提供一个简单的比例控制动作 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} e_k$。\n- 最终执行的控制指令 $u_k$ 是人类和自主控制动作的凸组合，由混合系数 $\\alpha$ 控制：\n$$u_k = \\alpha u_{\\mathrm{h},k} + (1 - \\alpha) u_{\\mathrm{a},k}$$\n此完整生成模型被实现用于产生训练数据对 $(e_k, u_k)$ 和验证数据对 $(e^{\\mathrm{val}}_k, u^{\\mathrm{val}}_k)$，并为可复现性使用独立的伪随机数生成器种子。\n\n**2. 模型标定**\n\n标定目标是从训练数据 $(e_k, u_k)$ 和已知的系统参数 $(\\Delta t, \\alpha, K_{\\mathrm{a}})$ 中估计参数 $(\\tau, K_{\\mathrm{h}}, \\sigma^2)$。该估计策略利用了模型的结构，该模型在 $\\tau$ 上是非线性的，但在 $K_{\\mathrm{h}}$ 上是线性的。这是一个可分离的非线性最小二乘问题。\n\n首先，我们重排共享控制方程以分离出人类的贡献。给定 $u_k$ 和 $e_k$，我们可以计算自主系统的贡献 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} e_k$。人类的贡献（由 $\\alpha$ 缩放）则为：\n$$\\alpha u_{\\mathrm{h},k} = u_k - (1 - \\alpha) u_{\\mathrm{a},k}$$\n我们将这个可观测量定义为 $z_k \\equiv u_k - (1-\\alpha)u_{\\mathrm{a},k}$。代入 $u_{\\mathrm{h},k}$ 的模型，我们得到回归方程：\n$$z_k = \\alpha (K_{\\mathrm{h}} s_k + w_k) = K_{\\mathrm{h}} (\\alpha s_k) + \\alpha w_k$$\n该方程在参数 $K_{\\mathrm{h}}$ 上是线性的，但在 $\\tau$ 上是非线性的，因为 $s_k$ 是 $\\tau$ 的函数。\n\n估计过程通过对非线性参数 $\\tau$ 进行网格搜索来进行。对于来自 $[\\tau_{\\min}, \\tau_{\\max}]$ 上均匀网格的每个候选值 $\\tau_{\\mathrm{cand}}$，我们执行以下步骤：\n- **生成回归器：** 内部状态序列 $s_k(\\tau_{\\mathrm{cand}})$ 是使用已知训练误差 $e_k$ 和候选值 $\\tau_{\\mathrm{cand}}$ 通过前向欧拉递归计算得出的。回归器则为 $\\phi_k(\\tau_{\\mathrm{cand}}) = \\alpha s_k(\\tau_{\\mathrm{cand}})$。\n- **估计 $K_{\\mathrm{h}}$：** 对于固定的 $\\tau$，模型为 $z_k = K_{\\mathrm{h}} \\phi_k + \\text{噪声}$。最小化误差平方和的标准线性最小二乘估计 $K_{\\mathrm{h}}$ 为：\n$$\\hat{K}_{\\mathrm{h}}(\\tau_{\\mathrm{cand}}) = \\frac{\\sum_{k=0}^{N-1} \\phi_k z_k}{\\sum_{k=0}^{N-1} \\phi_k^2}$$\n- **估计噪声方差：** 此回归的残差为 $r_k(\\tau_{\\mathrm{cand}}) = z_k - \\hat{K}_{\\mathrm{h}}(\\tau_{\\mathrm{cand}}) \\phi_k$。问题将“噪声方差”的最大似然估计定义为这些残差的样本方差：\n$$\\hat{\\sigma}^2(\\tau_{\\mathrm{cand}}) = \\frac{1}{N} \\sum_{k=0}^{N-1} r_k(\\tau_{\\mathrm{cand}})^2$$\n请注意，这些残差 $r_k$ 是对缩放后的观测噪声 $\\alpha w_k$ 的估计，因此所定义的 $\\hat{\\sigma}^2$ 是对 $\\alpha^2 \\sigma^2$ 的估计。我们遵循这个明确的问题定义。\n- **评估成本函数：** 最优的 $\\tau$ 通过最大化剖面（profile）对数似然找到，这等同于最小化负对数似然。不计加性常数，负对数似然由下式给出：\n$$J(\\tau_{\\mathrm{cand}}) = \\frac{N}{2} \\log\\left(\\hat{\\sigma}^2(\\tau_{\\mathrm{cand}})\\right)$$\n最小化 $J(\\tau_{\\mathrm{cand}})$ 等价于最小化残差方差 $\\hat{\\sigma}^2(\\tau_{\\mathrm{cand}})$。\n- **选择最优参数：** 网格搜索找到使 $J(\\tau)$ 最小化的值 $\\hat{\\tau}$。最终的估计值即为 $\\hat{\\tau}$，以及相应的 $\\hat{K}_{\\mathrm{h}} = \\hat{K}_{\\mathrm{h}}(\\hat{\\tau})$ 和 $\\hat{\\sigma}^2 = \\hat{\\sigma}^2(\\hat{\\tau})$。\n\n**3. 模型验证**\n\n标定模型 $(\\hat{\\tau}, \\hat{K}_{\\mathrm{h}})$ 的性能在一个留出的验证数据集 $(e^{\\mathrm{val}}_k, u^{\\mathrm{val}}_k)$ 上进行评估。这包括生成控制指令的单步前向预测，并将其与测量的指令进行比较。\n\n- **预测：** 预测的控制信号 $\\hat{u}^{\\mathrm{val}}_k$ 是使用标定的模型参数生成的，但不包含噪声项。对于每个步骤 $k$：\n    1. 预测的内部状态 $\\hat{s}^{\\mathrm{val}}_k$ 使用验证误差 $e^{\\mathrm{val}}_k$ 和估计的时间常数 $\\hat{\\tau}$ 进行更新：\n       $$\\hat{s}^{\\mathrm{val}}_{k+1} = \\hat{s}^{\\mathrm{val}}_k + \\frac{\\Delta t}{\\hat{\\tau}}(e^{\\mathrm{val}}_k - \\hat{s}^{\\mathrm{val}}_k), \\quad \\hat{s}^{\\mathrm{val}}_0=0$$\n    2. 预测的无噪声人类指令是 $\\hat{u}_{\\mathrm{h},k}^{\\mathrm{val}} = \\hat{K}_{\\mathrm{h}} \\hat{s}^{\\mathrm{val}}_k$。\n    3. 最终的预测指令是混合后的结果：$\\hat{u}^{\\mathrm{val}}_k = \\alpha \\hat{u}_{\\mathrm{h},k}^{\\mathrm{val}} + (1 - \\alpha) u_{\\mathrm{a},k}^{\\mathrm{val}}$，其中 $u_{\\mathrm{a},k}^{\\mathrm{val}} = -K_{\\mathrm{a}} e^{\\mathrm{val}}_k$。\n\n- **评估指标：** 预测准确性由归一化均方根误差 (NRMSE) 来量化，其定义为预测误差的均方根 (RMS) 除以测量的验证信号的标准差：\n$$\\mathrm{NRMSE} = \\frac{\\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\hat{u}^{\\mathrm{val}}_k\\right)^2}}{\\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\bar{u}^{\\mathrm{val}}\\right)^2}}$$\n其中 $\\bar{u}^{\\mathrm{val}}$ 是测量的验证信号 $u^{\\mathrm{val}}_k$ 的样本均值。该指标提供了一个与尺度无关的模型拟合度度量。\n\n整个过程针对三个指定的测试案例实施，严格遵守所提供的参数、数据生成过程、估计方法和网格规格。",
            "answer": "```python\nimport numpy as np\n\ndef generate_data(dt, alpha, Ka, Kh, tau_true, sigma, freqs, N, seed):\n    \"\"\"\n    Generates synthetic data for the human-in-the-loop tracking task.\n    \"\"\"\n    f1, f2 = freqs\n    rng = np.random.default_rng(seed)\n    \n    t = np.arange(N) * dt\n    e = np.sin(2 * np.pi * f1 * t) + 0.5 * np.sin(2 * np.pi * f2 * t)\n    \n    s = np.zeros(N)\n    u_h = np.zeros(N)\n    u_a = -Ka * e\n    u = np.zeros(N)\n    w = rng.normal(0, sigma, N)\n    \n    for k in range(N - 1):\n        # Calculate controls at step k based on state s[k]\n        u_h[k] = Kh * s[k] + w[k]\n        u[k] = alpha * u_h[k] + (1 - alpha) * u_a[k]\n        \n        # Update state for step k+1 based on error and state at k\n        s[k+1] = s[k] + (dt / tau_true) * (e[k] - s[k])\n        \n    # Final step calculation\n    k = N - 1\n    u_h[k] = Kh * s[k] + w[k]\n    u[k] = alpha * u_h[k] + (1 - alpha) * u_a[k]\n    \n    return e, u\n\ndef calibrate_model(e_train, u_train, dt, alpha, Ka, N, M_grid=300):\n    \"\"\"\n    Calibrates the human model parameters using grid search and least squares.\n    \"\"\"\n    tau_min = max(0.55 * dt, 0.02)\n    tau_max = 0.6\n    tau_grid = np.linspace(tau_min, tau_max, M_grid)\n    \n    best_J = np.inf\n    hat_tau, hat_Kh, hat_sigma_sq = 0.0, 0.0, 0.0\n    \n    u_a_train = -Ka * e_train\n    z_train = u_train - (1 - alpha) * u_a_train\n    \n    for tau_cand in tau_grid:\n        s_cand = np.zeros(N)\n        for k in range(N - 1):\n            s_cand[k+1] = s_cand[k] + (dt / tau_cand) * (e_train[k] - s_cand[k])\n            \n        phi = alpha * s_cand\n        \n        phi_sq_sum = np.dot(phi, phi)\n        if phi_sq_sum  1e-15:\n            continue\n\n        Kh_cand = np.dot(phi, z_train) / phi_sq_sum\n        \n        r = z_train - phi * Kh_cand\n        sigma_sq_cand = np.mean(r**2)\n        \n        if sigma_sq_cand  1e-15:\n            continue\n            \n        J = N / 2.0 * np.log(sigma_sq_cand)\n        \n        if J  best_J:\n            best_J = J\n            hat_tau = tau_cand\n            hat_Kh = Kh_cand\n            hat_sigma_sq = sigma_sq_cand\n            \n    return hat_tau, hat_Kh, hat_sigma_sq\n\ndef validate_model(e_val, u_val, hat_tau, hat_Kh, dt, alpha, Ka, N_val):\n    \"\"\"\n    Validates the calibrated model and computes NRMSE.\n    \"\"\"\n    s_pred = np.zeros(N_val)\n    u_pred = np.zeros(N_val)\n    u_a_val = -Ka * e_val\n    \n    for k in range(N_val - 1):\n        u_h_pred_k = hat_Kh * s_pred[k]\n        u_pred[k] = alpha * u_h_pred_k + (1 - alpha) * u_a_val[k]\n        s_pred[k+1] = s_pred[k] + (dt / hat_tau) * (e_val[k] - s_pred[k])\n        \n    k = N_val - 1\n    u_h_pred_k = hat_Kh * s_pred[k]\n    u_pred[k] = alpha * u_h_pred_k + (1 - alpha) * u_a_val[k]\n    \n    rmse_num = np.sqrt(np.mean((u_val - u_pred)**2))\n    std_den = np.std(u_val)\n    \n    if std_den  1e-15:\n        return np.inf if rmse_num  1e-15 else 0.0\n    \n    nrmse = rmse_num / std_den\n    return nrmse\n\ndef solve():\n    \"\"\"\n    Main function to run the calibration and validation for all test cases.\n    \"\"\"\n    # M_grid is the number of points in the tau grid search\n    M_grid = 300\n\n    test_cases = [\n        {\n            # Case A\n            'params': {'dt': 0.02, 'alpha': 0.7, 'Ka': 0.9, 'Kh': 1.1, 'tau': 0.15, 'sigma': 0.05},\n            'data': {'N': 1500, 'N_val': 800, 'f1': 0.3, 'f2': 0.7, 'f1_val': 0.45, 'f2_val': 1.1},\n            'seeds': {'train': 12345, 'val': 54321}\n        },\n        {\n            # Case B\n            'params': {'dt': 0.05, 'alpha': 0.9, 'Ka': 1.0, 'Kh': 0.8, 'tau': 0.03, 'sigma': 0.02},\n            'data': {'N': 1200, 'N_val': 600, 'f1': 0.2, 'f2': 0.5, 'f1_val': 0.35, 'f2_val': 0.9},\n            'seeds': {'train': 22222, 'val': 33333}\n        },\n        {\n            # Case C\n            'params': {'dt': 0.01, 'alpha': 0.6, 'Ka': 1.2, 'Kh': 1.8, 'tau': 0.25, 'sigma': 0.08},\n            'data': {'N': 2000, 'N_val': 1000, 'f1': 0.4, 'f2': 0.95, 'f1_val': 0.25, 'f2_val': 0.6},\n            'seeds': {'train': 44444, 'val': 55555}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p = case['params']\n        d = case['data']\n        s = case['seeds']\n\n        # 1. Generate training and validation data\n        e_train, u_train = generate_data(p['dt'], p['alpha'], p['Ka'], p['Kh'], p['tau'], p['sigma'], \n                                         (d['f1'], d['f2']), d['N'], s['train'])\n        e_val, u_val = generate_data(p['dt'], p['alpha'], p['Ka'], p['Kh'], p['tau'], p['sigma'], \n                                     (d['f1_val'], d['f2_val']), d['N_val'], s['val'])\n\n        # 2. Calibrate model parameters\n        hat_tau, hat_Kh, hat_sigma_sq = calibrate_model(e_train, u_train, p['dt'], p['alpha'], p['Ka'], d['N'], M_grid)\n\n        # 3. Validate model and compute NRMSE\n        nrmse = validate_model(e_val, u_val, hat_tau, hat_Kh, p['dt'], p['alpha'], p['Ka'], d['N_val'])\n\n        all_results.append([hat_tau, hat_Kh, hat_sigma_sq, nrmse])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join([f'{v:.6f}' for v in res])}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当同时获得人类和自主系统的输入时，我们应如何融合它们？本练习将共享自主问题构建为一个多目标优化问题，这是一种功能强大且普遍应用的方法。你将实践推导并实现一个解决方案，该方案能够在尊重安全约束的前提下，最优化地平衡任务性能、对人类意图的遵从以及与自主系统建议的一致性。",
            "id": "4226636",
            "problem": "考虑一个信息物理系统的共享自治控制器，其中数字孪生预测了控制输入与安全相关状态之间的线性化映射。设控制输入为一个向量 $u \\in \\mathbb{R}^2$。数字孪生提供一个线性映射 $S \\in \\mathbb{R}^{2 \\times 2}$ 和一个期望安全参考 $s_{\\mathrm{ref}} \\in \\mathbb{R}^2$。自治模块提出 $u_{\\mathrm{auto}} \\in \\mathbb{R}^2$，而人类操作员提出 $u_{\\mathrm{human}} \\in \\mathbb{R}^2$。一个信任参数 $\\tau \\in [0,1]$ 调节赋予自治模块和人类操作员的相对权重。定义权重 $w_{\\mathrm{p}}(\\tau) = \\beta (1 - \\tau)$ 和 $w_{\\mathrm{h}}(\\tau) = \\beta \\tau$，其中 $\\beta  0$，以及一个固定的安全-性能权重 $w_{\\mathrm{s}}  0$。\n\n该多目标优化问题是找到 $u^\\star$ 以最小化以下成本：\n$$\nJ(u; \\tau) = w_{\\mathrm{s}} \\lVert S u - s_{\\mathrm{ref}} \\rVert_2^2 + w_{\\mathrm{p}}(\\tau) \\lVert u - u_{\\mathrm{auto}} \\rVert_2^2 + w_{\\mathrm{h}}(\\tau) \\lVert u - u_{\\mathrm{human}} \\rVert_2^2\n$$\n服从于线性安全约束\n$$\nc^\\top u \\le d,\n$$\n其中 $c \\in \\mathbb{R}^2$ 且 $d \\in \\mathbb{R}$。\n\n仅从凸优化的基本定义和二次型的结构出发，不使用任何预先推导的捷径公式，推导此问题的必要最优性条件，并实现一个算法，为给定的参数集计算 $u^\\star$。推导必须基于第一性原理：正定二次型的性质、梯度以及由线性不等式施加的可行性条件。\n\n您的程序必须为下面指定的每个测试用例计算 $u^\\star$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。输出列表中的每个元素本身必须是一个双元素列表，表示相应测试用例的最优控制 $u^\\star$，每个数字四舍五入到六位小数，例如 $[[u_{1,1},u_{1,2}],[u_{2,1},u_{2,2}],\\ldots]$。不应打印任何额外文本。\n\n不涉及物理单位；所有量均为无量纲。不使用角度。不得出现百分比；任何分数应表示为小数。\n\n测试套件：\n- 案例 $1$ (通用“理想路径”)：\n  - $S = \\begin{bmatrix} 1.0  0.2 \\\\ 0.1  1.5 \\end{bmatrix}$，\n  - $s_{\\mathrm{ref}} = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$，\n  - $u_{\\mathrm{auto}} = \\begin{bmatrix} 0.5 \\\\ -0.3 \\end{bmatrix}$，\n  - $u_{\\mathrm{human}} = \\begin{bmatrix} 0.0 \\\\ 0.8 \\end{bmatrix}$，\n  - $\\beta = 2.0$，\n  - $w_{\\mathrm{s}} = 1.0$，\n  - $c = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$，\n  - $d = 1.0$，\n  - $\\tau = 0.5$。\n- 案例 $2$ (激活安全约束)：\n  - 与案例 $1$ 中的 $S$, $s_{\\mathrm{ref}}$, $u_{\\mathrm{auto}}$, $u_{\\mathrm{human}}$, $\\beta$, $w_{\\mathrm{s}}$, $c$ 相同，\n  - $d = 0.5$，\n  - $\\tau = 0.5$。\n- 案例 $3$ (信任边界在 $\\tau = 0$)：\n  - 与案例 $1$ 中的 $S$, $s_{\\mathrm{ref}}$, $u_{\\mathrm{auto}}$, $u_{\\mathrm{human}}$, $\\beta$, $w_{\\mathrm{s}}$, $c$ 相同，\n  - $d = 0.55$，\n  - $\\tau = 0.0$。\n- 案例 $4$ (信任边界在 $\\tau = 1$，且在约束边界上可行)：\n  - 与案例 $1$ 中的 $S$, $s_{\\mathrm{ref}}$, $u_{\\mathrm{auto}}$, $u_{\\mathrm{human}}$, $\\beta$, $w_{\\mathrm{s}}$, $c$ 相同，\n  - $\\tau = 1.0$，\n  - 将 $d$ 设置为等于 $c^\\top u_{\\mathrm{uncon}}$，其中 $u_{\\mathrm{uncon}}$ 是案例 4 中给定参数的无约束最优解。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个案例的 $u^\\star$ 按案例 1 到 4 的顺序列出，每个均为一个双元素列表，四舍五入到六位小数，例如：$[[x_{1,1},x_{1,2}],[x_{2,1},x_{2,2}],[x_{3,1},x_{3,2}],[x_{4,1},x_{4,2}]]$。",
            "solution": "问题是找到最优控制输入 $u^\\star \\in \\mathbb{R}^2$，使其在满足单个线性不等式约束的条件下，最小化一个二次成本函数。这是一个经典的二次规划 (QP) 问题。其解可以利用约束优化的 Karush-Kuhn-Tucker (KKT) 条件从第一性原理推导得出。\n\n优化问题表述如下：\n$$\n\\min_{u \\in \\mathbb{R}^2} J(u; \\tau) = w_{\\mathrm{s}} \\lVert S u - s_{\\mathrm{ref}} \\rVert_2^2 + w_{\\mathrm{p}}(\\tau) \\lVert u - u_{\\mathrm{auto}} \\rVert_2^2 + w_{\\mathrm{h}}(\\tau) \\lVert u - u_{\\mathrm{human}} \\rVert_2^2\n$$\n服从于约束：\n$$\nc^\\top u \\le d\n$$\n\n为清晰起见，我们将权重表示为 $w_s$、$w_p$ 和 $w_h$。\n\n**1. 成本函数的展开与简化**\n\n成本函数 $J(u)$ 是欧几里得范数平方的和。我们展开每一项，将 $J(u)$ 表示为标准二次型。使用恒等式 $\\lVert x \\rVert_2^2 = x^\\top x$，我们有：\n- $w_s \\lVert S u - s_{\\mathrm{ref}} \\rVert_2^2 = w_s (u^\\top S^\\top S u - 2 s_{\\mathrm{ref}}^\\top S u + s_{\\mathrm{ref}}^\\top s_{\\mathrm{ref}})$\n- $w_p \\lVert u - u_{\\mathrm{auto}} \\rVert_2^2 = w_p (u^\\top u - 2 u_{\\mathrm{auto}}^\\top u + u_{\\mathrm{auto}}^\\top u_{\\mathrm{auto}})$\n- $w_h \\lVert u - u_{\\mathrm{human}} \\rVert_2^2 = w_h (u^\\top u - 2 u_{\\mathrm{human}}^\\top u + u_{\\mathrm{human}}^\\top u_{\\mathrm{human}})$\n\n将这些项相加，并按 $u$ 的幂次分组，我们可以将 $J(u)$ 写成 $J(u) = u^\\top A u - 2 b^\\top u + \\gamma$ 的形式，其中不依赖于 $u$ 的项被收集在 $\\gamma$ 中。\n\n二次项是 $u^\\top (w_s S^\\top S + w_p I + w_h I) u$。线性项是 $-2 (w_s s_{\\mathrm{ref}}^\\top S + w_p u_{\\mathrm{auto}}^\\top + w_h u_{\\mathrm{human}}^\\top) u$。\n\n我们定义矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$ 和向量 $b \\in \\mathbb{R}^2$ 如下：\n$A = w_s S^\\top S + (w_p + w_h)I$\n$b = w_s S^\\top s_{\\mathrm{ref}} + w_p u_{\\mathrm{auto}} + w_h u_{\\mathrm{human}}$\n\n使用定义 $w_p(\\tau) = \\beta (1 - \\tau)$ 和 $w_h(\\tau) = \\beta \\tau$，它们的和是 $w_p + w_h = \\beta$。\n因此，表达式变为：\n$$\nA = w_s S^\\top S + \\beta I\n$$\n$$\nb = w_s S^\\top s_{\\mathrm{ref}} + \\beta(1-\\tau) u_{\\mathrm{auto}} + \\beta\\tau u_{\\mathrm{human}}\n$$\n现在成本函数为 $J(u) = u^\\top A u - 2 b^\\top u + \\text{constant}$。\n\n**2. 凸性与无约束解**\n\n为了找到 $J(u)$ 的最小值，我们首先计算它关于 $u$ 的梯度：\n$$\n\\nabla_u J(u) = 2 A u - 2 b\n$$\n成本函数的海森矩阵是 $\\nabla_u^2 J(u) = 2A = 2(w_s S^\\top S + \\beta I)$。由于 $w_s  0$ 且 $\\beta  0$，并且 $S^\\top S$ 是一个半正定矩阵，海森矩阵是一个半正定矩阵 ($2w_s S^\\top S$) 和一个正定矩阵 ($2\\beta I$) 的和。因此，海森矩阵是正定的。这证明了 $J(u)$ 是一个严格凸函数，从而保证了存在唯一的全局最小值。\n\n对于无约束问题，通过将梯度设为零来找到最小值 $u_{\\mathrm{uncon}}$：\n$$\n\\nabla_u J(u_{\\mathrm{uncon}}) = 2 A u_{\\mathrm{uncon}} - 2 b = 0\n$$\n$$\nA u_{\\mathrm{uncon}} = b\n$$\n由于 $A$ 是正定的，它是可逆的。唯一的无约束最优解是：\n$$\nu_{\\mathrm{uncon}} = A^{-1} b\n$$\n\n**3. 约束问题的 Karush-Kuhn-Tucker (KKT) 条件**\n\n对于约束问题，我们使用 KKT 条件。拉格朗日函数是：\n$\\mathcal{L}(u, \\lambda) = J(u) + \\lambda(c^\\top u - d)$，其中 $\\lambda$ 是拉格朗日乘子。\n\n最优解 $u^\\star$ 和乘子 $\\lambda^\\star$ 的 KKT 条件是：\n1.  **驻定性:** $\\nabla_u \\mathcal{L}(u^\\star, \\lambda^\\star) = \\nabla_u J(u^\\star) + \\lambda^\\star c = 0$\n2.  **原始可行性:** $c^\\top u^\\star - d \\le 0$\n3.  **对偶可行性:** $\\lambda^\\star \\ge 0$\n4.  **互补松弛性:** $\\lambda^\\star (c^\\top u^\\star - d) = 0$\n\n根据互补松弛性条件，我们分析两种不同的情况。\n\n**情况 I：约束未激活 ($c^\\top u^\\star - d  0$)。**\n根据互补松弛性，如果 $c^\\top u^\\star - d  0$，那么 $\\lambda^\\star$ 必须为 $0$。\n将 $\\lambda^\\star = 0$ 代入驻定性条件得到：\n$$\n\\nabla_u J(u^\\star) = 0\n$$\n这与无约束最小值的条件相同。因此，如果无约束解 $u_{\\mathrm{uncon}}$ 满足原始可行性条件，即 $c^\\top u_{\\mathrm{uncon}} \\le d$，那么它就是约束问题的最优解：\n$$\nu^\\star = u_{\\mathrm{uncon}} \\quad \\text{如果 } c^\\top u_{\\mathrm{uncon}} \\le d\n$$\n该解在 $\\lambda^\\star=0$ 的情况下满足所有 KKT 条件。\n\n**情况 II：约束被激活 ($c^\\top u^\\star - d = 0$)。**\n当无约束解不可行时，即 $c^\\top u_{\\mathrm{uncon}}  d$，就会发生这种情况。因此，最优解必须位于可行域的边界上，$c^\\top u^\\star = d$。在这种情况下，乘子 $\\lambda^\\star$ 可以是正的。\n\n我们使用驻定性条件来用 $\\lambda^\\star$ 表示 $u^\\star$：\n$$\n\\nabla_u J(u^\\star) + \\lambda^\\star c = 0 \\implies 2 A u^\\star - 2 b + \\lambda^\\star c = 0\n$$\n$$\nA u^\\star = b - \\frac{\\lambda^\\star}{2} c \\implies u^\\star = A^{-1}b - \\frac{\\lambda^\\star}{2} A^{-1}c\n$$\n认识到 $u_{\\mathrm{uncon}} = A^{-1}b$，我们有：\n$$\nu^\\star = u_{\\mathrm{uncon}} - \\frac{\\lambda^\\star}{2} A^{-1}c\n$$\n让我们定义一个新的乘子 $\\mu = \\lambda^\\star / 2 \\ge 0$。于是，$u^\\star = u_{\\mathrm{uncon}} - \\mu A^{-1}c$。\n为了找到 $\\mu$，我们将这个 $u^\\star$ 的表达式代入激活的约束方程 $c^\\top u^\\star = d$ 中：\n$$\nc^\\top (u_{\\mathrm{uncon}} - \\mu A^{-1}c) = d\n$$\n$$\nc^\\top u_{\\mathrm{uncon}} - \\mu (c^\\top A^{-1} c) = d\n$$\n解出 $\\mu$：\n$$\n\\mu = \\frac{c^\\top u_{\\mathrm{uncon}} - d}{c^\\top A^{-1} c}\n$$\n由于我们处于 $c^\\top u_{\\mathrm{uncon}}  d$ 的情况，分子是正的。由于 $A$ 是正定的， $A^{-1}$ 也是正定的，因此分母 $c^\\top A^{-1} c$ 也是正的（对于 $c \\neq 0$）。这确保了 $\\mu  0$（以及 $\\lambda^\\star  0$），满足对偶可行性条件。\n\n然后通过将这个 $\\mu$ 代回 $u^\\star$ 的表达式中来找到最优解：\n$$\nu^\\star = u_{\\mathrm{uncon}} - \\left( \\frac{c^\\top u_{\\mathrm{uncon}} - d}{c^\\top A^{-1} c} \\right) A^{-1}c \\quad \\text{如果 } c^\\top u_{\\mathrm{uncon}}  d\n$$\n\n**算法总结**\n计算过程如下：\n1.  给定问题参数，构建矩阵 $A = w_s S^\\top S + \\beta I$ 和向量 $b = w_s S^\\top s_{\\mathrm{ref}} + \\beta(1-\\tau) u_{\\mathrm{auto}} + \\beta\\tau u_{\\mathrm{human}}$。\n2.  计算无约束解 $u_{\\mathrm{uncon}} = A^{-1}b$。\n3.  通过计算 $c^\\top u_{\\mathrm{uncon}}$ 来检查 $u_{\\mathrm{uncon}}$ 是否可行。\n4.  如果 $c^\\top u_{\\mathrm{uncon}} \\le d$，解就是 $u^\\star = u_{\\mathrm{uncon}}$。\n5.  如果 $c^\\top u_{\\mathrm{uncon}}  d$，通过将 $u_{\\mathrm{uncon}}$ 投影到约束超平面上来找到解：\n    $u^\\star = u_{\\mathrm{uncon}} - \\mu (A^{-1}c)$，其中 $\\mu = \\frac{c^\\top u_{\\mathrm{uncon}} - d}{c^\\top A^{-1} c}$。\n\n此过程为所有指定案例提供了唯一的、最优的控制输入 $u^\\star$。",
            "answer": "```python\nimport numpy as np\n\ndef solve_case(S, s_ref, u_auto, u_human, beta, w_s, c, d, tau):\n    \"\"\"\n    Solves the constrained quadratic optimization problem for a single test case\n    based on the KKT-derived algorithm.\n    \"\"\"\n    # 1. Assemble matrices A and b based on the problem derivation.\n    # Note: w_p + w_h = beta.\n    A = w_s * (S.T @ S) + beta * np.identity(2)\n    b = w_s * (S.T @ s_ref) + beta * (1 - tau) * u_auto + beta * tau * u_human\n\n    # 2. Compute the unconstrained minimizer u_uncon = A^-1 * b.\n    try:\n        A_inv = np.linalg.inv(A)\n    except np.linalg.LinAlgError:\n        # A should always be invertible as it is positive definite.\n        # This is a fallback, not expected to be triggered.\n        raise ValueError(\"Matrix A is singular.\")\n        \n    u_uncon = A_inv @ b\n\n    # Special handling for Case 4: d is defined based on the unconstrained solution.\n    if d is None:\n        d = c.T @ u_uncon\n\n    # 3. Check if the unconstrained solution is feasible.\n    if c.T @ u_uncon = d:\n        # Case I: Constraint is inactive or active with lambda=0.\n        # The unconstrained solution is the optimal solution.\n        u_star = u_uncon\n    else:\n        # Case II: Constraint is violated by the unconstrained solution.\n        # The optimal solution lies on the constraint boundary.\n        # We project u_uncon onto the hyperplane c^T u = d in the A-metric.\n        \n        # Calculate the multiplier mu = (c^T u_uncon - d) / (c^T A^-1 c)\n        cT_A_inv_c = c.T @ A_inv @ c\n        mu = (c.T @ u_uncon - d) / cT_A_inv_c\n        \n        # Calculate the constrained solution u* = u_uncon - mu * (A^-1 c)\n        u_star = u_uncon - mu * (A_inv @ c)\n\n    return u_star\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each,\n    and print the results in the specified format.\n    \"\"\"\n    # Common parameters for all test cases\n    S = np.array([[1.0, 0.2], [0.1, 1.5]])\n    s_ref = np.array([0.0, 1.0])\n    u_auto = np.array([0.5, -0.3])\n    u_human = np.array([0.0, 0.8])\n    beta = 2.0\n    w_s = 1.0\n    c = np.array([1.0, 1.0])\n\n    # Test cases defined by (d, tau)\n    test_cases = [\n        # Case 1: General \"happy path\"\n        {'d': 1.0,  'tau': 0.5},\n        # Case 2: Active safety constraint\n        {'d': 0.5,  'tau': 0.5},\n        # Case 3: Trust boundary at tau = 0\n        {'d': 0.55, 'tau': 0.0},\n        # Case 4: Trust boundary at tau = 1, with d determined by u_uncon\n        {'d': None, 'tau': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        u_star = solve_case(\n            S, s_ref, u_auto, u_human, beta, w_s, c, case['d'], case['tau']\n        )\n        results.append(u_star)\n\n    # Format the output string as per requirements:\n    # [[u1_1,u1_2],[u2_1,u2_2],...] with 6 decimal places and no spaces.\n    formatted_results = [f\"[{r[0]:.6f},{r[1]:.6f}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对人类行为的建模永远无法做到完美。这项高级练习将处理一个关键的现实挑战：当系统所依赖的人类模型存在偏差时，如何确保系统仍然安全？你将设计一个以安全为核心的机器人干预策略，通过考虑人类行为在最坏情况下的偏离，为系统提供鲁棒的概率性安全保证。",
            "id": "4226706",
            "problem": "一个用于信息物理系统（CPS）数字孪生（DT）的共享自主控制器必须能够适应其动作模型被错误指定的人类操作员。考虑一个为离散时间线性高斯对象设计的单步安全保障措施，该措施融合了人类意图和机器人干预。该对象根据以下基本的离散时间线性动力学演化：\n$$\nx_{t+1} = a\\,x_t + b\\,u_t + w_t,\n$$\n其中，$x_t$ 是状态（单位为米），$u_t$ 是控制输入（单位为米），$a$ 和 $b$ 是已知标量，$w_t$ 是一个均值为零、方差为 $\\sigma_w^2$（单位为平方米）的扰动。共享自主融合方式为：\n$$\nu_t = \\alpha\\,h_t + (1-\\alpha)\\,r_t,\n$$\n其中，$h_t$ 是人类输入，$r_t$ 是由安全保障措施选择的机器人干预。融合参数 $\\alpha \\in [0,1]$ 是已知的。人类模型被错误指定：名义估计将 $h_t$ 视为均值为 $\\mu_h$、方差为 $\\sigma_h^2$ 的高斯变量，但真实均值存在一个满足 $|\\delta| \\le \\Delta$ 的未知偏移 $\\delta$。因此，人类输入 $h_t$ 被建模为：\n$$\nh_t \\sim \\mathcal{N}(\\mu_h + \\delta,\\ \\sigma_h^2),\\quad |\\delta| \\le \\Delta.\n$$\n安全性要求是下一状态保持在对称安全集内：\n$$\n|x_{t+1}| \\le X_{\\max},\n$$\n在最坏情况的错误指定下，此要求需以高概率满足。您的安全保障措施必须选择一个机器人干预 $r_t$，其受饱和约束：\n$$\n|r_t| \\le U_{\\max},\n$$\n以在维持安全机会约束的同时，最小化最坏情况下的风险。为确保科学真实性，请使用以下原则作为基础：对象和融合的线性特性，独立高斯变量之和的方差的独立性和可加性，用于双尾事件的联合界，以及高斯累积分布函数的性质。除这些原则外，不要假设任何快捷公式。\n\n任务：\n1. 从给定的动力学和融合方式出发，并将 $r_t$ 视为确定性的，推导 $x_{t+1}$ 的分布，用 $a$、$b$、$\\alpha$、$x_t$、$r_t$、$\\mu_h$、$\\Delta$、$\\sigma_h^2$ 和 $\\sigma_w^2$ 表示。通过在 $|\\delta| \\le \\Delta$ 上构建最坏情况界限，仔细考虑未知的均值偏移 $\\delta$。\n2. 仅使用联合界和高斯分布的性质，推导一个形式为 $P(|x_{t+1}| \\le X_{\\max}) \\ge 1 - \\varepsilon$ 的充分单步机会约束，该约束可以针对给定的 $r_t$ 进行检查。该约束必须对所有 $|\\delta| \\le \\Delta$ 具有鲁棒性，并且不得依赖于所述原则之外的任何快捷公式。\n3. 在 $|\\delta| \\le \\Delta$ 的条件下，推导使 $x_{t+1}$ 的最坏情况绝对均值最小化的 $r_t$ 选择，并受饱和约束 $|r_t| \\le U_{\\max}$ 的限制。解释您的推导如何遵循区间中心化和线性性的第一性原理。\n4. 使用推导出的充分条件，为所选的 $r_t$ 定义违规概率的最小可实现上界 $\\varepsilon_{\\text{bound}}$，该上界对 $|\\delta| \\le \\Delta$ 具有鲁棒性。如果总方差为零，请定义在该退化的确定性情况下 $\\varepsilon_{\\text{bound}}$ 的极限。\n\n数值单位和输出：\n- 状态 $x_t$ 的单位为米，控制 $u_t$ 和干预 $r_t$ 的单位为米，方差的单位为平方米，$X_{\\max}$ 的单位为米。\n- 不使用角度。\n- 将最终的干预 $r_t$ 以米为单位表示，并将 $\\varepsilon_{\\text{bound}}$ 表示为小数。\n\n测试套件：\n实现一个程序，对于以下每个测试用例，计算使最坏情况绝对均值最小化的饱和 $r_t$，然后计算违规概率的鲁棒充分上界 $\\varepsilon_{\\text{bound}}$，并评估目标机会约束 $P(|x_{t+1}| \\le X_{\\max}) \\ge 1 - \\varepsilon_{\\text{target}}$ 的布尔可行性：\n- 用例1（顺利情况）：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (0.9, 1.0, 0.7, 2.0, 1.0, 0.3, 0.5, 0.1, 3.0, 2.0, 0.05)$。\n- 用例2（边界压力）：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (1.2, 1.0, 0.9, 2.5, 1.5, 0.8, 0.7, 0.2, 3.0, 0.5, 0.02)$。\n- 用例3（无法干预）：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (0.95, 1.0, 1.0, 0.0, 0.0, 0.5, 0.3, 0.1, 0.4, 1.0, 0.1)$。\n- 用例4（大驱动空间，稳定中心化）：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (0.5, 2.0, 0.6, -1.0, -0.5, 0.1, 0.2, 0.05, 1.0, 10.0, 0.01)$。\n- 用例5（确定性边缘情况）：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (1.0, 1.0, 0.5, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.001)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素都必须是 $[r_t,\\ \\text{feasible},\\ \\varepsilon_{\\text{bound}}]$ 形式的列表，其中 $r_t$ 的单位是米，$\\text{feasible}$ 是一个布尔值，$\\varepsilon_{\\text{bound}}$ 是一个四舍五入到六位小数的小数。例如，\n$$\n[[r_1,\\ \\text{feasible}_1,\\ \\varepsilon_{\\text{bound},1}],\\ [r_2,\\ \\text{feasible}_2,\\ \\varepsilon_{\\text{bound},2}],\\ \\ldots]\n$$\n在单行上。",
            "solution": "### 基于原理的推导\n\n#### 任务1：下一状态 $x_{t+1}$ 的分布\n\n状态 $x_{t+1}$ 的演化通过将共享自主控制律代入对象动力学来确定：\n$$\nx_{t+1} = a\\,x_t + b \\left( \\alpha\\,h_t + (1-\\alpha)\\,r_t \\right) + w_t\n$$\n我们可以通过将确定性项和随机项分组来重新排列此表达式。在时间 $t$，状态 $x_t$ 和选择的干预 $r_t$ 是已知的（确定性的）。人类输入 $h_t$ 和过程噪声 $w_t$ 是独立的随机变量。\n$$\nx_{t+1} = \\underbrace{(a\\,x_t + b(1-\\alpha)r_t)}_{\\text{确定性部分}} + \\underbrace{b\\alpha\\,h_t + w_t}_{\\text{随机部分}}\n$$\n由于 $x_{t+1}$ 是独立高斯随机变量（$h_t$ 和 $w_t$）和确定性项的线性组合，$x_{t+1}$ 本身服从高斯分布，$x_{t+1} \\sim \\mathcal{N}(\\mu_{x_{t+1}}, \\sigma_{x_{t+1}}^2)$。\n\n$x_{t+1}$ 的均值，记为 $\\mu_{x_{t+1}}(\\delta)$，取决于未知的偏移 $\\delta$：\n$$\n\\mu_{x_{t+1}}(\\delta) = E[a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\,h_t + w_t]\n$$\n使用期望的线性性质以及给定的均值 $E[h_t] = \\mu_h + \\delta$ 和 $E[w_t] = 0$：\n$$\n\\mu_{x_{t+1}}(\\delta) = a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\,E[h_t] + E[w_t] = a\\,x_t + b(1-\\alpha)r_t + b\\alpha(\\mu_h + \\delta)\n$$\n我们将名义均值 $\\mu_{\\text{nom}}$ 定义为均值中独立于不确定性 $\\delta$ 的部分：\n$$\n\\mu_{\\text{nom}}(r_t) = a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h\n$$\n因此，均值为 $\\mu_{x_{t+1}}(\\delta) = \\mu_{\\text{nom}}(r_t) + b\\alpha\\delta$。由于 $|\\delta| \\le \\Delta$，均值位于区间 $[\\mu_{\\text{nom}}(r_t) - |b\\alpha|\\Delta, \\mu_{\\text{nom}}(r_t) + |b\\alpha|\\Delta]$ 内。\n\n$x_{t+1}$ 的方差 $\\sigma_{x_{t+1}}^2$ 与 $\\delta$ 无关。由于 $h_t$ 和 $w_t$ 是独立的：\n$$\n\\sigma_{x_{t+1}}^2 = \\text{Var}(a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\,h_t + w_t) = \\text{Var}(b\\alpha\\,h_t) + \\text{Var}(w_t)\n$$\n使用方差性质 $\\text{Var}(cZ) = c^2\\text{Var}(Z)$ 以及给定的方差 $\\text{Var}(h_t) = \\sigma_h^2$ 和 $\\text{Var}(w_t) = \\sigma_w^2$：\n$$\n\\sigma_{x_{t+1}}^2 = (b\\alpha)^2\\sigma_h^2 + \\sigma_w^2\n$$\n对于给定的系统参数集，此总方差是恒定的。\n\n#### 任务2：充分机会约束的推导\n\n安全性要求是在所有 $|\\delta| \\le \\Delta$ 条件下，$P(|x_{t+1}| \\le X_{\\max}) \\ge 1 - \\varepsilon$。这等同于确保在最坏情况的 $\\delta$ 下，违规概率 $P(|x_{t+1}|  X_{\\max}) \\le \\varepsilon$。\n\n我们寻求一个充分条件。将下一状态表示为 $x_{t+1} = \\mu_{x_{t+1}}(\\delta) + \\epsilon_t$，其中 $\\epsilon_t \\sim \\mathcal{N}(0, \\sigma_{x_{t+1}}^2)$ 是一个代表总系统噪声的零均值高斯变量。条件 $|x_{t+1}| \\le X_{\\max}$ 变为 $|\\mu_{x_{t+1}}(\\delta) + \\epsilon_t| \\le X_{\\max}$。\n\n根据三角不等式，有 $|\\mu_{x_{t+1}}(\\delta) + \\epsilon_t| \\le |\\mu_{x_{t+1}}(\\delta)| + |\\epsilon_t|$。因此，一个充分的安全条件是 $|\\mu_{x_{t+1}}(\\delta)| + |\\epsilon_t| \\le X_{\\max}$。为了使该条件对所有 $|\\delta| \\le \\Delta$ 具有鲁棒性，我们必须考虑 $|\\mu_{x_{t+1}}(\\delta)|$ 的最坏情况（最大）值。\n$$\n\\max_{|\\delta| \\le \\Delta} |\\mu_{x_{t+1}}(\\delta)| = \\max_{|\\delta| \\le \\Delta} |\\mu_{\\text{nom}}(r_t) + b\\alpha\\delta| = |\\mu_{\\text{nom}}(r_t)| + |b\\alpha|\\Delta\n$$\n让我们将这个最坏情况绝对均值命名为 $\\mu_{\\text{wc,abs}}(r_t)$。充分条件变为 $|\\epsilon_t| \\le X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)$。\n\n此条件成立的概率是 $P(|\\epsilon_t| \\le X_{\\max} - \\mu_{\\text{wc,abs}}(r_t))$。设 $Y(r_t) = X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)$。如果 $Y(r_t)  0$，概率为 $0$，因为 $|\\epsilon_t|$ 不能为负。如果 $Y(r_t) \\ge 0$，我们分析违规概率，该概率必须小于或等于 $\\varepsilon$：\n$$\nP(|\\epsilon_t|  Y(r_t)) \\le \\varepsilon\n$$\n使用联合界，$P(|\\epsilon_t|  Y(r_t)) = P(\\epsilon_t  Y(r_t)) + P(\\epsilon_t  -Y(r_t))$。由于 $\\epsilon_t$ 是一个零均值高斯变量，这两个尾部概率是相等的。\n$$\nP(|\\epsilon_t|  Y(r_t)) = 2 P(\\epsilon_t  Y(r_t)) = 2 P\\left(\\frac{\\epsilon_t}{\\sigma_{x_{t+1}}}  \\frac{Y(r_t)}{\\sigma_{x_{t+1}}}\\right)\n$$\n设 $Z = \\epsilon_t / \\sigma_{x_{t+1}}$ 为标准正态变量，$Z \\sim \\mathcal{N}(0,1)$。违规概率为 $2 P(Z  Y(r_t)/\\sigma_{x_{t+1}})$。设 $\\Phi(\\cdot)$ 为标准正态分布的累积分布函数（CDF）。则 $P(Zz) = 1 - \\Phi(z)$。充分机会约束为：\n$$\n2 \\left( 1 - \\Phi\\left( \\frac{X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{x_{t+1}}} \\right) \\right) \\le \\varepsilon\n$$\n只要 $X_{\\max} \\ge \\mu_{\\text{wc,abs}}(r_t)$，就可以对任何给定的 $r_t$ 检查此约束。如果 $X_{\\max}  \\mu_{\\text{wc,abs}}(r_t)$，则违规概率界限取为 $1$。\n\n#### 任务3：最优机器人干预 $r_t$\n\n目标是选择 $r_t$ 以最小化 $x_{t+1}$ 的最坏情况绝对均值，并受限于 $|r_t| \\le U_{\\max}$。要最小化的表达式是：\n$$\n\\mu_{\\text{wc,abs}}(r_t) = |\\mu_{\\text{nom}}(r_t)| + |b\\alpha|\\Delta = |a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h| + |b\\alpha|\\Delta\n$$\n针对 $r_t$ 最小化此表达式等同于最小化 $|\\mu_{\\text{nom}}(r_t)|$，因为项 $|b\\alpha|\\Delta$ 相对于 $r_t$ 是常数。当 $|\\mu_{\\text{nom}}(r_t)|$ 的参数为零时，该表达式被最小化，这就是将名义分布中心置于原点的原理。\n$$\n\\mu_{\\text{nom}}(r_t) = a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h = 0\n$$\n求解无约束的最优干预 $r_t^*$：\n$$\nb(1-\\alpha)r_t^* = -(a\\,x_t + b\\alpha\\mu_h) \\implies r_t^* = -\\frac{a\\,x_t + b\\alpha\\mu_h}{b(1-\\alpha)}\n$$\n如果 $b(1-\\alpha) \\neq 0$，则此解有效。如果 $b(1-\\alpha) = 0$（即 $b=0$ 或 $\\alpha=1$），机器人无权改变均值，其对 $r_t$ 的选择与目标无关。在这种情况下，常规选择是 $r_t=0$。\n\n为满足饱和约束 $|r_t| \\le U_{\\max}$，我们将无约束解 $r_t^*$ 投影到区间 $[-U_{\\max}, U_{\\max}]$ 上。这是一个裁剪操作：\n$$\nr_{t, \\text{opt}} = \\text{clip}(r_t^*, -U_{\\max}, U_{\\max}) = \\max(-U_{\\max}, \\min(U_{\\max}, r_t^*))\n$$\n\n#### 任务4：最小可实现违规概率上界 $\\varepsilon_{\\text{bound}}$\n\n违规概率的最小可实现上界 $\\varepsilon_{\\text{bound}}$ 是通过计算任务3中选择的最优干预 $r_{t, \\text{opt}}$，并将其代入任务2中推导的充分违规概率公式得到的。\n\n1.  计算最优饱和干预 $r_t = r_{t, \\text{opt}}$。\n2.  计算相应的最坏情况绝对均值 $\\mu_{\\text{wc,abs}}(r_t) = |a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h| + |b\\alpha|\\Delta$。\n3.  计算总标准差 $\\sigma_{\\text{tot}} = \\sqrt{(b\\alpha\\sigma_h)^2 + \\sigma_w^2}$。\n4.  基于两种情况计算界限 $\\varepsilon_{\\text{bound}}$：\n    *   **随机情况 ($\\sigma_{\\text{tot}}  0$):**\n        如果 $X_{\\max}  \\mu_{\\text{wc,abs}}(r_t)$，在此保守界限下违规是确定的，因此 $\\varepsilon_{\\text{bound}} = 1.0$。\n        否则，$\\varepsilon_{\\text{bound}} = 2 \\left( 1 - \\Phi\\left( \\frac{X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{\\text{tot}}} \\right) \\right)$。\n    *   **确定性情况 ($\\sigma_{\\text{tot}} = 0$):**\n        系统是确定性的。当且仅当最坏情况状态 $|x_{t+1}|$ 超过 $X_{\\max}$ 时，发生违规。\n        如果 $|x_{t+1}|_{\\text{wc}} = \\mu_{\\text{wc,abs}}(r_t)  X_{\\max}$，违规是确定的，因此 $\\varepsilon_{\\text{bound}} = 1.0$。\n        否则，违规是不可能的，因此 $\\varepsilon_{\\text{bound}} = 0.0$。\n\n该公式提供了一种计算最优干预及其相关鲁棒安全保证的完整方法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\n# np.__version__ should be 1.23.5\n# scipy.__version__ should be 1.11.4\n\ndef solve():\n    \"\"\"\n    Solves the shared autonomy safeguard problem for a set of test cases.\n    \"\"\"\n    # Test cases from the problem statement:\n    # (a, b, alpha, xt, mu_h, Delta, sigma_h, sigma_w, X_max, U_max, eps_target)\n    test_cases = [\n        (0.9, 1.0, 0.7, 2.0, 1.0, 0.3, 0.5, 0.1, 3.0, 2.0, 0.05),\n        (1.2, 1.0, 0.9, 2.5, 1.5, 0.8, 0.7, 0.2, 3.0, 0.5, 0.02),\n        (0.95, 1.0, 1.0, 0.0, 0.0, 0.5, 0.3, 0.1, 0.4, 1.0, 0.1),\n        (0.5, 2.0, 0.6, -1.0, -0.5, 0.1, 0.2, 0.05, 1.0, 10.0, 0.01),\n        (1.0, 1.0, 0.5, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.001),\n    ]\n\n    results = []\n    \n    # A small tolerance for floating point comparisons\n    TOLERANCE = 1e-9\n\n    for case in test_cases:\n        a, b, alpha, x_t, mu_h, Delta, sigma_h, sigma_w, X_max, U_max, eps_target = case\n\n        # Task 3: Derive the choice of r_t\n        r_t_opt = 0.0\n        # The term b*(1-alpha) determines the robot's control authority over the mean\n        control_authority = b * (1 - alpha)\n        \n        if abs(control_authority)  TOLERANCE:\n            # Unconstrained optimal r_t to center the nominal mean at zero\n            r_t_unc = -(a * x_t + b * alpha * mu_h) / control_authority\n            # Apply saturation constraint |r_t| = U_max\n            r_t_opt = np.clip(r_t_unc, -U_max, U_max)\n        else:\n            # If control authority is zero (alpha=1 or b=0), the robot cannot influence\n            # the mean. By convention, the override is set to zero.\n            r_t_opt = 0.0\n\n        # Task 4: Define the minimal achievable upper bound on the violation probability\n        \n        # 1. Calculate nominal mean with the chosen r_t\n        mu_nom = a * x_t + b * (1 - alpha) * r_t_opt + b * alpha * mu_h\n        \n        # 2. Calculate worst-case absolute mean, robust to delta\n        mu_wc_abs = abs(mu_nom) + abs(b * alpha) * Delta\n        \n        # 3. Calculate total variance and standard deviation\n        sigma_sq_h = (b * alpha * sigma_h)**2\n        sigma_sq_w = sigma_w**2\n        sigma_tot_sq = sigma_sq_h + sigma_sq_w\n        sigma_tot = np.sqrt(sigma_tot_sq)\n\n        eps_bound = 0.0\n\n        # 4. Calculate the violation probability bound\n        if sigma_tot  TOLERANCE:\n            # Deterministic case\n            if mu_wc_abs  X_max:\n                eps_bound = 1.0\n            else:\n                eps_bound = 0.0\n        else:\n            # Stochastic case\n            safety_margin = X_max - mu_wc_abs\n            if safety_margin  0:\n                # The worst-case mean is already outside the safe set,\n                # making the sufficient condition impossible to meet.\n                eps_bound = 1.0\n            else:\n                # Use survival function (1 - CDF) for numerical stability\n                # P(|err|  Y) = 2 * P(err  Y) = 2 * sf(Y / sigma)\n                z = safety_margin / sigma_tot\n                eps_bound = 2.0 * norm.sf(z)\n\n        # Evaluate feasibility of the target chance constraint\n        feasible = eps_bound = eps_target\n\n        results.append([r_t_opt, feasible, round(eps_bound, 6)])\n\n    # Format the final output as a string representing a list of lists.\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}