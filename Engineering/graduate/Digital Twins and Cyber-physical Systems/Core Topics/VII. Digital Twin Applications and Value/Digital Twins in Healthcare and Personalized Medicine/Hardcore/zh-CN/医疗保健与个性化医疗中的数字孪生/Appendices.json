{
    "hands_on_practices": [
        {
            "introduction": "医疗数字孪生的一项核心功能是将通用生理学模型适配于特定患者。本练习将引导你使用经典的药代动力学（PK）模型和来自真实世界的治疗药物监测（TDM）数据。通过最小化模型预测与实际测量值之间的差异，我们可以估算出关键的患者特异性参数，例如药物消除速率常数 $k_e$ 和分布容积 $V$ 。这个实践展示了模型个性化的基本过程，这是将通用模型转变为真正可用于个性化医疗的数字副本的第一步。",
            "id": "4217319",
            "problem": "我们利用通过治疗药物监测（TDM）测量值校准的单室药代动力学（PK）模型，构建用于个体化万古霉素治疗的数字孪生。从质量平衡和一级消除出发，考虑体内的药物量 $A(t)$ 与浓度 $C(t)$ 之间的关系为 $C(t) = A(t)/V$，其中 $V$ 是表观分布容积，单位为升。静脉输注在输注期间被建模为速率为 $R(t)$（单位为 $\\mathrm{mg}/\\mathrm{h}$）的零级输入，在其他时间则没有输入。消除过程为一级消除，消除速率常数为 $k_e$，单位为 $\\mathrm{h}^{-1}$。质量平衡得到常微分方程 $dA/dt = -k_e A + R(t)$，因此有 $dC/dt = -k_e C + R(t)/V$。假设在时间 $t_i$ 的 TDM 观测值 $y_i$ 满足 $y_i = C(t_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是方差未知的独立高斯噪声。\n\n您的任务是实现一个程序，为每个提供的测试用例执行以下操作：\n\n- 在高斯噪声假设下，通过最大似然估计个体化参数 $k_e$ 和 $V$。这等同于最小化预测浓度 $C(t_i)$ 与观测值 $y_i$ 之间的残差平方和。\n- 使用估计出的参数，计算在 $[0,T]$ 时间窗口内（$T$ 以小时为单位），根据给药方案得出的个体化浓度轨迹 $C(t)$。\n- 计算以下输出：\n  1. 估计的消除速率 $k_e$，单位为 $\\mathrm{h}^{-1}$，四舍五入至 $3$ 位小数。\n  2. 估计的容积 $V$，单位为 $\\mathrm{L}$，四舍五入至 $3$ 位小数。\n  3. 在 $[0,T]$ 区间内的最大浓度，单位为 $\\mathrm{mg}/\\mathrm{L}$，四舍五入至 $3$ 位小数。\n  4. 在 $t = T$ 时的浓度，单位为 $\\mathrm{mg}/\\mathrm{L}$，四舍五入至 $3$ 位小数。\n  5. 在 $[0,T]$ 区间内的浓度-时间曲线下面积，单位为 $\\mathrm{mg}\\cdot\\mathrm{h}/\\mathrm{L}$，四舍五入至 $3$ 位小数。\n\n仅使用科学上合理的假设。输注方案是分段恒定的，每次给药的已知剂量为 $D$（单位 $\\mathrm{mg}$），输注持续时间为 $\\tau$（单位 $\\mathrm{h}$）。对于每个测试用例，假设初始药物量 $A(0) = 0$。\n\n将校准过程实现为非线性最小二乘法，参数具有物理上合理的边界，并在分段的输注和消除区间内对 $A(t)$ 进行数值稳定的传播。程序必须是独立完整的，并能生成下述确切的最终输出格式。\n\n答案单位与四舍五入：\n- $k_e$ 以 $\\mathrm{h}^{-1}$ 表示，$V$ 以 $\\mathrm{L}$ 表示，浓度以 $\\mathrm{mg}/\\mathrm{L}$ 表示，曲线下面积以 $\\mathrm{mg}\\cdot\\mathrm{h}/\\mathrm{L}$ 表示。\n- 所有输出均四舍五入至 $3$ 位小数。\n- 此问题不涉及角度。\n\n测试套件：\n请为以下用例提供结果。在所有用例中，给药方案数组以 $(t_{\\text{start}}, \\tau, D)$ 的形式列出输注信息，其中时间和持续时间的单位为 $\\mathrm{h}$，剂量的单位为 $\\mathrm{mg}$。\n\n- 用例 $1$（典型成人，q12h）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 1, 1000), (12, 1, 1000)]$，TDM 观测的时间和测量浓度为 $[(1, 21.1), (11.5, 6.0), (13, 26.4), (23.5, 7.1)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n- 用例 $2$（单次剂量，短时输注）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 0.5, 1500)]$，TDM 观测值为 $[(0.5, 27.2), (2, 23.4), (8, 15.8), (24, 3.0)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n- 用例 $3$（q8h，长时输注）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 2, 750), (8, 2, 750), (16, 2, 750)]$，TDM 观测值为 $[(2, 15.9), (10, 21.5), (15.5, 9.4), (18, 22.2)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n- 用例 $4$（q12h，消除较慢，容积较大）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 1, 750), (12, 1, 750)]$，TDM 观测值为 $[(1, 10.6), (13, 15.6), (23.5, 8.1)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n\n算法要求：\n- 在 $R$ 恒定的区间上，使用 $dA/dt = -k_e A + R$ 的解，在输注之外的区间上使用 $R=0$ 的解，来精确地在每个区间传播 $A(t)$。\n- 计算 $C(t) = A(t)/V$。\n- 对于曲线下面积，使用 $A(t)$ 在每个区间上的精确积分，然后除以 $V$。\n- 使用非线性最小二乘法，参数边界为 $k_e \\in [0.02, 1.0]$ 和 $V \\in [10, 100]$，并采用一个合理的初始猜测值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，每个元素是单个用例的结果。每个用例的结果是一个包含 $5$ 个浮点数的列表，按上述顺序排列，全部四舍五入至 $3$ 位小数，并用方括号括起来。例如，输出应类似于 $[[k_{e,1},V_1,\\max C_1,C_1(T),\\mathrm{AUC}_1],[k_{e,2},V_2,\\max C_2,C_2(T),\\mathrm{AUC}_2],\\dots]$。",
            "solution": "该问题要求开发一种计算方法，利用治疗药物监测（TDM）数据对万古霉素治疗的单室药代动力学（PK）模型进行个性化处理。这包括估计患者特定参数，并使用这些参数来预测药物的浓度曲线及相关的临床指标。该问题在科学上是适定（well-posed）的，并为提供完整解决方案提供了所有必要信息。\n\n其基本原理是将质量平衡应用于代表身体的单个充分混合室中的药物量 $A(t)$。该室的表观容积为 $V$。药物量与浓度 $C(t)$ 之间的关系由 $C(t) = A(t)/V$ 给出。$A(t)$ 的动态由以下一阶线性常微分方程（ODE）描述：\n$$\n\\frac{dA}{dt} = -k_e A(t) + R(t)\n$$\n其中 $k_e$ 是一级消除速率常数，单位为 $\\mathrm{h}^{-1}$，$R(t)$ 是药物给药速率，单位为 $\\mathrm{mg}/\\mathrm{h}$。对于静脉输注，$R(t)$ 是一个分段常数函数。在持续时间为 $\\tau$、总剂量为 $D$ 的输注期间，它等于一个恒定速率 $R_{inf} = D/\\tau$，在其他时间 $R(t)=0$。初始条件指定为 $A(0) = 0$。\n\n解决方案的核心在于求解这个 ODE，并用它来预测浓度，然后将这些浓度用于参数估计框架。\n\n**1. 药代动力学模型的解析解**\n\n该 ODE 在输注速率 $R$ 恒定的连续时间区间内求解。对于一个区间 $[t_a, t_b]$，初始药物量为 $A(t_a)$，恒定速率为 $R$，则 $A(t)$ 在 $t \\in [t_a, t_b]$ 上的解析解为：\n$$\nA(t) = \\frac{R}{k_e} + \\left(A(t_a) - \\frac{R}{k_e}\\right) e^{-k_e (t - t_a)}\n$$\n当没有输注时，$R=0$，方程简化为纯指数衰减：\n$$\nA(t) = A(t_a) e^{-k_e (t - t_a)}\n$$\n这些方程使我们能够根据由输注和消除阶段组成的方案，精确地将药物量 $A(t)$ 从一个时间点传播到下一个时间点。\n\n**2. 通过非线性最小二乘法进行参数估计**\n\n个体的 PK 参数 $k_e$ 和 $V$ 是未知的，必须从 TDM 数据中估计。数据由成对的 $(t_i, y_i)$ 组成，其中 $y_i$ 是在时间 $t_i$ 测得的浓度。这些观测值的模型是 $y_i = C(t_i) + \\epsilon_i$，其中 $C(t_i) = A(t_i)/V$ 是真实浓度，$\\epsilon_i$ 是均值为 $0$ 的独立同分布高斯随机测量误差。\n\n在此假设下，最大似然估计等同于最小化模型预测浓度与观测浓度之间的残差平方和（SSR）：\n$$\n\\text{SSR}(k_e, V) = \\sum_{i} \\left( C(t_i; k_e, V) - y_i \\right)^2 = \\sum_{i} \\left( \\frac{A(t_i; k_e)}{V} - y_i \\right)^2\n$$\n这是一个非线性最小二乘问题。我们寻求最小化该目标函数的参数值 $(\\hat{k}_e, \\hat{V})$，并受限于物理上合理的边界 $k_e \\in [0.02, 1.0]\\,\\mathrm{h}^{-1}$ 和 $V \\in [10, 100]\\,\\mathrm{L}$。这种优化是数值进行的，`scipy.optimize.minimize` 函数配合有界约束算法（例如 L-BFGS-B）非常适合此任务。\n\n**3. 派生的药代动力学指标的计算**\n\n一旦确定了个体的最优参数 $(\\hat{k}_e, \\hat{V})$，我们就可以计算所需的治疗指标。\n\n- **最大浓度 ($C_{max}$)**：浓度 $C(t)$ 在输注期间增加（假设初始浓度低于该输注的稳态值），在消除期间减少。因此，在时间窗口 $[0, T]$ 内的峰浓度将出现在某个输注期结束时。操作步骤是模拟完整的浓度曲线，并找出在每个输注结束的特定时间点所达到的最大值。\n\n- **最终时刻的浓度 ($C(T)$)**：通过使用估计的参数 $\\hat{k}_e$ 和 $\\hat{V}$ 将模型向前传播到时间 $T$ 来计算。\n\n- **曲线下面积 (AUC)**：在区间 $[0, T]$ 上的 AUC 是浓度-时间曲线的积分：\n$$\n\\text{AUC}_{[0,T]} = \\int_0^T C(t) dt = \\frac{1}{\\hat{V}} \\int_0^T A(t) dt\n$$\n为了按要求精确计算，我们在每个分段常数区间上对 $A(t)$ 的解析解进行积分。通过对 ODE 本身进行积分，可以推导出一个数值稳定且简洁的公式来计算 $A(t)$ 在区间 $[t_a, t_b]$ 上（速率 $R$ 恒定）的积分：\n$$\n\\int_{t_a}^{t_b} \\frac{dA}{dt} dt = A(t_b) - A(t_a) = \\int_{t_a}^{t_b} (-k_e A(t) + R) dt = -k_e \\int_{t_a}^{t_b} A(t) dt + R(t_b - t_a)\n$$\n整理得到积分的表达式：\n$$\n\\int_{t_a}^{t_b} A(t) dt = \\frac{A(t_a) - A(t_b) + R(t_b - t_a)}{k_e}\n$$\n总积分 $\\int_0^T A(t) dt$ 是通过将这些区间积分在由所有输注开始/结束时间点和最终时间 $T$ 构成的时间轴上求和得到的。最终的 AUC 是这个总积分除以估计的容积 $\\hat{V}$。\n\n**算法实现**\n\n一个稳健的实现将包括三个主要部分：\n1.  一个核心模拟函数，给定参数 $(k_e, V)$、一个给药方案和一组评估时间点，该函数传播 $A(t)$ 并可选择性地计算 $A(t)$ 在时间轴上的积分。此函数将使用每个区间的解析解。\n2.  一个用于优化器的目标函数，它以参数 $(k_e, V)$ 为输入，调用模拟函数获取 TDM 时间点的预测浓度，并返回 SSR。\n3.  一个主循环，对于每个测试用例，调用优化程序找到 $(\\hat{k}_e, \\hat{V})$，然后使用这些最优参数计算并格式化所需的五个输出指标。\n\n整个过程将药代动力学原理转化为一个具体的计算工作流，用于模型个性化和预测，为药物治疗的数字孪生奠定了基础。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the pharmacokinetic modeling problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 1.0, 1000.0), (12.0, 1.0, 1000.0)],\n            \"tdm_data\": [(1.0, 21.1), (11.5, 6.0), (13.0, 26.4), (23.5, 7.1)],\n        },\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 0.5, 1500.0)],\n            \"tdm_data\": [(0.5, 27.2), (2.0, 23.4), (8.0, 15.8), (24.0, 3.0)],\n        },\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 2.0, 750.0), (8.0, 2.0, 750.0), (16.0, 2.0, 750.0)],\n            \"tdm_data\": [(2.0, 15.9), (10.0, 21.5), (15.5, 9.4), (18.0, 22.2)],\n        },\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 1.0, 750.0), (12.0, 1.0, 750.0)],\n            \"tdm_data\": [(1.0, 10.6), (13.0, 15.6), (23.5, 8.1)],\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        tdm_times = np.array([d[0] for d in case[\"tdm_data\"]])\n        tdm_obs = np.array([d[1] for d in case[\"tdm_data\"]])\n\n        def _propagate(ke, schedule, eval_times):\n            \"\"\"\n            Propagates the amount of drug A(t) over time.\n            \"\"\"\n            # Create a timeline of events (infusion starts/ends, evaluation points)\n            event_times = {0.0}\n            rate_changes = {}\n\n            for start, duration, dose in schedule:\n                if duration > 0:\n                    rate = dose / duration\n                    end = start + duration\n                    event_times.add(start)\n                    event_times.add(end)\n                    rate_changes[start] = rate_changes.get(start, 0) + rate\n                    rate_changes[end] = rate_changes.get(end, 0) - rate\n\n            if eval_times is not None:\n                for t in eval_times:\n                    event_times.add(t)\n\n            sorted_times = sorted(list(event_times))\n            \n            # Since eval_times might contain duplicates after adding to a set\n            eval_times_set = set(eval_times) if eval_times is not None else set()\n            \n            A = 0.0\n            current_rate = 0.0\n            last_t = 0.0\n            \n            amount_at_eval_times = {}\n\n            for t in sorted_times:\n                if t > last_t:\n                    dt = t - last_t\n                    A_start_interval = A\n                    if current_rate > 1e-9: # Infusion phase\n                        A = (current_rate / ke) + (A_start_interval - current_rate / ke) * np.exp(-ke * dt)\n                    else: # Elimination phase\n                        A = A_start_interval * np.exp(-ke * dt)\n\n                if t in rate_changes:\n                    current_rate += rate_changes[t]\n\n                if t in eval_times_set:\n                    amount_at_eval_times[t] = A\n                \n                last_t = t\n                \n            # Return amounts in the same order as eval_times\n            ordered_amounts = [amount_at_eval_times[t] for t in eval_times]\n            return ordered_amounts\n\n        def objective_function(params):\n            ke, V = params\n            predicted_amounts = _propagate(ke, case[\"schedule\"], tdm_times)\n            predicted_concentrations = np.array(predicted_amounts) / V\n            ssr = np.sum((predicted_concentrations - tdm_obs) ** 2)\n            return ssr\n        \n        # Parameter estimation\n        initial_guess = [0.1, 40.0]\n        bounds = [(0.02, 1.0), (10.0, 100.0)]\n        result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds)\n        ke_opt, V_opt = result.x\n\n        # Calculate final outputs with optimized parameters\n        T = case[\"T\"]\n        \n        # Create a timeline for final calculations (AUC, Cmax, C(T))\n        event_times = {0.0, T}\n        rate_changes = {}\n        infusion_end_times = []\n\n        for start, duration, dose in case[\"schedule\"]:\n            if duration > 0:\n                rate = dose / duration\n                end = start + duration\n                event_times.add(start)\n                event_times.add(end)\n                infusion_end_times.append(end)\n                rate_changes[start] = rate_changes.get(start, 0) + rate\n                rate_changes[end] = rate_changes.get(end, 0) - rate\n\n        sorted_times = sorted(list(event_times))\n        \n        A = 0.0\n        current_rate = 0.0\n        last_t = 0.0\n        auc_A = 0.0\n        amount_at_event_times = {}\n\n        for t in sorted_times:\n            if t > last_t:\n                dt = t - last_t\n                A_start_interval = A\n                if current_rate > 1e-9:\n                    A = (current_rate / ke_opt) + (A_start_interval - current_rate / ke_opt) * np.exp(-ke_opt * dt)\n                else:\n                    A = A_start_interval * np.exp(-ke_opt * dt)\n                \n                # Accumulate integral of A(t)\n                auc_A += (A_start_interval - A + current_rate * dt) / ke_opt\n\n            if t in rate_changes:\n                current_rate += rate_changes[t]\n\n            amount_at_event_times[t] = A\n            last_t = t\n        \n        # 1.  2. Estimated parameters\n        ke_final = round(ke_opt, 3)\n        V_final = round(V_opt, 3)\n        \n        # 3. Maximum Concentration\n        C_at_inf_ends = [amount_at_event_times[t] / V_opt for t in infusion_end_times if t = T]\n        C_max = round(max(C_at_inf_ends) if C_at_inf_ends else 0.0, 3)\n\n        # 4. Concentration at T\n        C_T = round(amount_at_event_times[T] / V_opt, 3)\n\n        # 5. Area Under the Curve\n        AUC = round(auc_A / V_opt, 3)\n\n        all_results.append([ke_final, V_final, C_max, C_T, AUC])\n    \n    # Format the final output string\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]},{r[4]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在校准模型后，我们必须确保估算出的参数是可靠的，因为一个包含不可辨识参数的模型对于临床决策而言是不可信的。本练习将介绍参数“可辨识性”这一关键概念，并运用一种强大的统计工具——轮廓似然法（profile likelihood）——来对其进行评估 。你将通过具体案例探索数据质量、采样方案等因素如何影响我们精确确定模型参数的能力，并学会诊断模型构建过程中的一个关键问题。",
            "id": "4217304",
            "problem": "医疗保健中用于个性化药物治疗的数字孪生是患者药物浓度动态的计算复制品，用于个性化给药决策。它是一个典型的信息物理系统（CPS）示例，其中计算模型通过物理测量数据不断更新。为了使数字孪生在临床上具有可操作性，其动态模型的参数必须能从可用数据中进行实践识别。本问题的目标是使用剖面似然法来操作化单室静脉推注药代动力学模型的实践可识别性，并实现一个程序，根据明确的标准为每个参数和每个测试用例确定其剖面是有界的还是平坦的。\n\n基本基础和设置：考虑一个单室静脉推注模型，药物浓度 $C(t)$ 由下式给出：\n$$\nC(t) \\;=\\; \\frac{D}{V} \\, e^{-k_e \\, t},\n$$\n其中 $t$ 是时间，$D$ 是剂量，$V$ 是分布容积，$k_e$ 是一级消除速率常数。假设在时间 $t_i$ 的测量值 $y_i$ 满足\n$$\ny_i \\;=\\; C(t_i) + \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),\n$$\n其中噪声 $\\varepsilon_i$ 是方差为 $\\sigma^2$ 的独立高斯噪声。在独立高斯误差下，对数似然 $\\ell(\\theta)$ 与残差平方和的负值成正比，\n$$\n-2 \\log L(\\theta) \\;=\\; \\sum_{i=1}^{n} \\frac{(y_i - C(t_i;\\theta))^2}{\\sigma^2} + \\text{constant},\n$$\n其中 $\\theta$ 表示由待估计参数组成的参数向量。参数 $\\theta_j$ 的剖面似然定义为：\n$$\n\\ell_p(\\theta_j) \\;=\\; \\max_{\\theta_{-j}} \\ell(\\theta_j,\\theta_{-j}),\n$$\n这等价于在保持 $\\theta_j$ 固定的同时，对除 $\\theta_j$ 之外的所有参数最小化 $-2\\log L$。\n\n实践可识别性标准：对于单个参数剖面，定义偏差\n$$\nD(\\theta) \\;=\\; \\sum_{i=1}^n \\frac{(y_i - C(t_i;\\theta))^2}{\\sigma^2}.\n$$\n设 $D_{\\min}$ 是对所有参数的最小偏差。对于 $95\\%$ 的置信水平，设 $q_{0.95}$ 是自由度为 $1$ 的卡方分布的 $0.95$ 分位数。$\\theta_j$ 的 $95\\%$ 基于剖面的置信集为：\n$$\n\\mathcal{S}_j \\;=\\; \\left\\{\\theta_j \\,\\middle|\\, D_j(\\theta_j) \\le D_{\\min} + q_{0.95}\\right\\},\n$$\n其中 $D_j(\\theta_j)$ 是在固定 $\\theta_j$ 的情况下，通过对除 $\\theta_j$ 之外的所有参数最小化 $D$ 所得到的剖面偏差。在数值实践中，如果集合 $\\mathcal{S}_j$ 是一个严格包含在为 $\\theta_j$ 探索的网格内的有界区间（即，它不接触网格边界），我们则将该参数分类为具有有界剖面（实践上可识别）。如果 $\\mathcal{S}_j$ 接触到边界或跨越整个网格而未超过阈值 $D_{\\min}+q_{0.95}$，则该剖面是平坦或无界的（实践上不可识别）。\n\n程序要求：实现一个程序，对于下面的每个测试用例，从真实参数生成合成数据，通过对待估计参数进行优化来计算全局最小偏差 $D_{\\min}$，通过固定一系列网格值并优化其余参数来为每个待估计参数构建剖面似然，并根据上述标准确定每个参数的剖面是有界还是平坦。使用以下网格进行剖面分析：\n- 对于 $k_e$：在 $[0.05,1.0]$（单位 $\\text{hr}^{-1}$）上取 $50$ 个等间距点。\n- 对于 $V$：在 $[5.0,50.0]$（单位 $\\text{L}$）上取 $50$ 个等间距点。\n- 对于 $D$：在 $[50.0,500.0]$（单位 $\\text{mg}$）上取 $50$ 个等间距点。\n对自由参数使用有界优化，边界如下：\n- $k_e \\in [0.01,5.0]$ 单位 $\\text{hr}^{-1}$，\n- $V \\in [1.0,200.0]$ 单位 $\\text{L}$，\n- $D \\in [10.0,1000.0]$ 单位 $\\text{mg}$。\n\n数据生成：对于每个测试用例，设置一个固定的随机种子以确保可复现性，并从 $\\mathcal{N}(0,\\sigma^2)$ 中抽取 $\\varepsilon_i$。\n\n单位：时间 $t$ 单位为 $\\text{hr}$，剂量 $D$ 单位为 $\\text{mg}$，容积 $V$ 单位为 $\\text{L}$，浓度 $C$ 和 $y_i$ 单位为 $\\text{mg}/\\text{L}$，消除速率 $k_e$ 单位为 $\\text{hr}^{-1}$。\n\n测试套件和覆盖范围：\n- 用例 1（理想情况）：已知剂量 $D$ 作为固定值 $D = 100$ $\\text{mg}$。待估计参数：$k_e$ 和 $V$。真实值：$k_e = 0.4$ $\\text{hr}^{-1}$，$V = 20$ $\\text{L}$。采样时间：$t = [0.0,0.5,1.0,2.0,4.0,6.0,8.0]$ $\\text{hr}$。噪声标准差：$\\sigma = 0.2$ $\\text{mg}/\\text{L}$。\n- 用例 2（结构不可识别性）：未知剂量 $D$ 包含在待估计参数中：$k_e$、$V$、$D$。真实值：$k_e = 0.4$ $\\text{hr}^{-1}$，$V = 20$ $\\text{L}$，$D = 100$ $\\text{mg}$。采样时间：$t = [0.0,0.5,1.0,2.0,4.0,6.0,8.0]$ $\\text{hr}$。噪声标准差：$\\sigma = 0.2$ $\\text{mg}/\\text{L}$。\n- 用例 3（边界和稀疏性边缘情况）：未知剂量 $D$ 包含在待估计参数中：$k_e$、$V$、$D$。真实值：$k_e = 0.4$ $\\text{hr}^{-1}$，$V = 20$ $\\text{L}$，$D = 100$ $\\text{mg}$。采样时间集中在零附近：$t = [0.0,0.1,0.2,0.3]$ $\\text{hr}$。噪声标准差：$\\sigma = 0.05$ $\\text{mg}/\\text{L}$。\n- 用例 4（高噪声压力测试）：已知剂量 $D$ 作为固定值 $D = 100$ $\\text{mg}$。待估计参数：$k_e$ 和 $V$。真实值：$k_e = 0.4$ $\\text{hr}^{-1}$，$V = 20$ $\\text{L}$。采样时间：$t = [0.0,0.5,1.0,2.0,4.0,6.0,8.0]$ $\\text{hr}$。噪声标准差：$\\sigma = 2.0$ $\\text{mg}/\\text{L}$。\n\n要求输出：对于每个用例，按用例定义中列出的参数顺序，生成一个布尔值列表，依次指示每个估计参数的剖面是有界（true）还是平坦/无界（false）。具体来说：\n- 用例 1：输出 $[b_{k_e}, b_V]$，\n- 用例 2：输出 $[b_{k_e}, b_V, b_D]$，\n- 用例 3：输出 $[b_{k_e}, b_V, b_D]$，\n- 用例 4：输出 $[b_{k_e}, b_V]$。\n程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，每个用例的列表本身也用方括号括起来。例如，输出格式应如下所示：$[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,\\ldots\\,]$。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n最终指令：使用 Python 实现程序，利用数值优化构建似然剖面，并应用上述可识别性标准。确保所有计算均遵循所提供的单位，并且程序在没有外部输入的情况下运行，精确打印指定格式的一行输出。",
            "solution": "该问题要求使用剖面似然法评估单室药代动力学模型中参数的实践可识别性。这包括生成合成数据，执行数值优化以找到全局似然和剖面似然，并应用统计标准将每个参数的剖面分类为“有界”（可识别）或“平坦/无界”（不可识别）。\n\n该药代动力学模型描述了静脉推注后药物浓度 $C(t)$ 随时间 $t$ 的变化。该模型由下式给出：\n$$\nC(t) \\;=\\; \\frac{D}{V} \\, e^{-k_e \\, t}\n$$\n此处，$D$ 是给药剂量，$V$ 是分布容积，$k_e$ 是一级消除速率常数。待估计的参数向量用 $\\theta$ 表示。\n\n数据由在时间 $t_i$ 采集的测量值 $y_i$ 组成，这些值被建模为真实浓度加上独立同分布的高斯噪声：\n$$\ny_i \\;=\\; C(t_i; \\theta) + \\varepsilon_i, \\quad \\text{where} \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)\n$$\n假设噪声方差 $\\sigma^2$ 是已知的。在此假设下，最大化似然函数 $L(\\theta)$ 等价于最小化由方差加权的残差平方和。这就产生了偏差函数 $D(\\theta)$：\n$$\nD(\\theta) \\;=\\; \\sum_{i=1}^{n} \\frac{(y_i - C(t_i;\\theta))^2}{\\sigma^2}\n$$\n关于所有参数 $\\theta$ 最小化 $D(\\theta)$ 会得到最大似然估计 $\\hat{\\theta}$ 和最小偏差 $D_{\\min} = D(\\hat{\\theta})$。\n\n为了评估单个参数（例如 $\\theta_j$）的可识别性，我们采用剖面似然法。对于 $\\theta_j$ 的一个固定值，我们关于所有其他参数 $\\theta_{-j}$ 最小化偏差函数。此过程定义了 $\\theta_j$ 的剖面偏差：\n$$\nD_j(\\theta_j) \\;=\\; \\min_{\\theta_{-j}} D\\left(\\theta = (\\theta_j, \\theta_{-j})\\right)\n$$\n通过在 $\\theta_j$ 的一组网格值上计算 $D_j(\\theta_j)$，我们得到了该参数的剖面。\n\n实践可识别性标准基于似然比检验。在 $95\\%$ 置信水平下，与数据一致的参数 $\\theta_j$ 的值集合由下式给出：\n$$\n\\mathcal{S}_j \\;=\\; \\left\\{\\theta_j \\,\\middle|\\, D_j(\\theta_j) \\le D_{\\min} + q_{0.95}\\right\\}\n$$\n其中 $q_{0.95}$ 是自由度为 1 的卡方分布的 $0.95$ 分位数（约等于 $3.841$）。这对应于偏差变化的阈值。\n\n如果置信集 $\\mathcal{S}_j$ 在指定的数值网格上求值时，形成一个不包含网格端点的区间，则参数 $\\theta_j$ 被认为是**实践上可识别的**（具有“有界”剖面）。这表明数据提供了足够的信息将参数约束在有限范围内。相反，如果置信集 $\\mathcal{S}_j$ 延伸到网格的一个或两个边界，则该参数是**实践上不可识别的**（具有“平坦”或“无界”剖面）。这意味着数据不足以约束该参数，这可能是由于结构模型属性（例如，参数冗余）或实践限制（例如，采样稀疏、噪声高）。\n\n解决此问题的算法对每个测试用例按以下步骤进行：\n1.  **数据合成**：使用真实参数在指定的时间点 $t_i$ 生成合成浓度数据 $y_i$，并添加具有指定标准差 $\\sigma$ 的高斯噪声。固定的随机种子确保可复现性。\n2.  **全局偏差最小化**：根据给定的边界，对所有可估计参数数值最小化偏差函数 $D(\\theta)$。此优化产生全局最小偏差 $D_{\\min}$。\n3.  **剖面偏差计算**：对于每个待估计的参数：\n    a. 遍历该参数的预定义网格值。\n    b. 在每个网格点，固定当前参数，并再次根据其边界，对剩余的自由参数数值最小化偏差。\n    c. 存储得到的最小化偏差。这些值的集合构成了该参数的剖面偏差。\n4.  **可识别性评估**：\n    a. 计算偏差阈值 $T = D_{\\min} + q_{0.95}$。\n    b. 对于每个参数的剖面，找出剖面偏差小于或等于 $T$ 的网格点。\n    c. 如果这组点非空，并且其最小和最大索引严格位于网格边界之内（即，不是第一个或最后一个索引），则该参数被分类为“有界”（True）。否则，它被分类为“平坦/无界”（False）。\n\n此过程应用于四个旨在测试不同可识别性场景的不同用例：\n-   **用例 1**：一个具有低噪声和足够数据的良态问题，其中 $k_e$ 和 $V$ 都有望被识别。\n-   **用例 2**：一个表现出结构不可识别性的用例。模型 $C(t) = (D/V) e^{-k_e t}$ 对 $D$ 和 $V$ 的单个值不敏感，仅对其比率 $D/V$ 敏感。因此，虽然 $k_e$ 应该是可识别的，但 $D$ 和 $V$ 预计是不可识别的。\n-   **用例 3**：一个采样稀疏且集中在早期时间点的用例。这种实践限制，加上 $D$ 和 $V$ 的结构不可识别性，预计会使所有三个参数（$k_e$、$V$、$D$）都不可识别。短时间过程几乎不提供关于指数衰减率 $k_e$ 的信息。\n-   **用例 4**：一个与用例 1 相同但具有高噪声的用例。低信噪比预计会使似然曲面变平，导致 $k_e$ 和 $V$ 都实践上不可识别。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Performs practical identifiability analysis for a one-compartment pharmacokinetic model\n    using the profile likelihood method for four distinct test cases.\n    \"\"\"\n\n    # --- Configuration and Test Cases ---\n\n    # Chi-square quantile for 95% confidence interval with 1 degree of freedom\n    q_095 = chi2.ppf(0.95, df=1)\n\n    # Profiling grids\n    grids = {\n        'ke': np.linspace(0.05, 1.0, 50),\n        'V': np.linspace(5.0, 50.0, 50),\n        'D': np.linspace(50.0, 500.0, 50)\n    }\n\n    # Optimization bounds\n    bounds = {\n        'ke': (0.01, 5.0),\n        'V': (1.0, 200.0),\n        'D': (10.0, 1000.0)\n    }\n    \n    # Test cases defined in a structured list\n    test_cases = [\n        {\n            'name': 'Case 1 (Happy Path)',\n            'params_to_estimate': ['ke', 'V'],\n            'fixed_params': {'D': 100.0},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]),\n            'sigma': 0.2,\n            'seed': 42\n        },\n        {\n            'name': 'Case 2 (Structural Non-identifiability)',\n            'params_to_estimate': ['ke', 'V', 'D'],\n            'fixed_params': {},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]),\n            'sigma': 0.2,\n            'seed': 43\n        },\n        {\n            'name': 'Case 3 (Boundary and Sparsity)',\n            'params_to_estimate': ['ke', 'V', 'D'],\n            'fixed_params': {},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.1, 0.2, 0.3]),\n            'sigma': 0.05,\n            'seed': 44\n        },\n        {\n            'name': 'Case 4 (High Noise)',\n            'params_to_estimate': ['ke', 'V'],\n            'fixed_params': {'D': 100.0},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]),\n            'sigma': 2.0,\n            'seed': 45\n        }\n    ]\n\n    # --- Helper Functions ---\n\n    def model(t, ke, V, D):\n        \"\"\" One-compartment IV bolus model \"\"\"\n        if V == 0: return np.inf\n        C0 = D / V\n        return C0 * np.exp(-ke * t)\n\n    def deviance(params, param_names, t, y, sigma, fixed_params):\n        \"\"\" Calculates the deviance (proportional to -2 * log-likelihood) \"\"\"\n        all_params = dict(zip(param_names, params))\n        all_params.update(fixed_params)\n        \n        ke = all_params['ke']\n        V = all_params['V']\n        D = all_params['D']\n\n        y_model = model(t, ke, V, D)\n        residuals = y - y_model\n        return np.sum(residuals**2) / (sigma**2)\n\n    # --- Main Processing Loop ---\n    \n    final_results = []\n\n    for case in test_cases:\n        # 1. Generate synthetic data\n        np.random.seed(case['seed'])\n        gt = case['ground_truth']\n        y_true = model(case['times'], gt['ke'], gt['V'], gt['D'])\n        y_data = y_true + np.random.normal(0, case['sigma'], size=len(case['times']))\n\n        params_to_estimate = case['params_to_estimate']\n        \n        # 2. Global optimization to find D_min\n        initial_guess = [gt[p] for p in params_to_estimate]\n        opt_bounds = [bounds[p] for p in params_to_estimate]\n        \n        res_global = minimize(\n            deviance,\n            x0=initial_guess,\n            args=(params_to_estimate, case['times'], y_data, case['sigma'], case['fixed_params']),\n            method='L-BFGS-B',\n            bounds=opt_bounds\n        )\n        D_min = res_global.fun\n        threshold = D_min + q_095\n\n        case_results = []\n        # 3. Profile likelihood for each parameter\n        for i, p_fixed_name in enumerate(params_to_estimate):\n            profile_grid = grids[p_fixed_name]\n            profile_deviance = np.zeros_like(profile_grid)\n            \n            p_optim_names = [p for p in params_to_estimate if p != p_fixed_name]\n            \n            for j, p_fixed_value in enumerate(profile_grid):\n                \n                def inner_objective(p_optim_values):\n                    current_fixed_params = {p_fixed_name: p_fixed_value}\n                    current_fixed_params.update(case['fixed_params'])\n                    return deviance(p_optim_values, p_optim_names, case['times'], y_data, case['sigma'], current_fixed_params)\n\n                inner_initial_guess = [gt[p] for p in p_optim_names]\n                inner_bounds = [bounds[p] for p in p_optim_names]\n\n                if not p_optim_names:\n                    profile_deviance[j] = inner_objective([])\n                    continue\n                \n                res_profile = minimize(\n                    inner_objective,\n                    x0=inner_initial_guess,\n                    method='L-BFGS-B',\n                    bounds=inner_bounds\n                )\n                profile_deviance[j] = res_profile.fun\n\n            # 4. Assess identifiability\n            within_threshold_indices = np.where(profile_deviance = threshold)[0]\n            \n            is_bounded = False\n            if len(within_threshold_indices) > 0:\n                min_idx = np.min(within_threshold_indices)\n                max_idx = np.max(within_threshold_indices)\n                if min_idx > 0 and max_idx  len(profile_grid) - 1:\n                    is_bounded = True\n            \n            case_results.append(is_bounded)\n            \n        final_results.append(case_results)\n\n    # Format and print the final output\n    output_str = '[' + ','.join([str(res) for res in final_results]) + ']'\n    output_str = output_str.replace(\"'\", \"\").replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "数字孪生的最终目标是作为一个虚拟试验平台，在将治疗方案应用于患者之前，对其进行优化。本练习将应用一个经过校准的肿瘤生长数字孪生模型，来模拟和比较不同的化疗给药方案。你的任务是在固定的总药物剂量预算下，找到能够最大限度减少累积肿瘤负荷的最优策略 。这项实践展示了数字孪生的预测能力，通过运行“计算机中的”（in silico）临床试验，你可以探索复杂的治疗权衡，为临床决策支持提供依据。",
            "id": "4217334",
            "problem": "考虑一个在个性化医疗中用于细胞毒性化疗下肿瘤负荷的简化版患者特异性数字孪生。该模型通过一个具有逻辑斯蒂增长和剂量依赖性杀伤项的单室肿瘤群体进行建模。设肿瘤群体为 $N(t)$（单位：细胞），并假设其动态由以下常微分方程（ODE）控制：$$\\dot N(t) = r\\,N(t)\\left(1 - \\frac{N(t)}{K}\\right) - \\kappa\\,u(t)\\,N(t),$$ 其中 $r$ 是内在增长率（单位：$\\mathrm{day}^{-1}$），$K$ 是环境承载力（单位：细胞），$\\kappa$ 是药物杀伤敏感性参数（单位：$(\\mathrm{mg}/\\mathrm{m}^2)^{-1}$），$u(t)$ 是化疗输注速率（单位：$\\mathrm{mg}/\\mathrm{m}^2/\\mathrm{day}$）。假设 $t$ 以天为单位测量，浓度已折算到有效输注速率 $u(t)$ 中，因此 $\\kappa\\,u(t)$ 的单位为 $\\mathrm{day}^{-1}$。设初始肿瘤群体为 $N(0) = N_0$（单位：细胞）。该 ODE 是一个质量平衡模型，它结合了经过充分检验的逻辑斯蒂增长模型和一个与剂量率成正比的一阶杀伤项。\n\n您的任务是编写一个完整的程序，对于每个代表患者特异性参数集的给定测试用例，评估一组给药方案 $u(t)$。这些方案都在一个固定的时间范围 $[0,T]$（单位：天）内消耗相同的总剂量预算 $B$（单位：$\\mathrm{mg}/\\mathrm{m}^2$）。对于每个方案，通过对 ODE 进行积分来计算标准化的累积负荷 $$A = \\frac{1}{T}\\int_0^T \\frac{N(t)}{K}\\,dt,$$ 该值为无量纲。如果肿瘤在某个时间 $t_\\mathrm{ext} \\le T$ 达到灭绝（$N(t)=0$），则在计算 $A$ 时，对于所有 $t \\in [t_\\mathrm{ext}, T]$，均视为 $N(t)=0$。找出在规定方案下使 $A$ 最小化的给药计划。如果出现平局，即对于两个或多个最佳计划有 $|A_i - A_j| \\le 10^{-6}$，则选择索引最小的那个计划。\n\n每个测试用例需要比较的给药方案如下：\n- 方案 $0$（节拍式）：对于所有 $t \\in [0,T]$，$u(t) = \\frac{B}{T}$，否则 $u(t)=0$。\n- 方案 $1$（每周脉冲，每次 $1$ 天）：在 $t=0,7,14,\\dots$（严格小于 $T$）开始的日期，以 $u(t) = \\frac{B}{n_\\mathrm{w}}$ 的速率输注 $1$ 天，其中 $n_\\mathrm{w}$ 是 $[0,T)$ 内的脉冲次数；否则 $u(t)=0$。\n- 方案 $2$（每两周脉冲，每次 $1$ 天）：在 $t=0,14,28,\\dots$（严格小于 $T$）开始的日期，以 $u(t) = \\frac{B}{n_\\mathrm{b}}$ 的速率输注 $1$ 天，其中 $n_\\mathrm{b}$ 是 $[0,T)$ 内的脉冲次数；否则 $u(t)=0$。\n- 方案 $3$（前期负荷，前 $3$ 天）：对于 $t \\in [0,d)$ 且 $d=\\min(3,T)$，$u(t) = \\frac{B}{d}$；否则 $u(t)=0$。\n\n为确保数值上的真实性，所有参数都具有科学合理性且自洽。使用以下参数集测试套件 $(r,K,\\kappa,N_0,T,B)$：\n- 用例 $1$：$(0.03,\\,10^9,\\,0.002,\\,10^8,\\,42,\\,600)$\n- 用例 $2$：$(0.06,\\,10^9,\\,0.0015,\\,2\\times 10^8,\\,42,\\,600)$\n- 用例 $3$：$(0.03,\\,10^9,\\,0.0005,\\,10^8,\\,42,\\,600)$\n- 用例 $4$：$(0.005,\\,10^9,\\,0.002,\\,3\\times 10^8,\\,42,\\,600)$\n- 用例 $5$（无治疗预算的边界条件）：$(0.03,\\,10^9,\\,0.002,\\,10^8,\\,42,\\,0)$\n\n所有时间量必须以天为单位处理，$N(t)$ 必须以细胞为单位解释，输注速率 $u(t)$ 以 $\\mathrm{mg}/\\mathrm{m}^2/\\mathrm{day}$ 为单位，而 $A$ 是无量纲的。\n\n您的程序应按顺序输出上述各用例的最优方案索引，并将结果汇总成单行输出，形式为方括号括起来的逗号分隔列表。例如，输出应为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$ 的形式，其中每个 $\\text{result}_i$ 是 $\\{0,1,2,3\\}$ 中的一个整数。",
            "solution": "用户提供的问题是计算系统生物学和个性化医疗领域中一个有效且适定的任务。它要求通过比较一组离散的方案与一个生物学相关的目标函数，来优化化疗给药策略。其基础模型是一个标准的逻辑斯蒂增长模型，并用一个一阶药物杀伤项进行了修正，这是对治疗中肿瘤动态的一个有科学依据的简化。所有参数、约束和目标函数都有清晰且一致的定义。\n\n问题在于，针对每个患者特异性参数集，找出四个已定义给药计划中的哪一个能使标准化累积肿瘤负荷 $A$ 最小化。这需要为每个计划求解一个常微分方程（ODE），然后对得到的肿瘤群体轨迹进行积分评估。\n\n控制肿瘤群体 $N(t)$ 的 ODE 为：\n$$\n\\dot N(t) = \\frac{dN}{dt} = r\\,N(t)\\left(1 - \\frac{N(t)}{K}\\right) - \\kappa\\,u(t)\\,N(t)\n$$\n初始条件为 $N(0) = N_0$。参数包括内在增长率 $r$、环境承载力 $K$、药物杀伤敏感性 $\\kappa$ 以及初始肿瘤大小 $N_0$。函数 $u(t)$ 是随时间变化的化疗输注速率。\n\n目标是最小化标准化的累积肿瘤负荷，这是一个无量纲量，定义为：\n$$\nA[u] = \\frac{1}{T}\\int_0^T \\frac{N(t; u)}{K}\\,dt\n$$\n其中 $N(t; u)$ 是在控制方案 $u(t)$ 下，在时间范围 $[0, T]$ 内 ODE 的解。所有方案都必须遵守一个固定的总剂量预算 $B$，即 $\\int_0^T u(t)\\,dt = B$。\n\n需要比较的四个计划是：\n1.  **方案 $0$（节拍式）：** 在整个时间范围内进行连续、恒定的输注。\n    $$\n    u_0(t) = \\begin{cases} B/T  \\text{for } t \\in [0, T] \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n2.  **方案 $1$（每周脉冲）：** 在每周开始时进行短暂、高剂量的输注。设周期为 $P_1 = 7$ 天。脉冲次数 $n_\\mathrm{w}$ 是满足 $k P_1  T$ 的非负整数 $k$ 的数量。\n    $$\n    u_1(t) = \\begin{cases} B/n_\\mathrm{w}  \\text{if } t \\in [kP_1, kP_1+1) \\text{ for some integer } k \\ge 0 \\text{ with } kP_1  T \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n3.  **方案 $2$（每两周脉冲）：** 与每周脉冲类似，但周期为 $P_2 = 14$ 天。脉冲次数为 $n_\\mathrm{b}$。\n    $$\n    u_2(t) = \\begin{cases} B/n_\\mathrm{b}  \\text{if } t \\in [kP_2, kP_2+1) \\text{ for some integer } k \\ge 0 \\text{ with } kP_2  T \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n4.  **方案 $3$（前期负荷）：** 在治疗期开始时以高速率输注全部剂量。设 $d = \\min(3, T)$。\n    $$\n    u_3(t) = \\begin{cases} B/d  \\text{for } t \\in [0, d) \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n该 ODE 是一个伯努利方程，对于分段常数函数 $u(t)$ 可以解析求解。然而，数值方法更为稳健、通用，并且在处理复杂的边界条件时不易出现实现错误。我们将采用一个高质量的数值 ODE 求解器。\n\n**数值积分策略：**\n解决方案的核心在于对每个计划的 ODE 进行数值积分。\n-   **ODE 求解器：** 我们使用 `scipy.integrate.solve_ivp`，这是一个现代的自适应步长求解器。该函数非常适合处理系统可能存在的刚性动力学（例如，快速的细胞杀伤后接着缓慢的再生长）。我们将其配置为产生密集输出，即解的连续插值，从而可以在任何时间点进行精确评估。\n-   **肿瘤灭绝：** 问题规定，如果 $N(t)$ 达到零，它将保持为零。由于细胞群体 $N(t)$ 不能为负，且 ODE 确保 $N(t)$ 仅从正初始条件渐近趋近于零，我们将“达到灭绝”解释为一个实际阈值。我们将此阈值设为 $N(t)  1$ 个细胞，因为非整数的细胞群体不符合物理实际。`solve_ivp` 的 `events` 功能用于检测解 $N(t)$ 从上方穿过此阈值的时刻。当此事件发生时，积分在事件时间 $t_\\mathrm{ext}$ 终止。\n-   **目标函数计算：** 用于计算 $A$ 的积分使用 `scipy.integrate.quad` 进行。鉴于 `solve_ivp` 提供的密集输出，这可以非常精确地评估积分。如果灭绝事件发生在 $t_\\mathrm{ext}  T$，积分只计算到 $t_\\mathrm{ext}$，因为对于 $t > t_\\mathrm{ext}$，$N(t)=0$：\n    $$\n    A = \\frac{1}{TK} \\int_0^{t_\\mathrm{ext}} N(t)\\,dt\n    $$\n    如果没有发生灭绝事件，则 $t_\\mathrm{ext} = T$。\n\n**算法流程：**\n总体算法系统地评估每个用例和每个计划：\n1.  遍历五个参数集（测试用例）中的每一个。\n2.  对每个用例，遍历四个给药计划（索引 $0$ 到 $3$）。\n3.  对每个计划：\n    a. 根据计划的定义以及用例参数 $T$ 和 $B$ 构建相应的控制函数 $u(t)$。\n    b. 定义 ODE 的右侧函数，该函数包含特定的 $u(t)$。\n    c. 为 ODE 求解器定义一个终止事件，以处理 $N(t)  1$ 时的肿瘤灭绝。\n    d. 使用 `solve_ivp` 在 $[0, T]$ 上数值求解初值问题。\n    e. 使用 `quad` 通过对所得解进行积分来计算目标函数 $A$。\n4.  在评估完一个给定用例的所有四个计划后，确定 $A$ 的最小值。\n5.  确定最优计划的索引。如果出现平局，即对于最佳计划有 $|A_i - A_j| \\le 10^{-6}$，则按照问题的平局决胜规则选择索引最小的那个。\n6.  收集所有测试用例的最优索引。\n7.  将最终结果格式化为方括号括起来的逗号分隔列表。\n\n这种有原则且稳健的数值方法确保了对治疗方案的准确可靠的比较，从而为每个患者特异性模型确定了最优策略。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the tumor growth ODE for various chemotherapy schedules to find the optimal one.\n    \"\"\"\n\n    test_cases = [\n        # (r, K, kappa, N0, T, B)\n        (0.03, 1e9, 0.002, 1e8, 42, 600),\n        (0.06, 1e9, 0.0015, 2e8, 42, 600),\n        (0.03, 1e9, 0.0005, 1e8, 42, 600),\n        (0.005, 1e9, 0.002, 3e8, 42, 600),\n        (0.03, 1e9, 0.002, 1e8, 42, 0),\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        r, K, kappa, N0, T, B = case\n        \n        schedules = []\n\n        # Schedule 0: Metronomic\n        def u0(t, T_loc=T, B_loc=B):\n            if 0 = t = T_loc:\n                return B_loc / T_loc if T_loc > 0 else 0\n            return 0\n        schedules.append(u0)\n\n        # Schedule 1: Weekly pulses\n        def u1(t, T_loc=T, B_loc=B):\n            if t  0 or t >= T_loc or T_loc = 0:\n                return 0\n            period = 7\n            num_pulses = math.floor((T_loc - 1e-9) / period) + 1\n            if num_pulses == 0: return 0\n            pulse_rate = B_loc / num_pulses\n            if (t / period) - math.floor(t / period)  (1 / period):\n                return pulse_rate\n            return 0\n        schedules.append(u1)\n        \n        # Schedule 2: Biweekly pulses\n        def u2(t, T_loc=T, B_loc=B):\n            if t  0 or t >= T_loc or T_loc = 0:\n                return 0\n            period = 14\n            num_pulses = math.floor((T_loc - 1e-9) / period) + 1\n            if num_pulses == 0: return 0\n            pulse_rate = B_loc / num_pulses\n            if (t / period) - math.floor(t / period)  (1 / period):\n                return pulse_rate\n            return 0\n        schedules.append(u2)\n        \n        # Schedule 3: Front-loaded\n        def u3(t, T_loc=T, B_loc=B):\n            d = min(3, T_loc)\n            if 0 = t  d:\n                return B_loc / d if d > 0 else 0\n            return 0\n        schedules.append(u3)\n\n        A_values = []\n        for u_func in schedules:\n            def ode_func(t, y, r_loc, K_loc, kappa_loc, u_f):\n                N = y[0]\n                if N  0:\n                    N = 0\n                dN_dt = r_loc * N * (1 - N / K_loc) - kappa_loc * u_f(t) * N\n                return [dN_dt]\n\n            def extinction(t, y, r_loc, K_loc, kappa_loc, u_f):\n                return y[0] - 1\n            extinction.terminal = True\n            extinction.direction = -1\n\n            sol = solve_ivp(\n                ode_func,\n                (0, T),\n                [N0],\n                args=(r, K, kappa, u_func),\n                dense_output=True,\n                events=extinction,\n                method='RK45',\n                atol=1e-8,\n                rtol=1e-8\n            )\n\n            t_end = T\n            if sol.t_events and len(sol.t_events[0]) > 0:\n                t_end = sol.t_events[0][0]\n\n            integral_val, _ = quad(lambda t: sol.sol(t)[0], 0, t_end)\n            \n            A = (1 / (T * K)) * integral_val if T > 0 else 0.\n            A_values.append(A)\n\n        min_A = min(A_values)\n        \n        tied_indices = np.where(np.isclose(A_values, min_A, rtol=0, atol=1e-6))[0]\n        \n        best_index = np.min(tied_indices)\n        final_results.append(best_index)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}