{
    "hands_on_practices": [
        {
            "introduction": "可追溯性的基础是建立一个结构化模型，将需求、设计、代码和测试等不同工件联系起来。将这些关系建模为二部图及其对应的矩阵表示是一种标准方法。在管理复杂系统时，一个关键的初步分析是确保基本的完整性：是否所有需求都在实现中得到了体现？是否所有的实现都是由某个需求驱动的？本练习  提供了一种动手实践的方法，通过识别“孤立需求”和“死代码”来执行这种静态完整性检查，这是确保项目覆盖范围和效率的基石。",
            "id": "4240765",
            "problem": "一个信息物理系统 (CPS) 项目维护着一组功能需求和一组代码模块之间的追溯性链接。将这种追溯性建模为一个二分图，其顶点集为 $R$（需求）和 $C$（代码模块），边集为 $E \\subseteq R \\times C$，其中 $(r_{i}, c_{j}) \\in E$ 表示从需求 $r_{i}$ 到代码模块 $c_{j}$ 的一条追溯性链接。设二分追溯矩阵为邻接矩阵 $M \\in \\{0,1\\}^{n_{R} \\times n_{C}}$，其元素为\n$$\nM_{i,j} =\n\\begin{cases}\n1  \\text{如果 } (r_{i}, c_{j}) \\in E,\\\\\n0  \\text{其他情况}。\n\\end{cases}\n$$\n对 $i \\in \\{0,1,\\dots,n_{R}-1\\}$ 和 $j \\in \\{0,1,\\dots,n_{C}-1\\}$ 采用从零开始的索引。\n\n基于集合论和图论的定义：\n- 一个需求 $r_{i}$ 是孤儿需求，当且仅当它没有任何关联边，即 $\\nexists\\, j \\in \\{0,1,\\dots,n_{C}-1\\}$ 使得 $M_{i,j} = 1$。\n- 一个代码模块 $c_{j}$ 是死代码（相对于指定的需求而言），当且仅当它没有任何关联边，即 $\\nexists\\, i \\in \\{0,1,\\dots,n_{R}-1\\}$ 使得 $M_{i,j} = 1$。\n\n任务：\n1. 基于上述定义，推导一个算法。该算法在给定 $n_{R}$、$n_{C}$ 和一个有限链接集 $E$ 的情况下，构建矩阵 $M$ 并检测以下集合\n$$\nO = \\{\\, i \\in \\{0,\\dots,n_{R}-1\\} \\mid \\sum_{j=0}^{n_{C}-1} M_{i,j} = 0 \\,\\}\n\\quad\\text{和}\\quad\nD = \\{\\, j \\in \\{0,\\dots,n_{C}-1\\} \\mid \\sum_{i=0}^{n_{R}-1} M_{i,j} = 0 \\,\\}，\n$$\n其中 $O$ 是孤儿需求的索引集，$D$ 是死代码模块的索引集。您的推导必须从上述核心定义以及二分图中度的基本性质出发，而不是从一个预先给定的简化公式开始。\n\n2. 将该算法实现为一个完整的程序，对于所提供的测试套件中的每个测试用例，输出 $O$ 和 $D$ 中已排序的索引列表。\n\n3. 通过将 $O$ 解释为未实现或未追踪的需求，将 $D$ 解释为与任何需求都无关的代码，来确保科学真实性；并基于所采用的形式化模型，论证检测的正确性。\n\n输入在程序内部固定；不读取外部输入。通篇使用从零开始的索引。\n\n用于覆盖典型和边界场景的测试套件：\n- 测试用例 1 (理想路径)：$n_{R} = 4$, $n_{C} = 5$, $E = \\{(0,0),(0,3),(1,1),(1,3),(3,4)\\}$。预期概念性结果：至少有一个孤儿需求和一个死代码模块。\n- 测试用例 2 (完全连接)：$n_{R} = 3$, $n_{C} = 3$, $E = \\{(i,j) \\mid i \\in \\{0,1,2\\}, j \\in \\{0,1,2\\}\\}$。预期概念性结果：没有孤儿需求也没有死代码。\n- 测试用例 3 (没有链接)：$n_{R} = 2$, $n_{C} = 3$, $E = \\varnothing$。预期概念性结果：所有需求都是孤儿需求，所有模块都是死代码。\n- 测试用例 4 (没有需求)：$n_{R} = 0$, $n_{C} = 3$, $E = \\varnothing$。预期概念性结果：没有孤儿需求（因为没有需求，此条件空洞地成立），且所有模块都是死代码。\n- 测试用例 5 (没有模块)：$n_{R} = 2$, $n_{C} = 0$, $E = \\varnothing$。预期概念性结果：所有需求都是孤儿需求，并且没有模块可被标记为死代码。\n\n最终输出格式规范：\n- 对于每个测试用例 $t \\in \\{1,2,3,4,5\\}$，计算列表对 $[O_{t}, D_{t}]$，其中 $O_{t}$ 是孤儿需求索引的排序列表，$D_{t}$ 是死代码索引的排序列表。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果。该输出是一个用方括号括起来的逗号分隔列表，每个元素本身都是一个包含两个列表的数组。例如，一个语法上类似的形状是 $[[[],[]],[[0],[1,2]]]$（这只是一个示例形状，并非上述测试套件的答案）。",
            "solution": "该问题要求推导并实现一个算法，以在需求追溯性模型中识别未追踪的实体。该模型是一个连接需求集 $R$ 和代码模块集 $C$ 的二分图。需要识别的实体是“孤儿需求”（未链接到任何代码模块的需求）和“死代码”（未链接到任何需求的代码模块）。解决方案从图论和线性代数的第一性原理推导得出。\n\n### 1. 从第一性原理推导\n\n追溯系统被建模为一个二分图 $G = (R \\cup C, E)$，其中 $R = \\{r_0, r_1, \\dots, r_{n_R-1}\\}$ 是需求顶点的集合，$C = \\{c_0, c_1, \\dots, c_{n_C-1}\\}$ 是代码模块顶点的集合，$E \\subseteq R \\times C$ 是表示追溯性链接的边集。该图的结构由其双邻接矩阵捕获，问题将其定义为追溯矩阵 $M \\in \\{0, 1\\}^{n_R \\times n_C}$。元素 $M_{i,j} = 1$ 表示存在一条边 $(r_i, c_j) \\in E$，$M_{i,j}=0$ 表示不存在。\n\n图中顶点的一个基本性质是它的度，记为 $\\deg(v)$，即与该顶点关联的边的数量。孤儿需求和死代码的定义可以直接用这个概念来表达。\n\n**孤儿需求：**\n一个需求 $r_i$ 被定义为孤儿，如果它没有关联边。用图论的术语来说，这等同于声明顶点 $r_i$ 的度为零：$\\deg(r_i) = 0$。\n\n顶点 $r_i \\in R$ 的度可以从追溯矩阵 $M$ 计算得出。当且仅当存在一条连接 $r_i$ 和 $c_j$ 的边时，元素 $M_{i,j}$ 为 $1$。因此，连接到 $r_i$ 的总边数（即其度）是矩阵 $M$ 第 $i$ 行所有元素的和。\n$$\n\\deg(r_i) = \\sum_{j=0}^{n_C-1} M_{i,j}\n$$\n将孤儿需求的定义与其度的计算相结合，我们发现需求 $r_i$ 是孤儿，当且仅当：\n$$\n\\sum_{j=0}^{n_C-1} M_{i,j} = 0\n$$\n这个推导验证了问题中为孤儿需求索引集 $O$ 提供的公式。算法必须找到所有对应行和为零的行索引 $i$。\n\n**死代码模块：**\n类似地，一个代码模块 $c_j$ 被定义为死代码，如果它没有关联边。这等同于声明顶点 $c_j$ 的度为零：$\\deg(c_j) = 0$。\n\n顶点 $c_j \\in C$ 的度可以从矩阵 $M$ 的列计算得出。当且仅当存在一条连接 $c_j$ 和 $r_i$ 的边时，元素 $M_{i,j}$ 为 $1$。因此，连接到 $c_j$ 的总边数是矩阵 $M$ 第 $j$ 列所有元素的和。\n$$\n\\deg(c_j) = \\sum_{i=0}^{n_R-1} M_{i,j}\n$$\n因此，一个代码模块 $c_j$ 被归类为死代码，当且仅当：\n$$\n\\sum_{i=0}^{n_R-1} M_{i,j} = 0\n$$\n这个推导验证了问题中为死代码模块索引集 $D$ 提供的公式。算法必须找到所有对应列和为零的列索引 $j$。\n\n### 2. 算法设计与正确性\n\n基于上述推导，可以设计一个简单直接的算法。\n\n1.  **矩阵构建**：给定维度 $n_R$ 和 $n_C$ 以及链接集 $E$，构建 $n_R \\times n_C$ 的追溯矩阵 $M$。这通过初始化一个 $n_R \\times n_C$ 的零矩阵，然后对每个链接 $(i, j) \\in E$ 设置 $M_{i,j} = 1$ 来完成。此步骤将基于集合的边表示正确地转换为矩阵模型。\n\n2.  **度计算**：计算矩阵 $M$ 的每行和每列的和。第 $i$ 行的和得出 $\\deg(r_i)$，第 $j$ 列的和得出 $\\deg(c_j)$。使用向量化操作可以高效地执行此计算。\n\n3.  **索引识别**：识别和为零的行与列的索引。行和为 $0$ 的索引 $i$ 的集合构成了孤儿需求索引集 $O$。列和为 $0$ 的索引 $j$ 的集合构成了死代码模块索引集 $D$。根据问题规范，生成的索引列表应该被排序。\n\n该算法可证明是正确的，因为每一步都是对形式化推导出的数学条件的直接实现。该模型本身是用于追溯性分析的一个科学上合理的抽象。在实践中，识别孤儿需求（$O$ 的元素）对项目管理至关重要，因为它标记出那些可能未实现或其实现未被正式追踪的需求，这对项目完成和验证构成了风险。识别死代码（$D$ 的元素）对代码质量和维护至关重要，因为它指出了那些没有任何指定需求支持的代码，这些代码可以被安全地移除，从而降低复杂性和维护成本。所提出的算法为执行此分析提供了一种可靠的自动化方法。边界情况，例如没有需求（$n_R=0$）或没有代码模块（$n_C=0$），都可以被此形式体系优雅地处理。例如，如果 $n_R=0$，则没有需求可以是孤儿，所以 $O=\\varnothing$。一个 $0 \\times n_C$ 矩阵的列和全部为 $0$，从而正确地将所有存在的代码模块识别为死代码。",
            "answer": "```python\nimport numpy as np\n\ndef find_untraced(n_r, n_c, links):\n    \"\"\"\n    Constructs the trace matrix and finds orphan requirements and dead code.\n\n    Args:\n        n_r (int): The number of requirements.\n        n_c (int): The number of code modules.\n        links (list of tuples): The set of traceability links (i, j).\n\n    Returns:\n        list: A list containing two lists: the sorted indices of orphan\n              requirements and the sorted indices of dead code modules.\n    \"\"\"\n    # The matrix M is initialized with zeros.\n    # For n_r=0, its shape is (0, n_c). For n_c=0, its shape is (n_r, 0).\n    # This unified setup correctly handles all boundary conditions without\n    # special case logic.\n    M = np.zeros((n_r, n_c), dtype=int)\n\n    # Populate the matrix from the edge set.\n    # If links is empty, or n_r=0, or n_c=0, this block is correctly skipped\n    # or has no effect, leaving M as a zero matrix.\n    if links:\n        # Unzip the list of tuples into row and column indices for efficient assignment.\n        rows, cols = zip(*links)\n        M[rows, cols] = 1\n\n    # Calculate row sums. The sum of row i corresponds to the degree of requirement r_i.\n    # If n_r=0, row_sums is an empty array.\n    # If n_c=0, row_sums is an array of n_r zeros, correctly marking all requirements as orphans.\n    row_sums = M.sum(axis=1)\n\n    # Calculate column sums. The sum of column j corresponds to the degree of module c_j.\n    # If n_c=0, col_sums is an empty array.\n    # If n_r=0, col_sums is an array of n_c zeros, correctly marking all modules as dead code.\n    col_sums = M.sum(axis=0)\n\n    # An orphan requirement has a degree of 0, meaning its corresponding row sum is 0.\n    # np.where returns sorted indices, which satisfies the problem requirements.\n    # The result is converted to a standard Python list.\n    orphan_reqs_indices = np.where(row_sums == 0)[0].tolist()\n\n    # A dead code module has a degree of 0, meaning its corresponding column sum is 0.\n    dead_code_indices = np.where(col_sums == 0)[0].tolist()\n\n    return [orphan_reqs_indices, dead_code_indices]\n\ndef solve():\n    \"\"\"\n    Runs the traceability analysis on a predefined test suite and prints the results.\n    \"\"\"\n    # Test suite covering typical, fully connected, empty, and boundary scenarios.\n    test_suite = [\n        # Test case 1 (happy path)\n        (4, 5, [(0, 0), (0, 3), (1, 1), (1, 3), (3, 4)]),\n        # Test case 2 (fully connected)\n        (3, 3, [(i, j) for i in range(3) for j in range(3)]),\n        # Test case 3 (no links)\n        (2, 3, []),\n        # Test case 4 (no requirements)\n        (0, 3, []),\n        # Test case 5 (no modules)\n        (2, 0, [])\n    ]\n    \n    all_results = []\n    for n_r, n_c, E in test_suite:\n        result = find_untraced(n_r, n_c, E)\n        all_results.append(result)\n\n    # Format the final output string precisely as specified in the problem statement.\n    # The output is a single-line string representation of a list of lists,\n    # with no whitespace between elements.\n    # e.g., [[[O1],[D1]],[[O2],[D2]],...]\n    results_str_parts = []\n    for res_pair in all_results:\n        # res_pair is a list like [[0, 1], [0, 1, 2]]\n        # Format the list of orphan indices, e.g., '[0,1]'\n        o_list_str = f\"[{','.join(map(str, res_pair[0]))}]\"\n        # Format the list of dead code indices, e.g., '[0,1,2]'\n        d_list_str = f\"[{','.join(map(str, res_pair[1]))}]\"\n        # Combine them into the pair format, e.g., '[[0,1],[0,1,2]]'\n        results_str_parts.append(f\"[{o_list_str},{d_list_str}]\")\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了静态追溯模型之后，下一步是利用它进行动态分析，例如影响分析和依赖追溯。追溯链接不仅用于记录，更重要的是，它们代表了工件之间的依赖关系和信息流。前向和后向可达性的概念是进行影响分析（变更会影响什么？）和依赖追溯（哪个需求导致了这个工件？）的强大形式化工具。本练习  将图遍历技术应用于追溯模型，让您能够量化依赖关系并识别更复杂的追溯断裂，例如代码未被相应测试验证的情况。",
            "id": "4240764",
            "problem": "一个有向可追溯性图 $G = (V, E)$ 建模了信息物理系统 (CPS) 的数字孪生 (DT) 中的工件和链接，遵循系统工程 (SE) 中关于需求工程和可追溯性的原则。顶点集为 $V = \\{R1, R2, \\mathrm{DesignA}, \\mathrm{CodeB}, \\mathrm{TestC}\\}$，有向边集为 $E = \\{(R1, \\mathrm{DesignA}), (\\mathrm{DesignA}, \\mathrm{CodeB}), (R1, \\mathrm{TestC}), (R2, \\mathrm{TestC})\\}$。标记为 $R1$ 和 $R2$ 的顶点是需求，$\\mathrm{DesignA}$ 是设计工件，$\\mathrm{CodeB}$ 是代码工件，$\\mathrm{TestC}$ 是测试工件。\n\n使用以下基本定义：\n- 对于顶点 $x \\in V$，其前向可达集 $F(x)$ 是所有顶点 $v \\in V$ 的集合，使得在图 $G$ 中存在一条从 $x$ 到 $v$ 的有向路径（不包括 $x$ 本身）。\n- 对于顶点 $x \\in V$，其后向可达集 $B(x)$ 是所有顶点 $u \\in V$ 的集合，使得在图 $G$ 中存在一条从 $u$ 到 $x$ 的有向路径（不包括 $x$ 本身）。\n- 在强验证策略下，从一个需求前向可达的每个代码工件都必须有一条到至少一个测试工件的有向路径。将缺失验证计数 $M$ 定义为 $F(R1)$ 中没有任何到 $V$ 中任何测试工件的有向路径的代码工件集合的基数。\n\n计算以下内容：\n1. 集合 $F(R1)$ 和 $B(R1)$。\n2. 和 $S = |F(R1)| + |B(R1)|$。\n3. 如上定义的缺失验证计数 $M$。\n\n最后，计算单个值 $V = S + M$。请用一个纯数字表示您的最终答案。无需四舍五入，不涉及单位。",
            "solution": "该问题被验证为科学上合理、定义明确且客观。它基于图论的标准原理，并应用于系统工程 (SE) 可追溯性这一正式且成熟的实践中。唯一解所需的所有定义和数据均已提供，不存在矛盾或歧义。\n\n该问题需要分析一个有向图 $G = (V, E)$。顶点集由 $V = \\{R1, R2, \\mathrm{DesignA}, \\mathrm{CodeB}, \\mathrm{TestC}\\}$ 给出。有向边集为 $E = \\{(R1, \\mathrm{DesignA}), (\\mathrm{DesignA}, \\mathrm{CodeB}), (R1, \\mathrm{TestC}), (R2, \\mathrm{TestC})\\}$。我们将逐步计算所需的量。\n\n首先，我们计算顶点 $R1$ 的前向可达集 $F(R1)$ 和后向可达集 $B(R1)$。\n\n前向可达集 $F(x)$ 定义为所有顶点 $v \\in V$ 的集合，其中存在一条从 $x$ 到 $v$ 的有向路径，不包括 $x$ 本身。为了找到 $F(R1)$，我们识别所有从 $R1$ 开始的路径。\n- 存在一条有向边 $(R1, \\mathrm{DesignA})$，这是一条长度为 $1$ 的路径。因此，$\\mathrm{DesignA} \\in F(R1)$。\n- 存在一条有向边 $(R1, \\mathrm{TestC})$，这是一条长度为 $1$ 的路径。因此，$\\mathrm{TestC} \\in F(R1)$。\n- 存在一条从 $R1$ 到 $\\mathrm{CodeB}$ 的长度为 $2$ 的路径：$R1 \\rightarrow \\mathrm{DesignA} \\rightarrow \\mathrm{CodeB}$。因此，$\\mathrm{CodeB} \\in F(R1)$。\n没有其他顶点可以从 $R1$ 到达。因此，前向可达集为 $F(R1) = \\{\\mathrm{DesignA}, \\mathrm{CodeB}, \\mathrm{TestC}\\}$。\n\n后向可达集 $B(x)$ 定义为所有顶点 $u \\in V$ 的集合，其中存在一条从 $u$ 到 $x$ 的有向路径，不包括 $x$ 本身。为了找到 $B(R1)$，我们识别所有以 $R1$ 结束的路径。通过检查边集 $E$，我们观察到不存在任何形式为 $(u, R1)$ 的边（对于任何 $u \\in V$）。顶点 $R1$ 的入度为 $0$。因此，不存在从任何其他顶点到 $R1$ 的路径。所以后向可达集为空集，$B(R1) = \\emptyset$。\n\n接下来，我们计算和 $S = |F(R1)| + |B(R1)|$。\n一个集合的基数是它包含的元素的数量。\n$|F(R1)| = |\\mathrm{ \\{\\mathrm{DesignA}, \\mathrm{CodeB}, \\mathrm{TestC}\\}} | = 3$。\n$|B(R1)| = |\\emptyset| = 0$。\n和为 $S = 3 + 0 = 3$。\n\n然后，我们计算缺失验证计数 $M$。根据定义，$M$ 是 $F(R1)$ 中没有任何到 $V$ 中任何测试工件的有向路径的代码工件集合的基数。\n首先，我们识别 $F(R1)$ 中的代码工件。该集合为 $F(R1) = \\{\\mathrm{DesignA}, \\mathrm{CodeB}, \\mathrm{TestC}\\}$。根据问题描述，$\\mathrm{CodeB}$ 是唯一的代码工件。所以，$F(R1)$ 中的代码工件集是 $\\{\\mathrm{CodeB}\\}$。\n其次，我们识别 $V$ 中的测试工件。根据问题描述，$\\mathrm{TestC}$ 是唯一的测试工件。测试工件集是 $\\{\\mathrm{TestC}\\}$。\n第三，我们检查代码工件 $\\mathrm{CodeB}$ 是否有到测试工件 $\\mathrm{TestC}$ 的有向路径。通过检查图的边集 $E$，我们看到没有从 $\\mathrm{CodeB}$ 出发的边。$\\mathrm{CodeB}$ 的出度为 $0$。因此，没有从 $\\mathrm{CodeB}$ 到任何其他顶点（包括 $\\mathrm{TestC}$）的有向路径。\n在 $F(R1)$ 中没有到测试工件的有向路径的代码工件集合是 $\\{\\mathrm{CodeB}\\}$。\n缺失验证计数 $M$ 是这个集合的基数：$M = |\\{\\mathrm{CodeB}\\}| = 1$。\n\n最后，我们计算值 $V = S + M$。\n我们得到 $S = 3$ 和 $M = 1$。\n因此，$V = 3 + 1 = 4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "信息物理系统中的需求工程不仅涉及设计时工件的结构性追溯，还必须延伸到对系统运行时性能的验证。诸如可靠性、延迟或资源消耗等性能需求，必须通过对真实或仿真系统产生的运行数据进行分析来验证。这个过程不可避免地会涉及测量不确定性和统计推断。本练习  演示了如何将一个形式化的性能需求（例如，网络丢包率）与经验数据联系起来，并使用统计方法在指定的置信水平下做出合规性决策，这是现代系统工程中的一项关键技能。",
            "id": "4240737",
            "problem": "一个由数字孪生（DT）监控的信息物理系统（CPS）必须满足一个网络可靠性要求，该要求规定真实丢包概率至多为 $p \\le 0.02$。为实现可追溯性，该要求被操作化如下：一个包含 $n = 1000$ 个已发送数据包的监控窗口被视为 $n$ 次独立同分布的伯努利试验，其损失指示器为 $Y_i \\in \\{0,1\\}$，其中 $\\Pr(Y_i = 1) = p$ 是未知的丢包概率。DT 在此窗口中记录到 $x = 15$ 次丢包。\n\n从伯努利模型和中心极限定理出发，推导经验丢包率 $\\hat{p}$ 以及 $p$ 的一个近似的单边 $95\\%$ 置信上界。使用正态近似来证明单边置信界构造的合理性，并陈述一个可追溯至该要求的合规性决策规则（即，如果该上界至多为 $0.02$，则在 $0.95$ 的置信水平上，该要求被视为满足）。\n\n仅报告 $p$ 的单边 $95\\%$ 置信上界，以小数形式表示，并四舍五入到四位有效数字。报告的数字中不允许使用百分号。",
            "solution": "### 步骤 1：提取已知条件\n-   **要求**：真实丢包概率至多为 $p \\le 0.02$。\n-   **监控窗口大小**：$n = 1000$ 个数据包。\n-   **模型**：$n$ 次独立同分布的伯努利试验。\n-   **损失指示器**：$Y_i \\in \\{0, 1\\}$。\n-   **丢包概率**：$\\Pr(Y_i = 1) = p$。\n-   **观测数据**：窗口内有 $x = 15$ 次丢包。\n-   **方法**：使用中心极限定理以及对伯努利/二项分布的正态近似，推导 $p$ 的近似单边 $95\\%$ 置信上界。\n-   **合规性决策规则**：如果该上界至多为 $0.02$，则在 $0.95$ 的置信水平上，该要求被视为满足。\n-   **输出要求**：以小数形式报告 $p$ 的单边 $95\\%$ 置信上界，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在标准统计理论中有坚实的基础。使用伯努利试验对丢包进行建模、使用中心极限定理（CLT）进行大样本近似，以及构造置信区间，这些都是统计推断和工程可靠性中的基本技术。\n-   **适定性**：该问题是适定的。它提供了所有必要的数据（$n$、$x$、置信水平），并指明了理论方法（CLT、正态近似），以找到唯一的数值答案。\n-   **客观性**：该问题以精确、客观的语言陈述，没有主观或模糊的术语。\n-   **一致性检查**：当 $np$ 和 $n(1-p)$ 都足够大（通常大于 5）时，对二项分布进行正态近似是合适的。使用样本估计值 $\\hat{p} = x/n = 15/1000 = 0.015$，我们发现 $n\\hat{p} = 1000 \\times 0.015 = 15$ 且 $n(1-\\hat{p}) = 1000 \\times (1 - 0.015) = 985$。两个值都远大于 5，这验证了使用正态近似的合理性。\n\n### 步骤 3：结论与行动\n该问题被认为是有效的，因为它在科学上是合理的、适定的、客观的且内部一致的。将推导其解决方案。\n\n### 解决方案推导\n该问题要求基于一个样本，计算总体比例 $p$ 的单边置信上界。\n\n设 $X$ 为 $n$ 个数据包样本中观测到的总丢包数。数据包传输序列被建模为 $n$ 次独立同分布的伯努利试验。因此，$X$ 服从二项分布，$X \\sim B(n, p)$，其中 $p$ 是真实的、未知的丢包概率。\n\n$p$ 的点估计量是样本比例，记为 $\\hat{p}$：\n$$ \\hat{p} = \\frac{X}{n} $$\n该估计量的期望值为 $E[\\hat{p}] = p$，其方差为 $\\text{Var}(\\hat{p}) = \\frac{p(1-p)}{n}$。\n\n根据中心极限定理，对于足够大的样本量 $n$，$\\hat{p}$ 的抽样分布可以用正态分布来近似：\n$$ \\hat{p} \\approx N\\left(p, \\frac{p(1-p)}{n}\\right) $$\n这意味着标准化随机变量 $Z$ 近似为一个标准正态随机变量，$Z \\sim N(0, 1)$：\n$$ Z = \\frac{\\hat{p} - p}{\\sqrt{\\frac{p(1-p)}{n}}} $$\n为了构造 $p$ 的单边 $100(1-\\alpha)\\%$ 置信区间，我们寻求一个上界 $p_{upper}$，使得 $\\Pr(p \\le p_{upper}) = 1-\\alpha$。这等价于找到不被观测数据在统计上拒绝的 $p$ 值的集合。我们从单边区间的概率陈述开始：\n$$ \\Pr\\left( \\frac{\\hat{p} - p}{\\sqrt{\\frac{p(1-p)}{n}}} > -z_{1-\\alpha} \\right) = 1-\\alpha $$\n其中 $z_{1-\\alpha}$ 是标准正态分布的 $(1-\\alpha)$-分位数。对于 $95\\%$ 的置信水平，$1-\\alpha = 0.95$，因此 $\\alpha = 0.05$。临界值是 $z_{0.95}$，约等于 $1.645$。\n\n分母中的标准误项 $\\sqrt{p(1-p)/n}$ 取决于未知参数 $p$。正如问题所建议的，一种常见且直接应用正态近似的方法是在标准误项中用估计量 $\\hat{p}$ 代替 $p$。这给出了估计的标准误 $SE(\\hat{p})$：\n$$ SE(\\hat{p}) = \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} $$\n然后根据以下关系构造置信区间：\n$$ \\frac{\\hat{p} - p}{SE(\\hat{p})} > -z_{1-\\alpha} $$\n重新整理这个不等式以求解 $p$，得到上界：\n$$ \\hat{p} - p > -z_{1-\\alpha} \\times SE(\\hat{p}) $$\n$$ p  \\hat{p} + z_{1-\\alpha} \\times SE(\\hat{p}) $$\n因此，单边置信上界 $p_{upper}$ 由以下公式给出：\n$$ p_{upper} = \\hat{p} + z_{1-\\alpha} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} $$\n现在，我们将所提供的值代入此公式。\n-   样本量，$n = 1000$。\n-   丢包数，$x = 15$。\n-   置信水平，$1-\\alpha = 0.95$，这给出 $z_{0.95} \\approx 1.64485...$。我们将使用常用值 $z_{0.95} = 1.645$。\n\n首先，计算样本比例 $\\hat{p}$：\n$$ \\hat{p} = \\frac{15}{1000} = 0.015 $$\n接下来，计算上界 $p_{upper}$：\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{\\frac{0.015(1 - 0.015)}{1000}} $$\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{\\frac{0.015 \\times 0.985}{1000}} $$\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{\\frac{0.014775}{1000}} $$\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{0.000014775} $$\n$$ p_{upper} = 0.015 + 1.645 \\times 0.0038438262... $$\n$$ p_{upper} = 0.015 + 0.0063230941... $$\n$$ p_{upper} = 0.0213230941... $$\n问题要求答案四舍五入到四位有效数字。第一位有效数字是百分位上的 $2$。第四位有效数字是万分位上的第二个 $2$。其后的数字是 $3$，小于 $5$，因此我们向下舍入。\n$$ p_{upper} \\approx 0.02132 $$\n这个上界就是答案。作为推理过程的一部分，我们现在可以应用可追溯性规则。要求是 $p \\le 0.02$。由于我们在 $95\\%$ 置信水平下计算出的上界是 $p_{upper} \\approx 0.02132$，大于 $0.02$，因此我们得出结论，该系统在此置信水平下不满足指定的可靠性要求。这展示了将操作数据追溯回形式化要求的可追溯性。",
            "answer": "$$\\boxed{0.02132}$$"
        }
    ]
}