{
    "hands_on_practices": [
        {
            "introduction": "数字孪生的有效性取决于其准确感知物理组织状态的能力。本练习引入了控制理论中的基本概念——可观测性，它提供了一种严格的数学方法，用以判断一个系统的内部动态是否可以从其输出测量中完全推断出来。通过分析一个简化的组织模型的可观测性，您将学会评估一组选定的关键绩效指标（KPIs）是否足以进行全面监控，或者是否存在某些关键动态（如潜在风险）被隐藏。",
            "id": "4214840",
            "problem": "一个组织在某个工作点附近的数字孪生被建模为一个连续时间线性时不变状态空间系统，其状态向量为 $x \\in \\mathbb{R}^{4}$，其中 $x_{1}$ 表示订单积压偏差，$x_{2}$ 表示在制品吞吐量偏差，$x_{3}$ 表示资源容量不平衡，$x_{4}$ 表示潜在的合规风险倾向。输出向量 $y \\in \\mathbb{R}^{2}$ 收集了关键监测指标：一个滤波后的积压度量和一个综合合规事件信号。在工作点附近的线性化得到矩阵对 $(A,C)$:\n$$\nA \\;=\\; \\begin{bmatrix}\n-0.3  1  0  0 \\\\\n0  -0.5  1  0 \\\\\n0  0  -0.1  0 \\\\\n0  0  0  -0.2\n\\end{bmatrix}, \n\\qquad\nC \\;=\\; \\begin{bmatrix}\n1  0  0  0 \\\\\n0  1  1  0\n\\end{bmatrix}.\n$$\n从线性时不变系统的可观测性定义出发，并且不使用任何给定的快捷公式，确定与 $(A,C)$ 相关联的可观测性矩阵的秩，并解释该秩对数字孪生的监测设计意味着什么（例如，哪些潜在的组织动态可以或不可以从可用指标中推断出来）。将该秩作为你的最终数值答案。无需四舍五入，秩也不需要物理单位。",
            "solution": "该问题要求我们确定由状态空间表示 $(\\dot{x} = Ax, y = Cx)$ 描述的线性时不变（LTI）系统的可观测性，并在一个组织的数字孪生背景下解释研究结果。任务的核心是从可观测性的基本定义出发，计算系统的可观测性矩阵的秩。\n\n如果对于任何未知的初始状态 $x(0) = x_0$，存在一个有限时间 $t_f  0$，使得在区间 $[0, t_f]$ 内的输入 $u(t)$ 和输出 $y(t)$ 的知识足以唯一确定 $x_0$，则称该LTI系统是可观测的。对于一个没有输入的系统（$u(t)=0$），状态轨迹由 $x(t) = \\exp(At)x_0$ 给出，输出为 $y(t) = C x(t) = C \\exp(At) x_0$。\n\n一个状态 $x_0$ 是不可观测的，当且仅当对于该初始状态，输出在所有时间 $t \\ge 0$ 内恒为零。即，对于所有 $t \\ge 0$，有 $y(t) = C \\exp(At) x_0 = \\mathbf{0}$。为了从这个定义中推导出一个可检验的条件，我们可以对输出方程关于时间反复求导，并在 $t=0$ 处求值：\n$y(0) = C x_0 = \\mathbf{0}$\n$\\dot{y}(t) = \\frac{d}{dt}(C \\exp(At) x_0) = C A \\exp(At) x_0 \\implies \\dot{y}(0) = C A x_0 = \\mathbf{0}$\n$\\ddot{y}(t) = \\frac{d^2}{dt^2}(C \\exp(At) x_0) = C A^2 \\exp(At) x_0 \\implies \\ddot{y}(0) = C A^2 x_0 = \\mathbf{0}$\n...\n$y^{(k)}(t) = \\frac{d^k}{dt^k}(C \\exp(At) x_0) = C A^k \\exp(At) x_0 \\implies y^{(k)}(0) = C A^k x_0 = \\mathbf{0}$\n\n因此，一个初始状态 $x_0$ 是不可观测的，当且仅当对于所有非负整数 $k$，都有 $C A^k x_0 = \\mathbf{0}$。根据 Cayley-Hamilton 定理，对于 $k \\ge n$（其中 $n$ 是状态向量的维度），任何矩阵的幂 $A^k$ 都可以表示为幂 $\\{A^0, A^1, \\dots, A^{n-1}\\}$ 的线性组合。因此，该条件简化为仅检查前 $n$ 个这样的方程。这组线性方程可以写成矩阵形式：\n$$\n\\begin{bmatrix}\nC \\\\\nCA \\\\\nCA^2 \\\\\n\\vdots \\\\\nCA^{n-1}\n\\end{bmatrix}\nx_0 = \\mathbf{0}\n$$\n该方程中的矩阵是可观测性矩阵，记为 $\\mathcal{O}$。一个非零状态 $x_0$ 如果位于 $\\mathcal{O}$ 的零空间中，则是不可观测的。如果 $\\mathcal{O} x_0 = \\mathbf{0}$ 的唯一解是平凡解 $x_0 = \\mathbf{0}$，则系统是完全可观测的。这等价于可观测性矩阵 $\\mathcal{O}$ 具有满列秩的条件，即 $\\text{rank}(\\mathcal{O}) = n$。\n\n状态维度为 $n=4$。可观测性矩阵为 $\\mathcal{O} = \\begin{bmatrix} C \\\\ CA \\\\ CA^2 \\\\ CA^3 \\end{bmatrix}$。给定：\n$$\nA = \\begin{bmatrix}\n-0.3  1  0  0 \\\\\n0  -0.5  1  0 \\\\\n0  0  -0.1  0 \\\\\n0  0  0  -0.2\n\\end{bmatrix}, \n\\qquad\nC = \\begin{bmatrix}\n1  0  0  0 \\\\\n0  1  1  0\n\\end{bmatrix}\n$$\n$\\mathcal{O}$ 的行是 $C, CA, CA^2,$ 和 $CA^3$ 的行。\n首先，我们计算矩阵乘积：\n$C = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  1  0 \\end{bmatrix}$\n\n$CA = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  1  0 \\end{bmatrix} \\begin{bmatrix} -0.3  1  0  0 \\\\ 0  -0.5  1  0 \\\\ 0  0  -0.1  0 \\\\ 0  0  0  -0.2 \\end{bmatrix} = \\begin{bmatrix} -0.3  1  0  0 \\\\ 0  -0.5  0.9  0 \\end{bmatrix}$\n\n为了计算 $CA^2$，我们先计算 $A^2$：\n$A^2 = A \\cdot A = \\begin{bmatrix} -0.3  1  0  0 \\\\ 0  -0.5  1  0 \\\\ 0  0  -0.1  0 \\\\ 0  0  0  -0.2 \\end{bmatrix}^2 = \\begin{bmatrix} 0.09  -0.8  1  0 \\\\ 0  0.25  -0.6  0 \\\\ 0  0  0.01  0 \\\\ 0  0  0  0.04 \\end{bmatrix}$\n然后，$CA^2 = C \\cdot A^2 = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  1  0 \\end{bmatrix} \\begin{bmatrix} 0.09  -0.8  1  0 \\\\ 0  0.25  -0.6  0 \\\\ 0  0  0.01  0 \\\\ 0  0  0  0.04 \\end{bmatrix} = \\begin{bmatrix} 0.09  -0.8  1  0 \\\\ 0  0.25  -0.59  0 \\end{bmatrix}$\n\n为了计算 $CA^3$，我们先计算 $A^3$：\n$A^3 = A \\cdot A^2 = \\begin{bmatrix} -0.3  1  0  0 \\\\ 0  -0.5  1  0 \\\\ 0  0  -0.1  0 \\\\ 0  0  0  -0.2 \\end{bmatrix} \\begin{bmatrix} 0.09  -0.8  1  0 \\\\ 0  0.25  -0.6  0 \\\\ 0  0  0.01  0 \\\\ 0  0  0  0.04 \\end{bmatrix} = \\begin{bmatrix} -0.027  0.49  -0.9  0 \\\\ 0  -0.125  0.31  0 \\\\ 0  0  -0.001  0 \\\\ 0  0  0  -0.008 \\end{bmatrix}$\n然后，$CA^3 = C \\cdot A^3 = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  1  0 \\end{bmatrix} \\begin{bmatrix} -0.027  0.49  -0.9  0 \\\\ 0  -0.125  0.31  0 \\\\ 0  0  -0.001  0 \\\\ 0  0  0  -0.008 \\end{bmatrix} = \\begin{bmatrix} -0.027  0.49  -0.9  0 \\\\ 0  -0.125  0.309  0 \\end{bmatrix}$\n\n现在我们组装完整的可观测性矩阵 $\\mathcal{O}$：\n$$\n\\mathcal{O} = \\begin{bmatrix}\nC \\\\\nCA \\\\\nCA^2 \\\\\nCA^3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1  0  0  0 \\\\\n0  1  1  0 \\\\\n-0.3  1  0  0 \\\\\n0  -0.5  0.9  0 \\\\\n0.09  -0.8  1  0 \\\\\n0  0.25  -0.59  0 \\\\\n-0.027  0.49  -0.9  0 \\\\\n0  -0.125  0.309  0\n\\end{bmatrix}\n$$\n为了确定这个 $8 \\times 4$ 矩阵的秩，我们分析它的列。第四列完全由零组成。这立即意味着这些列不是线性无关的。具体来说，对于任何非零标量 $\\alpha$，向量 $v = [0, 0, 0, \\alpha]^T$ 都将满足 $\\mathcal{O}v = \\mathbf{0}$。这意味着 $\\mathcal{O}$ 的零空间的维度至少为 $1$，因此 $\\mathcal{O}$ 的秩最多为 $4-1=3$。\n\n为了确定秩是否恰好为 $3$，我们必须检查前三列是否线性无关。我们可以通过找到一个行列式不为零的 $3 \\times 3$ 子矩阵来做到这一点。让我们使用 $\\mathcal{O}$ 的前三行和前三列构成一个子矩阵：\n$$\n M = \\begin{bmatrix}\n1  0  0 \\\\\n0  1  1 \\\\\n-0.3  1  0\n\\end{bmatrix}\n$$\n该子矩阵的行列式为：\n$$\n\\det(M) = 1 \\cdot \\det\\begin{pmatrix} 1  1 \\\\ 1  0 \\end{pmatrix} - 0 + 0 = 1 \\cdot (1 \\cdot 0 - 1 \\cdot 1) = -1\n$$\n由于 $\\det(M) \\neq 0$，$\\mathcal{O}$ 的前三列是线性无关的。因此，可观测性矩阵 $\\mathcal{O}$ 的秩恰好为 $3$。\n\n解释：\n可观测性矩阵的秩为 $3$，小于状态维度 $n=4$。差值 $n - \\text{rank}(\\mathcal{O}) = 4 - 3 = 1$ 表明存在一个一维的不可观测子空间。此子空间内的任何状态向量都无法从输出测量中确定。\n\n如计算所示，$\\mathcal{O}$ 的零空间由向量 $[0, 0, 0, 1]^T$ 张成。该向量对应于第四个状态变量 $x_4$，即“潜在的合规风险倾向”。这意味着 $x_4$ 的动态与输出 $y$ 完全解耦。$x_4$ 的初始值或任何后续变化对测量的“滤波后的积压度量”和“综合合规事件信号”没有影响。\n\n在数字孪生监测设计的背景下，这一结果意味着一个关键缺陷：当前的关键监测指标集不足以跟踪或推断组织的潜在合规风险。与积压（$x_1$）、吞吐量（$x_2$）和资源不平衡（$x_3$）相关的动态可以从输出数据中完全重构（因为它们在 $\\mathcal{O}$ 中对应的列是线性无关的）。然而，合规风险倾向（$x_4$）仍然是隐藏的。为了使这个状态可观测，监测策略必须增加新的、明确或隐含地依赖于 $x_4$ 的指标。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "组织数字孪生不仅是理论模型，更是一个具有实际性能约束的复杂软件系统。本练习使用离散事件模拟——运筹学中的一项核心技术——来建模和分析数字孪生的计算流水线。通过实施和比较不同的并行化策略，您将获得量化它们对系统吞吐量和延迟影响的实践经验，这对于设计响应迅速且可扩展的数字孪生系统至关重要。",
            "id": "4214864",
            "problem": "一个组织部署了一个组织数字孪生（DTO），该孪生持续运行内部模拟任务和下游分析任务。模拟任务创建状态更新，供分析任务使用。目标是为这个包含模拟阶段和分析阶段的两阶段处理流水线设计和评估并行化策略。评估必须使用程序化的、可复现的实验，在科学合理的假设和约束下，量化吞吐量和端到端延迟。\n\nDTO流水线建模的基本基础如下：\n- 到达过程为泊松过程，其中到达间隔时间是独立的，且服从速率参数为 $\\lambda$ 到达/秒的指数分布。\n- 服务时间为指数分布，具有指定的均值，与先到先服务（FCFS）排队和独立服务器一致。\n- 利特尔法则（Little's Law），表述为 $L = \\lambda W$，关联了系统中的稳态平均数量 $L$、到达率 $\\lambda$ 和系统中的平均时间 $W$。即使我们通过模拟而非闭式解进行计算，该法则在概念上仍支撑着吞吐量和延迟之间的关系。\n\n流水线包括两个阶段：\n- 阶段 $1$（模拟）：每个到达的作业的服务时间服从均值为 $s_{\\text{sim}}$ 秒的指数分布。阶段 $1$ 有 $c_1$ 个相同的并行服务器。\n- 阶段 $2$（分析）：每个作业的核心服务时间服从均值为 $s_{\\text{ana,core}}$ 秒的指数分布，并有 $o$ 秒的单项开销，除非使用微批处理。阶段 $2$ 有 $c_2$ 个相同的并行服务器，除非微批处理另有规定。\n\n要评估的四种并行化策略定义如下：\n- 策略 $0$（基线，每阶段串行）：$c_1 = 1$, $c_2 = 1$，FCFS，无批处理。每个分析作业耗时 $o + X$，其中 $X \\sim \\text{Exp}(\\text{mean}=s_{\\text{ana,core}})$。\n- 策略 $1$（分析数据并行）：$c_1 = 1$, $c_2 = k$，阶段 $2$ 采用 FCFS，无批处理。每个分析作业耗时 $o + X$，与上述 $X$ 分布相同。\n- 策略 $2$（两阶段数据并行）：$c_1 = m$, $c_2 = k$，每个阶段采用 FCFS，无批处理。每个分析作业耗时 $o + X$，与上述 $X$ 分布相同。\n- 策略 $3$（分析微批处理）：$c_1 = 1$, $c_2 = 1$，阶段 $2$ 根据 FCFS 将作业分批处理，每批最多 $b$ 个，在服务器可用时进行贪婪批次形成。每批的服务时间为 $o + \\sum_{i=1}^{n_b} X_i$，其中 $n_b \\leq b$ 是批次开始时可用项目的数量，而 $X_i \\sim \\text{Exp}(\\text{mean}=s_{\\text{ana,core}})$ 是独立的。批次中的所有项目在批次完成时间一同完成。\n\n调度规则：\n- 在每个阶段，调度均为 FCFS。对于有 $c$ 个并行服务器的阶段，每个到达的作业被分配给最早可用的服务器；作业的服务在其到达时间和该服务器可用时间的最大值时开始。这是独立服务时间下的经典多服务器 FCFS 规则。\n\n性能指标：\n- 吞吐量定义为完成的作业总数除以从第一个作业到达阶段 $1$ 到最后一个作业在阶段 $2$ 完成所经过的时间，单位为作业/秒。\n- 每个作业的端到端延迟定义为在阶段 $2$ 的完成时间减去其在阶段 $1$ 的初始到达时间，单位为秒。我们报告所有作业的平均值。\n\n建模约束：\n- 到达阶段 $1$ 的间隔时间是独立的，且服从均值为 $1/\\lambda$ 秒的指数分布。\n- 每个作业在阶段 $1$ 的服务时间是独立的，且服从均值为 $s_{\\text{sim}}$ 秒的指数分布。\n- 每个作业在阶段 $2$ 的核心服务时间是独立的，且服从均值为 $s_{\\text{ana,core}}$ 秒的指数分布。对于无微批处理的策略，单项开销 $o$ 对每个作业应用一次；对于策略3，对每个批次应用一次。\n\n您的程序必须：\n- 为每个策略和测试用例实现一个遵循上述假设的离散事件模拟。\n- 在一个测试用例中，跨策略使用相同的随机抽样，以隔离并行化策略的效果。具体来说，在给定的测试用例中，为所有策略预先生成并重用阶段 $1$ 服务时间、阶段 $2$ 核心服务时间以及到达间隔时间的序列。\n- 对于分析微批处理，在单个分析服务器可用时，贪婪地形成批次：包括在该时间点之前已经到达阶段 $2$ 的最多 $b$ 个作业；不要为了等待未来到达的作业填满批次而延迟服务器，超出当前可用的作业。\n- 以作业/秒表示吞吐量，以秒表示延迟。\n\n带参数集的测试套件：\n- 用例 1：$N=500$，$\\lambda=5$， $s_{\\text{sim}}=0.1$， $s_{\\text{ana,core}}=0.15$， $o=0.02$， $k=4$， $m=2$， $b=8$，随机种子 $42$。\n- 用例 2：$N=1000$，$\\lambda=20$， $s_{\\text{sim}}=0.08$， $s_{\\text{ana,core}}=0.12$， $o=0.04$， $k=6$， $m=4$， $b=16$，随机种子 $43$。\n- 用例 3：$N=400$，$\\lambda=8$， $s_{\\text{sim}}=0.05$， $s_{\\text{ana,core}}=0.3$， $o=0.1$， $k=8$， $m=2$， $b=32$，随机种子 $44$。\n- 用例 4：$N=200$，$\\lambda=1$， $s_{\\text{sim}}=0.2$， $s_{\\text{ana,core}}=0.2$， $o=0.02$， $k=4$， $m=2$, $b=8$，随机种子 $45$。\n\n输出规范：\n- 对于每个用例（按升序 $1,2,3,4$）和每个策略 $s \\in \\{0,1,2,3\\}$（按升序），计算两个浮点数：吞吐量和平均延迟。\n- 将结果汇总为单行输出，包含一个用方括号括起来的逗号分隔列表。\n- 列表排序必须是：对于用例 1，($\\text{throughput}_0,\\text{latency}_0,\\text{throughput}_1,\\text{latency}_1,\\text{throughput}_2,\\text{latency}_2,\\text{throughput}_3,\\text{latency}_3$)，然后是用例 2，模式相同，接着是用例 3，再接着是用例 4。\n\n单位：\n- 报告吞吐量单位为作业/秒，延迟单位为秒。\n\n角度单位：\n- 不使用角度；此项不适用。\n\n百分比：\n- 不使用百分比；此项不适用。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$）。",
            "solution": "用户提供了一个问题，要求设计并实现一个离散事件模拟，以评估一个两阶段处理流水线的四种不同并行化策略。该问题根植于排队论，定义明确、科学合理且可通过计算验证。\n\n### 第1步：提取已知条件\n\n问题提供了以下数据、定义和约束：\n- **到达过程**：速率为 $\\lambda$ 到达/秒的泊松过程。到达间隔时间是独立的，且服从均值为 $1/\\lambda$ 的指数分布。\n- **调度规则**：每个阶段均为先到先服务（FCFS）。对于多服务器阶段，到达的作业被分配给最早可用的服务器。\n- **阶段1（模拟）**：$c_1$ 个相同的并行服务器。服务时间是独立的，且服从均值为 $s_{\\text{sim}}$ 秒的指数分布。\n- **阶段2（分析）**：$c_2$ 个相同的并行服务器。核心服务时间是独立的，且服从均值为 $s_{\\text{ana,core}}$ 秒的指数分布。存在单项或单批次的开销 $o$ 秒。\n- **策略0（基线）**：$c_1 = 1$，$c_2 = 1$。无批处理。阶段2每个作业的服务时间为 $o + X$，其中 $X \\sim \\text{Exp}(\\text{mean}=s_{\\text{ana,core}})$。\n- **策略1（分析数据并行）**：$c_1 = 1$，$c_2 = k$。无批处理。阶段2服务时间与策略0相同。\n- **策略2（两阶段数据并行）**：$c_1 = m$，$c_2 = k$。无批处理。阶段2服务时间与策略0相同。\n- **策略3（分析微批处理）**：$c_1 = 1$，$c_2 = 1$。阶段2以最大为 $b$ 的批量大小处理作业。每批的服务时间为 $o + \\sum_{i=1}^{n_b} X_i$，其中 $n_b \\leq b$ 是批次大小，$X_i$ 是独立的 Exp($s_{\\text{ana,core}}$) 变量。当服务器可用时，贪婪地形成批次。\n- **性能指标**：\n    - **吞吐量**：完成的作业总数 / (最后完成时间 - 首次到达时间)。\n    - **平均端到端延迟**：所有作业的（阶段2完成时间 - 阶段1到达时间）的平均值。\n- **模拟约束**：对于每个测试用例，在所有四种策略中必须使用相同的到达间隔时间、阶段1服务时间和阶段2核心服务时间的随机抽样序列。\n- **测试用例**：\n    - 用例1：$N=500$，$\\lambda=5$， $s_{\\text{sim}}=0.1$， $s_{\\text{ana,core}}=0.15$， $o=0.02$， $k=4$， $m=2$， $b=8$，种子=42。\n    - 用例2：$N=1000$，$\\lambda=20$， $s_{\\text{sim}}=0.08$， $s_{\\text{ana,core}}=0.12$， $o=0.04$， $k=6$， $m=4$， $b=16$，种子=43。\n    - 用例3：$N=400$，$\\lambda=8$， $s_{\\text{sim}}=0.05$， $s_{\\text{ana,core}}=0.3$， $o=0.1$， $k=8$， $m=2$， $b=32$，种子=44。\n    - 用例4：$N=200$，$\\lambda=1$， $s_{\\text{sim}}=0.2$， $s_{\\text{ana,core}}=0.2$， $o=0.02$， $k=4$， $m=2$， $b=8$，种子=45。\n- **输出格式**：单行包含一个用方括号括起来的浮点数逗号分隔列表（每个策略和每个用例的吞吐量、延迟）。\n\n### 第2步：使用提取的已知条件进行验证\n\n对问题进行严格验证。\n- **科学依据**：该问题基于排队论（$M/M/c$ 队列、泊松过程、指数分布）和离散事件模拟的基本概念，这些概念在运筹学、计算机科学和工程学中是标准且成熟的。使用利特尔法则作为概念基础是恰当的。该模型具有科学合理性。\n- **适定性**：该问题是适定的。它要求为明确定义的系统配置计算特定的性能指标。所有必要的参数都已提供，并且使用随机种子确保了模拟是确定性和可复现的，从而得到唯一的解。由于处理固定数量的作业 $N$，模拟保证会终止。\n- **客观性**：问题使用精确的数学和算法语言陈述。所有策略、指标和假设都得到了客观且无歧义的定义。\n- **完整性与一致性**：问题陈述是自包含的，并提供了所有必要的数据（$N$、$\\lambda$、服务时间均值、开销、服务器数量、批次大小和随机种子）。诸如重用随机变量之类的约束，与比较系统的合理实验设计相符。没有矛盾之处。\n- **不切实际或不可行**：参数对于建模计算任务是物理上合理的。该模型是一种简化，但并非不切实际或不可能。\n- **不适定或结构不良**：问题结构良好，引导用户实现离散事件模拟。在给定固定随机种子的情况下，解是唯一且稳定的。\n- **伪深刻或琐碎**：为四种不同的排队配置实现离散事件模拟，特别是微批处理策略，是一项非凡的编程和建模任务。这是一个实质性的问题。\n- **超出科学可验证范围**：通过使用给定的参数和种子实现指定的模拟，结果是可验证的。\n\n### 第3步：结论与行动\n\n问题陈述是**有效的**。这是一个定义明确、有科学依据的模拟建模问题。我现在将着手提供一个完整的解决方案。\n\n### 基于原则的解决方案设计\n\n解决方案将是一个用Python实现的离散事件模拟模型。核心原则是跟踪 $N$ 个作业中每一个通过两阶段流水线的进程，根据指定策略的规则计算它们在每个阶段的到达和完成时间戳。\n\n**1. 随机变量生成：**\n为了确保按要求在策略之间进行公平比较，我们首先为给定的测试用例预先生成所有随机数。使用指定的种子初始化一个 `NumPy` 随机数生成器。我们为以下项生成 $N$ 个值：\n- 阶段1的到达间隔时间，来自均值为 $1/\\lambda$ 的指数分布。\n- 阶段1的服务时间，来自均值为 $s_{\\text{sim}}$ 的指数分布。\n- 阶段2的核心服务时间，来自均值为 $s_{\\text{ana,core}}$ 的指数分布。\n这三组随机变量数组将在一个测试用例中的所有四种策略中重用。\n\n**2. 多服务器阶段的模拟（类M/M/c队列）：**\n该逻辑对阶段1以及策略0、1和2的阶段2是通用的。一个有 $c$ 个服务器的阶段通过维护每个服务器变为可用的时间来建模。最小堆是实现此目的的理想数据结构，允许以 $O(1)$ 的时间复杂度访问最早可用的服务器时间。对于在时间 $t_{\\text{arrival}}$ 到达阶段的每个作业：\n- 找到最早可用的服务器，其可用时间为 $t_{\\text{server\\_avail}}$。\n- 作业的服务在 $t_{\\text{start}} = \\max(t_{\\text{arrival}}, t_{\\text{server\\_avail}})$ 开始。\n- 作业的服务在 $t_{\\text{complete}} = t_{\\text{start}} + t_{\\text{service}}$ 完成。\n- 服务器的可用时间更新为 $t_{\\text{complete}}$。\n\n**3. 阶段1的模拟：**\n我们首先通过对预先生成的到达间隔时间进行累积求和，来计算所有 $N$ 个作业在阶段1的绝对到达时间。然后，使用上述具有 $c_1$ 个服务器的多服务器逻辑，我们计算每个作业从阶段1完成的时间。这些完成时间成为阶段2的到达时间。\n\n**4. 阶段2的模拟：**\n作业必须按照它们从阶段1到达的顺序在阶段2进行处理。因此，在模拟阶段2之前，我们根据作业在阶段1的完成时间对它们进行排序。每个作业都携带其预先生成的阶段2核心服务时间及其原始的阶段1到达时间（以计算端到端延迟）。\n\n- **策略0、1、2（非批处理）：** 我们应用相同的多服务器模拟逻辑。服务器数量为 $c_2$。每个作业的服务时间是其预先生成的核心服务时间加上开销 $o$。\n\n- **策略3（微批处理）：** 这需要为其单个服务器（$c_2=1$）设置特殊逻辑。我们维护服务器的可用时间。模拟按步骤进行，由服务器变为可用驱动。\n    - 当服务器在时间 $t_{\\text{current}}$ 可用时，它会从其队列中等待的所有作业（即在 $t_{\\text{current}}$ 之前已完成阶段1的作业）中贪婪地形成一个批次。批次大小上限为 $b$。\n    - 如果服务器可用但队列为空，则时间快进到下一个作业从阶段1到达的时间。该作业随后形成一个大小为1的批次。\n    - 批次的总服务时间是单个开销 $o$ 加上批次中所有作业的核心服务时间之和。\n    - 批次中的所有作业共享相同的完成时间：$t_{\\text{batch\\_complete}} = t_{\\text{current}} + t_{\\text{batch\\_service}}$。\n    - 服务器的下一次可用时间更新为 $t_{\\text{batch\\_complete}}$。\n\n**5. 指标计算：**\n在模拟完所有 $N$ 个作业通过两个阶段后，我们得到了每个作业的初始到达时间和最终完成时间。\n- **端到端延迟**：对于每个作业，这是其最终完成时间减去其初始到达时间。计算这些值的平均值。\n- **吞吐量**：这是 $N$ 除以总模拟时长，即最后一个作业的完成时间减去第一个作业的到达时间。\n\n通过将此逻辑封装到函数中，我们可以系统地为每个测试用例和每个策略运行模拟，收集结果以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom collections import deque\n\ndef simulate_stage1(c1, s1_arrival_times, s1_service_times):\n    \"\"\"Simulates a multi-server stage 1 and returns job completion times.\"\"\"\n    num_jobs = len(s1_arrival_times)\n    s1_completion_times = np.zeros(num_jobs)\n    server_availability = [0.0] * c1\n    heapq.heapify(server_availability)\n\n    for i in range(num_jobs):\n        arrival_time = s1_arrival_times[i]\n        service_time = s1_service_times[i]\n        \n        earliest_server_avail = heapq.heappop(server_availability)\n        start_time = max(arrival_time, earliest_server_avail)\n        completion_time = start_time + service_time\n        \n        s1_completion_times[i] = completion_time\n        heapq.heappush(server_availability, completion_time)\n        \n    return s1_completion_times\n\ndef simulate_stage2_non_batching(c2, o, jobs_for_s2):\n    \"\"\"Simulates a non-batching multi-server stage 2.\"\"\"\n    server_availability = [0.0] * c2\n    heapq.heapify(server_availability)\n    completion_times_dict = {}\n\n    for s2_arrival_time, s2_core_service_time, s1_initial_arrival_time in jobs_for_s2:\n        service_time = o + s2_core_service_time\n        \n        earliest_server_avail = heapq.heappop(server_availability)\n        start_time = max(s2_arrival_time, earliest_server_avail)\n        completion_time = start_time + service_time\n        \n        completion_times_dict[s1_initial_arrival_time] = completion_time\n        heapq.heappush(server_availability, completion_time)\n        \n    return completion_times_dict\n\ndef simulate_stage2_batching(b, o, jobs_for_s2):\n    \"\"\"Simulates a single-server batching stage 2.\"\"\"\n    num_jobs = len(jobs_for_s2)\n    s2_queue = deque()\n    job_idx = 0\n    server_avail_time = 0.0\n    completion_times_dict = {}\n    processed_count = 0\n\n    while processed_count  num_jobs:\n        # If server is idle and no jobs are waiting, fast-forward to the next arrival.\n        if not s2_queue and server_avail_time  jobs_for_s2[job_idx][0]:\n            current_time = jobs_for_s2[job_idx][0]\n        else:\n            current_time = server_avail_time\n\n        # Add all jobs that have arrived by current_time to the queue.\n        while job_idx  num_jobs and jobs_for_s2[job_idx][0] = current_time:\n            s2_queue.append(jobs_for_s2[job_idx])\n            job_idx += 1\n        \n        # Form a batch from the available jobs in the queue.\n        batch_size = min(len(s2_queue), b)\n        if batch_size == 0:\n            # Should not happen if loop logic is correct, but as a safeguard.\n            if job_idx  num_jobs:\n                current_time = jobs_for_s2[job_idx][0]\n                continue\n            else:\n                break\n        \n        batch = [s2_queue.popleft() for _ in range(batch_size)]\n        \n        # Calculate batch service and completion time.\n        batch_core_service = sum(job[1] for job in batch)\n        batch_total_service = o + batch_core_service\n        batch_completion_time = current_time + batch_total_service\n        \n        server_avail_time = batch_completion_time\n\n        for job in batch:\n            s1_initial_arrival_time = job[2]\n            completion_times_dict[s1_initial_arrival_time] = batch_completion_time\n        \n        processed_count += batch_size\n        \n    return completion_times_dict\n\ndef run_simulation(params, strategy_params, random_variates):\n    \"\"\"Runs a single simulation for a given strategy.\"\"\"\n    N, o = params['N'], params['o']\n    c1, c2, b, is_batching = strategy_params\n    s1_arrival_times, s1_service_times, s2_core_service_times = random_variates\n\n    s1_completion_times = simulate_stage1(c1, s1_arrival_times, s1_service_times)\n    \n    # Jobs must be processed by stage 2 in their arrival order to that stage.\n    jobs_for_s2 = sorted(zip(s1_completion_times, s2_core_service_times, s1_arrival_times))\n\n    if is_batching:\n        s2_completion_dict = simulate_stage2_batching(b, o, jobs_for_s2)\n    else:\n        s2_completion_dict = simulate_stage2_non_batching(c2, o, jobs_for_s2)\n\n    s2_final_completions = np.array([s2_completion_dict[t] for t in s1_arrival_times])\n\n    first_arrival = s1_arrival_times[0]\n    last_completion = np.max(s2_final_completions)\n    total_time = last_completion - first_arrival\n    \n    throughput = N / total_time if total_time  0 else 0.0\n    \n    latencies = s2_final_completions - s1_arrival_times\n    mean_latency = np.mean(latencies)\n    \n    return throughput, mean_latency\n\n\ndef solve():\n    test_cases = [\n        {'N': 500, 'lambda': 5, 's_sim': 0.1, 's_ana_core': 0.15, 'o': 0.02, 'k': 4, 'm': 2, 'b': 8, 'seed': 42},\n        {'N': 1000, 'lambda': 20, 's_sim': 0.08, 's_ana_core': 0.12, 'o': 0.04, 'k': 6, 'm': 4, 'b': 16, 'seed': 43},\n        {'N': 400, 'lambda': 8, 's_sim': 0.05, 's_ana_core': 0.3, 'o': 0.1, 'k': 8, 'm': 2, 'b': 32, 'seed': 44},\n        {'N': 200, 'lambda': 1, 's_sim': 0.2, 's_ana_core': 0.2, 'o': 0.02, 'k': 4, 'm': 2, 'b': 8, 'seed': 45},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, lambda_, s_sim, s_ana_core = case['N'], case['lambda'], case['s_sim'], case['s_ana_core']\n        k, m, b, seed = case['k'], case['m'], case['b'], case['seed']\n        \n        # Pre-generate random variates for the test case\n        rng = np.random.default_rng(seed)\n        # Add a small value to inter-arrival times to avoid zero, which cumsum handles poorly for unique keys.\n        inter_arrival_times = rng.exponential(1.0 / lambda_, N) + 1e-12 \n        s1_service_times = rng.exponential(s_sim, N)\n        s2_core_service_times = rng.exponential(s_ana_core, N)\n        s1_arrival_times = np.cumsum(inter_arrival_times)\n        \n        random_variates = (s1_arrival_times, s1_service_times, s2_core_service_times)\n        \n        strategies = {\n            0: (1, 1, b, False),       # c1, c2, b, is_batching\n            1: (1, k, b, False),\n            2: (m, k, b, False),\n            3: (1, 1, b, True)\n        }\n        \n        case_results = []\n        for i in range(4):\n            strategy_params = strategies[i]\n            throughput, mean_latency = run_simulation(case, strategy_params, random_variates)\n            case_results.extend([throughput, mean_latency])\n        \n        all_results.extend(case_results)\n\n    # Format output as a comma-separated list of floats inside brackets\n    print(f\"[{','.join(f'{x:.6f}' for x in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "组织数字孪生的一个关键应用是在不确定性下指导最优决策。本练习将演示如何使用马尔可夫决策过程（MDP）——一种源于强化学习的强大框架——来形式化一个序贯决策问题。您将通过实现价值迭代算法来计算管理组织资源的最优策略，从而具体了解数字孪生如何将描述性洞察转化为规定性的、由数据驱动的行动。",
            "id": "4214863",
            "problem": "组织的数字孪生在不确定性下对粗粒度的积压工作状态进行决策建模。考虑一个具有折扣无限期回报的有限马尔可夫决策过程（MDP），其状态空间为 $S=\\{0,1,2\\}$，分别代表组织的积压工作水平：$0$（低）、$1$（中）和 $2$（高）。动作空间为 $A=\\{0,1,2\\}$，分别代表 $0$（分配资源以减少积压工作）、$1$（保持稳定）和 $2$（将资源转向创新）。即时奖励由 $R(s,a)=r_a + p_s$ 定义，其中 $r_a$ 是依赖于动作的即时奖励，而 $p_s$ 是依赖于积压工作的惩罚。假设 $r_0=-1$，$r_1=0$，$r_2=2$，以及 $p_0=0$，$p_1=-2$，$p_2=-5$。\n\n转移由两个核之一指定，$\\mathsf{P}^{(1)}$ 和 $\\mathsf{P}^{(2)}$，两者都将 $S \\times A$ 映射到 $S$ 上的分布。对于 $\\mathsf{P}^{(1)}$（随机运营动态）：\n- 对于动作 0（分配资源以减少积压工作）：\n  - 从 $s=0$ 出发：以概率 $0.7$ 转移到 $s'=0$，以概率 $0.3$ 转移到 $s'=1$，以概率 $0.0$ 转移到 $s'=2$。\n  - 从 $s=1$ 出发：以概率 $0.6$ 转移到 $s'=0$，以概率 $0.3$ 转移到 $s'=1$，以概率 $0.1$ 转移到 $s'=2$。\n  - 从 $s=2$ 出发：以概率 $0.0$ 转移到 $s'=0$，以概率 $0.6$ 转移到 $s'=1$，以概率 $0.4$ 转移到 $s'=2$。\n- 对于动作 1（保持稳定）：\n  - 从 $s=0$ 出发：以概率 $0.5$ 转移到 $s'=0$，以概率 $0.5$ 转移到 $s'=1$，以概率 $0.0$ 转移到 $s'=2$。\n  - 从 $s=1$ 出发：以概率 $0.0$ 转移到 $s'=0$，以概率 $0.6$ 转移到 $s'=1$，以概率 $0.4$ 转移到 $s'=2$。\n  - 从 $s=2$ 出发：以概率 $0.0$ 转移到 $s'=0$，以概率 $0.2$ 转移到 $s'=1$，以概率 $0.8$ 转移到 $s'=2$。\n- 对于动作 2（将资源转向创新）：\n  - 从 $s=0$ 出发：以概率 $0.3$ 转移到 $s'=0$，以概率 $0.7$ 转移到 $s'=1$，以概率 $0.0$ 转移到 $s'=2$。\n  - 从 $s=1$ 出发：以概率 $0.0$ 转移到 $s'=0$，以概率 $0.3$ 转移到 $s'=1$，以概率 $0.7$ 转移到 $s'=2$。\n  - 从 $s=2$ 出发：以概率 $0.0$ 转移到 $s'=0$，以概率 $0.1$ 转移到 $s'=1$，以概率 $0.9$ 转移到 $s'=2$。\n\n对于 $\\mathsf{P}^{(2)}$（确定性策略效应）：\n- 对于动作 0（分配资源以减少积压工作）：从 $s=0$ 以概率 $1.0$ 转移到 $s'=0$，从 $s=1$ 以概率 $1.0$ 转移到 $s'=0$，从 $s=2$ 以概率 $1.0$ 转移到 $s'=1$。\n- 对于动作 1（保持稳定）：从 $s=0$ 以概率 $1.0$ 转移到 $s'=0$，从 $s=1$ 以概率 $1.0$ 转移到 $s'=1$，从 $s=2$ 以概率 $1.0$ 转移到 $s'=2$。\n- 对于动作 2（将资源转向创新）：从 $s=0$ 以概率 $1.0$ 转移到 $s'=1$，从 $s=1$ 以概率 $1.0$ 转移到 $s'=2$，从 $s=2$ 以概率 $1.0$ 转移到 $s'=2$。\n\n在折扣因子 $\\gamma \\in [0,1)$ 的条件下，通过值迭代计算一个最优策略，使用的决策规则是：最大化过程中的平局必须通过选择最小的动作索引来打破。设状态值上确界范数中的停止阈值为 $\\varepsilon0$，最大迭代次数上限为 $N_{\\max} \\in \\mathbb{N}$。如果 $\\gamma \\ge 1$，检测到非压缩情况，则不运行值迭代，而是输出在每个状态下独立最大化 $R(s,a)$ 的短视策略，将迭代次数设置为 $0$，并将收敛标志设置为布尔值 false。如果 $\\gamma \\in [0,1)$ 但算法在 $N_{\\max}$ 次迭代内未达到停止阈值，则输出相对于最后一次迭代结果的贪心策略、实际执行的迭代次数，以及一个布尔值为 false 的收敛标志。\n\n您的程序必须实现上述逻辑，并评估以下参数值测试套件，每个测试用例指定为 $(\\text{核}, \\gamma, \\varepsilon, N_{\\max})$：\n- 情况 $1$：$\\left(\\mathsf{P}^{(1)},\\, 0.9,\\, 10^{-8},\\, 10000\\right)$。\n- 情况 $2$：$\\left(\\mathsf{P}^{(1)},\\, 0.999,\\, 10^{-12},\\, 20000\\right)$。\n- 情况 $3$：$\\left(\\mathsf{P}^{(1)},\\, 0.0,\\, 10^{-8},\\, 10000\\right)$。\n- 情况 $4$：$\\left(\\mathsf{P}^{(2)},\\, 0.95,\\, 10^{-8},\\, 10000\\right)$。\n- 情况 $5$：$\\left(\\mathsf{P}^{(1)},\\, 1.0,\\, 10^{-8},\\, 10000\\right)$。\n\n对于每种情况，生成一个结果列表 $\\left[a_0,a_1,a_2,n,c\\right]$，其中 $a_0,a_1,a_2 \\in \\{0,1,2\\}$ 是为状态 $s=0,1,2$ 选择的动作，$n \\in \\mathbb{N}$ 是您的程序实际执行的迭代次数（在 $\\gamma \\ge 1$ 的短视情况下 $n=0$），$c \\in \\{\\text{True},\\text{False}\\}$ 表示您的程序是否根据停止准则声明收敛。\n\n最终输出格式规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应各情况的结果列表，例如 $\\left[\\left[a_0,a_1,a_2,n,c\\right],\\left[\\cdots\\right],\\ldots\\right]$。",
            "solution": "经过彻底的验证过程，用户提供的问题被评估为**有效**。该问题描述了一组标准的有限状态马尔可夫决策过程（MDP），并要求使用成熟的值迭代算法计算最优策略。问题陈述是自包含的，科学上基于随机最优控制理论，并且在数学上是适定的。所有参数，包括状态和动作空间、奖励函数、转移核、折扣因子和停止准则，都得到了精确定义。问题还为处理特殊情况指定了明确的程序，例如非压缩性的折扣因子（$\\gamma \\ge 1$）和在给定迭代限制内不收敛的情况，从而确保所有指定的测试用例都有唯一且明确定义的输出。\n\n解决方案的步骤如下：\n\n首先，我们形式化 MDP 的组成部分。状态空间为 $S=\\{0, 1, 2\\}$，动作空间为 $A=\\{0, 1, 2\\}$，折扣因子为 $\\gamma$。在状态 $s$ 下采取动作 $a$ 的即时奖励由 $R(s, a) = r_a + p_s$ 给出。我们可以将其预先计算成一个 $3 \\times 3$ 的奖励矩阵 $\\mathbf{R}$：\n$$\n\\mathbf{R}_{s,a} = \\begin{pmatrix} r_0+p_0  r_1+p_0  r_2+p_0 \\\\ r_0+p_1  r_1+p_1  r_2+p_1 \\\\ r_0+p_2  r_1+p_2  r_2+p_2 \\end{pmatrix} = \\begin{pmatrix} -1+0  0+0  2+0 \\\\ -1-2  0-2  2-2 \\\\ -1-5  0-5  2-5 \\end{pmatrix} = \\begin{pmatrix} -1  0  2 \\\\ -3  -2  0 \\\\ -6  -5  -3 \\end{pmatrix}\n$$\n转移动态由概率核 $\\mathsf{P}(s'|s,a)$ 给出，我们将其表示为一个 $3 \\times 3 \\times 3$ 的张量 $\\mathbf{P}$，其中 $\\mathbf{P}_{s,a,s'} = \\mathsf{P}(s'|s,a)$。根据问题描述，构建了两个这样的张量 $\\mathbf{P}^{(1)}$ 和 $\\mathbf{P}^{(2)}$。\n\n解决方案的核心是值迭代算法，该算法用于寻找无限期折扣 MDP 的最优值函数 $V^*(s)$。值函数表示从状态 $s$ 开始的最大期望累积折扣奖励。值迭代基于 Bellman 最优性方程：\n$$\nV^*(s) = \\max_{a \\in A} \\left( R(s, a) + \\gamma \\sum_{s' \\in S} \\mathsf{P}(s'|s,a) V^*(s') \\right)\n$$\n该算法从一个初始猜测 $V_0(s)$（例如，对所有 $s$，$V_0(s)=0$）开始，迭代地改进值函数的估计。第 $k+1$ 次迭代的更新规则是：\n$$\nV_{k+1}(s) = \\max_{a \\in A} \\left( R(s, a) + \\gamma \\sum_{s' \\in S} \\mathsf{P}(s'|s,a) V_k(s') \\right)\n$$\n这可以通过定义状态-动作值函数（或 Q 函数）$Q_k(s, a) = R(s, a) + \\gamma \\sum_{s' \\in S} \\mathsf{P}(s'|s,a) V_k(s')$ 来更紧凑地表示。然后，更新变为 $V_{k+1}(s) = \\max_{a \\in A} Q_k(s, a)$。\n\n迭代持续进行，直到值函数收敛。收敛的判断标准是检查连续值函数迭代之间差值的上确界范数是否低于给定阈值 $\\varepsilon$：\n$$\n\\max_{s \\in S} |V_{k+1}(s) - V_k(s)|  \\varepsilon\n$$\n对于 $\\gamma \\in [0,1)$，此条件保证能够满足，因为 Bellman 算子是一个模为 $\\gamma$ 的压缩映射。\n\n如果算法被提供一个折扣因子 $\\gamma \\ge 1$，Bellman 算子不再是压缩映射，值迭代可能不会收敛。按照规定，在这种情况下，我们不运行迭代。而是为每个状态计算一个短视策略 $\\pi(s) = \\arg\\max_a R(s,a)$，将迭代次数设置为 0，并报告未达到收敛。\n\n如果对于 $\\gamma \\in [0,1)$ 的算法在最大迭代次数 $N_{\\max}$ 内未能收敛，则终止。最终策略是相对于最后计算出的值函数 $V_{N_{\\max}}$ 的贪心策略。\n\n一旦值函数 $V$ 收敛（或达到迭代上限），通过为每个状态找到最大化 Q 函数的动作来提取最优策略 $\\pi^*(s)$：\n$$\n\\pi^*(s) = \\arg\\max_{a \\in A} \\left( R(s, a) + \\gamma \\sum_{s' \\in S} \\mathsfP(s'|s,a) V(s') \\right)\n$$\n问题规定，在此最大化过程中的任何平局都必须通过选择索引最小的动作来打破。\n\n实现将使用 `NumPy` 数组进行高效的向量化计算。奖励 $\\mathbf{R}$ 将是一个 $3 \\times 3$ 的矩阵。转移核 $\\mathbf{P}^{(1)}$ 和 $\\mathbf{P}^{(2)}$ 将是 $3 \\times 3 \\times 3$ 的张量。值函数 $V$ 将是一个大小为 3 的向量。项 $\\sum_{s'} \\mathsf{P}(s'|s,a) V(s')$ 使用 `numpy.einsum` 可以同时为所有状态和动作进行高效计算。`numpy.argmax` 函数用于最大化步骤，因为它通过返回最大值的第一次出现时的索引来固有地打破平局，这满足了平局打破规则。该程序将应用于每个测试用例，并且结果将按照规定格式化为单行字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of Markov Decision Process problems using value iteration.\n    \"\"\"\n    \n    # Define MDP components\n    num_states = 3\n    num_actions = 3\n    r = np.array([-1, 0, 2])\n    p = np.array([0, -2, -5])\n    R = r.reshape(1, num_actions) + p.reshape(num_states, 1)\n\n    # Transition Kernel P1 (stochastic)\n    P1 = np.zeros((num_states, num_actions, num_states))\n    # Action 0: reduce backlog\n    P1[0, 0, :] = [0.7, 0.3, 0.0]\n    P1[1, 0, :] = [0.6, 0.3, 0.1]\n    P1[2, 0, :] = [0.0, 0.6, 0.4]\n    # Action 1: hold steady\n    P1[0, 1, :] = [0.5, 0.5, 0.0]\n    P1[1, 1, :] = [0.0, 0.6, 0.4]\n    P1[2, 1, :] = [0.0, 0.2, 0.8]\n    # Action 2: innovate\n    P1[0, 2, :] = [0.3, 0.7, 0.0]\n    P1[1, 2, :] = [0.0, 0.3, 0.7]\n    P1[2, 2, :] = [0.0, 0.1, 0.9]\n\n    # Transition Kernel P2 (deterministic)\n    P2 = np.zeros((num_states, num_actions, num_states))\n    # Action 0: reduce backlog\n    P2[0, 0, 0] = 1.0\n    P2[1, 0, 0] = 1.0\n    P2[2, 0, 1] = 1.0\n    # Action 1: hold steady\n    P2[0, 1, 0] = 1.0\n    P2[1, 1, 1] = 1.0\n    P2[2, 1, 2] = 1.0\n    # Action 2: innovate\n    P2[0, 2, 1] = 1.0\n    P2[1, 2, 2] = 1.0\n    P2[2, 2, 2] = 1.0\n    \n    kernels = {'P1': P1, 'P2': P2}\n\n    test_cases = [\n        ('P1', 0.9, 1e-8, 10000),\n        ('P1', 0.999, 1e-12, 20000),\n        ('P1', 0.0, 1e-8, 10000),\n        ('P2', 0.95, 1e-8, 10000),\n        ('P1', 1.0, 1e-8, 10000),\n    ]\n\n    def solve_mdp(P, gamma, epsilon, n_max):\n        \"\"\"\n        Implements value iteration for a given MDP.\n        \"\"\"\n        # Case: gamma = 1, non-contraction\n        if gamma = 1:\n            policy = np.argmax(R, axis=1)\n            return [int(policy[0]), int(policy[1]), int(policy[2]), 0, False]\n\n        # Case: gamma  1, value iteration\n        V = np.zeros(num_states)\n        for n in range(1, n_max + 1):\n            V_old = V.copy()\n            Q = R + gamma * np.einsum('ijk,k-ij', P, V_old)\n            V = np.max(Q, axis=1)\n            \n            # Check for convergence\n            if np.max(np.abs(V - V_old))  epsilon:\n                policy = np.argmax(Q, axis=1)\n                return [int(policy[0]), int(policy[1]), int(policy[2]), n, True]\n\n        # Case: did not converge within n_max iterations\n        Q = R + gamma * np.einsum('ijk,k-ij', P, V)\n        policy = np.argmax(Q, axis=1)\n        return [int(policy[0]), int(policy[1]), int(policy[2]), n_max, False]\n\n    all_results = []\n    for kernel_name, gamma, epsilon, n_max in test_cases:\n        P = kernels[kernel_name]\n        result_list = solve_mdp(P, gamma, epsilon, n_max)\n        all_results.append(result_list)\n        \n    # Format the final output string to match the required format without spaces\n    string_results = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        string_results.append(inner_str)\n    \n    final_output = f\"[{','.join(string_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}