{
    "hands_on_practices": [
        {
            "introduction": "任何增强现实应用的第一个基本步骤是将虚拟世界锚定到物理世界中。本练习旨在解决一个基本问题：配准。我们将利用一组对应点，计算出将数字孪生与其现实世界对应物对齐的精确刚体变换。掌握这种基于最小二乘法和奇异值分解（SVD）的经典算法 ，对于构建任何稳健的AR叠加系统都至关重要。",
            "id": "4206803",
            "problem": "在一个用于数字孪生的增强现实（AR）和虚拟现实（VR）界面中，一个头戴式设备在世界坐标系 $\\mathcal{W}$ 中追踪物理基准标记，并在孪生坐标系 $\\mathcal{T}$ 中渲染一个虚拟网格。为了将孪生体精确地叠加到物理场景上，需要估计一个刚体变换 $T_{\\mathcal{W}\\mathcal{T}} \\in \\mathrm{SE}(3)$，该变换将点从 $\\mathcal{T}$ 映射到 $\\mathcal{W}$。假设给定 $n \\geq 3$ 组已知的对应点对 $\\{(x_i^{\\mathcal{W}}, x_i^{\\mathcal{T}})\\}_{i=1}^{n}$，其中每个 $x_i^{\\mathcal{W}} \\in \\mathbb{R}^{3}$ 是在 $\\mathcal{W}$ 中测得的基准点位置，每个 $x_i^{\\mathcal{T}} \\in \\mathbb{R}^{3}$ 是孪生体网格中对应顶点在 $\\mathcal{T}$ 中的位置。测量模型为 $x_i^{\\mathcal{W}} = R x_i^{\\mathcal{T}} + t + \\varepsilon_i$，其中 $R \\in \\mathrm{SO}(3)$，$t \\in \\mathbb{R}^{3}$，噪声 $\\varepsilon_i$ 为零均值、具有有限二阶矩、在不同 $i$ 之间相互独立，且与 $x_i^{\\mathcal{T}}$ 独立。你可以假设这些对应关系是正确且固定的。\n\n从基于欧几里得范数和刚体约束的约束最小二乘公式出发，根据第一性原理，推导最小二乘估计量 $\\hat{T}_{\\mathcal{W}\\mathcal{T}}$ 的闭式解析表达式，并用给定的对应点对表示。你必须：\n- 从刚体变换、欧几里得范数和基本矩阵恒等式的定义开始，通过逻辑上消除平移，将旋转子问题简化为一个可在 $\\mathrm{SO}(3)$ 上使用奇异值分解求解的优化问题。\n- 清晰地展示导出估计量最终解析形式的推导步骤。\n- 陈述解在 $\\mathrm{SE}(3)$ 中具有可辨识性和唯一性所需的最小假设。\n\n用 $4 \\times 4$ 齐次坐标将你的最终答案表示为 $\\hat{T}_{\\mathcal{W}\\mathcal{T}}$ 的单个闭式解析表达式。无需进行数值舍入。",
            "solution": "该问题要求推导在两组 $n$ 个对应的三维点 $\\{(x_i^{\\mathcal{W}}, x_i^{\\mathcal{T}})\\}_{i=1}^{n}$ 之间的刚体变换 $T_{\\mathcal{W}\\mathcal{T}} \\in \\mathrm{SE}(3)$ 的闭式最小二乘估计量。该变换将点从孪生坐标系 $\\mathcal{T}$ 映射到世界坐标系 $\\mathcal{W}$。\n\n一个刚体变换由一个旋转 $R \\in \\mathrm{SO}(3)$ 和一个平移 $t \\in \\mathbb{R}^{3}$ 组成。一个点 $x^{\\mathcal{T}}$ 通过规则 $x^{\\mathcal{W}} = R x^{\\mathcal{T}} + t$ 映射到 $x^{\\mathcal{W}}$。给定测量模型 $x_i^{\\mathcal{W}} = R x_i^{\\mathcal{T}} + t + \\varepsilon_i$，最小二乘估计问题旨在找到使残差的欧几里得范数平方和最小的变换 $(\\hat{R}, \\hat{t})$。目标函数 $E(R, t)$ 为：\n$$E(R, t) = \\sum_{i=1}^{n} \\| x_i^{\\mathcal{W}} - (R x_i^{\\mathcal{T}} + t) \\|^2$$\n该优化受条件 $R$ 必须为真旋转矩阵的约束，即 $R \\in \\mathrm{SO}(3)$，这意味着 $R^T R = I$ 且 $\\det(R) = +1$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n\n推导过程分为两个主要阶段：首先，我们求解平移 $t$，其次，我们求解旋转 $R$。\n\n首先，对于一个固定的 $R$，我们通过最小化 $E(R, t)$ 来找到关于 $t$ 的最优平移 $\\hat{t}$。我们计算 $E(R, t)$ 关于 $t$ 的偏导数并令其为零。\n$$ \\frac{\\partial E}{\\partial t} = \\frac{\\partial}{\\partial t} \\sum_{i=1}^{n} (x_i^{\\mathcal{W}} - R x_i^{\\mathcal{T}} - t)^T (x_i^{\\mathcal{W}} - R x_i^{\\mathcal{T}} - t) = 0 $$\n$$ \\sum_{i=1}^{n} -2(x_i^{\\mathcal{W}} - R x_i^{\\mathcal{T}} - t) = 0 $$\n$$ \\sum_{i=1}^{n} t = \\sum_{i=1}^{n} (x_i^{\\mathcal{W}} - R x_i^{\\mathcal{T}}) $$\n$$ n t = \\sum_{i=1}^{n} x_i^{\\mathcal{W}} - R \\sum_{i=1}^{n} x_i^{\\mathcal{T}} $$\n让我们将两个点集的质心定义为 $\\bar{x}^{\\mathcal{W}} = \\frac{1}{n}\\sum_{i=1}^{n} x_i^{\\mathcal{W}}$ 和 $\\bar{x}^{\\mathcal{T}} = \\frac{1}{n}\\sum_{i=1}^{n} x_i^{\\mathcal{T}}$。那么最优平移 $\\hat{t}$ 可以表示为旋转 $R$ 的函数：\n$$ \\hat{t} = \\bar{x}^{\\mathcal{W}} - R \\bar{x}^{\\mathcal{T}} $$\n这个结果表明，变换后的点 $R x_i^{\\mathcal{T}}$ 的质心加上平移量必须与测量点 $x_i^{\\mathcal{W}}$ 的质心对齐。\n\n接下来，我们将 $\\hat{t}$ 的表达式代回目标函数，以得到一个只依赖于 $R$ 的问题。\n$$ x_i^{\\mathcal{W}} - (R x_i^{\\mathcal{T}} + \\hat{t}) = x_i^{\\mathcal{W}} - (R x_i^{\\mathcal{T}} + \\bar{x}^{\\mathcal{W}} - R \\bar{x}^{\\mathcal{T}}) $$\n$$ = (x_i^{\\mathcal{W}} - \\bar{x}^{\\mathcal{W}}) - R(x_i^{\\mathcal{T}} - \\bar{x}^{\\mathcal{T}}) $$\n让我们为每个点集定义中心化坐标：$y'_i = x_i^{\\mathcal{W}} - \\bar{x}^{\\mathcal{W}}$ 和 $x'_i = x_i^{\\mathcal{T}} - \\bar{x}^{\\mathcal{T}}$。目标函数变为：\n$$ E(R) = \\sum_{i=1}^{n} \\| y'_i - R x'_i \\|^2 $$\n我们必须找到最小化这个新目标函数的旋转 $\\hat{R}$。让我们展开范数的平方：\n$$ E(R) = \\sum_{i=1}^{n} (y'_i - R x'_i)^T (y'_i - R x'_i) $$\n$$ = \\sum_{i=1}^{n} ((y'_i)^T y'_i - (y'_i)^T R x'_i - (R x'_i)^T y'_i + (R x'_i)^T R x'_i) $$\n由于 $(y'_i)^T R x'_i$ 是一个标量，它等于其转置 $(R x'_i)^T y'_i$。另外，由于 $R \\in \\mathrm{SO}(3)$，我们有 $R^T R = I$，所以 $(R x'_i)^T R x'_i = (x'_i)^T R^T R x'_i = (x'_i)^T I x'_i = (x'_i)^T x'_i$。该表达式简化为：\n$$ E(R) = \\sum_{i=1}^{n} (\\|y'_i\\|^2 + \\|x'_i\\|^2 - 2 (y'_i)^T R x'_i) $$\n项 $\\sum_{i=1}^{n} \\|y'_i\\|^2$ 和 $\\sum_{i=1}^{n} \\|x'_i\\|^2$ 不依赖于 $R$。因此，最小化 $E(R)$ 等价于最大化项 $\\sum_{i=1}^{n} (y'_i)^T R x'_i$。\n使用迹算子及其循环性质 $\\mathrm{Tr}(ABC) = \\mathrm{Tr}(BCA)$，我们可以重写目标。由于 $(y'_i)^T R x'_i$ 是一个标量（$1 \\times 1$ 矩阵），它等于其自身的迹。\n$$ \\sum_{i=1}^{n} (y'_i)^T R x'_i = \\sum_{i=1}^{n} \\mathrm{Tr}((y'_i)^T R x'_i) = \\sum_{i=1}^{n} \\mathrm{Tr}(R x'_i (y'_i)^T) $$\n根据迹的线性性质，这等于：\n$$ \\mathrm{Tr} \\left( R \\sum_{i=1}^{n} x'_i (y'_i)^T \\right) $$\n让我们定义 $3 \\times 3$ 协方差矩阵 $H = \\sum_{i=1}^{n} x'_i (y'_i)^T$。旋转估计问题现在简化为：\n$$ \\hat{R} = \\arg\\max_{R \\in \\mathrm{SO}(3)} \\mathrm{Tr}(R H) $$\n为了解决这个最大化问题，我们使用 $H$ 的奇异值分解（SVD）。设 $H = U \\Sigma V^T$，其中 $U, V \\in \\mathrm{O}(3)$ 是正交矩阵，$\\Sigma = \\mathrm{diag}(\\sigma_1, \\sigma_2, \\sigma_3)$ 是一个非负奇异值的对角矩阵，且奇异值按 $\\sigma_1 \\geq \\sigma_2 \\geq \\sigma_3 \\geq 0$ 排序。\n将 $H$ 的SVD代入迹表达式：\n$$ \\mathrm{Tr}(R H) = \\mathrm{Tr}(R U \\Sigma V^T) $$\n再次使用迹的循环性质：\n$$ \\mathrm{Tr}(R U \\Sigma V^T) = \\mathrm{Tr}(\\Sigma V^T R U) $$\n令 $M = V^T R U$。由于 $V^T$、$R$ 和 $U$ 都是正交矩阵，它们的乘积 $M$ 也是一个正交矩阵（$M \\in \\mathrm{O}(3)$）。问题就变成了最大化 $\\mathrm{Tr}(\\Sigma M) = \\sum_{j=1}^{3} \\sigma_j M_{jj}$。由于 $M$ 是正交的，其列向量是单位向量，这意味着其元素满足 $|M_{jk}| \\leq 1$。为了在 $\\sigma_j$ 非负的情况下最大化这个和，我们需要使对角元素 $M_{jj}$ 尽可能大。每个 $M_{jj}$ 的最大可能值为 $1$，这在 $M$ 是单位矩阵 $M=I$ 时发生。\n如果 $M=I$，则 $V^T \\hat{R} U = I$，这给出了旋转的一个候选解：\n$$ \\hat{R} = V I U^T = V U^T $$\n然而，我们必须满足 $\\hat{R} \\in \\mathrm{SO}(3)$ 的约束，这要求 $\\det(\\hat{R}) = +1$。SVD矩阵 $U$ 和 $V$ 属于 $\\mathrm{O}(3)$，所以它们的行列式可以是 $+1$ 或 $-1$。\n我们有 $\\det(\\hat{R}) = \\det(V U^T) = \\det(V) \\det(U^T) = \\det(V) \\det(U)$。\n如果 $\\det(V)\\det(U) = +1$，那么 $\\hat{R} = V U^T$ 是一个有效的旋转，并且是最优解。\n如果 $\\det(V)\\det(U) = -1$，那么 $\\det(\\hat{R}) = -1$。这个解代表一个反射，而不是一个真旋转。必须找到在 $\\mathrm{SO}(3)$ 上的真正最大值。在这种情况下，$\\mathrm{Tr}(\\Sigma M)$ 在 $\\det(M) = -1$ 的约束下的最大值在 $M = \\mathrm{diag}(1, 1, -1)$ 时达到，这使得与最小奇异值 $\\sigma_3$ 相关的项变为负数。迹变为 $\\sigma_1 + \\sigma_2 - \\sigma_3$，这是在反射约束下的最大可能值。\n这得到 $V^T \\hat{R} U = \\mathrm{diag}(1, 1, -1)$。修正后的旋转是：\n$$ \\hat{R} = V \\, \\mathrm{diag}(1, 1, -1) \\, U^T $$\n我们可以将两种情况统一为一个表达式。令 $S = \\mathrm{diag}(1, 1, \\det(V U^T))$。那么最优旋转总是由 $\\hat{R} = V S U^T$ 给出。\n\n解 $\\hat{T}_{\\mathcal{W}\\mathcal{T}} \\in \\mathrm{SE}(3)$ 的可辨识性和唯一性所需的最小假设是：\n1. 对应点对的数量必须为 $n \\geq 3$。\n2. 对应的点集 $\\{x_i^\\mathcal{T}\\}_{i=1}^n$ 必须不共线。如果它们共线，则协方差矩阵 $H$ 的秩最多为 1，旋转无法被唯一确定（存在围绕共线轴的旋转不确定性）。如果点不共线，则变换是唯一的。为了得到一个所有旋转自由度都被数据良好约束的鲁棒解，这些点应该不共面，这确保了 $H$ 是满秩（秩为 3）。\n\n总而言之，闭式解通过以下步骤找到：\n1. 计算质心 $\\bar{x}^{\\mathcal{T}}$ 和 $\\bar{x}^{\\mathcal{W}}$。\n2. 计算协方差矩阵 $H = \\sum_{i=1}^{n} (x_i^{\\mathcal{T}} - \\bar{x}^{\\mathcal{T}})(x_i^{\\mathcal{W}} - \\bar{x}^{\\mathcal{W}})^T$。\n3. 对 $H$ 执行 SVD 得到 $H=U \\Sigma V^T$。\n4. 计算最优旋转 $\\hat{R} = V \\, \\mathrm{diag}(1, 1, \\det(V U^T)) \\, U^T$。\n5. 计算最优平移 $\\hat{t} = \\bar{x}^{\\mathcal{W}} - \\hat{R} \\bar{x}^{\\mathcal{T}}$。\n6. 组装齐次变换矩阵 $\\hat{T}_{\\mathcal{W}\\mathcal{T}}$。\n\n$\\hat{T}_{\\mathcal{W}\\mathcal{T}}$ 的最终表达式结合了这些结果。设根据输入的对应点对 $\\{(x_i^{\\mathcal{W}}, x_i^{\\mathcal{T}})\\}_{i=1}^{n}$ 定义以下量：\n- 质心：$\\bar{x}^{\\mathcal{T}} = \\frac{1}{n} \\sum_{i=1}^{n} x_i^{\\mathcal{T}}$ 和 $\\bar{x}^{\\mathcal{W}} = \\frac{1}{n} \\sum_{i=1}^{n} x_i^{\\mathcal{W}}$。\n- 协方差矩阵：$H = \\sum_{i=1}^{n} (x_i^{\\mathcal{T}} - \\bar{x}^{\\mathcal{T}}) (x_i^{\\mathcal{W}} - \\bar{x}^{\\mathcal{W}})^T$。\n- $H$ 的 SVD：$H = U \\Sigma V^T$。\n- 反射修正矩阵：$S = \\mathrm{diag}(1, 1, \\det(V U^T))$。\n\n有了这些定义，最优旋转和平移分别由 $\\hat{R} = V S U^T$ 和 $\\hat{t} = \\bar{x}^{\\mathcal{W}} - \\hat{R} \\bar{x}^{\\mathcal{T}}$ 给出。\n最终的齐次坐标变换为：\n$$ \\hat{T}_{\\mathcal{W}\\mathcal{T}} = \\begin{pmatrix} \\hat{R} & \\hat{t} \\\\ \\mathbf{0}^T & 1 \\end{pmatrix} = \\begin{pmatrix} V S U^T & \\bar{x}^{\\mathcal{W}} - (V S U^T) \\bar{x}^{\\mathcal{T}} \\\\ \\mathbf{0}^T & 1 \\end{pmatrix} $$\n其中 $\\mathbf{0}^T$ 是一个 $1 \\times 3$ 的零行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} V \\mathrm{diag}(1, 1, \\det(V U^T)) U^T & \\frac{1}{n}\\sum_{i=1}^{n} x_i^{\\mathcal{W}} - (V \\mathrm{diag}(1, 1, \\det(V U^T)) U^T) \\frac{1}{n}\\sum_{i=1}^{n} x_i^{\\mathcal{T}} \\\\ \\mathbf{0}^T & 1 \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "数字孪生不仅仅是一个静态模型，它通常包含对物理资产行为的动态仿真。本实践练习将探讨在仿真精度、数值稳定性以及AR/VR显示的实时性约束之间的关键权衡 。你将通过分析一个典型的二阶线性系统，推导出数值积分方法在精度和稳定性方面对时间步长的要求，从而确保虚拟表示既准确又具备实时响应能力。",
            "id": "4206875",
            "problem": "一个单自由度柔性机构的数字孪生 (DT) 被用于驱动头戴式虚拟现实 (VR) 显示器中的增强现实 (AR) 叠加层。该DT将该机构模拟为一个线性质量-弹簧-阻尼系统，其广义坐标为 $q(t)$，速度为 $v(t) = \\dot{q}(t)$，质量为 $m$，刚度为 $k$，阻尼为 $c$。连续时间动力学以一阶形式写作 $\\dot{x}(t) = A x(t)$，其中 $x(t) = \\begin{pmatrix} q(t) \\\\ v(t) \\end{pmatrix}$ 且\n$$\nA = \\begin{pmatrix}\n0 & 1 \\\\\n-\\frac{k}{m} & -\\frac{c}{m}\n\\end{pmatrix}.\n$$\n该DT使用具有固定步长 $\\Delta t$ 的显式（前向）欧拉时间离散化方法来更新状态，以渲染每一帧。\n\n假设AR跟踪模块在正常操作期间提供了运动的保守界限：对于帧间的所有时间 $t$，有 $|q(t)| \\leq Q_{\\max}$ 和 $|v(t)| \\leq V_{\\max}$。AR 叠加层对齐容差要求每步位置局部截断误差满足 $|e_q| \\leq \\varepsilon$，其中 $e_q$ 表示位置 $q$ 在一个步长内的局部截断误差。\n\n给定参数 $m = 2\\,\\mathrm{kg}$，$k = 4 \\times 10^{5}\\,\\mathrm{N/m}$，$c = 360\\,\\mathrm{N\\,s/m}$，$Q_{\\max} = 0.010\\,\\mathrm{m}$，$V_{\\max} = 0.50\\,\\mathrm{m/s}$，以及 $\\varepsilon = 5.0 \\times 10^{-4}\\,\\mathrm{m}$，完成以下任务：\n\n$1.$ 仅从精确解的泰勒展开和显式欧拉法的定义出发，推导每步位置局部截断误差 $|e_q|$ 的一个上界，该上界用 $\\Delta t$、$m$、$k$、$c$、$Q_{\\max}$ 和 $V_{\\max}$ 表示。\n\n$2.$ 使用应用于线性时不变系统的显式欧拉法的线性稳定性条件，推导 $\\Delta t$ 的一个稳定性上界，该上界用 $m$、$k$ 和 $c$ 表示。\n\n$3.$ 结合精度和稳定性要求，计算能同时满足推导出的误差界 $|e_q| \\leq \\varepsilon$ 和稳定性界的最大固定步长 $\\Delta t_{\\max}$。用毫秒表示 $\\Delta t_{\\max}$ 的最终数值答案，并将答案四舍五入到三位有效数字。\n\n$4.$ 提出一个形式为 $\\Delta t_{\\text{new}} = \\min\\{\\Delta t_{\\text{stab}}, s \\,\\Delta t \\, (\\varepsilon / \\widehat{e}_q)^{1/2}\\}$ 的自适应步长更新准则，其中 $\\widehat{e}_q$ 是一个可计算的局部误差估计，$s \\in (0,1)$ 是一个安全因子。此部分你不需要计算数值；只需声明一个有原则的 $\\widehat{e}_q$ 和 $s$ 的选择，该选择需与你在第 1 部分的推导和第 2 部分的稳定性界相一致。\n\n只报告 $\\Delta t_{\\max}$ 的值（以毫秒为单位）作为你的最终答案。",
            "solution": "问题要求使用显式欧拉法对线性质量-弹簧-阻尼系统进行仿真时，找出最大允许的固定时间步长 $\\Delta t_{\\max}$。这个最大步长受到两个要求的约束：局部精度容差和数值稳定性条件。我们必须为每个要求推导出界限，然后确定最严格的那个。\n\n首先，我们来解决精度要求。问题要求推导每步位置局部截断误差 $|e_q|$ 的上界。局部截断误差是在假设步长开始时状态是精确的情况下，一步之后的精确解与数值近似解之间的差值。\n\n系统状态由 $x(t) = \\begin{pmatrix} q(t) \\\\ v(t) \\end{pmatrix}$ 给出，其连续时间演化为 $\\dot{x}(t) = A x(t)$。该系统的第一个分量是 $\\dot{q}(t) = v(t)$。第二个分量是 $\\dot{v}(t) = -\\frac{k}{m}q(t) - \\frac{c}{m}v(t)$，这等价于二阶运动方程 $m\\ddot{q}(t) + c\\dot{q}(t) + kq(t) = 0$。\n\n在时间 $t_{n+1} = t_n + \\Delta t$ 时位置 $q(t)$ 的精确解可以通过在 $t_n$ 附近的泰勒级数展开来表示：\n$$\nq(t_n + \\Delta t) = q(t_n) + \\dot{q}(t_n)\\Delta t + \\frac{1}{2}\\ddot{q}(t_n)\\Delta t^2 + O(\\Delta t^3)\n$$\n假设在时间 $t_n$ 时解是精确的，即 $q_n = q(t_n)$ 且 $v_n = v(t_n) = \\dot{q}(t_n)$。\n\n显式欧拉法更新位置坐标为：\n$$\nq_{n+1} = q_n + v_n \\Delta t\n$$\n位置的局部截断误差 $e_q$ 定义为 $e_q = q(t_n + \\Delta t) - q_{n+1}$。代入以上表达式：\n$$\ne_q = \\left( q(t_n) + \\dot{q}(t_n)\\Delta t + \\frac{1}{2}\\ddot{q}(t_n)\\Delta t^2 + ... \\right) - (q_n + v_n \\Delta t)\n$$\n由于 $q_n = q(t_n)$ 且 $v_n = \\dot{q}(t_n)$，前两项相消，剩下主阶误差项：\n$$\ne_q = \\frac{1}{2}\\ddot{q}(t_n)\\Delta t^2 + O(\\Delta t^3)\n$$\n为了界定这个误差，我们需要找到加速度 $\\ddot{q}(t)$ 的最大可能幅值。根据运动方程：\n$$\n\\ddot{q}(t) = -\\frac{k}{m}q(t) - \\frac{c}{m}v(t)\n$$\n取绝对值并应用三角不等式：\n$$\n|\\ddot{q}(t)| = \\left| -\\frac{k}{m}q(t) - \\frac{c}{m}v(t) \\right| \\leq \\frac{k}{m}|q(t)| + \\frac{c}{m}|v(t)|\n$$\n问题提供了保守界限 $|q(t)| \\leq Q_{\\max}$ 和 $|v(t)| \\leq V_{\\max}$。使用这些界限，我们得到加速度幅值的一个上界：\n$$\n|\\ddot{q}(t)| \\leq \\frac{k}{m}Q_{\\max} + \\frac{c}{m}V_{\\max} = \\frac{1}{m}(kQ_{\\max} + cV_{\\max})\n$$\n将此代入局部误差幅值 $|e_q|$ 的表达式中：\n$$\n|e_q| \\approx \\left| \\frac{1}{2}\\ddot{q}(t_n)\\Delta t^2 \\right| \\leq \\frac{\\Delta t^2}{2m}(kQ_{\\max} + cV_{\\max})\n$$\n精度要求为 $|e_q| \\leq \\varepsilon$。因此，我们从精度考虑推导出对 $\\Delta t$ 的约束：\n$$\n\\frac{\\Delta t^2}{2m}(kQ_{\\max} + cV_{\\max}) \\leq \\varepsilon \\implies \\Delta t \\leq \\sqrt{\\frac{2m\\varepsilon}{kQ_{\\max} + cV_{\\max}}}\n$$\n让我们将此界标记为 $\\Delta t_{\\text{acc}}$。\n\n其次，我们来解决稳定性要求。对于系统 $\\dot{x} = Ax$，显式欧拉法的更新规则是 $x_{n+1} = (I + \\Delta t A)x_n$。该方法是数值稳定的，当且仅当放大矩阵 $G = I + \\Delta t A$ 的所有特征值的模都不大于1。$G$ 的特征值（记为 $\\mu_j$）与 $A$ 的特征值（记为 $\\lambda_j$）通过 $\\mu_j = 1 + \\Delta t \\lambda_j$ 相关联。因此，稳定性条件是对A的所有特征值 $\\lambda_j$，都有 $|1 + \\Delta t \\lambda_j| \\leq 1$。\n\n矩阵 $A = \\begin{pmatrix} 0 & 1 \\\\ -k/m & -c/m \\end{pmatrix}$ 的特征值可以从特征方程 $\\det(A-\\lambda I)=0$ 求得：\n$$\n\\lambda^2 + \\frac{c}{m}\\lambda + \\frac{k}{m} = 0\n$$\n其解为 $\\lambda = -\\frac{c}{2m} \\pm \\sqrt{(\\frac{c}{2m})^2 - \\frac{k}{m}}$。让我们用给定参数计算判别式：$m=2$，$c=360$，$k=4 \\times 10^5$。\n$$\n\\left(\\frac{c}{2m}\\right)^2 - \\frac{k}{m} = \\left(\\frac{360}{2 \\cdot 2}\\right)^2 - \\frac{4 \\times 10^5}{2} = 90^2 - 2 \\times 10^5 = 8100 - 200000  0\n$$\n判别式为负，所以特征值为一对共轭复数：$\\lambda = -\\alpha \\pm i\\omega_d$，其中 $\\alpha = \\frac{c}{2m}$ 且 $\\omega_d = \\sqrt{\\frac{k}{m} - (\\frac{c}{2m})^2}$。\n\n对于复数 $\\lambda$，稳定性条件 $|1 + \\Delta t \\lambda| \\leq 1$ 可以展开为：\n$$\n|1 + \\Delta t(-\\alpha \\pm i\\omega_d)|^2 \\leq 1^2 \\implies |(1-\\alpha\\Delta t) \\pm i(\\omega_d\\Delta t)|^2 \\leq 1\n$$\n$$\n(1-\\alpha\\Delta t)^2 + (\\omega_d\\Delta t)^2 \\leq 1 \\implies 1 - 2\\alpha\\Delta t + \\alpha^2\\Delta t^2 + \\omega_d^2\\Delta t^2 \\leq 1\n$$\n$$\n-2\\alpha\\Delta t + (\\alpha^2 + \\omega_d^2)\\Delta t^2 \\leq 0\n$$\n由于 $\\Delta t  0$，我们可以用它除以：$-2\\alpha + (\\alpha^2 + \\omega_d^2)\\Delta t \\leq 0$。\n项 $\\alpha^2 + \\omega_d^2 = (\\frac{c}{2m})^2 + (\\frac{k}{m} - (\\frac{c}{2m})^2) = \\frac{k}{m}$。并且 $\\alpha=\\frac{c}{2m}$。将这些代回：\n$$\n-2\\left(\\frac{c}{2m}\\right) + \\left(\\frac{k}{m}\\right)\\Delta t \\leq 0 \\implies -\\frac{c}{m} + \\frac{k}{m}\\Delta t \\leq 0\n$$\n解出 $\\Delta t$ 得到稳定性界：\n$$\n\\Delta t \\leq \\frac{c/m}{k/m} = \\frac{c}{k}\n$$\n让我们将此界标记为 $\\Delta t_{\\text{stab}}$。\n\n最后，我们结合这两个约束来找到最大允许步长 $\\Delta t_{\\max}$。步长必须同时满足两个条件，所以 $\\Delta t_{\\max} = \\min(\\Delta t_{\\text{acc}}, \\Delta t_{\\text{stab}})$。我们现在代入给定的数值：\n$m = 2.0\\,\\mathrm{kg}$，$k = 4.0 \\times 10^5\\,\\mathrm{N/m}$，$c = 360\\,\\mathrm{N\\,s/m}$，$Q_{\\max} = 0.010\\,\\mathrm{m}$，$V_{\\max} = 0.50\\,\\mathrm{m/s}$，以及 $\\varepsilon = 5.0 \\times 10^{-4}\\,\\mathrm{m}$。\n\n计算精度界 $\\Delta t_{\\text{acc}}$：\n$$\n\\Delta t_{\\text{acc}} = \\sqrt{\\frac{2m\\varepsilon}{kQ_{\\max} + cV_{\\max}}} = \\sqrt{\\frac{2(2.0)(5.0 \\times 10^{-4})}{(4.0 \\times 10^5)(0.010) + (360)(0.50)}}\n$$\n$$\n\\Delta t_{\\text{acc}} = \\sqrt{\\frac{2.0 \\times 10^{-3}}{4000 + 180}} = \\sqrt{\\frac{2.0 \\times 10^{-3}}{4180}} \\approx \\sqrt{4.78468... \\times 10^{-7}} \\approx 6.91714... \\times 10^{-4}~\\mathrm{s}\n$$\n计算稳定性界 $\\Delta t_{\\text{stab}}$：\n$$\n\\Delta t_{\\text{stab}} = \\frac{c}{k} = \\frac{360}{4.0 \\times 10^5} = 9.0 \\times 10^{-4}~\\mathrm{s}\n$$\n以毫秒为单位比较这两个界：\n$\\Delta t_{\\text{acc}} \\approx 0.6917~\\mathrm{ms}$\n$\\Delta t_{\\text{stab}} = 0.900~\\mathrm{ms}$\n\n最严格的约束是精度要求所施加的约束。因此，最大允许固定步长为：\n$$\n\\Delta t_{\\max} = \\min(0.6917...~\\mathrm{ms}, 0.900~\\mathrm{ms}) = 0.6917...~\\mathrm{ms}\n$$\n问题要求答案以毫秒为单位，并四舍五入到三位有效数字。\n$$\n\\Delta t_{\\max} \\approx 0.692~\\mathrm{ms}\n$$",
            "answer": "$$\n\\boxed{0.692}\n$$"
        },
        {
            "introduction": "为复杂的数字孪生提供流畅、低延迟的AR体验，其计算需求通常会超出独立头显设备的处理能力。本练习将深入探讨一种系统级解决方案：边缘-云协同计算 。你将基于排队论建立一个优化模型，以决定哪些计算任务应在本地设备（边缘）上运行，哪些应卸载到云端，从而在满足计算和网络资源约束的同时，最小化整个系统的端到端延迟。",
            "id": "4206841",
            "problem": "考虑一个用于数字孪生（DT）的交互式增强现实（AR）和虚拟现实（VR）接口，其中每个传入的帧在渲染给用户之前，必须经过一个由 $n$ 个有序任务 $\\{ \\tau_1, \\tau_2, \\ldots, \\tau_n \\}$ 组成的序列处理。该处理流水线可以在索引 $k \\in \\{0,1,\\ldots,n\\}$ 处进行划分，其中任务 $\\tau_1,\\ldots,\\tau_k$ 在边缘设备（例如，头戴式显示器）上运行，而任务 $\\tau_{k+1},\\ldots,\\tau_n$ 在云端运行。目标是选择 $k$ 以最小化端到端延迟，同时满足边缘和云端的计算约束，并使用一个有原则的成本函数来证明该放置的合理性。\n\n您必须基于基本原理推导出一个成本函数，并实现一个算法来选择最小化此成本的分区索引 $k$。仅使用下面指定的模型和定义；不要引入临时的公式。\n\n基本原理和定义：\n- 设任务 $\\tau_i$ 每帧的计算需求为 $c_i$，单位为吉咖操作（GOp）每帧。如果处理器的标称计算速率为 $r$，单位为 GOp/秒，那么对于总计算量为 $C$ 的一组任务，其每帧的服务时间为 $S = C / r$ 秒。\n- 对于一个确定性平均服务时间为 $S$ 的处理阶段，定义其服务速率为 $\\mu = 1 / S$，单位为帧每秒。\n- 假设帧以 $\\lambda$ 帧每秒的速率到达。将每个计算阶段建模为稳态下的马尔可夫到达、马尔可夫服务、单服务器（M/M/1）队列，其中对于一个稳定阶段，系统内的期望时间（包括等待和服务）为 $T = 1 / (\\mu - \\lambda)$ 秒，稳定性条件为 $\\lambda  \\mu$。定义利用率为 $\\rho = \\lambda / \\mu$，并为每个阶段施加一个额外的工程约束 $\\rho \\le u_{\\max}$，其中 $u_{\\max} \\in (0,1)$ 反映了最大允许利用率。\n- 边缘和云端之间的网络会为每帧引入一个确定性延迟。如果边缘阶段后发送的上行有效载荷大小为 $s_{\\text{up}}$ 兆比特，从云端返回到边缘的有效载荷大小为 $s_{\\text{down}}$ 兆比特，上行带宽为 $B_{\\text{up}}$ 兆比特每秒，下行带宽为 $B_{\\text{down}}$ 兆比特每秒，单向传播延迟为 $d_{\\text{prop}}$ 秒，则每帧的总网络延迟为\n$$\nN = \\frac{s_{\\text{up}}}{B_{\\text{up}}} + \\frac{s_{\\text{down}}}{B_{\\text{down}}} + 2 d_{\\text{prop}}.\n$$\n- 有效载荷 $s_{\\text{up}}$ 取决于 $k$。设 $s_{\\text{after}}[k]$ 表示在任务 $\\tau_1,\\ldots,\\tau_k$ 之后的上行有效载荷。根据定义，$s_{\\text{after}}[0]$ 是没有边缘任务时的原始上行有效载荷，$s_{\\text{after}}[n]$ 是所有任务完成后的上行有效载荷（如果不需要云处理，可能为 $0$）。\n\n成本函数设计：\n- 对于给定的 $k$，定义边缘每帧服务时间为 $S_{\\text{edge}}(k) = \\left(\\sum_{i=1}^{k} c_i\\right) / r_{\\text{edge}}$，云端每帧服务时间为 $S_{\\text{cloud}}(k) = \\left(\\sum_{i=k+1}^{n} c_i\\right) / r_{\\text{cloud}}$。它们的服务速率分别为 $\\mu_{\\text{edge}}(k) = 1 / S_{\\text{edge}}(k)$（约定 $S_{\\text{edge}}(0) = 0$ 导致 $\\mu_{\\text{edge}}(0) = +\\infty$）和 $\\mu_{\\text{cloud}}(k) = 1 / S_{\\text{cloud}}(k)$（约定 $S_{\\text{cloud}}(n) = 0$ 导致 $\\mu_{\\text{cloud}}(n) = +\\infty$）。\n- 在稳定运行下，每个阶段的系统内期望时间为 $T_{\\text{edge}}(k) = 1 / (\\mu_{\\text{edge}}(k) - \\lambda)$ 和 $T_{\\text{cloud}}(k) = 1 / (\\mu_{\\text{cloud}}(k) - \\lambda)$。如果 $\\mu_{\\text{edge}}(k) \\le \\lambda$ 或 $\\mu_{\\text{cloud}}(k) \\le \\lambda$，该阶段是不稳定的，在 M/M/1 模型中期望时间会发散；成本函数必须对这样的 $k$ 值进行重罚。\n- 定义确定性网络延迟 $N(k) = s_{\\text{after}}[k] / B_{\\text{up}} + s_{\\text{down}} / B_{\\text{down}} + 2 d_{\\text{prop}}$。\n- 设 $u_{\\max,\\text{edge}}$ 和 $u_{\\max,\\text{cloud}}$ 分别为边缘和云端的最大允许利用率。为将延迟最小化与约束满足统一起来，定义分区索引 $k$ 的成本为\n$$\nJ(k) = T_{\\text{edge}}(k) + N(k) + T_{\\text{cloud}}(k) + \\alpha \\left[\\max\\!\\left(0,\\ \\lambda - u_{\\max,\\text{edge}}\\,\\mu_{\\text{edge}}(k)\\right)\\, \\frac{1}{\\mu_{\\text{edge}}(k)} + \\max\\!\\left(0,\\ \\lambda - u_{\\max,\\text{cloud}}\\,\\mu_{\\text{cloud}}(k)\\right)\\, \\frac{1}{\\mu_{\\text{cloud}}(k)}\\right] + \\beta \\left[\\max\\!\\left(0,\\ \\lambda - \\mu_{\\text{edge}}(k)\\right)\\, \\frac{1}{\\mu_{\\text{edge}}(k)} + \\max\\!\\left(0,\\ \\lambda - \\mu_{\\text{cloud}}(k)\\right)\\, \\frac{1}{\\mu_{\\text{cloud}}(k)}\\right],\n$$\n约定当 $\\mu = +\\infty$ 时，包含 $\\frac{1}{\\mu}$ 的项被视为 $0$。这里的 $\\alpha$ 和 $\\beta$ 是惩罚系数，其单位使得惩罚项的单位为秒。第一个惩罚项强制执行利用率约束 $\\rho \\le u_{\\max}$，第二个惩罚项则惩罚不稳定性 $\\lambda \\ge \\mu$（否则会导致无限的期望时间）。需要最小化的总延迟为 $J(k)$，最优分区索引为 $k^\\star = \\arg\\min_{k \\in \\{0,\\ldots,n\\}} J(k)$。如果同时满足两个利用率约束：$\\lambda \\le u_{\\max,\\text{edge}}\\,\\mu_{\\text{edge}}(k^\\star)$ 和 $\\lambda \\le u_{\\max,\\text{cloud}}\\,\\mu_{\\text{cloud}}(k^\\star)$，则该分区是可行的。\n\n单位和输出规范：\n- 所有时间必须以秒为单位表示。\n- 所有带宽以兆比特每秒为单位。\n- 所有有效载荷以兆比特为单位。\n- 所有计算速率以吉咖操作每秒为单位。\n- 所有计算需求以吉咖操作每帧为单位。\n- 帧到达率 $\\lambda$ 以帧每秒为单位。\n\n您的程序必须计算每个测试用例的 $k^\\star$、最小化成本 $J(k^\\star)$（单位为秒）以及一个可行性指示符。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是形如 $[k^\\star, J(k^\\star), \\text{feasible}]$ 的列表。最小化成本 $J(k^\\star)$ 必须四舍五入到 $6$ 位小数。输出格式示例：$[[0,0.123456,True],[2,0.234567,False]]$。\n\n测试套件：\n- 案例 1 (理想情况):\n    - $n = 4$\n    - $c = [3.0, 2.0, 1.0, 1.0]$ (GOp/帧)\n    - $r_{\\text{edge}} = 200.0$ (GOp/秒), $r_{\\text{cloud}} = 600.0$ (GOp/秒)\n    - $s_{\\text{after}} = [80.0, 40.0, 20.0, 10.0, 5.0]$ (兆比特)\n    - $s_{\\text{down}} = 10.0$ (兆比特)\n    - $B_{\\text{up}} = 160.0$ (兆比特/秒), $B_{\\text{down}} = 200.0$ (兆比特/秒)\n    - $d_{\\text{prop}} = 0.01$ (秒)\n    - $\\lambda = 20.0$ (帧/秒)\n    - $u_{\\max,\\text{edge}} = 0.85$, $u_{\\max,\\text{cloud}} = 0.95$\n- 案例 2 (边缘处达到利用率边界):\n    - $n = 4$\n    - $c = [1.5, 1.0, 0.8, 0.5]$ (GOp/帧)\n    - $r_{\\text{edge}} = 100.0$ (GOp/秒), $r_{\\text{cloud}} = 400.0$ (GOp/秒)\n    - $s_{\\text{after}} = [100.0, 50.0, 25.0, 12.5, 6.0]$ (兆比特)\n    - $s_{\\text{down}} = 8.0$ (兆比特)\n    - $B_{\\text{up}} = 120.0$ (兆比特/秒), $B_{\\text{down}} = 150.0$ (兆比特/秒)\n    - $d_{\\text{prop}} = 0.02$ (秒)\n    - $\\lambda = 16.0$ (帧/秒)\n    - $u_{\\max,\\text{edge}} = 0.80$, $u_{\\max,\\text{cloud}} = 0.90$\n- 案例 3 (网络瓶颈，低带宽):\n    - $n = 5$\n    - $c = [0.8, 0.6, 0.6, 0.5, 0.4]$ (GOp/帧)\n    - $r_{\\text{edge}} = 180.0$ (GOp/秒), $r_{\\text{cloud}} = 500.0$ (GOp/秒)\n    - $s_{\\text{after}} = [200.0, 160.0, 120.0, 80.0, 40.0, 10.0]$ (兆比特)\n    - $s_{\\text{down}} = 5.0$ (兆比特)\n    - $B_{\\text{up}} = 40.0$ (兆比特/秒), $B_{\\text{down}} = 50.0$ (兆比特/秒)\n    - $d_{\\text{prop}} = 0.025$ (秒)\n    - $\\lambda = 18.0$ (帧/秒)\n    - $u_{\\max,\\text{edge}} = 0.90$, $u_{\\max,\\text{cloud}} = 0.95$\n- 案例 4 (云端计算瓶颈):\n    - $n = 3$\n    - $c = [1.2, 1.1, 1.0]$ (GOp/帧)\n    - $r_{\\text{edge}} = 220.0$ (GOp/秒), $r_{\\text{cloud}} = 150.0$ (GOp/秒)\n    - $s_{\\text{after}} = [60.0, 30.0, 15.0, 7.0]$ (兆比特)\n    - $s_{\\text{down}} = 6.0$ (兆比特)\n    - $B_{\\text{up}} = 180.0$ (兆比特/秒), $B_{\\text{down}} = 180.0$ (兆比特/秒)\n    - $d_{\\text{prop}} = 0.015$ (秒)\n    - $\\lambda = 22.0$ (帧/秒)\n    - $u_{\\max,\\text{edge}} = 0.85$, $u_{\\max,\\text{cloud}} = 0.85$\n- 案例 5 (高帧率，接近不可行):\n    - $n = 4$\n    - $c = [2.0, 1.5, 1.0, 1.0]$ (GOp/帧)\n    - $r_{\\text{edge}} = 210.0$ (GOp/秒), $r_{\\text{cloud}} = 300.0$ (GOp/秒)\n    - $s_{\\text{after}} = [120.0, 80.0, 55.0, 35.0, 20.0]$ (兆比特)\n    - $s_{\\text{down}} = 12.0$ (兆比特)\n    - $B_{\\text{up}} = 140.0$ (兆比特/秒), $B_{\\text{down}} = 160.0$ (兆比特/秒)\n    - $d_{\\text{prop}} = 0.02$ (秒)\n    - $\\lambda = 50.0$ (帧/秒)\n    - $u_{\\max,\\text{edge}} = 0.90$, $u_{\\max,\\text{cloud}} = 0.90$\n\n在所有情况下，设置惩罚系数 $\\alpha = 100.0$ 和 $\\beta = 1000.0$（选择这些值是为了在违反约束时，其影响能主导微小的延迟差异）。您的程序必须对所有 $k \\in \\{0,\\ldots,n\\}$ 计算 $J(k)$，选择 $k^\\star$，计算 $J(k^\\star)$（单位为秒，四舍五入到6位小数），并返回在 $k^\\star$ 处是否满足利用率约束。",
            "solution": "用户提供的问题陈述已经过仔细验证，并被确定为**有效**。它在科学上基于排队论和网络性能分析，作为一个约束优化问题，其提法是适定的，并提供了一套完整且一致的定义、参数和约束。所有术语都得到了正式定义，目标清晰。我现在将着手进行一个有原则的解决方案。\n\n问题要求我们为分布在边缘设备和云服务器之间的一系列 $n$ 个计算任务找到最优分区索引 $k^\\star$。最优分区是使总成本函数 $J(k)$ 最小化的分区，该函数代表处理单帧的端到端延迟，并增加了违反操作约束的惩罚项。索引 $k$ 的范围从 $0$（所有任务在云端）到 $n$（所有任务在边缘）。\n\n解决方案的核心是为每个可能的分区 $k \\in \\{0, 1, \\ldots, n\\}$ 系统地评估成本函数 $J(k)$，并找出产生最小成本的索引 $k^\\star$。\n\n首先，我们确定每个阶段的计算负载。对于给定的分区 $k$，边缘的总计算需求是前 $k$ 个任务需求的总和，云端处理其余任务。设任务 $\\tau_i$ 的计算需求为 $c_i$。\n边缘计算负载：$C_{\\text{edge}}(k) = \\sum_{i=1}^{k} c_i$。\n云端计算负载：$C_{\\text{cloud}}(k) = \\sum_{i=k+1}^{n} c_i$。\n为方便计算，我们可以预先计算任务需求的累积和。设 $\\text{csum}[j] = \\sum_{i=1}^{j} c_i$，并有 $\\text{csum}[0]=0$。则 $C_{\\text{edge}}(k) = \\text{csum}[k]$ 且 $C_{\\text{cloud}}(k) = \\text{csum}[n] - \\text{csum}[k]$。\n\n接下来，我们为每个阶段的性能建模。给定处理器计算速率 $r_{\\text{edge}}$ 和 $r_{\\text{cloud}}$，每帧的服务时间为：\n$S_{\\text{edge}}(k) = C_{\\text{edge}}(k) / r_{\\text{edge}}$\n$S_{\\text{cloud}}(k) = C_{\\text{cloud}}(k) / r_{\\text{cloud}}$\n相应的服务速率（单位：帧/秒）是服务时间的倒数：\n$\\mu_{\\text{edge}}(k) = 1 / S_{\\text{edge}}(k)$\n$\\mu_{\\text{cloud}}(k) = 1 / S_{\\text{cloud}}(k)$\n特殊情况是 $k=0$（无边缘处理）和 $k=n$（无云端处理）。对于 $k=0$，$C_{\\text{edge}}(0)=0$，所以 $S_{\\text{edge}}(0)=0$，我们定义 $\\mu_{\\text{edge}}(0) = +\\infty$。对称地，对于 $k=n$，$C_{\\text{cloud}}(n)=0$，所以 $S_{\\text{cloud}}(n)=0$，我们定义 $\\mu_{\\text{cloud}}(n) = +\\infty$。\n\n问题将每个阶段建模为 M/M/1 队列。对于一个稳定阶段（到达率 $\\lambda$ 小于服务率 $\\mu$），系统内的期望时间 $T$（排队延迟加服务时间）为：\n$T = 1 / (\\mu - \\lambda)$。\n此公式仅对稳定队列有效，即 $\\lambda  \\mu$。如果 $\\lambda \\ge \\mu$，队列不稳定，期望时间发散至无穷大。所提供的成本函数 $J(k)$ 通过将稳定阶段的延迟与针对不稳定或接近不稳定阶段的大额惩罚项相结合来解决此问题。根据问题的定义，如果 $\\mu(k)  \\lambda$，我们将延迟贡献 $T(k)$ 计算为 $1/(\\mu(k)-\\lambda)$，否则计算为 $0$，让惩罚项来处理不稳定性的成本。\n\n网络延迟 $N(k)$ 取决于分区 $k$，通过上行有效载荷大小 $s_{\\text{after}}[k]$ 体现：\n$N(k) = s_{\\text{after}}[k] / B_{\\text{up}} + s_{\\text{down}} / B_{\\text{down}} + 2 d_{\\text{prop}}$。\n\n总成本函数 $J(k)$ 是延迟和惩罚项的总和：\n$J(k) = T_{\\text{edge}}(k) + T_{\\text{cloud}}(k) + N(k) + \\text{Penalty}_{\\alpha}(k) + \\text{Penalty}_{\\beta}(k)$。\n惩罚项定义如下：\n$\\text{Penalty}_{\\alpha}(k) = \\alpha \\left[\\max\\!\\left(0,\\ \\lambda - u_{\\max,\\text{edge}}\\,\\mu_{\\text{edge}}(k)\\right)\\,S_{\\text{edge}}(k) + \\max\\!\\left(0,\\ \\lambda - u_{\\max,\\text{cloud}}\\,\\mu_{\\text{cloud}}(k)\\right)\\,S_{\\text{cloud}}(k)\\right]$\n$\\text{Penalty}_{\\beta}(k) = \\beta \\left[\\max\\!\\left(0,\\ \\lambda - \\mu_{\\text{edge}}(k)\\right)\\,S_{\\text{edge}}(k) + \\max\\!\\left(0,\\ \\lambda - \\mu_{\\text{cloud}}(k)\\right)\\,S_{\\text{cloud}}(k)\\right]$\n在这里，我们用 $S(k)$ 替换了 $1/\\mu(k)$。对于 $\\mu=\\infty$ 的约定确保了空闲阶段的惩罚项为零，因为其服务时间 $S$ 为零。$\\alpha$-惩罚项强制执行最大利用率约束 $\\rho_j = \\lambda/\\mu_j \\le u_{\\max,j}$，而 $\\beta$-惩罚项则惩罚基本的不稳定性 $\\lambda \\ge \\mu_j$。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  初始化 `min_cost` 为无穷大，`k_star` 为一个无效值。\n2.  对于从 $0$ 到 $n$ 的每个可能的分区索引 $k$：\n    a.  计算 $C_{\\text{edge}}(k)$ 和 $C_{\\text{cloud}}(k)$。\n    b.  确定 $S_{\\text{edge}}(k)$、$\\mu_{\\text{edge}}(k)$ 和 $T_{\\text{edge}}(k)$（如果稳定）。\n    c.  确定 $S_{\\text{cloud}}(k)$、$\\mu_{\\text{cloud}}(k)$ 和 $T_{\\text{cloud}}(k)$（如果稳定）。\n    d.  计算网络延迟 $N(k)$。\n    e.  计算边缘和云端阶段的 $\\alpha$ 和 $\\beta$ 惩罚项。\n    f.  将所有部分相加得到总成本 $J(k)$。\n    g.  如果 $J(k)$ 小于当前的 `min_cost`，则将 `min_cost` 更新为 $J(k)$，并将 `k_star` 更新为 $k$。\n3.  检查完所有 $k$ 后，即可找到最优分区 $k^\\star$ 及其相关的最小成本 $J(k^\\star)$。\n4.  最后，确定在 $k^\\star$ 处的解的可行性。如果两个阶段的利用率约束都得到满足：$\\lambda \\le u_{\\max,\\text{edge}}\\,\\mu_{\\text{edge}}(k^\\star)$ 和 $\\lambda \\le u_{\\max,\\text{cloud}}\\,\\mu_{\\text{cloud}}(k^\\star)$，则解是可行的。此检查必须正确处理空闲阶段的无限服务率。\n\n每个案例的最终结果将是一个三元组：$[k^\\star, J(k^\\star), \\text{is_feasible}]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the task partitioning problem for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"n\": 4, \"c\": [3.0, 2.0, 1.0, 1.0], \"r_edge\": 200.0, \"r_cloud\": 600.0,\n            \"s_after\": [80.0, 40.0, 20.0, 10.0, 5.0], \"s_down\": 10.0,\n            \"B_up\": 160.0, \"B_down\": 200.0, \"d_prop\": 0.01,\n            \"lambda\": 20.0, \"u_max_edge\": 0.85, \"u_max_cloud\": 0.95,\n        },\n        # Case 2 (boundary utilization at edge)\n        {\n            \"n\": 4, \"c\": [1.5, 1.0, 0.8, 0.5], \"r_edge\": 100.0, \"r_cloud\": 400.0,\n            \"s_after\": [100.0, 50.0, 25.0, 12.5, 6.0], \"s_down\": 8.0,\n            \"B_up\": 120.0, \"B_down\": 150.0, \"d_prop\": 0.02,\n            \"lambda\": 16.0, \"u_max_edge\": 0.80, \"u_max_cloud\": 0.90,\n        },\n        # Case 3 (network bottleneck, low bandwidth)\n        {\n            \"n\": 5, \"c\": [0.8, 0.6, 0.6, 0.5, 0.4], \"r_edge\": 180.0, \"r_cloud\": 500.0,\n            \"s_after\": [200.0, 160.0, 120.0, 80.0, 40.0, 10.0], \"s_down\": 5.0,\n            \"B_up\": 40.0, \"B_down\": 50.0, \"d_prop\": 0.025,\n            \"lambda\": 18.0, \"u_max_edge\": 0.90, \"u_max_cloud\": 0.95,\n        },\n        # Case 4 (cloud compute bottleneck)\n        {\n            \"n\": 3, \"c\": [1.2, 1.1, 1.0], \"r_edge\": 220.0, \"r_cloud\": 150.0,\n            \"s_after\": [60.0, 30.0, 15.0, 7.0], \"s_down\": 6.0,\n            \"B_up\": 180.0, \"B_down\": 180.0, \"d_prop\": 0.015,\n            \"lambda\": 22.0, \"u_max_edge\": 0.85, \"u_max_cloud\": 0.85,\n        },\n        # Case 5 (high frame rate, near-infeasible)\n        {\n            \"n\": 4, \"c\": [2.0, 1.5, 1.0, 1.0], \"r_edge\": 210.0, \"r_cloud\": 300.0,\n            \"s_after\": [120.0, 80.0, 55.0, 35.0, 20.0], \"s_down\": 12.0,\n            \"B_up\": 140.0, \"B_down\": 160.0, \"d_prop\": 0.02,\n            \"lambda\": 50.0, \"u_max_edge\": 0.90, \"u_max_cloud\": 0.90,\n        }\n    ]\n    \n    alpha = 100.0\n    beta = 1000.0\n    \n    results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        c = np.array(case[\"c\"])\n        r_edge, r_cloud = case[\"r_edge\"], case[\"r_cloud\"]\n        s_after = np.array(case[\"s_after\"])\n        s_down = case[\"s_down\"]\n        B_up, B_down = case[\"B_up\"], case[\"B_down\"]\n        d_prop = case[\"d_prop\"]\n        lambda_rate = case[\"lambda\"]\n        u_max_edge, u_max_cloud = case[\"u_max_edge\"], case[\"u_max_cloud\"]\n\n        c_cumulative = np.insert(np.cumsum(c), 0, 0)\n        c_total = c_cumulative[n]\n\n        min_cost = float('inf')\n        k_star = -1\n\n        for k in range(n + 1):\n            # Edge stage calculation\n            C_edge = c_cumulative[k]\n            T_edge, penalty_alpha_edge, penalty_beta_edge = 0, 0, 0\n            S_edge, mu_edge = 0, float('inf')\n            \n            if C_edge > 0:\n                S_edge = C_edge / r_edge\n                mu_edge = 1.0 / S_edge\n                if mu_edge > lambda_rate:\n                    T_edge = 1.0 / (mu_edge - lambda_rate)\n                \n                penalty_alpha_edge = alpha * max(0, lambda_rate - u_max_edge * mu_edge) * S_edge\n                penalty_beta_edge = beta * max(0, lambda_rate - mu_edge) * S_edge\n\n            # Cloud stage calculation\n            C_cloud = c_total - C_edge\n            T_cloud, penalty_alpha_cloud, penalty_beta_cloud = 0, 0, 0\n            S_cloud, mu_cloud = 0, float('inf')\n            \n            if C_cloud > 0:\n                S_cloud = C_cloud / r_cloud\n                mu_cloud = 1.0 / S_cloud\n                if mu_cloud > lambda_rate:\n                    T_cloud = 1.0 / (mu_cloud - lambda_rate)\n            \n                penalty_alpha_cloud = alpha * max(0, lambda_rate - u_max_cloud * mu_cloud) * S_cloud\n                penalty_beta_cloud = beta * max(0, lambda_rate - mu_cloud) * S_cloud\n\n            # Network latency\n            N_k = s_after[k] / B_up + s_down / B_down + 2 * d_prop\n\n            # Total cost J(k)\n            J_k = (T_edge + T_cloud + N_k + \n                   penalty_alpha_edge + penalty_beta_edge + \n                   penalty_alpha_cloud + penalty_beta_cloud)\n\n            if J_k  min_cost:\n                min_cost = J_k\n                k_star = k\n        \n        # Feasibility check for the optimal partition k_star\n        C_edge_star = c_cumulative[k_star]\n        mu_edge_star = float('inf')\n        if C_edge_star > 0:\n            mu_edge_star = 1.0 / (C_edge_star / r_edge)\n\n        C_cloud_star = c_total - C_edge_star\n        mu_cloud_star = float('inf')\n        if C_cloud_star > 0:\n            mu_cloud_star = 1.0 / (C_cloud_star / r_cloud)\n            \n        is_feasible_edge = (mu_edge_star == float('inf')) or (lambda_rate = u_max_edge * mu_edge_star)\n        is_feasible_cloud = (mu_cloud_star == float('inf')) or (lambda_rate = u_max_cloud * mu_cloud_star)\n        is_feasible = is_feasible_edge and is_feasible_cloud\n\n        results.append([k_star, min_cost, is_feasible])\n    \n    # Format the output as specified\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]:.6f},{str(r[2])}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}