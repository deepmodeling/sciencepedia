{
    "hands_on_practices": [
        {
            "introduction": "The performance of a centralized SDN architecture, a cornerstone for many Cyber-Physical Systems, critically hinges on the strategic placement of its controllers. This practice immerses you in this fundamental optimization challenge, tasking you with finding the optimal locations for controllers in a sample network to minimize communication delays. By working through this problem , you will develop practical skills in graph analysis and combinatorial optimization to minimize worst-case control-plane latency, a key determinant of overall system responsiveness and stability.",
            "id": "4246512",
            "problem": "Consider a centralized Software-Defined Networking (SDN) control plane for a Cyber-Physical System (CPS), where a set of switches $V=\\{1,2,3,4,5\\}$ are interconnected with symmetric communication latencies. The network is modeled as an undirected graph with edge latencies $w_{uv}$ in milliseconds between directly connected switches $u$ and $v$. The nonzero direct links and their latencies are:\n- $w_{1,2}=3\\,\\mathrm{ms}$,\n- $w_{2,3}=2\\,\\mathrm{ms}$,\n- $w_{3,4}=4\\,\\mathrm{ms}$,\n- $w_{4,5}=3\\,\\mathrm{ms}$,\n- $w_{1,5}=8\\,\\mathrm{ms}$,\n- $w_{2,5}=5\\,\\mathrm{ms}$,\n- $w_{1,3}=6\\,\\mathrm{ms}$.\n\nAll links not listed have no direct connection. Assume negligible queueing in the data plane and symmetric latency on each path; that is, propagation delay on a path equals the sum of its constituent link latencies, and the reverse path has the same latency.\n\nYou are to place $k=2$ SDN controllers at two distinct switches (controller locations must be chosen from $V$). Each switch sends control messages to its nearest controller over the shortest-latency path, and the associated control-policy reaction completes when the controller’s response arrives back at the originating switch. Assume a controller processing time of $t_{\\mathrm{proc}}=2\\,\\mathrm{ms}$ (this aggregates computation and any software overhead at the controller) and negligible processing time at switches.\n\nStarting from first principles (shortest-path latency as the sum of link latencies and reaction time as the time for a request to travel from a switch to a controller and for the response to return), determine:\n- the controller placement that minimizes the worst-case one-way latency from any switch to its nearest controller, and\n- the corresponding upper bound on the control-policy reaction time experienced by any switch event under that optimal placement.\n\nExpress the final reaction-time bound in milliseconds. No rounding is required; report the exact value.",
            "solution": "The problem requires us to determine the optimal placement of $k=2$ Software-Defined Networking (SDN) controllers within a network of $V=\\{1,2,3,4,5\\}$ switches to minimize the worst-case one-way communication latency from any switch to its assigned controller. Subsequently, we must calculate the upper bound on the control-policy reaction time for this optimal placement.\n\nThis problem is a specific instance of the unweighted vertex $k$-center problem on a graph. We seek to find a subset of vertices $C \\subset V$ with a size $|C|=k=2$, which will serve as controller locations. The objective is to minimize the maximum shortest-path latency from any switch $v \\in V$ to its nearest controller in $C$. Let $d(u,v)$ denote the shortest-path latency between switches $u$ and $v$. The optimization problem is to find the set $C^*$ that solves:\n$$ \\min_{C \\subset V, |C|=2} \\left( \\max_{v \\in V} \\left( \\min_{c \\in C} d(v,c) \\right) \\right) $$\n\nThe solution process involves three main steps:\n1.  Compute the all-pairs shortest-path latencies for the given network graph.\n2.  Evaluate all possible controller placements to find the one(s) that minimize the worst-case one-way latency.\n3.  Calculate the upper bound on the control-policy reaction time using the result from the optimal placement.\n\n**Step 1: All-Pairs Shortest Path Calculation**\n\nThe network of switches and links can be modeled as an undirected graph $G=(V, E)$, where $V=\\{1,2,3,4,5\\}$ and the edge weights are the given latencies in milliseconds. The adjacency matrix, representing direct link latencies ($w_{uv}$), is given by (with $\\infty$ for no direct link):\n$$ W = \\begin{pmatrix} 0 & 3 & 6 & \\infty & 8 \\\\ 3 & 0 & 2 & \\infty & 5 \\\\ 6 & 2 & 0 & 4 & \\infty \\\\ \\infty & \\infty & 4 & 0 & 3 \\\\ 8 & 5 & \\infty & 3 & 0 \\end{pmatrix} $$\nWe can use an algorithm such as the Floyd-Warshall algorithm or run Dijkstra's algorithm from each vertex to find the shortest-path latencies $d(u,v)$ between all pairs of switches. The resulting all-pairs shortest-path matrix, $D$, is:\n$$ D = \\begin{pmatrix} 0 & 3 & 5 & 9 & 8 \\\\ 3 & 0 & 2 & 6 & 5 \\\\ 5 & 2 & 0 & 4 & 7 \\\\ 9 & 6 & 4 & 0 & 3 \\\\ 8 & 5 & 7 & 3 & 0 \\end{pmatrix} $$\nFor example, the shortest path from switch $1$ to switch $3$ is $d(1,3)=5\\,\\mathrm{ms}$ via the path $1 \\to 2 \\to 3$ (latency $3+2=5$), which is shorter than the direct link with latency $6\\,\\mathrm{ms}$.\n\n**Step 2: Evaluation of Candidate Controller Placements**\n\nWe need to place $k=2$ controllers. The number of possible placements is the number of ways to choose $2$ switches from $5$, which is $\\binom{5}{2} = \\frac{5 \\times 4}{2} = 10$. For each candidate placement $C = \\{c_1, c_2\\}$, we calculate the worst-case one-way latency, $L(C) = \\max_{v \\in V} \\min(d(v, c_1), d(v, c_2))$.\n\n1.  $C = \\{1, 2\\}$: Latencies to nearest controller for $v \\in \\{1,2,3,4,5\\}$ are $\\{\\min(d(1,1),d(1,2)), \\min(d(2,1),d(2,2)), \\dots\\}$. This gives $\\{\\min(0,3), \\min(3,0), \\min(5,2), \\min(9,6), \\min(8,5)\\} = \\{0, 0, 2, 6, 5\\}$. $L(\\{1,2\\}) = \\max\\{0,0,2,6,5\\} = 6\\,\\mathrm{ms}$.\n2.  $C = \\{1, 3\\}$: Latencies are $\\{\\min(0,5), \\min(3,2), \\min(5,0), \\min(9,4), \\min(8,7)\\} = \\{0, 2, 0, 4, 7\\}$. $L(\\{1,3\\}) = \\max\\{0,2,0,4,7\\} = 7\\,\\mathrm{ms}$.\n3.  $C = \\{1, 4\\}$: Latencies are $\\{\\min(0,9), \\min(3,6), \\min(5,4), \\min(9,0), \\min(8,3)\\} = \\{0, 3, 4, 0, 3\\}$. $L(\\{1,4\\}) = \\max\\{0,3,4,0,3\\} = 4\\,\\mathrm{ms}$.\n4.  $C = \\{1, 5\\}$: Latencies are $\\{\\min(0,8), \\min(3,5), \\min(5,7), \\min(9,3), \\min(8,0)\\} = \\{0, 3, 5, 3, 0\\}$. $L(\\{1,5\\}) = \\max\\{0,3,5,3,0\\} = 5\\,\\mathrm{ms}$.\n5.  $C = \\{2, 3\\}$: Latencies are $\\{\\min(3,5), \\min(0,2), \\min(2,0), \\min(6,4), \\min(5,7)\\} = \\{3, 0, 0, 4, 5\\}$. $L(\\{2,3\\}) = \\max\\{3,0,0,4,5\\} = 5\\,\\mathrm{ms}$.\n6.  $C = \\{2, 4\\}$: Latencies are $\\{\\min(3,9), \\min(0,6), \\min(2,4), \\min(6,0), \\min(5,3)\\} = \\{3, 0, 2, 0, 3\\}$. $L(\\{2,4\\}) = \\max\\{3,0,2,0,3\\} = 3\\,\\mathrm{ms}$.\n7.  $C = \\{2, 5\\}$: Latencies are $\\{\\min(3,8), \\min(0,5), \\min(2,7), \\min(6,3), \\min(5,0)\\} = \\{3, 0, 2, 3, 0\\}$. $L(\\{2,5\\}) = \\max\\{3,0,2,3,0\\} = 3\\,\\mathrm{ms}$.\n8.  $C = \\{3, 4\\}$: Latencies are $\\{\\min(5,9), \\min(2,6), \\min(0,4), \\min(4,0), \\min(7,3)\\} = \\{5, 2, 0, 0, 3\\}$. $L(\\{3,4\\}) = \\max\\{5,2,0,0,3\\} = 5\\,\\mathrm{ms}$.\n9.  $C = \\{3, 5\\}$: Latencies are $\\{\\min(5,8), \\min(2,5), \\min(0,7), \\min(4,3), \\min(7,0)\\} = \\{5, 2, 0, 3, 0\\}$. $L(\\{3,5\\}) = \\max\\{5,2,0,3,0\\} = 5\\,\\mathrm{ms}$.\n10. $C = \\{4, 5\\}$: Latencies are $\\{\\min(9,8), \\min(6,5), \\min(4,7), \\min(0,3), \\min(3,0)\\} = \\{8, 5, 4, 0, 0\\}$. $L(\\{4,5\\}) = \\max\\{8,5,4,0,0\\} = 8\\,\\mathrm{ms}$.\n\nComparing the worst-case latencies for all placements, the minimum value is $3\\,\\mathrm{ms}$.\n$$ \\min_{C} L(C) = 3\\,\\mathrm{ms} $$\nThis minimum is achieved for two distinct controller placements: $C^*_1 = \\{2, 4\\}$ and $C^*_2 = \\{2, 5\\}$. Both are optimal placements. The question asks for the controller placement, and either of these sets constitutes a correct answer.\n\n**Step 3: Calculation of the Control-Policy Reaction Time Bound**\n\nThe control-policy reaction time for a given switch is the round-trip time for a message to its assigned controller, including a specified controller processing time.\nLet $t_{\\text{one-way}}(v)$ be the one-way latency for a switch $v$ to its nearest controller. The reaction time for switch $v$ is:\n$$ T_{\\text{reaction}}(v) = t_{\\text{one-way}}(v) + t_{\\text{proc}} + t_{\\text{one-way}}(v) = 2 \\cdot t_{\\text{one-way}}(v) + t_{\\text{proc}} $$\nThe problem asks for the upper bound on this reaction time, which corresponds to the switch experiencing the worst-case (maximum) one-way latency under the optimal controller placement. This maximum one-way latency is precisely the value $L(C^*)$ we minimized, which is $3\\,\\mathrm{ms}$.\n\nLet $L_{\\text{opt}} = \\max_{v \\in V} \\min_{c \\in C^*} d(v,c) = 3\\,\\mathrm{ms}$.\nThe controller processing time is given as $t_{\\text{proc}} = 2\\,\\mathrm{ms}$.\nThe upper bound on the control-policy reaction time, $T_{\\text{reaction,max}}$, experienced by any switch is therefore:\n$$ T_{\\text{reaction,max}} = 2 \\cdot L_{\\text{opt}} + t_{\\text{proc}} $$\n$$ T_{\\text{reaction,max}} = 2 \\cdot (3\\,\\mathrm{ms}) + 2\\,\\mathrm{ms} = 6\\,\\mathrm{ms} + 2\\,\\mathrm{ms} = 8\\,\\mathrm{ms} $$\nThus, with an optimal placement of controllers (either at switches $\\{2, 4\\}$ or $\\{2, 5\\}$), the maximum reaction time any switch will experience is $8\\,\\mathrm{ms}$.",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "In safety-critical systems, ambiguity can lead to failure; ensuring that the correct policy is always applied to a data packet is therefore non-negotiable. This exercise  delves into the mechanics of creating deterministic flow tables by assigning priorities based on rule specificity, preventing unpredictable behavior from overlapping rules. Furthermore, it bridges the gap between logical configuration and physical performance by guiding you to calculate the worst-case latency for a critical flow, providing a tangible understanding of how data plane rules and queuing discipline directly impact real-time guarantees.",
            "id": "4246510",
            "problem": "An OpenFlow-like Software-Defined Networking (SDN) data plane is used to enforce communication policies for a safety-critical Cyber-Physical System (CPS). The SDN switch uses integer rule priorities where higher integers denote higher matching precedence. The controller programs the following six flow rules, each with a three-field predicate consisting of Virtual Local Area Network (VLAN) Identifier, Internet Protocol version 4 (IPv4) destination prefix, and Transmission Control Protocol (TCP) destination port. Wildcards denote “any value”.\n\nRule $f_1$: VLAN $10$, IPv4 destination $10.0.0.0/8$, TCP destination port any.\n\nRule $f_2$: VLAN $10$, IPv4 destination $10.1.0.0/16$, TCP destination port $12345$.\n\nRule $f_3$ (safety-critical CPS control): VLAN $10$, IPv4 destination $10.1.2.0/24$, TCP destination port $12345$.\n\nRule $f_4$: VLAN any, IPv4 destination $10.1.2.0/24$, TCP destination port any.\n\nRule $f_5$: VLAN any, IPv4 destination any, TCP destination port any (table-miss default).\n\nRule $f_6$: VLAN $10$, IPv4 destination $10.1.2.34/32$, TCP destination port any.\n\nPackets are matched by choosing the highest-priority rule among all rules whose predicate is satisfied. To guarantee deterministic matching order in the presence of overlapping wildcard patterns, the controller defines the following specificity metric for a rule’s predicate. Let $s_{\\text{VLAN}}$ be the number of matched bits in the VLAN Identifier (exact match counts as $12$ bits; wildcard counts as $0$), let $s_{\\text{IP}}$ be the matched prefix length in the IPv4 destination address (from $0$ to $32$), and let $s_{\\text{TCP}}$ be the number of matched bits in the TCP destination port (exact match counts as $16$ bits; wildcard counts as $0$). The combined specificity is $S = s_{\\text{VLAN}} + s_{\\text{IP}} + s_{\\text{TCP}}$. The deterministic priority ordering requirement is: for any pair of rules with a non-empty intersection of their match sets, the rule with the strictly larger $S$ must have a strictly higher integer priority; ties in $S$ must be broken lexicographically by the tuple $(s_{\\text{TCP}}, s_{\\text{IP}}, s_{\\text{VLAN}})$ so that the rule with the larger tuple in lexicographic order has higher priority. All six rules must be assigned distinct integer priorities $p_1, p_2, p_3, p_4, p_5, p_6$, where $p_i$ is the priority of $f_i$.\n\nIn addition, the switch scheduler is strict non-preemptive priority: packets matching $f_3$ are placed into a high-priority queue, while all other packets are placed into a single lower-priority queue. The link rate is $C = 1 \\times 10^{9}$ bits per second, the maximum lower-priority frame size is $L_{\\text{BE}} = 1500$ bytes, the safety-critical frame size is $L_{\\text{CPS}} = 100$ bytes, the per-packet switch processing time is $t_{\\text{proc}} = 5 \\,\\mu\\text{s}$, the cable length is $d = 100$ meters, and the propagation speed in the medium is $v = 2 \\times 10^{8}$ meters per second. Using first principles of non-preemptive strict-priority queuing and serialization and propagation delays, derive the worst-case per-hop latency $\\Delta_{\\max}$ for a packet of the safety-critical flow $f_3$.\n\nCompute:\n- The integer priority assignment $(p_1, p_2, p_3, p_4, p_5, p_6)$ that satisfies the determinism requirement described above.\n- The worst-case per-hop latency $\\Delta_{\\max}$ for $f_3$.\n\nReport your final answer as a single row vector containing the six priorities followed by the scalar $\\Delta_{\\max}$. Round the latency to four significant figures and express it in milliseconds.",
            "solution": "The problem requires the determination of two quantities: an integer priority assignment for a set of six Software-Defined Networking (SDN) flow rules, and the worst-case per-hop latency for a specific safety-critical flow. The solution is derived in two corresponding parts.\n\nPart 1: Integer Priority Assignment\n\nThe priority of each flow rule $f_i$ is determined by a specificity metric. The combined specificity $S$ is defined as the sum of specificities of the three predicate fields: $S = s_{\\text{VLAN}} + s_{\\text{IP}} + s_{\\text{TCP}}$. The individual specificities are defined as:\n- $s_{\\text{VLAN}}$: The number of matched bits in the Virtual Local Area Network (VLAN) Identifier. An exact match corresponds to $12$ bits, while a wildcard corresponds to $0$ bits.\n- $s_{\\text{IP}}$: The prefix length of the Internet Protocol version 4 (IPv4) destination address, ranging from $0$ to $32$.\n- $s_{\\text{TCP}}$: The number of matched bits in the Transmission Control Protocol (TCP) destination port. An exact match corresponds to $16$ bits, while a wildcard corresponds to $0$ bits.\n\nThe rules are to be ordered based on the following criteria: a rule with a strictly larger $S$ value has strictly higher precedence. In case of a tie in $S$, the tie is broken by the lexicographical order of the tuple $(s_{\\text{TCP}}, s_{\\text{IP}}, s_{\\text{VLAN}})$; the rule with the lexicographically larger tuple has higher precedence. \"Higher integers denote higher matching precedence\". We will assign integer priorities from $1$ (lowest) to $6$ (highest).\n\nFirst, we calculate the specificity vector $(s_{\\text{VLAN}}, s_{\\text{IP}}, s_{\\text{TCP}})$ and the combined specificity $S$ for each of the six rules.\n\n- Rule $f_1$: (VLAN $10$, IPv4 $10.0.0.0/8$, TCP any)\n  $s_{\\text{VLAN},1} = 12$, $s_{\\text{IP},1} = 8$, $s_{\\text{TCP},1} = 0$.\n  $S_1 = 12 + 8 + 0 = 20$. Tie-breaking tuple: $(0, 8, 12)$.\n\n- Rule $f_2$: (VLAN $10$, IPv4 $10.1.0.0/16$, TCP $12345$)\n  $s_{\\text{VLAN},2} = 12$, $s_{\\text{IP},2} = 16$, $s_{\\text{TCP},2} = 16$.\n  $S_2 = 12 + 16 + 16 = 44$. Tie-breaking tuple: $(16, 16, 12)$.\n\n- Rule $f_3$: (VLAN $10$, IPv4 $10.1.2.0/24$, TCP $12345$)\n  $s_{\\text{VLAN},3} = 12$, $s_{\\text{IP},3} = 24$, $s_{\\text{TCP},3} = 16$.\n  $S_3 = 12 + 24 + 16 = 52$. Tie-breaking tuple: $(16, 24, 12)$.\n\n- Rule $f_4$: (VLAN any, IPv4 $10.1.2.0/24$, TCP any)\n  $s_{\\text{VLAN},4} = 0$, $s_{\\text{IP},4} = 24$, $s_{\\text{TCP},4} = 0$.\n  $S_4 = 0 + 24 + 0 = 24$. Tie-breaking tuple: $(0, 24, 0)$.\n\n- Rule $f_5$: (VLAN any, IPv4 any, TCP any)\n  $s_{\\text{VLAN},5} = 0$, $s_{\\text{IP},5} = 0$, $s_{\\text{TCP},5} = 0$.\n  $S_5 = 0 + 0 + 0 = 0$. Tie-breaking tuple: $(0, 0, 0)$.\n\n- Rule $f_6$: (VLAN $10$, IPv4 $10.1.2.34/32$, TCP any)\n  $s_{\\text{VLAN},6} = 12$, $s_{\\text{IP},6} = 32$, $s_{\\text{TCP},6} = 0$.\n  $S_6 = 12 + 32 + 0 = 44$. Tie-breaking tuple: $(0, 32, 12)$.\n\nNext, we sort the rules in descending order of precedence.\n1.  $f_3$ has the highest combined specificity, $S_3 = 52$.\n2.  $f_2$ and $f_6$ have the same specificity, $S_2 = S_6 = 44$. We apply the tie-breaking rule by comparing their tuples lexicographically:\n    - $f_2$: $(16, 16, 12)$\n    - $f_6$: $(0, 32, 12)$\n    Since $16 > 0$, the tuple for $f_2$ is lexicographically greater. Thus, $f_2$ has higher precedence than $f_6$.\n3.  The remaining rules have unique $S$ values: $S_4 = 24$, $S_1 = 20$, and $S_5 = 0$.\n\nThe final ranking from highest precedence to lowest is: $f_3, f_2, f_6, f_4, f_1, f_5$.\n\nWe assign distinct integer priorities $p_i$ from $6$ down to $1$:\n- Precedence 1 (highest): $f_3 \\implies p_3 = 6$\n- Precedence 2: $f_2 \\implies p_2 = 5$\n- Precedence 3: $f_6 \\implies p_6 = 4$\n- Precedence 4: $f_4 \\implies p_4 = 3$\n- Precedence 5: $f_1 \\implies p_1 = 2$\n- Precedence 6 (lowest): $f_5 \\implies p_5 = 1$\n\nThe resulting priority assignment vector is $(p_1, p_2, p_3, p_4, p_5, p_6) = (2, 5, 6, 3, 1, 4)$.\n\nPart 2: Worst-Case Per-Hop Latency Calculation\n\nThe worst-case per-hop latency $\\Delta_{\\max}$ for a safety-critical packet (matching rule $f_3$) is the sum of the maximum time spent in each stage of its journey through the switch: processing, queuing, serialization (transmission), and propagation.\n$$ \\Delta_{\\max} = t_{\\text{proc}} + t_{\\text{queue,max}} + t_{\\text{tx,CPS}} + t_{\\text{prop}} $$\n\nWe calculate each component using the provided values:\n- **Processing delay ($t_{\\text{proc}}$)**: This is given as a constant value for any packet.\n  $$ t_{\\text{proc}} = 5 \\,\\mu\\text{s} = 5 \\times 10^{-6} \\, \\text{s} $$\n\n- **Propagation delay ($t_{\\text{prop}}$)**: This is the time for a signal to travel the length of the cable.\n  $$ t_{\\text{prop}} = \\frac{d}{v} = \\frac{100 \\, \\text{m}}{2 \\times 10^{8} \\, \\text{m/s}} = 0.5 \\times 10^{-6} \\, \\text{s} = 0.5 \\,\\mu\\text{s} $$\n\n- **Serialization delay ($t_{\\text{tx,CPS}}$)**: This is the time required to place all bits of the safety-critical packet onto the link. The size is $L_{\\text{CPS}} = 100$ bytes.\n  $$ t_{\\text{tx,CPS}} = \\frac{L_{\\text{CPS}} \\times 8 \\, \\text{bits/byte}}{C} = \\frac{100 \\times 8}{1 \\times 10^{9} \\, \\text{bits/s}} = \\frac{800}{10^9} \\, \\text{s} = 0.8 \\times 10^{-6} \\, \\text{s} = 0.8 \\,\\mu\\text{s} $$\n\n- **Queuing delay ($t_{\\text{queue,max}}$)**: Packets matching $f_3$ are placed in a high-priority queue. All other packets go to a lower-priority queue. The scheduler is strict non-preemptive. The worst-case queuing delay for a high-priority packet occurs when it arrives to find the server (the link) having just started transmitting a maximum-sized lower-priority packet. Due to the non-preemptive nature, the high-priority packet must wait for this transmission to complete. This waiting time is the blocking time. The maximum size for a lower-priority (best-effort) frame is $L_{\\text{BE}} = 1500$ bytes.\n  $$ t_{\\text{queue,max}} = \\frac{L_{\\text{BE}} \\times 8 \\, \\text{bits/byte}}{C} = \\frac{1500 \\times 8}{1 \\times 10^{9} \\, \\text{bits/s}} = \\frac{12000}{10^9} \\, \\text{s} = 12 \\times 10^{-6} \\, \\text{s} = 12 \\,\\mu\\text{s} $$\n  This calculation assumes no other high-priority packets are already in the queue, which is standard for calculating the fundamental worst-case blocking in the absence of traffic characterization for the high-priority flow.\n\n- **Total Latency ($\\Delta_{\\max}$)**: We sum the individual delay components.\n  $$ \\Delta_{\\max} = (5 + 12 + 0.8 + 0.5) \\,\\mu\\text{s} = 18.3 \\,\\mu\\text{s} $$\n  The problem requires the latency to be expressed in milliseconds, rounded to four significant figures.\n  $$ \\Delta_{\\max} = 18.3 \\times 10^{-3} \\, \\text{ms} = 0.0183 \\, \\text{ms} $$\n  Rounding to four significant figures gives $0.01830 \\, \\text{ms}$.\n\nThe final combined answer is the row vector of the six priorities followed by the calculated latency.\n$$ (p_1, p_2, p_3, p_4, p_5, p_6, \\Delta_{\\max}) = (2, 5, 6, 3, 1, 4, 0.01830) $$",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2 & 5 & 6 & 3 & 1 & 4 & 0.01830 \\end{pmatrix} } $$"
        },
        {
            "introduction": "The advent of programmable data planes like P4 empowers network architects to enforce sophisticated policies directly within the switch hardware, moving beyond simple forwarding. This advanced practice  challenges you to design policies that manage per-flow deadlines, a common requirement in real-time CPS, while grappling with the practical reality of imperfect clock synchronization. Through deriving formal conditions and implementing a simulation, you will gain hands-on experience with the critical trade-offs between safety (never forwarding a late packet) and permissiveness (not dropping a potentially timely one) in uncertain environments.",
            "id": "4246533",
            "problem": "You are designing a programmable data plane policy for a Cyber-Physical System (CPS) network under Software-Defined Networking (SDN), implemented using Programming Protocol-independent Packet Processors (P4). The policy must enforce per-flow absolute deadlines carried in packet headers by comparing them to the switch’s local ingress time. Consider a global reference time $t$ used by controllers and devices, and a switch local ingress time $t_{\\mathrm{dp}}$. Assume bounded clock synchronization with respect to the global time such that $\\lvert t_{\\mathrm{dp}} - t \\rvert \\le \\varepsilon$, where $\\varepsilon$ is a known nonnegative bound in microseconds. Each packet carries a per-flow absolute deadline $d$ in microseconds, expressed in the global time $t$. The switch decides to either forward or drop based on comparing $t_{\\mathrm{dp}}$ and $d$.\n\nFundamental base:\n- Time is modeled as a continuous real variable and sampled at packet ingress, so the ingress timestamp is a sample of the switch clock $t_{\\mathrm{dp}}$, and the deadline $d$ is an absolute target in the global time $t$.\n- Bounded synchronization implies that for any packet at ingress, the true global time $t$ satisfies $t = t_{\\mathrm{dp}} - \\delta$ for some $\\delta$ with $\\delta \\in [-\\varepsilon, \\varepsilon]$.\n\nDefinitions:\n- A packet is timely if $t \\le d$ and tardy if $t > d$.\n- A policy is safe if it forwards no tardy packets for any $\\delta \\in [-\\varepsilon, \\varepsilon]$.\n- A policy is permissive if it maximizes forwarding of packets that could be timely for some $\\delta \\in [-\\varepsilon, \\varepsilon]$, potentially at the expense of safety.\n- A naive policy compares $t_{\\mathrm{dp}}$ directly to $d$ without compensating for $\\varepsilon$.\n\nYour tasks:\n1. From the bounded synchronization assumption and the definitions above, derive conditions on $t_{\\mathrm{dp}}$, $d$, and $\\varepsilon$ under which a policy is safe and under which a policy is permissive. Express your conditions as comparisons between $t_{\\mathrm{dp}}$ and $d$ adjusted with $\\varepsilon$, justified by inequalities over $t$ and $\\delta$. Do not assume specialized P4 hardware features beyond reading an ingress timestamp and matching on packet header fields.\n2. Construct a P4 program sketch in words that uses a match-action pipeline to enforce the safe policy in task $1$ relying only on timestamp comparisons and per-flow deadline fields. Clearly state what tables and actions are required at a high level and what comparisons must be performed.\n3. Implement a Python program that simulates the forwarding decisions of three policies for a given set of packets:\n   - Safe policy.\n   - Naive policy.\n   - Permissive policy.\n   The simulator must compute the following, for each test case:\n   - The count of tardy packets forwarded by the safe policy under the worst-case $\\delta = -\\varepsilon$ (switch clock lags the global time by $\\varepsilon$).\n   - The count of tardy packets forwarded by the naive policy under the worst-case $\\delta = -\\varepsilon$.\n   - The count of tardy packets forwarded by the permissive policy under the worst-case $\\delta = -\\varepsilon$.\n   - The count of packets dropped by the safe policy that could be timely under the best-case $\\delta = +\\varepsilon$ (switch clock leads the global time by $\\varepsilon$).\n   All time quantities must be treated in microseconds and all comparisons must be performed in microseconds.\n4. The program must run without inputs and must print a single line containing a comma-separated list enclosed in square brackets with the aggregated results over all test cases, in the order specified below.\n\nTest suite:\n- Test case $1$ (happy path variety):\n  - $\\varepsilon = 100$ microseconds.\n  - Packets: $(t_{\\mathrm{dp}}, d)$ pairs in microseconds: $(850, 1000)$, $(1150, 1200)$, $(1350, 1300)$.\n- Test case $2$ (boundary condition):\n  - $\\varepsilon = 0$ microseconds.\n  - Packets: $(t_{\\mathrm{dp}}, d)$ pairs in microseconds: $(1000, 1000)$, $(1001, 1000)$.\n- Test case $3$ (edge condition with tight deadlines):\n  - $\\varepsilon = 50$ microseconds.\n  - Packets: $(t_{\\mathrm{dp}}, d)$ pairs in microseconds: $(930, 1000)$, $(960, 1000)$, $(980, 1000)$.\n\nPolicies to simulate:\n- Safe policy: derive the comparison required between $t_{\\mathrm{dp}}$ and $d$ using $\\varepsilon$ to guarantee no tardy forwards for any $\\delta \\in [-\\varepsilon, \\varepsilon]$.\n- Naive policy: forward if $t_{\\mathrm{dp}} \\le d$.\n- Permissive policy: derive the comparison required between $t_{\\mathrm{dp}}$ and $d$ using $\\varepsilon$ to maximize forwarding of packets that could be timely for some $\\delta \\in [-\\varepsilon, \\varepsilon]$.\n\nOutput specification:\n- For each test case in order, output four integers on the single line, representing:\n  - The count of tardy packets forwarded by the safe policy (worst-case $\\delta = -\\varepsilon$).\n  - The count of tardy packets forwarded by the naive policy (worst-case $\\delta = -\\varepsilon$).\n  - The count of tardy packets forwarded by the permissive policy (worst-case $\\delta = -\\varepsilon$).\n  - The count of packets dropped by the safe policy that could be timely under best-case $\\delta = +\\varepsilon$.\n- Aggregate all results from the three test cases into one flat list printed as a single line, e.g., $[r_1,r_2,\\dots,r_{12}]$, where $r_i$ are integers.\n\nEnsure scientific realism and internal consistency. All mathematical symbols and numbers must be written using LaTeX. Answer all time-based quantities in microseconds. Angles are not applicable. Percentages are not applicable. The final program must be runnable as-is and produce exactly one line of output in the specified format.",
            "solution": "The problem requires the derivation of network packet forwarding policies under bounded clock uncertainty, a conceptual design of a P4 program to implement one such policy, and a Python simulation to evaluate the performance of these policies against specific metrics. The entire analysis is predicated on the model of clock synchronization error, where a switch's local clock $t_{\\mathrm{dp}}$ differs from a global reference time $t$ by at most $\\varepsilon$. The relationship is given by $t = t_{\\mathrm{dp}} - \\delta$, where $\\delta \\in [-\\varepsilon, \\varepsilon]$.\n\n### 1. Derivation of Safe and Permissive Policies\n\nThe core of this task is to translate the English definitions of \"safe\" and \"permissive\" into rigorous mathematical inequalities based on the provided time model. A packet is defined as timely if the true global time of its arrival, $t$, is no later than its absolute deadline, $d$, i.e., $t \\le d$.\n\n**Safe Policy Derivation**\n\nA policy is defined as \"safe\" if it forwards no tardy packets for any possible clock error $\\delta \\in [-\\varepsilon, \\varepsilon]$. This means a packet should be forwarded only if it is guaranteed to be timely ($t \\le d$) regardless of the actual value of $\\delta$. To guarantee this, the condition $t \\le d$ must hold even for the \"worst-case\" $\\delta$ that maximizes $t$.\n\nThe true time $t$ is given by the equation $t = t_{\\mathrm{dp}} - \\delta$. To find the maximum possible value of $t$ for a given $t_{\\mathrm{dp}}$, we must choose the value of $\\delta$ from its range $[-\\varepsilon, \\varepsilon]$ that minimizes $\\delta$. The minimum value of $\\delta$ is $-\\varepsilon$.\n\nSubstituting this into the equation for $t$ gives the maximum possible true time, $t_{\\text{max}}$:\n$$t_{\\text{max}} = t_{\\mathrm{dp}} - (-\\varepsilon) = t_{\\mathrm{dp}} + \\varepsilon$$\n\nFor the packet to be guaranteed timely, this maximum possible time must not exceed the deadline $d$:\n$$t_{\\text{max}} \\le d$$\n$$t_{\\mathrm{dp}} + \\varepsilon \\le d$$\n\nThus, the **safe policy** is to forward a packet if and only if $t_{\\mathrm{dp}} + \\varepsilon \\le d$. Any packet not meeting this condition must be dropped to maintain safety.\n\n**Permissive Policy Derivation**\n\nA policy is \"permissive\" if it \"maximizes forwarding of packets that could be timely for some $\\delta \\in [-\\varepsilon, \\varepsilon]$\". A packet \"could be timely\" if there exists at least one value of $\\delta \\in [-\\varepsilon, \\varepsilon]$ for which the condition $t \\le d$ is satisfied. To determine this, we only need to check if the condition can be met under the most favorable circumstances, i.e., the case that minimizes $t$.\n\nTo find the minimum possible value of $t$, we must choose the value of $\\delta$ from its range $[-\\varepsilon, \\varepsilon]$ that maximizes $\\delta$. The maximum value of $\\delta$ is $+\\varepsilon$.\n\nSubstituting this into the equation for $t$ gives the minimum possible true time, $t_{\\text{min}}$:\n$$t_{\\text{min}} = t_{\\mathrm{dp}} - (+\\varepsilon) = t_{\\mathrm{dp}} - \\varepsilon$$\n\nIf this minimum possible time is less than or equal to the deadline, then the packet could be timely. If even this minimum time exceeds the deadline, no possible value of $\\delta$ can make the packet timely. Therefore, the condition for a packet to be potentially timely is:\n$$t_{\\text{min}} \\le d$$\n$$t_{\\mathrm{dp}} - \\varepsilon \\le d$$\n\nThus, the **permissive policy** is to forward a packet if and only if $t_{\\mathrm{dp}} - \\varepsilon \\le d$. This maximizes the set of forwarded packets that are not guaranteed to be tardy.\n\nThe **naive policy** is given in the problem statement as forwarding if $t_{\\mathrm{dp}} \\le d$.\n\n### 2. P4 Program Sketch for the Safe Policy\n\nA P4 program can implement the safe policy in its ingress pipeline. The switch hardware must provide access to an ingress timestamp and support basic arithmetic operations. The design does not require complex features like floating-point arithmetic or stateful memory beyond registers for configuration.\n\n1.  **Header and Metadata**: The parser must be configured to recognize a custom header, say `scheduling_h`, which contains the absolute deadline `d`. P4 architectures provide intrinsic metadata, most importantly `standard_metadata.ingress_tstamp`, which corresponds to $t_{\\mathrm{dp}}$. Both $d$ and $t_{\\mathrm{dp}}$ would typically be represented as fixed-point numbers or large integers (e.g., $48$-bit or $64$-bit) representing microseconds.\n\n2.  **Control Plane Configuration**: The clock error bound $\\varepsilon$ is a system-wide parameter. It should be configured by the SDN controller and stored in a P4 register, which is accessible at runtime. For example, a register array `epsilon_val` of size $1$ could hold the value of $\\varepsilon$.\n\n3.  **Ingress Control Logic**: The core logic resides in the `apply` block of the ingress control pipeline.\n    -   **Actions**: Two simple actions are needed:\n        -   `action_forward()`: An empty action that allows the packet to proceed through the pipeline.\n        -   `action_drop()`: An action that sets metadata fields to instruct the switch to discard the packet. A common method is to set the `egress_spec` to a designated drop port.\n    -   **Implementation**: The safe policy condition, $t_{\\mathrm{dp}} + \\varepsilon \\le d$, is implemented directly. In P4-like pseudocode:\n        ```\n        control IngressPipeline(...) {\n            // Define variables for clarity\n            time_us_t current_t_dp = standard_metadata.ingress_tstamp;\n            time_us_t deadline_d = hdr.scheduling_h.deadline;\n            time_us_t epsilon;\n            \n            // Read epsilon from a register set by the controller\n            epsilon_register.read(epsilon, (bit<32>)0);\n            \n            // Apply the safe policy condition\n            if (current_t_dp + epsilon > deadline_d) {\n                action_drop.apply();\n            } else {\n                action_forward.apply();\n            }\n        }\n        ```\n    This logic requires only reading header fields, reading intrinsic metadata, reading a register, performing one addition and one comparison, and then conditionally executing an action. These are all fundamental operations in a P4-programmable data plane.\n\n### 3. Simulation Logic\n\nThe Python program simulates the forwarding decisions and evaluates the policies based on the provided metrics.\n\n**Policy Implementation:**\nFor each packet with ingress timestamp $t_{\\mathrm{dp}}$ and deadline $d$, given an error bound $\\varepsilon$:\n-   **Safe Policy Decision**: Forward if $t_{\\mathrm{dp}} + \\varepsilon \\le d$.\n-   **Naive Policy Decision**: Forward if $t_{\\mathrm{dp}} \\le d$.\n-   **Permissive Policy Decision**: Forward if $t_{\\mathrm{dp}} - \\varepsilon \\le d$.\n\n**Metric Calculation:**\n\n1.  **Tardy Packets Forwarded (Worst-Case $\\delta = -\\varepsilon$)**: This metric quantifies the lack of safety. The \"worst case\" for safety is the one that maximizes the true time $t$, which occurs when the switch clock $t_{\\mathrm{dp}}$ lags behind the global clock $t$ by the maximum amount, i.e., $\\delta = -\\varepsilon$. In this scenario, the true time is $t = t_{\\mathrm{dp}} - (-\\varepsilon) = t_{\\mathrm{dp}} + \\varepsilon$. A packet is truly tardy if $t > d$, or $t_{\\mathrm{dp}} + \\varepsilon > d$. For each policy, we count the packets for which the policy decides to forward AND the condition $t_{\\mathrm{dp}} + \\varepsilon > d$ holds. The safe policy should, by its definition, yield a count of $0$.\n\n2.  **Packets Dropped Unnecessarily (Best-Case $\\delta = +\\varepsilon$)**: This metric quantifies the loss of goodput for the safe policy. A packet is \"unnecessarily\" dropped if it is dropped by the policy, but it could have been timely. A packet \"could be timely\" if there is at least one $\\delta \\in [-\\varepsilon, \\varepsilon]$ for which $t \\le d$. The \"best case\" for timeliness occurs when $t$ is minimized, which is when $\\delta = +\\varepsilon$, giving $t = t_{\\mathrm{dp}} - \\varepsilon$. If this minimal time $t$ is no greater than $d$ (i.e., $t_{\\mathrm{dp}} - \\varepsilon \\le d$), the packet could have been timely. The safe policy drops a packet if $t_{\\mathrm{dp}} + \\varepsilon > d$.  Therefore, this counter increments for each packet where both $t_{\\mathrm{dp}} + \\varepsilon > d$ (safe policy drops) and $t_{\\mathrm{dp}} - \\varepsilon \\le d$ (packet could have been timely) are true.",
            "answer": "```python\nimport numpy as np\n# The numpy import is included to adhere to the specified execution environment,\n# though it is not strictly necessary for this problem's logic.\n\ndef solve():\n    \"\"\"\n    Simulates packet forwarding policies under bounded clock uncertainty and\n    calculates performance metrics.\n    \"\"\"\n    test_cases = [\n        {\n            \"epsilon\": 100,\n            \"packets\": [(850, 1000), (1150, 1200), (1350, 1300)],\n        },\n        {\n            \"epsilon\": 0,\n            \"packets\": [(1000, 1000), (1001, 1000)],\n        },\n        {\n            \"epsilon\": 50,\n            \"packets\": [(930, 1000), (960, 1000), (980, 1000)],\n        },\n    ]\n\n    aggregated_results = []\n\n    for case in test_cases:\n        epsilon = case[\"epsilon\"]\n        packets = case[\"packets\"]\n\n        # Initialize counters for the current test case\n        safe_tardy_forwards = 0\n        naive_tardy_forwards = 0\n        permissive_tardy_forwards = 0\n        safe_unnecessary_drops = 0\n\n        for t_dp, d in packets:\n            # --- Tardy Packet Forwarding Metrics (Worst-Case delta = -epsilon) ---\n            # In this scenario, true time t = t_dp + epsilon.\n            # A packet is truly tardy if t > d, which means t_dp + epsilon > d.\n            is_tardy_worst_case = (t_dp + epsilon > d)\n\n            # 1. Safe Policy: Forwards if t_dp + epsilon <= d.\n            # A tardy packet is forwarded if (t_dp + epsilon <= d) AND (t_dp + epsilon > d).\n            # This is a contradiction, so safe_tardy_forwards must be 0.\n            if (t_dp + epsilon <= d) and is_tardy_worst_case:\n                safe_tardy_forwards += 1\n\n            # 2. Naive Policy: Forwards if t_dp <= d.\n            if (t_dp <= d) and is_tardy_worst_case:\n                naive_tardy_forwards += 1\n\n            # 3. Permissive Policy: Forwards if t_dp - epsilon <= d.\n            if (t_dp - epsilon <= d) and is_tardy_worst_case:\n                permissive_tardy_forwards += 1\n\n            # --- Unnecessary Drop Metric for Safe Policy (Best-Case delta = +epsilon) ---\n            # A packet is dropped by the safe policy if t_dp + epsilon > d.\n            safe_policy_drops = (t_dp + epsilon > d)\n\n            # A packet could be timely if there exists a delta where t <= d.\n            # The best case for timeliness is when t is minimized, i.e., delta = +epsilon.\n            # So, true time t = t_dp - epsilon.\n            # The packet could have been timely if t_dp - epsilon <= d.\n            could_be_timely = (t_dp - epsilon <= d)\n            \n            # An unnecessary drop occurs if the safe policy drops a packet that could have been timely.\n            if safe_policy_drops and could_be_timely:\n                safe_unnecessary_drops += 1\n        \n        # Append the results for the current test case\n        aggregated_results.extend([\n            safe_tardy_forwards,\n            naive_tardy_forwards,\n            permissive_tardy_forwards,\n            safe_unnecessary_drops,\n        ])\n\n    # Print the final aggregated results in the specified format\n    print(f\"[{','.join(map(str, aggregated_results))}]\")\n\nsolve()\n```"
        }
    ]
}