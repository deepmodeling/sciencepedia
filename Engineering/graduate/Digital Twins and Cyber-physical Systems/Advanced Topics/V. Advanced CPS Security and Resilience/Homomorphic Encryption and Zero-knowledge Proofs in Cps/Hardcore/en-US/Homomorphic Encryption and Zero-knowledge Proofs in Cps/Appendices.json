{
    "hands_on_practices": [
        {
            "introduction": "To design efficient privacy-preserving systems, it is crucial to understand the costs of fundamental homomorphic operations. In leveled homomorphic encryption schemes like Brakerski–Fan–Vercauteren (BFV), operations are not equal in cost; while additions are relatively inexpensive, multiplications significantly increase ciphertext complexity and require a computationally intensive maintenance step called relinearization. This practice  will help you quantify this core trade-off by calculating the necessary cryptographic overhead for a simple arithmetic circuit.",
            "id": "4226129",
            "problem": "A Cyber-Physical System (CPS) digital twin must evaluate an encrypted state update over sensor streams using the Brakerski–Fan–Vercauteren (BFV) leveled homomorphic encryption scheme. The computation is expressed as an arithmetic circuit with $3$ multiplication gates and $10$ addition gates over ciphertext inputs, and its correctness will later be attested by a Zero-Knowledge Proof (ZKP) of computation without revealing plaintexts. Assume the following foundations of BFV homomorphic evaluation:\n\n- A BFV ciphertext is represented as a pair, and ciphertext-ciphertext addition produces a ciphertext whose representation length remains unchanged.\n- Ciphertext-ciphertext multiplication produces a ciphertext with an increased representation length that must be brought back down using relinearization with precomputed evaluation keys to continue evaluation in a leveled setting without bootstrapping.\n- No rescaling is used in BFV exact arithmetic.\n\nUnder these conditions, and assuming every multiplication gate in the circuit is a ciphertext-ciphertext multiplication and that relinearization is applied immediately after each such multiplication to maintain a constant ciphertext representation length throughout the evaluation, determine the total number of ciphertext-ciphertext multiplications and the total number of relinearizations required to evaluate the circuit. Provide your final answer as a row matrix in the order (total ciphertext-ciphertext multiplications, total relinearizations). No rounding is needed, and no units apply.",
            "solution": "The problem requires an analysis of the computational cost, specifically in terms of multiplication and relinearization operations, for evaluating an arithmetic circuit using the Brakerski–Fan–Vercauteren (BFV) homomorphic encryption scheme.\n\nFirst, a validation of the problem statement is in order.\n\n**Step 1: Extract Givens**\n- The computational model is an arithmetic circuit evaluated by a Cyber-Physical System (CPS) digital twin.\n- The encryption scheme is BFV leveled homomorphic encryption.\n- The circuit consists of $3$ multiplication gates and $10$ addition gates.\n- Inputs to the gates are ciphertexts.\n- The correctness of the computation is to be later verified by a Zero-Knowledge Proof (ZKP).\n- BFV ciphertext-ciphertext addition does not change the ciphertext representation length.\n- BFV ciphertext-ciphertext multiplication increases the ciphertext representation length.\n- Relinearization is a mandatory operation to reduce the ciphertext representation length after a multiplication.\n- Relinearization is applied immediately after each ciphertext-ciphertext multiplication.\n- Every multiplication gate is a ciphertext-ciphertext multiplication.\n- The evaluation is leveled and does not use bootstrapping.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded. The description of the BFV homomorphic encryption scheme's properties—specifically, the contrast between addition and multiplication—is accurate. Ciphertext addition in BFV is a component-wise operation on underlying polynomials, which preserves the ciphertext's form (a pair of polynomials). In contrast, ciphertext multiplication involves tensor products, increasing the ciphertext from a pair to a triplet (or from length $k+1$ to $2k+1$ in a general setting), which necessitates the relinearization procedure to return it to the standard pair format for subsequent operations. The problem's context of a digital twin in a CPS using secure computation is a valid and active area of research.\n\nThe problem is well-posed. It provides all necessary data and constraints to arrive at a deterministic answer. The question is precise and asks for two specific quantities. The assumptions are stated explicitly.\n\nThe problem is objective and free of any subjective or scientifically unsound claims. It is a formalizable problem within the field of applied cryptography.\n\n**Step 3: Verdict and Action**\nThe problem statement is deemed valid. A formal solution will now be derived.\n\nThe problem asks for two quantities: the total number of ciphertext-ciphertext multiplications and the total number of relinearizations.\n\nLet $N_{mult}$ be the total number of ciphertext-ciphertext multiplications and $N_{relin}$ be the total number of relinearizations.\n\nThe problem explicitly states that the arithmetic circuit comprises $3$ multiplication gates. It further specifies the assumption that \"every multiplication gate in the circuit is a ciphertext-ciphertext multiplication.\" This directly determines the value of $N_{mult}$.\n$$\nN_{mult} = 3\n$$\nThe number of addition gates, given as $10$, is extraneous information with respect to the question asked, as the problem states that ciphertext-ciphertext addition does not require any size-reducing maintenance operations like relinearization.\n\nNext, we determine the total number of relinearizations, $N_{relin}$. The problem provides a clear and unambiguous rule for the evaluation procedure: \"relinearization is applied immediately after each such multiplication to maintain a constant ciphertext representation length.\" This establishes a direct, one-to-one correspondence between a ciphertext-ciphertext multiplication operation and a relinearization operation. For every multiplication that occurs, a subsequent relinearization must be performed.\n\nGiven that there are $N_{mult} = 3$ ciphertext-ciphertext multiplications, it follows logically and directly from the stated procedure that there must be an equal number of relinearization operations.\n$$\nN_{relin} = N_{mult}\n$$\nSubstituting the value of $N_{mult}$:\n$$\nN_{relin} = 3\n$$\nTherefore, the evaluation of the specified arithmetic circuit requires $3$ ciphertext-ciphertext multiplications and $3$ relinearizations. The final answer should be presented as a row matrix containing these two values in the requested order.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3 & 3\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Many cyber-physical systems operate on real numbers, making approximate homomorphic encryption schemes like Cheon–Kim–Kim–Song (CKKS) essential. Unlike exact schemes, CKKS trades perfect precision for greater efficiency, but this requires careful parameterization to manage noise growth and a finite \"modulus budget\" that is consumed with each multiplication. This hands-on exercise  challenges you to perform this critical design task: sizing the cryptographic parameters to meet a desired level of numerical precision for a multi-step encrypted computation.",
            "id": "4226124",
            "problem": "A cyber-physical system (CPS) digital twin computes a nonlinear encrypted control law using the Cheon–Kim–Kim–Song (CKKS) approximate homomorphic encryption scheme. The control algorithm has a longest ciphertext–ciphertext multiplication chain depth of $D = 6$ per evaluation. The system designer specifies a desired output dynamic range bound $R_{\\text{out}} = 4$ (meaning the magnitude of the true plaintext output is bounded by $4$) and a target relative precision requirement $\\varepsilon = 1.5 \\times 10^{-11}$ at the final decrypted output.\n\nAssume the following well-tested CKKS properties and modeling assumptions:\n- CKKS encodes real values as fixed-point with a scale $\\Delta > 0$; the quantization resolution is on the order of $\\Delta^{-1}$.\n- Each ciphertext–ciphertext multiplication followed by rescaling to restore the scale consumes one prime in the modulus chain whose bit-size is approximately $\\log_{2}(\\Delta)$; the rescaling operation reduces the modulus by that prime’s bit-size.\n- The total absolute output error from fixed-point quantization and rescaling in this control evaluation can be upper bounded by $E \\leq \\kappa \\Delta^{-1}$ for a known algorithm-dependent constant $\\kappa$, derived from coefficient growth and operation counts (you may take $\\kappa = 100$ for this controller).\n- Multiplication by plaintext constants and additions do not consume levels and do not change the scale schedule for the purpose of this sizing calculation.\n\nDesign a uniform scale schedule that uses the same base scale $\\Delta$ at each level and determine the minimal modulus chain sizing required so that the final absolute output error bound $E$ is at most $\\varepsilon R_{\\text{out}}$. For sizing, include one initial prime to inject the base scale (so the chain must include $D+1$ primes, each of bit-size $\\log_{2}(\\Delta)$), and neglect any auxiliary primes for relinearization or key switching.\n\nCompute the minimal total modulus budget in bits, defined as $Q_{\\text{total}} = (D+1)\\log_{2}(\\Delta)$, that meets the dynamic range and precision requirements under these assumptions. Round your final numeric answer to four significant figures.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of approximate homomorphic encryption (specifically the CKKS scheme), is well-posed with a unique solution, and is expressed using objective and precise technical language. All necessary data and models are provided to solve for the requested quantity.\n\nThe objective is to compute the minimal total modulus budget, $Q_{\\text{total}}$, required for a homomorphic evaluation of a control law. The problem provides the formula for this budget:\n$$Q_{\\text{total}} = (D+1)\\log_{2}(\\Delta)$$\nwhere $D$ is the multiplicative depth and $\\Delta$ is the base scale factor. We are given $D=6$. The task reduces to finding the minimal required scale factor $\\Delta$ that satisfies the system's precision requirements.\n\nThe system requires a final relative precision of $\\varepsilon = 1.5 \\times 10^{-11}$. The output of the computation has a dynamic range bounded by $R_{\\text{out}} = 4$. The target relative precision can be converted to a target absolute error bound, $E_{\\text{target}}$, for the final output. The maximum allowable absolute error is the product of the relative precision and the maximum possible magnitude of the output:\n$$E_{\\text{target}} = \\varepsilon R_{\\text{out}}$$\n\nThe problem provides a model for the upper bound on the absolute error, $E$, introduced by the CKKS computation:\n$$E \\leq \\kappa \\Delta^{-1}$$\nwhere $\\kappa=100$ is a constant related to the specific algorithm.\n\nTo satisfy the precision requirement, the actual error bound from the computation must be no greater than the target absolute error bound. Therefore, we must enforce the condition:\n$$\\kappa \\Delta^{-1} \\leq E_{\\text{target}}$$\nSubstituting the expression for $E_{\\text{target}}$, we get:\n$$\\kappa \\Delta^{-1} \\leq \\varepsilon R_{\\text{out}}$$\nTo find the minimal total modulus budget, we must use the minimal scale factor $\\Delta$ that satisfies this condition. The minimal $\\Delta$ is found by solving the inequality for $\\Delta$:\n$$\\frac{\\kappa}{\\varepsilon R_{\\text{out}}} \\leq \\Delta$$\nThus, the minimal required scale factor, which we will denote $\\Delta_{\\min}$, is:\n$$\\Delta_{\\min} = \\frac{\\kappa}{\\varepsilon R_{\\text{out}}}$$\n\nNow, we can substitute the given numerical values: $D=6$, $\\kappa=100$, $\\varepsilon=1.5 \\times 10^{-11}$, and $R_{\\text{out}}=4$.\nFirst, we compute $\\Delta_{\\min}$:\n$$\\Delta_{\\min} = \\frac{100}{(1.5 \\times 10^{-11}) \\times 4} = \\frac{100}{6 \\times 10^{-11}} = \\frac{50}{3} \\times 10^{11}$$\n\nNext, we substitute this value of $\\Delta_{\\min}$ and the given value of $D$ into the formula for $Q_{\\text{total}}$:\n$$Q_{\\text{total}} = (6+1)\\log_{2}\\left(\\frac{50}{3} \\times 10^{11}\\right) = 7 \\log_{2}\\left(\\frac{50}{3} \\times 10^{11}\\right)$$\nTo compute the base-$2$ logarithm, we can use the change of base formula, $\\log_{2}(x) = \\frac{\\ln(x)}{\\ln(2)}$:\n$$Q_{\\text{total}} = 7 \\times \\frac{\\ln\\left(\\frac{50}{3} \\times 10^{11}\\right)}{\\ln(2)}$$\nCalculating the value of the argument of the logarithm:\n$$\\frac{50}{3} \\times 10^{11} \\approx 1.666... \\times 10^{12}$$\nNow, we compute the numerical value for $Q_{\\text{total}}$:\n$$Q_{\\text{total}} \\approx 7 \\times \\frac{\\ln(1.666... \\times 10^{12})}{\\ln(2)}$$\n$$Q_{\\text{total}} \\approx 7 \\times \\frac{28.1418468}{0.6931472}$$\n$$Q_{\\text{total}} \\approx 7 \\times 40.60018$$\n$$Q_{\\text{total}} \\approx 284.20126$$\n\nThe problem requires the final answer to be rounded to four significant figures. The first four significant figures of $284.20126$ are $2$, $8$, $4$, and $2$. The fifth significant figure is $0$, so we round down (i.e., we truncate).\n$$Q_{\\text{total}} \\approx 284.2$$\nThis represents the minimal total bit-size of the modulus chain required to meet the specified design constraints.",
            "answer": "$$\\boxed{284.2}$$"
        },
        {
            "introduction": "In secure cyber-physical systems, privacy is not enough; we must also guarantee the integrity of data and computations. Combining homomorphic encryption with zero-knowledge proofs (ZKPs) allows a prover to attest to the correctness of an encrypted operation without revealing any secret information. This powerful synthesis, however, introduces its own overhead, and this practice  provides a hands-on analysis of these real-world costs by having you calculate the total network-wide power consumption—spanning both communication and computation—required to augment an encrypted sensor network with ZKP-based verification.",
            "id": "4226091",
            "problem": "A time-synchronized Cyber-Physical System (CPS) network supports a Digital Twin by streaming encrypted sensor measurements to an aggregator for homomorphic fusion. Each of $N$ sensors emits messages at sampling rate $f_{s}$, where each message contains a single Paillier ciphertext under a $2048$-bit modulus. Paillier encryption maps plaintexts into the multiplicative group modulo $n^{2}$, so a ciphertext is a single element modulo $n^{2}$; for $n$ of bit-length $2048$, the ciphertext bit-length is $4096$ (i.e., $512$ bytes). To prevent maliciously crafted ciphertexts while preserving privacy, each message is augmented with a non-interactive Schnorr-style proof of knowledge (via the Fiat–Shamir transform) in an elliptic curve group $\\mathbb{G}$ of prime order $q \\approx 2^{256}$, with generator $G$. The prover has secret key $x \\in \\mathbb{Z}_{q}$ and public key $X = x G$, and constructs per-message proof elements: the commitment $t = r G$ with random $r \\in \\mathbb{Z}_{q}$, and response $s = r + c x \\bmod q$, where the challenge $c \\in \\mathbb{Z}_{q}$ is computed as a hash of the transcript fields using a cryptographic hash function. The network uses compressed point encoding for elements of $\\mathbb{G}$, so each group element occupies $33$ bytes, while scalars in $\\mathbb{Z}_{q}$ occupy $32$ bytes. The non-interactive proof transcript in each message consists of the pair $(t, s)$.\n\nAssume the following realistic performance and energy parameters for the sensor’s microcontroller and radio:\n- Each sensor’s CPU frequency is $f_{\\text{cpu}} = 10^{8}$ Hz.\n- While executing cryptography, the CPU consumes average dynamic power $P_{\\text{cpu}} = 0.5$ W, yielding an energy per cycle of $E_{\\text{cycle}} = P_{\\text{cpu}} / f_{\\text{cpu}}$.\n- One elliptic-curve scalar multiplication (to compute $t = r G$) costs $C_{\\text{ec}} = 2.5 \\times 10^{6}$ cycles.\n- The Fiat–Shamir hash uses $32$-byte output and has computational cost $12$ cycles per input byte plus a fixed $80$ cycles per invocation. The hash input concatenates the Paillier ciphertext ($512$ bytes), the commitment $t$ ($33$ bytes), the public key $X$ ($33$ bytes), and a per-message nonce ($8$ bytes).\n- A single modular multiplication in $\\mathbb{Z}_{q}$ costs $C_{\\text{mul}} = 2000$ cycles, and modular addition costs $C_{\\text{add}} = 50$ cycles.\n- Randomness generation for $r$ costs $C_{\\text{rand}} = 1000$ cycles.\n- Radio transmission energy is $e_{\\text{tx}} = 50 \\times 10^{-9}$ J per transmitted bit.\n\nSuppose there are $N = 300$ sensors, each sampling at $f_{s} = 10$ Hz. Define the communication overhead as the additional transmitted bits per second (network-wide) due to the Schnorr-style proof, and the computational overhead as the additional CPU dynamic power (Watts) attributable to computing the proof network-wide. Compute the total overhead power, defined as the sum of the radio transmission power for the added proof bits and the CPU dynamic power for the added proof computations across all sensors, under the above parameters.\n\nExpress the final result in Watts and round your answer to four significant figures.",
            "solution": "The problem requires the calculation of the total overhead power introduced by adding a non-interactive Schnorr-style proof of knowledge to messages in a Cyber-Physical System (CPS). This total overhead power, denoted as $P_{\\text{total}}$, is the sum of the power overhead from radio transmissions, $P_{\\text{comm}}$, and the power overhead from CPU computations, $P_{\\text{comp}}$.\n\n$$\nP_{\\text{total}} = P_{\\text{comm}} + P_{\\text{comp}}\n$$\n\nWe will calculate each component separately.\n\nFirst, we calculate the communication overhead power, $P_{\\text{comm}}$. This is the power required to transmit the additional bits of the proof across the entire network. The proof consists of a pair $(t, s)$, where $t$ is an elliptic curve point and $s$ is a scalar.\n\nThe size of the commitment $t$, which is a compressed elliptic curve point, is given as $L_t = 33$ bytes.\nThe size of the response $s$, which is a scalar in $\\mathbb{Z}_q$, is given as $L_s = 32$ bytes.\n\nThe total size of the proof per message, $L_{\\text{proof}}$, is the sum of the sizes of its components:\n$$\nL_{\\text{proof}} = L_t + L_s = 33 \\text{ bytes} + 32 \\text{ bytes} = 65 \\text{ bytes}\n$$\nTo calculate the power, we need this size in bits. Since $1$ byte = $8$ bits, the size in bits is:\n$$\nL_{\\text{proof, bits}} = L_{\\text{proof}} \\times 8 = 65 \\times 8 = 520 \\text{ bits}\n$$\nThe network consists of $N=300$ sensors, each transmitting messages at a sampling rate of $f_s = 10 \\text{ Hz}$. The total network-wide bit rate for the proofs, $R_{\\text{proof}}$, is:\n$$\nR_{\\text{proof}} = N \\times f_s \\times L_{\\text{proof, bits}}\n$$\nSubstituting the given values:\n$$\nR_{\\text{proof}} = 300 \\times 10 \\text{ s}^{-1} \\times 520 \\text{ bits} = 1,560,000 \\text{ bits/s}\n$$\nThe energy to transmit a single bit is given as $e_{\\text{tx}} = 50 \\times 10^{-9} \\text{ J/bit}$. The communication power is the product of the bit rate and the energy per bit:\n$$\nP_{\\text{comm}} = R_{\\text{proof}} \\times e_{\\text{tx}}\n$$\n$$\nP_{\\text{comm}} = 1,560,000 \\text{ bits/s} \\times (50 \\times 10^{-9} \\text{ J/bit}) = 0.078 \\text{ W}\n$$\n\nNext, we calculate the computational overhead power, $P_{\\text{comp}}$. This is the average CPU dynamic power consumed for computing the proofs across all sensors. First, we must determine the number of CPU cycles required to generate a single proof, $C_{\\text{proof}}$. The generation process consists of several steps:\n1.  Generation of a random scalar $r$: $C_{\\text{rand}} = 1000$ cycles.\n2.  Computation of the commitment $t = rG$: This is one elliptic-curve scalar multiplication, costing $C_{\\text{ec}} = 2.5 \\times 10^6$ cycles.\n3.  Computation of the challenge $c$ via hashing: The cost depends on the input size. The input is the concatenation of the Paillier ciphertext ($L_{\\text{cipher}} = 512$ bytes), the commitment $t$ ($L_t = 33$ bytes), the public key $X$ ($L_X = 33$ bytes), and a nonce ($L_{\\text{nonce}} = 8$ bytes). The total input length is:\n$$\nL_{\\text{hash\\_in}} = L_{\\text{cipher}} + L_t + L_X + L_{\\text{nonce}} = 512 + 33 + 33 + 8 = 586 \\text{ bytes}\n$$\nThe cost of hashing is $12$ cycles per input byte plus a fixed $80$ cycles. Thus, the number of cycles for the hash computation, $C_{\\text{hash}}$, is:\n$$\nC_{\\text{hash}} = (12 \\text{ cycles/byte} \\times L_{\\text{hash\\_in}}) + 80 \\text{ cycles} = (12 \\times 586) + 80 = 7032 + 80 = 7112 \\text{ cycles}\n$$\n4.  Computation of the response $s = r + cx \\pmod q$: This involves one modular multiplication (cost $C_{\\text{mul}} = 2000$ cycles) and one modular addition (cost $C_{\\text{add}} = 50$ cycles). The total cost is:\n$$\nC_{s} = C_{\\text{mul}} + C_{\\text{add}} = 2000 + 50 = 2050 \\text{ cycles}\n$$\nThe total number of cycles per proof is the sum of the cycles for each step:\n$$\nC_{\\text{proof}} = C_{\\text{rand}} + C_{\\text{ec}} + C_{\\text{hash}} + C_{s}\n$$\n$$\nC_{\\text{proof}} = 1000 + 2,500,000 + 7112 + 2050 = 2,510,162 \\text{ cycles}\n$$\nThe energy consumed per CPU cycle, $E_{\\text{cycle}}$, is the CPU power $P_{\\text{cpu}} = 0.5 \\text{ W}$ divided by the CPU frequency $f_{\\text{cpu}} = 10^8 \\text{ Hz}$:\n$$\nE_{\\text{cycle}} = \\frac{P_{\\text{cpu}}}{f_{\\text{cpu}}} = \\frac{0.5 \\text{ W}}{10^8 \\text{ Hz}} = 5 \\times 10^{-9} \\text{ J/cycle}\n$$\nThe total energy to compute one proof, $E_{\\text{proof}}$, is:\n$$\nE_{\\text{proof}} = C_{\\text{proof}} \\times E_{\\text{cycle}} = 2,510,162 \\text{ cycles} \\times (5 \\times 10^{-9} \\text{ J/cycle}) = 0.01255081 \\text{ J}\n$$\nThe average computational power for one sensor is the energy per proof multiplied by the rate at which proofs are generated, $f_s$:\n$$\nP_{\\text{comp,1}} = E_{\\text{proof}} \\times f_s = 0.01255081 \\text{ J} \\times 10 \\text{ Hz} = 0.1255081 \\text{ W}\n$$\nThe total computational power for the entire network of $N=300$ sensors is:\n$$\nP_{\\text{comp}} = N \\times P_{\\text{comp,1}} = 300 \\times 0.1255081 \\text{ W} = 37.65243 \\text{ W}\n$$\n\nFinally, the total overhead power $P_{\\text{total}}$ is the sum of the communication and computational power overheads:\n$$\nP_{\\text{total}} = P_{\\text{comm}} + P_{\\text{comp}} = 0.078 \\text{ W} + 37.65243 \\text{ W} = 37.73043 \\text{ W}\n$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\nP_{\\text{total}} \\approx 37.73 \\text{ W}\n$$",
            "answer": "$$\n\\boxed{37.73}\n$$"
        }
    ]
}