{
    "hands_on_practices": [
        {
            "introduction": "对抗性攻击通常旨在做到难以察觉。本练习将探讨在传感器层面，即连续物理信号转换为离散数字值的地方，这种隐蔽性的基本限制。通过计算量化传感器所能容忍的最大“隐形”扰动 ，您将具体理解物理硬件的限制如何创造出可预测的漏洞。",
            "id": "4204828",
            "problem": "一个支持学习的信息物理系统 (CPS) 使用一个数字孪生 (DT) 状态估计器，该估计器消耗量化的传感器测量值。每个标量传感器通道被建模为一个理想的均匀中步长量化器，其步长为 $\\,\\Delta > 0\\,$，对称饱和极限为 $\\,y_{\\max} > 0\\,$。量化前的模拟测量值为 $\\,y \\in \\mathbb{R}\\,$，攻击者在量化前注入一个加性扰动 $\\,\\delta \\in \\mathbb{R}\\,$，并满足约束 $\\,\\|\\delta\\|_{\\infty} \\le \\epsilon\\,$（对于标量，$\\,\\|\\delta\\|_{\\infty} = |\\delta|$）。测量值首先经过 $\\,\\mathrm{sat}(x) = \\mathrm{sgn}(x)\\,\\min\\{|x|,\\,y_{\\max}\\}\\,$ 进行饱和处理，然后通过中步长舍入映射进行量化：\n$$\nQ(x) \\;=\\; \\Delta \\cdot \\mathrm{clip}\\!\\left(\\mathrm{round}\\!\\left(\\frac{x}{\\Delta}\\right),\\, -K,\\, K\\right), \n\\quad K \\;=\\; \\left\\lfloor \\frac{y_{\\max}}{\\Delta} \\right\\rfloor,\n$$\n其中 $\\,\\mathrm{round}(\\cdot)\\,$ 表示舍入到最近的整数，而 $\\,\\mathrm{clip}(z,-K,K) = \\max\\{-K, \\min\\{z, K\\}\\}\\,$ 在码域中强制实现饱和。\n\nDT的不可感知性准则是数字输出码在攻击下不发生改变，即：\n$$\nQ\\!\\big(\\mathrm{sat}(y+\\delta)\\big) \\;=\\; Q\\!\\big(\\mathrm{sat}(y)\\big).\n$$\n假设CPS校准将标称测量值保持在其量化单元的中心并且远离饱和，即存在 $\\,k \\in \\mathbb{Z}\\,$ 使得 $\\,y = k\\,\\Delta\\,$ 且 $\\,|y| \\le y_{\\max} - \\frac{\\Delta}{2}\\,$。\n\n仅从上述定义以及均匀量化和饱和的标准属性出发，推导：\n1. 最大的 $\\,\\epsilon\\,$，使得每个满足 $\\,\\|\\delta\\|_{\\infty} \\le \\epsilon\\,$ 的对抗性扰动在量化后，在上述定义的意义下，仍然是不可感知的。\n2. 在这些约束下的有效攻击功率，定义为：\n$$\nP_{\\mathrm{eff}} \\;=\\; \\sup_{\\;|\\delta| \\le \\epsilon,\\;\\; Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))} \\; \\delta^{2}.\n$$\n\n将 $\\,\\epsilon\\,$ 以伏特 (V) 表示，$\\,P_{\\mathrm{eff}}\\,$ 以平方伏特 ($\\mathrm{V}^{2}$) 表示。请以单个闭式解析表达式的形式提供您的最终答案。无需进行四舍五入。",
            "solution": "该问题被验证为具有科学依据、良定、客观且自洽。所提供的带饱和的量化器模型和对抗性攻击的表述构成了信号处理和控制理论中的一个标准可解问题。我们可以开始求解。\n\n问题要求两个量：保证不可感知性的最大扰动容限 $\\epsilon$，以及在此约束下的有效攻击功率 $P_{\\mathrm{eff}}$。\n\n首先，我们分析未受扰动系统的输出 $Q(\\mathrm{sat}(y))$。\n标称测量值给定为 $y = k\\Delta$，其中 $k \\in \\mathbb{Z}$ 是某个整数。\n它还受到约束 $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$。\n由于 $\\Delta > 0$，这意味着 $|y|  y_{\\max}$。\n饱和函数为 $\\mathrm{sat}(x) = \\mathrm{sgn}(x)\\min\\{|x|, y_{\\max}\\}$。因为 $|y|  y_{\\max}$，我们有 $\\mathrm{sat}(y) = y$。\n量化函数为 $Q(x) = \\Delta \\cdot \\mathrm{clip}(\\mathrm{round}(x/\\Delta), -K, K)$，其中 $K = \\lfloor y_{\\max}/\\Delta \\rfloor$。\n对于未受扰动的输入 $y = k\\Delta$，舍入函数的参数为 $\\frac{y}{\\Delta} = \\frac{k\\Delta}{\\Delta} = k$。由于 $k$ 是整数，$\\mathrm{round}(k) = k$。\n因此，裁剪函数的参数是 $k$。给定条件 $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$ 意味着 $|k\\Delta| \\le y_{\\max} - \\frac{\\Delta}{2}$，即 $|k| \\le \\frac{y_{\\max}}{\\Delta} - \\frac{1}{2}$。由于 $k$ 是整数，这要求 $|k| \\le \\lfloor \\frac{y_{\\max}}{\\Delta} - \\frac{1}{2} \\rfloor$。对于任意 $z \\in \\mathbb{R}$，由于 $\\lfloor z-\\frac{1}{2} \\rfloor \\le \\lfloor z \\rfloor$，因此可以得出 $|k| \\le \\lfloor \\frac{y_{\\max}}{\\Delta} \\rfloor = K$。\n因此，对于索引 $k$，裁剪函数是无效的：$\\mathrm{clip}(k, -K, K) = k$。\n未受扰动信号的输出为 $Q(\\mathrm{sat}(y)) = Q(y) = \\Delta \\cdot k = k\\Delta$。\n\n接下来，我们分析不可感知性准则：$Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y)) = k\\Delta$。\n令 $x' = \\mathrm{sat}(y+\\delta)$。该准则变为 $Q(x') = k\\Delta$。\n根据我们发现的 $|k| \\le K$，这可以简化为 $\\Delta \\cdot \\mathrm{round}(x'/\\Delta) = k\\Delta$，这又要求 $\\mathrm{round}(x'/\\Delta) = k$。\n为了使 $\\mathrm{round}(\\cdot)$ 函数的输出为整数 $k$，其参数必须位于与 $k$ 对应的量化单元内。该单元包含所有比任何其他整数更接近 $k$ 的数字。这意味着条件 $|\\frac{x'}{\\Delta} - k| \\le \\frac{1}{2}$，这等价于 $|x' - k\\Delta| \\le \\frac{\\Delta}{2}$。\n\n因此，对于任何 $\\delta$ 的不可感知性条件是 $|\\mathrm{sat}(y+\\delta) - k\\Delta| \\le \\frac{\\Delta}{2}$。\n我们需要找到最大的 $\\epsilon  0$，使得对于所有满足 $|\\delta| \\le \\epsilon$ 的 $\\delta$，该条件都成立。\n\n让我们检查饱和项 $\\mathrm{sat}(y+\\delta)$。受扰动信号的幅度为 $|y+\\delta| \\le |y| + |\\delta|$。\n根据问题约束，有 $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$ 和 $|\\delta| \\le \\epsilon$。\n所以， $|y+\\delta| \\le (y_{\\max} - \\frac{\\Delta}{2}) + \\epsilon$。\n为使信号保持不饱和，我们需要 $|y+\\delta| \\le y_{\\max}$。这意味着 $(y_{\\max} - \\frac{\\Delta}{2}) + \\epsilon \\le y_{\\max}$，从而得到 $\\epsilon \\le \\frac{\\Delta}{2}$。\n让我们测试这个界限。如果我们选择 $\\epsilon = \\frac{\\Delta}{2}$，那么对于任何 $|\\delta| \\le \\frac{\\Delta}{2}$，我们有：\n$$|y+\\delta| \\le |y| + |\\delta| \\le \\left(y_{\\max} - \\frac{\\Delta}{2}\\right) + \\frac{\\Delta}{2} = y_{\\max}$$\n这表明，对于任何幅度高达 $\\frac{\\Delta}{2}$ 的扰动 $\\delta$，受扰动的信号 $y+\\delta$ 不会饱和。因此，$\\mathrm{sat}(y+\\delta) = y+\\delta$。\n\n在所讨论的 $\\delta$ 范围内饱和是无效的，不可感知性条件 $|\\mathrm{sat}(y+\\delta) - k\\Delta| \\le \\frac{\\Delta}{2}$ 简化为：\n$$| (y+\\delta) - k\\Delta | \\le \\frac{\\Delta}{2}$$\n代入 $y=k\\Delta$：\n$$| (k\\Delta+\\delta) - k\\Delta | \\le \\frac{\\Delta}{2}$$\n$$| \\delta | \\le \\frac{\\Delta}{2}$$\n我们的任务是找到最大的 $\\epsilon$，使得对于每个满足 $|\\delta| \\le \\epsilon$ 的 $\\delta$，不可感知性条件都成立。我们的推导表明，不可感知性条件等价于 $|\\delta| \\le \\frac{\\Delta}{2}$。\n因此，我们需要找到最大的 $\\epsilon$，使得陈述“$|\\delta| \\le \\epsilon \\implies |\\delta| \\le \\frac{\\Delta}{2}$”为真。这个逻辑蕴含当且仅当 $\\epsilon \\le \\frac{\\Delta}{2}$ 时成立。\n满足此条件的最大 $\\epsilon$ 值为 $\\epsilon = \\frac{\\Delta}{2}$。\n\n这解决了问题的第一部分。\n$\\epsilon = \\frac{\\Delta}{2}$。\n\n对于第二部分，我们必须找到有效攻击功率，定义为：\n$$P_{\\mathrm{eff}} \\;=\\; \\sup_{\\;|\\delta| \\le \\epsilon,\\;\\; Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))} \\; \\delta^{2}$$\n我们已经发现 $\\epsilon = \\frac{\\Delta}{2}$。\n我们还证明了对于任何满足 $|\\delta| \\le \\epsilon$ 的 $\\delta$，条件 $Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))$ 都成立。\n因此，上确界的约束集就是 $|\\delta| \\le \\epsilon$，即 $|\\delta| \\le \\frac{\\Delta}{2}$。\n问题简化为寻找：\n$$P_{\\mathrm{eff}} = \\sup_{|\\delta| \\le \\frac{\\Delta}{2}} \\delta^2$$\n函数 $f(\\delta) = \\delta^2$ 在闭区间 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ 上的最大值在其端点处取得，即在 $\\delta = \\frac{\\Delta}{2}$ 和 $\\delta = -\\frac{\\Delta}{2}$ 处。\n上确界值为：\n$$P_{\\mathrm{eff}} = \\left(\\frac{\\Delta}{2}\\right)^2 = \\frac{\\Delta^2}{4}$$\n\n问题要求 $\\epsilon$ 以伏特 (V) 为单位，而 $P_{\\mathrm{eff}}$ 以平方伏特 ($\\mathrm{V}^2$) 为单位。这意味着量 $\\Delta$ 是以伏特为单位测量的。推导出的表达式在量纲上是一致的。\n\n两个结果是 $\\epsilon = \\frac{\\Delta}{2}$ 和 $P_{\\mathrm{eff}} = \\frac{\\Delta^2}{4}$。我们按要求将它们表示为单个矩阵表达式。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\Delta}{2}  \\frac{\\Delta^{2}}{4} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在扰动概念的基础上，本练习转向一个动态的赛博物理系统——一个带有学习型障碍物探测器的移动机器人。这里的目标是精心设计一种攻击，它不仅要保持隐蔽，还要主动引发一个关乎安全的关键故障。通过该练习 ，您将学习如何构建并求解一个优化问题，以找到最有效的对抗性输入，从而将抽象的威胁模型与诸如避障失败等可触及的物理后果联系起来。",
            "id": "4204841",
            "problem": "考虑一个由移动机器人和已学习的障碍物检测器组成的离散时间信息物理系统 (CPS)。该机器人具有带曲率动力学和有界曲率变化率驱动的平面运动学模型。设机器人在时间步 $t$ 的状态为 $x_t = [p_{x,t}, p_{y,t}, \\theta_t, \\kappa_t]$，其中 $p_{x,t}$ 和 $p_{y,t}$ 是以米为单位的位置，$\\theta_t$ 是以弧度为单位的朝向，$\\kappa_t$ 是以米分之一为单位的曲率。控制输入为 $u_t = [v, \\Delta \\kappa_t]$，其中 $v$ 是以米每秒为单位的前进速度，$\\Delta \\kappa_t$ 是每个时间步内以米分之一为单位的曲率速率增量。在时间步长 $\\Delta t$ 内的离散时间更新为\n$$\n\\begin{aligned}\np_{x,t+1} = p_{x,t} + v \\cos(\\theta_t)\\, \\Delta t,\\\\\np_{y,t+1} = p_{y,t} + v \\sin(\\theta_t)\\, \\Delta t,\\\\\n\\theta_{t+1} = \\theta_t + v\\, \\kappa_t\\, \\Delta t,\\\\\n\\kappa_{t+1} = \\kappa_t + \\Delta \\kappa_t,\n\\end{aligned}\n$$\n并带有一个有界曲率变化率约束 $|\\Delta \\kappa_t| \\leq \\kappa_{\\mathrm{rate,max}}$。\n\n一个已学习的障碍物检测器作用于一个二维特征向量 $y_t \\in \\mathbb{R}^2$，该向量由机器人状态和固定的障碍物位置 $o = [o_x, o_y]$ 构建：\n$$\nr_t = \\sqrt{(o_x - p_{x,t})^2 + (o_y - p_{y,t})^2},\\quad\nb_t = \\mathrm{atan2}(o_y - p_{y,t}, o_x - p_{x,t}) - \\theta_t,\n$$\n其中 $r_t$ 是以米为单位的距离，$b_t$ 是以弧度为单位的方位角。特征向量为 $y_t = [\\phi_1(r_t), \\phi_2(b_t)] = [1/r_t, \\cos(b_t)]$，该向量是无量纲的。该检测器是一个逻辑分类器，通过以下方式产生一个概率 $p_t \\in [0,1]$：\n$$\np_t = \\sigma(w^\\top y_t + \\beta), \\quad \\text{with} \\quad \\sigma(z) = \\frac{1}{1 + e^{-z}},\n$$\n其中 $w \\in \\mathbb{R}^2$ 和 $\\beta \\in \\mathbb{R}$ 是固定的已学习参数。\n\n一个简单的避障策略使用 $t=0$ 时的检测器输出来设置所有后续步骤的曲率变化率指令：\n$$\n\\Delta \\kappa_t =\n\\begin{cases}\n-\\kappa_{\\mathrm{rate,max}}\\, \\mathrm{sign}(b_0),  \\text{if } p_0 \\ge \\tau,\\\\\n0,  \\text{if } p_0  \\tau,\n\\end{cases}\n\\quad \\text{for all } t \\in \\{0, 1, \\dots, N-1\\},\n$$\n其中 $\\tau \\in (0,1)$ 是一个固定的决策阈值，$\\mathrm{sign}(\\cdot)$ 表示符号函数。当检测器指示障碍物在路径上时，该策略试图转向以避开障碍物。在时域范围内相对于障碍物的最小间隙为\n$$\n\\mathrm{clearance}_{\\min} = \\min_{t \\in \\{0,1,\\dots,N\\}} \\sqrt{(o_x - p_{x,t})^2 + (o_y - p_{y,t})^2},\n$$\n并且安全要求规定 $\\mathrm{clearance}_{\\min} \\ge d_{\\min}$，其中 $d_{\\min}$ 的单位是米。\n\n一个对手通过在 $t=0$ 时添加一个特征空间扰动 $\\delta \\in \\mathbb{R}^2$ 来扰动检测器的输入，从而得到受攻击的特征向量 $y_0^{\\mathrm{adv}} = y_0 + \\delta$，扰动预算约束为 $\\|\\delta\\|_2 \\le \\varepsilon$，其中 $\\varepsilon$ 是无量纲的。对手的目标是通过将检测器输出降低到阈值 $\\tau$ 以下，来引发一个违反最小间隙约束的控制输入序列，同时该序列仍需满足有界曲率变化率约束。\n\n基于以上基本原理，实现一个程序，为每个给定的测试用例计算：\n- 一个在 $t=0$ 时的对抗性特征扰动 $\\delta^\\star$，该扰动在预算 $\\|\\delta\\|_2 \\le \\varepsilon$ 下最小化逻辑检测器的决策分数，\n- 由避障策略根据 $y_0^{\\mathrm{adv}}$ 决定的最终控制输入，\n- 在有界曲率变化率约束下，超过 $N$ 个步骤的离散时间轨迹，\n- 最小间隙，以及一个指示是否违反安全要求的布尔值，定义为 $\\mathrm{clearance}_{\\min}  d_{\\min}$。\n\n在所有测试用例中使用以下固定参数：\n- $v = 1.0$ 米每秒，\n- $\\Delta t = 0.1$ 秒，\n- $\\kappa_{\\mathrm{rate,max}} = 0.02$ 米分之一每时间步，\n- $N = 50$ 个时间步，\n- $d_{\\min} = 0.5$ 米，\n- $\\tau = 0.5$，\n- $w = [4.0, 6.0]$ (无量纲)，\n- $\\beta = -3.0$ (无量纲)，\n- 初始状态 $x_0 = [0.0, 0.0, 0.0, 0.0]$ (米, 米, 弧度, 米分之一)。\n\n包含四个用例的测试套件（所有角度以弧度表示，所有距离以米表示）：\n1. 用例 A (正常路径): 障碍物位于 $o = [3.0, 0.2]$，攻击预算 $\\varepsilon = 0.65$。\n2. 用例 B (边界预算): 障碍物位于 $o = [3.0, 0.2]$，攻击预算 $\\varepsilon = 0.55$。\n3. 用例 C (边缘情况，障碍物在后): 障碍物位于 $o = [-2.0, 0.0]$，攻击预算 $\\varepsilon = 0.65$。\n4. 用例 D (边缘情况，障碍物在远前方): 障碍物位于 $o = [10.0, 0.0]$，攻击预算 $\\varepsilon = 0.65$。\n\n您的程序必须产生单行输出，其中包含四个用例的布尔违规结果，格式为方括号内以逗号分隔的列表，例如，“[True,False,True,False]”。不应打印任何其他文本。角度必须以弧度计算，所有距离必须以米为单位。布尔值指示对于每个用例，对抗性扰动是否在有界曲率变化率约束下引发了违规（$\\mathrm{clearance}_{\\min}  d_{\\min}$）。",
            "solution": "该问题被验证为具有科学依据、良定且客观。它为模拟对基于学习的信息物理系统的对抗性攻击提供了一套完整且一致的定义、约束和参数。任务是确定一个特定的、经过最优设计的对抗性扰动是否能在给定的一组场景中导致安全违规。我们采用一种系统化的方法来求解。\n\n对于每个测试用例，求解过程包括四个主要步骤：\n1.  计算最优对抗性扰动 $\\delta^\\star$。\n2.  根据受扰动的检测器输出确定控制动作。\n3.  在确定的控制动作下模拟机器人的轨迹。\n4.  计算与障碍物的最小间隙并检查是否存在安全违规。\n\n所有计算使用的固定参数如下：\n- 速度 $v = 1.0 \\, \\mathrm{m/s}$\n- 时间步长 $\\Delta t = 0.1 \\, \\mathrm{s}$\n- 最大曲率速率 $\\kappa_{\\mathrm{rate,max}} = 0.02 \\, \\mathrm{m}^{-1}/\\text{步}$\n- 仿真时域 $N = 50$ 步\n- 最小要求间隙 $d_{\\min} = 0.5 \\, \\mathrm{m}$\n- 检测器阈值 $\\tau = 0.5$\n- 分类器权重 $w = [4.0, 6.0]^\\top$ (无量纲)\n- 分类器偏置 $\\beta = -3.0$ (无量纲)\n- 初始状态 $x_0 = [p_{x,0}, p_{y,0}, \\theta_0, \\kappa_0] = [0.0, 0.0, 0.0, 0.0]$，单位为 (米, 米, 弧度, 米⁻¹)。\n\n**步骤 1：最优对抗性扰动**\n\n对手的目标是最小化检测器的输出概率 $p_0^{\\mathrm{adv}} = \\sigma(w^\\top y_0^{\\mathrm{adv}} + \\beta)$。Sigmoid 函数 $\\sigma(z)$ 是单调递增的。因此，最小化 $p_0^{\\mathrm{adv}}$ 等价于最小化其参数，即决策分数 $S_{\\mathrm{adv}} = w^\\top y_0^{\\mathrm{adv}} + \\beta$。\n\n受攻击的特征向量为 $y_0^{\\mathrm{adv}} = y_0 + \\delta$。将其代入分数公式得到：\n$$\nS_{\\mathrm{adv}}(\\delta) = w^\\top (y_0 + \\delta) + \\beta = (w^\\top y_0 + \\beta) + w^\\top \\delta\n$$\n第一部分 $(w^\\top y_0 + \\beta)$ 对于给定场景是恒定的。为了最小化 $S_{\\mathrm{adv}}(\\delta)$，对手必须最小化 $w^\\top \\delta$ 这一项。这是一个点积，当向量 $\\delta$ 指向与向量 $w$ 相反的方向时，点积最小。\n\n对手受到预算 $\\|\\delta\\|_2 \\le \\varepsilon$ 的约束。为了在 $w$ 上获得最大的负投影，扰动 $\\delta$ 必须具有最大可能的大小 $\\varepsilon$，并与方向 $-w$ 对齐。因此，最优扰动 $\\delta^\\star$ 为：\n$$\n\\delta^\\star = -\\varepsilon \\frac{w}{\\|w\\|_2}\n$$\n当 $w = [4.0, 6.0]^\\top$ 时，L2 范数为 $\\|w\\|_2 = \\sqrt{4.0^2 + 6.0^2} = \\sqrt{16.0 + 36.0} = \\sqrt{52.0}$。\n最优扰动是攻击预算 $\\varepsilon$ 的函数：\n$$\n\\delta^\\star = -\\frac{\\varepsilon}{\\sqrt{52.0}} [4.0, 6.0]^\\top\n$$\n\n**步骤 2：控制策略决策**\n\n对于每个测试用例，我们首先计算初始的未受扰动特征向量 $y_0$。初始状态为 $x_0 = [0,0,0,0]$。\n- 到障碍物 $o=[o_x, o_y]$ 的距离为 $r_0 = \\sqrt{(o_x - 0)^2 + (o_y - 0)^2} = \\sqrt{o_x^2 + o_y^2}$。\n- 到障碍物的方位角为 $b_0 = \\mathrm{atan2}(o_y - 0, o_x - 0) - 0 = \\mathrm{atan2}(o_y, o_x)$。\n- 特征向量为 $y_0 = [1/r_0, \\cos(b_0)]^\\top$。\n\n然后我们计算受攻击的特征向量 $y_0^{\\mathrm{adv}} = y_0 + \\delta^\\star$ 和相应的决策分数 $S_{\\mathrm{adv}} = w^\\top y_0^{\\mathrm{adv}} + \\beta$。\n\n避障策略为：\n$$\n\\Delta \\kappa =\n\\begin{cases}\n-\\kappa_{\\mathrm{rate,max}}\\, \\mathrm{sign}(b_0),  \\text{if } p_0^{\\mathrm{adv}} \\ge \\tau,\\\\\n0,  \\text{if } p_0^{\\mathrm{adv}}  \\tau,\n\\end{cases}\n$$\n其中 $\\Delta\\kappa$ 是所有时间步 $t=0, \\dots, N-1$ 的恒定曲率速率。由于 $\\tau=0.5$，条件 $p_0^{\\mathrm{adv}} \\ge \\tau$ 等价于 $S_{\\mathrm{adv}} \\ge 0$，而 $p_0^{\\mathrm{adv}}  \\tau$ 等价于 $S_{\\mathrm{adv}}  0$。对手的目标是使 $S_{\\mathrm{adv}}  0$，这将导致 $\\Delta\\kappa=0$，使机器人直线行驶，可能会撞上障碍物。\n\n**步骤 3：轨迹模拟**\n\n在确定了恒定曲率速率 $\\Delta\\kappa$ 后，我们模拟机器人 $N=50$ 步的轨迹。从 $x_0$ 开始，我们使用离散时间动力学从 $t=0$ 迭代到 $N-1$：\n$$\n\\begin{aligned}\n\\kappa_{t+1} = \\kappa_t + \\Delta \\kappa \\\\\n\\theta_{t+1} = \\theta_t + v \\, \\kappa_t \\, \\Delta t \\\\\np_{x,t+1} = p_{x,t} + v \\cos(\\theta_t) \\, \\Delta t \\\\\np_{y,t+1} = p_{y,t} + v \\sin(\\theta_t) \\, \\Delta t\n\\end{aligned}\n$$\n我们存储每个时间步 $t \\in \\{0, 1, \\dots, N\\}$ 的位置 $[p_{x,t}, p_{y,t}]$。\n\n**步骤 4：最小间隙和违规检查**\n\n在生成完整的位置轨迹后，我们计算每个时间步到障碍物 $o$ 的欧几里得距离：\n$$\nd_t = \\sqrt{(o_x - p_{x,t})^2 + (o_y - p_{y,t})^2} \\quad \\text{for } t \\in \\{0, 1, \\dots, N\\}\n$$\n时域内的最小间隙为 $\\mathrm{clearance}_{\\min} = \\min_{t} d_t$。\n如果此间隙小于要求的最小值，即 $\\mathrm{clearance}_{\\min}  d_{\\min}$，则发生安全违规。我们为每个测试用例计算这个布尔值。\n\n对问题陈述中提供的四个测试用例中的每一个都执行了此完整过程。最终输出是这些布尔违规指示符的列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes adversarial attack outcomes for a CPS robot model.\n    For each test case, it calculates an optimal adversarial perturbation,\n    simulates the robot's trajectory under the attacked control policy,\n    and determines if a safety violation occurs.\n    \"\"\"\n\n    # Fixed parameters from the problem statement\n    v = 1.0  # meters per second\n    dt = 0.1  # seconds\n    kappa_rate_max = 0.02  # inverse meters per time step\n    N = 50  # time steps\n    d_min = 0.5  # meters\n    tau = 0.5  # dimensionless\n    w = np.array([4.0, 6.0])  # dimensionless\n    beta = -3.0  # dimensionless\n    x0 = np.array([0.0, 0.0, 0.0, 0.0])  # m, m, rad, 1/m\n\n    # Test cases: (obstacle_position, attack_budget_epsilon)\n    test_cases = [\n        (np.array([3.0, 0.2]), 0.65),  # Case A\n        (np.array([3.0, 0.2]), 0.55),  # Case B\n        (np.array([-2.0, 0.0]), 0.65),  # Case C\n        (np.array([10.0, 0.0]), 0.65),  # Case D\n    ]\n\n    results = []\n\n    # Calculate optimal perturbation direction\n    norm_w = np.linalg.norm(w)\n    w_dir_inv = -w / norm_w\n\n    for o, epsilon in test_cases:\n        # Step 1: Compute optimal adversarial perturbation delta_star\n        delta_star = epsilon * w_dir_inv\n\n        # Step 2: Determine control action with attacked detector\n        px0, py0, theta0, _ = x0\n        \n        # Calculate initial features\n        r0 = np.linalg.norm(o - x0[:2])\n        # Handle case where r0 is zero to avoid division by zero\n        if r0 == 0:\n            # If robot starts on the obstacle, it's a violation.\n            # However, problem setup ensures r0 > 0 for all test cases.\n            # We can treat y0 features as infinitely large.\n            # In practice, with this problem's test cases, this won't happen.\n            y0 = np.array([np.inf, 0.0])\n        else:\n            b0 = np.arctan2(o[1] - py0, o[0] - px0) - theta0\n            y0 = np.array([1.0 / r0, np.cos(b0)])\n\n        # Apply attack and get decision score\n        y0_adv = y0 + delta_star\n        score_adv = w @ y0_adv + beta\n        \n        # Decide on control input delta_kappa based on the policy\n        # Condition p_adv = tau is equivalent to score_adv = 0 for tau=0.5\n        delta_kappa = 0.0\n        if score_adv = 0:\n            delta_kappa = -kappa_rate_max * np.sign(b0)\n\n        # Step 3: Simulate the trajectory\n        x = x0.copy()\n        trajectory_positions = [x0[:2]]\n        for _ in range(N):\n            px, py, theta, kappa = x\n            \n            # Update state using discrete-time dynamics\n            kappa_next = kappa + delta_kappa\n            # Note: The model updates theta and position using state from start of timestep\n            theta_next = theta + v * kappa * dt\n            px_next = px + v * np.cos(theta) * dt\n            py_next = py + v * np.sin(theta) * dt\n            \n            x = np.array([px_next, py_next, theta_next, kappa_next])\n            trajectory_positions.append(x[:2])\n            \n        # Step 4: Calculate minimum clearance and check for violation\n        trajectory_positions = np.array(trajectory_positions)\n        distances_to_obstacle = np.linalg.norm(trajectory_positions - o, axis=1)\n        min_clearance = np.min(distances_to_obstacle)\n\n        violation = min_clearance  d_min\n        results.append(violation)\n\n    # Format the final output as a string\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "在探讨了如何攻击系统之后，我们现在转向防御。本练习将介绍一种强大的形式化验证技术——使用区间算术进行可达性分析，从而为赛博物理系统提供可认证的安全保证。通过实现该算法 ，您将学习如何在一个给定的扰动范围内，对学习型系统的所有可能行为进行形式化推理，并最终证明安全违规是不可能发生的。",
            "id": "4204835",
            "problem": "考虑一个由信息物理系统 (CPS) 的数字孪生内部的学习型策略控制的离散时间线性时不变系统。系统状态为 $x_t \\in \\mathbb{R}^2$，控制输入为 $u_t \\in \\mathbb{R}$，观测测量值为 $y_t \\in \\mathbb{R}^2$。其动态方程为\n$$\nx_{t+1} = A x_t + B u_t + w_t,\n$$\n其中 $A \\in \\mathbb{R}^{2 \\times 2}$，$B \\in \\mathbb{R}^{2 \\times 1}$，$w_t$ 是一个外源性扰动向量。测量值受到对抗性传感器噪声 $\\delta_t$ 的破坏，因此\n$$\ny_t = x_t + \\delta_t.\n$$\n控制输入由一个具有单隐藏层和整流线性单元 (ReLU) 激活函数的前馈人工神经网络 (ANN) 生成，该网络将 $y_t$ 映射到 $u_t = \\pi(y_t)$。对抗方在逐元素的区间预算内选择 $\\delta_t$，环境在逐元素的区间预算内注入 $w_t$。我们旨在通过过近似这些对抗性选择下的可达集来寻求一种可证的安全保证。\n\n基本依据：\n- 仿射映射 $z = W a + b$ 的集合传播，其中 $a$ 位于逐元素的区间 $[l,u]$ 内，其边界由以下基于单调性的包络确定。令 $W^+ = \\max(W,0)$ 和 $W^- = \\min(W,0)$ 分别为 $W$ 的逐元素的非负部分和非正部分。则像区间 $[l_z, u_z]$ 为\n$$\nl_z = W^+ l + W^- u + b, \\quad u_z = W^+ u + W^- l + b.\n$$\n- ReLU 运算 $\\mathrm{ReLU}(z) = \\max(0,z)$ 是逐元素单调的，因此如果 $z \\in [l,u]$ 逐元素成立，那么 $\\mathrm{ReLU}(z) \\in [\\max(0,l), \\max(0,u)]$ 逐元素成立。\n- 区间的闵可夫斯基和满足 $[l_1,u_1] + [l_2,u_2] = [l_1 + l_2, u_1 + u_2]$ 逐元素成立。\n\n控制器架构与参数：\n- 隐藏层有 $4$ 个单元，其权重 $W_1 \\in \\mathbb{R}^{4 \\times 2}$ 和偏置 $b_1 \\in \\mathbb{R}^{4}$ 由下式给出\n$$\nW_1 = \\begin{bmatrix}\n1  0\\\\\n-1  0\\\\\n0  1\\\\\n0  -1\n\\end{bmatrix}, \\quad b_1 = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.\n$$\n- 输出层的权重 $W_2 \\in \\mathbb{R}^{1 \\times 4}$ 和偏置 $b_2 \\in \\mathbb{R}$ 由下式给出\n$$\nW_2 = \\begin{bmatrix} -1  1  -0.5  0.5 \\end{bmatrix}, \\quad b_2 = 0.\n$$\n- 层间的激活函数为 $\\mathrm{ReLU}$，因此对于任何输入 $y \\in \\mathbb{R}^2$，\n$$\nu = \\pi(y) = W_2 \\, \\mathrm{ReLU}(W_1 y + b_1) + b_2.\n$$\n该网络实现了 $u \\approx -x_1 - 0.5 x_2$ 的分段线性近似。\n\n受控对象模型：\n- 系统矩阵对应于一个采样周期 $h = 0.1$ 的离散化双积分器，\n$$\nA = \\begin{bmatrix}\n1  0.1\\\\\n0  1\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n0.005\\\\\n0.1\n\\end{bmatrix}.\n$$\n\n对抗性输入与扰动集：\n- 对抗方可以在逐元素边界 $\\varepsilon \\ge 0$ 内扰动观测的每个分量，因此对于所有 $t$，$\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$。\n- 扰动位于逐元素的区间 $w_t \\in [-\\bar{w}, \\bar{w}]^2$ 内，其中 $\\bar{w} \\ge 0$ 是一个应用于两个状态分量的给定标量边界。\n\n初始集：\n- 初始状态位于一个盒子 $x_0 \\in [\\underline{x}_0, \\overline{x}_0]$ 内，其中\n$$\n\\underline{x}_0 = \\begin{bmatrix} 0.045\\\\ -0.005 \\end{bmatrix}, \\quad\n\\overline{x}_0 = \\begin{bmatrix} 0.055\\\\ 0.005 \\end{bmatrix}.\n$$\n\n安全性规约：\n- 安全性约束要求位置分量 $x_{t,1}$ 在所有时间 $t \\in \\{0,1,\\dots,T\\}$ 均满足 $|x_{t,1}| \\le p_{\\max}$，即多面体集\n$$\n\\mathcal{S}(p_{\\max}) = \\{ x \\in \\mathbb{R}^2 : C x \\le d \\}, \\quad\nC = \\begin{bmatrix} 1  0\\\\ -1  0 \\end{bmatrix}, \\quad\nd = \\begin{bmatrix} p_{\\max}\\\\ p_{\\max} \\end{bmatrix}.\n$$\n\n可证安全问题：\n- 仅使用上述基本事实和提供的参数，通过以下方式为 $t = 0,1,\\dots,T$ 递归地过近似可达状态区间 $[ \\underline{x}_t, \\overline{x}_t ]$：\n    - 计算观测区间 $[ \\underline{y}_t, \\overline{y}_t ] = [ \\underline{x}_t - \\varepsilon \\mathbf{1}, \\overline{x}_t + \\varepsilon \\mathbf{1} ]$。\n    - 使用区间边界将 $[ \\underline{y}_t, \\overline{y}_t ]$ 传播通过 ANN，以获得控制区间 $[ \\underline{u}_t, \\overline{u}_t ]$。\n    - 使用区间算术将 $[ \\underline{x}_t, \\overline{x}_t ]$ 和 $[ \\underline{u}_t, \\overline{u}_t ]$ 传播通过系统动态方程，并加上扰动区间 $[-\\bar{w}, \\bar{w}]^2$ 以获得 $[ \\underline{x}_{t+1}, \\overline{x}_{t+1} ]$。\n- 当且仅当对于所有 $t \\in \\{0,1,\\dots,T\\}$，每个安全性不等式的最坏情况值均为非正时，可证安全的测试才成立，即 $C x_t - d$ 在区间 $[ \\underline{x}_t, \\overline{x}_t ]$ 上的上界逐元素 $\\le 0$。\n\n测试套件：\n对于以下每个参数元组 $(\\varepsilon, p_{\\max}, T, \\bar{w})$，确定一个布尔值，指示在整个时域 $t \\in \\{0,1,\\dots,T\\}$ 内，对于所有容许的对抗性传感器噪声和扰动，安全性约束是否被证明成立。\n- 情况 1：$\\varepsilon = 0.01$, $p_{\\max} = 0.2$, $T = 20$, $\\bar{w} = 0.0005$。\n- 情况 2：$\\varepsilon = 0.05$, $p_{\\max} = 0.08$, $T = 30$, $\\bar{w} = 0.0005$。\n- 情况 3：$\\varepsilon = 0.0$, $p_{\\max} = 0.06$, $T = 10$, $\\bar{w} = 0.0$。\n- 情况 4：$\\varepsilon = 0.02$, $p_{\\max} = 0.1$, $T = 50$, $\\bar{w} = 0.0002$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述顺序排列的各个情况的结果，形式为方括号内以逗号分隔的 Python 布尔字面量列表，例如 $[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True}, \\mathrm{True} ]$。\n- 无需单位，因为在此问题中所有量均被视为无量纲。",
            "solution": "用户的请求是验证并解决一个关于学习型控制系统可证安全性的问题。该过程涉及在对抗性传感器攻击和环境扰动下，为一个离散时间线性系统迭代计算其可达状态集的过近似。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n- **系统动态方程**：$x_{t+1} = A x_t + B u_t + w_t$，其中状态为 $x_t \\in \\mathbb{R}^2$，控制输入为 $u_t \\in \\mathbb{R}$。\n- **测量方程**：$y_t = x_t + \\delta_t$，其中测量值为 $y_t \\in \\mathbb{R}^2$。\n- **控制器**：一个前馈人工神经网络 (ANN)，$u_t = \\pi(y_t) = W_2 \\, \\mathrm{ReLU}(W_1 y_t + b_1) + b_2$。\n- **对抗性集合**：\n    - 传感器噪声：$\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$。\n    - 扰动：$w_t \\in [-\\bar{w}, \\bar{w}]^2$。\n- **集合传播规则（基本依据）**：\n    - 仿射映射 $z = W a + b$，其中 $a \\in [l,u]$：$[l_z, u_z] = [W^+ l + W^- u + b, W^+ u + W^- l + b]$，其中 $W^+ = \\max(W,0)$，$W^- = \\min(W,0)$。\n    - ReLU 激活函数 $\\mathrm{ReLU}(z)$，其中 $z \\in [l,u]$：$[\\max(0,l), \\max(0,u)]$。\n    - 闵可夫斯基和：$[l_1,u_1] + [l_2,u_2] = [l_1 + l_2, u_1 + u_2]$。\n- **控制器参数**：\n    - $W_1 = \\begin{bmatrix} 1  0\\\\ -1  0\\\\ 0  1\\\\ 0  -1 \\end{bmatrix} \\in \\mathbb{R}^{4 \\times 2}$\n    - $b_1 = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\in \\mathbb{R}^{4}$\n    - $W_2 = \\begin{bmatrix} -1  1  -0.5  0.5 \\end{bmatrix} \\in \\mathbb{R}^{1 \\times 4}$\n    - $b_2 = 0 \\in \\mathbb{R}$\n- **系统参数**（离散化的双积分器，$h=0.1$）：\n    - $A = \\begin{bmatrix} 1  0.1\\\\ 0  1 \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 2}$\n    - $B = \\begin{bmatrix} 0.005\\\\ 0.1 \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 1}$\n- **初始状态集**：$x_0 \\in [\\underline{x}_0, \\overline{x}_0]$，其中 $\\underline{x}_0 = \\begin{bmatrix} 0.045\\\\ -0.005 \\end{bmatrix}$，$\\overline{x}_0 = \\begin{bmatrix} 0.055\\\\ 0.005 \\end{bmatrix}$。\n- **安全性规约**：对于所有 $t \\in \\{0, 1, \\dots, T\\}$，$|x_{t,1}| \\le p_{\\max}$，由多面体 $\\mathcal{S}(p_{\\max}) = \\{ x \\in \\mathbb{R}^2 : C x \\le d \\}$ 定义，其中 $C = \\begin{bmatrix} 1  0\\\\ -1  0 \\end{bmatrix}$，$d = \\begin{bmatrix} p_{\\max}\\\\ p_{\\max} \\end{bmatrix}$。\n- **可达性算法**：\n    1.  计算观测区间：$[ \\underline{y}_t, \\overline{y}_t ] = [ \\underline{x}_t - \\varepsilon \\mathbf{1}, \\overline{x}_t + \\varepsilon \\mathbf{1} ]$。\n    2.  通过传播 $[\\underline{y}_t, \\overline{y}_t]$ 经过 ANN 计算控制区间 $[\\underline{u}_t, \\overline{u}_t]$。\n    3.  通过传播 $[\\underline{x}_t, \\overline{x}_t]$ 和 $[\\underline{u}_t, \\overline{u}_t]$ 经过动态方程并加上扰动区间，计算下一状态区间 $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$。\n- **安全性认证测试**：如果对于所有 $t \\in \\{0, 1, \\dots, T\\}$，在集合 $[\\underline{x}_t, \\overline{x}_t]$ 上 $C x_t - d$ 的上界逐元素非正，则认证通过。\n- **测试套件**：\n    - 情况 1：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.01, 0.2, 20, 0.0005)$\n    - 情况 2：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.05, 0.08, 30, 0.0005)$\n    - 情况 3：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.0, 0.06, 10, 0.0)$\n    - 情况 4：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.02, 0.1, 50, 0.0002)$\n\n**步骤2：使用提取的给定条件进行验证**\n该问题具有科学依据，是适定且客观的。它是信息物理系统形式化验证和鲁棒控制领域的标准问题。所用模型基于线性系统理论和神经网络，分析方法为区间算术，这在数学上是可靠的。所有参数、方程和程序都已明确指定，没有歧义、矛盾或信息缺失。该问题可形式化且需要相当的计算量，直接切合指定的主题。\n\n**步骤3：结论与行动**\n该问题有效。将通过实现指定的可达性算法来提供解决方案。\n\n### 解法\n\n该问题要求我们通过计算可达状态集的区间过近似来确定控制系统的可证安全性。我们将实现指定的递归算法。设时间 $t$ 的状态区间为 $[\\underline{x}_t, \\overline{x}_t]$。目标是计算下一状态的区间 $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$，并在每一步验证安全性。\n\n**1. 安全性验证**\n在每个离散时间步 $t \\in \\{0, 1, \\dots, T\\}$，我们必须验证计算出的状态区间 $[\\underline{x}_t, \\overline{x}_t]$ 完全包含在安全集 $\\mathcal{S}(p_{\\max})$ 内。安全条件为 $|x_{t,1}| \\le p_{\\max}$，这可以转化为两个不等式：$x_{t,1} \\le p_{\\max}$ 和 $-x_{t,1} \\le p_{\\max}$。为检验这些不等式是否对整个区间都成立，我们必须检查它们的最坏情况值。这要求：\n- $\\max(x_{t,1}) = \\overline{x}_{t,1} \\le p_{\\max}$\n- $\\max(-x_{t,1}) = -\\underline{x}_{t,1} \\le p_{\\max}$，等价于 $\\underline{x}_{t,1} \\ge -p_{\\max}$\n如果这两个条件都满足，则系统在时间 $t$ 是安全的。如果从 $t=0$ 到 $T$ 的所有时间点都满足此条件，则整个系统被认证为安全。\n\n**2. 可达集传播 (从 $t$ 到 $t+1$)**\n\n**步骤 2.1：观测区间**\n测量值 $y_t = x_t + \\delta_t$ 受到对抗性传感器攻击 $\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$ 的影响。给定状态区间 $[\\underline{x}_t, \\overline{x}_t]$，观测值 $y_t$ 的区间是通过状态区间与噪声区间 $[-\\varepsilon \\mathbf{1}, \\varepsilon \\mathbf{1}]$ 的闵可夫斯基和求得的，其中 $\\mathbf{1}$ 是一个全为一的向量。\n$$ \\underline{y}_t = \\underline{x}_t - \\varepsilon \\mathbf{1} $$\n$$ \\overline{y}_t = \\overline{x}_t + \\varepsilon \\mathbf{1} $$\n\n**步骤 2.2：控制输入区间**\n控制输入 $u_t$ 是通过将观测区间 $[\\underline{y}_t, \\overline{y}_t]$ 传播通过神经网络控制器 $u_t = W_2 \\, \\mathrm{ReLU}(W_1 y_t + b_1) + b_2$ 来确定的。\n\n- **第一次仿射变换**：令 $z_{t,1} = W_1 y_t + b_1$。$z_{t,1}$ 的区间为 $[\\underline{z}_{t,1}, \\overline{z}_{t,1}]$，使用指定的基于单调性的包络规则计算：\n  $$ \\underline{z}_{t,1} = W_1^+ \\underline{y}_t + W_1^- \\overline{y}_t + b_1 $$\n  $$ \\overline{z}_{t,1} = W_1^+ \\overline{y}_t + W_1^- \\underline{y}_t + b_1 $$\n  其中 $W_1^+ = \\max(W_1, 0)$ 和 $W_1^- = \\min(W_1, 0)$ 分别是 $W_1$ 的逐元素正部和负部。\n\n- **ReLU 激活**：令 $a_{t,1} = \\mathrm{ReLU}(z_{t,1})$。激活输出的区间 $[\\underline{a}_{t,1}, \\overline{a}_{t,1}]$ 是通过对其输入区间的边界应用 ReLU 函数得到的：\n  $$ \\underline{a}_{t,1} = \\mathrm{ReLU}(\\underline{z}_{t,1}) = \\max(0, \\underline{z}_{t,1}) $$\n  $$ \\overline{a}_{t,1} = \\mathrm{ReLU}(\\overline{z}_{t,1}) = \\max(0, \\overline{z}_{t,1}) $$\n\n- **第二次仿射变换（输出）**：最终的控制输入为 $u_t = W_2 a_{t,1} + b_2$。其区间 $[\\underline{u}_t, \\overline{u}_t]$ 的计算方法类似：\n  $$ \\underline{u}_t = W_2^+ \\underline{a}_{t,1} + W_2^- \\overline{a}_{t,1} + b_2 $$\n  $$ \\overline{u}_t = W_2^+ \\overline{a}_{t,1} + W_2^- \\underline{a}_{t,1} + b_2 $$\n\n**步骤 2.3：下一状态区间**\n下一状态 $x_{t+1} = A x_t + B u_t + w_t$ 是三个项的和，每一项都位于一个区间内。$x_{t+1}$ 的结果区间是每一项区间的闵可夫斯基和。\n\n- **$A x_t$ 的区间**：使用仿射传播规则，输入为 $x_t \\in [\\underline{x}_t, \\overline{x}_t]$：\n  $$ [\\underline{(Ax_t)}, \\overline{(Ax_t)}] = [A^+ \\underline{x}_t + A^- \\overline{x}_t, A^+ \\overline{x}_t + A^- \\underline{x}_t] $$\n- **$B u_t$ 的区间**：使用仿射传播规则，输入为 $u_t \\in [\\underline{u}_t, \\overline{u}_t]$：\n  $$ [\\underline{(Bu_t)}, \\overline{(Bu_t)}] = [B^+ \\underline{u}_t + B^- \\overline{u}_t, B^+ \\overline{u}_t + B^- \\underline{u}_t] $$\n- **$w_t$ 的区间**：给定为 $[-\\bar{w}\\mathbf{1}, \\bar{w}\\mathbf{1}]$。\n\n将这些区间边界相加，得到下一状态区间 $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$：\n$$ \\underline{x}_{t+1} = (A^+ \\underline{x}_t + A^- \\overline{x}_t) + (B^+ \\underline{u}_t + B^- \\overline{u}_t) - \\bar{w}\\mathbf{1} $$\n$$ \\overline{x}_{t+1} = (A^+ \\overline{x}_t + A^- \\underline{x}_t) + (B^+ \\overline{u}_t + B^- \\underline{u}_t) + \\bar{w}\\mathbf{1} $$\n\n由于给定的矩阵 $A$ 和 $B$ 的所有元素都是非负的，因此 $A^+=A$，$A^-=0$，$B^+=B$，$B^-=0$。传播规则简化为：\n$$ \\underline{x}_{t+1} = A \\underline{x}_t + B \\underline{u}_t - \\bar{w}\\mathbf{1} $$\n$$ \\overline{x}_{t+1} = A \\overline{x}_t + B \\overline{u}_t + \\bar{w}\\mathbf{1} $$\n对每个测试用例实施此完整的递归过程，以确定其可证安全状态。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the certified safety problem for the four test cases specified.\n    \"\"\"\n    test_cases = [\n        # (epsilon, p_max, T, w_bar)\n        (0.01, 0.2, 20, 0.0005),\n        (0.05, 0.08, 30, 0.0005),\n        (0.0, 0.06, 10, 0.0),\n        (0.02, 0.1, 50, 0.0002),\n    ]\n\n    results = []\n    for case in test_cases:\n        is_safe = check_safety_certification(case)\n        results.append(is_safe)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_safety_certification(params):\n    \"\"\"\n    Performs reachability analysis for a given set of parameters to certify safety.\n\n    Args:\n        params (tuple): A tuple containing (epsilon, p_max, T, w_bar).\n\n    Returns:\n        bool: True if the system is certified safe, False otherwise.\n    \"\"\"\n    eps, p_max, T, w_bar = params\n\n    # --- System and Controller Parameters ---\n    # Using column vectors (shape N,1) for consistency in matrix operations.\n    \n    # Plant model\n    A = np.array([[1.0, 0.1], [0.0, 1.0]], dtype=float)\n    B = np.array([[0.005], [0.1]], dtype=float)\n\n    # Controller ANN parameters\n    W1 = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=float)\n    b1 = np.zeros((4, 1), dtype=float)\n    W2 = np.array([[-1, 1, -0.5, 0.5]], dtype=float)\n    b2 = np.array([[0.0]], dtype=float)\n\n    # Initial state set\n    x0_lower = np.array([[0.045], [-0.005]], dtype=float)\n    x0_upper = np.array([[0.055], [0.005]], dtype=float)\n\n    # Pre-compute positive and negative parts of weight matrices for propagation\n    W1_pos = np.maximum(W1, 0)\n    W1_neg = np.minimum(W1, 0)\n    W2_pos = np.maximum(W2, 0)\n    W2_neg = np.minimum(W2, 0)\n    \n    # Since A and B are non-negative, the general formula simplifies,\n    # but we implement the general form for correctness.\n    A_pos = np.maximum(A, 0)\n    A_neg = np.minimum(A, 0)\n    B_pos = np.maximum(B, 0)\n    B_neg = np.minimum(B, 0)\n\n    # Initialize current state interval\n    x_lower = x0_lower\n    x_upper = x0_upper\n\n    # Constant interval vectors for noise and disturbance\n    eps_vec = np.full((2, 1), eps)\n    w_bar_vec = np.full((2, 1), w_bar)\n\n    # --- Main Reachability Loop ---\n    for t in range(T + 1):\n        # 1. Safety Verification\n        # Check if the current reachable set violates the safety constraints.\n        # Condition: -p_max = x_t,1 = p_max\n        if x_upper[0, 0]  p_max or x_lower[0, 0]  -p_max:\n            return False  # Safety violated\n\n        # If it's the last time step, no need to compute the next state.\n        if t == T:\n            break\n\n        # 2. Reachable Set Propagation\n        \n        # 2.1. Observation Interval Calculation\n        y_lower = x_lower - eps_vec\n        y_upper = x_upper + eps_vec\n\n        # 2.2. Control Input Interval Calculation (propagate through ANN)\n        # First affine layer\n        z1_lower = W1_pos @ y_lower + W1_neg @ y_upper + b1\n        z1_upper = W1_pos @ y_upper + W1_neg @ y_lower + b1\n\n        # ReLU activation\n        a1_lower = np.maximum(0, z1_lower)\n        a1_upper = np.maximum(0, z1_upper)\n\n        # Output layer\n        u_lower = W2_pos @ a1_lower + W2_neg @ a1_upper + b2\n        u_upper = W2_pos @ a1_upper + W2_neg @ a1_lower + b2\n        \n        # 2.3. Next State Interval Calculation\n        # Contribution from Ax_t\n        ax_lower = A_pos @ x_lower + A_neg @ x_upper\n        ax_upper = A_pos @ x_upper + A_neg @ x_lower\n\n        # Contribution from Bu_t\n        bu_lower = B_pos @ u_lower + B_neg @ u_upper\n        bu_upper = B_pos @ u_upper + B_neg @ u_lower\n        \n        # Minkowski sum for the next state interval\n        x_next_lower = ax_lower + bu_lower - w_bar_vec\n        x_next_upper = ax_upper + bu_upper + w_bar_vec\n\n        # Update state for the next iteration\n        x_lower = x_next_lower\n        x_upper = x_next_upper\n\n    # If the loop completes without any safety violations, the property is certified.\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}