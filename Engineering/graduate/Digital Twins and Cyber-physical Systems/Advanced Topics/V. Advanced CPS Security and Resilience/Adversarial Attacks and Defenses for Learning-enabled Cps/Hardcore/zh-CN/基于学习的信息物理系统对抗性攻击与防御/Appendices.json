{
    "hands_on_practices": [
        {
            "introduction": "对抗性攻击最危险的特性之一是其隐蔽性。本练习将探讨一个核心概念：攻击的不可感知性，即攻击如何在不改变系统数字输出的情况下影响系统内部状态。通过分析一个带有量化和饱和环节的传感器模型，我们将精确计算出能够确保攻击不被察觉的最大扰动范围，这有助于我们从物理层面理解学习型CPS的脆弱性。",
            "id": "4204828",
            "problem": "一个启用学习的信息物理系统（CPS）使用一个数字孪生（DT）状态估计器，该估计器消耗量化的传感器测量值。每个标量传感器通道被建模为一个理想的均匀中置型量化器，其步长为 $\\,\\Delta > 0\\,$，对称饱和限制为 $\\,y_{\\max} > 0\\,$。量化前的模拟测量值为 $\\,y \\in \\mathbb{R}\\,$，攻击者在量化前注入一个加性扰动 $\\,\\delta \\in \\mathbb{R}\\,$，其约束为 $\\,\\|\\delta\\|_{\\infty} \\le \\epsilon\\,$（对于标量，$\\,\\|\\delta\\|_{\\infty} = |\\delta|$）。测量值首先通过 $\\,\\mathrm{sat}(x) = \\mathrm{sgn}(x)\\,\\min\\{|x|,\\,y_{\\max}\\}\\,$ 进行饱和处理，然后通过中置型舍入映射进行量化：\n$$\nQ(x) \\;=\\; \\Delta \\cdot \\mathrm{clip}\\!\\left(\\mathrm{round}\\!\\left(\\frac{x}{\\Delta}\\right),\\, -K,\\, K\\right), \n\\quad K \\;=\\; \\left\\lfloor \\frac{y_{\\max}}{\\Delta} \\right\\rfloor,\n$$\n其中 $\\,\\mathrm{round}(\\cdot)\\,$ 表示四舍五入到最近的整数，$\\,\\mathrm{clip}(z,-K,K) = \\max\\{-K, \\min\\{z, K\\}\\}\\,$ 在码域中实施饱和。\n\nDT的不可感知性准则是指数字输出码在攻击下不发生改变，即：\n$$\nQ\\!\\big(\\mathrm{sat}(y+\\delta)\\big) \\;=\\; Q\\!\\big(\\mathrm{sat}(y)\\big).\n$$\n假设CPS校准将标称测量值保持在其量化单元的中心并远离饱和区，即存在 $\\,k \\in \\mathbb{Z}\\,$ 使得 $\\,y = k\\,\\Delta\\,$ 且 $\\,|y| \\le y_{\\max} - \\frac{\\Delta}{2}\\,$。\n\n仅从上述定义以及均匀量化和饱和的标准属性出发，推导：\n1. 最大的 $\\,\\epsilon\\,$，使得每个满足 $\\,\\|\\delta\\|_{\\infty} \\le \\epsilon\\,$ 的对抗性扰动在量化后，在上述定义的意义下，仍然是不可感知的。\n2. 在这些约束下的有效攻击功率，定义为：\n$$\nP_{\\mathrm{eff}} \\;=\\; \\sup_{\\;|\\delta| \\le \\epsilon,\\;\\; Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))} \\; \\delta^{2}.\n$$\n\n以伏特（V）表示 $\\,\\epsilon\\,$，以平方伏特（$\\text{V}^2$）表示 $\\,P_{\\mathrm{eff}}\\,$。以单个闭式解析表达式的形式提供最终答案。无需四舍五入。",
            "solution": "该问题被验证为有科学依据、提法恰当、客观且自洽。所提供的带饱和的量化器模型以及对抗性攻击的表述，在信号处理和控制理论中构成一个标准的、可解的问题。我们可以开始求解。\n\n问题要求两个量：保证不可感知性的最大扰动容限 $\\epsilon$，以及在此约束下的有效攻击功率 $P_{\\mathrm{eff}}$。\n\n首先，我们分析未受扰动系统的输出 $Q(\\mathrm{sat}(y))$。\n标称测量值给定为 $y = k\\Delta$，其中 $k \\in \\mathbb{Z}$ 为某个整数。\n它还受到约束 $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$。由于 $\\Delta > 0$，这意味着 $|y|  y_{\\max}$。\n饱和函数为 $\\mathrm{sat}(x) = \\mathrm{sgn}(x)\\min\\{|x|, y_{\\max}\\}$。由于 $|y|  y_{\\max}$，我们有 $\\mathrm{sat}(y) = y$。\n量化函数为 $Q(x) = \\Delta \\cdot \\mathrm{clip}(\\mathrm{round}(x/\\Delta), -K, K)$，其中 $K = \\lfloor y_{\\max}/\\Delta \\rfloor$。\n对于未受扰动的输入 $y = k\\Delta$，舍入函数的参数为 $\\frac{y}{\\Delta} = \\frac{k\\Delta}{\\Delta} = k$。由于 $k$ 是一个整数，$\\mathrm{round}(k) = k$。\n因此，裁剪函数的参数是 $k$。给定条件 $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$ 意味着 $|k\\Delta| \\le y_{\\max} - \\frac{\\Delta}{2}$，即 $|k| \\le \\frac{y_{\\max}}{\\Delta} - \\frac{1}{2}$。由于 $k$ 是一个整数，这要求 $|k| \\le \\lfloor \\frac{y_{\\max}}{\\Delta} - \\frac{1}{2} \\rfloor$。因为对于任意 $z \\in \\mathbb{R}$，都有 $\\lfloor z-\\frac{1}{2} \\rfloor \\le \\lfloor z \\rfloor$，所以可得 $|k| \\le \\lfloor \\frac{y_{\\max}}{\\Delta} \\rfloor = K$。\n因此，对于索引 $k$，裁剪函数是未激活的：$\\mathrm{clip}(k, -K, K) = k$。\n未受扰动信号的输出为 $Q(\\mathrm{sat}(y)) = Q(y) = \\Delta \\cdot k = k\\Delta$。\n\n接下来，我们分析不可感知性准则：$Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y)) = k\\Delta$。\n令 $x' = \\mathrm{sat}(y+\\delta)$。准则变为 $Q(x') = k\\Delta$。根据我们发现的 $|k| \\le K$，这可以简化为 $\\Delta \\cdot \\mathrm{round}(x'/\\Delta) = k\\Delta$，这又要求 $\\mathrm{round}(x'/\\Delta) = k$。\n为了使 $\\mathrm{round}(\\cdot)$ 函数的输出为整数 $k$，其参数必须位于对应于 $k$ 的量化单元内。该单元包含所有比任何其他整数更接近 $k$ 的数。这意味着条件 $|\\frac{x'}{\\Delta} - k| \\le \\frac{1}{2}$ 成立，这等价于 $|x' - k\\Delta| \\le \\frac{\\Delta}{2}$。\n\n所以，对于任何 $\\delta$，不可感知性条件是 $|\\mathrm{sat}(y+\\delta) - k\\Delta| \\le \\frac{\\Delta}{2}$。我们需要找到最大的 $\\epsilon > 0$，使得对于所有满足 $|\\delta| \\le \\epsilon$ 的 $\\delta$，该条件都成立。\n\n让我们检查饱和项 $\\mathrm{sat}(y+\\delta)$。受扰动信号的幅值为 $|y+\\delta| \\le |y| + |\\delta|$。\n根据问题的约束，有 $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$ 和 $|\\delta| \\le \\epsilon$。所以， $|y+\\delta| \\le (y_{\\max} - \\frac{\\Delta}{2}) + \\epsilon$。\n为使信号保持未饱和状态，我们需要 $|y+\\delta| \\le y_{\\max}$。这意味着 $(y_{\\max} - \\frac{\\Delta}{2}) + \\epsilon \\le y_{\\max}$，从而得出 $\\epsilon \\le \\frac{\\Delta}{2}$。\n让我们测试这个界限。如果我们选择 $\\epsilon = \\frac{\\Delta}{2}$，那么对于任何 $|\\delta| \\le \\frac{\\Delta}{2}$，我们有：\n$$|y+\\delta| \\le |y| + |\\delta| \\le \\left(y_{\\max} - \\frac{\\Delta}{2}\\right) + \\frac{\\Delta}{2} = y_{\\max}$$\n这表明对于任何幅值高达 $\\frac{\\Delta}{2}$ 的扰动 $\\delta$，受扰动的信号 $y+\\delta$ 都不会饱和。因此，$\\mathrm{sat}(y+\\delta) = y+\\delta$。\n\n在所讨论的 $\\delta$ 范围内饱和是不激活的，不可感知性条件 $|\\mathrm{sat}(y+\\delta) - k\\Delta| \\le \\frac{\\Delta}{2}$ 简化为：\n$$| (y+\\delta) - k\\Delta | \\le \\frac{\\Delta}{2}$$\n代入 $y=k\\Delta$：\n$$| (k\\Delta+\\delta) - k\\Delta | \\le \\frac{\\Delta}{2}$$\n$$| \\delta | \\le \\frac{\\Delta}{2}$$\n我们的任务是找到最大的 $\\epsilon$，使得对于每个满足 $|\\delta| \\le \\epsilon$ 的 $\\delta$，不可感知性条件都成立。我们的推导表明，不可感知性条件等价于 $|\\delta| \\le \\frac{\\Delta}{2}$。因此，我们需要找到最大的 $\\epsilon$，使得陈述“$|\\delta| \\le \\epsilon \\implies |\\delta| \\le \\frac{\\Delta}{2}$”为真。这个逻辑蕴含当且仅当 $\\epsilon \\le \\frac{\\Delta}{2}$ 时成立。满足此条件的最大 $\\epsilon$ 值为 $\\epsilon = \\frac{\\Delta}{2}$。\n\n这就解决了问题的第一部分。\n$\\epsilon = \\frac{\\Delta}{2}$。\n\n对于第二部分，我们必须找到有效攻击功率，定义为：\n$$P_{\\mathrm{eff}} \\;=\\; \\sup_{\\;|\\delta| \\le \\epsilon,\\;\\; Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))} \\; \\delta^{2}$$\n我们已经发现 $\\epsilon = \\frac{\\Delta}{2}$。我们也证明了对于任何满足 $|\\delta| \\le \\epsilon$ 的 $\\delta$，条件 $Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))$ 都满足。因此，上确界的约束集就是 $|\\delta| \\le \\epsilon$，即 $|\\delta| \\le \\frac{\\Delta}{2}$。\n问题简化为寻找：\n$$P_{\\mathrm{eff}} = \\sup_{|\\delta| \\le \\frac{\\Delta}{2}} \\delta^2$$\n函数 $f(\\delta) = \\delta^2$ 在闭区间 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ 上的最大值在其端点处取得，即在 $\\delta = \\frac{\\Delta}{2}$ 和 $\\delta = -\\frac{\\Delta}{2}$ 处。\n上确界值为：\n$$P_{\\mathrm{eff}} = \\left(\\frac{\\Delta}{2}\\right)^2 = \\frac{\\Delta^2}{4}$$\n\n问题要求 $\\epsilon$ 以伏特（V）为单位，$\\,P_{\\mathrm{eff}}\\,$ 以平方伏特（$\\text{V}^2$）为单位。这意味着量 $\\Delta$ 是以伏特为单位测量的。推导出的表达式在量纲上是一致的。\n\n两个结果是 $\\epsilon = \\frac{\\Delta}{2}$ 和 $P_{\\mathrm{eff}} = \\frac{\\Delta^2}{4}$。我们按要求将它们表示为单个矩阵表达式。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\Delta}{2}  \\frac{\\Delta^{2}}{4} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在确保CPS安全时，分析其核心学习组件（即神经网络）的属性至关重要。本练习将指导你实现一种关键的鲁棒性分析技术：通过计算网络各层的谱范数来估计其全局利普希茨常数。这个常数量化了网络输出对输入扰动的敏感度，是提供可证明鲁棒性保证的基础。",
            "id": "4204838",
            "problem": "考虑一个信息物理系统 (CPS) 中的一个基于学习的控制器，该控制器由一个数字孪生进行镜像。该控制器被实现为一个前馈神经网络，层与层之间使用全连接层和修正线性单元 (ReLU) 激活函数。网络对对抗性扰动的鲁棒性在 $\\ell_2$ 范数下进行评估。您必须设计一个程序，为每个给定的网络和输入，通过谱范数计算全局 Lipschitz 常数的一个上界，并用它来预测在指定的扰动半径下，分类是否是可证鲁棒的。\n\n基本原理和定义：\n- 矩阵 $A$ 在 $\\ell_2$ 范数下的诱导算子范数等于其谱范数，即最大奇异值。\n- $A$ 的谱范数为 $\\sigma_{\\max}(A) = \\sqrt{\\lambda_{\\max}(A^\\top A)}$，其中 $\\lambda_{\\max}$ 表示最大特征值。\n- 仿射层 $x \\mapsto Ax + b$ 在 $\\ell_2$ 范数下的 Lipschitz 常数是 $\\sigma_{\\max}(A)$；偏置 $b$ 不影响 Lipschitz 常数。\n- ReLU 激活函数为 $x \\mapsto \\max(0, x)$，在 $\\ell_2$ 范数下的 Lipschitz 常数为 $1$。\n- 对于函数复合 $f = f_n \\circ \\cdots \\circ f_1$，其 Lipschitz 常数的一个上界是各部分上界的乘积。\n- 令 $f(x)$ 表示网络对于输入 $x$ 的输出 logits 向量。定义 logit 边际 $m(x)$ 为 $f(x)$ 的最大分量与第二大分量之差。对于半径为 $\\epsilon$ 的任何 $\\ell_2$ 扰动，可证鲁棒性的一个充分条件是 $\\epsilon  \\frac{m(x)}{L}$，其中 $L$ 是全局 Lipschitz 常数的一个上界。\n\n算法要求：\n- 通过对 $A^\\top A$ 进行迭代，实现幂迭代法来近似计算 $\\sigma_{\\max}(A)$：\n  - 在 $\\mathbb{R}^d$ 中初始化一个非零向量 $u_0$，其中 $d$ 是 $A$ 的列数，并将其归一化为单位范数。\n  - 对于 $k = 0, 1, \\dots$ 直至最大迭代次数，计算 $v_{k+1} = (A^\\top A) u_k$，设置 $u_{k+1} = v_{k+1} / \\|v_{k+1}\\|_2$，并在 $\\|u_{k+1} - u_k\\|_2$ 低于一个容差时停止。\n  - 估计 $\\lambda_{\\max} \\approx u^\\top (A^\\top A) u$ 并返回 $\\sigma_{\\max}(A) \\approx \\sqrt{\\lambda_{\\max}}$。\n- 使用各层谱范数的乘积来界定全局 Lipschitz 常数，将 ReLU 层的 Lipschitz 常数视为 $1$。\n- 最后一层必须是仿射层（即线性变换加偏置）；不要在最后一层之后应用 ReLU，以使输出为 logits。\n- 对于每个测试用例，计算每层的谱范数列表、全局 Lipschitz 上界 $L$、边际 $m(x)$，并使用严格不等式 $\\epsilon  \\frac{m(x)}{L}$ 判断在指定的 $\\epsilon$ 下鲁棒性证书是否成立。\n- 如果 $L = 0$，则网络输出相对于输入是恒定的，分类对于任何有限的 $\\epsilon$ 都是可证鲁棒的。\n\n幂迭代的数值参数：\n- 最大迭代次数：$1000$。\n- 容差：$1\\times 10^{-10}$。\n- 通过归一化一个全为一的向量来初始化 $u_0$。\n\n网络、输入和扰动半径（所有量均为无量纲；不涉及物理单位）：\n\n测试用例 1（两层网络，两类 logits）：\n- 第 1 层：权重矩阵\n  $$\n  W_1 =\n  \\begin{bmatrix}\n  1.0  0.5 \\\\\n  -0.3  0.8\n  \\end{bmatrix},\n  $$\n  偏置 $b_1 = \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix}$。\n- 第 2 层：权重矩阵\n  $$\n  W_2 =\n  \\begin{bmatrix}\n  0.7  -0.4 \\\\\n  0.3  0.9\n  \\end{bmatrix},\n  $$\n  偏置 $b_2 = \\begin{bmatrix} 0.05 \\\\ -0.1 \\end{bmatrix}$。\n- 输入 $x = \\begin{bmatrix} 0.6 \\\\ -1.2 \\end{bmatrix}$。\n- 扰动半径 $\\epsilon = 0.2$。\n\n测试用例 2（三层网络，三类 logits，边界条件为 $\\epsilon$ 等于计算出的认证半径）：\n- 第 1 层：权重矩阵\n  $$\n  W_1 =\n  \\begin{bmatrix}\n  1.2  -0.7  0.3 \\\\\n  0.5  0.9  -1.1 \\\\\n  -0.4  0.2  0.8\n  \\end{bmatrix},\n  $$\n  偏置 $b_1 = \\begin{bmatrix} 0.1 \\\\ -0.05 \\\\ 0.2 \\end{bmatrix}$。\n- 第 2 层：权重矩阵\n  $$\n  W_2 =\n  \\begin{bmatrix}\n  0.6  0.0  -0.3 \\\\\n  0.2  -0.5  1.0 \\\\\n  0.7  0.4  -0.6\n  \\end{bmatrix},\n  $$\n  偏置 $b_2 = \\begin{bmatrix} 0.0 \\\\ 0.1 \\\\ -0.1 \\end{bmatrix}$。\n- 第 3 层：权重矩阵\n  $$\n  W_3 =\n  \\begin{bmatrix}\n  0.9  -0.2  0.5 \\\\\n  -0.3  0.8  0.1 \\\\\n  0.4  0.3  -0.7\n  \\end{bmatrix},\n  $$\n  偏置 $b_3 = \\begin{bmatrix} 0.05 \\\\ -0.05 \\\\ 0.0 \\end{bmatrix}$。\n- 输入 $x = \\begin{bmatrix} 0.3 \\\\ -0.8 \\\\ 1.1 \\end{bmatrix}$。\n- 扰动半径 $\\epsilon$ 设定为等于根据网络和输入计算出的认证半径 $\\frac{m(x)}{L}$。\n\n测试用例 3（单层网络，权重为零，以测试 $L=0$ 的边界情况，两类 logits）：\n- 第 1 层：权重矩阵\n  $$\n  W_1 =\n  \\begin{bmatrix}\n  0.0  0.0 \\\\\n  0.0  0.0\n  \\end{bmatrix},\n  $$\n  偏置 $b_1 = \\begin{bmatrix} 1.0 \\\\ -2.0 \\end{bmatrix}$。\n- 输入 $x = \\begin{bmatrix} 100.0 \\\\ -50.0 \\end{bmatrix}$。\n- 扰动半径 $\\epsilon = 10.0$。\n\n所需输出和格式：\n- 对于每个测试用例，输出一个包含以下内容的列表：\n  - 按顺序排列的每层权重矩阵的谱范数列表。\n  - 全局 Lipschitz 上界 $L$（谱范数的乘积）。\n  - 边际 $m(x)$（最大 logit 减去第二大 logit）。\n  - 在指定 $\\epsilon$ 下，根据严格不等式判断的可证鲁棒性的布尔决策。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，不含任何空格，每个测试用例的结果本身也用方括号括起来。例如：$[[\\text{sn\\_list},L,m,\\text{robust}],[\\dots],[\\dots]]$。\n\n您的任务：\n- 精确实现所述计算。\n- 在幂迭代中，使用指定的容差和最大迭代次数确保数值稳定性。\n- 根据上述定义处理 $L=0$ 的情况。",
            "solution": "该问题被认为是有效的。它在科学上基于数值线性代数原理和神经网络中的对抗性鲁棒性理论。问题是适定的，所有必要的数据、定义和算法都已明确提供。语言客观、精确，设定自洽且一致。\n\n任务是为几个前馈神经网络计算 $\\ell_2$ Lipschitz 常数的上界，并用它来证明其对抗性扰动的鲁棒性。解决方案包括三个主要部分：使用幂迭代法计算层权重矩阵的谱范数，计算网络的前向传播以找到输出 logits 和边际，以及应用给定的鲁棒性证书。\n\n设前馈神经网络是 $n$ 个函数的复合，$f = f_n \\circ \\dots \\circ f_1$。网络由仿射变换和 ReLU 激活组成。仿射层形如 $f_i(z) = W_i z + b_i$，ReLU 激活是逐元素应用的，$\\text{ReLU}(z)_j = \\max(0, z_j)$。最后一层是仿射层，产生 logits。问题指定了一个由仿射变换和 ReLU 激活交替组成的网络结构：\n$$ f(x) = f_n \\circ g_{n-1} \\circ \\dots \\circ g_1 \\circ f_1(x) $$\n其中 $f_i(z) = W_i z + b_i$ 是仿射层，$g_i(z) = \\text{ReLU}(z)$ 是激活函数。最后一层 $f_n$ 没有后续的 ReLU 激活。\n\n函数 $h$ 在 $\\ell_2$ 范数下的 Lipschitz 常数，记为 $L(h)$，是满足 $\\|h(x) - h(y)\\|_2 \\le L(h) \\|x - y\\|_2$ 对所有 $x,y$ 成立的最小值。复合函数 $f$ 的 Lipschitz 常数的一个上界可以通过其构成函数的 Lipschitz 常数相乘得到：\n$$ L(f) \\le L(f_n) \\cdot L(g_{n-1}) \\cdot \\dots \\cdot L(g_1) \\cdot L(f_1) $$\n仿射层 $f_i(z) = W_i z + b_i$ 的 Lipschitz 常数是权重矩阵的谱范数，$L(f_i) = \\sigma_{\\max}(W_i)$。偏置 $b_i$ 不影响 Lipschitz 常数。ReLU 激活的 Lipschitz 常数为 $L(g_i) = 1$。因此，网络全局 Lipschitz 常数的一个上界是网络权重矩阵谱范数的乘积：\n$$ L = \\prod_{i=1}^{n} \\sigma_{\\max}(W_i) $$\n\n矩阵 $A$ 的谱范数 $\\sigma_{\\max}(A)$ 是其最大奇异值，也就是半正定矩阵 $A^\\top A$ 的最大特征值 $\\lambda_{\\max}$ 的平方根。我们将按规定使用幂迭代法来计算它。\n用于寻找矩阵 $M = A^\\top A$ 最大特征值的幂迭代算法如下：\n1. 初始化一个随机非零向量 $u_0$ 并将其归一化：$u_0 = u_0 / \\|u_0\\|_2$。问题指定用一个全为一的向量来初始化。\n2. 对于 $k = 0, 1, 2, \\dots$ 迭代，直至达到最大迭代次数：\n   a. 计算序列中的下一个向量：$v_{k+1} = M u_k = (A^\\top A) u_k$。\n   b. 归一化新向量：$u_{k+1} = v_{k+1} / \\|v_{k+1}\\|_2$。\n   c. 检查收敛性：如果 $\\|u_{k+1} - u_k\\|_2$ 小于某个容差，则停止。\n3. 一旦迭代收敛到主导特征向量 $u$，相应的特征值 $\\lambda_{\\max}$ 可以用瑞利商估计：$\\lambda_{\\max} \\approx u^\\top M u$。\n4. 谱范数则为 $\\sigma_{\\max}(A) = \\sqrt{\\lambda_{\\max}}$。\n\n计算完全局 Lipschitz 上界 $L$ 后，我们对输入 $x$ 进行一次网络前向传播，以获得输出 logit 向量 $f(x)$。logit 边际 $m(x)$ 定义为最大和第二大 logit 值之间的差。\n可证鲁棒性的一个充分条件是，对于任何满足 $\\|\\delta\\|_2 \\le \\epsilon$ 的扰动 $\\delta$，$x+\\delta$ 的分类与 $x$ 的分类保持不变。如果扰动半径 $\\epsilon$ 满足严格不等式，这一点就能得到保证：\n$$ \\epsilon  \\frac{m(x)}{L} $$\n如果 $L=0$，则网络的输出是恒定的（与输入无关），因为所有权重矩阵的谱范数都为零，意味着它们都是零矩阵。在这种情况下，分类无法改变，网络对于任何有限的 $\\epsilon$ 都是可证鲁棒的。\n\n我们现在将此过程应用于每个测试用例。\n\n**测试用例 1：**\n- 层：$f(x) = (W_2 \\cdot \\text{ReLU}(W_1 x + b_1) + b_2)$\n- $W_1 = \\begin{bmatrix} 1.0  0.5 \\\\ -0.3  0.8 \\end{bmatrix}, b_1 = \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix}$\n- $W_2 = \\begin{bmatrix} 0.7  -0.4 \\\\ 0.3  0.9 \\end{bmatrix}, b_2 = \\begin{bmatrix} 0.05 \\\\ -0.1 \\end{bmatrix}$\n- $x = \\begin{bmatrix} 0.6 \\\\ -1.2 \\end{bmatrix}, \\epsilon = 0.2$\n\n1.  **谱范数：**\n    -   对于 $W_1$：通过幂迭代计算 $\\sigma_{\\max}(W_1)$。\n    -   对于 $W_2$：通过幂迭代计算 $\\sigma_{\\max}(W_2)$。\n2.  **全局 Lipschitz 界：** $L = \\sigma_{\\max}(W_1) \\cdot \\sigma_{\\max}(W_2)$。\n3.  **前向传播：**\n    -   $z_0 = W_1 x + b_1 = \\begin{bmatrix} 1.0  0.5 \\\\ -0.3  0.8 \\end{bmatrix} \\begin{bmatrix} 0.6 \\\\ -1.2 \\end{bmatrix} + \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix} = \\begin{bmatrix} 0.0 \\\\ -1.14 \\end{bmatrix} + \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix} = \\begin{bmatrix} 0.1 \\\\ -1.34 \\end{bmatrix}$。\n    -   $z_1 = \\text{ReLU}(z_0) = \\begin{bmatrix} \\max(0, 0.1) \\\\ \\max(0, -1.34) \\end{bmatrix} = \\begin{bmatrix} 0.1 \\\\ 0.0 \\end{bmatrix}$。\n    -   $f(x) = W_2 z_1 + b_2 = \\begin{bmatrix} 0.7  -0.4 \\\\ 0.3  0.9 \\end{bmatrix} \\begin{bmatrix} 0.1 \\\\ 0.0 \\end{bmatrix} + \\begin{bmatrix} 0.05 \\\\ -0.1 \\end{bmatrix} = \\begin{bmatrix} 0.07 \\\\ 0.03 \\end{bmatrix} + \\begin{bmatrix} 0.05 \\\\ -0.1 \\end{bmatrix} = \\begin{bmatrix} 0.12 \\\\ -0.07 \\end{bmatrix}$。\n4.  **边际：** logits 是 $0.12$ 和 $-0.07$。边际为 $m(x) = 0.12 - (-0.07) = 0.19$。\n5.  **鲁棒性检查：** 比较 $\\epsilon = 0.2$ 和 $m(x)/L = 0.19 / L$。\n\n**测试用例 2：**\n- 层：$f(x) = W_3 \\cdot \\text{ReLU}(W_2 \\cdot \\text{ReLU}(W_1 x + b_1) + b_2) + b_3$\n- $W_1, b_1, W_2, b_2, W_3, b_3$ 是给定的 $3 \\times 3$ 和 $3 \\times 1$ 矩阵。\n- $x = \\begin{bmatrix} 0.3 \\\\ -0.8 \\\\ 1.1 \\end{bmatrix}$。\n\n1.  **谱范数：** 通过幂迭代计算 $\\sigma_{\\max}(W_1)$、$\\sigma_{\\max}(W_2)$ 和 $\\sigma_{\\max}(W_3)$。\n2.  **全局 Lipschitz 界：** $L = \\sigma_{\\max}(W_1) \\cdot \\sigma_{\\max}(W_2) \\cdot \\sigma_{\\max}(W_3)$。\n3.  **前向传播：** 将 $x$ 通过网络传播以找到 logits $f(x)$。\n4.  **边际：** 从三个输出 logits 计算 $m(x)$。\n5.  **鲁棒性检查：** 问题陈述设定 $\\epsilon = m(x)/L$。鲁棒性条件是严格不等式 $\\epsilon  m(x)/L$。由于 $\\epsilon$ 被设定为等于右侧，条件 $\\epsilon  \\epsilon$ 将为假。因此鲁棒性证书不成立。\n\n**测试用例 3：**\n- 层：$f(x) = W_1 x + b_1$\n- $W_1 = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}, b_1 = \\begin{bmatrix} 1.0 \\\\ -2.0 \\end{bmatrix}$\n- $x = \\begin{bmatrix} 100.0 \\\\ -50.0 \\end{bmatrix}, \\epsilon = 10.0$\n\n1.  **谱范数：** 零矩阵的谱范数为 $0$。所以，$\\sigma_{\\max}(W_1) = 0$。\n2.  **全局 Lipschitz 界：** $L = \\sigma_{\\max}(W_1) = 0$。\n3.  **前向传播：** $f(x) = W_1 x + b_1 = 0 \\cdot x + b_1 = b_1 = \\begin{bmatrix} 1.0 \\\\ -2.0 \\end{bmatrix}$。输出是恒定的。\n4.  **边际：** logits 是 $1.0$ 和 $-2.0$。边际为 $m(x) = 1.0 - (-2.0) = 3.0$。\n5.  **鲁棒性检查：** 问题陈述指出，如果 $L=0$，分类对于任何有限的 $\\epsilon$ 都是可证鲁棒的。由于 $\\epsilon = 10.0$ 是有限的，该条件成立。结果为 `True`。\n\n这些步骤将在提供的 Python 代码中实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of certifying neural network robustness.\n    \"\"\"\n\n    def power_iteration(A, max_iter=1000, tol=1e-10):\n        \"\"\"\n        Computes the spectral norm of a matrix A using power iteration.\n        The spectral norm is the largest singular value, sigma_max(A),\n        which is sqrt(lambda_max(A.T @ A)).\n        \"\"\"\n        if A.shape[1] == 0:\n            return 0.0\n        \n        # Power iteration on A.T @ A to find its largest eigenvalue.\n        M = A.T @ A\n        \n        # Initialize a vector u_0 from a vector of ones, normalized.\n        u = np.ones(M.shape[1])\n        u = u / np.linalg.norm(u)\n\n        for _ in range(max_iter):\n            v = M @ u\n            u_new = v / np.linalg.norm(v)\n\n            if np.linalg.norm(u_new - u)  tol:\n                break\n            \n            u = u_new\n        \n        # Estimate lambda_max using the Rayleigh quotient: u.T @ M @ u\n        # where u is the approximated eigenvector.\n        lambda_max = u.T @ M @ u\n        \n        # The spectral norm is the square root of the largest eigenvalue.\n        # Add a small epsilon to handle potential floating-point inaccuracies\n        # resulting in a tiny negative number.\n        spectral_norm = np.sqrt(max(0, lambda_max))\n        return spectral_norm\n\n    test_cases = [\n        {\n            \"weights\": [\n                np.array([[1.0, 0.5], [-0.3, 0.8]]),\n                np.array([[0.7, -0.4], [0.3, 0.9]])\n            ],\n            \"biases\": [\n                np.array([0.1, -0.2]),\n                np.array([0.05, -0.1])\n            ],\n            \"input\": np.array([0.6, -1.2]),\n            \"epsilon\": 0.2\n        },\n        {\n            \"weights\": [\n                np.array([[1.2, -0.7, 0.3], [0.5, 0.9, -1.1], [-0.4, 0.2, 0.8]]),\n                np.array([[0.6, 0.0, -0.3], [0.2, -0.5, 1.0], [0.7, 0.4, -0.6]]),\n                np.array([[0.9, -0.2, 0.5], [-0.3, 0.8, 0.1], [0.4, 0.3, -0.7]])\n            ],\n            \"biases\": [\n                np.array([0.1, -0.05, 0.2]),\n                np.array([0.0, 0.1, -0.1]),\n                np.array([0.05, -0.05, 0.0])\n            ],\n            \"input\": np.array([0.3, -0.8, 1.1]),\n            \"epsilon\": None  # To be computed\n        },\n        {\n            \"weights\": [\n                np.array([[0.0, 0.0], [0.0, 0.0]])\n            ],\n            \"biases\": [\n                np.array([1.0, -2.0])\n            ],\n            \"input\": np.array([100.0, -50.0]),\n            \"epsilon\": 10.0\n        }\n    ]\n\n    all_results = []\n\n    for i, case in enumerate(test_cases):\n        weights = case[\"weights\"]\n        biases = case[\"biases\"]\n        x = case[\"input\"]\n        epsilon = case[\"epsilon\"]\n\n        # 1. Compute spectral norms and global Lipschitz bound L\n        spectral_norms = [power_iteration(w) for w in weights]\n        lipschitz_bound = np.prod(spectral_norms)\n\n        # 2. Perform the forward pass\n        current_val = x\n        # Hidden layers with ReLU\n        for j in range(len(weights) - 1):\n            current_val = weights[j] @ current_val + biases[j]\n            current_val = np.maximum(0, current_val)\n        # Final affine layer (logits)\n        logits = weights[-1] @ current_val + biases[-1]\n\n        # 3. Compute the margin\n        if len(logits)  2:\n            # Undefined for single-class output\n            margin = float('inf') \n        else:\n            sorted_logits = np.sort(logits)\n            margin = sorted_logits[-1] - sorted_logits[-2]\n\n        # 4. Handle special epsilon for Test Case 2\n        if i == 1: # Test Case 2\n            if lipschitz_bound > 0:\n                epsilon = margin / lipschitz_bound\n            else: # Should not happen in this case, but for correctness\n                epsilon = float('inf')\n\n        # 5. Check the robustness certificate\n        if lipschitz_bound == 0:\n            # If L=0, output is constant, robust for any finite epsilon\n            is_robust = True\n        else:\n            # Strict inequality is required\n            is_robust = epsilon  margin / lipschitz_bound\n\n        all_results.append([spectral_norms, lipschitz_bound, margin, is_robust])\n\n    # Format the final output string to match the required format without spaces\n    result_strings = []\n    for sn_list, L, m, robust in all_results:\n        sn_list_str = f\"[{','.join(f'{sn:.15f}' for sn in sn_list)}]\"\n        # Format to remove unnecessary trailing zeros and ensure high precision\n        L_str = f\"{L:.15f}\"\n        m_str = f\"{m:.15f}\"\n        robust_str = str(robust)\n        case_result_str = f\"[{sn_list_str},{L_str},{m_str},{robust_str}]\"\n        result_strings.append(case_result_str)\n\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "最终，我们需要将控制器和物理设备作为一个整体来评估系统的安全性。本练习将介绍一种强大的形式化验证方法——可达性分析，用于在存在对抗性攻击和外部扰动的情况下，为闭环系统提供安全保证。你将通过区间算术来过近似系统的可达状态集，并验证系统是否始终满足给定的安全规范。",
            "id": "4204835",
            "problem": "考虑一个在信息物理系统（CPS）的数字孪生内部，由一个学习型策略控制的离散时间线性时不变系统。系统状态为 $x_t \\in \\mathbb{R}^2$，控制输入为 $u_t \\in \\mathbb{R}$，观测到的测量值为 $y_t \\in \\mathbb{R}^2$。其动态方程为\n$$\nx_{t+1} = A x_t + B u_t + w_t,\n$$\n其中 $A \\in \\mathbb{R}^{2 \\times 2}$，$B \\in \\mathbb{R}^{2 \\times 1}$，$w_t$ 是一个外源扰动向量。测量值受到对抗性传感器噪声 $\\delta_t$ 的干扰，因此\n$$\ny_t = x_t + \\delta_t.\n$$\n控制输入由一个具有单隐藏层和整流线性单元（ReLU）激活函数的前馈人工神经网络（ANN）生成，该网络将 $y_t$ 映射为 $u_t = \\pi(y_t)$。对抗方在一个逐元素的区间预算内选择 $\\delta_t$，环境在一个逐元素的区间预算内注入 $w_t$。我们通过过近似这些对抗性选择下的可达集来寻求一种经认证的安全保证。\n\n基本原理：\n- 对于一个仿射映射 $z = W a + b$，其中 $a$ 位于逐元素的区间 $[l,u]$ 内，其传播集合可以通过以下基于单调性的包络来界定。设 $W^+ = \\max(W,0)$ 和 $W^- = \\min(W,0)$ 分别是 $W$ 的逐元素的非负部分和非正部分。则像区间 $[l_z, u_z]$ 为\n$$\nl_z = W^+ l + W^- u + b, \\quad u_z = W^+ u + W^- l + b.\n$$\n- ReLU 操作 $\\mathrm{ReLU}(z) = \\max(0,z)$ 是逐元素单调的，所以如果 $z \\in [l,u]$（逐元素），那么 $\\mathrm{ReLU}(z) \\in [\\max(0,l), \\max(0,u)]$（逐元素）。\n- 区间的闵可夫斯基和满足 $[l_1,u_1] + [l_2,u_2] = [l_1 + l_2, u_1 + u_2]$（逐元素）。\n\n控制器架构与参数：\n- 隐藏层有 $4$ 个单元，其权重 $W_1 \\in \\mathbb{R}^{4 \\times 2}$ 和偏置 $b_1 \\in \\mathbb{R}^{4}$ 由下式给出\n$$\nW_1 = \\begin{bmatrix}\n1  0\\\\\n-1  0\\\\\n0  1\\\\\n0  -1\n\\end{bmatrix}, \\quad b_1 = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.\n$$\n- 输出层的权重 $W_2 \\in \\mathbb{R}^{1 \\times 4}$ 和偏置 $b_2 \\in \\mathbb{R}$ 由下式给出\n$$\nW_2 = \\begin{bmatrix} -1  1  -0.5  0.5 \\end{bmatrix}, \\quad b_2 = 0.\n$$\n- 层间使用 $\\mathrm{ReLU}$ 激活函数，因此对于任何输入 $y \\in \\mathbb{R}^2$，\n$$\nu = \\pi(y) = W_2 \\, \\mathrm{ReLU}(W_1 y + b_1) + b_2.\n$$\n该网络实现了 $u \\approx -x_1 - 0.5 x_2$ 的一个分段线性近似。\n\n受控对象模型：\n- 系统矩阵对应于一个采样周期为 $h = 0.1$ 的离散化双积分器，\n$$\nA = \\begin{bmatrix}\n1  0.1\\\\\n0  1\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n0.005\\\\\n0.1\n\\end{bmatrix}.\n$$\n\n对抗性输入与扰动集：\n- 对抗方可以在一个逐元素的边界 $\\varepsilon \\ge 0$ 内扰动观测的每个分量，因此对于所有 $t$，$\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$。\n- 扰动位于一个逐元素的区间 $w_t \\in [-\\bar{w}, \\bar{w}]^2$ 内，其中 $\\bar{w} \\ge 0$ 是一个应用于两个状态分量的给定标量边界。\n\n初始集：\n- 初始状态位于一个盒子 $x_0 \\in [\\underline{x}_0, \\overline{x}_0]$ 内，其中\n$$\n\\underline{x}_0 = \\begin{bmatrix} 0.045\\\\ -0.005 \\end{bmatrix}, \\quad\n\\overline{x}_0 = \\begin{bmatrix} 0.055\\\\ 0.005 \\end{bmatrix}.\n$$\n\n安全规约：\n- 安全约束要求位置分量 $x_{t,1}$ 在所有时间 $t \\in \\{0,1,\\dots,T\\}$ 满足 $|x_{t,1}| \\le p_{\\max}$，即多面体集\n$$\n\\mathcal{S}(p_{\\max}) = \\{ x \\in \\mathbb{R}^2 : C x \\le d \\}, \\quad\nC = \\begin{bmatrix} 1  0\\\\ -1  0 \\end{bmatrix}, \\quad\nd = \\begin{bmatrix} p_{\\max}\\\\ p_{\\max} \\end{bmatrix}.\n$$\n\n认证安全问题：\n- 仅使用上述基本事实和提供的参数，通过以下方式为 $t = 0,1,\\dots,T$ 递归地过近似可达状态区间 $[ \\underline{x}_t, \\overline{x}_t ]$：\n    - 计算观测区间 $[ \\underline{y}_t, \\overline{y}_t ] = [ \\underline{x}_t - \\varepsilon \\mathbf{1}, \\overline{x}_t + \\varepsilon \\mathbf{1} ]$。\n    - 使用区间边界将 $[ \\underline{y}_t, \\overline{y}_t ]$ 通过 ANN 进行传播，以获得一个控制区间 $[ \\underline{u}_t, \\overline{u}_t ]$。\n    - 使用区间算术将 $[ \\underline{x}_t, \\overline{x}_t ]$ 和 $[ \\underline{u}_t, \\overline{u}_t ]$ 通过系统动态方程进行传播，并加上扰动区间 $[-\\bar{w}, \\bar{w}]^2$ 以获得 $[ \\underline{x}_{t+1}, \\overline{x}_{t+1} ]$。\n- 当且仅当对于所有 $t \\in \\{0,1,\\dots,T\\}$，每个安全不等式的最坏情况下的值都是非正的，即在区间 $[ \\underline{x}_t, \\overline{x}_t ]$ 上 $C x_t - d$ 的上界逐元素地 $\\le 0$，认证安全测试成立。\n\n测试套件：\n对于以下每个参数元组 $(\\varepsilon, p_{\\max}, T, \\bar{w})$，确定一个布尔值，指示在整个时间范围 $t \\in \\{0,1,\\dots,T\\}$ 内，对于所有允许的对抗性传感器噪声和扰动，安全约束是否被认证为成立。\n- 情况 1：$\\varepsilon = 0.01$, $p_{\\max} = 0.2$, $T = 20$, $\\bar{w} = 0.0005$。\n- 情况 2：$\\varepsilon = 0.05$, $p_{\\max} = 0.08$, $T = 30$, $\\bar{w} = 0.0005$。\n- 情况 3：$\\varepsilon = 0.0$, $p_{\\max} = 0.06$, $T = 10$, $\\bar{w} = 0.0$。\n- 情况 4：$\\varepsilon = 0.02$, $p_{\\max} = 0.1$, $T = 50$, $\\bar{w} = 0.0002$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述顺序排列的各案例结果，形式为一个由逗号分隔的 Python布尔字面值列表，并用方括号括起，例如 $[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True}, \\mathrm{True} ]$。\n- 不需要单位，因为本问题中所有量都被视为无量纲。",
            "solution": "用户的请求是验证并解决一个关于学习型控制系统认证安全的问题。该过程涉及对一个离散时间线性系统，在对抗性传感器攻击和环境扰动下，迭代计算其可达状态集的过近似。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **系统动态方程**：$x_{t+1} = A x_t + B u_t + w_t$，状态 $x_t \\in \\mathbb{R}^2$，控制输入 $u_t \\in \\mathbb{R}$。\n- **测量方程**：$y_t = x_t + \\delta_t$，测量值 $y_t \\in \\mathbb{R}^2$。\n- **控制器**：一个前馈人工神经网络（ANN），$u_t = \\pi(y_t) = W_2 \\, \\mathrm{ReLU}(W_1 y_t + b_1) + b_2$。\n- **对抗性集合**：\n    - 传感器噪声：$\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$。\n    - 扰动：$w_t \\in [-\\bar{w}, \\bar{w}]^2$。\n- **集合传播规则（基本原理）**：\n    - 仿射映射 $z = W a + b$，$a \\in [l,u]$：$[l_z, u_z] = [W^+ l + W^- u + b, W^+ u + W^- l + b]$，其中 $W^+ = \\max(W,0)$ 且 $W^- = \\min(W,0)$。\n    - ReLU 激活函数 $\\mathrm{ReLU}(z)$，$z \\in [l,u]$：$[\\max(0,l), \\max(0,u)]$。\n    - 区间的闵可夫斯基和：$[l_1,u_1] + [l_2,u_2] = [l_1 + l_2, u_1 + u_2]$。\n- **控制器参数**：\n    - $W_1 = \\begin{bmatrix} 1  0\\\\ -1  0\\\\ 0  1\\\\ 0  -1 \\end{bmatrix} \\in \\mathbb{R}^{4 \\times 2}$\n    - $b_1 = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\in \\mathbb{R}^{4}$\n    - $W_2 = \\begin{bmatrix} -1  1  -0.5  0.5 \\end{bmatrix} \\in \\mathbb{R}^{1 \\times 4}$\n    - $b_2 = 0 \\in \\mathbb{R}$\n- **系统参数**（离散化双积分器，$h=0.1$）：\n    - $A = \\begin{bmatrix} 1  0.1\\\\ 0  1 \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 2}$\n    - $B = \\begin{bmatrix} 0.005\\\\ 0.1 \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 1}$\n- **初始状态集**：$x_0 \\in [\\underline{x}_0, \\overline{x}_0]$，其中 $\\underline{x}_0 = \\begin{bmatrix} 0.045\\\\ -0.005 \\end{bmatrix}$ 且 $\\overline{x}_0 = \\begin{bmatrix} 0.055\\\\ 0.005 \\end{bmatrix}$。\n- **安全规约**：对所有 $t \\in \\{0, 1, \\dots, T\\}$，$|x_{t,1}| \\le p_{\\max}$，由多面体 $\\mathcal{S}(p_{\\max}) = \\{ x \\in \\mathbb{R}^2 : C x \\le d \\}$ 定义，其中 $C = \\begin{bmatrix} 1  0\\\\ -1  0 \\end{bmatrix}$ 且 $d = \\begin{bmatrix} p_{\\max}\\\\ p_{\\max} \\end{bmatrix}$。\n- **可达性算法**：\n    1.  计算观测区间：$[ \\underline{y}_t, \\overline{y}_t ] = [ \\underline{x}_t - \\varepsilon \\mathbf{1}, \\overline{x}_t + \\varepsilon \\mathbf{1} ]$。\n    2.  通过将 $[\\underline{y}_t, \\overline{y}_t]$ 在ANN中传播，计算控制区间 $[\\underline{u}_t, \\overline{u}_t]$。\n    3.  通过动态方程传播 $[\\underline{x}_t, \\overline{x}_t]$ 和 $[\\underline{u}_t, \\overline{u}_t]$，并加上扰动区间，计算下一状态区间 $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$。\n- **安全认证测试**：若对所有 $t \\in \\{0, 1, \\dots, T\\}$，在集合 $[\\underline{x}_t, \\overline{x}_t]$ 上 $C x_t - d$ 的上界逐元素非正，则认证通过。\n- **测试套件**：\n    - 情况 1：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.01, 0.2, 20, 0.0005)$\n    - 情况 2：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.05, 0.08, 30, 0.0005)$\n    - 情况 3：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.0, 0.06, 10, 0.0)$\n    - 情况 4：$(\\varepsilon, p_{\\max}, T, \\bar{w}) = (0.02, 0.1, 50, 0.0002)$\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据、问题良态且客观。它是信息物理系统形式化验证和鲁棒控制领域的标准问题。模型基于线性系统理论和神经网络，分析方法是区间算术，这在数学上是合理的。所有参数、方程和程序都已明确指定，没有歧义、矛盾或信息缺失。该问题可形式化且需要非平凡的计算，直接解决了指定的主题。\n\n**步骤3：结论与行动**\n问题有效。将通过实现指定的可达性算法来提供解决方案。\n\n### 解法\n\n该问题要求我们通过计算状态可达集的区间过近似来确定控制系统的认证安全。我们将实现指定的递归算法。设时间 $t$ 的状态区间为 $[\\underline{x}_t, \\overline{x}_t]$。目标是计算下一状态的区间 $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$，并在每一步验证安全性。\n\n**1. 安全验证**\n在每个离散时间步 $t \\in \\{0, 1, \\dots, T\\}$，我们必须验证计算出的状态区间 $[\\underline{x}_t, \\overline{x}_t]$ 完全包含在安全集 $\\mathcal{S}(p_{\\max})$ 内。安全条件为 $|x_{t,1}| \\le p_{\\max}$，这可以转化为两个不等式：$x_{t,1} \\le p_{\\max}$ 和 $-x_{t,1} \\le p_{\\max}$。为检验这些不等式对整个区间都成立，我们必须检验它们的最坏情况值。这要求：\n- $\\max(x_{t,1}) = \\overline{x}_{t,1} \\le p_{\\max}$\n- $\\max(-x_{t,1}) = -\\underline{x}_{t,1} \\le p_{\\max}$，这等价于 $\\underline{x}_{t,1} \\ge -p_{\\max}$\n如果这两个条件都满足，则系统在时间 $t$ 是安全的。如果从 $t=0$ 到 $T$ 的所有时间步都满足此条件，则整个系统被认证为安全。\n\n**2. 可达集传播（从 $t$ 到 $t+1$）**\n\n**步骤2.1：观测区间**\n测量值 $y_t = x_t + \\delta_t$ 受到对抗性传感器攻击 $\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$ 的影响。给定状态区间 $[\\underline{x}_t, \\overline{x}_t]$，观测值 $y_t$ 的区间通过状态区间与噪声区间 $[-\\varepsilon \\mathbf{1}, \\varepsilon \\mathbf{1}]$ 的闵可夫斯基和求得，其中 $\\mathbf{1}$ 是元素全为1的向量。\n$$ \\underline{y}_t = \\underline{x}_t - \\varepsilon \\mathbf{1} $$\n$$ \\overline{y}_t = \\overline{x}_t + \\varepsilon \\mathbf{1} $$\n\n**步骤2.2：控制输入区间**\n控制输入 $u_t$ 通过将观测区间 $[\\underline{y}_t, \\overline{y}_t]$ 在神经网络控制器 $u_t = W_2 \\, \\mathrm{ReLU}(W_1 y_t + b_1) + b_2$ 中传播来确定。\n\n- **第一次仿射变换**：设 $z_{t,1} = W_1 y_t + b_1$。$z_{t,1}$ 的区间为 $[\\underline{z}_{t,1}, \\overline{z}_{t,1}]$，使用指定的基于单调性的包络规则计算：\n  $$ \\underline{z}_{t,1} = W_1^+ \\underline{y}_t + W_1^- \\overline{y}_t + b_1 $$\n  $$ \\overline{z}_{t,1} = W_1^+ \\overline{y}_t + W_1^- \\underline{y}_t + b_1 $$\n  其中 $W_1^+ = \\max(W_1, 0)$ 和 $W_1^- = \\min(W_1, 0)$ 分别是 $W_1$ 的逐元素正部和负部。\n\n- **ReLU 激活函数**：设 $a_{t,1} = \\mathrm{ReLU}(z_{t,1})$。激活输出的区间 $[\\underline{a}_{t,1}, \\overline{a}_{t,1}]$ 通过对其输入区间的边界应用 ReLU 函数得到：\n  $$ \\underline{a}_{t,1} = \\mathrm{ReLU}(\\underline{z}_{t,1}) = \\max(0, \\underline{z}_{t,1}) $$\n  $$ \\overline{a}_{t,1} = \\mathrm{ReLU}(\\overline{z}_{t,1}) = \\max(0, \\overline{z}_{t,1}) $$\n\n- **第二次仿射变换（输出）**：最终的控制输入为 $u_t = W_2 a_{t,1} + b_2$。其区间 $[\\underline{u}_t, \\overline{u}_t]$ 同样计算：\n  $$ \\underline{u}_t = W_2^+ \\underline{a}_{t,1} + W_2^- \\overline{a}_{t,1} + b_2 $$\n  $$ \\overline{u}_t = W_2^+ \\overline{a}_{t,1} + W_2^- \\underline{a}_{t,1} + b_2 $$\n\n**步骤2.3：下一状态区间**\n下一状态 $x_{t+1} = A x_t + B u_t + w_t$ 是三项之和，每一项都位于一个区间内。$x_{t+1}$ 的结果区间是每一项区间的闵可夫斯基和。\n\n- **$A x_t$ 的区间**：使用仿射传播规则，输入为 $x_t \\in [\\underline{x}_t, \\overline{x}_t]$：\n  $$ [\\underline{(Ax_t)}, \\overline{(Ax_t)}] = [A^+ \\underline{x}_t + A^- \\overline{x}_t, A^+ \\overline{x}_t + A^- \\underline{x}_t] $$\n- **$B u_t$ 的区间**：使用仿射传播规则，输入为 $u_t \\in [\\underline{u}_t, \\overline{u}_t]$：\n  $$ [\\underline{(Bu_t)}, \\overline{(Bu_t)}] = [B^+ \\underline{u}_t + B^- \\overline{u}_t, B^+ \\overline{u}_t + B^- \\underline{u}_t] $$\n- **$w_t$ 的区间**：给定为 $[-\\bar{w}\\mathbf{1}, \\bar{w}\\mathbf{1}]$。\n\n将这些区间边界相加，得到下一状态区间 $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$：\n$$ \\underline{x}_{t+1} = (A^+ \\underline{x}_t + A^- \\overline{x}_t) + (B^+ \\underline{u}_t + B^- \\overline{u}_t) - \\bar{w}\\mathbf{1} $$\n$$ \\overline{x}_{t+1} = (A^+ \\overline{x}_t + A^- \\underline{x}_t) + (B^+ \\overline{u}_t + B^- \\underline{u}_t) + \\bar{w}\\mathbf{1} $$\n\n由于给定的矩阵 $A$ 和 $B$ 的所有元素都是非负的，所以 $A^+=A$, $A^-=0$, $B^+=B$, $B^-=0$。传播规则简化为：\n$$ \\underline{x}_{t+1} = A \\underline{x}_t + B \\underline{u}_t - \\bar{w}\\mathbf{1} $$\n$$ \\overline{x}_{t+1} = A \\overline{x}_t + B \\overline{u}_t + \\bar{w}\\mathbf{1} $$\n针对每个测试案例实施此完整的递归过程，以确定其认证安全状态。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the certified safety problem for the four test cases specified.\n    \"\"\"\n    test_cases = [\n        # (epsilon, p_max, T, w_bar)\n        (0.01, 0.2, 20, 0.0005),\n        (0.05, 0.08, 30, 0.0005),\n        (0.0, 0.06, 10, 0.0),\n        (0.02, 0.1, 50, 0.0002),\n    ]\n\n    results = []\n    for case in test_cases:\n        is_safe = check_safety_certification(case)\n        results.append(is_safe)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_safety_certification(params):\n    \"\"\"\n    Performs reachability analysis for a given set of parameters to certify safety.\n\n    Args:\n        params (tuple): A tuple containing (epsilon, p_max, T, w_bar).\n\n    Returns:\n        bool: True if the system is certified safe, False otherwise.\n    \"\"\"\n    eps, p_max, T, w_bar = params\n\n    # --- System and Controller Parameters ---\n    # Using column vectors (shape N,1) for consistency in matrix operations.\n    \n    # Plant model\n    A = np.array([[1.0, 0.1], [0.0, 1.0]], dtype=float)\n    B = np.array([[0.005], [0.1]], dtype=float)\n\n    # Controller ANN parameters\n    W1 = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=float)\n    b1 = np.zeros((4, 1), dtype=float)\n    W2 = np.array([[-1, 1, -0.5, 0.5]], dtype=float)\n    b2 = np.array([[0.0]], dtype=float)\n\n    # Initial state set\n    x0_lower = np.array([[0.045], [-0.005]], dtype=float)\n    x0_upper = np.array([[0.055], [0.005]], dtype=float)\n\n    # Pre-compute positive and negative parts of weight matrices for propagation\n    W1_pos = np.maximum(W1, 0)\n    W1_neg = np.minimum(W1, 0)\n    W2_pos = np.maximum(W2, 0)\n    W2_neg = np.minimum(W2, 0)\n    \n    # Since A and B are non-negative, the general formula simplifies,\n    # but we implement the general form for correctness.\n    A_pos = np.maximum(A, 0)\n    A_neg = np.minimum(A, 0)\n    B_pos = np.maximum(B, 0)\n    B_neg = np.minimum(B, 0)\n\n    # Initialize current state interval\n    x_lower = x0_lower\n    x_upper = x0_upper\n\n    # Constant interval vectors for noise and disturbance\n    eps_vec = np.full((2, 1), eps)\n    w_bar_vec = np.full((2, 1), w_bar)\n\n    # --- Main Reachability Loop ---\n    for t in range(T + 1):\n        # 1. Safety Verification\n        # Check if the current reachable set violates the safety constraints.\n        # Condition: -p_max = x_t,1 = p_max\n        if x_upper[0, 0] > p_max or x_lower[0, 0]  -p_max:\n            return False  # Safety violated\n\n        # If it's the last time step, no need to compute the next state.\n        if t == T:\n            break\n\n        # 2. Reachable Set Propagation\n        \n        # 2.1. Observation Interval Calculation\n        y_lower = x_lower - eps_vec\n        y_upper = x_upper + eps_vec\n\n        # 2.2. Control Input Interval Calculation (propagate through ANN)\n        # First affine layer\n        z1_lower = W1_pos @ y_lower + W1_neg @ y_upper + b1\n        z1_upper = W1_pos @ y_upper + W1_neg @ y_lower + b1\n\n        # ReLU activation\n        a1_lower = np.maximum(0, z1_lower)\n        a1_upper = np.maximum(0, z1_upper)\n\n        # Output layer\n        u_lower = W2_pos @ a1_lower + W2_neg @ a1_upper + b2\n        u_upper = W2_pos @ a1_upper + W2_neg @ a1_lower + b2\n        \n        # 2.3. Next State Interval Calculation\n        # Contribution from Ax_t\n        ax_lower = A_pos @ x_lower + A_neg @ x_upper\n        ax_upper = A_pos @ x_upper + A_neg @ x_lower\n\n        # Contribution from Bu_t\n        bu_lower = B_pos @ u_lower + B_neg @ u_upper\n        bu_upper = B_pos @ u_upper + B_neg @ u_lower\n        \n        # Minkowski sum for the next state interval\n        x_next_lower = ax_lower + bu_lower - w_bar_vec\n        x_next_upper = ax_upper + bu_upper + w_bar_vec\n\n        # Update state for the next iteration\n        x_lower = x_next_lower\n        x_upper = x_next_upper\n\n    # If the loop completes without any safety violations, the property is certified.\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}