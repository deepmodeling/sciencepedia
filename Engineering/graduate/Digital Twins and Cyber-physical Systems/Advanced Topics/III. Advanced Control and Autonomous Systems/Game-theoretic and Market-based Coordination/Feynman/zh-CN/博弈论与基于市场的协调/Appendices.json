{
    "hands_on_practices": [
        {
            "introduction": "这个练习是进入博弈论思维的切入点。它模拟了一个常见的信息物理系统场景，其中个体智能体的行为会对其他智能体产生负外部性（例如拥塞）。通过推导纳什均衡，学生将学习如何预测去中心化、自利行为的最终结果，并理解系统参数如何影响这一均衡点。",
            "id": "4224185",
            "problem": "考虑一个信息物理系统 (CPS) 中的协同资源共享场景，其中 $n$ 个在边缘设备上运行的相同数字孪生同时选择其数据更新速率 $x_i \\in \\mathbb{R}_{\\ge 0}$，以最大化各自的效用。更高更新速率带来的收益被建模为线性新鲜度奖励，而本地能源和拥塞惩罚则分别被建模为二次项和双线性项。智能体 $i$ 的效用为\n$$\nu_i(x_i,x_{-i}) \\;=\\; a\\,x_i \\;-\\; \\frac{b}{2}\\,x_i^{2} \\;-\\; c\\,x_i \\sum_{j \\ne i} x_j,\n$$\n其中 $a > 0$ 是新鲜度的边际价值，$b > 0$ 反映了计算和通信的本地二次成本，$c \\ge 0$ 反映了因共享无线和计算资源拥塞而引起的单位交叉影响所对应的基于市场的协调价格。各智能体同时且非合作地选择 $x_i$。假设参数值使得纳什均衡是内部的（即，最优响应在严格为正的选择上达到）。\n\n从纳什均衡的定义（即每个智能体的行动在给定其他智能体行动的情况下最大化其自身效用）和单决策变量凹最大化问题的一阶最优性条件出发，推导出每个智能体的对称纳什均衡更新速率 $x^{*}$。然后，通过对 $x^{*}$ 关于 $c$ 求导，对 $c$ 进行比较静态分析，并确定 $\\frac{\\partial x^{*}}{\\partial c}$ 的解析表达式及其符号。\n\n将您的最终结果表示为 $x^{*}$ 和 $\\frac{\\partial x^{*}}{\\partial c}$ 的闭式解析表达式。无需进行数值计算或四舍五入，最终答案中也无需报告物理单位。",
            "solution": "所述问题是有效的。它提出了一个清晰、自洽且有科学依据的博弈论问题，具体是为多智能体系统中的非合作资源分配建模。效用函数是标准的二次型，这保证了效用函数对于智能体自身行动是严格凹的，从而确保了使用一阶条件寻找纳什均衡的问题是适定的。所有参数都用必要的约束（$a>0$，$b>0$，$c \\ge 0$）进行了明确定义，并且目标陈述精确。该问题没有歧义、矛盾和事实错误。\n\n该问题的核心是找到一个博弈的对称纳什均衡，其中 $n$ 个智能体选择其行动 $x_i$ 以最大化各自的效用。纳什均衡是一个策略组合 $(x_1^*, x_2^*, \\ldots, x_n^*)$，使得对于每个智能体 $i$，$x_i^*$ 是对其他智能体均衡策略 $x_{-i}^*$ 的最优响应。也就是说，$x_i^*$ 最大化了 $u_i(x_i, x_{-i}^*)$。\n\n智能体 $i$ 的效用函数由下式给出：\n$$\nu_i(x_i, x_{-i}) = a\\,x_i - \\frac{b}{2}\\,x_i^{2} - c\\,x_i \\sum_{j \\ne i} x_j\n$$\n为了找到智能体 $i$ 的最优响应，我们将其效用 $u_i$ 关于其自身行动 $x_i$ 进行最大化，同时将所有其他智能体 $j$（$j \\ne i$）的行动 $x_j$ 视为固定参数。由于问题假设存在内部解（$x_i > 0$），我们可以通过求效用函数关于 $x_i$ 的一阶偏导数并将其设为零来找到最优的 $x_i$。\n\n首先，我们计算偏导数：\n$$\n\\frac{\\partial u_i}{\\partial x_i} = \\frac{\\partial}{\\partial x_i} \\left( a\\,x_i - \\frac{b}{2}\\,x_i^{2} - c\\,x_i \\sum_{j \\ne i} x_j \\right) = a - b\\,x_i - c\\,\\sum_{j \\ne i} x_j\n$$\n为了确认将此导数设为零能得到最大值，我们检查二阶条件。二阶偏导数为：\n$$\n\\frac{\\partial^2 u_i}{\\partial x_i^2} = -b\n$$\n由于 $b > 0$，二阶导数严格为负。这证实了效用函数 $u_i$ 关于 $x_i$ 是严格凹的，因此一阶条件足以确定智能体 $i$ 效用的唯一全局最大值。\n\n将一阶条件设为零，得到智能体 $i$ 的最优响应函数：\n$$\na - b\\,x_i - c\\,\\sum_{j \\ne i} x_j = 0\n$$\n$$\nb\\,x_i = a - c\\,\\sum_{j \\ne i} x_j\n$$\n$$\nx_i = \\frac{a - c\\,\\sum_{j \\ne i} x_j}{b}\n$$\n接下来，我们寻找对称纳什均衡。在对称均衡中，所有智能体选择相同的行动，我们记为 $x^*$。因此，对于所有 $i \\in \\{1, 2, \\ldots, n\\}$，都有 $x_i = x^*$。对于任何智能体 $i$，其他智能体行动的总和变为：\n$$\n\\sum_{j \\ne i} x_j = \\sum_{j \\ne i} x^* = (n-1)x^*\n$$\n将此结果及 $x_i = x^*$ 代入一阶条件 ($a - b\\,x_i - c\\,\\sum_{j \\ne i} x_j = 0$)：\n$$\na - b\\,x^* - c\\,(n-1)x^* = 0\n$$\n现在，我们求解该方程以得到 $x^*$：\n$$\na = b\\,x^* + c\\,(n-1)x^*\n$$\n$$\na = x^* \\left( b + c(n-1) \\right)\n$$\n这就得出了对称纳什均衡更新速率：\n$$\nx^* = \\frac{a}{b + c(n-1)}\n$$\n问题接着要求通过求 $x^*$ 关于协调价格参数 $c$ 的导数来进行比较静态分析。我们将 $x^*$ 的表达式对 $c$ 求导，同时将 $a$、$b$ 和 $n$ 视为常数。使用商法则或等价地，对 $x^* = a(b + c(n-1))^{-1}$ 使用链式法则：\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\frac{d}{dc} \\left[ (b + c(n-1))^{-1} \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\left[ -1 \\cdot (b + c(n-1))^{-2} \\cdot \\frac{d}{dc}(b + c(n-1)) \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\left[ -(b + c(n-1))^{-2} \\cdot (n-1) \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = -\\frac{a(n-1)}{\\left( b + c(n-1) \\right)^2}\n$$\n最后，我们确定该导数的符号。问题陈述 $a > 0$ 且 $b > 0$。智能体数量 $n$ 是大于或等于 1 的整数。协调的背景意味着 $n \\ge 2$，这使得项 $(n-1)$ 为正。参数 $c$ 是非负的，$c \\ge 0$。\n分子是 $a(n-1)$。对于 $n \\ge 2$，该项为正。\n分母是 $(b + c(n-1))^2$。由于 $b>0$，$c \\ge 0$ 且 $n \\ge 2$，底数 $b + c(n-1)$ 严格为正。因此其平方也严格为正。\n因此，该导数是一个负量除以一个正量：\n$$\n\\frac{\\partial x^*}{\\partial c}  0 \\quad \\text{for } n \\ge 2\n$$\n如果 $n=1$，问题退化为没有交互的单智能体优化问题，项 $(n-1)$ 为零，且 $\\frac{\\partial x^*}{\\partial c} = 0$，这是合理的，因为在这种情况下 $c$ 没有影响。考虑到问题背景，我们假设 $n \\ge 2$。负号表明，随着拥塞价格 $c$ 的增加，每个智能体的均衡更新速率 $x^*$ 会降低。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{a}{b + c(n-1)}  -\\frac{a(n-1)}{(b + c(n-1))^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了去中心化的策略行为之后，这个练习将视角转向了社会最优结果的概念。它展示了中央计划者或系统范围的协调者如何实现总福利的最大化。学生将使用强大的优化工具（KKT条件）来找到这种有效分配，并且关键地，将看到市场出清价格如何自然地作为共享资源的“影子价格”而出现。",
            "id": "4224163",
            "problem": "考虑一个通过其信息物理系统 (CPS) 的数字孪生进行协调的信息物理能源微电网。一个聚合商供应总量为 $Q$ 的能源，其成本为 $C(Q) = \\frac{\\beta}{2} Q^{2}$。共有 $n$ 个消费者，由 $i \\in \\{1,2,\\dots,n\\}$ 索引，每个消费者对消费量 $x_{i}$ 的线性估值为 $v_{i}(x_{i}) = \\alpha_{i} x_{i}$，且受限于 $0 \\leq x_{i} \\leq \\bar{x}_{i}$，以及市场出清约束 $Q = \\sum_{i=1}^{n} x_{i}$。聚合商宣布单位能源的标量价格 $p$，该价格必须与实现的 $Q$ 值下的边际成本一致，即 $p = C'(Q)$。社会规划者的问题是在耦合约束和箱式约束下最大化总福利：\n$$\n\\max_{x,Q} \\;\\; \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2}\n\\quad \\text{subject to} \\quad\nQ = \\sum_{i=1}^{n} x_{i}, \\quad 0 \\leq x_{i} \\leq \\bar{x}_{i}.\n$$\n您需要通过写出并求解 Karush–Kuhn–Tucker (KKT) 系统来刻画从该社会福利最大化问题中产生的竞争均衡（Karush–Kuhn–Tucker (KKT) 条件是约束凸优化的一阶最优性条件），将均衡价格 $p^{*}$ 识别为耦合约束上的拉格朗日乘子（其必须等于边际成本），并通过箱式约束处的法锥条件推导出均衡分配。\n\n使用以下数据：\n- 消费者数量 $n = 4$。\n- 估值斜率 $\\alpha_{1} = 6$, $\\alpha_{2} = 3$, $\\alpha_{3} = 1.2$, $\\alpha_{4} = 0.9$。\n- 容量上限 $\\bar{x}_{1} = 2$, $\\bar{x}_{2} = 1$, $\\bar{x}_{3} = 0.5$, $\\bar{x}_{4} = 0.5$。\n- 成本参数 $\\beta = 1$。\n\n假设目标和约束与陈述完全一致，且均衡是唯一的。使用 KKT 系统找到福利最大化的分配 $(x^{*}, Q^{*})$ 以及相应的均衡价格 $p^{*} = \\beta Q^{*}$。仅报告均衡价格 $p^{*}$ 作为您的最终答案。以“货币单位/能源单位”表示价格。无需四舍五入。",
            "solution": "问题是通过求解一个社会福利最大化问题，来找到一个信息物理能源微电网中的均衡价格。该问题是一个约束凸优化问题，可以使用 Karush-Kuhn-Tucker (KKT) 条件来求解。\n\n首先，我们验证问题的有效性。\n- **已知条件**：\n  - 目标：$\\max_{x,Q} \\;\\; \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2}$\n  - 约束：$Q = \\sum_{i=1}^{n} x_{i}$，以及对所有 $i \\in \\{1, \\dots, n\\}$ 都有 $0 \\leq x_{i} \\leq \\bar{x}_{i}$。\n  - 数据：$n=4$，$\\alpha = (6, 3, 1.2, 0.9)$，$\\bar{x} = (2, 1, 0.5, 0.5)$，$\\beta=1$。\n- **验证**：\n  - 该问题具有科学依据，代表了经济市场中社会福利最大化的标准模型。二次成本函数和线性估值函数是常见且有效的建模选择。\n  - 目标函数是严格凹的，约束集是一个非空、紧凑的凸集。这保证了唯一解的存在，从而使问题是适定的。\n  - 所有术语都有定义，数据充分，没有矛盾。该问题是有效的。\n\n我们现在通过构建 KKT 系统来求解该问题。优化问题是：\n$$\n\\max_{x_{1},\\dots,x_{n},Q} \\;\\; \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2}\n$$\n受约束于：\n$$\n\\sum_{i=1}^{n} x_{i} - Q = 0 \\\\\nx_{i} - \\bar{x}_{i} \\leq 0, \\quad \\forall i \\in \\{1, \\dots, n\\} \\\\\n-x_{i} \\leq 0, \\quad \\forall i \\in \\{1, \\dots, n\\}\n$$\n设 $p$ 是耦合（等式）约束的拉格朗日乘子，$\\mu_{i}$ 是上界约束 ($x_{i} \\leq \\bar{x}_{i}$) 的乘子，$\\lambda_{i}$ 是下界约束 ($x_{i} \\geq 0$) 的乘子。该最大化问题的拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(x, Q, p, \\mu, \\lambda) = \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2} - p\\left(\\sum_{i=1}^{n} x_{i} - Q\\right) - \\sum_{i=1}^{n} \\mu_{i}(x_{i} - \\bar{x}_{i}) - \\sum_{i=1}^{n} \\lambda_{i}(-x_{i})\n$$\n最优解 $(x^{*}, Q^{*})$ 和相应乘子 $(p^{*}, \\mu^{*}, \\lambda^{*})$ 的 KKT 条件如下：\n\n1.  **平稳性条件** (拉格朗日函数的梯度为零)：\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial Q} = -\\beta Q^{*} + p^{*} = 0 \\implies p^{*} = \\beta Q^{*}\n    $$\n    这证实了问题陈述中的条件，即均衡价格 $p^{*}$ 等于边际成本 $C'(Q^{*}) = \\beta Q^{*}$。\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial x_{i}} = \\alpha_{i} - p^{*} - \\mu_{i}^{*} + \\lambda_{i}^{*} = 0 \\implies \\alpha_{i} - p^{*} = \\mu_{i}^{*} - \\lambda_{i}^{*}, \\quad \\forall i \\in \\{1, \\dots, n\\}\n    $$\n\n2.  **原始可行性 (Primal Feasibility)**：\n    $$\n    \\sum_{i=1}^{n} x_{i}^{*} - Q^{*} = 0\n    $$\n    $$\n    0 \\leq x_{i}^{*} \\leq \\bar{x}_{i}, \\quad \\forall i\n    $$\n\n3.  **对偶可行性 (Dual Feasibility)**：\n    $$\n    \\mu_{i}^{*} \\geq 0, \\quad \\lambda_{i}^{*} \\geq 0, \\quad \\forall i\n    $$\n\n4.  **互补松弛性 (Complementary Slackness)**：\n    $$\n    \\mu_{i}^{*}(x_{i}^{*} - \\bar{x}_{i}) = 0, \\quad \\forall i\n    $$\n    $$\n    \\lambda_{i}^{*} x_{i}^{*} = 0, \\quad \\forall i\n    $$\n\n从平稳性条件和互补松弛性条件中，我们可以推断出在给定价格 $p^{*}$ 下每个消费者 $i$ 的行为：\n-   如果 $0  x_{i}^{*}  \\bar{x}_{i}$，那么互补松弛性要求 $\\mu_{i}^{*} = 0$ 且 $\\lambda_{i}^{*} = 0$。此时关于 $x_i$ 的平稳性条件简化为 $\\alpha_{i} - p^{*} = 0$，即 $p^{*} = \\alpha_{i}$。\n-   如果 $x_{i}^{*} = \\bar{x}_{i}$，那么 $\\lambda_{i}^{*} = 0$。平稳性条件为 $\\alpha_{i} - p^{*} = \\mu_{i}^{*}$。由于 $\\mu_{i}^{*} \\geq 0$，这意味着 $\\alpha_{i} \\geq p^{*}$。\n-   如果 $x_{i}^{*} = 0$，那么 $\\mu_{i}^{*} = 0$。平稳性条件为 $\\alpha_{i} - p^{*} = -\\lambda_{i}^{*}$。由于 $\\lambda_{i}^{*} \\geq 0$，这意味着 $\\alpha_{i} \\leq p^{*}$。\n\n综合这些情况，对于给定的均衡价格 $p^{*}$，最优分配 $x_{i}^{*}$ 为：\n$$\nx_{i}^{*}(p^{*}) =\n\\begin{cases}\n\\bar{x}_{i}  \\text{如果 } p^{*}  \\alpha_{i} \\\\\n\\text{在 } [0, \\bar{x}_{i}] \\text{ 内的任意值}  \\text{如果 } p^{*} = \\alpha_{i} \\\\\n0  \\text{如果 } p^{*}  \\alpha_{i}\n\\end{cases}\n$$\n这就将每个消费者的需求定义为价格的函数。当总需求等于总供给时，达到均衡。总供给量为 $Q^{*}$，它与价格的关系为 $p^{*} = \\beta Q^{*}$，因此总供给为 $S(p^{*}) = Q^{*} = p^{*}/\\beta$。总需求为 $D(p^{*}) = \\sum_{i=1}^{n} x_{i}^{*}(p^{*})$。\n均衡价格 $p^{*}$ 必须满足市场出清条件：\n$$\n\\sum_{i=1}^{n} x_{i}^{*}(p^{*}) = \\frac{p^{*}}{\\beta}\n$$\n我们使用给定数据：$\\beta = 1$，$\\alpha = (6, 3, 1.2, 0.9)$，以及 $\\bar{x} = (2, 1, 0.5, 0.5)$。市场出清条件变为 $\\sum_{i=1}^{4} x_{i}^{*}(p^{*}) = p^{*}$。我们相对于估值参数 $\\alpha_i$（已按 $\\alpha_1  \\alpha_2  \\alpha_3  \\alpha_4$ 排序）测试不同的价格水平。\n\n-   **情况1：$p^{*}  \\alpha_{1} = 6$**。对所有 $i$，都有 $p^{*}  \\alpha_{i}$，因此 $x_{i}^{*} = 0$。总需求为 0。方程为 $0 = p^{*}$，这与 $p^{*}  6$ 相矛盾。\n\n-   **情况2：$p^{*} = \\alpha_{1} = 6$**。此处 $x_{1}^{*} \\in [0, 2]$ 且 $x_{2}^{*}=x_{3}^{*}=x_{4}^{*}=0$。方程为 $x_{1}^{*} = 6$。这与约束 $x_{1}^{*} \\leq \\bar{x}_{1} = 2$ 相矛盾。\n\n-   **情况3：$\\alpha_{2}  p^{*}  \\alpha_{1}$（即 $3  p^{*}  6$）**。此处 $p^{*}  \\alpha_{1}$，所以 $x_{1}^{*} = \\bar{x}_{1} = 2$。对于 $i=2,3,4$，$p^{*}  \\alpha_{i}$，所以 $x_{2}^{*}=x_{3}^{*}=x_{4}^{*}=0$。总需求为 2。方程为 $2 = p^{*}$。这与假设的价格范围 $p^{*} \\in (3, 6)$ 相矛盾。\n\n-   **情况4：$p^{*} = \\alpha_{2} = 3$**。此处 $p^{*}  \\alpha_{1}$，所以 $x_{1}^{*} = \\bar{x}_{1} = 2$。当 $p^{*} = \\alpha_{2}$ 时，消费者2是无差异的，所以 $x_{2}^{*} \\in [0, \\bar{x}_{2}] = [0, 1]$。对于 $i=3,4$，$p^{*}  \\alpha_{i}$，所以 $x_{3}^{*}=x_{4}^{*}=0$。总需求为 $2 + x_{2}^{*}$。市场出清方程为 $2 + x_{2}^{*} = p^{*} = 3$。这得出 $x_{2}^{*} = 1$。该值在 $x_2^*$ 的允许范围内，因为 $x_2^* \\in [0, 1]$。我们找到了一个一致的解。我们来验证一下：\n    -   均衡价格：$p^{*} = 3$。\n    -   分配：$x_{1}^{*} = 2$（因为 $3  6$），$x_{2}^{*} = 1$（使市场出清的值），$x_{3}^{*} = 0$（因为 $3  1.2$），$x_{4}^{*} = 0$（因为 $3  0.9$）。\n    -   总量：$Q^{*} = \\sum x_{i}^{*} = 2 + 1 + 0 + 0 = 3$。\n    -   价格-成本一致性：$p^{*} = \\beta Q^{*} \\implies 3 = 1 \\times 3$，该式成立。\n    所有条件都满足。唯一的均衡价格是 $p^{*} = 3$。\n\n-   **情况5：$\\alpha_3  p^*  \\alpha_2$（即 $1.2  p^*  3$）**。此处 $x_1^*=\\bar{x}_1=2$，$x_2^*=\\bar{x}_2=1$，且 $x_3^*=x_4^*=0$。总需求为 $2+1 = 3$。方程将是 $3=p^*$，这与 $p^*  3$ 相矛盾。\n\n分析证实，唯一有效的解出现在 $p^{*} = 3$ 时。\n均衡价格为 3 货币单位/能源单位。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "最后的这个实践将前面的概念整合到一个强大的框架中：机制设计。它解决了一个复杂的组合分配问题，其中智能体对任务组合拥有私有估值。通过实施Vickrey-Clarke-Groves (VCG) 机制，学生将构建一个系统，该系统不仅能找到社会有效的分配方案，还能巧妙地设计支付规则，以确保智能体没有动机谎报其偏好。这是一个位于现代基于市场的协调核心的实用性计算挑战。",
            "id": "4224153",
            "problem": "考虑一个信息物理系统 (CPS) 中的组合性任务分配问题，其中数字孪生代表可以执行任务包的代理人。系统中有 $N$ 个代理人和 $T$ 个不可分割的任务，任务的索引标签在 $\\{0,1,\\dots,T-1\\}$ 集合中。每个代理人 $i \\in \\{0,1,\\dots,N-1\\}$ 对每一个任务包 $S \\subseteq \\{0,1,\\dots,T-1\\}$ 报告一个估值函数 $v_i(S)$，其中 $v_i(\\emptyset) = 0$。一个分配方案是对任务集合在代理人之间的一种划分，其约束条件是每个任务至多分配给一个代理人，且任务可以保持未分配状态。代理人具有拟线性效用，因此对于一个分配方案 $\\{S_i\\}_{i=0}^{N-1}$ 和支付 $\\{p_i\\}_{i=0}^{N-1}$，每个代理人的效用为 $u_i = v_i(S_i) - p_i$。\n\n实现 Vickrey–Clarke–Groves (VCG) 机制：选择一个在可行性约束下最大化总报告社会福利 $\\sum_{i=0}^{N-1} v_i(S_i)$ 的分配方案，并计算 Clarke 枢轴支付，其中代理人 $i$ 的支付为\n$$\np_i = h_i - \\sum_{j \\ne i} v_j(S_j^*)\n$$\n其中 $h_i$ 等于移除代理人 $i$ 时，所有其他代理人的最大总福利，而 $\\{S_j^*\\}$ 表示所有代理人都在场时所选择的福利最大化分配。如果有多个分配方案达到相同的最大社会福利，则通过选择使分配向量 $(a_0,a_1,\\dots,a_{T-1})$ 字典序最小的分配方案来打破平局。其中 $a_t \\in \\{-1,0,1,\\dots,N-1\\}$ 表示分配给任务 $t$ 的代理人索引，-1 表示任务未分配。排序定义为 $-1  0  1  \\dots  (N-1)$。\n\n从拟线性偏好和有效机制的基本原理出发，并且不假设超出这些范围的捷径结果。\n\n对于每个测试用例，你的程序必须输出一个列表，其中包含：最大社会福利（浮点数）、分配给每个代理人的任务（编码为整数位掩码，即每个代理人 $i$ 被分配一个掩码 $m_i \\in \\{0,1,\\dots,2^T-1\\}$，当且仅当任务 $t$ 分配给代理人 $i$ 时，$m_i$ 的第 $t$ 位为 1），以及每个代理人的 VCG 支付（浮点数）。将所有测试用例的结果汇总到单行打印输出，格式为方括号内包含的逗号分隔列表，例如 $[result_1,result_2,\\dots]$。\n\n测试套件：\n- 用例 1：$N=2$, $T=3$。任务为 $\\{0,1,2\\}$。对所有子集 $S$ 的报告估值 $v_0$ 和 $v_1$ 如下所示（每个子集由其在 $\\{0,1,\\dots,7\\}$ 中的位掩码表示，其中第 $t$ 位表示任务 $t$ 是否包含在内）：\n  - 代理人 0：$v_0(\\emptyset)=0$, $v_0(\\{0\\})=3$, $v_0(\\{1\\})=2$, $v_0(\\{2\\})=2$, $v_0(\\{0,1\\})=6.5$, $v_0(\\{0,2\\})=5.5$, $v_0(\\{1,2\\})=4.5$, $v_0(\\{0,1,2\\})=8.0$。\n    位掩码形式：$v_0(0)=0$, $v_0(1)=3$, $v_0(2)=2$, $v_0(4)=2$, $v_0(3)=6.5$, $v_0(5)=5.5$, $v_0(6)=4.5$, $v_0(7)=8.0$。\n  - 代理人 1：$v_1(\\emptyset)=0$, $v_1(\\{0\\})=4.5$, $v_1(\\{1\\})=1.5$, $v_1(\\{2\\})=1.0$, $v_1(\\{0,1\\})=5.0$, $v_1(\\{0,2\\})=5.2$, $v_1(\\{1,2\\})=2.2$, $v_1(\\{0,1,2\\})=5.3$。\n    位掩码形式：$v_1(0)=0$, $v_1(1)=4.5$, $v_1(2)=1.5$, $v_1(4)=1.0$, $v_1(3)=5.0$, $v_1(5)=5.2$, $v_1(6)=2.2$, $v_1(7)=5.3$。\n- 用例 2：$N=3$, $T=1$。任务为 $\\{0\\}$。估值是对称且单值的：对于每个代理人 $i \\in \\{0,1,2\\}$，$v_i(\\emptyset)=0$ 且 $v_i(\\{0\\})=5$。\n- 用例 3：$N=2$, $T=4$。任务为 $\\{0,1,2,3\\}$。估值具有任务可加性；也就是说，对于每个代理人 $i$，$v_i(S) = \\sum_{t \\in S} a_{i,t}$。原子值为代理人 0 的 $a_{0,0}=2.0, a_{0,1}=3.0, a_{0,2}=1.0, a_{0,3}=4.0$，和代理人 1 的 $a_{1,0}=3.0, a_{1,1}=1.0, a_{1,2}=5.0, a_{1,3}=0.5$。\n- 用例 4：$N=2$, $T=2$。任务为 $\\{0,1\\}$。对所有任务包的估值恒为零：对于每个代理人 $i \\in \\{0,1\\}$ 和任意 $S \\subseteq \\{0,1\\}$，$v_i(S)=0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$ [result_1,result_2,result_3,result_4]$）。每个 $result_k$ 必须是 $[\\text{SW}_k,[m_{k,0},m_{k,1},\\dots,m_{k,N-1}],[p_{k,0},p_{k,1},\\dots,p_{k,N-1}]]$ 的形式，其中 $\\text{SW}_k$ 是用例 $k$ 的最大社会福利，$m_{k,i}$ 是在用例 $k$ 中分配给代理人 $i$ 的位掩码，$p_{k,i}$ 是在用例 $k$ 中代理人 $i$ 的 VCG 支付。",
            "solution": "所提出的问题是一个有效的、良构的优化问题，根植于机制设计领域，这是博弈论和微观经济学的一个子领域，在信息物理系统中的资源分配方面有直接应用。它要求在一个组合性任务分配场景中实现 Vickrey–Clarke–Groves (VCG) 机制。\n\n**1. 基本原理**\n\n问题的基础设定是存在 $N$ 个理性代理人和一个中央计划者（即机制）。每个代理人 $i$ 对获得特定的任务包 $S$ 有一个私人估值 $v_i(S)$。假设代理人的偏好是拟线性的，这意味着他们的总效用是他们从分配到的任务包中获得的价值减去他们所做的任何货币支付：$u_i = v_i(S_i) - p_i$。目标是设计一个能实现理想结果的机制（一个分配规则和一个支付规则）。VCG 机制因其在实现 *有效* 结果的同时确保激励代理人如实报告其估值而备受推崇。\n\n一个分配方案被定义为将所有任务的集合 $T$ 划分为不相交的子集 $\\{S_0, S_1, \\dots, S_{N-1}, S_{unassigned}\\}$，其中 $S_i$ 是分配给代理人 $i$ 的任务包，$S_{unassigned}$ 是剩余的任务。如果一个结果能最大化产生的总价值，或称 *社会福利*，那么该结果是有效的。社会福利定义为所有代理人对其分配到的任务包的估值总和：$W = \\sum_{i=0}^{N-1} v_i(S_i)$。\n\n**2. VCG 机制：分配规则**\n\nVCG 机制的第一个组成部分是其分配规则：选择最大化总报告社会福利的分配方案 $\\{S_i^*\\}_{i=0}^{N-1}$。这被称为赢家确定问题 (WDP)。\n$$ \\{S_i^*\\} = \\arg\\max_{\\{S_i\\}} \\sum_{i=0}^{N-1} v_i(S_i) \\quad \\text{subject to} \\quad S_i \\cap S_j = \\emptyset \\text{ for } i \\neq j $$\n对于一般的组合性分配问题，WDP 在计算上是困难的（NP-难）。然而，对于测试用例中给出的少量任务 $T$（$T \\le 4$），我们可以通过枚举所有可能性来找到最优分配。一个分配可以由一个向量 $(a_0, a_1, \\dots, a_{T-1})$ 唯一表示，其中 $a_t$ 是分配给任务 $t$ 的代理人索引，如果任务未分配则为 -1。此类分配的总数为 $(N+1)^T$。\n\n寻找福利最大化分配的算法如下：\n1. 初始化最大福利 $W_{max} = -\\infty$ 和对应的最佳分配向量 $A^* = \\text{None}$。\n2. 遍历每个可能的分配向量 $A = (a_0, \\dots, a_{T-1})$，其中每个 $a_t \\in \\{-1, 0, \\dots, N-1\\}$。\n3. 对每个分配 $A$：\n    a. 对每个代理人 $i$，构建其任务包 $S_i = \\{t \\mid a_t = i\\}$。\n    b. 计算当前社会福利 $W_A = \\sum_{i=0}^{N-1} v_i(S_i)$。\n    c. 如果 $W_A > W_{max}$，更新 $W_{max} = W_A$ 和 $A^* = A$。\n    d. 如果 $W_A = W_{max}$，应用指定的平局打破规则：将当前分配向量 $A$ 与存储的最佳向量 $A^*$ 进行字典序比较。如果 $A$ 更小，则更新 $A^* = A$。问题指定了排序为 $-1  0  1  \\dots  N-1$。\n4. 最终的向量 $A^*$ 决定了最优分配 $\\{S_i^*\\}$，最大社会福利为 $W_{max}$。\n\n**3. VCG 机制：支付规则**\n\nVCG 的第二个组成部分是支付规则，它确保如实报告估值对所有代理人来说都是一个占优策略。代理人 $i$ 的支付，即 Clarke 枢轴支付，其计算值等于他们对社会其他成员施加的外部性。\n代理人 $i$ 的支付 $p_i$ 是：\n$$ p_i = h_i - \\sum_{j \\neq i} v_j(S_j^*) $$\n- $\\sum_{j \\neq i} v_j(S_j^*)$ 项表示在最优分配中（当代理人 $i$ 存在时）所有其他代理人的总福利。这可以计算为 $W_{max} - v_i(S_i^*)$。\n- $h_i$ 项表示如果代理人 $i$ *没有参与* 机制，*本可以实现* 的假设的最大社会福利。这是通过为代理人集合 $\\{0, \\dots, N-1\\} \\setminus \\{i\\}$ 解决一个新的 WDP 来找到的。让这个假设场景中的分配对象为 $a_t' \\in \\{-1, 0, \\dots, i-1, i+1, \\dots, N-1\\}$。那么 $h_i = \\max \\sum_{j \\neq i} v_j(S_j')$，其中 $\\{S_j'\\}$ 是在其他 $N-1$ 个代理人中的最优分配。\n\n因此，代理人 $i$ 的效用是 $u_i = v_i(S_i^*) - p_i = v_i(S_i^*) - (h_i - \\sum_{j \\neq i} v_j(S_j^*)) = (\\sum_{j=0}^{N-1} v_j(S_j^*)) - h_i = W^* - h_i$。这是代理人 $i$ 的参与所创造的社会盈余。\n\n**4. 算法实现策略**\n\n对于每个测试用例，整体算法流程如下：\n1.  **解析输入**：读取代理人数量 $N$、任务数量 $T$ 以及估值函数 $v_i$。将估值存储在合适的数据结构中，如字典列表，其中 `valuations[i][mask]` 给出代理人 $i$ 对由整数位掩码 `mask` 表示的任务包的估值。对于可加性估值，预计算完整的估值表。\n2.  **求解最优分配（$S^*$ 和 $W^*$）**：\n    实现第 2 节中描述的穷举搜索 WDP 算法，考虑所有 $N$ 个代理人（加上未分配选项）。这将产生最大社会福利 $W^*$ 和作为一组位掩码 $\\{S_0^*, S_1^*, \\dots, S_{N-1}^*\\}$ 的最优分配。\n3.  **计算假设福利（$h_i$）**：\n    对于从 $0$ 到 $N-1$ 的每个代理人 $i$：\n    a. 再次运行 WDP 算法，但这次是针对代理人集合 $\\{0, \\dots, N-1\\} \\setminus \\{i\\}$。现在每个任务的可能分配对象是 $\\{-1, 0, \\dots, i-1, i+1, \\dots, N-1\\}$。\n    b. 这个子问题的最大福利是 $h_i$。\n4.  **计算支付（$p_i$）**：\n    对于每个代理人 $i$，使用导出的值计算支付：\n    $$ p_i = h_i - (W^* - v_i(S_i^*)) $$\n5.  **格式化输出**：将测试用例的结果组装成所需的列表格式：`[W*, [S_0*, S_1*, ...], [p_0, p_1, ...]]`。最后，将所有测试用例的结果汇总到单行输出中。",
            "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n\n    # Suppress scientific notation for cleaner float output\n    np.set_printoptions(suppress=True)\n    # Redirect stdout to a buffer if needed to ensure single-line output,\n    # though direct printing should be fine.\n\n    # ------------------ Test Case 1 ------------------\n    N1, T1 = 2, 3\n    v1 = [\n        {0: 0, 1: 3, 2: 2, 3: 6.5, 4: 2, 5: 5.5, 6: 4.5, 7: 8.0},\n        {0: 0, 1: 4.5, 2: 1.5, 3: 5.0, 4: 1.0, 5: 5.2, 6: 2.2, 7: 5.3}\n    ]\n    test_cases = [(N1, T1, v1)]\n    \n    # ------------------ Test Case 2 ------------------\n    N2, T2 = 3, 1\n    v2 = [\n        {0: 0, 1: 5.0},\n        {0: 0, 1: 5.0},\n        {0: 0, 1: 5.0}\n    ]\n    test_cases.append((N2, T2, v2))\n    \n    # ------------------ Test Case 3 ------------------\n    N3, T3 = 2, 4\n    atoms3 = [\n        [2.0, 3.0, 1.0, 4.0],\n        [3.0, 1.0, 5.0, 0.5]\n    ]\n    v3 = [{}, {}]\n    for m in range(1  T3):\n        v3[0][m] = sum(atoms3[0][t] for t in range(T3) if (m >> t)  1)\n        v3[1][m] = sum(atoms3[1][t] for t in range(T3) if (m >> t)  1)\n    test_cases.append((N3, T3, v3))\n\n    # ------------------ Test Case 4 ------------------\n    N4, T4 = 2, 2\n    v4 = [\n        {m: 0.0 for m in range(1  T4)},\n        {m: 0.0 for m in range(1  T4)}\n    ]\n    test_cases.append((N4, T4, v4))\n\n    all_results = []\n    for N, T, valuations in test_cases:\n        result = _solve_vcg_case(N, T, valuations)\n        all_results.append(result)\n\n    # Format output as a string of lists, as specified by the problem's boilerplate.\n    # str([..]) produces '[.., ..]' which has spaces. The prompt requires this specific format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef _find_optimal_allocation(T, N, valuations, excluded_agents):\n    \"\"\"\n    Finds the welfare-maximizing allocation for a given set of active agents.\n    \"\"\"\n    active_agents = [i for i in range(N) if i not in excluded_agents]\n    assignee_options = [-1] + active_agents\n\n    max_welfare = -1.0\n    best_assignment = None\n\n    for assignment in product(assignee_options, repeat=T):\n        bundles = {agent_idx: 0 for agent_idx in active_agents}\n        for task_idx, agent_idx in enumerate(assignment):\n            if agent_idx != -1:\n                bundles[agent_idx] |= (1  task_idx)\n        \n        current_welfare = 0.0\n        for agent_idx, bundle_mask in bundles.items():\n            current_welfare += valuations[agent_idx].get(bundle_mask, 0.0)\n\n        if best_assignment is None or current_welfare > max_welfare:\n            max_welfare = current_welfare\n            best_assignment = assignment\n        elif abs(current_welfare - max_welfare)  1e-9: # Float comparison\n            # Tie-breaking rule: lexicographically smallest assignment vector\n            if assignment  best_assignment:\n                best_assignment = assignment\n    \n    # Convert the best assignment vector to agent masks\n    final_masks = [0] * N\n    if best_assignment:\n        for task_idx, agent_idx in enumerate(best_assignment):\n            if agent_idx != -1:\n                final_masks[agent_idx] |= (1  task_idx)\n\n    return max_welfare, final_masks\n\ndef _solve_vcg_case(N, T, valuations):\n    \"\"\"\n    Solves a single VCG problem case.\n    \"\"\"\n    # 1. Find the optimal allocation and social welfare with all agents\n    max_social_welfare, optimal_masks = _find_optimal_allocation(T, N, valuations, excluded_agents=set())\n\n    # 2. Compute VCG payments\n    payments = [0.0] * N\n    for i in range(N):\n        # Find h_i: max welfare if agent i is excluded\n        h_i, _ = _find_optimal_allocation(T, N, valuations, excluded_agents={i})\n\n        # Welfare of others in the optimal allocation\n        welfare_of_others = 0\n        for j in range(N):\n            if i != j:\n                welfare_of_others += valuations[j].get(optimal_masks[j], 0.0)\n        \n        # Clarke pivot payment\n        # p_i = h_i - welfare_of_others\n        # which is equivalent to p_i = h_i - (max_social_welfare - v_i(S_i*))\n        payments[i] = h_i - welfare_of_others\n\n    return [max_social_welfare, optimal_masks, payments]\n\nsolve()\n```"
        }
    ]
}