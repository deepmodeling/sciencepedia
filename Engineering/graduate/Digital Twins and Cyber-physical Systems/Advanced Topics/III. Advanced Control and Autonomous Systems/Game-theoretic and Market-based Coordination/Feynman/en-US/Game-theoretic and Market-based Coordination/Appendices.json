{
    "hands_on_practices": [
        {
            "introduction": "Understanding the emergent behavior of decentralized systems is fundamental to Cyber-Physical System (CPS) design. This exercise  provides practice in deriving the Nash equilibrium for a classic resource-sharing game, where agents' actions impose negative externalities on each other. By solving for the equilibrium and performing comparative statics, you will gain insight into how coordination mechanisms, such as a congestion price $c$, can be used to regulate self-interested behavior.",
            "id": "4224185",
            "problem": "Consider a coordinated resource-sharing scenario in Cyber-Physical Systems (CPS), where $n$ identical digital twins running on edge devices simultaneously select their data-update rates $x_i \\in \\mathbb{R}_{\\ge 0}$ to maximize their individual utilities. The benefit of higher update rates is modeled as linear freshness reward, and the local energy and congestion penalties are modeled as quadratic and bilinear terms, respectively. The utility for agent $i$ is\n$$\nu_i(x_i,x_{-i}) \\;=\\; a\\,x_i \\;-\\; \\frac{b}{2}\\,x_i^{2} \\;-\\; c\\,x_i \\sum_{j \\ne i} x_j,\n$$\nwhere $a > 0$ is the marginal value of freshness, $b > 0$ captures the local quadratic cost of computation and communication, and $c \\ge 0$ captures a market-based coordination price per unit cross-impact induced by congestion on shared wireless and compute resources. The agents choose $x_i$ simultaneously and noncooperatively. Assume parameter values such that the Nash equilibrium is interior (that is, the best responses are attained at strictly positive choices).\n\nStarting from the definition of a Nash equilibrium (each agent’s action maximizes its own utility given the others’ actions) and the first-order optimality conditions for concave maximization in a single decision variable, derive the symmetric Nash equilibrium update rate $x^{*}$ per agent. Then, perform comparative statics in $c$ by differentiating $x^{*}$ with respect to $c$ and determining the analytical expression and sign of $\\frac{\\partial x^{*}}{\\partial c}$.\n\nExpress your final results as closed-form analytic expressions for $x^{*}$ and $\\frac{\\partial x^{*}}{\\partial c}$. No numerical evaluation or rounding is required, and no physical units need be reported in the final answer.",
            "solution": "The problem as stated is valid. It presents a clear, self-contained, and scientifically grounded problem in game theory, specifically modeling noncooperative resource allocation in a multi-agent system. The utility function is a standard quadratic form, which guarantees strict concavity in an agent's own action, ensuring the problem is well-posed for finding a Nash equilibrium using first-order conditions. All parameters are explicitly defined with necessary constraints ($a>0$, $b>0$, $c \\ge 0$), and the objective is precisely stated. The problem is free from ambiguity, contradiction, and factual unsoundness.\n\nThe core of the problem is to find the symmetric Nash equilibrium of a game where $n$ agents choose their actions $x_i$ to maximize their individual utilities. A Nash equilibrium is a profile of strategies $(x_1^*, x_2^*, \\ldots, x_n^*)$ such that for each agent $i$, $x_i^*$ is the best response to the other agents' equilibrium strategies $x_{-i}^*$. That is, $x_i^*$ maximizes $u_i(x_i, x_{-i}^*)$.\n\nThe utility function for agent $i$ is given by:\n$$\nu_i(x_i, x_{-i}) = a\\,x_i - \\frac{b}{2}\\,x_i^{2} - c\\,x_i \\sum_{j \\ne i} x_j\n$$\nTo find agent $i$'s best response, we maximize $u_i$ with respect to its own action $x_i$, treating the actions of all other agents $x_j$ (for $j \\ne i$) as fixed parameters. Since the problem assumes an interior solution ($x_i > 0$), we can find the optimal $x_i$ by taking the first-order partial derivative of the utility function with respect to $x_i$ and setting it to zero.\n\nFirst, we compute the partial derivative:\n$$\n\\frac{\\partial u_i}{\\partial x_i} = \\frac{\\partial}{\\partial x_i} \\left( a\\,x_i - \\frac{b}{2}\\,x_i^{2} - c\\,x_i \\sum_{j \\ne i} x_j \\right) = a - b\\,x_i - c\\,\\sum_{j \\ne i} x_j\n$$\nTo confirm that setting this derivative to zero yields a maximum, we check the second-order condition. The second partial derivative is:\n$$\n\\frac{\\partial^2 u_i}{\\partial x_i^2} = -b\n$$\nSince $b > 0$, the second derivative is strictly negative. This confirms that the utility function $u_i$ is strictly concave with respect to $x_i$, and thus the first-order condition is sufficient to identify the unique global maximum for agent $i$'s utility.\n\nSetting the first-order condition to zero gives the best response function for agent $i$:\n$$\na - b\\,x_i - c\\,\\sum_{j \\ne i} x_j = 0\n$$\n$$\nb\\,x_i = a - c\\,\\sum_{j \\ne i} x_j\n$$\n$$\nx_i = \\frac{a - c\\,\\sum_{j \\ne i} x_j}{b}\n$$\nNext, we find the symmetric Nash equilibrium. In a symmetric equilibrium, all agents choose the same action, which we denote by $x^*$. Thus, $x_i = x^*$ for all $i \\in \\{1, 2, \\ldots, n\\}$. For any agent $i$, the sum of the actions of the other agents becomes:\n$$\n\\sum_{j \\ne i} x_j = \\sum_{j \\ne i} x^* = (n-1)x^*\n$$\nSubstituting this into the first-order condition ($a - b\\,x_i - c\\,\\sum_{j \\ne i} x_j = 0$) with $x_i = x^*$:\n$$\na - b\\,x^* - c\\,(n-1)x^* = 0\n$$\nNow, we solve this equation for $x^*$:\n$$\na = b\\,x^* + c\\,(n-1)x^*\n$$\n$$\na = x^* \\left( b + c(n-1) \\right)\n$$\nThis yields the symmetric Nash equilibrium update rate:\n$$\nx^* = \\frac{a}{b + c(n-1)}\n$$\nThe problem then requires performing comparative statics by finding the derivative of $x^*$ with respect to the coordination price parameter $c$. We differentiate the expression for $x^*$ with respect to $c$, treating $a$, $b$, and $n$ as constants. Using the quotient rule or, equivalently, the chain rule on $x^* = a(b + c(n-1))^{-1}$:\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\frac{d}{dc} \\left[ (b + c(n-1))^{-1} \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\left[ -1 \\cdot (b + c(n-1))^{-2} \\cdot \\frac{d}{dc}(b + c(n-1)) \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\left[ -(b + c(n-1))^{-2} \\cdot (n-1) \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = -\\frac{a(n-1)}{\\left( b + c(n-1) \\right)^2}\n$$\nFinally, we determine the sign of this derivative. The problem states $a > 0$ and $b > 0$. The number of agents $n$ is an integer greater than or equal to $1$. The coordination context implies $n \\ge 2$, making the term $(n-1)$ positive. The parameter $c$ is non-negative, $c \\ge 0$.\nThe numerator is $a(n-1)$. For $n \\ge 2$, this term is positive.\nThe denominator is $(b + c(n-1))^2$. Since $b>0$, $c \\ge 0$, and $n \\ge 2$, the base $b + c(n-1)$ is strictly positive. Its square is therefore also strictly positive.\nThus, the derivative is a negative quantity divided by a positive quantity:\n$$\n\\frac{\\partial x^*}{\\partial c} < 0 \\quad \\text{for } n \\ge 2\n$$\nIf $n=1$, the problem degenerates to a single-agent optimization without interaction, the term $(n-1)$ is zero, and $\\frac{\\partial x^*}{\\partial c} = 0$, which is consistent as $c$ has no effect in that case. Given the problem context, we assume $n \\ge 2$. The negative sign indicates that as the price of congestion $c$ increases, the equilibrium update rate $x^*$ for each agent decreases.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{a}{b + c(n-1)} & -\\frac{a(n-1)}{(b + c(n-1))^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Many interactions in cyber-physical systems unfold over multiple stages, from bidding to execution. This problem  models such a dynamic scenario as an extensive-form game, requiring the use of backward induction to find the subgame-perfect equilibrium. Mastering this technique is essential for predicting outcomes in structured market environments like procurement auctions, where strategic decisions are sequential.",
            "id": "4224194",
            "problem": "A systems integrator acts as a procurement principal to contract a single critical service from Cyber-Physical Systems (CPS) providers in a Digital Twin (DT) enabled environment. There are two CPS providers indexed by $i \\in \\{1,2\\}$, with deterministic effort cost parameters $k_{i} > 0$ known to all parties. The DT records execution outcomes and enforces liquidated damages upon failure. The game unfolds in extensive form with the following stages: first, simultaneous sealed bids; second, conditional effort choice by the winner; third, a chance node for stochastic failure.\n\nThe procurement mechanism is a first-price, sealed-bid auction. Each provider $i$ submits a bid $b_{i} \\in [0,\\infty)$. The contract is awarded to the provider with the lowest bid; ties are resolved in favor of provider $1$. The contract stipulates pay-for-success and liquidated damages: the principal pays the winning provider its bid $b$ only upon success, and the winning provider pays the principal liquidated damages $L > 0$ upon failure. The winner then chooses an execution effort $e \\in [0,1]$, incurring a convex effort cost $\\frac{1}{2} k_{i} e^{2}$. The DT-monitored success probability is $e$; failure occurs with probability $1-e$ at the subsequent chance node. All agents are risk-neutral.\n\nLet $k_{1} < k_{2}$ and assume $0 < L < \\min\\!\\big\\{\\frac{k_{2}}{2}, \\frac{k_{1}^{2}}{2 k_{2}}\\big\\}$ so that equilibrium effort choices are interior ($e \\in (0,1)$) in the subgame that follows any winning bid. Using backward induction and the definition of subgame-perfect equilibrium, derive the equilibrium outcome in closed form under complete information. Specifically, determine the winner’s equilibrium execution effort $e_{1}^{\\star}$ as a function of $L$, $k_{1}$, and $k_{2}$.\n\nYour final answer must be a single closed-form analytic expression for $e_{1}^{\\star}$. No rounding is required. The effort $e_{1}^{\\star}$ is dimensionless and must be expressed exactly.",
            "solution": "The problem asks for the subgame-perfect equilibrium (SPE) outcome of a three-stage procurement game. We will solve for the SPE using backward induction, starting from the final stage.\n\n**Stage 3: Chance Node**\nThis stage is a chance move of nature where the project succeeds with probability $e$ or fails with probability $1-e$. The payoffs are determined based on this outcome.\n\n**Stage 2: Effort Choice Subgame**\nConsider a provider $i \\in \\{1, 2\\}$ who has won the auction with a bid $b_i$. The provider must now choose an effort level $e_i \\in [0, 1]$ to maximize their expected utility. The provider's expected utility, $U_i$, is the expected payment minus the cost of effort. The payment is $b_i$ upon success and $-L$ (a payment of liquidated damages) upon failure.\n\nThe expected utility for provider $i$ is:\n$$U_i(e_i | b_i) = e_i \\cdot b_i + (1 - e_i) \\cdot (-L) - \\frac{1}{2} k_i e_i^2$$\n$$U_i(e_i | b_i) = e_i b_i - L + e_i L - \\frac{1}{2} k_i e_i^2$$\n$$U_i(e_i | b_i) = e_i(b_i + L) - L - \\frac{1}{2} k_i e_i^2$$\n\nTo find the optimal effort $e_i^*$, we maximize this utility function with respect to $e_i$. The utility function $U_i(e_i | b_i)$ is a strictly concave function of $e_i$ because its second derivative is $\\frac{\\partial^2 U_i}{\\partial e_i^2} = -k_i < 0$. Therefore, the maximum is found from the first-order condition, provided the solution lies within the feasible interval $[0, 1]$.\n\nThe first-order condition is:\n$$\\frac{\\partial U_i}{\\partial e_i} = b_i + L - k_i e_i = 0$$\nSolving for $e_i$ gives the unconstrained optimal effort:\n$$e_i = \\frac{b_i + L}{k_i}$$\nThe problem states that $0 < L < \\min\\!\\big\\{\\frac{k_{2}}{2}, \\frac{k_{1}^{2}}{2 k_{2}}\\big\\}$, which is a condition specifically designed to ensure that the equilibrium effort choices are interior, i.e., $e_i^* \\in (0, 1)$. We can thus proceed by assuming the optimal effort is given by this expression:\n$$e_i^*(b_i) = \\frac{b_i + L}{k_i}$$\n\nNow, we substitute this optimal effort back into the utility function to find the provider's expected utility from winning the auction with bid $b_i$. This is the value function for the subgame:\n$$U_i^*(b_i) = \\left(\\frac{b_i + L}{k_i}\\right)(b_i + L) - L - \\frac{1}{2} k_i \\left(\\frac{b_i + L}{k_i}\\right)^2$$\n$$U_i^*(b_i) = \\frac{(b_i + L)^2}{k_i} - L - \\frac{1}{2} \\frac{(b_i + L)^2}{k_i}$$\n$$U_i^*(b_i) = \\frac{1}{2k_i}(b_i + L)^2 - L$$\nA rational provider $i$ will only submit a bid $b_i$ if their expected utility from winning is non-negative, i.e., $U_i^*(b_i) \\ge 0$.\n\n**Stage 1: Bidding Game**\nThis is a first-price, sealed-bid auction under complete information. The contract is awarded to the lowest bidder. Since $k_1 < k_2$, provider $1$ is more efficient than provider $2$. For any given bid $b$, provider $1$ can achieve a higher utility than provider $2$:\n$$U_1^*(b) = \\frac{1}{2k_1}(b + L)^2 - L > \\frac{1}{2k_2}(b + L)^2 - L = U_2^*(b)$$\nIn this setting, the more efficient provider (provider $1$) will win the auction by placing a bid that is just low enough to beat the competition. Provider $1$ needs to determine the lowest possible bid provider $2$ would be willing to make. This is provider $2$'s reservation bid, the bid $b_2^{min}$ at which their expected profit is zero.\n$$U_2^*(b_2^{min}) = \\frac{1}{2k_2}(b_2^{min} + L)^2 - L = 0$$\n$$\\frac{1}{2k_2}(b_2^{min} + L)^2 = L$$\n$$(b_2^{min} + L)^2 = 2k_2 L$$\nSince bids must be non-negative, $b_2^{min} + L$ must be positive.\n$$b_2^{min} + L = \\sqrt{2k_2 L}$$\n$$b_2^{min} = \\sqrt{2k_2 L} - L$$\nProvider $2$ will not bid below $b_2^{min}$. Provider $1$ can win the auction by bidding $b_1^* = b_2^{min}$. The tie-breaking rule, which favors provider $1$ in case of a tie, ensures that a bid of $b_1^* = b_2^{min}$ is sufficient for provider $1$ to win. Thus, the equilibrium winning bid is:\n$$b_1^* = \\sqrt{2k_2 L} - L$$\nThe condition $L < \\frac{k_2}{2}$ given in the problem ensures $L < 2k_2$, which implies $L^2 < 2k_2 L$, so $\\sqrt{2k_2 L} > L$, and thus the winning bid $b_1^*$ is positive. Provider $2$ makes zero profit, and provider $1$ makes a positive profit since $k_1 < k_2$.\n\n**Equilibrium Outcome**\nWe now have the equilibrium winning bid $b_1^*$. The problem asks for the winner's equilibrium execution effort, $e_1^{\\star}$. The winner is provider $1$. We use the optimal effort function derived for provider $1$ and substitute the equilibrium bid $b_1^*$:\n$$e_1^{\\star} = e_1^*(b_1^*) = \\frac{b_1^* + L}{k_1}$$\nSubstituting the expression for $b_1^*$:\n$$e_1^{\\star} = \\frac{(\\sqrt{2k_2 L} - L) + L}{k_1}$$\n$$e_1^{\\star} = \\frac{\\sqrt{2k_2 L}}{k_1}$$\nFinally, we must verify that this effort is in the interval $(0, 1)$ as assumed. Since $k_1, k_2, L > 0$, it is clear that $e_1^{\\star} > 0$. For $e_1^{\\star} < 1$, we require:\n$$\\frac{\\sqrt{2k_2 L}}{k_1} < 1 \\implies \\sqrt{2k_2 L} < k_1 \\implies 2k_2 L < k_1^2 \\implies L < \\frac{k_1^2}{2k_2}$$\nThis is precisely one of the conditions given in the problem statement. Thus, the derived equilibrium effort is indeed an interior solution.",
            "answer": "$$\\boxed{\\frac{\\sqrt{2k_2 L}}{k_1}}$$"
        },
        {
            "introduction": "Beyond analyzing existing games, a key skill is designing mechanisms that achieve desirable system-wide outcomes, such as efficiency and truthfulness. This computational practice  challenges you to implement the celebrated Vickrey-Clarke-Groves (VCG) mechanism for a complex combinatorial allocation problem. By coding the allocation and payment rules, you will bridge the gap between abstract theory and the practical engineering of incentive-compatible systems.",
            "id": "4224153",
            "problem": "Consider a combinatorial task allocation problem in a Cyber-Physical System (CPS), where digital twins represent agents that may execute bundles of tasks. There are $N$ agents and $T$ indivisible tasks labeled by indices in $\\{0,1,\\dots,T-1\\}$. Each agent $i \\in \\{0,1,\\dots,N-1\\}$ reports a valuation function $v_i(S)$ for every bundle $S \\subseteq \\{0,1,\\dots,T-1\\}$, where $v_i(\\emptyset) = 0$. An allocation is a partition of the task set among agents with the constraints that each task is assigned to at most one agent and tasks may remain unassigned. Agents have quasi-linear utilities, so for an allocation $\\{S_i\\}_{i=0}^{N-1}$ and payments $\\{p_i\\}_{i=0}^{N-1}$, each agent's utility is $u_i = v_i(S_i) - p_i$.\n\nImplement the Vickrey–Clarke–Groves (VCG) mechanism: choose an allocation that maximizes total reported social welfare $\\sum_{i=0}^{N-1} v_i(S_i)$ subject to the feasibility constraints, and compute Clarke pivot payments, where the payment for agent $i$ is\n$$\np_i = h_i - \\sum_{j \\ne i} v_j(S_j^*)\n$$\nwith $h_i$ equal to the maximum total welfare of all agents except $i$ when $i$ is removed, and $\\{S_j^*\\}$ denoting the chosen welfare-maximizing allocation with all agents present. In case of multiple allocations achieving the same maximum social welfare, break ties by selecting the allocation that minimizes the lexicographic order of the assignment vector $(a_0,a_1,\\dots,a_{T-1})$, where $a_t \\in \\{-1,0,1,\\dots,N-1\\}$ denotes the agent index assigned to task $t$ and $-1$ denotes an unassigned task. The ordering is defined by $-1 < 0 < 1 < \\dots < (N-1)$.\n\nStart from the foundational principles of quasi-linear preferences and efficient mechanisms, and do not assume shortcut results beyond these.\n\nYour program must output, for each test case, a list containing: the maximum social welfare (as a float), the allocation to each agent encoded as integer bitmasks of tasks (so each agent $i$ is assigned a mask $m_i \\in \\{0,1,\\dots,2^T-1\\}$ such that bit $t$ of $m_i$ is $1$ if and only if task $t$ is assigned to agent $i$), and the VCG payment of each agent (as floats). Aggregate the results of all test cases into a single line printed in the format of a comma-separated list enclosed in square brackets, for example, $[result_1,result_2,\\dots]$.\n\nTest Suite:\n- Case $1$: $N=2$, $T=3$. Tasks $\\{0,1,2\\}$. Reported valuations $v_0$ and $v_1$ for all subsets $S$ are given as follows (each subset indicated by its bitmask in $\\{0,1,\\dots,7\\}$ where bit $t$ indicates inclusion of task $t$):\n  - Agent $0$: $v_0(\\emptyset)=0$, $v_0(\\{0\\})=3$, $v_0(\\{1\\})=2$, $v_0(\\{2\\})=2$, $v_0(\\{0,1\\})=6.5$, $v_0(\\{0,2\\})=5.5$, $v_0(\\{1,2\\})=4.5$, $v_0(\\{0,1,2\\})=8.0$.\n    In bitmask form: $v_0(0)=0$, $v_0(1)=3$, $v_0(2)=2$, $v_0(4)=2$, $v_0(3)=6.5$, $v_0(5)=5.5$, $v_0(6)=4.5$, $v_0(7)=8.0$.\n  - Agent $1$: $v_1(\\emptyset)=0$, $v_1(\\{0\\})=4.5$, $v_1(\\{1\\})=1.5$, $v_1(\\{2\\})=1.0$, $v_1(\\{0,1\\})=5.0$, $v_1(\\{0,2\\})=5.2$, $v_1(\\{1,2\\})=2.2$, $v_1(\\{0,1,2\\})=5.3$.\n    In bitmask form: $v_1(0)=0$, $v_1(1)=4.5$, $v_1(2)=1.5$, $v_1(4)=1.0$, $v_1(3)=5.0$, $v_1(5)=5.2$, $v_1(6)=2.2$, $v_1(7)=5.3$.\n- Case $2$: $N=3$, $T=1$. Tasks $\\{0\\}$. Valuations are symmetric and single-valued: for each agent $i \\in \\{0,1,2\\}$, $v_i(\\emptyset)=0$ and $v_i(\\{0\\})=5$.\n- Case $3$: $N=2$, $T=4$. Tasks $\\{0,1,2,3\\}$. Valuations are additive across tasks; that is, for each agent $i$, $v_i(S) = \\sum_{t \\in S} a_{i,t}$. Atom values are $a_{0,0}=2.0$, $a_{0,1}=3.0$, $a_{0,2}=1.0$, $a_{0,3}=4.0$ for agent $0$, and $a_{1,0}=3.0$, $a_{1,1}=1.0$, $a_{1,2}=5.0$, $a_{1,3}=0.5$ for agent $1$.\n- Case $4$: $N=2$, $T=2$. Tasks $\\{0,1\\}$. Valuations are identically zero for all bundles: for each agent $i \\in \\{0,1\\}$ and any $S \\subseteq \\{0,1\\}$, $v_i(S)=0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$). Each $result_k$ must be of the form $[\\text{SW}_k,[m_{k,0},m_{k,1},\\dots,m_{k,N-1}],[p_{k,0},p_{k,1},\\dots,p_{k,N-1}]]$ where $\\text{SW}_k$ is the maximum social welfare for case $k$, $m_{k,i}$ is the bitmask assigned to agent $i$ in case $k$, and $p_{k,i}$ is the VCG payment of agent $i$ in case $k$.",
            "solution": "The problem presented is a valid, well-posed optimization problem rooted in the field of mechanism design, a subfield of game theory and microeconomics, with direct applications to resource allocation in cyber-physical systems. It asks for the implementation of the Vickrey–Clarke–Groves (VCG) mechanism for a combinatorial task allocation scenario.\n\n**1. Foundational Principles**\n\nThe foundation of the problem lies in a setting with $N$ rational agents and a central planner (the mechanism). Each agent $i$ has a private valuation $v_i(S)$ for receiving a specific bundle of tasks $S$. The agents' preferences are assumed to be quasi-linear, meaning their total utility is the value they derive from their allocated bundle minus any monetary payment they make: $u_i = v_i(S_i) - p_i$. The goal is to design a mechanism (an allocation rule and a payment rule) that achieves a desirable outcome. The VCG mechanism is celebrated for its ability to achieve an *efficient* outcome while ensuring agents are incentivized to report their valuations truthfully.\n\nAn allocation is defined as a partition of the set of all tasks $T$ into disjoint subsets $\\{S_0, S_1, \\dots, S_{N-1}, S_{unassigned}\\}$, where $S_i$ is the bundle assigned to agent $i$ and $S_{unassigned}$ are the leftover tasks. An outcome is efficient if it maximizes the total value generated, or the *social welfare*, defined as the sum of all agents' valuations for their assigned bundles: $W = \\sum_{i=0}^{N-1} v_i(S_i)$.\n\n**2. The VCG Mechanism: Allocation Rule**\n\nThe first component of the VCG mechanism is its allocation rule: select the allocation $\\{S_i^*\\}_{i=0}^{N-1}$ that maximizes the total reported social welfare. This is known as the Winner Determination Problem (WDP).\n$$ \\{S_i^*\\} = \\arg\\max_{\\{S_i\\}} \\sum_{i=0}^{N-1} v_i(S_i) \\quad \\text{subject to} \\quad S_i \\cap S_j = \\emptyset \\text{ for } i \\neq j $$\nFor a general combinatorial allocation problem, the WDP is computationally difficult (NP-hard). However, for the small number of tasks $T$ given in the test cases ($T \\le 4$), we can find the optimal allocation by enumerating all possibilities. An assignment can be uniquely represented by a vector $(a_0, a_1, \\dots, a_{T-1})$, where $a_t$ is the index of the agent assigned to task $t$, or $-1$ if the task is unassigned. The total number of such assignments is $(N+1)^T$.\n\nThe algorithm to find the welfare-maximizing allocation is as follows:\n1. Initialize a maximum welfare $W_{max} = -\\infty$ and a corresponding best assignment vector $A^* = \\text{None}$.\n2. Iterate through every possible assignment vector $A = (a_0, \\dots, a_{T-1})$, where each $a_t \\in \\{-1, 0, \\dots, N-1\\}$.\n3. For each assignment $A$:\n    a. For each agent $i$, construct their bundle $S_i = \\{t \\mid a_t = i\\}$.\n    b. Calculate the current social welfare $W_A = \\sum_{i=0}^{N-1} v_i(S_i)$.\n    c. If $W_A > W_{max}$, update $W_{max} = W_A$ and $A^* = A$.\n    d. If $W_A = W_{max}$, apply the specified tie-breaking rule: compare the current assignment vector $A$ with the stored best vector $A^*$ lexicographically. If $A$ is smaller, update $A^* = A$. The problem specifies the ordering $-1 < 0 < 1 < \\dots < N-1$.\n4. The final vector $A^*$ determines the optimal allocation $\\{S_i^*\\}$, and the maximum social welfare is $W_{max}$.\n\n**3. The VCG Mechanism: Payment Rule**\n\nThe second component of VCG is the payment rule, which ensures that truthful reporting of valuations is a dominant strategy for all agents. The payment for agent $i$, known as the Clarke pivot payment, is calculated to be equal to the externality they impose on the rest of society.\nThe payment $p_i$ for agent $i$ is:\n$$ p_i = h_i - \\sum_{j \\neq i} v_j(S_j^*) $$\n- The term $\\sum_{j \\neq i} v_j(S_j^*)$ represents the total welfare of all other agents in the optimal allocation (when agent $i$ is present). This can be calculated as $W_{max} - v_i(S_i^*)$.\n- The term $h_i$ represents the hypothetical maximum social welfare that *would have been achieved* if agent $i$ had not participated in the mechanism. This is found by solving a new WDP for the set of agents $\\{0, \\dots, N-1\\} \\setminus \\{i\\}$. Let the assignees in this hypothetical scenario be $a_t' \\in \\{-1, 0, \\dots, i-1, i+1, \\dots, N-1\\}$. Then $h_i = \\max \\sum_{j \\neq i} v_j(S_j')$, where $\\{S_j'\\}$ is the optimal allocation among the other $N-1$ agents.\n\nAgent $i$'s utility is therefore $u_i = v_i(S_i^*) - p_i = v_i(S_i^*) - (h_i - \\sum_{j \\neq i} v_j(S_j^*)) = (\\sum_{j=0}^{N-1} v_j(S_j^*)) - h_i = W^* - h_i$. This is the social surplus created by agent $i$'s participation.\n\n**4. Algorithmic Implementation Strategy**\n\nThe overall algorithm proceeds as follows for each test case:\n1.  **Parse Inputs**: Read the number of agents $N$, tasks $T$, and the valuation functions $v_i$. Store valuations in a suitable data structure, like a list of dictionaries, where `valuations[i][mask]` gives the value for agent $i$ of the bundle represented by the integer bitmask `mask`. For additive valuations, pre-compute the full valuation tables.\n2.  **Solve for Optimal Allocation ($S^*$ and $W^*$):**\n    Implement the exhaustive search WDP algorithm described in section 2, considering all $N$ agents (plus the unassigned option). This yields the maximum social welfare $W^*$ and the optimal allocation as a set of bitmasks $\\{S_0^*, S_1^*, \\dots, S_{N-1}^*\\}$.\n3.  **Compute Hypothetical Welfares ($h_i$):**\n    For each agent $i$ from $0$ to $N-1$:\n    a. Run the WDP algorithm again, but this time for the set of agents $\\{0, \\dots, N-1\\} \\setminus \\{i\\}$. The possible assignees for each task are now $\\{-1, 0, \\dots, i-1, i+1, \\dots, N-1\\}$.\n    b. The maximum welfare from this sub-problem is $h_i$.\n4.  **Calculate Payments ($p_i$):**\n    For each agent $i$, compute the payment using the derived values:\n    $$ p_i = h_i - (W^* - v_i(S_i^*)) $$\n5.  **Format Output**: Assemble the results for the test case into the required list format: `[W*, [S_0*, S_1*, ...], [p_0, p_1, ...]]`. Finally, aggregate the results from all test cases into a single line of output.",
            "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n\n    # Suppress scientific notation for cleaner float output\n    np.set_printoptions(suppress=True)\n    # Redirect stdout to a buffer if needed to ensure single-line output,\n    # though direct printing should be fine.\n\n    # ------------------ Test Case 1 ------------------\n    N1, T1 = 2, 3\n    v1 = [\n        {0: 0, 1: 3, 2: 2, 3: 6.5, 4: 2, 5: 5.5, 6: 4.5, 7: 8.0},\n        {0: 0, 1: 4.5, 2: 1.5, 3: 5.0, 4: 1.0, 5: 5.2, 6: 2.2, 7: 5.3}\n    ]\n    test_cases = [(N1, T1, v1)]\n    \n    # ------------------ Test Case 2 ------------------\n    N2, T2 = 3, 1\n    v2 = [\n        {0: 0, 1: 5.0},\n        {0: 0, 1: 5.0},\n        {0: 0, 1: 5.0}\n    ]\n    test_cases.append((N2, T2, v2))\n    \n    # ------------------ Test Case 3 ------------------\n    N3, T3 = 2, 4\n    atoms3 = [\n        [2.0, 3.0, 1.0, 4.0],\n        [3.0, 1.0, 5.0, 0.5]\n    ]\n    v3 = [{}, {}]\n    for m in range(1 << T3):\n        v3[0][m] = sum(atoms3[0][t] for t in range(T3) if (m >> t) & 1)\n        v3[1][m] = sum(atoms3[1][t] for t in range(T3) if (m >> t) & 1)\n    test_cases.append((N3, T3, v3))\n\n    # ------------------ Test Case 4 ------------------\n    N4, T4 = 2, 2\n    v4 = [\n        {m: 0.0 for m in range(1 << T4)},\n        {m: 0.0 for m in range(1 << T4)}\n    ]\n    test_cases.append((N4, T4, v4))\n\n    all_results = []\n    for N, T, valuations in test_cases:\n        result = _solve_vcg_case(N, T, valuations)\n        all_results.append(result)\n\n    # Format output as a string of lists, as specified by the problem's boilerplate.\n    # str([..]) produces '[.., ..]' which has spaces. The prompt requires this specific format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef _find_optimal_allocation(T, N, valuations, excluded_agents):\n    \"\"\"\n    Finds the welfare-maximizing allocation for a given set of active agents.\n    \"\"\"\n    active_agents = [i for i in range(N) if i not in excluded_agents]\n    assignee_options = [-1] + active_agents\n\n    max_welfare = -1.0\n    best_assignment = None\n\n    for assignment in product(assignee_options, repeat=T):\n        bundles = {agent_idx: 0 for agent_idx in active_agents}\n        for task_idx, agent_idx in enumerate(assignment):\n            if agent_idx != -1:\n                bundles[agent_idx] |= (1 << task_idx)\n        \n        current_welfare = 0.0\n        for agent_idx, bundle_mask in bundles.items():\n            current_welfare += valuations[agent_idx].get(bundle_mask, 0.0)\n\n        if best_assignment is None or current_welfare > max_welfare:\n            max_welfare = current_welfare\n            best_assignment = assignment\n        elif abs(current_welfare - max_welfare) < 1e-9: # Float comparison\n            # Tie-breaking rule: lexicographically smallest assignment vector\n            if assignment < best_assignment:\n                best_assignment = assignment\n    \n    # Convert the best assignment vector to agent masks\n    final_masks = [0] * N\n    if best_assignment:\n        for task_idx, agent_idx in enumerate(best_assignment):\n            if agent_idx != -1:\n                final_masks[agent_idx] |= (1 << task_idx)\n\n    return max_welfare, final_masks\n\ndef _solve_vcg_case(N, T, valuations):\n    \"\"\"\n    Solves a single VCG problem case.\n    \"\"\"\n    # 1. Find the optimal allocation and social welfare with all agents\n    max_social_welfare, optimal_masks = _find_optimal_allocation(T, N, valuations, excluded_agents=set())\n\n    # 2. Compute VCG payments\n    payments = [0.0] * N\n    for i in range(N):\n        # Find h_i: max welfare if agent i is excluded\n        h_i, _ = _find_optimal_allocation(T, N, valuations, excluded_agents={i})\n\n        # Welfare of others in the optimal allocation\n        welfare_of_others = 0\n        for j in range(N):\n            if i != j:\n                welfare_of_others += valuations[j].get(optimal_masks[j], 0.0)\n        \n        # Clarke pivot payment\n        # p_i = h_i - welfare_of_others\n        # which is equivalent to p_i = h_i - (max_social_welfare - v_i(S_i*))\n        payments[i] = h_i - welfare_of_others\n\n    return [max_social_welfare, optimal_masks, payments]\n\nsolve()\n```"
        }
    ]
}