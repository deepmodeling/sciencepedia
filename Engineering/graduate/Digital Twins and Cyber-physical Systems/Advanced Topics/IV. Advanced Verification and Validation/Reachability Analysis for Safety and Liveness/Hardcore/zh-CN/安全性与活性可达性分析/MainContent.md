## 引言
随着赛博物理系统（CPS）及其数字孪生日益融入我们生活的方方面面，从[自动驾驶](@entry_id:270800)汽车到智能医疗设备，确保这些复杂系统的行为安全、可靠且符合预期变得至关重要。系统的行为规范通常可以分为两大类：**安全性**（保证“坏事”永不发生，如系统不进入危险状态）和**活性**（保证“好事”终将发生，如系统最终达到目标）。然而，由于CPS固有的混合动态、不确定性和高维度特性，严格验证这些属性构成了一个巨大的挑战。

可达性分析（Reachability Analysis）正是一种应对这一挑战的强大数学与计算方法论。它系统地刻画一个系统从给定的初始状态出发，在所有可能输入和扰动下能够到达的全部状态集合。通过分析这个“可达集”与预定义的安全或目标区域的关系，我们可以对系统的行为做出严谨的、可证明的结论。本文旨在全面阐述[可达性](@entry_id:271693)分析在保证CPS[安全性与活性](@entry_id:634196)方面的理论与实践。

在第一章**“原理与机制”**中，我们将奠定理论基础，深入探讨[安全性与活性](@entry_id:634196)的形式化定义，介绍前向与反向[可达性](@entry_id:271693)分析的核心思想，并讨论在计算上不可避免的近似方法（如过近似）及其对验证结果的影响。我们还将探索[不变集](@entry_id:275226)、[屏障证书](@entry_id:1121354)等关键概念，它们为[控制器综合](@entry_id:261816)与[几何分析](@entry_id:157700)提供了有力工具。

随后，在第二章**“应用与跨学科连接”**中，我们将展示这些理论如何转化为解决实际问题的利器。通过具体的案例，我们将看到[可达性](@entry_id:271693)分析在机器人学、[鲁棒控制](@entry_id:260994)、随机与自适应系统验证中的应用，并跨越学科界限，探讨其在系统生物学和临床流程建模等领域的应用，凸显其作为分析复杂动态交互系统的普适框架的价值。

最后，**“动手实践”**部分将理论与实践相结合，提供一系列精心设计的编程问题，引导读者亲手实现将[连续系统](@entry_id:178397)抽象为离散模型、构建可达集过近似以及利用[优化技术](@entry_id:635438)搜索[屏障证书](@entry_id:1121354)等核心任务。通过这一系列的学习，读者将不仅理解可达性分析的“是什么”和“为什么”，更能掌握“怎么做”，从而为构建下一代安全可靠的智能系统奠定坚实的基础。

## 原理与机制

在对赛博物理系统（Cyber-Physical Systems, CPS）及其数字孪生进行分析时，核心任务之一是验证其行为是否符合预设的规范。这些规范通常分为两大类：**安全性（Safety）**和**活性（Liveness）**。[可达性](@entry_id:271693)分析（Reachability Analysis）为验证这些属性提供了坚实的理论基础和一套强大的计算工具。本章将深入探讨可达性分析的基本原理、核心机制及其在保证[CPS安全](@entry_id:1131376)与活性方面的应用。

### [安全性与活性](@entry_id:634196)：系统行为的形式化规范

要严谨地讨论系统属性，我们首先需要一种形式化的方式来描述系统的行为。一个系统的行为可以被抽象为一系列状态或事件的无限序列，称为**迹（trace）**。假设系统的每个快照（snapshot）可以由一个符号集 $\Sigma$ 中的元素表示，那么一个无限迹就是 $\Sigma^{\omega}$ 上的一个无限长字符串 $\sigma$。一个**属性（property）**就是所有允许的迹构成的集合，即 $\Sigma^{\omega}$ 的一个子集 $P$。

#### 安全性属性

安全性属性直观地表达了“坏事永不发生”的原则。形式上，一个属性 $S \subseteq \Sigma^{\omega}$ 是一个**安全性属性**，当且仅当对于任何不满足该属性的迹 $\sigma \notin S$（即“坏”的迹），都存在一个有限的前缀 $\pi \preceq \sigma$，使得所有以 $\pi$ 为前缀的无限迹 $\rho$ 都不满足该属性（即 $\rho \notin S$）。

$$
\forall \sigma \in \Sigma^{\omega}: \left( \sigma \notin S \implies \exists \pi \preceq \sigma, \forall \rho \in \Sigma^{\omega} (\pi \preceq \rho \implies \rho \notin S) \right)
$$

这个定义意味着，任何对安全性属性的违反都必须在有限的时间内被观察到。一旦一个“坏前缀”出现，系统的行为就无可挽回地违反了该属性。在拓扑学上，安全性属性对应于 $\Sigma^{\omega}$ 上康托尔拓扑（Cantor topology）中的[闭集](@entry_id:136446)。

一个典型的安全性属性是**不变性（invariance）**，即系统状态在任何时候都必须保持在一个“安全”的集合内。例如，在一个自动驾驶车队中，安全性要求可能是在任何时刻车辆之间都不能发生碰撞 。这可以形式化为一个不变的最小安全[距离约束](@entry_id:200711)：对于车队中的任意相邻车辆 $i$ 和 $i-1$，其间距 $d_i(t) = x_{i-1}(t) - x_i(t)$ 必须始终满足 $d_i(t) \ge d_{\min}$，其中 $d_{\min} > 0$ 是一个最小安全阈值。如果某个时刻 $t_k$ 的间距 $d_i(t_k)  d_{\min}$，那么安全性就被违反了，这个时刻之前的迹就是一个“坏前缀”。

#### 活性属性

与安全性相反，活性属性表达了“好事终将发生”的原则。形式上，一个属性 $L \subseteq \Sigma^{\omega}$ 是一个**活性属性**，当且仅当任何有限前缀 $\pi$ 都可以被扩展为一个满足该属性的无限迹 $\rho$。

$$
\forall \pi \in \Sigma^{*}: \exists \rho \in \Sigma^{\omega} \text{ such that } (\pi \preceq \rho \land \rho \in L)
$$

其中 $\Sigma^{*}$ 是所有有限迹的集合。这个定义意味着，仅通过观察一个有限的系统行为，我们永远无法断定一个活性属性被违反了，因为“好事”可能在未来的某个时刻发生。要证明活性属性被违反，必须审视整个无限迹。在拓扑学上，活性属性对应于 $\Sigma^{\omega}$ 上的[稠密集](@entry_id:147057)。

回到[自动驾驶](@entry_id:270800)车队的例子，一个活性属性可能是车队**最终能稳定（eventual stabilization）**到期望的巡航状态 。例如，我们可能要求所有车辆最终都能以一个参考速度 $v_{\mathrm{ref}}$ 行驶，并且保持一个基于时间的车头时距策略，如 $d_i(t) \approx h \cdot v_i(t) + d_0$。这个属性要求存在一个时刻 $T$，在此之后，所有车辆的速度和间距都保持在目标值的一个很小的容差范围内。在任何有限的时间内，即使车队尚未达到稳定状态，我们也不能断定它永远不会达到。

### 前向可达性分析：探索未来的状态

为了验证系统是否满足上述属性，我们需要一种方法来刻画系统从一个初始状态集合出发，在未来可能达到的所有状态。这就是**前向[可达集](@entry_id:276191)（forward reachable set）**的概念。

#### [连续时间系统](@entry_id:276553)

对于一个由常微分方程（ODE）$\dot{x} = f(x,u)$ 描述的连续[时间控制](@entry_id:263806)系统，其中 $x \in \mathbb{R}^n$ 是状态， $u \in U \subset \mathbb{R}^m$ 是输入，我们可以定义从初始状态 $x_0$ 出发，在[控制信号](@entry_id:747841) $u(\cdot)$ 下，在时刻 $t$ 的状态为流映射（flow map）$\varphi(t; x_0, u(\cdot))$。

给定一个初始状态集合 $X_0 \subset \mathbb{R}^n$ 和所有容许的控制信号集合 $\mathcal{U}$，在**时刻 $t$ 的前向[可达集](@entry_id:276191)** $\mathcal{R}^{+}(t; X_0)$ 被定义为从 $X_0$ 中任意初始状态出发，在任意容许[控制信号](@entry_id:747841)的作用下，在时刻 $t$ 可能到达的所有状态的集合 。其形式化定义为：

$$
\mathcal{R}^{+}(t; X_0) = \{ \varphi(t; x_{0}, u(\cdot)) \mid x_{0} \in X_0, u(\cdot) \in \mathcal{U} \}
$$

如果我们关心的是在**时间区间 $[0, T]$ 内**所有可能达到的状态，那么我们需要取遍所有时刻的[可达集](@entry_id:276191)之并集，这构成了**前向可达管道（forward reach tube）**：

$$
\mathcal{R}^{+}_{[0,T]}(X_0) = \bigcup_{\tau \in [0,T]} \mathcal{R}^{+}(\tau; X_0)
$$

通过计算前向[可达集](@entry_id:276191)，安全性验证问题就转化为一个几何问题：检查[可达集](@entry_id:276191)是否在任何时刻都包含在预定义的安[全集](@entry_id:264200) $S$ 内，即 $\mathcal{R}^{+}_{[0,T]}(X_0) \subseteq S$。

#### [离散时间系统](@entry_id:263935)

对于由状态[更新方程](@entry_id:264802) $x_{t+1} = F(x_t, u_t)$ 描述的[离散时间系统](@entry_id:263935)，可达集的计算可以通过迭代应用**单步后继算子（one-step successor operator）** $\mathrm{Post}(X)$ 来完成。该算子计算从集合 $X$ 中的所有状态出发，在施加所有可能的控制输入 $u \in \mathcal{U}$ 后，一步之内可以到达的所有状态的集合 。

$$
\mathrm{Post}(X) = \{ F(x,u) \mid x \in X, u \in \mathcal{U} \}
$$

基于此算子，我们可以递归地定义**精确 $k$ 步[可达集](@entry_id:276191)** $R^{(k)}$：
- **第0步**: $R^{(0)} = X_0$ （初始集）
- **第 $k+1$ 步**: $R^{(k+1)} = \mathrm{Post}(R^{(k)})$

而**至多 $k$ 步可达集** $R_{\le k}$ 则是所有 $0$ 到 $k$ 步可达集的并集：

$$
R_{\le k} = \bigcup_{i=0}^{k} R^{(i)} = \bigcup_{i=0}^{k} \mathrm{Post}^{i}(X_0)
$$

这里 $\mathrm{Post}^i(X_0)$ 表示对初始集 $X_0$ 连续应用 $i$ 次 $\mathrm{Post}$ 算子。

### 计算的挑战：近似与验证

对于除最简单系统之外的大多数CPS模型，精确计算可达集通常是不可行的。这是因为非线性动力学、复杂的几何形状以及高维度等因素使得解析解或精确数值解难以获得。因此，在实践中，我们通常计算可达集的**近似（approximations）**。

#### 过近似与欠近似

有两种主要的近似类型 ：
- **过近似（Over-approximation）** $R^{\supset}$：计算出的集合完全包含真实的[可达集](@entry_id:276191)，即 $R \subseteq R^{\supset}$。
- **欠近似（Under-approximation）** $R^{\subset}$：计算出的集合完全被真实的可达集所包含，即 $R^{\subset} \subseteq R$。

一个可达性分析算法的输出被称为**可靠的（sound）**，如果它生成的过近似和欠近似满足上述包含关系。如果算法能够精确计算[可达集](@entry_id:276191)，即 $R^{\supset} = R^{\subset} = R$，则称其为**完备的（complete）**。

这两种近似在验证中扮演着对偶的角色：
- **使用过近似证明安全性**：如果一个过近似集 $R^{\supset}$ 与不安全集 $U$ 的交集为空（$R^{\supset} \cap U = \emptyset$），那么由于 $R \subseteq R^{\supset}$，可以断定真实[可达集](@entry_id:276191) $R$ 也与 $U$ 无交集。因此，系统是安全的。这是一种可靠的验证方法，尽管它可能因为近似的保守性而产生**虚假警报（false positives）**（即系统本是安全的，但过近似集触碰了不安全区域）。
- **使用过近似证明非活性**：如果过近似集 $R^{\supset}$ 与目标集 $L$ 的交集为空（$R^{\supset} \cap L = \emptyset$），那么真实[可达集](@entry_id:276191)也一定不能到达 $L$。
- **使用欠近似证明活性**：如果一个欠近似集 $R^{\subset}$ 与目标集 $L$ 的交集非空（$R^{\subset} \cap L \neq \emptyset$），那么由于 $R^{\subset} \subseteq R$，可以断定真实[可达集](@entry_id:276191) $R$ 也一定与 $L$ 有交集。因此，系统满足该活性要求（能到达目标）。
- **使用欠近似证明非安全性**：如果欠近似集 $R^{\subset}$ 与不安[全集](@entry_id:264200) $U$ 的交集非空，那么真实可达集也必然与 $U$ 有交集，从而[证明系统](@entry_id:156272)是不安全的。

#### 过近似[可达性](@entry_id:271693)算法

一个典型的过[近似算法](@entry_id:139835)  通常采用迭代方式，每一步都保证计算出的集合包含所有可能的真实状态。对于一个受扰动的[混合系统](@entry_id:271183) $\dot{x} = f_{\ell}(x,u,w)$，其中 $w$ 是扰动，其算法步骤可以概括为：
1.  从初始集 $\hat{R}_0 = X_0$ 开始。
2.  对于连续演化，使用一种集合式的积分方法，如基于欧拉法的推进：$\hat{R}_{k+1}^{\mathrm{cont}} \supseteq \hat{R}_k \oplus h \cdot F_{\ell}(\hat{R}_k) \oplus E_k$。这里，$F_{\ell}(\hat{R}_k)$ 是动力学函数在当前[可达集](@entry_id:276191) $\hat{R}_k$ 以及所有控制和扰动输入下的像集，$\oplus$ 表示[闵可夫斯基和](@entry_id:176841)，$E_k$ 是一个基于李普希兹常数等信息计算出的误差项，用于包裹所有由离散化和线性化带来的误差。
3.  对于离散跳转，计算当前集合与守卫（guard）相交的部分，并应用重置映射（reset map）得到跳转后的状态集。
4.  将连续演化和离散跳转得到的状态集合并，形成下一步的过近似可达集。

该算法的**可靠性保证**是，它不会错过任何真正的安全违规。形式上，如果 $\hat{R}_k$ 是真实可达集 $R_k$ 的过近似，那么：
$$
(R_k \cap U_s \neq \emptyset) \implies (\hat{R}_k \cap U_s \neq \emptyset)
$$
这意味着，如果系统真的不安全，我们的分析一定会发出警报。反过来说，如果分析结果显示在所有时刻 $\hat{R}_k \cap U_s = \emptyset$，那么我们可以确信系统是安全的。

### 反向可达性分析与[控制综合](@entry_id:170565)

前向可达性分析回答了“系统可能去向何方？”的问题。相对地，**反向可达性分析（backward reachability analysis）**回答了“系统可能从何而来？”的问题。这个视角在[控制器综合](@entry_id:261816)中尤为重要，特别是当我们需要为系统设计一个策略以保证其始终停留在安全区域时。

考虑一个带有控制输入 $u$ 和[对抗性扰动](@entry_id:746324) $w$ 的系统 $s_{k+1} = F(s_k, u_k, w_k)$。我们的目标是设计一个控制器，无论扰动如何作用，都能使系统状态永远停留在安[全集](@entry_id:264200) $\mathcal{S}_{\mathrm{safe}}$ 内。

为此，我们定义**单步受控前驱算子（one-step controlled predecessor operator）** $\mathrm{Pre}(X)$ 。它表示所有状态 $s$ 的集合，从这些状态出发，控制器**存在一种**控制输入 $u$，使得**对于所有**可能的扰动 $w$，系统的下一个状态都将位于目标集 $X$ 内。

$$
\mathrm{Pre}(X) = \{ s \in \mathcal{S} \mid \exists u \in \mathcal{U} \; \forall w \in \mathcal{W}: F(s,u,w) \in X \}
$$

这种 `存在u，对于所有w` 的逻辑结构是[鲁棒控制](@entry_id:260994)和博弈论的核心。

一个状态是**安全获胜（safety-winning）**的，如果它本身是安全的，并且控制器可以确保下一步状态仍然是安全获胜的。这意味着安全获胜集 $\mathcal{W}_{\mathrm{safe}}$ 必须满足[不动点方程](@entry_id:203270)：
$$
\mathcal{W}_{\mathrm{safe}} = \mathcal{S}_{\mathrm{safe}} \cap \mathrm{Pre}(\mathcal{W}_{\mathrm{safe}})
$$
这个集合是所有能在安全集 $\mathcal{S}_{\mathrm{safe}}$ 内被控制器维持不变的初始状态构成的最大集合。它可以通过从整个安[全集](@entry_id:264200) $\mathcal{S}_{\mathrm{safe}}$ 开始，反复应用映射 $Z \mapsto \mathcal{S}_{\mathrm{safe}} \cap \mathrm{Pre}(Z)$ 并最终收敛到一个**最大不动点（greatest fixed point）**来计算。那些不在此集合中的状态被称为**规避集（avoid set）**，从这些状态出发，扰动可以在有限步骤内将系统强制推入不安全区域。

### 集合不变性：安全的几何诠释

反向[可达性](@entry_id:271693)计算出的安全获胜集是一个**受控不变集（controlled invariant set）**的例子。[不变性](@entry_id:140168)是安全性的一个核心几何概念。

一个集合 $\mathcal{K}$ 被称为**受控前向不变的（controlled forward invariant）**，如果从 $\mathcal{K}$ 内的任何状态 $x_0$ 出发，都存在一个控制信号 $u(\cdot)$，使得系统的整个轨迹都保持在 $\mathcal{K}$ 内 。

#### 可行性理论与[切锥](@entry_id:191609)

不变性的条件可以在无穷小的层面上刻画。定义 $F(x) = \{f(x,u) : u \in \mathcal{U}\}$ 为在状态 $x$ 所有可能的[瞬时速度](@entry_id:167797)向量集合。一个[闭集](@entry_id:136446) $\mathcal{K}$ 是受控不变的，当且仅当对于 $\mathcal{K}$ 中的每一个点 $x$，速度向量集 $F(x)$ 与 $\mathcal{K}$ 在 $x$ 点的**布里甘[切锥](@entry_id:191609)（Bouligand tangent cone）** $T_{\mathcal{K}}(x)$ 都有非空交集 。

$$
\forall x \in \mathcal{K}, \quad F(x) \cap T_{\mathcal{K}}(x) \neq \emptyset
$$

[切锥](@entry_id:191609) $T_{\mathcal{K}}(x)$ 直观上包含了所有从 $x$ 点出发“指向”集合 $\mathcal{K}$ 内部或沿其边界的方向。这个条件（称为**可行性条件**或**Nagumo条件**）意味着，在集合的任何一点，控制器总能找到一个控制输入 $u$，使得产生的速度向量 $f(x,u)$ 不会将状态带出集合。这为设计安全控制器提供了直接的几何指引：在边界上，选择一个能使系统向[内移](@entry_id:265618)动或沿边界滑行的控制。

#### [屏障证书](@entry_id:1121354)与[Lyapunov函数](@entry_id:273986)

除了几何方法，我们还可以使用函数方法来证明[不变性](@entry_id:140168)。**[屏障证书](@entry_id:1121354)（Barrier Certificate）**，或称屏障函数，就是这样一种工具 。假设安全集可以被定义为一个函数 $B(x)$ 的零水平子集，即 $\mathcal{S} = \{x \mid B(x) \le 0\}$。如果存在这样的函数 $B(x)$，使得对于所有在边界 $\partial\mathcal{S} = \{x \mid B(x) = 0\}$ 上的点，其沿系统轨线的导数满足 $\dot{B}(x) = \nabla B(x) \cdot f(x) \le 0$，那么集合 $\mathcal{S}$ 就是前向不变的。这个条件确保了任何到达边界的轨线都无法穿出。

[屏障证书](@entry_id:1121354)与经典控制理论中的**[Lyapunov函数](@entry_id:273986)**密切相关但目标不同：
- **[Lyapunov函数](@entry_id:273986)**用于证明**稳定性**，即轨线向一个平衡点或目标集**收敛**。它要求函数值沿轨线严格递减。
- **[屏障证书](@entry_id:1121354)**用于证明**安全性**，即轨线被限制在一个区域内**不逃逸**。它只对边界行为提出要求，不关心内部行为。

这两种工具是互补的，分别解决了CPS分析中的两个不同但都至重要的问题。在混合系统中，这两种证书都需要补充一个条件来处理离散跳转，即确保跳转不会将状态从安全区域（或[Lyapunov函数](@entry_id:273986)的某个水平集）中抛出。

### 高级主题：时序逻辑与[Zeno行为](@entry_id:268663)

#### [时序逻辑](@entry_id:181558)与活性验证

简单的[可达性](@entry_id:271693)（到达或避开一个集合）无法表达更复杂的属性，例如“请求最终会被响应”或“系统必须周期性地检查传感器”。**线性时序逻辑（Linear Temporal Logic, LTL）** 提供了一种强大的语言来描述这类属性。

验证LTL属性的标准方法是**基于自动机的方法** 。该方法将LTL公式 $\varphi$ 翻译成一个等价的**[非确定性](@entry_id:273591)布赫自动机（Nondeterministic Büchi Automaton, NBA）** $\mathcal{A}_{\varphi}$。NBA是一种在无限长字符串上运行的[有限自动机](@entry_id:1124972)，其接受条件是：一个运行是可接受的，当且仅当它**无限次**地访问接受状态集 $F$。

**布赫接受条件**是验证活性属性的关键。一个活性属性，如“事件 $p$ 无限次发生”（LTL公式为 $\mathbf{GF}\,p$），其对应的NBA的结构会确保只有当输入序列中 $p$ 确实出现无限次时，自动机才能无限次地访问其接受状态。通过构造系统模型与属性自动机（针对 $\neg\varphi$）的乘积自动机，并将[模型检验](@entry_id:150498)问题转化为检查乘积自动机语言是否为空（即是否存在接受环）的问题，我们就可以验证复杂的活性规范。

#### [Zeno行为](@entry_id:268663)及其影响

[混合系统](@entry_id:271183)的一个独特挑战是**[Zeno行为](@entry_id:268663)（Zeno behavior）**：系统在有限的时间内执行了无限次的离散跳转 。一个经典的例子是理想化的“弹跳球”模型，由于每次弹跳后能量损失，弹跳的高度和时间间隔会越来越短，最终在有限的时间内完成无限次弹跳。

[Zeno行为](@entry_id:268663)对[可达性](@entry_id:271693)分析和属性验证有深远影响：
1.  **可达[集的[闭](@entry_id:143367)包](@entry_id:148169)**：Zeno轨迹的**累积点（accumulation point）**——例如弹跳球最终静止在地面上的状态 $(y,v)=(0,0)$——只能在无限次跳转后、于Zeno时刻 $T_{\mathrm{Zeno}}$ 到达。这个点不属于任何有限步可达集，但它位于可达集[序列的极限](@entry_id:159239)中。因此，为了进行可靠的安全性分析，我们必须考虑**[可达集](@entry_id:276191)的拓扑[闭包](@entry_id:148169)（topological closure）**。如果仅分析有限步[可达集](@entry_id:276191)，可能会忽略在累积点处发生的安全违规 。
2.  **活性规范的满足性**：[Zeno行为](@entry_id:268663)可能导致时间“停滞”，使得要求时间发散的活性属性（如“最终稳定”）无法被满足。为了处理这种情况，模型经常需要被**正则化（regularized）**，例如为弹跳[球模型](@entry_id:161388)增加一个“粘滞”模式，当能量低于某个阈值时，球就停留在地面上。这种修正消除了[Zeno现象](@entry_id:274041)，使得时间可以继续流逝，从而让形如“最终永远停在地面上”（$\mathbf{F}\,\mathbf{G}(y=0)$）的活性规范变得可以满足。

总之，[可达性](@entry_id:271693)分析提供了一个统一的框架来推理CPS的[安全性与活性](@entry_id:634196)。从基本的前向/反向可达集定义，到处理[计算复杂性](@entry_id:204275)的近似方法，再到用于综合和[几何分析](@entry_id:157700)的不变集理论，以及处理复杂规范和奇异行为的高级技术，这些原理和机制共同构成了现代[CPS验证](@entry_id:1123177)与控制的基石。