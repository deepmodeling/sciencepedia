{
    "hands_on_practices": [
        {
            "introduction": "Symbolic verification of timed automata hinges on the ability to represent and manipulate infinite sets of clock valuations. This is achieved through zones, which are convex polyhedra defined by simple difference constraints, and their canonical representation, Difference Bound Matrices (DBMs). This practice will guide you through the fundamental mechanics of DBMs, including their construction, canonicalization, and the crucial operation of intersection, which corresponds to the logical conjunction of constraints. ",
            "id": "4251940",
            "problem": "Consider a fragment of a digital twin for a distributed cyber-physical system modeled by a timed automaton with two real-valued clocks $x$ and $y$. Let $x_0$ denote the distinguished zero clock fixed at value $0$. A valuation $v$ maps each clock to a real number, with $v(x_0)=0$. A zone is a set of valuations described by conjunctions of constraints of the form $x_i - x_j \\leq c$, where $x_i, x_j \\in \\{x_0, x, y\\}$ and $c \\in \\mathbb{R}$. A Difference Bound Matrix (DBM) is a matrix $M$ with entries $M_{ij} \\in \\mathbb{R} \\cup \\{\\infty\\}$ encoding the constraint $x_i - x_j \\leq M_{ij}$; the zone defined by $M$ is denoted $\\mathcal{Z}(M) = \\{ v \\mid \\forall i,j,\\ v(x_i)-v(x_j) \\leq M_{ij} \\}$. A DBM is closed (canonical) if it satisfies $M_{ii} = 0$ for all $i$, and $M_{ij} \\leq M_{ik} + M_{kj}$ for all $i,j,k$.\n\nTwo zones over $\\{x,y\\}$ are given by the following constraints.\n\nZone $\\mathcal{Z}_1$:\n- $x - x_0 \\leq 5$,\n- $x_0 - x \\leq 0$,\n- $y - x_0 \\leq 4$,\n- $x_0 - y \\leq -1$,\n- $x - y \\leq 2$,\n- $y - x \\leq 1$.\n\nZone $\\mathcal{Z}_2$:\n- $x - x_0 \\leq 6$,\n- $x_0 - x \\leq -2$,\n- $y - x_0 \\leq 3$,\n- $x - y \\leq \\tfrac{3}{2}$,\n- $y - x \\leq \\tfrac{1}{2}$.\n\nTasks:\n1) Using only the core definitions of zones and Difference Bound Matrices (DBMs), construct closed DBMs $M^{(1)}$ and $M^{(2)}$ for $\\mathcal{Z}_1$ and $\\mathcal{Z}_2$, respectively, over the clock index set $\\{0,1,2\\}$ corresponding to $\\{x_0, x, y\\}$. Explicitly compute any bounds that become tighter under closure.\n\n2) Starting from the definitions of DBMs and closedness (triangle inequalities), derive from first principles that the intersection zone $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ is captured by the DBM $M^{(\\wedge)}$ obtained by the entrywise minimum\n$$\nM^{(\\wedge)}_{ij} \\;=\\; \\min\\!\\big(M^{(1)}_{ij},\\, M^{(2)}_{ij}\\big)\n$$\napplied to closed DBMs, and verify this by computing $M^{(\\wedge)}$ for this instance and showing that $\\mathcal{Z}\\!\\big(M^{(\\wedge)}\\big) \\;=\\; \\mathcal{Z}_1 \\cap \\mathcal{Z}_2$.\n\n3) Over the intersection zone $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$, determine the exact supremum of the linear objective $f(x,y) = x + 2y$. Give your final answer as a single exact real number. Do not round; provide the exact value without units.",
            "solution": "The problem is validated as scientifically grounded, well-posed, objective, and consistent. It represents a standard exercise in the theory of timed automata and Difference Bound Matrices (DBMs). We proceed with the solution.\n\nThe clock indices are assigned as $0 \\to x_0$, $1 \\to x$, and $2 \\to y$. A constraint of the form $x_i - x_j \\leq c$ corresponds to the DBM entry $M_{ij} = c$. The clock $x_0$ is fixed at $v(x_0)=0$.\n\n### Task 1: Construction of Closed DBMs\n\nA DBM $M$ is closed (or canonical) if it is path-consistent, meaning for all indices $i, j, k$, the triangle inequality $M_{ij} \\leq M_{ik} + M_{kj}$ holds. This property is achieved by applying an all-pairs shortest path algorithm, such as the Floyd-Warshall algorithm, to an initial DBM constructed from the given constraints. The algorithm iteratively tightens the bounds: for $k$ from $0$ to $2$, for all $i, j$, update $M_{ij} \\leftarrow \\min(M_{ij}, M_{ik} + M_{kj})$. The diagonal entries $M_{ii}$ are initialized and remain at $0$. Unspecified off-diagonal entries are initialized to $\\infty$.\n\n**Zone $\\mathcal{Z}_1$:**\n\nThe constraints for $\\mathcal{Z}_1$ are:\n- $x - x_0 \\leq 5 \\implies x_1 - x_0 \\leq 5 \\implies M_{10}^{(1)} = 5$\n- $x_0 - x \\leq 0 \\implies x_0 - x_1 \\leq 0 \\implies M_{01}^{(1)} = 0$\n- $y - x_0 \\leq 4 \\implies x_2 - x_0 \\leq 4 \\implies M_{20}^{(1)} = 4$\n- $x_0 - y \\leq -1 \\implies x_0 - x_2 \\leq -1 \\implies M_{02}^{(1)} = -1$\n- $x - y \\leq 2 \\implies x_1 - x_2 \\leq 2 \\implies M_{12}^{(1)} = 2$\n- $y - x \\leq 1 \\implies x_2 - x_1 \\leq 1 \\implies M_{21}^{(1)} = 1$\n\nThe initial DBM for $\\mathcal{Z}_1$ is:\n$$ M_{init}^{(1)} = \\begin{pmatrix} 0  0  -1 \\\\ 5  0  2 \\\\ 4  1  0 \\end{pmatrix} $$\nWe apply the Floyd-Warshall algorithm to close this matrix.\nFor $k=0$:\n$M_{12} \\leftarrow \\min(M_{12}, M_{10} + M_{02}) = \\min(2, 5 + (-1)) = \\min(2, 4) = 2$. No change.\n$M_{21} \\leftarrow \\min(M_{21}, M_{20} + M_{01}) = \\min(1, 4 + 0) = \\min(1, 4) = 1$. No change.\nFor $k=1$:\n$M_{02} \\leftarrow \\min(M_{02}, M_{01} + M_{12}) = \\min(-1, 0 + 2) = \\min(-1, 2) = -1$. No change.\n$M_{20} \\leftarrow \\min(M_{20}, M_{21} + M_{10}) = \\min(4, 1 + 5) = \\min(4, 6) = 4$. No change.\nFor $k=2$:\n$M_{01} \\leftarrow \\min(M_{01}, M_{02} + M_{21}) = \\min(0, -1 + 1) = \\min(0, 0) = 0$. No change.\n$M_{10} \\leftarrow \\min(M_{10}, M_{12} + M_{20}) = \\min(5, 2 + 4) = \\min(5, 6) = 5$. No change.\n\nNo bounds were tightened during the closure process. The initial matrix was already closed.\nThe closed DBM for $\\mathcal{Z}_1$ is:\n$$ M^{(1)} = \\begin{pmatrix} 0  0  -1 \\\\ 5  0  2 \\\\ 4  1  0 \\end{pmatrix} $$\n\n**Zone $\\mathcal{Z}_2$:**\n\nThe constraints for $\\mathcal{Z}_2$ are:\n- $x - x_0 \\leq 6 \\implies x_1 - x_0 \\leq 6 \\implies M_{10}^{(2)} = 6$\n- $x_0 - x \\leq -2 \\implies x_0 - x_1 \\leq -2 \\implies M_{01}^{(2)} = -2$\n- $y - x_0 \\leq 3 \\implies x_2 - x_0 \\leq 3 \\implies M_{20}^{(2)} = 3$\n- The constraint $x_0-y \\leq c$ is not specified, so $M_{02}^{(2)} = \\infty$.\n- $x - y \\leq \\frac{3}{2} \\implies x_1 - x_2 \\leq \\frac{3}{2} \\implies M_{12}^{(2)} = \\frac{3}{2}$\n- $y - x \\leq \\frac{1}{2} \\implies x_2 - x_1 \\leq \\frac{1}{2} \\implies M_{21}^{(2)} = \\frac{1}{2}$\n\nThe initial DBM for $\\mathcal{Z}_2$ is:\n$$ M_{init}^{(2)} = \\begin{pmatrix} 0  -2  \\infty \\\\ 6  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\nWe apply the Floyd-Warshall algorithm.\nFor $k=0$: No entries change as paths through $x_0$ do not provide tighter bounds than already exist. For example, $M_{21} \\leftarrow \\min(\\frac{1}{2}, M_{20}+M_{01}) = \\min(\\frac{1}{2}, 3-2) = \\min(\\frac{1}{2}, 1) = \\frac{1}{2}$.\nFor $k=1$:\n$M_{02} \\leftarrow \\min(M_{02}, M_{01} + M_{12}) = \\min(\\infty, -2 + \\frac{3}{2}) = -\\frac{1}{2}$. **Bound tightened.**\n$M_{20} \\leftarrow \\min(M_{20}, M_{21} + M_{10}) = \\min(3, \\frac{1}{2} + 6) = \\min(3, 6.5) = 3$. No change.\nThe matrix becomes:\n$$ M_{k=1}^{(2)} = \\begin{pmatrix} 0  -2  -\\frac{1}{2} \\\\ 6  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\nFor $k=2$:\n$M_{01} \\leftarrow \\min(M_{01}, M_{02} + M_{21}) = \\min(-2, -\\frac{1}{2} + \\frac{1}{2}) = \\min(-2, 0) = -2$. No change.\n$M_{10} \\leftarrow \\min(M_{10}, M_{12} + M_{20}) = \\min(6, \\frac{3}{2} + 3) = \\min(6, \\frac{9}{2}) = \\frac{9}{2}$. **Bound tightened.**\nThe final closed DBM for $\\mathcal{Z}_2$ is:\n$$ M^{(2)} = \\begin{pmatrix} 0  -2  -\\frac{1}{2} \\\\ \\frac{9}{2}  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\nThe bounds that became tighter are $M_{02}^{(2)}$ (from $\\infty$ to $-\\frac{1}{2}$) and $M_{10}^{(2)}$ (from $6$ to $\\frac{9}{2}$).\n\n### Task 2: Intersection of Zones\n\nWe derive from first principles that the intersection of two zones $\\mathcal{Z}_1 = \\mathcal{Z}(M^{(1)})$ and $\\mathcal{Z}_2 = \\mathcal{Z}(M^{(2)})$ is given by the zone of the entrywise minimum DBM.\n\nA valuation $v$ belongs to the intersection zone $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ if and only if $v$ belongs to both $\\mathcal{Z}_1$ and $\\mathcal{Z}_2$.\n1. By definition of a zone of a DBM, $v \\in \\mathcal{Z}_1$ means that for all clock pairs $(x_i, x_j)$, the inequality $v(x_i) - v(x_j) \\leq M^{(1)}_{ij}$ holds.\n2. Similarly, $v \\in \\mathcal{Z}_2$ means that for all pairs $(x_i, x_j)$, $v(x_i) - v(x_j) \\leq M^{(2)}_{ij}$ holds.\n3. Therefore, for $v$ to be in the intersection, it must satisfy both sets of constraints simultaneously. For any given pair $(i,j)$, $v$ must satisfy both $v(x_i) - v(x_j) \\leq M^{(1)}_{ij}$ and $v(x_i) - v(x_j) \\leq M^{(2)}_{ij}$.\n4. The conjunction of two inequalities of the form $A \\leq B_1$ and $A \\leq B_2$ is logically equivalent to the single, more restrictive inequality $A \\leq \\min(B_1, B_2)$.\n5. Applying this to our case, for each pair $(i,j)$, the condition on the valuation $v$ becomes $v(x_i) - v(x_j) \\leq \\min(M^{(1)}_{ij}, M^{(2)}_{ij})$.\n6. Since this must hold for all pairs $(i,j)$, the intersection zone $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ is the set of all valuations $v$ satisfying $v(x_i) - v(x_j) \\leq \\min(M^{(1)}_{ij}, M^{(2)}_{ij})$ for all $i,j$.\n7. Let us define a new DBM, $M^{(\\wedge)}$, where $M^{(\\wedge)}_{ij} = \\min(M^{(1)}_{ij}, M^{(2)}_{ij})$. The set of valuations described in step 6 is precisely the zone $\\mathcal{Z}(M^{(\\wedge)})$. This completes the derivation.\n\nNow, we compute $M^{(\\wedge)}$ for the specific instance using the closed DBMs $M^{(1)}$ and $M^{(2)}$:\n$$ M^{(1)} = \\begin{pmatrix} 0  0  -1 \\\\ 5  0  2 \\\\ 4  1  0 \\end{pmatrix}, \\quad M^{(2)} = \\begin{pmatrix} 0  -2  -\\frac{1}{2} \\\\ \\frac{9}{2}  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\n$$ M^{(\\wedge)}_{ij} = \\min(M^{(1)}_{ij}, M^{(2)}_{ij}) $$\n$$ M^{(\\wedge)} = \\begin{pmatrix}\n  \\min(0,0)  \\min(0,-2)  \\min(-1,-\\frac{1}{2}) \\\\\n  \\min(5, \\frac{9}{2})  \\min(0,0)  \\min(2, \\frac{3}{2}) \\\\\n  \\min(4,3)  \\min(1,\\frac{1}{2})  \\min(0,0)\n\\end{pmatrix} = \\begin{pmatrix}\n  0  -2  -1 \\\\\n  \\frac{9}{2}  0  \\frac{3}{2} \\\\\n  3  \\frac{1}{2}  0\n\\end{pmatrix} $$\nThe DBM $M^{(\\wedge)}$ represents the intersection zone $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$. This matrix happens to be closed, so it provides the tightest possible constraints for the intersection zone.\n\n### Task 3: Supremum of $f(x,y) = x + 2y$\n\nWe seek to find the supremum of $f(x,y) = x+2y$ over the intersection zone $\\mathcal{Z}_{int} = \\mathcal{Z}(M^{(\\wedge)})$. The constraints on the valuations $v(x)=x$ and $v(y)=y$ are derived from $M^{(\\wedge)}$, using $v(x_0)=0$:\n- $x_0 - x \\leq M^{(\\wedge)}_{01} \\implies 0 - x \\leq -2 \\implies x \\geq 2$\n- $x - x_0 \\leq M^{(\\wedge)}_{10} \\implies x - 0 \\leq \\frac{9}{2} \\implies x \\leq 4.5$\n- $x_0 - y \\leq M^{(\\wedge)}_{02} \\implies 0 - y \\leq -1 \\implies y \\geq 1$\n- $y - x_0 \\leq M^{(\\wedge)}_{20} \\implies y - 0 \\leq 3 \\implies y \\leq 3$\n- $y - x \\leq M^{(\\wedge)}_{21} \\implies y - x \\leq \\frac{1}{2} \\implies y \\leq x + \\frac{1}{2}$\n- $x - y \\leq M^{(\\wedge)}_{12} \\implies x - y \\leq \\frac{3}{2} \\implies y \\geq x - \\frac{3}{2}$\n\nThis defines a linear programming problem: maximize $x+2y$ subject to:\n$2 \\leq x \\leq 4.5$\n$1 \\leq y \\leq 3$\n$y \\geq x - 1.5$\n$y \\leq x + 0.5$\n\nThe feasible region is a compact, convex polygon. The supremum of a linear function over this region is its maximum value, which must be attained at one of the vertices. We find the vertices by intersecting the boundary lines of the constraints.\nThe vertices of the feasible region are:\n1. Intersection of $x=2$ and $y=x+0.5$: $(x,y)=(2, 2.5)$. This point is in the feasible region.\n2. Intersection of $y=3$ and $y=x+0.5$: $(x,y)=(2.5, 3)$. This point is in the feasible region.\n3. Intersection of $y=3$ and $x=4.5$. This gives the point $(4.5, 3)$. Check other constraints: $3 \\geq 4.5 - 1.5 = 3$ (holds) and $3 \\leq 4.5 + 0.5 = 5$ (holds). This point is feasible. It is also the intersection of $y=x-1.5$ and $x=4.5$.\n4. Intersection of $y=1$ and $y=x-1.5$: $(x,y)=(2.5, 1)$. This point is in the feasible region.\n5. Intersection of $x=2$ and $y=1$: $(x,y)=(2, 1)$. This point is in the feasible region.\n\nWe evaluate the objective function $f(x,y)=x+2y$ at each vertex:\n- $f(2, 1) = 2 + 2(1) = 4$\n- $f(2.5, 1) = 2.5 + 2(1) = 4.5$\n- $f(2, 2.5) = 2 + 2(2.5) = 2 + 5 = 7$\n- $f(2.5, 3) = 2.5 + 2(3) = 2.5 + 6 = 8.5$\n- $f(4.5, 3) = 4.5 + 2(3) = 4.5 + 6 = 10.5$\n\nThe maximum value among these is $10.5$. The supremum of the objective function $f(x,y)=x+2y$ over the intersection zone is $10.5$.",
            "answer": "$$\\boxed{\\frac{21}{2}}$$"
        },
        {
            "introduction": "Having mastered the manipulation of zones, we can now assemble them into a complete verification algorithm. This exercise challenges you to implement a symbolic forward reachability engine for timed automata, a cornerstone of modern model checking for real-time systems. By programming the core operations—time elapse, guard intersection, and clock resets—all using DBMs, you will build a tool capable of verifying critical safety properties on timed models. ",
            "id": "4251986",
            "problem": "Consider a timed automaton modeling the real-time behavior of a cyber-physical system for use in a digital twin. A timed automaton is defined as a tuple $(L, \\ell_0, C, E, \\mathrm{Inv})$, where $L$ is a finite set of locations, $\\ell_0 \\in L$ is the initial location, $C = \\{x_1, \\dots, x_m\\}$ is a finite set of real-valued clocks, $E \\subseteq L \\times \\mathcal{G}(C) \\times 2^C \\times L$ is a set of edges where $\\mathcal{G}(C)$ denotes guards, and $\\mathrm{Inv}: L \\to \\mathcal{G}(C)$ assigns location invariants. Clocks evolve continuously with rate $1$ with respect to time, and may be reset to $0$ on discrete transitions.\n\nSymbolic reachability uses zones encoded by Difference Bound Matrices (DBMs). A DBM is an array $M \\in (\\mathbb{R} \\cup \\{\\infty\\})^{n \\times n}$ for $n = |C| + 1$, indexing clocks $x_0, x_1, \\dots, x_m$, where $x_0$ is a distinguished zero clock that never changes and always remains $0$. Each entry $M[i,j]$ encodes a constraint $x_i - x_j \\leq b_{ij}$, and the zone represented by $M$ is the conjunction of all encoded constraints. The DBM must be canonical (i.e., closed under the triangle inequality) to capture all implied constraints, which is achieved by computing the all-pairs shortest paths closure $M[i,j] \\leftarrow \\min(M[i,j], M[i,k] + M[k,j])$ for all indices $i,j,k$.\n\nFundamental operations for timed automata semantics over zones include:\n- Intersection with a guard or invariant: conjoin constraints $x_i - x_j \\leq b$, then recompute the canonical closure.\n- Time elapse under invariant $\\mathrm{Inv}(\\ell)$: starting from a zone $Z$, compute $Z' = \\mathrm{Up}(Z \\cap \\mathrm{Inv}(\\ell)) \\cap \\mathrm{Inv}(\\ell)$, where $\\mathrm{Up}$ removes all upper bounds of the form $x_i - x_0 \\leq b$ (i.e., sets them to $\\infty$) while preserving lower bounds $x_0 - x_i \\leq b$ and inter-clock difference constraints.\n- Resetting a clock $x_r$: set the row and column of $x_r$ equal to those of $x_0$ and set $M[r,r] = 0$, then canonically close the DBM.\n\nSafety property to verify: for a designated clock $x$ and a constant bound $c \\in \\mathbb{R}$, the system should ensure in all reachable zones at unsafe locations that the zone implies $x \\leq c$. In DBM terms, a zone implies $x \\leq c$ if and only if its canonical closure satisfies $M[\\mathrm{idx}(x), \\mathrm{idx}(x_0)] \\leq c$. That is, the symbolic zone is contained in the half-space $x - x_0 \\leq c$.\n\nYour task is to write a complete program that:\n1. Implements DBM-based symbolic reachability for timed automata as specified above.\n2. Checks the safety property “the clock $x$ never exceeds $c$ in unsafe locations” by verifying $M[\\mathrm{idx}(x), \\mathrm{idx}(x_0)] \\leq c$ for each reachable zone at any location labeled unsafe.\n3. Uses the following test suite of automata, each specified by locations, invariants, edges, initial location, and the property clock index and bound $c$. Time is interpreted in seconds, but the program’s outputs are pure booleans and require no unit conversion. All constraints and bounds are given as non-strict inequalities:\n\nTest case $1$ (reset enforces safety):\n- Clocks: $C = \\{x\\}$ with $x$ at index $1$.\n- Locations: $L = \\{\\ell_0, \\ell_1\\}$ with $\\ell_1$ unsafe.\n- Invariants: $\\mathrm{Inv}(\\ell_0): x \\leq 10$, $\\mathrm{Inv}(\\ell_1): x \\leq 2$.\n- Edge: $(\\ell_0, x \\geq 4, \\{x\\}, \\ell_1)$; guard $x \\geq 4$ encoded as $x_0 - x \\leq -4$; reset $\\{x\\}$.\n- Initial location: $\\ell_0$ with all clocks initially $0$.\n- Property: check $x \\leq c$ in unsafe locations with $c = 2$.\n\nTest case $2$ (boundary tight equality):\n- Clocks: $C = \\{x\\}$ with $x$ at index $1$.\n- Locations: $L = \\{\\ell_0, \\ell_1\\}$ with $\\ell_1$ unsafe.\n- Invariants: $\\mathrm{Inv}(\\ell_0): x \\leq 3$, $\\mathrm{Inv}(\\ell_1): x \\leq 3$.\n- Edge: $(\\ell_0, x \\geq 3 \\wedge x \\leq 3, \\emptyset, \\ell_1)$; equality $x = 3$ encoded by $x_0 - x \\leq -3$ and $x - x_0 \\leq 3$.\n- Initial location: $\\ell_0$.\n- Property: check $x \\leq c$ at unsafe with $c = 3$.\n\nTest case $3$ (violation due to invariant allowing growth):\n- Clocks: $C = \\{x\\}$ with $x$ at index $1$.\n- Locations: $L = \\{\\ell_0, \\ell_1\\}$ with $\\ell_1$ unsafe.\n- Invariants: $\\mathrm{Inv}(\\ell_0): x \\leq 10$, $\\mathrm{Inv}(\\ell_1): x \\leq 10$.\n- Edge: $(\\ell_0, x \\geq 4, \\emptyset, \\ell_1)$.\n- Initial location: $\\ell_0$.\n- Property: check $x \\leq c$ at unsafe with $c = 4$.\n\nTest case $4$ (unsafe unreachable):\n- Clocks: $C = \\{x\\}$ with $x$ at index $1$.\n- Locations: $L = \\{\\ell_0, \\ell_1\\}$ with $\\ell_1$ unsafe.\n- Invariants: $\\mathrm{Inv}(\\ell_0): x \\leq 2$, $\\mathrm{Inv}(\\ell_1): x \\leq 10$.\n- Edge: $(\\ell_0, x \\geq 5, \\emptyset, \\ell_1)$.\n- Initial location: $\\ell_0$.\n- Property: check $x \\leq c$ at unsafe with $c = 5$.\n\nTest case $5$ (derived bound via difference constraints with two clocks):\n- Clocks: $C = \\{x, y\\}$ with $x$ at index $1$ and $y$ at index $2$.\n- Locations: $L = \\{\\ell_0, \\ell_1\\}$ with $\\ell_1$ unsafe.\n- Invariants: $\\mathrm{Inv}(\\ell_0): y \\leq 3$, $\\mathrm{Inv}(\\ell_1): y \\leq 3$.\n- Edge: $(\\ell_0, x - y \\leq 0, \\emptyset, \\ell_1)$; guard $x \\leq y$ encoded as $x - y \\leq 0$.\n- Initial location: $\\ell_0$.\n- Property: check $x \\leq c$ at unsafe with $c = 3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is a boolean indicating whether the property holds in test case $i$. No other output should be produced.",
            "solution": "The problem posed is a valid and well-defined exercise in the domain of formal methods for cyber-physical systems. It requests the implementation of a symbolic forward reachability algorithm for timed automata using Difference Bound Matrices (DBMs) to verify a safety property. The problem statement is scientifically grounded in the established theory of timed automata, provides a complete and consistent set of definitions, operations, and test cases, and is objectively formulated. Therefore, I will proceed to delineate the solution.\n\nThe core of the task is to implement a symbolic state-space exploration algorithm. This algorithm iteratively computes the set of reachable symbolic states, where each symbolic state is a pair $(\\ell, Z)$ consisting of a location $\\ell \\in L$ and a zone $Z$. A zone is a convex set of clock valuations, which we represent using a Difference Bound Matrix (DBM). The algorithm must verify a safety property of the form $x \\le c$ for all reachable states within designated unsafe locations.\n\nA DBM $M$ for a set of $m$ clocks $\\{x_1, \\dots, x_m\\}$ is an $(m+1) \\times (m+1)$ matrix, where the additional clock $x_0$ is a fictitious clock fixed at the value $0$. An entry $M[i,j]$ represents the upper bound on the difference between two clocks, encoding the constraint $x_i - x_j \\le M[i,j]$. A zone is the set of all clock valuations satisfying all such constraints defined by the DBM. For a DBM to be a valid and efficient representation, it must be in a canonical form, which is achieved by computing its shortest-path closure. This ensures that all implied constraints are made explicit. The Floyd-Warshall algorithm is the standard method for this, defined by the update rule $M[i,j] \\leftarrow \\min(M[i,j], M[i,k] + M[k,j])$ for all $i,j,k$. A zone is empty if and only if its canonical DBM has a negative diagonal element, which can be detected by checking if $M[0,0]  0$ after canonization.\n\nThe symbolic reachability algorithm proceeds as follows:\nWe maintain a `waiting_list` of symbolic states $(\\ell, Z)$ yet to be explored, and a `passed_list` of states that have already been processed. The algorithm is initialized with the starting state $(\\ell_0, Z_0)$, where $Z_0$ represents the initial clock valuations (all clocks at $0$).\n\nThe main loop of the algorithm is:\n1.  Extract a symbolic state $(\\ell, Z)$ from the `waiting_list`.\n2.  To avoid redundant computations and ensure termination for systems with finite bisimulations, we check if the zone $Z$ is already subsumed by a previously visited zone at the same location. That is, if there exists $(\\ell, Z')$ in the `passed_list` such that $Z \\subseteq Z'$, we discard $(\\ell, Z)$ and continue. The subset relation $Z \\subseteq Z'$ holds if and only if $M_Z[i,j] \\le M_{Z'}[i,j]$ for all indices $i,j$.\n3.  If not subsumed, add $(\\ell, Z)$ to the `passed_list`.\n4.  Compute the set of states reachable from $(\\ell, Z)$ by letting time elapse. This is the time-successor zone, computed as $Z_{\\text{succ}} = \\mathrm{Up}(Z \\cap \\mathrm{Inv}(\\ell)) \\cap \\mathrm{Inv}(\\ell)$. The $\\mathrm{Up}$ operation abstracts away specific upper bounds on clocks, representing the effect of time advancing indefinitely. It is implemented by setting all entries $M[i,0]$ (for $i > 0$) to $\\infty$ and re-canonizing.\n5.  If the location $\\ell$ is designated as unsafe, the safety property must be checked on the time-successor zone $Z_{\\text{succ}}$. The property $x \\le c$ holds for the entire zone $Z_{\\text{succ}}$ if its DBM $M_{\\text{succ}}$ satisfies $M_{\\text{succ}}[\\mathrm{idx}(x), \\mathrm{idx}(x_0)] \\le c$. If this check fails for any reachable zone in any unsafe location, the property is violated for the entire system.\n6.  For each outgoing edge $(\\ell, g, R, \\ell')$ from location $\\ell$, compute the discrete successor state. This involves:\n    a.  Intersecting the time-successor zone $Z_{\\text{succ}}$ with the edge's guard $g$. This is done by updating the DBM with the guard constraints and re-canonizing. If the resulting zone is empty, this transition path is pruned.\n    b.  Applying the clock resets $R$ to the resulting zone. Resetting a clock $x_r$ corresponds to setting its value to $0$ while preserving the values of other clocks. In DBM terms, this involves copying the row and column of the zero clock $x_0$ to the row and column of $x_r$ and re-canonizing.\n    c.  The resulting symbolic state $(\\ell', Z_{\\text{new}})$ is added to the `waiting_list` for future exploration.\n\nThe algorithm terminates when the `waiting_list` becomes empty, at which point all reachable symbolic states have been explored. The safety property is considered to hold if and only if it was not violated during the exploration. This procedure will be implemented and applied to each of the five test cases provided.\n\nThe initial zone $Z_0$, where all clocks are $0$, is represented by a DBM where all entries are $0$.\nThe constraints are translated as follows:\n-   $x_i \\le c$ becomes $x_i - x_0 \\le c$.\n-   $x_i \\ge c$ becomes $x_0 - x_i \\le -c$.\n-   $x_i - x_j \\le c$ is a direct DBM constraint.\n\nThe implementation will encapsulate these DBM operations and the reachability logic to provide a boolean result for each test case, indicating whether the specified safety property is maintained.",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef canonicalize(dbm):\n    \"\"\"\n    Applies the Floyd-Warshall algorithm to compute the canonical form of a DBM.\n    \"\"\"\n    n = dbm.shape[0]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dbm[i, j] = min(dbm[i, j], dbm[i, k] + dbm[k, j])\n    return dbm\n\ndef is_empty(dbm):\n    \"\"\"\n    Checks if a zone represented by a DBM is empty.\n    A zone is empty if any diagonal element is negative after canonization.\n    \"\"\"\n    return dbm[0, 0]  0\n\ndef intersect(dbm, constraints):\n    \"\"\"\n    Intersects a zone with a set of constraints.\n    Constraints is a list of tuples (i, j, bound) for x_i - x_j = bound.\n    \"\"\"\n    new_dbm = dbm.copy()\n    for i, j, b in constraints:\n        if b  new_dbm[i, j]:\n            new_dbm[i, j] = b\n    \n    new_dbm = canonicalize(new_dbm)\n    return new_dbm\n\ndef time_elapse(dbm, inv_constraints):\n    \"\"\"\n    Computes the time-successor zone according to the problem's definition:\n    Z' = Up(Z intersect Inv(l)) intersect Inv(l).\n    \"\"\"\n    # 1. Z intersect Inv(l)\n    z_inv = intersect(dbm, inv_constraints)\n    if is_empty(z_inv):\n        return None\n\n    # 2. Up(z_inv)\n    num_clocks = z_inv.shape[0] - 1\n    for i in range(1, num_clocks + 1):\n        z_inv[i, 0] = np.inf\n    # Per the problem description, preserving inter-clock differences is\n    # part of the standard 'Up' definition, but the text only mentions\n    # setting upper bounds to infinity. Canonicalization after this step\n    # and intersection with invariant re-establishes correct bounds.\n    z_up = canonicalize(z_inv)\n    \n    # 3. z_up intersect Inv(l)\n    z_succ = intersect(z_up, inv_constraints)\n    if is_empty(z_succ):\n        return None\n\n    return z_succ\n\ndef reset(dbm, reset_indices):\n    \"\"\"\n    Resets specified clocks to 0.\n    \"\"\"\n    new_dbm = dbm.copy()\n    for r_idx in reset_indices:\n        # Copy row 0 to row r_idx\n        new_dbm[r_idx, :] = new_dbm[0, :]\n        # Copy column 0 to column r_idx\n        new_dbm[:, r_idx] = new_dbm[:, 0]\n        # Set diagonal to 0\n        new_dbm[r_idx, r_idx] = 0\n    \n    return canonicalize(new_dbm)\n\ndef is_subset(dbm1, dbm2):\n    \"\"\"\n    Checks if the zone of dbm1 is a subset of the zone of dbm2.\n    This holds if and only if for all i, j: dbm1[i,j] = dbm2[i,j].\n    \"\"\"\n    return np.all(dbm1 = dbm2)\n\ndef run_reachability(automaton):\n    \"\"\"\n    Performs symbolic forward reachability analysis for a given timed automaton.\n    \"\"\"\n    num_clocks = automaton['num_clocks']\n    initial_loc = automaton['initial_loc']\n    \n    # Initial zone: all clocks are 0. DBM is all zeros.\n    initial_dbm = np.zeros((num_clocks + 1, num_clocks + 1))\n    \n    waiting = deque([(initial_loc, initial_dbm)])\n    # passed is a dict: loc - list of DBMs\n    passed = {loc: [] for loc in automaton['locations']}\n    \n    property_holds = True\n\n    while waiting:\n        loc, dbm = waiting.popleft()\n\n        # Subsumption check\n        is_subsumed = False\n        for old_dbm in passed[loc]:\n            if is_subset(dbm, old_dbm):\n                is_subsumed = True\n                break\n        if is_subsumed:\n            continue\n        \n        # Add to passed list, removing any zones that are now subsumed by the new one\n        passed[loc] = [old for old in passed[loc] if not is_subset(old, dbm)]\n        passed[loc].append(dbm)\n        \n        # 1. Time Elapse\n        invariant = automaton['invariants'].get(loc, [])\n        succ_dbm = time_elapse(dbm.copy(), invariant)\n\n        if succ_dbm is None:  # Empty zone after elapse\n            continue\n        \n        # 2. Check property if in unsafe location\n        if loc in automaton['unsafe_locs']:\n            prop_idx = automaton['prop_clock_idx']\n            prop_bound = automaton['prop_bound']\n            # Zone implies x = c iff M[idx(x), 0] = c\n            if not (succ_dbm[prop_idx, 0] = prop_bound):\n                property_holds = False\n                # We can stop early if we only care if a violation exists\n                return False\n\n        # 3. Discrete Transitions\n        for l_from, guard, resets, l_to in automaton['edges']:\n            if l_from != loc:\n                continue\n                \n            # Apply guard\n            guarded_dbm = intersect(succ_dbm.copy(), guard)\n            if is_empty(guarded_dbm):\n                continue\n            \n            # Apply resets\n            reset_dbm = reset(guarded_dbm, resets)\n\n            waiting.append((l_to, reset_dbm))\n            \n    return property_holds\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the analysis.\n    \"\"\"\n    # x0 is clock 0 (the zero clock)\n    # Test cases defined according to the problem statement.\n    test_cases = [\n        { # Case 1: reset enforces safety\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 10)], 1: [(1, 0, 2)]}, # x = 10, x = 2\n            'edges': [(0, [(0, 1, -4)], {1}, 1)], # loc0 - loc1 if x = 4, reset x\n            'prop_clock_idx': 1, 'prop_bound': 2\n        },\n        { # Case 2: boundary tight equality\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 3)], 1: [(1, 0, 3)]}, # x = 3, x = 3\n            'edges': [(0, [(0, 1, -3), (1, 0, 3)], set(), 1)], # loc0 - loc1 if x = 3\n            'prop_clock_idx': 1, 'prop_bound': 3\n        },\n        { # Case 3: violation due to invariant allowing growth\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 10)], 1: [(1, 0, 10)]}, # x = 10, x = 10\n            'edges': [(0, [(0, 1, -4)], set(), 1)], # loc0 - loc1 if x = 4\n            'prop_clock_idx': 1, 'prop_bound': 4\n        },\n        { # Case 4: unsafe unreachable\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 2)], 1: [(1, 0, 10)]}, # x = 2, x = 10\n            'edges': [(0, [(0, 1, -5)], set(), 1)], # loc0 - loc1 if x = 5\n            'prop_clock_idx': 1, 'prop_bound': 5\n        },\n        { # Case 5: derived bound via difference constraints\n            'num_clocks': 2, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(2, 0, 3)], 1: [(2, 0, 3)]}, # y = 3, y = 3\n            'edges': [(0, [(1, 2, 0)], set(), 1)], # loc0 - loc1 if x = y\n            'prop_clock_idx': 1, 'prop_bound': 3\n        }\n    ]\n\n    results = []\n    for automaton in test_cases:\n        result = run_reachability(automaton)\n        results.append(result)\n    \n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Real-world systems are typically composed of multiple interacting components, and their analysis requires reasoning about their concurrent execution. This practice focuses on a critical property of composed systems: deadlock, a state where no further progress is possible. You will implement a detector that formalizes the conditions for deadlock by checking for both the absence of any enabled discrete transitions (internal or synchronized) and the inability for time to advance due to restrictive invariants. ",
            "id": "4251945",
            "problem": "A composed model of Timed Automata (TA) for Cyber-Physical Systems (CPS) and Digital Twins is defined over a finite set of locations, a finite set of clocks, invariants at locations, and edges labeled with actions and equipped with guards and clock resets. A discrete transition is allowed when its guard is true under the current clock valuation and the invariant at the target location is satisfied immediately after applying the clock resets. A time-elapse transition of duration $d$ moves the system from valuation $v$ to $v + d$, and is allowed only if the invariant of the current location in each automaton holds for all $t$ in $[0,d]$. A global state is called a deadlock if no discrete transition is enabled and time cannot progress.\n\nFundamental base:\n- A Timed Automaton is the tuple $(L, \\ell_0, C, E, Inv)$ where $L$ is a finite set of locations, $\\ell_0 \\in L$ is the initial location, $C$ is a finite set of clocks ranging over $\\mathbb{R}_{\\ge 0}$, $E$ is a finite set of edges, and $Inv$ assigns to each location an invariant expressed as a conjunction of atomic constraints over $C$.\n- Atomic constraints are of the form $x \\le c$, $x  c$, $x \\ge c$, $x  c$, or $x = c$, where $x \\in C$ and $c \\in \\mathbb{R}_{\\ge 0}$.\n- The semantics of composition $A_1 \\parallel A_2$ synchronizes on shared action labels: if both automata have enabled edges with the same label, a single synchronized discrete transition occurs that applies both sets of resets simultaneously. Internal edges (silent or unlabeled) fire independently in their respective automaton.\n\nYou must implement a program that detects deadlock for a given global state of a composed system of two timed automata. Use the following formal rules:\n- Discrete transition enabledness:\n  - Internal edge in one automaton: its guard must be true under the current valuation $v$ restricted to the automaton’s clocks, and the target location’s invariant must be true under the valuation obtained by resetting the specified clocks to $0$ while leaving all other clocks unchanged.\n  - Synchronized edge between the two automata on a common label $\\alpha$: both guards must be true under $v$, and both target invariants must be true under the valuation obtained by applying both sets of resets concurrently.\n- Time progression possibility: there exists $d  0$ such that for all $t \\in [0,d]$, each active invariant remains true under $v + t$. For invariants composed of conjunctions of atomic constraints, a necessary and sufficient condition for time to progress is that the minimum slack across all upper-bound constraints is strictly positive. Define slack for an atomic constraint as follows:\n  - For $x \\le c$ and $x  c$, slack is $c - v(x)$.\n  - For $x = c$, slack is $0$.\n  - For $x \\ge c$ and $x  c$, these constraints do not reduce allowable positive delay since clocks increase with time and are already satisfied at $t = 0$.\n  Time can progress if and only if the minimum slack across all currently active upper-bound constraints is strictly greater than $0$. If there are no upper-bound constraints, time can progress arbitrarily.\n\nImplement the detection function that returns a boolean indicating whether the provided global state is a deadlock, i.e., it returns $\\text{true}$ if and only if no discrete transition is enabled and no positive time delay is possible.\n\nRepresent constraints as triples $(x, \\mathop{\\mathrm{op}}, c)$ with $x$ a clock name, $\\mathop{\\mathrm{op}} \\in \\{\\le, , \\ge, , =\\}$, and $c \\in \\mathbb{R}_{\\ge 0}$. An edge is represented by a label $\\alpha$ (with $\\alpha$ either a string or $\\varnothing$ for internal edges), a guard which is a list of constraints, a set of resets (a list of clock names to set to $0$), and a target invariant (a list of constraints). Each automaton supplies its current location’s invariant and its outgoing edges from that location. The global clock valuation $v$ maps clock names to nonnegative real numbers.\n\nTest suite and parameters:\n- Case $1$ (happy path): Automaton $A$ has invariant $x \\le 10$ with $v(x) = 3$, no edges. Automaton $B$ has invariant $y \\le 7$ with $v(y) = 2$, no edges. Expect no deadlock since time can progress by at least $5$.\n- Case $2$ (deadlock by saturated invariant and missing synchronization): $A$ has invariant $x \\le 0$ with $v(x) = 0$ and one synchronized edge labeled $\\alpha$ with guard $x = 0$, reset $\\{x\\}$, and target invariant $x \\le 10$. $B$ has invariant $y \\le 5$ with $v(y) = 1$, and no edge labeled $\\alpha$. Expect deadlock since time cannot progress (slack $0$ on $x \\le 0$) and no discrete transition is enabled.\n- Case $3$ (synchronization available removes deadlock): Same as Case $2$ for $A$. $B$ has invariant $y \\le 5$ with $v(y) = 1$ and a synchronized edge labeled $\\alpha$ with guard $y \\ge 0$, reset $\\{y\\}$, and target invariant $y \\le 10$. Expect no deadlock since a synchronized discrete transition is enabled.\n- Case $4$ (boundary equality blocking time): $A$ has invariant $x = 2$ with $v(x) = 2$, no edges. $B$ has invariant $y \\le 3$ with $v(y) = 1$, no edges. Expect deadlock since equality yields zero slack and no discrete transitions.\n- Case $5$ (internal edge available removes deadlock): $A$ has invariant $x \\le 0$ with $v(x) = 0$ and an internal edge with guard $x = 0$, reset $\\{x\\}$, and target invariant $x \\le 5$. $B$ has invariant $y \\le 0$ with $v(y) = 0$, no edges. Expect no deadlock due to the internal discrete transition in $A$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., [$\\text{True}$,$\\text{False}$,$\\text{True}$,$\\text{False}$,$\\text{True}$]). The outputs must be booleans indicating deadlock presence for Cases $1$ through $5$, respectively, in the order listed above.",
            "solution": "The problem is validated as scientifically sound and well-posed. It requires implementing a function to detect deadlock, which is a state where no progress is possible. A deadlock occurs if and only if two conditions are met simultaneously: (1) no discrete transition is enabled, and (2) time cannot advance.\n\nThe solution logic is divided into two checks:\n1.  **Discrete Progression Check:** The program searches for any enabled transition. This includes internal (unlabeled) transitions within either automaton and synchronized transitions on shared labels. A transition is enabled if its guard(s) are satisfied by the current clock valuation, and the target location's invariant(s) hold true for the valuation that results from applying the clock resets. If any such transition is found, the system is not blocked discretely.\n2.  **Time Progression Check:** Time can advance if and only if all active invariants can be satisfied for a non-zero duration. This is formally checked by calculating the \"slack\" for all active upper-bound constraints ($x \\le c$, $x  c$, $x=c$). Time can progress only if the minimum slack is strictly positive. A slack of zero, which occurs for an equality constraint or a saturated inequality ($x \\le c$ with $v(x)=c$), blocks time.\n\nA deadlock is detected if and only if the system is blocked both discretely and temporally. The provided Python code directly implements these two checks to evaluate each test case.",
            "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the deadlock detection problem for a composed system of two timed automata.\n    \"\"\"\n\n    # --- Data Structures ---\n    Constraint = namedtuple('Constraint', ['clock', 'op', 'value'])\n    Edge = namedtuple('Edge', ['label', 'guard', 'resets', 'target_invariant'])\n    AutomatonState = namedtuple('AutomatonState', ['invariant', 'edges'])\n\n    # --- Test Case Definitions ---\n    # The structure for each test case is: (automaton_A_state, automaton_B_state, clock_valuation)\n    test_cases = [\n        # Case 1: Time can progress, no discrete transitions. Expect: No deadlock (False).\n        (\n            AutomatonState(invariant=[Constraint('x', '=', 10)], edges=[]),\n            AutomatonState(invariant=[Constraint('y', '=', 7)], edges=[]),\n            {'x': 3, 'y': 2}\n        ),\n        # Case 2: Time blocked, no enabled discrete transition. Expect: Deadlock (True).\n        (\n            AutomatonState(\n                invariant=[Constraint('x', '=', 0)],\n                edges=[Edge(label='alpha', guard=[Constraint('x', '==', 0)], resets=['x'], target_invariant=[Constraint('x', '=', 10)])]\n            ),\n            AutomatonState(invariant=[Constraint('y', '=', 5)], edges=[]),\n            {'x': 0, 'y': 1}\n        ),\n        # Case 3: Time blocked, but synchronization is possible. Expect: No deadlock (False).\n        (\n            AutomatonState(\n                invariant=[Constraint('x', '=', 0)],\n                edges=[Edge(label='alpha', guard=[Constraint('x', '==', 0)], resets=['x'], target_invariant=[Constraint('x', '=', 10)])]\n            ),\n            AutomatonState(\n                invariant=[Constraint('y', '=', 5)],\n                edges=[Edge(label='alpha', guard=[Constraint('y', '=', 0)], resets=['y'], target_invariant=[Constraint('y', '=', 10)])]\n            ),\n            {'x': 0, 'y': 1}\n        ),\n        # Case 4: Equality constraint blocks time, no discrete transitions. Expect: Deadlock (True).\n        (\n            AutomatonState(invariant=[Constraint('x', '==', 2)], edges=[]),\n            AutomatonState(invariant=[Constraint('y', '=', 3)], edges=[]),\n            {'x': 2, 'y': 1}\n        ),\n        # Case 5: Time blocked, but an internal transition is possible. Expect: No deadlock (False).\n        (\n            AutomatonState(\n                invariant=[Constraint('x', '=', 0)],\n                edges=[Edge(label=None, guard=[Constraint('x', '==', 0)], resets=['x'], target_invariant=[Constraint('x', '=', 5)])]\n            ),\n            AutomatonState(invariant=[Constraint('y', '=', 0)], edges=[]),\n            {'x': 0, 'y': 0}\n        ),\n    ]\n\n    results = []\n    for state_A, state_B, valuation in test_cases:\n        is_deadlocked = detect_deadlock(state_A, state_B, valuation)\n        results.append(is_deadlocked)\n    \n    print(f\"[{','.join(str(r).capitalize() for r in results)}]\")\n\n# --- Helper Functions for Semantic Evaluation ---\n\ndef eval_constraint(constraint: namedtuple, valuation: dict) - bool:\n    \"\"\"Evaluates a single atomic constraint against a clock valuation.\"\"\"\n    clock_val = valuation.get(constraint.clock, 0.0)\n    if constraint.op == '=': return clock_val = constraint.value\n    if constraint.op == '': return clock_val  constraint.value\n    if constraint.op == '=': return clock_val = constraint.value\n    if constraint.op == '': return clock_val  constraint.value\n    if constraint.op == '==': return clock_val == constraint.value\n    return False\n\ndef check_all_constraints(constraints: list, valuation: dict) - bool:\n    \"\"\"Checks if all constraints in a list are true.\"\"\"\n    return all(eval_constraint(c, valuation) for c in constraints)\n\ndef apply_resets(valuation: dict, resets: list) - dict:\n    \"\"\"Applies clock resets to a valuation, returning a new valuation.\"\"\"\n    new_valuation = valuation.copy()\n    for clock in resets:\n        new_valuation[clock] = 0.0\n    return new_valuation\n\n# --- Core Logic for Deadlock Detection ---\n\ndef can_time_progress(state_A: namedtuple, state_B: namedtuple, valuation: dict) - bool:\n    \"\"\"\n    Checks if time can progress from the current global state.\n    Time can progress if the minimum slack across all active upper-bound\n    invariants is strictly positive.\n    \"\"\"\n    all_invariants = state_A.invariant + state_B.invariant\n    upper_bound_constraints = [c for c in all_invariants if c.op in ('=', '', '==')]\n\n    if not upper_bound_constraints:\n        return True  # No upper bounds, time can progress indefinitely.\n\n    min_slack = math.inf\n    for constraint in upper_bound_constraints:\n        # Per problem, slack for x=c is 0, which is handled by this calculation.\n        slack = constraint.value - valuation[constraint.clock]\n        if slack  min_slack:\n            min_slack = slack\n    \n    return min_slack  0\n\ndef can_take_discrete_transition(state_A: namedtuple, state_B: namedtuple, valuation: dict) - bool:\n    \"\"\"\n    Checks if any discrete transition (internal or synchronized) is enabled.\n    \"\"\"\n    # 1. Check for internal transitions in Automaton A\n    for edge in state_A.edges:\n        if edge.label is None:  # Internal edge represented by label=None\n            if check_all_constraints(edge.guard, valuation):\n                v_prime = apply_resets(valuation, edge.resets)\n                # Per problem, check target invariant of the transitioning automaton\n                if check_all_constraints(edge.target_invariant, v_prime):\n                    return True # Found an enabled internal transition in A\n\n    # 2. Check for internal transitions in Automaton B\n    for edge in state_B.edges:\n        if edge.label is None:\n            if check_all_constraints(edge.guard, valuation):\n                v_prime = apply_resets(valuation, edge.resets)\n                if check_all_constraints(edge.target_invariant, v_prime):\n                    return True # Found an enabled internal transition in B\n\n    # 3. Check for synchronized transitions\n    sync_edges_A = {e.label: [] for e in state_A.edges if e.label is not None}\n    sync_edges_B = {e.label: [] for e in state_B.edges if e.label is not None}\n    for e in state_A.edges:\n        if e.label is not None: sync_edges_A[e.label].append(e)\n    for e in state_B.edges:\n        if e.label is not None: sync_edges_B[e.label].append(e)\n\n    common_labels = set(sync_edges_A.keys())  set(sync_edges_B.keys())\n\n    for label in common_labels:\n        for edge_A in sync_edges_A[label]:\n            for edge_B in sync_edges_B[label]:\n                # Check if both guards are simultaneously true\n                if check_all_constraints(edge_A.guard, valuation) and \\\n                   check_all_constraints(edge_B.guard, valuation):\n                    \n                    # Apply combined resets to get the post-transition valuation\n                    combined_resets = list(set(edge_A.resets + edge_B.resets))\n                    v_prime = apply_resets(valuation, combined_resets)\n                    \n                    # Check if both target invariants hold in the new state\n                    if check_all_constraints(edge_A.target_invariant, v_prime) and \\\n                       check_all_constraints(edge_B.target_invariant, v_prime):\n                        return True # Found an enabled synchronized transition\n\n    return False # No discrete transitions are possible\n\ndef detect_deadlock(state_A: namedtuple, state_B: namedtuple, valuation: dict) - bool:\n    \"\"\"\n    A state is a deadlock if no discrete transition is enabled AND time cannot progress.\n    Returns True if the state is a deadlock, False otherwise.\n    \"\"\"\n    is_discrete_possible = can_take_discrete_transition(state_A, state_B, valuation)\n    is_time_possible = can_time_progress(state_A, state_B, valuation)\n    \n    # A deadlock occurs if and only if neither action (discrete step or time passage) is possible.\n    return not (is_discrete_possible or is_time_possible)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}