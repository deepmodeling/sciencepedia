{
    "hands_on_practices": [
        {
            "introduction": "PID 控制器在实际应用中常常会遇到执行器饱和的问题。这种饱和会导致积分器“饱和”（integrator windup），严重影响控制性能，而抗饱和策略是解决此问题的关键。通过计算在给定系统状态下，使控制器输出恰好达到饱和极限的积分器状态值 ，您将对积分饱和现象的边界以及抗饱和策略的原理建立深刻的理解。",
            "id": "2731947",
            "problem": "一个单位反馈回路使用一个通过 Ziegler–Nichols (ZN) 极限振荡法整定的比例-积分-微分 (PID) 控制器。在使用纯比例控制器的极限测试中，在极限增益 $K_{u} = 8$ 和极限周期 $T_{u} = 2.5\\,\\mathrm{s}$ 时观测到持续振荡。该 PID 控制器以理想并联形式实现，执行器在硬上限 $u_{\\max} = 4.5$（以执行器的固有单位计）处饱和。\n\n在一次大的设定点变化过程中的某一瞬间 $t_{0}$，测得的误差及其时间导数分别为 $e(t_{0}) = 0.8$ 和 $\\dot{e}(t_{0}) = -0.3\\,\\mathrm{s}^{-1}$。微分作用应用于误差信号。控制器采用一种带有有限跟踪时间常数 $T_{t}  0$ 的抗积分饱和反计算方案。\n\n假设使用基于 $(K_{u}, T_{u})$ 的标准 Ziegler–Nichols 规则来确定 PID 参数，并假设抗积分饱和反计算驱动内部积分器，使得在饱和下的平衡状态时，内部计算的未饱和控制量等于饱和的执行器输出。在这些条件下，确定在 $t_{0}$ 时与无积分饱和现象一致的控制器积分器状态的最大值 $x_{I,\\max}(t_{0})$，该值被定义为在 $t_{0}$ 时，使内部计算的控制量等于 $u_{\\max}$ 的积分器状态值。\n\n以“误差乘以秒”（例如，如果误差单位是弧度，则单位是 $\\mathrm{rad}\\cdot\\mathrm{s}$）为单位，将最终答案表示为单个实数。将您的答案四舍五入到五位有效数字。",
            "solution": "首先将对问题进行严格的验证过程。\n\n步骤1：提取已知条件。\n- 控制器类型：比例-积分-微分 (PID)，理想并联形式。\n- 反馈回路：单位反馈。\n- 整定方法：Ziegler–Nichols (ZN) 极限振荡法。\n- 极限增益：$K_{u} = 8$。\n- 极限周期：$T_{u} = 2.5\\,\\mathrm{s}$。\n- 执行器饱和上限：$u_{\\max} = 4.5$。\n- $t_{0}$ 时刻的误差：$e(t_{0}) = 0.8$。\n- $t_{0}$ 时刻的误差导数：$\\dot{e}(t_{0}) = -0.3\\,\\mathrm{s}^{-1}$。\n- 微分作用：应用于误差信号。\n- 抗饱和方案：反计算法，跟踪时间常数 $T_{t}  0$。\n- $t_{0}$ 时刻无积分饱和条件的定义：对于积分器状态 $x_{I,\\max}(t_{0})$，在 $t_{0}$ 时刻内部计算的控制量等于 $u_{\\max}$。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据，因为它基于经典控制理论的标准原理，特别是 PID 控制、Ziegler-Nichols 整定以及带抗饱和的执行器饱和问题。该问题是适定的；它提供了所有必要的数值和一个明确的目标：在精确定义的边界条件下，计算积分器状态的一个特定值。所用术语在控制工程领域是标准且明确的。所提供的信息是自洽且一致的。对抗饱和机制的描述提供了背景信息，但计算并不需要 $T_t$ 的具体值，因为计算是由饱和边界处的平衡条件定义的。这不构成缺陷，而是考验区分相关和无关信息的能力。\n\n步骤3：结论与行动。\n问题被判定为有效。将制定解决方案。\n\n任务是确定控制器积分器状态的最大值，记为 $x_{I,\\max}(t_{0})$，使得在给定瞬间 $t_{0}$，控制器内部计算的输出恰好达到饱和极限 $u_{\\max}$。\n\n理想并联形式的 PID 控制器由未饱和控制输出 $u_{unsat}(t)$ 的方程描述：\n$$u_{unsat}(t) = K_{p} e(t) + K_{i} x_{I}(t) + K_{d} \\frac{de(t)}{dt}$$\n其中 $x_{I}(t)$ 表示积分器状态，定义为 $x_{I}(t) = \\int_{0}^{t} e(\\tau) d\\tau$。参数 $K_{p}$、$K_{i}$ 和 $K_{d}$ 分别是比例、积分和微分增益。\n\n问题指出，控制器参数是使用标准的 Ziegler-Nichols 极限振荡法规则为 PID 控制器确定的。这些规则如下：\n- 比例增益：$K_{p} = 0.6 K_{u}$\n- 积分时间常数：$T_{i} = 0.5 T_{u}$\n- 微分时间常数：$T_{d} = 0.125 T_{u}$\n\n增益 $K_{i}$ 和 $K_{d}$ 通过以下并联形式的标准定义与 $K_{p}$、$T_{i}$ 和 $T_{d}$ 相关联：\n- $K_{i} = \\frac{K_{p}}{T_{i}}$\n- $K_{d} = K_{p} T_{d}$\n\n我们已知极限增益 $K_{u} = 8$ 和极限周期 $T_{u} = 2.5\\,\\mathrm{s}$。现在我们可以计算控制器参数。\n$$K_{p} = 0.6 \\times 8 = 4.8$$\n$$T_{i} = 0.5 \\times 2.5\\,\\mathrm{s} = 1.25\\,\\mathrm{s}$$\n$$T_{d} = 0.125 \\times 2.5\\,\\mathrm{s} = 0.3125\\,\\mathrm{s}$$\n\n使用这些时间常数，我们计算积分和微分增益：\n$$K_{i} = \\frac{K_{p}}{T_{i}} = \\frac{4.8}{1.25\\,\\mathrm{s}} = 3.84\\,\\mathrm{s}^{-1}$$\n$$K_{d} = K_{p} T_{d} = 4.8 \\times 0.3125\\,\\mathrm{s} = 1.5\\,\\mathrm{s}$$\n\n系统在时刻 $t_{0}$ 处于饱和阈值的条件是未饱和控制输出等于饱和极限 $u_{\\max}$。\n$$u_{unsat}(t_{0}) = u_{\\max}$$\n\n将 $t_{0}$ 时刻的 PID 控制器方程代入，其中积分器状态为 $x_{I,\\max}(t_0)$：\n$$K_{p} e(t_{0}) + K_{i} x_{I,\\max}(t_{0}) + K_{d} \\dot{e}(t_{0}) = u_{\\max}$$\n我们必须解此方程以求得 $x_{I,\\max}(t_{0})$。\n$$K_{i} x_{I,\\max}(t_{0}) = u_{\\max} - K_{p} e(t_{0}) - K_{d} \\dot{e}(t_{0})$$\n$$x_{I,\\max}(t_{0}) = \\frac{1}{K_{i}} \\left( u_{\\max} - K_{p} e(t_{0}) - K_{d} \\dot{e}(t_{0}) \\right)$$\n\n现在，我们将已知的数值代入此表达式：\n- $u_{\\max} = 4.5$\n- $e(t_{0}) = 0.8$\n- $\\dot{e}(t_{0}) = -0.3\\,\\mathrm{s}^{-1}$\n- $K_{p} = 4.8$\n- $K_{i} = 3.84\\,\\mathrm{s}^{-1}$\n- $K_{d} = 1.5\\,\\mathrm{s}$\n\n计算过程如下：\n$$x_{I,\\max}(t_{0}) = \\frac{1}{3.84} \\left( 4.5 - (4.8)(0.8) - (1.5)(-0.3) \\right)$$\n$$x_{I,\\max}(t_{0}) = \\frac{1}{3.84} \\left( 4.5 - 3.84 - (-0.45) \\right)$$\n$$x_{I,\\max}(t_{0}) = \\frac{1}{3.84} \\left( 4.5 - 3.84 + 0.45 \\right)$$\n$$x_{I,\\max}(t_{0}) = \\frac{1}{3.84} \\left( 0.66 + 0.45 \\right)$$\n$$x_{I,\\max}(t_{0}) = \\frac{1.11}{3.84}$$\n$$x_{I,\\max}(t_{0}) = 0.2890625$$\n单位是一致的，结果符合要求的“误差乘以秒”。\n\n问题要求将答案四舍五入到五位有效数字。计算值为 $0.2890625$。前五位有效数字是 $2, 8, 9, 0, 6$。随后的数字是 $2$，小于 $5$，因此我们向下舍入。\n\n因此，与无积分饱和现象一致的积分器状态的最大值为 $0.28906$。",
            "answer": "$$\\boxed{0.28906}$$"
        },
        {
            "introduction": "在信息物理系统（CPS）的实际操作中，控制模式在手动和自动之间切换是常见的场景。如果切换处理不当，控制信号的突变会引起系统产生不必要的、甚至危险的瞬态响应。本练习  将指导您通过精确初始化 PID 控制器的积分状态，实现从手动到自动模式的“无扰动切换”（bumpless transfer），这是确保控制系统平稳、安全运行的一项核心技术。",
            "id": "4237286",
            "problem": "一个使用数字孪生（DT）的赛博物理系统（CPS）监控一个单输入单输出的被控对象。该被控对象一直以手动模式运行，其中执行器指令保持在一个恒定值。在时间 $t = 0$ 时，模式切换到自动控制，由一个并联形式的比例-积分-微分（PID）控制器进行管理，其微分作用由一个一阶低通滤波器进行滤波，定义为\n$$\nu(t) \\;=\\; K_{p}\\,e(t)\\;+\\;I(t)\\;+\\;K_{d}\\,v(t),\n$$\n其中 $e(t) = r(t) - y(t)$ 是设定值 $r(t)$ 和测量输出 $y(t)$ 之间的跟踪误差，$I(t)$ 是积分器对控制信号的贡献，$v(t)$ 是误差的滤波后导数，满足以下一阶滤波器方程\n$$\nT_{f}\\,\\dot{v}(t) \\;+\\; v(t) \\;=\\; \\dot{e}(t).\n$$\n当控制器处于自动模式时，积分器的贡献由一个内部状态 $\\xi(t)$ 通过 $I(t) = K_{i}\\,\\xi(t)$ 和 $\\dot{\\xi}(t) = e(t)$ 生成。在手动模式下，PID不驱动被控对象；但是，数字孪生提供了 $e(t)$ 和 $\\dot{e}(t)$ 的估计值。\n\n为避免切换瞬间的输出不连续性，自动控制器的输出 $u(0^{+})$ 相对于切换前瞬间的手动指令 $u(0^{-})$ 不得引入跳变。请从第一性原理出发，计算对于此控制器结构在 $t=0$ 时发生无扰动切换的条件，并利用这些条件设计积分器状态的初始化值 $\\xi(0^{+})$，以使积分器的贡献 $I(0^{+})$ 能够确保控制信号的连续性。\n\n假设在 $t=0$ 时，有以下由数字孪生观测到的量和控制器参数：\n- $u(0^{-}) = 3.1$ 伏特，\n- $r(0) = 2.0$ （与 $y$ 的单位相同），\n- $y(0) = 1.7$ （与 $r$ 的单位相同），\n- $\\dot{e}(0) = -0.4$ （与 $e$ 的单位/秒相同），\n- $K_{p} = 3.0$，\n- $K_{i} = 2.0$，\n- $K_{d} = 0.5$，\n- $T_{f} = 0.05$ 秒。\n\n假设微分滤波器状态的初始化是为了避免微分项贡献的跳变，其方法是选择与滤波器模型和 $t=0$ 时的数字孪生估计值一致的 $v(0^{+})$。使用这些数据，确定实现无扰动切换所需的积分器贡献 $I(0^{+})$ 的数值。将最终答案四舍五入到四位有效数字，并以伏特为单位表示。",
            "solution": "该问题提法清晰，科学依据充分，并提供了确定PID控制器积分项初始条件以确保从手动到自动模式无扰动切换所需的所有信息。我们将开始进行解答。\n\n无扰动切换的基本原理是确保在从手动控制切换到自动控制的瞬间，控制信号 $u(t)$ 的连续性。设 $t=0$ 为切换时间。因此，无扰动切换的条件是：\n$$\nu(0^{+}) = u(0^{-})\n$$\n其中 $u(0^{-})$ 是切换前瞬间手动模式下的控制信号值，而 $u(0^{+})$ 是切换后瞬间自动PID控制器生成的控制信号初始值。\n\n问题给出了手动控制信号的值为 $u(0^{-}) = 3.1$ 伏特。\n\nPID控制器以并联形式定义为：\n$$\nu(t) = K_{p}\\,e(t) + I(t) + K_{d}\\,v(t)\n$$\n在 $t=0^{+}$ 瞬间，自动控制器的输出是：\n$$\nu(0^{+}) = K_{p}\\,e(0^{+}) + I(0^{+}) + K_{d}\\,v(0^{+})\n$$\n为实现无扰动切换，我们必须满足：\n$$\nu(0^{-}) = K_{p}\\,e(0^{+}) + I(0^{+}) + K_{d}\\,v(0^{+})\n$$\n我们的目标是确定满足此方程所需的积分器贡献值 $I(0^{+})$。这需要我们确定在 $t=0^{+}$ 时其他各项的值。\n\n首先，我们确定比例项的贡献。跟踪误差为 $e(t) = r(t) - y(t)$。假设被控对象输出 $y(t)$ 和设定值 $r(t)$ 在切换瞬间是时间的连续函数（这是物理系统和非脉冲性设定值变化的通常假设），我们有 $e(0^{+}) = e(0)$。给出了在 $t=0$ 时的值：$r(0) = 2.0$ 和 $y(0) = 1.7$。\n因此，切换时的误差为：\n$$\ne(0) = r(0) - y(0) = 2.0 - 1.7 = 0.3\n$$\n比例项的贡献是 $K_{p}\\,e(0)$。\n\n其次，我们确定微分项的贡献。误差的滤波后导数 $v(t)$ 由微分方程 $T_{f}\\,\\dot{v}(t) + v(t) = \\dot{e}(t)$ 控制。问题指出，微分滤波器状态 $v(0^{+})$ 的初始化要“与滤波器模型和 $t=0$ 时的数字孪生估计值一致”。这是一个标准程序，用以避免在初始化时由微分项引起的人为“突跳”（kick）。实现平滑初始化的最直接和最常用的方法是将滤波器的状态设置为其要滤波的信号的当前（未滤波）值。在这种情况下，滤波器的输入是 $\\dot{e}(t)$，数字孪生提供的估计值为 $\\dot{e}(0) = -0.4$。因此，我们将滤波器状态初始化为：\n$$\nv(0^{+}) = \\dot{e}(0) = -0.4\n$$\n这个初始化意味着在 $t=0$ 时，滤波器方程变为 $T_{f}\\,\\dot{v}(0^{+}) + \\dot{e}(0) = \\dot{e}(0)$，从而得到 $T_{f}\\,\\dot{v}(0^{+}) = 0$。由于 $T_{f} = 0.05 \\neq 0$，这意味着 $\\dot{v}(0^{+}) = 0$。这对应于微分滤波器的最优平滑启动，因为其变化率初始为零。\n\n现在我们可以将已知量代入无扰动切换条件中：\n$$\nu(0^{-}) = K_{p}\\,e(0) + I(0^{+}) + K_{d}\\,v(0^{+})\n$$\n我们可以重新整理这个方程来求解所需的积分器贡献 $I(0^{+})$：\n$$\nI(0^{+}) = u(0^{-}) - K_{p}\\,e(0) - K_{d}\\,v(0^{+})\n$$\n代入 $e(0) = r(0) - y(0)$ 和 $v(0^{+}) = \\dot{e}(0)$，我们得到通用的设计方程：\n$$\nI(0^{+}) = u(0^{-}) - K_{p}\\,(r(0) - y(0)) - K_{d}\\,\\dot{e}(0)\n$$\n我们现在代入给定的数值：\n- $u(0^{-}) = 3.1$\n- $K_{p} = 3.0$\n- $r(0) = 2.0$\n- $y(0) = 1.7$\n- $K_{d} = 0.5$\n- $\\dot{e}(0) = -0.4$\n\n计算过程如下：\n$$\nI(0^{+}) = 3.1 - (3.0) \\times (2.0 - 1.7) - (0.5) \\times (-0.4)\n$$\n$$\nI(0^{+}) = 3.1 - (3.0) \\times (0.3) - (-0.2)\n$$\n$$\nI(0^{+}) = 3.1 - 0.9 + 0.2\n$$\n$$\nI(0^{+}) = 2.2 + 0.2\n$$\n$$\nI(0^{+}) = 2.4\n$$\n问题还要求设计积分器状态的初始化值 $\\xi(0^{+})$。其关系由 $I(t) = K_{i}\\,\\xi(t)$ 给出。因此，在 $t=0^{+}$ 时：\n$$\n\\xi(0^{+}) = \\frac{I(0^{+})}{K_{i}}\n$$\n使用给定值 $K_{i} = 2.0$：\n$$\n\\xi(0^{+}) = \\frac{2.4}{2.0} = 1.2\n$$\n这就完成了问题的设计部分。所要求的最终数值答案是 $I(0^{+})$ 的值，以伏特表示并四舍五入到四位有效数字。\n\n计算出的值为 $I(0^{+}) = 2.4$。为了用四位有效数字表示，我们将其写为 $2.400$。",
            "answer": "$$\\boxed{2.400}$$"
        },
        {
            "introduction": "许多现实世界的物理系统本质上是非线性的，这意味着一个固定增益的 PID 控制器可能无法在所有工作条件下都表现出色。增益调度（Gain scheduling）是一种根据系统当前工作点来调整控制器参数的有效方法。这项综合性练习  将引导您为数字孪生中的非线性对象设计一个增益调度的 PID 控制器，并使用结构化奇异值（$\\mu$-analysis）这一现代鲁棒控制工具来验证其稳定性，从而将经典的 PID 技术与先进的控制理论联系起来。",
            "id": "4237268",
            "problem": "考虑一个表现出平滑饱和特性的单输入单输出非线性设备，它被用作数字孪生（一个用于分析和控制设计的虚拟副本）的物理组件。该设备的动态特性由以下微分方程给出\n$$\\dot{x}(t) = -a\\,x(t) + b\\,\\mathrm{sat}(u(t)), \\quad y(t) = x(t),$$\n其中 $a \\gt 0$，$b \\gt 0$，饱和特性由一个平滑函数建模\n$$\\mathrm{sat}(u) = u_{\\max} \\tanh\\!\\left(\\frac{u}{u_{\\max}}\\right),$$\n其中 $u_{\\max} \\gt 0$。\n\n在一个由恒定输入 $u^\\star$ 定义的工作点，饱和非线性的局部斜率是 $\\mathrm{sat}(u)$ 对 $u$ 的导数在 $u^\\star$ 处的值，即\n$$\\alpha = \\left.\\frac{d}{du}\\,\\mathrm{sat}(u)\\right|_{u=u^\\star} = \\mathrm{sech}^2\\!\\left(\\frac{u^\\star}{u_{\\max}}\\right),$$\n其中 $\\mathrm{sech}(z) = 1/\\cosh(z)$。在每个工作点，该设备可以线性化为传递函数\n$$G(s;\\alpha) = \\frac{b\\,\\alpha}{s + a}.$$\n\n设计一个增益调度的比例-积分-微分（PID）控制器\n$$C(s;\\alpha) = K_p(\\alpha) + \\frac{K_i(\\alpha)}{s} + K_d(\\alpha)\\,s,$$\n通过推导一种方法，对于每个由 $\\alpha$ 表征的工作点，分配增益 $K_p(\\alpha)$、$K_i(\\alpha)$ 和 $K_d(\\alpha)$，使得闭环特征多项式与具有指定阻尼比 $0 \\lt \\zeta \\lt 1$ 和自然频率调度 $\\omega_n(\\alpha)$ 的期望二阶形式相匹配。该方法必须从第一性原理出发，不借助任何预先推导的整定规则捷径。您必须从闭环特征方程开始，并将归一化系数与目标二阶多项式相等，以推导出 $K_p(\\alpha)$ 和 $K_i(\\alpha)$（用 $\\zeta$、$\\omega_n(\\alpha)$、$a$、$b$、$\\alpha$ 和一个选定的常数 $K_d(\\alpha) = K_d$ 表示，即在整个调度中使用恒定的微分增益）。\n\n为了验证鲁棒性，将设备参数变化建模为两个独立的乘性输入不确定性：一个用于极点位置参数 $a$，另一个用于饱和斜率失配 $\\alpha$。也就是说，引入两个标量不确定性模块 $\\delta_a$ 和 $\\delta_\\alpha$，它们的大小分别受各自的不确定性半径 $\\epsilon_a$ 和 $\\epsilon_\\alpha$ 的限制，并让它们都作为具有恒定权重的乘性输入不确定性\n$$W_a(j\\omega) = \\epsilon_a, \\quad W_\\alpha(j\\omega) = \\epsilon_\\alpha.$$\n在这种结构化不确定性下，基于结构化奇异值（也称为 $\\mu$ 分析）的鲁棒稳定性条件简化为检查是否\n$$\\sup_{\\omega \\in \\mathbb{R}_{\\ge 0}}\\,\\mu\\!\\left(M(j\\omega)\\right) \\lt 1,$$\n其中互联矩阵是对角矩阵\n$$M(j\\omega) = \\begin{bmatrix} W_a(j\\omega)\\,T(j\\omega)  0 \\\\ 0  W_\\alpha(j\\omega)\\,T(j\\omega) \\end{bmatrix},$$\n并且互补灵敏度函数为\n$$T(j\\omega;\\alpha) = \\frac{L(j\\omega;\\alpha)}{1 + L(j\\omega;\\alpha)}, \\quad L(j\\omega;\\alpha) = C(j\\omega;\\alpha)\\,G(j\\omega;\\alpha).$$\n您必须计算在所有频率和所有给定工作点上的最坏情况 $\\mu$ 值。\n\n您的程序必须：\n- 通过按规定推导并应用闭环系数匹配方法来构建增益调度。\n- 对于每个工作点，在跨越 $10^{-3}$ 到 $10^{2}$ 弧度/秒的对数间隔频率网格上计算 $T(j\\omega;\\alpha)$。\n- 评估上面定义的对角矩阵 $M(j\\omega)$ 的结构化奇异值，该值可简化为\n$$\\mu\\!\\left(M(j\\omega)\\right) = \\max\\!\\left(\\left|W_a(j\\omega)\\,T(j\\omega)\\right|,\\;\\left|W_\\alpha(j\\omega)\\,T(j\\omega)\\right|\\right).$$\n- 对于每个测试用例，报告在频率网格和所有指定工作点上的最大 $\\mu$ 值。\n\n使用以下三个测试用例，它们共同构成了测试套件：\n1. 正常情况用例，具有中等不确定性和适度的微分作用：\n   - $a = 1.0$, $b = 1.0$, $u_{\\max} = 1.0$,\n   - 工作点 $u^\\star \\in \\{0.2,\\,0.6,\\,1.0\\}$,\n   - 阻尼比 $\\zeta = 0.7$,\n   - 自然频率调度 $\\omega_n(\\alpha) = \\omega_0 \\sqrt{\\alpha}$，其中 $\\omega_0 = 3.0$ 弧度/秒,\n   - 恒定微分增益 $K_d = 0.05$,\n   - 不确定性半径 $\\epsilon_a = 0.2$, $\\epsilon_\\alpha = 0.1$。\n2. 边界情况用例，具有大的不确定性：\n   - 与用例1相同的 $a$、$b$、$u_{\\max}$、工作点、$\\zeta$ 和 $\\omega_n(\\alpha)$,\n   - 恒定微分增益 $K_d = 0.05$,\n   - 不确定性半径 $\\epsilon_a = 1.5$, $\\epsilon_\\alpha = 1.5$。\n3. 边缘情况用例，具有更强的微分作用：\n   - 与用例1相同的 $a$、$b$、$u_{\\max}$、工作点、$\\zeta$ 和 $\\omega_n(\\alpha)$,\n   - 恒定微分增益 $K_d = 0.30$,\n   - 不确定性半径 $\\epsilon_a = 0.2$, $\\epsilon_\\alpha = 0.1$。\n\n角度和频率单位必须是弧度。最大 $\\mu$ 值必须报告为四舍五入到三位小数的十进制数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”），其中每个“result”是相应测试用例的最大 $\\mu$ 值，四舍五入到三位小数。",
            "solution": "所提出的问题是有效的，它要求系统地设计一个增益调度的比例-积分-微分（PID）控制器，然后使用结构化奇异值（$\\mu$）进行鲁棒稳定性分析。解决方案从第一性原理出发，首先推导控制器增益调度规律，然后进行鲁棒性度量的计算评估。\n\n### 第一部分：控制器增益调度规律的推导\n\n分析始于线性化的设备模型和 PID 控制器结构。设备在工作点 $u^\\star$ 附近的局部动态特性由以下一阶传递函数描述：\n$$G(s;\\alpha) = \\frac{b\\,\\alpha}{s + a}$$\n其中参数 $\\alpha = \\mathrm{sech}^2(u^\\star/u_{\\max})$ 量化了饱和函数在工作点的斜率。\n\nPID 控制器在拉普拉斯域中定义为：\n$$C(s;\\alpha) = K_p(\\alpha) + \\frac{K_i(\\alpha)}{s} + K_d s$$\n对于此设计，微分增益 $K_d(\\alpha)$ 是一个指定的常数 $K_d$。比例增益 $K_p(\\alpha)$ 和积分增益 $K_i(\\alpha)$ 是工作点 $\\alpha$ 的函数，我们必须确定它们。\n\n闭环系统的稳定性和性能由其特征方程的根决定，即 $1 + L(s;\\alpha) = 0$，其中 $L(s;\\alpha) = C(s;\\alpha)G(s;\\alpha)$ 是开环传递函数。\n$$L(s;\\alpha) = \\left( \\frac{K_d s^2 + K_p(\\alpha) s + K_i(\\alpha)}{s} \\right) \\left( \\frac{b\\,\\alpha}{s + a} \\right) = \\frac{b\\,\\alpha(K_d s^2 + K_p(\\alpha) s + K_i(\\alpha))}{s(s+a)}$$\n将此代入特征方程可得：\n$$1 + \\frac{b\\,\\alpha(K_d s^2 + K_p(\\alpha) s + K_i(\\alpha))}{s(s+a)} = 0$$\n为了消去分母，我们乘以 $s(s+a)$：\n$$s(s+a) + b\\,\\alpha(K_d s^2 + K_p(\\alpha) s + K_i(\\alpha)) = 0$$\n展开并按 $s$ 的幂次合并项，得到闭环特征多项式 $P_{cl}(s)$：\n$$s^2 + as + b\\,\\alpha K_d s^2 + b\\,\\alpha K_p(\\alpha) s + b\\,\\alpha K_i(\\alpha) = 0$$\n$$(1 + b\\,\\alpha K_d)s^2 + (a + b\\,\\alpha K_p(\\alpha))s + (b\\,\\alpha K_i(\\alpha)) = 0$$\n设计目标是使闭环响应与具有以下特征多项式的规范二阶系统的响应相匹配：\n$$P_{des}(s) = s^2 + 2\\zeta \\omega_n(\\alpha) s + \\omega_n^2(\\alpha)$$\n其中 $\\zeta$ 是期望的阻尼比，$\\omega_n(\\alpha)$ 是自然频率调度。\n\n为了使两个多项式相等，我们必须首先将 $P_{cl}(s)$ 通过除以其首项系数 $(1 + b\\,\\alpha K_d)$ 来进行归一化：\n$$s^2 + \\left(\\frac{a + b\\,\\alpha K_p(\\alpha)}{1 + b\\,\\alpha K_d}\\right)s + \\left(\\frac{b\\,\\alpha K_i(\\alpha)}{1 + b\\,\\alpha K_d}\\right) = 0$$\n通过将这个归一化多项式的系数与 $P_{des}(s)$ 的系数相等，我们推导出调度增益的表达式。\n\n令 $s^1$ 项的系数相等：\n$$\\frac{a + b\\,\\alpha K_p(\\alpha)}{1 + b\\,\\alpha K_d} = 2\\zeta \\omega_n(\\alpha)$$\n$$a + b\\,\\alpha K_p(\\alpha) = 2\\zeta \\omega_n(\\alpha) (1 + b\\,\\alpha K_d)$$\n$$b\\,\\alpha K_p(\\alpha) = 2\\zeta \\omega_n(\\alpha) (1 + b\\,\\alpha K_d) - a$$\n这得到了比例增益的增益调度规律：\n$$K_p(\\alpha) = \\frac{2\\zeta \\omega_n(\\alpha) (1 + b\\,\\alpha K_d) - a}{b\\,\\alpha}$$\n令 $s^0$ 项（常数部分）的系数相等：\n$$\\frac{b\\,\\alpha K_i(\\alpha)}{1 + b\\,\\alpha K_d} = \\omega_n^2(\\alpha)$$\n$$b\\,\\alpha K_i(\\alpha) = \\omega_n^2(\\alpha) (1 + b\\,\\alpha K_d)$$\n这得到了积分增益的增益调度规律：\n$$K_i(\\alpha) = \\frac{\\omega_n^2(\\alpha) (1 + b\\,\\alpha K_d)}{b\\,\\alpha}$$\n这两个方程为计算任何工作点 $\\alpha$ 的控制器增益提供了必要的公式。\n\n### 第二部分：通过 $\\mu$ 分析进行鲁棒稳定性分析\n\n所设计控制器对参数不确定性的鲁棒性是使用结构化奇异值 $\\mu$ 来评估的。不确定性由两个独立的乘性模块 $\\delta_a$ 和 $\\delta_\\alpha$ 建模，其幅值边界为 $\\epsilon_a$ 和 $\\epsilon_\\alpha$。用于 $\\mu$ 分析的互联矩阵给出如下：\n$$M(j\\omega) = \\begin{bmatrix} W_a(j\\omega)\\,T(j\\omega;\\alpha)  0 \\\\ 0  W_\\alpha(j\\omega)\\,T(j\\omega;\\alpha) \\end{bmatrix}$$\n其中 $T(j\\omega;\\alpha)$ 是互补灵敏度函数，而 $W_a(j\\omega) = \\epsilon_a$ 和 $W_\\alpha(j\\omega) = \\epsilon_\\alpha$ 是恒定的不确定性权重。互补灵敏度函数定义为：\n$$T(j\\omega;\\alpha) = \\frac{L(j\\omega;\\alpha)}{1 + L(j\\omega;\\alpha)}$$\n对于像 $M(j\\omega)$ 这样的块对角矩阵，结构化奇异值 $\\mu$ 就是其对角元素幅值的最大值。\n$$\\mu(M(j\\omega)) = \\max\\left(\\left|W_a(j\\omega) T(j\\omega;\\alpha)\\right|, \\left|W_\\alpha(j\\omega) T(j\\omega;\\alpha)\\right|\\right)$$\n代入恒定权重 $W_a(j\\omega) = \\epsilon_a$ 和 $W_\\alpha(j\\omega) = \\epsilon_\\alpha$：\n$$\\mu(M(j\\omega)) = \\max\\left(\\epsilon_a \\left|T(j\\omega;\\alpha)\\right|, \\epsilon_\\alpha \\left|T(j\\omega;\\alpha)\\right|\\right) = \\left|T(j\\omega;\\alpha)\\right| \\max(\\epsilon_a, \\epsilon_\\alpha)$$\n如果 $\\mu$ 在所有频率和所有工作点上的峰值小于 $1$，则满足鲁棒稳定性条件。任务是找到这个峰值 $\\sup_{\\alpha, \\omega} \\mu(M(j\\omega))$。\n\n### 第三部分：计算实现\n\n对于提供的每个测试用例，实施以下计算过程：\n1. 定义特定案例的参数（$a$、$b$、$u_{\\max}$、$u^\\star$ 值、$\\zeta$、$\\omega_0$、$K_d$、$\\epsilon_a$、$\\epsilon_\\alpha$）。\n2. 创建一个对数频率网格 $\\omega$，范围从 $10^{-3}$ 到 $10^{2}$ 弧度/秒。\n3. 将一个用于存储峰值 $\\mu$ 的变量 $\\mu_{\\text{peak}}$ 初始化为 $0$。\n4. 算法遍历每个指定的工作点 $u^\\star$：\n   a. 计算饱和增益 $\\alpha = \\mathrm{sech}^2(u^\\star/u_{\\max})$。\n   b. 计算调度的自然频率 $\\omega_n(\\alpha) = \\omega_0\\sqrt{\\alpha}$。\n   c. 使用推导出的公式计算控制器增益 $K_p(\\alpha)$ 和 $K_i(\\alpha)$。\n   d. 在整个频率网格上将传递函数 $G(j\\omega;\\alpha)$、$C(j\\omega;\\alpha)$、$L(j\\omega;\\alpha)$ 和 $T(j\\omega;\\alpha)$ 作为复数值数组进行评估。\n   e. 计算每个频率的 $\\mu$ 值：$\\mu(M(j\\omega)) = |T(j\\omega;\\alpha)| \\max(\\epsilon_a, \\epsilon_\\alpha)$。\n   f. 将当前工作点找到的峰值 $\\mu$ 与运行中的最大值 $\\mu_{\\text{peak}}$ 进行比较，如果找到新的最大值则更新。\n5. 在评估完所有工作点后，记录该测试用例的最终 $\\mu_{\\text{peak}}$ 值，四舍五入到三位小数。对所有三个测试用例重复此整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gain-scheduled PID design and robustness analysis problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy path\n        {\n            \"a\": 1.0, \"b\": 1.0, \"u_max\": 1.0,\n            \"u_star_values\": [0.2, 0.6, 1.0],\n            \"zeta\": 0.7, \"omega_0\": 3.0, \"K_d\": 0.05,\n            \"epsilon_a\": 0.2, \"epsilon_alpha\": 0.1,\n        },\n        # Case 2: Large uncertainties\n        {\n            \"a\": 1.0, \"b\": 1.0, \"u_max\": 1.0,\n            \"u_star_values\": [0.2, 0.6, 1.0],\n            \"zeta\": 0.7, \"omega_0\": 3.0, \"K_d\": 0.05,\n            \"epsilon_a\": 1.5, \"epsilon_alpha\": 1.5,\n        },\n        # Case 3: Stronger derivative action\n        {\n            \"a\": 1.0, \"b\": 1.0, \"u_max\": 1.0,\n            \"u_star_values\": [0.2, 0.6, 1.0],\n            \"zeta\": 0.7, \"omega_0\": 3.0, \"K_d\": 0.30,\n            \"epsilon_a\": 0.2, \"epsilon_alpha\": 0.1,\n        },\n    ]\n\n    results = []\n\n    # Define a high-resolution logarithmic frequency grid\n    omega_grid = np.logspace(-3, 2, 10000)\n    s = 1j * omega_grid\n\n    for case in test_cases:\n        a = case[\"a\"]\n        b = case[\"b\"]\n        u_max = case[\"u_max\"]\n        u_star_values = case[\"u_star_values\"]\n        zeta = case[\"zeta\"]\n        omega_0 = case[\"omega_0\"]\n        K_d = case[\"K_d\"]\n        epsilon_a = case[\"epsilon_a\"]\n        epsilon_alpha = case[\"epsilon_alpha\"]\n\n        max_mu_for_case = 0.0\n\n        for u_star in u_star_values:\n            # Step 1: Calculate operating point dependent parameter alpha\n            # alpha = sech^2(u_star / u_max)\n            alpha = (1.0 / np.cosh(u_star / u_max))**2\n\n            # Step 2: Calculate scheduled natural frequency\n            omega_n = omega_0 * np.sqrt(alpha)\n\n            # Step 3: Derive controller gains K_p and K_i based on pole placement\n            # K_i(alpha) = (omega_n(alpha)^2 * (1 + b*alpha*K_d)) / (b*alpha)\n            # K_p(alpha) = (2*zeta*omega_n(alpha)*(1 + b*alpha*K_d) - a) / (b*alpha)\n            # Both terms have a common denominator and a common factor in the numerator\n            common_numerator_factor = 1.0 + b * alpha * K_d\n            common_denominator = b * alpha\n\n            K_i = (omega_n**2 * common_numerator_factor) / common_denominator\n            K_p = (2 * zeta * omega_n * common_numerator_factor - a) / common_denominator\n\n            # Step 4: Evaluate transfer functions over the frequency grid\n            # Plant: G(s) = b*alpha / (s + a)\n            G_s = (b * alpha) / (s + a)\n            \n            # Controller: C(s) = K_p + K_i/s + K_d*s\n            C_s = K_p + K_i / s + K_d * s\n\n            # Loop transfer function: L(s) = C(s)G(s)\n            L_s = C_s * G_s\n\n            # Complementary sensitivity function: T(s) = L(s) / (1 + L(s))\n            T_s = L_s / (1.0 + L_s)\n\n            # Step 5: Compute the structured singular value mu\n            # mu(M(jw)) = |T(jw)| * max(epsilon_a, epsilon_alpha)\n            mu_values = np.abs(T_s) * max(epsilon_a, epsilon_alpha)\n            \n            # Find the peak mu for the current operating point\n            peak_mu_for_op_point = np.max(mu_values)\n\n            # Update the worst-case mu for the entire test case\n            if peak_mu_for_op_point  max_mu_for_case:\n                max_mu_for_case = peak_mu_for_op_point\n        \n        results.append(f\"{max_mu_for_case:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}