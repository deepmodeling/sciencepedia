{
    "hands_on_practices": [
        {
            "introduction": "在将连续的物理信号转化为数字孪生可以处理的离散数据时，采样是第一步。然而，这个过程并非没有代价，如果采样率不足，高频信号会“伪装”成低频信号，这种现象称为混叠。这个练习将通过一个具体的案例，从第一性原理出发，帮助你理解和计算混叠效应，这是正确解读传感器数据和设计数据采集系统的基础。",
            "id": "4245334",
            "problem": "一个信息物理系统 (CPS) 中旋转机械的数字孪生接收按时间均匀采样的传感器数据。考虑一个理想的点采样器，它对形式为 $x(t) = A \\cos(2 \\pi f t + \\phi)$ 的连续时间正弦振动信号 $x(t)$ 进行采样，其中 $A$ 是实数振幅，$f$ 是连续时间频率，$\\phi$ 是相位。该采样器以采样频率 $f_{s}$ 工作，采样周期为 $T_{s} = 1/f_{s}$，产生离散时间序列 $x[n] = x(n T_{s})$。\n\n假设传感链中没有抗混叠预滤波器，并且数字孪生纯粹从采样序列中估计频谱内容。对于 $f = 950\\,\\mathrm{Hz}$ 的振动和 $f_{s} = 1000\\,\\mathrm{Hz}$ 的采样频率，请使用采样基本原理和离散时间正弦波的周期性，确定数字孪生将在采样序列中观察到的唯一基带频率（以 $\\mathrm{Hz}$ 为单位）。\n\n请用 $\\mathrm{Hz}$ 表示您的最终答案。无需四舍五入。",
            "solution": "出发点是对连续时间正弦波进行理想的均匀采样。给定 $x(t) = A \\cos(2 \\pi f t + \\phi)$ 和采样周期 $T_{s} = 1/f_{s}$，采样后的序列为\n$$\nx[n] = x(n T_{s}) = A \\cos\\!\\big(2 \\pi f \\, n T_{s} + \\phi\\big) = A \\cos\\!\\big(2 \\pi n \\tfrac{f}{f_{s}} + \\phi\\big).\n$$\n定义离散时间角频率 $\\omega$（单位为弧度/采样点）为\n$$\n\\omega = 2 \\pi \\tfrac{f}{f_{s}}.\n$$\n离散时间正弦波的一个基本性质是，对于任何整数 $k$，$\\cos(\\omega n + \\phi)$ 与 $\\cos((\\omega - 2 \\pi k) n + \\phi)$ 是无法区分的，这是由于复指数 $\\exp(\\mathrm{i}\\omega n)$ 和余弦函数的 $2 \\pi$ 周期性。因此，有效的离散时间频率是以 $2 \\pi$ 为模确定的。\n\n为了在离散时间频谱的标准基带中表示观察到的频率，我们选择一个等效频率 $\\omega'$，使得\n$$\n\\omega' = \\omega - 2 \\pi k,\n$$\n其中选择整数 $k$ 以使 $\\omega'$ 的幅度 $|\\omega'|$ 落在 $[0, \\pi]$ 区间内，这代表了与单边奈奎斯特区间一致的唯一基带频率幅度。采样序列所表现出的相应连续时间频率（即混叠频率）是\n$$\nf_{\\mathrm{alias}} = \\tfrac{f_{s}}{2 \\pi} |\\omega'| = \\left| \\tfrac{f_{s}}{2 \\pi} \\left(\\omega - 2 \\pi k \\right) \\right| = \\left| f - k f_{s} \\right|.\n$$\n该表达式是通过代入 $\\omega = 2 \\pi f/f_{s}$ 并利用采样下连续时间频率和离散时间频率之间的线性比例关系直接得出的。\n\n我们选择 $k$ 以最小化 $|f - k f_{s}|$ 并确保结果落在基带 $[0, f_{s}/2]$ 内，这对应于采样序列中唯一可观测的正弦频率幅度。对于 $f = 950\\,\\mathrm{Hz}$ 和 $f_{s} = 1000\\,\\mathrm{Hz}$，我们有\n$$\n\\omega = 2 \\pi \\tfrac{950}{1000} = 1.9 \\pi.\n$$\n选择 $k = 1$ 可得\n$$\n\\omega' = \\omega - 2 \\pi k = 1.9 \\pi - 2 \\pi = -0.1 \\pi,\n$$\n其幅度为 $|\\omega'| = 0.1 \\pi \\in [0, \\pi]$。转换回赫兹单位，\n$$\nf_{\\mathrm{alias}} = \\tfrac{f_{s}}{2 \\pi} |\\omega'| = \\tfrac{1000}{2 \\pi} \\cdot 0.1 \\pi = 50.\n$$\n等效地，使用 $f_{\\mathrm{alias}} = |f - k f_{s}|$ 并取 $k=1$，可得\n$$\nf_{\\mathrm{alias}} = |950 - 1 \\cdot 1000| = 50.\n$$\n因此，在采样序列中观察到的混叠频率为 $50\\,\\mathrm{Hz}$。",
            "answer": "$$\\boxed{50}$$"
        },
        {
            "introduction": "继时间上的采样之后，信号的幅度也必须被离散化，即量化。这个过程将无限精度的模拟值映射到有限的数字代码，不可避免地引入了量化误差，这是数字传感系统中的一个基本噪声来源。本练习旨在推导理想均匀量化器所产生的误差方差，它将模数转换器（ADC）的物理参数（如位数和电压范围）与传感精度的统计极限直接联系起来。",
            "id": "4245359",
            "problem": "一个信息物理系统实现了一个数字孪生（DT），该数字孪生必须根据经由模数转换器（ADC）转换的传感器读数来估计物理状态。考虑一个理想的、中置步进、均匀量化器来模拟该ADC，其峰峰值满量程范围表示为 $V_{\\mathrm{FS}}$，分辨率为 $N$ 位。该量化器将区间 $\\left[-\\frac{V_{\\mathrm{FS}}}{2}, \\frac{V_{\\mathrm{FS}}}{2}\\right)$ 划分为 $2^{N}$ 个宽度相等的量化档，每个量化档的大小为 $\\Delta$，其中 $\\Delta = \\frac{V_{\\mathrm{FS}}}{2^{N}}$。设量化映射为 $Q(x)$，量化误差定义为 $e = Q(x) - x$。假设该DT在非过载状态下运行（$x \\in \\left[-\\frac{V_{\\mathrm{FS}}}{2}, \\frac{V_{\\mathrm{FS}}}{2}\\right)$），并且诸如足够丰富的输入统计特性或抖动等条件确保误差 $e$ 与 $x$ 统计独立，并在 $\\left[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}\\right]$ 上均匀分布。\n\n仅从均匀概率密度函数的定义以及方差作为对概率密度函数的期望的定义出发，推导量化误差方差 $\\sigma_{q}^{2}$ 关于 $V_{\\mathrm{FS}}$ 和 $N$ 的闭式解析表达式。最终答案以平方伏特（$\\mathrm{V}^{2}$）为单位表示。无需进行数值四舍五入；请提供精确的符号表达式。",
            "solution": "任务是推导均匀量化器的量化误差方差 $\\sigma_q^2$。已知量化误差 $e$ 是一个在区间 $\\left[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}\\right]$ 上均匀分布的随机变量。\n\n首先，我们定义均匀分布随机变量 $e$ 的概率密度函数（PDF）。对于区间 $[a, b]$ 上的均匀分布，其PDF（表示为 $p(e)$）由下式给出：\n$$p(e) = \\begin{cases} \\frac{1}{b-a}  \\text{for } a \\le e \\le b \\\\ 0  \\text{otherwise} \\end{cases}$$\n在本题中，区间为 $\\left[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}\\right]$，因此 $a = -\\frac{\\Delta}{2}$，$b = \\frac{\\Delta}{2}$。区间宽度为 $b-a = \\frac{\\Delta}{2} - \\left(-\\frac{\\Delta}{2}\\right) = \\Delta$。\n因此，量化误差 $e$ 的PDF为：\n$$p(e) = \\begin{cases} \\frac{1}{\\Delta}  \\text{for } -\\frac{\\Delta}{2} \\le e \\le \\frac{\\Delta}{2} \\\\ 0  \\text{otherwise} \\end{cases}$$\n\n接下来，我们使用方差的定义。随机变量 $e$ 的方差（表示为 $\\sigma_q^2$）是其与均值 $\\mu_e$ 之差的平方的期望值。\n$$\\sigma_q^2 = E[(e - \\mu_e)^2] = \\int_{-\\infty}^{\\infty} (e - \\mu_e)^2 p(e) \\, de$$\n\n我们必须首先计算误差的均值（期望值）$\\mu_e$：\n$$\\mu_e = E[e] = \\int_{-\\infty}^{\\infty} e \\cdot p(e) \\, de$$\n代入PDF $p(e)$，积分仅在区间 $\\left[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}\\right]$ 上非零：\n$$\\mu_e = \\int_{-\\Delta/2}^{\\Delta/2} e \\cdot \\frac{1}{\\Delta} \\, de = \\frac{1}{\\Delta} \\int_{-\\Delta/2}^{\\Delta/2} e \\, de$$\n被积函数 $e$ 是一个奇函数，积分区间是关于0对称的。因此，该积分的值为0。\n$$\\mu_e = \\frac{1}{\\Delta} \\left[ \\frac{e^2}{2} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{\\Delta} \\left( \\frac{(\\Delta/2)^2}{2} - \\frac{(-\\Delta/2)^2}{2} \\right) = \\frac{1}{\\Delta} \\left( \\frac{\\Delta^2/4}{2} - \\frac{\\Delta^2/4}{2} \\right) = 0$$\n所以，平均量化误差为 $\\mu_e = 0$。\n\n当均值为零时，方差公式简化为随机变量平方的均值：\n$$\\sigma_q^2 = E[(e - 0)^2] = E[e^2] = \\int_{-\\infty}^{\\infty} e^2 p(e) \\, de$$\n再次，我们在 $p(e)$ 的非零范围内进行积分：\n$$\\sigma_q^2 = \\int_{-\\Delta/2}^{\\Delta/2} e^2 \\cdot \\frac{1}{\\Delta} \\, de = \\frac{1}{\\Delta} \\int_{-\\Delta/2}^{\\Delta/2} e^2 \\, de$$\n我们计算该定积分：\n$$\\sigma_q^2 = \\frac{1}{\\Delta} \\left[ \\frac{e^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2}$$\n代入积分上下限：\n$$\\sigma_q^2 = \\frac{1}{\\Delta} \\left( \\frac{(\\Delta/2)^3}{3} - \\frac{(-\\Delta/2)^3}{3} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} - \\left(-\\frac{\\Delta^3}{8}\\right) \\right)$$\n$$\\sigma_q^2 = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( 2 \\cdot \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{4} \\right)$$\n化简该表达式，我们得到以量化步长 $\\Delta$ 表示的方差：\n$$\\sigma_q^2 = \\frac{\\Delta^2}{12}$$\n\n最后，题目要求用满量程范围 $V_{\\mathrm{FS}}$ 和分辨率位数 $N$ 来表示方差。我们已知量化步长的关系式：\n$$\\Delta = \\frac{V_{\\mathrm{FS}}}{2^N}$$\n将 $\\Delta$ 的这个表达式代入我们的方差结果中：\n$$\\sigma_q^2 = \\frac{1}{12} \\left( \\frac{V_{\\mathrm{FS}}}{2^N} \\right)^2 = \\frac{V_{\\mathrm{FS}}^2}{12 \\cdot (2^N)^2}$$\n使用指数性质 $(a^b)^c = a^{bc}$，我们有 $(2^N)^2 = 2^{2N}$。量化误差方差的最终表达式为：\n$$\\sigma_q^2 = \\frac{V_{\\mathrm{FS}}^2}{12 \\cdot 2^{2N}}$$\n这就是以平方伏特（$\\mathrm{V}^2$）为单位的量化误差方差的闭式解析表达式。",
            "answer": "$$\\boxed{\\frac{V_{\\mathrm{FS}}^{2}}{12 \\cdot 2^{2N}}}$$"
        },
        {
            "introduction": "理解了单个传感器的基本限制（如采样伪影和量化噪声）后，我们可以转向更高级的系统级设计问题。在构建信息物理系统或数字孪生时，我们常常需要在有限的预算内决定在哪里部署传感器。这个高级练习将引导你解决一个传感器优化布局问题，目标是在预算约束下最大化我们从整个系统中获取的信息量，这正是构建高保真数字孪生所面临的核心挑战之一。",
            "id": "4245364",
            "problem": "信息物理系统中的空间场数字孪生必须从带噪声的传感器测量中估计一个低维参数向量。您将实现一个程序，在几种指定场景下，计算在预算约束下放置不同传感器时，后验精度矩阵可实现的最大对数行列式值。传感器选择的目标是最大化 D-最优性准则，该准则定义为后验精度的对数行列式，由加性高斯噪声和费雪信息的第一性原理推导得出。\n\n从以下基本原理出发：\n- 传感模型对于未知参数是线性的。对于在特征向量为 $\\boldsymbol{\\phi} \\in \\mathbb{R}^{d}$ 的位置进行的测量，观测值为 $y = \\boldsymbol{\\phi}^{\\top} \\boldsymbol{\\theta} + \\varepsilon$，其中 $\\boldsymbol{\\theta} \\in \\mathbb{R}^{d}$ 是未知参数，$\\varepsilon \\sim \\mathcal{N}(0,\\sigma^{2})$ 且方差 $\\sigma^{2} \\in \\mathbb{R}_{0}$ 已知。\n- 给定 $\\boldsymbol{\\theta}$，各次测量是条件独立的。\n- 为 $\\boldsymbol{\\theta}$ 指定了高斯先验，其精度（逆协方差）矩阵为 $\\boldsymbol{\\Lambda}_{0} \\in \\mathbb{R}^{d \\times d}$，该矩阵是对称正定的。\n- 独立高斯测量的费雪信息是各测量雅可比矩阵外积的和，而贝叶斯线性高斯更新意味着后验精度等于先验精度加上所选测量的累积费雪信息。\n\n您必须：\n- 基于这些原理，推导在给定任何选定的传感器子集下的后验精度矩阵 $\\boldsymbol{\\Lambda}$ 的表达式。论证为何最大化 $\\boldsymbol{\\Lambda}$ 的对数行列式等同于最大化设计的 D-最优性。\n- 实现一个算法，该算法在给定一组具有已知成本的候选传感器位置时，选择一个总成本不超过给定预算的子集，并最大化后验精度的对数行列式。允许选择空集，这对应于仅使用先验信息。\n- 对于下方的每个测试用例，计算最大对数行列式值。将每个结果表示为精确到六位小数的实数。不涉及物理单位。\n\n空间场的特征图由基函数给出，如下所示：\n- 对于一维位置 $x \\in \\mathbb{R}$ 和二次基，$\\boldsymbol{\\phi}(x) = [\\,1,\\; x,\\; x^{2}\\,]^{\\top}$，其中 $d = 3$。\n- 对于二维位置 $(x,y) \\in \\mathbb{R}^{2}$ 和交互基，$\\boldsymbol{\\phi}(x,y) = [\\,1,\\; x,\\; y,\\; x y\\,]^{\\top}$，其中 $d = 4$。\n- 对于一维位置 $x \\in \\mathbb{R}$ 和线性基，$\\boldsymbol{\\phi}(x) = [\\,1,\\; x\\,]^{\\top}$，其中 $d = 2$。\n\n测试套件：\n- 用例 $1$ (一维二次模型):\n  - 先验精度 $\\boldsymbol{\\Lambda}_{0} = \\mathrm{diag}(\\{\\,0.5,\\;0.5,\\;0.5\\,\\})$。\n  - 噪声方差 $\\sigma^{2} = 0.04$。\n  - 候选位置 $\\{\\,x_{i}\\,\\} = \\{\\, -1.0,\\; -0.5,\\; 0.0,\\; 0.5,\\; 1.0,\\; 1.5 \\,\\}$。\n  - 成本 $\\{\\,c_{i}\\,\\} = \\{\\, 2,\\; 1,\\; 1,\\; 1,\\; 2,\\; 3 \\,\\}$。\n  - 预算 $B = 4$。\n- 用例 $2$ (二维交互模型):\n  - 先验精度 $\\boldsymbol{\\Lambda}_{0} = \\mathrm{diag}(\\{\\,1.0,\\; 0.5,\\; 0.5,\\; 0.2\\,\\})$。\n  - 噪声方差 $\\sigma^{2} = 0.09$。\n  - 候选位置 $\\{\\, (x_{i},y_{i}) \\,\\} = \\{\\, (0,0),\\; (1,0),\\; (0,1),\\; (1,1),\\; (-1,1),\\; (2,-1),\\; (-1,-1) \\,\\}$。\n  - 成本 $\\{\\,c_{i}\\,\\} = \\{\\, 3,\\; 2,\\; 2,\\; 2,\\; 3,\\; 4,\\; 1 \\,\\}$。\n  - 预算 $B = 6$。\n- 用例 $3$ (一维线性模型，边界预算):\n  - 先验精度 $\\boldsymbol{\\Lambda}_{0} = \\begin{bmatrix} 2  0.3 \\\\ 0.3  1 \\end{bmatrix}$。\n  - 噪声方差 $\\sigma^{2} = 1.0$。\n  - 候选位置 $\\{\\,x_{i}\\,\\} = \\{\\, -2.0,\\; 0.0,\\; 2.0 \\,\\}$。\n  - 成本 $\\{\\,c_{i}\\,\\} = \\{\\, 5,\\; 5,\\; 5 \\,\\}$。\n  - 预算 $B = 4$。\n\n您的程序必须为每个用例搜索所有总成本不超过给定预算的候选子集，并计算后验精度矩阵对数行列式的最大可达值。使用数值稳定的方法计算对数行列式。将每个用例的最大值四舍五入到恰好六位小数。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按 $\\left[\\text{case}_{1},\\text{case}_{2},\\text{case}_{3}\\right]$ 的顺序排列。例如，打印的行应类似于 $[v_{1},v_{2},v_{3}]$，其中每个 $v_{k}$ 是一个四舍五入到恰好六位小数的实数。",
            "solution": "我们从线性高斯传感模型开始。单次观测为 $y = \\boldsymbol{\\phi}^{\\top} \\boldsymbol{\\theta} + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^{2})$ 且 $\\boldsymbol{\\theta} \\in \\mathbb{R}^{d}$。对于独立的高斯观测，对数似然为\n$$\n\\log p(\\mathbf{y} \\mid \\boldsymbol{\\theta}) = -\\frac{1}{2 \\sigma^{2}} \\sum_{i=1}^{n} \\left(y_{i} - \\boldsymbol{\\phi}_{i}^{\\top} \\boldsymbol{\\theta}\\right)^{2} + \\text{const},\n$$\n其关于 $\\boldsymbol{\\theta}$ 的负海森矩阵即为费雪信息矩阵：\n$$\n\\mathcal{I}(\\boldsymbol{\\theta}) = \\frac{1}{\\sigma^{2}} \\sum_{i=1}^{n} \\boldsymbol{\\phi}_{i} \\boldsymbol{\\phi}_{i}^{\\top}.\n$$\n这源于独立高斯噪声下费雪信息的一般定义，其中均值相对于参数的雅可比矩阵即为特征向量 $\\boldsymbol{\\phi}_{i}$。在高斯先验 $p(\\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{0},\\boldsymbol{\\Lambda}_{0}^{-1})$（精度为 $\\boldsymbol{\\Lambda}_{0} \\succ \\mathbf{0}$）下，线性高斯模型的后验分布是高斯的，其精度等于先验精度与数据费雪信息之和：\n$$\n\\boldsymbol{\\Lambda} \\;=\\; \\boldsymbol{\\Lambda}_{0} \\;+\\; \\frac{1}{\\sigma^{2}} \\sum_{i \\in \\mathcal{S}} \\boldsymbol{\\phi}_{i} \\boldsymbol{\\phi}_{i}^{\\top},\n$$\n其中 $\\mathcal{S}$ 为所选传感器的索引。这一恒等式是贝叶斯线性回归中一个经过充分检验的事实，可以通过在联合密度的指数部分配方法，或通过观察独立高斯测量的费雪信息的可加性来推导。\n\nD-最优性准则选择能最大化参数空间中置信椭球体积的设计，这等价于最大化 $\\log \\det \\boldsymbol{\\Lambda}$，因为对于协方差为 $\\boldsymbol{\\Lambda}^{-1}$ 的高斯后验，椭球体积与 $(\\det \\boldsymbol{\\Lambda}^{-1})^{1/2}$ 成正比。因此，最大化 $\\log \\det \\boldsymbol{\\Lambda}$ 可最小化后验体积。这确立了目标的正确性。\n\n算法设计：\n- 对于每个测试用例，我们都给定了一组具有相关成本 $\\{c_{i}\\}$ 的有限候选位置和一个预算 $B$。我们必须搜索所有满足 $\\sum_{i \\in \\mathcal{S}} c_{i} \\le B$ 的子集 $\\mathcal{S}$。\n- 对于每个可行子集，使用推导出的表达式构建累积信息矩阵：\n$$\n\\boldsymbol{\\Lambda}(\\mathcal{S}) = \\boldsymbol{\\Lambda}_{0} + \\frac{1}{\\sigma^{2}} \\sum_{i \\in \\mathcal{S}} \\boldsymbol{\\phi}_{i} \\boldsymbol{\\phi}_{i}^{\\top}.\n$$\n- 使用数值稳健的方法（如符号对数行列式分解）来稳定地计算 $\\log \\det \\boldsymbol{\\Lambda}(\\mathcal{S})$。由于 $\\boldsymbol{\\Lambda}(\\mathcal{S}) \\succ \\mathbf{0}$，符号为 $+1$，对数行列式等于返回的对数部分。\n- 在所有可行子集中取最大值。允许空集 $\\mathcal{S} = \\emptyset$，此时得到 $\\boldsymbol{\\Lambda}(\\emptyset) = \\boldsymbol{\\Lambda}_{0}$ 和 $\\log \\det \\boldsymbol{\\Lambda}_{0}$；这确保了即使预算不允许放置任何传感器，也能得到一个明确定义的值。\n\n各用例的基函数：\n- 用例 1：对于 $x \\in \\mathbb{R}$，$\\boldsymbol{\\phi}(x) = [\\,1,\\; x,\\; x^{2}\\,]^{\\top}$ 且 $d=3$。先验精度为 $\\boldsymbol{\\Lambda}_{0} = \\mathrm{diag}(\\{\\,0.5,\\;0.5,\\;0.5\\,\\})$，噪声方差 $\\sigma^{2}=0.04$。候选位置为 $\\{\\, -1.0,\\; -0.5,\\; 0.0,\\; 0.5,\\; 1.0,\\; 1.5 \\,\\}$，成本为 $\\{\\,2,\\;1,\\;1,\\;1,\\;2,\\;3\\,\\}$，预算 $B=4$。\n- 用例 2：对于 $(x,y) \\in \\mathbb{R}^{2}$，$\\boldsymbol{\\phi}(x,y) = [\\,1,\\; x,\\; y,\\; x y\\,]^{\\top}$ 且 $d=4$。先验精度为 $\\boldsymbol{\\Lambda}_{0} = \\mathrm{diag}(\\{\\,1.0,\\;0.5,\\;0.5,\\;0.2\\,\\})$，噪声方差 $\\sigma^{2}=0.09$。候选位置为 $\\{\\, (0,0),\\; (1,0),\\; (0,1),\\; (1,1),\\; (-1,1),\\; (2,-1),\\; (-1,-1) \\,\\}$，成本为 $\\{\\,3,\\;2,\\;2,\\;2,\\;3,\\;4,\\;1\\,\\}$，预算 $B=6$。\n- 用例 3：对于 $x \\in \\mathbb{R}$，$\\boldsymbol{\\phi}(x) = [\\,1,\\; x\\,]^{\\top}$ 且 $d=2$。先验精度为 $\\boldsymbol{\\Lambda}_{0} = \\begin{bmatrix} 2  0.3 \\\\ 0.3  1 \\end{bmatrix}$，噪声方差 $\\sigma^{2}=1.0$。候选位置为 $\\{\\, -2.0,\\; 0.0,\\; 2.0 \\,\\}$，成本为 $\\{\\,5,\\;5,\\;5\\,\\}$，预算 $B=4$。由于预算小于任何单个传感器的成本，最优子集是空集，最大对数行列式等于 $\\log \\det \\boldsymbol{\\Lambda}_{0}$。\n\n计算考量：\n- 每个用例中的候选数量很少（最多7个），因此对所有子集进行穷举在计算上是可行的，最多有 $2^{7} = 128$ 个子集。对于每个子集，计算其成本并与预算进行比较。如果可行，则累加特征外积，并与先验精度结合以评估对数行列式。\n- 为确保在评估对称正定矩阵 $\\boldsymbol{\\Lambda}$ 的 $\\log \\det$ 时的数值稳定性，应使用能直接返回 $\\log \\det$ 而无需显式计算行列式的分解方法，例如符号对数行列式例程。或者，Cholesky 分解可得到 $\\log \\det \\boldsymbol{\\Lambda} = 2 \\sum_{i} \\log L_{ii}$，其中 $\\mathbf{L}$ 是下三角 Cholesky 因子。这两种方法都是稳定的。\n\n程序将为这三个用例实现这些步骤，将每个最大值四舍五入到恰好六位小数，并按 $[v_{1},v_{2},v_{3}]$ 的形式打印单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef slogdet_spd(A: np.ndarray) - float:\n    \"\"\"\n    Compute log(det(A)) for symmetric positive definite A using Cholesky\n    for numerical stability.\n    \"\"\"\n    L = np.linalg.cholesky(A)\n    return 2.0 * np.sum(np.log(np.diag(L)))\n\ndef phi_case1(x: float) - np.ndarray:\n    # Quadratic basis in 1D: [1, x, x^2]^T\n    return np.array([1.0, x, x * x], dtype=float)\n\ndef phi_case2(pt: tuple) - np.ndarray:\n    # Interaction basis in 2D: [1, x, y, x*y]^T\n    x, y = pt\n    return np.array([1.0, x, y, x * y], dtype=float)\n\ndef phi_case3(x: float) - np.ndarray:\n    # Linear basis in 1D: [1, x]^T\n    return np.array([1.0, x], dtype=float)\n\ndef max_logdet_for_case(prior_prec: np.ndarray,\n                        sigma2: float,\n                        candidates,\n                        costs,\n                        budget: float,\n                        phi_func) - float:\n    \"\"\"\n    Enumerate all subsets under budget and return the maximum log(det) of posterior precision.\n    \"\"\"\n    n = len(candidates)\n    costs = np.array(costs, dtype=float)\n    best_logdet = -np.inf\n\n    # Precompute feature vectors for all candidates\n    features = [phi_func(candidates[i]) for i in range(n)]\n    d = prior_prec.shape[0]\n    inv_sigma2 = 1.0 / sigma2\n\n    # Enumerate all subsets using bit masks from 0..(2^n - 1)\n    for mask in range(1  n):\n        # Compute total cost and skip early if exceeds budget\n        total_cost = 0.0\n        # Accumulate information matrix term S = sum phi phi^T\n        S = np.zeros((d, d), dtype=float)\n        for i in range(n):\n            if (mask >> i)  1:\n                total_cost += costs[i]\n                if total_cost > budget:\n                    # Prune this subset\n                    S = None\n                    break\n                phi = features[i]\n                S += np.outer(phi, phi)\n        if S is None:\n            continue\n        # Posterior precision: prior + (1/sigma^2) * S\n        Lambda = prior_prec + inv_sigma2 * S\n        # Compute log det\n        try:\n            logdet = slogdet_spd(Lambda)\n        except np.linalg.LinAlgError:\n            # In the unlikely event of numerical issues, skip this subset\n            continue\n        if logdet > best_logdet:\n            best_logdet = logdet\n\n    return best_logdet\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1\n    prior1 = np.diag([0.5, 0.5, 0.5])\n    sigma2_1 = 0.04\n    candidates1 = [-1.0, -0.5, 0.0, 0.5, 1.0, 1.5]\n    costs1 = [2, 1, 1, 1, 2, 3]\n    budget1 = 4.0\n\n    # Case 2\n    prior2 = np.diag([1.0, 0.5, 0.5, 0.2])\n    sigma2_2 = 0.09\n    candidates2 = [(0.0, 0.0),\n                   (1.0, 0.0),\n                   (0.0, 1.0),\n                   (1.0, 1.0),\n                   (-1.0, 1.0),\n                   (2.0, -1.0),\n                   (-1.0, -1.0)]\n    costs2 = [3, 2, 2, 2, 3, 4, 1]\n    budget2 = 6.0\n\n    # Case 3\n    prior3 = np.array([[2.0, 0.3],\n                       [0.3, 1.0]])\n    sigma2_3 = 1.0\n    candidates3 = [-2.0, 0.0, 2.0]\n    costs3 = [5, 5, 5]\n    budget3 = 4.0\n\n    test_cases = [\n        (prior1, sigma2_1, candidates1, costs1, budget1, phi_case1),\n        (prior2, sigma2_2, candidates2, costs2, budget2, phi_case2),\n        (prior3, sigma2_3, candidates3, costs3, budget3, phi_case3),\n    ]\n\n    results = []\n    for prior, sigma2, candidates, costs, budget, phi in test_cases:\n        max_logdet = max_logdet_for_case(prior, sigma2, candidates, costs, budget, phi)\n        results.append(f\"{max_logdet:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}