{
    "hands_on_practices": [
        {
            "introduction": "这项实践深入探讨了一个安全攸关的医疗应用：人工胰腺。我们将使用一个简化的葡萄糖-胰岛素动态模型来探索基本的控制理论原理，如稳定性分析，对于确保闭环胰岛素输送系统的患者安全至关重要。通过这个练习，您将锻炼对信息物理系统进行数学建模和稳定性分析的核心技能。",
            "id": "4205546",
            "problem": "医用级人工胰腺信息物理系统 (CPS) 集成了传感、驱动、计算和通信，通过闭环胰岛素输送来管理血糖。考虑一个为患者设计的基于数字孪生的控制器，该患者由围绕基础值的微小偏差下的最小葡萄糖-胰岛素动态模型来建模。设 $g(t)$ 表示血浆葡萄糖浓度与基础值之间的偏差，设 $x(t)$ 表示胰岛素作用状态，设 $i(t)$ 表示血浆胰岛素浓度与基础值之间的偏差。外部胰岛素输注率是由执行器提供的控制输入 $u(t)$。膳食和其他外源性输入被建模为有界扰动 $d(t)$。\n\n假设以下与质量平衡和房室动态学一致的基础线性化最小模型：\n$$\\frac{dg(t)}{dt} = -S_G\\, g(t) - x(t) + d(t),$$\n$$\\frac{dx(t)}{dt} = -p_2\\, x(t) + p_3\\, i(t),$$\n$$\\frac{di(t)}{dt} = -n\\, i(t) + u(t),$$\n其中 $S_G > 0$ 是葡萄糖有效性，$p_2 > 0$ 是胰岛素作用衰减率，$p_3 > 0$ 是胰岛素作用增益，$n > 0$ 是胰岛素清除率。控制器可以通过连续葡萄糖传感获取 $g(t)$，并应用比例定律 $u(t) = -K\\, g(t)$，其中 $K > 0$。\n\n对于相对于葡萄糖和胰岛素作用动态学而言具有快速胰岛素动力学的输注途径和设备，假设在小信号操作下对 $i(t)$ 进行准稳态简化，即 $\\frac{di(t)}{dt} \\approx 0$，从而 $i(t) \\approx \\frac{1}{n}\\, u(t)$。在此近似下，闭环动态简化为二状态系统\n$$\\frac{dg(t)}{dt} = -S_G\\, g(t) - x(t), \\quad \\frac{dx(t)}{dt} = -p_2\\, x(t) + \\frac{p_3}{n}\\, u(t), \\quad u(t) = -K\\, g(t).$$\n\n任务：\n- 从给定的定义和简化假设出发，推导该二状态系统的闭环特征多项式，并确定在没有扰动 $d(t)$ 的情况下保证平衡点 $g(t) = 0, x(t) = 0$ 渐近稳定的 $K$ 的条件。\n- 将最大稳定比例增益 $K_{\\text{max}}$ 定义为维持渐近稳定性的最大 $K$。使用线性系统稳定性的基本原理，用 $S_G$、$p_2$、$p_3$ 和 $n$ 表示 $K_{\\text{max}}$。\n- 计算 $K_{\\text{max}}$ 相对于胰岛素作用增益 $p_3$ 的归一化灵敏度，该灵敏度由对数灵敏度指数 $S_{p_3}(K_{\\text{max}}) = \\frac{\\partial \\ln K_{\\text{max}}}{\\partial \\ln p_3}$ 定义。将灵敏度指数报告为单个实数。无需四舍五入，最终答案中不应包含单位。",
            "solution": "首先对问题陈述进行严格的验证程序。\n\n### 步骤 1：提取已知条件\n- 状态变量：血浆葡萄糖浓度偏差 $g(t)$，胰岛素作用状态 $x(t)$，以及血浆胰岛素浓度偏差 $i(t)$。\n- 控制输入：外部胰岛素输注率 $u(t)$。\n- 扰动：有界外源性输入 $d(t)$。\n- 完整的三状态线性化模型：\n  $$ \\frac{dg(t)}{dt} = -S_G\\, g(t) - x(t) + d(t) $$\n  $$ \\frac{dx(t)}{dt} = -p_2\\, x(t) + p_3\\, i(t) $$\n  $$ \\frac{di(t)}{dt} = -n\\, i(t) + u(t) $$\n- 模型参数：葡萄糖有效性 $S_G > 0$，胰岛素作用衰减率 $p_2 > 0$，胰岛素作用增益 $p_3 > 0$，胰岛素清除率 $n > 0$。\n- 控制律：比例控制 $u(t) = -K\\, g(t)$，增益 $K > 0$。\n- 模型简化假设：胰岛素动态的准稳态，$\\frac{di(t)}{dt} \\approx 0$，这意味着 $i(t) \\approx \\frac{1}{n}\\, u(t)$。\n- 简化的二状态闭环系统动态（在无扰动，$d(t)=0$ 的情况下）：\n  $$ \\frac{dg(t)}{dt} = -S_G\\, g(t) - x(t) $$\n  $$ \\frac{dx(t)}{dt} = -p_2\\, x(t) + \\frac{p_3}{n}\\, u(t) $$\n  $$ u(t) = -K\\, g(t) $$\n- 任务：\n  1. 推导该二状态系统的闭环特征多项式，并求出实现渐近稳定的 $K$ 的条件。\n  2. 定义并求出最大稳定比例增益 $K_{\\text{max}}$，用 $S_G$、$p_2$、$p_3$ 和 $n$ 表示。\n  3. 计算归一化灵敏度指数 $S_{p_3}(K_{\\text{max}}) = \\frac{\\partial \\ln K_{\\text{max}}}{\\partial \\ln p_3}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据。所提出的模型是 Bergman 最小模型的一个标准线性化，该模型是葡萄糖-胰岛素动态建模的基石。在控制工程中，使用比例控制器和准稳态假设是进行系统分析和设计的常用有效技术。该问题是适定的；它要求对一个线性时不变 (LTI) 系统进行稳定性条件和灵敏度分析，这些是具有唯一解的标准、可形式化的任务。陈述是客观的，并使用了精确的术语。提供了所有必要的参数和方程，并且约束条件（例如 $S_G > 0$）在物理上是一致的。该问题没有指定的使其无效的缺陷。\n\n### 步骤 3：结论和行动\n问题有效。将提供完整的解答。\n\n### 解答推导\n目标是分析所提供的二状态系统的稳定性。首先，我们以状态空间形式构建闭环系统动态。为进行稳定性分析，将扰动设为零，$d(t)=0$。\n\n简化的系统由以下公式给出：\n$$ \\frac{dg(t)}{dt} = -S_G\\, g(t) - x(t) $$\n$$ \\frac{dx(t)}{dt} = -p_2\\, x(t) + \\frac{p_3}{n}\\, u(t) $$\n将比例控制律 $u(t) = -K\\, g(t)$ 代入第二个方程，得到：\n$$ \\frac{dx(t)}{dt} = -p_2\\, x(t) - \\frac{p_3 K}{n}\\, g(t) $$\n我们可以将系统写成标准的状态空间形式 $\\dot{\\mathbf{z}}(t) = A\\, \\mathbf{z}(t)$，其中状态向量为 $\\mathbf{z}(t) = \\begin{pmatrix} g(t) \\\\ x(t) \\end{pmatrix}$。\n$$ \\frac{d}{dt} \\begin{pmatrix} g(t) \\\\ x(t) \\end{pmatrix} = \\begin{pmatrix} -S_G  -1 \\\\ -\\frac{p_3 K}{n}  -p_2 \\end{pmatrix} \\begin{pmatrix} g(t) \\\\ x(t) \\end{pmatrix} $$\n矩阵 $A$ 代表闭环系统动态：\n$$ A = \\begin{pmatrix} -S_G  -1 \\\\ -\\frac{p_3 K}{n}  -p_2 \\end{pmatrix} $$\n\n**任务 1：特征多项式和稳定性条件**\n\n此 LTI 系统的稳定性由矩阵 $A$ 的特征值决定，这些特征值是特征多项式 $P(\\lambda) = \\det(\\lambda I - A) = 0$ 的根。\n$$ \\lambda I - A = \\begin{pmatrix} \\lambda  0 \\\\ 0  \\lambda \\end{pmatrix} - \\begin{pmatrix} -S_G  -1 \\\\ -\\frac{p_3 K}{n}  -p_2 \\end{pmatrix} = \\begin{pmatrix} \\lambda + S_G  1 \\\\ \\frac{p_3 K}{n}  \\lambda + p_2 \\end{pmatrix} $$\n特征多项式为：\n$$ P(\\lambda) = \\det(\\lambda I - A) = (\\lambda + S_G)(\\lambda + p_2) - (1) \\left(\\frac{p_3 K}{n}\\right) $$\n$$ P(\\lambda) = \\lambda^2 + (S_G + p_2)\\lambda + S_G p_2 - \\frac{p_3 K}{n} $$\n对于一个连续时间系统，要使其渐近稳定，其特征多项式的所有根都必须具有负实部。对于二阶多项式 $\\lambda^2 + a_1 \\lambda + a_0 = 0$，Routh-Hurwitz 稳定性判据要求所有系数都为正。\n1. $\\lambda^2$ 的系数是 $1$，为正。\n2. $\\lambda$ 的系数 $a_1 = S_G + p_2$ 必须为正。鉴于 $S_G > 0$ 和 $p_2 > 0$，此条件始终满足。\n3. 常数项 $a_0 = S_G p_2 - \\frac{p_3 K}{n}$ 必须为正。\n$$ S_G p_2 - \\frac{p_3 K}{n} > 0 $$\n这个不等式给出了增益 $K$ 的条件。对 $K$ 进行整理：\n$$ S_G p_2 > \\frac{p_3 K}{n} $$\n$$ K  \\frac{n S_G p_2}{p_3} $$\n由于问题规定 $K  0$，渐近稳定的条件是 $0  K  \\frac{n S_G p_2}{p_3}$。\n\n**任务 2：最大稳定增益 $K_{\\text{max}}$**\n\n最大稳定比例增益 $K_{\\text{max}}$ 是使系统渐近稳定的所有增益 $K$ 集合的上确界。这对应于稳定性边界，在该边界上，特征多项式的常数项变为零。\n基于稳定性条件 $K  \\frac{n S_G p_2}{p_3}$，最大值是该区间的上界。\n$$ K_{\\text{max}} = \\frac{n S_G p_2}{p_3} $$\n\n**任务 3：$K_{\\text{max}}$ 的归一化灵敏度**\n\n我们需要计算 $K_{\\text{max}}$ 相对于参数 $p_3$ 的归一化灵敏度，定义为 $S_{p_3}(K_{\\text{max}}) = \\frac{\\partial \\ln K_{\\text{max}}}{\\partial \\ln p_3}$。这个对数导数量化了 $p_3$ 的百分比变化所引起的 $K_{\\text{max}}$ 的百分比变化。\n\n首先，我们使用前一个任务中推导出的表达式来表示 $\\ln K_{\\text{max}}$：\n$$ K_{\\text{max}} = \\frac{n S_G p_2}{p_3} $$\n对两边取自然对数：\n$$ \\ln K_{\\text{max}} = \\ln \\left( \\frac{n S_G p_2}{p_3} \\right) $$\n利用对数的性质：\n$$ \\ln K_{\\text{max}} = \\ln(n S_G p_2) - \\ln(p_3) $$\n灵敏度指数是 $\\ln K_{\\text{max}}$ 关于 $\\ln p_3$ 的偏导数。让我们定义一个变量 $z = \\ln p_3$。然后我们需要计算 $\\frac{\\partial}{\\partial z} (\\ln K_{\\text{max}})$。\n$$ \\frac{\\partial}{\\partial (\\ln p_3)} (\\ln K_{\\text{max}}) = \\frac{\\partial}{\\partial (\\ln p_3)} (\\ln(n S_G p_2) - \\ln(p_3)) $$\n项 $\\ln(n S_G p_2)$ 相对于 $p_3$ 是常数，因此其导数为零。根据定义，$\\ln(p_3)$ 关于 $\\ln(p_3)$ 的导数是 $1$。\n$$ S_{p_3}(K_{\\text{max}}) = 0 - 1 = -1 $$\n灵敏度指数是一个常数值 $-1$。这表明胰岛素作用增益 $p_3$ 增加 $1\\%$ 会导致最大稳定控制增益 $K_{\\text{max}}$ 减少 $1\\%$。这种反比关系是符合预期的，因为较高的 $p_3$ 意味着胰岛素对葡萄糖的影响更强，因此需要较小的控制器增益以避免过度校正和不稳定性。\n最终结果是一个无量纲的实数。",
            "answer": "$$\n\\boxed{-1}\n$$"
        },
        {
            "introduction": "从单个控制回路扩展到系统级挑战，这项实践关注微电网中的最优资源分配问题。我们将构建并求解一个约束优化问题，以平衡驱动成本和电网频率稳定性，展示信息物理系统如何管理复杂的权衡。这项练习提供了将优化理论（如 Karush-Kuhn-Tucker 条件）转化为可执行计算解决方案的动手经验。",
            "id": "4205542",
            "problem": "考虑信息物理系统（CPS）领域中的一个微电网，其中需求响应（DR）控制器在一组可控资产上分配一系列稳态功率调整，以吸收一个已知的净功率冲击。这些资产可能包括分布式发电、储能和柔性负载。设控制动作向量为 $y \\in \\mathbb{R}^n$，其中每个分量 $y_i$ 代表资产 $i$ 的功率变化，单位为兆瓦（MW）。系统经历一个净冲击 $ \\Delta P $（单位为MW）。稳态频率偏差 $ \\Delta f $ 通过线性化的功率-频率灵敏度 $ \\beta $（单位为兆瓦/赫兹）与净功率失配 $ m $ 呈线性关系，即 $ \\Delta f = - \\dfrac{m}{\\beta} $，其中 $ m = \\Delta P - \\mathbf{1}^\\top y $，而 $ \\mathbf{1} $ 是 $ \\mathbb{R}^n $ 中的全一向量。\n\n每个资产都有一个严格凸的二次成本，代表驱动负效用或运行成本。需要最小化的总成本是各项资产成本与频率偏差惩罚之和。具体来说，目标函数为\n$$\nJ(y, m) = \\frac{1}{2} y^\\top A y + b^\\top y + \\frac{1}{2} w_f \\left( \\Delta f \\right)^2,\n$$\n其中 $ A = \\mathrm{diag}(\\alpha_1, \\alpha_2, \\ldots, \\alpha_n) $ 且 $ \\alpha_i  0 $，$ b \\in \\mathbb{R}^n $ 是线性成本系数，$ w_f  0 $ 是频率惩罚权重（单位为成本单位/赫兹平方）。使用 $ \\Delta f = - \\dfrac{m}{\\beta} $，该惩罚项变为 $ \\dfrac{1}{2} \\kappa m^2 $，其中 $ \\kappa = \\dfrac{w_f}{\\beta^2} $。功率失配 $ m $ 不是自由的；它受到物理功率平衡的约束，\n$$\nm = \\Delta P - \\mathbf{1}^\\top y.\n$$\n\n您的任务是，从第一性原理出发，推导这个严格凸优化问题的 Karush-Kuhn-Tucker (KKT) 最优性条件，推导过程始于基本的线性化功率-频率定律 $ \\Delta f = - \\dfrac{m}{\\beta} $ 和物理功率平衡约束的定义 $ m = \\Delta P - \\mathbf{1}^\\top y $。利用这些条件，计算唯一的最优解 $(y^\\star, m^\\star)$ 以及与等式约束 $ m - \\Delta P + \\mathbf{1}^\\top y = 0 $ 相关联的对偶变量 $ \\mu^\\star $。将 $ \\mu^\\star $ 解释为电网功率平衡约束的影子价格，说明其值如何反映驱动成本与频率稳定性之间的权衡。将 $ m^\\star $ 以兆瓦（MW）表示，$ \\mu^\\star $ 以成本单位/兆瓦表示，$ J^\\star $（最优目标值）以成本单位表示。所有数值答案必须是浮点数。\n\n实现一个完整、可运行的程序，该程序：\n- 为每个测试用例计算 $ \\kappa = \\dfrac{w_f}{\\beta^2} $。\n- 求解最优性条件以获得如上定义的 $ y^\\star $、$ m^\\star $、$ \\mu^\\star $ 和 $ J^\\star $。\n- 生成最终输出，为包含一个逗号分隔列表的单行，并用方括号括起来。对于每个测试用例，输出一个内部列表 $ [m^\\star, \\mu^\\star, J^\\star] $。在最终输出中将每个浮点数四舍五入到 $6$ 位小数。\n\n使用以下测试套件来验证您的实现。每个测试用例提供 $(\\alpha, b, \\Delta P, \\beta, w_f)$:\n- 测试用例 $1$：$ \\alpha = [0.8, 0.5, 1.2, 0.6] $，$ b = [0.1, 0.05, 0.2, 0.15] $，$ \\Delta P = 5.0 $ MW，$ \\beta = 400.0 $ MW/Hz，$ w_f = 10000.0 $。\n- 测试用例 $2$：$ \\alpha = [0.7, 0.9, 0.4] $，$ b = [0.0, 0.1, -0.05] $，$ \\Delta P = 8.0 $ MW，$ \\beta = 500.0 $ MW/Hz，$ w_f = 0.000001 $。\n- 测试用例 $3$：$ \\alpha = [0.5, 0.6, 0.7, 0.8, 1.0] $，$ b = [0.05, 0.04, 0.1, 0.2, 0.0] $，$ \\Delta P = 3.0 $ MW，$ \\beta = 300.0 $ MW/Hz，$ w_f = 1000000.0 $。\n- 测试用例 $4$：$ \\alpha = [1.0] $，$ b = [0.0] $，$ \\Delta P = 2.0 $ MW，$ \\beta = 600.0 $ MW/Hz，$ w_f = 1000.0 $。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的结果列表，并用方括号括起来，格式完全如下：\n$$\n\\text{[}[m^\\star_1, \\mu^\\star_1, J^\\star_1],[m^\\star_2, \\mu^\\star_2, J^\\star_2],[m^\\star_3, \\mu^\\star_3, J^\\star_3],[m^\\star_4, \\mu^\\star_4, J^\\star_4]\\text{]}\n$$\n其中下标 $k$ 索引测试用例 $k \\in \\{1,2,3,4\\}$。",
            "solution": "所呈现的问题是一个适定（well-posed）的、具有科学基础的优化问题，在电力系统和信息物理系统的研究中很常见。问题本身是自包含的，并且提供了获得唯一解所需的所有数据。因此，该问题被认为是有效的，并给出完整解答。\n\n任务是找到最优的功率调整 $y^\\star$ 和由此产生的功率失配 $m^\\star$，以最小化总成本函数 $J$，并服从功率平衡约束。该问题可以正式表述为一个约束二次规划。\n\n首先，我们构建优化问题。需要最小化的目标函数由下式给出\n$$\nJ(y, m) = \\frac{1}{2} y^\\top A y + b^\\top y + \\frac{1}{2} w_f \\left( \\Delta f \\right)^2\n$$\n其中 $y \\in \\mathbb{R}^n$ 是控制动作向量，$A = \\mathrm{diag}(\\alpha_1, \\ldots, \\alpha_n)$ 是二次成本系数的对角矩阵，且 $\\alpha_i  0$，$b \\in \\mathbb{R}^n$ 是线性成本系数向量，$w_f  0$ 是频率惩罚权重。频率偏差 $\\Delta f$ 通过线性化的功率-频率灵敏度 $\\beta$ 与功率失配 $m$ 相关联，即 $\\Delta f = -m/\\beta$。将此代入目标函数，得到一个惩罚项 $\\frac{1}{2} w_f (-m/\\beta)^2 = \\frac{1}{2} (w_f/\\beta^2) m^2$。我们定义 $\\kappa = w_f/\\beta^2$，因此以优化变量 $y$ 和 $m$ 表示的目标函数变为：\n$$\nJ(y, m) = \\frac{1}{2} y^\\top A y + b^\\top y + \\frac{1}{2} \\kappa m^2\n$$\n变量 $y$ 和 $m$ 通过物理功率平衡约束 $m = \\Delta P - \\mathbf{1}^\\top y$ 联系起来，其中 $\\Delta P$ 是净功率冲击，$\\mathbf{1}$ 是全一向量。这可以写成一个标准的等式约束：\n$$\ng(y, m) = m + \\mathbf{1}^\\top y - \\Delta P = 0\n$$\n由于 $A$ 是正定矩阵（所有 $\\alpha_i  0$）且 $\\kappa  0$，目标函数 $J(y, m)$ 是严格凸的。约束是线性的（仿射的）。在凸集（本例中为仿射子空间）上最小化一个严格凸函数，保证了存在唯一的最优解。\n\n为了找到这个唯一最优解，我们使用拉格朗日乘子法。对于这个凸问题，Karush-Kuhn-Tucker (KKT) 条件提供了最优性的充要条件。我们通过一个拉格朗日乘子 $\\mu \\in \\mathbb{R}$ 将约束附加到目标函数上，从而构造拉格朗日函数 $\\mathcal{L}$：\n$$\n\\mathcal{L}(y, m, \\mu) = J(y, m) + \\mu(m + \\mathbf{1}^\\top y - \\Delta P)\n$$\n$$\n\\mathcal{L}(y, m, \\mu) = \\frac{1}{2} y^\\top A y + b^\\top y + \\frac{1}{2} \\kappa m^2 + \\mu (m + \\mathbf{1}^\\top y - \\Delta P)\n$$\nKKT 条件通过将拉格朗日函数对原始变量 $y$ 和 $m$ 的梯度设为零（平稳性条件），并强制满足原始约束（原始可行性）来获得。\n\n1.  关于 $y$ 的平稳性条件：$\\mathcal{L}$ 关于向量 $y$ 的梯度必须为零。\n$$\n\\nabla_y \\mathcal{L}(y, m, \\mu) = Ay + b + \\mu \\mathbf{1} = 0 \\quad (1)\n$$\n2.  关于 $m$ 的平稳性条件：$\\mathcal{L}$ 关于标量 $m$ 的偏导数必须为零。\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial m}(y, m, \\mu) = \\kappa m + \\mu = 0 \\quad (2)\n$$\n3.  原始可行性：原始约束必须成立。\n$$\nm + \\mathbf{1}^\\top y - \\Delta P = 0 \\quad (3)\n$$\n我们现在有了一个关于 $(y, m, \\mu)$ 的线性方程组。我们解这个方程组来找到最优值 $(y^\\star, m^\\star, \\mu^\\star)$。\n\n从方程 $(1)$，我们可以用最优对偶变量 $\\mu^\\star$ 来表示最优控制动作 $y^\\star$。由于 $A$ 是一个对角元素均为正的对角矩阵，它是可逆的，其逆矩阵为 $A^{-1} = \\mathrm{diag}(1/\\alpha_1, \\ldots, 1/\\alpha_n)$。\n$$\nA y^\\star = -b - \\mu^\\star \\mathbf{1} \\implies y^\\star = -A^{-1}(b + \\mu^\\star \\mathbf{1})\n$$\n以分量形式表示，对于每个资产 $i \\in \\{1, \\ldots, n\\}$：\n$$\ny_i^\\star = -\\frac{b_i + \\mu^\\star}{\\alpha_i}\n$$\n从方程 $(2)$，我们用 $\\mu^\\star$ 来表示最优失配 $m^\\star$：\n$$\nm^\\star = -\\frac{\\mu^\\star}{\\kappa}\n$$\n现在，将 $y^\\star$ 和 $m^\\star$ 的这些表达式代入可行性约束，即方程 $(3)$：\n$$\n\\left(-\\frac{\\mu^\\star}{\\kappa}\\right) + \\mathbf{1}^\\top \\left(-A^{-1}(b + \\mu^\\star \\mathbf{1})\\right) - \\Delta P = 0\n$$\n展开转置并分配各项：\n$$\n-\\frac{\\mu^\\star}{\\kappa} - \\mathbf{1}^\\top A^{-1} b - \\mu^\\star (\\mathbf{1}^\\top A^{-1} \\mathbf{1}) - \\Delta P = 0\n$$\n我们组合各项以求解 $\\mu^\\star$：\n$$\n-\\mu^\\star \\left(\\frac{1}{\\kappa} + \\mathbf{1}^\\top A^{-1} \\mathbf{1}\\right) = \\Delta P + \\mathbf{1}^\\top A^{-1} b\n$$\n涉及求和的项是 $\\mathbf{1}^\\top A^{-1} \\mathbf{1} = \\sum_{i=1}^n \\frac{1}{\\alpha_i}$ 和 $\\mathbf{1}^\\top A^{-1} b = \\sum_{i=1}^n \\frac{b_i}{\\alpha_i}$。由于 $\\kappa  0$ 和 $\\alpha_i  0$，分母是严格为正的。最优对偶变量的唯一解是：\n$$\n\\mu^\\star = -\\frac{\\Delta P + \\sum_{i=1}^n (b_i/\\alpha_i)}{1/\\kappa + \\sum_{i=1}^n (1/\\alpha_i)}\n$$\n确定了 $\\mu^\\star$ 后，我们可以使用前面推导的表达式找到最优原始变量 $m^\\star$ 和 $y^\\star$。\n\n对偶变量 $\\mu^\\star$ 是与约束 $m + \\mathbf{1}^\\top y - \\Delta P = 0$ 相关联的影子价格。根据包络定理，最优成本 $J^\\star$ 对约束常数扰动的导数等于拉格朗日乘子。具体来说，如果约束是 $m + \\mathbf{1}^\\top y - (\\Delta P-c) = 0$，我们会有 $dJ^\\star/dc = \\mu^\\star$。约束放宽 $dc$ 等价于冲击 $\\Delta P$ 减少 $dc$。因此，$dJ^\\star/d(\\Delta P) = -\\mu^\\star$。值 $-\\mu^\\star$ 代表了功率冲击 $\\Delta P$ 每边际增加一个单位时，总系统成本的边际增加。其单位是成本/兆瓦。\n从平稳性条件，我们有 $-\\mu^\\star = \\kappa m^\\star$ 和 $-\\mu^\\star = \\alpha_i y_i^\\star + b_i$ 对所有 $i$ 成立。项 $\\alpha_i y_i^\\star + b_i$ 是资产 $i$ 的边际驱动成本，即 $\\frac{d}{dy_i}(\\frac{1}{2}\\alpha_i y_i^2 + b_i y_i)$。项 $\\kappa m^\\star$ 是频率偏差的边际成本，即 $\\frac{d}{dm}(\\frac{1}{2}\\kappa m^2)$。因此，$-\\mu^\\star$ 代表了全系统均等的响应边际成本，此时使用任何资产的成本与允许频率偏差的成本之间达到平衡。\n\n最后，通过将最优值 $y^\\star$ 和 $m^\\star$ 代入目标函数来计算最优成本 $J^\\star$：\n$$\nJ^\\star = J(y^\\star, m^\\star) = \\frac{1}{2} (y^\\star)^\\top A y^\\star + b^\\top y^\\star + \\frac{1}{2} \\kappa (m^\\star)^2\n$$\n实现将遵循这些推导出的解析解。对于每个测试用例，我们先计算 $\\kappa$，然后是 $\\mu^\\star$，接着是 $m^\\star$ 和 $y^\\star$，最后是 $J^\\star$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the microgrid demand response optimization problem for a series of test cases.\n\n    The problem is to minimize the cost function:\n    J(y, m) = 0.5 * y.T @ A @ y + b.T @ y + 0.5 * kappa * m^2\n    subject to the constraint:\n    m + 1.T @ y - Delta_P = 0\n\n    The KKT conditions lead to an analytical solution for the optimal dual variable mu*,\n    from which the optimal primal variables y* and m*, and the optimal cost J* can be derived.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, b, Delta_P, beta, wf)\n    test_cases = [\n        (np.array([0.8, 0.5, 1.2, 0.6]), np.array([0.1, 0.05, 0.2, 0.15]), 5.0, 400.0, 10000.0),\n        (np.array([0.7, 0.9, 0.4]), np.array([0.0, 0.1, -0.05]), 8.0, 500.0, 0.000001),\n        (np.array([0.5, 0.6, 0.7, 0.8, 1.0]), np.array([0.05, 0.04, 0.1, 0.2, 0.0]), 3.0, 300.0, 1000000.0),\n        (np.array([1.0]), np.array([0.0]), 2.0, 600.0, 1000.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, b, delta_p, beta, wf = case\n        \n        # 1. Compute kappa from physical parameters\n        # kappa = wf / beta^2\n        kappa = wf / (beta**2)\n        \n        # 2. Compute summary terms for the analytical solution\n        # S1 = sum(1 / alpha_i)\n        # S2 = sum(b_i / alpha_i)\n        sum_inv_alpha = np.sum(1.0 / alpha)\n        sum_b_over_alpha = np.sum(b / alpha)\n        \n        # 3. Solve for the optimal dual variable mu_star\n        # mu_star = - (Delta_P + S2) / (1/kappa + S1)\n        mu_star_numerator = delta_p + sum_b_over_alpha\n        mu_star_denominator = (1.0 / kappa) + sum_inv_alpha\n        mu_star = -mu_star_numerator / mu_star_denominator\n        \n        # 4. Compute the optimal primal variables m_star and y_star\n        # m_star = -mu_star / kappa\n        m_star = -mu_star / kappa\n        \n        # y_star_i = -(b_i + mu_star) / alpha_i\n        y_star = -(b + mu_star) / alpha\n        \n        # 5. Compute the optimal objective value J_star\n        # J_star = 0.5 * y_star.T @ A @ y_star + b.T @ y_star + 0.5 * kappa * m_star^2\n        # where A = diag(alpha). A term y_star.T @ A @ y_star simplifies to sum(alpha_i * y_star_i^2)\n        cost_y_quad = 0.5 * np.sum(alpha * y_star**2)\n        cost_y_linear = np.sum(b * y_star)\n        cost_m_quad = 0.5 * kappa * m_star**2\n        j_star = cost_y_quad + cost_y_linear + cost_m_quad\n        \n        results.append([m_star, mu_star, j_star])\n\n    # Final print statement in the exact required format.\n    # The output is a list of lists, with each inner list being [m*, mu*, J*]\n    #\n    # Example format: [[m1,mu1,J1],[m2,mu2,J2],...]\n    output_str = \",\".join([f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践将探索信息物理系统的前沿领域：数字孪生与预测性维护。我们将构建一个数据驱动模型来估计机器部件的剩余使用寿命（Remaining Useful Life, RUL），其中结合了贝叶斯推断与蒙特卡洛模拟。通过这个练习，您将学习如何利用来自物理系统的数据进行知情预测，从而优化运营和维护决策。",
            "id": "4205570",
            "problem": "您的任务是构建一个完整、可运行的程序，该程序使用数字孪生驱动的预测性维护方法来估算计算机数控（CNC）主轴的剩余使用寿命。信息物理模型由标量退化状态动力学和基于振动的测量通道指定。请从线性高斯模型的贝叶斯推断和连续时间线性系统的一阶离散化的基本原理开始。\n\n数字孪生模型如下。内部退化状态为 $\\theta(t)$，根据一阶微分方程 $\\dot{\\theta}(t) = \\alpha u(t) + \\beta$ 演变，其中 $\\alpha$ 和 $\\beta$ 是未知常数，$u(t)$ 是已知的使用输入。振动测量通道在离散时间 $t_k$ 返回一个标量特征 $y_k$，其模型为 $y_k = c \\theta_k + v_k$，其中 $\\theta_k = \\theta(t_k)$，$c  0$ 是一个已知的比例因子，$v_k \\sim \\mathcal{N}(0,\\sigma_y^2)$ 是已知方差为 $\\sigma_y^2$ 的零均值高斯测量噪声。假设状态动力学没有过程噪声。\n\n使用均匀采样周期 $\\Delta t  0$，使得 $t_{k+1} - t_k = \\Delta t$，应用一阶有限差分从测量中获得潜在状态的增量。证明这些增量为 $\\theta$ 的步进漂移定义了一个线性回归模型：\n$$\nz_k \\equiv \\frac{y_{k+1} - y_k}{c \\, \\Delta t} = \\alpha u_k + \\beta + \\varepsilon_k,\n$$\n其中 $\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma_\\varepsilon^2)$ 且 $\\sigma_\\varepsilon^2 = \\frac{2 \\sigma_y^2}{c^2 \\Delta t^2}$。考虑参数向量 $\\mathbf{w} = [\\alpha \\ \\ \\beta]^\\top$，其高斯先验为 $\\mathbf{w} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\boldsymbol{\\Sigma}_0)$，其中 $\\boldsymbol{\\mu}_0 \\in \\mathbb{R}^2$ 和 $\\boldsymbol{\\Sigma}_0 \\in \\mathbb{R}^{2 \\times 2}$ 是给定的。使用带高斯噪声的贝叶斯线性回归来计算后验分布 $\\mathbf{w} \\mid \\{(u_k, z_k)\\}_{k=0}^{K-1}$。\n\n将剩余使用寿命定义为，在给定的未来恒定输入 $u_f$ 和最新的可用测量值 $y_K$ 的条件下，退化状态达到已知失效阈值 $\\theta_{\\text{fail}}$ 的时间。使用最后一次测量形成一个点估计 $\\widehat{\\theta}_K = y_K / c$。在未来恒定输入 $u_f$ 下，瞬时漂移为 $d = \\alpha u_f + \\beta$。因为 $\\alpha$ 和 $\\beta$ 是不确定的，所以通过传递 $\\mathbf{w}$ 的后验分布来计算 $d$ 的后验分布。然后将剩余使用寿命的后验分布定义为随机时间\n$$\nT = \\max\\left(0, \\min\\left(H_{\\max}, \\frac{\\theta_{\\text{fail}} - \\widehat{\\theta}_K}{d}\\right)\\right)\n$$\n并遵循以下约定：如果 $d \\le 0$，系统将不会在有限时间内达到失效阈值，因此 $T = H_{\\max}$。使用蒙特卡洛采样从 $\\mathbf{w}$ 的后验分布中估计 $T$ 的后验均值，采样次数固定为 $N$，并使用固定的随机种子以确保确定性。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 构建回归目标 $z_k = \\frac{y_{k+1} - y_k}{c \\, \\Delta t}$ 和回归量 $\\mathbf{x}_k = [u_k \\ \\ 1]$，观测噪声方差为 $\\sigma_\\varepsilon^2 = \\frac{2 \\sigma_y^2}{c^2 \\Delta t^2}$。\n- 计算高斯后验参数\n$$\n\\boldsymbol{\\Sigma}_N = \\left(\\boldsymbol{\\Sigma}_0^{-1} + \\frac{1}{\\sigma_\\varepsilon^2} \\mathbf{X}^\\top \\mathbf{X}\\right)^{-1}, \\quad\n\\boldsymbol{\\mu}_N = \\boldsymbol{\\Sigma}_N \\left(\\boldsymbol{\\Sigma}_0^{-1} \\boldsymbol{\\mu}_0 + \\frac{1}{\\sigma_\\varepsilon^2} \\mathbf{X}^\\top \\mathbf{z}\\right),\n$$\n其中 $\\mathbf{X} \\in \\mathbb{R}^{K \\times 2}$ 堆叠了行向量 $\\mathbf{x}_k^\\top$，$\\mathbf{z} \\in \\mathbb{R}^K$ 堆叠了标量 $z_k$。\n- 计算 $\\widehat{\\theta}_K = y_K / c$，如果 $\\widehat{\\theta}_K \\ge \\theta_{\\text{fail}}$，则将剩余使用寿命设为 $0$。\n- 否则，抽取 $N$ 个样本 $\\mathbf{w}^{(i)} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_N, \\boldsymbol{\\Sigma}_N)$，计算 $d^{(i)} = \\alpha^{(i)} u_f + \\beta^{(i)}$ 和相应的 $T^{(i)} = \\max\\left(0, \\min\\left(H_{\\max}, \\frac{\\theta_{\\text{fail}} - \\widehat{\\theta}_K}{d^{(i)}}\\right)\\right)$，并遵循规则：当 $d^{(i)} \\le 0$ 时，$T^{(i)} = H_{\\max}$。通过样本均值 $\\frac{1}{N} \\sum_{i=1}^N T^{(i)}$ 来估计后验均值 $\\mathbb{E}[T]$。\n- 将该案例的最终剩余使用寿命表示为一个浮点数（单位：秒），四舍五入到三位小数。\n\n测试套件。您的程序必须解决以下四个案例；每个案例都提供了所有必需的量：\n- 案例 A（一般操作）：\n  - $\\Delta t = 10 \\ \\text{s}$，$c = 2.0$，$\\sigma_y = 0.001$。\n  - 先验 $\\boldsymbol{\\mu}_0 = [0.0 \\ \\ 0.0]^\\top$，$\\boldsymbol{\\Sigma}_0 = \\mathrm{diag}(10^{-4}, 10^{-6})$。\n  - 输入 $\\{u_k\\}_{k=0}^{5} = \\{2.0, 2.0, 2.0, 2.0, 2.0, 2.0\\}$。\n  - 测量 $\\{y_k\\}_{k=0}^{6} = \\{0.4000, 0.4205, 0.4406, 0.4610, 0.4811, 0.5016, 0.5220\\}$。\n  - 失效阈值 $\\theta_{\\text{fail}} = 1.0$。\n  - 未来输入 $u_f = 2.0$。\n  - 时间范围 $H_{\\max} = 10000.0 \\ \\text{s}$。\n  - 采样数 $N = 20000$。\n- 案例 B（接近阈值，磨损更快）：\n  - $\\Delta t = 5 \\ \\text{s}$，$c = 1.5$，$\\sigma_y = 0.002$。\n  - 先验 $\\boldsymbol{\\mu}_0 = [0.0 \\ \\ 0.0]^\\top$，$\\boldsymbol{\\Sigma}_0 = \\mathrm{diag}(10^{-4}, 10^{-6})$。\n  - 输入 $\\{u_k\\}_{k=0}^{3} = \\{5.0, 5.0, 5.0, 5.0\\}$。\n  - 测量 $\\{y_k\\}_{k=0}^{4} = \\{1.2750, 1.3132, 1.3516, 1.3897, 1.4279\\}$。\n  - 失效阈值 $\\theta_{\\text{fail}} = 1.0$。\n  - 未来输入 $u_f = 5.0$。\n  - 时间范围 $H_{\\max} = 1000.0 \\ \\text{s}$。\n  - 采样数 $N = 20000$。\n- 案例 C（低负载，基本无漂移）：\n  - $\\Delta t = 10 \\ \\text{s}$，$c = 1.8$，$\\sigma_y = 0.001$。\n  - 先验 $\\boldsymbol{\\mu}_0 = [0.0 \\ \\ 0.0]^\\top$，$\\boldsymbol{\\Sigma}_0 = \\mathrm{diag}(10^{-4}, 10^{-6})$。\n  - 输入 $\\{u_k\\}_{k=0}^{3} = \\{0.0, 0.0, 0.0, 0.0\\}$。\n  - 测量 $\\{y_k\\}_{k=0}^{4} = \\{0.5400, 0.5402, 0.5398, 0.5401, 0.5400\\}$。\n  - 失效阈值 $\\theta_{\\text{fail}} = 1.0$。\n  - 未来输入 $u_f = 0.0$。\n  - 时间范围 $H_{\\max} = 36000.0 \\ \\text{s}$。\n  - 采样数 $N = 20000$。\n- 案例 D（记录短，噪声高）：\n  - $\\Delta t = 10 \\ \\text{s}$，$c = 2.0$，$\\sigma_y = 0.010$。\n  - 先验 $\\boldsymbol{\\mu}_0 = [0.0 \\ \\ 0.0]^\\top$，$\\boldsymbol{\\Sigma}_0 = \\mathrm{diag}(10^{-4}, 10^{-6})$。\n  - 输入 $\\{u_k\\}_{k=0}^{1} = \\{1.0, 3.0\\}$。\n  - 测量 $\\{y_k\\}_{k=0}^{2} = \\{0.2000, 0.2230, 0.2360\\}$。\n  - 失效阈值 $\\theta_{\\text{fail}} = 1.0$。\n  - 未来输入 $u_f = 2.0$。\n  - 时间范围 $H_{\\max} = 20000.0 \\ \\text{s}$。\n  - 采样数 $N = 20000$。\n\n角度单位不适用。所有时间量必须以秒为单位表示。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[rulA,rulB,rulC,rulD]”），其中每个 $rul$ 是对应案例的后验均值剩余使用寿命，四舍五入到三位小数。",
            "solution": "问题陈述已经过验证，被确定为自洽、有科学依据且定义明确。所述过程是贝叶斯推断在预测性维护中的一个标准（尽管简化了）的应用，这是信息物理系统的一个关键领域。所提供的数据和参数对于所有指定的测试用例都是完整和一致的。因此，我们可以着手提供一个完整的解决方案。\n\n目标是估计CNC主轴的剩余使用寿命（RUL）。这是通过首先使用历史数据估计退化模型的参数，然后将系统状态预测到未来，直到达到失效阈值为止。\n\n内部退化状态 $\\theta(t)$ 的物理模型由一个一阶常微分方程给出：\n$$\n\\dot{\\theta}(t) = \\frac{d\\theta}{dt} = \\alpha u(t) + \\beta\n$$\n在这里，$\\theta(t)$ 表示在时间 $t$ 的磨损或损坏程度，$u(t)$ 是一个已知的控制输入（例如，主轴负载），而 $\\mathbf{w} = [\\alpha \\ \\ \\beta]^\\top$ 是一个未知常数参数向量，它表征了退化过程。\n\n状态 $\\theta(t)$ 无法直接观测。取而代之的是，我们可以在离散时间 $t_k = k \\Delta t$（对于一个恒定的采样周期 $\\Delta t$）获得相关物理量（如振动）的测量值。测量模型是：\n$$\ny_k = c \\theta_k + v_k\n$$\n其中 $\\theta_k = \\theta(t_k)$，$c  0$ 是一个已知的缩放常数，$v_k$ 表示独立同分布（i.i.d.）的测量噪声，建模为零均值高斯随机变量，具有已知方差，即 $v_k \\sim \\mathcal{N}(0, \\sigma_y^2)$。\n\n为了从测量值 $\\{y_k\\}$ 中推断参数 $\\alpha$ 和 $\\beta$，我们首先建立一个线性回归模型。我们使用一阶前向有限差分来近似在时间 $t_k$ 的连续时间导数 $\\dot{\\theta}(t)$：\n$$\n\\dot{\\theta}(t_k) \\approx \\frac{\\theta_{k+1} - \\theta_k}{\\Delta t}\n$$\n将此代入状态动力学方程，得到离散化的状态演化：\n$$\n\\frac{\\theta_{k+1} - \\theta_k}{\\Delta t} \\approx \\alpha u_k + \\beta\n$$\n其中 $u_k = u(t_k)$。该方程假设没有过程噪声。现在，我们用可观测的 $y_k$ 来表示潜在状态 $\\theta_k$。从测量模型中，我们有 $\\theta_k = (y_k - v_k)/c$。将此代入离散化的动力学方程：\n$$\n\\frac{1}{\\Delta t} \\left( \\frac{y_{k+1} - v_{k+1}}{c} - \\frac{y_k - v_k}{c} \\right) = \\alpha u_k + \\beta\n$$\n重新整理各项，将测量值隔离在一边，得到：\n$$\n\\frac{y_{k+1} - y_k}{c \\Delta t} = \\alpha u_k + \\beta + \\frac{v_{k+1} - v_k}{c \\Delta t}\n$$\n这具有线性回归问题的形式。我们定义回归目标 $z_k$ 和噪声项 $\\varepsilon_k$ 如下：\n$$\nz_k \\equiv \\frac{y_{k+1} - y_k}{c \\Delta t}, \\quad \\varepsilon_k \\equiv \\frac{v_{k+1} - v_k}{c \\Delta t}\n$$\n模型变为 $z_k = \\alpha u_k + \\beta + \\varepsilon_k$。由于测量噪声 $v_k$ 是独立同分布的，且 $v_k \\sim \\mathcal{N}(0, \\sigma_y^2)$，噪声项 $\\varepsilon_k$ 也是高斯分布的，其均值为 $\\mathbb{E}[\\varepsilon_k] = \\frac{1}{c\\Delta t}(\\mathbb{E}[v_{k+1}] - \\mathbb{E}[v_k]) = 0$。其方差为：\n$$\n\\sigma_\\varepsilon^2 = \\mathrm{Var}(\\varepsilon_k) = \\mathrm{Var}\\left(\\frac{v_{k+1} - v_k}{c \\Delta t}\\right) = \\frac{1}{c^2 \\Delta t^2} (\\mathrm{Var}(v_{k+1}) + \\mathrm{Var}(-v_k)) = \\frac{\\sigma_y^2 + \\sigma_y^2}{c^2 \\Delta t^2} = \\frac{2 \\sigma_y^2}{c^2 \\Delta t^2}\n$$\n注意，这些噪声项 $\\varepsilon_k$ 是相关的，因为 $\\mathrm{Cov}(\\varepsilon_k, \\varepsilon_{k+1})$ 非零。然而，问题指定使用标准的贝叶斯线性回归模型，该模型假设噪声是独立同分布的，这是一种常见的简化。我们在此指定假设下进行。\n\n对于一组 $K$ 个观测值 $\\{(u_k, z_k)\\}_{k=0}^{K-1}$，我们定义回归向量 $\\mathbf{z} = [z_0, \\dots, z_{K-1}]^\\top$ 和设计矩阵 $\\mathbf{X}$，其行向量为 $\\mathbf{x}_k^\\top = [u_k \\ \\ 1]$。矩阵形式的回归模型为 $\\mathbf{z} = \\mathbf{X}\\mathbf{w} + \\boldsymbol{\\varepsilon}$。\n我们使用贝叶斯线性回归来找到 $\\mathbf{w}$ 的后验分布。给定参数的高斯先验 $\\mathbf{w} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\boldsymbol{\\Sigma}_0)$ 和高斯似然 $p(\\mathbf{z}|\\mathbf{w}) \\sim \\mathcal{N}(\\mathbf{Xw}, \\sigma_\\varepsilon^2 \\mathbf{I})$，后验分布 $p(\\mathbf{w}|\\mathbf{z})$ 也是高斯的，$p(\\mathbf{w}|\\mathbf{z}) \\sim \\mathcal{N}(\\boldsymbol{\\mu}_N, \\boldsymbol{\\Sigma}_N)$，其参数由以下公式给出：\n$$\n\\boldsymbol{\\Sigma}_N = \\left(\\boldsymbol{\\Sigma}_0^{-1} + \\frac{1}{\\sigma_\\varepsilon^2} \\mathbf{X}^\\top \\mathbf{X}\\right)^{-1}\n$$\n$$\n\\boldsymbol{\\mu}_N = \\boldsymbol{\\Sigma}_N \\left(\\boldsymbol{\\Sigma}_0^{-1} \\boldsymbol{\\mu}_0 + \\frac{1}{\\sigma_\\varepsilon^2} \\mathbf{X}^\\top \\mathbf{z}\\right)\n$$\n\n一旦找到 $\\mathbf{w}$ 的后验分布，我们就可以预测 RUL。RUL 是状态 $\\theta(t)$ 从其当前估计值开始，达到预定义失效阈值 $\\theta_{\\text{fail}}$ 所需的时间。当前状态由最后一次测量 $y_K$ 估计为 $\\widehat{\\theta}_K = y_K / c$。如果 $\\widehat{\\theta}_K \\ge \\theta_{\\text{fail}}$，则部件已经失效，其 RUL 为 $0$。\n\n否则，对于给定的未来恒定输入 $u_f$，预期的退化速率（漂移）为 $d = \\alpha u_f + \\beta = [u_f \\ \\ 1]\\mathbf{w}$。由于 $\\mathbf{w}$ 是由其后验分布描述的随机变量，因此漂移 $d$ 也是一个随机变量。达到阈值的时间为 $T_{\\text{reach}} = (\\theta_{\\text{fail}} - \\widehat{\\theta}_K) / d$。\n\n完整的 RUL 被定义为一个随机变量 $T$，它考虑了各种情况：\n$$\nT = \\max\\left(0, \\min\\left(H_{\\max}, \\frac{\\theta_{\\text{fail}} - \\widehat{\\theta}_K}{d}\\right)\\right)\n$$\n并遵循以下约定：如果漂移 $d \\le 0$（即系统没有退化或正在改善），则不会达到失效阈值，RUL 被限制在最大时间范围 $H_{\\max}$。\n\n$T$ 的期望值 $\\mathbb{E}[T]$ 由于除以随机变量 $d$ 而难以解析计算。因此，我们使用蒙特卡洛模拟来估计它：\n1. 从后验分布中抽取 $N$ 个样本 $\\mathbf{w}^{(i)} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_N, \\boldsymbol{\\Sigma}_N)$。\n2. 对于每个样本 $i=1, \\dots, N$，计算漂移样本 $d^{(i)} = \\alpha^{(i)} u_f + \\beta^{(i)}$。\n3. 对于每个 $d^{(i)}$，使用上述定义计算相应的 RUL 样本 $T^{(i)}$。\n4. 估计的 RUL 是样本均值：$\\widehat{\\mathbb{E}[T]} = \\frac{1}{N}\\sum_{i=1}^N T^{(i)}$。\n\n以下程序为每个给定的测试用例实现了这整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RUL estimation problem for all test cases.\n    \"\"\"\n    \n    # A fixed random seed is used to ensure deterministic results for Monte Carlo simulation.\n    RNG = np.random.default_rng(42)\n\n    test_cases = [\n        # Case A (general operation)\n        {\n            \"name\": \"A\",\n            \"delta_t\": 10.0, \"c\": 2.0, \"sigma_y\": 0.001,\n            \"mu_0\": np.array([0.0, 0.0]), \"Sigma_0\": np.diag([1e-4, 1e-6]),\n            \"u\": np.array([2.0, 2.0, 2.0, 2.0, 2.0, 2.0]),\n            \"y\": np.array([0.4000, 0.4205, 0.4406, 0.4610, 0.4811, 0.5016, 0.5220]),\n            \"theta_fail\": 1.0, \"u_f\": 2.0, \"H_max\": 10000.0, \"N\": 20000\n        },\n        # Case B (near-threshold, faster wear)\n        {\n            \"name\": \"B\",\n            \"delta_t\": 5.0, \"c\": 1.5, \"sigma_y\": 0.002,\n            \"mu_0\": np.array([0.0, 0.0]), \"Sigma_0\": np.diag([1e-4, 1e-6]),\n            \"u\": np.array([5.0, 5.0, 5.0, 5.0]),\n            \"y\": np.array([1.2750, 1.3132, 1.3516, 1.3897, 1.4279]),\n            \"theta_fail\": 1.0, \"u_f\": 5.0, \"H_max\": 1000.0, \"N\": 20000\n        },\n        # Case C (low load, essentially no drift)\n        {\n            \"name\": \"C\",\n            \"delta_t\": 10.0, \"c\": 1.8, \"sigma_y\": 0.001,\n            \"mu_0\": np.array([0.0, 0.0]), \"Sigma_0\": np.diag([1e-4, 1e-6]),\n            \"u\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"y\": np.array([0.5400, 0.5402, 0.5398, 0.5401, 0.5400]),\n            \"theta_fail\": 1.0, \"u_f\": 0.0, \"H_max\": 36000.0, \"N\": 20000\n        },\n        # Case D (short record, high noise)\n        {\n            \"name\": \"D\",\n            \"delta_t\": 10.0, \"c\": 2.0, \"sigma_y\": 0.010,\n            \"mu_0\": np.array([0.0, 0.0]), \"Sigma_0\": np.diag([1e-4, 1e-6]),\n            \"u\": np.array([1.0, 3.0]),\n            \"y\": np.array([0.2000, 0.2230, 0.2360]),\n            \"theta_fail\": 1.0, \"u_f\": 2.0, \"H_max\": 20000.0, \"N\": 20000\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        delta_t, c, sigma_y = case[\"delta_t\"], case[\"c\"], case[\"sigma_y\"]\n        mu_0, Sigma_0 = case[\"mu_0\"], case[\"Sigma_0\"]\n        u, y = case[\"u\"], case[\"y\"]\n        theta_fail, u_f, H_max, N = case[\"theta_fail\"], case[\"u_f\"], case[\"H_max\"], case[\"N\"]\n\n        # Step 1: Check if already failed\n        K_idx = len(u)\n        y_K = y[K_idx]\n        theta_hat_K = y_K / c\n        \n        if theta_hat_K >= theta_fail:\n            results.append(0.0)\n            continue\n            \n        # Step 2: Construct regression targets and design matrix\n        num_regression_points = len(u)\n        z = np.zeros(num_regression_points)\n        for k in range(num_regression_points):\n            z[k] = (y[k+1] - y[k]) / (c * delta_t)\n        \n        X = np.ones((num_regression_points, 2))\n        X[:, 0] = u\n\n        # Step 3: Compute regression noise variance\n        sigma_eps_sq = (2 * sigma_y**2) / (c**2 * delta_t**2)\n\n        # Step 4: Compute posterior parameters\n        Sigma_0_inv = np.linalg.inv(Sigma_0)\n        XTX = X.T @ X\n        \n        Sigma_N = np.linalg.inv(Sigma_0_inv + (1 / sigma_eps_sq) * XTX)\n        \n        XTz = X.T @ z\n        mu_N = Sigma_N @ (Sigma_0_inv @ mu_0 + (1 / sigma_eps_sq) * XTz)\n\n        # Step 5: Monte Carlo simulation for RUL\n        # Draw N samples for w = [alpha, beta]\n        w_samples = RNG.multivariate_normal(mu_N, Sigma_N, size=N)\n        \n        # Compute drift d for each sample\n        d_samples = w_samples[:, 0] * u_f + w_samples[:, 1]\n        \n        # Calculate time-to-failure for each sample\n        delta_theta = theta_fail - theta_hat_K\n        \n        # Initialize all RUL samples to H_max (handles d = 0 case)\n        T_samples = np.full(N, H_max)\n        \n        # Identify samples with positive drift\n        positive_d_mask = d_samples > 0\n        \n        # Calculate RUL for positive drift samples\n        d_positive = d_samples[positive_d_mask]\n        T_uncensored = delta_theta / d_positive\n        \n        # Apply max(0, min(H_max, ...)) as per problem statement\n        T_calculated = np.maximum(0.0, np.minimum(H_max, T_uncensored))\n        \n        T_samples[positive_d_mask] = T_calculated\n        \n        # Estimate posterior mean RUL\n        mean_rul = np.mean(T_samples)\n        \n        results.append(round(mean_rul, 3))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}