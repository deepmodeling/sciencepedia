{
    "hands_on_practices": [
        {
            "introduction": "Understanding the theoretical connection between a formal language and its minimal automaton is fundamental to creating efficient models. This practice challenges you to derive the size of the most compact Deterministic Finite Automaton (DFA) for a given language by reasoning from first principles . Instead of using graphical algorithms, you will apply the concept of string indistinguishability, which is the core idea behind the Myhill-Nerode theorem, to find the exact number of states required, a crucial skill for optimizing the memory footprint of monitors in a digital twin.",
            "id": "4222765",
            "problem": "A digital twin of a Cyber-Physical System (CPS) models discrete event streams using a deterministic finite automaton (DFA), defined as a quintuple $(Q,\\Sigma,\\delta,q_0,F)$, where $Q$ is a finite set of states, $\\Sigma$ is a finite alphabet, $\\delta:Q\\times\\Sigma\\to Q$ is the transition function, $q_0\\in Q$ is the initial state, and $F\\subseteq Q$ is the set of accepting states. The DFA in use currently has $10$ states and recognizes the language\n$$\nL=\\{\\,w\\in\\{a,b\\}^{*}\\mid \\text{the number of occurrences of }a\\text{ in }w\\text{ modulo }3\\text{ equals }1\\,\\}.\n$$\nThis language models a control requirement in which only sequences with the count of the event $a$ congruent to $1$ modulo $3$ are considered valid, while $b$ represents a neutral event that does not change this validity criterion.\n\nStarting strictly from the core definitions of a DFA and the indistinguishability of strings with respect to a language (i.e., the equivalence relation that two strings are equivalent if no continuation from the alphabet can distinguish their membership in $L$), and without drawing or referencing any particular construction beyond these definitions, determine the exact number of states in the unique minimal DFA (up to isomorphism) that recognizes $L$. Your final answer must be a single integer. No rounding is necessary.",
            "solution": "The problem requires determining the number of states in the unique minimal Deterministic Finite Automaton (DFA) for a given language $L$. The solution must be derived strictly from the definition of the indistinguishability of strings.\n\nThe Myhill-Nerode theorem states that the number of states in the minimal DFA that recognizes a language $L$ is equal to the number of equivalence classes of the Myhill-Nerode relation, $R_L$. This relation is also known as the indistinguishability relation.\n\nThe relation $R_L$ is defined on the set of all strings $\\Sigma^*$. Two strings $x, y \\in \\Sigma^*$ are said to be indistinguishable with respect to $L$, denoted $x \\ R_L \\ y$, if for every string $z \\in \\Sigma^*$, the condition $xz \\in L \\iff yz \\in L$ holds. In other words, no \"continuation\" string $z$ can distinguish whether the prefixed strings $x$ or $y$ result in a final string that belongs to the language $L$. The states of the minimal DFA correspond bijectively to these equivalence classes.\n\nThe language specified in the problem is $L = \\{w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 1 \\pmod 3\\}$, where $n_a(w)$ is the number of occurrences of the symbol $a$ in the string $w$. The alphabet is $\\Sigma = \\{a, b\\}$.\n\nWe seek to characterize the equivalence classes of $R_L$ for this language. By definition, $x \\ R_L \\ y$ if and only if for all $z \\in \\{a, b\\}^*$, we have:\n$$\nn_a(xz) \\equiv 1 \\pmod 3 \\iff n_a(yz) \\equiv 1 \\pmod 3\n$$\nUsing the additive property of character counts in string concatenation, $n_a(uv) = n_a(u) + n_a(v)$, the condition becomes:\n$$\nn_a(x) + n_a(z) \\equiv 1 \\pmod 3 \\iff n_a(y) + n_a(z) \\equiv 1 \\pmod 3\n$$\nThis condition must hold for any choice of $z \\in \\{a, b\\}^*$, which means it must hold for any possible value of $n_a(z) \\ge 0$.\n\nLet us prove that the above condition is equivalent to $n_a(x) \\equiv n_a(y) \\pmod 3$.\n\nFirst, assume $n_a(x) \\equiv n_a(y) \\pmod 3$. Then for any integer $n_a(z)$, it is guaranteed that $n_a(x) + n_a(z) \\equiv n_a(y) + n_a(z) \\pmod 3$. Therefore, if the expression on the left is congruent to $1$ modulo $3$, the expression on the right must also be congruent to $1$ modulo $3$. This satisfies the definition of indistinguishability, so $x \\ R_L \\ y$.\n\nConversely, assume $x \\ R_L \\ y$. We must show that $n_a(x) \\equiv n_a(y) \\pmod 3$. We will use proof by contradiction. Suppose that $n_a(x) \\not\\equiv n_a(y) \\pmod 3$. Let $k_x = n_a(x) \\pmod 3$ and $k_y = n_a(y) \\pmod 3$. Our supposition means $k_x \\neq k_y$, where $k_x, k_y \\in \\{0, 1, 2\\}$. Since $x \\ R_L \\ y$, no string $z$ can distinguish them. Let us attempt to find such a distinguishing string $z$.\n\nWe want to find a $z$ such that $xz \\in L$ but $yz \\notin L$ (or vice-versa). The condition for $xz \\in L$ is $n_a(x) + n_a(z) \\equiv 1 \\pmod 3$, which simplifies to $k_x + n_a(z) \\equiv 1 \\pmod 3$. This is equivalent to $n_a(z) \\equiv (1 - k_x) \\pmod 3$. We can always choose a string $z$ that satisfies this condition. For instance, if $(1 - k_x) \\pmod 3 = 0$, we can choose $z = \\epsilon$ (the empty string). If $(1 - k_x) \\pmod 3 = 1$, we can choose $z = a$. If $(1 - k_x) \\pmod 3 = 2$, we can choose $z = aa$.\nLet's select such a $z$. By our choice, $n_a(xz) \\equiv 1 \\pmod 3$, so $xz \\in L$.\n\nNow we check the membership of $yz$ in $L$. The condition is $n_a(yz) \\equiv 1 \\pmod 3$. This is equivalent to $n_a(y) + n_a(z) \\equiv 1 \\pmod 3$, or $k_y + n_a(z) \\equiv 1 \\pmod 3$. Substituting the congruence for $n_a(z)$, we get $k_y + (1 - k_x) \\equiv 1 \\pmod 3$. This simplifies to $k_y - k_x \\equiv 0 \\pmod 3$, or $k_y \\equiv k_x \\pmod 3$. However, this contradicts our initial supposition that $k_x \\neq k_y$.\n\nTherefore, our choice of $z$ makes $xz \\in L$ but $yz \\notin L$. This string $z$ distinguishes $x$ and $y$, which contradicts the premise that $x \\ R_L \\ y$. The only way to resolve the contradiction is to reject the supposition. Thus, it must be true that $n_a(x) \\equiv n_a(y) \\pmod 3$.\n\nWe have demonstrated that the indistinguishability relation $R_L$ partitions the set of all strings $\\Sigma^*$ according to the value of $n_a(w) \\pmod 3$. The possible values for this congruence are $0$, $1$, and $2$. This leads to exactly three distinct equivalence classes:\n1. $C_0 = \\{ w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 0 \\pmod 3 \\}$\n2. $C_1 = \\{ w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 1 \\pmod 3 \\}$\n3. $C_2 = \\{ w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 2 \\pmod 3 \\}$\n\nAny string in $\\{a,b\\}^*$ belongs to exactly one of these classes. For example, the empty string $\\epsilon$ is in $C_0$, the string $a$ is in $C_1$, and the string $aa$ is in $C_2$.\n\nAccording to the Myhill-Nerode theorem, the number of states in the minimal DFA is the number of these equivalence classes. Since there are precisely $3$ such classes, the minimal DFA recognizing $L$ must have $3$ states. The information that the current DFA has $10$ states is extraneous and indicates that the current implementation is not minimal.",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "In many cyber-physical systems, a key task is to verify that a system's behavior, modeled by one automaton, adheres to a specification, modeled by another. This often involves checking for behaviors that are allowed by the system but forbidden by the specification. This exercise guides you through the formal process of constructing a new DFA that recognizes the set-theoretic difference between two languages . This technique, known as the product construction, is a powerful tool for building runtime monitors that can detect and flag non-compliant system traces.",
            "id": "4222760",
            "problem": "A Digital Twin in a Cyber-Physical System (CPS) uses runtime monitors built from Deterministic Finite Automata (DFA) to compare observed trace sequences against both a plant model and a supervisory controller specification. Let $A_1 = (Q_1, \\Sigma, \\delta_1, q_{1,0}, F_1)$ and $A_2 = (Q_2, \\Sigma, \\delta_2, q_{2,0}, F_2)$ be two complete Deterministic Finite Automata (DFA) over the same finite alphabet $\\Sigma$, where $\\delta_1$ and $\\delta_2$ are total transition functions and $F_1 \\subseteq Q_1$, $F_2 \\subseteq Q_2$ are sets of accepting states. The Digital Twin needs a monitor that accepts exactly those traces in $L(A_1)$ that are not in $L(A_2)$, i.e., the set-theoretic language difference $L(A_1) \\setminus L(A_2)$.\n\nStarting from the formal semantic definitions of a Deterministic Finite Automaton (DFA), the meaning of acceptance, and the set-theoretic definition of language difference, construct a DFA $A_{\\Delta}$ that recognizes $L(A_1) \\setminus L(A_2)$. Derive the state space, transition function, initial state, and accepting set of $A_{\\Delta}$ in terms of $A_1$ and $A_2$, and prove its correctness from first principles of DFA semantics and set operations on languages without relying on any pre-packaged construction rules.\n\nThen, compute a tight upper bound on the number of states of $A_{\\Delta}$ in terms of $|Q_1|$ and $|Q_2|$. Your final answer must be a single closed-form expression. No rounding is required. No units are required.",
            "solution": "We are given two complete DFAs, $A_1 = (Q_1, \\Sigma, \\delta_1, q_{1,0}, F_1)$ and $A_2 = (Q_2, \\Sigma, \\delta_2, q_{2,0}, F_2)$. A DFA $A = (Q, \\Sigma, \\delta, q_0, F)$ accepts a string $w \\in \\Sigma^*$ if and only if the machine, starting in its initial state $q_0$, finishes in\nan accepting state in $F$ after processing the entire string $w$.\n\nTo formalize this, we define the extended transition function, $\\hat{\\delta}: Q \\times \\Sigma^* \\to Q$, which gives the state the automaton is in after processing an entire string. It is defined recursively:\n$1.$ For the empty string $\\epsilon$, $\\hat{\\delta}(q, \\epsilon) = q$ for any state $q \\in Q$.\n$2.$ For a string $w \\in \\Sigma^*$ and a symbol $a \\in \\Sigma$, $\\hat{\\delta}(q, wa) = \\delta(\\hat{\\delta}(q, w), a)$ for any state $q \\in Q$.\n\nThe language accepted by a DFA $A$, denoted $L(A)$, is the set of all strings that take the automaton from its initial state to an accepting state:\n$$L(A) = \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\}$$\n\nThe problem requires constructing a DFA, let's call it $A_{\\Delta}$, that recognizes the language difference $L(A_1) \\setminus L(A_2)$. By the definition of set difference, this language is:\n$$L(A_1) \\setminus L(A_2) = \\{ w \\in \\Sigma^* \\mid w \\in L(A_1) \\text{ and } w \\notin L(A_2) \\}$$\nUsing the formal definition of language acceptance, we can express this condition in terms of the components of $A_1$ and $A_2$. A string $w$ belongs to this language if and only if:\n$$\\hat{\\delta}_1(q_{1,0}, w) \\in F_1 \\quad \\text{and} \\quad \\hat{\\delta}_2(q_{2,0}, w) \\notin F_2$$\n\nTo check this compound condition, we need to know the state of *both* automata, $A_1$ and $A_2$, after processing the string $w$. This suggests a construction where the states of our new automaton $A_{\\Delta}$ are pairs of states, one from $A_1$ and one from $A_2$. This is known as the product construction.\n\nLet us define the DFA $A_{\\Delta} = (Q_{\\Delta}, \\Sigma, \\delta_{\\Delta}, q_{\\Delta, 0}, F_{\\Delta})$ as follows:\n\n$1.$ **State Space $Q_{\\Delta}$**: The state space is the Cartesian product of the state spaces of $A_1$ and $A_2$. A state $(p, q) \\in Q_{\\Delta}$ tracks that $A_1$ would be in state $p \\in Q_1$ and $A_2$ would be in state $q \\in Q_2$.\n$$Q_{\\Delta} = Q_1 \\times Q_2 = \\{ (p, q) \\mid p \\in Q_1, q \\in Q_2 \\}$$\n\n$2.$ **Initial State $q_{\\Delta, 0}$**: The simulation starts with both $A_1$ and $A_2$ in their respective initial states.\n$$q_{\\Delta, 0} = (q_{1,0}, q_{2,0})$$\n\n$3.$ **Transition Function $\\delta_{\\Delta}$**: When in state $(p, q)$ and reading a symbol $a \\in \\Sigma$, the new state is determined by applying the respective transition functions of $A_1$ and $A_2$.\n$$\\delta_{\\Delta}: Q_{\\Delta} \\times \\Sigma \\to Q_{\\Delta}$$\n$$\\delta_{\\Delta}((p, q), a) = (\\delta_1(p, a), \\delta_2(q, a)) \\quad \\text{for all } (p,q) \\in Q_{\\Delta}, a \\in \\Sigma$$\n\n$4.$ **Accepting States $F_{\\Delta}$**: A string $w$ should be accepted by $A_{\\Delta}$ if and only if it is accepted by $A_1$ but not by $A_2$. This means that after processing $w$, a state $(p,q)$ is reached where $p$ is an accepting state of $A_1$ and $q$ is a *non-accepting* state of $A_2$.\n$$F_{\\Delta} = \\{ (p, q) \\in Q_1 \\times Q_2 \\mid p \\in F_1 \\text{ and } q \\notin F_2 \\}$$\nThis can be written more compactly as $F_{\\Delta} = F_1 \\times (Q_2 \\setminus F_2)$.\n\n**Proof of Correctness:**\nWe must prove that $L(A_{\\Delta}) = L(A_1) \\setminus L(A_2)$. To do this, we first establish a crucial lemma relating the extended transition function $\\hat{\\delta}_{\\Delta}$ to $\\hat{\\delta}_1$ and $\\hat{\\delta}_2$.\n\n**Lemma:** For any state $(p, q) \\in Q_{\\Delta}$ and any string $w \\in \\Sigma^*$, $\\hat{\\delta}_{\\Delta}((p, q), w) = (\\hat{\\delta}_1(p, w), \\hat{\\delta}_2(q, w))$.\n**Proof of Lemma (by induction on the length of $w$):**\n- **Base Case:** Let $|w| = 0$, so $w = \\epsilon$.\nBy definition of $\\hat{\\delta}$, $\\hat{\\delta}_{\\Delta}((p, q), \\epsilon) = (p, q)$.\nAlso, $(\\hat{\\delta}_1(p, \\epsilon), \\hat{\\delta}_2(q, \\epsilon)) = (p, q)$.\nThe lemma holds for $|w|=0$.\n- **Inductive Step:** Assume the lemma holds for all strings $w$ of length $n \\ge 0$. Let $x$ be a string of length $n+1$, so $x = wa$ for some $w \\in \\Sigma^*$ with $|w|=n$ and $a \\in \\Sigma$.\n\\begin{align*}\n\\hat{\\delta}_{\\Delta}((p, q), wa) &= \\delta_{\\Delta}(\\hat{\\delta}_{\\Delta}((p, q), w), a) && \\text{(by definition of } \\hat{\\delta}_{\\Delta}) \\\\\n&= \\delta_{\\Delta}((\\hat{\\delta}_1(p, w), \\hat{\\delta}_2(q, w)), a) && \\text{(by inductive hypothesis)} \\\\\n&= (\\delta_1(\\hat{\\delta}_1(p, w), a), \\delta_2(\\hat{\\delta}_2(q, w), a)) && \\text{(by definition of } \\delta_{\\Delta}) \\\\\n&= (\\hat{\\delta}_1(p, wa), \\hat{\\delta}_2(q, wa)) && \\text{(by definition of } \\hat{\\delta}_1, \\hat{\\delta}_2)\n\\end{align*}\nThus, the lemma holds for all strings $w \\in \\Sigma^*$.\n\n**Main Proof:**\nNow we show that for any string $w \\in \\Sigma^*$, $w \\in L(A_{\\Delta})$ if and only if $w \\in L(A_1) \\setminus L(A_2)$.\n\\begin{align*}\nw \\in L(A_{\\Delta}) &\\iff \\hat{\\delta}_{\\Delta}(q_{\\Delta, 0}, w) \\in F_{\\Delta} && \\text{(by definition of } L(A_{\\Delta})) \\\\\n&\\iff \\hat{\\delta}_{\\Delta}((q_{1,0}, q_{2,0}), w) \\in F_{\\Delta} && \\text{(by definition of } q_{\\Delta, 0}) \\\\\n&\\iff (\\hat{\\delta}_1(q_{1,0}, w), \\hat{\\delta}_2(q_{2,0}, w)) \\in F_{\\Delta} && \\text{(by the lemma)} \\\\\n&\\iff \\hat{\\delta}_1(q_{1,0}, w) \\in F_1 \\text{ and } \\hat{\\delta}_2(q_{2,0}, w) \\notin F_2 && \\text{(by definition of } F_{\\Delta}) \\\\\n&\\iff (w \\in L(A_1)) \\text{ and } (w \\notin L(A_2)) && \\text{(by definition of } L(A_1), L(A_2)) \\\\\n&\\iff w \\in L(A_1) \\setminus L(A_2) && \\text{(by definition of set difference)}\n\\end{align*}\nThe equivalence holds, thus we have proven that the constructed DFA $A_{\\Delta}$ correctly recognizes the language $L(A_1) \\setminus L(A_2)$.\n\n**Upper Bound on the Number of States:**\nThe number of states in our constructed automaton $A_{\\Delta}$ is $|Q_{\\Delta}|$. From the construction, we have $Q_{\\Delta} = Q_1 \\times Q_2$. The cardinality of the Cartesian product of two finite sets is the product of their individual cardinalities. Therefore:\n$$|Q_{\\Delta}| = |Q_1 \\times Q_2| = |Q_1| \\cdot |Q_2|$$\nThis gives an upper bound on the number of states in a DFA for the language difference. This bound is tight, meaning there exist DFAs $A_1$ and $A_2$ for which the minimal DFA recognizing $L(A_1) \\setminus L(A_2)$ requires $|Q_1| \\cdot |Q_2|$ states. This occurs when all states in the product construction are reachable from the initial state $(q_{1,0}, q_{2,0})$ and are pairwise distinguishable. For example, if $A_1$ is a counter modulo $|Q_1|$ and $A_2$ is a counter modulo $|Q_2|$ on different symbols, all $|Q_1| \\cdot |Q_2|$ states in the product are reachable. Thus, the quantity $|Q_1| \\cdot |Q_2|$ is a tight upper bound.",
            "answer": "$$\n\\boxed{|Q_1| |Q_2|}\n$$"
        },
        {
            "introduction": "While basic finite automata are powerful, the complexity of modern systems often demands more expressive models like statecharts, which feature hierarchy and history. This practice requires you to manually trace the execution of a hierarchical state machine that includes nested states and a shallow history connector . Mastering the intricate semantics of event processing, default entries, and history-based transitions is essential for accurately modeling and debugging the sophisticated mode-switching logic found in advanced digital twins.",
            "id": "4222783",
            "problem": "A digital twin of a process valve in a Cyber-Physical System (CPS) uses a hierarchical statechart to govern mode switching between two control regimes. The controller is modeled as a state machine with one top-level composite state $M$ equipped with a shallow history connector and one external quiescent state $O$. The shallow history connector on $M$ remembers the most recently active immediate substate of $M$ upon exit from $M$, and upon reentry targets that immediate substate (but, because it is shallow history, does not remember any deeper nested substate). The following structure and event semantics hold.\n\n- The top-level composite state $M$ has exactly two immediate substates: composite substate $A$ and composite substate $B$. The default initial substate of $M$ is $A$.\n- Substate $A$ contains two simple substates, $a_1$ (default initial) and $a_2$. There is exactly one internal transition in $A$, labeled by event $e$, that toggles between $a_1$ and $a_2$: on $e$, $a_1 \\rightarrow a_2$ and $a_2 \\rightarrow a_1$.\n- Substate $B$ contains three simple substates, $b_1$ (default initial), $b_2$, and $b_3$, arranged in a cycle under event $e$: on $e$, $b_1 \\rightarrow b_2$, $b_2 \\rightarrow b_3$, and $b_3 \\rightarrow b_1$.\n- At the level of $M$, there are event-triggered transitions: on event $\\mathrm{sw}$, the machine switches between $A$ and $B$ (i.e., if in $A$ then $A \\rightarrow B$, and if in $B$ then $B \\rightarrow A$). Such a switch is a direct target to the indicated immediate substate and, by default entry semantics, enters its default initial nested substate. On event $\\mathrm{out}$, the machine exits $M$ to $O$. On event $\\mathrm{in}$, the machine enters $M$ from $O$ through $M$â€™s shallow history connector. If there is no recorded history for $M$, the default initial substate $A$ is entered; otherwise, the most recently active immediate substate of $M$ is reentered, and then default entry semantics apply within that substate. There are no entry, exit, or do actions anywhere, and events are processed with run-to-completion semantics.\n\nThe machine starts in $O$ with no recorded history for $M$. Consider the following input trace applied to the machine, where the notation $e^{k}$ denotes $k$ consecutive occurrences of event $e$, and all other events are a single occurrence: \n$\\mathrm{in},\\, e^{5},\\, \\mathrm{sw},\\, e^{8},\\, \\mathrm{out},\\, \\mathrm{in},\\, e^{7},\\, \\mathrm{sw},\\, e^{9},\\, \\mathrm{out},\\, \\mathrm{in},\\, e^{11}$.\n\nDefine a coding function $c(\\cdot)$ for the five possible nested simple substates of $M$ as follows: $c(A.a_1)=1$, $c(A.a_2)=2$, $c(B.b_1)=3$, $c(B.b_2)=4$, and $c(B.b_3)=5$. Using only the foundational semantics of hierarchical state machines with shallow history and default entry, determine the code $c(\\cdot)$ of the final active nested simple substate of $M$ after processing the entire input trace. Provide your answer as a single integer with no units. No rounding is required.",
            "solution": "We will trace the state of the machine for the given input sequence. The state configuration is denoted by the active simple substate (e.g., $A.a_1$). The history state of $M$ is denoted by $H(M)$.\n\n1.  **Initial State**: The machine is in state $O$. The history of $M$, $H(M)$, is initially empty.\n\n2.  **Event `in`**: The machine transitions from $O$ to $M$. Since $H(M)$ is empty, the machine enters the default initial substate of $M$, which is $A$. Subsequently, it enters the default initial substate of $A$, which is $a_1$.\n    - Current State: $A.a_1$.\n\n3.  **Event $e^5$**: The machine is in substate $A$, where event $e$ causes a toggle between $a_1$ and $a_2$. This is a cycle of length $2$. Starting in $a_1$, after $5$ occurrences of $e$, the final state is determined by the number of transitions modulo $2$. Since $5 \\pmod{2} = 1$, the machine undergoes one net transition from $a_1$.\n    - Transition: $a_1 \\to a_2$.\n    - Current State: $A.a_2$.\n\n4.  **Event `sw`**: The machine is in a substate of $A$. The event $\\mathrm{sw}$ triggers the transition $A \\to B$. The machine enters state $B$ and, by default entry semantics, enters the default initial substate of $B$, which is $b_1$.\n    - Current State: $B.b_1$.\n\n5.  **Event $e^8$**: The machine is in substate $B$, where event $e$ causes transitions in the cycle $b_1 \\to b_2 \\to b_3 \\to b_1$. This is a cycle of length $3$. Starting in $b_1$, after $8$ occurrences of $e$, the final state is determined by $8 \\pmod{3} = 2$. This corresponds to two transitions from $b_1$.\n    - Transitions: $b_1 \\to b_2 \\to b_3$.\n    - Current State: $B.b_3$.\n\n6.  **Event `out`**: The machine is in state $M$ (specifically, $B.b_3$). The event `out` triggers the transition $M \\to O$. Upon exiting $M$, the shallow history connector records the most recently active immediate substate of $M$, which was $B$.\n    - Current State: $O$.\n    - History Update: $H(M) = B$.\n\n7.  **Event `in`**: The machine transitions from $O$ to $M$. Since history exists ($H(M) = B$), the machine re-enters state $B$. The problem specifies shallow history, meaning only the immediate substate $B$ is restored, not the deeper substate $b_3$. Default entry semantics then apply within $B$, so the machine enters $b_1$.\n    - Current State: $B.b_1$.\n\n8.  **Event $e^7$**: The machine is in state $B.b_1$. After $7$ occurrences of $e$, the state is determined by $7 \\pmod{3} = 1$. This corresponds to one transition from $b_1$.\n    - Transition: $b_1 \\to b_2$.\n    - Current State: $B.b_2$.\n\n9.  **Event `sw`**: The machine is in a substate of $B$. The event $\\mathrm{sw}$ triggers the transition $B \\to A$. The machine enters state $A$ and its default initial substate $a_1$.\n    - Current State: $A.a_1$.\n\n10. **Event $e^9$**: The machine is in state $A.a_1$. After $9$ occurrences of $e$, the state is determined by $9 \\pmod{2} = 1$. This corresponds to one transition from $a_1$.\n    - Transition: $a_1 \\to a_2$.\n    - Current State: $A.a_2$.\n\n11. **Event `out`**: The machine is in state $M$ (specifically, $A.a_2$). The event `out` triggers the transition $M \\to O$. The history is updated to reflect that $A$ was the last active immediate substate.\n    - Current State: $O$.\n    - History Update: $H(M) = A$.\n\n12. **Event `in`**: The machine transitions from $O$ to $M$. History is $H(M)=A$, so the machine re-enters state $A$. By shallow history semantics, it then enters the default initial substate of $A$, which is $a_1$.\n    - Current State: $A.a_1$.\n\n13. **Event $e^{11}$**: The machine is in state $A.a_1$. After $11$ occurrences of $e$, the state is determined by $11 \\pmod{2} = 1$. This corresponds to one transition from $a_1$.\n    - Transition: $a_1 \\to a_2$.\n    - Final State: $A.a_2$.\n\nThe final active nested simple substate of the machine after processing the entire input trace is $A.a_2$. According to the provided coding function $c(\\cdot)$, we have $c(A.a_2)=2$.",
            "answer": "$$\n\\boxed{2}\n$$"
        }
    ]
}