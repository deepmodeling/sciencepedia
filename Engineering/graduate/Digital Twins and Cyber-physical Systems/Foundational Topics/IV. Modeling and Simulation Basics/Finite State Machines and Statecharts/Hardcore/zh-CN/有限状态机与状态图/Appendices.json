{
    "hands_on_practices": [
        {
            "introduction": "在数字孪生和信息物理系统的设计中，状态机的效率至关重要，尤其是在资源受限的嵌入式环境中。此练习将引导您应用 Myhill-Nerode 定理，从字符串不可区分性的基本定义出发，确定一个给定语言的最小确定性有限自动机（DFA）的状态数。通过这个实践，您将深入理解状态的本质，并学会如何从理论上保证模型的最优化。",
            "id": "4222765",
            "problem": "一个信息物理系统 (CPS) 的数字孪生使用一个确定性有限自动机 (DFA) 来建模离散事件流。该 DFA 定义为一个五元组 $(Q,\\Sigma,\\delta,q_0,F)$，其中 $Q$ 是一个有限状态集，$\\Sigma$ 是一个有限字母表，$\\delta:Q\\times\\Sigma\\to Q$ 是转移函数，$q_0\\in Q$ 是初始状态，$F\\subseteq Q$ 是接受状态集。当前使用的 DFA 有 $10$ 个状态，并识别语言\n$$\nL=\\{\\,w\\in\\{a,b\\}^{*}\\mid w\\text{ 中 }a\\text{ 的出现次数模 }3\\text{ 等于 }1\\,\\}。\n$$\n该语言建模了一个控制要求，其中只有事件 $a$ 的出现次数与 $1$ 模 $3$ 同余的序列才被认为是有效的，而 $b$ 代表一个不改变此有效性标准的中性事件。\n\n严格从 DFA 的核心定义和关于一个语言的字符串不可区分性（即，如果字母表中的任何后续字符串都无法区分它们在 $L$ 中的成员资格，则两个字符串等价的等价关系）出发，并且不画图或引用超出这些定义的任何特定构造，确定识别 $L$ 的唯一最小 DFA（在同构意义下）的确切状态数。你的最终答案必须是一个整数。无需四舍五入。",
            "solution": "该问题要求确定识别给定语言 $L$ 的唯一最小确定性有限自动机 (DFA) 的状态数。解决方案必须严格从字符串不可区分性的定义推导出来。\n\nMyhill-Nerode 定理指出，识别语言 $L$ 的最小 DFA 的状态数等于 Myhill-Nerode 关系 $R_L$ 的等价类的数量。这个关系也称为不可区分关系。\n\n关系 $R_L$ 定义在所有字符串的集合 $\\Sigma^*$ 上。对于两个字符串 $x, y \\in \\Sigma^*$，如果对于每个字符串 $z \\in \\Sigma^*$，条件 $xz \\in L \\iff yz \\in L$ 都成立，那么我们称它们关于 $L$ 是不可区分的，记作 $x \\ R_L \\ y$。换句话说，没有任何“后续”字符串 $z$ 能够区分前缀字符串 $x$ 或 $y$ 是否导致最终字符串属于语言 $L$。最小 DFA 的状态与这些等价类一一对应。\n\n问题中指定的语言是 $L = \\{w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 1 \\pmod 3\\}$，其中 $n_a(w)$ 是符号 $a$ 在字符串 $w$ 中出现的次数。字母表是 $\\Sigma = \\{a, b\\}$。\n\n我们试图为该语言刻画 $R_L$ 的等价类。根据定义，$x \\ R_L \\ y$ 当且仅当对于所有 $z \\in \\{a, b\\}^*$，我们有：\n$$\nn_a(xz) \\equiv 1 \\pmod 3 \\iff n_a(yz) \\equiv 1 \\pmod 3\n$$\n利用字符串拼接中字符计数的加性性质 $n_a(uv) = n_a(u) + n_a(v)$，该条件变为：\n$$\nn_a(x) + n_a(z) \\equiv 1 \\pmod 3 \\iff n_a(y) + n_a(z) \\equiv 1 \\pmod 3\n$$\n这个条件必须对任何 $z \\in \\{a, b\\}^*$ 的选择都成立，这意味着它必须对任何可能的 $n_a(z) \\ge 0$ 的值都成立。\n\n让我们证明上述条件等价于 $n_a(x) \\equiv n_a(y) \\pmod 3$。\n\n首先，假设 $n_a(x) \\equiv n_a(y) \\pmod 3$。那么对于任何整数 $n_a(z)$，可以保证 $n_a(x) + n_a(z) \\equiv n_a(y) + n_a(z) \\pmod 3$。因此，如果左边的表达式模 $3$ 同余于 $1$，右边的表达式也必须模 $3$ 同余于 $1$。这满足了不可区分性的定义，所以 $x \\ R_L \\ y$。\n\n反过来，假设 $x \\ R_L \\ y$。我们必须证明 $n_a(x) \\equiv n_a(y) \\pmod 3$。我们将使用反证法。假设 $n_a(x) \\not\\equiv n_a(y) \\pmod 3$。令 $k_x = n_a(x) \\pmod 3$ 且 $k_y = n_a(y) \\pmod 3$。我们的假设意味着 $k_x \\neq k_y$，其中 $k_x, k_y \\in \\{0, 1, 2\\}$。由于 $x \\ R_L \\ y$，没有字符串 $z$ 能区分它们。让我们尝试找到这样一个起区分作用的字符串 $z$。\n\n我们想找到一个 $z$ 使得 $xz \\in L$ 但 $yz \\notin L$（或反之）。$xz \\in L$ 的条件是 $n_a(x) + n_a(z) \\equiv 1 \\pmod 3$，这可以简化为 $k_x + n_a(z) \\equiv 1 \\pmod 3$。这等价于 $n_a(z) \\equiv (1 - k_x) \\pmod 3$。我们总能选择一个满足此条件的字符串 $z$。例如，如果 $(1 - k_x) \\pmod 3 = 0$，我们可以选择 $z = \\epsilon$（空字符串）。如果 $(1 - k_x) \\pmod 3 = 1$，我们可以选择 $z = a$。如果 $(1 - k_x) \\pmod 3 = 2$，我们可以选择 $z = aa$。\n让我们选择这样一个 $z$。根据我们的选择，$n_a(xz) \\equiv 1 \\pmod 3$，所以 $xz \\in L$。\n\n现在我们检查 $yz$ 在 $L$ 中的成员资格。条件是 $n_a(yz) \\equiv 1 \\pmod 3$。这等价于 $n_a(y) + n_a(z) \\equiv 1 \\pmod 3$，或者 $k_y + n_a(z) \\equiv 1 \\pmod 3$。代入 $n_a(z)$ 的同余式，我们得到 $k_y + (1 - k_x) \\equiv 1 \\pmod 3$。这简化为 $k_y - k_x \\equiv 0 \\pmod 3$，或 $k_y \\equiv k_x \\pmod 3$。然而，这与我们最初的假设 $k_x \\neq k_y$ 相矛盾。\n\n因此，我们选择的 $z$ 使得 $xz \\in L$ 但 $yz \\notin L$。这个字符串 $z$ 区分了 $x$ 和 $y$，这与 $x \\ R_L \\ y$ 的前提相矛盾。解决这个矛盾的唯一方法是推翻假设。因此，必须有 $n_a(x) \\equiv n_a(y) \\pmod 3$。\n\n我们已经证明，不可区分关系 $R_L$ 根据 $n_a(w) \\pmod 3$ 的值将所有字符串的集合 $\\Sigma^*$ 进行划分。该同余式的可能值为 $0$、$1$ 和 $2$。这导致了恰好三个不同的等价类：\n1. $C_0 = \\{ w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 0 \\pmod 3 \\}$\n2. $C_1 = \\{ w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 1 \\pmod 3 \\}$\n3. $C_2 = \\{ w \\in \\{a,b\\}^* \\mid n_a(w) \\equiv 2 \\pmod 3 \\}$\n\n$\\{a,b\\}^*$ 中的任何字符串都恰好属于这些类中的一个。例如，空字符串 $\\epsilon$ 属于 $C_0$，字符串 $a$ 属于 $C_1$，字符串 $aa$ 属于 $C_2$。\n\n根据 Myhill-Nerode 定理，最小 DFA 的状态数就是这些等价类的数量。由于恰好有 $3$ 个这样的类，识别 $L$ 的最小 DFA 必须有 $3$ 个状态。当前 DFA 有 $10$ 个状态的信息是无关的，它表明当前的实现不是最小的。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "现实世界的信息物理系统通常需要同时满足多个行为规范，例如，一个操作必须符合工厂模型但不能违反安全协议。本练习将向您展示如何通过“乘积构造法”这一核心技术，系统地组合两个确定性有限自动机（DFA），以创建一个新的 DFA 来识别它们语言的集合差。掌握此方法对于构建能够精确执行复杂逻辑（例如，识别 $L(A_1) \\setminus L(A_2)$）的运行时监视器至关重要。",
            "id": "4222760",
            "problem": "信息物理系统（CPS）中的数字孪生使用由确定性有限自动机（DFA）构建的运行时监视器，将观测到的轨迹序列与对象模型和监控控制器规范进行比较。设 $A_1 = (Q_1, \\Sigma, \\delta_1, q_{1,0}, F_1)$ 和 $A_2 = (Q_2, \\Sigma, \\delta_2, q_{2,0}, F_2)$ 是两个定义在相同有限字母表 $\\Sigma$ 上的完备确定性有限自动机（DFA），其中 $\\delta_1$ 和 $\\delta_2$ 是全转移函数，$F_1 \\subseteq Q_1$ 和 $F_2 \\subseteq Q_2$ 是接受状态集。该数字孪生需要一个监视器，它恰好接受那些在 $L(A_1)$ 中但不在 $L(A_2)$ 中的轨迹，即集合论中的语言差集 $L(A_1) \\setminus L(A_2)$。\n\n从确定性有限自动机（DFA）的形式语义定义、接受的含义以及语言差集的集合论定义出发，构造一个识别 $L(A_1) \\setminus L(A_2)$ 的 DFA $A_{\\Delta}$。根据 $A_1$ 和 $A_2$ 推导出 $A_{\\Delta}$ 的状态空间、转移函数、初始状态和接受状态集，并基于 DFA 语义和语言上的集合运算的基本原理证明其正确性，而不依赖任何现成的构造规则。\n\n然后，根据 $|Q_1|$ 和 $|Q_2|$ 计算 $A_{\\Delta}$ 的状态数的紧上界。你的最终答案必须是单一的封闭形式表达式。无需四舍五入。无需单位。",
            "solution": "用户提供的问题是有效的。它在科学上基于自动机理论的原理，问题提出得当，客观，并包含了进行形式化推导所需的所有必要信息。该问题要求为两个正则语言的集合论差集构造一个确定性有限自动机（DFA），从基本原理出发证明其正确性，并给出一个状态数的紧上界。\n\n给定两个完备的 DFA，$A_1 = (Q_1, \\Sigma, \\delta_1, q_{1,0}, F_1)$ 和 $A_2 = (Q_2, \\Sigma, \\delta_2, q_{2,0}, F_2)$。一个 DFA $A = (Q, \\Sigma, \\delta, q_0, F)$ 接受一个字符串 $w \\in \\Sigma^*$ 当且仅当该机器从其初始状态 $q_0$ 开始，在处理完整个字符串 $w$ 后，最终处于 $F$ 中的一个接受状态。\n\n为了将其形式化，我们定义扩展转移函数 $\\hat{\\delta}: Q \\times \\Sigma^* \\to Q$，它给出自动机在处理完整个字符串后所处的状态。它被递归定义如下：\n$1.$ 对于空字符串 $\\epsilon$，对任何状态 $q \\in Q$，有 $\\hat{\\delta}(q, \\epsilon) = q$。\n$2.$ 对于字符串 $w \\in \\Sigma^*$ 和符号 $a \\in \\Sigma$，对任何状态 $q \\in Q$，有 $\\hat{\\delta}(q, wa) = \\delta(\\hat{\\delta}(q, w), a)$。\n\n由 DFA $A$ 接受的语言，记为 $L(A)$，是所有能使自动机从其初始状态转移到某个接受状态的字符串的集合：\n$$L(A) = \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\}$$\n\n问题要求构造一个 DFA，我们称之为 $A_{\\Delta}$，它识别语言差集 $L(A_1) \\setminus L(A_2)$。根据集合差集的定义，该语言是：\n$$L(A_1) \\setminus L(A_2) = \\{ w \\in \\Sigma^* \\mid w \\in L(A_1) \\text{ 且 } w \\notin L(A_2) \\}$$\n使用语言接受的形式化定义，我们可以用 $A_1$ 和 $A_2$ 的组成部分来表示这个条件。一个字符串 $w$ 属于该语言当且仅当：\n$$\\hat{\\delta}_1(q_{1,0}, w) \\in F_1 \\quad \\text{且} \\quad \\hat{\\delta}_2(q_{2,0}, w) \\notin F_2$$\n\n为了检查这个复合条件，我们需要知道在处理完字符串 $w$ 后，自动机 $A_1$ 和 $A_2$ *两者*的状态。这启发我们构造一个新的自动机 $A_{\\Delta}$，其状态是状态对，其中一个来自 $A_1$，另一个来自 $A_2$。这被称为乘积构造法。\n\n我们如下定义 DFA $A_{\\Delta} = (Q_{\\Delta}, \\Sigma, \\delta_{\\Delta}, q_{\\Delta, 0}, F_{\\Delta})$：\n\n$1.$ **状态空间 $Q_{\\Delta}$**：状态空间是 $A_1$ 和 $A_2$ 状态空间的笛卡尔积。一个状态 $(p, q) \\in Q_{\\Delta}$ 跟踪 $A_1$ 将处于状态 $p \\in Q_1$ 且 $A_2$ 将处于状态 $q \\in Q_2$ 的情况。\n$$Q_{\\Delta} = Q_1 \\times Q_2 = \\{ (p, q) \\mid p \\in Q_1, q \\in Q_2 \\}$$\n\n$2.$ **初始状态 $q_{\\Delta, 0}$**：模拟开始时，$A_1$ 和 $A_2$ 都处于它们各自的初始状态。\n$$q_{\\Delta, 0} = (q_{1,0}, q_{2,0})$$\n\n$3.$ **转移函数 $\\delta_{\\Delta}$**：当处于状态 $(p, q)$ 并读取一个符号 $a \\in \\Sigma$ 时，新状态通过应用 $A_1$ 和 $A_2$ 各自的转移函数来确定。\n$$\\delta_{\\Delta}: Q_{\\Delta} \\times \\Sigma \\to Q_{\\Delta}$$\n$$\\delta_{\\Delta}((p, q), a) = (\\delta_1(p, a), \\delta_2(q, a)) \\quad \\text{对于所有 } (p,q) \\in Q_{\\Delta}, a \\in \\Sigma$$\n\n$4.$ **接受状态 $F_{\\Delta}$**：一个字符串 $w$ 应被 $A_{\\Delta}$ 接受，当且仅当它被 $A_1$ 接受但不被 $A_2$ 接受。这意味着在处理完 $w$ 后，达到的状态 $(p,q)$ 满足 $p$ 是 $A_1$ 的一个接受状态，而 $q$ 是 $A_2$ 的一个*非接受*状态。\n$$F_{\\Delta} = \\{ (p, q) \\in Q_1 \\times Q_2 \\mid p \\in F_1 \\text{ 且 } q \\notin F_2 \\}$$\n这可以更紧凑地写为 $F_{\\Delta} = F_1 \\times (Q_2 \\setminus F_2)$。\n\n**正确性证明：**\n我们必须证明 $L(A_{\\Delta}) = L(A_1) \\setminus L(A_2)$。为此，我们首先建立一个关键引理，将扩展转移函数 $\\hat{\\delta}_{\\Delta}$ 与 $\\hat{\\delta}_1$ 和 $\\hat{\\delta}_2$ 联系起来。\n\n**引理：** 对于任何状态 $(p, q) \\in Q_{\\Delta}$ 和任何字符串 $w \\in \\Sigma^*$，有 $\\hat{\\delta}_{\\Delta}((p, q), w) = (\\hat{\\delta}_1(p, w), \\hat{\\delta}_2(q, w))$。\n**引理证明（通过对 $w$ 的长度进行归纳）：**\n- **基本情况：** 设 $|w| = 0$，即 $w = \\epsilon$。根据 $\\hat{\\delta}$ 的定义，$\\hat{\\delta}_{\\Delta}((p, q), \\epsilon) = (p, q)$。同时，$(\\hat{\\delta}_1(p, \\epsilon), \\hat{\\delta}_2(q, \\epsilon)) = (p, q)$。因此引理对 $|w|=0$ 成立。\n- **归纳步骤：** 假设引理对所有长度为 $n \\ge 0$ 的字符串 $w$ 成立。设 $x$ 是一个长度为 $n+1$ 的字符串，因此 $x = wa$，其中 $w \\in \\Sigma^*$ 且 $|w|=n$，$a \\in \\Sigma$。\n\\begin{align*}\n\\hat{\\delta}_{\\Delta}((p, q), wa) = \\delta_{\\Delta}(\\hat{\\delta}_{\\Delta}((p, q), w), a)  \\text{(根据 } \\hat{\\delta}_{\\Delta} \\text{ 的定义)} \\\\\n= \\delta_{\\Delta}((\\hat{\\delta}_1(p, w), \\hat{\\delta}_2(q, w)), a)  \\text{(根据归纳假设)} \\\\\n= (\\delta_1(\\hat{\\delta}_1(p, w), a), \\delta_2(\\hat{\\delta}_2(q, w), a))  \\text{(根据 } \\delta_{\\Delta} \\text{ 的定义)} \\\\\n= (\\hat{\\delta}_1(p, wa), \\hat{\\delta}_2(q, wa))  \\text{(根据 } \\hat{\\delta}_1, \\hat{\\delta}_2 \\text{ 的定义)}\n\\end{align*}\n因此，该引理对所有字符串 $w \\in \\Sigma^*$ 均成立。\n\n**主证明：**\n现在我们证明，对于任何字符串 $w \\in \\Sigma^*$，$w \\in L(A_{\\Delta})$ 当且仅当 $w \\in L(A_1) \\setminus L(A_2)$。\n\\begin{align*}\nw \\in L(A_{\\Delta}) \\iff \\hat{\\delta}_{\\Delta}(q_{\\Delta, 0}, w) \\in F_{\\Delta}  \\text{(根据 } L(A_{\\Delta}) \\text{ 的定义)} \\\\\n\\iff \\hat{\\delta}_{\\Delta}((q_{1,0}, q_{2,0}), w) \\in F_{\\Delta}  \\text{(根据 } q_{\\Delta, 0} \\text{ 的定义)} \\\\\n\\iff (\\hat{\\delta}_1(q_{1,0}, w), \\hat{\\delta}_2(q_{2,0}, w)) \\in F_{\\Delta}  \\text{(根据引理)} \\\\\n\\iff \\hat{\\delta}_1(q_{1,0}, w) \\in F_1 \\text{ 且 } \\hat{\\delta}_2(q_{2,0}, w) \\notin F_2  \\text{(根据 } F_{\\Delta} \\text{ 的定义)} \\\\\n\\iff (w \\in L(A_1)) \\text{ 且 } (w \\notin L(A_2))  \\text{(根据 } L(A_1), L(A_2) \\text{ 的定义)} \\\\\n\\iff w \\in L(A_1) \\setminus L(A_2)  \\text{(根据集合差集的定义)}\n\\end{align*}\n等价关系成立，因此我们证明了构造的 DFA $A_{\\Delta}$ 正确地识别了语言 $L(A_1) \\setminus L(A_2)$。\n\n**状态数的上界：**\n我们构造的自动机 $A_{\\Delta}$ 中的状态数是 $|Q_{\\Delta}|$。根据构造，我们有 $Q_{\\Delta} = Q_1 \\times Q_2$。两个有限集的笛卡尔积的基数是它们各自基数的乘积。因此：\n$$|Q_{\\Delta}| = |Q_1 \\times Q_2| = |Q_1| \\cdot |Q_2|$$\n这给出了语言差集的 DFA 的状态数的一个上界。该界是紧的，意味着存在 DFA $A_1$ 和 $A_2$，使得识别 $L(A_1) \\setminus L(A_2)$ 的最小 DFA 需要 $|Q_1| \\cdot |Q_2|$ 个状态。当乘积构造中的所有状态都可以从初始状态 $(q_{1,0}, q_{2,0})$ 到达，并且是两两可区分的时，这种情况就会发生。例如，如果 $A_1$ 是一个模 $|Q_1|$ 的计数器，$A_2$ 是一个模 $|Q_2|$ 的计数器，且它们作用于不同的符号，那么乘积中的所有 $|Q_1| \\cdot |Q_2|$ 个状态都是可达的。因此，数量 $|Q_1| \\cdot |Q_2|$ 是一个紧上界。",
            "answer": "$$\n\\boxed{|Q_1| |Q_2|}\n$$"
        },
        {
            "introduction": "当系统行为涉及复杂的操作模式和分层逻辑时，扁平的有限状态机便显得力不从心。层次化状态图（Statecharts）通过引入复合状态、历史连接器和默认进入等高级语义，极大地增强了模型的表达能力。本练习要求您在一个具体的信息物理系统控制器模型中，精确地追踪一个事件序列如何驱动状态机在不同层次间转换。这个模拟过程将考验您对状态图执行语义的精确认知，这是验证和调试复杂反应式系统行为的关键技能。",
            "id": "4222783",
            "problem": "一个信息物理系统（CPS）中过程阀门的数字孪生使用一个分层状态图来管理两种控制机制之间的模式切换。该控制器被建模为一个状态机，具有一个配备了浅历史连接器的顶层组合状态 $M$ 和一个外部静止状态 $O$。$M$ 上的浅历史连接器在退出 $M$ 时会记住 $M$ 最近活动的直接子状态，并在重新进入时以该直接子状态为目标（但是，因为它是浅历史，所以不会记住任何更深层嵌套的子状态）。以下结构和事件语义成立。\n\n- 顶层组合状态 $M$ 恰好有两个直接子状态：组合子状态 $A$ 和组合子状态 $B$。$M$ 的默认初始子状态是 $A$。\n- 子状态 $A$ 包含两个简单子状态，$a_1$（默认初始）和 $a_2$。在 $A$ 中只有一个由事件 $e$ 标记的内部转换，它在 $a_1$ 和 $a_2$ 之间切换：在事件 $e$ 上，$a_1 \\rightarrow a_2$ 且 $a_2 \\rightarrow a_1$。\n- 子状态 $B$ 包含三个简单子状态，$b_1$（默认初始）、$b_2$ 和 $b_3$，在事件 $e$ 下按周期排列：在事件 $e$ 上，$b_1 \\rightarrow b_2$，$b_2 \\rightarrow b_3$，且 $b_3 \\rightarrow b_1$。\n- 在 $M$ 的层级上，存在事件触发的转换：在事件 $\\mathrm{sw}$ 上，状态机在 $A$ 和 $B$ 之间切换（即，如果在 $A$ 中，则 $A \\rightarrow B$；如果在 $B$ 中，则 $B \\rightarrow A$）。这种切换是直接指向所指示的直接子状态的目标，并且根据默认进入语义，进入其默认的初始嵌套子状态。在事件 $\\mathrm{out}$ 上，状态机从 $M$ 退出到 $O$。在事件 $\\mathrm{in}$ 上，状态机通过 $M$ 的浅历史连接器从 $O$ 进入 $M$。如果 $M$ 没有记录的历史，则进入默认的初始子状态 $A$；否则，重新进入 $M$ 最近活动的直接子状态，然后在该子状态内应用默认进入语义。任何地方都没有进入、退出或执行动作，事件以运行到完成（run-to-completion）的语义进行处理。\n\n状态机从 $O$ 开始，没有 $M$ 的记录历史。考虑应用于该状态机的以下输入轨迹，其中符号 $e^{k}$ 表示事件 $e$ 连续发生 $k$ 次，所有其他事件均为单次发生：\n$\\mathrm{in},\\, e^{5},\\, \\mathrm{sw},\\, e^{8},\\, \\mathrm{out},\\, \\mathrm{in},\\, e^{7},\\, \\mathrm{sw},\\, e^{9},\\, \\mathrm{out},\\, \\mathrm{in},\\, e^{11}$。\n\n为 $M$ 的五个可能的嵌套简单子状态定义一个编码函数 $c(\\cdot)$ 如下：$c(A.a_1)=1$，$c(A.a_2)=2$，$c(B.b_1)=3$，$c(B.b_2)=4$ 和 $c(B.b_3)=5$。仅使用具有浅历史和默认进入的分层状态机的基本语义，确定在处理完整个输入轨迹后，$M$ 的最终活动嵌套简单子状态的编码 $c(\\cdot)$。请以单个整数形式提供您的答案，不带单位。无需四舍五入。",
            "solution": "根据指定标准对问题进行验证。\n\n### 第 1 步：提取已知信息\n- **模型**：一个信息物理系统中控制器的分层状态图。\n- **状态**：\n    - 一个外部静止状态 $O$。\n    - 一个带有浅历史连接器的顶层组合状态 $M$。\n- **状态层级**：\n    - $M$ 有两个直接子状态：$A$（组合）和 $B$（组合）。\n    - $M$ 的默认初始子状态是 $A$。\n    - $A$ 包含两个简单子状态：$a_1$（默认初始）和 $a_2$。\n    - $B$ 包含三个简单子状态：$b_1$（默认初始）、$b_2$ 和 $b_3$。\n- **转换和事件**：\n    - 在子状态 $A$ 中，事件 $e$ 在 $a_1$ 和 $a_2$ 之间切换：$a_1 \\leftrightarrows a_2$。\n    - 在子状态 $B$ 中，事件 $e$ 在其子状态之间循环：$b_1 \\to b_2 \\to b_3 \\to b_1$。\n    - 在 $M$ 的层级：\n        - 事件 $\\mathrm{sw}$ 在 $A$ 和 $B$ 之间切换：如果在 $A$ 中，则 $A \\to B$；如果在 $B$ 中，则 $B \\to A$。\n        - 事件 $\\mathrm{out}$ 导致从 $M$ 退出：$M \\to O$。\n        - 事件 $\\mathrm{in}$ 导致从 $O$ 进入 $M$：通过其浅历史连接器 $O \\to M$。\n- **历史语义**：\n    - $M$ 的浅历史记住最近活动的直接子状态（$A$ 或 $B$）。\n    - 如果 $M$ 没有记录的历史，则进入 $M$ 的默认子状态 $A$。\n    - 进入一个子状态（例如 $A$ 或 $B$）时，默认进入语义适用于其嵌套子状态（即，对于 $A$ 进入 $a_1$，对于 $B$ 进入 $b_1$）。\n- **初始条件**：\n    - 状态机从状态 $O$ 开始。\n    - 没有 $M$ 的记录历史。\n- **输入轨迹**：\n    - 事件序列为 $\\mathrm{in}, e^{5}, \\mathrm{sw}, e^{8}, \\mathrm{out}, \\mathrm{in}, e^{7}, \\mathrm{sw}, e^{9}, \\mathrm{out}, \\mathrm{in}, e^{11}$。\n- **编码函数**：\n    - $c(A.a_1)=1$，$c(A.a_2)=2$，$c(B.b_1)=3$，$c(B.b_2)=4$ 和 $c(B.b_3)=5$。\n- **目标**：确定最终活动嵌套简单子状态的编码 $c(\\cdot)$。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题在计算机科学和系统工程的形式体系内是定义明确且具有科学依据的。\n- **科学/事实的可靠性**：该问题利用了分层状态机（状态图）的标准、成熟的概念，包括组合状态、历史连接器和事件驱动的转换。这些概念是建模反应式系统的基础，并且在科学上是可靠的。\n- **适定性**：该状态机是确定性的。对于给定的初始状态和特定的输入序列，保证存在一个唯一的最终状态。问题提供了找到这个唯一解所需的所有信息（状态、转换、初始条件和输入轨迹）。\n- **客观性**：语言精确且正式。诸如“浅历史”和“默认进入”之类的术语在此上下文中具有清晰、明确的含义，并在问题中明确说明。\n- **完整性和一致性**：问题是自包含的。状态机的结构以及所有事件和机制的语义都已完全指定。所提供的规则中没有矛盾之处。\n\n### 第 3 步：结论与行动\n问题是有效的。通过追踪状态机的执行过程，可以得出一步一步的解决方案。\n\n我们将追踪状态机在给定输入序列下的状态。状态配置由活动的简单子状态（例如，$A.a_1$）表示。$M$ 的历史状态由 $H(M)$ 表示。\n\n1.  **初始状态**：状态机处于状态 $O$。$M$ 的历史 $H(M)$ 初始为空。\n\n2.  **事件 `in`**：状态机从 $O$ 转换到 $M$。由于 $H(M)$ 为空，状态机进入 $M$ 的默认初始子状态 $A$。随后，它进入 $A$ 的默认初始子状态 $a_1$。\n    - 当前状态：$A.a_1$。\n\n3.  **事件 $e^5$**：状态机处于子状态 $A$ 中，事件 $e$ 会在 $a_1$ 和 $a_2$ 之间切换。这是一个长度为 2 的循环。从 $a_1$ 开始，经过 5 次事件 $e$ 后，最终状态由转换次数模 2 决定。由于 $5 \\pmod{2} = 1$，状态机从 $a_1$ 经历一次净转换。\n    - 转换：$a_1 \\to a_2$。\n    - 当前状态：$A.a_2$。\n\n4.  **事件 `sw`**：状态机处于 $A$ 的一个子状态中。事件 $\\mathrm{sw}$ 触发转换 $A \\to B$。状态机进入状态 $B$，并根据默认进入语义，进入 $B$ 的默认初始子状态 $b_1$。\n    - 当前状态：$B.b_1$。\n\n5.  **事件 $e^8$**：状态机处于子状态 $B$ 中，事件 $e$ 会在循环 $b_1 \\to b_2 \\to b_3 \\to b_1$ 中引起转换。这是一个长度为 3 的循环。从 $b_1$ 开始，经过 8 次事件 $e$ 后，最终状态由 $8 \\pmod{3} = 2$ 决定。这对应于从 $b_1$ 开始的两次转换。\n    - 转换：$b_1 \\to b_2 \\to b_3$。\n    - 当前状态：$B.b_3$。\n\n6.  **事件 `out`**：状态机处于状态 $M$（具体为 $B.b_3$）。事件 `out` 触发转换 $M \\to O$。退出 $M$ 时，浅历史连接器记录 $M$ 最近活动的直接子状态，即 $B$。\n    - 当前状态：$O$。\n    - 历史更新：$H(M) = B$。\n\n7.  **事件 `in`**：状态机从 $O$ 转换到 $M$。由于存在历史（$H(M) = B$），状态机重新进入状态 $B$。问题指定了浅历史，这意味着只恢复了直接子状态 $B$，而没有恢复更深的子状态 $b_3$。然后默认进入语义在 $B$ 内部适用，因此状态机进入 $b_1$。\n    - 当前状态：$B.b_1$。\n\n8.  **事件 $e^7$**：状态机处于状态 $B.b_1$。经过 7 次事件 $e$ 后，状态由 $7 \\pmod{3} = 1$ 决定。这对应于从 $b_1$ 开始的一次转换。\n    - 转换：$b_1 \\to b_2$。\n    - 当前状态：$B.b_2$。\n\n9.  **事件 `sw`**：状态机处于 $B$ 的一个子状态中。事件 $\\mathrm{sw}$ 触发转换 $B \\to A$。状态机进入状态 $A$ 及其默认初始子状态 $a_1$。\n    - 当前状态：$A.a_1$。\n\n10. **事件 $e^9$**：状态机处于状态 $A.a_1$。经过 9 次事件 $e$ 后，状态由 $9 \\pmod{2} = 1$ 决定。这对应于从 $a_1$ 开始的一次转换。\n    - 转换：$a_1 \\to a_2$。\n    - 当前状态：$A.a_2$。\n\n11. **事件 `out`**：状态机处于状态 $M$（具体为 $A.a_2$）。事件 `out` 触发转换 $M \\to O$。历史被更新以反映 $A$ 是最后一个活动的直接子状态。\n    - 当前状态：$O$。\n    - 历史更新：$H(M) = A$。\n\n12. **事件 `in`**：状态机从 $O$ 转换到 $M$。历史为 $H(M)=A$，因此状态机重新进入状态 $A$。根据浅历史语义，它随后进入 $A$ 的默认初始子状态 $a_1$。\n    - 当前状态：$A.a_1$。\n\n13. **事件 $e^{11}$**：状态机处于状态 $A.a_1$。经过 11 次事件 $e$ 后，状态由 $11 \\pmod{2} = 1$ 决定。这对应于从 $a_1$ 开始的一次转换。\n    - 转换：$a_1 \\to a_2$。\n    - 最终状态：$A.a_2$。\n\n处理完整个输入轨迹后，状态机的最终活动嵌套简单子状态是 $A.a_2$。根据提供的编码函数 $c(\\cdot)$，我们有 $c(A.a_2)=2$。",
            "answer": "$$\n\\boxed{2}\n$$"
        }
    ]
}