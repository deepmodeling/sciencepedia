{
    "hands_on_practices": [
        {
            "introduction": "Geographic routing offers an elegant, scalable solution for Wireless Sensor Networks by using node locations to guide packets. However, the simplest form—greedy routing—can lead to poor long-term choices by only optimizing for immediate progress. This exercise provides a hands-on comparison between a myopic one-hop greedy strategy and a more prescient two-hop informed approach, directly quantifying the energy savings from a small increase in local network knowledge. By implementing and testing these strategies , you will gain a tangible understanding of the trade-offs between algorithm complexity and energy efficiency in distributed systems.",
            "id": "4254469",
            "problem": "A Digital Twin (DT) of a Wireless Sensor Network (WSN) is used to evaluate energy-aware geographic routing strategies under a realistic radio-energy model. The network is embedded in a two-dimensional Euclidean plane. Each node has a known position, and a communication link between two nodes exists if and only if the Euclidean distance between them is less than or equal to a specified communication radius. The task is to compute, for given topologies and radio parameters, the energy reduction achieved by a two-hop informed geographic routing strategy compared to a one-hop greedy geographic routing strategy, when forwarding a single packet from a specified source node to a sink (base station).\n\nFundamental base:\n- The Euclidean distance between points $(x_1,y_1)$ and $(x_2,y_2)$ is $d=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$.\n- Radio energy model: transmission energy is distance-dependent with a free-space path-loss regime and a multipath path-loss regime. Let $L$ be the packet length in bits, $E_{\\mathrm{elec}}$ be the electronics energy per bit in joules per bit, $\\epsilon_{\\mathrm{fs}}$ be the free-space amplifier coefficient in joules per bit per meter squared, and $\\epsilon_{\\mathrm{mp}}$ be the multipath amplifier coefficient in joules per bit per meter to the fourth. Define the regime threshold $d_0=\\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$. Then the transmit energy for distance $d$ is\n$$\nE_{\\mathrm{tx}}(d) = \n\\begin{cases}\nL\\,E_{\\mathrm{elec}} + L\\,\\epsilon_{\\mathrm{fs}}\\,d^2,  \\text{if } d \\le d_0,\\\\\nL\\,E_{\\mathrm{elec}} + L\\,\\epsilon_{\\mathrm{mp}}\\,d^4,  \\text{if } d > d_0.\n\\end{cases}\n$$\nThe receive energy is distance-independent and given by $E_{\\mathrm{rx}}(L) = L\\,E_{\\mathrm{elec}}$.\n\nRouting strategies:\n- One-hop greedy geographic routing: At each step from the current node, choose a neighbor whose Euclidean distance to the sink is strictly less than that of the current node, and among all such neighbors choose the one with the minimal sink distance. If there is a tie, choose the neighbor that minimizes the current-to-neighbor Euclidean distance; if still tied, choose the smallest node index. Repeat until the sink is reached. The total energy for one-hop routing is the sum over all hops of $E_{\\mathrm{tx}}(d_{\\text{hop}}) + E_{\\mathrm{rx}}(L)$, including the final reception at the sink.\n- Two-hop informed geographic routing: At each step from the current node, if the sink is directly reachable (i.e., within the communication radius), transmit directly to the sink. Otherwise, construct candidate pairs $(i,j)$ such that $i$ is a neighbor of the current node with strictly smaller sink distance, and $j$ is a neighbor of $i$ with strictly smaller sink distance than the current node (the sink itself is admissible as $j$ if it is within the communication radius of $i$). For each pair, compute the two-hop segment energy $E_{\\mathrm{tx}}(d_{\\text{current},i}) + E_{\\mathrm{rx}}(L) + E_{\\mathrm{tx}}(d_{i,j}) + E_{\\mathrm{rx}}(L)$. Choose the pair with minimal two-hop segment energy; ties are broken by minimal sink distance of $j$, then minimal sink distance of $i$, then lexicographically by $(i,j)$ indices. Execute the two hops and set the current node to $j$. Repeat until the sink is reached. The total energy for two-hop routing is the sum of transmit and receive energies over all executed hops.\n\nTask:\nFor each supplied test topology and parameter set, compute the energy reduction defined as the difference between the total energy of the one-hop greedy routing path and the total energy of the two-hop informed routing path, both calculated under the specified radio model. Express energy in joules as decimal numbers rounded to six decimal places.\n\nTest suite and parameters:\n- Common radio parameters used in all test cases:\n  - Packet length $L = 4096$ bits.\n  - Electronics energy per bit $E_{\\mathrm{elec}} = 5\\times 10^{-8}$ joules per bit.\n  - Free-space amplifier coefficient $\\epsilon_{\\mathrm{fs}} = 10^{-11}$ joules per bit per meter squared.\n  - Multipath amplifier coefficient $\\epsilon_{\\mathrm{mp}} = 1.3\\times 10^{-15}$ joules per bit per meter to the fourth.\n  - Regime threshold $d_0 = \\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$ meters.\n\n- Test Case $1$ (happy path; two-hop improvement expected):\n  - Communication radius $R = 60$ meters.\n  - Nodes (index: coordinates in meters):\n    - $0$: $(200,0)$ source.\n    - $1$: $(0,0)$ sink.\n    - $2$: $(150,0)$.\n    - $3$: $(90,0)$.\n    - $4$: $(30,0)$.\n    - $5$: $(160,45)$.\n    - $6$: $(120,30)$.\n    - $7$: $(80,20)$.\n    - $8$: $(40,10)$.\n- Test Case $2$ (boundary; equal energy expected):\n  - Communication radius $R = 60$ meters.\n  - Nodes:\n    - $0$: $(200,0)$ source.\n    - $1$: $(0,0)$ sink.\n    - $2$: $(150,0)$.\n    - $3$: $(100,0)$.\n    - $4$: $(50,0)$.\n- Test Case $3$ (edge near threshold; large two-hop improvement expected):\n  - Communication radius $R = 120$ meters.\n  - Nodes:\n    - $0$: $(200,0)$ source.\n    - $1$: $(0,0)$ sink.\n    - $2$: $(100,0)$.\n    - $3$: $(160,60)$.\n    - $4$: $(120,40)$.\n    - $5$: $(80,20)$.\n    - $6$: $(40,10)$.\n\nFinal output format:\nYour program should produce a single line of output containing the energy reductions for the three test cases, as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places in joules (e.g., \"[$x_1$,$x_2$,$x_3$]\").",
            "solution": "The problem is grounded in the physical radio-energy model used widely in Wireless Sensor Network (WSN) research and in cyber-physical system Digital Twins (DTs). The model couples the electronics energy per bit with a distance-dependent amplifier energy that follows the free-space law for short ranges and the multipath law for longer ranges. The threshold $d_0=\\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$ demarcates the switch between these regimes.\n\nFundamentals:\n- The Euclidean distance between two nodes at $(x_1,y_1)$ and $(x_2,y_2)$ is $d=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$, ensuring physically meaningful distances in meters.\n- The transmit energy $E_{\\mathrm{tx}}(d)$ employs the free-space amplifier model $L\\,\\epsilon_{\\mathrm{fs}}\\,d^2$ for $d \\le d_0$ and the multipath amplifier model $L\\,\\epsilon_{\\mathrm{mp}}\\,d^4$ for $dd_0$, with a constant electronics cost $L\\,E_{\\mathrm{elec}}$.\n- The receive energy $E_{\\mathrm{rx}}(L)=L\\,E_{\\mathrm{elec}}$ is independent of distance, modeling the cost of decoding and baseband processing at the receiver.\n\nAlgorithmic design:\n1. Construct the communication graph by connecting any pair of nodes whose Euclidean distance is less than or equal to the communication radius $R$. This reflects realistic physical adjacency.\n2. One-hop greedy geographic routing:\n   - From the current node $c$, enumerate neighbors $n$ with $d(n,\\mathrm{sink})d(c,\\mathrm{sink})$ to ensure progress toward the sink.\n   - Choose the neighbor that minimizes $d(n,\\mathrm{sink})$, breaking ties by minimal $d(c,n)$ and then by smallest index, to obtain a deterministic path.\n   - Accumulate energy for each hop as $E_{\\mathrm{tx}}(d(c,n))+E_{\\mathrm{rx}}(L)$, including the final reception at the sink.\n   - Repeat until the sink is reached. This procedure is memoryless and locally optimal in terms of geometric progress.\n3. Two-hop informed geographic routing:\n   - If the sink is within $R$ of the current node, transmit directly to the sink, accumulating $E_{\\mathrm{tx}}(d(c,\\mathrm{sink}))+E_{\\mathrm{rx}}(L)$, and terminate.\n   - Otherwise, for each neighbor $i$ of the current node with $d(i,\\mathrm{sink})d(c,\\mathrm{sink})$, enumerate neighbors $j$ of $i$ (including the sink if within $R$ of $i$) with $d(j,\\mathrm{sink})d(c,\\mathrm{sink})$. This guarantees net progress after two hops.\n   - For each admissible pair $(i,j)$, compute the two-hop segment energy $E_{\\mathrm{tx}}(d(c,i)) + E_{\\mathrm{rx}}(L) + E_{\\mathrm{tx}}(d(i,j)) + E_{\\mathrm{rx}}(L)$.\n   - Choose the pair with minimal segment energy; break ties by minimal $d(j,\\mathrm{sink})$, minimal $d(i,\\mathrm{sink})$, and then lexicographically by indices $(i,j)$.\n   - Execute the two hops sequentially, accumulate their energies, and set the current node to $j$. Repeat until the sink is reached. This look-ahead incorporates local future costs, potentially avoiding expensive single long hops that invoke the multipath regime.\n\nEnergy reduction computation:\n- For each test case, compute the total energy $E_{\\mathrm{one}}$ for the one-hop greedy path and the total energy $E_{\\mathrm{two}}$ for the two-hop informed path. The reduction is $\\Delta E = E_{\\mathrm{one}} - E_{\\mathrm{two}}$. Values are rounded to six decimal places and expressed in joules.\n\nWhy the two-hop strategy can reduce energy:\n- When the one-hop greedy choice leads to a subsequent long hop (distance $dd_0$), the amplifier cost $L\\,\\epsilon_{\\mathrm{mp}}\\,d^4$ can dominate, making that path energetically expensive. The two-hop strategy can prefer a first hop that is not the closest to the sink if it leads to a second hop that is significantly shorter (remaining in the free-space regime), reducing the sum of the two-hop segment costs. Over a route, repeating such decisions can substantially lower the total energy.\n\nApplication to the test suite:\n- Test Case $1$ sets two alternative corridors: a “straight” corridor composed of near-maximum-radius hops and a “diagonal” corridor composed of shorter hops. The one-hop greedy scheme selects the straight corridor initially due to closer neighbor-to-sink distance, but the two-hop informed scheme selects the diagonal corridor because the two-hop segment energy is lower.\n- Test Case $2$ places nodes collinearly at regular spacings, making the greedy and two-hop decisions coincide at every step; thus, the energy reduction is zero.\n- Test Case $3$ adjusts $R$ and geometry so the greedy path uses hops exceeding $d_0$, incurring multipath costs, whereas the two-hop path remains in the free-space regime, generating a large energy reduction.\n\nProgram output:\n- The program enumerates the routes using the defined strategies and sums transmit and receive energies using the radio model. It prints a single line of the form \"[$x_1$,$x_2$,$x_3$]\" where each $x_k$ is the reduction for test case $k$, rounded to six decimal places in joules.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef euclidean_distance(p, q):\n    return float(np.linalg.norm(np.array(p) - np.array(q)))\n\ndef build_adjacency(positions, R):\n    n = len(positions)\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            d = euclidean_distance(positions[i], positions[j])\n            if d = R + 1e-12:  # tolerances for floating-point\n                adj[i].append(j)\n    return adj\n\ndef radio_params():\n    # Common radio parameters for all test cases\n    L = 4096  # bits\n    E_elec = 5e-8  # J/bit\n    eps_fs = 1e-11  # J/bit/m^2\n    eps_mp = 1.3e-15  # J/bit/m^4\n    d0 = np.sqrt(eps_fs / eps_mp)\n    return L, E_elec, eps_fs, eps_mp, d0\n\ndef E_tx(d, L, E_elec, eps_fs, eps_mp, d0):\n    if d = d0:\n        return L * E_elec + L * eps_fs * (d ** 2)\n    else:\n        return L * E_elec + L * eps_mp * (d ** 4)\n\ndef E_rx(L, E_elec):\n    return L * E_elec\n\ndef one_hop_greedy_energy(positions, R, src_idx, sink_idx, L, E_elec, eps_fs, eps_mp, d0):\n    adj = build_adjacency(positions, R)\n    total_energy = 0.0\n    current = src_idx\n    sink_pos = positions[sink_idx]\n\n    # Safety cap to avoid infinite loops\n    max_steps = 10000\n    steps = 0\n\n    while current != sink_idx and steps  max_steps:\n        steps += 1\n        current_pos = positions[current]\n        current_sink_dist = euclidean_distance(current_pos, sink_pos)\n\n        # Candidate neighbors strictly closer to sink\n        candidates = []\n        for n in adj[current]:\n            n_pos = positions[n]\n            n_sink_dist = euclidean_distance(n_pos, sink_pos)\n            if n_sink_dist  current_sink_dist - 1e-12:  # strict progress\n                d_cn = euclidean_distance(current_pos, n_pos)\n                candidates.append((n, n_sink_dist, d_cn))\n\n        if not candidates:\n            # No progress possible under greedy; for this test suite it should not occur\n            raise RuntimeError(\"Greedy routing failed to find a progress neighbor.\")\n\n        # Choose neighbor minimizing sink distance, then minimizing hop distance, then index\n        candidates.sort(key=lambda x: (x[1], x[2], x[0]))\n        next_node = candidates[0][0]\n        hop_dist = candidates[0][2]\n\n        # Accumulate energy: transmit + receive at next node\n        total_energy += E_tx(hop_dist, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n\n        current = next_node\n\n    if steps = max_steps:\n        raise RuntimeError(\"Exceeded maximum steps in greedy routing.\")\n\n    return total_energy\n\ndef two_hop_informed_energy(positions, R, src_idx, sink_idx, L, E_elec, eps_fs, eps_mp, d0):\n    adj = build_adjacency(positions, R)\n    total_energy = 0.0\n    current = src_idx\n    sink_pos = positions[sink_idx]\n\n    max_steps = 10000\n    steps = 0\n\n    while current != sink_idx and steps  max_steps:\n        steps += 1\n        current_pos = positions[current]\n        current_sink_dist = euclidean_distance(current_pos, sink_pos)\n\n        # If sink is directly reachable, do a single hop\n        if sink_idx in adj[current]:\n            d_cs = euclidean_distance(current_pos, sink_pos)\n            total_energy += E_tx(d_cs, L, E_elec, eps_fs, eps_mp, d0)\n            total_energy += E_rx(L, E_elec)\n            current = sink_idx\n            break\n\n        # Build candidate two-hop pairs (i, j)\n        pairs = []\n        for i in adj[current]:\n            i_pos = positions[i]\n            i_sink_dist = euclidean_distance(i_pos, sink_pos)\n            if i_sink_dist = current_sink_dist - 1e-12:\n                continue  # must be closer than current to sink\n            # Neighbors of i that are closer than current\n            # Include sink if reachable from i\n            for j in adj[i]:\n                j_pos = positions[j]\n                j_sink_dist = euclidean_distance(j_pos, sink_pos)\n                if j_sink_dist  current_sink_dist - 1e-12:\n                    d_ci = euclidean_distance(current_pos, i_pos)\n                    d_ij = euclidean_distance(i_pos, j_pos)\n                    seg_energy = (\n                        E_tx(d_ci, L, E_elec, eps_fs, eps_mp, d0)\n                        + E_rx(L, E_elec)\n                        + E_tx(d_ij, L, E_elec, eps_fs, eps_mp, d0)\n                        + E_rx(L, E_elec)\n                    )\n                    pairs.append((seg_energy, j_sink_dist, i_sink_dist, i, j, d_ci, d_ij))\n\n        if not pairs:\n            # Fall back: pick a one-hop progress neighbor if no two-hop pair exists\n            candidates = []\n            for n in adj[current]:\n                n_pos = positions[n]\n                n_sink_dist = euclidean_distance(n_pos, sink_pos)\n                if n_sink_dist  current_sink_dist - 1e-12:\n                    d_cn = euclidean_distance(current_pos, n_pos)\n                    candidates.append((n, n_sink_dist, d_cn))\n            if not candidates:\n                raise RuntimeError(\"Two-hop routing failed to find progress.\")\n            candidates.sort(key=lambda x: (x[1], x[2], x[0]))\n            next_node = candidates[0][0]\n            hop_dist = candidates[0][2]\n            total_energy += E_tx(hop_dist, L, E_elec, eps_fs, eps_mp, d0)\n            total_energy += E_rx(L, E_elec)\n            current = next_node\n            continue\n\n        # Choose pair minimizing energy; tie-breakers as specified\n        pairs.sort(key=lambda x: (x[0], x[1], x[2], x[3], x[4]))\n        best = pairs[0]\n        _, _, _, i, j, d_ci, d_ij = best\n\n        # Execute the two hops sequentially\n        total_energy += E_tx(d_ci, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n        total_energy += E_tx(d_ij, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n\n        current = j\n\n    if steps = max_steps:\n        raise RuntimeError(\"Exceeded maximum steps in two-hop routing.\")\n\n    return total_energy\n\ndef solve():\n    L, E_elec, eps_fs, eps_mp, d0 = radio_params()\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"R\": 60.0,\n            \"positions\": [\n                (200.0, 0.0),  # 0 source\n                (0.0, 0.0),    # 1 sink\n                (150.0, 0.0),  # 2\n                (90.0, 0.0),   # 3\n                (30.0, 0.0),   # 4\n                (160.0, 45.0), # 5\n                (120.0, 30.0), # 6\n                (80.0, 20.0),  # 7\n                (40.0, 10.0),  # 8\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n        # Test Case 2\n        {\n            \"R\": 60.0,\n            \"positions\": [\n                (200.0, 0.0),  # 0 source\n                (0.0, 0.0),    # 1 sink\n                (150.0, 0.0),  # 2\n                (100.0, 0.0),  # 3\n                (50.0, 0.0),   # 4\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n        # Test Case 3\n        {\n            \"R\": 120.0,\n            \"positions\": [\n                (200.0, 0.0),   # 0 source\n                (0.0, 0.0),     # 1 sink\n                (100.0, 0.0),   # 2\n                (160.0, 60.0),  # 3\n                (120.0, 40.0),  # 4\n                (80.0, 20.0),   # 5\n                (40.0, 10.0),   # 6\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R = case[\"R\"]\n        positions = case[\"positions\"]\n        src = case[\"src\"]\n        sink = case[\"sink\"]\n\n        e_one = one_hop_greedy_energy(positions, R, src, sink, L, E_elec, eps_fs, eps_mp, d0)\n        e_two = two_hop_informed_energy(positions, R, src, sink, L, E_elec, eps_fs, eps_mp, d0)\n        reduction = e_one - e_two\n        # Round to six decimal places\n        results.append(round(reduction, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Effective routing relies on metrics that accurately reflect the desired outcome, which is often minimal energy consumption. The Expected Transmission Count ($ETX$) is a widely used metric that captures link reliability, but is it always a faithful proxy for energy? This practice challenges you to move beyond simplistic assumptions by deriving the precise conditions under which minimizing path $ETX$ also minimizes energy. Through a carefully constructed counterexample , you will see how factors like in-network processing and data aggregation—common in Digital Twin applications—can break this equivalence, highlighting the need for metric-awareness in protocol design.",
            "id": "4254503",
            "problem": "A wireless sensor network in a cyber-physical system supporting a Digital Twin uses multihop routing to deliver application packets from a source to a sink. Consider the Expected Transmission Count (ETX) metric, defined per link as the expected number of link-layer transmission attempts required to successfully deliver a packet with an acknowledgment. Each link has a forward delivery probability $p$ for the data and a reverse delivery probability $q$ for the acknowledgment in a single attempt. Radios consume per-bit energy for transmit and receive, and acknowledgments use the same radio interface. Intermediate nodes may incur local processing energy and may modify the payload, changing its size before forwarding.\n\nFrom first principles of Bernoulli trials and bit-level radio energy accounting, derive the condition under which minimizing the sum of ETX values along a path is equivalent to minimizing the total energy per delivered packet along that path. Then, to exhibit a counterexample where uneven packet sizes and per-node processing costs invalidate this equivalence, consider two candidate paths between the same source and sink:\n\n- Path $\\mathcal{A}$ has two hops, with both links having $p = 0.99$ and $q = 0.99$. The source emits an application payload of size $S = 2000$ bits with acknowledgment size $A = 80$ bits. Both links use identical radios with per-bit transmit energy $\\alpha = 2.0 \\times 10^{-7}$ $\\mathrm{J/bit}$ and per-bit receive energy $\\beta = 1.0 \\times 10^{-7}$ $\\mathrm{J/bit}$. The intermediate node performs Digital Twin metadata fusion, incurring a per-packet processing energy $c_{\\mathrm{proc}} = 5.0 \\times 10^{-2}$ $\\mathrm{J}$ and increases the payload by a factor $h = 1.25$ before forwarding to the second hop. Assume the acknowledgment size does not change.\n\n- Path $\\mathcal{B}$ has a single hop with $p = 0.70$ and $q = 0.70$, carries the original payload size $S = 2000$ bits with acknowledgment size $A = 80$ bits, uses the same radio parameters $\\alpha$ and $\\beta$ as above, and has no intermediate node processing or payload modification.\n\nUse the following modeling assumptions for both paths: a single link-layer attempt consists of one data transmission and one acknowledgment transmission; per-attempt radio energy on a link with payload size $L$ is $(L + A)(\\alpha + \\beta)$; the expected number of attempts for success is the reciprocal of the per-attempt success probability.\n\nCompute the ratio $R$ of the energy per delivered packet on the ETX-minimizing path to the energy per delivered packet on the energy-minimizing path under these parameters. Express your final ratio $R$ as a dimensionless decimal, and round your answer to four significant figures.",
            "solution": "The problem is found to be scientifically grounded, well-posed, objective, and self-contained. All necessary parameters and models are provided, and they are consistent with established principles in wireless networking and communication theory. The problem is therefore deemed valid.\n\nThe solution is presented in two parts. First, we derive the general condition under which minimizing the sum of Expected Transmission Counts (ETX) is equivalent to minimizing total energy consumption. Second, we use the provided parameters for two specific paths to demonstrate a counterexample and compute the required ratio.\n\nLet us begin with the derivation from first principles. Consider a single wireless link $i$ in a multihop path. The probability of a successful data packet transmission is $p_i$, and the probability of a successful acknowledgment (ACK) transmission is $q_i$. A link-layer transmission attempt is considered successful only if both the data packet and its subsequent ACK are correctly received. Assuming these are independent events, the probability of success for a single attempt is $P_{\\mathrm{success}, i} = p_i q_i$.\n\nThe number of attempts required to achieve one success follows a geometric distribution. Each attempt is a Bernoulli trial with success probability $P_{\\mathrm{success}, i}$. The expected number of trials until the first success is the mean of this distribution, which is the definition of the Expected Transmission Count (ETX) for that link:\n$$\n\\mathrm{ETX}_i = \\frac{1}{P_{\\mathrm{success}, i}} = \\frac{1}{p_i q_i}\n$$\nFor a path $\\mathcal{P}$ consisting of $N$ hops (links), the total path ETX is the sum of the ETX values for each link:\n$$\n\\mathrm{ETX}_{\\mathcal{P}} = \\sum_{i=1}^{N} \\mathrm{ETX}_i = \\sum_{i=1}^{N} \\frac{1}{p_i q_i}\n$$\nMinimizing the ETX metric for routing involves finding a path $\\mathcal{P}$ that minimizes this sum.\n\nNext, we analyze the energy consumption. Let $L_i$ be the payload size of the data packet and $A_i$ be the size of the ACK packet for link $i$. Let $\\alpha$ be the per-bit transmit energy and $\\beta$ be the per-bit receive energy. Based on the problem's energy model, the total radio energy consumed by both the sender and receiver for a single attempt on link $i$ is:\n$$\nE_{\\mathrm{attempt}, i} = (L_i + A_i)(\\alpha + \\beta)\n$$\nThe total expected radio energy to successfully transmit a packet across link $i$ is the product of the energy per attempt and the expected number of attempts (ETX):\n$$\nE_{\\mathrm{link}, i} = E_{\\mathrm{attempt}, i} \\times \\mathrm{ETX}_i = \\frac{(L_i + A_i)(\\alpha + \\beta)}{p_i q_i}\n$$\nThe total energy per delivered packet along the path $\\mathcal{P}$ is the sum of the expected link energies plus the sum of any processing energies $c_{\\mathrm{proc}, j}$ incurred at the $N-1$ intermediate nodes (indexed by $j$):\n$$\nE_{\\mathcal{P}} = \\sum_{i=1}^{N} E_{\\mathrm{link}, i} + \\sum_{j=1}^{N-1} c_{\\mathrm{proc}, j} = \\sum_{i=1}^{N} \\bigg( \\frac{(L_i + A_i)(\\alpha + \\beta)}{p_i q_i} \\bigg) + \\sum_{j=1}^{N-1} c_{\\mathrm{proc}, j}\n$$\nWe seek the conditions under which minimizing $\\mathrm{ETX}_{\\mathcal{P}}$ is equivalent to minimizing $E_{\\mathcal{P}}$.\nComparing the expressions, we can write $E_{\\mathcal{P}}$ in terms of $\\mathrm{ETX}_i$:\n$$\nE_{\\mathcal{P}} = \\sum_{i=1}^{N} (L_i + A_i)(\\alpha + \\beta) \\cdot \\mathrm{ETX}_i + \\sum_{j=1}^{N-1} c_{\\mathrm{proc}, j}\n$$\nFor the minimization of $E_{\\mathcal{P}}$ to be equivalent to the minimization of $\\mathrm{ETX}_{\\mathcal{P}} = \\sum_{i=1}^{N} \\mathrm{ETX}_i$, the path energy $E_{\\mathcal{P}}$ must be a monotonically increasing function of $\\mathrm{ETX}_{\\mathcal{P}}$. The simplest such relationship is a direct proportionality, $E_{\\mathcal{P}} = K \\cdot \\mathrm{ETX}_{\\mathcal{P}}$, where $K$ is a positive constant that is independent of the chosen path. This occurs if the coefficients of $\\mathrm{ETX}_i$ are constant across all links $i$ in the network, and the processing costs are zero.\nSpecifically, we require two conditions:\n1.  The term $(L_i + A_i)(\\alpha + \\beta)$ must be a constant for all links $i$ on all possible paths. Assuming uniform radio characteristics ($\\alpha$, $\\beta$) and a standard, fixed-size ACK packet ($A_i = A$), this condition simplifies to requiring the data payload size $L_i$ to be constant for all hops. This means no intermediate node can alter the packet size (i.e., payload scaling factor $h=1$).\n2.  The processing energy at all intermediate nodes must be zero ($c_{\\mathrm{proc}, j} = 0$). If this is not zero, the term $\\sum c_{\\mathrm{proc}, j}$ biases the choice towards paths with fewer hops, which is not captured by the ETX metric.\n\nUnder these two conditions, $L_i = S$ for all $i$ and $c_{\\mathrm{proc}, j} = 0$. The total energy becomes:\n$$\nE_{\\mathcal{P}} = \\sum_{i=1}^{N} \\frac{(S + A)(\\alpha + \\beta)}{p_i q_i} = (S + A)(\\alpha + \\beta) \\sum_{i=1}^{N} \\frac{1}{p_i q_i} = (S + A)(\\alpha + \\beta) \\cdot \\mathrm{ETX}_{\\mathcal{P}}\n$$\nSince $(S + A)(\\alpha + \\beta)$ is a positive constant, minimizing $\\mathrm{ETX}_{\\mathcal{P}}$ is equivalent to minimizing $E_{\\mathcal{P}}$. The equivalence is violated if packet sizes vary between hops or if there are non-zero processing costs.\n\nNow, we evaluate the provided counterexample.\nGiven parameters: $S = 2000$ bits, $A = 80$ bits, $\\alpha = 2.0 \\times 10^{-7}$ J/bit, $\\beta = 1.0 \\times 10^{-7}$ J/bit. Thus, $\\alpha + \\beta = 3.0 \\times 10^{-7}$ J/bit.\n\nFor Path $\\mathcal{A}$ (2 hops):\nLink 1 and Link 2 have $p = 0.99$ and $q = 0.99$. The ETX for each link is identical:\n$$\n\\mathrm{ETX}_{A, \\text{link}} = \\frac{1}{0.99 \\times 0.99} = \\frac{1}{0.9801}\n$$\nThe total path ETX is the sum of the link ETXs:\n$$\n\\mathrm{ETX}_{\\mathcal{A}} = \\frac{1}{0.9801} + \\frac{1}{0.9801} = \\frac{2}{0.9801} \\approx 2.0406\n$$\nThe energy calculation for Path $\\mathcal{A}$ must account for the payload modification at the intermediate node.\nOn the first hop, the payload size is $L_1 = S = 2000$ bits. The expected energy is:\n$$\nE_{\\mathrm{link}, A, 1} = \\frac{(L_1 + A)(\\alpha + \\beta)}{p_1 q_1} = \\frac{(2000 + 80)(3.0 \\times 10^{-7})}{0.9801} = \\frac{2080 \\times 3.0 \\times 10^{-7}}{0.9801} = \\frac{6.24 \\times 10^{-4}}{0.9801} \\text{ J}\n$$\nThe intermediate node incurs processing energy $c_{\\mathrm{proc}} = 5.0 \\times 10^{-2}$ J and increases the payload size by a factor $h = 1.25$.\nThe payload size for the second hop is $L_2 = h \\times S = 1.25 \\times 2000 = 2500$ bits. The expected energy for the second hop is:\n$$\nE_{\\mathrm{link}, A, 2} = \\frac{(L_2 + A)(\\alpha + \\beta)}{p_2 q_2} = \\frac{(2500 + 80)(3.0 \\times 10^{-7})}{0.9801} = \\frac{2580 \\times 3.0 \\times 10^{-7}}{0.9801} = \\frac{7.74 \\times 10^{-4}}{0.9801} \\text{ J}\n$$\nThe total energy for Path $\\mathcal{A}$ is the sum of link energies and processing cost:\n$$\nE_{\\mathcal{A}} = E_{\\mathrm{link}, A, 1} + c_{\\mathrm{proc}} + E_{\\mathrm{link}, A, 2} = \\frac{6.24 \\times 10^{-4}}{0.9801} + 5.0 \\times 10^{-2} + \\frac{7.74 \\times 10^{-4}}{0.9801} = \\frac{1.398 \\times 10^{-3}}{0.9801} + 0.05 \\approx 0.051426 \\text{ J}\n$$\n\nFor Path $\\mathcal{B}$ (1 hop):\nThe link has $p = 0.70$ and $q = 0.70$. The total path ETX is:\n$$\n\\mathrm{ETX}_{\\mathcal{B}} = \\frac{1}{0.70 \\times 0.70} = \\frac{1}{0.49} \\approx 2.0408\n$$\nThere is no intermediate node, so the payload is $L_1 = S = 2000$ bits. The total energy for Path $\\mathcal{B}$ is:\n$$\nE_{\\mathcal{B}} = \\frac{(S + A)(\\alpha + \\beta)}{p q} = \\frac{(2000 + 80)(3.0 \\times 10^{-7})}{0.49} = \\frac{2080 \\times 3.0 \\times 10^{-7}}{0.49} = \\frac{6.24 \\times 10^{-4}}{0.49} \\approx 0.001273 \\text{ J}\n$$\n\nNow we compare the paths.\nFor the ETX metric: $\\mathrm{ETX}_{\\mathcal{A}} \\approx 2.0406$ and $\\mathrm{ETX}_{\\mathcal{B}} \\approx 2.0408$. Since $\\mathrm{ETX}_{\\mathcal{A}}  \\mathrm{ETX}_{\\mathcal{B}}$, Path $\\mathcal{A}$ is the ETX-minimizing path.\nFor the energy metric: $E_{\\mathcal{A}} \\approx 0.051426$ J and $E_{\\mathcal{B}} \\approx 0.001273$ J. Since $E_{\\mathcal{B}}  E_{\\mathcal{A}}$, Path $\\mathcal{B}$ is the energy-minimizing path.\nThe two metrics lead to different optimal paths due to the large processing cost and payload modification on Path $\\mathcal{A}$, which are factors ignored by the ETX metric.\n\nThe problem asks for the ratio $R$ of the energy of the ETX-minimizing path to the energy of the energy-minimizing path.\n$$\nR = \\frac{\\text{Energy of ETX-min path}}{\\text{Energy of energy-min path}} = \\frac{E_{\\mathcal{A}}}{E_{\\mathcal{B}}}\n$$\nSubstituting the calculated values:\n$$\nR = \\frac{\\frac{1.398 \\times 10^{-3}}{0.9801} + 0.05}{\\frac{6.24 \\times 10^{-4}}{0.49}} = \\frac{0.001426385... + 0.05}{0.001273469...} = \\frac{0.051426385...}{0.001273469...} \\approx 40.38289\n$$\nRounding to four significant figures, the ratio is $40.38$.",
            "answer": "$$\\boxed{40.38}$$"
        },
        {
            "introduction": "While previous exercises focused on optimizing the path for a single packet, real-world Cyber-Physical Systems must sustain continuous data flows over long periods. This shifts the focus from path energy to overall network lifetime. This advanced practice introduces a powerful technique for maximizing lifetime by formulating the routing challenge as a formal optimization problem. You will use Linear Programming to find a globally optimal traffic allocation that balances the energy depletion rates across all nodes , ensuring no single node becomes a premature bottleneck and extending the operational viability of the entire system.",
            "id": "4254451",
            "problem": "Consider a Wireless Sensor Network (WSN) in the context of Cyber-Physical Systems (CPS), represented as a directed graph with node set $\\mathcal{N}$ and directed edge set $\\mathcal{E} \\subseteq \\mathcal{N} \\times \\mathcal{N}$. There is a unique sink node $s \\in \\mathcal{N}$. Each node $i \\in \\mathcal{N}$ (excluding $s$) generates data at a constant rate $d_i$ measured in bits per second (bit/s), with $d_s = 0$. Each directed edge $(i,j) \\in \\mathcal{E}$ has a per-unit transmission energy cost $c_{ij}$ measured in Joules per bit (J/bit). Each node $i \\in \\mathcal{N}$ has a residual energy $E_i$ measured in Joules (J). All traffic is destined for the sink $s$, and the network operates in steady state with constant flow rates $f_{ij} \\geq 0$ on each edge $(i,j) \\in \\mathcal{E}$, in bits per second.\n\nFundamental base:\n- Flow conservation holds at every node: the net outgoing flow rate minus net incoming flow rate at node $i$ equals the data generation rate $d_i$ for $i \\neq s$, and equals $-\\sum_{k \\neq s} d_k$ for $i = s$.\n- The energy depletion rate at node $i$ is given by $p_i = \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij}$ measured in Joules per second (J/s).\n- The network lifetime $T$ measured in seconds (s) is the time until the first node's residual energy is exhausted under steady-state operation, i.e., $T = \\min_{i \\in \\mathcal{N}} \\frac{E_i}{p_i}$.\n\nTask: Write a complete, runnable program that, for each of the test cases below, computes the maximum achievable network lifetime $T$ under all feasible steady-state flows that satisfy nonnegativity and flow conservation. The solution must implement a mathematically sound method that embodies the principle of balancing marginal depletion rates across nodes to maximize $T$.\n\nAssumptions:\n- Reception energy costs are negligible compared to transmission; only transmission energy costs are considered in $p_i$.\n- All generated data must be delivered to the sink $s$.\n- There are no link capacity constraints beyond nonnegativity.\n\nUnits:\n- Answer in seconds (s) as decimal floating-point numbers.\n\nTest Suite:\nProvide results for the following four test cases. Each test case supplies $(\\mathcal{N}, s, \\mathcal{E}, \\{c_{ij}\\}, \\{E_i\\}, \\{d_i\\})$.\n\n- Test Case $1$ (single path aggregation, balanced by structure):\n    - Nodes: $\\mathcal{N} = \\{1,2,3\\}$, sink $s = 3$.\n    - Edges: $\\mathcal{E} = \\{(1,2),(2,3)\\}$.\n    - Costs: $c_{12} = 5 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{23} = 4 \\times 10^{-6}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 100$ $\\mathrm{J}$, $E_2 = 120$ $\\mathrm{J}$, $E_3 = 10000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 1000$ $\\mathrm{bit/s}$, $d_2 = 500$ $\\mathrm{bit/s}$, $d_3 = 0$ $\\mathrm{bit/s}$.\n\n- Test Case $2$ (splittable source traffic with asymmetric costs and heterogeneous energies):\n    - Nodes: $\\mathcal{N} = \\{1,2,3,4\\}$, sink $s = 4$.\n    - Edges: $\\mathcal{E} = \\{(1,2),(1,3),(2,4),(3,4)\\}$.\n    - Costs: $c_{12} = 6 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{13} = 3 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{24} = 5 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{34} = 8 \\times 10^{-6}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 150$ $\\mathrm{J}$, $E_2 = 90$ $\\mathrm{J}$, $E_3 = 60$ $\\mathrm{J}$, $E_4 = 1000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 2000$ $\\mathrm{bit/s}$, $d_2 = 0$ $\\mathrm{bit/s}$, $d_3 = 0$ $\\mathrm{bit/s}$, $d_4 = 0$ $\\mathrm{bit/s}$.\n\n- Test Case $3$ (tiny energy at source dominates lifetime):\n    - Nodes: $\\mathcal{N} = \\{1,2\\}$, sink $s = 2$.\n    - Edges: $\\mathcal{E} = \\{(1,2)\\}$.\n    - Costs: $c_{12} = 1 \\times 10^{-5}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 1$ $\\mathrm{J}$, $E_2 = 1000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 1000$ $\\mathrm{bit/s}$, $d_2 = 0$ $\\mathrm{bit/s}$.\n\n- Test Case $4$ (multiple sources funnel through a single forwarding node):\n    - Nodes: $\\mathcal{N} = \\{1,2,3,4,5\\}$, sink $s = 5$.\n    - Edges: $\\mathcal{E} = \\{(1,4),(2,4),(3,4),(4,5)\\}$.\n    - Costs: $c_{14} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{24} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{34} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{45} = 1 \\times 10^{-5}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 50$ $\\mathrm{J}$, $E_2 = 50$ $\\mathrm{J}$, $E_3 = 50$ $\\mathrm{J}$, $E_4 = 60$ $\\mathrm{J}$, $E_5 = 1000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 500$ $\\mathrm{bit/s}$, $d_2 = 1200$ $\\mathrm{bit/s}$, $d_3 = 300$ $\\mathrm{bit/s}$, $d_4 = 0$ $\\mathrm{bit/s}$, $d_5 = 0$ $\\mathrm{bit/s}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the lifetimes for the four test cases as a comma-separated list enclosed in square brackets, with each lifetime in seconds rounded to six decimal places (e.g., `[20000.000000,12750.000000,100.000000,3000.000000]`).",
            "solution": "The problem is assessed to be **valid**. It is a well-posed optimization problem grounded in the fundamental principles of network flow conservation and energy consumption models, which are standard in the analysis of Wireless Sensor Networks (WSN). The problem is self-contained, with all necessary data and constraints provided for each test case. The objective is clearly defined, and the formulation leads to a solvable mathematical structure, specifically a linear program, for which a unique optimal value for the network lifetime exists.\n\nThe problem is to determine the optimal routing strategy, defined by the set of steady-state flow rates $\\{f_{ij}\\}$, to maximize the network lifetime $T$. The lifetime is defined as the time until the first node depletes its energy, mathematically expressed as:\n$$\nT = \\min_{i \\in \\mathcal{N}} \\frac{E_i}{p_i}\n$$\nwhere $E_i$ is the initial energy of node $i$ and $p_i$ is its energy depletion rate. The depletion rate is due to data transmission:\n$$\np_i = \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij}\n$$\nHere, $c_{ij}$ is the energy cost per bit for transmission on link $(i,j)$ and $f_{ij}$ is the flow rate. For the sink node $s$ and any other node with no outgoing edges, $p_i = 0$, and their lifetime $E_i/p_i$ is considered infinite, so they do not constrain the network lifetime.\n\nMaximizing $T$ is a bottleneck optimization problem. It can be reformulated into a more standard form by seeking to minimize the reciprocal of the lifetime, $\\gamma = 1/T$. The objective function then becomes to minimize $\\gamma$. The constraint $T \\geq 1/\\gamma$ implies that for every node $i$:\n$$\n\\frac{E_i}{p_i} \\geq \\frac{1}{\\gamma} \\implies p_i \\leq E_i \\gamma\n$$\nThis leads to a set of linear inequality constraints on the flow variables $f_{ij}$ and the new variable $\\gamma$:\n$$\n\\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij} - E_i \\gamma \\leq 0 \\quad \\forall i \\in \\mathcal{N} \\setminus \\{s\\}\n$$\nThe flows $\\{f_{ij}\\}$ must also satisfy the flow conservation laws at each non-sink node: for each $i \\in \\mathcal{N} \\setminus \\{s\\}$, the total outgoing flow must equal the total incoming flow plus the data generated at that node.\n$$\n\\sum_{j:(i,j) \\in \\mathcal{E}} f_{ij} - \\sum_{k:(k,i) \\in \\mathcal{E}} f_{ki} = d_i \\quad \\forall i \\in \\mathcal{N} \\setminus \\{s\\}\n$$\nFinally, the flow rates must be non-negative, $f_{ij} \\geq 0$.\n\nCombining these elements, we arrive at the following Linear Programming (LP) formulation:\n\n**Variables:**\n- $\\gamma$: The maximum normalized energy depletion rate (inverse of lifetime $T$).\n- $f_{ij}$: The flow rate on each directed edge $(i, j) \\in \\mathcal{E}$.\n\n**Objective:**\nMinimize $\\gamma$.\n\n**Subject to:**\n1.  **Lifetime Constraints:** For each transmitting node $i \\in \\mathcal{N} \\setminus \\{s\\}$:\n    $$\n    \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij} - E_i \\gamma \\leq 0\n    $$\n2.  **Flow Conservation Constraints:** For each node $i \\in \\mathcal{N} \\setminus \\{s\\}$:\n    $$\n    \\sum_{j:(i,j) \\in \\mathcal{E}} f_{ij} - \\sum_{k:(k,i) \\in \\mathcal{E}} f_{ki} = d_i\n    $$\n3.  **Non-negativity Constraints:** For all edges $(i,j) \\in \\mathcal{E}$:\n    $$\n    f_{ij} \\geq 0\n    $$\n    and $\\gamma \\geq 0$.\n\nThis LP can be solved using standard optimization solvers. The solution provides the minimum possible value of $\\gamma$, let's call it $\\gamma^*$. The maximum achievable network lifetime is then $T_{max} = 1/\\gamma^*$. If $\\gamma^*=0$, the lifetime is infinite. This formulation embodies the principle of balancing depletion rates, as the optimal solution typically drives the normalized depletion rates $p_i/E_i$ of a subset of nodes (the bottleneck nodes) to be equal to the maximum value $\\gamma^*$.\n\nThe algorithmic solution involves constructing the matrices and vectors that represent this LP in the standard form required by a solver, such as `scipy.optimize.linprog`. Specifically, we map the problem into the form:\n`minimize c @ x`\n`subject to A_ub @ x = b_ub`\n`A_eq @ x == b_eq`\n\nThe variable vector `x` is constructed by concatenating $\\gamma$ and all flow variables $f_{ij}$. The objective vector `c` is $[1, 0, 0, ...]$. The matrices `A_ub` and `A_eq` and vectors `b_ub` and `b_eq` are populated according to the lifetime and flow conservation constraints derived above. Once the LP is solved, the result `res.fun` gives $\\gamma^*$, and the final answer is computed as $1/\\gamma^*$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the WSN lifetime maximization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: single path aggregation, balanced by structure\n        {\n            \"nodes\": {1, 2, 3},\n            \"sink\": 3,\n            \"edges\": {(1, 2), (2, 3)},\n            \"costs\": {(1, 2): 5e-6, (2, 3): 4e-6},\n            \"energies\": {1: 100, 2: 120, 3: 10000},\n            \"rates\": {1: 1000, 2: 500, 3: 0},\n        },\n        # Test Case 2: splittable source traffic with asymmetric costs and heterogeneous energies\n        {\n            \"nodes\": {1, 2, 3, 4},\n            \"sink\": 4,\n            \"edges\": {(1, 2), (1, 3), (2, 4), (3, 4)},\n            \"costs\": {(1, 2): 6e-6, (1, 3): 3e-6, (2, 4): 5e-6, (3, 4): 8e-6},\n            \"energies\": {1: 150, 2: 90, 3: 60, 4: 1000},\n            \"rates\": {1: 2000, 2: 0, 3: 0, 4: 0},\n        },\n        # Test Case 3: tiny energy at source dominates lifetime\n        {\n            \"nodes\": {1, 2},\n            \"sink\": 2,\n            \"edges\": {(1, 2)},\n            \"costs\": {(1, 2): 1e-5},\n            \"energies\": {1: 1, 2: 1000},\n            \"rates\": {1: 1000, 2: 0},\n        },\n        # Test Case 4: multiple sources funnel through a single forwarding node\n        {\n            \"nodes\": {1, 2, 3, 4, 5},\n            \"sink\": 5,\n            \"edges\": {(1, 4), (2, 4), (3, 4), (4, 5)},\n            \"costs\": {(1, 4): 2e-6, (2, 4): 2e-6, (3, 4): 2e-6, (4, 5): 1e-5},\n            \"energies\": {1: 50, 2: 50, 3: 50, 4: 60, 5: 1000},\n            \"rates\": {1: 500, 2: 1200, 3: 300, 4: 0, 5: 0},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        lifetime = solve_case(case)\n        results.append(f\"{lifetime:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(case_data):\n    \"\"\"\n    Formulates and solves the LP for a single test case.\n\n    The LP is set up to minimize gamma = 1/T, where T is the network lifetime.\n    Variables are [gamma, f_1, f_2, ..., f_m], where f_i are flow variables.\n    \"\"\"\n    nodes = sorted(list(case_data[\"nodes\"]))\n    sink_node = case_data[\"sink\"]\n    edges = sorted(list(case_data[\"edges\"]))\n    costs = case_data[\"costs\"]\n    energies = case_data[\"energies\"]\n    rates = case_data[\"rates\"]\n\n    node_to_idx = {node: i for i, node in enumerate(nodes)}\n    non_sink_nodes = [n for n in nodes if n != sink_node]\n    \n    m = len(edges)\n    edge_to_idx = {edge: i for i, edge in enumerate(edges)}\n    \n    # LP variables are: [gamma, f_0, f_1, ... f_{m-1}]\n    num_vars = 1 + m\n    \n    # Objective function: minimize gamma\n    # c = [1, 0, 0, ...]\n    c = np.zeros(num_vars)\n    c[0] = 1\n\n    # Equality constraints (flow conservation)\n    # For each non-sink node i: sum(f_out) - sum(f_in) = d_i\n    num_eq_constraints = len(non_sink_nodes)\n    A_eq = np.zeros((num_eq_constraints, num_vars))\n    b_eq = np.zeros(num_eq_constraints)\n\n    for i, node in enumerate(non_sink_nodes):\n        b_eq[i] = rates.get(node, 0)\n        for edge_idx, edge in enumerate(edges):\n            u, v = edge\n            # Variable index for flow f_uv is 1 + edge_idx\n            var_idx = 1 + edge_idx\n            if u == node:\n                A_eq[i, var_idx] = 1  # Outgoing flow\n            if v == node:\n                A_eq[i, var_idx] = -1 # Incoming flow\n\n    # Inequality constraints (lifetime)\n    # For each transmitting non-sink node i: sum(c_ij * f_ij) - E_i * gamma = 0\n    transmitting_nodes = {u for u, v in edges if u != sink_node}\n    num_ub_constraints = len(transmitting_nodes)\n    A_ub = np.zeros((num_ub_constraints, num_vars))\n    b_ub = np.zeros(num_ub_constraints)\n    \n    for i, node in enumerate(sorted(list(transmitting_nodes))):\n        # Gamma coefficient\n        A_ub[i, 0] = -energies.get(node, 0)\n        \n        # Flow coefficients\n        for edge_idx, edge in enumerate(edges):\n            u, v = edge\n            if u == node:\n                var_idx = 1 + edge_idx\n                A_ub[i, var_idx] = costs.get(edge, 0)\n\n    # Bounds: gamma = 0, f_ij = 0\n    bounds = (0, None)\n\n    # Solve the linear program\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if not res.success:\n        raise RuntimeError(\"LP solver failed to find a solution.\")\n\n    # Optimal gamma is the minimum value of the objective function\n    gamma_star = res.fun\n    \n    # Handle case of infinite lifetime\n    if gamma_star = 1e-9: # Using a small tolerance for floating point\n        return float('inf')\n\n    # Lifetime is 1/gamma\n    max_lifetime = 1.0 / gamma_star\n    return max_lifetime\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}