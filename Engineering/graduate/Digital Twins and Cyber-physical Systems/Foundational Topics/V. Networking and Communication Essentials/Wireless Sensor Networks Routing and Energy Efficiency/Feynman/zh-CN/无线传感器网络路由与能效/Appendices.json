{
    "hands_on_practices": [
        {
            "introduction": "第一个实践练习将深入探讨节能路由的核心，通过比较两种基本的地理路由策略。您将实现并评估一种简单的贪婪方法与一种更具前瞻性的两跳预见策略，从而量化通过局部前瞻性决策所获得的能量节省。这项练习  为理解无线传感器网络中路由简单性与能效之间的权衡提供了基础。",
            "id": "4254469",
            "problem": "一个无线传感器网络（WSN）的数字孪生（DT）被用于在真实的无线电能耗模型下，评估节能地理路由策略。该网络嵌入在一个二维欧几里得平面中。每个节点都有一个已知位置，两个节点之间存在通信链路当且仅当它们之间的欧几里得距离小于或等于指定的通信半径。任务是，对于给定的拓扑和无线电参数，计算从指定源节点向汇聚节点（基站）转发单个数据包时，双跳知情地理路由策略相比于单跳贪婪地理路由策略所实现的能量减少量。\n\n基本原理：\n- 点 $(x_1,y_1)$ 和 $(x_2,y_2)$ 之间的欧几里得距离为 $d=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。\n- 无线电能耗模型：传输能量与距离相关，存在自由空间路径损耗模式和多径路径损耗模式。设 $L$ 为数据包长度（单位：比特），$E_{\\mathrm{elec}}$ 为每比特的电子能耗（单位：焦耳/比特），$\\epsilon_{\\mathrm{fs}}$ 为自由空间放大器系数（单位：焦耳/比特/平方米），$\\epsilon_{\\mathrm{mp}}$ 为多径放大器系数（单位：焦耳/比特/米^4）。定义模式阈值 $d_0=\\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$。则传输距离为 $d$ 时的发射能耗为\n$$\nE_{\\mathrm{tx}}(d) = \n\\begin{cases}\nL\\,E_{\\mathrm{elec}} + L\\,\\epsilon_{\\mathrm{fs}}\\,d^2,  \\text{若 } d \\le d_0,\\\\\nL\\,E_{\\mathrm{elec}} + L\\,\\epsilon_{\\mathrm{mp}}\\,d^4,  \\text{若 } d > d_0.\n\\end{cases}\n$$\n接收能耗与距离无关，由 $E_{\\mathrm{rx}}(L) = L\\,E_{\\mathrm{elec}}$ 给出。\n\n路由策略：\n- 单跳贪婪地理路由：从当前节点出发的每一步，选择一个其到汇聚节点的欧几里得距离严格小于当前节点到汇聚节点距离的邻居节点，并在所有此类邻居中选择到汇聚节点距离最小的那个。如果出现平局，则选择最小化当前节点到邻居节点欧几里得距离的那个邻居；如果仍然平局，则选择节点索引最小的那个。重复此过程直到到达汇聚节点。单跳路由的总能耗是所有跳的 $E_{\\mathrm{tx}}(d_{\\text{hop}}) + E_{\\mathrm{rx}}(L)$ 之和，包括在汇聚节点的最终接收。\n- 双跳知情地理路由：从当前节点出发的每一步，如果汇聚节点可直接到达（即在通信半径内），则直接向汇聚节点传输。否则，构建候选对 $(i,j)$，其中 $i$ 是当前节点的邻居且其到汇聚节点的距离严格更小，$j$ 是 $i$ 的邻居且其到汇聚节点的距离比当前节点到汇聚节点的距离严格更小（如果汇聚节点在 $i$ 的通信半径内，它本身也可作为 $j$）。对于每个候选对，计算双跳段能耗 $E_{\\mathrm{tx}}(d_{\\text{current},i}) + E_{\\mathrm{rx}}(L) + E_{\\mathrm{tx}}(d_{i,j}) + E_{\\mathrm{rx}}(L)$。选择具有最小双跳段能耗的对；平局由 $j$ 的最小汇聚节点距离、然后是 $i$ 的最小汇聚节点距离、最后是 $(i,j)$ 索引的字典序来打破。执行这两跳，并将当前节点设置为 $j$。重复此过程直到到达汇聚节点。双跳路由的总能耗是所有执行跳的发射和接收能耗之和。\n\n任务：\n对于每个提供的测试拓扑和参数集，计算能量减少量，其定义为单跳贪婪路由路径的总能耗与双跳知情路由路径的总能耗之差，两者均在指定的无线电模型下计算。能量以焦耳为单位，表示为四舍五入到六位小数的十进制数。\n\n测试套件和参数：\n- 所有测试用例中使用的通用无线电参数：\n  - 数据包长度 $L = 4096$ 比特。\n  - 每比特电子能耗 $E_{\\mathrm{elec}} = 5\\times 10^{-8}$ 焦耳/比特。\n  - 自由空间放大器系数 $\\epsilon_{\\mathrm{fs}} = 10^{-11}$ 焦耳/比特/平方米。\n  - 多径放大器系数 $\\epsilon_{\\mathrm{mp}} = 1.3\\times 10^{-15}$ 焦耳/比特/米^4。\n  - 模式阈值 $d_0 = \\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$ 米。\n\n- 测试用例 1 (理想路径；预期双跳会有改进)：\n  - 通信半径 $R = 60$ 米。\n  - 节点 (索引: 坐标，单位：米)：\n    - $0$: $(200,0)$ 源节点。\n    - $1$: $(0,0)$ 汇聚节点。\n    - $2$: $(150,0)$。\n    - $3$: $(90,0)$。\n    - $4$: $(30,0)$。\n    - $5$: $(160,45)$。\n    - $6$: $(120,30)$。\n    - $7$: $(80,20)$。\n    - $8$: $(40,10)$。\n- 测试用例 2 (边界情况；预期能耗相等)：\n  - 通信半径 $R = 60$ 米。\n  - 节点：\n    - $0$: $(200,0)$ 源节点。\n    - $1$: $(0,0)$ 汇聚节点。\n    - $2$: $(150,0)$。\n    - $3$: $(100,0)$。\n    - $4$: $(50,0)$。\n- 测试用例 3 (接近阈值的边缘情况；预期双跳有较大改进)：\n  - 通信半径 $R = 120$ 米。\n  - 节点：\n    - $0$: $(200,0)$ 源节点。\n    - $1$: $(0,0)$ 汇聚节点。\n    - $2$: $(100,0)$。\n    - $3$: $(160,60)$。\n    - $4$: $(120,40)$。\n    - $5$: $(80,20)$。\n    - $6$: $(40,10)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的能量减少量，格式为一个用方括号括起来的逗号分隔列表，每个值都以焦耳为单位四舍五入到六位小数（例如，\"[$x_1$,$x_2$,$x_3$]\"）。",
            "solution": "该问题基于在无线传感器网络（WSN）研究和信息物理系统数字孪生（DT）中广泛使用的物理无线电能耗模型。该模型将每比特的电子能耗与依赖于距离的放大器能耗相结合，短距离遵循自由空间定律，长距离遵循多径定律。阈值 $d_0=\\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$ 划分了这两种模式之间的转换。\n\n基本原理：\n- 位于 $(x_1,y_1)$ 和 $(x_2,y_2)$ 的两个节点之间的欧几里得距离为 $d=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$，确保了以米为单位的物理上有意义的距离。\n- 发射能耗 $E_{\\mathrm{tx}}(d)$ 在 $d \\le d_0$ 时采用自由空间放大器模型 $L\\,\\epsilon_{\\mathrm{fs}}\\,d^2$，在 $d>d_0$ 时采用多径放大器模型 $L\\,\\epsilon_{\\mathrm{mp}}\\,d^4$，并带有一个恒定的电子成本 $L\\,E_{\\mathrm{elec}}$。\n- 接收能耗 $E_{\\mathrm{rx}}(L)=L\\,E_{\\mathrm{elec}}$ 与距离无关，模拟了接收端的解码和基带处理成本。\n\n算法设计：\n1. 通过连接任何欧几里得距离小于或等于通信半径 $R$ 的节点对来构建通信图。这反映了真实的物理邻接关系。\n2. 单跳贪婪地理路由：\n   - 从当前节点 $c$ 开始，枚举满足 $d(n,\\mathrm{sink})<d(c,\\mathrm{sink})$ 的所有邻居 $n$。\n   - 在这些候选者中，选择最小化 $d(n,\\mathrm{sink})$ 的节点。\n   - 使用指定的规则解决平局，并将该跳的能耗（$E_{\\mathrm{tx}}+E_{\\mathrm{rx}}$）累加到总能耗中。\n   - 重复此过程，直到到达汇聚节点。最终的接收也计入总能耗中。\n\n3. 双跳知情地理路由：\n   - 从当前节点 $c$ 开始，如果可以直接到达汇聚节点，则执行单跳并更新总能耗。\n   - 否则，考虑所有双跳路径 $(c,i,j)$，其中 $i$ 是 $c$ 的邻居且 $d(i,\\mathrm{sink})<d(c,\\mathrm{sink})$，$j$ 是 $i$ 的邻居且 $d(j,\\mathrm{sink})<d(c,\\mathrm{sink})$。\n   - 计算每个候选双跳路径的能耗：$E_{\\mathrm{tx}}(d_{ci}) + E_{\\mathrm{rx}}(L) + E_{\\mathrm{tx}}(d_{ij}) + E_{\\mathrm{rx}}(L)$。\n   - 选择能耗最小的双跳路径，并使用指定的规则解决平局。\n   - 将这两跳的能耗累加到总能耗中，并将当前节点更新为 $j$。\n   - 如果没有有效的双跳路径，算法必须回退到单跳贪婪选择以确保进展。\n   - 重复此过程，直到到达汇聚节点。\n\n4. 能量减少量：\n   - 对于每个测试用例，运行这两种算法来获得总能耗 $E_{\\mathrm{one-hop}}$ 和 $E_{\\mathrm{two-hop}}$。\n   - 能量减少量为 $E_{\\mathrm{one-hop}} - E_{\\mathrm{two-hop}}$。\n\n以下提供的 Python 代码实现了这些算法，处理了所提供的拓扑结构，并为每个测试用例计算了最终的能量减少量，格式化为指定的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef euclidean_distance(p, q):\n    return float(np.linalg.norm(np.array(p) - np.array(q)))\n\ndef build_adjacency(positions, R):\n    n = len(positions)\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            d = euclidean_distance(positions[i], positions[j])\n            if d = R + 1e-12:  # tolerances for floating-point\n                adj[i].append(j)\n    return adj\n\ndef radio_params():\n    # Common radio parameters for all test cases\n    L = 4096  # bits\n    E_elec = 5e-8  # J/bit\n    eps_fs = 1e-11  # J/bit/m^2\n    eps_mp = 1.3e-15  # J/bit/m^4\n    d0 = np.sqrt(eps_fs / eps_mp)\n    return L, E_elec, eps_fs, eps_mp, d0\n\ndef E_tx(d, L, E_elec, eps_fs, eps_mp, d0):\n    if d = d0:\n        return L * E_elec + L * eps_fs * (d ** 2)\n    else:\n        return L * E_elec + L * eps_mp * (d ** 4)\n\ndef E_rx(L, E_elec):\n    return L * E_elec\n\ndef one_hop_greedy_energy(positions, R, src_idx, sink_idx, L, E_elec, eps_fs, eps_mp, d0):\n    adj = build_adjacency(positions, R)\n    total_energy = 0.0\n    current = src_idx\n    sink_pos = positions[sink_idx]\n\n    # Safety cap to avoid infinite loops\n    max_steps = 10000\n    steps = 0\n\n    while current != sink_idx and steps  max_steps:\n        steps += 1\n        current_pos = positions[current]\n        current_sink_dist = euclidean_distance(current_pos, sink_pos)\n\n        # Candidate neighbors strictly closer to sink\n        candidates = []\n        for n in adj[current]:\n            n_pos = positions[n]\n            n_sink_dist = euclidean_distance(n_pos, sink_pos)\n            if n_sink_dist  current_sink_dist - 1e-12:  # strict progress\n                d_cn = euclidean_distance(current_pos, n_pos)\n                candidates.append((n, n_sink_dist, d_cn))\n\n        if not candidates:\n            # No progress possible under greedy; for this test suite it should not occur\n            raise RuntimeError(\"Greedy routing failed to find a progress neighbor.\")\n\n        # Choose neighbor minimizing sink distance, then minimizing hop distance, then index\n        candidates.sort(key=lambda x: (x[1], x[2], x[0]))\n        next_node = candidates[0][0]\n        hop_dist = candidates[0][2]\n\n        # Accumulate energy: transmit + receive at next node\n        total_energy += E_tx(hop_dist, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n\n        current = next_node\n\n    if steps >= max_steps:\n        raise RuntimeError(\"Exceeded maximum steps in greedy routing.\")\n\n    return total_energy\n\ndef two_hop_informed_energy(positions, R, src_idx, sink_idx, L, E_elec, eps_fs, eps_mp, d0):\n    adj = build_adjacency(positions, R)\n    total_energy = 0.0\n    current = src_idx\n    sink_pos = positions[sink_idx]\n\n    max_steps = 10000\n    steps = 0\n\n    while current != sink_idx and steps  max_steps:\n        steps += 1\n        current_pos = positions[current]\n        current_sink_dist = euclidean_distance(current_pos, sink_pos)\n\n        # If sink is directly reachable, do a single hop\n        if sink_idx in adj[current]:\n            d_cs = euclidean_distance(current_pos, sink_pos)\n            total_energy += E_tx(d_cs, L, E_elec, eps_fs, eps_mp, d0)\n            total_energy += E_rx(L, E_elec)\n            current = sink_idx\n            break\n\n        # Build candidate two-hop pairs (i, j)\n        pairs = []\n        for i in adj[current]:\n            i_pos = positions[i]\n            i_sink_dist = euclidean_distance(i_pos, sink_pos)\n            if i_sink_dist >= current_sink_dist - 1e-12:\n                continue  # must be closer than current to sink\n            # Neighbors of i that are closer than current\n            # Include sink if reachable from i\n            for j in adj[i]:\n                j_pos = positions[j]\n                j_sink_dist = euclidean_distance(j_pos, sink_pos)\n                if j_sink_dist  current_sink_dist - 1e-12:\n                    d_ci = euclidean_distance(current_pos, i_pos)\n                    d_ij = euclidean_distance(i_pos, j_pos)\n                    seg_energy = (\n                        E_tx(d_ci, L, E_elec, eps_fs, eps_mp, d0)\n                        + E_rx(L, E_elec)\n                        + E_tx(d_ij, L, E_elec, eps_fs, eps_mp, d0)\n                        + E_rx(L, E_elec)\n                    )\n                    pairs.append((seg_energy, j_sink_dist, i_sink_dist, i, j, d_ci, d_ij))\n\n        if not pairs:\n            # Fall back: pick a one-hop progress neighbor if no two-hop pair exists\n            candidates = []\n            for n in adj[current]:\n                n_pos = positions[n]\n                n_sink_dist = euclidean_distance(n_pos, sink_pos)\n                if n_sink_dist  current_sink_dist - 1e-12:\n                    d_cn = euclidean_distance(current_pos, n_pos)\n                    candidates.append((n, n_sink_dist, d_cn))\n            if not candidates:\n                raise RuntimeError(\"Two-hop routing failed to find progress.\")\n            candidates.sort(key=lambda x: (x[1], x[2], x[0]))\n            next_node = candidates[0][0]\n            hop_dist = candidates[0][2]\n            total_energy += E_tx(hop_dist, L, E_elec, eps_fs, eps_mp, d0)\n            total_energy += E_rx(L, E_elec)\n            current = next_node\n            continue\n\n        # Choose pair minimizing energy; tie-breakers as specified\n        pairs.sort(key=lambda x: (x[0], x[1], x[2], x[3], x[4]))\n        best = pairs[0]\n        _, _, _, i, j, d_ci, d_ij = best\n\n        # Execute the two hops sequentially\n        total_energy += E_tx(d_ci, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n        total_energy += E_tx(d_ij, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n\n        current = j\n\n    if steps >= max_steps:\n        raise RuntimeError(\"Exceeded maximum steps in two-hop routing.\")\n\n    return total_energy\n\ndef solve():\n    L, E_elec, eps_fs, eps_mp, d0 = radio_params()\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"R\": 60.0,\n            \"positions\": [\n                (200.0, 0.0),  # 0 source\n                (0.0, 0.0),    # 1 sink\n                (150.0, 0.0),  # 2\n                (90.0, 0.0),   # 3\n                (30.0, 0.0),   # 4\n                (160.0, 45.0), # 5\n                (120.0, 30.0), # 6\n                (80.0, 20.0),  # 7\n                (40.0, 10.0),  # 8\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n        # Test Case 2\n        {\n            \"R\": 60.0,\n            \"positions\": [\n                (200.0, 0.0),  # 0 source\n                (0.0, 0.0),    # 1 sink\n                (150.0, 0.0),  # 2\n                (100.0, 0.0),  # 3\n                (50.0, 0.0),   # 4\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n        # Test Case 3\n        {\n            \"R\": 120.0,\n            \"positions\": [\n                (200.0, 0.0),   # 0 source\n                (0.0, 0.0),     # 1 sink\n                (100.0, 0.0),   # 2\n                (160.0, 60.0),  # 3\n                (120.0, 40.0),  # 4\n                (80.0, 20.0),   # 5\n                (40.0, 10.0),   # 6\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R = case[\"R\"]\n        positions = case[\"positions\"]\n        src = case[\"src\"]\n        sink = case[\"sink\"]\n\n        e_one = one_hop_greedy_energy(positions, R, src, sink, L, E_elec, eps_fs, eps_mp, d0)\n        e_two = two_hop_informed_energy(positions, R, src, sink, L, E_elec, eps_fs, eps_mp, d0)\n        reduction = e_one - e_two\n        # Round to six decimal places\n        results.append(round(reduction, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在基本能量模型的基础上，本实践将探索物理层参数与网络层性能之间错综复杂的关系。您将对从发射功率到信噪比、误码率，最终到链路可靠性和能量成本的整个链条进行建模。这个全面的仿真练习  揭示了通过降低功率来节省能源与维持网络鲁棒连接性之间的关键工程权衡。",
            "id": "4254534",
            "problem": "一个小型无线传感器网络嵌入在一个信息物理系统中，并由一个数字孪生进行镜像。该网络包含 $N$ 个传感器节点和一个汇聚节点。这些节点通过一个固定的种子在一个边长为 $S$ 米的正方形区域内进行随机但确定性的放置，汇聚节点位于中心。每个传感器必须使用多跳路由将一个数据包传递到汇聚节点。程序必须量化降低发射功率对链路数据包接收率 ($PRR$) 和期望传输次数 ($ETX$) 的影响，并且必须计算网络中净能量节省与连通性损失的权衡。\n\n该设置使用以下经过充分测试的基础模型和定义，将物理层效应与网络性能联系起来：\n\n- 对数距离路径损耗：接收功率（单位：分贝毫瓦）为 $P_r(\\mathrm{dBm}) = P_t(\\mathrm{dBm}) + G_t + G_r - PL(d)$，其中对于 $d \\ge d_0$，路径损耗 $PL(d) = PL(d_0) + 10 n \\log_{10}(d/d_0)$。$n$ 是路径损耗指数，$G_t$ 和 $G_r$ 是天线增益（单位：分贝），$d_0$ 是参考距离，$PL(d_0)$ 是自由空间参考损耗，$PL(d_0) = 20 \\log_{10}(4 \\pi d_0 / \\lambda)$，其中 $\\lambda = c/f$，$c$ 是光速，$f$ 是载波频率。\n- 热噪声（单位：分贝毫瓦）：$N(\\mathrm{dBm}) = -174 + 10 \\log_{10}(B) + NF$，其中 $B$ 是接收机带宽（单位：赫兹），$NF$ 是接收机噪声系数（单位：分贝）。假设 $B \\approx R_b$，其中 $R_b$ 是比特率，使得 $E_b/N_0 \\approx \\mathrm{SNR}$。\n- 加性高斯白噪声 (AWGN) 信道下的二进制相移键控 (BPSK)：误码率 (BER) 为 $\\mathrm{BER} = Q\\!\\left(\\sqrt{2 E_b/N_0}\\right)$，其中 $Q(x)$ 是标准正态分布的尾概率，$Q(x) = \\tfrac{1}{2}\\,\\mathrm{erfc}\\!\\left(x/\\sqrt{2}\\right)$。\n- 在比特错误独立的假设下，一个长度为 $L$ 比特的数据包的接收率 $PRR$ 为 $PRR = (1 - \\mathrm{BER})^{L}$。\n\n假设确认 (ACK) 机制要求发送方接收到一个长度为 $L_\\mathrm{ack}$ 比特的确认包来确认送达。令 $df$ 和 $dr$ 分别表示一条链路的前向和反向 $PRR$。从以上定义出发，定义带确认的单播的期望传输次数 $ETX$ 为成功接收一个 ACK 所需的数据传输期望次数。类似地，根据 $dr$ 推导出每次成功的端到端传输所需的 ACK 传输期望次数。\n\n令每次尝试的数据传输能量为 $E_\\mathrm{tx,data} = P_t \\, T_\\mathrm{data}$，其中 $T_\\mathrm{data} = L / R_b$；每次 ACK 的传输能量为 $E_\\mathrm{tx,ack} = P_t \\, T_\\mathrm{ack}$，其中 $T_\\mathrm{ack} = L_\\mathrm{ack} / R_b$。使用前面的定义，推导在单跳上成功投递一次所需的每链路期望传输能量成本，用 $ETX$、$E_\\mathrm{tx,data}$ 和 $dr$ 表示。对于路由，使用可加性路径成本，其等于沿路径的每链路期望传输能量成本之和。如果一条链路在任一方向上的 $PRR  10^{-3}$，则认为该链路不可用。将 $PRR$ 视为对称且在两个方向上相同，即 $df = dr$。\n\n网络几何与物理参数：\n- 传感器数量：$N = 12$。\n- 区域边长：$S = 200$ 米。\n- 随机放置种子：$42$。\n- 汇聚节点位置：中心 $(S/2, S/2)$ 米。\n- 数据包长度：$L = 1024$ 比特。\n- ACK 包长度：$L_\\mathrm{ack} = 112$ 比特。\n- 比特率：$R_b = 250 \\times 10^3$ 比特/秒。\n- 载波频率：$f = 2.4 \\times 10^9$ 赫兹。\n- 路径损耗指数：$n = 2.7$。\n- 参考距离：$d_0 = 1$ 米。\n- 天线增益：$G_t = 0$ 分贝，$G_r = 0$ 分贝。\n- 噪声系数：$NF = 5$ 分贝。\n- 基准发射功率：$P_{t,\\mathrm{base}} = 10$ 毫瓦。\n\n对于每个测试用例，网络拓扑是相同的；只有发射功率改变。计算所有链路的 $PRR$ 和 $ETX$，并通过排除不可用链路来构建路由图。对于每个传感器节点，使用可加性的每链路成本计算到汇聚节点的最小期望传输能量路径。将给定发射功率下的连通集定义为至少有一条到汇聚节点的有限成本路径的传感器节点集合。\n\n为每个测试用例定义以下结果指标：\n- 网络总期望传输能量（单位：焦耳），用于将降功率连通集中的每个传感器的一个数据包传输到汇聚节点。此能量在基准和降功率两种每链路成本下对同一组节点进行评估，以实现公平的能量比较。计算绝对能量节省（单位：焦耳）为基准总能量与降低后总能量之差，以及能量节省分数，为小数 $(E_\\mathrm{base} - E_\\mathrm{reduced})/E_\\mathrm{base}$。如果 $E_\\mathrm{base} = 0$，则报告能量节省分数为 $0$。\n- 连通性损失，为小数 $(|C_\\mathrm{base}| - |C_\\mathrm{reduced}|)/|C_\\mathrm{base}|$，其中 $C_\\mathrm{base}$ 和 $C_\\mathrm{reduced}$ 分别是基准和降功率连通集。\n- 平均 $PRR$ 比率，为在基准和降功率图中均可用的所有无向链路上 $PRR_\\mathrm{reduced}/PRR_\\mathrm{base}$ 的均值。如果交集为空，则报告 $0$。\n- 平均 $ETX$ 比率，为在同一组链路上 $ETX_\\mathrm{reduced}/ETX_\\mathrm{base}$ 的均值。如果交集为空，则报告 $0$。\n\n不涉及角度单位。所有能量必须以焦耳表示，功率以瓦特表示。距离以米为单位。\n\n相对于基准 $P_{t,\\mathrm{base}}$ 的发射功率降低测试套件：\n- 用例 $1$：降低 $0$ 分贝。\n- 用例 $2$：降低 $3$ 分贝。\n- 用例 $3$：降低 $8$ 分贝。\n- 用例 $4$：降低 $15$ 分贝。\n\n最终输出格式：您的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起来。其中每个元素是每个测试用例的五个浮点数列表，顺序为 $[E_\\mathrm{saved,J}, E_\\mathrm{saved,frac}, \\mathrm{conn\\_loss}, \\mathrm{avg\\_PRR\\_ratio}, \\mathrm{avg\\_ETX\\_ratio}]$。例如，总体结构应为 $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$。",
            "solution": "用户提供了一个需要对无线传感器网络进行多层次分析的问题，将物理层现象与网络级性能指标（如能耗和连通性）联系起来。\n\n### 问题验证\n\n**第 1 步：提取给定条件**\n- 网络规模：$N = 12$ 个传感器，1 个汇聚节点。\n- 部署区域：正方形，边长 $S = 200$ 米。\n- 节点放置：随机，种子为 $42$。\n- 汇聚节点位置：$(S/2, S/2)$。\n- 数据包大小：数据包 $L = 1024$ 比特，ACK包 $L_\\mathrm{ack} = 112$ 比特。\n- 物理层：\n    - 比特率：$R_b = 250 \\times 10^3$ bps。\n    - 载波频率：$f = 2.4 \\times 10^9$ Hz。\n    - 路径损耗指数：$n = 2.7$。\n    - 参考距离：$d_0 = 1$ 米。\n    - 天线增益：$G_t = 0$ dB, $G_r = 0$ dB。\n    - 噪声系数：$NF = 5$ dB。\n    - 基准发射功率：$P_{t,\\mathrm{base}} = 10$ 毫瓦。\n- 模型和定义：\n    - 路径损耗：对于 $d \\ge d_0$，$PL(d) = PL(d_0) + 10 n \\log_{10}(d/d_0)$，其中 $PL(d_0) = 20 \\log_{10}(4 \\pi d_0 / \\lambda)$。\n    - 热噪声：$N(\\mathrm{dBm}) = -174 + 10 \\log_{10}(B) + NF$，其中 $B \\approx R_b$。\n    - SNR 关系：$E_b/N_0 \\approx \\mathrm{SNR}$。\n    - 调制：BPSK，其中 $\\mathrm{BER} = Q(\\sqrt{2 E_b/N_0})$ 且 $Q(x) = \\frac{1}{2}\\mathrm{erfc}(x/\\sqrt{2})$。\n    - 数据包接收：$PRR = (1 - \\mathrm{BER})^L$。\n    - ETX 推导：需要。\n    - 链路能量成本推导：需要。\n    - 链路可用性：若 $PRR  10^{-3}$ 则不可用。\n    - 对称 PRR：假设 $df = dr$。\n- 测试用例：从基准功率降低 $0, 3, 8, 15$ 分贝。\n- 输出指标：绝对能量节省、能量节省分数、连通性损失、平均 PRR 比率、平均 ETX 比率。\n\n**第 2 步：使用提取的给定条件进行验证**\n该问题具有科学依据，使用了无线通信领域的标准模型（对数距离路径损耗、BPSK 误码率、热噪声）。所有参数都已指定，目标是定量的且定义清晰。该问题是适定的；使用固定的随机种子确保了单一、确定性的网络拓扑，从而导向唯一的解。语言是客观的。\n\n一个关键点是明确的指令“将 $PRR$ 视为对称且在两个方向上相同，即 $df = dr$”。物理上，数据包接收率取决于数据包长度（$L$ vs $L_\\mathrm{ack}$），因此对于给定的误码率，数据包和 ACK 包的 PRR 会有所不同。该指令强加了一个简化的抽象：使用为长度为 $L$ 的数据包计算的单个 $PRR$ 值来表征链路在两个方向上的所有用途，包括计算期望传输次数（$ETX$）。这是一个非物理的简化，但被明确规定为模型的一条规则。它不会使问题无效，而是定义了需要解决的特定理想化模型。根据这条规则，$ETX$ 和链路能量成本的推导是可处理的。\n\n**第 3 步：结论与行动**\n该问题是**有效的**。它提供了一套自洽、一致且可解的任务，基于既定的科学原理，尽管有一些明确说明的简化。\n\n### 基于原理的解决方案\n\n该解决方案通过从物理层到网络层对系统进行建模来开发。\n\n**1. 系统参数和节点部署**\n网络总共由 $N+1 = 13$ 个节点组成。我们将传感器节点表示为索引 $0, 1, \\dots, 11$，汇聚节点表示为索引 $12$。$N=12$ 个传感器的位置 $(x_i, y_i)$ 是在 $[0, S] \\times [0, S]$ 的正方形区域内伪随机生成的，其中 $S=200$ 米，使用指定的种子 $42$。汇聚节点固定在中心 $(100, 100)$。任意两个节点 $i$ 和 $j$ 之间的欧几里得距离 $d_{ij}$ 根据它们的坐标计算得出。\n\n**2. 物理层：链路质量计算**\n对于任意两个相距为 $d = d_{ij}$ 的节点 $i$ 和 $j$ 之间的链路，我们根据指定的发射功率 $P_t$ 计算数据包接收率 ($PRR$)。\n\n- **路径损耗 ($PL$)**：使用对数距离模型计算路径损耗（单位：分贝 dB）。波长为 $\\lambda = c/f$，其中 $c$ 是光速 ($299792458 \\text{ m/s}$)，$f=2.4 \\times 10^9 \\text{ Hz}$。\n在参考距离 $d_0=1$ 米处的参考路径损耗为：\n$$ PL(d_0) [\\mathrm{dB}] = 20 \\log_{10}\\left(\\frac{4 \\pi d_0}{\\lambda}\\right) $$\n对于任意距离 $d \\ge d_0$，路径损耗为：\n$$ PL(d) [\\mathrm{dB}] = PL(d_0) + 10 n \\log_{10}\\left(\\frac{d}{d_0}\\right) $$\n其中路径损耗指数为 $n=2.7$。为了处理模型未定义的距离 $d  d_0$，我们使用有效距离 $d_{\\mathrm{eff}} = \\max(d, d_0)$。\n\n- **接收功率 ($P_r$)**：发射功率 $P_t$ 首先从瓦特转换为 dBm ($10 \\log_{10}(P_t[\\mathrm{W}]/0.001)$)。接收功率（单位：dBm）为：\n$$ P_r [\\mathrm{dBm}] = P_t [\\mathrm{dBm}] + G_t + G_r - PL(d_{\\mathrm{eff}}) $$\n给定天线增益 $G_t = G_r = 0$ dB，这简化为 $P_r [\\mathrm{dBm}] = P_t [\\mathrm{dBm}] - PL(d_{\\mathrm{eff}})$。然后将接收功率转换回瓦特用于 SNR 计算。\n\n- **噪声功率 ($N_{pwr}$)**：热噪声功率（单位：dBm）由下式给出：\n$$ N_{pwr} [\\mathrm{dBm}] = -174 + 10 \\log_{10}(B) + NF $$\n接收机带宽 $B = R_b = 250 \\times 10^3$ Hz，噪声系数 $NF=5$ dB，计算出噪声功率并将其转换为瓦特。\n\n- **信噪比 ($E_b/N_0$) 和误码率 (BER)**：问题陈述假设 $E_b/N_0 \\approx \\mathrm{SNR}$。线性信噪比为 $\\mathrm{SNR} = P_r / N_{pwr}$。对于 BPSK 调制，误码率为：\n$$ \\mathrm{BER} = Q\\left(\\sqrt{2 \\frac{E_b}{N_0}}\\right) = \\frac{1}{2} \\mathrm{erfc}\\left(\\sqrt{\\frac{E_b}{N_0}}\\right) $$\n其中 $Q(x)$ 是标准高斯尾概率函数，$\\mathrm{erfc}$ 是互补误差函数。\n\n- **数据包接收率 ($PRR$)**：假设比特错误是独立的，成功接收一个长度为 $L=1024$ 比特的数据包的概率是：\n$$ PRR = (1 - \\mathrm{BER})^L $$\n\n**3. 链路层：ETX 和能量成本**\n- **期望传输次数 ($ETX$)**：一次传输成功的条件是：数据包被接收（事件 $D$）且随后的确认包也被接收（事件 $A$）。此联合事件的概率为 $P(D \\cap A) = P(D)P(A|D)$。假设事件独立，则为 $P(D)P(A) = df \\cdot dr$。问题规定使用单个 $PRR$ 值，因此 $df = dr = PRR$。直到第一次成功的尝试次数遵循几何分布。期望的数据传输次数是：\n$$ ETX = \\frac{1}{df \\cdot dr} = \\frac{1}{PRR^2} $$\n\n- **每链路能量成本 ($E_{\\mathrm{link}}$)**：问题要求推导一次成功跳跃的期望传输能量。此成本包括发送方的数据传输能量和接收方的 ACK 传输能量。\n    - 发送方的期望能量：发送方平均传输 $ETX$ 个数据包。每个数据包的能量为 $E_{\\mathrm{tx,data}} = P_t \\cdot T_{\\mathrm{data}} = P_t (L/R_b)$。因此，发送方能量为 $ETX \\cdot E_{\\mathrm{tx,data}}$。\n    - 接收方的期望能量：问题要求“每次成功的...投递所需的 ACK 传输期望次数”，对于成功概率为 $dr$ 的几何过程，这个值是 $1/dr$。这意味着一个简化的模型，其中总 ACK 能量基于确保最终的、成功的 ACK 得以通过。每个 ACK 的能量为 $E_{\\mathrm{tx,ack}} = P_t \\cdot T_{\\mathrm{ack}} = P_t (L_\\mathrm{ack}/R_b)$。接收方能量是 $(1/dr) \\cdot E_{\\mathrm{tx,ack}}$。\n    - 总链路能量成本：当 $dr = PRR$ 时，总期望能量为：\n    $$ E_{\\mathrm{link}} = ETX \\cdot E_{\\mathrm{tx,data}} + \\frac{1}{PRR} \\cdot E_{\\mathrm{tx,ack}} = \\frac{1}{PRR^2} \\left(P_t \\frac{L}{R_b}\\right) + \\frac{1}{PRR} \\left(P_t \\frac{L_\\mathrm{ack}}{R_b}\\right) $$\n\n**4. 网络层：图与路由**\n网络被建模为一个无向图 $G=(V, E)$，其中 $V$ 是 $N+1$ 个节点的集合。如果链路是可用的，即 $PRR_{ij} \\ge 10^{-3}$，则边 $(i,j)$ 存在于 $E$ 中。边的权重是链路能量成本 $w_{ij} = E_{\\mathrm{link},ij}$。不可用链路的权重为无穷大。目标是找到从每个传感器到汇聚节点的最小能量路径。这是一个在具有非负边权重的图上的单源最短路径问题，为此我们采用 Dijkstra 算法。算法从汇聚节点（节点 $12$）开始运行，以找到到所有其他节点的最小能量成本。\n\n**5. 性能指标计算**\n对于每个测试用例（降功率），我们与基准用例（0 dB 降低）进行比较。\n- **连通集 ($C$)**：$C_{\\mathrm{base}}$ 和 $C_{\\mathrm{reduced}}$ 分别是在基准和降功率场景下，到汇聚节点具有有限成本路径的传感器节点集合。\n- **连通性损失**：$\\mathrm{conn\\_loss} = (|C_{\\mathrm{base}}| - |C_{\\mathrm{reduced}}|) / |C_{\\mathrm{base}}|$。\n- **网络总能量和节省**：我们对在降功率设置下保持连通的节点集 $C_{\\mathrm{reduced}}$ 进行能量节省评估。\n    - $E_{\\mathrm{reduced}} = \\sum_{i \\in C_{\\mathrm{reduced}}} \\mathrm{cost}^{\\mathrm{reduced}}_i$，其中 $\\mathrm{cost}^{\\mathrm{reduced}}_i$ 是在降功率图中从节点 $i$ 到汇聚节点的最小路径成本。\n    - $E_{\\mathrm{base}} = \\sum_{i \\in C_{\\mathrm{reduced}}} \\mathrm{cost}^{\\mathrm{base}}_i$，其中 $\\mathrm{cost}^{\\mathrm{base}}_i$ 是在基准图中相同节点 $i$ 的最小路径成本。这确保了在同一组路由任务上进行公平比较。\n    - 绝对节省：$E_{\\mathrm{saved,J}} = E_{\\mathrm{base}} - E_{\\mathrm{reduced}}$。\n    - 节省分数：$E_{\\mathrm{saved,frac}} = E_{\\mathrm{saved,J}} / E_{\\mathrm{base}}$（如果 $E_{\\mathrm{base}}=0$ 则为 $0$）。\n- **平均比率**：这些是在基准和降功率图中都可用的链路集合 $L_{common}$ 上计算的。\n    - $\\mathrm{avg\\_PRR\\_ratio} = \\mathrm{mean} \\{ PRR_{\\mathrm{reduced}}(l) / PRR_{\\mathrm{base}}(l) \\mid l \\in L_{common} \\}$。\n    - $\\mathrm{avg\\_ETX\\_ratio} = \\mathrm{mean} \\{ ETX_{\\mathrm{reduced}}(l) / ETX_{\\mathrm{base}}(l) \\mid l \\in L_{common} \\}$。\n如果 $L_{common}$ 为空，这些比率为 $0$。\n\n以下代码实现了这整个过程，遍历指定的功率降低，并为每种情况计算五个指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.constants import c\nfrom scipy.sparse.csgraph import dijkstra\n\ndef solve():\n    \"\"\"\n    Solves the wireless sensor network problem by modeling the physical, link,\n    and network layers to evaluate energy and connectivity trade-offs.\n    \"\"\"\n\n    # 1. System Parameters\n    N = 12  # Number of sensors\n    S = 200.0  # meters\n    SEED = 42\n    L = 1024  # bits\n    L_ack = 112  # bits\n    R_b = 250e3  # bits per second\n    f = 2.4e9  # Hz\n    n_pl = 2.7\n    d0 = 1.0  # meters\n    G_t = 0.0  # dB\n    G_r = 0.0  # dB\n    NF = 5.0  # dB\n    P_T_BASE_W = 0.010  # 10mW in Watts\n\n    # Test suite: power reductions in dB\n    power_reductions_db = [0.0, 3.0, 8.0, 15.0]\n\n    # Derived constants\n    LAMBDA = c / f\n    T_data = L / R_b\n    T_ack = L_ack / R_b\n    \n    # Path loss at reference distance d0\n    pl_d0_db = 20 * np.log10(4 * np.pi * d0 / LAMBDA)\n    \n    # Noise power calculation\n    B = R_b\n    noise_power_dbm = -174 + 10 * np.log10(B) + NF\n    noise_power_w = 1e-3 * (10**(noise_power_dbm / 10))\n\n    # 2. Node Placement\n    rng = np.random.default_rng(SEED)\n    sensor_pos = rng.random((N, 2)) * S\n    sink_pos = np.array([[S / 2, S / 2]])\n    all_pos = np.vstack((sensor_pos, sink_pos))\n    \n    # Calculate all inter-node distances\n    dist_matrix = np.sqrt(np.sum((all_pos[:, np.newaxis, :] - all_pos[np.newaxis, :, :])**2, axis=-1))\n    np.fill_diagonal(dist_matrix, 0)\n\n    # Store results for all test cases\n    all_results = []\n    baseline_metrics = None\n\n    for reduction_db in power_reductions_db:\n        # 3. Core Physics and Link Calculation for the current power level\n        p_t_dbm = 10 * np.log10(P_T_BASE_W * 1000) - reduction_db\n        p_t_w = 1e-3 * (10**(p_t_dbm / 10))\n\n        # Vectorized calculations for all links\n        d_eff = np.maximum(dist_matrix, d0)\n        pl_db = pl_d0_db + 10 * n_pl * np.log10(d_eff / d0)\n        np.fill_diagonal(pl_db, -np.inf) # Avoid self-path loss\n\n        p_r_dbm = p_t_dbm + G_t + G_r - pl_db\n        p_r_w = 1e-3 * (10**(p_r_dbm / 10))\n\n        snr = p_r_w / noise_power_w\n        e_b_n0 = snr # As per problem statement\n        \n        # Clip to avoid math errors with very low SNR\n        e_b_n0_clipped = np.maximum(e_b_n0, 1e-20)\n\n        # BPSK BER\n        ber = 0.5 * erfc(np.sqrt(e_b_n0_clipped))\n        \n        # PRR, ETX, and Link Energy Cost\n        prr = (1 - ber)**L\n        \n        # Avoid division by zero for very small PRR\n        prr_clipped = np.maximum(prr, 1e-12)\n        etx = 1 / (prr_clipped**2)\n        \n        e_tx_data = p_t_w * T_data\n        e_tx_ack = p_t_w * T_ack\n        link_energy_cost = (etx * e_tx_data) + (1/prr_clipped) * e_tx_ack\n\n        # 4. Graph Construction and Routing\n        adjacency_matrix = link_energy_cost.copy()\n        adjacency_matrix[prr  1e-3] = np.inf\n        np.fill_diagonal(adjacency_matrix, 0)\n        \n        # Dijkstra from sink (node N) to all sensors\n        path_costs = dijkstra(adjacency_matrix, directed=False, indices=N)\n        \n        # Current case metrics\n        current_metrics = {\n            'prr': prr,\n            'etx': etx,\n            'path_costs': path_costs[:N],\n            'graph': adjacency_matrix != np.inf\n        }\n\n        if baseline_metrics is None:\n            baseline_metrics = current_metrics\n        \n        # 5. Performance Metrics Calculation\n        # Connectivity\n        c_base = np.where(baseline_metrics['path_costs'] != np.inf)[0]\n        c_reduced = np.where(current_metrics['path_costs'] != np.inf)[0]\n        \n        if len(c_base) > 0:\n            conn_loss = (len(c_base) - len(c_reduced)) / len(c_base)\n        else:\n            conn_loss = 0.0\n\n        # Energy Savings\n        # Compare over the set of nodes connected in the reduced power graph\n        connected_in_reduced = c_reduced\n        if len(connected_in_reduced) > 0:\n            e_reduced = np.sum(current_metrics['path_costs'][connected_in_reduced])\n            # For fair comparison, calculate baseline energy for the SAME set of nodes\n            e_base_for_saving = np.sum(baseline_metrics['path_costs'][connected_in_reduced])\n            e_saved_j = e_base_for_saving - e_reduced\n            e_saved_frac = e_saved_j / e_base_for_saving if e_base_for_saving > 0 else 0.0\n        else: # No nodes connected\n            e_saved_j = 0.0\n            e_saved_frac = 0.0\n\n        # Average Ratios\n        # Identify links usable in both scenarios (upper triangle to count once)\n        common_links_mask = np.triu(baseline_metrics['graph'], 1)  np.triu(current_metrics['graph'], 1)\n        \n        if np.any(common_links_mask):\n            prr_ratio = current_metrics['prr'][common_links_mask] / baseline_metrics['prr'][common_links_mask]\n            etx_ratio = current_metrics['etx'][common_links_mask] / baseline_metrics['etx'][common_links_mask]\n            avg_prr_ratio = np.mean(prr_ratio)\n            avg_etx_ratio = np.mean(etx_ratio)\n        else:\n            avg_prr_ratio = 0.0\n            avg_etx_ratio = 0.0\n\n        # Assemble results for this case\n        case_results = [\n            e_saved_j,\n            e_saved_frac,\n            conn_loss,\n            avg_prr_ratio,\n            avg_etx_ratio\n        ]\n        all_results.append(case_results)\n\n    # 6. Final Output Formatting\n    # Convert results to a string with the required format\n    def format_list(lst):\n        return f\"[{','.join(f'{x:.7f}' for x in lst)}]\"\n\n    print(f\"[{','.join(format_list(r) for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的实践练习将焦点从单跳效率转移到最大化整个网络的运行寿命，这是长期运行的赛博物理系统的一个关键目标。通过将问题构建为线性规划模型，您将确定最优的流量分配方案，以平衡网络中所有节点的能量消耗。这项练习  介绍了一种强大的全局资源管理优化技术，并展示了如何将“网络长寿”等高层目标转化为一个可解的数学模型。",
            "id": "4254451",
            "problem": "考虑一个在信息物理系统 (CPS) 背景下的无线传感器网络 (WSN)，该网络表示为一个有向图，其节点集为 $\\mathcal{N}$，有向边集为 $\\mathcal{E} \\subseteq \\mathcal{N} \\times \\mathcal{N}$。网络中存在一个唯一的汇聚节点 $s \\in \\mathcal{N}$。每个节点 $i \\in \\mathcal{N}$（$s$ 除外）以恒定速率 $d_i$ 生成数据，单位为比特/秒 (bit/s)，且 $d_s = 0$。每条有向边 $(i,j) \\in \\mathcal{E}$ 具有单位传输能耗成本 $c_{ij}$，单位为焦耳/比特 (J/bit)。每个节点 $i \\in \\mathcal{N}$ 具有剩余能量 $E_i$，单位为焦耳 (J)。所有流量都以汇聚节点 $s$ 为目的地，网络在稳态下运行，每条边 $(i,j) \\in \\mathcal{E}$ 上的流率为恒定的 $f_{ij} \\geq 0$，单位为比特/秒。\n\n基本原理：\n- 每个节点都满足流量守恒：在节点 $i$ 处，净流出速率（流出速率之和减去流入速率之和）对 $i \\neq s$ 等于数据生成速率 $d_i$，对 $i=s$ 等于 $-\\sum_{k \\neq s} d_k$。\n- 节点 $i$ 的能量消耗速率由 $p_i = \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij}$ 给出，单位为焦耳/秒 (J/s)。\n- 网络生命周期 $T$（单位为秒 (s)）是指在稳态运行下，第一个节点的剩余能量被耗尽所需的时间，即 $T = \\min_{i \\in \\mathcal{N}} \\frac{E_i}{p_i}$。\n\n任务：编写一个完整的、可运行的程序，该程序能为以下每个测试用例，计算在所有满足非负性和流量守恒条件的可行稳态流下，可实现的最大网络生命周期 $T$。解决方案必须实现一种数学上合理的方法，该方法体现了通过平衡各节点的边际消耗率来最大化 $T$ 的原则。\n\n假设：\n- 与传输能耗相比，接收能耗可忽略不计；在 $p_i$ 中只考虑传输能耗。\n- 所有生成的数据都必须被传送到汇聚节点 $s$。\n- 除了非负性之外，没有链路容量限制。\n\n单位：\n- 答案以秒 (s) 为单位，表示为十进制浮点数。\n\n测试套件：\n为以下四个测试用例提供结果。每个测试用例提供 $(\\mathcal{N}, s, \\mathcal{E}, \\{c_{ij}\\}, \\{E_i\\}, \\{d_i\\})$。\n\n- 测试用例 1（单路径聚合，结构上平衡）：\n    - 节点：$\\mathcal{N} = \\{1,2,3\\}$，汇聚节点 $s = 3$。\n    - 边：$\\mathcal{E} = \\{(1,2),(2,3)\\}$。\n    - 成本：$c_{12} = 5 \\times 10^{-6}$ $\\mathrm{J/bit}$，$c_{23} = 4 \\times 10^{-6}$ $\\mathrm{J/bit}$。\n    - 能量：$E_1 = 100$ $\\mathrm{J}$，$E_2 = 120$ $\\mathrm{J}$，$E_3 = 10000$ $\\mathrm{J}$。\n    - 数据速率：$d_1 = 1000$ $\\mathrm{bit/s}$，$d_2 = 500$ $\\mathrm{bit/s}$，$d_3 = 0$ $\\mathrm{bit/s}$。\n\n- 测试用例 2（可分源流量，非对称成本和异构能量）：\n    - 节点：$\\mathcal{N} = \\{1,2,3,4\\}$，汇聚节点 $s = 4$。\n    - 边：$\\mathcal{E} = \\{(1,2),(1,3),(2,4),(3,4)\\}$。\n    - 成本：$c_{12} = 6 \\times 10^{-6}$ $\\mathrm{J/bit}$，$c_{13} = 3 \\times 10^{-6}$ $\\mathrm{J/bit}$，$c_{24} = 5 \\times 10^{-6}$ $\\mathrm{J/bit}$，$c_{34} = 8 \\times 10^{-6}$ $\\mathrm{J/bit}$。\n    - 能量：$E_1 = 150$ $\\mathrm{J}$，$E_2 = 90$ $\\mathrm{J}$，$E_3 = 60$ $\\mathrm{J}$，$E_4 = 1000$ $\\mathrm{J}$。\n    - 数据速率：$d_1 = 2000$ $\\mathrm{bit/s}$，$d_2 = 0$ $\\mathrm{bit/s}$，$d_3 = 0$ $\\mathrm{bit/s}$，$d_4 = 0$ $\\mathrm{bit/s}$。\n\n- 测试用例 3（源节点的微小能量主导生命周期）：\n    - 节点：$\\mathcal{N} = \\{1,2\\}$，汇聚节点 $s = 2$。\n    - 边：$\\mathcal{E} = \\{(1,2)\\}$。\n    - 成本：$c_{12} = 1 \\times 10^{-5}$ $\\mathrm{J/bit}$。\n    - 能量：$E_1 = 1$ $\\mathrm{J}$，$E_2 = 1000$ $\\mathrm{J}$。\n    - 数据速率：$d_1 = 1000$ $\\mathrm{bit/s}$，$d_2 = 0$ $\\mathrm{bit/s}$。\n\n- 测试用例 4（多个源通过单个转发节点汇集）：\n    - 节点：$\\mathcal{N} = \\{1,2,3,4,5\\}$，汇聚节点 $s = 5$。\n    - 边：$\\mathcal{E} = \\{(1,4),(2,4),(3,4),(4,5)\\}$。\n    - 成本：$c_{14} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$，$c_{24} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$，$c_{34} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$，$c_{45} = 1 \\times 10^{-5}$ $\\mathrm{J/bit}$。\n    - 能量：$E_1 = 50$ $\\mathrm{J}$，$E_2 = 50$ $\\mathrm{J}$，$E_3 = 50$ $\\mathrm{J}$，$E_4 = 60$ $\\mathrm{J}$，$E_5 = 1000$ $\\mathrm{J}$。\n    - 数据速率：$d_1 = 500$ $\\mathrm{bit/s}$，$d_2 = 1200$ $\\mathrm{bit/s}$，$d_3 = 300$ $\\mathrm{bit/s}$，$d_4 = 0$ $\\mathrm{bit/s}$，$d_5 = 0$ $\\mathrm{bit/s}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的生命周期，格式为逗号分隔的列表，并用方括号括起来，每个生命周期以秒为单位，四舍五入到六位小数（例如，$\\texttt{[20000.000000,12750.000000,100.000000,3000.000000]}$）。",
            "solution": "经评估，该问题是 **有效的**。这是一个适定的优化问题，其基础是网络流守恒和能耗模型的基本原理，这些都是无线传感器网络 (WSN) 分析中的标准方法。该问题是自包含的，为每个测试用例提供了所有必要的数据和约束。目标定义清晰，其公式化可导出一个可解的数学结构，具体来说是一个线性规划问题，因此网络生命周期存在唯一的最优值。\n\n该问题旨在确定由稳态流率集合 $\\{f_{ij}\\}$ 定义的最优路由策略，以最大化网络生命周期 $T$。生命周期定义为第一个节点耗尽其能量的时间，数学上表示为：\n$$\nT = \\min_{i \\in \\mathcal{N}} \\frac{E_i}{p_i}\n$$\n其中 $E_i$ 是节点 $i$ 的初始能量，$p_i$ 是其能量消耗速率。消耗速率是由数据传输引起的：\n$$\np_i = \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij}\n$$\n在此，$c_{ij}$ 是在链路 $(i,j)$ 上每比特传输的能量成本，$f_{ij}$ 是流率。对于汇聚节点 $s$ 和任何没有出边的其他节点，$p_i = 0$，其生命周期 $E_i/p_i$ 被视为无限大，因此它们不会成为网络生命周期的制约因素。\n\n最大化 $T$ 是一个瓶颈优化问题。可以通过最小化生命周期的倒数 $\\gamma = 1/T$ 将其重构为一个更标准的形式。目标函数因此变为最小化 $\\gamma$。约束 $T \\geq 1/\\gamma$ 意味着对于每个节点 $i$：\n$$\n\\frac{E_i}{p_i} \\geq \\frac{1}{\\gamma} \\implies p_i \\leq E_i \\gamma\n$$\n这导出了一组关于流变量 $f_{ij}$ 和新变量 $\\gamma$ 的线性不等式约束：\n$$\n\\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij} - E_i \\gamma \\leq 0 \\quad \\forall i \\in \\mathcal{N} \\setminus \\{s\\}\n$$\n流 $\\{f_{ij}\\}$ 还必须满足每个非汇聚节点的流量守恒定律：对于每个 $i \\in \\mathcal{N} \\setminus \\{s\\}$，总流出量必须等于总流入量加上该节点生成的数据量。\n$$\n\\sum_{j:(i,j) \\in \\mathcal{E}} f_{ij} - \\sum_{k:(k,i) \\in \\mathcal{E}} f_{ki} = d_i \\quad \\forall i \\in \\mathcal{N} \\setminus \\{s\\}\n$$\n最后，流率必须为非负值，$f_{ij} \\geq 0$。\n\n综合这些元素，我们得到以下线性规划 (LP) 公式：\n\n**变量：**\n- $\\gamma$：最大归一化能量消耗率（生命周期 $T$ 的倒数）。\n- $f_{ij}$：每条有向边 $(i, j) \\in \\mathcal{E}$ 上的流率。\n\n**目标：**\n最小化 $\\gamma$。\n\n**约束条件：**\n1.  **生命周期约束：** 对于每个传输节点 $i \\in \\mathcal{N} \\setminus \\{s\\}$：\n    $$\n    \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij} - E_i \\gamma \\leq 0\n    $$\n2.  **流量守恒约束：** 对于每个节点 $i \\in \\mathcal{N} \\setminus \\{s\\}$：\n    $$\n    \\sum_{j:(i,j) \\in \\mathcal{E}} f_{ij} - \\sum_{k:(k,i) \\in \\mathcal{E}} f_{ki} = d_i\n    $$\n3.  **非负性约束：** 对于所有边 $(i,j) \\in \\mathcal{E}$：\n    $$\n    f_{ij} \\geq 0\n    $$\n    以及 $\\gamma \\geq 0$。\n\n这个 LP 问题可以使用标准优化求解器来解决。求解结果给出了 $\\gamma$ 的最小可能值，我们称之为 $\\gamma^*$。那么可实现的最大网络生命周期就是 $T_{max} = 1/\\gamma^*$。如果 $\\gamma^*=0$，则生命周期为无限大。该公式体现了平衡消耗率的原则，因为最优解通常会使一部分节点（瓶颈节点）的归一化消耗率 $p_i/E_i$ 达到最大值 $\\gamma^*$。\n\n算法解决方案涉及构建矩阵和向量，以求解器（如 `scipy.optimize.linprog`）所需的标准形式来表示此 LP。具体来说，我们将问题映射为以下形式：\n`minimize c @ x`\n`subject to A_ub @ x = b_ub`\n`A_eq @ x == b_eq`\n\n变量向量 `x` 通过拼接 $\\gamma$ 和所有流变量 $f_{ij}$ 构建。目标向量 `c` 为 $[1, 0, 0, ...]$。矩阵 `A_ub`、`A_eq` 以及向量 `b_ub`、`b_eq` 根据上面推导的生命周期和流量守恒约束进行填充。LP 问题求解后，结果 `res.fun` 会给出 $\\gamma^*$，最终答案则计算为 $1/\\gamma^*$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the WSN lifetime maximization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: single path aggregation, balanced by structure\n        {\n            \"nodes\": {1, 2, 3},\n            \"sink\": 3,\n            \"edges\": {(1, 2), (2, 3)},\n            \"costs\": {(1, 2): 5e-6, (2, 3): 4e-6},\n            \"energies\": {1: 100, 2: 120, 3: 10000},\n            \"rates\": {1: 1000, 2: 500, 3: 0},\n        },\n        # Test Case 2: splittable source traffic with asymmetric costs and heterogeneous energies\n        {\n            \"nodes\": {1, 2, 3, 4},\n            \"sink\": 4,\n            \"edges\": {(1, 2), (1, 3), (2, 4), (3, 4)},\n            \"costs\": {(1, 2): 6e-6, (1, 3): 3e-6, (2, 4): 5e-6, (3, 4): 8e-6},\n            \"energies\": {1: 150, 2: 90, 3: 60, 4: 1000},\n            \"rates\": {1: 2000, 2: 0, 3: 0, 4: 0},\n        },\n        # Test Case 3: tiny energy at source dominates lifetime\n        {\n            \"nodes\": {1, 2},\n            \"sink\": 2,\n            \"edges\": {(1, 2)},\n            \"costs\": {(1, 2): 1e-5},\n            \"energies\": {1: 1, 2: 1000},\n            \"rates\": {1: 1000, 2: 0},\n        },\n        # Test Case 4: multiple sources funnel through a single forwarding node\n        {\n            \"nodes\": {1, 2, 3, 4, 5},\n            \"sink\": 5,\n            \"edges\": {(1, 4), (2, 4), (3, 4), (4, 5)},\n            \"costs\": {(1, 4): 2e-6, (2, 4): 2e-6, (3, 4): 2e-6, (4, 5): 1e-5},\n            \"energies\": {1: 50, 2: 50, 3: 50, 4: 60, 5: 1000},\n            \"rates\": {1: 500, 2: 1200, 3: 300, 4: 0, 5: 0},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        lifetime = solve_case(case)\n        results.append(f\"{lifetime:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(case_data):\n    \"\"\"\n    Formulates and solves the LP for a single test case.\n\n    The LP is set up to minimize gamma = 1/T, where T is the network lifetime.\n    Variables are [gamma, f_1, f_2, ..., f_m], where f_i are flow variables.\n    \"\"\"\n    nodes = sorted(list(case_data[\"nodes\"]))\n    sink_node = case_data[\"sink\"]\n    edges = sorted(list(case_data[\"edges\"]))\n    costs = case_data[\"costs\"]\n    energies = case_data[\"energies\"]\n    rates = case_data[\"rates\"]\n\n    node_to_idx = {node: i for i, node in enumerate(nodes)}\n    non_sink_nodes = [n for n in nodes if n != sink_node]\n    \n    m = len(edges)\n    edge_to_idx = {edge: i for i, edge in enumerate(edges)}\n    \n    # LP variables are: [gamma, f_0, f_1, ... f_{m-1}]\n    num_vars = 1 + m\n    \n    # Objective function: minimize gamma\n    # c = [1, 0, 0, ...]\n    c = np.zeros(num_vars)\n    c[0] = 1\n\n    # Equality constraints (flow conservation)\n    # For each non-sink node i: sum(f_out) - sum(f_in) = d_i\n    num_eq_constraints = len(non_sink_nodes)\n    A_eq = np.zeros((num_eq_constraints, num_vars))\n    b_eq = np.zeros(num_eq_constraints)\n\n    for i, node in enumerate(non_sink_nodes):\n        b_eq[i] = rates.get(node, 0)\n        for edge_idx, edge in enumerate(edges):\n            u, v = edge\n            # Variable index for flow f_uv is 1 + edge_idx\n            var_idx = 1 + edge_idx\n            if u == node:\n                A_eq[i, var_idx] = 1  # Outgoing flow\n            if v == node:\n                A_eq[i, var_idx] = -1 # Incoming flow\n\n    # Inequality constraints (lifetime)\n    # For each transmitting non-sink node i: sum(c_ij * f_ij) - E_i * gamma = 0\n    transmitting_nodes = {u for u, v in edges if u != sink_node}\n    num_ub_constraints = len(transmitting_nodes)\n    A_ub = np.zeros((num_ub_constraints, num_vars))\n    b_ub = np.zeros(num_ub_constraints)\n    \n    for i, node in enumerate(sorted(list(transmitting_nodes))):\n        # Gamma coefficient\n        A_ub[i, 0] = -energies.get(node, 0)\n        \n        # Flow coefficients\n        for edge_idx, edge in enumerate(edges):\n            u, v = edge\n            if u == node:\n                var_idx = 1 + edge_idx\n                A_ub[i, var_idx] = costs.get(edge, 0)\n\n    # Bounds: gamma >= 0, f_ij >= 0\n    bounds = (0, None)\n\n    # Solve the linear program\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if not res.success:\n        raise RuntimeError(\"LP solver failed to find a solution.\")\n\n    # Optimal gamma is the minimum value of the objective function\n    gamma_star = res.fun\n    \n    # Handle case of infinite lifetime\n    if gamma_star = 1e-9: # Using a small tolerance for floating point\n        return float('inf')\n\n    # Lifetime is 1/gamma\n    max_lifetime = 1.0 / gamma_star\n    return max_lifetime\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}