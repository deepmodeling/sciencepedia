{
    "hands_on_practices": [
        {
            "introduction": "在网络通信中，应用数据在每一层都会被添加额外的头部或尾部信息，这个过程称为封装。这个练习将引导您详细计算一个典型的网络物理系统遥测流所产生的协议开销，这对于理解网络效率和进行容量规划至关重要。通过这个实践，您将深入体会分层模型在带来模块化优势的同时，也引入了不可忽视的性能成本 。",
            "id": "4209765",
            "problem": "一个信息物理生产系统将其工厂的状态遥测数据流式传输到一个监控数字孪生。遥测数据以用户数据报协议（UDP）数据报的形式周期性地发出，每 $2$ 毫秒发送一个 $256$ 字节的应用层载荷。该系统在局域网上使用基于以太网的互联网协议第 $4$ 版（IPv4），最大传输单元（MTU）为 $1500$ 字节。假设采用以太网版本 $2$ 帧格式，无虚拟局域网（VLAN）标签，无 IPv4 选项。在此环境下，使用以下经过充分验证的事实：\n- UDP 报头为 $8$ 字节。\n- IPv4 报头（无选项）为 $20$ 字节。\n- 以太网媒体访问控制（MAC）报头为 $14$ 字节，以太网帧检验序列（FCS）帧尾为 $4$ 字节。\n- 在物理层，以太网在每帧之前传输一个 $8$ 字节的前导码加起始帧分界符，并在每帧之后强制执行一个 $12$ 字节时间的帧间隙。\n\n从开放系统互连（OSI）分层定义和给定的报头大小出发，推导每个数据包在物理线路上的总非应用层开销，并用它来：\n1. 计算协议开销的小数形式 $f$，定义为 $f = \\dfrac{\\text{每包非应用层字节数}}{\\text{每包物理线路上总字节数}}$，其中“非应用层字节数”包括传输层、网络层、数据链路层的报头和报尾，以及物理层的前导码和帧间隙。\n2. 根据 $2$ 毫秒的周期性，计算传输到数字孪生的应用层载荷的有效吞吐量，单位为兆比特每秒（Mb/s）。\n\n以小数形式报告协议开销，以 Mb/s 为单位报告有效吞吐量。将两个量都四舍五入到四位有效数字。将吞吐量以 Mb/s 表示，将开销表示为无单位的小数。确认在给定的 MTU 下是否会发生分片，并将此判断纳入您的推导过程，不使用任何快捷公式。",
            "solution": "该问题具有科学依据，提法明确，并包含足够的信息以获得唯一解。我们开始进行推导。\n\n解决方案需要计算单个应用层载荷在物理介质上传输的数据总大小，然后用这个值来计算开销分数和有效吞吐量。我们遵循从应用层到物理层的数据封装过程，这与开放系统互连（OSI）模型一致。\n\n给定的参数如下：\n- 应用层载荷大小, $L_{app} = 256$ 字节。\n- 数据报之间的时间周期, $T = 2$ 毫秒 = $2 \\times 10^{-3}$ s。\n- 最大传输单元, $MTU = 1500$ 字节。\n- 用户数据报协议（UDP）报头大小, $H_{UDP} = 8$ 字节。\n- 互联网协议第 $4$ 版（IPv4）报头大小, $H_{IPv4} = 20$ 字节。\n- 以太网媒体访问控制（MAC）报头大小, $H_{Eth} = 14$ 字节。\n- 以太网帧检验序列（FCS）帧尾大小, $T_{Eth} = 4$ 字节。\n- 以太网前导码 + 起始帧分界符（SFD）大小, $P_{Eth} = 8$ 字节。\n- 以太网帧间隙（IFG）大小, $IFG = 12$ 字节时间。\n\n首先，我们必须确定是否会发生 IP 分片。$MTU$ 定义了数据链路层帧的载荷的最大大小。在这种情况下，它指的是可以封装在以太网帧内的 IP 数据包的最大大小。\n\n1.  在传输层（OSI 第 $4$ 层），应用层载荷被封装成一个 UDP 数据报。UDP 数据报的大小是其报头和应用层载荷之和。\n    $$L_{UDP\\_datagram} = H_{UDP} + L_{app} = 8 \\text{ bytes} + 256 \\text{ bytes} = 264 \\text{ bytes}$$\n\n2.  在网络层（OSI 第 $3$ 层），UDP 数据报成为 IPv4 数据包的载荷。IPv4 数据包的大小是其报头和其载荷（UDP 数据报）之和。\n    $$L_{IP\\_packet} = H_{IPv4} + L_{UDP\\_datagram} = 20 \\text{ bytes} + 264 \\text{ bytes} = 284 \\text{ bytes}$$\n\n3.  给定网络的 $MTU$ 为 $1500$ 字节。我们将 IP 数据包的总大小与 $MTU$ 进行比较：\n    $$L_{IP\\_packet} = 284 \\text{ bytes}  1500 \\text{ bytes} = MTU$$\n    由于 IP 数据包的大小小于 $MTU$，因此不需要分片。整个 IP 数据包将被封装在一个以太网帧中。\n\n现在，我们可以计算每个数据包在线路上实际传输的总字节数。这包括以太网帧本身和物理层的开销。\n\n4.  在数据链路层（OSI 第 $2$ 层），IP 数据包被封装在一个以太网帧中。该帧由报头、IP 数据包载荷和帧尾组成。\n    $$L_{Ethernet\\_frame} = H_{Eth} + L_{IP\\_packet} + T_{Eth} = 14 \\text{ bytes} + 284 \\text{ bytes} + 4 \\text{ bytes} = 302 \\text{ bytes}$$\n\n5.  在物理层（OSI 第 $1$ 层），会为信令和同步添加额外的字节。这些是带有 SFD 的前导码和帧间隙。问题要求计算“每包物理线路上总字节数”，这代表了传输一个数据包所消耗的总信道资源。\n    $$L_{total} = P_{Eth} + L_{Ethernet\\_frame} + IFG$$\n    $$L_{total} = 8 \\text{ bytes} + 302 \\text{ bytes} + 12 \\text{ byte-times} = 322 \\text{ bytes}$$\n    $IFG$ 以“字节时间”为单位给出，在此计算中，就信道占用而言，它等同于字节。\n\n在确定了物理线路上的总大小后，我们就可以求解所需的两个量。\n\n**1. 协议开销分数 ($f$)**\n\n协议开销分数 $f$ 定义为非应用层字节数与物理线路上总字节数的比率。\n非应用层字节数 $L_{non-app}$ 是总字节数减去原始应用层载荷。\n$$L_{non-app} = L_{total} - L_{app} = 322 \\text{ bytes} - 256 \\text{ bytes} = 66 \\text{ bytes}$$\n或者，我们可以将所有协议报头、帧尾和物理层开销的大小相加：\n$$L_{non-app} = H_{UDP} + H_{IPv4} + H_{Eth} + T_{Eth} + P_{Eth} + IFG$$\n$$L_{non-app} = 8 + 20 + 14 + 4 + 8 + 12 = 66 \\text{ bytes}$$\n那么分数 $f$ 是：\n$$f = \\frac{L_{non-app}}{L_{total}} = \\frac{66}{322} \\approx 0.2049689...$$\n四舍五入到四位有效数字，我们得到：\n$$f \\approx 0.2050$$\n\n**2. 有效应用层载荷吞吐量**\n\n有效吞吐量只关心传输到数字孪生的应用层载荷数据。每 $T = 2$ 毫秒传输一个大小为 $L_{app} = 256$ 字节的载荷。\n\n首先，我们将载荷大小从字节转换为比特：\n$$L_{app, bits} = L_{app} \\times 8 \\frac{\\text{bits}}{\\text{byte}} = 256 \\text{ bytes} \\times 8 \\frac{\\text{bits}}{\\text{byte}} = 2048 \\text{ bits}$$\n有效吞吐量 $R_{eff}$ 是单位时间内传输的应用层比特数。\n$$R_{eff} = \\frac{L_{app, bits}}{T} = \\frac{2048 \\text{ bits}}{2 \\times 10^{-3} \\text{ s}} = 1\\,024\\,000 \\text{ bits/s}$$\n问题要求答案以兆比特每秒（Mb/s）为单位，其中 $1$ Mb/s = $10^6$ 比特/秒。\n$$R_{eff} = \\frac{1\\,024\\,000 \\text{ bits/s}}{10^6 \\text{ bits/Mb}} = 1.024 \\text{ Mb/s}$$\n该结果已经满足四位有效数字的要求。\n\n两个最终结果是协议开销分数 $f$ 和有效吞吐量 $R_{eff}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.2050  1.024\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "数据包的成功传输不仅依赖于其正确的封装，还取决于网络中路由器做出的精确转发决策。本练习将带您深入探讨 IP 路由的核心机制：无类别域间路由 (CIDR) 和最长前缀匹配 (LPM) 规则。您将在一个模拟的工业场景中，像网络数字孪生一样，应用这些原理来决定数据包的命运，并探索路由聚合如何简化网络管理 。",
            "id": "4209772",
            "problem": "在一个信息物理生产工厂中，一个汇聚路由器互连了三个运营技术子网和两个外部网络段。该工厂的数字孪生在网络层复制路由行为，以评估在IPv4（Internet Protocol version 4）协议下的故障转移策略。仅使用以下基本原理：将无类域间路由（CIDR）前缀定义为$32$位IPv4地址上的位掩码，通过前缀成员关系定义网络可达性，以及最长前缀匹配（LPM）规则，即根据匹配的具有最长前缀长度的路由进行转发。\n\n三个工厂子网本地连接到三个不同的路由器接口上：\n- 子网 $S_A$：$\\text{10.0.16.0}/21$，位于接口 $I_A$ 上。\n- 子网 $S_B$：$\\text{10.0.24.0}/21$，位于接口 $I_B$ 上。\n- 子网 $S_C$：$\\text{10.0.32.0}/20$，位于接口 $I_C$ 上。\n\n该路由器还安装了以下路由和接口：\n- 隔离区（DMZ）：$\\text{172.20.0.0}/16$，位于接口 $I_{\\text{DMZ}}$ 上。\n- 朝向核心网的工厂汇总路由：$\\text{10.0.0.0}/8$，位于接口 $I_{\\text{Core}}$ 上。\n- 到广域网（WAN）的默认路由：$\\text{0.0.0.0}/0$，位于接口 $I_{\\text{WAN}}$ 上。\n\n任务1（为导出而进行的聚合）：仅使用CIDR原理和按位前缀对齐，确定可以由 $S_A$、$S_B$ 和 $S_C$ 的并集形成的、聚合后的CIDR前缀的最小精确覆盖集，且该集合不包含这三个子网之外的任何地址。您对此任务的回答应从逻辑上论证 $S_A$、$S_B$ 和 $S_C$ 是否以及如何能够聚合成超网，同时保持精确覆盖。\n\n任务2（通过LPM进行转发）：考虑以下需要由路由器的转发表（FIB）查找的目标地址：\n- $d_1 = \\text{10.0.17.5}$，\n- $d_2 = \\text{10.0.30.1}$，\n- $d_3 = \\text{10.0.200.1}$，\n- $d_4 = \\text{172.20.10.10}$，\n- $d_5 = \\text{10.0.36.9}$，\n- $d_6 = \\text{8.8.8.8}$。\n对于每个 $d_k$，根据上面列出的所有已安装路由，确定路由器在LPM规则下选择的出接口。\n\n最终编码（单个数值答案）：通过以下定义的函数 $g$ 将为每个 $d_k$ 选择的接口映射到一个代码：\n$$\ng(I_A)=2,\\quad g(I_B)=3,\\quad g(I_C)=5,\\quad g(I_{\\text{DMZ}})=7,\\quad g(I_{\\text{Core}})=11,\\quad g(I_{\\text{WAN}})=13.\n$$\n计算单个标量\n$$\nK \\;=\\; \\sum_{k=1}^{6} k \\cdot g\\big(\\text{interface selected for } d_k\\big).\n$$\n以十进制整数形式报告 $K$，不带单位。不允许也不需要四舍五入。最终答案必须是这个单一整数。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、问题定义明确的且客观的。它基于计算机网络的既定原则，特别是IPv4寻址、无类域间路由（CIDR）和最长前缀匹配（LPM）转发规则。所提供的数据是完整的、一致的，并允许得出唯一的、可验证的解。\n\n解答分为三个部分：首先，分析子网聚合（任务1）；其次，确定给定目标地址的转发路径（任务2）；第三，计算最终的标量值 $K$。\n\n### 任务1：CIDR前缀聚合\n\n目标是找到一个CIDR前缀的最小集合，该集合能够精确覆盖子网 $S_A$、$S_B$ 和 $S_C$ 的并集，而不包含任何无关的地址。这些子网是：\n- $S_A$：$\\text{10.0.16.0}/21$\n- $S_B$：$\\text{10.0.24.0}/21$\n- $S_C$：$\\text{10.0.32.0}/20$\n\n为了分析聚合的可能性，我们必须检查网络前缀的二进制表示，重点关注地址不同的第三个八位字节。一个IPv4地址是一个$32$位的数字。前缀长度为$/n$意味着该子网中所有地址的前$n$位是固定的。\n\n1.  **分析 $S_A$ 和 $S_B$：**\n    - 子网 $S_A = \\text{10.0.16.0}/21$。前缀长度为$21$意味着前$21$位是固定的。前两个八位字节（$16$位）是 `00001010.00000000`。网络地址的第三个八位字节是 $16 = 00010000_2$。这个八位字节的前 $21-16=5$ 位是前缀的一部分：`00010`。$S_A$ 的地址范围是从 $\\text{10.0.16.0}$ 到 $\\text{10.0.23.255}$。\n    - 子网 $S_B = \\text{10.0.24.0}/21$。网络地址的第三个八位字节是 $24 = 00011000_2$。这个八位字节的前$5$位是 `00011`。$S_B$ 的地址范围是从 $\\text{10.0.24.0}$ 到 $\\text{10.0.31.255}$。\n\n    $S_A$ 和 $S_B$ 直到第$21$位的二进制前缀是：\n    - $S_A$：`00001010.00000000.00010`\n    - $S_B$：`00001010.00000000.00011`\n\n    前$20$位是相同的（`00001010.00000000.0001`）。第$21$位对于 $S_A$ 是 $0$，对于 $S_B$ 是 $1$。这是两个相邻的 $/21$ 块（或称“伙伴块”）可以聚合成一个单独的 $/20$ 块的条件。产生的聚合前缀是通过取共同的$20$位前缀形成的，这对应于网络地址 $\\text{10.0.16.0}$。\n    聚合后的子网，我们称之为 $S_{AB}$，是 $\\text{10.0.16.0}/20$。这个块覆盖了从 $\\text{10.0.16.0}$ 到 $\\text{10.0.31.255}$ 的IP地址范围，这正是 $S_A$ 和 $S_B$ 地址范围的并集。\n\n2.  **分析 $S_{AB}$ 和 $S_C$：**\n    - 我们现在有两个块：聚合块 $S_{AB} = \\text{10.0.16.0}/20$ 和原始块 $S_C = \\text{10.0.32.0}/20$。\n    - $S_C$ 的地址范围是从 $\\text{10.0.32.0}$ 到 $\\text{10.0.47.255}$。\n    - 需要覆盖的总地址空间是 $S_{AB}$ 和 $S_C$ 的并集，这对应于从 $\\text{10.0.16.0}$ 到 $\\text{10.0.47.255}$ 的连续范围。\n\n    为了确定这两个 $/20$ 块是否可以进一步聚合成一个单独的块，我们检查它们的二进制前缀。\n    - $S_{AB}$ 网络地址：$\\text{10.0.16.0} \\rightarrow 00001010.00000000.00010000.00000000$\n    - $S_C$ 网络地址：$\\text{10.0.32.0} \\rightarrow 00001010.00000000.00100000.00000000$\n\n    共同前缀是 `00001010.00000000.00...`，长度为$18$位。单个聚合块必须是一个 $/18$ 前缀：$\\text{10.0.0.0}/18$。然而，这个前缀覆盖的范围是 $\\text{10.0.0.0}$ 到 $\\text{10.0.63.255}$，这比所需范围大得多，因此不是一个精确的覆盖。\n\n    另外，一个CIDR块的大小必须是$2$的幂，并且在该大小的边界上对齐。总范围 $[\\text{10.0.16.0}, \\text{10.0.47.255}]$ 包含 $2 \\times 2^{32-20} = 2 \\times 2^{12} = 2^{13}$ 个地址，这对应于一个 $/19$ 前缀的大小。然而，一个 $/19$ 块的起始地址的最后$13$位必须为零。起始地址 $\\text{10.0.16.0}$ 的二进制表示为 `00001010.00000000.00010000.00000000`。最后$13$位是 `10000.00000000`，它们不全为零。因此，这个范围不能用单个CIDR前缀表示。\n\n    精确覆盖 $S_A$、$S_B$ 和 $S_C$ 并集的最小聚合前缀集是 $\\{\\text{10.0.16.0}/20, \\text{10.0.32.0}/20\\}$。\n\n### 任务2：通过最长前缀匹配（LPM）进行转发\n\n路由器的转发表（FIB）包含以下路由：\n1.  $\\text{10.0.16.0}/21 \\rightarrow I_A$ （前缀长度 $L=21$）\n2.  $\\text{10.0.24.0}/21 \\rightarrow I_B$ （前缀长度 $L=21$）\n3.  $\\text{10.0.32.0}/20 \\rightarrow I_C$ （前缀长度 $L=20$）\n4.  $\\text{172.20.0.0}/16 \\rightarrow I_{\\text{DMZ}}$ （前缀长度 $L=16$）\n5.  $\\text{10.0.0.0}/8 \\rightarrow I_{\\text{Core}}$ （前缀长度 $L=8$）\n6.  $\\text{0.0.0.0}/0 \\rightarrow I_{\\text{WAN}}$ （前缀长度 $L=0$）\n\n对于每个目标地址 $d_k$，我们在FIB中找到所有匹配的前缀，并选择前缀长度（$L$）最大的那个。\n\n-   **对于 $d_1 = \\text{10.0.17.5}$**：\n    - 匹配 $\\text{10.0.16.0}/21$ （范围 $\\text{10.0.16.0} - \\text{10.0.23.255}$），$L=21$。\n    - 匹配 $\\text{10.0.0.0}/8$ （范围 $\\text{10.0.0.0} - \\text{10.255.255.255}$），$L=8$。\n    - 匹配 $\\text{0.0.0.0}/0$ （所有地址），$L=0$。\n    - 最长匹配是 $/21$。接口是 $I_A$。\n\n-   **对于 $d_2 = \\text{10.0.30.1}$**：\n    - 匹配 $\\text{10.0.24.0}/21$ （范围 $\\text{10.0.24.0} - \\text{10.0.31.255}$），$L=21$。\n    - 匹配 $\\text{10.0.0.0}/8$，$L=8$。\n    - 匹配 $\\text{0.0.0.0}/0$，$L=0$。\n    - 最长匹配是 $/21$。接口是 $I_B$。\n\n-   **对于 $d_3 = \\text{10.0.200.1}$**：\n    - 不匹配任何 $/21$ 或 $/20$ 前缀。\n    - 匹配 $\\text{10.0.0.0}/8$，$L=8$。\n    - 匹配 $\\text{0.0.0.0}/0$，$L=0$。\n    - 最长匹配是 $/8$。接口是 $I_{\\text{Core}}$。\n\n-   **对于 $d_4 = \\text{172.20.10.10}$**：\n    - 匹配 $\\text{172.20.0.0}/16$ （范围 $\\text{172.20.0.0} - \\text{172.20.255.255}$），$L=16$。\n    - 匹配 $\\text{0.0.0.0}/0$，$L=0$。\n    - 最长匹配是 $/16$。接口是 $I_{\\text{DMZ}}$。\n\n-   **对于 $d_5 = \\text{10.0.36.9}$**：\n    - 匹配 $\\text{10.0.32.0}/20$ （范围 $\\text{10.0.32.0} - \\text{10.0.47.255}$），$L=20$。\n    - 匹配 $\\text{10.0.0.0}/8$，$L=8$。\n    - 匹配 $\\text{0.0.0.0}/0$，$L=0$。\n    - 最长匹配是 $/20$。接口是 $I_C$。\n\n-   **对于 $d_6 = \\text{8.8.8.8}$**：\n    - 除了默认路由外，不匹配任何前缀。\n    - 匹配 $\\text{0.0.0.0}/0$，$L=0$。\n    - 最长匹配（也是唯一匹配）是 $/0$。接口是 $I_{\\text{WAN}}$。\n\n转发决策总结：\n- $d_1 \\rightarrow I_A$\n- $d_2 \\rightarrow I_B$\n- $d_3 \\rightarrow I_{\\text{Core}}$\n- $d_4 \\rightarrow I_{\\text{DMZ}}$\n- $d_5 \\rightarrow I_C$\n- $d_6 \\rightarrow I_{\\text{WAN}}$\n\n### 最终标量计算\n\n从接口到代码的映射由函数 $g$ 给出：\n$g(I_A)=2$, $g(I_B)=3$, $g(I_C)=5$, $g(I_{\\text{DMZ}})=7$, $g(I_{\\text{Core}})=11$, $g(I_{\\text{WAN}})=13$。\n\n我们使用以下公式计算标量 $K$：\n$$\nK = \\sum_{k=1}^{6} k \\cdot g\\big(\\text{interface selected for } d_k\\big)\n$$\n\n代入任务2中的值：\n$$\nK = (1 \\cdot g(I_A)) + (2 \\cdot g(I_B)) + (3 \\cdot g(I_{\\text{Core}})) + (4 \\cdot g(I_{\\text{DMZ}})) + (5 \\cdot g(I_C)) + (6 \\cdot g(I_{\\text{WAN}}))\n$$\n$$\nK = (1 \\cdot 2) + (2 \\cdot 3) + (3 \\cdot 11) + (4 \\cdot 7) + (5 \\cdot 5) + (6 \\cdot 13)\n$$\n$$\nK = 2 + 6 + 33 + 28 + 25 + 78\n$$\n$$\nK = 8 + 33 + 28 + 25 + 78\n$$\n$$\nK = 41 + 28 + 25 + 78\n$$\n$$\nK = 69 + 25 + 78\n$$\n$$\nK = 94 + 78\n$$\n$$\nK = 172\n$$\n\n最终的整数结果是 $172$。",
            "answer": "$$\\boxed{172}$$"
        },
        {
            "introduction": "传统的严格分层网络架构虽然提供了出色的模块化和互操作性，但有时难以满足网络物理系统苛刻的实时性要求。这个练习聚焦于一种更先进的设计理念——跨层设计，并以时间敏感网络 (TSN) 为例，展示其如何通过打破层间壁垒来优化性能。您将通过量化计算，亲身对比严格分层设计与跨层优化设计在端到端延迟上的巨大差异，从而理解架构选择对系统性能的决定性影响 。",
            "id": "4209727",
            "problem": "一个信息物理生产单元由一个数字孪生（DT）服务进行镜像，该服务发出一个周期性的状态更新流，其端到端截止时间为 $D=10$ ms，源释放抖动上限为 $J=2$ ms。DT数据包穿过两个配置为支持时间敏感网络（TSN）的以太网交换机，特别是时间感知整形器（TAS），它为更新流量类别提供了确定性的周期性传输机会。每个交换机重复一个持续时间为 $T$ 的周期，在此周期内，更新类别的门在一个宽度为 $w$ 的窗口内打开，在其他时间关闭。这两个交换机具有独立配置的门控调度（周期 $T$ 和窗口宽度 $w$ 相同，但相位偏移任意）。两跳的链路速率均为 $R=100$ Mbps，载荷长度为 $L=800$ 字节，每跳的传播延迟为 $0.5$ ms。\n\n考虑两种设计：\n- 严格分层设计：应用层、传输层和链路/MAC层各自在其层独立进行调度，不共享时间意图。数据包在第一跳的门下一次打开时立即从第一跳的TAS发出；它们到达第二跳的时间与第二跳的TAS窗口不协调。\n- 带有传输调度提示的跨层设计：应用程序将截止时间和时间意图向下层传递，以便选择第一跳的传输时间，如果可行，使其在第二跳的TAS打开窗口内到达，从而避免第二跳的门控等待。\n\n从确定性服务的第一性原理出发，将端到端延迟建模为序列化、传播、处理和排队组件的总和，并推断每跳周期性TAS服务引入的最大排队延迟。使用以下基本事实：\n- 端到端延迟是从数据包释放到其到达目的地的时间。\n- 对于一个仅在长度为 $T$ 的周期内、宽度为 $w$ 的周期性打开窗口中提供服务的服务器，到达事件所经历的排队延迟是到下一个打开窗口的时间；推导在一个周期内所有可能到达相位下该延迟的最大值。\n- 在跨层设计中，假设当 $J \\leq w$ 且序列化和一跳传播时间之和不大于第二跳窗口宽度时，端到端对齐是可行的。使用这些条件来论證第二跳的门控等待是否可以被消除。\n\n设两跳的TAS参数均为 $T=5$ ms 和 $w=2$ ms。假设每个设备的处理时间与TAS引起的等待相比可以忽略不计。在这些假设下，量化延迟改善，其定义为严格分层设计与带有调度提示的跨层设计之间的最坏情况端到端延迟之差。以ms为单位表示最终答案，并四舍五入到四位有效数字。",
            "solution": "首先验证问题具有科学依据、定义明确、客观且完整。所有必要的参数都已提供，并且该场景是用于实时网络（特别是时间敏感网络 TSN）分析的一个标准（尽管简化了）模型。所涉及的原理（序列化、传播、排队延迟）是网络性能分析的基础。因此，该问题被认为是有效的，可以制定解决方案。\n\n问题的核心是在两种不同的网络架构下（严格分层设计和跨层优化设计），计算并比较数据流的最坏情况端到端延迟。\n\n首先，我们根据问题描述定义和量化延迟的基本组成部分。总的端到端延迟是序列化延迟、传播延迟和排队延迟的总和。处理时间被说明为可以忽略不计。\n\n数据包载荷长度为 $L=800$ 字节。为了简化分析，我们假设这代表整个第2层帧的大小，因为TAS在MAC层（第2层）运行。以比特为单位的大小是 $S = L \\times 8 = 800 \\times 8 = 6400$ 比特。\n链路速率为 $R = 100$ Mbps，即每秒 $100 \\times 10^6$ 比特。\n序列化延迟 $\\tau_{ser}$ 是将数据包传输到链路上的时间：\n$$ \\tau_{ser} = \\frac{S}{R} = \\frac{6400 \\text{ bits}}{100 \\times 10^6 \\text{ bits/s}} = 64 \\times 10^{-6} \\text{ s} = 0.064 \\text{ ms} $$\n\n每跳的传播延迟 $\\tau_{prop}$ 为 $0.5$ ms。\n\n路径穿过两个以太网交换机，我们将其表示为SW1和SW2。此路径的标准模型是 源 $\\rightarrow$ SW1 $\\rightarrow$ SW2 $\\rightarrow$ 目的地。该路径涉及应用TSN整形的两跳：SW1和SW2的出口链路。总延迟是这两跳上的延迟之和，从数据包从源释放到到达目的地。我们将端到端延迟建模为在两跳中每一跳产生的延迟之和。一跳的延迟包括在交换机处的排队、在交换机出口端口的序列化以及在链路上的传播。\n\n排队延迟是由时间感知整形器（TAS）引起的。按照要求，我们从第一性原理推导最大排队延迟。特定流量类别的TAS门在一个周期为 $T$ 的重复周期内打开，持续时间为 $w$。到达交换机的数据包只能在这个门打开的间隔内传输。排队延迟的最坏情况发生在数据包在门刚关闭后到达时。设门在一个周期的区间 $[t_0, t_0+w]$ 内打开。如果一个数据包在 $t_0+w$ 之后的一个瞬间 $\\epsilon$ 到达，它必须等待下一个周期的门打开。下一个打开的间隔从时间 $t_0+T$ 开始。等待时间为 $(t_0+T) - (t_0+w+\\epsilon) = T-w-\\epsilon$。在极限情况下，当 $\\epsilon \\to 0$ 时，最大排队延迟 $d_{Q,max}$ 为：\n$$ d_{Q,max} = T - w $$\n给定 $T=5$ ms 和 $w=2$ ms，单跳的最大排队延迟为：\n$$ d_{Q,max} = 5 \\text{ ms} - 2 \\text{ ms} = 3 \\text{ ms} $$\n\n现在，我们分析两种设计的最坏情况端到端延迟。端到端延迟 $W$ 定义为从数据包释放到其到达目的地的时间。我们将其建模为两跳延迟之和：$W = (\\text{第一跳延迟}) + (\\text{第二跳延迟})$。我们假设路径是源 $\\rightarrow$ SW1 $\\rightarrow$ SW2，目的地是SW2的出口。延迟是从数据包在SW1的入口队列可用（考虑释放抖动后）到其到达SW2的出口端口的时间。对于一个 S$\\rightarrow$S1$\\rightarrow$S2$\\rightarrow$D 路径，一个更全面的模型是 $W = d_{Q1} + \\tau_{ser} + \\tau_{prop} + d_{Q2} + \\tau_{ser} + \\tau_{prop}$。这表示从在SW1队列可用到最终到达目的地的时间。\n\n情况1：严格分层设计\n在这种设计中，层与节点之间没有协调。来自源的数据包释放存在 $J=2$ ms 的抖动。这种抖动，加上SW1和SW2上TAS调度的独立和任意相位偏移，意味着数据包到达每个交换机队列的时间与该交换机的门控调度不协调。为了计算最坏情况的端到端延迟 $W_{SL}$，我们必须假设在每个交换机都发生最坏情况的排队延迟。\n$$ W_{SL} = d_{Q1,max} + \\tau_{ser} + \\tau_{prop} + d_{Q2,max} + \\tau_{ser} + \\tau_{prop} $$\n$$ W_{SL} = 2 \\cdot d_{Q,max} + 2 \\cdot \\tau_{ser} + 2 \\cdot \\tau_{prop} $$\n$$ W_{SL} = 2(T-w) + 2\\tau_{ser} + 2\\tau_{prop} $$\n\n情况2：带有传输调度提示的跨层设计\n在这种设计中，应用层向下层提供时间信息，以智能地调度在SW1的传输。目标是控制从SW1出发的时间，使数据包在SW2的门打开窗口期间到达，从而消除第二跳的排队延迟 $d_{Q2}$。\n问题为此提供了两个可行性条件：\n1. $J \\leq w$\n2. $\\tau_{ser} + \\tau_{prop} \\leq w$\n\n让我们用给定的参数验证这些条件：\n1. $J=2$ ms, $w=2$ ms。条件 $2 \\leq 2$ 满足。\n2. $\\tau_{ser}=0.064$ ms, $\\tau_{prop}=0.5$ ms。条件 $0.064 + 0.5 \\leq 2$，即 $0.564 \\leq 2$，也满足。\n由于两个可行性条件都满足，我们可以假设跨层调度是有效的，并且“第二跳的门控等待可以被消除”。这意味着在SW2的最坏情况排队延迟为零：$d_{Q2,max} = 0$。\n然而，数据包到达第一个交换机SW1的时间仍然受到源释放抖动的影响，并且与SW1的门控调度不协调。因此，我们仍必须考虑第一跳的最坏情况排队延迟。\n跨层设计的最坏情况端到端延迟 $W_{CL}$ 为：\n$$ W_{CL} = d_{Q1,max} + \\tau_{ser} + \\tau_{prop} + d_{Q2,max} + \\tau_{ser} + \\tau_{prop} $$\n$$ W_{CL} = (T-w) + 2\\tau_{ser} + 2\\tau_{prop} $$\n\n延迟改善\n延迟改善 $\\Delta W$ 是两种设计之间最坏情况延迟的差异。\n$$ \\Delta W = W_{SL} - W_{CL} $$\n$$ \\Delta W = (2(T-w) + 2\\tau_{ser} + 2\\tau_{prop}) - ((T-w) + 2\\tau_{ser} + 2\\tau_{prop}) $$\n$$ \\Delta W = (T-w) $$\n\n改善量正好是一跳的最大排队延迟，该延迟通过跨层协调在第二个交换机处被消除。\n\n最后，我们代入数值：\n$$ \\Delta W = T - w = 5 \\text{ ms} - 2 \\text{ ms} = 3 \\text{ ms} $$\n问题要求答案四舍五入到四位有效数字。由于结果是整数，我们将其表示为 $3.000$。\n\n为了完整起见，我们计算完整的延迟：\n$W_{SL} = 2(3 \\text{ ms}) + 2(0.064 \\text{ ms}) + 2(0.5 \\text{ ms}) = 6 + 0.128 + 1.0 = 7.128$ ms。\n$W_{CL} = 1(3 \\text{ ms}) + 2(0.064 \\text{ ms}) + 2(0.5 \\text{ ms}) = 3 + 0.128 + 1.0 = 4.128$ ms。\n$\\Delta W = 7.128 \\text{ ms} - 4.128 \\text{ ms} = 3.000$ ms。\n结果得到确认。",
            "answer": "$$\\boxed{3.000}$$"
        }
    ]
}