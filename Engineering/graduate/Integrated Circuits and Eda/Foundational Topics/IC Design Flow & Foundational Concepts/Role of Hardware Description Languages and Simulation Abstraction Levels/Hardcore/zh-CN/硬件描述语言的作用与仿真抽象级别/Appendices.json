{
    "hands_on_practices": [
        {
            "introduction": "现代硬件设计通常始于高抽象层次的行为模型，例如使用 `fork/join` 这样的并发结构来描述算法。这些模型虽然直观，但往往无法直接综合成物理电路。本练习旨在训练一项核心技能：将这种高层次的行为描述重构为资源受限、时钟驱动的寄存器传输级（RTL）设计。通过将一个并发任务模型转化为一个显式的有限状态机（FSM）控制器，您将亲身体验从行为规范到具体硬件实现的关键转换过程，深刻理解不同抽象层次之间的联系与权衡。",
            "id": "4294393",
            "problem": "给定一个硬件描述语言（HDL）中关于一个并发操作的高层行为描述，该操作使用一个动态的任务延迟数组和一个 fork/join_any 结构来同时启动任务，并在任何一个任务完成时立即结束。其目的是将此行为描述重构为一个等效的、可综合的寄存器传输级（RTL）实现，该实现使用显式的有限状态机控制以及有界的静态资源，并通过周期级别的仿真来验证等效性。\n\n将使用的基本定义：\n- 硬件描述语言（HDL）是一种用于描述同步数字系统的形式语言，其中行为结构表示离散时间中的并发性和时间演化。\n- 寄存器传输级（RTL）是一种抽象，其中寄存器之间的数据流由时钟控制逻辑驱动；可综合的RTL要求固定的资源边界和静态的数据大小。\n- 电子设计自动化（EDA）是用于跨抽象级别规范、仿真和综合数字系统的工具支持过程。\n- 离散事件仿真语义：在时间 $t=0$ 时独立启动的、具有确定性延迟 $\\{L_i\\}$ 的任务在绝对时间 $t_i = L_i$ 完成；一个 fork/join\\_any 在 $t^\\star = \\min_i L_i$ 完成，返回最早完成任务的索引 $i^\\star$。如果多个任务以最小延迟并列，则选择最小的索引。\n\n需要形式化的行为模型：\n- 动态数组包含 $N$ 个任务延迟 $\\{L_0,L_1,\\dots,L_{N-1}\\}$（单位为周期）。\n- 一个 fork/join\\_any 语义：所有 $N$ 个任务在 $t=0$ 时并发启动；完成时间为 $t^\\star = \\min_{0\\le i  N} L_i$，选定的索引为 $i^\\star = \\arg\\min_{0\\le i  N} L_i$，平局时优先选择最小的索引。\n- 对于边界情况 $N=0$，定义结果为 $i^\\star=-1$ 和 $t^\\star=0$ 周期，表示“无任务”。\n\n可综合RTL重构约束：\n- 固定的最大容量 $N_{\\max}$ 限制了动态数组；实际任务数量 $N$ 满足 $0\\le N\\le N_{\\max}$，未使用的槽位通过掩码停用。\n- 有界的并行资源：最多存在 $P$ 个并行工作槽，其中 $P\\ge 1$，但为了在不进行推测性资源超额分配的情况下保留 fork/join\\_any 语义，仅执行选定的 $\\arg\\min$ 任务，而其他任务则被取消（即，在硬件中从不启动）。\n- 必须使用显式有限状态控制。一个最小的控制可以通过状态指定：$\\mathrm{IDLE}\\to\\mathrm{SCAN}\\to\\mathrm{RUN}\\to\\mathrm{DONE}$。在 $\\mathrm{SCAN}$ 状态下，控制器通过顺序扫描 $N$ 个条目并选择具有确定性平局打破规则的最小值来计算 $i^\\star$。在 $\\mathrm{RUN}$ 状态下，它仅执行选定的任务，持续 $L_{i^\\star}$ 个周期。定义报告的完成时间以排除 $\\mathrm{SCAN}$ 周期，并使其等于执行延迟 $L_{i^\\star}$，以便在任务执行周期的层面上评估与行为 fork/join\\_any 的等效性。这模拟了在比较抽象级行为时，将组合或多周期选择控制与测量的执行区间分开的常见EDA实践。\n\n你的程序必须：\n1. 实现一个行为仿真器，给定一个延迟列表 $\\{L_i\\}$，该仿真器在 fork/join\\_any 语义下返回序对 $(i^\\star,t^\\star)$，并遵循上述指定的平局打破规则。\n2. 实现一个RTL有限状态控制仿真器，给定相同的列表、边界 $N_{\\max}$ 和并行工作槽数 $P$，该仿真器实现状态序列 $\\mathrm{IDLE}\\to\\mathrm{SCAN}\\to\\mathrm{RUN}\\to\\mathrm{DONE}$，取消所有未选中的任务，并返回序对 $(\\hat{i},\\hat{t})$，其中 $\\hat{i}$ 等于选定的索引，$\\hat{t}$ 等于 $L_{\\hat{i}}$（以周期为单位）。\n3. 通过为每个测试用例返回一个布尔值来验证等效性，该布尔值指示 $(i^\\star,t^\\star)=(\\hat{i},\\hat{t})$ 是否成立。\n\n单位和约定：\n- 所有延迟 $L_i$ 和报告的时间 $t^\\star,\\hat{t}$ 必须以周期为单位，表示为整数。\n- 对于 $N=0$，使用 $i^\\star=-1$ 和 $t^\\star=0$ 周期。\n\n测试套件：\n使用以下测试用例，每个用例由 $(\\{L_i\\}, N_{\\max}, P)$ 指定。\n- 情况A（正常路径）：$\\{L_i\\} = [\\,7,\\,2,\\,5,\\,4\\,]$，$N_{\\max}=8$，$P=2$。预期最小延迟为 $2$，在索引 $1$ 处。\n- 情况B（平局）：$\\{L_i\\} = [\\,3,\\,3,\\,5\\,]$，$N_{\\max}=8$，$P=4$。预期最小延迟为 $3$，平局打破后选择索引 $0$。\n- 情况C（存在零延迟）：$\\{L_i\\} = [\\,0,\\,4,\\,0,\\,2\\,]$，$N_{\\max}=8$，$P=3$。由于平局打破规则，预期最小延迟为 $0$，在索引 $0$ 处。\n- 情况D（单个任务）：$\\{L_i\\} = [\\,9\\,]$，$N_{\\max}=4$，$P=1$。预期最小延迟为 $9$，在索引 $0$ 处。\n- 情况E（空集）：$\\{L_i\\} = [\\,\\,]$（即 $N=0$），$N_{\\max}=4$，$P=1$。预期 $i^\\star=-1$，$t^\\star=0$。\n- 情况F（具有多个平局的更大数组）：$\\{L_i\\} = [\\,6,\\,5,\\,12,\\,3,\\,11,\\,7,\\,8,\\,3,\\,9,\\,10\\,]$，$N_{\\max}=16$，$P=4$。预期最小延迟为 $3$，在平局中最小的索引是索引 $3$。\n\n最终输出格式：\n你的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3]\"），其中每个结果是一个布尔值，指示相应测试用例的等效性。不应打印其他任何文本。",
            "solution": "该问题已经过验证，被认为是自洽的、在科学上基于数字设计和电子设计自动化（EDA）的原理，并且是良构的。它提出了一个标准的验证任务：确认高层并发模型与更具体的、顺序控制的寄存器传输级（RTL）实现之间的行为等效性。\n\n解决方案首先实现两个指定的不同仿真器：一个用于行为模型，另一个用于RTL模型。然后，它比较它们在给定测试用例集上的输出，以验证其等效性。\n\n1.  **行为模型仿真**\n    行为模型描述了一种基于 fork/join\\_any 语义的理想并发执行。给定一个包含 $N$ 个任务延迟的列表 $\\{L_0, L_1, \\dots, L_{N-1}\\}$，所有 $N$ 个任务在概念上于时间 $t=0$ 同时启动。整个操作在第一个任务完成时结束。\n\n    -   因此，完成时间 $t^\\star$ 是所有任务延迟中的最小值：\n        $$ t^\\star = \\min_{0 \\le i  N} L_i $$\n    -   已完成任务的标识 $i^\\star$ 是对应于此最小延迟的索引：\n        $$ i^\\star = \\arg\\min_{0 \\le i  N} L_i $$\n    -   问题指定了一个确定性的平局打破规则：如果多个任务共享相同的最小延迟，则选择索引最小的任务。用于查找最小值索引的标准库函数通常会隐式地遵守此规则。\n    -   为空任务集（$N=0$）定义了一个特殊的边界条件，其结果为 $(i^\\star, t^\\star) = (-1, 0)$。\n\n    行为仿真器的实现直接将这些规则形式化。它首先检查输入的延迟列表是否为空，以处理边界情况。如果不为空，它会计算列表中的最小值，并找到该最小值首次出现的索引。这将产生序对 $(i^\\star, t^\\star)$。\n\n2.  **RTL模型仿真**\n    RTL模型代表了一个可综合的硬件实现。由于可综合逻辑需要固定的资源和显式控制，行为模型的理想并发性被重构为一个由有限状态机（FSM）管理的顺序过程。FSM状态被指定为 $\\mathrm{IDLE} \\to \\mathrm{SCAN} \\to \\mathrm{RUN} \\to \\mathrm{DONE}$。\n\n    -   参数 $N_{\\max}$（最大任务数）和 $P$（并行工作单元数）定义了物理硬件的边界。然而，指定的控制逻辑简化了仿真：“仅执行选定的 $\\arg\\min$ 任务，而其他任务则被取消。” 这意味着即使有超过一个（$P  1$）的工作单元可用，也只有一个被用于执行。选择要运行的任务的逻辑与 $P$ 和 $N_{\\max}$ 无关（只要 $N \\le N_{\\max}$）。\n    -   在 $\\mathrm{SCAN}$ 状态下，控制器顺序检查 $N$ 个任务延迟，以识别将最先完成的任务。这在算法上与找到最小延迟及其对应索引 $\\hat{i}$ 是相同的，并采用与行为模型相同的平局打破规则。\n        $$ \\hat{i} = \\arg\\min_{0 \\le i  N} L_i $$\n    -   在 $\\mathrm{RUN}$ 状态下，机器*仅*执行在 $\\mathrm{SCAN}$ 状态下选择的单个任务。此状态的持续时间等于该任务的延迟 $L_{\\hat{i}}$。\n    -   问题的关键要素是等效性的定义。RTL模型的报告完成时间 $\\hat{t}$ 被指定为“执行延迟 $L_{\\hat{i}}$”，并明确排除了在 $\\mathrm{SCAN}$ 状态下花费的时间。\n        $$ \\hat{t} = L_{\\hat{i}} $$\n    -   因此，RTL模型仿真的输出是序对 $(\\hat{i}, \\hat{t})$。对于 $N=0$ 的情况，该模型正确地产生 $(-1, 0)$。\n\n3.  **等效性验证**\n    根据设计，RTL模型的核心逻辑被构造成产生一个与 fork/join\\_any 模型在行为上等效的结果。`SCAN` 阶段计算出的索引 $\\hat{i}$ 与行为模型的 $i^\\star$ 完全相同。报告的时间 $\\hat{t}$ 被定义为该任务的延迟 $L_{\\hat{i}}$，这与行为模型的 $t^\\star$ 相同。\n    $$ \\hat{i} = i^\\star $$\n    $$ \\hat{t} = L_{\\hat{i}} = L_{i^\\star} = t^\\star $$\n    程序通过在每个测试用例上执行两个仿真器并比较结果元组 $(i^\\star, t^\\star)$ 和 $(\\hat{i}, \\hat{t})$ 来验证这一点。该实现确认了这种逻辑等效性，预计对所有测试用例都成立。提供的Python代码实现了这两个仿真器并执行了指定的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef behavioral_simulator(latencies):\n    \"\"\"\n    Implements the behavioral simulator for a fork/join_any construct.\n\n    Args:\n        latencies (list[int]): A list of task latencies in cycles.\n\n    Returns:\n        tuple[int, int]: A pair (i_star, t_star) representing the index\n                         of the winning task and its latency.\n    \"\"\"\n    num_tasks = len(latencies)\n\n    # Handle the boundary case where there are no tasks.\n    if num_tasks == 0:\n        return -1, 0\n\n    # Under fork/join_any semantics, the completion time is the minimum latency.\n    # The numpy.argmin function finds the index of the first occurrence of the\n    # minimum value, which satisfies the specified tie-breaking rule.\n    i_star = np.argmin(latencies)\n    t_star = latencies[i_star]\n\n    return int(i_star), int(t_star)\n\ndef rtl_simulator(latencies, N_max, P):\n    \"\"\"\n    Implements the synthesizable RTL finite-state control simulator.\n\n    Args:\n        latencies (list[int]): A list of task latencies.\n        N_max (int): The maximum number of tasks the hardware can support.\n        P (int): The number of parallel worker slots available in hardware.\n\n    Returns:\n        tuple[int, int]: A pair (i_hat, t_hat) representing the selected\n                         task index and its execution latency.\n    \"\"\"\n    num_tasks = len(latencies)\n    \n    # The parameters N_max and P are contextual for a physical hardware\n    # implementation but do not affect the simulation logic as specified.\n    # The RTL logic is defined to first scan for the minimum latency task\n    # and then execute only that one, cancelling others. The reported time\n    # explicitly excludes the scan time.\n\n    # FSM State: IDLE - SCAN\n    # In the SCAN phase, the controller finds the task to execute.\n    if num_tasks == 0:\n        # If no tasks, SCAN phase finds nothing, FSM proceeds to DONE.\n        # The result is defined by the boundary condition.\n        return -1, 0\n\n    # The scan identifies the task with the minimum latency.\n    # np.argmin adheres to the tie-breaking rule (smallest index).\n    i_hat = np.argmin(latencies)\n    selected_task_latency = latencies[i_hat]\n\n    # FSM State: SCAN - RUN\n    # In the RUN phase, only the selected task is executed. Its duration is\n    # its latency. The problem specifies the reported time is this latency.\n    t_hat = selected_task_latency\n\n    # FSM State: RUN - DONE\n    return int(i_hat), int(t_hat)\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and validates equivalence.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        {'latencies': [7, 2, 5, 4], 'N_max': 8, 'P': 2},\n        # Case B (tie)\n        {'latencies': [3, 3, 5], 'N_max': 8, 'P': 4},\n        # Case C (zero latency present)\n        {'latencies': [0, 4, 0, 2], 'N_max': 8, 'P': 3},\n        # Case D (single task)\n        {'latencies': [9], 'N_max': 4, 'P': 1},\n        # Case E (empty set)\n        {'latencies': [], 'N_max': 4, 'P': 1},\n        # Case F (larger array with multiple ties)\n        {'latencies': [6, 5, 12, 3, 11, 7, 8, 3, 9, 10], 'N_max': 16, 'P': 4}\n    ]\n\n    results = []\n    for case in test_cases:\n        latencies = case['latencies']\n        n_max = case['N_max']\n        p = case['P']\n        \n        # Run the behavioral simulation\n        i_star, t_star = behavioral_simulator(latencies)\n        \n        # Run the RTL simulation\n        i_hat, t_hat = rtl_simulator(latencies, n_max, p)\n        \n        # Validate that the results are equivalent\n        is_equivalent = (i_star, t_star) == (i_hat, t_hat)\n        results.append(is_equivalent)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在进入 RTL 抽象层次后，精确掌握硬件描述语言（HDL）的仿真语义至关重要，因为它们直接映射到硬件的行为。本练习将探讨同步流水线设计中阻塞赋值（`=`）与非阻塞赋值（`=`）之间的根本区别。通过计算和对比两种语义下的流水线逐周期输出，您将理解这一差异如何影响寄存器之间的数据流动，而掌握它正是正确描述时序逻辑、避免设计缺陷的关键。",
            "id": "4294389",
            "problem": "考虑一个在电子设计自动化 (EDA) 背景下，使用硬件描述语言 (HDL) 描述的三级同步流水线的周期精确寄存器传输级 (RTL) 模型。该流水线包含三个寄存器 $s_1$、$s_2$ 和 $s_3$，由一个采用上升沿触发的单一全局时钟驱动。所有寄存器在周期 $t=0$ 时初始化为零，因此 $s_1[0]=0$，$s_2[0]=0$，且 $s_3[0]=0$。该流水线在每个时钟周期采样一个标量输入流 $x[t]$，其输入由离散时间函数 $x[t]=4t-1$ 定义，适用于所有整数周期 $t \\geq 1$。该流水线每级的变换为：在第 2 级增加 $k=2$，在第 3 级乘以 $m=3$。\n\n你将分析在 RTL 抽象级别下的两种 HDL 赋值语义：\n\n1. 阻塞式语义：在单个同步更新块内，赋值按程序顺序执行并立即更新目标变量。这可以通过同周期有序更新来建模：\n$$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t] + k,\\\\\ns_3[t] = m \\cdot s_2[t].\n\\end{aligned}\n$$\n在阻塞式语义下，将可观测流水线输出定义为 $y_{\\mathrm{B}}[t] = s_3[t]$。\n\n2. 非阻塞式语义：在单个同步更新块内，所有赋值都调度更新在时钟节拍结束时并发进行，因此右侧表达式读取的是前一个周期的值。这可以通过并发更新来建模：\n$$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t-1] + k,\\\\\ns_3[t] = m \\cdot s_2[t-1].\n\\end{aligned}\n$$\n在非阻塞式语义下，将可观测流水线输出定义为 $y_{\\mathrm{NB}}[t] = s_3[t]$。\n\n从这些定义和 $t=0$ 时的初始化开始，计算 $t=1,2,\\dots,10$ 时逐周期的输出 $y_{\\mathrm{B}}[t]$ 和 $y_{\\mathrm{NB}}[t]$。然后计算标量值\n$\nD=\\sum_{t=1}^{10}\\left(y_{\\mathrm{B}}[t]-y_{\\mathrm{NB}}[t]\\right).\n$\n给出 $D$ 的最终数值，无需单位。不需要四舍五入。",
            "solution": "...",
            "answer": "$$ \\boxed{228} $$"
        },
        {
            "introduction": "一个 RTL 描述通常会被多种工具分析，包括仿真器和形式验证工具，但它们底层的抽象模型可能存在差异。本练习聚焦于 HDL 仿真中常见的四值逻辑（`0`, `1`, `X`, `Z`）与形式等价性检查中典型的二值逻辑（`0`, `1`）之间的关键区别。通过模拟一个包含未初始化寄存器的场景，您将探索这种语义差异如何导致仿真与形式验证结果不匹配，并理解为何掌握不同工具的抽象模型对于实现稳健的验证流程至关重要。",
            "id": "4294432",
            "problem": "构建一个独立的编程实验，以形式化地展示双态语义与四态仿真语义之间的差异。前者是电子设计自动化（EDA）中某些形式等效性检查的典型特征，后者则用于硬件描述语言（HDL）如Verilog中，当寄存器上电时其值为未知的 $X$。考虑一个最小化的寄存器传输级（RTL）设计，该设计显式地模拟了一种常见场景：一个没有复位的寄存器，其值在输出端由复位线进行门控。对于 $W$ 位的数据宽度，其行为由以下离散时间步长 $t \\in \\{0,1,\\dots,T-1\\}$ 上的数学模型指定。\n\n定义状态寄存器 $q_t \\in \\{0,1,X\\}^W$，异步低电平有效复位信号表示为 $rst\\_n_t \\in \\{0,1\\}$，加载使能信号 $sel_t \\in \\{0,1\\}$，以及输入数据 $d_t \\in \\{0,1\\}^W$。该设计对 $q_t$ 没有显式复位；仅输出由复位信号进行门控。输出和次态方程如下：\n$$\ny_t = rst\\_n_t \\land q_t, \\quad q_{t+1} = \\begin{cases}\nd_t  \\text{if } sel_t = 1, \\\\\nq_t  \\text{if } sel_t = 0.\n\\end{cases}\n$$\n在四态仿真语义（硬件描述语言（HDL）中使用）中，初始条件为 $q_0 = X^W$，意味着 $q_0$ 的所有位均为 $X$。逻辑运算符遵循带有控制值的四态规则，具体到带有 $AND$ 运算的输出方程：如果 $rst\\_n_t = 0$，则 $y_t = 0^W$；如果 $rst\\_n_t = 1$，则 $y_t = q_t$。在双态语义（某些形式等效性模式的典型特征）中，所有值都在 $\\{0,1\\}$ 集合内，且初始寄存器状态假定为一个已知的常数 $b \\in \\{0,1\\}$，即 $q_0^{(2)} = b^W$，次态更新方程相同。\n\n时间语义如下：输出 $y_t$ 根据当前状态 $q_t$ 和 $rst\\_n_t$ 计算；之后，使用 $sel_t$ 和 $d_t$ 将状态更新为 $q_{t+1}$。这模拟了由时钟驱动的同步状态更新，其中 $y_t$ 在时间点 $t$ 的状态转换之前被观测到。\n\n定义 $y_t^{(4)}$ 为四态语义下的输出，$y_t^{(2)}$ 为双态语义下的输出。定义时间步长不匹配指示器 $M(t)$ 如下：\n$$\nM(t) = \\begin{cases}\n1  \\text{if any bit of } y_t^{(4)} \\text{ is } X \\text{ or if } y_t^{(4)} \\neq y_t^{(2)} \\text{ bitwise}, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n我们感兴趣的量是总的不匹配时间步数：\n$$\n\\mathrm{mismatch\\_count} = \\sum_{t=0}^{T-1} M(t).\n$$\n\n编写一个程序，对于每个测试用例，在 $T$ 个周期内模拟两种语义，其中当 $t  R$ 时 $rst\\_n_t = 0$，当 $t \\ge R$ 时 $rst\\_n_t = 1$，并计算 $\\mathrm{mismatch\\_count}$。\n\n您的程序必须实现：\n- 根据上述定义，实现 $q_t$ 和 $y_t$ 的四态值，包括当 $rst\\_n_t = 1$ 且 $q_t$ 包含 $X$ 时，$X$ 在输出端的传播。\n- 实现双态值，其中 $q_0^{(2)}$ 假定上电位为 $b \\in \\{0,1\\}$，所有逻辑都在 $\\{0,1\\}$ 集合内。\n- 实现同步时序模型，其中 $y_t$ 在计算 $q_{t+1}$ 之前根据 $q_t$ 和 $rst\\_n_t$ 计算。\n\n使用以下测试套件，每个测试用例指定为 $(W, T, R, b, sel, d)$：\n- 测试 1：$W = 1$, $T = 6$, $R = 2$, $b = 0$, $sel = [0,0,0,0,1,0]$, $d = [1,1,1,1,1,1]$。\n- 测试 2：$W = 8$, $T = 8$, $R = 3$, $b = 0$, $sel = [0,0,0,0,0,1,0,0]$, $d = [170,85,255,0,1,2,3,4]$。\n- 测试 3：$W = 4$, $T = 3$, $R = 3$, $b = 0$, $sel = [1,0,1]$, $d = [5,10,15]$。\n- 测试 4：$W = 2$, $T = 6$, $R = 1$, $b = 0$, $sel = [0,1,0,0,1,0]$, $d = [3,1,2,0,3,1]$。\n\n所有列表条目均为整数，对于 $d$ 的条目，其值必须解释为 $W$ 位的二进制字。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[result1,result2,result3,result4]`）。每个 `resulti` 必须是对应测试用例的整数 `mismatch_count`。不涉及物理单位。所有角度（如有）必须以弧度为单位。所有比率必须表示为小数或分数，而不是百分比。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上基于数字逻辑设计和电子设计自动化（EDA）的原理，问题提出得很好，具有清晰完整的定义和约束，并且其表述是客观的。该问题正确地模拟了一个常见场景，即四态仿真（如硬件描述语言Verilog中的典型情况）与双态形式化模型之间的差异变得明显，特别是在未初始化寄存器方面。\n\n任务是构建一个计算实验，以量化给定寄存器传输级（RTL）设计在这两种语义模型下的行为差异。我们感兴趣的量是 $\\mathrm{mismatch\\_count}$，定义为两个模型的输出发生分歧的总时间步数。\n\n解决方案通过在离散时间范围 $t \\in \\{0, 1, \\dots, T-1\\}$ 上模拟四态和双态模型的系统动态来进行。\n\n首先，我们必须为逻辑值建立一个具体的表示方法。双态模型使用集合 $\\{0, 1\\}$，这可以直接用标准整数表示。四态模型需要来自 $\\{0, 1, X\\}$ 的值。我们将它们表示为整数，其中 $0$ 对应逻辑 $0$，$1$ 对应逻辑 $1$，并使用 $-1$ 来表示未知状态 $X$。所有多位向量，如状态寄存器 $q_t$ 和数据输入 $d_t$，都建模为这些整数表示的数组。作为整数提供的输入数据 $d_t$，必须转换为其等效的 $W$ 位二进制向量。\n\n仿真对从 $0$ 到 $T-1$ 的每个时间步 $t$ 进行迭代，遵循指定的同步时序模型，其中输出在状态为下一周期更新之前根据当前状态计算。\n\n在每个时间步 $t$：\n1.  确定低电平有效复位信号 $rst\\_n_t$ 的值。根据规定，当 $t  R$ 时 $rst\\_n_t = 0$，当 $t \\ge R$ 时 $rst\\_n_t = 1$。\n\n2.  四态模型的输出 $y_t^{(4)}$ 基于方程 $y_t = rst\\_n_t \\land q_t$ 计算。逻辑与（AND）运算遵循带控制值的四态逻辑。如果 $rst\\_n_t = 0$，其控制特性会强制输出到一个已知状态，因此 $y_t^{(4)} = 0^W$。如果 $rst\\_n_t = 1$，这是与门的一个非控制值，输出将直接通过寄存器的值，即 $y_t^{(4)} = q_t^{(4)}$。\n\n3.  双态模型的输出 $y_t^{(2)}$ 以类似方式计算。运算 $rst\\_n_t \\land q_t^{(2)}$ 在 $rst\\_n_t = 0$ 时得到 $y_t^{(2)} = 0^W$，在 $rst\\_n_t = 1$ 时得到 $y_t^{(2)} = q_t^{(2)}$。由于所有值都在 $\\{0, 1\\}$ 集合内，这是一个标准的按位运算。\n\n4.  评估不匹配指示器 $M(t)$。如果不匹配发生，则四态输出包含任何未知位，或者它已完全定义但与双态输出不同。形式上，如果 $y_t^{(4)}$ 的任何位是 $X$（表示为-1），或者如果 $y_t^{(4)}$ 和 $y_t^{(2)}$ 按位不相同，则 $M(t)=1$。否则，$M(t)=0$。如果 $M(t)=1$，则总 $\\mathrm{mismatch\\_count}$ 增加。\n\n5.  两种模型的次态 $q_{t+1}^{(4)}$ 和 $q_{t+1}^{(2)}$ 由次态方程确定：\n    $$\n    q_{t+1} = \\begin{cases}\n    d_t  \\text{if } sel_t = 1, \\\\\n    q_t  \\text{if } sel_t = 0.\n    \\end{cases}\n    $$\n    如果加载使能信号 $sel_t = 1$，则状态寄存器 $q_t^{(4)}$ 和 $q_t^{(2)}$ 都会更新为输入数据向量 $d_t$ 的值。此操作可以从 $q_t^{(4)}$ 中清除未知状态 $X$。如果 $sel_t = 0$，则两个寄存器都保持其当前值。\n\n整个过程被封装在一个函数中，该函数接受一个测试用例的参数 $(W, T, R, b, sel, d)$ 并返回最终计算出的 $\\mathrm{mismatch\\_count}$。初始条件在 $t=0$ 时设置：$q_0^{(4)} = X^W$ 和 $q_0^{(2)} = b^W$。然后对所有指定的测试用例执行仿真，以生成所需的结果列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the simulation for all test cases and print the results.\n    \"\"\"\n    # Test cases defined as (W, T, R, b, sel, d)\n    test_cases = [\n        (1, 6, 2, 0, [0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1]),\n        (8, 8, 3, 0, [0, 0, 0, 0, 0, 1, 0, 0], [170, 85, 255, 0, 1, 2, 3, 4]),\n        (4, 3, 3, 0, [1, 0, 1], [5, 10, 15]),\n        (2, 6, 1, 0, [0, 1, 0, 0, 1, 0], [3, 1, 2, 0, 3, 1]),\n    ]\n\n    results = []\n    for W, T, R, b, sel, d in test_cases:\n        result = run_simulation(W, T, R, b, sel, d)\n        results.append(result)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef int_to_bits(n, width):\n    \"\"\"\n    Converts an integer to its W-bit binary representation as a NumPy array.\n    \"\"\"\n    if n  0:\n        raise ValueError(\"Input data must be non-negative.\")\n    binary_string = format(n, f'0{width}b')\n    return np.array([int(bit) for bit in binary_string], dtype=int)\n\ndef run_simulation(W, T, R, b, sel, d):\n    \"\"\"\n    Simulates the RTL design for a single test case under both 4-state and 2-state semantics.\n\n    Args:\n        W (int): Data width in bits.\n        T (int): Total number of time steps (cycles).\n        R (int): Number of initial cycles where reset is active.\n        b (int): Initial value (0 or 1) for the 2-state register bits.\n        sel (list): List of load-enable signals for each time step.\n        d (list): List of input data values for each time step.\n\n    Returns:\n        int: The total number of mismatch time steps.\n    \"\"\"\n    # A constant to represent the unknown 'X' state.\n    X_STATE = -1\n    mismatch_count = 0\n\n    # 1. Initialize states\n    # Four-state model: register starts at all 'X'\n    q_4 = np.full(W, X_STATE, dtype=int)\n    # Two-state model: register starts at a known constant 'b'\n    q_2 = np.full(W, b, dtype=int)\n\n    # Convert integer data inputs to W-bit NumPy arrays\n    d_bits_vectors = [int_to_bits(val, W) for val in d]\n\n    # 2. Loop through time steps t = 0 to T-1\n    for t in range(T):\n        # Determine rst_n_t based on the time step t and reset duration R\n        rst_n_t = 0 if t  R else 1\n\n        # 3. Calculate outputs y_t for both models\n        # Four-state output y_t^(4)\n        if rst_n_t == 0:\n            # The controlling '0' on the AND gate makes the output '0'\n            y_4 = np.zeros(W, dtype=int)\n        else:\n            # The '1' on the AND gate passes the register value through\n            y_4 = q_4.copy()\n\n        # Two-state output y_t^(2)\n        if rst_n_t == 0:\n            y_2 = np.zeros(W, dtype=int)\n        else:\n            y_2 = q_2.copy()\n            \n        # 4. Check for mismatch M(t)\n        # Mismatch if y_4 has any 'X' bits\n        has_x = np.any(y_4 == X_STATE)\n        if has_x:\n            mismatch_count += 1\n        else:\n            # Or if y_4 is a known value but differs from y_2\n            if not np.array_equal(y_4, y_2):\n                mismatch_count += 1\n\n        # 5. Calculate next states q_{t+1}\n        sel_t = sel[t]\n        d_t_bits = d_bits_vectors[t]\n\n        if sel_t == 1:\n            # Update both registers with the input data if sel_t is 1\n            q_4 = d_t_bits.copy()\n            q_2 = d_t_bits.copy()\n        # If sel_t is 0, registers q_4 and q_2 retain their old values (no update needed)\n\n    return mismatch_count\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}