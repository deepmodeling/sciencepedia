{
    "hands_on_practices": [
        {
            "introduction": "Design rules are the essential bridge between the physical realities of semiconductor manufacturing and the abstract geometry of a layout. This first practice demystifies this connection by tasking you with deriving a fundamental rule—via enclosure—from first principles. By accounting for worst-case process variations like layer misalignment (overlay) and feature size changes (etch bias), you will calculate the minimum required metal overlap to guarantee a reliable electrical connection, a critical factor for manufacturability and yield. This exercise  provides a concrete foundation for understanding why design rules exist and how they are quantified.",
            "id": "4281460",
            "problem": "In advanced Electronic Design Automation (EDA) for integrated circuits, mask layout layers are subject to overlay and etch process variations that must be accounted for in design rule notation to guarantee electrical continuity. Consider a via layer that connects two metal layers. The via is drawn as a rectangle with horizontal side length $V_{x}$ and vertical side length $V_{y}$ on the via mask. The metal polygon intended to enclose the via is drawn such that the distance from the via edge to the metal edge on each side is the metal enclosure. Due to process variations, the following effects occur:\n\n1. Overlay variation between the via layer and the metal layer causes a relative displacement of the via center with respect to the metal polygon up to $O_{x}$ in the horizontal direction and up to $O_{y}$ in the vertical direction.\n2. Etch bias of the metal layer causes an inward shrinkage of the metal polygon edges by $b_{m,x}$ per vertical edge and $b_{m,y}$ per horizontal edge.\n3. Etch bias of the via opening changes the via side lengths. The final via side lengths become $V_{x}^{\\prime} = V_{x} + \\beta_{x} V_{x}$ and $V_{y}^{\\prime} = V_{y} + \\beta_{y} V_{y}$, where $\\beta_{x}$ and $\\beta_{y}$ are fractional biases (positive for enlargement, negative for shrinkage).\n\nUnder these effects, the condition for electrical continuity is that, in the worst-case combination of overlay and etch biases, the final via opening lies completely within the final metal polygon. Define the drawn metal enclosures on the left, right, top, and bottom as $E_{\\text{left}}$, $E_{\\text{right}}$, $E_{\\text{top}}$, and $E_{\\text{bottom}}$, respectively, measured from the drawn via edge to the drawn metal edge. Assume worst-case misalignment brings the via edge as close as possible to each corresponding metal edge, and process biases act to reduce the available margin.\n\nGiven the following scientifically realistic and self-consistent parameters:\n- Via drawn dimensions: $V_{x} = 36\\,\\mathrm{nm}$, $V_{y} = 28\\,\\mathrm{nm}$.\n- Overlay budgets: $O_{x} = 3.5\\,\\mathrm{nm}$, $O_{y} = 2.8\\,\\mathrm{nm}$.\n- Metal etch bias (inward per edge): $b_{m,x} = 4.2\\,\\mathrm{nm}$, $b_{m,y} = 5.1\\,\\mathrm{nm}$.\n- Via fractional etch bias: $\\beta_{x} = 0.02$, $\\beta_{y} = 0.01$.\n\nCompute the minimum required drawn metal enclosure on each side, $E_{\\text{left}}$, $E_{\\text{right}}$, $E_{\\text{top}}$, and $E_{\\text{bottom}}$, that guarantees the via remains fully covered by the metal after processing under worst-case overlay and etch biases. Express your final enclosure values in nanometers. No rounding is required; provide exact values implied by the given parameters.",
            "solution": "The problem requires the calculation of the minimum drawn metal enclosures ($E_{\\text{left}}$, $E_{\\text{right}}$, $E_{\\text{top}}$, $E_{\\text{bottom}}$) around a via to ensure electrical continuity under worst-case process variations. The condition for continuity is that the final, post-process via polygon must lie entirely within the final, post-process metal polygon. This can be formulated as a set of geometric constraints that must hold under the most adverse combination of overlay errors and etch biases.\n\nLet us establish a coordinate system with its origin $(0, 0)$ at the center of the *drawn* via. The via is a rectangle aligned with the axes.\n\nThe edges of the *drawn* via are located at:\n- Left edge: $x = -\\frac{V_x}{2}$\n- Right edge: $x = +\\frac{V_x}{2}$\n- Bottom edge: $y = -\\frac{V_y}{2}$\n- Top edge: $y = +\\frac{V_y}{2}$\n\nThe edges of the *drawn* metal polygon that encloses the via are located at:\n- Left edge: $x = -\\frac{V_x}{2} - E_{\\text{left}}$\n- Right edge: $x = +\\frac{V_x}{2} + E_{\\text{right}}$\n- Bottom edge: $y = -\\frac{V_y}{2} - E_{\\text{bottom}}$\n- Top edge: $y = +\\frac{V_y}{2} + E_{\\text{top}}$\n\nNext, we model the effects of the specified process variations on the final geometry of the via and metal.\n\n1.  **Final Via Geometry**:\n    - The via dimensions are altered by a fractional etch bias. The final side lengths, $V_x'$ and $V_y'$, are:\n      $$V_x' = V_x + \\beta_x V_x = V_x(1 + \\beta_x)$$\n      $$V_y' = V_y + \\beta_y V_y = V_y(1 + \\beta_y)$$\n      Since the given $\\beta_x = 0.02$ and $\\beta_y = 0.01$ are positive, the via enlarges. This enlargement pushes the via edges outward, reducing the margin.\n    - The via center is displaced by an overlay variation, $(\\delta_x, \\delta_y)$, where the maximum displacements are $|\\delta_x| \\le O_x$ and $|\\delta_y| \\le O_y$.\n    - The edges of the *final* via, centered at $(\\delta_x, \\delta_y)$, are located at:\n      - Left edge, $x_{v, \\text{left}} = \\delta_x - \\frac{V_x'}{2}$\n      - Right edge, $x_{v, \\text{right}} = \\delta_x + \\frac{V_x'}{2}$\n      - Bottom edge, $y_{v, \\text{bottom}} = \\delta_y - \\frac{V_y'}{2}$\n      - Top edge, $y_{v, \\text{top}} = \\delta_y + \\frac{V_y'}{2}$\n\n2.  **Final Metal Geometry**:\n    - The metal edges experience an inward shrinkage (etch bias). The bias is $b_{m,x}$ for vertical edges and $b_{m,y}$ for horizontal edges.\n    - The edges of the *final* metal polygon are located at:\n      - Left edge, $x_{m, \\text{left}} = \\left(-\\frac{V_x}{2} - E_{\\text{left}}\\right) + b_{m,x}$\n      - Right edge, $x_{m, \\text{right}} = \\left(+\\frac{V_x}{2} + E_{\\text{right}}\\right) - b_{m,x}$\n      - Bottom edge, $y_{m, \\text{bottom}} = \\left(-\\frac{V_y}{2} - E_{\\text{bottom}}\\right) + b_{m,y}$\n      - Top edge, $y_{m, \\text{top}} = \\left(+\\frac{V_y}{2} + E_{\\text{top}}\\right) - b_{m,y}$\n\nThe condition for complete enclosure is that for each side, the final via edge must not extend past the corresponding final metal edge. This yields four inequalities that must hold for all possible process variations within the given budgets.\n\n**Analysis for the Left Enclosure, $E_{\\text{left}}$**:\nThe containment condition is $x_{v, \\text{left}} \\ge x_{m, \\text{left}}$.\n$$\\delta_x - \\frac{V_x'}{2} \\ge -\\frac{V_x}{2} - E_{\\text{left}} + b_{m,x}$$\nWe rearrange to solve for the required enclosure $E_{\\text{left}}$:\n$$E_{\\text{left}} \\ge -\\frac{V_x}{2} + b_{m,x} - \\delta_x + \\frac{V_x'}{2}$$\nTo find the minimum required $E_{\\text{left}}$, we must consider the worst-case scenario that maximizes the right-hand side of the inequality. This occurs when:\n- The via shifts as far left as possible: $\\delta_x = -O_x$.\n- The via enlarges due to etch bias (since $\\beta_x > 0$): $V_x' = V_x(1 + \\beta_x)$.\nSubstituting these worst-case values:\n$$E_{\\text{left}} \\ge -\\frac{V_x}{2} + b_{m,x} - (-O_x) + \\frac{V_x(1 + \\beta_x)}{2}$$\n$$E_{\\text{left}} \\ge -\\frac{V_x}{2} + b_{m,x} + O_x + \\frac{V_x}{2} + \\frac{\\beta_x V_x}{2}$$\n$$E_{\\text{left}} \\ge O_x + b_{m,x} + \\frac{\\beta_x V_x}{2}$$\nThe minimum required enclosure for the left side is therefore $E_{\\text{left, min}} = O_x + b_{m,x} + \\frac{\\beta_x V_x}{2}$.\n\n**Analysis for the Right Enclosure, $E_{\\text{right}}$**:\nThe containment condition is $x_{v, \\text{right}} \\le x_{m, \\text{right}}$.\n$$\\delta_x + \\frac{V_x'}{2} \\le \\frac{V_x}{2} + E_{\\text{right}} - b_{m,x}$$\n$$E_{\\text{right}} \\ge \\delta_x + \\frac{V_x'}{2} - \\frac{V_x}{2} + b_{m,x}$$\nThe worst case occurs when the via shifts right: $\\delta_x = +O_x$.\n$$E_{\\text{right}} \\ge O_x + \\frac{V_x(1 + \\beta_x)}{2} - \\frac{V_x}{2} + b_{m,x}$$\n$$E_{\\text{right}} \\ge O_x + \\frac{\\beta_x V_x}{2} + b_{m,x}$$\nThe minimum required enclosure is $E_{\\text{right, min}} = O_x + b_{m,x} + \\frac{\\beta_x V_x}{2}$.\n\nBy symmetry of the process effects in the horizontal direction, $E_{\\text{left, min}} = E_{\\text{right, min}}$.\n\n**Analysis for the Top Enclosure, $E_{\\text{top}}$**:\nThe containment condition is $y_{v, \\text{top}} \\le y_{m, \\text{top}}$. Following a similar derivation:\n$$E_{\\text{top}} \\ge \\delta_y + \\frac{V_y'}{2} - \\frac{V_y}{2} + b_{m,y}$$\nThe worst case is an upward shift of the via: $\\delta_y = +O_y$.\n$$E_{\\text{top}} \\ge O_y + \\frac{V_y(1 + \\beta_y)}{2} - \\frac{V_y}{2} + b_{m,y}$$\nThe minimum required enclosure is $E_{\\text{top, min}} = O_y + b_{m,y} + \\frac{\\beta_y V_y}{2}$.\n\n**Analysis for the Bottom Enclosure, $E_{\\text{bottom}}$**:\nThe containment condition is $y_{v, \\text{bottom}} \\ge y_{m, \\text{bottom}}$. Following a similar derivation:\n$$E_{\\text{bottom}} \\ge -\\frac{V_y}{2} + b_{m,y} - \\delta_y + \\frac{V_y'}{2}$$\nThe worst case is a downward shift of the via: $\\delta_y = -O_y$.\n$$E_{\\text{bottom}} \\ge -\\frac{V_y}{2} + b_{m,y} - (-O_y) + \\frac{V_y(1 + \\beta_y)}{2}$$\nThe minimum required enclosure is $E_{\\text{bottom, min}} = O_y + b_{m,y} + \\frac{\\beta_y V_y}{2}$.\n\nBy symmetry in the vertical direction, $E_{\\text{top, min}} = E_{\\text{bottom, min}}$.\n\nNow we substitute the given numerical values:\n- $V_x = 36\\,\\mathrm{nm}$, $O_x = 3.5\\,\\mathrm{nm}$, $b_{m,x} = 4.2\\,\\mathrm{nm}$, $\\beta_x = 0.02$.\n- $V_y = 28\\,\\mathrm{nm}$, $O_y = 2.8\\,\\mathrm{nm}$, $b_{m,y} = 5.1\\,\\mathrm{nm}$, $\\beta_y = 0.01$.\n\nMinimum horizontal enclosure:\n$$E_{\\text{left, min}} = E_{\\text{right, min}} = 3.5 + 4.2 + \\frac{0.02 \\times 36}{2}$$\n$$E_{\\text{left, min}} = E_{\\text{right, min}} = 7.7 + \\frac{0.72}{2}$$\n$$E_{\\text{left, min}} = E_{\\text{right, min}} = 7.7 + 0.36 = 8.06\\,\\mathrm{nm}$$\n\nMinimum vertical enclosure:\n$$E_{\\text{top, min}} = E_{\\text{bottom, min}} = 2.8 + 5.1 + \\frac{0.01 \\times 28}{2}$$\n$$E_{\\text{top, min}} = E_{\\text{bottom, min}} = 7.9 + \\frac{0.28}{2}$$\n$$E_{\\text{top, min}} = E_{\\text{bottom, min}} = 7.9 + 0.14 = 8.04\\,\\mathrm{nm}$$\n\nThe minimum required drawn metal enclosures on each side are:\n- $E_{\\text{left}} = 8.06\\,\\mathrm{nm}$\n- $E_{\\text{right}} = 8.06\\,\\mathrm{nm}$\n- $E_{\\text{top}} = 8.04\\,\\mathrm{nm}$\n- $E_{\\text{bottom}} = 8.04\\,\\mathrm{nm}$",
            "answer": "$$\\boxed{\\begin{pmatrix}8.06 & 8.06 & 8.04 & 8.04\\end{pmatrix}}$$"
        },
        {
            "introduction": "Once design rules are defined, they must be verified across millions of shapes on a layout, a computationally intensive task. This practice transitions from rule derivation to automated rule checking, introducing a powerful technique used in modern Design Rule Check (DRC) engines. You will implement a proximity check by modeling layout layers on a discrete grid and applying the Euclidean Distance Transform, which elegantly translates a complex geometric query into an efficient image processing problem. This hands-on coding exercise  demonstrates how abstract concepts like the Minkowski sum are realized in practice to create scalable verification tools.",
            "id": "4281470",
            "problem": "You are given two integrated circuit mask layout layers modeled as planar sets in the Cartesian plane. Let $A \\subset \\mathbb{R}^2$ and $B \\subset \\mathbb{R}^2$ denote the regions occupied by the two layers. The fundamental base consists of the Euclidean metric, where for $x \\in \\mathbb{R}^2$ and a set $S \\subset \\mathbb{R}^2$, the shortest Euclidean distance is defined by $\\mathrm{dist}(x,S) = \\inf\\{\\lVert x - y \\rVert_2 : y \\in S\\}$. A proximity-based design rule can be expressed using the Minkowski sum with a closed disk of radius $d$, denoted $D_d = \\{ z \\in \\mathbb{R}^2 : \\lVert z \\rVert_2 \\le d \\}$, and the morphological dilation $B \\oplus D_d = \\{ b + z : b \\in B, z \\in D_d \\} = \\{ x \\in \\mathbb{R}^2 : \\mathrm{dist}(x,B) \\le d \\}$.\n\nConstruct a Boolean expression, in terms of $A$, $B$, and $d$, that detects the locations where layer $A$ overlaps layer $B$ within Euclidean distance $d$. Derive this expression starting from the definitions above. Then outline an algorithm that computes the detection mask on a discretized grid by sampling the plane at a uniform resolution. The algorithm must be implementable without polygon clipping, using only binary masks and the Euclidean distance transform. Distances must be treated in micrometers (µm). The grid sampling resolution must be $r = 0.1$ micrometers per pixel.\n\nYour program must implement the algorithm and evaluate the detection condition for the following test suite of parameterized cases. In each case, the computational domain is the square $[0,L] \\times [0,L]$ with $L = 20$ micrometers, sampled at resolution $r = 0.1$ micrometers per pixel. Rectangles are axis-aligned and specified by their lower-left and upper-right corners in micrometers. The Euclidean proximity threshold $d$ is given in micrometers. For each case, report a boolean indicating if any point in $A$ lies within distance $d$ of $B$, i.e., whether the detection mask has any true element.\n\nTest suite:\n- Case 1 (happy path): $A$ is the rectangle with corners $(3,3)$ and $(8,7)$, $B$ is the rectangle with corners $(10,3)$ and $(14,7)$, $d = 2.5$.\n- Case 2 (boundary of overlap rule at zero distance): $A$ is the rectangle with corners $(12,4)$ and $(13,6)$, $B$ is the rectangle with corners $(10,3)$ and $(14,7)$, $d = 0$.\n- Case 3 (significant edge case: far separation): $A$ is the rectangle with corners $(0,0)$ and $(2,2)$, $B$ is the rectangle with corners $(10,3)$ and $(14,7)$, $d = 1.0$.\n- Case 4 (diagonal proximity): $A$ is the rectangle with corners $(8,7.6)$ and $(11,8.0)$, $B$ is the rectangle with corners $(10,3)$ and $(14,7)$, $d = 0.6$.\n\nRequired output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean value for the corresponding case in the order given.",
            "solution": "We formalize the detection of proximity between two mask layout layers using definitions from Euclidean geometry and set operations relevant to Electronic Design Automation (EDA). The key objects are two sets $A \\subset \\mathbb{R}^2$ and $B \\subset \\mathbb{R}^2$ representing the layers, along with the Euclidean distance defined by $\\mathrm{dist}(x,S) = \\inf\\{\\lVert x - y \\rVert_2 : y \\in S\\}$ for a point $x \\in \\mathbb{R}^2$ and a set $S \\subset \\mathbb{R}^2$.\n\nStarting from the fundamental definitions, the closed disk of radius $d$ centered at the origin is $D_d = \\{ z \\in \\mathbb{R}^2 : \\lVert z \\rVert_2 \\le d \\}$. The Minkowski sum of a set $B$ with $D_d$ is $B \\oplus D_d = \\{ b + z : b \\in B, z \\in D_d \\}$. A well-tested fact is that $B \\oplus D_d = \\{ x \\in \\mathbb{R}^2 : \\mathrm{dist}(x,B) \\le d \\}$, meaning the dilation of $B$ by a disk of radius $d$ is the set of all points at most distance $d$ from $B$.\n\nWe seek a Boolean expression that indicates the locations where $A$ overlaps $B$ within distance $d$. The detection mask $M$ is therefore derived as\n$$\nM = A \\cap (B \\oplus D_d) = \\{ x \\in \\mathbb{R}^2 : x \\in A \\ \\text{and} \\ \\mathrm{dist}(x,B) \\le d \\}.\n$$\nEquivalently, in pointwise Boolean notation for an indicator function $I_S(x)$ that is $1$ when $x \\in S$ and $0$ otherwise, we have\n$$\nI_M(x) = I_A(x) \\land \\big( \\mathrm{dist}(x,B) \\le d \\big).\n$$\nThe global detection result for a given $A$, $B$, and $d$ is whether $M$ is non-empty, i.e., \n$$\n\\text{exists\\_proximity}(A,B,d) = \\big( M \\ne \\emptyset \\big).\n$$\nThis is the desired Boolean condition.\n\nTo compute this on a discretized grid suitable for numerical implementation, we sample the plane on a uniform lattice with resolution $r$ micrometers per pixel. Let the computational domain be $[0,L] \\times [0,L]$ with $L = 20$ and $r = 0.1$, yielding a grid of $N = L / r$ samples along each axis. We represent $A$ and $B$ as binary masks on this grid, where a pixel is true if and only if its center lies inside the corresponding shape. To realize $\\mathrm{dist}(x,B)$ numerically, we use the Euclidean distance transform of the complement of $B$:\n$$\n\\mathrm{DT}(x) = \\mathrm{dist}_{\\text{grid}}(x,B) \\approx \\mathrm{dist}(x,B),\n$$\nwhich yields, for each pixel center $x$, the Euclidean distance to the nearest pixel that belongs to $B$. In practice, the Euclidean distance transform on a binary array returns distances in pixel units, so we multiply by $r$ to convert to micrometers. The dilation-like test is then implemented by thresholding this distance:\n$$\nI_{\\text{band}}(x) = \\big( \\mathrm{DT}(x) \\le d \\big).\n$$\nThe detection mask is computed pointwise by\n$$\nI_M(x) = I_A(x) \\land I_{\\text{band}}(x),\n$$\nand the global result is\n$$\n\\text{exists\\_proximity}(A,B,d) = \\left( \\sum_x I_M(x) \\ge 1 \\right).\n$$\n\nAlgorithm outline:\n1. Choose grid resolution $r = 0.1$ micrometers per pixel and domain size $L = 20$ micrometers, forming a grid of $N = L/r$ samples per axis. The pixel centers are at coordinates $\\left( (i + \\tfrac{1}{2}) r, (j + \\tfrac{1}{2}) r \\right)$ for integers $i,j$.\n2. Rasterize layer $A$ into a binary mask $A_{\\text{mask}}$ by marking each pixel center inside the specified geometric shape as true.\n3. Rasterize layer $B$ into a binary mask $B_{\\text{mask}}$ similarly.\n4. Compute the Euclidean distance transform on the complement of $B_{\\text{mask}}$, i.e., $\\mathrm{DT} = \\text{distance\\_transform\\_edt}(\\lnot B_{\\text{mask}})$ in pixel units, and convert to micrometers by $\\mathrm{DT}_\\mu = r \\cdot \\mathrm{DT}$.\n5. Threshold the distance map to form the band mask $I_{\\text{band}}$ where $I_{\\text{band}}(x)$ is true if $\\mathrm{DT}_\\mu(x) \\le d$.\n6. Form the detection mask $M_{\\text{mask}} = A_{\\text{mask}} \\land I_{\\text{band}}$ and compute the Boolean result as true if any element is true.\n7. Repeat for each test case with its specified $A$, $B$, and $d$.\n\nEdge cases and boundary conditions:\n- When $d = 0$, the detection reduces to testing whether $A$ and $B$ overlap directly, i.e., $A \\cap B \\ne \\emptyset$.\n- For separations strictly greater than $d$, the detection mask will be empty.\n- Due to discretization, distances are evaluated at pixel centers; using $r = 0.1$ micrometers keeps approximation error small relative to the chosen distances in the test suite.\n\nThe program implements the above algorithm and outputs a single line with the boolean results for the four specified cases in order.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.ndimage import distance_transform_edt\n\ndef rasterize_rectangle(mask_shape, rect, r, L):\n    \"\"\"\n    Rasterize an axis-aligned rectangle into a boolean mask on a grid.\n    mask_shape: (Ny, Nx) tuple for the grid.\n    rect: (x0, y0, x1, y1) in micrometers.\n    r: grid resolution in micrometers per pixel.\n    L: domain size in micrometers (assumed square [0, L] x [0, L]).\n    Returns: boolean array of shape mask_shape with True where the rectangle covers pixel centers.\n    \"\"\"\n    Ny, Nx = mask_shape\n    # Pixel center coordinates\n    xs = (np.arange(Nx) + 0.5) * r\n    ys = (np.arange(Ny) + 0.5) * r\n    X, Y = np.meshgrid(xs, ys)\n\n    x0, y0, x1, y1 = rect\n    # Clamp rectangle to domain to avoid out-of-bounds artifacts\n    x0c = max(0.0, min(L, x0))\n    y0c = max(0.0, min(L, y0))\n    x1c = max(0.0, min(L, x1))\n    y1c = max(0.0, min(L, y1))\n\n    # Mask of pixel centers inside the rectangle (half-open on upper bounds for stability)\n    return (X >= x0c) & (X < x1c) & (Y >= y0c) & (Y < y1c)\n\ndef detect_proximity_boolean(A_mask, B_mask, d_um, r):\n    \"\"\"\n    Compute whether any point in A lies within Euclidean distance d_um of B.\n    A_mask, B_mask: boolean arrays on the same grid (True where layer is present).\n    d_um: distance threshold in micrometers.\n    r: grid resolution (micrometers per pixel).\n    Returns: boolean\n    \"\"\"\n    # Distance transform of complement of B: each pixel gets distance to nearest B pixel\n    dt_pixels = distance_transform_edt(~B_mask)\n    dt_um = dt_pixels * r\n    band = dt_um <= d_um\n    M = A_mask & band\n    return bool(M.any())\n\ndef solve():\n    # Grid and domain parameters\n    L_um = 20.0         # domain size in micrometers\n    r_um = 0.1          # resolution in micrometers per pixel\n    Nx = int(round(L_um / r_um))\n    Ny = Nx\n    mask_shape = (Ny, Nx)\n\n    # Define test cases: (A_rect, B_rect, d_um)\n    test_cases = [\n        # Case 1: A near B, d large enough -> True\n        ((3.0, 3.0, 8.0, 7.0), (10.0, 3.0, 14.0, 7.0), 2.5),\n        # Case 2: d = 0, A overlaps B -> True\n        ((12.0, 4.0, 13.0, 6.0), (10.0, 3.0, 14.0, 7.0), 0.0),\n        # Case 3: A far from B, d too small -> False\n        ((0.0, 0.0, 2.0, 2.0), (10.0, 3.0, 14.0, 7.0), 1.0),\n        # Case 4: Diagonal proximity, d sufficient -> True\n        ((8.0, 7.6, 11.0, 8.0), (10.0, 3.0, 14.0, 7.0), 0.6),\n    ]\n\n    results = []\n    for A_rect, B_rect, d_um in test_cases:\n        A_mask = rasterize_rectangle(mask_shape, A_rect, r_um, L_um)\n        B_mask = rasterize_rectangle(mask_shape, B_rect, r_um, L_um)\n        result = detect_proximity_boolean(A_mask, B_mask, d_um, r_um)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Booleans will print as True/False; join them into a single list string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In dense layouts, design rules often create a web of competing constraints; fixing one spacing violation might inadvertently create an enclosure violation, leading to a \"design rule paradox.\" This advanced practice explores how to systematically manage these interactions using mathematical optimization. You will formulate a layout repair problem as a Linear Program (LP), a method that seeks a globally optimal set of adjustments to satisfy all rules simultaneously. By implementing this strategy , you will learn to not only find a valid repair that minimizes layout perturbation but also to formally determine if a layout is fundamentally unfixable under the given constraints.",
            "id": "4281520",
            "problem": "Consider the task of verifying and repairing interacting mask layout rules for features on a single metal layer and its associated via layer in Electronic Design Automation (EDA). Use the following fundamental bases: Euclidean geometry on the real line, standard inequality constraints, and Linear Programming (LP) feasibility. A mask-layout feature on the first metal layer (denoted as $M1$) is represented as a one-dimensional interval along the $x$-axis with left and right edge coordinates $L_i$ and $R_i$ for feature $i$, respectively, with $i \\in \\{0,1,\\dots,n-1\\}$ and $L_i < R_i$. A corrective operation is a translation along $x$ by a displacement $\\delta_i$, producing new edges $L_i + \\delta_i$ and $R_i + \\delta_i$. Let $S_{\\min}$ denote the minimum spacing requirement between successive features, and let $E_k$ denote the minimum enclosure requirement for via $k$ by its associated $M1$ feature. Each displacement is bounded by a maximum movement budget so that $|\\delta_i| \\le D_i$.\n\nThe minimum spacing rule between ordered pairs $(i,j)$ with $i<j$ is modeled by the inequality\n$$(L_j + \\delta_j) - (R_i + \\delta_i) \\ge S_{\\min}.$$\nThe minimum enclosure rule for via $k$ at coordinate $v_k$ associated with feature $i$ is modeled by both\n$$v_k - (L_i + \\delta_i) \\ge E_k \\quad \\text{and} \\quad (R_i + \\delta_i) - v_k \\ge E_k.$$\nTo penalize total movement and seek a globally consistent repair, introduce auxiliary variables $t_i$ satisfying $t_i \\ge |\\delta_i|$, encoded as\n$$t_i \\ge \\delta_i \\quad \\text{and} \\quad t_i \\ge -\\delta_i,$$\nwith $t_i \\ge 0$. The globally consistent repair strategy is to solve the LP that minimizes $\\sum_{i=0}^{n-1} t_i$ subject to all spacing, enclosure, and movement-bound constraints. If the LP is infeasible, the interacting rules form a paradox where fixing one violation necessarily creates another.\n\nYour program must implement this verification strategy. For each provided test case, compute the minimum possible total absolute movement $\\sum_{i=0}^{n-1} |\\delta_i|$ if a feasible global repair exists, otherwise return $-1.0$. All answers must be reported as floats with no units. There are no angles or percentages in this problem.\n\nUse the following test suite. Each test case specifies the list of $M1$ features $(L_i,R_i)$, the set of spacing-constrained ordered pairs $(i,j)$, the minimum spacing $S_{\\min}$, the set of vias with $(\\text{feature index}, v_k, E_k)$, and the movement bounds $D_i$ for each feature:\n\n- Test Case A (general happy path):\n  - $M1$ features: $(L_0,R_0)=(0.0,2.0)$, $(L_1,R_1)=(2.7,4.7)$, $(L_2,R_2)=(7.5,9.5)$.\n  - Spacing pairs: $(0,1)$, $(1,2)$.\n  - Minimum spacing: $S_{\\min}=1.0$.\n  - Vias: $(1,3.3,0.3)$ meaning via coordinate $v_0=3.3$ with enclosure $E_0=0.3$ by feature $i=1$.\n  - Movement bounds: $D_0=1.0$, $D_1=1.0$, $D_2=1.0$.\n\n- Test Case B (already compliant boundary case):\n  - $M1$ features: $(L_0,R_0)=(0.0,2.0)$, $(L_1,R_1)=(3.0,5.0)$.\n  - Spacing pair: $(0,1)$.\n  - Minimum spacing: $S_{\\min}=1.0$.\n  - Vias: $(1,3.8,0.5)$.\n  - Movement bounds: $D_0=0.5$, $D_1=0.5$.\n\n- Test Case C (paradox due to enclosure blocking spacing fix):\n  - $M1$ features: $(L_0,R_0)=(0.0,2.0)$, $(L_1,R_1)=(2.7,4.7)$, $(L_2,R_2)=(7.5,9.5)$.\n  - Spacing pairs: $(0,1)$, $(1,2)$.\n  - Minimum spacing: $S_{\\min}=1.0$.\n  - Vias: $(1,3.3,0.5)$.\n  - Movement bounds: $D_0=1.0$, $D_1=1.0$, $D_2=1.0$.\n\n- Test Case D (stress-chain interactions, globally feasible with distribution of moves):\n  - $M1$ features: $(L_0,R_0)=(0.0,1.8)$, $(L_1,R_1)=(2.5,4.0)$, $(L_2,R_2)=(4.7,6.0)$, $(L_3,R_3)=(6.6,8.0)$.\n  - Spacing pairs: $(0,1)$, $(1,2)$, $(2,3)$.\n  - Minimum spacing: $S_{\\min}=0.8$.\n  - Vias: $(1,2.9,0.4)$, $(2,5.8,0.05)$, $(3,6.9,0.2)$.\n  - Movement bounds: $D_0=0.4$, $D_1=0.5$, $D_2=0.5$, $D_3=0.5$.\n\nYour program should produce a single line of output containing the results for Test Cases A, B, C, and D, as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD]\"), where each result is a float equal to $\\sum_i |\\delta_i|$ if the LP is feasible, or $-1.0$ if infeasible. No other text should be printed.",
            "solution": "The problem of finding a globally consistent repair for interacting design rules can be formulated and solved as a Linear Program (LP). The goal is to determine a set of displacements $\\{\\delta_i\\}$ for each layout feature that satisfies all spacing, enclosure, and movement constraints, while minimizing the total absolute movement, $\\sum |\\delta_i|$. This is a standard approach in EDA for layout optimization.\n\nThe LP is set up as follows:\n- **Variables**: For each of the $n$ features, we define a displacement variable $\\delta_i$ and an auxiliary variable $t_i$. The vector of optimization variables is $\\mathbf{x} = [\\delta_0, \\dots, \\delta_{n-1}, t_0, \\dots, t_{n-1}]^T$.\n- **Objective Function**: We want to minimize $\\sum |\\delta_i|$. This non-linear objective is linearized by minimizing $\\sum t_i$ subject to the constraints $t_i \\ge |\\delta_i|$.\n- **Constraints**: All rules are converted into linear inequalities.\n    1. **Movement Budget**: Each displacement is bounded: $-D_i \\le \\delta_i \\le D_i$.\n    2. **Linearized Objective**: The absolute value is handled by two inequalities for each feature: $\\delta_i - t_i \\le 0$ and $-\\delta_i - t_i \\le 0$, along with $t_i \\ge 0$.\n    3. **Spacing Rule**: For a pair $(i,j)$, $(L_j + \\delta_j) - (R_i + \\delta_i) \\ge S_{\\min}$ becomes $\\delta_i - \\delta_j \\le L_j - R_i - S_{\\min}$.\n    4. **Enclosure Rule**: For a via on feature $i$, the rules $v_k - (L_i + \\delta_i) \\ge E_k$ and $(R_i + \\delta_i) - v_k \\ge E_k$ become $\\delta_i \\le v_k - L_i - E_k$ and $-\\delta_i \\le R_i - v_k - E_k$, respectively.\n\nThis system is solved using a standard LP solver. If a feasible solution exists, the solver returns the minimal value of $\\sum t_i$. If the constraints are contradictory (a \"design rule paradox\"), the LP is infeasible, and we report -1.0. The following Python code implements this strategy for the given test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_layout_lp(features, spacing_pairs, s_min, vias, movement_bounds):\n    \"\"\"\n    Solves the layout repair LP for a given test case.\n\n    Args:\n        features (list of tuples): List of (L_i, R_i) for each feature.\n        spacing_pairs (list of tuples): List of (i, j) for spacing constraints.\n        s_min (float): Minimum spacing requirement.\n        vias (list of tuples): List of (feature_idx, v_k, E_k) for vias.\n        movement_bounds (list of floats): List of D_i for each feature.\n\n    Returns:\n        float: The minimum total absolute movement, or -1.0 if infeasible.\n    \"\"\"\n    n = len(features)\n    \n    # Variables are [delta_0, ..., delta_{n-1}, t_0, ..., t_{n-1}]\n    # Objective: minimize sum(t_i)\n    c = np.zeros(2 * n)\n    c[n:] = 1.0\n\n    # Initialize lists for inequality constraints A_ub * x <= b_ub\n    A_ub_rows = []\n    b_ub_vals = []\n\n    # 1. Spacing constraints: delta_i - delta_j <= L_j - R_i - S_min\n    for i, j in spacing_pairs:\n        l_j, _ = features[j]\n        _, r_i = features[i]\n        row = np.zeros(2 * n)\n        row[i] = 1.0\n        row[j] = -1.0\n        A_ub_rows.append(row)\n        b_ub_vals.append(l_j - r_i - s_min)\n\n    # 2. Enclosure constraints for vias\n    for feature_idx, v_k, e_k in vias:\n        l_i, r_i = features[feature_idx]\n        \n        # a) delta_i <= v_k - L_i - E_k\n        row_a = np.zeros(2 * n)\n        row_a[feature_idx] = 1.0\n        A_ub_rows.append(row_a)\n        b_ub_vals.append(v_k - l_i - e_k)\n        \n        # b) -delta_i <= R_i - v_k - E_k\n        row_b = np.zeros(2 * n)\n        row_b[feature_idx] = -1.0\n        A_ub_rows.append(row_b)\n        b_ub_vals.append(r_i - v_k - e_k)\n\n    # 3. Auxiliary variable constraints: t_i >= |delta_i|\n    #    a) delta_i - t_i <= 0\n    #    b) -delta_i - t_i <= 0\n    for i in range(n):\n        row_a = np.zeros(2 * n)\n        row_a[i] = 1.0\n        row_a[n + i] = -1.0\n        A_ub_rows.append(row_a)\n        b_ub_vals.append(0.0)\n\n        row_b = np.zeros(2 * n)\n        row_b[i] = -1.0\n        row_b[n + i] = -1.0\n        A_ub_rows.append(row_b)\n        b_ub_vals.append(0.0)\n    \n    A_ub = np.array(A_ub_rows)\n    b_ub = np.array(b_ub_vals)\n\n    # 4. Bounds for variables\n    # -D_i <= delta_i <= D_i\n    # t_i >= 0\n    bounds = []\n    for i in range(n):\n        bounds.append((-movement_bounds[i], movement_bounds[i]))\n    for i in range(n):\n        bounds.append((0, None))\n\n    # Solve the LP\n    # The 'highs' method is recommended for its robustness.\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        return res.fun\n    else:\n        # According to scipy docs, status 2 indicates infeasibility.\n        # res.success is False for infeasible problems.\n        return -1.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"features\": [(0.0, 2.0), (2.7, 4.7), (7.5, 9.5)],\n            \"spacing_pairs\": [(0, 1), (1, 2)],\n            \"s_min\": 1.0,\n            \"vias\": [(1, 3.3, 0.3)],\n            \"movement_bounds\": [1.0, 1.0, 1.0]\n        },\n        # Test Case B\n        {\n            \"features\": [(0.0, 2.0), (3.0, 5.0)],\n            \"spacing_pairs\": [(0, 1)],\n            \"s_min\": 1.0,\n            \"vias\": [(1, 3.8, 0.5)],\n            \"movement_bounds\": [0.5, 0.5]\n        },\n        # Test Case C\n        {\n            \"features\": [(0.0, 2.0), (2.7, 4.7), (7.5, 9.5)],\n            \"spacing_pairs\": [(0, 1), (1, 2)],\n            \"s_min\": 1.0,\n            \"vias\": [(1, 3.3, 0.5)],\n            \"movement_bounds\": [1.0, 1.0, 1.0]\n        },\n        # Test Case D\n        {\n            \"features\": [(0.0, 1.8), (2.5, 4.0), (4.7, 6.0), (6.6, 8.0)],\n            \"spacing_pairs\": [(0, 1), (1, 2), (2, 3)],\n            \"s_min\": 0.8,\n            \"vias\": [(1, 2.9, 0.4), (2, 5.8, 0.05), (3, 6.9, 0.2)],\n            \"movement_bounds\": [0.4, 0.5, 0.5, 0.5]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_layout_lp(\n            case[\"features\"],\n            case[\"spacing_pairs\"],\n            case[\"s_min\"],\n            case[\"vias\"],\n            case[\"movement_bounds\"]\n        )\n        results.append(result)\n\n    # Format output as a list of floats\n    print(f\"[{','.join(map('{:.1f}'.format, results))}]\")\n\nsolve()\n```"
        }
    ]
}