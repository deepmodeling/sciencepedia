{
    "hands_on_practices": [
        {
            "introduction": "数字电路中的总动态功耗主要包括电容充放电功耗和短路功耗。虽然电容充放电所消耗的能量（$C V_{DD}^2$）有明确的公式，但短路功耗的产生与晶体管的瞬态行为密切相关，理解其机理对低功耗设计至关重要。本实践引导您通过构建一个简单的数值仿真模型，直观地“观察”并量化这两个能量分量，从而揭示输入信号的压摆率（slew rate）等因素如何影响它们的相对大小。",
            "id": "4267558",
            "problem": "一个互补金属氧化物半导体（CMOS）反相器由一个单端输入驱动，该输入以受控的线性摆率从逻辑高电平转换到逻辑低电平。该反相器驱动一个纯容性负载。电源电压是一个恒定源。目标是将电源提供的能量分离为一个与负载电容充电相关的能量分量，以及一个在转换期间因上拉和下拉晶体管同时导通而产生的短路导通相关的能量分量。\n\n使用以下基本定义来构建计算：\n- 电源提供的瞬时功率为 $p(t) = i(t) v(t)$。\n- 在一个时间间隔内提供的能量为 $E = \\int_{t_0}^{t_1} p(t)\\, dt$。\n- 电容器的本构关系为 $i_C(t) = C \\frac{d v_C(t)}{dt}$。\n- 对于CMOS反相器中的晶体管对，输出节点的节点电压 $v_{\\text{out}}(t)$ 遵循基尔霍夫电流定律 (KCL)：$C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$，其中 $i_p(t)$ 是从电源流入节点的上拉晶体管电流，$i_n(t)$ 是从节点流向地的下拉晶体管电流。\n\n您必须构建一个单端CMOS反相器的时域模型，该模型能捕捉在下降输入（从 $V_{DD}$ 到 $0$ 的线性斜坡）期间上拉和下拉器件的重叠导通。电源电流定义为 $i_{VDD}(t) = i_p(t)$，电源电压为常数 $v_{VDD}(t) = V_{DD}$。输出节点驱动一个纯电容 $C_L$。\n\n使用带有沟道长度调制的 Shichman–Hodges 强反型分段模型对晶体管电流进行建模。该模型广泛用于手动分析，并且对于本任务可作为一种可接受的数值器件定律近似：\n- 对于下拉（n沟道金属氧化物半导体）晶体管，定义 $V_{GS,n}(t) = v_{\\text{in}}(t)$，$V_{DS,n}(t) = v_{\\text{out}}(t)$，阈值为 $V_{TN}$。如果 $V_{GS,n}(t) \\le V_{TN}$，则 $i_n(t) = 0$。否则，\n  - 如果 $V_{DS,n}(t)  V_{GS,n}(t) - V_{TN}$，则 $i_n(t) = k_n \\left( (V_{GS,n}(t) - V_{TN}) V_{DS,n}(t) - \\tfrac{1}{2} V_{DS,n}(t)^2 \\right) \\left( 1 + \\lambda V_{DS,n}(t) \\right)$。\n  - 否则，$i_n(t) = \\tfrac{1}{2} k_n \\left( V_{GS,n}(t) - V_{TN} \\right)^2 \\left( 1 + \\lambda V_{DS,n}(t) \\right)$。\n- 对于上拉（p沟道金属氧化物半导体）晶体管，定义 $V_{SG,p}(t) = V_{DD} - v_{\\text{in}}(t)$，$V_{SD,p}(t) = V_{DD} - v_{\\text{out}}(t)$，阈值为 $|V_{TP}|$。如果 $V_{SG,p}(t) \\le |V_{TP}|$，则 $i_p(t) = 0$。否则，\n  - 如果 $V_{SD,p}(t)  V_{SG,p}(t) - |V_{TP}|$，则 $i_p(t) = k_p \\left( (V_{SG,p}(t) - |V_{TP}|) V_{SD,p}(t) - \\tfrac{1}{2} V_{SD,p}(t)^2 \\right) \\left( 1 + \\lambda V_{SD,p}(t) \\right)$。\n  - 否则，$i_p(t) = \\tfrac{1}{2} k_p \\left( V_{SG,p}(t) - |V_{TP}| \\right)^2 \\left( 1 + \\lambda V_{SD,p}(t) \\right)$。\n\n输入电压是一个线性下降斜坡 $v_{\\text{in}}(t) = V_{DD} \\max\\left( 1 - \\frac{t}{t_{\\text{slew}}}, 0 \\right)$，并且对于 $t \\ge t_{\\text{slew}}$，$v_{\\text{in}}(t)$ 保持为 $0$。假设反相器初始时驱动输出为低电平，因此 $v_{\\text{out}}(0) = 0$。\n\n任务：\n1. 在一个足够长的时间窗口内对输出节点动态方程 $C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$ 进行数值积分，以使输出在输入转换后能够稳定。在整个仿真过程中，使用上面指定的器件定律模型来计算作为 $v_{\\text{in}}(t)$ 和 $v_{\\text{out}}(t)$ 函数的 $i_p(t)$ 和 $i_n(t)$。\n2. 计算在仿真窗口内由电源提供的总能量，定义为 $E_{\\text{total}} = \\int i_{VDD}(t) v_{VDD}(t)\\, dt$，其中 $i_{VDD}(t) = i_p(t)$ 且 $v_{VDD}(t) = V_{DD}$。\n3. 计算在输出上升期间为负载电容充电所消耗的能量，定义为 $E_{\\text{cap}} = \\int u(t)\\, i_C(t)\\, v_{VDD}(t)\\, dt$，其中 $i_C(t) = C_L \\frac{d v_{\\text{out}}(t)}{dt}$ 且 $u(t)$ 是单位阶跃函数，$i_C(t) \\ge 0$ 时 $u(t) = 1$，$i_C(t)  0$ 时 $u(t) = 0$。此积分仅将正向电容充电归因于电源。注意 $v_{VDD}(t) = V_{DD}$ 是常数。\n4. 将短路能量定义为 $E_{\\text{sc}} = E_{\\text{total}} - E_{\\text{cap}}$。\n\n所有能量以焦耳表示。您的程序必须对每个测试用例执行上述计算，并为每个用例生成 $E_{\\text{sc}}$。\n\n测试套件：\n对五个具有真实、自洽值的测试用例，使用以下参数值集：\n- 用例1（快速输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 10 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 用例2（中等输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 50 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 用例3（慢速输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 200 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 用例4（极慢输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 1.0 \\times 10^{-9}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 用例5（较重负载）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 100 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 50 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n\n答案规格和输出格式：\n- 对于每个测试用例，以浮点数形式计算短路能量 $E_{\\text{sc}}$（单位为焦耳）。\n- 您的程序应生成单行输出，其中包含一个结果列表，格式为方括号内以逗号分隔的列表，顺序与上述用例相同（例如，$\\left[ e_1, e_2, e_3, e_4, e_5 \\right]$）。所有条目都必须以焦耳为单位。",
            "solution": "该问题要求计算CMOS反相器在由高到低输入斜坡触发的从低到高输出转换期间的短路能量耗散 $E_{\\text{sc}}$。这是通过对电路进行时域瞬态仿真，并将从电源获取的总能量分离为用于为负载电容充电和用于短路导通的分量来完成的。\n\n分析的核心在于求解控制输出节点电压 $v_{\\text{out}}(t)$ 的微分方程。该方程由输出节点的基尔霍夫电流定律（KCL）导出：\n$$\nC_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)\n$$\n此处，$C_L$ 是负载电容，$i_p(t)$ 是来自上拉p沟道晶体管的电流，$i_n(t)$ 是由下拉n沟道晶体管吸收的电流。初始条件为 $v_{\\text{out}}(0) = 0\\ \\text{V}$，对应于输入转换开始前的稳定低电平输出。\n\n晶体管电流 $i_p(t)$ 和 $i_n(t)$ 是其端电压的高度非线性函数，而端电压又取决于输入电压 $v_{\\text{in}}(t)$ 和输出电压 $v_{\\text{out}}(t)$。问题指定使用 Shichman–Hodges 模型来计算这些电流。\n\n对于n沟道晶体管（下拉）：\n栅源电压为 $V_{GS,n}(t) = v_{\\text{in}}(t)$，漏源电压为 $V_{DS,n}(t) = v_{\\text{out}}(t)$。如果 $V_{GS,n}(t) \\le V_{TN}$，晶体管处于截止区（$i_n(t) = 0$）。否则，如果 $V_{DS,n}(t)  V_{GS,n}(t) - V_{TN}$，它处于线性区；如果 $V_{DS,n}(t) \\ge V_{GS,n}(t) - V_{TN}$，则处于饱和区。这些区域的电流方程在问题描述中已提供。\n\n对于p沟道晶体管（上拉）：\n源栅电压为 $V_{SG,p}(t) = V_{DD} - v_{\\text{in}}(t)$，源漏电压为 $V_{SD,p}(t) = V_{DD} - v_{\\text{out}}(t)$。如果 $V_{SG,p}(t) \\le |V_{TP}|$，晶体管处于截止区（$i_p(t) = 0$）。否则，如果 $V_{SD,p}(t)  V_{SG,p}(t) - |V_{TP}|$，它处于线性区；如果 $V_{SD,p}(t) \\ge V_{SG,p}(t) - |V_{TP}|$，则处于饱和区。\n\n输入电压 $v_{\\text{in}}(t)$ 是一个在 $t_{\\text{slew}}$ 持续时间内从 $V_{DD}$ 下降到 $0$ 的线性斜坡：\n$$\nv_{\\text{in}}(t) = V_{DD} \\max\\left( 1 - \\frac{t}{t_{\\text{slew}}}, 0 \\right)\n$$\n基于这些定义，KCL方程成为一个关于 $v_{\\text{out}}(t)$ 的一阶非线性常微分方程（ODE）：\n$$\n\\frac{d v_{\\text{out}}(t)}{dt} = \\frac{1}{C_L} \\left( i_p\\left(v_{\\text{in}}(t), v_{\\text{out}}(t)\\right) - i_n\\left(v_{\\text{in}}(t), v_{\\text{out}}(t)\\right) \\right)\n$$\n该ODE使用合适的求解器进行数值求解，例如SciPy库中的 `solve_ivp` 函数。仿真在一个足够长的时间间隔内运行，以使输出稳定到其最终的高电平状态（接近 $V_{DD}$）。这会得到输出电压波形 $v_{\\text{out}}(t)$。\n\n一旦在仿真时间网格上知道了函数 $v_{\\text{in}}(t)$ 和 $v_{\\text{out}}(t)$，就可以在每个时间步长计算随时间变化的电流 $i_p(t)$ 和 $i_n(t)$。由此，通过数值积分（例如，使用梯形法则）计算所需的能量分量。\n\n1.  **来自电源的总能量 ($E_{\\text{total}}$)**：电源电压 $v_{VDD}(t)$ 是一个常数 $V_{DD}$，电源电流是 $i_{VDD}(t) = i_p(t)$。总能量是瞬时功率 $p(t) = v_{VDD}(t) i_{VDD}(t)$ 的时间积分。\n    $$\n    E_{\\text{total}} = \\int_0^{t_{\\text{final}}} V_{DD} i_p(t) \\, dt = V_{DD} \\int_0^{t_{\\text{final}}} i_p(t) \\, dt\n    $$\n\n2.  **电容充电能量 ($E_{\\text{cap}}$)**：问题将此定义为当电容电流为正时，用于为电容充电的那部分电源能量。电容电流为 $i_C(t) = C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$。\n    $$\n    E_{\\text{cap}} = \\int_0^{t_{\\text{final}}} u(t) i_C(t) v_{VDD}(t) \\, dt = V_{DD} \\int_0^{t_{\\text{final}}} \\max(i_p(t) - i_n(t), 0) \\, dt\n    $$\n    其中 $u(t)$ 是一个单位阶跃函数，当 $i_C(t) \\ge 0$ 时为 $1$，否则为 $0$。该积分分离出从电源获取并导致输出电压上升的能量。\n\n3.  **短路能量 ($E_{\\text{sc}}$)**：这是剩余的能量，当两个晶体管同时导通时，电流直接从电源通过它们流向地，这部分能量以热量形式耗散。\n    $$\n    E_{\\text{sc}} = E_{\\text{total}} - E_{\\text{cap}}\n    $$\n该算法通过迭代每个测试用例来进行：设置参数，求解关于 $v_{\\text{out}}(t)$ 的ODE，计算电流的时间序列，执行数值积分以找到 $E_{\\text{total}}$ 和 $E_{\\text{cap}}$，最后计算它们的差值以获得 $E_{\\text{sc}}$。最终结果以焦耳为单位呈现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes the short-circuit energy dissipation in a CMOS inverter for several test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (fast input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 10e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 2 (moderate input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 50e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 3 (slow input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 200e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 4 (very slow input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 1.0e-9, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 5 (heavier load)\n        {\"VDD\": 1.0, \"CL\": 100e-15, \"tslew\": 50e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n    ]\n\n    results = []\n\n    t_sim_end = 4.0e-9\n    num_points = 4001\n    t_eval = np.linspace(0, t_sim_end, num_points)\n\n    for params in test_cases:\n        VDD, CL, tslew, kn, kp, VTN, VTP_mag, lam = (\n            params[\"VDD\"], params[\"CL\"], params[\"tslew\"], params[\"kn\"],\n            params[\"kp\"], params[\"VTN\"], params[\"VTP_mag\"], params[\"lam\"]\n        )\n\n        def get_in(v_in, v_out):\n            Vgs_n = v_in\n            Vds_n = v_out\n            if Vgs_n = VTN:\n                return 0.0\n            \n            Vds_n = max(Vds_n, 0.0)\n            Vov_n = Vgs_n - VTN\n            if Vds_n  Vov_n:  # Linear\n                i_n = kn * (Vov_n * Vds_n - 0.5 * Vds_n**2) * (1 + lam * Vds_n)\n            else:  # Saturation\n                i_n = 0.5 * kn * Vov_n**2 * (1 + lam * Vds_n)\n            return i_n\n\n        def get_ip(v_in, v_out):\n            Vsg_p = VDD - v_in\n            Vsd_p = VDD - v_out\n            if Vsg_p = VTP_mag:\n                return 0.0\n\n            Vsd_p = max(Vsd_p, 0.0)\n            Vov_p = Vsg_p - VTP_mag\n            if Vsd_p  Vov_p:  # Linear\n                i_p = kp * (Vov_p * Vsd_p - 0.5 * Vsd_p**2) * (1 + lam * Vsd_p)\n            else:  # Saturation\n                i_p = 0.5 * kp * Vov_p**2 * (1 + lam * Vsd_p)\n            return i_p\n\n        def get_vin_scalar(t):\n            return VDD * max(1 - t / tslew, 0.0)\n\n        def model(t, y):\n            v_out = y[0]\n            v_in = get_vin_scalar(t)\n            v_out_clipped = np.clip(v_out, 0, VDD)\n            ip = get_ip(v_in, v_out_clipped)\n            in_ = get_in(v_in, v_out_clipped)\n            dv_out_dt = (ip - in_) / CL\n            return [dv_out_dt]\n\n        v_out_initial = [0.0]\n        t_span = (0, t_sim_end)\n\n        sol = solve_ivp(\n            fun=model,\n            t_span=t_span,\n            y0=v_out_initial,\n            method='RK45',\n            t_eval=t_eval,\n            atol=1e-12,\n            rtol=1e-9\n        )\n\n        t_points = sol.t\n        v_out_points = sol.y[0]\n\n        v_in_points = VDD * np.maximum(1 - t_points / tslew, 0)\n        \n        ip_points = np.zeros_like(t_points)\n        in_points = np.zeros_like(t_points)\n        v_out_clipped_points = np.clip(v_out_points, 0, VDD)\n\n        for i in range(len(t_points)):\n            ip_points[i] = get_ip(v_in_points[i], v_out_clipped_points[i])\n            in_points[i] = get_in(v_in_points[i], v_out_clipped_points[i])\n            \n        E_total = VDD * np.trapz(ip_points, t_points)\n\n        i_C_points = ip_points - in_points\n        i_C_charging_points = np.maximum(i_C_points, 0)\n        E_cap = VDD * np.trapz(i_C_charging_points, t_points)\n        \n        E_sc = E_total - E_cap\n        results.append(E_sc)\n\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了功耗的来源之后，电路设计师的核心任务之一便是进行优化。在设计中，速度（低延迟）和能耗之间存在着基本的权衡关系，而能量-延迟乘积（Energy-Delay Product, EDP）是衡量这一综合性能的关键指标。本实践将挑战您通过解析推导，找出能够最小化EDP的最佳电源电压 $V_{DD}$，从而深入理解电压缩放（voltage scaling）这一核心低功耗设计技术的物理原理。",
            "id": "4267560",
            "problem": "一个带负载电容 $C$ 的同步互补金属氧化物半导体（CMOS）逻辑门以时钟频率 $f$ 进行开关，每个周期的平均活动因子为 $\\alpha$。假设在所关注的工作范围内，静态（泄漏）功率与动态功率相比可以忽略不计。对于电容性开关，使用以下经过充分验证的基础：平均动态功率由每次转换每单位时间耗散的能量给出，并且门传播延迟遵循一种alpha-幂律电源定标，该定标源于短沟道金属氧化物半导体场效应晶体管（MOSFET）的漏极电流-电压特性。具体来说，延迟的定标关系为一个正常数比例因子乘以 $V_{DD}$，再除以有效过驱动电压的 $\\beta$ 次方，其中 $V_{th}$ 是阈值电压。假设 $0  \\alpha \\le 1$，$C>0$，$f>0$，$V_{DD}>V_{th}>0$，延迟比例常数 $k>0$，以及指数 $0  \\beta  3$。\n\n从这些基础出发，且不引入任何额外的经验拟合公式：\n- 推导能量-延迟积（EDP）作为 $V_{DD}$ 的函数，用 $\\alpha$、$C$、$k$、$V_{DD}$、$V_{th}$ 和 $\\beta$ 表示。\n- 然后，在所述假设下，确定使 EDP 最小的 $V_{DD}$ 值。\n\n将最终结果表示为最小化电源电压，单位为伏特。在最终的方框答案中不要包含单位。无需四舍五入；请报告精确的解析表达式。",
            "solution": "该问题要求推导CMOS逻辑门的能量-延迟积（EDP），并确定使该乘积最小化的电源电压 $V_{DD}$。\n\n首先，我们验证问题陈述的有效性。\n\n**第1步：提取已知条件**\n- 逻辑门类型：同步互补金属氧化物半导体（CMOS）。\n- 负载电容：$C > 0$。\n- 时钟频率：$f > 0$。\n- 平均活动因子：$\\alpha$，其中 $0  \\alpha \\le 1$。\n- 静态（泄漏）功率可忽略不计。\n- 动态功率模型基础：“平均动态功率由每次转换每单位时间耗散的能量给出”。\n- 门传播延迟模型基础：“alpha-幂律电源定标”。\n- 门传播延迟公式：$T_d = k \\frac{V_{DD}}{(V_{DD} - V_{th})^\\beta}$。\n- 延迟比例常数：$k > 0$。\n- 电源电压：$V_{DD}$。\n- 阈值电压：$V_{th}$。\n- Alpha-幂律指数：$\\beta$，其中 $0  \\beta  3$。\n- 约束条件：$V_{DD} > V_{th} > 0$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据充分：** 该问题基于数字集成电路设计中的标准、成熟的模型。动态功率公式 $P_{dyn} = \\alpha C f V_{DD}^2$ 是CMOS功耗分析的基石。延迟的alpha-幂律是一个广泛使用的半经验模型，它捕捉了短沟道MOSFET中的速度饱和效应。参数及其指定范围在物理上是现实的。\n- **适定性良好：** 该问题在数学上是明确定义的。它提供了推导EDP和执行优化所需的所有必要函数、参数和约束。目标明确，预计可以从变分法中得到一个唯一的、稳定的解。\n- **客观性：** 问题以精确的技术语言陈述，没有主观性或歧义。\n\n**第3步：结论与行动**\n经判定，该问题是有效的。它具有科学合理性、适定性和客观性。我们继续进行求解。\n\n**能量-延迟积（EDP）的推导**\n\nEDP定义为每次操作消耗的能量与该操作的延迟的乘积。\n\n1.  **每次操作的能量（$E$）**\n    平均动态功率 $P_{dyn}$ 是每单位时间耗散的能量。这种耗散发生在从电源电压 $V_{DD}$ 对负载电容 $C$ 充电的过程中。对于一个完整的充电/放电周期，总电荷 $Q = C V_{DD}$ 从电源转移到电容器，然后再到地。在充电阶段从电源获取的能量为 $E_{charge} = Q V_{DD} = (C V_{DD}) V_{DD} = C V_{DD}^2$。这部分能量最终以热量的形式耗散掉，无论是在充电期间于上拉网络中，还是在放电期间于下拉网络中。\n\n    每秒平均的开关事件（充电/放电周期）次数是时钟频率 $f$ 和活动因子 $\\alpha$ 的乘积。\n    因此，平均动态功率为：\n    $$P_{dyn} = (\\text{每次开关的能量}) \\times (\\text{每秒开关次数}) = (C V_{DD}^2) \\times (\\alpha f) = \\alpha C f V_{DD}^2$$\n    每次操作的能量，平均对应于每个时钟周期的能量，是平均功率除以频率：\n    $$E = \\frac{P_{dyn}}{f} = \\frac{\\alpha C f V_{DD}^2}{f} = \\alpha C V_{DD}^2$$\n\n2.  **每次操作的延迟（$T_d$）**\n    问题给出了门传播延迟的模型：\n    $$T_d = k \\frac{V_{DD}}{(V_{DD} - V_{th})^\\beta}$$\n    其中 $k$ 是一个正常数比例因子，$V_{th}$ 是阈值电压，$\\beta$ 是alpha-幂律指数。\n\n3.  **能量-延迟积（$EDP$）**\n    EDP 是能量 $E$ 和延迟 $T_d$ 的乘积：\n    $$EDP(V_{DD}) = E \\times T_d = (\\alpha C V_{DD}^2) \\left( k \\frac{V_{DD}}{(V_{DD} - V_{th})^\\beta} \\right)$$\n    合并各项，EDP 作为 $V_{DD}$ 的函数是：\n    $$EDP(V_{DD}) = \\alpha C k \\frac{V_{DD}^3}{(V_{DD} - V_{th})^\\beta}$$\n    这就完成了任务的第一部分。\n\n**EDP 的最小化**\n\n为了找到使 EDP 最小化的电源电压 $V_{DD}$，我们需要求 $EDP(V_{DD})$ 关于 $V_{DD}$ 的导数，并令其为零。\n$$\\frac{d(EDP)}{dV_{DD}} = 0$$\n项 $\\alpha$、$C$ 和 $k$ 是正常数，因此它们不影响最小值点的位置。我们可以最小化函数 $g(V_{DD}) = \\frac{V_{DD}^3}{(V_{DD} - V_{th})^\\beta}$。\n\n我们使用除法求导法则 $\\frac{d}{dx}\\left(\\frac{u}{v}\\right) = \\frac{u'v - uv'}{v^2}$，其中 $u(V_{DD}) = V_{DD}^3$ 且 $v(V_{DD}) = (V_{DD} - V_{th})^\\beta$。\n导数分别为 $u' = 3V_{DD}^2$ 和 $v' = \\beta(V_{DD} - V_{th})^{\\beta-1}$。\n\n$$\\frac{dg}{dV_{DD}} = \\frac{(3V_{DD}^2)(V_{DD} - V_{th})^\\beta - (V_{DD}^3)(\\beta(V_{DD} - V_{th})^{\\beta-1})}{((V_{DD} - V_{th})^\\beta)^2}$$\n令导数为零需要分子为零，因为当 $V_{DD} > V_{th}$ 时分母不为零。\n$$3V_{DD}^2 (V_{DD} - V_{th})^\\beta - \\beta V_{DD}^3 (V_{DD} - V_{th})^{\\beta-1} = 0$$\n我们可以提取公因式 $V_{DD}^2 (V_{DD} - V_{th})^{\\beta-1}$。由于 $V_{DD} > V_{th} > 0$，该项不为零，可以约去。\n$$V_{DD}^2 (V_{DD} - V_{th})^{\\beta-1} [3(V_{DD} - V_{th}) - \\beta V_{DD}] = 0$$\n这可以简化为方括号内的表达式为零：\n$$3(V_{DD} - V_{th}) - \\beta V_{DD} = 0$$\n现在，我们求解 $V_{DD}$：\n$$3V_{DD} - 3V_{th} - \\beta V_{DD} = 0$$\n$$V_{DD}(3 - \\beta) = 3V_{th}$$\n$$V_{DD,min} = \\frac{3V_{th}}{3 - \\beta}$$\n为了确认这是一个最小值，我们可以检验一阶导数的符号。符号由项 $h(V_{DD}) = 3(V_{DD} - V_{th}) - \\beta V_{DD} = (3-\\beta)V_{DD} - 3V_{th}$ 决定。给定约束条件 $0  \\beta  3$，系数 $(3-\\beta)$ 是正的。因此，当 $V_{DD}  V_{DD,min}$ 时，$h(V_{DD})  0$ 且 EDP 是递减的。当 $V_{DD} > V_{DD,min}$ 时，$h(V_{DD}) > 0$ 且 EDP 是递增的。这证实了 $V_{DD,min}$ 是一个局部最小值。\n\n最后，我们必须检查解是否物理上有效，即 $V_{DD,min} > V_{th}$。\n$$\\frac{3V_{th}}{3 - \\beta} > V_{th}$$\n由于 $V_{th} > 0$，我们可以两边同除以它：\n$$\\frac{3}{3 - \\beta} > 1$$\n由于 $0  \\beta  3$，分母 $(3 - \\beta)$ 是正的，所以我们可以两边同乘以它而不改变不等号的方向：\n$$3 > 3 - \\beta$$\n$$0 > -\\beta$$\n$$\\beta > 0$$\n这个条件在问题陈述中已经给出（$0  \\beta  3$），因此推导出的最优电压确实大于阈值电压，是一个有效的物理解决方案。",
            "answer": "$$\\boxed{\\frac{3 V_{th}}{3 - \\beta}}$$"
        },
        {
            "introduction": "单个逻辑门的行为是基础，但实际电路是由无数相互连接的逻辑门组成的复杂网络。本实践将视角从单个门提升到系统级，旨在解决数字电路网表（netlist）中的功耗估算挑战。它将重点探讨相邻导线间的耦合电容及其对动态功耗的关键影响——即密勒效应（Miller effect），并介绍在动态和统计背景下估算其影响的方法，让您一窥现代电子设计自动化（EDA）工具中所使用的核心算法。",
            "id": "4267551",
            "problem": "给定一个综合后的互补金属氧化物半导体 (CMOS) 数字设计的抽象视图。该设计在网表级别上表示，其中包含来自电子设计自动化 (EDA) 提取的寄生电容和来自单元模型的输入引脚电容。您的任务是构建一个算法，用于计算每个网表的有效电容负载，并由此计算在指定的开关因子和对齐参数下的总动态功耗。要求的输出是包含每个场景的总动态功耗的单行文本。\n\n推导所用的基本原理：电容器中存储的能量以及功率作为单位时间能量的定义。在问题陈述中，避免使用快捷公式或目标公式。必须基于这些基本原理，从第一性原理出发来构建和解决问题。\n\n输入和数据表示：\n- 一组网表 $\\mathcal{N} = \\{N_0, N_1, N_2\\}$。\n- 对于每个网表 $N_i$，一个导线对地电容 $C_{g,i}$（单位：法拉）以及一个作为负载连接的单元输入引脚电容列表 $\\{C_{pin,i,k}\\}$（单位：法拉）。\n- 对于每对耦合的无序网表对 $(N_i, N_j)$（其中 $i \\ne j$），一个耦合电容 $C_{c,ij}$（单位：法拉）。\n- 对于每个网表 $N_i$，一个开关因子 $\\alpha_i$（无量纲小数，单位：每次周期），表示该网表上每个时钟周期内 $0 \\rightarrow 1$ 转换的期望次数，并约束为 $0 \\le \\alpha_i \\le 1$。\n- 对于每对无序网表对 $(N_i, N_j)$，一个攻击者-受害者方向对齐系数 $\\delta_{ij}$，满足 $-1 \\le \\delta_{ij} \\le 1$。其中 $\\delta_{ij} = 1$ 表示强同向同时开关，$\\delta_{ij} = -1$ 表示强反向同时开关，而 $\\delta_{ij} = 0$ 表示方向不相关。\n- 该系数用于根据转换的相对方向，以物理上合理的方式，对开关期间的期望耦合贡献进行偏置。\n- 一个电源电压 $V_{dd}$（单位：伏特）和一个时钟频率 $f$（单位：赫兹）。\n\n不使用快捷公式的高级算法要求：\n1. 从电容器中的能量定义以及关于电荷和电势差的物理推理出发，推导出如何将对地电容、引脚电容和耦合电容聚合成一个有效负载 $C_{eff,i}$，这是网表 $N_i$ 的驱动单元在开关时必须充电和放电的负载。\n2. 展示每个相邻网表的耦合贡献如何依赖于由 $\\alpha_j$ 和 $\\delta_{ij}$ 编码的网表间转换的统计对齐，从而得出 $C_{c,ij}$ 对 $C_{eff,i}$ 的期望有效贡献。\n3. 使用从开关因子和时钟频率派生出的每次转换能量和每秒转换次数，求得所有网表的总动态功耗。\n\n单位和输出规范：\n- 所有电容均以法拉为单位，在数据规范中为了可读性，可方便地表示为飞法。\n- 电源电压 $V_{dd}$ 单位为伏特。\n- 时钟频率 $f$ 单位为赫兹。\n- 最终答案必须以瓦特为单位，表示为浮点数。没有舍入要求，但根据标准的双精度浮点运算，数值必须是精确的。\n- 本问题不使用角度和三角函数。\n- 您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，例如 `[r_1,r_2,r_3]`，其中每个 $r_k$ 是测试用例 $k$ 的总动态功耗（单位：瓦特）。\n\n设计数据（所有场景中固定）：\n- 网表和对地电容：\n  - $N_0$：$C_{g,0} = 120 \\times 10^{-15}$。\n  - $N_1$：$C_{g,1} = 80 \\times 10^{-15}$。\n  - $N_2$：$C_{g,2} = 150 \\times 10^{-15}$。\n- 连接到每个网表的单元输入引脚电容：\n  - $N_0$：$\\{3 \\times 10^{-15}, 2 \\times 10^{-15}\\}$。\n  - $N_1$：$\\{4 \\times 10^{-15}\\}$。\n  - $N_2$：$\\{2 \\times 10^{-15}, 2 \\times 10^{-15}, 3 \\times 10^{-15}\\}$。\n- 网表之间的耦合电容（无序对）：\n  - $(N_0, N_1)$：$C_{c,01} = 30 \\times 10^{-15}$。\n  - $(N_0, N_2)$：$C_{c,02} = 20 \\times 10^{-15}$。\n  - $(N_1, N_2)$：$C_{c,12} = 25 \\times 10^{-15}$。\n\n测试套件：\n- 场景 1（正常路径）：\n  - 电源和时钟：$V_{dd} = 0.9$, $f = 5.0 \\times 10^{8}$。\n  - 开关因子：$\\alpha_0 = 0.2$, $\\alpha_1 = 0.35$, $\\alpha_2 = 0.1$。\n  - 对齐系数：$\\delta_{01} = -0.6$, $\\delta_{02} = 0.2$, $\\delta_{12} = 0.0$。\n- 场景 2（边缘情况：一个网表不开关）：\n  - 电源和时钟：$V_{dd} = 1.0$, $f = 2.0 \\times 10^{8}$。\n  - 开关因子：$\\alpha_0 = 0.4$, $\\alpha_1 = 0.15$, $\\alpha_2 = 0.0$。\n  - 对齐系数：$\\delta_{01} = 1.0$, $\\delta_{02} = -1.0$, $\\delta_{12} = -1.0$。\n- 场景 3（边界情况：零频率）：\n  - 电源和时钟：$V_{dd} = 0.8$, $f = 0.0$。\n  - 开关因子：$\\alpha_0 = 0.5$, $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$。\n  - 对齐系数：$\\delta_{01} = 0.0$, $\\delta_{02} = 0.0$, $\\delta_{12} = 0.0$。\n- 场景 4（边界情况：全速率开关下的最大反向对齐）：\n  - 电源和时钟：$V_{dd} = 1.1$, $f = 3.0 \\times 10^{8}$。\n  - 开关因子：$\\alpha_0 = 1.0$, $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$。\n  - 对齐系数：$\\delta_{01} = -1.0$, $\\delta_{02} = -1.0$, $\\delta_{12} = -1.0$。\n\n程序要求：\n- 实现一个算法，在每个场景中，使用对地电容、由 $N_i$ 驱动的引脚电容总和，以及从 $\\alpha_j$ 和 $\\delta_{ij}$ 派生的每个相邻网表的期望耦合贡献，来聚合每个网表 $N_i$ 的有效电容 $C_{eff,i}$。\n- 根据物理推导的能量和事件率关系，计算所有网表的总动态功耗（单位：瓦特）。\n- 生成单行输出，其中包含场景 1 到 4 的总功耗，按所列顺序排列，格式为 `[r_1,r_2,r_3,r_4]`，不含空格。",
            "solution": "该问题是有效的。它在科学上基于电气工程的原理，特别是与CMOS数字电路中的功耗相关。问题定义良好，有足够的信息来推导出唯一解。参数及其数值在物理上是现实的。\n\n求解过程首先按照要求从基本原理推导出总动态功耗的公式，然后将此公式应用于所提供的测试场景。\n\n### 步骤 1：从第一性原理推导动态功耗\n\nCMOS数字电路消耗的动态功耗是在对网表的寄生电容进行充电和放电过程中耗散的功率。我们从电容器的能量出发，推导这个功率的表达式。\n\n一个电容为 $C$ 的电容器，其两端板间电压差为 $V$ 时，存储的能量 $E$ 由以下公式给出：\n$$E = \\frac{1}{2} C V^2$$\n\n在标准的轨到轨CMOS逻辑电路中，一个网表的电压 $V_{net}$ 在地（$0$）和电源电压（$V_{dd}$）之间切换。考虑单个网表 $N_i$，其驱动单元必须对其总有效电容 $C_{eff,i}$ 进行充电或放电。\n\n在 $0 \\to V_{dd}$ 的转换（充电）过程中，驱动单元的上拉网络将网表连接到电源 $V_{dd}$。从电源中总共抽取了电荷 $Q_i = C_{eff,i} V_{dd}$。从电源中抽取的能量是：\n$$E_{supply,i} = Q_i V_{dd} = (C_{eff,i} V_{dd}) V_{dd} = C_{eff,i} V_{dd}^2$$\n这些能量中，一半存储在电容器中（$\\frac{1}{2} C_{eff,i} V_{dd}^2$），另一半则在上拉网络的电阻元件中以热量形式耗散。\n\n在随后的 $V_{dd} \\to 0$ 转换（放电）过程中，驱动单元的下拉网络将网表连接到地。存储在电容器中的能量 $\\frac{1}{2} C_{eff,i} V_{dd}^2$ 在下拉网络中以热量形式耗散。在此阶段，电源断开，不提供能量。\n\n因此，对于一个完整的充放电周期（$0 \\to V_{dd} \\to 0$），从电源抽取的总能量为 $C_{eff,i} V_{dd}^2$。\n\n功率定义为单位时间的能量（$P = dE/dt$）。平均动态功耗是单位时间内消耗的总能量。问题将开关因子 $\\alpha_i$ 定义为网表 $N_i$ 上每个时钟周期的平均 $0 \\to 1$ 转换次数。给定一个时钟频率 $f$（单位：周期/秒，或赫兹），网表 $N_i$ 的充电事件速率为 $\\alpha_i f$。\n\n网表 $N_i$ 的动态功耗 $P_{dyn,i}$ 是每次充电事件的能量乘以这些事件的速率：\n$$P_{dyn,i} = E_{supply,i} \\times (\\alpha_i f) = (C_{eff,i} V_{dd}^2) (\\alpha_i f) = \\alpha_i f C_{eff,i} V_{dd}^2$$\n\n系统的总动态功耗是所有网表消耗功率的总和：\n$$P_{dyn,total} = \\sum_{i \\in \\mathcal{N}} P_{dyn,i} = \\sum_{i \\in \\mathcal{N}} \\alpha_i f C_{eff,i} V_{dd}^2 = f V_{dd}^2 \\sum_{i \\in \\mathcal{N}} \\alpha_i C_{eff,i}$$\n\n### 步骤 2：有效电容 ($C_{eff,i}$) 的推导\n\n有效电容 $C_{eff,i}$ 是网表 $N_i$ 的驱动单元在 $0 \\to V_{dd}$ 转换期间必须充电的总电容。它是由对地电容和耦合电容贡献的总和。\n\n1.  **对地电容**：这些包括导线的对地电容 $C_{g,i}$ 和由网表 $N_i$ 驱动的单元的输入引脚电容 $\\{C_{pin,i,k}\\}$。这些电容都连接在网表和地（或一个稳定参考电位）之间。它们的贡献是一个简单的加和：\n    $$C_{gnd,i} = C_{g,i} + \\sum_k C_{pin,i,k}$$\n\n2.  **耦合电容**：一个耦合电容 $C_{c,ij}$ 将网表 $N_i$（受害者）连接到一个相邻的网表 $N_j$（攻击者）。$N_i$ 的驱动单元为 $C_{c,ij}$ 充电所需的电荷量取决于网表 $N_j$ 上的同时电压变化。$N_i$ 的驱动单元必须向连接到它的电容器板提供的电荷变化量 $\\Delta Q_{ij}$ 由下式给出：\n    $$\\Delta Q_{ij} = C_{c,ij} \\Delta(V_i - V_j) = C_{c,ij} (\\Delta V_i - \\Delta V_j)$$\n    对于网表 $N_i$ 上的 $0 \\to V_{dd}$ 转换，$\\Delta V_i = V_{dd}$。方程变为：\n    $$\\Delta Q_{ij} = C_{c,ij} (V_{dd} - \\Delta V_j)$$\n    这里，$\\Delta V_j$ 是在 $N_i$ 转换期间网表 $N_j$ 上的电压摆幅。由于转换是统计性的，我们必须考虑在网表 $N_i$ 向上转换的条件下 $\\Delta V_j$ 的期望值：$E[\\Delta V_j | i \\uparrow]$。\n    期望电荷为 $E[\\Delta Q_{ij}] = C_{c,ij} (V_{dd} - E[\\Delta V_j | i \\uparrow])$。\n\n    问题提供了参数 $\\alpha_j$（攻击者 $N_j$ 的活动因子）和 $\\delta_{ij}$（方向对齐）来模拟这种效应。我们可以定义一个有效米勒因子 $k_{ij} = E[\\Delta V_j | i \\uparrow] / V_{dd}$。与参数定义一致的、一个简单的、物理上合理的该因子线性模型是：\n    $$k_{ij} = \\delta_{ij} \\alpha_j$$\n    该模型正确地反映了效应与攻击者的活动（$\\alpha_j$）成正比，并受到方向相关性（$\\delta_{ij}$）的偏置。例如，如果 $N_j$ 是静态的（$\\alpha_j=0$），则 $k_{ij}=0$。如果开关不相关（$\\delta_{ij}=0$），则 $k_{ij}=0$。对于全速率活动（$\\alpha_j=1$）的完全反相关开关（$\\delta_{ij}=-1$），$k_{ij}=-1$，这会使电荷需求最大化。\n\n    现在，期望电荷可以根据有效电容贡献来表示。电荷为 $C_{c,ij}(1 - k_{ij})V_{dd}$，因此 $C_{c,ij}$ 的有效电容贡献为 $C_{c,ij}(1 - k_{ij})$。\n    $$C_{c,ij,eff} = C_{c,ij} (1 - \\delta_{ij}\\alpha_j)$$\n    注意，在计算 $C_{eff,i}$ 时，相邻网表是 $N_j$，所以我们使用 $\\alpha_j$ 和 $\\delta_{ij}$。问题陈述给出了无序对的 $\\delta_{ij}$，这意味着 $\\delta_{ij} = \\delta_{ji}$。\n\n3.  **总有效电容**：将对地电容贡献和有效耦合电容贡献相加，我们得到网表 $N_i$ 的总有效电容：\n    $$C_{eff,i} = \\left(C_{g,i} + \\sum_k C_{pin,i,k}\\right) + \\sum_{j \\ne i, j \\in \\mathcal{N}} C_{c,ij} (1 - \\delta_{ij}\\alpha_j)$$\n\n### 总动态功耗的最终公式\n\n通过将 $C_{eff,i}$ 的表达式代入功率公式，我们得到总动态功耗的完整方程：\n$$P_{dyn,total} = f V_{dd}^2 \\sum_{i \\in \\mathcal{N}} \\alpha_i \\left[ \\left(C_{g,i} + \\sum_k C_{pin,i,k}\\right) + \\sum_{j \\ne i, j \\in \\mathcal{N}} C_{c,ij} (1 - \\delta_{ij}\\alpha_j) \\right]$$\n\n此公式将被实现，以解决每个给定测试场景中的总动态功耗问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used from scipy or other external packages.\n\ndef solve():\n    \"\"\"\n    Computes the total dynamic power for a CMOS digital design across multiple scenarios.\n    \"\"\"\n    \n    # Design data (fixed across all scenarios)\n    # All capacitances are in Farads (F).\n    C_g = {\n        0: 120e-15,  # C_g,0 for Net N_0\n        1: 80e-15,   # C_g,1 for Net N_1\n        2: 150e-15,  # C_g,2 for Net N_2\n    }\n    \n    C_pin = {\n        0: [3e-15, 2e-15],        # Pin loads on Net N_0\n        1: [4e-15],               # Pin loads on Net N_1\n        2: [2e-15, 2e-15, 3e-15], # Pin loads on Net N_2\n    }\n    \n    # Sum of pin capacitances per net for convenience\n    C_pin_sum = {net: sum(caps) for net, caps in C_pin.items()}\n    \n    C_c = {\n        (0, 1): 30e-15, # Coupling between N_0 and N_1\n        (0, 2): 20e-15, # Coupling between N_0 and N_2\n        (1, 2): 25e-15, # Coupling between N_1 and N_2\n    }\n    # Symmetrize the coupling capacitance matrix for easier lookup\n    C_c.update({(j, i): val for (i, j), val in C_c.items()})\n\n    nets = [0, 1, 2]\n    \n    # Test suite with multiple scenarios\n    test_cases = [\n        { # Scenario 1\n            \"V_dd\": 0.9,\n            \"f\": 5.0e8,\n            \"alpha\": {0: 0.2, 1: 0.35, 2: 0.1},\n            \"delta\": {(0, 1): -0.6, (0, 2): 0.2, (1, 2): 0.0},\n        },\n        { # Scenario 2\n            \"V_dd\": 1.0,\n            \"f\": 2.0e8,\n            \"alpha\": {0: 0.4, 1: 0.15, 2: 0.0},\n            \"delta\": {(0, 1): 1.0, (0, 2): -1.0, (1, 2): -1.0},\n        },\n        { # Scenario 3\n            \"V_dd\": 0.8,\n            \"f\": 0.0,\n            \"alpha\": {0: 0.5, 1: 0.5, 2: 0.5},\n            \"delta\": {(0, 1): 0.0, (0, 2): 0.0, (1, 2): 0.0},\n        },\n        { # Scenario 4\n            \"V_dd\": 1.1,\n            \"f\": 3.0e8,\n            \"alpha\": {0: 1.0, 1: 1.0, 2: 1.0},\n            \"delta\": {(0, 1): -1.0, (0, 2): -1.0, (1, 2): -1.0},\n        },\n    ]\n\n    total_power_results = []\n\n    for case in test_cases:\n        V_dd = case[\"V_dd\"]\n        f = case[\"f\"]\n        alpha = case[\"alpha\"]\n        delta = case[\"delta\"]\n        # Symmetrize delta for easier lookup\n        delta.update({(j, i): val for (i, j), val in delta.items()})\n\n        total_power = 0.0\n\n        if f == 0.0:\n            total_power_results.append(0.0)\n            continue\n        \n        # Calculate power contribution from each net\n        for i in nets:\n            # Power on net i is zero if it doesn't switch\n            if alpha[i] == 0.0:\n                continue\n\n            # 1. Sum of grounded capacitances\n            C_grounded_i = C_g[i] + C_pin_sum[i]\n\n            # 2. Sum of effective coupling capacitances\n            C_coupling_eff_i = 0.0\n            for j in nets:\n                if i == j:\n                    continue\n                \n                # Miller factor k_ij = delta_ij * alpha_j\n                # Effective coupling cap = C_c,ij * (1 - k_ij)\n                k_ij = delta[(i, j)] * alpha[j]\n                C_coupling_eff_i += C_c[(i, j)] * (1.0 - k_ij)\n            \n            # 3. Total effective capacitance for net i\n            C_eff_i = C_grounded_i + C_coupling_eff_i\n\n            # 4. Dynamic power for net i\n            P_dyn_i = alpha[i] * f * C_eff_i * (V_dd ** 2)\n            \n            total_power += P_dyn_i\n            \n        total_power_results.append(total_power)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, total_power_results))}]\")\n\nsolve()\n```"
        }
    ]
}