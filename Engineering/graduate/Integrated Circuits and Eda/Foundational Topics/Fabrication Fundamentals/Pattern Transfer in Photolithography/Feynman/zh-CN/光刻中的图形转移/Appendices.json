{
    "hands_on_practices": [
        {
            "introduction": "图形转移的保真度始于光学成像。在部分相coherent光照明下，孤立图形和密集图形具有不同的光学邻近环境，导致其成像结果存在显著差异。亚分辨率辅助图形（SRAF）是一种有效的光学邻近效应矫正（OPC）技术，通过在主图形旁放置无法被分辨的辅助图形，可以使孤立图形的成像环境模拟密集图形，从而增大工艺窗口。这项实践练习  将引导您通过一个简化的光学模型，动手优化SRAF的位置与尺寸，直观地理解计算光刻技术如何主动补偿光学效应，以确保图形转移的准确性。",
            "id": "4288223",
            "problem": "在部分相干照明下，二元光学掩模上的一条孤立线所呈现的光学成像环境，通常与嵌入在密集周期性图形中的线条不同。可以在孤立线附近添加亚分辨率辅助图形 (SRAF)，以调整其光学成像环境。考虑与部分相干成像的 Hopkins 模型一致的一维标量成像。使用以下基本设定：光瞳截止空间频率为 $f_{\\mathrm{c}} = \\mathrm{NA}/\\lambda$，部分相干光源被建模为点光源的一维均匀分布，每个点光源的空间频率偏移为 $k_{\\mathrm{s}} \\in [-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$，而部分相干光学图像是来自每个光源点的相干图像的非相干平均值。对于单个光源点，相干图像振幅是光瞳函数与偏移了 $k_{\\mathrm{s}}$ 的物体频谱之乘积的傅里叶逆变换，其中实空间中的空间调制 $\\exp\\left(i 2\\pi k_{\\mathrm{s}} x\\right)$ 实现了频谱的偏移。\n\n将掩模透过率 $t(x)$ 建模为一维的二值函数。对于密集图形，构建一个周期性的线条-间距掩模，其线宽为 $W$，周期为 $P$，并以一条线位于 $x=0$ 的方式居中。对于带有SRAF的孤立图形，构建一条位于 $x=0$ 中心的宽度为 $W$ 的孤立主线条，以及两条宽度为 $w$ 的相同SRAF线条，对称放置于中心位置 $x = \\pm \\left(\\frac{W}{2} + d + \\frac{w}{2}\\right)$，其中 $d$ 是主线条边缘与最近的SRAF边缘之间的间隙。使用一个标量成像模型，其一维实值光瞳函数由 $P(f) = 1$（当 $|f| \\le f_{\\mathrm{c}}$）和 $P(f) = 0$（其他情况）给出。对于每个光源点 $k_{\\mathrm{s}}$，形成调制后的物场 $u(x) = t(x)\\exp\\left(i 2\\pi k_{\\mathrm{s}} x\\right)$，对其进行傅里叶变换得到 $U(f)$，应用光瞳函数 $U(f)P(f)$，然后进行逆变换得到相干振幅 $a_{k_{\\mathrm{s}}}(x)$。对于 $N_{\\mathrms}}$ 个均匀间隔的光源样本，部分相干光学图像为 $I(x) = \\frac{1}{N_{\\mathrm{s}}}\\sum_{k_{\\mathrm{s}}} \\left|a_{k_{\\mathrm{s}}}(x)\\right|^{2}$。\n\n将环境等效性目标函数定义为，在关于 $x=0$ 的对称窗口 $[-L_{\\mathrm{w}}, L_{\\mathrm{w}}]$ 内，带有SRAF的孤立图形掩模与密集图形掩模的归一化光学图像之间的均方差。其中，归一化操作是将每个图像除以其在窗口内的最大值。通过要求每个SRAF中心的归一化强度严格小于阈值 $I_{\\mathrm{th}}$ 来施加非打印约束；否则，向目标函数中添加一个巨大的惩罚项。在候选SRAF宽度 $w$ 和偏移量 $d$ 的离散网格上进行搜索，并选择使带惩罚项的目标函数最小化的参数对 $(d^{\\star}, w^{\\star})$。\n\n使用以下符合科学实际的参数和单位，并将所有掩模尺寸和输出以纳米（nm）表示。不使用角度。计算空间采样步长必须为 $dx = \\,$$1$ nm，域长度必须为 $N \\cdot dx$，其中 $N = \\,$$2048$ 个样本。光瞳截止频率的单位是周/纳米。使用 $N_{\\mathrms}} = \\,$$11$ 个均匀间隔的光源样本，范围覆盖 $[-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$。如果违反非打印约束，则向目标函数添加 $J_{\\mathrm{pen}} = \\,$$1000$ 的惩罚值。密集掩模具有周期 $P$，并在整个计算域上实现。孤立掩模仅包含主线条和两条SRAF线条。\n\n测试套件：\n- 案例 1：波长 $\\lambda = \\,$$193$ nm，数值孔径 (NA) $\\mathrm{NA} = \\,$$0.85$，部分相干性 $\\sigma = \\,$$0.30$，主线条宽度 $W = \\,$$90$ nm，密集周期 $P = \\,$$220$ nm，窗口半宽 $L_{\\mathrm{w}} = \\,$$400$ nm，候选SRAF宽度 $w \\in \\{12, 16, 20, 24, 28\\}$ nm，候选SRAF偏移量 $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm，非打印阈值 $I_{\\mathrm{th}} = \\,$$0.35$。\n- 案例 2：$\\lambda = \\,$$193$ nm, $\\mathrm{NA} = \\,$$0.85$, $\\sigma = \\,$$0.60$, $W = \\,$$90$ nm, $P = \\,$$220$ nm, $L_{\\mathrm{w}} = \\,$$400$ nm, $w \\in \\{12, 16, 20, 24, 28\\}$ nm, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm, $I_{\\mathrm{th}} = \\,$$0.35$。\n- 案例 3：$\\lambda = \\,$$193$ nm, $\\mathrm{NA} = \\,$$0.85$, $\\sigma = \\,$$0.20$, $W = \\,$$70$ nm, $P = \\,$$200$ nm, $L_{\\mathrm{w}} = \\,$$400$ nm, $w \\in \\{12, 16, 20, 24, 28\\}$ nm, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm, $I_{\\mathrm{th}} = \\,$$0.35$。\n- 案例 4：$\\lambda = \\,$$193$ nm, $\\mathrm{NA} = \\,$$0.85$, $\\sigma = \\,$$0.80$, $W = \\,$$100$ nm, $P = \\,$$240$ nm, $L_{\\mathrm{w}} = \\,$$400$ nm, $w \\in \\{12, 16, 20, 24, 28\\}$ nm, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm, $I_{\\mathrm{th}} = \\,$$0.35$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。每个结果是对应测试案例的一个二元列表 $[d^{\\star}, w^{\\star}]$，以纳米为单位的浮点数表示。例如，输出格式为 $[[d_1,w_1],[d_2,w_2],[d_3,w_3],[d_4,w_4]]$，无任何附加文本。\n\n所有计算必须遵循指定的模型和单位。在输出之前，将报告的每个 $d^{\\star}$ 和 $w^{\\star}$ 四舍五入到一位小数。",
            "solution": "问题陈述经评估是有效的。其科学基础是傅里叶光学和部分相干成像的原理，特别是 Hopkins 模型，这是光刻模拟中的一个标准模型。该问题是适定的，提供了清晰的目标函数、明确的搜索空间以及所有必要的物理和计算参数。术语精确，设定自洽且无矛盾。给定的参数对于现代半导体制造工艺是符合实际的。\n\n解决方案首先构建一维标量成像系统的计算模型。这包括定义空间域和频率域、光学光瞳以及部分相干光源。随后，我们模拟两种类型掩模的光学图像：一种是参考的密集图形，另一种是增加了亚分辨率辅助图形（SRAF）的孤立图形。目标是找到SRAF的几何形状（宽度 $w$ 和位置 $d$），使得孤立线条的光学图像与密集线条的光学图像最为匹配，同时满足SRAF本身不被打印出来的约束条件。\n\n解决方案的核心是计算部分相干光学图像 $I(x)$，该计算基于 Hopkins 模型。光源被离散化为 $N_{\\mathrms}}$ 个点光源，每个点光源由其空间频率偏移 $k_{\\mathrms}}$ 索引。对每个光源点进行相干成像计算，最终的部分相干图像是所有光源点产生的强度之和。\n\n程序如下：\n\n1.  **系统设置**：\n    建立一个以坐标 $x$ 表示的一维空间域，包含 $N = 2048$ 个样本，步长为 $dx = 1$ nm。其范围从 $-1024$ nm 到 $1023$ nm。相应的频率域（坐标为 $f$）是利用离散傅里叶变换的性质确定的。光瞳截止频率计算为 $f_{\\mathrmc}} = \\mathrm{NA}/\\lambda$。光瞳函数 $P(f)$ 被定义为一个二值滤波器，当 $|f| \\le f_{\\mathrmc}}$ 时为 $1$，否则为 $0$。部分相干光源被建模为在频率范围 $[-\\sigma f_{\\mathrmc}}, \\sigma f_{\\mathrmc}}]$ 内均匀分布的 $N_{\\mathrms}} = 11$ 个离散点光源。\n\n2.  **掩模透过率函数**：\n    掩模图形由二值透过率函数 $t(x)$ 表示，其中 $t(x)=1$代表透光区域（清晰），$t(x)=0$ 代表不透光区域。\n    -   **密集掩模** ($t_{\\mathrm{dense}}(x)$): 在整个计算域上创建一个周期为 $P$、线宽为 $W$ 的周期性线条-间距图形。一条线位于 $x=0$ 的中心。\n    -   **带SRAF的孤立掩模** ($t_{\\mathrm{iso}}(x)$): 对于来自候选网格的每一对SRAF参数 $(d, w)$，都会构建一个掩模。它由一个宽度为 $W$ 的中心主图形和两个宽度为 $w$ 的SRAF组成。SRAF围绕原点对称放置，中心位置为 $x_{\\mathrm{sraf}} = \\pm \\left(\\frac{W}{2} + d + \\frac{w}{2}\\right)$。\n\n3.  **光学图像计算**：\n    实现一个函数来计算给定掩模透过率 $t(x)$ 的光学图像 $I(x)$。\n    - 该过程遍历每个光源点 $k_{\\mathrms}}$。\n    - 对于每个 $k_{\\mathrms}}$，物场由离轴照明相位因子进行调制：$u_{k_{\\mathrms}}}(x) = t(x) \\exp(i 2\\pi k_{\\mathrms}} x)$。\n    - 计算此调制场的傅里叶变换 $U_{k_{\\mathrms}}}(f) = \\mathcal{F}\\{u_{k_{\\mathrms}}}(x)\\}$。这等效于将物体频谱 $\\mathcal{F}\\{t(x)\\}$ 偏移 $k_{\\mathrms}}$。\n    - 然后用光瞳函数对频谱进行滤波：$U_{\\mathrm{filtered}}(f) = U_{k_{\\mathrms}}}(f) \\cdot P(f)$。\n    - 对滤波后的频谱进行傅里叶逆变换，得到相干图像振幅：$a_{k_{\\mathrms}}}(x) = \\mathcal{F}^{-1}\\{U_{\\mathrm{filtered}}(f)\\}$。\n    - 将来自此光源点的强度 $|a_{k_{\\mathrms}}}(x)|^2$ 添加到一个运行总和中。\n    - 在对所有光源点的贡献求和后，对总强度进行平均：$I(x) = \\frac{1}{N_{\\mathrms}}} \\sum_{k_{\\mathrms}}} |a_{k_{\\mathrms}}}(x)|^2$。\n    使用快速傅里叶变换（FFT）算法进行数值计算，并配合适当的移位操作（`fftshift`，`ifftshift`）来处理中心化的坐标系。\n\n4.  **通过网格搜索进行优化**：\n    通过在给定的 $(d, w)$ 值的离散网格上最小化一个带惩罚项的目标函数，来确定最优的SRAF参数 ($d^{\\star}, w^{\\star}$)。\n    - 首先，计算密集图形的光学图像 $I_{\\mathrm{dense}}(x)$，并将其作为目标。\n    - 优化循环遍历每个候选参数对 $(d, w)$。\n    - 对于每对参数，生成相应的带SRAF的孤立掩模 $t_{\\mathrm{iso}}(x)$，并计算其光学图像 $I_{\\mathrm{iso}}(x)$。\n    - 将 $I_{\\mathrm{dense}}(x)$ 和 $I_{\\mathrm{iso}}(x)$ 分别除以它们在评估窗口 $[-L_{\\mathrm{w}}, L_{\\mathrm{w}}]$ 内各自的最大值来进行归一化。将归一化后的图像表示为 $I_{\\mathrm{dense,norm}}(x)$ 和 $I_{\\mathrm{iso,norm}}(x)$。\n    - **非打印约束**：在SRAF中心处评估的归一化强度 $I_{\\mathrm{iso,norm}}(x_{\\mathrm{sraf}})$ 必须小于阈值 $I_{\\mathrm{th}} = 0.35$。\n    - **目标函数**：主要目标是窗口内两个归一化图像之间的均方误差（MSE）：\n      $$ \\text{MSE} = \\frac{1}{M} \\sum_{x_j \\in [-L_{\\mathrm{w}}, L_{\\mathrm{w}}]} \\left( I_{\\mathrm{iso,norm}}(x_j) - I_{\\mathrm{dense,norm}}(x_j) \\right)^2 $$\n      其中 $M$ 是窗口内的样本点数。\n    - 如果违反非打印约束，则向MSE中添加一个巨大的惩罚值 $J_{\\mathrm{pen}} = 1000$。\n    - 产生最小惩罚目标函数的参数对 $(d, w)$ 被选为给定测试案例的最优解 $(d^{\\star}, w^{\\star})$。\n\n对指定的四个测试案例中的每一个重复此过程，并将得到的最优参数对收集起来并格式化以供最终输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef calculate_aerial_image(t, x, f_shifted, pupil, ks_list):\n    \"\"\"\n    Calculates the partially coherent aerial image using the Hopkins model.\n    \"\"\"\n    N = len(x)\n    total_intensity = np.zeros(N, dtype=np.float64)\n\n    for ks in ks_list:\n        # 1. Modulate object field by the source\n        illumination_phase = np.exp(1j * 2 * np.pi * ks * x)\n        u_ks = t * illumination_phase\n\n        # 2. Compute object spectrum (FFT)\n        # Use ifftshift before FFT for centered spatial input\n        U_ks = fft.fftshift(fft.fft(fft.ifftshift(u_ks)))\n\n        # 3. Apply pupil filter\n        U_filtered = U_ks * pupil\n\n        # 4. Compute coherent image amplitude (IFFT)\n        # Use ifftshift before IFFT for centered spectral input\n        a_ks = fft.fftshift(fft.ifft(fft.ifftshift(U_filtered)))\n        \n        # 5. Accumulate intensity\n        total_intensity += np.abs(a_ks)**2\n        \n    # 6. Average intensity over all source points\n    return total_intensity / len(ks_list)\n\ndef solve():\n    \"\"\"\n    Main function to solve the SRAF optimization problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.30, 'W': 90.0, 'P': 220.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 2\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.60, 'W': 90.0, 'P': 220.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 3\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.20, 'W': 70.0, 'P': 200.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 4\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.80, 'W': 100.0, 'P': 240.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35}\n    ]\n\n    # Global computational parameters\n    N = 2048\n    dx = 1.0\n    Ns = 11\n    J_pen = 1000.0\n\n    # Spatial and frequency coordinates\n    x = (np.arange(N) - N / 2) * dx\n    f = fft.fftfreq(N, d=dx)\n    f_shifted = fft.fftshift(f)\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        lambda_ = case['lambda']\n        NA = case['NA']\n        sigma = case['sigma']\n        W = case['W']\n        P = case['P']\n        Lw = case['Lw']\n        w_cand = case['w_cand']\n        d_cand = case['d_cand']\n        I_th = case['I_th']\n\n        # System parameters\n        f_c = NA / lambda_\n        ks_list = np.linspace(-sigma * f_c, sigma * f_c, Ns)\n        \n        # Pupil function\n        pupil = np.zeros(N, dtype=np.float64)\n        pupil[np.abs(f_shifted) = f_c] = 1.0\n\n        # Create and simulate dense (target) mask\n        t_dense = (np.abs((x + P / 2) % P - P / 2) = W / 2).astype(np.float64)\n        I_dense = calculate_aerial_image(t_dense, x, f_shifted, pupil, ks_list)\n        \n        # Normalize target image\n        window_mask = np.abs(x) = Lw\n        max_I_dense = np.max(I_dense[window_mask])\n        I_dense_norm = I_dense / max_I_dense if max_I_dense > 0 else I_dense\n\n        min_objective = float('inf')\n        best_d, best_w = None, None\n\n        # Grid search for optimal d and w\n        for w in w_cand:\n            for d in d_cand:\n                # Create isolated-SRAF mask\n                t_iso = np.zeros_like(x)\n                t_iso[np.abs(x) = W / 2] = 1.0\n                sraf_center = W / 2 + d + w / 2\n                t_iso[np.abs(x - sraf_center) = w / 2] = 1.0\n                t_iso[np.abs(x + sraf_center) = w / 2] = 1.0\n                \n                # Calculate aerial image\n                I_iso = calculate_aerial_image(t_iso, x, f_shifted, pupil, ks_list)\n                \n                # Normalize and check constraint\n                max_I_iso = np.max(I_iso[window_mask])\n                I_iso_norm = I_iso / max_I_iso if max_I_iso > 0 else I_iso\n\n                sraf_center_idx = np.argmin(np.abs(x - sraf_center))\n                I_sraf = I_iso_norm[sraf_center_idx]\n                \n                is_printing = I_sraf >= I_th\n                \n                # Calculate objective function\n                mse = np.mean((I_iso_norm[window_mask] - I_dense_norm[window_mask])**2)\n                objective = mse + J_pen if is_printing else mse\n\n                # Update best parameters\n                if objective  min_objective:\n                    min_objective = objective\n                    best_d, best_w = d, w\n        \n        all_results.append([round(best_d, 1), round(best_w, 1)])\n\n    # Format and print the final results\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "当光学系统将掩模图形投影到晶圆上形成“空中像”后，光刻胶在曝光和显影步骤中被刻画，从而形成真正的物理图形。显影过程的动态特性直接决定了最终图形的关键尺寸（CD）及其质量。这个过程可以通过移动边界模型进行物理仿真，其中光刻胶的溶解前沿以一个与局部化学物质浓度（即“潜像”）相关的速度移动。这项实践练习  将让您基于一维移动边界模型，亲手实现对显影过程的动态仿真。您将通过求解常微分方程来追踪光刻胶轮廓随时间的变化，并分析最终CD对潜像噪声的敏感度，从而深入理解如何通过优化显影时间等工艺参数来实现更稳健的图形转移。",
            "id": "4288258",
            "problem": "您需要实现一个用于光刻胶线显影的一维移动边界模型，并计算关键尺寸（CD）如何依赖于显影时间和潜像噪声。目标是确定能使CD对小振幅潜像噪声的灵敏度最小化的显影时间。该问题的背景是集成电路（IC）和电子设计自动化（EDA）领域中光刻技术的图形转移。关键尺寸（CD）定义为显影后光刻胶特征的最终线宽。\n\n基本原理：\n- 在正性光刻胶中，溶解速率随去保护分数的增加而增加。设 $c(x)$ 为曝光和曝光后烘烤（PEB）后位置 $x$ 处的去保护分数，其中 $c(x) \\in [0,1]$。\n- 移动边界模型假设横向溶解前沿位置 $x_b(t)$ 从原始边缘向内移动，其局部速度等于在边界处计算的溶解速率。具体来说，右边缘的边界初始化为 $x_b(0) = W_0/2$（其中 $W_0$ 是初始线宽），并根据以下方程演化：\n$$\n\\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big),\n$$\n在时间 $t$ 的最终关键尺寸由下式给出：\n$$\n\\mathrm{CD}(t) = \\max\\left(0,\\,2\\,x_b(t)\\right).\n$$\n- 使用一个S型溶解速率模型（在化学放大光刻胶中经过充分测试），其中 $R(c)$ 为：\n$$\nR(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n},\n$$\n其中 $R_{\\min}  0$, $R_{\\max}  R_{\\min}$, $n \\geq 1$ 且 $c_{\\mathrm{th}} \\in (0,1)$。\n\n潜像模型：\n- 沿光刻胶线的基础去保护分数分布是一个从线内低值到线外高值的平滑过渡：\n$$\nc_0(x) = c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right),\n$$\n其中 $c_{\\min} \\in [0,1)$，$c_{\\max} \\in (0,1]$，以及 $\\sigma  0$ 控制边缘斜率。\n- 潜像噪声被建模为一个加到 $c_0(x)$ 上的小振幅空间正弦波，并裁剪到 $[0,1]$ 区间内：\n$$\nc(x;A) = \\mathrm{clip}\\left(c_0(x) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1\\right),\n$$\n其中 $A$ 是噪声振幅（无量纲），$\\lambda  0$ 是空间周期（单位为$\\mathrm{nm}$）。\n\n灵敏度定义：\n- 对于固定的 $t$，通过围绕零振幅的中心差分来定义CD对潜像噪声振幅的灵敏度：\n$$\nS(t) \\approx \\frac{\\mathrm{CD}(t; +A) - \\mathrm{CD}(t; -A)}{2\\,A},\n$$\n其中 $\\mathrm{CD}(t; A)$ 是使用 $c(x;A)$ 计算的在时间 $t$ 时的CD。\n\n任务：\n- 对于每个测试用例，模拟三种振幅 $A \\in \\{0, +A_0, -A_0\\}$ 下的边界运动，获得 $\\mathrm{CD}(t)$ 作为 $t$ 的函数，并为一组离散时间点 $t_k$ 计算 $S(t)$。\n- 将最小化域限制在 $t \\in [0, T_{\\mathrm{clear}}]$ 内，其中 $T_{\\mathrm{clear}}$ 是使得 $\\mathrm{CD}(t; 0) = 0$ 的最早时间。如果光刻胶线在给定的最大仿真时间 $T_{\\max}$ 之前未能完全清除，则使用 $T_{\\mathrm{clear}} = T_{\\max}$。\n- 在离散时间点集合中确定使 $|S(t)|$ 最小化的时间 $t^\\star$。报告以 $\\mathrm{s}$ 为单位的 $t^\\star$，以 $\\mathrm{nm}$ 为单位的 $\\mathrm{CD}(t^\\star;0)$，以及以 $\\mathrm{nm}$ 每单位噪声振幅为单位的 $S(t^\\star)$。\n\n数值实现要求：\n- 对移动边界常微分方程使用固定时间步长积分，时间步长为 $\\Delta t = 10^{-3}\\ \\mathrm{s}$。\n- 在每个步骤中计算并存储 $x_b(t)$ 和 $\\mathrm{CD}(t)$，直到达到 $T_{\\max}$ 或 $x_b(t) \\le 0$。\n- 在步长为 $\\Delta t_{\\mathrm{samp}} = 5\\times 10^{-2}\\ \\mathrm{s}$ 的均匀采样网格上评估 $S(t)$。\n- 确保在每次边界评估时，$c(x;A)$ 都被裁剪到 $[0,1]$ 区间内。\n\n单位：\n- 显影时间以秒（$\\mathrm{s}$）为单位报告。\n- 关键尺寸以纳米（$\\mathrm{nm}$）为单位报告。\n- 灵敏度以纳米每单位振幅（$\\mathrm{nm}$）为单位报告。\n\n测试套件：\n为以下三个科学上合理的测试用例提供结果：\n\n1. 典型特征：\n   - $W_0 = 40\\ \\mathrm{nm}$，$\\sigma = 5\\ \\mathrm{nm}$，$A_0 = 0.02$，$\\lambda = 8\\ \\mathrm{nm}$，\n   - $R_{\\min} = 0.2\\ \\mathrm{nm/s}$，$R_{\\max} = 5.0\\ \\mathrm{nm/s}$，$c_{\\mathrm{th}} = 0.5$，$n=4$，\n   - $c_{\\min} = 0.05$，$c_{\\max} = 0.95$，$T_{\\max} = 12\\ \\mathrm{s}$。\n\n2. 具有更陡峭边缘和更高噪声的更窄特征：\n   - $W_0 = 20\\ \\mathrm{nm}$，$\\sigma = 3\\ \\mathrm{nm}$，$A_0 = 0.03$，$\\lambda = 6\\ \\mathrm{nm}$，\n   - $R_{\\min} = 0.2\\ \\mathrm{nm/s}$，$R_{\\max} = 5.0\\ \\mathrm{nm/s}$，$c_{\\mathrm{th}} = 0.5$，$n=4$，\n   - $c_{\\min} = 0.05$，$c_{\\max} = 0.95$，$T_{\\max} = 8\\ \\mathrm{s}$。\n\n3. 具有更平滑边缘和更低噪声的更宽特征：\n   - $W_0 = 60\\ \\mathrm{nm}$，$\\sigma = 7\\ \\mathrm{nm}$，$A_0 = 0.015$，$\\lambda = 12\\ \\mathrm{nm}$，\n   - $R_{\\min} = 0.2\\ \\mathrm{nm/s}$，$R_{\\max} = 5.0\\ \\mathrm{nm/s}$，$c_{\\mathrm{th}} = 0.5$，$n=4$，\n   - $c_{\\min} = 0.05$，$c_{\\max} = 0.95$，$T_{\\max} = 16\\ \\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，格式为包含三个列表的列表：\n$$\n\\left[\\left[t^\\star_1,\\ \\mathrm{CD}_1(t^\\star_1),\\ S_1(t^\\star_1)\\right],\\ \\left[t^\\star_2,\\ \\mathrm{CD}_2(t^\\star_2),\\ S_2(t^\\star_2)\\right],\\ \\left[t^\\star_3,\\ \\mathrm{CD}_3(t^\\star_3),\\ S_3(t^\\star_3)\\right]\\right],\n$$\n所有值为数值。不应打印任何额外文本。使用上述指定的单位；数值应作为纯数字输出，不带单位符号，并统一四舍五入到六位小数。",
            "solution": "该问题已根据指定标准进行验证，并被确定为一个有效的科学问题。\n\n### 第1步：提取给定条件\n- **边界演化ODE**：$\\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big)$，初始条件为 $x_b(0) = W_0/2$。\n- **关键尺寸 (CD)**：$\\mathrm{CD}(t) = \\max\\left(0,\\,2\\,x_b(t)\\right)$。\n- **溶解速率模型**：$R(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n}$。\n- **基础潜像分布**：$c_0(x) = c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right)$。\n- **带噪声的潜像分布**：$c(x;A) = \\mathrm{clip}\\left(c_0(x) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1\\right)$。\n- **CD灵敏度**：$S(t) \\approx \\frac{\\mathrm{CD}(t; +A_0) - \\mathrm{CD}(t; -A_0)}{2\\,A_0}$。\n- **最小化任务**：在 $[0, T_{\\mathrm{clear}}]$ 内的离散采样时间点集合中找到使 $|S(t)|$ 最小化的 $t^\\star$。$T_{\\mathrm{clear}}$ 是 $\\mathrm{CD}(t; 0)=0$ 的时间点。\n- **数值参数**：积分时间步长 $\\Delta t = 10^{-3}\\ \\mathrm{s}$，灵敏度采样时间步长 $\\Delta t_{\\mathrm{samp}} = 5\\times 10^{-2}\\ \\mathrm{s}$。\n- **测试用例**：为 $(W_0, \\sigma, A_0, \\lambda, T_{\\max})$ 提供了三组参数，以及共同参数 $(R_{\\min}, R_{\\max}, c_{\\mathrm{th}}, n, c_{\\min}, c_{\\max})$。\n\n### 第2步：使用提取的给定条件进行验证\n该问题具有科学依据、良态性且客观。\n- **科学依据**：该模型基于光刻工艺仿真中的既定原理。移动边界模型是Eikonal方程的一维简化，S型溶解速率函数是广泛使用的Mack模型的一个变体，双曲正切函数是潜像分布的标准表示方法。\n- **良态性**：该问题已用所有必要的方程、参数和数值程序进行了完全规定。控制边界运动的ODE定义明确，所涉及的函数是连续且有界的，确保了稳定的解。寻找一个数值计算函数的最小值的任务是一个标准的计算问题。\n- **客观性**：该问题使用精确的数学语言定义，没有歧义或主观论断。\n\n### 第3步：结论与行动\n该问题是**有效的**。将按照指定的方法论开发一个解决方案。\n\n### 解决方案设计\n\n该问题要求模拟光刻胶线的显影过程，并分析其对潜像噪声的灵敏度。解决方案分为三个主要部分：边界演化的数值模拟、关键尺寸（CD）灵敏度的计算，以及为找到最小灵敏度时间而进行的优化。\n\n**1. 数学模型构建**\n\n模型的核心是光刻胶线右侧边界 $x_b(t)$ 的演化，它从 $x_b(0) = W_0/2$ 开始向内移动。其速度由局部溶解速率决定，而溶解速率又取决于局部的去保护分数 $c(x)$。这由以下一阶常微分方程（ODE）描述：\n$$ \\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big) $$\n\n去保护分数 $c(x)$ 包括一个基础分布 $c_0(x)$ 和一个振幅为 $A$、空间周期为 $\\lambda$ 的正弦噪声项。组合后的分布被裁剪到物理上有意义的范围 $[0, 1]$ 内：\n$$ c(x;A) = \\mathrm{clip}\\left( c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1 \\right) $$\n\n溶解速率 $R(c)$ 由一个S型函数给出，这是化学放大光刻胶的特征：\n$$ R(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n} $$\n该函数为低的 $c$ 值提供缓慢的蚀刻速率（$R_{\\min}$），为高的 $c$ 值提供快速的蚀刻速率（$R_{\\max}$），其间的急剧转变由阈值 $c_{\\mathrm{th}}$ 和对比度参数 $n$ 控制。\n\n**2. 数值模拟算法**\n\n为了求解 $x_b(t)$ 的ODE，我们采用显式前向欧拉法。鉴于固定的时间步长很小（$\\Delta t = 10^{-3} \\ \\mathrm{s}$），这是一个直接且适合该问题的方法。迭代更新规则是：\n$$ x_b(t_{k+1}) = x_b(t_k) - \\Delta t \\cdot R\\big(c(x_b(t_k); A)\\big) $$\n其中 $t_{k+1} = t_k + \\Delta t$。从 $x_b(0) = W_0/2$ 开始，重复此过程，直到边界完全退回（$x_b(t) \\le 0$）或达到最大仿真时间 $T_{\\max}$。\n\n对于每个测试用例，此模拟执行三次，以获得CD随时间演变的过程 $\\mathrm{CD}(t) = 2x_b(t)$（对于 $x_b(t)  0$），对应于三种噪声情景：\n- $\\mathrm{CD}(t; 0)$ 对应基准情况（$A=0$）。\n- $\\mathrm{CD}(t; +A_0)$ 对应正噪声振幅。\n- $\\mathrm{CD}(t; -A_0)$ 对应负噪声振幅。\n\n每次模拟的时间序列数据 $(t, \\mathrm{CD}(t))$ 都会被存储。\n\n**3. 灵敏度分析与优化**\n\n最后一步是计算灵敏度 $S(t)$ 并找到使其绝对值最小化的显影时间 $t^\\star$。\n\n首先，我们确定分析的有效时间域。这个域是 $[0, T_{\\mathrm{clear}}]$，其中 $T_{\\mathrm{clear}}$ 是基准情况（$A=0$）下光刻胶的清除时间，定义为使 $\\mathrm{CD}(t; 0) = 0$ 的最早时间 $t$。如果光刻胶线在 $T_{\\max}$ 之前没有清除，我们设定 $T_{\\mathrm{clear}} = T_{\\max}$。\n\n接下来，我们在区间 $[0, T_{\\mathrm{clear}}]$ 上建立一个时间 $t_k$ 的均匀采样网格，步长为 $\\Delta t_{\\mathrm{samp}} = 5 \\times 10^{-2} \\ \\mathrm{s}$。三条模拟的CD轨迹（它们是在更精细的网格 $\\Delta t$ 上生成的）通过线性插值被重采样到这个公共网格上。设插值后的值为 $\\mathrm{CD}_{\\mathrm{samp}}(t_k; A)$。\n\n然后，使用中心差分公式来近似每个采样点的灵敏度 $S(t_k)$：\n$$ S(t_k) = \\frac{\\mathrm{CD}_{\\mathrm{samp}}(t_k; +A_0) - \\mathrm{CD}_{\\mathrm{samp}}(t_k; -A_0)}{2\\,A_0} $$\n这产生了一个离散的灵敏度值序列 $S(t_k)$。\n\n最后，我们找到使灵敏度绝对值 $|S(t_k)|$ 最小化的索引 $k^\\star$。最优显影时间为 $t^\\star = t_{k^\\star}$。伴随的度量指标是此时的基准CD，即 $\\mathrm{CD}(t^\\star; 0) = \\mathrm{CD}_{\\mathrm{samp}}(t_{k^\\star}; 0)$，以及灵敏度本身，即 $S(t^\\star) = S(t_{k^\\star})$。这三个值——$(t^\\star, \\mathrm{CD}(t^\\star; 0), S(t^\\star))$——构成一个测试用例的结果。对所有提供的三个测试用例重复此整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations for all test cases and print the results.\n    \"\"\"\n\n    # Common parameters for all test cases\n    R_min = 0.2  # nm/s\n    R_max = 5.0  # nm/s\n    c_th = 0.5   # dimensionless\n    n = 4.0      # dimensionless\n    c_min = 0.05 # dimensionless\n    c_max = 0.95 # dimensionless\n    \n    # Numerical method parameters\n    dt = 1e-3    # s\n    dt_samp = 5e-2 # s\n\n    test_cases = [\n        {\n            \"W0\": 40.0, \"sigma\": 5.0, \"A0\": 0.02, \"lambda_val\": 8.0, \n            \"T_max\": 12.0\n        },\n        {\n            \"W0\": 20.0, \"sigma\": 3.0, \"A0\": 0.03, \"lambda_val\": 6.0, \n            \"T_max\": 8.0\n        },\n        {\n            \"W0\": 60.0, \"sigma\": 7.0, \"A0\": 0.015, \"lambda_val\": 12.0, \n            \"T_max\": 16.0\n        },\n    ]\n\n    all_results = []\n\n    for case_params in test_cases:\n        # Define model functions for the current case\n        def c0(x, p):\n            arg = (np.abs(x) - p[\"W0\"] / 2.0) / p[\"sigma\"]\n            return c_min + (c_max - c_min) * 0.5 * (1.0 + np.tanh(arg))\n\n        def c_noisy(x, A, p):\n            val = c0(x, p) + A * np.cos(2.0 * np.pi * x / p[\"lambda_val\"])\n            return np.clip(val, 0.0, 1.0)\n        \n        def R(c_val):\n            return R_min + (R_max - R_min) * (c_val**n) / (c_val**n + c_th**n)\n        \n        def simulate_cd_evolution(A, p):\n            \"\"\"Simulates the boundary evolution for a given noise amplitude A.\"\"\"\n            t = 0.0\n            xb = p[\"W0\"] / 2.0\n            \n            t_series = [t]\n            xb_series = [xb]\n\n            while t  p[\"T_max\"]:\n                c_at_boundary = c_noisy(xb, A, p)\n                rate = R(c_at_boundary)\n                xb -= rate * dt\n                t += dt\n\n                if xb = 0:\n                    xb = 0.0\n                    t_series.append(t)\n                    xb_series.append(xb)\n                    break \n                \n                t_series.append(t)\n                xb_series.append(xb)\n\n            t_series_np = np.array(t_series)\n            cd_series_np = np.maximum(0.0, 2.0 * np.array(xb_series))\n            \n            return t_series_np, cd_series_np\n\n        # Run simulations for A=0, +A0, -A0\n        A0 = case_params[\"A0\"]\n        t_0, cd_0 = simulate_cd_evolution(0.0, case_params)\n        t_pA, cd_pA = simulate_cd_evolution(A0, case_params)\n        t_nA, cd_nA = simulate_cd_evolution(-A0, case_params)\n\n        # Determine T_clear\n        clear_indices = np.where(cd_0 == 0.0)[0]\n        if len(clear_indices) > 0:\n            T_clear = t_0[clear_indices[0]]\n        else:\n            T_clear = case_params[\"T_max\"]\n\n        # Create sampling grid\n        t_samples = np.arange(0, T_clear, dt_samp)\n        if len(t_samples) == 0 or not np.isclose(t_samples[-1], T_clear):\n             t_samples = np.append(t_samples, T_clear)\n\n        # Interpolate CD values onto the sampling grid\n        cd_samp_0 = np.interp(t_samples, t_0, cd_0)\n        cd_samp_pA = np.interp(t_samples, t_pA, cd_pA)\n        cd_samp_nA = np.interp(t_samples, t_nA, cd_nA)\n        \n        # Calculate sensitivity\n        if A0 == 0.0:\n            S_values = np.zeros_like(t_samples)\n        else:\n            S_values = (cd_samp_pA - cd_samp_nA) / (2.0 * A0)\n\n        # Find time of minimum absolute sensitivity\n        if len(S_values) == 0:\n            k_star = 0\n            t_star = 0.0\n            cd_star = case_params[\"W0\"]\n            s_star = (np.interp([0], t_pA, cd_pA)[0] - np.interp([0], t_nA, cd_nA)[0]) / (2.0*A0) if A0 != 0 else 0\n        else:\n            k_star = np.argmin(np.abs(S_values))\n            t_star = t_samples[k_star]\n            cd_star = cd_samp_0[k_star]\n            s_star = S_values[k_star]\n\n        all_results.append([t_star, cd_star, s_star])\n\n    # Format output string\n    formatted_results = []\n    for res in all_results:\n        inner_list_str = [f\"{v:.6f}\" for v in res]\n        formatted_results.append(f\"[{','.join(inner_list_str)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "完整的图形转移链条涉及从掩模制造到光刻胶显影，再到最终基底刻蚀的多个环节。每一步都会引入系统性的偏差（bias），导致最终在晶圆上形成的图形尺寸偏离最初的设计意图。为了精确控制最终尺寸，工业界通常不依赖于纯粹的物理仿真，而是建立经验模型来预测和补偿这些偏差。这项实践练习  将带您体验现代工艺控制与OPC建模的核心任务。您将使用一个包含图形尺寸和图形密度（即微负载效应，microloading effect）的线性模型，通过对设计尺寸、光刻胶尺寸和刻蚀后尺寸的测量数据进行多元线性回归分析，来校准一个两步图形转移模型。这项练习不仅能让您掌握模型校准的方法，还能通过计算置信区间来量化模型参数的不确定性，从而将理论知识与工业实践紧密联系起来。",
            "id": "4288269",
            "problem": "给定一个在集成电路和电子设计自动化领域中，关于光刻图形转移的建模与校准任务。您必须编写一个程序，该程序使用一个包含多个间距下的绘制关键尺寸、测量的蚀刻前光刻胶关键尺寸和测量的蚀刻后关键尺寸的数据集，执行两阶段线性回归，以校准光刻胶和蚀刻偏差参数。该程序还必须在一个具有独立同分布高斯噪声的标准线性模型下，为每个拟合参数计算双边置信区间。\n\n建模假设与基本原理：\n- 设 $D_i$ 为样本 $i$ 在间距 $P_i$（单位 nm）下的绘制关键尺寸（单位 nm）。设 $R_i$ 为测量的蚀刻前光刻胶关键尺寸（单位 nm），设 $E_i$ 为测量的蚀刻后关键尺寸（单位 nm）。\n- 假设光刻胶显影和蚀刻转移过程均可通过一个线性关系来描述，该关系包含一个截距、一个相对于其上游尺寸的斜率，以及一个与 $1/P_i$ 成正比的微负载效应项：\n  - 光刻胶模型：$R_i = \\alpha_0 + \\alpha_1 D_i + \\alpha_2 \\left(\\dfrac{1}{P_i}\\right) + \\varepsilon^{(r)}_i$。\n  - 蚀刻模型：$E_i = \\beta_0 + \\beta_1 R_i + \\beta_2 \\left(\\dfrac{1}{P_i}\\right) + \\varepsilon^{(e)}_i$。\n- 噪声项服从独立同分布的零均值高斯分布，且方差有限：$\\varepsilon^{(r)}_i \\sim \\mathcal{N}(0,\\sigma_r^2)$ 和 $\\varepsilon^{(e)}_i \\sim \\mathcal{N}(0,\\sigma_e^2)$。在每次回归中，采用为普通最小二乘法提供理论依据的标准线性模型假设：参数线性、独立性、同方差性和零均值高斯误差。\n- 通过普通最小二乘法校准参数：构建设计矩阵 $X$，其列分别为截距、上游尺寸和 $1/P_i$，并估计参数矢量 $\\hat{\\theta} = (X^\\top X)^{-1} X^\\top y$。使用无偏残差方差估计量 $\\hat{\\sigma}^2 = \\dfrac{\\|y - X \\hat{\\theta}\\|_2^2}{n - p}$，其中 $n$ 是样本数量，$p$ 是参数数量；以及参数协方差 $\\widehat{\\mathrm{Cov}}(\\hat{\\theta}) = \\hat{\\sigma}^2 (X^\\top X)^{-1}$。对于名义覆盖率为 $1 - \\alpha$ 的双边置信区间，使用自由度为 $\\nu = n - p$ 的学生t分布分位数 $t_{1 - \\alpha/2,\\ \\nu}$，因此第 $k$ 个分量的区间为 $\\hat{\\theta}_k \\pm t_{1 - \\alpha/2,\\ \\nu} \\cdot \\mathrm{SE}(\\hat{\\theta}_k)$，其中 $\\mathrm{SE}(\\hat{\\theta}_k)$ 是 $\\widehat{\\mathrm{Cov}}(\\hat{\\theta})$ 第 $k$ 个对角线元素的平方根。\n\n程序要求：\n- 实现两个独立的回归分析：\n  - 光刻胶回归：从 $\\{(D_i, P_i, R_i)\\}$ 估计 $\\alpha_0$、$\\alpha_1$、$\\alpha_2$。\n  - 蚀刻回归：从 $\\{(R_i, P_i, E_i)\\}$ 估计 $\\beta_0$、$\\beta_1$、$\\beta_2$。\n- 使用具有相应自由度的t分布，为每个参数计算名义覆盖率为 $95\\%$（即 $\\alpha = 0.05$）的双边置信区间。\n- 所有关键尺寸必须以纳米 (nanometers) 为单位处理，间距也以纳米为单位。报告参数估计值时，截距项（$\\alpha_0$, $\\beta_0$）以纳米为单位，斜率项（$\\alpha_1$, $\\beta_1$）为无量纲，微负载效应系数（$\\alpha_2$, $\\beta_2$）以 $\\mathrm{nm}^2$ 为单位。置信区间边界的单位与其对应参数的单位相同。将所有报告的浮点数结果四舍五入到小数点后 $3$ 位。\n\n测试套件规范：\n- 为保证可复现性，您的程序必须使用独立的伪随机数生成器种子，为三个测试用例生成合成数据集。对于每个用例，通过以下方式生成 $N$ 个样本：\n  - 在指定范围 $[D_{\\min}, D_{\\max}]$（单位 nm）内独立均匀地抽取 $D_i$。\n  - 从指定的有限间距集合（单位 nm）中独立抽取 $P_i$。\n  - 根据具有指定真实参数的模型生成 $R_i$ 和 $E_i$，并添加具有指定标准差的高斯噪声。\n- 测试套件如下：\n  - 用例 1（典型微负载效应，中等噪声）：\n    - 真实光刻胶参数：$\\alpha_0 = -2.0$ nm, $\\alpha_1 = 1.02$, $\\alpha_2 = 300.0$ $\\mathrm{nm}^2$。\n    - 真实蚀刻参数：$\\beta_0 = -1.0$ nm, $\\beta_1 = 0.97$, $\\beta_2 = 200.0$ $\\mathrm{nm}^2$。\n    - 噪声标准差：$\\sigma_r = 1.0$ nm, $\\sigma_e = 1.2$ nm。\n    - 绘制CD范围：$[20.0, 80.0]$ nm。\n    - 间距集合：$\\{64.0, 72.0, 80.0, 90.0, 104.0, 128.0, 160.0, 200.0\\}$ nm。\n    - 样本数量：$N = 80$。\n    - 随机种子：$12345$。\n  - 用例 2（强微负载效应，低噪声）：\n    - 真实光刻胶参数：$\\alpha_0 = -1.0$ nm, $\\alpha_1 = 1.01$, $\\alpha_2 = 800.0$ $\\mathrm{nm}^2$。\n    - 真实蚀刻参数：$\\beta_0 = -0.5$ nm, $\\beta_1 = 0.98$, $\\beta_2 = 1000.0$ $\\mathrm{nm}^2$。\n    - 噪声标准差：$\\sigma_r = 0.5$ nm, $\\sigma_e = 0.5$ nm。\n    - 绘制CD范围：$[20.0, 80.0]$ nm。\n    - 间距集合：$\\{64.0, 72.0, 80.0, 90.0, 104.0, 128.0, 160.0, 200.0\\}$ nm。\n    - 样本数量：$N = 100$。\n    - 随机种子：$67890$。\n  - 用例 3（偏差可忽略的边界情况）：\n    - 真实光刻胶参数：$\\alpha_0 = 0.0$ nm, $\\alpha_1 = 1.00$, $\\alpha_2 = 0.0$ $\\mathrm{nm}^2$。\n    - 真实蚀刻参数：$\\beta_0 = 0.0$ nm, $\\beta_1 = 1.00$, $\\beta_2 = 0.0$ $\\mathrm{nm}^2$。\n    - 噪声标准差：$\\sigma_r = 0.8$ nm, $\\sigma_e = 0.8$ nm。\n    - 绘制CD范围：$[20.0, 80.0]$ nm。\n    - 间距集合：$\\{64.0, 72.0, 80.0, 90.0, 104.0, 128.0, 160.0, 200.0\\}$ nm。\n    - 样本数量：$N = 60$。\n    - 随机种子：$24680$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个子列表的列表，每个子列表对应一个测试用例。对于每个测试用例，按以下确切顺序输出一个包含 $18$ 个数字的扁平列表，所有数字均四舍五入到小数点后 $3$ 位：$\\hat{\\alpha}_0$, $\\hat{\\alpha}_1$, $\\hat{\\alpha}_2$, $\\hat{\\beta}_0$, $\\hat{\\beta}_1$, $\\hat{\\beta}_2$，然后按相同顺序给出每个参数的 $95\\%$ 置信区间的下界和上界：$\\alpha_0^{\\text{lo}}$, $\\alpha_0^{\\text{hi}}$, $\\alpha_1^{\\text{lo}}$, $\\alpha_1^{\\text{hi}}$, $\\alpha_2^{\\text{lo}}$, $\\alpha_2^{\\text{hi}}$, $\\beta_0^{\\text{lo}}$, $\\beta_0^{\\text{hi}}$, $\\beta_1^{\\text{lo}}$, $\\beta_1^{\\text{hi}}$, $\\beta_2^{\\text{lo}}$, $\\beta_2^{\\text{hi}}$。\n- 因此，最终打印的结构必须是一个包含三个列表的列表，例如：$[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题要求使用普通最小二乘（OLS）回归，对光刻中图形转移的两个线性模型进行校准。第一个模型描述了从绘制的版图形成光刻胶图形的过程，第二个模型描述了使用光刻胶图形作为掩模对衬底进行蚀刻的过程。对于每个模型，我们必须估计其参数并计算其 $95\\%$ 的置信区间。\n\n线性回归模型的一般形式为：\n$$ \\mathbf{y} = \\mathbf{X} \\mathbf{\\theta} + \\mathbf{\\varepsilon} $$\n其中 $\\mathbf{y}$ 是一个 $n \\times 1$ 的观测值矢量，$\\mathbf{X}$ 是一个 $n \\times p$ 的预测变量设计矩阵，$\\mathbf{\\theta}$ 是一个 $p \\times 1$ 的待估未知参数矢量，$\\mathbf{\\varepsilon}$ 是一个 $n \\times 1$ 的随机误差矢量。OLS 方法寻找能够最小化残差平方和 $\\| \\mathbf{y} - \\mathbf{X} \\mathbf{\\theta} \\|_2^2$ 的参数估计值 $\\hat{\\mathbf{\\theta}}$。解由正规方程给出：\n$$ \\hat{\\mathbf{\\theta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y} $$\n这要求矩阵 $\\mathbf{X}^\\top \\mathbf{X}$ 是可逆的，如果 $\\mathbf{X}$ 的列是线性无关的，并且样本数量 $n$ 大于参数数量 $p$，这个条件通常成立。\n\n该问题指定了两个不同的回归任务：\n\n1.  **光刻胶模型校准**：模型为 $R_i = \\alpha_0 + \\alpha_1 D_i + \\alpha_2 \\left(\\frac{1}{P_i}\\right) + \\varepsilon^{(r)}_i$。我们正在估计参数矢量 $\\mathbf{\\theta}^{(r)} = [\\alpha_0, \\alpha_1, \\alpha_2]^\\top$。响应矢量 $\\mathbf{y}^{(r)}$ 由测量的蚀刻前光刻胶关键尺寸 $\\{R_i\\}_{i=1}^n$ 组成。设计矩阵 $\\mathbf{X}^{(r)}$ 由绘制的关键尺寸 $\\{D_i\\}_{i=1}^n$ 和间距 $\\{P_i\\}_{i=1}^n$ 构建。$\\mathbf{X}^{(r)}$ 的第 $i$ 行对应一个样本，形式为 $[1, D_i, 1/P_i]$。\n    $$ \\mathbf{y}^{(r)} = \\begin{pmatrix} R_1 \\\\ R_2 \\\\ \\vdots \\\\ R_n \\end{pmatrix}, \\quad \\mathbf{X}^{(r)} = \\begin{pmatrix} 1  D_1  1/P_1 \\\\ 1  D_2  1/P_2 \\\\ \\vdots  \\vdots  \\vdots \\\\ 1  D_n  1/P_n \\end{pmatrix}, \\quad \\mathbf{\\theta}^{(r)} = \\begin{pmatrix} \\alpha_0 \\\\ \\alpha_1 \\\\ \\alpha_2 \\end{pmatrix} $$\n\n2.  **蚀刻模型校准**：模型为 $E_i = \\beta_0 + \\beta_1 R_i + \\beta_2 \\left(\\frac{1}{P_i}\\right) + \\varepsilon^{(e)}_i$。我们正在估计参数矢量 $\\mathbf{\\theta}^{(e)} = [\\beta_0, \\beta_1, \\beta_2]^\\top$。响应矢量 $\\mathbf{y}^{(e)}$ 由测量的蚀刻后关键尺寸 $\\{E_i\\}_{i=1}^n$ 组成。设计矩阵 $\\mathbf{X}^{(e)}$ 由测量的光刻胶尺寸 $\\{R_i\\}_{i=1}^n$ 和间距 $\\{P_i\\}_{i=1}^n$ 构建。$\\mathbf{X}^{(e)}$ 的第 $i$ 行形式为 $[1, R_i, 1/P_i]$。\n    $$ \\mathbf{y}^{(e)} = \\begin{pmatrix} E_1 \\\\ E_2 \\\\ \\vdots \\\\ E_n \\end{pmatrix}, \\quad \\mathbf{X}^{(e)} = \\begin{pmatrix} 1  R_1  1/P_1 \\\\ 1  R_2  1/P_2 \\\\ \\vdots  \\vdots  \\vdots \\\\ 1  R_n  1/P_n \\end{pmatrix}, \\quad \\mathbf{\\theta}^{(e)} = \\begin{pmatrix} \\beta_0 \\\\ \\beta_1 \\\\ \\beta_2 \\end{pmatrix} $$\n\n对于两个模型，参数数量均为 $p=3$。\n\n为了构建估计参数的置信区间，我们假设误差 $\\varepsilon_i$ 是独立同分布的，服从 $\\mathcal{N}(0, \\sigma^2)$。误差方差 $\\sigma^2$ 的一个无偏估计量是残差方差：\n$$ \\hat{\\sigma}^2 = \\frac{1}{n-p} \\| \\mathbf{y} - \\mathbf{X} \\hat{\\mathbf{\\theta}} \\|_2^2 = \\frac{1}{n-p} \\sum_{i=1}^n (y_i - \\hat{y}_i)^2 $$\n其中 $\\hat{y}_i$ 是模型的预测值。参数估计值 $\\hat{\\mathbf{\\theta}}$ 的协方差矩阵则通过以下方式估计：\n$$ \\widehat{\\mathrm{Cov}}(\\hat{\\mathbf{\\theta}}) = \\hat{\\sigma}^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1} $$\n第 $k$ 个参数估计值的标准误差 $\\mathrm{SE}(\\hat{\\theta}_k)$ 是该协方差矩阵第 $k$ 个对角线元素的平方根。参数 $\\theta_k$ 的一个双边 $100(1-\\alpha)\\%$ 置信区间由下式给出：\n$$ \\hat{\\theta}_k \\pm t_{1-\\alpha/2, \\nu} \\cdot \\mathrm{SE}(\\hat{\\theta}_k) $$\n此处，$\\nu = n-p$ 是残差的自由度，$t_{1-\\alpha/2, \\nu}$ 是在给定置信水平 $1-\\alpha$ 下学生t分布的上侧临界值。对于 $95\\%$ 的置信区间，$\\alpha = 0.05$，我们使用分位数 $t_{0.975, n-3}$。\n\n实现过程将首先根据指定的真实参数、噪声水平和抽样分布，为每个测试用例生成合成数据。然后，对于每个模型（光刻胶和蚀刻），它将构建相应的设计矩阵和响应矢量。执行 OLS 回归以获得参数估计值。随后，将计算残差方差、参数协方差矩阵、标准误差和适当的t统计量，以构建 $95\\%$ 置信区间。最终结果，包括六个参数估计值及其对应的置信区间界限（每个测试用例共 $18$ 个值），将被四舍五入到小数点后三位，并按指定格式进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef perform_regression(x_upstream, p_pitch, y_downstream, confidence_level=0.95):\n    \"\"\"\n    Performs multiple linear regression and calculates confidence intervals for parameters.\n    \n    Args:\n        x_upstream (np.ndarray): The upstream dimension vector.\n        p_pitch (np.ndarray): The pitch vector.\n        y_downstream (np.ndarray): The response vector (downstream dimension).\n        confidence_level (float): The confidence level for the intervals.\n\n    Returns:\n        tuple: A tuple containing (theta_hat, ci_lower, ci_upper), where\n               theta_hat are the estimated parameters,\n               ci_lower are the lower bounds of the confidence intervals,\n               ci_upper are the upper bounds of the confidence intervals.\n    \"\"\"\n    n = len(y_downstream)\n    p = 3  # Number of parameters: intercept, slope, microloading\n\n    # Construct the design matrix X\n    X = np.c_[np.ones(n), x_upstream, 1.0 / p_pitch]\n    \n    # Solve for parameters using ordinary least squares\n    # np.linalg.lstsq is numerically stable\n    theta_hat = np.linalg.lstsq(X, y_downstream, rcond=None)[0]\n\n    # Calculate residuals and residual sum of squares (RSS)\n    y_hat = X @ theta_hat\n    residuals = y_downstream - y_hat\n    rss = np.sum(residuals**2)\n\n    # Calculate unbiased estimator of error variance\n    df = n - p\n    sigma_sq_hat = rss / df\n\n    # Calculate covariance matrix of parameter estimates\n    # For stability, check invertibility if necessary, though unlikely with generated data.\n    try:\n        X_T_X_inv = np.linalg.inv(X.T @ X)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudo-inverse if X.T @ X is singular\n        X_T_X_inv = np.linalg.pinv(X.T @ X)\n\n    cov_theta_hat = sigma_sq_hat * X_T_X_inv\n\n    # Standard errors are the sqrt of the diagonal elements of the covariance matrix\n    se_theta_hat = np.sqrt(np.diag(cov_theta_hat))\n\n    # Calculate the t-statistic for the given confidence level\n    alpha = 1.0 - confidence_level\n    t_crit = stats.t.ppf(1 - alpha / 2, df)\n\n    # Calculate confidence intervals\n    ci_half_width = t_crit * se_theta_hat\n    ci_lower = theta_hat - ci_half_width\n    ci_upper = theta_hat + ci_half_width\n\n    return theta_hat, ci_lower, ci_upper\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case 1 (typical microloading, moderate noise)\",\n            \"true_alpha\": np.array([-2.0, 1.02, 300.0]),\n            \"true_beta\": np.array([-1.0, 0.97, 200.0]),\n            \"sigma_r\": 1.0,\n            \"sigma_e\": 1.2,\n            \"D_range\": [20.0, 80.0],\n            \"P_set\": [64.0, 72.0, 80.0, 90.0, 104.0, 128.0, 160.0, 200.0],\n            \"N\": 80,\n            \"seed\": 12345,\n        },\n        {\n            \"name\": \"Case 2 (strong microloading, low noise)\",\n            \"true_alpha\": np.array([-1.0, 1.01, 800.0]),\n            \"true_beta\": np.array([-0.5, 0.98, 1000.0]),\n            \"sigma_r\": 0.5,\n            \"sigma_e\": 0.5,\n            \"D_range\": [20.0, 80.0],\n            \"P_set\": [64.0, 72.0, 80.0, 90.0, 104.0, 128.0, 160.0, 200.0],\n            \"N\": 100,\n            \"seed\": 67890,\n        },\n        {\n            \"name\": \"Case 3 (boundary case with negligible biases)\",\n            \"true_alpha\": np.array([0.0, 1.00, 0.0]),\n            \"true_beta\": np.array([0.0, 1.00, 0.0]),\n            \"sigma_r\": 0.8,\n            \"sigma_e\": 0.8,\n            \"D_range\": [20.0, 80.0],\n            \"P_set\": [64.0, 72.0, 80.0, 90.0, 104.0, 128.0, 160.0, 200.0],\n            \"N\": 60,\n            \"seed\": 24680,\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        rng = np.random.default_rng(case[\"seed\"])\n        N = case[\"N\"]\n\n        # Generate synthetic data\n        D = rng.uniform(case[\"D_range\"][0], case[\"D_range\"][1], size=N)\n        P = rng.choice(case[\"P_set\"], size=N, replace=True)\n\n        noise_r = rng.normal(0, case[\"sigma_r\"], size=N)\n        R = case[\"true_alpha\"][0] + case[\"true_alpha\"][1] * D + case[\"true_alpha\"][2] / P + noise_r\n        \n        noise_e = rng.normal(0, case[\"sigma_e\"], size=N)\n        E = case[\"true_beta\"][0] + case[\"true_beta\"][1] * R + case[\"true_beta\"][2] / P + noise_e\n\n        # Perform resist regression\n        alpha_hat, alpha_ci_lo, alpha_ci_hi = perform_regression(D, P, R)\n\n        # Perform etch regression\n        beta_hat, beta_ci_lo, beta_ci_hi = perform_regression(R, P, E)\n        \n        # Assemble results in the specified order\n        case_result = [\n            alpha_hat[0], alpha_hat[1], alpha_hat[2],\n            beta_hat[0], beta_hat[1], beta_hat[2],\n            alpha_ci_lo[0], alpha_ci_hi[0],\n            alpha_ci_lo[1], alpha_ci_hi[1],\n            alpha_ci_lo[2], alpha_ci_hi[2],\n            beta_ci_lo[0], beta_ci_hi[0],\n            beta_ci_lo[1], beta_ci_hi[1],\n            beta_ci_lo[2], beta_ci_hi[2],\n        ]\n        \n        all_results.append(case_result)\n\n    # Format the final output string precisely as a list of lists.\n    outer_parts = []\n    for res_list in all_results:\n        inner_parts = [f\"{x:.3f}\" for x in res_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_string = f\"[{','.join(outer_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}