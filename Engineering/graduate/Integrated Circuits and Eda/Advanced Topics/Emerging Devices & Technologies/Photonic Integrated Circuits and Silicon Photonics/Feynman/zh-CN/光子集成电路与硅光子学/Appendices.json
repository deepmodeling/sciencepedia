{
    "hands_on_practices": [
        {
            "introduction": "在开始任何光子集成电路（PIC）设计之前，一个关键的初始步骤是选择合适的数值仿真方法。不同的光子器件和物理现象需要不同的计算工具来精确建模。本练习将引导你扮演设计工程师的角色，评估和辨析多种常用仿真方法的基本原理与局限性，从而做出明智的选择——这是实现高效、准确设计的核心技能。",
            "id": "4289024",
            "problem": "硅光子学中的一个纳米级光子集成电路（PIC）由二氧化硅上的高折射率差硅波导、光栅耦合器、环形谐振器和紧凑弯曲构成。从由麦克斯韦方程组 $\\nabla \\times \\mathbf{E}(\\mathbf{r},t) = -\\mu_0 \\frac{\\partial \\mathbf{H}(\\mathbf{r},t)}{\\partial t}$ 和 $\\nabla \\times \\mathbf{H}(\\mathbf{r},t) = \\mathbf{J}(\\mathbf{r},t) + \\frac{\\partial \\mathbf{D}(\\mathbf{r},t)}{\\partial t}$ 以及本构关系 $\\mathbf{D}(\\mathbf{r},t) = \\epsilon(\\mathbf{r},\\omega)\\,\\mathbf{E}(\\mathbf{r},t)$ 和 $\\mathbf{B}(\\mathbf{r},t) = \\mu_0 \\mathbf{H}(\\mathbf{r},t)$ 所支配的线性、可能色散的介质中的宏观电磁学基础出发，选择数值求解器在适当的近似和边界条件下对不同组件进行建模。考虑在集成光子学和电子设计自动化（EDA）中广泛使用的五类方法：时域有限差分法（FDTD）、有限元法（FEM）、本征模式求解器、光束传播法（BPM）和严格耦合波分析（RCWA）。哪个选项正确且一致地定义了每种方法的底层公式，并指出了其在 PIC 建模中的科学有效适用范围？\n\nA. 时域有限差分法（FDTD）在交错网格上对时域中的全矢量麦克斯韦方程组进行积分，捕捉复杂 $3$D 几何结构中的宽带响应、瞬态和反射；光束传播法（BPM）应用了前向传播、缓变包络/傍轴近似，非常适合具有小角度传播的长、弱变化结构，当出现强后向反射或反向传播波时通常无效；有限元法（FEM）使用非结构化网格求解频域麦克斯韦方程组的弱形式，能够处理弯曲边界和高折射率差；本征模式求解器通过求解均匀或分段均匀波导中矢量场的横截面本征值问题来计算导模和传播常数；严格耦合波分析（RCWA）将场和介电常数展开为傅里叶级数以求解周期性介质中的散射问题，使其适用于光栅和光子晶体元件，但不适用于强非周期性的孤立弯曲。\n\nB. 时域有限差分法（FDTD）是一种频域谐波求解器，仅限于窄带分析，不能捕捉瞬态或反射；光束传播法（BPM）可可靠地模拟突变不连续处的强后向反射和驻波；有限元法（FEM）仅限于直线均匀网格，且在处理弯曲边界时性能不佳；本征模式求解器需要周期性边界条件，并且主要用于光栅模拟；严格耦合波分析（RCWA）对于高度非周期性的波导弯曲和锥形结构是首选。\n\nC. 本征模式求解器在任意激励下对完整的时间演化进行积分，以产生瞬态场动力学；严格耦合波分析（RCWA）最适合均匀、非周期性的波导段和通用的非周期性耦合器；时域有限差分法（FDTD）不能包含材料色散或损耗；光束传播法（BPM）无需近似即可精确求解全矢量麦克斯韦方程组，以同等保真度处理前向和后向波。\n\nD. 有限元法（FEM）仅适用于低折射率差，对硅光子学几何结构无效；光束传播法（BPM）是模拟光子晶体带隙和具有多重布拉格反射的强谐振光栅的最佳选择；本征模式求解器主要计算瞬态谐振器动力学而不是模式色散；严格耦合波分析（RCWA）是用于任意 $3$D 非周期性结构的通用时域积分器。\n\n选择唯一最佳选项，该选项与基本控制定律以及支撑每种方法在硅光子 PIC 建模中有效性范围的标准近似相一致。通过基于基本定律和每种数值公式的性质进行推理来证明您的选择，而不是基于特定工具的功能或启发式方法。",
            "solution": "问题陈述是计算电磁学中一个有效的练习，要求评估用于光子集成电路（PIC）建模的五种标准数值方法的核心公式和适用领域。该问题科学地基于麦克斯韦方程组，并且是适定的。我们将从第一性原理出发来评估每个选项。\n\n控制定律是线性介质中的麦克斯韦方程组：\n$$ \\nabla \\times \\mathbf{E}(\\mathbf{r},t) = -\\mu_0 \\frac{\\partial \\mathbf{H}(\\mathbf{r},t)}{\\partial t} $$\n$$ \\nabla \\times \\mathbf{H}(\\mathbf{r},t) = \\mathbf{J}(\\mathbf{r},t) + \\frac{\\partial \\mathbf{D}(\\mathbf{r},t)}{\\partial t} $$\n对于潜在色散介质的本构关系为 $\\mathbf{D}(\\mathbf{r},t) = \\epsilon(\\mathbf{r},\\omega)\\,\\mathbf{E}(\\mathbf{r},t)$，它通过介电常数 $\\epsilon$ 将位移场 $\\mathbf{D}$ 与电场 $\\mathbf{E}$ 联系起来，介电常数可能依赖于位置 $\\mathbf{r}$ 和角频率 $\\omega$。这些方程可以在时域或频域中求解，可以有或没有近似，从而产生了不同的数值方法。\n\n让我们确立每种方法的基本原理：\n\n1.  **时域有限差分法 (FDTD):** 该方法在空间网格（通常是交错的 Yee 网格）上直接离散化含时麦克斯韦旋度方程，并在离散的时间步长上将场（$\\mathbf{E}$ 和 $\\mathbf{H}$）向前推进。它不做任何波传播近似，因此求解的是全波问题。使用脉冲源的单次模拟可以通过傅里叶变换得到宽带频率响应。它自然地捕捉了所有波现象，包括传播、反射、折射、衍射和共振。\n\n2.  **有限元法 (FEM):** 该方法通常求解麦克斯韦方程组的时谐（频域）形式，这会得到一个亥姆霍兹型波动方程。问题域被剖分成一个由有限元组成的网格（例如，二维中的三角形，三维中的四面体），该网格可以贴合任意弯曲的边界。该方法求解一个从微分方程的“弱形式”导出的矩阵方程。对于单个频率是严格的，并且对于复杂几何形状非常准确。\n\n3.  **本征模式求解器:** 这些是专门的频域求解器，用于解决横截面沿传播方向（例如，$z$ 方向）均匀的波导的特定问题。通过假设形式为 $\\mathbf{E}(x,y,z) = \\mathbf{e}(x,y) e^{-j\\beta z}$ 的解，麦克斯韦方程组在横截面 $(x,y)$ 上简化为一个二维本征值问题。本征值给出导模的传播常数 $\\beta$，本征矢量是相应的模场分布 $\\mathbf{e}(x,y)$。\n\n4.  **光束传播法 (BPM):** 这是一种*近似*的频域方法。它从亥姆霍兹方程开始，并假设场可以表示为一个缓变包络函数乘以一个前向传播的平面波，即 $\\mathbf{E}(x,y,z) = \\mathbf{u}(x,y,z) e^{-j\\beta_0 z}$。在缓变包络近似（SVEA）下，包络相对于传播方向 $z$ 的二阶导数被忽略（$\\partial^2 \\mathbf{u} / \\partial z^2 \\approx 0$）。这个关键近似将问题简化为一个可以沿 $z$ 方向高效推进的初值问题。然而，它从根本上忽略了后向反射，并且仅对相对于主轴的小传播角以及弱导或缓变结构有效。\n\n5.  **严格耦合波分析 (RCWA):** 也称为傅里叶模态法（FMM），这是一种专门为在一个或多个维度上具有周期性结构（例如衍射光栅、光子晶体）设计的频域技术。它将材料介电常数和电磁场都展开为傅里叶级数。将这些级数代入麦克斯韦方程组，将微分方程转换为傅里叶空间中的矩阵本征值问题。它被认为是“严格的”，因为它考虑了所有衍射级数，并且对其目标问题类别非常高效。\n\n现在，我们根据这些既定原则评估每个选项。\n\n**选项 A 评估:**\n- **FDTD:** 描述为在“交错网格上对时域中的全矢量麦克斯韦方程组进行积分，捕捉复杂 $3$D 几何结构中的宽带响应、瞬态和反射”。这是对 FDTD 方法的公式和能力的精确且正确的总结。\n- **BPM:** 描述为应用“前向传播、缓变包络/傍轴近似，非常适合具有小角度传播的长、弱变化结构，当出现强后向反射或反向传播波时通常无效”。这正确地指出了核心近似（SVEA）及其对方法有效性范围的直接影响。\n- **FEM:** 描述为求解“使用非结构化网格的频域麦克斯韦方程组的弱形式，能够处理弯曲边界和高折射率差”。这是对现代 FEM 公式及其主要优点的正确描述。\n- **本征模式求解器:** 描述为通过“求解均匀或分段均匀波导中矢量场的横截面本征值问题来计算导模和传播常数”。这正是本征模式求解器功能的准确定义。\n- **RCWA:** 描述为将“场和介电常数展开为傅里叶级数以求解周期性介质中的散射问题，使其适用于光栅和光子晶体元件，但不适用于强非周期性的孤立弯曲”。这正确地指出了傅里叶基、对周期性介质的适用性以及对非周期性结构的相应限制。\n此选项中的每一项陈述都是科学准确的，并且与对这些方法的基本理解相一致。\n**结论：正确**\n\n**选项 B 评估:**\n- **FDTD:** “是一种频域谐波求解器，仅限于窄带分析，不能捕捉瞬态或反射”。这从根本上是错误的。FDTD 是一种时域、宽带方法，它内在地捕捉反射和瞬态。\n- **BPM:** “可靠地模拟突变不连续处的强后向反射和驻波”。这与事实正好相反。BPM 的核心近似明确忽略了后向反射。\n- **FEM:** “仅限于直线均匀网格，且在处理弯曲边界时性能不佳”。这是错误的。FEM 的标志性优势在于其处理弯曲边界的非结构化网格的灵活性。该描述更适用于基本的有限差分法。\n- **本征模式求解器:** “需要周期性边界条件，并且主要用于光栅模拟”。这是不正确的。本征模式求解器用于均匀波导，而光栅模拟是 RCWA 的主要应用。\n- **RCWA:** “对于高度非周期性的波导弯曲和锥形结构是首选”。这是错误的。RCWA 是为周期性结构设计的。\n每一项陈述都与事实不符。\n**结论：错误**\n\n**选项 C 评估:**\n- **本征模式求解器:** “在任意激励下对完整的时间演化进行积分...以产生瞬态场动力学”。这是错误的。这描述的是像 FDTD 这样的时域求解器，而不是频域本征值求解器。\n- **RCWA:** “最适合均匀、非周期性的波导段”。这是错误的。RCWA 用于周期性结构。本征模式求解器处理均匀的非周期性段。\n- **FDTD:** “不能包含材料色散或损耗”。这是错误的。标准的 FDTD 算法通过辅助微分方程或递归卷积技术来包含色散和损耗。\n- **BPM:** “无需近似即可精确求解全矢量麦克斯韦方程组...处理前向和后向波”。这从根本上是错误的。BPM 是一种近似方法，其定义正是因为它忽略了后向波。\n多项陈述明显错误。\n**结论：错误**\n\n**选项 D 评估:**\n- **FEM:** “仅适用于低折射率差，对硅光子学几何结构无效”。这是错误的。FEM 能够很好地处理高折射率差的几何结构，如绝缘体上硅。\n- **BPM:** “是模拟光子晶体带隙和强谐振光栅的最佳选择”。这是错误的。这些现象主要由多重散射和反射主导，而 BPM 正是设计用来忽略这些的。这是 FDTD 或 RCWA 的领域。\n- **本征模式求解器:** “主要计算瞬态谐振器动力学而不是模式色散”。这与其目的正好相反。它们计算波导的模式特性，如色散（$\\beta(\\omega)$）；瞬态动力学是时域方法的任务。\n- **RCWA:** “是用于任意 $3$D 非周期性结构的通用时域积分器”。这是错误的。RCWA 是一种用于周期性结构的频域方法。所给的描述更适合 FDTD。\n每一项陈述都与事实不符。\n**结论：错误**\n\n基于严谨的分析，只有选项 A 提供了一组描述，其中每一项陈述都是科学正确的，并准确反映了每种数值方法的公式和有效适用范围。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "将电路原理图（schematic）转化为物理版图（layout）是PIC设计流程中至关重要但又容易出错的一环。这个实践将让你体验电子设计自动化（EDA）工具开发者的工作，即编写一个算法来自动验证版图的连通性是否与预期的原理图一致。你将基于光传播的物理原理来实现一系列几何和逻辑规则，以确保最终制造的芯片能精确符合设计意图。",
            "id": "4289020",
            "problem": "给定一个光子集成电路版图的几何描述和一个有向原理图连接图。该版图由多段线波导和带有位置与方向标注的元件端口组成。您的任务是编写一个程序，从版图中提取有向连接性（包括波导方向和传播方向），并根据原理图连接图进行验证。程序必须为每个测试用例计算一个布尔值判定结果。\n\n使用的基本原理和定义：\n- 光子集成电路（PIC）的连接性由电磁能量流决定，其由坡印亭矢量 $\\mathbf{S} = \\mathbf{E} \\times \\mathbf{H}$ 表示，其中 $\\mathbf{E}$ 是电场，$\\mathbf{H}$ 是磁场。在单模介质波导中，时间平均的能量传播方向与沿波导轴线的群速度矢量一致，该矢量在端口界面处与波导的切线方向重合。这为有效连接提供了物理基础，即端口方向必须与局部波导切线方向对齐。\n- 用于光子版图与原理图比对的电子设计自动化（EDA）验证，会比较两个有向图：一个是从几何和方向约束中提取的，另一个是作为预期原理图提供的。\n- 图论定义：一个有向图 $G = (V, E)$ 具有顶点集 $V$（端口）和边集 $E \\subseteq V \\times V$（从输出端口到输入端口的有向连接）。在本问题中，两个有向图相等意味着当顶点标签为端口标识符时，它们的边集相等。\n\n您必须实现的几何和算法规则：\n1. 端口是带有以下标注的对象：\n   - 标识符字符串（例如，“L:out”）、类型（“input”或“output”）、以微米为单位的位置 $(x, y)$，以及从 $+\\hat{x}$ 轴逆时针测量的方向角 $\\theta_p$（以度为单位）。\n2. 每个波导是一个多段线 $P = [\\mathbf{r}_0, \\mathbf{r}_1, \\ldots, \\mathbf{r}_n]$，其两个端点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_n$ 的坐标以微米为单位给出。对于端点 $\\mathbf{r}_0$，远离端口并指向波导内部的局部切线是 $\\mathbf{t}_0 = \\mathbf{r}_1 - \\mathbf{r}_0$。对于另一个端点 $\\mathbf{r}_n$，远离端口并指向波导内部的局部切线是 $\\mathbf{t}_n = \\mathbf{r}_{n-1} - \\mathbf{r}_n$。\n3. 如果波导端点与端口位置之间的欧几里得距离 $\\leq \\Delta r$（其中 $\\Delta r$ 是位置容差），则认为该端点与端口相连。如果多个端口位于同一端点的 $\\Delta r$ 范围内，则该端点的连接是模糊的，必须视为对该波导无效。\n4. 方向一致性：对于一个已连接的端点，计算切线角度 $\\theta_t = \\arctan2(t_y, t_x)$（以度为单位），并归一化到 $[0, 360)$。端口方向 $\\theta_p$ 必须在角度容差 $\\Delta \\theta$ 内与 $\\theta_t$ 对齐，使用圆上的最小环绕差，即 $d(\\theta_p, \\theta_t) = \\min\\left(|\\theta_p - \\theta_t|, 360 - |\\theta_p - \\theta_t|\\right) \\leq \\Delta \\theta$。\n5. 有向连接性提取：对于每个两端都有效连接且方向检查均通过的波导，创建一个从端口类型为“output”的端点到端口类型为“input”的端点的有向边。如果两端类型均为“output”或均为“input”，则不为该波导创建有向边。\n6. 验证标准：从版图中提取的边集必须与原理图的边集相等，判定结果才为真。\n\n角度单位要求：所有角度计算均使用度。位置单位要求：所有坐标均使用微米。容差以微米和度为单位提供。\n\n您的程序必须实现上述规则并处理以下测试套件。对于每个测试用例，返回一个布尔值，指示从版图提取的有向连接性是否与原理图完全匹配。\n\n测试套件：\n- 案例 1（理想路径，直线连接）：\n  - 容差：$\\Delta r = 0.5\\,\\mu\\mathrm{m}$，$\\Delta \\theta = 5^\\circ$。\n  - 端口：\n    - \"L:out\"：类型 \"output\"，位置 $(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 0^\\circ$。\n    - \"M:in\"：类型 \"input\"，位置 $(100\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 180^\\circ$。\n  - 波导：\n    - $P_1 = [(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m}), (50\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m}), (100\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})]$。\n  - 原理图有向边：$\\{(\\text{\"L:out\"}, \\text{\"M:in\"})\\}$。\n\n- 案例 2（通过分束器分支，多条边）：\n  - 容差：$\\Delta r = 0.5\\,\\mu\\mathrm{m}$，$\\Delta \\theta = 5^\\circ$。\n  - 端口：\n    - \"L:out\"：类型 \"output\"，位置 $(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 0^\\circ$。\n    - \"S:in\"：类型 \"input\"，位置 $(50\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 180^\\circ$。\n    - \"S:out1\"：类型 \"output\"，位置 $(50\\,\\mu\\mathrm{m}, 10\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 0^\\circ$。\n    - \"S:out2\"：类型 \"output\"，位置 $(50\\,\\mu\\mathrm{m}, -10\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 0^\\circ$。\n    - \"M1:in\"：类型 \"input\"，位置 $(100\\,\\mu\\mathrm{m}, 10\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 180^\\circ$。\n    - \"M2:in\"：类型 \"input\"，位置 $(100\\,\\mu\\mathrm{m}, -10\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 180^\\circ$。\n  - 波导：\n    - $P_1 = [(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m}), (50\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})]$。\n    - $P_2 = [(50\\,\\mu\\mathrm{m}, 10\\,\\mu\\mathrm{m}), (100\\,\\mu\\mathrm{m}, 10\\,\\mu\\mathrm{m})]$。\n    - $P_3 = [(50\\,\\mu\\mathrm{m}, -10\\,\\mu\\mathrm{m}), (100\\,\\mu\\mathrm{m}, -10\\,\\mu\\mathrm{m})]$。\n  - 原理图有向边：$\\{(\\text{\"L:out\"}, \\text{\"S:in\"}), (\\text{\"S:out1\"}, \\text{\"M1:in\"}), (\\text{\"S:out2\"}, \\text{\"M2:in\"})\\}$。\n\n- 案例 3（传播方向不匹配：两端均为输出，验证应失败）：\n  - 容差：$\\Delta r = 0.5\\,\\mu\\mathrm{m}$，$\\Delta \\theta = 5^\\circ$。\n  - 端口：\n    - \"L1:out\"：类型 \"output\"，位置 $(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 0^\\circ$。\n    - \"L2:out\"：类型 \"output\"，位置 $(100\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 180^\\circ$。\n  - 波导：\n    - $P_1 = [(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m}), (100\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})]$。\n  - 原理图有向边：$\\{(\\text{\"L1:out\"}, \\text{\"L2:in\"})\\}$。\n\n- 案例 4（边界情况：方向在 $360^\\circ$ 附近环绕）：\n  - 容差：$\\Delta r = 0.5\\,\\mu\\mathrm{m}$，$\\Delta \\theta = 5^\\circ$。\n  - 端口：\n    - \"L:out\"：类型 \"output\"，位置 $(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 355^\\circ$。\n    - \"M:in\"：类型 \"input\"，位置 $(100\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})$，方向 $\\theta_p = 180^\\circ$。\n  - 波导：\n    - $P_1 = [(0\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m}), (100\\,\\mu\\mathrm{m}, 0\\,\\mu\\mathrm{m})]$。\n  - 原理图有向边：$\\{(\\text{\"L:out\"}, \\text{\"M:in\"})\\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”），每个结果都是一个布尔值。不允许有其他输出。",
            "solution": "用户提供的问题陈述已经过评估并被确定为有效。它在科学上基于介质波导中电磁波传播的原理，在算法上是适定的，并使用客观、可形式化的语言表达。该问题提供了一套自洽的规则、定义和测试数据，从而可以开发一个确定性的验证程序。未检测到矛盾、歧义或事实不健全之处。\n\n解决此问题需要为光子集成电路实现版图与原理图比对（LVS）验证算法。该算法从几何版图中提取有向连接图，并将其与给定的原理图进行比较。该方法论分解为以下顺序步骤，并将为每个测试用例实现这些步骤。\n\n首先，我们表示版图和原理图数据。端口是包含标识符（字符串）、类型（'input' 或 'output'）、位置矢量 $\\mathbf{p} = (x, y)$ 和方向角 $\\theta_p$ 的结构。波导是由坐标矢量有序列表 $P = [\\mathbf{r}_0, \\mathbf{r}_1, \\ldots, \\mathbf{r}_n]$ 表示的多段线。原理图是一组有向边，其中每条边是端口标识符的元组（源，目标）。\n\n验证过程的核心是从版图几何中提取有向图。这是通过遍历每个波导并对其两个端点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_n$ 应用一系列检查来执行的。\n\n1.  **端点到端口的关联：** 对于每个波导端点（$\\mathbf{r}_0$ 或 $\\mathbf{r}_n$），我们必须识别一个唯一的连接端口。\n    - 如果一个位置为 $\\mathbf{p}_i$ 的端口 $i$ 与一个端点 $\\mathbf{r}_j$ 之间的欧几里得距离在指定的容差 $\\Delta r$ 之内，则该端口是连接到该端点的候选者。距离计算为 $d(\\mathbf{p}_i, \\mathbf{r}_j) = \\sqrt{(p_{ix} - r_{jx})^2 + (p_{iy} - r_{jy})^2} \\le \\Delta r$。\n    - 仅当恰好有一个端口满足此距离标准时，连接才被视为有效。如果在容差半径内找到零个或多个端口，则连接是模糊的，该波导将被取消形成任何边的资格。\n\n2.  **方向一致性验证：** 如果为波导的两个端点都找到了唯一的端口，则每个端口的方向必须与波导的局部方向一致。\n    - 对于第一个端点 $\\mathbf{r}_0$，代表能量流远离端口方向的局部波导切线矢量定义为 $\\mathbf{t}_0 = \\mathbf{r}_1 - \\mathbf{r}_0$。\n    - 对于最后一个端点 $\\mathbf{r}_n$，切线矢量定义为 $\\mathbf{t}_n = \\mathbf{r}_{n-1} - \\mathbf{r}_n$。\n    - 每个切线矢量 $\\mathbf{t} = (t_x, t_y)$ 的角度 $\\theta_t$ 使用四象限反正切函数 $\\theta_t = \\arctan2(t_y, t_x)$ 计算。此角度会转换为度，并归一化到 $[0, 360)$ 范围。\n    - 为使连接有效，端口的方向 $\\theta_p$ 必须与相应的切线角度 $\\theta_t$ 对齐。这通过确保圆上的最小角度差在角度容差 $\\Delta \\theta$ 内来检查。该差值计算为 $d(\\theta_p, \\theta_t) = \\min(|\\theta_p - \\theta_t|, 360 - |\\theta_p - \\theta_t|) \\le \\Delta \\theta$。\n    - 如果任一端点的方向检查失败，则该波导不合格。\n\n3.  **有向边形成：** 如果一个波导在其两个端点上都通过了唯一连接和方向一致性检查，我们确定它所代表的有向边。\n    - 设两个连接的端口为端口 A 和端口 B。\n    - 有向边从 'output' 端口形成到 'input' 端口。\n    - 如果端口 A 的类型是 'output' 而端口 B 的类型是 'input'，则将一个有向边（端口 A 标识符，端口 B 标识符）添加到提取的边集合中。\n    - 反之，如果端口 B 是 'output' 而端口 A 是 'input'，则添加边（端口 B 标识符，端口 A 标识符）。\n    - 如果两个端口具有相同的类型（例如，'input'-'input' 或 'output'-'output'），则不会形成有向边，因为这不代表两个不同组件之间的有效有向能量流。\n\n4.  **最终验证：** 处理完所有波导后，将生成的提取有向边集与为该测试用例提供的原理图边集进行比较。当且仅当这两个集合相同时，该测试用例的验证判定结果为真。这包括具有相同数量的边以及每条边具有相同的源和目标。\n\n该程序将系统地应用于所提供套件中的每个测试用例，以生成最终的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"tolerances\": {\"delta_r\": 0.5, \"delta_theta\": 5.0},\n            \"ports\": {\n                \"L:out\": {\"type\": \"output\", \"pos\": (0.0, 0.0), \"angle\": 0.0},\n                \"M:in\": {\"type\": \"input\", \"pos\": (100.0, 0.0), \"angle\": 180.0},\n            },\n            \"waveguides\": [\n                [(0.0, 0.0), (50.0, 0.0), (100.0, 0.0)]\n            ],\n            \"schematic_edges\": {(\"L:out\", \"M:in\")},\n        },\n        {\n            \"case_id\": 2,\n            \"tolerances\": {\"delta_r\": 0.5, \"delta_theta\": 5.0},\n            \"ports\": {\n                \"L:out\": {\"type\": \"output\", \"pos\": (0.0, 0.0), \"angle\": 0.0},\n                \"S:in\": {\"type\": \"input\", \"pos\": (50.0, 0.0), \"angle\": 180.0},\n                \"S:out1\": {\"type\": \"output\", \"pos\": (50.0, 10.0), \"angle\": 0.0},\n                \"S:out2\": {\"type\": \"output\", \"pos\": (50.0, -10.0), \"angle\": 0.0},\n                \"M1:in\": {\"type\": \"input\", \"pos\": (100.0, 10.0), \"angle\": 180.0},\n                \"M2:in\": {\"type\": \"input\", \"pos\": (100.0, -10.0), \"angle\": 180.0},\n            },\n            \"waveguides\": [\n                [(0.0, 0.0), (50.0, 0.0)],\n                [(50.0, 10.0), (100.0, 10.0)],\n                [(50.0, -10.0), (100.0, -10.0)],\n            ],\n            \"schematic_edges\": {\n                (\"L:out\", \"S:in\"), \n                (\"S:out1\", \"M1:in\"), \n                (\"S:out2\", \"M2:in\")\n            },\n        },\n        {\n            \"case_id\": 3,\n            \"tolerances\": {\"delta_r\": 0.5, \"delta_theta\": 5.0},\n            \"ports\": {\n                \"L1:out\": {\"type\": \"output\", \"pos\": (0.0, 0.0), \"angle\": 0.0},\n                \"L2:out\": {\"type\": \"output\", \"pos\": (100.0, 0.0), \"angle\": 180.0},\n            },\n            \"waveguides\": [\n                [(0.0, 0.0), (100.0, 0.0)]\n            ],\n            \"schematic_edges\": {(\"L1:out\", \"L2:in\")},\n        },\n        {\n            \"case_id\": 4,\n            \"tolerances\": {\"delta_r\": 0.5, \"delta_theta\": 5.0},\n            \"ports\": {\n                \"L:out\": {\"type\": \"output\", \"pos\": (0.0, 0.0), \"angle\": 355.0},\n                \"M:in\": {\"type\": \"input\", \"pos\": (100.0, 0.0), \"angle\": 180.0},\n            },\n            \"waveguides\": [\n                [(0.0, 0.0), (100.0, 0.0)]\n            ],\n            \"schematic_edges\": {(\"L:out\", \"M:in\")},\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        verdict = verify_layout(case)\n        results.append(verdict)\n\n    # Convert boolean to lower case for Python compatibility\n    str_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\ndef verify_layout(case_data):\n    \"\"\"\n    Performs layout vs. schematic verification for a single case.\n    \"\"\"\n    ports = case_data[\"ports\"]\n    waveguides = case_data[\"waveguides\"]\n    tolerances = case_data[\"tolerances\"]\n    schematic_edges = case_data[\"schematic_edges\"]\n    \n    extracted_edges = set()\n\n    for wg in waveguides:\n        wg_polyline = [np.array(p) for p in wg]\n        \n        # Endpoints of the waveguide\n        r0, rn = wg_polyline[0], wg_polyline[-1]\n\n        # 1. Endpoint-to-Port Association and Ambiguity Check\n        connected_ports_r0 = []\n        for port_id, port_data in ports.items():\n            if np.linalg.norm(r0 - np.array(port_data[\"pos\"])) = tolerances[\"delta_r\"]:\n                connected_ports_r0.append(port_id)\n        \n        if len(connected_ports_r0) != 1:\n            continue  # Ambiguous or no connection at r0\n\n        connected_ports_rn = []\n        for port_id, port_data in ports.items():\n            if np.linalg.norm(rn - np.array(port_data[\"pos\"])) = tolerances[\"delta_r\"]:\n                connected_ports_rn.append(port_id)\n        \n        if len(connected_ports_rn) != 1:\n            continue  # Ambiguous or no connection at rn\n            \n        port0_id = connected_ports_r0[0]\n        portn_id = connected_ports_rn[0]\n\n        # 2. Orientation Consistency Verification\n        # For endpoint r0\n        t0 = wg_polyline[1] - r0\n        theta_t0 = (math.degrees(np.arctan2(t0[1], t0[0])) + 360) % 360\n        theta_p0 = ports[port0_id][\"angle\"]\n        angle_diff0 = abs(theta_p0 - theta_t0)\n        min_angle_diff0 = min(angle_diff0, 360 - angle_diff0)\n        \n        if min_angle_diff0 > tolerances[\"delta_theta\"]:\n            continue\n\n        # For endpoint rn\n        tn = wg_polyline[-2] - rn\n        theta_tn = (math.degrees(np.arctan2(tn[1], tn[0])) + 360) % 360\n        theta_pn = ports[portn_id][\"angle\"]\n        angle_diffn = abs(theta_pn - theta_tn)\n        min_angle_diffn = min(angle_diffn, 360 - angle_diffn)\n\n        if min_angle_diffn > tolerances[\"delta_theta\"]:\n            continue\n\n        # 3. Directed Edge Formation\n        port0_type = ports[port0_id][\"type\"]\n        portn_type = ports[portn_id][\"type\"]\n\n        if port0_type == \"output\" and portn_type == \"input\":\n            extracted_edges.add((port0_id, portn_id))\n        elif port0_type == \"input\" and portn_type == \"output\":\n            extracted_edges.add((portn_id, port0_id))\n\n    # 4. Final Verification\n    return extracted_edges == schematic_edges\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "当一个光子集成电路制造完成后，需要通过测量来表征其性能，但测量结果常会受到噪声和系统误差的干扰。这项高级实践将深入探讨实验数据的后处理技术，利用物理学中的因果律基本原理——具体体现为克拉默-克若尼关系（Kramers-Kronig relations）——来验证和校正测得的散射参数（S-parameters）。对于从实验数据中建立精确的器件模型而言，这项任务至关重要。",
            "id": "4289042",
            "problem": "给定一个无源线性光子集成电路的单输入单输出传输路径 $S_{21}$ 的散射参数（S参数）随角频率变化的合成测量数据。对于一个因果线性时不变系统，其复传递函数 $H(\\omega)$ 的幅度 $|H(\\omega)|$ 和相位 $\\phi(\\omega)$ 不是独立的；由因果性保证的解析性意味着它们的倒数关系可以通过在幅度的对数和最小相位分量之间使用希尔伯特变换，通过 Kramers–Kronig 一致性来重建。在硅光子学中，当测量相位含有噪声或已损坏时，这种一致性对于从幅度数据中准确推断相位和群延迟至关重要。您的任务是实现一个程序，通过使用希尔伯特变换从测量的幅度重建相位来强制实现 Kramers–Kronig 一致性，然后通过拟合并强制施加一个物理上允许的线性延迟项来校正因果性差异。所有相位的角度单位必须是弧度，群延迟必须以秒为单位表示。\n\n从一个因果线性时不变系统具有一个复频率响应 $H(\\omega)$（它是上半平面解析函数的边界值）这一基本原理出发，可知 $|H(\\omega)|$ 的对数与最小相位 $\\phi_{\\mathrm{min}}(\\omega)$ 通过关于 $\\omega$ 的希尔伯特变换相关联。此外，纯时间延迟会引入一个关于 $\\omega$ 的线性相位项，该项不影响幅度。您必须从对称角频率网格上的幅度对数重建最小相位分量，然后拟合线性相位项 $-\\omega \\tau + \\phi_{0}$，以使重建的相位与测量的解卷绕相位最佳对齐。为了校正因果性差异，请在给定上下文中对无源介质强制施加约束 $\\tau \\ge 0$。\n\n该程序必须为每个测试用例实现以下步骤：\n- 构建一个对称的角频率网格 $\\omega$，在 $-\\Omega_{\\max}$ 到 $+\\Omega_{\\max}$ 范围内包含 $N$ 个均匀间隔的采样点。每个测试用例使用提供的 $N$ 和 $\\Omega_{\\max}$ 值。\n- 使用提供的测量幅度 $|S_{21}(\\omega)|$ 和卷绕相位 $\\psi(\\omega)$ 来计算：\n    1. 通过在对称网格上对 $\\ln |S_{21}(\\omega)|$ 应用希尔伯特变换，计算出符合 Kramers–Kronig 一致性的最小相位估计值 $\\phi_{\\mathrm{KK}}(\\omega)$。\n    2. 从 $\\psi(\\omega)$ 计算出解卷绕的测量相位 $\\Psi(\\omega)$。\n    3. 通过最小化 $\\Psi(\\omega)$ 与 $\\phi_{\\mathrm{KK}}(\\omega) - \\omega \\tau + \\phi_{0}$ 之间的平方误差，来求解最佳拟合的线性延迟参数 $\\tau$ 和偏移量 $\\phi_{0}$。强制施加 $\\tau \\ge 0$。\n- 以所需的格式，将每个用例估计出的 $\\tau$ 值（单位为秒）作为浮点数输出到单行中。\n\n角度单位：弧度。群延迟的答案单位：秒。\n\n测试套件规范（每个测试用例都已完全定义，并且必须嵌入到程序中；不要请求任何用户输入）：\n- 情况1（理想情况，平坦幅度加纯延迟）：\n    - $N = 4096$，$\\Omega_{\\max} = 5 \\times 10^{11}$ $\\mathrm{rad/s}$。\n    - 对所有 $\\omega$，$|S_{21}(\\omega)| = 0.9$。\n    - 真实延迟 $\\tau_{\\mathrm{true}} = 5.0 \\times 10^{-11}$ $\\mathrm{s}$。\n    - 测量相位构建为 $\\psi(\\omega) = \\operatorname{wrap}\\left(-\\omega \\tau_{\\mathrm{true}} + \\epsilon(\\omega)\\right)$，其中 $\\epsilon(\\omega)$ 是在每个频率采样点上独立施加的、标准差为 $5 \\times 10^{-3}$ 弧度的零均值高斯小噪声，$\\operatorname{wrap}(\\cdot)$ 将值映射到 $(-\\pi,\\pi]$ 内的主值。\n- 情况2（幅度由一阶低通特性和附加延迟共同决定）：\n    - $N = 4096$，$\\Omega_{\\max} = 5 \\times 10^{11}$ $\\mathrm{rad/s}$，截止频率 $\\omega_{c} = 1.5 \\times 10^{11}$ $\\mathrm{rad/s}$。\n    - $|S_{21}(\\omega)| = \\dfrac{0.8}{\\sqrt{1 + \\left(\\dfrac{\\omega}{\\omega_{c}}\\right)^{2}}}$。\n    - 真实延迟 $\\tau_{\\mathrm{true}} = 1.0 \\times 10^{-11}$ $\\mathrm{s}$。\n    - 测量相位构建为 $\\psi(\\omega) = \\operatorname{wrap}\\left(\\phi_{\\mathrm{min}}(\\omega) - \\omega \\tau_{\\mathrm{true}} + \\epsilon(\\omega)\\right)$，其中 $\\phi_{\\mathrm{min}}(\\omega)$ 是一阶低通特性的物理一致最小相位，$\\epsilon(\\omega)$ 是标准差为 $5 \\times 10^{-3}$ 弧度的高斯噪声。\n- 情况3（边缘情况，测量的相位中存在待校正的非因果性纹波）：\n    - $N = 4096$，$\\Omega_{\\max} = 5 \\times 10^{11}$ $\\mathrm{rad/s}$。\n    - 对所有 $\\omega$，$|S_{21}(\\omega)| = 0.85$。\n    - 真实延迟 $\\tau_{\\mathrm{true}} = 2.5 \\times 10^{-11}$ $\\mathrm{s}$。\n    - 测量相位构建为 $\\psi(\\omega) = \\operatorname{wrap}\\left(-\\omega \\tau_{\\mathrm{true}} + 0.2 \\sin\\left(2\\pi \\dfrac{\\omega}{\\Omega_{\\max}}\\right) + \\epsilon(\\omega)\\right)$，高斯噪声标准差为 $5 \\times 10^{-3}$ 弧度。正弦项模拟了由仪器引起的非因果性纹波，该纹波将通过强制执行 Kramers–Kronig 关系外加因果线性校正来移除。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"），列表中的条目分别是根据所述过程计算出的情况1、情况2和情况3的估计群延迟 $\\tau$（单位为秒）。所有中间量必须以弧度处理相位，以 $\\mathrm{rad/s}$ 处理角频率，最终报告的延迟必须是以秒为单位的浮点数。",
            "solution": "这项任务是验证并强制执行无源线性光子集成电路的合成散射参数（$S$-参数）测量的 Kramers-Kronig 一致性。这包括从传递函数的幅度重建其相位，并随后提取一个物理上可接受的群延迟。此过程在信号处理和物理学中是基础性的，用以确保系统模型遵循因果性原理。\n\n这个问题的基础在于因果、线性、时不变（LTI）系统的特性。这类系统的复频率响应或传递函数，记作 $H(\\omega)$，对于 $\\sigma  0$ 必须是复频率变量 $\\tilde{\\omega} = \\omega + i\\sigma$ 在上半平面的解析函数。这种解析性的一个直接数学推论是 Kramers-Kronig 关系，它将实频率轴上 $H(\\omega)$ 的实部和虚部联系起来。\n\n将传递函数用其幅度 $|H(\\omega)|$ 和相位 $\\phi(\\omega)$ 表示为 $H(\\omega) = |H(\\omega)|e^{i\\phi(\\omega)}$。为了以常见形式应用 Kramers-Kronig 关系，我们考虑传递函数的对数，$\\ln H(\\omega) = \\ln|H(\\omega)| + i\\phi(\\omega)$。由于 $H(\\omega)$ 在上半平面是解析且非零的（最小相位假设），$\\ln H(\\omega)$ 也是解析的。这意味着其实部 $\\ln|H(\\omega)|$ 和虚部 $\\phi(\\omega)$ 通过希尔伯特变换相关联。\n\n一个系统的总相位 $\\phi(\\omega)$ 可以分解为两部分：一个最小相位分量 $\\phi_{\\mathrm{min}}(\\omega)$ 和一个全通分量 $\\phi_{\\mathrm{ap}}(\\omega)$。最小相位分量由幅度 $|H(\\omega)|$ 唯一确定，而全通分量在所有频率下的幅度均为1，仅对相位有贡献。其关系如下：\n$$\n\\phi(\\omega) = \\phi_{\\mathrm{min}}(\\omega) + \\phi_{\\mathrm{ap}}(\\omega)\n$$\n最小相位分量通过对幅度对数进行希尔伯特变换 ($\\mathcal{H}$) 来计算：\n$$\n\\phi_{\\mathrm{min}}(\\omega) = \\mathcal{H}\\{\\ln|H(\\omega')|\\}(\\omega) = \\frac{1}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{\\ln|H(\\omega')|}{\\omega' - \\omega} d\\omega'\n$$\n其中 $\\mathcal{P}$ 表示积分的柯西主值。问题将此重建的最小相位称为 $\\phi_{\\mathrm{KK}}(\\omega)$。\n\n一个常见且物理上重要的全通滤波器是纯时间延迟，其特征是传递函数 $H_d(\\omega) = e^{-i\\omega\\tau}$。该分量引入了线性相移 $\\phi_d(\\omega) = -\\omega\\tau$，其中 $\\tau$ 是群延迟。对于无源系统，因果性要求群延迟 $\\tau$ 必须为非负值 ($\\tau \\ge 0$)。\n\n问题提供了幅度 $|S_{21}(\\omega)|$ 和卷绕相位 $\\psi(\\omega)$ 的合成测量数据。任务是找到与此数据一致的最可能的因果模型。总解卷绕相位 $\\Psi(\\omega)$ 的模型为：\n$$\n\\Psi(\\omega) \\approx \\phi_{\\mathrm{KK}}(\\omega) - \\omega\\tau + \\phi_0\n$$\n此处，$\\phi_{\\mathrm{KK}}(\\omega)$ 是通过 Kramers–Kronig 关系重建的最小相位，$-\\omega\\tau$ 是群延迟 $\\tau$ 贡献的相位，$\\phi_0$ 是一个恒定的相位偏移。我们的目标是确定 $\\tau$ 的值。\n\n解决每个测试用例的算法步骤如下：\n\n1.  **网格和数据生成**：构建一个对称的角频率网格 $\\omega$，在 $-\\Omega_{\\max}$ 到 $\\Omega_{\\max}$ 之间有 $N$ 个点。根据每个测试用例的规范生成合成幅度 $|S_{21}(\\omega)|$ 和卷绕相位 $\\psi(\\omega)$。\n\n2.  **最小相位重建**：从幅度数据计算最小相位分量 $\\phi_{\\mathrm{KK}}(\\omega)$。首先，我们计算对数幅度 $A(\\omega) = \\ln|S_{21}(\\omega)|$。然后，我们对 $A(\\omega)$ 应用希尔伯特变换。在数值上，这可以使用快速傅里叶变换（FFT）高效而准确地完成。`scipy.signal.hilbert` 函数计算解析信号 $A(\\omega) + i\\mathcal{H}\\{A(\\omega)\\}$，因此其输出的虚部即为 $\\phi_{\\mathrm{KK}}(\\omega)$。\n    $$\n    \\phi_{\\mathrm{KK}}(\\omega) = \\operatorname{Im}(\\text{scipy.signal.hilbert}(\\ln|S_{21}(\\omega)|))\n    $$\n\n3.  **相位解卷绕**：提供的测量相位 $\\psi(\\omega)$ 被卷绕在 $(-\\pi, \\pi]$ 区间内。为了进行有意义的拟合，必须将其解卷绕成一个连续函数 $\\Psi(\\omega)$。这是通过对相位的某些段落加上 $2\\pi$ 的整数倍来消除跳变，这是 `numpy.unwrap` 中实现的一个标准过程。\n\n4.  **约束线性拟合**：我们通过最小化解卷绕的测量相位与我们的模型之间的平方误差和来确定群延迟 $\\tau$ 和偏移量 $\\phi_0$。误差残差为 $r_i = \\Psi(\\omega_i) - (\\phi_{\\mathrm{KK}}(\\omega_i) - \\omega_i \\tau + \\phi_0)$。为了适用于标准线性最小二乘问题，我们重新整理公式，寻求将校正后的相位差 $y(\\omega) = \\Psi(\\omega) - \\phi_{\\mathrm{KK}}(\\omega)$ 拟合为一个关于频率的线性函数：\n    $$\n    y(\\omega_i) \\approx \\phi_0 - \\tau \\omega_i\n    $$\n    这是一个寻找参数 $\\tau$ 和 $\\phi_0$ 的线性回归问题。一个关键的约束是因果性，即 $\\tau \\ge 0$。这将问题转化为一个约束最小二乘优化问题。我们寻求找到 $\\beta = [\\tau, \\phi_0]^T$ 来最小化 $\\| \\mathbf{A}\\beta - \\mathbf{y} \\|_2^2$，约束条件为 $\\tau \\ge 0$，其中 $\\mathbf{y}$ 是 $y(\\omega_i)$ 值的向量，$\\mathbf{A}$ 是设计矩阵，其列为 $[-\\omega, \\mathbf{1}]$。这个问题可以使用像 `scipy.optimize.lsq_linear` 这样的函数来解决。\n\n通过对每个指定的测试用例执行此过程，我们可以估计出群延迟 $\\tau$，该值使系统模型既与测量的幅度一致，又符合因果性基本原理。\n\n-   **情况1** 测试从平坦幅度响应中恢复纯延迟的能力，此时 $\\phi_{\\mathrm{KK}}(\\omega)$ 理想情况下为零。\n-   **情况2** 涉及一个频率相关的幅度，要求算法能正确地将最小相位贡献与线性延迟相位分离开。\n-   **情况3** 在测量的相位中引入了一个非因果性伪影（正弦纹波）。基于 KK 的拟合过程预计对此类伪影具有鲁棒性，能够通过平均效应将其消除，并提取出底层的因果线性延迟。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import hilbert\nfrom scipy.optimize import lsq_linear\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It defines the test cases, orchestrates the analysis for each,\n    and prints the final results in the required format.\n    \"\"\"\n    \n    # Define the test cases as per the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"N\": 4096,\n            \"Omega_max\": 5e11,\n            \"tau_true\": 5.0e-11,\n            \"noise_std_dev\": 5e-3,\n            \"description\": \"Happy path, flat magnitude with pure delay\"\n        },\n        {\n            \"id\": 2,\n            \"N\": 4096,\n            \"Omega_max\": 5e11,\n            \"omega_c\": 1.5e11,\n            \"tau_true\": 1.0e-11,\n            \"noise_std_dev\": 5e-3,\n            \"description\": \"Magnitude shaped by a first-order low-pass\"\n        },\n        {\n            \"id\": 3,\n            \"N\": 4096,\n            \"Omega_max\": 5e11,\n            \"tau_true\": 2.5e-11,\n            \"noise_std_dev\": 5e-3,\n            \"description\": \"Edge case with noncausal ripple\"\n        }\n    ]\n\n    results = []\n    # Seed the random number generator for reproducibility of noise\n    rng = np.random.default_rng(seed=42)\n\n    for case in test_cases:\n        N = case[\"N\"]\n        Omega_max = case[\"Omega_max\"]\n        \n        # 1. Construct a symmetric angular frequency grid\n        omega = np.linspace(-Omega_max, Omega_max, N)\n\n        # 2. Generate synthetic measured magnitude and phase for each case\n        if case[\"id\"] == 1:\n            s21_mag = np.full(N, 0.9)\n            tau_true = case[\"tau_true\"]\n            noise = rng.normal(0, case[\"noise_std_dev\"], N)\n            true_phase = -omega * tau_true + noise\n            s21_phase_wrapped = np.angle(np.exp(1j * true_phase))\n\n        elif case[\"id\"] == 2:\n            omega_c = case[\"omega_c\"]\n            s21_mag = 0.8 / np.sqrt(1 + (omega / omega_c)**2)\n            tau_true = case[\"tau_true\"]\n            noise = rng.normal(0, case[\"noise_std_dev\"], N)\n            phi_min = -np.arctan(omega / omega_c)\n            true_phase = phi_min - omega * tau_true + noise\n            s21_phase_wrapped = np.angle(np.exp(1j * true_phase))\n\n        elif case[\"id\"] == 3:\n            s21_mag = np.full(N, 0.85)\n            tau_true = case[\"tau_true\"]\n            noise = rng.normal(0, case[\"noise_std_dev\"], N)\n            # The sinusoidal term argument is 2*pi*omega/Omega_max as per spec.\n            # This means it completes 2 cycles from -Omega_max to +Omega_max.\n            ripple = 0.2 * np.sin(2 * np.pi * omega / Omega_max)\n            true_phase = -omega * tau_true + ripple + noise\n            s21_phase_wrapped = np.angle(np.exp(1j * true_phase))\n\n        # 3. Compute Kramers-Kronig minimum-phase estimate\n        log_mag = np.log(s21_mag)\n        # The Hilbert transform of the log-magnitude gives the minimum phase.\n        # scipy.signal.hilbert computes the analytic signal, whose imaginary part is the\n        # Hilbert transform of the real input.\n        phi_kk = np.imag(hilbert(log_mag))\n\n        # 4. Unwrap the measured phase\n        s21_phase_unwrapped = np.unwrap(s21_phase_wrapped)\n\n        # 5. Fit linear delay term using constrained least-squares\n        # We want to fit: s21_phase_unwrapped ≈ phi_kk - omega*tau + phi_0\n        # Rearranging for linear regression:\n        # y = s21_phase_unwrapped - phi_kk\n        # y ≈ -omega*tau + phi_0\n        y = s21_phase_unwrapped - phi_kk\n        \n        # We solve A * x = y, where x = [tau, phi_0]\n        # First column of A is for tau (-omega), second for phi_0 (1)\n        A = np.vstack([-omega, np.ones(N)]).T\n        \n        # Enforce causality constraint tau >= 0\n        bounds = ([0, -np.inf], [np.inf, np.inf])\n        \n        # Perform the bounded/constrained linear least-squares fit\n        res = lsq_linear(A, y, bounds=bounds)\n        \n        tau_estimated = res.x[0]\n        results.append(tau_estimated)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}