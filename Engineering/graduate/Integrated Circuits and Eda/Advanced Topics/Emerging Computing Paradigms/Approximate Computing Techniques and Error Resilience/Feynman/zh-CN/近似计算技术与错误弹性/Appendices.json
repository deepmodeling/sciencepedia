{
    "hands_on_practices": [
        {
            "introduction": "本练习将带您深入近似计算的核心，通过分析一个常见的硬件单元——乘法器。您将通过一个假设性的截断场景，亲手计算由近似技术所节省的能耗和引入的误差，从而具体地理解能量与精度之间的基本权衡关系 。这个练习旨在阐明近似设计背后的核心原理，而非描述一个特定的真实世界乘法器设计。",
            "id": "4256152",
            "problem": "考虑在电子设计自动化（EDA）背景下，一个为两个独立随机输入实现的互补金属氧化物半导体（CMOS）无符号阵列乘法器。设操作数为 $X$ 和 $Y$，每个操作数的位宽为 $n$ 位，其输入字在各个周期之间是独立同分布的，并且对于 $i,j \\in \\{0,1,\\dots,n-1\\}$，每个比特 $X_i$ 和 $Y_j$ 都遵循参数为 $1/2$ 的伯努利分布。精确乘法器通过使用双输入与门形成所有部分积 $p_{ij} = X_i Y_j$，并用一个加法网络将它们相加。\n\n一个近似乘法器会截断部分积阵列的 $k$ 个最低有效列。具体来说，近似乘积 $\\tilde{P}$ 是通过仅对权重满足 $2^{i+j} \\ge 2^{k}$ 的部分积 $p_{ij}$ 求和得到的，即它省略了所有满足 $i+j  k$ 的 $p_{ij}$。这种截断消除了相应的与门以及与被丢弃的部分积相关的所有后续开关活动。假设一个双输入与门每次翻转的动态能耗是一个已知常数 $E_{\\mathrm{AND}}$（单位为焦耳），并且跨周期的连续输入字是独立的，因此任何 $p_{ij}=X_i Y_j$ 从一个周期到下一个周期的翻转概率可以从概率论的第一性原理推导出来。\n\n在此模型下：\n- 期望平均绝对误差定义为 $\\mathrm{MAE} = \\mathbb{E}\\big[|P - \\tilde{P}|\\big]$，其中 $P = X \\cdot Y$ 是精确乘积。\n- 由于截断，每周期的期望节能是未被消除的与门消耗的期望动态能耗。\n\n使用CMOS开关的标准动态功率与能量关系 $E_{\\mathrm{dyn}} = \\alpha C V^{2}$ 每次翻转（对于每个与门，此项被吸收到常数 $E_{\\mathrm{AND}}$ 中），计算以下参数的每周期望节能和期望平均绝对误差：\n- 操作数位宽 $n = 16$，\n- 截断 $k = 5$ 列，\n- 每个与门翻转的能量 $E_{\\mathrm{AND}} = 2.0 \\times 10^{-15}$ 焦耳。\n\n将节能以飞焦耳（fJ）为单位表示。将节能和平均绝对误差均四舍五入至四位有效数字。以一个包含两个元素的行矩阵形式提供最终答案，第一个元素是每周期的期望节能（单位为 fJ），第二个元素是期望平均绝对误差（在原生整数乘积域中的无量纲量）。",
            "solution": "问题陈述经评估为有效。它在科学上基于数字逻辑设计、CMOS 电路能耗建模和概率论的原理。所有术语都有明确定义，并提供了必要的数据（$n=16$，$k=5$，$E_{\\mathrm{AND}}=2.0 \\times 10^{-15}$ 焦耳）和统计模型（独立同分布的伯努利比特）。该问题是适定的、客观的、自洽的，可以得出一个唯一的、可验证的解。\n\n解答分为两部分：计算期望节能和计算期望平均绝对误差（MAE）。\n\n第一部分：每周期的期望节能\n\n每周期的期望节能 $\\Delta E$ 是被截断所消除的与门本应消耗的能量。截断规则消除了所有满足条件 $i+j  k$ 的部分积与门 $p_{ij} = X_i Y_j$。索引 $i, j$ 的范围是从 $0$ 到 $n-1$。\n\n单个门的动态能耗在其输出翻转时产生。期望节能是每个被消除的门期望能耗的总和。\n$$ \\Delta E = \\sum_{i,j : i+j  k} \\mathbb{E}[\\text{Energy of gate } (i,j)] $$\n单个门的期望能耗是每次翻转的能耗 $E_{\\mathrm{AND}}$ 乘以其输出翻转的概率 $P_{\\mathrm{toggle}}$。\n$$ \\mathbb{E}[\\text{Energy of gate } (i,j)] = E_{\\mathrm{AND}} \\cdot P_{\\mathrm{toggle}}(p_{ij}) $$\n由于输入比特 $X_i$ 和 $Y_j$ 是参数为 $1/2$ 的独立同分布伯努利随机变量，此性质对所有部分积 $p_{ij}$ 都成立。因此，所有门的 $P_{\\mathrm{toggle}}$ 都是相同的。\n设 $p_{ij}(t)$ 是与门在周期 $t$ 的输出。如果 $p_{ij}(t) \\neq p_{ij}(t-1)$，则发生翻转。由于跨周期的输入字是独立的，所以 $p_{ij}(t)$ 和 $p_{ij}(t-1)$ 是独立的随机变量。\n翻转的概率是：\n$$ P_{\\mathrm{toggle}} = P(p_{ij}(t)=1, p_{ij}(t-1)=0) + P(p_{ij}(t)=0, p_{ij}(t-1)=1) $$\n根据独立性，这简化为：\n$$ P_{\\mathrm{toggle}} = 2 \\cdot P(p_{ij}=1) \\cdot P(p_{ij}=0) $$\n部分积 $p_{ij} = X_i Y_j$ 为 $1$ 当且仅当 $X_i=1$ 和 $Y_j=1$。鉴于 $P(X_i=1) = 1/2$ 和 $P(Y_j=1) = 1/2$ 以及它们的独立性：\n$$ P(p_{ij}=1) = P(X_i=1) \\cdot P(Y_j=1) = \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4} $$\n因此，$P(p_{ij}=0) = 1 - P(p_{ij}=1) = 1 - 1/4 = 3/4$。\n翻转概率是：\n$$ P_{\\mathrm{toggle}} = 2 \\cdot \\frac{1}{4} \\cdot \\frac{3}{4} = \\frac{6}{16} = \\frac{3}{8} $$\n接下来，我们必须计算被消除的与门数量 $N_{\\mathrm{elim}}$。这些是对应于索引对 $(i,j)$ 的门，其中 $i,j \\ge 0$ 且 $i+j  k$。对于给定的和 $s = i+j$，有 $s+1$ 个这样的对：$(0,s), (1,s-1), \\dots, (s,0)$。和 $s$ 的范围是从 $0$ 到 $k-1$。\n$$ N_{\\mathrm{elim}} = \\sum_{s=0}^{k-1} (s+1) = \\frac{k(k+1)}{2} $$\n当 $k=5$ 时：\n$$ N_{\\mathrm{elim}} = \\frac{5(5+1)}{2} = \\frac{30}{2} = 15 $$\n每周期的总期望节能是被消除的门数、翻转概率和每次翻转能耗三者的乘积。\n$$ \\Delta E = N_{\\mathrm{elim}} \\cdot P_{\\mathrm{toggle}} \\cdot E_{\\mathrm{AND}} $$\n代入数值：\n$$ \\Delta E = 15 \\cdot \\frac{3}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = \\frac{45}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = 11.25 \\times 10^{-15} \\text{ J} $$\n问题要求答案以飞焦耳（fJ）为单位，其中 $1 \\text{ fJ} = 10^{-15} \\text{ J}$。\n$$ \\Delta E = 11.25 \\text{ fJ} $$\n这个值已经是四位有效数字。\n\n第二部分：期望平均绝对误差（MAE）\n\nMAE 定义为 $\\mathrm{MAE} = \\mathbb{E}[|P - \\tilde{P}|]$。精确乘积 $P$ 和近似乘积 $\\tilde{P}$ 分别是：\n$$ P = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} p_{ij} 2^{i+j} \\quad , \\quad \\tilde{P} = \\sum_{i,j : i+j \\ge k} p_{ij} 2^{i+j} $$\n误差是被截断项的总和：\n$$ P - \\tilde{P} = \\sum_{i,j : i+j  k} p_{ij} 2^{i+j} $$\n由于 $p_{ij} \\in \\{0, 1\\}$ 且 $2^{i+j} > 0$，误差项 $P - \\tilde{P}$ 总是非负的。因此，$|P - \\tilde{P}| = P - \\tilde{P}$。\nMAE 是该误差项的期望：\n$$ \\mathrm{MAE} = \\mathbb{E}\\left[\\sum_{i,j : i+j  k} p_{ij} 2^{i+j}\\right] $$\n根据期望的线性性：\n$$ \\mathrm{MAE} = \\sum_{i,j : i+j  k} \\mathbb{E}[p_{ij}] 2^{i+j} $$\n伯努利随机变量 $p_{ij}$ 的期望值是其为 $1$ 的概率：\n$$ \\mathbb{E}[p_{ij}] = P(p_{ij}=1) = \\frac{1}{4} $$\n将此代入 MAE 表达式：\n$$ \\mathrm{MAE} = \\sum_{i,j : i+j  k} \\frac{1}{4} \\cdot 2^{i+j} = \\frac{1}{4} \\sum_{i,j : i+j  k} 2^{i+j} $$\n设 $S = \\sum_{i,j : i+j  k} 2^{i+j}$。我们可以按和 $s=i+j$ 对各项进行分组。对于从 $0$ 到 $k-1$ 的每个 $s$ 值，有 $s+1$ 个和为 $s$ 的对 $(i,j)$。\n$$ S = \\sum_{s=0}^{k-1} (s+1) 2^s $$\n这是一个等差-等比级数。其和可以使用公式 $S_m = \\sum_{i=0}^{m} (i+1)x^i = \\frac{(m+1)x^{m+2} - (m+2)x^{m+1} + x}{(x-1)^2}$ 求得，或者，对于 $x=2$ 的情况，更简单地使用恒等式 $\\sum_{s=0}^{k-1} (s+1) 2^s = (k-1)2^k + 1$。\n对于 $k=5$：\n$$ S = (5-1) 2^5 + 1 = 4 \\cdot 32 + 1 = 128 + 1 = 129 $$\n现在，MAE 为：\n$$ \\mathrm{MAE} = \\frac{1}{4} S = \\frac{129}{4} = 32.25 $$\n这个值在乘积的整数域中是无量纲的，并且已经是四位有效数字。\n\n需要报告的最终值是节能（单位 fJ）和 MAE。\n- 期望节能：$11.25$ fJ\n- 期望平均绝对误差：$32.25$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11.25  32.25\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了单个组件的权衡之后，本练习将引导您应对一个真实的设计挑战：如何从一个包含多种选项的库中选择最佳的近似计算单元。您将学习并应用帕累托优化（Pareto optimization）这一多目标工程设计中的基石概念，来识别出最高效的设计集合（即帕累托前沿），并根据具体的项目约束做出最终选择 。",
            "id": "4256172",
            "problem": "请考虑一个集成电路中的近似计算单元库，其中每个单元都以其能耗和应用级误差度量为特征。设第 $i$ 个单元由对偶 $\\left(E_{i}, \\epsilon_{i}\\right)$ 表示，其中 $E_{i}$ 是以 $\\mathrm{nJ}$（纳焦耳）为单位的能耗，$\\epsilon_{i}$ 是一个表示为区间 $[0,1]$ 内小数的无量纲归一化误差。目标是计算这些单元在最小化能耗和最小化误差这两个目标下的帕累托前沿，然后在一个指定的能量预算和误差上限下选择一个可行的设计。\n\n从以下基本依据开始：\n- 能量的定义，即一种必须在预算内分配的物理资源，以及容错性原则，即必须遵守应用级误差约束。\n- 多目标优化中帕累托支配的数学定义：如果 $E_{i} \\le E_{j}$ 且 $\\epsilon_{i} \\le \\epsilon_{j}$，并且其中至少一个不等式是严格的，则单元 $i$ 支配单元 $j$。如果没有任何其他单元支配某个单元，则该单元是帕累托有效的（或非支配的）。\n\n基于这些基础，您必须设计一个算法，该算法能够：\n1. 识别所有非支配单元以形成帕累托前沿。\n2. 按能量升序、然后按误差升序、最后按索引升序对帕累托前沿进行排序，以确保确定性顺序。\n3. 给定一个能量预算 $B$（单位为 $\\mathrm{nJ}$）和一个误差上限 $C$（无量纲小数），从满足 $E_{i} \\le B$ 和 $\\epsilon_{i} \\le C$ 的单元中选择一个。选择必须优先考虑最小能量，通过最小误差打破平局，然后通过最小索引打破任何剩余的平局。如果没有单元满足这两个约束，则选择应为 $-1$。\n\n所有索引都必须从 $0$ 开始处理。如果两个单元具有相同的 $\\left(E_{i}, \\epsilon_{i}\\right)$，则两者都被认为是非支配的，并且都应出现在帕累托前沿中。\n\n您的程序必须嵌入以下参数值的测试套件，并严格按照规定处理它们：\n\n- 测试用例 1：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$，其中 $i \\in \\{0,1,2,3,4,5,6\\}$，由以下给出\n    - $E$: $[1.20, 0.90, 0.85, 1.10, 0.95, 1.50, 0.85]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.080, 0.060, 0.030, 0.050, 0.020, 0.030]$\n  - 预算 $B$：$1.00$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.050$\n- 测试用例 2：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$，其中 $i \\in \\{0,1,2,3,4\\}$，由以下给出\n    - $E$: $[1.00, 1.00, 0.90, 0.90, 0.80]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.040, 0.040, 0.050, 0.060]$\n  - 预算 $B$：$0.90$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.040$\n- 测试用例 3：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$，其中 $i \\in \\{0,1,2,3\\}$，由以下给出\n    - $E$: $[0.50, 0.50, 0.50, 0.60]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.030, 0.035, 0.025]$\n  - 预算 $B$：$1.00$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.040$\n- 测试用例 4：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$，其中 $i \\in \\{0,1,2\\}$，由以下给出\n    - $E$: $[1.20, 1.10, 1.05]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.10, 0.09, 0.08]$\n  - 预算 $B$：$1.00$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.05$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个双元素列表，其第一个元素是按指定排序顺序排列的帕累托前沿索引列表，第二个元素是所选的索引（如果不可行则为 $-1$）。例如，单个测试用例结果的格式应为 $[[i_{1}, i_{2}, \\dots], s]$，其中 $[i_{1}, i_{2}, \\dots]$ 是帕累托前沿上的索引，而 $s$ 是所选的索引。\n\n因此，最终的单行应为 $[r_{1}, r_{2}, r_{3}, r_{4}]$ 的形式，其中每个 $r_{k}$ 是上述的双元素列表之一。",
            "solution": "所提出的问题是多目标优化领域中的一个经典练习，特别应用于近似计算范式下的集成电路设计。任务是平衡最小化能耗（$E$）和最小化计算误差（$\\epsilon$）这两个相互冲突的目标。解决方案要求严格应用帕累托分析，并基于指定的约束和优先级建立一个清晰、确定性的选择过程。\n\n问题提供了基本原则：\n1.  **资源约束**：能量（$E$）是一种受预算 $B$ 管控的有限资源，而误差（$\\epsilon$）必须保持在应用特定的容忍上限 $C$ 以下。\n2.  **帕累托支配**：这是在多目标空间中比较解决方案的关键概念。一个由对偶 $(E_i, \\epsilon_i)$ 表征的计算单元 $i$ 被认为支配单元 $j$，如果它在所有目标上至少与 $j$ 一样好，并且在至少一个目标上严格优于 $j$。形式上，如果（$E_i \\le E_j$ 且 $\\epsilon_i \\le \\epsilon_j$）并且（$E_i  E_j$ 或 $\\epsilon_i  \\epsilon_j$），则单元 $i$ 支配单元 $j$。\n\n一个单元如果没有被设计空间中任何其他可用单元所支配，则被称为**帕累托有效**（或非支配的）。所有这些非支配单元的集合构成了**帕累托前沿**。该前沿代表了所有最优权衡的集合；对于前沿上的任何一点，都不可能在不降低另一个目标性能的情况下改善一个目标。\n\n算法解决方案按照问题的要求，被构建为三个不同的顺序步骤。\n\n**步骤 1：识别帕累托前沿**\n为了识别所有非支配单元，需要对所有可用单元进行系统的两两比较。对于每个单元 $i$，我们必须确定是否存在任何其他单元 $j$ 支配它。\n算法过程如下：\n对于所有单元集合中的每个单元 $i$：\n- 暂时假设单元 $i$ 是非支配的。\n- 遍历所有其他单元 $j$（其中 $j \\ne i$）。\n- 对于每个 $j$，检查它是否满足对 $i$ 的支配条件：$E_j \\le E_i$ 且 $\\epsilon_j \\le \\epsilon_i$，并且至少有一个不等式是严格的。\n- 如果找到了这样的单元 $j$，则确认单元 $i$ 是被支配的。我们可以立即停止用其他单元对 $i$ 进行检查，并断定它不在帕累托前沿上。\n- 如果检查了所有其他单元的集合，没有发现任何单元 $j$ 支配 $i$，那么最初的假设成立，单元 $i$ 是帕累托前沿的一部分。\n\n所有被发现为非支配的单元的索引被收集起来，形成帕累托前沿集合。请注意，如果两个单元 $k$ 和 $l$ 具有相同的特性，即 ($E_k, \\epsilon_k) = (E_l, \\epsilon_l)$，它们互不支配。如果没有其他单元支配它们，则两者都包含在帕累托前沿中。\n\n**步骤 2：对帕累托前沿进行排序**\n问题要求对帕累托前沿上的单元进行确定性排序。这是通过基于多级键对已识别的非支配单元进行排序来实现的。主要排序标准是按能耗（$E_i$）升序排列。能量上的任何平局都由次要标准，即按误差（$\\epsilon_i$）升序排列来解决。如果仍然存在平局（即前沿上两个不同的单元具有相同的能量和误差值），则由第三标准，即按单元的原始索引（$i$）升序排列来打破。这确保了帕累托前沿的唯一且一致的排序。此步骤的最终输出是一个排序后的索引列表。\n\n**步骤 3：选择最优可行单元**\n给定能量预算 $B$ 和误差上限 $C$，最后一步是从*整个*原始单元集中选择一个最优单元，而不仅仅是从帕累托前沿中选择。如果一个单元 $i$ 同时满足两个约束：$E_i \\le B$ 和 $\\epsilon_i \\le C$，则它被认为是**可行**的。\n\n选择过程如下：\n- 首先，筛选完整的单元集，生成一个仅包含可行单元的子集。\n- 如果这个可行子集为空（即没有单元同时满足预算和上限），则没有可能的解决方案，选择结果用 $-1$ 表示。\n- 如果可行子集非空，则必须根据一个有优先级的选择规则来选择一个单元。所选单元必须是提供最小能耗（$E_i$）的那个。如果多个可行单元共享相同的最小能量，则通过选择其中误差最小（$\\epsilon_i$）的那个来打破平局。如果仍然存在平局，则通过选择具有最小原始索引（$i$）的单元来解决。这种分层排序与用于帕累托前沿的排序相同，确保了在可行选项中有一个唯一的最佳选择。\n\n这个三步过程正确地实现了多目标优化和基于约束的设计选择原则。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-objective optimization problem for a series of test cases.\n    For each case, it finds the Pareto front, sorts it, and selects the\n    best feasible unit according to the specified constraints and criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"E\": [1.20, 0.90, 0.85, 1.10, 0.95, 1.50, 0.85],\n            \"epsilon\": [0.040, 0.080, 0.060, 0.030, 0.050, 0.020, 0.030],\n            \"B\": 1.00,\n            \"C\": 0.050\n        },\n        {\n            \"E\": [1.00, 1.00, 0.90, 0.90, 0.80],\n            \"epsilon\": [0.040, 0.040, 0.040, 0.050, 0.060],\n            \"B\": 0.90,\n            \"C\": 0.040\n        },\n        {\n            \"E\": [0.50, 0.50, 0.50, 0.60],\n            \"epsilon\": [0.040, 0.030, 0.035, 0.025],\n            \"B\": 1.00,\n            \"C\": 0.040\n        },\n        {\n            \"E\": [1.20, 1.10, 1.05],\n            \"epsilon\": [0.10, 0.09, 0.08],\n            \"B\": 1.00,\n            \"C\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E_vals = case[\"E\"]\n        e_vals = case[\"epsilon\"]\n        B = case[\"B\"]\n        C = case[\"C\"]\n        \n        num_units = len(E_vals)\n        # Store unit data as a list of dictionaries for clarity\n        units = [{'E': E_vals[i], 'e': e_vals[i], 'idx': i} for i in range(num_units)]\n\n        # Step 1: Identify all non-dominated units to form the Pareto front.\n        pareto_indices = []\n        for i in range(num_units):\n            is_dominated = False\n            for j in range(num_units):\n                if i == j:\n                    continue\n                # Check if unit j dominates unit i\n                # Dominance: E_j = E_i AND e_j = e_i AND (E_j  E_i OR e_j  e_i)\n                if (units[j]['E'] = units[i]['E'] and units[j]['e'] = units[i]['e']) and \\\n                   (units[j]['E']  units[i]['E'] or units[j]['e']  units[i]['e']):\n                    is_dominated = True\n                    break\n            if not is_dominated:\n                pareto_indices.append(i)\n\n        # Step 2: Sort the Pareto front.\n        pareto_units_data = [units[i] for i in pareto_indices]\n        # Sort by ascending energy, then ascending error, then ascending index.\n        pareto_units_data.sort(key=lambda u: (u['E'], u['e'], u['idx']))\n        sorted_pareto_indices = [u['idx'] for u in pareto_units_data]\n\n        # Step 3: Select the best feasible unit from the entire set.\n        # A unit is feasible if E = B and epsilon = C.\n        feasible_units = [u for u in units if u['E'] = B and u['e'] = C]\n\n        selected_index = -1\n        if feasible_units:\n            # Sort by minimal energy, then minimal error, then smallest index.\n            feasible_units.sort(key=lambda u: (u['E'], u['e'], u['idx']))\n            selected_index = feasible_units[0]['idx']\n\n        results.append([sorted_pareto_indices, selected_index])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces (e.g., '[1, 2]').\n    # The replace() call removes these spaces to match the compact format '[1,2]'\n    # implied by the problem description's example `[[i_1, i_2, ...], s]`.\n    formatted_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "设计的最后一步是确保近似引入的误差不会对应用的最终结果造成灾难性影响。本练习将近似计算与严谨的数值分析领域联系起来。通过应用后向误差（backward error）和条件数（condition number）等核心概念，您将学会如何正式地分析一个在近似硬件上实现的算法的数值稳定性，从而超越仅仅度量误差大小，深入理解误差的实际影响 。",
            "id": "4256165",
            "problem": "一个电子设计自动化 (EDA) 团队正在评估一个加速器，该加速器用于在迭代预处理器内部求解小型线性系统。该加速器使用近似乘法累加 (MAC) 单元来计算线性系统 $A x = b$ 的一个候选解 $\\hat{x}$。为了评估容错性，他们采用了以下模型：算法问题是将 $(A,b)$ 映射到精确解 $x = f(A,b)$，而硬件由于算術近似产生了 $\\hat{x}$。他们在向量和矩阵的 $\\infty$-范数下测量误差。\n\n在一个代表性实例上，精确数据为\n$$\nA = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix},\n$$\n加速器返回\n$$\n\\hat{x} = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix}.\n$$\n\n选择所有关于后向误差和条件数的定义及其与分析此近似硬件实现的相关性的正确陈述。\n\nA. 当将硬件误差建模为在 $A$ 精确的情况下对右端项 $b$ 的有效扰动时，后向误差是使 $A \\hat{x} = b + \\Delta b$ 成立的最小 $\\Delta b$。对于给定的数据，在 $\\infty$-范数下，相对后向误差等于 $1/10$。\n\nB. 在 $\\infty$-范数下，用于求解 $A x = b$ 的矩阵 $A$ 的条件数是 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\,\\|A^{-1}\\|_{\\infty} = 16/5$。\n\nC. 如果一个算法是后向稳定的，那么对于每个实例，相对前向误差都精确等于条件数乘以相对后向误差。\n\nD. 对于此实例，关联前向和后向误差的不等式成立，\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}},\n$$\n数值上为 $1/9 \\le 8/25$，这说明了即使是由硬件引起的微小残差也可能被问题的条件放大。\n\nE. 因为在有限维空间中范数是等价的，所以条件数对于范数的选择是不变的，因此对于这个 $A$ 有 $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$。",
            "solution": "问题陈述内部一致，在数值线性代数领域有科学依据，并提供了评估给定选项所需的所有信息。该场景是误差分析在硬件实现的数值方法中的一个标准应用。问题是有效的。我们开始进行解答。\n\n首先，我们根据提供的数据确定必要的量。\n线性系统为 $A x = b$，其中\n$$\nA = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\n$$\n加速器提供了一个近似解\n$$\n\\hat{x} = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix}\n$$\n所有分析都将使用 $\\infty$-范数（记为 $\\|\\cdot\\|_{\\infty}$）进行。\n\n**1. 精确解, $x$**\n为了找到精确解 $x$，我们首先计算 $A$ 的逆矩阵。行列式为 $\\det(A) = (2)(3) - (1)(1) = 5$。\n逆矩阵是\n$$\nA^{-1} = \\frac{1}{\\det(A)} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} = \\begin{bmatrix} 3/5  -1/5 \\\\ -1/5  2/5 \\end{bmatrix}\n$$\n精确解是\n$$\nx = A^{-1} b = \\frac{1}{5} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 3(1) - 1(2) \\\\ -1(1) + 2(2) \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 1 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 1/5 \\\\ 3/5 \\end{bmatrix}\n$$\n\n**2. 前向误差**\n绝对前向误差是近似解与精确解之差：\n$$\n\\hat{x} - x = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix} - \\begin{bmatrix} 1/5 \\\\ 3/5 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\frac{10 - 9}{15} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1/15 \\end{bmatrix}\n$$\n绝对前向误差的 $\\infty$-范数是 $\\|\\hat{x} - x\\|_{\\infty} = \\max(|0|, |1/15|) = 1/15$。\n精确解的 $\\infty$-范数是 $\\|x\\|_{\\infty} = \\max(|1/5|, |3/5|) = 3/5$。\n相对前向误差是\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} = \\frac{1/15}{3/5} = \\frac{1}{15} \\cdot \\frac{5}{3} = \\frac{1}{9}\n$$\n\n**3. 残差和后向误差**\n残差向量为 $r = b - A \\hat{x}$。\n首先，我们计算 $A \\hat{x}$：\n$$\nA \\hat{x} = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix} \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix} = \\begin{bmatrix} 2(1/5) + 1(2/3) \\\\ 1(1/5) + 3(2/3) \\end{bmatrix} = \\begin{bmatrix} 2/5 + 2/3 \\\\ 1/5 + 2 \\end{bmatrix} = \\begin{bmatrix} (6+10)/15 \\\\ (1+10)/5 \\end{bmatrix} = \\begin{bmatrix} 16/15 \\\\ 11/5 \\end{bmatrix}\n$$\n残差是\n$$\nr = b - A \\hat{x} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} - \\begin{bmatrix} 16/15 \\\\ 11/5 \\end{bmatrix} = \\begin{bmatrix} 15/15 - 16/15 \\\\ 10/5 - 11/5 \\end{bmatrix} = \\begin{bmatrix} -1/15 \\\\ -1/5 \\end{bmatrix}\n$$\n残差的 $\\infty$-范数是 $\\|r\\|_{\\infty} = \\|b - A \\hat{x}\\|_{\\infty} = \\max(|-1/15|, |-1/5|) = 1/5$。\n\n现在我们评估每个选项。\n\n**A. 当将硬件误差建模为在 $A$ 精确的情况下对右端项 $b$ 的有效扰动时，后向误差是使 $A \\hat{x} = b + \\Delta b$ 成立的最小 $\\Delta b$。对于给定的数据，在 $\\infty$-范数下，相对后向误差等于 $1/10$。**\n\n所描述的后向误差模型将扰动 $\\Delta b$ 定义为 $\\Delta b = A \\hat{x} - b = -r$。在 $\\infty$-范数下，这种扰动的最小值是 $\\|\\Delta b\\|_{\\infty} = \\|-r\\|_{\\infty} = \\|r\\|_{\\infty}$。这就是绝对后向误差。根据我们的计算，绝对后向误差是 $\\|r\\|_{\\infty} = 1/5$。\n相对后向误差是绝对后向误差除以原始数据的大小（通常是 $\\|b\\|_{\\infty}$）进行归一化。\n$$\n\\text{相对后向误差} = \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}}\n$$\n我们需要 $b$ 的范数：$\\|b\\|_{\\infty} = \\max(|1|, |2|) = 2$。\n代入数值：\n$$\n\\text{相对后向误差} = \\frac{1/5}{2} = \\frac{1}{10}\n$$\n该陈述断言相对后向误差为 $1/10$。这与我们的计算相符。\n\n**A 的结论：正确**\n\n**B. 在 $\\infty$-范数下，用于求解 $A x = b$ 的矩阵 $A$ 的条件数是 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\,\\|A^{-1}\\|_{\\infty} = 16/5$。**\n\n条件数的定义是 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty}\\|A^{-1}\\|_{\\infty}$。\n矩阵的 $\\infty$-范数是最大绝对行和。\n对于 $A = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}$：\n$\\|A\\|_{\\infty} = \\max(|2|+|1|, |1|+|3|) = \\max(3, 4) = 4$。\n对于 $A^{-1} = \\begin{bmatrix} 3/5  -1/5 \\\\ -1/5  2/5 \\end{bmatrix}$：\n$\\|A^{-1}\\|_{\\infty} = \\max(|3/5|+|-1/5|, |-1/5|+|2/5|) = \\max(4/5, 3/5) = 4/5$。\n条件数是：\n$$\n\\kappa_{\\infty}(A) = \\|A\\|_{\\infty}\\|A^{-1}\\|_{\\infty} = 4 \\times \\frac{4}{5} = \\frac{16}{5}\n$$\n该陈述断言 $\\kappa_{\\infty}(A) = 16/5$。这与我们的计算相符。\n\n**B 的结论：正确**\n\n**C. 如果一个算法是后向稳定的，那么对于每个实例，相对前向误差都精确等于条件数乘以相对后向误差。**\n\n这个陈述提出了一个普遍的等式：\n$$\n\\frac{\\|\\hat{x}-x\\|}{\\|x\\|} = \\kappa(A) \\frac{\\|b-A\\hat{x}\\|}{\\|b\\|}\n$$\n在数值分析中，正确的关系是一个不等式，它给出了前向误差的一个上界：\n$$\n\\frac{\\|\\hat{x}-x\\|}{\\|x\\|} \\le \\kappa(A) \\frac{\\|b-A\\hat{x}\\|}{\\|b\\|}\n$$\n（这是当扰动仅在 $b$ 中建模时的一种常见形式）。这个关系不是一个严格的等式。实际的放大因子取决于误差向量与矩阵奇异向量的对齐情况，而条件数代表了最坏情况下的放大倍数。该陈述关于“对于每个实例”都精确相等的断言是错误的。我们可以对当前实例验证这一点：\n相对前向误差是 $1/9$。\n条件数乘以相对后向误差是 $\\kappa_{\\infty}(A) \\times \\frac{\\|r\\|_{\\infty}}{\\|b\\|_{\\infty}} = \\frac{16}{5} \\times \\frac{1}{10} = \\frac{16}{50} = \\frac{8}{25}$。\n由于 $1/9 \\approx 0.111$ 且 $8/25 = 0.32$，很明显 $1/9 \\neq 8/25$。因此，该陈述无论是在一般情况下还是在这个具体案例中都是错误的。\n\n**C 的结论：不正确**\n\n**D. 对于此实例，关联前向和后向误差的不等式成立，\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}},\n$$\n数值上为 $1/9 \\le 8/25$，这说明了即使是由硬件引起的微小残差也可能被问题的条件放大。**\n\n所呈现的不等式是界定相对前向误差的标准结果。让我们代入我们已经计算出的值来验证这个数值声明：\n左侧 (LHS): $\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} = 1/9$。\n右侧 (RHS): $\\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}} = \\frac{16}{5} \\times \\frac{1/5}{2} = \\frac{16}{5} \\times \\frac{1}{10} = \\frac{16}{50} = \\frac{8}{25}$。\n不等式为 $1/9 \\le 8/25$。\n为了检验，我们可以使用公分母 $225$：$1/9 = 25/225$ 且 $8/25 = 72/225$。\n不等式为 $25/225 \\le 72/225$，这是成立的。\n所提供的解释也是正确的：条件数 $\\kappa_{\\infty}(A) = 16/5 = 3.2$ 充当了从相对后向误差（残差）到相对前向误差的放大因子。该不等式成立，数值正确，且解释是标准的。\n\n**D 的结论：正确**\n\n**E. 因为在有限维空间中范数是等价的，所以条件数对于范数的选择是不变的，因此对于这个 $A$ 有 $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$。**\n\n这个陈述包含一个严重的逻辑缺陷。“在有限维空间中范数是等价的”这个前提是正确的。这意味着对于任意两个范数 $\\|\\cdot\\|_a$ 和 $\\|\\cdot\\|_b$，都存在正常数 $c_1, c_2$ 使得对所有向量 $v$ 都有 $c_1 \\|v\\|_a \\le \\|v\\|_b \\le c_2 \\|v\\|_a$。然而，这并不意味着对于一个给定的向量，这些范数的值相同，也不意味着诱导矩阵范数或条件数是不变的。\n“条件数对于范数的选择是不变的”这个中间结论通常是错误的。例如，对于大多数大小为 $n2$ 的矩阵，$\\kappa_1(A) \\ne \\kappa_2(A) \\ne \\kappa_\\infty(A)$。\n让我们检验最终的结论，“对于这个 $A$ 有 $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$”。\n矩阵的 $1$-范数是最大绝对列和。\n$\\|A\\|_1 = \\max(|2|+|1|, |1|+|3|) = \\max(3, 4) = 4$。\n$\\|A^{-1}\\|_1 = \\max(|3/5|+|-1/5|, |-1/5|+|2/5|) = \\max(4/5, 3/5) = 4/5$。\n所以, $\\kappa_1(A) = \\|A\\|_1 \\|A^{-1}\\|_1 = 4 \\times (4/5) = 16/5$。\n我们之前发现 $\\kappa_\\infty(A) = 16/5$。因此，对于这个特定的矩阵，$\\kappa_1(A) = \\kappa_\\infty(A)$ 恰好成立。（这对所有可逆的 $2 \\times 2$ 矩阵都成立）。\n然而，整个陈述是一个形式为“因为Q为真，所以R为真”的论证，其中Q是“条件数是不变的”这个错误前提。一个基于错误推理的论证在数学或科学中不是一个正确的陈述，即使其最终结论对于特定数据碰巧为真。推理过程本身也是必须被评估的一部分。\n\n**E 的结论：不正确**",
            "answer": "$$\\boxed{ABD}$$"
        }
    ]
}