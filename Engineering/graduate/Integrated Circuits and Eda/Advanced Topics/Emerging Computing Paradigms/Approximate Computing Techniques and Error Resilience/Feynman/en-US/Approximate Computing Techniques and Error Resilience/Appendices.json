{
    "hands_on_practices": [
        {
            "introduction": "At the heart of approximate computing is the trade-off between energy efficiency and computational accuracy. This exercise provides a foundational look at this balance by analyzing a common approximation technique: truncating the partial products in a digital multiplier . By working through this problem, you will learn to quantify both the energy savings and the expected error, connecting low-level circuit design choices to their high-level performance implications.",
            "id": "4256152",
            "problem": "Consider an unsigned array multiplier implemented in complementary metal–oxide–semiconductor (CMOS) for two independent random inputs in the context of Electronic Design Automation (EDA). Let the operands be $X$ and $Y$, each of width $n$ bits, with independent and identically distributed input words across cycles, and each bit $X_i$ and $Y_j$ for $i,j \\in \\{0,1,\\dots,n-1\\}$ follows a Bernoulli distribution with parameter $1/2$. The exact multiplier forms all partial products via $p_{ij} = X_i Y_j$ using two-input AND gates and sums them with an addition network.\n\nAn approximate multiplier truncates the $k$ least significant columns of the partial product array. Specifically, the approximate product $\\tilde{P}$ is obtained by summing only those partial products $p_{ij}$ whose weights satisfy $2^{i+j} \\ge 2^{k}$, i.e., it omits all $p_{ij}$ with $i+j  k$. This truncation eliminates the corresponding AND gates and all subsequent switching activity associated with the dropped partial products. Assume the dynamic energy per toggle of a two-input AND gate is a known constant $E_{\\mathrm{AND}}$ (in joules), and successive input words across cycles are independent, so the toggling probability of any $p_{ij}=X_i Y_j$ from one cycle to the next can be derived from first principles of probability.\n\nUnder this model:\n- The expected mean absolute error is defined as $\\mathrm{MAE} = \\mathbb{E}\\big[|P - \\tilde{P}|\\big]$, where $P = X \\cdot Y$ is the exact product.\n- The expected energy savings per cycle due to truncation is the expected dynamic energy not consumed by the eliminated AND gates.\n\nUsing the standard dynamic power and energy relation for CMOS switching, $E_{\\mathrm{dyn}} = \\alpha C V^{2}$ per toggle (absorbed into the constant $E_{\\mathrm{AND}}$ for each AND gate), compute both the expected energy savings per cycle and the expected mean absolute error for the following parameters:\n- Operand width $n = 16$,\n- Truncation $k = 5$ columns,\n- Energy per AND-gate toggle $E_{\\mathrm{AND}} = 2.0 \\times 10^{-15}$ joules.\n\nExpress the energy savings in femtojoules (fJ). Round both the energy savings and the mean absolute error to four significant figures. Provide the final answer as a two-entry row matrix, with the first entry being the energy savings per cycle in fJ and the second entry being the expected mean absolute error as a dimensionless quantity in the native integer product domain.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of digital logic design, CMOS circuit energy modeling, and probability theory. All terms are clearly defined, and the necessary data ($n=16$, $k=5$, $E_{\\mathrm{AND}}=2.0 \\times 10^{-15}$ joules) and statistical models (i.i.d. Bernoulli bits) are provided. The problem is well-posed, objective, and self-contained, allowing for a unique, verifiable solution.\n\nThe solution is divided into two parts: calculation of the expected energy savings and calculation of the expected mean absolute error (MAE).\n\nPart 1: Expected Energy Savings per Cycle\n\nThe expected energy savings per cycle, $\\Delta E$, is the energy that would have been consumed by the AND gates which are eliminated by the truncation. The truncation rule eliminates all partial product AND gates $p_{ij} = X_i Y_j$ for which the condition $i+j  k$ is met. The indices $i, j$ range from $0$ to $n-1$.\n\nThe dynamic energy of a single gate is consumed when its output toggles. The expected energy saving is the sum of the expected energy consumption of each eliminated gate.\n$$ \\Delta E = \\sum_{i,j : i+j  k} \\mathbb{E}[\\text{Energy of gate } (i,j)] $$\nThe expected energy of a single gate is the energy per toggle, $E_{\\mathrm{AND}}$, multiplied by the probability of its output toggling, $P_{\\mathrm{toggle}}$.\n$$ \\mathbb{E}[\\text{Energy of gate } (i,j)] = E_{\\mathrm{AND}} \\cdot P_{\\mathrm{toggle}}(p_{ij}) $$\nSince the input bits $X_i$ and $Y_j$ are independent and identically distributed Bernoulli random variables with parameter $1/2$, this property holds for all partial products $p_{ij}$. Hence, $P_{\\mathrm{toggle}}$ is the same for all gates.\nLet $p_{ij}(t)$ be the output of the AND gate at cycle $t$. A toggle occurs if $p_{ij}(t) \\neq p_{ij}(t-1)$. Since input words across cycles are independent, $p_{ij}(t)$ and $p_{ij}(t-1)$ are independent random variables.\nThe probability of a toggle is:\n$$ P_{\\mathrm{toggle}} = P(p_{ij}(t)=1, p_{ij}(t-1)=0) + P(p_{ij}(t)=0, p_{ij}(t-1)=1) $$\nDue to independence, this simplifies to:\n$$ P_{\\mathrm{toggle}} = 2 \\cdot P(p_{ij}=1) \\cdot P(p_{ij}=0) $$\nThe partial product $p_{ij} = X_i Y_j$ is $1$ if and only if both $X_i=1$ and $Y_j=1$. Given $P(X_i=1) = 1/2$ and $P(Y_j=1) = 1/2$ and their independence:\n$$ P(p_{ij}=1) = P(X_i=1) \\cdot P(Y_j=1) = \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4} $$\nConsequently, $P(p_{ij}=0) = 1 - P(p_{ij}=1) = 1 - 1/4 = 3/4$.\nThe toggle probability is:\n$$ P_{\\mathrm{toggle}} = 2 \\cdot \\frac{1}{4} \\cdot \\frac{3}{4} = \\frac{6}{16} = \\frac{3}{8} $$\nNext, we must count the number of eliminated AND gates, $N_{\\mathrm{elim}}$. These are the gates corresponding to pairs of indices $(i,j)$ such that $i,j \\ge 0$ and $i+j  k$. For a given sum $s = i+j$, there are $s+1$ such pairs: $(0,s), (1,s-1), \\dots, (s,0)$. The sum $s$ ranges from $0$ to $k-1$.\n$$ N_{\\mathrm{elim}} = \\sum_{s=0}^{k-1} (s+1) = \\frac{k(k+1)}{2} $$\nWith $k=5$:\n$$ N_{\\mathrm{elim}} = \\frac{5(5+1)}{2} = \\frac{30}{2} = 15 $$\nThe total expected energy savings per cycle is the product of the number of eliminated gates, the toggle probability, and the energy per toggle.\n$$ \\Delta E = N_{\\mathrm{elim}} \\cdot P_{\\mathrm{toggle}} \\cdot E_{\\mathrm{AND}} $$\nSubstituting the values:\n$$ \\Delta E = 15 \\cdot \\frac{3}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = \\frac{45}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = 11.25 \\times 10^{-15} \\text{ J} $$\nThe problem requires the answer in femtojoules (fJ), where $1 \\text{ fJ} = 10^{-15} \\text{ J}$.\n$$ \\Delta E = 11.25 \\text{ fJ} $$\nThis value is already at four significant figures.\n\nPart 2: Expected Mean Absolute Error (MAE)\n\nThe MAE is defined as $\\mathrm{MAE} = \\mathbb{E}[|P - \\tilde{P}|]$. The exact product $P$ and approximate product $\\tilde{P}$ are:\n$$ P = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} p_{ij} 2^{i+j} \\quad , \\quad \\tilde{P} = \\sum_{i,j : i+j \\ge k} p_{ij} 2^{i+j} $$\nThe error is the sum of the truncated terms:\n$$ P - \\tilde{P} = \\sum_{i,j : i+j  k} p_{ij} 2^{i+j} $$\nSince $p_{ij} \\in \\{0, 1\\}$ and $2^{i+j} > 0$, the error term $P - \\tilde{P}$ is always non-negative. Therefore, $|P - \\tilde{P}| = P - \\tilde{P}$.\nThe MAE is the expectation of this error term:\n$$ \\mathrm{MAE} = \\mathbb{E}\\left[\\sum_{i,j : i+j  k} p_{ij} 2^{i+j}\\right] $$\nBy the linearity of expectation:\n$$ \\mathrm{MAE} = \\sum_{i,j : i+j  k} \\mathbb{E}[p_{ij}] 2^{i+j} $$\nThe expected value of the Bernoulli random variable $p_{ij}$ is its probability of being $1$:\n$$ \\mathbb{E}[p_{ij}] = P(p_{ij}=1) = \\frac{1}{4} $$\nSubstituting this into the MAE expression:\n$$ \\mathrm{MAE} = \\sum_{i,j : i+j  k} \\frac{1}{4} \\cdot 2^{i+j} = \\frac{1}{4} \\sum_{i,j : i+j  k} 2^{i+j} $$\nLet $S = \\sum_{i,j : i+j  k} 2^{i+j}$. We can group the terms by the sum $s=i+j$. For each value of $s$ from $0$ to $k-1$, there are $s+1$ pairs $(i,j)$ that sum to $s$.\n$$ S = \\sum_{s=0}^{k-1} (s+1) 2^s $$\nThis is an arithmetico-geometric series. The sum can be found using the formula $S_m = \\sum_{i=0}^{m} (i+1)x^i = \\frac{(m+1)x^{m+2} - (m+2)x^{m+1} + x}{(x-1)^2}$ or, more simply for $x=2$, we can use the identity $\\sum_{s=0}^{k-1} (s+1) 2^s = (k-1)2^k + 1$.\nFor $k=5$:\n$$ S = (5-1) 2^5 + 1 = 4 \\cdot 32 + 1 = 128 + 1 = 129 $$\nNow, the MAE is:\n$$ \\mathrm{MAE} = \\frac{1}{4} S = \\frac{129}{4} = 32.25 $$\nThis value is dimensionless in the product's integer domain and is already at four significant figures.\n\nFinal values to be reported are the energy savings in fJ and the MAE.\n- Expected energy savings: $11.25$ fJ\n- Expected mean absolute error: $32.25$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11.25  32.25\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While quantifying raw error is essential, understanding its impact on a larger algorithm requires a more sophisticated analytical framework. This practice introduces the powerful concepts of backward error and condition number from numerical analysis, which allow us to reason about the effects of hardware approximation on complex computations like solving linear systems . By applying these principles, you will gain insight into how a problem's inherent sensitivity can magnify small hardware-induced errors, a critical skill for designing robust approximate systems.",
            "id": "4256165",
            "problem": "An Electronic Design Automation (EDA) team is evaluating an accelerator that solves small linear systems inside an iterative preconditioner. The accelerator uses approximate Multiply-Accumulate (MAC) units to compute a candidate solution $\\hat{x}$ to a linear system $A x = b$. To assess error resilience, they adopt the following model: the algorithmic problem is mapping $(A,b)$ to $x = f(A,b)$, where $f(A,b)$ is the exact solution, and the hardware produces $\\hat{x}$ due to arithmetic approximations. They measure errors under the vector and matrix $\\infty$-norms.\n\nOn a representative instance, the exact data are\n$$\nA = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix},\n$$\nand the accelerator returns\n$$\n\\hat{x} = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix}.\n$$\n\nSelect all statements that are correct about the definitions of backward error and condition number and their relevance to analyzing this approximate hardware implementation.\n\nA. When modeling hardware errors as an effective perturbation of the right-hand side $b$ with $A$ exact, the backward error is the minimal $\\Delta b$ such that $A \\hat{x} = b + \\Delta b$. Under the $\\infty$-norm for the given data, the relative backward error equals $1/10$.\n\nB. In the $\\infty$-norm, the condition number of $A$ for solving $A x = b$ is $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\,\\|A^{-1}\\|_{\\infty} = 16/5$.\n\nC. If an algorithm is backward stable, then for every instance the relative forward error equals exactly the condition number times the relative backward error.\n\nD. For this instance, the inequality relating forward and backward error is satisfied,\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}},\n$$\nnumerically $1/9 \\le 8/25$, illustrating that even small hardware-induced residuals can be magnified by the problem conditioning.\n\nE. Because norms are equivalent in finite dimensions, the condition number is invariant to the choice of norm, so $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$ for this $A$.",
            "solution": "The problem statement is internally consistent, scientifically grounded in the field of numerical linear algebra, and provides all necessary information to evaluate the given options. The scenario is a standard application of error analysis for numerical methods implemented in hardware. The problem is valid. We proceed with the solution.\n\nFirst, we establish the necessary quantities based on the provided data.\nThe linear system is $A x = b$ with\n$$\nA = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\n$$\nThe accelerator provides an approximate solution\n$$\n\\hat{x} = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix}\n$$\nAll analysis will be done using the $\\infty$-norm, denoted by $\\|\\cdot\\|_{\\infty}$.\n\n**1. Exact Solution, $x$**\nTo find the exact solution $x$, we first compute the inverse of $A$. The determinant is $\\det(A) = (2)(3) - (1)(1) = 5$.\nThe inverse is\n$$\nA^{-1} = \\frac{1}{\\det(A)} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} = \\begin{bmatrix} 3/5  -1/5 \\\\ -1/5  2/5 \\end{bmatrix}\n$$\nThe exact solution is\n$$\nx = A^{-1} b = \\frac{1}{5} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 3(1) - 1(2) \\\\ -1(1) + 2(2) \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 1 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 1/5 \\\\ 3/5 \\end{bmatrix}\n$$\n\n**2. Forward Error**\nThe absolute forward error is the difference between the approximate and exact solutions:\n$$\n\\hat{x} - x = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix} - \\begin{bmatrix} 1/5 \\\\ 3/5 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\frac{10 - 9}{15} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1/15 \\end{bmatrix}\n$$\nThe $\\infty$-norm of the absolute forward error is $\\|\\hat{x} - x\\|_{\\infty} = \\max(|0|, |1/15|) = 1/15$.\nThe $\\infty$-norm of the exact solution is $\\|x\\|_{\\infty} = \\max(|1/5|, |3/5|) = 3/5$.\nThe relative forward error is\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} = \\frac{1/15}{3/5} = \\frac{1}{15} \\cdot \\frac{5}{3} = \\frac{1}{9}\n$$\n\n**3. Residual and Backward Error**\nThe residual vector is $r = b - A \\hat{x}$.\nFirst, we compute $A \\hat{x}$:\n$$\nA \\hat{x} = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix} \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix} = \\begin{bmatrix} 2(1/5) + 1(2/3) \\\\ 1(1/5) + 3(2/3) \\end{bmatrix} = \\begin{bmatrix} 2/5 + 2/3 \\\\ 1/5 + 2 \\end{bmatrix} = \\begin{bmatrix} (6+10)/15 \\\\ (1+10)/5 \\end{bmatrix} = \\begin{bmatrix} 16/15 \\\\ 11/5 \\end{bmatrix}\n$$\nThe residual is\n$$\nr = b - A \\hat{x} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} - \\begin{bmatrix} 16/15 \\\\ 11/5 \\end{bmatrix} = \\begin{bmatrix} 15/15 - 16/15 \\\\ 10/5 - 11/5 \\end{bmatrix} = \\begin{bmatrix} -1/15 \\\\ -1/5 \\end{bmatrix}\n$$\nThe $\\infty$-norm of the residual is $\\|r\\|_{\\infty} = \\|b - A \\hat{x}\\|_{\\infty} = \\max(|-1/15|, |-1/5|) = 1/5$.\n\nNow we evaluate each option.\n\n**A. When modeling hardware errors as an effective perturbation of the right-hand side $b$ with $A$ exact, the backward error is the minimal $\\Delta b$ such that $A \\hat{x} = b + \\Delta b$. Under the $\\infty$-norm for the given data, the relative backward error equals $1/10$.**\n\nThe backward error model described defines the perturbation $\\Delta b$ as $\\Delta b = A \\hat{x} - b = -r$. The minimal such perturbation in the $\\infty$-norm is $\\|\\Delta b\\|_{\\infty} = \\|-r\\|_{\\infty} = \\|r\\|_{\\infty}$. This is the absolute backward error. From our calculations, the absolute backward error is $\\|r\\|_{\\infty} = 1/5$.\nThe relative backward error is the absolute backward error normalized by the magnitude of the original data, typically $\\|b\\|_{\\infty}$.\n$$\n\\text{Relative Backward Error} = \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}}\n$$\nWe need the norm of $b$: $\\|b\\|_{\\infty} = \\max(|1|, |2|) = 2$.\nSubstituting the values:\n$$\n\\text{Relative Backward Error} = \\frac{1/5}{2} = \\frac{1}{10}\n$$\nThe statement asserts that the relative backward error is $1/10$. This matches our calculation.\n\n**Verdict for A: Correct**\n\n**B. In the $\\infty$-norm, the condition number of $A$ for solving $A x = b$ is $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\,\\|A^{-1}\\|_{\\infty} = 16/5$.**\n\nThe definition of the condition number is $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty}\\|A^{-1}\\|_{\\infty}$.\nThe matrix $\\infty$-norm is the maximum absolute row sum.\nFor $A = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}$:\n$\\|A\\|_{\\infty} = \\max(|2|+|1|, |1|+|3|) = \\max(3, 4) = 4$.\nFor $A^{-1} = \\begin{bmatrix} 3/5  -1/5 \\\\ -1/5  2/5 \\end{bmatrix}$:\n$\\|A^{-1}\\|_{\\infty} = \\max(|3/5|+|-1/5|, |-1/5|+|2/5|) = \\max(4/5, 3/5) = 4/5$.\nThe condition number is:\n$$\n\\kappa_{\\infty}(A) = \\|A\\|_{\\infty}\\|A^{-1}\\|_{\\infty} = 4 \\times \\frac{4}{5} = \\frac{16}{5}\n$$\nThe statement asserts that $\\kappa_{\\infty}(A) = 16/5$. This matches our calculation.\n\n**Verdict for B: Correct**\n\n**C. If an algorithm is backward stable, then for every instance the relative forward error equals exactly the condition number times the relative backward error.**\n\nThis statement proposes a general equality:\n$$\n\\frac{\\|\\hat{x}-x\\|}{\\|x\\|} = \\kappa(A) \\frac{\\|b-A\\hat{x}\\|}{\\|b\\|}\n$$\nThe correct relationship in numerical analysis is an inequality, which bounds the forward error:\n$$\n\\frac{\\|\\hat{x}-x\\|}{\\|x\\|} \\le \\kappa(A) \\frac{\\|b-A\\hat{x}\\|}{\\|b\\|}\n$$\n(This is a common form when the perturbation is modeled only in $b$). The relation is not a strict equality. The actual magnification factor depends on the alignment of the error vectors with the singular vectors of the matrix, with the condition number representing the worst-case amplification. The statement's claim of an exact equality \"for every instance\" is false. We can verify this for the present instance:\nRelative forward error is $1/9$.\nCondition number times relative backward error is $\\kappa_{\\infty}(A) \\times \\frac{\\|r\\|_{\\infty}}{\\|b\\|_{\\infty}} = \\frac{16}{5} \\times \\frac{1}{10} = \\frac{16}{50} = \\frac{8}{25}$.\nSince $1/9 \\approx 0.111$ and $8/25 = 0.32$, it is clear that $1/9 \\neq 8/25$. The statement is false both in general and for this specific case.\n\n**Verdict for C: Incorrect**\n\n**D. For this instance, the inequality relating forward and backward error is satisfied,\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}},\n$$\nnumerically $1/9 \\le 8/25$, illustrating that even small hardware-induced residuals can be magnified by the problem conditioning.**\n\nThe inequality presented is the standard result bounding the relative forward error. Let's verify the numerical claim by substituting the values we have computed:\nLeft-hand side (LHS): $\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} = 1/9$.\nRight-hand side (RHS): $\\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}} = \\frac{16}{5} \\times \\frac{1/5}{2} = \\frac{16}{5} \\times \\frac{1}{10} = \\frac{16}{50} = \\frac{8}{25}$.\nThe inequality is $1/9 \\le 8/25$.\nTo check, we can use a common denominator of $225$: $1/9 = 25/225$ and $8/25 = 72/225$.\nThe inequality is $25/225 \\le 72/225$, which is true.\nThe interpretation provided is also correct: the condition number $\\kappa_{\\infty}(A) = 16/5 = 3.2$ acts as an amplification factor from the relative backward error (residual) to the relative forward error. The inequality holds, the numerical values are correct, and the interpretation is standard.\n\n**Verdict for D: Correct**\n\n**E. Because norms are equivalent in finite dimensions, the condition number is invariant to the choice of norm, so $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$ for this $A$.**\n\nThis statement contains a severe logical flaw. The premise \"norms are equivalent in finite dimensions\" is true. This means for any two norms $\\|\\cdot\\|_a$ and $\\|\\cdot\\|_b$, there exist positive constants $c_1, c_2$ such that $c_1 \\|v\\|_a \\le \\|v\\|_b \\le c_2 \\|v\\|_a$ for all vectors $v$. However, this does not imply that the norms have the same value for a given vector, nor does it imply that induced matrix norms or condition numbers are invariant.\nThe intermediate conclusion, \"the condition number is invariant to the choice of norm,\" is generally false. For example, for most matrices of size $n2$, $\\kappa_1(A) \\ne \\kappa_2(A) \\ne \\kappa_\\infty(A)$.\nLet's check the final conclusion, \"$\\kappa_{1}(A) = \\kappa_{\\infty}(A)$ for this $A$\".\nThe matrix $1$-norm is the maximum absolute column sum.\n$\\|A\\|_1 = \\max(|2|+|1|, |1|+|3|) = \\max(3, 4) = 4$.\n$\\|A^{-1}\\|_1 = \\max(|3/5|+|-1/5|, |-1/5|+|2/5|) = \\max(4/5, 3/5) = 4/5$.\nSo, $\\kappa_1(A) = \\|A\\|_1 \\|A^{-1}\\|_1 = 4 \\times (4/5) = 16/5$.\nWe found earlier that $\\kappa_\\infty(A) = 16/5$. So, for this specific matrix, it happens to be true that $\\kappa_1(A) = \\kappa_\\infty(A)$.\nHowever, the statement as a whole is an argument of the form \"R is true because Q is true\", where Q is the false premise that \"the condition number is invariant\". An argument based on false reasoning is not a correct statement in mathematics or science, even if the final conclusion happens to be true for the specific data. The reasoning itself is part of what must be evaluated.\n\n**Verdict for E: Incorrect**",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "Effective system design often involves choosing from a library of components, each offering a different balance of performance metrics. This hands-on exercise moves from analysis to synthesis, introducing Pareto optimality as the guiding principle for design space exploration in approximate computing . You will implement an algorithm to identify the set of non-dominated designs—the Pareto front—and then select the optimal component that satisfies given energy and error constraints, a fundamental task in practical hardware design.",
            "id": "4256172",
            "problem": "Consider a library of approximate computational units in integrated circuits, where each unit is characterized by an energy consumption and an application-level error metric. Let the $i$-th unit be represented by the pair $(E_{i}, \\epsilon_{i})$ where $E_{i}$ is the energy consumption in $\\mathrm{nJ}$ (nanojoules) and $\\epsilon_{i}$ is a dimensionless normalized error expressed as a decimal in the interval $[0,1]$. The goal is to compute the Pareto front of these units under the two objectives of minimizing energy and minimizing error, and then select a design that is feasible under a specified energy budget and error cap.\n\nBegin from the following fundamental bases:\n- The definition of energy as a physical resource that must be allocated within a budget, and the principle that error resilience requires adherence to an application-level error constraint.\n- The mathematical definition of Pareto dominance in multi-objective optimization: unit $i$ dominates unit $j$ if $E_{i} \\le E_{j}$ and $\\epsilon_{i} \\le \\epsilon_{j}$ and at least one of the inequalities is strict. A unit is Pareto-efficient (or non-dominated) if no other unit dominates it.\n\nUsing these foundations, you must design an algorithm that:\n1. Identifies all non-dominated units to form the Pareto front.\n2. Sorts the Pareto front by ascending energy, then ascending error, and finally ascending index to ensure a deterministic order.\n3. Given an energy budget $B$ (in $\\mathrm{nJ}$) and an error cap $C$ (dimensionless decimal), selects one unit among those satisfying $E_{i} \\le B$ and $\\epsilon_{i} \\le C$. Selection must prioritize minimal energy, break ties by minimal error, and then break any remaining ties by smallest index. If no unit satisfies both constraints, the selection should be $-1$.\n\nAll indices must be treated as starting from $0$. If two units have identical $(E_{i}, \\epsilon_{i})$, both are considered non-dominated and should appear in the Pareto front.\n\nYour program must embed the following test suite of parameter values and process them exactly as specified:\n\n- Test case $1$:\n  - Units: $(E_{i}, \\epsilon_{i})$ for $i \\in \\{0,1,2,3,4,5,6\\}$ given by\n    - $E$: $[1.20, 0.90, 0.85, 1.10, 0.95, 1.50, 0.85]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.080, 0.060, 0.030, 0.050, 0.020, 0.030]$\n  - Budget $B$: $1.00$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.050$\n- Test case $2$:\n  - Units: $(E_{i}, \\epsilon_{i})$ for $i \\in \\{0,1,2,3,4\\}$ given by\n    - $E$: $[1.00, 1.00, 0.90, 0.90, 0.80]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.040, 0.040, 0.050, 0.060]$\n  - Budget $B$: $0.90$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.040$\n- Test case $3$:\n  - Units: $(E_{i}, \\epsilon_{i})$ for $i \\in \\{0,1,2,3\\}$ given by\n    - $E$: $[0.50, 0.50, 0.50, 0.60]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.030, 0.035, 0.025]$\n  - Budget $B$: $1.00$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.040$\n- Test case $4$:\n  - Units: $(E_{i}, \\epsilon_{i})$ for $i \\in \\{0,1,2\\}$ given by\n    - $E$: $[1.20, 1.10, 1.05]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.10, 0.09, 0.08]$\n  - Budget $B$: $1.00$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.05$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list, whose first element is the list of Pareto front indices in the specified sorted order, and whose second element is the selected index (or $-1$ if infeasible). For example, an individual test case result should be formatted as `[[i_{1}, i_{2}, \\dots], s]` where `[i_{1}, i_{2}, \\dots]` are indices on the Pareto front and `s` is the selected index.\n\nThe final single line should thus be of the form $[r_{1}, r_{2}, r_{3}, r_{4}]$ where each $r_{k}$ is one of the two-element lists described above.",
            "solution": "The problem presented is a classic exercise in multi-objective optimization, specifically applied to the domain of integrated circuit design under approximate computing paradigms. The task is to balance the conflicting objectives of minimizing energy consumption ($E$) and minimizing computational error ($\\epsilon$). The solution requires a rigorous application of Pareto analysis and a clear, deterministic selection process based on specified constraints and priorities.\n\nThe fundamental principles are provided:\n1.  **Resource Constraints**: Energy ($E$) is a finite resource governed by a budget $B$, while error ($\\epsilon$) must be kept below an application-specific tolerance cap $C$.\n2.  **Pareto Dominance**: A key concept for comparing solutions in a multi-objective space. A computational unit $i$, characterized by the pair $(E_i, \\epsilon_i)$, is said to dominate unit $j$ if it is at least as good in all objectives and strictly better in at least one. Formally, unit $i$ dominates unit $j$ if ($E_i \\le E_j$ and $\\epsilon_i \\le \\epsilon_j$) and ($E_i  E_j$ or $\\epsilon_i  \\epsilon_j$).\n\nA unit is termed **Pareto-efficient** (or non-dominated) if no other available unit in the design space dominates it. The set of all such non-dominated units constitutes the **Pareto front**. This front represents the set of all optimal trade-offs; for any point on the front, it is impossible to improve one objective without degrading the other.\n\nThe algorithmic solution is structured into three distinct, sequential steps as mandated by the problem.\n\n**Step 1: Identification of the Pareto Front**\nTo identify all non-dominated units, a systematic pairwise comparison across all available units is performed. For each unit $i$, we must determine if there exists any other unit $j$ that dominates it.\nThe algorithm proceeds as follows:\nFor each unit $i$ in the set of all units:\n- Assume, provisionally, that unit $i$ is non-dominated.\n- Iterate through every other unit $j$ (where $j \\ne i$).\n- For each $j$, check if it satisfies the dominance condition over $i$: $E_j \\le E_i$ and $\\epsilon_j \\le \\epsilon_i$, with at least one inequality being strict.\n- If such a unit $j$ is found, unit $i$ is confirmed to be dominated. We can immediately cease checking other units against $i$ and conclude it is not on the Pareto front.\n- If the entire set of other units is checked and no unit $j$ is found to dominate $i$, then the initial assumption holds, and unit $i$ is part of the Pareto front.\n\nThe indices of all units that are found to be non-dominated are collected to form the Pareto front set. Note that if two units $k$ and $l$ have identical characteristics, $(E_k, \\epsilon_k) = (E_l, \\epsilon_l)$, they do not dominate each other. If no other unit dominates them, both are included in the Pareto front.\n\n**Step 2: Sorting the Pareto Front**\nThe problem requires a deterministic ordering of the units on the Pareto front. This is achieved by sorting the identified non-dominated units based on a multi-level key. The primary sorting criterion is ascending energy consumption ($E_i$). Any ties in energy are resolved by the secondary criterion, ascending error ($\\epsilon_i$). If a tie persists (i.e., two distinct units on the front have identical energy and error values), it is broken by the tertiary criterion, the ascending original index ($i$) of the unit. This ensures a unique and consistent ordering of the Pareto front. The final output for this step is a sorted list of indices.\n\n**Step 3: Selection of the Optimal Feasible Unit**\nGiven an energy budget $B$ and an error cap $C$, the final step is to select a single optimal unit from the *entire* original set of units, not just from the Pareto front. A unit $i$ is considered **feasible** if it meets both constraints simultaneously: $E_i \\le B$ and $\\epsilon_i \\le C$.\n\nThe selection process is as follows:\n- First, filter the complete set of units to produce a subset containing only the feasible units.\n- If this feasible subset is empty (i.e., no unit satisfies both the budget and cap), then no solution is possible, and the selection result is denoted by $-1$.\n- If the feasible subset is non-empty, a single unit must be chosen based on a prioritized selection rule. The selected unit must be the one that offers the minimum energy consumption ($E_i$). If multiple feasible units share the same minimum energy, the tie is broken by choosing the one among them with the minimum error ($\\epsilon_i$). If a tie still remains, it is resolved by selecting the unit with the smallest original index ($i$). This hierarchical sorting is identical to the one used for the Pareto front, ensuring a unique best choice among the feasible options.\n\nThis three-step process correctly implements the principles of multi-objective optimization and constraint-based design selection.",
            "answer": "```\n[[[[6,5],6],[[4,2],2],[[1,3],1],[[2,1,0],-1]]]\n```"
        }
    ]
}