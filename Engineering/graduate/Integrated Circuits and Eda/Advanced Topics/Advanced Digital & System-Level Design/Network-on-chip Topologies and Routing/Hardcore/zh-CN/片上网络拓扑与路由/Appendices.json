{
    "hands_on_practices": [
        {
            "introduction": "本章的实践练习将从网络性能分析的基础构件——单个链路的排队延迟——开始。通过将片上网络（NoC）中的一个链路抽象为经典的 $M/M/1$ 排队模型，我们可以运用排队论的基本原理来估算数据包的平均等待时间。这项练习（）不仅能让你掌握如何根据网络拓扑、路由算法和流量模式来推导关键性能参数（如到达率），还能让你深入理解理论模型在面对真实世界中突发性流量时的局限性。",
            "id": "4285043",
            "problem": "考虑一个二维片上网络（NoC），其排列为一个 $N_{x} \\times N_{y}$ 的网格，其中有 $N_{x} = 8$ 列和 $N_{y} = 8$ 行。路由器由整数坐标 $(x,y)$ 索引，其中 $x \\in \\{0,1,\\dots,7\\}$ 且 $y \\in \\{0,1,\\dots,7\\}$。使用确定性 $X$–$Y$ 路由（XY）：数据包首先完全沿 $x$ 维度传输，然后沿 $y$ 维度传输。每个节点以恒定速率 $r = 0.04$ 包/周期独立注入数据包，目的地从所有其他节点中均匀随机选择（不包括自身作为目的地）。每个数据包的固定长度为 $L = 10$ flits，每条单向链路每个周期可以传输 $F = 1$ flit。假设采用虫洞流控，每个链路的输出队列可以通过马尔可夫/马尔可夫/单服务器（$M/M/1$）近似建模为生灭过程。\n\n关注从路由器 $(3,5)$ 到路由器 $(4,5)$ 的东向链路。使用排队论的基本原理和所述的流量模型，执行以下步骤：\n\n1. 根据基本定义，通过计算在确定性 $X$–$Y$ 路由下会穿过此特定链路的源-目标对集合，推导出到达所选链路的总到达率 $\\lambda$（单位：包/周期）。您的推导必须明确考虑均匀选择目的地且排除源本身的情况。\n\n2. 根据给定的 flit 速率 $F$ 和数据包长度 $L$，推导出链路的服务率 $\\mu$（单位：包/周期）。\n\n3. 定义利用率 $\\rho$，并从 $M/M/1$ 队列的稳态生灭过程特征和 Little’s law 出发，推导出队列中的平均等待时间 $W$ 作为 $\\rho$ 和 $\\mu$ 的函数的解析表达式。不要假设任何预先给定的公式；从生灭过程的核心定义和标准稳态属性开始。\n\n4. 计算指定参数下 $W$ 的数值。将您的答案四舍五入到四位有效数字，并以周期为单位表示最终等待时间。\n\n根据所述的建模假设，简明而严谨地解释，在链路级别使用 $M/M/1$ 近似来处理由现实工作负载产生的突发性 NoC 流量的局限性。您的解释应植根于假设的到达和服务过程与实际 NoC 行为之间的不匹配，但最终的数值答案必须仅为计算出的 $W$。",
            "solution": "问题陈述经评估为有效。它在科学上基于计算机体系结构和排队论的原理，问题设定良好，目标明确，数据充分，并使用客观、正式的语言。使用 $M/M/1$ 近似是一个理论建模问题中指定的、标准的简化方法。\n\n解决方案按要求分为四个主要部分：推导总到达率 $\\lambda$、推导服务率 $\\mu$、从基本原理推导平均等待时间 $W$、以及计算 $W$ 的数值。最后还提供了关于模型局限性的讨论。\n\n**1. 推导总到达率 $\\lambda$**\n\n网络是一个 $N_x \\times N_y$ 网格，其中 $N_x=8$ 且 $N_y=8$。节点总数为 $N = N_x \\times N_y = 8 \\times 8 = 64$。每个节点以 $r = 0.04$ 包/周期的速率注入数据包。每个数据包的目的地从其他 $N-1 = 63$ 个节点中均匀随机选择。\n\n路由算法是确定性 $X$–$Y$ 路由。一个从源节点 $(s_x, s_y)$ 到目标节点 $(d_x, d_y)$ 的数据包，首先沿行 $s_y$ 水平传输，直到到达列 $d_x$，然后沿列 $d_x$ 垂直传输，到达行 $d_y$。\n\n我们关心的是到达从路由器 $(3,5)$ 到路由器 $(4,5)$ 的东向链路的总到达率 $\\lambda$。一个数据包当且仅当其路径需要在行 $5$ 上从列 $3$ 移动到列 $4$ 时，才会穿过此特定链路。根据 $X$–$Y$ 路由，这对源 $(s_x, s_y)$ 和目标 $(d_x, d_y)$ 意味着以下条件：\n- 源的 $x$ 坐标必须在该链路起点的西侧或与之相同：$s_x \\in \\{0, 1, 2, 3\\}$。\n- 数据包的水平传输必须沿行 $5$ 发生：$s_y = 5$。\n- 目标的 $x$ 坐标必须在该链路终点的东侧或与之相同：$d_x \\in \\{4, 5, 6, 7\\}$。\n- 目标的 $y$ 坐标 $d_y$ 可以是任何值，因为垂直转向发生在水平传输完成之后：$d_y \\in \\{0, 1, \\dots, 7\\}$。\n\n我们定义源节点集合 $S_{link}$，其发出的数据包可能穿过该链路：\n$S_{link} = \\{(s_x, 5) \\mid s_x \\in \\{0, 1, 2, 3\\}\\}$。此类源节点的数量为 $|S_{link}| = 4$。\n\n我们定义目标节点集合 $D_{link}$，对于来自 $S_{link}$ 中源节点的数据包，发往这些目标节点会使其穿过该链路：\n$D_{link} = \\{(d_x, d_y) \\mid d_x \\in \\{4, 5, 6, 7\\}, d_y \\in \\{0, 1, \\dots, 7\\}\\}$。此类目标节点的数量为 $|D_{link}| = 4 \\times 8 = 32$。\n\n请注意，对于任何源 $s \\in S_{link}$ 和任何目标 $d \\in D_{link}$，我们有 $s \\neq d$，因为它们的 $x$ 坐标不同。因此，排除自身作为目的地不影响此计算。\n\n链路上总到达率 $\\lambda$ 是 $S_{link}$ 中每个源节点发送到 $D_{link}$ 中目标节点的流量贡献之和。$|S_{link}|$ 个源节点中的每一个都以速率 $r$ 注入数据包。一个数据包被发送到 $D_{link}$ 内的目的地的概率是此类目的地的数量除以可能的目的地总数，即 $N-1$。\n\n$$ \\lambda = |S_{link}| \\times r \\times \\frac{|D_{link}|}{N-1} $$\n代入给定值：\n$$ \\lambda = 4 \\times 0.04 \\times \\frac{32}{64-1} = 0.16 \\times \\frac{32}{63} = \\frac{5.12}{63} \\text{ 包/周期} $$\n\n**2. 推导服务率 $\\mu$**\n\n服务率 $\\mu$ 是链路能够服务数据包的最大速率。\n链路容量为 $F = 1$ flit/周期。\n数据包长度为 $L = 10$ flits/包。\n\n传输一个完整数据包所需的时间，即服务时间 $T_{service}$，是数据包长度除以链路容量：\n$$ T_{service} = \\frac{L}{F} = \\frac{10 \\text{ flits/包}}{1 \\text{ flit/周期}} = 10 \\text{ 周期/包} $$\n服务率 $\\mu$ 是平均服务时间的倒数：\n$$ \\mu = \\frac{1}{T_{service}} = \\frac{F}{L} = \\frac{1}{10} = 0.1 \\text{ 包/周期} $$\n\n**3. 推导平均等待时间 $W$**\n\n该队列被建模为 $M/M/1$ 系统。这对应于非负整数状态空间 $\\{0, 1, 2, \\dots\\}$ 上的生灭过程，其中状态 $n$ 表示系统中有 $n$ 个数据包（在队列中加上在服务中的）。\n设 $P_n$ 为处于状态 $n$ 的稳态概率。\n对所有状态 $n \\ge 0$，出生率（到达）为 $\\lambda$。\n对所有状态 $n \\ge 1$，死亡率（服务完成）为 $\\mu$。\n\n在稳态下，相邻状态之间的流率必须平衡。对于生灭过程，细致平衡方程为：\n$$ \\lambda P_n = \\mu P_{n+1} \\quad \\text{for } n \\ge 0 $$\n这给出了递推关系 $P_{n+1} = \\frac{\\lambda}{\\mu} P_n$。我们定义服务器利用率 $\\rho = \\frac{\\lambda}{\\mu}$。对于一个稳定的队列，必须有 $\\rho  1$。\n递推关系变为 $P_{n+1} = \\rho P_n$。通过归纳法求解可得：\n$$ P_n = \\rho^n P_0 $$\n所有概率之和必须等于 $1$：\n$$ \\sum_{n=0}^{\\infty} P_n = \\sum_{n=0}^{\\infty} \\rho^n P_0 = P_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\n对于 $\\rho  1$，几何级数和为 $\\sum_{n=0}^{\\infty} \\rho^n = \\frac{1}{1-\\rho}$。\n$$ P_0 \\left(\\frac{1}{1-\\rho}\\right) = 1 \\implies P_0 = 1 - \\rho $$\n因此，稳态概率分布为 $P_n = (1-\\rho)\\rho^n$。\n\n系统中的平均数据包数量 $N_{sys}$ 是 $n$ 的期望值：\n$$ N_{sys} = E[n] = \\sum_{n=0}^{\\infty} n P_n = \\sum_{n=1}^{\\infty} n(1-\\rho)\\rho^n = (1-\\rho)\\rho \\sum_{n=1}^{\\infty} n\\rho^{n-1} $$\n将该和式识别为几何级数的导数，$\\sum_{n=1}^{\\infty} n\\rho^{n-1} = \\frac{d}{d\\rho} \\sum_{n=0}^{\\infty} \\rho^n = \\frac{d}{d\\rho}\\left(\\frac{1}{1-\\rho}\\right) = \\frac{1}{(1-\\rho)^2}$。\n$$ N_{sys} = (1-\\rho)\\rho \\frac{1}{(1-\\rho)^2} = \\frac{\\rho}{1-\\rho} $$\nLittle's Law 指出 $N_{sys} = \\lambda T_{sys}$，其中 $T_{sys}$ 是数据包在系统中花费的平均总时间。\n$$ T_{sys} = \\frac{N_{sys}}{\\lambda} = \\frac{\\rho/(1-\\rho)}{\\lambda} = \\frac{(\\lambda/\\mu)/(1-\\lambda/\\mu)}{\\lambda} = \\frac{1/\\mu}{1-\\lambda/\\mu} = \\frac{1}{\\mu-\\lambda} $$\n系统中的总时间 $T_{sys}$ 是队列中的平均等待时间 $W$ 和平均服务时间 $T_{service} = 1/\\mu$ 的和。\n$$ T_{sys} = W + T_{service} \\implies W = T_{sys} - T_{service} $$\n$$ W = \\frac{1}{\\mu-\\lambda} - \\frac{1}{\\mu} = \\frac{\\mu - (\\mu-\\lambda)}{\\mu(\\mu-\\lambda)} = \\frac{\\lambda}{\\mu(\\mu-\\lambda)} $$\n这也可以用 $\\rho$ 来表示：\n$$ W = \\frac{\\lambda/\\mu}{\\mu(1-\\lambda/\\mu)} = \\frac{\\rho}{\\mu(1-\\rho)} $$\n\n**4. $W$ 的数值计算**\n\n我们有以下数值：\n$$ \\lambda = \\frac{5.12}{63} \\text{ 包/周期} \\approx 0.08127 \\text{ 包/周期} $$\n$$ \\mu = 0.1 \\text{ 包/周期} $$\n首先，我们计算利用率 $\\rho$：\n$$ \\rho = \\frac{\\lambda}{\\mu} = \\frac{5.12/63}{0.1} = \\frac{5.12}{6.3} = \\frac{51.2}{63} $$\n由于 $51.2  63$，我们有 $\\rho  1$，队列是稳定的。\n现在，我们使用推导出的公式计算平均等待时间 $W$：\n$$ W = \\frac{\\rho}{\\mu(1-\\rho)} = \\frac{51.2/63}{0.1 \\times (1 - 51.2/63)} = \\frac{51.2/63}{0.1 \\times (11.8/63)} = \\frac{51.2/63}{1.18/63} = \\frac{51.2}{1.18} $$\n$$ W = \\frac{5120}{118} = \\frac{2560}{59} \\approx 43.38983\\dots \\text{ 周期} $$\n四舍五入到四位有效数字，平均等待时间为 $W = 43.39$ 周期。\n\n**M/M/1 近似的局限性**\n\n$M/M/1$ 模型做了几个简化的假设，这些假设对于典型的 NoC 流量不成立，从而导致不准确性：\n- **马尔可夫到达：** 到达的 'M' 假设为泊松过程，其中到达间隔时间是独立且呈指数分布的。真实的 NoC 流量通常是突发和相关的。例如，一个处理器核心可能会在短时间内发出一系列内存请求，或者来自不同源的流量可能因上游阻塞而同步。这种突发性违反了泊松假设，通常会导致比 $M/M/1$ 模型预测的更长的排队延迟。\n- **马尔可夫服务时间：** 第二个 'M' 假设服务时间是指数分布的。问题中指出数据包长度固定为 $L = 10$ flits，链路容量为 $F = 1$ flit/周期。这导致服务时间是一个恒定的、确定性的值，即 10 个周期，而不是一个可变的、指数分布的时间。对于服务过程，$M/D/1$ 模型会更合适。$M/M/1$ 模型假设的服务时间方差比实际存在的要高，与具有相同平均服务时间的 $M/D/1$ 模型相比，这往往会高估等待时间。\n- **队列的独立性：** 将每个链路的输出队列建模为独立的 $M/M/1$ 系统，忽略了虫洞交换网络中队列之间的强依赖性。在虫洞流控中，单个数据包可以同时占用多个链路资源。如果一个数据包的头 flit 在下游路由器处被阻塞，整个数据包都会停滞，从而占用它当前占据的链路。这种反压效应在一条路径上不同队列的状态之间产生了强烈的相关性，这是独立的 $M/M/1$ 队列假设无法捕捉的现象。",
            "answer": "$$\n\\boxed{43.39}\n$$"
        },
        {
            "introduction": "在掌握了单链路的性能分析后，我们将视野扩展到整个网络的吞吐量极限。网络性能并非由平均负载决定，而是由最拥堵的“瓶颈”链路所限制。本练习（）将指导你分析一个具有挑战性的转置流量模式（transpose traffic pattern），通过精确计算每条链路上的流量负载，找出网络中最先饱和的链路，并由此推导出整个网络在崩溃前的临界注入率。",
            "id": "4285091",
            "problem": "考虑一个二维 $k \\times k$ 网格片上网络（NoC），其中每个位于坐标 $(i,j)$（$i,j \\in \\{0,1,\\dots,k-1\\}$）的区块都包含一个路由器。该网格使用确定性维度顺序 $X$-$Y$ 路由，每条物理链路都是双向的，每个方向的独立容量为每个周期 $b$ flit。假设为单flit数据包和均匀稳态注入：每个节点以每个周期 $\\lambda$ flit的速率注入数据包，其目的地遵循合成的转置流量模式，即，源于 $(i,j)$ 的数据包目的地为 $(j,i)$。沿对角线 $(i=j)$ 的自流量不消耗任何链路。忽略有限缓冲效应，并假设理想的流控制，因此吞吐量崩溃由第一条达到其容量的定向链路决定。\n\n使用流量守恒基本原理和维度顺序路由下的路径构成，并且不引用任何预先推导的流量公式，完成以下任务：\n\n1. 推导任意一条从 $(x,y)$ 到 $(x+1,y)$ 的定向水平链路和任意一条从 $(c,r)$ 到 $(c,r+1)$ 的定向垂直链路上的负载（以每个周期flit为单位），将其表示为 $k$、$x$、$y$、$c$、$r$ 和注入率 $\\lambda$ 的函数。\n\n2. 根据这些表达式，确定在转置流量下吞吐量崩溃开始时饱和的定向链路集合。\n\n3. 量化首次饱和发生时的临界均匀注入率 $\\lambda^{\\star}$（单位为每个节点每个周期flit）。\n\n将最终答案表示为关于 $k$ 和 $b$ 的 $\\lambda^{\\star}$ 的单个闭式表达式，单位为每个周期flit。无需四舍五入。在您的推导中，请清楚地指明您找到的饱和链路，但最终只需提供 $\\lambda^{\\star}$ 作为数值表达式。",
            "solution": "首先对用户提供的问题进行严格的验证过程。\n\n### 第1步：提取已知条件\n-   **拓扑结构**：一个二维 $k \\times k$ 网格片上网络（NoC）。\n-   **节点坐标**：每个区块位于坐标 $(i,j)$，其中 $i,j \\in \\{0,1,\\dots,k-1\\}$。\n-   **路由算法**：确定性维度顺序 $X$-$Y$ 路由。\n-   **链路属性**：每条物理链路都是双向的，每个方向的独立容量为每个周期 $b$ flit。\n-   **数据包大小**：单flit数据包。\n-   **流量注入**：每个节点以每个周期 $\\lambda$ flit的速率进行均匀稳态注入。\n-   **流量模式**：转置流量，其中源于 $(i,j)$ 的数据包目的地为 $(j,i)$。\n-   **排除情况**：自流量，即源节点为 $(i,i)$ 的流量，不消耗任何链路。\n-   **模型简化**：忽略有限缓冲效应；流控制是理想的。\n-   **饱和准则**：吞吐量崩溃由第一条达到其容量的定向链路决定。\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学依据**：该问题是NoC性能分析中的一个标准、经典的练习。网格拓扑、维度顺序路由和像转置这样的合成流量模式是计算机体系结构和集成电路设计领域中基础且成熟的模型。饱和分析原理是排队论和网络理论的基石。该问题是合理的。\n-   **适定性**：该问题定义明确。所有参数（$k$、$b$、$\\lambda$）和系统规则（路由、流量模式）都已指定，从而可以得到一个唯一、可确定的临界注入率 $\\lambda^{\\star}$。\n-   **客观性**：该问题以精确、技术性和无偏见的语言陈述，不含任何主观性。\n-   **完整性和一致性**：该问题是自洽的，为完整的解析推导提供了所有必要信息。其假设是内部一致的。\n-   **可行性**：该模型是一个理论抽象，但植根于片上通信网络的物理现实。在其理论框架内，它并非不切实际或不可行。\n-   **清晰度**：所使用的术语（例如，$X-Y$ 路由、转置流量、flit）在NoC的背景下是标准且明确的。\n\n### 第3步：结论与行动\n该问题是**有效的**。将提供完整的解答。\n\n### 推导过程\n\n该问题要求推导转置流量下网络链路上的负载，识别瓶颈链路，并计算最大可持续注入率。我们通过分析数据包所走的路径来进行推导。\n\n在确定性 $X-Y$ 路由下，一个从源节点 $S = (i_s, j_s)$ 到目的节点 $D = (i_d, j_d)$ 的数据包首先沿行 $j_s$ 水平传输，直到到达列 $i_d$，然后沿列 $i_d$ 垂直传输，以到达行 $j_d$。从水平移动到垂直移动的转弯发生在节点 $(i_d, j_s)$。\n\n对于指定的转置流量模式，一个从源节点 $S=(i_s, j_s)$ 发出的数据包的目的地是 $D=(j_s, i_s)$。因此，路径由一个从 $(i_s, j_s)$ 到 $(j_s, j_s)$ 的水平段，以及其后一个从 $(j_s, j_s)$ 到 $(j_s, i_s)$ 的垂直段组成。注意，对于对角线上的节点，即 $i_s=j_s$ 的情况，源和目的地相同，问题陈述该自流量不消耗链路。我们只考虑 $i_s \\neq j_s$ 的情况。\n\n**1. 定向链路上的负载**\n\n我们需要推导向右的水平链路和向上的垂直链路的负载。\n\n**水平链路 $(x,y) \\rightarrow (x+1,y)$ 上的负载：**\n设 $L_h(x,y \\rightarrow x+1,y)$ 为从节点 $(x,y)$到 $(x+1,y)$ 的定向水平链路上的流量负载。要让一个源于 $(i_s, j_s)$ 的数据包穿越此链路，其路径必须包含此段。根据针对转置目的地 $(j_s, i_s)$ 的 $X-Y$ 路由，这需要满足以下条件：\n- 数据包必须沿行 $y$ 传输，因此 $j_s = y$。\n- 水平传输必须是向右的，这意味着目的列 $j_s$ 在源列 $i_s$ 的右侧。因此，$i_s  j_s$。\n- 从列 $x$ 到 $x+1$ 的特定链路必须是从列 $i_s$ 到 $j_s$ 的水平路径的一部分。这意味着 $i_s \\le x  j_s$。\n\n对于给定的链路 $(x,y) \\rightarrow (x+1,y)$，综合这些条件：贡献流量的源节点 $(i_s, j_s)$ 必须满足 $j_s = y$ 和 $i_s \\le x  y$。条件 $x  y$ 是该链路承载任何转置流量的必要前提。如果 $x \\ge y$，则不存在满足 $i_s  y$ 且同时满足 $i_s \\le x$ 的源 $(i_s, y)$，因此负载为 $0$。如果 $x  y$，贡献流量的源是节点集合 $\\{(i_s, y) | 0 \\le i_s \\le x\\}$。此类源节点的数量为 $x+1$。由于每个节点以每个周期 $\\lambda$ flit的速率注入，此链路上的总负载是所有贡献源的注入率之和。\n$$\nL_{h}(x,y \\rightarrow x+1,y) = \n\\begin{cases} \n\\lambda (x+1)  \\text{若 } y > x \\\\\n0  \\text{若 } y \\le x \n\\end{cases}\n$$\n其中 $x \\in \\{0, \\dots, k-2\\}$ 且 $y \\in \\{0, \\dots, k-1\\}$。\n\n**垂直链路 $(c,r) \\rightarrow (c,r+1)$ 上的负载：**\n设 $L_v(c,r \\rightarrow c,r+1)$ 为从节点 $(c,r)$ 到 $(c,r+1)$ 的定向垂直链路上的流量负载。一个从源 $(i_s, j_s)$ 到目的地 $(j_s, i_s)$ 的数据包在以下情况下会穿越此链路：\n- 其行程的垂直部分发生在列 $c$ 上。垂直路径完全在目的列上，所以 $j_s = c$。\n- 垂直传输必须是向上的（行索引增加），这意味着目的行 $i_s$ 大于源行 $j_s$。因此，$i_s > j_s$。\n- 从行 $r$ 到 $r+1$ 的特定链路必须是从行 $j_s$ 到行 $i_s$ 的垂直路径的一部分。这意味着 $j_s \\le r  i_s$。\n\n对于给定的链路 $(c,r) \\rightarrow (c,r+1)$，综合这些条件：贡献流量的源节点 $(i_s, j_s)$ 必须满足 $j_s = c$、$i_s > c$ 和 $c \\le r  i_s$。条件 $c \\le r$ 是必要的。如果 $c > r$，则条件 $j_s \\le r$（其中 $j_s=c$）无法满足，因此负载为 $0$。如果 $c \\le r$，源节点坐标 $(i_s, j_s)$ 的条件变为：$j_s=c$ 和 $i_s > r$（因为 $i_s > c$ 由 $i_s > r$ 和 $r \\ge c$ 所隐含）。贡献流量的源是节点集合 $\\{(i_s, c) | r  i_s \\le k-1\\}$。此类源节点的数量为 $(k-1) - (r+1) + 1 = k-1-r$。此链路上的总负载是：\n$$\nL_{v}(c,r \\rightarrow c,r+1) = \n\\begin{cases} \n\\lambda (k-1-r)  \\text{若 } c \\le r \\\\\n0  \\text{若 } c > r \n\\end{cases}\n$$\n其中 $c \\in \\{0, \\dots, k-1\\}$ 且 $r \\in \\{0, \\dots, k-2\\}$。\n\n**2. 识别饱和链路**\n\n饱和发生在具有最大负载的链路上。我们必须通过在各自的定义域上最大化上面推导出的表达式来找到最大负载。\n\n对于水平链路（向右）：$L_{h}(x,y \\rightarrow x+1,y) = \\lambda (x+1)$，其中 $y > x$。为了最大化这个值，我们必须最大化 $x$。$x$ 的定义域是 $\\{0, \\dots, k-2\\}$。最大值为 $x = k-2$。这给出的负载为 $\\lambda(k-2+1) = \\lambda(k-1)$。当 $x=k-2$ 并且满足条件 $y > x$ 时达到该最大值。这意味着 $y > k-2$，在给定 $y \\le k-1$ 的情况下，意味着 $y=k-1$。因此，最大向右水平负载为 $L_{h,max} = \\lambda(k-1)$，唯一地发生在链路 $((k-2, k-1), (k-1, k-1))$ 上。\n\n对于垂直链路（向上）：$L_{v}(c,r \\rightarrow c,r+1) = \\lambda (k-1-r)$，其中 $c \\le r$。为了最大化这个值，我们必须最小化 $r$。$r$ 的定义域是 $\\{0, \\dots, k-2\\}$。最小值为 $r=0$。这给出的负载为 $\\lambda(k-1-0) = \\lambda(k-1)$。当 $r=0$ 并且满足条件 $c \\le r$ 时达到该最大值。这意味着 $c \\le 0$，即 $c=0$。因此，最大向上垂直负载为 $L_{v,max} = \\lambda(k-1)$，唯一地发生在链路 $((0, 0), (0, 1))$ 上。\n\n从这些表达式中找到的最大负载是 $L_{max} = \\lambda(k-1)$。完整的分析需要检查所有四个方向。对向左和向下链路的类似推导表明，在链路 $((1,0),(0,0))$（向左）和链路 $((k-1,k-1),(k-1,k-2))$（向下）上也达到了相同的最大负载 $\\lambda(k-1)$。因此，达到饱和的定向链路集合由以下四条链路组成：\n- $((k-2, k-1), (k-1, k-1))$\n- $((0, 0), (0, 1))$\n- $((1, 0), (0, 0))$\n- $((k-1, k-1), (k-1, k-2))$\n\n**3. 临界注入率 $\\lambda^{\\star}$**\n\n当利用率最高的链路上的负载等于链路容量 $b$ 时，系统达到饱和。我们发现任何链路上的最大负载为 $L_{max} = \\lambda(k-1)$。设 $\\lambda^{\\star}$ 为首次发生饱和时的临界注入率。此时：\n$$L_{max} = b$$\n$$\\lambda^{\\star} (k-1) = b$$\n解出 $\\lambda^{\\star}$，我们得到：\n$$\\lambda^{\\star} = \\frac{b}{k-1}$$\n该表达式对于 $k \\ge 2$ 有效。对于 $k=1$ 的单节点网格，没有链路也没有流量，因此饱和不是一个有意义的概念，该公式未定义，这是符合逻辑的。",
            "answer": "$$\n\\boxed{\\frac{b}{k-1}}\n$$"
        },
        {
            "introduction": "静态路由虽然简单，但在面对动态变化的网络拥塞时效率低下。为了克服这一局限，自适应路由算法应运而生。本练习（）将带你深入剖析一种经典的自适应路由算法——UGAL（通用全局自适应负载均衡）的核心决策机制。你将学习如何通过结合路径长度（跳数）和实时拥塞信息（队列深度）来量化评估不同路径的预期延迟，并最终推导出在最小化路径和非最小化路径之间做出抉择的关键阈值。",
            "id": "4285037",
            "problem": "一个采用虫洞（wormhole）或虚直通（virtual-cut-through）流量控制的片上网络（NoC）部署在 $2\\text{D}$ 网格上。每个路由器会增加一个恒定的每跳基础延迟，该延迟由路由器流水线延迟 $t_{r}$ 和链路传输延迟 $t_{\\ell}$ 组成。该网络传输单片（single-flit）数据包，因此输出端口上每片的服务（串行化）时间是一个已知的常数 $\\tau$。每个输出端口采用先来先服务（FCFS）调度策略。当一个数据包到达一个输出端口，而该端口当前有 $q$ 片缓存在其前面时，其预期等待时间近似为 $q\\,\\tau$。通用全局自适应负载均衡（UGAL）路由算法在每个源节点为每个数据包做决策，通过比较两种选择的估计端到端延迟，在最小路径和由 Valiant 路由构建的两段式非最小路径（从源节点到随机选择的中间节点，再从中间节点到目的节点）之间做出选择。该比较仅使用本地可测量的量（跳数和下游输出队列占用情况）。\n\n将端到端延迟视为所选路径上所有跳的每跳基础延迟与每跳输出端口等待时间之和。考虑某个时刻一个特定的源-目的节点对。设最小路径的跳数为 $h_{m}$，沿该路径的下游输出端口队列占用总和为 $Q_{m}$。设当前考虑的 Valiant 路径（通过一个均匀随机选择的中间节点）的总跳数为 $h_{v}$，沿其两段路径的下游输出端口队列占用总和为 $Q_{v}$。定义每跳基础延迟 $t_{b}$ 为 $t_{b} = t_{r} + t_{\\ell}$。\n\n从上述基本模型出发，推导出一个关于聚合队列占用阈值差（表示为 $K$）的封闭形式表达式，使得当 $Q_{v} - Q_{m} = K$ 时，UGAL 决策对于选择最小路径或 Valiant 路径是无差异的。将 $K$ 完全用 $h_{m}$、$h_{v}$、$t_{r}$、$t_{\\ell}$ 和 $\\tau$ 来表示。你的最终答案必须是一个单一的封闭形式解析表达式。不要提供不等式。最终答案中不要包含单位。",
            "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n-   片上网络（NoC）部署在 $2\\text{D}$ 网格上。\n-   流量控制：虫洞（wormhole）或虚直通（virtual-cut-through）。\n-   每跳基础延迟：$t_{r} + t_{\\ell}$，其中 $t_{r}$ 是路由器流水线延迟，$t_{\\ell}$ 是链路传输延迟。\n-   数据包是单片（single-flit）的。\n-   每片服务时间（串行化）：常数 $\\tau$。\n-   输出端口调度：先来先服务（FCFS）。\n-   在有 $q$ 片在其前的输出端口的预期等待时间：$q\\,\\tau$。\n-   路由算法：通用全局自适应负载均衡（UGAL）。\n-   最小路径跳数：$h_{m}$。\n-   下游输出端口队列占用总和（最小路径）：$Q_{m}$。\n-   Valiant 路径总跳数：$h_{v}$。\n-   下游输出端口队列占用总和（Valiant 路径）：$Q_{v}$。\n-   定义：每跳基础延迟 $t_{b} = t_{r} + t_{\\ell}$。\n-   目标：在最小路径和 Valiant 路径选择无差异点上，推导聚合队列占用阈值差 $K = Q_{v} - Q_{m}$ 的封闭形式表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，借鉴了片上网络设计领域的既定模型和概念，特别是 UGAL 路由、延迟建模和流量控制。延迟模型虽然是一种简化，却是性能分析中使用的标准且有效的近似方法。该问题提法明确，提供了所有必要的变量和清晰的目标。它以客观、技术性的语言表述。没有矛盾、信息缺失或违反物理或数学原理的情况。该问题需要直接应用给定的模型，使其成为该领域一个有效且可解的练习。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将推导解答。\n\n在片上网络中，数据包穿过一条路径的端到端延迟被建模为所有每跳延迟的总和。每跳的延迟包括两个部分：一个固定的基础延迟和一个因排队引起的可变等待时间。\n\n设 $L$ 表示任意路径的总估计端到端延迟。路径由其跳数 $h$ 和沿路径的输出端口队列占用总和 $Q$ 来表征。\n\n每跳基础延迟定义为 $t_{b} = t_{r} + t_{\\ell}$。对于一条有 $h$ 跳的路径，基础延迟的总贡献为 $h \\cdot t_{b}$。\n\n每跳的等待时间取决于相应输出端口队列中已有的片数。问题陈述，对于大小为 $q$ 的队列，等待时间为 $q \\cdot \\tau$。整条路径的总等待时间是所有跳上这些等待时间的总和。如果我们将第 $i$ 跳的队列占用表示为 $q_{i}$，那么总等待时间是 $\\sum_{i=1}^{h} q_{i}\\tau$。这可以重写为 $\\tau \\left(\\sum_{i=1}^{h} q_{i}\\right)$。问题将下游输出端口队列占用总和定义为 $Q = \\sum_{i=1}^{h} q_{i}$。因此，总等待时间是 $Q\\tau$。\n\n结合这些组成部分，对于跳数为 $h$、聚合队列占用为 $Q$ 的路径，其估计端到端延迟 $L$ 的通用表达式为：\n$$L = h \\cdot t_{b} + Q \\cdot \\tau$$\n代入 $t_{b}$ 的表达式：\n$$L = h(t_{r} + t_{\\ell}) + Q\\tau$$\n\n我们现在将此通用公式应用于 UGAL 算法所考虑的两条特定路径：最小路径和 Valiant 路径。\n\n对于最小路径，跳数为 $h_{m}$，聚合队列占用为 $Q_{m}$。其估计延迟 $L_{m}$ 为：\n$$L_{m} = h_{m}(t_{r} + t_{\\ell}) + Q_{m}\\tau$$\n\n对于 Valiant 路径，跳数为 $h_{v}$，聚合队列占用为 $Q_{v}$。其估计延迟 $L_{v}$ 为：\n$$L_{v} = h_{v}(t_{r} + t_{\\ell}) + Q_{v}\\tau$$\n\n当两条路径的估计延迟相等时，UGAL 的决策是无差异的。我们设 $L_{m} = L_{v}$：\n$$h_{m}(t_{r} + t_{\\ell}) + Q_{m}\\tau = h_{v}(t_{r} + t_{\\ell}) + Q_{v}\\tau$$\n\n问题要求一个关于聚合队列占用阈值差 $K$ 的表达式，定义为 $K = Q_{v} - Q_{m}$。为求此表达式，我们重新整理无差异方程，以分离出包含 $Q_{v}$ 和 $Q_{m}$ 的项。\n让我们将所有与队列相关的项移到方程的一边，所有与跳数相关的项移到另一边：\n$$h_{m}(t_{r} + t_{\\ell}) - h_{v}(t_{r} + t_{\\ell}) = Q_{v}\\tau - Q_{m}\\tau$$\n\n将方程两边的公因式提取出来得到：\n$$(h_{m} - h_{v})(t_{r} + t_{\\ell}) = (Q_{v} - Q_{m})\\tau$$\n\n根据定义，$K = Q_{v} - Q_{m}$。将 $K$ 代入方程：\n$$(h_{m} - h_{v})(t_{r} + t_{\\ell}) = K\\tau$$\n\n最后，为了得到 $K$ 的封闭形式表达式，我们将方程两边同时除以 $\\tau$。由于 $\\tau$ 代表服务时间，它是一个正的物理量，因此除以 $\\tau$ 是有明确定义的。\n$$K = \\frac{(h_{m} - h_{v})(t_{r} + t_{\\ell})}{\\tau}$$\n\n这个表达式完全用给定的参数 $h_{m}$、$h_{v}$、$t_{r}$、$t_{\\ell}$ 和 $\\tau$ 表示了聚合队列占用阈值差 $K$。",
            "answer": "$$\\boxed{\\frac{(h_{m} - h_{v})(t_{r} + t_{\\ell})}{\\tau}}$$"
        }
    ]
}