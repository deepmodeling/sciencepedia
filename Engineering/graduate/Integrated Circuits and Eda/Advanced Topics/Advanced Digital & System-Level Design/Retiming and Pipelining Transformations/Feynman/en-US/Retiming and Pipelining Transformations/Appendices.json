{
    "hands_on_practices": [
        {
            "introduction": "The most fundamental application of pipelining is to increase a circuit's operating frequency by breaking long combinational paths. This first exercise  puts you in the role of a designer tasked with partitioning a datapath to meet a specific performance target. By working through this problem, you will apply a systematic, greedy approach to determine the minimum number of pipeline stages required, providing a practical foundation for understanding the trade-off between latency and clock speed.",
            "id": "4293824",
            "problem": "A synchronous datapath in an Electronic Design Automation (EDA) context consists of a single feedforward chain of $n$ combinational blocks in a fixed topological order, with block $k$ having worst-case Process-Voltage-Temperature (PVT) delay $d_k$. Edge-triggered pipeline registers may be inserted between adjacent blocks to create pipeline stages. Each stage is defined as a contiguous subsequence of the chain and is bounded by pipeline registers at its input and output. The timing of each stage must obey the standard synchronous constraint that the clock period $T$ satisfies $T \\geq t_{\\text{clkq}} + D_{\\text{stage}} + t_{\\text{setup}} + t_{\\text{skew}}$, where $t_{\\text{clkq}}$ is the register clock-to-$Q$ delay, $t_{\\text{setup}}$ is the register setup time, $t_{\\text{skew}}$ is the effective clock skew plus jitter budget, and $D_{\\text{stage}}$ is the total combinational delay across the stage.\n\nYou are given a datapath with $n=10$ and delay profile $\\{d_1,d_2,\\dots,d_{10}\\}$ in nanoseconds defined by\n$$\nd_1=0.33,\\quad d_2=0.21,\\quad d_3=0.18,\\quad d_4=0.52,\\quad d_5=0.19,\\quad d_6=0.41,\\quad d_7=0.27,\\quad d_8=0.36,\\quad d_9=0.44,\\quad d_{10}=0.29.\n$$\nThe register parameters are $t_{\\text{clkq}}=0.08$ nanoseconds, $t_{\\text{setup}}=0.12$ nanoseconds, and $t_{\\text{skew}}=0.04$ nanoseconds. The target clock period specification is $T_{\\text{spec}}=1.50$ nanoseconds.\n\nAssuming retiming transformations can freely move registers across combinational blocks without changing functionality and that pipeline stages must be contiguous segments of the given order, determine the minimum number of pipeline stages $s$ needed so that every stage meets the target $T_{\\text{spec}}$, and specify the stage boundaries as the indices of the last block in each stage (in increasing order). Express your final answer as a single row matrix containing $s$ followed by the $s$ stage-boundary indices, and do not include units. No rounding is required.",
            "solution": "The problem asks for the minimum number of pipeline stages, $s$, and the corresponding stage boundaries for a given feedforward datapath, subject to a specific clock period constraint. A stage is a contiguous sequence of combinational blocks.\n\nFirst, we must validate the problem statement.\nThe givens are:\n- Number of combinational blocks: $n=10$.\n- Delays of the blocks: $\\{d_k\\}_{k=1}^{10}$ in nanoseconds, where $d_1=0.33$, $d_2=0.21$, $d_3=0.18$, $d_4=0.52$, $d_5=0.19$, $d_6=0.41$, $d_7=0.27$, $d_8=0.36$, $d_9=0.44$, and $d_{10}=0.29$.\n- Register clock-to-Q delay: $t_{\\text{clkq}} = 0.08$ ns.\n- Register setup time: $t_{\\text{setup}} = 0.12$ ns.\n- Clock skew and jitter budget: $t_{\\text{skew}} = 0.04$ ns.\n- Target clock period specification: $T_{\\text{spec}} = 1.50$ ns.\n- Timing constraint for any stage: $T \\geq t_{\\text{clkq}} + D_{\\text{stage}} + t_{\\text{setup}} + t_{\\text{skew}}$, where $D_{\\text{stage}}$ is the stage's total combinational delay.\n- The objective is to find the minimum number of stages, $s$, and the stage boundaries, which are the indices of the last block in each stage.\n\nThe problem is scientifically grounded in the principles of synchronous digital circuit design and timing analysis. It is well-posed, as it provides all necessary data and constraints to determine a unique, optimal solution. The terminology is precise and standard in the field of EDA. The problem is therefore valid.\n\nTo solve the problem, we first determine the maximum allowable combinational delay for any single pipeline stage, denoted $D_{\\text{max}}$. The timing constraint must be met for the target clock period, $T_{\\text{spec}}$.\n$$T_{\\text{spec}} \\geq t_{\\text{clkq}} + D_{\\text{stage}} + t_{\\text{setup}} + t_{\\text{skew}}$$\nRearranging this inequality to solve for $D_{\\text{stage}}$ gives:\n$$D_{\\text{stage}} \\leq T_{\\text{spec}} - (t_{\\text{clkq}} + t_{\\text{setup}} + t_{\\text{skew}})$$\nLet's define the total register and clocking overhead, $t_{\\text{overhead}}$, as:\n$$t_{\\text{overhead}} = t_{\\text{clkq}} + t_{\\text{setup}} + t_{\\text{skew}}$$\nSubstituting the given values:\n$$t_{\\text{overhead}} = 0.08 + 0.12 + 0.04 = 0.24 \\text{ ns}$$\nThe maximum combinational delay per stage, $D_{\\text{max}}$, is therefore:\n$$D_{\\text{max}} = T_{\\text{spec}} - t_{\\text{overhead}} = 1.50 - 0.24 = 1.26 \\text{ ns}$$\nAny individual block delay $d_k$ is less than $D_{\\text{max}}$, so a valid partitioning is possible. The problem reduces to partitioning the ordered sequence of block delays $\\{d_1, d_2, \\dots, d_{10}\\}$ into the minimum number of contiguous subsequences, where the sum of delays in each subsequence does not exceed $D_{\\text{max}}$.\n\nThis optimization problem can be solved optimally using a greedy algorithm. Starting from the first unassigned block, we form a stage by including as many subsequent blocks as possible without violating the $D_{\\text{max}}$ constraint. This process is repeated until all blocks are assigned to a stage.\n\nLet's apply this greedy strategy step-by-step.\n\n**Stage 1:**\nWe start with block $1$ and accumulate delays.\n- Delay of $\\{1\\}$: $d_1 = 0.33 \\leq 1.26$.\n- Delay of $\\{1, 2\\}$: $d_1 + d_2 = 0.33 + 0.21 = 0.54 \\leq 1.26$.\n- Delay of $\\{1, 2, 3\\}$: $0.54 + d_3 = 0.54 + 0.18 = 0.72 \\leq 1.26$.\n- Delay of $\\{1, 2, 3, 4\\}$: $0.72 + d_4 = 0.72 + 0.52 = 1.24 \\leq 1.26$.\n- Delay of $\\{1, 2, 3, 4, 5\\}$: $1.24 + d_5 = 1.24 + 0.19 = 1.43 > 1.26$.\nThe sum exceeds $D_{\\text{max}}$ upon including block $5$. Therefore, the first stage must end at block $4$.\nThe first stage consists of blocks $\\{1, 2, 3, 4\\}$. Its total delay is $D_1 = 1.24$ ns.\nThe first stage boundary is index $4$.\n\n**Stage 2:**\nThe next stage starts with block $5$.\n- Delay of $\\{5\\}$: $d_5 = 0.19 \\leq 1.26$.\n- Delay of $\\{5, 6\\}$: $d_5 + d_6 = 0.19 + 0.41 = 0.60 \\leq 1.26$.\n- Delay of $\\{5, 6, 7\\}$: $0.60 + d_7 = 0.60 + 0.27 = 0.87 \\leq 1.26$.\n- Delay of $\\{5, 6, 7, 8\\}$: $0.87 + d_8 = 0.87 + 0.36 = 1.23 \\leq 1.26$.\n- Delay of $\\{5, 6, 7, 8, 9\\}$: $1.23 + d_9 = 1.23 + 0.44 = 1.67 > 1.26$.\nThe sum exceeds $D_{\\text{max}}$ upon including block $9$. Therefore, the second stage must end at block $8$.\nThe second stage consists of blocks $\\{5, 6, 7, 8\\}$. Its total delay is $D_2 = 1.23$ ns.\nThe second stage boundary is index $8$.\n\n**Stage 3:**\nThe final stage starts with block $9$.\n- Delay of $\\{9\\}$: $d_9 = 0.44 \\leq 1.26$.\n- Delay of $\\{9, 10\\}$: $d_9 + d_{10} = 0.44 + 0.29 = 0.73 \\leq 1.26$.\nWe have reached the end of the block chain. The third stage consists of blocks $\\{9, 10\\}$. Its total delay is $D_3 = 0.73$ ns.\nThe third stage boundary is index $10$.\n\nAll $10$ blocks have been partitioned. The minimum number of stages is $s=3$. The stages are $\\{1,2,3,4\\}$, $\\{5,6,7,8\\}$, and $\\{9,10\\}$. The indices of the last block in each stage are $4$, $8$, and $10$.\n\nThe result, as a row matrix containing $s$ followed by the $s$ stage-boundary indices, is $\\begin{pmatrix} 3 & 4 & 8 & 10 \\end{pmatrix}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3 & 4 & 8 & 10\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While theoretical retiming allows registers to move freely, real-world hardware imposes significant constraints. This practice  models a common scenario in Field-Programmable Gate Array (FPGA) design, where dedicated resources like memory blocks (BRAMs) and digital signal processing (DSP) slices have fixed register locations. You will learn to perform retiming optimization within these architectural limits to find the best possible clock period, bridging the gap between abstract algorithms and practical hardware implementation.",
            "id": "4293845",
            "problem": "A synchronous digital circuit implemented on a Field-Programmable Gate Array (FPGA) is modeled by a directed graph $G=(V,E)$ where $V=\\{A,B,C,D\\}$ are combinational logic blocks and $E=\\{(A,B),(B,C),(C,D),(D,A)\\}$ are signal edges arranged in a simple cycle $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$. The timing report provides the following register-to-register combinational delays for the logic blocks: $d(A)=1.6\\,\\text{ns}$, $d(B)=2.1\\,\\text{ns}$, $d(C)=2.9\\,\\text{ns}$, and $d(D)=1.4\\,\\text{ns}$.\n\nThe initial number of registers on each edge is given by $w(A,B)=1$, $w(B,C)=0$, $w(C,D)=0$, and $w(D,A)=1$. The system uses a single clock domain. Dedicated routing and clocking resource limitations impose the following constraints on retiming:\n- The edge $(B,C)$ crosses a Digital Signal Processing (DSP) block boundary that requires at least one pipeline register at the DSP output; thus, after retiming, $w_{r}(B,C) \\geq 1$.\n- The edge $(C,D)$ is implemented entirely within a dedicated carry chain that prohibits placing a register in the chain; thus, after retiming, $w_{r}(C,D)=0$.\n- The edge $(D,A)$ crosses a Block Random Access Memory (BRAM) output that mandates at least one output register; thus, after retiming, $w_{r}(D,A) \\geq 1$.\n- The retiming may not change the total number of registers around the cycle and must preserve non-negativity of edge registers: for every edge $(u,v) \\in E$, $w_{r}(u,v) \\geq 0$ and $\\sum_{e \\in E} w_{r}(e) = \\sum_{e \\in E} w(e)$.\n\nA retiming assigns an integer label $r(v)$ to each node $v \\in V$, and produces a new register count on each edge $(u,v)$ equal to $w_{r}(u,v) = w(u,v) + r(v) - r(u)$.\n\nStarting from the foundational synchronous circuit model, where the clock period $T$ must be at least the maximum combinational delay between successive pipeline registers along any register-to-register path, determine the minimal achievable clock period $T_{\\min}$ under legal retiming that satisfies all the constraints above. Express your final answer in nanoseconds. No rounding is required.",
            "solution": "The user wants to find the minimal achievable clock period $T_{\\min}$ for a synchronous digital circuit under a set of retiming constraints.\n\nFirst, we establish the theoretical foundation. A synchronous circuit is modeled as a directed graph $G=(V, E)$, where $V$ is the set of combinational logic blocks and $E$ is the set of directed edges representing signal paths. Each vertex $v \\in V$ has a combinational delay $d(v)$, and each edge $e \\in E$ has a weight $w(e)$ corresponding to the number of registers on that edge.\n\nA retiming operation assigns an integer lag $r(v)$ to each vertex $v \\in V$. This transforms the register counts on the edges according to the formula $w_r(u,v) = w(u,v) + r(v) - r(u)$ for each edge $(u,v) \\in E$. For a valid retiming, the new register count $w_r(u,v)$ must be a non-negative integer for all edges.\n\nThe clock period $T$ of a synchronous circuit must be at least the delay of the longest combinational path between any two consecutive registers. In the graph model, this means that for any path $P$ of vertices $v_0 \\rightarrow v_1 \\rightarrow \\dots \\rightarrow v_k$ that has a total of zero registers along its edges, the clock period $T$ must satisfy $T \\geq \\sum_{i=0}^{k} d(v_i)$. The goal is to find a retiming $r$ that minimizes this maximum path delay, thereby minimizing the clock period $T$.\n\nLet's formalize the problem using the provided data.\nThe vertices are $V=\\{A, B, C, D\\}$. The delays are $d(A)=1.6\\,\\text{ns}$, $d(B)=2.1\\,\\text{ns}$, $d(C)=2.9\\,\\text{ns}$, and $d(D)=1.4\\,\\text{ns}$.\nThe edges form a cycle $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$.\nThe initial register counts are $w(A,B)=1$, $w(B,C)=0$, $w(C,D)=0$, and $w(D,A)=1$.\n\nA key property of retiming on a cycle is that the total number of registers around the cycle is invariant. The initial total number of registers is:\n$$ W = w(A,B) + w(B,C) + w(C,D) + w(D,A) = 1 + 0 + 0 + 1 = 2 $$\nAny legal retiming must preserve this total, so the sum of the retimed edge weights $w_r(e)$ over the cycle must also be $2$. This is explicitly stated as a constraint.\n\nThe problem imposes several constraints on the retimed register counts, $w_r(e)$:\n1.  $w_r(B,C) \\geq 1$ (Edge crossing a DSP block boundary)\n2.  $w_r(C,D) = 0$ (Edge within a carry chain)\n3.  $w_r(D,A) \\geq 1$ (Edge from a BRAM output)\n4.  $w_r(u,v) \\geq 0$ for all edges (non-negativity of registers, which is a fundamental requirement of retiming)\n5.  $\\sum_{e \\in E} w_r(e) = \\sum_{e \\in E} w(e) = 2$ (Total registers are constant)\n\nLet's find the possible integer values for the retimed register counts $w_r(A,B)$, $w_r(B,C)$, $w_r(C,D)$, and $w_r(D,A)$ that satisfy all these constraints simultaneously.\nFrom constraint 5, we have:\n$$ w_r(A,B) + w_r(B,C) + w_r(C,D) + w_r(D,A) = 2 $$\nUsing constraint 2, $w_r(C,D)=0$, the equation simplifies to:\n$$ w_r(A,B) + w_r(B,C) + w_r(D,A) = 2 $$\nWe also apply constraints 1, 3, and 4:\n- $w_r(B,C) \\geq 1$\n- $w_r(D,A) \\geq 1$\n- $w_r(A,B) \\geq 0$\n\nLet's analyze the sum $w_r(A,B) + w_r(B,C) + w_r(D,A) = 2$.\nSince $w_r(B,C)$ and $w_r(D,A)$ are integers satisfying $w_r(B,C) \\geq 1$ and $w_r(D,A) \\geq 1$, their sum must be at least $1+1=2$. So, $w_r(B,C) + w_r(D,A) \\geq 2$.\nSubstituting this into the sum equation:\n$$ w_r(A,B) + (w_r(B,C) + w_r(D,A)) = 2 $$\nGiven $w_r(A,B) \\geq 0$ and $w_r(B,C) + w_r(D,A) \\geq 2$, the only way for their sum to equal $2$ is if $w_r(A,B) = 0$ and $w_r(B,C) + w_r(D,A) = 2$.\nNow, with the conditions $w_r(B,C) \\geq 1$, $w_r(D,A) \\geq 1$ and their sum being $2$, the only integer solution is $w_r(B,C) = 1$ and $w_r(D,A) = 1$.\n\nThus, the constraints uniquely determine the register distribution after retiming. Any legal retiming satisfying the problem's conditions must result in the following register counts:\n- $w_r(A,B) = 0$\n- $w_r(B,C) = 1$\n- $w_r(C,D) = 0$\n- $w_r(D,A) = 1$\n\nThis configuration is achievable if there exist integers $r(A), r(B), r(C), r(D)$ satisfying the retiming equations. For instance, setting $r(A)=0$, we can solve for the others.\n$w_r(D,A) = w(D,A) + r(A) - r(D) \\implies 1 = 1 + 0 - r(D) \\implies r(D)=0$.\n$w_r(C,D) = w(C,D) + r(D) - r(C) \\implies 0 = 0 + 0 - r(C) \\implies r(C)=0$.\n$w_r(B,C) = w(B,C) + r(C) - r(B) \\implies 1 = 0 + 0 - r(B) \\implies r(B)=-1$.\nThe final check on edge $(A,B)$: $w_r(A,B) = w(A,B) + r(B) - r(A) = 1 + (-1) - 0 = 0$. This matches our derived required configuration. So, the retiming is valid.\n\nWith this unique register configuration, we can determine the minimal clock period. The registers are placed on edges $(B,C)$ and $(D,A)$. This divides the circuit cycle into two register-to-register combinational paths:\n1.  The path from the register on edge $(D,A)$ to the register on edge $(B,C)$. This path traverses the logic blocks $A$ and $B$. Its total combinational delay is $d(A) + d(B)$.\n    $$ T_1 = d(A) + d(B) = 1.6\\,\\text{ns} + 2.1\\,\\text{ns} = 3.7\\,\\text{ns} $$\n2.  The path from the register on edge $(B,C)$ to the register on edge $(D,A)$. This path traverses the logic blocks $C$ and $D$. Its total combinational delay is $d(C) + d(D)$.\n    $$ T_2 = d(C) + d(D) = 2.9\\,\\text{ns} + 1.4\\,\\text{ns} = 4.3\\,\\text{ns} $$\n\nThe clock period $T$ must be greater than or equal to the maximum delay of any register-to-register path.\n$$ T \\geq \\max(T_1, T_2) $$\n$$ T \\geq \\max(3.7\\,\\text{ns}, 4.3\\,\\text{ns}) = 4.3\\,\\text{ns} $$\nSince the constraints permit only one possible register configuration, the minimal clock period achievable under these constraints is determined by this configuration.\nTherefore, the minimal achievable clock period is $T_{\\min} = 4.3\\,\\text{ns}$.",
            "answer": "$$\\boxed{4.3}$$"
        },
        {
            "introduction": "Optimizing a circuit for a faster clock period often involves shortening critical paths, but this can introduce unintended side effects. This advanced exercise  explores a crucial consequence of retiming: the creation of hold-time violations on paths that become too short. You will analyze a retimed path using worst-case timing parameters to identify a hold violation and then determine the precise number of delay buffers needed to ensure the circuit's functional correctness, a vital skill in modern high-speed digital design.",
            "id": "4293812",
            "problem": "A synchronous pipeline implemented in a complementary metal–oxide–semiconductor (CMOS) digital integrated circuit is analyzed via Electronic Design Automation (EDA). The pipeline contains edge-triggered registers and two combinational sub-blocks, labeled $A$ and $B$, originally arranged as $R_{0} \\rightarrow A \\rightarrow B \\rightarrow R_{1}$. A retiming transformation relocates the register boundary to form two stages $R_{0} \\rightarrow A \\rightarrow R_{1}'$ and $R_{1}' \\rightarrow B \\rightarrow R_{2}$, thereby shortening the first stage data path to improve its setup margin.\n\nThe timing is analyzed under worst-case early/late clock arrival conditions. The characterization data are:\n- Minimum delay of the combinational sub-block $A$: $d_{A,\\min} = 0.024\\,\\text{ns}$.\n- Minimum clock-to-$Q$ of the launching register $R_{0}$: $t_{\\mathrm{CQ},\\min} = 0.012\\,\\text{ns}$.\n- Hold-time requirement of the capturing register $R_{1}'$: $t_{\\mathrm{hold}} = 0.030\\,\\text{ns}$.\n- Early and late clock arrival times at the launch and capture registers after retiming:\n  - $t_{\\mathrm{clk},R_{0}}^{\\mathrm{early}} = 0.013\\,\\text{ns}$, $t_{\\mathrm{clk},R_{0}}^{\\mathrm{late}} = 0.040\\,\\text{ns}$,\n  - $t_{\\mathrm{clk},R_{1}'}^{\\mathrm{early}} = 0.027\\,\\text{ns}$, $t_{\\mathrm{clk},R_{1}'}^{\\mathrm{late}} = 0.088\\,\\text{ns}$.\n- A standard buffer available for insertion on the data path has a characterized minimum delay $d_{\\mathrm{buf},\\min} = 0.023\\,\\text{ns}$.\n\nStarting from the fundamental definitions of synchronous timing and hold constraints, use the early/late clock arrival values to analyze the retimed edge $R_{0} \\rightarrow A \\rightarrow R_{1}'$. Determine whether a hold-time violation occurs on this edge under the worst-case hold scenario and, if so, compute the minimum number $N$ of identical buffers (each with minimum delay $d_{\\mathrm{buf},\\min}$) that must be inserted on the data path to guarantee that the retimed path satisfies the hold-time requirement. Express the final answer as the integer buffer count (unitless).",
            "solution": "The problem as stated will first be subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\nThe following data and definitions are explicitly provided in the problem statement:\n- Initial pipeline architecture: $R_{0} \\rightarrow A \\rightarrow B \\rightarrow R_{1}$\n- Retimed pipeline stages: $R_{0} \\rightarrow A \\rightarrow R_{1}'$ and $R_{1}' \\rightarrow B \\rightarrow R_{2}$\n- Minimum delay of combinational sub-block $A$: $d_{A,\\min} = 0.024\\,\\text{ns}$.\n- Minimum clock-to-$Q$ delay of launching register $R_{0}$: $t_{\\mathrm{CQ},\\min} = 0.012\\,\\text{ns}$.\n- Hold-time requirement of capturing register $R_{1}'$: $t_{\\mathrm{hold}} = 0.030\\,\\text{ns}$.\n- Early clock arrival time at $R_{0}$: $t_{\\mathrm{clk},R_{0}}^{\\mathrm{early}} = 0.013\\,\\text{ns}$.\n- Late clock arrival time at $R_{0}$: $t_{\\mathrm{clk},R_{0}}^{\\mathrm{late}} = 0.040\\,\\text{ns}$.\n- Early clock arrival time at $R_{1}'$: $t_{\\mathrm{clk},R_{1}'}^{\\mathrm{early}} = 0.027\\,\\text{ns}$.\n- Late clock arrival time at $R_{1}'$: $t_{\\mathrm{clk},R_{1}'}^{\\mathrm{late}} = 0.088\\,\\text{ns}$.\n- Minimum delay of a standard buffer: $d_{\\mathrm{buf},\\min} = 0.023\\,\\text{ns}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the required criteria:\n- **Scientifically Grounded**: The problem is based on fundamental principles of synchronous digital circuit timing analysis, a core topic in electrical engineering and computer engineering. All terms ($t_{\\mathrm{CQ}}$, $t_{\\mathrm{hold}}$, clock skew, retiming) and the scenario (hold-time violation analysis with buffer insertion) are standard in the field of integrated circuit design and Electronic Design Automation (EDA). The numerical values are physically realistic for modern CMOS processes.\n- **Well-Posed**: The problem is clearly defined and provides all necessary parameters to perform a worst-case hold time analysis. The objective is unambiguous: to determine if a violation exists and to calculate the minimum integer number of buffers required to resolve it. A unique and stable solution can be determined from the givens.\n- **Objective**: The problem is stated in precise, unbiased technical language, free of any subjective or speculative content.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or ambiguity. The presence of late clock arrival times ($t_{\\mathrm{clk}}^{\\mathrm{late}}$) is appropriate, as these are necessary for a complete worst-case timing model, even if only the early times are used for setup analysis and certain combinations are used for hold analysis.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived.\n\nThe fundamental principle of the hold-time constraint for an edge-triggered register is that the data at its input pin must remain stable for a duration $t_{\\mathrm{hold}}$ after the active clock edge arrives. A hold-time violation occurs if new data, launched from a preceding register, arrives too quickly and corrupts the data that the capturing register is supposed to be latching.\n\nLet us denote the clock arrival time at the launch register $R_{0}$ as $t_{\\mathrm{clk},R_{0}}$ and at the capture register $R_{1}'$ as $t_{\\mathrm{clk},R_{1}'}$. These times are measured from a common reference point, such as the ideal clock edge at the clock source. The data launched by $R_{0}$ becomes valid at its output $Q$ after a clock-to-$Q$ delay, $t_{\\mathrm{CQ}}$. This data then propagates through the combinational logic path (block $A$) with a delay $d_{A}$. Therefore, the arrival time of the new data at the input of the capture register $R_{1}'$ is:\n$$t_{\\mathrm{data\\_arrival}} = t_{\\mathrm{clk},R_{0}} + t_{\\mathrm{CQ}} + d_{A}$$\nThe data at the input of $R_{1}'$ is required to be stable until a time $t_{\\mathrm{hold}}$ after its clock edge arrives. This defines the data required time for the hold check:\n$$t_{\\mathrm{data\\_required}} = t_{\\mathrm{clk},R_{1}'} + t_{\\mathrm{hold}}$$\nThe hold constraint is satisfied if the data arrives at or after it is required to be stable:\n$$t_{\\mathrm{data\\_arrival}} \\ge t_{\\mathrm{data\\_required}}$$\nSubstituting the expressions gives the general hold-time inequality:\n$$t_{\\mathrm{clk},R_{0}} + t_{\\mathrm{CQ}} + d_{A} \\ge t_{\\mathrm{clk},R_{1}'} + t_{\\mathrm{hold}}$$\nThe hold slack, $S_{\\mathrm{hold}}$, is defined as the margin by which this constraint is met. A non-negative slack indicates no violation.\n$$S_{\\mathrm{hold}} = (t_{\\mathrm{clk},R_{0}} + t_{\\mathrm{CQ}} + d_{A}) - (t_{\\mathrm{clk},R_{1}'} + t_{\\mathrm{hold}})$$\nA hold-time violation is most likely to occur under the worst-case timing scenario. This corresponds to the minimum possible hold slack. To find this minimum, we must select the combination of parameter values that minimizes the left side of the inequality (fastest data arrival) and maximizes the right side (latest hold requirement relative to the common clock reference). This occurs when:\n1.  The data path is at its fastest: $t_{\\mathrm{CQ}} = t_{\\mathrm{CQ},\\min}$ and $d_{A} = d_{A,\\min}$.\n2.  The clock arrives at the launch register $R_{0}$ as early as possible: $t_{\\mathrm{clk},R_{0}} = t_{\\mathrm{clk},R_{0}}^{\\mathrm{early}}$.\n3.  The clock arrives at the capture register $R_{1}'$ as late as possible: $t_{\\mathrm{clk},R_{1}'} = t_{\\mathrm{clk},R_{1}'}^{\\mathrm{late}}$.\n\nThis last point defines the maximum harmful clock skew for hold analysis, where the clock at the capture register is delayed relative to the clock at the launch register. The worst-case hold slack is thus:\n$$S_{\\mathrm{hold,min}} = (t_{\\mathrm{clk},R_{0}}^{\\mathrm{early}} + t_{\\mathrm{CQ},\\min} + d_{A,\\min}) - (t_{\\mathrm{clk},R_{1}'}^{\\mathrm{late}} + t_{\\mathrm{hold}})$$\nWe now substitute the given numerical values to calculate the slack for the retimed path $R_{0} \\rightarrow A \\rightarrow R_{1}'$:\n$$S_{\\mathrm{hold,min}} = (0.013\\,\\text{ns} + 0.012\\,\\text{ns} + 0.024\\,\\text{ns}) - (0.088\\,\\text{ns} + 0.030\\,\\text{ns})$$\n$$S_{\\mathrm{hold,min}} = (0.049\\,\\text{ns}) - (0.118\\,\\text{ns})$$\n$$S_{\\mathrm{hold,min}} = -0.069\\,\\text{ns}$$\nSince $S_{\\mathrm{hold,min}}$ is negative, a hold-time violation exists. The magnitude of the violation indicates the minimum amount of additional delay, $d_{\\mathrm{required}}$, that must be inserted into the data path to satisfy the constraint:\n$$d_{\\mathrm{required}} = -S_{\\mathrm{hold,min}} = 0.069\\,\\text{ns}$$\nTo fix this violation, we must insert $N$ identical buffers into the data path $A$. Each buffer has a minimum delay of $d_{\\mathrm{buf},\\min} = 0.023\\,\\text{ns}$. The total minimum delay added by $N$ buffers is $N \\times d_{\\mathrm{buf},\\min}$. This added delay must be greater than or equal to the required delay:\n$$N \\times d_{\\mathrm{buf},\\min} \\ge d_{\\mathrm{required}}$$\nSubstituting the values:\n$$N \\times 0.023\\,\\text{ns} \\ge 0.069\\,\\text{ns}$$\nSolving for $N$:\n$$N \\ge \\frac{0.069}{0.023}$$\n$$N \\ge 3$$\nSince $N$ must be an integer representing a physical count of buffers, the minimum number of buffers that must be inserted is $3$.",
            "answer": "$$\\boxed{3}$$"
        }
    ]
}