{
    "hands_on_practices": [
        {
            "introduction": "GALS 设计的核心挑战在于处理亚稳态，这是一种在跨时钟域信号采样时可能发生的短暂不确定状态。虽然我们无法完全消除亚稳态，但可以通过精心设计将其风险降低到可接受的水平。本练习  提供了一种动手计算平均无故障时间 ($MTBF$) 的方法，这是设计可靠同步器的关键指标。通过推导公式并代入实际参数，您将直观地感受到时钟频率和同步器级数等因素如何显著影响系统可靠性。",
            "id": "4274483",
            "problem": "一个全局异步、局部同步 (GALS) 系统使用一个由触发器 (FF) 组成的链作为同步器，将一个单比特控制信号从源时钟域传输到目标时钟域。考虑以下被广泛使用并经实验验证的亚稳态模型：当一个触发器在其有效宽度为 $T_0$ 的孔径窗口内采样一个数据跳变时，该触发器可能进入亚稳态，其稳定时间 $t$ 是一个连续随机变量，其尾部概率呈指数衰减，形式为 $\\Pr\\{t > x\\} = \\exp(-x/\\tau)$，其中 $\\tau$ 是亚稳态时间常数。假设源时钟域以平均速率 $f_s$ 产生独立的数据跳变，目标时钟域以时钟速率 $f_d$ 进行采样，并且两个时钟域之间的数据采样时序是独立的。假设同步器中的每一个额外触发器级都会在下一级触发器采样可能处于亚稳态的输出之前，提供一个额外的可用稳定时间 $T_{\\text{res}}$。\n\n仅从上述定义以及在小窗口近似下每个采样边沿落入孔径窗口内的数据跳变期望数为 $f_s T_0$ 的假设出发，推导出一个 $N$ 级同步器链的平均无故障时间 (MTBF) 的解析表达式，该表达式应使用 $f_s$、$f_d$、$T_0$、$\\tau$、$T_{\\text{res}}$ 和 $N$ 表示。\n\n使用参数 $\\tau = 25\\ \\text{ps}$、$T_0 = 1.2\\ \\text{ns}$、$f_s = 500\\ \\text{MHz}$、$f_d = 1\\ \\text{GHz}$ 和 $T_{\\text{res}} = 150\\ \\text{ps}$，计算该 MTBF 公式在 $N=2$ 和 $N=3$ 时的值，并将数值 MTBF 值以秒为单位表示。最后，将 3 级 MTBF 与 2 级 MTBF 的比值 $R$ 作为你的唯一最终答案。将中间的 MTBF 值四舍五入到 3 位有效数字（以秒为单位），并将最终比值 $R$ 四舍五入到 4 位有效数字。最终报告的比值是无量纲的，并且必须不带任何单位。",
            "solution": "该问题要求推导一个 $N$ 级触发器同步器的平均无故障时间 (MTBF)，针对特定参数进行求值，并计算 3 级同步器与 2 级同步器的 MTBF 之比。解答过程将首先根据所给定义建立 MTBF 的通用解析公式，然后代入给定的数值进行计算。\n\n### 步骤 1：MTBF 公式的推导\n\nMTBF 是失效率 $R_{\\text{fail}}$ 的倒数。当满足以下两个条件时，同步器链会发生失效：\n1.  链中的第一个触发器 (FF) 在其孔径窗口期间采样异步输入数据，导致其进入亚稳态。\n2.  这个亚稳态未能在同步器链提供的总时间内稳定到稳定的逻辑电平。\n\n我们来分析每个事件的发生率。\n\n第一个触发器进入亚稳态的速率 $R_{\\text{meta}}$，是目标端采样事件的速率与每次采样事件中在孔径窗口内捕获到数据跳变的概率的乘积。目标时钟域以时钟速率 $f_d$ 进行采样。问题给出了一个假设：“每个采样边沿落入孔径窗口内的数据跳变期望数为 $f_s T_0$”。在小窗口近似 ($f_s T_0 \\ll 1$) 下，这个量代表捕获概率 $P_{\\text{capture}}$。\n因此，进入亚稳态的速率为：\n$$ R_{\\text{meta}} = f_d \\cdot P_{\\text{capture}} = f_d f_s T_0 $$\n\n接下来，我们必须确定亚稳态导致系统失效的概率。问题提供了一个亚稳态稳定时间 $t$ 的模型，其中稳定时间超过某个时长 $x$ 的概率由 $\\Pr\\{t > x\\} = \\exp(-x/\\tau)$ 给出。如果稳定时间 $t$ 超过了可用的总稳定时间，则发生失效。对于一个 $N$ 级同步器，我们将其记为 $T_{\\text{avail}}(N)$。\n在发生亚稳态的情况下，失效的概率为：\n$$ P_{\\text{fail|meta}} = \\Pr\\{t > T_{\\text{avail}}(N)\\} = \\exp\\left(-\\frac{T_{\\text{avail}}(N)}{\\tau}\\right) $$\n\n问题陈述道：“同步器中的每一个额外触发器级都会提供一个额外的可用稳定时间 $T_{\\text{res}}$”。这表明总可用稳定时间是一个累积模型。多级同步器的基准是一个 2 级链 ($N=2$)，它为第一个触发器提供一个完整的目标时钟周期 $T_d = 1/f_d$ 的时间来稳定，然后其输出才被第二个触发器采样。因此，我们定义 $N=2$ 时的可用时间为 $T_{\\text{avail}}(2) = T_d = 1/f_d$。\n对于每个额外的级（即，对于 $N > 2$），会增加一个额外的时间 $T_{\\text{res}}$。\n对于 $N=3$，$T_{\\text{avail}}(3) = T_{\\text{avail}}(2) + T_{\\text{res}} = T_d + T_{\\text{res}}$。\n对于 $N=4$，$T_{\\text{avail}}(4) = T_{\\text{avail}}(3) + T_{\\text{res}} = T_d + 2T_{\\text{res}}$。\n对于 $N \\ge 2$ 进行推广，总可用稳定时间为：\n$$ T_{\\text{avail}}(N) = T_d + (N-2)T_{\\text{res}} = \\frac{1}{f_d} + (N-2)T_{\\text{res}} $$\n\n$N$ 级同步器的总失效率 $R_{\\text{fail}}(N)$ 是进入亚稳态的速率与该状态未能及时稳定的概率的乘积。\n$$ R_{\\text{fail}}(N) = R_{\\text{meta}} \\cdot P_{\\text{fail|meta}} = (f_d f_s T_0) \\exp\\left(-\\frac{T_{\\text{avail}}(N)}{\\tau}\\right) $$\n代入 $T_{\\text{avail}}(N)$ 的表达式：\n$$ R_{\\text{fail}}(N) = (f_d f_s T_0) \\exp\\left(-\\frac{1/f_d + (N-2)T_{\\text{res}}}{\\tau}\\right) $$\n\nMTBF 是失效率的倒数：\n$$ MTBF(N) = \\frac{1}{R_{\\text{fail}}(N)} = \\frac{1}{f_d f_s T_0} \\exp\\left(\\frac{1/f_d + (N-2)T_{\\text{res}}}{\\tau}\\right) $$\n这就是对于 $N \\ge 2$ 的 $N$ 级同步器所需的 MTBF 解析表达式。\n\n### 步骤 2：对 N=2 和 N=3 进行数值计算\n\n给定以下参数：\n- $\\tau = 25\\ \\text{ps} = 25 \\times 10^{-12}\\ \\text{s}$\n- $T_0 = 1.2\\ \\text{ns} = 1.2 \\times 10^{-9}\\ \\text{s}$\n- $f_s = 500\\ \\text{MHz} = 5 \\times 10^{8}\\ \\text{Hz}$\n- $f_d = 1\\ \\text{GHz} = 1 \\times 10^{9}\\ \\text{Hz}$\n- $T_{\\text{res}} = 150\\ \\text{ps} = 150 \\times 10^{-12}\\ \\text{s}$\n\n首先，我们计算目标时钟周期 $T_d$ 和分母项 $f_d f_s T_0$。\n$$ T_d = \\frac{1}{f_d} = \\frac{1}{1 \\times 10^9\\ \\text{Hz}} = 1 \\times 10^{-9}\\ \\text{s} = 1\\ \\text{ns} $$\n$$ f_d f_s T_0 = (1 \\times 10^9\\ \\text{s}^{-1}) \\cdot (5 \\times 10^8\\ \\text{s}^{-1}) \\cdot (1.2 \\times 10^{-9}\\ \\text{s}) = 6 \\times 10^8\\ \\text{s}^{-1} $$\n\n**对于 2 级同步器 ($N=2$)：**\n可用稳定时间为 $T_{\\text{avail}}(2) = T_d = 1\\ \\text{ns}$。\n指数的参数为：\n$$ \\frac{T_{\\text{avail}}(2)}{\\tau} = \\frac{1 \\times 10^{-9}\\ \\text{s}}{25 \\times 10^{-12}\\ \\text{s}} = 40 $$\nMTBF 为：\n$$ MTBF(2) = \\frac{\\exp(40)}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx \\frac{2.35385 \\times 10^{17}}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx 3.92309 \\times 10^8\\ \\text{s} $$\n四舍五入到 3 位有效数字，$MTBF(2) \\approx 3.92 \\times 10^8\\ \\text{s}$。\n\n**对于 3 级同步器 ($N=3$)：**\n可用稳定时间为 $T_{\\text{avail}}(3) = T_d + (3-2)T_{\\text{res}} = T_d + T_{\\text{res}}$。\n$$ T_{\\text{avail}}(3) = 1\\ \\text{ns} + 150\\ \\text{ps} = 1 \\times 10^{-9}\\ \\text{s} + 0.15 \\times 10^{-9}\\ \\text{s} = 1.15 \\times 10^{-9}\\ \\text{s} $$\n指数的参数为：\n$$ \\frac{T_{\\text{avail}}(3)}{\\tau} = \\frac{1.15 \\times 10^{-9}\\ \\text{s}}{25 \\times 10^{-12}\\ \\text{s}} = 46 $$\nMTBF 为：\n$$ MTBF(3) = \\frac{\\exp(46)}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx \\frac{9.47450 \\times 10^{19}}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx 1.57908 \\times 10^{11}\\ \\text{s} $$\n四舍五入到 3 位有效数字，$MTBF(3) \\approx 1.58 \\times 10^{11}\\ \\text{s}$。\n\n### 步骤 3：计算比值 R\n\n最终答案是比值 $R = MTBF(3) / MTBF(2)$。使用推导出的解析表达式可以得到最准确的结果，因为可以约掉公因子，并避免由大的中间数可能引起的浮点误差。\n$$ R = \\frac{MTBF(3)}{MTBF(2)} = \\frac{\\frac{1}{f_d f_s T_0} \\exp\\left(\\frac{T_d + T_{res}}{\\tau}\\right)}{\\frac{1}{f_d f_s T_0} \\exp\\left(\\frac{T_d}{\\tau}\\right)} = \\frac{\\exp\\left(\\frac{T_d}{\\tau} + \\frac{T_{res}}{\\tau}\\right)}{\\exp\\left(\\frac{T_d}{\\tau}\\right)} $$\n$$ R = \\exp\\left(\\left(\\frac{T_d}{\\tau} + \\frac{T_{res}}{\\tau}\\right) - \\frac{T_d}{\\tau}\\right) = \\exp\\left(\\frac{T_{res}}{\\tau}\\right) $$\n现在，我们代入 $T_{res}$ 和 $\\tau$ 的值：\n$$ \\frac{T_{res}}{\\tau} = \\frac{150 \\times 10^{-12}\\ \\text{s}}{25 \\times 10^{-12}\\ \\text{s}} = 6 $$\n因此，该比值为：\n$$ R = \\exp(6) \\approx 403.428793... $$\n将最终比值 $R$ 四舍五入到 4 位有效数字，得到 $403.4$。",
            "answer": "$$\\boxed{403.4}$$"
        },
        {
            "introduction": "在建立了可靠的单比特信号跨越后，GALS 系统中更常见的任务是传输数据流，这通常通过异步先进先出（FIFO）缓冲器来实现。此练习  将重点从单比特控制信号转移到数据总线，并引入了一个核心挑战：如何管理具有不同标称频率和实际时钟漂移（以 ppm 衡量）的两个时钟域之间的数据流。通过本练习，您将学习如何计算避免数据丢失（上溢或下溢）所需的 FIFO 深度，这是设计弹性 GALS 通信通道的一项基本技能。",
            "id": "4274541",
            "problem": "考虑一个全局异步，局部同步 (GALS) 通道，该通道通过一个先入先出 (FIFO) 缓冲器实现，用于连接两个独立的时钟域。写入端逻辑的时钟标称速率为 $f_{w} = 600\\text{ MHz}$，读取端逻辑的时钟标称速率为 $f_{r} = 500\\text{ MHz}$。假设 FIFO 在每个写入端时钟周期将其写指针加 $1$，在每个读取端时钟周期将其读指针加 $1$，且无停顿，因此瞬时写入和读取速率分别等于其各自的时钟频率。FIFO 深度为 $D = 64$ 个条目。\n\n每个时钟源都是自由运行的，并且可以在 $\\pm 50\\text{ ppm}$ 的有界频率稳定性范围内偏离标称值，各个域之间相互独立。将 FIFO 占用漂移 $N(t)$（以条目为单位）建模为从 $N(0) = 0$ 开始，写入和读取之间瞬时速率差的时间积分。设观测区间为 $T = 1\\text{ ms}$。\n\n仅使用累积令牌积聚的速率差定义和百万分率频率稳定性的标准属性，完成以下任务：\n- 在标称频率下（即忽略 $\\pm 50\\text{ ppm}$ 的偏差），计算在区间 $[0, T]$ 内的预期 FIFO 占用漂移。\n- 在每个域 $\\pm 50\\text{ ppm}$ 边界内的最坏频率偏差情况下，计算在相同区间内为避免溢出所需的最小 FIFO 深度（整数个条目）。\n\n将两个结果都表示为精确整数（不进行四舍五入），并以条目数报告。最终答案必须是包含这两个量的单个复合结果。",
            "solution": "FIFO 占用漂移 $N(t)$ 表示随时间推移缓冲器中条目的净累积量。它定义为瞬时写入速率 $r_w(t)$ 和瞬时读取速率 $r_r(t)$ 之差的时间积分。初始条件为 $N(0) = 0$。\n\n$$N(T) = \\int_{0}^{T} [r_w(\\tau) - r_r(\\tau)] d\\tau$$\n\n问题假设瞬时写入和读取速率分别等于其各自的时钟频率 $f_w(t)$ 和 $f_r(t)$。因此，我们有 $r_w(t) = f_w(t)$ 和 $r_r(t) = f_r(t)$。\n\n第一个任务是计算在标称频率下，区间 $T = 1 \\text{ ms}$ 内的预期 FIFO 占用漂移。\n\n标称频率为：\n- 写入频率: $f_{w,nom} = 600 \\text{ MHz} = 600 \\times 10^6 \\text{ s}^{-1}$\n- 读取频率: $f_{r,nom} = 500 \\text{ MHz} = 500 \\times 10^6 \\text{ s}^{-1}$\n\n观测区间为 $T = 1 \\text{ ms} = 1 \\times 10^{-3} \\text{ s}$。\n\n在标称条件下，频率是恒定的。速率差也是恒定的：\n$$ \\Delta f_{nom} = f_{w,nom} - f_{r,nom} = (600 \\times 10^6) - (500 \\times 10^6) = 100 \\times 10^6 \\text{ s}^{-1} $$\n\n预期占用漂移 $N_{nom}(T)$ 是这个恒定速率差在区间 $[0, T]$ 上的积分：\n$$ N_{nom}(T) = \\int_{0}^{T} \\Delta f_{nom} d\\tau = \\Delta f_{nom} \\times T $$\n$$ N_{nom}(T) = (100 \\times 10^6 \\text{ s}^{-1}) \\times (1 \\times 10^{-3} \\text{ s}) = 100 \\times 10^3 = 100,000 $$\n预期的 FIFO 占用漂移为 $100,000$ 个条目。\n\n第二个任务是计算在考虑最坏情况频率偏差时，为避免在相同区间内发生溢出所需的最小 FIFO 深度。\n\n每个时钟源的频率稳定性为 $\\delta = \\pm 50 \\text{ ppm}$，即分数偏差为 $\\pm 50 \\times 10^{-6}$。为了找到最大可能的占用漂移，我们必须找到最大可能的速率差。这发生在写入频率达到其最大值而读取频率达到其最小值时。\n\n最大写入频率为：\n$$ f_{w,max} = f_{w,nom} (1 + 50 \\times 10^{-6}) = (600 \\times 10^6)(1.00005) \\text{ s}^{-1} $$\n\n最小读取频率为：\n$$ f_{r,min} = f_{r,nom} (1 - 50 \\times 10^{-6}) = (500 \\times 10^6)(0.99995) \\text{ s}^{-1} $$\n\n最壞情況（最大）速率差 $\\Delta f_{max}$ 为：\n$$ \\Delta f_{max} = f_{w,max} - f_{r,min} $$\n$$ \\Delta f_{max} = f_{w,nom}(1 + 50 \\times 10^{-6}) - f_{r,nom}(1 - 50 \\times 10^{-6}) $$\n$$ \\Delta f_{max} = (f_{w,nom} - f_{r,nom}) + (f_{w,nom} + f_{r,nom})(50 \\times 10^{-6}) $$\n\n代入数值：\n$$ \\Delta f_{max} = (100 \\times 10^6) + (600 \\times 10^6 + 500 \\times 10^6)(50 \\times 10^{-6}) $$\n$$ \\Delta f_{max} = (100 \\times 10^6) + (1100 \\times 10^6)(50 \\times 10^{-6}) $$\n$$ \\Delta f_{max} = (100 \\times 10^6) + (11 \\times 10^8)(5 \\times 10^{-5}) $$\n$$ \\Delta f_{max} = 100 \\times 10^6 + 55 \\times 10^3 = 100,000,000 + 55,000 = 100,055,000 \\text{ s}^{-1} $$\n\n最大占用漂移 $N_{max}(T)$ 是这个最大恒定速率差在区间 $[0, T]$ 上的积分：\n$$ N_{max}(T) = \\Delta f_{max} \\times T $$\n$$ N_{max}(T) = (100,055,000 \\text{ s}^{-1}) \\times (1 \\times 10^{-3} \\text{ s}) = 100,055 $$\n\n为避免溢出，FIFO 深度必须至少等于累積的最大条目数。由于计算得出一个精确整数，所需的最小 FIFO 深度为 $100,055$ 个条目。给定的 FIFO 深度 $D=64$ 对于此观测区间是不够的。\n\n计算出的两个量是：\n1. 预期标称占用漂移：$100,000$ 个条目。\n2. 最坏情况下偏差所需的最小 FIFO 深度：$100,055$ 个条目。",
            "answer": "$$\\boxed{\\begin{pmatrix} 100000 & 100055 \\end{pmatrix}}$$"
        },
        {
            "introduction": "一个在理论上正确的 GALS 设计，如果无法被正确实现和验证，那便是纸上谈兵。最后的这项实践  将设计理论与电子设计自动化（EDA）工具的实际应用联系起来。它专注于为静态时序分析（STA）创建必要的 Synopsys 设计约束（SDC），从而指导工具正确地忽略异步路径，同时对各个同步域内部的逻辑进行精确的时序分析。掌握这项技能对于确保 GALS 设计能够成功通过时序收敛并在芯片上正常工作至关重要。",
            "id": "4274542",
            "problem": "考虑一个在全局异步、局部同步 (GALS) 系统中设计的双时钟先进先出 (FIFO) 接口。您需要通过从第一性原理进行逻辑推导，形式化此接口的 Synopsys 设计约束 (SDC)，确定需要哪些约束以及每种类型的约束必须存在多少个。该接口连接一个写时钟域和一个读时钟域。每个域可能都有从各自的主时钟派生出来的内部生成时钟。静态时序分析依赖于正确的时钟声明和跨异步交叉点的适当例外。\n\n使用的基本原理：\n- 在纯同步路径中，时序分析使用时钟周期 $T$ 来评估建立和保持约束；时钟频率为 $f = 1/T$。\n- 一个时钟域由一个主时钟定义确定；一个生成时钟是源时钟的确定性变换（例如，分频操作）。\n- 无关时钟之间的异步路径不进行时序分析；必须使用明确定义的构造将其从分析中排除。\n- 同步器链是目标时钟域上一系列触发器，用于缓解跨时钟域信号的亚稳态问题。在同步时序中，默认假设强制每级采用单周期时序；显式多周期例外调整该假设，以在适当时允许多周期行为。\n\n应用的定义和假设：\n- 定义一个周期为 $T_{\\mathrm{w}}$（单位：纳秒）的主写时钟 $C_{\\mathrm{w}}$ 和一个周期为 $T_{\\mathrm{r}}$（单位：纳秒）的主读时钟 $C_{\\mathrm{r}}$。\n- 对于生成时钟，每个都有一个名称、一个源主时钟和一个整数分频因子 $d \\geq 2$，该因子创建一个周期为 $d \\cdot T_{\\text{source}}$ 的派生时钟。\n- 必须通过将 $C_{\\mathrm{w}}$ 和 $C_{\\mathrm{r}}$ 之间的异步交叉声明为异步来将其从时序分析中排除。必须考虑写域和读域之间的两个显式伪路径（每个方向一个），以对特定方向的排除进行建模。\n- 同步器链在目标域中有长度为 $L \\geq 1$ 级，宽度为 $N \\geq 1$ 位。为解决此问题，假设对于链中的每一对相邻触发器，需要对所有 $N$ 位应用一个显式多周期路径例外。如果 $L = 1$，则没有相邻对，也不会产生多周期例外。\n- 假定每个相邻对的多周期例外使用一个两周期的建立时间松弛和一个一周期的保持时间调整，但您不需要输出数值；只需计算所有链和所有位需要多少个多周期例外。\n\n您的任务：\n- 对于每个提供的测试案例，逻辑上对所需的SDC指令进行建模，并计算以下指标：\n  1. 必须定义的主时钟数量。\n  2. 必须定义的生成时钟数量。\n  3. 在写域和读域之间切断时序所需的异步时钟组声明数量。\n  4. 两个域之间的显式伪路径声明数量（有方向性）。\n  5. 所有同步器链和所有位所需的多周期路径例外数量，计算为所有链上 $(L - 1) \\cdot N$ 的总和。\n\n测试套件：\n- 案例 1 (正常路径)：\n  - $T_{\\mathrm{w}} = 5$ 纳秒, $T_{\\mathrm{r}} = 8$ 纳秒。\n  - 生成时钟：`wr_div2` 来自 $C_{\\mathrm{w}}$，分频因子 $d = 2$；`rd_div4` 来自 $C_{\\mathrm{r}}$，分频因子 $d = 4$。\n  - 同步器链：\n    - 读域中的写到读指针同步：长度 $L = 2$，宽度 $N = 5$ 位。\n    - 写域中的读到写指针同步：长度 $L = 2$，宽度 $N = 5$ 位。\n- 案例 2 (边界情况，无生成时钟和简单同步器)：\n  - $T_{\\mathrm{w}} = 3$ 纳秒, $T_{\\mathrm{r}} = 10$ 纳秒。\n  - 生成时钟：无。\n  - 同步器链：\n    - 读域中的写到读数据有效同步：长度 $L = 1$，宽度 $N = 7$ 位。\n    - 写域中的读到写就绪同步：长度 $L = 1$，宽度 $N = 7$ 位。\n- 案例 3 (边缘情况，具有更深的同步器和多个生成时钟)：\n  - $T_{\\mathrm{w}} = 4$ 纳秒, $T_{\\mathrm{r}} = 6$ 纳秒。\n  - 生成时钟：`wr_div2` 来自 $C_{\\mathrm{w}}$，分频因子 $d = 2$；`wr_div4` 来自 $C_{\\mathrm{w}}$，分频因子 $d = 4$。\n  - 同步器链：\n    - 读域中的写到读指针同步：长度 $L = 3$，宽度 $N = 4$ 位。\n    - 写域中的读到写指针同步：长度 $L = 3$，宽度 $N = 4$ 位。\n\n程序要求：\n- 实现一个程序，为每个测试案例计算上述五个指标作为整数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例的指标表示为按给定顺序排列的五个整数的列表。例如，输出格式必须像 $[\\,[C_{1},G_{1},A_{1},F_{1},M_{1}],\\,[C_{2},G_{2},A_{2},F_{2},M_{2}],\\,[C_{3},G_{3},A_{3},F_{3},M_{3}]\\,]$。\n- 没有输入。所有数据都从上面的测试套件中硬编码。\n- 在计数计算中不需要进行物理单位转换，但为了科学的完整性，周期以纳秒为单位给出。不使用角度。\n\n交付物：\n- 一个单一、完整、独立的程序，实现上述功能并打印指定的单行输出，其中包含三个测试案例的整数列表的列表。",
            "solution": "通过应用所提供的原理和定义，为每个测试案例计算五个必需的指标。\n\n**1. 主时钟数量 ($C$)**\n问题定义了一个双时钟FIFO，有一个写时钟域和一个读时钟域。每个域由一个主时钟定义。问题陈述：“定义一个主写时钟 $C_{\\mathrm{w}}$... 和一个主读时钟 $C_{\\mathrm{r}}$”。这为系统建立了两个基本的、独立的时钟源。因此，需要定义的主时钟数量总是 $2$。\n对于所有测试案例，$C = 2$。\n\n**2. 生成时钟数量 ($G$)**\n生成时钟派生自一个主时钟。生成时钟的数量是通过计算每个测试案例中提供的定义来确定的。\n- **案例 1**：指定了两个生成时钟：来自 $C_{\\mathrm{w}}$ 的 `wr_div2` 和来自 $C_{\\mathrm{r}}$ 的 `rd_div4`。因此，$G_1=2$。\n- **案例 2**：未指定生成时钟。因此，$G_2=0$。\n- **案例 3**：指定了两个生成时钟：`wr_div2` 和 `wr_div4`，都来自 $C_{\\mathrm{w}}$。因此，$G_3=2$。\n\n**3. 异步时钟组声明数量 ($A$)**\n问题要求将写时钟域和读时钟域声明为异步，以防止STA工具分析它们之间的路径。一个 `set_clock_groups -asynchronous` 指令是实现这一目标的标准且有效的方法。一个组将包含 $C_{\\mathrm{w}}$ 及其所有生成时钟，第二个组将包含 $C_{\\mathrm{r}}$ 及其所有生成时钟。由于只有两个基本的异步域（写和读），一个这样的声明是必要且充分的。\n对于所有测试案例，$A = 1$。\n\n**4. 显式伪路径声明数量 ($F$)**\n问题陈述给出了一个直接且无条件的指令：“必须考虑写域和读域之间的两个显式伪路径（每个方向一个）”。这是问题形式化的一个具体要求，无论是否也使用了 `set_clock_groups`。这两个路径对应于从写域到读域的交叉和从读域到写域的交叉。\n对于所有测试案例，$F = 2$。\n\n**5. 多周期路径例外数量 ($M$)**\n多周期路径例外的数量由公式 $\\sum (L - 1) \\cdot N$ 明确定义，对所有同步器链求和。长度为 $L$ 的同步器有 $L-1$ 个相邻触发器级。对于这些级中的每一个，都需要为同步总线的所有 $N$ 位设置例外。\n- **案例 1**：\n  - W-to-R 链：$L=2, N=5$。例外数 = $(2-1) \\cdot 5 = 1 \\cdot 5 = 5$。\n  - R-to-W 链：$L=2, N=5$。例外数 = $(2-1) \\cdot 5 = 1 \\cdot 5 = 5$。\n  - 总计 $M_1 = 5 + 5 = 10$。\n- **案例 2**：\n  - W-to-R 链：$L=1, N=7$。例外数 = $(1-1) \\cdot 7 = 0 \\cdot 7 = 0$。\n  - R-to-W 链：$L=1, N=7$。例外数 = $(1-1) \\cdot 7 = 0 \\cdot 7 = 0$。\n  - 总计 $M_2 = 0 + 0 = 0$。这与 $L=1$ 时不需要例外的规则一致。\n- **案例 3**：\n  - W-to-R 链：$L=3, N=4$。例外数 = $(3-1) \\cdot 4 = 2 \\cdot 4 = 8$。\n  - R-to-W 链：$L=3, N=4$。例外数 = $(3-1) \\cdot 4 = 2 \\cdot 4 = 8$。\n  - 总计 $M_3 = 8 + 8 = 16$。\n\n**结果总结**\n\n- **案例 1**：$[C_1, G_1, A_1, F_1, M_1] = [2, 2, 1, 2, 10]$\n- **案例 2**：$[C_2, G_2, A_2, F_2, M_2] = [2, 0, 1, 2, 0]$\n- **案例 3**：$[C_3, G_3, A_3, F_3, M_3] = [2, 2, 1, 2, 16]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this problem.\n\ndef solve():\n    \"\"\"\n    Computes the SDC constraint metrics for the given test cases.\n    \"\"\"\n    \n    # Define the test cases based on the problem statement.\n    # Each case is a dictionary containing its specific parameters.\n    test_cases = [\n        {\n            # Case 1 (happy path)\n            \"generated_clocks\": [\n                {\"source\": \"Cw\", \"div\": 2},\n                {\"source\": \"Cr\", \"div\": 4}\n            ],\n            \"synchronizers\": [\n                {\"L\": 2, \"N\": 5},  # Write-to-read pointer\n                {\"L\": 2, \"N\": 5}   # Read-to-write pointer\n            ]\n        },\n        {\n            # Case 2 (boundary with no generated clocks and trivial synchronizer)\n            \"generated_clocks\": [],\n            \"synchronizers\": [\n                {\"L\": 1, \"N\": 7},  # Write-to-read data-valid\n                {\"L\": 1, \"N\": 7}   # Read-to-write ready\n            ]\n        },\n        {\n            # Case 3 (edge with deeper synchronizer and multiple generated clocks)\n            \"generated_clocks\": [\n                {\"source\": \"Cw\", \"div\": 2},\n                {\"source\": \"Cw\", \"div\": 4}\n            ],\n            \"synchronizers\": [\n                {\"L\": 3, \"N\": 4},  # Write-to-read pointer\n                {\"L\": 3, \"N\": 4}   # Read-to-write pointer\n            ]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # 1. Number of primary clocks (C)\n        # The system is a dual-clock FIFO, with a primary write clock (Cw)\n        # and a primary read clock (Cr) by definition.\n        num_primary_clocks = 2\n\n        # 2. Number of generated clocks (G)\n        # This is a direct count of the generated clocks defined for the case.\n        num_generated_clocks = len(case[\"generated_clocks\"])\n\n        # 3. Number of asynchronous clock group declarations (A)\n        # A single declaration is sufficient to define the two groups\n        # (write domain clocks and read domain clocks) as asynchronous.\n        num_async_groups = 1\n\n        # 4. Number of explicit false path declarations (F)\n        # The problem explicitly requires two directional false path declarations.\n        num_false_paths = 2\n\n        # 5. Number of multicycle path exceptions (M)\n        # Calculated using the formula (L - 1) * N for each synchronizer chain.\n        num_multicycle_exceptions = 0\n        for sync in case[\"synchronizers\"]:\n            L = sync[\"L\"]\n            N = sync[\"N\"]\n            # A synchronizer of length L has (L-1) adjacent stages.\n            # No exceptions if L=1.\n            if L > 1:\n                num_multicycle_exceptions += (L - 1) * N\n        \n        # Collect the five metrics for the current case.\n        case_results = [\n            num_primary_clocks,\n            num_generated_clocks,\n            num_async_groups,\n            num_false_paths,\n            num_multicycle_exceptions\n        ]\n        results.append(case_results)\n\n    # Format the final output as a single string according to the specification.\n    # Example: [[C1,G1,A1,F1,M1],[C2,G2,A2,F2,M2],[C3,G3,A3,F3,M3]]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}