{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any GALS system lies the challenge of reliably passing signals between different clock domains. This practice delves into the phenomenon of metastability, an unavoidable consequence of violating flip-flop timing requirements at asynchronous interfaces. By deriving and applying the formula for Mean Time Between Failures (MTBF), you will gain a quantitative understanding of how multi-stage synchronizers dramatically improve system reliability, transforming a probabilistic risk into a manageable engineering parameter .",
            "id": "4274483",
            "problem": "A globally asynchronous, locally synchronous (GALS) system uses a chain of flip-flops (FFs) as a synchronizer to transfer a single-bit control signal from a source clock domain to a destination clock domain. Consider the following widely used and experimentally validated metastability model: when an FF samples a data transition within an aperture window of effective width $T_0$, the FF may enter a metastable state whose resolution time $t$ is a continuous random variable with a tail probability that decays exponentially as $\\Pr\\{t > x\\} = \\exp(-x/\\tau)$, where $\\tau$ is the metastability time constant. Assume the source domain produces independent data transitions at an average rate $f_s$, the destination domain samples at clock rate $f_d$, and the data-sampling timing between domains is independent. Suppose each additional FF stage in the synchronizer provides an additional available resolution time of $T_{\\text{res}}$ before the next FF samples the potentially metastable output.\n\nStarting only from the definitions above, and from the assumption that the expected number of data transitions falling within the aperture per sampling edge is $f_s T_0$ under the small-window approximation, derive an analytical expression for the mean time between failures (MTBF) of an $N$-stage synchronizer chain in terms of $f_s$, $f_d$, $T_0$, $\\tau$, $T_{\\text{res}}$, and $N$.\n\nEvaluate this MTBF formula for $N=2$ and $N=3$ using the parameters $\\tau = 25\\ \\text{ps}$, $T_0 = 1.2\\ \\text{ns}$, $f_s = 500\\ \\text{MHz}$, $f_d = 1\\ \\text{GHz}$, and $T_{\\text{res}} = 150\\ \\text{ps}$, and express the numerical MTBF values in seconds. Finally, report as your single final answer the ratio $R$ of the $3$-stage MTBF to the $2$-stage MTBF. Round the intermediate MTBF values to $3$ significant figures (in seconds), and round the final ratio $R$ to $4$ significant figures. The final reported ratio is dimensionless and must be given without any units.",
            "solution": "The problem asks for the derivation of the mean time between failures (MTBF) for an $N$-stage flip-flop synchronizer, its evaluation for specific parameters, and the ratio of MTBFs for a $3$-stage versus a $2$-stage synchronizer. The solution will proceed by first establishing the general analytical formula for MTBF based on the provided definitions, and then substituting the given numerical values.\n\n### Step 1: Derivation of the MTBF Formula\n\nThe MTBF is the reciprocal of the failure rate, $R_{\\text{fail}}$. A failure in the synchronizer chain occurs when two conditions are met:\n1.  The first flip-flop (FF) in the chain samples the asynchronous input data during its aperture window, causing it to enter a metastable state.\n2.  This metastable state does not resolve to a stable logic level within the total time provided by the synchronizer chain.\n\nLet's analyze the rate of each event.\n\nThe rate at which the first FF enters a metastable state, $R_{\\text{meta}}$, is the product of the rate of sampling events at the destination and the probability of capturing a data transition within the aperture window at each sampling event. The destination domain samples at a clock rate of $f_d$. The problem provides the assumption that \"the expected number of data transitions falling within the aperture per sampling edge is $f_s T_0$\". This quantity represents the probability of capture, $P_{\\text{capture}}$, under the small-window approximation ($f_s T_0 \\ll 1$).\nTherefore, the rate of entering metastability is:\n$$ R_{\\text{meta}} = f_d \\cdot P_{\\text{capture}} = f_d f_s T_0 $$\n\nNext, we must determine the probability that a metastable state leads to a system failure. The problem provides a model for the resolution time $t$ of a metastable state, where the probability of the resolution time exceeding a duration $x$ is given by $\\Pr\\{t > x\\} = \\exp(-x/\\tau)$. A failure occurs if the resolution time $t$ exceeds the total time available for resolution, which we denote as $T_{\\text{avail}}(N)$ for an $N$-stage synchronizer.\nThe probability of failure, given that metastability has occurred, is:\n$$ P_{\\text{fail|meta}} = \\Pr\\{t > T_{\\text{avail}}(N)\\} = \\exp\\left(-\\frac{T_{\\text{avail}}(N)}{\\tau}\\right) $$\n\nThe problem states that \"each additional FF stage in the synchronizer provides an additional available resolution time of $T_{\\text{res}}$\". This suggests a cumulative model for the total available resolution time. The baseline for a multi-stage synchronizer is a $2$-stage chain ($N=2$), which provides one full clock period of the destination clock, $T_d = 1/f_d$, for the first FF to resolve before its output is sampled by the second FF. Thus, we define the available time for $N=2$ as $T_{\\text{avail}}(2) = T_d = 1/f_d$.\nFor each additional stage (i.e., for $N > 2$), an additional time $T_{\\text{res}}$ is added.\nFor $N=3$, $T_{\\text{avail}}(3) = T_{\\text{avail}}(2) + T_{\\text{res}} = T_d + T_{\\text{res}}$.\nFor $N=4$, $T_{\\text{avail}}(4) = T_{\\text{avail}}(3) + T_{\\text{res}} = T_d + 2T_{\\text{res}}$.\nGeneralizing for $N \\ge 2$, the total available resolution time is:\n$$ T_{\\text{avail}}(N) = T_d + (N-2)T_{\\text{res}} = \\frac{1}{f_d} + (N-2)T_{\\text{res}} $$\n\nThe overall failure rate for an $N$-stage synchronizer, $R_{\\text{fail}}(N)$, is the product of the rate of entering metastability and the probability of that state not resolving in time.\n$$ R_{\\text{fail}}(N) = R_{\\text{meta}} \\cdot P_{\\text{fail|meta}} = (f_d f_s T_0) \\exp\\left(-\\frac{T_{\\text{avail}}(N)}{\\tau}\\right) $$\nSubstituting the expression for $T_{\\text{avail}}(N)$:\n$$ R_{\\text{fail}}(N) = (f_d f_s T_0) \\exp\\left(-\\frac{1/f_d + (N-2)T_{\\text{res}}}{\\tau}\\right) $$\n\nThe MTBF is the reciprocal of the failure rate:\n$$ MTBF(N) = \\frac{1}{R_{\\text{fail}}(N)} = \\frac{1}{f_d f_s T_0} \\exp\\left(\\frac{1/f_d + (N-2)T_{\\text{res}}}{\\tau}\\right) $$\nThis is the required analytical expression for the MTBF of an $N$-stage synchronizer for $N \\ge 2$.\n\n### Step 2: Numerical Evaluation for N=2 and N=3\n\nWe are given the following parameters:\n- $\\tau = 25\\ \\text{ps} = 25 \\times 10^{-12}\\ \\text{s}$\n- $T_0 = 1.2\\ \\text{ns} = 1.2 \\times 10^{-9}\\ \\text{s}$\n- $f_s = 500\\ \\text{MHz} = 5 \\times 10^{8}\\ \\text{Hz}$\n- $f_d = 1\\ \\text{GHz} = 1 \\times 10^{9}\\ \\text{Hz}$\n- $T_{\\text{res}} = 150\\ \\text{ps} = 150 \\times 10^{-12}\\ \\text{s}$\n\nFirst, let's calculate the destination clock period $T_d$ and the denominator term $f_d f_s T_0$.\n$$ T_d = \\frac{1}{f_d} = \\frac{1}{1 \\times 10^9\\ \\text{Hz}} = 1 \\times 10^{-9}\\ \\text{s} = 1\\ \\text{ns} $$\n$$ f_d f_s T_0 = (1 \\times 10^9\\ \\text{s}^{-1}) \\cdot (5 \\times 10^8\\ \\text{s}^{-1}) \\cdot (1.2 \\times 10^{-9}\\ \\text{s}) = 6 \\times 10^8\\ \\text{s}^{-1} $$\n\n**For a 2-stage synchronizer ($N=2$):**\nThe available resolution time is $T_{\\text{avail}}(2) = T_d = 1\\ \\text{ns}$.\nThe argument of the exponent is:\n$$ \\frac{T_{\\text{avail}}(2)}{\\tau} = \\frac{1 \\times 10^{-9}\\ \\text{s}}{25 \\times 10^{-12}\\ \\text{s}} = 40 $$\nThe MTBF is:\n$$ MTBF(2) = \\frac{\\exp(40)}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx \\frac{2.35385 \\times 10^{17}}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx 3.92309 \\times 10^8\\ \\text{s} $$\nRounding to $3$ significant figures, $MTBF(2) \\approx 3.92 \\times 10^8\\ \\text{s}$.\n\n**For a 3-stage synchronizer ($N=3$):**\nThe available resolution time is $T_{\\text{avail}}(3) = T_d + (3-2)T_{\\text{res}} = T_d + T_{\\text{res}}$.\n$$ T_{\\text{avail}}(3) = 1\\ \\text{ns} + 150\\ \\text{ps} = 1 \\times 10^{-9}\\ \\text{s} + 0.15 \\times 10^{-9}\\ \\text{s} = 1.15 \\times 10^{-9}\\ \\text{s} $$\nThe argument of the exponent is:\n$$ \\frac{T_{\\text{avail}}(3)}{\\tau} = \\frac{1.15 \\times 10^{-9}\\ \\text{s}}{25 \\times 10^{-12}\\ \\text{s}} = 46 $$\nThe MTBF is:\n$$ MTBF(3) = \\frac{\\exp(46)}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx \\frac{9.47450 \\times 10^{19}}{6 \\times 10^8\\ \\text{s}^{-1}} \\approx 1.57908 \\times 10^{11}\\ \\text{s} $$\nRounding to $3$ significant figures, $MTBF(3) \\approx 1.58 \\times 10^{11}\\ \\text{s}$.\n\n### Step 3: Calculation of the Ratio R\n\nThe final answer is the ratio $R = MTBF(3) / MTBF(2)$. Using the derived analytical expressions provides the most accurate result, cancelling common terms and avoiding potential floating-point errors from large intermediate numbers.\n$$ R = \\frac{MTBF(3)}{MTBF(2)} = \\frac{\\frac{1}{f_d f_s T_0} \\exp\\left(\\frac{T_d + T_{res}}{\\tau}\\right)}{\\frac{1}{f_d f_s T_0} \\exp\\left(\\frac{T_d}{\\tau}\\right)} = \\frac{\\exp\\left(\\frac{T_d}{\\tau} + \\frac{T_{res}}{\\tau}\\right)}{\\exp\\left(\\frac{T_d}{\\tau}\\right)} $$\n$$ R = \\exp\\left(\\left(\\frac{T_d}{\\tau} + \\frac{T_{res}}{\\tau}\\right) - \\frac{T_d}{\\tau}\\right) = \\exp\\left(\\frac{T_{res}}{\\tau}\\right) $$\nNow, we substitute the values for $T_{res}$ and $\\tau$:\n$$ \\frac{T_{res}}{\\tau} = \\frac{150 \\times 10^{-12}\\ \\text{s}}{25 \\times 10^{-12}\\ \\text{s}} = 6 $$\nTherefore, the ratio is:\n$$ R = \\exp(6) \\approx 403.428793... $$\nRounding the final ratio $R$ to $4$ significant figures gives $403.4$.",
            "answer": "$$\\boxed{403.4}$$"
        },
        {
            "introduction": "While a synchronizer can reliably transfer a single bit, most GALS communication involves multi-bit data buses, which introduces the challenge of data coherency. This exercise moves beyond the analysis of a single component to the architectural level of Clock Domain Crossing (CDC) design. You will analyze a common but critical design flaw and evaluate different corrective strategies, learning how to select a robust solution that guarantees both data integrity and reliability while respecting practical area constraints .",
            "id": "4274473",
            "problem": "A Globally Asynchronous, Locally Synchronous (GALS) system integrates a source clock domain $\\mathcal{S}$ running at frequency $f_{\\mathcal{S}}$ and a destination clock domain $\\mathcal{D}$ running at frequency $f_{\\mathcal{D}}$. A Clock Domain Crossing (CDC) report flags a violation: \"combinational logic on a crossing path.\" Investigation reveals that an $N$-bit status bus ($N = 16$) generated in $\\mathcal{S}$ feeds a combinational decoder in $\\mathcal{D}$ that ultimately drives a control signal used by sequential logic in $\\mathcal{D}$. The bus is updated sporadically, at a maximum event rate $f_{\\text{event}}$, and is currently sent directly without a registered interface in $\\mathcal{S}$.\n\nYou are asked to determine the root cause and select a redesign that both eliminates the CDC violation and satisfies reliability constraints for metastability. The destination flip-flops are characterized by a metastability time constant $\\tau$ and an empirical parameter $T_0$. The design constraint requires a Mean Time Between Failures (MTBF) of at least $10$ years for the crossing control signal. To keep area and complexity bounded, the total sequential element count added by the crossing solution must be less than $100$. The system parameters are:\n- $f_{\\mathcal{D}} = 500\\,\\text{MHz}$,\n- $f_{\\text{event}} = 5\\,\\text{MHz}$,\n- $\\tau = 20\\,\\text{ps}$,\n- $T_0 = 0.05\\,\\text{ns}$,\n- destination setup time $t_{\\text{su}} = 0.05\\,\\text{ns}$.\n\nAssume the following widely accepted facts for flip-flop sampling in asynchronous crossings: the probability that a metastable event persists longer than a resolution time decays exponentially with the resolution time, the destination clock period is $T_{\\mathcal{D}} = 1/f_{\\mathcal{D}}$, and a $k$-stage synchronizer provides approximately $(k-1)$ destination clock periods of resolution time prior to the final capture. Also assume the MTBF scales inversely with the product of the destination clock frequency and the data/event rate. No fan-in reconvergence of independently synchronized multi-bit signals is permitted.\n\nWhich option provides a correct and sufficient redesign and placement of synchronizers to eliminate the flagged \"combinational logic on a crossing path\" while meeting the MTBF and area constraints?\n\nA. Register the $N$-bit status bus in $\\mathcal{S}$ and generate a single-bit request strobe that is asserted when new bus data is available. Hold the bus stable until acknowledgement from $\\mathcal{D}$. Cross only the single-bit strobe into $\\mathcal{D}$ through a $2$-flip-flop synchronizer, edge-detect it in $\\mathcal{D}$, capture the bus into a destination register on the detected event, and place all decoding logic strictly after the destination register. Return a single-bit acknowledgement through a $2$-flip-flop synchronizer back to $\\mathcal{S}$. Do not use a First-In First-Out (FIFO). Justify that a $2$-stage synchronizer meets the MTBF requirement with the given parameters.\n\nB. Keep the combinational decoder in $\\mathcal{D}$, but add a $2$-flip-flop synchronizer to each of the $N$ data bits individually. Eliminate the request/acknowledge handshake for simplicity. Feed the synchronized multi-bit bus directly into the existing combinational decoder.\n\nC. Register the $N$-bit bus in $\\mathcal{S}$, cross a single-bit valid signal into $\\mathcal{D}$ with a single flip-flop synchronizer to minimize latency, and allow the combinational decoder in $\\mathcal{D}$ to gate downstream sequential logic based on the asynchronous bus values before any destination register capture.\n\nD. Eliminate the combinational hazard by introducing a dual-clock asynchronous First-In First-Out (FIFO) with Gray-coded pointers whose data width is $N$ and a minimum depth of $8$, and feed its output into the existing combinational decoder in $\\mathcal{D}$. Do not add any request/acknowledge handshake. Accept the added complexity and area, and argue the FIFO inherently resolves CDC issues and MTBF concerns for the control signal.",
            "solution": "The user wants me to act as a meticulous and exacting professor in the STEM fields to solve a problem about Globally Asynchronous, Locally Synchronous (GALS) systems.\n\n### Step 1: Extract Givens\n- System Type: Globally Asynchronous, Locally Synchronous (GALS)\n- Source Clock Domain: $\\mathcal{S}$, frequency $f_{\\mathcal{S}}$\n- Destination Clock Domain: $\\mathcal{D}$, frequency $f_{\\mathcal{D}} = 500\\,\\text{MHz}$\n- CDC Violation: \"combinational logic on a crossing path\"\n- Signal Path: An $N$-bit status bus ($N = 16$) from $\\mathcal{S}$ feeds a combinational decoder in $\\mathcal{D}$.\n- Bus Update Rate: Maximum event rate $f_{\\text{event}} = 5\\,\\text{MHz}$\n- Initial State: Bus is sent directly without a registered interface in $\\mathcal{S}$.\n- Design Goal: Eliminate the CDC violation and meet reliability constraints.\n- Reliability Constraint: Mean Time Between Failures (MTBF) $\\ge 10$ years for the crossing control signal.\n- Area Constraint: Total added sequential elements must be less than $100$.\n- Flip-Flop Metastability Parameters: Time constant $\\tau = 20\\,\\text{ps}$, empirical parameter $T_0 = 0.05\\,\\text{ns}$.\n- Destination Timing: Setup time $t_{\\text{su}} = 0.05\\,\\text{ns}$.\n- Provided Assumptions:\n    - MTBF scales inversely with the product of destination clock frequency ($f_{\\mathcal{D}}$) and data/event rate ($f_{\\text{event}}$).\n    - A $k$-stage synchronizer provides approximately $(k-1)$ destination clock periods of resolution time.\n    - No fan-in reconvergence of independently synchronized multi-bit signals is permitted.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically grounded, describing a standard and realistic scenario in digital integrated circuit design involving Clock Domain Crossing (CDC). The parameters provided ($f_{\\mathcal{D}}$, $f_{\\text{event}}$, $\\tau$, $T_0$) are physically plausible for modern semiconductor technologies. The problem is well-posed, providing a clear objective (redesign a faulty CDC path) with quantifiable constraints (MTBF, area). The language is objective and unambiguous. The provided assumptions, such as the structure of the MTBF formula and the prohibition of reconvergence paths, are standard best practices in the field. The problem is self-contained and does not contain internal contradictions. It requires both qualitative understanding of CDC architectures and quantitative analysis of metastability, making it a non-trivial engineering problem.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. The solution process will now proceed.\n\n### Solution Derivation\n\nThe root cause of the flagged violation, \"combinational logic on a crossing path,\" is that the $N$-bit bus from domain $\\mathcal{S}$ is being fed directly into a combinational decoder in domain $\\mathcal{D}$. Because the bus is asynchronous to $\\mathcal{D}$'s clock, its bits may be sampled at different times relative to their transitions, causing the decoder to see transient, invalid input values. This can lead to glitches and functional failures in the control signal generated by the decoder.\n\nA secondary, critical issue is ensuring data coherency for the $N=16$ bit bus. If each bit were synchronized independently, timing variations and metastability could cause the set of synchronized bits to represent a value that never existed in the source domain. The problem statement explicitly forbids this by disallowing \"fan-in reconvergence of independently synchronized multi-bit signals,\" which is precisely what would happen if independently synchronized bits were fed into a common decoder.\n\nA valid redesign must therefore satisfy three primary criteria:\n1.  **Eliminate the combinational path violation**: The asynchronous bus must first be captured into a register synchronous to the destination clock domain $\\mathcal{D}$ before being used by any combinational logic in $\\mathcal{D}$.\n2.  **Ensure multi-bit data coherency**: A mechanism must be used to guarantee that the entire $N$-bit bus is transferred as a single, valid word. Common solutions include handshake protocols or asynchronous FIFOs.\n3.  **Meet all constraints**: The solution must satisfy the MTBF requirement of $\\ge 10$ years and the area constraint of adding fewer than $100$ sequential elements.\n\nWe first analyze the MTBF constraint for a synchronizer on a single-bit signal. The standard formula for MTBF is:\n$$ \\text{MTBF} = \\frac{e^{t_{\\text{res}}/\\tau}}{T_0 \\cdot f_{\\text{clk}} \\cdot f_{\\text{data}}} $$\nBased on the problem statement, we use $f_{\\text{clk}} = f_{\\mathcal{D}}$ and $f_{\\text{data}} = f_{\\text{event}}$. The resolution time, $t_{\\text{res}}$, for a $k$-stage synchronizer is given as $t_{\\text{res}} = (k-1)T_{\\mathcal{D}}$, where $T_{\\mathcal{D}} = 1/f_{\\mathcal{D}}$.\n\nLet's calculate the MTBF for a $2$-stage ($k=2$) synchronizer:\n- $f_{\\mathcal{D}} = 500\\,\\text{MHz} = 5 \\times 10^8\\,\\text{Hz}$\n- $T_{\\mathcal{D}} = 1 / (5 \\times 10^8\\,\\text{Hz}) = 2 \\times 10^{-9}\\,\\text{s} = 2\\,\\text{ns}$\n- $f_{\\text{event}} = 5\\,\\text{MHz} = 5 \\times 10^6\\,\\text{Hz}$\n- $\\tau = 20\\,\\text{ps} = 20 \\times 10^{-12}\\,\\text{s}$\n- $T_0 = 0.05\\,\\text{ns} = 5 \\times 10^{-11}\\,\\text{s}$\n- For $k=2$, resolution time is $t_{\\text{res}} = (2-1)T_{\\mathcal{D}} = T_{\\mathcal{D}} = 2\\,\\text{ns}$.\n\nThe exponent term is $t_{\\text{res}}/\\tau = (2 \\times 10^{-9}\\,\\text{s}) / (20 \\times 10^{-12}\\,\\text{s}) = 100$.\nThe denominator is $T_0 \\cdot f_{\\mathcal{D}} \\cdot f_{\\text{event}} = (5 \\times 10^{-11}\\,\\text{s}) \\cdot (5 \\times 10^8\\,\\text{s}^{-1}) \\cdot (5 \\times 10^6\\,\\text{s}^{-1}) = 125 \\times 10^3\\,\\text{s}^{-1} = 1.25 \\times 10^5\\,\\text{s}^{-1}$.\n\nThe MTBF is:\n$$ \\text{MTBF} = \\frac{e^{100}}{1.25 \\times 10^5\\,\\text{s}^{-1}} \\approx \\frac{2.69 \\times 10^{43}}{1.25 \\times 10^5}\\,\\text{s} \\approx 2.15 \\times 10^{38}\\,\\text{s} $$\nThe required MTBF is $10$ years, which is approximately $10 \\times 3.15 \\times 10^7\\,\\text{s} = 3.15 \\times 10^8\\,\\text{s}$. Since $2.15 \\times 10^{38}\\,\\text{s} \\gg 3.15 \\times 10^8\\,\\text{s}$, a $2$-stage synchronizer is more than sufficient to meet the reliability constraint for a single-bit crossing.\n\n### Option-by-Option Analysis\n\n**A. Register the $N$-bit status bus in $\\mathcal{S}$ and generate a single-bit request strobe that is asserted when new bus data is available. Hold the bus stable until acknowledgement from $\\mathcal{D}$. Cross only the single-bit strobe into $\\mathcal{D}$ through a $2$-flip-flop synchronizer, edge-detect it in $\\mathcal{D}$, capture the bus into a destination register on the detected event, and place all decoding logic strictly after the destination register. Return a single-bit acknowledgement through a $2$-flip-flop synchronizer back to $\\mathcal{S}$. Do not use a First-In First-Out (FIFO). Justify that a $2$-stage synchronizer meets the MTBF requirement with the given parameters.**\n\nThis option describes a classic request-acknowledge (req/ack) handshake protocol.\n- **Fixes violation?** Yes. It explicitly states that the bus is captured into a destination register and the decoder is placed *after* this register.\n- **Ensures coherency?** Yes. The data bus from $\\mathcal{S}$ is held stable while the single-bit `request` signal crosses the domains. Domain $\\mathcal{D}$ only captures the bus after receiving the synchronized `request`, guaranteeing the bus data is stable and coherent.\n- **Meets MTBF?** Yes. It uses $2$-flip-flop synchronizers for the single-bit control signals (`request` and `acknowledge`). As calculated above, this provides an MTBF far exceeding the requirement.\n- **Meets Area Constraint?** Added sequential elements include:\n    - Register for the bus in $\\mathcal{S}$: $N=16$ flip-flops.\n    - `request` synchronizer: $2$ flip-flops.\n    - Capture register for the bus in $\\mathcal{D}$: $N=16$ flip-flops.\n    - `acknowledge` synchronizer: $2$ flip-flops.\n    - Control logic (e.g., edge detector, FSMs) might add a few more, e.g., $1-4$ flip-flops.\n    - Total: $16 + 2 + 16 + 2 + (\\text{control logic}) \\approx 36-40$ flip-flops. This is well below the limit of $100$.\n\n**Verdict: Correct.** This is a textbook, robust solution that satisfies all problem constraints.\n\n**B. Keep the combinational decoder in $\\mathcal{D}$, but add a $2$-flip-flop synchronizer to each of the $N$ data bits individually. Eliminate the request/acknowledge handshake for simplicity. Feed the synchronized multi-bit bus directly into the existing combinational decoder.**\n\nThis option synchronizes each bit of the bus independently.\n- **Fixes violation?** No. While synchronizers are added, feeding their outputs directly into a decoder constitutes a fan-in reconvergence path. This is explicitly disallowed by the problem statement and is a known source of functional bugs due to inter-bit skew introduced by the independent synchronizers.\n- **Ensures coherency?** No. This design is the canonical example of how *not* to handle multi-bit CDC, as it leads to data incoherency.\n- **Constraints?** The area ($16 \\times 2 = 32$ FFs) and individual-bit MTBF would be met, but the circuit is functionally incorrect.\n\n**Verdict: Incorrect.** This design is fundamentally flawed and violates a stated constraint of the problem's engineering context.\n\n**C. Register the $N$-bit bus in $\\mathcal{S}$, cross a single-bit valid signal into $\\mathcal{D}$ with a single flip-flop synchronizer to minimize latency, and allow the combinational decoder in $\\mathcal{D}$ to gate downstream sequential logic based on the asynchronous bus values before any destination register capture.**\n\nThis option proposes two major design errors.\n- **Fixes violation?** No. It explicitly allows the decoder to be driven by \"asynchronous bus values,\" which is the original problem.\n- **Ensures coherency?** No, for the same reason.\n- **Meets MTBF?** Absolutely not. A \"single flip-flop synchronizer\" ($k=1$) provides zero resolution time ($t_{\\text{res}}=0$). The MTBF would be:\n$$ \\text{MTBF} = \\frac{e^{0}}{1.25 \\times 10^5\\,\\text{s}^{-1}} = 8 \\times 10^{-6}\\,\\text{s} = 8\\,\\mu\\text{s} $$\nThis failure rate is catastrophic and violates the $10$-year MTBF requirement by many orders of magnitude.\n\n**Verdict: Incorrect.** This solution is unsafe, unreliable, and fails to correct the original design flaw.\n\n**D. Eliminate the combinational hazard by introducing a dual-clock asynchronous First-In First-Out (FIFO) with Gray-coded pointers whose data width is $N$ and a minimum depth of $8$, and feed its output into the existing combinational decoder in $\\mathcal{D}$. Do not add any request/acknowledge handshake. Accept the added complexity and area, and argue the FIFO inherently resolves CDC issues and MTBF concerns for the control signal.**\n\nThis option proposes using an asynchronous FIFO.\n- **Fixes violation?** Yes. The read-side output of an async FIFO is synchronous to the destination clock, so it can be safely fed to a decoder.\n- **Ensures coherency?** Yes. A FIFO is a standard, robust solution for transferring coherent multi-bit data across clock domains.\n- **Meets MTBF?** Yes, a properly designed FIFO with internal pointer synchronizers (typically $2$ or $3$ stages) will meet the MTBF requirement.\n- **Meets Area Constraint?** No. The area constraint is \"less than $100$ sequential elements.\"\n    - The data storage alone requires $N \\times \\text{depth} = 16 \\times 8 = 128$ flip-flops.\n    - This number by itself exceeds the $100$-element limit. The FIFO also requires additional flip-flops for its internal pointers and synchronizers.\n\n**Verdict: Incorrect.** While a functionally correct solution, it violates the explicit area constraint given in the problem statement.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "A theoretically sound GALS architecture must be correctly described to the Electronic Design Automation (EDA) tools that implement and verify the design. This final practice bridges the gap between conceptual design and physical implementation by focusing on Static Timing Analysis (STA). You will learn to formalize your design intent using Synopsys Design Constraints (SDC), specifying clock domains, asynchronous paths, and the unique timing behavior of synchronizer chains to ensure correct synthesis and verification .",
            "id": "4274542",
            "problem": "Consider a dual-clock First-In-First-Out (FIFO) interface designed in a Globally Asynchronous, Locally Synchronous (GALS) system. You are to formalize the Synopsys Design Constraints (SDC) for this interface by logically deriving, from first principles, which constraints are required and how many constraints of each type must be present. The interface connects a write clock domain and a read clock domain. Each domain may have internally generated clocks derived from the respective primary clock. The static timing analysis depends on correct declaration of clocks and appropriate exceptions across asynchronous crossings.\n\nFundamental base to use:\n- In purely synchronous paths, timing analysis uses the clock period $T$ to evaluate setup and hold constraints; the clock frequency is $f = 1/T$.\n- A clock domain is determined by a primary clock definition; a generated clock is a deterministic transform of a source clock (for example, divide-by operations).\n- Asynchronous paths between unrelated clocks are not timed; they must be excluded from analysis using well-defined constructs.\n- A synchronizer chain is a sequence of flip-flops on the destination clock domain used to mitigate metastability for signals crossing clock domains. In synchronous timing, default assumptions enforce single-cycle timing per stage; explicit multicycle exceptions adjust that assumption to permit multi-cycle behavior when appropriate.\n\nDefinitions and assumptions to apply:\n- Define a primary write clock $C_{\\mathrm{w}}$ with period $T_{\\mathrm{w}}$ (in nanoseconds) and a primary read clock $C_{\\mathrm{r}}$ with period $T_{\\mathrm{r}}$ (in nanoseconds).\n- For generated clocks, each has a name, a source primary clock, and an integer divide-by factor $d \\geq 2$ that creates a derived clock with period $d \\cdot T_{\\text{source}}$.\n- Asynchronous crossings between $C_{\\mathrm{w}}$ and $C_{\\mathrm{r}}$ must be excluded from timing by declaring the two domains as asynchronous. Two explicit false paths (one in each direction) must be considered between the write and read domains to model direction-specific exclusions.\n- A synchronizer chain has length $L \\geq 1$ stages in the destination domain, and width $N \\geq 1$ bits. For the purposes of this problem, assume that for each adjacent flip-flop pair in the chain, an explicit multicycle path exception is applied across all $N$ bits. If $L = 1$, there are no adjacent pairs, and no multicycle exceptions arise.\n- A multicycle exception is assumed to use a two-cycle setup relaxation and a one-cycle hold adjustment per adjacent pair, but you do not need to output the numerical values; only count how many multicycle exceptions are required across all chains and bits.\n\nYour task:\n- For each provided test case, model the required SDC directives logically and compute the following metrics:\n  1. The number of primary clocks that must be defined.\n  2. The number of generated clocks that must be defined.\n  3. The number of asynchronous clock group declarations required to cut timing between the write and read domains.\n  4. The number of explicit false path declarations between the two domains (directional).\n  5. The number of multicycle path exceptions required for all synchronizer chains and all bits, computed as the sum over chains of $(L - 1) \\cdot N$.\n\nTest suite:\n- Case $1$ (happy path):\n  - $T_{\\mathrm{w}} = 5$ nanoseconds, $T_{\\mathrm{r}} = 8$ nanoseconds.\n  - Generated clocks: $\\text{wr\\_div2}$ from $C_{\\mathrm{w}}$ with divide-by $d = 2$; $\\text{rd\\_div4}$ from $C_{\\mathrm{r}}$ with divide-by $d = 4$.\n  - Synchronizer chains:\n    - Write-to-read pointer synchronization in read domain: length $L = 2$, width $N = 5$ bits.\n    - Read-to-write pointer synchronization in write domain: length $L = 2$, width $N = 5$ bits.\n- Case $2$ (boundary with no generated clocks and trivial synchronizer):\n  - $T_{\\mathrm{w}} = 3$ nanoseconds, $T_{\\mathrm{r}} = 10$ nanoseconds.\n  - Generated clocks: none.\n  - Synchronizer chains:\n    - Write-to-read data-valid synchronization in read domain: length $L = 1$, width $N = 7$ bits.\n    - Read-to-write ready synchronization in write domain: length $L = 1$, width $N = 7$ bits.\n- Case $3$ (edge with deeper synchronizer and multiple generated clocks):\n  - $T_{\\mathrm{w}} = 4$ nanoseconds, $T_{\\mathrm{r}} = 6$ nanoseconds.\n  - Generated clocks: $\\text{wr\\_div2}$ from $C_{\\mathrm{w}}$ with divide-by $d = 2$; $\\text{wr\\_div4}$ from $C_{\\mathrm{w}}$ with divide-by $d = 4$.\n  - Synchronizer chains:\n    - Write-to-read pointer synchronization in read domain: length $L = 3$, width $N = 4$ bits.\n    - Read-to-write pointer synchronization in write domain: length $L = 3$, width $N = 4$ bits.\n\nProgram requirements:\n- Implement a program that, for each test case, computes the five metrics described above as integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test caseâ€™s metrics are represented as a list of five integers in the order given. For example, the output format must be like $[\\,[C_{1},G_{1},A_{1},F_{1},M_{1}],\\,[C_{2},G_{2},A_{2},F_{2},M_{2}],\\,[C_{3},G_{3},A_{3},F_{3},M_{3}]\\,]$.\n- There is no input. All data are hard-coded from the test suite above.\n- No physical unit conversion is required in the calculation of counts, but periods are given in nanoseconds for scientific completeness. Angles are not used.\n\nDeliverable:\n- A single, complete, standalone program that implements the above and prints the specified single-line output containing the list of lists of integers for the three test cases.",
            "solution": "The user-provided problem has been validated and is determined to be sound.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Clocks**:\n  - Primary write clock $C_{\\mathrm{w}}$ with period $T_{\\mathrm{w}}$ (nanoseconds).\n  - Primary read clock $C_{\\mathrm{r}}$ with period $T_{\\mathrm{r}}$ (nanoseconds).\n  - Generated clocks have a name, a source primary clock, and a divide-by factor $d \\geq 2$.\n\n- **Timing Exceptions**:\n  - Asynchronous crossings between $C_{\\mathrm{w}}$ and $C_{\\mathrm{r}}$ domains are excluded from timing.\n  - Two explicit false path declarations (one in each direction) are required between the write and read domains.\n  - Synchronizer chains have length $L \\geq 1$ and width $N \\geq 1$.\n  - An explicit multicycle path exception is applied for each adjacent flip-flop pair in a synchronizer chain.\n  - The total number of multicycle path exceptions is the sum over all chains of $(L - 1) \\cdot N$.\n\n- **Metrics to Compute**:\n  1. $C$: Number of primary clocks.\n  2. $G$: Number of generated clocks.\n  3. $A$: Number of asynchronous clock group declarations.\n  4. $F$: Number of explicit false path declarations.\n  5. $M$: Number of multicycle path exceptions.\n\n- **Test Cases**:\n  - **Case 1**:\n    - $T_{\\mathrm{w}} = 5$ ns, $T_{\\mathrm{r}} = 8$ ns.\n    - Generated clocks: $1$ from $C_{\\mathrm{w}}$ ($d=2$), $1$ from $C_{\\mathrm{r}}$ ($d=4$).\n    - Synchronizer chains: W-to-R ($L=2, N=5$), R-to-W ($L=2, N=5$).\n  - **Case 2**:\n    - $T_{\\mathrm{w}} = 3$ ns, $T_{\\mathrm{r}} = 10$ ns.\n    - Generated clocks: None.\n    - Synchronizer chains: W-to-R ($L=1, N=7$), R-to-W ($L=1, N=7$).\n  - **Case 3**:\n    - $T_{\\mathrm{w}} = 4$ ns, $T_{\\mathrm{r}} = 6$ ns.\n    - Generated clocks: $2$ from $C_{\\mathrm{w}}$ ($d=2, d=4$).\n    - Synchronizer chains: W-to-R ($L=3, N=4$), R-to-W ($L=3, N=4$).\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is **scientifically grounded**, as it is based on the established principles of Static Timing Analysis (STA) for digital integrated circuits, specifically regarding Clock Domain Crossing (CDC) verification in Globally Asynchronous, Locally Synchronous (GALS) systems. The concepts of primary clocks, generated clocks, asynchronous clock groups, false paths, and multicycle paths are standard constructs in Synopsys Design Constraints (SDC).\n\nThe problem is **well-posed**. It provides a clear and unambiguous set of rules for deriving five quantitative metrics from the parameters of each test case. The calculations are deterministic, ensuring a unique solution exists for each case.\n\nThe problem is **objective**. The language is precise and technical, requesting numerical counts based on explicit definitions, free of any subjective interpretation.\n\nNo flaws, inconsistencies, or ambiguities were detected. The problem is a valid, formal exercise in applying STA principles.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A step-by-step solution will be provided.\n\n**Solution Derivation**\n\nThe five required metrics are calculated for each test case by applying the principles and definitions provided.\n\n**1. Number of Primary Clocks ($C$)**\nThe problem defines a dual-clock FIFO with a write clock domain and a read clock domain. Each domain is defined by a primary clock. The problem states: \"Define a primary write clock $C_{\\mathrm{w}}$... and a primary read clock $C_{\\mathrm{r}}$\". This establishes two fundamental, independent clock sources for the system. Therefore, the number of primary clocks to be defined is always $2$.\n$C = 2$ for all test cases.\n\n**2. Number of Generated Clocks ($G$)**\nA generated clock is derived from a primary clock. The number of generated clocks is determined by counting the definitions provided in each test case.\n- **Case 1**: Two generated clocks are specified: `wr_div2` from $C_{\\mathrm{w}}$ and `rd_div4` from $C_{\\mathrm{r}}$. Thus, $G_1=2$.\n- **Case 2**: Zero generated clocks are specified. Thus, $G_2=0$.\n- **Case 3**: Two generated clocks are specified: `wr_div2` and `wr_div4`, both from $C_{\\mathrm{w}}$. Thus, $G_3=2$.\n\n**3. Number of Asynchronous Clock Group Declarations ($A$)**\nThe problem requires declaring the write and read clock domains as asynchronous to prevent STA tools from analyzing paths between them. A single `set_clock_groups -asynchronous` directive is the standard and efficient method to achieve this. One group would contain $C_{\\mathrm{w}}$ and all clocks generated from it, and the second group would contain $C_{\\mathrm{r}}$ and all clocks generated from it. Since there are only two fundamental asynchronous domains (write and read), one such declaration is necessary and sufficient.\n$A = 1$ for all test cases.\n\n**4. Number of Explicit False Path Declarations ($F$)**\nThe problem statement gives a direct and unconditional instruction: \"Two explicit false paths (one in each direction) must be considered between the write and read domains\". This is a specific requirement of the problem formalization, regardless of whether `set_clock_groups` is also used. These two paths correspond to the crossing from the write domain to the read domain and the crossing from the read domain to the write domain.\n$F = 2$ for all test cases.\n\n**5. Number of Multicycle Path Exceptions ($M$)**\nThe number of multicycle path exceptions is explicitly defined by the formula $\\sum (L - 1) \\cdot N$, summed over all synchronizer chains. A synchronizer of length $L$ has $L-1$ adjacent flip-flop stages. For each of these stages, exceptions are required for all $N$ bits of the synchronized bus.\n- **Case 1**:\n  - W-to-R chain: $L=2, N=5$. Exceptions = $(2-1) \\cdot 5 = 1 \\cdot 5 = 5$.\n  - R-to-W chain: $L=2, N=5$. Exceptions = $(2-1) \\cdot 5 = 1 \\cdot 5 = 5$.\n  - Total $M_1 = 5 + 5 = 10$.\n- **Case 2**:\n  - W-to-R chain: $L=1, N=7$. Exceptions = $(1-1) \\cdot 7 = 0 \\cdot 7 = 0$.\n  - R-to-W chain: $L=1, N=7$. Exceptions = $(1-1) \\cdot 7 = 0 \\cdot 7 = 0$.\n  - Total $M_2 = 0 + 0 = 0$. This aligns with the rule that for $L=1$, no exceptions are needed.\n- **Case 3**:\n  - W-to-R chain: $L=3, N=4$. Exceptions = $(3-1) \\cdot 4 = 2 \\cdot 4 = 8$.\n  - R-to-W chain: $L=3, N=4$. Exceptions = $(3-1) \\cdot 4 = 2 \\cdot 4 = 8$.\n  - Total $M_3 = 8 + 8 = 16$.\n\n**Summary of Results**\n\n- **Case 1**: $[C_1, G_1, A_1, F_1, M_1] = [2, 2, 1, 2, 10]$\n- **Case 2**: $[C_2, G_2, A_2, F_2, M_2] = [2, 0, 1, 2, 0]$\n- **Case 3**: $[C_3, G_3, A_3, F_3, M_3] = [2, 2, 1, 2, 16]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this problem.\n\ndef solve():\n    \"\"\"\n    Computes the SDC constraint metrics for the given test cases.\n    \"\"\"\n    \n    # Define the test cases based on the problem statement.\n    # Each case is a dictionary containing its specific parameters.\n    test_cases = [\n        {\n            # Case 1 (happy path)\n            \"generated_clocks\": [\n                {\"source\": \"Cw\", \"div\": 2},\n                {\"source\": \"Cr\", \"div\": 4}\n            ],\n            \"synchronizers\": [\n                {\"L\": 2, \"N\": 5},  # Write-to-read pointer\n                {\"L\": 2, \"N\": 5}   # Read-to-write pointer\n            ]\n        },\n        {\n            # Case 2 (boundary with no generated clocks and trivial synchronizer)\n            \"generated_clocks\": [],\n            \"synchronizers\": [\n                {\"L\": 1, \"N\": 7},  # Write-to-read data-valid\n                {\"L\": 1, \"N\": 7}   # Read-to-write ready\n            ]\n        },\n        {\n            # Case 3 (edge with deeper synchronizer and multiple generated clocks)\n            \"generated_clocks\": [\n                {\"source\": \"Cw\", \"div\": 2},\n                {\"source\": \"Cw\", \"div\": 4}\n            ],\n            \"synchronizers\": [\n                {\"L\": 3, \"N\": 4},  # Write-to-read pointer\n                {\"L\": 3, \"N\": 4}   # Read-to-write pointer\n            ]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # 1. Number of primary clocks (C)\n        # The system is a dual-clock FIFO, with a primary write clock (Cw)\n        # and a primary read clock (Cr) by definition.\n        num_primary_clocks = 2\n\n        # 2. Number of generated clocks (G)\n        # This is a direct count of the generated clocks defined for the case.\n        num_generated_clocks = len(case[\"generated_clocks\"])\n\n        # 3. Number of asynchronous clock group declarations (A)\n        # A single declaration is sufficient to define the two groups\n        # (write domain clocks and read domain clocks) as asynchronous.\n        num_async_groups = 1\n\n        # 4. Number of explicit false path declarations (F)\n        # The problem explicitly requires two directional false path declarations.\n        num_false_paths = 2\n\n        # 5. Number of multicycle path exceptions (M)\n        # Calculated using the formula (L - 1) * N for each synchronizer chain.\n        num_multicycle_exceptions = 0\n        for sync in case[\"synchronizers\"]:\n            L = sync[\"L\"]\n            N = sync[\"N\"]\n            # A synchronizer of length L has (L-1) adjacent stages.\n            # No exceptions if L=1.\n            if L > 1:\n                num_multicycle_exceptions += (L - 1) * N\n        \n        # Collect the five metrics for the current case.\n        case_results = [\n            num_primary_clocks,\n            num_generated_clocks,\n            num_async_groups,\n            num_false_paths,\n            num_multicycle_exceptions\n        ]\n        results.append(case_results)\n\n    # Format the final output as a single string according to the specification.\n    # Example: [[C1,G1,A1,F1,M1],[C2,G2,A2,F2,M2],[C3,G3,A3,F3,M3]]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}