{
    "hands_on_practices": [
        {
            "introduction": "A foundational decision in memory controller design is the page policy, which dictates whether a DRAM row is kept open after an access. This exercise allows you to analytically compare the performance of open-page and close-page policies by calculating the average access latency for a workload with a specific locality pattern. By working through this problem, you'll gain a quantitative understanding of the fundamental trade-off between exploiting row-buffer hits and preparing for random accesses .",
            "id": "4255802",
            "problem": "A high-performance memory controller for Dynamic Random-Access Memory (DRAM) must decide between an open-page policy and a close-page policy. In an open-page policy, the controller leaves the most recently accessed row open, so subsequent accesses to the same row can be served as row-buffer hits. In a close-page policy, the controller proactively precharges after each access, so the row is closed and each subsequent access requires full activation and column access. Consider a single-bank DRAM channel with negligible queuing effects and no write-to-read turnarounds. The per-access service latency is measured in cycles from the time an access is issued by the controller to the time data is returned.\n\nAssume the following timing parameters: the row-buffer hit latency is $t_{\\mathrm{hit}}=10$ cycles, and the row-buffer miss latency is defined as $t_{\\mathrm{miss}}=t_{\\mathrm{RCD}}+t_{\\mathrm{CAS}}+t_{\\mathrm{RP}}$ with $t_{\\mathrm{CAS}}=12$, $t_{\\mathrm{RCD}}=14$, and $t_{\\mathrm{RP}}=14$. The workload exhibits locality such that the probability of a row-buffer hit under an open-page policy is $0.7$ (sequential accesses within the currently open row), and the remaining $0.3$ are random accesses that map to other rows and thus are treated as row-buffer misses. Under a close-page policy, assume that each access is closed immediately after service, so every access is a row-buffer miss.\n\nStarting from the definitions of row-buffer hit and row-buffer miss latencies and the expected value of latency, derive the average per-access latency for both policies. Express the final answers in cycles. Report your answer as a row matrix $\\big[$open-page average latency, close-page average latency$\\big]$. No rounding is required.",
            "solution": "The objective is to compute the average per-access latency under two memory controller page policies using fundamental definitions. For a DRAM access, a row-buffer hit occurs when the target address lies in the currently activated row, while a row-buffer miss occurs when the target address lies in a different row, requiring precharge, activate, and column access phases. The row-buffer hit latency is given to be $t_{\\mathrm{hit}}=10$ cycles. The row-buffer miss latency is defined by the core DRAM timing parameters as\n$$\nt_{\\mathrm{miss}} = t_{\\mathrm{RCD}} + t_{\\mathrm{CAS}} + t_{\\mathrm{RP}}.\n$$\nWith $t_{\\mathrm{CAS}}=12$, $t_{\\mathrm{RCD}}=14$, and $t_{\\mathrm{RP}}=14$, we have\n$$\nt_{\\mathrm{miss}} = 14 + 12 + 14 = 40 \\text{ cycles}.\n$$\nTo compute the average latency, use the expected value definition. Let $L$ denote the random variable representing the latency of an access, and let $p_{\\mathrm{hit}}$ be the probability of a row-buffer hit. Then the expected latency under an open-page policy is\n$$\n\\mathbb{E}[L_{\\mathrm{open}}] = p_{\\mathrm{hit}} \\cdot t_{\\mathrm{hit}} + (1 - p_{\\mathrm{hit}}) \\cdot t_{\\mathrm{miss}}.\n$$\nThe workload specifies $p_{\\mathrm{hit}}=0.7$ (sequential accesses within the open row) and $1-p_{\\mathrm{hit}}=0.3$ (random accesses mapped to other rows, treated as misses). Substituting the given values yields\n$$\n\\mathbb{E}[L_{\\mathrm{open}}] = 0.7 \\cdot 10 + 0.3 \\cdot 40 = 7 + 12 = 19 \\text{ cycles}.\n$$\nUnder a close-page policy, by assumption, the controller closes the row after each access, eliminating row-buffer hits. Therefore, every access is a row-buffer miss, and the expected latency is simply\n$$\n\\mathbb{E}[L_{\\mathrm{close}}] = 1.0 \\cdot t_{\\mathrm{miss}} = 40 \\text{ cycles}.\n$$\nThus, the average per-access latencies are $19$ cycles for the open-page policy and $40$ cycles for the close-page policy. The requested row matrix in the order $\\big[$open-page average latency, close-page average latency$\\big]$ is\n$$\n\\begin{pmatrix}\n19 & 40\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}19 & 40\\end{pmatrix}}$$"
        },
        {
            "introduction": "While simple page policies provide a baseline, advanced controllers employ dynamic scheduling algorithms to reorder requests and maximize performance. This practice challenges you to simulate the First-Ready, First-Come, First-Served (FR-FCFS) policy, a common algorithm that prioritizes row-buffer hits. By manually tracing a request stream, you will see firsthand how a scheduler's decisions impact row-buffer hit rates and overall throughput .",
            "id": "4255781",
            "problem": "A memory controller schedules a mixed read/write stream targeting a single-rank Double Data Rate Synchronous Dynamic Random-Access Memory (DDR SDRAM) device with $B=4$ banks, indexed by $b \\in \\{0,1,2,3\\}$. Each bank has a single row buffer that holds the most recently activated row. The initial state at time $t=0$ is that all banks are precharged (no open row). The shared command/address bus allows at most one command to be issued per cycle. The following timing applies to each bank:\n- A precharge takes $t_{RP}=2$ cycles and closes the currently open row.\n- An activation takes $t_{RCD}=2$ cycles and opens the specified row.\n- A column access command (READ or WRITE) takes $1$ cycle; after the column command, the row remains open.\n\nA memory request is characterized by $(t_{i}, \\text{op}_{i}, b_{i}, r_{i})$ where $t_{i}$ is the arrival time in cycles, $\\text{op}_{i} \\in \\{\\text{READ}, \\text{WRITE}\\}$, $b_{i}$ is the bank index, and $r_{i}$ is the row index. The request stream is:\n- $i=1$: $(t_{1}=0, \\text{READ}, b_{1}=0, r_{1}=10)$\n- $i=2$: $(t_{2}=1, \\text{WRITE}, b_{2}=1, r_{2}=7)$\n- $i=3$: $(t_{3}=2, \\text{READ}, b_{3}=0, r_{3}=10)$\n- $i=4$: $(t_{4}=3, \\text{READ}, b_{4}=2, r_{4}=3)$\n- $i=5$: $(t_{5}=4, \\text{WRITE}, b_{5}=0, r_{5}=12)$\n- $i=6$: $(t_{6}=5, \\text{READ}, b_{6}=1, r_{6}=7)$\n- $i=7$: $(t_{7}=6, \\text{READ}, b_{7}=2, r_{7}=3)$\n- $i=8$: $(t_{8}=7, \\text{WRITE}, b_{8}=3, r_{8}=1)$\n- $i=9$: $(t_{9}=8, \\text{READ}, b_{9}=1, r_{9}=9)$\n- $i=10$: $(t_{10}=9, \\text{READ}, b_{10}=3, r_{10}=1)$\n\nThe controller uses First-Ready, First-Come, First-Served (FR-FCFS): at each cycle when the bus becomes free, consider all requests with $t_{i}$ not exceeding the current time. Requests whose target row equals the currently open row in their bank are considered “first-ready” (row-buffer hits). Among first-ready requests, select the earliest-arrival request; if none exist, select the earliest-arrival request among all available. Once a request is selected, issue the minimal sequence of commands back-to-back to serve it: if the bank is closed, issue an activation then the column command; if the bank has a different row open, issue a precharge, then an activation, then the column command; if the desired row is already open, issue only the column command. Do not interleave commands of different requests.\n\nApply FR-FCFS to this stream to generate the issue order of requests and identify, for each request at the time its column command is issued, whether it is a row-buffer hit or a miss. Compute the achieved row-buffer hit rate, defined as the ratio of the number of requests that are row-buffer hits to the total number of requests. Express the final hit rate as a decimal and round your answer to four significant figures. No unit is required for the hit rate.",
            "solution": "The solution is derived by simulating the memory controller's operation cycle by cycle, applying the FR-FCFS scheduling policy. We will track the state of each bank (precharged or active with a specific open row) and the bus availability.\n\nA request can be a row-buffer hit or miss. The command sequence and time depend on the state of the target bank:\n1.  **Row-Buffer Hit**: The correct row is already open. The sequence is one column command (READ/WRITE). Total time: $1$ cycle.\n2.  **Row-Buffer Miss (Empty Bank)**: The bank is precharged. The sequence is ACTIVATE, then column command. Total time: $t_{RCD} + 1 = 2+1=3$ cycles.\n3.  **Row-Buffer Miss (Conflict)**: A different row is open in the bank. The sequence is PRECHARGE, ACTIVATE, then column command. Total time: $t_{RP} + t_{RCD} + 1 = 2+2+1=5$ cycles.\n\nLet's trace the execution. `t` is the current cycle. `Bank State` is represented as `(Status, Open Row)` for each bank $\\{0, 1, 2, 3\\}$. `H` is the hit count, `M` is the miss count.\n\n**Initial State (t=0):**\n- Bus: Free.\n- Bank States: B0(PRE, null), B1(PRE, null), B2(PRE, null), B3(PRE, null).\n- `H=0`, `M=0`.\n\n**Scheduling Event 1 (t=0):**\n- Bus is free. Available requests (arrived at or before $t=0$): Req 1 $(t_1=0, \\text{R}, \\text{B0}, r_{10})$.\n- Req 1 targets Bank 0, which is precharged. It is a miss. No \"ready\" requests exist.\n- **Select Req 1**. It is a miss (empty bank). Time cost = $t_{RCD} + 1 = 3$ cycles.\n- Commands: `t=0: ACT(B0, r10)`, `t=1: (ACT)`, `t=2: READ(B0, r10)`.\n- Bus is busy until $t=0+3=3$.\n- `M=1`. At $t=3$, Bank 0 becomes `(ACTIVE, r10)`.\n\n**Scheduling Event 2 (t=3):**\n- Bus is free. Available requests: Req 2 $(t_2=1)$, Req 3 $(t_3=2)$, Req 4 $(t_4=3)$.\n- Check for ready (hit) requests:\n    - Req 2 (B1, r7): Bank 1 is PRECHARGED. Miss.\n    - Req 3 (B0, r10): Bank 0 is ACTIVE with row 10. **Hit**.\n    - Req 4 (B2, r3): Bank 2 is PRECHARGED. Miss.\n- The \"ready\" set is {Req 3}.\n- **Select Req 3**. It is a hit. Time cost = $1$ cycle.\n- Command: `t=3: READ(B0, r10)`.\n- Bus is busy until $t=3+1=4$.\n- `H=1`, `M=1`. Bank 0 remains `(ACTIVE, r10)`.\n\n**Scheduling Event 3 (t=4):**\n- Bus is free. Available requests: Req 2 $(t_2=1)$, Req 4 $(t_4=3)$, Req 5 $(t_5=4)$.\n- Check for hits:\n    - Req 2 (B1, r7): Bank 1 is PRECHARGED. Miss.\n    - Req 4 (B2, r3): Bank 2 is PRECHARGED. Miss.\n    - Req 5 (B0, r12): Bank 0 has row 10 open. Miss (conflict).\n- No ready requests. Select from all available based on arrival time (FCFS): Req 2 is earliest.\n- **Select Req 2**. It is a miss (empty bank). Time cost = $3$ cycles.\n- Commands: `t=4: ACT(B1, r7)`, `t=5: (ACT)`, `t=6: WRITE(B1, r7)`.\n- Bus is busy until $t=4+3=7$.\n- `H=1`, `M=2`. At $t=7$, Bank 1 becomes `(ACTIVE, r7)`.\n\n**Scheduling Event 4 (t=7):**\n- Bus is free. Available requests: Req 4 $(t_4=3)$, Req 5 $(t_5=4)$, Req 6 $(t_6=5)$, Req 7 $(t_7=6)$, Req 8 $(t_8=7)$.\n- Check for hits:\n    - Req 6 (B1, r7): Bank 1 is ACTIVE with row 7. **Hit**.\n- The \"ready\" set is {Req 6}.\n- **Select Req 6**. It is a hit. Time cost = $1$ cycle.\n- Command: `t=7: READ(B1, r7)`.\n- Bus is busy until $t=7+1=8$.\n- `H=2`, `M=2`. Bank 1 remains `(ACTIVE, r7)`.\n\n**Scheduling Event 5 (t=8):**\n- Bus is free. Available requests: Req 4, 5, 7, 8, 9.\n- Check for hits: All available requests are misses.\n- No ready requests. Select earliest arrival: Req 4 $(t_4=3)$.\n- **Select Req 4**. It is a miss (empty bank). Time cost = $3$ cycles.\n- Commands: `t=8: ACT(B2, r3)`, `t=9: (ACT)`, `t=10: READ(B2, r3)`.\n- Bus is busy until $t=8+3=11$.\n- `H=2`, `M=3`. At $t=11$, Bank 2 becomes `(ACTIVE, r3)`.\n\n**Scheduling Event 6 (t=11):**\n- Bus is free. Available requests: Req 5, 7, 8, 9, 10.\n- Check for hits:\n    - Req 7 (B2, r3): Bank 2 is ACTIVE with row 3. **Hit**.\n- The \"ready\" set is {Req 7}.\n- **Select Req 7**. It is a hit. Time cost = $1$ cycle.\n- Command: `t=11: READ(B2, r3)`.\n- Bus is busy until $t=11+1=12$.\n- `H=3`, `M=3`. Bank 2 remains `(ACTIVE, r3)`.\n\n**Scheduling Event 7 (t=12):**\n- Bus is free. Available requests: Req 5, 8, 9, 10.\n- Check for hits: All are misses.\n- No ready requests. Select earliest arrival: Req 5 $(t_5=4)$.\n- **Select Req 5**. It is a miss (conflict). Bank 0 has row 10 open, request needs 12. Time cost = $t_{RP} + t_{RCD} + 1 = 5$ cycles.\n- Commands: `t=12: PRE(B0)`, `t=13: (PRE)`, `t=14: ACT(B0, r12)`, `t=15: (ACT)`, `t=16: WRITE(B0, r12)`.\n- Bus is busy until $t=12+5=17$.\n- `H=3`, `M=4`. At $t=17$, Bank 0 becomes `(ACTIVE, r12)`.\n\n**Scheduling Event 8 (t=17):**\n- Bus is free. Available requests: Req 8, 9, 10.\n- Check for hits: All are misses.\n- No ready requests. Select earliest arrival: Req 8 $(t_8=7)$.\n- **Select Req 8**. It is a miss (empty bank). Time cost = $3$ cycles.\n- Commands: `t=17: ACT(B3, r1)`, `t=18: (ACT)`, `t=19: WRITE(B3, r1)`.\n- Bus is busy until $t=17+3=20$.\n- `H=3`, `M=5`. At $t=20$, Bank 3 becomes `(ACTIVE, r1)`.\n\n**Scheduling Event 9 (t=20):**\n- Bus is free. Available requests: Req 9, 10.\n- Check for hits:\n    - Req 10 (B3, r1): Bank 3 is ACTIVE with row 1. **Hit**.\n- The \"ready\" set is {Req 10}.\n- **Select Req 10**. It is a hit. Time cost = $1$ cycle.\n- Command: `t=20: READ(B3, r1)`.\n- Bus is busy until $t=20+1=21$.\n- `H=4`, `M=5`. Bank 3 remains `(ACTIVE, r1)`.\n\n**Scheduling Event 10 (t=21):**\n- Bus is free. Available requests: Req 9.\n- Check for hits: Req 9 (B1, r9) is a miss (conflict with open row 7).\n- No ready requests. Select from available: Req 9.\n- **Select Req 9**. It is a miss (conflict). Time cost = $5$ cycles.\n- Commands: `t=21: PRE(B1)`, `t=22: (PRE)`, `t=23: ACT(B1, r9)`, `t=24: (ACT)`, `t=25: READ(B1, r9)`.\n- Bus is busy until $t=21+5=26$.\n- `H=4`, `M=6`. At $t=26$, Bank 1 becomes `(ACTIVE, r9)`.\n\n**Summary:**\n- The sequence of serviced requests is: 1, 3, 2, 6, 4, 7, 5, 8, 10, 9.\n- The following requests were row-buffer hits: 3, 6, 7, 10.\n- The following requests were row-buffer misses: 1, 2, 4, 5, 8, 9.\n\nTotal number of requests: $N_{total} = 10$.\nNumber of row-buffer hits: $N_{hits} = 4$.\n\nThe row-buffer hit rate is calculated as the ratio of the number of hits to the total number of requests.\n$$ \\text{Hit Rate} = \\frac{N_{hits}}{N_{total}} = \\frac{4}{10} = 0.4 $$\nThe problem requires the answer as a decimal rounded to four significant figures.\n$$ \\text{Hit Rate} = 0.4000 $$",
            "answer": "$$\\boxed{0.4000}$$"
        },
        {
            "introduction": "Optimal memory performance is achieved not just by smart request scheduling, but also by meticulously orchestrating the command sequence on the bus. This exercise delves into the intricate timing constraints of modern DRAM, such as the Four Activate Window ($t_{FAW}$) and Row-to-Row Delay ($t_{RRD}$). Your task is to construct a valid command schedule that minimizes idle cycles, providing insight into the fine-grained optimizations required to push DRAM bandwidth to its limits .",
            "id": "4255759",
            "problem": "A memory controller issues commands to a Double Data Rate synchronous Dynamic Random-Access Memory (DDR SDRAM) device over a shared command/address bus that can carry at most one command per clock cycle. Consider four banks, each targeting a different row. The controller must issue four ACTIVATE (ACT) commands to different banks and two READ commands, one to each of the first two banks that were activated. The timeline starts at cycle $0$ with all banks precharged and the bus idle. Only the following timing constraints apply; ignore bank-group constraints, data-bus burst length, bus turnaround, and any timing not listed below.\n\n- Row-to-Column Delay ($t_{RCD}$): after an ACT to a bank, the earliest READ to that bank is $t_{RCD}$ cycles later.\n- Row Precharge ($t_{RP}$): minimum time to precharge a bank after a PRECHARGE; no PRECHARGE is required in this task, but the parameter is provided for completeness.\n- Row Active Time ($t_{RAS}$): minimum time a row must remain active before precharge; again, no PRECHARGE is required in this task, but the parameter is provided for completeness.\n- Row-to-Row Delay ($t_{RRD}$): minimum time between ACT commands to different banks.\n- Four Activate Window ($t_{FAW}$): in any rolling window of length $t_{FAW}$ cycles, no more than four ACT commands may be issued.\n- Column-to-Column Delay ($t_{CCD}$): minimum time between successive column commands (e.g., READ to READ), regardless of bank.\n\nYou are given $t_{RCD}=14$, $t_{RP}=14$, $t_{RAS}=34$, $t_{RRD}=6$, $t_{FAW}=30$, and $t_{CCD}=4$ (all in cycles). The two READs must target the rows activated by the first and second ACTs, respectively. Construct a valid command schedule that minimizes idle cycles on the command bus while respecting the above constraints.\n\nWhat is the earliest cycle index at which the second READ command can be issued under an optimal schedule that minimizes command-bus idle cycles up to that point? Express your answer in cycles as an integer (no rounding required).",
            "solution": "The objective is to find the earliest cycle at which the second of two required READ commands can be issued. The schedule must be optimal, meaning it minimizes idle cycles on the command bus up to the point of the final command issue, while respecting all specified timing constraints.\n\nFirst, we establish the sequence of commands to be scheduled. The problem requires issuing four ACTIVATE (ACT) commands to four different banks, followed by two READ commands. The READs must target the banks activated by the first and second ACT commands. Let us denote the banks as $B_0, B_1, B_2, B_3$. We will schedule the commands `ACT`$_0$, `ACT`$_1$, `ACT`$_2$, `ACT`$_3$ for these banks, respectively. The READ commands will therefore be `READ`$_0$ and `READ`$_1$. The timeline begins at cycle $0$.\n\nThe scheduling strategy will be a greedy one: at any given clock cycle, we will issue a command if the command bus is free and there is at least one command whose timing dependencies have been met. This strategy naturally fulfills the requirement of minimizing idle bus cycles.\n\nThe given timing parameters are:\n- Row-to-Column Delay: $t_{RCD} = 14$ cycles\n- Row-to-Row Delay: $t_{RRD} = 6$ cycles\n- Four Activate Window: $t_{FAW} = 30$ cycles\n- Column-to-Column Delay: $t_{CCD} = 4$ cycles\nThe parameters $t_{RP}=14$ and $t_{RAS}=34$ are not relevant as no PRECHARGE commands are issued in this task. The bus can accept at most one command per cycle.\n\nLet $C(cmd)$ denote the cycle index at which a command $cmd$ is issued.\n\n**Step 1: Schedule the ACTIVATE commands**\nThe four ACT commands must be issued to four different banks. The primary constraint governing their separation is the Row-to-Row Delay, $t_{RRD}$.\n1.  The first command, `ACT`$_0$, can be issued at the earliest possible time, which is cycle $0$.\n    $C(\\text{ACT}_0) = 0$.\n2.  The second command, `ACT`$_1$, must be issued at least $t_{RRD}$ cycles after `ACT`$_0$.\n    $C(\\text{ACT}_1) \\geq C(\\text{ACT}_0) + t_{RRD} = 0 + 6 = 6$.\n    To minimize idle time, we schedule `ACT`$_1$ at the earliest possible cycle: $C(\\text{ACT}_1) = 6$.\n3.  Similarly, `ACT`$_2$ must be issued at least $t_{RRD}$ cycles after `ACT`$_1$.\n    $C(\\text{ACT}_2) \\geq C(\\text{ACT}_1) + t_{RRD} = 6 + 6 = 12$.\n    We schedule it at $C(\\text{ACT}_2) = 12$.\n4.  Finally, `ACT`$_3$ must be issued at least $t_{RRD}$ cycles after `ACT`$_2$.\n    $C(\\text{ACT}_3) \\geq C(\\text{ACT}_2) + t_{RRD} = 12 + 6 = 18$.\n    We schedule it at $C(\\text{ACT}_3) = 18$.\n\nThis yields the following schedule for ACT commands:\n- `ACT`$_0$ at cycle $0$\n- `ACT`$_1$ at cycle $6$\n- `ACT`$_2$ at cycle $12$\n- `ACT`$_3$ at cycle $18$\n\nWe must verify this against the Four Activate Window constraint, $t_{FAW}$. The constraint states that in any rolling window of $t_{FAW}=30$ cycles, no more than four ACT commands may be issued. Our four ACTs are issued at cycles $0, 6, 12, 18$. The time elapsed between the first and the fourth ACT is $C(\\text{ACT}_3) - C(\\text{ACT}_0) = 18 - 0 = 18$ cycles. Since we only issue four ACT commands in total, any subsequent ACT command would need to respect the window established by the first four. For instance, a hypothetical fifth ACT, `ACT`$_4$, could not be issued before cycle $30$, since $C(\\text{ACT}_4) - C(\\text{ACT}_1)$ would need to be $\\ge t_{FAW}$. As we only have four ACTs, our schedule is valid with respect to $t_{FAW}$.\n\n**Step 2: Schedule the READ commands**\nWe need to schedule `READ`$_0$ (to bank $B_0$) and `READ`$_1$ (to bank $B_1$).\n\nFirst, let's determine the earliest readiness time for each READ command, based on the Row-to-Column Delay, $t_{RCD}$.\n-   `READ`$_0$ can be issued only after its corresponding bank has been activated and $t_{RCD}$ has elapsed.\n    $C(\\text{READ}_0) \\geq C(\\text{ACT}_0) + t_{RCD} = 0 + 14 = 14$.\n    So, `READ`$_0$ is ready at or after cycle $14$.\n-   `READ`$_1$ readiness is determined similarly.\n    $C(\\text{READ}_1) \\geq C(\\text{ACT}_1) + t_{RCD} = 6 + 14 = 20$.\n    So, `READ`$_1$ is ready at or after cycle $20$.\n\nNow, we must place these on the command bus, respecting their readiness times and bus availability.\n-   The earliest cycle at which we can issue `READ`$_0$ is cycle $14$. The command bus is available at cycle $14$ (the previous command was `ACT`$_2$ at cycle $12$). Thus, we schedule `READ`$_0$ at its earliest possible time to minimize idle cycles:\n    $C(\\text{READ}_0) = 14$.\n\n-   Next, we schedule `READ`$_1$. Its issue time is constrained by two factors:\n    1.  Its own readiness time based on $t_{RCD}$: $C(\\text{READ}_1) \\geq 20$.\n    2.  The Column-to-Column Delay, $t_{CCD}$, relative to the previously issued READ command (`READ`$_0$).\n        $C(\\text{READ}_1) \\geq C(\\text{READ}_0) + t_{CCD} = 14 + 4 = 18$.\n\n    To satisfy both constraints, the issue time for `READ`$_1$ must be greater than or equal to the maximum of these two lower bounds:\n    $C(\\text{READ}_1) \\geq \\max(20, 18) = 20$.\n\n    The earliest possible cycle to issue `READ`$_1$ is therefore $20$. We must check if the command bus is available at cycle $20$. The command schedule so far is:\n    - Cycle $0$: `ACT`$_0$\n    - Cycle $6$: `ACT`$_1$\n    - Cycle $12$: `ACT`$_2$\n    - Cycle $14$: `READ`$_0$\n    - Cycle $18$: `ACT`$_3$\n    The bus is indeed free at cycle $20$. Therefore, we can schedule `READ`$_1$ at this time.\n    $C(\\text{READ}_1) = 20$.\n\nThis constitutes a complete and valid schedule that adheres to a greedy, idle-minimizing strategy. The lower bound analysis for $C(\\text{READ}_1)$ demonstrates that no earlier time is possible. The final schedule is:\n- Cycle $0$: `ACT`$_0$\n- Cycle $6$: `ACT`$_1$\n- Cycle $12$: `ACT`$_2$\n- Cycle $14$: `READ`$_0$\n- Cycle $18$: `ACT`$_3$\n- Cycle $20$: `READ`$_1$\n\nThe question asks for the earliest cycle index at which the second READ command can be issued. Based on our optimal schedule, this is cycle $20$.",
            "answer": "$$\\boxed{20}$$"
        }
    ]
}