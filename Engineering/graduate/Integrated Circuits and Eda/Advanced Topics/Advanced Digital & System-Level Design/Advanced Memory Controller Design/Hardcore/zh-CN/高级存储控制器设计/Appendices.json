{
    "hands_on_practices": [
        {
            "introduction": "内存控制器最基本的决策之一是其页策略（page policy）。本练习通过计算具有已知局部性特征的工作负载的平均访问延迟，帮助您量化开放页策略（open-page policy）与关闭页策略（close-page policy）对性能的影响。理解这种基本的权衡是设计高效控制器的第一步。",
            "id": "4255802",
            "problem": "一个用于动态随机存取存储器 (DRAM) 的高性能内存控制器必须在开放页策略和关闭页策略之间做出选择。在开放页策略中，控制器保持最近访问的行处于打开状态，因此对同一行的后续访问可以作为行缓冲区命中来处理。在关闭页策略中，控制器在每次访问后主动进行预充电，因此行被关闭，每次后续访问都需要完整的激活和列访问。考虑一个具有可忽略排队效应且无写-读转换的单存储体 DRAM 通道。每次访问的服务延迟以时钟周期为单位进行测量，从控制器发出访问请求到数据返回为止。\n\n假设以下时序参数：行缓冲区命中延迟为 $t_{\\mathrm{hit}}=10$ 个时钟周期，行缓冲区未命中延迟定义为 $t_{\\mathrm{miss}}=t_{\\mathrm{RCD}}+t_{\\mathrm{CAS}}+t_{\\mathrm{RP}}$，其中 $t_{\\mathrm{CAS}}=12$，$t_{\\mathrm{RCD}}=14$，以及 $t_{\\mathrm{RP}}=14$。该工作负载表现出局部性，使得在开放页策略下，行缓冲区命中的概率为 $0.7$（对当前打开行内的顺序访问），而剩下的 $0.3$ 是映射到其他行的随机访问，因此被视为行缓冲区未命中。在关闭页策略下，假设每次访问在服务后立即关闭行，因此每次访问都是行缓冲区未命中。\n\n从行缓冲区命中和行缓冲区未命中延迟的定义以及延迟的期望值出发，推导两种策略下每次访问的平均延迟。最终答案以时钟周期为单位表示。将你的答案以行矩阵 $\\big[$开放页平均延迟, 关闭页平均延迟$\\big]$ 的形式报告。无需进行四舍五入。",
            "solution": "目标是使用基本定义来计算两种内存控制器页面策略下每次访问的平均延迟。对于一次 DRAM 访问，当目标地址位于当前激活的行中时，发生行缓冲区命中；而当目标地址位于不同的行中时，发生行缓冲区未命中，这需要预充电、激活和列访问等阶段。给定行缓冲区命中延迟为 $t_{\\mathrm{hit}}=10$ 个时钟周期。行缓冲区未命中延迟由核心 DRAM 时序参数定义为\n$$\nt_{\\mathrm{miss}} = t_{\\mathrm{RCD}} + t_{\\mathrm{CAS}} + t_{\\mathrm{RP}}.\n$$\n当 $t_{\\mathrm{CAS}}=12$，$t_{\\mathrm{RCD}}=14$，以及 $t_{\\mathrm{RP}}=14$ 时，我们得到\n$$\nt_{\\mathrm{miss}} = 14 + 12 + 14 = 40 \\text{ 个时钟周期}。\n$$\n为计算平均延迟，我们使用期望值的定义。设 $L$ 为表示一次访问延迟的随机变量，设 $p_{\\mathrm{hit}}$ 为行缓冲区命中的概率。那么，在开放页策略下的期望延迟为\n$$\n\\mathbb{E}[L_{\\mathrm{open}}] = p_{\\mathrm{hit}} \\cdot t_{\\mathrm{hit}} + (1 - p_{\\mathrm{hit}}) \\cdot t_{\\mathrm{miss}}.\n$$\n工作负载指定 $p_{\\mathrm{hit}}=0.7$（打开行内的顺序访问）和 $1-p_{\\mathrm{hit}}=0.3$（映射到其他行并被视为未命中的随机访问）。代入给定值可得\n$$\n\\mathbb{E}[L_{\\mathrm{open}}] = 0.7 \\cdot 10 + 0.3 \\cdot 40 = 7 + 12 = 19 \\text{ 个时钟周期}。\n$$\n在关闭页策略下，根据假设，控制器在每次访问后都会关闭行，从而消除了行缓冲区命中。因此，每次访问都是一次行缓冲区未命中，其期望延迟就是\n$$\n\\mathbb{E}[L_{\\mathrm{close}}] = 1.0 \\cdot t_{\\mathrm{miss}} = 40 \\text{ 个时钟周期}。\n$$\n因此，开放页策略的平均每次访问延迟为 $19$ 个时钟周期，关闭页策略的平均每次访问延迟为 $40$ 个时钟周期。按 $\\big[$开放页平均延迟, 关闭页平均延迟$\\big]$ 顺序排列的所求行矩阵为\n$$\n\\begin{pmatrix}\n19  40\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}19  40\\end{pmatrix}}$$"
        },
        {
            "introduction": "选定页策略后，控制器必须决定服务挂起内存请求的顺序。本练习模拟了流行的FR-FCFS（就绪优先，先到先服务）调度算法，该算法优先处理行缓冲（row-buffer）命中的请求。通过逐步执行该过程，您将具体地理解调度策略如何利用局部性来提高系统性能。",
            "id": "4255781",
            "problem": "一个内存控制器调度一个混合读/写流，该流的目标是一个单rank双倍数据速率同步动态随机存取存储器（DDR SDRAM）设备，该设备有 $B=4$ 个bank，索引为 $b \\in \\{0,1,2,3\\}$。每个bank有一个行缓冲区，用于存放最近被激活的行。在时间 $t=0$ 时的初始状态是所有bank都已预充电（没有打开的行）。共享的命令/地址总线每周期最多允许发出一个命令。以下时序适用于每个bank：\n- 预充电（precharge）需要 $t_{RP}=2$ 个周期，并关闭当前打开的行。\n- 激活（activation）需要 $t_{RCD}=2$ 个周期，并打开指定的行。\n- 列访问命令（READ或WRITE）需要 $1$ 个周期；在列命令之后，该行保持打开状态。\n\n一个内存请求由 $(t_{i}, \\text{op}_{i}, b_{i}, r_{i})$ 来表征，其中 $t_{i}$ 是以周期为单位的到达时间，$\\text{op}_{i} \\in \\{\\text{READ}, \\text{WRITE}\\}$，$b_{i}$ 是bank索引，$r_{i}$ 是行索引。请求流如下：\n- $i=1$: $(t_{1}=0, \\text{READ}, b_{1}=0, r_{1}=10)$\n- $i=2$: $(t_{2}=1, \\text{WRITE}, b_{2}=1, r_{2}=7)$\n- $i=3$: $(t_{3}=2, \\text{READ}, b_{3}=0, r_{3}=10)$\n- $i=4$: $(t_{4}=3, \\text{READ}, b_{4}=2, r_{4}=3)$\n- $i=5$: $(t_{5}=4, \\text{WRITE}, b_{5}=0, r_{5}=12)$\n- $i=6$: $(t_{6}=5, \\text{READ}, b_{6}=1, r_{6}=7)$\n- $i=7$: $(t_{7}=6, \\text{READ}, b_{7}=2, r_{7}=3)$\n- $i=8$: $(t_{8}=7, \\text{WRITE}, b_{8}=3, r_{8}=1)$\n- $i=9$: $(t_{9}=8, \\text{READ}, b_{9}=1, r_{9}=9)$\n- $i=10$: $(t_{10}=9, \\text{READ}, b_{10}=3, r_{10}=1)$\n\n控制器使用“就绪优先，先到先服务”（First-Ready, First-Come, First-Served, FR-FCFS）策略：在总线空闲的每个周期，考虑所有到达时间 $t_{i}$ 不超过当前时间的请求。目标行与其所在bank中当前打开的行相同的请求被认为是“优先就绪”的（行缓冲命中）。在优先就绪的请求中，选择到达时间最早的请求；如果不存在优先就绪的请求，则从所有可用请求中选择到达时间最早的请求。一旦一个请求被选中，就背对背地发出服务该请求所需的最短命令序列：如果bank是关闭的，则发出一个激活命令，然后是列命令；如果bank中打开了不同的行，则发出一个预充电命令，然后是激活命令，再然后是列命令；如果所需的行已经打开，则只发出列命令。不同请求的命令不能交错执行。\n\n将FR-FCFS策略应用于此请求流，以生成请求的发出顺序，并为每个请求在其列命令发出时，确定它是行缓冲命中还是未命中。计算实现的行缓冲命中率，其定义为行缓冲命中的请求数与总请求数之比。将最终的命中率表示为小数，并四舍五入到四位有效数字。命中率不需要单位。",
            "solution": "首先验证问题，以确保其是适定的、有科学依据且完整的。\n\n### 第1步：提取已知条件\n- **内存系统**：单rank DDR SDRAM设备。\n- **Bank**：$B=4$ 个bank，索引为 $b \\in \\{0,1,2,3\\}$。\n- **行缓冲区**：每个bank有一个行缓冲区。\n- **初始状态**：在时间 $t=0$ 时，所有bank都已预充电。\n- **总线**：共享命令/地址总线，每周期一个命令。\n- **时序参数**：\n    - 预充电时间：$t_{RP}=2$ 个周期。\n    - 激活时间：$t_{RCD}=2$ 个周期。\n    - 列访问时间（READ或WRITE）：$1$ 个周期。\n- **请求流**：一组10个请求，每个请求由 $(t_{i}, \\text{op}_{i}, b_{i}, r_{i})$ 定义。\n    - $i=1$: $(t_{1}=0, \\text{READ}, b_{1}=0, r_{1}=10)$\n    - $i=2$: $(t_{2}=1, \\text{WRITE}, b_{2}=1, r_{2}=7)$\n    - $i=3$: $(t_{3}=2, \\text{READ}, b_{3}=0, r_{3}=10)$\n    - $i=4$: $(t_{4}=3, \\text{READ}, b_{4}=2, r_{4}=3)$\n    - $i=5$: $(t_{5}=4, \\text{WRITE}, b_{5}=0, r_{5}=12)$\n    - $i=6$: $(t_{6}=5, \\text{READ}, b_{6}=1, r_{6}=7)$\n    - $i=7$: $(t_{7}=6, \\text{READ}, b_{7}=2, r_{7}=3)$\n    - $i=8$: $(t_{8}=7, \\text{WRITE}, b_{8}=3, r_{8}=1)$\n    - $i=9$: $(t_{9}=8, \\text{READ}, b_{9}=1, r_{9}=9)$\n    - $i=10$: $(t_{10}=9, \\text{READ}, b_{10}=3, r_{10}=1)$\n- **调度策略**：“就绪优先，先到先服务”（FR-FCFS）。在总线空闲的每个周期：\n    1. 考虑所有到达时间 $t_i$ 小于或等于当前时间的请求。\n    2. 优先处理“优先就绪”（行缓冲命中）的请求。如果一个请求的目标行与其bank中打开的行匹配，则该请求为命中。\n    3. 在就绪的请求中，选择到达时间最早的那个。\n    4. 如果没有就绪的请求，则从所有可用请求中选择到达时间最早的那个。\n- **命令发出**：背对背地发出最短的命令序列。\n- **目标**：计算行缓冲命中率，定义为（命中数）/（总请求数），并四舍五入到四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n该问题是计算机体系结构领域（特别是内存系统）中一个定义明确的模拟任务。该模型是DDR SDRAM控制器的一个标准但简化的表示。所有参数（$B$、$t_{RP}$、$t_{RCD}$）、初始状态、请求流和调度算法（FR-FCFS）都得到了明确且无歧义的定义。该问题是自包含的、有科学依据且客观的。它没有违反任何基本原则，也不包含矛盾或不完整的信息。因此，该问题是有效的。\n\n### 第3步：结论与行动\n问题有效。详细解法如下。\n\n解法通过逐周期模拟内存控制器的操作，并应用FR-FCFS调度策略来推导。我们将跟踪每个bank的状态（预充电或激活并打开了特定行）以及总线的可用性。\n\n一个请求可能是行缓冲命中或未命中。命令序列和所需时间取决于目标bank的状态：\n1.  **行缓冲命中**：正确的行已经打开。序列是一个列命令（READ/WRITE）。总时间：$1$ 个周期。\n2.  **行缓冲未命中（空bank）**：bank已预充电。序列是ACTIVATE，然后是列命令。总时间：$t_{RCD} + 1 = 2+1=3$ 个周期。\n3.  **行缓冲未命中（冲突）**：bank中打开了不同的行。序列是PRECHARGE，然后是ACTIVATE，再然后是列命令。总时间：$t_{RP} + t_{RCD} + 1 = 2+2+1=5$ 个周期。\n\n让我们追踪执行过程。`t` 是当前周期。`Bank State`（Bank状态）表示为每个bank $\\{0, 1, 2, 3\\}$ 的 `(状态, 打开的行)`。`H` 是命中计数，`M` 是未命中计数。\n\n**初始状态 (t=0):**\n- 总线：空闲。\n- Bank状态：B0(PRE, null), B1(PRE, null), B2(PRE, null), B3(PRE, null)。\n- `H=0`, `M=0`。\n\n**调度事件1 (t=0):**\n- 总线空闲。可用请求（在 $t=0$ 或之前到达）：请求1 $(t_1=0, \\text{R}, \\text{B0}, r_{10})$。\n- 请求1的目标是Bank 0，该bank已预充电。这是一个未命中。不存在“就绪”的请求。\n- **选择请求1**。这是一个未命中（空bank）。时间成本 = $t_{RCD} + 1 = 3$ 个周期。\n- 命令：`t=0: ACT(B0, r10)`, `t=1: (ACT)`, `t=2: READ(B0, r10)`。\n- 总线忙碌直到 $t=0+3=3$。\n- `M=1`。在 $t=3$ 时，Bank 0 变为 `(ACTIVE, r10)`。\n\n**调度事件2 (t=3):**\n- 总线空闲。可用请求：请求2 $(t_2=1)$，请求3 $(t_3=2)$，请求4 $(t_4=3)$。\n- 检查就绪（命中）的请求：\n    - 请求2 (B1, r7)：Bank 1已预充电。未命中。\n    - 请求3 (B0, r10)：Bank 0已激活，打开的行是10。**命中**。\n    - 请求4 (B2, r3)：Bank 2已预充电。未命中。\n- “就绪”集合是{请求3}。\n- **选择请求3**。这是一个命中。时间成本 = $1$ 个周期。\n- 命令：`t=3: READ(B0, r10)`。\n- 总线忙碌直到 $t=3+1=4$。\n- `H=1`, `M=1`。Bank 0 保持 `(ACTIVE, r10)` 状态。\n\n**调度事件3 (t=4):**\n- 总线空闲。可用请求：请求2 $(t_2=1)$，请求4 $(t_4=3)$，请求5 $(t_5=4)$。\n- 检查命中：\n    - 请求2 (B1, r7)：Bank 1已预充电。未命中。\n    - 请求4 (B2, r3)：Bank 2已预充电。未命中。\n    - 请求5 (B0, r12)：Bank 0 打开的是行10。未命中（冲突）。\n- 没有就绪的请求。根据到达时间（FCFS）从所有可用请求中选择：请求2最早。\n- **选择请求2**。这是一个未命中（空bank）。时间成本 = $3$ 个周期。\n- 命令：`t=4: ACT(B1, r7)`, `t=5: (ACT)`, `t=6: WRITE(B1, r7)`。\n- 总线忙碌直到 $t=4+3=7$。\n- `H=1`, `M=2`。在 $t=7$ 时，Bank 1 变为 `(ACTIVE, r7)`。\n\n**调度事件4 (t=7):**\n- 总线空闲。可用请求：请求4 $(t_4=3)$，请求5 $(t_5=4)$，请求6 $(t_6=5)$，请求7 $(t_7=6)$，请求8 $(t_8=7)$。\n- 检查命中：\n    - 请求6 (B1, r7)：Bank 1已激活，打开的行是7。**命中**。\n- “就绪”集合是{请求6}。\n- **选择请求6**。这是一个命中。时间成本 = $1$ 个周期。\n- 命令：`t=7: READ(B1, r7)`。\n- 总线忙碌直到 $t=7+1=8$。\n- `H=2`, `M=2`。Bank 1 保持 `(ACTIVE, r7)` 状态。\n\n**调度事件5 (t=8):**\n- 总线空闲。可用请求：请求4, 5, 7, 8, 9。\n- 检查命中：所有可用请求都是未命中。\n- 没有就绪的请求。选择到达时间最早的：请求4 $(t_4=3)$。\n- **选择请求4**。这是一个未命中（空bank）。时间成本 = $3$ 个周期。\n- 命令：`t=8: ACT(B2, r3)`, `t=9: (ACT)`, `t=10: READ(B2, r3)`。\n- 总线忙碌直到 $t=8+3=11$。\n- `H=2`, `M=3`。在 $t=11$ 时，Bank 2 变为 `(ACTIVE, r3)`。\n\n**调度事件6 (t=11):**\n- 总线空闲。可用请求：请求5, 7, 8, 9, 10。\n- 检查命中：\n    - 请求7 (B2, r3)：Bank 2已激活，打开的行是3。**命中**。\n- “就绪”集合是{请求7}。\n- **选择请求7**。这是一个命中。时间成本 = $1$ 个周期。\n- 命令：`t=11: READ(B2, r3)`。\n- 总线忙碌直到 $t=11+1=12$。\n- `H=3`, `M=3`。Bank 2 保持 `(ACTIVE, r3)` 状态。\n\n**调度事件7 (t=12):**\n- 总线空闲。可用请求：请求5, 8, 9, 10。\n- 检查命中：全部是未命中。\n- 没有就绪的请求。选择到达时间最早的：请求5 $(t_5=4)$。\n- **选择请求5**。这是一个未命中（冲突）。Bank 0 打开的是行10，而请求需要行12。时间成本 = $t_{RP} + t_{RCD} + 1 = 5$ 个周期。\n- 命令：`t=12: PRE(B0)`, `t=13: (PRE)`, `t=14: ACT(B0, r12)`, `t=15: (ACT)`, `t=16: WRITE(B0, r12)`。\n- 总线忙碌直到 $t=12+5=17$。\n- `H=3`, `M=4`。在 $t=17$ 时，Bank 0 变为 `(ACTIVE, r12)`。\n\n**调度事件8 (t=17):**\n- 总线空闲。可用请求：请求8, 9, 10。\n- 检查命中：全部是未命中。\n- 没有就绪的请求。选择到达时间最早的：请求8 $(t_8=7)$。\n- **选择请求8**。这是一个未命中（空bank）。时间成本 = $3$ 个周期。\n- 命令：`t=17: ACT(B3, r1)`, `t=18: (ACT)`, `t=19: WRITE(B3, r1)`。\n- 总线忙碌直到 $t=17+3=20$。\n- `H=3`, `M=5`。在 $t=20$ 时，Bank 3 变为 `(ACTIVE, r1)`。\n\n**调度事件9 (t=20):**\n- 总线空闲。可用请求：请求9, 10。\n- 检查命中：\n    - 请求10 (B3, r1)：Bank 3已激活，打开的行是1。**命中**。\n- “就绪”集合是{请求10}。\n- **选择请求10**。这是一个命中。时间成本 = $1$ 个周期。\n- 命令：`t=20: READ(B3, r1)`。\n- 总线忙碌直到 $t=20+1=21$。\n- `H=4`, `M=5`。Bank 3 保持 `(ACTIVE, r1)` 状态。\n\n**调度事件10 (t=21):**\n- 总线空闲。可用请求：请求9。\n- 检查命中：请求9 (B1, r9) 是一个未命中（与打开的行7冲突）。\n- 没有就绪的请求。从可用请求中选择：请求9。\n- **选择请求9**。这是一个未命中（冲突）。时间成本 = $5$ 个周期。\n- 命令：`t=21: PRE(B1)`, `t=22: (PRE)`, `t=23: ACT(B1, r9)`, `t=24: (ACT)`, `t=25: READ(B1, r9)`。\n- 总线忙碌直到 $t=21+5=26$。\n- `H=4`, `M=6`。在 $t=26$ 时，Bank 1 变为 `(ACTIVE, r9)`。\n\n**总结:**\n- 服务的请求序列是：1, 3, 2, 6, 4, 7, 5, 8, 10, 9。\n- 以下请求是行缓冲命中：3, 6, 7, 10。\n- 以下请求是行缓冲未命中：1, 2, 4, 5, 8, 9。\n\n总请求数：$N_{total} = 10$。\n行缓冲命中数：$N_{hits} = 4$。\n\n行缓冲命中率计算为命中数与总请求数之比。\n$$ \\text{命中率} = \\frac{N_{hits}}{N_{total}} = \\frac{4}{10} = 0.4 $$\n问题要求答案为小数，并四舍五入到四位有效数字。\n$$ \\text{命中率} = 0.4000 $$",
            "answer": "$$\\boxed{0.4000}$$"
        },
        {
            "introduction": "在选择了要服务的请求之后，最后一步是发出精确的DRAM命令序列。本练习要求您在复杂的DRAM时序约束（如 $t_{RRD}$、$t_{FAW}$ 等）网络中，创建一个最优的命令调度。解决这个时序难题对于最大限度地减少总线空闲时间和最大化内存带宽至关重要。",
            "id": "4255759",
            "problem": "一个内存控制器通过一条共享的命令/地址总线向一个双倍数据速率同步动态随机存取存储器（DDR SDRAM）设备发送命令，该总线每个时钟周期最多能传输一个命令。假设有四个存储体（bank），每个存储体都针对一个不同的行。控制器必须向不同的存储体发出四个激活（ACTIVATE, ACT）命令，并向最先被激活的两个存储体各发出一个读取（READ）命令。时间线从周期 $0$ 开始，此时所有存储体都已预充电，总线处于空闲状态。只需考虑以下时序约束；忽略存储体组约束、数据总线突发长度、总线转换时间以及任何下面未列出的时序。\n\n- 行至列延迟（$t_{RCD}$）：对一个存储体执行ACT命令后，最早对该存储体执行READ命令的时间是在 $t_{RCD}$ 个周期之后。\n- 行预充电时间（$t_{RP}$）：执行PRECHARGE命令后预充电一个存储体的最短时间；本任务中不需要PRECHARGE命令，但为完整起见提供了此参数。\n- 行有效时间（$t_{RAS}$）：在预充电前，一个行必须保持激活状态的最短时间；同样，本任务中不需要PRECHARGE命令，但为完整起见提供了此参数。\n- 行至行延迟（$t_{RRD}$）：对不同存储体执行ACT命令之间的最短时间间隔。\n- 四激活窗口（$t_{FAW}$）：在任何长度为 $t_{FAW}$ 个周期的滚动窗口内，最多只能发出四个ACT命令。\n- 列至列延迟（$t_{CCD}$）：连续的列命令（例如，READ到READ）之间的最短时间间隔，无论存储体是否相同。\n\n给定参数为 $t_{RCD}=14$、$t_{RP}=14$、$t_{RAS}=34$、$t_{RRD}=6$、$t_{FAW}=30$ 和 $t_{CCD}=4$（所有单位均为时钟周期）。两个READ命令必须分别针对由第一个和第二个ACT命令激活的行。请构建一个有效的命令调度方案，在满足上述约束的同时，最小化命令总线上的空闲周期。\n\n在一个直到该时间点为止命令总线空闲周期最少的优化调度下，第二个READ命令可以被发出的最早周期索引是什么？请用整数形式表示你的答案（单位为周期，无需四舍五入）。",
            "solution": "用户希望找到向DDR SDRAM设备发出的两个所需READ命令中的第二个命令可以被发出的最早周期。该调度必须是最优的，意味着在发出最后一个命令之前，它要最小化命令总线上的空闲周期，同时遵守所有指定的时序约束。\n\n首先，我们确定需要调度的命令序列。问题要求向四个不同的存储体发出四个激活（ACT）命令，然后是两个读取（READ）命令。READ命令必须针对由第一个和第二个ACT命令激活的存储体。我们用 $B_0, B_1, B_2, B_3$ 表示这些存储体。我们将分别调度 `ACT`$_0$、`ACT`$_1$、`ACT`$_2$、`ACT`$_3$ 命令给这些存储体。因此，READ命令将是 `READ`$_0$ 和 `READ`$_1$。时间线从周期 $0$ 开始。\n\n调度策略将采用贪心算法：在任何给定的时钟周期，如果命令总线空闲，并且至少有一个命令的时序依赖关系已经满足，我们就会发出该命令。这个策略自然地满足了最小化总线空闲周期的要求。\n\n给定的时序参数是：\n- 行至列延迟：$t_{RCD} = 14$ 个周期\n- 行至行延迟：$t_{RRD} = 6$ 个周期\n- 四激活窗口：$t_{FAW} = 30$ 个周期\n- 列至列延迟：$t_{CCD} = 4$ 个周期\n参数 $t_{RP}=14$ 和 $t_{RAS}=34$ 在本任务中不相关，因为没有发出PRECHARGE命令。总线每个周期最多能接受一个命令。\n\n令 $C(cmd)$ 表示命令 $cmd$ 发出的周期索引。\n\n**第一步：调度ACTIVATE命令**\n四个ACT命令必须发往四个不同的存储体。控制它们间隔的主要约束是行至行延迟，$t_{RRD}$。\n1.  第一个命令 `ACT`$_0$ 可以在最早的时间，即周期 $0$ 发出。\n    $C(\\text{ACT}_0) = 0$。\n2.  第二个命令 `ACT`$_1$ 必须在 `ACT`$_0$ 之后至少 $t_{RRD}$ 个周期才能发出。\n    $C(\\text{ACT}_1) \\geq C(\\text{ACT}_0) + t_{RRD} = 0 + 6 = 6$。\n    为了最小化空闲时间，我们在最早可能的周期调度 `ACT`$_1$：$C(\\text{ACT}_1) = 6$。\n3.  同样，`ACT`$_2$ 必须在 `ACT`$_1$ 之后至少 $t_{RRD}$ 个周期才能发出。\n    $C(\\text{ACT}_2) \\geq C(\\text{ACT}_1) + t_{RRD} = 6 + 6 = 12$。\n    我们在 $C(\\text{ACT}_2) = 12$ 调度它。\n4.  最后，`ACT`$_3$ 必须在 `ACT`$_2$ 之后至少 $t_{RRD}$ 个周期才能发出。\n    $C(\\text{ACT}_3) \\geq C(\\text{ACT}_2) + t_{RRD} = 12 + 6 = 18$。\n    我们在 $C(\\text{ACT}_3) = 18$ 调度它。\n\n这样就得出了ACT命令的调度方案：\n- `ACT`$_0$ 在周期 $0$\n- `ACT`$_1$ 在周期 $6$\n- `ACT`$_2$ 在周期 $12$\n- `ACT`$_3$ 在周期 $18$\n\n我们必须根据四激活窗口约束（$t_{FAW}$）来验证这一点。该约束规定，在任何长度为 $t_{FAW}=30$ 个周期的滚动窗口内，最多只能发出四个ACT命令。我们的四个ACT命令分别在周期 $0, 6, 12, 18$ 发出。第一个和第四个ACT之间经过的时间是 $C(\\text{ACT}_3) - C(\\text{ACT}_0) = 18 - 0 = 18$ 个周期。由于我们总共只发出四个ACT命令，任何后续的ACT命令都需要遵守由前四个命令建立的窗口。例如，一个假设的第五个ACT命令 `ACT`$_4$ 不能在周期 $30$ 之前发出，因为 $C(\\text{ACT}_4) - C(\\text{ACT}_1)$ 需要 $\\ge t_{FAW}$。由于我们只有四个ACT命令，我们的调度方案在 $t_{FAW}$ 方面是有效的。\n\n**第二步：调度READ命令**\n我们需要调度 `READ`$_0$（到存储体 $B_0$）和 `READ`$_1$（到存储体 $B_1$）。\n\n首先，我们根据行至列延迟（$t_{RCD}$）确定每个READ命令的最早准备就绪时间。\n-   `READ`$_0$ 只有在其对应的存储体被激活且经过了 $t_{RCD}$ 时间后才能发出。\n    $C(\\text{READ}_0) \\geq C(\\text{ACT}_0) + t_{RCD} = 0 + 14 = 14$。\n    所以，`READ`$_0$ 在周期 $14$ 或之后准备就绪。\n-   `READ`$_1$ 的准备就绪时间也类似地确定。\n    $C(\\text{READ}_1) \\geq C(\\text{ACT}_1) + t_{RCD} = 6 + 14 = 20$。\n    所以，`READ`$_1$ 在周期 $20$ 或之后准备就绪。\n\n现在，我们必须将这些命令放置在命令总线上，同时要考虑它们的准备就绪时间和总线可用性。\n-   我们可以发出 `READ`$_0$ 的最早周期是周期 $14$。命令总线在周期 $14$ 是可用的（前一个命令是周期 $12$ 的 `ACT`$_2$）。因此，我们在其最早可能的时间调度 `READ`$_0$ 以最小化空闲周期：\n    $C(\\text{READ}_0) = 14$。\n\n-   接下来，我们调度 `READ`$_1$。它的发出时间受到两个因素的制约：\n    1.  其自身基于 $t_{RCD}$ 的准备就绪时间：$C(\\text{READ}_1) \\geq 20$。\n    2.  相对于前一个发出的READ命令（`READ`$_0$）的列至列延迟 $t_{CCD}$。\n        $C(\\text{READ}_1) \\geq C(\\text{READ}_0) + t_{CCD} = 14 + 4 = 18$。\n\n    为了同时满足这两个约束，`READ`$_1$ 的发出时间必须大于或等于这两个下界中的最大值：\n    $C(\\text{READ}_1) \\geq \\max(20, 18) = 20$。\n\n    因此，发出 `READ`$_1$ 的最早可能周期是 $20$。我们必须检查命令总线在周期 $20$ 是否可用。到目前为止的命令调度是：\n    - 周期 $0$：`ACT`$_0$\n    - 周期 $6$：`ACT`$_1$\n    - 周期 $12$：`ACT`$_2$\n    - 周期 $14$：`READ`$_0$\n    - 周期 $18$：`ACT`$_3$\n    总线在周期 $20$ 确实是空闲的。因此，我们可以在这个时间调度 `READ`$_1$。\n    $C(\\text{READ}_1) = 20$。\n\n这构成了一个完整且有效的调度方案，它遵循了贪心的、最小化空闲时间的策略。对 $C(\\text{READ}_1)$ 的下界分析表明，不可能有更早的时间。最终的调度方案是：\n- 周期 $0$：`ACT`$_0$\n- 周期 $6$：`ACT`$_1$\n- 周期 $12$：`ACT`$_2$\n- 周期 $14$：`READ`$_0$\n- 周期 $18$：`ACT`$_3$\n- 周期 $20$：`READ`$_1$\n\n问题询问的是第二个READ命令可以被发出的最早周期索引。根据我们的最优调度，这个时间是周期 $20$。",
            "answer": "$$\\boxed{20}$$"
        }
    ]
}