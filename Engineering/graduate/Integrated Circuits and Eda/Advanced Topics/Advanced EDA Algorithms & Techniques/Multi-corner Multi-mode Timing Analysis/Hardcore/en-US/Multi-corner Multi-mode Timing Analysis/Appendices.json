{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of Static Timing Analysis (STA) is the ability to accurately calculate signal propagation delay through a combinational logic path. This first exercise provides hands-on practice with this fundamental skill by using a linearized Non-Linear Delay Model (NLDM), which captures the dependency of cell delay on input signal transition time (slew) and output load. By manually propagating arrival times and slews through a multi-stage path, you will build an intuition for the core mechanics that underpin all modern timing engines .",
            "id": "4284051",
            "problem": "In multi-corner multi-mode static timing analysis for integrated circuits, the time of data arrival at an endpoint is determined by propagating timing through a combinational path while accounting for the dependence of each cell’s propagation delay and output slew on its input slew and output capacitive load. Consider a synchronous pipeline path analyzed for setup timing at the slow-slow, low-voltage, high-temperature corner (denoted SS, with supply $0.72$ V and temperature $125\\,^{\\circ}$C) in functional mode, which is designated as setup-worst for this design. The path is from the launching register output $Q$ of $\\text{FF}_\\text{L}$,\n1. Launching register output $Q$ of $\\text{FF}_\\text{L}$,\n2. $\\text{INV\\_X2}$,\n3. $\\text{NAND2\\_X1}$ with the non-controlling input held at logic high, and\n4. $\\text{BUF\\_X4}$,\nending at the data input $D$ of the capturing register $\\text{FF}_\\text{C}$.\n\nThe cell library at this corner is available in a linearized Non-Linear Delay Model (NLDM) form around the relevant operating point. For each driver cell $g$, the propagation delay and output slew are modeled as affine functions of input slew and output capacitive load:\n- Propagation delay: $d_g = d_{0,g} + k_{s,g}\\,S_{\\text{in}} + k_{c,g}\\,C_{\\text{load}}$,\n- Output slew: $S_{\\text{out},g} = s_{0,g} + m_{s,g}\\,S_{\\text{in}} + m_{c,g}\\,C_{\\text{load}}$,\nwhere $S_{\\text{in}}$ and $S_{\\text{out},g}$ are in ns, and $C_{\\text{load}}$ is in fF. For the launching register $\\text{FF}_\\text{L}$, the clock-to-$Q$ delay and $Q$ output slew are given by:\n- Clock-to-$Q$ delay: $d_{\\text{CQ}} = d_{0,\\text{FF}} + k_{c,\\text{FF}}\\,C_{\\text{load,FF}}$,\n- $Q$ output slew: $S_{Q} = s_{0,\\text{FF}} + m_{c,\\text{FF}}\\,C_{\\text{load,FF}}$.\n\nUse the following cell parameters at the SS corner:\n- $\\text{FF}_\\text{L}$: $d_{0,\\text{FF}} = 0.080$ ns, $k_{c,\\text{FF}} = 0.0005$ ns/fF, $s_{0,\\text{FF}} = 0.040$ ns, $m_{c,\\text{FF}} = 0.0012$ ns/fF.\n- $\\text{INV\\_X2}$: $d_{0} = 0.020$ ns, $k_{s} = 0.20$, $k_{c} = 0.0010$ ns/fF, $s_{0} = 0.015$ ns, $m_{s} = 0.30$, $m_{c} = 0.0025$ ns/fF.\n- $\\text{NAND2\\_X1}$: $d_{0} = 0.030$ ns, $k_{s} = 0.25$, $k_{c} = 0.0015$ ns/fF, $s_{0} = 0.020$ ns, $m_{s} = 0.35$, $m_{c} = 0.0030$ ns/fF.\n- $\\text{BUF\\_X4}$: $d_{0} = 0.018$ ns, $k_{s} = 0.15$, $k_{c} = 0.0008$ ns/fF, $s_{0} = 0.012$ ns, $m_{s} = 0.25$, $m_{c} = 0.0018$ ns/fF.\n\nThe capacitive loads of the receiving pins are:\n- $\\text{INV\\_X2}$ input pin capacitance: $2.5$ fF,\n- $\\text{NAND2\\_X1}$ input pin capacitance on the switching input: $3.0$ fF,\n- $\\text{BUF\\_X4}$ input pin capacitance: $4.0$ fF,\n- $\\text{FF}_\\text{C}$ data input $D$ pin capacitance: $2.0$ fF.\n\nThe interconnects between driving and receiving pins are modeled as lumped capacitors added to the load seen by the driver, with the following values:\n- Between $\\text{FF}_\\text{L}.Q$ and $\\text{INV\\_X2}.A$: $C_{0} = 6.0$ fF,\n- Between $\\text{INV\\_X2}.Y$ and $\\text{NAND2\\_X1}.A$: $C_{1} = 7.0$ fF,\n- Between $\\text{NAND2\\_X1}.Y$ and $\\text{BUF\\_X4}.A$: $C_{2} = 8.0$ fF,\n- Between $\\text{BUF\\_X4}.Y$ and $\\text{FF}_\\text{C}.D$: $C_{3} = 10.0$ fF.\n\nAssumptions and modeling directives:\n- Treat all interconnects as purely capacitive with no explicit resistive delay; driver resistance effects are implicitly captured by the linearized NLDM coefficients above.\n- Use single-input switching for $\\text{NAND2\\_X1}$ with its non-switching input at a non-controlling logic level.\n- The load seen by each driver equals the sum of the input pin capacitances of its immediate fanouts plus the interconnect capacitance on that net.\n- Propagate slew stage-by-stage using the linear slew model given for each driver, using the previous stage’s output slew as the next stage’s input slew.\n- The launch clock edge at $\\text{FF}_\\text{L}$ occurs at time $t = 0$, and you should measure the data arrival time at $\\text{FF}_\\text{C}.D$ relative to this edge.\n\nTask: Compute the data arrival time at $\\text{FF}_\\text{C}.D$ at the SS corner in functional mode under the assumptions above. Explicitly state the assumptions you are making about how slew and load are propagated from stage to stage. Round your final numeric answer to four significant figures and express it in ns. Your final answer must be a single real number.",
            "solution": "### Step 1: Extract Givens\n**Path Information:**\n- Synchronous pipeline path analyzed for setup timing.\n- Corner: slow-slow (SS), low-voltage, high-temperature.\n- Supply: $0.72$ V.\n- Temperature: $125\\,^{\\circ}$C.\n- Mode: functional.\n- Path: Launching register $\\text{FF}_\\text{L}$ output $Q$ $\\rightarrow$ $\\text{INV\\_X2}$ $\\rightarrow$ $\\text{NAND2\\_X1}$ (non-controlling input held high) $\\rightarrow$ $\\text{BUF\\_X4}$ $\\rightarrow$ Capturing register $\\text{FF}_\\text{C}$ input $D$.\n\n**NLDM Model Equations:**\n- Propagation delay: $d_g = d_{0,g} + k_{s,g}\\,S_{\\text{in}} + k_{c,g}\\,C_{\\text{load}}$\n- Output slew: $S_{\\text{out},g} = s_{0,g} + m_{s,g}\\,S_{\\text{in}} + m_{c,g}\\,C_{\\text{load}}$\n- Clock-to-$Q$ delay: $d_{\\text{CQ}} = d_{0,\\text{FF}} + k_{c,\\text{FF}}\\,C_{\\text{load,FF}}$\n- $Q$ output slew: $S_{Q} = s_{0,\\text{FF}} + m_{c,\\text{FF}}\\,C_{\\text{load,FF}}$\n\n**Cell Parameters at SS Corner:**\n- $\\text{FF}_\\text{L}$: $d_{0,\\text{FF}} = 0.080$ ns, $k_{c,\\text{FF}} = 0.0005$ ns/fF, $s_{0,\\text{FF}} = 0.040$ ns, $m_{c,\\text{FF}} = 0.0012$ ns/fF.\n- $\\text{INV\\_X2}$: $d_{0} = 0.020$ ns, $k_{s} = 0.20$, $k_{c} = 0.0010$ ns/fF, $s_{0} = 0.015$ ns, $m_{s} = 0.30$, $m_{c} = 0.0025$ ns/fF.\n- $\\text{NAND2\\_X1}$: $d_{0} = 0.030$ ns, $k_{s} = 0.25$, $k_{c} = 0.0015$ ns/fF, $s_{0} = 0.020$ ns, $m_{s} = 0.35$, $m_{c} = 0.0030$ ns/fF.\n- $\\text{BUF\\_X4}$: $d_{0} = 0.018$ ns, $k_{s} = 0.15$, $k_{c} = 0.0008$ ns/fF, $s_{0} = 0.012$ ns, $m_{s} = 0.25$, $m_{c} = 0.0018$ ns/fF.\n\n**Capacitive Loads:**\n- $\\text{INV\\_X2}$ input pin capacitance: $2.5$ fF.\n- $\\text{NAND2\\_X1}$ input pin capacitance: $3.0$ fF.\n- $\\text{BUF\\_X4}$ input pin capacitance: $4.0$ fF.\n- $\\text{FF}_\\text{C}$ data input $D$ pin capacitance: $2.0$ fF.\n- Interconnect between $\\text{FF}_\\text{L}.Q$ and $\\text{INV\\_X2}.A$: $C_{0} = 6.0$ fF.\n- Interconnect between $\\text{INV\\_X2}.Y$ and $\\text{NAND2\\_X1}.A$: $C_{1} = 7.0$ fF.\n- Interconnect between $\\text{NAND2\\_X1}.Y$ and $\\text{BUF\\_X4}.A$: $C_{2} = 8.0$ fF.\n- Interconnect between $\\text{BUF\\_X4}.Y$ and $\\text{FF}_\\text{C}.D$: $C_{3} = 10.0$ fF.\n\n**Assumptions and Directives:**\n- Interconnects are purely capacitive.\n- Single-input switching for $\\text{NAND2\\_X1}$.\n- Load seen by driver = sum of input pin capacitances + interconnect capacitance.\n- Slew is propagated stage-by-stage.\n- Launch clock edge at $t = 0$.\n- Round final answer to four significant figures.\n\nThe task is to compute the total data arrival time, denoted $T_A$, at the data input pin $D$ of the capturing register $\\text{FF}_\\text{C}$. The launch clock for the launching register $\\text{FF}_\\text{L}$ arrives at time $t=0$. The total arrival time is the accumulated delay through the combinational path starting from the clock-to-Q delay of $\\text{FF}_\\text{L}$.\n\nThe key principle is that the timing characteristics (delay and output slew) of each logic stage depend on the output capacitive load it drives and the slew of the signal at its input. Therefore, we must propagate the timing information—arrival time and signal slew—sequentially through the path.\n\nThe assumptions for propagation, as requested, are:\n1.  The total capacitive load $C_{\\text{load}}$ on a driver's output is the sum of the interconnect capacitance and the input pin capacitance of the cell(s) driven by that output.\n2.  The input slew $S_{\\text{in}}$ for a given logic stage is the output slew $S_{\\text{out}}$ of the preceding driver stage.\n3.  The arrival time at a node is the sum of the arrival time at the preceding node and the propagation delay of the intervening cell.\n\nThe path consists of four stages of delay accumulation:\n1.  $\\text{FF}_\\text{L}$ (clock-to-Q delay)\n2.  $\\text{INV\\_X2}$ (propagation delay)\n3.  $\\text{NAND2\\_X1}$ (propagation delay)\n4.  $\\text{BUF\\_X4}$ (propagation delay)\n\nWe will compute the contribution of each stage sequentially. All delays and slews are in nanoseconds (ns) and capacitances are in femtofarads (fF).\n\n**Stage 1: Launching Register ($\\text{FF}_\\text{L}$)**\nThe first stage is the launching register $\\text{FF}_\\text{L}$. Its timing is determined by the load on its output pin $Q$.\nThe load $C_{\\text{load,FF}}$ is the sum of the interconnect capacitance $C_0$ and the input pin capacitance of the inverter $\\text{INV\\_X2}$.\n$$C_{\\text{load,FF}} = C_0 + C_{\\text{pin,INV}} = 6.0\\,\\text{fF} + 2.5\\,\\text{fF} = 8.5\\,\\text{fF}$$\nThe clock-to-Q delay ($d_{\\text{CQ}}$) and the output slew at $Q$ ($S_Q$) are calculated using the given models for $\\text{FF}_\\text{L}$:\n$$d_{\\text{CQ}} = d_{0,\\text{FF}} + k_{c,\\text{FF}}\\,C_{\\text{load,FF}} = 0.080 + 0.0005 \\times 8.5 = 0.080 + 0.00425 = 0.08425\\,\\text{ns}$$\n$$S_Q = s_{0,\\text{FF}} + m_{c,\\text{FF}}\\,C_{\\text{load,FF}} = 0.040 + 0.0012 \\times 8.5 = 0.040 + 0.0102 = 0.0502\\,\\text{ns}$$\nThe arrival time at the input of the $\\text{INV\\_X2}$ is $T_{A,0} = d_{\\text{CQ}} = 0.08425$\\,ns.\nThe output slew $S_Q$ becomes the input slew for the next stage, $S_{\\text{in,INV}}$.\n\n**Stage 2: Inverter ($\\text{INV\\_X2}$)**\nThe input slew for the inverter is $S_{\\text{in,INV}} = S_Q = 0.0502$\\,ns.\nThe load on the inverter's output, $C_{\\text{load,INV}}$, is the sum of the interconnect capacitance $C_1$ and the input pin capacitance of the $\\text{NAND2\\_X1}$ gate.\n$$C_{\\text{load,INV}} = C_1 + C_{\\text{pin,NAND}} = 7.0\\,\\text{fF} + 3.0\\,\\text{fF} = 10.0\\,\\text{fF}$$\nThe propagation delay ($d_{\\text{INV}}$) and output slew ($S_{\\text{out,INV}}$) of the inverter are:\n$$d_{\\text{INV}} = d_{0,\\text{INV}} + k_{s,\\text{INV}}\\,S_{\\text{in,INV}} + k_{c,\\text{INV}}\\,C_{\\text{load,INV}}$$\n$$d_{\\text{INV}} = 0.020 + 0.20 \\times 0.0502 + 0.0010 \\times 10.0 = 0.020 + 0.01004 + 0.010 = 0.04004\\,\\text{ns}$$\n$$S_{\\text{out,INV}} = s_{0,\\text{INV}} + m_{s,\\text{INV}}\\,S_{\\text{in,INV}} + m_{c,\\text{INV}}\\,C_{\\text{load,INV}}$$\n$$S_{\\text{out,INV}} = 0.015 + 0.30 \\times 0.0502 + 0.0025 \\times 10.0 = 0.015 + 0.01506 + 0.025 = 0.05506\\,\\text{ns}$$\nThe arrival time at the input of the $\\text{NAND2\\_X1}$ is $T_{A,1} = T_{A,0} + d_{\\text{INV}} = 0.08425 + 0.04004 = 0.12429$\\,ns.\nThe output slew $S_{\\text{out,INV}}$ becomes the input slew for the next stage, $S_{\\text{in,NAND}}$.\n\n**Stage 3: NAND Gate ($\\text{NAND2\\_X1}$)**\nThe input slew for the NAND gate is $S_{\\text{in,NAND}} = S_{\\text{out,INV}} = 0.05506$\\,ns.\nThe load on the NAND gate's output, $C_{\\text{load,NAND}}$, is the sum of the interconnect capacitance $C_2$ and the input pin capacitance of the buffer $\\text{BUF\\_X4}$.\n$$C_{\\text{load,NAND}} = C_2 + C_{\\text{pin,BUF}} = 8.0\\,\\text{fF} + 4.0\\,\\text{fF} = 12.0\\,\\text{fF}$$\nThe propagation delay ($d_{\\text{NAND}}$) and output slew ($S_{\\text{out,NAND}}$) of the NAND gate are:\n$$d_{\\text{NAND}} = d_{0,\\text{NAND}} + k_{s,\\text{NAND}}\\,S_{\\text{in,NAND}} + k_{c,\\text{NAND}}\\,C_{\\text{load,NAND}}$$\n$$d_{\\text{NAND}} = 0.030 + 0.25 \\times 0.05506 + 0.0015 \\times 12.0 = 0.030 + 0.013765 + 0.018 = 0.061765\\,\\text{ns}$$\n$$S_{\\text{out,NAND}} = s_{0,\\text{NAND}} + m_{s,\\text{NAND}}\\,S_{\\text{in,NAND}} + m_{c,\\text{NAND}}\\,C_{\\text{load,NAND}}$$\n$$S_{\\text{out,NAND}} = 0.020 + 0.35 \\times 0.05506 + 0.0030 \\times 12.0 = 0.020 + 0.019271 + 0.036 = 0.075271\\,\\text{ns}$$\nThe arrival time at the input of the $\\text{BUF\\_X4}$ is $T_{A,2} = T_{A,1} + d_{\\text{NAND}} = 0.12429 + 0.061765 = 0.186055$\\,ns.\nThe output slew $S_{\\text{out,NAND}}$ becomes the input slew for the final stage, $S_{\\text{in,BUF}}$.\n\n**Stage 4: Buffer ($\\text{BUF\\_X4}$)**\nThe input slew for the buffer is $S_{\\text{in,BUF}} = S_{\\text{out,NAND}} = 0.075271$\\,ns.\nThe load on the buffer's output, $C_{\\text{load,BUF}}$, is the sum of the interconnect capacitance $C_3$ and the data pin capacitance of the capturing register $\\text{FF}_\\text{C}$.\n$$C_{\\text{load,BUF}} = C_3 + C_{\\text{pin,FF\\_C}} = 10.0\\,\\text{fF} + 2.0\\,\\text{fF} = 12.0\\,\\text{fF}$$\nThe propagation delay ($d_{\\text{BUF}}$) of the buffer is:\n$$d_{\\text{BUF}} = d_{0,\\text{BUF}} + k_{s,\\text{BUF}}\\,S_{\\text{in,BUF}} + k_{c,\\text{BUF}}\\,C_{\\text{load,BUF}}$$\n$$d_{\\text{BUF}} = 0.018 + 0.15 \\times 0.075271 + 0.0008 \\times 12.0 = 0.018 + 0.01129065 + 0.0096 = 0.03889065\\,\\text{ns}$$\n\n**Final Arrival Time Calculation**\nThe final data arrival time $T_A$ at the $D$ input of $\\text{FF}_\\text{C}$ is the sum of all stage delays.\n$$T_A = d_{\\text{CQ}} + d_{\\text{INV}} + d_{\\text{NAND}} + d_{\\text{BUF}}$$\n$$T_A = 0.08425 + 0.04004 + 0.061765 + 0.03889065 = 0.22494565\\,\\text{ns}$$\nThis can also be calculated as the arrival time at the input of the last stage plus its delay: $T_A = T_{A,2} + d_{\\text{BUF}} = 0.186055 + 0.03889065 = 0.22494565$\\,ns.\n\nThe problem requires rounding the final answer to four significant figures.\nThe calculated value is $0.22494565$\\,ns. The four most significant digits are $2$, $2$, $4$, and $9$. The fifth digit is $4$, so we round down.\n$$T_A \\approx 0.2249\\,\\text{ns}$$",
            "answer": "$$\\boxed{0.2249}$$"
        },
        {
            "introduction": "After mastering path delay calculation, the next step is to evaluate this delay against the clock constraints, which is the essence of calculating timing slack. This practice delves into the complexities of Multi-Corner Multi-Mode (MCMM) analysis, where you must identify the pessimistic corner combinations for both setup and hold violations, a concept central to designing robust circuits. You will learn to account for how Process-Voltage-Temperature (PVT) variations independently affect the data and clock paths to determine the true worst-case timing margin across different operating modes .",
            "id": "4284013",
            "problem": "A synchronous single-clock pipeline in an integrated circuit is analyzed using Static Timing Analysis (STA) within a Multi-Corner Multi-Mode (MCMM) flow as part of Electronic Design Automation (EDA). Consider a single register-to-register path from a launch flip-flop $\\text{FF}_{\\mathrm{L}}$ to a capture flip-flop $\\text{FF}_{\\mathrm{C}}$. The data path comprises two logic gates and three interconnect segments. The analysis must incorporate Process-Voltage-Temperature (PVT) device corners and resistance-capacitance (RC) routing corners.\n\nFundamental definitions: STA evaluates signal propagation times and constraints. The setup requirement ensures that data arrives at $\\text{FF}_{\\mathrm{C}}$ before its active capture edge by a margin $t_{\\mathrm{setup}}$, while the hold requirement ensures that newly launched data does not overwrite stored data for a duration $t_{\\mathrm{hold}}$ after the same capture edge. For each timing check, define the data arrival time as the sum of the launch clock edge time and data path delay, and define the required time as the appropriate capture edge time shifted by the setup or hold margin. Slack is defined as required time minus arrival time. A negative slack indicates a violation.\n\nDevice corners available: Slow-Slow $(\\mathrm{SS})$ and Fast-Fast $(\\mathrm{FF})$, with gate delay multipliers of $1.30$ and $0.70$, respectively, relative to Typical-Typical $(\\mathrm{TT})$. RC corners available: $RC_{\\max}$ and $RC_{\\min}$, with interconnect delay multipliers of $1.40$ and $0.60$, respectively, relative to $\\mathrm{TT}$.\n\nNominal data path delays at $\\mathrm{TT}$:\n- Total gate delay: $100\\,\\mathrm{ps}$ (two gates totaling $100\\,\\mathrm{ps}$).\n- Total interconnect delay: $60\\,\\mathrm{ps}$ (three segments totaling $60\\,\\mathrm{ps}$).\n- Hence nominal total data delay: $160\\,\\mathrm{ps}$.\n\nClock network latencies are given per mode, with each latency consisting of a gate portion and an interconnect portion. The gate portion scales with device corner multipliers, and the interconnect portion scales with RC corner multipliers.\n\nMode $\\mathcal{A}$:\n- Clock period $T_{\\mathcal{A}} = 1000\\,\\mathrm{ps}$.\n- Launch clock latency $L_{\\mathcal{A},\\mathrm{TT}} = 120\\,\\mathrm{ps}$, composed of $60\\%$ gates and $40\\%$ interconnect.\n- Capture clock latency $C_{\\mathcal{A},\\mathrm{TT}} = 150\\,\\mathrm{ps}$, composed of $60\\%$ gates and $40\\%$ interconnect.\n\nMode $\\mathcal{B}$:\n- Clock period $T_{\\mathcal{B}} = 2000\\,\\mathrm{ps}$.\n- Launch clock latency $L_{\\mathcal{B},\\mathrm{TT}} = 210\\,\\mathrm{ps}$, composed of $60\\%$ gates and $40\\%$ interconnect.\n- Capture clock latency $C_{\\mathcal{B},\\mathrm{TT}} = 230\\,\\mathrm{ps}$, composed of $60\\%$ gates and $40\\%$ interconnect.\n\nCapture flip-flop setup and hold margins at $\\mathrm{TT}$ are:\n- $t_{\\mathrm{setup,TT}} = 35\\,\\mathrm{ps}$,\n- $t_{\\mathrm{hold,TT}} = 25\\,\\mathrm{ps}$.\n\nAssume that the capture flip-flop constraint parameters $t_{\\mathrm{setup}}$ and $t_{\\mathrm{hold}}$ scale with the device corner of the capture clock path in the same way as gate delays.\n\nTask:\n1. Using first principles of STA, choose corner combinations that minimize setup slack and minimize hold slack for each mode. The selection must be scientifically consistent with minimizing slack given the definitions of arrival time and required time, including consistent corner assignment for the capture clock path and its associated $t_{\\mathrm{setup}}$ or $t_{\\mathrm{hold}}$.\n2. Compute the setup slack and hold slack for Mode $\\mathcal{A}$ and Mode $\\mathcal{B}$ under the chosen worst-case corner combinations, using the device and RC multipliers provided for gates and interconnect, respectively.\n3. Finally, among the four computed slacks (setup and hold for each mode), report the single most negative slack value as the global worst case. Express the final slack value in $\\mathrm{ps}$ and round your answer to four significant figures.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and self-contained. It presents a standard, albeit simplified, Static Timing Analysis (STA) problem within an Electronic Design Automation (EDA) context, requiring the calculation of timing slacks under Multi-Corner Multi-Mode (MCMM) conditions. All necessary parameters, definitions, and constraints are provided. We may therefore proceed with a formal solution.\n\nThe core of STA is the evaluation of setup and hold timing constraints. Let us first formalize the slack equations based on the principles provided. A clock cycle begins at time $t=0$ at the clock source.\n\nThe **data arrival time**, $AT$, at the input of the capture flip-flop $\\text{FF}_{\\mathrm{C}}$ is the sum of the launch clock path latency, $L$, and the data path delay, $d_{\\mathrm{data}}$.\n$$AT = L + d_{\\mathrm{data}}$$\n\nFor a **setup check**, the data must arrive at $\\text{FF}_{\\mathrm{C}}$ at least $t_{\\mathrm{setup}}$ time *before* the capturing clock edge. The capture edge originates from the clock source at time $T$, where $T$ is the clock period, and arrives at $\\text{FF}_{\\mathrm{C}}$'s clock pin at time $T+C$. Thus, the required arrival time for setup, $RAT_{\\mathrm{setup}}$, is:\n$$RAT_{\\mathrm{setup}} = (T + C) - t_{\\mathrm{setup}}$$\nSetup slack, $S_{\\mathrm{setup}}$, is the margin by which this constraint is met:\n$$S_{\\mathrm{setup}} = RAT_{\\mathrm{setup}} - AT = (T + C - t_{\\mathrm{setup}}) - (L + d_{\\mathrm{data}})$$\n$$S_{\\mathrm{setup}} = T + C - L - d_{\\mathrm{data}} - t_{\\mathrm{setup}}$$\n\nFor a **hold check**, we ensure that the data signal from one launch event does not arrive at the capture register too early and corrupt the data being latched by that same clock event. The data being latched must remain stable for the hold time $t_{\\mathrm{hold}}$ *after* the capture clock edge arrives. Thus, the arrival time of the new data, $AT$, must be greater than or equal to the required time, $RAT_{\\mathrm{hold}}$. The required arrival time for a hold check is:\n$$RAT_{\\mathrm{hold}} = C + t_{\\mathrm{hold}}$$\nHold slack, $S_{\\mathrm{hold}}$, is conventionally defined as $AT - RAT_{\\mathrm{hold}}$ such that a non-negative value indicates the constraint is met. A negative value indicates a violation.\n$$S_{\\mathrm{hold}} = AT - RAT_{\\mathrm{hold}} = (L + d_{\\mathrm{data}}) - (C + t_{\\mathrm{hold}})$$\n$$S_{\\mathrm{hold}} = L + d_{\\mathrm{data}} - C - t_{\\mathrm{hold}}$$\n\nTo find the worst-case (minimum) slack, we must select the Process-Voltage-Temperature (PVT) and Resistance-Capacitance (RC) corners that pessimistically affect each calculation. The multipliers are:\n-   Device Slow-Slow (SS): $k_{dev,SS} = 1.30$\n-   Device Fast-Fast (FF): $k_{dev,FF} = 0.70$\n-   RC Maximum ($RC_{\\max}$): $k_{RC,max} = 1.40$\n-   RC Minimum ($RC_{\\min}$): $k_{RC,min} = 0.60$\nWe define a \"slow corner\" combination as $(\\mathrm{SS}, RC_{\\max})$ and a \"fast corner\" as $(\\mathrm{FF}, RC_{\\min})$.\n\n**Worst-Case Corner Selection for Setup Slack:**\nTo minimize $S_{\\mathrm{setup}} = T + C - L - d_{\\mathrm{data}} - t_{\\mathrm{setup}}$, we must maximize $L$, $d_{\\mathrm{data}}$, and $t_{\\mathrm{setup}}$, and minimize $C$. This corresponds to a slow launch path and data path, and a fast capture path.\n-   **Setup Corners**: Launch/Data Path = Slow $(\\mathrm{SS}, RC_{\\max})$; Capture Path = Fast $(\\mathrm{FF}, RC_{\\min})$.\n\n**Worst-Case Corner Selection for Hold Slack:**\nTo minimize $S_{\\mathrm{hold}} = L + d_{\\mathrm{data}} - C - t_{\\mathrm{hold}}$, we must minimize $L$ and $d_{\\mathrm{data}}$, and maximize $C$ and $t_{\\mathrm{hold}}$. This corresponds to a fast launch path and data path, and a slow capture path.\n-   **Hold Corners**: Launch/Data Path = Fast $(\\mathrm{FF}, RC_{\\min})$; Capture Path = Slow $(\\mathrm{SS}, RC_{\\max})$.\n\nWe now proceed with the calculations for each mode.\nNominal (TT) values:\n-   Data path gate delay $d_{\\mathrm{gate,TT}} = 100\\,\\mathrm{ps}$; interconnect delay $d_{\\mathrm{ic,TT}} = 60\\,\\mathrm{ps}$.\n-   Setup time $t_{\\mathrm{setup,TT}} = 35\\,\\mathrm{ps}$; hold time $t_{\\mathrm{hold,TT}} = 25\\,\\mathrm{ps}$.\n\nData path delays at corners:\n-   Slow data path: $d_{\\mathrm{data,s}} = k_{dev,SS} d_{\\mathrm{gate,TT}} + k_{RC,max} d_{\\mathrm{ic,TT}} = 1.30 \\times 100 + 1.40 \\times 60 = 130 + 84 = 214\\,\\mathrm{ps}$.\n-   Fast data path: $d_{\\mathrm{data,f}} = k_{dev,FF} d_{\\mathrm{gate,TT}} + k_{RC,min} d_{\\mathrm{ic,TT}} = 0.70 \\times 100 + 0.60 \\times 60 = 70 + 36 = 106\\,\\mathrm{ps}$.\n\nConstraint times at corners:\n-   Fast setup time: $t_{\\mathrm{setup,f}} = k_{dev,FF} t_{\\mathrm{setup,TT}} = 0.70 \\times 35 = 24.5\\,\\mathrm{ps}$.\n-   Slow hold time: $t_{\\mathrm{hold,s}} = k_{dev,SS} t_{\\mathrm{hold,TT}} = 1.30 \\times 25 = 32.5\\,\\mathrm{ps}$.\n\n**Analysis for Mode $\\mathcal{A}$ ($T_{\\mathcal{A}} = 1000\\,\\mathrm{ps}$)**\n-   $L_{\\mathcal{A},\\mathrm{TT}} = 120\\,\\mathrm{ps}$ ($72\\,\\mathrm{ps}$ gate, $48\\,\\mathrm{ps}$ interconnect).\n-   $C_{\\mathcal{A},\\mathrm{TT}} = 150\\,\\mathrm{ps}$ ($90\\,\\mathrm{ps}$ gate, $60\\,\\mathrm{ps}$ interconnect).\n-   Slow launch latency $L_{\\mathcal{A},\\mathrm{s}} = 1.30 \\times 72 + 1.40 \\times 48 = 93.6 + 67.2 = 160.8\\,\\mathrm{ps}$.\n-   Fast capture latency $C_{\\mathcal{A},\\mathrm{f}} = 0.70 \\times 90 + 0.60 \\times 60 = 63 + 36 = 99\\,\\mathrm{ps}$.\n-   Fast launch latency $L_{\\mathcal{A},\\mathrm{f}} = 0.70 \\times 72 + 0.60 \\times 48 = 50.4 + 28.8 = 79.2\\,\\mathrm{ps}$.\n-   Slow capture latency $C_{\\mathcal{A},\\mathrm{s}} = 1.30 \\times 90 + 1.40 \\times 60 = 117 + 84 = 201\\,\\mathrm{ps}$.\n\nSetup Slack for Mode $\\mathcal{A}$:\n$S_{\\mathrm{setup},\\mathcal{A}} = T_{\\mathcal{A}} + C_{\\mathcal{A},\\mathrm{f}} - L_{\\mathcal{A},\\mathrm{s}} - d_{\\mathrm{data,s}} - t_{\\mathrm{setup,f}}$\n$S_{\\mathrm{setup},\\mathcal{A}} = 1000 + 99 - 160.8 - 214 - 24.5 = 699.7\\,\\mathrm{ps}$.\n\nHold Slack for Mode $\\mathcal{A}$:\n$S_{\\mathrm{hold},\\mathcal{A}} = L_{\\mathcal{A},\\mathrm{f}} + d_{\\mathrm{data,f}} - C_{\\mathcal{A},\\mathrm{s}} - t_{\\mathrm{hold,s}}$\n$S_{\\mathrm{hold},\\mathcal{A}} = 79.2 + 106 - 201 - 32.5 = 185.2 - 233.5 = -48.3\\,\\mathrm{ps}$.\n\n**Analysis for Mode $\\mathcal{B}$ ($T_{\\mathcal{B}} = 2000\\,\\mathrm{ps}$)**\n-   $L_{\\mathcal{B},\\mathrm{TT}} = 210\\,\\mathrm{ps}$ ($126\\,\\mathrm{ps}$ gate, $84\\,\\mathrm{ps}$ interconnect).\n-   $C_{\\mathcal{B},\\mathrm{TT}} = 230\\,\\mathrm{ps}$ ($138\\,\\mathrm{ps}$ gate, $92\\,\\mathrm{ps}$ interconnect).\n-   Slow launch latency $L_{\\mathcal{B},\\mathrm{s}} = 1.30 \\times 126 + 1.40 \\times 84 = 163.8 + 117.6 = 281.4\\,\\mathrm{ps}$.\n-   Fast capture latency $C_{\\mathcal{B},\\mathrm{f}} = 0.70 \\times 138 + 0.60 \\times 92 = 96.6 + 55.2 = 151.8\\,\\mathrm{ps}$.\n-   Fast launch latency $L_{\\mathcal{B},\\mathrm{f}} = 0.70 \\times 126 + 0.60 \\times 84 = 88.2 + 50.4 = 138.6\\,\\mathrm{ps}$.\n-   Slow capture latency $C_{\\mathcal{B},\\mathrm{s}} = 1.30 \\times 138 + 1.40 \\times 92 = 179.4 + 128.8 = 308.2\\,\\mathrm{ps}$.\n\nSetup Slack for Mode $\\mathcal{B}$:\n$S_{\\mathrm{setup},\\mathcal{B}} = T_{\\mathcal{B}} + C_{\\mathcal{B},\\mathrm{f}} - L_{\\mathcal{B},\\mathrm{s}} - d_{\\mathrm{data,s}} - t_{\\mathrm{setup,f}}$\n$S_{\\mathrm{setup},\\mathcal{B}} = 2000 + 151.8 - 281.4 - 214 - 24.5 = 1631.9\\,\\mathrm{ps}$.\n\nHold Slack for Mode $\\mathcal{B}$:\n$S_{\\mathrm{hold},\\mathcal{B}} = L_{\\mathcal{B},\\mathrm{f}} + d_{\\mathrm{data,f}} - C_{\\mathcal{B},\\mathrm{s}} - t_{\\mathrm{hold,s}}$\n$S_{\\mathrm{hold},\\mathcal{B}} = 138.6 + 106 - 308.2 - 32.5 = 244.6 - 340.7 = -96.1\\,\\mathrm{ps}$.\n\n**Conclusion**\nThe four computed slack values are:\n-   $S_{\\mathrm{setup},\\mathcal{A}} = 699.7\\,\\mathrm{ps}$\n-   $S_{\\mathrm{hold},\\mathcal{A}} = -48.3\\,\\mathrm{ps}$\n-   $S_{\\mathrm{setup},\\mathcal{B}} = 1631.9\\,\\mathrm{ps}$\n-   $S_{\\mathrm{hold},\\mathcal{B}} = -96.1\\,\\mathrm{ps}$\n\nThe single most negative slack value is the minimum of these values, which is $-96.1\\,\\mathrm{ps}$. This represents the global worst-case timing violation for the specified path across both modes and all corners. Rounding this value to four significant figures gives $-96.10\\,\\mathrm{ps}$.",
            "answer": "$$\\boxed{-96.10}$$"
        },
        {
            "introduction": "Moving from analysis to optimization, this final practice addresses a classic challenge in timing closure: fixing a timing violation in one scenario can often create a new one in another. Here, you will explore the trade-off between hold time, which is often fixed by adding delay, and setup time, which is worsened by the same delay, especially across different process corners. By formulating this as a linear programming problem, you will implement a strategy to find an optimal delay adjustment that maximizes the worst-case slack, providing a glimpse into the sophisticated algorithms used in modern EDA tools for automated timing closure .",
            "id": "4284055",
            "problem": "Consider a synchronous register-to-register path analyzed under Multi-Corner Multi-Mode (MCMM) timing within Electronic Design Automation (EDA). Multi-corner refers to distinct Process-Voltage-Temperature (PVT) views such as Fast-Fast (FF) and Slow-Slow (SS). Multi-mode refers to distinct clocking modes with different clock periods. For a single combinational path between a launching register and a capturing register, define the maximum (worst-case) and minimum (best-case) data path delays in corner $c$ as $D_{\\max}^{(c)}$ and $D_{\\min}^{(c)}$, respectively. Define the per-corner setup margin (including register setup time, skew, and uncertainty lumped together) as $U^{(c)}$, and the per-corner hold requirement (including register hold time, skew, and uncertainty) as $H^{(c)}$. For a mode $m$ with clock period $T^{(m)}$, the setup slack in corner $c$ is given by $T^{(m)} - (D_{\\max}^{(c)} + \\Delta_{\\max}^{(c)}) - U^{(c)}$, and the hold slack in corner $c$ is given by $(D_{\\min}^{(c)} + \\Delta_{\\min}^{(c)}) - H^{(c)}$, where $\\Delta_{\\max}^{(c)}$ and $\\Delta_{\\min}^{(c)}$ are the changes induced in the path delay by an added tunable delay element of magnitude $x \\ge 0$.\n\nAssume a first-order linear delay sensitivity model per corner, where the added delay element of magnitude $x$ changes the minimum delay and maximum delay as $\\Delta_{\\min}^{(c)} = \\alpha^{(c)} x$ and $\\Delta_{\\max}^{(c)} = \\beta^{(c)} x$, with sensitivities $\\alpha^{(c)} \\ge 0$ and $\\beta^{(c)} \\ge 0$. The physical rationale is that the added element slows the path; in a fast corner, it helps hold by increasing $D_{\\min}^{(c)}$ but simultaneously worsens setup in a slow corner by increasing $D_{\\max}^{(c)}$.\n\nDefine the worst-case slack $t$ across all corners and modes as the minimum of all setup and hold slacks. The optimization objective is to choose $x \\ge 0$ to maximize $t$, balancing hold improvements against setup degradations. Formulate this as a linear program that maximizes $t$ subject to linear inequalities derived from setup and hold slack definitions across all corners and modes.\n\nYour task is to implement a program that, for each provided test case, solves for the optimal added delay $x$ (in nanoseconds) and the corresponding maximized worst-case slack $t$ (in nanoseconds) using linear programming. Use the following test suite, with parameters expressed in nanoseconds for all delays and clock periods. All numeric answers must be expressed in nanoseconds (ns) and rounded to six decimals.\n\nTest Case 1 (happy path where optimal $x$ is at a balance point):\n- Corners: $c \\in \\{ \\text{FF}, \\text{SS} \\}$.\n- Modes: $m \\in \\{ M_1, M_2 \\}$ with $T^{(M_1)} = 1.0$, $T^{(M_2)} = 0.8$.\n- Base delays and margins:\n  - $D_{\\min}^{(\\text{FF})} = 0.07$, $H^{(\\text{FF})} = 0.08$.\n  - $D_{\\min}^{(\\text{SS})} = 0.12$, $H^{(\\text{SS})} = 0.10$.\n  - $D_{\\max}^{(\\text{FF})} = 0.42$, $U^{(\\text{FF})} = 0.06$.\n  - $D_{\\max}^{(\\text{SS})} = 0.62$, $U^{(\\text{SS})} = 0.08$.\n- Sensitivities:\n  - $\\alpha^{(\\text{FF})} = 1.0$, $\\alpha^{(\\text{SS})} = 1.2$.\n  - $\\beta^{(\\text{FF})} = 0.8$, $\\beta^{(\\text{SS})} = 1.4$.\n\nTest Case 2 (boundary case where the best solution is $x = 0$):\n- Corners: $c \\in \\{ \\text{FF}, \\text{SS} \\}$.\n- Modes: $m \\in \\{ M_1, M_2 \\}$ with $T^{(M_1)} = 1.0$, $T^{(M_2)} = 0.7$.\n- Base delays and margins:\n  - $D_{\\min}^{(\\text{FF})} = 0.20$, $H^{(\\text{FF})} = 0.05$.\n  - $D_{\\min}^{(\\text{SS})} = 0.25$, $H^{(\\text{SS})} = 0.06$.\n  - $D_{\\max}^{(\\text{FF})} = 0.40$, $U^{(\\text{FF})} = 0.05$.\n  - $D_{\\max}^{(\\text{SS})} = 0.60$, $U^{(\\text{SS})} = 0.05$.\n- Sensitivities:\n  - $\\alpha^{(\\text{FF})} = 1.1$, $\\alpha^{(\\text{SS})} = 1.3$.\n  - $\\beta^{(\\text{FF})} = 1.0$, $\\beta^{(\\text{SS})} = 1.5$.\n\nTest Case 3 (edge case where even the balanced optimum yields negative worst-case slack):\n- Corners: $c \\in \\{ \\text{FF}, \\text{SS} \\}$.\n- Modes: $m \\in \\{ M_1, M_2 \\}$ with $T^{(M_1)} = 1.10$, $T^{(M_2)} = 0.85$.\n- Base delays and margins:\n  - $D_{\\min}^{(\\text{FF})} = 0.02$, $H^{(\\text{FF})} = 0.09$.\n  - $D_{\\min}^{(\\text{SS})} = 0.10$, $H^{(\\text{SS})} = 0.11$.\n  - $D_{\\max}^{(\\text{FF})} = 0.45$, $U^{(\\text{FF})} = 0.06$.\n  - $D_{\\max}^{(\\text{SS})} = 0.70$, $U^{(\\text{SS})} = 0.08$.\n- Sensitivities:\n  - $\\alpha^{(\\text{FF})} = 1.0$, $\\alpha^{(\\text{SS})} = 1.3$.\n  - $\\beta^{(\\text{FF})} = 1.1$, $\\beta^{(\\text{SS})} = 1.6$.\n\nFormulation details to implement:\n- Decision variables are $x \\ge 0$ and $t \\in \\mathbb{R}$.\n- For each corner $c$, enforce hold slack constraints:\n  - $D_{\\min}^{(c)} + \\alpha^{(c)} x - H^{(c)} \\ge t$.\n- For each corner $c$ and each mode $m$, enforce setup slack constraints:\n  - $T^{(m)} - D_{\\max}^{(c)} - \\beta^{(c)} x - U^{(c)} \\ge t$.\n- Objective: maximize $t$.\n\nProgram requirements:\n- Implement the optimization using linear programming.\n- For each test case, compute the optimal $x$ and corresponding maximized worst-case slack $t$, both in nanoseconds.\n- Round each numeric output to six decimals.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, one per test case, in the format $[[x_1,t_1],[x_2,t_2],[x_3,t_3]]$. Units are nanoseconds, and no unit symbols should be printed in the output line itself; the values must be interpreted in nanoseconds.\n\nAnswer all numeric values in nanoseconds (ns). Angles are not involved. Percentages are not involved.",
            "solution": "The problem requires finding an optimal value for an added tunable delay, $x \\ge 0$, to maximize the worst-case timing slack, $t$, in a digital circuit path across multiple process corners and operational modes. This is a classic optimization problem that can be formulated and solved as a Linear Program (LP).\n\nFirst, we define the slack for setup and hold timing checks. The setup slack for a given corner $c$ and mode $m$ is given by:\n$$S_{\\text{setup}}^{(c,m)} = T^{(m)} - (D_{\\max}^{(c)} + \\Delta_{\\max}^{(c)}) - U^{(c)}$$\nThe hold slack for a given corner $c$ is given by:\n$$S_{\\text{hold}}^{(c)} = (D_{\\min}^{(c)} + \\Delta_{\\min}^{(c)}) - H^{(c)}$$\nwhere $T^{(m)}$ is the clock period for mode $m$, $D_{\\max}^{(c)}$ and $D_{\\min}^{(c)}$ are the maximum and minimum path delays for corner $c$, $U^{(c)}$ and $H^{(c)}$ are the setup and hold margin requirements for corner $c$, and $\\Delta_{\\max}^{(c)}$ and $\\Delta_{\\min}^{(c)}$ are the changes in delay due to the added delay element of magnitude $x$.\n\nThe problem states a linear delay sensitivity model, where the delay changes are proportional to $x$:\n$$\\Delta_{\\max}^{(c)} = \\beta^{(c)} x$$\n$$\\Delta_{\\min}^{(c)} = \\alpha^{(c)} x$$\nwith non-negative sensitivities $\\alpha^{(c)} \\ge 0$ and $\\beta^{(c)} \\ge 0$. Substituting this model into the slack equations, we get:\n$$S_{\\text{setup}}^{(c,m)} = T^{(m)} - D_{\\max}^{(c)} - U^{(c)} - \\beta^{(c)} x$$\n$$S_{\\text{hold}}^{(c)} = D_{\\min}^{(c)} - H^{(c)} + \\alpha^{(c)} x$$\n\nThe worst-case slack, $t$, is defined as the minimum of all these individual slack values across all corners $c$ and modes $m$:\n$$t = \\min_{c,m} \\left\\{ S_{\\text{setup}}^{(c,m)}, S_{\\text{hold}}^{(c)} \\right\\}$$\nThe optimization goal is to choose $x \\ge 0$ to maximize $t$. This is a maximin problem:\n$$\\max_{x \\ge 0} \\left( \\min_{c,m} \\left\\{ T^{(m)} - D_{\\max}^{(c)} - U^{(c)} - \\beta^{(c)} x, \\quad D_{\\min}^{(c)} - H^{(c)} + \\alpha^{(c)} x \\right\\} \\right)$$\nThis type of problem can be directly converted into a Linear Program. We introduce $t$ as a new decision variable that we aim to maximize. The condition that $t$ must be the minimum of all slacks is enforced by a set of constraints stating that $t$ must be less than or equal to every individual slack value.\n\nThe resulting LP formulation is as follows:\n\n**Decision Variables:**\nThe variables to be determined are the worst-case slack $t \\in \\mathbb{R}$ and the added delay $x \\in \\mathbb{R}$.\n\n**Objective Function:**\nThe objective is to maximize the worst-case slack $t$:\n$$\\text{Maximize} \\quad t$$\n\n**Constraints:**\nThe constraints ensure that $t$ is indeed the minimum slack, and that $x$ is physically realizable (non-negative).\n1.  For each corner $c$ and mode $m$, the setup slack constraint is:\n    $$t \\le S_{\\text{setup}}^{(c,m)} \\implies t \\le T^{(m)} - D_{\\max}^{(c)} - U^{(c)} - \\beta^{(c)} x$$\n2.  For each corner $c$, the hold slack constraint is:\n    $$t \\le S_{\\text{hold}}^{(c)} \\implies t \\le D_{\\min}^{(c)} - H^{(c)} + \\alpha^{(c)} x$$\n3.  The added delay must be non-negative:\n    $$x \\ge 0$$\n\nTo use a standard LP solver, which typically minimizes a function subject to constraints of the form $\\mathbf{A}\\mathbf{z} \\le \\mathbf{b}$, we reformat the problem. Maximizing $t$ is equivalent to minimizing $-t$. Let the vector of decision variables be $\\mathbf{z} = [t, x]^T$. The objective is to minimize $\\mathbf{c}^T \\mathbf{z}$ where the cost vector is $\\mathbf{c} = [-1, 0]^T$.\n\nThe constraints are rearranged to group variables on the left-hand side:\n$$t + \\beta^{(c)} x \\le T^{(m)} - D_{\\max}^{(c)} - U^{(c)} \\quad (\\text{for all } c, m)$$\n$$t - \\alpha^{(c)} x \\le D_{\\min}^{(c)} - H^{(c)} \\quad (\\text{for all } c)$$\nThe non-negativity constraint $x \\ge 0$ can be handled by setting a lower bound on $x$.\n\nFor each test case, we construct the matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ from these inequalities, along with the cost vector $\\mathbf{c}$ and variable bounds. An LP solver is then used to find the optimal values of $t$ and $x$ that satisfy all conditions. For an instance with $N_c$ corners and $N_m$ modes, there will be $N_c \\times N_m$ setup constraints and $N_c$ hold constraints, resulting in a total of $N_c \\cdot (N_m + 1)$ inequality constraints on the two variables $t$ and $x$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the timing optimization problem for a series of test cases\n    using linear programming.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            \"corners\": [\"FF\", \"SS\"],\n            \"modes\": {\"M1\": 1.0, \"M2\": 0.8},\n            \"D_min\": {\"FF\": 0.07, \"SS\": 0.12},\n            \"H\": {\"FF\": 0.08, \"SS\": 0.10},\n            \"D_max\": {\"FF\": 0.42, \"SS\": 0.62},\n            \"U\": {\"FF\": 0.06, \"SS\": 0.08},\n            \"alpha\": {\"FF\": 1.0, \"SS\": 1.2},\n            \"beta\": {\"FF\": 0.8, \"SS\": 1.4},\n        },\n        # Test Case 2 (boundary case x=0)\n        {\n            \"corners\": [\"FF\", \"SS\"],\n            \"modes\": {\"M1\": 1.0, \"M2\": 0.7},\n            \"D_min\": {\"FF\": 0.20, \"SS\": 0.25},\n            \"H\": {\"FF\": 0.05, \"SS\": 0.06},\n            \"D_max\": {\"FF\": 0.40, \"SS\": 0.60},\n            \"U\": {\"FF\": 0.05, \"SS\": 0.05},\n            \"alpha\": {\"FF\": 1.1, \"SS\": 1.3},\n            \"beta\": {\"FF\": 1.0, \"SS\": 1.5},\n        },\n        # Test Case 3 (edge case, negative slack)\n        {\n            \"corners\": [\"FF\", \"SS\"],\n            \"modes\": {\"M1\": 1.10, \"M2\": 0.85},\n            \"D_min\": {\"FF\": 0.02, \"SS\": 0.10},\n            \"H\": {\"FF\": 0.09, \"SS\": 0.11},\n            \"D_max\": {\"FF\": 0.45, \"SS\": 0.70},\n            \"U\": {\"FF\": 0.06, \"SS\": 0.08},\n            \"alpha\": {\"FF\": 1.0, \"SS\": 1.3},\n            \"beta\": {\"FF\": 1.1, \"SS\": 1.6},\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A_ub = []\n        b_ub = []\n\n        # Objective function: maximize t is min -t. Variables are [t, x].\n        c = [-1, 0]\n\n        # Hold constraints: t - alpha*x <= D_min - H\n        for corner in case[\"corners\"]:\n            A_ub.append([1, -case[\"alpha\"][corner]])\n            b_ub.append(case[\"D_min\"][corner] - case[\"H\"][corner])\n\n        # Setup constraints: t + beta*x <= T - D_max - U\n        for corner in case[\"corners\"]:\n            for mode, T_m in case[\"modes\"].items():\n                A_ub.append([1, case[\"beta\"][corner]])\n                b_ub.append(T_m - case[\"D_max\"][corner] - case[\"U\"][corner])\n        \n        # Bounds for variables [t, x]: t is free, x >= 0\n        bounds = [(None, None), (0, None)]\n\n        # Solve the linear program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.success:\n            # res.x contains the optimal values for [t, x]\n            t_opt, x_opt = res.x\n            # Round to six decimal places as required\n            x_out = round(x_opt, 6)\n            t_out = round(t_opt, 6)\n            results.append([x_out, t_out])\n        else:\n            # Handle cases where the solver fails, though not expected for these problems\n            results.append([float('nan'), float('nan')])\n    \n    # Format the final output string exactly as specified: [[x1,t1],[x2,t2],...]\n    # Using repr() and replacing space ensures comma-separation without spaces.\n    # Note: str() on a list adds spaces, so we build the string representation manually.\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}