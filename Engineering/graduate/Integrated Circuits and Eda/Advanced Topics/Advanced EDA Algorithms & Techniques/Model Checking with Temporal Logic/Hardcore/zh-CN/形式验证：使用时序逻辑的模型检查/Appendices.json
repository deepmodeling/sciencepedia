{
    "hands_on_practices": [
        {
            "introduction": "模型检查的第一步是将一个具体系统的行为抽象成一个精确的数学模型。本练习将通过一个常见的硬件设计场景——同步握手协议，指导你构建一个Kripke结构，这是模型检查中最核心的状态变迁系统。通过在这个结构上评估一个关键的活性属性（liveness property）$AF\\;ack$，你将掌握从系统描述到形式化验证的基本流程 。",
            "id": "4282897",
            "problem": "考虑一个在电子设计自动化（EDA）背景下的、用于单请求/单应答握手的同步寄存器传输级（RTL）控制自动机。该握手遵循广泛使用的同步协议：当请求方发出请求时，响应方最终会发出应答；然后请求方撤销请求，响应方随后撤销应答，使系统返回空闲状态。系统是时钟同步的，状态转换发生在时钟边沿。原子命题是 $req$ 和 $ack$，表示由控制器驱动的请求和应答信号的布尔值。假设环境可能非确定性地选择开始一次握手，并且响应方可能非确定性地延迟应答。\n\n从协议规则和同步语义（每个周期，下一状态由当前状态和输入决定，所有信号在时钟边沿采样）出发，构建一个具有四个不同控制状态的最小确定性控制自动机，该自动机在不违反协议顺序的情况下实现握手。使用以下与握手协议一致的状态：\n- 空闲（`Idle`）（$req$ 为低，$ack$ 为低），\n- 请求（`Request`）（$req$ 为高，$ack$ 为低），\n- 已应答（`Acknowledged`）（$req$ 为高，$ack$ 为高），\n- 释放（`Release`）（$req$ 为低，$ack$ 为高）。\n\n将此控制器建模为一个 Kripke 结构 $K = (S, R, L)$，其中 $S$ 是有限的状态集合，$R \\subseteq S \\times S$ 是全转移关系（每个状态至少有一个后继状态），$L: S \\to 2^{\\{req, ack\\}}$ 为每个状态标记在该状态下为真的原子命题集合。使用从同步握手正确性和非确定性环境行为中导出的以下转移约束：\n- 从空闲（`Idle`）状态，下一周期要么保持空闲，要么发出 $req$ 进入请求（`Request`）状态。\n- 在请求（`Request`）状态，下一周期要么保持在请求状态，要么由响应方置位 $ack$ 进入已应答（`Acknowledged`）状态。\n- 在已应答（`Acknowledged`）状态，下一周期要么保持在已应答状态，要么由请求方撤销 $req$ 进入释放（`Release`）状态。\n- 在释放（`Release`）状态，下一周期要么保持在释放状态，要么由响应方撤销 $ack$ 返回空闲（`Idle`）状态。\n\n根据每个状态的信号值，用 $\\{req, ack\\}$ 的适当子集来标记它。基于此 Kripke 结构，考虑计算树逻辑（CTL）属性 $A F\\; ack$，其含义是“在所有路径上，最终 $ack$ 成立”。仅使用 Kripke 结构和 CTL 语义的标准定义，确定满足 $K, s \\models A F\\; ack$ 的状态 $s \\in S$ 的数量。将你的最终答案表示为单个整数。无需四舍五入，不涉及单位。",
            "solution": "该问题要求在一个表示同步握手协议的 Kripke 结构上，对一个计算树逻辑（CTL）公式进行求值。第一步是根据所提供的描述来形式化定义这个 Kripke 结构。\n\nKripke 结构是一个元组 $K = (S, R, L)$，其中 $S$ 是一个状态集合，$R \\subseteq S \\times S$ 是一个转移关系，$L: S \\to 2^{AP}$ 是一个标记函数，它将状态映射到来自集合 $AP$ 的为真的原子命题集合。\n\n**1. 形式化 Kripke 结构**\n\n**状态 ($S$):**\n问题指定了四个不同的控制状态。我们如下表示它们：\n- $s_I$：`Idle`（空闲）状态。\n- $s_Q$：`Request`（请求）状态。\n- $s_A$：`Acknowledged`（已应答）状态。\n- $s_R$：`Release`（释放）状态。\n因此，状态集合为 $S = \\{s_I, s_Q, s_A, s_R\\}$。\n\n**原子命题 ($AP$) 和标记函数 ($L$):**\n原子命题给定为 $AP = \\{req, ack\\}$。标记函数 $L$ 由每个状态中的信号值确定：\n- `Idle`（空闲）（$req$ 为低，$ack$ 为低）：$L(s_I) = \\emptyset$。\n- `Request`（请求）（$req$ 为高，$ack$ 为低）：$L(s_Q) = \\{req\\}$。\n- `Acknowledged`（已应答）（$req$ 为高，$ack$ 为高）：$L(s_A) = \\{req, ack\\}$。\n- `Release`（释放）（$req$ 为低，$ack$ 为高）：$L(s_R) = \\{ack\\}$。\n\n**转移关系 ($R$):**\n转移约束定义了状态图的边。该关系必须是全的，意味着每个状态都有一个出向转移。\n- 从 $s_I$（`Idle`），系统可以保持 `Idle` 状态或转移到 `Request` 状态。这定义了转移 $(s_I, s_I) \\in R$ 和 $(s_I, s_Q) \\in R$。\n- 从 $s_Q$（`Request`），系统可以保持在 `Request` 状态或转移到 `Acknowledged` 状态。这定义了转移 $(s_Q, s_Q) \\in R$ 和 $(s_Q, s_A) \\in R$。\n- 从 $s_A$（`Acknowledged`），系统可以保持 `Acknowledged` 状态或转移到 `Release` 状态。这定义了转移 $(s_A, s_A) \\in R$ 和 $(s_A, s_R) \\in R$。\n- 从 $s_R$（`Release`），系统可以保持在 `Release` 状态或转移到 `Idle` 状态。这定义了转移 $(s_R, s_R) \\in R$ 和 $(s_R, s_I) \\in R$。\n\n完整的转移关系是 $R = \\{(s_I, s_I), (s_I, s_Q), (s_Q, s_Q), (s_Q, s_A), (s_A, s_A), (s_A, s_R), (s_R, s_R), (s_R, s_I)\\}$。这个关系是全的，因为每个状态至少有一个后继状态。每个状态的自环对应于问题中提到的非确定性延迟（例如，环境可能不发出 `req`，或者响应方可能延迟 `ack`）。\n\n**2. 对 CTL 属性 $AF\\;ack$ 求值**\n\n需要求值的 CTL 公式是 $AF\\;ack$。该公式的语义是：“对于从给定状态开始的所有计算路径，路径上存在某个未来状态，在该状态下命题 $ack$ 为真。”\n\n如果 $p \\in L(s)$，则状态 $s$ 满足命题 $p$（记为 $s \\models p$）。\n首先，让我们确定满足命题 $ack$ 的状态集合。\n根据标记函数 $L$：\n- $s_A \\models ack$ 因为 $ack \\in L(s_A) = \\{req, ack\\}$。\n- $s_R \\models ack$ 因为 $ack \\in L(s_R) = \\{ack\\}$。\n状态 $s_I$ 和 $s_Q$ 不满足 $ack$，因为 $ack \\notin L(s_I)$ 且 $ack \\notin L(s_Q)$。\n令 $S_{ack} = \\{s \\in S \\mid s \\models ack\\} = \\{s_A, s_R\\}$。\n\n现在，我们必须检查每个状态 $s \\in S$ 是否满足 $K, s \\models AF\\;ack$。如果从 $s_0 = s$ 开始的每条无限路径 $\\pi = (s_0, s_1, s_2, \\dots)$ 都包含至少一个状态 $s_i$ 使得 $s_i \\in S_{ack}$，则状态 $s$ 满足 $AF\\;ack$。\n\n让我们分析每个状态：\n\n- **状态 $s_A$ (`Acknowledged`):**\n任何从 $s_A$ 开始的路径都以 $s_A$ 作为其第一个状态。由于 $s_A \\models ack$，所以“最终 $ack$”的条件在路径的一开始（时间为0）就得到满足。这对所有从 $s_A$ 开始的路径都成立。因此，$K, s_A \\models AF\\;ack$。\n\n- **状态 $s_R$ (`Release`):**\n类似地，任何从 $s_R$ 开始的路径都以 $s_R$ 作为其第一个状态。由于 $s_R \\models ack$，条件立即得到满足。这对所有从 $s_R$ 开始的路径都成立。因此，$K, s_R \\models AF\\;ack$。\n\n- **状态 $s_I$ (`Idle`):**\n从状态 $s_I$ 出发，有两种可能的转移：到 $s_I$ 或到 $s_Q$。由于非确定性选择，可以通过重复选择自环转移 $(s_I, s_I)$ 来形成一条有效的计算路径。这得到无限路径 $\\pi = (s_I, s_I, s_I, \\dots)$。对于这条路径上的每个状态 $s_i$，都有 $s_i = s_I$，而我们知道 $s_I \\not\\models ack$。因此，我们找到了一个从 $s_I$ 开始的路径，在该路径上 $ack$ 永远不为真。因为 $A$（“对所有路径”）量词未被满足，该属性不成立。因此，$K, s_I \\not\\models AF\\;ack$。\n\n- **状态 $s_Q$ (`Request`):**\n从状态 $s_Q$ 出发，有两种可能的转移：到 $s_Q$ 或到 $s_A$。与 `Idle` 状态类似，可以通过重复选择自环转移 $(s_Q, s_Q)$ 来形成一条有效的计算路径。这得到无限路径 $\\pi = (s_Q, s_Q, s_Q, \\dots)$。对于这条路径上的每个状态 $s_i$，都有 $s_i = s_Q$，而我们知道 $s_Q \\not\\models ack$。这条路径代表了响应方永不置位应答信号的场景。由于我们找到了一个从 $s_Q$ 开始且永远不会到达 $ack$ 为真状态的路径，因此 $A$ 量词未被满足。因此，$K, s_Q \\not\\models AF\\;ack$。\n\n**结论**\n满足属性 $K, s \\models AF\\;ack$ 的状态集合 $s$ 是 $\\{s_A, s_R\\}$。问题要求的是这类状态的*数量*。该集合中有两个状态。\n满足 $AF\\;ack$ 的状态数量是 $2$。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "在系统验证中，一个核心问题是系统是否可能达到某个特定状态，无论是期望的目标状态还是不希望的错误状态。这个练习将探讨这一“可达性”问题，它在时序逻辑中通常用 $EF\\, p$ 公式来表达。你将对一个简化的流水线模型应用前向可达性分析，以确定到达目标状态所需的最少步骤数，从而加深对状态空间搜索算法的理解 。",
            "id": "4282921",
            "problem": "考虑一个在电子设计自动化（EDA）中使用的同步有限状态抽象，用于为一个具有单令牌流控制的 $n$ 级流水线建模。该系统有两个状态变量：一个整数位置索引 $i \\in \\{0,1,\\ldots,n-1\\}$，指示当前哪个流水线阶段持有令牌（在硬件中编码为独热寄存器），以及一个停顿位 $s \\in \\{0,1\\}$。在每个时钟沿，环境提供一个不确定的输入 $u \\in \\{0,1\\}$，该输入设置下一个停顿位。转移关系由下一状态变量 $i'$ 和 $s'$ 的以下规则定义：\n- 如果 $s=1$，则 $i'=i$。\n- 如果 $s=0$，则 $i'=(i+1) \\bmod n$。\n- 环境在每一步任意选择 $u$，并且 $s'=u$。\n\n初始状态由 $i=0$ 和 $s=1$ 给出。令 $p$ 为命题 $i=j$，其中 $j$ 是一个满足 $1 \\le j \\le n-1$ 的固定整数。在计算树逻辑（CTL）中解释 $p$，其中 $p$ 在一个状态成立当且仅当该状态的位置索引等于 $j$。CTL 算子 $\\mathrm{E}\\mathrm{F}$ 表示“存在一条路径最终会……”。在 CTL 的标准语义下，$\\mathrm{E}\\mathrm{F}\\, p$ 在初始状态成立，当且仅当存在一条从初始状态出发、沿着转移关系的路径，使得在未来的某个时刻 $p$ 成立。\n\n从初始状态开始应用前向可达性分析，来刻画在恰好 $k$ 步内可达的状态集（作为 $k$ 的函数），并用此来判断 $\\mathrm{E}\\mathrm{F}\\, p$ 是否从初始状态成立。如果成立，确定最小的 $k$，使得一个满足 $p$ 的状态在恰好 $k$ 步内可达。用 $j$ 和 $n$ 的封闭形式符号表达式表示您的最终答案。无需舍入。最终答案必须是单个表达式。",
            "solution": "该问题要求验证一个模型检测问题陈述的有效性，如果有效，则确定达到满足给定属性的状态所需的最小步数 $k$。\n\n### 第 1 步：提取已知条件\n-   **系统**：一个 $n$ 级流水线模型。\n-   **状态空间**：一个状态是一个对 $(i, s)$，其中位置索引为 $i \\in \\{0, 1, \\ldots, n-1\\}$，停顿位为 $s \\in \\{0, 1\\}$。\n-   **输入**：一个不确定的输入 $u \\in \\{0, 1\\}$。\n-   **转移关系**：给定当前状态 $(i, s)$ 和输入 $u$，下一个状态 $(i', s')$ 由以下规则确定：\n    1.  $s'=u$。\n    2.  如果 $s=1$，则 $i'=i$。\n    3.  如果 $s=0$，则 $i'=(i+1) \\bmod n$。\n-   **初始状态**：$(i_0, s_0) = (0, 1)$。\n-   **命题**：$p$ 是命题 $i=j$，其中 $j$ 是一个满足 $1 \\le j \\le n-1$ 的固定整数。\n-   **CTL 公式**：$\\mathrm{E}\\mathrm{F}\\, p$。如果存在一条从初始状态出发的路径，使得 $p$ 最终为真，则该公式成立。\n-   **任务**：\n    1.  应用前向可达性分析来判断 $\\mathrm{E}\\mathrm{F}\\, p$ 是否从初始状态成立。\n    2.  如果成立，确定到达 $p$ 为真的状态所需的最小步数 $k$。\n    3.  用 $j$ 和 $n$ 的封闭形式表达式给出 $k$ 的答案。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据指定的标准对问题进行评估。\n\n-   **科学依据**：该问题在形式化验证领域，特别是模型检测方面，有充分的科学依据。模型检测是电子设计自动化（EDA）和计算机科学的核心课题。带有停顿逻辑的同步流水线模型是一个标准的、简化的抽象。计算树逻辑（CTL）是该领域使用的基本时序逻辑。所有概念都是标准的、科学合理的。\n-   **适定性**：该问题是适定的。状态空间是有限的，初始状态已定义，转移关系是明确的。输入 $u$ 的不确定性在建模环境交互中是标准的。问题要求判断路径的存在性以及到目标状态集的最短长度，这是一个在状态转移图上定义明确的最短路径问题。\n-   **客观性**：该问题以精确、客观、形式化的语言陈述，不含任何主观或基于观点的断言。\n\n该问题不存在任何无效性缺陷：\n1.  它在科学上和事实上都是合理的。\n2.  这是一个与指定主题直接相关的可形式化问题。\n3.  设置是完整且一致的；例如，条件 $1 \\le j \\le n-1$ 确保了目标状态在流水线阶段内有明确定义，并且与初始位置不同。\n4.  该模型是抽象的，但在物理上并非不可能或不一致。\n5.  它结构良好，并允许一个唯一的、稳定的、有意义的解。\n6.  由于受控状态变量 $i$ 和不确定性控制变量 $s$ 之间的相互作用，该问题并非微不足道。\n7.  解是可以通过数学推导和验证的。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供完整的解答。\n\n### 解答\n该系统是一个 Kripke 结构，其中状态是序对 $(i, s)$，满足 $i \\in \\{0, 1, \\dots, n-1\\}$ 和 $s \\in \\{0, 1\\}$。初始状态为 $q_0 = (0, 1)$。命题 $p$ 在任何满足 $i=j$ 的状态 $(i, s)$ 下为真。CTL 公式 $\\mathrm{E}\\mathrm{F}\\, p$ 在初始状态成立，如果存在至少一个从 $(0, 1)$ 开始的转移序列（一条路径），在有限步数内到达某个状态 $(j, s')$，其中 $s' \\in \\{0, 1\\}$。问题要求的是这样一条路径上的最小步数 $k$。这是一个状态转移图上的最短路径问题。\n\n设 $R_k$ 为在恰好 $k$ 步内可达的状态集合。我们在寻找最小的 $k \\geq 0$，使得 $R_k$ 包含一个满足 $i=j$ 的状态 $(i, s)$。\n\n首先，我们通过构造一条从初始状态到 $i=j$ 状态的显式路径，来确定 $\\mathrm{E}\\mathrm{F}\\, p$ 成立。目标是尽快增加位置索引 $i$。要增加 $i$，停顿位 $s$ 必须为 $0$。\n\n进展最快的路径构造如下：\n1.  **第 0 步**：系统处于初始状态 $q_0 = (0, 1)$。此时，$i_0 = 0$ 且 $s_0 = 1$。\n2.  **第 1 步**：从状态 $(0, 1)$ 出发，由于 $s_0=1$，位置索引无法前进：$i_1 = i_0 = 0$。为了使未来能够前进，下一个停顿位 $s_1$ 必须为 $0$。由于输入 $u$ 由环境不确定地选择，因此存在一个转移，其中 $u_0=0$，导致 $s_1=0$。在第 $k=1$ 步的状态是 $q_1 = (0, 0)$。\n3.  **第 2 步**：从状态 $(0, 0)$ 出发，由于 $s_1=0$，位置索引前进：$i_2 = (i_1+1) \\bmod n = (0+1) \\bmod n = 1$。为继续前进，我们沿着环境选择 $u_1=0$ 的路径，因此 $s_2=0$。在第 $k=2$ 步的状态是 $q_2 = (1, 0)$。\n4.  **一般步骤 $m > 1$**：假设在第 $m$ 步我们处于状态 $q_m = (m-1, 0)$。由于 $s_m=0$，索引前进：$i_{m+1} = (i_m+1) \\bmod n = ((m-1)+1) \\bmod n = m \\bmod n$。条件 $1 \\le j \\le n-1$ 意味着目标步数将小于或等于 $n$，因此对于所有相关步骤，$m \\bmod n = m$。为了保持最快进展，我们选择 $u_m=0$，所以 $s_{m+1}=0$。在第 $k=m+1$ 步的状态是 $q_{m+1} = (m, 0)$。\n\n这个状态序列定义了一条有效路径：\n$$ (0, 1) \\xrightarrow{k=1} (0, 0) \\xrightarrow{k=2} (1, 0) \\xrightarrow{k=3} (2, 0) \\rightarrow \\dots $$\n沿此路径，在第 $k$ 步（对于 $k \\geq 2$）的状态是 $(k-1, 0)$。要达到一个索引为 $j$ 的状态，我们需要找到 $k$ 使得 $i_k=j$。\n沿着我们构造的路径，在第 $k=j+1$ 步的状态是 $( (j+1)-1, 0) = (j, 0)$。在此状态下，命题 $p$ ($i=j$) 为真。\n这证明了存在一条长度为 $j+1$ 的路径到达一个满足 $p$ 的状态。因此，CTL 公式 $\\mathrm{E}\\mathrm{F}\\, p$ 成立，并且最小步数至多为 $j+1$。\n\n接下来，我们证明 $j+1$ 确实是最小步数。我们将表明，在少于 $j+1$ 步内不可能到达任何满足 $i=j$ 的状态 $(i, s)$。为此，我们确定在第 $k$ 步可达的任何状态中索引 $i$ 的最大可能值，我们将其表示为 $i_{\\max}(k)$。\n\n设 $R_k$ 为在恰好 $k$ 步内可达的所有状态的集合。\n$i_{\\max}(k) = \\max \\{ i \\mid \\exists s \\in \\{0,1\\} \\text{ s.t. } (i,s) \\in R_k \\}$。\n\n-   对于 $k=0$：$R_0 = \\{(0, 1)\\}$。所以，$i_{\\max}(0) = 0$。\n-   对于 $k=1$：从 $(0, 1)$ 的转移会导致状态 $(0, 0)$ 和 $(0, 1)$。所以，$R_1 = \\{(0, 0), (0, 1)\\}$，且 $i_{\\max}(1) = 0$。\n-   对于 $k > 1$：如果一个状态 $(i', s')$ 是某个状态 $(i, s) \\in R_{k-1}$ 的后继状态，则它在 $R_k$ 中。下一个索引 $i'$ 要么是 $i$（如果 $s=1$），要么是 $(i+1) \\bmod n$（如果 $s=0$）。$i'$ 的最大可能值是通过取 $R_{k-1}$ 中 $i$ 的最大值（即 $i_{\\max}(k-1)$）并应用索引递增规则得到的：\n    $$ i_{\\max}(k) \\le (i_{\\max}(k-1) + 1) \\bmod n $$\n    由于我们已经证明存在一条路径，在第 $k$ 步（对于 $k \\ge 1$）索引为 $k-1$，因此最大值是可以达到的。\n    因此，我们有递推关系：对于 $k \\ge 2$，$i_{\\max}(k) = i_{\\max}(k-1) + 1$，初始条件为 $i_{\\max}(1)=0$。\n\n我们来为 $k \\ge 1$ 时的 $i_{\\max}(k)$ 建立一个封闭形式。\n-   $i_{\\max}(1) = 0$。\n-   $i_{\\max}(2) = i_{\\max}(1) + 1 = 1$。\n-   $i_{\\max}(3) = i_{\\max}(2) + 1 = 2$。\n通过归纳法，很容易证明对于 $k \\ge 1$：\n$$ i_{\\max}(k) = k-1 $$\n只要 $k-1  n$，这个结论就成立，这对于我们感兴趣的步数范围是正确的，因为到达 $j$ 至少需要 $j+1$ 步，且 $j+1 \\le n$。\n\n要使一个状态满足命题 $p$，其索引必须为 $j$。一个索引为 $j$ 的状态只有在该步的最大可能索引至少为 $j$ 时才能在第 $k$ 步到达。\n$$ i_{\\max}(k) \\ge j $$\n代入我们关于 $i_{\\max}(k)$ 的表达式：\n$$ k-1 \\ge j $$\n这意味着：\n$$ k \\ge j+1 $$\n这个不等式表明，步数 $k$ 必须至少为 $j+1$，才有可能使索引 $i$ 等于 $j$。\n我们已经构造了一条长度恰好为 $j+1$ 的路径，该路径到达一个索引为 $j$ 的状态。因此，所需的最小步数恰好是 $j+1$。\n\n最终答案是这个最小 $k$ 的封闭形式表达式。该表达式为 $j+1$。由于约束条件 $1 \\le j \\le n-1$ 保证了流水线在最小前进序列中不会“回绕”，因此它不依赖于 $n$。",
            "answer": "$$\\boxed{j+1}$$"
        },
        {
            "introduction": "随着系统复杂度的增加，“状态空间爆炸”成为显式状态模型检查的主要障碍。为了应对这一挑战，符号模型检查应运而生，它使用如二元决策图（BDD）等数据结构来紧凑地表示状态集和转换关系。本练习将通过一个简单的二位计数器模型，让你体验如何利用基于BDD的不动点算法来高效地验证一个重要的安全性属性 $EG(\\varphi)$，初步领略符号方法的威力 。",
            "id": "4282944",
            "problem": "考虑一个在一个典型的数字集成电路中作为有限状态机实现的同步两位加法计数器。该计数器有两个状态位 $x_{1}$（最高有效位）和 $x_{0}$（最低有效位），并在每个时钟上升沿模 $4$ 加一。将该计数器建模为一个克里普克结构，其状态空间由 $\\{x_{1}, x_{0}\\}$ 的所有赋值给出，从 $(x_{1}, x_{0})$ 到 $(x_{1}', x_{0}')$ 的转移关系由电路的功能性次态逻辑定义。使用规约有序二元决策图 (ROBDD) 对布尔变量 $\\{x_{1}, x_{0}, x_{1}', x_{0}'\\}$ 上的转移关系进行编码，变量顺序为 $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$。您可以假设理想的同步行为并且没有额外的输入。\n\n使用计算树逻辑 (CTL) 的标准语义，其中 $EG\\,\\varphi$ 在一个状态上成立，当且仅当存在一条从该状态开始的无限路径，在该路径的每一步上 $\\varphi$ 都成立；并使用状态集和关系集的标准二元决策图 (BDD) 表示，通过存在量化进行像和原像计算，完成以下任务：\n\n- 为编码计数器转移关系 $T(x_{1}, x_{0}, x_{1}', x_{0}')$ 的 ROBDD 构建一个布尔公式，该公式直接从位级的模 $4$ 加一运算推导得出。\n- 令 $\\varphi(x_{1}, x_{0})$ 为状态谓词，表示计数器的值不等于 $3$（即二进制的 $11$）。使用 $EG\\,\\varphi$ 的基于 BDD 的不动点刻画和转移关系 $T$，计算满足 $EG(\\varphi)$ 的状态集合。\n- 报告满足 $EG(\\varphi)$ 的状态集的基数（以整数形式）。\n\n将最终答案表示为单个整数，不带单位。无需四舍五入。",
            "solution": "该问题经检验是合理且适定的。这是符号模型检测中的一个标准练习。\n\n该系统是一个同步两位加法计数器。状态由两位 $x_{1}$（最高有效位）和 $x_{0}$（最低有效位）表示。状态空间 $S$ 由四个状态组成，可以与整数 $0, 1, 2, 3$ 一一对应：\n- 状态 $0$：$(x_{1}, x_{0}) = (0, 0)$\n- 状态 $1$：$(x_{1}, x_{0}) = (0, 1)$\n- 状态 $2$：$(x_{1}, x_{0}) = (1, 0)$\n- 状态 $3$：$(x_{1}, x_{0}) = (1, 1)$\n\n计数器在每个时钟周期模 $4$ 加一。转移关系是确定性的。令 $(x_{1}', x_{0}')$ 为下一个时钟周期的状态。次态逻辑由二进制加法推导得出：\n- 最低有效位 $x_{0}'$ 的下一个值是其当前值的否定：$x_{0}' = \\neg x_{0}$。\n- 最高有效位 $x_{1}'$ 的下一个值翻转当且仅当 $x_{0}$ 的当前值为 $1$：$x_{1}' = x_{1} \\oplus x_{0}$（异或）。\n\n转移关系 $T(x_{1}, x_{0}, x_{1}', x_{0}')$ 是一个关于当前状态变量 $\\{x_{1}, x_{0}\\}$ 和次态变量 $\\{x_{1}', x_{0}'\\}$ 的布尔函数。对于一个变量赋值的元组，当且仅当 $(x_{1}', x_{0}')$ 是 $(x_{1}, x_{0})$ 的后继状态时，该函数为真。$T$ 的公式为：\n$$T(x_{1}, x_{0}, x_{1}', x_{0}') \\equiv (x_{0}' \\leftrightarrow \\neg x_{0}) \\land (x_{1}' \\leftrightarrow (x_{1} \\oplus x_{0}))$$\n这个单一的关系编码了所有四个状态转移：\n- $T(0, 0, 0, 1)$ 为真，表示从状态 $0$ 到状态 $1$ 的转移。\n- $T(0, 1, 1, 0)$ 为真，表示从状态 $1$ 到状态 $2$ 的转移。\n- $T(1, 0, 1, 1)$ 为真，表示从状态 $2$ 到状态 $3$ 的转移。\n- $T(1, 1, 0, 0)$ 为真，表示从状态 $3$ 到状态 $0$ 的转移。\n在一个基于 BDD 的模型检测器中，这个布尔公式将使用指定的变量顺序 $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$ 被编译成一个规约有序二元决策图 (ROBDD)。\n\n问题要求计算满足计算树逻辑 (CTL) 公式 $EG(\\varphi)$ 的状态集合。状态谓词 $\\varphi$ 定义为计数器的值不等于 $3$。状态 $3$ 对应于 $(x_{1}, x_{0}) = (1, 1)$。因此，谓词 $\\varphi$ 由以下布尔公式表示：\n$$\\varphi(x_{1}, x_{0}) \\equiv \\neg (x_{1} \\land x_{0})$$\n满足 $\\varphi$ 的状态集合，我们记为 $S_\\varphi$，是 $\\{ (0,0), (0,1), (1,0) \\}$，对应于状态 $\\{0, 1, 2\\}$。\n\n满足 $EG(\\varphi)$ 的状态集合被刻画为算子 $F(Y) = S_\\varphi \\cap \\text{PreImage}(Y)$ 的最大不动点，其中 $\\text{PreImage}(Y)$ 是存在转移到集合 $Y$ 中某个状态的所有状态的集合。这对应于 CTL 语义 $EG(\\varphi) \\equiv \\nu Z . (\\varphi \\land EX(Z))$。不动点通过迭代计算。令 $Y_k$ 为第 $k$ 次迭代时的状态集合。\n计算最大不动点的标准算法从满足属性 $\\varphi$ 的所有状态的集合开始，并重复地移除那些无法保持在该集合内的状态。\n令 $Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$。\n迭代过程为 $Y_{k+1} = Y_k \\cap \\text{PreImage}(Y_k)$。当 $Y_{k+1} = Y_k$ 时，过程停止。\n\n原像 (PreImage) 运算，对应于 $EX(Y)$，符号化地定义为：\n$$ \\text{PreImage}(Y) = \\{ s \\mid \\exists s' \\in Y, T(s,s') \\} $$\n在基于 BDD 的框架中，如果 $Y(x_1', x_0')$ 是集合 $Y$ 的特征函数，则其原像集计算为 $\\exists x_{1}', x_{0}' . (T(x_{1}, x_{0}, x_{1}', x_{0}') \\land Y(x_{1}', x_{0}'))$。\n\n让我们执行迭代计算：\n初始步骤：\n$Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$。\n\n迭代 1：\n我们计算 $\\text{PreImage}(Y_{0})$。这是在 $Y_{0} = \\{ (0,0), (0,1), (1,0) \\}$ 中有后继状态的状态集合。\n- 状态 $(0,0)$ 的前驱是 $(1,1)$。\n- 状态 $(0,1)$ 的前驱是 $(0,0)$。\n- 状态 $(1,0)$ 的前驱是 $(0,1)$。\n所以，$\\text{PreImage}(Y_{0}) = \\{ (1,1), (0,0), (0,1) \\}$。\n现在我们计算 $Y_{1} = Y_{0} \\cap \\text{PreImage}(Y_{0})$：\n$$Y_{1} = \\{ (0,0), (0,1), (1,0) \\} \\cap \\{ (1,1), (0,0), (0,1) \\} = \\{ (0,0), (0,1) \\}$$\n\n迭代 2：\n我们计算 $\\text{PreImage}(Y_{1})$，其中 $Y_{1} = \\{ (0,0), (0,1) \\}$。\n- 状态 $(0,0)$ 的前驱是 $(1,1)$。\n- 状态 $(0,1)$ 的前驱是 $(0,0)$。\n所以，$\\text{PreImage}(Y_{1}) = \\{ (1,1), (0,0) \\}$。\n现在我们计算 $Y_{2} = Y_{1} \\cap \\text{PreImage}(Y_{1})$：\n$$Y_{2} = \\{ (0,0), (0,1) \\} \\cap \\{ (1,1), (0,0) \\} = \\{ (0,0) \\}$$\n\n迭代 3：\n我们计算 $\\text{PreImage}(Y_{2})$，其中 $Y_{2} = \\{ (0,0) \\}$。\n- 状态 $(0,0)$ 的前驱是 $(1,1)$。\n所以，$\\text{PreImage}(Y_{2}) = \\{ (1,1) \\}$。\n现在我们计算 $Y_{3} = Y_{2} \\cap \\text{PreImage}(Y_{2})$：\n$$Y_{3} = \\{ (0,0) \\} \\cap \\{ (1,1) \\} = \\emptyset$$\n\n迭代 4：\n我们计算 $\\text{PreImage}(Y_{3})$，其中 $Y_{3} = \\emptyset$。\n空集的原像集是空集，所以 $\\text{PreImage}(Y_{3}) = \\emptyset$。\n现在我们计算 $Y_{4} = Y_{3} \\cap \\text{PreImage}(Y_{3})$：\n$$Y_{4} = \\emptyset \\cap \\emptyset = \\emptyset$$\n\n由于 $Y_{4} = Y_{3}$，算法已达到不动点。满足 $EG(\\varphi)$ 的状态集合是空集 $\\emptyset$。\n\n这个结果是直观的。公式 $EG(\\varphi)$ 在一个状态上成立，前提是存在一条从该状态开始的无限路径，该路径永不访问状态 $3$（二进制 $11$）。计数器遵循一个单一的循环：$(0,0) \\to (0,1) \\to (1,0) \\to (1,1) \\to (0,0) \\to \\dots$。从任何初始状态开始，系统最终都保证会到达状态 $(1,1)$。因此，没有状态能满足存在一条总是避开状态 $(1,1)$ 的路径这一性质。满足 $EG(\\varphi)$ 的状态集合必须为空。\n\n最终集合 $\\emptyset$ 的基数是 $0$。",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}