{
    "hands_on_practices": [
        {
            "introduction": "The foundation of model checking lies in translating an informal system specification into a precise mathematical model. This practice challenges you to construct a Kripke structure for a standard synchronous handshake protocol, a common pattern in digital design. By formalizing the protocol's states and transitions, and then evaluating a Computation Tree Logic (CTL) property like $AF\\;ack$, you will gain firsthand experience in the critical process of abstraction and the semantics of temporal logic .",
            "id": "4282897",
            "problem": "Consider a synchronous Register-Transfer Level (RTL) control automaton for a single-request/single-acknowledge handshake in the context of Electronic Design Automation (EDA). The handshake follows the widely used synchronous protocol: when a requester raises a request, a responder eventually raises an acknowledge; the requester then lowers the request, and the responder subsequently lowers the acknowledge, returning the system to idle. The system is clocked and transitions occur on clock edges. The atomic propositions are $req$ and $ack$, representing the Boolean values of the request and acknowledge signals driven by the controller. Assume the environment may nondeterministically choose to start a handshake and the responder may nondeterministically delay the acknowledge.\n\nStarting from the protocol rules and synchronous semantics (every cycle the next state is determined by current state and inputs, and all signals are sampled at clock edges), construct a minimal deterministic control automaton with four distinct control states that realizes the handshake without violating the protocol ordering. Use these handshake-consistent states:\n- Idle ($req$ low, $ack$ low),\n- Request ($req$ high, $ack$ low),\n- Acknowledged ($req$ high, $ack$ high),\n- Release ($req$ low, $ack$ high).\n\nModel this controller as a Kripke structure $K = (S, R, L)$, where $S$ is the finite set of states, $R \\subseteq S \\times S$ is the total transition relation (every state has at least one successor), and $L: S \\to 2^{\\{req, ack\\}}$ labels each state with the set of atomic propositions true in that state. Use the following transition constraints derived from synchronous handshake correctness and nondeterministic environment behaviors:\n- From Idle, either remain Idle or raise $req$ to enter Request in the next cycle.\n- In Request, either remain in Request or have the responder assert $ack$ to enter Acknowledged in the next cycle.\n- In Acknowledged, either remain in Acknowledged or have the requester drop $req$ to enter Release in the next cycle.\n- In Release, either remain in Release or have the responder drop $ack$ to return to Idle in the next cycle.\n\nLabel each state with the appropriate subset of $\\{req, ack\\}$ implied by its signal values. With this Kripke structure, consider the Computation Tree Logic (CTL) property $A F\\; ack$, meaning \"on all paths, eventually $ack$ holds.\" Using only standard definitions of Kripke structures and CTL semantics, determine the number of states $s \\in S$ such that $K, s \\models A F\\; ack$. Express your final answer as a single integer. No rounding is required, and no units are involved.",
            "solution": "The problem requires an evaluation of a Computation Tree Logic (CTL) formula on a Kripke structure representing a synchronous handshake protocol. The first step is to formally define this Kripke structure based on the provided description.\n\nA Kripke structure is a tuple $K = (S, R, L)$, where $S$ is a set of states, $R \\subseteq S \\times S$ is a transition relation, and $L: S \\to 2^{AP}$ is a labeling function mapping states to sets of true atomic propositions from a set $AP$.\n\n**1. Formalizing the Kripke Structure**\n\n**States ($S$):**\nThe problem specifies four distinct control states. Let us denote them as follows:\n- $s_I$: The `Idle` state.\n- $s_Q$: The `Request` state.\n- $s_A$: The `Acknowledged` state.\n- $s_R$: The `Release` state.\nThus, the set of states is $S = \\{s_I, s_Q, s_A, s_R\\}$.\n\n**Atomic Propositions ($AP$) and Labeling Function ($L$):**\nThe atomic propositions are given as $AP = \\{req, ack\\}$. The labeling function $L$ is determined by the signal values in each state:\n- `Idle` ($req$ low, $ack$ low): $L(s_I) = \\emptyset$.\n- `Request` ($req$ high, $ack$ low): $L(s_Q) = \\{req\\}$.\n- `Acknowledged` ($req$ high, $ack$ high): $L(s_A) = \\{req, ack\\}$.\n- `Release` ($req$ low, $ack$ high): $L(s_R) = \\{ack\\}$.\n\n**Transition Relation ($R$):**\nThe transition constraints define the edges of the state graph. The relation must be total, meaning every state has an outgoing transition.\n- From $s_I$ (`Idle`), the system can either remain `Idle` or transition to `Request`. This defines the transitions $(s_I, s_I) \\in R$ and $(s_I, s_Q) \\in R$.\n- From $s_Q$ (`Request`), the system can either remain in `Request` or transition to `Acknowledged`. This defines the transitions $(s_Q, s_Q) \\in R$ and $(s_Q, s_A) \\in R$.\n- From $s_A$ (`Acknowledged`), the system can either remain `Acknowledged` or transition to `Release`. This defines the transitions $(s_A, s_A) \\in R$ and $(s_A, s_R) \\in R$.\n- From $s_R$ (`Release`), the system can either remain in `Release` or transition to `Idle`. This defines the transitions $(s_R, s_R) \\in R$ and $(s_R, s_I) \\in R$.\n\nThe complete transition relation is $R = \\{(s_I, s_I), (s_I, s_Q), (s_Q, s_Q), (s_Q, s_A), (s_A, s_A), (s_A, s_R), (s_R, s_R), (s_R, s_I)\\}$. This relation is total, as each state has at least one successor. The self-loops at each state correspond to the nondeterministic delays mentioned in the problem (e.g., the environment might not raise `req`, or the responder might delay `ack`).\n\n**2. Evaluating the CTL Property $AF\\;ack$**\n\nThe CTL formula to be evaluated is $AF\\;ack$. The semantics of this formula are: \"For all computation paths starting from a given state, there is some future state on the path where the proposition $ack$ is true.\"\n\nA state $s$ satisfies a proposition $p$ (written $s \\models p$) if $p \\in L(s)$.\nFirst, let's identify the set of states that satisfy the proposition $ack$.\nFrom the labeling function $L$:\n- $s_A \\models ack$ because $ack \\in L(s_A) = \\{req, ack\\}$.\n- $s_R \\models ack$ because $ack \\in L(s_R) = \\{ack\\}$.\nThe states $s_I$ and $s_Q$ do not satisfy $ack$, since $ack \\notin L(s_I)$ and $ack \\notin L(s_Q)$.\nLet $S_{ack} = \\{s \\in S \\mid s \\models ack\\} = \\{s_A, s_R\\}$.\n\nNow, we must check for each state $s \\in S$ whether $K, s \\models AF\\;ack$. A state $s$ satisfies $AF\\;ack$ if every infinite path $\\pi = (s_0, s_1, s_2, \\dots)$ starting with $s_0 = s$ contains at least one state $s_i$ such that $s_i \\in S_{ack}$.\n\nLet's analyze each state:\n\n- **State $s_A$ (`Acknowledged`):**\nAny path starting from $s_A$ has $s_A$ as its first state. Since $s_A \\models ack$, the condition \"eventually $ack$\" is satisfied at the very beginning of the path (at time $0$). This holds for all paths starting from $s_A$. Therefore, $K, s_A \\models AF\\;ack$.\n\n- **State $s_R$ (`Release`):**\nSimilarly, any path starting from $s_R$ has $s_R$ as its first state. Since $s_R \\models ack$, the condition is immediately satisfied. This holds for all paths starting from $s_R$. Therefore, $K, s_R \\models AF\\;ack$.\n\n- **State $s_I$ (`Idle`):**\nFrom state $s_I$, there are two possible transitions: to $s_I$ or to $s_Q$. Due to the nondeterministic choice, a valid computation path can be formed by repeatedly choosing the self-loop transition $(s_I, s_I)$. This gives the infinite path $\\pi = (s_I, s_I, s_I, \\dots)$. For every state $s_i$ on this path, $s_i = s_I$, and we know that $s_I \\not\\models ack$. Thus, we have found a path starting from $s_I$ on which $ack$ is never true. Because the $A$ (\"for all paths\") quantifier is not met, the property fails. Therefore, $K, s_I \\not\\models AF\\;ack$.\n\n- **State $s_Q$ (`Request`):**\nFrom state $s_Q$, there are two possible transitions: to $s_Q$ or to $s_A$. Similar to the `Idle` state, a valid computation path can be formed by repeatedly choosing the self-loop transition $(s_Q, s_Q)$. This gives the infinite path $\\pi = (s_Q, s_Q, s_Q, \\dots)$. For every state $s_i$ on this path, $s_i = s_Q$, and we know that $s_Q \\not\\models ack$. This path represents the scenario where the responder never asserts the acknowledge signal. As we have found a path starting from $s_Q$ that never reaches a state where $ack$ is true, the $A$ quantifier is not met. Therefore, $K, s_Q \\not\\models AF\\;ack$.\n\n**Conclusion**\nThe set of states $s$ for which the property $K, s \\models AF\\;ack$ holds is $\\{s_A, s_R\\}$. The problem asks for the *number* of such states. There are two states in this set.\nThe number of states satisfying $AF\\;ack$ is $2$.",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "Once a system is modeled, we need algorithms to verify its properties automatically. This exercise introduces forward reachability, a fundamental technique for exploring a system's state space to determine if a certain condition can ever be met. You will apply this method to a simplified pipeline model to find the shortest path to a target state, which directly corresponds to checking an $EF$ property in CTL .",
            "id": "4282921",
            "problem": "Consider a synchronous finite-state abstraction used in Electronic Design Automation (EDA) to model an $n$-stage pipeline with single-token flow control. The system has two state variables: an integer position index $i \\in \\{0,1,\\ldots,n-1\\}$ indicating which pipeline stage currently holds the token (encoded as a one-hot register in hardware), and a stall bit $s \\in \\{0,1\\}$. The environment provides a nondeterministic input $u \\in \\{0,1\\}$ at each clock edge that sets the next stall bit. The transition relation is defined by the following rules for the next-state variables $i'$ and $s'$:\n- If $s = 1$, then $i' = i$.\n- If $s = 0$, then $i' = (i+1) \\bmod n$.\n- The environment chooses $u$ arbitrarily at each step, and $s' = u$.\n\nThe initial state is given by $i = 0$ and $s = 1$. Let $p$ be the proposition $i = j$, where $j$ is a fixed integer satisfying $1 \\leq j \\leq n-1$. Interpret $p$ in Computation Tree Logic (CTL), where $p$ holds at a state if and only if the state’s position index equals $j$. The CTL operator $\\mathrm{E}\\mathrm{F}$ denotes “there exists a path on which eventually.” Under the standard semantics of CTL, $\\mathrm{E}\\mathrm{F}\\, p$ holds at the initial state if and only if there exists a path from the initial state along the transition relation such that at some future time $p$ holds.\n\nApply forward reachability starting from the initial state to characterize the set of states reachable in exactly $k$ steps as a function of $k$, and use this to decide whether $\\mathrm{E}\\mathrm{F}\\, p$ holds from the initial state. If it holds, determine the minimal $k$ such that a state satisfying $p$ is reachable in exactly $k$ steps. Express your final answer as a closed-form symbolic expression in terms of $j$ and $n$. No rounding is required. The final answer must be a single expression.",
            "solution": "The problem asks for the validation of a model checking problem statement and, if valid, the determination of the minimal number of steps $k$ to reach a state satisfying a given property.\n\n### Step 1: Extract Givens\n-   **System**: An $n$-stage pipeline model.\n-   **State Space**: A state is a pair $(i, s)$, where the position index is $i \\in \\{0, 1, \\ldots, n-1\\}$ and the stall bit is $s \\in \\{0, 1\\}$.\n-   **Input**: A nondeterministic input $u \\in \\{0, 1\\}$.\n-   **Transition Relation**: Given the current state $(i, s)$ and input $u$, the next state $(i', s')$ is determined by:\n    1.  $s' = u$.\n    2.  If $s = 1$, then $i' = i$.\n    3.  If $s = 0$, then $i' = (i+1) \\bmod n$.\n-   **Initial State**: $(i_0, s_0) = (0, 1)$.\n-   **Proposition**: $p$ is the proposition $i=j$, where $j$ is a fixed integer satisfying $1 \\leq j \\leq n-1$.\n-   **CTL Formula**: $\\mathrm{E}\\mathrm{F}\\, p$. The formula holds if there exists a path from the initial state where $p$ eventually becomes true.\n-   **Task**:\n    1.  Apply forward reachability to decide if $\\mathrm{E}\\mathrm{F}\\, p$ holds from the initial state.\n    2.  If it holds, determine the minimal number of steps $k$ required to reach a state where $p$ is true.\n    3.  Provide the answer for $k$ as a closed-form expression in terms of $j$ and $n$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the specified criteria.\n\n-   **Scientific Grounding**: The problem is well-grounded in the field of formal verification, specifically model checking, which is a core topic in Electronic Design Automation (EDA) and computer science. The model of a synchronous pipeline with stall logic is a standard, simplified abstraction. Computation Tree Logic (CTL) is a fundamental temporal logic used in this domain. All concepts are standard and scientifically sound.\n-   **Well-Posedness**: The problem is well-posed. The state space is finite, the initial state is defined, and the transition relation is unambiguous. The nondeterminism of the input $u$ is standard in modeling environmental interaction. The question asks for the existence of a path and the minimal length to a target set of states, which is a well-defined shortest path problem on the state transition graph.\n-   **Objectivity**: The problem is stated in precise, objective, and formal language, free of any subjective or opinion-based claims.\n\nThe problem does not exhibit any of the invalidity flaws:\n1.  It is scientifically and factually sound.\n2.  It is a formalizable problem directly relevant to the specified topic.\n3.  The setup is complete and consistent; for instance, the condition $1 \\le j \\le n-1$ ensures the target state is well-defined within the pipeline stages and distinct from the initial position.\n4.  The model is abstract but not physically impossible or inconsistent.\n5.  It is well-structured and admits a unique, stable, and meaningful solution.\n6.  The problem is not trivial due to the interaction between the controlled state variable $i$ and the nondeterministically controlled variable $s$.\n7.  The solution is mathematically derivable and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution\nThe system is a Kripke structure where the states are pairs $(i, s)$ with $i \\in \\{0, 1, \\dots, n-1\\}$ and $s \\in \\{0, 1\\}$. The initial state is $q_0 = (0, 1)$. The proposition $p$ is true at any state $(i, s)$ where $i=j$. The CTL formula $\\mathrm{E}\\mathrm{F}\\, p$ holds at the initial state if there exists at least one sequence of transitions (a path) starting from $(0, 1)$ that leads to a state $(j, s')$ for some $s' \\in \\{0, 1\\}$ in a finite number of steps. The problem asks for the minimal number of steps $k$ on such a path. This is a shortest path problem on the state transition graph.\n\nLet $R_k$ be the set of states reachable in exactly $k$ steps. We are looking for the smallest $k \\geq 0$ such that $R_k$ contains a state $(i, s)$ with $i=j$.\n\nFirst, we establish that $\\mathrm{E}\\mathrm{F}\\, p$ holds by constructing an explicit path from the initial state to a state where $i=j$. The goal is to increment the position index $i$ as quickly as possible. To increment $i$, the stall bit $s$ must be $0$.\n\nThe path of fastest progress is constructed as follows:\n1.  **Step 0**: The system is in the initial state $q_0 = (0, 1)$. Here, $i_0 = 0$ and $s_0 = 1$.\n2.  **Step 1**: From state $(0, 1)$, since $s_0=1$, the position index cannot advance: $i_1 = i_0 = 0$. To enable future advancement, the next stall bit $s_1$ must be $0$. Since the input $u$ is chosen nondeterministically by the environment, there exists a transition where $u_0=0$, resulting in $s_1=0$. The state at step $k=1$ is $q_1 = (0, 0)$.\n3.  **Step 2**: From state $(0, 0)$, since $s_1=0$, the position index advances: $i_2 = (i_1+1) \\bmod n = (0+1) \\bmod n = 1$. To continue advancing, we follow the path where the environment chooses $u_1=0$, so $s_2=0$. The state at step $k=2$ is $q_2 = (1, 0)$.\n4.  **General Step $m > 1$**: Assume at step $m$ we are in state $q_m = (m-1, 0)$. Since $s_m=0$, the index advances: $i_{m+1} = (i_m+1) \\bmod n = ((m-1)+1) \\bmod n = m \\bmod n$. The condition $1 \\le j \\le n-1$ implies that the target step count will be less than or equal to $n$, so for all relevant steps, $m \\bmod n = m$. To maintain fastest progress, we choose $u_m=0$, so $s_{m+1}=0$. The state at step $k=m+1$ is $q_{m+1} = (m, 0)$.\n\nThis sequence of states defines a valid path:\n$$ (0, 1) \\xrightarrow{k=1} (0, 0) \\xrightarrow{k=2} (1, 0) \\xrightarrow{k=3} (2, 0) \\rightarrow \\dots $$\nThe state at step $k$ (for $k \\geq 2$) along this path is $(k-1, 0)$. To reach a state where the index is $j$, we need to find $k$ such that $i_k=j$.\nFollowing our constructed path, the state at step $k=j+1$ is $( (j+1)-1, 0) = (j, 0)$. At this state, the proposition $p$ ($i=j$) is true.\nThis demonstrates the existence of a path of length $j+1$ to a state satisfying $p$. Therefore, the CTL formula $\\mathrm{E}\\mathrm{F}\\, p$ holds, and the minimal number of steps is at most $j+1$.\n\nNext, we prove that $j+1$ is indeed the minimal number of steps. We will show that it is impossible to reach any state $(i, s)$ with $i=j$ in fewer than $j+1$ steps. To do this, we determine the maximum possible value of the index $i$ in any state reachable at step $k$, which we denote by $i_{\\max}(k)$.\n\nLet $R_k$ be the set of all states reachable in exactly $k$ steps.\n$i_{\\max}(k) = \\max \\{ i \\mid \\exists s \\in \\{0,1\\} \\text{ s.t. } (i,s) \\in R_k \\}$.\n\n-   For $k=0$: $R_0 = \\{(0, 1)\\}$. So, $i_{\\max}(0) = 0$.\n-   For $k=1$: Transitions from $(0, 1)$ lead to states $(0, 0)$ and $(0, 1)$. So, $R_1 = \\{(0, 0), (0, 1)\\}$, and $i_{\\max}(1) = 0$.\n-   For $k > 1$: A state $(i', s')$ is in $R_k$ if it is a successor of some state $(i, s) \\in R_{k-1}$. The next index $i'$ is either $i$ (if $s=1$) or $(i+1) \\bmod n$ (if $s=0$). The maximum possible value for $i'$ is obtained by taking the maximum value of $i$ in $R_{k-1}$ (which is $i_{\\max}(k-1)$) and applying the index-incrementing rule:\n    $$ i_{\\max}(k) \\le (i_{\\max}(k-1) + 1) \\bmod n $$\n    Since we have already shown a path exists where the index at step $k$ is $k-1$ (for $k \\ge 1$), the maximum is achieved.\n    Thus, we have the recurrence relation: $i_{\\max}(k) = i_{\\max}(k-1) + 1$ for $k \\ge 2$, with the initial condition $i_{\\max}(1)=0$.\n\nLet's establish a closed form for $i_{\\max}(k)$ for $k \\ge 1$.\n-   $i_{\\max}(1) = 0$.\n-   $i_{\\max}(2) = i_{\\max}(1) + 1 = 1$.\n-   $i_{\\max}(3) = i_{\\max}(2) + 1 = 2$.\nBy induction, it is straightforward to show that for $k \\ge 1$:\n$$ i_{\\max}(k) = k-1 $$\nThis holds as long as $k-1  n$, which is true for the range of steps we are interested in, since reaching $j$ requires at least $j+1$ steps, and $j+1 \\le n$.\n\nFor a state to satisfy the proposition $p$, its index must be $j$. A state with index $j$ can be reached at step $k$ only if the maximum possible index at that step is at least $j$.\n$$ i_{\\max}(k) \\ge j $$\nSubstituting our expression for $i_{\\max}(k)$:\n$$ k-1 \\ge j $$\nThis implies:\n$$ k \\ge j+1 $$\nThis inequality shows that the number of steps $k$ must be at least $j+1$ to have any possibility of the index $i$ being equal to $j$.\nWe have already constructed a path of length exactly $j+1$ that reaches a state with index $j$. Therefore, the minimal number of steps required is precisely $j+1$.\n\nThe final answer is a closed-form expression for this minimal $k$. The expression is $j+1$. It does not depend on $n$ due to the constraint $1 \\le j \\le n-1$, which ensures the pipeline does not \"wrap around\" during the minimal sequence of advancements.",
            "answer": "$$\\boxed{j+1}$$"
        },
        {
            "introduction": "Explicitly exploring every state is infeasible for complex systems due to the state explosion problem. Symbolic model checking offers a powerful solution by representing large sets of states and transitions implicitly using data structures like Binary Decision Diagrams (BDDs). In this final practice, you will use the symbolic approach to verify an $EG$ property on a simple counter by computing a greatest fixpoint, providing a glimpse into the scalable techniques that make model checking practical for real-world hardware verification .",
            "id": "4282944",
            "problem": "Consider a synchronous two-bit up-counter implemented as a finite-state machine in a typical digital integrated circuit. The counter has two state bits $x_{1}$ (most significant bit) and $x_{0}$ (least significant bit) and increments by one modulo $4$ on each rising clock edge. Model the counter as a Kripke structure with state space given by all valuations of $\\{x_{1}, x_{0}\\}$ and a transition relation from $(x_{1}, x_{0})$ to $(x_{1}', x_{0}')$ defined by the functional next-state logic of the circuit. Use a Reduced Ordered Binary Decision Diagram (ROBDD) to encode the transition relation over Boolean variables $\\{x_{1}, x_{0}, x_{1}', x_{0}'\\}$ with the variable order $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$. You may assume ideal synchronous behavior and no additional inputs.\n\nUsing the standard semantics of Computation Tree Logic (CTL), where $EG\\,\\varphi$ holds at a state if there exists an infinite path starting at that state along which $\\varphi$ holds at every step, and the standard Binary Decision Diagram (BDD) representation of sets of states and relations with existential quantification for image and preimage computations, do the following:\n\n- Construct a Boolean formula for the ROBDD that encodes the transition relation $T(x_{1}, x_{0}, x_{1}', x_{0}')$ of the counter, derived directly from the bit-level addition by one modulo $4$.\n- Let $\\varphi(x_{1}, x_{0})$ be the state predicate expressing that the counter value is not equal to $3$ (i.e., binary $11$). Using the BDD-based fixpoint characterization of $EG\\,\\varphi$ and the transition relation $T$, compute the set of states satisfying $EG(\\varphi)$.\n- Report the cardinality (as an integer) of the set of states that satisfy $EG(\\varphi)$.\n\nExpress the final answer as a single integer with no units. No rounding is required.",
            "solution": "The problem is validated as sound and well-posed. It is a standard exercise in symbolic model checking.\n\nThe system is a synchronous two-bit up-counter. The state is represented by two bits, $x_{1}$ (most significant) and $x_{0}$ (least significant). The state space $S$ consists of four states, which can be identified with the integers $0, 1, 2, 3$:\n- State $0$: $(x_{1}, x_{0}) = (0, 0)$\n- State $1$: $(x_{1}, x_{0}) = (0, 1)$\n- State $2$: $(x_{1}, x_{0}) = (1, 0)$\n- State $3$: $(x_{1}, x_{0}) = (1, 1)$\n\nThe counter increments by one modulo $4$ at each clock cycle. The transition relation is deterministic. Let $(x_{1}', x_{0}')$ be the state at the next clock cycle. The next-state logic is derived from binary addition:\n- The next value of the least significant bit, $x_{0}'$, is the negation of its current value: $x_{0}' = \\neg x_{0}$.\n- The next value of the most significant bit, $x_{1}'$, flips if and only if the current value of $x_{0}$ is $1$: $x_{1}' = x_{1} \\oplus x_{0}$ (exclusive OR).\n\nThe transition relation $T(x_{1}, x_{0}, x_{1}', x_{0}')$ is a Boolean function over the current state variables $\\{x_{1}, x_{0}\\}$ and next state variables $\\{x_{1}', x_{0}'\\}$. This function is true for a tuple of variable assignments if and only if $(x_{1}', x_{0}')$ is the successor of $(x_{1}, x_{0})$. The formula for $T$ is:\n$$T(x_{1}, x_{0}, x_{1}', x_{0}') \\equiv (x_{0}' \\leftrightarrow \\neg x_{0}) \\land (x_{1}' \\leftrightarrow (x_{1} \\oplus x_{0}))$$\nThis single relation encodes all four state transitions:\n- $T(0, 0, 0, 1)$ is true, representing the transition from state $0$ to state $1$.\n- $T(0, 1, 1, 0)$ is true, representing the transition from state $1$ to state $2$.\n- $T(1, 0, 1, 1)$ is true, representing the transition from state $2$ to state $3$.\n- $T(1, 1, 0, 0)$ is true, representing the transition from state $3$ to state $0$.\nIn a BDD-based model checker, this Boolean formula would be compiled into a Reduced Ordered Binary Decision Diagram (ROBDD) using the specified variable order $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$.\n\nThe problem asks for the set of states satisfying the Computation Tree Logic (CTL) formula $EG(\\varphi)$. The state predicate $\\varphi$ is defined as the counter value not being equal to $3$. State $3$ corresponds to $(x_{1}, x_{0}) = (1, 1)$. Thus, the predicate $\\varphi$ is represented by the Boolean formula:\n$$\\varphi(x_{1}, x_{0}) \\equiv \\neg (x_{1} \\land x_{0})$$\nThe set of states satisfying $\\varphi$, which we will denote $S_\\varphi$, is $\\{ (0,0), (0,1), (1,0) \\}$, corresponding to states $\\{0, 1, 2\\}$.\n\nThe set of states satisfying $EG(\\varphi)$ is characterized as the greatest fixpoint of the operator $F(Y) = S_\\varphi \\cap \\text{PreImage}(Y)$, where $\\text{PreImage}(Y)$ is the set of states from which there exists a transition to a state in the set $Y$. This corresponds to the CTL semantics $EG(\\varphi) \\equiv \\nu Z . (\\varphi \\land EX(Z))$. The fixpoint is computed iteratively. Let $Y_k$ be the set of states at iteration $k$.\nThe standard algorithm for a greatest fixpoint starts with the set of all states that satisfy the property $\\varphi$ and repeatedly removes states that cannot remain within this set.\nLet $Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$.\nThe iteration proceeds as $Y_{k+1} = Y_k \\cap \\text{PreImage}(Y_k)$. The process stops when $Y_{k+1} = Y_k$.\n\nThe PreImage operation, corresponding to $EX(Y)$, is defined symbolically as:\n$$ \\text{PreImage}(Y) = \\{ s \\mid \\exists s' \\in Y, T(s,s') \\} $$\nIn a BDD-based framework, if $Y(x_1', x_0')$ is the characteristic function of the set $Y$, the pre-image is computed as $\\exists x_{1}', x_{0}' . (T(x_{1}, x_{0}, x_{1}', x_{0}') \\land Y(x_{1}', x_{0}'))$.\n\nLet's perform the iterative computation:\nInitial step:\n$Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$.\n\nIteration 1:\nWe compute $\\text{PreImage}(Y_{0})$. This is the set of states that have a successor in $Y_{0} = \\{ (0,0), (0,1), (1,0) \\}$.\n- The predecessor of state $(0,0)$ is $(1,1)$.\n- The predecessor of state $(0,1)$ is $(0,0)$.\n- The predecessor of state $(1,0)$ is $(0,1)$.\nSo, $\\text{PreImage}(Y_{0}) = \\{ (1,1), (0,0), (0,1) \\}$.\nNow we compute $Y_{1} = Y_{0} \\cap \\text{PreImage}(Y_{0})$:\n$$Y_{1} = \\{ (0,0), (0,1), (1,0) \\} \\cap \\{ (1,1), (0,0), (0,1) \\} = \\{ (0,0), (0,1) \\}$$\n\nIteration 2:\nWe compute $\\text{PreImage}(Y_{1})$, where $Y_{1} = \\{ (0,0), (0,1) \\}$.\n- The predecessor of state $(0,0)$ is $(1,1)$.\n- The predecessor of state $(0,1)$ is $(0,0)$.\nSo, $\\text{PreImage}(Y_{1}) = \\{ (1,1), (0,0) \\}$.\nNow we compute $Y_{2} = Y_{1} \\cap \\text{PreImage}(Y_{1})$:\n$$Y_{2} = \\{ (0,0), (0,1) \\} \\cap \\{ (1,1), (0,0) \\} = \\{ (0,0) \\}$$\n\nIteration 3:\nWe compute $\\text{PreImage}(Y_{2})$, where $Y_{2} = \\{ (0,0) \\}$.\n- The predecessor of state $(0,0)$ is $(1,1)$.\nSo, $\\text{PreImage}(Y_{2}) = \\{ (1,1) \\}$.\nNow we compute $Y_{3} = Y_{2} \\cap \\text{PreImage}(Y_{2})$:\n$$Y_{3} = \\{ (0,0) \\} \\cap \\{ (1,1) \\} = \\emptyset$$\n\nIteration 4:\nWe compute $\\text{PreImage}(Y_{3})$, where $Y_{3} = \\emptyset$.\nThe preimage of the empty set is the empty set, so $\\text{PreImage}(Y_{3}) = \\emptyset$.\nNow we compute $Y_{4} = Y_{3} \\cap \\text{PreImage}(Y_{3})$:\n$$Y_{4} = \\emptyset \\cap \\emptyset = \\emptyset$$\n\nSince $Y_{4} = Y_{3}$, the algorithm has reached a fixpoint. The set of states satisfying $EG(\\varphi)$ is the empty set, $\\emptyset$.\n\nThis result is intuitive. The formula $EG(\\varphi)$ holds in a state if there exists an infinite path starting from it that never visits state $3$ (binary $11$). The counter follows a single cycle: $(0,0) \\to (0,1) \\to (1,0) \\to (1,1) \\to (0,0) \\to \\dots$. From any starting state, the system is guaranteed to reach state $(1,1)$ eventually. Therefore, no state can satisfy the property that there exists a path always avoiding state $(1,1)$. The set of states satisfying $EG(\\varphi)$ must be empty.\n\nThe cardinality of the resulting set $\\emptyset$ is $0$.",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}