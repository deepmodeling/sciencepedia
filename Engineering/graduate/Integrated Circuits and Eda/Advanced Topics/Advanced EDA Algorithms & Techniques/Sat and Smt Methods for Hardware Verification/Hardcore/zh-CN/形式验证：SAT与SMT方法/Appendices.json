{
    "hands_on_practices": [
        {
            "introduction": "这项实践是掌握基于SAT的硬件验证的基石，旨在将电路的物理实现与其抽象的逻辑表示联系起来。我们将使用标准的Tseitin变换，将一个1位全加器电路编码为合取范式（CNF），使其行为能被SAT求解器分析。通过这个过程，你将深入理解硬件功能是如何被精确地映射为逻辑公式的。",
            "id": "4295338",
            "problem": "考虑一个一位全加器，它被实现为一个布尔电路，具有三个主输入 $a$、$b$ 和 $c$（其中 $c$ 是进位输入），以及两个主输出 $s$（和位）和 $k$（进位输出位）。在电子设计自动化（EDA）以及用于硬件验证的可满足性（SAT）和可满足性模理论（SMT）方法的背景下，该电路必须被编码为合取范式（CNF），以供布尔可满足性求解器使用。从 $\\land$、$\\lor$ 和 $\\oplus$ 的布尔语义的基本定义、CNF 作为文字析取之合取的定义，以及引入辅助变量来表示内部门输出同时保持等可满足性的标准 Tseitin 变换方法开始。\n\n您的任务是：\n- 推导一位全加器的 CNF 编码，该编码严格按照布尔电路的含义来强制执行 $s$ 和 $k$ 的语义，并使用 Tseitin 风格的方法为内部节点引入辅助变量。每个门的功能等价性必须由 CNF 子句捕获，这些子句根据其输入变量来约束其输出变量。\n- 通过为 $(a,b,c)$ 的所有 $2^3$ 种输入组合，展示至少一个对您 CNF 中所有变量（包括任何辅助变量以及输出 $s$ 和 $k$）的满足赋值，且该赋值与预期的全加器行为一致，来验证其正确性。\n- 令 $N_{\\mathrm{clauses}}$ 表示您 CNF 中子句的总数（每个子句只计算一次），令 $N_{\\mathrm{models}}$ 表示当输入 $a$、$b$ 和 $c$ 不受约束时（即，所有 $2^3$ 种输入组合都被允许且不需要额外约束），CNF 中所有变量的满足赋值的总数。计算乘积 $N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}}$。\n\n将最终答案表示为单个实数值。无需四舍五入。",
            "solution": "问题要求使用 Tseitin 变换推导一位全加器的合取范式（CNF）表示，验证该编码，并计算涉及 CNF 子句数量和满足模型总数的乘积。\n\n首先，我们必须定义一位全加器的布尔电路。该加法器有三个主输入 $a$、$b$ 和进位输入 $c$，以及两个主输出，和 $s$ 与进位输出 $k$。其逻辑函数为：\n$$s = a \\oplus b \\oplus c$$\n$$k = (a \\land b) \\lor (a \\land c) \\lor (b \\land c)$$\n\n对于 Tseitin 变换，我们需要一个门级实现。一个标准且高效的实现是使用两个异或门来计算和，并使用与门和或门的组合来计算进位。我们用辅助变量为内部节点定义电路如下：\n1.  一个异或门，用于计算 $a$ 和 $b$ 的和：$x_1 = a \\oplus b$。\n2.  第二个异或门，用于计算最终的和：$s = x_1 \\oplus c$。\n3.  一个与门，用于计算来自 $a$ 和 $b$ 的进位分量：$x_2 = a \\land b$。\n4.  一个与门，用于计算涉及 $c$ 的进位分量：$x_3 = x_1 \\land c$。这是因为 $k = (a \\land b) \\lor (c \\land (a \\oplus b))$。\n5.  一个或门，用于合并进位分量：$k = x_2 \\lor x_3$。\n\n我们模型中所有变量的集合是 $\\{a, b, c, x_1, x_2, x_3, s, k\\}$。共有 $3$ 个主输入、$3$ 个辅助变量和 $2$ 个主输出，总计 $8$ 个变量。\n\n现在，我们对每个门应用 Tseitin 变换来推导 CNF 子句。对于每个输出为 $y$、输入为 $i_1, i_2, \\dots$ 的门，我们为等价关系 $y \\leftrightarrow f(i_1, i_2, \\dots)$ 生成子句，这确保了 CNF 公式的任何满足赋值都尊重该门的功能。\n\n1.  **门 1: $x_1 = a \\oplus b$**\n    等价关系为 $x_1 \\leftrightarrow (a \\oplus b)$。一个双输入异或门 $(y \\leftrightarrow i_1 \\oplus i_2)$ 的标准 CNF 编码包含 $4$ 个子句：\n    -   $(\\neg x_1 \\lor a \\lor b)$\n    -   $(\\neg x_1 \\lor \\neg a \\lor \\neg b)$\n    -   $(x_1 \\lor \\neg a \\lor b)$\n    -   $(x_1 \\lor a \\lor \\neg b)$\n\n2.  **门 2: $s = x_1 \\oplus c$**\n    等价关系为 $s \\leftrightarrow (x_1 \\oplus c)$。这是另一个双输入异或门，产生 $4$ 个子句：\n    -   $(\\neg s \\lor x_1 \\lor c)$\n    -   $(\\neg s \\lor \\neg x_1 \\lor \\neg c)$\n    -   $(s \\lor \\neg x_1 \\lor c)$\n    -   $(s \\lor x_1 \\lor \\neg c)$\n\n3.  **门 3: $x_2 = a \\land b$**\n    等价关系为 $x_2 \\leftrightarrow (a \\land b)$。一个双输入与门 $(y \\leftrightarrow i_1 \\land i_2)$ 的标准 CNF 编码包含 $3$ 个子句：\n    -   $(\\neg x_2 \\lor a)$\n    -   $(\\neg x_2 \\lor b)$\n    -   $(x_2 \\lor \\neg a \\lor \\neg b)$\n\n4.  **门 4: $x_3 = x_1 \\land c$**\n    等价关系为 $x_3 \\leftrightarrow (x_1 \\land c)$。这是另一个双输入与门，产生 $3$ 个子句：\n    -   $(\\neg x_3 \\lor x_1)$\n    -   $(\\neg x_3 \\lor c)$\n    -   $(x_3 \\lor \\neg x_1 \\lor \\neg c)$\n\n5.  **门 5: $k = x_2 \\lor x_3$**\n    等价关系为 $k \\leftrightarrow (x_2 \\lor x_3)$。一个双输入或门 $(y \\leftrightarrow i_1 \\lor i_2)$ 的标准 CNF 编码包含 $3$ 个子句：\n    -   $(k \\lor \\neg x_2)$\n    -   $(k \\lor \\neg x_3)$\n    -   $(\\neg k \\lor x_2 \\lor x_3)$\n\n全加器的完整 CNF 编码是所有这些子句的合取。子句的总数 $N_{\\mathrm{clauses}}$ 是每个门的子句数之和：\n$$N_{\\mathrm{clauses}} = 4 + 4 + 3 + 3 + 3 = 17$$\n\n接下来，我们必须验证此编码的正确性。我们通过为 $(a, b, c)$ 的 $2^3 = 8$ 种可能输入组合中的每一种展示一个满足赋值来做到这一点。对于每个输入赋值，辅助变量和输出变量的值由电路逻辑唯一确定。下表显示了每种输入情况下所有 $8$ 个变量的唯一满足赋值。$s$ 和 $k$ 的值与标准全加器真值表一致。\n\n| $a$ | $b$ | $c$ | $x_1 = a \\oplus b$ | $x_2 = a \\land b$ | $s = x_1 \\oplus c$ | $x_3 = x_1 \\land c$ | $k = x_2 \\lor x_3$ |\n|---|---|---|---|---|---|---|---|\n| $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |\n| $0$ | $0$ | $1$ | $0$ | $0$ | $1$ | $0$ | $0$ |\n| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $0$ |\n| $0$ | $1$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ |\n| $1$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ | $0$ |\n| $1$ | $0$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ |\n| $1$ | $1$ | $0$ | $0$ | $1$ | $0$ | $0$ | $1$ |\n| $1$ | $1$ | $1$ | $0$ | $1$ | $1$ | $0$ | $1$ |\n\n此表中的每一行都代表对所有 $8$ 个变量的完整赋值。由于这些值是直接从门定义中派生出来的，并且 CNF 子句是这些定义的直接编码，因此这 $8$ 个赋值中的每一个都构成了 CNF 公式的一个满足模型。这验证了编码的正确性。\n\n最后，我们计算乘积 $N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}}$。我们已经确定 $N_{\\mathrm{clauses}} = 17$。$N_{\\mathrm{models}}$ 是在输入 $a$、$b$ 和 $c$ 不受约束的情况下，CNF 公式对所有 $8$ 个变量的满足赋值（模型）的总数。\n\nTseitin 变换确保对于任何给定的门输入赋值，输出变量的值被唯一确定，以使该赋值满足相应的子句。因为我们的电路是一个从主输入到主输出的有向无环图（DAG），所以对主输入 $(a, b, c)$ 的赋值通过逻辑传播链唯一地决定了所有内部和输出变量的值。\n\n对于输入 $(a, b, c)$ 的 $2^3 = 8$ 种可能赋值中的每一种，都存在唯一一个对应的对其余 $5$ 个变量 $(x_1, x_2, x_3, s, k)$ 的赋值，该赋值满足所有 CNF 子句。上面的验证表列出了这 $8$ 个唯一的赋值。不存在其他满足赋值。例如，如果我们固定 $(a, b, c)$ 但为某个内部变量（比如 $x_1$）选择一个与 $x_1=a \\oplus b$ 相矛盾的值，那么 CNF 中至少会有一个子句被违反。因此，对于不受约束的 CNF 公式，模型的总数恰好是可能的输入组合数。\n$$N_{\\mathrm{models}} = 2^3 = 8$$\n\n现在我们计算最终的乘积：\n$$N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}} = 17 \\cdot 8 = 136$$",
            "answer": "$$\n\\boxed{136}\n$$"
        },
        {
            "introduction": "现代硬件设计在数据字（bit-vectors）的层面上操作，而不仅仅是单个比特。这项实践将我们的关注点从布尔逻辑提升到字级层面，并利用“可满足性模理论”（SMT）的强大能力。你将解决一个经典且关键的硬件验证问题：检测加法器中的有符号算术溢出。通过直接在位向量理论中推导出一个形式化断言，你将学习SMT求解器如何对高级算术属性进行推理，而无需将所有操作“位爆炸”（bit-blast）成底层布尔门。",
            "id": "4295387",
            "problem": "设 $w \\ge 2$ 为一个固定的字宽。在可满足性模理论（Satisfiability Modulo Theories, SMT）中使用的固定大小位向量的无量词理论中，考虑两个 $w$ 位向量 $a$ 和 $b$，以及它们的模加和 $s = \\mathrm{bvadd}(a,b)$，该运算执行模 $2^{w}$ 的加法。将 $a$、$b$ 和 $s$ 以二进制补码形式解释为范围在 $\\left[-2^{w-1},\\,2^{w-1}-1\\right]$ 内的有符号整数，其中最高有效位是符号位。设 $\\operatorname{msb}(x)$ 表示一个 $w$ 位向量 $x$ 的最高有效位。\n\n你需要从二进制补码表示和模加法的核心定义出发，推导出一个用于检测有符号溢出的判定谓词，并从可满足性（Satisfiability, SAT）和可满足性模理论（SMT）的角度分析其可满足性属性。在位向量符号体系（signature）中进行操作，该体系允许提取位、使用布尔连接词以及运算符 $\\mathrm{bvadd}$；除了这些核心定义之外，不要假定任何更高级别的算术运算。\n\n任务：\n\n1) 从二进制补码的解释和模加法的定义出发，推导一个纯粹的位向量断言 $\\mathsf{OVF}_{w}(a,b)$，它当且仅当 $a$ 和 $b$ 的二进制补码加法溢出时为真。你的断言必须仅用 $\\operatorname{msb}(a)$、$\\operatorname{msb}(b)$、$\\operatorname{msb}(s)$、布尔连接词以及 $s = \\mathrm{bvadd}(a,b)$ 来表示，不得借助于任何更高级别的算术谓词，例如显式的有符号比较。\n\n2) 仅使用推导出的断言和核心定义，刻画在给定 $w$ 的情况下 SMT 公式 $\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ 何时是可满足的，并给出一个关于 $a$ 和 $b$ 的通用充分条件，当该条件与 $\\mathsf{OVF}_{w}(a,b)$ 合取时，使得该合取式不可满足。你的刻画应从二进制补码算术的第一性原理出发。\n\n3) 设 $\\#\\mathcal{M}_{w}$ 表示使 $\\mathsf{OVF}_{w}(a,b)$ 为真的 $w$ 位向量有序对 $(a,b)$ 的数量。通过直接从定义出发对模型进行计数，推导出 $\\#\\mathcal{M}_{w}$ 作为 $w$ 的函数的封闭形式表达式。你的推导除了基于第一性原理证明的对简单区域中整格点的基本计数外，不得调用任何预先记忆的计数公式。\n\n请提供你获得的 $\\#\\mathcal{M}_{w}$ 的封闭形式表达式作为最终答案。无需四舍五入。将最终答案表示为关于 $w$ 的单一解析表达式，不带单位。",
            "solution": "我们按顺序处理这三个任务来解答。设 $a$ 和 $b$ 是两个 $w$ 位向量，其中 $w \\ge 2$。设 $a_{i}$ 表示 $a$ 的第 $i$ 位，索引从 $a_{0}$（最低有效位）到 $a_{w-1}$（最高有效位）。最高有效位 $\\operatorname{msb}(x) = x_{w-1}$ 在二进制补码表示中充当符号位。位向量 $x$ 的整数值，记为 $\\operatorname{int}(x)$，由下式给出：\n$$\n\\operatorname{int}(x) = -x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i\n$$\n可表示整数的范围是 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$。模加和 $s = \\mathrm{bvadd}(a,b)$ 对应于无符号整数的模 $2^w$ 加法。当且仅当 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 的值超出了可表示范围时，发生有符号溢出。\n\n### 任务1：溢出谓词 $\\mathsf{OVF}_{w}(a,b)$ 的推导\n\n我们通过考虑操作数的符号来分析溢出条件，操作数的符号由其最高有效位决定。设 $a_{w-1} = \\operatorname{msb}(a)$，$b_{w-1} = \\operatorname{msb}(b)$，以及 $s_{w-1} = \\operatorname{msb}(s)$。\n\n1.  **两个正数（或零）相加：**\n    如果 $a_{w-1}=0$ 且 $b_{w-1}=0$，那么 $\\operatorname{int}(a) \\ge 0$ 且 $\\operatorname{int}(b) \\ge 0$。它们的和 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 也是非负的。如果这个和超过了可表示的最大正数值，即 $\\operatorname{int}(a) + \\operatorname{int}(b) > 2^{w-1}-1$，就会发生溢出，具体来说是正溢出。\n    在这种情况下，$\\operatorname{int}(a)$ 和 $\\operatorname{int}(b)$ 就是它们的无符号整数值。它们的和 $S = \\operatorname{int}(a) + \\operatorname{int}(b)$ 将是结果 $s$ 的无符号值，因为 $0 \\le S < 2^w-1$。如果 $S \\ge 2^{w-1}$，结果 $s$ 的最高有效位将为 $1$，即 $s_{w-1}=1$。这在二进制补码中表示一个负数，这对于两个正数之和是不正确的。因此，当且仅当结果看起来是负数时，发生溢出。\n    正溢出的条件是：$\\neg a_{w-1} \\land \\neg b_{w-1} \\land s_{w-1}$。\n\n2.  **两个负数相加：**\n    如果 $a_{w-1}=1$ 且 $b_{w-1}=1$，那么 $\\operatorname{int}(a) < 0$ 且 $\\operatorname{int}(b) < 0$。它们的和 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 也是负的。如果这个和小于可表示的最小负数值，即 $\\operatorname{int}(a) + \\operatorname{int}(b) < -2^{w-1}$，就会发生溢出，具体来说是负溢出。\n    真实和为 $\\operatorname{int}(a) + \\operatorname{int}(b)$。计算出的结果 $\\operatorname{int}(s)$ 通过模运算与真实和相关。具体来说，$\\operatorname{int}(a) + \\operatorname{int}(b) \\equiv \\operatorname{int}(s) \\pmod{2^w}$。如果没有溢出，和会保持在有效的负数范围内，结果 $s$ 也必须是负数，因此 $s_{w-1}=1$。如果发生负溢出，和会从最负的值“回绕”到正数范围。这意味着计算出的结果 $s$ 将有 $s_{w-1}=0$，看起来是非负的。\n    负溢出的条件是：$a_{w-1} \\land b_{w-1} \\land \\neg s_{w-1}$。\n\n3.  **符号相反的数相加：**\n    如果 $a_{w-1} \\neq b_{w-1}$，则一个数为非负数，另一个为负数。设 $\\operatorname{int}(a) \\ge 0$ 且 $\\operatorname{int}(b) < 0$。\n    我们有 $0 \\le \\operatorname{int}(a) \\le 2^{w-1}-1$ 和 $-2^{w-1} \\le \\operatorname{int}(b) \\le -1$。和的范围被界定为：\n    $$\n    0 + (-2^{w-1}) \\le \\operatorname{int}(a) + \\operatorname{int}(b) \\le (2^{w-1}-1) + (-1)\n    $$\n    $$\n    -2^{w-1} \\le \\operatorname{int}(a) + \\operatorname{int}(b) \\le 2^{w-1}-2\n    $$\n    和 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 始终在可表示范围 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$ 内。因此，当相加的数符号相反时，不可能发生溢出。\n\n结合正溢出和负溢出的条件，我们发现当且仅当操作数的符号相同，而结果的符号不同时，发生溢出。溢出谓词是这两个互斥溢出情况的析取：\n$$\n\\mathsf{OVF}_{w}(a,b) \\equiv (\\neg \\operatorname{msb}(a) \\land \\neg \\operatorname{msb}(b) \\land \\operatorname{msb}(s)) \\lor (\\operatorname{msb}(a) \\land \\operatorname{msb}(b) \\land \\neg \\operatorname{msb}(s))\n$$\n此表达式仅使用了指定的位向量操作和布尔连接词。\n\n### 任务2：可满足性与不可满足性分析\n\n**$\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ 的可满足性：**\n我们必须确定是否存在一对 $w$ 位向量 $(a,b)$，在给定的 $w \\ge 2$ 的情况下导致溢出。我们可以通过构造一个简单的正溢出例子来证明这一点。\n设 $\\operatorname{int}(a) = 1$ 且 $\\operatorname{int}(b) = 2^{w-1}-1$。\n对于 $w \\ge 2$，两者都是有效的正整数。\n$\\operatorname{msb}(a) = 0$ 且 $\\operatorname{msb}(b) = 0$。\n真实和为 $\\operatorname{int}(a) + \\operatorname{int}(b) = 1 + (2^{w-1}-1) = 2^{w-1}$。\n这个和超出了有效范围 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$，因此发生溢出。\n模加和 $s = \\mathrm{bvadd}(a,b)$ 对应于 $2^{w-1}$ 的位模式，即 $100...0$。在二进制补码中，$\\operatorname{int}(s) = -2^{w-1}$。因此，$\\operatorname{msb}(s)=1$。\n符号位元组为 $(\\operatorname{msb}(a), \\operatorname{msb}(b), \\operatorname{msb}(s)) = (0, 0, 1)$，这满足条件 $\\neg \\operatorname{msb}(a) \\land \\neg \\operatorname{msb}(b) \\land \\operatorname{msb}(s)$。\n由于对于任何 $w \\ge 2$ 都可以构造出这样的一对 $(a,b)$，因此公式 $\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ 对所有 $w \\ge 2$ 都是可满足的。\n\n**不可满足性的充分条件：**\n我们寻找一个条件 $\\phi(a,b)$，使得公式 $\\phi(a,b) \\land \\mathsf{OVF}_{w}(a,b)$ 是不可满足的。根据我们在任务1中的推导，我们已经确定，如果操作数 $a$ 和 $b$ 的符号不同，溢出是不可能的。这个条件可以表示为 $\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)$，或者使用布尔连接词，$\\operatorname{msb}(a) \\oplus \\operatorname{msb}(b)$。\n如果我们将这个条件与溢出谓词进行合取：\n$$\n(\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)) \\land \\mathsf{OVF}_{w}(a,b)\n$$\n第一部分要求符号不同。第二部分 $\\mathsf{OVF}_{w}(a,b)$ 仅当符号相同时（$\\neg a_{w-1} \\land \\neg b_{w-1}$ 或 $a_{w-1} \\land b_{w-1}$）才可能为真。这是一个直接的矛盾。因此，使 $\\mathsf{OVF}_{w}(a,b)$ 在合取后变得不可满足的关于 $a$ 和 $b$ 的一个充分条件是 $a$ 和 $b$ 具有不同的符号，即 $\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)$。\n\n### 任务3：$\\#\\mathcal{M}_{w}$ 的推导\n\n我们需要计算使 $\\mathsf{OVF}_{w}(a,b)$ 为真的 $w$ 位向量有序对 $(a,b)$ 的数量。我们可以将两个不相交的情况的计数相加：正溢出（$N_{pos}$）和负溢出（$N_{neg}$）。设 $N = 2^{w-1}$。\n\n**1. 计数正溢出（$N_{pos}$）：**\n这种情况发生在和过大的非负整数对上。操作数必须满足 $\\operatorname{msb}(a)=0$ 和 $\\operatorname{msb}(b)=0$。这对应于整数值 $\\operatorname{int}(a)=x$ 和 $\\operatorname{int}(b)=y$，其中 $x, y \\in \\{0, 1, \\dots, N-1\\}$。$x$ 有 $N$ 个这样的值，$y$ 也有 $N$ 个，总共有 $N^2$ 对。\n如果 $x+y > N-1$，即 $x+y \\ge N$，则发生溢出。\n更容易的方法是计算不溢出的数对，其中 $x+y \\le N-1$，然后从总数中减去。\n对于一个固定的 $x \\in \\{0, \\dots, N-1\\}$，$y$ 必须满足 $0 \\le y \\le N-1-x$。$y$ 的可能值的数量是 $(N-1-x) + 1 = N-x$。\n不溢出数对的总数是所有可能的 $x$ 的和：\n$$\n\\sum_{x=0}^{N-1} (N-x) = N + (N-1) + \\dots + 1 = \\sum_{k=1}^{N} k = \\frac{N(N+1)}{2}\n$$\n溢出数对的数量是总数对减去不溢出的数对：\n$$\nN_{pos} = N^2 - \\frac{N(N+1)}{2} = \\frac{2N^2 - N^2 - N}{2} = \\frac{N^2 - N}{2} = \\frac{N(N-1)}{2}\n$$\n\n**2. 计数负溢出（$N_{neg}$）：**\n这种情况发生在和过小的负整数对上。操作数必须满足 $\\operatorname{msb}(a)=1$ 和 $\\operatorname{msb}(b)=1$。这对应于整数值 $\\operatorname{int}(a)=x$ 和 $\\operatorname{int}(b)=y$，其中 $x, y \\in \\{-N, \\dots, -1\\}$。$x$ 有 $N$ 个这样的值，$y$ 也有 $N$ 个，总共有 $N^2$ 对。\n如果 $x+y < -N$，则发生溢出。\n为简化计数，我们使用正变量 $x' = -x$ 和 $y' = -y$，其中 $x', y' \\in \\{1, \\dots, N\\}$。溢出条件变为 $-x' - y' < -N$，这等价于 $x' + y' > N$。\n我们需要计算在正方形 $[1, N] \\times [1, N]$ 中满足 $x' + y' \\ge N+1$ 的整数对 $(x', y')$ 的数量。\n对于一个固定的 $x' \\in \\{1, \\dots, N\\}$，$y'$ 必须满足 $y' \\ge N+1-x'$。由于 $y' \\le N$，$y'$ 的可能值的数量是 $N - (N+1-x') + 1 = x'$。\n总计数 $N_{neg}$ 是所有可能的 $x'$ 的和：\n$$\nN_{neg} = \\sum_{x'=1}^{N} x' = \\frac{N(N+1)}{2}\n$$\n\n**3. 总计数 $\\#\\mathcal{M}_{w}$：**\n溢出数对的总数是两种情况计数之和：\n$$\n\\#\\mathcal{M}_{w} = N_{pos} + N_{neg} = \\frac{N(N-1)}{2} + \\frac{N(N+1)}{2}\n$$\n$$\n\\#\\mathcal{M}_{w} = \\frac{N^2 - N + N^2 + N}{2} = \\frac{2N^2}{2} = N^2\n$$\n将 $N=2^{w-1}$ 代回表达式中：\n$$\n\\#\\mathcal{M}_{w} = (2^{w-1})^2 = 2^{2(w-1)} = 2^{2w-2}\n$$\n因此，导致有符号溢出的有序对 $(a,b)$ 的数量是 $2^{2w-2}$。",
            "answer": "$$\\boxed{2^{2w-2}}$$"
        },
        {
            "introduction": "在探索了如何为SAT和SMT求解器建模硬件属性之后，我们现在将目光投向这些求解器在高级自动化验证算法中的应用。这项实践为你提供了一个了解属性导向可达性（Property Directed Reachability, PDR）算法内部工作原理的窗口，这是一种用于证明安全属性的先进技术。你将模拟PDR算法中的一个关键步骤：通过生成并分析一个前驱状态SAT查询来阻塞一个潜在的反例。这个练习将具体展示PDR算法是如何通过增量式地构建归纳不变量来证明设计正确性的。",
            "id": "4295406",
            "problem": "考虑一个同步转换系统，该系统为一个带有环境控制使能信号的单锁存器翻转电路建模。状态由一个布尔锁存器 $s \\in \\{0,1\\}$ 和一个布尔输入 $en \\in \\{0,1\\}$ 组成。转换关系由下一状态更新公式 $s' = s \\oplus en$ 给出，其中 $\\oplus$ 表示布尔异或。初始条件为 $I(s) \\equiv (s = 0)$。环境在所有时间步都遵循假设 $A(en) \\equiv (en = 0)$。需要验证的安全性属性是不变量 $P(s) \\equiv (\\lnot s)$，意味着在所有可达状态中，锁存器 $s$ 必须保持为 $0$。\n\n属性导向可达性 (Property Directed Reachability, PDR) 是一种归纳不变量生成方法，它维护一个过近似帧的序列 $\\{F_{i}\\}$，满足 $F_{0} \\equiv I$ 和对于所有 $i \\geq 1$ 都有 $F_{i} \\subseteq P$，并使用布尔可满足性问题 (SAT) 查询通过前驱分析来阻塞反例。假设第一个帧 $F_{1}$ 最初相对于 $s$ 是不受约束的（也就是说，它尚未包含强制执行 $P$ 的归纳子句），因此在层级 $1$ 的一个潜在坏立方体 $c$ 是文字 $(s = 1)$，它违反了 $P$。\n\n模拟 PDR 的一次迭代，该迭代试图通过检查来自 $F_{0}$ 的前驱来阻塞层级 $1$ 的这个坏立方体 $c$。根据转换关系和环境假设，构建前驱 SAT 查询：\n$$\nI(s) \\,\\land\\, A(en) \\,\\land\\, T(s,en,s') \\,\\land\\, c'(s'),\n$$\n其中 $c'(s')$ 是立方体 $c$ 的加撇版本，$T(s,en,s')$ 编码了 $s' = s \\oplus en$。判断此查询是否可满足。如果不可满足，推导出 PDR 添加到 $F_{1}$ 中以阻塞 $c$ 的子句（仅用当前状态变量表示），并将其作为最终答案提供。最终答案必须是单一的封闭形式 LaTeX 布尔表达式。无需数值四舍五入，也无单位适用。",
            "solution": "目标是模拟 PDR 算法的单步迭代以阻塞一个坏立方体。坏立方体 $c$ 代表一个违反安全性属性 $P(s) \\equiv (\\lnot s)$ 的状态。该属性要求 $s$ 始终为 $0$，因此违反它的状态是 $s=1$ 的状态。给定的坏立方体是 $c \\equiv (s=1)$。\n\nPDR 试图在层级 $1$ 阻塞这个坏立方体，方法是检查它是否可以从前一帧 $F_0$ 中的某个状态到达。这个检查被表述为一个布尔可满足性 (SAT) 问题。该查询确定是否存在一个满足 $F_0$ 条件的状态 $s$，一个满足环境假设 $A(en)$ 的输入 $en$，以及一个满足坏立方体 $c'(s')$ 的下一状态 $s'$，使得 $(s, en, s')$ 根据 $T$ 是一个有效的转换。\n\nSAT 查询的组成部分是：\n$1.$ 初始条件帧 $F_0$：$I(s) \\equiv (s=0)$。\n$2.$ 环境假设：$A(en) \\equiv (en=0)$。\n$3.$ 转换关系：$T(s,en,s') \\equiv (s' = s \\oplus en)$。\n$4.$ 坏立方体的加撇版本，代表目标违反属性的状态：$c'(s') \\equiv (s'=1)$。\n\n完整的 SAT 查询是这四个谓词的合取：\n$$\n\\Phi \\equiv I(s) \\land A(en) \\land T(s,en,s') \\land c'(s')\n$$\n代入具体定义，查询变为：\n$$\n\\Phi \\equiv (s=0) \\land (en=0) \\land (s' = s \\oplus en) \\land (s'=1)\n$$\n为了确定 $\\Phi$ 的可满足性，我们可以将变量 $s$、$en$ 和 $s'$ 的约束代入转换关系中。\n从 $I(s)$，我们有约束 $s=0$。\n从 $A(en)$，我们有约束 $en=0$。\n从 $c'(s')$，我们有约束 $s'=1$。\n\n将 $s=0$ 和 $en=0$ 代入转换关系 $s' = s \\oplus en$ 得出：\n$$\ns' = 0 \\oplus 0\n$$\n异或运算 $0 \\oplus 0$ 的结果为 $0$。因此，在这些约束下，转换关系简化为 $s'=0$。\n\n我们现在对下一状态 $s'$ 有两个相互矛盾的要求：\n- 从坏立方体 $c'$，我们要求 $s'=1$。\n- 从 $F_0$ 中一个状态在假设的环境下进行转换，我们推导出 $s'=0$。\n\n合取式 $(s'=1) \\land (s'=0)$ 是一个逻辑矛盾，等价于 `False`。因此，整个公式 $\\Phi$ 是不可满足的。\n\n在 PDR 的背景下，一个不可满足的前驱查询证明了坏立方体 $c$ 不能在一步内从帧 $F_0$ 到达。这意味着没有满足 $F_0$ 的状态可以转换到满足 $c$ 的状态。因为 $c$ 从 $F_0$ 不可达，PDR 可以通过向下一帧 $F_1$ 添加一个排除它的子句来“阻塞” $c$。\n\n坏立方体是 $c \\equiv (s=1)$。一个子句是文字的析取。为了阻塞或排除立方体 $c$，我们将其否定 $\\lnot c$ 作为一个新子句添加到 $F_1$ 中。\n要添加的子句是：\n$$\n\\lnot c \\equiv \\lnot(s=1)\n$$\n这在逻辑上等价于 $(s=0)$。在此上下文中常用的布尔逻辑表示法中，一个变量代表它为真（即等于 $1$）的命题，这个子句被写作 $\\lnot s$。\n\n这个新子句 $\\lnot s$ 被添加到定义 $F_1$ 的子句集合中。这通过确保任何满足 $F_1$ 条件的状态也必须满足 $\\lnot s$ 来加强 $F_1$，从而防止从 $F_1$ 开始的算法后续步骤中考虑由 $c$ 代表的属性违规。\n该子句按要求仅用当前状态变量 $s$ 表示。",
            "answer": "$$\n\\boxed{\\lnot s}\n$$"
        }
    ]
}