{
    "hands_on_practices": [
        {
            "introduction": "Before a SAT solver can analyze a digital circuit, the design must first be translated into the solver's native language: Conjunctive Normal Form (CNF). This exercise guides you through this fundamental encoding process using a one-bit full adder, a cornerstone of computer arithmetic. By applying the systematic Tseitin transformation, you will convert the circuit's gate-level logic into an equisatisfiable set of clauses, making its behavior ready for automated reasoning.",
            "id": "4295338",
            "problem": "Consider a one-bit full adder implemented as a Boolean circuit with three primary inputs $a$, $b$, and $c$ (where $c$ is the carry-in), and two primary outputs $s$ (the sum bit) and $k$ (the carry-out bit). In the context of Electronic Design Automation (EDA) and Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) methods for hardware verification, the circuit must be encoded into Conjunctive Normal Form (CNF) for use with a Boolean satisfiability solver. Start from the fundamental definitions of Boolean semantics of $\\land$, $\\lor$, and $\\oplus$, the definition of CNF as a conjunction of disjunctions of literals, and the standard approach of Tseitin transformation introducing auxiliary variables to represent internal gate outputs while preserving equisatisfiability. \n\nYour tasks are:\n- Derive a CNF encoding of the one-bit full adder that enforces the semantics of $s$ and $k$ strictly according to the Boolean circuit meaning, using a Tseitin-style introduction of auxiliary variables for internal nodes. Each gate’s functional equivalence must be captured by CNF clauses that constrain its output variable in terms of its input variables.\n- Verify correctness by exhibiting, for all $2^3$ input combinations for $(a,b,c)$, at least one satisfying assignment to all variables in your CNF (including any auxiliary variables and the outputs $s$ and $k$) that is consistent with the intended full-adder behavior.\n- Let $N_{\\mathrm{clauses}}$ denote the total number of clauses in your CNF (count every clause exactly once), and let $N_{\\mathrm{models}}$ denote the total number of satisfying assignments to all variables in the CNF when the inputs $a$, $b$, and $c$ are left unconstrained (i.e., all $2^3$ input combinations are admitted and do not require additional constraints). Compute the product $N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}}$.\n\nExpress the final answer as a single real-valued number. No rounding is necessary.",
            "solution": "The problem requires the derivation of a Conjunctive Normal Form (CNF) representation for a one-bit full adder using the Tseitin transformation, verification of the encoding, and the calculation of a product involving the number of CNF clauses and the total number of satisfying models.\n\nFirst, we must define the Boolean circuit for the one-bit full adder. The adder has three primary inputs, $a$, $b$, and the carry-in $c$, and two primary outputs, the sum $s$ and the carry-out $k$. The logical functions are:\n$$s = a \\oplus b \\oplus c$$\n$$k = (a \\land b) \\lor (a \\land c) \\lor (b \\land c)$$\n\nFor the Tseitin transformation, we need a gate-level implementation. A standard and efficient implementation uses two XOR gates for the sum and a combination of AND and OR gates for the carry. Let's define the circuit with auxiliary variables for the internal nodes:\n1.  An XOR gate to compute the sum of $a$ and $b$: $x_1 = a \\oplus b$.\n2.  A second XOR gate to compute the final sum: $s = x_1 \\oplus c$.\n3.  An AND gate for the carry component from $a$ and $b$: $x_2 = a \\land b$.\n4.  An AND gate for the carry component involving $c$: $x_3 = x_1 \\land c$. This is because $k = (a \\land b) \\lor (c \\land (a \\oplus b))$.\n5.  An OR gate to combine the carry components: $k = x_2 \\lor x_3$.\n\nThe set of all variables in our model is $\\{a, b, c, x_1, x_2, x_3, s, k\\}$. There are $3$ primary inputs, $3$ auxiliary variables, and $2$ primary outputs, for a total of $8$ variables.\n\nNow, we apply the Tseitin transformation to each gate to derive the CNF clauses. For each gate with output $y$ and inputs $i_1, i_2, \\dots$, we generate clauses for the equivalence $y \\leftrightarrow f(i_1, i_2, \\dots)$, which ensures that any satisfying assignment to the CNF formula respects the gate's functionality.\n\n1.  **Gate 1: $x_1 = a \\oplus b$**\n    The equivalence is $x_1 \\leftrightarrow (a \\oplus b)$. The standard CNF encoding for a two-input XOR gate, $(y \\leftrightarrow i_1 \\oplus i_2)$, consists of $4$ clauses:\n    -   $(\\neg x_1 \\lor a \\lor b)$\n    -   $(\\neg x_1 \\lor \\neg a \\lor \\neg b)$\n    -   $(x_1 \\lor \\neg a \\lor b)$\n    -   $(x_1 \\lor a \\lor \\neg b)$\n\n2.  **Gate 2: $s = x_1 \\oplus c$**\n    The equivalence is $s \\leftrightarrow (x_1 \\oplus c)$. This is another two-input XOR gate, yielding $4$ clauses:\n    -   $(\\neg s \\lor x_1 \\lor c)$\n    -   $(\\neg s \\lor \\neg x_1 \\lor \\neg c)$\n    -   $(s \\lor \\neg x_1 \\lor c)$\n    -   $(s \\lor x_1 \\lor \\neg c)$\n\n3.  **Gate 3: $x_2 = a \\land b$**\n    The equivalence is $x_2 \\leftrightarrow (a \\land b)$. The standard CNF encoding for a two-input AND gate, $(y \\leftrightarrow i_1 \\land i_2)$, consists of $3$ clauses:\n    -   $(\\neg x_2 \\lor a)$\n    -   $(\\neg x_2 \\lor b)$\n    -   $(x_2 \\lor \\neg a \\lor \\neg b)$\n\n4.  **Gate 4: $x_3 = x_1 \\land c$**\n    The equivalence is $x_3 \\leftrightarrow (x_1 \\land c)$. This is another two-input AND gate, yielding $3$ clauses:\n    -   $(\\neg x_3 \\lor x_1)$\n    -   $(\\neg x_3 \\lor c)$\n    -   $(x_3 \\lor \\neg x_1 \\lor \\neg c)$\n\n5.  **Gate 5: $k = x_2 \\lor x_3$**\n    The equivalence is $k \\leftrightarrow (x_2 \\lor x_3)$. The standard CNF encoding for a two-input OR gate, $(y \\leftrightarrow i_1 \\lor i_2)$, consists of $3$ clauses:\n    -   $(k \\lor \\neg x_2)$\n    -   $(k \\lor \\neg x_3)$\n    -   $(\\neg k \\lor x_2 \\lor x_3)$\n\nThe complete CNF encoding for the full adder is the conjunction of all these clauses. The total number of clauses, $N_{\\mathrm{clauses}}$, is the sum of the clauses from each gate:\n$$N_{\\mathrm{clauses}} = 4 + 4 + 3 + 3 + 3 = 17$$\n\nNext, we must verify the correctness of this encoding. We do this by exhibiting a satisfying assignment for each of the $2^3 = 8$ possible input combinations for $(a, b, c)$. For each input assignment, the values of the auxiliary and output variables are uniquely determined by the circuit logic. The following table shows the unique satisfying assignment for all $8$ variables for each input case. The values for $s$ and $k$ are consistent with the standard full-adder truth table.\n\n| $a$ | $b$ | $c$ | $x_1 = a \\oplus b$ | $x_2 = a \\land b$ | $s = x_1 \\oplus c$ | $x_3 = x_1 \\land c$ | $k = x_2 \\lor x_3$ |\n|---|---|---|---|---|---|---|---|\n| $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |\n| $0$ | $0$ | $1$ | $0$ | $0$ | $1$ | $0$ | $0$ |\n| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $0$ |\n| $0$ | $1$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ |\n| $1$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ | $0$ |\n| $1$ | $0$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ |\n| $1$ | $1$ | $0$ | $0$ | $1$ | $0$ | $0$ | $1$ |\n| $1$ | $1$ | $1$ | $0$ | $1$ | $1$ | $0$ | $1$ |\n\nEach row in this table represents a complete assignment to all $8$ variables. Since these values are derived directly from the gate definitions, and the CNF clauses are a direct encoding of these definitions, each of these $8$ assignments constitutes a satisfying model for the CNF formula. This verifies the correctness of the encoding.\n\nFinally, we compute the product $N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}}$. We have already determined $N_{\\mathrm{clauses}} = 17$. $N_{\\mathrm{models}}$ is the total number of satisfying assignments (models) for the CNF formula over all $8$ variables, with the inputs $a$, $b$, and $c$ unconstrained.\n\nThe Tseitin transformation ensures that for any given assignment to the inputs of a gate, the value of the output variable is uniquely determined for the assignment to satisfy the corresponding clauses. Because our circuit is a directed acyclic graph (DAG) from primary inputs to primary outputs, an assignment to the primary inputs $(a, b, c)$ uniquely determines the values of all internal and output variables through a chain of logical propagation.\n\nFor each of the $2^3 = 8$ possible assignments to the inputs $(a, b, c)$, there exists exactly one corresponding assignment for the remaining $5$ variables $(x_1, x_2, x_3, s, k)$ that satisfies all the CNF clauses. The verification table above lists these $8$ unique assignments. There are no other satisfying assignments. For example, if we were to fix $(a, b, c)$ but choose a value for an internal variable, say $x_1$, that contradicts $x_1=a \\oplus b$, at least one clause in the CNF would be violated. Therefore, the total number of models for the unconstrained CNF formula is exactly the number of possible input combinations.\n$$N_{\\mathrm{models}} = 2^3 = 8$$\n\nNow we compute the final product:\n$$N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}} = 17 \\cdot 8 = 136$$",
            "answer": "$$\n\\boxed{136}\n$$"
        },
        {
            "introduction": "While SAT operates on raw Booleans, SMT solvers provide the power to reason about higher-level concepts like arithmetic directly. This practice moves into the SMT domain by using the theory of fixed-size bit-vectors to tackle a critical problem in hardware design: detecting signed integer overflow. You will derive the precise logical predicate for overflow from first principles and see how SMT can be used to formally analyze and count the exact number of input pairs that trigger this bug.",
            "id": "4295387",
            "problem": "Let $w \\ge 2$ be a fixed word width. In the quantifier-free theory of fixed-size bit-vectors used in Satisfiability Modulo Theories (SMT), consider two $w$-bit vectors $a$ and $b$, and their modular sum $s = \\mathrm{bvadd}(a,b)$, which performs addition modulo $2^{w}$. Interpret $a$, $b$, and $s$ in two’s complement as signed integers in the range $\\left[-2^{w-1},\\,2^{w-1}-1\\right]$, where the most significant bit is the sign bit. Let $\\operatorname{msb}(x)$ denote the most significant bit of a $w$-bit vector $x$.\n\nYou are to reason from core definitions of two’s complement representation and modular addition to derive a detection predicate for signed overflow and analyze its satisfiability properties in the sense of Satisfiability (SAT) and Satisfiability Modulo Theories (SMT). Work in the bit-vector signature that allows extracting bits, Boolean connectives, and the operator $\\mathrm{bvadd}$; do not assume any higher-level arithmetic beyond these core definitions.\n\nTasks:\n\n1) Starting from the two’s complement interpretation and the definition of modular addition, derive a pure bit-vector assertion $\\mathsf{OVF}_{w}(a,b)$ that is true if and only if the two’s complement addition of $a$ and $b$ overflows. Your assertion must be expressed only in terms of $\\operatorname{msb}(a)$, $\\operatorname{msb}(b)$, $\\operatorname{msb}(s)$, Boolean connectives, and $s = \\mathrm{bvadd}(a,b)$, without appealing to any higher-level arithmetic predicates such as explicit signed comparisons.\n\n2) Using only the derived assertion and the core definitions, characterize when the SMT formula $\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ is satisfiable for a given $w$, and give at least one general sufficient condition on $a$ and $b$ that makes $\\mathsf{OVF}_{w}(a,b)$ unsatisfiable when conjoined. Your characterization should follow from first principles of two’s complement arithmetic.\n\n3) Let $\\#\\mathcal{M}_{w}$ denote the number of ordered pairs $(a,b)$ of $w$-bit vectors for which $\\mathsf{OVF}_{w}(a,b)$ is true. Derive a closed-form expression for $\\#\\mathcal{M}_{w}$ as a function of $w$ by counting models directly from the definitions. Your derivation must not invoke any pre-memorized counting formulas beyond the basic counting of integer lattice points in simple regions, justified from first principles.\n\nProvide as your final answer the closed-form expression you obtain for $\\#\\mathcal{M}_{w}$. No rounding is required. Express the final answer as a single analytic expression in terms of $w$ with no units.",
            "solution": "Let us proceed with the solution, addressing each of the three tasks in sequence. Let $a$ and $b$ be two $w$-bit vectors, with $w \\ge 2$. Let $a_{i}$ denote the $i$-th bit of $a$, indexed from $a_{0}$ (least significant bit) to $a_{w-1}$ (most significant bit). The most significant bit, $\\operatorname{msb}(x) = x_{w-1}$, serves as the sign bit in the two's complement representation. The integer value of a bit-vector $x$, denoted $\\operatorname{int}(x)$, is given by:\n$$\n\\operatorname{int}(x) = -x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i\n$$\nThe range of representable integers is $\\left[-2^{w-1}, 2^{w-1}-1\\right]$. The modular sum $s = \\mathrm{bvadd}(a,b)$ corresponds to unsigned integer addition modulo $2^w$. A signed overflow occurs if and only if $\\operatorname{int}(a) + \\operatorname{int}(b)$ falls outside the representable range.\n\n### Task 1: Derivation of the Overflow Predicate $\\mathsf{OVF}_{w}(a,b)$\n\nWe analyze the conditions for overflow by considering the signs of the operands, which are determined by their most significant bits. Let $a_{w-1} = \\operatorname{msb}(a)$, $b_{w-1} = \\operatorname{msb}(b)$, and $s_{w-1} = \\operatorname{msb}(s)$.\n\n1.  **Adding two positive numbers (or zero):**\n    If $a_{w-1}=0$ and $b_{w-1}=0$, then $\\operatorname{int}(a) \\ge 0$ and $\\operatorname{int}(b) \\ge 0$. The sum $\\operatorname{int}(a) + \\operatorname{int}(b)$ is also non-negative. An overflow, specifically a positive overflow, occurs if this sum exceeds the maximum representable positive value, i.e., $\\operatorname{int}(a) + \\operatorname{int}(b) > 2^{w-1}-1$.\n    In this case, $\\operatorname{int}(a)$ and $\\operatorname{int}(b)$ are simply their unsigned integer values. Their sum, $S = \\operatorname{int}(a) + \\operatorname{int}(b)$, will be the unsigned value of the result $s$, since $0 \\le S < 2^w$. If $S \\ge 2^{w-1}$, the most significant bit of the result $s$ will be $1$, so $s_{w-1}=1$. This signifies a negative number in two's complement, which is incorrect for the sum of two positives. Therefore, overflow occurs if and only if the result appears negative.\n    The condition for positive overflow is: $\\neg a_{w-1} \\land \\neg b_{w-1} \\land s_{w-1}$.\n\n2.  **Adding two negative numbers:**\n    If $a_{w-1}=1$ and $b_{w-1}=1$, then $\\operatorname{int}(a) < 0$ and $\\operatorname{int}(b) < 0$. The sum $\\operatorname{int}(a) + \\operatorname{int}(b)$ is also negative. An overflow, specifically a negative overflow, occurs if this sum is less than the minimum representable negative value, i.e., $\\operatorname{int}(a) + \\operatorname{int}(b) < -2^{w-1}$.\n    The true sum is $\\operatorname{int}(a) + \\operatorname{int}(b)$. The computed result $\\operatorname{int}(s)$ is related to the true sum by modular arithmetic. Specifically, $\\operatorname{int}(a) + \\operatorname{int}(b) \\equiv \\operatorname{int}(s) \\pmod{2^w}$. If there is no overflow, the sum remains in the valid negative range, and the result $s$ must also be negative, so $s_{w-1}=1$. If a negative overflow occurs, the sum \"wraps around\" from the most negative values to the positive range. This means the computed result $s$ will have $s_{w-1}=0$, appearing to be non-negative.\n    The condition for negative overflow is: $a_{w-1} \\land b_{w-1} \\land \\neg s_{w-1}$.\n\n3.  **Adding numbers with opposite signs:**\n    If $a_{w-1} \\neq b_{w-1}$, one number is non-negative and the other is negative. Let $\\operatorname{int}(a) \\ge 0$ and $\\operatorname{int}(b) < 0$.\n    We have $0 \\le \\operatorname{int}(a) \\le 2^{w-1}-1$ and $-2^{w-1} \\le \\operatorname{int}(b) \\le -1$.\n    The sum is bounded by:\n    $$\n    0 + (-2^{w-1}) \\le \\operatorname{int}(a) + \\operatorname{int}(b) \\le (2^{w-1}-1) + (-1)\n    $$\n    $$\n    -2^{w-1} \\le \\operatorname{int}(a) + \\operatorname{int}(b) \\le 2^{w-1}-2\n    $$\n    The sum $\\operatorname{int}(a) + \\operatorname{int}(b)$ is always within the representable range $\\left[-2^{w-1}, 2^{w-1}-1\\right]$. Thus, no overflow can occur when adding numbers of opposite signs.\n\nCombining the conditions for positive and negative overflow, we find that overflow occurs if and only if the signs of the operands are the same, and the sign of the result is different. The overflow predicate is the disjunction of the two mutually exclusive overflow cases:\n$$\n\\mathsf{OVF}_{w}(a,b) \\equiv (\\neg \\operatorname{msb}(a) \\land \\neg \\operatorname{msb}(b) \\land \\operatorname{msb}(s)) \\lor (\\operatorname{msb}(a) \\land \\operatorname{msb}(b) \\land \\neg \\operatorname{msb}(s))\n$$\nThis expression uses only the specified bit-vector operations and Boolean connectives.\n\n### Task 2: Satisfiability and Unsatisfiability Analysis\n\n**Satisfiability of $\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$:**\nWe must determine if there exists a pair of $w$-bit vectors $(a,b)$ that causes an overflow for a given $w \\ge 2$. We can demonstrate this by constructing a simple example of positive overflow.\nLet $\\operatorname{int}(a) = 1$ and $\\operatorname{int}(b) = 2^{w-1}-1$.\nFor $w \\ge 2$, both are valid positive integers.\n$\\operatorname{msb}(a) = 0$ and $\\operatorname{msb}(b) = 0$.\nThe true sum is $\\operatorname{int}(a) + \\operatorname{int}(b) = 1 + (2^{w-1}-1) = 2^{w-1}$.\nThis sum is outside the valid range $\\left[-2^{w-1}, 2^{w-1}-1\\right]$, so an overflow occurs.\nThe modular sum $s = \\mathrm{bvadd}(a,b)$ corresponds to the bit pattern for $2^{w-1}$, which is $100...0$. In two's complement, $\\operatorname{int}(s) = -2^{w-1}$. Thus, $\\operatorname{msb}(s)=1$.\nThe tuple of sign bits is $(\\operatorname{msb}(a), \\operatorname{msb}(b), \\operatorname{msb}(s)) = (0, 0, 1)$, which satisfies the condition $\\neg \\operatorname{msb}(a) \\land \\neg \\operatorname{msb}(b) \\land \\operatorname{msb}(s)$.\nSince such a pair $(a,b)$ can be constructed for any $w \\ge 2$, the formula $\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ is satisfiable for all $w \\ge 2$.\n\n**Sufficient condition for unsatisfiability:**\nWe seek a condition $\\phi(a,b)$ such that the formula $\\phi(a,b) \\land \\mathsf{OVF}_{w}(a,b)$ is unsatisfiable. From our derivation in Task 1, we established that overflow is impossible if the operands $a$ and $b$ have different signs. This condition can be expressed as $\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)$, or using Boolean connectives, $\\operatorname{msb}(a) \\oplus \\operatorname{msb}(b)$.\nIf we conjoin this condition with the overflow predicate:\n$$\n(\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)) \\land \\mathsf{OVF}_{w}(a,b)\n$$\nThe first part requires the signs to be different. The second part, $\\mathsf{OVF}_{w}(a,b)$, can only be true if the signs are the same ($\\neg a_{w-1} \\land \\neg b_{w-1}$ or $a_{w-1} \\land b_{w-1}$). This is a direct contradiction. Therefore, a sufficient condition on $a$ and $b$ that makes $\\mathsf{OVF}_{w}(a,b)$ unsatisfiable when conjoined is that $a$ and $b$ have different signs, i.e., $\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)$.\n\n### Task 3: Derivation of $\\#\\mathcal{M}_{w}$\n\nWe need to count the number of ordered pairs $(a,b)$ of $w$-bit vectors for which $\\mathsf{OVF}_{w}(a,b)$ is true. We can sum the counts for the two disjoint cases: positive overflow ($N_{pos}$) and negative overflow ($N_{neg}$). Let $N = 2^{w-1}$.\n\n**1. Counting Positive Overflows ($N_{pos}$):**\nThis occurs for pairs of non-negative integers whose sum is too large. The operands must satisfy $\\operatorname{msb}(a)=0$ and $\\operatorname{msb}(b)=0$. This corresponds to integer values $\\operatorname{int}(a)=x$ and $\\operatorname{int}(b)=y$ where $x, y \\in \\{0, 1, \\dots, N-1\\}$. There are $N$ such values for $x$ and $N$ for $y$, making $N^2$ total pairs.\nOverflow occurs if $x+y > N-1$, i.e., $x+y \\ge N$.\nIt is easier to count the non-overflowing pairs, where $x+y \\le N-1$, and subtract from the total.\nFor a fixed $x \\in \\{0, \\dots, N-1\\}$, $y$ must satisfy $0 \\le y \\le N-1-x$. The number of possible values for $y$ is $(N-1-x) + 1 = N-x$.\nThe total number of non-overflowing pairs is the sum over all possible $x$:\n$$\n\\sum_{x=0}^{N-1} (N-x) = N + (N-1) + \\dots + 1 = \\sum_{k=1}^{N} k = \\frac{N(N+1)}{2}\n$$\nThe number of overflowing pairs is the total number of pairs minus the non-overflowing ones:\n$$\nN_{pos} = N^2 - \\frac{N(N+1)}{2} = \\frac{2N^2 - N^2 - N}{2} = \\frac{N^2 - N}{2} = \\frac{N(N-1)}{2}\n$$\n\n**2. Counting Negative Overflows ($N_{neg}$):**\nThis occurs for pairs of negative integers whose sum is too small. The operands must satisfy $\\operatorname{msb}(a)=1$ and $\\operatorname{msb}(b)=1$. This corresponds to integer values $\\operatorname{int}(a)=x$ and $\\operatorname{int}(b)=y$ where $x, y \\in \\{-N, \\dots, -1\\}$. There are $N$ such values for $x$ and $N$ for $y$, making $N^2$ total pairs.\nOverflow occurs if $x+y  -N$.\nTo simplify counting, let's use positive variables $x' = -x$ and $y' = -y$, where $x', y' \\in \\{1, \\dots, N\\}$. The overflow condition becomes $-x' - y'  -N$, which is equivalent to $x' + y' > N$.\nWe need to count integer pairs $(x', y')$ in the square $[1, N] \\times [1, N]$ that satisfy $x' + y' \\ge N+1$.\nFor a fixed $x' \\in \\{1, \\dots, N\\}$, $y'$ must satisfy $y' \\ge N+1-x'$. Since $y' \\le N$, the number of possible values for $y'$ is $N - (N+1-x') + 1 = x'$.\nThe total count $N_{neg}$ is the sum over all possible $x'$ of the number of valid $y'$ values:\n$$\nN_{neg} = \\sum_{x'=1}^{N} x' = \\frac{N(N+1)}{2}\n$$\n\n**3. Total Count $\\#\\mathcal{M}_{w}$:**\nThe total number of overflowing pairs is the sum of the counts from the two cases:\n$$\n\\#\\mathcal{M}_{w} = N_{pos} + N_{neg} = \\frac{N(N-1)}{2} + \\frac{N(N+1)}{2}\n$$\n$$\n\\#\\mathcal{M}_{w} = \\frac{N^2 - N + N^2 + N}{2} = \\frac{2N^2}{2} = N^2\n$$\nSubstituting $N=2^{w-1}$ back into the expression:\n$$\n\\#\\mathcal{M}_{w} = (2^{w-1})^2 = 2^{2(w-1)} = 2^{2w-2}\n$$\nThus, the number of ordered pairs $(a,b)$ that cause a signed overflow is $2^{2w-2}$.",
            "answer": "$$\\boxed{2^{2w-2}}$$"
        },
        {
            "introduction": "Modern verification tools use SAT and SMT solvers not just for one-shot checks, but as the core engine within sophisticated algorithms for unbounded verification. This practice offers a look inside one such algorithm, Property Directed Reachability (PDR), which proves properties by building an inductive invariant. By simulating a single iteration, you will use a SAT query to perform a predecessor check and learn how PDR blocks bad states to progressively prove a system is safe.",
            "id": "4295406",
            "problem": "Consider a synchronous transition system modeling a single-latch toggle with an environment-controlled enable. The state consists of one Boolean latch $s \\in \\{0,1\\}$ and one Boolean input $en \\in \\{0,1\\}$. The transition relation is given by the next-state update $s' = s \\oplus en$, where $\\oplus$ denotes Boolean exclusive-or. The initial condition is $I(s) \\equiv (s = 0)$. The environment adheres to the assumption $A(en) \\equiv (en = 0)$ at all time steps. The safety property to be verified is the invariant $P(s) \\equiv (\\lnot s)$, meaning the latch $s$ must remain $0$ in all reachable states.\n\nProperty Directed Reachability (PDR) is an inductive invariant generation method that maintains a sequence of over-approximating frames $\\{F_{i}\\}$ satisfying $F_{0} \\equiv I$ and $F_{i} \\subseteq P$ for all $i \\geq 1$, and uses Boolean Satisfiability Problem (SAT) queries to block counterexamples by predecessor analysis. Assume the first frame $F_{1}$ is initially unconstrained with respect to $s$ (that is, it does not yet contain inductive clauses enforcing $P$), so a potential bad cube $c$ at level $1$ is the literal $(s = 1)$, which violates $P$.\n\nSimulate one iteration of PDR that attempts to block this bad cube $c$ at level $1$ by checking for predecessors from $F_{0}$. Form the predecessor SAT query under the transition relation and environment assumption,\n$$\nI(s) \\,\\land\\, A(en) \\,\\land\\, T(s,en,s') \\,\\land\\, c'(s'),\n$$\nwhere $c'(s')$ is the primed version of the cube $c$ and $T(s,en,s')$ encodes $s' = s \\oplus en$. Determine whether this query is satisfiable. If it is unsatisfiable, conclude the clause that PDR adds to $F_{1}$ to block $c$ (expressed over current-state variables only) and provide it as the final answer. The final answer must be a single closed-form Boolean expression in LaTeX. No numerical rounding is required, and no units apply.",
            "solution": "The goal is to simulate a single step of the PDR algorithm to block a bad cube. The bad cube $c$ represents a state that violates the safety property $P(s) \\equiv (\\lnot s)$. The property requires $s$ to always be $0$, so a state violating it is one where $s=1$. The given bad cube is $c \\equiv (s=1)$.\n\nPDR attempts to block this bad cube at level $1$ by checking if it is reachable from a state in the previous frame, $F_0$. This check is formulated as a Boolean Satisfiability (SAT) problem. The query determines if there exists a state $s$ satisfying the conditions of $F_0$, an input $en$ satisfying the environment assumption $A(en)$, and a next state $s'$ satisfying the bad cube $c'(s')$, such that $(s, en, s')$ is a valid transition according to $T$.\n\nThe components of the SAT query are:\n$1.$ The initial condition frame, $F_0$: $I(s) \\equiv (s=0)$.\n$2.$ The environment assumption: $A(en) \\equiv (en=0)$.\n$3.$ The transition relation: $T(s,en,s') \\equiv (s' = s \\oplus en)$.\n$4.$ The primed version of the bad cube, which represents the target state violating the property: $c'(s') \\equiv (s'=1)$.\n\nThe full SAT query is the conjunction of these four predicates:\n$$\n\\Phi \\equiv I(s) \\land A(en) \\land T(s,en,s') \\land c'(s')\n$$\nSubstituting the specific definitions, the query becomes:\n$$\n\\Phi \\equiv (s=0) \\land (en=0) \\land (s' = s \\oplus en) \\land (s'=1)\n$$\nTo determine the satisfiability of $\\Phi$, we can substitute the constraints on the variables $s$, $en$, and $s'$ into the transition relation.\nFrom $I(s)$, we have the constraint $s=0$.\nFrom $A(en)$, we have the constraint $en=0$.\nFrom $c'(s')$, we have the constraint $s'=1$.\n\nSubstituting $s=0$ and $en=0$ into the transition relation $s' = s \\oplus en$ yields:\n$$\ns' = 0 \\oplus 0\n$$\nThe exclusive-or operation $0 \\oplus 0$ evaluates to $0$. Thus, the transition relation under these constraints simplifies to $s'=0$.\n\nWe now have two conflicting requirements for the next state $s'$:\n- From the bad cube $c'$, we require $s'=1$.\n- From the transition out of a state in $F_0$ with the assumed environment, we deduce $s'=0$.\n\nThe conjunction $(s'=1) \\land (s'=0)$ is a logical contradiction, which is equivalent to `False`. Therefore, the entire formula $\\Phi$ is unsatisfiable.\n\nIn the context of PDR, an unsatisfiable predecessor query proves that the bad cube $c$ is not reachable in one step from the frame $F_0$. This means that no state satisfying $F_0$ can transition to a state satisfying $c$. Because $c$ is unreachable from $F_0$, PDR can \"block\" $c$ by adding a clause to the next frame, $F_1$, that excludes it.\n\nThe bad cube is $c \\equiv (s=1)$. A clause is a disjunction of literals. To block or exclude the cube $c$, we add its negation, $\\lnot c$, as a new clause to $F_1$.\nThe clause to be added is:\n$$\n\\lnot c \\equiv \\lnot(s=1)\n$$\nThis is logically equivalent to $(s=0)$. In Boolean logic notation as often used in this context, where a variable represents the proposition that it is true (i.e., equal to $1$), this clause is written as $\\lnot s$.\n\nThis new clause, $\\lnot s$, is added to the set of clauses defining $F_1$. This strengthens $F_1$ by ensuring that any state satisfying the conditions of $F_1$ must also satisfy $\\lnot s$, thereby preventing the property violation represented by $c$ from being considered in subsequent steps of the algorithm starting from $F_1$.\nThe clause is expressed over the current-state variable $s$, as required.",
            "answer": "$$\n\\boxed{\\lnot s}\n$$"
        }
    ]
}