{
    "hands_on_practices": [
        {
            "introduction": "在多重曝光光刻中，解决版图分解问题的第一步是将物理版图的几何信息抽象成一个图论模型。本练习 () 将指导您如何根据最小间距规则，从一组给定的矩形特征中构建冲突图。通过完成这项实践，您将亲身体验从物理约束到抽象图模型的转化过程，并运用广度优先搜索（BFS）算法来检验图是否为二分图，从而判断理想的双重曝光方案是否存在。",
            "id": "4284553",
            "problem": "在用于集成电路和电子设计自动化的多重曝光光刻技术中，版图着色决定了相邻特征是否可以在不违反最小间距约束的情况下分配给不同的掩模。冲突图的构建捕捉了这些约束：顶点代表特征，如果两个对应的特征距离太近以至于不能同时分配给同一个掩模，则在它们对应的顶点之间连接一条边。一个关键的判定过程是该图是否允许二着色，这等价于验证该图是否为二分图。考虑一组轴对齐的矩形特征，每个特征由坐标 $\\left(x_{\\min},y_{\\min},x_{\\max},y_{\\max}\\right)$ 给出，其中 $x_{\\min}  x_{\\max}$ 且 $y_{\\min}  y_{\\max}$，所有坐标都以纳米为单位。使用临界间距阈值 $d_c=40\\,\\mathrm{nm}$，构建冲突图，其中如果两个矩形之间的最小边到边欧几里得间距严格小于 $d_c$，则在这两个矩形之间存在一条无向边。两个闭合矩形 $R_1=[x_{1,\\min},x_{1,\\max}]\\times[y_{1,\\min},y_{1,\\max}]$ 和 $R_2=[x_{2,\\min},x_{2,\\max}]\\times[y_{2,\\min},y_{2,\\max}]$ 之间的最小边到边欧几里得间距定义为首先计算轴向间距\n$$\n\\Delta x=\\max\\left(0,\\;x_{2,\\min}-x_{1,\\max},\\;x_{1,\\min}-x_{2,\\max}\\right),\\quad\n\\Delta y=\\max\\left(0,\\;y_{2,\\min}-y_{1,\\max},\\;y_{1,\\min}-y_{2,\\max}\\right),\n$$\n然后计算欧几里得距离\n$$\nd(R_1,R_2)=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}.\n$$\n如果 $d(R_1,R_2)d_c$，则两个矩形存在冲突。通过应用广度优先搜索 (BFS) 二着色来确定每个测试用例中得到的冲突图是否为二分图。广度优先搜索 (BFS) 是指从每个未访问过的顶点开始，逐层探索图，并为相邻顶点分配交替的颜色。如果在 BFS 过程中发现一条连接相同颜色顶点的边，则该图不是二分图。\n\n本问题中所有坐标和距离都必须以纳米为单位处理，临界间距阈值也以纳米为单位指定。不涉及角度单位。要求的输出是每个测试用例的布尔值，表示其二分性。\n\n测试套件：\n- 测试用例 $1$ (预期为路径图): 矩形\n  - $R_1:\\;(0,0,40,20)$,\n  - $R_2:\\;(70,0,110,20)$,\n  - $R_3:\\;(140,0,180,20)$,\n  - $R_4:\\;(210,0,250,20)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $2$ (预期为三角形图): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(30,0,70,40)$,\n  - $R_3:\\;(15,30,55,70)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $3$ (阈值边界，无边): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(80,0,120,40)$,\n  - $R_3:\\;(0,100,40,140)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $4$ (不连通组件：一个路径图和一个三角形图): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(70,0,110,40)$,\n  - $R_3:\\;(1000,1000,1040,1040)$,\n  - $R_4:\\;(1030,1000,1070,1040)$,\n  - $R_5:\\;(1015,1030,1055,1070)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $5$ (长度为四的偶数环): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(70,0,110,40)$,\n  - $R_3:\\;(70,70,110,110)$,\n  - $R_4:\\;(0,70,40,110)$,\n  $d_c=40\\,\\mathrm{nm}$。\n\n你的程序应使用上述几何规则为每个案例构建冲突图，并通过基于 BFS 的二着色来确定其二分性。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$），每个条目是对应测试用例的布尔值。",
            "solution": "该问题要求确定从一组矩形电子电路特征派生出的冲突图是否为二分图。这是电子设计自动化 (EDA) 中多重曝光光刻领域的一个基本问题，其中一个可二着色（二分）的冲突图表明一个版图可以使用双掩模工艺制造，而不会违反最小间距规则。\n\n对于每个测试用例，解决方案分为两个主要阶段：首先，基于几何约束构建冲突图；其次，使用基于广度优先搜索 (BFS) 的二着色算法测试其二分性。\n\n如果一个图的顶点可以被划分为两个不相交的独立集 $U$ 和 $W$，使得每条边都连接 $U$ 中的一个顶点和 $W$ 中的一个顶点，则该图被定义为二分图。图论中的一个关键定理指出，一个图是二分图当且仅当它不包含奇数长度的环。指定的基于 BFS 的着色算法是检测这种奇数长度环存在的标准且高效的方法。\n\n**1. 冲突图构建**\n\n对于每个测试用例，我们给定一组 $N$ 个轴对齐的矩形和一个临界间距阈值 $d_c = 40\\,\\mathrm{nm}$。冲突图 $G=(V, E)$ 的顶点对应这 $N$ 个矩形。如果矩形 $R_i$ 和矩形 $R_j$ 之间的最小边到边欧几里得间距严格小于 $d_c$，则在边集 $E$ 中存在一条无向边 $(R_i, R_j)$。\n\n两个矩形 $R_1=\\left[x_{1,\\min},x_{1,\\max}\\right]\\times\\left[y_{1,\\min},y_{1,\\max}\\right]$ 和 $R_2=\\left[x_{2,\\min},x_{2,\\max}\\right]\\times\\left[y_{2,\\min},y_{2,\\max}\\right]$ 之间的最小间距 $d(R_1, R_2)$ 由以下公式给出：\n$$\nd(R_1,R_2)=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}\n$$\n其中 $\\Delta x$ 和 $\\Delta y$ 是沿每个轴的间距：\n$$\n\\Delta x=\\max\\left(0,\\;x_{2,\\min}-x_{1,\\max},\\;x_{1,\\min}-x_{2,\\max}\\right)\n$$\n$$\n\\Delta y=\\max\\left(0,\\;y_{2,\\min}-y_{1,\\max},\\;y_{1,\\min}-y_{2,\\max}\\right)\n$$\n这些公式正确地计算了矩形在每个轴上的区间间隙。如果区间重叠，则该轴上的间距为 $0$。\n\n冲突条件是 $d(R_i, R_j)  d_c$。为避免浮点运算和计算上更昂贵的平方根操作，我们可以使用距离的平方。该条件等价于：\n$$\nd(R_i, R_j)^2  d_c^2 \\implies (\\Delta x)^2 + (\\Delta y)^2  d_c^2\n$$\n给定 $d_c = 40\\,\\mathrm{nm}$，临界距离的平方为 $d_c^2 = 40^2 = 1600\\,\\mathrm{nm}^2$。\n\n图构建的算法如下：\n- 初始化一个具有 $N$ 个顶点的图的空邻接表表示。\n- 对于索引为 $i$ 和 $j$ ($0 \\le i  j  N$) 的每对不同矩形 $(R_i, R_j)$：\n    - 计算 $\\Delta x$ 和 $\\Delta y$。\n    - 如果 $(\\Delta x)^2 + (\\Delta y)^2  1600$，则在邻接表中顶点 $i$ 和顶点 $j$ 之间添加一条边。\n\n**2. 通过广度优先搜索 (BFS) 进行二分性测试**\n\n冲突图构建完成后，我们测试其二分性。基于 BFS 的二着色算法系统地探索图，并为每个顶点分配两种颜色之一（例如，颜色 $1$ 和颜色 $-1$）。该过程必须考虑到图可能具有多个不连通分量的情况。\n\n算法如下：\n- 初始化一个大小为 $N$ 的 `colors` 数组，其值为 $0$，表示所有顶点都未着色。\n- 从 $0$ 到 $N-1$ 遍历每个顶点 $i$：\n    - 如果顶点 $i$ 未着色 (`colors[i] == 0`)，则表示一个新的连通分量的开始。我们从此顶点开始进行 BFS 遍历。\n        - 创建一个队列并将顶点 $i$ 添加进去。\n        - 为顶点 $i$ 分配一个起始颜色，例如 `colors[i] = 1`。\n        - 当队列不为空时：\n            - 出队一个顶点 $u$。\n            - 对于其邻接表中的 $u$ 的每个邻居 $v$：\n                - 如果顶点 $v$ 未着色 (`colors[v] == 0`)：\n                    - 为其分配与 $u$ 相反的颜色（即 `colors[v] = -colors[u]`）。\n                    - 将顶点 $v$ 入队。\n                - 否则，如果顶点 $v$ 与 $u$ 的颜色相同 (`colors[v] == colors[u]`)：\n                    - 一条边连接了两个相同颜色的顶点。这意味着存在一个奇数长度的环。\n                    - 该图不是二分图。当前测试用例的算法终止并返回 `False`。\n- 如果主循环完成而没有发现任何此类颜色冲突，则意味着没有连通分量包含奇数长度的环。因此，整个图是二分图，算法返回 `True`。\n\n这个两阶段过程应用于五个测试用例中的每一个，以确定它们各自的二分性。例如，在测试用例 2 中，三个矩形都相互重叠，导致任意一对之间的距离为 $0$。这形成了一个完全图 $K_3$（一个三角形），它是一个长度为 3 的奇数环，因此不是二分图。相比之下，测试用例 5 形成一个长度为 4 的环，这是一个偶数环，因此是二分图。该方法为所有指定的配置稳健地提供了正确的分类。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the layout coloring problem for the given test cases.\n    \"\"\"\n\n    # Each case is a list of rectangles, where each rectangle is a tuple\n    # (x_min, y_min, x_max, y_max).\n    test_cases = [\n        # Case 1 (path graph expected)\n        [\n            (0, 0, 40, 20),\n            (70, 0, 110, 20),\n            (140, 0, 180, 20),\n            (210, 0, 250, 20),\n        ],\n        # Case 2 (triangle expected)\n        [\n            (0, 0, 40, 40),\n            (30, 0, 70, 40),\n            (15, 30, 55, 70),\n        ],\n        # Case 3 (threshold boundary, no edges)\n        [\n            (0, 0, 40, 40),\n            (80, 0, 120, 40),\n            (0, 100, 40, 140),\n        ],\n        # Case 4 (disconnected components: one path and one triangle)\n        [\n            (0, 0, 40, 40),\n            (70, 0, 110, 40),\n            (1000, 1000, 1040, 1040),\n            (1030, 1000, 1070, 1040),\n            (1015, 1030, 1055, 1070),\n        ],\n        # Case 5 (even cycle of four)\n        [\n            (0, 0, 40, 40),\n            (70, 0, 110, 40),\n            (70, 70, 110, 110),\n            (0, 70, 40, 110),\n        ],\n    ]\n\n    dc = 40.0\n    results = []\n    \n    for rectangles in test_cases:\n        results.append(check_bipartite(rectangles, dc))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_bipartite(rectangles: list, dc: float) -> bool:\n    \"\"\"\n    Constructs a conflict graph and checks if it's bipartite.\n\n    Args:\n        rectangles: A list of rectangle coordinates.\n        dc: The critical spacing threshold.\n\n    Returns:\n        True if the graph is bipartite, False otherwise.\n    \"\"\"\n    n = len(rectangles)\n    if n = 1:\n        return True\n\n    adj = [[] for _ in range(n)]\n    dc_sq = dc**2\n\n    # Step 1: Construct the conflict graph\n    for i in range(n):\n        for j in range(i + 1, n):\n            r1 = rectangles[i]\n            r2 = rectangles[j]\n            \n            # Unpack coordinates\n            x1_min, y1_min, x1_max, y1_max = r1\n            x2_min, y2_min, x2_max, y2_max = r2\n\n            # Calculate axis separations\n            delta_x = max(0, x2_min - x1_max, x1_min - x2_max)\n            delta_y = max(0, y2_min - y1_max, y1_min - y2_max)\n            \n            # Check for conflict using squared distance\n            dist_sq = delta_x**2 + delta_y**2\n            if dist_sq  dc_sq:\n                adj[i].append(j)\n                adj[j].append(i)\n\n    # Step 2: Check for bipartiteness using BFS-based 2-coloring\n    colors = np.zeros(n, dtype=int)  # 0: uncolored, 1: color A, -1: color B\n\n    for i in range(n):\n        if colors[i] == 0:  # Start BFS for a new connected component\n            queue = collections.deque([i])\n            colors[i] = 1\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if colors[v] == 0:\n                        colors[v] = -colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        return False  # Odd cycle detected, not bipartite\n                        \n    return True  # No odd cycles found, graph is bipartite\n\nsolve()\n```"
        },
        {
            "introduction": "当冲突图不是二分图时，直接进行双色光刻是不可行的，必须对版图进行修改。本练习 () 介绍了一种名为“缝合”（stitching）的修复技术，它在图模型中等价于移除顶点以打破所有的奇数环，从而消除着色冲突。这项任务要求您通过算法找出使图成为二分图所需的最小缝合数，帮助您掌握版图分解中的核心优化思想，并理解其与寻找最小奇环覆盖集这一图论问题的深刻联系。",
            "id": "4284591",
            "problem": "在用于多重曝光光刻的电子设计自动化 (EDA) 中，版图分解的标准抽象是冲突图 $G=(V,E)$，其中每个顶点 $v \\in V$ 代表一个多边形版图特征，每条边 $(u,v) \\in E$ 代表一个最小间距约束，该约束禁止为 $u$ 和 $v$ 分配相同的光刻掩模（颜色）。一个 2-可着色的冲突图对应于一个没有缝合点的可行双重曝光分配。缝合点是对一个多边形特征进行刻意拆分，使其成为两个可以独立着色的子特征。在图的抽象层面上，这可以建模为将该特征从奇数环中移除。在本问题中，我们将缝合点形式化为选择一个集合 $S \\subseteq V$ 进行拆分（每个选定的顶点对应一个缝合点），使得剩余的图 $G - S$ 是一个二分图。根据图论的基本事实——一个图是二分图当且仅当它不包含奇数环——最小缝合点数等于最小奇数环贯穿集 $S$ 的基数，即移除后能使 $G$ 成为二分图的最小顶点集。\n\n从上述定义出发，推导并实现一个算法。对于小图，该算法按基数递增的顺序枚举子集 $S \\subseteq V$，并通过检查 2-着色的可行性来判断 $G - S$ 是否为二分图。算法必须返回实现二分性所需的最小 $|S|$。您的程序必须实现这种枚举和二分性测试，并为所提供的测试套件中的每个图计算最小缝合点数。\n\n您必须使用纯粹的数学和逻辑推理，并基于以下经过充分检验的事实进行推导：\n- 一个图 $G$ 是二分图，当且仅当它允许对 $V$ 进行 2-着色，使得 $E$ 中的每条边都连接不同颜色的顶点。\n- 一个图 $G$ 是二分图，当且仅当它不包含奇数长度的环。\n- 从 $G$ 中移除一个顶点集 $S$ 会得到导出子图 $G-S$，该子图是通过删除 $S$ 中的所有顶点以及所有与之相连的边得到的。\n\n您的程序应评估以下测试套件。每个测试用例由顶点数 $n$ 和一个边列表 $E$ 指定，顶点用整数标记。对于所有用例，输出最小缝合点数（作为整数）。不涉及物理单位。最终输出格式必须是单行文本，其中包含所有测试用例的结果，结果连接成一个逗号分隔的列表并用方括号括起来，例如 $[r_1,r_2,\\dots,r_k]$。\n\n测试套件：\n- 用例 1：$n=4$，$E=\\{(0,1),(1,2),(2,3)\\}$，一个有 4 个顶点的路径图。\n- 用例 2：$n=3$，$E=\\{(0,1),(1,2),(2,0)\\}$，一个三角形。\n- 用例 3：$n=4$，$E=\\{(0,1),(1,2),(2,3),(3,0)\\}$，一个 4-环（正方形）。\n- 用例 4：$n=4$，$E=\\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$，一个 4 个顶点的完全图。\n- 用例 5：$n=5$，$E=\\{(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)\\}$，两个共享顶点 0 的三角形。\n- 用例 6：$n=6$，$E=\\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)\\}$，两个不相交的三角形。\n- 用例 7：$n=5$，$E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$，一个 5-环。\n- 用例 8：$n=1$，$E=\\{\\}$，一个孤立顶点。\n- 用例 9：$n=6$，$E=\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$，一个以顶点 0 为中心的星形图。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来（例如，$[result_1,result_2,\\dots,result_9]$）。每个 $result_i$ 必须是对应测试用例的最小缝合点数的整数值。",
            "solution": "所述问题是有效的。它在科学上基于图论的既定原则及其在电子设计自动化 (EDA) 中的应用，特别是针对多重曝光光刻的版图分解问题。该问题定义明确、客观且自洽，为获得唯一解提供了所有必要的定义和数据。它要求实现一个特定算法——按基数递增的顺序枚举顶点子集以找到最小奇数环贯穿集——这是一种正确但计算密集的方法，适用于解决小图问题。\n\n该问题要求计算使冲突图 $G=(V,E)$ 成为二分图所需的最小缝合点数。应用于一个特征（由顶点 $v \\in V$ 表示）的缝合点被建模为从图中移除顶点 $v$。因此，目标是找到一个最小基数的顶点集 $S \\subseteq V$，使得导出子图 $G-S$ 是二分图。一个图是二分图当且仅当它不包含奇数长度的环路。因此，集合 $S$ 必须是一个与 $G$ 中每个奇数环都相交的最小顶点集。在图论中，这样的集合被称为最小奇数环贯穿集。\n\n规定的算法是搜索最小的整数 $k \\geq 0$，使得存在一个子集 $S \\subseteq V$ 且 $|S|=k$，并且 $G-S$ 是二分图。这是一种暴力搜索策略，由于它按递增顺序（从 $k=0, 1, 2, \\dots, |V|$）检查子集的基数，因此保证能找到最小的 $k$。\n\n算法流程如下：\n1.  设 $k$ 为要移除的顶点集 $S$ 的大小（缝合点数）。我们从 $k=0$ 开始。\n2.  对于给定的 $k$，生成所有基数为 $k$ 的不同子集 $S \\subseteq V$。\n3.  对于每个子集 $S$，构建导出子图 $G-S$。该子图由顶点 $V' = V \\setminus S$ 以及原图 $E$ 中两个端点都在 $V'$ 内的所有边组成。\n4.  测试子图 $G-S$ 是否为二分图。如果是，则我们找到了一个大小为 $k$ 的有效缝合点集。由于我们是按递增顺序迭代 $k$，这个 $k$ 必定是所需的最小缝合点数。算法可以终止并返回 $k$。\n5.  如果没有大小为 $k$ 的子集能产生二分图，则将 $k$ 增加 1，并从步骤 2 重复。该过程保证会终止，因为移除所有顶点（即 $S=V$, $k=|V|$）会得到一个空图，而空图是平凡的二分图。\n\n该算法的核心是给定图（或子图）的二分性测试。一个图是二分图，当且仅当其顶点可以被划分为两个不相交的独立集 $U_1$ 和 $U_2$，使得每条边都连接 $U_1$ 中的一个顶点和 $U_2$ 中的一个顶点。这等价于检查该图是否是 2-可着色的。一个标准方法是使用图遍历算法，如广度优先搜索 (BFS) 或深度优先搜索 (DFS)。\n\n基于 BFS 的 2-着色算法对图 $G'=(V', E')$ 的工作原理如下：\n1.  创建一个 `color` 数据结构，例如数组或哈希映射，用于存储 $V'$ 中每个顶点的颜色。将所有顶点初始化为未着色（例如，颜色 0）。设两种颜色为 $1$ 和 $-1$。\n2.  遍历 $V'$ 中的每个顶点 $v$。如果 $v$ 未着色：\n    a. 为 $v$ 分配一个起始颜色，比如颜色 $1$。\n    b. 从 $v$ 开始进行 BFS 遍历。将 $v$ 添加到队列中。\n    c. 当队列不为空时：\n        i.   从队列中取出一个顶点 $u$。\n        ii.  对于 $u$ 的每个邻居 $w$：\n             - 如果 $w$ 未着色，则为其分配与 $u$ 相反的颜色（即 `color[w] = -color[u]`）并将 $w$ 入队。\n             - 如果 $w$ 已被着色且 `color[w] == color[u]`，则有一条边连接了两个相同颜色的顶点。这表明存在一个奇数长度的环路。该图不是二分图。测试失败。\n3.  如果图的所有连通分量的遍历都完成，且没有发现任何同色邻居，则该图已成功 2-着色，因此是二分图。测试成功。\n\n邻接表表示法对于实现广度优先搜索 (BFS) 遍历是高效的。对于每个测试用例，我们通过顶点数 $n$ 和边列表 $E$ 来定义图。主循环将 $k$ 从 $0$ 迭代到 $n$。一个内循环生成所有 $k$ 个顶点的组合以形成集合 $S$。对于每个 $S$，我们对 $G-S$ 应用二分性测试。第一个使测试通过的 $k$ 值即为该测试用例的解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through each test case, finds the minimum number of stitches,\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1: n=4, E={(0,1),(1,2),(2,3)}\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Case 2: n=3, E={(0,1),(1,2),(2,0)}\n        (3, [(0, 1), (1, 2), (2, 0)]),\n        # Case 3: n=4, E={(0,1),(1,2),(2,3),(3,0)}\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Case 4: n=4, E={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)}\n        (4, [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]),\n        # Case 5: n=5, E={(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)}\n        (5, [(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)]),\n        # Case 6: n=6, E={(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)}\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)]),\n        # Case 7: n=5, E={(0,1),(1,2),(2,3),(3,4),(4,0)}\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Case 8: n=1, E={}\n        (1, []),\n        # Case 9: n=6, E={(0,1),(0,2),(0,3),(0,4),(0,5)}\n        (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        min_stitches = find_min_stitches(n, edges)\n        results.append(min_stitches)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef is_bipartite(num_vertices, edges, removed_vertices):\n    \"\"\"\n    Checks if the subgraph G-S is bipartite using BFS-based 2-coloring.\n    S is the set of removed_vertices.\n    \"\"\"\n    removed_set = set(removed_vertices)\n    \n    # Adjacency list for the subgraph G-S\n    adj = {i: [] for i in range(num_vertices) if i not in removed_set}\n    if not adj:  # Empty graph is bipartite\n        return True\n\n    for u, v in edges:\n        if u not in removed_set and v not in removed_set:\n            adj[u].append(v)\n            adj[v].append(u)\n    \n    # colors map: 0 for uncolored, 1 or -1 for the two colors\n    colors = {}\n    \n    # Iterate through all vertices to handle disconnected components\n    for i in adj:\n        if i not in colors:\n            colors[i] = 1\n            queue = deque([i])\n            \n            while queue:\n                u = queue.popleft()\n                \n                for v in adj[u]:\n                    if v not in colors:\n                        colors[v] = -colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        # Found an edge connecting two same-colored vertices,\n                        # which implies an odd cycle.\n                        return False\n    return True\n\n\ndef find_min_stitches(n, edges):\n    \"\"\"\n    Finds the minimum number of stitches (vertices to remove) to make the\n    graph bipartite by enumerating subsets of vertices of increasing size.\n    \"\"\"\n    vertices = list(range(n))\n    \n    # k is the number of stitches (vertices to remove)\n    for k in range(n + 1):\n        # Generate all subsets of vertices of size k\n        for s in itertools.combinations(vertices, k):\n            if is_bipartite(n, edges, s):\n                return k\n    return n # Should not be reached in practice as an empty graph is bipartite\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的芯片制造中，引入缝合不仅要考虑方案的可行性，还必须最小化其带来的制造成本并满足复杂的物理约束。本练习 () 将引导您从简单的计数问题过渡到更强大的优化框架——整数线性规划（ILP）。通过构建并求解这个ILP模型，您将学会如何精确地建模现实世界中的各种约束（如不同的缝合成本、特征片段的连续性等），从而将一个复杂的EDA问题转化为一个可由通用求解器高效处理的标准数学优化问题。",
            "id": "4284590",
            "problem": "在电子设计自动化 (EDA) 的双重曝光光刻 (DPL) 的多重图案成形技术中，冲突图用于建模最小间距违规：每个顶点对应一个可印刷的多边形特征，每条冲突边表示两个必须分配到不同掩模的特征。一个缝合点 (stitch) 将单个特征分割成两个可印刷的片段，这两个片段可以被分配给不同的掩模，但这会产生以成本权重来量化的套刻风险。设计目标是最小化总缝合成本，同时确保所有冲突边得到满足，并且除非调用了缝合点，否则缝合的片段在物理上保持连续。\n\n考虑一个布局，其特征由集合 $V=\\{1,2,3,4,5\\}$ 索引。冲突边为\n$$E=\\{(1,2),(2,3),(3,4),(4,5),(5,1),(2,5)\\}.$$\n特征 $2$ 是一个预着色的锚点，被约束在掩模 $0$ 上，即其二元颜色变量必须满足 $x_2=0$。二元颜色变量 $x_i\\in\\{0,1\\}$ 代表每个特征 $i$ 的掩模分配，其中 $0$ 和 $1$ 表示两个不同的掩模。\n\n在特征 $1$、$3$ 和 $4$ 上可以使用缝合点。如果在特征 $i\\in\\{1,3,4\\}$ 上插入一个缝合点，该特征被分割成两个可印刷的片段，其二元颜色变量为 $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$，并且一个二元缝合变量 $s_i\\in\\{0,1\\}$ 指示是否使用该缝合点 ($s_i=1$) 或不使用 ($s_i=0$)。当不使用缝合点时 ($s_i=0$)，两个片段的颜色必须保持连续。当使用缝合点时 ($s_i=1$)，两个片段可以取不同的颜色。缝合成本为 $\\alpha_1=2$、$\\alpha_3=1$ 和 $\\alpha_4=1.5$，目标是最小化总缝合成本 $\\sum_{i\\in\\{1,3,4\\}}\\alpha_i s_i$。\n\n对于与已缝合特征 $i$ 相邻的冲突边，其几何一侧的邻居与 $x_i^{(L)}$ 相互作用，而另一侧的邻居与 $x_i^{(R)}$ 相互作用：\n- 对于特征 $1$：$(1,2)$ 与 $x_1^{(L)}$ 耦合，$(1,5)$ 与 $x_1^{(R)}$ 耦合。\n- 对于特征 $3$：$(2,3)$ 与 $x_3^{(L)}$ 耦合，$(3,4)$ 与 $x_3^{(R)}$ 耦合。\n- 对于特征 $4$：$(3,4)$ 与 $x_4^{(L)}$ 耦合，$(4,5)$ 与 $x_4^{(R)}$ 耦合。\n\n所有未缝合的特征使用单个变量 $x_i$。所有冲突边必须分配到不同的掩模。所有缝合的片段必须遵守连续性，除非缝合变量允许颜色差异。\n\n任务：从二元掩模分配和缝合片段物理连续性的核心定义出发，根据二元变量 $x_i$、$x_i^{(L)}$、$x_i^{(R)}$ 和 $s_i$，建立一个整数线性规划 (ILP) 模型，该模型在满足冲突边的掩模差异约束和缝合片段的连续性约束的条件下，最小化总缝合成本。然后，求解该实例的ILP，确定最小可能的目标函数值\n$$\\sum_{i\\in\\{1,3,4\\}}\\alpha_i s_i.$$\n将最终答案表示为单个实数。无需四舍五入。",
            "solution": "我们从双重曝光光刻 (DPL) 与图的2-着色之间的映射关系开始：任何冲突边都要求其端点被分配到不同的掩模。使用二元颜色变量 $x\\in\\{0,1\\}$ 来表示掩模，两个变量不同的要求可以等效地写为 $|x_u - x_v| = 1$，对于二元端点 $x_u,x_v\\in\\{0,1\\}$。因为 $x_u,x_v$ 是二元变量，所以 $|x_u-x_v|=1$ 等价于 $x_u + x_v = 1$。\n\n对于一个被分割成两个片段的已缝合特征 $i$，其二元变量为 $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$ 和一个缝合变量 $s_i\\in\\{0,1\\}$，物理连续性规定，当 $s_i=0$ 时，片段必须是相同的颜色，而当 $s_i=1$ 时，允许颜色差异。该规则的一个标准线性编码是\n$$|x_i^{(L)} - x_i^{(R)}| \\le s_i,$$\n对于二元变量，这可以通过以下一对不等式进行线性化\n\\begin{align*}\nx_i^{(L)} - x_i^{(R)} \\le s_i,\\\\\nx_i^{(R)} - x_i^{(L)} \\le s_i.\n\\end{align*}\n如果 $s_i=0$，这些约束强制 $x_i^{(L)}=x_i^{(R)}$。如果 $s_i=1$，它们允许 $x_i^{(L)}\\neq x_i^{(R)}$。\n\n我们现在建立整数线性规划 (ILP) 模型。决策变量：\n- 对于未缝合的特征 $i\\in V\\setminus\\{1,3,4\\}$，一个二元变量 $x_i\\in\\{0,1\\}$。\n- 对于可缝合的特征 $i\\in\\{1,3,4\\}$，二元片段变量 $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$ 和一个二元缝合变量 $s_i\\in\\{0,1\\}$。\n- 锚点约束固定了 $x_2=0$。\n\n目标函数：\n$$\\min \\sum_{i\\in\\{1,3,4\\}} \\alpha_i s_i \\quad \\text{其中} \\quad \\alpha_1=2,\\ \\alpha_3=1,\\ \\alpha_4=1.5.$$\n\n在整个实例中强制执行冲突边的约束，采用指定的片段耦合：\n- 边 $(1,2)$：$x_1^{(L)} + x_2 = 1$。\n- 边 $(1,5)$：$x_1^{(R)} + x_5 = 1$。\n- 边 $(2,3)$：$x_2 + x_3^{(L)} = 1$。\n- 边 $(3,4)$：$x_3^{(R)} + x_4^{(L)} = 1$。\n- 边 $(4,5)$：$x_4^{(R)} + x_5 = 1$。\n- 边 $(2,5)$：$x_2 + x_5 = 1$。\n\n已缝合特征 $i\\in\\{1,3,4\\}$ 的连续性约束：\n\\begin{align*}\nx_i^{(L)} - x_i^{(R)} \\le s_i,\\\\\nx_i^{(R)} - x_i^{(L)} \\le s_i.\n\\end{align*}\n\n我们现在通过从锚点和冲突约束进行传播来解析地求解ILP。\n\n从锚点出发，我们有 $x_2=0$。弦边 $(2,5)$ 强制要求 $x_2 + x_5 = 1$，因此\n$$x_5 = 1.$$\n考虑由边 $(1,2)$、$(2,5)$ 和 $(5,1)$ 形成的三角形。如果在特征 $1$（或特征 $2$ 或 $5$）上没有缝合点，这个三角形就无法进行2-着色，因为它是一个奇数环。由于缝合点仅在特征 $1$、$3$ 和 $4$ 上可用，解决这个三角形的唯一方法是在特征 $1$ 上使用缝合点，以便其两个片段可以取不同的颜色。\n\n我们通过显式赋值来验证其必要性和充分性：\n\n- 由 $(1,2)$ 可得，$x_1^{(L)} + x_2 = 1$ 给出\n$$x_1^{(L)} = 1.$$\n- 由 $(1,5)$ 可得，$x_1^{(R)} + x_5 = 1$ 给出\n$$x_1^{(R)} = 0.$$\n这些意味着\n$$|x_1^{(L)} - x_1^{(R)}| = |1 - 0| = 1,$$\n这迫使 $s_1 \\ge 1$。由于 $s_1\\in\\{0,1\\}$，我们有\n$$s_1 = 1.$$\n\n沿着链 $2\\to 3\\to 4\\to 5$ 进行推导：\n- 边 $(2,3)$ 强制要求 $x_2 + x_3^{(L)} = 1$，所以\n$$x_3^{(L)} = 1.$$\n- 边 $(3,4)$ 强制要求 $x_3^{(R)} + x_4^{(L)} = 1$。我们尚不知道 $x_3^{(R)}$ 或 $x_4^{(L)}$，但我们接下来使用来自 $(4,5)$ 的前向约束。\n- 边 $(4,5)$ 强制要求 $x_4^{(R)} + x_5 = 1$，因此\n$$x_4^{(R)} = 0.$$\n我们还需要满足 $(3,4)$。设 $x_4^{(L)}=0$；那么 $(3,4)$ 给出 $x_3^{(R)} + 0 = 1$，所以\n$$x_3^{(R)} = 1.$$\n\n最后，检查已缝合特征 $3$ 和 $4$ 的连续性约束：\n- 对于特征 $3$，$x_3^{(L)}=1$ 和 $x_3^{(R)}=1$ 得出 $|x_3^{(L)} - x_3^{(R)}| = 0 \\le s_3$，所以我们可以取 $s_3=0$。\n- 对于特征 $4$，$x_4^{(L)}=0$ 和 $x_4^{(R)}=0$ 得出 $|x_4^{(L)} - x_4^{(R)}| = 0 \\le s_4$，所以我们可以取 $s_4=0$。\n\n所有冲突边都得到满足：\n\\begin{align*}\n(1,2)\\ x_1^{(L)} + x_2 = 1 + 0 = 1,\\\\\n(1,5)\\ x_1^{(R)} + x_5 = 0 + 1 = 1,\\\\\n(2,3)\\ x_2 + x_3^{(L)} = 0 + 1 = 1,\\\\\n(3,4)\\ x_3^{(R)} + x_4^{(L)} = 1 + 0 = 1,\\\\\n(4,5)\\ x_4^{(R)} + x_5 = 0 + 1 = 1,\\\\\n(2,5)\\ x_2 + x_5 = 0 + 1 = 1.\n\\end{align*}\n因此，当 $s_1=1$、$s_3=0$、$s_4=0$ 时，该分配是可行的，目标函数值为\n$$\\sum_{i\\in\\{1,3,4\\}} \\alpha_i s_i = 2\\cdot 1 + 1\\cdot 0 + 1.5\\cdot 0 = 2.$$\n\n为了论证最小值，我们观察到 $\\{1,2,5\\}$ 上的奇数环必须通过允许其某个顶点上的颜色翻转来打破。由于缝合点仅在特征 $1$、$3$ 和 $4$ 上可用，且特征 $3$ 和 $4$ 不在该三角形中，唯一可行的缝合点在特征 $1$。因此，任何可行解都必须有 $s_1=1$，并且没有必要产生额外的缝合点。因此，最小可能的目标函数值恰好是 $2$。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}