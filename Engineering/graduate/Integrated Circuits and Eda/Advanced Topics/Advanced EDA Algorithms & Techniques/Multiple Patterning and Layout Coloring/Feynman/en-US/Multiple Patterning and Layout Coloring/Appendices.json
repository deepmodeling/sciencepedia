{
    "hands_on_practices": [
        {
            "introduction": "The first critical step in analyzing a layout for multiple patterning is to translate the physical geometry of circuit features into an abstract conflict graph. This practice bridges the gap between the physical domain of nanometer-scale distances and the mathematical domain of graph theory. By implementing an algorithm to construct a conflict graph from a set of rectangular features and then testing it for bipartiteness, you will gain hands-on experience with the fundamental model used in layout decomposition .",
            "id": "4284553",
            "problem": "In multiple patterning lithography for integrated circuits and electronic design automation, layout coloring determines whether adjacent features can be assigned to different masks without violating minimum spacing constraints. The construct of a conflict graph captures these constraints: vertices represent features, and an edge connects two vertices if the corresponding features are too close to be simultaneously assigned to the same mask. A key decision procedure is whether this graph admits a two-coloring, which is equivalent to verifying that the graph is bipartite. Consider a set of axis-aligned rectangular features, each given by the coordinates $\\left(x_{\\min},y_{\\min},x_{\\max},y_{\\max}\\right)$, with $x_{\\min} < x_{\\max}$ and $y_{\\min} < y_{\\max}$, all coordinates expressed in nanometers. Using a critical spacing threshold $d_c=40\\,\\mathrm{nm}$, construct the conflict graph where an undirected edge exists between two rectangles if their minimum edge-to-edge Euclidean separation is strictly less than $d_c$. The minimum edge-to-edge Euclidean separation between two closed rectangles $R_1=[x_{1,\\min},x_{1,\\max}]\\times[y_{1,\\min},y_{1,\\max}]$ and $R_2=[x_{2,\\min},x_{2,\\max}]\\times[y_{2,\\min},y_{2,\\max}]$ is defined by first computing the axis separations as\n$$\n\\Delta x=\\max\\left(0,\\;x_{2,\\min}-x_{1,\\max},\\;x_{1,\\min}-x_{2,\\max}\\right),\\quad\n\\Delta y=\\max\\left(0,\\;y_{2,\\min}-y_{1,\\max},\\;y_{1,\\min}-y_{2,\\max}\\right),\n$$\nand then the Euclidean distance as\n$$\nd(R_1,R_2)=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}.\n$$\nTwo rectangles are in conflict if $d(R_1,R_2)<d_c$. Determine for each test case whether the resulting conflict graph is bipartite by applying Breadth-First Search (BFS) two-coloring, where Breadth-First Search (BFS) refers to the level-by-level exploration of the graph starting from each unvisited vertex and assigning alternating colors to adjacent vertices. If during BFS an edge is found connecting vertices of the same color, the graph is not bipartite.\n\nAll coordinates and distances in this problem must be treated in nanometers, and the critical spacing threshold is specified in nanometers. There are no angle units involved. The required outputs are booleans per test case indicating bipartiteness.\n\nTest suite:\n- Case $1$ (path graph expected): rectangles\n  - $R_1:\\;(0,0,40,20)$,\n  - $R_2:\\;(70,0,110,20)$,\n  - $R_3:\\;(140,0,180,20)$,\n  - $R_4:\\;(210,0,250,20)$,\n  with $d_c=40\\,\\mathrm{nm}$.\n- Case $2$ (triangle expected): rectangles\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(30,0,70,40)$,\n  - $R_3:\\;(15,30,55,70)$,\n  with $d_c=40\\,\\mathrm{nm}$.\n- Case $3$ (threshold boundary, no edges): rectangles\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(80,0,120,40)$,\n  - $R_3:\\;(0,100,40,140)$,\n  with $d_c=40\\,\\mathrm{nm}$.\n- Case $4$ (disconnected components: one path and one triangle): rectangles\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(70,0,110,40)$,\n  - $R_3:\\;(1000,1000,1040,1040)$,\n  - $R_4:\\;(1030,1000,1070,1040)$,\n  - $R_5:\\;(1015,1030,1055,1070)$,\n  with $d_c=40\\,\\mathrm{nm}$.\n- Case $5$ (even cycle of four): rectangles\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(70,0,110,40)$,\n  - $R_3:\\;(70,70,110,110)$,\n  - $R_4:\\;(0,70,40,110)$,\n  with $d_c=40\\,\\mathrm{nm}$.\n\nYour program should construct the conflict graph for each case using the above geometric rule and determine bipartiteness via BFS-based two-coloring. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$), where each entry is a boolean corresponding to the respective test case.",
            "solution": "The problem requires determining whether conflict graphs derived from sets of rectangular electronic-circuit features are bipartite. This is a fundamental problem in electronic design automation (EDA) for multiple patterning lithography, where a two-colorable (bipartite) conflict graph indicates that a layout can be fabricated using a two-mask process without violating minimum spacing rules.\n\nThe solution proceeds in two primary stages for each test case: first, the construction of the conflict graph based on geometric constraints, and second, testing for bipartiteness using a Breadth-First Search (BFS) based two-coloring algorithm.\n\nA graph is defined as bipartite if its vertices can be divided into two disjoint and independent sets, $U$ and $W$, such that every edge connects a vertex in $U$ to one in $W$. A key theorem in graph theory states that a graph is bipartite if and only if it contains no odd-length cycles. The specified BFS-based coloring algorithm is a standard and efficient method for detecting the presence of such odd-length cycles.\n\n**1. Conflict Graph Construction**\n\nFor each test case, we are given a set of $N$ axis-aligned rectangles and a critical spacing threshold $d_c = 40\\,\\mathrm{nm}$. The vertices of the conflict graph $G=(V, E)$ correspond to these $N$ rectangles. An undirected edge $(R_i, R_j)$ exists in the edge set $E$ if the minimum edge-to-edge Euclidean separation between rectangle $R_i$ and rectangle $R_j$ is strictly less than $d_c$.\n\nThe minimum separation distance $d(R_1, R_2)$ between two rectangles $R_1=\\left[x_{1,\\min},x_{1,\\max}\\right]\\times\\left[y_{1,\\min},y_{1,\\max}\\right]$ and $R_2=\\left[x_{2,\\min},x_{2,\\max}\\right]\\times\\left[y_{2,\\min},y_{2,\\max}\\right]$ is given by the formula:\n$$\nd(R_1,R_2)=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}\n$$\nwhere $\\Delta x$ and $\\Delta y$ are the separations along each axis:\n$$\n\\Delta x=\\max\\left(0,\\;x_{2,\\min}-x_{1,\\max},\\;x_{1,\\min}-x_{2,\\max}\\right)\n$$\n$$\n\\Delta y=\\max\\left(0,\\;y_{2,\\min}-y_{1,\\max},\\;y_{1,\\min}-y_{2,\\max}\\right)\n$$\nThese formulas correctly compute the gap between the rectangles' intervals on each axis. If the intervals overlap, the separation on that axis is $0$.\n\nThe conflict condition is $d(R_i, R_j) < d_c$. To avoid floating-point arithmetic and the computationally more expensive square root operation, we can work with squared distances. The condition is equivalent to:\n$$\nd(R_i, R_j)^2 < d_c^2 \\implies (\\Delta x)^2 + (\\Delta y)^2 < d_c^2\n$$\nGiven $d_c = 40\\,\\mathrm{nm}$, the squared critical distance is $d_c^2 = 40^2 = 1600\\,\\mathrm{nm}^2$.\n\nThe algorithm for graph construction is as follows:\n- Initialize an empty adjacency list representation for a graph with $N$ vertices.\n- For every pair of distinct rectangles $(R_i, R_j)$ with indices $i$ and $j$ ($0 \\le i < j < N$):\n    - Calculate $\\Delta x$ and $\\Delta y$.\n    - If $(\\Delta x)^2 + (\\Delta y)^2 < 1600$, add an edge between vertex $i$ and vertex $j$ in the adjacency list.\n\n**2. Bipartiteness Test via Breadth-First Search (BFS)**\n\nOnce the conflict graph is constructed, we test for bipartiteness. The BFS-based two-coloring algorithm systematically explores the graph and assigns one of two colors (e.g., color $1$ and color $-1$) to each vertex. The process must account for graphs that may have multiple disconnected components.\n\nThe algorithm is as follows:\n- Initialize a `colors` array of size $N$ with a value of $0$, signifying that all vertices are uncolored.\n- Iterate through each vertex $i$ from $0$ to $N-1$:\n    - If vertex $i$ is uncolored (`colors[i] == 0`), it signifies the start of a new connected component. We initiate a BFS traversal from this vertex.\n        - Create a queue and add vertex $i$ to it.\n        - Assign a starting color to vertex $i$, for example, `colors[i] = 1`.\n        - While the queue is not empty:\n            - Dequeue a vertex $u$.\n            - For each neighbor $v$ of $u$ in its adjacency list:\n                - If vertex $v$ is uncolored (`colors[v] == 0`):\n                    - Assign it the opposite color of $u$ (i.e., `colors[v] = -colors[u]`).\n                    - Enqueue vertex $v$.\n                - Else, if vertex $v$ has the same color as $u$ (`colors[v] == colors[u]`):\n                    - An edge connects two vertices of the same color. This implies the existence of an odd-length cycle.\n                    - The graph is not bipartite. The algorithm for the current test case terminates and returns `False`.\n- If the main loop completes without finding any such color conflicts, it means no connected component contains an odd-length cycle. Therefore, the entire graph is bipartite, and the algorithm returns `True`.\n\nThis two-stage process is applied to each of the five test cases to determine their respective bipartiteness. For instance, in Case $2$, the three rectangles all overlap, resulting in a distance of $0$ between any pair. This forms a complete graph $K_3$ (a triangle), which is an odd cycle of length $3$ and is thus not bipartite. In contrast, Case $5$ forms a cycle of length $4$, an even cycle, which is bipartite. This method robustly provides the correct classification for all specified configurations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the layout coloring problem for the given test cases.\n    \"\"\"\n\n    # Each case is a list of rectangles, where each rectangle is a tuple\n    # (x_min, y_min, x_max, y_max).\n    test_cases = [\n        # Case 1 (path graph expected)\n        [\n            (0, 0, 40, 20),\n            (70, 0, 110, 20),\n            (140, 0, 180, 20),\n            (210, 0, 250, 20),\n        ],\n        # Case 2 (triangle expected)\n        [\n            (0, 0, 40, 40),\n            (30, 0, 70, 40),\n            (15, 30, 55, 70),\n        ],\n        # Case 3 (threshold boundary, no edges)\n        [\n            (0, 0, 40, 40),\n            (80, 0, 120, 40),\n            (0, 100, 40, 140),\n        ],\n        # Case 4 (disconnected components: one path and one triangle)\n        [\n            (0, 0, 40, 40),\n            (70, 0, 110, 40),\n            (1000, 1000, 1040, 1040),\n            (1030, 1000, 1070, 1040),\n            (1015, 1030, 1055, 1070),\n        ],\n        # Case 5 (even cycle of four)\n        [\n            (0, 0, 40, 40),\n            (70, 0, 110, 40),\n            (70, 70, 110, 110),\n            (0, 70, 40, 110),\n        ],\n    ]\n\n    dc = 40.0\n    results = []\n    \n    for rectangles in test_cases:\n        results.append(check_bipartite(rectangles, dc))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_bipartite(rectangles: list, dc: float) -> bool:\n    \"\"\"\n    Constructs a conflict graph and checks if it's bipartite.\n\n    Args:\n        rectangles: A list of rectangle coordinates.\n        dc: The critical spacing threshold.\n\n    Returns:\n        True if the graph is bipartite, False otherwise.\n    \"\"\"\n    n = len(rectangles)\n    if n <= 1:\n        return True\n\n    adj = [[] for _ in range(n)]\n    dc_sq = dc**2\n\n    # Step 1: Construct the conflict graph\n    for i in range(n):\n        for j in range(i + 1, n):\n            r1 = rectangles[i]\n            r2 = rectangles[j]\n            \n            # Unpack coordinates\n            x1_min, y1_min, x1_max, y1_max = r1\n            x2_min, y2_min, x2_max, y2_max = r2\n\n            # Calculate axis separations\n            delta_x = max(0, x2_min - x1_max, x1_min - x2_max)\n            delta_y = max(0, y2_min - y1_max, y1_min - y2_max)\n            \n            # Check for conflict using squared distance\n            dist_sq = delta_x**2 + delta_y**2\n            if dist_sq < dc_sq:\n                adj[i].append(j)\n                adj[j].append(i)\n\n    # Step 2: Check for bipartiteness using BFS-based 2-coloring\n    colors = np.zeros(n, dtype=int)  # 0: uncolored, 1: color A, -1: color B\n\n    for i in range(n):\n        if colors[i] == 0:  # Start BFS for a new connected component\n            queue = collections.deque([i])\n            colors[i] = 1\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if colors[v] == 0:\n                        colors[v] = -colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        return False  # Odd cycle detected, not bipartite\n                        \n    return True  # No odd cycles found, graph is bipartite\n\nsolve()\n```"
        },
        {
            "introduction": "Once a conflict graph is constructed, we may discover it is not bipartite, meaning a stitch-free two-mask assignment is impossible. This exercise introduces the concept of \"stitching\" as a common industrial solution to repair such layouts by breaking odd cycles. You will implement a direct, enumerative algorithm to find the minimum number of stitches required, providing a foundational understanding of the odd cycle transversal problem that lies at the heart of layout decomposition .",
            "id": "4284591",
            "problem": "In Electronic Design Automation (EDA) for multiple patterning lithography, a standard abstraction for layout decomposition is a conflict graph $G=(V,E)$, where each vertex $v \\in V$ represents a polygonal layout feature and each edge $(u,v) \\in E$ represents a minimum-spacing constraint that forbids assigning the same lithography mask (color) to both $u$ and $v$. A $2$-colorable conflict graph corresponds to a feasible double-patterning assignment without stitches. A stitch is a deliberate split of a polygonal feature into two sub-features that can be independently colored, which, at the graph abstraction level, can be modeled by removing the feature from participation in odd cycles. In this problem, we formalize stitches as selecting a set $S \\subseteq V$ to split (one stitch per selected vertex), such that the remaining graph $G - S$ is bipartite. By the fundamental graph-theoretic fact that a graph is bipartite if and only if it contains no odd cycle, the minimum number of stitches equals the cardinality of a minimum odd cycle transversal $S$, i.e., a smallest vertex set whose removal makes $G$ bipartite.\n\nStarting from the definitions above, derive and implement an algorithm that, for small graphs, enumerates subsets $S \\subseteq V$ in increasing cardinality order and checks whether $G - S$ is bipartite via feasibility of a $2$-coloring. The algorithm must return the minimum $|S|$ that achieves bipartiteness. Your program must implement this enumeration and bipartiteness test and compute the minimum number of stitches for each graph in the provided test suite.\n\nYou must use purely mathematical and logical reasoning and base your derivation on the following well-tested facts:\n- A graph $G$ is bipartite if and only if it admits a $2$-coloring of $V$ such that every edge in $E$ connects vertices of opposite colors.\n- A graph $G$ is bipartite if and only if it contains no cycle of odd length.\n- Removing a set of vertices $S$ from $G$ yields the induced subgraph $G-S$ obtained by deleting all vertices in $S$ and all incident edges.\n\nYour program should evaluate the following test suite. Each test case is specified by the number of vertices $n$ and an edge list $E$ with vertices labeled by integers. For all cases, output the minimum number of stitches (as an integer). There are no physical units involved. The final output format must be a single line with the results of all test cases concatenated as a comma-separated list enclosed in square brackets, e.g., $[r_1,r_2,\\dots,r_k]$.\n\nTest suite:\n- Case $1$: $n=4$, $E=\\{(0,1),(1,2),(2,3)\\}$, a path graph with $4$ vertices.\n- Case $2$: $n=3$, $E=\\{(0,1),(1,2),(2,0)\\}$, a triangle.\n- Case $3$: $n=4$, $E=\\{(0,1),(1,2),(2,3),(3,0)\\}$, a $4$-cycle (square).\n- Case $4$: $n=4$, $E=\\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$, the complete graph on $4$ vertices.\n- Case $5$: $n=5$, $E=\\{(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)\\}$, two triangles sharing vertex $0$.\n- Case $6$: $n=6$, $E=\\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)\\}$, two disjoint triangles.\n- Case $7$: $n=5$, $E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$, a $5$-cycle.\n- Case $8$: $n=1$, $E=\\{\\}$, a single isolated vertex.\n- Case $9$: $n=6$, $E=\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$, a star centered at vertex $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots,result_9]$). Each $result_i$ must be an integer specifying the minimum number of stitches for the corresponding case.",
            "solution": "The problem as stated is valid. It is scientifically grounded in established principles of graph theory and its application to Electronic Design Automation (EDA), specifically the layout decomposition problem for multiple patterning lithography. The problem is well-posed, objective, and self-contained, providing all necessary definitions and data for a unique solution. It requests the implementation of a specific algorithm—enumerating vertex subsets of increasing cardinality to find a minimum odd cycle transversal—which is a correct, albeit computationally intensive, method for solving the problem for small graphs.\n\nThe problem asks for the minimum number of stitches required to make a conflict graph $G=(V,E)$ bipartite. A stitch applied to a feature, represented by a vertex $v \\in V$, is modeled as removing $v$ from the graph. The goal is thus to find a minimum-cardinality set of vertices $S \\subseteq V$ such that the induced subgraph $G-S$ is bipartite. A graph is bipartite if and only if it contains no odd-length cycles. Therefore, the set $S$ must be a minimum set of vertices that intersects every odd cycle in $G$. Such a set is known in graph theory as a minimum odd cycle transversal.\n\nThe prescribed algorithm is to search for the smallest integer $k \\geq 0$ for which there exists a subset $S \\subseteq V$ with $|S|=k$ such that $G-S$ is bipartite. This is a brute-force search strategy that is guaranteed to find the minimum $k$ because it inspects subset cardinalities in increasing order, from $k=0, 1, 2, \\dots, |V|$.\n\nThe algorithm proceeds as follows:\n1.  Let $k$ be the size of the vertex set $S$ to be removed (number of stitches). We start with $k=0$.\n2.  For a given $k$, generate all distinct subsets $S \\subseteq V$ of cardinality $k$.\n3.  For each subset $S$, construct the induced subgraph $G-S$. This subgraph consists of the vertices $V' = V \\setminus S$ and all edges from the original graph $E$ that have both endpoints in $V'$.\n4.  Test if the subgraph $G-S$ is bipartite. If it is, then we have found a valid set of stitches of size $k$. Since we are iterating on $k$ in increasing order, this $k$ must be the minimum number of required stitches. The algorithm can terminate and return $k$.\n5.  If no subset of size $k$ results in a bipartite subgraph, increment $k$ by $1$ and repeat from step 2. The process is guaranteed to terminate, as removing all vertices (i.e., $S=V$, $k=|V|$) results in an empty graph, which is trivially bipartite.\n\nThe core of the algorithm is the bipartiteness test for a given graph (or subgraph). A graph is bipartite if and only if its vertices can be partitioned into two disjoint and independent sets, $U_1$ and $U_2$, such that every edge connects a vertex in $U_1$ to one in $U_2$. This is equivalent to checking if the graph is $2$-colorable. A standard method for this is to use a graph traversal algorithm like Breadth-First Search (BFS) or Depth-First Search (DFS).\n\nThe BFS-based $2$-coloring algorithm works as follows for a graph $G'=(V', E')$:\n1.  Create a `color` data structure, e.g., an array or hash map, to store the color of each vertex in $V'$. Initialize all vertices as uncolored (e.g., color $0$). Let the two colors be $1$ and $-1$.\n2.  Iterate through each vertex $v \\in V'$. If $v$ is uncolored:\n    a. Assign a starting color to $v$, say color $1$.\n    b. Begin a BFS traversal starting from $v$. Add $v$ to a queue.\n    c. While the queue is not empty:\n        i.   Dequeue a vertex $u$.\n        ii.  For each neighbor $w$ of $u$:\n             - If $w$ is uncolored, assign it the opposite color of $u$ (i.e., `color[w] = -color[u]`) and enqueue $w$.\n             - If $w$ is already colored and `color[w] == color[u]`, then an edge connects two vertices of the same color. This indicates the presence of an odd-length cycle. The graph is not bipartite. The test fails.\n3.  If the traversal completes for all connected components of the graph without finding any same-colored neighbors, the graph is successfully $2$-colored and is therefore bipartite. The test succeeds.\n\nAn adjacency list representation is efficient for implementing the BFS traversal. For each test case, we define the graph by its number of vertices $n$ and its edge list $E$. The main loop iterates $k$ from $0$ to $n$. An inner loop generates all combinations of $k$ vertices to form the set $S$. For each $S$, we apply the bipartiteness test on $G-S$. The first $k$ for which the test passes is the solution for that test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through each test case, finds the minimum number of stitches,\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1: n=4, E={(0,1),(1,2),(2,3)}\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Case 2: n=3, E={(0,1),(1,2),(2,0)}\n        (3, [(0, 1), (1, 2), (2, 0)]),\n        # Case 3: n=4, E={(0,1),(1,2),(2,3),(3,0)}\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Case 4: n=4, E={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)}\n        (4, [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]),\n        # Case 5: n=5, E={(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)}\n        (5, [(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)]),\n        # Case 6: n=6, E={(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)}\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)]),\n        # Case 7: n=5, E={(0,1),(1,2),(2,3),(3,4),(4,0)}\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Case 8: n=1, E={}\n        (1, []),\n        # Case 9: n=6, E={(0,1),(0,2),(0,3),(0,4),(0,5)}\n        (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        min_stitches = find_min_stitches(n, edges)\n        results.append(min_stitches)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef is_bipartite(num_vertices, edges, removed_vertices):\n    \"\"\"\n    Checks if the subgraph G-S is bipartite using BFS-based 2-coloring.\n    S is the set of removed_vertices.\n    \"\"\"\n    removed_set = set(removed_vertices)\n    \n    # Adjacency list for the subgraph G-S\n    adj = {i: [] for i in range(num_vertices) if i not in removed_set}\n    if not adj:  # Empty graph is bipartite\n        return True\n\n    for u, v in edges:\n        if u not in removed_set and v not in removed_set:\n            adj[u].append(v)\n            adj[v].append(u)\n    \n    # colors map: 0 for uncolored, 1 & -1 for the two colors\n    colors = {}\n    \n    # Iterate through all vertices to handle disconnected components\n    for i in adj:\n        if i not in colors:\n            colors[i] = 1\n            queue = deque([i])\n            \n            while queue:\n                u = queue.popleft()\n                \n                for v in adj[u]:\n                    if v not in colors:\n                        colors[v] = -colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        # Found an edge connecting two same-colored vertices,\n                        # which implies an odd cycle.\n                        return False\n    return True\n\n\ndef find_min_stitches(n, edges):\n    \"\"\"\n    Finds the minimum number of stitches (vertices to remove) to make the\n    graph bipartite by enumerating subsets of vertices of increasing size.\n    \"\"\"\n    vertices = list(range(n))\n    \n    # k is the number of stitches (vertices to remove)\n    for k in range(n + 1):\n        # Generate all subsets of vertices of size k\n        for s in itertools.combinations(vertices, k):\n            if is_bipartite(n, edges, s):\n                return k\n    return n # Should not be reached in practice as an empty graph is bipartite\n\nsolve()\n```"
        },
        {
            "introduction": "While enumeration is useful for understanding the stitch minimization problem on small graphs, it is not scalable for realistic layouts. This advanced practice introduces Integer Linear Programming (ILP), a powerful and versatile framework used in industry to solve complex optimization tasks. You will formulate the stitch minimization problem, including variable costs and physical continuity constraints, as a formal ILP, learning how to translate intricate design rules into a solvable mathematical model .",
            "id": "4284590",
            "problem": "In multiple patterning for Double Patterning Lithography (DPL) within Electronic Design Automation (EDA), a conflict graph models minimum-spacing violations: each vertex corresponds to a printable polygonal feature and each conflict edge indicates two features that must be assigned to different masks. A stitch splits a single feature into two printable fragments that may be assigned different masks, but incurs overlay risk quantified as a cost weight. The design objective is to minimize total stitch cost while ensuring all conflict edges are satisfied and stitched fragments remain physically continuous unless a stitch is invoked.\n\nConsider a layout with features indexed by the set $V=\\{1,2,3,4,5\\}$. The conflict edges are\n$$E=\\{(1,2),(2,3),(3,4),(4,5),(5,1),(2,5)\\}.$$\nFeature $2$ is a pre-colored anchor constrained to mask $0$, i.e., its binary color variable must satisfy $x_2=0$. Binary color variables $x_i\\in\\{0,1\\}$ represent mask assignment for each feature $i$, where $0$ and $1$ denote the two masks.\n\nStitches are available on features $1$, $3$, and $4$. If a stitch is inserted on feature $i\\in\\{1,3,4\\}$, the feature is split into two printable fragments with binary color variables $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$, and a binary stitch variable $s_i\\in\\{0,1\\}$ indicates whether the stitch is used ($s_i=1$) or not ($s_i=0$). When no stitch is used ($s_i=0$), the two fragments must remain continuous in color. When a stitch is used ($s_i=1$), the two fragments may take different colors. The stitch costs are $\\alpha_1=2$, $\\alpha_3=1$, and $\\alpha_4=1.5$, and the objective is to minimize the total stitch cost $\\sum_{i\\in\\{1,3,4\\}}\\alpha_i s_i$.\n\nFor conflict edges incident to a stitched feature $i$, the neighbor on one geometrical side interacts with $x_i^{(L)}$ and the neighbor on the other side interacts with $x_i^{(R)}$:\n- For feature $1$: $(1,2)$ couples to $x_1^{(L)}$ and $(1,5)$ couples to $x_1^{(R)}$.\n- For feature $3$: $(2,3)$ couples to $x_3^{(L)}$ and $(3,4)$ couples to $x_3^{(R)}$.\n- For feature $4$: $(3,4)$ couples to $x_4^{(L)}$ and $(4,5)$ couples to $x_4^{(R)}$.\n\nAll non-stitched features use a single variable $x_i$. All conflict edges must be assigned to different masks. All stitched fragments must obey continuity unless the stitch variable permits a color difference.\n\nTask: Starting from the core definitions of binary mask assignment and physical continuity of stitched fragments, formulate an Integer Linear Programming (ILP) model in terms of the binary variables $x_i$, $x_i^{(L)}$, $x_i^{(R)}$, and $s_i$ that minimizes the total stitch cost subject to the mask-difference constraints on conflict edges and the continuity constraints for stitched fragments. Then, solve the ILP for this instance to determine the minimum possible objective value\n$$\\sum_{i\\in\\{1,3,4\\}}\\alpha_i s_i.$$\nExpress the final answer as a single real number. No rounding is required.",
            "solution": "We begin from the mapping between Double Patterning Lithography (DPL) and graph $2$-coloring: any conflict edge requires its endpoints to be assigned to different masks. Using binary color variables $x\\in\\{0,1\\}$ to indicate the mask, the requirement that two variables differ can be written equivalently as $|x_u - x_v| = 1$ for binary endpoints $x_u,x_v\\in\\{0,1\\}$. Because $x_u,x_v$ are binary, $|x_u-x_v|=1$ is equivalent to $x_u + x_v = 1$.\n\nFor a stitched feature $i$ split into two fragments with binary variables $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$ and a stitch variable $s_i\\in\\{0,1\\}$, physical continuity dictates that when $s_i=0$ the fragments must be the same color, and when $s_i=1$ a color difference is permitted. A standard linear encoding of this rule is\n$$|x_i^{(L)} - x_i^{(R)}| \\le s_i,$$\nwhich can be linearized for binary variables by the pair of inequalities\n\\begin{align*}\nx_i^{(L)} - x_i^{(R)} &\\le s_i,\\\\\nx_i^{(R)} - x_i^{(L)} &\\le s_i.\n\\end{align*}\nIf $s_i=0$, these constraints force $x_i^{(L)}=x_i^{(R)}$. If $s_i=1$, they allow $x_i^{(L)}\\neq x_i^{(R)}$.\n\nWe now formulate the Integer Linear Programming (ILP) model. Decision variables:\n- For unstitched features $i\\in V\\setminus\\{1,3,4\\}$, a binary $x_i\\in\\{0,1\\}$.\n- For stitched-capable features $i\\in\\{1,3,4\\}$, binary fragment variables $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$ and a binary stitch variable $s_i\\in\\{0,1\\}$.\n- The anchor constraint fixes $x_2=0$.\n\nObjective:\n$$\\min \\sum_{i\\in\\{1,3,4\\}} \\alpha_i s_i \\quad \\text{with} \\quad \\alpha_1=2,\\ \\alpha_3=1,\\ \\alpha_4=1.5.$$\n\nConstraints enforcing conflict edges across the instance, adopting the fragment coupling specified:\n- Edge $(1,2)$: $x_1^{(L)} + x_2 = 1$.\n- Edge $(1,5)$: $x_1^{(R)} + x_5 = 1$.\n- Edge $(2,3)$: $x_2 + x_3^{(L)} = 1$.\n- Edge $(3,4)$: $x_3^{(R)} + x_4^{(L)} = 1$.\n- Edge $(4,5)$: $x_4^{(R)} + x_5 = 1$.\n- Edge $(2,5)$: $x_2 + x_5 = 1$.\n\nContinuity constraints for stitched features $i\\in\\{1,3,4\\}$:\n\\begin{align*}\nx_i^{(L)} - x_i^{(R)} &\\le s_i,\\\\\nx_i^{(R)} - x_i^{(L)} &\\le s_i.\n\\end{align*}\n\nWe now solve the ILP analytically by propagation from the anchor and conflict constraints.\n\nFrom the anchor, we have $x_2=0$. The chord edge $(2,5)$ enforces $x_2 + x_5 = 1$, hence\n$$x_5 = 1.$$\nConsider the triangle formed by edges $(1,2)$, $(2,5)$, and $(5,1)$. Without a stitch on feature $1$ (or on feature $2$ or $5$), this triangle cannot be $2$-colored because it is an odd cycle. Since stitches are only available on features $1$, $3$, and $4$, the only way to resolve this triangle is to use the stitch at feature $1$ so that its two fragments may take different colors.\n\nWe verify necessity and sufficiency by explicit assignment:\n\n- From $(1,2)$, $x_1^{(L)} + x_2 = 1$ gives\n$$x_1^{(L)} = 1.$$\n- From $(1,5)$, $x_1^{(R)} + x_5 = 1$ gives\n$$x_1^{(R)} = 0.$$\nThese imply\n$$|x_1^{(L)} - x_1^{(R)}| = |1 - 0| = 1,$$\nwhich forces $s_1 \\ge 1$. Since $s_1\\in\\{0,1\\}$, we have\n$$s_1 = 1.$$\n\nProceeding along the chain $2\\to 3\\to 4\\to 5$:\n- Edge $(2,3)$ enforces $x_2 + x_3^{(L)} = 1$, so\n$$x_3^{(L)} = 1.$$\n- Edge $(3,4)$ enforces $x_3^{(R)} + x_4^{(L)} = 1$. We do not yet know $x_3^{(R)}$ or $x_4^{(L)}$, but we use the forward constraint from $(4,5)$ next.\n- Edge $(4,5)$ enforces $x_4^{(R)} + x_5 = 1$, hence\n$$x_4^{(R)} = 0.$$\nWe also need $(3,4)$ to be satisfied. Set $x_4^{(L)}=0$; then $(3,4)$ gives $x_3^{(R)} + 0 = 1$, so\n$$x_3^{(R)} = 1.$$\n\nFinally, check continuity constraints for stitched features $3$ and $4$:\n- For feature $3$, $x_3^{(L)}=1$ and $x_3^{(R)}=1$ yield $|x_3^{(L)} - x_3^{(R)}| = 0 \\le s_3$, so we can take $s_3=0$.\n- For feature $4$, $x_4^{(L)}=0$ and $x_4^{(R)}=0$ yield $|x_4^{(L)} - x_4^{(R)}| = 0 \\le s_4$, so we can take $s_4=0$.\n\nAll conflict edges are satisfied:\n\\begin{align*}\n(1,2)&:\\ x_1^{(L)} + x_2 = 1 + 0 = 1,\\\\\n(1,5)&:\\ x_1^{(R)} + x_5 = 0 + 1 = 1,\\\\\n(2,3)&:\\ x_2 + x_3^{(L)} = 0 + 1 = 1,\\\\\n(3,4)&:\\ x_3^{(R)} + x_4^{(L)} = 1 + 0 = 1,\\\\\n(4,5)&:\\ x_4^{(R)} + x_5 = 0 + 1 = 1,\\\\\n(2,5)&:\\ x_2 + x_5 = 0 + 1 = 1.\n\\end{align*}\nThus the assignment is feasible with $s_1=1$, $s_3=0$, $s_4=0$, and the objective value is\n$$\\sum_{i\\in\\{1,3,4\\}} \\alpha_i s_i = 2\\cdot 1 + 1\\cdot 0 + 1.5\\cdot 0 = 2.$$\n\nTo argue minimality, observe that the odd cycle on $\\{1,2,5\\}$ must be broken by allowing a color flip along one of its vertices. Since stitches are only available on features $1$, $3$, and $4$, and features $3$ and $4$ are not in the triangle, the only viable stitch is at feature $1$. Therefore, any feasible solution must have $s_1=1$, and there is no need to incur additional stitches. Hence the minimum possible objective value is exactly $2$.",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}