{
    "hands_on_practices": [
        {
            "introduction": "任何稳健的电路设计都始于深刻理解其输出如何响应内部参数的变化。本练习聚焦于符号级的灵敏度分析，这是评估和优化模拟电路性能的基石。通过推导基准电压对关键参数（如电阻比和器件特性）的偏导数，你将学会量化地识别出对电路精度影响最大的因素，从而为后续的设计优化和修调策略提供明确的指引 。",
            "id": "4257169",
            "problem": "集成电路中的一个模拟带隙基准源由两个偏置在不同电流密度下的匹配双极结型晶体管 (BJT) 和一个电阻网络构成，并通过一个高增益运算放大器闭合环路。在传统拓扑结构中，一个 BJT 工作在由发射极面积比缩放的电流密度下，产生一个基极-发射极电压差，该电压差被用来生成一个与绝对温度成正比 (Proportional To Absolute Temperature, PTAT) 的电压。然后，该 PTAT 电压由一个电阻比进行缩放，并与一个基极-发射极电压相加以合成一个对温度不敏感的基准电压。考虑以下基于第一性原理和经过充分检验的公式的建模假设。\n\n1. 热电压为 $V_{T} = \\frac{k_{B} T}{q}$，其中 $k_{B}$ 是玻尔兹曼常数 (Boltzmann constant)，$q$ 是基本电荷，而 $T$ 是绝对温度。在本题中，将 $T$ 视为固定值。\n\n2. BJT 的基极-发射极电压遵循 $V_{BE} = V_{T} \\ln\\!\\left(\\frac{I_{C}}{I_{S}}\\right)$，其中 $I_{C}$ 是集电极电流，$I_{S}$ 是饱和电流。假设 $I_{C}$ 由一个偏置网络固定，且独立于此处变化的参数。\n\n3. PTAT 生成器使用两个发射极面积比为 $N$（其中 $N > 1$）的 BJT，在一个电阻 $R_{1}$ 两端产生 $\\Delta V_{BE} = V_{T} \\ln(N)$ 的电压，从而设定一个电流 $I_{PTAT} = \\frac{V_{T} \\ln(N)}{R_{1}}$。在 $R_{2}$ 两端产生的 PTAT 电压为 $V_{PTAT} = I_{PTAT} R_{2}$。定义电阻比 $m = \\frac{R_{2}}{R_{1}}$。\n\n4. 运算放大器具有有限的直流 (DC) 增益 $A_{0}$，并且 PTAT 路径被布置在近似单位增益的反馈配置中，使得 PTAT 项的闭环缩放因子被典型的因子 $\\alpha(A_{0}) = \\frac{A_{0}}{1 + A_{0}}$ 所减小。对于处于类单位反馈环路中的高增益放大器，此近似是合适的，并忽略了如有限带宽和输出电阻等高阶效应。\n\n在这些假设下，基准电压可以建模为一个基极-发射极电压和一个经缩放的 PTAT 项之和。从上述物理定义出发，首先推导基准电压 $V_{ref}$ 对参数 $m$、$N$、$I_{S}$ 和 $A_{0}$ 的函数依赖关系，保持 $T$ 和 $I_{C}$ 不变。然后，进行符号灵敏度分析：计算四个偏导数 $\\frac{\\partial V_{ref}}{\\partial m}$、$\\frac{\\partial V_{ref}}{\\partial N}$、$\\frac{\\partial V_{ref}}{\\partial I_{S}}$ 和 $\\frac{\\partial V_{ref}}{\\partial A_{0}}$。\n\n将最终结果表示为包含这四个偏导数的单个行向量，顺序为 $\\left(\\frac{\\partial V_{ref}}{\\partial m}, \\frac{\\partial V_{ref}}{\\partial N}, \\frac{\\partial V_{ref}}{\\partial I_{S}}, \\frac{\\partial V_{ref}}{\\partial A_{0}}\\right)$。不需要进行数值计算。不需要四舍五入。最终表达式中不包含单位。",
            "solution": "该问题已经过验证，被认为是科学上合理的、适定的和客观的。所有假设和定义在模拟集成电路设计领域都是标准的，并构成一个自洽、一致的陈述集合。该问题需要进行标准的灵敏度分析，这是一项可形式化且有意义的任务。因此，我将着手推导解决方案。\n\n目标是首先推导出基准电压 $V_{ref}$ 的表达式，然后计算其关于参数 $m$、$N$、$I_{S}$ 和 $A_{0}$ 的偏导数。\n\n首先，我们构建基准电压 $V_{ref}$ 的表达式。问题陈述 $V_{ref}$ 是一个基极-发射极电压 $V_{BE}$ 和一个经缩放的与绝对温度成正比 (PTAT) 的项之和。\n\n基极-发射极电压由标准 BJT 模型给出：\n$$V_{BE} = V_{T} \\ln\\left(\\frac{I_{C}}{I_{S}}\\right)$$\n其中 $V_{T} = \\frac{k_{B} T}{q}$ 是热电压，$I_{C}$ 是集电极电流，$I_{S}$ 是饱和电流。在本次分析中，$V_{T}$ 和 $I_{C}$ 均被视为固定参数。\n\n接下来，我们构建 PTAT 电压项 $V_{PTAT}$。它由两个发射极面积比为 $N$ 的 BJT 的基极-发射极电压差生成。该差值表示为：\n$$\\Delta V_{BE} = V_{T} \\ln(N)$$\n此电压施加于电阻 $R_{1}$ 两端以生成 PTAT 电流：\n$$I_{PTAT} = \\frac{\\Delta V_{BE}}{R_{1}} = \\frac{V_{T} \\ln(N)}{R_{1}}$$\n该电流随后流过电阻 $R_{2}$ 以产生 PTAT 电压：\n$$V_{PTAT} = I_{PTAT} R_{2} = \\left(\\frac{V_{T} \\ln(N)}{R_{1}}\\right) R_{2}$$\n使用定义的电阻比 $m = \\frac{R_{2}}{R_{1}}$， $V_{PTAT}$ 的表达式简化为：\n$$V_{PTAT} = m V_{T} \\ln(N)$$\n问题指明，由于运算放大器的有限直流增益 $A_{0}$，该 PTAT 电压被一个因子 $\\alpha(A_{0})$ 缩放。该缩放因子为：\n$$\\alpha(A_{0}) = \\frac{A_{0}}{1 + A_{0}}$$\n因此，经缩放的 PTAT 项为 $\\alpha(A_{0}) V_{PTAT}$。\n\n总基准电压 $V_{ref}$ 是 $V_{BE}$ 和经缩放的 $V_{PTAT}$ 之和：\n$$V_{ref} = V_{BE} + \\alpha(A_{0}) V_{PTAT}$$\n代入各分量的表达式，我们得到 $V_{ref}$ 对指定参数的完整函数依赖关系：\n$$V_{ref}(m, N, I_{S}, A_{0}) = V_{T} \\ln\\left(\\frac{I_{C}}{I_{S}}\\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N)$$\n为便于求导，可将此表达式展开：\n$$V_{ref} = V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N)$$\n\n现在，我们通过计算四个所需的偏导数来进行灵敏度分析。\n\n1.  关于 $m$ 的偏导数：\n在此微分中，所有其他变量（$N$、$I_{S}$、$A_{0}$）和常量（$V_{T}$、$I_{C}$）均保持不变。\n$$\\frac{\\partial V_{ref}}{\\partial m} = \\frac{\\partial}{\\partial m} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\n第一项与 $m$ 无关，因此其导数为 $0$。\n$$\\frac{\\partial V_{ref}}{\\partial m} = \\frac{A_{0}}{1 + A_{0}} V_{T} \\ln(N) \\frac{\\partial}{\\partial m}(m) = \\frac{A_{0}}{1 + A_{0}} V_{T} \\ln(N)$$\n\n2.  关于 $N$ 的偏导数：\n此处，我们将 $m$、$I_{S}$ 和 $A_{0}$ 视为常量。\n$$\\frac{\\partial V_{ref}}{\\partial N} = \\frac{\\partial}{\\partial N} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\n第一项与 $N$ 无关。我们使用法则 $\\frac{d}{dx}\\ln(x) = \\frac{1}{x}$。\n$$\\frac{\\partial V_{ref}}{\\partial N} = \\frac{A_{0}}{1 + A_{0}} m V_{T} \\frac{\\partial}{\\partial N}(\\ln(N)) = \\frac{A_{0}}{1 + A_{0}} m V_{T} \\frac{1}{N}$$\n$$\\frac{\\partial V_{ref}}{\\partial N} = \\frac{m V_{T} A_{0}}{N(1 + A_{0})}$$\n\n3.  关于 $I_{S}$ 的偏导数：\n此处，我们将 $m$、$N$ 和 $A_{0}$ 视为常量。\n$$\\frac{\\partial V_{ref}}{\\partial I_{S}} = \\frac{\\partial}{\\partial I_{S}} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\n第二项与 $I_{S}$ 无关。\n$$\\frac{\\partial V_{ref}}{\\partial I_{S}} = V_{T} \\frac{\\partial}{\\partial I_{S}}( \\ln(I_{C}) - \\ln(I_{S}) ) = V_{T} \\left( 0 - \\frac{1}{I_{S}} \\right)$$\n$$\\frac{\\partial V_{ref}}{\\partial I_{S}} = -\\frac{V_{T}}{I_{S}}$$\n\n4.  关于 $A_{0}$ 的偏导数：\n此处，我们将 $m$、$N$ 和 $I_{S}$ 视为常量。\n$$\\frac{\\partial V_{ref}}{\\partial A_{0}} = \\frac{\\partial}{\\partial A_{0}} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\n第一项与 $A_{0}$ 无关。对项 $\\frac{A_{0}}{1 + A_{0}}$ 的微分需要使用商法则。令 $u = A_{0}$ 且 $v = 1 + A_{0}$。则 $u' = 1$ 且 $v' = 1$。\n$$\\frac{\\partial}{\\partial A_{0}}\\left( \\frac{A_{0}}{1 + A_{0}} \\right) = \\frac{u'v - uv'}{v^{2}} = \\frac{1(1 + A_{0}) - A_{0}(1)}{(1 + A_{0})^{2}} = \\frac{1}{(1 + A_{0})^{2}}$$\n将此结果代回 $V_{ref}$ 的偏导数表达式中：\n$$\\frac{\\partial V_{ref}}{\\partial A_{0}} = m V_{T} \\ln(N) \\left( \\frac{1}{(1 + A_{0})^{2}} \\right)$$\n$$\\frac{\\partial V_{ref}}{\\partial A_{0}} = \\frac{m V_{T} \\ln(N)}{(1 + A_{0})^{2}}$$\n\n四个偏导数已计算完毕。最终结果是按指定顺序包含这些表达式的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{A_{0} V_{T} \\ln(N)}{1 + A_{0}}  \\frac{m V_{T} A_{0}}{N(1 + A_{0})}  -\\frac{V_{T}}{I_{S}}  \\frac{m V_{T} \\ln(N)}{(1 + A_{0})^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在识别出影响电路性能的关键敏感参数后，下一步自然是采用修调技术来补偿工艺偏差，以精确达到目标电压。本练习将带你深入探究数字修调系统的实际应用及其内禀限制。通过分析一个典型的修调场景，你将掌握一个核心概念：离散的修调机制必然会引入量化误差，这个误差决定了电路通过修调所能达到的最终精度极限 。",
            "id": "4257162",
            "problem": "一个硅带隙基准电压源采用基极-发射极电压与一个经过缩放的、与绝对温度成正比的项的典型求和方式，其比例因子记为 $m$。在生产中，$m$ 通过一个 $6$ 位电子熔丝 (eFuse) 梯形网络进行数字修调，该网络以相对于标称设计值 $m_0$ 的 $0.1\\%$ 的均匀分数步长来调整 $m$。数字修调码 $c \\in \\{-32,-31,\\dots,+31\\}$ 实现\n$$\nm(c) = m_0\\left(1 + s\\,c\\right),\n$$\n其中分数步长为 $s = 10^{-3}$。由于工艺变化，未经修调的比例因子会偏离 $m_0$ 一个未知的分数偏移量 $\\delta$，因此校正后的目标值为 $m_{\\mathrm{target}} = m_0(1+\\delta)$，其中 $|\\delta| \\le B$，边界值为 $B = 3.0\\times 10^{-2}$。修调算法通过四舍五入到最接近的可用码来选择 $c$，以最小化绝对误差 $|m_{\\mathrm{target}} - m(c)|$，并受限于端点处的削波。\n\n从均匀量化和离散码范围的定义出发，推导最坏情况下的残余分数误差\n$$\n\\epsilon_{\\max} = \\max_{|\\delta|\\le B}\\left|\\frac{m_{\\mathrm{target}} - m(c^{\\star}(\\delta))}{m_0}\\right|,\n$$\n其中 $c^{\\star}(\\delta)$ 是针对给定 $\\delta$ 所选的修调码。假设只要边界值 $B$ 严格位于梯形网络可实现的分数范围内，均匀量化模型就有效。将最终答案表示为单个小数，不要使用百分号。无需四舍五入。",
            "solution": "该问题经确认为自洽、有科学依据且定义明确。所有提供的数据、定义和条件都是一致且充分的，足以推导出唯一解。所描述的场景是数字修调模拟电路设计中的一个标准问题，特别是分析线性修调系统的量化误差。\n\n**第一步：提取已知条件**\n-   修调后的比例因子：$m(c) = m_0(1 + sc)$\n-   数字修调码：$c \\in \\{-32, -31, \\dots, +31\\}$，一个包含 $64$ 个整数值的集合。\n-   分数步长：$s = 10^{-3}$，对应于 $0.1\\%$。\n-   目标比例因子：$m_{\\mathrm{target}} = m_0(1+\\delta)$，其中 $\\delta$ 是一个未知的分数偏移量。\n-   偏移量的边界：$|\\delta| \\le B$，其中 $B = 3.0 \\times 10^{-2}$。\n-   修调目标：通过选择最优整数码 $c^{\\star}$ 来最小化绝对误差 $|m_{\\mathrm{target}} - m(c)|$。方法是四舍五入到最接近的可用码。\n-   削波：如果理想码落在可用范围之外，所选的码将被削波至范围的端点。\n-   待求量：最坏情况下的残余分数误差，$\\epsilon_{\\max} = \\max_{|\\delta|\\le B}\\left|\\frac{m_{\\mathrm{target}} - m(c^{\\star}(\\delta))}{m_0}\\right|$。\n-   假设：由于边界值 $B$ 严格位于修调梯形网络的可实现分数范围内，均匀量化模型有效。\n\n**第二步：问题分析与求解推导**\n残余分数误差（记为 $\\epsilon(\\delta)$）定义为：\n$$\n\\epsilon(\\delta) = \\left|\\frac{m_{\\mathrm{target}} - m(c^{\\star}(\\delta))}{m_0}\\right|\n$$\n代入 $m_{\\mathrm{target}}$ 和 $m(c)$ 的给定表达式：\n$$\n\\epsilon(\\delta) = \\left|\\frac{m_0(1+\\delta) - m_0(1+sc^{\\star})}{m_0}\\right|\n$$\n公因子 $m_0$ 可以消去，表达式简化为：\n$$\n\\epsilon(\\delta) = |(1+\\delta) - (1+sc^{\\star})| = |\\delta - sc^{\\star}|\n$$\n题目指出，修调算法选择整数码 $c^{\\star}$ 来最小化此误差 $|\\delta - sc^{\\star}|$。这等效于最小化距离 $| \\frac{\\delta}{s} - c^{\\star} |$。对于一个整数码 $c^{\\star}$，当 $c^{\\star}$ 是最接近连续值 $\\frac{\\delta}{s}$ 的整数时，该距离最小。这个过程称为四舍五入。\n$$\nc^{\\star}(\\delta) = \\text{round}\\left(\\frac{\\delta}{s}\\right)\n$$\n我们现在必须考虑修调码 $c \\in \\{-32, \\dots, +31\\}$ 的有限范围以及削波的可能性。初始分数偏移的范围由 $|\\delta| \\le B$ 给出，即 $\\delta \\in [-3.0 \\times 10^{-2}, 3.0 \\times 10^{-2}]$。我们来确定“理想”连续码 $\\frac{\\delta}{s}$ 的相应范围：\n$$\n\\frac{\\delta}{s} \\in \\left[\\frac{-3.0 \\times 10^{-2}}{10^{-3}}, \\frac{3.0 \\times 10^{-2}}{10^{-3}}\\right] = [-30, 30]\n$$\n可用的整数码在集合 $\\{-32, -31, \\dots, +30, +31\\}$ 中。理想码 $\\frac{\\delta}{s}$ 始终在 $[-30, 30]$ 的范围内。当此区间内的任何实数四舍五入到最接近的整数时，结果也将落在整数区间 $[-30, 30]$ 内。由于四舍五入后的码区间 $[-30, 30]$ 是可用码 $\\{-32, \\dots, +31\\}$ 的严格子集，因此对于所考虑的任何 $\\delta$，所选的码 $c^{\\star}$ 永远不需要在端点处进行削波。这证实了题目中关于均匀量化模型有效性的假设。\n\n排除了削波的可能性后，问题简化为对均匀量化误差的标准分析。残余分数误差由下式给出：\n$$\n\\epsilon(\\delta) = \\left|\\delta - s \\cdot \\text{round}\\left(\\frac{\\delta}{s}\\right)\\right|\n$$\n我们可以提出步长 $s$：\n$$\n\\epsilon(\\delta) = s \\left|\\frac{\\delta}{s} - \\text{round}\\left(\\frac{\\delta}{s}\\right)\\right|\n$$\n设变量 $x = \\frac{\\delta}{s}$。误差的表达式变为 $s|x - \\text{round}(x)|$。项 $|x - \\text{round}(x)|$ 是标准四舍五入操作的量化误差的大小。该项的最大值为 $0.5$。这种最坏情况发生在 $x$ 正好位于两个整数中间时，即对于某个整数 $k$，$x = k + 0.5$。\n\n例如，考虑 $x = 0.5$ 的情况。这对应于初始偏移 $\\delta = x \\cdot s = 0.5 \\times 10^{-3} = 0.0005$。这个 $\\delta$ 值在允许的边界内，因为 $|0.0005| \\le 0.03$。对于这个 $\\delta$，最优码 $c^{\\star}$ 将是 $0$ 或 $1$，具体取决于四舍五入的取舍规则。\n- 如果 $c^{\\star} = 0$，误差为 $|\\delta - s \\cdot 0| = |0.0005| = 0.0005$。\n- 如果 $c^{\\star} = 1$，误差为 $|\\delta - s \\cdot 1| = |0.0005 - 0.001| = |-0.0005| = 0.0005$。\n在这两种情况下，误差的大小是相同的。\n\n最坏情况下的残余分数误差 $\\epsilon_{\\max}$ 是在 $\\delta$ 的整个范围内 $\\epsilon(\\delta)$ 的最大值。这发生在量化误差项最大化时：\n$$\n\\epsilon_{\\max} = \\max_{|\\delta|\\le B} \\left(s \\left|\\frac{\\delta}{s} - \\text{round}\\left(\\frac{\\delta}{s}\\right)\\right|\\right) = s \\cdot \\max_{x} |x - \\text{round}(x)|\n$$\n$$\n\\epsilon_{\\max} = s \\cdot (0.5)\n$$\n代入 $s = 10^{-3}$ 的值：\n$$\n\\epsilon_{\\max} = 10^{-3} \\times 0.5 = 0.0005\n$$\n这表示在修调过程完成后可能残留的最大分数误差，其值对应于最小修调步长的一半。",
            "answer": "$$\n\\boxed{0.0005}\n$$"
        },
        {
            "introduction": "真实的集成电路设计是一个复杂的多目标优化问题，需要在精度、功耗和面积等多个维度之间做出权衡，并确保在所有工艺角（corners）和工作环境下性能的稳健性。这个综合性练习将引导你模拟现代EDA（电子设计自动化）工具的自动化设计流程。通过编写一个脚本来执行面向工艺角的优化，你将学习如何系统性地搜索设计空间，并识别出提供最佳性能权衡的帕累托最优设计集合，这正是高级电路设计师的核心技能之一 。",
            "id": "4257125",
            "problem": "您的任务是为某个带隙基准电压源实现一个角点感知优化。该基准电压源结合了互补于绝对温度（CTAT）的硅双极结型晶体管基极-发射极电压和正比于绝对温度（PTAT）的电压。目标是选择电阻的几何面积和运算放大器的偏置电流，以在修调后最小化一组工艺-温度角点下的最坏情况基准电压误差，并解释面积、功耗和误差之间的帕累托权衡。您的程序必须是一个可运行的完整程序，用于计算和汇总指定测试套件的结果。\n\n从以下基本原理开始：\n- 热电压为 $V_{t}(T) = \\dfrac{k T}{q}$，其中 $k$ 是玻尔兹曼常数， $q$ 是元电荷。\n- PTAT生成器使用发射极面积比为 $N$ 的两个双极结型晶体管产生一个电压差 $\\Delta V_{\\mathrm{PTAT}}(T) = V_{t}(T)\\,\\ln(N)$，其中 $\\ln(\\cdot)$ 表示自然对数。\n- 基极-发射极电压建模为 $V_{BE}(T) = V_{BE}(T_{0}) + \\beta\\,(T - T_{0})$，其中 $T_{0}$ 是修调温度，$\\beta$ 是一阶温度系数。在适度的温度范围内，此近似在带隙基准的设计计算中被广泛使用并经过经验验证。\n- 带隙基准通过电阻比 $r = R_{2}/R_{1}$ 结合CTAT和PTAT分量，形成 $V_{\\mathrm{ref}}(T)$，其中修调以离散步长调整 $R_{2}$。修调仅在修调温度 $T_{0}$ 下执行。\n- 电阻失配遵循Pelgrom定律：每个电阻值的分数标准差为 $\\sigma_{R}/R = A_{R}/\\sqrt{A}$，其中 $A$ 是电阻的几何面积， $A_{R}$ 是工艺失配常数。假设独立，对于比率 $r = R_{2}/R_{1}$，其比率失配标准差约为 $\\sigma_{r} \\approx \\sqrt{\\left(\\dfrac{A_{R}}{\\sqrt{A_{1}}}\\right)^{2} + \\left(\\dfrac{A_{R}}{\\sqrt{A_{2}}}\\right)^{2}}$，对应面积为 $A_{1}$ 和 $A_{2}$。\n- 运算放大器的输入参考失调标准差随偏置电流的近似关系为 $\\sigma_{v_{\\mathrm{os}}} = \\dfrac{K_{\\mathrm{vos}}}{\\sqrt{I_{\\mathrm{bias}}/1\\,\\mu\\mathrm{A}}}$，其中 $K_{\\mathrm{vos}}$ 是一个工艺常数， $I_{\\mathrm{bias}}$ 是偏置电流。这是一个基于器件噪声-面积-电流比例关系且经过充分检验的启发式模型。\n- 运放通过感知 $\\Delta V_{\\mathrm{PTAT}}(T)$ 来强制PTAT电流流过 $R_{1}$；其输入参考失调为PTAT电流增加一个误差项，该误差项通过 $R_{2}$ 作为加法项传播。修调 $R_{2}$ 会改变PTAT增益，从而同时影响失调校正和温度斜率。\n\n您的程序中要使用的设计模型：\n- 基准电压建模为\n$$\nV_{\\mathrm{ref}}(T) = V_{BE}(T) + r\\,\\Delta V_{\\mathrm{PTAT}}(T) + r\\,v_{\\mathrm{os}},\n$$\n其中 $r$ 是考虑失配和修调后的有效电阻比， $v_{\\mathrm{os}}$ 是运算放大器的失调（在给定实例中建模为常数）。\n- 标称比率 $r_{\\mathrm{nom}}$ 的选择是为了在标称 $\\beta_{\\mathrm{nom}}$ 下抵消一阶温度系数，通过 $r_{\\mathrm{nom}}\\,\\ln(N) \\approx -\\beta_{\\mathrm{nom}}\\,\\dfrac{q}{k}$ 实现，这来自于将 $\\dfrac{d}{dT}\\left(V_{BE}(T) + r\\,V_{t}(T)\\,\\ln(N)\\right) \\approx 0$ 在一阶近似下设为零。\n- 失配会扰动该比率，得到 $r_{\\mathrm{pre}} = r_{\\mathrm{nom}}\\,(1 + \\varepsilon)$，其中 $\\varepsilon$ 是一个比率误差。修调通过一个离散分数步长修改 $R_{2}$，得到 $r = r_{\\mathrm{pre}}\\,(1 + c\\,s)$，其中 $c$ 是有界范围内的整数修调码，$s$ 是每个码的分数步长大小。\n- 修调在 $T_{0}$ 进行，选择 $c$ 以在给定的角点、失配和失调下最小化 $\\left|V_{\\mathrm{ref}}(T_{0}) - V_{\\mathrm{ref,target}}\\right|$，并受限于离散的修调步长和码边界。\n\n角点感知的最坏情况评估：\n- 考虑工艺-温度角点 $\\{(V_{BE}(T_{0}), \\beta)\\}$ 和温度 $T \\in \\{T_{\\min}, T_{0}, T_{\\max}\\}$。\n- 对于每个设计、每个角点、以及每个失配和运放失调的极端情况（两者均使用 $\\pm 3\\sigma$），在 $T_{0}$ 选择修调码以最小化 $T_{0}$ 处的误差。固定此修调码后，计算该集合中所有温度下的绝对误差。设计的最坏情况误差是所有角点、失配极端值、失调极端值和温度下的最大绝对误差。\n\n成本指标和帕累托解释：\n- 总面积为 $A_{\\mathrm{tot}} = A_{1} + A_{2}$。\n- 总功耗建模为 $P_{\\mathrm{tot}} = V_{\\mathrm{DD}}\\,\\left(I_{\\mathrm{bias}} + I_{\\mathrm{PTAT}}(T_{0})\\right)$，其中 $I_{\\mathrm{PTAT}}(T_{0}) = \\dfrac{\\Delta V_{\\mathrm{PTAT}}(T_{0})}{R_{1}}$ 且 $R_{1}$ 是一个固定的标称电阻值。功耗以 $\\mu\\mathrm{W}$ 表示，面积以 $\\mu\\mathrm{m}^{2}$ 表示。\n- 如果设计A在所有指标 $\\left(\\text{最坏情况误差}, A_{\\mathrm{tot}}, P_{\\mathrm{tot}}\\right)$ 上不比设计B差，并且在至少一个指标上严格更优，则设计A支配设计B。帕累托集是非支配设计的集合。\n\n您的程序必须：\n- 从指定的电阻面积和运放偏置电流的离散集合中枚举候选设计。\n- 对每个候选设计，按照上述方法计算修调后的最坏情况误差，以及总面积和总功耗。\n- 计算每个测试用例的非支配设计的帕累托集。\n- 对每个测试用例，输出一个包含四个条目的列表：所有设计中的最小最坏情况误差（单位 $\\mathrm{mV}$，四舍五入到三位小数），帕累托最优设计的数量（一个整数），帕累托最优设计中的最小总面积（单位 $\\mu\\mathrm{m}^{2}$，四舍五入到一位小数），以及帕累托最优设计中的最小总功耗（单位 $\\mu\\mathrm{W}$，四舍五入到三位小数）。\n\n您必须使用以下测试套件。所有符号和数字必须严格按照规定处理。\n\n全局常数和修调配置：\n- 玻尔兹曼常数 $k = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$。\n- 元电荷 $q = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$。\n- 修调温度 $T_{0} = 298.15\\,\\mathrm{K}$。\n- 评估温度 $T_{\\min} = 233.15\\,\\mathrm{K}$ (即 $-40\\,^{\\circ}\\mathrm{C}$), $T_{0} = 298.15\\,\\mathrm{K}$, 和 $T_{\\max} = 398.15\\,\\mathrm{K}$ (即 $125\\,^{\\circ}\\mathrm{C}$)。\n- 发射极面积比 $N = 8$，因此相应地使用 $\\ln(N)$。\n- 目标基准电压 $V_{\\mathrm{ref,target}} = 1.21\\,\\mathrm{V}$。\n- 电源电压 $V_{\\mathrm{DD}} = 1.8\\,\\mathrm{V}$。\n- 在 $T_{0}$ 时电阻 $R_{1} = 10\\,\\mathrm{k}\\Omega$。\n- 修调分数步长 $s$ 和码边界根据下面的每个测试用例确定。\n- 标称温度系数 $\\beta_{\\mathrm{nom}} = -1.8\\times 10^{-3}\\,\\mathrm{V/K}$。\n\n工艺-温度角点：\n- 典型角点： $(V_{BE}(T_{0}), \\beta) = (0.85\\,\\mathrm{V}, -1.8\\times 10^{-3}\\,\\mathrm{V/K})$。\n- 快速角点： $(V_{BE}(T_{0}), \\beta) = (0.84\\,\\mathrm{V}, -2.0\\times 10^{-3}\\,\\mathrm{V/K})$。\n- 慢速角点： $(V_{BE}(T_{0}), \\beta) = (0.86\\,\\mathrm{V}, -1.6\\times 10^{-3}\\,\\mathrm{V/K})$。\n\n失配和失调极端值：\n- 使用 $\\varepsilon \\in \\{\\,-3\\sigma_{r}, +3\\sigma_{r}\\,\\}$ 和 $v_{\\mathrm{os}} \\in \\{\\,-3\\sigma_{v_{\\mathrm{os}}}, +3\\sigma_{v_{\\mathrm{os}}}\\,\\}$。\n\n测试用例：\n- 测试用例 1 (通用情况):\n    - 电阻失配常数 $A_{R} = 0.001$。\n    - 运算放大器失调常数 $K_{\\mathrm{vos}} = 0.5\\times 10^{-3}\\,\\mathrm{V}\\cdot\\sqrt{\\mu\\mathrm{A}}$。\n    - 电阻面积 $A_{1}, A_{2} \\in \\{1000, 4000, 10000\\}\\,\\mu\\mathrm{m}^{2}$。\n    - 运放偏置电流 $I_{\\mathrm{bias}} \\in \\{20\\times 10^{-6}, 50\\times 10^{-6}, 100\\times 10^{-6}\\}\\,\\mathrm{A}$。\n    - 修调分数步长 $s = 0.003125$。\n    - 修调码边界 $c \\in \\{-16, -15, \\dots, +15\\}$。\n- 测试用例 2 (功耗受限):\n    - 电阻失配常数 $A_{R} = 0.001$。\n    - 运算放大器失调常数 $K_{\\mathrm{vos}} = 0.5\\times 10^{-3}\\,\\mathrm{V}\\cdot\\sqrt{\\mu\\mathrm{A}}$。\n    - 电阻面积 $A_{1}, A_{2} \\in \\{1000, 4000, 10000\\}\\,\\mu\\mathrm{m}^{2}$。\n    - 运放偏置电流 $I_{\\mathrm{bias}} \\in \\{5\\times 10^{-6}, 10\\times 10^{-6}, 20\\times 10^{-6}\\}\\,\\mathrm{A}$。\n    - 修调分数步长 $s = 0.003125$。\n    - 修调码边界 $c \\in \\{-16, -15, \\dots, +15\\}$。\n- 测试用例 3 (电阻匹配差，修调更精细):\n    - 电阻失配常数 $A_{R} = 0.003$。\n    - 运算放大器失调常数 $K_{\\mathrm{vos}} = 0.5\\times 10^{-3}\\,\\mathrm{V}\\cdot\\sqrt{\\mu\\mathrm{A}}$。\n    - 电阻面积 $A_{1}, A_{2} \\in \\{1000, 2000, 4000, 8000, 16000\\}\\,\\mu\\mathrm{m}^{2}$。\n    - 运放偏置电流 $I_{\\mathrm{bias}} \\in \\{20\\times 10^{-6}, 50\\times 10^{-6}, 100\\times 10^{-6}\\}\\,\\mathrm{A}$。\n    - 修调分数步长 $s = 0.002$。\n    - 修调码边界 $c \\in \\{-16, -15, \\dots, +15\\}$。\n\n您的程序必须为每个测试用例计算上述四个输出，然后生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素对应一个测试用例，并且本身是一个按指定顺序包含四个值的列表。具体来说，输出必须是以下形式\n$[\\,[e_{1},p_{1},a_{1},w_{1}],\\,[e_{2},p_{2},a_{2},w_{2}],\\,[e_{3},p_{3},a_{3},w_{3}]\\,]$,\n其中 $e_{i}$ 是最小最坏情况误差（单位 $\\mathrm{mV}$，四舍五入到三位小数），$p_{i}$ 是帕累托最优设计的数量（一个整数），$a_{i}$ 是最小帕累托面积（单位 $\\mu\\mathrm{m}^{2}$，四舍五入到一位小数），$w_{i}$ 是最小帕累托功耗（单位 $\\mu\\mathrm{W}$，四舍五入到三位小数）。不应打印任何额外文本。\n\n所有数值输出必须按规定四舍五入，物理单位必须符合上述要求。此问题不涉及角度。内部计算中出现的百分比（例如，修调分数步长）在计算中应保持为小数；仅打印指定的输出。",
            "solution": "该问题要求对带隙基准电压源（BGR）电路进行角点感知的多目标优化。目标是探索一个由电阻面积（$A_1$, $A_2$）和运算放大器（op-amp）偏置电流（$I_{\\mathrm{bias}}$）定义的离散设计空间，并找出一组非支配（帕累托最优）的设计。优化目标是最小化经过模拟修调过程后的最坏情况电压误差、总硅片面积以及总功耗。\n\n解决方案是通过将所提供的物理模型和评估标准进行算法形式化来开发的。该方法的核心是对设计空间进行系统性探索，其中每个候选设计都经过严格的最坏情况分析。\n\n**1. 基本BGR模型**\n\nBGR电压 $V_{\\mathrm{ref}}$ 是通过将一个互补于绝对温度（CTAT）的电压（由双极结型晶体管BJT的基极-发射极电压 $V_{BE}(T)$ 表示）和一个正比于绝对温度（PTAT）的电压相加而产生的。模型如下：\n$$\nV_{\\mathrm{ref}}(T) = V_{BE}(T) + r\\,\\Delta V_{\\mathrm{PTAT}}(T) + r\\,v_{\\mathrm{os}}\n$$\n在此， $V_{BE}(T)$ 通过围绕修调温度 $T_0$ 的一阶泰勒展开来近似：\n$$\nV_{BE}(T) = V_{BE}(T_{0}) + \\beta\\,(T - T_{0})\n$$\n其中 $\\beta$ 是温度系数。PTAT电压 $\\Delta V_{\\mathrm{PTAT}}(T)$ 由两个发射极面积比为 $N$ 的BJT的 $V_{BE}$ 差值产生：\n$$\n\\Delta V_{\\mathrm{PTAT}}(T) = V_t(T) \\, \\ln(N) = \\frac{k T}{q} \\ln(N)\n$$\n其中 $V_t(T)$ 是热电压， $k$ 是玻尔兹曼常数， $q$ 是元电荷。项 $v_{\\mathrm{os}}$ 代表运放的输入参考失调电压，它会引入一个系统误差。电阻比 $r = R_2/R_1$ 用于缩放PTAT分量。\n\n**2. 一阶温度补偿**\n\nBGR的原理是使 $V_{\\mathrm{ref}}$ 至少在一阶上与温度无关。这通过选择一个能够抵消温度依赖性的标称比率 $r_{\\mathrm{nom}}$ 来实现。将 $V_{\\mathrm{ref}}(T)$ 对 $T$ 求导（在此标称计算中忽略 $v_{\\mathrm{os}}$ 项）并令结果为零，得到：\n$$\n\\frac{d V_{\\mathrm{ref}}(T)}{dT} \\approx \\frac{d}{dT} \\left( V_{BE}(T_0) + \\beta(T-T_0) \\right) + r_{\\mathrm{nom}} \\frac{d}{dT} \\left( \\frac{kT}{q} \\ln(N) \\right) = \\beta + r_{\\mathrm{nom}} \\frac{k}{q} \\ln(N) = 0\n$$\n这给出了基于标称温度系数 $\\beta_{\\mathrm{nom}}$ 的标称比率公式：\n$$\nr_{\\mathrm{nom}} = -\\beta_{\\mathrm{nom}} \\frac{q}{k \\ln(N)}\n$$\n\n**3. 用于设计空间探索的算法设计**\n\n解决方案涉及一个嵌套循环算法，用于评估每个候选设计。一个设计由三元组 $(A_1, A_2, I_{\\mathrm{bias}})$ 唯一确定。\n\n**3.1. 设计成本指标**\n\n对于每个设计 $(A_1, A_2, I_{\\mathrm{bias}})$，我们首先计算其固有的成本指标：总面积和功耗。\n- **总面积 ($A_{\\mathrm{tot}}$)**: 这是电阻面积之和，是硅片占用的直接度量。\n$$A_{\\mathrm{tot}} = A_1 + A_2$$\n- **总功耗 ($P_{\\mathrm{tot}}$)**: 这是从电源 $V_{\\mathrm{DD}}$ 汲取的功率。它包括运放偏置电流和在参考温度 $T_0$ 下流过 $R_1$ 的PTAT电流。\n$$P_{\\mathrm{tot}} = V_{\\mathrm{DD}} \\left( I_{\\mathrm{bias}} + I_{\\mathrm{PTAT}}(T_0) \\right) = V_{\\mathrm{DD}} \\left( I_{\\mathrm{bias}} + \\frac{\\Delta V_{\\mathrm{PTAT}}(T_0)}{R_1} \\right)$$\n\n**3.2. 最坏情况误差评估**\n\n性能指标是最坏情况电压误差。这是评估中最复杂的部分，需要在所有指定的工艺角点、制造变化（失配和失调）以及整个温度范围内进行仿真。\n\n对于一个给定的设计 $(A_1, A_2, I_{\\mathrm{bias}})$，我们首先确定其对随机变化的敏感性：\n- **电阻比失配 ($\\sigma_r$)**: 使用Pelgrom定律，比率 $r=R_2/R_1$ 的标准差由失配常数 $A_R$ 以及电阻面积 $A_1$ 和 $A_2$ 决定。\n$$ \\sigma_r = A_R \\sqrt{\\frac{1}{A_1} + \\frac{1}{A_2}} $$\n- **运放失调失配 ($\\sigma_{v_{\\mathrm{os}}}$)**: 运放失调的标准差由工艺常数 $K_{\\mathrm{vos}}$ 和偏置电流 $I_{\\mathrm{bias}}$ （以 $\\mu\\mathrm{A}$ 为单位）决定。\n$$ \\sigma_{v_{\\mathrm{os}}} = \\frac{K_{\\mathrm{vos}}}{\\sqrt{I_{\\mathrm{bias}} / (1\\,\\mu\\mathrm{A})}} $$\n\n然后算法执行一次最坏情况扫描：\n一个外层循环遍历所有 $N_d$ 个设计。在循环内部，一个变量 `max_error_for_design` 被初始化为 $0$。一系列嵌套循环遍历所有 $N_c$ 个工艺角点（典型、快速、慢速）、 $N_\\epsilon=2$ 个失配极端情况（$\\varepsilon = \\pm 3 \\sigma_r$）和 $N_{vos}=2$ 个失调极端情况（$v_{\\mathrm{os}} = \\pm 3\\sigma_{v_{\\mathrm{os}}}$）。这为每个设计定义了总共 $N_c \\times N_\\epsilon \\times N_{vos}$ 个“场景”。\n\n对于每个场景：\n1.  **在 $T_0$ 模拟修调**: 制造完成、修调前的电阻比为 $r_{\\mathrm{pre}} = r_{\\mathrm{nom}}(1 + \\varepsilon)$。修调将此比率调整为 $r = r_{\\mathrm{pre}}(1+cs)$，其中 $c$ 是一个整数修调码，$s$ 是步长。最优修调码 $c_{\\mathrm{opt}}$ 是通过从其允许范围内选择整数 $c$ 来找到的，该整数 $c$ 使得在修调温度 $T_0$ 时的电压误差最小化：\n$$\nc_{\\mathrm{opt}} = \\underset{c \\in [c_{\\min}, c_{\\max}]}{\\operatorname{argmin}} \\left| V_{\\mathrm{ref}}(T_0, c) - V_{\\mathrm{ref,target}} \\right|\n$$\n其中 $V_{\\mathrm{ref}}(T_0, c) = V_{BE}(T_0) + r_{\\mathrm{pre}}(1+cs)(\\Delta V_{\\mathrm{PTAT}}(T_0) + v_{\\mathrm{os}})$。这一步通过穷举检查所有可能的整数值 $c$ 来实现。\n\n2.  **跨温度评估误差**: 对于当前场景，固定 $c_{\\mathrm{opt}}$ 后，最终的修调比率为 $r_{\\mathrm{final}} = r_{\\mathrm{pre}}(1+c_{\\mathrm{opt}}s)$。然后在每个评估温度 $T \\in \\{T_{\\min}, T_0, T_{\\max}\\}$ 下计算电压误差。\n$$\n\\text{error}(T) = \\left| V_{BE}(T) + r_{\\mathrminal}(\\Delta V_{\\mathrm{PTAT}}(T) + v_{\\mathrm{os}}) - V_{\\mathrm{ref,target}} \\right|\n$$\n这些误差中的最大值是此单个场景的最坏情况误差。`max_error_for_design` 会用所有场景中发现的最大误差进行更新。\n\n遍历所有场景后，`max_error_for_design` 持有该设计 $(A_1, A_2, I_{\\mathrm{bias}})$ 的最坏情况误差。三元组 $(\\text{最坏情况误差}, A_{\\mathrm{tot}}, P_{\\mathrm{tot}})$ 被存储起来。\n\n**3.3. 帕累托前沿识别**\n\n在评估了所有候选设计之后，我们进行帕累托分析。一个具有指标 $(e_A, a_A, p_A)$ 的设计 `A` 被称为支配一个具有指标 $(e_B, a_B, p_B)$ 的设计 `B`，如果它在任何目标上都不比 `B` 差，并且在至少一个目标上严格更优：\n$$\n(e_A \\le e_B) \\land (a_A \\le a_B) \\land (p_A \\le p_B) \\land ((e_A  e_B) \\lor (a_A  a_B) \\lor (p_A  p_B))\n$$\n帕累托最优集是所有不被集合中任何其他设计所支配的设计的集合。该算法通过对所有评估过的设计进行成对比较来识别这个集合。\n\n**4. 最终输出指标**\n\n最后，为每个测试用例计算所需的指标：\n1.  所有设计中的全局最小最坏情况误差。\n2.  帕累托最优集中的设计总数。\n3.  帕累托集中的设计中的最小总面积。\n4.  帕累托集中的设计中的最小总功耗。\n\n然后将这些值按要求格式化并呈现，为给定的设计空间提供一个简洁的权衡摘要。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    # Global constants and configuration\n    K_BOLTZMANN = 1.380649e-23  # J/K\n    Q_ECHARGE = 1.602176634e-19  # C\n    T0 = 298.15  # K\n    TEMPS = [233.15, 298.15, 398.15]  # K (T_min, T0, T_max)\n    N_RATIO = 8\n    LN_N = np.log(N_RATIO)\n    V_REF_TARGET = 1.21  # V\n    V_DD = 1.8  # V\n    R1_NOMINAL = 10e3  # Ohms\n    BETA_NOM = -1.8e-3  # V/K\n\n    # Derived constants\n    K_OVER_Q = K_BOLTZMANN / Q_ECHARGE\n    R_NOM = -BETA_NOM / (K_OVER_Q * LN_N)\n    DELTA_VPTAT_T0 = K_OVER_Q * T0 * LN_N\n    I_PTAT_T0 = DELTA_VPTAT_T0 / R1_NOMINAL\n\n    # Process-temperature corners\n    CORNERS = {\n        'typical': {'vbe_t0': 0.85, 'beta': -1.8e-3},\n        'fast': {'vbe_t0': 0.84, 'beta': -2.0e-3},\n        'slow': {'vbe_t0': 0.86, 'beta': -1.6e-3},\n    }\n\n    # Test suite definition\n    test_suite = [\n        {\n            'A_R': 0.001,\n            'K_vos': 0.5e-3,\n            'A_vals': [1000, 4000, 10000],\n            'Ibias_vals': [20e-6, 50e-6, 100e-6],\n            's_trim': 0.003125,\n            'c_range': range(-16, 16),\n        },\n        {\n            'A_R': 0.001,\n            'K_vos': 0.5e-3,\n            'A_vals': [1000, 4000, 10000],\n            'Ibias_vals': [5e-6, 10e-6, 20e-6],\n            's_trim': 0.003125,\n            'c_range': range(-16, 16),\n        },\n        {\n            'A_R': 0.003,\n            'K_vos': 0.5e-3,\n            'A_vals': [1000, 2000, 4000, 8000, 16000],\n            'Ibias_vals': [20e-6, 50e-6, 100e-6],\n            's_trim': 0.002,\n            'c_range': range(-16, 16),\n        }\n    ]\n\n    final_results = []\n\n    for case_params in test_suite:\n        A_R = case_params['A_R']\n        K_vos = case_params['K_vos']\n        A_vals = case_params['A_vals']\n        Ibias_vals = case_params['Ibias_vals']\n        s_trim = case_params['s_trim']\n        c_range = case_params['c_range']\n\n        design_space = list(itertools.product(A_vals, A_vals, Ibias_vals))\n        evaluated_designs = []\n\n        # Iterate through each candidate design\n        for A1, A2, Ibias in design_space:\n            # Calculate design-specific parameters (mismatch, offset, area, power)\n            sigma_r = A_R * np.sqrt(1/A1 + 1/A2)\n            sigma_vos = K_vos / np.sqrt(Ibias * 1e6)\n            \n            A_tot = float(A1 + A2)\n            P_tot = V_DD * (Ibias + I_PTAT_T0)\n            \n            max_error_for_design = 0.0\n\n            # Iterate through all worst-case scenarios (corners, mismatch, offset)\n            for corner in CORNERS.values():\n                vbe_t0_corner = corner['vbe_t0']\n                beta_corner = corner['beta']\n\n                for eps_sign in [-1, 1]:\n                    eps = eps_sign * 3 * sigma_r\n                    r_pre = R_NOM * (1 + eps)\n                    \n                    for vos_sign in [-1, 1]:\n                        vos = vos_sign * 3 * sigma_vos\n\n                        # Find optimal trim code c_opt at T0\n                        min_error_at_t0 = float('inf')\n                        c_opt = 0\n                        # Term for V_ref expression at T0\n                        ptat_plus_os_t0 = DELTA_VPTAT_T0 + vos\n                        \n                        for c in c_range:\n                            r_eff = r_pre * (1 + c * s_trim)\n                            vref_at_t0 = vbe_t0_corner + r_eff * ptat_plus_os_t0\n                            error_at_t0 = abs(vref_at_t0 - V_REF_TARGET)\n                            if error_at_t0  min_error_at_t0:\n                                min_error_at_t0 = error_at_t0\n                                c_opt = c\n\n                        r_final = r_pre * (1 + c_opt * s_trim)\n\n                        # Evaluate error across temperatures with the fixed optimal trim code\n                        for T in TEMPS:\n                            v_be = vbe_t0_corner + beta_corner * (T - T0)\n                            delta_v_ptat = K_OVER_Q * T * LN_N\n                            v_ref = v_be + r_final * (delta_v_ptat + vos)\n                            error = abs(v_ref - V_REF_TARGET)\n                            if error > max_error_for_design:\n                                max_error_for_design = error\n            \n            evaluated_designs.append({'error': max_error_for_design, 'area': A_tot, 'power': P_tot})\n\n        # Pareto Analysis\n        pareto_set = []\n        for i, design1 in enumerate(evaluated_designs):\n            is_dominated = False\n            for j, design2 in enumerate(evaluated_designs):\n                if i == j:\n                    continue\n                # Check if design2 dominates design1\n                if (design2['error'] = design1['error'] and\n                    design2['area'] = design1['area'] and\n                    design2['power'] = design1['power'] and\n                    (design2['error']  design1['error'] or\n                     design2['area']  design1['area'] or\n                     design2['power']  design1['power'])):\n                    is_dominated = True\n                    break\n            if not is_dominated:\n                pareto_set.append(design1)\n\n        # Calculate final metrics for the test case\n        min_worst_case_error = min(d['error'] for d in evaluated_designs)\n        num_pareto_designs = len(pareto_set)\n        \n        if not pareto_set: # Handle case of empty pareto set, although unlikely here\n            min_pareto_area = 0.0\n            min_pareto_power = 0.0\n        else:\n            min_pareto_area = min(d['area'] for d in pareto_set)\n            min_pareto_power = min(d['power'] for d in pareto_set)\n\n        # Format results as required\n        e_mV = round(min_worst_case_error * 1000, 3)\n        p_count = num_pareto_designs\n        a_um2 = round(min_pareto_area, 1)\n        w_uW = round(min_pareto_power * 1e6, 3)\n        \n        final_results.append([e_mV, p_count, a_um2, w_uW])\n\n    # Print the final output in the exact specified format\n    results_str_list = [f\"[{','.join(map(str, res))}]\" for res in final_results]\n    print(f\"[{','.join(results_str_list)}]\")\n\n\nsolve()\n```"
        }
    ]
}