## 引言
在现代超大规模[集成电路](@entry_id:265543)（VLSI）设计中，[布局规划](@entry_id:1125091)（Floorplanning）是决定芯片最终性能、功耗和成本的关键前端物理设计步骤。其核心挑战在于如何在庞大的可能性空间中，高效地表示和探索数百万个[功能模块](@entry_id:275097)的排列方案，以满足多重且相互冲突的设计目标。为了应对这一挑战，学术界和工业界发展出了一系列精巧的布局表示法，它们是所有现代电子设计自动化（EDA）工具的基石。这些方法主要分为两大类：切片式（slicing）和非切片式（non-slicing），各自拥有独特的优势和局限性。

本文将系统地引导读者深入理解[布局规划](@entry_id:1125091)表示法的世界。在**第一章：原理与机制**中，我们将从形式化定义出发，详细解析切片式布局的[波兰表达式](@entry_id:1129910)和非切片式布局的[序列对](@entry_id:1131501)、B*树等经典表示法的内在机理。接着，在**第二章：应用与跨学科连接**中，我们将探讨这些表示法如何在[多目标优化](@entry_id:637420)（如面积、线长、时序）的实际工程问题中发挥作用，并揭示其与[电路理论](@entry_id:189041)、图论等领域的深刻联系。最后，**第三章：动手实践**将通过具体的编程练习，帮助读者将理论知识转化为解决实际问题的能力。

## 原理与机制

在[集成电路物理设计](@entry_id:1126338)中，[布局规划](@entry_id:1125091)（Floorplanning）的核心任务是在一个给定的矩形区域内，对一组功能模块（modules）进行无重叠的排列，以优化面积、线长、时序和功耗等多个目标。本章将深入探讨布局规划的基本原理和机制，重点阐述用于描述和操作布局方案的各种表示方法。我们将从[布局规划](@entry_id:1125091)问题的形式化定义出发，区分两种主要的布局类别——切片式（slicing）与非切片式（non-slicing）布局，并详细介绍各自的经典表示方法及其内在机理。

### 布局规划问题的形式化定义

一个有效的[布局规划](@entry_id:1125091)方案必须满足两个基本几何约束：所有模块必须完全包含在指定的[边界框](@entry_id:635282)内，且任意两个模块的内部不能发生重叠。为了严谨地描述这一问题，我们可以将其表述为一组数学约束。

一个布局方案可以被视为一种**马赛克式布局（mosaic floorplan）**，即用一组矩形模块对一个给定的边界矩形进行无重叠、无空隙的精确划分。假设我们有 $n$ 个矩形模块，对于每个模块 $i \in \{1, \dots, n\}$，其左下角坐标为 $(x_i, y_i)$，宽度为 $w_i > 0$，高度为 $h_i > 0$。其占据的闭合区域为 $R_i = [x_i, x_i+w_i] \times [y_i, y_i+h_i]$，内部开放区域为 $R_i^\circ = (x_i, x_i+w_i) \times (y_i, y_i+h_i)$。设边界矩形为 $B = [0, W] \times [0, H]$。

一个有效的马赛克式布局必须满足以下两个条件：
1.  **无内部重叠**：对于任意两个不同的模块 $i$ 和 $j$（$i \neq j$），它们的内部区域互不相交，即 $R_i^\circ \cap R_j^\circ = \emptyset$。
2.  **完全覆盖**：所有模块的区域并集恰好等于边界矩形，即 $\bigcup_{i=1}^n R_i = B$。

无重叠条件可以形式化为一组析取不等式。对于任意一对模块 $i$ 和 $j$，它们不重叠意味着模块 $i$ 必须完全位于模块 $j$ 的左侧、右侧、下方或上方。这四种空间关系可以表示为：
$$(x_i + w_i \le x_j) \lor (x_j + w_j \le x_i) \lor (y_i + h_i \le y_j) \lor (y_j + h_j \le y_i)$$
这组析取约束必须对所有模块对 $\{i, j\}$ ($i \neq j$) 成立。在数学规划中，这类[逻辑约束](@entry_id:635151)通常通过引入辅助二元变量和“大M”方法（big-M method）进行线性化 。

完全覆盖条件则包含两个方面。首先，所有模块必须在[边界框](@entry_id:635282)内部，这可以通过以下不等式保证：
$$ \forall i \in \{1, \dots, n\}: \quad 0 \le x_i, \quad x_i+w_i \le W, \quad 0 \le y_i, \quad y_i+h_i \le H $$
其次，在满足无重叠和边界约束的前提下，要确保模块之间没有留下任何未被覆盖的空隙（即“死空间”），一个必要且充分的条件是所有模块的面[积之和](@entry_id:266697)等于边界矩形的面积 ：
$$ \sum_{i=1}^n w_i h_i = W H $$
这组约束完整地定义了布局规划问题的[可行解](@entry_id:634783)空间，适用于任何类型的布局结构，无论是切片式还是非切片式。

### 切片式布局及其表示

尽管上述形式化定义是完备的，但其析取性质使得直接求解非常困难。因此，研究人员提出了多种结构化的表示方法来简化和探索布局空间。其中最经典的一类是**切片式布局（slicing floorplan）**。

#### 切片式布局的定义

一个切片式布局是通过递归地使用**剖切（guillotine cuts）**来生成的。剖切是指用一条横贯当前矩形区域的水平或垂直直线，将其分割成两个更小的子矩形。如果一个布局可以通过一系列这样的剖切操作，从初始的边界矩形开始，递归地分割直到每个最小的子矩形恰好包含一个模块为止，那么这个布局就是切片式的。

然而，并非所有的马赛克式布局都是切片式的。存在一些**非切片式布局（non-slicing floorplan）**，它们的模块排列方式使得在任何递归层级都无法找到一条完整的剖切线。一个典型的例子是“风车”（pinwheel）结构，其中四个或更多模块环绕一个中心模块，任何试图贯穿整个区域的直线都必然会穿过某个模块的内部 。这一根本区别说明，切片式布局的集合只是所有马赛克式布局集合的一个**[真子集](@entry_id:152276)**。因此，任何只能表示切片式布局的方法，其**表达能力（expressiveness）** 都是有限的 。

#### 切片树表示

切片式布局的递归生成过程天然地对应于一种树形结构——**切片树（slicing tree）**。切片树是一个有序的满[二叉树](@entry_id:270401)，其：
- **[叶节点](@entry_id:266134)**：代表基本的[功能模块](@entry_id:275097)。
- **内部节点**：代表一次剖切操作，标记为 $H$（水平切割）或 $V$（垂直切割）。

在一个切片树中，如果一个内部节点标记为 $H$，其左右子树分别代表堆叠在上方和下方的子布局。如果标记为 $V$，则左右子树分别代表并排在左侧和右侧的子布局。

给定每个[叶节点](@entry_id:266134)（模块）的宽度和高度，整个布局的包围盒尺寸可以通过[后序遍历](@entry_id:273478)切片树来递归计算 ：
- 对于一个标记为 $V$ 的节点，其左右子布局分别为 $L$ 和 $R$。该节点代表的组合模块的宽度是 $W_L + W_R$（宽度相加），高度是 $\max(H_L, H_R)$（高度取最大值）。
- 对于一个标记为 $H$ 的节点，其组合模块的宽度是 $\max(W_L, W_R)$（宽度取最大值），高度是 $H_L + H_R$（高度相加）。

通过这种方式，从[叶节点](@entry_id:266134)的尺寸出发，可以自底向上计算出根节点所代表的整个布局的总宽度和总高度。

#### [波兰表达式](@entry_id:1129910)表示

为了在优化算法中更高效地操作切片树，通常会使用一种称为**[波兰表达式](@entry_id:1129910)（Polish expression）**的线性编码。一个切片树的[波兰表达式](@entry_id:1129910)是通过对其进行**[后序遍历](@entry_id:273478)**得到的字符串，其中[叶节点](@entry_id:266134)（模块）是操作数，内部节点（$H$ 或 $V$）是操作符。

例如，对于一个布局 $V(A, H(B, C))$，其[波兰表达式](@entry_id:1129910)为 $A B C H V$。这种编码方式非常紧凑，并且具有一个重要的结构特性，即**投票数属性（balloting property）**。一个包含 $n$ 个模块的有效[波兰表达式](@entry_id:1129910)必须满足以下必要且充分的条件 ：
1.  表达式的长度为 $2n-1$。
2.  包含 $n$ 个操作数（模块）和 $n-1$ 个操作符（$H$ 或 $V$）。
3.  对于任意长度为 $k$（$1 \le k \le 2n-1$）的前缀，操作数的数量必须**严格大于**操作符的数量。

这个属性确保了在基于栈的解码过程中，每当遇到一个操作符时，栈中总是有至少两个操作数可供其操作，从而保证表达式的合法性。

#### 表达的冗余性与规范化

[波兰表达式](@entry_id:1129910)虽然有效，但存在显著的**冗余性（redundancy）**，即多个不同的表达式可以表示同一个拓扑结构的布局。这种冗余主要来源于两个方面 ：
- **[结合律](@entry_id:151180)（Associativity）**：一系列连续的同类型切割（如两个连续的水平切割）在拓扑上是等价的，无论它们的组合顺序如何。例如，表达式 $A B H C H$ 和 $A B C H H$ 都表示将 $A, B, C$ 垂直堆叠，只是对应的切片树结构不同（分别为左偏树和[右偏](@entry_id:180351)树）。
- **[交换律](@entry_id:141214)（Commutativity）**：由于[镜像对称](@entry_id:158730)的布局被视为拓扑等价，因此操作符的两个操作数可以交换位置。例如，$A B H$ 和 $B A H$ 代表的布局互为镜像，拓扑上是相同的。

为了消除冗余、缩小[优化算法](@entry_id:147840)的搜索空间，可以对[波兰表达式](@entry_id:1129910)进行**规范化（normalization）**。一个常见的规范化方案包括 ：
1.  **禁止连续相同的操作符**：规定表达式中不允许出现 "HH" 或 "VV" 这样的子串。这强制为一连串同类切割选择一个唯一的、规范的树结构（例如，总是左偏树）。
2.  **对操作数排序**：在由相同操作符连接的模块块内，根据一个预定义的总序对操作数（模块）进行排序。这消除了因[交换律](@entry_id:141214)（镜像）产生的冗余。

通过这种规范化，每个唯一的切片拓扑结构都对应一个唯一的规范化[波兰表达式](@entry_id:1129910)，大大提高了表示的效率。

### 非切片式布局及其表示

切片式表示的局限性催生了更具表达能力的非切片式表示方法。这些方法的目标是能够覆盖所有马赛克式布局，包括那些无法用剖切方法生成的布局。

#### [序列对](@entry_id:1131501)（Sequence Pair）

**[序列对](@entry_id:1131501)（Sequence Pair, SP）**是一种强大且完备的非切片式布局表示方法，由 Murata 等人提出。它使用一对模块名称的排列组合 $(\pi_x, \pi_y)$ 来编码模块间的相对位置关系。

其解码规则非常简洁 ：对于任意两个模块 $i$ 和 $j$：
- 如果 $i$ 在 $\pi_x$ 和 $\pi_y$ 中都排在 $j$ 的前面，则模块 $i$ 位于模块 $j$ 的**左侧**。
- 如果 $i$ 在 $\pi_x$ 中排在 $j$ 的前面，但在 $\pi_y$ 中排在 $j$ 的后面，则模块 $i$ 位于模块 $j$ 的**下方**。

这组简单的规则为任意两个模块都确定了水平或垂直的相对位置约束。例如，对于[序列对](@entry_id:1131501) $\pi_x=(A,C,B,D)$ 和 $\pi_y=(C,A,D,B)$：
- 对 (A, B) 而言，$A$ 在两个序列中都先于 $B$，因此 $A$ 在 $B$ 的左侧。
- 对 (A, C) 而言，$A$ 在 $\pi_x$ 中先于 $C$，但在 $\pi_y$ 中后于 $C$，因此 $A$ 在 $C$ 的下方。

这些“左侧”和“下方”的约束可以被用来构建两个**[约束图](@entry_id:267131)（constraint graphs）**：一个水平[约束图](@entry_id:267131) $G_H$ 和一个[垂直约束图](@entry_id:1133785) $G_V$ 。
- 在 $G_H$ 中，每个模块是一个节点。如果 $i$ 在 $j$ 的左侧，则从节点 $i$ 到节点 $j$ 画一条有向边。
- 在 $G_V$ 中，同样每个模块是一个节点。如果 $i$ 在 $j$ 的下方，则从节点 $i$ 到节点 $j$ 画一条有向边。

这两个图都是有向无环图（DAG）。模块的坐标可以通过[计算图](@entry_id:636350)中的**最长路径**来确定。具体而言，模块 $i$ 的 $x$ 坐标 $x_i$ 等于 $G_H$ 中从源点到节点 $i$ 的最长路径长度，而 $y$ 坐标 $y_i$ 等于 $G_V$ 中从源点到节点 $i$ 的最长路径长度。路径的长度通常定义为路径上所有节点（或边）权重的总和，权重即模块的宽度（在 $G_H$ 中）或高度（在 $G_V$ 中）。最终，整个布局的总宽度 $W$ 就是 $G_H$ 中最长路径的长度，总高度 $H$ 就是 $G_V$ 中最长路径的长度  。

[序列对](@entry_id:1131501)表示法的一个重要理论性质是其**完备性（completeness）**：任何马赛克式布局（无论是切片式还是非切片式）都可以用至少一个[序列对](@entry_id:1131501)来表示 。同时，它也存在冗余。一个通用的布局拓扑结构，在不考虑退化情况时，对应着8个由于[几何对称性](@entry_id:189059)（[旋转和反射](@entry_id:136876)）而等价的[序列对](@entry_id:1131501)表示 。

#### B*树（B*-Tree）

**B*树**是另一种著名且高效的非切片式布局表示，由 Chang 等人提出。它将布局表示为一个有序的[二叉树](@entry_id:270401)，其中每个节点都代表一个模块。其空间位置的解释规则如下 ：
- 节点的**左孩子**代表的模块被放置在其**父节点**的**右侧**。
- 节点的**右孩子**代表的模块被放置在其**父节点**的**上方**。

与[序列对](@entry_id:1131501)通过[约束图](@entry_id:267131)进行全局计算不同，B*树的解码通常采用一种增量式的打包算法，该算法依赖于一个称为**轮廓线（skyline/contour）**的[数据结构](@entry_id:262134)。

轮廓线是一个分段[常数函数](@entry_id:152060) $Y(\xi)$，记录了当前已放置模块的上边界包络。当需要放置一个新模块时，算法会根据其在B*树中的父子关系确定一个试探性的 $x$ 坐标。然后，在轮廓线上查询该模块将要占据的 $x$ 坐标区间 $[x, x+w)$ 内的最高点。该模块的 $y$ 坐标就被设置为这个最高点的高度，以确保它恰好落在已放置模块的顶部而不发生重叠。放置完毕后，轮廓线在该区间内被更新为新模块的顶部高度 。

例如，给定根节点 $A$ 放置在 $(0,0)$，其左孩子 $B$ 的试探 $x$ 坐标为 $x_A+w_A$。算法会在轮廓线上查找区间 $[x_A+w_A, x_A+w_A+w_B)$ 的最大高度，并将 $B$ 放置在该高度上。而 $A$ 的右孩子 $C$ 的试探 $x$ 坐标为 $x_A$，算法则查找区间 $[x_A, x_A+w_C)$ 上的轮廓线高度来放置 $C$。

当使用[平衡二叉搜索树](@entry_id:636550)等高效[数据结构](@entry_id:262134)来维护轮廓线时，B*树的解码（打包）过程可以在 $O(n \log n)$ 的时间内完成，其中 $n$ 是模块数量。这种表示方法因其简洁的结构和高效的解码算法，在现代[布局规划](@entry_id:1125091)工具中得到了广泛应用。