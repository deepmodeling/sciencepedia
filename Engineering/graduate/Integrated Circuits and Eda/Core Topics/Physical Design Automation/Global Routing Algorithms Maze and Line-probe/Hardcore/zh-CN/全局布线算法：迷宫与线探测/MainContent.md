## 引言
在现代集成电路（IC）设计中，全局布线是连接数百万[逻辑门](@entry_id:178011)的关键物理设计步骤，直接决定了芯片的性能、功耗和面积。随着工艺节点的不断缩小，布线资源的日益紧张使得在满足时序要求的同时避免拥塞成为一项巨大的挑战。本文旨在系统性地阐述解决这一核心问题的经典算法，即迷宫布[线与](@entry_id:177118)线探测算法。

我们将分为三个章节，引导读者从理论基础走向实际应用。在“原理与机制”一章中，我们将首先建立全局布线的数学模型，然后深入剖析迷宫布线和线探测算法的工作原理、理论保证和性能特点。接下来，在“应用与跨学科连接”一章中，我们将探讨这些基础算法如何被整合到复杂的现代EDA系统中，以应对时序、拥塞和多层布线等实际约束，并揭示其与优化理论、并行计算等领域的联系。最后，在“动手实践”部分，读者将通过一系列精心设计的问题，将理论知识应用于具体的布线场景中。通过本文的学习，您将对全局布线的核心技术及其在复杂系统中的应用有一个全面而深入的理解。

## 原理与机制

在“引言”章节中，我们概述了全局布线在[集成电路物理设计](@entry_id:1126338)流程中的关键作用。本章将深入探讨全局布线背后的核心原理与算法机制。我们将首先形式化地定义全局布线问题，将其从物理现实抽象为图论模型。随后，我们将详细剖析两种经典的[全局布线算法](@entry_id:1125679)族——迷宫布线（Maze Routing）和线探测（Line-probe）算法——的工作原理、性能特点与理论保证。最后，我们将讨论处理多端点网络和管理布线拥塞等高级主题，这些是现代全局布线器必须面对的实际挑战。

### 全球布线问题的形式化

全局布线的核心任务是在一个抽象的层面上为芯片上成千上万个[信号网络](@entry_id:754820)规划路径，其主要目标是在满足物理约束的同时，[平衡路径](@entry_id:749059)长度（时延）和资源使用（拥塞）。为了实现这一目标，我们需要将连续的芯片版图转化为一个离散的数学模型。

#### 从物理版图到[网格图](@entry_id:261673)

在电子设计自动化（EDA）中，芯片的布线区域被划分为一个由许多矩形单元组成的网格，这些单元被称为**全局单元（Global Cells, GCells）**。这个网格结构可以被自然地建模为一个**[网格图](@entry_id:261673)（Grid Graph）** $G=(V, E)$。图中的每个顶点 $v \in V$ 对应一个 GCell，而每条边 $e \in E$ 代表两个相邻 GCell 之间的边界，即一个**布线通道（Routing Channel）**。

全局布线中的一个关键参数是每条边 $e$ 的**容量（capacity）**，记为 $c(e)$。这个整数值抽象地表示了穿过相应 GCell 边界的所有金属层上可用的布线轨道总数。一个[信号网络](@entry_id:754820)（net） $N_k$ 由一组需要电气连接的端点（terminals）$T_k$ 组成，这些端点通常是标准单元或宏单元的引脚（pins），它们被映射到其所在的 GCell 顶点上。全局布线的解是为每个网络 $N_k$ 在图 $G$ 上找到一个连接其所有端点 $T_k$ 的树形结构。

全局布线的目标可以形式化为一个[组合优化](@entry_id:264983)问题。设 $u(e)$ 为通过边 $e$ 的网络总数，称为边的**需求（demand）**或用量。首要的可行性要求是，任何边的需求都不能超过其容量，即对所有 $e \in E$ 满足 $u(e) \le c(e)$。当无法找到完全满足容量约束的解时，目标转为最小化**总[溢出](@entry_id:172355)（total overflow）**，其定义为 $\sum_{e \in E} \max\{0, u(e) - c(e)\}$。在满足拥塞目标之后，次要目标通常包括最小化总线长和过孔（via）数量。这个问题可以被表述为一个整数多商品流（Integer Multi-Commodity Flow, MCF）问题，其中每个网络是一个“商品”，并附加了树形连接的约束。

必须明确区分**全局布线**和**详细布线（detailed routing）**。全局布线的输出是为每个网络提供的一组“布线指南（routing guides）”，即一系列 GCell 或网格边的序列，它只在粗粒度上处理拥塞。而详细布线则依据这些指南，在精确的物理版图上为每个网络分配具体的金属轨道和过孔，生成符合所有[设计规则检查](@entry_id:1123588)（Design Rule Check, DRC）——如最小线宽、间距等——的可制造版图。

#### 边容量与布线几何的物理基础

[网格图](@entry_id:261673)中的边容量 $c(e)$ 并非一个随意的数字，它源于底层金属层的物理特性和[设计规则](@entry_id:1123586)。考虑一个长度为 $L_e$ 的 GCell 边界，其容量由能够跨越该边界的布线层共同贡献。

首先，金属层通常有**首选布线方向（preferred direction）**（例如，M1层为水平方向，M2层为垂直方向），以提高布线性并减少过孔。对于一个水平方向的 GCell 边界，其容量主要由水平首选方向的金属层贡献。

对于某个贡献层 $\ell$，其上可容纳的布线轨道数由**轨道间距（track pitch）** $p_\ell$ 决定，该间距由最小导[线宽](@entry_id:199028)度和最小间距规则定义。理论上，总轨道数为 $\lfloor L_e / p_\ell \rfloor$。然而，实际可用轨道数会因以下因素而减少：
1.  **布线阻塞（Blockages）**: 局部区域可能存在宏单元或IP核，导致可用布线长度减少。这通常通过一个可用比例因子 $\alpha_e$ 来建模。
2.  **预留轨道（Reserved Tracks）**: 一部分轨道可能被预留给电源/地网络（PG nets）或[时钟网络](@entry_id:1122493)，不能用于信号布线。
3.  **布线利用率（Utilization Factor）**: 一个全局性的利用率因子 $\eta_e$ 会被引入，以考虑因过孔区域、规则复杂性等因素造成的资源损失。

综合这些因素，一条水平边界 $e$ 的总容量 $c(e)$ 是所有水平首选方向布线层 $\ell$ 的可用信号轨道数之和。例如，对于给定的几何长度 $L_e = 100 \mu\mathrm{m}$，可用比例 $\alpha_e = 0.9$，利用率 $\eta_e = 0.95$，以及两个水平层 $\ell_1, \ell_2$，其轨道间距分别为 $p_{\ell_1} = 0.8 \mu\mathrm{m}, p_{\ell_2} = 1.0 \mu\mathrm{m}$，预留轨道数分别为 $r_{\ell_1} = 4, r_{\ell_2} = 2$，则总容量的计算方式如下：
$$ c(e) = \sum_{\ell \in \{\ell_1, \ell_2\}} \left\lfloor \eta_e \cdot \left( \left\lfloor \alpha_e \frac{L_e}{p_\ell} \right\rfloor - r_\ell \right) \right\rfloor $$
代入数值，层 $\ell_1$ 的贡献为 $\lfloor 0.95 \cdot (\lfloor 0.9 \cdot 100 / 0.8 \rfloor - 4) \rfloor = \lfloor 0.95 \cdot (112 - 4) \rfloor = 102$。层 $\ell_2$ 的贡献为 $\lfloor 0.95 \cdot (\lfloor 0.9 \cdot 100 / 1.0 \rfloor - 2) \rfloor = \lfloor 0.95 \cdot (90 - 2) \rfloor = 83$。因此，总容量 $c(e) = 102 + 83 = 185$。这个值将作为后续布线算法的输入。

此外，布线路径的几何形状也至关重要。由于现代工艺中导线通常沿着正交的水平和垂直方向（即**曼哈顿结构**），从一个点 $p=(x_p, y_p)$ 到另一个点 $q=(x_q, y_q)$ 的任何纯直线段路径的长度，在没有障碍物的情况下，都等于它们的**[曼哈顿距离](@entry_id:141126)（Manhattan distance）**，也称为 $L_1$ 距离：
$$ d_1(p,q) = |x_p-x_q| + |y_p-y_q| $$
这是因为任何矩形路径都必须独立地覆盖水平和垂直方向上的位移。因此，$d_1$ 成为[矩形布线](@entry_id:1130733)中的自然度量。在更复杂的模型中，如果不同方向或不同层上的单位长度成本不同（例如，水平步长成本为 $p_x$，垂直步长成本为 $p_y$），则该度量推广为加权 $L_1$ 度量 $p_x|x_p-x_q| + p_y|y_p-y_q|$。这个度量是A*等[启发式搜索](@entry_id:637758)算法中估算剩余路径成本的基础。

### 迷宫布线算法

迷宫布线算法是一类通过在[网格图](@entry_id:261673)上系统性地扩展搜索“波前”来寻找路径的算法。它们以其概念简单和能保证找到解（如果存在）而著称。

#### 基本的[Lee算法](@entry_id:1127152)：[广度优先搜索](@entry_id:156630)

最基础的迷宫布线算法是**[Lee算法](@entry_id:1127152)**，由C. Y. Lee于1961年提出。在成本统一的[网格图](@entry_id:261673)上（即每一步移动的成本都为1），[Lee算法](@entry_id:1127152)本质上是一个**[广度优先搜索](@entry_id:156630)（Breadth-First Search, BFS）**。

算法从源点 $S$ 开始，使用一个先进先出（FIFO）队列来管理搜索的前沿。
1.  **初始化**：将源点 $S$ 放入队列，并标记为已访问。
2.  **扩展**：从队列中取出一个顶点 $u$，检查其所有未被访问且可通行的邻居。
3.  **入队**：将这些邻居标记为已访问，记录 $u$ 为它们的前驱节点，并将它们加入队列。
4.  **终止**：重复此过程，直到目标点 $T$ 被访问到，或者队列变空。
5.  **回溯**：如果找到了 $T$，则通过前驱节点指针从 $T$ 回溯到 $S$，构造出一条路径。

[Lee算法](@entry_id:1127152)具有两个重要的理论性质：
*   **完备性（Completeness）**：只要在可通行的网格中存在一条从 $S$ 到 $T$ 的路径，[Lee算法](@entry_id:1127152)保证能够找到它。障碍物仅定义了图的拓扑结构，并不会破坏算法的完备性。
*   **最优性（Optimality）**：在单位成本的网格上，[Lee算法](@entry_id:1127152)找到的路径是**最短路径**，即包含最少步数（或网格边）的路径。这是因为BFS按离源点的距离逐层扩展，确保第一次到达目标点时所经过的层数（即路径长度）是最小的。

这种逐层扩展的行为就像水波一样，从源点向四周扩散，因此[Lee算法](@entry_id:1127152)也被称为波前扩展算法。

#### 加权网格上的推广：[Dijkstra算法](@entry_id:273943)

在实际的全局布线中，边的成本很少是统一的。如前所述，成本可能依赖于线长、过孔惩罚、层优选方向以及拥塞状况。为了处理这种**加权[网格图](@entry_id:261673)**，我们需要对[Lee算法](@entry_id:1127152)进行推广。

这种推广自然地导向了**[Dijkstra算法](@entry_id:273943)**。其核心思想是将[Lee算法](@entry_id:1127152)中使用的FIFO队列替换为一个**[最小优先队列](@entry_id:636722)（Min-Priority Queue）**。队列中的每个元素不仅包含顶点信息，还包含从源点 $S$ 到该顶点的当前已知最短路径成本。算法总是从[优先队列](@entry_id:263183)中取出具有最小成本的顶点进行扩展。

这个经过修改的“加权迷宫布线”算法（即[Dijkstra算法](@entry_id:273943)）的步骤如下：
1.  **初始化**：将所有顶点的成本设为无穷大，源点 $S$ 的成本设为0。将 $(0, S)$ 放入[优先队列](@entry_id:263183)。
2.  **选择**：从[优先队列](@entry_id:263183)中提取成本最小的顶点 $u$。一旦一个顶点被提取，其到源点的[最短路径](@entry_id:157568)成本就被“确定（set）”了。
3.  **松弛（Relaxation）**：对于 $u$ 的每个邻居 $v$，如果通过 $u$ 到达 $v$ 的路径成本（即 $u$ 的成本加上边 $(u,v)$ 的权重）小于 $v$ 当前的已知成本，则更新 $v$ 的成本，记录 $u$ 为 $v$ 的前驱，并将 `(新成本, v)` 放入（或更新）[优先队列](@entry_id:263183)。
4.  **终止与回溯**：重复此过程，直到目标点 $T$ 被从[优先队列](@entry_id:263183)中提取出来，或者队列变空。然后通过回溯前驱节点找到最短路径。

[Dijkstra算法](@entry_id:273943)保证在所有边权重为非负的情况下，能够找到从源点到所有其他顶点的[最小成本路径](@entry_id:187582)。这一性质对于布线问题至关重要，因为成本通常代表物理量（如长度或延时），总是非负的。

从计算复杂度的角度看，使用基于**[二叉堆](@entry_id:636601)（binary heap）**的[优先队列](@entry_id:263183)，[Dijkstra算法](@entry_id:273943)的运行时间为 $O(|E|\log|V|)$。对于稀疏的[网格图](@entry_id:261673)（其中 $|E| = \Theta(|V|)$），这通常简化为 $O(|V|\log|V|)$。相比之下，如果使用简单的未排[序数](@entry_id:150084)组来查找最小成本顶点，复杂度将是 $O(|V|^2)$，这对于大型网格来说效率低下。因此，[优先队列](@entry_id:263183)的使用在计算上是合理且必要的。

#### 示例：在双层网格上执行[Dijkstra算法](@entry_id:273943)

为了具体说明加权迷宫布线的工作方式，我们来看一个实例。考虑一个 $4 \times 4$ 的双层[网格图](@entry_id:261673)，源点 $S=(0,0,L_1)$，目标点 $T=(3,3,L_1)$。层 $L_1$ 优选水平方向（水平移动成本 $h_1=1$，垂直成本 $v_1=2$），层 $L_2$ 优选垂直方向（$h_2=2, v_2=1$）。层间过孔成本为 $x=2$。图中还存在一些层特定的障碍物。

[Dijkstra算法](@entry_id:273943)的波前扩展过程如下（仅展示关键步骤）：
1.  **提取 $(0, (0,0,L_1))$**: 成本为0。松弛邻居，将 $(2, (0,1,L_1))$ 和 $(2, (0,0,L_2))$ 加入[优先队列](@entry_id:263183)。
2.  **提取 $(2, (0,0,L_2))$**: 成本为2。松弛邻居，更新 $(1,0,L_2)$ 的成本为 $2+h_2=4$，并将 $(3, (0,1,L_2))$ 加入队列。
3.  **提取 $(2, (0,1,L_1))$**: 成本为2。松弛邻居，更新 $(1,1,L_1)$ 成本为 $2+h_1=3$。
...（算法继续扩展成本最低的节点）...
14. **提取 $(7, (3,1,L_1))$**: 成本为7。松弛邻居 $(3,2,L_1)$，更新其成本为 $7+v_1=9$。
17. **提取 $(8, (3,2,L_1))$**: 成本为8。松弛邻居 $(3,3,L_1)$（即目标 $T$），更新其成本为 $8+v_1=10$。
最终，当 $T=(3,3,L_1)$ 以成本9被从[优先队列](@entry_id:263183)中提取时，[算法终止](@entry_id:143996)。

通过回溯前驱节点，我们可以重建出一条[最短路径](@entry_id:157568)：
$S=(0,0,L_1) \to (1,0,L_1) \to (2,0,L_1) \to (3,0,L_1) \to (3,1,L_1) \to (3,2,L_1) \to (3,3,L_1)$
这条路径完全在 $L_1$ 层上，它首先水平移动，然后垂直移动以到达目标。其总成本为 $h_1+h_1+h_1+v_1+v_1+v_1 = 1+1+1+2+2+2=9$，这与算法找到的最小成本一致。这个例子清晰地展示了算法如何在考虑不同层成本和障碍物的情况下找到最优解。

### 线探测算法

尽管迷宫布线算法具有完备性和最优性的保证，但其“盲目”的波前扩展在实践中可能非常耗时，因为它会探索大量远离最终路径的区域。为了提高效率，**线探测（Line-probe）算法**被提出，它是一种启发式方法，旨在更直接地朝目标前进。

#### Hadlock算法：最小化绕路

一个经典且保证最优的线探测算法是**Hadlock算法**。它也是一种最佳优先搜索，但其成本函数设计得非常巧妙，旨在最小化路径的“绕路程度”。

Hadlock算法的核心概念是**绕路数（detour number）**，记为 $k$。对于从源点 $S$ 到目标点 $T$ 的路径上的任意一点 $p$，如果从 $p$ 移动到相邻点 $p'$ 导致其到 $T$ 的[曼哈顿距离](@entry_id:141126)增加，那么这一步就被视为一次“绕路”。一个路径的绕路数 $k$ 就是该路径上所有“绕路”步数的总和。可以证明，任何从 $S$ 到 $T$ 的路径的总长度 $L$ 与其绕路数 $k$ 之间的关系为：
$$ L = d_1(S, T) + 2k $$
其中 $d_1(S,T)$ 是 $S$ 和 $T$ 之间的[曼哈顿距离](@entry_id:141126)。这个公式的直观解释是，每一次“绕路”（远离目标）都必须由额外的一次“朝向目标”的移动来补偿，因此路径长度比最短的[曼哈顿距离](@entry_id:141126)多了 $2k$ 步。最小化路径长度等价于最小化绕路数 $k$。

Hadlock算法正是基于这一原理，通过对绕路数 $k$ 进行[广度优先搜索](@entry_id:156630)来工作的：
1.  **k=0 搜索**: 算法首先尝试寻找一条 $k=0$ 的路径。这意味着从 $S$ 出发，只允许进行“朝向”目标的移动（即减少到 $T$ 的[曼哈顿距离](@entry_id:141126)的移动）。这种搜索通常以“线探测”的形式进行，即沿着一个方向直线前进，直到碰到障碍物或已访问过的区域。
2.  **k=1 搜索**: 如果在 $k=0$ 的搜索中没有找到目标，算法就开始寻找 $k=1$ 的路径。它会从所有 $k=0$ 搜索所能到达的节点出发，进行一次“绕路”移动，到达新的节点。这些新节点构成了 $k=1$ 搜索的起点。
3.  **迭代**: 从这些 $k=1$ 的新起点开始，算法再次只进行“朝向”目标的线探测移动（以保持 $k$ 不再增加）。
这个过程不断重复，系统性地探索 $k=0, 1, 2, \dots$ 的所有可能性。由于它总是先穷尽所有具有较小 $k$ 值的路径，因此当它第一次找到目标点 $T$ 时，所找到的路径必然具有最小的绕路数，从而也是最短的路径。

例如，考虑源点 $S=(0,0)$，目标点 $T=(4,0)$，而在 $(1,0), (2,0), (3,0)$ 处有障碍物。一条 $k=0$ 的路径必须始终向东移动，但这条直线路径被障碍物阻挡了。因此，不存在 $k=0$ 的解。算法接下来会尝试 $k=1$ 的路径，例如从 $S$ 先向上移动到 $(0,1)$（这是一次绕路，因为到 $T$ 的[曼哈顿距离](@entry_id:141126)从4增加到5），然后从 $(0,1)$ 开始，一路向东探测到 $(4,1)$，最后向下移动到 $T=(4,0)$。这条路径的绕路数为1，是该问题中的最优解。

#### 性能比较：迷宫布线 vs. 线探测

线探测算法的主要优势在于其搜索的**方向性**。在障碍物稀疏的环境中，其性能远超迷宫布线。
*   **[Lee算法](@entry_id:1127152)**的波前是各向同性的，为了连接相距[曼哈顿距离](@entry_id:141126)为 $D$ 的两点，它通常需要探索一个菱形区域，访问的节点数约为 $\Theta(D^2)$。
*   **线探测算法**（如Hadlock或A*）由于其[启发式](@entry_id:261307)引导，搜索范围被限制在连接源和目标的一条狭窄“走廊”内。它会沿着直线探测，只有在遇到障碍时才进行局部绕行。因此，它访问的节点数通常与路径长度成正比，即 $O(D)$。

当 $D$ 较大时，$O(D)$ 远小于 $\Theta(D^2)$，这意味着线探测算法在典型场景下要快得多。然而，线探测算法的**最坏情况[时间复杂度](@entry_id:145062)**通常更高。基于[优先队列](@entry_id:263183)的实现（如Hadlock或A*）在最坏情况下（例如，迷宫般的障碍物布局迫使算法探索大部分区域）的[时间复杂度](@entry_id:145062)为 $O(|V|\log|V|)$，而基本[Lee算法](@entry_id:1127152)为 $O(|V|)$。这种在典型性能和[最坏情况复杂度](@entry_id:270834)之间的权衡是[算法设计](@entry_id:634229)中的常见主题。

### 多端点网络与拥塞管理

前面的讨论主要集中于连接两个端点的网络。然而，实际电路中许多网络是**多端点网络（multi-pin nets）**。同时，全局布线的最终目标是在满足所有网络连接需求的同时，避免布线资源过度使用，即有效管理**拥塞（congestion）**。

#### 多端点网络的布线：斯坦纳树问题

对于一个包含多个端点的网络，最短的连接方式不再是一条简单的路径，而是一棵**树**。在[矩形布线](@entry_id:1130733)几何下，理想的连接是一棵**[矩形斯坦纳最小树](@entry_id:1130734)（Rectilinear Steiner Minimum Tree, RSMT）**。RSMT是一棵由水平和[垂直线](@entry_id:174147)段组成的树，它连接了网络的所有端点，并具有最小的总长度。为了实现最小长度，RSMT可以引入不在原始端点集合中的新顶点，这些顶点被称为**斯坦纳点（Steiner points）**。

RSMT不同于一个更简单的结构——**[最小生成树](@entry_id:264423)（Minimum Spanning Tree, MST）**。MST只在原始端点之间建立连接，不允许引入新的斯坦纳点。由于RSMT的搜索空间（允许任意斯坦纳点）比MST更大，因此RSMT的长度总是小于或等于相应MST的长度：
$$ \text{Length}(\text{RSMT}) \le \text{Length}(\text{MST}) $$
一个重要的理论结果是**[Hanan网格](@entry_id:1125900)定理**，它指出对于任何给定的端点集，总存在一个RSMT，其所有的斯坦纳点都位于由所有端点的水平和垂直线构成的网格（即[Hanan网格](@entry_id:1125900)）的交点上。这极大地缩小了寻找最优斯坦纳点的搜索空间。

然而，寻找一个精确的RSMT是一个**N[P-难](@entry_id:265298)问题**。对于需要处理数百万个网络的现代EDA工具来说，为每个多端点网络计算精确的RSMT在计算上是不可行的。因此，实际的全局布线器通常采用高效的**[启发式算法](@entry_id:176797)**来近似RSMT，例如，先计算一个MST，然后将其分解为一系列两端点连接，再用迷宫或线探测算法依次进行布线。

#### 拥塞驱动的迭代布线

全局布线的核心挑战是同时为所有网络规划路径，以避免在某些区域产生超出资源容量的拥塞。一种强大而广泛使用的方法是**迭代式布线（iterative routing）**，也称为“rip-up and reroute”。

在这种框架下，布线过程分为多轮。在每一轮中，一个或多个网络（通常是那些导致[溢出](@entry_id:172355)的网络）被“拆除（rip-up）”，然后在一个更新了成本的网格上重新布线（reroute）。成本的更新是关键所在。边的成本不再是固定的，而是动态变化的，以反映当前的拥塞状况。

这个过程可以通过一个统一的**成本函数**来形式化，该函数结合了总线长和总[溢出](@entry_id:172355)两个目标。一个常见的形式是加权和：
$$ J_{\lambda} = \sum_{e \in E} w(e) d(e) + \lambda \sum_{e \in E} \max\{0, d(e) - c(e)\} $$
其中，$w(e)$是边的基本成本（如长度），$d(e)$是当前的需求，$\lambda$是一个非负的**权衡参数**。

*   当 $\lambda$ 很小时，优化目标接近于最小化总线长。
*   当 $\lambda$ 很大时，任何[溢出](@entry_id:172355)都会导致巨大的惩罚，因此优化目标的首要任务是消除溢出。

这个全局成本函数巧妙地转化为每次布线子问题（例如，用[Dijkstra算法](@entry_id:273943)为一个网络寻找路径）中的**动态边成本**。在第 $t$ 次迭代中，为网络增加一个单位需求到边 $e$ 上的边际成本可以近似为：
$$ \text{cost}_t(e) = w(e) + \lambda \cdot f(d^{(t-1)}(e), c(e)) $$
其中 $f$ 是一个与拥塞相关的惩[罚函数](@entry_id:638029)。一个简单的例子是，当边的需求 $d^{(t-1)}(e)$ 超过其容量 $c(e)$ 时，惩[罚函数](@entry_id:638029)取值为1，否则为0。更平滑的惩[罚函数](@entry_id:638029)（例如，随需求接近容量而逐渐增加）在实践中也常被使用。

通过这种方式，迷宫布[线或](@entry_id:170208)线探测算法在选择路径时，会自动避开那些已经拥塞或接近饱和的区域，因为这些区域的边成本被人为地提高了。经过多轮迭代，整个布线方案会趋向于一个拥塞分布更均匀、总成本更低的解。这种拥塞驱动的迭代策略是现代高性能全局布线器的基石。