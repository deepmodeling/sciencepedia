{
    "hands_on_practices": [
        {
            "introduction": "在电子设计自动化（EDA）中，Elmore 延迟是估算互连线延迟最常用和最基础的度量之一。这项练习旨在通过严格的数学推导，揭示 Elmore 延迟与均匀分布 RC 线路精确物理模型之间的深刻联系，帮助你理解为何这个看似简单的近似在实际中如此有效。通过完成这项实践，你将从第一性原理出发，验证对于均匀 RC 线，Elmore 延迟并非近似，而是其脉冲响应的一阶矩的精确值 。",
            "id": "4308257",
            "problem": "在集成电路设计中，电子设计自动化（EDA）通常将长的片上互连建模为一维阻容（RC）分布式线路。考虑一个长度为 $\\ell$ 的均匀RC线路，其单位长度电阻为 $r$，单位长度对地电容为 $c$，且电感可忽略不计。该线路在 $x=0$ 处由一个理想的零电阻源驱动，该源在 $t=0$ 时施加一个单位阶跃电压。可观察的输出节点位于远端 $x=\\ell$ 处。假设远端未端接，因此在 $x=\\ell$ 处没有电流流出。\n\n仅从专用于零电感情况的电报方程以及阶跃响应、冲激响应和一阶矩的定义出发，执行以下操作：\n\n1. 将线路视为一个连续RC树，并计算与远端节点相关的Elmore延迟。其定义为通过对整个连续体上每个电容元件的上游电阻乘以该电容元件的值进行求和（积分）而获得的冲激响应的一阶矩。\n2. 使用分布式公式，推导从 $x=0$ 处的输入电压到 $x=\\ell$ 处的输出电压的精确传递函数，并由此通过拉普拉斯变换使用矩的定义计算远端冲激响应的精确一阶矩。\n3. 比较这两个结果。\n\n作为最终答案，报告精确一阶矩与Elmore延迟的无量纲比率。无需四舍五入，最终比率中不应包含单位。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、内容自洽且提法明确的。所有提供的数据和条件均符合电路理论和分布参数系统分析的既定原则。该问题是关于片上互连建模的一个标准的、非平凡的练习。因此，我们可以着手求解。\n\n问题需要分三部分进行分析：首先，计算均匀分布式RC线路的Elmore延迟；其次，从线路的传递函数推导冲激响应的精确一阶矩；第三，比较这两个量。\n\n**1. Elmore延迟计算**\n\nElmore延迟是RC树中传播延迟的一阶近似。对于特定节点 $i$，它定义为从源到任何其他节点 $k$ 的每个路径段的电阻之和，由节点 $k$ 处的电容加权，其中该路径段也是从源到节点 $i$ 的路径的一部分。其公式为 $T_{D,i} = \\sum_k R_{ik} C_k$。\n\n对于长度为 $\\ell$ 的连续、均匀分布式RC线路，此求和变为积分。输出节点位于 $x=\\ell$ 处。我们考虑距离源（其中 $0 \\le x \\le \\ell$）位置 $x$ 处长度为 $dx$ 的无穷小线路段。\n这个无穷小段的电容是 $dC = c \\, dx$，其中 $c$是单位长度电容。\n从源（在 $x=0$ 处）到远端（在 $x=\\ell$ 处）的路径中，与到位置 $x$ 处线段的路径所共享的电阻，就是从源到位置 $x$ 的电阻。我们记这个电阻为 $R(x)$，由 $R(x) = r x$ 给出，其中 $r$ 是单位长度电阻。\n\n根据定义，远端的Elmore延迟（我们记为 $T_{\\text{Elmore}}$）是通过将路径电阻 $R(x)$ 和无穷小电容 $dC$ 的乘积在线路的整个长度上积分得到的：\n$$T_{\\text{Elmore}} = \\int_{0}^{\\ell} R(x) \\, dC(x) = \\int_{0}^{\\ell} (rx)(c \\, dx)$$\n我们可以将常数 $r$ 和 $c$ 提出来：\n$$T_{\\text{Elmore}} = rc \\int_{0}^{\\ell} x \\, dx$$\n执行积分得到：\n$$T_{\\text{Elmore}} = rc \\left[ \\frac{x^2}{2} \\right]_{0}^{\\ell} = rc \\left( \\frac{\\ell^2}{2} - 0 \\right)$$\n因此，远端节点的Elmore延迟为：\n$$T_{\\text{Elmore}} = \\frac{rc\\ell^2}{2}$$\n\n**2. 从传递函数计算精确一阶矩**\n\n为了找到冲激响应的精确一阶矩，我们必须首先推导分布式RC线路的传递函数 $H(s)$。我们从拉普拉斯域中的电报方程开始，该线路的电感 ($L=0$) 和对地电导 ($G=0$) 均可忽略不计。设 $V(x,s)$ 和 $I(x,s)$ 分别是位置 $x$ 处电压和电流的拉普拉斯变换。\n方程为：\n$$\\frac{dV(x,s)}{dx} = -rI(x,s)$$\n$$\\frac{dI(x,s)}{dx} = -scV(x,s)$$\n将第一个方程对 $x$ 求导，并代入第二个方程，得到关于 $V(x,s)$ 的二阶常微分方程：\n$$\\frac{d^2V(x,s)}{dx^2} = -r\\frac{dI(x,s)}{dx} = -r(-scV(x,s)) = (src)V(x,s)$$\n让我们定义传播常数 $\\gamma(s) = \\sqrt{src}$。方程变为：\n$$\\frac{d^2V(x,s)}{dx^2} - \\gamma^2(s)V(x,s) = 0$$\n该方程的通解为：\n$$V(x,s) = A e^{\\gamma(s)x} + B e^{-\\gamma(s)x}$$\n系数 $A$ 和 $B$ 由边界条件确定。\n在输入端（$x=0$），施加一个单位阶跃电压，所以其拉普拉斯变换为 $V(0,s) = 1/s$。\n$$V(0,s) = A + B = \\frac{1}{s}$$\n在远端（$x=\\ell$），线路是未端接的（开路），这意味着电流为零：$I(\\ell,s)=0$。我们可以用第一个电报方程来表示 $I(x,s)$：\n$$I(x,s) = -\\frac{1}{r}\\frac{dV(x,s)}{dx} = -\\frac{\\gamma(s)}{r} \\left( A e^{\\gamma(s)x} - B e^{-\\gamma(s)x} \\right)$$\n在 $x=\\ell$ 处应用零电流条件：\n$$I(\\ell,s) = -\\frac{\\gamma(s)}{r} \\left( A e^{\\gamma(s)\\ell} - B e^{-\\gamma(s)\\ell} \\right) = 0$$\n这意味着 $A e^{\\gamma(s)\\ell} = B e^{-\\gamma(s)\\ell}$，或者 $A = B e^{-2\\gamma(s)\\ell}$。\n将此代入 $V(0,s)$ 的方程：\n$$B e^{-2\\gamma(s)\\ell} + B = \\frac{1}{s} \\implies B \\left( 1 + e^{-2\\gamma(s)\\ell} \\right) = \\frac{1}{s}$$\n解出 $B$：\n$$B = \\frac{1}{s(1 + e^{-2\\gamma(s)\\ell})}$$\n输出电压为 $V_{\\text{out}}(s) = V(\\ell,s)$：\n$$V(\\ell,s) = A e^{\\gamma(s)\\ell} + B e^{-\\gamma(s)\\ell} = (B e^{-2\\gamma(s)\\ell})e^{\\gamma(s)\\ell} + B e^{-\\gamma(s)\\ell} = 2B e^{-\\gamma(s)\\ell}$$\n代入 $B$ 的表达式：\n$$V(\\ell,s) = \\frac{2 e^{-\\gamma(s)\\ell}}{s(1 + e^{-2\\gamma(s)\\ell})} = \\frac{2}{s(e^{\\gamma(s)\\ell} + e^{-\\gamma(s)\\ell})} = \\frac{1}{s \\cosh(\\gamma(s)\\ell)}$$\n传递函数 $H(s)$ 将输出变换与输入变换联系起来。由于输入是一个单位阶跃，所以 $V_{\\text{in}}(s) = 1/s$。\n$$H(s) = \\frac{V_{\\text{out}}(s)}{V_{\\text{in}}(s)} = \\frac{1/(s \\cosh(\\gamma(s)\\ell))}{1/s} = \\frac{1}{\\cosh(\\gamma(s)\\ell)}$$\n代入 $\\gamma(s) = \\sqrt{src}$：\n$$H(s) = \\frac{1}{\\cosh(\\ell\\sqrt{rc}\\sqrt{s})}$$\n冲激响应的一阶矩 $m_1$ 由传递函数在 $s=0$ 处的导数给出：\n$$m_1 = -\\frac{dH(s)}{ds}\\bigg|_{s=0}$$\n让我们计算导数。为简单起见，设 $\\alpha = \\ell\\sqrt{rc}$。\n$$H(s) = [\\cosh(\\alpha\\sqrt{s})]^{-1}$$\n$$\\frac{dH}{ds} = -[\\cosh(\\alpha\\sqrt{s})]^{-2} \\cdot \\sinh(\\alpha\\sqrt{s}) \\cdot \\frac{d}{ds}(\\alpha\\sqrt{s})$$\n$$\\frac{dH}{ds} = -\\frac{\\sinh(\\alpha\\sqrt{s})}{\\cosh^2(\\alpha\\sqrt{s})} \\cdot \\frac{\\alpha}{2\\sqrt{s}}$$\n为了在 $s=0$ 处求值，我们必须取 $s \\to 0$ 的极限。我们使用分量函数的已知极限：\n$$\\lim_{s \\to 0} \\cosh^2(\\alpha\\sqrt{s}) = \\cosh^2(0) = 1^2 = 1$$\n$$\\lim_{s \\to 0} \\frac{\\sinh(\\alpha\\sqrt{s})}{\\sqrt{s}} = \\lim_{\\theta \\to 0} \\frac{\\sinh(\\alpha\\theta)}{\\theta} = \\alpha$$\n第二个极限可以使用洛必达法则或通过对小 $z$ 的泰勒级数展开式 $\\sinh(z) \\approx z$ 来验证。\n结合这些结果：\n$$\\frac{dH}{ds}\\bigg|_{s=0} = \\lim_{s \\to 0} \\left( -\\frac{\\alpha}{2} \\cdot \\frac{\\sinh(\\alpha\\sqrt{s})}{\\sqrt{s}} \\cdot \\frac{1}{\\cosh^2(\\alpha\\sqrt{s})} \\right) = -\\frac{\\alpha}{2} \\cdot \\alpha \\cdot \\frac{1}{1} = -\\frac{\\alpha^2}{2}$$\n一阶矩，我们记为 $T_{\\text{moment}}$，是：\n$$T_{\\text{moment}} = m_1 = - \\left( -\\frac{\\alpha^2}{2} \\right) = \\frac{\\alpha^2}{2}$$\n代回 $\\alpha = \\ell\\sqrt{rc}$：\n$$T_{\\text{moment}} = \\frac{(\\ell\\sqrt{rc})^2}{2} = \\frac{rc\\ell^2}{2}$$\n\n**3. 比较**\n\n我们已经计算了Elmore延迟和冲激响应的精确一阶矩：\n$$T_{\\text{Elmore}} = \\frac{rc\\ell^2}{2}$$\n$$T_{\\text{moment}} = \\frac{rc\\ell^2}{2}$$\n这两个结果是相同的。这表明对于一个简单的、均匀的分布式RC线路，Elmore延迟不是一个近似值，而实际上就是冲激响应的精确一阶矩。\n\n问题要求的是精确一阶矩与Elmore延迟的无量纲比率：\n$$\\text{Ratio} = \\frac{T_{\\text{moment}}}{T_{\\text{Elmore}}} = \\frac{rc\\ell^2/2}{rc\\ell^2/2} = 1$$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "从理论分析转向实际优化，关键一步是量化设计变量对性能指标的影响。为了自动优化导线尺寸以最小化延迟，优化算法需要知道延迟对每个线宽变化的敏感度，即梯度。这项练习将指导你为一个两段式 RC 梯形网络，推导其 Elmore 延迟关于线宽的解析梯度，这是所有基于梯度的尺寸优化算法的核心 。",
            "id": "4308258",
            "problem": "考虑在电子设计自动化（EDA）的背景下，一个集成电路中的两段式互连线，其模型为阻容（RC）梯形网络。该互连线由长度为 $L_{1}$、宽度为 $w_{1}$ 的段落 $1$ 和长度为 $L_{2}$、宽度为 $w_{2}$ 的段落 $2$ 串联组成，由源电阻 $R_{d}$ 驱动，并终止于一个容性负载 $C_{L}$。假设金属薄层电阻为 $R_{s}$（单位为欧姆/方块），因此各段电阻为 $R_{1} = R_{s} \\frac{L_{1}}{w_{1}}$ 和 $R_{2} = R_{s} \\frac{L_{2}}{w_{2}}$。将单位长度对地电容建模为随宽度变化的仿射函数，即 $c(w) = c_{0} + k w$，从而得到各段电容为 $C_{1} = \\left(c_{0} + k w_{1}\\right) L_{1}$ 和 $C_{2} = \\left(c_{0} + k w_{2}\\right) L_{2}$。忽略与相邻线路的耦合以及任何其他寄生参数。\n\n使用RC树的一阶矩近似（Elmore延迟），从第一性原理出发，推导出在段落 $2$ 末端的宿端延迟 $T_{d}(w_{1}, w_{2})$ 的解析表达式，该表达式应以 $R_{d}$、$R_{1}$、$R_{2}$、$C_{1}$、$C_{2}$ 和 $C_{L}$ 表示。然后，解析地计算梯度分量 $\\frac{\\partial T_{d}}{\\partial w_{1}}$ 和 $\\frac{\\partial T_{d}}{\\partial w_{2}}$。\n\n使用扰动 $\\delta w_{1} = 0.01\\, w_{1}$ 和 $\\delta w_{2} = 0.01\\, w_{2}$，通过中心有限差分近似来验证您的解析梯度，并报告相对误差。使用以下参数值：\n- $R_{s} = 0.05$\n- $L_{1} = 2.0 \\times 10^{-3}$\n- $L_{2} = 1.5 \\times 10^{-3}$\n- $c_{0} = 2.5 \\times 10^{-10}$\n- $k = 2.0 \\times 10^{-4}$\n- $R_{d} = 120$\n- $C_{L} = 4.0 \\times 10^{-13}$\n- $w_{1} = 0.9 \\times 10^{-6}$\n- $w_{2} = 1.2 \\times 10^{-6}$\n\n将您的最终梯度分量四舍五入至四位有效数字。以秒/米（s/m）为单位表示最终梯度。",
            "solution": "用户要求我解决一个关于集成电路中互连线延迟优化的问题。\n\n### 第一步：提取已知条件\n问题提供了一个两段式RC互连线的模型。给定的参数和定义如下：\n- 源电阻：$R_{d}$\n- 段落1：长度 $L_{1}$，宽度 $w_{1}$\n- 段落2：长度 $L_{2}$，宽度 $w_{2}$\n- 负载电容：$C_{L}$\n- 金属薄层电阻：$R_{s}$\n- 段落电阻：$R_{1} = R_{s} \\frac{L_{1}}{w_{1}}$ 和 $R_{2} = R_{s} \\frac{L_{2}}{w_{2}}$\n- 单位长度电容模型：$c(w) = c_{0} + k w$\n- 段落电容：$C_{1} = (c_{0} + k w_{1}) L_{1}$ 和 $C_{2} = (c_{0} + k w_{2}) L_{2}$\n- 数值：\n  - $R_{s} = 0.05$\n  - $L_{1} = 2.0 \\times 10^{-3}$\n  - $L_{2} = 1.5 \\times 10^{-3}$\n  - $c_{0} = 2.5 \\times 10^{-10}$\n  - $k = 2.0 \\times 10^{-4}$\n  - $R_{d} = 120$\n  - $C_{L} = 4.0 \\times 10^{-13}$\n  - $w_{1} = 0.9 \\times 10^{-6}$\n  - $w_{2} = 1.2 \\times 10^{-6}$\n- 有限差分扰动：$\\delta w_{1} = 0.01\\, w_{1}$ 和 $\\delta w_{2} = 0.01\\, w_{2}$\n\n任务是推导Elmore延迟 $T_d$，计算其梯度 $\\nabla T_d = \\left(\\frac{\\partial T_{d}}{\\partial w_{1}}, \\frac{\\partial T_{d}}{\\partial w_{2}}\\right)$，用有限差分近似验证解析梯度，并报告四舍五入到四位有效数字的解析梯度分量。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，使用了公认的RC梯形网络模型和Elmore延迟近似，这些都是集成电路互连线分析中的基本概念。该问题是良构的，提供了所有必要的参数和明确的目标。语言客观而精确。这些参数（假设使用国际单位制，即米、秒、欧姆、法拉）在物理上是一致的，并且处于VLSI或封装互连线的合理范围内。该问题是自洽的，不包含任何矛盾、不切实际的假设或主观因素。\n\n### 第三步：结论与行动\n问题有效。将提供完整的解决方案。\n\n### Elmore延迟的推导\n该互连线被建模为一个两级RC梯形网络。\n- 节点 $0$：由源驱动，电阻为 $R_d$。\n- 节点 $1$：段落 $1$ 和段落 $2$ 的连接点，对地电容为 $C_1$。\n- 节点 $2$：宿端，段落 $2$ 的终点，对地电容为 $C_2$ 和负载电容 $C_L$。\n\n节点 $i$ 的Elmore延迟由 $T_{d,i} = \\sum_{j} R_{path(i,j)} C_j$ 给出，其中 $C_j$ 是节点 $j$ 的电容，而 $R_{path(i,j)}$ 是从源到节点 $i$ 和节点 $j$ 的公共路径上的电阻。\n\n我们关心的是宿端节点 $2$ 的延迟。电路中的电容器是节点 $1$ 处的 $C_1$以及节点 $2$ 处的 $C_2$ 和 $C_L$。\n从源到节点 $1$ 的路径包含电阻 $R_d$ 和 $R_1$。\n从源到节点 $2$ 的路径包含电阻 $R_d$、 $R_1$ 和 $R_2$。\n\n1. 对于节点 $1$ 处的电容器 $C_1$：源到宿端（节点 $2$）路径与源到节点 $1$ 路径之间的公共路径电阻为 $R_d + R_1$。其对延迟的贡献是 $(R_d + R_1)C_1$。\n2. 对于节点 $2$ 处的电容器 $C_2$ 和 $C_L$：公共路径电阻是到节点 $2$ 的完整路径，即 $R_d + R_1 + R_2$。其对延迟的贡献是 $(R_d + R_1 + R_2)(C_2 + C_L)$。\n\n将这些贡献相加，得到宿端的总Elmore延迟：\n$$T_d = (R_d + R_1)C_1 + (R_d + R_1 + R_2)(C_2 + C_L)$$\n将 $R_1, R_2, C_1, C_2$ 用 $w_1, w_2$ 表示的给定表达式代入：\n$$T_d(w_1, w_2) = \\left(R_d + R_s \\frac{L_1}{w_1}\\right) \\left( (c_0 + k w_1) L_1 \\right) + \\left(R_d + R_s \\frac{L_1}{w_1} + R_s \\frac{L_2}{w_2}\\right) \\left( (c_0 + k w_2) L_2 + C_L \\right)$$\n\n### 解析梯度计算\n我们将计算 $T_d$ 关于 $w_1$ 和 $w_2$ 的偏导数。\n\n**关于 $w_1$ 的偏导数：**\n为了求得 $\\frac{\\partial T_d}{\\partial w_1}$，我们将 $T_d(w_1, w_2)$ 对 $w_1$ 求导，并将 $w_2$ 视为常数。\n$$\\frac{\\partial T_d}{\\partial w_1} = \\frac{\\partial}{\\partial w_1} \\left[ (R_d + R_1)C_1 + (R_d + R_1 + R_2)(C_2 + C_L) \\right]$$\n我们使用乘法法则和微分的线性性质。注意 $\\frac{\\partial R_2}{\\partial w_1} = 0$、$\\frac{\\partial C_2}{\\partial w_1} = 0$ 和 $\\frac{\\partial C_L}{\\partial w_1} = 0$。\n$R_1$ 和 $C_1$ 关于 $w_1$ 的导数是：\n$$\\frac{\\partial R_1}{\\partial w_1} = \\frac{\\partial}{\\partial w_1} \\left(R_s L_1 w_1^{-1}\\right) = -R_s \\frac{L_1}{w_1^2} = -\\frac{R_1}{w_1}$$\n$$\\frac{\\partial C_1}{\\partial w_1} = \\frac{\\partial}{\\partial w_1} \\left( (c_0 + k w_1) L_1 \\right) = k L_1$$\n将这些应用到 $T_d$ 的表达式中：\n$$\\frac{\\partial T_d}{\\partial w_1} = \\left[ \\frac{\\partial (R_d+R_1)}{\\partial w_1} C_1 + (R_d+R_1) \\frac{\\partial C_1}{\\partial w_1} \\right] + \\left[ \\frac{\\partial (R_d+R_1+R_2)}{\\partial w_1} (C_2+C_L) \\right]$$\n$$\\frac{\\partial T_d}{\\partial w_1} = \\left( -\\frac{R_1}{w_1} \\right) C_1 + (R_d+R_1)(k L_1) + \\left( -\\frac{R_1}{w_1} \\right) (C_2+C_L)$$\n整理各项：\n$$\\frac{\\partial T_d}{\\partial w_1} = (R_d + R_1)k L_1 - \\frac{R_1}{w_1}(C_1 + C_2 + C_L)$$\n\n**关于 $w_2$ 的偏导数：**\n为了求得 $\\frac{\\partial T_d}{\\partial w_2}$，我们将 $T_d(w_1, w_2)$ 对 $w_2$ 求导，并将 $w_1$ 视为常数。\n$$\\frac{\\partial T_d}{\\partial w_2} = \\frac{\\partial}{\\partial w_2} \\left[ (R_d + R_1)C_1 + (R_d + R_1 + R_2)(C_2 + C_L) \\right]$$\n第一项 $(R_d + R_1)C_1$ 相对于 $w_2$ 是常数。$R_2$ 和 $C_2$ 的导数是：\n$$\\frac{\\partial R_2}{\\partial w_2} = \\frac{\\partial}{\\partial w_2} \\left(R_s L_2 w_2^{-1}\\right) = -R_s \\frac{L_2}{w_2^2} = -\\frac{R_2}{w_2}$$\n$$\\frac{\\partial C_2}{\\partial w_2} = \\frac{\\partial}{\\partial w_2} \\left( (c_0 + k w_2) L_2 \\right) = k L_2$$\n对 $T_d$ 的第二项应用乘法法则：\n$$\\frac{\\partial T_d}{\\partial w_2} = \\frac{\\partial (R_d+R_1+R_2)}{\\partial w_2} (C_2+C_L) + (R_d+R_1+R_2) \\frac{\\partial (C_2+C_L)}{\\partial w_2}$$\n$$\\frac{\\partial T_d}{\\partial w_2} = \\left( -\\frac{R_2}{w_2} \\right) (C_2+C_L) + (R_d+R_1+R_2) (k L_2)$$\n整理各项：\n$$\\frac{\\partial T_d}{\\partial w_2} = (R_d + R_1 + R_2)k L_2 - \\frac{R_2}{w_2}(C_2 + C_L)$$\n\n### 数值计算与验证\n首先，我们计算在标称宽度下 $R_1, R_2, C_1, C_2$ 的值。所有单位均为国际单位制。\n$R_1 = (0.05) \\frac{2.0 \\times 10^{-3}}{0.9 \\times 10^{-6}} = \\frac{1000}{9} \\Omega \\approx 111.111\\,\\Omega$\n$R_2 = (0.05) \\frac{1.5 \\times 10^{-3}}{1.2 \\times 10^{-6}} = 62.5\\,\\Omega$\n$C_1 = (2.5 \\times 10^{-10} + (2.0 \\times 10^{-4})(0.9 \\times 10^{-6})) (2.0 \\times 10^{-3}) = (4.3 \\times 10^{-10})(2.0 \\times 10^{-3}) = 8.6 \\times 10^{-13}\\,\\text{F}$\n$C_2 = (2.5 \\times 10^{-10} + (2.0 \\times 10^{-4})(1.2 \\times 10^{-6})) (1.5 \\times 10^{-3}) = (4.9 \\times 10^{-10})(1.5 \\times 10^{-3}) = 7.35 \\times 10^{-13}\\,\\text{F}$\n\n**解析梯度值：**\n对于 $\\frac{\\partial T_d}{\\partial w_1}$：\n$R_d+R_1 = 120 + \\frac{1000}{9} = \\frac{2080}{9}\\,\\Omega$\n$kL_1 = (2.0 \\times 10^{-4})(2.0 \\times 10^{-3}) = 4.0 \\times 10^{-7}\\,\\text{F/m}$\n$\\frac{R_1}{w_1} = \\frac{1000/9}{0.9 \\times 10^{-6}} = \\frac{10^9}{8.1}\\,\\Omega/\\text{m}$\n$C_1+C_2+C_L = (8.6 + 7.35 + 4.0) \\times 10^{-13} = 1.995 \\times 10^{-12}\\,\\text{F}$\n$\\frac{\\partial T_d}{\\partial w_1} = \\left(\\frac{2080}{9}\\right)(4.0 \\times 10^{-7}) - \\left(\\frac{10^9}{8.1}\\right)(1.995 \\times 10^{-12}) = 9.2444... \\times 10^{-5} - 2.46296... \\times 10^{-4} = -1.53852... \\times 10^{-4}\\,\\text{s/m}$\n\n对于 $\\frac{\\partial T_d}{\\partial w_2}$：\n$R_d+R_1+R_2 = 120 + \\frac{1000}{9} + 62.5 = \\frac{2642.5}{9}\\,\\Omega$\n$kL_2 = (2.0 \\times 10^{-4})(1.5 \\times 10^{-3}) = 3.0 \\times 10^{-7}\\,\\text{F/m}$\n$\\frac{R_2}{w_2} = \\frac{62.5}{1.2 \\times 10^{-6}}\\,\\Omega/\\text{m}$\n$C_2+C_L = (7.35 + 4.0) \\times 10^{-13} = 1.135 \\times 10^{-12}\\,\\text{F}$\n$\\frac{\\partial T_d}{\\partial w_2} = \\left(\\frac{2642.5}{9}\\right)(3.0 \\times 10^{-7}) - \\left(\\frac{62.5}{1.2 \\times 10^{-6}}\\right)(1.135 \\times 10^{-12}) = 8.80833... \\times 10^{-5} - 5.91145... \\times 10^{-5} = 2.89687... \\times 10^{-5}\\,\\text{s/m}$\n\n**有限差分验证：**\n中心有限差分近似为 $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$。\n对于 $\\frac{\\partial T_d}{\\partial w_1}$，$h = \\delta w_1 = 0.01 \\times (0.9 \\times 10^{-6}) = 9 \\times 10^{-9}\\,\\text{m}$。\n$w_1^{\\pm} = w_1 \\pm \\delta w_1 = (0.9 \\pm 0.009) \\times 10^{-6}\\,\\text{m}$。\n$T_d(w_1 + \\delta w_1, w_2) \\approx 5.30637 \\times 10^{-10}\\,\\text{s}$\n$T_d(w_1 - \\delta w_1, w_2) \\approx 5.33417 \\times 10^{-10}\\,\\text{s}$\n$\\left.\\frac{\\partial T_d}{\\partial w_1}\\right|_{\\text{FD}} = \\frac{5.30637 \\times 10^{-10} - 5.33417 \\times 10^{-10}}{2 \\times 9 \\times 10^{-9}} = -1.5444... \\times 10^{-4}\\,\\text{s/m}$\n$\\frac{\\partial T_d}{\\partial w_1}$ 的相对误差：$| \\frac{-1.5444 \\times 10^{-4} - (-1.5385 \\times 10^{-4})}{-1.5385 \\times 10^{-4}} | \\approx 0.0038 \\text{ 或 } 0.38\\%$。\n\n对于 $\\frac{\\partial T_d}{\\partial w_2}$，$h = \\delta w_2 = 0.01 \\times (1.2 \\times 10^{-6}) = 1.2 \\times 10^{-8}\\,\\text{m}$。\n$w_2^{\\pm} = w_2 \\pm \\delta w_2 = (1.2 \\pm 0.012) \\times 10^{-6}\\,\\text{m}$。\n$T_d(w_1, w_2 + \\delta w_2) \\approx 5.32362 \\times 10^{-10}\\,\\text{s}$\n$T_d(w_1, w_2 - \\delta w_2) \\approx 5.31671 \\times 10^{-10}\\,\\text{s}$\n$\\left.\\frac{\\partial T_d}{\\partial w_2}\\right|_{\\text{FD}} = \\frac{5.32362 \\times 10^{-10} - 5.31671 \\times 10^{-10}}{2 \\times 1.2 \\times 10^{-8}} = 2.879... \\times 10^{-5}\\,\\text{s/m}$\n$\\frac{\\partial T_d}{\\partial w_2}$ 的相对误差：$| \\frac{2.879 \\times 10^{-5} - 2.897 \\times 10^{-5}}{2.897 \\times 10^{-5}} | \\approx 0.0062 \\text{ 或 } 0.62\\%$。\n微小的相对误差验证了解析梯度表达式的正确性。\n\n### 最终答案计算\n问题要求将最终梯度分量四舍五入到四位有效数字。\n$\\frac{\\partial T_d}{\\partial w_1} = -1.53852... \\times 10^{-4}\\,\\text{s/m} \\approx -1.539 \\times 10^{-4}\\,\\text{s/m}$\n$\\frac{\\partial T_d}{\\partial w_2} = 2.89687... \\times 10^{-5}\\,\\text{s/m} \\approx 2.897 \\times 10^{-5}\\,\\text{s/m}$\n\n最终答案以梯度分量的行矩阵形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-1.539 \\times 10^{-4}  2.897 \\times 10^{-5}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "获得了延迟梯度后，我们便可以将其应用于实际的优化算法中，以迭代地改进互连性能。这项练习将让你亲手实现约束优化中的一个核心步骤：投影梯度下降。你将学习如何利用上一步计算出的梯度信息来更新导线宽度，同时确保新的宽度值满足制造工艺所要求的物理边界条件（例如最小/最大线宽）。",
            "id": "4308231",
            "problem": "考虑在集成电路的电子设计自动化（EDA）背景下的受约束导线宽度优化问题。导线宽度向量 $w \\in \\mathbb{R}^n$ 的每个分量 $w_i$ 都受到设计规则边界 $w_{\\min} \\le w_i \\le w_{\\max}$ 的约束。假设给定一个可微的目标函数 $J(w)$，它模拟了延迟或功耗等性能指标，以及它在当前迭代点 $w^{(k)}$ 处的梯度 $\\nabla J(w)$。您将使用给定的正步长 $\\alpha$，执行一次投影梯度法的迭代，该方法使用到由边界定义的可行箱上的欧几里得投影。\n\n从以下基本原理出发：\n- 无约束梯度下降步骤将 $w$ 更新为 $w^{(k)} - \\alpha \\nabla J(w^{(k)})$，其中 $\\alpha$ 是一个正步长。\n- 针对箱型约束的投影梯度步骤将欧几里得投影 $\\Pi_{\\mathcal{B}}(\\cdot)$ 应用到可行集 $\\mathcal{B} = \\{x \\in \\mathbb{R}^n \\mid w_{\\min} \\le x_i \\le w_{\\max} \\text{ for all } i\\}$ 上的无约束更新，即 $w^{(k+1)} = \\Pi_{\\mathcal{B}}\\!\\left(w^{(k)} - \\alpha \\nabla J(w^{(k)})\\right)$。\n- 一个点 $y \\in \\mathbb{R}^n$ 到一个闭凸集 $\\mathcal{C}$ 上的欧几里得投影定义为 $\\Pi_{\\mathcal{C}}(y) = \\arg\\min_{x \\in \\mathcal{C}} \\|x - y\\|_2$。\n\n任务：给定当前宽度 $w^{(k)}$、梯度 $g = \\nabla J(w^{(k)})$、步长 $\\alpha$ 和箱型边界，实现单次投影梯度更新 $w^{(k+1)}$。将投影视为到箱上的欧几里得投影。边界可以指定为标量（所有分量相同）或向量（分量级边界 $w_{\\min,i}$ 和 $w_{\\max,i}$）。所有宽度 $w_i$、下界 $w_{\\min}$ 和上界 $w_{\\max}$ 的单位都是微米。步长 $\\alpha$ 必须为正，且其大小应使 $\\alpha \\, g_i$ 的单位为微米。将更新后宽度 $w^{(k+1)}$ 的每个分量以微米表示，并四舍五入到 $6$ 位小数。\n\n测试套件：\n对于下面的每个测试用例，计算一次投影梯度步骤后的 $w^{(k+1)}$。请完全按照给定的参数进行计算。在所有情况下，以微米为单位报告结果宽度。\n\n- 测试用例 1：\n  - $w^{(k)} = [\\,0.8,\\, 1.2,\\, 0.5\\,]$\n  - $g = [\\,0.3,\\, -0.5,\\, 2.0\\,]$\n  - $\\alpha = 0.1$\n  - $w_{\\min} = 0.4$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 2：\n  - $w^{(k)} = [\\,1.9,\\, 1.95\\,]$\n  - $g = [\\,-5.0,\\, -1.0\\,]$\n  - $\\alpha = 0.05$\n  - $w_{\\min} = 0.5$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 3：\n  - $w^{(k)} = [\\,0.5,\\, 0.6,\\, 0.7\\,]$\n  - $g = [\\,10.0,\\, 0.0,\\, -3.0\\,]$\n  - $\\alpha = 0.02$\n  - $w_{\\min} = 0.5$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 4（分量级边界）：\n  - $w^{(k)} = [\\,0.45,\\, 0.9,\\, 1.8,\\, 0.4\\,]$\n  - $g = [\\,-1.0,\\, 2.0,\\, -5.0,\\, 1.0\\,]$\n  - $\\alpha = 0.1$\n  - $w_{\\min} = [\\,0.4,\\, 0.6,\\, 1.0,\\, 0.45\\,]$\n  - $w_{\\max} = [\\,0.6,\\, 1.5,\\, 1.9,\\, 0.6\\,]$\n\n- 测试用例 5：\n  - $w^{(k)} = [\\,0.4,\\, 2.0\\,]$\n  - $g = [\\,0.0,\\, 0.0\\,]$\n  - $\\alpha = 10.0$\n  - $w_{\\min} = 0.4$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 6（数值边缘压力）：\n  - $w^{(k)} = [\\,10^{-3},\\, 10^{3}\\,]$\n  - $g = [\\,10^{-9},\\, -10^{-9}\\,]$\n  - $\\alpha = 10^{6}$\n  - $w_{\\min} = 0.0$\n  - $w_{\\max} = 1000.0$\n\n您的程序必须为每个测试用例实现投影梯度更新，并以微米为单位输出四舍五入到 $6$ 位小数的更新后宽度。最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，用方括号括起来，不含空格（例如，$[[a_{11},a_{12}],\\,[a_{21},a_{22}]]$）。每个内部列表对应于一个测试用例的更新后宽度，顺序与提供的一致。输出中的所有数字必须精确到 $6$ 位小数，并且单位为微米。",
            "solution": "所呈现的问题是约束优化的一个明确定义的实例，具体来说，是将投影梯度下降法应用于集成电路设计中的导线尺寸调整问题。目标是给定当前迭代值 $w^{(k)}$、成本函数的梯度 $g = \\nabla J(w^{(k)})$、步长 $\\alpha$ 以及箱型约束 $w_{\\min} \\le w_i \\le w_{\\max}$，计算单个更新后的导线宽度迭代值 $w^{(k+1)}$。\n\n投影梯度下降法是解决形如 $\\min_{w \\in \\mathcal{B}} J(w)$ 的约束优化问题的一种迭代算法，其中 $\\mathcal{B}$ 是一个闭凸集。更新规则如下：\n$$\nw^{(k+1)} = \\Pi_{\\mathcal{B}}\\!\\left(w^{(k)} - \\alpha g\\right)\n$$\n其中 $\\Pi_{\\mathcal{B}}(y)$ 是点 $y$ 在集合 $\\mathcal{B}$ 上的欧几里得投影。此操作在集合 $\\mathcal{B}$ 中找到在欧几里得范数意义下距离 $y$ 最近的点。该过程可以分解为两个基本步骤：\n\n1.  **无约束梯度步骤**：首先，执行一个标准的梯度下降步骤来找到一个中间点，我们称之为 $y$。该点最小化了 $J(w)$ 在 $w^{(k)}$ 周围的一阶泰勒展开，而不考虑约束。\n    $$\n    y = w^{(k)} - \\alpha g\n    $$\n    这里，$w^{(k)}$ 是当前的导线宽度向量，$g$ 是梯度向量 $\\nabla J(w^{(k)})$，而 $\\alpha > 0$ 是学习率或步长。\n\n2.  **投影步骤**：中间点 $y$ 可能位于可行集 $\\mathcal{B}$ 之外。投影步骤将此点映射回 $\\mathcal{B}$ 内最近的点。此问题中的可行集是一个由分量级约束定义的超矩形（或“箱”）：\n    $$\n    \\mathcal{B} = \\{x \\in \\mathbb{R}^n \\mid w_{\\min,i} \\le x_i \\le w_{\\max,i} \\text{ for } i=1, \\dots, n\\}\n    $$\n    在箱上投影的一个关键特性是它是可分离的。这意味着向量 $y$ 的投影可以通过将其每个分量 $y_i$ 独立地投影到相应的一维区间 $[w_{\\min,i}, w_{\\max,i}]$ 上来计算。单个分量 $y_i$ 的投影是区间 $[w_{\\min,i}, w_{\\max,i}]$ 中最接近 $y_i$ 的值。这可以通过一个简单的裁剪或钳位操作来表示：\n    $$\n    (\\Pi_{\\mathcal{B}}(y))_i = \\begin{cases}\n        w_{\\min,i}  \\text{if } y_i  w_{\\min,i} \\\\\n        y_i  \\text{if } w_{\\min,i} \\le y_i \\le w_{\\max,i} \\\\\n        w_{\\max,i}  \\text{if } y_i  w_{\\max,i}\n    \\end{cases}\n    $$\n    这等价于表达式 $w^{(k+1)}_i = \\max(w_{\\min,i}, \\min(y_i, w_{\\max,i}))$。\n\n每个测试用例的总体算法如下：\n1.  给定向量 $w^{(k)}$ 和 $g$，以及标量 $\\alpha$、$w_{\\min}$、$w_{\\max}$（或向量 $w_{\\min}$、$w_{\\max}$）。\n2.  如果边界 $w_{\\min}$ 和 $w_{\\max}$ 作为标量提供，则将它们视为每个分量都等于相应标量的向量。\n3.  计算每个分量 $i$ 的无约束更新：$y_i = w^{(k)}_i - \\alpha g_i$。\n4.  计算每个分量 $i$ 的投影更新：$w^{(k+1)}_i = \\max(w_{\\min,i}, \\min(y_i, w_{\\max,i}))$。\n5.  将结果分量收集到最终向量 $w^{(k+1)}$ 中。\n\n作为说明性示例，让我们将此应用于测试用例 1：\n- 给定：$w^{(k)} = [\\,0.8,\\, 1.2,\\, 0.5\\,]$, $g = [\\,0.3,\\, -0.5,\\, 2.0\\,]$, $\\alpha = 0.1$, $w_{\\min} = 0.4$, $w_{\\max} = 2.0$。\n- 步骤 1：计算无约束更新向量 $y$。\n  $$\n  y = [\\,0.8,\\, 1.2,\\, 0.5\\,] - 0.1 \\times [\\,0.3,\\, -0.5,\\, 2.0\\,] = [\\,0.8,\\, 1.2,\\, 0.5\\,] - [\\,0.03,\\, -0.05,\\, 0.2\\,] = [\\,0.77,\\, 1.25,\\, 0.3\\,]\n  $$\n- 步骤 2：将 $y$ 投影到所有分量均由 $[0.4, 2.0]$ 定义的箱上。\n  - $w^{(k+1)}_1$：$y_1 = 0.77$。由于 $0.4 \\le 0.77 \\le 2.0$，所以 $w^{(k+1)}_1 = 0.77$。\n  - $w^{(k+1)}_2$：$y_2 = 1.25$。由于 $0.4 \\le 1.25 \\le 2.0$，所以 $w^{(k+1)}_2 = 1.25$。\n  - $w^{(k+1)}_3$：$y_3 = 0.3$。由于 $0.3  0.4$，$w^{(k+1)}_3$ 被钳位到下界，因此 $w^{(k+1)}_3 = 0.4$。\n- 最终的更新后宽度向量为 $w^{(k+1)} = [\\,0.77,\\, 1.25,\\, 0.4\\,]$。然后，将每个分量格式化为六位小数以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the projected gradient descent problem for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"w_k\": [0.8, 1.2, 0.5],\n            \"g\": [0.3, -0.5, 2.0],\n            \"alpha\": 0.1,\n            \"w_min\": 0.4,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [1.9, 1.95],\n            \"g\": [-5.0, -1.0],\n            \"alpha\": 0.05,\n            \"w_min\": 0.5,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [0.5, 0.6, 0.7],\n            \"g\": [10.0, 0.0, -3.0],\n            \"alpha\": 0.02,\n            \"w_min\": 0.5,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [0.45, 0.9, 1.8, 0.4],\n            \"g\": [-1.0, 2.0, -5.0, 1.0],\n            \"alpha\": 0.1,\n            \"w_min\": [0.4, 0.6, 1.0, 0.45],\n            \"w_max\": [0.6, 1.5, 1.9, 0.6]\n        },\n        {\n            \"w_k\": [0.4, 2.0],\n            \"g\": [0.0, 0.0],\n            \"alpha\": 10.0,\n            \"w_min\": 0.4,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [1e-3, 1e3],\n            \"g\": [1e-9, -1e-9],\n            \"alpha\": 1e6,\n            \"w_min\": 0.0,\n            \"w_max\": 1000.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w_k = np.array(case[\"w_k\"], dtype=float)\n        g = np.array(case[\"g\"], dtype=float)\n        alpha = float(case[\"alpha\"])\n        w_min = case[\"w_min\"]\n        w_max = case[\"w_max\"]\n\n        # Step 1: Perform the unconstrained gradient descent step.\n        y = w_k - alpha * g\n\n        # Step 2: Project the result onto the feasible box.\n        # np.clip is the direct implementation of the projection onto a box.\n        # It handles both scalar and array-like bounds correctly.\n        w_k_plus_1 = np.clip(y, w_min, w_max)\n        \n        results.append(w_k_plus_1)\n\n    # Format the final output string according to the specified format.\n    # Each number must have exactly 6 decimal places.\n    # The final string should have no spaces.\n    formatted_results = []\n    for res_array in results:\n        # Format each number to have 6 decimal places.\n        formatted_list = [f'{x:.6f}' for x in res_array]\n        # Create the string for the inner list, e.g., \"[0.100000,0.200000]\"\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    # join the inner list strings into the final output format, e.g., \"[[...],[...]]\"\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}