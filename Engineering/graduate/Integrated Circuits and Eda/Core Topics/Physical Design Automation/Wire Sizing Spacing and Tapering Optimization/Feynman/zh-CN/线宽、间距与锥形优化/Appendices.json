{
    "hands_on_practices": [
        {
            "introduction": "在电子设计自动化（EDA）中，我们常常需要在模型精度和计算成本之间做出权衡。本练习通过对比简单的集总$RC$模型和更精确的分布式$RC$模型，深入探讨了这种权衡在互连线延迟分析中的具体体现。通过推导集总模型误差超过特定阈值的临界线长，您将对何时以及为何不能忽略分布式效应建立起定量的认知，这对于高速电路设计至关重要。",
            "id": "4308186",
            "problem": "考虑一个片上互连，其模型为一根长度为 $L$、宽度为 $w$、厚度为 $t$ 的均匀直矩形导线，由电阻率为 $\\rho$ 的导电材料制成。该导线在其近端连接一个理想阶跃电压源（源电阻为零），在远端连接一个电容性负载。假设金属为非磁性材料，且互连工作在电感效应可忽略的区域；因此，该线路可以建模为分布式阻容网络，其单位长度电阻为 $r=\\rho/(t w)$，单位长度对地电容为 $c_{w}$。远端电容性负载建模为在 $x=L$ 处连接的单个集总电容 $c_{f}$。\n\n使用线性时不变冲激响应的一阶矩（即 Elmore 延迟）来定义远端节点的延迟指标。从适用于阻容网络的基本定义和均匀分布线路的连续极限出发，推导当导线被视为分布式阻容线时远端节点的 Elmore 延迟预测值。另外，通过将导线简化为单个串联电阻 $R_{\\text{wire}}=rL$ 和位于远端的单个集总电容 $C_{\\text{tot}}=c_{f}+c_{w}L$ 来构建一个集总模型，并使用相同的延迟指标推导相应的单极点延迟预测值。\n\n使用这两个预测值，将集总模型预测相对于分布式模型预测的相对误差定义为绝对差值与分布式模型预测值之比。确定临界长度 $\\ell$（用 $c_{f}$ 和 $c_{w}$ 表示的封闭形式符号表达式），当超过该长度时，集总模型的延迟预测的相对误差将超过 $0.10$。最终长度以米为单位表示。题目未提供数值；您的最终答案必须是单个解析表达式。除已说明的寄生参数和源电阻外，不要假设任何额外的寄生参数或源电阻，也不要考虑电感效应。",
            "solution": "该问题陈述已经过验证，被认为是集成电路设计与分析领域中一个适定且科学合理的问题。解题过程如下。\n\n主要目标是确定互连线的临界长度 $\\ell$，在该长度下，简单的集总 RC 模型的延迟预测值与更精确的分布式 RC 模型的预测值之间的偏差达到指定的 $0.10$ 相对误差。所用的延迟指标是 Elmore 延迟。\n\n首先，我们推导分布式 RC 线的 Elmore 延迟。RC 网络中节点 $i$ 的 Elmore 延迟定义为 $\\tau_{D,i} = \\sum_k R_{ik} C_k$，其中 $C_k$ 是节点 $k$ 处的电容，$R_{ik}$ 是从电压源到节点 $i$ 的路径中与从源到节点 $k$ 的路径所共有的那部分电阻。对于连续分布的线路，这个求和变成一个积分。\n\n该互连线长度为 $L$，单位长度电阻为 $r$，单位长度电容为 $c_w$。在远端 $x=L$ 处，有一个集总负载电容 $c_f$。我们要求的是这个远端节点的延迟。\n\n总电容由两部分组成：导线本身的分布电容和远端的集总电容。\n1. 来自导线分布电容的贡献：考虑在离源端距离为 $x'$ ($0 \\le x' \\le L$) 处，长度为 $dx'$ 的无限小导线段。该线段的电容为 $dC = c_w dx'$。从源到远端（$x=L$）的路径与从源到 $x'$ 的路径所共有的路径电阻是从源到 $x'$ 的电阻，即 $R(x') = r x'$。这个无限小电容对 Elmore 延迟的贡献是 $d\\tau = R(x') dC = (r x') (c_w dx')$。为了求出整条导线的总贡献，我们从 $x'=0$ 到 $x'=L$ 进行积分：\n$$ \\tau_{\\text{wire}} = \\int_0^L (r x') (c_w dx') = r c_w \\int_0^L x' dx' = r c_w \\left[ \\frac{x'^2}{2} \\right]_0^L = \\frac{1}{2} r c_w L^2 $$\n2. 来自远端负载电容 $c_f$ 的贡献：该电容位于 $x=L$ 处。从源到 $c_f$ 的路径电阻是导线的总电阻 $R_{\\text{wire}} = rL$。整个路径与到远端节点自身的路径是共用的。因此，$c_f$ 的贡献是：\n$$ \\tau_{\\text{load}} = (rL) c_f $$\n\n分布式模型的总 Elmore 延迟 $T_{D, \\text{dist}}$ 是这两部分贡献之和：\n$$ T_{D, \\text{dist}}(L) = \\tau_{\\text{wire}} + \\tau_{\\text{load}} = \\frac{1}{2} r c_w L^2 + r L c_f $$\n\n接下来，我们推导集总 L-模型的延迟。在此模型中，整个导线电阻被集总为单个串联电阻 $R_{\\text{wire}} = rL$，整个导线电容与负载电容一起被集总为远端的单个电容器 $C_{\\text{tot}} = c_w L + c_f$。这构成一个简单的一阶 RC 电路。对于这样的电路，Elmore 延迟等同于其时间常数，即电阻和电容的乘积。\n$$ T_{D, \\text{lump}}(L) = R_{\\text{wire}} C_{\\text{tot}} = (rL) (c_w L + c_f) = r c_w L^2 + r L c_f $$\n\n现在，我们定义集总模型预测相对于分布式模型预测的相对误差。\n$$ \\text{Error}(L) = \\frac{|T_{D, \\text{lump}}(L) - T_{D, \\text{dist}}(L)|}{T_{D, \\text{dist}}(L)} $$\n延迟预测值的差值为：\n$$ T_{D, \\text{lump}}(L) - T_{D, \\text{dist}}(L) = (r c_w L^2 + r L c_f) - \\left(\\frac{1}{2} r c_w L^2 + r L c_f\\right) = \\frac{1}{2} r c_w L^2 $$\n由于 $r$、$c_w$ 和 $L$ 都是正的物理量，这个差值总是正的，因此不需要绝对值符号。\n将表达式代入误差公式：\n$$ \\text{Error}(L) = \\frac{\\frac{1}{2} r c_w L^2}{\\frac{1}{2} r c_w L^2 + r L c_f} $$\n我们可以通过将分子和分母同时除以 $rL$（假设 $L>0$）来简化这个表达式：\n$$ \\text{Error}(L) = \\frac{\\frac{1}{2} c_w L}{\\frac{1}{2} c_w L + c_f} $$\n将分子和分母乘以 $2$ 可以得到一个更简洁的形式：\n$$ \\text{Error}(L) = \\frac{c_w L}{c_w L + 2 c_f} $$\n\n最后，我们必须找到临界长度 $\\ell$，当超过此长度时，相对误差将超过 $0.10$。我们通过设定 $L=\\ell$ 时的误差等于 $0.10$ 来找到边界情况。\n$$ \\frac{c_w \\ell}{c_w \\ell + 2 c_f} = 0.10 = \\frac{1}{10} $$\n现在，我们求解 $\\ell$：\n$$ 10 c_w \\ell = 1 (c_w \\ell + 2 c_f) $$\n$$ 10 c_w \\ell = c_w \\ell + 2 c_f $$\n$$ 9 c_w \\ell = 2 c_f $$\n$$ \\ell = \\frac{2 c_f}{9 c_w} $$\n误差函数 $\\text{Error}(L)$ 在 $L>0$ 时随 $L$ 单调递增。因此，对于任何长度 $L > \\ell$，相对误差都将超过 $0.10$。这样就确定了临界长度 $\\ell$ 的表达式。单位是一致的，因为 $c_f$ 的单位是法拉 (F)，$c_w$ 的单位是法拉每米 (F/m)，所以 $\\ell$ 的结果单位是米。",
            "answer": "$$ \\boxed{\\frac{2 c_f}{9 c_w}} $$"
        },
        {
            "introduction": "在建立了精确的延迟模型之后，下一步便是对其进行优化。基于梯度的方法是现代优化算法的基石，而精确计算梯度是这一切的核心。本练习要求您针对一个多分段互连线模型，推导其Elmore延迟（$T_d$）关于各段导线宽度（例如$w_1, w_2$）的解析梯度。掌握延迟敏感度的计算，是开发和理解自动化导线尺寸优化工具的基础，因为梯度直接指明了为减少延迟而调整导线宽度的最有效方向。",
            "id": "4308258",
            "problem": "在电子设计自动化 (EDA) 的背景下，考虑一个在集成电路中被建模为阻容 (RC) 梯形网络的双段互连线。该互连线由长度为 $L_{1}$、宽度为 $w_{1}$ 的第一段和长度为 $L_{2}$、宽度为 $w_{2}$ 的第二段组成，由源电阻 $R_{d}$ 驱动，并终止于一个容性负载 $C_{L}$。假设金属方块电阻为 $R_{s}$ (单位为欧姆/方块)，因此各段电阻为 $R_{1} = R_{s} \\frac{L_{1}}{w_{1}}$ 和 $R_{2} = R_{s} \\frac{L_{2}}{w_{2}}$。将单位长度对地电容建模为宽度的仿射函数，$c(w) = c_{0} + k w$，从而得到各段电容为 $C_{1} = \\left(c_{0} + k w_{1}\\right) L_{1}$ 和 $C_{2} = \\left(c_{0} + k w_{2}\\right) L_{2}$。忽略与相邻线路的耦合以及任何其他寄生效应。\n\n使用 RC 树的一阶矩近似（Elmore 延迟），从第一性原理出发，推导第二段末端终端延迟 $T_{d}(w_{1}, w_{2})$ 关于 $R_{d}$、$R_{1}$、$R_{2}$、$C_{1}$、$C_{2}$ 和 $C_{L}$ 的解析表达式。然后，解析地计算梯度分量 $\\frac{\\partial T_{d}}{\\partial w_{1}}$ 和 $\\frac{\\partial T_{d}}{\\partial w_{2}}$。\n\n使用扰动 $\\delta w_{1} = 0.01\\, w_{1}$ 和 $\\delta w_{2} = 0.01\\, w_{2}$，将您的解析梯度与中心有限差分近似进行验证，并报告相对误差。使用以下参数值：\n- $R_{s} = 0.05$\n- $L_{1} = 2.0 \\times 10^{-3}$\n- $L_{2} = 1.5 \\times 10^{-3}$\n- $c_{0} = 2.5 \\times 10^{-10}$\n- $k = 2.0 \\times 10^{-4}$\n- $R_{d} = 120$\n- $C_{L} = 4.0 \\times 10^{-13}$\n- $w_{1} = 0.9 \\times 10^{-6}$\n- $w_{2} = 1.2 \\times 10^{-6}$\n\n将您的最终梯度分量四舍五入至四位有效数字。以秒/米 (s/m) 为单位表示最终梯度。",
            "solution": "用户要求我解决一个关于集成电路中互连延迟优化的问题。\n\n### 步骤 1：提取已知条件\n该问题提供了一个两段式 RC 互连的模型。给定的参数和定义如下：\n- 源电阻：$R_{d}$\n- 第 1 段：长度 $L_{1}$，宽度 $w_{1}$\n- 第 2 段：长度 $L_{2}$，宽度 $w_{2}$\n- 负载电容：$C_{L}$\n- 金属方块电阻：$R_{s}$\n- 段电阻：$R_{1} = R_{s} \\frac{L_{1}}{w_{1}}$ 和 $R_{2} = R_{s} \\frac{L_{2}}{w_{2}}$\n- 单位长度电容模型：$c(w) = c_{0} + k w$\n- 段电容：$C_{1} = (c_{0} + k w_{1}) L_{1}$ 和 $C_{2} = (c_{0} + k w_{2}) L_{2}$\n- 数值：\n  - $R_{s} = 0.05$\n  - $L_{1} = 2.0 \\times 10^{-3}$\n  - $L_{2} = 1.5 \\times 10^{-3}$\n  - $c_{0} = 2.5 \\times 10^{-10}$\n  - $k = 2.0 \\times 10^{-4}$\n  - $R_{d} = 120$\n  - $C_{L} = 4.0 \\times 10^{-13}$\n  - $w_{1} = 0.9 \\times 10^{-6}$\n  - $w_{2} = 1.2 \\times 10^{-6}$\n- 有限差分扰动：$\\delta w_{1} = 0.01\\, w_{1}$ 和 $\\delta w_{2} = 0.01\\, w_{2}$\n\n任务是推导 Elmore 延迟 $T_d$，计算其梯度 $\\nabla T_d = \\left(\\frac{\\partial T_{d}}{\\partial w_{1}}, \\frac{\\partial T_{d}}{\\partial w_{2}}\\right)$，用有限差分近似验证解析梯度，并报告四舍五入到四位有效数字的解析梯度分量。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，使用了成熟的 RC 梯形网络模型和 Elmore 延迟近似，这些都是集成电路互连分析中的基本概念。该问题是适定的，提供了所有必要的参数和明确的目标。语言客观而精确。这些参数，假设采用国际单位制（米、秒、欧姆、法拉），在物理上是一致的，并且在 VLSI 或封装互连的合理范围内。该问题是自洽的，不包含任何矛盾、不切实际的假设或主观因素。\n\n### 步骤 3：判断与行动\n该问题有效。将提供完整的解答。\n\n### Elmore 延迟的推导\n互连被建模为两级 RC 梯形网络。\n- 节点 $0$：由源驱动，电阻为 $R_d$。\n- 节点 $1$：第 1 段和第 2 段的连接点，对地电容为 $C_1$。\n- 节点 $2$：终端，第 2 段的终点，对地电容为 $C_2$ 和负载 $C_L$。\n\n节点 $i$ 的 Elmore 延迟由 $T_{d,i} = \\sum_{j} R_{path(i,j)} C_j$ 给出，其中 $C_j$ 是节点 $j$ 的电容，$R_{path(i,j)}$ 是从源到节点 $i$ 和节点 $j$ 的公共路径的电阻。\n\n我们关心的是终端节点 2 的延迟。电路中的电容器是 $C_1$（在节点 1）以及 $C_2$ 和 $C_L$（在节点 2）。\n从源到节点 1 的路径包含电阻 $R_d$ 和 $R_1$。\n从源到节点 2 的路径包含电阻 $R_d$、$R_1$ 和 $R_2$。\n\n1. 对于节点 1 的电容器 $C_1$：源到终端路径（节点 2）与源到节点 1 路径之间的公共路径电阻是 $R_d + R_1$。对延迟的贡献是 $(R_d + R_1)C_1$。\n2. 对于节点 2 的电容器 $C_2$ 和 $C_L$：公共路径电阻是到节点 2 的完整路径，即 $R_d + R_1 + R_2$。对延迟的贡献是 $(R_d + R_1 + R_2)(C_2 + C_L)$。\n\n将这些贡献相加，得到终端的总 Elmore 延迟：\n$$T_d = (R_d + R_1)C_1 + (R_d + R_1 + R_2)(C_2 + C_L)$$\n将给定的关于 $w_1, w_2$ 的 $R_1, R_2, C_1, C_2$ 表达式代入：\n$$T_d(w_1, w_2) = \\left(R_d + R_s \\frac{L_1}{w_1}\\right) \\left( (c_0 + k w_1) L_1 \\right) + \\left(R_d + R_s \\frac{L_1}{w_1} + R_s \\frac{L_2}{w_2}\\right) \\left( (c_0 + k w_2) L_2 + C_L \\right)$$\n\n### 解析梯度计算\n我们将计算 $T_d$ 关于 $w_1$ 和 $w_2$ 的偏导数。\n\n**关于 $w_1$ 的偏导数：**\n为了求得 $\\frac{\\partial T_d}{\\partial w_1}$，我们将 $T_d(w_1, w_2)$ 对 $w_1$ 求导，并将 $w_2$ 视为常数。\n$$\\frac{\\partial T_d}{\\partial w_1} = \\frac{\\partial}{\\partial w_1} \\left[ (R_d + R_1)C_1 + (R_d + R_1 + R_2)(C_2 + C_L) \\right]$$\n我们使用乘法法则和微分的线性性质。注意 $\\frac{\\partial R_2}{\\partial w_1} = 0$，$\\frac{\\partial C_2}{\\partial w_1} = 0$，以及 $\\frac{\\partial C_L}{\\partial w_1} = 0$。\n$R_1$ 和 $C_1$ 关于 $w_1$ 的导数是：\n$$\\frac{\\partial R_1}{\\partial w_1} = \\frac{\\partial}{\\partial w_1} \\left(R_s L_1 w_1^{-1}\\right) = -R_s \\frac{L_1}{w_1^2} = -\\frac{R_1}{w_1}$$\n$$\\frac{\\partial C_1}{\\partial w_1} = \\frac{\\partial}{\\partial w_1} \\left( (c_0 + k w_1) L_1 \\right) = k L_1$$\n将这些应用到 $T_d$ 的表达式中：\n$$\\frac{\\partial T_d}{\\partial w_1} = \\left[ \\frac{\\partial (R_d+R_1)}{\\partial w_1} C_1 + (R_d+R_1) \\frac{\\partial C_1}{\\partial w_1} \\right] + \\left[ \\frac{\\partial (R_d+R_1+R_2)}{\\partial w_1} (C_2+C_L) \\right]$$\n$$\\frac{\\partial T_d}{\\partial w_1} = \\left( -\\frac{R_1}{w_1} \\right) C_1 + (R_d+R_1)(k L_1) + \\left( -\\frac{R_1}{w_1} \\right) (C_2+C_L)$$\n重新整理各项：\n$$\\frac{\\partial T_d}{\\partial w_1} = (R_d + R_1)k L_1 - \\frac{R_1}{w_1}(C_1 + C_2 + C_L)$$\n\n**关于 $w_2$ 的偏导数：**\n为了求得 $\\frac{\\partial T_d}{\\partial w_2}$，我们将 $T_d(w_1, w_2)$ 对 $w_2$ 求导，并将 $w_1$ 视为常数。\n$$\\frac{\\partial T_d}{\\partial w_2} = \\frac{\\partial}{\\partial w_2} \\left[ (R_d + R_1)C_1 + (R_d + R_1 + R_2)(C_2 + C_L) \\right]$$\n第一项 $(R_d + R_1)C_1$ 相对于 $w_2$ 是常数。$R_2$ 和 $C_2$ 的导数是：\n$$\\frac{\\partial R_2}{\\partial w_2} = \\frac{\\partial}{\\partial w_2} \\left(R_s L_2 w_2^{-1}\\right) = -R_s \\frac{L_2}{w_2^2} = -\\frac{R_2}{w_2}$$\n$$\\frac{\\partial C_2}{\\partial w_2} = \\frac{\\partial}{\\partial w_2} \\left( (c_0 + k w_2) L_2 \\right) = k L_2$$\n对 $T_d$ 的第二项应用乘法法则：\n$$\\frac{\\partial T_d}{\\partial w_2} = \\frac{\\partial (R_d+R_1+R_2)}{\\partial w_2} (C_2+C_L) + (R_d+R_1+R_2) \\frac{\\partial (C_2+C_L)}{\\partial w_2}$$\n$$\\frac{\\partial T_d}{\\partial w_2} = \\left( -\\frac{R_2}{w_2} \\right) (C_2+C_L) + (R_d+R_1+R_2) (k L_2)$$\n重新整理各项：\n$$\\frac{\\partial T_d}{\\partial w_2} = (R_d + R_1 + R_2)k L_2 - \\frac{R_2}{w_2}(C_2 + C_L)$$\n\n### 数值计算与验证\n首先，我们计算在标称宽度下 $R_1, R_2, C_1, C_2$ 的值。所有单位均为国际单位制。\n$R_1 = (0.05) \\frac{2.0 \\times 10^{-3}}{0.9 \\times 10^{-6}} = \\frac{1000}{9} \\Omega \\approx 111.111\\,\\Omega$\n$R_2 = (0.05) \\frac{1.5 \\times 10^{-3}}{1.2 \\times 10^{-6}} = 62.5\\,\\Omega$\n$C_1 = (2.5 \\times 10^{-10} + (2.0 \\times 10^{-4})(0.9 \\times 10^{-6})) (2.0 \\times 10^{-3}) = (4.3 \\times 10^{-10})(2.0 \\times 10^{-3}) = 8.6 \\times 10^{-13}\\,\\text{F}$\n$C_2 = (2.5 \\times 10^{-10} + (2.0 \\times 10^{-4})(1.2 \\times 10^{-6})) (1.5 \\times 10^{-3}) = (4.9 \\times 10^{-10})(1.5 \\times 10^{-3}) = 7.35 \\times 10^{-13}\\,\\text{F}$\n\n**解析梯度值：**\n对于 $\\frac{\\partial T_d}{\\partial w_1}$：\n$R_d+R_1 = 120 + \\frac{1000}{9} = \\frac{2080}{9}\\,\\Omega$\n$kL_1 = (2.0 \\times 10^{-4})(2.0 \\times 10^{-3}) = 4.0 \\times 10^{-7}\\,\\text{F/m}$\n$\\frac{R_1}{w_1} = \\frac{1000/9}{0.9 \\times 10^{-6}} = \\frac{10^9}{8.1}\\,\\Omega/\\text{m}$\n$C_1+C_2+C_L = (8.6 + 7.35 + 4.0) \\times 10^{-13} = 1.995 \\times 10^{-12}\\,\\text{F}$\n$\\frac{\\partial T_d}{\\partial w_1} = \\left(\\frac{2080}{9}\\right)(4.0 \\times 10^{-7}) - \\left(\\frac{10^9}{8.1}\\right)(1.995 \\times 10^{-12}) = 9.2444... \\times 10^{-5} - 2.46296... \\times 10^{-4} = -1.53852... \\times 10^{-4}\\,\\text{s/m}$\n\n对于 $\\frac{\\partial T_d}{\\partial w_2}$：\n$R_d+R_1+R_2 = 120 + \\frac{1000}{9} + 62.5 = \\frac{2642.5}{9}\\,\\Omega$\n$kL_2 = (2.0 \\times 10^{-4})(1.5 \\times 10^{-3}) = 3.0 \\times 10^{-7}\\,\\text{F/m}$\n$\\frac{R_2}{w_2} = \\frac{62.5}{1.2 \\times 10^{-6}}\\,\\Omega/\\text{m}$\n$C_2+C_L = (7.35 + 4.0) \\times 10^{-13} = 1.135 \\times 10^{-12}\\,\\text{F}$\n$\\frac{\\partial T_d}{\\partial w_2} = \\left(\\frac{2642.5}{9}\\right)(3.0 \\times 10^{-7}) - \\left(\\frac{62.5}{1.2 \\times 10^{-6}}\\right)(1.135 \\times 10^{-12}) = 8.80833... \\times 10^{-5} - 5.91145... \\times 10^{-5} = 2.89687... \\times 10^{-5}\\,\\text{s/m}$\n\n**有限差分验证：**\n中心有限差分近似为 $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$。\n对于 $\\frac{\\partial T_d}{\\partial w_1}$，$h = \\delta w_1 = 0.01 \\times (0.9 \\times 10^{-6}) = 9 \\times 10^{-9}\\,\\text{m}$。\n$w_1^{\\pm} = w_1 \\pm \\delta w_1 = (0.9 \\pm 0.009) \\times 10^{-6}\\,\\text{m}$。\n$T_d(w_1 + \\delta w_1, w_2) \\approx 5.30637 \\times 10^{-10}\\,\\text{s}$\n$T_d(w_1 - \\delta w_1, w_2) \\approx 5.33417 \\times 10^{-10}\\,\\text{s}$\n$\\left.\\frac{\\partial T_d}{\\partial w_1}\\right|_{\\text{FD}} = \\frac{5.30637 \\times 10^{-10} - 5.33417 \\times 10^{-10}}{2 \\times 9 \\times 10^{-9}} = -1.5444... \\times 10^{-4}\\,\\text{s/m}$\n$\\frac{\\partial T_d}{\\partial w_1}$ 的相对误差：$| \\frac{-1.5444 \\times 10^{-4} - (-1.5385 \\times 10^{-4})}{-1.5385 \\times 10^{-4}} | \\approx 0.0038 \\text{ 或 } 0.38\\%$。\n\n对于 $\\frac{\\partial T_d}{\\partial w_2}$，$h = \\delta w_2 = 0.01 \\times (1.2 \\times 10^{-6}) = 1.2 \\times 10^{-8}\\,\\text{m}$。\n$w_2^{\\pm} = w_2 \\pm \\delta w_2 = (1.2 \\pm 0.012) \\times 10^{-6}\\,\\text{m}$。\n$T_d(w_1, w_2 + \\delta w_2) \\approx 5.32362 \\times 10^{-10}\\,\\text{s}$\n$T_d(w_1, w_2 - \\delta w_2) \\approx 5.31671 \\times 10^{-10}\\,\\text{s}$\n$\\left.\\frac{\\partial T_d}{\\partial w_2}\\right|_{\\text{FD}} = \\frac{5.32362 \\times 10^{-10} - 5.31671 \\times 10^{-10}}{2 \\times 1.2 \\times 10^{-8}} = 2.879... \\times 10^{-5}\\,\\text{s/m}$\n$\\frac{\\partial T_d}{\\partial w_2}$ 的相对误差：$| \\frac{2.879 \\times 10^{-5} - 2.897 \\times 10^{-5}}{2.897 \\times 10^{-5}} | \\approx 0.0062 \\text{ 或 } 0.62\\%$。\n较小的相对误差验证了解析梯度表达式的正确性。\n\n### 最终答案计算\n问题要求将最终梯度分量四舍五入至四位有效数字。\n$\\frac{\\partial T_d}{\\partial w_1} = -1.53852... \\times 10^{-4}\\,\\text{s/m} \\approx -1.539 \\times 10^{-4}\\,\\text{s/m}$\n$\\frac{\\partial T_d}{\\partial w_2} = 2.89687... \\times 10^{-5}\\,\\text{s/m} \\approx 2.897 \\times 10^{-5}\\,\\text{s/m}$\n\n最终答案以梯度分量的行矩阵形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-1.539 \\times 10^{-4} & 2.897 \\times 10^{-5}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论上的优化必须转化为能够应对真实制造约束的实用算法。本练习将带您实现投影梯度下降算法的核心步骤，这是一种处理诸如最小/最大导线宽度等“盒约束”（$w_{\\min} \\le w_i \\le w_{\\max}$）的标准方法。通过将该算法应用于一系列测试案例，您将亲身体验优化算法如何在受限的设计空间中进行迭代，从而将数学理论与EDA工具中的计算实现联系起来。",
            "id": "4308231",
            "problem": "考虑在集成电路的电子设计自动化（EDA）背景下的约束线宽优化问题。一个线宽向量 $w \\in \\mathbb{R}^n$ 的每个分量 $w_i$ 都受到设计规则边界 $w_{\\min} \\le w_i \\le w_{\\max}$ 的约束。假设给定一个可微的目标函数 $J(w)$，它为一个性能指标（如延迟或功耗）建模，以及它在当前迭代点 $w^{(k)}$ 处的梯度 $\\nabla J(w)$。您将使用给定的正步长 $\\alpha$ 执行一次投影梯度法迭代，其中使用欧几里得投影将点投影到由边界定义的可行盒上。\n\n从以下基本基础开始：\n- 无约束梯度下降步将 $w$ 更新为 $w^{(k)} - \\alpha \\nabla J(w^{(k)})$，其中 $\\alpha$ 为正步长。\n- 针对盒约束的投影梯度步将欧几里得投影 $\\Pi_{\\mathcal{B}}(\\cdot)$ 应用于无约束更新之上，投影到可行集 $\\mathcal{B} = \\{x \\in \\mathbb{R}^n \\mid w_{\\min} \\le x_i \\le w_{\\max} \\text{ for all } i\\}$，即 $w^{(k+1)} = \\Pi_{\\mathcal{B}}\\!\\left(w^{(k)} - \\alpha \\nabla J(w^{(k)})\\right)$。\n- 一个点 $y \\in \\mathbb{R}^n$ 到一个闭凸集 $\\mathcal{C}$ 上的欧几里得投影定义为 $\\Pi_{\\mathcal{C}}(y) = \\arg\\min_{x \\in \\mathcal{C}} \\|x - y\\|_2$。\n\n任务：在给定当前线宽 $w^{(k)}$、梯度 $g = \\nabla J(w^{(k)})$、步长 $\\alpha$ 和盒边界的情况下，实现单次投影梯度更新 $w^{(k+1)}$。将投影视为到盒上的欧几里得投影。边界可以指定为标量（所有分量相同）或向量（分量级边界 $w_{\\min,i}$ 和 $w_{\\max,i}$）。所有线宽 $w_i$、下界 $w_{\\min}$ 和上界 $w_{\\max}$ 的单位均为微米。步长 $\\alpha$ 必须为正，且 $\\alpha \\, g_i$ 的单位为微米。以微米为单位表示更新后线宽 $w^{(k+1)}$ 的每个分量，并四舍五入到6位小数。\n\n测试套件：\n对于下面的每个测试用例，计算一次投影梯度步后的 $w^{(k+1)}$。请完全按照给定的参数进行计算。在所有情况下，以微米为单位报告结果线宽。\n\n- 测试用例 1：\n  - $w^{(k)} = [\\,0.8,\\, 1.2,\\, 0.5\\,]$\n  - $g = [\\,0.3,\\, -0.5,\\, 2.0\\,]$\n  - $\\alpha = 0.1$\n  - $w_{\\min} = 0.4$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 2：\n  - $w^{(k)} = [\\,1.9,\\, 1.95\\,]$\n  - $g = [\\,-5.0,\\, -1.0\\,]$\n  - $\\alpha = 0.05$\n  - $w_{\\min} = 0.5$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 3：\n  - $w^{(k)} = [\\,0.5,\\, 0.6,\\, 0.7\\,]$\n  - $g = [\\,10.0,\\, 0.0,\\, -3.0\\,]$\n  - $\\alpha = 0.02$\n  - $w_{\\min} = 0.5$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 4 (分量级边界)：\n  - $w^{(k)} = [\\,0.45,\\, 0.9,\\, 1.8,\\, 0.4\\,]$\n  - $g = [\\,-1.0,\\, 2.0,\\, -5.0,\\, 1.0\\,]$\n  - $\\alpha = 0.1$\n  - $w_{\\min} = [\\,0.4,\\, 0.6,\\, 1.0,\\, 0.45\\,]$\n  - $w_{\\max} = [\\,0.6,\\, 1.5,\\, 1.9,\\, 0.6\\,]$\n\n- 测试用例 5：\n  - $w^{(k)} = [\\,0.4,\\, 2.0\\,]$\n  - $g = [\\,0.0,\\, 0.0\\,]$\n  - $\\alpha = 10.0$\n  - $w_{\\min} = 0.4$\n  - $w_{\\max} = 2.0$\n\n- 测试用例 6 (数值边缘压力测试)：\n  - $w^{(k)} = [\\,10^{-3},\\, 10^{3}\\,]$\n  - $g = [\\,10^{-9},\\, -10^{-9}\\,]$\n  - $\\alpha = 10^{6}$\n  - $w_{\\min} = 0.0$\n  - $w_{\\max} = 1000.0$\n\n您的程序必须为每个测试用例实现投影梯度更新，并以微米为单位输出四舍五入到6位小数的更新后线宽。最终输出格式：您的程序应生成单行输出，其中包含一个由逗号分隔的列表组成的列表，用方括号括起来且不含空格（例如，$[[a_{11},a_{12}],\\,[a_{21},a_{22}]]$）。每个内部列表对应一个测试用例的更新后线宽，顺序与提供的一致。输出中的所有数字必须恰好有6位小数，单位为微米。",
            "solution": "所提出的问题是约束优化的一个明确定义的实例，具体而言，是将投影梯度下降法应用于集成电路设计中的线宽尺寸调整问题。目标是在给定当前迭代点 $w^{(k)}$、成本函数的梯度 $g = \\nabla J(w^{(k)})$、步长 $\\alpha$ 以及盒约束 $w_{\\min} \\le w_i \\le w_{\\max}$ 的情况下，计算线宽的单次更新迭代 $w^{(k+1)}$。\n\n投影梯度下降法是一种用于解决形如 $\\min_{w \\in \\mathcal{B}} J(w)$ 的约束优化问题的迭代算法，其中 $\\mathcal{B}$ 是一个闭凸集。其更新规则由下式给出：\n$$\nw^{(k+1)} = \\Pi_{\\mathcal{B}}\\!\\left(w^{(k)} - \\alpha g\\right)\n$$\n其中 $\\Pi_{\\mathcal{B}}(y)$ 是点 $y$ 到集合 $\\mathcal{B}$ 上的欧几里得投影。此操作寻找在欧几里得范数意义上 $\\mathcal{B}$ 中离 $y$ 最近的点。该过程可以分解为两个基本步骤：\n\n1.  **无约束梯度步**：首先，执行一个标准的梯度下降步来找到一个中间点，我们将其表示为 $y$。该点最小化了 $J(w)$ 在 $w^{(k)}$ 周围的一阶泰勒近似，而不考虑约束。\n    $$\n    y = w^{(k)} - \\alpha g\n    $$\n    此处，$w^{(k)}$ 是当前线宽向量，$g$ 是梯度向量 $\\nabla J(w^{(k)})$，$\\alpha > 0$ 是学习率或步长。\n\n2.  **投影步**：中间点 $y$ 可能位于可行集 $\\mathcal{B}$ 之外。投影步将此点映射回 $\\mathcal{B}$ 内最近的点。在此问题中，可行集是一个由分量级约束定义的超矩形（或‘盒’）：\n    $$\n    \\mathcal{B} = \\{x \\in \\mathbb{R}^n \\mid w_{\\min,i} \\le x_i \\le w_{\\max,i} \\text{ for } i=1, \\dots, n\\}\n    $$\n    投影到盒上的一个关键性质是其可分离性。这意味着向量 $y$ 的投影可以通过将其每个分量 $y_i$ 独立地投影到相应的一维区间 $[w_{\\min,i}, w_{\\max,i}]$ 上来计算。单个分量 $y_i$ 的投影是区间 $[w_{\\min,i}, w_{\\max,i}]$ 中离 $y_i$ 最近的值。这可以通过一个简单的裁剪或钳位操作来表示：\n    $$\n    (\\Pi_{\\mathcal{B}}(y))_i = \\begin{cases}\n        w_{\\min,i}  & \\text{if } y_i < w_{\\min,i} \\\\\n        y_i  & \\text{if } w_{\\min,i} \\le y_i \\le w_{\\max,i} \\\\\n        w_{\\max,i}  & \\text{if } y_i > w_{\\max,i}\n    \\end{cases}\n    $$\n    这等价于表达式 $w^{(k+1)}_i = \\max(w_{\\min,i}, \\min(y_i, w_{\\max,i}))$。\n\n每个测试用例的总体算法如下：\n1.  给定向量 $w^{(k)}$ 和 $g$，以及标量 $\\alpha$、$w_{\\min}$、$w_{\\max}$（或向量 $w_{\\min}$、$w_{\\max}$）。\n2.  如果边界 $w_{\\min}$ 和 $w_{\\max}$ 以标量形式提供，则将它们视为每个分量都等于相应标量的向量。\n3.  计算每个分量 $i$ 的无约束更新：$y_i = w^{(k)}_i - \\alpha g_i$。\n4.  计算每个分量 $i$ 的投影更新：$w^{(k+1)}_i = \\max(w_{\\min,i}, \\min(y_i, w_{\\max,i}))$。\n5.  将得到的分量收集到最终向量 $w^{(k+1)}$ 中。\n\n作为一个说明性示例，让我们将其应用于测试用例 1：\n- 给定：$w^{(k)} = [\\,0.8,\\, 1.2,\\, 0.5\\,]$, $g = [\\,0.3,\\, -0.5,\\, 2.0\\,]$, $\\alpha = 0.1$, $w_{\\min} = 0.4$, $w_{\\max} = 2.0$。\n- 步骤 1：计算无约束更新向量 $y$。\n  $$\n  y = [\\,0.8,\\, 1.2,\\, 0.5\\,] - 0.1 \\times [\\,0.3,\\, -0.5,\\, 2.0\\,] = [\\,0.8,\\, 1.2,\\, 0.5\\,] - [\\,0.03,\\, -0.05,\\, 0.2\\,] = [\\,0.77,\\, 1.25,\\, 0.3\\,]\n  $$\n- 步骤 2：将 $y$ 投影到对所有分量都由 $[0.4, 2.0]$ 定义的盒上。\n  - $w^{(k+1)}_1$：$y_1 = 0.77$。因为 $0.4 \\le 0.77 \\le 2.0$，所以 $w^{(k+1)}_1 = 0.77$。\n  - $w^{(k+1)}_2$：$y_2 = 1.25$。因为 $0.4 \\le 1.25 \\le 2.0$，所以 $w^{(k+1)}_2 = 1.25$。\n  - $w^{(k+1)}_3$：$y_3 = 0.3$。因为 $0.3  0.4$，所以 $w^{(k+1)}_3$ 被钳位到下界，即 $w^{(k+1)}_3 = 0.4$。\n- 得到的更新后线宽向量为 $w^{(k+1)} = [\\,0.77,\\, 1.25,\\, 0.4\\,]$。然后将每个分量格式化为六位小数以用于最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the projected gradient descent problem for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"w_k\": [0.8, 1.2, 0.5],\n            \"g\": [0.3, -0.5, 2.0],\n            \"alpha\": 0.1,\n            \"w_min\": 0.4,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [1.9, 1.95],\n            \"g\": [-5.0, -1.0],\n            \"alpha\": 0.05,\n            \"w_min\": 0.5,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [0.5, 0.6, 0.7],\n            \"g\": [10.0, 0.0, -3.0],\n            \"alpha\": 0.02,\n            \"w_min\": 0.5,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [0.45, 0.9, 1.8, 0.4],\n            \"g\": [-1.0, 2.0, -5.0, 1.0],\n            \"alpha\": 0.1,\n            \"w_min\": [0.4, 0.6, 1.0, 0.45],\n            \"w_max\": [0.6, 1.5, 1.9, 0.6]\n        },\n        {\n            \"w_k\": [0.4, 2.0],\n            \"g\": [0.0, 0.0],\n            \"alpha\": 10.0,\n            \"w_min\": 0.4,\n            \"w_max\": 2.0\n        },\n        {\n            \"w_k\": [1e-3, 1e3],\n            \"g\": [1e-9, -1e-9],\n            \"alpha\": 1e6,\n            \"w_min\": 0.0,\n            \"w_max\": 1000.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w_k = np.array(case[\"w_k\"], dtype=float)\n        g = np.array(case[\"g\"], dtype=float)\n        alpha = float(case[\"alpha\"])\n        w_min = case[\"w_min\"]\n        w_max = case[\"w_max\"]\n\n        # Step 1: Perform the unconstrained gradient descent step.\n        y = w_k - alpha * g\n\n        # Step 2: Project the result onto the feasible box.\n        # np.clip is the direct implementation of the projection onto a box.\n        # It handles both scalar and array-like bounds correctly.\n        w_k_plus_1 = np.clip(y, w_min, w_max)\n        \n        results.append(w_k_plus_1)\n\n    # Format the final output string according to the specified format.\n    # Each number must have exactly 6 decimal places.\n    # The final string should have no spaces.\n    formatted_results = []\n    for res_array in results:\n        # Format each number to have 6 decimal places.\n        formatted_list = [f'{x:.6f}' for x in res_array]\n        # Create the string for the inner list, e.g., \"[0.100000,0.200000]\"\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    # join the inner list strings into the final output format, e.g., \"[[...],[...]]\"\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}