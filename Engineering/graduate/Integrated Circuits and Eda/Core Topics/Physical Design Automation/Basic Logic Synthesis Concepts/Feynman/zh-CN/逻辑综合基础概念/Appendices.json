{
    "hands_on_practices": [
        {
            "introduction": "现代逻辑综合依赖于规范且可扩展的数据结构，其中与非逆变器图（And-Inverter Graph, AIG）是最核心的一种。在AIG上，复杂的逻辑优化过程通常被分解为一系列的局部重写（rewrite）操作。本练习  将让你亲手实践两种基本的重写技术——代数分解（algebraic factoring）和关联平衡（associative balancing），并量化这些变换对电路成本（以节点数 $N$ 衡量）和性能（以逻辑深度 $D$ 衡量）的影响。通过这个过程，你将对综合工具如何迭代地改进电路设计获得一个具体的认识。",
            "id": "4257773",
            "problem": "在电子设计自动化（EDA）的背景下，考虑一个表示为与门-反相器图（AIG）的单输出布尔网络。AIG是一个有向无环图，其内部节点是双输入逻辑与（AND），边可以被反相以表示逻辑非（NOT）。该网络有主输入 $\\{x,y,z,u,v,w,t\\}$ 和输出 $Y$，由以下未优化的布尔表达式定义\n$$\nY = \\big((x \\wedge y) \\vee (x \\wedge z)\\big) \\wedge \\big(((u \\wedge v) \\wedge w) \\wedge t\\big).\n$$\nAIG实现仅使用与门节点和反相边，析取通过德摩根定律实现，即 $p \\vee q = \\neg(\\neg p \\wedge \\neg q)$。将AIG的节点数 $N$ 定义为双输入与门节点的总数。将逻辑深度 $D$ 定义为从任何主输入到输出的最长有向路径的长度（以与门节点数量计），其中反相边不增加深度。\n\n给定以下重写序列：\n- 重写 $R_{1}$ （代数因式分解）：对左子表达式应用分配律，将 $\\big((x \\wedge y) \\vee (x \\wedge z)\\big)$ 转换为 $x \\wedge (y \\vee z)$。\n- 重写 $R_{2}$ （结合律平衡）：对右子表达式应用结合律，将 $\\big(((u \\wedge v) \\wedge w) \\wedge t\\big)$ 转换为 $\\big((u \\wedge v) \\wedge (w \\wedge t)\\big)$。\n\n假设每次重写按指定顺序 $R_{1}$ 后跟 $R_{2}$ 精确应用一次，并且最终的AIG是在可能的情况下通过对相同子图进行结构哈希获得的，但除了这些重写之外不引入额外的逻辑。对网络使用以下成本模型：\n$$\nC = \\alpha N + \\beta D,\n$$\n其中 $\\alpha = 3$ 且 $\\beta = 5$，而 $N$ 和 $D$ 分别是最终重写后AIG的节点数和逻辑深度。\n\n从布尔代数的第一性原理和上述AIG定义出发，推导出初始未优化AIG的 $N$ 和 $D$，推导出应用 $R_{1}$ 和 $R_{2}$ 后的 $N$ 和 $D$，然后计算成本降低\n$$\n\\Delta C = C_{\\text{initial}} - C_{\\text{final}}.\n$$\n将您的最终答案表示为单个实数。无需四舍五入。",
            "solution": "目标是计算表示为与门-反相器图（AIG）的布尔网络的成本降低 $\\Delta C = C_{\\text{initial}} - C_{\\text{final}}$。成本 $C$ 是AIG节点数 $N$ 和逻辑深度 $D$ 的函数，由 $C = \\alpha N + \\beta D$ 给出，其中 $\\alpha=3$ 且 $\\beta=5$。\n\n首先，我们分析初始的、未优化的AIG以确定其成本 $C_{\\text{initial}}$。初始的布尔表达式为\n$$\nY = \\big((x \\wedge y) \\vee (x \\wedge z)\\big) \\wedge \\big(((u \\wedge v) \\wedge w) \\wedge t\\big)\n$$\n我们通过将每个双输入与门操作表示为一个节点，并使用德摩根定律 $p \\vee q = \\neg(\\neg p \\wedge \\neg q)$ 来实现析取，从而构建AIG。\n\n让我们分解初始表达式。\n左子表达式为 $L = (x \\wedge y) \\vee (x \\wedge z)$。\n令 $n_1 = x \\wedge y$。这是一个与门节点。\n令 $n_2 = x \\wedge z$。这是第二个与门节点。\n$L$ 的表达式变为 $n_1 \\vee n_2$。使用德摩根定律，这等价于 $\\neg(\\neg n_1 \\wedge \\neg n_2)$。\n令 $n_3 = \\neg n_1 \\wedge \\neg n_2$。这是第三个与门节点，其输入是 $n_1$ 和 $n_2$ 的反相输出。\n因此，子表达式 $L$ 由节点 $n_3$ 的反相输出表示。\n$L$ 的AIG需要3个与门节点：$\\{n_1, n_2, n_3\\}$。\n\n右子表达式是 $R = ((u \\wedge v) \\wedge w) \\wedge t$。这是一个左结合的与运算链。\n令 $n_4 = u \\wedge v$。这是第四个与门节点。\n令 $n_5 = n_4 \\wedge w$。这是第五个与门节点。\n令 $n_6 = n_5 \\wedge t$。这是第六个与门节点。\n子表达式 $R$ 是节点 $n_6$ 的输出。\n$R$ 的AIG需要3个与门节点：$\\{n_4, n_5, n_6\\}$。\n\n最后，总表达式为 $Y = L \\wedge R = (\\neg n_3) \\wedge n_6$。\n这需要第七个与门节点，$n_7 = (\\neg n_3) \\wedge n_6$。\n$L$ 和 $R$ 的子电路的输入是不相交的，因此它们之间不可能进行结构哈希。因此，初始总节点数是各部分节点数之和。\n$$\nN_{\\text{initial}} = 3 + 3 + 1 = 7\n$$\n\n接下来，我们确定初始逻辑深度 $D_{\\text{initial}}$。深度是从任何主输入到输出的最长与门节点路径的长度。主输入的深度为 $0$。反相边不增加深度。\n$L$ 中节点的深度：\n$\\text{depth}(n_1) = \\max(\\text{depth}(x), \\text{depth}(y)) + 1 = \\max(0, 0) + 1 = 1$。\n$\\text{depth}(n_2) = \\max(\\text{depth}(x), \\text{depth}(z)) + 1 = \\max(0, 0) + 1 = 1$。\n$\\text{depth}(n_3) = \\max(\\text{depth}(n_1), \\text{depth}(n_2)) + 1 = \\max(1, 1) + 1 = 2$。\n$L$ 的输出深度为 $2$。\n\n$R$ 中节点的深度：\n$\\text{depth}(n_4) = \\max(\\text{depth}(u), \\text{depth}(v)) + 1 = 1$。\n$\\text{depth}(n_5) = \\text{depth}(n_4) + 1 = 1 + 1 = 2$。\n$\\text{depth}(n_6) = \\text{depth}(n_5) + 1 = 2 + 1 = 3$。\n$R$ 的输出深度为 $3$。\n\n最终的输出深度为：\n$D_{\\text{initial}} = \\text{depth}(n_7) = \\max(\\text{depth}(n_3), \\text{depth}(n_6)) + 1 = \\max(2, 3) + 1 = 4$。\n\n初始成本为：\n$C_{\\text{initial}} = \\alpha N_{\\text{initial}} + \\beta D_{\\text{initial}} = (3)(7) + (5)(4) = 21 + 20 = 41$。\n\n现在，我们分析应用重写 $R_1$ 和 $R_2$ 后的最终AIG。\n重写 $R_1$ 将 $(x \\wedge y) \\vee (x \\wedge z)$ 转换为 $x \\wedge (y \\vee z)$。\n重写 $R_2$ 将 $((u \\wedge v) \\wedge w) \\wedge t$ 转换为 $(u \\wedge v) \\wedge (w \\wedge t)$。\n最终的布尔表达式为：\n$$\nY = \\big(x \\wedge (y \\vee z)\\big) \\wedge \\big((u \\wedge v) \\wedge (w \\wedge t)\\big)\n$$\n让我们分解这个重写后的表达式。\n新的左子表达式是 $L' = x \\wedge (y \\vee z)$。\n首先，我们实现 $y \\vee z = \\neg(\\neg y \\wedge \\neg z)$。\n令 $n'_1 = \\neg y \\wedge \\neg z$。这是一个与门节点。\n$y \\vee z$ 的表达式是 $\\neg n'_1$。\n然后，$L' = x \\wedge (\\neg n'_1)$。令 $n'_2 = x \\wedge (\\neg n'_1)$。这是第二个与门节点。\n$L'$ 的AIG需要2个与门节点：$\\{n'_1, n'_2\\}$。\n\n新的右子表达式是 $R' = (u \\wedge v) \\wedge (w \\wedge t)$。这是一个平衡结构。\n令 $n'_3 = u \\wedge v$。这是第三个与门节点。\n令 $n'_4 = w \\wedge t$。这是第四个与门节点。\n然后，$R' = n'_3 \\wedge n'_4$。令 $n'_5 = n'_3 \\wedge n'_4$。这是第五个与门节点。\n$R'$ 的AIG需要3个与门节点：$\\{n'_3, n'_4, n'_5\\}$。\n\n最终表达式为 $Y = L' \\wedge R' = n'_2 \\wedge n'_5$。\n这需要第六个与门节点，$n'_6 = n'_2 \\wedge n'_5$。\n没有两个子图是相同的，所以结构哈希不会进一步减少节点数。\n最终总节点数为：\n$$\nN_{\\text{final}} = 2 + 3 + 1 = 6\n$$\n\n接下来，我们确定最终逻辑深度 $D_{\\text{final}}$。\n$L'$ 中节点的深度：\n$\\text{depth}(n'_1) = \\max(\\text{depth}(y), \\text{depth}(z)) + 1 = 1$。\n$\\text{depth}(n'_2) = \\max(\\text{depth}(x), \\text{depth}(n'_1)) + 1 = \\max(0, 1) + 1 = 2$。\n$L'$ 的输出深度为 $2$。\n\n$R'$ 中节点的深度：\n$\\text{depth}(n'_3) = \\max(\\text{depth}(u), \\text{depth}(v)) + 1 = 1$。\n$\\text{depth}(n'_4) = \\max(\\text{depth}(w), \\text{depth}(t)) + 1 = 1$。\n$\\text{depth}(n'_5) = \\max(\\text{depth}(n'_3), \\text{depth}(n'_4)) + 1 = \\max(1, 1) + 1 = 2$。\n$R'$ 的输出深度为 $2$。\n\n最终的输出深度为：\n$D_{\\text{final}} = \\text{depth}(n'_6) = \\max(\\text{depth}(n'_2), \\text{depth}(n'_5)) + 1 = \\max(2, 2) + 1 = 3$。\n\n最终成本为：\n$C_{\\text{final}} = \\alpha N_{\\text{final}} + \\beta D_{\\text{final}} = (3)(6) + (5)(3) = 18 + 15 = 33$。\n\n最后，我们计算成本降低 $\\Delta C$：\n$\\Delta C = C_{\\text{initial}} - C_{\\text{final}} = 41 - 33 = 8$。\n该重写序列将与门节点的数量从7个减少到6个，将逻辑深度从4减少到3，从而实现了成本降低。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "在对电路结构进行优化之后，下一个关键步骤是验证其是否满足性能目标，即时序要求。静态时序分析（Static Timing Analysis, STA）是完成此项任务的工业标准方法，它无需进行耗时的动态仿真即可精确评估电路的延迟。本练习  将引导你完成一次完整的STA计算，通过基本的正向传播计算到达时间（arrival time）和反向传播计算需求时间（required time），最终确定每个节点的时序裕量（slack）并识别出决定电路最高工作频率的关键路径（critical path）。",
            "id": "4257797",
            "problem": "在集成电路的电子设计自动化（EDA）中，静态时序分析（STA）将组合逻辑网络建模为一个有向无环图（DAG），其顶点代表引脚和单元，其边代表带延迟的信号传播。时序裕量（slack）是使用前向到达时间和反向需求时间的概念来定义的，这两个概念源于DAG上到达时间的最大延迟累积和需求时间的最小允许时间的基本定义。考虑以下由逻辑门组成的映射网络，其具有引脚相关的单元延迟和互连延迟。所有时间量都必须视为实值，并在适用时明确使用纳秒 $(\\mathrm{ns})$ 作为单位。\n\n具有指定到达时间的主输入：\n- $A$：$0\\,\\mathrm{ns}$，\n- $B$：$0\\,\\mathrm{ns}$，\n- $C$：$0.5\\,\\mathrm{ns}$。\n\n单元库引脚到输出的延迟：\n- 双输入与非门 $G_{\\mathrm{NAND2}}$：$A\\rightarrow Y$ 延迟 $0.20\\,\\mathrm{ns}$，$B\\rightarrow Y$ 延迟 $0.15\\,\\mathrm{ns}$。\n- 双输入或非门 $G_{\\mathrm{NOR2}}$：$A\\rightarrow Y$ 延迟 $0.25\\,\\mathrm{ns}$，$B\\rightarrow Y$ 延迟 $0.20\\,\\mathrm{ns}$。\n- 反相器 $G_{\\mathrm{INV}}$：$X\\rightarrow Y$ 延迟 $0.10\\,\\mathrm{ns}$。\n\n网络拓扑（单元实例和连接）：\n- $N1$：$G_{\\mathrm{NAND2}}$，输入由 $A$ 和 $B$ 驱动，输出为 $Y1$。\n- $N2$：$G_{\\mathrm{INV}}$，输入由 $C$ 驱动，输出为 $Y2$。\n- $N3$：$G_{\\mathrm{NOR2}}$，输入 $A$ 引脚由 $Y1$ 驱动，$B$ 引脚由 $Y2$ 驱动，输出为 $O1$。\n- $N4$：$G_{\\mathrm{INV}}$，输入由 $Y1$ 驱动，输出为 $Y4$。\n- $N5$：$G_{\\mathrm{NOR2}}$，输入 $A$ 引脚由 $Y4$ 驱动，$B$ 引脚由 $C$ 驱动，输出为 $O2$。\n\n每条有向连接上的互连（线网）延迟：\n- $A\\rightarrow N1.A$：$0.01\\,\\mathrm{ns}$，\n- $B\\rightarrow N1.B$：$0.01\\,\\mathrm{ns}$，\n- $C\\rightarrow N2.X$：$0.02\\,\\mathrm{ns}$，\n- $Y1\\rightarrow N3.A$：$0.06\\,\\mathrm{ns}$，\n- $Y2\\rightarrow N3.B$：$0.04\\,\\mathrm{ns}$，\n- $Y1\\rightarrow N4.X$：$0.05\\,\\mathrm{ns}$，\n- $Y4\\rightarrow N5.A$：$0.03\\,\\mathrm{ns}$，\n- $C\\rightarrow N5.B$：$0.02\\,\\mathrm{ns}$。\n\n主输出端的宿点需求到达时间：\n- $O1$：$1.20\\,\\mathrm{ns}$，\n- $O2$：$1.00\\,\\mathrm{ns}$。\n\n从到达时间（作为在DAG上向前传播的每个节点的最晚信号时间）和需求时间（作为从宿点向后传播的最早允许时间）的基本定义出发，并将节点的裕量定义为需求时间减去到达时间，完成以下任务：\n- 解释如何基于这些定义，通过拓扑前向和反向遍历来识别组合逻辑映射网络中的时序裕量和关键路径。\n- 计算每个门输出的前向到达时间，以及每个节点（包括主输入 $A$、$B$ 和 $C$）的反向需求时间。\n- 计算每个节点输出和每个主输入的裕量。\n- 根据计算出的到达时间和裕量值，通过推理确定关键路径。\n\n最后，报告网络中所有节点的最小裕量。将最终报告的最小裕量四舍五入到四位有效数字，并以 $\\mathrm{ns}$ 为单位表示该值。",
            "solution": "### 静态时序分析的概念框架\n\n静态时序分析（STA）是一种用于验证数字电路时序性能的方法，无需进行完整的动态仿真。它将电路建模为有向无环图（DAG），其中节点代表逻辑门的引脚或主输入/输出（I/O），边代表具有相关延迟的信号传播路径。STA的核心涉及对该图的两次拓扑遍历：一次前向遍历以计算到达时间，一次反向遍历以计算需求时间。\n\n_到达时间_（$AT$）：一个节点的到达时间是信号转换能够到达该节点的最晚可能时间，考虑了从主输入到该节点的所有可能路径。它是通过从主输入（PI）到主输出（PO）的前向拓扑遍历来计算的。对于任何给定节点 $u$，其到达时间计算为通过其所有扇入节点 $v_i$ 的到达时间的最大值。\n$$AT(u) = \\max_{v_i \\in \\text{fanin}(u)} \\left( AT(v_i) + \\text{delay}(v_i \\rightarrow u) \\right)$$\n$\\text{delay}(v_i \\rightarrow u)$ 项既包含从门 $v_i$ 输出到门 $u$ 输入的互连延迟，也包含门 $u$ 从该特定输入到其输出的内部引脚延迟。对于主输入，到达时间作为初始条件被指定。\n\n_需求时间_（$RT$）：一个节点的需求时间是信号转换可以到达该节点而不导致任何主输出发生时序违例的最晚时间。它是通过从主输出（PO）到主输入（PI）的反向拓扑遍历来计算的。对于任何给定节点 $u$，其需求时间是由其所有扇出节点 $w_j$ 所决定的需求时间的最小值。\n$$RT(u) = \\min_{w_j \\in \\text{fanout}(u)} \\left( RT(w_j) - \\text{delay}(u \\rightarrow w_j) \\right)$$\n$\\text{delay}(u \\rightarrow w_j)$ 项包括门 $w_j$ 的内部延迟和随后的互连延迟。对于主输出，需求时间被指定为外部时序约束。\n\n_裕量_（Slack）：节点 $u$ 的裕量是其需求时间与到达时间之差。\n$$S(u) = RT(u) - AT(u)$$\n裕量代表可用的时序余量。正裕量表示路径比要求快。零或负裕量分别表示路径是关键的或已经违反了时序约束。\n\n_关键路径_（Critical Path）：关键路径是从一个主输入（PI）到一个主输出（PO）的特定节点和边序列，它在整个电路中表现出最小的裕量。该路径决定了设计的最大工作频率。识别关键路径的方法是：找到具有最小裕量的节点（通常是PO），然后向后追溯到PI，在每一步选择导致最大到达时间（“最迟路径”）的扇入路径，并确保该路径也对应于最小需求时间约束。\n\n### 到达时间的计算（前向遍历）\n\n我们从主输入的指定到达时间开始：\n$AT(A) = 0.0\\,\\mathrm{ns}$\n$AT(B) = 0.0\\,\\mathrm{ns}$\n$AT(C) = 0.5\\,\\mathrm{ns}$\n\n我们按拓扑顺序遍历网络：\n1.  **门 $N1$ ($G_{\\mathrm{NAND2}}$)：**\n    -   输入 $N1.A$ 的到达时间：$AT(N1.A) = AT(A) + d(A\\rightarrow N1.A) = 0.0 + 0.01 = 0.01\\,\\mathrm{ns}$。\n    -   输入 $N1.B$ 的到达时间：$AT(N1.B) = AT(B) + d(B\\rightarrow N1.B) = 0.0 + 0.01 = 0.01\\,\\mathrm{ns}$。\n    -   输出 $Y1$ 的到达时间：\n        $AT(Y1) = \\max \\left( AT(N1.A) + d(N1.A \\rightarrow Y1), AT(N1.B) + d(N1.B \\rightarrow Y1) \\right)$\n        $AT(Y1) = \\max \\left( 0.01 + 0.20, 0.01 + 0.15 \\right) = \\max(0.21, 0.16) = 0.21\\,\\mathrm{ns}$。\n\n2.  **门 $N2$ ($G_{\\mathrm{INV}}$)：**\n    -   输入 $N2.X$ 的到达时间：$AT(N2.X) = AT(C) + d(C\\rightarrow N2.X) = 0.5 + 0.02 = 0.52\\,\\mathrm{ns}$。\n    -   输出 $Y2$ 的到达时间：\n        $AT(Y2) = AT(N2.X) + d(N2.X \\rightarrow Y2) = 0.52 + 0.10 = 0.62\\,\\mathrm{ns}$。\n\n3.  **门 $N4$ ($G_{\\mathrm{INV}}$)：**\n    -   输入 $N4.X$ 的到达时间：$AT(N4.X) = AT(Y1) + d(Y1\\rightarrow N4.X) = 0.21 + 0.05 = 0.26\\,\\mathrm{ns}$。\n    -   输出 $Y4$ 的到达时间：\n        $AT(Y4) = AT(N4.X) + d(N4.X \\rightarrow Y4) = 0.26 + 0.10 = 0.36\\,\\mathrm{ns}$。\n\n4.  **门 $N3$ ($G_{\\mathrm{NOR2}}$)：**\n    -   输入 $N3.A$ 的到达时间：$AT(N3.A) = AT(Y1) + d(Y1\\rightarrow N3.A) = 0.21 + 0.06 = 0.27\\,\\mathrm{ns}$。\n    -   输入 $N3.B$ 的到达时间：$AT(N3.B) = AT(Y2) + d(Y2\\rightarrow N3.B) = 0.62 + 0.04 = 0.66\\,\\mathrm{ns}$。\n    -   输出 $O1$ 的到达时间：\n        $AT(O1) = \\max \\left( AT(N3.A) + d(N3.A \\rightarrow O1), AT(N3.B) + d(N3.B \\rightarrow O1) \\right)$\n        $AT(O1) = \\max \\left( 0.27 + 0.25, 0.66 + 0.20 \\right) = \\max(0.52, 0.86) = 0.86\\,\\mathrm{ns}$。\n\n5.  **门 $N5$ ($G_{\\mathrm{NOR2}}$)：**\n    -   输入 $N5.A$ 的到达时间：$AT(N5.A) = AT(Y4) + d(Y4\\rightarrow N5.A) = 0.36 + 0.03 = 0.39\\,\\mathrm{ns}$。\n    -   输入 $N5.B$ 的到达时间：$AT(N5.B) = AT(C) + d(C\\rightarrow N5.B) = 0.5 + 0.02 = 0.52\\,\\mathrm{ns}$。\n    -   输出 $O2$ 的到达时间：\n        $AT(O2) = \\max \\left( AT(N5.A) + d(N5.A \\rightarrow O2), AT(N5.B) + d(N5.B \\rightarrow O2) \\right)$\n        $AT(O2) = \\max \\left( 0.39 + 0.25, 0.52 + 0.20 \\right) = \\max(0.64, 0.72) = 0.72\\,\\mathrm{ns}$。\n\n### 需求时间的计算（反向遍历）\n\n我们从主输出的指定需求时间开始：\n$RT(O1) = 1.20\\,\\mathrm{ns}$\n$RT(O2) = 1.00\\,\\mathrm{ns}$\n\n我们按反向拓扑顺序进行：\n1.  **从 $O1$（$N3$的输出）开始：**\n    -   输入 $N3.A$ 的需求时间：$RT(N3.A) = RT(O1) - d(N3.A \\rightarrow O1) = 1.20 - 0.25 = 0.95\\,\\mathrm{ns}$。\n    -   输入 $N3.B$ 的需求时间：$RT(N3.B) = RT(O1) - d(N3.B \\rightarrow O1) = 1.20 - 0.20 = 1.00\\,\\mathrm{ns}$。\n\n2.  **从 $O2$（$N5$的输出）开始：**\n    -   输入 $N5.A$ 的需求时间：$RT(N5.A) = RT(O2) - d(N5.A \\rightarrow O2) = 1.00 - 0.25 = 0.75\\,\\mathrm{ns}$。\n    -   输入 $N5.B$ 的需求时间：$RT(N5.B) = RT(O2) - d(N5.B \\rightarrow O2) = 1.00 - 0.20 = 0.80\\,\\mathrm{ns}$。\n\n3.  **在节点 $Y4$（$N5.A$ 的输入）：**\n    $RT(Y4) = RT(N5.A) - d(Y4\\rightarrow N5.A) = 0.75 - 0.03 = 0.72\\,\\mathrm{ns}$。\n\n4.  **在节点 $Y2$（$N3.B$ 的输入）：**\n    $RT(Y2) = RT(N3.B) - d(Y2\\rightarrow N3.B) = 1.00 - 0.04 = 0.96\\,\\mathrm{ns}$。\n\n5.  **在节点 $Y1$（$N3.A$ 和 $N4.X$ 的输入）：**\n    -   来自扇出 $N3.A$ 的需求时间：$RT(N3.A) - d(Y1 \\rightarrow N3.A) = 0.95 - 0.06 = 0.89\\,\\mathrm{ns}$。\n    -   输入 $N4.X$ 的需求时间：$RT(N4.X) = RT(Y4) - d(N4.X \\rightarrow Y4) = 0.72 - 0.10 = 0.62\\,\\mathrm{ns}$。\n    -   来自扇出 $N4.X$ 的需求时间：$RT(N4.X) - d(Y1 \\rightarrow N4.X) = 0.62 - 0.05 = 0.57\\,\\mathrm{ns}$。\n    -   $RT(Y1) = \\min(0.89, 0.57) = 0.57\\,\\mathrm{ns}$。\n\n6.  **在主输入 $C$（$N2.X$ 和 $N5.B$ 的输入）：**\n    -   输入 $N2.X$ 的需求时间：$RT(N2.X) = RT(Y2) - d(N2.X \\rightarrow Y2) = 0.96 - 0.10 = 0.86\\,\\mathrm{ns}$。\n    -   来自扇出 $N2.X$ 的需求时间：$RT(N2.X) - d(C \\rightarrow N2.X) = 0.86 - 0.02 = 0.84\\,\\mathrm{ns}$。\n    -   来自扇出 $N5.B$ 的需求时间：$RT(N5.B) - d(C \\rightarrow N5.B) = 0.80 - 0.02 = 0.78\\,\\mathrm{ns}$。\n    -   $RT(C) = \\min(0.84, 0.78) = 0.78\\,\\mathrm{ns}$。\n\n7.  **在主输入 $A$（$N1.A$ 的输入）：**\n    -   输入 $N1.A$ 的需求时间：$RT(N1.A) = RT(Y1) - d(N1.A \\rightarrow Y1) = 0.57 - 0.20 = 0.37\\,\\mathrm{ns}$。\n    -   $RT(A) = RT(N1.A) - d(A \\rightarrow N1.A) = 0.37 - 0.01 = 0.36\\,\\mathrm{ns}$。\n\n8.  **在主输入 $B$（$N1.B$ 的输入）：**\n    -   输入 $N1.B$ 的需求时间：$RT(N1.B) = RT(Y1) - d(N1.B \\rightarrow Y1) = 0.57 - 0.15 = 0.42\\,\\mathrm{ns}$。\n    -   $RT(B) = RT(N1.B) - d(B \\rightarrow N1.B) = 0.42 - 0.01 = 0.41\\,\\mathrm{ns}$。\n\n### 裕量的计算与关键路径的识别\n\n我们计算每个主输入和门输出的裕量 $S = RT - AT$。\n\n-   $S(A) = RT(A) - AT(A) = 0.36 - 0.0 = 0.36\\,\\mathrm{ns}$。\n-   $S(B) = RT(B) - AT(B) = 0.41 - 0.0 = 0.41\\,\\mathrm{ns}$。\n-   $S(C) = RT(C) - AT(C) = 0.78 - 0.5 = 0.28\\,\\mathrm{ns}$。\n-   $S(Y1) = RT(Y1) - AT(Y1) = 0.57 - 0.21 = 0.36\\,\\mathrm{ns}$。\n-   $S(Y2) = RT(Y2) - AT(Y2) = 0.96 - 0.62 = 0.34\\,\\mathrm{ns}$。\n-   $S(Y4) = RT(Y4) - AT(Y4) = 0.72 - 0.36 = 0.36\\,\\mathrm{ns}$。\n-   $S(O1) = RT(O1) - AT(O1) = 1.20 - 0.86 = 0.34\\,\\mathrm{ns}$。\n-   $S(O2) = RT(O2) - AT(O2) = 1.00 - 0.72 = 0.28\\,\\mathrm{ns}$。\n\n所有计算节点中的最小裕量为 $0.28\\,\\mathrm{ns}$。这个值在主输入 $C$ 和主输出 $O2$ 处观察到。因此，关键路径必须连接 $C$ 和 $O2$。\n\n为了确认，我们追踪该路径：\n-   在输出 $O2$ 处，最晚到达时间 $AT(O2) = 0.72\\,\\mathrm{ns}$ 是由通过输入 $N5.B$ 的路径决定的。\n-   $N5.B$ 处的信号源于主输入 $C$。到达时间为 $AT(N5.B) = AT(C) + d(C \\rightarrow N5.B) = 0.5 + 0.02 = 0.52\\,\\mathrm{ns}$。\n-   主输入 $C$ 的需求时间 $RT(C) = 0.78\\,\\mathrm{ns}$ 是由其扇出路径的最小值决定的，即到 $N5.B$ 的路径。\n-   由于最晚到达时间的前向传播和最紧需求时间的反向传播都遵循相同的节点序列，我们可以明确地识别出关键路径。\n\n关键路径是节点和边的序列：$C \\rightarrow (\\text{线网}) \\rightarrow N5.B \\rightarrow (\\text{单元 } N5) \\rightarrow O2$。这条路径上的所有节点都具有 $0.28\\,\\mathrm{ns}$ 的最小裕量。\n\n网络中所有节点的最小裕量为 $0.28\\,\\mathrm{ns}$。题目要求将此值四舍五入到四位有效数字。",
            "answer": "$$\n\\boxed{0.2800}\n$$"
        },
        {
            "introduction": "当组合逻辑优化不足以满足时序约束时，就需要采用时序电路优化技术，而重定时（retiming）是其中最基本且强大的方法之一。重定时通过在组合逻辑块之间重新定位寄存器，来平衡不同时钟周期内的逻辑延迟，从而提高电路的整体时钟频率。本练习  将展示如何将电路的合法性与时序要求转化为一个差分约束系统（system of difference constraints），并利用基于图论的最短路径算法来求解一个可行的重定时方案，这是一种优化同步电路的经典而有效的方法。",
            "id": "4257792",
            "problem": "考虑一个用于集成电路和电子设计自动化（EDA）中基于重定时（retiming）的逻辑综合的同步数据流图。其顶点集为 $V=\\{A,B,C,D\\}$，有向边集为\n$$E=\\{(A,B),(B,C),(C,D),(D,A),(A,C),(B,D)\\}.$$\n每条边 $(u,v)\\in E$ 都有一个关联的非负整数 $w(u,v)$，等于最初放置在该边上的寄存器数量。初始寄存器数量为\n$$w(A,B)=2,\\quad w(B,C)=0,\\quad w(C,D)=0,\\quad w(D,A)=1,\\quad w(A,C)=1,\\quad w(B,D)=1.$$\n重定时是一个函数 $R:V\\rightarrow \\mathbb{Z}$，它在保持同步语义的同时重新安置寄存器。边 $(u,v)$ 上经过重定时后的寄存器数量定义为\n$$w_{r}(u,v)=w(u,v)+R(v)-R(u).$$\n重定时的合法性要求对于所有 $(u,v)\\in E$，都有 $w_{r}(u,v)\\geq 0$。此外，为了满足由时序分析确定的目标时钟要求，要求重定时后在边 $(B,C)$ 和 $(C,D)$ 上至少有一个寄存器，即 $w_{r}(B,C)\\geq 1$ 且 $w_{r}(C,D)\\geq 1$。\n  \n任务：\n- 根据合法性要求，建立关于 $R$ 的差分约束系统，其形式为对所有 $(u,v)\\in E$ 都有 $R(u)-R(v)\\leq w(u,v)$，并包含由 $w_{r}(B,C)\\geq 1$ 和 $w_{r}(C,D)\\geq 1$ 所引申的加强约束。\n- 在约束图上求解相应的最短路径系统，以得出一个满足所有约束的可行重定时 $R$。使用规范构造方法，将每个不等式 $R(u)-R(v)\\leq b$ 映射为一条权重为 $b$ 的有向边 $v\\rightarrow u$，并计算从一个超级源点出发的距离以获得一个可行赋值。\n  \n将最终答案表示为整数重定数值的行矩阵 $(R(A),R(B),R(C),R(D))$。无需四舍五入，答案中不应包含任何单位。",
            "solution": "该问题要求找到一个可行的重定时函数 $R: V \\to \\mathbb{Z}$，其中顶点为 $V=\\{A, B, C, D\\}$。\n\n首先，我们建立差分约束系统。重定时的合法性要求重定时后任何边上的寄存器数量 $w_r(u,v)$ 为非负数。\n一般的合法性约束是 $w_r(u,v) \\geq 0$，等价于 $w(u,v) + R(v) - R(u) \\geq 0$。这可以重写为差分约束：\n$$R(u) - R(v) \\leq w(u,v)$$\n将此应用于 $E$ 中的所有边及其初始权重，得到以下六个不等式：\n1.  对于 $(A,B)$: $R(A) - R(B) \\leq w(A,B) \\implies R(A) - R(B) \\leq 2$\n2.  对于 $(B,C)$: $R(B) - R(C) \\leq w(B,C) \\implies R(B) - R(C) \\leq 0$\n3.  对于 $(C,D)$: $R(C) - R(D) \\leq w(C,D) \\implies R(C) - R(D) \\leq 0$\n4.  对于 $(D,A)$: $R(D) - R(A) \\leq w(D,A) \\implies R(D) - R(A) \\leq 1$\n5.  对于 $(A,C)$: $R(A) - R(C) \\leq w(A,C) \\implies R(A) - R(C) \\leq 1$\n6.  对于 $(B,D)$: $R(B) - R(D) \\leq w(B,D) \\implies R(B) - R(D) \\leq 1$\n\n接下来，我们加入额外的时钟要求。\n-   $w_r(B,C) \\geq 1$:\n    $w(B,C) + R(C) - R(B) \\geq 1 \\implies 0 + R(C) - R(B) \\geq 1 \\implies R(B) - R(C) \\leq -1$。这个约束比原始的合法性约束 $R(B) - R(C) \\leq 0$ 更强，并取代了它。\n-   $w_r(C,D) \\geq 1$:\n    $w(C,D) + R(D) - R(C) \\geq 1 \\implies 0 + R(D) - R(C) \\geq 1 \\implies R(C) - R(D) \\leq -1$。这个约束比原始的合法性约束 $R(C) - R(D) \\leq 0$ 更强，并取代了它。\n\n完整且最终的差分约束系统是：\n1.  $R(A) - R(B) \\leq 2$\n2.  $R(D) - R(A) \\leq 1$\n3.  $R(A) - R(C) \\leq 1$\n4.  $R(B) - R(D) \\leq 1$\n5.  $R(B) - R(C) \\leq -1$\n6.  $R(C) - R(D) \\leq -1$\n\n为了解这个系统，我们构建一个约束图。按照指定，形式为 $R(u) - R(v) \\leq b$ 的不等式对应于一条从 $v$ 到 $u$ 且权重为 $b$ 的有向边。该图的顶点为 $\\{A, B, C, D\\}$。边及其权重如下：\n1.  由 $R(A) - R(B) \\leq 2$ 得：边 $B \\to A$，权重为 $2$。\n2.  由 $R(D) - R(A) \\leq 1$ 得：边 $A \\to D$，权重为 $1$。\n3.  由 $R(A) - R(C) \\leq 1$ 得：边 $C \\to A$，权重为 $1$。\n4.  由 $R(B) - R(D) \\leq 1$ 得：边 $D \\to B$，权重为 $1$。\n5.  由 $R(B) - R(C) \\leq -1$ 得：边 $C \\to B$，权重为 $-1$。\n6.  由 $R(C) - R(D) \\leq -1$ 得：边 $D \\to C$，权重为 $-1$。\n\n我们添加一个超级源点顶点 $S$，以及从 $S$ 到所有其他顶点的权重为零的边：$S \\to A$, $S \\to B$, $S \\to C$, 和 $S \\to D$，权重均为 $0$。这对应于约束 $R(A)-R(S) \\leq 0$, $R(B)-R(S) \\leq 0$, ...，通过设置 $R(S)=0$，意味着我们正在寻找一个对所有 $v \\in V$ 都满足 $R(v) \\leq 0$ 的解。\n\n重定数值的一个可行解由从源点 $S$ 到所有其他顶点的最短路径距离给出，即 $R(v) = \\delta(S, v)$。由于图中包含负权重边，我们必须使用 Bellman-Ford 算法。\n\n令 $d(v)$ 为从 $S$ 到 $v$ 的最短路径距离。\n初始化：$d(S)=0$，对于 $v \\in \\{A, B, C, D\\}$，$d(v)=\\infty$。\n\n迭代 1：\n-   从超级源点 $S$ 开始，我们对到所有其他顶点的边进行松弛操作：\n    $d(A) = \\min(\\infty, d(S)+0) = 0$\n    $d(B) = \\min(\\infty, d(S)+0) = 0$\n    $d(C) = \\min(\\infty, d(S)+0) = 0$\n    $d(D) = \\min(\\infty, d(S)+0) = 0$\n-   现在使用更新后的距离对其他边进行松弛：\n    -   $B \\to A$ (权重 $2$): $d(A) = \\min(0, d(B)+2) = \\min(0, 0+2) = 0$。无变化。\n    -   $A \\to D$ (权重 $1$): $d(D) = \\min(0, d(A)+1) = \\min(0, 0+1) = 0$。无变化。\n    -   $C \\to A$ (权重 $1$): $d(A) = \\min(0, d(C)+1) = \\min(0, 0+1) = 0$。无变化。\n    -   $D \\to B$ (权重 $1$): $d(B) = \\min(0, d(D)+1) = \\min(0, 0+1) = 0$。无变化。\n    -   $C \\to B$ (权重 $-1$): $d(B) = \\min(0, d(C)-1) = \\min(0, 0-1) = -1$。$d(B)$ 更新为 $-1$。\n    -   $D \\to C$ (权重 $-1$): $d(C) = \\min(0, d(D)-1) = \\min(0, 0-1) = -1$。$d(C)$ 更新为 $-1$。\n-   迭代1结束时的距离：$d(A)=0, d(B)=-1, d(C)=-1, d(D)=0$。\n\n迭代 2：\n-   再次用新的距离对所有边进行松弛：\n    -   $B \\to A$ (权重 $2$): $d(A) = \\min(0, d(B)+2) = \\min(0, -1+2) = 0$。无变化。\n    -   $A \\to D$ (权重 $1$): $d(D) = \\min(0, d(A)+1) = \\min(0, 0+1) = 0$。无变化。\n    -   $C \\to A$ (权重 $1$): $d(A) = \\min(0, d(C)+1) = \\min(0, -1+1) = 0$。无变化。\n    -   $D \\to B$ (权重 $1$): $d(B) = \\min(-1, d(D)+1) = \\min(-1, 0+1) = -1$。无变化。\n    -   $C \\to B$ (权重 $-1$): $d(B) = \\min(-1, d(C)-1) = \\min(-1, -1-1) = -2$。$d(B)$ 更新为 $-2$。\n    -   $D \\to C$ (权重 $-1$): $d(C) = \\min(-1, d(D)-1) = \\min(-1, 0-1) = -1$。无变化。\n-   迭代2结束时的距离：$d(A)=0, d(B)=-2, d(C)=-1, d(D)=0$。\n\n迭代 3：\n-   再次对所有边进行松弛：\n    -   $B \\to A$ (权重 $2$): $d(A) = \\min(0, d(B)+2) = \\min(0, -2+2) = 0$。无变化。\n    -   $A \\to D$ (权重 $1$): $d(D) = \\min(0, d(A)+1) = 0$。无变化。\n    -   $C \\to A$ (权重 $1$): $d(A) = \\min(0, d(C)+1) = \\min(0, -1+1) = 0$。无变化。\n    -   $D \\to B$ (权重 $1$): $d(B) = \\min(-2, d(D)+1) = \\min(-2, 0+1) = -2$。无变化。\n    -   $C \\to B$ (权重 $-1$): $d(B) = \\min(-2, d(C)-1) = \\min(-2, -1-1) = -2$。无变化。\n    -   $D \\to C$ (权重 $-1$): $d(C) = \\min(-1, d(D)-1) = \\min(-1, 0-1) = -1$。无变化。\n-   在这次迭代中没有距离被更新。算法已经收敛。\n\n最终的最短路径距离是：\n-   $\\delta(S, A) = 0$\n-   $\\delta(S, B) = -2$\n-   $\\delta(S, C) = -1$\n-   $\\delta(S, D) = 0$\n\n因此，重定数值为：\n-   $R(A) = 0$\n-   $R(B) = -2$\n-   $R(C) = -1$\n-   $R(D) = 0$\n\n让我们根据最终的约束系统来验证这个解：\n1.  $R(A) - R(B) \\leq 2 \\implies 0 - (-2) = 2 \\leq 2$。（满足）\n2.  $R(D) - R(A) \\leq 1 \\implies 0 - 0 = 0 \\leq 1$。（满足）\n3.  $R(A) - R(C) \\leq 1 \\implies 0 - (-1) = 1 \\leq 1$。（满足）\n4.  $R(B) - R(D) \\leq 1 \\implies -2 - 0 = -2 \\leq 1$。（满足）\n5.  $R(B) - R(C) \\leq -1 \\implies -2 - (-1) = -1 \\leq -1$。（满足）\n6.  $R(C) - R(D) \\leq -1 \\implies -1 - 0 = -1 \\leq -1$。（满足）\n所有约束都得到满足，证实了解的有效性。\n\n最终答案是重定数值的行矩阵 $(R(A), R(B), R(C), R(D))$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  -2  -1  0\n\\end{pmatrix}\n}\n$$"
        }
    ]
}