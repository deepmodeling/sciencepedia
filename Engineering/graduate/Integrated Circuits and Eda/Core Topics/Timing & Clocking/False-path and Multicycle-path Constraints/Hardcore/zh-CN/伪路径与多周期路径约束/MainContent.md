## 引言
在现代数字集成电路设计中，静态时序分析（STA）是确保芯片性能达标的基石。然而，自动化工具在进行分析时，往往只依赖电路的拓扑结构，这可能导致对一些功能上永不激活或被有意设计为慢速的路径产生不切实际的时序要求。这种差异是设计意图与工具默认分析之间的核心知识鸿沟，若不加以弥合，将导致大量的虚假时序违例，并严重阻碍设计收敛进程。

本文旨在系统性地阐述如何通过[时序例外](@entry_id:1133190)（timing exceptions）来解决这一问题，重点聚焦于两种最重要、最常见的约束：伪路径（false paths）和[多周期路径](@entry_id:172527)（multicycle paths）。通过学习本文，读者将能够精确地向STA工具传达设计的真实功能行为，从而实现更高效、更可靠的时序分析和优化。

我们将分三个章节展开：
*   **原理与机制**：深入剖析[伪路径](@entry_id:168255)和[多周期路径](@entry_id:172527)的定义，它们与路径敏化的关系，以及用于定义它们的[SDC约束](@entry_id:1131320)命令如何影响[建立和保持时间](@entry_id:167893)检查。
*   **应用与跨学科连接**：探索这些约束在真实工程场景中的应用，例如处理[异步时钟域](@entry_id:1121164)交叉（CDC）、优化[微架构](@entry_id:751960)性能，并揭示其如何连接[物理设计](@entry_id:1129644)、可测试性设计（DFT）和[形式验证](@entry_id:149180)等多个领域。
*   **动手实践**：通过一系列具体的计算和场景分析问题，巩固所学知识，并掌握在复杂情况下精确应用[时序例外](@entry_id:1133190)的技能。

现在，让我们首先进入第一章，深入了解这些关键约束的基本原理与核心机制。

## Principles and Mechanisms

静态时序分析（Static Timing Analysis, STA）是现代数字[集成电路设计流程](@entry_id:1126336)的基石，它通过将电路抽象为[时序图](@entry_id:1133191)来评估性能。然而，一个纯粹基于拓扑的分析可能会对实际上从未被激活或功能上需要多个时钟周期才能完成的路径产生不切实际的定时要求。为了使STA工具能够准确反映设计的真实意图和功能行为，设计者必须提供[时序例外](@entry_id:1133190)（timing exceptions）约束。本章将深入探讨两种最重要、最常见的[时序例外](@entry_id:1133190)：伪路径（false paths）和[多周期路径](@entry_id:172527)（multicycle paths）。我们将阐述其基本原理、定义它们的约束机制，并探讨它们在复杂设计场景中的应用和影响。

### 路径敏化与逻辑[伪路径](@entry_id:168255)

在深入研究[时序例外](@entry_id:1133190)之前，我们必须首先区分电路网表中的**拓扑路径（topological path）**与功能上可行的**可敏化路径（sensitizable path）**。STA工具将[电路建模](@entry_id:263743)为一个[有向无环图](@entry_id:164045)，其中节点（vertices）代表时序点（如寄存器的输入/输出引脚、端口），边（edges）代表它们之间的时序弧（timing arcs），其权重为[信号传播延迟](@entry_id:271898) 。从一个起点（startpoint，如寄存器时钟引脚或主输入端口）到终点（endpoint，如寄存器数据输入引脚或主输出端口）的任何连续时序弧序列都构成一条拓扑路径。

然而，并非所有拓扑路径都能在功能上传播数据转换。一条路径要能传播信号，它必须是**可敏化**的。这意味着，对于路径上的每一个[逻辑门](@entry_id:178011)，其所有不在路径上的“旁路”输入（off-path inputs）都必须被设置为非控制值（例如，与门AND的非控制值为1，[或门](@entry_id:168617)OR的非控制值为0）。对于[多路选择器](@entry_id:172320)（multiplexer, MUX），其[选择信号](@entry_id:894787)必须选择路径所经过的数据输入端 。如果存在至少一组有效的输入激励和可达的电路状态，能够满足路径上所有[逻辑门](@entry_id:178011)的敏化条件，则该路径是可敏化的，或称为**逻辑合法路径**。

与此相对，**逻辑伪路径（logically false path）**是一条在任何有效输入和[可达状态](@entry_id:265999)下都无法被敏化的拓扑路径 。这种路径在物理上存在，但从功能上看，信号变化永远无法沿着它从头到尾传播。一个典型的例子是，一个多路选择器的[选择线](@entry_id:170649)被一个静态的模式控制引脚（mode pin）固定在一个常数值上。例如，假设一个2输入MUX的[选择信号](@entry_id:894787) $S$ 在正常工作模式下恒为0，那么从其输入引脚 `D1` 到输出引脚 `Y` 的路径就是一条逻辑伪路径，因为信号永远无法通过这个分支 。

由于对整个超大规模[集成电路](@entry_id:265543)进行详尽的[布尔可满足性](@entry_id:136675)分析以自动识别所有逻辑伪路径在计算上是不可行的，因此STA工具主要依赖于拓扑分析。这就要求设计者通过时序约束明确地告知STA工具哪些路径是伪路径，以免工具浪费资源去优化这些功能上无意义的路径，或者报告虚假的违规。

### [伪路径](@entry_id:168255)约束及其影响

在Synopsys设计约束（SDC）标准中，`set_false_path` 命令是声明伪路径的主要机制。当设计者应用此约束时，他们实际上是在创建一个**工具声明的[伪路径](@entry_id:168255)（tool-declared false path）**，指示STA工具在进行时序分析时完全忽略指定的路径。

`set_false_path` 命令的根本效果是**彻底地将路径从[时序分析](@entry_id:178997)中移除**。这至关重要的一点是，它不仅消除了对最大延迟的**建立时间（setup）检查**，也同时消除了对最小延迟的**保持时间（hold）检查** 。这个行为是符合逻辑的：如果一条路径功能上无法传播数据，那么讨论数据到达得“太晚”（[建立时间](@entry_id:167213)违规）或“太早”（[保持时间](@entry_id:266567)违规）都失去了意义。未能禁用保持时间检查将是一个严重的错误，因为综合或优化工具可能会错误地插入缓冲器来“修复”一个功能上不存在的路径上的保持时间违规，这会浪费芯片面积和功耗，并可能恶化真实路径的时序。

#### [异步时钟域](@entry_id:1121164)交叉

伪路径约束最关键和最常见的应用场景之一是**[异步时钟域](@entry_id:1121164)交叉（Asynchronous Clock Domain Crossing, CDC）**。当数据从一个由时钟 $C_A$ 驱动的寄存器传递到一个由异步时钟 $C_B$ 驱动的寄存器时，两个时钟之间没有固定或可预测的相位关系。这意味着捕获[时钟沿](@entry_id:171051)相对于数据到达时间的时刻是随机的。

根据[亚稳态](@entry_id:167515)理论，如果数据在捕获寄存器的有效采样时钟沿附近的极小时间窗口（[孔径](@entry_id:172936)时间, aperture time）内发生变化，寄存器就有可能进入[亚稳态](@entry_id:167515)——一种不确定的中间状态。它最终会恢复到稳定状态，但所需的分辨时间 $T_{\mathrm{res}}$ 是一个[随机变量](@entry_id:195330) 。由于异步时钟间的相位关系是随机的，数据变化落入亚稳态窗口的事件是概率上确定会发生的。标准的STA[建立和保持时间](@entry_id:167893)检查是基于确定性的时钟关系，因此它们对于这种概率性事件是无能为力的。任何由STA工具报告的关于异步路径的时序裕量（slack）都是基于工具任意假定的一个相位关系，这在物理上毫无意义。

因此，处理[异步时钟域](@entry_id:1121164)之间的所有路径的正确方法是，将它们声明为伪路径，从而把它们从确定性的建立/[保持时间](@entry_id:266567)分析中排除。这些路径的可靠性必须通过专门的CDC分析工具和方法（如确保使用了正确的[同步器](@entry_id:175850)结构，并计算平均无故障时间MTBF）来保证。在SDC中，声明两个时钟域完全异步的最高效、最明确的方式是使用 `set_clock_groups` 命令：

`set_clock_groups -asynchronous -group {C_A} -group {C_B}`

这个命令是**双向的**，它会切断所有从 $C_A$ 域到 $C_B$ 域的路径，以及所有从 $C_B$ 域到 $C_A$ 域的路径。另一种方法是使用 `set_false_path` 命令：

`set_false_path -from [get_clocks C_A] -to [get_clocks C_B]`
`set_false_path -from [get_clocks C_B] -to [get_clocks C_A]`

与 `set_clock_groups` 不同，`set_false_path` 命令是**单向的**，因此需要两条命令才能完全切断两个方向的路径。通常，`set_clock_groups` 是首选，因为它在语义上更清晰地表达了时钟域之间毫无关联的意图 。

#### 伪路径与电气规则

一个至关重要的概念是，将一条路径声明为时序上的“[伪路径](@entry_id:168255)”，并不意味着它在电气上也是“伪”的。物理连线依然存在，信号依然会在其上传播。因此，即便是伪路径上的[信号网络](@entry_id:754820)，也必须遵守基本的**电气设计规则**，例如**最大转换时间（max transition/slew）**和**最大电容（max capacitance）** 。

*   **最大转换时间**：如果一个信号的边沿（上升或下降）过于缓慢，接收该信号的[逻辑门](@entry_id:178011)的PMOS和NMOS晶体管可能会在一段时间内同时导通，产生巨大的**短路电流**，这不仅会增加功耗，还可能导致可靠性问题。此外，缓慢的信号边沿对[串扰](@entry_id:136295)等噪声也更敏感。
*   **最大电容**：每个逻辑单元的设计都假定其驱动的负载电容在一个特定范围内。如果一个网络的总电容（线电容 + 扇出引脚电容）超过了驱动单元所能承受的最大电容，驱动单元的性能（如延迟和转换时间）将变得不可预测，甚至可能导致功能失效。

以一个跨域信号 $N_{\mathrm{false}}$ 为例，假设其驱动单元的等效[上拉电阻](@entry_id:178010)为 $R_{\mathrm{eq}} = 1.8\ \mathrm{k}\Omega$，总负载电容为 $C_{\mathrm{load}} = 120\ \mathrm{fF}$。使用一阶RC模型估算，其上升时间约为 $t_{\mathrm{rise}} \approx 2.2 \cdot R_{\mathrm{eq}} \cdot C_{\mathrm{load}} = 2.2 \times (1.8 \times 10^3) \times (120 \times 10^{-15}) \approx 0.475\ \mathrm{ns}$。如果工艺库要求最大转换时间 $T_{\mathrm{slew,max}} = 0.20\ \mathrm{ns}$，那么这条“[伪路径](@entry_id:168255)”上的信号已严重违反了电气规则。因此，即便是被 `set_false_path` 约束的路径，也必须通过 `set_max_transition` 和 `set_max_capacitance` 等约束来确保其电气完整性。

#### [伪路径](@entry_id:168255)与异步控制信号

`set_false_path` 主要用于数据路径。对于异步控制信号，如异步复位（reset）或置位（set），它们有自己的时序要求：**恢复时间（recovery time）**和**移除时间（removal time）**。

*   **恢复时间** ($t_{\mathrm{rec}}$)：类似于[建立时间](@entry_id:167213)，它要求[异步信号](@entry_id:746555)在时钟有效沿到来之前，必须保持在非激活状态的最短时间。
*   **移除时间** ($t_{\mathrm{rem}}$)：类似于保持时间，它要求[异步信号](@entry_id:746555)在时钟有效沿到来之后，必须继续保持在激活状态的最短时间。

违反这些要求同样会导致[亚稳态](@entry_id:167515)。使用 `set_false_path` 来压制恢复/移除时间违规是一种错误且危险的做法，因为它掩盖了潜在的物理风险。对于异步复位，正确的处理方式通常是设计一个[复位同步器](@entry_id:1130890)，或者使用更精确的约束，如 `set_disable_timing` 来断开特定的不需要的 timing arcs，而不是将整个路径声明为伪路径 。

### [多周期路径](@entry_id:172527)：功能正确的慢速路径

与功能上无法传播信号的伪路径不同，**[多周期路径](@entry_id:172527)（multicycle path, MCP）**是功能上完全合法，但被**有意设计**为需要超过一个[时钟周期](@entry_id:165839)来完成数据传播的路径。一个典型的例子是，一个复杂的组合逻辑单元（如乘法器）需要较长的计算时间，但其结果并非每个时钟周期都需要，而是由下游的[有限状态机](@entry_id:174162)（FSM）每隔 $M$ 个周期才采样一次。

在这种情况下，默认的单周期时序约束 ($t_{path} \le T_{clk}$) 是不必要的苛刻。设计者可以通过 `set_multicycle_path` 命令来放宽时序要求。

#### [多周期路径](@entry_id:172527)的时序检查

`set_multicycle_path -setup M` 命令告知STA工具，数据有 $M$ 个[时钟周期](@entry_id:165839)的时间来传播。这会改变建立时间的计算方式 。假设发射沿在时刻 $0$，对于单周期路径，捕获沿在时刻 $T_{clk}$。对于 $M$ 周期的[多周期路径](@entry_id:172527)，捕获沿被推迟到时刻 $M \cdot T_{clk}$。因此，建立时间方程变为：

$t_{cq} + d^{\max} \le M \cdot T_{clk} + \phi_C - \phi_L - t_{\mathrm{setup}}$

其中，$t_{cq}$ 是时钟到Q端的延迟，$d^{\max}$ 是组合逻辑最大延迟，$T_{clk}$ 是[时钟周期](@entry_id:165839)，$t_{\mathrm{setup}}$ 是[建立时间](@entry_id:167213)，$\phi_L$ 和 $\phi_C$ 分别是发射和捕获寄存器的时钟到达时间。

然而，修改建立时间检查会带来一个重要的副作用：它会影响默认的[保持时间](@entry_id:266567)检查。当只指定 `-setup M` 时，大多数STA工具的默认行为是将保持时间检查的参考沿移动到建立时间检查参考沿的前一个周期，即第 $M-1$ 周期。这被称为 $m_{\mathrm{hold}} = M-1$ 规则。[保持时间](@entry_id:266567)方程变为：

$t_{cq} + d^{\min} \ge (M-1) \cdot T_{clk} + \phi_C - \phi_L + t_{\mathrm{hold}}$

这个默认的保持时间检查通常是过于悲观的。它要求[最小路径延迟](@entry_id:1127942)必须长到足以跨越 $M-1$ 个时钟周期，这在大多数情况下是不必要的。因此，一个常见且推荐的做法是，在设置多周期[建立时间](@entry_id:167213)的同时，明确地设置保持时间检查周期：

`set_multicycle_path -setup M ...`
`set_multicycle_path -hold 0 ...`

`-hold 0` 选项将保持时间检查移回到其原始位置，即相对于发射沿的第0个周期，这通常是设计意图。

#### [多周期路径](@entry_id:172527)与流水线的权衡

当一条路径的时序不满足单周期要求时，例如，路径延迟 $D = 1.1\ \mathrm{ns}$ 而[时钟周期](@entry_id:165839) $T_{clk} = 1.0\ \mathrm{ns}$，应用多周期约束（例如 $M=2$）可以“合法化”该路径，避免工具进行不必要的[逻辑优化](@entry_id:177444)。然而，这引入了一个系统级的设计权衡 。

使用MCP意味着该路径的有效吞吐率降低为原来的 $1/M$。如果系统要求每个[时钟周期](@entry_id:165839)都有一个有效输出，则可能需要复制整个功能单元以[并行处理](@entry_id:753134)数据，然后交错输出结果，这会带来巨大的面积和功耗开销。

另一种策略是**流水线（pipelining）**，即在长组合逻辑路径中间插入一个或多个寄存器级。这会将长路径分割成多个较短的路径，使每一段都满足单周期时序要求。这种方法保持了每个周期一个输出的吞吐率，但代价是增加了[流水线寄存器](@entry_id:753459)所带来的面积和功耗，以及增加了数据通路的总延迟（latency）。设计者必须根据具体的性能、功耗和面积（PPA）目标来权衡这两种策略。

### 约束的指定与优先级

为了有效地应用这些[时序例外](@entry_id:1133190)，设计者必须精确地指定它们，并理解当多个约束重叠时，它们是如何相互作用的。

#### 约束的指定

SDC提供了灵活的机制来指定路径，例如 `-from`, `-to`, `-through` 选项。
*   `-from` 和 `-to` 可以接受时钟对象、寄存器引脚、端口等，以定义路径的起点和终点。
*   `-through` 指定了路径必须经过的中间点（引脚、端口或网络）。当提供多个 `-through` 参数时，它们构成一个**有序的**检查点序列：路径必须按顺序经过每个 `-through` 集合中指定的对象 。
*   一个常见的错误是试图通过一个控制引脚（如MUX的[选择线](@entry_id:170649)）来约束一条数据路径。数据路径的时序弧不会经过控制引脚，因此这样的 `-through` 约束永远不会匹配任何路径。

对于由静态信号引起的逻辑伪路径，除了`set_false_path`，`set_case_analysis` 是一个更根本的约束。它直接告知工具某个引脚的值是常数。工具会基于此常数进行逻辑传播，并自动剪除所有因此而无法敏化的逻辑分支，这比逐一指定伪路径更高效、更准确 。

#### 约束的优先级

当多条不同的[时序例外](@entry_id:1133190)约束应用于同一条路径时，STA工具遵循一个明确的**优先级层次**来解决冲突 。这个层次与约束文件的书写顺序无关，而是基于约束的类型：

1.  **路径禁用约束（最高优先级）**: 任何将路径从时序分析中移除的约束都具有最高优先级。这包括 `set_false_path` 和 `set_clock_groups -asynchronous`。如果这些约束中的任何一个适用，该路径将被忽略，所有其他[时序例外](@entry_id:1133190)（如 `set_multicycle_path` 或 `set_max_delay`）都将失效。
2.  **绝对延迟约束**: `set_max_delay` 和 `set_min_delay` 直接为路径指定一个绝对的延迟要求。它们覆盖了所有基于[时钟周期](@entry_id:165839)的时序检查。
3.  **周期修改约束（最低优先级）**: `set_multicycle_path` 修改了默认的基于[时钟周期](@entry_id:165839)的检查。它的优先级最低。

例如，如果一条路径同时被施加了 `set_multicycle_path -setup 2` 和 `set_max_delay 0.9` 约束，工具将忽略多周期设置，而采用 `0.9ns` 作为其最大延迟要求。如果这条路径还被施加了 `set_false_path`，那么前两者都将被忽略，路径将不被分析。理解这个优先级规则对于编写健壮且可预测的[时序约束](@entry_id:168640)至关重要。