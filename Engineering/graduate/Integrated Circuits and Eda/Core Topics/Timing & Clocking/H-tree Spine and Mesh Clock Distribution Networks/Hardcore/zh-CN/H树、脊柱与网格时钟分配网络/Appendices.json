{
    "hands_on_practices": [
        {
            "introduction": "在我们分析或设计复杂的时钟网络之前，我们必须掌握估算延迟的基本工具：埃尔莫延迟（Elmore delay）模型。本练习要求您直接从其作为脉冲响应一阶矩的定义出发，推导一个RC树的延迟表达式 。这个基础练习将加深您对路径上及其分支的电阻和电容如何影响总延迟的理解。",
            "id": "4274828",
            "problem": "一种基于带有局部网格连接的H树的平衡分层时钟分配网络，用于驱动大型集成电路上的同步接收端。考虑H树的一个分支，该分支为节点 $S$ 处的接收端供电，而其在节点 $B$ 处的兄弟分支则从上游的一个分支节点分出。驱动器被建模为其戴维南电阻 $R_{s}$ 驱动一个阻容 (RC) 树。所有互连电容、缓冲器输入电容和接收端负载均被建模为相应节点到地的电容器。拓扑和参数如下，所有元件值均为严格正值：\n- 源（驱动器）节点通过串联电阻 $R_{s}$ 连接到节点 $0$。\n- 从节点 $0$ 开始，一段电阻为 $R_{1}$ 的串联导线段连接到分支节点 $1$。节点 $1$ 处的对地并联电容（代表导线段 $R_{1}$ 的分布电容以及节点 $1$ 处的任何局部缓冲器输入）为 $C_{1}$。\n- 从节点 $1$ 开始，通往目标接收端 $S$ 的主路径经过一段电阻为 $R_{2}$ 的串联导线段到达节点 $2$。节点 $2$ 处的对地并联电容为 $C_{2}$，另有一个额外的并联电容 $C_{m}$ 在节点 $2$ 处模拟局部网格连接。\n- 从节点 $2$ 开始，最后一段电阻为 $R_{3}$ 的串联导线段连接到接收节点 $3 \\equiv S$。节点 $3$ 处的对地并联电容为 $C_{3}$，在 $S$ 处的接收端负载为 $C_{L}$。\n- 从节点 $1$ 开始，一个通往接收端 $B$ 的兄弟分支包含一个到节点 $b$ 的串联电阻 $R_{b}$，该节点具有并联电容 $C_{b}$（代表兄弟分支上的导线和接收端负载）。\n假设网络是线性和时不变的，并且驱动器施加一个上升时间足够快的阶跃输入，以至于阻容 (RC) 动态特性主导了插入延迟。将接收端 $S$ 处的插入延迟 $t_{\\mathrm{ins}}(S)$ 定义为该接收端脉冲响应的一阶矩，即RC树的标准Elmore延迟。\n仅使用线性RC网络的基本性质和一阶矩的定义（不使用任何预先给出的简化公式），推导出一个关于 $R_{s}$、$R_{1}$、$R_{2}$、$R_{3}$、$R_{b}$、$C_{1}$、$C_{2}$、$C_{3}$、$C_{m}$、$C_{L}$ 和 $C_{b}$ 的 $t_{\\mathrm{ins}}(S)$ 的封闭形式解析表达式。你的最终答案必须是单个符号表达式。以秒为单位表示答案。不需要进行数值计算或四舍五入。",
            "solution": "问题要求推导指定阻容 (RC) 树中接收端 $S$ 处的插入延迟（定义为Elmore延迟）的封闭形式解析表达式。推导必须基于基本原理和一阶矩的定义，而不是预先给出的公式。\n\n首先，我们建立理论基础。节点 $i$ 处的插入延迟 $t_{\\mathrm{ins}}(i)$ 定义为该节点脉冲响应 $h_i(t)$ 的一阶矩。用数学公式表示为：\n$$t_{\\mathrm{ins}}(i) = \\int_{0}^{\\infty} t h_i(t) dt$$\n拉普拉斯变换的一个基本性质将函数的一阶矩与其变换的导数联系起来。脉冲响应的拉普拉斯变换是传递函数，$H_i(s) = \\mathcal{L}\\{h_i(t)\\} = \\int_{0}^{\\infty} h_i(t) e^{-st} dt$。对 $H_i(s)$ 关于 $s$ 求导，得到：\n$$\\frac{dH_i(s)}{ds} = \\int_{0}^{\\infty} (-t) h_i(t) e^{-st} dt$$\n在 $s=0$ 处求值：\n$$\\frac{dH_i(s)}{ds} \\bigg|_{s=0} = \\int_{0}^{\\infty} -t h_i(t) dt = -t_{\\mathrm{ins}}(i)$$\n因此，插入延迟可以计算为：\n$$t_{\\mathrm{ins}}(i) = -\\frac{dH_i(s)}{ds} \\bigg|_{s=0}$$\n\n接下来，我们推导RC树中节点 $i$ 的 $H_i(s)$ 的一般表达式。网络是线性和时不变的。设输入电压为 $v_{\\mathrm{in}}(t)$，其拉普拉斯变换为 $V_{\\mathrm{in}}(s)$。任意节点 $i$ 的电压 $V_i(s)$ 等于输入电压减去从输入到节点 $i$ 的唯一路径上所有电阻的电压降之和。\n$$V_i(s) = V_{\\mathrm{in}}(s) - \\sum_{j \\in \\text{path(in, i)}} R_j I_j(s)$$\n此处，$R_j$ 是通往节点 $i$ 路径上的一个电阻，$I_j(s)$ 是流经它的电流。在RC树中，流经电阻 $R_j$ 的电流必须对其下游子树中的所有电容器充电。流入单个电容器 $C_k$ 的电流是 $sC_k V_k(s)$。因此，总电流 $I_j(s)$ 是：\n$$I_j(s) = s \\sum_{k \\in \\text{subtree}(R_j)} C_k V_k(s)$$\n将此代入电压方程：\n$$V_i(s) = V_{\\mathrm{in}}(s) - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( s \\sum_{k \\in \\text{subtree}(R_j)} C_k V_k(s) \\right)$$\n传递函数 $H_i(s) = V_i(s) / V_{\\mathrm{in}}(s)$ 是：\n$$H_i(s) = 1 - s \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(s) \\right)$$\n现在，我们使用乘法法则对 $H_i(s)$ 关于 $s$ 求导：\n$$\\frac{dH_i(s)}{ds} = -\\left[ \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(s) \\right) + s \\frac{d}{ds}(\\dots) \\right]$$\n在 $s=0$ 处求值，乘以 $s$ 的项消失。对于任何RC树，到任意节点的直流增益均为1，因此对所有 $k$ 都有 $H_k(0) = 1$。\n$$\\frac{dH_i(s)}{ds} \\bigg|_{s=0} = - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(0) \\right) = - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k \\right)$$\n项 $\\sum_{k \\in \\text{subtree}(R_j)} C_k$ 是电阻 $R_j$ 下游的总电容，我们将其表示为 $C_{\\text{downstream}, j}$。\n$$t_{\\mathrm{ins}}(i) = - \\left(-\\sum_{j \\in \\text{path(in, i)}} R_j C_{\\text{downstream}, j}\\right) = \\sum_{j \\in \\text{path(in, i)}} R_j C_{\\text{downstream}, j}$$\n这个推导出的公式也可以通过遍历网络中每个电容器 $C_k$ 来表示。节点 $i$ 处的延迟是每个电容 $C_k$ 与从源到节点 $i$ 和节点 $k$ 的共享路径总电阻的乘积之和。将此共享路径电阻表示为 $R_{ik}$，公式为：\n$$t_{\\mathrm{ins}}(i) = \\sum_{\\text{all } k} R_{ik} C_k$$\n我们将使用此公式计算接收端 $S$ (节点 $3$) 处的延迟。\n\n具有电容的节点是 $1$、$2$、$3$ (或 $S$) 和 $b$。每个节点的总电容是：\n- 节点 $1$：$C_{node1} = C_1$\n- 节点 $2$：$C_{node2} = C_2 + C_m$\n- 节点 $S$：$C_{nodeS} = C_3 + C_L$\n- 节点 $b$：$C_{nodeb} = C_b$\n\n求和是针对这四个电容节点。目标节点是 $i=S$。\n$$t_{\\mathrm{ins}}(S) = R_{S,1}C_{node1} + R_{S,2}C_{node2} + R_{S,S}C_{nodeS} + R_{S,b}C_{nodeb}$$\n\n1.  **来自 $C_{node1} = C_1$ 的贡献**：\n    - 从源到 $S$ 的路径经过电阻 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $1$ 的路径经过 $R_s, R_1$。\n    - 共享路径电阻 $R_{S,1}$ 是从源到节点 $1$ 的电阻：$R_s + R_1$。\n    - 贡献：$(R_s + R_1)C_1$。\n\n2.  **来自 $C_{node2} = C_2 + C_m$ 的贡献**：\n    - 从源到 $S$ 的路径经过 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $2$ 的路径经过 $R_s, R_1, R_2$。\n    - 共享路径电阻 $R_{S,2}$ 是从源到节点 $2$ 的电阻：$R_s + R_1 + R_2$。\n    - 贡献：$(R_s + R_1 + R_2)(C_2 + C_m)$。\n\n3.  **来自 $C_{nodeS} = C_3 + C_L$ 的贡献**：\n    - 从源到 $S$ 的路径经过 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $S$ 的路径是相同的。\n    - 共享路径电阻 $R_{S,S}$ 是到 $S$ 的完整路径电阻：$R_s + R_1 + R_2 + R_3$。\n    - 贡献：$(R_s + R_1 + R_2 + R_3)(C_3 + C_L)$。\n\n4.  **来自 $C_{nodeb} = C_b$ 的贡献**：\n    - 从源到 $S$ 的路径经过 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $b$ 的路径经过 $R_s, R_1, R_b$。\n    - 分支点是节点 $1$。共享路径电阻 $R_{S,b}$ 是从源到节点 $1$ 的电阻：$R_s + R_1$。\n    - 贡献：$(R_s + R_1)C_b$。\n\n将这四个贡献相加，得到接收端 $S$ 的总插入延迟：\n$$t_{\\mathrm{ins}}(S) = (R_s + R_1)C_1 + (R_s + R_1 + R_2)(C_2 + C_m) + (R_s + R_1 + R_2 + R_3)(C_3 + C_L) + (R_s + R_1)C_b$$\n这个表达式可以通过对具有相同路径电阻的项进行分组来重新排列：\n$$t_{\\mathrm{ins}}(S) = (R_s + R_1)(C_1 + C_b) + (R_s + R_1 + R_2)(C_2 + C_m) + (R_s + R_1 + R_2 + R_3)(C_3 + C_L)$$\n这个最终表达式是接收端 $S$ 处插入延迟的封闭形式解析解。单位是欧姆乘以法拉，正确地得到秒。",
            "answer": "$$\n\\boxed{(R_{s} + R_{1})(C_{1} + C_{b}) + (R_{s} + R_{1} + R_{2})(C_{2} + C_{m}) + (R_{s} + R_{1} + R_{2} + R_{3})(C_{3} + C_{L})}\n$$"
        },
        {
            "introduction": "时钟偏移不仅源于导线长度或负载的不匹配，它还受到功率分配网络的严重影响。本练习模拟了一个实际场景，其中沿电源总线分布的驱动器因IR压降而经历不同的供电电压，从而导致其延迟产生差异 。通过计算这种偏移，您将获得关于功耗完整性（power integrity）与时钟时序之间关键相互作用的实践见解。",
            "id": "4274800",
            "problem": "一个高性能片上系统采用混合时钟分配方案，该方案由一个 $H$ 树构成，它将时钟扇出到一组相同的网格驱动器，这些驱动器再驱动一个局部时钟网格。这些网格驱动器由一根水平电源脊柱供电，该脊柱沿 $x$ 轴从 $x=0$ 处的稳压焊盘延伸到 $x=L$ 处的网格区域末端。该电源脊柱被建模为电网的一维阻容 ($RC$) 传输线，具有单位长度均匀电阻 $r$ 和单位长度均匀去耦电容 $c$。对于本问题，假设以下场景和参数：\n- 电源脊柱长度为 $L=8\\,\\text{mm}$，位于 $x=0$ 处的电源焊盘电压保持在 $V_{\\text{DD}}=0.8\\,\\text{V}$。\n- 有 $N=16$ 个相同的网格驱动器，沿着电源脊柱均匀分布，位置为 $x_{k}=(k-\\tfrac{1}{2})\\Delta$，其中 $\\Delta=L/N$， $k\\in\\{1,2,\\dots,N\\}$。\n- 在持续时间为 $T_{\\text{edge}}=50\\,\\text{ps}$ 的时钟边沿期间，每个驱动器吸取恒定电流 $I_{d}=5\\,\\text{mA}$，并且所有驱动器同时开关。电源脊柱的单位长度电阻为 $r=0.2\\,\\Omega/\\text{mm}$，单位长度去耦电容为 $c=0.1\\,\\text{nF}/\\text{mm}$。\n- 到达驱动器输入端的时钟路径（即通过 $H$ 树）对所有驱动器具有相同的插入延迟；因此，任何时钟偏移（skew）都完全是由电源引起的驱动器延迟差异造成的。\n- 在标称工作点附近，驱动器延迟对电源电压表现出小信号线性灵敏度，使得延迟变化为 $\\Delta t_{d}\\approx s\\,\\Delta V$，其中 $s=0.02\\,\\text{ps}/\\text{mV}$ 是在 $V_{\\text{DD}}=0.8\\,\\text{V}$ 附近测得的。\n\n使用基于欧姆定律、电流连续性以及 $RC$ 网络在边沿时间内的准静态有效性的电源脊柱第一性原理模型，推导当驱动器吸取指定电流时，沿电源脊柱的电压降随位置 $x$ 变化的函数。然后，确定纯粹由电源 $IR$ 压降引起的最早和最晚到达的网格驱动器之间的最坏情况下的时钟偏移。将最终数值答案四舍五入到四位有效数字。以皮秒（ps）为单位表示最终的时钟偏移。\n\n在首字母缩略词首次出现时进行定义。例如，电子设计自动化（EDA）。所有数学推理必须基于基本定律和经过充分检验的公式，而不是临时的快捷方式。确保所有给定数据的使用保持一致和实际。最终答案必须是单个实数。",
            "solution": "该问题要求计算高性能片上系统（SoC）混合时钟分配网络中网格驱动器之间的最坏情况下的时钟偏移。该时钟偏移源于沿电源脊柱的电压变化，这些变化导致了驱动器传播延迟的差异。分析将基于电源脊柱的第一性原理准静态模型。“准静态”一词意味着我们在驱动器吸取电流的瞬间分析系统，将其视为一个直流（DC）问题。因此，电压降是电阻性压降或 $IR$ 压降，其中 $I$ 代表电流，$R$ 代表电阻。电源脊柱被建模为一维阻容（$RC$）传输线。虽然给出了单位长度去耦电容 $c$ 和边沿持续时间 $T_{\\text{edge}}$，但指令要求使用基于欧姆定律和电流连续性的准静态模型来计算电压降，这意味着我们关注的是每个驱动器吸取恒定电流 $I_d$ 所产生的电阻效应。\n\n首先，我们建立物理模型。长度为 $L$ 的电源脊柱沿 $x$ 轴从 $x=0$ 延伸到 $x=L$。在 $x=0$ 处施加恒定的电源电压 $V_{\\text{DD}}$。有 $N=16$ 个相同的网格驱动器，每个驱动器吸取电流 $I_d$，位于位置 $x_k = (k-\\frac{1}{2})\\Delta$，其中 $k \\in \\{1, 2, \\dots, N\\}$，$\\Delta = L/N$。该脊柱具有单位长度的均匀电阻 $r$。\n\n在位置 $x$ 处流过电源脊柱的电流 $I(x)$ 是所有位于大于 $x$ 的位置的驱动器所吸取电流的总和。由于所有驱动器同时开关，我们可以将 $I(x)$ 确定为分段常数函数。\n对于第一个段中的位置 $x \\in [0, x_1]$，电源脊柱必须为所有 $N$ 个驱动器供电。因此，电流为 $I(x) = N I_d$。\n对于位于驱动器 $x_k$ 和 $x_{k+1}$ 之间的位置 $x$，即 $x \\in (x_k, x_{k+1}]$，前 $k$ 个驱动器已经吸取了电流。电源脊柱中的电流为剩下的 $N-k$ 个驱动器供电。因此，对于 $k=1, \\dots, N-1$，$I(x) = (N-k)I_d$。\n对于 $x > x_N$，没有驱动器需要供电，因此 $I(x) = 0$。\n\n沿电源脊柱的电压降遵循欧姆定律。在无穷小长度 $dx$ 上的微分电压降 $dV$ 为 $dV = -I(x) r dx$。任意位置 $x$ 处的电压 $V(x)$ 可以通过从 $x=0$ 处的电源焊盘开始对此表达式进行积分得到：\n$$V(x) = V(0) - \\int_0^x r I(\\xi) d\\xi = V_{\\text{DD}} - r \\int_0^x I(\\xi) d\\xi$$\n位置 $x$ 处的电压降为 $\\Delta V(x) = V_{\\text{DD}} - V(x) = r \\int_0^x I(\\xi) d\\xi$。\n\n我们关心的是每个驱动器位置 $V(x_k)$ 处的电压，以及因此产生的电压降 $\\Delta V(x_k)$。让我们计算从一个驱动器到下一个驱动器的电压降。驱动器 $j-1$ 和驱动器 $j$ 之间的压降由该段中流动的电流决定。\n从 $x=0$ 处的焊盘到第一个驱动器 $x_1$ 处的电压降为：\n$$\\Delta V(x_1) = r \\int_0^{x_1} I(\\xi)d\\xi = r \\int_0^{\\Delta/2} (N I_d) d\\xi = r N I_d \\frac{\\Delta}{2}$$\n对于 $j \\ge 2$，驱动器 $j-1$（在 $x_{j-1}$ 处）和驱动器 $j$（在 $x_j$ 处）之间的电压降取决于段 $(x_{j-1}, x_j]$ 中的电流 $I(x) = (N-(j-1))I_d$。该段的长度为 $x_j - x_{j-1} = ((j-\\frac{1}{2})\\Delta) - ((j-1-\\frac{1}{2})\\Delta) = \\Delta$。\n该段上的增量电压降为 $r (N-j+1)I_d \\Delta$。\n\n第 $k$ 个驱动器处的总电压降 $\\Delta V(x_k)$ 是到该点为止所有压降的总和：\n$$\\Delta V(x_k) = \\Delta V(x_1) + \\sum_{j=2}^{k} (V(x_{j-1}) - V(x_j))$$\n$$\\Delta V(x_k) = r N I_d \\frac{\\Delta}{2} + \\sum_{j=2}^{k} r (N-j+1) I_d \\Delta = r I_d \\Delta \\left( \\frac{N}{2} + \\sum_{j=2}^{k} (N-j+1) \\right)$$\n该求和是一个等差数列。令 $p = j-1$。求和变为 $\\sum_{p=1}^{k-1} (N-p) = (N-1) + (N-2) + \\dots + (N-k+1)$。\n该数列的和为 $\\frac{k-1}{2}( (N-1) + (N-k+1) ) = \\frac{(k-1)(2N-k)}{2}$。\n将其代回：\n$$\\Delta V(x_k) = r I_d \\Delta \\left( \\frac{N}{2} + \\frac{(k-1)(2N-k)}{2} \\right) = \\frac{r I_d \\Delta}{2} (N + 2Nk - k^2 - 2N + k) = \\frac{r I_d \\Delta}{2}(-k^2 + (2N+1)k - N)$$\n电压降 $\\Delta V(x_k)$ 随 $k$ 的增加而增加。最靠近焊盘的驱动器（$k=1$）经历最高的电压（最小压降），而离焊盘最远的驱动器（$k=N$）经历最低的电压（最大压降）。\n最小电压降发生在 $k=1$ 时：\n$$\\Delta V_{\\text{min}} = \\Delta V(x_1) = \\frac{r I_d \\Delta}{2}(-1 + (2N+1) - N) = \\frac{r I_d \\Delta N}{2}$$\n最大电压降发生在 $k=N$ 时：\n$$\\Delta V_{\\text{max}} = \\Delta V(x_N) = \\frac{r I_d \\Delta}{2}(-N^2 + (2N+1)N - N) = \\frac{r I_d \\Delta}{2}(-N^2 + 2N^2 + N - N) = \\frac{r I_d \\Delta N^2}{2}$$\n任意两个驱动器之间的最大电压差为 $\\Delta V_{\\text{worst-case}} = \\Delta V_{\\text{max}} - \\Delta V_{\\text{min}}$。\n$$\\Delta V_{\\text{worst-case}} = \\frac{r I_d \\Delta N^2}{2} - \\frac{r I_d \\Delta N}{2} = \\frac{r I_d \\Delta}{2}(N^2-N) = \\frac{r I_d N(N-1)\\Delta}{2}$$\n代入 $\\Delta = L/N$：\n$$\\Delta V_{\\text{worst-case}} = \\frac{r I_d N(N-1)}{2} \\frac{L}{N} = \\frac{r I_d L (N-1)}{2}$$\n时钟偏移是最晚到达时间（最低电压，在 $x_N$ 处）和最早到达时间（最高电压，在 $x_1$ 处）之间的延迟差。延迟变化由 $\\Delta t_d \\approx s \\Delta V$ 给出。\n$$\\text{Skew} = t_{d,\\text{late}} - t_{d,\\text{early}} = s(\\Delta V_{\\text{max}} - \\Delta V_{\\text{min}}) = s \\cdot \\Delta V_{\\text{worst-case}}$$\n$$\\text{Skew} = s \\frac{r I_d L (N-1)}{2}$$\n现在，我们代入给定的数值：\n$s = 0.02\\,\\text{ps}/\\text{mV}$\n$r = 0.2\\,\\Omega/\\text{mm}$\n$I_d = 5\\,\\text{mA}$\n$L = 8\\,\\text{mm}$\n$N = 16$\n\n首先，计算最坏情况下的电压降 $\\Delta V_{\\text{worst-case}}$。保持单位一致至关重要。我们可以使用毫米（mm）、毫安（mA）和欧姆（$\\Omega$）进行计算，这将得到以毫伏（mV）为单位的电压。\n$$\\Delta V_{\\text{worst-case}} = \\frac{(0.2\\,\\Omega/\\text{mm}) \\cdot (5\\,\\text{mA}) \\cdot (8\\,\\text{mm}) \\cdot (16-1)}{2}$$\n$$\\Delta V_{\\text{worst-case}} = \\frac{0.2 \\cdot 5 \\cdot 8 \\cdot 15}{2}\\,\\text{mV} = \\frac{1 \\cdot 8 \\cdot 15}{2}\\,\\text{mV} = \\frac{120}{2}\\,\\text{mV} = 60\\,\\text{mV}$$\n现在，我们可以使用灵敏度 $s$ 来计算时钟偏移：\n$$\\text{Skew} = (0.02\\,\\text{ps}/\\text{mV}) \\cdot (60\\,\\text{mV}) = 1.2\\,\\text{ps}$$\n题目要求将答案四舍五入到四位有效数字。因此，时钟偏移为 $1.200\\,\\text{ps}$。",
            "answer": "$$\\boxed{1.200}$$"
        },
        {
            "introduction": "从分析转向综合，本练习将指导您实现延迟合并嵌入（Deferred-Merge Embedding, DME）算法，这是现代时钟树综合的基石。您将通过迭代合并子树，并通过计算导线蜿蜒（meandering）来平衡延迟，从而从零开始构建一个零偏移时钟树 。这项练习将为您提供创建按构造即正确（correct-by-construction）的时钟网络的动手经验。",
            "id": "4274820",
            "problem": "您需要使用延迟合并嵌入 (DME) 方法，在曼哈顿 (直线) 布局下，为一组指定的时钟接收端坐标构建一个零时钟偏移树 (ZST)，并计算根据 Elmore 延迟度量实现零偏移所需的分支长度。该问题设定在一个适用于时钟分配网络的阻容互连模型中，重点是合成树形结构。根据接收端的空间分布，这些结构可以模拟分层 H-树、线性主干或局部网格片段的特征。请从阻容树中直线几何和 Elmore 延迟的基本定义出发，推导出能够强制所有接收端具有相等到达时间的算法。\n\n定义与要求：\n- 使用曼哈顿 (直线) 布局模型：两点 $(x_1,y_1)$ 和 $(x_2,y_2)$ 之间的距离为 $|x_2-x_1|+|y_2-y_1|$。\n- 导线具有均匀的单位长度电阻 $r$ (单位为 $\\mathrm{\\Omega/\\mu m}$) 和均匀的单位长度电容 $c$ (单位为 $\\mathrm{F/\\mu m}$)。每个接收端 $i$ 在其位置 $(x_i,y_i)$ 处具有一个集总电容 $C_i$ (单位为 $\\mathrm{F}$)。\n- 您必须使用 DME 构建方法。在每次二元合并时，为了最小化基准总曼哈顿长度，需在两个子锚点的直线中值区域内为新父节点选择一个锚点位置。然后，如有必要，通过增加蜿蜒走线来调整分支长度，以精确地均衡两个子树的 Elmore 到达时间，同时保持曼哈顿布局。当两个子树的基准 Elmore 延迟不相等时，仅在基准延迟较小的一侧增加蜿蜒走线，所增加的长度需足以实现延迟相等。每次合并后，更新等效的下游电容以及从新父节点到其子树中各接收端的共同内部延迟，并将这些值向上传播至树的更上层。\n- 通过贪心方式重复合并节点对来构建最终的 ZST：在每一轮中，按键值 $x+y$ 对当前节点进行排序，并按顺序将它们配对；如果剩余一个奇数节点，则将其保留到下一轮，不进行合并。\n- 对于每个测试用例，您的输出必须是所构建的 ZST 中每条边的分支长度列表。所有分支长度以微米 ($\\mathrm{\\mu m}$) 为单位，表示为四舍五入到三位小数的浮点数。\n\n从以下基本原理开始：\n- 直线几何 (曼哈顿度量)。\n- 由均匀导线电阻 $r$ 和均匀导线电容 $c$ 建模的阻容互连。\n- 阻容树的 Elmore 延迟定义。\n\n测试套件：\n1. 案例 A (网格状，类 H-树):\n   - $r = 0.05$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.2 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端: $\\{((0,0), 20 \\times 10^{-15}), ((0,200), 20 \\times 10^{-15}), ((200,0), 20 \\times 10^{-15}), ((200,200), 20 \\times 10^{-15})\\}$。\n2. 案例 B (共线，类主干状，非平衡负载):\n   - $r = 0.08$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.3 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端: $\\{((0,0), 15 \\times 10^{-15}), ((150,0), 25 \\times 10^{-15}), ((300,0), 10 \\times 10^{-15})\\}$。\n3. 案例 C (重合接收端，退化情况):\n   - $r = 0.10$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.1 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端: $\\{((100,100), 20 \\times 10^{-15}), ((100,100), 20 \\times 10^{-15})\\}$。\n4. 案例 D (垂直类主干状，含五个接收端):\n   - $r = 0.06$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.25 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端: $\\{((0,0), 10 \\times 10^{-15}), ((0,100), 12 \\times 10^{-15}), ((0,200), 15 \\times 10^{-15}), ((0,300), 20 \\times 10^{-15}), ((0,400), 18 \\times 10^{-15})\\}$。\n\n答案规格：\n- 对于每个测试用例，结果是一个浮点数列表 (四舍五入到三位小数)，表示所构建 ZST 中每条边的分支长度。列表按合并的时间顺序排列，在每次合并内部，按两个子分支的顺序排列。单位是微米 ($\\mathrm{\\mu m}$)。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，没有空格。例如：$[[\\ell_{1,1},\\ell_{1,2},\\dots],[\\ell_{2,1},\\ell_{2,2},\\dots],[\\ell_{3,1},\\ell_{3,2},\\dots],[\\ell_{4,1},\\ell_{4,2},\\dots]]$，其中 $\\ell_{k,j}$ 是测试用例 $k$ 的分支长度。",
            "solution": "用户要求使用延迟合并嵌入 (DME) 算法为给定的时钟接收端集合构建一个零时钟偏移树 (ZST)。目标是计算最终树中所有分支的长度，确保根据 Elmore 延迟模型，所有接收端的时钟偏移为零。该问题设定在一个直线 (曼哈顿) 布局空间中，并采用均匀的阻容 ($RC$) 导线模型。\n\n### **1. 基本原理**\n\n**a. 直线几何 (曼哈顿度量)**\n两点 $p_1 = (x_1, y_1)$ 和 $p_2 = (x_2, y_2)$ 之间的距离 $d_M$ 由其坐标的绝对差之和给出：\n$$d_M(p_1, p_2) = |x_2 - x_1| + |y_2 - y_1|$$\n\n**b. RC 树的 Elmore 延迟模型**\nElmore 延迟是 $RC$ 电路中延迟的一阶近似。对于一个长度为 $\\ell$、单位长度电阻为 $r$、单位长度电容为 $c$ 的单一导线段，其驱动一个下游负载电容 $C_{load}$，该线段上的延迟为：\n$$T_{segment} = (r\\ell) \\left( \\frac{c\\ell}{2} + C_{load} \\right) = \\frac{1}{2}rc\\ell^2 + r\\ell C_{load}$$\n项 $\\frac{1}{2}rc\\ell^2$ 考虑了导线自身的分布式 $RC$ 特性。\n\n在一个树形结构中，从根 (源) 到特定接收端 $i$ 的总 Elmore 延迟是从根到该接收端的唯一路径上所有延迟的总和。此路径上每条边 $e_k$ 贡献的延迟是其电阻 $R_k = r\\ell_k$ 乘以它所驱动的总下游电容 $C_{downstream}(k)$。$C_{downstream}(k)$ 包括连接到该边的子树中所有的导线和接收端电容。\n$$T_{D,i} = \\sum_{e_k \\in \\text{path}(\\text{root} \\to i)} R_k C_{downstream}(k)$$\n\n### **2. 用于零时钟偏移的延迟合并嵌入 (DME) 算法**\n\nDME 算法从接收端开始，自底向上构建 ZST。在每一步中，它将两个子树合并成一个更大的子树，并确保从新根到合并后子树内所有接收端的延迟相等。\n\n**a. 节点表示**\n在构建过程中的每个节点 $v_i$，无论是接收端还是内部合并点，都由以下特征定义：\n1.  一个锚点位置 $(x_i, y_i)$。\n2.  以其为根的子树的总电容 $C_{subtree, i}$。\n3.  从该节点锚点到其子树中任意接收端的内部延迟 $T_{internal, i}$。对于一个 ZST，该延迟对子树中的所有接收端都是恒定的。\n\n最初，对于每个位于 $(x_i, y_i)$ 且电容为 $C_i$ 的接收端 $s_i$，其对应的节点具有 $C_{subtree, i} = C_i$ 和 $T_{internal, i} = 0$。\n\n**b. 配对策略**\n问题指定了一种贪心配对启发式方法。在每一轮合并中：\n1.  当前节点集合根据键值 $(x+y)$ 进行排序，其中 $(x,y)$ 是锚点位置。为确保过程的确定性，平局情况首先使用 $x$ 坐标打破，然后使用 $y$ 坐标。\n2.  排序后的节点按顺序配对：$(v_1, v_2), (v_3, v_4), \\dots$。如果节点数量为奇数，最后一个节点将被带到下一轮。\n\n**c. 合并两个子树**\n考虑合并两个节点 $v_1$ 和 $v_2$，形成一个新的父节点 $v_p$。连接 $v_p$ 到 $v_1$ 和 $v_2$ 的分支长度分别为 $\\ell_1$ 和 $\\ell_2$。\n\n**i. 父节点锚点位置与基准长度**\n父节点锚点 $a_p$ 被放置在子节点锚点 $a_1=(x_1, y_1)$ 和 $a_2=(x_2, y_2)$ 的直线中值区域内，即边界框 $[min(x_1, x_2), max(x_1, x_2)] \\times [min(y_1, y_2), max(y_1, y_2)]$。此区域内的任何点都能最小化总基准导线长度 $\\ell_{1,0} + \\ell_{2,0} = d_M(a_1, a_2)$。为确保算法的确定性，我们选择一个规范的锚点。设 $v_1$ 是排序后配对中出现的第一个节点。我们选择父节点锚点为 $a_p = (x_1, y_2)$。这将创建一个 L 形路径。基准 (曼哈顿) 分支长度为：\n$$\\ell_{1,0} = d_M(a_p, a_1) = |x_1-x_1| + |y_2-y_1| = |y_2-y_1|$$\n$$\\ell_{2,0} = d_M(a_p, a_2) = |x_1-x_2| + |y_2-y_2| = |x_1-x_2|$$\n\n**ii. 延迟平衡**\n从新父节点 $v_p$ 到子节点 $v_i$ (对于 $i=1, 2$) 子树中任意接收端的延迟为：\n$$T_{p \\to \\text{sinks}(i)} = \\left(\\frac{1}{2}rc\\ell_i^2 + r\\ell_i C_{subtree, i}\\right) + T_{internal, i}$$\n我们首先使用基准长度 $\\ell_{1,0}$ 和 $\\ell_{2,0}$ 计算基准延迟：\n$$T_{base, i} = \\left(\\frac{1}{2}rc\\ell_{i,0}^2 + r\\ell_{i,0} C_{subtree, i}\\right) + T_{internal, i}$$\n为实现零时钟偏移，最终延迟必须相等：$T_{p \\to \\text{sinks}(1)} = T_{p \\to \\text{sinks}(2)}$。我们只在基准延迟较小的分支上增加蜿蜒走线 (导线长度)。\n假设 $T_{base, 1}  T_{base, 2}$。我们将分支 2 的最终长度设为其基准长度 $\\ell_2 = \\ell_{2,0}$，目标延迟变为 $T_{target} = T_{base, 2}$。我们必须为分支 1 找到一个新的长度 $\\ell_1 \\ge \\ell_{1,0}$，使其满足：\n$$\\frac{1}{2}rc\\ell_1^2 + r\\ell_1 C_{subtree, 1} + T_{internal, 1} = T_{target}$$\n这是一个形式为 $A\\ell_1^2 + B\\ell_1 + C = 0$ 的二次方程，其中 $A=\\frac{1}{2}rc$，$B=rC_{subtree, 1}$，且 $C=T_{internal, 1} - T_{target}$。$\\ell_1$ 的物理可行解由正根给出：\n$$\\ell_1 = \\frac{-B + \\sqrt{B^2 - 4AC}}{2A}$$\n如果 $T_{base, 2}  T_{base, 1}$，则对 $\\ell_2$ 执行对称计算。如果 $T_{base, 1} = T_{base, 2}$，则不需要蜿蜒走线，因此 $\\ell_1 = \\ell_{1,0}$ 且 $\\ell_2 = \\ell_{2,0}$。\n\n**d. 传播**\n合并后，为下一轮创建的新父节点 $v_p$ 具有以下属性：\n-   锚点位置：$a_p=(x_1, y_2)$。\n-   内部延迟：$T_{internal, p} = T_{target} = \\max(T_{base, 1}, T_{base, 2})$。\n-   子树电容：这是子节点子树电容和新导线电容的总和。\n    $$C_{subtree, p} = (c\\ell_1 + C_{subtree, 1}) + (c\\ell_2 + C_{subtree, 2})$$\n\n算法持续进行，直到只剩下一个节点，即 ZST 的根节点。要求的输出是每次合并计算出的所有分支长度 $(\\ell_1, \\ell_2)$ 的按时间顺序排列的列表。",
            "answer": "[[200.000,200.000,200.000,200.000],[441.520,150.000,103.024,300.000],[0.000,0.000],[100.000,100.000,100.000,100.000,183.216,200.000,80.124,196.784]]"
        }
    ]
}