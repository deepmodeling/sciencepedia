{
    "hands_on_practices": [
        {
            "introduction": "The performance and reliability of a Static Random-Access Memory (SRAM) array begin with the design of its fundamental building block: the single 6T bit-cell. This exercise provides a foundational practice in transistor sizing, a core task in memory design. By applying first-principle MOSFET models, you will navigate the critical trade-off between read stability, quantified by the Static Noise Margin (SNM), and read performance, determined by the cell's current-sourcing capability. This problem () challenges you to calculate the precise transistor widths that satisfy a set of realistic design constraints, giving you a tangible understanding of how device geometry directly impacts cell behavior.",
            "id": "4299984",
            "problem": "Consider a six-transistor Static Random-Access Memory (SRAM) cell implemented in a planar Complementary Metal-Oxide-Semiconductor (CMOS) technology. The cell comprises two cross-coupled inverters and two access transistors. The access transistors are n-channel MOSFETs (NMOS), the pull-down transistors within each inverter are NMOS, and the pull-up transistors are p-channel MOSFETs (PMOS). The supply voltage is $V_{DD} = 0.9\\,\\text{V}$, the NMOS threshold voltage is $V_{TH,n} = 0.25\\,\\text{V}$, and the PMOS threshold voltage magnitude is $|V_{TH,p}| = 0.30\\,\\text{V}$. The effective mobility–oxide-capacitance parameters are $k_{n}' = \\mu_{n} C_{ox} = 300\\,\\mu\\text{A}/\\text{V}^{2}$ and $k_{p}' = \\mu_{p} C_{ox} = 120\\,\\mu\\text{A}/\\text{V}^{2}$. All transistors have channel length $L = 0.05\\,\\mu\\text{m}$. Neglect body effect, velocity saturation, and channel-length modulation. Use the long-channel square-law model for the drain current:\n- In saturation: $I_{D} = \\dfrac{1}{2} k' \\dfrac{W}{L} \\left( V_{GS} - V_{TH} \\right)^{2}$.\n- In the linear region: $I_{D} = k' \\dfrac{W}{L} \\left[ \\left( V_{GS} - V_{TH} \\right) V_{DS} - \\dfrac{1}{2} V_{DS}^{2} \\right]$.\n\nDuring a read of a stored logical zero on one side of the cell, both bitlines are initially precharged to $V_{DD}$, the wordline is asserted to $V_{DD}$, and the bitline connected to the zero-storing side must discharge by $\\Delta V_{BL} = 0.1\\,\\text{V}$ within the sensing time $t_{\\text{sense}} = 0.5\\,\\text{ns}$. The associated bitline capacitance is $C_{BL} = 100\\,\\text{fF}$. The series current path is through the access NMOS and the corresponding pull-down NMOS to ground, and the internal storage node on the zero-storing side rises to a disturbed voltage $V_{x}$ during the read.\n\nDefine the Static Noise Margin (SNM) in read as the minimum DC noise voltage separating the disturbed node voltage from the switching threshold of the opposite inverter. For this problem, constrain the read SNM to be at least $V_{\\text{SNM}} = 0.18\\,\\text{V}$. Let $V_{M}$ denote the switching threshold of the cell inverter, defined by equating NMOS and PMOS saturation currents at $V_{in} = V_{out} = V_{M}$:\n$$\n\\dfrac{1}{2} k_{n}' \\dfrac{W_{pd}}{L} \\left( V_{M} - V_{TH,n} \\right)^{2}\n=\n\\dfrac{1}{2} k_{p}' \\dfrac{W_{pu}}{L} \\left( V_{DD} - |V_{TH,p}| - V_{M} \\right)^{2}.\n$$\nTo maximize noise robustness in hold, adopt a symmetric design target $V_{M} = \\dfrac{V_{DD}}{2}$, and enforce the read-disturb constraint $V_{x} \\leq V_{M} - V_{\\text{SNM}}$.\n\nUnder these conditions:\n- Model the access NMOS during read-disturb as operating in saturation with $V_{GS,a} = V_{DD} - V_{x}$ and $V_{DS,a} = V_{DD} - V_{x}$.\n- Model the pull-down NMOS as operating in the linear region with gate at $V_{DD}$, drain at $V_{x}$, and source at $0$.\n\nUsing these models and constraints, compute the minimum gate widths $W_{a}$ (access NMOS), $W_{pd}$ (pull-down NMOS), and $W_{pu}$ (pull-up PMOS) that:\n1. Achieve the target average read current $I_{\\text{read}}$ sufficient to discharge the bitline by $\\Delta V_{BL}$ within $t_{\\text{sense}}$, and\n2. Satisfy $V_{x} = V_{M} - V_{\\text{SNM}}$ at that current, and\n3. Satisfy the area constraint $W_{a} + W_{pd} + W_{pu} \\leq 180\\,\\text{nm}$.\n\nExpress all final widths in nanometers and round your answers to four significant figures. The final answer must be reported as a single row matrix in the order $\\left( W_{a},\\, W_{pd},\\, W_{pu} \\right)$.",
            "solution": "The problem statement has been validated and is determined to be self-contained, scientifically grounded, and well-posed. All provided data, models, and constraints are consistent and sufficient for a unique solution.\n\nThe objective is to find the minimum gate widths for the access transistor ($W_{a}$), the pull-down NMOS ($W_{pd}$), and the pull-up PMOS ($W_{pu}$) of a 6T SRAM cell. These widths must satisfy three primary conditions: a specific read current performance, a read static noise margin (SNM) constraint, and a total-width area constraint.\n\nFirst, we determine the key operating voltages and the required read current from the given constraints.\nThe supply voltage is $V_{DD} = 0.9\\,\\text{V}$.\nThe symmetric design target for the inverter switching threshold is $V_{M} = \\dfrac{V_{DD}}{2}$.\n$$V_{M} = \\frac{0.9\\,\\text{V}}{2} = 0.45\\,\\text{V}$$\nThe problem enforces the read-disturb constraint at its boundary: $V_{x} = V_{M} - V_{\\text{SNM}}$, where $V_x$ is the disturbed voltage on the zero-storing internal node and $V_{\\text{SNM}} = 0.18\\,\\text{V}$ is the required read SNM.\n$$V_{x} = 0.45\\,\\text{V} - 0.18\\,\\text{V} = 0.27\\,\\text{V}$$\nThe target average read current, $I_{\\text{read}}$, required to discharge the bitline capacitance $C_{BL} = 100\\,\\text{fF}$ by $\\Delta V_{BL} = 0.1\\,\\text{V}$ within the sensing time $t_{\\text{sense}} = 0.5\\,\\text{ns}$ is calculated as:\n$$I_{\\text{read}} = C_{BL} \\frac{\\Delta V_{BL}}{t_{\\text{sense}}} = (100 \\times 10^{-15}\\,\\text{F}) \\frac{0.1\\,\\text{V}}{0.5 \\times 10^{-9}\\,\\text{s}} = 20 \\times 10^{-6}\\,\\text{A} = 20\\,\\mu\\text{A}$$\n\nNext, we determine the required sizing ratio of the inverter transistors to achieve the symmetric switching threshold $V_{M} = V_{DD}/2$. We use the provided equation, equating the saturation currents of the pull-down NMOS (width $W_{pd}$) and pull-up PMOS (width $W_{pu}$) at $V_{in} = V_{out} = V_{M}$.\n$$\n\\frac{1}{2} k_{n}' \\frac{W_{pd}}{L} \\left( V_{M} - V_{TH,n} \\right)^{2}\n=\n\\frac{1}{2} k_{p}' \\frac{W_{pu}}{L} \\left( V_{DD} - V_{M} - |V_{TH,p}| \\right)^{2}\n$$\nThe ratio of the widths, $\\beta_{R} = W_{pu}/W_{pd}$, is:\n$$ \\beta_{R} = \\frac{W_{pu}}{W_{pd}} = \\frac{k_{n}'}{k_{p}'} \\left( \\frac{V_{M} - V_{TH,n}}{V_{DD} - V_{M} - |V_{TH,p}|} \\right)^{2} $$\nSubstituting the given values ($V_{M} = 0.45\\,\\text{V}$, $V_{DD}=0.9\\,\\text{V}$, $V_{TH,n} = 0.25\\,\\text{V}$, $|V_{TH,p}| = 0.30\\,\\text{V}$, $k_{n}' = 300\\,\\mu\\text{A}/\\text{V}^{2}$, $k_{p}' = 120\\,\\mu\\text{A}/\\text{V}^{2}$):\n$$ \\beta_{R} = \\frac{300}{120} \\left( \\frac{0.45 - 0.25}{0.9 - 0.45 - 0.30} \\right)^{2} = 2.5 \\left( \\frac{0.20}{0.15} \\right)^{2} = 2.5 \\left( \\frac{4}{3} \\right)^{2} = 2.5 \\left( \\frac{16}{9} \\right) = \\frac{40}{9} $$\n\nNow, we analyze the read-disturb condition to find the relationship between $W_{pd}$ and $W_{a}$. During a read operation, the current $I_{\\text{read}}$ flows through the access transistor ($MN_a$) and the pull-down transistor ($MN_{pd}$). At the stable disturbed node voltage $V_x$, their currents are equal: $I_{D,a} = I_{D,pd}$.\nAccording to the problem, $MN_{a}$ is in saturation with $V_{GS,a} = V_{DD} - V_{x}$. Its current is:\n$$ I_{D,a} = \\frac{1}{2} k_{n}' \\frac{W_{a}}{L} (V_{GS,a} - V_{TH,n})^2 = \\frac{1}{2} k_{n}' \\frac{W_{a}}{L} (V_{DD} - V_{x} - V_{TH,n})^2 $$\n$MN_{pd}$ is in the linear region with $V_{GS,pd} = V_{DD}$ (its gate is connected to the other side of the cell, which stores a '1') and $V_{DS,pd} = V_{x}$. Its current is:\n$$ I_{D,pd} = k_{n}' \\frac{W_{pd}}{L} \\left[ (V_{GS,pd} - V_{TH,n})V_{DS,pd} - \\frac{1}{2}V_{DS,pd}^2 \\right] = k_{n}' \\frac{W_{pd}}{L} \\left[ (V_{DD} - V_{TH,n})V_{x} - \\frac{1}{2}V_{x}^2 \\right] $$\nEquating $I_{D,a}$ and $I_{D,pd}$ gives the cell ratio $CR_{\\text{eff}} = W_{pd}/W_{a}$:\n$$ CR_{\\text{eff}} = \\frac{W_{pd}}{W_{a}} = \\frac{\\frac{1}{2} (V_{DD} - V_{x} - V_{TH,n})^2}{(V_{DD} - V_{TH,n})V_{x} - \\frac{1}{2}V_{x}^2} $$\nSubstituting the numerical values ($V_{DD} = 0.9\\,\\text{V}$, $V_x = 0.27\\,\\text{V}$, $V_{TH,n} = 0.25\\,\\text{V}$):\n$$ CR_{\\text{eff}} = \\frac{\\frac{1}{2} (0.9 - 0.27 - 0.25)^2}{(0.9 - 0.25)(0.27) - \\frac{1}{2}(0.27)^2} = \\frac{\\frac{1}{2}(0.38)^2}{(0.65)(0.27) - \\frac{1}{2}(0.0729)} = \\frac{0.0722}{0.1755 - 0.03645} = \\frac{0.0722}{0.13905} \\approx 0.519237 $$\n\nWith the relationships between the widths established, we can calculate their absolute values using the read current requirement $I_{\\text{read}} = I_{D,pd} = 20\\,\\mu\\text{A}$.\n$$ I_{\\text{read}} = k_{n}' \\frac{W_{pd}}{L} \\left[ (V_{DD} - V_{TH,n})V_{x} - \\frac{1}{2}V_{x}^2 \\right] $$\n$$ 20 \\times 10^{-6}\\,\\text{A} = (300 \\times 10^{-6}\\,\\text{A}/\\text{V}^2) \\frac{W_{pd}}{0.05 \\times 10^{-6}\\,\\text{m}} \\left[ 0.13905\\,\\text{V}^2 \\right] $$\nSolving for $W_{pd}$:\n$$ W_{pd} = \\frac{(20 \\times 10^{-6})(0.05 \\times 10^{-6})}{(300 \\times 10^{-6})(0.13905)} \\,\\text{m} = \\frac{1 \\times 10^{-12}}{41.715 \\times 10^{-6}} \\,\\text{m} \\approx 2.3972 \\times 10^{-8}\\,\\text{m} = 23.972\\,\\text{nm} $$\nRounding to four significant figures, $W_{pd} = 23.97\\,\\text{nm}$.\n\nNow we can find $W_{pu}$ and $W_{a}$ using the calculated ratios:\n$$ W_{pu} = \\beta_{R} \\cdot W_{pd} = \\left(\\frac{40}{9}\\right) \\cdot (23.972\\,\\text{nm}) \\approx 106.543\\,\\text{nm} $$\nRounding to four significant figures, $W_{pu} = 106.5\\,\\text{nm}$.\n$$ W_{a} = \\frac{W_{pd}}{CR_{\\text{eff}}} = \\frac{23.972\\,\\text{nm}}{0.519237} \\approx 46.168\\,\\text{nm} $$\nRounding to four significant figures, $W_{a} = 46.17\\,\\text{nm}$.\n\nFinally, we verify the area constraint: $W_{a} + W_{pd} + W_{pu} \\leq 180\\,\\text{nm}$.\n$$ 46.17\\,\\text{nm} + 23.97\\,\\text{nm} + 106.5\\,\\text{nm} = 176.64\\,\\text{nm} $$\nSince $176.64\\,\\text{nm} \\leq 180\\,\\text{nm}$, the area constraint is satisfied.\n\nThe calculated widths are the minimum sizes required to meet the specified electrical performance constraints. The final values, expressed in nanometers and rounded to four significant figures, for $(W_{a}, W_{pd}, W_{pu})$ are $(46.17, 23.97, 106.5)$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 46.17 & 23.97 & 106.5 \\end{pmatrix} } $$"
        },
        {
            "introduction": "While designing for nominal specifications is a crucial first step, a robust SRAM cell must function correctly despite inevitable variations in the manufacturing process. This practice moves beyond nominal design to explore the concept of process corner analysis, a cornerstone of modern integrated circuit verification. In this exercise (), you will develop a computational model to evaluate the read and write margins of an SRAM cell under different process corners, such as 'Fast-N/Slow-P'. By identifying the worst-case corners, you will gain insight into how designers create guard bands to ensure high-yield, reliable memory systems.",
            "id": "4299993",
            "problem": "You are asked to design and implement a program that, for a six-transistor Static Random-Access Memory (SRAM) cell, analyzes how process corners alter effective device strength ratios and identifies the worst-case process corner for read stability and write-ability. The objective is to compute, for each provided test case, which corner produces the smallest read margin and which produces the smallest write margin according to a simplified but principled model grounded in Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) square-law behavior. The problem is situated in the context of integrated circuits and Electronic Design Automation (EDA).\n\nFundamental base and model assumptions to be used:\n- Use the first-order MOSFET square-law current model for saturation, namely that the saturation current magnitude scales with the transconductance parameter $\\beta$, where $\\beta \\propto \\mu C_{\\mathrm{ox}} W/L$; here $\\mu$ is the carrier mobility, $C_{\\mathrm{ox}}$ is the oxide capacitance per unit area, and $W/L$ is the transistor geometry ratio. Since absolute current is not required, you may treat $C_{\\mathrm{ox}}$ as a constant and absorb it into $\\beta$ scaling.\n- Let the effective conduction “strength” for a device be approximated by $S = \\beta \\cdot \\max(V_{\\mathrm{eff}},0)^2$, where $V_{\\mathrm{eff}}$ is the gate overdrive in saturation. For simplification at the supply voltage $V_{\\mathrm{DD}}$, approximate the overdrives by $V_{\\mathrm{eff},n} = V_{\\mathrm{DD}} - V_{tn}$ for an n-channel device and $V_{\\mathrm{eff},p} = V_{\\mathrm{DD}} - |V_{tp}|$ for a p-channel device.\n- The SRAM inverter pair trip point $V_M$ is to be computed under the square-law balance condition for the cross-coupled inverters by equating the saturated n-channel and p-channel currents. With $a = \\sqrt{\\beta_n}$ and $b = \\sqrt{\\beta_p}$, the switching threshold should be taken as\n$$\nV_M = \\frac{b\\,(V_{\\mathrm{DD}} - |V_{tp}|) + a\\, V_{tn}}{a + b}.\n$$\n- Define read disturb during a read access on the node storing a logical zero as a static divider between the access transistor pulling up from $V_{\\mathrm{DD}}$ and the pull-down transistor pulling down to ground. Using the strength abstraction, approximate the disturbed node voltage as\n$$\nV_{\\mathrm{read\\_rise}} = V_{\\mathrm{DD}} \\cdot \\frac{S_{\\mathrm{ax}}}{S_{\\mathrm{ax}} + S_{\\mathrm{pd}}},\n$$\nwhere $S_{\\mathrm{ax}}$ is the access transistor strength and $S_{\\mathrm{pd}}$ is the pull-down strength. Define the read margin proxy in volts as\n$$\nM_{\\mathrm{read}} = V_M - V_{\\mathrm{read\\_rise}}.\n$$\n- Define write-ability for writing a logical zero by the competition between the pull-up p-channel device (pulling up from $V_{\\mathrm{DD}}$) and the access transistor (pulling down to ground). Using the same strength abstraction, approximate the quasi-static settle point as\n$$\nV_{\\mathrm{write\\_settle}} = V_{\\mathrm{DD}} \\cdot \\frac{S_{\\mathrm{pu}}}{S_{\\mathrm{pu}} + S_{\\mathrm{ax}}},\n$$\nwhere $S_{\\mathrm{pu}}$ is the pull-up strength. Define the write margin proxy in volts as\n$$\nM_{\\mathrm{write}} = V_M - V_{\\mathrm{write\\_settle}}.\n$$\n- For the cross-coupled inverter strengths used to compute $V_M$, use the pull-down $\\beta_n$ of the memory cell n-channel and the pull-up $\\beta_p$ of the memory cell p-channel. For the access transistor strength, use its n-channel $\\beta_n$.\n\nProcess corners and parameter variation model:\n- Consider five process corners with independent mobility and threshold voltage variations for n-channel and p-channel devices:\n    - Typical–Typical (TT): $s_N = 1$, $s_P = 1$, $\\Delta V_{tn} = 0$, $\\Delta |V_{tp}| = 0$.\n    - Fast–Fast (FF): $s_N = 1 + \\alpha$, $s_P = 1 + \\alpha$, $\\Delta V_{tn} = -\\Delta V_t$, $\\Delta |V_{tp}| = -\\Delta V_t$.\n    - Slow–Slow (SS): $s_N = 1 - \\alpha$, $s_P = 1 - \\alpha$, $\\Delta V_{tn} = +\\Delta V_t$, $\\Delta |V_{tp}| = +\\Delta V_t$.\n    - Fast–N / Slow–P (FS): $s_N = 1 + \\alpha$, $s_P = 1 - \\alpha$, $\\Delta V_{tn} = -\\Delta V_t$, $\\Delta |V_{tp}| = +\\Delta V_t$.\n    - Slow–N / Fast–P (SF): $s_N = 1 - \\alpha$, $s_P = 1 + \\alpha$, $\\Delta V_{tn} = +\\Delta V_t$, $\\Delta |V_{tp}| = -\\Delta V_t$.\n- Here $s_N$ and $s_P$ scale the effective transconductance parameters $\\beta_n$ and $\\beta_p$ respectively via mobility changes, and the threshold variations are additive to the baseline magnitudes. Use fixed, globally applied numerical values $\\alpha = 0.25$ and $\\Delta V_t = 0.03$ in volts for all test cases.\n\nDevice strength formation:\n- The effective transconductance parameters for each device are given by\n$$\n\\beta_n = s_N \\cdot \\rho \\cdot \\frac{W}{L}, \\quad \\beta_p = s_P \\cdot \\frac{W}{L},\n$$\nwhere $\\rho$ is the baseline mobility ratio $\\mu_n/\\mu_p$ provided per test case, and $W/L$ are the geometry ratios provided per device in each test case.\n\nAlgorithmic tasks to implement:\n- For each test case, and for each of the five corners, compute\n    - Effective thresholds: $V_{tn,\\mathrm{eff}} = V_{tn,0} + \\Delta V_{tn}$, $|V_{tp,\\mathrm{eff}}| = |V_{tp,0}| + \\Delta |V_{tp}|$, with the base magnitudes given in each test case.\n    - Inverter trip point $V_M$ using the $\\beta$ values of the pull-down n-channel and pull-up p-channel devices and the effective thresholds.\n    - Strengths $S_{\\mathrm{pd}}$, $S_{\\mathrm{ax}}$, and $S_{\\mathrm{pu}}$ using the strength model $S = \\beta \\cdot \\max(V_{\\mathrm{eff}},0)^2$ with the appropriate effective thresholds.\n    - Read margin proxy $M_{\\mathrm{read}}$ and write margin proxy $M_{\\mathrm{write}}$ in volts.\n- Identify, for each test case, the corner that minimizes $M_{\\mathrm{read}}$ (worst read stability) and the corner that minimizes $M_{\\mathrm{write}}$ (worst write-ability). In case of exact ties, choose the smallest corner index.\n\nCorner index mapping that must be used in the output:\n- TT $\\to 0$, FF $\\to 1$, SS $\\to 2$, FS $\\to 3$, SF $\\to 4$.\n\nUnits:\n- All voltages must be treated in volts. Geometry ratios $W/L$ and mobility ratio $\\rho$ are dimensionless.\n\nTest suite:\nEach test case is a tuple containing the parameters $(W/L)_{\\mathrm{pd}}$, $(W/L)_{\\mathrm{pu}}$, $(W/L)_{\\mathrm{ax}}$, $\\rho$, $V_{\\mathrm{DD}}$, $V_{tn,0}$, $|V_{tp,0}|$, each of which is dimensionless except for voltages that are in volts. Use exactly the following four test cases:\n1. $\\left( 2.0, 1.0, 1.0, 2.5, 1.0, 0.35, 0.35 \\right)$.\n2. $\\left( 1.0, 1.0, 2.0, 2.0, 0.8, 0.35, 0.35 \\right)$.\n3. $\\left( 3.0, 0.8, 1.0, 2.5, 1.0, 0.32, 0.34 \\right)$.\n4. $\\left( 2.0, 1.2, 1.2, 2.5, 0.6, 0.38, 0.42 \\right)$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-integer list $[i_{\\mathrm{read}}, i_{\\mathrm{write}}]$ corresponding to the identified worst-case corner indices for read and write respectively for each test case. For example, a valid output format is [[0,4],[3,4],[2,2],[4,3]] but with the actual computed indices for the provided test suite.\n\nScientific realism and constraints:\n- The model must be implemented exactly as described and must not rely on any unmentioned empirical shortcuts. No user input is required; use the provided constants $\\alpha = 0.25$ and $\\Delta V_t = 0.03$ volts for all test cases and perform the computations deterministically as specified.",
            "solution": "The problem requires an analysis of a six-transistor (6T) Static Random-Access Memory (SRAM) cell's read stability and write-ability under various manufacturing process corners. The analysis is to be performed using a simplified, first-order model based on the Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) square-law behavior. For each of the provided test cases, we must identify the process corner that results in the minimum read margin and the minimum write margin.\n\nThe methodology involves a systematic calculation for each test case across five defined process corners: Typical-Typical (TT), Fast-Fast (FF), Slow-Slow (SS), Fast-N/Slow-P (FS), and Slow-N/Fast-P (SF). The corner indices are mapped as follows: TT $\\to 0$, FF $\\to 1$, SS $\\to 2$, FS $\\to 3$, SF $\\to 4$.\n\nFor a given test case, specified by the parameters $((W/L)_{\\mathrm{pd}}, (W/L)_{\\mathrm{pu}}, (W/L)_{\\mathrm{ax}}, \\rho, V_{\\mathrm{DD}}, V_{tn,0}, |V_{tp,0}|)$, and for each process corner, the following sequence of calculations is performed.\n\nFirst, the process corner variations are applied. Each corner is defined by a set of scaling factors, $s_N$ for n-channel mobility and $s_P$ for p-channel mobility, and threshold voltage shifts, $\\Delta V_{tn}$ and $\\Delta |V_{tp}|$. The global variation parameters are given as $\\alpha = 0.25$ and $\\Delta V_t = 0.03$ V. For instance, the FS corner corresponds to $s_N = 1 + \\alpha$, $s_P = 1 - \\alpha$, $\\Delta V_{tn} = -\\Delta V_t$, and $\\Delta |V_{tp}| = +\\Delta V_t$.\n\nThe effective threshold voltages for the n-channel and p-channel MOSFETs are calculated by adding the variations to the baseline values:\n$$V_{tn,\\mathrm{eff}} = V_{tn,0} + \\Delta V_{tn}$$\n$$|V_{tp,\\mathrm{eff}}| = |V_{tp,0}| + \\Delta |V_{tp}|$$\n\nNext, the effective transconductance parameters ($\\beta$) for the three critical transistors—pull-down (pd), pull-up (pu), and access (ax)—are determined. These parameters scale with the mobility factor $s$ and the device geometry $W/L$. The n-channel devices also include the baseline mobility ratio $\\rho = \\mu_n/\\mu_p$.\n$$\\beta_{\\mathrm{pd}} = s_N \\cdot \\rho \\cdot (W/L)_{\\mathrm{pd}}$$\n$$\\beta_{\\mathrm{pu}} = s_P \\cdot (W/L)_{\\mathrm{pu}}$$\n$$\\beta_{\\mathrm{ax}} = s_N \\cdot \\rho \\cdot (W/L)_{\\mathrm{ax}}$$\n\nWith these parameters, we can determine the trip point, $V_M$, of the cross-coupled inverters that form the SRAM latch. This is the voltage at which the inverter switches, and it is found by equating the saturation currents of the pull-up p-channel and pull-down n-channel transistors. Using the provided formula with $a = \\sqrt{\\beta_{\\mathrm{pd}}}$ and $b = \\sqrt{\\beta_{\\mathrm{pu}}}$:\n$$V_M = \\frac{b\\,(V_{\\mathrm{DD}} - |V_{tp,\\mathrm{eff}}|) + a\\, V_{tn,\\mathrm{eff}}}{a + b}$$\n\nThe next step is to compute the effective \"strength\" of each transistor, which is a proxy for its current-driving capability. The strength $S$ is modeled as $S = \\beta \\cdot \\max(V_{\\mathrm{eff}}, 0)^2$. The gate overdrive voltage $V_{\\mathrm{eff}}$ is approximated for a device whose gate is driven to a supply rail, which is the case during read and write operations. For an n-channel transistor with its gate at $V_{\\mathrm{DD}}$, the overdrive is $V_{\\mathrm{eff},n} = V_{\\mathrm{DD}} - V_{tn,\\mathrm{eff}}$. For a p-channel transistor with its gate at ground (and source at $V_{\\mathrm{DD}}$), the overdrive is $V_{\\mathrm{eff},p} = V_{\\mathrm{DD}} - |V_{tp,\\mathrm{eff}}|$. The strengths for the pull-down, pull-up, and access transistors are thus:\n$$S_{\\mathrm{pd}} = \\beta_{\\mathrm{pd}} \\cdot \\max(0, V_{\\mathrm{DD}} - V_{tn,\\mathrm{eff}})^2$$\n$$S_{\\mathrm{pu}} = \\beta_{\\mathrm{pu}} \\cdot \\max(0, V_{\\mathrm{DD}} - |V_{tp,\\mathrm{eff}}|)^2$$\n$$S_{\\mathrm{ax}} = \\beta_{\\mathrm{ax}} \\cdot \\max(0, V_{\\mathrm{DD}} - V_{tn,\\mathrm{eff}})^2$$\n\nNow, we evaluate the two key metrics: read margin and write margin.\n\nThe read margin, $M_{\\mathrm{read}}$, is a measure of the cell's stability during a read operation. When reading a stored '0', the access transistor and the pull-down transistor form a voltage divider that can cause the voltage on the storage node to rise. This voltage rise, $V_{\\mathrm{read\\_rise}}$, must not exceed the inverter's trip point $V_M$, otherwise the cell may flip. The voltage rise is modeled as:\n$$V_{\\mathrm{read\\_rise}} = V_{\\mathrm{DD}} \\cdot \\frac{S_{\\mathrm{ax}}}{S_{\\mathrm{ax}} + S_{\\mathrm{pd}}}$$\nThe read margin is then the difference:\n$$M_{\\mathrm{read}} = V_M - V_{\\mathrm{read\\_rise}}$$\nA smaller, or negative, $M_{\\mathrm{read}}$ indicates worse read stability.\n\nThe write margin, $M_{\\mathrm{write}}$, assesses the cell's write-ability. When writing a '0' into a cell storing a '1', the access transistor must overcome the pull-up transistor to pull the storage node voltage below the inverter's trip point. The quasi-static voltage to which the node settles in this contention is modeled as:\n$$V_{\\mathrm{write\\_settle}} = V_{\\mathrm{DD}} \\cdot \\frac{S_{\\mathrm{pu}}}{S_{\\mathrm{pu}} + S_{\\mathrm{ax}}}$$\nThe write margin is defined as:\n$$M_{\\mathrm{write}} = V_M - V_{\\mathrm{write\\_settle}}$$\nA smaller, or negative, $M_{\\mathrm{write}}$ indicates a more difficult or failed write operation.\n\nBy executing these calculations for all five process corners for a single test case, we obtain five values for $M_{\\mathrm{read}}$ and five for $M_{\\mathrm{write}}$. We then identify the corner index corresponding to the minimum value in each set. In case of a tie, the problem specifies selecting the smallest corner index. This procedure is repeated for all four test cases. The final output aggregates these worst-case corner indices into the specified list format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes SRAM cell read and write margins across process corners.\n    \"\"\"\n    # Global constants for process variation modeling\n    ALPHA = 0.25\n    DELTA_V_T = 0.03  # in Volts\n\n    # Process corner definitions as tuples of:\n    # (s_N_scaler, s_P_scaler, V_tn_shift_multiplier, V_tp_shift_multiplier)\n    # Corner indices: TT -> 0, FF -> 1, SS -> 2, FS -> 3, SF -> 4\n    CORNER_PARAMS = [\n        (1.0, 1.0, 0.0, 0.0),                              # TT: Typical-Typical\n        (1.0 + ALPHA, 1.0 + ALPHA, -1.0, -1.0),            # FF: Fast-Fast\n        (1.0 - ALPHA, 1.0 - ALPHA, 1.0, 1.0),              # SS: Slow-Slow\n        (1.0 + ALPHA, 1.0 - ALPHA, -1.0, 1.0),             # FS: Fast-N, Slow-P\n        (1.0 - ALPHA, 1.0 + ALPHA, 1.0, -1.0)              # SF: Slow-N, Fast-P\n    ]\n\n    # Test suite from the problem statement\n    # Each tuple contains:\n    # (W/L)_pd, (W/L)_pu, (W/L)_ax, rho, V_DD, V_tn0, |V_tp0|\n    test_cases = [\n        (2.0, 1.0, 1.0, 2.5, 1.0, 0.35, 0.35),\n        (1.0, 1.0, 2.0, 2.0, 0.8, 0.35, 0.35),\n        (3.0, 0.8, 1.0, 2.5, 1.0, 0.32, 0.34),\n        (2.0, 1.2, 1.2, 2.5, 0.6, 0.38, 0.42),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        w_l_pd, w_l_pu, w_l_ax, rho, v_dd, v_tn0, v_tp0 = case\n        \n        read_margins = []\n        write_margins = []\n\n        for s_n, s_p, dvtn_multiplier, dvtp_multiplier in CORNER_PARAMS:\n            # Step 1: Calculate effective threshold voltages for the current corner\n            delta_vtn = dvtn_multiplier * DELTA_V_T\n            delta_vtp = dvtp_multiplier * DELTA_V_T\n            v_tn_eff = v_tn0 + delta_vtn\n            v_tp_eff = v_tp0 + delta_vtp  # This represents |V_tp,eff|\n\n            # Step 2: Calculate effective transconductance parameters\n            beta_pd = s_n * rho * w_l_pd\n            beta_pu = s_p * w_l_pu\n            beta_ax = s_n * rho * w_l_ax\n\n            # Step 3: Calculate the inverter trip point V_M\n            a = np.sqrt(beta_pd)\n            b = np.sqrt(beta_pu)\n            \n            vm_numerator = b * (v_dd - v_tp_eff) + a * v_tn_eff\n            vm_denominator = a + b\n            # Denominator should not be zero for valid W/L ratios\n            v_m = vm_numerator / vm_denominator\n\n            # Step 4: Calculate device strengths (S)\n            v_eff_n = v_dd - v_tn_eff\n            v_eff_p = v_dd - v_tp_eff\n            \n            # The strength is zero if the device is off (V_eff <= 0)\n            s_pd = beta_pd * (max(0, v_eff_n))**2\n            s_ax = beta_ax * (max(0, v_eff_n))**2\n            s_pu = beta_pu * (max(0, v_eff_p))**2\n\n            # Step 5: Calculate read margin\n            s_ax_plus_s_pd = s_ax + s_pd\n            if s_ax_plus_s_pd == 0:\n                # If both access and pull-down transistors are off, the node voltage\n                # does not rise during a read.\n                v_read_rise = 0.0\n            else:\n                v_read_rise = v_dd * s_ax / s_ax_plus_s_pd\n            \n            m_read = v_m - v_read_rise\n            read_margins.append(m_read)\n\n            # Step 6: Calculate write margin\n            s_pu_plus_s_ax = s_pu + s_ax\n            if s_pu_plus_s_ax == 0:\n                # If both pull-up and access transistors are off, the node cannot be\n                # pulled down from V_DD. The write fails completely.\n                v_write_settle = v_dd\n            else:\n                v_write_settle = v_dd * s_pu / s_pu_plus_s_ax\n\n            m_write = v_m - v_write_settle\n            write_margins.append(m_write)\n        \n        # Step 7: Identify the corner with the minimum margin for read and write\n        # np.argmin() breaks ties by choosing the smallest index, as required.\n        worst_read_corner_idx = np.argmin(read_margins)\n        worst_write_corner_idx = np.argmin(write_margins)\n        \n        all_results.append([int(worst_read_corner_idx), int(worst_write_corner_idx)])\n    \n    # Format the output string to exactly match the problem specification\n    results_str_list = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    final_output_str = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "To achieve the highest accuracy in predicting memory yield, designers often move beyond deterministic corner analysis to a full statistical treatment of variability. This advanced practice introduces the concept of probabilistic design, where key performance metrics are modeled as random variables rather than fixed values. This exercise () asks you to calculate the write failure probability by treating both the cell's required write trip point ($W$) and the available bitline drive ($B$) as statistical distributions. Completing this task will provide a practical understanding of how statistical methods are used to quantify and manage the risk of failure in nano-scale memory arrays.",
            "id": "4300036",
            "problem": "An Static Random Access Memory (SRAM) write operation succeeds when the bitcell undergoes a state flip under the applied bitline and wordline stimulus. Define the write trip point as a random variable $W$ representing the minimum bitline differential (in millivolts) required to guarantee a successful write under stochastic process-voltage-temperature variations. Let the available bitline drive be represented by a random variable $B$ (in millivolts), which models the actual differential delivered by the write driver under the same variations. A write failure occurs if and only if the event $W \\gt B$ happens for a given cell access.\n\nStarting from the foundational probability definitions for independent random variables, and the cumulative distribution function definition, derive an algorithm to compute the write failure probability $P\\left(W \\gt B\\right)$ for a design in which $W$ and $B$ may follow any of the following parametric distributions:\n- Normal distribution with mean $\\mu$ and standard deviation $\\sigma$.\n- Lognormal distribution with logarithmic parameters $\\mu_{\\ln}$ and $\\sigma_{\\ln}$ such that if $X \\sim \\mathcal{N}\\!\\left(\\mu_{\\ln}, \\sigma_{\\ln}^2\\right)$ then $W = e^X$.\n- Finite Gaussian mixture for $W$: $W \\sim \\sum_{i=1}^K \\alpha_i \\,\\mathcal{N}\\!\\left(\\mu_i, \\sigma_i^2\\right)$ with nonnegative weights $\\alpha_i$ that sum to $1$.\n- Deterministic bitline drive: $B = d$ for some constant $d$.\n\nUse only the axioms of probability, the definition of independence, and the definitions of probability density functions and cumulative distribution functions as the starting point. Do not assume any formula for the target probability a priori, and do not assume shortcuts; the algorithm must be derived from these base definitions.\n\nAssume $W$ and $B$ are independent. The answer must be reported as a decimal fraction for each test case. No physical units should be printed in the output. All angles are irrelevant in this problem. The final program must compute the write failure probability for the following test suite and produce the specified output format.\n\nTest suite:\n1. $W \\sim \\mathcal{N}\\!\\left(\\mu = 120,\\ \\sigma = 20\\right)$ and $B = d = 120$.\n2. $W$ is lognormal with $\\mu_{\\ln} = \\ln\\!\\left(100\\right)$ and $\\sigma_{\\ln} = 0.25$, and $B = d = 130$.\n3. $W$ is a Gaussian mixture: $\\alpha_1 = 0.9$, $\\mu_1 = 110$, $\\sigma_1 = 15$ and $\\alpha_2 = 0.1$, $\\mu_2 = 160$, $\\sigma_2 = 10$, and $B = d = 130$.\n4. $W \\sim \\mathcal{N}\\!\\left(\\mu = 150,\\ \\sigma = 25\\right)$ and $B \\sim \\mathcal{N}\\!\\left(\\mu = 140,\\ \\sigma = 10\\right)$.\n5. $W \\sim \\mathcal{N}\\!\\left(\\mu = 100,\\ \\sigma = 5\\right)$ and $B = d = 1000000$.\n\nInterpretation and scientific realism notes:\n- The write trip point $W$ models the minimum bitline differential needed to flip the cell; variation induces randomness through device mismatch and supply fluctuations.\n- The available bitline drive $B$ accounts for the effective delivered differential, which can be modeled as deterministic or random depending on driver and supply conditions.\n- Independence of $W$ and $B$ is a common approximation when global variations are addressed through design guard-bands and remaining local variations dominate.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each probability must be rounded to exactly $6$ decimal places. For example, the output format must be of the form $[x_1,x_2,x_3,x_4,x_5]$ where each $x_i$ is a decimal with exactly $6$ digits after the decimal point.",
            "solution": "The user wants to compute the write failure probability of an SRAM cell, defined as $P(W \\gt B)$, where $W$ is the write trip point and $B$ is the available bitline drive. The problem requires a derivation of the computation algorithm from foundational probability principles, assuming $W$ and $B$ are independent random variables.\n\n### Foundational Derivation of Failure Probability\n\nLet $W$ and $B$ be independent random variables with probability density functions (PDFs) $f_W(w)$ and $f_B(b)$, respectively. Their joint PDF is $f_{W,B}(w, b) = f_W(w) f_B(b)$ due to independence.\n\nThe probability of the write failure event, $W \\gt B$, is found by integrating the joint PDF over the region in the $(w,b)$ plane where this inequality holds.\n$$ P(W \\gt B) = \\iint_{w \\gt b} f_{W,B}(w, b) \\,dw \\,db = \\iint_{w \\gt b} f_W(w) f_B(b) \\,dw \\,db $$\n\nWe can express this double integral as an iterated integral. Let's integrate over all possible values of $B$, and for each value $b$, integrate over the values of $W$ that satisfy the failure condition, i.e., $w \\gt b$.\n\n$$ P(W \\gt B) = \\int_{-\\infty}^{\\infty} f_B(b) \\left( \\int_{b}^{\\infty} f_W(w) \\,dw \\right) db $$\n\nThe inner integral, $\\int_{b}^{\\infty} f_W(w) \\,dw$, is the probability that the random variable $W$ is greater than some value $b$. This is the definition of the complementary cumulative distribution function (CCDF), or survival function, of $W$, which we denote as $\\bar{F}_W(b)$. The CCDF is related to the cumulative distribution function (CDF), $F_W(b) = P(W \\leq b)$, by $\\bar{F}_W(b) = 1 - F_W(b)$.\n\nSubstituting this into our expression yields the general formula for the failure probability:\n$$ P(W \\gt B) = \\int_{-\\infty}^{\\infty} \\bar{F}_W(b) f_B(b) \\,db = \\int_{-\\infty}^{\\infty} (1 - F_W(b)) f_B(b) \\,db $$\n\nThis formula serves as the basis for our algorithm. We now specialize it for the distributions given in the problem.\n\n### Case 1: Deterministic Bitline Drive ($B = d$)\n\nWhen the bitline drive $B$ is a deterministic constant $d$, its distribution is not continuous. The \"PDF\" can be formally described by a Dirac delta function, $f_B(b) = \\delta(b - d)$. Substituting this into the general formula:\n$$ P(W \\gt d) = \\int_{-\\infty}^{\\infty} \\bar{F}_W(b) \\delta(b - d) \\,db $$\nUsing the sifting property of the Dirac delta function, which states $\\int g(x) \\delta(x-x_0) dx = g(x_0)$, we get:\n$$ P(W \\gt d) = \\bar{F}_W(d) = 1 - F_W(d) $$\nThis confirms the intuitive result that for a fixed drive $d$, the failure probability is simply the probability that the required trip point $W$ exceeds $d$. We now apply this to the specified distributions for $W$.\n\n#### Subcase 1.1: $W \\sim \\mathcal{N}(\\mu, \\sigma^2)$\nThe CDF of a Normal distribution is $F_W(d) = \\Phi\\left(\\frac{d - \\mu}{\\sigma}\\right)$, where $\\Phi(z)$ is the CDF of the standard normal distribution $\\mathcal{N}(0,1)$. The failure probability is:\n$$ P(W \\gt d) = 1 - \\Phi\\left(\\frac{d - \\mu}{\\sigma}\\right) $$\nThis is the survival function (SF) of the normal distribution.\n\n#### Subcase 1.2: $W$ is Lognormal\n$W$ is given by $W = e^X$, where $X \\sim \\mathcal{N}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$. The failure condition $W \\gt d$ is equivalent to $e^X \\gt d$. Since $\\ln(\\cdot)$ is a strictly increasing function, this is equivalent to $X \\gt \\ln(d)$ (assuming $d \\gt 0$, as is physically required).\nThe problem thus reduces to computing the probability that a normally distributed variable $X$ exceeds a threshold.\n$$ P(W \\gt d) = P(X \\gt \\ln(d)) = 1 - F_X(\\ln(d)) = 1 - \\Phi\\left(\\frac{\\ln(d) - \\mu_{\\ln}}{\\sigma_{\\ln}}\\right) $$\n\n#### Subcase 1.3: $W$ is a Finite Gaussian Mixture\nThe distribution of $W$ is given by $W \\sim \\sum_{i=1}^K \\alpha_i \\,\\mathcal{N}(\\mu_i, \\sigma_i^2)$ with weights $\\alpha_i \\ge 0$ and $\\sum_{i=1}^K \\alpha_i = 1$. The PDF is $f_W(w) = \\sum_{i=1}^K \\alpha_i f_i(w)$, where $f_i(w)$ is the PDF of $\\mathcal{N}(\\mu_i, \\sigma_i^2)$.\nBy the linearity of integration, the CDF is a weighted sum of the component CDFs:\n$$ F_W(d) = \\int_{-\\infty}^d f_W(w) \\,dw = \\sum_{i=1}^K \\alpha_i \\int_{-\\infty}^d f_i(w) \\,dw = \\sum_{i=1}^K \\alpha_i F_i(d) $$\nThe failure probability is therefore:\n$$ P(W \\gt d) = 1 - F_W(d) = 1 - \\sum_{i=1}^K \\alpha_i F_i(d) = \\sum_{i=1}^K \\alpha_i (1 - F_i(d)) = \\sum_{i=1}^K \\alpha_i \\bar{F}_i(d) $$\nThis means the total failure probability is the weighted average of the failure probabilities of each normal component in the mixture.\n\n### Case 2: Random Bitline Drive ($B$ follows a distribution)\n\nThe problem provides a case where both $W$ and $B$ are random and normally distributed.\n$W \\sim \\mathcal{N}(\\mu_W, \\sigma_W^2)$ and $B \\sim \\mathcal{N}(\\mu_B, \\sigma_B^2)$.\n\nThe failure event is $W \\gt B$, which is equivalent to $W - B \\gt 0$. Let's define a new random variable $D = W - B$. Since $W$ and $B$ are independent normal random variables, their difference $D$ is also a normal random variable.\nThe mean of $D$ is $E[D] = E[W] - E[B] = \\mu_W - \\mu_B$.\nThe variance of $D$, due to independence, is $\\text{Var}(D) = \\text{Var}(W) + \\text{Var}(-B) = \\text{Var}(W) + (-1)^2 \\text{Var}(B) = \\sigma_W^2 + \\sigma_B^2$.\nSo, the distribution of the difference is $D \\sim \\mathcal{N}(\\mu_D, \\sigma_D^2)$, where $\\mu_D = \\mu_W - \\mu_B$ and $\\sigma_D^2 = \\sigma_W^2 + \\sigma_B^2$.\n\nThe failure probability calculation is now transformed into finding $P(D \\gt 0)$:\n$$ P(W \\gt B) = P(D \\gt 0) = 1 - F_D(0) = 1 - \\Phi\\left(\\frac{0 - \\mu_D}{\\sigma_D}\\right) = 1 - \\Phi\\left(\\frac{-(\\mu_W - \\mu_B)}{\\sqrt{\\sigma_W^2 + \\sigma_B^2}}\\right) $$\nUsing the symmetry property $\\Phi(-z) = 1 - \\Phi(z)$, this simplifies to:\n$$ P(W \\gt B) = \\Phi\\left(\\frac{\\mu_W - \\mu_B}{\\sqrt{\\sigma_W^2 + \\sigma_B^2}}\\right) $$\nThis can also be computed as the survival function of $D$ at $0$.\n\n### Algorithm for Test Cases\n\nThe derived formulas directly yield the algorithm for each test case.\n\n1.  $W \\sim \\mathcal{N}(\\mu = 120, \\sigma = 20), B = d = 120$: Use Subcase 1.1. $P(W \\gt 120) = 1 - \\Phi\\left(\\frac{120-120}{20}\\right) = 1 - \\Phi(0) = 0.5$.\n2.  $W$ lognormal $(\\mu_{\\ln} = \\ln(100), \\sigma_{\\ln} = 0.25), B = d = 130$: Use Subcase 1.2. $P(W \\gt 130) = 1 - \\Phi\\left(\\frac{\\ln(130) - \\ln(100)}{0.25}\\right)$.\n3.  $W$ Gaussian mixture, $B = d = 130$: Use Subcase 1.3. $P(W \\gt 130) = 0.9 \\times \\bar{F}_{\\mathcal{N}(110, 15^2)}(130) + 0.1 \\times \\bar{F}_{\\mathcal{N}(160, 10^2)}(130)$.\n4.  $W \\sim \\mathcal{N}(\\mu = 150, \\sigma = 25), B \\sim \\mathcal{N}(\\mu = 140, \\sigma = 10)$: Use Case 2. Compute $P(D \\gt 0)$ for $D \\sim \\mathcal{N}(\\mu_D = 150 - 140, \\sigma_D^2 = 25^2 + 10^2)$.\n5.  $W \\sim \\mathcal{N}(\\mu = 100, \\sigma = 5), B = d = 1000000$: Use Subcase 1.1. $P(W \\gt 1000000) = 1 - \\Phi\\left(\\frac{1000000-100}{5}\\right)$. This probability will be vanishingly small.\n\nThe implementation will use `scipy.stats` functions, which provide numerically stable calculations for the survival functions of these distributions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, lognorm\n\ndef calculate_failure_prob(W_params, B_params):\n    \"\"\"\n    Computes the write failure probability P(W > B) based on the distributions of W and B.\n    \"\"\"\n    b_dist = B_params[\"dist\"]\n    w_dist = W_params[\"dist\"]\n\n    # Case 1: B is a deterministic constant\n    if b_dist == \"deterministic\":\n        d = B_params[\"d\"]\n        \n        # Subcase 1.1: W is Normal\n        if w_dist == \"normal\":\n            mu, sigma = W_params[\"mu\"], W_params[\"sigma\"]\n            # P(W > d) is the survival function of W at d\n            return norm.sf(d, loc=mu, scale=sigma)\n            \n        # Subcase 1.2: W is Lognormal\n        elif w_dist == \"lognormal\":\n            mu_ln, sigma_ln = W_params[\"mu_ln\"], W_params[\"sigma_ln\"]\n            # To use scipy's lognorm(s, loc, scale), which is for variables\n            # exp(s*Z + log(scale)) + loc where Z ~ N(0,1), we set:\n            # s = sigma_ln\n            # loc = 0\n            # scale = exp(mu_ln)\n            scale = np.exp(mu_ln)\n            return lognorm.sf(d, s=sigma_ln, loc=0, scale=scale)\n\n        # Subcase 1.3: W is a Gaussian Mixture\n        elif w_dist == \"gaussian_mixture\":\n            prob = 0.0\n            # P(W > d) = sum(alpha_i * P(W_i > d))\n            for comp in W_params[\"components\"]:\n                alpha, mu, sigma = comp[\"alpha\"], comp[\"mu\"], comp[\"sigma\"]\n                prob += alpha * norm.sf(d, loc=mu, scale=sigma)\n            return prob\n\n    # Case 2: B is random and Normal\n    elif b_dist == \"normal\":\n        # From the problem, this case only occurs when W is also Normal\n        if w_dist == \"normal\":\n            mu_W, sigma_W = W_params[\"mu\"], W_params[\"sigma\"]\n            mu_B, sigma_B = B_params[\"mu\"], B_params[\"sigma\"]\n            \n            # P(W > B) is equivalent to P(W - B > 0).\n            # Let D = W - B. Since W and B are independent Normal variables,\n            # D is also a Normal variable.\n            # E[D] = E[W] - E[B]\n            mu_D = mu_W - mu_B\n            # Var(D) = Var(W) + Var(B) due to independence\n            sigma_D_sq = sigma_W**2 + sigma_B**2\n            sigma_D = np.sqrt(sigma_D_sq)\n            \n            # We need to compute P(D > 0). This is the survival function of D at 0.\n            return norm.sf(0, loc=mu_D, scale=sigma_D)\n\n    # Fallback for unhandled distribution combinations\n    raise NotImplementedError(f\"Calculation for W={w_dist} and B={b_dist} is not implemented.\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. W ~ N(120, 20), B = 120\n        {\n            \"W\": {\"dist\": \"normal\", \"mu\": 120, \"sigma\": 20},\n            \"B\": {\"dist\": \"deterministic\", \"d\": 120}\n        },\n        # 2. W is lognormal(mu_ln=ln(100), sigma_ln=0.25), B = 130\n        {\n            \"W\": {\"dist\": \"lognormal\", \"mu_ln\": np.log(100), \"sigma_ln\": 0.25},\n            \"B\": {\"dist\": \"deterministic\", \"d\": 130}\n        },\n        # 3. W is a Gaussian mixture, B = 130\n        {\n            \"W\": {\"dist\": \"gaussian_mixture\", \"components\": [\n                {\"alpha\": 0.9, \"mu\": 110, \"sigma\": 15},\n                {\"alpha\": 0.1, \"mu\": 160, \"sigma\": 10}\n            ]},\n            \"B\": {\"dist\": \"deterministic\", \"d\": 130}\n        },\n        # 4. W ~ N(150, 25), B ~ N(140, 10)\n        {\n            \"W\": {\"dist\": \"normal\", \"mu\": 150, \"sigma\": 25},\n            \"B\": {\"dist\": \"normal\", \"mu\": 140, \"sigma\": 10}\n        },\n        # 5. W ~ N(100, 5), B = 1,000,000\n        {\n            \"W\": {\"dist\": \"normal\", \"mu\": 100, \"sigma\": 5},\n            \"B\": {\"dist\": \"deterministic\", \"d\": 1000000}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        prob = calculate_failure_prob(case[\"W\"], case[\"B\"])\n        results.append(prob)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}