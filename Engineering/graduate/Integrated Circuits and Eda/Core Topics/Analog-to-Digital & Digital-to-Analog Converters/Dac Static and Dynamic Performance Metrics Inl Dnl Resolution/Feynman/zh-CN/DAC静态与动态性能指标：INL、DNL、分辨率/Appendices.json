{
    "hands_on_practices": [
        {
            "introduction": "本练习将为任何数模转换器（DAC）建立基本性能极限。我们将从一个理想DAC出发，利用基本原理推导两个关键参数：最低有效位（LSB）的大小和理想的量化噪声功率。这项练习至关重要，因为它将DAC的分辨率（位数，$N$）与其精度和理论噪声基底直接联系起来，为所有后续的DAC性能分析奠定了基石。",
            "id": "4262893",
            "problem": "考虑一个理想的 $N$ 位数模转换器 (DAC)，其输出电平在 $V_{\\mathrm{FS}} = 1\\ \\mathrm{V}$ 的全幅范围内均匀分布。采用标准均匀中置式量化器模型，其中 $2^{N}$ 个可表示的输出电平将全幅范围 $V_{\\mathrm{FS}}$ 划分为 $2^{N}$ 个等宽的区间。仅使用第一性原理和量化理论的核心定义，推导最低有效位 (LSB) 步长大小和 DAC 输出端的理想量化误差功率，并假设随着时间的推移，量化误差样本在其支撑集上是均匀分布的。然后，计算：\n- 以 $\\mu\\mathrm{V}$ 为单位表示的 LSB 大小，以及\n- 以 $\\mathrm{V}^{2}$ 为单位表示的相应理想量化噪声功率，\n两者都应是关于 $N$ 的符号函数。请将最终答案表示为关于 $N$ 的符号表达式，不要进行四舍五入。",
            "solution": "该问题要求推导理想 $N$ 位数模转换器 (DAC) 的两个基本指标：最低有效位 (LSB) 的大小和理想量化噪声的功率。推导将按规定从第一性原理出发。\n\n首先，我们确定 LSB 步长，记为 $\\Delta$。一个 $N$ 位转换器具有 $2^N$ 个不同的数字输入码，这些输入码映射到 $2^N$ 个离散的模拟输出电压电平。问题规定，这 $2^N$ 个电平将全幅范围 $V_{\\mathrm{FS}}$ 均匀划分为 $2^N$ 个大小相等的量化区间。根据定义，这样一个区间的宽度就是 LSB 步长。这引出以下关系：\n$$ \\Delta = \\frac{V_{\\mathrm{FS}}}{2^N} $$\n给定全幅范围为 $V_{\\mathrm{FS}} = 1\\ \\mathrm{V}$。代入该值，以伏特为单位的 LSB 步长为：\n$$ \\Delta = \\frac{1}{2^N}\\ \\mathrm{V} $$\n问题的第一个部分要求以微伏 ($\\mu\\mathrm{V}$) 表示 LSB 的大小。从伏特到微伏的换算关系是 $1\\ \\mathrm{V} = 10^6\\ \\mu\\mathrm{V}$。应用此转换因子，我们得到 LSB 大小作为 $N$ 的符号函数：\n$$ \\Delta_{\\mu\\mathrm{V}} = \\left( \\frac{1}{2^N}\\ \\mathrm{V} \\right) \\times \\left( \\frac{10^6\\ \\mu\\mathrm{V}}{1\\ \\mathrm{V}} \\right) = \\frac{10^6}{2^N} $$\n该表达式代表以微伏为单位的 LSB 大小。\n\n接下来，我们推导理想量化噪声功率 $P_q$。量化误差 $e_q$ 是被表示的连续值信号与量化器产生的离散输出电平之间的差值。对于指定的均匀中置式量化器模型，离散输出电平位于每个量化区间的中心。因此，量化误差被限制在对称区间 $[-\\frac{\\Delta}{2}, +\\frac{\\Delta}{2}]$ 内。\n\n该问题采用了标准假设，即量化误差 $e_q$ 是一个在其支撑区间上均匀分布的随机变量。因此，误差的概率密度函数 (PDF)，记为 $f(e_q)$，在此区间上为常数，在其他地方为零：\n$$\nf(e_q) =\n\\begin{cases}\n\\frac{1}{(\\Delta/2) - (-\\Delta/2)} = \\frac{1}{\\Delta}  \\text{for } -\\frac{\\Delta}{2} \\le e_q \\le \\frac{\\Delta}{2} \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n理想量化噪声功率 $P_q$ 定义为量化误差的均方值 $E[e_q^2]$。对于像这样的零均值分布，均方值等于方差。我们通过对 $e_q^2$ 与 PDF 的乘积在 $e_q$ 的所有可能值上进行积分来计算它：\n$$ P_q = E[e_q^2] = \\int_{-\\infty}^{\\infty} e_q^2 f(e_q) \\, de_q $$\n将均匀 PDF 代入积分，得到：\n$$ P_q = \\int_{-\\Delta/2}^{\\Delta/2} e_q^2 \\left( \\frac{1}{\\Delta} \\right) \\, de_q $$\n我们继续计算这个基本积分：\n$$ P_q = \\frac{1}{\\Delta} \\left[ \\frac{e_q^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} $$\n$$ P_q = \\frac{1}{3\\Delta} \\left[ \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right] $$\n$$ P_q = \\frac{1}{3\\Delta} \\left[ \\frac{\\Delta^3}{8} - \\left(-\\frac{\\Delta^3}{8}\\right) \\right] = \\frac{1}{3\\Delta} \\left[ \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right] $$\n$$ P_q = \\frac{1}{3\\Delta} \\left( 2 \\cdot \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{4} \\right) $$\n这可以简化为量化噪声功率的标准结果：\n$$ P_q = \\frac{\\Delta^2}{12} $$\n最后，为了将 $P_q$ 表示为 $N$ 的符号函数，我们将我们的表达式 $\\Delta = \\frac{V_{\\mathrm{FS}}}{2^N}$（其中 $V_{\\mathrm{FS}} = 1\\ \\mathrm{V}$）代入：\n$$ P_q = \\frac{1}{12} \\left( \\frac{1}{2^N} \\right)^2 = \\frac{1}{12 \\cdot (2^N)^2} $$\n$$ P_q = \\frac{1}{12 \\cdot 2^{2N}} $$\n该量的单位是 $\\mathrm{V}^2$，这对于均方电压是合适的，它对应于一个归一化 $1\\ \\Omega$ 系统中的功率。\n\n总之，所要求的两个关于 $N$ 的符号函数是：\n1. 以 $\\mu\\mathrm{V}$ 为单位的 LSB 大小：$\\frac{10^6}{2^N}$\n2. 以 $\\mathrm{V}^2$ 为单位的理想量化噪声功率：$\\frac{1}{12 \\cdot 2^{2N}}$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{10^6}{2^N}  \\frac{1}{12 \\cdot 2^{2N}} \\end{pmatrix}}$$"
        },
        {
            "introduction": "现实世界中的DAC并非理想器件，会存在静态误差。本练习提供了一个实际场景：给定一组测量的积分非线性（INL）数据点，你的任务是运用INL与微分非线性（DNL）之间的基本关系来计算DNL，并诊断一个关键性能问题——非单调性。这项实践将提高你解读技术规格数据的能力，并理解这两个关键静态指标是如何内在地联系在一起的。",
            "id": "4262902",
            "problem": "一个分辨率为 $N$ 位的数模转换器 (DAC) 在稳态条件下测量时表现出静态非线性。设 $V_{\\text{actual}}(k)$ 表示在编码 $k \\in \\{0,1,\\dots,2^{N}-1\\}$ 下测得的 DAC 输出，端点拟合参考线定义为 $V_{\\text{fit}}(k) = V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$，其中 $\\text{LSB}_{e} = \\dfrac{V_{\\text{actual}}(2^{N}-1) - V_{\\text{actual}}(0)}{2^{N}-1}$。定义积分非线性 (INL) 为 $I(k) = \\dfrac{V_{\\text{actual}}(k) - V_{\\text{fit}}(k)}{\\text{LSB}_{e}}$，微分非线性 (DNL) 为 $D(k) = \\dfrac{V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)}{\\text{LSB}_{e}} - 1$（对于 $k \\geq 1$）。这些量都已根据端点拟合的最低有效位 (LSB) 进行了归一化，因此它们的单位是 $\\mathrm{LSB}$。\n\n考虑一个 $N=12$ 位的 DAC，其在一个疑似非单调区域附近的测得积分非线性 (INL) 值（已归一化到 $\\text{LSB}_{e}$）在以下连续编码处给出：\n- $k=2045$: $I(2045)=0.1843$\n- $k=2046$: $I(2046)=0.1402$\n- $k=2047$: $I(2047)=0.0975$\n- $k=2048$: $I(2048)=-1.2389$\n- $k=2049$: $I(2049)=-1.2103$\n- $k=2050$: $I(2050)=-1.1837$\n\n仅从上述 INL 和 DNL 的端点拟合定义出发，通过对测得的 INL 进行离散微分，来确定在 $k \\in \\{2046,2047,2048,2049,2050\\}$ 范围内的最小可能微分非线性。然后，从第一性原理出发解释推理过程，评估是否有任何 DNL 值必须低于 $-1$ $\\mathrm{LSB}$。报告最小 DNL 的单一数值（以 $\\mathrm{LSB}$ 为单位）。将您的最终数值答案四舍五入至四位有效数字，并以 $\\mathrm{LSB}$ 为单位表示。",
            "solution": "任务是根据一组给定的积分非线性 $I(k)$ 值，求出在指定数字编码 $k$ 范围内的最小微分非线性 $D(k)$。$D(k)$ 和 $I(k)$ 之间的关系必须从所提供的定义中推导出来。\n\nINL 的定义如下：\n$$I(k) = \\frac{V_{\\text{actual}}(k) - V_{\\text{fit}}(k)}{\\text{LSB}_{e}}$$\n其中 $V_{\\text{actual}}(k)$ 是在编码 $k$ 处测得的输出电压，而 $V_{\\text{fit}}(k)$ 是端点拟合线上的理想电压。$\\text{LSB}_{e}$ 是端点拟合线的最低有效位大小。根据这个定义，我们可以将实际输出电压表示为：\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{fit}}(k)$$\n端点拟合线定义为 $V_{\\text{fit}}(k) = V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$。将此代入 $V_{\\text{actual}}(k)$ 的表达式，得到：\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$$\n对于编码 $k$（其中 $k \\ge 1$），DNL 的定义如下：\n$$D(k) = \\frac{V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)}{\\text{LSB}_{e}} - 1$$\n为了建立 $D(k)$ 和 $I(k)$ 之间的关系，我们首先使用上面推导出的 $V_{\\text{actual}}(k)$ 表达式来表示电压阶跃 $V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)$。对于编码 $k$，我们有：\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$$\n对于编码 $k-1$，我们有：\n$$V_{\\text{actual}}(k-1) = I(k-1) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + (k-1) \\cdot \\text{LSB}_{e}$$\n从第一个方程中减去第二个方程，得到电压差，注意 $V_{\\text{actual}}(0)$ 项会抵消：\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) \\cdot \\text{LSB}_{e} - I(k-1) \\cdot \\text{LSB}_{e}) + (k \\cdot \\text{LSB}_{e} - (k-1) \\cdot \\text{LSB}_{e})$$\n提取公因式 $\\text{LSB}_{e}$：\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + (k - (k-1)) \\cdot \\text{LSB}_{e}$$\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + 1 \\cdot \\text{LSB}_{e}$$\n现在，我们将这个表达式代回 $D(k)$ 的定义中：\n$$D(k) = \\frac{(I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + \\text{LSB}_{e}}{\\text{LSB}_{e}} - 1$$\n分子除以 $\\text{LSB}_{e}$：\n$$D(k) = (I(k) - I(k-1)) + 1 - 1$$\n这简化为 DNL 和 INL 之间的基本关系，它表示一个离散微分：\n$$D(k) = I(k) - I(k-1)$$\n现在我们可以利用这个关系，使用提供的 INL 数据来计算指定编码 $k \\in \\{2046, 2047, 2048, 2049, 2050\\}$ 的 DNL 值。\n\n给定的 INL 数据点（单位为 $\\mathrm{LSB}_{e}$）是：\n$I(2045) = 0.1843$\n$I(2046) = 0.1402$\n$I(2047) = 0.0975$\n$I(2048) = -1.2389$\n$I(2049) = -1.2103$\n$I(2050) = -1.1837$\n\n我们按如下方式计算 DNL 值：\n对于 $k=2046$：\n$D(2046) = I(2046) - I(2045) = 0.1402 - 0.1843 = -0.0441$\n对于 $k=2047$：\n$D(2047) = I(2047) - I(2046) = 0.0975 - 0.1402 = -0.0427$\n对于 $k=2048$：\n$D(2048) = I(2048) - I(2047) = -1.2389 - 0.0975 = -1.3364$\n对于 $k=2049$：\n$D(2049) = I(2049) - I(2048) = -1.2103 - (-1.2389) = -1.2103 + 1.2389 = 0.0286$\n对于 $k=2050$：\n$D(2050) = I(2050) - I(2049) = -1.1837 - (-1.2103) = -1.1837 + 1.2103 = 0.0266$\n\n计算出的 DNL 值（单位为 $\\mathrm{LSB}_{e}$）是：\n$D(2046) = -0.0441$\n$D(2047) = -0.0427$\n$D(2048) = -1.3364$\n$D(2049) = 0.0286$\n$D(2050) = 0.0266$\n\n题目要求在指定范围内的最小可能 DNL。通过比较计算出的值，最小值为：\n$$\\min\\{D(k)\\} = D(2048) = -1.3364$$\n题目还要求评估是否有 DNL 值必须低于 $-1$ $\\mathrm{LSB}$。如果一个 DAC 对于所有编码的 DNL 始终大于或等于 $-1$ LSB（即 $D(k) \\geq -1$），则可以保证其单调性。小于 $-1$ 的 DNL 值表示非单调行为，即当数字输入编码增加时，模拟输出电压反而减小。在本例中，编码 $k=2048$ 处的 DNL 是 $D(2048) = -1.3364$，小于 $-1$。这证实了该 DAC 在此转换处是非单调的。从编码 $2047$ 到 $2048$ 的电压阶跃为 $V_{\\text{actual}}(2048) - V_{\\text{actual}}(2047) = (D(2048) + 1) \\cdot \\text{LSB}_e = (-1.3364 + 1) \\cdot \\text{LSB}_e = -0.3364 \\cdot \\text{LSB}_e$，这是一个负向变化。\n\n最后的任务是报告最小 DNL 的单一数值，并四舍五入到四位有效数字。最小 DNL 是 $-1.3364$。四舍五入到四位有效数字得到 $-1.336$。",
            "answer": "$$\n\\boxed{-1.336}\n$$"
        },
        {
            "introduction": "DAC的性能不仅取决于其静态精度，其在处理时变信号时的行为也同样至关重要。这个高级仿真练习搭建了从静态非线性到动态性能的桥梁。你将为一个具有给定INL特性的DAC建模，用数字正弦波驱动它，并进行频谱分析以预测由此产生的谐波失真。这项实践有助于你深入理解静态误差是如何破坏动态信号的，这是混合信号系统设计中的一个核心概念。",
            "id": "4262912",
            "problem": "一个分辨率为 $N$ 位的单极性数模转换器（DAC）将数字输入码 $m \\in \\{0,1,\\dots,2^N-1\\}$ 映射为模拟输出。设满量程输出归一化为 $V_{\\mathrm{FS}} = 1$（无量纲单位），因此理想的最低有效位大小为 $V_{\\mathrm{LSB}} = \\dfrac{V_{\\mathrm{FS}}}{2^N-1}$。一个测得的最佳拟合积分非线性度（INL）以无量纲数组 $E[m]$ 的形式提供，单位为最低有效位（LSB），适用于每个码 $m$。实际的静态传输特性建模为\n$$\nv(m) = V_{\\mathrm{LSB}} \\cdot \\big(m + E[m]\\big).\n$$\n考虑一个离散时间周期性激励，该激励以频率为 $f_0$ 的量化数字正弦波驱动DAC，且与记录长度相干。设记录每个周期有 $L$ 个采样点，并假设在 $L$ 个采样点内有 $k$ 个正弦周期。输入码序列 $m[n]$ 是通过量化一个中心化的正弦波形成的，其幅值以码值单位指定为半量程范围的一部分 $a$：\n$$\nm_{\\mathrm{mid}} = \\dfrac{2^N - 1}{2}, \\quad A_{\\mathrm{codes}} = a \\cdot \\dfrac{2^N - 1}{2},\n$$\n$$\nm[n] = \\mathrm{clip}\\Big(\\mathrm{round}\\big(m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\cdot \\sin(2\\pi k n / L)\\big),\\,0,\\,2^N-1\\Big),\n$$\n其中 $n = 0,1,\\dots,L-1$。相应的离散时间DAC输出序列为\n$$\nx[n] = V_{\\mathrm{LSB}} \\cdot \\big(m[n] + E[m[n]]\\big).\n$$\n为近似连续时间零阶保持（ZOH）输出，使用离散时间卷积。首先通过插零将 $x[n]$ 上采样一个整数因子 $U$ 以获得 $x_{\\uparrow}[n]$，然后与一个长度为 $U$、系数为单位1的矩形核 $h[n]$ 进行卷积：\n$$\nx_{\\uparrow}[n] = \\begin{cases}\nx[n/U],  \\text{若 } n \\text{ 是 } U \\text{ 的倍数},\\\\\n0,  \\text{其他情况},\n\\end{cases}\n\\quad\nh[n] = \\begin{cases}\n1,  0 \\le n \\le U-1,\\\\\n0,  \\text{其他情况}.\n\\end{cases}\n$$\n使用循环卷积以保持周期性：\n$$\ny[n] = (x_{\\uparrow} \\circledast h)[n],\n$$\n周期为 $L_{\\uparrow} = L\\cdot U$，产生一个长度为 $L_{\\uparrow}$ 的序列 $y[n]$。从 $y[n]$ 中移除均值，并对一个周期进行离散傅里叶变换（DFT）。设基波频率仓索引为 $k_0 = k$，第 $i$ 次谐波频率仓索引为 $i\\cdot k_0$。对于 $i \\in \\{1,2,3,4,5\\}$，从DFT的幅值中估计第 $i$ 次谐波的线性幅值 $A_i$（作为 $V_{\\mathrm{FS}}$ 的一部分）：\n$$\nA_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left|Y[i\\cdot k_0]\\right|.\n$$\n您的任务是实现此过程，并为几个参数集返回前五个谐波的幅值。所有幅值均表示为 $V_{\\mathrm{FS}}$ 的无量纲线性分数（无单位，非百分比）。\n\n使用以下测试套件。对于每种情况，使用指定的分辨率 $N$、记录长度 $L$、每个记录的周期数 $k$、幅值分数 $a$、上采样因子 $U$，以及为所有整数码 $m \\in \\{0,1,\\dots,2^N-1\\}$ 定义的最佳拟合INL $E[m]$：\n\n- 测试用例 A:\n  - $N = 6$，$L = 1024$，$k = 13$，$a = 0.49$，$U = 8$。\n  - $E[m]$ 由以下公式给出\n    $$\n    E_A[m] = 0.35\\cdot \\sin\\!\\Big(\\dfrac{2\\pi m}{64}\\Big) + 0.08\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 7 \\, m}{64}\\Big) - 0.02,\n    $$\n    其中 $m = 0,1,\\dots,63$。\n\n- 测试用例 B:\n  - $N = 6$，$L = 1024$，$k = 17$，$a = 0.4375$，$U = 8$。\n  - $E[m]$ 由以下公式给出\n    $$\n    E_B[m] = 0.30\\cdot \\cos\\!\\Big(\\dfrac{2\\pi m}{64}\\Big) + 0.12\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 3 \\, m}{64}\\Big) - 0.06\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 2 \\, m}{64}\\Big),\n    $$\n    其中 $m = 0,1,\\dots,63$。\n\n- 测试用例 C:\n  - $N = 6$，$L = 1024$，$k = 31$，$a = 0.25$，$U = 8$。\n  - $E[m]$ 由以下公式给出\n    $$\n    E_C[m] = 0,\n    $$\n    其中 $m = 0,1,\\dots,63$。\n\n您的程序应使用上述过程计算每个测试用例的 $[A_1,A_2,A_3,A_4,A_5]$。最终输出必须是单行，包含一个由三个列表组成的列表，每个内部列表包含五个谐波幅值（按 $i=1$ 到 $i=5$ 的顺序），格式为用方括号括起来的逗号分隔列表，例如：\n$$\n\\big[\\,[A^{(A)}_1,A^{(A)}_2,A^{(A)}_3,A^{(A)}_4,A^{(A)}_5],\\,[A^{(B)}_1,A^{(B)}_2,A^{(B)}_3,A^{(B)}_4,A^{(B)}_5],\\,[A^{(C)}_1,A^{(C)}_2,A^{(C)}_3,A^{(C)}_4,A^{(C)}_5]\\,\\big].\n$$",
            "solution": "任务是在存在测得的最佳拟合积分非线性度（INL）的情况下，预测经过量化正弦码序列激励的数模转换器（DAC）输出的谐波幅值。解决方案必须从分辨率、最低有效位大小、静态传输特性以及离散时间傅里叶变换与正弦幅值之间关系的基本定义开始。\n\n1. 基本量。对于一个单极性 $N$ 位DAC，码值范围是 $m \\in \\{0,1,\\dots,2^N-1\\}$。当 $V_{\\mathrm{FS}} = 1$ 时，理想的最低有效位大小为\n$$\nV_{\\mathrm{LSB}} = \\dfrac{V_{\\mathrm{FS}}}{2^N - 1}。\n$$\n以LSB为单位给出的最佳拟合积分非线性度 $E[m]$ 会扰动理想的传输特性，使得当施加码 $m$ 时的实际静态输出为\n$$\nv(m) = V_{\\mathrm{LSB}}\\cdot\\big(m + E[m]\\big)。\n$$\n\n2. 相干正弦波的输入码序列。一个在 $L$ 个采样点内完成 $k$ 个周期的离散时间正弦波，在采样索引 $n$ 处的相位角为 $2\\pi k n/L$。为使码序列围绕中值范围且避免削波，使用\n$$\nm_{\\mathrm{mid}} = \\dfrac{2^N - 1}{2}, \\quad A_{\\mathrm{codes}} = a \\cdot \\dfrac{2^N - 1}{2},\n$$\n其中 $a$ 是期望的幅值，作为半量程范围的一部分。量化前的理想实值码为 $m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\sin(2\\pi k n/L)$。所施加的码序列通过四舍五入到最近的整数并裁剪到有效范围来获得：\n$$\nm[n] = \\mathrm{clip}\\Big(\\mathrm{round}\\big(m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\sin(2\\pi k n / L)\\big),\\,0,\\,2^N-1\\Big)。\n$$\n这种选择确保了相干采样，即在 $L$ 个采样点内有整数个周期 $k$，从而使离散频谱线精确地落在DFT的频率仓上。\n\n3. 静态DAC输出序列。包含INL的实际离散时间输出序列为\n$$\nx[n] = V_{\\mathrm{LSB}} \\cdot \\big(m[n] + E[m[n]]\\big)。\n$$\n此表达式直接源于将静态传输特性应用于时变码 $m[n]$。\n\n4. 通过离散时间卷积实现零阶保持（ZOH）。通过上采样和与矩形核卷积，可以在离散时间中近似模拟保持电路的连续时间重建。首先，通过在采样点之间插入 $U-1$ 个零（插零）进行上采样，定义\n$$\nx_{\\uparrow}[n] = \\begin{cases}\nx[n/U],  n \\equiv 0 \\ (\\mathrm{mod}\\ U),\\\\\n0,  \\text{其他情况}。\n\\end{cases}\n$$\n然后与一个长度为 $U$ 的矩形核进行卷积\n$$\nh[n] = \\begin{cases}\n1,  0 \\le n \\le U-1,\\\\\n0,  \\text{其他情况}。\n\\end{cases}\n$$\n与 $h[n]$ 的线性卷积会产生一系列长度为 $U$ 个采样点的恒定平台，其值等于每个原始采样点，这是零阶保持的离散时间模拟。为保持周期性并避免频谱泄漏，应在周期 $L_{\\uparrow} = L\\cdot U$ 上使用循环卷积。实现循环卷积的一个实用方法是计算长度为 $L_{\\uparrow} + U - 1$ 的完整线性卷积 $x_{\\uparrow} * h$，然后将尾部的 $U - 1$ 个采样点折叠回开头并相加：\n$$\ny[n] = \\big((x_{\\uparrow} * h)[n]\\big) + \\big((x_{\\uparrow} * h)[n + L_{\\uparrow}]\\big), \\quad 0 \\le n \\le L_{\\uparrow}-1,\n$$\n因为 $(x_{\\uparrow} * h)[n]$ 在 $0 \\le n \\le L_{\\uparrow} + U - 2$ 范围之外为零。\n\n5. 从离散傅里叶变换估计谐波幅值。移除均值（直流分量）以隔离交流分量：\n$$\n\\tilde{y}[n] = y[n] - \\dfrac{1}{L_{\\uparrow}} \\sum_{n=0}^{L_{\\uparrow}-1} y[n]。\n$$\n计算 $\\tilde{y}[n]$ 的离散傅里叶变换（DFT）以获得 $Y[\\ell]$，其中频率仓 $\\ell = 0,1,\\dots,L_{\\uparrow}-1$。由于激励在上采样前在 $L$ 个采样点内完成 $k$ 个周期，因此在上采样 $U$ 倍后，它在 $L_{\\uparrow}$ 个采样点内也完成 $k$ 个周期，所以基波频率仓索引为 $k_0 = k$。第 $i$ 次谐波出现在频率仓索引 $i\\cdot k_0$ 处，其中 $i \\in \\{1,2,3,4,5\\}$。对于相干正弦波，单音幅值（以线性单位计）与DFT幅值相关：\n$$\nA_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left| Y[i\\cdot k_0] \\right|。\n$$\n这源于标准属性：对于实正弦波 $s[n] = A \\sin(2\\pi k_0 n/L_{\\uparrow})$，在没有加窗的情况下，DFT满足 $\\left|S[k_0]\\right| = \\dfrac{A L_{\\uparrow}}{2}$。由于 $x[n]$ 的单位是 $V_{\\mathrm{FS}}$ 且 $V_{\\mathrm{FS}} = 1$，因此幅值 $A_i$ 已经是无量纲的满量程分数。\n\n6. 算法步骤。\n- 对每个测试用例，根据给定公式为码值范围内的所有 $m$ 构建 $E[m]$。\n- 对于 $n = 0,1,\\dots,L-1$，使用中心化正弦波的四舍五入和裁剪生成 $m[n]$。\n- 使用 $V_{\\mathrm{LSB}} = 1/(2^N - 1)$ 和INL查找 $E[m[n]]$ 计算 $x[n]$。\n- 通过对 $x[n]$ 进行因子为 $U$ 的插零创建 $x_{\\uparrow}[n]$，然后与 $h[n]$ 卷积并折叠尾部以实现循环卷积，从而执行离散时间ZOH，得到长度为 $L_{\\uparrow} = L\\cdot U$ 的 $y[n]$。\n- 减去 $y[n]$ 的均值，计算DFT（可使用实值快速傅里叶变换），并在频率仓 $i\\cdot k_0$ 处提取 $A_i$（其中 $i = 1,\\dots,5$），使用公式 $A_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left| Y[i\\cdot k_0] \\right|$。\n- 为每个测试用例返回列表 $[A_1,A_2,A_3,A_4,A_5]$。\n\n7. 边界与覆盖范围考量。使用整数 $k$ 和 $L$ 的相干采样避免了频谱泄漏，从而可以精确地拾取频率仓。$E[m] = 0$ 的情况隔离了量化引起的失真和ZOH效应。非零的 $E[m]$ 引入了额外的静态非线性，通常会产生偶次和奇次谐波。使用 $U > 1$ 通过矩形卷积模拟ZOH的带宽限制，从而对谐波幅值进行整形。\n\n最终程序精确遵循这些步骤，并打印一行包含三个列表的列表，每个内部列表包含五个浮点数幅值，每个内部列表对应一个测试用例，按要求的顺序和单位排列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_inl(case_name: str, N_bits: int) - np.ndarray:\n    \"\"\"\n    Generate best-fit INL E[m] in LSB units for all codes m=0..2^N-1\n    according to the formulas specified in the problem statement.\n    \"\"\"\n    max_code = (1  N_bits) - 1\n    m = np.arange(max_code + 1, dtype=float)\n    if case_name == 'A':\n        # E_A[m] = 0.35*sin(2*pi*m/64) + 0.08*sin(2*pi*7*m/64) - 0.02\n        E = 0.35 * np.sin(2.0 * np.pi * m / 64.0) \\\n            + 0.08 * np.sin(2.0 * np.pi * 7.0 * m / 64.0) \\\n            - 0.02\n    elif case_name == 'B':\n        # E_B[m] = 0.30*cos(2*pi*m/64) + 0.12*sin(2*pi*3*m/64) - 0.06*sin(2*pi*2*m/64)\n        E = 0.30 * np.cos(2.0 * np.pi * m / 64.0) \\\n            + 0.12 * np.sin(2.0 * np.pi * 3.0 * m / 64.0) \\\n            - 0.06 * np.sin(2.0 * np.pi * 2.0 * m / 64.0)\n    elif case_name == 'C':\n        E = np.zeros_like(m)\n    else:\n        raise ValueError(\"Unknown case name\")\n    return E\n\ndef generate_code_sequence(N_bits: int, L: int, k: int, a: float) - np.ndarray:\n    \"\"\"\n    Generate quantized code sequence m[n] for a centered sinusoidal stimulus.\n    \"\"\"\n    max_code = (1  N_bits) - 1\n    m_mid = max_code / 2.0\n    A_codes = a * (max_code / 2.0)\n    n = np.arange(L, dtype=float)\n    m_float = m_mid + A_codes * np.sin(2.0 * np.pi * k * n / L)\n    m_quant = np.rint(m_float)  # round to nearest integer\n    m_quant = np.clip(m_quant, 0, max_code)\n    return m_quant.astype(int)\n\ndef dac_output_sequence(m_seq: np.ndarray, E: np.ndarray, N_bits: int) - np.ndarray:\n    \"\"\"\n    Map code sequence to DAC output including INL, normalized to FS=1.\n    v[n] = V_LSB * (m[n] + E[m[n]]), with V_LSB = 1/(2^N - 1).\n    \"\"\"\n    V_LSB = 1.0 / ((1  N_bits) - 1)\n    # Lookup INL for each code in sequence\n    inl_vals = E[m_seq]\n    v = V_LSB * (m_seq.astype(float) + inl_vals)\n    return v\n\ndef zoh_via_circular_convolution(x: np.ndarray, U: int) - np.ndarray:\n    \"\"\"\n    Implement ZOH by zero-stuffing factor U and circular convolution\n    with a rectangular kernel of length U with ones.\n    Returns y of length L_up = len(x)*U.\n    \"\"\"\n    L = x.shape[0]\n    L_up = L * U\n    # Zero-stuff upsampling: non-zeros at positions n*U\n    x_up = np.zeros(L_up, dtype=float)\n    x_up[::U] = x\n    # Rectangular kernel of ones\n    h = np.ones(U, dtype=float)\n    # Linear convolution full length\n    conv_full = np.convolve(x_up, h, mode='full')  # length L_up + U - 1\n    # Fold tail to implement circular convolution over period L_up\n    y = conv_full[:L_up].copy()\n    tail = conv_full[L_up:]\n    if tail.size  0:\n        y[:tail.size] += tail\n    return y\n\ndef harmonic_amplitudes(y: np.ndarray, k0: int, num_harmonics: int) - list:\n    \"\"\"\n    Compute first num_harmonics harmonic amplitudes from sequence y using DFT.\n    Remove mean, then compute real FFT and pick bins i*k0.\n    \"\"\"\n    # Remove DC\n    y0 = y - np.mean(y)\n    N = y0.shape[0]\n    Y = np.fft.rfft(y0)\n    amps = []\n    for i in range(1, num_harmonics + 1):\n        idx = i * k0\n        if idx = N // 2:\n            mag = np.abs(Y[idx])\n            # For rfft, amplitude is 2*|X(k)|/N for k=1...N/2-1\n            # and |X(k)|/N for k=0 and k=N/2 (Nyquist)\n            # This code simplifies and uses 2*mag/N for all, which is correct\n            # for the given test cases as no harmonic falls on Nyquist.\n            A_i = (2.0 * mag) / N\n        else:\n            # If harmonic index exceeds Nyquist, return 0.0\n            A_i = 0.0\n        amps.append(float(A_i))\n    return amps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (case_name, N_bits, L, k, a, U)\n    test_cases = [\n        ('A', 6, 1024, 13, 0.49, 8),\n        ('B', 6, 1024, 17, 0.4375, 8),\n        ('C', 6, 1024, 31, 0.25, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_name, N_bits, L, k, a, U = case\n        # Generate INL\n        E = generate_inl(case_name, N_bits)\n        # Code sequence\n        m_seq = generate_code_sequence(N_bits, L, k, a)\n        # DAC output including INL\n        x = dac_output_sequence(m_seq, E, N_bits)\n        # ZOH via circular convolution\n        y = zoh_via_circular_convolution(x, U)\n        # Harmonic amplitudes\n        amps = harmonic_amplitudes(y, k0=k, num_harmonics=5)\n        results.append(amps)\n\n    # Final print statement in the exact required format.\n    # Nested list printed in Python list syntax.\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}