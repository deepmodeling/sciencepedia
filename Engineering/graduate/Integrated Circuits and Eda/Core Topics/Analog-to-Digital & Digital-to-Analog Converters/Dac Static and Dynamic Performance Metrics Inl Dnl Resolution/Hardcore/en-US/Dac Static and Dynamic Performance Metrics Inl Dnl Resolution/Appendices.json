{
    "hands_on_practices": [
        {
            "introduction": "Understanding the performance of a real-world Digital-to-Analog Converter (DAC) begins with a firm grasp of its ideal counterpart. The fundamental limits of resolution and noise in an ideal DAC provide the essential baseline against which all practical implementations are measured. This first-principles exercise  will solidify your understanding of how the number of bits ($N$) directly determines the smallest voltage step, or Least Significant Bit (LSB), and the inherent quantization noise power, which represents the theoretical 'best-case' noise floor.",
            "id": "4262893",
            "problem": "Consider an ideal $N$-bit Digital-to-Analog Converter (DAC) whose output levels are uniformly spaced across a full-scale span $V_{\\mathrm{FS}} = 1\\ \\mathrm{V}$. Adopt the canonical uniform mid-tread quantizer model in which the $2^{N}$ representable output levels partition the span $V_{\\mathrm{FS}}$ into $2^{N}$ equal-width bins. Using only first principles and core definitions from quantization theory, derive the least significant bit (LSB) step size and the ideal quantization error power at the DAC output under the assumption that, over time, the quantization error samples are uniformly distributed across their support. Then, compute:\n- the LSB magnitude expressed in $\\mu\\mathrm{V}$, and\n- the corresponding ideal quantization noise power expressed in $\\mathrm{V}^{2}$,\nboth as symbolic functions of $N$. Express your final answers symbolically in terms of $N$. Do not round.",
            "solution": "The problem requires the derivation of two fundamental metrics for an ideal $N$-bit Digital-to-Analog Converter (DAC): the magnitude of the least significant bit (LSB) and the power of the ideal quantization noise. The derivation will proceed from first principles as stipulated.\n\nFirst, we determine the LSB step size, which we denote as $\\Delta$. An $N$-bit converter possesses $2^N$ distinct digital input codes, which map to $2^N$ discrete analog output voltage levels. The problem specifies that these $2^N$ levels uniformly partition the full-scale span, $V_{\\mathrm{FS}}$, into $2^N$ equally-sized quantization bins. The width of one such bin is, by definition, the LSB step size. This leads to the following relationship:\n$$ \\Delta = \\frac{V_{\\mathrm{FS}}}{2^N} $$\nWe are given that the full-scale span is $V_{\\mathrm{FS}} = 1\\ \\mathrm{V}$. Substituting this value, the LSB step size in units of volts is:\n$$ \\Delta = \\frac{1}{2^N}\\ \\mathrm{V} $$\nThe first part of the problem asks for the LSB magnitude expressed in microvolts ($\\mu\\mathrm{V}$). The conversion from volts to microvolts is $1\\ \\mathrm{V} = 10^6\\ \\mu\\mathrm{V}$. Applying this conversion factor, we obtain the LSB magnitude as a symbolic function of $N$:\n$$ \\Delta_{\\mu\\mathrm{V}} = \\left( \\frac{1}{2^N}\\ \\mathrm{V} \\right) \\times \\left( \\frac{10^6\\ \\mu\\mathrm{V}}{1\\ \\mathrm{V}} \\right) = \\frac{10^6}{2^N} $$\nThis expression represents the LSB magnitude in microvolts.\n\nNext, we derive the ideal quantization noise power, $P_q$. The quantization error, $e_q$, is the difference between the continuous-valued signal being represented and the discrete output level produced by the quantizer. For the specified uniform mid-tread quantizer model, the discrete output levels are situated at the center of each quantization interval. Consequently, the quantization error is bounded within the symmetric interval $[-\\frac{\\Delta}{2}, +\\frac{\\Delta}{2}]$.\n\nThe problem makes the standard assumption that the quantization error $e_q$ is a random variable that is uniformly distributed across its support interval. The probability density function (PDF) of the error, denoted $f(e_q)$, is therefore constant over this interval and zero elsewhere:\n$$\nf(e_q) =\n\\begin{cases}\n\\frac{1}{(\\Delta/2) - (-\\Delta/2)} = \\frac{1}{\\Delta} & \\text{for } -\\frac{\\Delta}{2} \\le e_q \\le \\frac{\\Delta}{2} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nThe ideal quantization noise power, $P_q$, is defined as the mean-squared value of the quantization error, $E[e_q^2]$. For a zero-mean distribution like this one, the mean-squared value is equal to the variance. We calculate it by integrating the product of $e_q^2$ and the PDF over all possible values of $e_q$:\n$$ P_q = E[e_q^2] = \\int_{-\\infty}^{\\infty} e_q^2 f(e_q) \\, de_q $$\nSubstituting the uniform PDF into the integral gives:\n$$ P_q = \\int_{-\\Delta/2}^{\\Delta/2} e_q^2 \\left( \\frac{1}{\\Delta} \\right) \\, de_q $$\nWe proceed to evaluate this elementary integral:\n$$ P_q = \\frac{1}{\\Delta} \\left[ \\frac{e_q^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} $$\n$$ P_q = \\frac{1}{3\\Delta} \\left[ \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right] $$\n$$ P_q = \\frac{1}{3\\Delta} \\left[ \\frac{\\Delta^3}{8} - \\left(-\\frac{\\Delta^3}{8}\\right) \\right] = \\frac{1}{3\\Delta} \\left[ \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right] $$\n$$ P_q = \\frac{1}{3\\Delta} \\left( 2 \\cdot \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{4} \\right) $$\nThis simplifies to the canonical result for quantization noise power:\n$$ P_q = \\frac{\\Delta^2}{12} $$\nFinally, to express $P_q$ as a symbolic function of $N$, we substitute our expression for $\\Delta = \\frac{V_{\\mathrm{FS}}}{2^N}$ with $V_{\\mathrm{FS}} = 1\\ \\mathrm{V}$:\n$$ P_q = \\frac{1}{12} \\left( \\frac{1}{2^N} \\right)^2 = \\frac{1}{12 \\cdot (2^N)^2} $$\n$$ P_q = \\frac{1}{12 \\cdot 2^{2N}} $$\nThe units for this quantity are $\\mathrm{V}^2$, as is appropriate for a mean-squared voltage, which corresponds to power in a normalized $1\\ \\Omega$ system.\n\nIn summary, the two requested symbolic functions of $N$ are:\n1. LSB magnitude in $\\mu\\mathrm{V}$: $\\frac{10^6}{2^N}$\n2. Ideal quantization noise power in $\\mathrm{V}^2$: $\\frac{1}{12 \\cdot 2^{2N}}$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{10^6}{2^N} & \\frac{1}{12 \\cdot 2^{2N}} \\end{pmatrix}}$$"
        },
        {
            "introduction": "In practice, a DAC's transfer function is never perfectly linear, and its deviation is quantified by Integral Nonlinearity (INL) and Differential Nonlinearity (DNL). While they describe different aspects of the static error, they are fundamentally linked. This exercise  provides a hands-on opportunity to derive the DNL from a given set of INL measurements, demonstrating that DNL is effectively the discrete derivative of INL and allowing you to diagnose critical performance issues like non-monotonicity.",
            "id": "4262902",
            "problem": "A Digital-to-Analog Converter (DAC) of resolution $N$ codes exhibits static nonlinearity when measured under steady-state conditions. Let $V_{\\text{actual}}(k)$ denote the measured DAC output at code $k \\in \\{0,1,\\dots,2^{N}-1\\}$, and let the endpoint-fit reference line be defined by $V_{\\text{fit}}(k) = V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$ where $\\text{LSB}_{e} = \\dfrac{V_{\\text{actual}}(2^{N}-1) - V_{\\text{actual}}(0)}{2^{N}-1}$. Define the Integral Nonlinearity (INL) as $I(k) = \\dfrac{V_{\\text{actual}}(k) - V_{\\text{fit}}(k)}{\\text{LSB}_{e}}$ and the Differential Nonlinearity (DNL) as $D(k) = \\dfrac{V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)}{\\text{LSB}_{e}} - 1$, for $k \\geq 1$. These quantities are normalized to the endpoint-fit Least Significant Bit (LSB), so their units are $\\mathrm{LSB}$.\n\nConsider a $N=12$ DAC for which the measured Integral Nonlinearity (INL) values (normalized to $\\text{LSB}_{e}$) around a suspected non-monotonic region are given at the following contiguous codes:\n- $k=2045$: $I(2045)=0.1843$\n- $k=2046$: $I(2046)=0.1402$\n- $k=2047$: $I(2047)=0.0975$\n- $k=2048$: $I(2048)=-1.2389$\n- $k=2049$: $I(2049)=-1.2103$\n- $k=2050$: $I(2050)=-1.1837$\n\nStarting only from the above endpoint-fit definitions of INL and DNL, use discrete differentiation of the measured INL to determine the minimum possible Differential Nonlinearity over $k \\in \\{2046,2047,2048,2049,2050\\}$. Then assess whether any DNL must be below $-1$ $\\mathrm{LSB}$, explaining the reasoning from first principles. Report the single numeric value of the minimum DNL in $\\mathrm{LSB}$. Round your final numeric answer to four significant figures, and express the final number in $\\mathrm{LSB}$.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of Digital-to-Analog Converter (DAC) characterization, is well-posed with sufficient information for a unique solution, and is objective in its language. The definitions for Integral Nonlinearity (INL) and Differential Nonlinearity (DNL) are standard in the field of electronics and integrated circuits.\n\nThe task is to find the minimum Differential Nonlinearity, $D(k)$, for a specified range of digital codes $k$, given a set of Integral Nonlinearity, $I(k)$, values. The relationship between $D(k)$ and $I(k)$ must be derived from the provided definitions.\n\nThe definition for INL is given as:\n$$I(k) = \\frac{V_{\\text{actual}}(k) - V_{\\text{fit}}(k)}{\\text{LSB}_{e}}$$\nwhere $V_{\\text{actual}}(k)$ is the measured output voltage at code $k$, and $V_{\\text{fit}}(k)$ is the ideal voltage on an endpoint-fit line. $\\text{LSB}_{e}$ is the least significant bit size for the endpoint-fit line. From this definition, we can express the actual output voltage as:\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{fit}}(k)$$\nThe endpoint-fit line is defined as $V_{\\text{fit}}(k) = V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$. Substituting this into the expression for $V_{\\text{actual}}(k)$ yields:\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$$\nThe definition for DNL for code $k$ (where $k \\ge 1$) is given as:\n$$D(k) = \\frac{V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)}{\\text{LSB}_{e}} - 1$$\nTo establish the relationship between $D(k)$ and $I(k)$, we first express the voltage step $V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)$ using the expression for $V_{\\text{actual}}(k)$ derived above. For code $k$, we have:\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$$\nFor code $k-1$, we have:\n$$V_{\\text{actual}}(k-1) = I(k-1) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + (k-1) \\cdot \\text{LSB}_{e}$$\nSubtracting the second equation from the first gives the voltage difference, noting that the $V_{\\text{actual}}(0)$ terms cancel:\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) \\cdot \\text{LSB}_{e} - I(k-1) \\cdot \\text{LSB}_{e}) + (k \\cdot \\text{LSB}_{e} - (k-1) \\cdot \\text{LSB}_{e})$$\nFactoring out $\\text{LSB}_{e}$:\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + (k - (k-1)) \\cdot \\text{LSB}_{e}$$\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + 1 \\cdot \\text{LSB}_{e}$$\nNow, we substitute this expression back into the definition of $D(k)$:\n$$D(k) = \\frac{(I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + \\text{LSB}_{e}}{\\text{LSB}_{e}} - 1$$\nDividing the numerator by $\\text{LSB}_{e}$:\n$$D(k) = (I(k) - I(k-1)) + 1 - 1$$\nThis simplifies to the fundamental relationship between DNL and INL, which represents a discrete differentiation:\n$$D(k) = I(k) - I(k-1)$$\nWe can now use this relationship to calculate the DNL values for the specified codes $k \\in \\{2046, 2047, 2048, 2049, 2050\\}$ using the provided INL data.\n\nThe given INL data points (in units of $\\mathrm{LSB}_{e}$) are:\n$I(2045) = 0.1843$\n$I(2046) = 0.1402$\n$I(2047) = 0.0975$\n$I(2048) = -1.2389$\n$I(2049) = -1.2103$\n$I(2050) = -1.1837$\n\nWe calculate the DNL values as follows:\nFor $k=2046$:\n$D(2046) = I(2046) - I(2045) = 0.1402 - 0.1843 = -0.0441$\nFor $k=2047$:\n$D(2047) = I(2047) - I(2046) = 0.0975 - 0.1402 = -0.0427$\nFor $k=2048$:\n$D(2048) = I(2048) - I(2047) = -1.2389 - 0.0975 = -1.3364$\nFor $k=2049$:\n$D(2049) = I(2049) - I(2048) = -1.2103 - (-1.2389) = -1.2103 + 1.2389 = 0.0286$\nFor $k=2050$:\n$D(2050) = I(2050) - I(2049) = -1.1837 - (-1.2103) = -1.1837 + 1.2103 = 0.0266$\n\nThe calculated DNL values (in $\\mathrm{LSB}_{e}$) are:\n$D(2046) = -0.0441$\n$D(2047) = -0.0427$\n$D(2048) = -1.3364$\n$D(2049) = 0.0286$\n$D(2050) = 0.0266$\n\nThe problem asks for the minimum possible DNL over the specified range. By comparing the calculated values, the minimum is:\n$$\\min\\{D(k)\\} = D(2048) = -1.3364$$\nThe problem also asks to assess whether any DNL must be below $-1$ $\\mathrm{LSB}$. A DAC is guaranteed to be monotonic if its DNL is always greater than or equal to $-1$ LSB for all codes, i.e., $D(k) \\geq -1$. A DNL value less than $-1$ indicates non-monotonic behavior, where the analog output voltage decreases as the digital input code is incremented. In this case, at code $k=2048$, the DNL is $D(2048) = -1.3364$, which is less than $-1$. This confirms that the DAC is non-monotonic at this transition. The voltage step from code $2047$ to $2048$ is $V_{\\text{actual}}(2048) - V_{\\text{actual}}(2047) = (D(2048) + 1) \\cdot \\text{LSB}_e = (-1.3364 + 1) \\cdot \\text{LSB}_e = -0.3364 \\cdot \\text{LSB}_e$, which is a negative change.\n\nThe final task is to report the single numeric value of the minimum DNL, rounded to four significant figures. The minimum DNL is $-1.3364$. Rounding to four significant figures gives $-1.336$.",
            "answer": "$$\n\\boxed{-1.336}\n$$"
        },
        {
            "introduction": "A crucial skill in mixed-signal design is connecting static specifications to dynamic performance. While a DAC's datasheet might specify its static Integral Nonlinearity (INL), the end application often cares about the spectral purity of a dynamic signal passing through it, such as its harmonic distortion. This advanced simulation practice  bridges that gap by guiding you through the process of predicting the harmonic content of a DAC's output based on its known static INL profile, providing direct insight into how static errors corrupt a time-varying signal.",
            "id": "4262912",
            "problem": "A unipolar Digital-to-Analog Converter (DAC) with resolution of $N$ bits maps a digital input code $m \\in \\{0,1,\\dots,2^N-1\\}$ to an analog output. Let the full-scale output be normalized to $V_{\\mathrm{FS}} = 1$ (dimensionless unit), so that the ideal least significant bit size is $V_{\\mathrm{LSB}} = \\dfrac{V_{\\mathrm{FS}}}{2^N-1}$. A measured best-fit Integral Nonlinearity (INL) is provided as a dimensionless array $E[m]$ in units of least significant bits (LSBs), for each code $m$. The actual static transfer characteristic is modeled as\n$$\nv(m) = V_{\\mathrm{LSB}} \\cdot \\big(m + E[m]\\big).\n$$\nConsider a discrete-time periodic stimulus that drives the DAC with a quantized digital sine wave at $f_0$ that is coherent with the record length. Let the record have $L$ samples per period, and suppose there are $k$ sinusoidal cycles within $L$ samples. The input code sequence $m[n]$ is formed by quantizing a centered sinusoid with amplitude specified as a fraction $a$ of the half-scale range in units of codes:\n$$\nm_{\\mathrm{mid}} = \\dfrac{2^N - 1}{2}, \\quad A_{\\mathrm{codes}} = a \\cdot \\dfrac{2^N - 1}{2},\n$$\n$$\nm[n] = \\mathrm{clip}\\Big(\\mathrm{round}\\big(m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\cdot \\sin(2\\pi k n / L)\\big),\\,0,\\,2^N-1\\Big),\n$$\nfor $n = 0,1,\\dots,L-1$. The corresponding discrete-time DAC output sequence is\n$$\nx[n] = V_{\\mathrm{LSB}} \\cdot \\big(m[n] + E[m[n]]\\big).\n$$\nTo approximate the continuous-time Zero-Order Hold (ZOH) output, use discrete-time convolution by first upsampling $x[n]$ by an integer factor $U$ via zero-stuffing to obtain $x_{\\uparrow}[n]$ and then convolving with a rectangular kernel $h[n]$ of length $U$ with unity coefficients:\n$$\nx_{\\uparrow}[n] = \\begin{cases}\nx[n/U], & \\text{if } n \\text{ is a multiple of } U,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n\\quad\nh[n] = \\begin{cases}\n1, & 0 \\le n \\le U-1,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nUse circular convolution to preserve periodicity:\n$$\ny[n] = (x_{\\uparrow} \\circledast h)[n],\n$$\nwith period $L_{\\uparrow} = L\\cdot U$, producing a length-$L_{\\uparrow}$ sequence $y[n]$. Remove the mean from $y[n]$ and compute the Discrete Fourier Transform (DFT) over one period. Let the fundamental bin index be $k_0 = k$ and the $i$-th harmonic bin index be $i\\cdot k_0$. For $i \\in \\{1,2,3,4,5\\}$, estimate the linear amplitude $A_i$ of the $i$-th harmonic (as a fraction of $V_{\\mathrm{FS}}$) from the DFT magnitude by\n$$\nA_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left|Y[i\\cdot k_0]\\right|.\n$$\nYour task is to implement this procedure and return the first five harmonic amplitudes for several parameter sets. Express all amplitudes as dimensionless linear fractions of $V_{\\mathrm{FS}}$ (no unit, and not as percentages).\n\nUse the following test suite. For each case, use the specified resolution $N$, record length $L$, cycles per record $k$, amplitude fraction $a$, upsampling factor $U$, and best-fit INL $E[m]$ defined for all integer codes $m \\in \\{0,1,\\dots,2^N-1\\}$:\n\n- Test case A:\n  - $N = 6$, $L = 1024$, $k = 13$, $a = 0.49$, $U = 8$.\n  - $E[m]$ given by the formula\n    $$\n    E_A[m] = 0.35\\cdot \\sin\\!\\Big(\\dfrac{2\\pi m}{64}\\Big) + 0.08\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 7 \\, m}{64}\\Big) - 0.02,\n    $$\n    for $m = 0,1,\\dots,63$.\n\n- Test case B:\n  - $N = 6$, $L = 1024$, $k = 17$, $a = 0.4375$, $U = 8$.\n  - $E[m]$ given by the formula\n    $$\n    E_B[m] = 0.30\\cdot \\cos\\!\\Big(\\dfrac{2\\pi m}{64}\\Big) + 0.12\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 3 \\, m}{64}\\Big) - 0.06\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 2 \\, m}{64}\\Big),\n    $$\n    for $m = 0,1,\\dots,63$.\n\n- Test case C:\n  - $N = 6$, $L = 1024$, $k = 31$, $a = 0.25$, $U = 8$.\n  - $E[m]$ given by\n    $$\n    E_C[m] = 0,\n    $$\n    for $m = 0,1,\\dots,63$.\n\nYour program should compute $[A_1,A_2,A_3,A_4,A_5]$ for each test case using the procedure described above. The final output must be a single line containing a list of three lists, each inner list containing the five harmonic amplitudes (in the order $i=1$ to $i=5$), formatted as a comma-separated list enclosed in square brackets, for example: `[[A^(A)_1,A^(A)_2,A^(A)_3,A^(A)_4,A^(A)_5], [A^(B)_1,...], [A^(C)_1,...]]`.",
            "solution": "The task is to predict harmonic amplitudes of a Digital-to-Analog Converter (DAC) output subjected to a quantized sinusoidal code sequence in the presence of measured best-fit Integral Nonlinearity (INL). The solution must begin from the fundamental definitions of resolution, least significant bit size, static transfer, and the relation between the discrete-time Fourier transform and sinusoidal amplitudes.\n\n1. Fundamental quantities. For a unipolar $N$-bit DAC, the code range is $m \\in \\{0,1,\\dots,2^N-1\\}$. With $V_{\\mathrm{FS}} = 1$, the ideal least significant bit size is\n$$\nV_{\\mathrm{LSB}} = \\dfrac{V_{\\mathrm{FS}}}{2^N - 1}.\n$$\nA best-fit Integral Nonlinearity $E[m]$ given in units of LSBs perturbs the ideal transfer such that the actual static output when code $m$ is applied is\n$$\nv(m) = V_{\\mathrm{LSB}}\\cdot\\big(m + E[m]\\big).\n$$\n\n2. Input code sequence for a coherent sinusoid. A discrete-time sinusoid that completes $k$ cycles over $L$ samples has argument $2\\pi k n/L$ at sample index $n$. To center the code sequence around midscale and avoid clipping, use\n$$\nm_{\\mathrm{mid}} = \\dfrac{2^N - 1}{2}, \\quad A_{\\mathrm{codes}} = a \\cdot \\dfrac{2^N - 1}{2},\n$$\nwhere $a$ is the desired amplitude as a fraction of half-scale. The ideal real-valued code before quantization is $m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\sin(2\\pi k n/L)$. The applied code sequence is obtained by rounding to the nearest integer and clipping to the valid range:\n$$\nm[n] = \\mathrm{clip}\\Big(\\mathrm{round}\\big(m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\sin(2\\pi k n / L)\\big),\\,0,\\,2^N-1\\Big).\n$$\nThis choice ensures coherent sampling, i.e., an integer number of cycles $k$ within $L$ samples, leading to discrete spectral lines precisely on DFT bins.\n\n3. Static DAC output sequence. The actual discrete-time output sequence that includes INL is\n$$\nx[n] = V_{\\mathrm{LSB}} \\cdot \\big(m[n] + E[m[n]]\\big).\n$$\nThis expression follows directly from the static transfer characteristic applied to the time-varying code $m[n]$.\n\n4. Zero-Order Hold (ZOH) via discrete-time convolution. The continuous-time reconstruction by a hold circuit can be approximated in discrete-time by upsampling and convolution with a rectangular kernel. First, upsample by inserting $U-1$ zeros between samples (zero-stuffing), defining\n$$\nx_{\\uparrow}[n] = \\begin{cases}\nx[n/U], & n \\equiv 0 \\ (\\mathrm{mod}\\ U),\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThen convolve with a length-$U$ rectangular kernel\n$$\nh[n] = \\begin{cases}\n1, & 0 \\le n \\le U-1,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nLinear convolution with $h[n]$ creates a sequence of constant plateaus of length $U$ samples equal to each original sample, which is the discrete-time analog of zero-order hold. To maintain periodicity and avoid spectral leakage, use circular convolution over a period of $L_{\\uparrow} = L\\cdot U$. A practical way to implement circular convolution is to compute the full linear convolution $x_{\\uparrow} * h$ of length $L_{\\uparrow} + U - 1$, then fold the trailing $U - 1$ samples back into the beginning by addition:\n$$\ny[n] = \\big((x_{\\uparrow} * h)[n]\\big) + \\big((x_{\\uparrow} * h)[n + L_{\\uparrow}]\\big), \\quad 0 \\le n \\le L_{\\uparrow}-1,\n$$\nsince $(x_{\\uparrow} * h)[n]$ is zero outside the range $0 \\le n \\le L_{\\uparrow} + U - 2$.\n\n5. Harmonic amplitude estimation from the Discrete Fourier Transform. The mean (direct current) is removed to isolate alternating components:\n$$\n\\tilde{y}[n] = y[n] - \\dfrac{1}{L_{\\uparrow}} \\sum_{n=0}^{L_{\\uparrow}-1} y[n].\n$$\nCompute the Discrete Fourier Transform (DFT) of $\\tilde{y}[n]$ to obtain $Y[\\ell]$ for frequency bins $\\ell = 0,1,\\dots,L_{\\uparrow}-1$. Because the stimulus completes $k$ cycles in $L$ samples before upsampling, it also completes $k$ cycles in $L_{\\uparrow}$ samples after upsampling by $U$, so the fundamental bin index is $k_0 = k$. The $i$-th harmonic occurs at bin index $i\\cdot k_0$ for $i \\in \\{1,2,3,4,5\\}$. For a coherent sinusoid, the single-tone amplitude in linear units is related to the DFT magnitude by\n$$\nA_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left| Y[i\\cdot k_0] \\right|.\n$$\nThis follows from the standard property that for a real sinusoid $s[n] = A \\sin(2\\pi k_0 n/L_{\\uparrow})$, the DFT satisfies $\\left|S[k_0]\\right| = \\dfrac{A L_{\\uparrow}}{2}$ in the absence of windowing. Since $x[n]$ is expressed in units of $V_{\\mathrm{FS}}$ and $V_{\\mathrm{FS}} = 1$, the amplitudes $A_i$ are already dimensionless fractions of full-scale.\n\n6. Algorithmic steps.\n- For each test case, construct $E[m]$ from the given formula for all $m$ in the code range.\n- Generate $m[n]$ for $n = 0,1,\\dots,L-1$ using rounding and clipping of the centered sinusoid.\n- Compute $x[n]$ using $V_{\\mathrm{LSB}} = 1/(2^N - 1)$ and the INL lookup $E[m[n]]$.\n- Perform discrete-time ZOH by zero-stuffing $x[n]$ by factor $U$ to create $x_{\\uparrow}[n]$, then convolving with $h[n]$ and folding the tail to implement circular convolution, resulting in $y[n]$ of length $L_{\\uparrow} = L\\cdot U$.\n- Subtract the mean of $y[n]$, compute the DFT (a real-valued fast Fourier transform can be used), and extract $A_i$ at bins $i\\cdot k_0$ for $i = 1,\\dots,5$ using $A_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left| Y[i\\cdot k_0] \\right|$.\n- Return the list $[A_1,A_2,A_3,A_4,A_5]$ for each test case.\n\n7. Edge and coverage considerations. Coherent sampling with integer $k$ and $L$ avoids spectral leakage, enabling exact bin picking. The case with $E[m] = 0$ isolates quantization-induced distortion and ZOH effects. Nonzero $E[m]$ introduces additional static nonlinearity that generally produces both even and odd harmonics. Using $U > 1$ models the ZOH bandwidth limitation via the rectangular convolution, shaping the harmonic amplitudes.\n\nThe final program follows these steps precisely and prints a single line containing a list of three lists with five floating-point amplitudes each, one inner list per test case, in the required order and units.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_inl(case_name: str, N_bits: int) -> np.ndarray:\n    \"\"\"\n    Generate best-fit INL E[m] in LSB units for all codes m=0..2^N-1\n    according to the formulas specified in the problem statement.\n    \"\"\"\n    max_code = (1 << N_bits) - 1\n    m = np.arange(max_code + 1, dtype=float)\n    if case_name == 'A':\n        # E_A[m] = 0.35*sin(2*pi*m/64) + 0.08*sin(2*pi*7*m/64) - 0.02\n        E = 0.35 * np.sin(2.0 * np.pi * m / 64.0) \\\n            + 0.08 * np.sin(2.0 * np.pi * 7.0 * m / 64.0) \\\n            - 0.02\n    elif case_name == 'B':\n        # E_B[m] = 0.30*cos(2*pi*m/64) + 0.12*sin(2*pi*3*m/64) - 0.06*sin(2*pi*2*m/64)\n        E = 0.30 * np.cos(2.0 * np.pi * m / 64.0) \\\n            + 0.12 * np.sin(2.0 * np.pi * 3.0 * m / 64.0) \\\n            - 0.06 * np.sin(2.0 * np.pi * 2.0 * m / 64.0)\n    elif case_name == 'C':\n        E = np.zeros_like(m)\n    else:\n        raise ValueError(\"Unknown case name\")\n    return E\n\ndef generate_code_sequence(N_bits: int, L: int, k: int, a: float) -> np.ndarray:\n    \"\"\"\n    Generate quantized code sequence m[n] for a centered sinusoidal stimulus.\n    \"\"\"\n    max_code = (1 << N_bits) - 1\n    m_mid = max_code / 2.0\n    A_codes = a * (max_code / 2.0)\n    n = np.arange(L, dtype=float)\n    m_float = m_mid + A_codes * np.sin(2.0 * np.pi * k * n / L)\n    m_quant = np.rint(m_float)  # round to nearest integer\n    m_quant = np.clip(m_quant, 0, max_code)\n    return m_quant.astype(int)\n\ndef dac_output_sequence(m_seq: np.ndarray, E: np.ndarray, N_bits: int) -> np.ndarray:\n    \"\"\"\n    Map code sequence to DAC output including INL, normalized to FS=1.\n    v[n] = V_LSB * (m[n] + E[m[n]]), with V_LSB = 1/(2^N - 1).\n    \"\"\"\n    V_LSB = 1.0 / ((1 << N_bits) - 1)\n    # Lookup INL for each code in sequence\n    inl_vals = E[m_seq]\n    v = V_LSB * (m_seq.astype(float) + inl_vals)\n    return v\n\ndef zoh_via_circular_convolution(x: np.ndarray, U: int) -> np.ndarray:\n    \"\"\"\n    Implement ZOH by zero-stuffing factor U and circular convolution\n    with a rectangular kernel of length U with ones.\n    Returns y of length L_up = len(x)*U.\n    \"\"\"\n    L = x.shape[0]\n    L_up = L * U\n    # Zero-stuff upsampling: non-zeros at positions n*U\n    x_up = np.zeros(L_up, dtype=float)\n    x_up[::U] = x\n    # Rectangular kernel of ones\n    h = np.ones(U, dtype=float)\n    # Linear convolution full length\n    conv_full = np.convolve(x_up, h, mode='full')  # length L_up + U - 1\n    # Fold tail to implement circular convolution over period L_up\n    y = conv_full[:L_up].copy()\n    tail = conv_full[L_up:]\n    if tail.size > 0:\n        y[:tail.size] += tail\n    return y\n\ndef harmonic_amplitudes(y: np.ndarray, k0: int, num_harmonics: int) -> list:\n    \"\"\"\n    Compute first num_harmonics harmonic amplitudes from sequence y using DFT.\n    Remove mean, then compute real FFT and pick bins i*k0.\n    \"\"\"\n    # Remove DC\n    y0 = y - np.mean(y)\n    N = y0.shape[0]\n    Y = np.fft.rfft(y0)\n    amps = []\n    for i in range(1, num_harmonics + 1):\n        idx = i * k0\n        if idx <= N // 2:\n            mag = np.abs(Y[idx])\n            A_i = (2.0 * mag) / N\n        else:\n            # If harmonic index exceeds Nyquist, return 0.0\n            A_i = 0.0\n        amps.append(float(A_i))\n    return amps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (case_name, N_bits, L, k, a, U)\n    test_cases = [\n        ('A', 6, 1024, 13, 0.49, 8),\n        ('B', 6, 1024, 17, 0.4375, 8),\n        ('C', 6, 1024, 31, 0.25, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_name, N_bits, L, k, a, U = case\n        # Generate INL\n        E = generate_inl(case_name, N_bits)\n        # Code sequence\n        m_seq = generate_code_sequence(N_bits, L, k, a)\n        # DAC output including INL\n        x = dac_output_sequence(m_seq, E, N_bits)\n        # ZOH via circular convolution\n        y = zoh_via_circular_convolution(x, U)\n        # Harmonic amplitudes\n        amps = harmonic_amplitudes(y, k0=k, num_harmonics=5)\n        results.append(amps)\n\n    # Final print statement in the exact required format.\n    # Nested list printed in Python list syntax.\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}