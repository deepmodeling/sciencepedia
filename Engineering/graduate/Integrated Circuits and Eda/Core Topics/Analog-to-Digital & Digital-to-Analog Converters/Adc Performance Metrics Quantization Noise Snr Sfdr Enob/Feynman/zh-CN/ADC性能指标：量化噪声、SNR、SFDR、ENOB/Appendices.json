{
    "hands_on_practices": [
        {
            "introduction": "在评估任何ADC的性能之前，我们必须首先理解其理想情况下的理论极限。这个练习将引导你从第一性原理出发，推导一个理想ADC的信噪比（SNR），将输入信号的功率与由量化过程产生的固有噪声进行比较。通过亲手完成这些计算，你将对量化噪声的来源及其对ADC性能的根本性影响建立起深刻的直观理解。",
            "id": "4255221",
            "problem": "在具有 $N$ 位的模数转换器 (ADC) 中，一个理想的中置均匀量化器将其满量程峰峰值范围 $V_{\\mathrm{pp,FS}}$ 内的零均值输入映射到 $2^{N}$ 个等间距代码之一。最低有效位 (LSB) 的步长定义为这种均匀划分所隐含的代码间距。考虑一个单音、零均值的正弦输入 $x(t) = A \\sin(2 \\pi f_{0} t)$，其峰值幅度为 $A$，且严格在量化器的无过载区域内，因此不会发生削波。假设量化误差定义为 $e(t) = x(t) - \\hat{x}(t)$，其中 $\\hat{x}(t)$ 是量化后的输出，并且 $e(t)$ 与 $x(t)$ 无关，在其由均匀量化器步长决定的支撑集上均匀分布。\n\n设 $N = 13$，$V_{\\mathrm{pp,FS}} = 2.56~\\mathrm{V}$，且 $A = 0.80~\\mathrm{V}$。将所有功率视为在多个周期上的时间平均值。完全从第一性原理出发，从上述定义开始，包括正弦波功率的定义、根据满量程范围和位分辨率对 LSB 的定义，以及理想均匀量化器引起的量化误差的均匀概率密度函数。在没有从这些基础进行推导的情况下，不要引用任何公式。\n\n任务：\n- 推导以 LSB 单位表示的输入峰值幅度。\n- 推导以 $\\mathrm{LSB}^{2}$ 为单位的预期量化噪声功率。\n- 推导信噪比 (SNR)，定义为正弦信号功率与量化噪声功率之比，以分贝表示。\n\n以以下有序三元组形式报告您的最终数值结果：$\\big[$峰值幅度 (LSB), 量化噪声功率 ($\\mathrm{LSB}^{2}$), 信噪比 ($\\mathrm{dB}$)$\\big]$。信噪比以分贝表示，并四舍五入到四位有效数字。最终报告的三元组中不包含任何单位；此处的单位仅为解释说明。",
            "solution": "该问题要求基于第一性原理，推导和计算模数转换器 (ADC) 的三个关键性能指标：以最低有效位 (LSB) 为单位的输入峰值幅度、以 $\\mathrm{LSB}^2$ 为单位的量化噪声功率，以及以分贝为单位的信噪比 (SNR)。该问题陈述清晰且科学严谨，为获得唯一解提供了所有必要的参数。\n\n给定的参数是：\n- ADC 分辨率：$N = 13$ 位\n- 满量程峰峰值范围：$V_{\\mathrm{pp,FS}} = 2.56~\\mathrm{V}$\n- 输入信号：$x(t) = A \\sin(2 \\pi f_{0} t)$，峰值幅度 $A = 0.80~\\mathrm{V}$\n\n我们将按顺序完成这三项任务。\n\n首先，我们推导以 LSB 为单位的输入信号峰值幅度。\n量化器的基本步长，即最低有效位 (LSB)，是通过将满量程峰峰值范围 $V_{\\mathrm{pp,FS}}$ 均匀划分为 $2^N$ 个电平来定义的。因此，对应于一个 LSB 的电压，记为 $\\Delta$，为：\n$$ \\Delta = \\frac{V_{\\mathrm{pp,FS}}}{2^N} $$\n代入给定值 $V_{\\mathrm{pp,FS}} = 2.56~\\mathrm{V}$ 和 $N = 13$：\n$$ \\Delta = \\frac{2.56}{2^{13}} = \\frac{2.56}{8192}~\\mathrm{V} $$\n输入信号的峰值幅度为 $A = 0.80~\\mathrm{V}$。为了以 LSB 单位表示该幅度，我们将其记为 $A_{\\mathrm{LSB}}$，我们计算 $A$ 与 $\\Delta$ 的比值：\n$$ A_{\\mathrm{LSB}} = \\frac{A}{\\Delta} = \\frac{0.80~\\mathrm{V}}{\\frac{2.56}{8192}~\\mathrm{V}} = \\frac{0.80 \\times 8192}{2.56} $$\n我们可以将比率 $\\frac{0.80}{2.56}$ 简化为 $\\frac{80}{256} = \\frac{5 \\times 16}{16 \\times 16} = \\frac{5}{16}$。\n$$ A_{\\mathrm{LSB}} = \\frac{5}{16} \\times 8192 = 5 \\times \\frac{8192}{16} = 5 \\times 512 = 2560 $$\n因此，输入正弦波的峰值幅度为 $2560$ LSB。不发生削波的条件得到满足，因为满量程峰值幅度为 $\\frac{V_{\\mathrm{pp,FS}}}{2} = \\frac{2.56}{2} = 1.28~\\mathrm{V}$，而 $A = 0.80~\\mathrm{V}  1.28~\\mathrm{V}$。此外，以 LSB 为单位，满量程峰值幅度为 $\\frac{A_{FS}}{ \\Delta} = \\frac{1.28}{\\Delta} = \\frac{1.28 \\times 8192}{2.56} = \\frac{1}{2}\\times 8192 = 4096$ LSB。$A_{\\mathrm{LSB}} = 2560  4096$。\n\n其次，我们推导以 $\\mathrm{LSB}^2$ 为单位的预期量化噪声功率。\n问题指出，量化误差 $e(t) = x(t) - \\hat{x}(t)$ 在其支撑集上均匀分布。对于步长为 $\\Delta$ 的理想均匀中置量化器，任何输入值的误差都限制在区间 $[-\\frac{\\Delta}{2}, +\\frac{\\Delta}{2}]$ 内。因此，误差的概率密度函数 (PDF) $p(e)$ 为：\n$$ p(e) = \\begin{cases} \\frac{1}{\\Delta}  \\text{当 } -\\frac{\\Delta}{2} \\le e \\le \\frac{\\Delta}{2} \\\\ 0  \\text{其他情况} \\end{cases} $$\n量化噪声功率 $P_n$ 是误差的均方值 $E[e^2]$。对于零均值过程，这等于其方差。由于分布围绕零对称，误差的均值确实为零：$E[e] = \\int_{-\\infty}^{\\infty} e \\, p(e) \\, de = \\int_{-\\Delta/2}^{\\Delta/2} e \\, \\frac{1}{\\Delta} \\, de = 0$。\n噪声功率计算如下：\n$$ P_n = E[e^2] = \\int_{-\\infty}^{\\infty} e^2 p(e) \\, de = \\int_{-\\Delta/2}^{\\Delta/2} e^2 \\frac{1}{\\Delta} \\, de $$\n$$ P_n = \\frac{1}{\\Delta} \\left[ \\frac{e^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{3\\Delta} \\left[ \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right] $$\n$$ P_n = \\frac{1}{3\\Delta} \\left[ \\frac{\\Delta^3}{8} - \\left(-\\frac{\\Delta^3}{8}\\right) \\right] = \\frac{1}{3\\Delta} \\left( \\frac{2\\Delta^3}{8} \\right) = \\frac{\\Delta^2}{12} $$\n这是以 $\\mathrm{V}^2$ 为单位的噪声功率。问题要求以 $\\mathrm{LSB}^2$ 为单位的功率。由于 $1~\\mathrm{LSB}$ 对应于电压 $\\Delta$，因此 $1~\\mathrm{LSB}^2$ 对应于功率 $\\Delta^2~\\mathrm{V}^2$。要将 $P_n$ 转换为以 $\\mathrm{LSB}^2$ 为单位，我们将其除以 $\\Delta^2$：\n$$ P_{n, \\mathrm{LSB}^2} = \\frac{P_n}{\\Delta^2} = \\frac{\\Delta^2/12}{\\Delta^2} = \\frac{1}{12} $$\n量化噪声功率为 $\\frac{1}{12}~\\mathrm{LSB}^2$，在给定模型下，这个结果与具体的 ADC 参数无关。\n\n第三，我们推导以分贝为单位的信噪比 (SNR)。\n正弦输入信号 $x(t) = A \\sin(2 \\pi f_0 t)$ 的功率是其均方值，通过在一个周期 $T = 1/f_0$ 上求平均来计算：\n$$ P_s = \\frac{1}{T} \\int_0^T x(t)^2 \\, dt = \\frac{1}{T} \\int_0^T \\left( A \\sin(2 \\pi f_0 t) \\right)^2 \\, dt = \\frac{A^2}{T} \\int_0^T \\sin^2(2 \\pi f_0 t) \\, dt $$\n使用三角恒等式 $\\sin^2(\\theta) = \\frac{1}{2}(1 - \\cos(2\\theta))$，积分变为：\n$$ P_s = \\frac{A^2}{T} \\int_0^T \\frac{1}{2}(1 - \\cos(4 \\pi f_0 t)) \\, dt = \\frac{A^2}{2T} \\left[ t - \\frac{\\sin(4 \\pi f_0 t)}{4 \\pi f_0} \\right]_0^T $$\n$$ P_s = \\frac{A^2}{2T} \\left[ (T - 0) - (0 - 0) \\right] = \\frac{A^2}{2} $$\nSNR 是信号功率 $P_s$ 与量化噪声功率 $P_n$ 的比值。必须使用相同单位的功率（例如，$\\mathrm{V}^2$）。\n$$ \\mathrm{SNR} = \\frac{P_s}{P_n} = \\frac{A^2/2}{\\Delta^2/12} = \\frac{6A^2}{\\Delta^2} = 6 \\left(\\frac{A}{\\Delta}\\right)^2 $$\n从我们的第一个任务中，我们发现 $\\frac{A}{\\Delta} = A_{\\mathrm{LSB}} = 2560$。代入这个值：\n$$ \\mathrm{SNR} = 6 \\times (2560)^2 = 6 \\times 6553600 = 39321600 $$\n以分贝 ($\\mathrm{dB}$) 表示的 SNR 定义为功率比的以 10 为底的对数的 10 倍：\n$$ \\mathrm{SNR}_{\\mathrm{dB}} = 10 \\log_{10}(\\mathrm{SNR}) = 10 \\log_{10}(39321600) $$\n$$ \\mathrm{SNR}_{\\mathrm{dB}} = 10 \\log_{10}(3.93216 \\times 10^7) = 10 \\left( \\log_{10}(3.93216) + \\log_{10}(10^7) \\right) $$\n$$ \\mathrm{SNR}_{\\mathrm{dB}} = 10 \\left( \\log_{10}(3.93216) + 7 \\right) \\approx 10(0.5946268 + 7) = 10(7.5946268) \\approx 75.946268 $$\n根据要求将结果四舍五入到四位有效数字，得到 $75.95$。\n\n这三项任务的最终结果是：峰值幅度为 $2560$ LSB，量化噪声功率为 $\\frac{1}{12}~\\mathrm{LSB}^2$，信噪比为 $75.95~\\mathrm{dB}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2560  \\frac{1}{12}  75.95 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "除了量化噪声，ADC的性能还受到由非线性引起的谐波失真和其他杂散信号的限制。无杂散动态范围（SFDR）是衡量ADC线性度的关键指标，它量化了信号在被最强的杂散信号淹没之前的可用动态范围。这个练习提供了一个实际的频谱分析场景，要求你根据谐波和非谐波杂散的电平来计算SFDR，并理解在实际测量中为何两者都必须被考虑。",
            "id": "4255224",
            "problem": "一个模数转换器 (ADC) 在其第一个奈奎斯特区内受到单音输入信号的激励。在使用相干记录和保持音调幅度的窗函数进行的稳态频谱测量中，离散时间频谱显示，一个占主导地位的三次谐波电平为 $-70\\,\\mathrm{dBc}$，以及几个非谐波杂散分量（杂散），其中最大的非谐波杂散电平为 $-68\\,\\mathrm{dBc}$。假设所有报告的杂散电平都是根据相对于载波的分贝定义，相对于基波测量的，即，对于任何功率为 $P_{x}$ 的频谱分量和功率为 $P_{1}$ 的基波，其相对于载波的分贝 (dBc) 电平为 $10\\log_{10}\\!\\big(P_{x}/P_{1}\\big)$，并且根据定义，基波位于 $0\\,\\mathrm{dBc}$。我们关心的杂散位于第一个奈奎斯特区内，并且不是由记录长度或频谱泄漏引起的混叠伪影。\n\n从上述定义以及“杂散分量是除基波外的任何离散谱线”这一概念出发，推导无杂散动态范围 (SFDR) 关于基波和最大杂散的恰当表达式，并用它来计算该转换器的 SFDR。在您的推导中，请明确论证在通常的模数转换器测量实践中，确定 SFDR 时是否应将谐波包含在杂散中。\n\n最终的 SFDR 值以 $\\mathrm{dBc}$ 表示，并将您的答案四舍五入到三位有效数字。对于最终答案，仅报告数值，不带单位。",
            "solution": "问题陈述经评估具有科学依据、提法明确、客观且完整。它描述了模数转换器 (ADC) 特性分析中的一个标准场景，并提供了计算所要求的性能指标所需的所有数据。因此，可以推导出解答。\n\n无杂散动态范围 (SFDR) 是一个关键指标，它量化了在杂散信号干扰或被误认为所需信号之前，ADC 的动态范围。它被定义为输出频谱中基波（或载波）信号的功率与最大杂散分量功率之比。\n\n设 $P_1$ 为基波的功率，$P_{spur,max}$ 为最大杂散分量的功率。作为功率比的 SFDR 为：\n$$ \\mathrm{SFDR}_{\\mathrm{ratio}} = \\frac{P_1}{P_{spur,max}} $$\n当用分贝表示时，这变为：\n$$ \\mathrm{SFDR}_{\\mathrm{dB}} = 10\\log_{10}(\\mathrm{SFDR}_{\\mathrm{ratio}}) = 10\\log_{10}\\left(\\frac{P_1}{P_{spur,max}}\\right) $$\n利用对数的性质，这个表达式可以改写为以分贝为单位的基波功率 ($P_{1,\\mathrm{dB}}$) 与以分贝为单位的最大杂散功率 ($P_{spur,max,\\mathrm{dB}}$) 之差：\n$$ \\mathrm{SFDR}_{\\mathrm{dB}} = P_{1,\\mathrm{dB}} - P_{spur,max,\\mathrm{dB}} $$\n问题以相对于载波的分贝 ($\\mathrm{dBc}$) 提供了功率电平。功率为 $P_x$ 的频谱分量，其以 $\\mathrm{dBc}$ 为单位的电平 $L_x$ 定义为：\n$$ L_{x, \\mathrm{dBc}} = 10\\log_{10}\\left(\\frac{P_x}{P_1}\\right) $$\n根据定义，基波的电平为 $L_{1, \\mathrm{dBc}} = 10\\log_{10}(P_1/P_1) = 10\\log_{10}(1) = 0\\,\\mathrm{dBc}$，如问题所述。\n\n最大杂散的电平（以 $\\mathrm{dBc}$ 为单位）为：\n$$ L_{spur,max, \\mathrm{dBc}} = 10\\log_{10}\\left(\\frac{P_{spur,max}}{P_1}\\right) $$\n我们现在可以推导出用 $\\mathrm{dBc}$ 值表示的 SFDR 表达式。请注意，$\\mathrm{SFDR}_{\\mathrm{dB}} = 10\\log_{10}(P_1/P_{spur,max}) = -10\\log_{10}(P_{spur,max}/P_1)$。将此与以 $\\mathrm{dBc}$ 为单位的杂散电平的定义进行比较，我们发现：\n$$ \\mathrm{SFDR}_{\\mathrm{dBc}} = -L_{spur,max, \\mathrm{dBc}} $$\n由于 SFDR 通常表示为代表动态范围的正值，这等价于最大杂散电平（以 $\\mathrm{dBc}$ 为单位）的绝对值：\n$$ \\mathrm{SFDR}_{\\mathrm{dBc}} = |L_{spur,max, \\mathrm{dBc}}| $$\n等效地，它是基波与最大杂散之间的幅度差：\n$$ \\mathrm{SFDR}_{\\mathrm{dBc}} = L_{1, \\mathrm{dBc}} - L_{spur,max, \\mathrm{dBc}} = 0 - L_{spur,max, \\mathrm{dBc}} = -L_{spur,max, \\mathrm{dBc}} $$\n\n下一步是确定最大的杂散分量。问题陈述“杂散分量是除基波外的任何离散谱线”。这个定义明确地包括了谐波。此外，在“通常的模数转换器测量实践”中，SFDR 几乎普遍是通过找到频谱中单个最大的无用音调来确定的，而无论其来源如何。SFDR 的目的是定义没有任何显著杂散能量的范围。限制性杂散是由 ADC 的非线性产生的谐波，还是非谐波相关的音调（例如，来自时钟馈通或其他干扰），这与 SFDR 本身的值无关，因为任何一种杂散都可能损坏信号。因此，必须将谐波视为最大杂散的候选对象。\n\n问题提供了两个潜在的最大杂散候选者的电平：\n$1$。占主导地位的三次谐波，电平为 $L_{H3} = -70\\,\\mathrm{dBc}$。\n$2$。最大的非谐波杂散，电平为 $L_{NHS} = -68\\,\\mathrm{dBc}$。\n\n要找到最大的杂散，我们必须比较这两个电平。在分贝标度中，较大的功率电平对应于较小的负值。\n由于 $-68 > -70$，因此 $-68\\,\\mathrm{dBc}$ 处的杂散比 $-70\\,\\mathrm{dBc}$ 处的杂散具有更高的功率电平。因此，整个频谱中最大的杂散分量是非谐波杂散。\n$$ L_{spur,max, \\mathrm{dBc}} = \\max(L_{H3}, L_{NHS}) = \\max(-70\\,\\mathrm{dBc}, -68\\,\\mathrm{dBc}) = -68\\,\\mathrm{dBc} $$\n\n使用推导出的 SFDR 表达式，我们可以计算其值：\n$$ \\mathrm{SFDR}_{\\mathrm{dBc}} = -L_{spur,max, \\mathrm{dBc}} = -(-68\\,\\mathrm{dBc}) = 68\\,\\mathrm{dBc} $$\n\n问题要求答案四舍五入到三位有效数字。计算值为 $68$，有两位有效数字。为了用三位有效数字表示，我们将其写为 $68.0$。\n因此，该转换器的 SFDR 为 $68.0\\,\\mathrm{dBc}$。",
            "answer": "$$\n\\boxed{68.0}\n$$"
        },
        {
            "introduction": "理论计算和实际测量之间需要一座桥梁，而这座桥梁就是严谨的验证方法学。这项综合性练习要求你编写一个程序，用以模拟ADC的输出，并实现两种核心的SNR估算方法：时域拟合和频域FFT分析。你将学习如何处理相干与非相干采样、窗函数选择等实际问题，并建立一套诊断标准来区分校准误差和信号处理伪影，这对于任何从事ADC建模或测试的工程师来说都是一项至关重要的技能。",
            "id": "4255222",
            "problem": "您的任务是为模数转换器（ADC）模型构建一套严格的验证方法，该方法比较两种信噪比（SNR）估计器：一种是基于模型拟合的时域估计器，另一种是基于离散傅里叶变换（DFT）的频域估计器。您必须定义在 $0.5$ dB 内达成一致的验收标准，并诊断由加窗选择或校准误差引起的不一致。解决方案必须从第一性原理推导，并实现为一个完整的、可运行的程序。\n\n请从以下基本依据和核心定义开始：\n\n- ADC 是一个 $N$ 位均匀量化器，其满量程峰峰值电压为 $V_{\\mathrm{pp}}$。最低有效位（LSB）的步长为 $\\Delta = V_{\\mathrm{pp}} / 2^N$。\n- 输入信号是一个离散时间正弦波 $x[n] = A \\sin(2\\pi f_{\\mathrm{in}} n / f_s)$，其中 $A$ 相对于 $V_{\\mathrm{pp}}/2$ 表示，以采样率 $f_s$ 在 $N_s$ 个采样点上采样。量化后可能会施加一个数字增益误差 $g$ 和一个数字失调误差 $o$，使得报告的数字输出为 $y[n] = g \\cdot q[n] + o$，其中 $q[n]$ 是以伏特为单位的量化值，并被限幅在 ADC 范围内。\n- 信噪比（SNR）定义为 $ \\mathrm{SNR}_{\\mathrm{dB}} = 10 \\log_{10}\\left(\\frac{P_{\\mathrm{sig}}}{P_{\\mathrm{noise}}}\\right) $，其中 $P_{\\mathrm{sig}}$ 是信号功率，$P_{\\mathrm{noise}}$ 是噪声功率。\n- 加窗序列 $x_w[n] = w[n] \\cdot x[n]$ 的离散时间 DFT 是 $X[k] = \\sum_{n=0}^{N_s-1} x_w[n] e^{-j 2\\pi k n / N_s}$。帕塞瓦尔定理（Parseval’s theorem）通过 $\\sum_{n=0}^{N_s-1} |x_w[n]|^2 = \\frac{1}{N_s} \\sum_{k=0}^{N_s-1} |X[k]|^2$ 将时域能量与频域能量关联起来。平均功率是时域能量除以 $N_s$，等于 $\\frac{1}{N_s^2} \\sum_{k=0}^{N_s-1} |X[k]|^2$。\n- 当信号音在 $N_s$ 个采样点内完成整数个周期时，即当 $C = f_{\\mathrm{in}} N_s / f_s$ 是一个整数时，发生相干采样。否则，能量会泄漏到各个频率仓（频谱泄漏），这取决于所用的窗函数 $w[n]$。\n\n请实现以下方法：\n\n1.  生成一个理想的正弦波 $x[n]$，其频率为 $f_{\\mathrm{in}}$，幅度为 $A = \\alpha \\cdot (V_{\\mathrm{pp}}/2)$，其中 $\\alpha$ 是幅度分数。使用中间步进四舍五入法将 $x[n]$ 量化为 $q[n]$，步长为 $\\Delta$，并限幅在 $[-V_{\\mathrm{pp}}/2, V_{\\mathrm{pp}}/2]$ 范围内。施加数字增益 $g$ 和失调 $o$，生成 $y[n] = g \\cdot q[n] + o$。\n2.  时域 SNR 估计：使用包含未知幅度、相位和直流失调的单音模型，通过最小二乘法拟合 $y[n]$。使用基函数 $\\sin(2\\pi f_{\\mathrm{in}} n / f_s)$、$\\cos(2\\pi f_{\\mathrm{in}} n / f_s)$ 和 $1$ 来获得系数 $B_1$、$B_2$ 和 $C$。拟合信号为 $s_{\\mathrm{fit}}[n] = B_1 \\sin(2\\pi f_{\\mathrm{in}} n / f_s) + B_2 \\cos(2\\pi f_{\\mathrm{in}} n / f_s)$，直流分量为 $C$。计算 $P_{\\mathrm{sig,td}} = \\frac{1}{N_s} \\sum_{n=0}^{N_s-1} s_{\\mathrm{fit}}[n]^2$ 和 $P_{\\mathrm{noise,td}} = \\frac{1}{N_s} \\sum_{n=0}^{N_s-1} (y[n] - C - s_{\\mathrm{fit}}[n])^2$。然后 $\\mathrm{SNR}_{\\mathrm{td}} = 10 \\log_{10} \\left( \\frac{P_{\\mathrm{sig,td}}}{P_{\\mathrm{noise,td}}} \\right)$。\n3.  频域 SNR 估计：从 $y[n]$ 中移除均值，应用指定的窗函数 $w[n]$（矩形窗、汉宁窗或布莱克曼窗），计算 DFT $X[k]$ 和每个频率仓的能量 $E[k] = |X[k]|^2 / N_s^2$。在正频率范围 $k \\in [1, \\lfloor N_s/2 \\rfloor - 1]$ 中识别基波频率仓索引 $k_{\\mathrm{peak}}$。根据窗函数定义一个主瓣捕获宽度 $m$（对于矩形窗和汉宁窗，$m=1$；对于布莱克曼窗，$m=2$）。形成信号频率仓集合 $\\mathcal{S}$，该集合包含 $k_{\\mathrm{peak}} + r$（其中 $r \\in [-m, m]$）及其对称对应部分 $N_s - (k_{\\mathrm{peak}} + r)$，并限制在有效索引范围内，同时排除直流分量（$k=0$）。计算 $P_{\\mathrm{sig,fft}} = \\sum_{k \\in \\mathcal{S}} E[k]$，$P_{\\mathrm{noise,fft}} = \\sum_{k \\notin \\mathcal{S}, k \\neq 0} E[k]$，以及 $\\mathrm{SNR}_{\\mathrm{fft}} = 10 \\log_{10} \\left( \\frac{P_{\\mathrm{sig,fft}}}{P_{\\mathrm{noise,fft}}} \\right)$。\n4.  验收标准：如果 $|\\mathrm{SNR}_{\\mathrm{td}} - \\mathrm{SNR}_{\\mathrm{fft}}| \\le 0.5$ dB，则两个 SNR 估计值一致。\n5.  差异诊断：\n    -   如果采样非相干（即 $C$ 在一个容差范围内不是整数）且捕获的信号能量分数 $\\rho = P_{\\mathrm{sig,fft}} / (P_{\\mathrm{sig,fft}} + P_{\\mathrm{noise,fft}})$ 低于某个阈值（例如，$\\rho  0.9$），则怀疑存在加窗泄漏，尤其对于矩形窗。\n    -   如果最小二乘法拟合的幅度 $A_{\\mathrm{LS}} = \\sqrt{B_1^2 + B_2^2}$ 与标称模拟幅度 $A_{\\mathrm{nom}} = \\alpha \\cdot (V_{\\mathrm{pp}}/2)$ 的相对差异超过一个相对阈值（例如， $|A_{\\mathrm{LS}} - A_{\\mathrm{nom}}| / A_{\\mathrm{nom}} > 0.02$），或者如果拟合的直流分量 $C$ 的偏差超过 $0.5$ LSB（即 $|C| > 0.5 \\Delta$），则怀疑存在校准误差。\n    -   组合标志位生成一个诊断代码：$0$ 表示没有问题，$1$ 表示怀疑有加窗泄漏，$2$ 表示怀疑有校准误差，$3$ 表示两者都有。\n\n使用 $V_{\\mathrm{pp}} = 1$ V，因此 $\\Delta = 1/2^N$ V，并将所有 SNR 值以 dB 表示，四舍五入到三位小数。如果涉及角度，必须使用弧度。\n\n测试套件：\n为以下参数集实现该方法，以验证不同方面：\n- 案例 1（理想路径，相干采样，合适的窗函数）：$N = 12$，$N_s = 4096$，$f_s = 10^6$ Hz，$C = 205$ 个周期，$f_{\\mathrm{in}} = C \\cdot f_s / N_s$，$\\alpha = 0.9$，窗函数 = 汉宁窗 (Hann)，$g = 1.0$，$o = 0.0$ V。\n- 案例 2（非相干采样，不合适的窗函数）：$N = 12$，$N_s = 4096$，$f_s = 10^6$ Hz，$C = 205.5$ 个周期，$f_{\\mathrm{in}} = C \\cdot f_s / N_s$，$\\alpha = 0.9$，窗函数 = 矩形窗，$g = 1.0$，$o = 0.0$ V。\n- 案例 3（校准误差）：$N = 12$，$N_s = 4096$，$f_s = 10^6$ Hz，$C = 205$ 个周期，$f_{\\mathrm{in}} = C \\cdot f_s / N_s$，$\\alpha = 0.9$，窗函数 = 汉宁窗，$g = 1.05$，$o = 0.5 \\Delta$ V。\n- 案例 4（低幅度边缘情况）：$N = 10$，$N_s = 4096$，$f_s = 10^6$ Hz，$C = 123.3$ 个周期，$f_{\\mathrm{in}} = C \\cdot f_s / N_s$，$\\alpha = 2 / 2^{10}$，窗函数 = 布莱克曼窗，$g = 1.0$，$o = 0.0$ V。\n\n您的程序应生成单行输出，其中包含一个 Python 风格的列表的列表，每个子列表对应一个测试案例，其条目顺序为 $[\\mathrm{SNR}_{\\mathrm{td}}, \\mathrm{SNR}_{\\mathrm{fft}}, \\mathrm{accept}, \\mathrm{diag}]$，其中 $\\mathrm{accept}$ 对真为 $1$，对假为 $0$，而 $\\mathrm{diag}$ 是上述的诊断代码。例如，最终格式应类似于 $[[x_1,y_1,a_1,d_1],[x_2,y_2,a_2,d_2],...]$，其中 $\\mathrm{SNR}$ 值四舍五入到三位小数。",
            "solution": "该解决方案通过编写一个程序来实现，该程序系统地遵循问题陈述中定义的步骤，以构建和验证一个 ADC 模型。\n\n### 1. 信号生成与 ADC 模型\n首先，根据给定的幅度、频率、采样率和采样点数生成一个离散时间的理想正弦波 $x[n]$。然后，该信号通过一个理想的 $N$ 位均匀量化器进行处理，该量化器使用中间步进四舍五入法，步长为 $\\Delta = V_{\\mathrm{pp}} / 2^N$。此过程产生量化信号 $q[n]$。最后，为了模拟真实世界的设备，我们施加一个数字增益误差 $g$ 和一个失调误差 $o$，得到最终的输出序列 $y[n] = g \\cdot q[n] + o$。\n\n### 2. 时域 SNR 估计 ($\\mathrm{SNR}_{\\mathrm{td}}$)\n此方法通过将一个参数化模型拟合到输出数据 $y[n]$ 来工作。该模型是一个纯正弦波，具有未知的幅度、相位和直流失调，其频率 $f_{\\mathrm{in}}$ 是已知的。我们使用线性最小二乘法来求解模型 $y_{\\mathrm{model}}[n] = B_1 \\sin(\\omega_0 n) + B_2 \\cos(\\omega_0 n) + C_{dc}$ 中的系数 $(B_1, B_2, C_{dc})$，其中 $\\omega_0 = 2\\pi f_{\\mathrm{in}}/f_s$。\n拟合后，信号功率 $P_{\\mathrm{sig,td}}$ 被计算为拟合的正弦分量 $s_{\\mathrm{fit}}[n] = B_1 \\sin(\\omega_0 n) + B_2 \\cos(\\omega_0 n)$ 的平均功率。噪声功率 $P_{\\mathrm{noise,td}}$ 被计算为残差（即原始信号与完整拟合模型之间的差异）的平均功率。最后，时域 SNR 就是这两种功率之比的分贝表示。\n\n### 3. 频域 SNR 估计 ($\\mathrm{SNR}_{\\mathrm{fft}}$)\n此方法在频域中操作。首先，从 $y[n]$ 中减去其均值。然后，对得到的序列应用指定的窗函数（矩形、汉宁或布莱克曼窗）以减轻频谱泄漏。接下来，计算加窗序列的离散傅里叶变换（DFT），得到频谱 $X[k]$。\n根据帕塞瓦尔定理，我们计算每个频率仓的功率。通过在频谱中找到功率最大的仓来识别基波。信号功率 $P_{\\mathrm{sig,fft}}$ 被定义为基波主瓣内（包括其负频率镜像）的功率总和，其宽度取决于所选的窗函数。噪声功率 $P_{\\mathrm{noise,fft}}$ 是所有其他频率仓（不包括直流和信号仓）中的功率总和。频域 SNR 就是这两种功率之比的分贝表示。\n\n### 4. 验收与差异诊断\n首先，比较 $\\mathrm{SNR}_{\\mathrm{td}}$ 和 $\\mathrm{SNR}_{\\mathrm{fft}}$。如果它们的差值在 $0.5$ dB 以内，则认为它们一致。\n如果不一致，则运行诊断程序：\n- **加窗泄漏**：如果采样是非相干的（即信号周期数不是整数），并且由于使用了不合适的窗函数（如矩形窗）导致大量信号能量泄漏出主瓣，则标记此问题。\n- **校准误差**：如果时域拟合产生的幅度或直流失调与标称值显著偏离（幅度误差 > 2%，或失调 > 0.5 LSB），则标记此问题。\n\n根据这些检查生成一个诊断代码，以查明不一致的根本原因。该完整的方法被封装在一个程序中，该程序处理所有指定的测试案例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the ADC verification methodology on a suite of test cases.\n    \"\"\"\n\n    def run_adc_analysis(N, Ns, fs, C, alpha, window_name, g, o_val_expr):\n        \"\"\"\n        Performs the complete ADC analysis for a single parameter set.\n        \"\"\"\n        # --- Constants and Derived Parameters ---\n        Vpp = 1.0\n        Delta = Vpp / (2**N)\n        o = eval(o_val_expr, {\"Delta\": Delta}) # Evaluate offset expression\n        fin = C * fs / Ns\n        A_nom = alpha * (Vpp / 2.0)\n        \n        # --- 1. Signal Generation and ADC Model ---\n        n = np.arange(Ns)\n        x = A_nom * np.sin(2 * np.pi * fin * n / fs)\n        \n        # Quantization (mid-tread)\n        q = Delta * np.round(x / Delta)\n        \n        # Apply digital gain and offset\n        y = g * q + o\n\n        # --- 2. Time-Domain SNR Estimation ---\n        # Set up least-squares problem: y = M * beta\n        v_sin = np.sin(2 * np.pi * fin * n / fs)\n        v_cos = np.cos(2 * np.pi * fin * n / fs)\n        v_dc = np.ones(Ns)\n        M = np.vstack([v_sin, v_cos, v_dc]).T\n        \n        # Solve for coefficients [B1, B2, C_dc]\n        beta, residuals, rank, s = np.linalg.lstsq(M, y, rcond=None)\n        B1, B2, C_dc = beta[0], beta[1], beta[2]\n        \n        # Reconstruct signal and calculate powers\n        s_fit = B1 * v_sin + B2 * v_cos\n        P_sig_td = np.mean(s_fit**2)\n        \n        # The residual from lstsq is sum of squares, not mean. We use our definition.\n        noise_td_res = y - (s_fit + C_dc)\n        P_noise_td = np.mean(noise_td_res**2)\n        \n        # Handle case of zero noise to avoid division by zero\n        if P_noise_td  1e-20:\n             snr_td = np.inf\n        else:\n             snr_td = 10 * np.log10(P_sig_td / P_noise_td)\n\n        # --- 3. Frequency-Domain SNR Estimation ---\n        y_detrend = y - np.mean(y)\n        \n        if window_name == 'rectangular':\n            w = np.ones(Ns)\n        elif window_name == 'Hann':\n            w = np.hanning(Ns)\n        elif window_name == 'Blackman':\n            w = np.blackman(Ns)\n        else:\n            raise ValueError(\"Unknown window type\")\n\n        y_w = y_detrend * w\n        X_fft = np.fft.fft(y_w)\n        \n        # Per-bin power spectrum\n        P_spec = (np.abs(X_fft)**2) / (Ns**2)\n\n        # Find peak bin in the positive frequency range [1, Ns/2 - 1]\n        pos_freq_range = slice(1, Ns // 2)\n        k_peak = np.argmax(P_spec[pos_freq_range]) + 1\n        \n        # Define signal bin set S\n        if window_name in ['rectangular', 'Hann']:\n            m = 1\n        else: # Blackman\n            m = 2\n        \n        signal_bins = set()\n        for r in range(-m, m + 1):\n            k = k_peak + r\n            if 1 = k  Ns:\n                signal_bins.add(k)\n                signal_bins.add(Ns - k)\n\n        P_sig_fft = 0\n        P_noise_fft = 0\n        \n        for k in range(1, Ns):\n            if k in signal_bins:\n                P_sig_fft += P_spec[k]\n            else:\n                P_noise_fft += P_spec[k]\n        \n        if P_noise_fft  1e-20:\n            snr_fft = np.inf\n        else:\n            snr_fft = 10 * np.log10(P_sig_fft / P_noise_fft)\n\n        # --- 4. Acceptance Criterion ---\n        accept = 1 if abs(snr_td - snr_fft) = 0.5 else 0\n\n        # --- 5. Discrepancy Diagnosis ---\n        diag_code = 0\n        \n        # Windowing leakage check\n        is_coherent = abs(C - round(C))  1e-6\n        rho = P_sig_fft / (P_sig_fft + P_noise_fft) if (P_sig_fft + P_noise_fft) > 0 else 1\n        if not is_coherent and rho  0.9:\n            diag_code |= 1\n        \n        # Calibration error check\n        A_ls = np.sqrt(B1**2 + B2**2)\n        rel_amp_error = abs(A_ls - A_nom) / A_nom if A_nom > 1e-9 else 0\n        dc_offset_in_lsb = abs(C_dc) / Delta\n        \n        if rel_amp_error > 0.02 or dc_offset_in_lsb > 0.5:\n            diag_code |= 2\n            \n        return [round(snr_td, 3), round(snr_fft, 3), accept, diag_code]\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case 1: Happy path, coherent, proper window\n        {'N': 12, 'Ns': 4096, 'fs': 1e6, 'C': 205, 'alpha': 0.9, 'window_name': 'Hann', 'g': 1.0, 'o_val_expr': '0.0'},\n        # Case 2: Non-coherent, poor window\n        {'N': 12, 'Ns': 4096, 'fs': 1e6, 'C': 205.5, 'alpha': 0.9, 'window_name': 'rectangular', 'g': 1.0, 'o_val_expr': '0.0'},\n        # Case 3: Calibration errors\n        {'N': 12, 'Ns': 4096, 'fs': 1e6, 'C': 205, 'alpha': 0.9, 'window_name': 'Hann', 'g': 1.05, 'o_val_expr': '0.5 * Delta'},\n        # Case 4: Low-amplitude edge case\n        {'N': 10, 'Ns': 4096, 'fs': 1e6, 'C': 123.3, 'alpha': 2 / (2**10), 'window_name': 'Blackman', 'g': 1.0, 'o_val_expr': '0.0'},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = run_adc_analysis(**case)\n        results.append(result)\n        \n    # Format the final output as a string representing a list of lists.\n    result_str = '[' + ','.join([str(r).replace(\" \", \"\") for r in results]) + ']'\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}