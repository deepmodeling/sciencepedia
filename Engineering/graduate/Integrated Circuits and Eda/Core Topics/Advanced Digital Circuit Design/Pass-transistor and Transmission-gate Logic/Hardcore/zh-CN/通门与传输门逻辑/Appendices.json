{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式就是动手实践。本节将从一个具体的数字逻辑单元——全加器——入手，帮助你深入理解传输晶体管逻辑（PTL）和传输门（TG）逻辑在实际电路中的行为差异。通过对一个使用NMOS管的PTL电路进行建模，你将亲手计算并观察到“弱高电平”问题，即阈值电压损失，并将其与理想的传输门进行对比，从而量化这种非理想效应对下游逻辑门正确判决的影响。",
            "id": "4287962",
            "problem": "考虑一个使用传输晶体管逻辑（PTL）实现的一位全加器，并为了比较，也考虑使用传输门（TG）逻辑的实现。该全加器有三个二进制输入，表示为$A$、$B$和$C_{in}$，并产生两个二进制输出，表示为$S$（和）和$C_{out}$（进位）。其逻辑定义为 $S = A \\oplus B \\oplus C_{in}$ 和 $C_{out} = (A \\land B) \\lor \\left(C_{in} \\land (A \\oplus B)\\right)$，其中 $\\oplus$ 表示异或，$\\land$ 表示逻辑与，$\\lor$ 表示逻辑或。\n\n您需要根据以下的器件级约束和假设，为PTL和TG两种实现方式的和节点与进位节点建立静态输出电压电平模型，然后判断下游的互补金属氧化物半导体（CMOS）反相器是否会正确解读每个输出。所有量必须使用国际单位制（SI）表示和计算，特别是电压单位为伏特。\n\n基本假设：\n- 仅当栅源电压满足 $V_{GS} \\ge V_{T}$ 时，金属氧化物半导体场效应晶体管（MOSFET）才会显著导通，其中 $V_{T}$ 是阈值电压。\n- 由于阈值电压降条件，n沟道MOSFET（NMOS）能传输强逻辑零和弱逻辑一。对于一个由$n$个串联的NMOS传输晶体管组成的链，当由一个在$V_{DD}$的高电平源驱动时，链末端的静态高电平受限于阈值条件，为 $V_{OH} \\approx \\max\\left(V_{DD} - n \\cdot V_{TN}, \\, 0\\right)$，其中 $V_{TN}$ 是NMOS的阈值电压。通过NMOS传输路径的静态低电平为 $V_{OL} \\approx 0$。\n- 传输门由一个并联的NMOS和一个p沟道MOSFET（PMOS）组成，采用互补栅极控制，能够强力传输逻辑零和逻辑一，从而得到 $V_{OH} \\approx V_{DD}$ 和 $V_{OL} \\approx 0$。\n- 下游的CMOS反相器将节点电压$V_X$解读为逻辑一（如果$V_X \\ge V_M$）或逻辑零（如果$V_X \\le V_M$），其中$V_M$是反相器的开关阈值电压。\n\n您将实现一个算法，该算法针对每个测试用例，根据输入的$A$、$B$和$C_{in}$计算逻辑输出$S$和$C_{out}$，根据指定的逻辑家族和串联传输晶体管链的长度推导出和节点与进位节点的相应静态节点电压，并判断在给定$V_M$的情况下，下游反相器是否会将每个节点解读为正确的逻辑电平。对于PTL，假设$S$处的高电平数据路径穿过$n_S$个串联的NMOS传输晶体管，$C_{out}$处的高电平数据路径穿过$n_C$个串联的NMOS传输晶体管；通过NMOS的低电平被认为是强的，即$V_{OL} \\approx 0$。对于TG逻辑，假设输出为全摆幅，即$V_{OH} \\approx V_{DD}$和$V_{OL} \\approx 0$，与$n_S$和$n_C$无关。\n\n对于每个测试用例，您的程序必须生成一个包含四个项目的列表：\n- 计算出的和节点电压，单位为伏特，四舍五入到三位小数。\n- 计算出的进位节点电压，单位为伏特，四舍五入到三位小数。\n- 一个布尔值，指示和节点是否会被下游反相器正确解读。\n- 一个布尔值，指示进位节点是否会被下游反相器正确解读。\n\n您的程序必须将所有测试用例的结果聚合到单行输出中，该输出包含一个由这些单用例列表组成的逗号分隔列表，并用方括号括起来，不含空格。例如，输出格式必须像 $[ [v_{S1},v_{C1},b_{S1},b_{C1}], [v_{S2},v_{C2},b_{S2},b_{C2}], \\dots ]$ 这样，用实际的数值和布尔值渲染，并打印为单行。所有电压均以$\\mathrm{V}$为单位表示，并四舍五入到三位小数。\n\n使用以下测试套件，其设计旨在检验不同的行为和边界条件：\n- 用例 1（正常路径，PTL，中等阈值）：\n    - 逻辑家族：$\\text{PTL}$\n    - $V_{DD} = 1.000 \\, \\mathrm{V}$\n    - $V_{TN} = 0.250 \\, \\mathrm{V}$\n    - $|V_{TP}| = 0.300 \\, \\mathrm{V}$ （在此模型中不用于PTL数据路径）\n    - $A = 1$, $B = 0$, $C_{in} = 1$\n    - $n_{S} = 1$, $n_{C} = 2$\n    - $V_{M} = 0.500 \\, \\mathrm{V}$\n- 用例 2（低电源电压，PTL鲁棒性检查）：\n    - 逻辑家族：$\\text{PTL}$\n    - $V_{DD} = 0.700 \\, \\mathrm{V}$\n    - $V_{TN} = 0.300 \\, \\mathrm{V}$\n    - $|V_{TP}| = 0.300 \\, \\mathrm{V}$\n    - $A = 1$, $B = 1$, $C_{in} = 0$\n    - $n_{S} = 1$, $n_{C} = 1$\n    - $V_{M} = 0.350 \\, \\mathrm{V}$\n- 用例 3（TG全摆幅比较）：\n    - 逻辑家族：$\\text{TG}$\n    - $V_{DD} = 1.200 \\, \\mathrm{V}$\n    - $V_{TN} = 0.250 \\, \\mathrm{V}$\n    - $|V_{TP}| = 0.300 \\, \\mathrm{V}$\n    - $A = 0$, $B = 1$, $C_{in} = 0$\n    - $n_{S} = 2$, $n_{C} = 2$ （不用于TG全摆幅）\n    - $V_{M} = 0.600 \\, \\mathrm{V}$\n- 用例 4（边界失效，PTL，严重阈值压降）：\n    - 逻辑家族：$\\text{PTL}$\n    - $V_{DD} = 0.600 \\, \\mathrm{V}$\n    - $V_{TN} = 0.350 \\, \\mathrm{V}$\n    - $|V_{TP}| = 0.300 \\, \\mathrm{V}$\n    - $A = 1$, $B = 0$, $C_{in} = 0$\n    - $n_{S} = 2$, $n_{C} = 1$\n    - $V_{M} = 0.300 \\, \\mathrm{V}$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，格式为 $[[v_{S1},v_{C1},b_{S1},b_{C1}],[v_{S2},v_{C2},b_{S2},b_{C2}],[v_{S3},v_{C3},b_{S3},b_{C3}],[v_{S4},v_{C4},b_{S4},b_{C4}]]$，其中每个$v$是以$\\mathrm{V}$为单位的电压，四舍五入到三位小数，每个$b$是一个布尔值。",
            "solution": "该问题要求分析一个使用两种不同逻辑风格实现的一位全加器的静态输出电压电平：传输晶体管逻辑（PTL）和传输门（TG）逻辑。目标是确定这些电压电平，并评估后续的CMOS反相器是否会正确解读相应的逻辑值。该评估基于一个简化的器件模型，该模型考虑了n沟道金属氧化物半导体场效应晶体管（NMOS）中的阈值电压降。\n\n全加器的基本逻辑运算为和（$S$）与进位输出（$C_{out}$）定义如下：\n$$S = A \\oplus B \\oplus C_{in}$$\n$$C_{out} = (A \\land B) \\lor (C_{in} \\land (A \\oplus B))$$\n其中$A$、$B$和$C_{in}$是二进制输入。运算符$\\oplus$、$\\land$和$\\lor$分别代表异或、逻辑与和逻辑或。\n\n分析的关键在于所提供的逻辑家族的静态电压模型：\n\n1.  传输晶体管逻辑（PTL）：此实现仅使用NMOS晶体管作为传输门。\n    -   NMOS晶体管强力传输逻辑'0'，导致输出低电压（$V_{OL}$）约为$0 \\, \\mathrm{V}$。\n        $$V_{OL} \\approx 0 \\, \\mathrm{V}$$\n    -   NMOS晶体管弱力传输逻辑'1'。当一个在$V_{DD}$的高电平信号通过一个由$n$个串联NMOS晶体管组成的链时，输出高电压（$V_{OH}$）会因$n$个阈值电压（$V_{TN}$）降而降低。电压不能低于$0 \\, \\mathrm{V}$。\n        $$V_{OH} \\approx \\max(V_{DD} - n \\cdot V_{TN}, 0)$$\n    -   问题指明，对于逻辑'1'输出，和节点（$S$）的路径涉及$n_S$个串联晶体管，而进位输出节点（$C_{out}$）的路径涉及$n_C$个串联晶体管。\n\n2.  传输门（TG）逻辑：此实现使用一个并联的NMOS和一个p沟道MOSFET（PMOS）组合来传输信号。\n    -   TG能够强力传输逻辑'0'和逻辑'1'，从而实现全摆幅输出。\n        $$V_{OL} \\approx 0 \\, \\mathrm{V}$$\n        $$V_{OH} \\approx V_{DD}$$\n    -   在此模型中，输出电压与串联门的数量$n_S$或$n_C$无关。\n\n3.  下游反相器解读：一个开关阈值电压为$V_M$的下游CMOS反相器，按如下方式解读输入电压$V_X$：\n    -   如果 $V_X \\ge V_M$，则为逻辑'1'（高电平）。\n    -   如果 $V_X \\le V_M$，则为逻辑'0'（低电平）。\n\n解读的正确性通过比较反相器的行为与预期的逻辑输出来确定。\n-   如果预期的逻辑输出是'1'，当其电压$V_{out}$满足$V_{out} \\ge V_M$时，输出被正确解读。\n-   如果预期的逻辑输出是'0'，当其电压$V_{out}$满足$V_{out} \\le V_M$时，输出被正确解读。\n\n每个测试用例的算法流程如下：\n1.  使用全加器的布尔表达式，根据给定的输入$A$、$B$和$C_{in}$计算理想的逻辑输出$S$和$C_{out}$。\n2.  根据指定的`logic_family`和计算出的逻辑输出，确定和节点（$V_S$）和进位输出节点（$V_{Cout}$）的静态输出电压。\n    -   如果逻辑输出为'0'，则电压为$0 \\, \\mathrm{V}$。\n    -   如果逻辑输出为'1'，则使用PTL模型（$V_{OH} \\approx \\max(V_{DD} - n \\cdot V_{TN}, 0)$，使用相关的$n$）或TG模型（$V_{OH} \\approx V_{DD}$）计算电压。\n3.  评估每个输出解读的正确性。对于逻辑值为$S_{logic}$、电压为$V_S$的和输出$S$，其正确性由以下条件确定：$(S_{logic}=1 \\land V_S \\ge V_M) \\lor (S_{logic}=0 \\land V_S \\le V_M)$。对进位输出执行类似的检查。\n4.  将每个用例的结果格式化为一个列表，其中包含四舍五入的电压和布尔正确性标志：$[V_S, V_{Cout}, \\text{is_S_correct}, \\text{is_Cout_correct}]$。\n\n此流程应用于四个测试用例中的每一个。\n\n**用例 1 分析：**\n- 输入：`logic_family`=PTL, $V_{DD}=1.0\\,\\mathrm{V}$, $V_{TN}=0.250\\,\\mathrm{V}$, $A=1$, $B=0$, $C_{in}=1$, $n_S=1$, $n_C=2$, $V_M=0.500\\,\\mathrm{V}$。\n- 逻辑输出：$S = 1 \\oplus 0 \\oplus 1 = 0$; $C_{out} = (1 \\land 0) \\lor (1 \\land (1 \\oplus 0)) = 1$。\n- 电压 (PTL)：\n    - $V_S$（对于逻辑 $0$）：$0.0\\,\\mathrm{V}$。\n    - $V_{Cout}$（对于逻辑 $1$）：$V_{OH} = \\max(1.0 - 2 \\cdot 0.250, 0) = \\max(0.5, 0) = 0.5\\,\\mathrm{V}$。\n- 正确性：\n    - 和：逻辑值为 $0$，$V_S=0.0\\,\\mathrm{V}$。如果 $0.0 \\le 0.500$ 则正确，结果为 True。\n    - 进位：逻辑值为 $1$，$V_{Cout}=0.5\\,\\mathrm{V}$。如果 $0.5 \\ge 0.500$ 则正确，结果为 True。\n- 结果：$[0.000, 0.500, \\text{True}, \\text{True}]$\n\n**用例 2 分析：**\n- 输入：`logic_family`=PTL, $V_{DD}=0.700\\,\\mathrm{V}$, $V_{TN}=0.300\\,\\mathrm{V}$, $A=1$, $B=1$, $C_{in}=0$, $n_S=1$, $n_C=1$, $V_M=0.350\\,\\mathrm{V}$。\n- 逻辑输出：$S = 1 \\oplus 1 \\oplus 0 = 0$; $C_{out} = (1 \\land 1) \\lor (0 \\land (1 \\oplus 1)) = 1$。\n- 电压 (PTL)：\n    - $V_S$（对于逻辑 $0$）：$0.0\\,\\mathrm{V}$。\n    - $V_{Cout}$（对于逻辑 $1$）：$V_{OH} = \\max(0.7 - 1 \\cdot 0.300, 0) = \\max(0.4, 0) = 0.4\\,\\mathrm{V}$。\n- 正确性：\n    - 和：逻辑值为 $0$，$V_S=0.0\\,\\mathrm{V}$。如果 $0.0 \\le 0.350$ 则正确，结果为 True。\n    - 进位：逻辑值为 $1$，$V_{Cout}=0.4\\,\\mathrm{V}$。如果 $0.4 \\ge 0.350$ 则正确，结果为 True。\n- 结果：$[0.000, 0.400, \\text{True}, \\text{True}]$\n\n**用例 3 分析：**\n- 输入：`logic_family`=TG, $V_{DD}=1.200\\,\\mathrm{V}$, $A=0$, $B=1$, $C_{in}=0$, $V_M=0.600\\,\\mathrm{V}$。\n- 逻辑输出：$S = 0 \\oplus 1 \\oplus 0 = 1$; $C_{out} = (0 \\land 1) \\lor (0 \\land (0 \\oplus 1)) = 0$。\n- 电压 (TG)：\n    - $V_S$（对于逻辑 $1$）：$V_{OH} = V_{DD} = 1.2\\,\\mathrm{V}$。\n    - $V_{Cout}$（对于逻辑 $0$）：$0.0\\,\\mathrm{V}$。\n- 正确性：\n    - 和：逻辑值为 $1$，$V_S=1.2\\,\\mathrm{V}$。如果 $1.2 \\ge 0.600$ 则正确，结果为 True。\n    - 进位：逻辑值为 $0$，$V_{Cout}=0.0\\,\\mathrm{V}$。如果 $0.0 \\le 0.600$ 则正确，结果为 True。\n- 结果：$[1.200, 0.000, \\text{True}, \\text{True}]$\n\n**用例 4 分析：**\n- 输入：`logic_family`=PTL, $V_{DD}=0.600\\,\\mathrm{V}$, $V_{TN}=0.350\\,\\mathrm{V}$, $A=1$, $B=0$, $C_{in}=0$, $n_S=2$, $n_C=1$, $V_M=0.300\\,\\mathrm{V}$。\n- 逻辑输出：$S = 1 \\oplus 0 \\oplus 0 = 1$; $C_{out} = (1 \\land 0) \\lor (0 \\land (1 \\oplus 0)) = 0$。\n- 电压 (PTL)：\n    - $V_S$（对于逻辑 $1$）：$V_{OH} = \\max(0.6 - 2 \\cdot 0.350, 0) = \\max(0.6 - 0.7, 0) = \\max(-0.1, 0) = 0.0\\,\\mathrm{V}$。\n    - $V_{Cout}$（对于逻辑 $0$）：$0.0\\,\\mathrm{V}$。\n- 正确性：\n    - 和：逻辑值为 $1$，$V_S=0.0\\,\\mathrm{V}$。如果 $0.0 \\ge 0.300$ 则正确，结果为 False。\n    - 进位：逻辑值为 $0$，$V_{Cout}=0.0\\,\\mathrm{V}$。如果 $0.0 \\le 0.300$ 则正确，结果为 True。\n- 结果：$[0.000, 0.000, \\text{False}, \\text{True}]$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing PTL and TG full adder output voltages\n    and their interpretation by a downstream inverter.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, PTL with moderate thresholds)\n        {\n            \"logic_family\": \"PTL\", \"v_dd\": 1.000, \"v_tn\": 0.250, \n            \"a\": 1, \"b\": 0, \"c_in\": 1, \"n_s\": 1, \"n_c\": 2, \"v_m\": 0.500\n        },\n        # Case 2 (low supply, PTL robustness check)\n        {\n            \"logic_family\": \"PTL\", \"v_dd\": 0.700, \"v_tn\": 0.300, \n            \"a\": 1, \"b\": 1, \"c_in\": 0, \"n_s\": 1, \"n_c\": 1, \"v_m\": 0.350\n        },\n        # Case 3 (TG comparison with full swing)\n        {\n            \"logic_family\": \"TG\", \"v_dd\": 1.200, \"v_tn\": 0.250, \n            \"a\": 0, \"b\": 1, \"c_in\": 0, \"n_s\": 2, \"n_c\": 2, \"v_m\": 0.600\n        },\n        # Case 4 (boundary failure, PTL with severe threshold drop)\n        {\n            \"logic_family\": \"PTL\", \"v_dd\": 0.600, \"v_tn\": 0.350, \n            \"a\": 1, \"b\": 0, \"c_in\": 0, \"n_s\": 2, \"n_c\": 1, \"v_m\": 0.300\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # 1. Calculate ideal logical outputs\n        s_logic = case[\"a\"] ^ case[\"b\"] ^ case[\"c_in\"]\n        a_xor_b = case[\"a\"] ^ case[\"b\"]\n        cout_logic = (case[\"a\"]  case[\"b\"]) | (case[\"c_in\"]  a_xor_b)\n\n        v_s = 0.0\n        v_cout = 0.0\n\n        # 2. Determine static output voltages based on logic family and logic levels\n        if case[\"logic_family\"] == \"PTL\":\n            if s_logic == 1:\n                v_s = max(case[\"v_dd\"] - case[\"n_s\"] * case[\"v_tn\"], 0.0)\n            else: # s_logic == 0\n                v_s = 0.0\n            \n            if cout_logic == 1:\n                v_cout = max(case[\"v_dd\"] - case[\"n_c\"] * case[\"v_tn\"], 0.0)\n            else: # cout_logic == 0\n                v_cout = 0.0\n        \n        elif case[\"logic_family\"] == \"TG\":\n            if s_logic == 1:\n                v_s = case[\"v_dd\"]\n            else: # s_logic == 0\n                v_s = 0.0\n            \n            if cout_logic == 1:\n                v_cout = case[\"v_dd\"]\n            else: # cout_logic == 0\n                v_cout = 0.0\n\n        # 3. Evaluate correctness of downstream interpretation\n        v_m = case[\"v_m\"]\n        \n        is_s_correct = False\n        if s_logic == 1:\n            is_s_correct = (v_s >= v_m)\n        else: # s_logic == 0\n            is_s_correct = (v_s = v_m)\n            \n        is_cout_correct = False\n        if cout_logic == 1:\n            is_cout_correct = (v_cout >= v_m)\n        else: # cout_logic == 0\n            is_cout_correct = (v_cout = v_m)\n\n        # 4. Store results for this case\n        all_results.append([v_s, v_cout, is_s_correct, is_cout_correct])\n\n    # 5. Format and print the final output string\n    result_strings = []\n    for res in all_results:\n        # Format: [voltage_S (3dp), voltage_C (3dp), bool_S, bool_C]\n        s = f\"[{res[0]:.3f},{res[1]:.3f},{str(res[2])},{str(res[3])}]\"\n        result_strings.append(s)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在上一节的实践中，我们看到了NMOS传输管导致的电压损失。一个自然而然的问题是：作为电路设计者，我们如何确保即使存在这种电压损失，电路依然能可靠工作？这项练习将引导你从器件物理的第一性原理出发，推导出一个关键的设计约束方程。你将为保证电平再生接收器能够被成功触发，计算出所需的最小电源电压$V_{DD, \\min}$，从而将器件参数与电路的鲁棒性直接联系起来。",
            "id": "4287937",
            "problem": "一个以传输晶体管风格实现的逻辑网络，使用单个$n$沟道金属氧化物半导体（NMOS）传输器件，将上游驱动器在电源电压$V_{DD}$下的高逻辑电平传输到下游互连节点$X$上。当需要向前传输高逻辑电平时，该NMOS管的栅极被驱动至$V_{DD}$，其体端接地。由于源-体偏置效应，节点$X$上的高电平相对于$V_{DD}$有所下降。节点$X$连接到一个电平恢复接收器，该接收器由一个静态互补金属氧化物半导体（CMOS）反相器和一个反馈控制的$p$沟道金属氧化物半导体（PMOS）上拉管组成。一旦反相器翻转，该上拉管会将节点$X$的电平恢复至$V_{DD}$。设反相器的输入开关阈值为$V_{M}$，其定义为当$V_{X}$超过$V_{M}$时，反相器输出发生翻转。\n\n假设以下经过充分测试的器件行为：\n- 在源-体偏置$V_{SB}$下，NMOS的阈值电压为$V_{TN}(V_{SB})=V_{TN0}+\\gamma\\left(\\sqrt{2\\phi_{F}+V_{SB}}-\\sqrt{2\\phi_{F}}\\right)$，其中$V_{TN0}$是零偏压NMOS阈值，$\\gamma$是体效应系数，$\\phi_{F}$是衬底的费米势。\n- 当NMOS传输器件的栅极保持在$V_{DD}$以传输高逻辑电平时，随着节点$X$的电压上升，当$V_{GS}$等于阈值电压时，导通停止，从而得到平衡关系式$V_{X}=V_{DD}-V_{TN}(V_{SB}=V_{X})$。\n\n为了让电平恢复接收器能够触发并恢复高逻辑电平，节点$X$上经过衰减的高电平必须满足$V_{X}\\geq V_{M}$。请推导一个闭式解析表达式，用于计算最小电源电压$V_{DD,\\min}$。该电压需确保NMOS传输晶体管传输到节点$X$的高电平至少达到$V_{M}$，从而触发电平恢复反相器翻转，并使PMOS恢复器工作。请将您的最终答案表示为以伏特为单位的、仅包含$V_{M}$、$V_{TN0}$、$\\gamma$和$\\phi_{F}$的单个符号表达式。不要四舍五入。",
            "solution": "该问题要求推导使传输晶体管电路与电平恢复接收器能正常工作的最小电源电压$V_{DD, \\min}$。分析首先从形式化给定的条件开始。\n\n首先，我们考虑$n$沟道金属氧化物半导体（NMOS）传输晶体管的行为。它被配置用于传输高逻辑电平。其栅极连接到电源电压$V_{DD}$。漏极连接到高电平源，电压也为$V_{DD}$。晶体管的源极连接到目标节点$X$，因此其电压为$V_X$。晶体管的体端接地，因此其电位为$0$。\n\n只要晶体管的栅-源电压$V_{GS}$大于其阈值电压$V_{TN}$，电流就会从漏极流向源极。栅极电压为$V_G = V_{DD}$，源极电压为$V_S = V_X$。因此，$V_{GS} = V_G - V_S = V_{DD} - V_X$。随着电荷流向节点$X$，其电压$V_X$上升，导致$V_{GS}$减小。当$V_{GS}$下降到阈值电压$V_{TN}$时，导通停止，节点$X$达到其稳定最终电压。这个平衡状态由给定的关系式描述：\n$$V_{X} = V_{DD} - V_{TN}(V_X)$$\n符号$V_{TN}(V_X)$强调了由于体效应，阈值电压本身依赖于源极电压$V_X$。\n\n体效应描述了由于非零的源-体偏置$V_{SB}$引起的阈值电压变化。在这里，源极电位为$V_S = V_X$，体端电位为$V_B = 0$，所以$V_{SB} = V_S - V_B = V_X - 0 = V_X$。题目提供了在此偏置下阈值电压的标准模型：\n$$V_{TN}(V_{SB}) = V_{TN0} + \\gamma \\left( \\sqrt{2\\phi_{F} + V_{SB}} - \\sqrt{2\\phi_{F}} \\right)$$\n其中$V_{TN0}$是零偏压阈值电压，$\\gamma$是体效应系数，$2\\phi_F$是强反型时的表面势，而$\\phi_F$是衬底的费米势。\n\n将$V_{SB} = V_X$代入阈值电压方程，我们得到：\n$$V_{TN}(V_X) = V_{TN0} + \\gamma \\left( \\sqrt{2\\phi_{F} + V_X} - \\sqrt{2\\phi_{F}} \\right)$$\n\n现在，我们将$V_{TN}(V_X)$的这个表达式代回到节点电压$V_X$的平衡条件中：\n$$V_{X} = V_{DD} - \\left[ V_{TN0} + \\gamma \\left( \\sqrt{2\\phi_{F} + V_X} - \\sqrt{2\\phi_{F}} \\right) \\right]$$\n该方程将稳态传输电压$V_X$与电源电压$V_{DD}$及器件参数联系起来。\n\n题目指出，为使电平恢复接收器触发，节点$X$的电压必须至少达到反相器的开关阈值$V_M$。这个条件表示为：\n$$V_{X} \\geq V_{M}$$\n\n我们正在寻找满足此条件的最小电源电压$V_{DD, \\min}$。最小电压对应于传输电压$V_X$恰好等于所需最小值$V_M$的临界情况。通过设置$V_X = V_M$并相应地设置$V_{DD} = V_{DD, \\min}$，我们可以求解所需的电源电压。\n\n将$V_X = V_M$代入控制方程：\n$$V_{M} = V_{DD, \\min} - \\left[ V_{TN0} + \\gamma \\left( \\sqrt{2\\phi_{F} + V_M} - \\sqrt{2\\phi_{F}} \\right) \\right]$$\n\n为了求出$V_{DD, \\min}$的表达式，我们通过将$V_{DD, \\min}$移到等式一侧来重新整理方程：\n$$V_{DD, \\min} = V_M + V_{TN0} + \\gamma \\left( \\sqrt{2\\phi_{F} + V_M} - \\sqrt{2\\phi_{F}} \\right)$$\n\n这就是所需的最小电源电压的最终闭式解析表达式。它完全由给定参数表示：反相器开关阈值$V_M$、零偏压NMOS阈值$V_{TN0}$、体效应系数$\\gamma$和费米势$\\phi_F$。表达式中的所有项都以伏特为单位，确保了量纲上的一致性。",
            "answer": "$$\\boxed{V_{M} + V_{TN0} + \\gamma \\left( \\sqrt{2\\phi_{F} + V_{M}} - \\sqrt{2\\phi_{F}} \\right)}$$"
        },
        {
            "introduction": "确定性分析虽然是电路设计的基础，但它无法完全捕捉真实世界中制造工艺波动带来的影响。为了设计出真正稳健的芯片，我们必须从统计学的角度来评估电路的可靠性。这项高级实践将带你进入统计电路分析的世界，通过蒙特卡洛（Monte Carlo）仿真方法，评估在器件参数（如阈值电压和导通电阻）存在随机变化时，传输管电路的成品率（yield）。通过这项练习，你将从分析单个“最差情况”的思维模式，提升到对电路性能进行概率性预测的高度。",
            "id": "4287967",
            "problem": "考虑在工艺变化下，互补金属氧化物半导体（CMOS）传输晶体管逻辑（PTL）和传输门（TG）互连中逻辑电平传输的统计鲁棒性。您将设计一个蒙特卡洛程序，用于估算当通过单个n沟道金属氧化物半导体场效应晶体管（NMOS）传输晶体管或一个完整的传输门驱动时，被驱动节点满足给定逻辑电平约束的概率。\n\n仅使用以下基本定律和经过充分检验的关系式作为您的建模基础：\n- 欧姆定律以及串联/并联电阻组合。\n- NMOS阈值电压的长沟道体效应关系式：$$V_{tn}(V_{SB}) = V_{tn0} + \\gamma\\left(\\sqrt{2\\phi_F + V_{SB}} - \\sqrt{2\\phi_F}\\right)$$, 其中 $V_{tn0}$ 是零偏置阈值电压，$\\gamma$ 是体效应参数，$\\phi_F$ 是费米势。假设NMOS的体（body）接地，因此在传输高逻辑电平时 $V_{SB} = V_{out}$。\n- 对于传输高逻辑电平的单个NMOS传输器件，当 $$V_{out} = V_{DD} - V_{tn}(V_{out})$$ 时，达到源极跟随器极限，除了任何阻性负载外，您还必须强制执行此条件。对于通过单个NMOS传输低逻辑电平，没有阈值压降限制。\n- 对于由并联的NMOS和p沟道金属氧化物半导体场效应晶体管（PMOS）组成的传输门，忽略阈值压降限制；仅将其有限的导通电阻建模为NMOS和PMOS导通电阻的并联组合。\n\n将被驱动节点建模为连接到某一电源的纯阻性负载，从而在驱动器的有限导通电阻和负载之间产生静态分压。设 $R_{on,n}$ 表示NMOS的导通电阻，$R_{on,p}$ 表示PMOS的导通电阻，$R_{eff}$ 表示传输门在导通状态下的有效导通电阻，由下式给出 $$R_{eff} = \\left(\\frac{1}{R_{on,n}} + \\frac{1}{R_{on,p}}\\right)^{-1}$$。\n\n统计变化模型：\n- 将每个电阻和每个阈值参数视为具有给定均值和标准差的独立高斯（正态）随机变量，对于电阻，通过重采样直至获得严格为正的值，将其截断到严格为正的支撑集上。\n- 使用固定的随机种子 $12345$ 以确保可复现性。\n- 对于任何采样到的非物理电阻（非正值），进行重采样直到获得正值。对于任何采样到的阈值参数，使用未经截断的原始高斯抽样值。\n\n每次试验的蒙特卡洛逻辑电平评估：\n- 对于单个NMOS在电源 $V_{DD}$、输入 $V_{in} = V_{DD}$ 的情况下，将高逻辑电平传输到值为 $R_L$ 的接地电阻负载：\n  1. 采样 $V_{tn0}$ 和 $R_{on,n}$。\n  2. 计算体效应限制的 $V_{out}$，作为 $$V_{out} = V_{DD} - \\left(V_{tn0} + \\gamma\\left(\\sqrt{2\\phi_F + V_{out}} - \\sqrt{2\\phi_F}\\right)\\right)$$ 的物理有效解，其中 $V_{out}$ 限制在区间 $[0, V_{DD}]$ 内。\n  3. 计算电阻分压的 $V_{out}$ 为 $$V_{out,div} = V_{DD}\\cdot \\frac{R_L}{R_{on,n} + R_L}$$。\n  4. 静态 $V_{out}$ 是体效应限制值和电阻分压值中的较小者。\n- 对于单个NMOS在输入 $V_{in} = 0$ 的情况下，将低逻辑电平传输到值为 $R_U$ 的上拉到 $V_{DD}$ 的电阻负载：\n  1. 采样 $R_{on,n}$。\n  2. 计算 $$V_{out} = V_{DD}\\cdot \\frac{R_{on,n}}{R_{on,n} + R_U}。$$\n- 对于传输门将高逻辑电平传输到接地电阻负载：\n  1. 采样 $R_{on,n}$ 和 $R_{on,p}$，计算 $R_{eff}$。\n  2. 计算 $$V_{out} = V_{DD}\\cdot \\frac{R_L}{R_{eff} + R_L}。$$\n- 对于传输门将低逻辑电平传输到上拉到 $V_{DD}$ 的电阻负载：\n  1. 采样 $R_{on,n}$ 和 $R_{on,p}$，计算 $R_{eff}$。\n  2. 计算 $$V_{out} = V_{DD}\\cdot \\frac{R_{eff}}{R_{eff} + R_U}。$$\n\n对于以下每种情况，通过蒙特卡洛估算良率（yield），其定义为在接收端满足指定逻辑阈值的试验所占的比例：\n- 对于高逻辑电平检查，标准是 $V_{out} \\ge V_{IH,min}$。\n- 对于低逻辑电平检查，标准是 $V_{out} \\le V_{IL,max}$。\n\n单位：\n- 电压以 $\\mathrm{V}$ 表示，电阻以 $\\mathrm{\\Omega}$ 表示。最终输出是无量纲的蒙特卡洛良率，必须以小数（而非百分比）表示。\n\n测试套件：\n- 情况 $1$（单个NMOS，传输高电平，中等负载）：\n  - $V_{DD} = 1.0\\,\\mathrm{V}$，$V_{in} = 1.0\\,\\mathrm{V}$，$V_{IH,min} = 0.5\\,\\mathrm{V}$。\n  - $V_{tn0} \\sim \\mathcal{N}(\\mu = 0.35\\,\\mathrm{V}, \\sigma = 0.03\\,\\mathrm{V})$。\n  - $\\gamma = 0.45\\,\\mathrm{V}^{1/2}$，$\\phi_F = 0.3\\,\\mathrm{V}$，因此 $2\\phi_F = 0.6\\,\\mathrm{V}$。\n  - $R_{on,n} \\sim \\mathcal{N}(\\mu = 4.0\\times 10^3\\,\\mathrm{\\Omega}, \\sigma = 0.6\\times 10^3\\,\\mathrm{\\Omega})$，截断至 $R_{on,n}  0$。\n  - 负载 $R_L = 2.0\\times 10^4\\,\\mathrm{\\Omega}$。\n  - 蒙特卡洛试验次数 $N = 100000$。\n- 情况 $2$（传输门，传输高电平，中等负载）：\n  - $V_{DD} = 1.0\\,\\mathrm{V}$，$V_{in} = 1.0\\,\\mathrm{V}$，$V_{IH,min} = 0.7\\,\\mathrm{V}$。\n  - $R_{on,n} \\sim \\mathcal{N}(4.0\\times 10^3\\,\\mathrm{\\Omega}, 0.6\\times 10^3\\,\\mathrm{\\Omega})$，$R_{on,p} \\sim \\mathcal{N}(6.0\\times 10^3\\,\\mathrm{\\Omega}, 0.9\\times 10^3\\,\\mathrm{\\Omega})$，两者均截断为正值。\n  - 负载 $R_L = 2.0\\times 10^4\\,\\mathrm{\\Omega}$。\n  - 蒙特卡洛试验次数 $N = 50000$。\n- 情况 $3$（单个NMOS，传输低电平，上拉负载）：\n  - $V_{DD} = 1.0\\,\\mathrm{V}$，$V_{in} = 0\\,\\mathrm{V}$，$V_{IL,max} = 0.2\\,\\mathrm{V}$。\n  - $R_{on,n} \\sim \\mathcal{N}(4.0\\times 10^3\\,\\mathrm{\\Omega}, 0.6\\times 10^3\\,\\mathrm{\\Omega})$，截断为正值。\n  - 负载 $R_U = 2.0\\times 10^4\\,\\mathrm{\\Omega}$。\n  - 蒙特卡洛试验次数 $N = 50000$。\n- 情况 $4$（传输门，传输低电平，上拉负载）：\n  - $V_{DD} = 1.0\\,\\mathrm{V}$，$V_{in} = 0\\,\\mathrm{V}$，$V_{IL,max} = 0.2\\,\\mathrm{V}$。\n  - $R_{on,n} \\sim \\mathcal{N}(4.0\\times 10^3\\,\\mathrm{\\Omega}, 0.6\\times 10^3\\,\\mathrm{\\Omega})$，$R_{on,p} \\sim \\mathcal{N}(6.0\\times 10^3\\,\\mathrm{\\Omega}, 0.9\\times 10^3\\,\\mathrm{\\Omega})$，两者均截断为正值。\n  - 负载 $R_U = 2.0\\times 10^4\\,\\mathrm{\\Omega}$。\n  - 蒙特卡洛试验次数 $N = 50000$。\n- 情况 $5$（单个NMOS，传输高电平，近阈值边界，极轻负载）：\n  - $V_{DD} = 1.0\\,\\mathrm{V}$，$V_{in} = 1.0\\,\\mathrm{V}$，$V_{IH,min} = 0.525\\,\\mathrm{V}$。\n  - $V_{tn0} \\sim \\mathcal{N}(0.35\\,\\mathrm{V}, 0.03\\,\\mathrm{V})$。\n  - $\\gamma = 0.45\\,\\mathrm{V}^{1/2}$，$\\phi_F = 0.3\\,\\mathrm{V}$。\n  - $R_{on,n} \\sim \\mathcal{N}(4.0\\times 10^3\\,\\mathrm{\\Omega}, 0.6\\times 10^3\\,\\mathrm{\\Omega})$，截断为正值。\n  - 负载 $R_L = 1.0\\times 10^9\\,\\mathrm{\\Omega}$。\n  - 蒙特卡洛试验次数 $N = 20000$。\n\n实现要求：\n- 使用随机种子 $12345$。\n- 对于每种情况，计算蒙特卡洛良率，结果为 $[0,1]$ 区间内的一个小数。\n- 您的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起来（例如，$[r_1,r_2,r_3,r_4,r_5]$），结果按情况 $1$ 到情况 $5$ 的顺序排列。\n- 程序必须是自包含的，并且不得读取任何输入或写入任何文件。",
            "solution": "该问题要求设计一个蒙特卡洛模拟，以估算传输晶体管逻辑（PTL）和传输门（TG）互连的良率。良率定义为在存在统计性工艺变化的情况下，被驱动节点的输出电压满足指定逻辑电平要求（对于高逻辑电平，$V_{out} \\ge V_{IH,min}$；对于低逻辑电平，$V_{out} \\le V_{IL,max}$）的概率。分析将针对四种不同场景进行：n沟道金属氧化物半导体（NMOS）传输晶体管传输高逻辑电平和低逻辑电平，以及互补金属氧化物半导体（CMOS）传输门在相同条件下的情况。\n\n解决方案的开发严格遵循所提供的物理模型和统计方法。该方法的核心是一个数值模拟，它通过大量试验来评估电路性能，其中器件参数被视为随机变量。\n\n首先，我们建立建模框架。互连的行为使用基本电路原理进行建模。被驱动节点表示为由传输器件的有效导通电阻和电阻性负载形成的静态分压器。对于传输高逻辑电平的单个NMOS，存在一个额外的关键约束：输出电压不能超过栅极电压减去阈值电压。这种现象被称为阈值压降，并因体效应而加剧，即NMOS的阈值电压 $V_{tn}$ 随着其源极-体极电压 $V_{SB}$ 的升高而增加。问题为此效应提供了长沟道模型：\n$$V_{tn}(V_{SB}) = V_{tn0} + \\gamma\\left(\\sqrt{2\\phi_F + V_{SB}} - \\sqrt{2\\phi_F}\\right)$$\n当从输入 $V_{in} = V_{DD}$ 传输高逻辑电平时，NMOS的源极端子是输出节点，因此 $V_{SB} = V_{out}$。源极跟随器极限因此由以下隐式方程定义：\n$$V_{out} = V_{DD} - V_{tn}(V_{out})$$\n对于由并联的NMOS和p沟道金属氧化物半导体（PMOS）组成的传输门，这种阈值压降限制被认为可以忽略不计。其行为仅通过有效导通电阻 $R_{eff}$ 来建模，该电阻计算为单个晶体管导通电阻 $R_{on,n}$ 和 $R_{on,p}$ 的并联组合：\n$$R_{eff} = \\left(\\frac{1}{R_{on,n}} + \\frac{1}{R_{on,p}}\\right)^{-1}$$\n\n通过将零偏置阈值电压 $V_{tn0}$ 和导通电阻 $R_{on,n}$、$R_{on,p}$ 建模为具有指定均值（$\\mu$）和标准差（$\\sigma$）的独立高斯随机变量来引入工艺变化。一个关键细节是强制执行物理约束：任何采样得到的电阻值都必须严格为正。这是通过对随机变量进行重采样直到获得正值来实现的。随机数生成器使用固定的种子值 $12345$ 以确保结果的可复现性。\n\n模拟算法通过对五个指定情况中的每一种进行大量试验（$N$ 次）来推进。在每次试验中，我们执行以下步骤：\n$1$. 从各自的分布中为变化的器件参数（$V_{tn0}$、$R_{on,n}$、$R_{on,p}$）采样随机值。\n$2$. 根据具体的电路配置计算稳态输出电压 $V_{out}$。\n\n对于传输高逻辑电平的单个NMOS（情况1和5），计算 $V_{out}$ 的两个潜在限制。第一个是电阻分压电压 $V_{out,div}$，由负载电阻 $R_L$ 与总串联电阻的比率确定：\n$$V_{out,div} = V_{DD} \\cdot \\frac{R_L}{R_{on,n} + R_L}$$\n第二个是体效应限制电压 $V_{out,BE}$，它是超越方程 $V_{out} = V_{DD} - V_{tn}(V_{out})$ 的解。该方程没有封闭形式的解，必须进行数值求解。我们定义一个函数 $f(V_{out}) = V_{out} - V_{DD} + V_{tn}(V_{out})$，并在物理上有意义的区间 $[0, V_{DD}]$ 内找到它的根。为此，采用了像 Brent-Dekker 方法这样的稳健数值方法。最终的输出电压 $V_{out}$ 是这两个限制中更严格的一个：\n$$V_{out} = \\min(V_{out,BE}, V_{out,div})$$\n\n对于传输低逻辑电平的单个NMOS（情况3），不存在阈值压降。电路是一个由上拉电阻 $R_U$ 和NMOS导通电阻 $R_{on,n}$ 构成的简单分压器：\n$$V_{out} = V_{DD} \\cdot \\frac{R_{on,n}}{R_{on,n} + R_U}$$\n\n对于传输门（情况2和4），计算也是一个直接的电阻分压，使用有效电阻 $R_{eff}$。对于传输高逻辑电平并带有下拉负载 $R_L$ 的情况：\n$$V_{out} = V_{DD} \\cdot \\frac{R_L}{R_{eff} + R_L}$$\n对于传输低逻辑电平并带有上拉负载 $R_U$ 的情况：\n$$V_{out} = V_{DD} \\cdot \\frac{R_{eff}}{R_{eff} + R_U}$$\n\n$3$. 在每次试验中，将计算出的 $V_{out}$ 与指定的逻辑电平要求（$V_{IH,min}$ 或 $V_{IL,max}$）进行比较。如果满足条件，则成功试验的计数器加一。\n$4$. 在所有 $N$ 次试验完成后，该情况的良率计算为成功试验的总数除以 $N$。\n\n对所有五个测试用例重复此过程，并收集所得的良率。该实现利用 `numpy` 库进行高效的向量化计算和统计采样，并使用 `scipy.optimize.brentq` 函数进行所需的数值求根。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Performs a Monte Carlo simulation to estimate the yield of pass-transistor\n    and transmission-gate logic circuits under process variation.\n    \"\"\"\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    def sample_truncated_normal(mu, sigma, num_samples, rng_instance):\n        \"\"\"\n        Samples from a normal distribution, resampling any non-positive values.\n        This function is vectorized for efficiency.\n        \"\"\"\n        samples = rng_instance.normal(mu, sigma, num_samples)\n        if num_samples == 1:\n            while samples = 0:\n                samples = rng_instance.normal(mu, sigma, 1)\n            return samples\n\n        while np.any(samples = 0):\n            mask = samples = 0\n            num_to_resample = np.sum(mask)\n            samples[mask] = rng_instance.normal(mu, sigma, num_to_resample)\n        return samples\n\n    def solve_vout_body_effect(V_dd, V_tn0, gamma, two_phi_F):\n        \"\"\"\n        Solves for the body-effect-limited output voltage for an NMOS pass transistor.\n        V_out = V_dd - V_tn(V_out)\n        \"\"\"\n        # If the gate-source voltage at V_out=0 is less than threshold, transistor\n        # is off, and output is pulled to 0 by the load resistor.\n        if V_dd = V_tn0:\n            return 0.0\n\n        def f(v_out, v_tn0_sample):\n            # We must ensure the argument to sqrt is non-negative.\n            # Since v_out is bracketed in [0, V_dd], this is guaranteed.\n            v_sb = v_out\n            v_tn_with_body_effect = v_tn0_sample + gamma * (np.sqrt(two_phi_F + v_sb) - np.sqrt(two_phi_F))\n            return v_out - (V_dd - v_tn_with_body_effect)\n\n        try:\n            # f(0) = -(V_dd - V_tn0)  0\n            # f(V_dd) = V_dd - (V_dd - Vtn(Vdd)) = Vtn(Vdd) > 0\n            # A root is guaranteed in [0, V_dd] if V_dd > V_tn0.\n            root = brentq(f, 0, V_dd, args=(V_tn0,))\n            return root\n        except ValueError:\n            # This can happen if f(0) and f(V_dd) have the same sign, which\n            # occurs if V_dd = V_tn0. Handled by the initial check.\n            return 0.0\n\n    def run_case_1(params, rng_instance):\n        V_dd, V_ih_min, V_tn0_mu, V_tn0_sigma, gamma, two_phi_F, R_onn_mu, R_onn_sigma, R_l, N = params\n        \n        V_tn0_samples = rng_instance.normal(V_tn0_mu, V_tn0_sigma, N)\n        R_onn_samples = sample_truncated_normal(R_onn_mu, R_onn_sigma, N, rng_instance)\n\n        v_out_be_limited = np.array([solve_vout_body_effect(V_dd, v_tn0, gamma, two_phi_F) for v_tn0 in V_tn0_samples])\n        v_out_div = V_dd * R_l / (R_onn_samples + R_l)\n        v_out_final = np.minimum(v_out_be_limited, v_out_div)\n        \n        success_count = np.sum(v_out_final >= V_ih_min)\n        return success_count / N\n\n    def run_case_2(params, rng_instance):\n        V_dd, V_ih_min, R_onn_mu, R_onn_sigma, R_onp_mu, R_onp_sigma, R_l, N = params\n        \n        R_onn_samples = sample_truncated_normal(R_onn_mu, R_onn_sigma, N, rng_instance)\n        R_onp_samples = sample_truncated_normal(R_onp_mu, R_onp_sigma, N, rng_instance)\n        \n        R_eff = 1.0 / (1.0 / R_onn_samples + 1.0 / R_onp_samples)\n        v_out = V_dd * R_l / (R_eff + R_l)\n        \n        success_count = np.sum(v_out >= V_ih_min)\n        return success_count / N\n\n    def run_case_3(params, rng_instance):\n        V_dd, V_il_max, R_onn_mu, R_onn_sigma, R_u, N = params\n        \n        R_onn_samples = sample_truncated_normal(R_onn_mu, R_onn_sigma, N, rng_instance)\n        v_out = V_dd * R_onn_samples / (R_onn_samples + R_u)\n        \n        success_count = np.sum(v_out = V_il_max)\n        return success_count / N\n\n    def run_case_4(params, rng_instance):\n        V_dd, V_il_max, R_onn_mu, R_onn_sigma, R_onp_mu, R_onp_sigma, R_u, N = params\n        \n        R_onn_samples = sample_truncated_normal(R_onn_mu, R_onn_sigma, N, rng_instance)\n        R_onp_samples = sample_truncated_normal(R_onp_mu, R_onp_sigma, N, rng_instance)\n        \n        R_eff = 1.0 / (1.0 / R_onn_samples + 1.0 / R_onp_samples)\n        v_out = V_dd * R_eff / (R_eff + R_u)\n        \n        success_count = np.sum(v_out = V_il_max)\n        return success_count / N\n\n    test_cases = [\n        # Case 1: single NMOS, pass-high, moderate load\n        {\"func\": run_case_1, \"params\": (1.0, 0.5, 0.35, 0.03, 0.45, 0.6, 4.0e3, 0.6e3, 2.0e4, 100000)},\n        # Case 2: transmission gate, pass-high, moderate load\n        {\"func\": run_case_2, \"params\": (1.0, 0.7, 4.0e3, 0.6e3, 6.0e3, 0.9e3, 2.0e4, 50000)},\n        # Case 3: single NMOS, pass-low, pull-up load\n        {\"func\": run_case_3, \"params\": (1.0, 0.2, 4.0e3, 0.6e3, 2.0e4, 50000)},\n        # Case 4: transmission gate, pass-low, pull-up load\n        {\"func\": run_case_4, \"params\": (1.0, 0.2, 4.0e3, 0.6e3, 6.0e3, 0.9e3, 2.0e4, 50000)},\n        # Case 5: single NMOS, pass-high, near-threshold boundary, very light load\n        {\"func\": run_case_1, \"params\": (1.0, 0.525, 0.35, 0.03, 0.45, 0.6, 4.0e3, 0.6e3, 1.0e9, 20000)}\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = case[\"func\"](case[\"params\"], rng)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}