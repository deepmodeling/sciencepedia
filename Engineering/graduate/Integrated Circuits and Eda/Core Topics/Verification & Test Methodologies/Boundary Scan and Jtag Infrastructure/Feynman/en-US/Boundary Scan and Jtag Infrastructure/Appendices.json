{
    "hands_on_practices": [
        {
            "introduction": "The efficiency of JTAG operations is dictated by the number of Test Clock ($TCK$) cycles required for any given task. Every action, from loading an instruction to shifting data, involves navigating the 16-state Test Access Port (TAP) controller. This exercise provides a foundational drill in JTAG protocol timing, challenging you to calculate the exact number of $TCK$ cycles for a complete instruction-load and data-scan sequence. By doing so, you will develop a quantitative understanding of the protocol's overhead and master the minimal state transitions required, a skill essential for predicting test times and designing efficient debug scripts. ",
            "id": "4258496",
            "problem": "A digital integrated circuit implements the boundary-scan architecture defined by the Institute of Electrical and Electronics Engineers (IEEE) Standard $1149.1$, with a standard Test Access Port (TAP) controller. You are to determine the exact number of Test Clock (TCK) rising edges required to perform the following composite operation under minimal-overhead control of the Test Mode Select (TMS) signal.\n\nAssume the following operational constraints and definitions:\n- The circuit starts in the TAP state Run-Test/Idle and must finish in Run-Test/Idle after the entire composite operation is complete.\n- First, an $m$-bit Instruction Register (IR) load is performed. Then, immediately afterward, a specific $n$-bit Data Register (DR) is shifted out through Test Data Out (TDO).\n- All state transitions follow the IEEE Standard $1149.1$ TAP state machine. The path taken through the states must be minimal and legal, with no pausing and no extra idling beyond what is strictly necessary to enter and exit the required shift operations and to return to Run-Test/Idle upon completion.\n- Each rising edge of the Test Clock (TCK) advances the TAP state machine according to the current TMS value and performs one shift of the currently selected shift register in the Shift-IR or Shift-DR states.\n- During the $m$-bit and $n$-bit shifts, exactly one bit is shifted per rising edge of $TCK$. The final bit of each shift operation is clocked while asserting TMS to exit the corresponding shift state on that same edge.\n- No asynchronous resets are applied. No transitions to Test-Logic-Reset are invoked. No pauses are inserted.\n\nUnder these assumptions, derive a closed-form analytic expression, as a function of $m$ and $n$, for the total number of $TCK$ rising edges required to:\n$1)$ load the $m$-bit IR, and $2)$ shift out the $n$-bit DR, starting in Run-Test/Idle and ending in Run-Test/Idle, using the minimal legal sequence of TAP state transitions. Your final answer must be a single analytic expression in terms of $m$ and $n$ with no units. Do not approximate or round.",
            "solution": "The user wants to find a close-form analytic expression for the total number of TCK rising edges required for a composite JTAG operation.\n\n### Step 1: Extract Givens\n- **Standard**: The operation adheres to the Institute of Electrical and Electronics Engineers (IEEE) Standard $1149.1$.\n- **Controller**: A standard Test Access Port (TAP) controller is used.\n- **Initial State**: The process starts in the `Run-Test/Idle` TAP state.\n- **Final State**: The process must end in the `Run-Test/Idle` TAP state.\n- **Composite Operation**: The sequence of operations is:\n    1. An $m$-bit Instruction Register (IR) load.\n    2. An $n$-bit Data Register (DR) shift-out.\n- **Constraints**:\n    - The path through the TAP state machine must be minimal and legal, with no pausing or extra idling.\n    - Each Test Clock (TCK) rising edge advances the state machine or performs one bit-shift.\n    - The final bit of any shift operation (IR or DR) is clocked on the same TCK rising edge that causes the transition out of the `Shift-IR` or `Shift-DR` state, which is achieved by asserting the Test Mode Select (TMS) signal.\n    - No asynchronous resets are used, and the `Test-Logic-Reset` state is not entered.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based entirely on the IEEE $1149.1$ standard, a fundamental and universally accepted protocol in integrated circuit design and testing. The concepts of the TAP controller, its states, IR, DR, TCK, and TMS are all standard and factually correct.\n- **Well-Posed**: The problem is well-posed. The initial and final states are specified, the sequence of operations is defined, and the \"minimal legal path\" constraint removes any ambiguity in the traversal of the TAP state machine. This ensures that a unique, stable, and meaningful solution exists.\n- **Objective**: The problem is stated in precise, objective, and standard technical language, free from any subjective or ambiguous terminology.\n- **Other Flaws**: The problem is self-contained, consistent, and scientifically sound. It does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A detailed solution will be provided by tracing the state transitions of the TAP controller and counting the required TCK cycles.\n\n### Solution Derivation\n\nThe total number of TCK cycles is determined by summing the cycles required for each phase of the composite operation. The analysis involves tracing the minimal path through the $16$-state TAP state machine. The path is broken down into four distinct segments: the IR load operation, the transition from the IR scan path to the DR scan path, the DR shift operation, and the final return to the idle state.\n\n**1. IR Load Operation**\n\nThis phase consists of navigating from `Run-Test/Idle` to `Shift-IR` and then performing the $m$-bit shift.\n\n- **Path to `Shift-IR`**: The minimal path from the `Run-Test/Idle` state to the `Shift-IR` state requires traversing four intermediate states.\n    1.  `Run-Test/Idle` $\\xrightarrow{\\text{TMS=1}}$ `Select-DR-Scan` ($1$ TCK)\n    2.  `Select-DR-Scan` $\\xrightarrow{\\text{TMS=1}}$ `Select-IR-Scan` ($1$ TCK)\n    3.  `Select-IR-Scan` $\\xrightarrow{\\text{TMS=0}}$ `Capture-IR` ($1$ TCK)\n    4.  `Capture-IR` $\\xrightarrow{\\text{TMS=0}}$ `Shift-IR` ($1$ TCK)\n    The total TCK cycles to enter the `Shift-IR` state is $4$.\n\n- **IR Shift**: Shifting an $m$-bit instruction into the IR.\n    - The first $m-1$ bits are shifted while TMS is held at $0$, keeping the TAP controller in the `Shift-IR` state. This takes $m-1$ TCK cycles.\n    - The final, $m$-th bit is shifted while TMS is set to $1$. This single TCK cycle both shifts the last bit and transitions the state from `Shift-IR` to `Exit1-IR`.\n    - The total time for the shift operation is $(m-1) + 1 = m$ TCK cycles.\n\n**2. Transition from IR Scan to DR Scan**\n\nAfter the IR shift is complete, the controller is in the `Exit1-IR` state. To perform the DR operation immediately, it must navigate to the `Shift-DR` state via a minimal path.\n\n1.  `Exit1-IR` $\\xrightarrow{\\text{TMS=1}}$ `Update-IR` ($1$ TCK). The loaded instruction becomes the current instruction on the falling edge of this TCK.\n2.  `Update-IR` $\\xrightarrow{\\text{TMS=1}}$ `Select-DR-Scan` ($1$ TCK). This is the required first step to enter the DR scan branch of the state machine.\n3.  `Select-DR-Scan` $\\xrightarrow{\\text{TMS=0}}$ `Capture-DR` ($1$ TCK).\n4.  `Capture-DR` $\\xrightarrow{\\text{TMS=0}}$ `Shift-DR` ($1$ TCK).\nThe total TCK cycles for this transition phase is $4$.\n\n**3. DR Shift-Out Operation**\n\nThis phase consists of shifting out the $n$-bit content of the selected DR.\n\n- **DR Shift**: Shifting an $n$-bit data word out of the DR.\n    - The first $n-1$ bits are shifted while TMS is held at $0$, keeping the TAP controller in the `Shift-DR` state. This takes $n-1$ TCK cycles.\n    - The final, $n$-th bit is shifted while TMS is set to $1$. This TCK cycle both shifts the last bit and transitions the state from `Shift-DR` to `Exit1-DR`.\n    - The total time for the shift operation is $(n-1) + 1 = n$ TCK cycles.\n\n**4. Return to `Run-Test/Idle` State**\n\nAfter the DR shift, the controller is in the `Exit1-DR` state and must return to the `Run-Test/Idle` state.\n\n1.  `Exit1-DR` $\\xrightarrow{\\text{TMS=1}}$ `Update-DR` ($1$ TCK).\n2.  `Update-DR` $\\xrightarrow{\\text{TMS=0}}$ `Run-Test/Idle` ($1$ TCK).\nThe total TCK cycles to return to the idle state is $2$.\n\n**5. Total TCK Cycle Count**\n\nThe total number of TCK rising edges, $N_{TCK}$, is the sum of the cycles from each of the four segments.\n$$N_{TCK} = (\\text{Path to Shift-IR}) + (\\text{IR Shift}) + (\\text{Transition to Shift-DR}) + (\\text{DR Shift}) + (\\text{Return to Idle})$$\nSubstituting the values derived in the previous sections:\n$$N_{TCK} = 4 + m + 4 + n + 2$$\n$$N_{TCK} = m + n + 10$$\nTherefore, the total number of TCK rising edges required for the composite operation is $m + n + 10$.",
            "answer": "$$\n\\boxed{m+n+10}\n$$"
        },
        {
            "introduction": "Beyond the dynamic behavior of the TAP controller, the JTAG infrastructure is defined by its static hardware structure, primarily the Boundary Scan Register (BSR). The Boundary Scan Description Language (BSDL) is the standard format for describing this structure, linking the logical scan chain to the physical pins of an integrated circuit. This practice shifts the focus from protocol timing to this hardware architecture, requiring you to translate a device's physical pinout into its corresponding BSR structure. This exercise mimics the fundamental process of creating a BSDL file, a critical step for enabling JTAG-based testing and programming tools. ",
            "id": "4258524",
            "problem": "You are given the task of constructing a Boundary-Scan Description Language (BSDL) fragment for a device that conforms to Institute of Electrical and Electronics Engineers (IEEE) Standard Test Access Port and Boundary-Scan Architecture (IEEE 1149.1), commonly known as Joint Test Action Group (JTAG). The device has $4$ pins comprising two inputs, one output, and one bidirectional pin. The fragment must declare boundary-scan register (BSR) cell types and the instruction register (IR) with the BYPASS and EXTEST instructions. The construction must follow from fundamental definitions of boundary scan and be algorithmically derived. Your program must internally generate this BSDL fragment but the final output must be a purely numeric aggregate that can be used to validate conformance.\n\nUse the following fundamental base and definitions:\n- The Boundary-Scan Register (BSR) is defined by IEEE 1149.1 as a shift register composed of boundary cells associated with device pins. Each boundary-scan cell is capable of capturing data from a pin or driving data to a pin under test mode. A device pin may require multiple boundary-scan cells depending on its function (for example, bidirectional pins require both input capture and output drive, along with output enable control).\n- The Instruction Register (IR) is a shift register that selects the current JTAG instruction. The BYPASS instruction is mandated to have an opcode composed of all ones of length equal to the IR length, and the EXTEST instruction uses the BSR to drive and capture external signals. In this problem, model the EXTEST opcode as all zeros of length equal to the IR length (a common and scientifically sound assignment).\n- For purposes of this problem, model tri-state outputs and bidirectional pins as requiring explicit control of output enable. Use the following boundary cell model per pin type:\n  1. Input pin: one input capture boundary cell.\n  2. Output pin (tri-state): one output drive boundary cell and one output-enable control boundary cell.\n  3. Bidirectional pin (tri-state): one input capture boundary cell, one output drive boundary cell, and one output-enable control boundary cell.\n- The BSR cell ordering for each pin shall follow a consistent sequence from a logical per-pin grouping: for an input pin use input capture; for an output pin use output drive followed by control; for a bidirectional pin use input capture, then output drive, then control. Across pins, enumerate in ascending pin index order.\n\nGiven this model and definitions, you must:\n1. Derive the total BSR length $L_{BSR}$ as a function of the number of pins of each type.\n2. Derive IR length $L_{IR}$ as specified per test case.\n3. Derive the decimal value of the BYPASS opcode as $2^{L_{IR}} - 1$, and the decimal value of EXTEST opcode as $0$.\n4. Internally construct a valid BSDL fragment string representing:\n   - The entity name (can be arbitrary but consistent within your program).\n   - The boundary register section enumerating the boundary cells with types per pin type grouping as above (for example, use placeholders such as BC_1 for input capture, BC_2 for output drive, and BC_2 for control to reflect that control is a boundary cell affecting output enable). The exact BSDL grammar is not required to be exhaustively validated but must be logically consistent and self-contained.\n   - The instruction register length and the BYPASS and EXTEST opcodes consistent with the above derivations.\nHowever, your program must not print this fragment; instead, it must compute and print numeric conformance metrics only.\n\nYour program must process the following test suite of parameter sets. Each test case is a tuple specifying the ordered pin types and the IR length:\n- Test case $1$: pins $[\\text{IN}, \\text{IN}, \\text{OUT}, \\text{BIDIR}]$, $L_{IR} = 4$.\n- Test case $2$: pins $[\\text{IN}, \\text{IN}, \\text{IN}, \\text{IN}]$, $L_{IR} = 2$.\n- Test case $3$: pins $[\\text{BIDIR}, \\text{BIDIR}, \\text{BIDIR}, \\text{BIDIR}]$, $L_{IR} = 5$.\n- Test case $4$: pins $[\\text{OUT}, \\text{OUT}, \\text{OUT}, \\text{OUT}]$, $L_{IR} = 3$.\n\nFor each test case, compute and output a list of four values $[L_{BSR}, L_{IR}, \\text{BYPASS}_{\\text{dec}}, \\text{EXTEST}_{\\text{dec}}]$ where:\n- $L_{BSR}$ is the total boundary-scan register length based on the per-pin composition rules above.\n- $L_{IR}$ is the instruction register length.\n- $\\text{BYPASS}_{\\text{dec}}$ is the decimal value of the BYPASS opcode, which equals $2^{L_{IR}} - 1$.\n- $\\text{EXTEST}_{\\text{dec}}$ is the decimal value of the EXTEST opcode, which equals $0$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list of lists enclosed in square brackets. For example, produce an output of the form $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$ where each $a_i$, $b_i$, $c_i$, and $d_i$ are integers as defined above. No other text must be printed.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the IEEE 1149.1 standard, well-posed with a clear and complete set of definitions, and objective in its formulation. The task is to algorithmically derive a set of numeric conformance metrics for specified hardware configurations based on the fundamental principles of the JTAG boundary-scan architecture.\n\nThe derivation proceeds by applying the definitions provided for the Boundary-Scan Register (BSR) and the Instruction Register (IR).\n\n**1. Derivation of Boundary-Scan Register (BSR) Length ($L_{BSR}$)**\n\nThe BSR is a serial shift register formed by linking boundary-scan cells associated with each device pin. The total length of the BSR, denoted as $L_{BSR}$, is the sum of the number of cells contributed by each pin. The problem specifies a model where the number of cells per pin depends on the pin's type:\n\n-   An input pin ($\\text{IN}$) is modeled with $1$ boundary-scan cell for data capture. Let this count be $C_{\\text{IN}} = 1$.\n-   A tri-state output pin ($\\text{OUT}$) is modeled with $2$ cells: $1$ for driving data and $1$ for controlling the output enable. Let this count be $C_{\\text{OUT}} = 2$.\n-   A tri-state bidirectional pin ($\\text{BIDIR}$) requires capabilities for input capture, output drive, and output enable control. It is modeled with $3$ cells. Let this count be $C_{\\text{BIDIR}} = 3$.\n\nGiven a device with a set of pins $P$, the total BSR length is the summation of the cell counts for each pin in the set:\n$$L_{BSR} = \\sum_{p \\in P} C_p$$\nwhere $C_p$ is the cell count corresponding to the type of pin $p$.\n\n**2. Derivation of Instruction Register (IR) Properties**\n\nThe IR is a register that holds the currently selected JTAG instruction. Its length, $L_{IR}$, is a device-specific design choice and is provided for each test case. The problem defines two standard instructions:\n\n-   **BYPASS**: This instruction provides a minimal path through the device, consisting of a single-bit register. The IEEE 1149.1 standard mandates that the opcode for the BYPASS instruction must be a binary vector of all ones. For an IR of length $L_{IR}$, the opcode is a sequence of $L_{IR}$ ones. The decimal equivalent, $\\text{BYPASS}_{\\text{dec}}$, is calculated as:\n    $$\\text{BYPASS}_{\\text{dec}} = \\sum_{i=0}^{L_{IR}-1} 1 \\cdot 2^i = 2^{L_{IR}} - 1$$\n-   **EXTEST**: This instruction connects the BSR to the device pins to allow for testing of external circuitry. The problem specifies that the opcode for EXTEST is to be modeled as a binary vector of all zeros. For an IR of length $L_{IR}$, this corresponds to a sequence of $L_{IR}$ zeros. The decimal equivalent, $\\text{EXTEST}_{\\text{dec}}$, is therefore:\n    $$\\text{EXTEST}_{\\text{dec}} = 0$$\n\n**3. Calculation for Test Cases**\n\nThe required conformance metrics $[L_{BSR}, L_{IR}, \\text{BYPASS}_{\\text{dec}}, \\text{EXTEST}_{\\text{dec}}]$ are computed for each test case by applying these principles.\n\n**Test Case 1:**\n-   Pins: $[\\text{IN}, \\text{IN}, \\text{OUT}, \\text{BIDIR}]$\n-   $L_{IR} = 4$\n-   Calculation of $L_{BSR}$:\n    $L_{BSR} = C_{\\text{IN}} + C_{\\text{IN}} + C_{\\text{OUT}} + C_{\\text{BIDIR}} = 1 + 1 + 2 + 3 = 7$\n-   Calculation of opcodes:\n    $\\text{BYPASS}_{\\text{dec}} = 2^{4} - 1 = 16 - 1 = 15$\n    $\\text{EXTEST}_{\\text{dec}} = 0$\n-   Result: $[7, 4, 15, 0]$\n\n**Test Case 2:**\n-   Pins: $[\\text{IN}, \\text{IN}, \\text{IN}, \\text{IN}]$\n-   $L_{IR} = 2$\n-   Calculation of $L_{BSR}$:\n    $L_{BSR} = 4 \\times C_{\\text{IN}} = 4 \\times 1 = 4$\n-   Calculation of opcodes:\n    $\\text{BYPASS}_{\\text{dec}} = 2^{2} - 1 = 4 - 1 = 3$\n    $\\text{EXTEST}_{\\text{dec}} = 0$\n-   Result: $[4, 2, 3, 0]$\n\n**Test Case 3:**\n-   Pins: $[\\text{BIDIR}, \\text{BIDIR}, \\text{BIDIR}, \\text{BIDIR}]$\n-   $L_{IR} = 5$\n-   Calculation of $L_{BSR}$:\n    $L_{BSR} = 4 \\times C_{\\text{BIDIR}} = 4 \\times 3 = 12$\n-   Calculation of opcodes:\n    $\\text{BYPASS}_{\\text{dec}} = 2^{5} - 1 = 32 - 1 = 31$\n    $\\text{EXTEST}_{\\text{dec}} = 0$\n-   Result: $[12, 5, 31, 0]$\n\n**Test Case 4:**\n-   Pins: $[\\text{OUT}, \\text{OUT}, \\text{OUT}, \\text{OUT}]$\n-   $L_{IR} = 3$\n-   Calculation of $L_{BSR}$:\n    $L_{BSR} = 4 \\times C_{\\text{OUT}} = 4 \\times 2 = 8$\n-   Calculation of opcodes:\n    $\\text{BYPASS}_{\\text{dec}} = 2^{3} - 1 = 8 - 1 = 7$\n    $\\text{EXTEST}_{\\text{dec}} = 0$\n-   Result: $[8, 3, 7, 0]$\n\nThe program will implement this logic to compute the results for all test cases and format them as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes JTAG/BSDL numeric conformance metrics for a suite of test cases.\n    \"\"\"\n\n    # Define the fundamental model for boundary-scan cell counts per pin type.\n    # IN: 1 cell (input capture)\n    # OUT: 2 cells (output drive, output enable)\n    # BIDIR: 3 cells (input capture, output drive, output enable)\n    cell_counts = {\n        'IN': 1,\n        'OUT': 2,\n        'BIDIR': 3\n    }\n\n    # Define the test suite of parameter sets as specified in the problem.\n    # Each test case is a tuple: (list of pin types, instruction register length).\n    test_cases = [\n        (['IN', 'IN', 'OUT', 'BIDIR'], 4),\n        (['IN', 'IN', 'IN', 'IN'], 2),\n        (['BIDIR', 'BIDIR', 'BIDIR', 'BIDIR'], 5),\n        (['OUT', 'OUT', 'OUT', 'OUT'], 3),\n    ]\n\n    results = []\n    for pins, L_IR in test_cases:\n        # 1. Derive the total BSR length (L_BSR)\n        # L_BSR is the sum of cells for all pins in the configuration.\n        L_BSR = sum(cell_counts[pin_type] for pin_type in pins)\n\n        # 2. Get the given IR length (L_IR)\n        # This is directly provided in the test case.\n\n        # 3. Derive the decimal value of the BYPASS opcode.\n        # The BYPASS opcode is defined as all ones, so its decimal value is 2^L_IR - 1.\n        bypass_dec = (1  L_IR) - 1 # Using bit-shift for 2^L_IR is efficient.\n\n        # 4. Derive the decimal value of the EXTEST opcode.\n        # The EXTEST opcode is modeled as all zeros, so its decimal value is 0.\n        extest_dec = 0\n\n        # Store the computed metrics for the current test case.\n        case_result = [L_BSR, L_IR, bypass_dec, extest_dec]\n        results.append(case_result)\n\n    # Format the final output as a single-line string representation of a list of lists.\n    # The map(str, ...) inside the list comprehension converts each integer to a string.\n    # Then '[' + ','.join(...) + ']' creates the inner list string, e.g., \"[7,4,15,0]\".\n    # The outer join and brackets assemble the final string.\n    final_output_str = '[' + ','.join(['[' + ','.join(map(str, res)) + ']' for res in results]) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Applying JTAG in a system context demands an awareness of system-level electrical hazards, the most significant of which is bus contention. This dangerous condition can occur if a test mode is activated improperly on a live board where multiple devices share a bus. This final practice addresses this critical real-world application, asking you to analyze the distinct roles of key JTAG instructions like `SAMPLE/PRELOAD`, `EXTEST`, and `INTEST`. By devising a sequence that safely tri-states a device's outputs before entering an internal test mode, you will learn a procedure crucial for preventing hardware damage and ensuring reliable in-system testing. ",
            "id": "4258533",
            "problem": "A system-on-chip integrates multiple bus masters and shared peripheral interfaces. During normal operation, on-chip pads may drive a shared bus. You are asked to enter the Joint Test Action Group (JTAG) Internal Test (`INTEST`) mode to perform core-isolated testing without causing bus contention on off-chip nets. Consider an Institute of Electrical and Electronics Engineers (IEEE) 1149.1 compliant boundary-scan architecture with a Boundary Scan Register (BSR) composed of output data cells and output control cells that drive the Output Enable (OE) of pad drivers. Assume the following foundational facts:\n\n- In 1149.1, the BSR consists of shift, capture, and update elements, where Update-DR latches drive values to their effect points only when the BSR is selected by the current instruction.\n- The Joint Test Action Group (JTAG) Test Access Port (TAP) state machine only modifies the contents of the shift path on entering Capture-DR; latching into effect points occurs at Update-DR.\n- The `SAMPLE/PRELOAD` instruction selects the BSR for shifting and capture but does not drive pins; the system logic continues to control pad drivers.\n- The `EXTEST` instruction selects the BSR to drive pins; output control cells set pad driver OE, and output data cells set pad driver data; tri-stating requires $OE=0$ in the corresponding control cells.\n- The `INTEST` instruction selects the BSR to drive core inputs and capture core outputs; safe entry requires pad drivers to be disabled to avoid contention with external drivers.\n- The `HIGHZ` instruction, if implemented, forces outputs to a high-impedance state but typically selects the BYPASS register and does not allow BSR access for readback.\n- The `CLAMP` instruction, if implemented, applies the preloaded BSR update values to pads while selecting the BYPASS register; it maintains pad states without permitting BSR scanning.\n\nYour goal is to construct an instruction-and-state sequence that guarantees the following before selecting INTEST: pad drivers are disabled by forcing all relevant output control cells to $OE=0$, and the disabled OE states are confirmed via BSR readback. The sequence must be free of transient contention hazards introduced by instruction changes or TAP transitions and must use only the semantics above. Choose the option that most rigorously satisfies these constraints when starting in Run-Test/Idle (RTI) under normal operation.\n\nWhich sequence is correct?\n\nA. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$, Update-DR; load `EXTEST` via Shift-IR and Update-IR so the BSR controls pad OE; perform Capture-DR and Shift-DR to read back control cell states and verify $OE=0$; then load `INTEST` via Shift-IR and Update-IR to enter core-isolated test with pads remaining disabled.\n\nB. From RTI, load `INTEST` via Shift-IR and Update-IR immediately; then Shift-DR to preload output control bits to $OE=0$; finally Update-DR to apply the tri-state while already in `INTEST`.\n\nC. From RTI, load `HIGHZ` via Shift-IR and Update-IR to force all outputs high-impedance; then load `INTEST` via Shift-IR and Update-IR; assume pads stay disabled during `INTEST` without any BSR readback.\n\nD. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$; perform Capture-DR and Shift-DR to read back the BSR and verify $OE=0$; then Update-DR; finally load `INTEST` via Shift-IR and Update-IR.\n\nE. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload $OE=0$ and Update-DR; load `CLAMP` via Shift-IR and Update-IR to apply the preloaded tri-state; then attempt to confirm $OE=0$ by performing Capture-DR and Shift-DR while remaining in `CLAMP`; finally load `INTEST` via Shift-IR and Update-IR.",
            "solution": "### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem statement provides the following definitions, constraints, and objectives:\n- **System**: A system-on-chip with multiple bus masters and shared peripheral interfaces.\n- **Goal**: Enter the Joint Test Action Group (JTAG) Internal Test (`INTEST`) mode for core-isolated testing.\n- **Primary Constraint**: Avoid bus contention on off-chip nets.\n- **Architecture**: Conforms to IEEE 1149.1 standard for boundary-scan.\n- **Boundary Scan Register ($BSR$)**: Composed of output data cells and output control cells that drive the Output Enable ($OE$) of pad drivers.\n- **Fact 1**: The $BSR$ has shift, capture, and update elements. Update-DR latches drive values only when the $BSR$ is selected by the current instruction.\n- **Fact 2**: The Test Access Port ($TAP$) state machine modifies the shift path on entering Capture-DR; latching into effect points occurs at Update-DR.\n- **Fact 3 (`SAMPLE/PRELOAD` instruction)**: Selects the $BSR$ for shifting and capture but does not drive pins. System logic continues to control pad drivers.\n- **Fact 4 (`EXTEST` instruction)**: Selects the $BSR$ to drive pins. Control cells set pad driver $OE$; data cells set pad driver data. Tri-stating requires $OE=0$ in the control cells.\n- **Fact 5 (`INTEST` instruction)**: Selects the $BSR$ to drive core inputs and capture core outputs. Safe entry requires pad drivers to be disabled.\n- **Fact 6 (`HIGHZ` instruction)**: If implemented, forces outputs to a high-impedance state, but typically selects the $BYPASS$ register and disallows $BSR$ access for readback.\n- **Fact 7 (`CLAMP` instruction)**: If implemented, applies preloaded $BSR$ update values to pads while selecting the $BYPASS$ register; it disallows $BSR$ scanning.\n- **Required Sequence Properties**:\n    1.  Guarantees pad drivers are disabled by forcing all relevant output control cells to $OE=0$.\n    2.  Confirms the disabled $OE$ states via $BSR$ readback.\n    3.  This must be achieved *before* selecting the `INTEST` instruction.\n    4.  The sequence must be free of transient contention hazards.\n    5.  The starting state is Run-Test/Idle ($RTI$).\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is based entirely on the IEEE 1149.1 standard, which governs JTAG boundary-scan architecture and operation. The described behaviors of instructions (`SAMPLE/PRELOAD`, `EXTEST`, `INTEST`, etc.) and $TAP$ controller states are consistent with this well-established engineering standard. The issue of preventing bus contention during test mode entry is a fundamental and practical concern in digital circuit design and test.\n- **Well-Posed**: The problem is clearly defined. It specifies a starting state ($RTI$), a goal (safely enter `INTEST`), a set of allowed operations (the described JTAG instructions), and a set of explicit constraints (no contention, must verify pad state via readback). This structure allows for the deduction of a unique, correct sequence of operations.\n- **Objective**: The problem is stated in precise, technical language. The descriptions of the instructions are provided as \"foundational facts,\" removing ambiguity and subjectivity.\n\nThe problem does not exhibit any invalidating flaws. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, or ill-posed. It is a substantive question requiring logical deduction from a given set of formal rules.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. Proceeding to the solution.\n\n### Derivation from First Principles\n\nThe objective is to devise a sequence of IEEE 1149.1 operations to transition from normal operation (represented by the $TAP$ state Run-Test/Idle, or $RTI$) into the `INTEST` mode, while guaranteeing that I/O-pad-related bus contention is avoided. This guarantee requires two key actions: first, forcing the pad output drivers into a high-impedance (tri-state) condition, and second, verifying that this state has been successfully established before entering `INTEST`. The tri-state condition is achieved by setting the value of the output enable control bit for each relevant pin to $0$ (i.e., $OE=0$).\n\nLet us construct the required sequence step-by-step based on the provided instruction semantics.\n\n1.  **Isolate the BSR for Safe Preloading**: We start in $RTI$ where the system logic controls the pads. To load a new state into the $BSR$ without simultaneously causing it to drive the pads, we must use an instruction that decouples the $BSR$ update latches from the pad drivers. The given Fact 3 for the `SAMPLE/PRELOAD` instruction states it \"selects the $BSR$ for shifting and capture but does not drive pins.\" This is the correct tool for this step. Therefore, the first action is to load the `SAMPLE/PRELOAD` instruction into the instruction register ($IR$).\n\n2.  **Load the Safe State**: With `SAMPLE/PRELOAD` active, we can now safely manipulate the contents of the $BSR$. The goal is to program all output enable control cells to their disable value ($OE=0$). This is done by traversing the $TAP$ state machine to the Shift-DR state and shifting the desired bit pattern into the $BSR$. After the pattern is shifted in, we must transition to the Update-DR state. This action latches the contents of the $BSR$ shift path into the $BSR$'s update latches. Critically, because `SAMPLE/PRELOAD` is active, these newly updated values are *not* driven to the pads. The pads remain under the control of the system logic. We have successfully preloaded a \"safe\" pattern.\n\n3.  **Apply the Safe State and Enable Verification**: The preloaded safe state must now be applied to the pads. This requires an instruction that connects the $BSR$ update latches to the pad drivers. Fact 4 states that the `EXTEST` instruction \"selects the $BSR$ to drive pins.\" By loading the `EXTEST` instruction, the preloaded $OE=0$ values will be applied to the output enable logic of the pads, forcing them into a high-impedance state. This transition is safe because the state of the update latches is determinate and set to a safe value *before* the instruction that applies them becomes active. Once `EXTEST` is the active instruction, the $BSR$ is the selected data register, and it is in control of the pads.\n\n4.  **Confirm the Safe State**: The problem explicitly requires confirmation of the $OE=0$ state via $BSR$ readback. Now that `EXTEST` is active, the $BSR$ is the current data register. We can perform a capture-and-shift operation. By transitioning through Capture-DR, the current state of the boundary scan cells is loaded into their shift-register elements. For an output control cell, a compliant and logical implementation will capture the value of its own update latch, which is currently driving the pad's $OE$ logic. Subsequently, transitioning to Shift-DR allows this captured value to be shifted out for external verification. If the shifted-out bits corresponding to the control cells are all $0$, we have positively confirmed that the $BSR$ is commanding all outputs to a high-impedance state.\n\n5.  **Enter the Final Test Mode**: Having confirmed that the pads are safely disabled, we can now transition to the target mode, `INTEST`. This is done by loading the `INTEST` instruction. According to the IEEE 1149.1 standard, the behavior of the output pins during `INTEST` is specified to be the same as their behavior during `EXTEST`. Since the content of the $BSR$ update latches is not altered by an instruction change alone, the pads will remain in the safe, high-impedance state that was established and verified in the previous steps.\n\nThis sequence—preload with `SAMPLE/PRELOAD`, apply and verify with `EXTEST`, then switch to `INTEST`—is a standard, robust, and logically sound procedure that satisfies all the problem's requirements.\n\n### Option-by-Option Analysis\n\n**A. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$, Update-DR; load `EXTEST` via Shift-IR and Update-IR so the BSR controls pad OE; perform Capture-DR and Shift-DR to read back control cell states and verify $OE=0$; then load `INTEST` via Shift-IR and Update-IR to enter core-isolated test with pads remaining disabled.**\n\nThis option perfectly matches the sequence derived from first principles.\n1.  It correctly uses `SAMPLE/PRELOAD` and an Update-DR to safely preload the $OE=0$ state into the BSR update latches.\n2.  It correctly uses `EXTEST` to apply this preloaded safe state to the pads, preventing contention.\n3.  It correctly identifies that while in `EXTEST`, a Capture-DR/Shift-DR sequence can be used to read back the state of the control cells for verification.\n4.  It correctly transitions to `INTEST` only after the safe pad state has been established and verified.\nThe sequence is free of hazards and meets all specified constraints.\n\n**Verdict: Correct**\n\n**B. From RTI, load `INTEST` via Shift-IR and Update-IR immediately; then Shift-DR to preload output control bits to $OE=0$; finally Update-DR to apply the tri-state while already in `INTEST`.**\n\nThis sequence is hazardous. Loading `INTEST` immediately connects the $BSR$ to the core and pads. However, the initial contents of the $BSR$ update latches are undefined. If these latches contain values that enable the output drivers ($OE=1$), and the system logic is also driving the bus, immediate bus contention will occur at the moment the `INTEST` instruction becomes active in the Update-IR state. Attempting to fix the contention *after* entering `INTEST` is too late; the hazard has already been realized. This violates the core requirement to avoid contention.\n\n**Verdict: Incorrect**\n\n**C. From RTI, load `HIGHZ` via Shift-IR and Update-IR to force all outputs high-impedance; then load `INTEST` via Shift-IR and Update-IR; assume pads stay disabled during `INTEST` without any BSR readback.**\n\nThis option has two critical flaws.\n1.  Fact 6 states that `HIGHZ` \"does not allow $BSR$ access for readback.\" This directly violates the problem requirement to \"confirm via $BSR$ readback.\"\n2.  Fact 6 also states that `HIGHZ` \"typically selects the $BYPASS$ register.\" When the instruction is changed from `HIGHZ` to `INTEST`, the selected data register changes from $BYPASS$ to $BSR$. The global tri-stating effect of `HIGHZ` is removed, and control reverts to the $BSR$ update latches. As in option B, the contents of these latches are unknown, creating a potential for bus contention.\n\n**Verdict: Incorrect**\n\n**D. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$; perform Capture-DR and Shift-DR to read back the BSR and verify $OE=0$; then Update-DR; finally load `INTEST` via Shift-IR and Update-IR.**\n\nThis sequence is logically flawed. After shifting in the $OE=0$ pattern, it attempts to verify it *before* the Update-DR state. A Capture-DR operation overwrites the contents of the shift-register path with newly captured data. With `SAMPLE/PRELOAD` active, the captured data comes from the system-logic-to-pad interfaces. Therefore, the $OE=0$ pattern that was just shifted in is immediately destroyed and replaced by the current state of the system logic. The subsequent Shift-DR would read out the system's state, not the intended state, failing the verification goal. The sequence of operations is incorrect for verifying the preloaded data.\n\n**Verdict: Incorrect**\n\n**E. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload $OE=0$ and Update-DR; load `CLAMP` via Shift-IR and Update-IR to apply the preloaded tri-state; then attempt to confirm $OE=0$ by performing Capture-DR and Shift-DR while remaining in `CLAMP`; finally load `INTEST` via Shift-IR and Update-IR.**\n\nThis sequence fails for a reason similar to option C. While using `CLAMP` to apply the preloaded value is a valid step, the verification step is impossible. Fact 7 states that the `CLAMP` instruction \"selects the $BYPASS$ register\" and does not permit \"$BSR$ scanning\". With the $BYPASS$ register selected, any attempt to perform a Capture-DR/Shift-DR operation will act on the single-bit $BYPASS$ register, not the $BSR$. It is therefore impossible to \"confirm $OE=0$ by performing Capture-DR and Shift-DR\" on the $BSR$ while the `CLAMP` instruction is active. This violates the explicit readback requirement.\n\n**Verdict: Incorrect**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}