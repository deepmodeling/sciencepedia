{
    "hands_on_practices": [
        {
            "introduction": "Understanding the efficiency of a memory test is the first step in designing an effective Built-In Self-Test (BIST) strategy. This exercise provides a hands-on analysis of the widely used March C-minus algorithm, breaking it down into its fundamental read and write operations. By calculating the total test time from first principles , you will gain a quantitative appreciation for the linear relationship between memory size and test cost, a cornerstone of memory BIST design.",
            "id": "4282093",
            "problem": "A synchronous built-in self-test (BIST) is run on a single-port static random-access memory (SRAM) with $n$ word addresses and word width $b$ bits. The BIST employs the classical March C-minus (March C$^{-}$) algorithm. In March testing, each March element performs a fixed sequence of read and write operations to every address in a specified address order. Assume the following definition of March C$^{-}$, where the arrows indicate the address traversal order and each parenthetical list specifies the per-address operation sequence:\n*   $\\uparrow(w0)$: sweep addresses in ascending order and, at each address, write the word value $0$.\n*   $\\uparrow(r0, w1)$: sweep ascending and, at each address, read the word and expect $0$, then write $1$.\n*   $\\uparrow(r1, w0)$: sweep ascending and, at each address, read $1$, then write $0$.\n*   $\\downarrow(r0, w1)$: sweep descending and, at each address, read $0$, then write $1$.\n*   $\\downarrow(r1, w0)$: sweep descending and, at each address, read $1$, then write $0$.\n*   $\\downarrow(r0)$: sweep descending and, at each address, read $0$.\n\nAssume a single-port memory interface where each read or write at the word level consumes exactly $1$ clock cycle, and the BIST operates at a test clock frequency $f$ (in hertz). A single read cycle fetches the entire $b$-bit word, and a single write cycle writes the entire $b$-bit word.\n\nStarting from these definitions, and without invoking any pre-memorized complexity results, derive:\n*   The total number of word-level read operations and word-level write operations executed over the full March C$^{-}$ sequence, as functions of $n$.\n*   The total number of bit-level operations (sum of bit-level reads and bit-level writes), as a function of $n$ and $b$.\n*   The total BIST test time $T$ (in seconds), expressed in the form $T = \\frac{O(n)}{f}$ with explicit constants contributed by each March element.\n\nProvide your final answer as a single closed-form expression for $T$ in terms of $n$ and $f$ only. Do not include units in your final answer.",
            "solution": "We begin with core definitions of March testing and synchronous single-port memory access timing:\n\n1.  A March element applies a fixed sequence of read and write operations to every address exactly once per traversal, either in ascending or descending order. For a memory with $n$ addresses, a single traversal touches $n$ addresses.\n\n2.  In a single-port synchronous memory interface, a read of a word consumes $1$ clock cycle, and a write of a word consumes $1$ clock cycle. Read and write cannot occur in the same cycle. Therefore, a per-address sequence of $k$ operations consumes $k$ cycles per address, or $k n$ cycles per full traversal of $n$ addresses.\n\n3.  Each word-level read returns $b$ bits in parallel and each word-level write applies $b$ bits in parallel. Therefore, the bit-level operation count equals the number of word-level operations multiplied by $b$.\n\nWe next enumerate the March C$^{-}$ elements and their per-address operation counts:\n\n*   Element $\\uparrow(w0)$: per address, the sequence is a single write of value $0$. This contributes $1$ word-level operation per address, hence $1 \\cdot n$ total word-level operations for this element. Of these, reads are $0 \\cdot n$ and writes are $1 \\cdot n$.\n\n*   Element $\\uparrow(r0, w1)$: per address, the sequence is a read expecting $0$ followed by a write of $1$. This contributes $2$ word-level operations per address, hence $2 \\cdot n$ operations for this element, consisting of $1 \\cdot n$ reads and $1 \\cdot n$ writes.\n\n*   Element $\\uparrow(r1, w0)$: similarly contributes $2 \\cdot n$ word-level operations, with $1 \\cdot n$ reads and $1 \\cdot n$ writes.\n\n*   Element $\\downarrow(r0, w1)$: contributes $2 \\cdot n$ word-level operations, with $1 \\cdot n$ reads and $1 \\cdot n$ writes.\n\n*   Element $\\downarrow(r1, w0)$: contributes $2 \\cdot n$ word-level operations, with $1 \\cdot n$ reads and $1 \\cdot n$ writes.\n\n*   Element $\\downarrow(r0)$: per address, a single read expecting $0$, contributing $1 \\cdot n$ word-level operations, all reads.\n\nSumming across all six elements gives the total word-level read and write counts:\n\n*   Total reads: from elements $\\uparrow(r0,w1)$, $\\uparrow(r1,w0)$, $\\downarrow(r0,w1)$, $\\downarrow(r1,w0)$, and $\\downarrow(r0)$, each contributing $1 \\cdot n$ reads, we obtain\n    $$\n    n + n + n + n + n \\;=\\; 5 n.\n    $$\n\n*   Total writes: from elements $\\uparrow(w0)$, $\\uparrow(r0,w1)$, $\\uparrow(r1,w0)$, $\\downarrow(r0,w1)$, and $\\downarrow(r1,w0)$, each contributing $1 \\cdot n$ writes, we obtain\n    $$\n    n + n + n + n + n \\;=\\; 5 n.\n    $$\n\nTherefore, the total number of word-level memory accesses (reads plus writes) over the entire March C$^{-}$ is\n$$\n5 n + 5 n \\;=\\; 10 n.\n$$\n\nBy the parallel word interface of width $b$ bits, each word-level access corresponds to $b$ bit-level operations. Hence, the total number of bit-level operations is\n$$\n(10 n) \\cdot b \\;=\\; 10 n b.\n$$\n\nFor test time, with one word-level access per cycle and frequency $f$, the total number of cycles equals the total number of word-level accesses. Thus,\n$$\nT \\;=\\; \\frac{\\text{total cycles}}{f} \\;=\\; \\frac{10 n}{f}.\n$$\n\nTo exhibit the explicit constants contributed by each March element to $T$, note that the per-element cycle contributions are $1 \\cdot n$, $2 \\cdot n$, $2 \\cdot n$, $2 \\cdot n$, $2 \\cdot n$, and $1 \\cdot n$, summing to $(1+2+2+2+2+1) n = 10 n$. Consequently,\n$$\nT \\;=\\; \\frac{(1+2+2+2+2+1)\\,n}{f} \\;=\\; \\frac{10 n}{f}.\n$$\n\nThis expression is in seconds when $f$ is in hertz.",
            "answer": "$$\\boxed{\\frac{10 n}{f}}$$"
        },
        {
            "introduction": "Once faults are detected, redundancy offers a path to recovery, but its power is not infinite. This practice explores the theoretical ceiling of repair capability by asking you to determine the maximum number of defects that a given set of spare rows and columns can cover . By applying the principle of inclusion-exclusion, you will derive the fundamental formula for maximum coverage and develop an intuition for why defect clustering dramatically impacts repair efficiency.",
            "id": "4282064",
            "problem": "A static random-access memory macro is organized as a rectangular bit-cell array with $M$ wordlines (rows) and $N$ bitlines (columns). The design implements redundancy with $R$ spare rows and $C$ spare columns. A Built-In Self-Test (BIST) identifies single-bit point defects, and a Built-In Redundancy Analysis (BIRA) performs optimal allocation of spares subject to the following implementation constraints: when a row (respectively, column) spare is allocated to a faulty row (respectively, column), it replaces the entire row (respectively, column), thereby masking all defects on that line. Assume ideal remapping resources so that up to $R$ distinct rows and up to $C$ distinct columns can be replaced without address conflicts, and assume that the spare lines are indistinguishable and can target arbitrary victim lines.\n\nStarting from first principles of set counting and without invoking any pre-derived redundancy coverage formulas, derive a closed-form expression, as a function of $M$, $N$, $R$, and $C$, for the theoretical maximum number of single-bit point defects that can be rendered non-observable (i.e., covered) under the best-case spatial arrangement of defects and optimal BIRA allocation of at most $R$ spare rows and $C$ spare columns. Your final expression must count only distinct defective cells that can be covered and must account for any overlap between covered rows and columns.\n\nBriefly justify why this expression is both an upper bound and is achievable by a specific arrangement of defects and corresponding spare allocation. In addition, explain qualitatively (no calculation required) how highly clustered versus highly dispersed defect patterns affect the number of defects that can be repaired under the same $(R,C)$ resources.\n\nProvide your final result as a single closed-form expression in terms of $M$, $N$, $R$, and $C$. No units are required. Do not round.",
            "solution": "The objective is to find the theoretical maximum number of single-bit point defects that can be covered by allocating at most $R$ spare rows and $C$ spare columns. To achieve the maximum possible coverage, we must utilize all available spare resources, namely, replacing exactly $R$ rows and $C$ columns. The problem then reduces to counting the total number of unique cells contained within an arbitrary set of $R$ rows and $C$ columns. A best-case spatial arrangement of defects would involve placing one defect in every cell that can be repaired, making the number of coverable defects equal to the number of unique cells in the repaired region. We assume that the number of spare resources does not exceed the number of original lines, i.e., $R \\le M$ and $C \\le N$.\n\nWe will derive this count from the first principle of set counting, specifically the principle of inclusion-exclusion.\n\nLet the memory array be a set of cells indexed by $(i, j)$, where the row index $i$ ranges from $1$ to $M$ and the column index $j$ ranges from $1$ to $N$. Let us select $R$ specific rows and $C$ specific columns for replacement. The exact choice of which rows and columns are selected does not alter the total count of covered cells due to the symmetry of the array.\n\nLet $\\mathcal{A}$ be the set of all cells contained in the $R$ selected rows. Since each of the $R$ rows contains $N$ cells (one for each column), the total number of cells in this set is:\n$$|\\mathcal{A}| = R \\times N$$\n\nLet $\\mathcal{B}$ be the set of all cells contained in the $C$ selected columns. Since each of the $C$ columns contains $M$ cells (one for each row), the total number of cells in this set is:\n$$|\\mathcal{B}| = C \\times M$$\n\nThe total set of cells covered by the repair is the union of these two sets, $\\mathcal{A} \\cup \\mathcal{B}$. If we simply sum the sizes of the two sets, $|\\mathcal{A}| + |\\mathcal{B}|$, we will have double-counted the cells that belong to both a selected row and a selected column. These are the cells that lie at the intersections of the chosen rows and columns.\n\nThe set of such overlapping cells is the intersection of the two sets, $\\mathcal{A} \\cap \\mathcal{B}$. This intersection forms a rectangular sub-grid of cells whose row index is one of the $R$ selected rows and whose column index is one of the $C$ selected columns. The number of cells in this intersection is therefore:\n$$|\\mathcal{A} \\cap \\mathcal{B}| = R \\times C$$\n\nAccording to the principle of inclusion-exclusion for two sets, the size of their union is given by:\n$$|\\mathcal{A} \\cup \\mathcal{B}| = |\\mathcal{A}| + |\\mathcal{B}| - |\\mathcal{A} \\cap \\mathcal{B}|$$\n\nSubstituting the expressions for the sizes of the sets, we obtain the expression for the total number of unique cells covered:\n$$|\\mathcal{A} \\cup \\mathcal{B}| = (R \\times N) + (C \\times M) - (R \\times C)$$\n\nThis expression represents the theoretical maximum number of single-bit point defects that can be covered.\n\nJustification:\nThis expression is an upper bound because no repair allocation can cover more cells than the total number of unique cells within the chosen $R$ rows and $C$ columns. The formula correctly counts every unique cell in this union. The expression is also achievable. Consider a defect arrangement where a defect is placed at every cell $(i, j)$ such that $1 \\le i \\le R$ or $1 \\le j \\le C$. The total number of such defects is precisely $R \\times N + C \\times M - R \\times C$. By allocating the $R$ spare rows to the first $R$ rows of the array and the $C$ spare columns to the first $C$ columns, all of these defects are successfully covered. This demonstrates that there exists a defect layout and a corresponding optimal repair allocation for which this maximum number of defects is repaired.\n\nQualitative effect of defect patterns:\nThe effectiveness of row/column redundancy is highly dependent on the spatial distribution of defects.\nFor highly clustered defects, the repair scheme is very efficient. For example, if many defects are concentrated on a single row, one spare row can repair all of them. The best-case scenario described above, where all defects fall perfectly within the grid formed by $R$ rows and $C$ columns, is an example of optimal clustering for the given repair resources. In this case, a large number of defects can be repaired.\nFor highly dispersed defects, the repair scheme is inefficient. The worst-case scenario involves a \"diagonal\" distribution, where each of $k$ defects is in a unique row and a unique column. To repair $k$ such defects, one would ideally need to use $k$ spare rows and $k$ spare columns, if available. With only $R$ rows and $C$ columns, one can repair at most $R+C$ such defects (e.g., using $R$ rows to fix $R$ defects and $C$ columns to fix the other $C$ defects). Therefore, for the same number of defects and the same $(R,C)$ resources, a highly dispersed pattern leads to a much lower number of repairable defects and thus lower yield compared to a clustered pattern.",
            "answer": "$$\n\\boxed{R N + C M - R C}\n$$"
        },
        {
            "introduction": "Real-world fault patterns are rarely simple, and deciding how to allocate limited spare resources is a complex optimization task. This final exercise challenges you to step into the role of a Built-In Redundancy Analysis (BIRA) designer by formulating the spare allocation problem as a formal constraint satisfaction problem . You will learn how to encode fault coverage requirements, resource limits, and repair priorities into a mathematical model, providing a direct glimpse into the algorithms that power intelligent self-repair in modern chips.",
            "id": "4282099",
            "problem": "Consider a random-access memory array subjected to Memory Built-In Self-Test (MBIST), which reports a finite set of faulty cell coordinates and invokes Built-In Self-Repair (BISR) using spare rows and spare columns. A row repair replaces all cells in a selected physical wordline, and a column repair replaces all cells in a selected bitline. Assume each spare row targets exactly one physical row and each spare column targets exactly one physical column, and that a repaired row or column covers all faults that lie on that row or column. You are to construct a constraint satisfaction formulation that captures multi-fault, multi-spare allocation with a strict preference for row repairs over column repairs, and then solve a concrete instance to validate correctness and optimality.\n\nStart from the fundamental definitions that: a fault at coordinate $(i,j)$ is repaired if either its row $i$ is repaired or its column $j$ is repaired, that spare capacity limits the number of rows and columns that can be repaired, and that lexicographic preference can be enforced by a weighted objective with a sufficiently large weight. Let the decision variables be binary indicators on whether to repair a row or a column. State all constraints and the objective precisely.\n\nThen, solve the following instance. The memory has physical row index set $R=\\{1,2,3,4,5,6\\}$ and column index set $C=\\{1,2,3,4,5,6\\}$. The MBIST-reported fault set is\n$$\nF=\\{(1,2),(1,5),(2,5),(3,1),(3,5),(5,3)\\}.\n$$\nThere are at most $S_r=2$ spare rows and at most $S_c=2$ spare columns available. To encode the preference for row repairs, use a weighted sum objective with $M=100$ multiplying the number of column repairs and unit weight on the number of row repairs. Justify that the chosen $M$ enforces the strict preference for minimizing the number of column repairs before minimizing the number of row repairs for this instance.\n\nCompute the optimal objective value of your formulation on the given instance. Express your final answer as an exact integer (no units). If multiple allocations achieve the same minimal objective, you do not need to report the allocation, only the objective value.",
            "solution": "The problem can be formulated as an integer linear program (ILP). Let $R_{all}$ and $C_{all}$ be the index sets for all physical rows and columns in the memory array, respectively. Let $F$ be the set of coordinates $(i, j)$ of faulty cells, where $i \\in R_{all}$ and $j \\in C_{all}$.\n\nWe define two sets of binary decision variables:\n*   $r_i \\in \\{0, 1\\}$ for each row $i \\in R_{all}$. $r_i = 1$ if row $i$ is repaired using a spare row, and $r_i = 0$ otherwise.\n*   $c_j \\in \\{0, 1\\}$ for each column $j \\in C_{all}$. $c_j = 1$ if column $j$ is repaired using a spare column, and $c_j = 0$ otherwise.\n\nThe problem is governed by the following constraints:\n1.  **Fault Coverage:** Every reported fault must be repaired. A fault at $(i, j) \\in F$ is repaired if its row $i$ is repaired or its column $j$ is repaired. This translates to a constraint for each fault:\n    $$r_i + c_j \\ge 1 \\quad \\forall (i, j) \\in F$$\n2.  **Spare Row Capacity:** The total number of rows repaired cannot exceed the number of available spare rows, $S_r$.\n    $$\\sum_{i \\in R_{all}} r_i \\le S_r$$\n3.  **Spare Column Capacity:** The total number of columns repaired cannot exceed the number of available spare columns, $S_c$.\n    $$\\sum_{j \\in C_{all}} c_j \\le S_c$$\n\nThe objective is to find a repair allocation that satisfies these constraints while observing a strict preference for row repairs over column repairs. This is a lexicographic optimization problem, where we seek to minimize the pair $(N_c, N_r)$, where $N_c = \\sum c_j$ is the number of column repairs and $N_r = \\sum r_i$ is the number of row repairs. This can be achieved by minimizing a weighted sum objective function $Z$:\n$$\\text{Minimize} \\quad Z = \\sum_{i \\in R_{all}} r_i + M \\sum_{j \\in C_{all}} c_j$$\nwhere $M$ is a sufficiently large weight.\n\nTo ensure that minimizing $Z$ is equivalent to lexicographically minimizing $(N_c, N_r)$, $M$ must be chosen such that a change in $N_c$ has a greater impact on $Z$ than any possible change in $N_r$. Let's consider two feasible solutions, $A$ and $B$, with repair counts $(N_{r,A}, N_{c,A})$ and $(N_{r,B}, N_{c,B})$. If we prefer solution $A$ because $N_{c,A} < N_{c,B}$, we require $Z_A < Z_B$.\n$$Z_B - Z_A = (N_{r,B} - N_{r,A}) + M(N_{c,B} - N_{c,A}) > 0$$\nSince $N_{c,B} - N_{c,A} \\ge 1$ (as they are integers), this inequality becomes $M(N_{c,B} - N_{c,A}) > N_{r,A} - N_{r,B}$. The maximum possible value for the difference $N_{r,A} - N_{r,B}$ is bounded by the maximum possible value of $N_r$, which is the total number of available spare rows, $S_r$. Therefore, a sufficient condition to enforce the strict preference is $M > S_r$. In the given problem, $S_r=2$. The chosen weight $M=100$ satisfies $100 > 2$, thus correctly enforcing the lexicographic preference.\n\nNow, we solve the specific instance:\n*   Row indices: $R=\\{1,2,3,4,5,6\\}$\n*   Column indices: $C=\\{1,2,3,4,5,6\\}$\n*   Fault set: $F=\\{(1,2),(1,5),(2,5),(3,1),(3,5),(5,3)\\}$\n*   Spare capacity: $S_r=2$, $S_c=2$\n*   Objective: Minimize $Z = \\sum r_i + 100 \\sum c_j$\n\nWe begin by seeking a solution that minimizes the number of column repairs, $N_c$.\n\n**Case 1: $N_c = 0$**\nIf no columns are repaired, all $6$ faults must be covered by at most $S_r=2$ row repairs. The faults are located in rows $1$, $2$, $3$, and $5$. Let's examine the coverage of row repairs:\n*   $r_1=1$ covers faults $\\{(1,2), (1,5)\\}$\n*   $r_2=1$ covers fault $\\{(2,5)\\}$\n*   $r_3=1$ covers faults $\\{(3,1), (3,5)\\}$\n*   $r_5=1$ covers fault $\\{(5,3)\\}$\nTo cover all faults, we need to cover those in rows $1$, $2$, $3$, and $5$. The best two-row combination is $\\{r_1, r_3\\}$, which covers $\\{(1,2), (1,5), (3,1), (3,5)\\}$. The faults $\\{(2,5), (5,3)\\}$ remain uncovered. No combination of $2$ rows can cover all $6$ faults. Therefore, no feasible solution exists for $N_c=0$.\n\n**Case 2: $N_c = 1$**\nWe use one spare column. To maximize the benefit, we should repair the column with the most faults, which is column $5$.\n*   Let $c_5=1$. This covers the faults $\\{(1,5), (2,5), (3,5)\\}$.\n*   The remaining faults to be covered are $F' = \\{(1,2), (3,1), (5,3)\\}$.\n*   These faults are in distinct rows ($1$, $3$, and $5$) and distinct columns ($2$, $1$, and $3$). To cover them with row repairs, we would need to set $r_1=1$, $r_3=1$, and $r_5=1$. This requires $N_r=3$ row repairs. However, we only have $S_r=2$. Thus, this approach is not feasible. Other choices for a single column repair are even less effective as they cover only one fault each. Therefore, no feasible solution exists for $N_c=1$.\n\n**Case 3: $N_c = 2$**\nSince solutions with $N_c < 2$ are infeasible, the minimum number of column repairs must be $N_c=2$, provided a solution exists. We have a budget of $S_c=2$, so this is possible. Our goal now is to find a solution with $N_c=2$ that uses the minimum number of row repairs, $N_r$. We have a budget of $S_r=2$ for row repairs.\n\nLet's examine combinations of two column repairs:\n*   Choose to repair columns $c_2$ and $c_5$. So $c_2=1, c_5=1$.\n*   These repairs cover the faults $\\{(1,2)\\}$ and $\\{(1,5), (2,5), (3,5)\\}$.\n*   The set of covered faults is $\\{(1,2), (1,5), (2,5), (3,5)\\}$.\n*   The remaining faults are $F' = \\{(3,1), (5,3)\\}$.\n*   To cover these remaining faults, we must repair row $3$ (for $(3,1)$) and row $5$ (for $(5,3)$).\n*   This requires setting $r_3=1$ and $r_5=1$, which means $N_r=2$.\n*   This is a feasible allocation: $N_c = 2$ and $N_r = 2$. Both are within the spare budgets ($S_c=2, S_r=2$).\n\nWe have found a valid solution vector $(N_c, N_r)=(2,2)$. We must verify that no solution with $N_c=2$ and $N_r < 2$ exists.\n*   If $N_r=1$: Let's try repairing one row and two columns. For example, if we repair row $3$ ($r_3=1$), we cover $\\{(3,1), (3,5)\\}$. The remaining faults are $\\{(1,2), (1,5), (2,5), (5,3)\\}$. These faults are in columns $2, 5, 3$. To cover them, we would need three column repairs ($c_2, c_5, c_3$), but we only have $S_c=2$. This and similar analyses for other single-row choices confirm that no solution exists with $N_r=1, N_c=2$.\n*   If $N_r=0$: We must cover all $6$ faults with $2$ column repairs. The faults are in columns $1, 2, 3, 5$. Picking the two best columns, $c_5$ and any other, is insufficient. For instance, $\\{c_1, c_5\\}$ covers $\\{(1,5),(2,5),(3,5),(3,1)\\}$, leaving $\\{(1,2), (5,3)\\}$ uncovered. No pair of columns covers all faults.\n\nTherefore, the lexicographically minimal solution is $(N_c, N_r) = (2, 2)$.\n\nThe optimal objective value is calculated using these values:\n$$Z_{opt} = N_r + M \\times N_c = 2 + 100 \\times 2 = 2 + 200 = 202$$\nOther valid repair allocations exist (e.g., $\\{r_1, r_5, c_1, c_5\\}$ or $\\{r_1, r_3, c_3, c_5\\}$), but they all result in $N_r=2, N_c=2$, yielding the same optimal objective value.",
            "answer": "$$\\boxed{202}$$"
        }
    ]
}