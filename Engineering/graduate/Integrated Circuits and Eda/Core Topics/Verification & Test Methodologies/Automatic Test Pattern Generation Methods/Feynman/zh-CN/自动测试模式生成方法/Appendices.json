{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导您逐步完成经典的 D 算法。通过手动执行故障激活、传播和线值合理化，您将具体了解 ATPG 算法如何遍历电路逻辑以针对特定故障生成测试向量。这项实践对于掌握 ATPG 算法的核心机制至关重要 。",
            "id": "4256794",
            "problem": "考虑一个用于电子设计自动化 (EDA) 中自动测试向量生成 (ATPG) 的组合电路。该电路有主输入 $\\{a,b,c,d,e\\}$，一个内部故障点，以及一个单一主输出 $y$。其门级结构由以下布尔函数定义：\n$$n_{1} = \\operatorname{NAND}(a,b), \\quad n_{2} = \\operatorname{NAND}(c,d), \\quad n_{3} = \\operatorname{XOR}(n_{1},e),$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3}), \\quad n_{5} = \\operatorname{OR}(b,n_{4}), \\quad y = \\operatorname{AND}(n_{5},a).$$\n假设采用单一固定型故障模型，在信号线 $n_{2}$ 上存在一个固定为1 (stuck-at-1) 的故障。使用五值逻辑 $\\{0,1,X,D,\\overline{D}\\}$ 的 D 算法，其中 $D$ 表示在无故障电路中为 $1$ 而在故障电路中为 $0$ 的值，$\\overline{D}$ 表示在无故障电路中为 $0$ 而在故障电路中为 $1$ 的值。仅使用固定型故障激活和传播的基本定义，以及标准逻辑门的控制值和非控制值的概念（例如，对于 $\\operatorname{AND}$ 门，控制值为 $0$，非控制值为 $1$；对于 $\\operatorname{OR}$ 门，控制值为 $1$，非控制值为 $0$），执行约束传播和合理化，以推导出一个完整的主输入赋值，该赋值能在主输出 $y$ 处检测到 $n_{2}$ 上的固定为1故障。明确论述在 $n_{2}$ 处的故障激活、到 $y$ 的路径敏化，以及回溯至主输入的合理化过程。\n\n将最终的主输入向量按 $\\left[a,b,c,d,e\\right]$ 的顺序列为一个仅包含数值 $0$ 和 $1$ 的行矩阵。无需四舍五入，也无需报告物理单位。",
            "solution": "该问题要求针对给定组合电路中信号线 $n_{2}$ 上的单一固定为1故障，推导出一个测试向量。所采用的方法是D算法，该算法包含三个基本步骤：故障激活、故障传播和信号线合理化。我们将使用五值逻辑字母表 $\\{0, 1, X, D, \\overline{D}\\}$，其中 $D$ 表示无故障电路中的 $1$ 和故障电路中的 $0$，而 $\\overline{D}$ 表示无故障电路中的 $0$ 和故障电路中的 $1$。\n\n该电路由以下布尔函数定义：\n$$n_{1} = \\operatorname{NAND}(a,b)$$\n$$n_{2} = \\operatorname{NAND}(c,d)$$\n$$n_{3} = \\operatorname{XOR}(n_{1},e)$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3})$$\n$$n_{5} = \\operatorname{OR}(b,n_{4})$$\n$$y = \\operatorname{AND}(n_{5},a)$$\n故障被指定为 $n_{2}$ 固定为1 (s-a-1)。\n\n**步骤1：故障激活**\n\n为了激活信号线 $n_{2}$ 上的固定为1故障，我们必须在无故障电路中将该信号线驱动为相反的值，即 $0$。驱动信号线 $n_{2}$ 的门是 $n_{2} = \\operatorname{NAND}(c,d)$。要使一个 $\\operatorname{NAND}$ 门的输出为 $0$，其两个输入都必须设置为值 $1$。\n因此，我们必须设置主输入 $c=1$ 和 $d=1$。\n\n通过此赋值，在无故障电路中，$n_{2} = \\operatorname{NAND}(1,1) = 0$。\n在故障电路中，信号线 $n_{2}$ 固定为 $1$。\n因此，信号线 $n_{2}$ 上的复合值为 $(0,1)$，对应于逻辑值 $\\overline{D}$。\n此操作构成了 D-前沿。初始主输入赋值为 $c=1$ 和 $d=1$。\n\n**步骤2：故障传播**\n\n在信号线 $n_{2}$ 上由 $\\overline{D}$ 表示的故障效应必须通过一条敏化路径传播到主输出 $y$。从 $n_{2}$ 到 $y$ 的路径是 $n_{2} \\to n_{4} \\to n_{5} \\to y$。\n\n从 $n_{2}$ 到 $n_{4}$ 的传播：\n该门是 $n_{4} = \\operatorname{AND}(n_{2}, n_{3})$。为了将信号线 $n_{2}$ 上的值通过这个 $\\operatorname{AND}$ 门传播，另一个输入 $n_{3}$ 必须设置为其非控制值，即 $1$。\n设置 $n_{3} = 1$，该门的输出变为 $n_{4} = \\operatorname{AND}(\\overline{D}, 1)$。\n在无故障电路中：$n_{4} = \\operatorname{AND}(0, 1) = 0$。\n在故障电路中：$n_{4} = \\operatorname{AND}(1, 1) = 1$。\n信号线 $n_{4}$ 上的复合值为 $(0,1)$，即 $\\overline{D}$。D-前沿已推进至 $n_{4}$。我们有了一个新目标：$n_{3}=1$。\n\n从 $n_{4}$ 到 $n_{5}$ 的传播：\n该门是 $n_{5} = \\operatorname{OR}(b, n_{4})$。为了将信号线 $n_{4}$ 上的值通过这个 $\\operatorname{OR}$ 门传播，另一个输入 $b$ 必须设置为其非控制值，即 $0$。\n设置主输入 $b=0$，该门的输出变为 $n_{5} = \\operatorname{OR}(0, \\overline{D})$。\n在无故障电路中：$n_{5} = \\operatorname{OR}(0, 0) = 0$。\n在故障电路中：$n_{5} = \\operatorname{OR}(0, 1) = 1$。\n信号线 $n_{5}$ 上的复合值为 $(0,1)$，即 $\\overline{D}$。D-前沿已推进至 $n_{5}$。我们有了一个新的主输入赋值：$b=0$。\n\n从 $n_{5}$ 到 $y$ 的传播：\n该门是 $y = \\operatorname{AND}(n_{5}, a)$。为了将信号线 $n_{5}$ 上的值传播到主输出 $y$，另一个输入 $a$ 必须设置为其非控制值，即 $1$。\n设置主输入 $a=1$，该门的输出变为 $y = \\operatorname{AND}(\\overline{D}, 1)$。\n在无故障电路中：$y = \\operatorname{AND}(0, 1) = 0$。\n在故障电路中：$y = \\operatorname{AND}(1, 1) = 1$。\n主输出 $y$ 处的复合值为 $(0,1)$，即 $\\overline{D}$。故障现在是可观测的。我们有了一个新的主输入赋值：$a=1$。\n\n传播阶段完成。当前的约束和赋值集是：\n- 主输入赋值：$a=1, b=0, c=1, d=1$。\n- 内部信号线目标：$n_{3}=1$。\n\n**步骤3：合理化**\n\n最后一步是通过为剩余的主输入寻找一个一致的赋值来合理化内部信号线上的设定值。唯一未合理化的值是 $n_{3}=1$。\n该门是 $n_{3} = \\operatorname{XOR}(n_{1}, e)$。要使一个 $\\operatorname{XOR}$ 门的输出为 $1$，其输入必须不同。所以，$(n_1, e)$ 必须是 $(0,1)$ 或 $(1,0)$。\n\n我们必须首先确定 $n_{1}$ 的值，因为其输入 $a$ 和 $b$ 已经被赋值。\n$n_{1} = \\operatorname{NAND}(a,b) = \\operatorname{NAND}(1,0) = 1$。\n$n_{1}$ 的值由先前的决策固定为 $1$。\n\n现在，我们将此值代回到 $n_{3}$ 的目标中。我们需要 $n_{3} = \\operatorname{XOR}(1, e) = 1$。\n为使该等式成立，输入 $e$ 必须为 $0$。\n这就设定了最后一个主输入：$e=0$。\n\n所有内部信号线的值现在都已通过对主输入的赋值得到合理化，没有任何矛盾。\n\n完整且一致的主输入向量是 $[a,b,c,d,e]$。\n- 来自传播：$a = 1, b = 0$。\n- 来自激活：$c = 1, d = 1$。\n- 来自合理化：$e = 0$。\n\n最终的测试向量是 $[1, 0, 1, 1, 0]$。为了验证，在此输入下，无故障电路的输出是 $y=0$，而故障电路的输出是 $y=1$。该故障被检测到。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1  0  1  1  0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "虽然像 D 算法这样的算法能找到*一个*测试向量，但理解所有可能解的完整空间也至关重要。本练习要求您推导故障检测的完备必要与充分布尔条件，从而有效地定义给定故障的所有可能测试向量。这项实践在算法过程与测试生成的底层数学基础之间架起了一座桥梁 。",
            "id": "4256795",
            "problem": "考虑一个全扫描设计，其中所有时序元件通过扫描都变得可控和可观，从而使自动测试向量生成（ATPG）问题简化为扫描捕获时间帧上的一个组合逻辑问题。设该组合逻辑块有主输入 $x_{1}, x_{2}, x_{3}, x_{4}, x_{5}$ 和一个主输出 $y$。其逻辑定义如下\n$$\nn_{1} = x_{1} \\land x_{2}, \\quad n_{2} = \\lnot x_{1} \\land x_{3}, \\quad n_{3} = n_{1} \\lor n_{2}, \\quad n_{4} = x_{4} \\oplus x_{5}, \\quad y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5}).\n$$\n假设使用单固定型故障模型，并考虑线路 $n_{3}$ 固定为 $0$ 的故障。仅使用固定型故障模型的第一性原理、五值 $D$-演算（符号 $0, 1, X, D, \\overline{D}$ 分别表示好/坏电路中的逻辑 $0$、逻辑 $1$、未知、 $1/0$ 和 $0/1$ 值）以及逻辑门的控制值和非控制值的定义，完成以下任务：\n\n- 从第一性原理出发，推导在全扫描下，在 $y$ 处检测到上述故障所需的主输入上的充分必要布尔条件。您必须从故障激活和故障效应传播的定义开始，不使用任何预封装的ATPG模板。\n- 使用 D-算法（检测算法）和面向路径的决策（PODEM）的基本语义，论证为何在全扫描假设下，这两种方法在它们能产生的用于检测该电路中此故障的主输入赋值集合方面是等价的。\n\n最后，计算能检测到 $n_{3}$ 处固定为 $0$ 故障，从而满足推导出的充分必要条件的唯一主输入赋值 $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}) \\in \\{0,1\\}^{5}$ 的确切数量。将最终答案表示为一个精确整数。无需四舍五入，不涉及单位。",
            "solution": "该问题要求三个不同的交付内容：\n1.  推导用于检测线路 $n_{3}$ 上的固定为 $0$ 故障的主输入 $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ 的充分必要布尔条件。\n2.  论证在全扫描假设下，D-算法和 PODEM 在生成此故障的测试向量集合方面的等价性。\n3.  构成此故障的完整测试集的唯一主输入赋值的确切数量。\n\n我们将按照规定，遵循第一性原理，依次解决这些问题。\n\n**第1部分：充分必要条件的推导**\n\n检测单个固定型故障需要同时满足两个基本条件：\n- **故障激活**：输入向量必须在好（无故障）电路中，将故障线路强制设置为与固定值相反的值。\n- **故障传播**：故障效应（好电路与坏电路之间信号值的差异）必须从故障点传播到至少一个主输出。\n\n所考虑的故障是 $n_{3}$ 固定为 $0$ (SA0)。\n\n**1. 故障激活条件**\n为激活 $n_{3}$ SA0 故障，好电路中线路 $n_{3}$ 的值必须是逻辑 $1$。设 $n_{3, good}$ 表示好电路中 $n_3$ 的值。激活条件是：\n$$\nn_{3, good} = 1\n$$\n$n_{3}$ 的逻辑由 $n_{3} = n_{1} \\lor n_{2}$ 给出，其中 $n_{1} = x_{1} \\land x_{2}$ 且 $n_{2} = \\lnot x_{1} \\land x_{3}$。将这些代入激活条件，我们得到以主输入表示的整体检测条件的第一部分：\n$$\n(x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1\n$$\n\n**2. 故障传播条件**\n当故障被激活时，线路 $n_{3}$ 在好电路中的值为 $1$，在坏电路中的值为 $0$。使用 $D$-演算，这表示为 $n_{3} = D$，其中 $D$ 表示好电路中的 $1$ 和坏电路中的 $0$。这个故障效应 $D$ 必须传播到主输出 $y$。\n\n输出 $y$ 定义为 $y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5})$。为了使 $n_{3}$ 处的故障效应传播到 $y$，输出 $y$ 必须对 $n_{3}$ 的值敏感。这可以通过要求 $y$ 对 $n_{3}$ 的布尔偏导数为 $1$ 来形式化：\n$$\n\\frac{\\partial y}{\\partial n_{3}} = 1\n$$\n根据定义，布尔偏导数是 $y(n_{3}=1) \\oplus y(n_{3}=0)$，其中 $\\oplus$ 是异或（XOR）运算。\n首先，我们计算 $n_{3}=1$ 和 $n_{3}=0$ 时的 $y$ 值：\n$$\ny(n_{3}=1) = (1 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = n_{4} \\lor (x_{2} \\land x_{5})\n$$\n$$\ny(n_{3}=0) = (0 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = 0 \\lor (x_{2} \\land x_{5}) = x_{2} \\land x_{5}\n$$\n现在，我们计算异或：\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\left( n_{4} \\lor (x_{2} \\land x_{5}) \\right) \\oplus (x_{2} \\land x_{5})\n$$\n使用恒等式 $A \\oplus (A \\lor B) = \\lnot A \\land B$，我们设 $A = x_{2} \\land x_{5}$ 和 $B = n_{4}$。那么：\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\lnot (x_{2} \\land x_{5}) \\land n_{4}\n$$\n因此，传播条件是：\n$$\nn_{4} \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\n这个单一方程意味着必须同时满足两个子条件：\n1.  $n_{4} = 1$\n2.  $x_{2} \\land x_{5} = 0$，等价于 $\\lnot(x_{2} \\land x_{5}) = 1$。\n\n这也可以用控制值和非控制值的概念来理解。为了使 $n_3$ 处的 $D$ 能够通过与 $n_4$ 相与的与门传播， $n_4$ 必须处于其非控制值，即 $1$。这得到 $n_4=1$。该与门的输出则为 $(D \\land 1) = D$。为了使这个 $D$ 能够通过最后的或门传播，另一个输入 $(x_2 \\land x_5)$ 必须处于其非控制值，即 $0$。这得到 $x_2 \\land x_5 = 0$。这证实了上述推导。\n\n代入 $n_{4} = x_{4} \\oplus x_{5}$，以主输入表示的传播条件为：\n$$\n(x_{4} \\oplus x_{5} = 1) \\land (x_{2} \\land x_{5} = 0)\n$$\n\n**3. 完整的充分必要条件**\n当且仅当激活和传播条件都满足时，故障才被检测到。设 $T(x_1, x_2, x_3, x_4, x_5)$ 是表示完整测试集的布尔函数。此函数是所有推导条件的逻辑与：\n$$\nT = \\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right) \\land (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5})\n$$\n一个输入向量 $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ 能检测到 $n_3$ SA0 故障，当且仅当 $T(x_1, x_2, x_3, x_4, x_5) = 1$。\n\n**第2部分：D-算法和 PODEM 的等价性**\n\n在全扫描假设下，被测电路是纯组合逻辑电路。对于组合逻辑电路，D-算法和 PODEM 都是*完备*算法。完备性意味着如果给定故障存在测试向量，该算法保证能找到一个。\n\n- **D-算法** 在门级网表上操作。它首先在故障点生成一个 $D$ 或 $\\overline{D}$（激活），然后沿着一条敏化路径将此故障效应向前传播到一个主输出。同时，它执行一个合理化步骤，从传播所需的内部线值向后推导，以确定一组一致的主输入值。决策在内部节点上做出，冲突通过回溯解决。\n\n- **面向路径的决策（PODEM）** 算法的运作方式不同。它仅对主输入（PIs）进行决策。它使用一个反向追踪过程来确定一个有助于实现目标（例如，将一个内部节点设置为所需值）的主输入赋值，然后正向模拟以观察后果。如果主输入赋值导致冲突或未能朝着激活和传播故障的目标前进，它就会在该赋值上回溯。\n\n它们能产生的解集等价，源于其共同的目标和完备性：\n1.  **共同目标**：两种算法都旨在找到一个满足故障激活和传播要求的主输入赋值。这组要求定义了所有可能解（测试向量）的空间。\n2.  **在组合逻辑电路上的完备性**：由于两种算法对于组合逻辑都是完备的，它们都能够找到任何及所有存在的测试向量。所有有效测试向量的集合是电路和故障的固有属性，由上面推导的布尔函数 $T$ 定义。它与用于寻找该集合成员的搜索策略无关。\n3.  **搜索空间与搜索策略**：D-算法和 PODEM 在导航解空间时的*搜索策略*上有所不同。D-算法的搜索空间涉及内部节点赋值，而 PODEM 的搜索空间仅限于主输入赋值。然而，两者的最终输出都是一个主输入向量。由于两者都是完备的，每个算法*可能*找到的所有主输入向量的并集是相同的，并对应于完整的测试集。差异在于计算效率和内存使用（PODEM 通常更高效，因为它避免了 D-算法复杂的合理化步骤），而不在于它们能产生的解的逻辑范围。\n\n因此，对于这个组合逻辑问题，D-算法能够产生的主输入赋值集合与 PODEM 能够产生的集合是相同的。\n\n**第3部分：测试向量数量的计算**\n\n我们必须计算使测试函数 $T$ 的值为 $1$ 的 5 位输入向量 $(x_1, x_2, x_3, x_4, x_5)$ 的数量。\n$$\nT = \\underbrace{\\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right)}_{C_1} \\land \\underbrace{(x_{4} \\oplus x_{5})}_{C_2} \\land \\underbrace{\\lnot(x_{2} \\land x_{5})}_{C_3} = 1\n$$\n我们来分析这些条件。变量 $(x_1, x_3)$ 仅在 $C_1$ 中，而 $(x_4)$ 仅在 $C_2$ 中。变量 $x_2$ 出现在 $C_1$ 和 $C_3$ 中，而 $x_5$ 出现在 $C_2$ 和 $C_3$ 中。我们可以系统地计算满足条件的赋值。让我们首先合并条件 $C_2$ 和 $C_3$：\n$$\nC_{23} = (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\n我们展开这个表达式：\n$$\nC_{23} = (x_{4}\\lnot x_{5} \\lor \\lnot x_{4}x_{5}) \\land (\\lnot x_{2} \\lor \\lnot x_{5})\n$$\n$$\n= (x_{4}\\lnot x_{5} \\land \\lnot x_{2}) \\lor (x_{4}\\lnot x_{5} \\land \\lnot x_{5}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{2}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{5})\n$$\n最后一项 $(\\lnot x_{4}x_{5} \\land \\lnot x_{5})$ 为 $0$。第二项简化为 $x_{4}\\lnot x_{5}$。根据吸收律 ($A \\lor (A \\land B) = A$)，前两项简化为 $x_{4}\\lnot x_{5}$。\n$$\nC_{23} = x_{4}\\lnot x_{5} \\lor \\lnot x_{2}\\lnot x_{4}x_{5}\n$$\n我们可以计算满足条件的 $(x_2, x_4, x_5)$ 赋值：\n- 如果 $x_{4}=1, x_{5}=0$：项 $x_{4}\\lnot x_{5}$ 为 $1$，所以 $C_{23}=1$。这对任何 $x_2$ 都成立。这给出了 $(x_2, x_4, x_5)$ 的两个解：$(0,1,0)$ 和 $(1,1,0)$。\n- 如果此项为 $0$，我们需要 $\\lnot x_{2}\\lnot x_{4}x_{5}=1$。这要求 $x_2=0, x_4=0, x_5=1$。这给出了一个解：$(0,0,1)$。\n总共有 $2+1=3$ 种满足 $(x_2, x_4, x_5)$ 的赋值：$(0,1,0)$, $(1,1,0)$ 和 $(0,0,1)$。\n\n现在我们必须为每种情况满足条件 $C_1 = (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1$。$C_1$ 依赖于 $x_1, x_2, x_3$。$(x_1, x_3)$ 的解的数量取决于 $x_2$ 的值。\n- 如果 $x_2 = 0$：$C_1$ 变为 $(x_1 \\land 0) \\lor (\\lnot x_1 \\land x_3) = \\lnot x_1 \\land x_3 = 1$。这只有一个解：$(x_1, x_3) = (0,1)$。\n- 如果 $x_2 = 1$：$C_1$ 变为 $(x_1 \\land 1) \\lor (\\lnot x_1 \\land x_3) = x_1 \\lor (\\lnot x_1 \\land x_3)$。使用恒等式 $A \\lor (\\lnot A \\land B) = A \\lor B$，这等价于 $x_1 \\lor x_3 = 1$。这有三个解：$(x_1, x_3)$: $(0,1)$, $(1,0)$ 和 $(1,1)$。\n\n我们现在可以通过将三个有效的 $(x_2, x_4, x_5)$ 元组的贡献相加来找到总数：\n1.  对于 $(x_2, x_4, x_5) = (0,1,0)$：这里 $x_2=0$。满足 $C_1$ 的方法数量是 $1$。总向量数：$1$。\n2.  对于 $(x_2, x_4, x_5) = (1,1,0)$：这里 $x_2=1$。满足 $C_1$ 的方法数量是 $3$。总向量数：$3$。\n3.  对于 $(x_2, x_4, x_5) = (0,0,1)$：这里 $x_2=0$。满足 $C_1$ 的方法数量是 $1$。总向量数：$1$。\n\n不同的主输入赋值的总数是这些计数的总和：$1 + 3 + 1 = 5$。\n\n这五个测试向量是：\n1.  $(x_1,x_3)=(0,1)$ 且 $(x_2,x_4,x_5)=(0,1,0) \\implies (0,0,1,1,0)$\n2.  $(x_1,x_3)=(0,1)$ 且 $(x_2,x_4,x_5)=(1,1,0) \\implies (0,1,1,1,0)$\n3.  $(x_1,x_3)=(1,0)$ 且 $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,0,1,0)$\n4.  $(x_1,x_3)=(1,1)$ 且 $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,1,1,0)$\n5.  $(x_1,x_3)=(0,1)$ 且 $(x_2,x_4,x_5)=(0,0,1) \\implies (0,0,1,0,1)$\n\n最终计数为 5。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "任何 ATPG 流程中一个必不可少的环节是验证生成的测试模式是否确实能检测到目标故障。这个编程练习要求您从基本原理出发，实现一个故障模拟器。通过将拓扑评估、故障注入和处理“无关项”（$X$ 值）等概念转化为代码，您将从实践中获得关于 ATPG 工具如何运作的宝贵视角 。",
            "id": "4256830",
            "problem": "给定一个有向无环组合逻辑网络模型和一组用于验证的自动测试向量生成 (ATPG) 向量。自动测试向量生成 (ATPG) 向量可能包含由未知符号表示的未指定位，我们将其记为 $X$。该逻辑网络由集合 $\\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$ 中的逻辑门组成，这些逻辑门以有向无环图的形式连接在一起。主输入 (PI) 是源节点，主输出 (PO) 是汇节点。单一固定型 (SSA) 故障被建模为将一条逻辑信号线永久强制为 $0$ (固定于$0$) 或 $1$ (固定于$1$)。\n\n基本原理：\n- 布尔电路通过在有向无环图上复合基本门函数 $g \\in \\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$ 来计算布尔函数 $F: \\{0,1\\}^{n} \\to \\{0,1\\}^{m}$。\n- 在信号线 $f$ 上值为 $s \\in \\{0,1\\}$ 的单一固定型故障会产生一个修改后的布尔函数 $F_{f=s}$，其中信号线 $f$ 的值被永久强制为 $s$，无论其上游输入如何。\n- 一个测试向量能检测到某个单一固定型故障，当且仅当存在至少一个主输出 $y \\in \\mathrm{PO}$，使得对于相同的输入赋值 $\\mathbf{u} \\in \\{0,1\\}^{n}$，正常电路的输出值 $F(\\mathbf{u})[y]$ 与故障电路的输出值 $F_{f=s}(\\mathbf{u})[y]$ 不同。\n\n您必须实现一个向量验证和故障仿真流程，该流程利用这些原理来确定在每个测试用例中，所提供的 ATPG 向量是否能检测到指定的单一固定型故障。如果 ATPG 向量的某些主输入包含 $X$ 条目，请将 $X$ 视作未指定的输入位，并在存在性补全的条件下验证检测：如果存在对每个 $X$ 的任何 $0$ 或 $1$ 的赋值，使得检测标准成立（即，任何一种补全都能在正常电路和故障电路之间产生主输出不匹配），则该向量被视为可检测。您的算法必须：\n- 为逻辑门构建一个拓扑求值顺序，以确保在计算每个门的输出之前，其输入均已可用。\n- 通过按拓扑顺序将 PI 值在门之间传播，来计算正常电路的输出值。\n- 通过传播 PI 值来计算故障电路的输出值，同时在定义 $f$ 的点（如果 $f$ 是主输入，则在 PI 处）将故障信号线 $f$ 强制为固定值 $s$。\n- 对于包含 $X$ 的向量，枚举 $X$ 位置的所有二进制补全，并对每个补全应用检测检查；如果任何一个补全能够检测到故障，则报告检测结果为真。\n\n数学形式化：\n- 令 $\\mathcal{N}$ 表示电路中信号线的集合，$\\mathrm{PI} \\subset \\mathcal{N}$ 为主输入，$\\mathrm{PO} \\subset \\mathcal{N}$ 为主输出。每个门是一个元组 $(\\text{type}, \\text{inputs}, \\text{output})$，其中 $\\text{type} \\in \\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$，$\\text{inputs} \\subset \\mathcal{N}$，且 $\\text{output} \\in \\mathcal{N}$。\n- 通过使用布尔门语义进行拓扑求值，定义由 PI 赋值 $\\mathbf{u}$ 导出的正常估值函数 $V: \\mathcal{N} \\to \\{0,1\\}$：$\\mathrm{AND}(x_1,x_2)=x_1 \\wedge x_2$, $\\mathrm{OR}(x_1,x_2)=x_1 \\vee x_2$, $\\mathrm{NOT}(x)=\\neg x$。\n- 对于相同的 $\\mathbf{u}$，通过在任何下游求值之前或之时强制 $V_{f=s}(f)=s$ 并使用相同的门语义，来定义故障估值函数 $V_{f=s}: \\mathcal{N} \\to \\{0,1\\}$。\n- 对于给定的补全 $\\mathbf{u}$，检测标准为 $\\exists y \\in \\mathrm{PO}: V(y) \\neq V_{f=s}(y)$；对于包含 $X$ 的向量，如果存在与指定的非 $X$ 位一致的 $\\mathbf{u} \\in \\{0,1\\}^{n}$ 使得该标准成立，则该向量是可检测的。\n\n输入规范是程序内部的。使用以下电路、故障和向量的测试套件：\n\n- 测试用例 $1$ (正常路径)：电路 $C_1$，$\\mathrm{PI}=\\{a,b\\}$，门 $\\{(\\mathrm{AND}, [a,b], n_1)\\}$，$\\mathrm{PO}=\\{n_1\\}$。故障 $(f=n_1, s=0)$。向量 $a=1$, $b=1$。预期结果：检测为真。\n- 测试用例 $2$ (屏蔽)：电路 $C_2$，$\\mathrm{PI}=\\{a,b,c\\}$，门 $\\{(\\mathrm{AND}, [a,b], n_1), (\\mathrm{OR}, [n_1,c], y)\\}$，$\\mathrm{PO}=\\{y\\}$。故障 $(f=n_1, s=0)$。向量 $a=1$, $b=1$, $c=1$。预期结果：检测为假，因为 $\\mathrm{OR}$ 门的控制输入导致输出被屏蔽。\n- 测试用例 $3$ (未激活)：电路 $C_1$ 同上。故障 $(f=n_1, s=0)$。向量 $a=0$, $b=1$。预期结果：检测为假，因为故障未被激活（在正常电路中 $n_1$ 的值已经是 $0$）。\n- 测试用例 $4$ (存在性 $X$ 补全可检测)：电路 $C_2$ 同上。故障 $(f=n_1, s=0)$。向量 $a=1$, $b=X$, $c=0$。预期结果：检测为真，因为补全 $b=1$ 可检测到故障，而 $b=0$ 则不能。\n- 测试用例 $5$ (主输入上的故障)：电路 $C_3$，$\\mathrm{PI}=\\{a\\}$，门 $\\{(\\mathrm{NOT}, [a], y)\\}$，$\\mathrm{PO}=\\{y\\}$。故障 $(f=a, s=1)$。向量 $a=0$。预期结果：检测为真。\n\n您的程序必须实现所述的验证和仿真流程，并为上述测试套件生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$），每个结果都是一个布尔值，指示该向量是否检测到其电路中的指定故障。不涉及物理单位或角度。程序必须是自包含的，不接受外部输入，并严格遵守输出格式。",
            "solution": "该解决方案通过遵循以下基于原则的、分步的过程来实现：\n\n1.  **电路表示与拓扑排序**：\n    组合逻辑网络是一个有向无环图 (DAG)，其中节点代表逻辑信号（信号线），有向边代表通过逻辑门的数据流。为了仿真电路，我们必须按一定顺序对门进行求值，以确保在计算一个门的输出值之前，其所有输入值都已知。这可以通过对电路的信号线进行拓扑排序来实现。该算法从主输入 ($\\mathrm{PI}$) 开始，这些输入在电路内部没有依赖关系，然后逐层遍历整个网络。\n\n    令 $\\mathcal{N}$ 为所有信号线的集合。拓扑排序会生成一个有序的信号线列表 $(v_1, v_2, \\dots, v_{|\\mathcal{N}|})$，使得对于任何输入为 $\\{i_1, \\dots, i_k\\}$、输出为 $o$ 的门，所有输入都在排序列表中出现在输出之前。这个顺序保证了信号传播仿真的正确性。我们可以使用 Kahn 算法来实现这一点，该算法系统地处理入度为 $0$ 的节点。\n\n2.  **全指定输入向量的逻辑仿真**：\n    给定一个完整的输入向量 $\\mathbf{u} \\in \\{0,1\\}^{n}$，其中 $n=|\\mathrm{PI}|$，我们通过按确定的拓扑顺序将输入值在门之间传播来仿真电路的行为。这个过程执行两次：一次针对“正常”（无故障）电路，一次针对“故障”电路。\n\n    *   **正常电路仿真**：我们为所有信号线计算一个估值函数 $V: \\mathcal{N} \\to \\{0,1\\}$。\n        - 对于每个主输入 $p_i \\in \\mathrm{PI}$，其值由输入向量设定：$V(p_i) = u_i$。\n        - 对于拓扑顺序中的每个后续信号线 $o$，如果它是门 $g$ 的输出，其输入为 $\\{i_1, \\dots, i_k\\}$，则通过将该门的布尔函数应用于其已计算出的输入值来计算其值：$V(o) = g(V(i_1), \\dots, V(i_k))$。门函数是标准的：对于 $\\mathrm{AND}$ 门，$V(o) = V(i_1) \\wedge V(i_2)$；对于 $\\mathrm{OR}$ 门，$V(o) = V(i_1) \\vee V(i_2)$；对于 $\\mathrm{NOT}$ 门，$V(o) = \\neg V(i_1)$。\n\n    *   **故障电路仿真**：我们对信号线 $f$ 上的值为 $s \\in \\{0,1\\}$ 的单一固定型故障进行建模。我们计算一个故障估值函数 $V_{f=s}: \\mathcal{N} \\to \\{0,1\\}$。\n        - 仿真过程与正常电路仿真相同，但有一个关键例外：当在拓扑求值顺序中遇到故障信号线 $f$ 时，其值被强制设定为固定值 $s$，即 $V_{f=s}(f) = s$。然后，该值将用于所有下游门的求值。如果故障位于主输入上，则其值在仿真开始时即被覆盖。\n\n3.  **故障检测标准**：\n    一个测试向量 $\\mathbf{u}$ 成功检测到故障 $(f, s)$，当且仅当正常电路的输出与故障电路的输出在至少一个主输出 ($\\mathrm{PO}$) 上不同。形式上，如果满足以下条件，则发生检测：\n    $$ \\exists y \\in \\mathrm{PO} \\text{ such that } V(y) \\neq V_{f=s}(y) $$\n    这要求测试向量同时满足两个条件：\n    - **故障激活**：该向量必须在正常电路的故障点 $f$ 上产生一个与固定值相反的值。即 $V(f) \\neq s$。如果不满足此条件，故障对电路状态没有影响。\n    - **故障传播**：故障的影响（在信号线 $f$ 上的差异）必须通过下游逻辑传播到至少一个主输出。如果故障效应被逻辑屏蔽（例如，如果 $\\mathrm{AND}$ 门的另一个输入为 $0$，则其一个输入固定于$0$的故障将被屏蔽），它将是不可观测的。\n\n4.  **处理未指定输入 ($X$)**：\n    ATPG 向量可能包含由 $X$ 表示的未指定输入。问题规定检测在*存在性补全*的条件下成立。这意味着，如果存在对 $X$ 输入的*任何*二进制值（$0$ 或 $1$）的赋值满足检测标准，则该向量被认为可检测到故障。\n\n    为实现这一点，我们枚举该向量所有可能的二进制补全。如果一个向量有 $k$ 个输入被指定为 $X$，则存在 $2^k$ 个可能的完整输入向量。对于这 $2^k$ 个向量中的每一个，我们都执行完整的正常电路和故障电路仿真，并检查检测标准。只要其中一个补全导致了检测，整个向量就被验证为可检测到故障，并且该测试用例的搜索可以终止。如果所有 $2^k$ 个补全都未能检测到故障，则该向量被声明为不可检测。\n\n**示例演练**\n\n让我们用测试用例 $4$ 来阐述这个过程：\n- **电路**：$C_2$，$\\mathrm{PI}=\\{a,b,c\\}$，门 $\\{(\\mathrm{AND}, [a,b], n_1), (\\mathrm{OR}, [n_1,c], y)\\}$，$\\mathrm{PO}=\\{y\\}$。\n- **故障**：$(f=n_1, s=0)$。\n- **向量**：$(a=1, b=X, c=0)$。\n\n该向量有一个未指定的输入，$b=X$。我们必须测试两种补全：$(b=0)$ 和 $(b=1)$。\n\n**补全 1: $b=0$。输入向量为 $(a=1, b=0, c=0)$。**\n- **正常电路仿真**：\n    - $V(a)=1, V(b)=0, V(c)=0$。\n    - $V(n_1) = \\mathrm{AND}(V(a), V(b)) = \\mathrm{AND}(1, 0) = 0$。\n    - $V(y) = \\mathrm{OR}(V(n_1), V(c)) = \\mathrm{OR}(0, 0) = 0$。\n    - 主输出值：$V(y)=0$。\n- **故障电路仿真** (故障 $n_1$ 固定于$0$)：\n    - $V_{f=s}(a)=1, V_{f=s}(b)=0, V_{f=s}(c)=0$。\n    - $n_1$ 的值被强制为：$V_{f=s}(n_1) = 0$。\n    - $V_{f=s}(y) = \\mathrm{OR}(V_{f=s}(n_1), V_{f=s}(c)) = \\mathrm{OR}(0, 0) = 0$。\n    - 主输出值：$V_{f=s}(y)=0$。\n- **检测检查**：$V(y) = 0$ 且 $V_{f=s}(y) = 0$。它们相等。此补全未检测到故障。\n\n**补全 2: $b=1$。输入向量为 $(a=1, b=1, c=0)$。**\n- **正常电路仿真**：\n    - $V(a)=1, V(b)=1, V(c)=0$。\n    - $V(n_1) = \\mathrm{AND}(V(a), V(b)) = \\mathrm{AND}(1, 1) = 1$。（故障被激活）。\n    - $V(y) = \\mathrm{OR}(V(n_1), V(c)) = \\mathrm{OR}(1, 0) = 1$。（故障效应传播）。\n    - 主输出值：$V(y)=1$。\n- **故障电路仿真** (故障 $n_1$ 固定于$0$)：\n    - $V_{f=s}(a)=1, V_{f=s}(b)=1, V_{f=s}(c)=0$。\n    - $n_1$ 的值被强制为：$V_{f=s}(n_1) = 0$。\n    - $V_{f=s}(y) = \\mathrm{OR}(V_{f=s}(n_1), V_{f=s}(c)) = \\mathrm{OR}(0, 0) = 0$。\n    - 主输出值：$V_{f=s}(y)=0$。\n- **检测检查**：$V(y) = 1$ 且 $V_{f=s}(y) = 0$。它们不相等。此补全检测到故障。\n\n由于存在一个能检测到故障的补全（即 $b=1$），向量 $(a=1, b=X, c=0)$ 被视为一个可检测向量。此测试用例的结果为真。所提供的代码为所有指定的测试用例实现了这一完整流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    \n    # Test case definitions\n    # Each case: (circuit_dict, fault_tuple, pattern_dict)\n    test_cases = [\n        # Test case 1 (happy path)\n        (\n            {\n                'PI': ['a', 'b'], 'PO': ['n1'],\n                'gates': [('AND', ['a', 'b'], 'n1')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 1}\n        ),\n        # Test case 2 (masking)\n        (\n            {\n                'PI': ['a', 'b', 'c'], 'PO': ['y'],\n                'gates': [('AND', ['a', 'b'], 'n1'), ('OR', ['n1', 'c'], 'y')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 1, 'c': 1}\n        ),\n        # Test case 3 (no excitation)\n        (\n            {\n                'PI': ['a', 'b'], 'PO': ['n1'],\n                'gates': [('AND', ['a', 'b'], 'n1')],\n            },\n            ('n1', 0),\n            {'a': 0, 'b': 1}\n        ),\n        # Test case 4 (existential X completion detects)\n        (\n            {\n                'PI': ['a', 'b', 'c'], 'PO': ['y'],\n                'gates': [('AND', ['a', 'b'], 'n1'), ('OR', ['n1', 'c'], 'y')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 'X', 'c': 0}\n        ),\n        # Test case 5 (fault on primary input)\n        (\n            {\n                'PI': ['a'], 'PO': ['y'],\n                'gates': [('NOT', ['a'], 'y')],\n            },\n            ('a', 1),\n            {'a': 0}\n        )\n    ]\n\n    results = []\n    for circuit, fault, pattern in test_cases:\n        results.append(check_detection(circuit, fault, pattern))\n\n    # Format output as specified: [True,False,...]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\ndef topological_sort(circuit):\n    \"\"\"\n    Performs a topological sort of the circuit nets using Kahn's algorithm.\n    Returns an ordered list of nets for evaluation.\n    \"\"\"\n    in_degree = collections.defaultdict(int)\n    graph = collections.defaultdict(list)\n    all_nets = set(circuit['PI'])\n\n    for _, inputs, output in circuit['gates']:\n        all_nets.add(output)\n        for net in inputs:\n            all_nets.add(net)\n\n    # Build graph and in-degrees for output nets\n    for _, inputs, output in circuit['gates']:\n        in_degree[output] = len(inputs)\n        for input_net in inputs:\n            graph[input_net].append(output)\n\n    # Queue for nodes with in-degree 0 (only PIs initially)\n    queue = collections.deque([net for net in circuit['PI']])\n    \n    topo_order = []\n    while queue:\n        net = queue.popleft()\n        topo_order.append(net)\n        for neighbor in graph[net]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycles\n    gate_outputs = {g[2] for g in circuit['gates']}\n    # The order should contain PIs and all gate outputs\n    if len(topo_order) != len(circuit['PI']) + len(gate_outputs):\n         # This should not happen in a valid combinational circuit\n         raise ValueError(\"Cycle detected or disconnected graph\")\n         \n    return topo_order\n\ndef simulate(circuit, full_pattern, sorted_nets, fault=None):\n    \"\"\"\n    Simulates the circuit for a given full input pattern and an optional fault.\n    \"\"\"\n    net_values = {}\n    fault_net, fault_val = (None, None) if fault is None else fault\n\n    # Define gate logic\n    gate_logic = {\n        'AND': lambda inputs: int(all(inputs)),\n        'OR':  lambda inputs: int(any(inputs)),\n        'NOT': lambda inputs: int(not inputs[0])\n    }\n    \n    gate_map = {output: (op_type, inputs) for op_type, inputs, output in circuit['gates']}\n\n    for net in sorted_nets:\n        if net in circuit['PI']:\n            if net == fault_net:\n                net_values[net] = fault_val  # PI stuck-at fault\n            else:\n                net_values[net] = full_pattern[net]\n        else: # It's a gate output\n            if net == fault_net:\n                net_values[net] = fault_val  # Internal net stuck-at fault\n                continue\n            \n            op_type, inputs = gate_map[net]\n            input_values = [net_values[i] for i in inputs]\n            net_values[net] = gate_logic[op_type](input_values)\n\n    return net_values\n\ndef check_detection(circuit, fault, pattern):\n    \"\"\"\n    Checks if a pattern (potentially with 'X') detects a fault.\n    \"\"\"\n    x_inputs = [pi for pi, val in pattern.items() if val == 'X']\n    fixed_inputs = {pi: val for pi, val in pattern.items() if val != 'X'}\n    \n    num_x = len(x_inputs)\n    \n    # Generate all binary completions for 'X' inputs\n    completions = itertools.product([0, 1], repeat=num_x)\n\n    topo_order = topological_sort(circuit)\n    \n    for completion in completions:\n        current_pattern = fixed_inputs.copy()\n        for i, pi_name in enumerate(x_inputs):\n            current_pattern[pi_name] = completion[i]\n\n        # Simulate good and faulty circuits\n        good_vals = simulate(circuit, current_pattern, topo_order)\n        faulty_vals = simulate(circuit, current_pattern, topo_order, fault)\n        \n        # Check for detection at any Primary Output\n        detected = False\n        for po in circuit['PO']:\n            if good_vals.get(po) != faulty_vals.get(po):\n                detected = True\n                break\n        \n        if detected:\n            return True # Existential completion: one is enough\n\n    return False # No completion detected the fault\n\n# Run the solver\nsolve()\n```"
        }
    ]
}