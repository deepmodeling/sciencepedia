{
    "hands_on_practices": [
        {
            "introduction": "D算法是结构化自动测试向量生成（ATPG）领域中最早也是最基础的算法之一。要想真正掌握它如何系统性地寻找测试向量，没有比亲手完整地走一遍流程更好的方法。这个练习  要求您运用故障激活、D-边界传播和线值合理化这三大核心步骤，为指定的固定型故障生成一个测试向量。",
            "id": "4256794",
            "problem": "考虑一个用于电子设计自动化（EDA）中自动测试模式生成（ATPG）的组合电路。该电路具有主输入 $\\{a,b,c,d,e\\}$，一个内部故障点，以及一个单一主输出 $y$。其门级结构由以下布尔函数定义：\n$$n_{1} = \\operatorname{NAND}(a,b), \\quad n_{2} = \\operatorname{NAND}(c,d), \\quad n_{3} = \\operatorname{XOR}(n_{1},e),$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3}), \\quad n_{5} = \\operatorname{OR}(b,n_{4}), \\quad y = \\operatorname{AND}(n_{5},a).$$\n假设一个单一固定型故障模型，故障位于线路 $n_{2}$，类型为固定于1。使用五值逻辑 $\\{0,1,X,D,\\overline{D}\\}$ 的 D 算法，其中 $D$ 表示在无故障电路中值为 $1$ 而在故障电路中值为 $0$，$\\overline{D}$ 表示在无故障电路中值为 $0$ 而在故障电路中值为 $1$。仅使用固定型故障激活和传播的基本定义，以及标准逻辑门的控制值和非控制值的概念（例如，对于 $\\operatorname{AND}$ 门，控制值为 $0$，非控制值为 $1$；对于 $\\operatorname{OR}$ 门，控制值为 $1$，非控制值为 $0$），执行约束传播和验证，以得出一个完整的主输入赋值，从而在主输出 $y$ 处检测到 $n_{2}$ 上的固定于1故障。明确地对 $n_{2}$ 处的故障激活、$y$ 的路径敏化以及回溯到主输入的验证过程进行推理。\n\n将您的最终主输入向量按 $\\left[a,b,c,d,e\\right]$ 的顺序列为一个仅包含数值 $0$ 和 $1$ 的行矩阵。无需四舍五入，也无需报告物理单位。",
            "solution": "该问题要求为给定组合电路中线路 $n_{2}$ 上的单一固定于1故障推导出一个测试向量。所采用的方法是 D 算法，该算法包括三个基本步骤：故障激活、故障传播和线路验证。我们将使用五值逻辑字母表 $\\{0, 1, X, D, \\overline{D}\\}$，其中 $D$ 代表无故障电路中的 $1$ 和故障电路中的 $0$，而 $\\overline{D}$ 代表无故障电路中的 $0$ 和故障电路中的 $1$。\n\n电路通过以下布尔函数定义：\n$$n_{1} = \\operatorname{NAND}(a,b)$$\n$$n_{2} = \\operatorname{NAND}(c,d)$$\n$$n_{3} = \\operatorname{XOR}(n_{1},e)$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3})$$\n$$n_{5} = \\operatorname{OR}(b,n_{4})$$\n$$y = \\operatorname{AND}(n_{5},a)$$\n故障被指定为 $n_{2}$ 固定于1 (s-a-1)。\n\n**步骤 1：故障激活**\n\n为了激活线路 $n_{2}$ 上的固定于1故障，我们必须在无故障电路中将该线路驱动到相反的值，即 $0$。驱动线路 $n_{2}$ 的是门 $n_{2} = \\operatorname{NAND}(c,d)$。要使一个 $\\operatorname{NAND}$ 门的输出为 $0$，其两个输入都必须设置为值 $1$。\n因此，我们必须设置主输入 $c=1$ 和 $d=1$。\n\n通过此赋值，在无故障电路中，$n_{2} = \\operatorname{NAND}(1,1) = 0$。\n在故障电路中，线路 $n_{2}$ 固定于 $1$。\n因此，线路 $n_{2}$ 上的复合值为 $(0,1)$，对应于逻辑值 $\\overline{D}$。\n这一操作构成了 D-前沿。初始主输入赋值为 $c=1$ 和 $d=1$。\n\n**步骤 2：故障传播**\n\n故障效应，即线路 $n_{2}$ 上的 $\\overline{D}$，必须通过一条敏化路径传播到主输出 $y$。从 $n_{2}$到 $y$ 的路径是 $n_{2} \\to n_{4} \\to n_{5} \\to y$。\n\n从 $n_{2}$ 到 $n_{4}$ 的传播：\n该门是 $n_{4} = \\operatorname{AND}(n_{2}, n_{3})$。为了通过此 $\\operatorname{AND}$ 门传播线路 $n_{2}$ 上的值，另一个输入 $n_{3}$ 必须设置为其非控制值，即 $1$。\n设置 $n_{3} = 1$，该门的输出变为 $n_{4} = \\operatorname{AND}(\\overline{D}, 1)$。\n在无故障电路中：$n_{4} = \\operatorname{AND}(0, 1) = 0$。\n在故障电路中：$n_{4} = \\operatorname{AND}(1, 1) = 1$。\n$n_{4}$ 线路上的复合值为 $(0,1)$，即 $\\overline{D}$。D-前沿已推进到 $n_{4}$。我们有了一个新目标：$n_{3}=1$。\n\n从 $n_{4}$ 到 $n_{5}$ 的传播：\n该门是 $n_{5} = \\operatorname{OR}(b, n_{4})$。为了通过此 $\\operatorname{OR}$ 门传播线路 $n_{4}$ 上的值，另一个输入 $b$ 必须设置为其非控制值，即 $0$。\n设置主输入 $b=0$，该门的输出变为 $n_{5} = \\operatorname{OR}(0, \\overline{D})$。\n在无故障电路中：$n_{5} = \\operatorname{OR}(0, 0) = 0$。\n在故障电路中：$n_{5} = \\operatorname{OR}(0, 1) = 1$。\n$n_{5}$ 线路上的复合值为 $(0,1)$，即 $\\overline{D}$。D-前沿已推进到 $n_{5}$。我们有了一个新的主输入赋值：$b=0$。\n\n从 $n_{5}$ 到 $y$ 的传播：\n该门是 $y = \\operatorname{AND}(n_{5}, a)$。为了将线路 $n_{5}$ 上的值传播到主输出 $y$，另一个输入 $a$ 必须设置为其非控制值，即 $1$。\n设置主输入 $a=1$，该门的输出变为 $y = \\operatorname{AND}(\\overline{D}, 1)$。\n在无故障电路中：$y = \\operatorname{AND}(0, 1) = 0$。\n在故障电路中：$y = \\operatorname{AND}(1, 1) = 1$。\n主输出 $y$ 处的复合值为 $(0,1)$，即 $\\overline{D}$。故障现在是可观测的。我们有了一个新的主输入赋值：$a=1$。\n\n传播阶段完成。当前的约束和赋值集为：\n- 主输入赋值：$a=1, b=0, c=1, d=1$。\n- 内部线路目标：$n_{3}=1$。\n\n**步骤 3：验证**\n\n最后一步是通过为剩余的主输入找到一个一致的赋值，来验证内部线路上设置的值。唯一未验证的值是 $n_{3}=1$。\n该门是 $n_{3} = \\operatorname{XOR}(n_{1}, e)$。要从一个 $\\operatorname{XOR}$ 门获得输出 $1$，其输入必须不同。所以，$(n_1, e)$ 必须是 $(0,1)$ 或 $(1,0)$。\n\n我们必须首先确定 $n_{1}$ 的值，因为它的输入 $a$ 和 $b$ 已经被赋值。\n$n_{1} = \\operatorname{NAND}(a,b) = \\operatorname{NAND}(1,0) = 1$。\n$n_{1}$ 的值由先前的决定固定为 $1$。\n\n现在，我们将这个值代回到 $n_{3}$ 的目标中。我们需要 $n_{3} = \\operatorname{XOR}(1, e) = 1$。\n为使此方程成立，输入 $e$ 必须为 $0$。\n这设置了最后一个主输入：$e=0$。\n\n现在，所有内部线路的值都通过对主输入的赋值得到了验证，没有任何矛盾。\n\n完整且一致的主输入向量是 $[a,b,c,d,e]$。\n- 来自传播：$a = 1, b = 0$。\n- 来自激活：$c = 1, d = 1$。\n- 来自验证：$e = 0$。\n\n最终的测试向量是 $[1, 0, 1, 1, 0]$。\n为验证，在此输入下，无故障电路的输出是 $y=0$，故障电路的输出是 $y=1$。故障被检测到。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1  0  1  1  0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "像D算法这样的经典方法能高效地找到*一个*测试向量，但更深刻的理解源于对能检测某个故障的*所有*可能向量的完整刻画。这个问题  将引导您推导故障检测的完整充要布尔条件，从而在算法搜索过程与形式化逻辑描述之间建立一座桥梁。这种分析性的视角也为比较不同ATPG算法（如D算法和PODEM）的能力提供了坚实的基础。",
            "id": "4256795",
            "problem": "考虑一个全扫描设计，其中所有时序元件都通过扫描变得可控和可观，因此自动测试向量生成（ATPG）简化为扫描捕获时间帧上的组合逻辑问题。设该组合逻辑块具有主输入 $x_{1}, x_{2}, x_{3}, x_{4}, x_{5}$ 和单个主输出 $y$。其逻辑定义如下：\n$$\nn_{1} = x_{1} \\land x_{2}, \\quad n_{2} = \\lnot x_{1} \\land x_{3}, \\quad n_{3} = n_{1} \\lor n_{2}, \\quad n_{4} = x_{4} \\oplus x_{5}, \\quad y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5}).\n$$\n假设采用单一固定型故障模型，并考虑信号线 $n_{3}$ 固定于0的故障。仅使用固定型故障模型的基本原理、五值$D$-演算（符号 $0, 1, X, D, \\overline{D}$ 分别表示好/坏电路中的逻辑$0$、逻辑$1$、未知、$1/0$和$0/1$值）以及逻辑门的控制值和非控制值的定义，完成以下任务：\n\n- 从基本原理出发，推导在全扫描条件下，为了在 $y$ 处检测到上述故障，主输入所需满足的充分必要布尔条件。你必须从故障激活和故障效应传播的定义开始，并且不得使用任何预设的ATPG模板。\n- 使用D-算法和面向路径的决策（PODEM）的基础语义，论证在全扫描假设下，这两种方法在生成可检测此电路中故障的主输入赋值集合方面为何是等价的。\n\n最后，计算检测 $n_{3}$ 处固定于0故障并因此满足所推导的充分必要条件的、不同的主输入赋值 $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}) \\in \\{0,1\\}^{5}$ 的确切数量。将最终答案表示为一个精确整数。无需四舍五入，不涉及单位。",
            "solution": "该问题要求三个不同的交付成果：\n1.  推导用于检测信号线 $n_{3}$ 处固定于0故障的主输入 $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ 所需满足的充分必要布尔条件。\n2.  论证在全扫描假设下，D-Algorithm和PODEM在生成此故障的测试向量集合方面的等价性。\n3.  构成此故障的完整测试集的不同主输入赋值的确切数量。\n\n我们将按顺序并遵循规定的基本原理来解决这些问题。\n\n**第一部分：充分必要条件的推导**\n\n检测单一固定型故障需要同时满足两个基本条件：\n- **故障激活**：输入向量必须在好（无故障）电路中，强迫故障线呈现与固定值相反的值。\n- **故障传播**：故障效应（好电路与坏电路之间信号值的差异）必须从故障点传播到至少一个主输出。\n\n所考虑的故障是 $n_{3}$ 固定于0（SA0）。\n\n**1. 故障激活条件**\n要激活 $n_{3}$ SA0故障，好电路中信号线 $n_{3}$ 的值必须是逻辑$1$。设 $n_{3, good}$ 表示好电路中 $n_3$ 的值。激活条件是：\n$$\nn_{3, good} = 1\n$$\n$n_{3}$ 的逻辑由 $n_{3} = n_{1} \\lor n_{2}$ 给出，其中 $n_{1} = x_{1} \\land x_{2}$ 和 $n_{2} = \\lnot x_{1} \\land x_{3}$。将这些代入激活条件，我们得到整体检测条件的第一部分，用主输入表示为：\n$$\n(x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1\n$$\n\n**2. 故障传播条件**\n当故障被激活时，信号线 $n_{3}$ 在好电路中的值为$1$，在坏电路中的值为$0$。使用$D$-演算，这表示为 $n_{3} = D$，其中 $D$ 表示好电路中的$1$和坏电路中的$0$。这个故障效应 $D$ 必须传播到主输出 $y$。\n\n输出 $y$ 定义为 $y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5})$。为了使 $n_{3}$ 处的故障效应传播到 $y$，输出 $y$ 必须对 $n_{3}$ 的值敏感。这可以通过要求 $y$ 相对于 $n_{3}$ 的布尔偏导数为$1$来形式化：\n$$\n\\frac{\\partial y}{\\partial n_{3}} = 1\n$$\n根据定义，布尔偏导数是 $y(n_{3}=1) \\oplus y(n_{3}=0)$，其中 $\\oplus$ 是异或（XOR）运算。\n首先，我们计算 $n_{3}=1$ 和 $n_{3}=0$ 时的 $y$ 值：\n$$\ny(n_{3}=1) = (1 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = n_{4} \\lor (x_{2} \\land x_{5})\n$$\n$$\ny(n_{3}=0) = (0 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = 0 \\lor (x_{2} \\land x_{5}) = x_{2} \\land x_{5}\n$$\n现在，我们计算异或：\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\left( n_{4} \\lor (x_{2} \\land x_{5}) \\right) \\oplus (x_{2} \\land x_{5})\n$$\n使用恒等式 $A \\oplus (A \\lor B) = \\lnot A \\land B$，我们令 $A = x_{2} \\land x_{5}$ 和 $B = n_{4}$。那么：\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\lnot (x_{2} \\land x_{5}) \\land n_{4}\n$$\n因此，传播条件是：\n$$\nn_{4} \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\n这个单一方程意味着必须同时成立两个子条件：\n1.  $n_{4} = 1$\n2.  $x_{2} \\land x_{5} = 0$，这等价于 $\\lnot(x_{2} \\land x_{5}) = 1$。\n\n这也可以用控制值和非控制值的概念来理解。为了使 $n_3$ 处的 $D$ 能够通过与 $n_4$ 相连的与门传播， $n_4$ 必须处于其非控制值，即$1$。这得出 $n_4=1$。该与门的输出则为 $(D \\land 1) = D$。为了使这个 $D$ 能够通过最后的或门传播，另一个输入 $(x_2 \\land x_5)$ 必须处于其非控制值，即$0$。这得出 $x_2 \\land x_5 = 0$。这证实了上述推导。\n\n将 $n_{4} = x_{4} \\oplus x_{5}$ 代入，用主输入表示的传播条件是：\n$$\n(x_{4} \\oplus x_{5} = 1) \\land (x_{2} \\land x_{5} = 0)\n$$\n\n**3. 完整的充分必要条件**\n当且仅当激活和传播条件都得到满足时，故障才被检测到。设 $T(x_1, x_2, x_3, x_4, x_5)$ 是代表完整测试集的布尔函数。该函数是所有推导条件的逻辑与：\n$$\nT = \\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right) \\land (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5})\n$$\n当且仅当 $T(x_1, x_2, x_3, x_4, x_5) = 1$ 时，输入向量 $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ 能检测到 $n_3$ SA0 故障。\n\n**第二部分：D-Algorithm与PODEM的等价性**\n\n在全扫描假设下，被测电路是纯组合逻辑的。对于组合逻辑电路，D-Algorithm和PODEM都是*完备*算法。完备性意味着，如果给定故障存在测试向量，该算法保证能找到一个。\n\n- **D-Algorithm** 在门级网表上操作。它首先在故障点生成一个 $D$ 或 $\\overline{D}$（激活），然后将这个故障效应沿一条敏化路径向前传播到一个主输出。同时，它执行一个合理化步骤，从传播所需的内部信号线值反向工作，以确定一组一致的主输入值。决策在内部节点上做出，冲突通过回溯解决。\n\n- **面向路径的决策（PODEM）** 算法的操作方式不同。它仅在主输入（PIs）上做决策。它使用一个反向追踪过程来确定一个有助于实现目标（例如，将一个内部节点设置为所需值）的PI赋值，然后正向模拟以观察结果。如果PI赋值导致冲突或未能朝向激活和传播故障的目标前进，它就在这些赋值上进行回溯。\n\n它们能产生的解集合的等价性源于它们共同的目标和完备性：\n1.  **共同目标**：两种算法都旨在找到一个满足故障激活和传播要求的PI赋值。这些要求定义了所有可能解（测试向量）的空间。\n2.  **对组合逻辑电路的完备性**：由于两种算法对组合逻辑都是完备的，它们都能找到任何及所有存在的测试向量。所有有效测试向量的集合是电路和故障的内在属性，由上面推导的布尔函数 $T$ 定义。它与用于查找该集合中某个成员的搜索策略无关。\n3.  **搜索空间与搜索策略**：D-Algorithm和PODEM在遍历解空间的*搜索策略*上有所不同。D-Algorithm的搜索空间涉及内部节点赋值，而PODEM的搜索空间仅限于PI赋值。然而，两者的最终输出都是一个PI向量。由于两者都是完备的，每种算法*可能*找到的所有PI向量的并集是相同的，并对应于完整的测试集。差异在于计算效率和内存使用（PODEM通常更高效，因为它避免了D-algorithm复杂的合理化步骤），而不在于它们能生成的解的逻辑范围。\n\n因此，对于这个组合逻辑问题，D-Algorithm能够产生的主输入赋值集合与PODEM能够产生的集合是相同的。\n\n**第三部分：测试向量数量的计算**\n\n我们必须计算使测试函数 $T$ 值为$1$的5位输入向量 $(x_1, x_2, x_3, x_4, x_5)$ 的数量。\n$$\nT = \\underbrace{\\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right)}_{C_1} \\land \\underbrace{(x_{4} \\oplus x_{5})}_{C_2} \\land \\underbrace{\\lnot(x_{2} \\land x_{5})}_{C_3} = 1\n$$\n让我们分析这些条件。变量 $(x_1, x_3)$ 只在 $C_1$ 中，而 $(x_4)$ 只在 $C_2$ 中。变量 $x_2$ 出现在 $C_1$ 和 $C_3$ 中，变量 $x_5$ 出现在 $C_2$ 和 $C_3$ 中。我们可以系统地计算满足条件的赋值。让我们首先组合条件 $C_2$ 和 $C_3$：\n$$\nC_{23} = (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\n我们展开此表达式：\n$$\nC_{23} = (x_{4}\\lnot x_{5} \\lor \\lnot x_{4}x_{5}) \\land (\\lnot x_{2} \\lor \\lnot x_{5})\n$$\n$$\n= (x_{4}\\lnot x_{5} \\land \\lnot x_{2}) \\lor (x_{4}\\lnot x_{5} \\land \\lnot x_{5}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{2}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{5})\n$$\n最后一项 $(\\lnot x_{4}x_{5} \\land \\lnot x_{5})$ 为 $0$。第二项简化为 $x_{4}\\lnot x_{5}$。根据吸收律 ($A \\lor (A \\land B) = A$)，前两项简化为 $x_{4}\\lnot x_{5}$。\n$$\nC_{23} = x_{4}\\lnot x_{5} \\lor \\lnot x_{2}\\lnot x_{4}x_{5}\n$$\n我们可以计算满足条件的 $(x_2, x_4, x_5)$ 赋值：\n- 如果 $x_{4}=1, x_{5}=0$：项 $x_{4}\\lnot x_{5}$ 为 $1$，所以 $C_{23}=1$。这对任何 $x_2$ 都成立。这给出了两个关于 $(x_2, x_4, x_5)$ 的解：$(0,1,0)$ 和 $(1,1,0)$。\n- 如果此项为 $0$，我们需要 $\\lnot x_{2}\\lnot x_{4}x_{5}=1$。这要求 $x_2=0, x_4=0, x_5=1$。这给出一个解：$(0,0,1)$。\n总共有 $2+1=3$ 个满足条件的 $(x_2, x_4, x_5)$ 赋值：$(0,1,0)$、$(1,1,0)$ 和 $(0,0,1)$。\n\n现在我们必须对上述每种情况满足条件 $C_1 = (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1$。$C_1$ 依赖于 $x_1, x_2, x_3$。关于 $(x_1, x_3)$ 的解的数量取决于 $x_2$ 的值。\n- 如果 $x_2 = 0$：$C_1$ 变为 $(x_1 \\land 0) \\lor (\\lnot x_1 \\land x_3) = \\lnot x_1 \\land x_3 = 1$。这只有一个解：$(x_1, x_3) = (0,1)$。\n- 如果 $x_2 = 1$：$C_1$ 变为 $(x_1 \\land 1) \\lor (\\lnot x_1 \\land x_3) = x_1 \\lor (\\lnot x_1 \\land x_3)$。使用恒等式 $A \\lor (\\lnot A \\land B) = A \\lor B$，这等于 $x_1 \\lor x_3 = 1$。这有三个关于 $(x_1, x_3)$ 的解：$(0,1)$、$(1,0)$ 和 $(1,1)$。\n\n我们现在可以通过对三个有效的 $(x_2, x_4, x_5)$ 元组的贡献求和来找到总数：\n1.  对于 $(x_2, x_4, x_5) = (0,1,0)$：这里 $x_2=0$。满足 $C_1$ 的方式有 $1$ 种。总向量数：$1$。\n2.  对于 $(x_2, x_4, x_5) = (1,1,0)$：这里 $x_2=1$。满足 $C_1$ 的方式有 $3$ 种。总向量数：$3$。\n3.  对于 $(x_2, x_4, x_5) = (0,0,1)$：这里 $x_2=0$。满足 $C_1$ 的方式有 $1$ 种。总向量数：$1$。\n\n不同主输入赋值的总数是这些计数的总和：$1 + 3 + 1 = 5$。\n\n这五个测试向量是：\n1.  $(x_1,x_3)=(0,1)$ 且 $(x_2,x_4,x_5)=(0,1,0) \\implies (0,0,1,1,0)$\n2.  $(x_1,x_3)=(0,1)$ 且 $(x_2,x_4,x_5)=(1,1,0) \\implies (0,1,1,1,0)$\n3.  $(x_1,x_3)=(1,0)$ 且 $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,0,1,0)$\n4.  $(x_1,x_3)=(1,1)$ 且 $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,1,1,0)$\n5.  $(x_1,x_3)=(0,1)$ 且 $(x_2,x_4,x_5)=(0,0,1) \\implies (0,0,1,0,1)$\n\n最终计数为5。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "任何工业级ATPG和故障诊断工具的核心都是一个高性能的故障仿真器。这最后一个实践练习  将带您从理论分析走向实际编码。您的任务是编写一个程序，通过模拟正常电路和故障电路的行为来验证测试向量的有效性，这将巩固您对拓扑排序、处理未指定值“X”等关键概念的理解。",
            "id": "4256830",
            "problem": "给定一个有向无环组合逻辑网络模型和一组用于验证的自动测试模式生成 (ATPG) 模式。自动测试模式生成 (ATPG) 模式可能包含未指定的位，这些位由未知符号表示，我们将其记为 $X$。该逻辑网络由集合 $\\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$ 中的逻辑门组成，这些逻辑门连接成一个有向无环图。主输入 (PI) 是源节点，主输出 (PO) 是汇节点。单一固定型 (SSA) 故障被建模为将一条逻辑线网永久强制为 $0$ (固定于0) 或 $1$ (固定于1)。\n\n基本原理：\n- 布尔电路通过沿有向无环图组合基本门函数 $g \\in \\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$ 来计算一个布尔函数 $F: \\{0,1\\}^{n} \\to \\{0,1\\}^{m}$。\n- 在具有固定值 $s \\in \\{0,1\\}$ 的线网 $f$ 上的一个 SSA 故障会产生一个修改后的布尔函数 $F_{f=s}$，其中无论上游输入如何，线网 $f$ 的值始终被强制为 $s$。\n- 一个测试模式能检测到一个 SSA 故障，当且仅当存在至少一个主输出 $y \\in \\mathrm{PO}$，使得对于相同的输入赋值 $\\mathbf{u} \\in \\{0,1\\}^{n}$，正常电路的输出值 $F(\\mathbf{u})[y]$ 与故障电路的输出值 $F_{f=s}(\\mathbf{u})[y]$ 不同。\n\n您必须实现一个模式验证和故障仿真流程，该流程利用这些原理来确定，对于每个测试用例，所提供的 ATPG 模式是否能检测到指定的 SSA 故障。如果 ATPG 模式的某些主输入包含 $X$ 条目，则将 $X$ 视作一个未指定的输入位，并根据存在性补全来验证检测：如果存在任何将每个 $X$ 赋值为 $0$ 或 $1$ 的组合，使得检测标准成立（即，任何补全都会在正常电路和故障电路之间产生主输出不匹配），则该模式被认为是可检测的。您的算法必须：\n- 为逻辑门构建一个拓扑评估顺序，以确保在评估每个逻辑门的输出之前，其输入都已可用。\n- 通过按拓扑顺序将 PI 值在逻辑门中传播，来评估正常电路的输出值。\n- 在传播 PI 值的同时，在故障线网 $f$ 定义的位置（如果 $f$ 是主输入，则在 PI 处）将其强制为固定值 $s$，从而评估故障电路的输出值。\n- 对于带有 $X$ 的模式，枚举 $X$ 位置的所有二进制补全，并对每个补全应用检测检查；如果任何一个补全能够检测到故障，则报告检测结果为真。\n\n数学形式化：\n- 设 $\\mathcal{N}$ 表示电路中线网的集合，$\\mathrm{PI} \\subset \\mathcal{N}$ 表示主输入，$\\mathrm{PO} \\subset \\mathcal{N}$ 表示主输出。每个逻辑门是一个元组 $(\\text{type}, \\text{inputs}, \\text{output})$，其中 $\\text{type} \\in \\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$，$\\text{inputs} \\subset \\mathcal{N}$，且 $\\text{output} \\in \\mathcal{N}$。\n- 定义由 PI 赋值 $\\mathbf{u}$ 导出的正常估值函数 $V: \\mathcal{N} \\to \\{0,1\\}$，该函数通过使用布尔门语义进行拓扑评估：$\\mathrm{AND}(x_1,x_2)=x_1 \\wedge x_2$, $\\mathrm{OR}(x_1,x_2)=x_1 \\vee x_2$, $\\mathrm{NOT}(x)=\\neg x$。\n- 为相同的 $\\mathbf{u}$ 定义故障估值函数 $V_{f=s}: \\mathcal{N} \\to \\{0,1\\}$，方法是在任何下游评估之前或之时强制 $V_{f=s}(f)=s$，并在其他情况下使用相同的门语义。\n- 对于一个给定的补全 $\\mathbf{u}$，检测标准为 $\\exists y \\in \\mathrm{PO}: V(y) \\neq V_{f=s}(y)$，而对于带有 $X$ 的模式，如果存在一个与指定的非 $X$ 位一致的 $\\mathbf{u} \\in \\{0,1\\}^{n}$ 使得该标准成立，则该模式是可检测的。\n\n输入规范是程序内部的。请使用以下电路、故障和模式的测试套件：\n\n- 测试用例 1 (正常路径)：电路 $C_1$，其中 $\\mathrm{PI}=\\{a,b\\}$，逻辑门为 $\\{(\\mathrm{AND}, [a,b], n_1)\\}$，$\\mathrm{PO}=\\{n_1\\}$。故障为 $(f=n_1, s=0)$。模式为 $a=1$, $b=1$。预期结果：检测为真。\n- 测试用例 2 (掩蔽)：电路 $C_2$，其中 $\\mathrm{PI}=\\{a,b,c\\}$，逻辑门为 $\\{(\\mathrm{AND}, [a,b], n_1), (\\mathrm{OR}, [n_1,c], y)\\}$，$\\mathrm{PO}=\\{y\\}$。故障为 $(f=n_1, s=0)$。模式为 $a=1$, $b=1$, $c=1$。预期结果：由于 $\\mathrm{OR}$ 门的控制输入导致输出掩蔽，检测为假。\n- 测试用例 3 (未激活)：电路 $C_1$ 如上。故障为 $(f=n_1, s=0)$。模式为 $a=0$, $b=1$。预期结果：检测为假，因为故障未被激活（在正常电路中 $n_1$ 已经是 $0$）。\n- 测试用例 4 (存在性 $X$ 补全可检测)：电路 $C_2$ 如上。故障为 $(f=n_1, s=0)$。模式为 $a=1$, $b=X$, $c=0$。预期结果：检测为真，因为补全 $b=1$ 可以检测到故障，而 $b=0$ 则不能。\n- 测试用例 5 (主输入上的故障)：电路 $C_3$，其中 $\\mathrm{PI}=\\{a\\}$，逻辑门为 $\\{(\\mathrm{NOT}, [a], y)\\}$，$\\mathrm{PO}=\\{y\\}$。故障为 $(f=a, s=1)$。模式为 $a=0$。预期结果：检测为真。\n\n您的程序必须实现所述的验证和仿真流程，并为上述测试套件生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：$[\\text{result}_1,\\text{result}_2,\\dots]$），每个结果都是一个布尔值，指示该模式是否在其电路中检测到指定的故障。不涉及物理单位或角度。程序必须是自包含的，不接受任何外部输入，并严格遵循输出格式。",
            "solution": "该解决方案通过遵循以下原则性的、分步的程序来实现：\n\n1.  **电路表示与拓扑排序**：\n    组合逻辑网络是一个有向无环图 (DAG)，其中节点代表逻辑信号（线网），有向边代表通过逻辑门的数据流。为了模拟电路，我们必须按照一个顺序来评估逻辑门，该顺序能确保在计算一个门的输出值之前，其所有输入值都已知。这通过对电路的线网执行拓扑排序来实现。该算法从主输入 ($\\mathrm{PI}$) 开始，它们在电路内部没有依赖关系，然后逐层遍历网络。\n\n    设 $\\mathcal{N}$ 是所有线网的集合。拓扑排序会产生一个有序的线网列表 $(v_1, v_2, \\dots, v_{|\\mathcal{N}|})$，使得对于任何具有输入 $\\{i_1, \\dots, i_k\\}$ 和输出 $o$ 的门，所有输入都在排序列表中出现在输出之前。这个顺序保证了正确的信号传播模拟。我们可以使用 Kahn 算法来实现这一点，该算法系统地处理入度为 $0$ 的节点。\n\n2.  **全指定输入模式的逻辑模拟**：\n    给定一个完整的输入向量 $\\mathbf{u} \\in \\{0,1\\}^{n}$，其中 $n=|\\mathrm{PI}|$，我们通过在确定的拓扑顺序中将输入值传播通过逻辑门来模拟电路的行为。这个过程执行两次：一次针对“正常”（无故障）电路，一次针对“故障”电路。\n\n    *   **正常电路模拟**：我们为所有线网计算一个估值函数 $V: \\mathcal{N} \\to \\{0,1\\}$。\n        - 对于每个主输入 $p_i \\in \\mathrm{PI}$，其值由输入向量设定：$V(p_i) = u_i$。\n        - 对于拓扑顺序中的每个后续线网 $o$，它是具有输入 $\\{i_1, \\dots, i_k\\}$ 的门 $g$ 的输出，其值是通过将门的布尔函数应用于其输入的已计算值来计算的：$V(o) = g(V(i_1), \\dots, V(i_k))$。门函数是标准的：对于 $\\mathrm{AND}$ 门，$V(o) = V(i_1) \\wedge V(i_2)$；对于 $\\mathrm{OR}$ 门，$V(o) = V(i_1) \\vee V(i_2)$；对于 $\\mathrm{NOT}$ 门，$V(o) = \\neg V(i_1)$。\n\n    *   **故障电路模拟**：我们对具有固定值 $s \\in \\{0,1\\}$ 的线网 $f$ 上的单一固定型故障进行建模。我们计算一个故障估值函数 $V_{f=s}: \\mathcal{N} \\to \\{0,1\\}$。\n        - 模拟过程与正常电路模拟完全相同，只有一个关键例外：当在拓扑评估顺序中遇到故障线网 $f$ 时，其值被强制设置为固定值 $s$，即 $V_{f=s}(f) = s$。然后，该值将用于所有下游门的评估。如果故障发生在主输入上，其值将在模拟的最开始被覆盖。\n\n3.  **故障检测标准**：\n    一个测试模式 $\\mathbf{u}$ 成功检测到故障 $(f, s)$，当且仅当对于至少一个主输出 ($\\mathrm{PO}$)，正常电路的输出与故障电路的输出不同。形式上，如果满足以下条件，则发生检测：\n    $$ \\exists y \\in \\mathrm{PO} \\text{ such that } V(y) \\neq V_{f=s}(y) $$\n    这要求测试模式同时满足两个条件：\n    - **故障激活**：在正常电路中，该模式必须在故障点 $f$ 上产生一个与固定值相反的值。即，$V(f) \\neq s$。如果不满足此条件，故障对电路状态没有影响。\n    - **故障传播**：故障的影响（线网 $f$ 上的差异）必须通过下游逻辑传播到至少一个主输出。如果故障效应被逻辑掩蔽（例如，如果 $\\mathrm{AND}$ 门的一个输入是 $0$，则另一个输入固定于0的故障将被掩蔽），它将是不可观察的。\n\n4.  **处理未指定输入 ($X$)**：\n    ATPG 模式可能包含用 $X$ 表示的未指定输入。问题规定检测在*存在性补全*下成立。这意味着如果存在*任何*将二进制值（$0$ 或 $1$）赋给 $X$ 输入的赋值，满足检测标准，那么该模式就被认为可以检测到故障。\n\n    为了实现这一点，我们枚举了该模式所有可能的二进制补全。如果一个模式有 $k$ 个输入被指定为 $X$，则存在 $2^k$ 个可能的完整输入向量。对于这 $2^k$ 个向量中的每一个，我们都执行完整的正常电路和故障电路模拟，并检查检测标准。只要有一个补全导致检测成功，整个模式就被验证为可检测故障，并且该测试用例的搜索可以终止。如果所有 $2^k$ 个补全都未能检测到故障，则该模式被声明为不可检测。\n\n**示例演练**\n\n让我们用测试用例 4 来说明这个过程：\n- **电路**：$C_2$，其中 $\\mathrm{PI}=\\{a,b,c\\}$，逻辑门为 $\\{(\\mathrm{AND}, [a,b], n_1), (\\mathrm{OR}, [n_1,c], y)\\}$，$\\mathrm{PO}=\\{y\\}$。\n- **故障**：$(f=n_1, s=0)$。\n- **模式**：$(a=1, b=X, c=0)$。\n\n该模式有一个未指定的输入 $b=X$。我们必须测试两种补全：$(b=0)$ 和 $(b=1)$。\n\n**补全 1：$b=0$。输入向量为 $(a=1, b=0, c=0)$。**\n- **正常电路模拟**：\n    - $V(a)=1, V(b)=0, V(c)=0$。\n    - $V(n_1) = \\mathrm{AND}(V(a), V(b)) = \\mathrm{AND}(1, 0) = 0$。\n    - $V(y) = \\mathrm{OR}(V(n_1), V(c)) = \\mathrm{OR}(0, 0) = 0$。\n    - 主输出值：$V(y)=0$。\n- **故障电路模拟** (故障 $n_1$ 固定于$0$)：\n    - $V_{f=s}(a)=1, V_{f=s}(b)=0, V_{f=s}(c)=0$。\n    - $n_1$ 的值被强制：$V_{f=s}(n_1) = 0$。\n    - $V_{f=s}(y) = \\mathrm{OR}(V_{f=s}(n_1), V_{f=s}(c)) = \\mathrm{OR}(0, 0) = 0$。\n    - 主输出值：$V_{f=s}(y)=0$。\n- **检测检查**：$V(y) = 0$ 且 $V_{f=s}(y) = 0$。它们相等。此补全不检测该故障。\n\n**补全 2：$b=1$。输入向量为 $(a=1, b=1, c=0)$。**\n- **正常电路模拟**：\n    - $V(a)=1, V(b)=1, V(c)=0$。\n    - $V(n_1) = \\mathrm{AND}(V(a), V(b)) = \\mathrm{AND}(1, 1) = 1$。（故障被激活）。\n    - $V(y) = \\mathrm{OR}(V(n_1), V(c)) = \\mathrm{OR}(1, 0) = 1$。（故障效应传播）。\n    - 主输出值：$V(y)=1$。\n- **故障电路模拟** (故障 $n_1$ 固定于$0$)：\n    - $V_{f=s}(a)=1, V_{f=s}(b)=1, V_{f=s}(c)=0$。\n    - $n_1$ 的值被强制：$V_{f=s}(n_1) = 0$。\n    - $V_{f=s}(y) = \\mathrm{OR}(V_{f=s}(n_1), V_{f=s}(c)) = \\mathrm{OR}(0, 0) = 0$。\n    - 主输出值：$V_{f=s}(y)=0$。\n- **检测检查**：$V(y) = 1$ 且 $V_{f=s}(y) = 0$。它们不相等。此补全检测到该故障。\n\n由于存在一个能够检测到故障的补全（即 $b=1$），因此模式 $(a=1, b=X, c=0)$ 被认为是一个可检测模式。此测试用例的结果为真。所提供的代码为所有指定的测试用例实现了这一完整流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    \n    # Test case definitions\n    # Each case: (circuit_dict, fault_tuple, pattern_dict)\n    test_cases = [\n        # Test case 1 (happy path)\n        (\n            {\n                'PI': ['a', 'b'], 'PO': ['n1'],\n                'gates': [('AND', ['a', 'b'], 'n1')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 1}\n        ),\n        # Test case 2 (masking)\n        (\n            {\n                'PI': ['a', 'b', 'c'], 'PO': ['y'],\n                'gates': [('AND', ['a', 'b'], 'n1'), ('OR', ['n1', 'c'], 'y')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 1, 'c': 1}\n        ),\n        # Test case 3 (no excitation)\n        (\n            {\n                'PI': ['a', 'b'], 'PO': ['n1'],\n                'gates': [('AND', ['a', 'b'], 'n1')],\n            },\n            ('n1', 0),\n            {'a': 0, 'b': 1}\n        ),\n        # Test case 4 (existential X completion detects)\n        (\n            {\n                'PI': ['a', 'b', 'c'], 'PO': ['y'],\n                'gates': [('AND', ['a', 'b'], 'n1'), ('OR', ['n1', 'c'], 'y')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 'X', 'c': 0}\n        ),\n        # Test case 5 (fault on primary input)\n        (\n            {\n                'PI': ['a'], 'PO': ['y'],\n                'gates': [('NOT', ['a'], 'y')],\n            },\n            ('a', 1),\n            {'a': 0}\n        )\n    ]\n\n    results = []\n    for circuit, fault, pattern in test_cases:\n        results.append(check_detection(circuit, fault, pattern))\n\n    # Format output as specified: [True,False,...]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\ndef topological_sort(circuit):\n    \"\"\"\n    Performs a topological sort of the circuit nets using Kahn's algorithm.\n    Returns an ordered list of nets for evaluation.\n    \"\"\"\n    in_degree = collections.defaultdict(int)\n    graph = collections.defaultdict(list)\n    all_nets = set(circuit['PI'])\n\n    for _, inputs, output in circuit['gates']:\n        all_nets.add(output)\n        for net in inputs:\n            all_nets.add(net)\n\n    # Build graph and in-degrees for output nets\n    for _, inputs, output in circuit['gates']:\n        in_degree[output] = len(inputs)\n        for input_net in inputs:\n            graph[input_net].append(output)\n\n    # Queue for nodes with in-degree 0 (only PIs initially)\n    queue = collections.deque([net for net in circuit['PI']])\n    \n    topo_order = []\n    while queue:\n        net = queue.popleft()\n        topo_order.append(net)\n        for neighbor in graph[net]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycles\n    gate_outputs = {g[2] for g in circuit['gates']}\n    # The order should contain PIs and all gate outputs\n    if len(topo_order) != len(circuit['PI']) + len(gate_outputs):\n         # This should not happen in a valid combinational circuit\n         raise ValueError(\"Cycle detected or disconnected graph\")\n         \n    return topo_order\n\ndef simulate(circuit, full_pattern, sorted_nets, fault=None):\n    \"\"\"\n    Simulates the circuit for a given full input pattern and an optional fault.\n    \"\"\"\n    net_values = {}\n    fault_net, fault_val = (None, None) if fault is None else fault\n\n    # Define gate logic\n    gate_logic = {\n        'AND': lambda inputs: int(all(inputs)),\n        'OR':  lambda inputs: int(any(inputs)),\n        'NOT': lambda inputs: int(not inputs[0])\n    }\n    \n    gate_map = {output: (op_type, inputs) for op_type, inputs, output in circuit['gates']}\n\n    for net in sorted_nets:\n        if net in circuit['PI']:\n            if net == fault_net:\n                net_values[net] = fault_val  # PI stuck-at fault\n            else:\n                net_values[net] = full_pattern[net]\n        else: # It's a gate output\n            if net == fault_net:\n                net_values[net] = fault_val  # Internal net stuck-at fault\n                continue\n            \n            op_type, inputs = gate_map[net]\n            input_values = [net_values[i] for i in inputs]\n            net_values[net] = gate_logic[op_type](input_values)\n\n    return net_values\n\ndef check_detection(circuit, fault, pattern):\n    \"\"\"\n    Checks if a pattern (potentially with 'X') detects a fault.\n    \"\"\"\n    x_inputs = [pi for pi, val in pattern.items() if val == 'X']\n    fixed_inputs = {pi: val for pi, val in pattern.items() if val != 'X'}\n    \n    num_x = len(x_inputs)\n    \n    # Generate all binary completions for 'X' inputs\n    completions = itertools.product([0, 1], repeat=num_x)\n\n    topo_order = topological_sort(circuit)\n    \n    for completion in completions:\n        current_pattern = fixed_inputs.copy()\n        for i, pi_name in enumerate(x_inputs):\n            current_pattern[pi_name] = completion[i]\n\n        # Simulate good and faulty circuits\n        good_vals = simulate(circuit, current_pattern, topo_order)\n        faulty_vals = simulate(circuit, current_pattern, topo_order, fault)\n        \n        # Check for detection at any Primary Output\n        detected = False\n        for po in circuit['PO']:\n            if good_vals.get(po) != faulty_vals.get(po):\n                detected = True\n                break\n        \n        if detected:\n            return True # Existential completion: one is enough\n\n    return False # No completion detected the fault\n\n# Run the solver\nsolve()\n```"
        }
    ]
}