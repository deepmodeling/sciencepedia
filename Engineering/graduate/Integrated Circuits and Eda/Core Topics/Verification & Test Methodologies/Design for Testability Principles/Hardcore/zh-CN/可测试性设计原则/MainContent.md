## 引言
随着[集成电路](@entry_id:265543)（IC）的规模和复杂性以前所未有的速度增长，确保每一颗出厂的芯片都能可靠工作，成为半导体行业面临的核心挑战。传统的外部测试方法在面对数十亿晶体管的现代[片上系统](@entry_id:1131845)（SoC）时，已显得力不从心，测试成本和时间急剧攀升。为了解决这一难题，可测试性设计（Design for Testability, DFT）应运而生，它不再将测试视为制造后的附加步骤，而是在设计之初就系统性地植入电路的可测试性。本文旨在为读者提供一个关于DFT原理的全面而深入的指南，填补从理论知识到实际应用的认知鸿沟。

本文将通过三个循序渐进的章节，带领读者全面掌握DFT。在“原理与机制”一章中，我们将深入探索DFT的基石，从定义缺陷语言的[故障模型](@entry_id:1124860)，到解决测试性挑战的[扫描设计](@entry_id:177301)与ATPG算法。接着，在“应用与跨学科关联”一章中，我们将视野扩展到真实世界的SoC，探讨[测试压缩](@entry_id:1132958)、BIST等高级架构，并揭示DFT如何与[物理设计](@entry_id:1129644)、硬件安全和良率提升等领域紧密相连。最后，“动手实践”部分将提供具体的练习，帮助读者将理论知识转化为解决实际问题的能力。

让我们首先从构建DFT大厦的基石——其基本原理与核心机制开始。

## 原理与机制

在可测试性设计（Design for Testability, DFT）领域，其核心目标是确保制造出的集成电路能够被高效、经济地测试，以筛除有缺陷的芯片。本章将深入探讨支撑现代DFT方法的根本原理与核心机制。我们将从缺陷的抽象表示——[故障模型](@entry_id:1124860)开始，进而分析测试的根本挑战，即控制性与可观测性。随后，我们将系统地阐述作为业界标准解决方案的[扫描设计](@entry_id:177301)技术，以及用于自动生成和评估测试向量的算法。最后，本章将讨论一系列高级议题，包括高速测试、内建自测试（BIST）以及测试过程中面临的功耗挑战，这些都是将理论应用于复杂现代芯片所必须面对的实际问题。

### 基本[故障模型](@entry_id:1124860)：缺陷的语言

物理缺陷（如金属连线中的断路或短路、晶体管缺陷等）在物理层面上千变万化，直接对它们进行建模和分析是极其复杂的。因此，DFT领域采用了一系列抽象的**[故障模型](@entry_id:1124860)**（Fault Models），将物理缺陷映射为逻辑或时序上的行为偏差。这些模型为测试生成和故障仿真提供了统一的语言和数学基础。

#### 静态[故障模型](@entry_id:1124860)

静态[故障模型](@entry_id:1124860)描述的是那些不依赖于电路工作速度，会导致电路在稳定状态下产生错误逻辑值的故障。

**[固定型故障](@entry_id:171196) (Stuck-at Fault, SAF)** 是最经典、最广泛使用的[故障模型](@entry_id:1124860)。它假设电路中某一信号线（或称节点）永久性地固定在逻辑“0”（**固定于0, stuck-at-0**）或逻辑“1”（**固定于1, stuck-at-1**）上，而不受其驱动源的影响。检测一个[固定型故障](@entry_id:171196)需要一个测试向量，该向量能够同时满足两个条件：**激活 (activation)**，即试图将故障节点驱动到其“好”值（与固定值相反的值）；以及**传播 (propagation)**，即将该节点上由于故障产生的逻辑差异（在好电路和坏电路之间）沿着一条或多条路径传播到一个可观测的主输出（Primary Output, PO）或扫描单元。其物理根源通常是与电源轨（$V_{DD}$ 或 $V_{SS}$）的硬短路，或者是一个完全失效的晶体管。

**[桥接故障](@entry_id:169089) (Bridging Fault, BF)** 指两条通常不应相连的信号线之间形成了意外的电阻性连接。当这两条线被驱动到相反的逻辑值（一条为0，一条为1）时，会产生电流竞争。最终的逻辑行为取决于桥接电阻的大小以及两个驱动门的[上拉网络](@entry_id:166914)（PMOS）和[下拉网络](@entry_id:174150)（NMOS）的相对强度。如果下拉网络更强，往往会把高电平拉低，形成所谓的“线与”（Wired-AND）行为；反之，则可能形成“线或”（Wired-OR）行为。因此，其行为并非固定不变。检测[桥接故障](@entry_id:169089)通常需要一个测试向量，它能将被桥接的两条线驱动到相反的逻辑值，并观测其中一条或两条线上的错误结果。

**开路[固定型故障](@entry_id:171196) (Stuck-open Fault, SOF)** 特指在[静态CMOS逻辑](@entry_id:1132311)门内部，由于某个晶体管路径发生断路（例如，接触孔缺失、多晶硅断裂）而导致的故障。当输入试图激活包含该断路晶体管的路径时（例如，激活一个断路的[下拉网络](@entry_id:174150)），输出节点会与 $V_{DD}$ 和 $V_{SS}$ 都断开连接，处于**浮空状态**。此时，输出节点的逻辑值将由其[寄生电容](@entry_id:270891)上先前状态所存储的电荷决定，表现出一种“[记忆效应](@entry_id:266709)”。因此，检测开路[固定型故障](@entry_id:171196)需要一个**两周期测试序列**：第一个向量用于对输出节点进行预充电（或放电）到一个初始状态，第二个向量则试图通过故障路径将其翻转到相反状态。如果在第二个周期结束时，输出值未能成功翻转，则检测到故障。

#### 动态（时序）[故障模型](@entry_id:1124860)

随着电路工作频率的不断提升，仅仅保证逻辑功能正确已不足够。时序[故障模型](@entry_id:1124860)用于描述那些不改变电路的[稳态](@entry_id:139253)逻辑功能，但会延迟信号传播，从而可能违反时序约束的缺陷。

**转换延迟故障 (Transition-Delay Fault, TDF)** 模型假设电路中的某个特定节点存在**局部缺陷**，导致该节点从0到1的上升转换（slow-to-rise）或从1到0的下降转换（slow-to-fall）过慢。这种故障是**与节点相关的**，而非与特定路径相关。检测TDF同样需要一个两周期的、在电路额定速度（at-speed）下施加的测试序列：第一个向量建立初始值，第二个向量在该节点发起一次转换。重要的是，只要能将该转换的效果沿着**任意一条**路径传播到可观测点，就可以检测到此故障。其物理原因通常是电阻性接触孔、[晶体管老化](@entry_id:1133332)（如[负偏压温度不稳定性](@entry_id:1128469)，NBTI）等局部参数退化。

**[路径延迟故障](@entry_id:172397) (Path-delay Fault, PDF)** 模型关注的是信号沿一条**特定结构路径**从起点到终点的**累积延迟**。即使路径上的每一个门都在其标称延迟范围内，这些微小延迟的累积也可能使得总延迟超过[时钟周期](@entry_id:165839)，导致[时序违规](@entry_id:177649)。这种故障是**与路径相关的**，其根源通常是沿路径分布的工艺偏差、电源电压跌落或温度梯度等。检测PDF同样需要一个高速的两周期测试序列，但与TDF不同的是，该测试必须**精确地敏化 (sensitize)** 所要测试的目标路径。一个“鲁棒”的测试会通过将路径上各门的所有旁路输入（off-path inputs）设置为非控制值，来确保信号转换只沿目标路径传播。

### 测试性挑战：控制性与可观测性

明确了要寻找的[故障模型](@entry_id:1124860)后，下一个问题是在庞大而复杂的[时序电路](@entry_id:174704)中，如何有效地激活并观测这些故障。这引出了测试领域的两个核心概念：**控制性 (Controllability)** 和**[可观测性](@entry_id:152062) (Observability)**。

- **控制性**是指通过操控电路的主输入（Primary Inputs, PIs），将电路内部任意一个节点设置为特定逻辑值（0或1）的难易程度。
- **[可观测性](@entry_id:152062)**是指当一个内部节点的逻辑值发生变化时，在电路的主输出（Primary Outputs, POs）上能够观察到这一变化的难易程度。

在纯粹的[时序电路](@entry_id:174704)中，控制和观测内部节点是一项艰巨的任务。例如，要控制一个深埋在流水线中的节点，可能需要施加一长串输入向量，以驱动整个有限状态机进入一个特定的状态。同样，要观测一个节点，也可能需要多个时钟周期，才能将故障效应一步步地传递到主输出。这种对状态可达性和多周期传播的依赖，极大地增加了测试的复杂性。

为了量化评估电路的测试难易程度，研究人员提出了多种测试性分析方法。

**SCOAP (Sandia Controllability/Observability Analysis Program)** 是一种经典的结构化测试性分析方法。它为每个节点计算一组整数值的“成本”：$CC0$（0-控制性成本）、$CC1$（1-控制性成本）和$CO$（[可观测性](@entry_id:152062)成本）。这些成本代表了设置或观测该节点所需的“最小结构化努力”。成本从PI（成本为1）和PO（成本为0）开始，根据门级规则递归计算。例如，对于一个输出为 $y$，输入为 $a, b$ 的[与门](@entry_id:166291)：
$$ CC1(y) = CC1(a) + CC1(b) + 1 $$
$$ CC0(y) = \min(CC0(a), CC0(b)) + 1 $$
$$ CO(a) = CO(y) + CC1(b) + 1 $$
SCOAP的优点是计算简单且独立于输入信号的概率分布。但其主要局限在于无法精确处理**重聚扇出 (reconvergent fanout)** 结构。在上述 $CC1(y)$ 的计算中，如果 $a$ 和 $b$ 有共同的信号源，那么设置该源的成本会被重复计算，导致成本估算过于悲观。此外，SCOAP是纯[静态分析](@entry_id:755368)，不考虑任何时序信息。

**概率测试性度量**是另一类方法，它计算节点取值为1的概率（$C_1(n)$）以及节点可被观测的概率（$O(n)$）。这类方法依赖于对PIs概率分布的假设（例如，均匀分布），并通过假设门输入信号相互独立来传播概率。例如，对于上述[与门](@entry_id:166291)，若输入独立，则 $C_1(y) = C_1(a) \cdot C_1(b)$。与SCOA[P类](@entry_id:262479)似，其主要弱点也是在处理重聚扇出时，信号独立性假设被打破，导致计算不准确。

### [扫描设计](@entry_id:177301)：系统性的测试性解决方案

面对[时序电路](@entry_id:174704)测试的巨大挑战，业界开发出了**[扫描设计](@entry_id:177301) (Scan Design)** 技术，这已成为现代DFT的基石。[扫描设计](@entry_id:177301)的核心思想是通过引入一种特殊的“测试模式”，极大地提升对内部状态（存储在触发器中）的控制性和可观测性。

实现方式是在设计中将标准的触发器替换为**扫描单元 (Scan Cell)**，通常是一个在数据输入端带有一个2输入多路选择器（MUX）的[D触发器](@entry_id:171740)。该MUX由一个全局的**扫描使能 (Scan Enable, SE)** 信号控制。
- 当 $SE=0$（功能模式）时，触发器从其正常的功能数据输入端获取数据。
- 当 $SE=1$（扫描模式）时，触发器从前一个扫描单元的输出获取数据。

所有的扫描单元被连接成一条或多条**[扫描链](@entry_id:171661) (Scan Chain)**，形成一个巨大的[移位寄存器](@entry_id:754780)。测试过程通常分为三个阶段：
1.  **扫描移入 (Scan-In)**：置位 $SE=1$，通过扫描输入（Scan In, SI）端口，将一个预先计算好的测试状态向量串行地移入扫描链。
2.  **捕获 (Capture)**：复位 $SE=0$，电路回到功能模式。施加一个主输入向量，并发出一个时钟脉冲。组合逻辑根据当前的（扫描移入的）状态和主输入计算出下一个状态，该结果被“捕获”到触发器中。
3.  **扫描移出 (Scan-Out)**：再次置位 $SE=1$，将被捕获的状态通过扫描输出（Scan Out, SO）端口串行地移出，同时可以移入下一个测试向量的初始状态。

[扫描设计](@entry_id:177301)的革命性在于，它将一个困难的**序贯测试问题**转化为了一个相对简单的**组合测试问题**。对于自动测试[向量生成](@entry_id:152883)（ATPG）工具而言，在捕获周期，扫描链中的触发器输出被视为**伪主输入 (Pseudo-Primary Inputs, PPIs)**，因为它们的值可以被任意设定；触发器的输入则被视为**伪主输出 (Pseudo-Primary Outputs, PPOs)**，因为它们捕获的值可以被无障碍地观测到。这彻底摆脱了对状态可达性的依赖，极大地简化了测试生成。

根据扫描单元的覆盖范围，[扫描设计](@entry_id:177301)可分为：
- **全扫描 (Full-Scan)**：设计中所有的触发器都被转换为扫描单元并连入扫描链。这确保了对所有状态的完[全控制](@entry_id:275827)和观测，使得可以使用纯组合ATPG算法。
- **部分扫描 (Partial-Scan)**：只将一部分[触发器转换](@entry_id:177244)为扫描单元。其目标通常是至少打破电路中所有的反馈环路，从而简化测试生成。然而，如果未被扫描的触发器在测试过程中不能被置于已知状态，那么测试生成仍然需要复杂的序贯ATPG算法（如时域扩展法）。

为了保证扫描测试的可靠性，设计必须遵守一系列“DFT规则”，例如：必须能在测试模式下禁用所有异步置位/复位信号；必须避免总线竞争（tri-state contention）；对于跨越不同时钟域的信号路径，必须使用**锁存闩锁 (lock-up latch)** 等结构来隔离，以防止在捕获周期产生时序问题。 

### 生成与评估测试向量

在具备[扫描设计](@entry_id:177301)的基础上，接下来的任务是生成有效的测试向量并评估其质量。

#### [自动测试向量生成 (ATPG)](@entry_id:174265)

ATPG算法的目标是为故障列表中的每一个故障，自动地寻找一个测试向量。一个成功的测试向量必须能同时激活故障并将其效应传播到可观测点。ATPG的本质是一个在巨大输入空间中的约束[搜索问题](@entry_id:270436)。

经典的ATPG算法经历了重要的演进：
- **D算法 (D-algorithm)**：作为早期的里程碑，D算法首次引入了**五值逻辑**（$\{0, 1, X, D, \overline{D}\}$），其中 $D$ 代表“好电路为1，坏电路为0”，$\overline{D}$ 则相反。算法通过传播 $D$ 或 $\overline{D}$ 来敏化故障路径。其[决策空间](@entry_id:1123459)是电路的所有内部节点，当做出一个错误的决策后，往往需要大量的回溯（backtracking），尤其是在重聚扇出结构中效率低下。
- **PODEM (Path-Oriented Decision Making)**：PODEM针对D算法的低效进行了革命性改进。其关键思想是将[决策空间](@entry_id:1123459)**仅限于主输入（PIs）**。算法首先设定一个目标（如，将某节点设为1），然后通过**回溯 (backtrace)** 结构找到一个可以影响该目标的PI，并对该PI赋值。接着，通过**前向蕴含 (forward implication)** 计算该赋值在整个电路中的影响。这种“目标->回溯->决策->蕴含”的循环，极大地减少了无效搜索和回溯。
- **FAN (Fanout-Oriented test generation)**：FAN算法在PODEM的基础上进一步优化，引入了更智能的决策策略。例如，它采用**多重回溯**来更有效地满足目标，并特别关注**[扇出](@entry_id:173211)干点 (fanout stem)** 的决策，优先处理约束较少的节点。它还利用**支配点 (dominator)** 等结构信息来指导搜索，从而在复杂的电路中比PODEM更高效。

#### 故障仿真 (Fault Simulation)

故障仿真的任务是：给定一个电路和一组测试向量，确定这组向量能够检测出故障列表中的哪些故障。它是衡量[测试集](@entry_id:637546)质量的关键步骤。

主要的三种故障仿真算法是：
- **并行故障仿真 (Parallel Fault Simulation)**：该技术利用计算机字（word）的位并行性。一个 $W$ 位的字可以同时表示一个节点在好电路和 $W-1$ 个不同故障电路中的逻辑值。[逻辑门](@entry_id:178011)的运算（如AND、OR）可以通过单条[位运算](@entry_id:172125)指令（``, `|`）完成，从而并行地模拟多个电路。这种方法对于[组合电路](@entry_id:174695)的批量仿真非常高效。
- **演绎故障仿真 (Deductive Fault Simulation)**：此方法首先进行一次无故障的“好电路”仿真。然后，对于每个节点，它通过“演绎”的方式计算出能使其逻辑值翻转的故障集合（故障列表）。故障列表在电路中逐级传播，其传播规则由门的逻辑功能和输入值决定。例如，对于一个输入为 $a=0, b=1$ 的与门，其输出受 $a$ 控制，因此输出端的故障列表将包含 $a$ 的故障列表以及输出自身的 stuck-at-1 故障。
- **并发故障仿真 (Concurrent Fault Simulation)**：这是目前最主流、最高效的方法。其核心思想是“事件驱动的差异跟踪”。它完整地模拟好电路，而对于每个故障，只在坏电路的行为与好电路**产生[分歧](@entry_id:193119)**的地方进行显式模拟。它为每个节点维护一个列表，只包含那些导致该节点值发生变化的故障。当故障效应被掩盖，坏电路与好电路的值重新一致时，该故障就从节点的活动列表中移除。由于在任何时刻只有一小部分故障是“活动的”，这种方法极大地节省了计算和内存资源，尤其适用于大型[时序电路](@entry_id:174704)的仿真。

#### 衡量测试质量

测试质量由一系列覆盖率指标来衡量，它们之间存在层次关系：
- **测试覆盖率 (Test Coverage)**：衡量测试向量对电路**结构或行为的激活程度**。例如，扫描翻转覆盖率（scan toggle coverage）衡量有多少比例的节点在测试过程中至少翻转过一次。它反映了测试的“活跃度”，但并不直接等同于[故障检测](@entry_id:270968)能力。
- **[故障覆盖率](@entry_id:170456) (Fault Coverage)**：这是DFT流程中最核心的指标。它定义为被测试集检测到的、特定**[故障模型](@entry_id:1124860)**下的故障数量，占该模型总故障数量的比例。例如，99%的[固定型故障](@entry_id:171196)覆盖率意味着[测试集](@entry_id:637546)能够检测出99%的潜在[固定型故障](@entry_id:171196)。
- **缺陷覆盖率 (Defect Coverage, $C_{\delta}$)**：这是与最终产品质量最直接相关的指标。它估算的是一个随机出现的**物理缺陷**能被[测试集](@entry_id:637546)检测到的概率。由于物理缺陷的真实分布未知，缺陷覆盖率通常通过对多种[故障模型](@entry_id:1124860)的覆盖率进行加权平均来估算。权重为每种物理缺陷类型的先验发生概率。公式为：
$$ C_{\delta} = \sum_{i} \pi_i C_{f_i} $$
其中 $\pi_i$ 是第 $i$ 类缺陷的发生概率，而 $C_{f_i}$ 是对应的[故障模型](@entry_id:1124860)覆盖率。

这些覆盖率指标最终决定了出厂产品的质量，通常用 **DPPM (Defective Parts Per Million)**，即每百万出货产品中的次品数来衡量。测试[逃逸率](@entry_id:199818)（Test Escape Rate, TER），即一个有缺陷的芯片通过了测试的概率，可以由缺陷覆盖率 $C_{\delta}$ 和初始芯片缺陷率 $p$ 计算得出。一个简化的近似公式是 $TER \approx p(1 - C_{\delta})$。例如，如果初始缺陷率为2%（$p=0.02$），缺陷覆盖率为94%（$C_{\delta}=0.94$），那么测试[逃逸率](@entry_id:199818)约为 $0.02 \times (1 - 0.94) = 0.0012$，相应的DPPM约为1200。更精确的计算需要考虑测试通过的总概率，其结果约为1223 DPPM。

### 高级议题与实践挑战

将DFT原理应用于真实的SoC设计时，会遇到一系列更复杂的挑战。

#### 高速测试与延迟故障

为了检测前述的转换延迟故障（TDF）和[路径延迟故障](@entry_id:172397)（PDF），测试必须在芯片的额定工作速度下进行，并且需要施加两周期测试向量（一个初始化向量 $V_1$ 和一个发射向量 $V_2$）。在[扫描设计](@entry_id:177301)中，主要有两种方法来生成这个高速的两[周期序列](@entry_id:159194)：**[移位](@entry_id:145848)发射 (Launch-on-Shift, LOS)** 和 **捕获发射 (Launch-on-Capture, LOC)**。

- **[移位](@entry_id:145848)发射 (LOS)**：初始化向量 $V_1$ 被移入扫描链。$V_2$ 则通过对 $V_1$ 进行最后一次**移位操作**来生成。即，最后一个扫描时钟脉冲（此时 $SE=1$）既完成了[移位](@entry_id:145848)，也“发射”了转换。随后，SE信号必须在下一个功能时钟到来之前快速切换到0，以完成“捕获”。LOS的优点是 $V_1$ 和 $V_2$ 之间的关联性很小，ATPG可以生成更多样化的测试对，从而可能获得更高的[故障覆盖率](@entry_id:170456)。其主要缺点是对SE信号的分布和时序要求极为苛刻，很容易因时序竞争而导致错误的测试结果。
- **捕获发射 (LOC)**：初始化向量 $V_1$ 被移入后，首先将SE信号切换到0，使电路进入功能模式。然后，施加**第一个功能时钟脉冲**，电路根据 $V_1$ 和主输入，功能性地计算出下一个状态，这个状态作为发射向量 $V_2$。紧接着，**第二个功能时钟脉冲**在额定延迟后到来，捕获 $V_2$ 在[组合逻辑](@entry_id:265083)中传播的结果。LOC的优点是SE信号在高速测试期间保持稳定，避免了LOS中的时序风险。其缺点是 $V_2$ 是 $V_1$ 的函数（$V_2 = \text{function}(V_1)$），这种固有的功能相关性限制了可生成的测试对，可能导致对某些特定路径的延迟故障无法测试，从而覆盖率较低。

#### 内建自测试 (BIST)

**内建自测试 (BIST)** 是一种将测试功能直接集成到芯片内部的技术，旨在减少对昂贵外部测试设备（ATE）的依赖。**[逻辑内建自测试](@entry_id:1127433) (Logic BIST, LBIST)** 是其中应用于逻辑电路的一种。一个典型的LBIST架构包括：
- **伪随机[向量生成](@entry_id:152883)器 (PRPG)**：通常由一个**[线性反馈移位寄存器 (LFSR)](@entry_id:170942)** 实现，它能产生确定性但统计特性良好的伪随机测试向量。
- **相位选择器 (Phase Shifter)**：由[异或门](@entry_id:162892)构成的线性网络，用于将PRPG的少量输出进行线性组合和[时移](@entry_id:261541)，以生成大量**去相关**的测试流，驱动多条扫描链。
- **多输入特征寄存器 (MISR)**：一个并行的LFSR，用于将多条[扫描链](@entry_id:171661)的输出响应进行**压缩**，最终形成一个简短的“特征签名 (signature)”。

测试结束后，只需将MISR中的最终特征签名与预期的“黄金签名”进行比较即可判断通过/失败。LBIST的优势在于能以极高的速度施加海量测试向量，有效检测“随机向量易检”的故障。其主要挑战包括：
- **覆盖率饱和**：对于需要特定输入组合才能检测的“随机向量难检”故障，LBIST的效率很低，导致[故障覆盖率](@entry_id:170456)在达到一定水平后难以再提升。
- **混叠 (Aliasing)**：由于MISR是[有损压缩](@entry_id:267247)，一个错误的响应序列有可能碰巧产生与正确响应相同的“黄金签名”，从而掩盖了故障。对于一个 $n$ 位的MISR，其[混叠](@entry_id:146322)概率约为 $2^{-n}$。
- **诊断困难**：一个错误的签名只能表明电路出了问题，但由于时域和空域上的信息都被压缩，很难定位到具体的故障位置。

#### 测试功耗问题

测试模式下的功耗往往远高于正常功能模式，这带来了严峻的挑战。测试功耗问题主要分为两类：

**扫描移位功耗**：在长达数百万周期的扫描移位过程中，所有扫描链同时翻转，导致**平均功耗**显著升高。这种持续的高功耗会引起芯片整体温度上升，加剧**[电迁移](@entry_id:141380) (electromigration)** 等长期可靠性问题，可能永久性地损坏芯片。其平均电流可表示为 $I_{\mathrm{avg}} = C_{\mathrm{shift}} V_{\mathrm{DD}} f_{\mathrm{shift}}$，其中 $C_{\mathrm{shift}}$ 是每个移位周期内翻转的有效电容。

**高速捕获功耗**：在高速测试的捕获周期，大量[逻辑门](@entry_id:178011)可能在极短时间内同时翻转。这会导致巨大的**峰值电流**和极高的电流变化率 ($di/dt$)。这种瞬时的高电流会对电源分配网络（PDN）造成两种主要的噪声：
- **动态[IR压降](@entry_id:272464)**：峰值电流流过PDN的电阻性部分（$R_{\mathrm{pd}}$）时，会产生瞬时的[电压降](@entry_id:263648) $V_{\mathrm{IR}} = I_{\mathrm{peak}} \cdot R_{\mathrm{pd}}$。
- **地弹 (Ground Bounce)**：巨大的 $di/dt$ 流过封装和片上电感的感性部分（$L_{\mathrm{pkg}}$）时，会产生瞬时的电压扰动 $V_{L} = L_{\mathrm{pkg}} \frac{di}{dt}$。

这两种效应共同导致了芯片内部实际供电电压的瞬时跌落。由于[逻辑门](@entry_id:178011)的[传播延迟](@entry_id:170242)与供电电压负相关（$\partial t_{\mathrm{pd}} / \partial V_{\mathrm{DD}}  0$），电压跌落会使电路路径延迟增加。在时序本已紧张的高速测试中，这种额外的延迟可能导致[时序违规](@entry_id:177649)，使得一个本应通过测试的好芯片被误判为坏芯片，即**假失效 (false fail)**。例如，在一次捕获事件中，高达16A的[峰值电流](@entry_id:264029)可能导致80mV的[IR压降](@entry_id:272464)和320mV的地弹，总计400mV的电压噪声足以对0.8V供电的电路造成严重的时序问题。与关注平均效应的可靠性问题不同，假失效是由瞬时峰值效应驱动的。通过交错不同时钟域的捕获时钟等技术可以平滑峰值电流，从而缓解此问题。 