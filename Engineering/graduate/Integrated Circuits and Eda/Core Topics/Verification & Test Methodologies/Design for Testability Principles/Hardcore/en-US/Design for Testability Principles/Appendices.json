{
    "hands_on_practices": [
        {
            "introduction": "Effective Design for Testability begins with a quantitative understanding of a circuit's inherent test challenges. This practice introduces the Sandia Controllability/Observability Analysis Program (SCOAP), a foundational algorithm used to estimate the difficulty of setting internal circuit nodes to specific logic values (controllability) and propagating a fault effect from those nodes to an output (observability). By calculating these metrics from first principles, you will gain hands-on experience in identifying potential testability bottlenecks in a design before committing to a full test generation effort .",
            "id": "4264468",
            "problem": "Consider the following single-clock-domain combinational network specified at the gate level. The design context is Design for Testability (DFT) within Electronic Design Automation (EDA). The network has Primary Inputs (PI) $a$, $b$, $c$, $d$, $e$, $f$, $g$ and Primary Outputs (PO) $y_1$, $y_2$. Internal nodes are $n_1$, $n_2$, $n_3$, $n_4$, $n_5$, $n_6$, $n_7$. All gates have unit cost, meaning each gate contributes a cost of $1$ when a signal value is forced through it or when an effect is propagated through it.\n\nThe network is defined as follows:\n- $n_1 = \\mathrm{NAND}(a,b)$\n- $n_2 = \\mathrm{OR}(c,d)$\n- $n_3 = \\mathrm{AND}(n_1,n_2)$\n- $n_4 = \\mathrm{XOR}(n_3,e)$\n- $n_5 = \\mathrm{NOR}(f,g)$\n- $n_6 = \\mathrm{AND}(n_4,n_5)$\n- $n_7 = \\mathrm{NOT}(n_2)$\n- $y_1 = \\mathrm{OR}(n_6,n_7)$\n- $y_2 = \\mathrm{AND}(n_1,e)$\n\nUsing the Sandia Controllability/Observability Analysis Program (SCOAP) framework, compute the controllability metrics $CC0$ and $CC1$ and the observability metric $CO$ for every node in the network. Base your derivation on the core definitions:\n- Controllability $CC0(x)$ and $CC1(x)$ quantify the minimum effort to force node $x$ to logic $0$ or logic $1$, respectively, starting from the primary inputs and accounting for gate semantics and required side-input assignments.\n- Observability $CO(x)$ quantifies the minimum effort to propagate a logic difference at node $x$ to at least one primary output, accounting for path sensitization from $x$ to a primary output.\n\nAssume the baseline costs are $CC0(x)=CC1(x)=1$ for any primary input $x$ and $CO(y)=0$ for any primary output $y$. Do not assume closed-form gate-specific SCOAP recurrences; instead derive them from first principles using Boolean semantics and path sensitization.\n\nAfter computing $CC0$, $CC1$, and $CO$ for all nodes, define the worst-case stuck-at detection cost for a node $v$ as\n$$D(v) = \\max\\!\\big(CC0(v) + CO(v),\\; CC1(v) + CO(v)\\big).$$\nAmong all nodes in the network (including primary inputs and internal nodes, but noting that primary outputs already have $CO=0$), determine the maximum value\n$$D_{\\max} = \\max_{v} D(v).$$\n\nReport only $D_{\\max}$ as your final answer. The final answer must be a single real-valued number. No rounding is required.",
            "solution": "We begin from the core definitions of controllability and observability. Controllability $CC0(x)$ is the minimal cost to force node $x$ to logic $0$ from the primary inputs, and $CC1(x)$ is the minimal cost to force node $x$ to logic $1$. Observability $CO(x)$ is the minimal cost to propagate a logic difference at node $x$ to a primary output. All costs count gate traversals and necessary side-input assignments, each with unit cost $1$.\n\nBaseline initialization follows from the definitions:\n- For any primary input $p$, forcing $p$ to $0$ or $1$ is a direct assignment with cost $1$, so $CC0(p)=1$ and $CC1(p)=1$.\n- For any primary output $y$, the difference is already at the output, so $CO(y)=0$.\n\nWe derive gate-wise controllability from Boolean semantics:\n- For $\\mathrm{AND}$: output $0$ occurs if any input is $0$, so $CC0(\\mathrm{AND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$. Output $1$ requires all inputs $1$, so $CC1(\\mathrm{AND}) = 1 + \\sum CC1(\\text{inputs})$.\n- For $\\mathrm{OR}$: output $0$ requires all inputs $0$, so $CC0(\\mathrm{OR}) = 1 + \\sum CC0(\\text{inputs})$. Output $1$ occurs if any input is $1$, so $CC1(\\mathrm{OR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$.\n- For $\\mathrm{NAND}$ is the inversion of $\\mathrm{AND}$: to get output $0$, its pre-inversion $\\mathrm{AND}$ must be $1$, so $CC0(\\mathrm{NAND}) = 1 + \\sum CC1(\\text{inputs})$. To get output $1$, its pre-inversion $\\mathrm{AND}$ must be $0$, so $CC1(\\mathrm{NAND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$.\n- For $\\mathrm{NOR}$ is the inversion of $\\mathrm{OR}$: $CC0(\\mathrm{NOR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$ and $CC1(\\mathrm{NOR}) = 1 + \\sum CC0(\\text{inputs})$.\n- For $\\mathrm{NOT}$: $CC0(\\mathrm{NOT}(x)) = 1 + CC1(x)$ and $CC1(\\mathrm{NOT}(x)) = 1 + CC0(x)$.\n- For two-input $\\mathrm{XOR}(u,v)$: output $0$ requires $u=v$, achievable either by $u=0,v=0$ or $u=1,v=1$, hence $CC0(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC0(v),\\; CC1(u)+CC1(v)\\big)$. Output $1$ requires $u\\neq v$, achievable either by $u=0,v=1$ or $u=1,v=0$, hence $CC1(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC1(v),\\; CC1(u)+CC0(v)\\big)$.\n\nWe derive gate-wise observability from path sensitization:\n- For $\\mathrm{AND}$ with output $y$ and input $x_i$, to observe $x_i$ at $y$ the other inputs must be $1$, and traversal through the gate adds $1$, so $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC1(x_j)$.\n- For $\\mathrm{OR}$, to observe $x_i$ the other inputs must be $0$, so $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC0(x_j)$.\n- For $\\mathrm{NAND}$ and $\\mathrm{NOR}$, the inversion at the output does not change side-input sensitization; observability through them matches the corresponding $\\mathrm{AND}$ or $\\mathrm{OR}$ case: $\\mathrm{NAND}$ uses $CC1$ of other inputs, $\\mathrm{NOR}$ uses $CC0$ of other inputs.\n- For $\\mathrm{NOT}$, $CO(\\text{input}) = 1 + CO(\\text{output})$.\n- For two-input $\\mathrm{XOR}$, to observe one input through the output, the other input must be sensitized to either $0$ or $1$, whichever is easier; thus $CO(u) = 1 + CO(\\text{output}) + \\min\\big(CC0(v), CC1(v)\\big)$ and symmetrically for $v$.\n- For fanout, the observability of a node is the minimum over its fanout branches: $CO(x) = \\min_{\\text{fanout } f} CO_f(x)$.\n\nWe now apply these to the given network. Initialize the PIs:\n- $CC0(a)=CC1(a)=CC0(b)=CC1(b)=\\cdots=CC0(g)=CC1(g)=1$.\n\nCompute forward controllability:\n\n$\\,\\bullet\\,$ $n_1=\\mathrm{NAND}(a,b)$:\n- $CC0(n_1) = 1 + CC1(a) + CC1(b) = 1 + 1 + 1 = 3$.\n- $CC1(n_1) = 1 + \\min\\big(CC0(a), CC0(b)\\big) = 1 + \\min(1,1) = 2$.\n\n$\\,\\bullet\\,$ $n_2=\\mathrm{OR}(c,d)$:\n- $CC0(n_2) = 1 + CC0(c) + CC0(d) = 1 + 1 + 1 = 3$.\n- $CC1(n_2) = 1 + \\min\\big(CC1(c), CC1(d)\\big) = 1 + \\min(1,1) = 2$.\n\n$\\,\\bullet\\,$ $n_3=\\mathrm{AND}(n_1,n_2)$:\n- $CC0(n_3) = 1 + \\min\\big(CC0(n_1), CC0(n_2)\\big) = 1 + \\min(3,3) = 4$.\n- $CC1(n_3) = 1 + CC1(n_1) + CC1(n_2) = 1 + 2 + 2 = 5$.\n\n$\\,\\bullet\\,$ $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CC0(n_4) = 1 + \\min\\big(CC0(n_3)+CC0(e),\\; CC1(n_3)+CC1(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 1 + \\min(5,6) = 6$.\n- $CC1(n_4) = 1 + \\min\\big(CC0(n_3)+CC1(e),\\; CC1(n_3)+CC0(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 6$.\n\n$\\,\\bullet\\,$ $n_5=\\mathrm{NOR}(f,g)$:\n- $CC0(n_5) = 1 + \\min\\big(CC1(f), CC1(g)\\big) = 1 + \\min(1,1) = 2$.\n- $CC1(n_5) = 1 + CC0(f) + CC0(g) = 1 + 1 + 1 = 3$.\n\n$\\,\\bullet\\,$ $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CC0(n_6) = 1 + \\min\\big(CC0(n_4), CC0(n_5)\\big) = 1 + \\min(6,2) = 3$.\n- $CC1(n_6) = 1 + CC1(n_4) + CC1(n_5) = 1 + 6 + 3 = 10$.\n\n$\\,\\bullet\\,$ $n_7=\\mathrm{NOT}(n_2)$:\n- $CC0(n_7) = 1 + CC1(n_2) = 1 + 2 = 3$.\n- $CC1(n_7) = 1 + CC0(n_2) = 1 + 3 = 4$.\n\n$\\,\\bullet\\,$ $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CC0(y_1) = 1 + CC0(n_6) + CC0(n_7) = 1 + 3 + 3 = 7$.\n- $CC1(y_1) = 1 + \\min\\big(CC1(n_6), CC1(n_7)\\big) = 1 + \\min(10,4) = 5$.\n\n$\\,\\bullet\\,$ $y_2=\\mathrm{AND}(n_1,e)$:\n- $CC0(y_2) = 1 + \\min\\big(CC0(n_1), CC0(e)\\big) = 1 + \\min(3,1) = 2$.\n- $CC1(y_2) = 1 + CC1(n_1) + CC1(e) = 1 + 2 + 1 = 4$.\n\nCompute backward observability. Initialize POs:\n- $CO(y_1)=0$, $CO(y_2)=0$.\n\n$\\,\\bullet\\,$ Through $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CO(n_6) = 1 + CO(y_1) + CC0(n_7) = 1 + 0 + 3 = 4$.\n- $CO(n_7) = 1 + CO(y_1) + CC0(n_6) = 1 + 0 + 3 = 4$.\n\n$\\,\\bullet\\,$ Through $y_2=\\mathrm{AND}(n_1,e)$:\n- $CO(n_1) = 1 + CO(y_2) + CC1(e) = 1 + 0 + 1 = 2$.\n- $CO(e) = 1 + CO(y_2) + CC1(n_1) = 1 + 0 + 2 = 3$.\n\n$\\,\\bullet\\,$ Through $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CO(n_4) = 1 + CO(n_6) + CC1(n_5) = 1 + 4 + 3 = 8$.\n- $CO(n_5) = 1 + CO(n_6) + CC1(n_4) = 1 + 4 + 6 = 11$.\n\n$\\,\\bullet\\,$ Through $n_7=\\mathrm{NOT}(n_2)$:\n- $CO(n_2)$ via this branch $= 1 + CO(n_7) = 1 + 4 = 5$.\n\n$\\,\\bullet\\,$ Through $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CO(n_3) = 1 + CO(n_4) + \\min\\big(CC0(e), CC1(e)\\big) = 1 + 8 + \\min(1,1) = 10$.\n- $CO(e)$ via this branch $= 1 + CO(n_4) + \\min\\big(CC0(n_3), CC1(n_3)\\big) = 1 + 8 + \\min(4,5) = 13$.\n\nCombine fanouts for $e$: $e$ has fanouts to $y_2$ and $n_4$, so $CO(e) = \\min(3,13) = 3$.\n\n$\\,\\bullet\\,$ Through $n_3=\\mathrm{AND}(n_1,n_2)$:\n- $CO(n_1)$ via this branch $= 1 + CO(n_3) + CC1(n_2) = 1 + 10 + 2 = 13$.\n- $CO(n_2)$ via this branch $= 1 + CO(n_3) + CC1(n_1) = 1 + 10 + 2 = 13$.\n\nCombine fanouts:\n- $n_1$ fans out to $y_2$ and $n_3$, so $CO(n_1) = \\min(2,13) = 2$.\n- $n_2$ fans out to $n_7$ and $n_3$, so $CO(n_2) = \\min(5,13) = 5$.\n\n$\\,\\bullet\\,$ Through $n_1=\\mathrm{NAND}(a,b)$:\n- $CO(a) = 1 + CO(n_1) + CC1(b) = 1 + 2 + 1 = 4$.\n- $CO(b) = 1 + CO(n_1) + CC1(a) = 1 + 2 + 1 = 4$.\n\n$\\,\\bullet\\,$ Through $n_2=\\mathrm{OR}(c,d)$:\n- $CO(c) = 1 + CO(n_2) + CC0(d) = 1 + 5 + 1 = 7$.\n- $CO(d) = 1 + CO(n_2) + CC0(c) = 7$.\n\n$\\,\\bullet\\,$ Through $n_5=\\mathrm{NOR}(f,g)$:\n- $CO(f) = 1 + CO(n_5) + CC0(g) = 1 + 11 + 1 = 13$.\n- $CO(g) = 1 + CO(n_5) + CC0(f) = 13$.\n\nWe summarize $CC0$, $CC1$, $CO$:\n- $a$: $CC0=1$, $CC1=1$, $CO=4$.\n- $b$: $CC0=1$, $CC1=1$, $CO=4$.\n- $c$: $CC0=1$, $CC1=1$, $CO=7$.\n- $d$: $CC0=1$, $CC1=1$, $CO=7$.\n- $e$: $CC0=1$, $CC1=1$, $CO=3$.\n- $f$: $CC0=1$, $CC1=1$, $CO=13$.\n- $g$: $CC0=1$, $CC1=1$, $CO=13$.\n- $n_1$: $CC0=3$, $CC1=2$, $CO=2$.\n- $n_2$: $CC0=3$, $CC1=2$, $CO=5$.\n- $n_3$: $CC0=4$, $CC1=5$, $CO=10$.\n- $n_4$: $CC0=6$, $CC1=6$, $CO=8$.\n- $n_5$: $CC0=2$, $CC1=3$, $CO=11$.\n- $n_6$: $CC0=3$, $CC1=10$, $CO=4$.\n- $n_7$: $CC0=3$, $CC1=4$, $CO=4$.\n- $y_1$: $CC0=7$, $CC1=5$, $CO=0$.\n- $y_2$: $CC0=2$, $CC1=4$, $CO=0$.\n\nIdentify nodes limiting fault activation and propagation qualitatively:\n- Largest activation difficulty $CC1$ occurs at $n_6$ with $CC1(n_6)=10$ and at $n_4$ with $CC1(n_4)=6$; largest $CC0$ occurs at $n_4$ with $CC0(n_4)=6$ and at $y_1$ with $CC0(y_1)=7$.\n- Largest propagation difficulty $CO$ occurs at $f$ and $g$ with $CO=13$, and at $n_5$ with $CO=11$, and at $n_3$ with $CO=10$.\n\nCompute the worst-case stuck-at detection cost $D(v) = \\max\\big(CC0(v)+CO(v),\\; CC1(v)+CO(v)\\big)$ for each node:\n- $D(a) = \\max(1+4,\\; 1+4) = 5$.\n- $D(b) = 5$.\n- $D(c) = \\max(1+7,\\; 1+7) = 8$.\n- $D(d) = 8$.\n- $D(e) = \\max(1+3,\\; 1+3) = 4$.\n- $D(f) = \\max(1+13,\\; 1+13) = 14$.\n- $D(g) = 14$.\n- $D(n_1) = \\max(3+2,\\; 2+2) = 5$.\n- $D(n_2) = \\max(3+5,\\; 2+5) = 8$.\n- $D(n_3) = \\max(4+10,\\; 5+10) = \\max(14,\\; 15) = 15$.\n- $D(n_4) = \\max(6+8,\\; 6+8) = 14$.\n- $D(n_5) = \\max(2+11,\\; 3+11) = \\max(13,\\; 14) = 14$.\n- $D(n_6) = \\max(3+4,\\; 10+4) = \\max(7,\\; 14) = 14$.\n- $D(n_7) = \\max(3+4,\\; 4+4) = 8$.\n- $D(y_1) = \\max(7+0,\\; 5+0) = 7$.\n- $D(y_2) = \\max(2+0,\\; 4+0) = 4$.\n\nTherefore, the maximum worst-case detection cost is\n$$D_{\\max} = 15,$$\nachieved at node $n_3$.",
            "answer": "$$\\boxed{15}$$"
        },
        {
            "introduction": "While SCOAP provides a high-level estimate of testability, the ultimate goal is to generate concrete test vectors that can detect specific faults. This exercise delves into the Path-Oriented Decision Making (PODEM) algorithm, a classic method for automatic test pattern generation (ATPG) for stuck-at faults . You will step through the process of making decisions at the primary inputs and observing their implications, systematically working to both activate a target fault and propagate its effect to a primary output.",
            "id": "4264494",
            "problem": "Consider a combinational logic block within the context of Electronic Design Automation (EDA) and Design for Testability (DFT), with primary inputs $a$, $b$, $c$, $d$, $e$, $f$ and a single primary output $o$. The internal signals are defined by the following Boolean relationships:\n$$x = \\neg(a \\land b),$$\n$$y = c \\oplus d,$$\n$$z = y \\lor e,$$\n$$m = x \\land z,$$\n$$n = x \\lor f,$$\n$$t = \\neg(n \\oplus m),$$\nand the primary output is\n$$o = t.$$\nAssume a single stuck-at fault model where the target fault is a stuck-at-$0$ on the line $z$ (the output of the $\\lor$ gate producing $z$). Using Path-Oriented Decision Making (PODEM), compute a complete test vector for the ordered inputs $(a,b,c,d,e,f)$ that detects this fault at the primary output $o$. Your derivation must begin from fundamental definitions: the single stuck-at fault model, five-valued logic $\\{0,1,X,D,D'\\}$ where $D$ denotes a value of $1$ in the fault-free circuit and $0$ in the faulty circuit, $D'$ denotes a value of $0$ in the fault-free circuit and $1$ in the faulty circuit, and gate-level controllability and observability principles (controlling and non-controlling values for $\\land$, $\\lor$, $\\oplus$, and $\\operatorname{XNOR}$). \n\nYou must justify the PODEM objective selection, backtrace to primary inputs, and forward implication steps, and prove correctness by showing that the resulting primary output values in the fault-free and faulty circuits differ, i.e., $o_{\\text{good}} \\neq o_{\\text{faulty}}$. Provide the final answer as a single ordered $6$-tuple corresponding to $(a,b,c,d,e,f)$. Since the answer is a binary vector, no rounding or unit specification is required. Your final vector must be fully assigned with values in $\\{0,1\\}$.",
            "solution": "The objective is to find a test vector $(a,b,c,d,e,f)$ that detects the single stuck-at fault $z/0$, meaning line $z$ is permanently fixed to the logical value $0$. We will use the PODEM algorithm, which systematically makes assignments to primary inputs (PIs) to satisfy the two conditions for fault detection: fault activation and fault propagation. The logic values are represented using the five-valued algebra $\\{0,1,X,D,D'\\}$, where $D$ represents a good-circuit value of $1$ and a faulty-circuit value of $0$, and $X$ denotes an unknown or unspecified value.\n\n**1. Fault Activation**\n\nTo detect a stuck-at-$0$ fault on line $z$, we must first drive line $z$ to a logical $1$ in the fault-free (good) circuit. This is the fault activation condition. This creates a composite value $D$ at the fault site, since $z_{\\text{good}}=1$ and $z_{\\text{faulty}}=0$.\n\nThe initial objective for PODEM is therefore to set $z=1$.\nThe gate producing $z$ is defined by the Boolean expression $z = y \\lor e$. To force the output of an $\\lor$ gate to $1$, we must set at least one of its inputs to $1$. The PODEM algorithm must choose one of these inputs to satisfy. We can choose either $y=1$ or $e=1$. A common heuristic is to choose an objective that is easier to satisfy, which often means an input closer to the PIs. Since $e$ is a PI, setting the objective $(e,1)$ is a direct choice.\n\n**Backtrace Step 1:**\nThe initial objective $(z,1)$ is translated by backtracing through the $\\lor$ gate to one of its inputs. We select the objective $(e,1)$. Since $e$ is a primary input, the backtrace phase is complete, and we make the PI assignment $e=1$.\n\n**Forward Implication Step 1:**\nWith the assignment $e=1$, and all other PIs set to $X$, we propagate the known values forward through the circuit.\nThe value of $z$ is now $z = y \\lor e = X \\lor 1 = 1$.\nThis assignment satisfies the fault activation condition. The signal at line $z$ is now $D$ (value is $1$ in the good circuit, $0$ in the faulty circuit).\n\n**2. Fault Propagation**\n\nThe next phase is to propagate the fault effect, represented by $D$, from the fault site $z$ to the primary output $o$. The propagation path is through gates $m$ and $t$, i.e., $z \\rightarrow m \\rightarrow t \\rightarrow o$.\n\nTo propagate the fault effect from an input of a gate to its output, all other inputs to that gate must be set to their non-controlling values.\n\n**New Objective (Propagation through gate $m$):**\nThe gate $m$ is defined by $m = x \\land z$. To propagate the value from input $z$ through this $\\land$ gate, the other input, $x$, must be set to the non-controlling value for an $\\land$ gate, which is $1$. Thus, the new objective for PODEM is $(x,1)$.\n\n**Backtrace Step 2:**\nThe objective is $(x,1)$. The signal $x$ is generated by the gate $x = \\neg(a \\land b)$, which is a NAND gate. To make the output of a NAND gate equal to $1$, its inputs must not both be $1$; that is, $a \\land b$ must equal $0$. This can be achieved by setting either $a=0$ or $b=0$. We choose to set the objective $(a,0)$. Since $a$ is a PI, the backtrace completes, yielding the PI assignment $a=0$.\n\n**Forward Implication Step 2:**\nThe current PI assignments are $a=0$ and $e=1$. Other PIs remain at $X$. We re-evaluate the circuit.\n- $x = \\neg(a \\land b) = \\neg(0 \\land X) = \\neg(0) = 1$. The objective $(x,1)$ is satisfied.\n- Now we check the propagation of $D$. At gate $m$, we have inputs $x=1$ and $z=D$.\n  - $m_{\\text{good}} = x_{\\text{good}} \\land z_{\\text{good}} = 1 \\land 1 = 1$.\n  - $m_{\\text{faulty}} = x_{\\text{faulty}} \\land z_{\\text{faulty}} = 1 \\land 0 = 0$.\n  - Therefore, the output of gate $m$ is $D$. The fault effect has successfully propagated to line $m$.\n\n**New Objective (Propagation through gate $t$):**\nThe next gate in the path is $t = \\neg(n \\oplus m)$, which is an XNOR gate. To propagate the fault effect from input $m$ through an XOR or XNOR gate, we must sensitize the path by setting the other input $n$ to a known value ($0$ or $1$). Let's evaluate $n$.\n- $n = x \\lor f$. From our previous assignment, we have $x=1$.\n- Thus, $n = 1 \\lor f = 1$, regardless of the value of $f$. The value of $n$ is already determined to be $1$ by the existing PI assignments. No new objective is needed.\n\n**Final Forward Implication:**\nThe inputs to gate $t$ are $n=1$ and $m=D$.\n- $t_{\\text{good}} = \\neg(n_{\\text{good}} \\oplus m_{\\text{good}}) = \\neg(1 \\oplus 1) = \\neg(0) = 1$.\n- $t_{\\text{faulty}} = \\neg(n_{\\text{faulty}} \\oplus m_{\\text{faulty}}) = \\neg(1 \\oplus 0) = \\neg(1) = 0$.\n- Therefore, the output of gate $t$ is $D$.\nThe primary output is $o=t$. Thus, $o = D$.\n\nA value of $D$ (or $D'$) at a primary output indicates that the fault is detected. The PODEM algorithm has found a set of PI assignments that detects the fault $z/0$. The assignments made are $a=0$ and $e=1$. The other PIs ($b,c,d,f$) are \"don't cares\" ($X$) for this test. To provide a complete, fully-specified test vector, we can assign them any binary value. A conventional choice is to set all unspecified inputs to $0$.\n\nThis yields the test vector $(a,b,c,d,e,f) = (0,0,0,0,1,0)$.\n\n**3. Verification of the Test Vector**\n\nWe must prove that the vector $(0,0,0,0,1,0)$ detects the fault $z/0$.\n\n**Fault-Free (Good) Circuit Simulation:**\n- Inputs: $a=0, b=0, c=0, d=0, e=1, f=0$.\n- $x = \\neg(a \\land b) = \\neg(0 \\land 0) = \\neg(0) = 1$.\n- $y = c \\oplus d = 0 \\oplus 0 = 0$.\n- $z = y \\lor e = 0 \\lor 1 = 1$.\n- $m = x \\land z = 1 \\land 1 = 1$.\n- $n = x \\lor f = 1 \\lor 0 = 1$.\n- $t = \\neg(n \\oplus m) = \\neg(1 \\oplus 1) = \\neg(0) = 1$.\n- Primary output: $o_{\\text{good}} = t = 1$.\n\n**Faulty Circuit Simulation (with $z$ stuck-at-$0$):**\n- Inputs: $a=0, b=0, c=0, d=0, e=1, f=0$.\n- Node values up to the fault site are the same as in the good circuit.\n- $x = 1$.\n- Line $z$ is forced to $0$, so $z_{\\text{faulty}} = 0$.\n- $m = x \\land z = 1 \\land 0 = 0$.\n- $n = x \\lor f = 1 \\lor 0 = 1$.\n- $t = \\neg(n \\oplus m) = \\neg(1 \\oplus 0) = \\neg(1) = 0$.\n- Primary output: $o_{\\text{faulty}} = t = 0$.\n\n**Conclusion of Verification:**\nSince $o_{\\text{good}} = 1$ and $o_{\\text{faulty}} = 0$, the primary output values differ. The test vector $(0,0,0,0,1,0)$ successfully detects the fault $z/0$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 0  0  0  0  1  0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "In modern, large-scale integrated circuits, DFT is not just about individual gates but about a system-level strategy, with scan design being the most prevalent. This final practice moves from gate-level analysis to the architectural and economic implications of scan testing, focusing on the critical trade-off between test application time and the hardware resources (pins) required . By analyzing how parallel scan chains impact test time and ATE utilization, you will explore a core challenge in making complex chips testable in a cost-effective manner.",
            "id": "4264470",
            "problem": "A synchronous design-for-test scan architecture is applied to a large digital system-on-chip to enable structural testing using Automatic Test Equipment (ATE). The scan method operates by shifting stimulus bits into scan flip-flops, applying one capture cycle, and shifting response bits out. Under an overlapped scan-in/scan-out execution model, once the first pattern is loaded, the unloading of the current pattern is performed concurrently with the loading of the next, and a single capture cycle per pattern is assumed. Let the total number of scan flip-flops be $N_{\\text{ff}}$, the number of scan patterns be $P$, the scan shift frequency be $f_{\\text{shift}}$, and the scan chain count be $k$. Assume the scan chains are perfectly balanced so that the longest chain length is $L_{k} = N_{\\text{ff}}/k$.\n\nConsider two configurations:\n- Baseline single-chain configuration with $k = 1$.\n- Parallel multi-chain configuration with $k = 10$.\n\nAssume $N_{\\text{ff}} = 1{,}000{,}000$, $P = 5{,}000$, $f_{\\text{shift}} = 50 \\times 10^{6}$, and one capture cycle per pattern. The ATE has $C = 1{,}024$ available channels. The device requires $p_{\\text{func}} = 300$ functional I/O channels and $p_{\\text{ctrl}} = 4$ test control channels (for items such as scan enable, test clock, mode, and reset). Each scan chain consumes one scan-in and one scan-out ATE channel. Define ATE pin utilization for configuration $k$ as the fraction $U_{k}$ of ATE channels used by the device in that configuration.\n\nLet $T_{k}$ be the total ATE time to apply all $P$ patterns in configuration $k$ using the overlapped execution model, and let $U_{k}$ be the corresponding ATE pin utilization. Define the efficiency index\n$$\\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}}.$$\nThis index quantifies the test time reduction per unit of ATE pin utilization increase when moving from $k=1$ to $k=10$.\n\nCompute $\\Phi$ for the given parameters. Express the final answer as a pure number without units, and round your answer to four significant figures.",
            "solution": "The problem requires the calculation of an efficiency index $\\Phi$ which relates the test time reduction to the increase in ATE pin utilization when moving from a single scan chain configuration ($k=1$) to a parallel multi-chain configuration ($k=10$). The efficiency index is defined as:\n$$ \\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}} $$\nwhere $T_k$ is the total test time and $U_k$ is the ATE pin utilization for a configuration with $k$ scan chains.\n\nFirst, we must derive the expression for the total ATE test time, $T_k$.\nThe test application process follows an overlapped scan-in/scan-out model with a single capture cycle per pattern. Let $L_k$ be the length of the longest scan chain, $P$ be the number of test patterns, and $f_{\\text{shift}}$ be the scan shift frequency.\n\nThe sequence of operations for applying $P$ patterns is as follows:\n1.  **Initial Load**: The first pattern's stimulus is shifted into the scan chains. This takes $L_k$ shift cycles.\n2.  **First Capture**: A single capture cycle is applied. At this point, $L_k + 1$ cycles have elapsed.\n3.  **Overlapped Execution**: For each subsequent pattern $i$ (from $i=2$ to $P$), the stimulus for pattern $i$ is shifted in concurrently with the response from pattern $i-1$ being shifted out. This takes $L_k$ cycles, followed by one capture cycle for pattern $i$. This block of $(L_k+1)$ cycles is repeated for patterns $2, 3, \\dots, P$.\n4.  **Final Unload**: After the P-th pattern's capture cycle, its response resides in the scan flip-flops. This response must be shifted out. This final unload operation takes $L_k$ cycles.\n\nLet's trace the total number of cycles, $N_{\\text{cycles},k}$:\nThe time to complete the capture for the first pattern is $L_k+1$ cycles.\nThe time for each of the subsequent $P-1$ patterns adds an additional $L_k+1$ cycles. Thus, the capture for the final pattern, $P$, completes at a total elapsed time of $P \\times (L_k+1)$ cycles.\nAfter this final capture, the response of pattern $P$ must be fully shifted out of the scan chains, which requires an additional $L_k$ cycles.\nTherefore, the total number of cycles required to apply all $P$ patterns is:\n$$ N_{\\text{cycles},k} = P(L_k + 1) + L_k = PL_k + P + L_k = (P+1)L_k + P $$\nThe problem states that the scan chains are perfectly balanced, so $L_k = N_{\\text{ff}}/k$. Substituting this into the cycle count expression:\n$$ N_{\\text{cycles},k} = (P+1)\\frac{N_{\\text{ff}}}{k} + P $$\nThe total test time $T_k$ is the total number of cycles divided by the shift frequency $f_{\\text{shift}}$:\n$$ T_k = \\frac{N_{\\text{cycles},k}}{f_{\\text{shift}}} = \\frac{(P+1)\\frac{N_{\\text{ff}}}{k} + P}{f_{\\text{shift}}} $$\n\nNext, we derive the expression for the ATE pin utilization, $U_k$.\nThe total number of ATE channels used by the device is the sum of functional I/O channels ($p_{\\text{func}}$), test control channels ($p_{\\text{ctrl}}$), and scan chain channels. Each of the $k$ scan chains requires one scan-in and one scan-out channel, so the scan chains consume $2k$ channels.\nThe total number of pins used in configuration $k$ is:\n$$ p_{\\text{total},k} = p_{\\text{func}} + p_{\\text{ctrl}} + 2k $$\nThe pin utilization $U_k$ is the fraction of total available ATE channels ($C$) that are used:\n$$ U_k = \\frac{p_{\\text{total},k}}{C} = \\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2k}{C} $$\n\nNow, we can compute the ratios required for $\\Phi$.\nThe ratio of test times is:\n$$ \\frac{T_1}{T_{10}} = \\frac{\\frac{(P+1)\\frac{N_{\\text{ff}}}{1} + P}{f_{\\text{shift}}}}{\\frac{(P+1)\\frac{N_{\\text{ff}}}{10} + P}{f_{\\text{shift}}}} = \\frac{(P+1)N_{\\text{ff}} + P}{(P+1)\\frac{N_{\\text{ff}}}{10} + P} $$\nThe ratio of pin utilizations is:\n$$ \\frac{U_{10}}{U_1} = \\frac{\\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2(10)}{C}}{\\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2(1)}{C}} = \\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 20}{p_{\\text{func}} + p_{\\text{ctrl}} + 2} $$\n\nWe now substitute the given numerical values:\n$N_{\\text{ff}} = 1{,}000{,}000 = 10^6$\n$P = 5{,}000$\n$p_{\\text{func}} = 300$\n$p_{\\text{ctrl}} = 4$\n$C = 1{,}024$\n\nFirst, calculate the test time ratio:\n$P+1 = 5001$.\n$$ \\frac{T_1}{T_{10}} = \\frac{(5001)(10^6) + 5000}{(5001)\\frac{10^6}{10} + 5000} = \\frac{5001000000 + 5000}{500100000 + 5000} = \\frac{5001005000}{500105000} \\approx 9.99991001 $$\n\nNext, calculate the pin utilization ratio:\n$$ \\frac{U_{10}}{U_1} = \\frac{300 + 4 + 20}{300 + 4 + 2} = \\frac{324}{306} $$\nThis fraction can be simplified. Both numbers are divisible by $18$:\n$$ \\frac{324}{18} = 18 \\quad \\text{and} \\quad \\frac{306}{18} = 17 $$\nSo,\n$$ \\frac{U_{10}}{U_1} = \\frac{18}{17} \\approx 1.05882353 $$\n\nFinally, we compute the efficiency index $\\Phi$:\n$$ \\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}} = \\frac{5001005000/500105000}{18/17} = \\frac{9.99991001...}{1.05882353...} \\approx 9.44436589 $$\nRounding the result to four significant figures gives $9.444$.",
            "answer": "$$\\boxed{9.444}$$"
        }
    ]
}