## 引言
随着[集成电路](@entry_id:265543)（IC）的复杂度日益增加，确保其出厂时的质量与可靠性变得至关重要。自动测试码样生成（ATPG）是超大规模[集成电路](@entry_id:265543)（VLSI）测试流程中的核心环节，其目标是系统性地创建输入向量，以检测制造过程中可能出现的物理缺陷。对于包含数百万乃至数十亿晶体管的现代芯片，手动设计测试码样已无可能，因此高效的自动化算法成为必然选择。本文旨在深入剖析确定性ATPG领域中的两大基石性算法——D-算法和PODEM，填补从理解测试需求到掌握算法内部工作机制之间的知识鸿沟。

为实现这一目标，本文将分步展开。在“**原理与机制**”一章中，我们将建立用于描述故障行为的五值逻辑语言，并详细拆解D-算法与PODEM的搜索策略与核心差异。接着，在“**应用与交叉学科联系**”一章，我们将探讨如何通过启发式方法与[可测性](@entry_id:199191)设计（DFT）[提升算法](@entry_id:635795)的实际效能，并揭示其在逻辑综合、验证以及与现代[布尔可满足性](@entry_id:136675)（SAT）求解器融合中的深远影响。最后，“**动手实践**”部分将提供具体案例，帮助读者巩固所学知识。通过本次学习，读者将从基础理论出发，逐步深入到算法的应用与演进，最终全面掌握确定性ATPG的关键技术。

## 原理与机制

在本章中，我们将深入探讨确定性自动测试码样生成（ATPG）的核心原理与算法机制。我们将首先建立一套用于描述故障电路行为的数学语言，然后剖析生成测试码样的基本任务，最后详细阐述两种经典的确定性ATPG算法——D算法和PODEM——的工作流程与关键区别。

### 故障的语言：五值逻辑

为了生成一个能够检测特定故障的测试码样，算法必须能够同时推理无故障电路（“好电路”）和存在单个[固定型故障](@entry_id:171196)的电路（“坏电路”）的行为。为了有效地实现这一点，我们需要一种能够捕捉两种电路状态之间差异的逻辑系统。标准的布尔逻辑（$\{0,1\}$）仅能描述单个电路的状态，而[三值逻辑](@entry_id:153539)（$\{0,1,X\}$，其中 $X$ 代表未知）虽能处理未定值，但仍无法表示好电路与坏电路之间的明确差异。

因此，确定性ATPG算法普遍采用一种**五值逻辑代数**，其符号集为 $\{0, 1, X, D, \overline{D}\}$。这五个符号中的每一个都简洁地编码了一个**[有序对](@entry_id:269702) $(v_g, v_f)$**，其中 $v_g$ 是信号线在好电路中的值，而 $v_f$ 是同一信号线在坏电路中的值。

这些符号的精确语义定义如下：

*   $0 \equiv (0, 0)$：表示该信号线在好电路和坏电路中均为逻辑 $0$。
*   $1 \equiv (1, 1)$：表示该信号线在好电路和坏电路中均为逻辑 $1$。
*   $X \equiv (X, X)$：表示该信号线的值在两个电路中均为未知或“不关心”。这是一个保守的表示，用于算法尚未确定或无需确定其值的信号线。
*   $D \equiv (1, 0)$：表示该信号线在好电路中为 $1$，但在坏电路中为 $0$。这是最关键的符号之一，代表了一个**故障效应**或**差异 (discrepancy)**。
*   $\overline{D} \equiv (0, 1)$：表示该信号线在好电路中为 $0$，但在坏电路中为 $1$。它同样代表一个故障效应，并且与 $D$ 互补。

$D$ 和 $\overline{D}$ 之间的区别至关重要，它编码了误差的方向性。例如，如果一个值为 $D$ 的信号通过一个反相器（NO[T门](@entry_id:138474)），其输出值将变为 $\overline{D}$（因为好电路中的 $1$ 变为 $0$，坏电路中的 $0$ 变为 $1$）。如果不对差异进行区分，就无法正确地模拟故障效应在电路中的传播。

### ATPG的目标：激活、传播与合理化

一个有效的测试码样必须完成一项核心任务：使目标故障的影响在一个或多个**主输出（Primary Outputs, POs）**上可见。这个任务可以分解为三个紧密相连的子问题：故障激活、[故障传播](@entry_id:1124821)和值合理化。

#### 故障激活 (Fault Activation)

**故障激活**，也称为**故障激励 (fault excitation)**，是在故障所在位置（fault site）制造一个初始差异的过程。对于一个**[固定型故障](@entry_id:171196) (stuck-at fault)**，即某条信号线 $n$ 的值在坏电路中被固定为 $v \in \{0, 1\}$（分别称为**固定为0 (stuck-at-0, $s\text{-}a\text{-}0$)** 和**固定为1 (stuck-at-1, $s\text{-}a\text{-}1$)**），激活该故障就意味着必须在好电路中将信号线 $n$ 驱动到与固定值相反的值 $\overline{v}$。

*   对于**$s\text{-}a\text{-}0$**故障（坏电路值为 $0$），必须在好电路中将该线的值置为 $1$。这样，该信号线上的复合值为 $(v_g, v_f) = (1, 0)$，即 $D$。
*   对于**$s\text{-}a\text{-}1$**故障（坏电路值为 $1$），必须在好电路中将该线的值置为 $0$。这样，该信号线上的复合值为 $(v_g, v_f) = (0, 1)$，即 $\overline{D}$。

只有在故障被成功激活，即在故障点产生了 $D$ 或 $\overline{D}$ 之后，测试生成过程才能进入下一步。

#### [故障传播](@entry_id:1124821) (Fault Propagation)

**[故障传播](@entry_id:1124821)**是指将故障点产生的初始差异（$D$ 或 $\overline{D}$）沿着一条或多条路径传递到至少一个主输出的过程。如果一个故障效应到达了主输出，那么通过比较测试仪器在施加该测试码样时测得的输出与预期（好电路）的输出，就可以判断出故障是否存在。

为了使故障效应能够通过一个[逻辑门](@entry_id:178011)，该[逻辑门](@entry_id:178011)必须被**敏化 (sensitized)**。这意味着该门的输出值必须对承载故障效应的那个输入值敏感。这通过将该门的其他所有输入（称为**旁路输入 (side inputs)**）设置为**非控制值 (non-controlling value)** 来实现。

*   **控制值 (Controlling value)** 是指一个[逻辑门](@entry_id:178011)的某个输入取该值时，无论其他输入为何值，输出都将被唯一确定。
    *   对于[与门](@entry_id:166291)（AND）和[与非门](@entry_id:151508)（NAND），控制值是 $0$。
    *   对于[或门](@entry_id:168617)（OR）和[或非门](@entry_id:174081)（NOR），控制值是 $1$。

*   **非控制值 (Non-controlling value)** 则是控制值的相反值。
    *   对于与门（AND）和与非门（NAND），非控制值是 $1$。
    *   对于或门（OR）和[或非门](@entry_id:174081)（NOR），非控制值是 $0$。

例如，要将一个 $D$ 信号从一个与门的一个输入传播到其输出，所有其他旁路输入都必须被设置为 $1$（非控制值）。如果任何一个旁路输入被设置为 $0$（控制值），[与门](@entry_id:166291)的输出将被强制为 $0$，从而**阻塞 (block)** 或**掩蔽 (mask)** 了 $D$ 信号的传播。

一个故障是**可观测的 (observable)**，当且仅当存在一个从故障点到某个主输出的**敏化路径**。更形式化地，我们可以使用**[布尔差分](@entry_id:1121774) (Boolean difference)** 的概念来定义可观测性。对于一个[布尔函数](@entry_id:276668) $h$ 和其输入 $x$，[布尔差分](@entry_id:1121774) $\partial h / \partial x$ 在其他输入值固定的情况下等于 $1$，表示 $h$ 的输出对 $x$ 的变化敏感。因此，故障的可观测性条件可以表述为：存在一个从故障点到主输出的路径，以及一个主输入赋值，使得该路径上的每一个[逻辑门](@entry_id:178011)的[布尔差分](@entry_id:1121774)（相对于路径上的输入）都为 $1$。

#### 值合理化 (Value Justification)

**值合理化**，也称为**反向蕴含 (backward implication)**，是确保为实现故障激活和传播而在电路内部节点上设定的所有逻辑值（$0$ 或 $1$）都是一致的，并且可以通过对**主输入（Primary Inputs, PIs）**的某个赋值来实现。这是一个从电路内部向主输入反向推理的过程。

例如，如果为了传播一个 $D$ 信号，我们需要一个与门的输出为 $1$，那么我们必须将其所有输入都设置为 $1$。这个“输出为 $1$”的目标就通过反向蕴含转化为“所有输入为 $1$”的新目标。这个过程持续进行，直到所有内部目标都最终追溯到对主输入的赋值要求。

以下是与门和或门的基本合理化规则：
*   **与门 (AND Gate):**
    *   要使输出为 $1$，所有输入必须为 $1$。
    *   要使输出为 $0$，只需将任意一个输入设置为 $0$ 即可（其他输入为 $X$）。
    *   要使输出为 $D$，需将一个输入设为 $D$，所有其他输入设为 $1$（非控制值）。
*   **[或门](@entry_id:168617) (OR Gate):**
    *   要使输出为 $0$，所有输入必须为 $0$。
    *   要使输出为 $1$，只需将任意一个输入设置为 $1$ 即可（其他输入为 $X$）。
    *   要使输出为 $D$，需将一个输入设为 $D$，所有其他输入设为 $0$（非控制值）。

### D-算法：一种集成的搜索方法

D-算法是第一个为[组合电路](@entry_id:174695)提供完整ATPG解决方案的算法。它将激活、传播和合理化这三个[过程集成](@entry_id:1130203)到一个基于决策和回溯的统一搜索框架中。

D-算法的核心是维护两个动态的门集合，即**D-边界 (D-frontier)** 和 **J-边界 (J-frontier)**。

*   **D-边界** 的形式化定义是这样一个门的集合：其输出值为 $X$（未知），但至少有一个输入值为 $D$ 或 $\overline{D}$。这个集合代表了故障效应传播的最前沿。D-算法的目标就是不断地将这个边界向主输出推进。
*   **J-边界** 则是这样一个门的集合：其输出值已被确定为 $0$ 或 $1$（为了激活或传播），但其输入值尚未能唯一地确定这个输出。这个集合代表了需要被合理化的内部赋值目标。

D-算法的主循环在**D-驱动 (D-drive)** 和**合理化 (justification)** 之间交替进行。

1.  **D-驱动**: 算法从D-边界中选择一个门，并尝试通过将该门的旁路输入设置为非控制值来传播故障效应。这是一个决策点，因为D-边界中可能有多个门，每个门也可能有多条路径可选。
2.  **蕴含 (Implication)**: 做出决策后，算法立即计算该决策导致的直接逻辑后果。
3.  **合理化**: 新的赋值可能会在J-边界上创建新的目标。算法会尝试通过反向蕴含来合理化这些目标，即反向追溯到主输入。
4.  **冲突与回溯 (Conflict and Backtracking)**: 在这个过程中，如果出现逻辑冲突（例如，要求一个信号同时为 $0$ 和 $1$），或者D-边界为空但故障尚未传播到主输出，说明之前的某个决策是错误的。算法必须**回溯**，撤销最近的决策并尝试另一个选项。

算法成功终止的条件是：当一个 $D$ 或 $\overline{D}$ 到达某个主输出，并且所有的内部赋值都得到了一致的、可由主输入实现的合理解释（即J-边界为空）。如果所有可能的决策路径都因冲突而被穷尽，则算法失败，表明对于该故障不存在测试码样（或者该故障是冗余的）。

### PODEM：面向路径的决策制定

尽管D-算法是开创性的，但它在处理具有复杂依赖关系（如**重聚[扇出](@entry_id:173211) (reconvergent fanout)**）的电路时，其搜索空间可能变得非常大。这是因为它允许在电路的**内部节点**上做出决策，而这些决策可能在后续的合理化步骤中被证明是错误的，从而导致大量的回溯。

**面向路径的决策制定 (Path-Oriented Decision Making, PODEM)** 算法通过一个根本性的策略转变来解决这个问题：**所有决策只在主输入（PIs）上进行**。 算法不再直接对内部节点赋值，而是设定一个内部目标，然后反向追溯到某个主输入，并对该主输入进行赋值。

PODEM的工作流程如下：

1.  **设定目标 (Set Objective)**: 算法的初始目标是激活故障（例如，对于 $n$ 点的 $s\text{-}a\text{-}0$ 故障，目标是 $n=1$）。一旦故障被激活，后续目标就是从D-边界中选择一个门，并设置其旁路输入为非控制值以进行传播。
2.  **反向追溯 (Backtrace)**: 算法从当前目标（一个内部节点和期望的值）开始，沿着一条路径**反向追溯**到尚未赋值的某个主输入。这个过程的关键在于计算路径的**反转奇偶性 (inversion parity)**。每经过一个反相[逻辑门](@entry_id:178011)（如NOT, NAND, NOR），期望的值就会翻转一次。如果从目标节点到主输入的路径上经过了偶数个反相门，则主输入的目标值与内部节点的目标值相同；如果经过了奇数个反相门，则主输入的目标值相反。
3.  **赋值与蕴含 (Assign and Imply)**: 算法对选定的主输入赋上目标值（$0$ 或 $1$），然后执行**前向蕴含**，计算该赋值在整个电路中引起的所有确定性后果。
4.  **检查与回溯**: 在蕴含之后，算法检查目标是否达成。如果目标未达成，则继续为当前目标选择另一个PI赋值。如果蕴含导致了冲突，或者所有努力都无法达成目标，算法就会**回溯**，撤销最近的PI赋值，并尝试其反值。

PODEM的优势在于其搜索空间的大小仅由主输入的数量 $n$ 决定（最坏情况下为 $O(2^n)$），而D-算法的搜索空间则与内部节点的数量有关，通常要大得多。

### 比较案例研究：重聚[扇出](@entry_id:173211)

重聚[扇出](@entry_id:173211)结构是电路中一个信号分岔后，经过不同路径又在下游某个门重新汇合的现象。这种结构是测试生成中的一个主要难点，因为它可能导致**故障掩蔽 (fault masking)**。

考虑以下电路，其中信号 $n$ 经过两条路径在 $z$ 点重聚：
$n = x_1 \land x_2$
$u = n \land p$
$v = \overline{n} \land q$
$z = u \lor v$

假设我们想测试 $n$ 点的 $s\text{-}a\text{-}0$ 故障。

1.  **激活**: 我们必须设置 $n=1$，这要求主输入 $x_1=1, x_2=1$。此时，$n$ 的值为 $D$（好电路为 $1$，坏电路为 $0$）。
2.  **传播**: 故障效应 $D$ 沿着两条路径传播。
    *   上路：$u = n \land p = D \land p$。
    *   下路：经过一个反相器，$\overline{n}$ 的值为 $\overline{D}$。因此 $v = \overline{n} \land q = \overline{D} \land q$。
    *   在 $z$ 点汇合：$z = u \lor v$。

如果D-算法试图同时敏化两条路径，它可能会做出决策 $p=1$ 和 $q=1$。这将导致 $u=D$ 和 $v=\overline{D}$。在[输出门](@entry_id:634048) $z$ 上，计算结果为 $z = D \lor \overline{D}$。根据五值逻辑的定义，$(v_g, v_f) = (1,0) \lor (0,1) = (1\lor0, 0\lor1) = (1,1)$，这对应于逻辑值 $1$。故障效应在输出端消失了，发生了自我掩蔽。D-算法此时必须回溯。

相比之下，PODEM的策略天生就能更好地处理这种情况。它会选择一个传播路径，例如通过 $u$ 的路径。
*   **目标**: 传播 $D$ 通过 $u$，需要 $p=1$。
*   **目标**: 同时，为了不让下路的信号干扰，需要阻塞下路。为了让 $z = u \lor v$ 的输出只取决于 $u$，需要将 $v$ 设置为或门的非控制值 $0$。
*   **合理化**: 为了使 $v = \overline{n} \land q = 0$，最简单的方法是设置主输入 $q=0$。

因此，PODEM会导向一个类似 $(x_1, x_2, p, q) = (1, 1, 1, 0)$ 的测试码样。在这个码样下：
*   好电路: $n=1, u=1, v=0 \implies z=1$。
*   坏电路: $n=0, \overline{n}=1, u=0, v=0 \implies z=0$。
*   输出 $z$ 的复合值为 $(1,0)$, 即 $D$。故障被成功检测。

这个例子清晰地表明，PODEM通过其“仅对主输入做决策”和“一次专注于一条路径”的策略，避免了D-算法可能遇到的内部决策过度承诺和导致的复杂回溯，从而在许多实际电路中表现出更高的效率。