{
    "hands_on_practices": [
        {
            "introduction": "The integration of Design for Test (DFT) structures, while essential for manufacturing quality, is not without cost. The first and most direct consequence of inserting a scan chain is the impact on the circuit's functional timing performance. This exercise focuses on quantifying this fundamental trade-off from first principles.\n\nBy analyzing the replacement of a standard flip-flop with a multiplexer-based scan flop, you will derive how this change introduces additional delay into the data path. This practice provides a crucial foundation for understanding why scan insertion can degrade setup timing slack, potentially creating new critical paths that must be managed during timing closure. ",
            "id": "4295557",
            "problem": "Consider a synchronous single-cycle datapath in an integrated circuit designed using Electronic Design Automation (EDA) methods, with a launch register and a capture register, both originally implemented as functional D flip-flops (DFFs). The clock period is $T$, the clock-to-$Q$ propagation delay of the launch register is $t_{\\text{clkq}}$, the total combinational propagation delay between the launch register output and the capture register input is $t_{\\text{pd}}$, and the setup time requirement of the capture register is $t_{\\text{setup}}$. The clock skew from the launch register clock pin to the capture register clock pin is $t_{\\text{skew}}$. Assume a single clock domain, no retiming, and ignore on-chip variation, jitter, and any dynamic power supply noise effects. All timing quantities are for a single process-voltage-temperature corner and are treated as constants.\n\nIn a Design for Test (DFT) insertion step, the capture register is replaced by a muxed-$D$ scan flip-flop, in which the functional $D$ input passes through an internal two-input multiplexer before reaching the storage element. In functional mode (scan enable deasserted), this multiplexer adds an additional delay $\\Delta t_{\\text{mux}}$ to the data path seen at the capture register input. Furthermore, distributing and gating the scan enable signal inside the scan flip-flop adds a setup-time overhead at the capture register, modeled as an increase $\\Delta t_{\\text{SE}}$ in the setup time requirement relative to the original functional DFF. Assume the replacement does not change the launch register characteristics, the clock distribution, or $t_{\\text{skew}}$.\n\nStarting from first principles of synchronous setup timing, derive an analytic expression for the change in setup slack, $\\Delta S$, defined as the setup slack after replacement minus the setup slack before replacement, as a function of $\\Delta t_{\\text{mux}}$ and $\\Delta t_{\\text{SE}}$. Express your final answer as a closed-form symbolic expression in seconds. Do not numerically evaluate or approximate any quantities.",
            "solution": "The setup timing condition for a synchronous single-cycle path in a single clock domain is based on comparing a required arrival time at the capture register with the actual data arrival time at its $D$ input. The setup slack is defined as the difference between the required time and the arrival time, where positive slack indicates the setup constraint is met.\n\nLet the launch clock edge be the reference. The data arrival time at the capture register input in the original, pre-scan configuration is the sum of the launch register clock-to-$Q$ delay and the combinational path delay:\n$$\nt_{\\text{arr,0}} = t_{\\text{clkq}} + t_{\\text{pd}}.\n$$\nThe required arrival time at the capture register input, accounting for the clock period $T$, the clock skew $t_{\\text{skew}}$ (defined as capture clock arrival time minus launch clock arrival time), and the setup time requirement $t_{\\text{setup}}$ of the capture register, is\n$$\nt_{\\text{req,0}} = T + t_{\\text{skew}} - t_{\\text{setup}}.\n$$\nTherefore, the original setup slack $S_{0}$ is\n$$\nS_{0} = t_{\\text{req,0}} - t_{\\text{arr,0}} = \\left(T + t_{\\text{skew}} - t_{\\text{setup}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}}\\right).\n$$\n\nAfter replacing the capture register with a muxed-$D$ scan flip-flop, the functional $D$ input incurs an additional delay $\\Delta t_{\\text{mux}}$ inside the cell before reaching the storage element. This increases the data arrival time at the capture input by $\\Delta t_{\\text{mux}}$, yielding\n$$\nt_{\\text{arr,1}} = t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}.\n$$\nThe scan enable gating overhead increases the setup time requirement by $\\Delta t_{\\text{SE}}$, so the new required time becomes\n$$\nt_{\\text{req,1}} = T + t_{\\text{skew}} - \\left(t_{\\text{setup}} + \\Delta t_{\\text{SE}}\\right).\n$$\nThus, the new setup slack $S_{1}$ is\n$$\nS_{1} = t_{\\text{req,1}} - t_{\\text{arr,1}} = \\left(T + t_{\\text{skew}} - t_{\\text{setup}} - \\Delta t_{\\text{SE}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}\\right).\n$$\n\nThe change in setup slack, defined as the post-replacement slack minus the pre-replacement slack, is\n$$\n\\Delta S = S_{1} - S_{0}.\n$$\nSubstituting the expressions for $S_{1}$ and $S_{0}$:\n$$\n\\Delta S = \\Big[\\left(T + t_{\\text{skew}} - t_{\\text{setup}} - \\Delta t_{\\text{SE}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}\\right)\\Big] - \\Big[\\left(T + t_{\\text{skew}} - t_{\\text{setup}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}}\\right)\\Big].\n$$\nSimplifying, the common terms $T$, $t_{\\text{skew}}$, $t_{\\text{setup}}$, $t_{\\text{clkq}}$, and $t_{\\text{pd}}$ cancel:\n$$\n\\Delta S = -\\Delta t_{\\text{SE}} - \\Delta t_{\\text{mux}}.\n$$\n\nThis expression indicates that the setup slack is reduced by the sum of the multiplexer delay on the functional $D$ path and the increase in setup time caused by the scan enable gating overhead, under the stated assumptions that the launch register, clock distribution, and skew remain unchanged.",
            "answer": "$$\\boxed{-\\left(\\Delta t_{\\text{mux}}+\\Delta t_{\\text{SE}}\\right)}$$"
        },
        {
            "introduction": "Beyond the impact on functional paths, the scan chain itself must operate reliably during test. A primary challenge in scan-shift mode is ensuring data stability between adjacent scan cells, which is governed by hold-time constraints. This problem becomes particularly acute when clock skew—the difference in clock signal arrival times at the launch and capture flops—is significant.\n\nThis exercise requires you to isolate the hold-time constraint and derive the precise threshold of clock skew beyond which a timing violation will occur. This practice clarifies the physical and timing origins of hold-time failures in scan chains and provides the quantitative justification for inserting \"lock-up latches,\" a standard technique used by EDA tools to ensure robust scan chain operation across large designs or different clock domains. ",
            "id": "4295616",
            "problem": "Consider two positive-edge-triggered scan flip-flops (FFs) $S_L$ (launch) and $S_C$ (capture) connected consecutively in a scan chain in shift mode. Both are driven by the same scan clock net but experience different clock arrival times due to clock tree skew. Let the arrival time of a given scan clock edge at $S_L$ be $t_L$ and at $S_C$ be $t_C$, and define the (signed) skew as $s \\triangleq t_C - t_L$. The minimum clock-to-$Q$ delay of $S_L$ is $t_{\\text{cq}}^{\\min}$, the minimum data-path contamination delay from $S_L$’s $Q$ to $S_C$’s $D$ (including the scan multiplexer and interconnect) is $d_{\\text{path}}^{\\min}$, and the hold time of $S_C$ is $t_{\\text{h}}$. In addition, the scan clock has worst-case relative uncertainty (including jitter and modeling uncertainty) $u$ between $S_L$ and $S_C$, defined such that the effective capture edge can arrive up to $u$ later than nominal relative to the launch edge in the worst case.\n\nUsing only the fundamental timing definitions for hold-time, clock-to-$Q$ delay, contamination delay, and clock skew/uncertainty, derive from first principles the analytical expression for the maximum permissible positive skew $s_{\\max}$ that guarantees no hold-time violation at $S_C$ during scan shift (i.e., the threshold beyond which a lock-up latch becomes necessary). Then, evaluate this $s_{\\max}$ numerically for the following parameter values:\n- $t_{\\text{cq}}^{\\min} = 0.037\\ \\mathrm{ns}$,\n- $d_{\\text{path}}^{\\min} = 0.126\\ \\mathrm{ns}$,\n- $t_{\\text{h}} = 0.081\\ \\mathrm{ns}$,\n- $u = 0.019\\ \\mathrm{ns}$.\n\nState the final numeric value of $s_{\\max}$ rounded to four significant figures. Express the final result in nanoseconds.",
            "solution": "The hold-time constraint ensures that new data launched from a scan cell does not arrive at the next cell's input before the current data has been reliably captured. A hold violation occurs if the data arrives too early. We derive the maximum permissible clock skew by comparing the earliest data arrival time with the latest time the hold requirement must be met.\n\nLet's define the timing events relative to a global reference:\n1.  **Earliest Data Arrival at $S_C$**: The clock edge arrives at the launching flip-flop $S_L$ at time $t_L$. The new data appears at its output $Q$ after the minimum clock-to-$Q$ delay, $t_{\\text{cq}}^{\\min}$. This data then propagates through the interconnect, arriving at the capture flip-flop's input $D$ after the minimum path delay, $d_{\\text{path}}^{\\min}$.\n    $$ T_{\\text{data\\_arrival}} = t_L + t_{\\text{cq}}^{\\min} + d_{\\text{path}}^{\\min} $$\n2.  **Hold Time Requirement at $S_C$**: The same clock edge arrives at the capture flip-flop $S_C$ at time $t_C$. The hold requirement, $t_{\\text{h}}$, dictates that the data at input $D$ must remain stable until time $t_C + t_{\\text{h}}$.\n\nTo avoid a hold violation, the new data must arrive after the hold window closes. The robust hold condition, which includes the clock uncertainty margin $u$, is:\n$$ T_{\\text{data\\_arrival}} \\ge t_C + t_{\\text{h}} + u $$\n\nSubstituting the expression for data arrival time:\n$$ t_L + t_{\\text{cq}}^{\\min} + d_{\\text{path}}^{\\min} \\ge t_C + t_{\\text{h}} + u $$\n\nThe clock skew is defined as $s = t_C - t_L$. Rearranging the inequality to solve for $s$:\n$$ t_{\\text{cq}}^{\\min} + d_{\\text{path}}^{\\min} - t_{\\text{h}} - u \\ge t_C - t_L $$\n$$ s \\le t_{\\text{cq}}^{\\min} + d_{\\text{path}}^{\\min} - t_{\\text{h}} - u $$\n\nThis gives the analytical expression for the maximum permissible positive skew:\n$$ s_{\\max} = t_{\\text{cq}}^{\\min} + d_{\\text{path}}^{\\min} - t_{\\text{h}} - u $$\n\nNow, we evaluate this expression using the given numerical values:\n- $t_{\\text{cq}}^{\\min} = 0.037\\ \\mathrm{ns}$\n- $d_{\\text{path}}^{\\min} = 0.126\\ \\mathrm{ns}$\n- $t_{\\text{h}} = 0.081\\ \\mathrm{ns}$\n- $u = 0.019\\ \\mathrm{ns}$\n\n$$ s_{\\max} = 0.037 + 0.126 - 0.081 - 0.019 $$\n$$ s_{\\max} = 0.163 - 0.100 $$\n$$ s_{\\max} = 0.063\\ \\mathrm{ns} $$\n\nThe result, expressed to four significant figures as required, is $0.06300$, which is equivalent to $6.300 \\times 10^{-2}$.",
            "answer": "$$\\boxed{6.300 \\times 10^{-2}}$$"
        },
        {
            "introduction": "Having explored the timing constraints at the cell-pair level, we can now address the global challenge: how does an Electronic Design Automation (EDA) tool connect thousands of scan cells into a single, efficient chain? This \"stitching\" process is a complex optimization problem that must balance competing physical and timing objectives.\n\nThis problem models scan chain reordering as a variant of the classic Traveling Salesman Problem (TSP), where the goal is to find an optimal path through all scan cells. You will implement a practical solver that minimizes total wirelength while penalizing short connections that introduce the very hold-time risks analyzed in the previous exercise. This hands-on coding practice illuminates the algorithmic core of DFT automation, bridging the gap between theoretical timing analysis and the automated physical implementation of modern integrated circuits. ",
            "id": "4295638",
            "problem": "You are given a set of scan cells placed at two-dimensional coordinates expressed in micrometers, and two anchor points representing the scan input and scan output pins. The task is to reorder the scan cells to form a single scan chain path from the scan input anchor to the scan output anchor such that each scan cell is visited exactly once. The path cost must reflect a balance between wirelength and hold-time risk. Formulate this reordering as an anchored open variant of the Traveling Salesman Problem (TSP) over scan cell locations, and implement an approximate solver that achieves a reasonable trade-off between wirelength minimization and hold-time risk reduction.\n\nFundamental base:\n- A scan chain is a sequence of scan cells connected serially, clocked by a scan clock during test. Excessively short physical connections between sequential scan cells increase the probability of hold-time violations, because the data path delay can become too small to satisfy hold requirements under clock skew and variability. Conversely, excessively long connections increase routing congestion and transition time.\n- The Traveling Salesman Problem (TSP) is the problem of finding an order to visit a set of points that minimizes the sum of edge costs. An \"open\" TSP variant seeks a path rather than a cycle, with specified endpoints.\n\nDefinitions:\n- Let the scan input anchor be at coordinates $\\mathbf{s} = (x_s, y_s)$ and the scan output anchor be at coordinates $\\mathbf{t} = (x_t, y_t)$, measured in micrometers.\n- Let the set of scan cells be $\\{\\mathbf{p}_i = (x_i, y_i)\\}_{i=1}^N$, also in micrometers.\n- For any two points $\\mathbf{u} = (x_u, y_u)$ and $\\mathbf{v} = (x_v, y_v)$, define the Manhattan distance in micrometers as $d(\\mathbf{u}, \\mathbf{v}) = |x_u - x_v| + |y_u - y_v|$.\n- Let the per-edge cost be defined as $c(\\mathbf{u}, \\mathbf{v}) = \\alpha \\cdot d(\\mathbf{u}, \\mathbf{v}) + \\beta \\cdot \\max(0, d_h - d(\\mathbf{u}, \\mathbf{v}))$, where $d_h$ is a hold-safe minimum wirelength threshold in micrometers, $\\alpha$ and $\\beta$ are nonnegative weights. The term $\\beta \\cdot \\max(0, d_h - d)$ penalizes connections shorter than $d_h$ to reduce hold risk.\n\nObjective:\n- Find an ordering $\\pi$ of the scan cells that minimizes the total path cost\n$$\nC(\\pi) = c(\\mathbf{s}, \\mathbf{p}_{\\pi(1)}) + \\sum_{k=1}^{N-1} c(\\mathbf{p}_{\\pi(k)}, \\mathbf{p}_{\\pi(k+1)}) + c(\\mathbf{p}_{\\pi(N)}, \\mathbf{t}).\n$$\n\nApproximate solution requirement:\n- Implement a constructive heuristic followed by local improvement. A valid approach is a multi-start greedy construction that builds a path from the scan input anchor through unvisited scan cells by iteratively adding the next scan cell that minimizes incremental edge cost, followed by a $2$-opt local search adapted to the anchored open path to reduce the total cost. The $2$-opt move reverses a contiguous subpath and replaces two edges with two alternative edges, preserving anchors at endpoints.\n\nNumerical and unit requirements:\n- Distances and thresholds are in micrometers, and the total cost must be expressed in micrometers. Your program must report each total cost in micrometers, rounded to three decimal places.\n\nTest suite:\nFor each test case, you are provided with $\\mathbf{s}$, $\\mathbf{t}$, the list of scan cell coordinates, and parameters $\\alpha$, $\\beta$, and $d_h$.\n\n- Test case $1$ (happy path): \n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (1000, 0)$\n  - Scan cells: $[(100, 50), (200, 300), (400, 100), (250, 80), (700, 60), (900, 200), (650, 350), (500, 20)]$\n  - $\\alpha = 1.0$, $\\beta = 3.0$, $d_h = 80$\n- Test case $2$ (short-edge risk emphasis):\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (500, 500)$\n  - Scan cells: $[(50, 50), (55, 52), (60, 48), (58, 55), (62, 51), (57, 49)]$\n  - $\\alpha = 1.0$, $\\beta = 10.0$, $d_h = 50$\n- Test case $3$ (minimum nontrivial chain):\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (1000, 0)$\n  - Scan cells: $[(100, 0), (900, 0)]$\n  - $\\alpha = 1.0$, $\\beta = 0.5$, $d_h = 10$\n- Test case $4$ (grid placement):\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (400, 400)$\n  - Scan cells: $[(100, 100), (100, 200), (100, 300), (200, 100), (200, 200), (200, 300), (300, 100), (300, 200), (300, 300)]$\n  - $\\alpha = 1.0$, $\\beta = 1.0$, $d_h = 40$\n- Test case $5$ (anchors far, clustered cells):\n  - $\\mathbf{s} = (0, 1000)$, $\\mathbf{t} = (1000, 1000)$\n  - Scan cells: $[(420, 210), (430, 250), (415, 230), (460, 240), (500, 260), (520, 220), (480, 200)]$\n  - $\\alpha = 1.0$, $\\beta = 2.0$, $d_h = 60$\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list whose first element is the total cost in micrometers, rounded to three decimal places, and whose second element is the scan chain order as a list of integers denoting the zero-based indices of the scan cells. For example:\n- $[ [123.456,[0,2,1]], [789.000,[1,0]] ]$.",
            "solution": "The problem of finding the optimal scan chain order is formulated as an anchored open Traveling Salesman Problem (TSP). The set of nodes to be visited includes all scan cells $\\{\\mathbf{p}_i\\}_{i=1}^N$, with the path beginning at a fixed start node $\\mathbf{s}$ and ending at a fixed terminal node $\\mathbf{t}$. The total path length is determined by the sum of edge costs, where the cost function $c(\\mathbf{u}, \\mathbf{v})$ uniquely incorporates a penalty for short connections to mitigate hold-time risks.\n\nSince the TSP is NP-hard, finding an exact solution is computationally infeasible for all but the smallest instances. Therefore, we employ a standard and effective two-phase heuristic approach as required: a constructive heuristic to generate a good initial solution, followed by an iterative local search to refine it.\n\n**Phase 1: Greedy Constructive Heuristic (Nearest Neighbor)**\n\nThe initial path is constructed greedily. This method, a variant of the Nearest Neighbor heuristic, builds the scan chain one cell at a time.\n1. The path starts at the scan input anchor, $\\mathbf{s}$.\n2. From the last point added to the chain (initially $\\mathbf{s}$), we select the unvisited scan cell that can be connected with the minimum edge cost, $c(\\cdot, \\cdot)$.\n3. This \"closest\" cell is appended to the chain, and the process repeats until all $N$ scan cells have been visited.\n4. Finally, the last scan cell in the chain is connected to the scan output anchor, $\\mathbf{t}$, completing the path.\n\nThis greedy strategy tends to produce a reasonably short path, providing a high-quality starting point for the subsequent optimization phase.\n\n**Phase 2: Iterative Improvement (2-Opt Local Search)**\n\nThe 2-opt algorithm is a powerful local search heuristic for improving TSP solutions. It works by systematically swapping pairs of edges to see if a shorter path can be formed. For an anchored path `(v_0, v_1, ..., v_N, v_{N+1})`, where $v_0=\\mathbf{s}$ and $v_{N+1}=\\mathbf{t}$, the 2-opt move is adapted as follows:\n1. Select a contiguous subpath of scan cells $(v_i, v_{i+1}, ..., v_j)$ where $1 \\le i  j \\le N$. This subpath is connected to the rest of the path by edges $(v_{i-1}, v_i)$ and $(v_j, v_{j+1})$.\n2. Reverse the order of the subpath to get $(v_j, v_{j-1}, ..., v_i)$.\n3. Reconnect the path by forming new edges $(v_{i-1}, v_j)$ and $(v_i, v_{j+1})$. This constitutes a 2-opt move.\n4. Calculate the change in total cost:\n$$\n\\Delta C = \\left[ c(v_{i-1}, v_j) + c(v_i, v_{j+1}) \\right] - \\left[ c(v_{i-1}, v_i) + c(v_j, v_{j+1}) \\right].\n$$\n5. If $\\Delta C  0$, the new path is shorter. The move is accepted, and the path is updated.\n\nThis process is repeated, iterating through all possible subpaths to reverse, until no further cost-reducing 2-opt moves can be found. At this point, the algorithm has reached a local optimum and terminates. The combination of a greedy start and 2-opt refinement provides a robust and high-quality solution to this complex optimization problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the scan chain reordering problem for a suite of test cases.\n    The problem is modeled as an anchored open Traveling Salesman Problem (TSP) with a custom cost function.\n    The solution uses a two-phase heuristic:\n    1. A greedy construction (Nearest Neighbor) to create an initial path.\n    2. A 2-opt local search to iteratively improve the path until a local optimum is reached.\n    \"\"\"\n    test_cases = [\n        {\n            \"s\": (0, 0), \"t\": (1000, 0),\n            \"cells\": [(100, 50), (200, 300), (400, 100), (250, 80), (700, 60), (900, 200), (650, 350), (500, 20)],\n            \"alpha\": 1.0, \"beta\": 3.0, \"d_h\": 80\n        },\n        {\n            \"s\": (0, 0), \"t\": (500, 500),\n            \"cells\": [(50, 50), (55, 52), (60, 48), (58, 55), (62, 51), (57, 49)],\n            \"alpha\": 1.0, \"beta\": 10.0, \"d_h\": 50\n        },\n        {\n            \"s\": (0, 0), \"t\": (1000, 0),\n            \"cells\": [(100, 0), (900, 0)],\n            \"alpha\": 1.0, \"beta\": 0.5, \"d_h\": 10\n        },\n        {\n            \"s\": (0, 0), \"t\": (400, 400),\n            \"cells\": [(100, 100), (100, 200), (100, 300), (200, 100), (200, 200), (200, 300), (300, 100), (300, 200), (300, 300)],\n            \"alpha\": 1.0, \"beta\": 1.0, \"d_h\": 40\n        },\n        {\n            \"s\": (0, 1000), \"t\": (1000, 1000),\n            \"cells\": [(420, 210), (430, 250), (415, 230), (460, 240), (500, 260), (520, 220), (480, 200)],\n            \"alpha\": 1.0, \"beta\": 2.0, \"d_h\": 60\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_coord, t_coord, cells_coords = case[\"s\"], case[\"t\"], case[\"cells\"]\n        alpha, beta, d_h = case[\"alpha\"], case[\"beta\"], case[\"d_h\"]\n\n        # Consolidate all points: start anchor, cells, end anchor\n        points = [s_coord] + cells_coords + [t_coord]\n        n_cells = len(cells_coords)\n        points_np = np.array(points, dtype=float)\n\n        # Memoization cache for edge costs to speed up calculations\n        cost_cache = {}\n\n        def edge_cost(p1_idx, p2_idx):\n            key = tuple(sorted((p1_idx, p2_idx)))\n            if key in cost_cache:\n                return cost_cache[key]\n            \n            dist = np.sum(np.abs(points_np[p1_idx] - points_np[p2_idx]))\n            cost = alpha * dist + beta * max(0, d_h - dist)\n            cost_cache[key] = cost\n            return cost\n\n        # Phase 1: Greedy Construction (Nearest Neighbor)\n        unvisited_indices = set(range(1, n_cells + 1))\n        initial_path = [0]\n        \n        if n_cells  0:\n            current_idx = 0\n            while unvisited_indices:\n                last_point_idx = initial_path[-1]\n                \n                best_next_idx = -1\n                min_cost = float('inf')\n                \n                for next_idx in unvisited_indices:\n                    cost = edge_cost(last_point_idx, next_idx)\n                    if cost  min_cost:\n                        min_cost = cost\n                        best_next_idx = next_idx\n                \n                initial_path.append(best_next_idx)\n                unvisited_indices.remove(best_next_idx)\n        \n        initial_path.append(n_cells + 1)\n        \n        # Phase 2: 2-Opt Local Search\n        path = initial_path\n        \n        if n_cells  1:\n            improved = True\n            while improved:\n                improved = False\n                # The subpath of scan cells to operate on is path[1:n_cells+1]\n                for i in range(1, n_cells):\n                    for j in range(i + 1, n_cells + 1):\n                        v_i_minus_1, v_i = path[i-1], path[i]\n                        v_j, v_j_plus_1 = path[j], path[j+1]\n\n                        current_edge_cost = edge_cost(v_i_minus_1, v_i) + edge_cost(v_j, v_j_plus_1)\n                        new_edge_cost = edge_cost(v_i_minus_1, v_j) + edge_cost(v_i, v_j_plus_1)\n\n                        if new_edge_cost  current_edge_cost:\n                            path[i:j+1] = path[i:j+1][::-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n        \n        # Final cost calculation for the optimized path\n        total_cost = 0.0\n        for k in range(len(path) - 1):\n            total_cost += edge_cost(path[k], path[k+1])\n            \n        # Convert path indices (referencing `points` array) to original cell indices (0-based)\n        cell_order = [p - 1 for p in path[1:-1]]\n        \n        results.append([f\"{total_cost:.3f}\", cell_order])\n\n    # Format the results into the required string format\n    result_str = \"[\" + \",\".join([f\"[{cost},{order}]\" for cost, order in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}