{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。本节的第一个练习将引导我们计算一种常见的逻辑内建自测试（BIST）架构——STUMPS（使用多输入特征寄存器和并行移位寄存器序列生成器的自测试）的测试时间。通过这个练习，你将学会如何将测试流程中的各个阶段（如扫描加载、高速捕获和响应移出）分解并量化，从而推导出精确的测试时间公式，这是评估测试成本和效率的关键技能。",
            "id": "4258828",
            "problem": "考虑一个采用多输入特征寄存器和并行移位寄存器序列生成器（STUMPS）的自测试架构，该架构使用 $S$ 条并行扫描链。每条扫描链的长度为 $L$ 个触发器，扫描移位时钟的工作频率为 $f_s$，并且需要施加 $N$ 个确定性测试图形。测试响应由一个多输入特征寄存器（MISR）进行压缩，图形生成器是一个并行移位寄存器序列生成器（SRSG），它通过一个带有适当相移器的线性反馈移位寄存器实现。测试采用全速发射-捕获方法以覆盖转换故障，这意味着对于每个测试图形，发射和捕获过程使用频率为 $f_c$ 的功能时钟，且每个图形恰好消耗两个功能时钟周期。\n\n从基于扫描的内建自测试（BIST）的基本原理和核心定义出发，推导施加所有测试图形所需的总时间（以秒为单位），并遵循以下科学且切合实际的假设：\n- 除了初始的扫描填充和最终的扫描清空外，连续测试图形的扫描输入和扫描输出是完全重叠的（流水线操作）。\n- 扫描使能控制确保在发射和捕获期间禁用扫描，因此在这两个功能时钟周期内不发生扫描移位。\n- 在每个扫描移位周期，所有 $S$ 条扫描链并行加载和卸载，且 $L$ 表示这 $S$ 条链中的最大链长。\n- 忽略测试结束时 MISR 特征的读出时间以及任何控制器开销；仅考虑扫描移位和每个图形所需的两个全速功能时钟周期。\n\n将最终答案表示为包含 $S$、$L$、$N$、$f_s$ 和 $f_c$ 的单个封闭形式解析表达式。以秒为单位给出总时间。题目未提供数值，请勿引入近似。答案必须是单个表达式。如果需要进行数值计算，题目会指示您四舍五入到指定的有效数字位数，但此处无需四舍五入。",
            "solution": "首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- $S$：并行扫描链的数量。\n- $L$：$S$ 条并行扫描链的最大长度（以触发器为单位）。\n- $f_s$：扫描移位时钟频率。\n- $N$：确定性测试图形的数量。\n- $f_c$：功能时钟频率。\n- 架构：STUMPS（采用多输入特征寄存器和并行移位寄存器序列生成器的自测试）。\n- 测试方法：用于转换故障覆盖的全速发射-捕获。\n- 发射-捕获持续时间：每个图形两个功能时钟周期，即 $2/f_c$ 秒。\n- 重叠条件：连续测试图形的扫描输入和扫描输出完全重叠（流水线操作）。\n- 排除项：初始扫描填充和最终扫描清空是重叠操作的例外。MISR 特征读出时间和控制器开销将被忽略。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于 STUMPS BIST 架构，这是 VLSI 测试和可测性设计（DFT）领域中一种标准且有详细文档记录的技术。所有概念，包括扫描链、MISR、发射-捕获测试和时钟频率，都是基础性的且应用正确。\n- **问题定义良好**：该问题定义良好。它提供了所有必要的变量（$L$、$N$、$f_s$、$f_c$），并清晰地定义了操作序列和假设（例如，流水线操作、忽略的开销）。这使得推导一个唯一的封闭形式解成为可能。关于 $L$ 是最大链长的澄清至关重要，并且是并行扫描架构的标准做法。\n- **客观性**：问题陈述语言精确、客观且技术性强，没有含糊不清或主观的论断。\n\n### 步骤3：结论与行动\n该问题被认为是**有效的**，因为它科学合理、定义良好且客观。将从第一性原理推导解答。\n\n### 解的推导\n\n施加 $N$ 个测试图形的总时间 $T_{total}$ 是所有顺序操作持续时间的总和，从扫描输入第一个图形开始，到扫描输出最后一个响应结束。我们逐步分析事件序列。\n\n测试过程包括一系列交替的扫描和捕获阶段。总时间可以分解为所有扫描阶段的总时间和所有捕获阶段的总时间。\n\n1.  **总捕获时间 ($T_{capture\\_total}$)**\n    每个测试图形都需要一个独立的发射-捕获序列，该序列消耗 $2$ 个功能时钟周期。共有 $N$ 个测试图形，因此有 $N$ 个捕获阶段。\n    单个捕获阶段的持续时间为 $\\frac{2}{f_c}$。\n    因此，总捕获时间为：\n    $$T_{capture\\_total} = N \\times \\frac{2}{f_c} = \\frac{2N}{f_c}$$\n\n2.  **总扫描时间 ($T_{scan\\_total}$)**\n    扫描操作以流水线方式进行，但整个序列始于一次初始扫描填充，终于一次最终扫描清空。\n    - **初始扫描填充**：加载第一个测试图形 ($P_1$) 需要 $L$ 个扫描时钟周期。\n    - **流水线扫描**：对于接下来的 $N-1$ 个图形（从 $P_2$ 到 $P_N$），每个图形的加载都与前一个图形响应的卸载重叠。这构成了 $N-1$ 个流水线扫描阶段，每个阶段需要 $L$ 个扫描时钟周期。\n    - **最终扫描清空**：在最后一个图形 ($P_N$) 的捕获之后，其响应 ($R_N$) 必须从扫描链中移出。这需要额外的 $L$ 个扫描时钟周期。\n\n    我们可以将整个扫描过程看作 $N+1$ 个长度为 $L$ 的顺序扫描块：一次初始填充， $N-1$ 次流水线扫描，以及一次最终清空。\n    总扫描块数 = $1 + (N-1) + 1 = N+1$。\n    单个扫描块的持续时间为 $\\frac{L}{f_s}$。\n    因此，总扫描时间为：\n    $$T_{scan\\_total} = (N+1) \\times \\frac{L}{f_s}$$\n\n3.  **总测试时间 ($T_{total}$)**\n    总测试时间是总扫描时间和总捕获时间的和。\n    $$T_{total} = T_{scan\\_total} + T_{capture\\_total}$$\n    $$T_{total} = \\frac{(N+1)L}{f_s} + \\frac{2N}{f_c}$$\n\n    需要注意的是，并行扫描链的数量 $S$ 并未出现在最终表达式中。这是正确的，因为所有 $S$ 条链的扫描操作是并行执行的。任何扫描操作的时间都由最长的链决定，其长度为 $L$。因此，由 $S > 1$ 提供的并行性增加了每个图形可以测试的电路部分，但并未改变施加一个有效长度为 $L$ 的图形所需的时间。\n\n最终的表达式是一个由指定变量构成的单一封闭形式方程。",
            "answer": "$$\\boxed{\\frac{(N+1)L}{f_s} + \\frac{2N}{f_c}}$$"
        },
        {
            "introduction": "内建自测试不仅用于逻辑电路，在嵌入式存储器的测试中也至关重要。这个练习将我们的注意力转移到存储器内建自测试（MBIST）上，特别是针对一种广泛使用的March测试算法。你的任务是基于一个详细的控制器时序模型，计算完成整个March测试所需的总时间。这项实践旨在训练你将复杂的算法步骤和控制器开销转化为精确时序计算的能力，这对设计高效的MBIST解决方案至关重要。",
            "id": "4258802",
            "problem": "考虑一个用于同步静态随机存取存储器（SRAM）的内建自测试（BIST）控制器，该存储器有$N$个字，每个字宽为$W$位。该控制器以时钟频率$f$（单位为$\\mathrm{s}^{-1}$）运行。存储器接口是面向字的，但为了面积效率，BIST的数据生成和响应分析是按位串行实现的：在控制器监督下，每个字的读或写都作为$W$个连续的单比特操作来执行。假设每次单比特操作需要一个控制器时钟周期。\n\nBIST按以下方式在整个地址空间上执行一个包含四个元素的March测试：\n\n1. 元素$\\mathrm{E}_1$：按地址升序，在每个地址执行一次全零数据的写操作。\n2. 元素$\\mathrm{E}_2$：按地址升序，在每个地址依次执行一次全零数据的读操作、一次全一数据的写操作、一次全一数据的读操作和一次全零数据的写操作。\n3. 元素$\\mathrm{E}_3$：按地址降序，在每个地址依次执行一次全零数据的读操作、一次全一数据的写操作和一次全一数据的读操作。\n4. 元素$\\mathrm{E}_4$：按地址升序，在每个地址依次执行一次全一数据的读操作和一次全零数据的写操作。\n\n对BIST控制器和地址生成器使用以下时序模型：\n\n- 每次单比特读或写操作恰好消耗$1$个控制器周期。因此，一次字级读或写操作恰好消耗$W$个控制器周期。\n- 在任何March元素内，地址生成器在连续地址之间移动$\\pm 1$步，除了数据操作周期外，每步会产生额外的$c_{\\mathrm{a}} = 1$个控制器周期的开销。\n- 在第一个March元素开始时，加载基地址会产生$c_{\\mathrm{s}} = 2$个控制器周期的开销。\n- 在每个后续March元素开始时，对微码进行重定时会产生$c_{\\mathrm{e}} = 1$个控制器周期的开销。\n- 在连续元素之间每次地址遍历方向反转时，控制器会执行一次流水线刷新和基地址加载，产生$c_{\\mathrm{d}} = 5$个控制器周期的开销。\n\n假设存储器是单端口的，且控制器以非重叠方式调度操作，因此所有开销周期都与数据操作周期线性相加。\n\n仅从以上定义和标准观察（即总测试时间等于总控制器周期数除以$f$）出发，推导出一个关于总测试时间（以秒为单位）的闭式表达式，该表达式是$N$、$W$和$f$的函数。请将您的最终答案表示为关于$N$、$W$和$f$的单个解析表达式。您无需提供数值近似值。",
            "solution": "为了推导总测试时间 $T$，我们首先计算所需的总控制器时钟周期数 $C_{total}$，然后使用关系式 $T = C_{total} / f$。$C_{total}$ 由三部分组成：数据操作周期 ($C_{data}$)、地址步进开销周期 ($C_{addr}$) 和设置/转换开销周期 ($C_{setup}$)。\n\n### 1. 数据操作周期 ($C_{data}$)\n我们首先计算在所有 $N$ 个地址上执行的字级操作总数。\n- 元素 $\\mathrm{E}_1$：每个地址1次写操作。\n- 元素 $\\mathrm{E}_2$：每个地址4次操作（读、写、读、写）。\n- 元素 $\\mathrm{E}_3$：每个地址3次操作（读、写、读）。\n- 元素 $\\mathrm{E}_4$：每个地址2次操作（读、写）。\n\n每个地址的操作总数 = $1 + 4 + 3 + 2 = 10$ 次操作。\n由于有 $N$ 个地址，并且每次字级操作消耗 $W$ 个周期，因此总数据操作周期为：\n$$ C_{data} = 10 \\times N \\times W = 10NW $$\n\n### 2. 地址步进开销周期 ($C_{addr}$)\n每个March元素都遍历全部 $N$ 个地址，这需要从一个地址移动到下一个地址 $N-1$ 次。\n- 总共有4个March元素，因此有4次完整的地址遍历。\n- 总的地址步数 = $4 \\times (N-1)$。\n- 每一步的开销是 $c_a = 1$ 个周期。\n总地址步进开销为：\n$$ C_{addr} = 4 \\times (N-1) \\times c_a = 4(N-1) \\times 1 = 4N - 4 $$\n\n### 3. 设置和转换开销周期 ($C_{setup}$)\n这是所有一次性或转换性开销的总和。\n- **初始设置**：在 $\\mathrm{E}_1$ 开始时，有 $c_s = 2$ 个周期的开销。\n- **元素间重定时**：对于 $\\mathrm{E}_2$、$\\mathrm{E}_3$ 和 $\\mathrm{E}_4$ 这3个后续元素，每个都有 $c_e = 1$ 个周期的开销。总计 $3 \\times 1 = 3$ 周期。\n- **方向反转**：地址遍历方向发生两次反转：\n  1.  从 $\\mathrm{E}_2$ (升序) 到 $\\mathrm{E}_3$ (降序)。\n  2.  从 $\\mathrm{E}_3$ (降序) 到 $\\mathrm{E}_4$ (升序)。\n  每次反转产生 $c_d = 5$ 个周期的开销。总计 $2 \\times 5 = 10$ 周期。\n总设置和转换开销为：\n$$ C_{setup} = c_s + 3c_e + 2c_d = 2 + 3 + 10 = 15 $$\n\n### 4. 总周期数和总时间\n现在，我们将所有周期数相加得到 $C_{total}$：\n$$ C_{total} = C_{data} + C_{addr} + C_{setup} $$\n$$ C_{total} = 10NW + (4N - 4) + 15 $$\n$$ C_{total} = 10NW + 4N + 11 $$\n\n最后，总测试时间 $T$ 是总周期数除以时钟频率 $f$：\n$$ T = \\frac{C_{total}}{f} = \\frac{10NW + 4N + 11}{f} $$",
            "answer": "$$ \\boxed{ \\frac{10NW + 4N + 11}{f} } $$"
        },
        {
            "introduction": "一个BIST方案的优劣不仅取决于测试时间，更在于其测试质量，即发现故障的能力。最后一个练习将带你深入BIST的概率分析层面，探讨如何量化和提升对“随机图形抗性故障”的检测能力。你将通过从第一性原理出发，计算加权随机图形生成（WRPG）相比于传统伪随机测试在检测特定故障上的优势，并最终推导出包含多输入特征寄存器（MISR）混叠效应的最终故障覆盖率。这个练习将BIST架构与底层的故障模型和测试有效性紧密联系起来。",
            "id": "4258760",
            "problem": "一个组合逻辑块使用内置自测试（BIST）进行测试。测试图形源是一个线性反馈移位寄存器（LFSR），它被增强为一个加权随机图形生成器（WRPG），以将一个特定的主输入（表示为 $x$）偏置为逻辑 $1$ 的概率为 $p$，而所有其他输入保持无偏置，其为逻辑 $0$ 或逻辑 $1$ 的概率均为 $0.5$。考虑 $x$ 上的一个固定为 $0$ 的单一故障，该故障具有随机图形抗性，因为其影响必须被激活，并通过一条敏化路径传播到一个观测点。在敏化路径的相关段中，有 $k$ 个旁路输入驱动着逻辑门，这些逻辑门的非控制值为逻辑 $0$，并且只有当这 $k$ 个旁路输入同时为逻辑 $0$ 时，该路径才被敏化。假设如下：\n- 除了对 $x$ 的单一偏置外，所有主输入上的值在不同图形间是独立同分布的。\n- 在不同图形间，值是独立的，并从相同的分布中抽取。\n- 响应由一个长度为 $m$ 位的多输入特征寄存器（MISR）进行压缩。假设一个在 $\\mathrm{GF}(2)$ 上的线性 MISR，其中，在任何非零错误序列进入 MISR 的条件下，发生混叠（最终特征与无故障响应的特征相同）的概率为 $2^{-m}$，并且与施加的图形数量 $N$ 无关。\n使用独立伯努利试验的核心定义和重复独立试验的补集法则，从第一性原理推导以下量：\n1. 当控制输入 $x$ 被偏置为逻辑 $1$ 的概率为 $p$ 时，与无偏置情况下逻辑 $1$ 的概率为 $0.5$ 相比，每个图形的检测概率的改进比率。\n2. 施加 $N$ 个独立图形后的预期故障覆盖率，其中包含了激活和传播要求以及 MISR 混叠行为。\n将两个结果表示为关于 $p$、$k$、$m$ 和 $N$ 的闭式解析表达式。将您的最终答案以一个包含改进比率和覆盖率表达式的两元行向量的形式提供。不需要进行数值计算或四舍五入，最终答案中也不应包含任何单位。",
            "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n- 一个组合逻辑块使用内置自测试（BIST）进行测试。\n- 测试图形源是一个加权随机图形生成器（WRPG）。\n- 一个特定的主输入 $x$ 被偏置为逻辑 $1$ 的概率为 $p$。\n- 所有其他主输入都是无偏置的，其为逻辑 $0$ 或逻辑 $1$ 的概率均为 $0.5$。\n- 考虑输入 $x$ 上的一个固定为 $0$ 的单一故障。\n- 该故障是随机图形抗性的。\n- 故障激活要求输入 $x$ 为逻辑 $1$。\n- 故障传播要求 $k$ 个旁路输入同时为逻辑 $0$。\n- 除了对 $x$ 的偏置外，所有主输入上的值在不同图形间是独立同分布的。\n- 不同图形间的值是独立的。\n- 响应由一个长度为 $m$ 位的多输入特征寄存器（MISR）进行压缩。\n- MISR 在 $\\mathrm{GF}(2)$ 上是线性的。\n- 在给定非零错误序列的情况下，混叠的条件概率为 $2^{-m}$。\n- 混叠概率与施加的图形数量 $N$ 无关。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于数字逻辑测试的既定原则，特别是 BIST 架构。诸如 WRPG、固定型故障、路径敏化和 MISR 混叠等概念是 VLSI 设计与测试领域的标准内容。\n- **适定性：** 所有必要的变量（$p$、$k$、$m$、$N$）和条件都已明确定义。用于故障检测和混叠的概率模型已清晰说明，从而可以得出一个唯一且有意义的解。\n- **客观性：** 问题陈述使用了精确的技术语言，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n问题是有效的。它在科学上是合理的，具有适定性和客观性。将按要求从第一性原理推导求解。\n\n### 推导\n\n求解需要推导两个量：一个改进比率和预期的故障覆盖率。\n\n**1. 每个图形检测概率的改进比率**\n\n通过单个测试图形检测输入 $x$ 上的固定为 $0$ 故障需要同时满足两个条件：\n1.  **激活：** 故障点必须被设置为与固定值相反的值。对于 $x$ 上的固定为 $0$ 故障，这要求 $x=1$。\n2.  **传播：** 故障的影响必须传播到一个观测点。问题陈述指出，这当且仅当 $k$ 个特定的旁路输入都为逻辑 $0$ 时才会发生。\n\n设 $P_d$ 为每个图形的检测概率。根据独立事件的概率原理，$P_d$ 是激活概率和传播概率的乘积。\n$$P_d = P(\\text{activation}) \\times P(\\text{propagation})$$\n\n我们来计算有偏置和无偏置两种情况下的这些概率。\n\n**无偏置情况：**\n在无偏置情况下，每个主输入为逻辑 $1$ 的概率均为 $0.5$。\n- 激活概率为 $P(\\text{activation, unbiased}) = P(x=1) = 0.5 = 2^{-1}$。\n- $k$ 个旁路输入也是无偏置的。单个旁路输入为逻辑 $0$ 的概率是 $0.5$。由于这些输入是独立的，所有 $k$ 个旁路输入同時为逻辑 $0$ 的概率是：\n  $$P(\\text{propagation}) = (0.5)^k = \\left(\\frac{1}{2}\\right)^k = 2^{-k}$$\n- 因此，在无偏置情况下，每个图形的检测概率是：\n  $$P_{d, \\text{unbiased}} = P(\\text{activation, unbiased}) \\times P(\\text{propagation}) = 2^{-1} \\times 2^{-k} = 2^{-(k+1)}$$\n\n**有偏置情况：**\n在有偏置情况下，WRPG 将输入 $x$ 为逻辑 $1$ 的概率设置为 $p$。所有其他输入保持无偏置。\n- 激活概率为 $P(\\text{activation, biased}) = P(x=1) = p$。\n- 传播概率不变，因为假定 $k$ 个旁路输入与 $x$ 不同并且保持无偏置：\n  $$P(\\text{propagation}) = 2^{-k}$$\n- 因此，在有偏置情况下，每个图形的检测概率是：\n  $$P_{d, \\text{biased}} = P(\\text{activation, biased}) \\times P(\\text{propagation}) = p \\cdot 2^{-k}$$\n\n**改进比率：**\n改进比率 $R$ 是有偏置情况下的每个图形检测概率与无偏置情况下该概率的比值。\n$$R = \\frac{P_{d, \\text{biased}}}{P_{d, \\text{unbiased}}} = \\frac{p \\cdot 2^{-k}}{2^{-(k+1)}} = \\frac{p \\cdot 2^{-k}}{2^{-1} \\cdot 2^{-k}} = \\frac{p}{2^{-1}} = 2p$$\n这是第一个要求的结果。\n\n**2. N个图形后的预期故障覆盖率**\n\n故障覆盖率 $FC$ 是在施加一个包含 $N$ 个独立测试图形的序列后，故障被检测到的概率。这意味着故障必须被至少一个图形敏化，并且这种敏化不能被 MISR 混叠所掩盖。\n\n首先，我们确定在 $N$ 个图形中故障至少被敏化一次的概率。如果一个图形既激活又传播了故障，则发生敏化。在有偏置的 BIST 设置中，单个图形发生这种情况的概率是 $P_{d, \\text{biased}} = p \\cdot 2^{-k}$。\n\n施加 $N$ 个图形构成一个包含 $N$ 次独立伯努利试验的序列，其中“成功”指的是故障被敏化。\n- 单次试验中敏化的概率是 $q = p \\cdot 2^{-k}$。\n- 单次试验中*未*能敏化故障的概率是 $1-q = 1 - p \\cdot 2^{-k}$。\n- 在所有 $N$ 次独立试验中均未能敏化故障的概率是 $(1-q)^N = (1 - p \\cdot 2^{-k})^N$。\n\n使用补集法则，在 $N$ 次试验中至少敏化故障一次的概率（我们将此事件称为 $S_{\\ge 1}$）是：\n$$P(S_{\\ge 1}) = 1 - (1 - p \\cdot 2^{-k})^N$$\n\n接下来，我们必须考虑 MISR 混叠。问题陈述指出，在非零错误序列进入 MISR 的条件下，混叠的概率是 $P_{\\text{alias}} = 2^{-m}$。一个“非零错误序列”等同于故障至少被敏化一次（事件 $S_{\\ge 1}$）。\n\n如果故障被敏化（事件 $S_{\\ge 1}$）并且没有发生混叠，则该故障被成功检测和覆盖。设 $A$ 为混叠事件。我们想要求解概率 $P(S_{\\ge 1} \\cap A^c)$，其中 $A^c$ 是 $A$ 的补集（无混叠）。\n\n根据条件概率的定义，$P(S_{\\ge 1} \\cap A^c) = P(A^c | S_{\\ge 1}) \\times P(S_{\\ge 1})$。\n- 在发生敏化的条件下，不发生混叠的概率是：\n  $$P(A^c | S_{\\ge 1}) = 1 - P(A | S_{\\ge 1}) = 1 - P_{\\text{alias}} = 1 - 2^{-m}$$\n- 我们已经推導出了 $P(S_{\\ge 1})$。\n\n因此，最终的故障覆盖率 $FC$ 是：\n$$FC = P(S_{\\ge 1} \\cap A^c) = (1 - 2^{-m}) \\times P(S_{\\ge 1})$$\n$$FC = (1 - 2^{-m}) \\left[1 - (1 - p \\cdot 2^{-k})^N\\right]$$\n这是第二个要求的结果。对于单个故障，“预期故障覆盖率”一词等同于其检测概率，也就是我们计算得出的值。\n\n最终答案将两个结果合并为一个两元行向量。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2p & (1 - 2^{-m})\\left(1 - \\left(1 - p \\cdot 2^{-k}\\right)^N\\right) \\end{pmatrix} } $$"
        }
    ]
}