{
    "hands_on_practices": [
        {
            "introduction": "This first exercise grounds us in the fundamental technique of Combinational Equivalence Checking (CEC). We will construct a 'miter' circuit, which formally captures the difference between two designs. The core challenge here  is to perform this check not over all possible inputs, but within a constrained 'care set', reflecting realistic operating environments where only certain input combinations are possible or relevant.",
            "id": "4270275",
            "problem": "Consider two combinational circuits $C_{A}$ and $C_{B}$ over Boolean inputs $a$, $b$, $c$, $d$, $e \\in \\{0,1\\}$, each producing two outputs. Circuit $C_{A}$ has outputs\n- $o_{1}^{A} = a \\oplus b \\oplus (c \\wedge d) \\oplus e$,\n- $o_{2}^{A} = (a \\wedge c) \\oplus (b \\wedge d) \\oplus e$,\nand circuit $C_{B}$ has outputs\n- $o_{1}^{B} = a \\oplus b \\oplus (c \\wedge \\neg d) \\oplus e$,\n- $o_{2}^{B} = (a \\wedge c) \\oplus (b \\wedge \\neg d) \\oplus e$,\nwhere $\\oplus$ denotes exclusive OR (XOR), $\\wedge$ denotes logical AND, $\\vee$ denotes logical OR, and $\\neg$ denotes logical NOT.\n\nYou will check equivalence under a restricted input environment, called the care set. The care set $\\mathcal{C}$ is defined by the following constraints on the inputs:\n- Exactly $3$ of the variables in $\\{a,b,c,d,e\\}$ are equal to $1$.\n- The input $d$ is functionally constrained by $d = a \\oplus e$.\n\nUsing only the foundational definition of Combinational Equivalence Checking (CEC) and the canonical miter construction from Boolean algebra, determine the exact number of input assignments in the care set $\\mathcal{C}$ for which $C_{A}$ and $C_{B}$ are not equivalent. Provide your final answer as a single integer. No rounding is required and no physical units apply.",
            "solution": "To determine when the two circuits, $C_{A}$ and $C_{B}$, are not equivalent, we use the canonical miter construction. Two combinational circuits are equivalent if and only if their corresponding outputs are identical for all possible input assignments within the care set. They are not equivalent for a specific input assignment if at least one pair of corresponding outputs differs.\n\nThe miter circuit's output, let's call it $M$, is a Boolean function that evaluates to $1$ if the circuits are not equivalent, and $0$ if they are. For circuits with multiple outputs, the miter output is the logical OR of the XOR difference of each corresponding output pair.\nIn this case, with two outputs for each circuit, the miter function is:\n$$M = (o_{1}^{A} \\oplus o_{1}^{B}) \\vee (o_{2}^{A} \\oplus o_{2}^{B})$$\nWe need to find the number of input assignments $(a,b,c,d,e)$ in the care set $\\mathcal{C}$ for which $M=1$.\n\nFirst, let's simplify the two XOR terms in the expression for $M$.\nFor the first pair of outputs:\n$$o_{1}^{A} \\oplus o_{1}^{B} = (a \\oplus b \\oplus (c \\wedge d) \\oplus e) \\oplus (a \\oplus b \\oplus (c \\wedge \\neg d) \\oplus e)$$\nUsing the associative and commutative properties of XOR, and the identity $x \\oplus x = 0$:\n$$o_{1}^{A} \\oplus o_{1}^{B} = (a \\oplus a) \\oplus (b \\oplus b) \\oplus (e \\oplus e) \\oplus (c \\wedge d) \\oplus (c \\wedge \\neg d)$$\n$$o_{1}^{A} \\oplus o_{1}^{B} = 0 \\oplus 0 \\oplus 0 \\oplus (c \\wedge d) \\oplus (c \\wedge \\neg d)$$\n$$o_{1}^{A} \\oplus o_{1}^{B} = c \\wedge (d \\oplus \\neg d)$$\nSince for any Boolean variable $x$, $x \\oplus \\neg x = 1$, we have $d \\oplus \\neg d = 1$.\n$$o_{1}^{A} \\oplus o_{1}^{B} = c \\wedge 1 = c$$\n\nFor the second pair of outputs:\n$$o_{2}^{A} \\oplus o_{2}^{B} = ((a \\wedge c) \\oplus (b \\wedge d) \\oplus e) \\oplus ((a \\wedge c) \\oplus (b \\wedge \\neg d) \\oplus e)$$\nSimilarly,\n$$o_{2}^{A} \\oplus o_{2}^{B} = ((a \\wedge c) \\oplus (a \\wedge c)) \\oplus (e \\oplus e) \\oplus (b \\wedge d) \\oplus (b \\wedge \\neg d)$$\n$$o_{2}^{A} \\oplus o_{2}^{B} = 0 \\oplus 0 \\oplus (b \\wedge d) \\oplus (b \\wedge \\neg d)$$\n$$o_{2}^{A} \\oplus o_{2}^{B} = b \\wedge (d \\oplus \\neg d)$$\n$$o_{2}^{A} \\oplus o_{2}^{B} = b \\wedge 1 = b$$\n\nSubstituting these simplified expressions back into the miter function $M$:\n$$M = c \\vee b$$\nThus, the circuits $C_A$ and $C_B$ are not equivalent for a given input assignment if and only if the condition $b \\vee c = 1$ is satisfied. This is equivalent to stating that at least one of the variables $b$ or $c$ must be equal to $1$.\n\nThe problem now reduces to counting the number of input vectors $(a,b,c,d,e)$ that satisfy the constraints of the care set $\\mathcal{C}$ AND the non-equivalence condition $b \\vee c = 1$. The care set $\\mathcal{C}$ is defined by:\n1.  The Hamming weight of the input vector is $3$. That is, the arithmetic sum $a+b+c+d+e = 3$.\n2.  The functional constraint $d = a \\oplus e$.\n\nWe need to find the size of the set of vectors $(a,b,c,d,e)$ satisfying:\n1.  $a+b+c+d+e = 3$\n2.  $d = a \\oplus e$\n3.  $b \\vee c = 1$\n\nLet's analyze the constraints on the care set $\\mathcal{C}$ first. We can enumerate the valid assignments by considering the possible values for the pair $(a,e)$, which in turn determines the value of $d$.\n\nCase 1: $(a,e) = (0,0)$.\nFrom the functional constraint, $d = a \\oplus e = 0 \\oplus 0 = 0$.\nThe values of these three variables are $(a,d,e) = (0,0,0)$. Their contribution to the Hamming weight is $0$.\nThe Hamming weight constraint becomes $a+b+c+d+e = 0+b+c+0+0 = 3$, so $b+c = 3$.\nSince $b,c \\in \\{0,1\\}$, the maximum value of $b+c$ is $2$. Thus, $b+c=3$ is impossible. There are $0$ assignments in this case.\n\nCase 2: $(a,e) = (0,1)$.\nFrom the functional constraint, $d = a \\oplus e = 0 \\oplus 1 = 1$.\nThe values of these three variables are $(a,d,e) = (0,1,1)$. Their contribution to the Hamming weight is $2$.\nThe Hamming weight constraint becomes $a+b+c+d+e = 0+b+c+1+1 = 3$, so $b+c = 1$.\nThis condition is satisfied by two pairs of values for $(b,c)$: $(1,0)$ and $(0,1)$.\nThis gives us two valid input vectors in the care set:\n-   $(a,b,c,d,e) = (0,1,0,1,1)$\n-   $(a,b,c,d,e) = (0,0,1,1,1)$\nThere are $2$ such assignments.\n\nCase 3: $(a,e) = (1,0)$.\nFrom the functional constraint, $d = a \\oplus e = 1 \\oplus 0 = 1$.\nThe values of these three variables are $(a,d,e) = (1,1,0)$. Their contribution to the Hamming weight is $2$.\nThe Hamming weight constraint becomes $a+b+c+d+e = 1+b+c+1+0 = 3$, so $b+c = 1$.\nThis is satisfied by $(b,c)=(1,0)$ and $(b,c)=(0,1)$.\nThis gives us two valid input vectors in the care set:\n-   $(a,b,c,d,e) = (1,1,0,1,0)$\n-   $(a,b,c,d,e) = (1,0,1,1,0)$\nThere are $2$ such assignments.\n\nCase 4: $(a,e) = (1,1)$.\nFrom the functional constraint, $d = a \\oplus e = 1 \\oplus 1 = 0$.\nThe values of these three variables are $(a,d,e) = (1,0,1)$. Their contribution to the Hamming weight is $2$.\nThe Hamming weight constraint becomes $a+b+c+d+e = 1+b+c+0+1 = 3$, so $b+c = 1$.\nThis is satisfied by $(b,c)=(1,0)$ and $(b,c)=(0,1)$.\nThis gives us two valid input vectors in the care set:\n-   $(a,b,c,d,e) = (1,1,0,0,1)$\n-   $(a,b,c,d,e) = (1,0,1,0,1)$\nThere are $2$ such assignments.\n\nIn total, the number of input assignments in the care set $\\mathcal{C}$ is the sum of the counts from each case: $0+2+2+2 = 6$.\nThe care set is $\\mathcal{C} = \\{(0,1,0,1,1), (0,0,1,1,1), (1,1,0,1,0), (1,0,1,1,0), (1,1,0,0,1), (1,0,1,0,1)\\}$.\n\nNow we must check for how many of these $6$ assignments the non-equivalence condition $M = b \\vee c = 1$ holds.\nLooking back at our case analysis, every single valid assignment in the care set was derived from the condition $b+c=1$.\nIf $b+c=1$ (where $b, c$ are Booleans), it must be that one variable is $1$ and the other is $0$.\nFor any such pair of values, the condition $b \\vee c = 1$ is satisfied.\nFor example, if $(b,c)=(1,0)$, then $b \\vee c = 1 \\vee 0 = 1$.\nIf $(b,c)=(0,1)$, then $b \\vee c = 0 \\vee 1 = 1$.\nTherefore, for all $6$ input assignments that constitute the care set $\\mathcal{C}$, the non-equivalence condition $b \\vee c = 1$ is met.\n\nThis means that for every input vector in the care set, the circuits $C_A$ and $C_B$ are not equivalent.\nThe number of such input assignments is the total size of the care set, which is $6$.\n\nAlternatively, we could have determined that any vector in $\\mathcal{C}$ must satisfy $b \\vee c = 1$. Assume for contradiction that a vector $(a,b,c,d,e) \\in \\mathcal{C}$ exists for which $b \\vee c = 0$. This implies $b=0$ and $c=0$. The Hamming weight constraint $a+b+c+d+e=3$ then simplifies to $a+d+e=3$. For Boolean variables, this requires $a=1$, $d=1$, and $e=1$. However, these values contradict the second care set constraint, $d=a \\oplus e$, because $1 \\oplus 1 = 0 \\neq 1$. Therefore, no vector in $\\mathcal{C}$ can have $b=0$ and $c=0$. It follows that all vectors in $\\mathcal{C}$ must satisfy $b \\vee c=1$. The problem is then equivalent to finding the size of $\\mathcal{C}$, which we have calculated to be $6$.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "Moving beyond standard Boolean methods, this practice explores an elegant and powerful algebraic approach to equivalence checking. By modeling logic gates as polynomial equations over the finite field $\\mathbb{F}_2$, we transform the verification problem into the domain of computer algebra. This exercise  will have you use polynomial reduction, a core technique related to Gröbner bases, to formally prove the equivalence of two circuits.",
            "id": "4270272",
            "problem": "Consider equivalence checking of two combinational hardware circuits modeled over the finite field $\\mathbb{F}_{2}$ using algebraic methods. The polynomial ring is $R = \\mathbb{F}_{2}[x_{1}, x_{2}, x_{3}, a_{1}, a_{2}, a_{3}, s_{1}, p_{1}, p_{2}, y_{A}, y_{B}]$. Each gate is encoded as a polynomial of the form $z + h(\\text{inputs})$ in $R$, which enforces the constraint $z = h(\\text{inputs})$ over $\\mathbb{F}_{2}$. The Boolean semantics are enforced for primary inputs by the field polynomials $x_{i}^{2} + x_{i}$ for $i \\in \\{1,2,3\\}$.\n\nCircuit $\\mathcal{C}_{A}$ has an output $y_{A}$ and is defined by the following gate polynomials:\n- $g_{1}: a_{1} + x_{1} x_{2}$,\n- $g_{2}: a_{2} + x_{1} x_{3}$,\n- $g_{3}: a_{3} + x_{2} x_{3}$,\n- $g_{4}: y_{A} + a_{1} + a_{2} + a_{3}$.\n\nCircuit $\\mathcal{C}_{B}$ has an output $y_{B}$ and is defined by the following gate polynomials:\n- $h_{1}: s_{1} + x_{1} + x_{2}$,\n- $h_{2}: p_{1} + x_{1} x_{2}$,\n- $h_{3}: p_{2} + s_{1} x_{3}$,\n- $h_{4}: y_{B} + p_{1} + p_{2}$.\n\nLet $G$ be the set of the above eight gate polynomials together with the three field polynomials $x_{1}^{2} + x_{1}$, $x_{2}^{2} + x_{2}$, $x_{3}^{2} + x_{3}$. Consider the lexicographic term order $\\succ$ on $R$ given by\n$$\ny_{A} \\succ y_{B} \\succ a_{1} \\succ a_{2} \\succ a_{3} \\succ s_{1} \\succ p_{1} \\succ p_{2} \\succ x_{1} \\succ x_{2} \\succ x_{3}.\n$$\nForm the miter polynomial $m = y_{A} + y_{B} \\in R$.\n\nStarting only from fundamental definitions of polynomial ideals and reduction in $\\mathbb{F}_{2}$, compute the unique reduced normal form (remainder) of $m$ upon multivariate polynomial division by $G$ under the given term order $\\succ$. Express your final answer as a single closed-form algebraic expression in the ring $R$ over $\\mathbb{F}_{2}$. No rounding is required, and no units apply. Your final answer must be a single expression.",
            "solution": "The problem requires the computation of the unique reduced normal form of the miter polynomial $m = y_{A} + y_{B}$ with respect to a given set of polynomials $G$ and a lexicographic term order $\\succ$. This is a standard procedure in algebraic hardware verification, where two circuits are proven equivalent if and only if their miter polynomial reduces to zero within the ideal generated by the polynomials defining the circuit constraints. The computation is performed in the polynomial ring $R = \\mathbb{F}_{2}[x_{1}, x_{2}, x_{3}, a_{1}, a_{2}, a_{3}, s_{1}, p_{1}, p_{2}, y_{A}, y_{B}]$. All arithmetic is in the finite field $\\mathbb{F}_{2}$, where $1+1=0$.\n\nThe process of finding the normal form is multivariate polynomial division. A polynomial $p$ is reduced by a set of divisor polynomials $G = \\{g_1, g_2, \\dots, g_k\\}$. A single reduction step replaces $p$ with $p' = p + \\frac{T}{LT(g_i)} g_i$, where $T$ is a term in $p$ that is divisible by the leading term $LT(g_i)$ of some polynomial $g_i \\in G$. This process is repeated until no term in the resulting polynomial is divisible by any leading term from $G$. The final, irreducible polynomial is the normal form, or remainder. The uniqueness of the result is guaranteed because the provided set of gate polynomials, structured as definitions for new variables, forms a Gröbner basis with respect to the specified term order.\n\nThe term order is given as $\\succ$:\n$$\ny_{A} \\succ y_{B} \\succ a_{1} \\succ a_{2} \\succ a_{3} \\succ s_{1} \\succ p_{1} \\succ p_{2} \\succ x_{1} \\succ x_{2} \\succ x_{3}\n$$\n\nThe set of polynomials $G$ consists of eleven polynomials. We list them along with their leading terms (LT) with respect to $\\succ$:\n1.  $g_{4}: y_{A} + a_{1} + a_{2} + a_{3}$, with $LT(g_{4}) = y_{A}$\n2.  $h_{4}: y_{B} + p_{1} + p_{2}$, with $LT(h_{4}) = y_{B}$\n3.  $g_{1}: a_{1} + x_{1} x_{2}$, with $LT(g_{1}) = a_{1}$\n4.  $g_{2}: a_{2} + x_{1} x_{3}$, with $LT(g_{2}) = a_{2}$\n5.  $g_{3}: a_{3} + x_{2} x_{3}$, with $LT(g_{3}) = a_{3}$\n6.  $h_{1}: s_{1} + x_{1} + x_{2}$, with $LT(h_{1}) = s_{1}$\n7.  $h_{2}: p_{1} + x_{1} x_{2}$, with $LT(h_{2}) = p_{1}$\n8.  $h_{3}: p_{2} + s_{1} x_{3}$, with $LT(h_{3}) = p_{2}$\n9.  $f_1: x_{1}^{2} + x_{1}$, with $LT(f_1) = x_{1}^{2}$\n10. $f_2: x_{2}^{2} + x_{2}$, with $LT(f_2) = x_{2}^{2}$\n11. $f_3: x_{3}^{2} + x_{3}$, with $LT(f_3) = x_{3}^{2}$\n\nWe start with the miter polynomial $m = y_{A} + y_{B}$ and sequentially reduce it.\n\nStep 1: The initial polynomial is $P_{0} = y_{A} + y_{B}$. The leading term of $P_0$ is $y_{A}$, which is equal to $LT(g_{4})$. We reduce $P_0$ using $g_{4}$:\n$$\nP_{1} = P_{0} + g_{4} = (y_{A} + y_{B}) + (y_{A} + a_{1} + a_{2} + a_{3}) = y_{B} + a_{1} + a_{2} + a_{3}\n$$\n\nStep 2: The leading term of $P_{1}$ is $y_{B}$, which is $LT(h_{4})$. We reduce $P_{1}$ using $h_{4}$:\n$$\nP_{2} = P_{1} + h_{4} = (y_{B} + a_{1} + a_{2} + a_{3}) + (y_{B} + p_{1} + p_{2}) = a_{1} + a_{2} + a_{3} + p_{1} + p_{2}\n$$\n\nStep 3: The leading term of $P_{2}$ is $a_{1}$ (since $a_{1} \\succ a_{2} \\succ a_{3} \\succ p_{1} \\succ p_{2}$), which is $LT(g_{1})$. We reduce $P_{2}$ using $g_{1}$:\n$$\nP_{3} = P_{2} + g_{1} = (a_{1} + a_{2} + a_{3} + p_{1} + p_{2}) + (a_{1} + x_{1} x_{2}) = a_{2} + a_{3} + p_{1} + p_{2} + x_{1} x_{2}\n$$\n\nStep 4: The leading term of $P_{3}$ is $a_{2}$, which is $LT(g_{2})$. We reduce $P_{3}$ using $g_{2}$:\n$$\nP_{4} = P_{3} + g_{2} = (a_{2} + a_{3} + p_{1} + p_{2} + x_{1} x_{2}) + (a_{2} + x_{1} x_{3}) = a_{3} + p_{1} + p_{2} + x_{1} x_{2} + x_{1} x_{3}\n$$\n\nStep 5: The leading term of $P_{4}$ is $a_{3}$, which is $LT(g_{3})$. We reduce $P_{4}$ using $g_{3}$:\n$$\nP_{5} = P_{4} + g_{3} = (a_{3} + p_{1} + p_{2} + x_{1} x_{2} + x_{1} x_{3}) + (a_{3} + x_{2} x_{3}) = p_{1} + p_{2} + x_{1} x_{2} + x_{1} x_{3} + x_{2} x_{3}\n$$\n\nStep 6: The leading term of $P_{5}$ is $p_{1}$, which is $LT(h_{2})$. We reduce $P_{5}$ using $h_{2}$:\n$$\nP_{6} = P_{5} + h_{2} = (p_{1} + p_{2} + x_{1} x_{2} + x_{1} x_{3} + x_{2} x_{3}) + (p_{1} + x_{1} x_{2}) = p_{2} + x_{1} x_{3} + x_{2} x_{3} + (x_{1}x_{2} + x_{1}x_{2}) = p_{2} + x_{1} x_{3} + x_{2} x_{3}\n$$\n\nStep 7: The leading term of $P_{6}$ is $p_{2}$, which is $LT(h_{3})$. We reduce $P_{6}$ using $h_{3}$:\n$$\nP_{7} = P_{6} + h_{3} = (p_{2} + x_{1} x_{3} + x_{2} x_{3}) + (p_{2} + s_{1} x_{3}) = s_{1} x_{3} + x_{1} x_{3} + x_{2} x_{3}\n$$\n\nStep 8: The leading term of $P_{7}$ is $s_{1} x_{3}$ because $s_{1}$ is the highest-ordered variable present. This term is divisible by $LT(h_{1}) = s_{1}$. We reduce $P_{7}$ using $h_{1}$:\n$$\nP_{8} = P_{7} + x_{3} \\cdot h_{1} = (s_{1} x_{3} + x_{1} x_{3} + x_{2} x_{3}) + x_{3}(s_{1} + x_{1} + x_{2})\n$$\nDistributing $x_{3}$ gives:\n$$\nP_{8} = s_{1} x_{3} + x_{1} x_{3} + x_{2} x_{3} + s_{1} x_{3} + x_{1} x_{3} + x_{2} x_{3}\n$$\nCombining like terms in $\\mathbb{F}_{2}$:\n$$\nP_{8} = (1+1)s_{1} x_{3} + (1+1)x_{1} x_{3} + (1+1)x_{2} x_{3} = 0 \\cdot s_{1} x_{3} + 0 \\cdot x_{1} x_{3} + 0 \\cdot x_{2} x_{3} = 0\n$$\n\nThe polynomial has been reduced to $0$. There are no non-zero terms left to reduce. Throughout the process, no terms of degree $2$ or higher in any single variable $x_i$ were generated, so the field polynomials $x_{i}^{2} + x_{i}$ were not needed for any reduction. The unique reduced normal form of $m$ is $0$. This implies that $y_{A} + y_{B} \\in I(G)$, where $I(G)$ is the ideal generated by the polynomials in $G$. Consequently, on the variety defined by $G$, the functions represented by $y_A$ and $y_B$ are identical, meaning the circuits $\\mathcal{C}_{A}$ and $\\mathcal{C}_{B}$ are functionally equivalent.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Our final practice tackles a subtle but critical aspect of hardware modeling: the handling of unknown states. In simulation and formal analysis, an 'unknown' or '$X$' value is often used to represent uninitialized registers or abstracted parts of a design. This exercise  delves into the formal relationship between the 4-valued logic used in simulators ($\\{0, 1, X, Z\\}$) and the strict 2-valued logic ($\\{0, 1\\}$) that defines correctness, revealing what can and cannot be soundly inferred.",
            "id": "4270282",
            "problem": "Consider two gate-level combinational netlists, denoted by $C_1$ and $C_2$, each implementing a vector Boolean function from $n$ primary inputs to $m$ primary outputs. Let the underlying two-valued domain be $B = \\{0,1\\}$ and the four-valued domain be $V = \\{0,1,X,Z\\}$. In four-valued evaluation, treat the high-impedance value $Z$ as unknown, that is, for logic evaluation, identify $Z$ with $X$. Assume all gates are evaluated under the standard four-valued semantics used in Electronic Design Automation (EDA) simulation for bitwise logic in hardware description languages: for example, for bitwise $\\land$ (AND), $0 \\land v = 0$, $1 \\land v = v$, $X \\land 0 = 0$, $X \\land 1 = X$, and $X \\land X = X$; for bitwise $\\lor$ (OR), $1 \\lor v = 1$, $0 \\lor v = v$, $X \\lor 0 = X$, $X \\lor 1 = 1$, and $X \\lor X = X$; for bitwise $\\oplus$ (XOR), $0 \\oplus v = v$, $1 \\oplus v = \\neg v$, and $X \\oplus v = X$ whenever $v \\in \\{0,1,X\\}$; and for bitwise negation, $\\neg 0 = 1$, $\\neg 1 = 0$, and $\\neg X = X$.\n\nDefine the miter circuit $M$ that compares $C_1$ and $C_2$ by computing a single-bit output\n$$\nM(u) \\;=\\; \\bigvee_{i=1}^{m} \\left( y_{1,i}(u) \\oplus y_{2,i}(u) \\right),\n$$\nwhere $y_{1,i}(u)$ and $y_{2,i}(u)$ denote the $i$-th outputs of $C_1$ and $C_2$ respectively, evaluated on input vector $u$. The standard two-valued notion of equivalence is that $C_1$ and $C_2$ are equivalent if, for all $b \\in B^n$, $M(b) = 0$ under two-valued evaluation.\n\nTo relate four-valued and two-valued semantics, define the concretization function $\\gamma: V \\to \\mathcal{P}(B)$ by $\\gamma(0) = \\{0\\}$, $\\gamma(1) = \\{1\\}$, and $\\gamma(X) = \\gamma(Z) = \\{0,1\\}$. Extend $\\gamma$ pointwise to vectors, so that for $u \\in V^n$, $\\gamma(u) \\subseteq B^n$ is the set of all two-valued completions consistent with $u$. Define the abstraction function $\\alpha: \\mathcal{P}(B) \\to V$ on singleton sets by $\\alpha(\\{0\\}) = 0$, $\\alpha(\\{1\\}) = 1$, and on the set $\\{0,1\\}$ by $\\alpha(\\{0,1\\}) = X$, and extend $\\alpha$ pointwise to vectors. Assume the gate semantics are monotone with respect to the information ordering in which $X$ (and $Z$) represent less information than $0$ or $1$, so four-valued evaluation is an over-approximation of all two-valued completions: for any expression $E$ composed of the above gates and any $u \\in V^n$, every $b \\in \\gamma(u)$ satisfies $E(b) \\in \\gamma(E(u))$.\n\nUnder these assumptions, consider the following statements about using four-valued evaluation to infer two-valued equivalence of $C_1$ and $C_2$:\n\nA. If for all $u \\in V^n$, the four-valued miter evaluates to $M(u) = 0$, then for all $b \\in B^n$, the two-valued miter evaluates to $M(b) = 0$. Hence, $C_1$ and $C_2$ are equivalent under two-valued semantics.\n\nB. If $C_1$ and $C_2$ are equivalent under two-valued semantics (that is, for all $b \\in B^n$, $M(b) = 0$), then for all $u \\in V^n$, the four-valued miter evaluates to $M(u) = 0$.\n\nC. To prove that $C_1$ and $C_2$ are not equivalent, it suffices to find one $u \\in V^n$ such that under four-valued evaluation, $M(u) = 1$; this implies that for all $b \\in \\gamma(u)$, the two-valued miter evaluates to $M(b) = 1$, and thus $C_1$ and $C_2$ are inequivalent.\n\nD. For sequential netlists with uninitialized registers modeled as $X$ at time $t = 0$, replacing every $X$ input at time $t = 0$ by $0$ and checking two-valued equivalence over time proves equivalence that is sound and complete for all uninitialized behaviors.\n\nWhich of the above statements are sound in the sense of yielding valid inferences about two-valued equivalence or inequivalence from four-valued evaluation, given the stated semantics and assumptions? Select all that apply.",
            "solution": "The problem statement describes a formal framework for relating a four-valued logic, commonly used in hardware simulation, to the standard two-valued Boolean logic that defines the functional correctness of a circuit. The core of this relationship is the monotonicity assumption, which states that for any circuit (expression) $E$ and any four-valued input vector $u \\in V^n$, the two-valued evaluation on any concretization $b \\in \\gamma(u)$ is consistent with the four-valued evaluation on $u$. Formally, for all $b \\in \\gamma(u)$, it holds that $E(b) \\in \\gamma(E(u))$.\n\nThe concretization function $\\gamma$ is defined as $\\gamma(0) = \\{0\\}$, $\\gamma(1) = \\{1\\}$, and $\\gamma(X) = \\gamma(Z) = \\{0,1\\}$. This implies the following key properties for an expression $E$:\n1. If $E(u)$ evaluates to $0$ in the four-valued domain, then for all corresponding two-valued input vectors $b \\in \\gamma(u)$, the expression $E(b)$ must evaluate to $0$. This is because $\\gamma(0) = \\{0\\}$.\n2. If $E(u)$ evaluates to $1$ in the four-valued domain, then for all $b \\in \\gamma(u)$, $E(b)$ must evaluate to $1$. This is because $\\gamma(1) = \\{1\\}$.\n3. If $E(u)$ evaluates to $X$ in the four-valued domain, then for any $b \\in \\gamma(u)$, $E(b)$ may evaluate to either $0$ or $1$. This is because $\\gamma(X) = \\{0,1\\}$. This case provides no definite information about the two-valued behavior.\n\nThe miter circuit $M$ is defined such that its output is $M(u) = \\bigvee_{i=1}^{m} (y_{1,i}(u) \\oplus y_{2,i}(u))$. The two-valued equivalence of circuits $C_1$ and $C_2$ is defined as $M(b) = 0$ for all $b \\in B^n$.\n\nLet us evaluate each statement based on these principles.\n\nA. If for all $u \\in V^n$, the four-valued miter evaluates to $M(u) = 0$, then for all $b \\in B^n$, the two-valued miter evaluates to $M(b) = 0$. Hence, $C_1$ and $C_2$ are equivalent under two-valued semantics.\n\nThis statement describes a sound, though impractically strong, condition for proving equivalence.\nLet's assume the premise is true: for all $u \\in V^n$, $M(u)=0$. We want to prove that for all $b \\in B^n$, $M(b)=0$.\nConsider the specific input vector $u_X \\in V^n$ where every component is $X$. The set of all possible two-valued input vectors, $B^n$, is the concretization of this vector: $\\gamma(u_X) = B^n$.\nAccording to the premise, for this specific vector $u_X$, we must have $M(u_X)=0$ in the four-valued evaluation.\nNow, we apply the given monotonicity property with $E=M$ and $u=u_X$. The property states that for every $b \\in \\gamma(u_X)$, it must be that $M(b) \\in \\gamma(M(u_X))$.\nSubstituting our values, for every $b \\in B^n$, it must be that $M(b) \\in \\gamma(0)$.\nSince $\\gamma(0) = \\{0\\}$, this implies that for every $b \\in B^n$, $M(b)$ must be $0$.\nThis is precisely the definition of two-valued equivalence for $C_1$ and $C_2$. Thus, the inference is valid.\n\nVerdict: **Correct**.\n\nB. If $C_1$ and $C_2$ are equivalent under two-valued semantics (that is, for all $b \\in B^n$, $M(b) = 0$), then for all $u \\in V^n$, the four-valued miter evaluates to $M(u) = 0$.\n\nThis statement is the converse of statement A. It claims that two-valued equivalence implies that the four-valued miter output is always $0$. This is generally false because four-valued logic may yield $X$ when it cannot determine a definite $0$ or $1$.\nConsider a simple counterexample. Let $n=1$, $m=1$. Let $C_1$ implement the function $y_1(a) = a$ and $C_2$ implement $y_2(a) = \\neg(\\neg a)$.\nIn two-valued logic ($a \\in B$), $\\neg(\\neg a) = a$, so the circuits are equivalent. The miter output $M(b) = b \\oplus (\\neg(\\neg b)) = b \\oplus b = 0$ for all $b \\in B^1$. The premise holds.\nNow, let's evaluate the miter for the four-valued input $u=X$.\nThe output of $C_1$ is $y_1(X) = X$.\nThe output of $C_2$ is $y_2(X) = \\neg(\\neg X)$. According to the given semantics, $\\neg X = X$, so $y_2(X) = \\neg X = X$.\nThe miter output is $M(X) = y_1(X) \\oplus y_2(X) = X \\oplus X$.\nThe semantics for XOR state that $X \\oplus v = X$. Thus, $X \\oplus X = X$.\nSince $M(X) = X \\neq 0$, the conclusion \"for all $u \\in V^n$, $M(u)=0$\" is false. Therefore, the implication is invalid. This illustrates that four-valued evaluation can lose information, resulting in an $X$ output even for equivalent circuits.\n\nVerdict: **Incorrect**.\n\nC. To prove that $C_1$ and $C_2$ are not equivalent, it suffices to find one $u \\in V^n$ such that under four-valued evaluation, $M(u) = 1$; this implies that for all $b \\in \\gamma(u)$, the two-valued miter evaluates to $M(b) = 1$, and thus $C_1$ and $C_2$ are inequivalent.\n\nThis statement describes using four-valued evaluation to find counterexamples to equivalence.\nLet's assume we have found a $u \\in V^n$ such that $M(u) = 1$.\nWe use the monotonicity property again: for every $b \\in \\gamma(u)$, we must have $M(b) \\in \\gamma(M(u))$.\nSince $M(u)=1$, we have $\\gamma(M(u)) = \\gamma(1) = \\{1\\}$.\nThis means that for every $b \\in \\gamma(u)$, the two-valued evaluation must result in $M(b) = 1$.\nSince $u \\in V^n$, the set $\\gamma(u)$ is non-empty. Therefore, there exists at least one two-valued input vector $b$ for which $M(b)=1$.\nThe existence of such a $b$ where $M(b) \\neq 0$ is the definition of two-valued inequivalence.\nThus, finding a single $u \\in V^n$ for which $M(u) = 1$ is a sound proof of inequivalence. The logic presented in the statement is entirely correct.\n\nVerdict: **Correct**.\n\nD. For sequential netlists with uninitialized registers modeled as $X$ at time $t = 0$, replacing every $X$ input at time $t = 0$ by $0$ and checking two-valued equivalence over time proves equivalence that is sound and complete for all uninitialized behaviors.\n\nThis statement extends the discussion to sequential circuits. Equivalence for \"all uninitialized behaviors\" means the circuits must be equivalent for every possible initial state of the registers. Modeling the uninitialized state with $X$ values correctly captures this uncertainty.\nThe proposed method is to check equivalence for only one specific initial state, the all-zeros state. The statement claims this is a \"sound and complete\" method for proving equivalence for ALL initial states.\n\nLet's analyze soundness. A proof method for equivalence is sound if it never declares inequivalent circuits to be equivalent.\nConsider two sequential circuits, $C_1$ and $C_2$, each with one register $Q$. The output is the register value.\nLet the next-state logic be:\n- $C_1$: $Q_{next} = 0$\n- $C_2$: $Q_{next} = Q_{current}$\nThe proposed method checks starting from the initial state $Q(0)=0$ for both.\n- For $t=0$, outputs are $Q_1(0)=0$ and $Q_2(0)=0$. They match.\n- For $t=1$, $Q_1(1)=0$ and $Q_2(1)=Q_2(0)=0$. They match.\n- For all subsequent time steps, both registers will remain $0$. So, the circuits are deemed equivalent by this method.\n\nNow, let's consider a different initial state, $Q(0)=1$.\n- For $t=0$, outputs are $Q_1(0)=1$ and $Q_2(0)=1$. They match.\n- For $t=1$, $Q_1(1)=0$ and $Q_2(1)=Q_2(0)=1$. The outputs are now different ($0$ vs $1$).\nThe circuits are not equivalent for all uninitialized behaviors. However, the proposed method declared them equivalent. This is a false positive. Therefore, the method is **unsound**.\n\nA method that is not sound is not a valid proof method. The claim that it is \"sound and complete\" is false because it is not sound.\n\nVerdict: **Incorrect**.",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}