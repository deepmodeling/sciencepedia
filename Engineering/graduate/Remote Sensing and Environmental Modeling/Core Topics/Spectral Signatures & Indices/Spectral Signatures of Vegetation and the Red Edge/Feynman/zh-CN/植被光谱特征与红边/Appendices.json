{
    "hands_on_practices": [
        {
            "introduction": "多光谱传感器在离散的波段上提供数据，而植被的许多关键光谱特征（如红边位置）本质上是连续谱上的概念。本练习旨在通过应用线性插值法，将红边位置的定义从一个连续的光谱概念转化为一个可根据具体波段反射率计算的实用公式。这项基本功训练对于任何希望从遥感数据中定量提取生物物理参数的研究生都至关重要 。",
            "id": "3854886",
            "problem": "一台多光谱卫星传感器测量了一个植被像元在红光和近红外区域四个波段中心的冠层顶光谱反射率：$670$ 纳米、$700$ 纳米、$740$ 纳米和 $780$ 纳米。设相应经过大气校正的反射率分别表示为 $R_{670}$、$R_{700}$、$R_{740}$ 和 $R_{780}$，其中每个 $R_{\\lambda}$ 代表对连续冠层顶反射率函数 $R(\\lambda)$ 的波段中心近似。在红边区域，由于叶绿素的吸收和叶片内部的散射，植被光谱通常表现为从红光吸收区到近红外平台的反射率单调增加的过渡，并且根据经验观察，对于健康的植被冠层，在 $700$ 纳米和 $740$ 纳米之间的波段通常近似线性。\n\n将红边位置 (REP) 定义为波长 $\\lambda_{\\mathrm{REP}}$，在该波长处的反射率等于在 $670$ 纳米和 $780$ 纳米处测得的反射率的算术平均值，即满足 $R(\\lambda_{\\mathrm{REP}}) = \\frac{R_{670} + R_{780}}{2}$ 且 $\\lambda_{\\mathrm{REP}} \\in [700, 740]$ 纳米的波长。从反射率作为波长的函数的定义以及 $R(\\lambda)$ 在区间 $[700, 740]$ 上呈线性的假设出发，推导出一个关于 $\\lambda_{\\mathrm{REP}}$ 的闭式解析表达式，该表达式用 $R_{670}$、$R_{700}$、$R_{740}$ 和 $R_{780}$ 以及标称波段中心 $700$ 和 $740$ 纳米来表示。陈述你所使用的任何数学关系，并以纳米为单位表示你关于 $\\lambda_{\\mathrm{REP}}$ 的最终公式。不需要进行数值计算或四舍五入；提供一个单一的符号表达式。",
            "solution": "### 解答推导\n这个问题的核心在于假设光谱反射率函数 $R(\\lambda)$ 在区间 $[\\lambda_1, \\lambda_2]$上是线性的，其中 $\\lambda_1 = 700$ nm 且 $\\lambda_2 = 740$ nm。在这些波长处的相应反射率是 $R(\\lambda_1) = R_{700}$ 和 $R(\\lambda_2) = R_{740}$。\n\n我们可以使用直线方程的两点式来表示该区间内任意波长 $\\lambda$ 的线性关系。这种形式特别适用于插值。对于两点 $(\\lambda_1, R_1)$ 和 $(\\lambda_2, R_2)$，方程为：\n$$R(\\lambda) = R_1 + (\\lambda - \\lambda_1) \\frac{R_2 - R_1}{\\lambda_2 - \\lambda_1}$$\n代入我们的特定点 $(700, R_{700})$ 和 $(740, R_{740})$，在指定区间内的反射率方程变为：\n$$R(\\lambda) = R_{700} + (\\lambda - 700) \\frac{R_{740} - R_{700}}{740 - 700}$$\n分母简化为 $40$：\n$$R(\\lambda) = R_{700} + (\\lambda - 700) \\frac{R_{740} - R_{700}}{40}$$\n问题将红边位置 $\\lambda_{\\mathrm{REP}}$ 定义为这样一个波长，在该波长处的反射率 $R(\\lambda_{\\mathrm{REP}})$ 等于一个特定值，我们将其表示为 $R_{\\mathrm{target}}$。这个目标反射率定义为在 $670$ nm 和 $780$ nm 处反射率的算术平均值：\n$$R_{\\mathrm{target}} = \\frac{R_{670} + R_{780}}{2}$$\n为了找到 $\\lambda_{\\mathrm{REP}}$，我们在我们的线性模型中设 $R(\\lambda_{\\mathrm{REP}}) = R_{\\mathrm{target}}$。由于问题陈述 $\\lambda_{\\mathrm{REP}} \\in [700, 740]$，我们的线性模型是适用的。\n$$\\frac{R_{670} + R_{780}}{2} = R_{700} + (\\lambda_{\\mathrm{REP}} - 700) \\frac{R_{740} - R_{700}}{40}$$\n我们现在必须解此方程以求得 $\\lambda_{\\mathrm{REP}}$。首先，我们通过从两边减去 $R_{700}$ 来分离出含有 $\\lambda_{\\mathrm{REP}}$ 的项：\n$$\\frac{R_{670} + R_{780}}{2} - R_{700} = (\\lambda_{\\mathrm{REP}} - 700) \\frac{R_{740} - R_{700}}{40}$$\n为了简化左边，我们进行通分：\n$$\\frac{R_{670} + R_{780} - 2R_{700}}{2} = (\\lambda_{\\mathrm{REP}} - 700) \\frac{R_{740} - R_{700}}{40}$$\n接下来，我们通过两边同乘以斜率项的倒数 $\\frac{40}{R_{740} - R_{700}}$ 来分离出 $(\\lambda_{\\mathrm{REP}} - 700)$ 项：\n$$\\lambda_{\\mathrm{REP}} - 700 = \\left( \\frac{R_{670} + R_{780} - 2R_{700}}{2} \\right) \\left( \\frac{40}{R_{740} - R_{700}} \\right)$$\n简化数值常数 ($40/2 = 20$)：\n$$\\lambda_{\\mathrm{REP}} - 700 = 20 \\left( \\frac{R_{670} + R_{780} - 2R_{700}}{R_{740} - R_{700}} \\right)$$\n最后，我们通过在方程两边同时加上 $700$ 来得到 $\\lambda_{\\mathrm{REP}}$ 的闭式表达式：\n$$\\lambda_{\\mathrm{REP}} = 700 + 20 \\frac{R_{670} + R_{780} - 2R_{700}}{R_{740} - R_{700}}$$\n该表达式基于四个反射率测量值以及光谱在 $700$ nm 和 $740$ nm 之间呈线性行为的假设，给出了以纳米为单位的红边位置。它是直接从线性插值原理推导出来的。",
            "answer": "$$\n\\boxed{700 + 20 \\frac{R_{670} + R_{780} - 2R_{700}}{R_{740} - R_{700}}}\n$$"
        },
        {
            "introduction": "计算出植被指数（如归一化红边指数NDRE）的值仅仅是分析的第一步；评估其可靠性同样关键。本练习将引导你应用一阶泰勒展开法来推导NDRE的不确定性，这一过程不仅考虑了原始近红外和红边波段反射率测量的不确定性（分别为 $\\sigma_{\\mathrm{NIR}}$ 和 $\\sigma_{\\mathrm{RE}}$），还包含了它们之间的相关性 $\\rho$。掌握不确定性传播  是确保遥感产品科学有效性并进行可靠时空比较的核心技能。",
            "id": "3854890",
            "problem": "一台星载成像光谱仪测量冠层顶部的近红外波段和红边波段的双向反射因子。设近红外（NIR）反射率为随机变量 $X$，其均值为 $r_{\\mathrm{NIR}}$，标准不确定度为 $\\sigma_{\\mathrm{NIR}}$；设红边（RE）反射率为随机变量 $Y$，其均值为 $r_{\\mathrm{RE}}$，标准不确定度为 $\\sigma_{\\mathrm{RE}}$。假设由于共同的定标和大气路径效应，$X$ 和 $Y$ 的相关系数为 $\\rho$，并且它们的联合变异性可以很好地由一个具有较小相对不确定度的二元正态分布来近似。\n\n归一化差异红边（NDRE）指数定义为反射率之比\n$$\n\\mathrm{NDRE} = \\frac{X - Y}{X + Y}.\n$$\n\n从随机变量的可微函数的一阶泰勒展开以及方差、协方差和相关性的定义出发，推导 $\\mathrm{NDRE}$ 的一阶传播标准不确定度，记为 $u_{\\mathrm{NDRE}} = \\sqrt{\\operatorname{Var}(\\mathrm{NDRE})}$，其形式为一个以 $r_{\\mathrm{NIR}}$、$r_{\\mathrm{RE}}$、$\\sigma_{\\mathrm{NIR}}$、$\\sigma_{\\mathrm{RE}}$ 和 $\\rho$ 表示的闭式解析表达式。在您的推理中，明确地考虑 $X$ 和 $Y$ 之间的相关性对不确定度的影响。将最终答案表示为一个无量纲量。无需进行四舍五入。",
            "solution": "### 解答推导\n推导基于两个相关随机变量的可微函数 $f(X, Y)$ 的不确定度传播，方法是使用在其均值 $\\mu_X = r_{\\mathrm{NIR}}$ 和 $\\mu_Y = r_{\\mathrm{RE}}$ 附近的一阶泰勒级数展开。$f(X, Y)$ 的方差通用公式由下式给出：\n$$\n\\operatorname{Var}(f(X, Y)) \\approx \\left(\\frac{\\partial f}{\\partial X}\\right)^2 \\operatorname{Var}(X) + \\left(\\frac{\\partial f}{\\partial Y}\\right)^2 \\operatorname{Var}(Y) + 2 \\left(\\frac{\\partial f}{\\partial X}\\right) \\left(\\frac{\\partial f}{\\partial Y}\\right) \\operatorname{Cov}(X, Y)\n$$\n其中偏导数在均值 $(\\mu_X, \\mu_Y)$ 处进行求值。\n\n所需的统计矩如下：\n$\\operatorname{Var}(X) = \\sigma_{\\mathrm{NIR}}^2$\n$\\operatorname{Var}(Y) = \\sigma_{\\mathrm{RE}}^2$\n协方差由相关系数 $\\rho$ 定义：\n$\\operatorname{Cov}(X, Y) = \\rho \\sqrt{\\operatorname{Var}(X)\\operatorname{Var}(Y)} = \\rho \\sigma_{\\mathrm{NIR}} \\sigma_{\\mathrm{RE}}$\n\n所讨论的函数是 NDRE 指数：\n$$\nf(X, Y) = \\frac{X - Y}{X + Y}\n$$\n\n首先，我们计算 $f(X, Y)$ 对 $X$ 和 $Y$ 的偏导数。\n\n使用商法则，对 $X$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial X} = \\frac{(1)(X + Y) - (X - Y)(1)}{(X + Y)^2} = \\frac{X + Y - X + Y}{(X + Y)^2} = \\frac{2Y}{(X + Y)^2}\n$$\n\n类似地，对 $Y$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial Y} = \\frac{(-1)(X + Y) - (X - Y)(1)}{(X + Y)^2} = \\frac{-X - Y - X + Y}{(X + Y)^2} = \\frac{-2X}{(X + Y)^2}\n$$\n\n接下来，我们在变量的均值处，即 $X = r_{\\mathrm{NIR}}$ 和 $Y = r_{\\mathrm{RE}}$ 处，对这些偏导数进行求值：\n$$\n\\left.\\frac{\\partial f}{\\partial X}\\right|_{(\\mu_X, \\mu_Y)} = \\frac{2r_{\\mathrm{RE}}}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^2}\n$$\n$$\n\\left.\\frac{\\partial f}{\\partial Y}\\right|_{(\\mu_X, \\mu_Y)} = \\frac{-2r_{\\mathrm{NIR}}}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^2}\n$$\n\n现在，我们将这些表达式和统计矩代入方差传播公式：\n$$\n\\operatorname{Var}(\\mathrm{NDRE}) \\approx \\left(\\frac{2r_{\\mathrm{RE}}}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^2}\\right)^2 \\sigma_{\\mathrm{NIR}}^2 + \\left(\\frac{-2r_{\\mathrm{NIR}}}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^2}\\right)^2 \\sigma_{\\mathrm{RE}}^2 + 2 \\left(\\frac{2r_{\\mathrm{RE}}}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^2}\\right) \\left(\\frac{-2r_{\\mathrm{NIR}}}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^2}\\right) (\\rho \\sigma_{\\mathrm{NIR}} \\sigma_{\\mathrm{RE}})\n$$\n\n简化各项：\n$$\n\\operatorname{Var}(\\mathrm{NDRE}) \\approx \\frac{4r_{\\mathrm{RE}}^2 \\sigma_{\\mathrm{NIR}}^2}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^4} + \\frac{4r_{\\mathrm{NIR}}^2 \\sigma_{\\mathrm{RE}}^2}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^4} - \\frac{8 \\rho r_{\\mathrm{NIR}} r_{\\mathrm{RE}} \\sigma_{\\mathrm{NIR}} \\sigma_{\\mathrm{RE}}}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^4}\n$$\n\n提出公分母和常数 $4$：\n$$\n\\operatorname{Var}(\\mathrm{NDRE}) \\approx \\frac{4}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^4} \\left( r_{\\mathrm{RE}}^2 \\sigma_{\\mathrm{NIR}}^2 + r_{\\mathrm{NIR}}^2 \\sigma_{\\mathrm{RE}}^2 - 2 \\rho r_{\\mathrm{NIR}} r_{\\mathrm{RE}} \\sigma_{\\mathrm{NIR}} \\sigma_{\\mathrm{RE}} \\right)\n$$\n\n标准不确定度 $u_{\\mathrm{NDRE}}$ 是方差的平方根：\n$$\nu_{\\mathrm{NDRE}} = \\sqrt{\\operatorname{Var}(\\mathrm{NDRE})} \\approx \\sqrt{\\frac{4}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^4} \\left( r_{\\mathrm{RE}}^2 \\sigma_{\\mathrm{NIR}}^2 + r_{\\mathrm{NIR}}^2 \\sigma_{\\mathrm{RE}}^2 - 2 \\rho r_{\\mathrm{NIR}} r_{\\mathrm{RE}} \\sigma_{\\mathrm{NIR}} \\sigma_{\\mathrm{RE}} \\right)}\n$$\n\n对前置因子取平方根，得到传播标准不确定度的最终表达式：\n$$\nu_{\\mathrm{NDRE}} \\approx \\frac{2}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^2} \\sqrt{r_{\\mathrm{RE}}^2 \\sigma_{\\mathrm{NIR}}^2 + r_{\\mathrm{NIR}}^2 \\sigma_{\\mathrm{RE}}^2 - 2 \\rho r_{\\mathrm{NIR}} r_{\\mathrm{RE}} \\sigma_{\\mathrm{NIR}} \\sigma_{\\mathrm{RE}}}\n$$\n量 $r$ 和 $\\sigma$ 代表无量纲的反射率值，而 $\\rho$ 是无量纲的。因此，得到的不确定度 $u_{\\mathrm{NDRE}}$ 也是一个无量纲量，与 NDRE 指数本身一致。该推导正确地包含了输入不确定度及其相关性的影响。",
            "answer": "$$\n\\boxed{\\frac{2}{(r_{\\mathrm{NIR}} + r_{\\mathrm{RE}})^{2}} \\sqrt{r_{\\mathrm{RE}}^{2} \\sigma_{\\mathrm{NIR}}^{2} + r_{\\mathrm{NIR}}^{2} \\sigma_{\\mathrm{RE}}^{2} - 2 \\rho r_{\\mathrm{NIR}} r_{\\mathrm{RE}} \\sigma_{\\mathrm{NIR}} \\sigma_{\\mathrm{RE}}}}\n$$"
        },
        {
            "introduction": "植被红边特征并非静止不变，它会随着物候周期和胁迫事件（如病害）而动态变化，而从平缓的物候背景中准确识别出突发的胁迫信号是遥感监测中的核心挑战。本综合练习要求你设计并实现一个完整的时间序列分析流程，用于从模拟的光谱数据中提取红边位置 $\\lambda_{\\mathrm{REP}}(t)$ 和红边斜率 $S(t)$，并构建统计模型以区分病害引起的突变与季节性的物候趋势。这项顶石实践  融合了编程、信号处理和统计分析，模拟了开发一个实用植被健康监测工具的真实研究过程。",
            "id": "3854871",
            "problem": "给定一个旨在表示红边区域的植被反射光谱的时间序列。反射率定义为上行辐射与下行辐照度的无量纲比值，记为 $R(\\lambda,t)$，其中 $\\lambda$ 是波长，$t$ 是时间。关于波长的光谱导数为 $R'(\\lambda,t) = \\frac{\\partial R(\\lambda,t)}{\\partial \\lambda}$。植被表现出一个称为红边的强烈光谱过渡，通常在 $700\\,\\mathrm{nm}$ 和 $740\\,\\mathrm{nm}$ 之间，由于叶绿素吸收和叶片细胞结构，反射率从红光区域到近红外区域急剧增加。将时间 $t$ 的红边位置 $\\lambda_{\\mathrm{REP}}(t)$ 定义为在指定搜索区间内，使 $R'(\\lambda,t)$ 达到其最大值的波长 $\\lambda$，并将红边斜率 $S(t)$ 定义为搜索区间内对应的最大导数值 $S(t) = \\max_{\\lambda} R'(\\lambda,t)$。\n\n使用的基本原理：\n- 反射率 $R(\\lambda,t)$ 是无量纲的，并且物理上约束在 $0 \\le R \\le 1$。\n- 红边是一个具有强光谱梯度的区域，健康的植被通常具有较高的 $S(t)$ 和一个位于过渡区附近的 $\\lambda_{\\mathrm{REP}}(t)$。\n- 减少叶绿素并改变叶片结构的病害往往会导致 $S(t)$ 下降以及 $\\lambda_{\\mathrm{REP}}(t)$ 向较短波长移动（蓝移），而物候趋势（季节性生长和衰老）则会随时间产生更平滑、渐进的变化。\n- 可以使用数值微分从采样光谱中近似计算 $R'(\\lambda,t)$，而时间平滑（例如，基于样条的平滑）可以估计物候基线。\n\n任务：\n- 设计并实现一个时间分析方法。该方法在给定围绕红边区域的、随时间变化的合成但物理上合理的反射光谱 $R(\\lambda,t)$ 的情况下，计算 $R'(\\lambda,t)$，在每个时间点估计 $\\lambda_{\\mathrm{REP}}(t)$ 和 $S(t)$，为 $\\lambda_{\\mathrm{REP}}(t)$ 和 $S(t)$ 构建平滑的物候基线，并通过识别与这些基线相比的突发性、统计上显著的负偏差（蓝移和斜率降低）来检测由病害引起的变化。通过要求偏差同时超过一个稳健的统计阈值和一个相对于基线随时间变化率的突变性标准，来区分病害引起的变化和物候趋势。\n\n检测标准（需实现）：\n- 设残差为 $\\Delta \\lambda(t) = \\lambda_{\\mathrm{REP}}(t) - \\hat{\\lambda}_{\\mathrm{REP}}(t)$ 和 $\\Delta S(t) = S(t) - \\hat{S}(t)$，其中 $\\hat{\\lambda}_{\\mathrm{REP}}(t)$ 和 $\\hat{S}(t)$ 分别是从 $\\lambda_{\\mathrm{REP}}(t)$ 和 $S(t)$ 估计出的平滑物候基线。\n- 使用中位数绝对偏差 (MAD) 从残差中估计稳健的尺度参数 $\\sigma_{\\lambda}$ 和 $\\sigma_{S}$，并将其缩放至高斯等效值，即 $\\sigma \\approx 1.4826 \\cdot \\mathrm{MAD}$。\n- 仅当以下所有条件在时间 $t$ 同时成立时，才标记为病害事件：\n  1. $\\Delta \\lambda(t)  -\\max(3 \\sigma_{\\lambda}, \\delta_{\\lambda})$，其中 $\\delta_{\\lambda}$ 是以纳米为单位表示的绝对最小蓝移阈值。\n  2. $\\Delta S(t)  -\\max(3 \\sigma_{S}, \\delta_{S})$，其中 $\\delta_{S}$ 是以反射率/纳米为单位表示的绝对最小斜率下降阈值。\n  3. $|\\Delta \\lambda(t)|$ 和 $|\\Delta S(t)|$ 各自超过一个突变性乘子与相应基线时间导数大小的乘积，即 $|\\Delta \\lambda(t)|  \\alpha \\left|\\frac{d \\hat{\\lambda}_{\\mathrm{REP}}}{dt}(t)\\right|$ 和 $|\\Delta S(t)|  \\alpha \\left|\\frac{d \\hat{S}}{dt}(t)\\right|$，其中 $\\alpha$ 是一个给定常数。\n\n搜索区间和单位：\n- 在 $[\\lambda_{\\min}, \\lambda_{\\max}] = [690\\,\\mathrm{nm}, 760\\,\\mathrm{nm}]$ 区间上搜索 $R'(\\lambda,t)$ 的最大值，以计算 $\\lambda_{\\mathrm{REP}}(t)$ 和 $S(t)$。\n- 波长必须以 $\\mathrm{nm}$ 表示，时间必须以整数时间步长（可解释为天）表示。\n- 任何报告的波长偏移必须以 $\\mathrm{nm}$ 为单位，并表示为十进制数。\n- 任何报告的斜率下降必须以反射率/$\\mathrm{nm}$ 为单位，并表示为十进制数。\n\n数据生成（程序内部实现，不接受外部输入）：\n- 对于每个测试用例，使用物理上合理的S型红边形状，在波长 $\\lambda \\in \\{680,681,\\ldots,780\\}\\,\\mathrm{nm}$ 和时间 $t \\in \\{0,1,\\ldots,T-1\\}$ 上生成合成光谱。\n- 使用平滑的季节性（物候）参数演变，加上具有指定标准差的加性高斯噪声，并可选择性地注入一个在指定持续时间内引起蓝移和斜率降低的病害事件。\n- 程序必须对每个时间 $t$ 沿 $\\lambda$ 实现数值微分，然后从导数中计算出 $\\lambda_{\\mathrm{REP}}(t)$ 和 $S(t)$。\n- 在微分之前，使用适当的波长平滑方法来减轻噪声。\n\n输出规格：\n- 对于每个测试用例，您的程序必须输出一个包含四项的列表，顺序如下：一个布尔值，指示是否检测到病害事件；一个整数，表示发病起始索引（如果未检测到则为-1）；估计的蓝移幅度，以 $\\mathrm{nm}$ 为单位的十进制数；以及估计的斜率下降值，以反射率/$\\mathrm{nm}$ 为单位的十进制数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表。每个测试用例的结果本身也是一个列表。例如：$[\\,[\\text{True},\\,12,\\,4.2,\\,0.0085],\\,[\\text{False},\\,-1,\\,0.0,\\,0.0]\\,]$。\n\n测试套件：\n实现您的解决方案，并在以下四个测试用例上对其进行评估，每个测试用例都必须由您的程序内部模拟：\n\n- 测试用例 1（健康植被，有物候变化，无病害）：\n  - 时间步数 $T = 60$。\n  - 噪声标准差 $\\sigma_{\\mathrm{noise}} = 0.002$（反射率单位）。\n  - 病害发作时间 $t_{\\mathrm{onset}} = \\text{None}$，病害持续时间 $D = 0$。\n  - 病害参数 $\\Delta \\lambda_{\\mathrm{d}} = 0\\,\\mathrm{nm}$ 和 $f_{k} = 1.0$（无变化）。\n  - 物候参数振幅：早期偏移振幅 $A_{1} = 3\\,\\mathrm{nm}$，晚期偏移振幅 $A_{2} = -2\\,\\mathrm{nm}$，早期斜率振幅 $B_{1} = -2$，晚期斜率振幅 $B_{2} = 1.5$。\n\n- 测试用例 2（季中明显病害，蓝移和斜率降低）：\n  - $T = 60$，$\\sigma_{\\mathrm{noise}} = 0.002$。\n  - $t_{\\mathrm{onset}} = 25$，$D = 5$。\n  - $\\Delta \\lambda_{\\mathrm{d}} = -5\\,\\mathrm{nm}$，$f_{k} = 1.5$。\n  - $A_{1} = 3\\,\\mathrm{nm}$，$A_{2} = -2\\,\\mathrm{nm}$，$B_{1} = -2$，$B_{2} = 1.5$。\n\n- 测试用例 3（临界胁迫，小幅蓝移和小幅斜率降低）：\n  - $T = 60$，$\\sigma_{\\mathrm{noise}} = 0.002$。\n  - $t_{\\mathrm{onset}} = 25$，$D = 4$。\n  - $\\Delta \\lambda_{\\mathrm{d}} = -2\\,\\mathrm{nm}$，$f_{k} = 1.1$。\n  - $A_{1} = 3\\,\\mathrm{nm}$，$A_{2} = -2\\,\\mathrm{nm}$，$B_{1} = -2$，$B_{2} = 1.5$。\n\n- 测试用例 4（强烈的季末物候变化，无病害）：\n  - $T = 60$，$\\sigma_{\\mathrm{noise}} = 0.002$。\n  - $t_{\\mathrm{onset}} = \\text{None}$，$D = 0$。\n  - $\\Delta \\lambda_{\\mathrm{d}} = 0\\,\\mathrm{nm}$，$f_{k} = 1.0$。\n  - $A_{1} = 3\\,\\mathrm{nm}$，$A_{2} = -4\\,\\mathrm{nm}$，$B_{1} = -2$，$B_{2} = 2.2$。\n\n使用的阈值常数：\n- 绝对最小蓝移阈值 $\\delta_{\\lambda} = 3.5\\,\\mathrm{nm}$。\n- 绝对最小斜率下降阈值 $\\delta_{S} = 0.007$（反射率/$\\mathrm{nm}$）。\n- 突变性乘子 $\\alpha = 3.0$。\n- 对 $\\Delta \\lambda(t)$ 和 $\\Delta S(t)$ 使用基于 MAD 的 $\\sigma$，稳健统计阈值为 $3\\sigma$。\n\n您的程序必须实现完整的处理流程，并按规定格式生成单行的列表嵌套列表输出。不允许外部输入，程序必须能直接运行。所有波长值必须以 $\\mathrm{nm}$ 处理，所有斜率值必须以反射率/$\\mathrm{nm}$ 处理。",
            "solution": "该问题要求设计并实现一个时间分析算法，通过分析光谱红边来检测植被中由病害引起的胁迫。该分析必须能区分突发的、显著的异常与平滑、渐进的物候趋势。该问题具有良好的科学基础，并提供了足够详细的信息来构建一个有效的解决方案，但这取决于为合成数据生成模型做出合理且符合物理实际的设计选择，正如“设计并实现”这一指令所暗示的。\n\n解决方案分为两个主要阶段：首先，生成合成但物理上真实的时间序列光谱数据；其次，分析这些数据以根据提供的标准检测病害事件。\n\n**1. 合成数据生成**\n\n为了测试检测算法，我们首先在一系列波长 $\\lambda$ 和时间步长 $t$ 上生成合成反射光谱 $R(\\lambda, t)$。红边使用逻辑S型函数（logistic sigmoid function）进行建模，该函数为反射率从红光到近红外波长的急剧增加提供了一个简单而有效的表示。\n\n在波长 $\\lambda$ 和时间 $t$ 的反射率 $R$ 建模如下：\n$$\nR(\\lambda, t) = R_{\\mathrm{soil}} + \\frac{R_{\\mathrm{veg}} - R_{\\mathrm{soil}}}{1 + \\exp(-k(t) (\\lambda - \\lambda_{0}(t)))} + \\epsilon(t)\n$$\n其中：\n- $R_{\\mathrm{soil}} \\approx 0.05$ 是土壤或衰老植被的基线反射率。\n- $R_{\\mathrm{veg}} \\approx 0.50$ 是健康植被的最大近红外反射率。\n- $\\lambda_{0}(t)$ 是S型曲线的拐点，对应于红边位置 $\\lambda_{\\mathrm{REP}}(t)$。其时间演变捕捉了物候变化和病害引起的偏移。\n- $k(t)$ 是陡峭度参数。红边的最大斜率 $S(t)$ 与 $k(t)$ 成正比：$S(t) = \\frac{d R}{d \\lambda}\\bigg|_{\\lambda=\\lambda_0} = \\frac{(R_{\\mathrm{veg}} - R_{\\mathrm{soil}}) k(t)}{4}$。其时间演变模拟了植被健康和活力的变化。\n- $\\epsilon(t)$ 是加性高斯噪声，$\\epsilon(t) \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{noise}}^2)$。\n\n参数 $\\lambda_0(t)$ 和 $k(t)$ 被建模为一个平滑的物候周期和一个可选的、突发的病害事件的叠加。物候周期使用两个高斯函数建模，以表示生长季早期和衰老季晚期，由测试用例参数 $A_1, A_2, B_1, B_2$ 控制。\n\n设 $T$ 为总时间步数。物候驱动因子为：\n$$\nf_{\\mathrm{early}}(t) = \\exp\\left(-\\frac{(t - T/3)^2}{2(T/8)^2}\\right) \\quad \\text{和} \\quad f_{\\mathrm{late}}(t) = \\exp\\left(-\\frac{(t - 2T/3)^2}{2(T/8)^2}\\right)\n$$\n那么，S型函数参数的物候分量为：\n$$\n\\lambda_{\\mathrm{pheno}}(t) = \\lambda_{\\mathrm{base}} + A_1 f_{\\mathrm{early}}(t) + A_2 f_{\\mathrm{late}}(t)\n$$\n$$\nk_{\\mathrm{pheno}}(t) = k_{\\mathrm{base}} \\left(1 + \\frac{B_1}{10} f_{\\mathrm{early}}(t) + \\frac{B_2}{10} f_{\\mathrm{late}}(t)\\right)\n$$\n在此我们设定一个基准红边位置 $\\lambda_{\\mathrm{base}} = 715\\,\\mathrm{nm}$ 和一个基准陡峭度 $k_{\\mathrm{base}} = 0.5\\,\\mathrm{nm}^{-1}$。参数 $B_1$ 和 $B_2$ 被缩放了10倍，以表示斜率在百分比级别上的合理变化。\n\n如果存在病害事件，则将其建模为一个从 $t_{\\mathrm{onset}}$ 开始、持续时间为 $D$ 的瞬态高斯脉冲。\n$$\nf_{\\mathrm{disease}}(t) = \\begin{cases} \\exp\\left(-\\frac{(t - (t_{\\mathrm{onset}} + D/2))^2}{2(D/3)^2}\\right)  \\text{if } t_{\\mathrm{onset}} \\le t \\le t_{\\mathrm{onset}} + D \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n病害对S型函数参数的影响如下：\n$$\n\\lambda_{\\mathrm{disease}}(t) = \\Delta\\lambda_{\\mathrm{d}} \\cdot f_{\\mathrm{disease}}(t)\n$$\n$$\nk_{\\mathrm{factor}}(t) = 1 + (f_k - 1) f_{\\mathrm{disease}}(t)\n$$\n其中 $\\Delta\\lambda_{\\mathrm{d}}$ 是最大蓝移量，$f_k$ 是斜率修正因子。$f_k  1$ 的值会降低有效陡峭度参数，从而减小红边斜率，这与植被胁迫的情况一致。\n\n最终的组合参数为：\n$$\n\\lambda_0(t) = \\lambda_{\\mathrm{pheno}}(t) + \\lambda_{\\mathrm{disease}}(t)\n$$\n$$\nk(t) = \\frac{k_{\\mathrm{pheno}}(t)}{k_{\\mathrm{factor}}(t)}\n$$\n这些参数用于生成反射率矩阵 $R(\\lambda, t)$，其中 $\\lambda \\in \\{680, 681, \\ldots, 780\\}\\,\\mathrm{nm}$ 且 $t \\in \\{0, 1, \\ldots, T-1\\}$。\n\n**2. 检测算法**\n\n分析流程处理生成的 $R(\\lambda, t)$ 矩阵以检测病害事件。\n\n**步骤 2.1：预处理与特征提取**\n对于每个时间步长 $t$，离散光谱 $R(\\lambda_i, t)$ 包含噪声。为了获得导数 $R'(\\lambda,t)$ 的稳健估计，我们首先使用Savitzky-Golay滤波器对光谱进行平滑处理并同时计算其导数。这是光谱学中的一项标准技术。我们应用一个窗口长度为15个样本、多项式阶数为3的滤波器。\n从得到的导数光谱 $R'(\\lambda, t)$ 中，我们在指定的搜索区间 $[\\lambda_{\\min}, \\lambda_{\\max}] = [690, 760]\\,\\mathrm{nm}$ 内找到最大值。\n- 红边位置 $\\lambda_{\\mathrm{REP}}(t)$ 是该最大值出现的波长。\n- 红边斜率 $S(t)$ 是该最大值的值。\n这个过程为 $t=0, \\ldots, T-1$ 产生两个时间序列，$\\lambda_{\\mathrm{REP}}(t)$ 和 $S(t)$。\n\n**步骤 2.2：基线估计**\n问题要求区分突发的病害事件与平滑的物候趋势。这通过为每个时间序列估计一个平滑基线来实现。我们使用平滑样条，特别是 `scipy.interpolate.UnivariateSpline`，来建模物候基线，记为 $\\hat{\\lambda}_{\\mathrm{REP}}(t)$ 和 $\\hat{S}(t)$。平滑因子 $s$ 至关重要：它必须足够大，以平滑掉噪声和短期异常（病害事件），但又必须足够小，以捕捉整体的季节性曲线。通过经验选择，我们为 $\\lambda_{\\mathrm{REP}}(t)$ 时间序列设置平滑因子 $s_{\\lambda}=10$，为 $S(t)$ 时间序列设置 $s_{S}=1 \\times 10^{-5}$，发现这些值对于指定的数据特征是有效的。样条模型还允许直接计算基线的时间导数 $\\frac{d\\hat{\\lambda}_{\\mathrm{REP}}}{dt}(t)$ 和 $\\frac{d\\hat{S}}{dt}(t)$，这是突变性标准所要求的。\n\n**步骤 2.3：异常检测**\n检测逻辑基于分析观测数据与估计基线之间的残差：\n$$\n\\Delta\\lambda(t) = \\lambda_{\\mathrm{REP}}(t) - \\hat{\\lambda}_{\\mathrm{REP}}(t)\n$$\n$$\n\\Delta S(t) = S(t) - \\hat{S}(t)\n$$\n使用中位数绝对偏差 (MAD) 计算这些残差的统计尺度的稳健度量，并将其缩放至与高斯数据的标准差等效：\n$$\n\\sigma_{\\lambda} = 1.4826 \\cdot \\mathrm{median}_t(|\\Delta\\lambda(t) - \\mathrm{median}_{t'}(\\Delta\\lambda(t'))|)\n$$\n$$\n\\sigma_{S} = 1.4826 \\cdot \\mathrm{median}_t(|\\Delta S(t) - \\mathrm{median}_{t'}(\\Delta S(t'))|)\n$$\n当且仅当以下所有三个条件在时间 $t$ 同时满足时，标记为病害事件：\n1.  **显著蓝移**：红边位置必须显著低于基线。\n    $$\n    \\Delta\\lambda(t)  -\\max(3\\sigma_{\\lambda}, \\delta_{\\lambda})\n    $$\n    其中 $\\delta_{\\lambda} = 3.5\\,\\mathrm{nm}$ 是一个最小绝对偏移阈值。\n2.  **显著斜率下降**：红边斜率必须显著低于基线。\n    $$\n    \\Delta S(t)  -\\max(3\\sigma_S, \\delta_S)\n    $$\n    其中 $\\delta_S = 0.007\\,\\mathrm{nm}^{-1}$ 是一个最小绝对斜率下降阈值。\n3.  **突变性**：相对于物候基线的变化率，该偏差必须是突发的。这将急剧发作与快速但平滑的季节性变化区分开来。\n    $$\n    |\\Delta\\lambda(t)|  \\alpha \\left| \\frac{d\\hat{\\lambda}_{\\mathrm{REP}}}{dt}(t) \\right| \\quad \\text{和} \\quad |\\Delta S(t)|  \\alpha \\left| \\frac{d\\hat{S}}{dt}(t) \\right|\n    $$\n    其中 $\\alpha = 3.0$ 是突变性乘子。\n\n**步骤 2.4：输出生成**\n算法遍历所有时间步。如果检测到病害事件，第一个满足所有条件的的时间步 $t$ 被记录为发病起始索引。每个测试用例的输出是一个列表，包含一个指示是否检测到的布尔标志、整数发病起始索引（如果没有则为-1）、发病时的蓝移幅度 $|\\Delta\\lambda(t)|$ 以及发病时的斜率下降幅度 $|\\Delta S(t)|$。所有测试用例的结果被汇总到一个最终列表中。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import UnivariateSpline\nfrom scipy.signal import savgol_filter\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for disease detection in vegetation spectra.\n    \"\"\"\n    # Unpack parameters\n    T = case_params['T']\n    sigma_noise = case_params['sigma_noise']\n    t_onset = case_params['t_onset']\n    D = case_params['D']\n    delta_lambda_d = case_params['delta_lambda_d']\n    f_k = case_params['f_k']\n    A1, A2, B1, B2 = case_params['pheno_amps']\n    delta_lambda_thresh = case_params['delta_lambda']\n    delta_S_thresh = case_params['delta_S']\n    alpha = case_params['alpha']\n\n    # 1. Data Generation\n    # Wavelength and time arrays\n    lambdas = np.arange(680.0, 781.0, 1.0)\n    times = np.arange(T)\n\n    # Constants for sigmoid model\n    R_soil = 0.05\n    R_veg = 0.5\n    lambda_base = 715.0\n    k_base = 0.5\n\n    # Phenological drivers\n    f_early = np.exp(-((times - T / 3)**2) / (2 * (T / 8)**2))\n    f_late = np.exp(-((times - 2 * T / 3)**2) / (2 * (T / 8)**2))\n    \n    lambda_pheno = lambda_base + A1 * f_early + A2 * f_late\n    # B parameters scaled to represent reasonable percent-level changes in k\n    k_pheno = k_base * (1 + (B1 / 10.0) * f_early + (B2 / 10.0) * f_late)\n\n    # Disease event modeling\n    lambda_disease_eff = np.zeros(T)\n    k_factor = np.ones(T)\n    if t_onset is not None:\n        disease_pulse = np.zeros(T)\n        disease_indices = (times >= t_onset)  (times  t_onset + D)\n        t_disease = times[disease_indices]\n        if len(t_disease) > 0:\n            center = t_onset + D / 2.0\n            width = D / 3.0\n            disease_pulse[disease_indices] = np.exp(-((t_disease - center)**2) / (2 * width**2))\n    \n        lambda_disease_eff = delta_lambda_d * disease_pulse\n        k_factor = 1.0 + (f_k - 1.0) * disease_pulse\n\n    # Final sigmoid parameters\n    lambda_0_t = lambda_pheno + lambda_disease_eff\n    k_t = k_pheno / k_factor\n\n    # Generate reflectance matrix R(lambda, t)\n    R = np.zeros((len(lambdas), T))\n    for t in range(T):\n        sigmoid = 1.0 / (1.0 + np.exp(-k_t[t] * (lambdas - lambda_0_t[t])))\n        R[:, t] = R_soil + (R_veg - R_soil) * sigmoid\n    \n    # Add noise\n    R += np.random.normal(0, sigma_noise, size=R.shape)\n    R = np.clip(R, 0, 1)\n\n    # 2. Analysis Pipeline\n    # 2.1 Feature Extraction\n    lambda_rep_t = np.zeros(T)\n    S_t = np.zeros(T)\n    \n    # Sav-Gol filter parameters\n    sg_win = 15\n    sg_poly = 3\n\n    # Search interval for red edge\n    search_mask = (lambdas >= 690)  (lambdas = 760)\n    lambda_search = lambdas[search_mask]\n\n    for t in range(T):\n        # Smooth and differentiate spectrum\n        R_prime = savgol_filter(R[:, t], window_length=sg_win, polyorder=sg_poly, deriv=1, delta=1.0)\n        \n        # Search for max derivative in the specified interval\n        R_prime_search = R_prime[search_mask]\n        max_idx = np.argmax(R_prime_search)\n        \n        lambda_rep_t[t] = lambda_search[max_idx]\n        S_t[t] = R_prime_search[max_idx]\n\n    # 2.2 Baseline Estimation\n    # Use smoothing splines to estimate phenological baselines\n    # Smoothing factors (s) are chosen empirically to filter out anomalies\n    s_lambda = 10.0\n    s_S = 1e-5\n    \n    spl_lambda = UnivariateSpline(times, lambda_rep_t, s=s_lambda)\n    spl_S = UnivariateSpline(times, S_t, s=s_S)\n\n    lambda_hat_t = spl_lambda(times)\n    S_hat_t = spl_S(times)\n    \n    # Get baseline derivatives\n    d_lambda_hat_dt = spl_lambda.derivative(1)(times)\n    d_S_hat_dt = spl_S.derivative(1)(times)\n\n    # 2.3 Anomaly Detection\n    delta_lambda_t = lambda_rep_t - lambda_hat_t\n    delta_S_t = S_t - S_hat_t\n\n    # Robust scale estimation using MAD\n    mad_lambda = np.median(np.abs(delta_lambda_t - np.median(delta_lambda_t)))\n    sigma_lambda = 1.4826 * mad_lambda if mad_lambda > 1e-9 else 1e-9\n    \n    mad_S = np.median(np.abs(delta_S_t - np.median(delta_S_t)))\n    sigma_S = 1.4826 * mad_S if mad_S > 1e-9 else 1e-9\n\n    # Detection thresholds\n    T_lambda = -max(3 * sigma_lambda, delta_lambda_thresh)\n    T_S = -max(3 * sigma_S, delta_S_thresh)\n\n    detection_flag = False\n    onset_index = -1\n    blue_shift_mag = 0.0\n    slope_drop_mag = 0.0\n\n    for t in range(T):\n        # Condition 1: Blue shift\n        cond1 = delta_lambda_t[t]  T_lambda\n        # Condition 2: Slope drop\n        cond2 = delta_S_t[t]  T_S\n        # Condition 3: Abruptness\n        cond3_lambda = np.abs(delta_lambda_t[t]) > alpha * np.abs(d_lambda_hat_dt[t])\n        cond3_S = np.abs(delta_S_t[t]) > alpha * np.abs(d_S_hat_dt[t])\n        cond3 = cond3_lambda and cond3_S\n        \n        if cond1 and cond2 and cond3:\n            detection_flag = True\n            onset_index = t\n            blue_shift_mag = np.abs(delta_lambda_t[t])\n            slope_drop_mag = np.abs(delta_S_t[t])\n            break # Report first detection\n\n    return [detection_flag, onset_index, blue_shift_mag, slope_drop_mag]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    np.random.seed(42)  # For reproducibility\n\n    thresholds = {\n        'delta_lambda': 3.5,\n        'delta_S': 0.007,\n        'alpha': 3.0,\n    }\n\n    test_cases = [\n        # Case 1: Healthy with phenology\n        {'T': 60, 'sigma_noise': 0.002, 't_onset': None, 'D': 0, \n         'delta_lambda_d': 0.0, 'f_k': 1.0, 'pheno_amps': (3, -2, -2, 1.5)},\n        # Case 2: Clear disease\n        {'T': 60, 'sigma_noise': 0.002, 't_onset': 25, 'D': 5, \n         'delta_lambda_d': -5.0, 'f_k': 1.5, 'pheno_amps': (3, -2, -2, 1.5)},\n        # Case 3: Borderline stress\n        {'T': 60, 'sigma_noise': 0.002, 't_onset': 25, 'D': 4, \n         'delta_lambda_d': -2.0, 'f_k': 1.1, 'pheno_amps': (3, -2, -2, 1.5)},\n        # Case 4: Strong late phenology, no disease\n        {'T': 60, 'sigma_noise': 0.002, 't_onset': None, 'D': 0, \n         'delta_lambda_d': 0.0, 'f_k': 1.0, 'pheno_amps': (3, -4, -2, 2.2)},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        params = {**case, **thresholds}\n        result = run_case(params)\n        all_results.append(result)\n\n    # Format the final output string\n    # Convert bools to lowercase 'true'/'false' as in example\n    result_str = '[' + ','.join([\n        f\"[{str(r[0]).lower()},{r[1]},{r[2]},{r[3]}]\" for r in all_results\n    ]) + ']'\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}