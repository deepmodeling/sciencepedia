{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of retrieving land surface temperature from space is the radiative transfer equation (RTE). This equation models how thermal energy emitted by the Earth's surface is modified by the atmosphere before it reaches the satellite sensor. This first practice exercise provides a direct, hands-on application of the RTE, challenging you to work backward from a simulated satellite measurement to calculate the true surface temperature, a fundamental skill in thermal remote sensing .",
            "id": "3797035",
            "problem": "A spaceborne thermal infrared imager acquires narrowband, nadir-view measurements centered at wavelength $\\lambda=11\\,\\mu\\mathrm{m}$ over a homogeneous, opaque land surface. The measured Top-of-Atmosphere (TOA) spectral radiance $L_{\\text{TOA}}$ is $9.0\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$. The atmosphere is approximated as plane-parallel, horizontally homogeneous, and in local thermodynamic equilibrium along the line of sight. The atmospheric transmittance is $\\tau=0.85$. The surface spectral emissivity is $\\epsilon=0.98$. The downwelling atmospheric spectral radiance incident at the surface is $L_{d}=2.0\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$. The upwelling path spectral radiance is $L_{u}=1.5\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$. Assume the surface is Lambertian and obeys Kirchhoff’s law in the thermal region so that the hemispherical reflectance equals $1-\\epsilon$ at the measurement wavelength.\n\nStarting from the radiative transfer description of thermal emission and reflection at the surface and along the line of sight, and from Planck’s law for spectral radiance,\n$$\nB_{\\lambda}(T)=\\frac{2\\,h\\,c^{2}}{\\lambda^{5}}\\;\\frac{1}{\\exp\\!\\left(\\frac{h\\,c}{\\lambda\\,k_{B}\\,T}\\right)-1},\n$$\nderive an expression for the surface temperature $T_{s}$ and compute its numerical value using the provided measurements. Use the following physical constants: Planck constant $h=6.62607015\\times 10^{-34}\\,\\mathrm{J\\,s}$, speed of light in vacuum $c=2.99792458\\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$, and Boltzmann constant $k_{B}=1.380649\\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}$. Treat $B_{\\lambda}$ as spectral radiance per unit wavelength so that when $\\lambda$ is expressed in meters, $B_{\\lambda}$ has units $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,m^{-1}}$. Be consistent with unit conversions when using the measured quantities, which are reported per micrometer.\n\nRound your final numerical answer for $T_{s}$ to four significant figures. Express the final temperature in Kelvin.",
            "solution": "The spectral radiance measured by a sensor at the Top-of-Atmosphere, $L_{\\text{TOA}}$, is the sum of the transmitted surface radiance and the upwelling path radiance emitted by the atmosphere. The surface radiance itself is composed of an emitted and a reflected component. This is expressed by the radiative transfer equation:\n$$\nL_{\\text{TOA}}(\\lambda) = \\tau(\\lambda) \\left[ \\epsilon(\\lambda) B_{\\lambda}(T_s) + \\rho(\\lambda) L_d(\\lambda) \\right] + L_u(\\lambda)\n$$\nwhere $T_s$ is the surface temperature, $B_{\\lambda}(T_s)$ is the Planck blackbody radiance, $\\epsilon$ is emissivity, $\\tau$ is transmittance, $L_d$ is downwelling radiance, $L_u$ is upwelling path radiance, and $\\rho$ is reflectance.\n\nGiven that the surface is opaque and obeys Kirchhoff’s law, we have $\\rho(\\lambda) = 1 - \\epsilon(\\lambda)$. Substituting this into the equation and dropping the explicit wavelength dependence for simplicity gives:\n$$\nL_{\\text{TOA}} = \\tau [ \\epsilon B_{\\lambda}(T_s) + (1 - \\epsilon) L_d ] + L_u\n$$\n\nOur goal is to solve for $T_s$. We first rearrange the equation to isolate the blackbody radiance term, $B_{\\lambda}(T_s)$:\n$$\nB_{\\lambda}(T_s) = \\frac{L_{\\text{TOA}} - L_u - \\tau(1 - \\epsilon) L_d}{\\tau \\epsilon}\n$$\nNext, we invert Planck's law to solve for $T_s$ from the computed $B_{\\lambda}(T_s)$. The expression for $T_s$ obtained by inverting the Planck function is:\n$$\nT_s = \\frac{hc / (k_B \\lambda)}{\\ln\\left( \\frac{2hc^2}{\\lambda^5 B_{\\lambda}(T_s)} + 1 \\right)}\n$$\n\nNow we compute the numerical value. It is critical to use consistent SI units for the calculation. The given radiances are converted from per-$\\mu\\mathrm{m}$ to per-meter units by multiplying by $10^6$.\n*   $\\lambda = 11 \\times 10^{-6} \\, \\mathrm{m}$\n*   $L_{\\text{TOA}} = 9.0 \\times 10^6 \\, \\mathrm{W \\, m^{-2} \\, sr^{-1} \\, m^{-1}}$\n*   $L_d = 2.0 \\times 10^6 \\, \\mathrm{W \\, m^{-2} \\, sr^{-1} \\, m^{-1}}$\n*   $L_u = 1.5 \\times 10^6 \\, \\mathrm{W \\, m^{-2} \\, sr^{-1} \\, m^{-1}}$\n*   $\\tau = 0.85$\n*   $\\epsilon = 0.98$\n\nFirst, calculate the surface blackbody radiance $B_{\\lambda}(T_s)$ using the given values:\n$$\nB_{\\lambda}(T_s) = \\frac{9.0 \\times 10^6 - 1.5 \\times 10^6 - 0.85(1 - 0.98)(2.0 \\times 10^6)}{0.85 \\times 0.98}\n$$\n$$\nB_{\\lambda}(T_s) = \\frac{7.5 \\times 10^6 - 34000}{0.833} = \\frac{7466000}{0.833} \\approx 8.962785 \\times 10^6 \\, \\mathrm{W \\, m^{-2} \\, sr^{-1} \\, m^{-1}}\n$$\nNext, we use the physical constants and the calculated $B_{\\lambda}(T_s)$ to invert the Planck function for $T_s$. Let $c_1 = 2 h c^2$ and $c_2 = hc/k_B$.\n*   $c_1 \\approx 1.19104 \\times 10^{-16} \\, \\mathrm{W \\, m^2 \\, sr^{-1}}$\n*   $c_2 \\approx 0.0143877 \\, \\mathrm{m \\cdot K}$\n\nWe can now substitute these values into the expression for $T_s$:\n$$\nT_s = \\frac{c_2}{\\lambda \\ln\\left( \\frac{c_1}{\\lambda^5 B_{\\lambda}(T_s)} + 1 \\right)}\n$$\nCalculate the term inside the logarithm:\n$$\n\\frac{c_1}{\\lambda^5 B_{\\lambda}(T_s)} + 1 = \\frac{1.19104 \\times 10^{-16}}{(11 \\times 10^{-6})^5 (8.962785 \\times 10^6)} + 1 \\approx 82.508 + 1 = 83.508\n$$\nFinally, we compute $T_s$:\n$$\nT_s = \\frac{0.0143877}{(11 \\times 10^{-6}) \\ln(83.508)} \\approx \\frac{0.0143877}{(11 \\times 10^{-6}) \\times 4.42494} \\approx 295.6136 \\, \\mathrm{K}\n$$\nRounding to four significant figures, the surface temperature is $295.6\\,\\mathrm{K}$.",
            "answer": "$$\n\\boxed{295.6}\n$$"
        },
        {
            "introduction": "A retrieved surface temperature is only as valuable as its uncertainty estimate, as errors from atmospheric correction and instrument noise affect the final result. This exercise focuses on a critical aspect of quantitative remote sensing: error propagation. You will derive the sensitivity of the Planck function to temperature, which quantifies the conversion from radiance uncertainty to temperature uncertainty, allowing you to assess the quality of a retrieval and understand its error budget .",
            "id": "3797038",
            "problem": "A Thermal Infrared (TIR) land surface temperature retrieval at wavelength $\\lambda = 11\\,\\mu\\mathrm{m}$ requires atmospheric correction of Top of Atmosphere (TOA) radiance. After correction, the surface-leaving spectral radiance $L_{\\lambda}^{\\mathrm{surf}}$ is modeled as $L_{\\lambda}^{\\mathrm{surf}} = \\varepsilon_{\\lambda}\\,B_{\\lambda}(T)$, where $B_{\\lambda}(T)$ is the Planck spectral radiance of a blackbody and $\\varepsilon_{\\lambda}$ is the surface spectral emissivity. The uncertainty in the atmospheric correction yields an estimated radiance uncertainty $\\Delta L_{\\lambda}$ at the surface. \n\nStarting from the fundamental laws:\n- Planck’s law for spectral radiance per unit wavelength,\n$$\nB_{\\lambda}(T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k_{B} T}\\right)-1},\n$$\n- and the linearized propagation of uncertainties for a differentiable mapping,\nderive the sensitivity $\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T}$ analytically, evaluate it numerically at $\\lambda = 11\\,\\mu\\mathrm{m}$ and $T = 300\\,\\mathrm{K}$, and then use it to convert a radiance uncertainty into a temperature uncertainty under the small-signal approximation.\n\nAssume the following physically realistic conditions for a mid-infrared atmospheric window channel:\n- Wavelength $\\lambda = 11\\,\\mu\\mathrm{m}$,\n- Surface emissivity $\\varepsilon_{\\lambda} = 0.98$,\n- Surface kinetic temperature $T = 300\\,\\mathrm{K}$,\n- Radiance uncertainty after atmospheric correction $\\Delta L_{\\lambda} = 0.15\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n\nUse the exact physical constants:\n- Planck constant $h = 6.62607015 \\times 10^{-34}\\,\\mathrm{J\\,s}$,\n- Speed of light in vacuum $c = 2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$,\n- Boltzmann constant $k_{B} = 1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}$.\n\nTasks:\n1. Derive the analytic expression for $\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T}$ from Planck’s law without introducing any shortcut formulas.\n2. Evaluate $\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T}$ numerically at the specified $\\lambda$ and $T$, and report it in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}\\,K^{-1}}$.\n3. Under the small-signal linearization of $L_{\\lambda}^{\\mathrm{surf}} = \\varepsilon_{\\lambda} B_{\\lambda}(T)$, compute the corresponding temperature uncertainty $\\Delta T$ from $\\Delta L_{\\lambda}$.\n\nRound your final numerical answer for $\\Delta T$ to three significant figures and express it in Kelvin. Your final answer must be a single real-valued number.",
            "solution": "The problem is well-posed, scientifically grounded, and provides all necessary information to derive a unique and meaningful solution. The tasks will be addressed sequentially as requested.\n\n### 1. Analytic Derivation of the Sensitivity $\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T}$\n\nThe starting point is Planck's law for spectral radiance per unit wavelength, $B_{\\lambda}(T)$:\n$$\nB_{\\lambda}(T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\frac{1}{\\exp\\left(\\frac{h c}{\\lambda k_{B} T}\\right)-1}\n$$\nTo find the sensitivity of the spectral radiance to temperature, we must compute the derivative of $B_{\\lambda}(T)$ with respect to $T$. For clarity, let's define two constants: $A = \\frac{2 h c^{2}}{\\lambda^{5}}$ and $x(T) = \\frac{h c}{\\lambda k_{B} T}$. The expression for Planck's law becomes:\n$$\nB_{\\lambda}(T) = A \\left( \\exp(x(T)) - 1 \\right)^{-1}\n$$\nWe apply the chain rule for differentiation: $\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T} = \\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}x} \\frac{\\mathrm{d}x}{\\mathrm{d}T}$.\n\nFirst, we differentiate $B_{\\lambda}$ with respect to $x$:\n$$\n\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}x} = A \\cdot (-1) \\left( \\exp(x) - 1 \\right)^{-2} \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}x}(\\exp(x) - 1) = -A \\frac{\\exp(x)}{(\\exp(x) - 1)^{2}}\n$$\nNext, we differentiate $x(T)$ with respect to $T$:\n$$\nx(T) = \\frac{h c}{\\lambda k_{B}} T^{-1}\n$$\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}T} = \\frac{h c}{\\lambda k_{B}} \\cdot (-1) T^{-2} = -\\frac{h c}{\\lambda k_{B} T^{2}}\n$$\nNow, we combine these results using the chain rule:\n$$\n\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T} = \\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}x} \\frac{\\mathrm{d}x}{\\mathrm{d}T} = \\left( -A \\frac{\\exp(x)}{(\\exp(x) - 1)^{2}} \\right) \\left( -\\frac{h c}{\\lambda k_{B} T^{2}} \\right)\n$$\nThe two negative signs cancel, and substituting the expressions for $A$ and $x$ back in, we obtain the analytical formula for the derivative:\n$$\n\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T} = \\left( \\frac{2 h c^{2}}{\\lambda^{5}} \\right) \\frac{\\exp\\left(\\frac{h c}{\\lambda k_{B} T}\\right)}{\\left(\\exp\\left(\\frac{h c}{\\lambda k_{B} T}\\right)-1\\right)^{2}} \\left( \\frac{h c}{\\lambda k_{B} T^{2}} \\right)\n$$\nThis expression can be written more compactly by relating it to $B_{\\lambda}(T)$ itself:\n$$\n\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T} = B_{\\lambda}(T) \\frac{\\exp\\left(\\frac{h c}{\\lambda k_{B} T}\\right)}{\\exp\\left(\\frac{h c}{\\lambda k_{B} T}\\right)-1} \\frac{h c}{\\lambda k_{B} T^{2}}\n$$\n\n### 2. Numerical Evaluation of $\\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T}$\n\nWe are given the following parameters and constants:\n- Wavelength $\\lambda = 11\\,\\mu\\mathrm{m} = 11 \\times 10^{-6}\\,\\mathrm{m}$\n- Surface kinetic temperature $T = 300\\,\\mathrm{K}$\n- Planck constant $h = 6.62607015 \\times 10^{-34}\\,\\mathrm{J\\,s}$\n- Speed of light $c = 2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$\n- Boltzmann constant $k_{B} = 1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}$\n\nThe calculation will be performed in base SI units, which will yield the derivative in units of $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,m^{-1}\\,K^{-1}}$. A conversion is required to obtain the result in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}\\,K^{-1}}$. Since $1\\,\\mu\\mathrm{m} = 10^{-6}\\,\\mathrm{m}$, the conversion factor is $10^{-6}$.\n\nFirst, we compute the dimensionless argument of the exponential function:\n$$\nx = \\frac{h c}{\\lambda k_{B} T} = \\frac{(6.62607015 \\times 10^{-34}\\,\\mathrm{J\\,s}) (2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}})}{(11 \\times 10^{-6}\\,\\mathrm{m})(1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}})(300\\,\\mathrm{K})} \\approx 4.35993\n$$\nNext, we evaluate the Planck function $B_{\\lambda_m}(T)$ in per-meter units.\nThe first radiation constant is $c_1 = 2hc^2 = 2(6.62607015 \\times 10^{-34})(2.99792458 \\times 10^{8})^2 \\approx 1.19104297 \\times 10^{-16}\\,\\mathrm{W\\,m^2\\,sr^{-1}}$.\n$$\nB_{\\lambda_m}(T) = \\frac{c_1}{\\lambda^5 (\\exp(x)-1)} = \\frac{1.19104297 \\times 10^{-16}}{(11 \\times 10^{-6})^5 (\\exp(4.35993)-1)} \\approx \\frac{7.39563 \\times 10^8}{78.2513 - 1} \\approx 9.57347 \\times 10^6\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,m^{-1}}\n$$\nNow, we can evaluate the derivative in per-meter units using the compact form:\n$$\n\\frac{\\mathrm{d}B_{\\lambda_m}}{\\mathrm{d}T} = B_{\\lambda_m}(T) \\frac{x}{T} \\frac{\\exp(x)}{\\exp(x)-1}\n$$\n$$\n\\frac{\\mathrm{d}B_{\\lambda_m}}{\\mathrm{d}T} \\approx (9.57347 \\times 10^6) \\left( \\frac{4.35993}{300} \\right) \\left( \\frac{\\exp(4.35993)}{\\exp(4.35993)-1} \\right) \\approx (9.57347 \\times 10^6) (0.0145331) (1.01294) \\approx 140857\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,m^{-1}\\,K^{-1}}\n$$\nTo report this value in the required units of $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}\\,K^{-1}}$, we multiply by $10^{-6}$:\n$$\n\\frac{\\mathrm{d}B_{\\lambda_{\\mu\\mathrm{m}}}}{\\mathrm{d}T} \\approx 140857 \\times 10^{-6} \\approx 0.140857\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}\\,K^{-1}}\n$$\n\n### 3. Computation of Temperature Uncertainty $\\Delta T$\n\nThe relationship between the surface-leaving spectral radiance $L_{\\lambda}^{\\mathrm{surf}}$ and the blackbody spectral radiance $B_{\\lambda}(T)$ is given by:\n$$\nL_{\\lambda}^{\\mathrm{surf}} = \\varepsilon_{\\lambda}\\,B_{\\lambda}(T)\n$$\nAssuming the emissivity $\\varepsilon_{\\lambda}$ is constant with respect to small variations in temperature, we can linearize this relationship to propagate uncertainties. The change in radiance $\\Delta L_{\\lambda}$ for a small change in temperature $\\Delta T$ is approximated by:\n$$\n\\Delta L_{\\lambda} \\approx \\frac{\\mathrm{d}L_{\\lambda}^{\\mathrm{surf}}}{\\mathrm{d}T} \\Delta T = \\left( \\varepsilon_{\\lambda} \\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T} \\right) \\Delta T\n$$\nWe can rearrange this equation to solve for the temperature uncertainty $\\Delta T$:\n$$\n\\Delta T = \\frac{\\Delta L_{\\lambda}}{\\varepsilon_{\\lambda} \\frac{\\mathrm{d}B_{\\lambda}}{\\mathrm{d}T}}\n$$\nWe are given:\n- Radiance uncertainty $\\Delta L_{\\lambda} = 0.15\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$\n- Surface emissivity $\\varepsilon_{\\lambda} = 0.98$\n\nUsing the numerically evaluated sensitivity in consistent units:\n$$\n\\Delta T = \\frac{0.15\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}}{0.98 \\cdot (0.140857\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}\\,K^{-1}})}\n$$\n$$\n\\Delta T \\approx \\frac{0.15}{0.13804} \\,\\mathrm{K} \\approx 1.08664\\,\\mathrm{K}\n$$\nRounding the final answer to three significant figures, as requested, we get:\n$$\n\\Delta T \\approx 1.09\\,\\mathrm{K}\n$$",
            "answer": "$$\n\\boxed{1.09}\n$$"
        },
        {
            "introduction": "Real-world retrieval systems must simultaneously solve for multiple unknown parameters and optimally balance information from measurements with prior knowledge. This capstone exercise guides you through implementing a professional-grade Optimal Estimation (OE) algorithm to tackle the classic temperature-emissivity separation problem. By building a complete OE system that uses multi-channel measurements to retrieve both surface temperature and emissivity, you will bridge the gap between theoretical principles and operational satellite data processing .",
            "id": "3797043",
            "problem": "You are given the task of implementing a retrieval for surface temperature $T_s$ and a band-constant emissivity $\\epsilon$ from two measured top-of-atmosphere radiances $L_{\\text{band}}$ at wavelengths $11\\,\\mu\\mathrm{m}$ and $12\\,\\mu\\mathrm{m}$, using Optimal Estimation (OE) in the context of remote sensing and environmental modeling for thermal infrared atmospheric correction.\n\nThe retrieval must be formulated from first principles using the following fundamental bases:\n\n- Radiative Transfer (RT) for thermal infrared top-of-atmosphere radiance: for each wavelength $\\lambda$, the forward model is\n$$\nL_{\\text{TOA},\\lambda} = \\tau_{\\lambda} \\left[ \\epsilon \\, B_{\\lambda}(T_s) + \\left(1-\\epsilon\\right) L_{d,\\lambda} \\right] + L_{u,\\lambda},\n$$\nwhere $L_{\\text{TOA},\\lambda}$ is the top-of-atmosphere radiance, $\\tau_{\\lambda}$ is atmospheric transmittance, $L_{u,\\lambda}$ is upwelling path radiance, $L_{d,\\lambda}$ is downwelling path radiance, $\\epsilon$ is surface emissivity (assumed band-constant over both wavelengths), and $B_{\\lambda}(T_s)$ is the Planck radiance in units of $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n\n- Planck’s law for spectral radiance per unit wavelength:\n$$\nB_{\\lambda}(T) = \\frac{2 h c^2}{\\lambda^5} \\frac{1}{\\exp\\left(\\frac{h c}{\\lambda k T}\\right) - 1},\n$$\nwhere $h$ is Planck’s constant, $c$ is the speed of light, $k$ is Boltzmann’s constant, $\\lambda$ is wavelength in $m$, and the radiance is subsequently expressed per $\\mu\\mathrm{m}$ via a multiplicative factor of $10^{-6}$. The derivative with respect to temperature is\n$$\n\\frac{\\partial B_{\\lambda}}{\\partial T}(T) = \\frac{2 h c^2}{\\lambda^5} \\cdot \\frac{\\exp\\left(\\frac{h c}{\\lambda k T}\\right)}{\\left[\\exp\\left(\\frac{h c}{\\lambda k T}\\right)-1\\right]^2} \\cdot \\frac{h c}{\\lambda k T^2},\n$$\nalso expressed per $\\mu\\mathrm{m}$ via the same multiplicative factor.\n\n- Optimal Estimation (OE) for a state vector $\\mathbf{x} = \\begin{bmatrix} T_s  \\epsilon \\end{bmatrix}^T$, measurements $\\mathbf{y} = \\begin{bmatrix} L_{\\text{TOA},11\\,\\mu\\mathrm{m}}  L_{\\text{TOA},12\\,\\mu\\mathrm{m}} \\end{bmatrix}^T$, forward model $\\mathbf{F}(\\mathbf{x})$, measurement error covariance $\\mathbf{S}_e$, and prior $\\mathbf{x}_a$ with prior covariance $\\mathbf{S}_a$. The OE cost function is\n$$\nJ(\\mathbf{x}) = \\left[\\mathbf{y} - \\mathbf{F}(\\mathbf{x})\\right]^T \\mathbf{S}_e^{-1} \\left[\\mathbf{y} - \\mathbf{F}(\\mathbf{x})\\right] + \\left[\\mathbf{x} - \\mathbf{x}_a\\right]^T \\mathbf{S}_a^{-1} \\left[\\mathbf{x} - \\mathbf{x}_a\\right].\n$$\n\nYour program must implement an iterative Gauss-Newton OE retrieval that uses the Jacobian of $\\mathbf{F}$ with respect to $\\mathbf{x}$ and reports convergence behavior. Convergence is defined as the Euclidean norm of the state update falling below a threshold of $10^{-6}$ when measured in the native units of the state components (Kelvin for $T_s$ and dimensionless for $\\epsilon$), or a maximum of $20$ iterations, whichever comes first. The program must compute and report, for each test case, the retrieved $T_s$ in $K$, the retrieved $\\epsilon$ (dimensionless), the number of iterations as an integer, a boolean indicating whether convergence was achieved, and the final cost $J$ as a float.\n\nAll quantities with physical units must be handled consistently:\n- Wavelengths must be specified in $\\mu\\mathrm{m}$.\n- Radiances must be expressed in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n- Temperature must be expressed in $K$.\n- Angles do not appear; none are required.\n- Percentages do not appear; none are required.\n\nTest Suite:\nImplement the retrieval for the following four test cases. In each case, the measured radiances $\\mathbf{y}$ are to be generated internally by applying the RT forward model to the given “true” values of $T_s$ and $\\epsilon$ alongside the specified atmospheric parameters. The retrieval then uses these generated measurements (without adding noise) along with the stated $\\mathbf{S}_e$ and $\\mathbf{S}_a$.\n\n- Case $1$ (happy path):\n    - Wavelengths: $[11\\,\\mu\\mathrm{m}, 12\\,\\mu\\mathrm{m}]$.\n    - Atmospheric transmittance: $\\boldsymbol{\\tau} = [0.90, 0.88]$.\n    - Upwelling path radiance: $\\mathbf{L}_u = [1.20, 1.10]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - Downwelling path radiance: $\\mathbf{L}_d = [8.70, 9.20]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - True surface temperature and emissivity: $T_s^{\\text{true}} = 300\\,\\mathrm{K}$, $\\epsilon^{\\text{true}} = 0.98$.\n    - Measurement error standard deviations: $\\boldsymbol{\\sigma}_e = [0.10, 0.10]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$, with $\\mathbf{S}_e = \\mathrm{diag}(\\boldsymbol{\\sigma}_e^2)$.\n    - Prior state and covariance: $\\mathbf{x}_a = [290\\,\\mathrm{K}, 0.95]^T$, $\\mathbf{S}_a = \\mathrm{diag}([5^2, 0.03^2])$.\n\n- Case $2$ (moderate path absorption):\n    - Wavelengths: $[11\\,\\mu\\mathrm{m}, 12\\,\\mu\\mathrm{m}]$.\n    - Atmospheric transmittance: $\\boldsymbol{\\tau} = [0.50, 0.45]$.\n    - Upwelling path radiance: $\\mathbf{L}_u = [3.00, 3.50]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - Downwelling path radiance: $\\mathbf{L}_d = [10.50, 11.00]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - True surface temperature and emissivity: $T_s^{\\text{true}} = 310\\,\\mathrm{K}$, $\\epsilon^{\\text{true}} = 0.92$.\n    - Measurement error standard deviations: $\\boldsymbol{\\sigma}_e = [0.20, 0.20]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$, with $\\mathbf{S}_e = \\mathrm{diag}(\\boldsymbol{\\sigma}_e^2)$.\n    - Prior state and covariance: $\\mathbf{x}_a = [295\\,\\mathrm{K}, 0.95]^T$, $\\mathbf{S}_a = \\mathrm{diag}([8^2, 0.05^2])$.\n\n- Case $3$ (nearly clear atmosphere, emissivity near unity):\n    - Wavelengths: $[11\\,\\mu\\mathrm{m}, 12\\,\\mu\\mathrm{m}]$.\n    - Atmospheric transmittance: $\\boldsymbol{\\tau} = [0.99, 0.985]$.\n    - Upwelling path radiance: $\\mathbf{L}_u = [0.30, 0.30]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - Downwelling path radiance: $\\mathbf{L}_d = [7.50, 8.00]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - True surface temperature and emissivity: $T_s^{\\text{true}} = 280\\,\\mathrm{K}$, $\\epsilon^{\\text{true}} = 0.999$.\n    - Measurement error standard deviations: $\\boldsymbol{\\sigma}_e = [0.05, 0.05]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$, with $\\mathbf{S}_e = \\mathrm{diag}(\\boldsymbol{\\sigma}_e^2)$.\n    - Prior state and covariance: $\\mathbf{x}_a = [300\\,\\mathrm{K}, 0.97]^T$, $\\mathbf{S}_a = \\mathrm{diag}([4^2, 0.02^2])$.\n\n- Case $4$ (low transmittance, challenging retrieval):\n    - Wavelengths: $[11\\,\\mu\\mathrm{m}, 12\\,\\mu\\mathrm{m}]$.\n    - Atmospheric transmittance: $\\boldsymbol{\\tau} = [0.30, 0.25]$.\n    - Upwelling path radiance: $\\mathbf{L}_u = [5.00, 5.50]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - Downwelling path radiance: $\\mathbf{L}_d = [12.00, 12.50]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$.\n    - True surface temperature and emissivity: $T_s^{\\text{true}} = 295\\,\\mathrm{K}$, $\\epsilon^{\\text{true}} = 0.90$.\n    - Measurement error standard deviations: $\\boldsymbol{\\sigma}_e = [0.50, 0.50]$ in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$, with $\\mathbf{S}_e = \\mathrm{diag}(\\boldsymbol{\\sigma}_e^2)$.\n    - Prior state and covariance: $\\mathbf{x}_a = [330\\,\\mathrm{K}, 0.85]^T$, $\\mathbf{S}_a = \\mathrm{diag}([20^2, 0.10^2])$.\n\nAlgorithmic requirements:\n- Implement the forward model $\\mathbf{F}(\\mathbf{x})$ using the RT equation and Planck’s law.\n- Implement the Jacobian $\\mathbf{K} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}$ using analytic derivatives with respect to $T_s$ and $\\epsilon$.\n- Implement an iterative Gauss-Newton OE solver:\n    - Initialize $\\mathbf{x}_0 = \\mathbf{x}_a$.\n    - At each iteration, compute the update $\\Delta \\mathbf{x}$ by solving a linear system based on $\\mathbf{K}$, $\\mathbf{S}_e$, and $\\mathbf{S}_a$.\n    - Update $\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta \\mathbf{x}$.\n    - Stop when $\\|\\Delta \\mathbf{x}\\|_2  10^{-6}$ or after $20$ iterations.\n    - Compute the final cost $J$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each of the four test cases in order, append the following five values: retrieved $T_s$ in $K$ (float), retrieved $\\epsilon$ (float), number of iterations (integer), convergence flag (boolean), and final cost $J$ (float). The final output must therefore contain $20$ comma-separated entries enclosed in square brackets, e.g., $\\left[ T_{s,1}, \\epsilon_1, n_1, \\text{converged}_1, J_1, T_{s,2}, \\epsilon_2, n_2, \\text{converged}_2, J_2, T_{s,3}, \\epsilon_3, n_3, \\text{converged}_3, J_3, T_{s,4}, \\epsilon_4, n_4, \\text{converged}_4, J_4 \\right]$.",
            "solution": "The problem requires the implementation of an Optimal Estimation (OE) retrieval algorithm to determine the surface temperature $T_s$ and surface emissivity $\\epsilon$ from a pair of top-of-atmosphere (TOA) thermal infrared radiance measurements. The solution is formulated based on first principles of radiative transfer and Bayesian inversion theory, implemented using a Gauss-Newton iterative method.\n\n**1. Theoretical Framework**\n\nThe retrieval problem is cast in a Bayesian framework, where we seek to find the state vector $\\mathbf{x}$ that minimizes a cost function $J(\\mathbf{x})$. The state vector consists of the parameters to be retrieved:\n$$\n\\mathbf{x} = \\begin{bmatrix} T_s \\\\ \\epsilon \\end{bmatrix}\n$$\nwhere $T_s$ is the surface temperature in Kelvin and $\\epsilon$ is the surface emissivity, assumed to be constant across the two measurement wavelengths.\n\nThe measurements are the TOA radiances at two distinct wavelengths, $\\lambda_1 = 11\\,\\mu\\mathrm{m}$ and $\\lambda_2 = 12\\,\\mu\\mathrm{m}$. The measurement vector is:\n$$\n\\mathbf{y} = \\begin{bmatrix} L_{\\text{TOA},\\lambda_1} \\\\ L_{\\text{TOA},\\lambda_2} \\end{bmatrix}\n$$\n\n**2. Forward Model**\n\nThe forward model, denoted by $\\mathbf{F}(\\mathbf{x})$, relates the state vector $\\mathbf{x}$ to the measurement vector $\\mathbf{y}$. It is based on the radiative transfer equation for a non-scattering, plane-parallel thermal atmosphere. For a given wavelength $\\lambda$, the TOA radiance $L_{\\text{TOA},\\lambda}$ is modeled as:\n$$\nL_{\\text{TOA},\\lambda} = \\tau_{\\lambda} L_{\\text{surf},\\lambda} + L_{u,\\lambda}\n$$\nThe surface-leaving radiance, $L_{\\text{surf},\\lambda}$, is composed of an emitted component and a reflected downwelling component:\n$$\nL_{\\text{surf},\\lambda} = \\epsilon \\, B_{\\lambda}(T_s) + \\left(1-\\epsilon\\right) L_{d,\\lambda}\n$$\nCombining these gives the full forward model for a single channel:\n$$\nF_{\\lambda}(\\mathbf{x}) = \\tau_{\\lambda} \\left[ \\epsilon \\, B_{\\lambda}(T_s) + \\left(1-\\epsilon\\right) L_{d,\\lambda} \\right] + L_{u,\\lambda}\n$$\nwhere $\\tau_{\\lambda}$ is the atmospheric transmittance, $L_{u,\\lambda}$ is the upwelling path radiance, $L_{d,\\lambda}$ is the downwelling atmospheric radiance, and $B_{\\lambda}(T_s)$ is the Planck blackbody radiance function. The vector forward model $\\mathbf{F}(\\mathbf{x})$ is simply a vector of these functions evaluated at $\\lambda_1$ and $\\lambda_2$.\n\nThe Planck function, which gives the spectral radiance of a blackbody at temperature $T$ and wavelength $\\lambda$, is:\n$$\nB_{\\lambda}(T) = \\frac{2 h c^2}{\\lambda^5} \\frac{1}{\\exp\\left(\\frac{h c}{\\lambda k T}\\right) - 1}\n$$\nHere, $h$ is the Planck constant, $c$ is the speed of light, and $k$ is the Boltzmann constant. In this problem, all radiances are specified in units of $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$. This requires careful handling of units, as the fundamental Planck equation uses wavelength $\\lambda$ in meters ($m$) and yields radiance per meter. A conversion factor of $10^{-6}$ is applied to the result to express it in the required units.\n\n**3. Optimal Estimation (OE) and Cost Function**\n\nThe OE method combines information from the measurements with prior knowledge of the state vector. The optimal state is found by minimizing the cost function $J(\\mathbf{x})$, which penalizes deviations from both the measurements and a prior estimate of the state, weighted by their respective uncertainties:\n$$\nJ(\\mathbf{x}) = \\left[\\mathbf{y} - \\mathbf{F}(\\mathbf{x})\\right]^T \\mathbf{S}_e^{-1} \\left[\\mathbf{y} - \\mathbf{F}(\\mathbf{x})\\right] + \\left[\\mathbf{x} - \\mathbf{x}_a\\right]^T \\mathbf{S}_a^{-1} \\left[\\mathbf{x} - \\mathbf{x}_a\\right]\n$$\nHere, $\\mathbf{x}_a$ is the prior state vector, $\\mathbf{S}_a$ is the prior error covariance matrix, and $\\mathbf{S}_e$ is the measurement error covariance matrix.\n\n**4. Iterative Solution using Gauss-Newton Method**\n\nSince the forward model $\\mathbf{F}(\\mathbf{x})$ is non-linear in $T_s$, the minimization of $J(\\mathbf{x})$ requires an iterative approach. The Gauss-Newton method is employed. Starting with an initial guess $\\mathbf{x}_0$ (typically the prior, $\\mathbf{x}_a$), the state is updated iteratively:\n$$\n\\mathbf{x}_{i+1} = \\mathbf{x}_i + \\Delta \\mathbf{x}_i\n$$\nThe update step $\\Delta \\mathbf{x}_i$ is found by linearizing the forward model around the current state estimate $\\mathbf{x}_i$ and solving for the minimum of the linearized cost function. This leads to the following linear system for the update vector $\\Delta \\mathbf{x}_i$:\n$$\n\\left[ \\mathbf{K}_i^T \\mathbf{S}_e^{-1} \\mathbf{K}_i + \\mathbf{S}_a^{-1} \\right] \\Delta \\mathbf{x}_i = \\mathbf{K}_i^T \\mathbf{S}_e^{-1} \\left[ \\mathbf{y} - \\mathbf{F}(\\mathbf{x}_i) \\right] - \\mathbf{S}_a^{-1} \\left[ \\mathbf{x}_i - \\mathbf{x}_a \\right]\n$$\nwhere $\\mathbf{K}_i$ is the Jacobian matrix of the forward model evaluated at $\\mathbf{x}_i$.\n\n**5. Jacobian Matrix**\n\nThe Jacobian matrix $\\mathbf{K} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}$ contains the partial derivatives of the forward model with respect to each element of the state vector. For our $2$-channel, $2$-parameter system, it is a $2 \\times 2$ matrix:\n$$\n\\mathbf{K} = \\begin{bmatrix}\n\\frac{\\partial F_{\\lambda_1}}{\\partial T_s}  \\frac{\\partial F_{\\lambda_1}}{\\partial \\epsilon} \\\\\n\\frac{\\partial F_{\\lambda_2}}{\\partial T_s}  \\frac{\\partial F_{\\lambda_2}}{\\partial \\epsilon}\n\\end{bmatrix}\n$$\nThe analytical derivatives are:\n$$\n\\frac{\\partial F_{\\lambda}}{\\partial T_s} = \\tau_{\\lambda} \\, \\epsilon \\, \\frac{\\partial B_{\\lambda}(T_s)}{\\partial T_s}\n$$\n$$\n\\frac{\\partial F_{\\lambda}}{\\partial \\epsilon} = \\tau_{\\lambda} \\left[ B_{\\lambda}(T_s) - L_{d,\\lambda} \\right]\n$$\nThe derivative of the Planck function with respect to temperature is given by:\n$$\n\\frac{\\partial B_{\\lambda}}{\\partial T}(T) = \\frac{2 h c^2}{\\lambda^5} \\cdot \\frac{\\exp\\left(\\frac{h c}{\\lambda k T}\\right)}{\\left[\\exp\\left(\\frac{h c}{\\lambda k T}\\right)-1\\right]^2} \\cdot \\frac{h c}{\\lambda k T^2}\n$$\nLike the Planck function itself, this derivative is converted to units of $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}K^{-1}}$ by a multiplicative factor of $10^{-6}$.\n\n**6. Algorithm Implementation and Convergence**\n\nThe algorithm is implemented as follows:\n1.  Initialize the state vector: $\\mathbf{x}_0 = \\mathbf{x}_a$.\n2.  For each iteration $i=0, 1, 2, ...$:\n    a. Evaluate the forward model $\\mathbf{F}(\\mathbf{x}_i)$ and the Jacobian matrix $\\mathbf{K}_i$.\n    b. Construct the linear system for the state update aformentioned.\n    c. Solve the system for $\\Delta \\mathbf{x}_i$. This is done numerically using a standard linear solver, which is more stable than explicit matrix inversion.\n    d. Update the state: $\\mathbf{x}_{i+1} = \\mathbf{x}_i + \\Delta \\mathbf{x}_i$.\n    e. Check for convergence by calculating the Euclidean norm of the update vector, $\\|\\Delta \\mathbf{x}_i\\|_2$. If $\\|\\Delta \\mathbf{x}_i\\|_2  10^{-6}$, the iteration stops.\n3.  The process also terminates if the maximum number of iterations ($20$) is reached.\n4.  After termination, the final cost $J(\\mathbf{x}_{\\text{final}})$ is computed using the final retrieved state.\n\nThe test cases are executed by first generating the \"true\" measurement vector $\\mathbf{y}$ using the provided true state ($T_s^{\\text{true}}, \\epsilon^{\\text{true}}$) and atmospheric parameters, without adding any random noise. The retrieval algorithm then uses this synthetic measurement $\\mathbf{y}$ along with the specified prior information ($\\mathbf{x}_a, \\mathbf{S}_a$) and measurement uncertainties ($\\mathbf{S}_e$) to retrieve the state. This \"twin experiment\" setup allows for a direct assessment of the algorithm's ability to recover the true state under ideal (noise-free) conditions.",
            "answer": "```python\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Main function to run the Optimal Estimation retrieval for all test cases.\n    \"\"\"\n\n    # Physical constants\n    h = constants.h  # Planck constant (J.s)\n    c = constants.c  # Speed of light (m/s)\n    k = constants.k  # Boltzmann constant (J/K)\n    c1 = 2 * h * c**2\n    c2 = h * c / k\n\n    def planck_function(lmbda_um, T):\n        \"\"\"\n        Calculates Planck's law radiance B(lambda, T).\n        \n        Args:\n            lmbda_um (float): Wavelength in micrometers.\n            T (float): Temperature in Kelvin.\n        \n        Returns:\n            float: Spectral radiance in W m^-2 sr^-1 um^-1.\n        \"\"\"\n        lmbda_m = lmbda_um * 1e-6\n        if T = 0: return 0.0\n        val = c2 / (lmbda_m * T)\n        # Avoid overflow for large exp(val)\n        if val  60:\n            return 0.0 # Effectively zero\n        \n        radiance_per_m = (c1 / lmbda_m**5) / (np.exp(val) - 1)\n        return radiance_per_m * 1e-6\n\n    def planck_derivative(lmbda_um, T):\n        \"\"\"\n        Calculates the derivative of Planck's law radiance dB/dT.\n\n        Args:\n            lmbda_um (float): Wavelength in micrometers.\n            T (float): Temperature in Kelvin.\n\n        Returns:\n            float: Derivative of spectral radiance in W m^-2 sr^-1 um^-1 K^-1.\n        \"\"\"\n        lmbda_m = lmbda_um * 1e-6\n        if T = 0: return 0.0\n        val = c2 / (lmbda_m * T)\n        \n        # Avoid overflow and division by zero\n        if val  60:\n           return 0.0\n           \n        exp_val = np.exp(val)\n        if exp_val - 1 == 0:\n            return float('inf')\n\n        deriv_per_m = (c1 / lmbda_m**5) * \\\n                      (exp_val / (exp_val - 1)**2) * \\\n                      (c2 / (lmbda_m * T**2))\n        return deriv_per_m * 1e-6\n\n    def forward_model(x, atm_params):\n        \"\"\"\n        Computes the forward model F(x).\n        \n        Args:\n            x (np.ndarray): State vector [T_s, epsilon].\n            atm_params (dict): Dictionary of atmospheric parameters.\n        \n        Returns:\n            np.ndarray: Modeled TOA radiances [L_1, L_2].\n        \"\"\"\n        Ts, eps = x\n        lmbdas = atm_params['lmbdas']\n        tau = atm_params['tau']\n        Lu = atm_params['Lu']\n        Ld = atm_params['Ld']\n        \n        B_vals = np.array([planck_function(l, Ts) for l in lmbdas])\n        \n        L_toa = tau * (eps * B_vals + (1 - eps) * Ld) + Lu\n        return L_toa\n\n    def jacobian(x, atm_params):\n        \"\"\"\n        Computes the Jacobian of the forward model, K = dF/dx.\n        \n        Args:\n            x (np.ndarray): State vector [T_s, epsilon].\n            atm_params (dict): Dictionary of atmospheric parameters.\n\n        Returns:\n            np.ndarray: The 2x2 Jacobian matrix.\n        \"\"\"\n        Ts, eps = x\n        lmbdas = atm_params['lmbdas']\n        tau = atm_params['tau']\n        Ld = atm_params['Ld']\n\n        B_vals = np.array([planck_function(l, Ts) for l in lmbdas])\n        dBdT_vals = np.array([planck_derivative(l, Ts) for l in lmbdas])\n\n        dF_dTs = tau * eps * dBdT_vals\n        dF_deps = tau * (B_vals - Ld)\n        \n        K = np.vstack([dF_dTs, dF_deps]).T\n        return K\n\n    def solve_case(case_params):\n        \"\"\"\n        Performs the OE retrieval for a single test case.\n        \"\"\"\n        max_iter = 20\n        conv_thresh = 1e-6\n\n        # Unpack parameters\n        atm_params = {\n            'lmbdas': np.array(case_params['wavelengths']),\n            'tau': np.array(case_params['tau']),\n            'Lu': np.array(case_params['Lu']),\n            'Ld': np.array(case_params['Ld']),\n        }\n\n        # True state and measurement generation\n        x_true = np.array([case_params['Ts_true'], case_params['eps_true']])\n        y = forward_model(x_true, atm_params)\n\n        # Prior and error covariance matrices\n        xa = np.array(case_params['xa'])\n        Sa = np.diag(case_params['Sa_diag'])\n        Se = np.diag(np.array(case_params['sigma_e'])**2)\n        inv_Sa = np.linalg.inv(Sa)\n        inv_Se = np.linalg.inv(Se)\n\n        # Initialization\n        x_i = xa.copy()\n        n_iter = 0\n        converged = False\n\n        for i in range(max_iter):\n            n_iter = i + 1\n            \n            # Reshape for matrix algebra\n            x_i_col = x_i.reshape(-1, 1)\n            xa_col = xa.reshape(-1, 1)\n            y_col = y.reshape(-1, 1)\n\n            # Evaluate forward model and Jacobian\n            F_i = forward_model(x_i, atm_params).reshape(-1, 1)\n            K_i = jacobian(x_i, atm_params)\n\n            # Assemble and solve the Gauss-Newton linear system\n            # (K.T * inv(Se) * K + inv(Sa)) * dx = K.T * inv(Se) * (y - F(xi)) - inv(Sa) * (xi - xa)\n            lhs = K_i.T @ inv_Se @ K_i + inv_Sa\n            \n            # Defensive check for singular matrix\n            if np.linalg.cond(lhs)  1/np.finfo(lhs.dtype).eps:\n                # Poorly conditioned, stop iteration\n                break\n\n            rhs = K_i.T @ inv_Se @ (y_col - F_i) - inv_Sa @ (x_i_col - xa_col)\n            \n            delta_x = np.linalg.solve(lhs, rhs)\n\n            # Update state\n            x_i += delta_x.flatten()\n            \n            # Check for physical boundaries\n            x_i[1] = np.clip(x_i[1], 0.0, 1.0) # Emissivity [0,1]\n            if x_i[0] = 0: # Temperature  0K\n                break \n\n            # Check convergence\n            if np.linalg.norm(delta_x)  conv_thresh:\n                converged = True\n                break\n\n        # Final state calculation\n        x_final = x_i\n        \n        # Final cost function J(x)\n        d_y = y - forward_model(x_final, atm_params)\n        d_x = x_final - xa\n        cost_y = d_y.T @ inv_Se @ d_y\n        cost_x = d_x.T @ inv_Sa @ d_x\n        final_cost = cost_y + cost_x\n\n        return x_final[0], x_final[1], n_iter, converged, final_cost\n\n    test_cases = [\n        {\n            # Case 1\n            \"wavelengths\": [11.0, 12.0], \"tau\": [0.90, 0.88], \"Lu\": [1.20, 1.10], \"Ld\": [8.70, 9.20],\n            \"Ts_true\": 300.0, \"eps_true\": 0.98,\n            \"sigma_e\": [0.10, 0.10],\n            \"xa\": [290.0, 0.95], \"Sa_diag\": [5.0**2, 0.03**2]\n        },\n        {\n            # Case 2\n            \"wavelengths\": [11.0, 12.0], \"tau\": [0.50, 0.45], \"Lu\": [3.00, 3.50], \"Ld\": [10.50, 11.00],\n            \"Ts_true\": 310.0, \"eps_true\": 0.92,\n            \"sigma_e\": [0.20, 0.20],\n            \"xa\": [295.0, 0.95], \"Sa_diag\": [8.0**2, 0.05**2]\n        },\n        {\n            # Case 3\n            \"wavelengths\": [11.0, 12.0], \"tau\": [0.99, 0.985], \"Lu\": [0.30, 0.30], \"Ld\": [7.50, 8.00],\n            \"Ts_true\": 280.0, \"eps_true\": 0.999,\n            \"sigma_e\": [0.05, 0.05],\n            \"xa\": [300.0, 0.97], \"Sa_diag\": [4.0**2, 0.02**2]\n        },\n        {\n            # Case 4\n            \"wavelengths\": [11.0, 12.0], \"tau\": [0.30, 0.25], \"Lu\": [5.00, 5.50], \"Ld\": [12.00, 12.50],\n            \"Ts_true\": 295.0, \"eps_true\": 0.90,\n            \"sigma_e\": [0.50, 0.50],\n            \"xa\": [330.0, 0.85], \"Sa_diag\": [20.0**2, 0.10**2]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = solve_case(case)\n        all_results.extend(results)\n\n    # Format output as specified\n    formatted_results = []\n    for i, res in enumerate(all_results):\n        if (i % 5 == 3): # Boolean convergence flag\n            formatted_results.append(str(res))\n        else: # Other values\n            formatted_results.append(f\"{res}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}