{
    "hands_on_practices": [
        {
            "introduction": "高效的阴影检测始于对光照基本物理原理的理解。一个被阴影覆盖的像元不仅仅是变暗了；它的光谱成分也发生了改变，因为它主要由富含蓝光的漫射天空光而非太阳直射光照亮。本练习  要求你通过构建一个基于物理模型的阴影可能性得分来量化这一效应，从而将辐射传输原理与实用的检测技术直接联系起来。",
            "id": "3801373",
            "problem": "一个覆盖均一植被冠层的多光谱卫星像元已经过大气校正得到地表反射率，测得蓝通道反射率 $\\rho_{\\mathrm{blue}} = 0.12$ 和红通道反射率 $\\rho_{\\mathrm{red}} = 0.06$。该像元处于一个被怀疑有投射阴影的空间背景中，目标是利用蓝红反射率比值，从第一性原理出发，量化一个阴影可能性得分。\n\n假设以下物理模型和条件：\n- 冠层近似表现为朗伯面，因此冠层顶部的辐射亮度 $L_{\\lambda}$ 通过 $L_{\\lambda} \\propto \\rho_{\\lambda} E_{\\lambda}$ 与地表反射率 $\\rho_{\\lambda}$ 和波段平均下行辐照度 $E_{\\lambda}$ 相关，在相同的几何条件下，比例常数在通道比值中被抵消。\n- 在邻近效应可忽略不计和双向几何条件相同的情况下，测得的反射率比值 $r \\equiv \\rho_{\\mathrm{blue}} / \\rho_{\\mathrm{red}}$ 由冠层的固有光谱反射率比值与光照的光谱比值的乘积控制，即 $r \\approx \\left(\\rho_{\\mathrm{blue}}^{\\mathrm{intr}} / \\rho_{\\mathrm{red}}^{\\mathrm{intr}}\\right)\\left(E_{\\mathrm{blue}} / E_{\\mathrm{red}}\\right)$。\n- 对于可见光波段的典型绿色植被，取其固有反射率比值 $\\gamma \\equiv \\rho_{\\mathrm{blue}}^{\\mathrm{intr}} / \\rho_{\\mathrm{red}}^{\\mathrm{intr}} = 1.3$，这反映了蓝光和红光波段相似的叶绿素吸收特性，但蓝光反射率略高。\n- 在以太阳直射为主的光照条件下，使用一个代表性的波段平均辐照度光谱比值 $\\alpha_{\\mathrm{sun}} \\equiv E_{\\mathrm{blue}} / E_{\\mathrm{red}} = 0.95$，这与由于大气散射和吸收导致地表太阳光谱偏红的情况一致。\n- 在晴天以天空光为主的阴影光照条件下，使用 $\\alpha_{\\mathrm{shad}} \\equiv E_{\\mathrm{blue}} / E_{\\mathrm{red}} = 1.8$，这反映了富含蓝光的漫射天空光。\n\n利用这些具有物理动机的量，定义光照充足的植被的预期蓝红反射率比值为 $r_{\\mathrm{sun}} \\equiv \\gamma \\alpha_{\\mathrm{sun}}$，阴影下的植被的预期蓝红反射率比值为 $r_{\\mathrm{shad}} \\equiv \\gamma \\alpha_{\\mathrm{shad}}$。构建一个阴影可能性得分 $S(r)$，该得分在 $r=r_{\\mathrm{sun}}$ 时赋值 $S=0$，在 $r=r_{\\mathrm{shad}}$ 时赋值 $S=1$，并假设该得分在 $r$ 上是线性映射，且与上述朗伯体和光谱混合假设一致。然后，根据给定的测量值，使用测得的比值 $r = \\rho_{\\mathrm{blue}} / \\rho_{\\mathrm{red}}$ 计算得分 $S$。\n\n报告最终得分，以无量纲小数形式表示，并四舍五入到四位有效数字。",
            "solution": "问题陈述已经过验证，被认为是合理的。其科学基础在于辐射传输和遥感的原理，提法恰当，提供了所有必要信息，且其表述是客观的。我们将继续进行解答。\n\n目标是根据一个植被像元测得的蓝、红通道地表反射率，计算其阴影可能性得分 $S$。该得分将从一个由理论上的光照和阴影条件定义的线性模型中推导出来。\n\n首先，我们根据给定数据计算测得的蓝红反射率比值 $r$：\n测得的蓝通道反射率, $\\rho_{\\mathrm{blue}} = 0.12$。\n测得的红通道反射率, $\\rho_{\\mathrm{red}} = 0.06$。\n\n测得的比值 $r$ 定义为：\n$$r = \\frac{\\rho_{\\mathrm{blue}}}{\\rho_{\\mathrm{red}}}$$\n代入给定值：\n$$r = \\frac{0.12}{0.06} = 2.0$$\n\n接下来，我们计算完全光照像元的理论参考比值 $r_{\\mathrm{sun}}$ 和完全阴影像元的理论参考比值 $r_{\\mathrm{shad}}$。这些计算基于所提供的物理模型。\n光照充足的植被的预期比值由 $r_{\\mathrm{sun}} = \\gamma \\alpha_{\\mathrm{sun}}$ 给出，其中 $\\gamma$ 是植被的固有反射率比值，$\\alpha_{\\mathrm{sun}}$ 是太阳直射下的辐照度光谱比值。\n给定：\n固有反射率比值, $\\gamma = 1.3$。\n光照条件下的辐照度比值, $\\alpha_{\\mathrm{sun}} = 0.95$。\n因此，光照参考比值为：\n$$r_{\\mathrm{sun}} = 1.3 \\times 0.95 = 1.235$$\n\n阴影下的植被的预期比值由 $r_{\\mathrm{shad}} = \\gamma \\alpha_{\\mathrm{shad}}$ 给出，其中 $\\alpha_{\\mathrm{shad}}$ 是以天空光为主的阴影下的辐照度光谱比值。\n给定：\n阴影条件下的辐照度比值, $\\alpha_{\\mathrm{shad}} = 1.8$。\n因此，阴影参考比值为：\n$$r_{\\mathrm{shad}} = 1.3 \\times 1.8 = 2.34$$\n\n阴影可能性得分 $S(r)$ 被定义为 $r$ 的一个线性函数，它将光照条件映射为得分 0，将阴影条件映射为得分 1。即，$S(r_{\\mathrm{sun}}) = 0$ 且 $S(r_{\\mathrm{shad}}) = 1$。\n设线性函数为 $S(r) = m \\cdot r + c$。我们可以使用这两个条件来确定斜率 $m$ 和截距 $c$。\n斜率 $m$ 为：\n$$m = \\frac{S(r_{\\mathrm{shad}}) - S(r_{\\mathrm{sun}})}{r_{\\mathrm{shad}} - r_{\\mathrm{sun}}} = \\frac{1 - 0}{r_{\\mathrm{shad}} - r_{\\mathrm{sun}}} = \\frac{1}{r_{\\mathrm{shad}} - r_{\\mathrm{sun}}}$$\n使用点 $(r_{\\mathrm{sun}}, 0)$ 的点斜式方程：\n$$S(r) - S(r_{\\mathrm{sun}}) = m (r - r_{\\mathrm{sun}})$$\n$$S(r) - 0 = \\left(\\frac{1}{r_{\\mathrm{shad}} - r_{\\mathrm{sun}}}\\right) (r - r_{\\mathrm{sun}})$$\n这给出了得分的通用公式：\n$$S(r) = \\frac{r - r_{\\mathrm{sun}}}{r_{\\mathrm{shad}} - r_{\\mathrm{sun}}}$$\n这个方程表示对测量比值 $r$ 进行线性归一化，将其映射到由参考比值 $r_{\\mathrm{sun}}$ 和 $r_{\\mathrm{shad}}$ 定义的 $[0, 1]$ 区间。\n\n最后，我们将计算出的 $r$、$r_{\\mathrm{sun}}$ 和 $r_{\\mathrm{shad}}$ 的值代入此表达式，以计算给定像元的得分。\n$$S = \\frac{2.0 - 1.235}{2.34 - 1.235}$$\n$$S = \\frac{0.765}{1.105}$$\n$$S \\approx 0.6923076923...$$\n\n问题要求结果四舍五入到四位有效数字。\n$$S \\approx 0.6923$$\n这个得分表明，该像元的光谱特征明显更接近纯阴影情况（$S=1$）而非纯光照情况（$S=0$），这与它位于投射阴影中的初步怀疑是一致的。",
            "answer": "$$\\boxed{0.6923}$$"
        },
        {
            "introduction": "卫星传感器的像元很少只包含单一、纯净的地物类型。本练习  超越了简单的二元分类，通过应用线性混合模型来估算亚像元云量，以解决部分多云像元这一常见场景。更关键的是，它还引入了不确定性传播分析，提供了一种动手实践的方法，来评估云物理属性的可变性如何影响你所推导的云量估算的置信度。",
            "id": "3801428",
            "problem": "一颗天底观测的多光谱卫星观测到一个部分有云的像元，该像元所在的可见光波段的各向异性足够弱，以至于云场和晴空地-气系统都可以被视为朗伯体。设大气层顶（TOA）反射率（定义为 $ \\rho_{\\mathrm{TOA}} = \\pi L / (E_{0} \\cos \\theta_{0}) $）的测量值为 $ \\rho_{\\mathrm{TOA}} = 0.4 $，其中 $ L $ 为传感器处的辐亮度，$ E_{0} $ 为大气层外辐照度，$ \\theta_{0} $ 为太阳天顶角。该场景被建模为一个亚像元混合体，由反射率为 $ \\rho_{\\mathrm{cloud}} $ 的有云部分和反射率为 $ \\rho_{\\mathrm{clear}} $ 的晴空部分组成，云量为 $ f $，晴空量为 $ 1-f $。晴空TOA反射率被独立表征为 $ \\rho_{\\mathrm{clear}} = 0.1 $，当前条件下有云部分的TOA反射率为 $ \\rho_{\\mathrm{cloud}} = 0.8 $。使用物理学上的标准假设，即独立组分的辐亮度在面积上线性相加，并且在固定光照下到反射率的映射是线性的，求出亚像元云量 $ f $。\n\n接下来，在一个基于物理的云反射率参数化方案下，评估由云光学厚度 $ \\tau $ 的变化引起的 $ f $ 的不确定性。假设云反射率由一个半无限近似参数化方案控制，\n$$\n\\rho_{\\mathrm{cloud}}(\\tau) = \\rho_{\\infty}\\left(1 - \\exp(-\\beta \\tau)\\right),\n$$\n其中 $ \\rho_{\\infty} = 0.9 $，$ \\beta = 0.6 $。设 $ \\tau_{0} $ 是使 $ \\rho_{\\mathrm{cloud}}(\\tau_{0}) = 0.8 $ 的光学厚度，并假设反演得到的光学厚度的标准不确定度为 $ \\sigma_{\\tau} = 0.2 $。使用一阶（线性）不确定性传播方法，并将所有其他量视为固定值，计算云量 $ f $ 的标准不确定度 $ \\sigma_{f} $。\n\n将 $ f $ 和 $ \\sigma_{f} $ 均表示为无量纲数，并均四舍五入到四位有效数字。最终答案必须同时包含这两个值。",
            "solution": "该问题陈述已经过严格评估，并被确定为有效。它在科学上基于辐射传输和遥感的原理，问题设定良好，有足够的信息得出唯一解，并使用客观精确的术语进行表述。所有提供的数值都是物理上现实的。该问题是线性混合模型和不确定性分析的一个标准应用。因此，将构建一个解决方案。\n\n该问题分两部分解决：首先，确定亚像元云量 $f$；其次，估计该云量的不确定度 $\\sigma_f$。\n\n第一部分：计算亚像元云量 $f$。\n\n提供的核心物理模型是大气层顶（TOA）反射率 $\\rho_{\\mathrm{TOA}}$ 的线性混合模型。该模型假设从一个像元测得的总反射率是其组成部分反射率的面积加权平均值。在本例中，这些组分是一个云量为 $f$、反射率为 $\\rho_{\\mathrm{cloud}}$ 的有云部分，以及一个晴空量为 $1-f$、反射率为 $\\rho_{\\mathrm{clear}}$ 的晴空部分。辐亮度线性相加以及在固定光照下到反射率的映射是线性的这一假设，导出了以下方程：\n$$\n\\rho_{\\mathrm{TOA}} = f \\rho_{\\mathrm{cloud}} + (1-f) \\rho_{\\mathrm{clear}}\n$$\n我们的目标是求解云量 $f$。我们对该方程进行代数整理：\n$$\n\\rho_{\\mathrm{TOA}} = f \\rho_{\\mathrm{cloud}} + \\rho_{\\mathrm{clear}} - f \\rho_{\\mathrm{clear}}\n$$\n$$\n\\rho_{\\mathrm{TOA}} - \\rho_{\\mathrm{clear}} = f (\\rho_{\\mathrm{cloud}} - \\rho_{\\mathrm{clear}})\n$$\n分离出 $f$ 得到云量用组分反射率表示的表达式：\n$$\nf = \\frac{\\rho_{\\mathrm{TOA}} - \\rho_{\\mathrm{clear}}}{\\rho_{\\mathrm{cloud}} - \\rho_{\\mathrm{clear}}}\n$$\n问题为这部分提供了以下数值：$\\rho_{\\mathrm{TOA}} = 0.4$，$\\rho_{\\mathrm{clear}} = 0.1$ 和 $\\rho_{\\mathrm{cloud}} = 0.8$。将这些值代入 $f$ 的表达式中：\n$$\nf = \\frac{0.4 - 0.1}{0.8 - 0.1} = \\frac{0.3}{0.7} = \\frac{3}{7}\n$$\n换算成小数，即 $f \\approx 0.4285714$。按要求四舍五入到四位有效数字，我们得到：\n$$\nf = 0.4286\n$$\n\n第二部分：计算云量的不确定度 $\\sigma_f$。\n\n$f$ 的不确定性源于云光学厚度 $\\tau$ 的不确定性。问题指明，云反射率 $\\rho_{\\mathrm{cloud}}$ 是 $\\tau$ 的函数，由以下参数化方案给出：\n$$\n\\rho_{\\mathrm{cloud}}(\\tau) = \\rho_{\\infty}\\left(1 - \\exp(-\\beta \\tau)\\right)\n$$\n其中常数 $\\rho_{\\infty} = 0.9$，$ \\beta = 0.6 $。\n\n因此，云量 $f$ 也是 $\\tau$ 的函数：\n$$\nf(\\tau) = \\frac{\\rho_{\\mathrm{TOA}} - \\rho_{\\mathrm{clear}}}{\\rho_{\\mathrm{cloud}}(\\tau) - \\rho_{\\mathrm{clear}}}\n$$\n题目要求我们使用一阶不确定性传播。对于函数 $f(\\tau)$，其标准不确定度 $\\sigma_f$ 与标准不确定度 $\\sigma_\\tau$ 的关系由下式给出：\n$$\n\\sigma_f = \\left| \\frac{df}{d\\tau} \\right| \\sigma_\\tau\n$$\n该导数必须在工作点处计算，该工作点由 $\\rho_{\\mathrm{cloud}}(\\tau_0) = 0.8$ 指定。\n\n首先，我们必须计算导数 $\\frac{df}{d\\tau}$。使用链式法则：\n$$\n\\frac{df}{d\\tau} = \\frac{d}{d\\tau} \\left[ (\\rho_{\\mathrm{TOA}} - \\rho_{\\mathrm{clear}}) \\left( \\rho_{\\mathrm{cloud}}(\\tau) - \\rho_{\\mathrm{clear}} \\right)^{-1} \\right]\n$$\n$$\n\\frac{df}{d\\tau} = -(\\rho_{\\mathrm{TOA}} - \\rho_{\\mathrm{clear}}) \\left( \\rho_{\\mathrm{cloud}}(\\tau) - \\rho_{\\mathrm{clear}} \\right)^{-2} \\frac{d\\rho_{\\mathrm{cloud}}}{d\\tau}\n$$\n接下来，我们计算 $\\rho_{\\mathrm{cloud}}(\\tau)$ 的导数：\n$$\n\\frac{d\\rho_{\\mathrm{cloud}}}{d\\tau} = \\frac{d}{d\\tau} \\left[ \\rho_{\\infty}\\left(1 - \\exp(-\\beta \\tau)\\right) \\right] = \\rho_{\\infty} \\left( - \\exp(-\\beta \\tau) \\cdot (-\\beta) \\right) = \\rho_{\\infty} \\beta \\exp(-\\beta \\tau)\n$$\n我们需要在 $\\tau_0$ 处计算这个导数，其中 $\\rho_{\\mathrm{cloud}}(\\tau_0) = 0.8$。我们可以用已知量来表示 $\\exp(-\\beta \\tau_0)$。根据云反射率模型：\n$$\n\\rho_{\\mathrm{cloud}}(\\tau_0) = \\rho_{\\infty}\\left(1 - \\exp(-\\beta \\tau_0)\\right)\n$$\n$$\n\\frac{\\rho_{\\mathrm{cloud}}(\\tau_0)}{\\rho_{\\infty}} = 1 - \\exp(-\\beta \\tau_0)\n$$\n$$\n\\exp(-\\beta \\tau_0) = 1 - \\frac{\\rho_{\\mathrm{cloud}}(\\tau_0)}{\\rho_{\\infty}}\n$$\n将此代回在 $\\tau_0$ 处的 $\\frac{d\\rho_{\\mathrm{cloud}}}{d\\tau}$ 表达式中：\n$$\n\\left. \\frac{d\\rho_{\\mathrm{cloud}}}{d\\tau} \\right|_{\\tau=\\tau_0} = \\rho_{\\infty} \\beta \\left( 1 - \\frac{\\rho_{\\mathrm{cloud}}(\\tau_0)}{\\rho_{\\infty}} \\right) = \\beta (\\rho_{\\infty} - \\rho_{\\mathrm{cloud}}(\\tau_0))\n$$\n现在，我们可以整合出在 $\\tau_0$ 处计算的 $\\frac{df}{d\\tau}$ 的完整表达式：\n$$\n\\left. \\frac{df}{d\\tau} \\right|_{\\tau=\\tau_0} = - \\frac{\\rho_{\\mathrm{TOA}} - \\rho_{\\mathrm{clear}}}{(\\rho_{\\mathrm{cloud}}(\\tau_0) - \\rho_{\\mathrm{clear}})^2} \\cdot \\beta (\\rho_{\\infty} - \\rho_{\\mathrm{cloud}}(\\tau_0))\n$$\n我们代入给定的数值：$\\rho_{\\mathrm{TOA}} = 0.4$，$\\rho_{\\mathrm{clear}} = 0.1$，$\\rho_{\\mathrm{cloud}}(\\tau_0) = 0.8$，$\\rho_{\\infty} = 0.9$ 和 $\\beta = 0.6$：\n$$\n\\left. \\frac{df}{d\\tau} \\right|_{\\tau=\\tau_0} = - \\frac{0.4 - 0.1}{(0.8 - 0.1)^2} \\cdot 0.6 \\cdot (0.9 - 0.8)\n$$\n$$\n\\left. \\frac{df}{d\\tau} \\right|_{\\tau=\\tau_0} = - \\frac{0.3}{(0.7)^2} \\cdot 0.6 \\cdot (0.1) = - \\frac{0.3}{0.49} \\cdot 0.06 = - \\frac{0.018}{0.49}\n$$\n计算结果约等于 $-0.03673469$。负号表明，正如预期的那样，对于固定的混合像元反射率 $\\rho_{\\mathrm{TOA}}$，更高的云反射率（来自更高的 $\\tau$）意味着需要更小的云量 $f$。\n\n最后，我们使用给定的光学厚度标准不确定度 $\\sigma_\\tau = 0.2$ 来计算不确定度 $\\sigma_f$：\n$$\n\\sigma_f = \\left| \\left. \\frac{df}{d\\tau} \\right|_{\\tau=\\tau_0} \\right| \\sigma_\\tau = \\left| - \\frac{0.018}{0.49} \\right| \\cdot 0.2 \\approx 0.03673469 \\cdot 0.2 \\approx 0.007346938\n$$\n四舍五入到四位有效数字，我们得到：\n$$\n\\sigma_f = 0.007347\n$$\n云量及其标准不确定度的最终结果是 $f=0.4286$ 和 $\\sigma_f=0.007347$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.4286 & 0.007347 \\end{pmatrix}}$$"
        },
        {
            "introduction": "稳健的检测算法不仅利用单个像元的光谱特征，还会利用其空间上下文信息。云通常表现出独特的纹理模式，这使其有别于雪地或平静水体等平滑表面。本动手实践练习  将指导你基于局部空间方差构建一个云检测器，并学习使用形态学运算来优化输出结果，最终生成一个空间上连续、完整的云掩膜。",
            "id": "3801425",
            "problem": "考虑一个多光谱可见光波段场景，由三个二维反射率数组表示，分别对应蓝、绿、红三个波段。反射率定义为上行辐射亮度与下行辐射照度的比值，是无量纲的。对于大气层顶 (TOA) 反射率，通常的辐射转换是通过太阳辐照度和太阳天顶角将光谱辐射亮度转换为反射率，但在本练习中，输入已经是 TOA 反射率值。可见光 (VIS) 波段是光谱中包含蓝、绿、红波长的部分。在可见光影像中，由于微物理异质性和云元素的阴影遮蔽，云通常表现出高反射率和空间纹理，这可以通过方差等局部空间统计量来捕捉。形态学闭运算是数学形态学中的一种标准操作，它通过使用选定的结构元素执行一次膨胀再进行一次侵蚀，来稳定破碎的检测结果。\n\n从以下基本原理出发：\n- 图像的空间统计学：对于一个标量场 $I(x,y)$，在一个以 $(x,y)$ 为中心、大小为 $w \\times w$ 的有限邻域 $K$ 上的局部均值为 $$\\mu(x,y) = \\frac{1}{|K|} \\sum_{(i,j)\\in K} I(x+i,y+j),$$ 局部二阶矩为 $$m_2(x,y) = \\frac{1}{|K|} \\sum_{(i,j)\\in K} I(x+i,y+j)^2.$$ 局部方差为 $$\\sigma^2(x,y) = m_2(x,y) - \\mu(x,y)^2.$$\n- 数学形态学：对于一个二值图像 $D(x,y)\\in\\{0,1\\}$ 和一个二值结构元素 $S$，膨胀是用 $S$ 来扩张 $D$，侵蚀是用 $S$ 来收缩 $D$；闭运算定义为 $$\\text{close}(D,S) = \\text{erode}(\\text{dilate}(D,S),S)。$$\n\n您的任务是利用可见光波段的局部方差推导出一个基于邻域的云分数，并用形态学闭运算来稳定破碎的检测结果，然后实现该方法并将其应用于提供的测试套件。\n\n从上述基本原理出发，且不使用任何简便公式，为每个像素推导出一个标量云分数 $s(x,y)$，该分数聚合了蓝、绿、红反射率波段的局部方差。推导过程应使用宽度为 $w$ 的方形邻域，计算每个波段的局部方差，将它们聚合成一个标量，并使用一个固定尺度 $T>0$ 将结果归一化到 $[0,1]$ 范围内。通过在固定水平 $\\tau \\in (0,1)$ 对 $s(x,y)$ 进行阈值化，定义一个二值检测图 $d(x,y)$，然后通过应用一个 $3 \\times 3$ 的方形结构元素进行形态学闭运算，得到一个稳定的检测结果 $\\hat{d}(x,y)$。\n\n程序的实现要求：\n- 对于局部统计，使用宽度为 $w = 3$ 像素的方形邻域，并通过对称反射处理边缘。\n- 在归一化之前，通过计算各波段局部方差的算术平均值，将它们聚合成一个单一标量场。\n- 使用固定正尺度 $T = 0.005$ 归一化聚合后的局部方差，以获得一个裁剪到 $[0,1]$ 区间的无量纲分数 $s(x,y)$。\n- 使用检测阈值 $\\tau = 0.6$ 来形成 $d(x,y)$。\n- 应用一个 $3 \\times 3$ 的方形结构元素进行形态学闭运算，以获得 $\\hat{d}(x,y)$。\n\n测试套件：\n给定四个合成的多光谱场景，每个场景由三个对应蓝、绿、红 TOA 反射率的 $6 \\times 6$ 数组表示。所有反射率均为无量纲。\n\n- 测试用例 1 (带有纹理云核的混合场景)：\n  - 蓝光波段 $R^{(B)}$：除中心 $3 \\times 3$ 区域外，基准值均为 $0.15$，该区域的值为\n    $$\\begin{bmatrix}\n    0.45  0.50  0.47 \\\\\n    0.48  0.55  0.49 \\\\\n    0.46  0.52  0.48\n    \\end{bmatrix}.$$\n  - 绿光波段 $R^{(G)}$：除中心 $3 \\times 3$ 区域外，基准值均为 $0.18$，该区域的值为\n    $$\\begin{bmatrix}\n    0.52  0.58  0.54 \\\\\n    0.55  0.62  0.56 \\\\\n    0.53  0.59  0.55\n    \\end{bmatrix}.$$\n  - 红光波段 $R^{(R)}$：除中心 $3 \\times 3$ 区域外，基准值均为 $0.14$，该区域的值为\n    $$\\begin{bmatrix}\n    0.43  0.48  0.45 \\\\\n    0.46  0.51  0.47 \\\\\n    0.44  0.49  0.46\n    \\end{bmatrix}.$$\n\n- 测试用例 2 (均匀晴空)：\n  - 蓝、绿、红波段在整个 $6 \\times 6$ 网格上均为常数 $0.12$。\n\n- 测试用例 3 (均匀明亮表面，如雪，但空间同质)：\n  - 蓝、绿、红波段在整个 $6 \\times 6$ 网格上均为常数 $0.65$。\n\n- 测试用例 4 (边缘附近带小孔的破碎亮斑)：\n  - 蓝光波段 $R^{(B)}$：除左上角（行 $0$–$2$，列 $0$–$2$）的 $3 \\times 3$ 区域外，基准值为 $0.20$，该区域的值设置为\n    $$\\begin{bmatrix}\n    0.50  0.52  0.51 \\\\\n    0.53  0.20  0.54 \\\\\n    0.51  0.55  0.52\n    \\end{bmatrix},$$\n    其中中心元素 $0.20$ 形成一个孔洞。\n  - 绿光波段 $R^{(G)}$：基准值为 $0.22$，同样在 $3 \\times 3$ 区域设置为\n    $$\\begin{bmatrix}\n    0.56  0.57  0.55 \\\\\n    0.58  0.22  0.59 \\\\\n    0.56  0.60  0.57\n    \\end{bmatrix}.$$\n  - 红光波段 $R^{(R)}$：基准值为 $0.19$，同样在 $3 \\times 3$ 区域设置为\n    $$\\begin{bmatrix}\n    0.48  0.50  0.49 \\\\\n    0.51  0.19  0.52 \\\\\n    0.49  0.53  0.50\n    \\end{bmatrix}.$$\n\n对于每个测试用例，计算：\n- 稳定后的检测结果 $\\hat{d}(x,y)$ 中的云像素总数（整数）。\n- 在 $\\hat{d}(x,y) = 1$ 的像素上的平均云分数（浮点数），表示为无量纲小数，四舍五入到小数点后5位；如果没有云像素，则定义平均云分数为 $0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个 $[\\text{count}, \\text{mean}]$ 形式的双元素列表。例如，输出应类似于 $[[c_1,m_1],[c_2,m_2],[c_3,m_3],[c_4,m_4]]$，其中 $c_i$ 为整数，$m_i$ 为四舍五入到五位小数的小数。不应打印任何其他文本。",
            "solution": "该问题陈述具有科学依据、表述清晰且客观。它基于遥感和图像处理的既定原则，提供了所有必要的数据和参数，并且没有歧义或矛盾。因此，我们可以着手解决。\n\n目标是制定并实现一种基于局部空间纹理的云检测算法，然后将其应用于一系列测试用例。推导和实现过程分为五个主要步骤：(1) 计算每个光谱波段的局部方差，(2) 聚合与归一化方差以生成云分数，(3) 对分数进行阈值化以创建初始二值检测结果，(4) 使用形态学闭运算稳定检测结果，以及 (5) 从最终结果中计算汇总统计数据。\n\n### 步骤 1: 局部方差计算\n\n物理前提是，由于其微物理异质性和三维结构，云比晴空地表表现出更强的空间纹理。这种纹理可以通过局部统计离散度的度量（如方差）来量化。我们得到三个大气层顶 (TOA) 反射率的输入波段，$R^{(c)}(x,y)$，其中 $c \\in \\{B, G, R\\}$ 分别代表蓝、绿、红波段。\n\n对于每个波段 $c$，我们计算一个局部方差图 $\\sigma_c^2(x,y)$。问题指定使用方差的基本定义。对于坐标为 $(x,y)$ 的给定像素，我们考虑一个以此像素为中心、宽度为 $w=3$ 的方形邻域 $K$。该邻域中的像素数为 $|K| = w^2 = 9$。\n\n局部平均反射率 $\\mu_c(x,y)$ 是邻域 $K$ 内反射率值的算术平均值：\n$$ \\mu_c(x,y) = \\frac{1}{|K|} \\sum_{(i,j)\\in K'} R^{(c)}(x+i, y+j) $$\n其中 $K'$ 代表距中心的相对偏移量集合，此处为从 $(-1,-1)$ 到 $(1,1)$。\n\n局部二阶矩 $m_{2,c}(x,y)$ 是同一邻域内反射率值平方的平均值：\n$$ m_{2,c}(x,y) = \\frac{1}{|K|} \\sum_{(i,j)\\in K'} [R^{(c)}(x+i, y+j)]^2 $$\n\n局部方差则由以下关系式给出：\n$$ \\sigma_c^2(x,y) = m_{2,c}(x,y) - [\\mu_c(x,y)]^2 $$\n对三个波段中的每个像素 $(x,y)$ 都执行此计算，从而生成三个方差图：$\\sigma_B^2(x,y)$、$\\sigma_G^2(x,y)$ 和 $\\sigma_R^2(x,y)$。\n\n对于靠近图像边界的像素，其 $w \\times w$ 邻域会超出图像域。问题指定使用“对称反射”来处理这些边缘。这对应于一种填充模式，即通过在边界处镜像来扩展图像。在计算上，这是通过应用具有适当边界处理模式的滑动窗口算子（例如，均匀滤波器）来实现的，例如 `scipy.ndimage` 库中的 `mode='mirror'`，它以最后一个像素的中心为轴进行反射。\n\n### 步骤 2: 聚合与归一化\n\n为了获得一个单一、综合性的云指示符，需要聚合特定波段的方差。问题要求使用它们的算术平均值。设 $V(x,y)$ 为聚合方差：\n$$ V(x,y) = \\frac{1}{3} \\left( \\sigma_B^2(x,y) + \\sigma_G^2(x,y) + \\sigma_R^2(x,y) \\right) $$\n\n这个聚合方差 $V(x,y)$ 可作为原始纹理分数。为了将其转换为范围在 $[0, 1]$ 内的归一化无量纲云分数 $s(x,y)$，我们用一个固定的正常数 $T = 0.005$ 对其进行缩放。然后将分数裁剪到有效范围内。\n$$ s(x,y) = \\text{clip} \\left( \\frac{V(x,y)}{T}, 0, 1 \\right) $$\n由于方差 $V(x,y)$ 是非负的，这可以简化为：\n$$ s(x,y) = \\min \\left( \\frac{V(x,y)}{T}, 1 \\right) $$\n\n### 步骤 3: 阈值化\n\n通过对云分数图 $s(x,y)$ 应用固定阈值 $\\tau = 0.6$，生成一个二值云检测图 $d(x,y)$。分数大于或等于阈值的像素被分类为云 ($1$)，其他则为非云 ($0$)。\n$$ d(x,y) = \\begin{cases} 1 & \\text{if } s(x,y) \\ge \\tau \\\\ 0 & \\text{if } s(x,y) < \\tau \\end{cases} $$\n这个初始图可能包含伪检测或呈破碎状，尤其是在纹理复杂的区域。\n\n### 步骤 4: 形态学闭运算\n\n为了提高检测图的空间连贯性，我们应用形态学闭运算。闭运算是一种标准的图像处理操作，倾向于填充小孔并连接邻近物体。它被定义为使用指定的结构元素 $S$ 进行一次膨胀操作，然后进行一次侵蚀操作。\n$$ \\hat{d}(x,y) = \\text{close}(d(x,y), S) = \\text{erode}(\\text{dilate}(d(x,y), S), S) $$\n在这里，$S$ 是一个 $3 \\times 3$ 的方形结构元素，即一个全为1的矩阵。膨胀操作会扩张检测到的云像素区域，填补小间隙。随后的侵蚀操作会收缩扩张后的区域，但新填补的间隙通常会保持填充状态。其结果是一个“稳定”的检测图 $\\hat{d}(x,y)$。\n\n### 步骤 5: 最终指标计算\n\n最后，对于每个测试用例，我们从稳定后的检测图 $\\hat{d}(x,y)$ 和云分数图 $s(x,y)$ 中计算两个指标：\n1.  云像素总数 $c$，是最终二值图中所有像素值的总和：\n    $$ c = \\sum_{x,y} \\hat{d}(x,y) $$\n2.  平均云分数 $m$，是在最终图中被识别为云的像素上计算的。它是云覆盖像素的分数总和除以云像素总数。如果没有检测到云像素 ($c=0$)，则平均分数定义为 $0$。\n    $$ m = \\begin{cases} \\frac{1}{c} \\sum_{x,y} s(x,y) \\cdot \\hat{d}(x,y) & \\text{if } c > 0 \\\\ 0 & \\text{if } c = 0 \\end{cases} $$\n对每个提供的测试用例实施这些步骤，以产生最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import uniform_filter, binary_closing\n\ndef solve():\n    \"\"\"\n    Main function to execute the cloud detection algorithm on the test suite.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    w = 3         # Neighborhood width for local statistics\n    T = 0.005     # Normalization scale for cloud score\n    tau = 0.6     # Detection threshold for cloud score\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Mixture with textured cloud core\n        {\n            \"name\": \"case 1\",\n            \"R_b\": np.full((6, 6), 0.15, dtype=float),\n            \"R_g\": np.full((6, 6), 0.18, dtype=float),\n            \"R_r\": np.full((6, 6), 0.14, dtype=float),\n        },\n        # Test case 2: Uniform clear sky\n        {\n            \"name\": \"case 2\",\n            \"R_b\": np.full((6, 6), 0.12, dtype=float),\n            \"R_g\": np.full((6, 6), 0.12, dtype=float),\n            \"R_r\": np.full((6, 6), 0.12, dtype=float),\n        },\n        # Test case 3: Uniform bright surface (snow)\n        {\n            \"name\": \"case 3\",\n            \"R_b\": np.full((6, 6), 0.65, dtype=float),\n            \"R_g\": np.full((6, 6), 0.65, dtype=float),\n            \"R_r\": np.full((6, 6), 0.65, dtype=float),\n        },\n        # Test case 4: Fragmented bright patches with a small hole\n        {\n            \"name\": \"case 4\",\n            \"R_b\": np.full((6, 6), 0.20, dtype=float),\n            \"R_g\": np.full((6, 6), 0.22, dtype=float),\n            \"R_r\": np.full((6, 6), 0.19, dtype=float),\n        },\n    ]\n\n    # Populate special values for test cases\n    # Case 1\n    test_cases[0][\"R_b\"][2:5, 2:5] = np.array([[0.45, 0.50, 0.47], [0.48, 0.55, 0.49], [0.46, 0.52, 0.48]])\n    test_cases[0][\"R_g\"][2:5, 2:5] = np.array([[0.52, 0.58, 0.54], [0.55, 0.62, 0.56], [0.53, 0.59, 0.55]])\n    test_cases[0][\"R_r\"][2:5, 2:5] = np.array([[0.43, 0.48, 0.45], [0.46, 0.51, 0.47], [0.44, 0.49, 0.46]])\n\n    # Case 4\n    test_cases[3][\"R_b\"][0:3, 0:3] = np.array([[0.50, 0.52, 0.51], [0.53, 0.20, 0.54], [0.51, 0.55, 0.52]])\n    test_cases[3][\"R_g\"][0:3, 0:3] = np.array([[0.56, 0.57, 0.55], [0.58, 0.22, 0.59], [0.56, 0.60, 0.57]])\n    test_cases[3][\"R_r\"][0:3, 0:3] = np.array([[0.48, 0.50, 0.49], [0.51, 0.19, 0.52], [0.49, 0.53, 0.50]])\n    \n    results = []\n    \n    for case in test_cases:\n        # Assemble bands for processing\n        reflectance_bands = [case[\"R_b\"], case[\"R_g\"], case[\"R_r\"]]\n        \n        # Step 1: Local Variance Calculation for each band\n        all_band_variances = []\n        for band_data in reflectance_bands:\n            # The 'mirror' mode in scipy.ndimage corresponds to symmetric reflection\n            # by mirroring about the center of boundary pixels.\n            local_mean = uniform_filter(band_data, size=w, mode='mirror')\n            local_second_moment = uniform_filter(np.square(band_data), size=w, mode='mirror')\n            \n            variance = local_second_moment - np.square(local_mean)\n            # Correct for potential floating point inaccuracies\n            variance[variance < 0] = 0\n            all_band_variances.append(variance)\n            \n        # Step 2: Aggregation and Normalization\n        aggregated_variance = np.mean(np.array(all_band_variances), axis=0)\n        cloud_score = aggregated_variance / T\n        cloud_score = np.clip(cloud_score, 0, 1)\n        \n        # Step 3: Thresholding\n        detection_map = cloud_score >= tau\n        \n        # Step 4: Morphological Closing\n        structuring_element = np.ones((3, 3), dtype=bool)\n        stabilized_detection = binary_closing(detection_map, structure=structuring_element)\n        \n        # Step 5: Final Metrics Calculation\n        cloud_pixels_mask = stabilized_detection == 1\n        count = np.sum(cloud_pixels_mask)\n        \n        if count == 0:\n            mean_score = 0.0\n        else:\n            mean_score = np.mean(cloud_score[cloud_pixels_mask])\n            \n        results.append([int(count), f\"{mean_score:.5f}\"])\n\n    # Final print statement in the exact required format.\n    results_str = [f\"[{c},{m}]\" for c, m in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}