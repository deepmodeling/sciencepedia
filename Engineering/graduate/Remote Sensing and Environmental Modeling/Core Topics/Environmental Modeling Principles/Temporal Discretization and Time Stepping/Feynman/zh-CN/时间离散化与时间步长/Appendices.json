{
    "hands_on_practices": [
        {
            "introduction": "理论上的精度阶数和稳定性是选择时间步进方案的基石。第一个练习将提供一个基础的动手实践：你将实现几种经典的数值方法，并使用标准的线性测试方程来凭经验验证它们的收敛阶数。通过这个过程 ，你将直观地理解刚性（stiffness）如何影响显式和隐式方法的性能与稳定性，这是环境建模中的一个关键概念。",
            "id": "3859481",
            "problem": "考虑线性常微分方程 (ODE) 初值问题 $y'(t)=-\\lambda y(t)$，对于 $t \\in [0,T]$，初值条件为 $y(0)=y_0$，其中 $\\lambda>0$。其精确解为 $y(t)=y_0 \\exp(-\\lambda t)$。这个线性测试问题是环境模型中线性化松弛过程时间行为的一个标准代理，并用于评估数值时间步进格式，这些格式也用于由遥感信息驱动的数据驱动状态估计。您的任务是设计一个程序，该程序针对一组给定的参数，通过比较连续两次步长减半后的全局误差，计算在最终时刻的观测精度阶，这需要对以下三种方法中的每一种进行计算：\n\n- 显式（前向）Euler 方法：$y_{n+1} = y_n + h f(t_n,y_n)$。\n- 隐式（后向）Euler 方法：$y_{n+1} = y_n + h f(t_{n+1},y_{n+1})$。\n- Heun 方法（显式梯形法，一种二阶 Runge–Kutta 方法）：$y_{n+1} = y_n + \\frac{h}{2}\\left(f(t_n,y_n)+f(t_n+h,y_n+h f(t_n,y_n))\\right)$。\n\n这里，$f(t,y)=-\\lambda y$，$h$ 是时间步长，而最终时刻 $T$ 的数值解是在 $N$ 步之后得到的，其中 $h = T/N$。对于给定的基础步数 $N_0$，通过每次将步数加倍来定义两次细化，即使用 $N_0$、$2N_0$ 和 $4N_0$，这对应于 $h$、$h/2$ 和 $h/4$。对于每种方法和每组参数，计算在最终时刻对于步长 $h$、$h/2$ 和 $h/4$ 的全局误差 $E(h)=\\lvert y_N - y(T)\\rvert$。然后通过比较连续细化之间的误差来估计观测到的精度阶，并将从 $(h,h/2)$ 和 $(h/2,h/4)$ 这两对中得到的两个估计值取平均。在您的实现中，不要使用任何解析误差常数或预先推导的误差阶公式；而应仅根据在三种分辨率下数值运行所获得的误差来估算。\n\n您必须遵守的科学依据：\n- 使用在固定最终时刻 $T$ 的全局误差定义，以及对于一个相容的方法，存在一个常数 $C$ 和一个阶 $p>0$，使得当 $h \\to 0$ 时，$E(h) \\approx C h^p$。\n- 仅使用问题的精确解 $y(T)=y_0 \\exp(-\\lambda T)$ 来计算误差；不要使用构造解析解法或内部误差估计器。\n\n测试套件：\n所有情况均使用 $y_0 = 1$。对于每种情况，程序必须首先将基础步数 $N_0$ 设置为最接近 $T/h_0$ 的整数，即 $N_0 = \\operatorname{round}(T/h_0)$，然后使用 $N_0$、$2N_0$ 和 $4N_0$。这保证了在每种分辨率下都能精确达到最终时刻 $T$。\n\n为以下四组参数提供观测到的精度阶，这些参数组被选择用来探测非刚性、中度刚性、稳定域内刚性以及接近不稳定域的刚性区域：\n- 情况 A（非刚性）：$\\lambda = 1$, $T = 1$, $h_0 = 0.2$。\n- 情况 B（中度刚性，显式方法的边界）：$\\lambda = 20$, $T = 1$, $h_0 = 0.1$。\n- 情况 C（刚性，但在细化后处于显式稳定域内）：$\\lambda = 100$, $T = 1$, $h_0 = 0.015$。\n- 情况 D（非常刚性，粗糙步长下显式方法不稳定但时间域短）：$\\lambda = 500$, $T = 0.1$, $h_0 = 0.05$。\n\n您的程序必须：\n- 完全按照上面的定义实现这三种方法。\n- 对于每种情况，通过对从 $N_0$、$2N_0$ 和 $4N_0$ 三种分辨率中获得的两个基于细化的估计值进行平均，来计算每种方法的观测精度阶。\n- 返回单行输出，其中包含 12 个浮点数结果，形式为由逗号分隔并用方括号括起来的列表。序列必须是按 A、B、C、D 的顺序排列每种情况，每种情况内按显式 Euler、隐式 Euler 和 Heun 方法的顺序排列其观测到的精度阶。例如，输出格式为 $[\\text{A\\_EE},\\text{A\\_IE},\\text{A\\_HM},\\text{B\\_EE},\\text{B\\_IE},\\text{B\\_HM},\\text{C\\_EE},\\text{C\\_IE},\\text{C\\_HM},\\text{D\\_EE},\\text{D\\_IE},\\text{D\\_HM}]$，其中 $\\text{EE}$ 代表显式 Euler，$\\text{IE}$ 代表隐式 Euler，$\\text{HM}$ 代表 Heun 方法。在输出前，将每个报告值数值上四舍五入到 6 位小数。\n\n角度单位不适用。不涉及物理单位；所有量均为无量纲。最终输出必须是具有上述确切列表语法的单行文本。",
            "solution": "### **问题验证**\n\n#### **步骤 1：提取已知信息**\n\n问题陈述提供了以下信息：\n- **常微分方程 (ODE)**：$y'(t)=-\\lambda y(t)$，对于 $t \\in [0,T]$。\n- **初始条件**：$y(0)=y_0$。\n- **参数约束**：$\\lambda>0$。\n- **精确解**：$y(t)=y_0 \\exp(-\\lambda t)$。\n- **函数定义**：$f(t,y)=-\\lambda y$。\n- **数值方法**：\n    1.  **显式（前向）Euler**：$y_{n+1} = y_n + h f(t_n,y_n)$。\n    2.  **隐式（后向）Euler**：$y_{n+1} = y_n + h f(t_{n+1},y_{n+1})$。\n    3.  **Heun 方法（显式梯形法）**：$y_{n+1} = y_n + \\dfrac{h}{2}\\left(f(t_n,y_n)+f(t_n+h,y_n+h f(t_n,y_n))\\right)$。\n- **时间离散化**：$h = T/N$，其中 $N$ 是步数。\n- **误差计算**：在最终时刻 $T$ 的全局误差 $E(h)=\\lvert y_N - y(T)\\rvert$。\n- **精度阶估计**：对于步数为 $N_0, 2N_0, 4N_0$ 的分辨率，观测阶是两个估计值的平均值。\n- **科学依据**：对于小的 $h$，$E(h) \\approx C h^p$，且误差计算必须使用给定的精确解。\n- **测试套件设置**：所有情况均使用 $y_0 = 1$。基础步数 $N_0 = \\operatorname{round}(T/h_0)$。\n- **参数集**：\n    -   情况 A：$\\lambda = 1$, $T = 1$, $h_0 = 0.2$。\n    -   情况 B：$\\lambda = 20$, $T = 1$, $h_0 = 0.1$。\n    -   情况 C：$\\lambda = 100$, $T = 1$, $h_0 = 0.015$。\n    -   情况 D：$\\lambda = 500$, $T = 0.1$, $h_0 = 0.05$。\n- **输出格式**：一个单行，包含一个由逗号分隔的 12 个浮点数结果列表，用方括号括起，四舍五入到 6 位小数。顺序指定为 (A_EE, A_IE, A_HM, B_EE, B_IE, B_HM, C_EE, C_IE, C_HM, D_EE, D_IE, D_HM)。\n\n#### **步骤 2：使用提取的已知信息进行验证**\n\n- **科学上合理**：该问题基于线性测试方程 $y' = -\\lambda y$，这是常微分方程数值分析中用于研究时间积分格式的稳定性和准确性的一个基本工具。所提供的方法（显式 Euler、隐式 Euler、Heun 方法）是数值积分器的标准、典型示例。该问题牢固地植根于既定的数值分析原理。\n- **适定的**：问题被精确地规定了。所有常数、方程、初值条件和步骤都已明确定义。对于每组参数，指令都能导出一个单一、唯一且有意义的数值结果（观测到的精度阶）。\n- **客观的**：问题以精确的数学和计算术语陈述，没有任何主观性、模糊性或基于观点的主张。\n\n该问题不存在任何无效性缺陷：\n1.  **科学/事实上的不健全**：不存在违反数学逻辑或科学原理的情况。\n2.  **无法形式化/不相关**：该问题是一个形式化的、可量化的任务，与建模中的时间离散化直接相关。\n3.  **不完整/矛盾的设置**：所有必要信息都已提供，且没有矛盾之处。\n4.  **不切实际/不可行**：参数的选择旨在探索不同的刚性区域，这在数值分析的背景下是现实的。计算是可行的。\n5.  **不适定/结构不良**：计算观测阶的程序定义明确，并能得出唯一结果。\n6.  **伪深刻/琐碎**：该问题要求正确实现数值方法，并理解如何评估其经验性能，这是一个非琐碎的任务，说明了稳定性和收敛性的重要概念。\n7.  **超出科学可验证性范围**：结果是可以通过计算验证的。\n\n#### **步骤 3：结论与行动**\n\n问题陈述是**有效的**。将提供一个解决方案。\n\n### **解决方案**\n\n该问题要求我们计算三种数值方法——显式 Euler、隐式 Euler 和 Heun 方法——在线性测试常微分方程 $y'(t) = -\\lambda y(t)$（其中 $y(0) = y_0$）上的观测精度阶。其精确解为 $y(t) = y_0 \\exp(-\\lambda t)$。\n\n对于一个给定的方法，一个时间步长 $h$ 后的数值解可以写成 $y_{n+1} = g(h\\lambda) y_n$，其中 $g(z)$ 是方法的放大因子，$z=h\\lambda$。我们针对 $f(t,y) = -\\lambda y$ 推导每种方法的 $g(z)$：\n\n1.  **显式 Euler**：\n    $y_{n+1} = y_n + h(-\\lambda y_n) = (1 - h\\lambda) y_n$。\n    放大因子为 $g_{EE}(z) = 1 - z$。\n\n2.  **隐式 Euler**：\n    $y_{n+1} = y_n + h(-\\lambda y_{n+1}) \\implies y_{n+1}(1+h\\lambda) = y_n \\implies y_{n+1} = \\frac{1}{1+h\\lambda} y_n$。\n    放大因子为 $g_{IE}(z) = \\frac{1}{1+z}$。\n\n3.  **Heun 方法**：\n    $y_{n+1} = y_n + \\frac{h}{2} \\left( (-\\lambda y_n) + (-\\lambda(y_n + h(-\\lambda y_n))) \\right)$\n    $y_{n+1} = y_n + \\frac{h}{2} \\left( -\\lambda y_n - \\lambda y_n + h\\lambda^2 y_n \\right)$\n    $y_{n+1} = y_n \\left( 1 - h\\lambda + \\frac{h^2\\lambda^2}{2} \\right)$。\n    放大因子为 $g_{HM}(z) = 1 - z + \\frac{z^2}{2}$。\n\n经过 $N$ 步到达最终时刻 $T=Nh$ 后，数值解为 $y_N = y_0 \\cdot [g(h\\lambda)]^N$。对于这个线性问题，这个闭式表达式比分步循环更高效、数值上更稳健。\n\n任务的核心是找到观测到的精度阶 $p$。对于一个 $p$ 阶方法，在固定的最终时刻 $T$，当步长 $h$ 足够小时，全局误差 $E(h)$ 的行为近似于 $E(h) \\approx C h^p$。给定来自两个不同步长 $h_1$ 和 $h_2$ 的误差，我们有：\n$$ \\frac{E(h_1)}{E(h_2)} \\approx \\frac{C h_1^p}{C h_2^p} = \\left(\\frac{h_1}{h_2}\\right)^p $$\n求解 $p$ 可得：\n$$ p \\approx \\frac{\\log(E(h_1)/E(h_2))}{\\log(h_1/h_2)} $$\n在我们的情况下，我们执行一系列的步长减半，因此 $h_1/h_2 = 2$。这可以简化为 $p \\approx \\log_2(E(h_1)/E(h_2))$。\n\n对于每个测试用例和方法，其步骤如下：\n1.  给定 $(\\lambda, T, h_0)$ 和 $y_0 = 1$，计算基础步数 $N_0 = \\operatorname{round}(T/h_0)$。\n2.  定义三种分辨率，步数分别为 $N_1 = N_0$，$N_2 = 2N_0$ 和 $N_3 = 4N_0$。\n3.  对于每种分辨率 $k \\in \\{1,2,3\\}$，计算步长 $h_k = T/N_k$ 和数值解 $y_{N_k}$。\n4.  计算每种分辨率下的全局误差：$E_k = |y_{N_k} - y(T)|$，其中 $y(T) = y_0 \\exp(-\\lambda T)$。\n5.  计算精度阶的两个估计值：\n    $p_1 = \\log_2(E_1/E_2)$\n    $p_2 = \\log_2(E_2/E_3)$\n6.  最终的观测阶是这两个估计值的平均值：$p_{obs} = (p_1 + p_2)/2$。\n\n此过程应用于测试用例和方法的所有十二种组合。参数集的设计旨在测试方法在非刚性到非常刚性区域的表现。对于刚性问题（大的 $\\lambda$），如果步长 $h$ 太大（具体来说，如果 $h\\lambda > 2$），像前向 Euler 和 Heun 这样的显式方法可能会变得不稳定。在这种不稳定情况下，误差会随着 $h$ 的减小而增大，从而导致观测到的精度阶为负。隐式 Euler 方法是 A-稳定的，对于任何 $h > 0$ 都保持稳定，能够正确处理刚性方程，尽管其精度特性可能偏离经典的非刚性理论。计算将捕捉到这些行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed order of accuracy for three numerical methods\n    on the linear test ODE y' = -lambda*y across four different parameter sets.\n    \"\"\"\n\n    def compute_numerical_solution(method_name, lam, y0, T, N):\n        \"\"\"\n        Calculates the numerical solution y(T) using the amplification factor.\n        \n        Args:\n            method_name (str): Identifier for the method ('EE', 'IE', 'HM').\n            lam (float): The lambda parameter of the ODE.\n            y0 (float): Initial condition y(0).\n            T (float): Final time.\n            N (int): Number of time steps.\n        \n        Returns:\n            float: The numerical solution at time T.\n        \"\"\"\n        h = T / N\n        z = h * lam\n        \n        if method_name == 'EE': # Explicit Euler\n            # Amplification factor: g(z) = 1 - z\n            # Solution: y_N = y_0 * (1 - h*lam)^N\n            amp_factor = 1.0 - z\n        elif method_name == 'IE': # Implicit Euler\n            # Amplification factor: g(z) = 1 / (1 + z)\n            # Solution: y_N = y_0 * (1 + h*lam)^(-N)\n            amp_factor = 1.0 / (1.0 + z)\n        elif method_name == 'HM': # Heun's Method\n            # Amplification factor: g(z) = 1 - z + z^2/2\n            # Solution: y_N = y_0 * (1 - h*lam + 0.5*(h*lam)^2)^N\n            amp_factor = 1.0 - z + 0.5 * z**2\n        else:\n            raise ValueError(\"Unknown method name\")\n        \n        # Using the power of the amplification factor can be unstable for large N\n        # with negative bases. We must handle complex numbers that arise from\n        # negative bases in the amplification factor for explicit methods.\n        # The result of y_N should be real.\n        if isinstance(amp_factor, complex) or amp_factor  0:\n            # y_N = y_0 * (g)^N. If g is negative, result is y_0 * |g|^N * (-1)^N\n            # We take the real part, which is y_0 * g^N\n            return y0 * (amp_factor**N).real\n        else:\n            return y0 * amp_factor**N\n\n    def calculate_observed_order(method_name, lam, y0, T, h0):\n        \"\"\"\n        Calculates the observed order of accuracy for a given method and parameters.\n        \n        Args:\n            method_name (str): Identifier for the method ('EE', 'IE', 'HM').\n            lam (float): The lambda parameter of the ODE.\n            y0 (float): Initial condition y(0).\n            T (float): Final time.\n            h0 (float): Base step size parameter.\n        \n        Returns:\n            float: The observed order of accuracy.\n        \"\"\"\n        N0 = int(round(T / h0))\n        Ns = [N0, 2 * N0, 4 * N0]\n        \n        y_exact = y0 * np.exp(-lam * T)\n        \n        errors = []\n        for N in Ns:\n            if N == 0:\n                # Avoid division by zero if T/h0 rounds to 0. Not expected for given test cases.\n                errors.append(np.inf)\n                continue\n            y_num = compute_numerical_solution(method_name, lam, y0, T, N)\n            error = np.abs(y_num - y_exact)\n            errors.append(error)\n            \n        E1, E2, E3 = errors\n\n        # Handle cases where error is zero to avoid division by zero or log(0)\n        if E1 == 0 or E2 == 0 or E3 == 0:\n            # If error becomes 0, this implies very fast convergence or machine precision limit.\n            # The order is effectively infinite, but the problem's formula would break down.\n            # For practical purposes, if E1/E2 is extremely small, log2 will be a large negative number.\n            # Or if E2/E3 is extremely large, log2 will be large.\n            # The problem context doesn't expect this, so we proceed.\n            # A robust implementation might return a sentinel like NaN.\n            if E2 == 0: p1 = np.inf if E1 > 0 else 0\n            else: p1 = np.log2(E1 / E2)\n            \n            if E3 == 0: p2 = np.inf if E2 > 0 else 0\n            else: p2 = np.log2(E2 / E3)\n        else:\n            p1 = np.log2(E1 / E2)\n            p2 = np.log2(E2 / E3)\n        \n        p_obs = (p1 + p2) / 2.0\n        return p_obs\n\n    y0 = 1.0 # Initial condition y(0)=1 for all cases.\n\n    # Test cases: (lambda, T, h0)\n    test_cases = [\n        (1.0, 1.0, 0.2),      # Case A: nonstiff\n        (20.0, 1.0, 0.1),     # Case B: moderately stiff\n        (100.0, 1.0, 0.015),  # Case C: stiff but stable\n        (500.0, 0.1, 0.05),   # Case D: very stiff, unstable explicit\n    ]\n    \n    method_names = ['EE', 'IE', 'HM']\n    \n    results = []\n    for lam, T, h0 in test_cases:\n        for method_name in method_names:\n            order = calculate_observed_order(method_name, lam, y0, T, h0)\n            results.append(round(order, 6))\n\n    # Format the final output string as per the requirements\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了纯粹的数值精度，一个稳健的环境模型还必须遵守基本的物理定律。诸如污染物浓度或生物量等物理量不能为负。本实践  将从抽象的分析转向这一实际问题，展示一个简单的显式格式如何产生非物理的负值。你将推导出演算过程中维持正值所需的条件，无论是通过限制时间步长还是设计一个“限制器”（limiter）——这是构建可靠输运模型的常用技术。",
            "id": "3859476",
            "problem": "一个单网格单元大气质量平衡模型被用于模拟一种化学反应性污染物的非负浓度 $y(t)$，该污染物的排放由星载遥感观测推断得出。其时间演变遵循质量守恒定律：变化率等于源项减去汇项。具体来说，假设\n$$\\frac{dy}{dt} = e(t) - \\lambda\\, y(t),$$\n其中 $e(t) \\ge 0$ 表示从遥感反演中得到的排放源项，$0  \\lambda$ 是一个常数，代表沉降和化学去除总和的一阶损失率。时间推进采用单步显式方法，在先前的时间层上计算右侧项，时间步长为 $\\Delta t_n  0$。已知在当前步，浓度为非负，$y_n \\ge 0$，且排放估计值满足 $e_n \\ge 0$。\n\n从守恒方程和导数的定义出发，推导出一个关于显式时间步长 $\\Delta t_n$（用 $\\lambda$ 表示）的严格限制条件，以保证更新过程中的正定性保持，即当 $y_n \\ge 0$ 和 $e_n \\ge 0$ 时，有 $y_{n+1} \\ge 0$。此外，对于一个通用的显式更新 $y_{n+1} = y_n + \\Delta t_n f(y_n)$，推导一个形式为 $y_{n+1}^{\\mathrm{lim}} = y_n + \\phi\\,\\Delta t_n\\,f(y_n)$ 的单行正定性保持限制器策略，该策略在 $y_n \\ge 0$ 时能确保 $y_{n+1}^{\\mathrm{lim}} \\ge 0$，而无需减小 $\\Delta t_n$。你必须证明该时间步长限制条件的严格性。\n\n最后，计算当 $\\lambda = 1.25 \\times 10^{-5}\\,\\mathrm{s}^{-1}$ 时，允许的最大时间步长 $\\Delta t_{\\max}$。请以秒为单位表示最终数值答案，并四舍五入到四位有效数字。",
            "solution": "所述问题具有科学依据、适定且客观。它提出了一个来自环境建模的标准质量平衡方程，并要求严格推导数值时间步进格式的正定性约束、构建正定性保持限制器，最后进行数值计算。所有提供的信息都是自洽且一致的。因此，该问题是有效的，我将开始解答。\n\n污染物浓度 $y(t)$ 的时间演变由以下线性一阶常微分方程给出：\n$$\n\\frac{dy}{dt} = e(t) - \\lambda y(t)\n$$\n约束条件为 $y(t) \\ge 0$、$e(t) \\ge 0$ 和 $\\lambda  0$。\n\n该数值格式是一种单步显式方法，它在先前的时间层 $t_n$ 上计算右侧项 $f(t, y) = e(t) - \\lambda y(t)$。这对应于前向或显式欧拉法。离散更新法则为：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t_n} = e_n - \\lambda y_n\n$$\n其中 $y_n \\equiv y(t_n)$，$e_n \\equiv e(t_n)$，且 $\\Delta t_n = t_{n+1} - t_n  0$。对 $y_{n+1}$ 进行移项整理，我们得到：\n$$\ny_{n+1} = y_n + \\Delta t_n (e_n - \\lambda y_n)\n$$\n我们可以合并包含 $y_n$ 的项：\n$$\ny_{n+1} = y_n(1 - \\lambda \\Delta t_n) + e_n \\Delta t_n\n$$\n我们已知在当前步，浓度 $y_n \\ge 0$ 且排放项 $e_n \\ge 0$。时间步长 $\\Delta t_n$ 也为正。因此，项 $e_n \\Delta t_n$ 总是非负的。\n\n**第一部分：时间步长限制的推导**\n\n为保证正定性保持，我们必须确保对于任何有效输入（$y_n \\ge 0, e_n \\ge 0$），都有 $y_{n+1} \\ge 0$。由于 $e_n \\Delta t_n \\ge 0$，只要项 $y_n(1 - \\lambda \\Delta t_n)$ 也非负，那么 $y_{n+1} \\ge 0$ 的条件就能得到保证。因为我们必须对任何 $y_n \\ge 0$ 都保证这一点，所以 $y_n$ 的系数必须为非负。\n$$\n1 - \\lambda \\Delta t_n \\ge 0\n$$\n解出 $\\Delta t_n$：\n$$\n1 \\ge \\lambda \\Delta t_n \\implies \\Delta t_n \\le \\frac{1}{\\lambda}\n$$\n这是无条件保证 $y_{n+1} \\ge 0$ 所需的时间步长限制。\n\n为证明此限制是严格的，我们必须表明，如果该条件被违反，则至少存在一组有效输入使得 $y_{n+1}  0$。我们假设 $\\Delta t_n > 1/\\lambda$。可以写作 $\\Delta t_n = (1+\\epsilon)/\\lambda$，其中 $\\epsilon  0$ 是某个小的正数。将此代入更新方程：\n$$\ny_{n+1} = y_n\\left(1 - \\lambda \\frac{1+\\epsilon}{\\lambda}\\right) + e_n \\Delta t_n = y_n(1 - (1+\\epsilon)) + e_n \\Delta t_n = - \\epsilon y_n + e_n \\Delta t_n\n$$\n现在，考虑一个物理上可能的情景，即没有排放（$e_n = 0$）且初始浓度非零（$y_n  0$）。在这种情况下，$y_{n+1}$ 的方程简化为：\n$$\ny_{n+1} = - \\epsilon y_n\n$$\n由于 $\\epsilon  0$ 且 $y_n  0$，显然 $y_{n+1}  0$。这违反了浓度非负的物理要求。因此，条件 $\\Delta t_n \\le 1/\\lambda$ 不仅是充分的，而且是必要的，以保证在所有可能的有效条件下都具有正定性，从而证明了其严格性。\n\n**第二部分：正定性保持限制器策略的推导**\n\n我们需要为一个通用的显式更新 $y_{n+1} = y_n + \\Delta t_n f(y_n)$ 推导一个限制器，当 $y_n \\ge 0$ 时，该限制器能强制 $y_{n+1}^{\\mathrm{lim}} \\ge 0$。该限制器必须具有形式 $y_{n+1}^{\\mathrm{lim}} = y_n + \\phi\\,\\Delta t_n\\,f(y_n)$。\n\n目标是找到一个缩放因子 $\\phi$，它能修改更新步长 $\\Delta y_n = \\Delta t_n f(y_n)$ 以防止 $y_{n+1}$ 变为负数。我们要求 $y_{n+1}^{\\mathrm{lim}} \\ge 0$，这意味着：\n$$\ny_n + \\phi \\Delta t_n f(y_n) \\ge 0\n$$\n我们根据趋势项 $f(y_n)$ 的符号分两种情况进行分析：\n\n情况 1：$f(y_n) \\ge 0$。\n浓度是非递减的。由于 $y_n \\ge 0$ 且 $\\Delta t_n  0$，未经限制的更新 $y_{n+1} = y_n + \\Delta t_n f(y_n)$ 将总是大于或等于 $y_n$，因此保持非负。不需要进行限制。为了保持原始格式的精度，我们不应改变更新。这可以通过设置 $\\phi = 1$ 来实现。\n\n情况 2：$f(y_n)  0$。\n浓度是递减的，如果时间步长过大，$y_{n+1}$ 可能会变为负数。我们必须强制 $y_n + \\phi \\Delta t_n f(y_n) \\ge 0$。对 $\\phi$ 进行移项整理：\n$$\n\\phi \\Delta t_n f(y_n) \\ge -y_n\n$$\n由于 $\\Delta t_n  0$ 且 $f(y_n)  0$，项 $\\Delta t_n f(y_n)$ 是负的。除以这个负数会反转不等号的方向：\n$$\n\\phi \\le \\frac{-y_n}{\\Delta t_n f(y_n)}\n$$\n我们定义比率 $r = \\frac{-y_n}{\\Delta t_n f(y_n)}$。注意，由于 $y_n \\ge 0$ 且分母为负，所以 $r \\ge 0$。保证正定性的条件是 $\\phi \\le r$。为了尽可能接近原始的、未限制的格式（其中 $\\phi = 1$），我们应该选择满足此约束的 $\\phi$ 的最大可能值。\n\n如果 $r \\ge 1$，这意味着 $\\frac{-y_n}{\\Delta t_n f(y_n)} \\ge 1$，等价于 $-y_n \\ge \\Delta t_n f(y_n)$ 或 $y_n + \\Delta t_n f(y_n) \\ge 0$。未限制的步骤已经保持了正定性。在这种情况下，我们可以选择 $\\phi = 1$，这满足 $\\phi \\le r$。\n\n如果 $0 \\le r  1$，未限制的步骤将导致负浓度。为了在对更新做尽可能小的修改的同时保证正定性，我们必须选择 $\\phi$ 的最大允许值，即 $\\phi = r$。这个选择导致 $y_{n+1}^{\\mathrm{lim}} = y_n + r (\\Delta t_n f(y_n)) = y_n + \\frac{-y_n}{\\Delta t_n f(y_n)} (\\Delta t_n f(y_n)) = y_n - y_n = 0$。\n\n对于 $f(y_n)  0$ 的情况，结合这些子情况，既能尽可能保持精度又保证正定性的最佳选择是 $\\phi = \\min(1, r)$。\n\n因此，完整的“单行”正定性保持限制器策略是 $y_{n+1}^{\\mathrm{lim}} = y_n + \\phi\\,\\Delta t_n\\,f(y_n)$，其中因子 $\\phi$ 定义如下：\n$$\n\\phi = \\begin{cases} 1   \\text{if } f(y_n) \\ge 0 \\\\ \\min\\left(1, \\frac{-y_n}{\\Delta t_n f(y_n)}\\right)   \\text{if } f(y_n)  0 \\end{cases}\n$$\n该策略确保对于任何时间步长 $\\Delta t_n  0$ 都有 $y_{n+1}^{\\mathrm{lim}} \\ge 0$，而无需减小时间步长。\n\n**第三部分：数值计算**\n\n最后，我们被要求计算在没有限制器的情况下保证正定性的最大允许时间步长 $\\Delta t_{\\max}$。根据第一部分的推导，这由严格界限给出：\n$$\n\\Delta t_{\\max} = \\frac{1}{\\lambda}\n$$\n给定损失率常数 $\\lambda = 1.25 \\times 10^{-5}\\,\\mathrm{s}^{-1}$：\n$$\n\\Delta t_{\\max} = \\frac{1}{1.25 \\times 10^{-5}\\,\\mathrm{s}^{-1}} = \\frac{1}{1.25} \\times 10^5\\,\\mathrm{s}\n$$\n由于 $1.25 = 5/4$，我们有 $1/1.25 = 4/5 = 0.8$。\n$$\n\\Delta t_{\\max} = 0.8 \\times 10^5\\,\\mathrm{s} = 80000\\,\\mathrm{s}\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\Delta t_{\\max} = 8.000 \\times 10^4\\,\\mathrm{s}\n$$",
            "answer": "$$\\boxed{8.000 \\times 10^4}$$"
        },
        {
            "introduction": "第一个练习强调了隐式方法在处理环境科学中常见的刚性系统时所具有的卓越稳定性。但这种稳定性的代价是：每个时间步都需要求解一个庞大且计算密集型的非线性方程组。最后一个练习  将揭开这一过程的神秘面纱，引导你推导牛顿-克雷洛夫（Newton-Krylov）方法。这是一种先进的“无矩阵”（matrix-free）技术，它使得求解由遥感数据驱动的大尺度、高分辨率模型中的这类方程组成为可能。",
            "id": "3859502",
            "problem": "考虑一个遥感污染物浓度场的半离散环境输运-反应模型，其中状态向量 $c(t) \\in \\mathbb{R}^{N}$ 根据空间离散化的常微分方程演化\n$$\nM \\,\\frac{d c(t)}{dt} \\;=\\; A\\,c(t) \\;+\\; D\\,c(t) \\;-\\; S\\!\\left(c(t)\\right) \\;+\\; f(t),\n$$\n其具有以下基于物理的结构：$M \\in \\mathbb{R}^{N \\times N}$ 是通过保守有限体积离散化得到的对称正定质量矩阵；$A \\in \\mathbb{R}^{N \\times N}$ 是源于迎风数值通量的线性平流算子；$D \\in \\mathbb{R}^{N \\times N}$ 是对称半正定扩散算子；$S:\\mathbb{R}^{N} \\to \\mathbb{R}^{N}$ 是一个逐元素的非线性反应项，用于模拟饱和的生物地球化学吸收，其分量定义为 $S_{i}(c) = k_{i}\\,c_{i}^{2}/\\left(1+\\alpha_{i}\\,c_{i}\\right)$，其中 $k_{i}  0$ 且 $\\alpha_{i}  0$；而 $f(t) \\in \\mathbb{R}^{N}$ 代表外源强迫（包括从遥感反演推断的同化增量），在时间步内进行隐式处理。\n\n设在时间层 $t^{n+1} = t^{n} + \\Delta t$ 的隐式欧拉时间离散化由下式给出\n$$\nM\\,c^{n+1} \\;=\\; M\\,c^{n} \\;+\\; \\Delta t\\left[A\\,c^{n+1} \\;+\\; D\\,c^{n+1} \\;-\\; S\\!\\left(c^{n+1}\\right) \\;+\\; f^{n+1}\\right],\n$$\n并在一个通用的试验向量 $y \\in \\mathbb{R}^{N}$ 上定义非线性残差 $F:\\mathbb{R}^{N} \\to \\mathbb{R}^{N}$ 为\n$$\nF(y) \\;=\\; M\\,y \\;-\\; M\\,c^{n} \\;-\\; \\Delta t\\left[A\\,y \\;+\\; D\\,y \\;-\\; S(y) \\;+\\; f^{n+1}\\right].\n$$\n\n从求解 $F(y) = 0$ 的 Newton 方法的基本定义和 $F$ 的方向（Gâteaux）导数出发，推导用于将 $c^{n}$推进到 $c^{n+1}$ 的 Newton–Krylov 迭代，其中内部线性求解通过广义最小残差方法（GMRES）在 Krylov 子空间中执行。明确地用模型算子和 $S'(y)$ 表示雅可比矩阵 $J(y)$，然后推导一个无需显式构造 $J(y)$ 的雅可比-向量积的无矩阵表达式。在你的推导中，讨论雅可比近似在大型环境模型中的作用，包括对计算成本、内存、由反应项引起的刚性以及在遥感驱动的建模工作流中遇到的多物理场系统典型的算子耦合的考虑。\n\n作为最终输出，提供在 GMRES 内部使用的无矩阵雅可比-向量积的封闭形式解析表达式，该表达式仅用残差函数 $F$、当前 Newton 迭代 $y_{k}$、任意向量 $v \\in \\mathbb{R}^{N}$ 和一个非零标量探测参数 $h \\in \\mathbb{R}$ 来书写。你的最终答案必须是一个解析表达式，并且不得包含单位。",
            "solution": "该问题要求推导用于求解由环境输运-反应模型的隐式时间离散化产生的非线性系统的 Newton-Krylov 迭代。核心任务是确定系统雅可比矩阵，然后推导在像 GMRES 这样的 Krylov 求解器中使用的雅可比-向量积的无矩阵表达式。\n\n首先，我们重申在每个时间步需要解决的问题。我们寻求由隐式欧拉离散化得到的非线性代数系统的解 $c^{n+1}$。设 $y = c^{n+1}$ 为时间层 $n+1$ 的未知解向量。该方程组为 $F(y) = 0$，其中残差函数 $F:\\mathbb{R}^{N} \\to \\mathbb{R}^{N}$ 定义为：\n$$\nF(y) \\;=\\; M\\,y \\;-\\; M\\,c^{n} \\;-\\; \\Delta t\\left[A\\,y \\;+\\; D\\,y \\;-\\; S(y) \\;+\\; f^{n+1}\\right]\n$$\n这是一个关于向量 $y$ 的求根问题。Newton 方法是解决此类问题的标准迭代技术。从一个初始猜测 $y_0$（例如，$y_0 = c^n$）开始，Newton 方法生成一个旨在收敛到真解的近似序列 $\\{y_k\\}$。从迭代 $y_k$ 到下一个迭代 $y_{k+1}$ 的更新由下式给出\n$$\ny_{k+1} = y_k + \\delta y_k\n$$\n其中更新向量 $\\delta y_k$ 是以下线性系统的解：\n$$\nJ(y_k) \\, \\delta y_k = -F(y_k)\n$$\n这里，$J(y_k)$ 是残差函数 $F$ 在当前迭代 $y_k$ 处求值的雅可比矩阵。\n\n下一步是推导雅可比矩阵 $J(y) = \\frac{dF}{dy}$ 的解析表达式。我们对 $F(y)$ 的表达式关于向量 $y$ 求导。项 $M c^n$ 和 $\\Delta t f^{n+1}$ 相对于 $y$ 是常数，因此它们的导数为零。涉及 $M, A$ 和 $D$ 的项是 $y$ 的线性项。\n$$\n\\frac{d}{dy} \\left( M y - \\Delta t A y - \\Delta t D y \\right) = M - \\Delta t A - \\Delta t D\n$$\n反应项 $S(y)$ 是非线性的。它关于 $y$ 的导数是 $S$ 的雅可比矩阵，记为 $S'(y)$。因此，$F(y)$ 的完整雅可比矩阵是：\n$$\nJ(y) = M - \\Delta t A - \\Delta t D + \\Delta t S'(y)\n$$\n问题陈述反应项 $S(y)$ 是逐元素定义的，$S_i(y) = S_i(y_i) = k_i y_i^2 / (1+\\alpha_i y_i)$。因此，其雅可比矩阵 $S'(y)$ 是一个对角矩阵，其中第 $i$ 个对角元素是 $S_i$ 相对于 $y_i$ 的导数：\n$$\n[S'(y)]_{ii} = \\frac{d S_i}{d y_i} = \\frac{d}{d y_i} \\left( \\frac{k_i y_i^2}{1+\\alpha_i y_i} \\right)\n$$\n使用除法法则求导，我们得到：\n$$\n\\frac{d S_i}{d y_i} = k_i \\frac{(2 y_i)(1+\\alpha_i y_i) - (y_i^2)(\\alpha_i)}{(1+\\alpha_i y_i)^2} = k_i \\frac{2 y_i + 2\\alpha_i y_i^2 - \\alpha_i y_i^2}{(1+\\alpha_i y_i)^2} = k_i \\frac{y_i(2 + \\alpha_i y_i)}{(1+\\alpha_i y_i)^2}\n$$\n所以，$S'(y)$ 是一个对角矩阵，其对角线上的元素如上所示。\n\nNewton-Krylov 方法将用于非线性问题的外部 Newton 迭代与用于线性系统的内部 Krylov 子空间迭代相结合。具体来说，在每个 Newton 步骤 $k$，线性系统 $J(y_k) \\delta y_k = -F(y_k)$ 使用像 GMRES（广义最小残差方法）这样的方法求解，该方法适用于大型、稀疏且通常非对称的雅可比矩阵 $J(y_k)$。\n\nKrylov 方法的一个关键特点是它们不需要矩阵 $J(y_k)$ 的显式信息。相反，它们只需要一个程序来计算该矩阵与给定向量 $v$ 的乘积。这个“矩阵-向量积”是 GMRES 算法中的基本操作。避免构造 $J(y_k)$ 的主要动机是计算效率。\n\n矩阵-向量积 $J(y_k)v$ 可以使用基于 Gâteaux（或方向）导数定义的有限差分公式来近似。$F$ 在点 $y_k$ 沿向量 $v$ 方向的 Gâteaux 导数由以下极限定义：\n$$\nDF(y_k; v) = \\lim_{h \\to 0} \\frac{F(y_k + h v) - F(y_k)}{h}\n$$\n其中 $h$ 是一个标量参数。向量函数的微积分基本定理指出，这个方向导数完全等于雅可比矩阵作用于方向向量：\n$$\nDF(y_k; v) = J(y_k)v\n$$\n在实际的“无矩阵”实现中，我们通过为标量探测参数 $h$ 选择一个很小但非零的值来近似这个极限。这产生了一阶前向差分近似的雅可比-向量积：\n$$\nJ(y_k)v \\approx \\frac{F(y_k + h v) - F(y_k)}{h}\n$$\n这个表达式是无矩阵 Newton-Krylov 方法的基石。它允许仅使用两次残差函数 $F$ 的求值（一次是已知的 $F(y_k)$，另一次是 $F(y_k + hv)$）来计算所需的乘积，从而完全绕过了雅可比矩阵 $J(y_k)$ 的构造和存储。$h$ 的选择是一个微妙的平衡：它必须足够小以确保近似的准确性，但又必须足够大以避免由于有限精度算术导致的灾难性抵消（相减抵消误差）。\n\n在大型环境建模中，使用此类雅可比近似和无矩阵方法至关重要，原因有几个：\n\n1.  **计算成本和内存**：对于在精细网格上离散化的环境模型，状态向量的维度 $N$ 可能非常大（$10^6$ 到 $10^9$ 或更多）。构造和存储 $N \\times N$ 的雅可比矩阵 $J(y_k)$ 的成本将高得令人望而却步，如果矩阵是稠密的，则需要 $O(N^2)$ 的内存。即使对于稀疏矩阵，内存占用和在每个 Newton 步骤 $k$ 重新组装矩阵（因为 $S'(y_k)$ 会改变）的成本也很可观。此外，使用直接求解器求解线性系统涉及矩阵分解（例如，LU 分解），这通常会遭受“填充”（在因子中引入非零元素）的影响，并且计算复杂度很高。无矩阵方法将内存需求减少到为 Krylov 基存储几个大小为 $N$ 的向量，并且每次 GMRES 迭代的计算成本主要由单个雅可比-向量积决定，其成本大约相当于模型右端项的一次求值。\n\n2.  **反应项带来的刚性**：非线性反应项 $S(c)$ 通常引入比输运时间尺度（平流和扩散）快得多的化学时间尺度。这种差异使得常微分方程组变得刚性。对于刚性系统，显式时间步进格式是不稳定的，除非使用不切实际的小时间步 $\\Delta t$。隐式方法，如这里使用的隐式欧拉格式，被用来克服这种稳定性限制，允许根据精度考虑来选择 $\\Delta t$。然而，这需要在每一步求解一个大型非线性系统。对于刚性问题，Newton 方法的收敛性对雅可比矩阵的准确性高度敏感。无矩阵方法通过近似精确雅可比矩阵的作用，向 Krylov 求解器提供关于刚性分量的必要信息，即使在较大的时间步长下也能实现 Newton 迭代的稳健收敛。\n\n3.  **多物理场系统中的算子耦合**：环境模型通常是多物理场的，将流体动力学与生物地球化学、热力学和其他过程耦合在一起。状态向量 $c(t)$ 可以代表多种相互作用物质的浓度、温度、压力等。这些物理过程是耦合的，意味着一个变量的控制方程依赖于其他变量。这种耦合在完整的系统雅可比矩阵中表现为非对角块。制定和编码这些复杂的、耦合的雅可比块是一项困难且容易出错的任务。无矩阵方法在软件工程方面提供了显著的优势：只要能编写一个函数来评估残差 $F(y)$——它封装了所有的物理过程及其耦合——就可以通过有限差分公式自动获得雅可比-向量积。这简化了代码，使其更加模块化，并在修改或扩展模型物理时大大减少了实现负担。通过强迫项 $f(t)$ 同化遥感数据使系统进一步复杂化，而无矩阵方法可以无缝地处理这些增加的内容。\n\n所要求的最终表达式是无矩阵雅可比-向量积的解析形式，即上面推导出的有限差分近似。",
            "answer": "$$\n\\boxed{\\frac{F\\left(y_{k} + h v\\right) - F(y_{k})}{h}}\n$$"
        }
    ]
}