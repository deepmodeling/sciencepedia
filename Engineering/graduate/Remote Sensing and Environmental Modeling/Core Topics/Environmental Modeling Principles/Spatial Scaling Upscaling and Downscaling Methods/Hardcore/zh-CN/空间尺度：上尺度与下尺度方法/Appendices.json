{
    "hands_on_practices": [
        {
            "introduction": "空间升尺度（upscaling）的一个核心挑战是，当数据从精细网格聚合到更粗糙且常常未对齐的多边形区域时，如何保持总量（如总生物量或水量）的守恒。本练习  提供了一个动手编程实践，旨在比较一种简单但有缺陷的基于质心的分配方法与一种物理上严谨的精确叠加方法。通过实施这两种方法并量化由此产生的误差，您将对为何守恒重采样对于精确的环境建模至关重要获得实践性的理解。",
            "id": "3851372",
            "problem": "考虑遥感和环境建模中常见的空间尺度转换情景，其中物理场在精细的栅格网格上表示，并聚合到粗糙、非对齐的多边形上。设矩形空间域为 $\\Omega = [0,L_x] \\times [0,L_y]$（单位：米），精细栅格是一个由 $N_x \\times N_y$ 个轴对齐的矩形单元组成的均匀网格，这些单元划分了 $\\Omega$。假设存在一个确定性的、连续的面密度场 $\\rho(x,y)$，单位为千克/平方米，其定义为 $\\rho(x,y) = \\alpha + \\beta x + \\gamma y$，其中 $\\alpha$ 的单位为千克/平方米，$\\beta$ 和 $\\gamma$ 的单位为千克/立方米，因此 $\\beta x$ 和 $\\gamma y$ 的单位为千克/平方米。\n\n支撑体变换的守恒原理指出，在任何可测子集 $S \\subseteq \\Omega$ 上的质量为\n$$\nM(S) = \\iint_S \\rho(x,y)\\, \\mathrm{d}x\\, \\mathrm{d}y.\n$$\n粗糙支撑体以轴对齐的矩形多边形列表 $P_1,\\dots,P_m$ 的形式给出，每个多边形由其 $x$ 区间 $[a_x^{(p)},b_x^{(p)}]$ 和 $y$ 区间 $[a_y^{(p)},b_y^{(p)}]$（单位：米）指定。定义以下两种升尺度方法：\n\n1. 质心分配法：对于每个精细单元 $C$，计算其质心 $(x_c,y_c)$，并将整个单元的质量分配给其内部包含 $(x_c,y_c)$ 的第一个多边形 $P_p$（如果没有多边形包含该质心，则该单元对所有多边形的贡献为零）。将多边形 $P_p$ 的聚合质量记为 $A_p^{\\mathrm{cen}}$。\n\n2. 校正精确叠加法：对于每个精细单元 $C$ 和多边形 $P_p$，计算其矩形交集 $I = C \\cap P_p$。如果 $I$ 的面积为正，则将精确积分 $\\iint_I \\rho(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$ 加到该多边形的总量中。将多边形 $P_p$ 的聚合质量记为 $A_p^{\\mathrm{exact}}$。\n\n使用守恒原理定义多边形真值 $T_p = M(P_p)$。使用再分配误差大小和聚合非守恒度量来量化泄漏：\n- 再分配误差大小：\n$$\nE(A) = \\sum_{p=1}^m \\left| A_p - T_p \\right|,\n$$\n其中 $A_p$ 为 $A_p^{\\mathrm{cen}}$ 或 $A_p^{\\mathrm{exact}}$。\n- 跨多边形的聚合非守恒：\n$$\nC(A) = \\sum_{p=1}^m A_p - \\sum_{p=1}^m T_p.\n$$\n所有质量和泄漏度量必须以千克为单位表示。\n\n您的任务是实现一个程序，对于下方的每个测试用例，构建精细网格，通过在每个单元上积分给定的 $\\rho(x,y)$ 来计算每个单元的精确质量，使用两种方法升尺度到多边形，从第一性原理计算每个多边形的 $T_p$，并报告两种方法的 $E(A)$ 和 $C(A)$。\n\n测试套件（四个案例）：\n- 案例1（未对齐划分）：\n    - $L_x = 1000$ 米, $L_y = 1000$ 米; $N_x = 10$, $N_y = 10$。\n    - $\\alpha = 2$ 千克/平方米, $\\beta = 0.001$ 千克/立方米, $\\gamma = -0.0005$ 千克/立方米。\n    - 多边形: $P_1 = [0,430] \\times [0,1000]$, $P_2 = [430,1000] \\times [0,1000]$。\n- 案例2（对齐划分）：\n    - $L_x = 1000$ 米, $L_y = 1000$ 米; $N_x = 10$, $N_y = 10$。\n    - $\\alpha = 2$ 千克/平方米, $\\beta = 0.001$ 千克/立方米, $\\gamma = -0.0005$ 千克/立方米。\n    - 多边形: $P_1 = [0,500] \\times [0,1000]$, $P_2 = [500,1000] \\times [0,1000]$。\n- 案例3（重叠）：\n    - $L_x = 1000$ 米, $L_y = 1000$ 米; $N_x = 10$, $N_y = 10$。\n    - $\\alpha = 2$ 千克/平方米, $\\beta = 0.001$ 千克/立方米, $\\gamma = -0.0005$ 千克/立方米。\n    - 多边形: $P_1 = [200,700] \\times [200,700]$, $P_2 = [500,900] \\times [100,600]$。\n- 案例4（间隙）：\n    - $L_x = 1000$ 米, $L_y = 1000$ 米; $N_x = 10$, $N_y = 10$。\n    - $\\alpha = 2$ 千克/平方米, $\\beta = 0.001$ 千克/立方米, $\\gamma = -0.0005$ 千克/立方米。\n    - 多边形: $P_1 = [0,400] \\times [0,1000]$, $P_2 = [600,1000] \\times [0,1000]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，输出一个四元素列表 $[E(A^{\\mathrm{cen}}),C(A^{\\mathrm{cen}}),E(A^{\\mathrm{exact}}),C(A^{\\mathrm{exact}})]$，所有单位均为千克，并以列表的列表形式呈现。例如，最终输出格式必须为 $[[e_1,c_1,e'_1,c'_1],[e_2,c_2,e'_2,c'_2],[e_3,c_3,e'_3,c'_3],[e_4,c_4,e'_4,c'_4]]$，其中每个 $e_i$、$c_i$、$e'_i$、$c'_i$ 是以千克为单位的实数。",
            "solution": "用户提供的问题被评估为有效。它在科学上基于积分学和质量守恒原理，问题设定良好，数据完整一致，表述客观。该任务要求实现并比较两种空间升尺度方法，这是遥感和环境建模中的一个常见问题。我们将提供完整的解决方案。\n\n问题的核心是通过对给定的面密度场 $\\rho(x,y)$ 进行积分，来计算不同矩形域上的质量。密度场是空间坐标的线性函数：\n$$\n\\rho(x,y) = \\alpha + \\beta x + \\gamma y\n$$\n其中 $\\alpha$ 的单位是 kg/m²，$\\beta, \\gamma$ 的单位是 kg/m³，以确保量纲一致性。\n\n一个关键步骤是推导 $\\rho(x,y)$ 在任意轴对齐矩形区域 $R = [x_1, x_2] \\times [y_1, y_2]$ 上的积分的通用公式。质量 $M(R)$ 由以下公式给出：\n$$\nM(R) = \\iint_R \\rho(x,y) \\, \\mathrm{d}x\\mathrm{d}y = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} (\\alpha + \\beta x + \\gamma y) \\, \\mathrm{d}x\\mathrm{d}y\n$$\n首先对 $x$ 进行积分：\n$$\n\\int_{x_1}^{x_2} (\\alpha + \\beta x + \\gamma y) \\, \\mathrm{d}x = \\left[ \\alpha x + \\frac{\\beta}{2} x^2 + \\gamma y x \\right]_{x_1}^{x_2} = \\alpha(x_2 - x_1) + \\frac{\\beta}{2}(x_2^2 - x_1^2) + \\gamma y(x_2 - x_1)\n$$\n现在，对结果关于 $y$ 进行积分：\n$$\n\\int_{y_1}^{y_2} \\left( \\alpha(x_2 - x_1) + \\frac{\\beta}{2}(x_2^2 - x_1^2) + \\gamma y(x_2 - x_1) \\right) \\, \\mathrm{d}y = \\left[ \\alpha(x_2 - x_1)y + \\frac{\\beta}{2}(x_2^2 - x_1^2)y + \\frac{\\gamma}{2}(x_2 - x_1)y^2 \\right]_{y_1}^{y_2}\n$$\n$$\nM(R) = \\alpha(x_2 - x_1)(y_2 - y_1) + \\frac{\\beta}{2}(x_2^2 - x_1^2)(y_2 - y_1) + \\frac{\\gamma}{2}(x_2 - x_1)(y_2^2 - y_1^2)\n$$\n这个表达式可以通过引入矩形的质心 $(\\bar{x}, \\bar{y}) = \\left(\\frac{x_1+x_2}{2}, \\frac{y_1+y_2}{2}\\right)$ 和其面积 $A_R = (x_2 - x_1)(y_2 - y_1)$ 来简化。使用恒等式 $x_2^2 - x_1^2 = (x_2 - x_1)(x_2 + x_1) = (x_2 - x_1)(2\\bar{x})$ 和 $y_2^2 - y_1^2 = (y_2 - y_1)(2\\bar{y})$，表达式变为：\n$$\nM(R) = \\alpha A_R + \\frac{\\beta}{2}(2\\bar{x}(x_2-x_1))(y_2 - y_1) + \\frac{\\gamma}{2}(x_2 - x_1)(2\\bar{y}(y_2-y_1))\n$$\n$$\nM(R) = \\alpha A_R + \\beta \\bar{x} A_R + \\gamma \\bar{y} A_R = (\\alpha + \\beta \\bar{x} + \\gamma \\bar{y}) A_R = \\rho(\\bar{x}, \\bar{y}) A_R\n$$\n这是一个值得注意的结果：对于线性密度场，其在矩形上的精确积分等于在该矩性质心处的密度值乘以其面积。这简化了所有质量计算。\n\n对于每个测试用例，解决方案按以下步骤进行：\n1.  **网格和参数定义**：将域 $\\Omega = [0, L_x] \\times [0, L_y]$ 划分为一个 $N_x \\times N_y$ 的精细单元网格。单元尺寸为 $\\Delta x_{cell} = L_x/N_x$ 和 $\\Delta y_{cell} = L_y/N_y$。定义参数 $\\alpha, \\beta, \\gamma$ 和粗糙多边形列表 $\\{P_p\\}$。\n\n2.  **多边形真实质量计算 ($T_p$)**：使用推导出的积分公式直接计算每个多边形 $P_p = [a_x^{(p)},b_x^{(p)}] \\times [a_y^{(p)},b_y^{(p)}]$ 的真实质量：\n    $$\n    T_p = M(P_p) = \\rho(\\bar{x}_p, \\bar{y}_p) \\cdot \\text{Area}(P_p)\n    $$\n    其中 $(\\bar{x}_p, \\bar{y}_p)$ 是多边形 $P_p$ 的质心。\n\n3.  **质心分配升尺度 ($A_p^{\\mathrm{cen}}$)**：\n    a. 首先计算每个精细网格单元 $C_{ij}$ 的质量 $M(C_{ij})$。\n    b. 确定每个单元的质心 $(x_c, y_c)$。\n    c. 对于每个单元，搜索多边形列表 $\\{P_p\\}$。将整个质量 $M(C_{ij})$ 加到其内部包含该单元质心的*第一个*多边形 $P_p$ 的总质量 $A_p^{\\mathrm{cen}}$ 中。如果没有多边形包含该质心，该单元的质量在聚合中实际上丢失，导致非守恒。\n\n4.  **精确叠加升尺度 ($A_p^{\\mathrm{exact}}$)**：\n    a. 为每个多边形 $P_p$ 初始化一个累积质量 $A_p^{\\mathrm{exact}}$ 为零。\n    b. 对于精细单元 $C$ 和多边形 $P_p$ 的每个组合，计算它们的几何交集 $I = C \\cap P_p$。这个交集也是一个轴对齐的矩形。\n    c. 如果交集 $I$ 的面积为正，则使用积分公式计算其质量 $M(I)$ 并加到 $A_p^{\\mathrm{exact}}$ 中。\n    d. 该方法在构造上是守恒的。由于精细单元集合 $\\{C\\}$ 构成了域 $\\Omega$ 的一个划分，与多边形 $P_p$ 的交集上的积分之和必须等于在整个多边形上的积分：\n       $$\n       A_p^{\\mathrm{exact}} = \\sum_C M(C \\cap P_p) = \\sum_C \\iint_{C \\cap P_p} \\rho \\, dA = \\iint_{\\bigcup_C (C \\cap P_p)} \\rho \\, dA = \\iint_{P_p} \\rho \\, dA = T_p\n       $$\n       因此，我们预测对于精确叠加法，$A_p^{\\mathrm{exact}} = T_p$ 对所有 $p$ 成立。因此，再分配误差 $E(A^{\\mathrm{exact}})$ 和聚合非守恒 $C(A^{\\mathrm{exact}})$ 都必须为零，不计可忽略的浮点计算误差。这可作为实现正确性的有力内部检查。\n\n5.  **误差度量计算**：最后，为两种升尺度方法计算两个误差度量：\n    - 再分配误差大小：$E(A) = \\sum_{p=1}^m | A_p - T_p |$\n    - 聚合非守恒：$C(A) = \\sum_{p=1}^m A_p - \\sum_{p=1}^m T_p$\n\n所提供的测试用例探讨了多边形相对于精细网格的不同空间排列（未对齐、对齐、重叠和存在间隙），这系统地揭示了每种升尺度方法的优点和缺点。当多边形边界与单元边界不对齐，或存在间隙和重叠时，预计质心法会显示出显著误差。而精确叠加法预计在所有情况下都是完全准确的，因为它被设计为该聚合问题的基准真值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spatial scaling problem for a suite of test cases.\n    \"\"\"\n    \n    # Test suite definition\n    test_cases = [\n        {\n            \"L_x\": 1000, \"L_y\": 1000, \"N_x\": 10, \"N_y\": 10,\n            \"alpha\": 2, \"beta\": 0.001, \"gamma\": -0.0005,\n            \"polygons\": [\n                (0, 430, 0, 1000),  # P1 = [0,430] x [0,1000]\n                (430, 1000, 0, 1000) # P2 = [430,1000] x [0,1000]\n            ]\n        },\n        {\n            \"L_x\": 1000, \"L_y\": 1000, \"N_x\": 10, \"N_y\": 10,\n            \"alpha\": 2, \"beta\": 0.001, \"gamma\": -0.0005,\n            \"polygons\": [\n                (0, 500, 0, 1000),   # P1 = [0,500] x [0,1000]\n                (500, 1000, 0, 1000) # P2 = [500,1000] x [0,1000]\n            ]\n        },\n        {\n            \"L_x\": 1000, \"L_y\": 1000, \"N_x\": 10, \"N_y\": 10,\n            \"alpha\": 2, \"beta\": 0.001, \"gamma\": -0.0005,\n            \"polygons\": [\n                (200, 700, 200, 700), # P1 = [200,700] x [200,700]\n                (500, 900, 100, 600)  # P2 = [500,900] x [100,600]\n            ]\n        },\n        {\n            \"L_x\": 1000, \"L_y\": 1000, \"N_x\": 10, \"N_y\": 10,\n            \"alpha\": 2, \"beta\": 0.001, \"gamma\": -0.0005,\n            \"polygons\": [\n                (0, 400, 0, 1000),   # P1 = [0,400] x [0,1000]\n                (600, 1000, 0, 1000) # P2 = [600,1000] x [0,1000]\n            ]\n        }\n    ]\n\n    def mass_integral(x1, y1, x2, y2, alpha, beta, gamma):\n        \"\"\"\n        Calculates the exact integral of rho(x,y) over a rectangle [x1,x2]x[y1,y2].\n        \"\"\"\n        if x1 >= x2 or y1 >= y2:\n            return 0.0\n        area = (x2 - x1) * (y2 - y1)\n        centroid_x = (x1 + x2) / 2.0\n        centroid_y = (y1 + y2) / 2.0\n        rho_at_centroid = alpha + beta * centroid_x + gamma * centroid_y\n        return rho_at_centroid * area\n\n    all_results = []\n    for case in test_cases:\n        Lx, Ly, Nx, Ny = case[\"L_x\"], case[\"L_y\"], case[\"N_x\"], case[\"N_y\"]\n        alpha, beta, gamma = case[\"alpha\"], case[\"beta\"], case[\"gamma\"]\n        polygons = [p for p in case[\"polygons\"]]\n        \n        dx_cell = Lx / Nx\n        dy_cell = Ly / Ny\n        num_polygons = len(polygons)\n\n        # 1. Compute true polygon mass T_p\n        T_p = np.zeros(num_polygons)\n        for p_idx, poly in enumerate(polygons):\n            T_p[p_idx] = mass_integral(poly[0], poly[2], poly[1], poly[3], alpha, beta, gamma)\n\n        # Pre-compute cell masses\n        cell_masses = np.zeros((Nx, Ny))\n        for i in range(Nx):\n            for j in range(Ny):\n                x1_cell, x2_cell = i * dx_cell, (i + 1) * dx_cell\n                y1_cell, y2_cell = j * dy_cell, (j + 1) * dy_cell\n                cell_masses[i, j] = mass_integral(x1_cell, y1_cell, x2_cell, y2_cell, alpha, beta, gamma)\n\n        # 2. Centroid-assignment method A_cen\n        A_cen = np.zeros(num_polygons)\n        for i in range(Nx):\n            for j in range(Ny):\n                x1_cell, x2_cell = i * dx_cell, (i + 1) * dx_cell\n                y1_cell, y2_cell = j * dy_cell, (j + 1) * dy_cell\n                centroid_x = (x1_cell + x2_cell) / 2.0\n                centroid_y = (y1_cell + y2_cell) / 2.0\n                mass = cell_masses[i, j]\n\n                for p_idx, poly in enumerate(polygons):\n                    ax, bx, ay, by = poly[0], poly[1], poly[2], poly[3]\n                    if ax  centroid_x  bx and ay  centroid_y  by:\n                        A_cen[p_idx] += mass\n                        break\n\n        # 3. Exact-overlay method A_exact\n        A_exact = np.zeros(num_polygons)\n        for p_idx, poly in enumerate(polygons):\n            poly_x1, poly_x2, poly_y1, poly_y2 = poly\n            for i in range(Nx):\n                for j in range(Ny):\n                    cell_x1, cell_x2 = i * dx_cell, (i + 1) * dx_cell\n                    cell_y1, cell_y2 = j * dy_cell, (j + 1) * dy_cell\n\n                    inter_x1 = max(cell_x1, poly_x1)\n                    inter_x2 = min(cell_x2, poly_x2)\n                    inter_y1 = max(cell_y1, poly_y1)\n                    inter_y2 = min(cell_y2, poly_y2)\n                    \n                    mass_in_intersection = mass_integral(inter_x1, inter_y1, inter_x2, inter_y2, alpha, beta, gamma)\n                    A_exact[p_idx] += mass_in_intersection\n        \n        # 4. Compute error metrics\n        E_cen = np.sum(np.abs(A_cen - T_p))\n        C_cen = np.sum(A_cen) - np.sum(T_p)\n        \n        E_exact = np.sum(np.abs(A_exact - T_p))\n        C_exact = np.sum(A_exact) - np.sum(T_p)\n        \n        # Consistent with theory, E_exact and C_exact should be ~0.\n        # We present the calculated floating point values.\n        \n        case_results = [E_cen, C_cen, E_exact, C_exact]\n        all_results.append(case_results)\n\n    # Format output string\n    result_strings = []\n    for res in all_results:\n        result_strings.append(f\"[{','.join(f'{x:.17g}' for x in res)}]\")\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "升尺度并非总是简单的线性平均；当一个精细尺度的变量在聚合前经过非线性变换时，会出现一种称为聚合偏差（aggregation bias）的系统性误差。这种现象是琴生不等式（Jensen's inequality）的直接后果，在许多遥感应用中对其的理解至关重要。本练习  要求您通过解析推导来计算指数变换下的这种偏差，并将精确结果与一个常见的二阶近似进行比较，从而加深您对非线性过程尺度转换背后数学原理的理解。",
            "id": "3851419",
            "problem": "在一个地表遥感工作流中，一个高分辨率场 $X$ 代表某个辐射量的对数（例如，路径辐射的对数或柱光学厚度的对数）。该场在粗网格单元上的空间变异性被建模为均值为 $\\mu$、方差为 $\\sigma^{2}$ 的高斯分布，即 $X \\sim \\mathcal{N}(\\mu,\\sigma^{2})$。Level-2 产品在聚合前通过指数变换 $f(x)=\\exp(x)$ 将该场映射为一个物理量。升尺度这个非线性变换的聚合偏差定义为：变换后的细尺度场的粗网格期望与细尺度场的粗网格均值的变换之差，即\n$$\nB \\equiv \\mathbb{E}[f(X)] - f\\!\\left(\\mathbb{E}[X]\\right).\n$$\n从期望的核心定义、高斯分布的性质以及 Taylor 级数展开出发，推导 $B$ 的精确闭式表达式，以及通过将 $f$ 在 $x=\\mu$ 附近的 Taylor 展开截断到二次项得到的二阶近似。然后，报告以下比值的单一闭式解析表达式：\n$$\nR \\equiv \\frac{B}{B_{\\text{(second-order)}}},\n$$\n该表达式应以 $\\mu$ 和 $\\sigma^{2}$ 表示。无需进行数值计算，也无需四舍五入。请以无单位的符号表达式形式表达最终答案。",
            "solution": "该问题被验证为具有科学依据、良定且客观。这是空间统计学和遥感领域中一个关于非线性对空间聚合影响的标准问题。所有必需信息均已提供，问题没有矛盾或歧义。\n\n目标是求出比值 $R \\equiv \\frac{B}{B_{\\text{(second-order)}}}$，其中 $B$ 是精确的聚合偏差，$B_{\\text{(second-order)}}$ 是其二阶近似。场 $X$ 是一个服从高斯分布的随机变量，$X \\sim \\mathcal{N}(\\mu, \\sigma^{2})$，非线性变换为 $f(x) = \\exp(x)$。\n\n推导过程分三步：首先，计算精确偏差 $B$；其次，计算近似偏差 $B_{\\text{(second-order)}}$；第三，计算它们的比值 $R$。\n\n**第 1 步：精确聚合偏差 $B$ 的推导**\n\n聚合偏差 $B$ 定义为：\n$$\nB \\equiv \\mathbb{E}[f(X)] - f(\\mathbb{E}[X])\n$$\n给定随机变量 $X$ 服从正态分布 $X \\sim \\mathcal{N}(\\mu, \\sigma^{2})$。根据定义，$X$ 的期望为：\n$$\n\\mathbb{E}[X] = \\mu\n$$\n变换为 $f(x) = \\exp(x)$。将此变换应用于 $X$ 的期望可得：\n$$\nf(\\mathbb{E}[X]) = f(\\mu) = \\exp(\\mu)\n$$\n接下来，我们计算变换后变量的期望 $\\mathbb{E}[f(X)]$：\n$$\n\\mathbb{E}[f(X)] = \\mathbb{E}[\\exp(X)]\n$$\n根据定义，该表达式是随机变量 $X$ 的矩生成函数 (MGF)，记为 $M_X(t)$，在 $t=1$ 处的值。对于正态分布 $X \\sim \\mathcal{N}(\\mu, \\sigma^{2})$，其 MGF 的标准公式为：\n$$\nM_X(t) = \\mathbb{E}[\\exp(tX)] = \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^{2}t^{2}\\right)\n$$\n在 $t=1$ 处计算 MGF 的值：\n$$\n\\mathbb{E}[\\exp(X)] = M_X(1) = \\exp\\left(\\mu \\cdot 1 + \\frac{1}{2}\\sigma^{2}\\cdot 1^{2}\\right) = \\exp\\left(\\mu + \\frac{1}{2}\\sigma^{2}\\right)\n$$\n这是对数正态分布均值的著名公式。\n\n现在，我们可以组合出精确偏差 $B$ 的表达式：\n$$\nB = \\mathbb{E}[\\exp(X)] - \\exp(\\mathbb{E}[X]) = \\exp\\left(\\mu + \\frac{1}{2}\\sigma^{2}\\right) - \\exp(\\mu)\n$$\n通过提取公因子 $\\exp(\\mu)$，我们得到精确偏差的最终表达式：\n$$\nB = \\exp(\\mu)\\left(\\exp\\left(\\frac{1}{2}\\sigma^{2}\\right) - 1\\right)\n$$\n\n**第 2 步：二阶近似偏差 $B_{\\text{(second-order)}}$ 的推导**\n\n二阶近似是通过对 $f(x)$ 在均值 $\\mu$ 附近的 Taylor 级数展开求期望，并截断到二次项得到的。函数 $f(x)$ 在 $x=\\mu$ 附近的 Taylor 展开为：\n$$\nf(x) = f(\\mu) + f'(\\mu)(x-\\mu) + \\frac{f''(\\mu)}{2!}(x-\\mu)^{2} + \\mathcal{O}\\left((x-\\mu)^{3}\\right)\n$$\n对于函数 $f(x) = \\exp(x)$，其导数为 $f'(x) = \\exp(x)$ 和 $f''(x) = \\exp(x)$。在 $x=\\mu$ 处计算这些导数的值，得到 $f'(\\mu) = \\exp(\\mu)$ 和 $f''(\\mu) = \\exp(\\mu)$。\n将这些代入 Taylor 展开式并在二阶处截断，得到 $f(X)$ 的近似：\n$$\nf(X) \\approx \\exp(\\mu) + \\exp(\\mu)(X-\\mu) + \\frac{\\exp(\\mu)}{2}(X-\\mu)^{2}\n$$\n这个近似表达式的期望，记为 $\\mathbb{E}[f(X)]_{\\text{approx}}$，可利用期望算子的线性性质求得：\n$$\n\\mathbb{E}[f(X)]_{\\text{approx}} = \\mathbb{E}\\left[\\exp(\\mu) + \\exp(\\mu)(X-\\mu) + \\frac{\\exp(\\mu)}{2}(X-\\mu)^{2}\\right]\n$$\n$$\n\\mathbb{E}[f(X)]_{\\text{approx}} = \\exp(\\mu) + \\exp(\\mu)\\mathbb{E}[X-\\mu] + \\frac{\\exp(\\mu)}{2}\\mathbb{E}\\left[(X-\\mu)^{2}\\right]\n$$\n我们使用 $X$ 分布的两个基本性质：\n1. 与均值的偏差的期望为零：$\\mathbb{E}[X-\\mu] = \\mathbb{E}[X] - \\mu = \\mu - \\mu = 0$。\n2. 与均值的偏差的平方的期望是方差：$\\mathbb{E}\\left[(X-\\mu)^{2}\\right] = \\sigma^{2}$。\n\n将这些结果代入 $\\mathbb{E}[f(X)]_{\\text{approx}}$ 的表达式中：\n$$\n\\mathbb{E}[f(X)]_{\\text{approx}} = \\exp(\\mu) + \\exp(\\mu) \\cdot 0 + \\frac{\\exp(\\mu)}{2} \\cdot \\sigma^{2} = \\exp(\\mu)\\left(1 + \\frac{1}{2}\\sigma^{2}\\right)\n$$\n二阶近似偏差 $B_{\\text{(second-order)}}$ 是这个近似期望与变换后的均值之差：\n$$\nB_{\\text{second-order}} = \\mathbb{E}[f(X)]_{\\text{approx}} - f(\\mathbb{E}[X]) = \\exp(\\mu)\\left(1 + \\frac{1}{2}\\sigma^{2}\\right) - \\exp(\\mu)\n$$\n$$\nB_{\\text{(second-order)}} = \\exp(\\mu) + \\frac{1}{2}\\exp(\\mu)\\sigma^{2} - \\exp(\\mu) = \\frac{1}{2}\\exp(\\mu)\\sigma^{2}\n$$\n\n**第 3 步：比值 $R$ 的计算**\n\n最后一步是计算比值 $R = \\frac{B}{B_{\\text{(second-order)}}}$。我们代入前面步骤中推导出的表达式：\n$$\nR = \\frac{\\exp(\\mu)\\left(\\exp\\left(\\frac{1}{2}\\sigma^{2}\\right) - 1\\right)}{\\frac{1}{2}\\exp(\\mu)\\sigma^{2}}\n$$\n项 $\\exp(\\mu)$ 同时出现在分子和分母中，并且由于 $\\exp(\\mu)  0$，可以消去。这留下一个只依赖于方差 $\\sigma^{2}$ 的表达式：\n$$\nR = \\frac{\\exp\\left(\\frac{1}{2}\\sigma^{2}\\right) - 1}{\\frac{1}{2}\\sigma^{2}}\n$$\n这可以写成一种更简洁的形式，让分母成为一个单项：\n$$\nR = \\frac{\\exp\\left(\\frac{\\sigma^{2}}{2}\\right) - 1}{\\frac{\\sigma^{2}}{2}}\n$$\n这就是所要求比值的最终的精确闭式表达式。",
            "answer": "$$\n\\boxed{\\frac{\\exp\\left(\\frac{\\sigma^{2}}{2}\\right) - 1}{\\frac{\\sigma^{2}}{2}}}\n$$"
        },
        {
            "introduction": "从升尺度转向降尺度（downscaling），我们常常需要根据粗糙数据创建高分辨率地图，同时尊重特定区域内的已知总量。等值区域插值法（Pycnophylactic interpolation，或称“质量守恒”插值法）是完成此任务的一种经典而优雅的技术，它能生成一个既平滑又满足这些约束条件的表面。在本练习  中，您将实施迭代式的等值区域插值算法，该算法巧妙地平衡了平滑度与守恒性的目标，为理解约束性空间插值的原理提供了实践性的入门。",
            "id": "3851410",
            "problem": "考虑一个具有 $m \\times n$ 个单元的高分辨率矩形网格，单元由整数对 $(i,j)$ 索引，其中 $i \\in \\{0,\\dots,m-1\\}$ 且 $j \\in \\{0,\\dots,n-1\\}$。定义在此网格上的一个非负标量场 $x$ 由数组 $x_{i,j} \\in \\mathbb{R}_{\\ge 0}$ 表示。该网格通过一个给定的区域标签数组 $z_{i,j} \\in \\{0,\\dots,B-1\\}$ 被划分为 $B$ 个不相交的区域，每个区域 $b \\in \\{0,\\dots,B-1\\}$ 都有一个指定的粗略总和 $M_b \\in \\mathbb{R}_{\\ge 0}$，这是该区域内高分辨率值的目标总和。pycnophylactic 插值法的目标是构建一个平滑的高分辨率场 $x$，同时精确地保持区域总和不变，即对于每个区域 $b$，\n$$\n\\sum_{\\{(i,j) \\mid z_{i,j} = b\\}} x_{i,j} = M_b.\n$$\n\n从一个初始非负场 $x^{(0)}$ 开始，通过带有齐次诺伊曼（反射）边界条件的 $5$ 点平均定义一个平滑算子 $S$：\n$$\n\\left(Sx\\right)_{i,j} = \\frac{1}{5}\\left(x_{i,j} + x_{\\max(i-1,0),j} + x_{\\min(i+1,m-1),j} + x_{i,\\max(j-1,0)} + x_{i,\\min(j+1,n-1)}\\right).\n$$\nPycnophylactic 插值法迭代地交替进行平滑处理与通过逐区域重缩放精确强制执行区域总和守恒。令 $Z_b = \\{(i,j) \\mid z_{i,j}=b\\}$ 表示区域 $b$ 的索引集。用 $s_b(x) = \\sum_{(p,q)\\in Z_b} x_{p,q}$ 表示区域 $b$ 上的总和。重缩放算子 $R$ 的作用如下：\n$$\n\\left(Ry\\right)_{i,j} =\n\\begin{cases}\n\\displaystyle r_b \\, y_{i,j}  \\text{若 } z_{i,j} = b, \\\\\n\\end{cases}\n\\quad \\text{其中} \\quad r_b = \n\\begin{cases}\n\\displaystyle \\frac{M_b}{s_b(y)}  \\text{若 } s_b(y)  0, \\\\\n\\displaystyle 0  \\text{若 } s_b(y) = 0 \\text{ 且 } M_b = 0.\n\\end{cases}\n$$\n然后，pycnophylactic 更新为\n$$\nx^{(k+1)} = R\\big(S(x^{(k)})\\big),\n$$\n这在每次迭代后强制执行 $s_b\\!\\left(x^{(k+1)}\\right) = M_b$ 对所有 $b$ 成立，同时通过 $S$ 促进平滑性。\n\n你的任务是：\n- 从第一性原理推导为什么更新 $x^{(k+1)} = R\\big(S(x^{(k)})\\big)$ 对所有 $k$ 都能保持精确的粗略总和，并解释其与在线性守恒约束条件下最小化离散狄利克雷能量的联系。\n- 使用上面定义的 $5$ 点平均 $S$ 和逐区域重缩放 $R$ 来实现迭代的 pycnophylactic 插值算法。\n- 对于每个提供的测试用例，运行算法直到收敛或达到固定的迭代上限，以先发生者为准。当最大绝对变化 $\\max_{i,j} \\left|x^{(k+1)}_{i,j} - x^{(k)}_{i,j}\\right|$ 低于容差 $\\varepsilon$ 时，可以检测到收敛。\n- 对于每个测试用例，计算：\n  $1)$ 一个布尔值，指示最终场的所有区域总和是否在其目标总和的绝对容差 $\\varepsilon$ 范围内，以及\n  $2)$ 最终离散狄利克雷能量与初始离散狄利克雷能量之比，\n$$\nE(x) = \\sum_{i=1}^{m-1}\\sum_{j=0}^{n-1} \\left(x_{i,j} - x_{i-1,j}\\right)^2 + \\sum_{i=0}^{m-1}\\sum_{j=1}^{n-1} \\left(x_{i,j} - x_{i,j-1}\\right)^2,\n$$\n四舍五入到六位小数。如果 $E\\!\\left(x^{(0)}\\right) = 0$，则定义该比率为 $0.0$。\n\n你的程序应产生单行输出，包含一个方括号括起来的逗号分隔列表（例如 $[result1,result2,result3]$）。对于 $N$ 个测试用例，输出应按 $[b_1,r_1,b_2,r_2,\\dots,b_N,r_N]$ 的顺序排列，其中 $b_t$ 是测试用例 $t$ 的布尔值，$r_t$ 是测试用例 $t$ 的能量比率，四舍五入到六位小数。\n\n使用以下测试套件。在所有情况下，使用 $\\varepsilon = 10^{-9}$，迭代上限为 $k_{\\max} = 300$，并完全按照指定的方式初始化 $x^{(0)}$。\n\n- 测试用例 $1$（理想路径，多区域矩形分区）：\n  - 网格大小：$m = 4$，$n = 4$。\n  - 区域标签 $z$（行从上到下列出），含 $B = 4$ 个区域：\n    $$\n    \\begin{aligned}\n    \\left[\\,0,\\,0,\\,1,\\,1\\,\\right],\\\\\n    \\left[\\,0,\\,0,\\,1,\\,1\\,\\right],\\\\\n    \\left[\\,2,\\,2,\\,3,\\,3\\,\\right],\\\\\n    \\left[\\,2,\\,2,\\,3,\\,3\\,\\right].\n    \\end{aligned}\n    $$\n  - 粗略总和：$M_0 = 10$，$M_1 = 20$，$M_2 = 30$，$M_3 = 40$。\n  - 初始场 $x^{(0)}$（行从上到下列出）：\n    $$\n    \\begin{aligned}\n    \\left[\\,1.0,\\,1.2,\\,0.8,\\,0.9\\,\\right],\\\\\n    \\left[\\,1.1,\\,0.9,\\,1.3,\\,0.7\\,\\right],\\\\\n    \\left[\\,0.6,\\,0.5,\\,1.4,\\,1.1\\,\\right],\\\\\n    \\left[\\,0.4,\\,0.6,\\,1.0,\\,1.2\\,\\right].\n    \\end{aligned}\n    $$\n\n- 测试用例 $2$（含零总和区域的边界条件）：\n  - 网格大小：$m = 2$，$n = 4$。\n  - 区域标签 $z$，含 $B = 2$ 个区域：\n    $$\n    \\begin{aligned}\n    \\left[\\,0,\\,0,\\,1,\\,1\\,\\right],\\\\\n    \\left[\\,0,\\,0,\\,1,\\,1\\,\\right].\n    \\end{aligned}\n    $$\n  - 粗略总和：$M_0 = 0$，$M_1 = 50$。\n  - 初始场 $x^{(0)}$：\n    $$\n    \\begin{aligned}\n    \\left[\\,0.5,\\,0.2,\\,1.0,\\,1.5\\,\\right],\\\\\n    \\left[\\,0.4,\\,0.3,\\,0.8,\\,2.0\\,\\right].\n    \\end{aligned}\n    $$\n\n- 测试用例 $3$（不规则区域几何形状）：\n  - 网格大小：$m = 3$，$n = 5$。\n  - 区域标签 $z$，含 $B = 3$ 个区域：\n    $$\n    \\begin{aligned}\n    \\left[\\,0,\\,0,\\,1,\\,1,\\,1\\,\\right],\\\\\n    \\left[\\,0,\\,2,\\,2,\\,1,\\,1\\,\\right],\\\\\n    \\left[\\,0,\\,2,\\,2,\\,2,\\,1\\,\\right].\n    \\end{aligned}\n    $$\n  - 粗略总和：$M_0 = 5$，$M_1 = 15$，$M_2 = 10$。\n  - 初始场 $x^{(0)}$：\n    $$\n    \\begin{aligned}\n    \\left[\\,1.0,\\,0.5,\\,2.0,\\,1.0,\\,0.5\\,\\right],\\\\\n    \\left[\\,0.8,\\,3.0,\\,1.0,\\,2.0,\\,1.5\\,\\right],\\\\\n    \\left[\\,0.6,\\,0.5,\\,0.5,\\,3.0,\\,0.7\\,\\right].\n    \\end{aligned}\n    $$\n\n- 测试用例 $4$（单区域域）：\n  - 网格大小：$m = 3$，$n = 3$。\n  - 区域标签 $z$，含 $B = 1$ 个区域：\n    $$\n    \\begin{aligned}\n    \\left[\\,0,\\,0,\\,0\\,\\right],\\\\\n    \\left[\\,0,\\,0,\\,0\\,\\right],\\\\\n    \\left[\\,0,\\,0,\\,0\\,\\right].\n    \\end{aligned}\n    $$\n  - 粗略总和：$M_0 = 100$。\n  - 初始场 $x^{(0)}$：\n    $$\n    \\begin{aligned}\n    \\left[\\,1.0,\\,2.0,\\,3.0\\,\\right],\\\\\n    \\left[\\,4.0,\\,5.0,\\,6.0\\,\\right],\\\\\n    \\left[\\,7.0,\\,8.0,\\,9.0\\,\\right].\n    \\endaligned}\n    $$\n\n完全按照规定实现算法。你的程序应在单行上输出列表 $[b_1,r_1,b_2,r_2,b_3,r_3,b_4,r_4]$，其中每个 $b_t$ 是一个布尔值，每个 $r_t$ 是一个浮点数，四舍五入到六位小数。不允许有其他输出。",
            "solution": "pycnophylactic 插值问题是在一个网格上构建一个平滑的高分辨率标量场 $x$，该场遵循指定的粗分辨率区域总和。该问题定义明确，其科学基础植根于成熟的空间分析技术，并为计算求解提供了所有必要的数据和参数。因此，该问题被认为是有效的。\n\n### 理论基础\n\n#### 1. 粗略总和的保持\n\n迭代更新规则由 $x^{(k+1)} = R\\big(S(x^{(k)})\\big)$ 给出。我们必须证明对于任何 $k \\ge 0$，结果场 $x^{(k+1)}$ 都满足守恒约束 $\\sum_{\\{(i,j) \\mid z_{i,j} = b\\}} x^{(k+1)}_{i,j} = M_b$ 对每个区域 $b \\in \\{0, \\dots, B-1\\}$ 都成立。\n\n令 $y = S(x^{(k)})$ 为平滑步骤后的场。下一个迭代值为 $x^{(k+1)} = R(y)$。为了验证守恒属性，我们计算 $x^{(k+1)}$ 在任意区域 $b$ 上的值的总和。令 $Z_b = \\{(i,j) \\mid z_{i,j}=b\\}$ 为区域 $b$ 的单元索引集。\n\n区域 $b$ 上的总和为：\n$$ \\sum_{(i,j) \\in Z_b} x^{(k+1)}_{i,j} = \\sum_{(i,j) \\in Z_b} (Ry)_{i,j} $$\n\n根据重缩放算子 $R$ 的定义，对于区域 $b$ 内的任何单元 $(i,j)$，值 $(Ry)_{i,j}$ 由 $r_b \\, y_{i,j}$ 给出，其中 $r_b$ 是整个区域的恒定缩放因子。因此，我们可以将 $r_b$ 从求和中提取出来：\n$$ \\sum_{(i,j) \\in Z_b} (Ry)_{i,j} = \\sum_{(i,j) \\in Z_b} r_b \\, y_{i,j} = r_b \\sum_{(i,j) \\in Z_b} y_{i,j} $$\n\n总和 $\\sum_{(i,j) \\in Z_b} y_{i,j}$ 正是平滑后的场在区域 $b$ 上的总和，记为 $s_b(y)$。因此，表达式变为：\n$$ \\sum_{(i,j) \\in Z_b} x^{(k+1)}_{i,j} = r_b \\, s_b(y) $$\n\n我们现在基于缩放因子 $r_b$ 的定义来分析这一点：\n- **情况 1：$s_b(y)  0$。** 在这种情况下，$r_b = \\frac{M_b}{s_b(y)}$。将其代入我们的方程，得到：\n  $$ \\sum_{(i,j) \\in Z_b} x^{(k+1)}_{i,j} = \\left(\\frac{M_b}{s_b(y)}\\right) s_b(y) = M_b $$\n- **情况 2：$s_b(y) = 0$ 且 $M_b = 0$。** 在这种情况下，$r_b = 0$。方程给出：\n  $$ \\sum_{(i,j) \\in Z_b} x^{(k+1)}_{i,j} = (0) \\cdot (0) = 0 = M_b $$\n\n在所有明确定义的情况下，$x^{(k+1)}$ 中区域 $b$ 上的值的总和恰好是 $M_b$。算子 $R$ 被精确地构建以强制执行此属性。由于更新 $x^{(k+1)}$ 是算子 $R$ 的直接输出，它必须对所有的 $k$ 满足区域总和约束，前提是迭代从一个非负场 $x^{(0)}$ 开始，并且平滑不会导致 $s_b(y) = 0$ 而 $M_b  0$ 的未定义情况。给定的平滑算子 $S$ 是一个平均过程，它保持非负性并扩散值，使得在给定的初始数据下，这种病态情况极不可能发生。\n\n#### 2. 与约束能量最小化的联系\n\npycnophylactic 问题可以表述为一个约束优化问题。目标是找到一个尽可能“平滑”的场 $x$，同时满足给定的约束。衡量场不平滑性（或“粗糙度”）的标准度量是离散狄利克雷能量：\n$$ E(x) = \\sum_{i=1}^{m-1}\\sum_{j=0}^{n-1} \\left(x_{i,j} - x_{i-1,j}\\right)^2 + \\sum_{i=0}^{m-1}\\sum_{j=1}^{n-1} \\left(x_{i,j} - x_{i,j-1}\\right)^2 $$\n该能量是相邻单元值之差的平方和。一个更平滑的场具有较小的局部变化，因此具有较低的狄利克雷能量。\n\n优化问题是：\n$$ \\text{最小化} \\quad E(x) \\\\ \\text{约束条件：} \\quad \\sum_{\\{(i,j) \\mid z_{i,j} = b\\}} x_{i,j} = M_b \\quad \\text{对所有 } b \\in \\{0, \\dots, B-1\\} \\\\ \\text{且} \\quad x_{i,j} \\ge 0 \\quad \\text{对所有 } i,j. $$\n\n这是一个凸优化问题，因为它涉及在一个凸可行集（由线性等式约束和非负性定义）上最小化一个凸函数（$E(x)$ 是二次的）。\n\n迭代算法 $x^{(k+1)} = R(S(x^{(k)}))$ 是解决此问题的一种交替投影法（或更一般地，算子分裂法）的形式。两个主要操作，平滑和重缩放，可以被解释为解决问题的两个相互竞争的需求（平滑性和约束满足）的步骤。\n\n1.  **平滑步骤 $y = S(x^{(k)})$**：此步骤旨在减少狄利克雷能量。平滑算子 $S$ 的更新规则是一个 5 点平均，它等价于求解离散拉普拉斯方程 $\\nabla^2 x = 0$ 的雅可比法的一次迭代。该方程的稳态解（带有诺伊曼边界）是一个常数场，其具有最小可能的狄利克雷能量 $0$。因此，应用 $S$ 将场 $x^{(k)}$ 移向更平滑的配置。\n\n2.  **重缩放步骤 $x^{(k+1)} = R(y)$**：平滑后的场 $y$ 通常不会满足区域总和约束。算子 $R$ 将场 $y$ 投影回由线性守恒约束定义的可行集上。通过将区域 $b$ 内的所有值乘以单个因子 $r_b$，它恢复了所需的总和 $M_b$。这种乘法投影特别适用于也包含非负性约束的问题。\n\n总而言之，该算法在促进目标（最小化能量）的步骤和强制执行约束的步骤之间迭代交替。虽然单次迭代不保证能量减少（投影步骤 $R$ 可能会增加它），但这类交替方案已知会收敛到一个不动点，在此背景下，该不动点代表了在最大平滑度和精确质量守恒之间取得平衡的最优解。\n\n### 实现策略\n\n该算法将使用 `numpy` 库在 Python 中实现，以进行高效的数组操作。一个函数将封装单个测试用例的逻辑。\n\n1.  **初始化**：将初始场 $x^{(0)}$、区域标签 $z$ 和粗略总和 $M$ 初始化为 `numpy` 数组。\n2.  **迭代**：一个循环最多运行 $k_{\\max} = 300$ 次。\n3.  **平滑 ($S$)**：高效地实现带有反射（诺伊曼）边界条件的 $5$ 点平均。使用 `np.pad(x, 1, mode='edge')` 为场 `x` 填充一个 1 单元的边界。然后，在填充后的数组上使用向量化操作计算平滑场 `y`，对每个单元的五个相应位置（中心、上、下、左、右）的值求和并除以 $5$。\n4.  **重缩放 ($R$)**：初始化新场 `x_next`。一个循环遍历每个区域 $b \\in \\{0, \\dots, B-1\\}$。对于每个区域，一个布尔掩码识别属于它的单元。计算平滑场 `y` 在该区域上的总和 $s_b(y)$。根据问题的定义确定缩放比率 $r_b$。然后将区域内 `x_next` 的值设置为 `y` 的相应值乘以 $r_b$。循环结束后，将主场 `x` 更新为 `x_next`。\n5.  **收敛**：每次迭代后，计算当前场 $x$ 和前一个场 $x_{\\text{prev}}$ 之间的最大绝对差。如果此差值低于容差 $\\varepsilon = 10^{-9}$，则循环终止。\n6.  **最终计算**：\n    - **守恒性检查**：循环结束后，计算每个区域的最终总和，并将其与目标总和 $M_b$ 进行比较。如果所有区域总和都在其目标的容差 $\\varepsilon$ 范围内，则将一个布尔标志设置为 `True`，否则为 `False`。\n    - **能量比率**：一个辅助函数使用 `numpy` 切片计算水平和垂直差异来计算离散狄利克雷能量 $E(x)$。计算比率 $E(x^{(\\text{final})}) / E(x^{(0)})$，处理 $E(x^{(0)}) = 0$ 的情况。结果四舍五入到六位小数。\n\n收集每个测试用例的结果（守恒布尔值和能量比率），并将其格式化为所需的单行输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for pycnophylactic interpolation\n    and print the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (happy path, multi-zone rectangular partition)\n        {\n            \"m\": 4, \"n\": 4,\n            \"z\": np.array([\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [2, 2, 3, 3],\n                [2, 2, 3, 3]\n            ]),\n            \"M\": np.array([10.0, 20.0, 30.0, 40.0]),\n            \"x0\": np.array([\n                [1.0, 1.2, 0.8, 0.9],\n                [1.1, 0.9, 1.3, 0.7],\n                [0.6, 0.5, 1.4, 1.1],\n                [0.4, 0.6, 1.0, 1.2]\n            ])\n        },\n        # Test case 2 (boundary condition with a zero-total zone)\n        {\n            \"m\": 2, \"n\": 4,\n            \"z\": np.array([\n                [0, 0, 1, 1],\n                [0, 0, 1, 1]\n            ]),\n            \"M\": np.array([0.0, 50.0]),\n            \"x0\": np.array([\n                [0.5, 0.2, 1.0, 1.5],\n                [0.4, 0.3, 0.8, 2.0]\n            ])\n        },\n        # Test case 3 (irregular zone geometry)\n        {\n            \"m\": 3, \"n\": 5,\n            \"z\": np.array([\n                [0, 0, 1, 1, 1],\n                [0, 2, 2, 1, 1],\n                [0, 2, 2, 2, 1]\n            ]),\n            \"M\": np.array([5.0, 15.0, 10.0]),\n            \"x0\": np.array([\n                [1.0, 0.5, 2.0, 1.0, 0.5],\n                [0.8, 3.0, 1.0, 2.0, 1.5],\n                [0.6, 0.5, 0.5, 3.0, 0.7]\n            ])\n        },\n        # Test case 4 (single-zone domain)\n        {\n            \"m\": 3, \"n\": 3,\n            \"z\": np.array([\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"M\": np.array([100.0]),\n            \"x0\": np.array([\n                [1.0, 2.0, 3.0],\n                [4.0, 5.0, 6.0],\n                [7.0, 8.0, 9.0]\n            ])\n        }\n    ]\n\n    # Global parameters\n    k_max = 300\n    epsilon = 1e-9\n    \n    results = []\n    for case in test_cases:\n        conserved, ratio = run_pycno(\n            case[\"z\"], case[\"M\"], case[\"x0\"], k_max, epsilon\n        )\n        results.append(str(conserved))\n        results.append(f\"{ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef E_dirichlet(x: np.ndarray) - float:\n    \"\"\"Computes the discrete Dirichlet energy of a 2D field.\"\"\"\n    if x.shape[0]  2 and x.shape[1]  2:\n        return 0.0\n    \n    diff_h = 0.0\n    if x.shape[0] > 1:\n        diff_h = np.sum((x[1:, :] - x[:-1, :])**2)\n    \n    diff_v = 0.0\n    if x.shape[1] > 1:\n        diff_v = np.sum((x[:, 1:] - x[:, :-1])**2)\n        \n    return float(diff_h + diff_v)\n\ndef run_pycno(z: np.ndarray, M: np.ndarray, x0: np.ndarray, k_max: int, eps: float):\n    \"\"\"\n    Performs pycnophylactic interpolation for a single test case.\n\n    Args:\n        z: Zone label array.\n        M: Array of coarse totals for each zone.\n        x0: Initial field.\n        k_max: Maximum number of iterations.\n        eps: Convergence tolerance.\n\n    Returns:\n        A tuple containing:\n        - A boolean indicating if zone sums are conserved.\n        - The ratio of final to initial Dirichlet energy.\n    \"\"\"\n    x = np.copy(x0)\n    num_zones = len(M)\n\n    for _ in range(k_max):\n        x_prev = np.copy(x)\n\n        # Smoothing step (S)\n        # Pad the array to handle Neumann boundary conditions\n        padded_x = np.pad(x, 1, mode='edge')\n        \n        # Apply the 5-point average stencil using vectorized operations\n        y = (padded_x[1:-1, 1:-1] +   # Center\n             padded_x[:-2, 1:-1] +    # Up\n             padded_x[2:, 1:-1] +     # Down\n             padded_x[1:-1, :-2] +    # Left\n             padded_x[1:-1, 2:]) / 5.0\n\n        # Rescaling step (R)\n        x_next = np.zeros_like(x)\n        for b in range(num_zones):\n            mask = (z == b)\n            if not np.any(mask):\n                continue\n            \n            s_b = np.sum(y[mask])\n            M_b = M[b]\n\n            r_b = 0.0\n            if s_b > 0:\n                r_b = M_b / s_b\n            elif M_b == 0:  # This covers the case s_b == 0 and M_b == 0\n                r_b = 0.0\n            # The case s_b == 0 and M_b > 0 would be a division by zero.\n            # This is not expected given the smoothing operator and positive initial fields.\n\n            x_next[mask] = y[mask] * r_b\n        \n        x = x_next\n\n        # Check for convergence\n        max_change = np.max(np.abs(x - x_prev))\n        if max_change  eps:\n            break\n\n    # Calculate final metrics after iteration\n    \n    # 1. Check if all zone sums are conserved within tolerance\n    conserved = True\n    for b in range(num_zones):\n        mask = (z == b)\n        if not np.any(mask):\n            continue\n        final_sum = np.sum(x[mask])\n        if np.abs(final_sum - M[b]) > eps:\n            conserved = False\n            break\n\n    # 2. Calculate the ratio of final to initial discrete Dirichlet energy\n    E_initial = E_dirichlet(x0)\n    E_final = E_dirichlet(x)\n\n    if E_initial  eps: # Treat as zero if very small\n        energy_ratio = 0.0\n    else:\n        energy_ratio = E_final / E_initial\n\n    return conserved, energy_ratio\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}