{
    "hands_on_practices": [
        {
            "introduction": "在遥感中，诸如归一化植被指数（$NDVI$）等非线性指数被广泛用于监测地球系统。然而，一个常见的问题是，我们应该先对反射率数据进行时间平均，然后再计算指数，还是应该先计算每日的指数值，然后再对指数进行平均？这个练习将通过一个具体的例子，引导您从第一性原理出发，推导并量化这两种聚合顺序所产生的偏差。通过这项实践，您将深刻理解非线性变换与数据聚合之间的相互作用，这是准确解释时间序列遥感数据的基础。",
            "id": "3859636",
            "problem": "一个陆地植被像元在生长季的两个不同时间被多光谱卫星观测。在每个时间点，仪器记录了传感器接收到的近红外波段和红光波段的反射率，在时间 $t_1$ 记为 $N_1$、$R_1$，在时间 $t_2$ 记为 $N_2$、$R_2$。归一化植被指数 (NDVI) 定义为近红外反射率 $N$ 和红光反射率 $R$ 的函数 $f(N,R)$。从业者应用的时间聚合方法可以是先平均反射率再计算 $f$，也可以是先计算每个时间的 $f$ 再对指数进行平均。在遥感和环境建模的背景下，由于指数的非线性，时间尺度变换和数据聚合可能会导致系统性偏差。\n\n假设在典型条件下，一个叶冠的物理上合理的反射率为：$N_1 = 0.7$，$R_1 = 0.05$ 以及 $N_2 = 0.2$，$R_2 = 0.18$。令时间聚合反射率为 $\\bar{N} = (N_1 + N_2)/2$ 和 $\\bar{R} = (R_1 + R_2)/2$。将 NDVI 的时间均值定义为 $f(N_1,R_1)$ 和 $f(N_2,R_2)$ 的算术平均值，将聚合 NDVI 定义为 $f(\\bar{N},\\bar{R})$。\n\n从 NDVI 作为反射率的有理函数及其平均值的基本性质出发，根据第一性原理推导一个表达式，说明 $f(\\bar{N},\\bar{R})$ 如何与 $f(N_1,R_1)$ 和 $f(N_2,R_2)$ 的加权平均值相关联，并用此解释当总反射率 $N_i + R_i$ 在 NDVI 较大的时刻也较大时，偏差的方向。然后，计算偏差\n$$\\Delta = f(\\bar{N},\\bar{R}) - \\frac{f(N_1,R_1) + f(N_2,R_2)}{2}.$$\n将最终结果表示为一个无单位的十进制小数。将答案四舍五入到 $4$ 位有效数字。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于遥感原理，在数学上是适定的，并且为得出唯一解提供了所有必要的数据和定义。该情景是由于非线性变换引起的聚合偏差的一个典型例子，这是环境建模中的一个基本课题。\n\n归一化植被指数 (NDVI) 定义为近红外反射率 $N$ 和红光反射率 $R$ 的函数 $f$。这个标准指数是一个有理函数，由下式给出：\n$$f(N,R) = \\frac{N-R}{N+R}$$\n问题考虑了两种时间聚合方案。第一种方案涉及根据时间平均的反射率计算 NDVI，我们称这个量为聚合 NDVI：\n$$f(\\bar{N}, \\bar{R})$$\n其中 $\\bar{N} = \\frac{N_1+N_2}{2}$ 且 $\\bar{R} = \\frac{R_1+R_2}{2}$。\n\n第二种方案涉及对每个时间步计算的 NDVI 值进行平均，我们称之为 NDVI 的时间均值：\n$$\\frac{f(N_1,R_1) + f(N_2,R_2)}{2}$$\n\n第一个任务是推导一个表达式，将聚合 NDVI 与单个 NDVI 值 $f(N_1,R_1)$ 和 $f(N_2,R_2)$ 的加权平均值联系起来。我们首先将 $\\bar{N}$ 和 $\\bar{R}$ 的定义代入函数 $f$ 中：\n$$f(\\bar{N},\\bar{R}) = \\frac{\\bar{N}-\\bar{R}}{\\bar{N}+\\bar{R}} = \\frac{\\frac{N_1+N_2}{2} - \\frac{R_1+R_2}{2}}{\\frac{N_1+N_2}{2} + \\frac{R_1+R_2}{2}}$$\n分子和分母中的因子 $\\frac{1}{2}$ 可以消去：\n$$f(\\bar{N},\\bar{R}) = \\frac{(N_1-R_1) + (N_2-R_2)}{(N_1+R_1) + (N_2+R_2)}$$\n为了揭示与单个 NDVI 值的关系，令 $NDVI_1 = f(N_1,R_1)$ 和 $NDVI_2 = f(N_2,R_2)$。根据 NDVI 的定义，我们可以将指数的分子 $N-R$ 写成指数与其分母 $N+R$ 的乘积。因此，$N_1-R_1 = NDVI_1 \\cdot (N_1+R_1)$ 和 $N_2-R_2 = NDVI_2 \\cdot (N_2+R_2)$。将这些代入 $f(\\bar{N},\\bar{R})$ 的表达式中：\n$$f(\\bar{N},\\bar{R}) = \\frac{NDVI_1 (N_1+R_1) + NDVI_2 (N_2+R_2)}{(N_1+R_1) + (N_2+R_2)}$$\n让我们将每个时间步的总反射率定义为 $S_i = N_i+R_i$，其中 $i \\in \\{1, 2\\}$。表达式简化为：\n$$f(\\bar{N},\\bar{R}) = \\frac{S_1 \\cdot NDVI_1 + S_2 \\cdot NDVI_2}{S_1+S_2}$$\n这个方程可以重写为加权平均的形式：\n$$f(\\bar{N},\\bar{R}) = \\left(\\frac{S_1}{S_1+S_2}\\right) NDVI_1 + \\left(\\frac{S_2}{S_1+S_2}\\right) NDVI_2$$\n这表明聚合 NDVI，$f(\\bar{N},\\bar{R})$，是单个 NDVI 值的加权平均值，其中权重由每次观测的总反射率 $S_i$ 在总反射率之和 $S_1+S_2$ 中所占的比例决定。\n\n下一个任务是解释偏差 $\\Delta = f(\\bar{N}, \\bar{R}) - \\frac{NDVI_1 + NDVI_2}{2}$ 的方向。使用我们推导出的 $f(\\bar{N},\\bar{R})$ 表达式：\n$$\\Delta = \\left(\\frac{S_1}{S_1+S_2} NDVI_1 + \\frac{S_2}{S_1+S_2} NDVI_2 \\right) - \\left(\\frac{1}{2} NDVI_1 + \\frac{1}{2} NDVI_2 \\right)$$\n按 $NDVI_1$ 和 $NDVI_2$ 分组各项：\n$$\\Delta = \\left(\\frac{S_1}{S_1+S_2} - \\frac{1}{2}\\right) NDVI_1 + \\left(\\frac{S_2}{S_1+S_2} - \\frac{1}{2}\\right) NDVI_2$$\n为系数找到公分母：\n$$\\frac{S_1}{S_1+S_2} - \\frac{1}{2} = \\frac{2S_1 - (S_1+S_2)}{2(S_1+S_2)} = \\frac{S_1-S_2}{2(S_1+S_2)}$$\n$$\\frac{S_2}{S_1+S_2} - \\frac{1}{2} = \\frac{2S_2 - (S_1+S_2)}{2(S_1+S_2)} = \\frac{S_2-S_1}{2(S_1+S_2)} = -\\frac{S_1-S_2}{2(S_1+S_2)}$$\n将这些代回 $\\Delta$ 的表达式中：\n$$\\Delta = \\left(\\frac{S_1-S_2}{2(S_1+S_2)}\\right) NDVI_1 - \\left(\\frac{S_1-S_2}{2(S_1+S_2)}\\right) NDVI_2$$\n提取公因子得到偏差的最终表达式：\n$$\\Delta = \\frac{S_1-S_2}{2(S_1+S_2)} (NDVI_1 - NDVI_2)$$\n问题要求解释当总反射率 $S_i$ 在 NDVI 较大的时刻也较大时偏差的方向。不失一般性，我们假设 $NDVI_1 > NDVI_2$。条件同样表明 $S_1 > S_2$。在这种情况下，项 $(NDVI_1 - NDVI_2)$ 为正，项 $(S_1-S_2)$ 也为正。由于反射率为非负值，分母 $2(S_1+S_2)$ 为正。因此，偏差 $\\Delta$ 将为正。这意味着，与先计算指数再平均相比，先平均反射率会高估 NDVI。这是因为加权平均给总反射率较高的观测值所对应的 NDVI 值赋予了更大的权重。\n\n最后，我们使用提供的数据计算偏差 $\\Delta$ 的数值：\n$N_1 = 0.7$, $R_1 = 0.05$\n$N_2 = 0.2$, $R_2 = 0.18$\n\n首先，我们计算单个 NDVI 值：\n$$NDVI_1 = f(0.7, 0.05) = \\frac{0.7 - 0.05}{0.7 + 0.05} = \\frac{0.65}{0.75} = \\frac{13}{15}$$\n$$NDVI_2 = f(0.2, 0.18) = \\frac{0.2 - 0.18}{0.2 + 0.18} = \\frac{0.02}{0.38} = \\frac{1}{19}$$\nNDVI 的时间均值为：\n$$\\frac{NDVI_1 + NDVI_2}{2} = \\frac{1}{2} \\left(\\frac{13}{15} + \\frac{1}{19}\\right) = \\frac{1}{2} \\left(\\frac{13 \\times 19 + 15 \\times 1}{15 \\times 19}\\right) = \\frac{1}{2} \\left(\\frac{247 + 15}{285}\\right) = \\frac{262}{570} = \\frac{131}{285}$$\n接下来，我们计算时间平均的反射率：\n$$\\bar{N} = \\frac{0.7 + 0.2}{2} = 0.45$$\n$$\\bar{R} = \\frac{0.05 + 0.18}{2} = \\frac{0.23}{2} = 0.115$$\n现在，我们计算聚合 NDVI：\n$$f(\\bar{N}, \\bar{R}) = \\frac{0.45 - 0.115}{0.45 + 0.115} = \\frac{0.335}{0.565} = \\frac{335}{565} = \\frac{67}{113}$$\n偏差 $\\Delta$ 是这两个值之间的差：\n$$\\Delta = f(\\bar{N}, \\bar{R}) - \\frac{NDVI_1 + NDVI_2}{2} = \\frac{67}{113} - \\frac{131}{285}$$\n为了计算差值，我们找到一个公分母：$113 \\times 285 = 32205$。\n$$\\Delta = \\frac{67 \\times 285 - 131 \\times 113}{32205} = \\frac{19095 - 14803}{32205} = \\frac{4292}{32205}$$\n将此分数转换为小数：\n$$\\Delta \\approx 0.133271231...$$\n四舍五入到 $4$ 位有效数字，我们得到 $\\Delta \\approx 0.1333$。\n这个正偏差与我们的理论分析一致，因为 $NDVI_1 \\approx 0.867$ 大于 $NDVI_2 \\approx 0.053$，并且相应的总反射率 $S_1 = 0.75$ 大于 $S_2 = 0.38$。",
            "answer": "$$\\boxed{0.1333}$$"
        },
        {
            "introduction": "环境时间序列数据（如地表温度）很少是完全独立的；它们通常表现出时间自相关性，即一个时间点的值与其相邻时间点的值相关。这项练习将引导您推导在一个自回归（$AR(1)$）过程中，时间聚合均值的方差与独立同分布样本的方差有何不同。完成这项练习将使您掌握量化自相关对统计不确定性影响的关键技能，这对于任何依赖时间序列数据的环境建模分析都至关重要。",
            "id": "3859623",
            "problem": "一个基于卫星的环境监测系统生成某个生物群系上陆地表面温度的每日网格化异常。对于给定的网格单元，异常时间序列 $\\{X_t\\}_{t \\in \\mathbb{Z}}$ 是二阶平稳的，均值为 $0$，并且由于大气持续性和仪器漂移，其误差结构服从一阶自回归（AR(1)）模型：$X_t = \\phi X_{t-1} + \\varepsilon_t$，其中 $|\\phi|1$，且 $\\{\\varepsilon_t\\}$ 是均值为 $0$、方差为 $\\sigma_{\\varepsilon}^2$ 的独立同分布白噪声。在平稳性条件下，$X_t$ 的边际方差记为 $\\sigma_X^2 = \\operatorname{Var}(X_t)$。\n\n为了减少噪声并与生态过程的尺度对齐，分析师将每日序列聚合为一个连续的 $W$ 天窗口均值，\n$$\n\\bar{X}_W \\equiv \\frac{1}{W} \\sum_{t=1}^{W} X_t.\n$$\n\n仅从方差和协方差的基本定义、AR(1) 模型和平稳性，以及标准的有限几何级数恒等式出发，推导在 AR(1) 时间相关性下，相对于独立样本基准，聚合均值的方差膨胀因子的一个精确的、闭合形式的表达式。具体来说，推导比率\n$$\n\\tau_W(\\phi) \\equiv \\frac{\\operatorname{Var}(\\bar{X}_W \\,\\text{under AR(1) with parameter } \\phi)}{\\sigma_X^2/W},\n$$\n作为 $\\phi$ 和 $W$ 的显式函数。\n\n将你的最终答案表示为关于 $\\phi$ 和 $W$ 的 $\\tau_W(\\phi)$ 的单一闭合形式解析表达式。不需要进行数值计算或四舍五入。最终表达式中不要包含单位。另外，在你的推导过程中，单独报告在 AR(1) 条件下，用 $\\sigma_X^2$、$\\phi$ 和 $W$ 表示的相应方差 $\\operatorname{Var}(\\bar{X}_W)$，并说明它与独立样本情况 $\\sigma_X^2/W$ 的关系。",
            "solution": "用户提供了一个需要进行形式验证的问题陈述。\n\n### 第 1 步：提取已知条件\n-   时间序列为 $\\{X_t\\}_{t \\in \\mathbb{Z}}$。\n-   该序列是二阶平稳的，均值为 $E[X_t] = 0$。\n-   数据生成过程是一阶自回归模型：$X_t = \\phi X_{t-1} + \\varepsilon_t$。\n-   自回归参数满足 $|\\phi|1$。\n-   噪声项 $\\{\\varepsilon_t\\}$ 是独立同分布 (i.i.d.) 的白噪声，均值为 $E[\\varepsilon_t] = 0$，方差为 $\\operatorname{Var}(\\varepsilon_t) = \\sigma_{\\varepsilon}^2$。\n-   序列的边际方差为 $\\sigma_X^2 = \\operatorname{Var}(X_t)$。\n-   聚合均值定义为 $\\bar{X}_W \\equiv \\frac{1}{W} \\sum_{t=1}^{W} X_t$。\n-   待推导的目标量是方差膨胀因子：$\\tau_W(\\phi) \\equiv \\frac{\\operatorname{Var}(\\bar{X}_W \\,\\text{under AR(1) with parameter } \\phi)}{\\sigma_X^2/W}$。\n-   推导必须从方差、协方差的基本定义、AR(1) 模型、平稳性以及标准的有限几何级数恒等式出发。\n\n### 第 2 步：使用提取的已知条件进行验证\n-   **科学依据：** 该问题基于 AR(1) 过程，这是时间序列分析中一个基础且广泛使用的模型，应用于许多 STEM 领域，包括所指定的环境遥感背景。该设定在科学上是合理的。\n-   **适定性：** 该问题在数学上是适定的。它要求在一个完全指定的随机过程下推导一个特定量 $\\tau_W(\\phi)$。条件 $|\\phi|1$ 确保了矩（方差、协方差）定义良好且不随时变所需的平稳性。这保证了唯一稳定解的存在。\n-   **客观性：** 问题陈述使用精确、客观的数学语言编写，没有任何主观或有偏见的措辞。\n-   **不完整或矛盾的设定：** 问题是自洽的。所有必要的变量、定义和约束都已提供。没有内部矛盾。\n-   **不切实际或不可行：** 所描述的情景是时间序列分析在环境科学中的一个标准且现实的应用。所需的推导是研究生水平统计学或计量经济学中的一个常规练习，完全可行。\n-   **不适定或结构不良：** 问题结构清晰且合乎逻辑。它指明了出发点（第一性原理）和期望的终点（$\\tau_W(\\phi)$ 的闭合形式表达式）。\n-   **伪深刻、琐碎或同义反复：** 推导过程并非微不足道。它需要扎实掌握方差和协方差的性质、AR(1) 过程的结构以及级数求和。这代表了一项实质性的概念和数学挑战。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整的推导过程。\n\n目标是推导方差膨胀因子 $\\tau_W(\\phi)$ 的表达式。这需要首先计算样本均值的方差 $\\operatorname{Var}(\\bar{X}_W)$。\n\n样本均值 $\\bar{X}_W$ 的方差由下式给出：\n$$\n\\operatorname{Var}(\\bar{X}_W) = \\operatorname{Var}\\left(\\frac{1}{W} \\sum_{t=1}^{W} X_t\\right) = \\frac{1}{W^2} \\operatorname{Var}\\left(\\sum_{t=1}^{W} X_t\\right)\n$$\n使用随机变量和的方差的一般公式，我们有：\n$$\n\\operatorname{Var}\\left(\\sum_{t=1}^{W} X_t\\right) = \\sum_{t=1}^{W} \\sum_{s=1}^{W} \\operatorname{Cov}(X_t, X_s)\n$$\n由于二阶平稳性，协方差 $\\operatorname{Cov}(X_t, X_s)$ 仅取决于时间滞后 $|t-s|$。我们将自协方差函数定义为 $\\gamma_k = \\operatorname{Cov}(X_t, X_{t-k})$。方差为 $\\gamma_0 = \\operatorname{Var}(X_t) = \\sigma_X^2$。\n\n对于 AR(1) 模型 $X_t = \\phi X_{t-1} + \\varepsilon_t$，当 $k > 0$ 时：\n$$\n\\gamma_k = \\operatorname{Cov}(X_t, X_{t-k}) = E[X_t X_{t-k}] - E[X_t]E[X_{t-k}]\n$$\n由于 $E[X_t] = 0$，我们有 $\\gamma_k = E[X_t X_{t-k}]$。代入 AR(1) 模型：\n$$\n\\gamma_k = E[(\\phi X_{t-1} + \\varepsilon_t) X_{t-k}] = \\phi E[X_{t-1} X_{t-k}] + E[\\varepsilon_t X_{t-k}]\n$$\n对于 $k > 0$，项 $X_{t-k}$ 是截至时间 $t-k$ 的噪声项（即 $\\{\\varepsilon_{t-k}, \\varepsilon_{t-k-1}, \\ldots\\}$）的函数。由于噪声过程 $\\{\\varepsilon_t\\}$ 是独立同分布的，$\\varepsilon_t$ 与 $X_{t-k}$ 独立。因此，$E[\\varepsilon_t X_{t-k}] = E[\\varepsilon_t]E[X_{t-k}] = 0 \\cdot 0 = 0$。\n该表达式简化为一个递推关系：\n$$\n\\gamma_k = \\phi E[X_{t-1} X_{t-k}] = \\phi \\operatorname{Cov}(X_{t-1}, X_{t-k}) = \\phi \\gamma_{k-1}\n$$\n从 $\\gamma_0 = \\sigma_X^2$ 开始求解这个递推关系，得到对于 $k \\ge 0$ 有 $\\gamma_k = \\phi^k \\gamma_0 = \\phi^k \\sigma_X^2$。由于 $\\gamma_k = \\gamma_{-k}$，其一般形式为 $\\gamma_k = \\phi^{|k|} \\sigma_X^2$。\n\n现在我们可以计算这个和的方差的双重求和：\n$$\n\\operatorname{Var}\\left(\\sum_{t=1}^{W} X_t\\right) = \\sum_{t=1}^{W} \\sum_{s=1}^{W} \\sigma_X^2 \\phi^{|t-s|} = \\sigma_X^2 \\sum_{t=1}^{W} \\sum_{s=1}^{W} \\phi^{|t-s|}\n$$\n让我们计算和 $S = \\sum_{t=1}^{W} \\sum_{s=1}^{W} \\phi^{|t-s|}$。我们可以通过对每个 $t$ 分解内层求和来重写它：\n$$\nS = \\sum_{t=1}^{W} \\left( \\sum_{s=1}^{t-1} \\phi^{t-s} + \\phi^{|t-t|} + \\sum_{s=t+1}^{W} \\phi^{s-t} \\right)\n$$\n项 $\\phi^{|t-t|} = \\phi^0 = 1$。第一个内层和是一个几何级数 $\\sum_{k=1}^{t-1} \\phi^k = \\frac{\\phi(1-\\phi^{t-1})}{1-\\phi}$。第二个内层和是 $\\sum_{k=1}^{W-t} \\phi^k = \\frac{\\phi(1-\\phi^{W-t})}{1-\\phi}$。\n对所有 $t$ 求和：\n$$\nS = \\sum_{t=1}^{W} \\left( 1 + \\frac{\\phi(1-\\phi^{t-1})}{1-\\phi} + \\frac{\\phi(1-\\phi^{W-t})}{1-\\phi} \\right)\n$$\n$$\nS = W + \\frac{\\phi}{1-\\phi} \\sum_{t=1}^{W} (1-\\phi^{t-1} + 1-\\phi^{W-t}) = W + \\frac{\\phi}{1-\\phi} \\left( 2W - \\sum_{t=1}^{W}\\phi^{t-1} - \\sum_{t=1}^{W}\\phi^{W-t} \\right)\n$$\n这两个和是相同的级数，只是索引相反。在第一个和中令 $k=t-1$，在第二个和中令 $k=W-t$，两个和都等于 $\\sum_{k=0}^{W-1} \\phi^k = \\frac{1-\\phi^W}{1-\\phi}$。\n$$\nS = W + \\frac{\\phi}{1-\\phi} \\left( 2W - 2 \\frac{1-\\phi^W}{1-\\phi} \\right)\n$$\n为了简化，我们通分，分母为 $(1-\\phi)^2$：\n$$\nS = \\frac{W(1-\\phi)^2 + 2W\\phi(1-\\phi) - 2\\phi(1-\\phi^W)}{(1-\\phi)^2}\n$$\n$$\nS = \\frac{W(1-2\\phi+\\phi^2) + 2W\\phi - 2W\\phi^2 - 2\\phi + 2\\phi^{W+1}}{(1-\\phi)^2}\n$$\n$$\nS = \\frac{W - 2W\\phi + W\\phi^2 + 2W\\phi - 2W\\phi^2 - 2\\phi + 2\\phi^{W+1}}{(1-\\phi)^2}\n$$\n$$\nS = \\frac{W - W\\phi^2 - 2\\phi + 2\\phi^{W+1}}{(1-\\phi)^2} = \\frac{W(1-\\phi^2) - 2\\phi(1-\\phi^W)}{(1-\\phi)^2}\n$$\n因此，样本均值的方差由下式给出：\n$$\n\\operatorname{Var}(\\bar{X}_W) = \\frac{1}{W^2} \\operatorname{Var}\\left(\\sum_{t=1}^{W} X_t\\right) = \\frac{\\sigma_X^2}{W^2} S = \\frac{\\sigma_X^2}{W^2} \\left[ \\frac{W(1-\\phi^2) - 2\\phi(1-\\phi^W)}{(1-\\phi)^2} \\right]\n$$\n这就是在 AR(1) 相关性下聚合均值的方差的所求表达式。\n\n作为比较，如果样本是独立的（基准情况），则均值的方差将是 $\\operatorname{Var}(\\bar{X}_W)_{\\text{indep}} = \\frac{1}{W^2} \\sum_{t=1}^{W} \\operatorname{Var}(X_t) = \\frac{1}{W^2} (W\\sigma_X^2) = \\frac{\\sigma_X^2}{W}$。这与 $\\tau_W(\\phi)$ 定义中的分母相匹配。\n\n最后，我们通过取比率来推导方差膨胀因子 $\\tau_W(\\phi)$：\n$$\n\\tau_W(\\phi) = \\frac{\\operatorname{Var}(\\bar{X}_W)}{\\sigma_X^2/W} = \\frac{\\frac{\\sigma_X^2}{W^2} \\left[ \\frac{W(1-\\phi^2) - 2\\phi(1-\\phi^W)}{(1-\\phi)^2} \\right]}{\\frac{\\sigma_X^2}{W}}\n$$\n消去公因子 $\\frac{\\sigma_X^2}{W}$：\n$$\n\\tau_W(\\phi) = \\frac{1}{W} \\left[ \\frac{W(1-\\phi^2) - 2\\phi(1-\\phi^W)}{(1-\\phi)^2} \\right]\n$$\n为了清晰起见，可以重新整理这个表达式：\n$$\n\\tau_W(\\phi) = \\frac{W(1-\\phi)(1+\\phi) - 2\\phi(1-\\phi^W)}{W(1-\\phi)^2} = \\frac{1+\\phi}{1-\\phi} - \\frac{2\\phi(1-\\phi^W)}{W(1-\\phi)^2}\n$$\n这个最终结果提供了方差膨胀因子的精确闭合形式表达式，它是自回归参数 $\\phi$ 和窗口大小 $W$ 的函数。",
            "answer": "$$\n\\boxed{\\frac{1+\\phi}{1-\\phi} - \\frac{2\\phi(1-\\phi^W)}{W(1-\\phi)^2}}\n$$"
        },
        {
            "introduction": "我们对环境过程之间关系的理解，例如降雨与植被生长之间的滞后关系，可能严重依赖于我们选择的分析时间尺度。这种现象被称为“可变时间单元问题”（Modifiable Temporal Unit Problem, MTUP）。这项动手编程练习旨在通过模拟来具体展示MTUP的影响。您将生成具有已知滞后时间的合成时间序列，在不同时间尺度（每日、8天、30天）上对其进行聚合，并观察估计的滞后时间如何随聚合窗口的变化而变化。这项实践将使您对时间尺度选择在环境分析中的关键作用有直观的认识，并培养您在处理多尺度数据时进行批判性思考的能力。",
            "id": "3859639",
            "problem": "要求您设计并实现一个仿真，以量化遥感和环境建模中两个时间序列之间滞后估计的可变时间单元问题（MTUP）。MTUP 关注的是估计关系对时间聚合窗口选择的敏感性。您必须生成一个基础日时间序列及其滞后对应序列，在不同的区间大小下对两者进行聚合，然后在每种聚合方案下估计滞后，并与已知的真实滞后进行比较。\n\n从基本原理出发，使用以下数学基础：\n\n1. 定义一个离散时间日信号 $\\{x_t\\}$，其中整数日索引 $t \\in \\{0,1,\\dots,T-1\\}$，$T$ 是总天数。令 $x_t$ 由确定性季节性分量和随机噪声组成，即\n$$\nx_t = s_t + \\epsilon_t,\n$$\n其中 $s_t$ 是一个平滑的季节性函数，$\\epsilon_t$ 是独立同分布 (i.i.d.) 的零均值有限方差噪声。\n\n2. 将滞后信号 $\\{y_t\\}$ 定义为 $\\{x_t\\}$ 的一个经过缩放和时移并附加了噪声的版本：\n$$\ny_t = \\gamma \\, x_{t-\\ell} + \\eta_t,\n$$\n其中 $\\gamma > 0$ 是一个缩放因子，$\\ell$ 是以天为单位的真实整数滞后，$\\eta_t$ 是独立于 $\\epsilon_t$ 的独立同分布零均值噪声。为避免未定义的索引，当 $t-\\ell  0$ 时，将 $x_{t-\\ell}$ 解释为零。\n\n3. 定义一个宽度为 $\\Delta$ 天的非重叠时间聚合算子 $A_{\\Delta}(\\cdot)$，它通过在区间内取平均将日序列映射到聚合序列：\n$$\nA_{\\Delta}(z)_k = \\frac{1}{\\Delta} \\sum_{t=k\\Delta}^{(k+1)\\Delta-1} z_t,\n$$\n其中整数区间索引 $k \\in \\{0,1,\\dots,K-1\\}$ 且 $K = \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$。\n\n4. 对于两个聚合离散序列 $\\{u_k\\}$ 和 $\\{v_k\\}$，将整数区间滞后 $h$ 处的样本互相关定义为\n$$\n\\widehat{\\rho}_{uv}(h) = \\frac{\\sum_{k} \\left(u_k - \\overline{u}\\right)\\left(v_{k+h} - \\overline{v}\\right)}{\\sqrt{\\sum_{k} \\left(u_k - \\overline{u}\\right)^2} \\, \\sqrt{\\sum_{k} \\left(v_{k+h} - \\overline{v}\\right)^2}},\n$$\n其中求和是针对使 $u_k$ 和 $v_{k+h}$ 都有定义的索引 $k$ 进行的，$\\overline{u}$ 和 $\\overline{v}$ 是在这些对齐索引上的样本均值。以区间为单位的估计滞后 $\\hat{h}$ 是在搜索范围 $\\{-H,-H+1,\\dots,H\\}$ 内使 $\\widehat{\\rho}_{uv}(h)$ 最大化的参数。则以天为单位的估计滞后为 $\\widehat{\\ell} = \\Delta \\cdot \\hat{h}$。\n\n科学真实性和约束条件：\n\n- 使用一个对于环境信号而言平滑且真实的季节性分量 $s_t$，例如正弦年周期。选择 $s_t = A \\sin\\left(\\frac{2\\pi t}{P}\\right)$，其中 $A$ 为振幅，$P$ 为以天为单位的周期。\n- 对 $\\epsilon_t$ 和 $\\eta_t$ 使用具有指定标准差的独立同分布高斯噪声。\n- 对区间大小 $\\Delta \\in \\{1,8,30\\}$ 使用上述聚合算子，分别对应于每日 ($\\Delta = 1$)、8日和30日合成数据。为简单和精确起见，此处将“月度”区间视为固定宽度为 $\\Delta = 30$ 天的窗口。\n- 通过最大化整数区间滞后上的样本互相关来估计滞后。相关性计算必须严格对齐具有有效重叠的索引。\n\n您的程序必须：\n\n- 实现针对给定参数的 $\\{x_t\\}$ 和 $\\{y_t\\}$ 的生成。\n- 使用 $A_{\\Delta}$ 对两个序列进行聚合，其中 $\\Delta \\in \\{1,8,30\\}$。\n- 在每个 $\\Delta$ 下，通过在 $h \\in \\{-H,\\dots,H\\}$ 上最大化 $\\widehat{\\rho}_{uv}(h)$ 来估计以天为单位的滞后 $\\widehat{\\ell}$，其中 $H$ 是以区间为单位的最大滞后，其选择是为了覆盖 $H_{\\text{days}}$ 天的最大滞后量值。使用 $H_{\\text{days}} = 60$ 天。\n- 为保证可复现性，使用固定的随机种子。\n- 以整数形式返回以天为单位的估计滞后。\n\n单位和输出格式：\n\n- 所有滞后量必须以天为单位表示，并且您的最终结果必须是天为单位的整数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下面的测试套件中所指定。对于每个测试用例，报告 $\\Delta = 1$、$\\Delta = 8$ 和 $\\Delta = 30$ 的估计滞后，并将它们展平到一个列表中。\n\n测试套件：\n\n使用以下参数集来测试不同方面（正常路径、边界情况、边缘情况）。在所有情况下，使用正弦波 $s_t = A \\sin\\left(\\frac{2\\pi t}{P}\\right)$，其中 $A = 1$，$P = 365$，且 $\\gamma = 1$。对于每个情况，指定 $(T,\\ell,\\sigma_x,\\sigma_y)$，其中 $T$ 是以天为单位的序列长度，$\\ell$ 是以天为单位的真实滞后，$\\sigma_x$ 是 $\\epsilon_t$ 的标准差，$\\sigma_y$ 是 $\\eta_t$ 的标准差：\n\n- 情况 1：$(T = 365, \\ell = 5, \\sigma_x = 0.3, \\sigma_y = 0.3)$。\n- 情况 2：$(T = 365, \\ell = 9, \\sigma_x = 0.5, \\sigma_y = 0.8)$。\n- 情况 3：$(T = 365, \\ell = 29, \\sigma_x = 0.4, \\sigma_y = 0.4)$。\n- 情况 4：$(T = 365, \\ell = 0, \\sigma_x = 0.6, \\sigma_y = 0.6)$。\n- 情况 5：$(T = 120, \\ell = 14, \\sigma_x = 0.8, \\sigma_y = 1.0)$。\n\n搜索范围：\n\n- 使用 $H_{\\text{days}} = 60$ 天作为要搜索的最大绝对滞后天数，这意味着对于每个 $\\Delta$，最大区间滞后为 $H_{\\Delta} = \\left\\lfloor \\frac{60}{\\Delta} \\right\\rfloor$。\n\n最终输出规范：\n\n- 您的程序应生成单行输出，其中包含所有测试用例（按情况1到5的顺序）的估计滞后（以天为单位的整数），每个用例内的三种聚合方案按 $\\Delta = 1$、$\\Delta = 8$、$\\Delta = 30$ 的顺序排列。最终输出必须格式化为单个 Python 列表字面量，例如 $[\\widehat{\\ell}_{1,1},\\widehat{\\ell}_{1,8},\\widehat{\\ell}_{1,30},\\dots,\\widehat{\\ell}_{5,30}]$，其中 $\\widehat{\\ell}_{i,\\Delta}$ 表示情况 $i$ 在区间大小为 $\\Delta$ 时的估计滞后。",
            "solution": "我们首先对数据生成过程和估计方法进行形式化，然后解释时间聚合如何在滞后估计中引起可变时间单元问题（MTUP）。\n\n基于基本原理的数据生成：\n\n1. 一个真实的环境信号通常具有强烈的季节性周期。我们将每日基础序列 $\\{x_t\\}$ 定义为\n$$\nx_t = s_t + \\epsilon_t, \\quad s_t = A \\sin\\left(\\frac{2\\pi t}{P}\\right),\n$$\n其中振幅 $A = 1$，周期 $P = 365$ 天。噪声项 $\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_x^2)$ 是独立同分布的高斯噪声。这种构造捕捉了环境信号一个经过充分检验的特性：平滑的季节性加上随机变率。\n\n2. 配对序列 $\\{y_t\\}$ 被构造为 $\\{x_t\\}$ 的一个经过缩放、时移并加上独立噪声的版本：\n$$\ny_t = \\gamma \\, x_{t - \\ell} + \\eta_t,\n$$\n其中 $\\gamma = 1$，且 $\\eta_t \\sim \\mathcal{N}(0,\\sigma_y^2)$ 独立于 $\\epsilon_t$。对于索引 $t - \\ell  0$ 的情况，我们取 $x_{t - \\ell} = 0$ 以避免未定义引用，这实际上会引入一个瞬态边缘效应，当 $T \\gg \\ell$ 时，该效应相对于整个序列来说很小。\n\n作为算子的时间聚合：\n\n3. 在 $\\Delta$ 天的非重叠区间上的聚合是算子\n$$\nA_{\\Delta}(z)_k = \\frac{1}{\\Delta} \\sum_{t=k\\Delta}^{(k+1)\\Delta-1} z_t,\n$$\n这等效于与宽度为 $\\Delta$ 的矩形核（boxcar）进行离散卷积，然后进行抽取。用信号处理的术语来说，这是一种低通滤波，它会衰减高频分量并减少方差。\n\n通过互相关进行滞后估计：\n\n4. 对于聚合序列 $\\{u_k\\}$ 和 $\\{v_k\\}$，在区间滞后 $h$ 处的样本互相关为\n$$\n\\widehat{\\rho}_{uv}(h) = \\frac{\\sum_{k} \\left(u_k - \\overline{u}\\right)\\left(v_{k+h} - \\overline{v}\\right)}{\\sqrt{\\sum_{k} \\left(u_k - \\overline{u}\\right)^2} \\, \\sqrt{\\sum_{k} \\left(v_{k+h} - \\overline{v}\\right)^2}}.\n$$\n我们通过\n$$\n\\hat{h} = \\arg\\max_{h \\in \\{-H,\\dots,H\\}} \\; \\widehat{\\rho}_{uv}(h),\n$$\n来估计滞后，然后转换为天数 $\\widehat{\\ell} = \\Delta \\cdot \\hat{h}$。以区间为单位的搜索半宽度 $H$ 是通过以天为单位的最大滞后 $H_{\\text{days}}$ 来选择的，具体为 $H = \\left\\lfloor \\frac{H_{\\text{days}}}{\\Delta} \\right\\rfloor$。\n\n聚合如何影响滞后估计（MTUP）：\n\n5. 聚合算子 $A_{\\Delta}$ 可以表示为与一个矩形窗 $w_{\\Delta}(t)$ 的卷积，\n$$\nw_{\\Delta}(t) = \\begin{cases}\n\\frac{1}{\\Delta},  t \\in \\{0,1,\\dots,\\Delta-1\\},\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n因此，在区间索引 $k$ 处计算的 $A_{\\Delta}(x)$ 实质上是在 $t = k\\Delta + (\\Delta - 1)/2$ 处采样的 $(x * w_{\\Delta})(t)$（不考虑整数舍入）。在相关域中，聚合信号的互相关与原始信号的互相关和 $w_{\\Delta}$ 的自相关进行卷积有关。这种平滑作用可以使相关峰变得平坦，并且与抽取（分箱）相结合，将可检测的滞后量化为 $\\Delta$ 的整数倍。当真实滞后 $\\ell$ 不是 $\\Delta$ 的整数倍时，在聚合分辨率下的估计滞后通常是与 $\\ell$ 最接近的 $\\Delta$ 的倍数 $\\Delta \\cdot \\hat{h}$，假设信噪比足够高，其量化误差的界限约为 $\\Delta/2$ 天。更高的噪声会进一步扰动峰值位置，有时会偏向于较小的绝对滞后，或者偏好具有更多重叠的区间。\n\n算法设计：\n\n6. 对于每个测试用例 $(T,\\ell,\\sigma_x,\\sigma_y)$：\n- 生成 $t = 0,\\dots,T-1$ 的序列 $\\{x_t\\}$，其中 $A = 1$，$P = 365$：\n$$\nx_t = \\sin\\left(\\frac{2\\pi t}{365}\\right) + \\epsilon_t, \\quad \\epsilon_t \\sim \\mathcal{N}(0,\\sigma_x^2).\n$$\n- 生成 $\\{y_t\\}$：\n$$\ny_t = x_{t - \\ell} + \\eta_t, \\quad \\eta_t \\sim \\mathcal{N}(0,\\sigma_y^2), \\quad x_{t-\\ell} = 0 \\; \\text{if} \\; t - \\ell  0.\n$$\n- 对于每个 $\\Delta \\in \\{1,8,30\\}$，计算聚合序列 $u_k = A_{\\Delta}(x)_k$ 和 $v_k = A_{\\Delta}(y)_k$，其中 $k = 0,\\dots,K-1$，$K = \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$。\n- 通过在 $h \\in \\{-H,\\dots,H\\}$ 上最大化 $\\widehat{\\rho}_{uv}(h)$ 来估计 $\\hat{h}$，其中 $H = \\left\\lfloor \\frac{60}{\\Delta} \\right\\rfloor$。正确对齐索引：对于给定的 $h$，定义重叠索引集，使得 $u_k$ 和 $v_{k+h}$ 都存在，然后使用这些对齐的样本计算相关性。如果任一对齐的子序列方差为零，则将该 $h$ 的相关性设置为 $0$。\n- 报告 $\\widehat{\\ell} = \\Delta \\cdot \\hat{h}$ 为以天为单位的整数。\n\n测试套件的覆盖理由：\n\n- 情况 1（$\\ell = 5$ 天）测试了一个相对于 $\\Delta = 8$ 和 $\\Delta = 30$ 而言较小的滞后。在这种情况下，如果噪声占主导，量化可能导致高达 4 或 15 天的误差，但在中等噪声下，对于日尺度应能恢复 $\\widehat{\\ell} \\approx 5$，对于 8 天区间应能恢复 $\\widehat{\\ell} \\approx 8$。\n- 情况 2（$\\ell = 9$ 天）测试了一个接近但不等于 8 天的滞后，用以说明来自 $\\Delta = 8$ 区间的量化偏差以及在 $\\Delta = 30$ 区间下更大的偏差。\n- 情况 3（$\\ell = 29$ 天）探究了近月尺度的滞后，其中 $\\Delta = 30$ 的区间可能报告 $\\widehat{\\ell} \\approx 30$，显示出近似量化效应。\n- 情况 4（$\\ell = 0$ 天）是一个边界情况，确保估计器在存在噪声的情况下，在各种聚合尺度上都能检测到零滞后。\n- 情况 5（$T = 120$，$\\ell = 14$ 天，更高噪声）是一个短且噪声大的序列，它对估计器施加了压力，并展示了聚合在方差减少与分辨率损失之间的权衡。\n\n实现细节：\n\n- 使用固定的随机种子以确保可复现性。\n- 通过在非重叠窗口上取简单平均值来计算聚合。\n- 通过显式对齐和标准化协方差计算样本互相关。\n- 通过乘以 $\\Delta$ 将区间滞后转换为天数，并返回整数值。\n\n最终程序将处理所有五个情况，并按情况顺序打印一个包含 15 个整数的 Python 列表，这些整数对应于 $\\Delta = 1$、$\\Delta = 8$ 和 $\\Delta = 30$ 的估计滞后。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_series(T, lag_days, sigma_x, sigma_y, A=1.0, P=365, gamma=1.0, rng=None):\n    \"\"\"\n    Generate x_t and y_t daily series.\n    x_t = A * sin(2*pi*t / P) + epsilon_t\n    y_t = gamma * x_{t - lag_days} + eta_t, with x_{t - lag_days} = 0 if t - lag_days  0\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng(0)\n    t = np.arange(T, dtype=int)\n    seasonal = A * np.sin(2.0 * np.pi * t / P)\n    epsilon = rng.normal(loc=0.0, scale=sigma_x, size=T)\n    x = seasonal + epsilon\n    # Shifted version for y; zero-pad the left side\n    y = np.empty(T, dtype=float)\n    y[:] = 0.0\n    if lag_days >= 0:\n        # y[t] = gamma * x[t - lag_days] + eta[t] if t - lag_days >= 0 else eta[t]\n        eta = rng.normal(loc=0.0, scale=sigma_y, size=T)\n        for tt in range(T):\n            xt_shift = x[tt - lag_days] if (tt - lag_days) >= 0 else 0.0\n            y[tt] = gamma * xt_shift + eta[tt]\n    else:\n        # Negative lag: y leads x, i.e., x is shifted forward\n        # y[t] = gamma * x[t - lag_days] + eta[t], with t - lag_days always >= 0 for lag_days  0 sufficiently small\n        # Still safe to implement same as above.\n        eta = rng.normal(loc=0.0, scale=sigma_y, size=T)\n        for tt in range(T):\n            xt_shift = x[tt - lag_days] if (tt - lag_days)  T else 0.0\n            y[tt] = gamma * xt_shift + eta[tt]\n    return x, y\n\ndef aggregate_nonoverlapping(z, delta):\n    \"\"\"\n    Aggregate daily series z into non-overlapping windows of size delta via mean.\n    Returns aggregated series u and number of bins K.\n    \"\"\"\n    T = len(z)\n    K = T // delta\n    if K == 0:\n        return np.array([], dtype=float)\n    reshaped = z[:K*delta].reshape(K, delta)\n    return reshaped.mean(axis=1)\n\ndef estimate_lag_days(u, v, delta, H_days):\n    \"\"\"\n    Estimate lag by maximizing sample cross-correlation between aggregated series u and v.\n    u and v are arrays defined on bin indices k.\n    delta is bin size in days. H_days is maximum absolute lag in days.\n    Returns lag estimate in days (integer).\n    \"\"\"\n    # Compute maximum lag in bins\n    H_bins = int(H_days // delta)\n    n = min(len(u), len(v))\n    if n == 0:\n        return 0\n    # For robustness in short series, limit H_bins to n-2\n    H_bins = min(H_bins, max(0, n - 2))\n    best_h = 0\n    best_r = -np.inf\n    # Iterate over integer bin lags h in [-H_bins, H_bins]\n    for h in range(-H_bins, H_bins + 1):\n        if h >= 0:\n            u_sub = u[:n - h]\n            v_sub = v[h:n]\n        else:\n            u_sub = u[-h:n]\n            v_sub = v[:n + h]\n        # Compute Pearson correlation if variances are non-zero\n        if len(u_sub)  2 or len(v_sub)  2:\n            r = -np.inf\n        else:\n            u_centered = u_sub - np.mean(u_sub)\n            v_centered = v_sub - np.mean(v_sub)\n            su = np.sqrt(np.sum(u_centered ** 2))\n            sv = np.sqrt(np.sum(v_centered ** 2))\n            if su == 0.0 or sv == 0.0:\n                r = 0.0 # Set to 0 if one series is flat, cannot be max unless all are\n            else:\n                r = np.sum(u_centered * v_centered) / (su * sv)\n        # Choose the lag with maximum correlation; tie-breaker prefers smaller |h|\n        if r > best_r:\n            best_r = r\n            best_h = h\n        elif r == best_r and abs(h)  abs(best_h):\n            best_h = h\n\n    # Convert lag in bins to days\n    return int(best_h * delta)\n\ndef solve():\n    # Fixed RNG seed for reproducibility across all test cases\n    rng = np.random.default_rng(12345)\n\n    # Define the test cases from the problem statement.\n    # Each case: (T, lag_days, sigma_x, sigma_y)\n    test_cases = [\n        (365, 5, 0.3, 0.3),   # Case 1\n        (365, 9, 0.5, 0.8),   # Case 2\n        (365, 29, 0.4, 0.4),  # Case 3\n        (365, 0, 0.6, 0.6),   # Case 4\n        (120, 14, 0.8, 1.0),  # Case 5\n    ]\n\n    deltas = [1, 8, 30]  # daily, 8-day, 30-day bins\n    H_days = 60\n\n    results = []\n    for T, lag_days, sigma_x, sigma_y in test_cases:\n        # Generate series\n        x, y = generate_series(T=T, lag_days=lag_days, sigma_x=sigma_x, sigma_y=sigma_y, rng=rng)\n        # For each aggregation regime, estimate lag\n        for delta in deltas:\n            u = aggregate_nonoverlapping(x, delta)\n            v = aggregate_nonoverlapping(y, delta)\n            est = estimate_lag_days(u, v, delta, H_days)\n            results.append(est)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}