{
    "hands_on_practices": [
        {
            "introduction": "We begin with the fundamental physics governing how information propagates in transport models, which directly dictates how we can apply boundary conditions. This exercise uses the linear advection equation, $u_t + c u_x = 0$, to explore the concept of characteristics. By tracing information flow along these characteristic curves, you will understand precisely why boundary conditions are required at inflow boundaries but are impermissible at outflow boundaries, a crucial principle for setting up physically consistent simulations .",
            "id": "3828052",
            "problem": "A one-dimensional passive tracer field $u(x,t)$ evolving along a straight coastline segment of length $L$ is modeled by the linear advection equation $u_t + c\\,u_x = 0$ on the space-time domain $x \\in [0,L]$, $t \\ge 0$. The constant alongshore current speed $c$ is known from in situ current meters, and a satellite-derived time series provides a boundary forcing at the up-current end of the segment. In the context of hyperbolic partial differential equations used for environmental modeling and remote sensing data assimilation, model forcing is imposed at boundaries through the appropriate characteristic variables, which for a scalar advection equation coincide with the Riemann invariant(s).\n\nStarting from the conservation-law form and basic definitions, derive the correct boundary condition to impose at an inflow boundary by identifying and prescribing the incoming Riemann invariant. Justify, using the characteristic structure and domain of dependence, why no boundary condition is needed at the outflow boundary.\n\nThen, consider the specific case $L = 3000\\ \\mathrm{m}$, $c = 1.5\\ \\mathrm{m\\,s^{-1}}$, initial condition $u(x,0) = \\exp\\!\\big(-\\frac{(x-600\\ \\mathrm{m})^2}{2\\,(150\\ \\mathrm{m})^2}\\big)$ for $x \\in [0,L]$, and boundary forcing at the inflow boundary $x=0$ given by $u(0,t) = 2\\cos\\!\\big(\\frac{\\pi}{400}\\,t\\big)$ for $t \\ge 0$. Treat $u$ as nondimensional. Evaluate $u$ at the query point $(x^\\ast,t^\\ast) = (1800\\ \\mathrm{m}, 2000\\ \\mathrm{s})$.\n\nProvide the final value of $u(x^\\ast,t^\\ast)$ as a pure number with no units. If you decide to approximate, round to four significant figures.",
            "solution": "The problem statement is scientifically grounded, well-posed, and objective. It describes a standard initial-boundary value problem for the one-dimensional linear advection equation, a fundamental model in transport phenomena. All parameters and functions are clearly defined and consistent. We may therefore proceed with a full solution.\n\nThe problem is divided into two parts: a general theoretical derivation concerning boundary conditions for hyperbolic equations, and a specific calculation based on given data.\n\n**Part 1: General Theory of Boundary Conditions and Characteristics**\n\nThe governing partial differential equation (PDE) for the passive tracer concentration $u(x,t)$ is the linear advection equation:\n$$u_t + c\\,u_x = 0$$\nwhere $u_t = \\frac{\\partial u}{\\partial t}$ and $u_x = \\frac{\\partial u}{\\partial x}$. This is a first-order hyperbolic PDE. The behavior of such equations is governed by the propagation of information along characteristic curves.\n\nA characteristic curve is a path in the $(x,t)$ plane along which the PDE can be reduced to an ordinary differential equation (ODE). If we parameterize a curve by $s$ as $(x(s), t(s))$, the total derivative of $u$ along this curve is:\n$$\\frac{du}{ds} = \\frac{\\partial u}{\\partial t}\\frac{dt}{ds} + \\frac{\\partial u}{\\partial x}\\frac{dx}{ds}$$\nComparing this to the PDE, we can choose the characteristic equations as:\n$$\\frac{dt}{ds} = 1, \\quad \\frac{dx}{ds} = c, \\quad \\frac{du}{ds} = 0$$\nFrom the first two equations, we find the slope of the characteristic curves in the $(x,t)$ plane:\n$$\\frac{dx}{dt} = c$$\nSince $c$ is a constant, these curves are straight lines. Integrating this equation yields:\n$$x - ct = k$$\nwhere $k$ is a constant that labels each individual characteristic line. The third characteristic equation, $\\frac{du}{ds} = 0$, implies that the solution $u$ is constant along these characteristic lines. Thus, information, represented by the value of $u$, propagates along these lines.\n\nFor hyperbolic systems, a Riemann invariant is a quantity that remains constant along a characteristic curve. For the scalar advection equation, the solution $u$ itself is the only Riemann invariant.\n\nThe specification of boundary conditions depends on the direction of information propagation relative to the domain boundaries. The problem states $c$ is a positive constant, representing an alongshore current. We can thus assume $c > 0$ without loss of generality. This means that the characteristics $x = ct + k$ have a positive slope in the $(t,x)$ plane (or $1/c$ in the $(x,t)$ plane), indicating that information propagates in the direction of increasing $x$.\n\nConsider the spatial domain $x \\in [0,L]$.\n1.  **Inflow Boundary ($x=0$):** At this boundary, the characteristic lines $x = c(t-t_0)$ (originating at $(0, t_0)$) enter the domain. The value of $u$ along any such characteristic is determined by its value at the point where it enters the domain. To solve the problem within the domain, the value of $u$ must be specified at this boundary for all $t > 0$. This is physically equivalent to knowing the concentration of the tracer being carried into the domain by the current. Therefore, a boundary condition of the form $u(0,t) = g(t)$ is required. This act of prescribing $u(0,t)$ is precisely the prescription of the incoming Riemann invariant ($u$) at the inflow boundary.\n\n2.  **Outflow Boundary ($x=L$):** At this boundary, the characteristics exit the domain. The domain of dependence for any point $(x,t)$ in the interior of the domain consists of the single point on the boundary from which its characteristic originates. For $c > 0$, this origin point is always at a location $x_0 \\le x$ and time $t_0 \\le t$. Specifically, the characteristic through any point $(x,t)$ traces back to either the initial line ($t=0$ at a point $x_0 = x - ct > 0$) or the inflow boundary ($x=0$ at a time $t_0 = t - x/c > 0$). In neither case does the domain of dependence include the outflow boundary at $x=L$. The value of $u$ at the outflow boundary is determined by the values that have propagated from within the domain. Imposing a condition at $x=L$ would be an attempt to specify a value that is already determined, which would in general over-constrain the system and lead to a non-existent or discontinuous solution. Thus, no boundary condition is needed or permitted at the outflow boundary.\n\n**Part 2: Specific Calculation**\n\nWe are given the following specific case:\n-   Length of segment: $L = 3000 \\ \\mathrm{m}$\n-   Current speed: $c = 1.5 \\ \\mathrm{m\\,s^{-1}}$\n-   Initial condition: $u(x,0) = \\exp\\left(-\\frac{(x-600)^2}{2 \\cdot 150^2}\\right)$ for $x \\in [0, 3000]$\n-   Boundary condition at inflow ($x=0$): $u(0,t) = 2\\cos\\left(\\frac{\\pi}{400}t\\right)$ for $t \\ge 0$\n-   Query point: $(x^\\ast, t^\\ast) = (1800 \\ \\mathrm{m}, 2000 \\ \\mathrm{s})$\n\nWe need to find the value of $u(x^\\ast, t^\\ast)$. As established, the value of $u$ is constant along the characteristic line passing through the point $(x^\\ast, t^\\ast)$. The equation of this characteristic is given by $x - ct = k$, where the constant $k$ is determined by the query point:\n$$k = x^\\ast - c t^\\ast = 1800 - (1.5)(2000) = 1800 - 3000 = -1200$$\nSo, the characteristic line is $x - 1.5t = -1200$.\n\nTo find the value of $u$ on this line, we must trace it back to its origin on the boundary of the solution domain (i.e., where $t=0$ or $x=0$).\n-   Intersection with the initial line ($t=0$):\n    $$x - 1.5(0) = -1200 \\implies x = -1200 \\ \\mathrm{m}$$\n    This point is outside the spatial domain $x \\in [0, 3000]$, so the value at the query point is not determined by the initial condition.\n\n-   Intersection with the inflow boundary ($x=0$):\n    $$0 - 1.5t = -1200 \\implies 1.5t = 1200 \\implies t = \\frac{1200}{1.5} = 800 \\ \\mathrm{s}$$\n    The intersection point is $(0, 800)$. This point is on the inflow boundary where the boundary condition is specified.\n\nSince the value of $u$ is conserved along the characteristic, the value at the query point $(1800, 2000)$ must be the same as the value at the boundary point $(0, 800)$.\n$$u(1800, 2000) = u(0, 800)$$\nWe use the given boundary forcing function $u(0,t) = 2\\cos\\left(\\frac{\\pi}{400}t\\right)$ and evaluate it at $t = 800$:\n$$u(0, 800) = 2\\cos\\left(\\frac{\\pi}{400} \\cdot 800\\right) = 2\\cos(2\\pi)$$\nThe cosine of $2\\pi$ is $1$. Therefore:\n$$u(1800, 2000) = 2 \\times 1 = 2$$\nThe value of the tracer field at the specified point and time is exactly $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "With the physical principles established, we turn to the practical details of numerical implementation within a finite difference framework. This practice focuses on the diffusion equation, $u_t = D u_{xx}$, a classic parabolic model, and introduces the versatile \"ghost cell\" method for applying both Dirichlet (prescribed value) and Neumann (prescribed gradient) conditions . You will also engage in the essential scientific practice of code verification by using a manufactured solution to confirm that your numerical boundary treatment achieves the expected order of accuracy.",
            "id": "3828127",
            "problem": "Consider the one-dimensional heat equation (a linear parabolic Partial Differential Equation (PDE)) on the domain $[0,L]$ with constant diffusivity $D$ given by $u_t = D\\,u_{xx}$. In environmental modeling, boundary conditions represent model forcing at the domain boundary (for example, surface temperature from remote sensing for Dirichlet, or surface flux from an energy balance for Neumann). You must implement second-order Finite Difference (FD) spatial discretization of $u_{xx}$ and enforce boundary conditions using ghost cells. Then, derive and verify the truncation error at the boundary nodes using a manufactured, smooth, dimensionless analytic solution $u(x)$.\n\nYou will use the semi-discrete spatial operator (discrete Laplacian) defined by the standard second-order central difference at grid node $i$:\n$$\n\\mathcal{L}_h[u]_i \\equiv \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\nwith a uniform grid $x_i = i\\,\\Delta x$, $i=0,1,\\dots,N$, and $\\Delta x = L/N$. For boundary handling, use ghost cells at $i=-1$ and $i=N+1$ that encode the boundary conditions.\n\nBoundary condition implementations with ghost cells:\n- Dirichlet at $x=0$: $u(0,t) = g_L(t)$. For evaluating $\\mathcal{L}_h$ at interior nodes, use the exact boundary value $u_0 = g_L(t)$; no ghost cell is required to evaluate $\\mathcal{L}_h$ at $i=1$. Similarly, Dirichlet at $x=L$: $u(L,t) = g_R(t)$ implies $u_N = g_R(t)$; no ghost is required to evaluate $\\mathcal{L}_h$ at $i=N-1$.\n- Neumann at $x=0$: $u_x(0,t) = q_L(t)$. Enforce this with a second-order central derivative using a left ghost cell:\n$$\n\\frac{u_1 - u_{-1}}{2\\,\\Delta x} = q_L(t) \\quad \\Rightarrow \\quad u_{-1} = u_1 - 2\\,\\Delta x\\,q_L(t).\n$$\nUse this $u_{-1}$ to evaluate $\\mathcal{L}_h$ at the boundary node $i=0$.\n- Neumann at $x=L$: $u_x(L,t) = q_R(t)$. Enforce this with a right ghost cell:\n$$\n\\frac{u_{N+1} - u_{N-1}}{2\\,\\Delta x} = q_R(t) \\quad \\Rightarrow \\quad u_{N+1} = u_{N-1} + 2\\,\\Delta x\\,q_R(t).\n$$\nUse this $u_{N+1}$ to evaluate $\\mathcal{L}_h$ at the boundary node $i=N$.\n\nManufactured analytic solution for verification (dimensionless):\n$$\nu(x) = e^{x} + \\sin(2x), \\quad u_x(x) = e^{x} + 2\\cos(2x), \\quad u_{xx}(x) = e^{x} - 4\\sin(2x).\n$$\nThis defines boundary forcing consistently: for Dirichlet, $g_L(t) = u(0)$ or $g_R(t) = u(L)$; for Neumann, $q_L(t) = u_x(0)$ or $q_R(t) = u_x(L)$.\n\nGoal: For each specified boundary scenario, compute the local truncation error of the discrete Laplacian at the designated boundary-related node by inserting the exact $u(x)$ into the discrete operator:\n$$\n\\text{TE}(x_i; \\Delta x) \\equiv \\mathcal{L}_h[u]_i - u_{xx}(x_i).\n$$\nYou will empirically verify the convergence order by computing the ratio\n$$\nR \\equiv \\frac{\\big|\\text{TE}(x_i; \\Delta x)\\big|}{\\big|\\text{TE}(x_i; \\Delta x/2)\\big|}.\n$$\nFor a second-order accurate truncation error, $R$ should approach $4$; for first-order accurate, $R$ should approach $2$.\n\nUnits: All quantities are dimensionless in this verification task. Angles in the sine and cosine are in radians.\n\nTest suite specification (each test case returns one float $R$):\n- Test case $1$ (Dirichlet-left, Dirichlet-right): $L = 1$, $N_{\\text{coarse}} = 20$, $N_{\\text{fine}} = 40$. Evaluate $\\text{TE}$ at the left boundary-adjacent node $i=1$.\n- Test case $2$ (Neumann-left, Dirichlet-right): $L = 1$, $N_{\\text{coarse}} = 20$, $N_{\\text{fine}} = 40$. Evaluate $\\text{TE}$ at the left boundary node $i=0$ using the ghost cell $u_{-1}$ formed from $q_L$.\n- Test case $3$ (Dirichlet-left, Neumann-right): $L = 1$, $N_{\\text{coarse}} = 20$, $N_{\\text{fine}} = 40$. Evaluate $\\text{TE}$ at the right boundary node $i=N$ using the ghost cell $u_{N+1}$ formed from $q_R$.\n\nYour program must:\n- Implement the above discrete operator and ghost-cell boundary conditions.\n- For each test case, compute the ratio $R$ as defined.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[$r_1,$ $r_2,$ $r_3$]\").\n\nNo external input is allowed; hard-code the parameters above. The final output must be numeric floats.",
            "solution": "The user has provided a valid, well-posed problem statement from the field of numerical analysis, specifically concerning the verification of a finite difference scheme for a partial differential equation.\n\nThe objective is to determine the order of accuracy of a second-order central difference approximation for the Laplacian operator ($u_{xx}$) at and near the boundaries of a one-dimensional domain. This is achieved by computing the local truncation error (TE) for a known analytic function, the method of manufactured solutions. The convergence order is then empirically verified by calculating the ratio of truncation errors on successively refined grids.\n\nThe manufactured analytic solution and its derivatives are given as:\n$$\nu(x) = e^{x} + \\sin(2x)\n$$\n$$\nu_x(x) = e^{x} + 2\\cos(2x)\n$$\n$$\nu_{xx}(x) = e^{x} - 4\\sin(2x)\n$$\nThe discrete Laplacian operator at a grid node $x_i = i\\Delta x$ is:\n$$\n\\mathcal{L}_h[u]_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}\n$$\nThe local truncation error is defined as the residual when the exact solution is substituted into the finite difference scheme:\n$$\n\\text{TE}(x_i; \\Delta x) = \\mathcal{L}_h[u(x)]_i - u_{xx}(x_i)\n$$\nThe ratio $R$ used to verify the order of convergence $p$, where $\\text{TE} \\propto (\\Delta x)^p$, is:\n$$\nR = \\frac{|\\text{TE}(x_i; \\Delta x)|}{|\\text{TE}(x_i; \\Delta x/2)|} \\approx \\frac{|C(\\Delta x)^p|}{|C(\\Delta x/2)^p|} = 2^p\n$$\nFor a first-order accurate method ($p=1$), we expect $R \\approx 2$. For a second-order accurate method ($p=2$), we expect $R \\approx 4$.\n\nWe will now analyze each test case.\n\n**Test Case 1: Dirichlet-Dirichlet Boundary Conditions, evaluated at an interior node $i=1$.**\nThe truncation error is evaluated at the node $x_1 = \\Delta x$, which is adjacent to the left boundary at $x_0=0$. The discrete operator is:\n$$\n\\mathcal{L}_h[u]_1 = \\frac{u_2 - 2u_1 + u_0}{\\Delta x^2}\n$$\nSince this is a verification exercise using an analytic solution, we use the exact function values at the grid points: $u_j = u(x_j)$. The Dirichlet condition at $x_0=0$ is implicitly satisfied by using $u_0 = u(x_0)$.\nTo find the truncation error, we perform a Taylor series expansion of $u(x_2) = u(x_1 + \\Delta x)$ and $u(x_0) = u(x_1 - \\Delta x)$ around the point $x_1$:\n$$\nu(x_1 \\pm \\Delta x) = u(x_1) \\pm u_x(x_1)\\Delta x + \\frac{u_{xx}(x_1)}{2!}\\Delta x^2 \\pm \\frac{u_{xxx}(x_1)}{3!}\\Delta x^3 + \\frac{u^{(4)}(x_1)}{4!}\\Delta x^4 \\pm \\dots\n$$\nSubstituting these into the expression for $\\mathcal{L}_h[u]_1$:\n$$\n\\mathcal{L}_h[u]_1 = \\frac{1}{\\Delta x^2} \\left[ (u(x_1) + u_x(x_1)\\Delta x + \\dots) - 2u(x_1) + (u(x_1) - u_x(x_1)\\Delta x + \\dots) \\right]\n$$\nThe odd-powered terms cancel, leaving:\n$$\n\\mathcal{L}_h[u]_1 = \\frac{1}{\\Delta x^2} \\left[ 2\\left(\\frac{u_{xx}(x_1)\\Delta x^2}{2}\\right) + 2\\left(\\frac{u^{(4)}(x_1)\\Delta x^4}{24}\\right) + \\mathcal{O}(\\Delta x^6) \\right] = u_{xx}(x_1) + \\frac{u^{(4)}(x_1)}{12}\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\nThe truncation error is:\n$$\n\\text{TE}(x_1; \\Delta x) = \\mathcal{L}_h[u]_1 - u_{xx}(x_1) = \\frac{u^{(4)}(x_1)}{12}\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\nThis is a second-order accurate approximation, $\\text{TE} = \\mathcal{O}(\\Delta x^2)$. Therefore, we expect the ratio $R_1$ to be approximately $4$.\n\n**Test Case 2: Neumann-Left Boundary Condition, evaluated at the boundary node $i=0$.**\nThe discrete operator at $x_0=0$ requires a ghost cell value $u_{-1}$:\n$$\n\\mathcal{L}_h[u]_0 = \\frac{u_1 - 2u_0 + u_{-1}}{\\Delta x^2}\n$$\nThe Neumann condition $u_x(0) = q_L$ is enforced using a second-order central difference involving the ghost cell:\n$$\n\\frac{u_1 - u_{-1}}{2\\Delta x} = q_L \\implies u_{-1} = u_1 - 2\\Delta x q_L\n$$\nSubstituting the ghost cell value into the discrete Laplacian:\n$$\n\\mathcal{L}_h[u]_0 = \\frac{u_1 - 2u_0 + (u_1 - 2\\Delta x q_L)}{\\Delta x^2} = \\frac{2u_1 - 2u_0 - 2\\Delta x q_L}{\\Delta x^2}\n$$\nFor verification, we use the exact solution: $u_1=u(x_1)=u(\\Delta x)$, $u_0=u(x_0)=u(0)$, and $q_L=u_x(0)$.\n$$\n\\mathcal{L}_h[u]_0 = \\frac{2u(\\Delta x) - 2u(0) - 2\\Delta x u_x(0)}{\\Delta x^2}\n$$\nWe expand $u(\\Delta x)$ in a Taylor series around $x=0$:\n$$\nu(\\Delta x) = u(0) + u_x(0)\\Delta x + \\frac{u_{xx}(0)}{2}\\Delta x^2 + \\frac{u_{xxx}(0)}{6}\\Delta x^3 + \\mathcal{O}(\\Delta x^4)\n$$\nSubstituting this into the operator:\n$$\n\\mathcal{L}_h[u]_0 = \\frac{2(u(0) + u_x(0)\\Delta x + \\frac{u_{xx}(0)}{2}\\Delta x^2 + \\frac{u_{xxx}(0)}{6}\\Delta x^3 + \\mathcal{O}(\\Delta x^4)) - 2u(0) - 2\\Delta x u_x(0)}{\\Delta x^2}\n$$\n$$\n\\mathcal{L}_h[u]_0 = \\frac{ u_{xx}(0)\\Delta x^2 + \\frac{u_{xxx}(0)}{3}\\Delta x^3 + \\mathcal{O}(\\Delta x^4) }{\\Delta x^2} = u_{xx}(0) + \\frac{u_{xxx}(0)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\nThe truncation error is:\n$$\n\\text{TE}(x_0; \\Delta x) = \\mathcal{L}_h[u]_0 - u_{xx}(0) = \\frac{u_{xxx}(0)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\nThis approximation is only first-order accurate, $\\text{TE} = \\mathcal{O}(\\Delta x)$. We expect the ratio $R_2$ to be approximately $2$.\n\n**Test Case 3: Neumann-Right Boundary Condition, evaluated at the boundary node $i=N$.**\nThe analysis is symmetric to Case 2. The operator at $x_N=L$ uses a ghost cell $u_{N+1}$:\n$$\n\\mathcal{L}_h[u]_N = \\frac{u_{N+1} - 2u_N + u_{N-1}}{\\Delta x^2}\n$$\nThe Neumann condition $u_x(L) = q_R$ gives the ghost cell value:\n$$\n\\frac{u_{N+1} - u_{N-1}}{2\\Delta x} = q_R \\implies u_{N+1} = u_{N-1} + 2\\Delta x q_R\n$$\nSubstituting into the Laplacian and using exact values ($u_j = u(x_j)=u(L+(j-N)\\Delta x)$, $q_R=u_x(L)$):\n$$\n\\mathcal{L}_h[u]_N = \\frac{2u(L-\\Delta x) - 2u(L) + 2\\Delta x u_x(L)}{\\Delta x^2}\n$$\nExpanding $u(L-\\Delta x)$ around $x=L$:\n$$\nu(L-\\Delta x) = u(L) - u_x(L)\\Delta x + \\frac{u_{xx}(L)}{2}\\Delta x^2 - \\frac{u_{xxx}(L)}{6}\\Delta x^3 + \\mathcal{O}(\\Delta x^4)\n$$\nSubstituting this into the operator:\n$$\n\\mathcal{L}_h[u]_N = \\frac{2(u(L) - u_x(L)\\Delta x + \\frac{u_{xx}(L)}{2}\\Delta x^2 - \\frac{u_{xxx}(L)}{6}\\Delta x^3 + \\dots) - 2u(L) + 2\\Delta x u_x(L)}{\\Delta x^2}\n$$\n$$\n\\mathcal{L}_h[u]_N = \\frac{ u_{xx}(L)\\Delta x^2 - \\frac{u_{xxx}(L)}{3}\\Delta x^3 + \\mathcal{O}(\\Delta x^4) }{\\Delta x^2} = u_{xx}(L) - \\frac{u_{xxx}(L)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\nThe truncation error is:\n$$\n\\text{TE}(x_N; \\Delta x) = \\mathcal{L}_h[u]_N - u_{xx}(L) = -\\frac{u_{xxx}(L)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\nThis approximation is also first-order accurate, $\\text{TE} = \\mathcal{O}(\\Delta x)$. We expect the ratio $R_3$ to be approximately $2$.\n\nThe Python code will implement these calculations to find the numerical values of $R_1, R_2, R_3$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Manufactured Analytic Solution and its Derivatives ---\ndef u_analytic(x):\n    \"\"\"Analytic solution u(x).\"\"\"\n    return np.exp(x) + np.sin(2 * x)\n\ndef ux_analytic(x):\n    \"\"\"First derivative u_x(x).\"\"\"\n    return np.exp(x) + 2 * np.cos(2 * x)\n\ndef uxx_analytic(x):\n    \"\"\"Second derivative u_xx(x).\"\"\"\n    return np.exp(x) - 4 * np.sin(2 * x)\n\ndef calculate_te(L, N, case_type):\n    \"\"\"\n    Calculates the local truncation error for a given case configuration.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of grid intervals.\n        case_type (int): The test case number (1, 2, or 3).\n\n    Returns:\n        float: The calculated local truncation error.\n    \"\"\"\n    dx = L / N\n\n    if case_type == 1:\n        # Case 1: Dirichlet-Dirichlet, TE at i=1\n        # Grid points needed: x_0, x_1, x_2\n        # The node of interest is x_1\n        i = 1\n        x_i = i * dx\n        x_im1 = (i - 1) * dx\n        x_ip1 = (i + 1) * dx\n\n        # Values of u from the analytic solution\n        u_i = u_analytic(x_i)\n        u_im1 = u_analytic(x_im1) # This is the boundary value u(0)\n        u_ip1 = u_analytic(x_ip1)\n\n        # Discrete and exact Laplacians\n        lap_h = (u_ip1 - 2 * u_i + u_im1) / (dx**2)\n        lap_exact = uxx_analytic(x_i)\n\n        return lap_h - lap_exact\n\n    elif case_type == 2:\n        # Case 2: Neumann-Left, TE at i=0\n        # The node of interest is x_0\n        i = 0\n        x_i = i * dx # x_0 = 0\n        x_ip1 = (i + 1) * dx # x_1\n\n        # Values of u from the analytic solution\n        u_i = u_analytic(x_i)\n        u_ip1 = u_analytic(x_ip1)\n\n        # Neumann boundary condition value q_L = u_x(0)\n        q_L = ux_analytic(x_i)\n\n        # Ghost cell value u_{-1}\n        u_im1_ghost = u_ip1 - 2 * dx * q_L\n\n        # Discrete and exact Laplacians at x_0\n        lap_h = (u_ip1 - 2 * u_i + u_im1_ghost) / (dx**2)\n        lap_exact = uxx_analytic(x_i)\n\n        return lap_h - lap_exact\n\n    elif case_type == 3:\n        # Case 3: Neumann-Right, TE at i=N\n        # The node of interest is x_N = L\n        i = N\n        x_i = i * dx # x_N = L\n        x_im1 = (i - 1) * dx # x_{N-1}\n\n        # Values of u from the analytic solution\n        u_i = u_analytic(x_i)\n        u_im1 = u_analytic(x_im1)\n\n        # Neumann boundary condition value q_R = u_x(L)\n        q_R = ux_analytic(x_i)\n\n        # Ghost cell value u_{N+1}\n        u_ip1_ghost = u_im1 + 2 * dx * q_R\n        \n        # Discrete and exact Laplacians at x_N\n        lap_h = (u_ip1_ghost - 2 * u_i + u_im1) / (dx**2)\n        lap_exact = uxx_analytic(x_i)\n\n        return lap_h - lap_exact\n    \n    else:\n        raise ValueError(\"Invalid case_type specified.\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N_coarse, N_fine, case_type)\n        (1.0, 20, 40, 1), # Case 1: D-D, at i=1\n        (1.0, 20, 40, 2), # Case 2: N-D, at i=0\n        (1.0, 20, 40, 3)  # Case 3: D-N, at i=N\n    ]\n\n    results = []\n    for L, N_coarse, N_fine, case_type in test_cases:\n        # Calculate truncation error for coarse grid\n        te_coarse = calculate_te(L, N_coarse, case_type)\n        \n        # Calculate truncation error for fine grid\n        te_fine = calculate_te(L, N_fine, case_type)\n        \n        # Calculate the ratio R. Handle potential division by zero.\n        if abs(te_fine)  1e-15:\n             # If fine error is virtually zero, ratio is effectively infinite or undefined.\n             # This shouldn't happen for this problem, but is good practice.\n            R = float('inf') \n        else:\n            R = abs(te_coarse) / abs(te_fine)\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    # The format specified is [r1,r2,r3] without spaces.\n    print(_format_results(results))\n\ndef _format_results(results):\n    \"\"\"\n    Formats the list of float results into the required string format \" [r1,r2,r3] \".\n    e.g., [4.000001,2.000001,2.000001]\n    Note: The problem example `[r1, r2, r3]` has spaces, but the final output format\n    description in the `solve` function template does not. Adhering to the template's\n    `','.join` which produces no spaces.\n    \"\"\"\n    return f\"[{','.join(map(str, results))}]\"\n\nsolve()\n```"
        },
        {
            "introduction": "Finally, we explore an alternative and powerful discretization approach: the Finite Volume Method (FVM), which is built upon the principle of strict conservation. This exercise challenges you to correctly represent a Neumann boundary condition not by approximating a derivative at a node, but by constructing a consistent numerical flux, $\\hat{F}(u)$, at the domain's edge . This practice deepens your understanding of how boundary forcing is integrated into models based on conservation laws, contrasting the flux-centric FVM approach with the point-wise FDM.",
            "id": "3828100",
            "problem": "Consider a one-dimensional conservative transport of a scalar concentration field in a Finite Volume Method (FVM, Finite Volume Method), where the domain is discretized into uniform control volumes of width $\\Delta x$ and the left boundary is located at $x=0$. The unknown is the cell-averaged concentration $u$ in units of $\\mathrm{kg}/\\mathrm{m}^3$. The total physical flux $F(u)$ in $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$ combining advection and diffusion is the sum of an advective contribution and a diffusive contribution. The advective speed $a$ is in $\\mathrm{m}/\\mathrm{s}$ and the diffusion coefficient $\\kappa$ is in $\\mathrm{m}^2/\\mathrm{s}$. A Neumann boundary condition is prescribed at the left boundary specifying the spatial derivative $\\partial u/\\partial x$ at $x=0$ in units of $\\mathrm{kg}/\\mathrm{m}^4$, denoted by $g$.\n\nStarting from the integral conservation law and the definition of flux continuity across a face, derive a consistent numerical flux $\\hat{F}(u)$ at the left boundary face of the first cell that enforces conservation. Use the following modeling and discretization assumptions:\n\n- The governing balance law is a standard conservation law written in integral form over a control volume with face-normal fluxes that must be computed to ensure conservation.\n- The Neumann boundary condition specifies $\\partial u/\\partial x$ at the boundary; interpret this physically as a constraint on the diffusive component of the flux.\n- For the diffusive contribution, impose the Neumann boundary condition by constructing a ghost cell state adjacent to the boundary and a second-order central approximation for the gradient at the boundary face that is consistent with the prescribed derivative.\n- For the advective contribution, use a first-order upwind numerical flux at the boundary face based on the sign of the advective speed $a$, recognizing that the upstream state may lie outside the domain and must be represented by the ghost cell when $a0$ at the left boundary.\n- The total numerical flux at the boundary face is the sum of the advective numerical flux and the diffusive numerical flux, oriented in the positive $x$-direction.\n\nYour program must implement the derived numerical flux function and compute $\\hat{F}(u)$ for each test case below. Express each final flux in $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$, rounded to six decimal places.\n\nTest Suite:\n- Case A (happy path, pure diffusion): $u_1=1.0\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=10\\,\\mathrm{m}$, $a=0.0\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=5\\times 10^{-3}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=2.0\\times 10^{-2}\\,\\mathrm{kg}/\\mathrm{m}^4$.\n- Case B (inflow advection-diffusion, small negative gradient): $u_1=3.0\\times 10^{-1}\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=5.0\\times 10^{2}\\,\\mathrm{m}$, $a=5.0\\times 10^{-2}\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=1.0\\times 10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=-1.0\\times 10^{-5}\\,\\mathrm{kg}/\\mathrm{m}^4$.\n- Case C (outflow advection-diffusion, positive gradient): $u_1=2.0\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=1.0\\times 10^{2}\\,\\mathrm{m}$, $a=-1.0\\times 10^{-1}\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=2.0\\times 10^{-3}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=1.0\\times 10^{-3}\\,\\mathrm{kg}/\\mathrm{m}^4$.\n- Case D (zero gradient, inflow advection): $u_1=0.0\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=1.0\\,\\mathrm{m}$, $a=1.0\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=1.0\\times 10^{-2}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=0.0\\,\\mathrm{kg}/\\mathrm{m}^4$.\n- Case E (advective-only inflow, zero diffusion): $u_1=5.0\\times 10^{-1}\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=2.0\\times 10^{1}\\,\\mathrm{m}$, $a=2.0\\times 10^{-1}\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=0.0\\,\\mathrm{m}^2/\\mathrm{s}$, $g=1.0\\times 10^{-2}\\,\\mathrm{kg}/\\mathrm{m}^4$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E\\right]$), where each $\\text{result}$ is the rounded numerical flux for the corresponding test case in $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$.",
            "solution": "The problem statement is evaluated as scientifically grounded, well-posed, objective, and complete. All provided data and constraints are consistent and physically and mathematically sound. We may therefore proceed with the derivation and solution.\n\nThe objective is to derive the numerical flux, $\\hat{F}_{1/2}$, at the left boundary face of a $1$-dimensional Finite Volume Method (FVM) grid. The boundary is located at $x=0$. The domain is discretized into cells of uniform width $\\Delta x$. The first cell, indexed as $i=1$, spans the interval $[0, \\Delta x]$ and has its cell-averaged concentration $u_1$ centered at $x_1 = \\Delta x/2$. To handle the boundary condition, we introduce a ghost cell, indexed as $i=0$, centered at $x_0 = -\\Delta x/2$. The boundary face itself is at $x_{1/2}=0$, separating the ghost cell from the first interior cell.\n\nThe total physical flux $F(u)$ is the sum of an advective flux, $F_{adv} = au$, and a diffusive flux, $F_{diff} = -\\kappa \\frac{\\partial u}{\\partial x}$. The total numerical flux $\\hat{F}$ at a cell face is the sum of the numerical advective flux $\\hat{F}_{adv}$ and the numerical diffusive flux $\\hat{F}_{diff}$:\n$$\n\\hat{F}_{1/2} = \\hat{F}_{adv, 1/2} + \\hat{F}_{diff, 1/2}\n$$\nWe shall derive each component separately according to the problem's specifications.\n\nFirst, we address the diffusive flux component, $\\hat{F}_{diff, 1/2}$. The problem specifies a Neumann boundary condition at $x=0$, given by $\\frac{\\partial u}{\\partial x} \\big|_{x=0} = g$. The instruction is to enforce this by using a $2^{nd}$-order central difference approximation for the gradient at the boundary face. This approximation involves the cell-averaged values in the adjacent cells, $u_0$ (ghost cell) and $u_1$ (first cell):\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x=0} \\approx \\frac{u_1 - u_0}{x_1 - x_0} = \\frac{u_1 - u_0}{\\Delta x}\n$$\nEquating this approximation to the prescribed gradient $g$ allows us to define the state of the ghost cell:\n$$\n\\frac{u_1 - u_0}{\\Delta x} = g \\implies u_0 = u_1 - g \\Delta x\n$$\nThis expression for $u_0$ is a necessary component for constructing the advective flux, as will be shown. For the diffusive flux itself, the problem states to interpret the Neumann condition as a direct constraint on the diffusive flux. The physical diffusive flux at the boundary is $F_{diff} \\big|_{x=0} = -\\kappa \\frac{\\partial u}{\\partial x} \\big|_{x=0}$. By substituting the given boundary condition, we directly obtain the numerical diffusive flux at the face:\n$$\n\\hat{F}_{diff, 1/2} = -\\kappa g\n$$\nThis approach is consistent and directly enforces the specified flux condition. The use of the ghost cell stencil to define a gradient, $\\frac{u_1-u_0}{\\Delta x}$, which is then used in a flux formula, $-\\kappa\\frac{u_1-u_0}{\\Delta x}$, would yield the same result, $-\\kappa g$, confirming the methodology.\n\nNext, we derive the advective flux component, $\\hat{F}_{adv, 1/2}$. The problem mandates a $1^{st}$-order upwind scheme. This scheme selects the cell-averaged value from the \"upwind\" direction to compute the flux. The direction is determined by the sign of the advective speed, $a$.\n- If $a \\ge 0$, the flow is from left to right (positive $x$-direction), which is an inflow condition at the left boundary. The upwind state is the one to the left of the face $x_{1/2}=0$, which is the ghost cell value $u_0$. The advective flux is therefore:\n  $$\n  \\hat{F}_{adv, 1/2} = a u_0 \\quad (\\text{for } a \\ge 0)\n  $$\n- If $a  0$, the flow is from right to left (negative $x$-direction), which is an outflow condition at the left boundary. The upwind state is the one to the right of the face, which is the first interior cell value $u_1$. The advective flux is:\n  $$\n  \\hat{F}_{adv, 1/2} = a u_1 \\quad (\\text{for } a  0)\n  $$\n\nFinally, we synthesize the total numerical flux $\\hat{F}_{1/2}$ by summing the advective and diffusive components for each case.\n\nCase 1: Inflow ($a \\ge 0$)\nThe total flux is the sum of the inflow advective flux and the diffusive flux. We substitute the expression for the ghost cell value $u_0 = u_1 - g \\Delta x$ into the advective flux term.\n$$\n\\hat{F}_{1/2} = \\hat{F}_{adv, 1/2} + \\hat{F}_{diff, 1/2} = a u_0 - \\kappa g = a(u_1 - g \\Delta x) - \\kappa g\n$$\n\nCase 2: Outflow ($a  0$)\nThe total flux is the sum of the outflow advective flux and the diffusive flux.\n$$\n\\hat{F}_{1/2} = \\hat{F}_{adv, 1/2} + \\hat{F}_{diff, 1/2} = a u_1 - \\kappa g\n$$\n\nIn summary, the complete formula for the numerical flux at the left boundary face is:\n$$\n\\hat{F}(u_1, \\Delta x, a, \\kappa, g) = \\begin{cases} a (u_1 - g \\Delta x) - \\kappa g  \\text{if } a \\ge 0 \\\\ a u_1 - \\kappa g  \\text{if } a  0 \\end{cases}\n$$\nThis formula will now be implemented to compute the flux for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical flux at the left boundary of a 1D FVM domain\n    for a series of test cases, based on a derived formula for a\n    Neumann boundary condition.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (u1, delta_x, a, kappa, g)\n    test_cases = [\n        # Case A: happy path, pure diffusion\n        (1.0, 10.0, 0.0, 5e-3, 2e-2),\n        # Case B: inflow advection-diffusion, small negative gradient\n        (3.0e-1, 5.0e2, 5.0e-2, 1.0e-4, -1.0e-5),\n        # Case C: outflow advection-diffusion, positive gradient\n        (2.0, 1.0e2, -1.0e-1, 2.0e-3, 1.0e-3),\n        # Case D: zero gradient, inflow advection\n        (0.0, 1.0, 1.0, 1.0e-2, 0.0),\n        # Case E: advective-only inflow, zero diffusion\n        (5.0e-1, 2.0e1, 2.0e-1, 0.0, 1.0e-2),\n    ]\n\n    results = []\n    for case in test_cases:\n        u1, delta_x, a, kappa, g = case\n\n        # The numerical flux at the left boundary is derived as:\n        # F_hat = a * u_upwind - kappa * g\n        # where u_upwind is determined by the sign of 'a'.\n        # For a = 0 (inflow): u_upwind is the ghost cell value u0.\n        #    u0 is defined by the Neumann BC: (u1 - u0) / delta_x = g\n        #    = u0 = u1 - g * delta_x\n        # For a  0 (outflow): u_upwind is the first cell value u1.\n\n        if a = 0:\n            # Inflow or zero advection case\n            # Flux = a * (u1 - g * delta_x) - kappa * g\n            flux = a * (u1 - g * delta_x) - kappa * g\n        else:\n            # Outflow case\n            # Flux = a * u1 - kappa * g\n            flux = a * u1 - kappa * g\n        \n        results.append(flux)\n\n    # Format the results to 6 decimal places and join into the final string.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}