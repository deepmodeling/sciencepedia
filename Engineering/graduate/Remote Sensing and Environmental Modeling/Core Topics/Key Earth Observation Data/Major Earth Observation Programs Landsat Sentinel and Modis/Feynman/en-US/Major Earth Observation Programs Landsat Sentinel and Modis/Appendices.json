{
    "hands_on_practices": [
        {
            "introduction": "The first step in any quantitative remote sensing analysis is converting the raw digital numbers ($DN$) recorded by the sensor into physically meaningful units. This exercise guides you through the fundamental process of radiometric calibration for Landsat 8, transforming $DN$s into at-sensor spectral radiance ($L_{\\lambda}$) and then into Top-of-Atmosphere (TOA) reflectance ($\\rho$). By also propagating the uncertainty from the calibration coefficients, you will gain a deeper appreciation for the precision of satellite-derived measurements and the importance of metadata in scientific applications .",
            "id": "3825717",
            "problem": "A Level-1 scene from the Landsat 8 Operational Land Imager (OLI) provides a pixel in the red band with Digital Number (DN). Level-1 radiance rescaling for Landsat is a linear mapping from DN to at-sensor spectral radiance based on metadata-provided multiplicative and additive radiance rescaling coefficients. Top-of-atmosphere (TOA) bidirectional reflectance is defined, under a Lambertian assumption, by the ratio of reflected radiance to the incident exoatmospheric solar irradiance, accounting for Earth–Sun distance and the solar zenith geometry.\n\nStarting from these foundations:\n- The Level-1 linear radiometric calibration definition connecting DN to spectral radiance.\n- The radiometric definition of TOA reflectance for a Lambertian target under solar zenith angle.\n\nderive the expressions needed to convert from DN to spectral radiance $L_{\\lambda}$ and then to TOA reflectance $\\rho$, and propagate uncertainty from the radiance rescaling coefficients only using first-order (Gaussian) uncertainty propagation. Assume all other quantities are exact and neglect atmospheric path terms.\n\nFor a specific pixel in Landsat 8 OLI Band 4 (red), you are given:\n- Digital Number (DN): $Q = 12000$.\n- Radiance multiplicative rescaling coefficient: $M_{L} = 6.000 \\times 10^{-3}\\ \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}\\,\\text{DN}^{-1}$ with standard uncertainty $u(M_{L}) = 1.5 \\times 10^{-4}\\ \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}\\,\\text{DN}^{-1}$.\n- Radiance additive rescaling coefficient: $A_{L} = 2.0 \\times 10^{-1}\\ \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}$ with standard uncertainty $u(A_{L}) = 1.0 \\times 10^{-1}\\ \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}$.\n- Mean solar exoatmospheric irradiance for Landsat 8 OLI Band 4 (exospheric solar constant in band): $E_{\\text{SUN}} = 1.570 \\times 10^{3}\\ \\text{W}\\,\\text{m}^{-2}\\,\\mu\\text{m}^{-1}$.\n- Earth–Sun distance in astronomical units (AU): $d = 1.005$.\n- Solar zenith angle: $\\theta_{s} = 30^\\circ$.\n\nAssumptions:\n- Treat $Q$, $E_{\\text{SUN}}$, $d$, and $\\theta_{s}$ as constants with negligible uncertainty.\n- Treat $M_{L}$ and $A_{L}$ as independent (uncorrelated) random variables with the given standard uncertainties.\n- Use first-order (Gaussian) uncertainty propagation.\n- Express angles in degrees; trigonometric functions should be evaluated accordingly.\n- TOA reflectance is dimensionless; express it as a decimal (no percent sign).\n\nCompute the standard uncertainty of the TOA reflectance, $u(\\rho)$, due solely to $u(M_{L})$ and $u(A_{L})$. Round your final result to three significant figures. Report only the final numerical value of $u(\\rho)$ (unitless).",
            "solution": "The problem is deemed valid as it is scientifically grounded in the principles of remote sensing radiometry, well-posed with sufficient information for a unique solution, and objective in its formulation.\n\nThe task is to derive the expression for top-of-atmosphere (TOA) reflectance, $\\rho$, as a function of the Digital Number ($Q$) and other parameters, and then to calculate the standard uncertainty of this reflectance, $u(\\rho)$, arising from the uncertainties in the radiance rescaling coefficients, $M_L$ and $A_L$.\n\nFirst, we establish the relationship between the raw Digital Number ($Q$) from the sensor and the at-sensor spectral radiance, $L_{\\lambda}$. As stated, this is a linear transformation defined by a multiplicative rescaling factor, $M_L$, and an additive rescaling factor, $A_L$.\n$$L_{\\lambda} = M_{L} Q + A_{L}$$\nwhere $L_{\\lambda}$ is the spectral radiance in units of $\\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}$.\n\nNext, we define the TOA reflectance, $\\rho$. Under a Lambertian assumption, the reflectance is the ratio of the total reflected energy to the total incident energy. In terms of radiance, the TOA reflectance is given by:\n$$\\rho = \\frac{\\pi L_{\\lambda}}{E_{\\text{incident}}}$$\nwhere $L_{\\lambda}$ is the reflected radiance observed by the sensor, and $E_{\\text{incident}}$ is the total solar irradiance incident on a horizontal surface at the top of the atmosphere. The factor of $\\pi$ accounts for the solid angle integration over a hemisphere for an ideal Lambertian surface.\n\nThe incident solar irradiance, $E_{\\text{incident}}$, must be calculated from the mean solar exoatmospheric irradiance, $E_{\\text{SUN}}$, by correcting for two factors: the solar zenith angle, $\\theta_s$, and the Earth–Sun distance, $d$ (in astronomical units, AU). The cosine of the solar zenith angle accounts for the projection of the incoming solar flux onto a horizontal surface. The inverse square law, proportional to $1/d^2$, accounts for the variation in solar irradiance due to the Earth's elliptical orbit.\n$$E_{\\text{incident}} = \\frac{E_{\\text{SUN}} \\cos(\\theta_s)}{d^2}$$\n\nSubstituting the expression for $E_{\\text{incident}}$ into the equation for $\\rho$, we get:\n$$\\rho = \\frac{\\pi L_{\\lambda} d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}$$\n\nNow, we substitute the first equation for $L_{\\lambda}$ into this expression to obtain the full model for TOA reflectance as a function of the input DN and sensor/scene parameters:\n$$\\rho(Q, M_L, A_L, E_{\\text{SUN}}, d, \\theta_s) = \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)} (M_{L} Q + A_{L})$$\n\nThe problem requires calculating the standard uncertainty in $\\rho$, $u(\\rho)$, due solely to the uncertainties in $M_L$ and $A_L$. All other variables ($Q$, $E_{\\text{SUN}}$, $d$, $\\theta_s$) are treated as exact constants. We are given that $M_L$ and $A_L$ are independent. The formula for first-order (Gaussian) uncertainty propagation for a function $f(x, y)$ with independent variables $x$ and $y$ is:\n$$u(f)^2 = \\left(\\frac{\\partial f}{\\partial x}\\right)^2 u(x)^2 + \\left(\\frac{\\partial f}{\\partial y}\\right)^2 u(y)^2$$\nApplying this to our function $\\rho(M_L, A_L)$:\n$$u(\\rho)^2 = \\left(\\frac{\\partial \\rho}{\\partial M_L}\\right)^2 u(M_L)^2 + \\left(\\frac{\\partial \\rho}{\\partial A_L}\\right)^2 u(A_L)^2$$\n\nWe compute the partial derivatives of $\\rho$ with respect to $M_L$ and $A_L$:\n$$\\frac{\\partial \\rho}{\\partial M_L} = \\frac{\\partial}{\\partial M_L} \\left[ \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)} (M_{L} Q + A_{L}) \\right] = \\frac{\\pi Q d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}$$\n$$\\frac{\\partial \\rho}{\\partial A_L} = \\frac{\\partial}{\\partial A_L} \\left[ \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)} (M_{L} Q + A_{L}) \\right] = \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}$$\n\nSubstituting these derivatives into the uncertainty propagation formula:\n$$u(\\rho)^2 = \\left(\\frac{\\pi Q d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 u(M_L)^2 + \\left(\\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 u(A_L)^2$$\nWe can factor out the common term:\n$$u(\\rho)^2 = \\left(\\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 \\left[ (Q u(M_L))^2 + u(A_L)^2 \\right]$$\n\nNow we substitute the provided numerical values:\n- $Q = 12000$\n- $u(M_{L}) = 1.5 \\times 10^{-4}$\n- $u(A_{L}) = 1.0 \\times 10^{-1}$\n- $E_{\\text{SUN}} = 1.570 \\times 10^{3}$\n- $d = 1.005$\n- $\\theta_{s} = 30^\\circ$\n\nFirst, calculate the terms inside the brackets:\n$$(Q u(M_L))^2 = (12000 \\times 1.5 \\times 10^{-4})^2 = (1.8)^2 = 3.24$$\n$$u(A_L)^2 = (1.0 \\times 10^{-1})^2 = 0.01$$\n\nThe sum of these squared terms is:\n$$(Q u(M_L))^2 + u(A_L)^2 = 3.24 + 0.01 = 3.25$$\n\nNext, calculate the squared pre-factor. We use $\\cos(30^\\circ) = \\frac{\\sqrt{3}}{2}$.\n$$\\left(\\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 = \\left(\\frac{\\pi (1.005)^2}{(1.570 \\times 10^{3}) \\times \\frac{\\sqrt{3}}{2}}\\right)^2$$\n$$\\left(\\frac{\\pi \\times 1.010025}{1359.6601...}\\right)^2 \\approx (0.00233370...)^2 \\approx 5.44614 \\times 10^{-6}$$\n\nNow, multiply the two parts to find $u(\\rho)^2$:\n$$u(\\rho)^2 \\approx (5.44614 \\times 10^{-6}) \\times 3.25 \\approx 1.769996 \\times 10^{-5}$$\n\nFinally, take the square root to find the standard uncertainty $u(\\rho)$:\n$$u(\\rho) = \\sqrt{1.769996 \\times 10^{-5}} \\approx 0.00420713$$\n\nRounding the result to three significant figures as requested:\n$$u(\\rho) \\approx 0.00421$$",
            "answer": "$$\\boxed{0.00421}$$"
        },
        {
            "introduction": "Working with data from multiple missions like Landsat, Sentinel, and MODIS presents a practical challenge: each program uses different data formats and metadata conventions. This practice requires you to design a programmatic scheme to navigate these differences, extracting essential radiometric scale factors and decoding bit-packed Quality Assessment (QA) flags from abstracted metadata structures. Mastering this kind of data wrangling is a crucial skill for any remote sensing scientist, enabling the creation of robust, automated processing workflows for multi-sensor data analysis .",
            "id": "3825756",
            "problem": "Design and implement a programmatic metadata parsing scheme that, given structured metadata describing products from three major Earth observation programs—Georeferenced Tagged Image File Format (GeoTIFF) carrying Landsat Surface Reflectance (SR), Joint Photographic Experts Group 2000 (JPEG 2000, JP2) carrying Sentinel-2 Level-1C, and Hierarchical Data Format version 5 (HDF5) carrying Moderate Resolution Imaging Spectroradiometer (MODIS)—extracts per-band radiometric scale factors and decodes a set of Quality Assessment (QA) bits from a supplied integer QA value.\n\nFundamental base and definitions to be used:\n- Radiometric linear calibration: for each spectral band, a digital number $x_b$ is mapped to a physical quantity $y_b$ by $y_b = s_b \\, x_b + o_b$, where $s_b$ is the band-specific scale factor and $o_b$ is the band-specific offset. The task focuses on extracting $s_b$; offsets $o_b$ may be used for precedence logic but are not part of the required output.\n- Bitfield decomposition of a nonnegative integer QA value: any $q \\in \\mathbb{N}_0$ has a binary expansion $q = \\sum_{p=0}^{P} b_p \\, 2^p$ with $b_p \\in \\{0,1\\}$ indicating the bit at position $p$. Decoding a set of requested bit positions $\\{p_i\\}$ means returning the list $[b_{p_1}, b_{p_2}, \\dots, b_{p_k}]$.\n\nProgram-specific precedence conventions to resolve metadata into $s_b$ and $o_b$ (scientifically realistic and commonly used):\n1. Landsat SR in GeoTIFF:\n   - If per-band keys are present for band index $n$ of the form “REFLECTANCE_MULT_BAND_$n$” and “REFLECTANCE_ADD_BAND_$n$”, then set $s_b$ from “REFLECTANCE_MULT_BAND_$n$” and $o_b$ from “REFLECTANCE_ADD_BAND_$n$”.\n   - Else, if a global key “SCALE_FACTOR” is present, use $s_b$ equal to that scalar for all bands and $o_b = 0$.\n   - Else, default $s_b = 1$ and $o_b = 0$.\n2. Sentinel-2 Level-1C in JP2:\n   - If a global key “QUANTIFICATION_VALUE” is present with value $Q$, set $s_b = 1/Q$ and $o_b = 0$ for all bands (mapping radiance-like digital numbers to top-of-atmosphere reflectance-like quantities).\n   - Else, if a per-band “Radiometric_Gain” mapping is present, use $s_b$ as that per-band gain and $o_b = 0$.\n   - Else, default $s_b = 1$ and $o_b = 0$.\n3. MODIS in HDF5:\n   - If attributes contain “scale_factor” equal to $a$ and “add_offset” equal to $b$ (either global or per-band), then set $s_b = a$ and $o_b = b$.\n   - If “scale_factor” is present but nonpositive, treat the metadata as corrupted and default to $s_b = 1$ and $o_b = 0$; if “scale_factor” is missing, also default $s_b = 1$ and $o_b = 0$.\n\nQuality Assessment (QA) decoding rule:\n- For an integer $q \\ge 0$ and requested bit positions $\\{p_i\\}$, return the list $[b_{p_1}, \\dots, b_{p_k}]$ where $b_{p} \\in \\{0,1\\}$ is determined by the binary decomposition of $q$.\n\nInput abstraction:\n- Each test case is a tuple-like structure with fields: “format” (one of {“LANDSAT_SR_GEOTIFF”, “SENTINEL2_L1C_JP2”, “MODIS_HDF5”}), “bands” (an ordered list of band identifiers, each a nonnegative integer index), “metadata” (a mapping from string keys to values, potentially including nested mappings), “qa_value” (a nonnegative integer $q$), and “qa_bit_positions” (an ordered list of nonnegative integer positions $\\{p_i\\}$ to decode).\n\nOutput specification:\n- For each test case, produce a pair consisting of:\n  - The ordered list of per-band scale factors $[s_{b_1}, s_{b_2}, \\dots, s_{b_m}]$ aligned to the supplied “bands” list.\n  - The ordered list of decoded QA bits $[b_{p_1}, \\dots, b_{p_k}]$ aligned to the supplied “qa_bit_positions” list.\n- Aggregate the results of all test cases into a single line of output containing the results as a comma-separated list enclosed in square brackets. The outer list contains one element per test case; each element is a two-element list comprising the scale-factor list and the QA-bits list. No additional text may be printed.\n\nTest suite:\n- Case $1$ (happy path, Landsat SR, global scale):\n  - format: “LANDSAT_SR_GEOTIFF”\n  - bands: $[2, 3, 4]$\n  - metadata: {“SCALE_FACTOR”: $0.0001$}\n  - qa_value: $24$ (binary $11000$)\n  - qa_bit_positions: $[3, 4]$\n- Case $2$ (happy path, Sentinel-2 L1C, quantification value):\n  - format: “SENTINEL2_L1C_JP2”\n  - bands: $[2, 3, 4, 8]$\n  - metadata: {“QUANTIFICATION_VALUE”: $10000$}\n  - qa_value: $130$ (binary $10000010$)\n  - qa_bit_positions: $[1, 7]$\n- Case $3$ (happy path, MODIS HDF5, standard attributes):\n  - format: “MODIS_HDF5”\n  - bands: $[1, 2, 3]$\n  - metadata: {“attrs”: {“scale_factor”: $0.0001$, “add_offset”: $0$}}\n  - qa_value: $1024$ (binary $10000000000$)\n  - qa_bit_positions: $[10, 0]$\n- Case $4$ (edge path, Landsat SR, mixed per-band with fallback):\n  - format: “LANDSAT_SR_GEOTIFF”\n  - bands: $[2, 3, 4]$\n  - metadata: {“REFLECTANCE_MULT_BAND_2”: $0.00002$, “REFLECTANCE_ADD_BAND_2”: $0$, “REFLECTANCE_MULT_BAND_3”: $0.00003$, “REFLECTANCE_ADD_BAND_3”: $0$, “SCALE_FACTOR”: $0.0001$}\n  - qa_value: $0$\n  - qa_bit_positions: $[3, 4]$\n- Case $5$ (edge path, MODIS HDF5, nonpositive scale factor defaults):\n  - format: “MODIS_HDF5”\n  - bands: $[1, 2]$\n  - metadata: {“attrs”: {“scale_factor”: $0$, “add_offset”: $0$}}\n  - qa_value: $1$\n  - qa_bit_positions: $[0, 15]$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[result1,result2,result3]”). Each result element must be a two-element list, the first being the per-band scale factors and the second being the decoded QA bits, both expressed as lists of base numeric types (floats for scale factors, integers for decoded bits).",
            "solution": "The problem statement has been critically validated and is determined to be a valid, well-posed scientific programming task. It is scientifically grounded in the principles of remote sensing data processing, internally consistent, and provides all necessary information to construct a unique and verifiable solution.\n\nThe task is to design a programmatic scheme to parse metadata from three distinct Earth observation data products—Landsat Surface Reflectance (SR), Sentinel-2 Level-1C, and MODIS—to extract radiometric scale factors and decode quality assessment (QA) bit flags. The solution requires a structured implementation of specified precedence logic for metadata interpretation and a standard algorithm for bitfield decomposition.\n\nThe overall design will be implemented in a Python program structured as follows:\n1.  A main function, `solve`, iterates through a list of predefined test cases.\n2.  For each test case, a helper function, `process_case`, is invoked. This function orchestrates the two main sub-tasks: extracting scale factors and decoding QA bits.\n3.  A dedicated function, `extract_scale_factors`, implements the product-specific logic for determining the radiometric scale factor, $s_b$, for each requested spectral band.\n4.  A second dedicated function, `decode_qa_bits`, performs the bitfield decomposition of a given integer QA value, $q$.\n\nThe results from each test case, consisting of an ordered list of scale factors and an ordered list of decoded QA bits, are collected and formatted into a single string for final output, as per the specification.\n\n**Principle-Based Design**\n\n**1. Quality Assessment (QA) Bit Decoding**\n\nThe decoding of QA bits is a fundamental operation based on the binary representation of a non-negative integer. Any non-negative integer, $q \\in \\mathbb{N}_0$, can be expressed as a sum of powers of $2$: $q = \\sum_{p=0}^{P} b_p \\, 2^p$, where $b_p \\in \\{0,1\\}$ is the bit at position $p$.\n\nThe function `decode_qa_bits` takes an integer `qa_value`, $q$, and a list of `qa_bit_positions`, $\\{p_i\\}$, as input. For each requested position $p$, the value of the corresponding bit $b_p$ is determined using a bitwise right shift followed by a bitwise AND operation. The expression for this is:\n$$\nb_p = (q \\gg p) \\land 1\n$$\nHere, $q \\gg p$ shifts the bits of $q$ to the right by $p$ positions, placing the bit of interest at the least significant position (position $0$). The subsequent AND operation with $1$ (binary $...0001_2$) isolates this bit, yielding either $0$ or $1$. The function returns a list of these bit values, ordered according to the input `qa_bit_positions`.\n\n**2. Radiometric Scale Factor Extraction**\n\nThe function `extract_scale_factors` is responsible for interpreting the provided `metadata` dictionary based on the product `format` and the list of requested `bands`. It applies a specific set of precedence rules for each format to find the correct scale factor, $s_b$, for each band. The general radiometric calibration model is $y_b = s_b \\, x_b + o_b$, where our focus is on $s_b$.\n\n**2.1. Landsat Surface Reflectance (GeoTIFF)**\n\nFor the format `LANDSAT_SR_GEOTIFF`, the logic proceeds on a per-band basis, checking for metadata keys in a specific order of precedence for each requested band index $n$:\n1.  It first checks for a band-specific scale factor key, `REFLECTANCE_MULT_BAND_$n$`. If this key exists in the metadata, its value is used as the scale factor $s_b$ for that band.\n2.  If the band-specific key is not found, the logic falls back to checking for a global scale factor key, `SCALE_FACTOR`. If this key exists, its value is used for the band.\n3.  If neither of the above keys is found, a default scale factor of $1.0$ is assigned.\n\nThis per-band, cascading lookup ensures that the most specific metadata is used when available, while providing robust fallbacks.\n\n**2.2. Sentinel-2 Level-1C (JPEG 2000)**\n\nFor the format `SENTINEL2_L1C_JP2`, the rules define a product-level precedence:\n1.  The primary check is for the `QUANTIFICATION_VALUE` key, let its value be $Q$. If present, the scale factor for all bands is computed as $s_b = 1/Q$. This reflects the standard conversion from scaled digital numbers to Top-of-Atmosphere (TOA) reflectance.\n2.  If `QUANTIFICATION_VALUE` is absent, the rules specify a check for a per-band `Radiometric_Gain` mapping. As this is not present in the test data, this branch of logic is noted but will not be triggered.\n3.  If neither of the above conditions is met, a default scale factor of $1.0$ is applied to all requested bands.\n\n**2.3. MODIS (HDF5)**\n\nFor the format `MODIS_HDF5`, the metadata is expected to be nested within an `attrs` dictionary. The rules are as follows:\n1.  The primary condition requires the presence of both a `scale_factor` key and an `add_offset` key within the `attrs` dictionary. Furthermore, the value of `scale_factor` must be positive. If all these conditions are met, its value is used as the scale factor $s_b$ for all requested bands.\n2.  If the primary condition is not met for any reason (e.g., missing keys, or a `scale_factor` that is non-positive, i.e., $\\le 0$), the logic defaults to a scale factor of $1.0$ for all bands. This correctly handles cases of missing, incomplete, or corrupted metadata as defined in the problem.\n\nThis systematic implementation of well-defined rules ensures that the metadata parsing is robust, deterministic, and scientifically correct according to the provided specifications.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes a suite of remote sensing metadata parsing test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, Landsat SR, global scale)\n        {\n            \"format\": \"LANDSAT_SR_GEOTIFF\",\n            \"bands\": [2, 3, 4],\n            \"metadata\": {\"SCALE_FACTOR\": 0.0001},\n            \"qa_value\": 24,\n            \"qa_bit_positions\": [3, 4],\n        },\n        # Case 2 (happy path, Sentinel-2 L1C, quantification value)\n        {\n            \"format\": \"SENTINEL2_L1C_JP2\",\n            \"bands\": [2, 3, 4, 8],\n            \"metadata\": {\"QUANTIFICATION_VALUE\": 10000},\n            \"qa_value\": 130,\n            \"qa_bit_positions\": [1, 7],\n        },\n        # Case 3 (happy path, MODIS HDF5, standard attributes)\n        {\n            \"format\": \"MODIS_HDF5\",\n            \"bands\": [1, 2, 3],\n            \"metadata\": {\"attrs\": {\"scale_factor\": 0.0001, \"add_offset\": 0}},\n            \"qa_value\": 1024,\n            \"qa_bit_positions\": [10, 0],\n        },\n        # Case 4 (edge path, Landsat SR, mixed per-band with fallback)\n        {\n            \"format\": \"LANDSAT_SR_GEOTIFF\",\n            \"bands\": [2, 3, 4],\n            \"metadata\": {\n                \"REFLECTANCE_MULT_BAND_2\": 0.00002,\n                \"REFLECTANCE_ADD_BAND_2\": 0,\n                \"REFLECTANCE_MULT_BAND_3\": 0.00003,\n                \"REFLECTANCE_ADD_BAND_3\": 0,\n                \"SCALE_FACTOR\": 0.0001,\n            },\n            \"qa_value\": 0,\n            \"qa_bit_positions\": [3, 4],\n        },\n        # Case 5 (edge path, MODIS HDF5, nonpositive scale factor defaults)\n        {\n            \"format\": \"MODIS_HDF5\",\n            \"bands\": [1, 2],\n            \"metadata\": {\"attrs\": {\"scale_factor\": 0, \"add_offset\": 0}},\n            \"qa_value\": 1,\n            \"qa_bit_positions\": [0, 15],\n        },\n    ]\n\n    def decode_qa_bits(q, bit_positions):\n        \"\"\"\n        Decodes requested bits from a non-negative integer QA value.\n\n        Args:\n            q (int): The non-negative integer QA value.\n            bit_positions (list[int]): An ordered list of bit positions to decode.\n\n        Returns:\n            list[int]: The list of decoded bit values (0 or 1).\n        \"\"\"\n        return [(q >> pos) & 1 for pos in bit_positions]\n\n    def extract_scale_factors(case):\n        \"\"\"\n        Extracts radiometric scale factors based on product-specific metadata rules.\n\n        Args:\n            case (dict): The test case dictionary.\n\n        Returns:\n            list[float]: The ordered list of per-band scale factors.\n        \"\"\"\n        fmt = case[\"format\"]\n        metadata = case[\"metadata\"]\n        bands = case[\"bands\"]\n        scales = []\n\n        if fmt == \"LANDSAT_SR_GEOTIFF\":\n            for band_idx in bands:\n                per_band_key = f\"REFLECTANCE_MULT_BAND_{band_idx}\"\n                if per_band_key in metadata:\n                    scales.append(metadata[per_band_key])\n                elif \"SCALE_FACTOR\" in metadata:\n                    scales.append(metadata[\"SCALE_FACTOR\"])\n                else:\n                    scales.append(1.0)\n            return scales\n\n        elif fmt == \"SENTINEL2_L1C_JP2\":\n            scale = 1.0 # Default\n            if \"QUANTIFICATION_VALUE\" in metadata:\n                q_val = metadata[\"QUANTIFICATION_VALUE\"]\n                if q_val > 0:\n                    scale = 1.0 / q_val\n            # The \"Radiometric_Gain\" rule is not triggered by test cases\n            # so the logic defaults to 1.0 if QUANTIFICATION_VALUE is not present.\n            return [scale] * len(bands)\n            \n        elif fmt == \"MODIS_HDF5\":\n            scale = 1.0  # Default\n            if \"attrs\" in metadata:\n                attrs = metadata[\"attrs\"]\n                if \"scale_factor\" in attrs and \"add_offset\" in attrs:\n                    sf = attrs[\"scale_factor\"]\n                    if isinstance(sf, (int, float)) and sf > 0:\n                        scale = sf\n            return [scale] * len(bands)\n        \n        return [1.0] * len(bands) # Fallback for unknown formats\n\n    def process_case(case):\n        \"\"\"\n        Processes a single test case to extract scale factors and QA bits.\n\n        Args:\n            case (dict): The test case dictionary.\n\n        Returns:\n            list: A two-element list containing the list of scale factors\n                  and the list of decoded QA bits.\n        \"\"\"\n        scales = extract_scale_factors(case)\n        qa_bits = decode_qa_bits(case[\"qa_value\"], case[\"qa_bit_positions\"])\n        return [scales, qa_bits]\n\n    results = [process_case(case) for case in test_cases]\n\n    # The final print statement must match the project specification exactly.\n    # The default str() representation of a list in Python includes spaces.\n    # This is joined with commas, resulting in a format like '[[...], [...]], [[...], [...]]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To compare or fuse data from sensors with different spatial resolutions, such as Sentinel-2 ($10\\,\\mathrm{m}$) and Landsat ($30\\,\\mathrm{m}$), resampling is unavoidable, yet the choice of algorithm can significantly affect scientific results. This exercise uses a controlled thought experiment—a sharp boundary between water and land—to explore how different resampling methods introduce specific biases in derived products. By quantifying the error in the Normalized Difference Water Index ($I$) after resampling, you will gain critical insight into the artifacts introduced by common image processing steps and their impact on data harmonization .",
            "id": "3825805",
            "problem": "Consider a cross-sensor harmonization task across Landsat, Copernicus Sentinel-2, and Moderate Resolution Imaging Spectroradiometer (MODIS), where a shoreline boundary separates open water from vegetated land. Assume the reflectance field is a one-dimensional, piecewise-constant step function along the horizontal coordinate $x$, with the boundary at $x=0$, water for $x<0$, and land for $x\\geq 0$. Let the water endmember have green- and near-infrared (NIR) surface reflectances $R_{g}^{w}=0.05$ and $R_{n}^{w}=0.01$, and the land endmember (dense vegetation) have $R_{g}^{\\ell}=0.08$ and $R_{n}^{\\ell}=0.45$. Define the Normalized Difference Water Index (NDWI) as $I=\\frac{R_{g}-R_{n}}{R_{g}+R_{n}}$, which is commonly used across Landsat, Sentinel-2, and MODIS for water detection.\n\nYou are resampling Sentinel-2 green and NIR reflectances from their native grid ($10\\,\\mathrm{m}$ sample spacing) to a Landsat target grid ($30\\,\\mathrm{m}$) at the target pixel center located at $x=0$. Due to typical cross-sensor geolocation discrepancies, the Sentinel-2 sample centers are offset by $\\Delta=5\\,\\mathrm{m}$ relative to the shoreline, so that sample centers lie at $x_{k}=\\Delta+10k$ with $k\\in\\mathbb{Z}$. Thus, the four nearest Sentinel-2 samples to $x=0$ occur at $x=-15\\,\\mathrm{m}$, $x=-5\\,\\mathrm{m}$ (water side) and $x=+5\\,\\mathrm{m}$, $x=+15\\,\\mathrm{m}$ (land side).\n\nStarting from the definitions of sampling and interpolation operators and the NDWI definition, derive how nearest-neighbor, bilinear (in one dimension), and cubic convolution resampling (Keys kernel with parameter $a=-\\frac{1}{2}$) alter edge contrast for this step edge at $x=0$. Then, using those operators, compute the NDWI bias at the shoreline target location for each method, defined as\n$$\nB=\\left(\\frac{R_{g}^{\\mathrm{res}}-R_{n}^{\\mathrm{res}}}{R_{g}^{\\mathrm{res}}+R_{n}^{\\mathrm{res}}}\\right)-\\left(\\frac{R_{g}^{w}-R_{n}^{w}}{R_{g}^{w}+R_{n}^{w}}\\right),\n$$\nwhere $R_{g}^{\\mathrm{res}}$ and $R_{n}^{\\mathrm{res}}$ are the resampled green and NIR reflectances at $x=0$ produced by each method.\n\nAssume ideal point sampling at pixel centers (neglect point-spread functions and subpixel mixing other than the resampling weights) and that reflectances are spectrally and spatially constant within each endmember. Use the Keys cubic convolution kernel:\n$$\nh(t)=\n\\begin{cases}\n(a+2)|t|^{3}-(a+3)|t|^{2}+1, & 0\\leq |t|<1,\\\\\na|t|^{3}-5a|t|^{2}+8a|t|-4a, & 1\\leq |t|<2,\\\\\n0, & |t|\\geq 2,\n\\end{cases}\n\\quad a=-\\frac{1}{2}.\n$$\n\nProvide the three NDWI biases $B_{\\mathrm{NN}}$, $B_{\\mathrm{BL}}$, and $B_{\\mathrm{CC}}$ corresponding to nearest-neighbor, bilinear, and cubic convolution, respectively. Express the final biases as decimals (unitless) and round your answer to four significant figures.",
            "solution": "The problem is valid as it is scientifically grounded in remote sensing principles, well-posed with all necessary information, and free of contradictions or ambiguities.\n\nThe one-dimensional reflectance field $R(x)$ for a given spectral band is a piecewise-constant step function with a discontinuity at $x=0$.\n$$\nR(x) =\n\\begin{cases}\nR^{w} & \\text{if } x < 0 \\\\\nR^{\\ell} & \\text{if } x \\ge 0\n\\end{cases}\n$$\nThe endmember reflectances are given for the green ($g$) and near-infrared ($n$) bands:\nWater (w): $R_{g}^{w}=0.05$, $R_{n}^{w}=0.01$.\nLand ($\\ell$): $R_{g}^{\\ell}=0.08$, $R_{n}^{\\ell}=0.45$.\n\nThe source Sentinel-2 samples are located at positions $x_k = \\Delta + S \\cdot k = 5 + 10k$ for $k \\in \\mathbb{Z}$, where the sample spacing is $S=10\\,\\mathrm{m}$.\nFor $k \\le -1$, $x_k < 0$, so the samples have water reflectance, $R(x_k)=R^w$.\nFor $k \\ge 0$, $x_k > 0$, so the samples have land reflectance, $R(x_k)=R^\\ell$.\n\nWe are resampling to a target location $x_{\\mathrm{target}}=0$. The resampled reflectance, $R^{\\mathrm{res}}$, is a weighted sum of the source samples:\n$$\nR^{\\mathrm{res}}(x_{\\mathrm{target}}) = \\sum_{k \\in \\mathbb{Z}} R(x_k) h\\left(\\frac{x_{\\mathrm{target}} - x_k}{S}\\right)\n$$\nwhere $h(t)$ is the resampling kernel. With $x_{\\mathrm{target}}=0$ and $S=10$, the argument to the kernel is $t_k = -x_k/10 = -(5+10k)/10 = -0.5-k$.\n\nThe resampling kernels have finite support, so we only need to consider samples near $x=0$. The four nearest samples are at:\n$x_{-2} = -15\\,\\mathrm{m}$ (water), with $t_{-2} = 1.5$\n$x_{-1} = -5\\,\\mathrm{m}$ (water), with $t_{-1} = 0.5$\n$x_{0} = 5\\,\\mathrm{m}$ (land), with $t_{0} = -0.5$\n$x_{1} = 15\\,\\mathrm{m}$ (land), with $t_{1} = -1.5$\n\nWe will now compute the resampled green ($R_g^{\\mathrm{res}}$) and NIR ($R_n^{\\mathrm{res}}$) reflectances for each method.\n\n**1. Nearest-Neighbor (NN) Resampling**\nThis method assigns the value of the nearest source sample to the target location. The target $x_{\\mathrm{target}}=0$ is equidistant from $x_{-1}=-5\\,\\mathrm{m}$ and $x_0=5\\,\\mathrm{m}$. An ambiguity exists in this tie-breaking case. A physically consistent choice is to use the an endmember type corresponding to the target location's classification. Since $x=0$ is defined as land ($x \\ge 0$), we assign the land reflectance values.\n$$\nR^{\\mathrm{res, NN}} = R(x_0) = R^{\\ell}\n$$\nTherefore, the resampled reflectances are:\n$R_{g}^{\\mathrm{NN}} = R_{g}^{\\ell} = 0.08$\n$R_{n}^{\\mathrm{NN}} = R_{n}^{\\ell} = 0.45$\nThis method perfectly preserves the endmember spectral signature but shifts the perceived location of the boundary.\n\n**2. Bilinear (1D Linear) Resampling**\nThe 1D linear interpolation kernel is $h(t) = \\max(0, 1-|t|)$, with support on $|t|<1$. Only samples for which $|t_k|<1$ will contribute. These are $x_{-1}$ ($t_{-1}=0.5$) and $x_0$ ($t_0=-0.5$).\nThe weights are:\n$w_{-1} = h(t_{-1}) = h(0.5) = 1 - 0.5 = 0.5$\n$w_0 = h(t_0) = h(-0.5) = 1 - |-0.5| = 0.5$\nThe resampled reflectance is the weighted average:\n$R^{\\mathrm{res, BL}} = w_{-1}R(x_{-1}) + w_0R(x_0) = 0.5 R^w + 0.5 R^\\ell$.\nFor each band:\n$R_{g}^{\\mathrm{BL}} = 0.5 R_{g}^{w} + 0.5 R_{g}^{\\ell} = 0.5(0.05) + 0.5(0.08) = 0.025 + 0.04 = 0.065$\n$R_{n}^{\\mathrm{BL}} = 0.5 R_{n}^{w} + 0.5 R_{n}^{\\ell} = 0.5(0.01) + 0.5(0.45) = 0.005 + 0.225 = 0.23$\nThis method blurs the edge by creating a mixed pixel with reflectance exactly halfway between the two endmembers.\n\n**3. Cubic Convolution (CC) Resampling**\nThe Keys kernel with $a=-1/2$ is given by:\n$$\nh(t)=\n\\begin{cases}\n1.5|t|^{3}-2.5|t|^{2}+1, & 0\\leq |t|<1\\\\\n-0.5|t|^{3}+2.5|t|^{2}-4|t|+2, & 1\\leq |t|<2\\\\\n0, & |t|\\geq 2\n\\end{cases}\n$$\nThe kernel has support on $|t|<2$, so the four nearest samples ($x_{-2}, x_{-1}, x_0, x_1$) contribute.\nThe weights are calculated for $t_{-2}=1.5$, $t_{-1}=0.5$, $t_0=-0.5$, $t_1=-1.5$. Due to kernel symmetry, $h(t)=h(-t)$.\nFor $|t|=0.5$ (applies to $t_{-1}, t_0$):\n$w_{-1} = w_0 = h(0.5) = 1.5(0.5)^3 - 2.5(0.5)^2 + 1 = 1.5(0.125) - 2.5(0.25) + 1 = 0.1875 - 0.625 + 1 = 0.5625$.\nFor $|t|=1.5$ (applies to $t_{-2}, t_1$):\n$w_{-2} = w_1 = h(1.5) = -0.5(1.5)^3 + 2.5(1.5)^2 - 4(1.5) + 2 = -0.5(3.375) + 2.5(2.25) - 6 + 2 = -1.6875 + 5.625 - 4 = -0.0625$.\nThe resampled reflectance is:\n$R^{\\mathrm{res, CC}} = w_{-2}R(x_{-2}) + w_{-1}R(x_{-1}) + w_0R(x_0) + w_1R(x_1)$\n$R^{\\mathrm{res, CC}} = w_{-2}R^w + w_{-1}R^w + w_0R^\\ell + w_1R^\\ell = (w_{-2}+w_{-1})R^w + (w_0+w_1)R^\\ell$.\nThe total weight on the water endmember is $w_{-2}+w_{-1} = -0.0625 + 0.5625 = 0.5$.\nThe total weight on the land endmember is $w_0+w_1 = 0.5625 - 0.0625 = 0.5$.\nSo, $R^{\\mathrm{res, CC}} = 0.5R^w + 0.5R^\\ell$.\nThis demonstrates that for this perfectly symmetric configuration, the cubic convolution yields the exact same result as bilinear interpolation.\n$R_{g}^{\\mathrm{CC}} = R_{g}^{\\mathrm{BL}} = 0.065$\n$R_{n}^{\\mathrm{CC}} = R_{n}^{\\mathrm{BL}} = 0.23$\n\n**NDWI Bias Calculation**\nThe NDWI is $I = \\frac{R_g-R_n}{R_g+R_n}$. The bias is defined as $B = I^{\\mathrm{res}} - I^w$.\nFirst, we compute the reference NDWI for water:\n$$\nI^w = \\frac{R_{g}^{w}-R_{n}^{w}}{R_{g}^{w}+R_{n}^{w}} = \\frac{0.05 - 0.01}{0.05 + 0.01} = \\frac{0.04}{0.06} = \\frac{2}{3}\n$$\nNow we compute the bias for each resampling method.\n\nBias for NN ($B_{\\mathrm{NN}}$):\n$I_{\\mathrm{NN}} = \\frac{R_{g}^{\\mathrm{NN}}-R_{n}^{\\mathrm{NN}}}{R_{g}^{\\mathrm{NN}}+R_{n}^{\\mathrm{NN}}} = \\frac{0.08 - 0.45}{0.08 + 0.45} = \\frac{-0.37}{0.53}$\n$B_{\\mathrm{NN}} = \\frac{-0.37}{0.53} - \\frac{2}{3} \\approx -0.698113 - 0.666667 = -1.36478\\dots$\nRounding to four significant figures, $B_{\\mathrm{NN}} \\approx -1.365$.\n\nBias for Bilinear ($B_{\\mathrm{BL}}$):\n$I_{\\mathrm{BL}} = \\frac{R_{g}^{\\mathrm{BL}}-R_{n}^{\\mathrm{BL}}}{R_{g}^{\\mathrm{BL}}+R_{n}^{\\mathrm{BL}}} = \\frac{0.065 - 0.23}{0.065 + 0.23} = \\frac{-0.165}{0.295}$\n$B_{\\mathrm{BL}} = \\frac{-0.165}{0.295} - \\frac{2}{3} \\approx -0.559322 - 0.666667 = -1.225989\\dots$\nRounding to four significant figures, $B_{\\mathrm{BL}} \\approx -1.226$.\n\nBias for Cubic Convolution ($B_{\\mathrm{CC}}$):\nSince the resampled reflectances are identical to the bilinear case, the NDWI and the bias are also identical.\n$I_{\\mathrm{CC}} = I_{\\mathrm{BL}}$, so $B_{\\mathrm{CC}} = B_{\\mathrm{BL}} \\approx -1.226$.\nThe biases show that the choice of resampling algorithm significantly impacts the derived index value at a sharp boundary, which is a critical consideration in cross-sensor harmonization and feature extraction.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -1.365 & -1.226 & -1.226 \\end{pmatrix}}\n$$"
        }
    ]
}