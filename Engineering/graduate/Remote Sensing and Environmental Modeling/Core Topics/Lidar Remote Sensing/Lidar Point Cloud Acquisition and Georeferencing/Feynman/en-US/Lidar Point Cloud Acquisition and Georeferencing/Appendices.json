{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any LiDAR measurement is the range, determined by the time-of-flight of a laser pulse. However, this measurement is not perfect; its precision is fundamentally limited by the characteristics of the emitted pulse and the receiver's electronics. This practice delves into the core of LiDAR error analysis by deriving an expression for the single-shot range resolution, combining the effects of laser pulse width and receiver timing jitter to quantify this intrinsic uncertainty .",
            "id": "3824599",
            "problem": "An airborne Light Detection and Ranging (LiDAR) system estimates the range to a target by measuring the time-of-flight of an optical pulse. Let the range estimate be formed by time stamping the received waveform relative to a reference clock and converting elapsed time to distance using the speed of light. Assume the following physically grounded model for the timing uncertainty in a single-shot measurement.\n\n1. The transmitted optical pulse has a finite temporal extent. Model the system’s effective impulse response due to the pulse shape and matched filtering as a zero-mean Gaussian temporal random variable with standard deviation $\\tau$, representing the irreducible timing spread inherited from the pulse’s temporal width.\n\n2. The receiver’s clock and discriminator introduce timing jitter that is statistically independent of the pulse-shape-induced timing spread. Model this receiver timing jitter as a zero-mean Gaussian random variable with standard deviation $\\sigma_{t}$.\n\n3. The time-of-flight estimate is formed by a linear time-stamping operation, and range is obtained from time by the standard time-of-flight mapping based on the speed of light $c$.\n\nDefine the effective range resolution as the one-standard-deviation uncertainty (standard deviation) of a single-shot range estimate, and assume that two independent Gaussian timing uncertainties combine through convolution of their time distributions. Starting only from the time-of-flight relation between distance and travel time and the properties of independent Gaussian random variables under convolution and linear scaling, derive a closed-form analytic expression for the effective range resolution in terms of $c$, $\\tau$, and $\\sigma_{t}$. Provide your final answer as a single simplified analytic expression in terms of $c$, $\\tau$, and $\\sigma_{t}$, with no numerical substitution.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, and objective. It presents a standard, albeit simplified, model of LiDAR ranging uncertainty, providing all necessary definitions and constraints to derive a unique, meaningful solution.\n\nThe problem requires the derivation of the effective range resolution, defined as the one-standard-deviation uncertainty of a single-shot range estimate. This derivation will be based on the provided models for timing uncertainties and the fundamental time-of-flight principle for LiDAR.\n\nLet $T_p$ be the random variable representing the timing uncertainty introduced by the finite temporal extent of the optical pulse and the system's impulse response. As per the problem statement, this is a zero-mean Gaussian random variable with standard deviation $\\tau$. Its probability density function is $\\mathcal{N}(0, \\tau^2)$, and its variance is $Var(T_p) = \\tau^2$.\n\nLet $T_j$ be the random variable representing the timing jitter from the receiver's clock and discriminator. This is also a zero-mean Gaussian random variable, with standard deviation $\\sigma_t$. Its probability density function is $\\mathcal{N}(0, \\sigma_t^2)$, and its variance is $Var(T_j) = \\sigma_t^2$.\n\nThe problem states that these two sources of timing uncertainty are statistically independent. The total timing uncertainty in a single measurement, let's call this random variable $T_{total}$, is the sum of the individual uncertainties:\n$$T_{total} = T_p + T_j$$\n\nA fundamental property of independent Gaussian random variables is that their sum is also a Gaussian random variable. The mean of the sum is the sum of the means, and the variance of the sum is the sum of the variances.\n\nThe mean of the total timing uncertainty is:\n$$E[T_{total}] = E[T_p] + E[T_j] = 0 + 0 = 0$$\n\nThe variance of the total timing uncertainty, due to the independence of $T_p$ and $T_j$, is:\n$$Var(T_{total}) = Var(T_p) + Var(T_j) = \\tau^2 + \\sigma_t^2$$\n\nThe standard deviation of the total timing uncertainty, $\\sigma_{T_{total}}$, is the square root of its variance:\n$$\\sigma_{T_{total}} = \\sqrt{Var(T_{total})} = \\sqrt{\\tau^2 + \\sigma_t^2}$$\n\nNext, we must relate this timing uncertainty to the range uncertainty. The range $R$ measured by a LiDAR system is determined by the round-trip time-of-flight, $t$, of the optical pulse, according to the relation:\n$$R = \\frac{c \\cdot t}{2}$$\nwhere $c$ is the speed of light. The factor of $\\frac{1}{2}$ accounts for the fact that the measured time $t$ corresponds to the pulse traveling to the target and back.\n\nThe measured time-of-flight, $t_{meas}$, can be modeled as the sum of the true, deterministic time-of-flight, $t_{true}$, and the random total timing error, $T_{total}$:\n$$t_{meas} = t_{true} + T_{total}$$\n\nThe estimated range, $R_{est}$, is thus a random variable obtained by applying the time-of-flight formula to the measured time:\n$$R_{est} = \\frac{c \\cdot t_{meas}}{2} = \\frac{c}{2} (t_{true} + T_{total})$$\nExpanding this expression, we get:\n$$R_{est} = \\frac{c \\cdot t_{true}}{2} + \\frac{c}{2} T_{total}$$\nThe term $\\frac{c \\cdot t_{true}}{2}$ is the true range, $R_{true}$, which is a constant for a given measurement. Therefore, the estimated range is:\n$$R_{est} = R_{true} + \\frac{c}{2} T_{total}$$\n\nThe problem defines the effective range resolution as the one-standard-deviation uncertainty of the range estimate, which we denote as $\\sigma_R$. This is $std(R_{est})$. To find this, we first calculate the variance of $R_{est}$. We use the property of variance for a linearly transformed random variable $X$, which states that $Var(aX + b) = a^2 Var(X)$ for constants $a$ and $b$.\n\nIn our case, the random variable is $T_{total}$, the scaling constant is $a = \\frac{c}{2}$, and the additive constant is $b = R_{true}$.\n$$Var(R_{est}) = Var\\left(R_{true} + \\frac{c}{2} T_{total}\\right) = \\left(\\frac{c}{2}\\right)^2 Var(T_{total})$$\nSubstituting the expression for $Var(T_{total})$ we found earlier:\n$$Var(R_{est}) = \\frac{c^2}{4} (\\tau^2 + \\sigma_t^2)$$\n\nThe effective range resolution, $\\sigma_R$, is the standard deviation, which is the square root of the variance:\n$$\\sigma_R = std(R_{est}) = \\sqrt{Var(R_{est})} = \\sqrt{\\frac{c^2}{4} (\\tau^2 + \\sigma_t^2)}$$\n\nFinally, simplifying this expression yields the closed-form analytic expression for the range resolution:\n$$\\sigma_R = \\frac{c}{2} \\sqrt{\\tau^2 + \\sigma_t^2}$$\nThis expression represents the one-standard-deviation uncertainty in a single-shot range measurement, based on the provided parameters.",
            "answer": "$$\\boxed{\\frac{c}{2} \\sqrt{\\tau^2 + \\sigma_{t}^{2}}}$$"
        },
        {
            "introduction": "Once the range to a target is known, we must determine its precise direction. Before georeferencing to an Earth-fixed frame, this line-of-sight vector must be accurately defined within the scanner's own coordinate system. This exercise challenges you to model the complex internal geometry of a scanning LiDAR, applying the physical law of reflection to derive the true outgoing beam direction and critically evaluate the accuracy of a simplified model often used in sensor calibration .",
            "id": "3824516",
            "problem": "A Light Detection and Ranging (LiDAR) scanner uses a planar oscillating mirror to deflect a laser beam emitted along a fixed axis in the scanner frame. Consider the scanner coordinate frame $\\mathcal{S}$ with axes $(x_{\\mathcal{S}}, y_{\\mathcal{S}}, z_{\\mathcal{S}})$, where the incident ray direction is the unit vector $d_{\\mathrm{in}} = [0,\\,0,\\,1]^{\\top}$. The mirror’s nominal unit normal at zero scan is $n_{0} = [\\sin\\beta,\\,0,\\,\\cos\\beta]^{\\top}$, with $\\beta = \\pi/4$. The mirror rotates about the $y_{\\mathcal{S}}$-axis by a scan angle $\\theta$, and the mirror mount has a small fixed elevation offset $\\delta$ realized as a rotation about the $x_{\\mathcal{S}}$-axis. The mirror normal under scan is therefore $n(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(\\theta)\\,n_{0}$, where $R_{x}$ and $R_{y}$ are standard right-handed rotation matrices about the $x$ and $y$ axes, respectively. The outgoing beam direction (the unit line-of-sight vector) is obtained from the law of reflection: $u_{s}(\\theta,\\delta) = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n(\\theta,\\delta))\\,n(\\theta,\\delta)$.\n\nA sensor calibration model used in georeferencing approximates the mapping from mirror scan angle to outgoing direction by applying a yaw rotation of $2\\theta$ about $y_{\\mathcal{S}}$ to the nominal reflected direction at zero scan, followed by the elevation offset $\\delta$ about $x_{\\mathcal{S}}$. That is, with $u_{0} = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n_{0})\\,n_{0}$, the calibration-predicted unit vector is $u_{\\mathrm{cal}}(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(2\\theta)\\,u_{0}$.\n\nStarting from the fundamental law of reflection and the definitions of $R_{x}$ and $R_{y}$, derive the explicit expression for $u_{s}(\\theta,\\delta)$ in the scanner frame, and then form $u_{\\mathrm{cal}}(\\theta,\\delta)$. Using these, compute the angular residual $\\Delta\\varphi(\\theta,\\delta)$ between $u_{s}$ and $u_{\\mathrm{cal}}$ defined by $\\Delta\\varphi(\\theta,\\delta) = \\arccos\\!\\big(u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta)\\big)$. Evaluate $\\Delta\\varphi$ for $\\theta = 30^{\\circ}$ and $\\delta = 2^{\\circ}$, and express the final angle in degrees. Round your answer to four significant figures.",
            "solution": "The principal task is to determine the angular residual $\\Delta\\varphi(\\theta,\\delta)$ between the physically correct line-of-sight vector, $u_{s}(\\theta,\\delta)$, and an approximate vector derived from a calibration model, $u_{\\mathrm{cal}}(\\theta,\\delta)$. The residual is defined by $\\Delta\\varphi(\\theta,\\delta) = \\arccos\\!\\big(u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta)\\big)$. The analysis requires deriving explicit expressions for both vectors, computing their dot product, and then evaluating the result for the given angles $\\theta = 30^{\\circ}$ and $\\delta = 2^{\\circ}$.\n\nFirst, we establish the fundamental mathematical entities. The standard right-handed rotation matrices about the $x$- and $y$-axes are given by:\n$$ R_{x}(\\alpha) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{pmatrix}, \\quad R_{y}(\\alpha) = \\begin{pmatrix} \\cos\\alpha & 0 & \\sin\\alpha \\\\ 0 & 1 & 0 \\\\ -\\sin\\alpha & 0 & \\cos\\alpha \\end{pmatrix} $$\nThe incident laser beam direction is $d_{\\mathrm{in}} = [0,\\,0,\\,1]^{\\top}$. The nominal mirror normal is $n_{0} = [\\sin\\beta,\\,0,\\,\\cos\\beta]^{\\top}$ with $\\beta = \\pi/4$.\nSubstituting $\\beta = \\pi/4$, we get $\\sin(\\pi/4) = 1/\\sqrt{2}$ and $\\cos(\\pi/4) = 1/\\sqrt{2}$. Thus,\n$$ n_{0} = \\begin{pmatrix} 1/\\sqrt{2} \\\\ 0 \\\\ 1/\\sqrt{2} \\end{pmatrix} $$\nWe begin by calculating the nominal reflected direction at zero scan, $u_{0}$, using the law of reflection:\n$$ u_{0} = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n_{0})\\,n_{0} $$\nThe dot product is $d_{\\mathrm{in}}\\cdot n_{0} = (0)(1/\\sqrt{2}) + (0)(0) + (1)(1/\\sqrt{2}) = 1/\\sqrt{2}$.\nSubstituting this into the expression for $u_0$:\n$$ u_{0} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - 2\\left(\\frac{1}{\\sqrt{2}}\\right) \\begin{pmatrix} 1/\\sqrt{2} \\\\ 0 \\\\ 1/\\sqrt{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n\nNext, we derive the expression for the physically correct reflected vector $u_{s}(\\theta,\\delta)$. This requires first finding the mirror normal under scan, $n(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(\\theta)\\,n_{0}$.\n$$ R_{y}(\\theta)n_{0} = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} 1/\\sqrt{2} \\\\ 0 \\\\ 1/\\sqrt{2} \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ 0 \\\\ \\cos\\theta - \\sin\\theta \\end{pmatrix} $$\n$$ n(\\theta,\\delta) = R_{x}(\\delta)(R_{y}(\\theta)n_{0}) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\delta & -\\sin\\delta \\\\ 0 & \\sin\\delta & \\cos\\delta \\end{pmatrix} \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ 0 \\\\ \\cos\\theta - \\sin\\theta \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ -\\sin\\delta(\\cos\\theta - \\sin\\theta) \\\\ \\cos\\delta(\\cos\\theta - \\sin\\theta) \\end{pmatrix} $$\nThe dot product with the incident ray is $d_{\\mathrm{in}}\\cdot n(\\theta,\\delta) = n_z(\\theta,\\delta) = \\frac{1}{\\sqrt{2}}\\cos\\delta(\\cos\\theta - \\sin\\theta)$.\nNow, we compute $u_{s}(\\theta,\\delta) = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n(\\theta,\\delta))\\,n(\\theta,\\delta)$:\n$$ u_{s} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - 2\\left(\\frac{1}{\\sqrt{2}}\\cos\\delta(\\cos\\theta - \\sin\\theta)\\right) \\left(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ -\\sin\\delta(\\cos\\theta - \\sin\\theta) \\\\ \\cos\\delta(\\cos\\theta - \\sin\\theta) \\end{pmatrix}\\right) $$\n$$ u_{s} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - \\cos\\delta(\\cos\\theta - \\sin\\theta) \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ -\\sin\\delta(\\cos\\theta - \\sin\\theta) \\\\ \\cos\\delta(\\cos\\theta - \\sin\\theta) \\end{pmatrix} $$\nThe components of $u_s$ are:\n$(u_{s})_x = -\\cos\\delta(\\cos\\theta - \\sin\\theta)(\\cos\\theta + \\sin\\theta) = -\\cos\\delta(\\cos^2\\theta - \\sin^2\\theta) = -\\cos\\delta\\cos(2\\theta)$.\n$(u_{s})_y = \\sin\\delta\\cos\\delta(\\cos\\theta - \\sin\\theta)^2 = \\sin\\delta\\cos\\delta(\\cos^2\\theta - 2\\sin\\theta\\cos\\theta + \\sin^2\\theta) = \\frac{1}{2}\\sin(2\\delta)(1 - \\sin(2\\theta))$.\n$(u_{s})_z = 1 - \\cos^2\\delta(\\cos\\theta - \\sin\\theta)^2 = 1 - \\cos^2\\delta(1 - \\sin(2\\theta)) = \\sin^2\\delta + \\cos^2\\delta\\sin(2\\theta)$.\nSo, $u_{s}(\\theta,\\delta) = \\begin{pmatrix} -\\cos\\delta\\cos(2\\theta) \\\\ \\frac{1}{2}\\sin(2\\delta)(1 - \\sin(2\\theta)) \\\\ \\sin^2\\delta + \\cos^2\\delta\\sin(2\\theta) \\end{pmatrix}$.\n\nNow, we derive the calibration-predicted vector $u_{\\mathrm{cal}}(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(2\\theta)\\,u_{0}$.\n$$ R_{y}(2\\theta)u_{0} = \\begin{pmatrix} \\cos(2\\theta) & 0 & \\sin(2\\theta) \\\\ 0 & 1 & 0 \\\\ -\\sin(2\\theta) & 0 & \\cos(2\\theta) \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\cos(2\\theta) \\\\ 0 \\\\ \\sin(2\\theta) \\end{pmatrix} $$\n$$ u_{\\mathrm{cal}}(\\theta,\\delta) = R_{x}(\\delta) (R_{y}(2\\theta)u_{0}) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\delta & -\\sin\\delta \\\\ 0 & \\sin\\delta & \\cos\\delta \\end{pmatrix} \\begin{pmatrix} -\\cos(2\\theta) \\\\ 0 \\\\ \\sin(2\\theta) \\end{pmatrix} = \\begin{pmatrix} -\\cos(2\\theta) \\\\ -\\sin\\delta\\sin(2\\theta) \\\\ \\cos\\delta\\sin(2\\theta) \\end{pmatrix} $$\n\nThe next step is to compute the dot product $u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta)$.\n$$ (u_s \\cdot u_{\\mathrm{cal}}) = (-\\cos\\delta\\cos(2\\theta))(-\\cos(2\\theta)) + \\left(\\frac{1}{2}\\sin(2\\delta)(1 - \\sin(2\\theta))\\right)(-\\sin\\delta\\sin(2\\theta)) + (\\sin^2\\delta + \\cos^2\\delta\\sin(2\\theta))(\\cos\\delta\\sin(2\\theta)) $$\nLet's expand and simplify this expression term by term:\nTerm 1: $\\cos\\delta\\cos^2(2\\theta)$.\nTerm 2: Using $\\frac{1}{2}\\sin(2\\delta) = \\sin\\delta\\cos\\delta$, this becomes $-\\sin^2\\delta\\cos\\delta\\sin(2\\theta)(1 - \\sin(2\\theta)) = -\\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin^2(2\\theta)$.\nTerm 3: $\\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\cos^3\\delta\\sin^2(2\\theta)$.\nSumming all terms:\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) - \\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin^2(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\cos^3\\delta\\sin^2(2\\theta) $$\nThe terms $-\\sin^2\\delta\\cos\\delta\\sin(2\\theta)$ and $+\\sin^2\\delta\\cos\\delta\\sin(2\\theta)$ cancel.\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin^2(2\\theta) + \\cos^3\\delta\\sin^2(2\\theta) $$\nFactor out $\\cos\\delta$ from the first term and $\\cos\\delta\\sin^2(2\\theta)$ from the last two:\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) + (\\sin^2\\delta + \\cos^2\\delta)\\cos\\delta\\sin^2(2\\theta) $$\nUsing the identity $\\sin^2\\delta + \\cos^2\\delta = 1$:\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) + \\cos\\delta\\sin^2(2\\theta) = \\cos\\delta(\\cos^2(2\\theta) + \\sin^2(2\\theta)) $$\nUsing the identity $\\cos^2(2\\theta) + \\sin^2(2\\theta) = 1$:\n$$ u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta) = \\cos\\delta $$\nThis remarkably simple result can be understood geometrically. The calibration model $u_{\\mathrm{cal}} = R_x(\\delta) R_y(2\\theta) u_0$ is equivalent to $R_x(\\delta) u_s(\\theta,0)$. Using the identity for reflections behaving under rotation, $R_x(\\delta) u_s(\\theta,0) = R_x(\\delta) \\mathrm{Refl}_{R_y(\\theta)n_0}(d_{in}) = \\mathrm{Refl}_{R_x(\\delta)R_y(\\theta)n_0}(R_x(\\delta)d_{in})$. The true vector is $u_s(\\theta,\\delta) = \\mathrm{Refl}_{R_x(\\delta)R_y(\\theta)n_0}(d_{in})$. Since reflection is an isometry, it preserves the angle between vectors. Therefore, the angle between $u_s$ and $u_{\\mathrm{cal}}$ is equal to the angle between the pre-image vectors $d_{in}$ and $R_x(\\delta)d_{in}$. Their dot product is $d_{in} \\cdot (R_x(\\delta)d_{in}) = [0,0,1]^\\top \\cdot [0, -\\sin\\delta, \\cos\\delta]^\\top = \\cos\\delta$.\n\nThe angular residual is thus:\n$$ \\Delta\\varphi(\\theta,\\delta) = \\arccos(u_s \\cdot u_{\\mathrm{cal}}) = \\arccos(\\cos\\delta) $$\nFor any physically realistic small offset angle $\\delta$, we can take the principal value, so $\\Delta\\varphi(\\theta,\\delta) = \\delta$.\nThe residual angle is independent of the scan angle $\\theta$ and is equal to the elevation offset angle $\\delta$.\n\nThe problem asks for the evaluation at $\\theta = 30^{\\circ}$ and $\\delta = 2^{\\circ}$.\n$$ \\Delta\\varphi = 2^{\\circ} $$\nRounding to four significant figures gives $2.000^{\\circ}$.",
            "answer": "$$ \\boxed{2.000} $$"
        },
        {
            "introduction": "To transform a point from the sensor's frame into a global coordinate system, the platform's attitude (orientation) at the exact moment of measurement is critical. Since the IMU samples attitude at a different frequency than the LiDAR emits pulses, a robust interpolation scheme is essential for accurate georeferencing. This hands-on coding practice guides you through implementing spherical linear interpolation (Slerp) for unit quaternions, the gold standard for rotating orientations, and quantifying the resulting interpolation error against a known ground truth .",
            "id": "3824565",
            "problem": "In remote sensing and environmental modeling, Light Detection and Ranging (LiDAR) requires accurate georeferencing of each emitted laser pulse to the Earth-fixed frame. This georeferencing depends on the platform attitude provided by the Inertial Measurement Unit (IMU). Because IMU attitude is sampled at discrete epochs while LiDAR firing times are asynchronous, an interpolation scheme on the rotation manifold is required. Represent attitude as unit quaternions and interpolate between IMU epochs using spherical linear interpolation on the unit quaternion hypersphere. Quantify interpolation error by comparing the interpolated attitude at LiDAR firing times to a known, analytically defined ground-truth attitude function.\n\nStart from the following fundamental base:\n- Rotations in three dimensions form the special orthogonal group $\\mathrm{SO}(3)$. A unit quaternion $q(t)$ is a point on the $3$-sphere $S^3$ representing an element of $\\mathrm{SO}(3)$, with the unit-norm constraint $\\lVert q(t) \\rVert = 1$. Quaternions $q$ and $-q$ represent the same physical rotation.\n- The shortest rotation between two unit quaternions corresponds to the great-circle arc on $S^3$. Interpolation along this arc maintains unit norm and constant angular speed.\n- The angular difference between two rotations can be measured by the angle of their relative rotation, which is the angle associated with the quaternion $q_{\\text{rel}} = q_{\\text{est}}^{-1} q_{\\text{true}}$.\n\nYour task is to implement quaternion spherical linear interpolation between IMU epochs to align with LiDAR firing times and compute mean angular interpolation error for a set of test cases. All computations of trigonometric functions must be performed in radians internally. The requested output is angular errors in degrees. The rotation convention to construct quaternions from Euler angles must be the standard yaw–pitch–roll about the $z$–$y$–$x$ axes, applied in that order.\n\nDefinitions and requirements:\n- A unit quaternion is an ordered tuple $q = (w, x, y, z)$ with $\\lVert q \\rVert = 1$, where $w$ is the scalar part and $(x, y, z)$ is the vector part.\n- Use the yaw–pitch–roll angles $(\\psi(t), \\theta(t), \\phi(t))$ to define ground-truth orientation as an analytic function of time $t$.\n- Given IMU epoch times $t_0, t_1, \\dots$ and LiDAR firing times $\\tau_1, \\tau_2, \\dots$, for each $\\tau$ in an interval $[t_k, t_{k+1}]$, interpolate attitude between $q(t_k)$ and $q(t_{k+1})$ using spherical linear interpolation, and compare to the ground-truth quaternion at time $\\tau$.\n\nAngle unit specification:\n- Internally compute angles in radians.\n- Express final mean angular interpolation errors in degrees, rounded to six decimal places.\n\nError computation:\n- For each LiDAR firing time $\\tau$, compute the interpolated quaternion $\\hat{q}(\\tau)$ and the ground-truth quaternion $q(\\tau)$. Form the relative rotation $q_{\\text{rel}}(\\tau) = \\hat{q}(\\tau)^{-1} q(\\tau)$ and compute its rotation angle $\\Delta(\\tau)$.\n- For each test case, report the mean of $\\Delta(\\tau)$ across all LiDAR firing times in degrees.\n\nTest suite:\n- Case A (smooth motion, happy path):\n  - IMU epoch times in seconds: $0.0, 0.5, 1.0, 1.5, 2.0$.\n  - LiDAR firing times in seconds: $0.05, 0.10, 0.15, \\dots, 1.95$ in increments of $0.05$ (inclusive).\n  - Ground truth yaw, pitch, roll in degrees: $\\psi(t) = 12 t$, $\\theta(t) = 2 \\sin(2 \\pi t)$, $\\phi(t) = 0.5 \\cos(\\pi t)$.\n- Case B (antipodal quaternion sign edge case):\n  - IMU epoch times in seconds: $0.0, 1.0$.\n  - LiDAR firing times in seconds: $0.0, 0.1, 0.2, \\dots, 1.0$ in increments of $0.1$ (inclusive).\n  - Ground truth yaw, pitch, roll in degrees: $\\psi(t) = 179$, $\\theta(t) = 0$, $\\phi(t) = 0$ (constant orientation).\n  - IMU quaternions: set $q(0.0)$ equal to the ground truth at $t = 0.0$; set $q(1.0)$ to the negative of the ground truth quaternion at $t = 1.0$ to simulate the sign ambiguity, which represents the same rotation.\n- Case C (boundary condition and very small interval):\n  - IMU epoch times in seconds: $0.0, 0.001$.\n  - LiDAR firing times in seconds: $0.0, 0.00025, 0.0005, 0.00075, 0.001$.\n  - Ground truth yaw, pitch, roll in degrees: $\\psi(t) = 100 t$, $\\theta(t) = 0$, $\\phi(t) = 0$.\n\nProgram requirements:\n- Construct ground-truth quaternions $q(t)$ from the specified yaw–pitch–roll functions for each test case.\n- For each LiDAR time $\\tau$, find the adjacent IMU epoch interval $[t_k, t_{k+1}]$ such that $t_k \\le \\tau \\le t_{k+1}$ and interpolate with spherical linear interpolation between $q(t_k)$ and $q(t_{k+1})$.\n- Compute $\\Delta(\\tau)$ in radians from the relative quaternion and convert it to degrees.\n- For each test case, compute the mean of $\\Delta(\\tau)$ over all LiDAR firing times.\n- The output must be a single line containing the three mean errors for Cases A, B, and C, in degrees, rounded to six decimal places, as a comma-separated list enclosed in square brackets (for example, $[\\text{A},\\text{B},\\text{C}]$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[0.012345,0.000001,0.000100]$). The values must be floats as specified. No other output is permitted.",
            "solution": "The rotation of a rigid body in three dimensions can be represented by a unit quaternion $q \\in S^3 \\subset \\mathbb{R}^4$ that maps to an element of the special orthogonal group $\\mathrm{SO}(3)$. The quaternion encodes a rotation angle $\\theta$ about a unit axis $\\hat{\\mathbf{u}}$, with the correspondence $q = (\\cos(\\theta/2), \\sin(\\theta/2) \\hat{\\mathbf{u}})$, ensuring the unit-norm constraint $\\lVert q \\rVert = 1$. Two quaternions $q$ and $-q$ represent the same physical rotation because they encode the same axis-angle pair with a sign flip across $S^3$.\n\nWe require an interpolation method that preserves unit norm and follows the shortest path on $S^3$ between two orientations, i.e., the great-circle arc. Spherical linear interpolation (Slerp) arises from the geodesic structure of $S^3$. Given two unit quaternions $q_0$ and $q_1$ with dot product $d = q_0 \\cdot q_1$, the angle between them on $S^3$ is $\\theta = \\arccos(d)$ for $d \\in [-1, 1]$. The geodesic arc parameterized by $u \\in [0, 1]$ is constructed such that the interpolated quaternion $q(u)$ satisfies $q(0) = q_0$, $q(1) = q_1$, maintains unit norm, and evolves with constant angular velocity along the arc.\n\nTo ensure the shortest path, if $d < 0$ we flip the second quaternion $q_1 \\leftarrow -q_1$ so that the dot product becomes nonnegative, $d \\leftarrow -d$, because $q_1$ and $-q_1$ represent identical rotations but choose the nearer point on $S^3$. For the general case $|d| < 1$ and not too close to $\\pm 1$, the interpolation is constructed from the linear combination in the tangent space mapped back via spherical trigonometry:\n$$\nq(u) = \\frac{\\sin((1-u)\\theta)}{\\sin(\\theta)} q_0 + \\frac{\\sin(u \\theta)}{\\sin(\\theta)} q_1,\n$$\nwhich is unit-norm by construction since it lies on the great circle. If $d$ is very close to $1$, i.e., $\\theta \\approx 0$, the limit reduces to the straight line in $\\mathbb{R}^4$ followed by renormalization:\n$$\nq(u) \\approx \\frac{(1-u) q_0 + u q_1}{\\lVert (1-u) q_0 + u q_1 \\rVert}.\n$$\nThis yields numerical stability for near-coincident rotations.\n\nTo quantify interpolation error at a LiDAR firing time $\\tau$ within an IMU epoch interval $[t_k, t_{k+1}]$, set $u = \\frac{\\tau - t_k}{t_{k+1} - t_k} \\in [0,1]$, compute $\\hat{q}(\\tau) = \\mathrm{Slerp}(q(t_k), q(t_{k+1}), u)$, and compare to the ground-truth quaternion $q(\\tau)$. The relative rotation quaternion is\n$$\nq_{\\text{rel}}(\\tau) = \\hat{q}(\\tau)^{-1} q(\\tau),\n$$\nwhere for unit quaternions the inverse is the conjugate: $q^{-1} = (w, -x, -y, -z)$. The rotation angle of $q_{\\text{rel}}$ is\n$$\n\\Delta(\\tau) = 2 \\arctan2\\left(\\sqrt{x^2 + y^2 + z^2}, \\, |w|\\right),\n$$\nwhich equals $2 \\arccos(w)$ with appropriate clamping for numerical stability. We compute $\\Delta(\\tau)$ in radians, convert it to degrees by multiplication with $\\frac{180}{\\pi}$, and average over all LiDAR firing times to produce a scalar mean error per test case.\n\nFor constructing ground-truth quaternions from yaw–pitch–roll $(\\psi, \\theta, \\phi)$, we adopt the standard $z$–$y$–$x$ rotation convention (yaw about $z$, then pitch about $y$, then roll about $x$). Let $q_z(\\psi)$, $q_y(\\theta)$, and $q_x(\\phi)$ be the unit quaternions for pure-axis rotations. The composed rotation quaternion is\n$$\nq(\\psi, \\theta, \\phi) = q_z(\\psi) \\, q_y(\\theta) \\, q_x(\\phi),\n$$\nusing the Hamilton product for quaternion multiplication. Each elemental quaternion is defined by its axis-angle: for axis $\\hat{\\mathbf{e}}$ and angle $\\alpha$, $q = \\left( \\cos(\\alpha/2), \\, \\sin(\\alpha/2) \\hat{\\mathbf{e}} \\right)$, where $\\hat{\\mathbf{e}}$ is one of the Cartesian axes. Numerical implementation proceeds by converting degrees to radians for all trigonometric computations.\n\nThe algorithm:\n- Define quaternion operations: normalization, Hamilton product, conjugate/inverse, dot product.\n- Implement Slerp with dot-product sign handling and linear fallback near-zero angle.\n- Implement conversion from yaw–pitch–roll angles to a unit quaternion under the $z$–$y$–$x$ convention.\n- For each test case, define IMU epochs and LiDAR firing times as specified; define ground-truth yaw–pitch–roll angle functions in degrees, convert to radians to compute quaternions.\n- For Case A: IMU epochs at $0.0, 0.5, 1.0, 1.5, 2.0$ seconds; LiDAR times in increments of $0.05$ seconds; ground truth angles $\\psi(t) = 12 t$, $\\theta(t) = 2 \\sin(2 \\pi t)$, $\\phi(t) = 0.5 \\cos(\\pi t)$ (degrees).\n- For Case B: IMU epochs at $0.0, 1.0$ seconds with $q(1.0)$ set to the negative of the ground-truth quaternion at $t = 1.0$ to simulate the antipodal sign; LiDAR times in increments of $0.1$ seconds; ground truth constant angles $\\psi(t) = 179$, $\\theta(t) = 0$, $\\phi(t) = 0$ (degrees).\n- For Case C: IMU epochs at $0.0, 0.001$ seconds; LiDAR times at $0.0, 0.00025, 0.0005, 0.00075, 0.001$ seconds; ground truth angles $\\psi(t) = 100 t$, $\\theta(t) = 0$, $\\phi(t) = 0$ (degrees).\n- For each LiDAR time $\\tau$, bracket by IMU epochs, compute $u$, interpolate $\\hat{q}(\\tau)$, compute $q(\\tau)$, form $q_{\\text{rel}}(\\tau)$, compute $\\Delta(\\tau)$ in radians, convert to degrees, and average.\n\nFinally, output the mean errors for Cases A, B, and C in a single line as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places. This program design adheres to the rotation geometry on $S^3$ and quantifies how quaternion spherical interpolation aligns IMU attitude with LiDAR event times, demonstrating effects of sampling, sign ambiguity, and boundary conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef quat_normalize(q: np.ndarray) -> np.ndarray:\n    \"\"\"Normalize a quaternion to unit norm.\"\"\"\n    norm = np.linalg.norm(q)\n    if norm == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n    return q / norm\n\ndef quat_multiply(q1: np.ndarray, q2: np.ndarray) -> np.ndarray:\n    \"\"\"Hamilton product of two quaternions (w,x,y,z).\"\"\"\n    w1, x1, y1, z1 = q1\n    w2, x2, y2, z2 = q2\n    w = w1*w2 - x1*x2 - y1*y2 - z1*z2\n    x = w1*x2 + x1*w2 + y1*z2 - z1*y2\n    y = w1*y2 - x1*z2 + y1*w2 + z1*x2\n    z = w1*z2 + x1*y2 - y1*x2 + z1*w2\n    return np.array([w, x, y, z])\n\ndef quat_conjugate(q: np.ndarray) -> np.ndarray:\n    \"\"\"Conjugate of a quaternion (inverse for unit quaternion).\"\"\"\n    w, x, y, z = q\n    return np.array([w, -x, -y, -z])\n\ndef quat_dot(q1: np.ndarray, q2: np.ndarray) -> float:\n    \"\"\"Dot product of two quaternions.\"\"\"\n    return float(np.dot(q1, q2))\n\ndef slerp(q0: np.ndarray, q1: np.ndarray, u: float) -> np.ndarray:\n    \"\"\"\n    Spherical linear interpolation between unit quaternions q0 and q1 for parameter u in [0,1].\n    Handles antipodal quaternions and near-zero angles with linear fallback.\n    \"\"\"\n    q0 = quat_normalize(q0)\n    q1 = quat_normalize(q1)\n    dot = quat_dot(q0, q1)\n\n    # If dot is negative, flip sign of q1 to ensure shortest path\n    if dot < 0.0:\n        q1 = -q1\n        dot = -dot\n\n    # Clamp dot for numerical stability\n    dot = max(min(dot, 1.0), -1.0)\n\n    # If the quaternions are very close, use linear interpolation\n    if dot > 0.9995:\n        q = (1.0 - u) * q0 + u * q1\n        return quat_normalize(q)\n\n    theta = np.arccos(dot)\n    sin_theta = np.sin(theta)\n    a = np.sin((1.0 - u) * theta) / sin_theta\n    b = np.sin(u * theta) / sin_theta\n    q = a * q0 + b * q1\n    return quat_normalize(q)\n\ndef euler_zyx_to_quat(roll: float, pitch: float, yaw: float) -> np.ndarray:\n    \"\"\"\n    Convert yaw-pitch-roll (ZYX order) angles in radians to a unit quaternion.\n    yaw about z, then pitch about y, then roll about x.\n    \"\"\"\n    cz = np.cos(yaw / 2.0)\n    sz = np.sin(yaw / 2.0)\n    cy = np.cos(pitch / 2.0)\n    sy = np.sin(pitch / 2.0)\n    cx = np.cos(roll / 2.0)\n    sx = np.sin(roll / 2.0)\n\n    # q = qz * qy * qx\n    qz = np.array([cz, 0.0, 0.0, sz])\n    qy = np.array([cy, 0.0, sy, 0.0])\n    qx = np.array([cx, sx, 0.0, 0.0])\n\n    q = quat_multiply(quat_multiply(qz, qy), qx)\n    return quat_normalize(q)\n\ndef quat_angle_deg(q_est: np.ndarray, q_true: np.ndarray) -> float:\n    \"\"\"\n    Compute the angular difference between two unit quaternions in degrees.\n    \"\"\"\n    q_est = quat_normalize(q_est)\n    q_true = quat_normalize(q_true)\n    q_rel = quat_multiply(quat_conjugate(q_est), q_true)\n    w, x, y, z = q_rel\n    # Clamp w to valid range for arccos\n    w = max(min(w, 1.0), -1.0)\n    # Robust relative angle using atan2 of vector norm and scalar part\n    angle_rad = 2.0 * np.arctan2(np.linalg.norm([x, y, z]), abs(w))\n    angle_deg = angle_rad * (180.0 / np.pi)\n    return angle_deg\n\ndef ground_truth_case_A(t: float) -> np.ndarray:\n    \"\"\"\n    Case A ground truth quaternion at time t (seconds).\n    Angles: yaw=12*t deg, pitch=2*sin(2*pi*t) deg, roll=0.5*cos(pi*t) deg.\n    \"\"\"\n    yaw_deg = 12.0 * t\n    pitch_deg = 2.0 * np.sin(2.0 * np.pi * t)\n    roll_deg = 0.5 * np.cos(np.pi * t)\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef ground_truth_case_B(t: float) -> np.ndarray:\n    \"\"\"\n    Case B ground truth quaternion at time t (seconds).\n    Constant orientation: yaw=179 deg, pitch=0 deg, roll=0 deg.\n    \"\"\"\n    yaw_deg = 179.0\n    pitch_deg = 0.0\n    roll_deg = 0.0\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef ground_truth_case_C(t: float) -> np.ndarray:\n    \"\"\"\n    Case C ground truth quaternion at time t (seconds).\n    Yaw=100*t deg, pitch=0 deg, roll=0 deg.\n    \"\"\"\n    yaw_deg = 100.0 * t\n    pitch_deg = 0.0\n    roll_deg = 0.0\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef mean_interpolation_error_deg(imu_times, lidar_times, gt_func, imu_quat_override=None):\n    \"\"\"\n    Compute mean angular error in degrees by Slerp interpolation between IMU epoch quaternions.\n    Optionally override IMU quaternions for edge-case simulation.\n    \"\"\"\n    # Compute IMU quaternions from ground truth unless overridden\n    imu_quats = []\n    for t in imu_times:\n        if imu_quat_override is not None and t in imu_quat_override:\n            imu_quats.append(imu_quat_override[t])\n        else:\n            imu_quats.append(gt_func(t))\n    imu_quats = [quat_normalize(q) for q in imu_quats]\n\n    # Build intervals for bracketing\n    errors = []\n    for tau in lidar_times:\n        # Find bracketing IMU indices\n        if tau <= imu_times[0]:\n            k = 0\n        elif tau >= imu_times[-1]:\n            k = len(imu_times) - 2\n        else:\n            # k such that imu_times[k] <= tau <= imu_times[k+1]\n            k = max(i for i in range(len(imu_times) - 1) if imu_times[i] <= tau)\n            # ensure tau <= imu_times[k+1]\n            if tau > imu_times[k+1]:\n                k = k + 1 if k + 1 < len(imu_times) - 1 else k\n\n        t0 = imu_times[k]\n        t1 = imu_times[k+1]\n        q0 = imu_quats[k]\n        q1 = imu_quats[k+1]\n        # Handle exact epoch times\n        if t1 == t0:\n            u = 0.0\n        else:\n            u = (tau - t0) / (t1 - t0)\n            u = max(0.0, min(1.0, u))\n        q_interp = slerp(q0, q1, u)\n        q_true = gt_func(tau)\n        err_deg = quat_angle_deg(q_interp, q_true)\n        errors.append(err_deg)\n    return float(np.mean(errors))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    imu_times_A = [0.0, 0.5, 1.0, 1.5, 2.0]\n    lidar_times_A = [round(x, 2) for x in np.arange(0.05, 2.0, 0.05)]\n    # Case B\n    imu_times_B = [0.0, 1.0]\n    lidar_times_B = [round(x, 1) for x in np.arange(0.0, 1.0 + 1e-12, 0.1)]\n    # Override IMU quaternions: q(1.0) = -q_true(1.0)\n    imu_quat_override_B = {\n        0.0: ground_truth_case_B(0.0),\n        1.0: -ground_truth_case_B(1.0)\n    }\n    # Case C\n    imu_times_C = [0.0, 0.001]\n    lidar_times_C = [0.0, 0.00025, 0.0005, 0.00075, 0.001]\n\n    results = []\n    # Case A mean error\n    err_A = mean_interpolation_error_deg(imu_times_A, lidar_times_A, ground_truth_case_A)\n    # Case B mean error with antipodal override\n    err_B = mean_interpolation_error_deg(imu_times_B, lidar_times_B, ground_truth_case_B, imu_quat_override=imu_quat_override_B)\n    # Case C mean error\n    err_C = mean_interpolation_error_deg(imu_times_C, lidar_times_C, ground_truth_case_C)\n\n    # Round to six decimal places as required\n    formatted = [f\"{x:.6f}\" for x in [err_A, err_B, err_C]]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}