{
    "hands_on_practices": [
        {
            "introduction": "本实践将引导您实现一个基础的、基于规则的生境适宜性模型。这种方法，常被称为“生态位包络模型”，通过为物种设定明确的环境阈值（如温度和降水范围）来界定其适宜的生境。通过本练习，您将掌握栅格数据分析的基本原理，并学习如何将多个环境图层组合成一个综合的适宜性指数地图。",
            "id": "3818680",
            "problem": "给定一个景观的网格化环境数据，这些数据由形状相同的数组表示，分别对应气温、年降水量和生物排斥因子。目标是计算逐像元的生境适宜度指数，根据一个阈值对像元进行分类，并总结满足该阈值的景观比例。适宜度指数必须严格根据以下基本原则构建。\n\n基本原理和定义：\n- 令像元位置由符号 $x$ 表示。每个像元包含三个值：气温 $T(x)$、年降水量 $P(x)$ 和生物排斥因子 $b(x)$。\n- 该物种受气候限制，适宜的温度区间为闭区间 $[10,30]$ 摄氏度，适宜的降水量区间为闭区间 $[500,1500]$ 毫米。所有温度都必须以摄氏度处理和报告，所有降水量都必须以毫米处理和报告。\n- 使用指示函数定义。对于任何陈述 $A$，定义指示函数 $\\mathbb{I}(A)$ 为：如果 $A$ 为真，则 $\\mathbb{I}(A)=1$；否则 $\\mathbb{I}(A)=0$。\n- 生物排斥由 $b(x)$ 表示，作为单位区间 $[0,1]$ 内的一个不可用比例，其中 $b(x)=0$ 表示没有生物排斥，$b(x)=1$ 表示完全排斥。如果在进一步计算之前，任何 $b(x)$ 的值超出了 $[0,1]$ 的范围，则需将其裁剪到 $[0,1]$ 区间内。\n- 无效或缺失的像元由特殊值 $\\mathrm{NaN}$ (非数值) 表示。一个像元 $x$ 被认为是有效的，当且仅当 $T(x)$、$P(x)$ 和 $b(x)$ 都是有限实数 (即，没有一个是 $\\mathrm{NaN}$)。无效像元必须在任何分数计算的分子和分母中被排除。\n\n任务：\n1. 对于每个像元 $x$，通过区间约束的交集定义一个气候可行性指示函数：\n   - 温度可行性指示函数为 $\\mathbb{I}\\left(10 \\leq T(x) \\leq 30\\right)$。\n   - 降水可行性指示函数为 $\\mathbb{I}\\left(500 \\leq P(x) \\leq 1500\\right)$。\n   - 气候可行性指示函数是两者的乘积 $\\mathbb{I}\\left(10 \\leq T(x) \\leq 30\\right)\\cdot \\mathbb{I}\\left(500 \\leq P(x) \\leq 1500\\right)$。\n2. 对于每个有效像元 $x$，通过气候可行性与生物排斥补集的组合来定义适宜度指数 $s(x)$：\n   - 如果气候可行性指示函数等于 $0$，则 $s(x)=0$。\n   - 如果气候可行性指示函数等于 $1$，则 $s(x)=1-b(x)$，其中 $b(x)$ 已被裁剪到 $[0,1]$ 区间内。\n3. 使用适宜度阈值 $\\tau_s=0.8$ (无量纲)，计算有多少有效像元满足 $s(x)\\geq \\tau_s$。将满足阈值的景观比例计算为\n   $$f=\\frac{\\text{满足 } s(x)\\geq \\tau_s \\text{ 的有效像元数量}}{\\text{有效像元总数}}。$$\n   按照惯例，如果没有有效像元，则定义 $f=0.0$。\n4. 对于每个提供的测试用例，计算 $f$ 并将结果报告为四舍五入到六位小数的浮点数。\n\n本问题不涉及角度单位。所有百分比必须以小数形式报告。\n\n测试套件：\n使用以下四个用例。在每个用例中，所有数组都具有相同的维度并指向同一个像元网格。请在所示位置精确使用 $\\mathrm{NaN}$ 表示缺失值。\n\n- 测试用例 1 (一般混合情况)：\n  - 温度 $T^{(1)}$ (摄氏度)：\n    $\\begin{bmatrix}\n    12  25  5  31 \\\\\n    10  30  20  \\mathrm{NaN} \\\\\n    15  9  28  11\n    \\end{bmatrix}$\n  - 降水量 $P^{(1)}$ (毫米)：\n    $\\begin{bmatrix}\n    600  1400  600  600 \\\\\n    500  1500  1000  900 \\\\\n    499  800  1600  \\mathrm{NaN}\n    \\end{bmatrix}$\n  - 生物排斥 $b^{(1)}$ (比例，使用前需裁剪到 $[0,1]$ 区间内)：\n    $\\begin{bmatrix}\n    0.1  0.05  0.3  0.1 \\\\\n    0.2  0.0  0.19  0.9 \\\\\n    0.0  0.15  0.2  0.1\n    \\end{bmatrix}$\n\n- 测试用例 2 (边界条件和裁剪)：\n  - 温度 $T^{(2)}$ (摄氏度)：\n    $\\begin{bmatrix}\n    10  30  20  10 \\\\\n    30  10  30  25\n    \\end{bmatrix}$\n  - 降水量 $P^{(2)}$ (毫米)：\n    $\\begin{bmatrix}\n    500  1500  1000  500 \\\\\n    1500  500  1500  700\n    \\end{bmatrix}$\n  - 生物排斥 $b^{(2)}$ (比例，裁剪到 $[0,1]$)：\n    $\\begin{bmatrix}\n    0.2  0.2  0.8  0.0 \\\\\n    0.2000001  -0.1  1.2  0.2\n    \\end{bmatrix}$\n\n- 测试用例 3 (所有气候均不可行)：\n  - 温度 $T^{(3)}$ (摄氏度)：\n    $\\begin{bmatrix}\n    9  35 \\\\\n    8  31\n    \\end{bmatrix}$\n  - 降水量 $P^{(3)}$ (毫米)：\n    $\\begin{bmatrix}\n    400  1600 \\\\\n    200  2000\n    \\end{bmatrix}$\n  - 生物排斥 $b^{(3)}$ (比例)：\n    $\\begin{bmatrix}\n    0.0  0.0 \\\\\n    0.0  0.0\n    \\end{bmatrix}$\n\n- 测试用例 4 (无有效像元)：\n  - 温度 $T^{(4)}$ (摄氏度)：\n    $\\begin{bmatrix}\n    \\mathrm{NaN}  \\mathrm{NaN} \\\\\n    \\mathrm{NaN}  \\mathrm{NaN}\n    \\end{bmatrix}$\n  - 降水量 $P^{(4)}$ (毫米)：\n    $\\begin{bmatrix}\n    \\mathrm{NaN}  \\mathrm{NaN} \\\\\n    \\mathrm{NaN}  \\mathrm{NaN}\n    \\end{bmatrix}$\n  - 生物排斥 $b^{(4)}$ (比例)：\n    $\\begin{bmatrix}\n    \\mathrm{NaN}  \\mathrm{NaN} \\\\\n    \\mathrm{NaN}  \\mathrm{NaN}\n    \\end{bmatrix}$\n\n要求的最终输出格式：\n您的程序必须按顺序为四个测试用例中的每一个计算 $f$，并生成单行输出。该输出包含一个由方括号括起来的逗号分隔列表，其中每个浮点数结果都四舍五入到六位小数。例如，包含四个结果的输出必须类似于\n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$。",
            "solution": "问题陈述已经过评估并被确定为有效。它具有科学依据、提法明确、客观，并为标准的生境适宜度建模练习提供了一套完整且一致的定义和数据。\n\n解决方案通过对任意一组网格化数据层逐步实施指定的算法来进行。设温度、降水量和生物排斥的输入数组分别表示为 $T$、$P$ 和 $b$。\n\n1.  **有效像元的识别**：第一步是确定网格中哪些像元包含有效数据。根据问题定义，位置 $x$ 处的像元是有效的，当且仅当温度 $T(x)$、降水量 $P(x)$ 和生物因子 $b(x)$ 的值都是有限实数 (即，不是 $\\mathrm{NaN}$)。这可以通过创建一个布尔掩码来实现，我们称之为 $M_{valid}$，如果对应的像元有效，则掩码中的元素为 `True`，否则为 `False`。有效像元的总数 $N_{valid}$ 是此掩码中 `True` 元素的总和。\n    $$M_{valid}(x) = \\mathbb{I}(\\neg\\mathrm{isNaN}(T(x)) \\land \\neg\\mathrm{isNaN}(P(x)) \\land \\neg\\mathrm{isNaN}(b(x)))$$\n    $$N_{valid} = \\sum_{x} M_{valid}(x)$$\n    如果 $N_{valid} = 0$，问题规定分数 $f$ 定义为 $0.0$，计算终止。\n\n2.  **生物排斥因子的裁剪**：生物排斥因子 $b(x)$ 被定义为一个不可用比例，并且必须在闭合的单位区间 $[0, 1]$ 内。问题要求裁剪任何超出此范围的值。我们定义一个新的网格 $b_{clipped}$，其中对于每个像元 $x$：\n    $$b_{clipped}(x) = \\max(0, \\min(1, b(x)))$$\n    此操作应用于整个 $b$ 网格，包括那些稍后可能被识别为无效的像元；无效像元掩码 $M_{valid}$ 将确保这些位置在最终计算中被正确忽略。\n\n3.  **气候可行性的计算**：为每个像元计算一个气候可行性指示函数 $C(x)$。如果温度和降水量都在其指定的有利范围内，则该指示函数为 $1$，否则为 $0$。\n    温度可行性由指示掩码 $C_T(x) = \\mathbb{I}(10 \\leq T(x) \\leq 30)$ 给出。\n    降水可行性由指示掩码 $C_P(x) = \\mathbb{I}(500 \\leq P(x) \\leq 1500)$ 给出。\n    组合的气候可行性是这两个指示函数的乘积：\n    $$C(x) = C_T(x) \\cdot C_P(x) = \\mathbb{I}\\left((10 \\leq T(x) \\leq 30) \\land (500 \\leq P(x) \\leq 1500)\\right)$$\n\n4.  **适宜度指数的计算**：现在，基于气候可行性 $C(x)$ 和裁剪后的生物因子 $b_{clipped}(x)$，为每个像元计算生境适宜度指数 $s(x)$。\n    - 如果 $C(x) = 0$，则气候不适宜，因此 $s(x) = 0$。\n    - 如果 $C(x) = 1$，则气候适宜，适宜度由生物因子决定：$s(x) = 1 - b_{clipped}(x)$。\n    这个逻辑可以为整个网格简洁地表示为：\n    $$s(x) = C(x) \\cdot (1 - b_{clipped}(x))$$\n\n5.  **分类和聚合**：最后一步是确定高度适宜的有效景观的比例。如果一个像元的适宜度指数 $s(x)$ 大于或等于阈值 $\\tau_s = 0.8$，则该像元被分类为高度适宜。我们计算满足此条件*并且*也是有效的像元数量。令此计数为 $N_{suitable}$。\n    $$N_{suitable} = \\sum_{x} \\mathbb{I}(s(x) \\geq \\tau_s) \\cdot M_{valid}(x)$$\n    请注意，乘以 $M_{valid}(x)$ 确保了按问题规定，只有有效像元才被计入分子。\n\n6.  **最终比例的计算**：比例 $f$ 是高度适宜的有效像元数量与有效像元总数的比值。\n    $$f = \\frac{N_{suitable}}{N_{valid}}$$\n    如步骤 1 所述，如果 $N_{valid} = 0$，则 $f = 0.0$。最终结果四舍五入到六位小数。\n\n让我们将此逻辑应用于测试用例 1：\n-   $T^{(1)} = \\begin{bmatrix} 12  25  5  31 \\\\ 10  30  20  \\mathrm{NaN} \\\\ 15  9  28  11 \\end{bmatrix}$\n-   $P^{(1)} = \\begin{bmatrix} 600  1400  600  600 \\\\ 500  1500  1000  900 \\\\ 499  800  1600  \\mathrm{NaN} \\end{bmatrix}$\n-   $b^{(1)} = \\begin{bmatrix} 0.1  0.05  0.3  0.1 \\\\ 0.2  0.0  0.19  0.9 \\\\ 0.0  0.15  0.2  0.1 \\end{bmatrix}$\n\n1.  **有效像元**：有两个像元具有 $\\mathrm{NaN}$ 值：来自 $T^{(1)}$ 的索引 $(1, 3)$ 处和来自 $P^{(1)}$ 的索引 $(2, 3)$ 处。所有其他 $12-2=10$ 个像元都是有效的。因此，$N_{valid} = 10$。\n2.  **裁剪生物因子**：$b^{(1)}$ 中的所有值都已在 $[0, 1]$ 区间内，所以 $b_{clipped}^{(1)} = b^{(1)}$。\n3.  **气候可行性**：\n    $C_T = \\begin{bmatrix} 1  1  0  0 \\\\ 1  1  1  0 \\\\ 1  0  1  1 \\end{bmatrix}$, $C_P = \\begin{bmatrix} 1  1  1  1 \\\\ 1  1  1  1 \\\\ 0  1  0  0 \\end{bmatrix}$。\n    $C = C_T \\cdot C_P = \\begin{bmatrix} 1  1  0  0 \\\\ 1  1  1  0 \\\\ 0  0  0  0 \\end{bmatrix}$。\n4.  **适宜度指数**：$s(x) = C(x) \\cdot (1 - b_{clipped}(x))$。\n    $s = \\begin{bmatrix} 1\\cdot(1-0.1)  1\\cdot(1-0.05)  0  0 \\\\ 1\\cdot(1-0.2)  1\\cdot(1-0.0)  1\\cdot(1-0.19)  0 \\\\ 0  0  0  0 \\end{bmatrix} = \\begin{bmatrix} 0.9  0.95  0  0 \\\\ 0.8  1.0  0.81  0 \\\\ 0  0  0  0 \\end{bmatrix}$。\n5.  **分类**：找到 $s(x) \\geq 0.8$ 的位置。\n    $\\mathbb{I}(s(x) \\geq 0.8) = \\begin{bmatrix} 1  1  0  0 \\\\ 1  1  1  0 \\\\ 0  0  0  0 \\end{bmatrix}$。\n    高度适宜的有效像元数量 $N_{suitable}$ 是此网格中 `1` 的数量，不包括无效像元的位置（此处没有重叠）。共有 $5$ 个这样的像元。$N_{suitable} = 5$。\n6.  **最终比例**：$f = \\frac{N_{suitable}}{N_{valid}} = \\frac{5}{10} = 0.5$。四舍五入到六位小数，即为 $0.500000$。\n对所有其他测试用例应用相同的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fraction of a landscape satisfying a habitat suitability threshold\n    for several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: General mixed case\n        {\n            \"T\": np.array([\n                [12, 25, 5, 31],\n                [10, 30, 20, np.nan],\n                [15, 9, 28, 11]\n            ]),\n            \"P\": np.array([\n                [600, 1400, 600, 600],\n                [500, 1500, 1000, 900],\n                [499, 800, 1600, np.nan]\n            ]),\n            \"b\": np.array([\n                [0.1, 0.05, 0.3, 0.1],\n                [0.2, 0.0, 0.19, 0.9],\n                [0.0, 0.15, 0.2, 0.1]\n            ])\n        },\n        # Test Case 2: Boundary conditions and clipping\n        {\n            \"T\": np.array([\n                [10, 30, 20, 10],\n                [30, 10, 30, 25]\n            ]),\n            \"P\": np.array([\n                [500, 1500, 1000, 500],\n                [1500, 500, 1500, 700]\n            ]),\n            \"b\": np.array([\n                [0.2, 0.2, 0.8, 0.0],\n                [0.2000001, -0.1, 1.2, 0.2]\n            ])\n        },\n        # Test Case 3: All climate-infeasible\n        {\n            \"T\": np.array([\n                [9, 35],\n                [8, 31]\n            ]),\n            \"P\": np.array([\n                [400, 1600],\n                [200, 2000]\n            ]),\n            \"b\": np.array([\n                [0.0, 0.0],\n                [0.0, 0.0]\n            ])\n        },\n        # Test Case 4: No valid pixels\n        {\n            \"T\": np.array([\n                [np.nan, np.nan],\n                [np.nan, np.nan]\n            ]),\n            \"P\": np.array([\n                [np.nan, np.nan],\n                [np.nan, np.nan]\n            ]),\n            \"b\": np.array([\n                [np.nan, np.nan],\n                [np.nan, np.nan]\n            ])\n        }\n    ]\n\n    results = []\n    # Suitability threshold\n    tau_s = 0.8\n\n    for case in test_cases:\n        T, P, b = case[\"T\"], case[\"P\"], case[\"b\"]\n        \n        # 1. Identify valid pixels (not NaN in any layer)\n        valid_pixels_mask = ~np.isnan(T)  ~np.isnan(P)  ~np.isnan(b)\n        num_valid_pixels = np.sum(valid_pixels_mask)\n\n        # Handle case with no valid pixels\n        if num_valid_pixels == 0:\n            results.append(0.0)\n            continue\n\n        # 2. Clip biotic exclusion factor b to [0, 1]\n        b_clipped = np.clip(b, 0, 1)\n\n        # 3. Calculate climate feasibility indicator C(x)\n        # C(x) is 1 if T and P are within bounds, 0 otherwise.\n        temp_feasibility = (T >= 10)  (T = 30)\n        precip_feasibility = (P >= 500)  (P = 1500)\n        climate_feasibility_mask = temp_feasibility  precip_feasibility\n\n        # 4. Compute the suitability index s(x)\n        # s(x) = C(x) * (1 - b_clipped)\n        # This works because the boolean mask acts as 0s and 1s.\n        suitability_grid = climate_feasibility_mask * (1 - b_clipped)\n        \n        # 5. Count pixels where s(x) >= tau_s, but only for valid pixels\n        suitable_mask = suitability_grid >= tau_s\n        # The number of suitable pixels is the sum of pixels that are\n        # both suitable AND valid.\n        num_suitable_pixels = np.sum(suitable_mask  valid_pixels_mask)\n\n        # 6. Compute the final fraction f\n        f = num_suitable_pixels / num_valid_pixels\n        \n        # Store the result, rounded to six decimal places\n        results.append(round(f, 6))\n\n    # Format the final output string exactly as required, ensuring six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基于规则的建模后，我们将进入一个更高级的领域：数据驱动的统计建模。本实践将使用逻辑斯蒂回归，这是一种在物种分布模型中广泛应用的广义线性模型（GLM）。您将学习如何不再手动设定规则，而是利用物种有无（presence-absence）数据和环境变量，通过最大化惩罚对数似然来拟合模型，从而生成一个概率性的适宜性地图。",
            "id": "3818652",
            "problem": "给定一个二元存在-缺失数据集以及从遥感获取的环境协变量，用于生境适宜性建模。假设每次观测 $(y_i, x_i)$ 满足一个概率为 $p_i$ 的伯努利数据生成过程和一个 logit 链接：$y_i \\sim \\mathrm{Bernoulli}(p_i)$，其中 $p_i = \\mathrm{logit}^{-1}(\\eta_i)$ 且 $\\eta_i = \\beta_0 + \\beta^\\top x_i$。此处，$x_i \\in \\mathbb{R}^d$ 是协变量（不含截距），$\\beta_0 \\in \\mathbb{R}$ 是截距，$\\beta \\in \\mathbb{R}^d$ 是斜率系数。反 logit 函数定义为 $\\mathrm{logit}^{-1}(z) = \\frac{1}{1 + e^{-z}}$。\n\n您的任务是编写一个完整的程序，该程序针对下面提供的每个测试用例，通过最大化 logit 链接下的伯努利对数似然来拟合系数向量 $(\\beta_0, \\beta)$，在提供的协变量测试网格上计算预测的适宜性值，并报告拟合的系数估计值和整个网格的平均预测适宜性。为确保在准分离或共线性情况下的可识别性和数值稳定性，请对斜率（但不包括截距）使用各向同性高斯先验，这等效于仅对斜率添加一个强度为 $\\lambda$ 的 $\\ell_2$ 岭惩罚。具体而言，目标是惩罚对数似然\n$$\n\\ell(\\beta_0,\\beta) = \\sum_{i=1}^n \\left[ y_i \\,\\eta_i - \\log\\left(1 + e^{\\eta_i}\\right) \\right] - \\frac{\\lambda}{2}\\,\\|\\beta\\|_2^2,\n$$\n对 $\\beta_0$ 不施加惩罚。使用 $\\lambda = 10^{-4}$。不要应用任何其他正则化、加权或特征变换。\n\n使用的基本原理：伯努利似然、logit 链接的定义以及最大似然估计原理（或选择性地使用高斯先验下的最大后验估计，它会产生指定的 $\\ell_2$ 惩罚）。\n\n基于基本原理实现一个数值稳定且收敛的求解器，例如用于广义线性模型（GLMs）的 Newton–Raphson 方法，确保对海森矩阵进行调整以仅包含对斜率的惩罚。您可以假设由于岭惩罚，海森矩阵是严格正定的，并且可以通过参数的最大绝对变化来检验收敛性。\n\n对于每个测试用例，计算：\n- 拟合系数 $(\\hat{\\beta}_0, \\hat{\\beta})$。\n- 对于每个给定的网格协变量 $x_g$，计算预测的适宜性值 $p_g = \\mathrm{logit}^{-1}(\\hat{\\beta}_0 + \\hat{\\beta}^\\top x_g)$。\n- 整个网格的平均预测适宜性 $\\bar{p} = \\frac{1}{m} \\sum_{g=1}^m p_g$。\n\n所有输出均为无量纲概率，因此不需要物理单位。如果任何量可以解释为比率或比例，请以 $[0,1]$ 范围内的小数表示。\n\n数据集和网格的测试套件：\n- 测试用例 $1$（理想情况，两个协变量）：\n  - 每个观测的协变量 $(\\mathrm{NDVI}, \\mathrm{distance\\_to\\_water})$：\n    - $x_1 = (0.75, 0.2),\\; x_2 = (0.68, 0.5),\\; x_3 = (0.80, 1.2),\\; x_4 = (0.55, 2.0),$\n    - $x_5 = (0.40, 3.5),\\; x_6 = (0.30, 4.0),\\; x_7 = (0.62, 1.5),\\; x_8 = (0.48, 2.8),$\n    - $x_9 = (0.72, 0.8),\\; x_{10} = (0.66, 1.0)$.\n  - 存在-缺失响应：\n    - $y = (1, 1, 1, 0, 0, 0, 1, 0, 1, 1)$.\n  - 测试网格协变量：\n    - $g_1 = (0.60, 1.0),\\; g_2 = (0.50, 3.0),\\; g_3 = (0.80, 0.5),\\; g_4 = (0.35, 4.5)$.\n- 测试用例 $2$（准分离，两个协变量）：\n  - 协变量：\n    - $x_1 = (0.82, 3.0),\\; x_2 = (0.78, 2.5),\\; x_3 = (0.76, 1.0),\\; x_4 = (0.20, 0.8),$\n    - $x_5 = (0.30, 1.5),\\; x_6 = (0.35, 2.0),\\; x_7 = (0.70, 4.0),\\; x_8 = (0.45, 3.5)$.\n  - 响应：\n    - $y = (1, 1, 1, 0, 0, 0, 1, 0)$.\n  - 测试网格：\n    - $g_1 = (0.25, 1.0),\\; g_2 = (0.65, 2.0),\\; g_3 = (0.85, 0.5)$.\n- 测试用例 $3$（高度共线性，两个协变量）：\n  - 协变量：\n    - $x_1 = (0.20, 0.402),\\; x_2 = (0.25, 0.499),\\; x_3 = (0.30, 0.601),\\; x_4 = (0.35, 0.699),$\n    - $x_5 = (0.40, 0.800),\\; x_6 = (0.45, 0.901),\\; x_7 = (0.50, 1.001),\\; x_8 = (0.55, 1.099),$\n    - $x_9 = (0.60, 1.199),\\; x_{10} = (0.65, 1.300)$.\n  - 响应：\n    - $y = (0, 0, 0, 0, 1, 1, 1, 1, 1, 1)$.\n  - 测试网格：\n    - $g_1 = (0.33, 0.66),\\; g_2 = (0.58, 1.16)$.\n\n程序要求：\n- 使用 Newton–Raphson 程序实现惩罚伯努利对数似然的最大化，其中海森矩阵等于 $X^\\top W X + \\Lambda$，$W$ 是对角矩阵，其元素为 $p_i (1 - p_i)$，$\\Lambda$ 是对角矩阵，其元素为 $(0, \\lambda, \\lambda)$，从而仅对斜率进行惩罚。\n- 使用 $\\lambda = 10^{-4}$ 并将 $(\\beta_0, \\beta)$ 初始化为零。\n- 收敛准则：当参数的最大绝对更新量小于 $10^{-9}$ 或达到 $100$ 次迭代时停止，以先到者为准。\n- 对每个测试用例，计算并报告一个包含 4 个值的列表：$[\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\bar{p}]$，其中 $\\bar{p}$ 是该测试用例在网格上的平均预测适宜性。\n- 最终输出格式：您的程序应生成单行输出，包含一个由列表组成的列表，其中每个值都四舍五入到 6 位小数，例如 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4]]$。",
            "solution": "我们从二元存在-缺失数据的伯努利似然和 logit 链接开始。对于每个响应为 $y_i \\in \\{0,1\\}$、协变量向量为 $x_i \\in \\mathbb{R}^d$（不含截距）的观测 $i \\in \\{1,\\dots,n\\}$，模型假设 $y_i \\sim \\mathrm{Bernoulli}(p_i)$，其中 $p_i = \\mathrm{logit}^{-1}(\\eta_i)$ 且 $\\eta_i = \\beta_0 + \\beta^\\top x_i$。反 logit 函数为 $\\mathrm{logit}^{-1}(z) = \\frac{1}{1 + e^{-z}}$，它将 $\\mathbb{R}$ 映射到 $(0,1)$。\n\n参数 $(\\beta_0, \\beta)$ 的对数似然是\n$$\n\\ell_{\\text{ll}}(\\beta_0,\\beta) = \\sum_{i=1}^n \\left[ y_i \\,\\eta_i - \\log\\!\\left(1 + e^{\\eta_i}\\right) \\right].\n$$\n为了处理准分离和共线性问题并确保数值稳定性，我们对斜率（但不包括截距）采用高斯先验，这等效于仅对斜率添加一个 $\\ell_2$ 惩罚。设 $\\lambda  0$ 表示惩罚强度，定义惩罚对数似然为\n$$\n\\ell(\\beta_0,\\beta) = \\ell_{\\text{ll}}(\\beta_0,\\beta) - \\frac{\\lambda}{2}\\,\\|\\beta\\|_2^2.\n$$\n这等效于在 $\\beta \\sim \\mathcal{N}(0, \\lambda^{-1} I)$ 下进行最大后验估计，且对 $\\beta_0$ 没有先验惩罚。最大化者 $(\\hat{\\beta}_0,\\hat{\\beta})$ 可以通过 Newton–Raphson 迭代获得，该迭代使用 $\\ell$ 的梯度和海森矩阵。\n\n令 $X \\in \\mathbb{R}^{n \\times (d+1)}$ 表示设计矩阵，其第一列为 1（截距），其余 $d$ 列为协变量。用 $\\theta = (\\beta_0, \\beta_1, \\dots, \\beta_d)^\\top \\in \\mathbb{R}^{d+1}$ 表示完整的参数向量。令 $p \\in \\mathbb{R}^n$ 为一个向量，其元素为 $p_i = \\mathrm{logit}^{-1}(x_i^\\top \\theta)$，其中 $x_i$ 现在指代 $X$ 中包含截距的完整行。未惩罚的对数似然的梯度为\n$$\n\\nabla \\ell_{\\text{ll}}(\\theta) = X^\\top (y - p),\n$$\n其中 $y \\in \\mathbb{R}^n$ 是响应向量，减法是逐元素进行的。未惩罚的对数似然的海森矩阵为\n$$\n\\nabla^2 \\ell_{\\text{ll}}(\\theta) = -X^\\top W X,\n$$\n其中 $W \\in \\mathbb{R}^{n \\times n}$ 是对角矩阵，其元素为 $W_{ii} = p_i (1 - p_i)$。对于仅对斜率施加惩罚的惩罚目标，定义 $\\Lambda \\in \\mathbb{R}^{(d+1) \\times (d+1)}$ 为一个对角矩阵，其对角线元素为 $(0, \\lambda, \\dots, \\lambda)$，其中第一个元素为零确保了对截距没有惩罚。惩罚对数后验的梯度和海森矩阵则为\n$$\n\\nabla \\ell(\\theta) = X^\\top (y - p) - \\Lambda \\theta,\\quad\n\\nabla^2 \\ell(\\theta) = -X^\\top W X - \\Lambda.\n$$\nNewton–Raphson 更新通过求解线性系统来获得增量 $\\Delta \\theta$\n$$\n\\big(X^\\top W X + \\Lambda\\big)\\, \\Delta \\theta = X^\\top (y - p) - \\Lambda \\theta,\n$$\n然后更新 $\\theta \\leftarrow \\theta + \\Delta \\theta$。这是一种适用于岭惩罚广义线性模型（GLM）的迭代重加权最小二乘（IRLS）风格的更新。因为 $\\Lambda$ 是半正定的，并且对应斜率分量的条目是严格为正的，只要至少有一个观测满足 $p_i \\in (0,1)$ 且 $\\lambda  0$，$X^\\top W X + \\Lambda$ 就将是正定的，这保证了 $\\Delta \\theta$ 有唯一解和良好的数值条件。\n\n每个测试用例的算法步骤：\n- 将一列 1 与协变量矩阵连接起来，形成 $X$。\n- 初始化 $\\theta^{(0)} = 0 \\in \\mathbb{R}^{d+1}$。\n- 对于迭代 $t = 0, 1, \\dots$ 直至最多 $100$ 次：\n  - 计算 $\\eta^{(t)} = X \\theta^{(t)}$，然后 $p^{(t)} = \\mathrm{logit}^{-1}(\\eta^{(t)})$。\n  - 以 $W_{ii}^{(t)} = p_i^{(t)} \\big( 1 - p_i^{(t)} \\big)$ 形成 $W^{(t)}$。\n  - 计算梯度 $g^{(t)} = X^\\top \\big( y - p^{(t)} \\big) - \\Lambda \\theta^{(t)}$。\n  - 计算类海森矩阵 $H^{(t)} = X^\\top W^{(t)} X + \\Lambda$。\n  - 求解 $H^{(t)} \\Delta \\theta^{(t)} = g^{(t)}$ 并更新 $\\theta^{(t+1)} = \\theta^{(t)} + \\Delta \\theta^{(t)}$。\n  - 当 $\\|\\Delta \\theta^{(t)}\\|_\\infty  10^{-9}$ 时停止。\n- 令 $(\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2)$ 为 $d = 2$ 个协变量时 $\\hat{\\theta}$ 的分量。\n- 对于每个网格协变量 $x_g \\in \\mathbb{R}^2$，计算 $p_g = \\mathrm{logit}^{-1}\\big(\\hat{\\beta}_0 + \\hat{\\beta}_1 x_{g1} + \\hat{\\beta}_2 x_{g2}\\big)$。\n- 计算 $\\bar{p} = \\frac{1}{m} \\sum_{g=1}^m p_g$，其中 $m$ 是网格点的数量，且所有权重相等。\n\n数值稳定性考虑：\n- 为避免计算 $\\mathrm{logit}^{-1}(z)$ 时发生溢出，请以数值稳定的方式进行计算，例如在应用 $1/(1+e^{-z})$ 之前将 $z$ 裁剪到一个有界区间（如 $[-35, 35]$），或使用一个稳定的逻辑斯谛函数实现。\n- 在存在高度共线性或近分离的情况下，使用 $\\lambda = 10^{-4}$ 的岭惩罚可以避免 $H^{(t)}$ 的奇异性，确保每次迭代中线性求解的可逆性。\n- 不对截距进行惩罚，这与正则化广义线性模型中的标准做法一致。\n\n输出规范：\n- 对每个测试用例，生成列表 $[\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\bar{p}]$，所有值均四舍五入至 6 位小数。\n- 将所有测试用例的结果汇总到一个由列表组成的列表中，并将该列表作为程序的唯一输出打印在一行上，例如：$[[b_{01}, b_{11}, b_{21}, \\bar{p}_1], [b_{02}, b_{12}, b_{22}, \\bar{p}_2], [b_{03}, b_{13}, b_{23}, \\bar{p}_3]]$。\n\n此过程将生境适宜性建模直接实现为对遥感协变量的逻辑斯谛回归，计算代表研究区域的测试网格上的预测适宜性，并报告拟合系数和平均预测适宜性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef stable_logistic(z):\n    # Compute logistic function in a numerically stable way.\n    # Clip z to avoid overflow in exp.\n    z = np.clip(z, -35.0, 35.0)\n    return 1.0 / (1.0 + np.exp(-z))\n\ndef fit_logistic_ridge(X, y, lam=1e-4, tol=1e-9, max_iter=100):\n    \"\"\"\n    Fit penalized logistic regression with ridge penalty on slopes only.\n    X: (n, d+1) design matrix with intercept in the first column (ones).\n    y: (n,) binary responses.\n    lam: ridge penalty strength applied to slopes only.\n    Returns theta of shape (d+1,).\n    \"\"\"\n    n, p = X.shape\n    theta = np.zeros(p, dtype=float)\n    # Penalty matrix: 0 on intercept, lam on slopes.\n    Lambda = np.diag([0.0] + [lam] * (p - 1))\n\n    for _ in range(max_iter):\n        eta = X @ theta\n        p_hat = stable_logistic(eta)\n        W = p_hat * (1.0 - p_hat)  # (n,)\n        # Form X^T W X efficiently\n        # H = X^T W X + Lambda\n        # Use broadcasting to multiply rows of X by W\n        XW = X * W[:, None]\n        H = X.T @ XW + Lambda\n        # gradient: X^T(y - p) - Lambda theta\n        g = X.T @ (y - p_hat) - Lambda @ theta\n        try:\n            delta = np.linalg.solve(H, g)\n        except np.linalg.LinAlgError:\n            # Fallback to least squares solution if needed\n            delta = np.linalg.lstsq(H, g, rcond=None)[0]\n        theta_new = theta + delta\n        if np.max(np.abs(delta))  tol:\n            theta = theta_new\n            break\n        theta = theta_new\n    return theta\n\ndef predict_logistic(theta, X_grid):\n    \"\"\"\n    Predict probabilities for grid covariates without intercept column.\n    theta: (d+1,), X_grid: (m, d)\n    \"\"\"\n    intercept = theta[0]\n    beta = theta[1:]\n    eta = intercept + X_grid @ beta\n    return stable_logistic(eta)\n\ndef solve():\n    lam = 1e-4\n\n    # Test case 1\n    X1_cov = np.array([\n        [0.75, 0.2],\n        [0.68, 0.5],\n        [0.80, 1.2],\n        [0.55, 2.0],\n        [0.40, 3.5],\n        [0.30, 4.0],\n        [0.62, 1.5],\n        [0.48, 2.8],\n        [0.72, 0.8],\n        [0.66, 1.0],\n    ], dtype=float)\n    y1 = np.array([1,1,1,0,0,0,1,0,1,1], dtype=float)\n    G1 = np.array([\n        [0.60, 1.0],\n        [0.50, 3.0],\n        [0.80, 0.5],\n        [0.35, 4.5],\n    ], dtype=float)\n\n    # Test case 2\n    X2_cov = np.array([\n        [0.82, 3.0],\n        [0.78, 2.5],\n        [0.76, 1.0],\n        [0.20, 0.8],\n        [0.30, 1.5],\n        [0.35, 2.0],\n        [0.70, 4.0],\n        [0.45, 3.5],\n    ], dtype=float)\n    y2 = np.array([1,1,1,0,0,0,1,0], dtype=float)\n    G2 = np.array([\n        [0.25, 1.0],\n        [0.65, 2.0],\n        [0.85, 0.5],\n    ], dtype=float)\n\n    # Test case 3\n    X3_cov = np.array([\n        [0.20, 0.402],\n        [0.25, 0.499],\n        [0.30, 0.601],\n        [0.35, 0.699],\n        [0.40, 0.800],\n        [0.45, 0.901],\n        [0.50, 1.001],\n        [0.55, 1.099],\n        [0.60, 1.199],\n        [0.65, 1.300],\n    ], dtype=float)\n    y3 = np.array([0,0,0,0,1,1,1,1,1,1], dtype=float)\n    G3 = np.array([\n        [0.33, 0.66],\n        [0.58, 1.16],\n    ], dtype=float)\n\n    test_cases = [\n        (X1_cov, y1, G1),\n        (X2_cov, y2, G2),\n        (X3_cov, y3, G3),\n    ]\n\n    results = []\n    for X_cov, y, G in test_cases:\n        n, d = X_cov.shape\n        # Build design matrix with intercept\n        X = np.hstack([np.ones((n, 1)), X_cov])\n        theta_hat = fit_logistic_ridge(X, y, lam=lam, tol=1e-9, max_iter=100)\n        # Predictions on grid\n        p_grid = predict_logistic(theta_hat, G)\n        avg_p = float(np.mean(p_grid))\n        # Collect [beta0, beta1, beta2, avg_p]\n        res = [float(theta_hat[0]), float(theta_hat[1]), float(theta_hat[2]), avg_p]\n        results.append(res)\n\n    # Format results: each value rounded to 6 decimals\n    def fmt(x):\n        return f\"{x:.6f}\"\n\n    out = \"[\" + \",\".join(\"[\" + \",\".join(fmt(v) for v in row) + \"]\" for row in results) + \"]\"\n    print(out)\n\nsolve()\n```"
        },
        {
            "introduction": "构建模型后，关键的一步是负责任地应用和验证它，尤其是在预测未来气候等新情景时。本实践探讨了模型外推（extrapolation）的挑战，即当模型应用于其训练范围之外的环境条件时，其预测可能变得不可靠。您将学习如何使用多变量环境相似性表面（MESS）来量化环境的新颖性，并应用“钳制”（clamping）这一常用策略来约束预测结果。",
            "id": "3818689",
            "problem": "您正在为一个物种建立栖息地适宜性模型，该模型使用一组源自遥感和气候数据的环境预测因子来评估未来的预测情景。您将实施一个严谨的程序来计算多元环境相似性表面 (MESS) 图，识别外推，对预测因子应用训练范围内的钳制，并量化在未来情景下预测适宜性的变化。所有计算必须基于有界区间上的归一化和逻辑斯谛变换的基本定义，并且必须以数学方式表达。\n\n设预测因子向量为 $\\mathbf{z} = (z_1, z_2, z_3)$，其中 $z_1$ 是年平均温度（单位：摄氏度），$z_2$ 是年降水量（单位：毫米/年），$z_3$ 是归一化植被指数（NDVI，无单位）。训练环境空间由下界 $\\mathbf{a} = (a_1, a_2, a_3)$ 和上界 $\\mathbf{b} = (b_1, b_2, b_3)$、训练均值 $\\boldsymbol{\\mu} = (\\mu_1, \\mu_2, \\mu_3)$ 以及训练标准差 $\\boldsymbol{\\sigma} = (\\sigma_1, \\sigma_2, \\sigma_3)$ 汇总。这些元素是：\n- 温度：$a_1 = 12$ 摄氏度, $b_1 = 20$ 摄氏度, $\\mu_1 = 16$ 摄氏度, $\\sigma_1 = 2.5$ 摄氏度。\n- 降水量：$a_2 = 800$ 毫米/年, $b_2 = 1200$ 毫米/年, $\\mu_2 = 1000$ 毫米/年, $\\sigma_2 = 120$ 毫米/年。\n- NDVI：$a_3 = 0.4$ (无单位), $b_3 = 0.7$ (无单位), $\\mu_3 = 0.55$ (无单位), $\\sigma_3 = 0.08$ (无单位)。\n\n对于每个预测因子 $i \\in \\{1,2,3\\}$，定义训练区间内的归一化位置为\n$$\ns_i(z_i) = \\frac{z_i - a_i}{b_i - a_i}.\n$$\n通过以下分段表达式定义基于中心性的单变量相似性函数 $c_i(z_i)$\n$$\nc_i(z_i) =\n\\begin{cases}\n1 - 2\\left| s_i(z_i) - \\frac{1}{2} \\right|,  \\text{if } a_i \\le z_i \\le b_i, \\\\\n-\\dfrac{a_i - z_i}{b_i - a_i},  \\text{if } z_i  a_i, \\\\\n-\\dfrac{z_i - b_i}{b_i - a_i},  \\text{if } z_i  b_i.\n\\end{cases}\n$$\n该函数产生的值在区间 $[-1,1]$ 内，在区间中心处等于 $1$，在边界处等于 $0$，在训练范围外为负，且其值与超出距离相对于区间宽度的比例成正比。\n\n定义多元环境相似性表面 (MESS) 分数为\n$$\nM(\\mathbf{z}) = \\min\\{c_1(z_1), c_2(z_2), c_3(z_3)\\}.\n$$\n将外推定义为以下条件\n$$\nE(\\mathbf{z}) = \\left( \\exists i \\in \\{1,2,3\\} \\text{ such that } z_i  a_i \\text{ or } z_i  b_i \\right),\n$$\n等价地，$E(\\mathbf{z})$ 为真当且仅当 $M(\\mathbf{z})  0$。\n\n为限制外推对预测的影响，对每个预测因子定义到训练区间的钳制：\n$$\n\\tilde{z}_i = \\min\\{ \\max\\{ z_i, a_i \\}, b_i \\}, \\quad i \\in \\{1,2,3\\}.\n$$\n设标准化预测因子为\n$$\nz_i^{\\star} = \\frac{z_i - \\mu_i}{\\sigma_i}, \\quad \\tilde{z}_i^{\\star} = \\frac{\\tilde{z}_i - \\mu_i}{\\sigma_i}.\n$$\n设适宜性由一个使用固定系数 $\\boldsymbol{\\beta} = (\\beta_0, \\beta_1, \\beta_2, \\beta_3)$ 的逻辑斯谛函数（一个使用 logit 连接的广义线性模型 (GLM)）建模：\n$$\n\\beta_0 = -0.5, \\quad \\beta_1 = 0.9, \\quad \\beta_2 = 0.6, \\quad \\beta_3 = 1.2.\n$$\n定义线性预测器\n$$\nf(\\mathbf{z}) = \\beta_0 + \\beta_1 z_1^{\\star} + \\beta_2 z_2^{\\star} + \\beta_3 z_3^{\\star}, \\quad\nf(\\tilde{\\mathbf{z}}) = \\beta_0 + \\beta_1 \\tilde{z}_1^{\\star} + \\beta_2 \\tilde{z}_2^{\\star} + \\beta_3 \\tilde{z}_3^{\\star},\n$$\n和适宜性值\n$$\nS(\\mathbf{z}) = \\frac{1}{1 + e^{-f(\\mathbf{z})}}, \\quad S(\\tilde{\\mathbf{z}}) = \\frac{1}{1 + e^{-f(\\tilde{\\mathbf{z}})}}.\n$$\n将钳制引起的预测适宜性变化量化为\n$$\n\\Delta S = S(\\tilde{\\mathbf{z}}) - S(\\mathbf{z}).\n$$\n\n实现一个程序，对于一组未来气候情景像素，计算 $M(\\mathbf{z})$、$E(\\mathbf{z})$ 和 $\\Delta S$。所有原始预测因子必须使用上述指定的物理单位进行处理。报告浮点数答案，四舍五入至 $6$ 位小数。本问题不涉及角度。不使用百分比。\n\n使用以下未来预测因子向量 $\\mathbf{z}$ 的测试套件：\n- 测试 $1$：$\\mathbf{z} = (16, 1000, 0.55)$，单位如上所述。\n- 测试 $2$：$\\mathbf{z} = (24, 900, 0.60)$，单位如上所述。\n- 测试 $3$：$\\mathbf{z} = (12, 800, 0.40)$，单位如上所述。\n- 测试 $4$：$\\mathbf{z} = (10, 1300, 0.20)$，单位如上所述。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形如 $[M(\\mathbf{z}), E(\\mathbf{z}), \\Delta S]$ 的列表。例如，输出格式必须为 $[[m_1,e_1,d_1],[m_2,e_2,d_2],[m_3,e_3,d_3],[m_4,e_4,d_4]]$，所有浮点值都四舍五入到 $6$ 位小数。",
            "solution": "该问题要求实施一个程序来评估未来环境情景下的栖息地适宜性，涉及计算多元环境相似性表面 (MESS)、识别外推、应用预测因子钳制以及量化由此导致的预测适宜性变化。该问题在科学上是合理的、定义明确的，并提供了所有必要的参数和定义。\n\n首先，我们确定所提供的常量和参数。环境预测因子是 $\\mathbf{z} = (z_1, z_2, z_3)$。训练数据由下界 $\\mathbf{a} = (12, 800, 0.4)$、上界 $\\mathbf{b} = (20, 1200, 0.7)$、均值 $\\boldsymbol{\\mu} = (16, 1000, 0.55)$ 和标准差 $\\boldsymbol{\\sigma} = (2.5, 120, 0.08)$ 汇总。逻辑斯谛模型的系数是 $\\boldsymbol{\\beta} = (\\beta_0, \\beta_1, \\beta_2, \\beta_3) = (-0.5, 0.9, 0.6, 1.2)$。\n\n对于任何给定的未来预测因子向量 $\\mathbf{z}$，解决过程包括以下顺序步骤：\n\n1.  **对于 $i \\in \\{1,2,3\\}$，计算每个变量的相似性分数 $c_i(z_i)$。**\n    这需要首先计算归一化位置 $s_i(z_i) = \\frac{z_i - a_i}{b_i - a_i}$。然后通过分段函数确定相似性 $c_i(z_i)$：\n    $$\n    c_i(z_i) =\n    \\begin{cases}\n    1 - 2\\left| s_i(z_i) - \\frac{1}{2} \\right|,  \\text{if } a_i \\le z_i \\le b_i \\\\\n    -\\dfrac{a_i - z_i}{b_i - a_i} = s_i(z_i),  \\text{if } z_i  a_i \\\\\n    -\\dfrac{z_i - b_i}{b_i - a_i} = -(s_i(z_i) - 1),  \\text{if } z_i  b_i\n    \\end{cases}\n    $$\n    注意，对于 $z_i  a_i$ 和 $z_i  b_i$ 的表达式也可以用 $s_i(z_i)$ 来表示。对于 $z_i  a_i$，$s_i(z_i) = \\frac{z_i-a_i}{b_i-a_i}  0$，且 $-\\frac{a_i-z_i}{b_i-a_i} = \\frac{z_i-a_i}{b_i-a_i} = s_i(z_i)$。\n\n2.  **计算 MESS 分数 $M(\\mathbf{z})$ 并确定外推 $E(\\mathbf{z})$。**\n    MESS 分数是各个相似性分数的最小值：\n    $$\n    M(\\mathbf{z}) = \\min\\{c_1(z_1), c_2(z_2), c_3(z_3)\\}\n    $$\n    如果任何预测因子超出其训练范围，则发生外推 $E(\\mathbf{z})$，这等同于 MESS 分数为负。我们将 $E(\\mathbf{z})$ 表示为 $1$（如果为真，即外推）和 $0$（如果为假，即内插或在边界上）。\n    $$\n    E(\\mathbf{z}) =\n    \\begin{cases}\n    1  \\text{if } M(\\mathbf{z})  0 \\\\\n    0  \\text{if } M(\\mathbf{z}) \\ge 0\n    \\end{cases}\n    $$\n\n3.  **执行预测因子钳制。**\n    为减轻外推的影响，每个预测因子 $z_i$ 被钳制到其训练范围 $[a_i, b_i]$ 内：\n    $$\n    \\tilde{z}_i = \\min\\{ \\max\\{ z_i, a_i \\}, b_i \\}\n    $$\n    这将创建一个钳制后的预测因子向量 $\\tilde{\\mathbf{z}} = (\\tilde{z}_1, \\tilde{z}_2, \\tilde{z}_3)$。\n\n4.  **标准化原始和钳制后的预测因子。**\n    原始向量 $\\mathbf{z}$ 和钳制后的向量 $\\tilde{\\mathbf{z}}$ 都使用训练均值 $\\boldsymbol{\\mu}$ 和标准差 $\\boldsymbol{\\sigma}$ 进行标准化：\n    $$\n    z_i^{\\star} = \\frac{z_i - \\mu_i}{\\sigma_i}, \\quad \\tilde{z}_i^{\\star} = \\frac{\\tilde{z}_i - \\mu_i}{\\sigma_i}\n    $$\n\n5.  **计算适宜性分数 $S(\\mathbf{z})$ 和 $S(\\tilde{\\mathbf{z}})$。**\n    首先，使用系数 $\\boldsymbol{\\beta}$ 计算线性预测器：\n    $$\n    f(\\mathbf{z}) = \\beta_0 + \\beta_1 z_1^{\\star} + \\beta_2 z_2^{\\star} + \\beta_3 z_3^{\\star}\n    $$\n    $$\n    f(\\tilde{\\mathbf{z}}) = \\beta_0 + \\beta_1 \\tilde{z}_1^{\\star} + \\beta_2 \\tilde{z}_2^{\\star} + \\beta_3 \\tilde{z}_3^{\\star}\n    $$\n    然后，应用逻辑斯谛函数获得适宜性分数：\n    $$\n    S(\\mathbf{z}) = \\frac{1}{1 + e^{-f(\\mathbf{z})}}, \\quad S(\\tilde{\\mathbf{z}}) = \\frac{1}{1 + e^{-f(\\tilde{\\mathbf{z}})}}\n    $$\n\n6.  **量化适宜性的变化 $\\Delta S$。**\n    变化是钳制后和原始适宜性预测值之间的差异：\n    $$\n    \\Delta S = S(\\tilde{\\mathbf{z}}) - S(\\mathbf{z})\n    $$\n\n让我们以 **测试用例 2** 为例，逐步进行计算：$\\mathbf{z} = (24, 900, 0.60)$。\n\n1.  **相似性分数 $c_i(z_i)$**：\n    *   $z_1 = 24 > b_1 = 20$。外推。$c_1(24) = -\\frac{24 - 20}{20 - 12} = -\\frac{4}{8} = -0.5$。\n    *   $a_2 = 800 \\le z_2 = 900 \\le b_2 = 1200$。内插。$s_2(900) = \\frac{900 - 800}{1200 - 800} = \\frac{100}{400} = 0.25$。\n        $c_2(900) = 1 - 2|0.25 - 0.5| = 1 - 2(0.25) = 0.5$。\n    *   $a_3 = 0.4 \\le z_3 = 0.6 \\le b_3 = 0.7$。内插。$s_3(0.6) = \\frac{0.6 - 0.4}{0.7 - 0.4} = \\frac{0.2}{0.3} = \\frac{2}{3}$。\n        $c_3(0.6) = 1 - 2|\\frac{2}{3} - 0.5| = 1 - 2(\\frac{1}{6}) = \\frac{2}{3} \\approx 0.666667$。\n\n2.  **MESS 分数 $M(\\mathbf{z})$ 和外推 $E(\\mathbf{z})$**：\n    *   $M(\\mathbf{z}) = \\min\\{-0.5, 0.5, \\frac{2}{3}\\} = -0.5$。\n    *   由于 $M(\\mathbf{z})  0$，我们有外推，所以 $E(\\mathbf{z}) = 1$。\n\n3.  **预测因子钳制**：\n    *   $\\tilde{z}_1 = \\min\\{\\max\\{24, 12\\}, 20\\} = \\min\\{24, 20\\} = 20$。\n    *   $\\tilde{z}_2 = \\min\\{\\max\\{900, 800\\}, 1200\\} = \\min\\{900, 1200\\} = 900$。\n    *   $\\tilde{z}_3 = \\min\\{\\max\\{0.6, 0.4\\}, 0.7\\} = \\min\\{0.6, 0.7\\} = 0.6$。\n    *   $\\tilde{\\mathbf{z}} = (20, 900, 0.6)$。\n\n4.  **标准化**：\n    *   $z_1^{\\star} = \\frac{24 - 16}{2.5} = 3.2$, $z_2^{\\star} = \\frac{900 - 1000}{120} = -\\frac{5}{6}$, $z_3^{\\star} = \\frac{0.6 - 0.55}{0.08} = 0.625$。\n    *   $\\tilde{z}_1^{\\star} = \\frac{20 - 16}{2.5} = 1.6$, $\\tilde{z}_2^{\\star} = \\frac{900 - 1000}{120} = -\\frac{5}{6}$, $\\tilde{z}_3^{\\star} = \\frac{0.6 - 0.55}{0.08} = 0.625$。\n\n5.  **适宜性计算**：\n    *   $f(\\mathbf{z}) = -0.5 + 0.9(3.2) + 0.6(-\\frac{5}{6}) + 1.2(0.625) = -0.5 + 2.88 - 0.5 + 0.75 = 2.63$。\n    *   $S(\\mathbf{z}) = \\frac{1}{1 + e^{-2.63}} \\approx 0.932717$。\n    *   $f(\\tilde{\\mathbf{z}}) = -0.5 + 0.9(1.6) + 0.6(-\\frac{5}{6}) + 1.2(0.625) = -0.5 + 1.44 - 0.5 + 0.75 = 1.19$。\n    *   $S(\\tilde{\\mathbf{z}}) = \\frac{1}{1 + e^{-1.19}} \\approx 0.766755$。\n\n6.  **变化 $\\Delta S$**：\n    *   $\\Delta S = S(\\tilde{\\mathbf{z}}) - S(\\mathbf{z}) \\approx 0.766755 - 0.932717 = -0.165962$。\n\n该测试用例的最终结果，四舍五入到 $6$ 位小数后为 $[M(\\mathbf{z}), E(\\mathbf{z}), \\Delta S] = [-0.5, 1, -0.165962]$。对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes habitat suitability metrics for a set of future climate scenarios.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    # Lower bounds [temperature, precipitation, NDVI]\n    a = np.array([12.0, 800.0, 0.4])\n    # Upper bounds\n    b = np.array([20.0, 1200.0, 0.7])\n    # Training means\n    mu = np.array([16.0, 1000.0, 0.55])\n    # Training standard deviations\n    sigma = np.array([2.5, 120.0, 0.08])\n    # GLM coefficients [intercept, beta1, beta2, beta3]\n    beta = np.array([-0.5, 0.9, 0.6, 1.2])\n\n    test_cases = [\n        np.array([16.0, 1000.0, 0.55]),  # Test 1\n        np.array([24.0, 900.0, 0.60]),   # Test 2\n        np.array([12.0, 800.0, 0.40]),   # Test 3\n        np.array([10.0, 1300.0, 0.20])   # Test 4\n    ]\n\n    all_results = []\n\n    for z in test_cases:\n        # Step 1: Compute per-variable centrality-based similarity c_i(z_i)\n        c = np.zeros(3)\n        interval_width = b - a\n        \n        for i in range(3):\n            if z[i]  a[i]:\n                # Extrapolation below the lower bound\n                c[i] = -(a[i] - z[i]) / interval_width[i]\n            elif z[i] > b[i]:\n                # Extrapolation above the upper bound\n                c[i] = -(z[i] - b[i]) / interval_width[i]\n            else:\n                # Interpolation within the training range\n                s_i = (z[i] - a[i]) / interval_width[i]\n                c[i] = 1.0 - 2.0 * np.abs(s_i - 0.5)\n\n        # Step 2: Compute MESS score M(z) and determine extrapolation E(z)\n        m_z = np.min(c)\n        e_z = 1 if m_z  0 else 0\n\n        # Step 3: Perform predictor clamping\n        z_clamped = np.clip(z, a, b)\n        \n        # Step 4: Standardize original and clamped predictors\n        z_star = (z - mu) / sigma\n        z_clamped_star = (z_clamped - mu) / sigma\n\n        # Step 5: Calculate suitability scores S(z) and S(~z)\n        # Add intercept term for linear predictor calculation\n        z_star_with_intercept = np.insert(z_star, 0, 1)\n        z_clamped_star_with_intercept = np.insert(z_clamped_star, 0, 1)\n        \n        # We need to adjust the beta vector to use with the inserted '1'\n        # f(z) = beta0 + beta1*z1* + ...\n        # Let's compute manually to avoid confusion\n        f_z = beta[0] + np.dot(beta[1:], z_star)\n        f_z_clamped = beta[0] + np.dot(beta[1:], z_clamped_star)\n\n        # Logistic function S(x) = 1 / (1 + exp(-f(x)))\n        s_z = 1.0 / (1.0 + np.exp(-f_z))\n        s_z_clamped = 1.0 / (1.0 + np.exp(-f_z_clamped))\n\n        # Step 6: Quantify clamping-induced change\n        delta_s = s_z_clamped - s_z\n        \n        # Round results to 6 decimal places\n        result_tuple = [\n            round(m_z, 6),\n            e_z,\n            round(delta_s, 6)\n        ]\n        all_results.append(result_tuple)\n        \n    # Final print statement in the exact required format.\n    # The requirement `[[m1,e1,d1],[m2,e2,d2],...]` is the default string representation of a list of lists.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}