{
    "hands_on_practices": [
        {
            "introduction": "在物种分布模型中，原始的环境数据（如地表温度）本身往往不足以直接捕捉驱动物种分布的关键生态过程。相反，相对于历史基线的极端事件或异常值（例如热浪）通常更为重要。本练习  提供了一种动手实践方法，将时间序列的栅格数据转换为代表环境压力的强大预测因子，这是构建机理上更合理的模型的关键一步。",
            "id": "3852186",
            "problem": "为您提供代表地表温度（LST）的小型合成栅格，单位为摄氏度。将每个栅格视为一个像素值矩阵。目标是通过将目标温度栅格（特定时间）的每个像素值 $x$ 与历史栅格堆栈中同一像素的基线分布进行比较，将其转换为无量纲的标准化异常栅格。使用以下基本定义：一个像素在 $n$ 个基线栅格中的样本均值 $\\mu$ 是其值的算术平均值，无偏样本标准差 $\\sigma$ 是以 $n-1$ 为分母计算的样本方差的平方根。为避免当 $\\sigma$ 接近零时出现除以零或数值不稳定的情况，需要实施一种正则化策略，即使用修正后的标准差 $\\sigma_{\\epsilon}$，它是通过将基线离散度 $\\sigma$ 与一个与温度具有相同物理单位的微小正常数 $\\epsilon$ 组合得到的。标准化异常应为一个无量纲量，它反映了 $x$ 相对于 $\\sigma_{\\epsilon}$ 偏离 $\\mu$ 的程度。计算出标准化异常栅格后，导出一个二元胁迫掩码，如果某个像素的标准化异常的绝对值超过给定阈值，则该像素被标记为受胁迫。\n\n物理单位：温度单位为摄氏度（°C）。标准化异常是无量纲的。正则化常数的单位必须是 °C。胁迫阈值是无量纲的。\n\n算法要求：\n- 根据基线栅格堆栈计算每个像素的样本均值 $\\mu$ 和无偏样本标准差 $\\sigma$。\n- 定义稳定化离散度为 $\\sigma_{\\epsilon} = \\sqrt{\\sigma^2 + \\epsilon^2}$，其中 $\\epsilon = 0.01$ °C。\n- 使用 $\\mu$ 和 $\\sigma_{\\epsilon}$ 将每个目标像素值 $x$ 转换为无量纲的标准化异常。\n- 为每个像素创建一个布尔胁迫掩码，如果标准化异常的绝对值超过阈值 $t = 2$，则标记为受胁迫。\n- 对每个测试用例，返回三个输出：\n  1. 展平的标准化异常栅格（按行主序），作为浮点数列表，四舍五入到三位小数。\n  2. 展平的胁迫掩码（按行主序），作为布尔值列表，其中 True 表示 $|z| \\ge t$。\n  3. 受胁迫像素的比例，作为一个在闭区间 $[0,1]$ 内的浮点数，四舍五入到三位小数。\n\n测试套件：\n使用以下测试用例，每个用例包含一个由 $n=4$ 个栅格组成的基线堆栈和一个目标栅格。所有温度单位均为 °C。每个栅格大小为 $2 \\times 3$。\n\n- 用例1（典型变异性）：\n  基线堆栈：\n  $$\n  B_1 = \\begin{bmatrix} 20  21  22 \\\\ 23  24  25 \\end{bmatrix},\\;\n  B_2 = \\begin{bmatrix} 19  21  23 \\\\ 22  24  26 \\end{bmatrix},\\;\n  B_3 = \\begin{bmatrix} 20  22  22 \\\\ 23  25  25 \\end{bmatrix},\\;\n  B_4 = \\begin{bmatrix} 21  21  24 \\\\ 23  24  27 \\end{bmatrix}.\n  $$\n  目标：\n  $$\n  X = \\begin{bmatrix} 22  23  21 \\\\ 24  26  24 \\end{bmatrix}.\n  $$\n\n- 用例2（基线中存在零方差像素）：\n  基线堆栈：\n  $$\n  B_1 = \\begin{bmatrix} 15  30  5 \\\\ 10  0  12 \\end{bmatrix},\\;\n  B_2 = \\begin{bmatrix} 15  32  5 \\\\ 11  0  12 \\end{bmatrix},\\;\n  B_3 = \\begin{bmatrix} 15  28  5 \\\\ 9  0  12 \\end{bmatrix},\\;\n  B_4 = \\begin{bmatrix} 15  31  5 \\\\ 10  0  12 \\end{bmatrix}.\n  $$\n  目标：\n  $$\n  X = \\begin{bmatrix} 15  33  7 \\\\ 13  0  12 \\end{bmatrix}.\n  $$\n\n- 用例3（相对于基线的极端热浪）：\n  基线堆栈：\n  $$\n  B_1 = \\begin{bmatrix} 18  18  18 \\\\ 18  18  18 \\end{bmatrix},\\;\n  B_2 = \\begin{bmatrix} 19  19  19 \\\\ 19  19  19 \\end{bmatrix},\\;\n  B_3 = \\begin{bmatrix} 20  20  20 \\\\ 20  20  20 \\end{bmatrix},\\;\n  B_4 = \\begin{bmatrix} 19  19  19 \\\\ 19  19  19 \\end{bmatrix}.\n  $$\n  目标：\n  $$\n  X = \\begin{bmatrix} 35  35  35 \\\\ 35  35  35 \\end{bmatrix}.\n  $$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须为每个测试用例包含一个条目，每个条目本身都是一个列表，按上述顺序包含该用例的三个输出。例如：\n\"[case1_result,case2_result,case3_result]\"\n其中每个 \"caseX_result\" 本身就是包含上述三个输出的列表。",
            "solution": "我们从像素温度的统计特征入手，将其视为一个随机变量 $X$，其基线经验分布源自地表温度（LST）的历史卫星观测数据。对于给定像素，设基线观测值为 $\\{x_1, x_2, \\dots, x_n\\}$，其中 $n \\ge 2$。样本均值定义为\n$$\n\\mu = \\frac{1}{n} \\sum_{j=1}^{n} x_j,\n$$\n无偏样本方差为\n$$\ns^2 = \\frac{1}{n-1} \\sum_{j=1}^{n} (x_j - \\mu)^2,\n$$\n无偏样本标准差为\n$$\n\\sigma = \\sqrt{s^2}.\n$$\n为了给新的观测值 $x$ 构建一个无量纲的标准化异常，我们用离散度 $\\sigma$ 来缩放偏差 $x - \\mu$。然而，当基线变异性 $\\sigma$ 为零或非常小（例如，在基线观测值不变的像素中），该比率可能无定义或数值不稳定。一个广泛使用的稳定化策略是将 $\\sigma$ 与一个和 $X$ 具有相同物理单位的微小正常数 $\\epsilon$ 相结合，以获得一个严格为正的有效离散度\n$$\n\\sigma_{\\epsilon} = \\sqrt{\\sigma^2 + \\epsilon^2}.\n$$\n这类似于 Tikhonov 正则化：它在防止奇异点的同时，保持了分母中的单位。然后，标准化异常 $z$ 根据通过离散度进行归一化的第一性原理推导得出\n$$\nz = \\frac{x - \\mu}{\\sigma_{\\epsilon}}.\n$$\n根据定义，$z$ 是无量纲的：$z = 2$ 的异常值表示，当使用 $\\sigma_{\\epsilon}$ 衡量时，$x$ 比基线均值高出两个离散单位。\n\n与物种分布相关的胁迫事件通常是超出其生理或生态耐受范围的环境条件的偶发性偏离。在物种分布模型中，LST的极端异常可能表示热胁迫或冷胁迫，这些胁迫会改变物种的生存、繁殖、迁移或资源可得性。标准化异常 $z$ 以可在空间上比较的单位来量化偏离程度。绝对值 $|z|$ 超过阈值 $t$（此处 $t = 2$）的像素对应于其幅度相对于典型基线变异性较大的事件。识别此类事件可提供预测因子，用于捕捉仅靠长期气候平均值无法反映的急性胁迫事件。例如，通过热红外遥感探测到的异常高的LST可能与热浪同时发生，这些热浪会降低栖息地适宜性或使环境条件超出物种特定的热生态位。使用 $z$ 既包含了偏离的幅度，也包含了局部变异性的背景，从而实现了跨区域的可比性，这对于在景观到大陆尺度上建模物种分布至关重要。\n\n算法设计：\n1. 对于每个测试用例，使用无偏估计量（分母为 $n-1$）计算基线堆栈中每个像素的 $\\mu$ 和 $\\sigma$。\n2. 设置 $\\epsilon = 0.01$ °C，并为每个像素计算 $\\sigma_{\\epsilon} = \\sqrt{\\sigma^2 + \\epsilon^2}$。\n3. 使用 $z = (x - \\mu)/\\sigma_{\\epsilon}$ 为每个像素计算标准化异常栅格 $z$。\n4. 使用条件 $|z| \\ge t$（其中 $t = 2$）为每个像素创建布尔胁迫掩码。\n5. 将布尔掩码在所有像素上取平均值，计算受胁迫像素的比例，得到一个在 $[0, 1]$ 区间内的值。\n6. 将 $z$ 栅格和胁迫掩码按行主序展平，将 $z$ 值和受胁迫比例四舍五入到三位小数，并按规定汇总每个测试用例的输出。\n\n此过程遵循基本的统计定义，并为量化和检测作为物种分布模型中预测因子的环境胁迫事件提供了一种有原则的方法。由于 $z$ 是无量纲的，它适用于与其他标准化预测因子集成，也适用于在高级生态位模型（包括广义线性模型、广义相加模型和机器学习框架）中进行基于阈值的特征工程。使用一个小的 $\\epsilon$ 可确保数值稳定性，当 $\\sigma$ 足够大时，它不会显著改变 $z$ 的值，同时可以防止在基线变异性可忽略的区域（例如，持续均一的表面或粗糙的气候数据）出现发散。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_standardized_anomaly(baseline_stack, target_raster, epsilon=0.01, threshold=2.0):\n    \"\"\"\n    Compute per-pixel standardized anomaly z and stress mask.\n    baseline_stack: numpy array of shape (n, rows, cols)\n    target_raster: numpy array of shape (rows, cols)\n    epsilon: small positive constant in same units as temperature (°C)\n    threshold: dimensionless threshold for stress detection on |z|\n    Returns:\n        z_flat: list of floats (rounded to 3 decimals), flattened row-major\n        stress_flat: list of booleans, flattened row-major\n        stressed_fraction: float rounded to 3 decimals\n    \"\"\"\n    # Compute per-pixel unbiased sample mean and standard deviation across baseline rasters\n    mu = np.mean(baseline_stack, axis=0)\n    sigma = np.std(baseline_stack, axis=0, ddof=1)\n\n    # Stabilize the denominator using epsilon in °C\n    sigma_eps = np.sqrt(sigma**2 + epsilon**2)\n\n    # Compute standardized anomaly (dimensionless)\n    z = (target_raster - mu) / sigma_eps\n\n    # Stress mask: absolute z exceeding threshold\n    stress_mask = np.abs(z) >= threshold\n\n    # Flatten in row-major order\n    z_flat = np.round(z.flatten(), 3).tolist()\n    stress_flat = stress_mask.flatten().tolist()\n\n    # Fraction of stressed pixels\n    stressed_fraction = np.round(np.mean(stress_mask), 3)\n\n    return z_flat, stress_flat, float(stressed_fraction)\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1 (typical variability)\n    B1_1 = np.array([[20,21,22],[23,24,25]], dtype=float)\n    B1_2 = np.array([[19,21,23],[22,24,26]], dtype=float)\n    B1_3 = np.array([[20,22,22],[23,25,25]], dtype=float)\n    B1_4 = np.array([[21,21,24],[23,24,27]], dtype=float)\n    baseline1 = np.stack([B1_1, B1_2, B1_3, B1_4], axis=0)\n    target1 = np.array([[22,23,21],[24,26,24]], dtype=float)\n\n    # Case 2 (zero-variance pixels in baseline)\n    B2_1 = np.array([[15,30,5],[10,0,12]], dtype=float)\n    B2_2 = np.array([[15,32,5],[11,0,12]], dtype=float)\n    B2_3 = np.array([[15,28,5],[9,0,12]], dtype=float)\n    B2_4 = np.array([[15,31,5],[10,0,12]], dtype=float)\n    baseline2 = np.stack([B2_1, B2_2, B2_3, B2_4], axis=0)\n    target2 = np.array([[15,33,7],[13,0,12]], dtype=float)\n\n    # Case 3 (extreme heatwave relative to baseline)\n    B3_1 = np.array([[18,18,18],[18,18,18]], dtype=float)\n    B3_2 = np.array([[19,19,19],[19,19,19]], dtype=float)\n    B3_3 = np.array([[20,20,20],[20,20,20]], dtype=float)\n    B3_4 = np.array([[19,19,19],[19,19,19]], dtype=float)\n    baseline3 = np.stack([B3_1, B3_2, B3_3, B3_4], axis=0)\n    target3 = np.array([[35,35,35],[35,35,35]], dtype=float)\n\n    test_cases = [\n        (baseline1, target1, 0.01, 2.0),\n        (baseline2, target2, 0.01, 2.0),\n        (baseline3, target3, 0.01, 2.0),\n    ]\n\n    results = []\n    for baseline, target, eps, thr in test_cases:\n        z_flat, stress_flat, stressed_fraction = compute_standardized_anomaly(\n            baseline, target, epsilon=eps, threshold=thr\n        )\n        # Each case result is [z_flattened, stress_flattened, stressed_fraction]\n        results.append([z_flat, stress_flat, stressed_fraction])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "物种出现记录通常伴随着全球定位系统（GPS）的位置误差，这可能导致从栅格地图中提取环境数据时出现错误，即所谓的“尺度不匹配”问题。本练习  演示了一种严谨的、基于概率的方法来解决这种位置不确定性，超越了简单的点提取，以计算更准确的环境期望值。当GPS误差与栅格单元尺寸相当时，这项技能对于建立可靠的模型至关重要。",
            "id": "3852193",
            "problem": "给定一个在规则网格上定义的二维栅格预测场，以及一组点状分布数据，其记录位置受到全球定位系统（GPS）误差的影响。目标是将栅格点提取与位置不确定性进行协调，并在位置误差与栅格单元尺寸相当时，量化此不确定性的影响。所有空间坐标必须以米为单位，所有栅格单元尺寸必须以米为单位，预测值为无量纲（无单位）。您的程序必须为每个测试用例计算位置不确定性的影响，该影响量化为两个量：朴素提取与考虑不确定性的期望提取之间的偏差，以及由位置不确定性引起的标准差。输出必须为单行，包含一个嵌套的浮点数列表，保留六位小数。\n\n设置如下。考虑一个定义在 $N_{r} \\times N_{c}$ 个单元的矩形网格上的栅格，单元尺寸为 $s$ 米，原点位于左下角，坐标为 $(x_{0}, y_{0})$。由行 $i$ 和列 $j$（其中 $i \\in \\{0,\\dots,N_{r}-1\\}$ 且 $j \\in \\{0,\\dots,N_{c}-1\\}$）索引的单元覆盖了左闭右开矩形区间 $[x_{0} + j s, x_{0} + (j+1)s) \\times [y_{0} + i s, y_{0} + (i+1)s)$。栅格预测变量在每个单元上是分段常数，该单元上的值为 $v_{i,j}$，且预测值是无单位的。\n\n单个测量到的分布点位置 $(x_{m}, y_{m})$ 在每个轴上都受到各向同性、独立、零均值的高斯位置误差的影响。具体来说，相对于 $(x_{m}, y_{m})$ 的真实位置 $(X, Y)$ 服从一个双变量正态分布，其轴是独立的，在 $x$ 和 $y$ 方向上的标准差均为 $\\sigma$ 米，且均值为零。二维概率密度函数为 $p(x,y) = \\frac{1}{2\\pi \\sigma^{2}} \\exp\\left(-\\frac{x^{2} + y^{2}}{2\\sigma^{2}}\\right)$。朴素的栅格点提取方法取包含 $(x_{m}, y_{m})$ 的单个栅格单元 $(i_{0}, j_{0})$ 中的预测值 $v_{i_{0}, j_{0}}$。考虑不确定性的期望提取是在给定高斯误差和有限栅格范围的条件下，预测变量的条件期望。它通过在栅格域上对分段常数栅格场与位置误差密度进行积分，并在高斯质量部分落在栅格之外时进行重新归一化来获得。由不确定性引起的方差是在相同模型下预测值的条件方差。\n\n从概率密度和期望的基本定义出发，实现一个方法来为每个测试用例计算：\n- 朴素提取值 $v_{\\text{naive}}$，通过在 $(x_{m}, y_{m})$ 进行单元查找获得。\n- 考虑不确定性的期望值 $E[V]$，作为在高斯位置模型和有限网格域下栅格值的条件期望计算得出。\n- 由不确定性引起的方差 $\\mathrm{Var}[V] = E[V^{2}] - (E[V])^{2}$，其条件与上述相同。\n- 偏差 $b = v_{\\text{naive}} - E[V]$ 和标准差 $s_{V} = \\sqrt{\\mathrm{Var}[V]}$。\n\n通过正确处理栅格的有限范围来确保科学真实性：当 $\\sigma$ 相对于 $s$ 较大且高斯质量延伸到栅格之外时，通过栅格域内的总概率质量进行重新归一化，从而使得条件期望和方差是相对于栅格支持域上的截断分布计算的。各轴是独立的，且栅格在每个单元上是分段常数的。\n\n您的程序必须为以下测试套件计算上述量。在所有情况下，原点为 $(x_{0}, y_{0}) = (0, 0)$ 米，所有坐标 $(x_{m}, y_{m})$ 以米为单位，单元尺寸 $s$ 以米为单位，且根据定义，预测值是无单位的：\n\n- 测试用例 1（理想情况，$\\sigma$ 与单元尺寸相当）：$N_{r} = 7$, $N_{c} = 7$, $s = 100.0$, $\\sigma = 100.0$, $(x_{m}, y_{m}) = (3.3 s, 2.7 s)$。栅格由 $v_{i,j} = 0.2 + 0.01 i + 0.02 j + 0.005 i j$ 定义，适用于所有整数 $i, j$。\n- 测试用例 2（边界条件，大量截断）：$N_{r} = 5$, $N_{c} = 5$, $s = 100.0$, $\\sigma = 150.0$, $(x_{m}, y_{m}) = (0.05 s, 0.1 s)$。栅格由 $v_{i,j} = 1.0 + 0.1 i - 0.05 j$ 定义。\n- 测试用例 3（接近零的不确定性）：$N_{r} = 6$, $N_{c} = 6$, $s = 100.0$, $\\sigma = 1.0$, $(x_{m}, y_{m}) = (2.4 s, 1.6 s)$。栅格由 $v_{i,j} = 0.5 + 0.03 i + 0.04 j$ 定义。\n- 测试用例 4（大的不确定性）：$N_{r} = 5$, $N_{c} = 5$, $s = 100.0$, $\\sigma = 300.0$, $(x_{m}, y_{m}) = (2.5 s, 2.5 s)$。栅格由 $v_{i,j} = 0.2 + 0.02 i + 0.02 j + 0.01 (i - j)$ 定义。\n\n您的实现必须：\n- 利用轴的独立性和期望的定义，计算高斯模型下精确的矩形单元概率，并将它们在所有单元上聚合以获得 $E[V]$ 和 $E[V^{2}]$。必要时，通过栅格内概率质量进行重新归一化。\n- 将 $v_{\\text{naive}}$ 计算为包含 $(x_{m}, y_{m})$ 的单元的栅格值。\n- 为每个测试用例报告偏差 $b$ 和标准差 $s_{V}$。这两个数字必须以无单位的预测单位表示。\n- 将报告的每个浮点数四舍五入到六位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的嵌套逗号分隔列表，每个内部列表按顺序对应一个测试用例，并包含两个浮点数 $[b, s_{V}]$。例如，一个语法上有效的输出看起来像 $[[b_{1}, s_{V,1}],[b_{2}, s_{V,2}],[b_{3}, s_{V,3}],[b_{4}, s_{V,4}]]$，其中每个浮点数都四舍五入到六位小数。",
            "solution": "用户提供的问题陈述经过严格分析，被认定为有效。它在科学上基于空间统计学，且问题定义明确，为获得唯一且有意义的解提供了所有必要的参数和定义。该问题是客观的，没有歧义或矛盾。\n\n### 基于原理的解决方案设计\n\n该问题要求我们量化位置不确定性对从栅格网格中提取预测值的影响。问题的核心在于将朴素的点提取方法与一种概率性的、考虑不确定性的方法进行对比。我们将从概率论的第一性原理出发推导解决方案。\n\n#### 1. 数学模型\n\n设一个分布点的测量位置为 $(x_m, y_m)$。真实位置是一个随机变量 $(\\tilde{X}, \\tilde{Y})$。问题陈述表明，误差由各向同性、独立、零均值的高斯分布控制，每个轴上的标准差为 $\\sigma$。这意味着真实位置 $(\\tilde{X}, \\tilde{Y})$ 服从一个以 $(x_m, y_m)$ 为中心的双变量正态分布，其概率密度函数（PDF）为：\n$$\nf(\\tilde{x}, \\tilde{y}) = \\frac{1}{2\\pi\\sigma^2} \\exp\\left(-\\frac{(\\tilde{x} - x_m)^2 + (\\tilde{y} - y_m)^2}{2\\sigma^2}\\right)\n$$\n由于坐标轴的独立性，该 PDF 是可分离的：$f(\\tilde{x}, \\tilde{y}) = f_X(\\tilde{x}) f_Y(\\tilde{y})$，其中\n$$\nf_X(\\tilde{x}) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(\\tilde{x} - x_m)^2}{2\\sigma^2}\\right)\n$$\n且 $f_Y(\\tilde{y})$ 是类似的。\n\n预测变量是在栅格网格上定义的分段常数场 $V(\\tilde{x}, \\tilde{y})$。该网格有 $N_r \\times N_c$ 个尺寸为 $s \\times s$ 的单元。索引为 $(i, j)$ 的单元（其中 $i \\in \\{0, \\dots, N_r-1\\}$ 且 $j \\in \\{0, \\dots, N_c-1\\}$）对应于空间域 $[j s, (j+1)s) \\times [i s, (i+1)s)$（假设原点为 $(0,0)$）。在此单元内，预测值是常数，$V(\\tilde{x}, \\tilde{y}) = v_{i,j}$。\n\n#### 2. 朴素提取\n朴素提取值 $v_{\\text{naive}}$ 是包含测量位置 $(x_m, y_m)$ 的单个单元的预测值。该单元的索引 $(i_0, j_0)$ 由以下公式确定：\n$$\nj_0 = \\lfloor \\frac{x_m}{s} \\rfloor, \\quad i_0 = \\lfloor \\frac{y_m}{s} \\rfloor\n$$\n因此，$v_{\\text{naive}} = v_{i_0, j_0}$。\n\n#### 3. 考虑不确定性的期望和方差\n\n考虑不确定性的方法计算预测值 $V$ 的条件期望和方差，给定误差模型和栅格网格的有限范围。栅格域为 $\\mathcal{D} = [0, N_c s) \\times [0, N_r s)$。\n\n首先，我们必须计算落在栅格域 $\\mathcal{D}$ 内的位置分布的总概率质量：\n$$\nP_{\\mathcal{D}} = \\iint_{\\mathcal{D}} f(\\tilde{x}, \\tilde{y}) \\,d\\tilde{x} \\,d\\tilde{y}\n$$\n利用 PDF 的可分离性，上式变为：\n$$\nP_{\\mathcal{D}} = \\left( \\int_{0}^{N_c s} f_X(\\tilde{x}) \\,d\\tilde{x} \\right) \\left( \\int_{0}^{N_r s} f_Y(\\tilde{y}) \\,d\\tilde{y} \\right)\n$$\n这些一维积分可以使用标准正态分布的累积分布函数（CDF）$\\Phi(z) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{z} e^{-t^2/2} dt$ 来表示。\n$$\n\\int_{a}^{b} f_X(\\tilde{x}) \\,d\\tilde{x} = \\Phi\\left(\\frac{b - x_m}{\\sigma}\\right) - \\Phi\\left(\\frac{a - x_m}{\\sigma}\\right)\n$$\n因此，$P_{\\mathcal{D}}$ 是两个这样项的乘积，每个轴一项。该值 $P_{\\mathcal{D}}$ 作为我们条件概率空间的归一化常数。\n\n预测变量的条件期望 $E[V]$ 由下式给出：\n$$\nE[V] = \\frac{1}{P_{\\mathcal{D}}} \\iint_{\\mathcal{D}} V(\\tilde{x}, \\tilde{y}) f(\\tilde{x}, \\tilde{y}) \\,d\\tilde{x} \\,d\\tilde{y}\n$$\n由于 $V$ 是分段常数，我们可以将积分分解为所有单元的总和：\n$$\nE[V] = \\frac{1}{P_{\\mathcal{D}}} \\sum_{i=0}^{N_r-1} \\sum_{j=0}^{N_c-1} v_{i,j} \\iint_{\\text{cell}_{i,j}} f(\\tilde{x}, \\tilde{y}) \\,d\\tilde{x} \\,d\\tilde{y}\n$$\n设 $P_{i,j}$ 为单元 $(i,j)$ 内的概率质量：\n$$\nP_{i,j} = \\left( \\int_{js}^{(j+1)s} f_X(\\tilde{x}) \\,d\\tilde{x} \\right) \\left( \\int_{is}^{(i+1)s} f_Y(\\tilde{y}) \\,d\\tilde{y} \\right)\n$$\n每个积分再次使用正态 CDF 计算。然后，期望是单元值的加权平均：\n$$\nE[V] = \\frac{1}{P_{\\mathcal{D}}} \\sum_{i=0}^{N_r-1} \\sum_{j=0}^{N_c-1} v_{i,j} P_{i,j}\n$$\n类似地，条件二阶矩 $E[V^2]$ 是：\n$$\nE[V^2] = \\frac{1}{P_{\\mathcal{D}}} \\sum_{i=0}^{N_r-1} \\sum_{j=0}^{N_c-1} v_{i,j}^2 P_{i,j}\n$$\n然后使用标准公式找到条件方差 $\\mathrm{Var}[V]$：\n$$\n\\mathrm{Var}[V] = E[V^2] - (E[V])^2\n$$\n\n#### 4. 最终量\n\n所需的两个量是偏差 $b$ 和由不确定性引起的标准差 $s_V$：\n$$\nb = v_{\\text{naive}} - E[V]\n$$\n$$\ns_V = \\sqrt{\\mathrm{Var}[V]}\n$$\n为防止数值问题，如果计算出的方差由于浮点误差而为小的负数，则将其视为 $0$。\n\n#### 算法总结\n对于每个测试用例：\n1.  定义栅格参数（$N_r, N_c, s$）和误差模型参数（$\\sigma, x_m, y_m$）。\n2.  通过识别单元 $(i_0, j_0) = (\\lfloor y_m/s \\rfloor, \\lfloor x_m/s \\rfloor)$ 并检索其值 $v_{i_0, j_0}$ 来计算 $v_{\\text{naive}}$。\n3.  使用正态 CDF 计算栅格整个范围内的总概率质量 $P_{\\mathcal{D}}$。\n4.  遍历栅格的每个单元 $(i, j)$：\n    a. 计算该单元内的概率质量 $P_{i,j}$。\n    b. 检索单元值 $v_{i,j}$。\n    c. 累加总和 $\\sum v_{i,j} P_{i,j}$ 和 $\\sum v_{i,j}^2 P_{i,j}$。\n5.  通过将累加的总和除以 $P_{\\mathcal{D}}$ 来计算 $E[V]$ 和 $E[V^2]$。\n6.  计算 $\\mathrm{Var}[V] = E[V^2] - (E[V])^2$。\n7.  计算最终指标 $b = v_{\\text{naive}} - E[V]$ 和 $s_V = \\sqrt{\\max(0, \\mathrm{Var}[V])}$。\n8.  按要求四舍五入并报告结果。\n\n此方法正确地考虑了栅格的分段常数性质、连续高斯误差模型以及空间数据的有限边界，为问题提供了严谨的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    def compute_metrics(nr, nc, s, sigma, xm, ym, v_func):\n        \"\"\"\n        Computes bias and standard deviation for a single test case.\n\n        Args:\n            nr (int): Number of rows in the raster.\n            nc (int): Number of columns in the raster.\n            s (float): Cell size in meters.\n            sigma (float): Standard deviation of Gaussian error in meters.\n            xm (float): Measured x-coordinate in meters.\n            ym (float): Measured y-coordinate in meters.\n            v_func (callable): Function v_func(i, j) to get raster value.\n\n        Returns:\n            tuple: A tuple containing (bias, std_dev).\n        \"\"\"\n        # 1. Naive extraction\n        # The cell definition is [js, (j+1)s) x [is, (i+1)s), so floor is correct.\n        j0 = int(np.floor(xm / s))\n        i0 = int(np.floor(ym / s))\n        \n        # Ensure indices are within bounds in case xm/ym fall on the boundary.\n        # e.g., if xm = nc * s, floor would give nc.\n        j0 = min(j0, nc - 1)\n        i0 = min(i0, nr - 1)\n        \n        v_naive = v_func(i0, j0)\n\n        # 2. Uncertainty-aware calculation\n        \n        def prob_1d(a, b, loc, scale):\n            # Computes integral of 1D normal PDF from a to b.\n            if scale == 0 or scale  1e-9: # Effectively a dirac delta\n                if a = loc  b:\n                    return 1.0\n                else:\n                    return 0.0\n            # Use scipy's highly accurate CDF implementation\n            return norm.cdf(b, loc=loc, scale=scale) - norm.cdf(a, loc=loc, scale=scale)\n\n        # 2a. Total probability mass within the grid domain\n        total_prob_x = prob_1d(0, nc * s, xm, sigma)\n        total_prob_y = prob_1d(0, nr * s, ym, sigma)\n        total_prob = total_prob_x * total_prob_y\n\n        # Handle edge case where no probability mass is in the grid\n        if total_prob = 1e-12:\n            # Conditional distribution is undefined. Assume E[V]=0, Var[V]=0.\n            # This implies the point is extremely far from the grid.\n            # This choice makes bias = v_naive and s_V = 0.\n            E_V = 0.0\n            Var_V = 0.0\n        else:\n            # 2b. Loop over cells to compute moments\n            sum_v_p = 0.0\n            sum_v2_p = 0.0\n            \n            # Precompute cell probabilities for each axis to optimize the loops\n            # This avoids recomputing the same 1D integrals.\n            cell_probs_x = np.array([prob_1d(j * s, (j + 1) * s, xm, sigma) for j in range(nc)])\n            cell_probs_y = np.array([prob_1d(i * s, (i + 1) * s, ym, sigma) for i in range(nr)])\n\n            for i in range(nr):\n                p_y = cell_probs_y[i]\n                if p_y == 0: continue # Optimization\n                for j in range(nc):\n                    p_x = cell_probs_x[j]\n                    if p_x == 0: continue # Optimization\n\n                    v_ij = v_func(i, j)\n                    p_ij = p_y * p_x\n                    \n                    sum_v_p += v_ij * p_ij\n                    sum_v2_p += v_ij**2 * p_ij\n            \n            # 2c. Renormalize to get conditional moments\n            E_V = sum_v_p / total_prob\n            E_V2 = sum_v2_p / total_prob\n            \n            # Ensure variance is non-negative due to potential floating point errors\n            Var_V = E_V2 - E_V**2\n            if Var_V  0:\n                Var_V = 0.0\n\n        # 3. Final quantities\n        bias = v_naive - E_V\n        s_V = np.sqrt(Var_V)\n        \n        return bias, s_V\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        {'nr': 7, 'nc': 7, 's': 100.0, 'sigma': 100.0, 'xm': 3.3 * 100.0, 'ym': 2.7 * 100.0, 'v_func': lambda i, j: 0.2 + 0.01 * i + 0.02 * j + 0.005 * i * j},\n        # Case 2: Boundary condition\n        {'nr': 5, 'nc': 5, 's': 100.0, 'sigma': 150.0, 'xm': 0.05 * 100.0, 'ym': 0.1 * 100.0, 'v_func': lambda i, j: 1.0 + 0.1 * i - 0.05 * j},\n        # Case 3: Near-zero uncertainty\n        {'nr': 6, 'nc': 6, 's': 100.0, 'sigma': 1.0, 'xm': 2.4 * 100.0, 'ym': 1.6 * 100.0, 'v_func': lambda i, j: 0.5 + 0.03 * i + 0.04 * j},\n        # Case 4: Large uncertainty\n        {'nr': 5, 'nc': 5, 's': 100.0, 'sigma': 300.0, 'xm': 2.5 * 100.0, 'ym': 2.5 * 100.0, 'v_func': lambda i, j: 0.2 + 0.02 * i + 0.02 * j + 0.01 * (i - j)}\n    ]\n\n    results = []\n    for case in test_cases:\n        bias, s_V = compute_metrics(**case)\n        results.append([bias, s_V])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "物种分布建模中的一个常见陷阱是由于空间自相关而高估了模型的预测性能，导致标准的随机交叉验证在空间背景下常常失效。本练习  是一项批判性思维实践，旨在探讨这种情况发生的原因，以及空间交叉验证如何为模型在新地理区域的泛化能力提供更切合实际的评估。掌握这一概念是避免建模中严重错误、确保结论可靠性的前提。",
            "id": "3852189",
            "problem": "您正在为一个位于 $\\mathbf{s} \\in \\mathcal{D} \\subset \\mathbb{R}^{2}$ 的二元存在-缺失响应 $Y(\\mathbf{s}) \\in \\{0,1\\}$ 建立一个物种分布模型（SDM; Species Distribution Model），该模型使用一组遥感环境变量 $\\mathbf{X}(\\mathbf{s}) \\in \\mathbb{R}^{p}$ 作为预测因子。假设数据生成结构如下：$Y(\\mathbf{s})$ 的条件均值遵循一个逻辑斯蒂连接函数，其线性预测器为 $\\eta(\\mathbf{s}) = \\beta_{0} + \\boldsymbol{\\beta}^{\\top} \\mathbf{X}(\\mathbf{s}) + \\varepsilon(\\mathbf{s})$，其中 $\\varepsilon(\\mathbf{s})$ 是一个零均值空间随机效应，其协方差函数为 $\\operatorname{Cov}[\\varepsilon(\\mathbf{s}), \\varepsilon(\\mathbf{s}^{\\prime})] = \\sigma^{2} \\rho(\\lVert \\mathbf{s} - \\mathbf{s}^{\\prime} \\rVert)$，相关函数 $\\rho(h)$ 随分离距离 $h$ 单调递减，并满足 $\\rho(0)=1$ 和当 $h \\to \\infty$ 时 $\\rho(h) \\to 0$。环境变量 $\\mathbf{X}(\\mathbf{s})$ 本身也存在空间自相关。您希望估计区域外泛化性能的期望值，该性能定义为在距离所有训练位置至少为 $h_{\\star}$ 的测试位置 $\\mathbf{s}_{\\text{test}}$ 上进行预测时的期望损失，其中 $h_{\\star}$ 足够大以至于 $\\rho(h_{\\star}) \\approx 0$。考虑使用 $K$ 折的交叉验证程序，并假设 $K \\geq 2$。\n\n在此情景下，下列关于空间交叉验证和随机交叉验证的陈述中，哪些是正确的？选择所有适用项。\n\nA. 空间交叉验证将观测数据划分到地理上不相交的折中，以使训练集和测试集之间的距离至少为 $h_{\\star}$（其中 $\\rho(h_{\\star}) \\approx 0$），从而减少折之间的统计依赖性，并与随机交叉验证相比，产生对区域外泛化误差的偏差更小的估计。\n\nB. 在存在空间自相关的情况下，随机交叉验证仍然是无偏的，因为独立性假设仅适用于模型残差，而不适用于观测对 $\\{Y(\\mathbf{s}), \\mathbf{X}(\\mathbf{s})\\}$，并且残差的独立性由最大似然估计自动保证。\n\nC. 在空间结构化的物种分布模型中，随机交叉验证倾向于高估预测性能，因为许多测试位置会落在训练位置的空间自相关范围内，因此预测值会因 $\\rho(h)  0$ 导致的信息泄露而受益；因此，交叉验证得到的分数反映的是短程插值，而非真实的区域外泛化。\n\nD. 空间交叉验证应始终使用固定大小的棋盘格分块方案，并选择块大小以最小化样本内偏差，因为这能保证对迁移性能作出最优无偏的估计。\n\nE. 如果环境变量 $\\mathbf{X}(\\mathbf{s})$ 被完美测量，且物种分布模型的参数形式是正确的，那么即使当 $\\rho(h)  0$ 时，随机交叉验证对于区域外性能的估计也是无偏的，因为在以 $\\mathbf{X}(\\mathbf{s})$ 为条件时，$Y(\\mathbf{s})$ 中任何剩余的空间自相关都不能影响测试预测。",
            "solution": "用户希望我扮演一位严谨的STEM教授，批判性地验证一个关于物种分布模型和交叉验证的给定问题陈述，然后提供详细的解决方案。\n\n### 第1步：提取已知条件\n- **响应变量**：位于位置 $\\mathbf{s} \\in \\mathcal{D} \\subset \\mathbb{R}^{2}$ 的二元存在-缺失响应 $Y(\\mathbf{s}) \\in \\{0,1\\}$。\n- **预测因子**：一组遥感环境变量 $\\mathbf{X}(\\mathbf{s}) \\in \\mathbb{R}^{p}$。预测因子 $\\mathbf{X}(\\mathbf{s})$ 具有空间自相关性。\n- **模型结构**：$Y(\\mathbf{s})$ 的条件均值遵循逻辑斯蒂连接函数，其线性预测器为 $\\eta(\\mathbf{s})$。\n- **线性预测器**：$\\eta(\\mathbf{s}) = \\beta_{0} + \\boldsymbol{\\beta}^{\\top} \\mathbf{X}(\\mathbf{s}) + \\varepsilon(\\mathbf{s})$。\n- **空间随机效应**：$\\varepsilon(\\mathbf{s})$ 是一个零均值空间随机效应。\n- **协方差结构**：随机效应的协方差函数为 $\\operatorname{Cov}[\\varepsilon(\\mathbf{s}), \\varepsilon(\\mathbf{s}^{\\prime})] = \\sigma^{2} \\rho(\\lVert \\mathbf{s} - \\mathbf{s}^{\\prime} \\rVert)$。\n- **相关函数**：$\\rho(h)$ 是分离距离 $h = \\lVert \\mathbf{s} - \\mathbf{s}^{\\prime} \\rVert$ 的单调递减函数，满足 $\\rho(0)=1$ 和当 $h \\to \\infty$ 时 $\\rho(h) \\to 0$。\n- **目标**：估计期望的区域外泛化性能。\n- **“区域外”的定义**：在距离所有训练位置至少为 $h_{\\star}$ 的测试位置 $\\mathbf{s}_{\\text{test}}$ 进行预测，其中 $h_{\\star}$ 足够大以至于空间相关性可以忽略不计，即 $\\rho(h_{\\star}) \\approx 0$。\n- **评估方法**：使用 $K$ 折的交叉验证（CV），其中 $K \\geq 2$。\n\n### 第2步：使用提取的已知条件进行验证\n问题陈述描述了空间统计和生态建模中的一个标准场景。\n- **科学依据（关键）**：所提出的模型是一个空间广义线性混合模型（GLMM）。这是现代物种分布建模的基石，用于解释未被环境变量捕获的空间自相关。对二元数据使用逻辑斯蒂连接函数、预测因子的线性组合以及具有衰减相关函数的空间随机效应，这些都是标准的、完善的理论结构。该问题在科学上是合理的。\n- **适定性**：问题是适定的。它定义了一个清晰的统计模型和一个需要估计的特定量（区域外泛化误差）。然后，它要求在此背景下对两种标准估计程序（随机交叉验证与空间交叉验证）进行定性比较。进行有意义的分析是可能的。\n- **客观性（关键）**：语言正式、精确、客观，使用了统计学和遥感的标准术语。没有主观或含糊的陈述。\n- **不完整或矛盾的设定**：设定是自洽的，提供了对交叉验证方法的统计特性进行推理所需的所有必要信息。\n- **不切实际或不可行**：该场景非常现实。物种出现数据和源自遥感的环境数据都已知表现出强烈的空间自相关性。评估模型在新的、地理上分离的区域（迁移性）的性能，是保护和生态学中一个关键且实际的关注点。\n- **其他缺陷**：未发现其他缺陷。该问题是应用统计学中一个有效且表述良好的问题。\n\n### 第3步：结论与行动\n问题是有效的。我将继续推导解决方案。\n\n### 推导与选项分析\n\n数据生成过程是为位于 $\\mathbf{s}$ 的响应 $Y(\\mathbf{s})$ 指定的。物种存在的概率 $p(\\mathbf{s}) = P(Y(\\mathbf{s})=1)$ 由逻辑斯蒂模型给出：\n$$ \\operatorname{logit}(p(\\mathbf{s})) = \\log\\left(\\frac{p(\\mathbf{s})}{1 - p(\\mathbf{s})}\\right) = \\eta(\\mathbf{s}) = \\beta_{0} + \\boldsymbol{\\beta}^{\\top} \\mathbf{X}(\\mathbf{s}) + \\varepsilon(\\mathbf{s}) $$\n关键要素是空间随机效应 $\\varepsilon(\\mathbf{s})$，它在地理上相近的观测值之间引入了相关性。具体来说，对于任意两个位置 $\\mathbf{s}_i$ 和 $\\mathbf{s}_j$，即使以它们的预测因子 $\\mathbf{X}(\\mathbf{s}_i)$ 和 $\\mathbf{X}(\\mathbf{s}_j)$ 为条件，响应 $Y(\\mathbf{s}_i)$ 和 $Y(\\mathbf{s}_j)$ 也不是独立的。它们的依赖性是由 $\\varepsilon(\\mathbf{s}_i)$ 和 $\\varepsilon(\\mathbf{s}_j)$ 之间的相关性驱动的，只要距离 $h = \\lVert \\mathbf{s}_i - \\mathbf{s}_j \\rVert$ 小于空间自相关的范围，这种相关性就非零。\n\n目标是估计“区域外泛化性能”，即在远离任何训练数据位置 $\\mathbf{s}_{\\text{train}}$ 的测试数据位置 $\\mathbf{s}_{\\text{test}}$ 上的性能。形式上，对于所有训练点，$\\lVert \\mathbf{s}_{\\text{test}} - \\mathbf{s}_{\\text{train}} \\rVert \\ge h_{\\star}$，其中 $\\rho(h_{\\star}) \\approx 0$。这意味着测试位置的随机效应 $\\varepsilon(\\mathbf{s}_{\\text{test}})$ 与所有训练位置的随机效应 $\\varepsilon(\\mathbf{s}_{\\text{train}})$ 不相关。\n\n**随机交叉验证 (RCV)**：RCV 将数据点随机分配到各个折中。因此，一个折中的测试点很可能在地理上靠近其他折中的某些训练点。对于这样一个测试点 $\\mathbf{s}_{\\text{test}}$ 和一个附近的训练点 $\\mathbf{s}_{\\text{train}}$ 对，距离 $h = \\lVert \\mathbf{s}_{\\text{test}} - \\mathbf{s}_{\\text{train}} \\rVert$ 很小，因此 $\\rho(h)  0$。因此，训练数据包含了关于测试位置随机效应值 $\\varepsilon(\\mathbf{s}_{\\text{test}})$ 的信息。一个拟合好的模型可以利用这些信息（例如，通过经验贝叶斯估计或对随机效应场进行克里金插值）来做出更准确的预测。这个预测任务是空间插值。然而，目标是估计空间*外推*（区域外）的性能，而此时这些信息是不存在的。因为插值比外推更容易，所以 RCV 会对区域外泛化性能产生一个过于乐观的有偏估计（即，它报告的性能会比实际可达到的要好）。\n\n**空间交叉验证 (SCV)**：SCV 旨在解决这个问题。它根据空间位置将数据划分到不同的折中，创建地理上连续的块或缓冲区。其关键思想是确保测试折中的任何点与其相应训练集中的任何点之间的最小距离足够大（理想情况下 $\\ge h_{\\star}$），以打破空间依赖性。通过这样做，每个折的测试集与其训练集变得近似独立，从而模拟了区域外预测的场景。因此，SCV 提供了一个偏差小得多、更现实的区域外泛化性能估计。\n\n现在，我们基于这一理解来评估每个选项。\n\n**A. 空间交叉验证将观测数据划分到地理上不相交的折中，以使训练集和测试集之间的距离至少为 $h_{\\star}$（其中 $\\rho(h_{\\star}) \\approx 0$），从而减少折之间的统计依赖性，并与随机交叉验证相比，产生对区域外泛化误差的偏差更小的估计。**\n这个陈述准确地描述了空间交叉验证的理想实施方式和目的。通过创建地理上不相交的折，它强制训练集和测试集之间有最小的分离距离。这种分离的目的是确保由空间随机效应 $\\varepsilon(\\mathbf{s})$（其相关性为 $\\rho(h)$）引起的统计依赖性被最小化或消除。这使得验证过程能更好地模拟区域外预测的目标任务。因此，与随机交叉验证产生的结果相比，其泛化误差的估计具有更小的乐观偏差。\n**结论：正确。**\n\n**B. 在存在空间自相关的情况下，随机交叉验证仍然是无偏的，因为独立性假设仅适用于模型残差，而不适用于观测对 $\\{Y(\\mathbf{s}), \\mathbf{X}(\\mathbf{s})\\}$，并且残差的独立性由最大似然估计自动保证。**\n这个陈述在几个方面都是不正确的。首先，在这种情况下，随机交叉验证在估计区域外性能方面明显是有偏的（过于乐观）。其次，交叉验证的有效性依赖于训练集和测试集的独立性，而这一点在这里被违反了。陈述中“独立性假设仅适用于模型残差”的说法具有误导性；观测值之间的依赖性正是导致 RCV 在此目标下失效的问题所在。第三，“残差的独立性由最大似然估计自动保证”的说法是错误的。最大似然估计（MLE）是一种在*给定一组假设*（可能包括独立性）下寻找最能拟合数据的模型参数的方法；如果底层结构是相关的，并且验证方案没有尊重这一点，它并不能神奇地在数据或残差中创造独立性。\n**结论：不正确。**\n\n**C. 在空间结构化的物种分布模型中，随机交叉验证倾向于高估预测性能，因为许多测试位置会落在训练位置的空间自相关范围内，因此预测值会因 $\\rho(h)  0$ 导致的信息泄露而受益；因此，交叉验证得到的分数反映的是短程插值，而非真实的区域外泛化。**\n这个陈述为随机交叉验证在此背景下的失败提供了一个极好且准确的解释。“高估预测性能”正确地指出了偏差的方向（例如，AUC 会被夸大，错误率会被低估）。其机制被正确地识别为“信息泄露”，这是由于测试点靠近训练点，使其相关的随机效应（通过 $\\rho(h)0$ 介导）能够为预测提供信息。正在执行的任务（短程插值）与目标任务（区域外泛化）之间的区别是问题的核心。\n**结论：正确。**\n\n**D. 空间交叉验证应始终使用固定大小的棋盘格分块方案，并选择块大小以最小化样本内偏差，因为这能保证对迁移性能作出最优无偏的估计。**\n这个陈述过于绝对，并且包含不正确的信息。虽然棋盘格方案是一种空间交叉验证方法，但它不是唯一的，也并非“总是”最佳选择。还存在其他方法，如分块交叉验证或带缓冲区的交叉验证。更重要的是，选择块大小的标准是错误的。块大小必须根据数据的空间结构来选择，特别是空间自相关的范围，以确保折之间有足够的分离。目标是使块大小大于自相关范围。“最小化样本内偏差”是一个与最大化训练数据似然相关的模型拟合标准；它不是设计有效交叉验证分区的原则。最后，没有哪种实用方法能“保证”一个“最优无偏”的估计。空间交叉验证旨在减少偏差，但关于最优性和保证的说法是没有根据的。\n**结论：不正确。**\n\n**E. 如果环境变量 $\\mathbf{X}(\\mathbf{s})$ 被完美测量，且物种分布模型的参数形式是正确的，那么即使当 $\\rho(h)  0$ 时，随机交叉验证对于区域外性能的估计也是无偏的，因为在以 $\\mathbf{X}(\\mathbf{s})$ 为条件时，$Y(\\mathbf{s})$ 中任何剩余的空间自相关都不能影响测试预测。**\n这个陈述是错误的。它错误地假设包含预测因子 $\\mathbf{X}(\\mathbf{s})$ 就消除了空间自相关的问题。模型明确包含了 $\\varepsilon(\\mathbf{s})$ 项，以解释*未被* $\\mathbf{X}(\\mathbf{s})$ 解释的空间模式。即使模型被完美指定和拟合，对新位置 $\\mathbf{s}_{\\text{test}}$ 的预测仍将涉及对 $\\varepsilon(\\mathbf{s}_{\\text{test}})$ 的估计。在 GLMM 的背景下，这个预测是以整个训练集为条件的，而训练集包含了关于已实现的随机效应场的信息。如果 $\\mathbf{s}_{\\text{test}}$ 靠近一个训练点 $\\mathbf{s}_{\\text{train}}$，那么 $\\varepsilon(\\mathbf{s}_{\\text{test}})$ 和 $\\varepsilon(\\mathbf{s}_{\\text{train}})$ 之间的相关性将被用来改善预测（这是克里金插值的原理）。因此，由 $\\varepsilon(\\mathbf{s})$ 代表的剩余空间自相关绝对会影响测试预测，随机交叉验证仍然是有偏的。\n**结论：不正确。**",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}