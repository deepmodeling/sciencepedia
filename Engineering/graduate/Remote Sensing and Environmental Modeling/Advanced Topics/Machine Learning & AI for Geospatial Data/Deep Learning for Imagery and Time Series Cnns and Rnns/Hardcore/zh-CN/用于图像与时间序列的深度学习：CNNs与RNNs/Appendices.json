{
    "hands_on_practices": [
        {
            "introduction": "高光谱遥感影像提供了丰富的光谱信息，但也给深度学习模型带来了巨大的计算挑战。直接应用标准的三维卷积神经网络（CNN）可能会因其高昂的参数量和计算成本而变得不可行。本练习将引导你从第一性原理出发，推导和分析三维卷积的计算复杂性，并通过比较密集卷积与可分离卷积的差异，掌握设计高效深度学习模型的关键技能，这对于处理高维遥感数据至关重要。",
            "id": "3805474",
            "problem": "考虑一个高光谱图像立方体，表示为一个三维张量 $X \\in \\mathbb{R}^{H \\times W \\times C}$，其中 $H$ 和 $W$ 是空间高度和宽度，$C$ 是光谱带的数量。您设计一个层，该层使用 $F$ 个输出滤波器执行三维卷积，所有维度的步幅均为 $1$，并选择填充方式以使输出与输入的空间和光谱维度相同（通常称为“same”填充）。每个滤波器使用一个大小为 $(k_{s}, k_{s}, k_{\\lambda})$ 的空间-光谱核，并且在卷积之后为每个输出滤波器添加一个标量偏置。您需要从第一性原理出发，量化模型的复杂度和计算负担。\n\n从离散卷积的定义（核支撑域上的乘积之和）开始，将计算成本定义为在单个输入立方体 $X$ 上单次前向传播中执行的标量乘加对（一次乘法后跟一次加法，通常缩写为乘法累加（MAC））的总数。在MAC计数中，偏置的加法可忽略不计。\n\n现在考虑一种替代设计，其中每个输出滤波器的三维核被限制为空间-光谱可分离的，即核等于一个空间二维核 $A \\in \\mathbb{R}^{k_{s} \\times k_{s}}$ 和一个光谱一维核 $b \\in \\mathbb{R}^{k_{\\lambda}}$ 的外积。将此可分离核实现为两次连续的卷积：首先，在每个光谱索引上独立地应用与 $A$ 的二维卷积；然后，在每个空间位置上独立地沿光谱维度应用与 $b$ 的一维卷积；最后为每个输出滤波器添加一个标量偏置。假设在每个阶段，步幅为 $1$ 且选择填充以保持维度不变。\n\n推导密集三维卷积和可分离空间-光谱设计两种情况下，一次前向传播中可训练参数的总数和MAC总数的符号表达式，用 $H$、$W$、$C$、$F$、$k_{s}$ 和 $k_{\\lambda}$ 表示。最后，以闭式解析表达式的形式给出这两个比率：密集与可分离参数数量之比，以及密集与可分离MAC数量之比。最终答案仅以这两个比率的精确符号形式表示，不进行数值代入或四舍五入。",
            "solution": "该问题要求从第一性原理出发，推导两种应用于高光谱数据立方体的三维卷积层的可训练参数数量和计算复杂度（以乘加运算，即MAC为单位）。输入是一个张量 $X \\in \\mathbb{R}^{H \\times W \\times C}$，其中 $H$ 和 $W$ 是空间维度，$C$ 是光谱维度。该层有 $F$ 个输出滤波器。在这两种情况下，步幅均为 $1$，并选择填充以使每个输出特征图的维度与输入维度 $H, W, C$ 保持一致。\n\n首先，我们分析标准（密集）三维卷积。\n\n一个具有 $F$ 个滤波器的密集3D卷积层有 $F$ 个不同的核。每个核，我们将其表示为 $K_f$（对于滤波器 $f \\in \\{1, \\dots, F\\}$），是一个大小为 $k_s \\times k_s \\times k_\\lambda$ 的三维张量。此外，每个滤波器 $f$ 都有一个标量偏置项 $b_f$。\n\n单个滤波器 $f$ 的可训练参数数量是其核中元素数量与偏置之和。核 $K_f$ 有 $k_s \\times k_s \\times k_\\lambda = k_s^2 k_\\lambda$ 个权重参数。偏置 $b_f$ 是 $1$ 个参数。因此，一个滤波器有 $(k_s^2 k_\\lambda + 1)$ 个参数。由于有 $F$ 个这样的滤波器，每个滤波器都有一套独立的参数，因此密集卷积层的可训练参数总数 $P_{\\text{dense}}$ 为：\n$$P_{\\text{dense}} = F \\cdot (k_s^2 k_\\lambda + 1)$$\n\n接下来，我们计算单次前向传播的MAC数量。一个MAC定义为一次乘法后跟一次加法。输出特征图中每个元素的计算都涉及核与输入张量相应区域的点积。对于一个大小为 $k_s \\times k_s \\times k_\\lambda$ 的核，此点积需要 $k_s^2 k_\\lambda$ 次乘法。根据问题的定义，这对应于 $k_s^2 k_\\lambda$ 个MAC（因为在MAC计数中，偏置加法可忽略不计）。\n\n该层产生 $F$ 个输出特征图。由于采用“same”填充和步幅为 $1$，每个特征图的维度均为 $H \\times W \\times C$。因此，输出张量中的元素总数为 $F \\times H \\times W \\times C$。由于计算这些元素中的每一个都需要 $k_s^2 k_\\lambda$ 个MAC，因此密集卷积层的MAC总数 $M_{\\text{dense}}$ 为：\n$$M_{\\text{dense}} = (F \\cdot H \\cdot W \\cdot C) \\cdot (k_s^2 k_\\lambda) = F \\cdot HWC \\cdot k_s^2 k_\\lambda$$\n\n其次，我们分析空间-光谱可分离卷积。\n\n在这种设计中，$F$ 个滤波器中的每一个都不是由一个密集的三维核来参数化，而是由一对较小的核来参数化：一个空间核 $A_f \\in \\mathbb{R}^{k_s \\times k_s}$ 和一个光谱核 $b_f \\in \\mathbb{R}^{k_\\lambda}$。密集的三维核被隐式地定义为 $A_f$ 和 $b_f$ 的外积。\n\n单个滤波器 $f$ 的可训练参数数量是 $A_f$ 中的元素数量、$b_f$ 中的元素数量和单个标量偏置之和。空间核 $A_f$ 有 $k_s^2$ 个参数。光谱核 $b_f$ 有 $k_\\lambda$ 个参数。偏置是 $1$ 个参数。因此，一个可分离滤波器有 $(k_s^2 + k_\\lambda + 1)$ 个参数。对于 $F$ 个滤波器，参数总数 $P_{\\text{sep}}$ 为：\n$$P_{\\text{sep}} = F \\cdot (k_s^2 + k_\\lambda + 1)$$\n\n计算成本通过分析所述的两阶段过程来计算。\n阶段1：应用二维空间卷积。对于 $F$ 个滤波器中的每一个，其空间核 $A_f$ 与输入张量 $X$ 的 $C$ 个光谱切片中的每一个进行卷积。为滤波器 $f$ 生成一个大小为 $H \\times W \\times C$ 的中间特征图，我们执行 $C$ 次独立的二维卷积（每个切片一次）。在这些二维卷积中计算一个像素的成本是 $k_s^2$ 个MAC。对于单个滤波器 $f$，在 $H \\times W$ 空间维度和 $C$ 个切片上，成本为 $H \\cdot W \\cdot C \\cdot k_s^2$。对于所有 $F$ 个滤波器，阶段1的总MAC数 $M_1$ 为：\n$$M_1 = F \\cdot HWC \\cdot k_s^2$$\n\n阶段2：应用一维光谱卷积。对于每个滤波器 $f$，其光谱核 $b_f$ 与阶段1生成的中间特征图进行卷积。该卷积沿光谱维度执行，对于 $H \\times W$ 个空间位置中的每一个都是独立的。计算一个最终输出像素的成本是一次长度为 $k_\\lambda$ 的一维卷积，需要 $k_\\lambda$ 个MAC。最终输出有 $F \\cdot H \\cdot W \\cdot C$ 个元素。因此，阶段2的总MAC数 $M_2$ 为：\n$$M_2 = F \\cdot HWC \\cdot k_\\lambda$$\n\n可分离设计的MAC总数 $M_{\\text{sep}}$ 是两个阶段MAC数的总和：\n$$M_{\\text{sep}} = M_1 + M_2 = F \\cdot HWC \\cdot k_s^2 + F \\cdot HWC \\cdot k_\\lambda = F \\cdot HWC \\cdot (k_s^2 + k_\\lambda)$$\n\n最后，我们计算所需的比率。\n\n参数数量之比为：\n$$\\text{Ratio}_P = \\frac{P_{\\text{dense}}}{P_{\\text{sep}}} = \\frac{F (k_s^2 k_\\lambda + 1)}{F (k_s^2 + k_\\lambda + 1)} = \\frac{k_s^2 k_\\lambda + 1}{k_s^2 + k_\\lambda + 1}$$\n\nMAC数量之比为：\n$$\\text{Ratio}_M = \\frac{M_{\\text{dense}}}{M_{\\text{sep}}} = \\frac{F \\cdot HWC \\cdot k_s^2 k_\\lambda}{F \\cdot HWC \\cdot (k_s^2 + k_\\lambda)} = \\frac{k_s^2 k_\\lambda}{k_s^2 + k_\\lambda}$$\n\n这两个表达式分别表示通过使用可分离卷积而非密集卷积所实现模型复杂度和计算成本的降低程度。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{k_s^{2} k_{\\lambda} + 1}{k_s^{2} + k_{\\lambda} + 1}  \\frac{k_s^{2} k_{\\lambda}}{k_s^{2} + k_{\\lambda}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "标准的“黑箱”深度学习模型在预测时可能违反基本的物理定律，这在环境科学应用中是不可接受的。为了确保模型的可信度与实用性，将物理约束融入模型设计至关重要。本练习将挑战你超越现成的架构，通过修改长短期记忆（LSTM）单元来强制执行物理约束（例如积雪的单调累积），从而实践物理知识指导的机器学习。这项动手编程任务将帮助你弥合纯数据驱动模型与过程模型之间的鸿沟。",
            "id": "3805512",
            "problem": "我们使用一个由卫星衍生的降水量和近地表气温组成的遥感时间序列，来模拟雪水当量的时间演变。令 $p_t$ 表示在离散时间步 $t$ 的降水量（单位为毫米水当量每时间步，缩写为 mm WE/时间步），令 $T_t$ 表示同一时间的气温（单位为摄氏度）。定义累积雪水当量 $c_t$（单位为毫米水当量，mm WE）为待预测的状态。在仅考虑积雪累积的条件下（无融化、升华或压实导致的损失），离散质量守恒定律意味着当 $p_t \\ge 0$ 时，$c_t$ 是非递减的。\n\n为累积部分构建一个一维长短期记忆（LSTM）单元，该单元在 $p_t \\ge 0$ 的条件下强制实现单调非递减的累积。其构建必须基于物理真实性，并且必须从质量守恒推导得出。您的设计必须满足以下约束条件：\n\n- 记忆状态 $c_t$ 必须从 $c_{t-1}$ 进行加法更新，且当 $p_t \\ge 0$ 时，增量为非负。\n- 增量必须单调依赖于 $p_t$，并由一个编码了温度敏感性的门控因子进行调制，其中，较高的 $T_t$ 会减少有效累积量。\n- 在仅考虑累积的条件下，遗忘机制不得减少先前累积的质量。\n\n从质量守恒和 LSTM 门控的标准定义出发，推导出门控和参数化的充分条件，以强制实现 $c_t$ 的单调性。然后将此约束单元实现为一个程序，对所提供的测试集模拟 $c_t$ 随时间的变化。为使输出可量化，对测试集使用以下特定参数化：\n- 输入门 $i_t = \\sigma(\\beta_0 + \\beta_T T_t)$，其中 $\\sigma(\\cdot)$ 是 logistic 函数，$\\beta_0 = 1.0$ 且 $\\beta_T = -0.5$。\n- 降水量被裁剪为非负值：$\\tilde{p}_t = \\max(p_t, 0)$。\n- 增量系数是恒定非负的：$\\phi = 1.0$。\n- 状态更新是加性的且仅考虑累积：$c_t = c_{t-1} + i_t \\, \\phi \\, \\tilde{p}_t$。\n- 初始化 $c_0 = 0$ (mm WE)。\n- 输出门可以设为1，且不改变 $c_t$。\n\n输入和输出的单位要求如下：\n- $p_t$ 的单位为 mm WE/时间步。\n- $T_t$ 的单位为摄氏度。\n- $c_t$ 和最终的 $c_T$ 的单位为 mm WE。\n\n您的程序必须：\n- 实现上述约束单元，并为每个测试用例计算序列 $\\{c_t\\}_{t=1}^T$。\n- 通过检查每个用例中是否对所有 $t$ 都有 $c_t \\ge c_{t-1}$ 来验证单调性。\n- 对每个测试用例，输出两个量：一个布尔值，指示单调性条件是否对整个序列成立；以及最终的 $c_T$ 值，四舍五入到三位小数（单位为 mm WE）。\n\n测试集（五个用例，涵盖正常路径、边界和边缘条件）：\n1. $p = [0, 5, 10, 0, 20]$ （mm WE/时间步），$T = [-5, -2, 1, 0, -3]$ （摄氏度）。\n2. $p = [0, 0, 0, 0]$ （mm WE/时间步），$T = [-1, 0, 3, 5]$ （摄氏度）。\n3. $p = [100, 100, 100, 100, 100]$ （mm WE/时间步），$T = [0, 0, 0, 0, 0]$ （摄氏度）。\n4. $p = [-2, -5, -1]$ （mm WE/时间步），$T = [-10, -8, -6]$ （摄氏度）。\n5. $p = [5, 5, 5, 5]$ （mm WE/时间步），$T = [10, 12, 8, 15]$ （摄氏度）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[\\text{monotonic}_1, c_T^{(1)}, \\text{monotonic}_2, c_T^{(2)}, \\text{monotonic}_3, c_T^{(3)}, \\text{monotonic}_4, c_T^{(4)}, \\text{monotonic}_5, c_T^{(5)}]$，其中每个 $\\text{monotonic}_k$ 是一个布尔值，每个 $c_T^{(k)}$ 是一个四舍五入到三位小数的浮点数（单位为 mm WE）。",
            "solution": "该问题要求构建并实现一个物理约束的长短期记忆（LSTM）单元，以模拟雪水当量（$c_t$）的累积过程。其核心物理原理是仅考虑累积条件下的质量守恒，该原理规定了累积雪量 $c_t$ 必须是时间的单调非递减函数，即对所有时间步 $t$ 都有 $c_t \\ge c_{t-1}$。这一约束必须通过单元的设计在结构上强制实现。\n\n我们首先考察一维 LSTM 单元的标准公式。单元状态 $c_t$ 根据以下方程更新：\n$$c_t = f_t \\cdot c_{t-1} + i_t \\cdot \\tilde{c}_t$$\n其中 $f_t$ 是遗忘门，$i_t$ 是输入门，而 $\\tilde{c}_t$ 是候选状态（新信息）。为了确保物理真实性并满足问题约束，我们必须基于给定原理推导这些组件的具体形式。\n\n**1. 质量守恒与遗忘门 ($f_t$):**\n问题陈述指定了一个“仅累积”模型，意味着没有质量通过融化或升华等过程损失。在此背景下，质量守恒原理意味着先前时间步累积的雪必须被完全保留。在 LSTM 状态更新方程中，项 $f_t \\cdot c_{t-1}$ 代表被“记住”的先前状态部分。为确保没有质量被遗忘，遗忘门 $f_t$ 在所有时间步必须恒等于 $1$。\n$$f_t \\equiv 1$$\n这满足了“遗忘机制不得减少先前累积的质量”这一约束。当 $f_t=1$ 时，状态更新方程按要求简化为纯加法形式：\n$$c_t = c_{t-1} + i_t \\cdot \\tilde{c}_t$$\n\n**2. 单调累积与状态增量:**\n核心要求是累积必须是单调非递减的，即 $c_t \\ge c_{t-1}$。从加法更新方程可知，这意味着增量项 $i_t \\cdot \\tilde{c}_t$ 必须为非负。\n$$c_t - c_{t-1} = i_t \\cdot \\tilde{c}_t \\ge 0$$\n\n**3. 基于物理输入 ($p_t, T_t$) 建模增量:**\n增量代表新的积雪，它是降水量（$p_t$）和气温（$T_t$）的函数。\n- 候选状态 $\\tilde{c}_t$ 代表来自降水的潜在新质量。将其建模为与输入降水量成正比是符合物理现实的。由于只有正降水量才能增加积雪（在此背景下，负降水量没有物理意义），我们使用裁剪后的降水量 $\\tilde{p}_t = \\max(p_t, 0)$。问题指定使用一个恒定的非负系数 $\\phi$。因此，我们将候选状态定义为：\n  $$\\tilde{c}_t = \\phi \\cdot \\tilde{p}_t$$\n  根据定义，由于 $\\phi \\ge 0$ 且 $\\tilde{p}_t \\ge 0$，候选状态 $\\tilde{c}_t$ 始终为非负。\n\n- 输入门 $i_t$ 调制有多少候选降水实际变成雪。这种调制依赖于温度。问题指出，较高的温度应减少有效累积量，这反映了在较暖的温度下，降水更可能是雨而不是雪的物理现实。输入门的指定形式为：\n  $$i_t = \\sigma(\\beta_0 + \\beta_T T_t)$$\n  其中 $\\sigma(x) = (1 + e^{-x})^{-1}$ 是 logistic sigmoid 函数。sigmoid 函数的值域是 $(0, 1)$，因此 $i_t$ 总是严格为正。为确保 $T_t$ 的增加导致 $i_t$ 的减少（从而减少累积量），sigmoid 函数的参数必须是 $T_t$ 的递减函数。这要求系数 $\\beta_T$ 为负。问题提供了 $\\beta_T = -0.5$，这满足了此物理约束。\n\n**4. 最终约束单元公式与单调性验证:**\n将推导出的组件代回状态更新方程，我们得到最终模型：\n$$c_t = c_{t-1} + i_t \\cdot (\\phi \\cdot \\tilde{p}_t)$$\n这个公式与问题陈述中提供的一致。我们现在可以正式验证它能保证单调行为。状态的变化是：\n$$\\Delta c_t = c_t - c_{t-1} = i_t \\cdot \\phi \\cdot \\tilde{p}_t$$\n我们来分析右侧各项的符号：\n- $i_t = \\sigma(\\beta_0 + \\beta_T T_t)$：sigmoid 函数总是返回一个在 $(0, 1)$ 范围内的值，所以 $i_t  0$。\n- $\\phi = 1.0$：这是一个正常数。\n- $\\tilde{p}_t = \\max(p_t, 0)$：根据定义，$\\tilde{p}_t \\ge 0$。\n\n一个严格为正的项（$i_t$）、一个正项（$\\phi$）和一个非负项（$\\tilde{p}_t$）的乘积保证为非负。\n$$\\Delta c_t = \\underbrace{i_t}_{0} \\cdot \\underbrace{\\phi}_{0} \\cdot \\underbrace{\\tilde{p}_t}_{\\ge 0} \\ge 0$$\n因此，在所有时间步，$c_t \\ge c_{t-1}$ 在结构上得到保证。实现该模型的程序应始终发现单调性检查为真。初始条件为 $c_0 = 0$。对每个测试用例，序列 $\\{c_t\\}$ 都通过迭代计算得出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the snow accumulation problem by implementing and simulating a\n    physically constrained LSTM-like cell for a suite of test cases.\n    \"\"\"\n\n    # Test suite provided in the problem statement.\n    test_cases = [\n        {'p': [0, 5, 10, 0, 20], 'T': [-5, -2, 1, 0, -3]},\n        {'p': [0, 0, 0, 0], 'T': [-1, 0, 3, 5]},\n        {'p': [100, 100, 100, 100, 100], 'T': [0, 0, 0, 0, 0]},\n        {'p': [-2, -5, -1], 'T': [-10, -8, -6]},\n        {'p': [5, 5, 5, 5], 'T': [10, 12, 8, 15]},\n    ]\n    \n    # Parameters for the constrained cell, as specified in the problem.\n    beta0 = 1.0\n    betaT = -0.5\n    phi = 1.0\n    c0 = 0.0\n\n    def sigmoid(x):\n        \"\"\"Computes the logistic sigmoid function.\"\"\"\n        return 1.0 / (1.0 + np.exp(-x))\n\n    def simulate_accumulation(p_series, T_series):\n        \"\"\"\n        Simulates the snow water equivalent accumulation over time.\n\n        Args:\n            p_series (list[float]): Time series of precipitation.\n            T_series (list[float]): Time series of temperature.\n\n        Returns:\n            tuple: A boolean indicating if monotonicity holds, and the\n                   final accumulated snow water equivalent rounded to 3 places.\n        \"\"\"\n        c_history = [c0]\n        c_current = c0\n        \n        for p_t, T_t in zip(p_series, T_series):\n            # 1. Clip precipitation to be non-negative.\n            p_tilde_t = max(p_t, 0.0)\n            \n            # 2. Calculate the temperature-dependent input gate.\n            i_t = sigmoid(beta0 + betaT * T_t)\n            \n            # 3. Calculate the additive increment.\n            increment = i_t * phi * p_tilde_t\n            \n            # 4. Update the state.\n            c_current = c_current + increment\n            c_history.append(c_current)\n            \n        # Verify monotonicity of the entire sequence [c0, c1, ..., cT].\n        # A small tolerance is used for robust floating point comparison.\n        c_history_np = np.array(c_history)\n        is_monotonic = np.all(np.diff(c_history_np) >= -1e-9)\n        \n        # Get the final value and round it.\n        c_final = c_history[-1]\n        c_final_rounded = round(c_final, 3)\n        \n        return is_monotonic, c_final_rounded\n\n    # Process all test cases and collect results.\n    results = []\n    for case in test_cases:\n        p = case['p']\n        T = case['T']\n        monotonicity_result, final_c = simulate_accumulation(p, T)\n        results.append(monotonicity_result)\n        results.append(final_c)\n\n    # Format and print the final output string as required.\n    # str(True) -> 'True', str(False) -> 'False'\n    # str(29.111) -> '29.111', str(0.0) -> '0.0'\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "地理空间建模中的一个常见陷阱是空间自相关，它会导致标准的交叉验证方法产生过于乐观和具有误导性的性能评估。一个模型的好坏最终取决于其在真实世界中的泛化能力，而可靠的评估是衡量这一能力的基础。本练习将引导你分析并量化空间留出法交叉验证的必要性，从而掌握如何设计一个能够充分考虑数据空间依赖性的评估方案，为你的模型提供一个值得信赖的泛化误差估计。",
            "id": "3805490",
            "problem": "一个土地覆盖分类模型在一个大型农业区域上，使用多光谱卫星影像和月度时间序列进行训练，以在像素尺度上预测离散的土地覆盖类别。输入是从 Sentinel-2 数据中提取的二维空间图块和十二个月的时间序列。模型架构是一个混合卷积神经网络（CNN, Convolutional Neural Network）和循环神经网络（RNN, Recurrent Neural Network）：三个卷积层，其卷积核大小分别为 $5$、$3$ 和 $3$，步长为 $1$，其输出被送入一个在 $12$ 个时间步上运行的门控循环单元。像素在 $x$ 和 $y$ 方向上的分辨率均为 $10\\ \\mathrm{m}$。研究区域在光谱特征和标签上都表现出各向同性、平稳的空间自相关，其相关函数为 $\\rho(d) = \\exp\\!\\left(-d/\\lambda\\right)$，其中 $d$ 是以米为单位的欧氏距离，$\\lambda = 150\\ \\mathrm{m}$ 是根据经验半变异函数估计的相关长度。用于分类中泛化误差的交叉验证风险估计器是通过在留出折（held-out folds）上的平均损失来定义的。\n\n请从第一性原理出发，解释为什么当存在正空间自相关且模型具有非零空间感受野时，在像素级别进行随机 $K$-折交叉验证会导致对泛化误差的估计出现乐观偏差。然后，推导一种二维空间分块交叉验证方案，通过确保训练集和测试集在边界处近似独立，来减少这种乐观偏差。推导必须从独立性、空间自相关和 CNN 有效感受野的定义开始。具体来说：\n\n- 推导 CNN 在给定架构和像素分辨率下的有效空间感受野半径 $r$（以米为单位），将感受野解释为输入像素可以影响中心像素预测的最大半径。\n- 使用自相关函数 $\\rho(d)$ 和独立性阈值 $\\epsilon = 0.05$，推导出一个充分的缓冲区宽度 $h$（以米为单位），以确保任何可能影响测试预测的训练像素与测试像素本身之间的最大互相关受限于 $\\rho(h - r) \\le \\epsilon$。\n- 说明应如何构建块并将其分配到各个折中，以便在给定的自相关模型下产生近似无偏的交叉验证风险估计。提供块大小相对于 $\\lambda$ 和 $r$ 的任何必要条件，并解释如何在折中处理时间序列。\n\n计算 $r$ 和满足该边界条件的最小 $h$ 的数值。然后选择与您的推导一致的、正确指定了空间分块方案的选项。\n\n选项：\nA. 执行随机像素级 $K$-折交叉验证，并采用类别分层抽样以确保每折的类别平衡；不使用空间块或缓冲区。这维持了独立同分布的样本，并产生无偏的风险估计。\n\nB. 将地图划分为边长等于相关长度 $\\lambda$ 的非重叠方形测试瓦片；对于每一折，在测试瓦片外的所有像素上进行训练，不设置缓冲区。在瓦片内保持所有时间序列的完整性。\n\nC. 使用二维空间 $h$-分块交叉验证：定义边长至少为 $3\\lambda$ 的方形测试块，将块分配给 $K$ 个折，对于每一折，仅在距离任何测试块至少 $h$ 米的像素上进行训练，其中 $h \\ge r + \\lambda \\ln(1/\\epsilon)$ 是根据感受野半径 $r$ 和相关函数 $\\rho(d)$ 计算得出的；在训练块和测试块中都保持完整的 $12$ 个月序列的完整性。这在各向同性自相关模型下产生近似无偏的风险估计。\n\nD. 通过在整个区域内留出交替的月份并在剩余月份上训练，来执行时间分块交叉验证。空间位置在训练月份和测试月份之间共享；不应用空间缓冲。\n\nE. 使用空间分块交叉验证，块的边长至少为 $3\\lambda$，缓冲区宽度仅等于感受野半径 $r$；将块分配到折中并保持时间序列的完整性。这确保了训练和测试像素永远不会在一个感受野之内，并且足以消除乐观偏差。",
            "solution": "用户提供的问题陈述是有效的。它在科学上基于地理统计学和机器学习的原理，问题提出得很好，有明确的目标和充分的信息，并使用了客观、精确的语言。所描述的场景是将深度学习应用于地理空间数据的典型问题。我现在将进行解答。\n\n该问题要求解释为什么在存在空间自相关的情况下，标准的、随机的像素级交叉验证会导致有偏的误差估计，并要求推导一种能够减轻这种偏差的空间分块交叉验证方案。\n\n### 1. 随机像素级交叉验证的乐观偏差\n\n$K$-折交叉验证的基本假设是，每一折的训练集和测试集都是从底层数据分布中独立抽取的样本。当这个假设成立时，所有折的平均误差为模型泛化误差提供了一个无偏估计。\n\n问题指出，数据中存在正空间自相关，由函数 $\\rho(d) = \\exp(-d/\\lambda)$ 描述，其中 $d$ 是距离。这意味着彼此靠近的像素不是独立的；它们的特征值和类别标签是相关的。两个像素越近，它们的相关性就越高。\n\n在像素级别执行随机 $K$-折交叉验证时，每个像素被分配到一个折中，而与其空间位置无关。因此，对于一个折的测试集中的任何给定像素，几乎可以肯定在其紧邻区域内会有来自训练集的像素。\n\n模型的卷积神经网络（CNN）部分基于输入像素的一个空间邻域（由其感受野定义）进行预测。由于空间自相关，靠近测试像素的训练像素所携带的信息与测试像素及其邻域中的信息高度冗余。因此，模型是在与测试数据并非真正独立的数据上进行训练的。这种现象通常被称为“信息泄露”。\n\n结果，模型在留出的测试数据上的表现将被被人为地夸大，因为它不是在真正未见过、独立的样本上进行评估。由此产生的泛化误差估计会系统性地低于在地理上分离的独立数据集上观察到的真实误差。这种向下的偏差被称为“乐观偏差”。\n\n### 2. 空间分块交叉验证方案的推导\n\n为了获得更准确的泛化误差估计，必须使训练集和测试集近似独立。这可以通过在它们之间强制施加一个最小的空间间隔来实现。\n\n#### 2.1. 有效感受野半径 ($r$)\n\nCNN 的感受野是影响单个输出单元的输入区域的大小。中心像素的预测受到一定半径内的输入像素的影响。我们必须首先计算这个感受野的大小（以像素为单位），然后将其转换为米。\n\n该网络有三个连续的卷积层，步长均为 $s=1$。第 $i$ 层之后的感受野大小 ($RF$) 由递归公式给出：\n$$RF_i = RF_{i-1} + (k_i - 1) \\prod_{j=1}^{i-1} s_j$$\n鉴于所有步长都是 $s_j = 1$，公式简化为 $RF_i = RF_{i-1} + (k_i - 1)$。输入层的感受野为 $RF_0 = 1$。\n\n- 经过第1层后（卷积核大小 $k_1 = 5$）：\n  $$RF_1 = RF_0 + (k_1 - 1) = 1 + (5 - 1) = 5$$\n- 经过第2层后（卷积核大小 $k_2 = 3$）：\n  $$RF_2 = RF_1 + (k_2 - 1) = 5 + (3 - 1) = 7$$\n- 经过第3层后（卷积核大小 $k_3 = 3$）：\n  $$RF_3 = RF_2 + (k_3 - 1) = 7 + (3 - 1) = 9$$\n\n最终的感受野是一个 $9 \\times 9$ 的像素块。问题将半径 $r$ 定义为从中心像素到有影响的输入像素的最大半径。对于一个 $9 \\times 9$ 的感受野，该区域从中心沿主轴线延伸 $(9-1)/2 = 4$ 个像素。\n像素分辨率为 $10\\ \\mathrm{m}$。因此，感受野半径 $r$（以米为单位）是：\n$$r = 4\\ \\text{pixels} \\times 10\\ \\mathrm{m/pixel} = 40\\ \\mathrm{m}$$\n\n#### 2.2. 充分的缓冲区宽度 ($h$)\n\n空间分块交叉验证方案在任何训练像素和任何测试像素之间引入一个宽度为 $h$ 的缓冲区。设 $p_{test}$ 是测试块中的一个像素，而 $p_{train}$ 是训练集中的一个像素。它们之间的最小距离是 $h$。\n\n在 $p_{test}$ 处的预测受到其感受野内的输入像素的影响，即距离 $p_{test}$ 最多为 $r$ 的像素。设 $p_{input}$ 是这样一个输入像素。我们希望限制训练数据和用于进行测试预测的数据之间的相关性。最大化相关性的“最坏情况”发生在训练像素和用于测试预测的输入像素之间的距离最小时。\n\n根据三角不等式，影响 $p_{test}$ 处预测的任何输入像素 $p_{input}$ 与任何训练像素 $p_{train}$ 之间的距离为：\n$$\\text{dist}(p_{input}, p_{train}) \\ge \\text{dist}(p_{test}, p_{train}) - \\text{dist}(p_{test}, p_{input})$$\n最小距离发生在 $p_{test}$ 位于测试块的边缘，而 $p_{input}$ 和 $p_{train}$ 位于从 $p_{test}$ 延伸出的一条线上，其中 $p_{input}$ 在感受野内，$p_{train}$ 在缓冲区外。\n最小距离为 $\\text{dist}(p_{test}, p_{train}) \\ge h$。最大距离为 $\\text{dist}(p_{test}, p_{input}) \\le r$。\n因此，用于测试预测的任何输入像素与任何训练像素之间的最小距离是 $h - r$。\n\n问题要求最大互相关受限于 $\\epsilon = 0.05$。自相关函数是单调递减的，因此如果在最小可能距离上的相关性小于或等于 $\\epsilon$，则该条件得到满足：\n$$\\rho(h - r) \\le \\epsilon$$\n代入给定的自相关函数 $\\rho(d) = \\exp(-d/\\lambda)$:\n$$\\exp\\left(-\\frac{h - r}{\\lambda}\\right) \\le \\epsilon$$\n为了解出 $h$，我们对两边取自然对数：\n$$-\\frac{h - r}{\\lambda} \\le \\ln(\\epsilon)$$\n乘以 $-\\lambda$（一个正常数）会反转不等号：\n$$h - r \\ge -\\lambda \\ln(\\epsilon)$$\n$$h - r \\ge \\lambda \\ln\\left(\\frac{1}{\\epsilon}\\right)$$\n$$h \\ge r + \\lambda \\ln\\left(\\frac{1}{\\epsilon}\\right)$$\n这是推导出的充分缓冲区宽度 $h$ 的条件。\n\n#### 2.3. $r$ 和 $h$ 的数值计算\n\n从上一节可知，感受野半径为：\n$$r = 40\\ \\mathrm{m}$$\n\n现在，我们计算满足不等式的最小 $h$。给定：\n- $r = 40\\ \\mathrm{m}$\n- $\\lambda = 150\\ \\mathrm{m}$\n- $\\epsilon = 0.05$\n\n$$h \\ge 40\\ \\mathrm{m} + (150\\ \\mathrm{m}) \\ln\\left(\\frac{1}{0.05}\\right)$$\n$$h \\ge 40 + 150 \\ln(20)$$\n使用 $\\ln(20) \\approx 2.9957$:\n$$h \\ge 40 + 150 \\times 2.9957$$\n$$h \\ge 40 + 449.355$$\n$$h \\ge 489.355\\ \\mathrm{m}$$\n一个最小的充分缓冲区宽度约为 $h = 490\\ \\mathrm{m}$。\n\n#### 2.4. 块的构建与分配\n\n推导出的方案是一种空间 $h$-分块交叉验证。其过程如下：\n1.  **分区**：将研究区域划分为不重叠的空间块。为了最小化在缓冲区中被丢弃的数据比例，这些块应相对于相关长度 $\\lambda$ 和缓冲区 $h$ 较大。边长至少为 $3\\lambda$ 是一个合理的启发式规则。\n2.  **折分配**：将块分配给 $K$ 个折。对于给定的折 $k$，测试集由分配给折 $k$ 的块内的所有像素组成。\n3.  **训练集定义**：折 $k$ 的训练集由未分配给折 $k$ 的块中、*且*与折 $k$ 中任何测试块的距离至少为 $h$ 的所有像素组成。缓冲区内的像素在该折中既不用于训练也不用于测试。\n4.  **时间数据处理**：模型使用一个 $12$ 个月的时间序列。空间分区不能破坏这些时间序列。因此，对于任何给定的像素，其整个 $12$ 个月的序列作为一个单元被分配到训练集、测试集或缓冲区。\n\n### 3. 选项评估\n\n**A. 执行随机像素级 $K$-折交叉验证，并采用类别分层抽样...**\n此方法明确忽略了空间自相关，而这正是核心问题。它错误地声称维持了独立同分布样本并产生无偏估计。如第1节所述，这会导致乐观偏差。\n**结论：不正确。**\n\n**B. 将地图划分为边长等于相关长度 $\\lambda$ 的非重叠方形测试瓦片；对于每一折，在测试瓦片外的所有像素上进行训练，不设置缓冲区...**\n此方法使用了空间分块，但关键地省略了缓冲区。没有缓冲区，训练像素可能与测试像素相邻，由于模型的感受野和近距离上高度的空间相关性，这会导致严重的信息泄露，违反了独立性假设。\n**结论：不正确。**\n\n**C. 使用二维空间 $h$-分块交叉验证：定义边长至少为 $3\\lambda$ 的方形测试块，将块分配给 $K$ 个折，对于每一折，仅在距离任何测试块至少 $h$ 米的像素上进行训练，其中 $h \\ge r + \\lambda \\ln(1/\\epsilon)$ 是根据感受野半径 $r$ 和相关函数 $\\rho(d)$ 计算得出的；在训练块和测试块中都保持完整的 $12$ 个月序列的完整性...**\n此选项正确地描述了整个推导过程。它指定使用 $h$-分块交叉验证，为块大小提供了合理的条件（至少 $3\\lambda$），使用缓冲区 $h$ 正确定义了训练集，提供了从第一性原理推导出的 $h$ 的精确公式（$h \\ge r + \\lambda \\ln(1/\\epsilon)$），并正确处理了时间序列。此过程将产生近似无偏的风险估计。\n**结论：正确。**\n\n**D. 通过在整个区域内留出交替的月份...来执行时间分块交叉验证...**\n此方法解决了时间自相关问题，但这并非问题所述的核心。问题是空间自相关。这种方法没有进行任何空间分离，并且会遭受大量的信息泄露，使得误差估计高度有偏。\n**结论：不正确。**\n\n**E. 使用空间分块交叉验证，块的边长至少为 $3\\lambda$，缓冲区宽度仅等于感受野半径 $r$...**\n此方法使用了缓冲区，但缓冲区宽度被设置为 $h=r$。这是不够的。宽度为 $r$ 的缓冲区仅能防止测试预测的感受野包含训练像素。它没有考虑在更长距离上仍然存在的空间相关性。当 $h=r=40\\ \\mathrm{m}$ 和 $\\lambda=150\\ \\mathrm{m}$ 时，缓冲区边缘的训练像素与块边缘的测试像素之间的相关性将是 $\\rho(40) = \\exp(-40/150) \\approx 0.766$，这是非常高的。声称这足以消除偏差是错误的。\n**结论：不正确。**",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}