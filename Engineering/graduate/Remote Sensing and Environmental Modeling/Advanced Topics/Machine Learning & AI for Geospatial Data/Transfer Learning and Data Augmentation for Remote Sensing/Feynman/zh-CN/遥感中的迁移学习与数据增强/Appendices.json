{
    "hands_on_practices": [
        {
            "introduction": "数据增强对于训练稳健的深度学习模型至关重要，但通用的增强方法可能不适用于遥感影像等具有物理意义的数据。本练习专注于创建一种*基于物理原理*的辐射增强方法，它模拟了传感器定标和信号噪声中的自然变化。通过完成此实践 ，您将学习如何推导并实现尊重遥感数据底层物理原理的增强方法，确保您的模型从真实而非人为的变化中学习。",
            "id": "3862712",
            "problem": "你的任务是为遥感中的多光谱地表反射率设计一种基于物理的辐射增强方法。该增强方法通过一个乘法因子扰动每个波段的反射率，以模拟合理的辐射定标变异性。你的推导和实现必须从辐射度学中的基本测量和不确定性原理开始，并且不得依赖于简化的公式。\n\n从以下基本事实和定义开始：\n\n- 令 $D_b$ 表示波段 $b$ 的数字计数值（digital number），$L_b$ 表示波段 $b$ 的传感器处辐亮度。一个标准的线性定标模型将它们关联为 $L_b = g_b \\,(D_b - d_b) + o_b$，其中 $g_b$ 是增益，$d_b$ 是暗电平，$o_b$ 是偏置。假设经过预处理后偏置可忽略不计，因此 $L_b \\approx g_b\\,(D_b - d_b)$。\n- 波段 $b$ 的无量纲地表反射率，记为 $\\rho_b$，通过一个经过充分检验的辐射关系与传感器处辐亮度相关联，形式为 $\\rho_b = \\kappa_b \\, L_b$，其中 $\\kappa_b$ 聚合了大气校正后的确定性项，如大气外辐照度、太阳天顶角、大气透射率和几何因子，因此 $L_b$ 中的乘性定标误差会乘性地传播到 $\\rho_b$。\n- 设增益不确定性表示为相对标准不确定度 $u_b$（一个标准差），并设波段 $b$ 的信噪比（SNR）为 $s_b$（定义为平均信号除以噪声的标准差，即 $s_b = \\mu_b/\\sigma_b$）。\n- 对于高斯近似下的 $95\\%$ 类置信区间，使用两倍标准差的界限。在独立相对不确定度的保守相加（三角不等式）下，总相对扰动界限为\n$$\n\\alpha_b = \\min\\!\\left(2\\,u_b + \\frac{2}{s_b}, \\, \\alpha_{\\mathrm{cap}}\\right),\n$$\n其中 $\\alpha_{\\mathrm{cap}}$ 是为避免不切实际的扰动而选择的硬性上限。\n- 地表反射率在物理上是无量纲的，且位于闭区间 $[0,1]$ 内。对于一个已知的每个波段的最大预期反射率 $r^{\\max}_b \\in (0,1]$（源自地表属性和光照条件），对乘性增强因子 $f_b$ 的界定必须确保对于所有 $\\rho_b \\in [0, r_b^{\\max}]$，都有 $\\rho_b' = f_b \\,\\rho_b \\in [0,1]$。这意味着\n$$\nf_b \\in \\left[\\max\\!\\left(1 - \\alpha_b,\\, 0\\right),\\; \\min\\!\\left(1 + \\alpha_b,\\, \\frac{1}{r_b^{\\max}}\\right)\\right]。\n$$\n- 增强过程应在上述区间内为每个波段 $b$ 均匀采样 $f_b$，然后形成增强后的反射率 $\\rho_b' = \\mathrm{clip}(f_b \\rho_b,\\, 0,\\, 1)$，以保守地强制施加物理边界。\n\n你的程序必须实现上述逻辑。对所有测试用例使用以下固定常量：\n- 校准和噪声贡献的置信度缩放因子均为 $2$。\n- 增强上限 $\\alpha_{\\mathrm{cap}} = 0.25$。\n- 随机数生成器种子设置为 $2025$，以保证采样的确定性。\n- 每个 $f_b$ 的采样分布是在上述定义的每个波段的区间上的均匀分布。\n\n输入隐含在提供的测试套件中，不应读取外部输入。反射率值是无量纲的，必须如此处理。所有相对不确定度和 $s_b$ 值都是无量纲的。\n\n测试套件。对于每个案例 $i$，给你 $u_b$、$s_b$、$r_b^{\\max}$ 的数组和一个相同长度的观测反射率向量 $\\rho_b$。通过使用固定种子采样因子，计算每个波段的边界和一次增强反射率的实现：\n- 案例 1（理想路径，中等不确定度和高信噪比）：\n  - $u_b = [0.02,\\, 0.02,\\, 0.03,\\, 0.03]$，\n  - $s_b = [200,\\, 220,\\, 180,\\, 150]$，\n  - $r_b^{\\max} = [0.6,\\, 0.7,\\, 0.8,\\, 0.5]$，\n  - $\\rho_b = [0.1,\\, 0.2,\\, 0.3,\\, 0.4]$。\n- 案例 2（上界受接近于1的高最大反射率约束）：\n  - $u_b = [0.03,\\, 0.03]$，\n  - $s_b = [250,\\, 250]$，\n  - $r_b^{\\max} = [0.95,\\, 0.95]$，\n  - $\\rho_b = [0.9,\\, 0.95]$。\n- 案例 3（低信噪比波段，具有较大不确定性，但低于上限）：\n  - $u_b = [0.05,\\, 0.04,\\, 0.05]$，\n  - $s_b = [30,\\, 40,\\, 20]$，\n  - $r_b^{\\max} = [0.7,\\, 0.6,\\, 0.4]$，\n  - $\\rho_b = [0.5,\\, 0.3,\\, 0.2]$。\n- 案例 4（“上限激活”的极端情况，加盖上限前的总不确定性非常大）：\n  - $u_b = [0.2]$，\n  - $s_b = [10]$，\n  - $r_b^{\\max} = [0.8]$，\n  - $\\rho_b = [0.5]$。\n\n输出要求：\n- 对于每个案例，计算每个波段的边界 $[L_b, U_b]$，其中 $L_b = \\max(1 - \\alpha_b, 0)$ 且 $U_b = \\min(1 + \\alpha_b, 1/r_b^{\\max})$。\n- 使用固定种子，为每个波段从 $\\mathrm{Uniform}(L_b, U_b)$ 中采样一个 $f_b$，并计算 $\\rho_b' = \\mathrm{clip}(f_b \\rho_b, 0, 1)$。\n- 将所有浮点输出四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个长度为 $4$ 的列表（每个案例一个）。每个元素是包含两个元素的列表：\n  1.  一个包含该案例中每个波段的双元素列表 $[L_b, U_b]$ 的列表。\n  2.  一个包含该案例中增强反射率 $\\rho_b'$ 的列表。\n- 该行必须打印为类似JSON的列表，不含空格，例如：\n  - 每个案例为 $[ [[L_1,U_1],\\ldots], [\\rho'_1,\\ldots] ]$，并聚合成一个包含 4 个案例的顶层列表。",
            "solution": "该问题是有效的。它在科学上基于辐射度学和误差传播原理，问题陈述清晰，提供了所有必要信息，并且表述客观。我们现在将进行完整解答。\n\n目标是为多光谱地表反射率 $\\rho_b$（其中 $b$ 为光谱波段的索引）制定并实现一种基于物理的辐射增强方法。该增强方法通过对每个波段的反射率应用一个随机乘法因子 $f_b$ 来模拟由传感器定标不确定性和噪声引起的变异性。推导从第一性原理开始。\n\n首先，我们确定界定增强范围的总相对不确定度。问题提供了两个主要的不确定性来源：\n1. 传感器增益 $g_b$ 具有相对标准不确定度 $u_b$。\n2. 信号本身受到噪声影响，由信噪比 $s_b$ 表征。由噪声引起的相对不确定度可取为信噪比的倒数 $1/s_b$。\n\n问题指定使用一个 $95\\%$ 的类置信区间，通过两倍标准差（$2\\sigma$）界限来近似。来自增益和噪声的不确定性被视为独立的，其影响线性相加，这代表一种保守（最坏情况）的求和方式。因此，每个波段 $b$ 的组合相对扰动界限 $\\alpha_b$ 是通过将两个来源的 $2\\sigma$ 贡献相加来构建的。这个总扰动随后被限制在一个最大值 $\\alpha_{\\mathrm{cap}}$ 以防止不符合物理实际的增强。这被形式化为：\n$$\n\\alpha_b = \\min\\!\\left(2\\,u_b + \\frac{2}{s_b}, \\, \\alpha_{\\mathrm{cap}}\\right)\n$$\n给定的 $\\alpha_{\\mathrm{cap}}$ 值为 $0.25$，置信度缩放因子为 $2$。\n\n接下来，我们推导乘性增强因子 $f_b$ 的有效区间。因子 $f_b$ 旨在扰动反射率，因此它将从一个以 $1$ 为中心、宽度与 $\\alpha_b$ 相关的区间中采样。增强后的反射率为 $\\rho_b' = f_b \\rho_b$。一个关键的物理约束是，任何有效的地表反射率，无论是原始的还是增强后的，都必须位于闭区间 $[0, 1]$ 内。这一约束不仅对给定的 $\\rho_b$ 成立，而且对任何物理上可能的、高达每个波段最大预期值 $r^{\\max}_b \\in (0,1]$ 的反射率都必须成立。\n\n这导致对 $f_b$ 的两个约束：\n1.  **下界**：由于 $\\rho_b \\ge 0$，为确保 $\\rho_b' = f_b \\rho_b \\ge 0$，我们必须有 $f_b \\ge 0$。从不确定性模型导出的下界是 $1 - \\alpha_b$。结合这两者， $f_b$ 的下界，记为 $L_b$，是 $L_b = \\max(1 - \\alpha_b, 0)$。\n2.  **上界**：为确保对于所有可能的反射率 $\\rho_b \\in [0, r_b^{\\max}]$ 都有 $\\rho_b' = f_b \\rho_b \\le 1$，最严格的条件施加在最大反射率 $\\rho_b = r_b^{\\max}$ 处。这得出 $f_b r_b^{\\max} \\le 1$，即 $f_b \\le 1/r_b^{\\max}$。从不确定性模型导出的上界是 $1 + \\alpha_b$。为了同时满足这两个条件，我们取两者的最小值。因此， $f_b$ 的上界，记为 $U_b$，是 $U_b = \\min(1 + \\alpha_b, 1/r_b^{\\max})$。\n\n综合这些，每个波段的乘法因子 $f_b$ 的采样区间为：\n$$\nf_b \\in [L_b, U_b] = \\left[\\max\\!\\left(1 - \\alpha_b, 0\\right), \\min\\!\\left(1 + \\alpha_b, \\frac{1}{r_b^{\\max}}\\right)\\right]\n$$\n\n增强过程如下：\n1. 对于给定多光谱观测中的每个波段 $b$，计算总相对扰动界限 $\\alpha_b$。\n2. 使用 $\\alpha_b$ 和每个波段的最大反射率 $r_b^{\\max}$，确定采样区间 $[L_b, U_b]$。\n3. 对于每个波段 $b$，从其对应的区间 $[L_b, U_b]$ 上的均匀分布中抽取一个随机样本 $f_b$。为确保可复现性，使用固定的种子（$2025$）来初始化随机数生成器。\n4. 计算增强后的反射率 $\\rho_b' = f_b \\rho_b$。\n5. 作为最后的保障措施，将结果裁剪到物理范围 $[0, 1]$ 内：$\\rho_b' = \\mathrm{clip}(f_b \\rho_b, 0, 1)$。\n\n程序将为提供的四个测试用例实现此逻辑。对于每个用例，它将计算每个波段的边界 $[L_b, U_b]$ 和增强反射率向量 $\\rho_b'$ 的一次实现。所有数值结果将四舍五入到 $6$ 位小数，并按规定格式化为单行类JSON字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a physically grounded radiometric augmentation for multispectral surface reflectance.\n    \"\"\"\n    # Define fixed constants\n    confidence_factor = 2.0\n    alpha_cap = 0.25\n    seed = 2025\n\n    # Initialize a random number generator with a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Test suite as defined in the problem statement\n    test_cases = [\n        {\n            \"u_b\": [0.02, 0.02, 0.03, 0.03],\n            \"s_b\": [200, 220, 180, 150],\n            \"r_max_b\": [0.6, 0.7, 0.8, 0.5],\n            \"rho_b\": [0.1, 0.2, 0.3, 0.4],\n        },\n        {\n            \"u_b\": [0.03, 0.03],\n            \"s_b\": [250, 250],\n            \"r_max_b\": [0.95, 0.95],\n            \"rho_b\": [0.9, 0.95],\n        },\n        {\n            \"u_b\": [0.05, 0.04, 0.05],\n            \"s_b\": [30, 40, 20],\n            \"r_max_b\": [0.7, 0.6, 0.4],\n            \"rho_b\": [0.5, 0.3, 0.2],\n        },\n        {\n            \"u_b\": [0.2],\n            \"s_b\": [10],\n            \"r_max_b\": [0.8],\n            \"rho_b\": [0.5],\n        },\n    ]\n\n    all_results = []\n\n    for case_data in test_cases:\n        # Extract data and convert to NumPy arrays for vectorized operations\n        u_b = np.array(case_data[\"u_b\"], dtype=float)\n        s_b = np.array(case_data[\"s_b\"], dtype=float)\n        r_max_b = np.array(case_data[\"r_max_b\"], dtype=float)\n        rho_b = np.array(case_data[\"rho_b\"], dtype=float)\n\n        # Step 1: Calculate the total relative perturbation bound, alpha_b\n        alpha_b = np.minimum(confidence_factor * u_b + confidence_factor / s_b, alpha_cap)\n\n        # Step 2: Calculate the bounds [L_b, U_b] for the multiplicative factor f_b\n        L_b = np.maximum(1.0 - alpha_b, 0.0)\n        U_b = np.minimum(1.0 + alpha_b, 1.0 / r_max_b)\n\n        # Step 3: Sample f_b from a uniform distribution over [L_b, U_b]\n        f_b = rng.uniform(L_b, U_b, size=u_b.shape)\n\n        # Step 4: Compute the augmented reflectance and clip to the physical range [0, 1]\n        rho_prime_b = np.clip(f_b * rho_b, 0.0, 1.0)\n        \n        # Step 5: Round results to 6 decimal places as required\n        L_b_rounded = np.round(L_b, 6)\n        U_b_rounded = np.round(U_b, 6)\n        rho_prime_b_rounded = np.round(rho_prime_b, 6)\n\n        # Structure the results for the current case\n        bounds_list = [[l, u] for l, u in zip(L_b_rounded, U_b_rounded)]\n        rhos_list = rho_prime_b_rounded.tolist()\n        \n        case_result = [bounds_list, rhos_list]\n        all_results.append(case_result)\n\n    # Print the final output in the specified compact JSON-like format\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在学习了如何创建数据增强之后，理解其有效性的原因也同样重要。测试时增强（Test-Time Augmentation, TTA）是一种在推理阶段提升模型性能的强大技术。本实践将深入探讨 TTA 背后的统计学理论，您将对在变换输入上做出的预测误差进行建模，并推导通过平均这些预测所实现的预测方差的减少量。这项推导  将使您从量化角度理解 TTA 如何增强模型的稳健性，从经验观察提升到第一性原理的解释。",
            "id": "3862720",
            "problem": "一个迁移学习的卷积神经网络 (CNN) 被微调，用于从农业区域的合成孔径雷达 (SAR) 图像块中回归地表土壤湿度。在测试时，为提高鲁棒性，系统应用了阶为八的二面体群，记为 $D_{4}$，它由 $8$ 种变换组成：旋转 $0^{\\circ}$、$90^{\\circ}$、$180^{\\circ}$、$270^{\\circ}$ 和反射（水平和垂直翻转，每种都可以选择性地与旋转复合）。对于单个图像块，模型会输出 $8$ 个预测值，每个变换对应一个，然后将它们平均以产生最终估计值。\n\n设在变换 $g \\in D_{4}$ 下的预测为 $Y_{g}$。预测误差由 $Y_{g} = \\theta + \\varepsilon_{g}$ 建模，其中 $\\theta$ 是该图像块的变换不变目标值，而 $\\varepsilon_{g}$ 是一个零均值误差项。假设存在以下仅取决于相对变换的协方差结构：\n- 对于所有 $g \\in D_{4}$，$\\operatorname{Var}(\\varepsilon_{g}) = \\sigma^{2}$，\n- 如果 $g^{-1} h$ 是一个真旋转（即 $D_{4}$ 旋转子群中的一个元素），则 $\\operatorname{Cov}(\\varepsilon_{g}, \\varepsilon_{h}) = \\sigma^{2} \\rho_{\\mathrm{rot}}$，\n- 如果 $g^{-1} h$ 是一个反射（即涉及一次翻转），则 $\\operatorname{Cov}(\\varepsilon_{g}, \\varepsilon_{h}) = \\sigma^{2} \\rho_{\\mathrm{flip}}$。\n\n这种结构捕捉到了一个经验性的观察：在旋转下的预测比涉及翻转的预测具有更强的相关性。\n\n设测试时增强估计量为 $\\bar{Y} = \\frac{1}{8} \\sum_{g \\in D_{4}} Y_{g}$。从概率论中方差和协方差的基本原理出发，根据上述假设，推导 $\\operatorname{Var}(\\bar{Y})$ 关于 $\\sigma^{2}$、$\\rho_{\\mathrm{rot}}$ 和 $\\rho_{\\mathrm{flip}}$ 的解析表达式。然后，将由测试时增强引起的分数方差缩减定义为\n$$\\Delta \\equiv 1 - \\frac{\\operatorname{Var}(\\bar{Y})}{\\operatorname{Var}(Y_{g})},$$\n并对于科学上合理的值 $\\rho_{\\mathrm{rot}} = 0.6$ 和 $\\rho_{\\mathrm{flip}} = 0.3$ 计算 $\\Delta$。将最终的 $\\Delta$ 表示为一个无单位小数，并将答案四舍五入到四位有效数字。",
            "solution": "该问题要求推导测试时增强估计量的方差，并随后计算分数方差缩减。我们首先验证问题陈述。\n\n### 问题验证\n**第1步：提取的已知条件**\n- **对称群：** 阶为八的二面体群 $D_{4}$，由 $8$ 个变换组成。该群有一个阶为 $4$ 的旋转子群（旋转 $0^{\\circ}, 90^{\\circ}, 180^{\\circ}, 270^{\\circ}$）和一套 $4$ 个反射。\n- **预测模型：** 对于一个变换 $g \\in D_{4}$，其预测为 $Y_{g} = \\theta + \\varepsilon_{g}$。\n- **目标值：** $\\theta$ 是一个变换不变的常数。\n- **误差项：** $\\varepsilon_{g}$ 是一个均值为 $E[\\varepsilon_{g}] = 0$ 的随机变量。\n- **误差协方差结构：**\n  - 对于所有 $g \\in D_{4}$，$\\operatorname{Var}(\\varepsilon_{g}) = \\sigma^{2}$。\n  - 如果 $g^{-1} h$ 是一个真旋转，则 $\\operatorname{Cov}(\\varepsilon_{g}, \\varepsilon_{h}) = \\sigma^{2} \\rho_{\\mathrm{rot}}$。问题在括号中澄清了这一点：“（即 $D_{4}$ 旋转子群中的一个元素）”。\n  - 如果 $g^{-1} h$ 是一个反射，则 $\\operatorname{Cov}(\\varepsilon_{g}, \\varepsilon_{h}) = \\sigma^{2} \\rho_{\\mathrm{flip}}$。\n- **估计量：** 测试时增强估计量为 $\\bar{Y} = \\frac{1}{8} \\sum_{g \\in D_{4}} Y_{g}$。\n- **目标1：** 推导 $\\operatorname{Var}(\\bar{Y})$ 关于 $\\sigma^{2}$、$\\rho_{\\mathrm{rot}}$ 和 $\\rho_{\\mathrm{flip}}$ 的表达式。\n- **目标2：** 对于特定值 $\\rho_{\\mathrm{rot}} = 0.6$ 和 $\\rho_{\\mathrm{flip}} = 0.3$，计算分数方差缩减 $\\Delta \\equiv 1 - \\frac{\\operatorname{Var}(\\bar{Y})}{\\operatorname{Var}(Y_{g})}$。\n- **最终答案格式：** 一个四舍五入到四位有效数字的小数。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，提法恰当且客观。它描述了机器学习中一种应用于真实遥感问题的常规技术（测试时增强）。误差的统计建模是标准的。所有必要的参数和定义都已提供。问题陈述中存在一个微小的歧义：“真旋转（即旋转子群的一个元素）”。按照惯例，真旋转不包括单位变换，而旋转子群则包括它。然而，问题也明确指出 $\\operatorname{Var}(\\varepsilon_{g}) = \\sigma^{2}$。如果旋转的协方差规则 $\\sigma^{2}\\rho_{\\mathrm{rot}}$ 应用于单位变换的情况（$g=h$），那将意味着 $\\sigma^2 = \\sigma^2 \\rho_{\\mathrm{rot}}$，从而得出 $\\rho_{\\mathrm{rot}}=1$，这是一个过于苛刻且不大可能的情景。唯一一致的解释是，协方差规则适用于 $g \\neq h$ 的情况，而 $g=h$ 的情况由单独的方差定义所决定。这种解释消除了歧义，并使问题完全自洽。因此，该问题被认为是有效的。\n\n### 解答\n主要任务是计算测试时增强估计量 $\\bar{Y}$ 的方差。该估计量定义为在群 $D_{4}$ 上的预测值的算术平均值：\n$$ \\bar{Y} = \\frac{1}{8} \\sum_{g \\in D_{4}} Y_{g} $$\n$\\bar{Y}$ 的方差由以下公式给出：\n$$ \\operatorname{Var}(\\bar{Y}) = \\operatorname{Var}\\left(\\frac{1}{8} \\sum_{g \\in D_{4}} Y_{g}\\right) = \\frac{1}{8^{2}} \\operatorname{Var}\\left(\\sum_{g \\in D_{4}} Y_{g}\\right) = \\frac{1}{64} \\sum_{g \\in D_{4}} \\sum_{h \\in D_{4}} \\operatorname{Cov}(Y_{g}, Y_{h}) $$\n每个预测的模型是 $Y_{g} = \\theta + \\varepsilon_{g}$。由于 $\\theta$ 是一个常数，它不影响方差或协方差：\n$$ \\operatorname{Var}(Y_{g}) = \\operatorname{Var}(\\varepsilon_{g}) = \\sigma^{2} $$\n$$ \\operatorname{Cov}(Y_{g}, Y_{h}) = \\operatorname{Cov}(\\varepsilon_{g}, \\varepsilon_{h}) $$\n协方差 $\\operatorname{Cov}(\\varepsilon_{g}, \\varepsilon_{h})$ 被规定为仅取决于相对变换 $k = g^{-1}h$。我们可以通过固定一个索引（比如 $g$）并对 $h$ 求和来重写这个双重求和。\n$$ \\operatorname{Var}\\left(\\sum_{g \\in D_{4}} Y_{g}\\right) = \\sum_{g \\in D_{4}} \\left( \\sum_{h \\in D_{4}} \\operatorname{Cov}(Y_{g}, Y_{h}) \\right) $$\n让我们分析固定 $g$ 时的内部和。当 $h$ 遍历 $D_{4}$ 的所有 $8$ 个元素时，相对变换 $k = g^{-1}h$ 也遍历 $D_{4}$ 的所有 $8$ 个元素，因为用 $g^{-1}$ 进行左乘是群元素的一个排列。因此，对于任何固定的 $g$，相对变换的集合 $\\{g^{-1}h \\mid h \\in D_{4}\\}$ 与集合 $D_{4}$ 本身是相同的。\n\n群 $D_{4}$ 包括：\n1.  一个单位变换 ($e$)。\n2.  三个非单位旋转。完整的旋转子群包含 $4$ 个元素。\n3.  四个反射。\n\n协方差的值取决于相对变换 $k = g^{-1}h$ 的性质：\n- 如果 $k = e$（即 $h=g$）：对于每个 $g$，这种情况只对一个 $h$ 发生。协方差为 $\\operatorname{Cov}(Y_{g}, Y_{g}) = \\operatorname{Var}(Y_{g}) = \\sigma^{2}$。\n- 如果 $k$ 是一个非单位旋转：对于每个 $g$，这种情况有 $3$ 种 $h$ 的选择。协方差为 $\\operatorname{Cov}(Y_g, Y_h) = \\sigma^2 \\rho_{\\mathrm{rot}}$。\n- 如果 $k$ 是一个反射：对于每个 $g$，这种情况有 $4$ 种 $h$ 的选择。协方差为 $\\operatorname{Cov}(Y_g, Y_h) = \\sigma^2 \\rho_{\\mathrm{flip}}$。\n\n因此，对于任何固定的 $g$，内部和为：\n$$ \\sum_{h \\in D_{4}} \\operatorname{Cov}(Y_{g}, Y_{h}) = 1 \\cdot \\sigma^{2} + 3 \\cdot (\\sigma^{2} \\rho_{\\mathrm{rot}}) + 4 \\cdot (\\sigma^{2} \\rho_{\\mathrm{flip}}) = \\sigma^{2}(1 + 3\\rho_{\\mathrm{rot}} + 4\\rho_{\\mathrm{flip}}) $$\n这个和与 $g$ 的选择无关。为了得到和的总方差，我们将此量对所有 $8$ 个可能的 $g$ 进行求和：\n$$ \\operatorname{Var}\\left(\\sum_{g \\in D_{4}} Y_{g}\\right) = \\sum_{g \\in D_{4}} \\sigma^{2}(1 + 3\\rho_{\\mathrm{rot}} + 4\\rho_{\\mathrm{flip}}) = 8 \\sigma^{2}(1 + 3\\rho_{\\mathrm{rot}} + 4\\rho_{\\mathrm{flip}}) $$\n现在，我们将其代回 $\\operatorname{Var}(\\bar{Y})$ 的表达式中：\n$$ \\operatorname{Var}(\\bar{Y}) = \\frac{1}{64} \\left( 8 \\sigma^{2}(1 + 3\\rho_{\\mathrm{rot}} + 4\\rho_{\\mathrm{flip}}) \\right) = \\frac{\\sigma^{2}}{8}(1 + 3\\rho_{\\mathrm{rot}} + 4\\rho_{\\mathrm{flip}}) $$\n这是 $\\operatorname{Var}(\\bar{Y})$ 所需的解析表达式。\n\n接下来，我们计算分数方差缩减 $\\Delta$。其定义为：\n$$ \\Delta \\equiv 1 - \\frac{\\operatorname{Var}(\\bar{Y})}{\\operatorname{Var}(Y_{g})} $$\n我们知道 $\\operatorname{Var}(Y_{g}) = \\sigma^{2}$。代入方差的表达式：\n$$ \\Delta = 1 - \\frac{\\frac{\\sigma^{2}}{8}(1 + 3\\rho_{\\mathrm{rot}} + 4\\rho_{\\mathrm{flip}})}{\\sigma^{2}} = 1 - \\frac{1}{8}(1 + 3\\rho_{\\mathrm{rot}} + 4\\rho_{\\mathrm{flip}}) $$\n问题提供了数值 $\\rho_{\\mathrm{rot}} = 0.6$ 和 $\\rho_{\\mathrm{flip}} = 0.3$。我们将这些值代入 $\\Delta$ 的表达式中：\n$$ \\Delta = 1 - \\frac{1}{8}(1 + 3(0.6) + 4(0.3)) $$\n我们计算括号内的项：\n$$ 1 + 3(0.6) + 4(0.3) = 1 + 1.8 + 1.2 = 4.0 $$\n将此值代回 $\\Delta$ 的方程：\n$$ \\Delta = 1 - \\frac{1}{8}(4.0) = 1 - 0.5 = 0.5 $$\n问题要求答案表示为四舍五入到四位有效数字的小数。因此，$0.5$ 写为 $0.5000$。",
            "answer": "$$\\boxed{0.5000}$$"
        },
        {
            "introduction": "遥感领域的一个主要挑战是“域偏移”（domain shift），即在一个地理区域训练的模型在另一区域表现不佳，而迁移学习旨在解决此问题。本练习介绍了一种经典的域自适应技术——相关性对齐（Correlation Alignment, CORAL）。您将计算 CORAL 损失，它用于衡量源域和目标域特征之间二阶统计量（协方差）的差异。通过亲手实现 CORAL 损失的计算 ，您将获得对齐特征分布的基本方法的实践经验，这是将模型适应于新的、未见过的环境的关键一步。",
            "id": "3862784",
            "problem": "给定两个有限的特征向量集合，它们代表来自两个不同大洲的编码后的作物地块，一个集合被指定为源域，另一个为目标域。您的任务是计算相关对齐 (CORAL) 损失，该损失用于惩罚源域和目标域特征分布之间二阶统计量的差异。CORAL 损失定义为源协方差矩阵和目标协方差矩阵之差的弗罗贝尼乌斯范数的平方。\n\n从以下基本定义开始：\n\n- 令 $X \\in \\mathbb{R}^{n \\times d}$ 表示一个数据矩阵，其中有 $n$ 个样本（行）和 $d$ 个特征（列）。\n- 样本均值向量为 $\\mu = \\frac{1}{n} \\sum_{i=1}^{n} x_i$，其中 $x_i$ 是 $X$ 的第 $i$ 行。\n- 中心化数据矩阵为 $X_c = X - \\mathbf{1}_n \\mu^\\top$，其中 $\\mathbf{1}_n \\in \\mathbb{R}^{n \\times 1}$ 是一个全为 1 的列向量。\n- 无偏样本协方差矩阵（当 $n \\ge 2$ 时）为 $C = \\frac{1}{n-1} X_c^\\top X_c \\in \\mathbb{R}^{d \\times d}$。对于 $n \\le 1$ 的情况，使用约定 $C = 0_{d \\times d}$。\n- 弗罗贝尼乌斯范数为 $\\lVert A \\rVert_F = \\sqrt{\\sum_{i,j} a_{ij}^2}$，适用于任何矩阵 $A$。\n- 具有协方差 $C_S$ 和 $C_T$ 的源特征集和目标特征集之间的 CORAL 损失为\n$$\nL_{\\text{CORAL}} = \\lVert C_S - C_T \\rVert_F^2 = \\operatorname{trace}\\!\\big((C_S - C_T)^\\top(C_S - C_T)\\big).\n$$\n\n在迁移学习中，特征是通过将预训练的编码器应用于原始输入来获得的。在本问题中，将编码器建模为一个无仿射变换的线性映射，后跟一个逐点激活函数。具体来说，给定原始输入 $X \\in \\mathbb{R}^{n \\times m}$ 和一个编码器权重矩阵 $W \\in \\mathbb{R}^{m \\times d}$，编码后的特征定义为\n$$\nF = \\phi(X W),\n$$\n其中 $\\phi$ 要么是逐元素应用的恒等激活函数 $\\phi(z) = z$，要么是逐元素应用的修正线性单元 (ReLU) $\\phi(z) = \\max(0, z)$。\n\n对于下面的每个测试用例，您必须：\n$1.$ 计算 $F_S = \\phi(X_S W)$ 和 $F_T = \\phi(X_T W)$。\n$2.$ 根据 $F_S$ 和 $F_T$ 计算无偏样本协方差矩阵 $C_S$ 和 $C_T$，当 $n \\ge 2$ 时使用 $C = \\frac{1}{n-1} X_c^\\top X_c$，当 $n \\le 1$ 时使用 $C = 0_{d \\times d}$。\n$3.$ 计算 $L_{\\text{CORAL}} = \\lVert C_S - C_T \\rVert_F^2$。\n将每个 $L_{\\text{CORAL}}$ 作为四舍五入到 $6$ 位小数的浮点数返回。\n\n测试套件（所有矩阵都已明确给出）：\n\n- 用例 $1$（通用情况，恒等激活）：\n  - $X_S^{(1)} = \\begin{bmatrix}\n  1  2  3 \\\\\n  2  1  0 \\\\\n  0  1  2 \\\\\n  3  5  7\n  \\end{bmatrix}$,\n  $X_T^{(1)} = \\begin{bmatrix}\n  2  0  1 \\\\\n  1  1  1 \\\\\n  4  2  0 \\\\\n  0  3  6\n  \\end{bmatrix}$,\n  $W^{(1)} = \\begin{bmatrix}\n  1  0 \\\\\n  0  1 \\\\\n  1  -1\n  \\end{bmatrix}$,\n  $\\phi$ 是恒等函数。\n\n- 用例 $2$（相同域，ReLU）：\n  - $X_S^{(2)} = \\begin{bmatrix}\n  1  0  1 \\\\\n  0  1  1 \\\\\n  2  2  2\n  \\end{bmatrix}$,\n  $X_T^{(2)} = \\begin{bmatrix}\n  1  0  1 \\\\\n  0  1  1 \\\\\n  2  2  2\n  \\end{bmatrix}$,\n  $W^{(2)} = \\begin{bmatrix}\n  1  0 \\\\\n  0  1 \\\\\n  1  -1\n  \\end{bmatrix}$,\n  $\\phi$ 是 ReLU，$\\phi(z) = \\max(0, z)$ 逐元素应用。\n\n- 用例 $3$（使用 ReLU 的一维编码特征，零方差源）：\n  - $X_S^{(3)} = \\begin{bmatrix}\n  1  1 \\\\\n  2  1 \\\\\n  0  2\n  \\end{bmatrix}$,\n  $X_T^{(3)} = \\begin{bmatrix}\n  3  1 \\\\\n  1  0 \\\\\n  0  3\n  \\end{bmatrix}$,\n  $W^{(3)} = \\begin{bmatrix}\n  1 \\\\\n  -2\n  \\end{bmatrix}$,\n  $\\phi$ 是 ReLU，$\\phi(z) = \\max(0, z)$ 逐元素应用。\n\n- 用例 $4$（边界条件，单个源样本，恒等激活）：\n  - $X_S^{(4)} = \\begin{bmatrix}\n  10  10\n  \\end{bmatrix}$,\n  $X_T^{(4)} = \\begin{bmatrix}\n  9  11 \\\\\n  11  9\n  \\end{bmatrix}$,\n  $W^{(4)} = \\begin{bmatrix}\n  1  0 \\\\\n  0  1\n  \\end{bmatrix}$,\n  $\\phi$ 是恒等函数。\n\n实现要求：\n- 当 $n \\ge 2$ 时，使用无偏协方差估计量 $C = \\frac{1}{n-1} X_c^\\top X_c$；当 $n \\le 1$ 时，使用 $C = 0_{d \\times d}$。\n- 最终输出必须是单行，包含按顺序排列的四个结果的列表，四舍五入到 $6$ 位小数，并格式化为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，不含空格。\n- 本问题不涉及物理单位。不涉及角度。不要将任何量表示为百分比；所有输出都必须是浮点数。\n\n您的程序必须为每个用例计算 $L_{\\text{CORAL}}$，并按规定打印单行汇总结果。",
            "solution": "该问题是适定的且在科学上是合理的。其解决需要系统地应用线性代数和统计学中的标准定义。目标是计算相关对齐 (CORAL) 损失，其定义为源样本协方差矩阵和目标样本协方差矩阵之差的弗罗贝尼乌斯范数的平方：$L_{\\text{CORAL}} = \\lVert C_S - C_T \\rVert_F^2$。\n\n计算过程包括三个顺序步骤：\n$1$. **特征编码**：原始输入数据矩阵 $X_S$ 和 $X_T$ 分别被转换为编码后的特征矩阵 $F_S$ 和 $F_T$。这是通过指定的映射 $F = \\phi(XW)$ 实现的，其中 $\\phi$ 是一个逐元素激活函数（恒等函数或 ReLU）。\n$2$. **协方差矩阵计算**：无偏样本协方差矩阵 $C_S$ 和 $C_T$ 是根据编码后的特征 $F_S$ 和 $F_T$ 计算的。对于一个给定的特征矩阵 $F \\in \\mathbb{R}^{n \\times d}$（包含 $n$ 个样本和 $d$ 个特征），协方差矩阵 $C$ 的计算方法如下：\n- 如果 $n \\ge 2$，无偏样本协方差为 $C = \\frac{1}{n-1} F_c^\\top F_c$，其中 $F_c = F - \\mathbf{1}_n \\mu^\\top$ 是中心化数据矩阵，$\\mu$ 是 $F$ 的样本均值向量。\n- 如果 $n \\le 1$，协方差矩阵定义为 $d \\times d$ 的零矩阵，$C = 0_{d \\times d}$。\n$3$. **损失计算**：CORAL 损失是差分矩阵 $C_S - C_T$ 中所有元素的平方和。即，$L_{\\text{CORAL}} = \\sum_{i,j} ( (C_S - C_T)_{ij} )^2$。\n\n我们现在将此过程应用于所提供的四个测试用例中的每一个。\n\n**用例 1：使用恒等激活的通用情况**\n给定 $X_S^{(1)}$、$X_T^{(1)}$、$W^{(1)}$ 和 $\\phi(z)=z$。\n编码后的特征为 $F_S^{(1)} = X_S^{(1)} W^{(1)}$ 和 $F_T^{(1)} = X_T^{(1)} W^{(1)}$。\n$$\nF_S^{(1)} = \\begin{bmatrix} 1  2  3 \\\\ 2  1  0 \\\\ 0  1  2 \\\\ 3  5  7 \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  -1 \\end{bmatrix} = \\begin{bmatrix} 4  -1 \\\\ 2  1 \\\\ 2  -1 \\\\ 10  -2 \\end{bmatrix}\n$$\n$$\nF_T^{(1)} = \\begin{bmatrix} 2  0  1 \\\\ 1  1  1 \\\\ 4  2  0 \\\\ 0  3  6 \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  -1 \\end{bmatrix} = \\begin{bmatrix} 3  -1 \\\\ 2  0 \\\\ 4  2 \\\\ 6  -3 \\end{bmatrix}\n$$\n样本大小为 $n_S=4$ 和 $n_T=4$，均大于或等于 $2$。我们计算无偏样本协方差矩阵。\n对于源域，$\\mu_S = [4.5, -0.75]$。协方差矩阵为：\n$$ C_S^{(1)} = \\frac{1}{3} \\begin{bmatrix} 43  -10.5 \\\\ -10.5  4.75 \\end{bmatrix} = \\begin{bmatrix} 14.333\\dots  -3.5 \\\\ -3.5  1.5833\\dots \\end{bmatrix} $$\n对于目标域，$\\mu_T = [3.75, -0.5]$。协方差矩阵为：\n$$ C_T^{(1)} = \\frac{1}{3} \\begin{bmatrix} 8.75  -5.5 \\\\ -5.5  13 \\end{bmatrix} = \\begin{bmatrix} 2.9166\\dots  -1.8333\\dots \\\\ -1.8333\\dots  4.3333\\dots \\end{bmatrix} $$\nCORAL 损失是 $C_S^{(1)} - C_T^{(1)}$ 的弗罗贝尼乌斯范数的平方：\n$$ L_{\\text{CORAL}}^{(1)} = \\left\\lVert \\frac{1}{3} \\begin{bmatrix} 34.25  -5 \\\\ -5  -8.25 \\end{bmatrix} \\right\\rVert_F^2 = \\frac{1}{9} (34.25^2 + (-5)^2 + (-5)^2 + (-8.25)^2) = \\frac{1291.125}{9} = 143.458333\\dots $$\n\n**用例 2：使用 ReLU 激活的相同域**\n给定 $X_S^{(2)} = X_T^{(2)}$、$W^{(2)}$ 和 $\\phi(z)=\\max(0,z)$。\n由于源域和目标域的原始输入相同 ($X_S^{(2)} = X_T^{(2)}$)，并且它们由相同的编码器（$W^{(2)}$ 和 $\\phi$）处理，因此它们的特征表示也将相同：$F_S^{(2)} = \\phi(X_S^{(2)}W^{(2)}) = \\phi(X_T^{(2)}W^{(2)}) = F_T^{(2)}$。因此，它们的协方差矩阵必然相等，$C_S^{(2)} = C_T^{(2)}$。\n差分矩阵 $C_S^{(2)} - C_T^{(2)}$ 是零矩阵。因此，损失为零。\n$$ L_{\\text{CORAL}}^{(2)} = \\lVert 0 \\rVert_F^2 = 0 $$\n\n**用例 3：使用 ReLU 激活的一维特征**\n给定 $X_S^{(3)}$、$X_T^{(3)}$、$W^{(3)}$ 和 $\\phi(z)=\\max(0,z)$。编码后的特征将是一维的（$d=1$）。\n$$ Z_S^{(3)} = X_S^{(3)} W^{(3)} = \\begin{bmatrix} 1  1 \\\\ 2  1 \\\\ 0  2 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix} = \\begin{bmatrix} -1 \\\\ 0 \\\\ -4 \\end{bmatrix} \\implies F_S^{(3)} = \\phi(Z_S^{(3)}) = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix} $$\n由于所有源特征均为 0，方差为 0。$C_S^{(3)} = [0]$。\n$$ Z_T^{(3)} = X_T^{(3)} W^{(3)} = \\begin{bmatrix} 3  1 \\\\ 1  0 \\\\ 0  3 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 1 \\\\ -6 \\end{bmatrix} \\implies F_T^{(3)} = \\phi(Z_T^{(3)}) = \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix} $$\n对于目标特征，$n_T=3$，$\\mu_T = [2/3]$。中心化数据为 $[1/3, 1/3, -2/3]^\\top$。协方差（对于 $d=1$ 即为方差）是：\n$$ C_T^{(3)} = \\frac{1}{3-1} \\left( (1/3)^2 + (1/3)^2 + (-2/3)^2 \\right) = \\frac{1}{2} \\left( \\frac{6}{9} \\right) = \\left[\\frac{1}{3}\\right] $$\nCORAL 损失为：\n$$ L_{\\text{CORAL}}^{(3)} = \\lVert [0] - [1/3] \\rVert_F^2 = (-1/3)^2 = 1/9 = 0.111111\\dots $$\n\n**用例 4：单个源样本的边界条件**\n给定 $X_S^{(4)}$、$X_T^{(4)}$、$W^{(4)}$ 和 $\\phi(z)=z$。\n源域只有一个样本，$n_S = 1$。根据问题定义，对于 $n \\le 1$ 的情况，协方差矩阵是零矩阵。特征维度为 $d=2$。\n$$ C_S^{(4)} = \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix} $$\n对于目标域，$n_T = 2$。使用恒等激活函数且 $W^{(4)}$ 为单位矩阵，则 $F_T^{(4)} = X_T^{(4)} = \\begin{bmatrix} 9  11 \\\\ 11  9 \\end{bmatrix}$。均值为 $\\mu_T = [10, 10]$。中心化数据为 $F_{T,c}^{(4)} = \\begin{bmatrix} -1  1 \\\\ 1  -1 \\end{bmatrix}$。协方差矩阵为：\n$$ C_T^{(4)} = \\frac{1}{2-1} (F_{T,c}^{(4)})^\\top F_{T,c}^{(4)} = \\begin{bmatrix} -1  1 \\\\ 1  -1 \\end{bmatrix} \\begin{bmatrix} -1  1 \\\\ 1  -1 \\end{bmatrix} = \\begin{bmatrix} 2  -2 \\\\ -2  2 \\end{bmatrix} $$\nCORAL 损失为：\n$$ L_{\\text{CORAL}}^{(4)} = \\left\\lVert \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix} - \\begin{bmatrix} 2  -2 \\\\ -2  2 \\end{bmatrix} \\right\\rVert_F^2 = (-2)^2 + 2^2 + 2^2 + (-2)^2 = 4+4+4+4=16 $$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_covariance(F):\n    \"\"\"\n    Computes the unbiased sample covariance matrix for a feature matrix F.\n    Handles the case n = 1 as specified in the problem.\n    \"\"\"\n    if F.ndim == 1:\n        F = F.reshape(-1, 1)\n    \n    n, d = F.shape\n\n    if n = 1:\n        return np.zeros((d, d))\n    else:\n        mu = np.mean(F, axis=0)\n        F_c = F - mu\n        # Using (F_c.T @ F_c) / (n - 1) as per the definition\n        C = np.dot(F_c.T, F_c) / (n - 1)\n        return C\n\ndef compute_coral_loss(X_S, X_T, W, activation):\n    \"\"\"\n    Computes the CORAL loss for given source and target data, and an encoder.\n    \"\"\"\n    X_S_np = np.array(X_S, dtype=np.float64)\n    X_T_np = np.array(X_T, dtype=np.float64)\n    W_np = np.array(W, dtype=np.float64)\n\n    # 1. Encode features\n    Z_S = X_S_np @ W_np\n    Z_T = X_T_np @ W_np\n\n    if activation == 'relu':\n        F_S = np.maximum(0, Z_S)\n        F_T = np.maximum(0, Z_T)\n    else:  # identity\n        F_S = Z_S\n        F_T = Z_T\n\n    # 2. Compute covariance matrices\n    C_S = compute_covariance(F_S)\n    C_T = compute_covariance(F_T)\n\n    # 3. Compute CORAL loss\n    C_diff = C_S - C_T\n    loss = np.sum(C_diff**2)  # Squared Frobenius norm\n\n    return loss\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            [[1, 2, 3], [2, 1, 0], [0, 1, 2], [3, 5, 7]], \n            [[2, 0, 1], [1, 1, 1], [4, 2, 0], [0, 3, 6]],\n            [[1, 0], [0, 1], [1, -1]], \n            'identity'\n        ),\n        # Case 2\n        (\n            [[1, 0, 1], [0, 1, 1], [2, 2, 2]],\n            [[1, 0, 1], [0, 1, 1], [2, 2, 2]],\n            [[1, 0], [0, 1], [1, -1]],\n            'relu'\n        ),\n        # Case 3\n        (\n            [[1, 1], [2, 1], [0, 2]],\n            [[3, 1], [1, 0], [0, 3]],\n            [[1], [-2]],\n            'relu'\n        ),\n        # Case 4\n        (\n            [[10, 10]],\n            [[9, 11], [11, 9]],\n            [[1, 0], [0, 1]],\n            'identity'\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        X_S, X_T, W, activation = case\n        coral_loss = compute_coral_loss(X_S, X_T, W, activation)\n        results.append(coral_loss)\n\n    # Final print statement in the exact required format.\n    # Results are formatted to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}