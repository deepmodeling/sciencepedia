{
    "hands_on_practices": [
        {
            "introduction": "植被指数是利用不同光谱波段反射率的组合来增强植被信号的常用工具。本练习旨在通过计算和比较三种广泛使用的植被指数——归一化植被指数 ($NDVI$)、土壤调节植被指数 ($SAVI$) 和增强型植被指数 ($EVI$)，来加深对它们各自优势和局限性的理解。通过这项实践，您将学会如何根据具体应用场景（例如，区分稀疏植被与裸土）选择最合适的指数 。",
            "id": "3803509",
            "problem": "为监测作物健康状况并使用归一化植被指数区分稀疏植被与裸土，开展了一项多光谱遥感活动。考虑在晴朗天空下，于当地太阳正午时观测到的两个相邻地块。已经应用了大气校正以获得地表反射率。地块 $\\mathrm{S}$ 是一个稀疏的新生作物冠层，地块 $\\mathrm{B}$ 是裸土。对于每个地块，测得的波段反射率如下：地块 $\\mathrm{S}$ 的 $R_{\\mathrm{NIR}}=0.42$, $R_{\\mathrm{Red}}=0.15$, $R_{\\mathrm{Blue}}=0.07$。地块 $\\mathrm{B}$ 的 $R_{\\mathrm{NIR}}=0.30$, $R_{\\mathrm{Red}}=0.22$, $R_{\\mathrm{Blue}}=0.19$。从地表反射率的基本定义（即在一个光谱波段上积分的上行辐射亮度与下行辐射照度的无量纲比率）以及归一化光谱对比度能够抑制乘性光照和传感器增益效应的原理出发，推导归一化植被指数 (NDVI)、土壤调节植被指数 (SAVI) 和增强型植被指数 (EVI) 的显式表达式。在您的推导中，为 SAVI 引入冠层背景调节参数 $L$，并为 EVI 引入一个利用蓝光波段的气溶胶阻力项。使用中分辨率成像光谱仪 (MODIS) 文献中定义的 EVI 标准业务常数，即 $G=2.5$, $C_{1}=6$, $C_{2}=7.5$，以及 EVI 分母中的 $L=1$。对于 SAVI，取 $L=0.5$。然后，计算地块 $\\mathrm{S}$ 和地块 $\\mathrm{B}$ 的 NDVI、SAVI 和 EVI 值。为评估哪个指数能最好地区分稀疏作物与裸土，请为每个指数计算定义为 $|I_{\\mathrm{S}}-I_{\\mathrm{B}}|$ 的类间绝对差，其中 $I_{\\mathrm{S}}$ 和 $I_{\\mathrm{B}}$ 分别表示地块 $\\mathrm{S}$ 和地块 $\\mathrm{B}$ 的指数值。报告 NDVI、SAVI 和 EVI 中的最大绝对差，结果为一个十进制数值，四舍五入到四位有效数字。最终结果不带单位。",
            "solution": "该问题要求推导三种标准植被指数的表达式，计算它们在两种不同土地覆盖类型下的值，并评估它们区分这两种类型的能力。对问题陈述的验证表明，其科学依据充分、提法明确、客观且完整。因此，在此给出完整解答。\n\n基本概念是地表反射率 $R$，它是一个无量纲量，表示在给定光谱波段内，地表反射的入射太阳辐射的比例。对于中心波长为 $\\lambda$ 的波段，反射率 $R_{\\lambda}$ 定义为上行光谱辐射亮度 $L_{\\uparrow, \\lambda}$ 与下行光谱辐射照度 $E_{\\downarrow, \\lambda}$ 的比值。由太阳角度或大气霾引起的光照变化以及传感器增益伪影等乘性因子，往往会以相关的方式影响不同光谱波段的反射率。植被指数的设计旨在利用光谱对比度，同时抑制这些混淆因素。比值，特别是归一化差异，对于实现这一目的非常有效。\n\n健康、具有光合作用活性的植被的主要光谱特征是，叶绿素在光谱的红色部分对辐射有强吸收，而叶片内部的细胞结构在近红外 (NIR) 部分有强反射。相比之下，裸土的反射率通常从红色到近红外波段呈现更平缓的增加。植被指数就是为了量化这种对比度而构建的。\n\n1.  **归一化植被指数 (NDVI)**\n    NDVI 旨在增强红光与近红外的对比度，同时对光照条件进行归一化。它被构建为近红外和红光反射率之间的归一化差异。设 $R_{\\mathrm{NIR}}$ 和 $R_{\\mathrm{Red}}$ 分别为相应波段的反射率，则 NDVI 定义为：\n    $$\n    \\mathrm{NDVI} = \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{Red}}}{R_{\\mathrm{NIR}} + R_{\\mathrm{Red}}}\n    $$\n    这种公式将指数的值限制在 $-1$ 和 $+1$ 之间，并减轻了乘性噪声的影响。\n\n2.  **土壤调节植被指数 (SAVI)**\n    在有稀疏植被的场景中，光谱信号是植被和下垫土壤背景的混合。NDVI 对土壤亮度可能很敏感，这会导致解释 NDVI 值时出现模糊性。SAVI 通过引入一个冠层背景调节参数 $L$ 来修正 NDVI 方程，以最小化这种由土壤引起的变异。参数 $L$ 是一个取决于冠层密度的常数；对于中等植被覆盖度，通常使用 $L=0.5$ 的值，正如问题中所指定的。SAVI 的表达式为：\n    $$\n    \\mathrm{SAVI} = \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{Red}}}{R_{\\mathrm{NIR}} + R_{\\mathrm{Red}} + L} (1+L)\n    $$\n    针对此问题，我们使用 $L=0.5$。\n\n3.  **增强型植被指数 (EVI)**\n    EVI 的开发旨在改善 NDVI 在高生物量区域（NDVI 在这些区域会饱和）的敏感度，并进一步减少土壤背景和大气的影响。EVI 引入了蓝光波段反射率 $R_{\\mathrm{Blue}}$ 来校正气溶胶散射，气溶胶散射对红光波段的影响大于对近红外波段的影响。EVI 表达式包含一个增益因子 $G$、两个气溶胶阻力系数 $C_1$ 和 $C_2$，以及一个土壤调节项 $L$。EVI 的标准 MODIS 业务公式为：\n    $$\n    \\mathrm{EVI} = G \\times \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{Red}}}{R_{\\mathrm{NIR}} + C_1 R_{\\mathrm{Red}} - C_2 R_{\\mathrm{Blue}} + L}\n    $$\n    问题提供了标准的 MODIS 常数：$G=2.5$，$C_1=6$，$C_2=7.5$ 和 $L=1$。\n\n现在，我们计算稀疏作物（地块 $\\mathrm{S}$）和裸土（地块 $\\mathrm{B}$）这三种指数的值。\n\n**给定反射率：**\n-   地块 $\\mathrm{S}$：$R_{\\mathrm{NIR,S}}=0.42$, $R_{\\mathrm{Red,S}}=0.15$, $R_{\\mathrm{Blue,S}}=0.07$。\n-   地块 $\\mathrm{B}$：$R_{\\mathrm{NIR,B}}=0.30$, $R_{\\mathrm{Red,B}}=0.22$, $R_{\\mathrm{Blue,B}}=0.19$。\n\n**地块 S（稀疏作物）的计算：**\n-   $\\mathrm{NDVI}_{\\mathrm{S}} = \\frac{0.42 - 0.15}{0.42 + 0.15} = \\frac{0.27}{0.57} \\approx 0.473684$\n-   $\\mathrm{SAVI}_{\\mathrm{S}} = \\frac{0.42 - 0.15}{0.42 + 0.15 + 0.5} (1+0.5) = \\frac{0.27}{1.07} \\times 1.5 \\approx 0.378505$\n-   $\\mathrm{EVI}_{\\mathrm{S}} = 2.5 \\times \\frac{0.42 - 0.15}{0.42 + (6 \\times 0.15) - (7.5 \\times 0.07) + 1} = 2.5 \\times \\frac{0.27}{0.42 + 0.90 - 0.525 + 1} = 2.5 \\times \\frac{0.27}{1.795} \\approx 0.376045$\n\n**地块 B（裸土）的计算：**\n-   $\\mathrm{NDVI}_{\\mathrm{B}} = \\frac{0.30 - 0.22}{0.30 + 0.22} = \\frac{0.08}{0.52} \\approx 0.153846$\n-   $\\mathrm{SAVI}_{\\mathrm{B}} = \\frac{0.30 - 0.22}{0.30 + 0.22 + 0.5} (1+0.5) = \\frac{0.08}{1.02} \\times 1.5 \\approx 0.117647$\n-   $\\mathrm{EVI}_{\\mathrm{B}} = 2.5 \\times \\frac{0.30 - 0.22}{0.30 + (6 \\times 0.22) - (7.5 \\times 0.19) + 1} = 2.5 \\times \\frac{0.08}{0.30 + 1.32 - 1.425 + 1} = 2.5 \\times \\frac{0.08}{1.195} \\approx 0.167364$\n\n最后，我们为每个指数计算类间绝对差 $|I_{\\mathrm{S}} - I_{\\mathrm{B}}|$，以确定哪个指数能在这两个地块之间提供最佳的区分度。\n-   $\\Delta_{\\mathrm{NDVI}} = |\\mathrm{NDVI}_{\\mathrm{S}} - \\mathrm{NDVI}_{\\mathrm{B}}| = |0.473684 - 0.153846| \\approx 0.319838$\n-   $\\Delta_{\\mathrm{SAVI}} = |\\mathrm{SAVI}_{\\mathrm{S}} - \\mathrm{SAVI}_{\\mathrm{B}}| = |0.378505 - 0.117647| \\approx 0.260858$\n-   $\\Delta_{\\mathrm{EVI}} = |\\mathrm{EVI}_{\\mathrm{S}} - \\mathrm{EVI}_{\\mathrm{B}}| = |0.376045 - 0.167364| \\approx 0.208681$\n\n比较这三个差值：\n$\\max(\\Delta_{\\mathrm{NDVI}}, \\Delta_{\\mathrm{SAVI}}, \\Delta_{\\mathrm{EVI}}) = \\max(0.319838, 0.260858, 0.208681) = 0.319838$。\n最大的绝对差由 NDVI 提供。问题要求将此值四舍五入到四位有效数字。\n$0.319838 \\approx 0.3198$。",
            "answer": "$$\\boxed{0.3198}$$"
        },
        {
            "introduction": "在光学遥感中，云层和云影是影响数据质量的主要因素，准确地识别和剔除受污染的像素是保证分析结果可靠性的关键预处理步骤。本练习将引导您通过编程实现并比较两种主流的云检测方法：一种基于质量评估 ($QA$) 波段，另一种基于光谱阈值。这项实践不仅能让您掌握云检测的实用技术，还能量化评估未被有效剔除的云对植被红边指数 ($NDRE$) 等下游产品造成的偏差 。",
            "id": "3803491",
            "problem": "一位遥感分析师旨在量化云污染如何对农田的红边植被指数产生偏差，并在合成但物理上合理的数据上比较两种云掩膜方法。该分析必须基于辐射传输的基本原理以及反射率和植被指数的既定定义，并实现为一个完整的、可运行的程序。从像元级别的云覆盖度分数的能量可加性和线性混合假设出发，将观测到的大气顶层反射率建模为晴空地表光谱和云光谱的凸组合。比较源自质量评估 (QA) 标志的掩膜与源自光谱阈值的掩膜，并评估当像元未被掩膜时，归一化差异红边指数中的残余偏差。\n\n基本原理和定义：\n- 设 $R_{\\lambda}$ 表示在波长（波段）$\\lambda$ 处的大气顶层反射率。在像元级别的云覆盖度分数 $f$ 和朗伯体、线性混合假设下，观测到的波段 $\\lambda$ 的反射率建模为\n$$\nR_{\\lambda}^{\\mathrm{obs}} = (1 - f)\\, R_{\\lambda}^{\\mathrm{surf}} + f \\, R_{\\lambda}^{\\mathrm{cloud}},\n$$\n其中 $R_{\\lambda}^{\\mathrm{surf}}$ 是晴空地表反射率，$R_{\\lambda}^{\\mathrm{cloud}}$ 是云反射率。在弱多次散射假设下，该凸组合遵循亚像元混合的能量守恒和反射率线性关系。\n- 归一化差异红边 (NDRE) 指数定义为\n$$\n\\mathrm{NDRE} = \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{RE}}}{R_{\\mathrm{NIR}} + R_{\\mathrm{RE}}},\n$$\n其中 $R_{\\mathrm{NIR}}$ 是近红外反射率，$R_{\\mathrm{RE}}$ 是红边反射率。NDRE 广泛用于农作物的植被活力估算。\n- 质量评估 (QA) 波段是一个位掩码，在此问题中，其相关标志为：比特 $0$ 表示云存在，比特 $1$ 表示云影，比特 $2$ 表示卷云。如果这些比特中的任何一个被设置为 $1$，则认为该像元被 QA 掩膜。\n- 光谱云掩膜是使用基于物理原理的阈值定义的，这些阈值利用了高可见光波段亮度和卷云波段的敏感性：\n    - 设 $t_{b}$ 为蓝光波段阈值，$t_{c}$ 为卷云波段阈值，$t_{V}$ 为可见光亮度阈值。定义可见光亮度 $B_{V}$ 为\n    $$\n    B_{V} = R_{\\mathrm{blue}} + R_{\\mathrm{green}} + R_{\\mathrm{red}}.\n    $$\n    - 如果满足以下任一条件，则像元在光谱上被掩膜为云：$R_{\\mathrm{blue}} \\ge t_{b}$，$R_{\\mathrm{cirrus}} \\ge t_{c}$，或 $B_{V} \\ge t_{V}$。\n\n任务：\n- 实现一个程序，对于每个测试用例，该程序使用线性混合计算观测反射率，应用基于 QA 的掩膜和光谱掩膜，根据晴空反射率计算真实 NDRE，根据混合反射率计算观测 NDRE，并仅在像元未被某个掩膜算法掩膜时，输出该算法下的残余 NDRE 偏差。如果一个像元被某个算法掩膜，则报告该算法的偏差为 $0$。偏差定义为\n$$\n\\Delta \\mathrm{NDRE} = \\mathrm{NDRE}^{\\mathrm{obs}} - \\mathrm{NDRE}^{\\mathrm{true}}.\n$$\n- 使用以下全局光谱阈值：$t_{b} = 0.30$，$t_{c} = 0.25$ 和 $t_{V} = 1.10$。\n- 使用以下云光谱反射率，代表典型云类型：\n    1. 积云光谱：$R_{\\mathrm{blue}} = 0.65$, $R_{\\mathrm{green}} = 0.70$, $R_{\\mathrm{red}} = 0.65$, $R_{\\mathrm{RE}} = 0.60$, $R_{\\mathrm{NIR}} = 0.55$, $R_{\\mathrm{SWIR1}} = 0.42$, $R_{\\mathrm{cirrus}} = 0.05$。\n    2. 卷云光谱：$R_{\\mathrm{blue}} = 0.45$, $R_{\\mathrm{green}} = 0.50$, $R_{\\mathrm{red}} = 0.48$, $R_{\\mathrm{RE}} = 0.46$, $R_{\\mathrm{NIR}} = 0.40$, $R_{\\mathrm{SWIR1}} = 0.30$, $R_{\\mathrm{cirrus}} = 0.35$。\n- 使用以下合成的作物地表光谱（晴空），这些光谱被设计为对农田是物理上合理的：\n    1. 健康小麦：$R_{\\mathrm{blue}} = 0.05$, $R_{\\mathrm{green}} = 0.08$, $R_{\\mathrm{red}} = 0.06$, $R_{\\mathrm{RE}} = 0.24$, $R_{\\mathrm{NIR}} = 0.52$, $R_{\\mathrm{SWIR1}} = 0.30$, $R_{\\mathrm{cirrus}} = 0.01$。\n    2. 玉米：$R_{\\mathrm{blue}} = 0.06$, $R_{\\mathrm{green}} = 0.09$, $R_{\\mathrm{red}} = 0.05$, $R_{\\mathrm{RE}} = 0.28$, $R_{\\mathrm{NIR}} = 0.60$, $R_{\\mathrm{SWIR1}} = 0.35$, $R_{\\mathrm{cirrus}} = 0.01$。\n    3. 大豆：$R_{\\mathrm{blue}} = 0.04$, $R_{\\mathrm{green}} = 0.08$, $R_{\\mathrm{red}} = 0.05$, $R_{\\mathrm{RE}} = 0.22$, $R_{\\mathrm{NIR}} = 0.58$, $R_{\\mathrm{SWIR1}} = 0.33$, $R_{\\mathrm{cirrus}} = 0.01$。\n    4. 裸土（季节早期田地）：$R_{\\mathrm{blue}} = 0.30$, $R_{\\mathrm{green}} = 0.35$, $R_{\\mathrm{red}} = 0.30$, $R_{\\mathrm{RE}} = 0.25$, $R_{\\mathrm{NIR}} = 0.40$, $R_{\\mathrm{SWIR1}} = 0.25$, $R_{\\mathrm{cirrus}} = 0.01$。\n- 应用以下测试场景套件，以检验不同条件和边缘情况：\n    1. 用例 1（理想路径，晴空）：健康小麦，$f = 0.00$，QA 整型比特位 $= 0$（无云，无云影，无卷云），云类型 = 无。\n    2. 用例 2（QA 失败，光谱方法捕捉到）：玉米，$f = 0.50$，QA 整型比特位 $= 0$，云类型 = 积云。\n    3. 用例 3（QA 检测到卷云，光谱方法漏检薄卷云）：大豆，$f = 0.15$，QA 整型比特位 $= 4$（仅卷云比特位置位），云类型 = 卷云。\n    4. 用例 4（浓云，两者均检测到）：健康小麦，$f = 0.70$，QA 整型比特位 $= 1$（云比特位置位），云类型 = 积云。\n    5. 用例 5（明亮土壤边界，光谱方法误报）：裸土，$f = 0.00$，QA 整型比特位 $= 0$，云类型 = 无。\n- 对于 QA 整型比特位，将比特 $0$ 解释为云存在，比特 $1$ 解释为云影，比特 $2$ 解释为卷云。如果 `(bits  1) != 0` 或 `(bits  2) != 0` 或 `(bits  4) != 0`，则像元被 QA 掩膜。\n- 对于每个用例，计算并返回一个按顺序包含四个值的列表：QA 掩膜决策（$\\mathrm{boolean}$），光谱掩膜决策（$\\mathrm{boolean}$），QA 下的 NDRE 偏差（一个 $\\mathrm{float}$），以及光谱掩膜下的 NDRE 偏差（一个 $\\mathrm{float}$）。如果被掩膜，相应的偏差必须报告为 $0$。\n- 将所有计算出的偏差值四舍五入到 $6$ 位小数。由于反射率和 NDRE 是无量纲的，因此没有物理单位要求。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的各用例结果列表，每个用例的结果本身也是一个列表，并且外层列表用方括号括起来。格式必须省略无关文本，例如：$[ [\\mathrm{case1\\_values}], [\\mathrm{case2\\_values}], \\dots ]$。",
            "solution": "该问题已经过验证，并被确定为遥感领域一个有效的、有科学依据且定义明确的问题。所有必要的数据、模型和定义均已提供，任务是基于这些输入实现一个直接的、确定性的计算。其基本原理，如反射率的线性混合模型和归一化差异红边 (NDRE) 指数的定义，是该领域的标准。所提供的测试用例在物理上是合理的，用于在各种现实场景下测试实现。\n\n解决方案通过为每个测试用例以清晰、分步的方式实现指定的模型和算法来推进。\n\n**1. 建模观测到的大气顶层 (TOA) 反射率**\n\n对于具有云覆盖度分数 $f$ 的像元，其观测到的大气顶层 (TOA) 反射率 $R^{\\mathrm{obs}}$ 的基本模型是线性混合模型。该模型假设传感器接收到的总能量是来自晴空地表分量和云分量的能量的加权平均，其中权重是面积分数。对于给定的光谱波段 $\\lambda$，反射率为：\n$$\nR_{\\lambda}^{\\mathrm{obs}} = (1 - f) R_{\\lambda}^{\\mathrm{surf}} + f R_{\\lambda}^{\\mathrm{cloud}}\n$$\n其中 $R_{\\lambda}^{\\mathrm{surf}}$ 是晴空地表反射率，$R_{\\lambda}^{\\mathrm{cloud}}$ 是云的反射率。对所有提供的光谱波段进行此计算：蓝光、绿光、红光、红边 (RE)、近红外 (NIR) 和卷云波段。当云覆盖度分数 $f$ 为 $0$ 时，方程简化为 $R_{\\lambda}^{\\mathrm{obs}} = R_{\\lambda}^{\\mathrm{surf}}$。这可以表示为所有波段上的向量形式 $\\mathbf{R}^{\\mathrm{obs}} = (1 - f)\\mathbf{R}^{\\mathrm{surf}} + f \\mathbf{R}^{\\mathrm{cloud}}$，从而实现高效计算。\n\n**2. 计算归一化差异红边 (NDRE) 指数**\n\nNDRE 指数是评估植被健康的广泛使用指标，定义为：\n$$\n\\mathrm{NDRE} = \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{RE}}}{R_{\\mathrm{NIR}} + R_{\\mathrm{RE}}}\n$$\n计算该指数的两个版本：\n- **真实 NDRE ($\\mathrm{NDRE}^{\\mathrm{true}}$)**：这是基准真值，使用未受污染的晴空地表反射率（$R_{\\mathrm{NIR}}^{\\mathrm{surf}}$ 和 $R_{\\mathrm{RE}}^{\\mathrm{surf}}$）计算。\n- **观测 NDRE ($\\mathrm{NDRE}^{\\mathrm{obs}}$)**：这是分析师从可能受云污染的卫星测量中得到的值，使用观测到的大气顶层反射率（$R_{\\mathrm{NIR}}^{\\mathrm{obs}}$ 和 $R_{\\mathrm{RE}}^{\\mathrm{obs}}$）计算。\n\n**3. 实现云掩膜算法**\n\n评估了两种不同的云掩膜算法。对一个像元的掩膜决策是一个布尔值，指示该像元被认为是多云 (`True`) 还是晴空 (`False`)。\n\n- **质量评估 (QA) 掩膜：** 该掩膜依赖于预处理的质量标志，这些标志为每个测试用例以整数位掩码的形式提供。如果对应于云（比特 $0$，值 $1$）、云影（比特 $1$，值 $2$）或卷云（比特 $2$，值 $4$）的任何比特位被设置，则认为像元被掩膜 (`True`)。这通过位运算条件进行评估：$(\\text{bits} \\ 1) \\neq 0$ 或 $(\\text{bits} \\ 2) \\neq 0$ 或 $(\\text{bits} \\ 4) \\neq 0$。\n\n- **光谱掩膜：** 该掩膜直接从观测到的光谱反射率值推导出来。如果满足以下任何基于观测反射率 $R_{\\lambda}^{\\mathrm{obs}}$ 的条件，则像元被掩膜 (`True`)：\n    1. 蓝光波段反射率超过阈值：$R_{\\mathrm{blue}}^{\\mathrm{obs}} \\ge t_{b}$，其中 $t_{b} = 0.30$。\n    2. 卷云波段反射率超过阈值：$R_{\\mathrm{cirrus}}^{\\mathrm{obs}} \\ge t_{c}$，其中 $t_{c} = 0.25$。\n    3. 可见光波段反射率之和（可见光亮度 $B_{V}$）超过阈值：$B_{V} = R_{\\mathrm{blue}}^{\\mathrm{obs}} + R_{\\mathrm{green}}^{\\mathrm{obs}} + R_{\\mathrm{red}}^{\\mathrm{obs}} \\ge t_{V}$，其中 $t_{V} = 1.10$。\n\n**4. 量化残余偏差**\n\n由未被掩膜的云污染引起的 NDRE 指数偏差是主要关注的输出。它被定义为观测到的 NDRE 值与真实 NDRE 值之间的差异：\n$$\n\\Delta \\mathrm{NDRE} = \\mathrm{NDRE}^{\\mathrm{obs}} - \\mathrm{NDRE}^{\\mathrm{true}}\n$$\n对于每种掩膜算法（QA 和光谱），都会报告其残余偏差。如果一个算法成功地掩膜了像元（即其掩膜决策为 `True`），则出于此分析的目的，污染被视为已完全移除，并且该算法的残余偏差报告为 $0$。如果算法未能掩膜该像元（其决策为 `False`），则报告完整的计算偏差 $\\Delta \\mathrm{NDRE}$。\n\n整个过程被系统地应用于五个测试用例中的每一个，并将结果——两个掩膜决策和两个相应的残余偏差——汇编成最终输出。所有偏差值都四舍五入到 $6$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the remote sensing cloud masking and bias analysis problem.\n    \"\"\"\n    \n    # --- Define Global Constants and Data ---\n\n    # Spectral cloud masking thresholds\n    THRESH_BLUE = 0.30\n    THRESH_CIRRUS = 0.25\n    THRESH_VIS_BRIGHTNESS = 1.10\n\n    # Band indices for numpy arrays\n    BAND_IDX = {\n        'blue': 0, 'green': 1, 'red': 2, \n        'RE': 3, 'NIR': 4, 'SWIR1': 5, 'cirrus': 6\n    }\n\n    # Cloud spectral reflectances (Blue, Green, Red, RE, NIR, SWIR1, Cirrus)\n    SPECTRA_CLOUD = {\n        'cumulus': np.array([0.65, 0.70, 0.65, 0.60, 0.55, 0.42, 0.05]),\n        'cirrus': np.array([0.45, 0.50, 0.48, 0.46, 0.40, 0.30, 0.35]),\n    }\n\n    # Surface spectral reflectances (Blue, Green, Red, RE, NIR, SWIR1, Cirrus)\n    SPECTRA_SURFACE = {\n        'Healthy wheat': np.array([0.05, 0.08, 0.06, 0.24, 0.52, 0.30, 0.01]),\n        'Maize': np.array([0.06, 0.09, 0.05, 0.28, 0.60, 0.35, 0.01]),\n        'Soybean': np.array([0.04, 0.08, 0.05, 0.22, 0.58, 0.33, 0.01]),\n        'Bare soil': np.array([0.30, 0.35, 0.30, 0.25, 0.40, 0.25, 0.01]),\n    }\n    \n    # Test suite of scenarios\n    test_cases = [\n        # (surface_type, fractional_cloud_cover_f, qa_bits, cloud_type)\n        ('Healthy wheat', 0.00, 0, 'none'),\n        ('Maize', 0.50, 0, 'cumulus'),\n        ('Soybean', 0.15, 4, 'cirrus'),\n        ('Healthy wheat', 0.70, 1, 'cumulus'),\n        ('Bare soil', 0.00, 0, 'none'),\n    ]\n\n    # --- Helper Functions ---\n\n    def calculate_ndre(nir_reflectance, re_reflectance):\n        \"\"\"Calculates the Normalized Difference Red Edge (NDRE) index.\"\"\"\n        numerator = nir_reflectance - re_reflectance\n        denominator = nir_reflectance + re_reflectance\n        # Avoid division by zero, though unlikely with positive reflectances\n        if denominator == 0:\n            return 0.0\n        return numerator / denominator\n\n    # --- Main Processing Logic ---\n\n    results = []\n    \n    for case in test_cases:\n        surface_type, f, qa_bits, cloud_type = case\n\n        # 1. Get spectral data for the case\n        r_surf = SPECTRA_SURFACE[surface_type]\n        \n        # 2. Model Observed Reflectance using linear mixture model\n        if f == 0.0 or cloud_type == 'none':\n            r_obs = r_surf\n        else:\n            r_cloud = SPECTRA_CLOUD[cloud_type]\n            r_obs = (1 - f) * r_surf + f * r_cloud\n\n        # 3. Calculate True and Observed NDRE\n        ndre_true = calculate_ndre(\n            r_surf[BAND_IDX['NIR']], r_surf[BAND_IDX['RE']]\n        )\n        ndre_obs = calculate_ndre(\n            r_obs[BAND_IDX['NIR']], r_obs[BAND_IDX['RE']]\n        )\n        \n        # 4. Calculate potential NDRE bias\n        ndre_bias = ndre_obs - ndre_true\n\n        # 5. Apply QA Mask\n        # Mask if bit 0 (cloud), 1 (shadow), or 2 (cirrus) is set\n        is_qa_masked = (qa_bits  1) != 0 or (qa_bits  2) != 0 or (qa_bits  4) != 0\n\n        # 6. Apply Spectral Mask\n        vis_brightness = r_obs[BAND_IDX['blue']] + r_obs[BAND_IDX['green']] + r_obs[BAND_IDX['red']]\n        \n        is_spectral_masked = (r_obs[BAND_IDX['blue']] >= THRESH_BLUE or\n                              r_obs[BAND_IDX['cirrus']] >= THRESH_CIRRUS or\n                              vis_brightness >= THRESH_VIS_BRIGHTNESS)\n        \n        # 7. Determine residual bias for each algorithm\n        qa_bias = 0.0 if is_qa_masked else ndre_bias\n        spectral_bias = 0.0 if is_spectral_masked else ndre_bias\n        \n        # 8. Compile results for the case\n        case_result = [\n            is_qa_masked, \n            is_spectral_masked, \n            round(qa_bias, 6), \n            round(spectral_bias, 6)\n        ]\n        results.append(case_result)\n        \n    # --- Format and Print Final Output ---\n    \n    # Custom formatting to match the required output style without spaces\n    inner_strings = []\n    for res in results:\n        # Format floats to 6 decimal places\n        # Booleans will be converted to 'True'/'False' by f-string\n        s = f\"[{res[0]},{res[1]},{res[2]:.6f},{res[3]:.6f}]\"\n        inner_strings.append(s)\n    \n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n    \nsolve()\n```"
        },
        {
            "introduction": "遥感分析链中的每个环节都存在不确定性，从传感器测量到大气校正参数的估算，这些不确定性会最终传播到分类图等最终产品中。本练习介绍了一种量化最终产品可靠性的高级方法：蒙特卡洛模拟。您将通过编程，模拟大气校正参数的不确定性如何通过作物分类模型传播，并最终为分类图的总体精度提供一个置信区间，从而对分析结果的可靠性有更深刻的认识 。",
            "id": "3803451",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，该程序将大气校正参数中的不确定性，通过监督式作物类型分类进行传播，并使用蒙特卡洛采样报告地图精度的置信区间。场景设定为用于农业监测的光学遥感。\n\n使用的基本原理：\n- 线性化的辐射传输关系，用于描述大气层顶反射率与地表反射率之间的关系，模型为 $\\,\\rho^{\\mathrm{TOA}}_{b} = \\rho_{b}\\,T_{b} + \\rho^{\\mathrm{path}}_{b}\\,$，其中 $\\,\\rho^{\\mathrm{TOA}}_{b}\\,$ 是波段 $\\,b\\,$ 测得的大气层顶反射率，$\\,\\rho_{b}\\,$ 是我们期望得到的波段 $\\,b\\,$ 的地表反射率，$\\,T_{b}\\,$ 是波段 $\\,b\\,$ 的大气下行及上行总透射率因子，而 $\\,\\rho^{\\mathrm{path}}_{b}\\,$ 是波段 $\\,b\\,$ 的路径反射率贡献。在中等气溶胶载量下，该关系是对光学波段广泛使用且科学合理的简化。\n- 基于多元正态类条件密度和共享协方差矩阵的贝叶斯决策理论，这是在反射率特征空间中进行线性判别分类的一个有效且经过充分检验的模型。您必须使用与此假设一致的贝叶斯分类器，但不得假设任何绕过基于此原理推导的简化公式。\n- 用于不确定性传播的蒙特卡洛采样。将大气参数视为具有给定分布的随机变量。生成独立样本，执行大气校正，进行分类，并计算地图精度的经验分布。\n\n您的程序必须从上述基本原理出发，实现以下内容：\n\n1. 大气校正。对于每次蒙特卡洛抽样，将大气参数 $\\,T_{R}\\,$, $\\,T_{N}\\,$, $\\,\\rho^{\\mathrm{path}}_{R}\\,$ 和 $\\,\\rho^{\\mathrm{path}}_{N}\\,$ 视为从指定分布中抽取的全景范围常数。对于每个像元 $\\,i\\,$ 和每个波段 $\\,b \\in \\{R,N\\}\\,$，使用物理上一致的反演公式 $\\,\\rho_{i,b} = (\\rho^{\\mathrm{TOA}}_{i,b} - \\rho^{\\mathrm{path}}_{b}) / T_{b}\\,$ 计算校正后的地表反射率，并通过裁剪将其约束在物理有效区间 $\\,[0,1]\\,$ 内。\n2. 分类。用二维特征向量 $\\,\\mathbf{x}_{i} = [\\rho_{i,R},\\,\\rho_{i,N}]^{\\top}\\,$ 表示每个像元。假设有三个作物类别，由 $\\,k \\in \\{0,1,2\\}\\,$ 索引，其类条件多元正态密度共享一个协方差矩阵。在每次蒙特卡洛抽样中，使用这些假设所蕴含的贝叶斯分类器（类别先验概率如下所述）为每个像元打上标签。\n3. 地图精度。对于每次蒙特卡洛抽样，计算总体精度 $\\,\\mathrm{OA}\\,$，即预测类别与所提供的地面真值标签相等的像元比例。在所有抽样中，报告 $\\,\\mathrm{OA}\\,$ 的经验 $\\,0.025\\,$ 和 $\\,0.975\\,$ 分位数，作为 $\\,95\\,\\%$-水平置信区间的下界和上界。将精度值表示为小数（例如，使用 $\\,0.92\\,$ 而不是百分比）。反射率是无单位的分数，因此不需要物理单位。\n\n在所有测试案例中使用以下固定的场景数据：\n- 像元数量 $\\,N = 12\\,$。\n- 波段：$\\,R\\,$（红光）和 $\\,N\\,$（近红外）。\n- 测得的 $\\,i=1,\\dots,12\\,$ 的大气层顶反射率 $\\,\\rho^{\\mathrm{TOA}}_{i,R}\\,$：$[\\,0.0938,\\,0.0902,\\,0.0965,\\,0.0920,\\,0.0749,\\,0.0722,\\,0.0767,\\,0.0740,\\,0.1091,\\,0.1127,\\,0.1073,\\,0.1109\\,]$。\n- 测得的 $\\,i=1,\\dots,12\\,$ 的大气层顶反射率 $\\,\\rho^{\\mathrm{TOA}}_{i,N}\\,$：$[\\,0.4444,\\,0.43965,\\,0.4501,\\,0.43585,\\,0.5394,\\,0.5356,\\,0.54415,\\,0.53275,\\,0.3969,\\,0.3931,\\,0.39975,\\,0.39025\\,]$。\n- 地面真值作物类别标签 $\\,y_{i}\\,$（对于 $\\,i=1,\\dots,12\\,$）：$[\\,0,\\,0,\\,0,\\,0,\\,1,\\,1,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2\\,]$。\n- 类别均值 $\\,\\boldsymbol{\\mu}_{0} = [\\,0.08,\\,0.45\\,]^{\\top}\\,$, $\\,\\boldsymbol{\\mu}_{1} = [\\,0.06,\\,0.55\\,]^{\\top}\\,$, $\\,\\boldsymbol{\\mu}_{2} = [\\,0.10,\\,0.40\\,]^{\\top}\\,$。\n- 共享协方差矩阵 $\\,\\boldsymbol{\\Sigma} = \\begin{bmatrix} 0.0004  0.0001 \\\\ 0.0001  0.0016 \\end{bmatrix}\\,$。该矩阵是对称正定的。\n- 类别先验概率 $\\,\\pi_{0} = \\pi_{1} = \\pi_{2} = 1/3\\,$。\n\n蒙特卡洛采样细节：\n- 对于每个测试案例，从具有指定均值和标准差的正态分布中，抽取 $\\,N_{s}\\,$ 个关于 $\\,T_{R}\\,$, $\\,T_{N}\\,$, $\\,\\rho^{\\mathrm{path}}_{R}\\,$ 和 $\\,\\rho^{\\mathrm{path}}_{N}\\,$ 的独立样本，然后将每次抽样裁剪到指定边界以保持物理合理性。每次抽样都被视为全景范围的，并应用于该次抽样中的所有像元。\n- 为保证可复现性，使用随机种子 $\\,42\\,$。\n- 计算 $\\,\\mathrm{OA}\\,$ 值集合的经验 $\\,0.025\\,$ 和 $\\,0.975\\,$ 分位数。\n\n测试套件：\n为以下四组参数集提供结果，每组代表一个不同的大气情景：\n- 案例 $\\,1\\,$（中等不确定性，典型气溶胶）：\n  - $\\,T_{R}\\,$ 均值 $\\,0.90\\,$, 标准差 $\\,0.03\\,$。\n  - $\\,T_{N}\\,$ 均值 $\\,0.95\\,$, 标准差 $\\,0.02\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ 均值 $\\,0.02\\,$, 标准差 $\\,0.005\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ 均值 $\\,0.015\\,$, 标准差 $\\,0.005\\,$。\n  - 边界：$\\,T_{R}, T_{N}\\,$ 裁剪到 $[\\,0.70,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ 裁剪到 $[\\,0.0,\\,0.10\\,]$。\n  - $\\,N_{s} = 5000\\,$。\n- 案例 $\\,2\\,$（更高气溶胶载量和不确定性）：\n  - $\\,T_{R}\\,$ 均值 $\\,0.85\\,$, 标准差 $\\,0.07\\,$。\n  - $\\,T_{N}\\,$ 均值 $\\,0.92\\,$, 标准差 $\\,0.05\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ 均值 $\\,0.03\\,$, 标准差 $\\,0.01\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ 均值 $\\,0.025\\,$, 标准差 $\\,0.01\\,$。\n  - 边界：$\\,T_{R}, T_{N}\\,$ 裁剪到 $[\\,0.60,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ 裁剪到 $[\\,0.0,\\,0.10\\,]$。\n  - $\\,N_{s} = 6000\\,$。\n- 案例 $\\,3\\,$（低不确定性，特征明确的大气）：\n  - $\\,T_{R}\\,$ 均值 $\\,0.90\\,$, 标准差 $\\,0.005\\,$。\n  - $\\,T_{N}\\,$ 均值 $\\,0.95\\,$, 标准差 $\\,0.005\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ 均值 $\\,0.02\\,$, 标准差 $\\,0.001\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ 均值 $\\,0.015\\,$, 标准差 $\\,0.001\\,$。\n  - 边界：$\\,T_{R}, T_{N}\\,$ 裁剪到 $[\\,0.80,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ 裁剪到 $[\\,0.0,\\,0.05\\,]$。\n  - $\\,N_{s} = 5000\\,$。\n- 案例 $\\,4\\,$（非常晴朗的大气，路径反射率小但非零）：\n  - $\\,T_{R}\\,$ 均值 $\\,0.98\\,$, 标准差 $\\,0.01\\,$。\n  - $\\,T_{N}\\,$ 均值 $\\,0.99\\,$, 标准差 $\\,0.01\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ 均值 $\\,0.005\\,$, 标准差 $\\,0.003\\,$。\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ 均值 $\\,0.005\\,$, 标准差 $\\,0.003\\,$。\n  - 边界：$\\,T_{R}, T_{N}\\,$ 裁剪到 $[\\,0.85,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ 裁剪到 $[\\,0.0,\\,0.02\\,]$。\n  - $\\,N_{s} = 4000\\,$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个元素应为一个双元素列表 $[\\,\\text{lower},\\,\\text{upper}\\,]$，给出相应测试案例的 $\\,\\mathrm{OA}\\,$ 的经验 $\\,95\\,\\%$-水平置信区间的下界和上界。例如，您的输出必须类似于 $[[l_{1},u_{1}],[l_{2},u_{2}],[l_{3},u_{3}],[l_{4},u_{4}]]$，并用数值替换。",
            "solution": "用户提供了一个有效且定义明确的问题。\n\n该问题要求实现一个蒙特卡洛模拟，以传播大气参数中的不确定性至一个遥感分析工作流中。该工作流包括大气校正，然后是监督式作物类型分类。最终输出是总体分类精度的 $95\\%$ 置信区间。解决方案被构建为一系列程序性步骤，每一步都基于既定的科学原理。\n\n首先，我们确定所提供的数据和参数。场景由 $N=12$ 个像元组成，每个像元都有在两个光谱波段——红光（$R$）和近红外（$N$）——测得的大气层顶反射率 $\\rho^{\\mathrm{TOA}}$。每个像元 $i$ 的地面真值类别标签 $y_i$ 是已知的。分类模型假设有三个作物类别（$k \\in \\{0,1,2\\}$），其类条件密度是二维多元正态分布，$p(\\mathbf{x}|C_k) \\sim \\mathcal{N}(\\boldsymbol{\\mu}_k, \\boldsymbol{\\Sigma})$，具有已知的均值 $\\boldsymbol{\\mu}_k$ 和一个共享的协方差矩阵 $\\boldsymbol{\\Sigma}$。类别先验概率 $\\pi_k$ 被给定为相等，即 $\\pi_0 = \\pi_1 = \\pi_2 = 1/3$。\n\n总体流程如下：\n$1$. 对于 $N_s$ 次蒙特卡洛模拟中的每一次，以及对于每个大气情景（测试案例），我们生成大气参数的随机样本。\n$2$. 在每次模拟中，使用这些参数对 $\\rho^{\\mathrm{TOA}}$ 数据进行大气校正，得到所有像元的地表反射率 $\\rho$。\n$3$. 然后使用从给定统计模型推导出的贝叶斯分类器对得到的地表反射率向量进行分类。\n$4$. 通过将预测标签与地面真值进行比较，计算分类图的总体精度（$\\mathrm{OA}$）。\n$5$. $N_s$ 个总体精度值构成了经验分布，从中计算出 $0.025$ 和 $0.975$ 分位数，以形成 $95\\%$ 的置信区间。\n\n下面提供了详细的、分步的推导和程序纲要。\n\n步骤1：大气参数的蒙特卡洛采样\n大气参数包括透射率（$T_R$, $T_N$）和路径反射率（$\\rho^{\\mathrm{path}}_R$, $\\rho^{\\mathrm{path}}_N$）。对于每个测试案例和 $N_s$ 次模拟中的每一次，都会抽取一组这四个参数。问题指定每个参数都从具有给定均值和标准差的正态分布中抽取，然后裁剪到指定的物理合理范围内。对于单次模拟运行 $s$，我们生成参数集 $\\{\\,T_{R}^{(s)}, T_{N}^{(s)}, \\rho^{\\mathrm{path},(s)}_{R}, \\rho^{\\mathrm{path},(s)}_{N}\\,\\}$。在同一次模拟运行中，此参数集对所有像元都是恒定的。为保证每个测试案例的可复现性，随机数生成器使用种子 $42$。\n\n步骤2：大气校正\n大气层顶反射率 $\\rho^{\\mathrm{TOA}}_{b}$ 与地表反射率 $\\rho_{b}$ 之间的关系由线性化模型 $\\rho^{\\mathrm{TOA}}_{b} = \\rho_{b}\\,T_{b} + \\rho^{\\mathrm{path}}_{b}$ 给出。为了求得地表反射率，我们必须反演此方程。对于每次模拟 $s$、每个像元 $i$ 和每个波段 $b \\in \\{R, N\\}$，地表反射率计算如下：\n$$\n\\rho^{(s)}_{i,b} = \\frac{\\rho^{\\mathrm{TOA}}_{i,b} - \\rho^{\\mathrm{path},(s)}_{b}}{T^{(s)}_{b}}\n$$\n反射率是通量之比，物理上必须被约束在区间 $[0, 1]$ 内。因此，计算出的值 $\\rho^{(s)}_{i,b}$ 被裁剪到此区间内。在模拟 $s$ 中，每个像元 $i$ 的校正后数据形成一个二维特征向量 $\\mathbf{x}^{(s)}_{i} = [\\rho^{(s)}_{i,R}, \\rho^{(s)}_{i,N}]^{\\top}$。\n\n步骤3：贝叶斯分类\n每个像元向量 $\\mathbf{x}$ 被分为 $K=3$ 个类别中的一个，这一过程使用贝叶斯决策规则，其目标是最小化错分概率。该规则是指定使后验概率 $P(C_k | \\mathbf{x})$ 最大的类别 $k$。\n$$\n\\hat{k} = \\arg\\max_{k \\in \\{0,1,2\\}} P(C_k | \\mathbf{x})\n$$\n使用贝叶斯定理，后验概率为 $P(C_k | \\mathbf{x}) = \\frac{p(\\mathbf{x} | C_k)P(C_k)}{p(\\mathbf{x})}$，其中 $p(\\mathbf{x} | C_k)$ 是类条件概率密度，$P(C_k) = \\pi_k$ 是类别先验概率，$p(\\mathbf{x})$ 是证据项 (evidence)。由于 $p(\\mathbf{x})$ 对所有类别都相同，因此在最大化过程中可以忽略它。最大化后验概率等价于最大化其对数：\n$$\n\\hat{k} = \\arg\\max_{k} \\left( \\ln p(\\mathbf{x} | C_k) + \\ln \\pi_k \\right)\n$$\n问题陈述中指出，类条件密度是具有共享协方差矩阵 $\\boldsymbol{\\Sigma}$ 的多元正态分布：\n$$\np(\\mathbf{x} | C_k) = \\frac{1}{(2\\pi)^{d/2} |\\boldsymbol{\\Sigma}|^{1/2}} \\exp\\left(-\\frac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu}_k)^\\top \\boldsymbol{\\Sigma}^{-1} (\\mathbf{x} - \\boldsymbol{\\mu}_k)\\right)\n$$\n其中 $d=2$ 是特征空间的维度。将此代入对数后验概率表达式中，得到判别函数 $g_k(\\mathbf{x})$：\n$$\ng_k(\\mathbf{x}) = -\\frac{1}{2}\\ln\\left((2\\pi)^{d}|\\boldsymbol{\\Sigma}|\\right) - \\frac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu}_k)^\\top \\boldsymbol{\\Sigma}^{-1} (\\mathbf{x} - \\boldsymbol{\\mu}_k) + \\ln \\pi_k\n$$\n在所有类别 $k$ 中都为常数的项可以从最大化过程中省略。这些项包括 $-\\frac{1}{2}\\ln\\left((2\\pi)^{d}|\\boldsymbol{\\Sigma}|\\right)$。展开二次型：\n$$\ng_k(\\mathbf{x}) = -\\frac{1}{2} \\left( \\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\mathbf{x} - 2\\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k + \\boldsymbol{\\mu}_k^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k \\right) + \\ln \\pi_k\n$$\n项 $-\\frac{1}{2}\\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\mathbf{x}$ 对所有类别也是公共的，可以省略。这导出一个简化的线性判别函数：\n$$\ng_k(\\mathbf{x}) = \\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k - \\frac{1}{2} \\boldsymbol{\\mu}_k^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k + \\ln \\pi_k\n$$\n此外，问题指定了相等的先验概率 $\\pi_k = 1/3$，因此 $\\ln \\pi_k$ 项也是常数，可以舍弃。最终的决策规则是将 $\\mathbf{x}$ 分类到使以下函数最大化的类别 $k$：\n$$\ng_k(\\mathbf{x}) = \\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k - \\frac{1}{2} \\boldsymbol{\\mu}_k^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k\n$$\n此函数为每个像元向量 $\\mathbf{x}^{(s)}_{i}$ 和每个类别 $k$ 进行计算，从而得到预测标签 $\\hat{y}^{(s)}_{i} = \\arg\\max_k g_k(\\mathbf{x}^{(s)}_{i})$。\n\n步骤4：总体精度计算\n对于每次蒙特卡洛模拟 $s$，总体精度 $\\mathrm{OA}^{(s)}$ 被计算为正确分类的像元比例。\n$$\n\\mathrm{OA}^{(s)} = \\frac{1}{N} \\sum_{i=1}^{N} I(\\hat{y}^{(s)}_{i} = y_i)\n$$\n其中 $N=12$ 是总像元数，$I(\\cdot)$ 是指示函数，如果其参数为真则为 $1$，否则为 $0$。\n\n步骤5：置信区间估计\n在对给定的测试案例运行所有 $N_s$ 次模拟后，我们得到一组精度值 $\\{\\mathrm{OA}^{(1)}, \\mathrm{OA}^{(2)}, \\dots, \\mathrm{OA}^{(N_s)}\\}$。这个集合代表了在给定大气参数不确定性模型下总体精度的经验概率分布。通过找到该分布的经验 $0.025$ 和 $0.975$ 分位数来确定 $95\\%$ 置信区间。这些分位数分别对应于置信区间的下界和上界。对问题陈述中指定的四个测试案例中的每一个都重复整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Propagates atmospheric parameter uncertainties through a remote sensing\n    classification workflow using Monte Carlo simulation to find confidence\n    intervals on overall map accuracy.\n    \"\"\"\n\n    # --- Fixed Scene Data ---\n    N_pixels = 12\n    rho_toa_r = np.array([0.0938, 0.0902, 0.0965, 0.0920, 0.0749, 0.0722, 0.0767, 0.0740, 0.1091, 0.1127, 0.1073, 0.1109])\n    rho_toa_n = np.array([0.4444, 0.43965, 0.4501, 0.43585, 0.5394, 0.5356, 0.54415, 0.53275, 0.3969, 0.3931, 0.39975, 0.39025])\n    # Shape: (N_pixels, 2) for [R, N] bands\n    rho_toa = np.stack([rho_toa_r, rho_toa_n], axis=1)\n\n    y_true = np.array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2], dtype=int)\n\n    # --- Classifier Parameters ---\n    mus = np.array([\n        [0.08, 0.45],  # Class 0\n        [0.06, 0.55],  # Class 1\n        [0.10, 0.40]   # Class 2\n    ])\n    Sigma = np.array([\n        [0.0004, 0.0001],\n        [0.0001, 0.0016]\n    ])\n    # Priors are equal, so log(pi_k) term can be dropped from discriminant.\n\n    # --- Pre-calculate parts of the linear discriminant function ---\n    # g_k(x) = x^T @ Sigma^-1 @ mu_k - 0.5 * mu_k^T @ Sigma^-1 @ mu_k\n    # Let W = mu_k @ Sigma^-1 (shape 3x2)\n    # Let W0 = -0.5 * diag(mu_k @ Sigma^-1 @ mu_k^T) (shape 3,)\n    # scores = x @ W.T + W0\n    inv_Sigma = np.linalg.inv(Sigma)\n    W = mus @ inv_Sigma  # Shape (3, 2)\n    W0 = -0.5 * np.sum((mus @ inv_Sigma) * mus, axis=1) # Shape (3,)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1\n        {'Ns': 5000,\n         'params': {\n             'T_R': {'mean': 0.90, 'std': 0.03, 'clip': [0.70, 1.00]},\n             'T_N': {'mean': 0.95, 'std': 0.02, 'clip': [0.70, 1.00]},\n             'rho_path_R': {'mean': 0.02, 'std': 0.005, 'clip': [0.0, 0.10]},\n             'rho_path_N': {'mean': 0.015, 'std': 0.005, 'clip': [0.0, 0.10]}\n         }},\n        # Case 2\n        {'Ns': 6000,\n         'params': {\n             'T_R': {'mean': 0.85, 'std': 0.07, 'clip': [0.60, 1.00]},\n             'T_N': {'mean': 0.92, 'std': 0.05, 'clip': [0.60, 1.00]},\n             'rho_path_R': {'mean': 0.03, 'std': 0.01, 'clip': [0.0, 0.10]},\n             'rho_path_N': {'mean': 0.025, 'std': 0.01, 'clip': [0.0, 0.10]}\n         }},\n        # Case 3\n        {'Ns': 5000,\n         'params': {\n             'T_R': {'mean': 0.90, 'std': 0.005, 'clip': [0.80, 1.00]},\n             'T_N': {'mean': 0.95, 'std': 0.005, 'clip': [0.80, 1.00]},\n             'rho_path_R': {'mean': 0.02, 'std': 0.001, 'clip': [0.0, 0.05]},\n             'rho_path_N': {'mean': 0.015, 'std': 0.001, 'clip': [0.0, 0.05]}\n         }},\n        # Case 4\n        {'Ns': 4000,\n         'params': {\n             'T_R': {'mean': 0.98, 'std': 0.01, 'clip': [0.85, 1.00]},\n             'T_N': {'mean': 0.99, 'std': 0.01, 'clip': [0.85, 1.00]},\n             'rho_path_R': {'mean': 0.005, 'std': 0.003, 'clip': [0.0, 0.02]},\n             'rho_path_N': {'mean': 0.005, 'std': 0.003, 'clip': [0.0, 0.02]}\n         }}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        Ns = case['Ns']\n        params = case['params']\n        \n        #\n        # For reproducibility, reset seed for each independent case\n        #\n        rng = np.random.default_rng(42)\n\n        #_ --- Step 1: Monte Carlo Sampling of Atmospheric Parameters ---\n        # Draw Ns samples for each of the 4 parameters\n        T_R_samples = rng.normal(params['T_R']['mean'], params['T_R']['std'], Ns)\n        T_N_samples = rng.normal(params['T_N']['mean'], params['T_N']['std'], Ns)\n        rho_path_R_samples = rng.normal(params['rho_path_R']['mean'], params['rho_path_R']['std'], Ns)\n        rho_path_N_samples = rng.normal(params['rho_path_N']['mean'], params['rho_path_N']['std'], Ns)\n\n        # Clip samples to physically plausible bounds\n        T_R_samples = np.clip(T_R_samples, params['T_R']['clip'][0], params['T_R']['clip'][1])\n        T_N_samples = np.clip(T_N_samples, params['T_N']['clip'][0], params['T_N']['clip'][1])\n        rho_path_R_samples = np.clip(rho_path_R_samples, params['rho_path_R']['clip'][0], params['rho_path_R']['clip'][1])\n        rho_path_N_samples = np.clip(rho_path_N_samples, params['rho_path_N']['clip'][0], params['rho_path_N']['clip'][1])\n\n        # Reshape for broadcasting: (Ns, 1, 2)\n        T_samples = np.stack([T_R_samples, T_N_samples], axis=1)[:, np.newaxis, :]\n        rho_path_samples = np.stack([rho_path_R_samples, rho_path_N_samples], axis=1)[:, np.newaxis, :]\n        \n        # --- Step 2: Atmospheric Correction (Vectorized) ---\n        # rho_toa shape (1, N_pixels, 2) for broadcasting\n        # Result rho_surf_all shape (Ns, N_pixels, 2)\n        rho_surf_all = (rho_toa[np.newaxis, :, :] - rho_path_samples) / T_samples\n        rho_surf_all = np.clip(rho_surf_all, 0.0, 1.0)\n        \n        # --- Step 3: Bayesian Classification (Vectorized) ---\n        # rho_surf_all (Ns, 12, 2) @ W.T (2, 3) -> scores_all (Ns, 12, 3)\n        # W0 (3,) is broadcast\n        scores_all = rho_surf_all @ W.T + W0\n        predicted_labels_all = np.argmax(scores_all, axis=2) # Shape (Ns, 12)\n        \n        # --- Step 4: Overall Accuracy Calculation (Vectorized) ---\n        # y_true (12,) is broadcast against predicted_labels_all (Ns, 12)\n        correct_classifications = (predicted_labels_all == y_true)\n        oa_samples = np.mean(correct_classifications, axis=1) # Shape (Ns,)\n\n        # --- Step 5: Confidence Interval Estimation ---\n        ci_bounds = np.quantile(oa_samples, [0.025, 0.975])\n        all_results.append(ci_bounds.tolist())\n\n    # Format the final output string exactly as specified\n    # e.g., \"[[l1,u1],[l2,u2]]\" with no spaces\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}