{
    "hands_on_practices": [
        {
            "introduction": "比较不同传感器数据的第一步，是将原始的数字量化值（Digital Numbers, DN）转换为一致的物理单位，例如光谱辐亮度。此过程依赖于每个传感器特定的辐射定标系数（增益 $G$ 和偏移 $O$），即使这些系数存在微小差异，也可能在传感器之间引入显著的偏差。该练习  旨在量化由不同定标参数直接导致的两个传感器间的辐射偏差，这是进行任何跨传感器数据协调工作的基本技能。",
            "id": "3804105",
            "problem": "两个星载推扫式辐射计，传感器A（参考）和传感器B（目标），在相同的观测和光照条件下，观测同一均匀、时间稳定的可见光波段地表目标。每个传感器记录一个数字量化值（DN），记为 $DN$，该值通过仿射辐射定标与大气顶层光谱辐亮度 $L_{\\lambda}$ 相关联，定标公式为 $L_{\\lambda} = G \\, DN + O$，其中 $G$ 和 $O$ 分别是波段特定的增益和偏移。假设目标为朗伯体，大气路径辐亮度和邻近效应可以忽略不计，两个传感器的波段光谱响应函数相同，且采集时间相同。\n\n观测和环境参数如下：\n- 记录的数字量化值：$DN = 500$。\n- 传感器A定标参数：$G_A = 0.105 \\mathrm{W m^{-2} sr^{-1} \\mu m^{-1} DN^{-1}}$，$O_A = -2.10 \\mathrm{W m^{-2} sr^{-1} \\mu m^{-1}}$。\n- 传感器B定标参数（定标不准）：$G_B = 0.102 \\mathrm{W m^{-2} sr^{-1} \\mu m^{-1} DN^{-1}}$，$O_B = -1.60 \\mathrm{W m^{-2} sr^{-1} \\mu m^{-1}}$。\n- 波段有效波长处的大气外太阳光谱辐照度：$E_{\\sun,\\lambda} = 1850 \\mathrm{W m^{-2} \\mu m^{-1}}$（定义在$1$个天文单位（AU）处）。\n- 日地距离：$d = 0.983$ AU。\n- 太阳天顶角：$\\theta_s = 30^\\circ$。\n\n任务：\n1) 仅使用给定的物理定义，计算传感器A和传感器B的 $L_{\\lambda}$。\n2) 使用大气顶层反射率的标准定义（即一个无量纲比率，通过经日地距离校正的地外太阳辐照度和太阳天顶角的余弦投影对辐亮度进行归一化），计算每个传感器的大气顶层反射率 $R_{\\mathrm{TOA}}$。\n3) 为了进行跨传感器协调，将传感器B定标不准引起的乘性偏差因子 $b$ 定义为比率 $b = R_{\\mathrm{TOA}}^{(B)} / R_{\\mathrm{TOA}}^{(A)}$。报告 $b$ 的值。\n\n将最终的乘性偏差因子 $b$ 表示为一个无量纲数，并将最终答案四舍五入至四位有效数字。太阳天顶角使用给定的单位“度”。",
            "solution": "该问题陈述在遥感和辐射定标领域内科学合理、内容完整且定义明确。它提供了计算唯一解所需的所有必要参数和定义。我们直接进行求解。\n\n解题过程分为三个部分，与问题中定义的任务相对应。\n\n第1步：计算大气顶层（TOA）光谱辐亮度 $L_{\\lambda}$\n\n传感器记录的数字量化值 $DN$ 与大气顶层光谱辐亮度 $L_{\\lambda}$ 之间的关系由标准线性定标模型给出：\n$$L_{\\lambda} = G \\cdot DN + O$$\n其中 $G$ 代表传感器的辐射增益，$O$ 代表其偏移量。问题指定两个传感器观测同一均匀目标时记录到的值为 $DN = 500$。\n\n对于传感器A，定标系数为 $G_A = 0.105$ 和 $O_A = -2.10$，单位分别为 $\\mathrm{W m^{-2} sr^{-1} \\mu m^{-1} DN^{-1}}$ 和 $\\mathrm{W m^{-2} sr^{-1} \\mu m^{-1}}$。传感器A测量的光谱辐亮度为：\n$$L_{\\lambda}^{(A)} = G_A \\cdot DN + O_A$$\n$$L_{\\lambda}^{(A)} = (0.105)(500) + (-2.10) = 52.5 - 2.10 = 50.4$$\n得到的辐亮度单位为 $\\mathrm{W m^{-2} sr^{-1} \\mu m^{-1}}$。\n\n对于传感器B，定标系数为 $G_B = 0.102$ 和 $O_B = -1.60$，单位相同。传感器B测量的光谱辐亮度为：\n$$L_{\\lambda}^{(B)} = G_B \\cdot DN + O_B$$\n$$L_{\\lambda}^{(B)} = (0.102)(500) + (-1.60) = 51.0 - 1.60 = 49.4$$\n得到的辐亮度单位也为 $\\mathrm{W m^{-2} sr^{-1} \\mu m^{-1}}$。\n\n第2步：大气顶层（TOA）反射率 $R_{\\mathrm{TOA}}$ 的公式推导\n\n问题将大气顶层反射率 $R_{\\mathrm{TOA}}$ 定义为一个无量纲量，用于对测量的光谱辐亮度进行归一化。具体来说，它是观测到的辐亮度 $L_{\\lambda}$ 与在相同光照条件下，一个理想的、完美的朗伯表面（100%反射）所反射的辐亮度之比。\n\n大气顶层的入射太阳光谱辐照度是大气外太阳光谱辐照度 $E_{\\sun,\\lambda}$ 根据与日地距离 $d$ 的平方反比关系进行校正后的值。垂直于太阳光线的表面上的辐照度为 $E_{\\sun,\\lambda} / d^2$。大气顶层水平面上的辐照度是该值乘以太阳天顶角 $\\theta_s$ 的余弦投影：\n$$E_{\\mathrm{TOA}} = \\frac{E_{\\sun,\\lambda} \\cos(\\theta_s)}{d^2}$$\n对于一个完美的朗伯反射体，出射辐亮度在整个半球（$2\\pi$ 球面度立体角）内均匀分布，反射出射度（对于完美反射体，其值等于入射辐照度）与辐亮度之间的关系是 $E = \\pi L$。因此，来自这个理想表面的辐亮度为：\n$$L_{\\lambda, \\mathrm{perfect}} = \\frac{E_{\\mathrm{TOA}}}{\\pi} = \\frac{E_{\\sun,\\lambda} \\cos(\\theta_s)}{\\pi d^2}$$\n大气顶层反射率是观测到的辐亮度与这个理想辐亮度之比：\n$$R_{\\mathrm{TOA}} = \\frac{L_{\\lambda}}{L_{\\lambda, \\mathrm{perfect}}} = \\frac{L_{\\lambda}}{\\left(\\frac{E_{\\sun,\\lambda} \\cos(\\theta_s)}{\\pi d^2}\\right)} = \\frac{\\pi L_{\\lambda} d^2}{E_{\\sun,\\lambda} \\cos(\\theta_s)}$$\n给定的参数为 $d=0.983$，$E_{\\sun,\\lambda} = 1850 \\mathrm{W m^{-2} \\mu m^{-1}}$，以及 $\\theta_s = 30^\\circ$。虽然我们可以计算 $R_{\\mathrm{TOA}}^{(A)}$ 和 $R_{\\mathrm{TOA}}^{(B)}$，但这对于最后一步并非必要。\n\n第3步：计算乘性偏差因子 $b$\n\n由传感器B定标不准引起的乘性偏差因子 $b$ 定义为从传感器B导出的TOA反射率与从传感器A导出的TOA反射率之比：\n$$b = \\frac{R_{\\mathrm{TOA}}^{(B)}}{R_{\\mathrm{TOA}}^{(A)}}$$\n将 $R_{\\mathrm{TOA}}$ 的完整表达式代入此比率：\n$$b = \\frac{\\left(\\frac{\\pi L_{\\lambda}^{(B)} d^2}{E_{\\sun,\\lambda} \\cos(\\theta_s)}\\right)}{\\left(\\frac{\\pi L_{\\lambda}^{(A)} d^2}{E_{\\sun,\\lambda} \\cos(\\theta_s)}\\right)}$$\n由于观测是在相同条件下对同一目标进行的，因此与日地距离（$d$）、太阳辐照度（$E_{\\sun,\\lambda}$）和太阳天顶角（$\\theta_s$）相关的项，以及常数 $\\pi$，在分子和分母中都是共有的。这些项可以消去，从而得到一个更简单的偏差因子表达式：\n$$b = \\frac{L_{\\lambda}^{(B)}}{L_{\\lambda}^{(A)}}$$\n这表明，对于这种偏差的特定定义，它就是传感器接收到的辐亮度之比。使用第1步中计算的值：\n$$b = \\frac{49.4}{50.4}$$\n进行除法运算：\n$$b \\approx 0.98015873...$$\n问题要求将结果四舍五入到四位有效数字。\n$$b \\approx 0.9802$$\n这个无量纲因子表示，为了使传感器B的反射率值与传感器A在此特定辐亮度水平上协调一致，需要应用的乘性校正系数。",
            "answer": "$$\\boxed{0.9802}$$"
        },
        {
            "introduction": "在将数据转换为通用辐射度量（如反射率）后，我们必须处理由观测几何差异引起的变化。同一地物会因太阳位置和传感器视角的不同而显得更亮或更暗，这种方向性效应由双向反射分布函数（Bidirectional Reflectance Distribution Function, BRDF）描述。此练习  演示了如何应用一个标准的BRDF模型，将一个传感器的反射率归一化到另一个传感器的几何条件下，这是从多源数据创建无缝数据产品的关键一步。",
            "id": "3804144",
            "problem": "给定分别对应于 Landsat 和 Sentinel-2 的两种卫星观测几何，用于同一地表目标，以及一个半经验双向反射分布函数 (BRDF) 参数化方案。任务是估算所需的加性 BRDF 校正量，以便使用核驱动模型将 Landsat 测量的地表反射率协调到 Sentinel-2 的观测和光照几何条件下。这种协调是跨传感器辐射归一化的一部分。\n\n基本原理和定义：\n- 双向反射分布函数 (BRDF) $f_r(\\theta_s,\\theta_v,\\phi)$ 表征了地表反射率的方向依赖性，其中 $\\theta_s$ 是太阳天顶角，$\\theta_v$ 是观测天顶角，$\\phi$ 是太阳和观测方向之间的相对方位角。\n- 在核驱动线性 BRDF 模型中，给定几何条件 $(\\theta_s,\\theta_v,\\phi)$ 下的地表反射率因子 $R$ 近似为\n$$\nR(\\theta_s,\\theta_v,\\phi) = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s,\\theta_v,\\phi),\n$$\n其中 $f_{\\text{iso}}$ 是各向同性（朗伯）系数，$f_{\\text{vol}}$ 是体散射系数。体散射核 $K_{\\text{vol}}$ 采用 Ross–Thick 核：\n$$\n\\cos \\xi = \\cos \\theta_s \\cos \\theta_v + \\sin \\theta_s \\sin \\theta_v \\cos \\phi,\n$$\n$$\n\\xi = \\arccos(\\cos \\xi),\n$$\n$$\nK_{\\text{vol}}(\\theta_s,\\theta_v,\\phi) = \\left(\\frac{\\pi}{2} - \\xi\\right)\\cos \\xi + \\sin \\xi - \\frac{\\pi}{4}.\n$$\n该核源于将球面余弦定理应用于太阳与观测方向之间的相角 $\\xi$，并广泛用于模拟植被冠层中的体散射。\n\n目标：\n- 对于每个测试用例，通过对 Landsat 测量的反射率 $R^{L}_{\\text{meas}}$ 应用加性 BRDF 校正，将其转换到 Sentinel-2 的几何条件下，计算协调后的反射率 $R^{\\text{harm}}$。利用各向同性项 $f_{\\text{iso}}$ 与几何无关，而各向异性（体散射）依赖性由 $K_{\\text{vol}}$ 捕捉这一事实。\n\n输入和单位：\n- 角度 $\\theta_s$、$\\theta_v$ 和 $\\phi$ 以度为单位提供。使用 $\\text{弧度} = \\text{度} \\times \\pi/180$ 将度转换为弧度。\n- 反射率是无量纲比值，必须表示为小数。\n- 最终协调后的反射率值必须报告为浮点数，并四舍五入到 $6$ 位小数。\n\n计算要求：\n- 对于每个具有 Landsat 几何 $(\\theta_s^L,\\theta_v^L,\\phi^L)$、Sentinel-2 几何 $(\\theta_s^S,\\theta_v^S,\\phi^S)$、系数 $(f_{\\text{iso}}, f_{\\text{vol}})$ 和 Landsat 测量反射率 $R_{\\text{meas}}^{L}$ 的测试用例，计算：\n  1. $K_{\\text{vol}}^L = K_{\\text{vol}}(\\theta_s^L,\\theta_v^L,\\phi^L)$,\n  2. $K_{\\text{vol}}^S = K_{\\text{vol}}(\\theta_s^S,\\theta_v^S,\\phi^S)$,\n  3. $R_{\\text{model}}^L = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}^L$,\n  4. $R_{\\text{model}}^S = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}^S$,\n  5. $R^{\\text{harm}} = R_{\\text{meas}}^{L} + (R_{\\text{model}}^S - R_{\\text{model}}^L)$.\n\n测试套件：\n为以下五个测试用例提供计算。所有角度均以度为单位，反射率为无量纲：\n\n- 测试用例 $1$ (一般情况): $\\theta_s^L = 30$, $\\theta_v^L = 7$, $\\phi^L = 20$; $\\theta_s^S = 32$, $\\theta_v^S = 5$, $\\phi^S = 25$; $f_{\\text{iso}} = 0.05$, $f_{\\text{vol}} = 0.10$; $R_{\\text{meas}}^{L} = 0.18$.\n- 测试用例 $2$ (边界情况，几何形状相同): $\\theta_s^L = 35$, $\\theta_v^L = 10$, $\\phi^L = 60$; $\\theta_s^S = 35$, $\\theta_v^S = 10$, $\\phi^S = 60$; $f_{\\text{iso}} = 0.03$, $f_{\\text{vol}} = 0.08$; $R_{\\text{meas}}^{L} = 0.20$.\n- 测试用例 $3$ (边缘情况，天底 vs 离天底): $\\theta_s^L = 10$, $\\theta_v^L = 20$, $\\phi^L = 180$; $\\theta_s^S = 10$, $\\theta_v^S = 0$, $\\phi^S = 180$; $f_{\\text{iso}} = 0.04$, $f_{\\text{vol}} = 0.12$; $R_{\\text{meas}}^{L} = 0.10$.\n- 测试用例 $4$ (边缘情况，大太阳天顶角): $\\theta_s^L = 70$, $\\theta_v^L = 15$, $\\phi^L = 120$; $\\theta_s^S = 65$, $\\theta_vS = 10$, $\\phi^S = 100$; $f_{\\text{iso}} = 0.06$, $f_{\\text{vol}} = 0.09$; $R_{\\text{meas}}^{L} = 0.15$.\n- 测试用例 $5$ (边缘情况，极端相对方位角变化): $\\theta_s^L = 45$, $\\theta_v^L = 10$, $\\phi^L = 0$; $\\theta_s^S = 45$, $\\theta_v^S = 10$, $\\phi^S = 180$; $f_{\\text{iso}} = 0.05$, $f_{\\text{vol}} = 0.11$; $R_{\\text{meas}}^{L} = 0.22$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的协调反射率结果，格式为方括号内以逗号分隔的列表，每个值四舍五入到 $6$ 位小数（例如，$\\text{[result1,result2,result3,result4,result5]}$）。",
            "solution": "问题陈述已经过仔细验证，并被确定为有效。它在科学上基于遥感和辐射传输的原理，特别利用了公认的 Ross–Thick 核来模拟地表反射率的各向异性。该问题是适定的，提供了所有必要的数据、定义和计算步骤，确保每个测试用例都存在唯一且可验证的解。物理参数和情景对于卫星地球观测是现实的。\n\n目标是计算 BRDF（双向反射分布函数）校正，以将 Landsat 传感器测量的地表反射率 ($R_{\\text{meas}}^{L}$) 协调到 Sentinel-2 传感器的观测和光照几何条件下。这是通过使用一个简化的线性核驱动 BRDF 模型来实现的。\n\n该模型将地表反射率因子 $R$ 近似为各向同性分量和体散射分量之和：\n$$\nR(\\theta_s, \\theta_v, \\phi) = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s, \\theta_v, \\phi)\n$$\n这里，$f_{\\text{iso}}$ 是各向同性散射系数，代表朗伯反射；$f_{\\text{vol}}$ 是体散射系数，它对体散射核 $K_{\\text{vol}}$ 的贡献进行加权。角度 $\\theta_s$、$\\theta_v$ 和 $\\phi$ 分别代表太阳天顶角、观测天顶角和相对方位角。\n\n体散射由 Ross–Thick 核描述，该核源自均质植被冠层的辐射传输理论。其公式取决于光照和观测矢量之间的相角 $\\xi$。相角的余弦由球面余弦定理给出：\n$$\n\\cos \\xi = \\cos \\theta_s \\cos \\theta_v + \\sin \\theta_s \\sin \\theta_v \\cos \\phi\n$$\n相角 $\\xi$ 则是 $\\xi = \\arccos(\\cos \\xi)$。然后，Ross–Thick 核 $K_{\\text{vol}}$ 计算如下：\n$$\nK_{\\text{vol}}(\\theta_s,\\theta_v,\\phi) = \\left(\\frac{\\pi}{2} - \\xi\\right)\\cos \\xi + \\sin \\xi - \\frac{\\pi}{4}\n$$\n所有角度输入均以度为单位，必须通过关系式 $\\text{弧度} = \\text{度} \\times (\\pi / 180)$ 转换为弧度，以便在三角函数中使用。\n\n协调过程基于加性校正。核心假设是，即使模型不能完美预测absolute reflectance，它也能准确捕捉由于几何条件变化引起的反射率*变化*。协调后的反射率 $R^{\\text{harm}}$ 是通过用 Sentinel-2 几何条件和 Landsat 几何条件下的模型反射率之差来调整测量的 Landsat 反射率 $R_{\\text{meas}}^{L}$ 计算得出的。\n设 Landsat 和 Sentinel-2 的几何条件分别为 $(\\theta_s^L, \\theta_v^L, \\phi^L)$ 和 $(\\theta_s^S, \\theta_v^S, \\phi^S)$。每种几何条件的模型预测反射率为：\n$$\nR_{\\text{model}}^L = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s^L, \\theta_v^L, \\phi^L)\n$$\n$$\nR_{\\text{model}}^S = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s^S, \\theta_v^S, \\phi^S)\n$$\n则协调后的反射率由下式给出：\n$$\nR^{\\text{harm}} = R_{\\text{meas}}^{L} + (R_{\\text{model}}^S - R_{\\text{model}}^L)\n$$\n通过代入模型方程，我们可以简化此表达式。各向同性项 $f_{\\text{iso}}$ 与几何无关，因此被消去：\n$$\nR^{\\text{harm}} = R_{\\text{meas}}^{L} + (f_{\\text{iso}} + f_{\\text{vol}}K_{\\text{vol}}^S) - (f_{\\text{iso}} + f_{\\text{vol}}K_{\\text{vol}}^L)\n$$\n$$\nR^{\\text{harm}} = R_{\\text{meas}}^{L} + f_{\\text{vol}}(K_{\\text{vol}}^S - K_{\\text{vol}}^L)\n$$\n这个简化的公式在计算上更直接，并用于求解。每个测试用例的步骤如下：\n1.  对于给定的 Landsat 几何条件 $(\\theta_s^L, \\theta_v^L, \\phi^L)$，计算核值 $K_{\\text{vol}}^L$。\n2.  对于给定的 Sentinel-2 几何条件 $(\\theta_s^S, \\theta_v^S, \\phi^S)$，计算核值 $K_{\\text{vol}}^S$。\n3.  使用提供的系数 $f_{\\text{vol}}$ 和测量的 Landsat 反射率 $R_{\\text{meas}}^L$，使用上述简化公式计算协调后的反射率 $R^{\\text{harm}}$。\n4.  根据要求将最终结果四舍五入到 $6$ 位小数。\n此过程将系统地应用于所提供的五个测试用例中的每一个。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the harmonized surface reflectance for a series of test cases based on a kernel-driven BRDF model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: ((theta_s_L, theta_v_L, phi_L), (theta_s_S, theta_v_S, phi_S), f_iso, f_vol, R_meas_L)\n    test_cases = [\n        # Test case 1 (general case)\n        ((30, 7, 20), (32, 5, 25), 0.05, 0.10, 0.18),\n        # Test case 2 (boundary, identical geometries)\n        ((35, 10, 60), (35, 10, 60), 0.03, 0.08, 0.20),\n        # Test case 3 (edge, nadir vs off-nadir)\n        ((10, 20, 180), (10, 0, 180), 0.04, 0.12, 0.10),\n        # Test case 4 (edge, large solar zenith)\n        ((70, 15, 120), (65, 10, 100), 0.06, 0.09, 0.15),\n        # Test case 5 (edge, extreme relative azimuth change)\n        ((45, 10, 0), (45, 10, 180), 0.05, 0.11, 0.22),\n    ]\n\n    def calculate_k_vol(theta_s_deg, theta_v_deg, phi_deg):\n        \"\"\"\n        Calculates the Ross–Thick volumetric kernel K_vol.\n\n        Args:\n            theta_s_deg (float): Solar zenith angle in degrees.\n            theta_v_deg (float): View zenith angle in degrees.\n            phi_deg (float): Relative azimuth angle in degrees.\n\n        Returns:\n            float: The value of the K_vol kernel.\n        \"\"\"\n        # Convert degrees to radians\n        theta_s = np.deg2rad(theta_s_deg)\n        theta_v = np.deg2rad(theta_v_deg)\n        phi = np.deg2rad(phi_deg)\n\n        # Calculate the cosine of the phase angle (xi)\n        cos_xi = np.cos(theta_s) * np.cos(theta_v) + np.sin(theta_s) * np.sin(theta_v) * np.cos(phi)\n        \n        # Clamp cos_xi to the valid range [-1, 1] for arccos to avoid floating point issues\n        cos_xi = np.clip(cos_xi, -1.0, 1.0)\n        \n        # Calculate the phase angle (xi)\n        xi = np.arccos(cos_xi)\n\n        # Calculate the Ross–Thick kernel as defined in the problem\n        k_vol = (np.pi / 2 - xi) * cos_xi + np.sin(xi) - (np.pi / 4)\n        \n        return k_vol\n\n    results = []\n    for case in test_cases:\n        geom_L, geom_S, f_iso, f_vol, R_meas_L = case\n        theta_s_L, theta_v_L, phi_L = geom_L\n        theta_s_S, theta_v_S, phi_S = geom_S\n\n        # 1. Compute K_vol for Landsat geometry\n        k_vol_L = calculate_k_vol(theta_s_L, theta_v_L, phi_L)\n        \n        # 2. Compute K_vol for Sentinel-2 geometry\n        k_vol_S = calculate_k_vol(theta_s_S, theta_v_S, phi_S)\n        \n        # 3. Compute the harmonized reflectance R_harm\n        # R_harm = R_meas_L + (R_model_S - R_model_L)\n        # R_harm = R_meas_L + (f_iso + f_vol*k_vol_S) - (f_iso + f_vol*k_vol_L)\n        # This simplifies to:\n        r_harm = R_meas_L + f_vol * (k_vol_S - k_vol_L)\n        \n        results.append(r_harm)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    # The original code has a print statement, we just need the calculation.\n    return f\"[{','.join(formatted_results)}]\"\n\n# This part is just for execution and won't be in the final XML.\n# print(solve())\n```",
            "answer": "$$\n\\boxed{[0.178734, 0.200000, 0.111867, 0.147171, 0.202353]}\n$$"
        },
        {
            "introduction": "数据协调中的最后一个主要挑战是，不同传感器的光谱响应函数（Spectral Response Functions, SRFs）各不相同，这意味着即使在完全相同的几何条件下观测同一目标，它们记录的反射率值也可能不同。通过使用一组代表性的地表反射光谱（例如，来自植被、土壤等），我们可以建立一个统计模型（通常是线性回归），将一个传感器波段的反射率映射到另一个。这项高级实践  提供了开发和评估光谱波段调整模型的动手经验，这对于从多个卫星任务中生成科学上稳健、可直接分析的数据至关重要。",
            "id": "3804157",
            "problem": "给定两种离散波段遥感仪器，其光谱响应函数（SRF）已知，以及一组物理上合理的表面反射光谱。目标是计算跨传感器反射率映射，并评估在多种场景下植被和土壤的按类别偏差。使用以下基本原理来推导计算。\n\n由一个波段有限、光谱响应函数为 $S(\\lambda)$ 的传感器在入射光谱辐照度为 $I(\\lambda)$ 的条件下观测一个光谱反射率为 $\\rho(\\lambda)$ 的表面时，所测得的辐亮度与 $I(\\lambda)\\rho(\\lambda)$ 在波长上由 $S(\\lambda)$ 加权的积分成正比。因此，传感器 $X$ 的有效波段反射率定义为加权平均值\n$$\nR_X = \\frac{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} \\rho(\\lambda) S_X(\\lambda) I(\\lambda) \\, d\\lambda}{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} S_X(\\lambda) I(\\lambda) \\, d\\lambda}.\n$$\n对于两个传感器 $A$ 和 $B$，定义一个线性跨传感器映射 $R_B \\approx \\alpha R_A + \\beta$。通过最小化训练光谱集上的残差平方和，从一个反射光谱训练集中确定映射系数 $\\alpha$ 和 $\\beta$。然后，对于两个类别（植被和土壤）的评估光谱，计算偏差 $b = \\hat{R}_B - R_B$，其中 $\\hat{R}_B = \\alpha R_A + \\beta$ 是从传感器 $A$ 映射到传感器 $B$ 的反射率。\n\n除了波长（必须以纳米表示）外，所有量纲均为无量纲。此问题中没有角度量。最终输出应为按类别划分的偏差，这些是无量纲数。使用波长范围为 $\\lambda \\in [400,900]$ 纳米、分辨率为 $1$ 纳米的波长网格。积分的近似必须在此网格上使用梯形法则进行数值计算。\n\n缩写定义：\n- 光谱响应函数 (SRF): $S(\\lambda)$，传感器作为波长函数的相对灵敏度。\n- 太阳辐照度 (SI): $I(\\lambda)$，到达表面的入射光谱辐照度。\n\n传感器 SRF 和辐照度使用高斯参数形式定义：\n- 传感器 $X \\in \\{A,B\\}$ 的 SRF: $S_X(\\lambda) \\propto \\exp\\!\\left(-\\frac{(\\lambda-\\mu_X)^2}{2\\sigma_X^2}\\right)$，归一化后使其在网格上的离散积分为 $1$。\n- 辐照度: $I(\\lambda) = \\exp\\!\\left(-\\frac{(\\lambda-\\mu_I)^2}{2\\sigma_I^2}\\right)$。\n\n反射光谱使用以下参数函数定义，每个函数的值都被截断到区间 $[0,1]$ 内：\n- 植被:\n$$\n\\rho_{\\text{veg}}(\\lambda; \\lambda_0, s, a_g) = 0.05 + \\frac{0.45}{1+\\exp\\!\\left(-\\frac{\\lambda-\\lambda_0}{s}\\right)} + a_g \\exp\\!\\left(-\\frac{(\\lambda-550)^2}{2\\cdot 30^2}\\right).\n$$\n- 土壤:\n$$\n\\rho_{\\text{soil}}(\\lambda; a, b, a_c) = a + b(\\lambda-400) + a_c \\exp\\!\\left(-\\frac{(\\lambda-700)^2}{2\\cdot 150^2}\\right).\n$$\n- 平坦（恒定反射率）:\n$$\n\\rho_{\\text{flat}}(\\lambda; c) = c.\n$$\n\n对于下面的每个测试用例，你必须：\n1. 根据给定参数构建 $S_A(\\lambda)$、$S_B(\\lambda)$ 和 $I(\\lambda)$。\n2. 构建训练反射光谱，并为每个训练光谱计算 $R_A$ 和 $R_B$。\n3. 通过在训练集上最小化 $\\sum_i \\left(\\alpha R_{A,i} + \\beta - R_{B,i}\\right)^2$ 来求解 $\\alpha$ 和 $\\beta$。\n4. 构建植被和土壤的评估光谱，并使用 $b = \\alpha R_A + \\beta - R_B$ 计算 $b_{\\text{veg}}$ 和 $b_{\\text{soil}}$。\n\n使用以下三个测试用例。在所有情况下，$\\lambda \\in [400,900]$ 纳米，间距为 $1$ 纳米，并使用梯形积分。\n\n测试用例 1（理想情况；红波段对齐，存在中度不匹配）：\n- 辐照度参数: $\\mu_I = 550$ 纳米, $\\sigma_I = 130$ 纳米。\n- 传感器 A SRF 参数: $\\mu_A = 650$ 纳米, $\\sigma_A = 20$ 纳米。\n- 传感器 B SRF 参数: $\\mu_B = 660$ 纳米, $\\sigma_B = 25$ 纳米。\n- 训练反射光谱:\n    - 植被 1: $\\lambda_0 = 700$ 纳米, $s = 20$ 纳米, $a_g = 0.08$。\n    - 植被 2: $\\lambda_0 = 710$ 纳米, $s = 15$ 纳米, $a_g = 0.10$。\n    - 土壤 1: $a = 0.12$, $b = 1.5\\times 10^{-4}$ 每纳米, $a_c = -0.02$。\n    - 土壤 2: $a = 0.18$, $b = 1.0\\times 10^{-4}$ 每纳米, $a_c = 0.015$。\n- 评估反射光谱:\n    - 植被评估: $\\lambda_0 = 705$ 纳米, $s = 18$ 纳米, $a_g = 0.09$。\n    - 土壤评估: $a = 0.14$, $b = 1.4\\times 10^{-4}$ 每纳米, $a_c = -0.01$。\n\n测试用例 2（边界条件；绿波段对齐）：\n- 辐照度参数: $\\mu_I = 560$ 纳米, $\\sigma_I = 100$ 纳米。\n- 传感器 A SRF 参数: $\\mu_A = 550$ 纳米, $\\sigma_A = 30$ 纳米。\n- 传感器 B SRF 参数: $\\mu_B = 560$ 纳米, $\\sigma_B = 30$ 纳米。\n- 训练反射光谱:\n    - 植被 1: $\\lambda_0 = 690$ 纳米, $s = 25$ 纳米, $a_g = 0.12$。\n    - 植被 2: $\\lambda_0 = 695$ 纳米, $s = 22$ 纳米, $a_g = 0.09$。\n    - 土壤 1: $a = 0.10$, $b = 2.0\\times 10^{-4}$ 每纳米, $a_c = -0.02$。\n    - 土壤 2: $a = 0.20$, $b = 1.5\\times 10^{-4}$ 每纳米, $a_c = 0.01$。\n- 评估反射光谱:\n    - 植被评估: $\\lambda_0 = 692$ 纳米, $s = 20$ 纳米, $a_g = 0.11$。\n    - 土壤评估: $a = 0.12$, $b = 1.8\\times 10^{-4}$ 每纳米, $a_c = -0.015$。\n\n测试用例 3（边缘情况；窄SRF与宽SRF的红波段，并在训练中包含平坦光谱）：\n- 辐照度参数: $\\mu_I = 650$ 纳米, $\\sigma_I = 120$ 纳米。\n- 传感器 A SRF 参数: $\\mu_A = 680$ 纳米, $\\sigma_A = 10$ 纳米。\n- 传感器 B SRF 参数: $\\mu_B = 680$ 纳米, $\\sigma_B = 40$ 纳米。\n- 训练反射光谱:\n    - 植被 1: $\\lambda_0 = 700$ 纳米, $s = 12$ 纳米, $a_g = 0.08$。\n    - 植被 2: $\\lambda_0 = 710$ 纳米, $s = 10$ 纳米, $a_g = 0.07$。\n    - 土壤 1: $a = 0.15$, $b = 1.0\\times 10^{-4}$ 每纳米, $a_c = -0.01$。\n    - 平坦 1: $c = 0.30$。\n    - 平坦 2: $c = 0.50$。\n- 评估反射光谱:\n    - 植被评估: $\\lambda_O = 705$ 纳米, $s = 10$ 纳米, $a_g = 0.09$。\n    - 土壤评估: $a = 0.13$, $b = 1.0\\times 10^{-4}$ 每纳米, $a_c = -0.005$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[b_{\\text{veg, case 1}}, b_{\\text{soil, case 1}}, b_{\\text{veg, case 2}}, b_{\\text{soil, case 2}}, b_{\\text{veg, case 3}}, b_{\\text{soil, case 3}}].\n$$\n所有条目必须是十进制数。不应打印任何单位。",
            "solution": "该问题要求计算跨传感器一致化系数，并随后评估特定类别的偏差。解决方案源自辐射度学第一性原理和统计回归，并进行数值实现。\n\n基本量是传感器 $X$ 的有效波段反射率 $R_X$。它被定义为表面反射率 $\\rho(\\lambda)$ 的光谱加权平均值，其中权重函数是传感器的光谱响应函数（SRF）$S_X(\\lambda)$ 和入射太阳辐照度 $I(\\lambda)$ 的乘积。形式化定义如下：\n$$\nR_X = \\frac{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} \\rho(\\lambda) S_X(\\lambda) I(\\lambda) \\, d\\lambda}{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} S_X(\\lambda) I(\\lambda) \\, d\\lambda}\n$$\n问题规定，所有积分必须在从 $400$ nm到 $900$ nm、间距为 $\\Delta\\lambda = 1$ nm的离散波长网格 $\\lambda$ 上，使用梯形法则进行数值近似。\n\n首先，我们必须为每个测试用例构建必要的光谱函数。\n入射辐照度 $I(\\lambda)$ 建模为高斯函数：\n$$\nI(\\lambda) = \\exp\\!\\left(-\\frac{(\\lambda-\\mu_I)^2}{2\\sigma_I^2}\\right)\n$$\n传感器 $A$ 和 $B$ 的SRF，$S_A(\\lambda)$ 和 $S_B(\\lambda)$，也建模为高斯函数。一个关键步骤是归一化。问题指出，SRF在波长网格上的离散积分必须等于 $1$。我们首先计算未归一化的SRF，$S'_X(\\lambda) \\propto \\exp\\!\\left(-\\frac{(\\lambda-\\mu_X)^2}{2\\sigma_X^2}\\right)$，然后计算其梯形积分 $C_X = \\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} S'_X(\\lambda) d\\lambda$。归一化后的SRF则为 $S_X(\\lambda) = S'_X(\\lambda) / C_X$。这确保了 $S_X(\\lambda)$ 在波长网格上作为一个合适的概率密度函数，从而防止引入任意的比例因子。\n\n表面反射光谱 $\\rho(\\lambda)$ 由植被、土壤和平坦表面的参数模型给出。例如，植被模型是：\n$$\n\\rho_{\\text{veg}}(\\lambda; \\lambda_0, s, a_g) = 0.05 + \\frac{0.45}{1+\\exp\\!\\left(-\\frac{\\lambda-\\lambda_0}{s}\\right)} + a_g \\exp\\!\\left(-\\frac{(\\lambda-550)^2}{2\\cdot 30^2}\\right)\n$$\n由于反射率是反射通量与入射通量之比，其值必须在物理上被限制在区间 $[0,1]$ 内。因此，在从参数函数计算出值之后，我们将得到的反射光谱向量截断，使其位于此范围内。\n\n定义了这些函数后，我们可以通过使用梯形法则对分子 $\\rho(\\lambda) S_X(\\lambda) I(\\lambda)$ 和分母 $S_X(\\lambda) I(\\lambda)$ 进行数值积分，然后计算它们的比值，来计算任何给定表面 $\\rho(\\lambda)$ 的波段平均反射率 $R_X$。\n\n下一步是确定线性跨传感器映射 $R_B \\approx \\alpha R_A + \\beta$。系数 $\\alpha$（斜率）和 $\\beta$（截距）通过在一组 $N$ 个训练光谱上最小化残差平方和来找到：\n$$\n\\text{minimize} \\sum_{i=1}^{N} \\left( (\\alpha R_{A,i} + \\beta) - R_{B,i} \\right)^2\n$$\n这是一个标准的普通最小二乘法（OLS）线性回归问题。我们可以用矩阵形式来表述。设 $\\mathbf{y}$ 为目标反射率 $\\{R_{B,i}\\}$ 的 $N \\times 1$ 列向量，$\\mathbf{M}$ 为 $N \\times 2$ 的设计矩阵，其中第一列是预测变量反射率 $\\{R_{A,i}\\}$ 的向量，第二列是元素全为1的向量。设 $\\mathbf{c} = [\\alpha, \\beta]^T$ 为系数向量。OLS问题是在最小二乘意义上求解线性系统 $\\mathbf{M}\\mathbf{c} = \\mathbf{y}$。一个数值稳定且鲁棒的方法是使用像 `numpy.linalg.lstsq` 这样的函数，它通常采用QR分解或SVD。\n\n从训练集获得映射系数 $\\alpha$ 和 $\\beta$ 后，我们进入评估阶段。对于给定的评估光谱（例如植被），我们计算其两个传感器的“真实”波段反射率 $R_{A,\\text{eval}}$ 和 $R_{B,\\text{eval}}$。然后，我们使用导出的映射从传感器 $A$ 的测量值来预测传感器 $B$ 的反射率：\n$$\n\\hat{R}_{B,\\text{eval}} = \\alpha R_{A,\\text{eval}} + \\beta\n$$\n偏差 $b$ 是传感器 $B$ 的预测反射率与真实反射率之间的差值：\n$$\nb = \\hat{R}_{B,\\text{eval}} - R_{B,\\text{eval}}\n$$\n这个偏差量化了线性模型对于未包含在训练数据中的特定表面类型的系统误差。我们在每个测试用例中为植被和土壤评估光谱计算这个偏差。\n\n对于每个测试用例，整体算法按以下步骤进行：\n1. 定义波长网格 $\\lambda$。\n2. 使用指定参数生成辐照度光谱 $I(\\lambda)$ 和归一化的SRF $S_A(\\lambda)$、$S_B(\\lambda)$。\n3. 对训练集中的每个光谱：\n   a. 使用其参数公式生成反射光谱 $\\rho_i(\\lambda)$ 并截断到 $[0, 1]$。\n   b. 计算相应的波段反射率 $R_{A,i}$ 和 $R_{B,i}$。\n4. 汇集集合 $\\{R_{A,i}\\}$ 和 $\\{R_{B,i}\\}$，并执行线性回归以找到 $\\alpha$ 和 $\\beta$。\n5. 对于每个评估光谱（植被和土壤）：\n   a. 生成其反射光谱 $\\rho_{\\text{eval}}(\\lambda)$。\n   b. 计算其波段反射率 $R_{A,\\text{eval}}$ 和 $R_{B,\\text{eval}}$。\n   c. 计算预测反射率 $\\hat{R}_{B,\\text{eval}} = \\alpha R_{A,\\text{eval}} + \\beta$。\n   d. 计算偏差 $b = \\hat{R}_{B,\\text{eval}} - R_{B,\\text{eval}}$。\n6. 收集生成的偏差 $b_{\\text{veg}}$ 和 $b_{\\text{soil}}$ 作为最终输出。\n对所有三个测试用例重复此整个过程。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes cross-sensor reflectance mapping and evaluates class-wise bias\n    for three test cases as specified in the problem statement.\n    \"\"\"\n    \n    # Define the wavelength grid as a constant.\n    # Wavelength lambda is in nanometers.\n    LMBDA = np.arange(400, 901, 1)\n\n    # --- Helper functions for spectral models and calculations ---\n\n    def gaussian(lmbda, mu, sigma):\n        \"\"\"Computes a Gaussian function over the wavelength grid.\"\"\"\n        return np.exp(-(lmbda - mu)**2 / (2 * sigma**2))\n\n    def normalize_srf(srf, lmbda):\n        \"\"\"Normalizes an SRF so its discrete trapezoidal integral is 1.\"\"\"\n        integral = np.trapz(srf, lmbda)\n        if integral == 0:\n            return srf # Avoid division by zero, though unlikely.\n        return srf / integral\n\n    def rho_veg(lmbda, l0, s, ag):\n        \"\"\"Computes vegetation reflectance spectrum.\"\"\"\n        term1 = 0.05\n        term2 = 0.45 / (1.0 + np.exp(-(lmbda - l0) / s))\n        term3 = ag * np.exp(-(lmbda - 550)**2 / (2 * 30**2))\n        rho = term1 + term2 + term3\n        return np.clip(rho, 0, 1)\n\n    def rho_soil(lmbda, a, b, ac):\n        \"\"\"Computes soil reflectance spectrum.\"\"\"\n        rho = a + b * (lmbda - 400) + ac * np.exp(-(lmbda - 700)**2 / (2 * 150**2))\n        return np.clip(rho, 0, 1)\n\n    def rho_flat(lmbda, c):\n        \"\"\"Computes a flat reflectance spectrum.\"\"\"\n        # Use np.full_like to ensure the output array has the same shape as the input lambda grid.\n        return np.clip(np.full_like(lmbda, c, dtype=float), 0, 1)\n\n    def calculate_R(rho, srf, irradiance, lmbda):\n        \"\"\"Calculates the effective band reflectance R_X.\"\"\"\n        integrand_num = rho * srf * irradiance\n        integrand_den = srf * irradiance\n        numerator = np.trapz(integrand_num, lmbda)\n        denominator = np.trapz(integrand_den, lmbda)\n        # Denominator should be positive, but handle for robustness.\n        if denominator == 0:\n            return 0.0\n        return numerator / denominator\n\n    # --- Test Case Data Definition ---\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"irradiance\": {\"mu_I\": 550, \"sigma_I\": 130},\n            \"sensor_A\": {\"mu_A\": 650, \"sigma_A\": 20},\n            \"sensor_B\": {\"mu_B\": 660, \"sigma_B\": 25},\n            \"training_spectra\": [\n                {\"type\": \"veg\", \"params\": {\"l0\": 700, \"s\": 20, \"ag\": 0.08}},\n                {\"type\": \"veg\", \"params\": {\"l0\": 710, \"s\": 15, \"ag\": 0.10}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.12, \"b\": 1.5e-4, \"ac\": -0.02}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.18, \"b\": 1.0e-4, \"ac\": 0.015}},\n            ],\n            \"eval_spectra\": {\n                \"veg\": {\"l0\": 705, \"s\": 18, \"ag\": 0.09},\n                \"soil\": {\"a\": 0.14, \"b\": 1.4e-4, \"ac\": -0.01},\n            }\n        },\n        # Test Case 2\n        {\n            \"irradiance\": {\"mu_I\": 560, \"sigma_I\": 100},\n            \"sensor_A\": {\"mu_A\": 550, \"sigma_A\": 30},\n            \"sensor_B\": {\"mu_B\": 560, \"sigma_B\": 30},\n            \"training_spectra\": [\n                {\"type\": \"veg\", \"params\": {\"l0\": 690, \"s\": 25, \"ag\": 0.12}},\n                {\"type\": \"veg\", \"params\": {\"l0\": 695, \"s\": 22, \"ag\": 0.09}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.10, \"b\": 2.0e-4, \"ac\": -0.02}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.20, \"b\": 1.5e-4, \"ac\": 0.01}},\n            ],\n            \"eval_spectra\": {\n                \"veg\": {\"l0\": 692, \"s\": 20, \"ag\": 0.11},\n                \"soil\": {\"a\": 0.12, \"b\": 1.8e-4, \"ac\": -0.015},\n            }\n        },\n        # Test Case 3\n        {\n            \"irradiance\": {\"mu_I\": 650, \"sigma_I\": 120},\n            \"sensor_A\": {\"mu_A\": 680, \"sigma_A\": 10},\n            \"sensor_B\": {\"mu_B\": 680, \"sigma_B\": 40},\n            \"training_spectra\": [\n                {\"type\": \"veg\", \"params\": {\"l0\": 700, \"s\": 12, \"ag\": 0.08}},\n                {\"type\": \"veg\", \"params\": {\"l0\": 710, \"s\": 10, \"ag\": 0.07}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.15, \"b\": 1.0e-4, \"ac\": -0.01}},\n                {\"type\": \"flat\", \"params\": {\"c\": 0.30}},\n                {\"type\": \"flat\", \"params\": {\"c\": 0.50}},\n            ],\n            \"eval_spectra\": {\n                \"veg\": {\"l0\": 705, \"s\": 10, \"ag\": 0.09},\n                \"soil\": {\"a\": 0.13, \"b\": 1.0e-4, \"ac\": -0.005},\n            }\n        }\n    ]\n\n    # --- Main Processing Loop ---\n\n    all_results = []\n    \n    for case in test_cases:\n        # Correct the typo from the original problem statement for Test Case 3 eval veg\n        if \"l0\" not in case[\"eval_spectra\"][\"veg\"]:\n             case[\"eval_spectra\"][\"veg\"][\"l0\"] = case[\"eval_spectra\"][\"veg\"].pop(\"lO\")\n\n        # 1. Construct spectral functions (Irradiance and SRFs)\n        I = gaussian(LMBDA, case[\"irradiance\"][\"mu_I\"], case[\"irradiance\"][\"sigma_I\"])\n        S_A_unnorm = gaussian(LMBDA, case[\"sensor_A\"][\"mu_A\"], case[\"sensor_A\"][\"sigma_A\"])\n        S_A = normalize_srf(S_A_unnorm, LMBDA)\n        S_B_unnorm = gaussian(LMBDA, case[\"sensor_B\"][\"mu_B\"], case[\"sensor_B\"][\"sigma_B\"])\n        S_B = normalize_srf(S_B_unnorm, LMBDA)\n        \n        # 2. Compute band reflectances for the training set\n        R_A_train = []\n        R_B_train = []\n        for spec_def in case[\"training_spectra\"]:\n            if spec_def[\"type\"] == \"veg\":\n                rho = rho_veg(LMBDA, **spec_def[\"params\"])\n            elif spec_def[\"type\"] == \"soil\":\n                rho = rho_soil(LMBDA, **spec_def[\"params\"])\n            else: # flat\n                rho = rho_flat(LMBDA, **spec_def[\"params\"])\n\n            R_A_train.append(calculate_R(rho, S_A, I, LMBDA))\n            R_B_train.append(calculate_R(rho, S_B, I, LMBDA))\n\n        R_A_train = np.array(R_A_train)\n        R_B_train = np.array(R_B_train)\n        \n        # 3. Solve for alpha and beta using linear least squares\n        # Design matrix M for M*c=y, where c = [alpha, beta]^T\n        M = np.vstack([R_A_train, np.ones(len(R_A_train))]).T\n        alpha, beta = np.linalg.lstsq(M, R_B_train, rcond=None)[0]\n\n        # 4. Compute biases for evaluation spectra\n        \n        # Vegetation evaluation\n        params_veg = case[\"eval_spectra\"][\"veg\"]\n        rho_veg_eval = rho_veg(LMBDA, **params_veg)\n        R_A_veg_eval = calculate_R(rho_veg_eval, S_A, I, LMBDA)\n        R_B_veg_eval = calculate_R(rho_veg_eval, S_B, I, LMBDA)\n        R_B_veg_hat = alpha * R_A_veg_eval + beta\n        b_veg = R_B_veg_hat - R_B_veg_eval\n        all_results.append(b_veg)\n\n        # Soil evaluation\n        params_soil = case[\"eval_spectra\"][\"soil\"]\n        rho_soil_eval = rho_soil(LMBDA, **params_soil)\n        R_A_soil_eval = calculate_R(rho_soil_eval, S_A, I, LMBDA)\n        R_B_soil_eval = calculate_R(rho_soil_eval, S_B, I, LMBDA)\n        R_B_soil_hat = alpha * R_A_soil_eval + beta\n        b_soil = R_B_soil_hat - R_B_soil_eval\n        all_results.append(b_soil)\n\n    # The original python code has a print statement that is not needed for the final solution tag.\n    return f\"[{','.join(f'{r:.10f}' for r in all_results)}]\"\n\n# This part is just for execution and won't be in the final XML.\n# print(solve())\n```",
            "answer": "$$\n\\boxed{[-0.0003004812, 0.0003714902, -0.0016462740, 0.0019253457, 0.0051864197, -0.0102604588]}\n$$"
        }
    ]
}