{
    "hands_on_practices": [
        {
            "introduction": "综合评估的第一步是模拟耦合人类-自然系统的核心物理过程。本练习使用一个简化的碳箱模型——气候科学中的一个基础工具——将人类活动（排放）与大气成分和辐射强迫的变化联系起来。通过求解其底层的微分方程，您将亲身体验量化社会经济路径对气候造成的影响，这是综合评估模型（IAMs）的一项核心功能。",
            "id": "3803179",
            "problem": "一位政策制定者使用综合评估模型，结合基于卫星的大气二氧化碳遥感反演数据，评估一个人类—自然耦合系统情景。一个遥感数据同化系统报告称，在时间 $t=0$ 时，初始全球平均大气二氧化碳浓度为 $C(0)=415\\,\\mathrm{ppm}$。人为排放被预测为时间 $t$（单位：年）的函数，其路径由反映社会经济驱动因素和减缓政策的预设路径给出：\n$$\nE(t)=\n\\begin{cases}\n11 + 0.3\\,t  &\\text{for } 0 \\le t \\le 30,\\\\\n20\\,\\exp\\!\\big(-0.04\\,(t-30)\\big)  &\\text{for } 30  t \\le 100,\n\\end{cases}\n$$\n其中 $E(t)$ 的单位是 $\\mathrm{PgC\\,yr^{-1}}$（拍克碳/年）。对于大气碳箱室模型，假设大气碳质量守恒，且地表汇相对于一个基线浓度的吸收是线性的，由此得到常微分方程\n$$\n\\frac{dC}{dt} = \\frac{E(t)}{M_a} - \\lambda\\big(C(t)-C_b\\big),\n$$\n其中 $C(t)$ 是大气二氧化碳浓度，单位为 $\\mathrm{ppm}$；$C_b=280\\,\\mathrm{ppm}$ 是工业化前基线；$M_a=2.12\\,\\mathrm{PgC\\,ppm^{-1}}$ 是碳质量到浓度的转换系数；$\\lambda=0.02\\,\\mathrm{yr^{-1}}$ 是有效线性汇率。\n\n根据辐射强迫的定义和基本辐射传输原理（比尔-朗伯吸收定律以及热红外波段的谱线饱和与展宽），对于一种混合均匀的温室气体，其瞬时大气层顶辐射强迫与浓度 $C$ 相对于参考浓度 $C_0$ 的比值 $C/C_0$ 成对数关系；使用比例常数 $\\alpha=5.35\\,\\mathrm{W\\,m^{-2}}$，该常数反映了标准状况下二氧化碳的辐射核，并取 $C_0=C_b$。\n\n仅从上述质量守恒方程和基本辐射传输原理（比尔-朗伯定律和饱和）出发，推导 $C(t)$ 的闭式表达式，计算给定 $E(t)$ 下的 $C(100)$，然后计算在 $t=100\\,\\mathrm{yr}$ 时对应的辐射强迫。将最终的辐射强迫值四舍五入到四位有效数字，并以 $\\mathrm{W\\,m^{-2}}$ 为单位表示。你的最终答案必须是一个实数。",
            "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **初始条件**：$t=0$ 时的大气二氧化碳浓度为 $C(0)=415\\,\\mathrm{ppm}$。\n- **人为排放函数, $E(t)$**:\n$$\nE(t)=\n\\begin{cases}\n11 + 0.3\\,t  \\text{for } 0 \\le t \\le 30,\\\\\n20\\,\\exp\\!\\big(-0.04\\,(t-30)\\big)  \\text{for } 30  t \\le 100,\n\\end{cases}\n$$\n其中 $t$ 是时间，单位为年 ($\\mathrm{yr}$)，$E(t)$ 的单位是拍克碳/年 ($\\mathrm{PgC\\,yr^{-1}}$)。\n- **大气碳箱室模型常微分方程 (ODE)**：\n$$\n\\frac{dC}{dt} = \\frac{E(t)}{M_a} - \\lambda\\big(C(t)-C_b\\big)\n$$\n- **常数**：\n  - 工业化前基线浓度：$C_b=280\\,\\mathrm{ppm}$。\n  - 碳质量-浓度转换系数：$M_a=2.12\\,\\mathrm{PgC\\,ppm^{-1}}$。\n  - 有效线性汇率：$\\lambda=0.02\\,\\mathrm{yr^{-1}}$。\n- **辐射强迫 (RF) 关系**：RF 与浓度 $C$ 相对于参考浓度 $C_0$ 的比值成对数关系：$RF = \\alpha \\ln(C/C_0)$。\n- **RF 常数**：\n  - 比例常数：$\\alpha=5.35\\,\\mathrm{W\\,m^{-2}}$。\n  - 参考浓度：$C_0=C_b=280\\,\\mathrm{ppm}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题是在简化气候模型背景下的一个定义明确的数学物理问题。\n1.  **科学依据**：该问题使用了一个标准的、尽管简化的碳循环箱室模型（一阶线性常微分方程）以及已确立的二氧化碳辐射强迫对数关系。这些是气候科学中基本且广泛使用的概念。像 $M_a$、$C_b$ 和 $\\alpha$ 这样的常数值与文献值一致。排放情景 $E(t)$ 是对一个达峰后下降路径的合理、程式化的表述。该模型是一个简化模型，但没有违反任何基本原理。\n2.  **适定性**：该问题提供了一个具有给定初始条件 $C(0)$ 的一阶常微分方程。强迫函数 $E(t)$ 是分段连续的，确保对于 $t \\ge 0$ 存在一个唯一的连续解 $C(t)$。所有参数都已指定。要求是找到特定时间点的值，这是一个定义明确的任务。\n3.  **客观性**：该问题以精确的数学和物理术语表述，没有主观或含糊不清的语言。\n4.  **完整性与一致性**：该问题是自洽的。所有必要的方程、常数和初始条件都已提供。没有内部矛盾。\n\n**步骤 3：结论与行动**\n\n该问题是有效的，因为它具有科学依据、适定、客观且自洽。可以继续求解过程。\n\n### 解的推导\n\n核心任务是求解大气二氧化碳浓度 $C(t)$ 的一阶线性常微分方程 (ODE)。该 ODE 可以重写为标准形式：\n$$\n\\frac{dC}{dt} + \\lambda C(t) = \\frac{E(t)}{M_a} + \\lambda C_b\n$$\n这是一个形如 $y' + p(t)y = q(t)$ 的线性 ODE，其积分因子为 $\\exp(\\int p(t) dt) = \\exp(\\lambda t)$。解由以下公式给出：\n$$\nC(t) = \\exp(-\\lambda t) \\left[ \\int \\exp(\\lambda t) \\left( \\frac{E(t)}{M_a} + \\lambda C_b \\right) dt + K \\right]\n$$\n其中 $K$ 是积分常数。由于 $E(t)$ 是一个分段函数，我们必须分别对两个时间区间求解 ODE。\n\n**第 1 部分：$0 \\le t \\le 30$ 时的解**\n\n在此区间内，$E(t) = 11 + 0.3t$。ODE 为：\n$$\n\\frac{dC}{dt} + \\lambda C(t) = \\frac{11 + 0.3t}{M_a} + \\lambda C_b\n$$\n等式右侧是 $t$ 的线性函数。我们来求解：\n$$\nC_1(t) = \\exp(-\\lambda t) \\left[ \\int \\exp(\\lambda t) \\left( \\frac{11}{M_a} + \\lambda C_b + \\frac{0.3}{M_a}t \\right) dt + K_1 \\right]\n$$\n包含 $t$ 的项的积分使用分部积分法求解：\n$$\n\\int \\exp(\\lambda t) \\left( \\frac{11}{M_a} + \\lambda C_b \\right) dt = \\frac{1}{\\lambda}\\left(\\frac{11}{M_a} + \\lambda C_b\\right)\\exp(\\lambda t)\n$$\n$$\n\\int \\frac{0.3t}{M_a} \\exp(\\lambda t) dt = \\frac{0.3}{M_a} \\left( \\frac{t}{\\lambda}\\exp(\\lambda t) - \\frac{1}{\\lambda^2}\\exp(\\lambda t) \\right)\n$$\n结合这些结果，此区间的通解为：\n$$\nC_1(t) = \\frac{1}{\\lambda}\\left(\\frac{11}{M_a} + \\lambda C_b\\right) + \\frac{0.3}{M_a\\lambda}t - \\frac{0.3}{M_a\\lambda^2} + K_1\\exp(-\\lambda t)\n$$\n可以简化为：\n$$\nC_1(t) = C_b + \\frac{11}{M_a\\lambda} - \\frac{0.3}{M_a\\lambda^2} + \\frac{0.3t}{M_a\\lambda} + K_1\\exp(-\\lambda t)\n$$\n我们使用初始条件 $C(0) = 415$ 来求 $K_1$：\n$$\nC(0) = 415 = C_b + \\frac{11}{M_a\\lambda} - \\frac{0.3}{M_a\\lambda^2} + K_1\n$$\n$$\nK_1 = C(0) - C_b - \\frac{11}{M_a\\lambda} + \\frac{0.3}{M_a\\lambda^2}\n$$\n因此，$C(t)$ 在 $0 \\le t \\le 30$ 上的闭式表达式为：\n$$\nC_1(t) = C_b + \\frac{11+0.3t}{M_a\\lambda} - \\frac{0.3}{M_a\\lambda^2} + \\left( C(0) - C_b - \\frac{11}{M_a\\lambda} + \\frac{0.3}{M_a\\lambda^2} \\right) \\exp(-\\lambda t)\n$$\n\n**第 2 部分：$30  t \\le 100$ 时的解**\n\n对于此区间，我们定义一个新的时间变量 $\\tau = t - 30$，其范围从 0 到 70。排放函数为 $E(\\tau) = 20\\exp(-0.04\\tau)$。设 $\\beta = 0.04\\,\\mathrm{yr^{-1}}$。ODE 变为：\n$$\n\\frac{dC}{d\\tau} + \\lambda C(\\tau) = \\frac{20\\exp(-\\beta\\tau)}{M_a} + \\lambda C_b\n$$\n解 $C_2(\\tau)$ 的求法类似：\n$$\nC_2(\\tau) = \\exp(-\\lambda \\tau) \\left[ \\int \\exp(\\lambda \\tau) \\left( \\frac{20\\exp(-\\beta\\tau)}{M_a} + \\lambda C_b \\right) d\\tau + K_2 \\right]\n$$\n积分为：\n$$\n\\int \\left( \\frac{20}{M_a}\\exp((\\lambda-\\beta)\\tau) + \\lambda C_b \\exp(\\lambda\\tau) \\right) d\\tau = \\frac{20}{M_a(\\lambda-\\beta)}\\exp((\\lambda-\\beta)\\tau) + C_b\\exp(\\lambda\\tau)\n$$\n这里我们假设 $\\lambda \\ne \\beta$，这是成立的（$0.02 \\ne 0.04$）。通解为：\n$$\nC_2(\\tau) = \\frac{20}{M_a(\\lambda-\\beta)}\\exp(-\\beta\\tau) + C_b + K_2\\exp(-\\lambda\\tau)\n$$\n此区间的初始条件是 $t=30$ 时的浓度，即 $C_1(30)$。所以，$C_2(0) = C_1(30)$。\n$$\nC_2(0) = C_1(30) = \\frac{20}{M_a(\\lambda-\\beta)} + C_b + K_2\n$$\n$$\nK_2 = C_1(30) - C_b - \\frac{20}{M_a(\\lambda-\\beta)}\n$$\n$C(t)$ 在 $30  t \\le 100$ 上的闭式表达式（用 $\\tau=t-30$ 表示）为：\n$$\nC_2(\\tau) = C_b + \\frac{20\\exp(-\\beta\\tau)}{M_a(\\lambda-\\beta)} + \\left( C_1(30) - C_b - \\frac{20}{M_a(\\lambda-\\beta)} \\right) \\exp(-\\lambda\\tau)\n$$\n\n**$C(t)$ 的完整闭式表达式**\n结合两部分，完整的解为：\n$$\nC(t)=\n\\begin{cases}\nC_b + \\frac{11+0.3t}{M_a\\lambda} - \\frac{0.3}{M_a\\lambda^2} + \\left( C(0) - C_b - \\frac{11}{M_a\\lambda} + \\frac{0.3}{M_a\\lambda^2} \\right) \\exp(-\\lambda t)  \\text{for } 0 \\le t \\le 30, \\\\\nC_b + \\frac{20\\exp(-0.04(t-30))}{M_a(\\lambda-0.04)} + \\left( C_1(30) - C_b - \\frac{20}{M_a(\\lambda-0.04)} \\right) \\exp(-\\lambda(t-30))  \\text{for } 30  t \\le 100,\n\\end{cases}\n$$\n其中 $C_1(30)$ 是第一个表达式在 $t=30$ 时的值。\n\n**第 3 部分：数值计算**\n\n我们已知数值：$C(0)=415$，$C_b=280$，$M_a=2.12$，$\\lambda=0.02$，$\\beta=0.04$。\n\n首先，计算 $C_1(30)$：\n$$\nC_1(30) = 280 + \\frac{11+0.3(30)}{2.12(0.02)} - \\frac{0.3}{2.12(0.02)^2} + \\left( 415 - 280 - \\frac{11}{2.12(0.02)} + \\frac{0.3}{2.12(0.02)^2} \\right) \\exp(-0.02 \\times 30)\n$$\n$$\nC_1(30) = 280 + \\frac{20}{0.0424} - \\frac{0.3}{0.000848} + \\left( 135 - \\frac{11}{0.0424} + \\frac{0.3}{0.000848} \\right) \\exp(-0.6)\n$$\n$$\nC_1(30) \\approx 280 + 471.6981 - 353.7736 + (135 - 259.4340 + 353.7736) \\exp(-0.6)\n$$\n$$\nC_1(30) \\approx 397.9245 + (229.3396) \\exp(-0.6) \\approx 397.9245 + 229.3396 (0.5488116)\n$$\n$$\nC_1(30) \\approx 397.9245 + 125.8606 \\approx 523.7851\\,\\mathrm{ppm}\n$$\n\n接下来，计算 $C(100)$，对应于 $\\tau=70$：\n$$\nC(100) = C_2(70) = C_b + \\frac{20\\exp(-0.04 \\times 70)}{2.12(0.02-0.04)} + \\left( C_1(30) - C_b - \\frac{20}{2.12(0.02-0.04)} \\right) \\exp(-0.02 \\times 70)\n$$\n$$\nC(100) = 280 + \\frac{20\\exp(-2.8)}{-0.0424} + \\left( 523.7851 - 280 - \\frac{20}{-0.0424} \\right) \\exp(-1.4)\n$$\n$$\nC(100) \\approx 280 - 471.6981 \\exp(-2.8) + (243.7851 + 471.6981) \\exp(-1.4)\n$$\n$$\nC(100) \\approx 280 - 471.6981 (0.060810) + (715.4832) (0.246597)\n$$\n$$\nC(100) \\approx 280 - 28.6831 + 176.4710 \\approx 427.7879\\,\\mathrm{ppm}\n$$\n\n**第 4 部分：辐射强迫计算**\n\n最后，使用给定公式 $RF = \\alpha \\ln(C/C_0)$ 计算 $t=100$ 时的辐射强迫：\n$$\nRF(100) = \\alpha \\ln\\left(\\frac{C(100)}{C_b}\\right) = 5.35 \\ln\\left(\\frac{427.7879}{280}\\right)\n$$\n$$\nRF(100) \\approx 5.35 \\ln(1.527814) \\approx 5.35 \\times 0.423800\n$$\n$$\nRF(100) \\approx 2.26733\\,\\mathrm{W\\,m^{-2}}\n$$\n四舍五入到四位有效数字，辐射强迫为 $2.267\\,\\mathrm{W\\,m^{-2}}$。",
            "answer": "$$\\boxed{2.267}$$"
        },
        {
            "introduction": "在对系统进行建模之后，下一个挑战是如何对其进行管理以实现预期的结果。本练习介绍多目标优化，这是一种关键技术，用于在经济生产、碳封存和生物多样性等相互冲突的目标之间进行权衡取舍。通过使用加权和法，您将探索帕累托前沿的有效解，这个实践性的编码问题将使您掌握构建和解决复杂土地利用分配问题的能力，从而直接应对耦合系统中可持续管理的核心挑战。",
            "id": "3803125",
            "problem": "考虑一个耦合人类—自然系统和综合评估建模领域中的空间显式土地分配问题，该问题通过遥感和环境监测进行参数化。您将得到一组地块，索引为 $i \\in \\{1,\\dots,N\\}$，其中 $N=4$，每个地块的面积为 $a_i$ 公顷。决策变量 $x_{i,L}$ 代表地块 $i$ 分配给土地利用类型 $L \\in \\{\\text{农业 (A)}, \\text{林业 (F)}, \\text{保护 (C)}\\}$ 的比例。每个地块必须被完全分配，满足 $\\sum_{L \\in \\{A,F,C\\}} x_{i,L} = 1$ 和 $0 \\leq x_{i,L} \\leq 1$。遥感和生态评估提供了每公顷的系数，包括碳汇 $c_{i,L}$（单位：公吨二氧化碳/年，tCO$_2$/yr）、农业产量 $y_i$（单位：吨/年）和一个生物多样性指数 $b_{i,L}$（无量纲），所有这些系数都假定相对于 $x_{i,L}$ 是恒定的。系统的总体目标是所有地块和土地利用类型的总和：总碳汇 $C = \\sum_i \\sum_L a_i c_{i,L} x_{i,L}$，总农业产量 $P = \\sum_i a_i y_i x_{i,A}$，以及总生物多样性 $B = \\sum_i \\sum_L a_i b_{i,L} x_{i,L}$。出于社会生态可行性的考虑，该分配还必须满足以下系统级约束：最低产量要求 $P \\geq P_{\\min}$，最低生物多样性要求 $B \\geq B_{\\min}$，以及灌溉能力约束 $\\sum_i a_i x_{i,A} \\leq A_{\\max}$。\n\n本问题的基础理论：\n- 帕累托效率的定义：一个可行分配是帕累托有效的，当且仅当不存在其他可行分配，能在不降低任何其他目标的情况下，至少改进一个目标。\n- 凸多目标优化的加权和标量化原则：对于总和为一的非负权重，在凸可行集上最大化目标的凸组合可以得到帕累托有效的解。\n\n参数化（所有数组均与地块对齐，并按 $i=1,2,3,4$ 的顺序列出）：\n- 面积（公顷）：$a = [100,80,120,60]$。\n- 碳汇密度（tCO$_2$/年/公顷）：\n  - 农业：$c_{A} = [2.0,2.5,1.5,2.0]$，\n  - 林业：$c_{F} = [8.0,10.0,7.5,9.0]$，\n  - 保护：$c_{C} = [6.0,7.0,5.5,6.5]$。\n- 农业产量（吨/年/公顷）：$y = [3.0,4.0,2.5,3.5]$。\n- 生物多样性指数（无量纲/公顷）：\n  - 农业：$b_{A} = [0.30,0.35,0.25,0.32]$，\n  - 林业：$b_{F} = [0.70,0.75,0.65,0.72]$，\n  - 保护：$b_{C} = [0.90,0.85,0.80,0.88]$。\n- 系统级约束：\n  - 最低产量：$P_{\\min} = 500$ 吨/年，\n  - 最低生物多样性：$B_{\\min} = 180$，\n  - 最大农业面积：$A_{\\max} = 220$ 公顷。\n\n在给定约束条件下，定义碳汇、农业产量和生物多样性之间权衡的帕累托前沿。使用加权和方法，通过满足 $w_C + w_P + w_B = 1$ 的非负权重 $(w_C,w_P,w_B)$，计算一组帕累托有效的分配方案。由于各目标具有不同的单位和尺度，需要通过除以其在约束下的最大值来对每个目标进行无量纲化处理：如果 $C_{\\max}$、$P_{\\max}$ 和 $B_{\\max}$ 分别表示在相同约束下 $C$、$P$ 和 $B$ 可达到的最大值，则要最大化的标量化目标是 $w_C \\cdot \\frac{C}{C_{\\max}} + w_P \\cdot \\frac{P}{P_{\\max}} + w_B \\cdot \\frac{B}{B_{\\max}}$。\n\n你的程序必须：\n- 构建并求解计算 $C_{\\max}$、$P_{\\max}$、$B_{\\max}$ 所需的约束线性规划问题，并对每个权重向量，通过最大化归一化目标的加权和来计算相应的帕累托有效分配。\n- 对于每个权重向量，报告未归一化的目标值三元组 $(C,P,B)$。\n\n单位和输出规范：\n- 将碳汇 $C$ 以 tCO$_2$/年 表示，农业产量 $P$ 以 吨/年 表示，生物多样性指数 $B$ 为无量纲量。将每个报告的数字四舍五入到小数点后两位。\n\n测试集（按顺序评估的权重）：\n- 平衡型：$[1/3,1/3,1/3]$，\n- 碳汇优先型：$[0.7,0.2,0.1]$，\n- 产量优先型：$[0.1,0.8,0.1]$，\n- 生物多样性优先型：$[0.2,0.1,0.7]$，\n- 边界情况（生物多样性权重为零）：$[0.5,0.5,0.0]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应权重向量的结果列表 $[C,P,B]$（单位和舍入如上所述），其顺序与测试集相同。例如：$[[c_1,p_1,b_1],[c_2,p_2,b_2],\\dots]$。",
            "solution": "所提出的问题是一个应用于土地利用分配的多目标线性规划（MOLP）问题。其目标是确定一组帕累托有效的土地分配方案，这些方案代表了三个相互冲突的目标之间的最优权衡：最大化总碳汇（$C$）、总农业产量（$P$）和总生物多样性（$B$）。解决方案是使用加权和标量化方法得出的，这是一种解决MOLP问题的标准技术。\n\n### 数学公式\n该问题被形式化为一个线性规划（LP）问题。\n\n**1. 决策变量**\n核心决策变量是 $x_{i,L}$，代表地块 $i$ 中分配给土地利用类型 $L$ 的比例。共有 $N=4$ 个地块和 $3$ 种土地利用类型，即 $\\{\\text{农业 (A)}, \\text{林业 (F)}, \\text{保护 (C)}\\}$，因此总共有 $4 \\times 3 = 12$ 个决策变量。\n这些变量受以下边界约束：\n$$0 \\leq x_{i,L} \\leq 1 \\quad \\forall i \\in \\{1,2,3,4\\}, L \\in \\{A,F,C\\}$$\n\n**2. 目标函数**\n三个目标都是决策变量的线性函数。\n- **总碳汇 ($C$)：** 总固碳量是每个地块和土地利用类型贡献的总和。\n  $$C = \\sum_{i=1}^{4} \\sum_{L \\in \\{A,F,C\\}} a_i c_{i,L} x_{i,L}$$\n  其中 $a_i$ 是地块 $i$ 的面积，$c_{i,L}$ 是每公顷的碳汇系数。\n\n- **总农业产量 ($P$)：** 产量仅发生在分配给农业的土地上。\n  $$P = \\sum_{i=1}^{4} a_i y_i x_{i,A}$$\n  其中 $y_i$ 是地块 $i$ 的每公顷农业产量。\n\n- **总生物多样性 ($B$)：** 总生物多样性得分是每个地块和土地利用类型贡献的总和。\n  $$B = \\sum_{i=1}^{4} \\sum_{L \\in \\{A,F,C\\}} a_i b_{i,L} x_{i,L}$$\n  其中 $b_{i,L}$ 是每公顷的生物多样性指数。\n\n**3. 约束条件**\n分配方案必须满足地块和系统两个层面上的若干约束。\n- **地块的完全分配：** 每个地块必须在三种土地利用类型之间被完全分配。\n  $$\\sum_{L \\in \\{A,F,C\\}} x_{i,L} = 1 \\quad \\forall i \\in \\{1,2,3,4\\}$$\n\n- **最低农业产量：** 总产量必须满足最低社会需求。\n  $$P \\geq P_{\\min} \\quad (P_{\\min} = 500 \\text{ 吨/年})$$\n\n- **最低生物多样性：** 总生物多样性得分不得低于某个阈值。\n  $$B \\geq B_{\\min} \\quad (B_{\\min} = 180)$$\n\n- **最大农业面积：** 由于灌溉等资源限制，用于农业的总面积有上限。\n  $$\\sum_{i=1}^{4} a_i x_{i,A} \\leq A_{\\max} \\quad (A_{\\max} = 220 \\text{ 公顷})$$\n\n### 求解方法\n同时最大化 $C$、$P$ 和 $B$ 的问题，可以通过使用加权和方法将MOLP转换成一系列单目标LP来解决。\n\n**1. 加权和标量化**\n核心思想是最大化目标函数的加权和。由于可行集（由线性约束定义）是凸的，且目标函数是线性的，因此最大化目标的凸组合（即，总和为1的非负权重）保证能产生帕累托有效的解。\n\n**2. 目标归一化**\n各个目标具有不同的单位（tCO$_2$/年、吨/年和无量纲）和差异巨大的数值尺度。为了确保权重 $(w_C, w_P, w_B)$ 真实反映对每个目标的偏好，必须在组合它们之前对目标进行归一化。问题指定将每个目标除以其在给定约束下的最大可能值（$C_{\\max}, P_{\\max}, B_{\\max}$）来进行归一化。需要最大化的标量化目标函数是：\n$$Z_{norm} = w_C \\frac{C}{C_{\\max}} + w_P \\frac{P}{P_{\\max}} + w_B \\frac{B}{B_{\\max}}$$\n其中 $w_C + w_P + w_B = 1$ 且 $w_C, w_P, w_B \\ge 0$。\n\n### 算法步骤\n解决方案通过以下步骤计算得出：\n\n**步骤1：计算归一化因子**\n首先，我们分别确定每个目标在所有系统约束条件下的最大可能值。这需要求解三个独立的LP：\n- 在所有约束条件下最大化 $C$，以找到 $C_{\\max}$。\n- 在所有约束条件下最大化 $P$，以找到 $P_{\\max}$。\n- 在所有约束条件下最大化 $B$，以找到 $B_{\\max}$。\n\n**步骤2：为每个权重向量求解加权和问题**\n对于每个给定的权重向量 $(w_C, w_P, w_B)$，求解一个新的LP。目标是最大化 $Z_{norm}$。由于 $C$、$P$ 和 $B$ 是 $x_{i,L}$ 的线性函数，而 $C_{\\max}, P_{\\max}, B_{\\max}$ 是常数，因此 $Z_{norm}$ 也是 $x_{i,L}$ 的线性函数。该问题是：\n$$\\text{最大化} \\quad \\left( \\frac{w_C}{C_{\\max}} \\sum_{i,L} a_i c_{i,L} x_{i,L} + \\frac{w_P}{P_{\\max}} \\sum_{i} a_i y_i x_{i,A} + \\frac{w_B}{B_{\\max}} \\sum_{i,L} a_i b_{i,L} x_{i,L} \\right)$$\n受所有上述约束条件限制。\n\n**步骤3：报告结果**\n步骤2中LP的解是一个最优分配向量 $\\{x_{i,L}^*\\}$。我们使用这个向量来计算三个目标的未归一化值：$(C^*, P^*, B^*)$。这个三元组代表了权衡曲面上的一个帕累托有效点。对所有测试权重向量重复此过程。\n\n### 实现\n该算法使用Python实现，其中 `numpy` 库用于数值运算，`scipy.optimize.linprog` 用于求解线性规划问题。决策变量 $x_{i,L}$ 被展平为一个包含12个元素的向量。目标函数和约束被格式化为 `linprog` 所需的标准矩阵表示：$\\min \\mathbf{c}^T \\mathbf{x}$，约束条件为 $\\mathbf{A}_{ub} \\mathbf{x} \\le \\mathbf{b}_{ub}$ 和 $\\mathbf{A}_{eq} \\mathbf{x} = \\mathbf{b}_{eq}$。最大化问题通过将目标系数向量 $\\mathbf{c}$ 取反来转换为最小化问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    # =========================================================================\n    # 1. Define Givens from the Problem Statement\n    # =========================================================================\n    \n    # Parcels (i=1,2,3,4), Land Uses (L=A,F,C)\n    N_parcels = 4\n    N_land_uses = 3\n    n_vars = N_parcels * N_land_uses\n\n    # Parcel areas (hectares)\n    a = np.array([100, 80, 120, 60])\n\n    # Carbon sequestration densities (tCO2/yr per ha)\n    c_A = np.array([2.0, 2.5, 1.5, 2.0])\n    c_F = np.array([8.0, 10.0, 7.5, 9.0])\n    c_C = np.array([6.0, 7.0, 5.5, 6.5])\n    \n    # Agricultural yields (tonnes/yr per ha)\n    y = np.array([3.0, 4.0, 2.5, 3.5])\n\n    # Biodiversity indices (dimensionless)\n    b_A = np.array([0.30, 0.35, 0.25, 0.32])\n    b_F = np.array([0.70, 0.75, 0.65, 0.72])\n    b_C = np.array([0.90, 0.85, 0.80, 0.88])\n\n    # System-level constraints\n    P_min = 500.0\n    B_min = 180.0\n    A_max = 220.0\n\n    # Test cases: weight vectors (wC, wP, wB)\n    test_weights = [\n        [1/3, 1/3, 1/3],       # Balanced\n        [0.7, 0.2, 0.1],      # Carbon-focused\n        [0.1, 0.8, 0.1],      # Production-focused\n        [0.2, 0.1, 0.7],      # Biodiversity-focused\n        [0.5, 0.5, 0.0]       # Boundary case\n    ]\n\n    # =========================================================================\n    # 2. Formulate LP in Matrix Form for scipy.optimize.linprog\n    # =========================================================================\n    # Variables are flattened: [x_1A, x_1F, x_1C, x_2A, x_2F, x_2C, ...]\n\n    # Objective Coefficient Vectors (for unnormalized C, P, B)\n    c_coeffs_matrix = np.vstack([c_A, c_F, c_C]).T # 4x3\n    b_coeffs_matrix = np.vstack([b_A, b_F, b_C]).T # 4x3\n\n    C_coeffs = (a[:, np.newaxis] * c_coeffs_matrix).flatten()\n    B_coeffs = (a[:, np.newaxis] * b_coeffs_matrix).flatten()\n    \n    P_coeffs = np.zeros(n_vars)\n    P_coeffs[0::N_land_uses] = a * y\n\n    # Equality Constraints: sum(x_i,L for L) = 1 for each i\n    A_eq = np.kron(np.eye(N_parcels), np.ones(N_land_uses))\n    b_eq = np.ones(N_parcels)\n\n    # Inequality Constraints: P = P_min, B = B_min, AgArea = A_max\n    # Re-arranged for linprog: -P = -P_min, -B = -B_min\n    ag_area_coeffs = np.zeros(n_vars)\n    ag_area_coeffs[0::N_land_uses] = a\n    \n    A_ub = np.array([\n        -P_coeffs,\n        -B_coeffs,\n        ag_area_coeffs\n    ])\n    b_ub = np.array([-P_min, -B_min, A_max])\n\n    # Bounds for decision variables: 0 = x_i,L = 1\n    bounds = (0, 1)\n\n    # =========================================================================\n    # 3. Calculate Normalization Factors (C_max, P_max, B_max)\n    # =========================================================================\n    \n    # For maximization, we minimize the negative of the objective function.\n    \n    # C_max\n    res_C = linprog(c=-C_coeffs, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    C_max = -res_C.fun if res_C.success else 0\n\n    # P_max\n    res_P = linprog(c=-P_coeffs, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    P_max = -res_P.fun if res_P.success else 0\n\n    # B_max\n    res_B = linprog(c=-B_coeffs, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    B_max = -res_B.fun if res_B.success else 0\n\n    if not all([C_max  0, P_max  0, B_max  0]):\n        # This case would indicate an issue with the problem setup, e.g., infeasible.\n        # Based on validation, this should not happen.\n        # Fallback to prevent division by zero.\n        C_max = C_max if C_max  0 else 1\n        P_max = P_max if P_max  0 else 1\n        B_max = B_max if B_max  0 else 1\n\n    # =========================================================================\n    # 4. Solve for each weight vector and collect results\n    # =========================================================================\n    final_results = []\n    for w in test_weights:\n        w_C, w_P, w_B = w\n        \n        # Formulate weighted objective function\n        c_weighted = -(w_C/C_max * C_coeffs + w_P/P_max * P_coeffs + w_B/B_max * B_coeffs)\n        \n        # Solve the LP for the weighted objective\n        res = linprog(c=c_weighted, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            x_opt = res.x\n            # Calculate unnormalized objective values\n            C_val = np.dot(C_coeffs, x_opt)\n            P_val = np.dot(P_coeffs, x_opt)\n            B_val = np.dot(B_coeffs, x_opt)\n            final_results.append([C_val, P_val, B_val])\n        else:\n            # Append nulls if solver fails, to maintain output structure\n            final_results.append([0.0, 0.0, 0.0])\n\n    # =========================================================================\n    # 5. Format and Print Final Output\n    # =========================================================================\n    sublist_strings = []\n    for c, p, b in final_results:\n        sublist_strings.append(f\"[{c:.2f},{p:.2f},{b:.2f}]\")\n    \n    print(f\"[{','.join(sublist_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "政策周期的闭环在于评估干预措施在现实世界中的实际影响。本练习通过实施双重差分法（DiD）——一种来自计量经济学的强大的准实验技术——来超越相关性，探究因果关系。该方法允许使用来自遥感的观测数据来估计政策的平均处理效应。通过从零开始实现这个估计器，您将学习到一种严谨且广泛应用的项目评估方法，从而能够可靠地评估环境政策和干预措施的有效性。",
            "id": "3803118",
            "problem": "给定两期面板数据，这些数据针对在一个人—自然耦合系统场景中，通过卫星遥感分类为处理组和控制组的区域。每个区域在每个时期有一个单一的结果：一个从遥感测量的无单位生态系统服务指数（例如，源自归一化植被指数的植被绿度）。处理对应于一项政策干预，该干预在干预前时期和干预后时期之间影响处理区域，并且结果指数在时间上是一致测量的。目标是实现一个双重差分估计量，并计算平均处理效应及其稳健标准误。\n\n使用以下基本框架：包含单位处理值稳定假设的潜在结果框架、平行趋势假设，以及两期、两组双重差分法的线性模型表示，结合普通最小二乘法和 Eicker–Huber–White 异方差稳健协方差（HC3 变体）。具体而言，将单位 $i$ 在时间 $t$ 的结果视为 $Y_{it}$，其中处理指标为 $D_i \\in \\{0,1\\}$，干预后指标为 $T_t \\in \\{0,1\\}$。根据这些基本定义和假设，推导一个可实现的平均处理效应估计量，该估计量对应于一个正确指定的线性模型中交互项 $D_i T_t$ 的系数。使用从普通最小二乘法残差和杠杆值推导出的三明治形式构建一个稳健方差估计。\n\n输入数据将在您的程序中以浮点数列表的形式提供，代表控制组和处理组在干预前和干预后时期的单位级结果。所有结果都是无单位的浮点值。不需要外部输入。您不得引入任何随机性。\n\n您的程序必须：\n- 构建最小的两期面板，每个单位每个时期有一个观测值，其列对应于截距项、处理指标 $D_i$、干预后时期指标 $T_t$ 以及它们的交互项 $D_i T_t$。\n- 使用矩阵代数，通过普通最小二乘法估计系数，与满秩设计的 $X^\\top X$ 求逆和 $X^\\top Y$ 乘法一致。\n- 使用 HC3 方差估计量计算稳健标准误。设残差向量为 $u$，设计矩阵为 $X$，帽子矩阵为 $H = X (X^\\top X)^{-1} X^\\top$，其对角线上的杠杆值为 $h_i$。定义一个对角矩阵 $S$，其元素为 $s_{ii} = \\left(\\frac{u_i}{1 - h_i}\\right)^2$。稳健协方差估计量为 $(X^\\top X)^{-1} X^\\top S X (X^\\top X)^{-1}$。报告交互项系数的标准误，即相应对角元素的平方根。\n- 生成单行输出，包含一个列表的列表，其中每个内部列表包含给定测试用例的平均处理效应及其稳健标准误，四舍五入到 $6$ 位小数。\n\n测试套件。为以下参数集实现计算：\n\n- 案例 1（具有正处理效应的一般情况）：\n  - 控制组，干预前：$[0.62, 0.58, 0.60, 0.65, 0.61]$\n  - 控制组，干预后：$[0.64, 0.59, 0.61, 0.66, 0.62]$\n  - 处理组，干预前：$[0.55, 0.57, 0.56, 0.54, 0.58]$\n  - 处理组，干预后：$[0.60, 0.63, 0.62, 0.61, 0.64]$\n\n- 案例 2（平行趋势下平均处理效应为零的边界情况）：\n  - 控制组，干预前：$[0.50, 0.52, 0.51]$\n  - 控制组，干预后：$[0.55, 0.57, 0.56]$\n  - 处理组，干预前：$[0.49, 0.53, 0.50, 0.52]$\n  - 处理组，干预后：$[0.54, 0.58, 0.55, 0.57]$\n\n- 案例 3（异方差结果和组别大小不平衡的边缘情况）：\n  - 控制组，干预前：$[0.70, 0.68, 0.69, 0.71, 0.67, 0.70]$\n  - 控制组，干预后：$[0.69, 0.69, 0.70, 0.72, 0.68, 0.71]$\n  - 处理组，干预前：$[0.60, 0.61, 0.59]$\n  - 处理组，干预后：$[0.66, 0.64, 0.65]$\n\n答案格式。您的程序应生成单行输出，包含一个逗号分隔的列表的列表，其中每个内部列表格式为 $[ATE,SE]$，四舍五入到 $6$ 位小数，并用方括号括起来。例如，一个有效的输出格式是 $[[0.012345,0.067890],[0.000000,0.012345],[0.123456,0.234567]]$。由于生态系统服务指数是无单位的，这些值也是无单位的浮点数。不涉及角度或百分比。输出必须根据给定数据确定性地生成，无需任何外部输入。",
            "solution": "该问题要求对一个两期、两组的面板数据集实施双重差分（DiD）估计量，以计算平均处理效应（ATE）及其稳健标准误。该方法以计量经济学为基础，并应用于一个涉及通过遥感测量的生态系统服务的场景。\n\nDiD方法的基础是潜在结果框架。对于每个单位（区域）$i$在时间$t$，我们可以想象两种潜在结果：$Y_{it}(1)$（如果它接受处理）和$Y_{it}(0)$（如果它不接受处理）。观测到的结果是$Y_{it} = D_i Y_{it}(1) + (1-D_i)Y_{it}(0)$，其中$D_i$是一个不随时间变化的处理指标，对于处理单位为$1$，对于控制单位为$0$。处理在干预前时期（$t=0$）和干预后时期（$t=1$）之间应用。我们使用一个时间指标$T_t$，在$t=0$时为$0$，在$t=1$时为$1$。\n\n我们感兴趣的参数是处理组的平均处理效应（ATT），在问题的背景下被称为ATE：\n$$\n\\text{ATE} = E[Y_{i1}(1) - Y_{i1}(0) | D_i = 1]\n$$\n这是处理对处理组的预期效应。识别此参数的一个关键且无法检验的假设是平行趋势假设：\n$$\nE[Y_{i1}(0) - Y_{i0}(0) | D_i = 1] = E[Y_{i1}(0) - Y_{i0}(0) | D_i = 0]\n$$\n这个假设表明，在没有处理的情况下，处理组的结果平均变化会与控制组的平均变化相同。\n\n这个设定可以用一个线性回归模型来形式化。单位$i$在时间$t$的观测结果$Y_{it}$被建模为：\n$$\nY_{it} = \\beta_0 + \\beta_1 D_i + \\beta_2 T_t + \\beta_3 (D_i T_t) + \\epsilon_{it}\n$$\n其中：\n- $\\beta_0$是截距项，代表控制组（$D_i=0$）在干预前时期（$T_t=0$）的平均结果。\n- $\\beta_1$是处理组（$D_i=1$）和控制组在干预前时期的平均差异。\n- $\\beta_2$代表时间趋势，即控制组从干预前到干预后时期的平均结果变化。\n- $\\beta_3$是交互项$D_i T_t$的系数。该系数捕捉了处理组相对于控制组的结果差异性变化，并且在数值上等同于ATE的DiD估计值。\n- $\\epsilon_{it}$是误差项。\n\n为了估计这些系数，我们采用普通最小二乘法（OLS）。我们根据面板数据构建一个设计矩阵$X$和一个结果向量$Y$。对于总共$M$个观测值（来自$N_C$个控制单位和$N_T$个处理单位，每个单位观测两次，所以$M = 2(N_C + N_T)$），模型矩阵形式为：\n$$\nY = X\\beta + \\epsilon\n$$\n这里，$Y$是一个$M \\times 1$的结果向量，$X$是一个$M \\times 4$的设计矩阵，$\\beta$是$4 \\times 1$的系数向量$[\\beta_0, \\beta_1, \\beta_2, \\beta_3]^\\top$，$\\epsilon$是$M \\times 1$的误差向量。$X$的每一行对应一个观测$(i,t)$，形式为$[1, D_i, T_t, D_i T_t]$。\n\n$\\beta$的OLS估计量由以下公式给出：\n$$\n\\hat{\\beta} = (X^\\top X)^{-1} X^\\top Y\n$$\nATE由$\\hat{\\beta}_3$估计，即$\\hat{\\beta}$向量的第四个元素。\n\n为了进行统计推断，我们必须计算$\\hat{\\beta}_3$的标准误。问题指定了异方差稳健标准误，特别是HC$3$变体。这是必要的，因为同方差性（$\\epsilon_{it}$的方差恒定）的假设在实践中常常被违反。$\\hat{\\beta}$的稳健协方差矩阵是使用三明治估计量来估计的。\n\n首先，我们计算OLS残差$u = Y - X\\hat{\\beta}$。然后，我们计算帽子矩阵$H = X(X^\\top X)^{-1}X^\\top$，它将$Y$投影到由$X$的列所张成的空间上。$H$的对角线元素，记为$h_i$，是每个观测值的杠杆值。\n\nHC$3$估计量使用这些杠杆值来调整残差的平方。形成一个对角矩阵$S$，其对角线元素为：\n$$\ns_{ii} = \\left(\\frac{u_i}{1 - h_i}\\right)^2\n$$\n其中$u_i$是第$i$个残差，$h_i$是第$i$个杠杆值。已知这种调整在小样本中比其他变体（如HC$0$或HC$1$）表现更好。\n\n$\\hat{\\beta}$的HC$3$稳健协方差矩阵估计量为：\n$$\nV_{HC3} = (X^\\top X)^{-1} (X^\\top S X) (X^\\top X)^{-1}\n$$\nATE估计值的标准误$SE(\\hat{\\beta}_3)$是这个$V_{HC3}$矩阵第四个对角元素的平方根。\n\n算法流程如下：\n1. 对于每个测试案例，将数据组装成一个单一的结果向量$Y$和一个设计矩阵$X$。\n2. 使用矩阵公式计算OLS系数向量$\\hat{\\beta}$。ATE是第四个元素。\n3. 从帽子矩阵计算OLS残差$u$和杠杆值$h_i$。\n4. 使用三明治公式构建HC$3$协方差矩阵$V_{HC3}$。\n5. 提取$V_{HC3}$第四个对角元素的平方根，以获得ATE的稳健标准误。\n6. 将ATE及其标准误四舍五入到$6$位小数，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the difference-in-differences estimator with HC3 robust standard errors.\n    \"\"\"\n    test_cases = [\n        # Case 1: general case with positive treatment effect\n        {\n            \"control_pre\": [0.62, 0.58, 0.60, 0.65, 0.61],\n            \"control_post\": [0.64, 0.59, 0.61, 0.66, 0.62],\n            \"treated_pre\": [0.55, 0.57, 0.56, 0.54, 0.58],\n            \"treated_post\": [0.60, 0.63, 0.62, 0.61, 0.64]\n        },\n        # Case 2: boundary case with zero average treatment effect under parallel trends\n        {\n            \"control_pre\": [0.50, 0.52, 0.51],\n            \"control_post\": [0.55, 0.57, 0.56],\n            \"treated_pre\": [0.49, 0.53, 0.50, 0.52],\n            \"treated_post\": [0.54, 0.58, 0.55, 0.57]\n        },\n        # Case 3: edge case with heteroskedastic outcomes and imbalanced group sizes\n        {\n            \"control_pre\": [0.70, 0.68, 0.69, 0.71, 0.67, 0.70],\n            \"control_post\": [0.69, 0.69, 0.70, 0.72, 0.68, 0.71],\n            \"treated_pre\": [0.60, 0.61, 0.59],\n            \"treated_post\": [0.66, 0.64, 0.65]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack data for the current test case\n        control_pre = case[\"control_pre\"]\n        control_post = case[\"control_post\"]\n        treated_pre = case[\"treated_pre\"]\n        treated_post = case[\"treated_post\"]\n\n        # Step 1: Construct the Y vector and X matrix\n        observations = []\n        # Control group, pre-period (D=0, T=0)\n        for y_val in control_pre:\n            observations.append({'y': y_val, 'd': 0, 't': 0})\n        # Control group, post-period (D=0, T=1)\n        for y_val in control_post:\n            observations.append({'y': y_val, 'd': 0, 't': 1})\n        # Treated group, pre-period (D=1, T=0)\n        for y_val in treated_pre:\n            observations.append({'y': y_val, 'd': 1, 't': 0})\n        # Treated group, post-period (D=1, T=1)\n        for y_val in treated_post:\n            observations.append({'y': y_val, 'd': 1, 't': 1})\n\n        num_obs = len(observations)\n        Y = np.array([obs['y'] for obs in observations]).reshape(num_obs, 1)\n        X = np.array([[1, obs['d'], obs['t'], obs['d'] * obs['t']] for obs in observations], dtype=float)\n\n        # Step 2: Estimate coefficients by Ordinary Least Squares (OLS)\n        XtX = X.T @ X\n        XtX_inv = np.linalg.inv(XtX)\n        XtY = X.T @ Y\n        beta_hat = XtX_inv @ XtY\n\n        # The Average Treatment Effect (ATE) is the coefficient on the interaction term\n        ate = beta_hat[3, 0]\n\n        # Step 3: Compute robust standard errors (HC3)\n        # Residuals\n        residuals = Y - (X @ beta_hat)\n\n        # Hat matrix and leverages\n        hat_matrix = X @ XtX_inv @ X.T\n        leverages = np.diag(hat_matrix)\n\n        # HC3 adjustment: u_i / (1 - h_i)\n        u_flat = residuals.flatten()\n        h_flat = leverages.flatten()\n        \n        # Guard against division by zero, although not expected with this design\n        h_flat[h_flat = 1.0] = 1.0 - 1e-9 # Numerical stability\n        \n        s_diag = (u_flat / (1 - h_flat))**2\n\n        # \"Meat\" of the sandwich estimator: X' S X\n        # For diagonal S, this is sum(s_ii * x_i' * x_i) which can be computed efficiently\n        omega = (X.T * s_diag) @ X\n\n        # \"Sandwich\" the \"meat\" with the \"bread\": (X'X)^-1 (X' S X) (X'X)^-1\n        vcov_hc3 = XtX_inv @ omega @ XtX_inv\n\n        # The standard error is the square root of the diagonal element for the interaction term\n        se_ate = np.sqrt(vcov_hc3[3, 3])\n\n        results.append([ate, se_ate])\n\n    # Final print statement in the exact required format\n    formatted_results = [f\"[{round(ate, 6):.6f},{round(se, 6):.6f}]\" for ate, se in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}