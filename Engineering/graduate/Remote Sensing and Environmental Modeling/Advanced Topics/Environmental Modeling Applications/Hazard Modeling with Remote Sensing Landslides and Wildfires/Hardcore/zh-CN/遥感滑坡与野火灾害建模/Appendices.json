{
    "hands_on_practices": [
        {
            "introduction": "在利用遥感技术进行滑坡等灾害制图时，一个最基本的问题是：我们能看到多小的地物？这个问题的答案取决于传感器的空间分辨率。本练习将引导你从第一性原理出发，基于卫星高度和传感器视场等核心参数，推导并计算地面采样距离（Ground Sampling Distance, GSD），并将其与确定可识别的最小滑坡面积这一实际应用联系起来。通过这个实践，你将掌握评估遥感数据探测能力的基础方法。",
            "id": "3819344",
            "problem": "卫星上搭载的一台天底观测光学帧传感器用于绘制山区地形的滑坡。假设观测点处为局部平坦地形，镜头畸变可以忽略不计，且探测器像素为正方形，因此在天底点的地面投影是正方形。平台在离地 $H = 700{,}000\\,\\mathrm{m}$ 的恒定高度飞行。该传感器的水平全视场角为 $\\Phi_{x} = 15^\\circ$，探测器阵列为正方形，水平（跨轨）方向有 $N_{x} = 6000$ 个像素，垂直（沿轨）方向有 $N_{y} = 6000$ 个像素。角度以度为单位。\n\n从针孔相机模型和基本三角关系出发，根据 $H$、$\\Phi_{x}$ 和 $N_{x}$ 推导出天底点处水平方向的地面采样距离（Ground Sampling Distance, GSD）。然后，根据业务化遥感中针对多边形地物的保守最小制图单元标准，即一个滑坡必须至少占据一个 $3 \\times 3$ 的连续像素簇才能被可靠地勾画出来，计算最小可制图滑坡面积（以平方米为单位）。\n\n将最终面积以 $\\mathrm{m^2}$ 表示，并将您的答案四舍五入到四位有效数字。最终的数值答案必须是一个单独的数字。",
            "solution": "该问题要求推导星载光学传感器在天底点的地面采样距离（GSD），并基于指定标准计算最小可制图滑坡面积。这个问题提法明确且有科学依据。我们将首先使用针孔相机模型推导所需公式，然后计算数值结果。\n\n设 $H$ 为卫星离地的恒定高度。设 $\\Phi_{x}$ 为传感器的水平全视场角，设 $N_{x}$ 为相应水平方向（跨轨）的探测器像素数。我们假设观测点处为局部平坦地形。\n\n根据针孔相机模型，位于高度 $H$ 的传感器观测到的地面总刈幅宽度，我们记为 $W_x$。传感器、地面上的天底点和刈幅的一侧边缘构成一个直角三角形。传感器处，天底线与到刈幅边缘的视线之间的夹角是全视场角的一半，即 $\\frac{\\Phi_{x}}{2}$。该角的对边是地面上的一半刈幅宽度，即 $\\frac{W_x}{2}$。该角的邻边是高度 $H$。\n\n根据基本三角关系，我们可以写出：\n$$\n\\tan\\left(\\frac{\\Phi_{x}}{2}\\right) = \\frac{\\frac{W_x}{2}}{H}\n$$\n解出总刈幅宽度 $W_x$，我们得到：\n$$\nW_x = 2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)\n$$\n地面采样距离（GSD）是单个探测器像素所覆盖的地面区域的尺寸。对于天底观测情况，我们可以通过将总刈幅宽度 $W_x$ 除以该方向上的像素数 $N_x$ 来求得水平方向的 GSD，即 $GSD_x$。\n$$\nGSD_x = \\frac{W_x}{N_x}\n$$\n代入 $W_x$ 的表达式，我们得到用给定参数表示的天底点 GSD 的推导公式：\n$$\nGSD_x = \\frac{2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)}{N_{x}}\n$$\n至此，问题的推导部分完成。\n\n接下来，我们需要计算最小可制图滑坡面积。问题规定，一个滑坡必须至少占据一个 $3 \\times 3$ 的连续像素簇才能被可靠地勾画出来。问题还指出，天底点的地面投影是正方形，这意味着水平（跨轨）和垂直（沿轨）方向的 GSD 是相同的。我们将这个共同的 GSD 记为 $GSD = GSD_x$。因此，单个像素的地面投影面积为 $A_{\\text{pixel}} = GSD^2$。\n\n最小可制图面积 $A_{\\min}$ 对应于一个 $3 \\times 3$ 像素簇的面积。该像素簇由 $3 \\times 3 = 9$ 个像素组成。因此，最小面积为：\n$$\nA_{\\min} = 9 \\times A_{\\text{pixel}} = 9 \\times GSD^2\n$$\n代入推导出的 $GSD = GSD_x$ 表达式：\n$$\nA_{\\min} = 9 \\left( \\frac{2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)}{N_{x}} \\right)^2\n$$\n现在我们代入给定的数值：\n- 高度: $H = 700000\\,\\mathrm{m}$\n- 水平全视场角: $\\Phi_{x} = 15^\\circ$\n- 水平像素数: $N_{x} = 6000$\n\n首先，我们计算 GSD 的值：\n$$\nGSD = \\frac{2 \\times 700000 \\times \\tan\\left(\\frac{15^\\circ}{2}\\right)}{6000} = \\frac{1400000 \\times \\tan(7.5^\\circ)}{6000} = \\frac{700}{3} \\tan(7.5^\\circ)\n$$\n现在，我们计算最小可制图面积 $A_{\\min}$：\n$$\nA_{\\min} = 9 \\times \\left( \\frac{700}{3} \\tan(7.5^\\circ) \\right)^2\n$$\n$$\nA_{\\min} = 9 \\times \\frac{700^2}{3^2} \\times (\\tan(7.5^\\circ))^2\n$$\n$$\nA_{\\min} = 9 \\times \\frac{490000}{9} \\times (\\tan(7.5^\\circ))^2\n$$\n$$\nA_{\\min} = 490000 \\times (\\tan(7.5^\\circ))^2\n$$\n使用计算器计算 $\\tan(7.5^\\circ)$ 的值：\n$$\n\\tan(7.5^\\circ) \\approx 0.13165249758\n$$\n$$\n(\\tan(7.5^\\circ))^2 \\approx 0.01733238622\n$$\n将此值代回 $A_{\\min}$ 的表达式中：\n$$\nA_{\\min} \\approx 490000 \\times 0.01733238622 \\approx 8492.869248\\,\\mathrm{m^2}\n$$\n问题要求将最终答案四舍五入到四位有效数字。计算值为 $8492.869248$。第五位有效数字是 $8$，所以我们将第四位数字向上取整。\n$$\nA_{\\min} \\approx 8493\\,\\mathrm{m^2}\n$$",
            "answer": "$$\\boxed{8493}$$"
        },
        {
            "introduction": "有效的灾害建模通常需要融合多种数据源，并校正环境因素造成的偏差。本练习将这一理念应用于火灾后评估，引导你通过编程，利用数字高程模型（DEM）和太阳几何信息来生成地形阴影掩膜。通过这个综合实践，你将亲身体会未经校正的地形阴影如何影响归一化燃烧指数（NBR）等光谱指数的准确性，并学习如何通过基于物理的校正方法来提高火烧严重程度制图的可靠性。",
            "id": "3819382",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，该程序使用数字高程模型（DEM）和太阳几何结构为光学影像构建地形阴影掩膜，然后量化其对基于光谱指数的燃烧严重程度估算的影响。该程序必须计算一个物理上一致的地形阴影掩膜，该掩膜能捕捉由地形引起的自遮蔽阴影和投射阴影，并且必须评估阴影如何对火后光谱测量产生偏差，以及如何在基于物理的模型下进行校正。工作应完全在二维网格（栅格）域中进行，采用右手笛卡尔坐标系，其中 $x$ 轴指向地理正东，$y$ 轴指向地理正北，$z$ 轴指向上方。角度必须以度为单位提供和使用。所有量都必须使用此处定义的单位表示：距离以米为单位，角度以度为单位，反射率作为无单位的十进制值。\n\n从以下基本基础开始：\n\n- 地形由一个数字高程模型（DEM）网格化表面 $z(x,y)$ 表示，该表面在一个间距为 $\\Delta$ 的规则网格上采样，其中 $\\Delta$ 是像素大小（假设 $\\Delta$ 是恒定的）。\n- 对于平滑表面，局部单位法向量 $\\mathbf{n}(x,y)$ 可以从偏导数 $\\partial z / \\partial x$ 和 $\\partial z / \\partial y$ 导出，通过 $\\mathbf{n} \\propto \\left(-\\frac{\\partial z}{\\partial x}, -\\frac{\\partial z}{\\partial y}, 1\\right)$，然后进行归一化。\n- 太阳几何由太阳高度角 $\\theta_e$（地平线以上角度）和太阳方位角 $\\phi$（从地理正北顺时针测量角度）表示。太阳方向单位向量 $\\mathbf{s}$，从表面位置指向太阳，由太阳天顶角 $\\theta_z = 90^\\circ - \\theta_e$ 和方位角 $\\phi$ 通过与所述坐标轴约定一致的标准方向余弦定义。\n- 局部入射余弦为 $\\cos i = \\mathbf{n} \\cdot \\mathbf{s}$。如果 $\\cos i \\le 0$，则表面处于自遮蔽阴影中（无直接光照）。\n- 当地形阻挡了沿太阳方位角方向的太阳视线时，会产生投射阴影。对于一个位于高程 $z_0$ 和沿逆太阳方向的水平地面投影距离为 $d$ 的给定像素，定义地平线角 $\\alpha(d) = \\arctan\\left( \\frac{z(d) - z_0}{d} \\right)$。如果沿朝向太阳的光线遇到的最大地平线角 $\\alpha_{\\max}$ 满足 $\\alpha_{\\max} > \\theta_e$，则该像素处于投射阴影中。\n- 根据朗伯余弦定律，近朗伯表面在直接光照下的光学表面反射率与 $\\cos i$ 成比例。一种广泛使用的一阶地形校正方法是将反射率 $R$ 按比例因子 $1/\\cos i$ 进行重新缩放，并通过场景平均光照进行归一化，以保持整体亮度。\n\n仅使用这些基础，实现一个算法，该算法：\n\n1.  使用有限差分法，从提供的DEM为每个网格单元计算局部地形单位法向量 $\\mathbf{n}$，该方法需遵循所述的坐标轴方向和像素间距 $\\Delta$。\n2.  通过结合自遮蔽阴影和投射阴影，构建一个二进制地形阴影掩膜。对于自遮蔽阴影，使用准则 $\\cos i \\le 0$。对于投射阴影，通过沿太阳方位角方向进行追踪，并使用DEM的双线性插值来评估 $\\alpha(d)$，然后与 $\\theta_e$ 进行比较，从而估算地平线角。\n3.  以十进制形式量化阴影像素的比例。\n4.  使用近红外（NIR）和短波红外（SWIR）反射率计算火前和火后条件下的归一化燃烧指数（NBR），然后计算归一化燃烧指数差值（dNBR），即火前NBR减去火后NBR。使用NBR的常规定义，该定义源自植被和炭黑在NIR和SWIR反射率上经过充分检验的对比度，即 $ \\mathrm{NBR} = \\frac{\\mathrm{NIR} - \\mathrm{SWIR}}{\\mathrm{NIR} + \\mathrm{SWIR}} $，以及 $ \\mathrm{dNBR} = \\mathrm{NBR}_{\\text{pre}} - \\mathrm{NBR}_{\\text{post}} $。如果分母 $\\mathrm{NIR} + \\mathrm{SWIR}$ 等于零，则将该像素的结果视为未定义。\n5.  使用 $\\cos i$ 对火后反射率应用基于余弦的地形校正，使得 $R_{\\text{corr}} = R \\cdot \\frac{\\overline{\\cos i}}{\\cos i}$，其中 $\\overline{\\cos i}$ 是所有 $\\cos i > 0$ 的光照像素上的平均 $\\cos i$。然后重新计算NBR和dNBR。为避免非物理缩放，将校正后的反射率限制在闭区间 $[0,1]$ 内，并将 $\\cos i \\le 0$ 的情况替换为一个微小正常数以避免除以零。这代表了一阶影响，即地形引起的阴影会降低观测到的反射率，并可能夸大估算的燃烧严重程度；校正旨在减轻这种偏差。\n\n测试套件规范：\n\n为三个测试用例实现该算法，这三个用例共同涵盖了典型条件、边界行为和边缘情况。对于所有情况，像素大小为 $\\Delta = 30\\ \\text{m}$。\n\n- 案例 1（中等坡度，中等太阳高度）：\n  - 太阳方位角 $\\phi = 135^\\circ$，太阳高度角 $\\theta_e = 35^\\circ$。\n  - DEM为一个 $5\\times 5$ 的高程网格（单位：米）：\n    $$\n    \\begin{bmatrix}\n    100  102  104  106  108 \\\\\n    100  103  106  109  112 \\\\\n    100  104  108  112  116 \\\\\n    100  105  110  115  120 \\\\\n    100  106  112  118  124\n    \\end{bmatrix}\n    $$\n  - 火前NIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.52  0.50  0.48  0.46  0.44 \\\\\n    0.53  0.51  0.49  0.47  0.45 \\\\\n    0.54  0.52  0.50  0.48  0.46 \\\\\n    0.55  0.53  0.51  0.49  0.47 \\\\\n    0.56  0.54  0.52  0.50  0.48\n    \\end{bmatrix}\n    $$\n  - 火前SWIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.22  0.22  0.23  0.24  0.25 \\\\\n    0.21  0.21  0.22  0.23  0.24 \\\\\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.18  0.18  0.19  0.20  0.21\n    \\end{bmatrix}\n    $$\n  - 火后NIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.36  0.34  0.32  0.30  0.28 \\\\\n    0.35  0.33  0.31  0.29  0.27 \\\\\n    0.34  0.32  0.30  0.28  0.26 \\\\\n    0.33  0.31  0.29  0.27  0.25 \\\\\n    0.32  0.30  0.28  0.26  0.24\n    \\end{bmatrix}\n    $$\n  - 火后SWIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.30  0.31  0.32  0.33  0.34 \\\\\n    0.31  0.32  0.33  0.34  0.35 \\\\\n    0.32  0.33  0.34  0.35  0.36 \\\\\n    0.33  0.34  0.35  0.36  0.37 \\\\\n    0.34  0.35  0.36  0.37  0.38\n    \\end{bmatrix}\n    $$\n\n- 案例 2（陡坡，极低太阳高度，预计有大量阴影）：\n  - 太阳方位角 $\\phi = 270^\\circ$，太阳高度角 $\\theta_e = 5^\\circ$。\n  - DEM为一个 $5\\times 5$ 的高程网格（单位：米）：\n    $$\n    \\begin{bmatrix}\n    120  118  116  114  112 \\\\\n    122  120  118  116  114 \\\\\n    124  122  120  118  116 \\\\\n    126  124  122  120  118 \\\\\n    128  126  124  122  120\n    \\end{bmatrix}\n    $$\n  - 火前NIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.60  0.58  0.56  0.54  0.52 \\\\\n    0.61  0.59  0.57  0.55  0.53 \\\\\n    0.62  0.60  0.58  0.56  0.54 \\\\\n    0.63  0.61  0.59  0.57  0.55 \\\\\n    0.64  0.62  0.60  0.58  0.56\n    \\end{bmatrix}\n    $$\n  - 火前SWIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.18  0.18  0.19  0.20  0.21\n    \\end{bmatrix}\n    $$\n  - 火后NIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.40  0.38  0.36  0.34  0.32 \\\\\n    0.41  0.39  0.37  0.35  0.33 \\\\\n    0.42  0.40  0.38  0.36  0.34 \\\\\n    0.43  0.41  0.39  0.37  0.35 \\\\\n    0.44  0.42  0.40  0.38  0.36\n    \\end{bmatrix}\n    $$\n  - 火后SWIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.32  0.33  0.34  0.35  0.36 \\\\\n    0.33  0.34  0.35  0.36  0.37 \\\\\n    0.34  0.35  0.36  0.37  0.38 \\\\\n    0.35  0.36  0.37  0.38  0.39 \\\\\n    0.36  0.37  0.38  0.39  0.40\n    \\end{bmatrix}\n    $$\n\n- 案例 3（平坦地形，高太阳高度，预计阴影极少）：\n  - 太阳方位角 $\\phi = 0^\\circ$，太阳高度角 $\\theta_e = 80^\\circ$。\n  - DEM为一个 $5\\times 5$ 的高程网格（单位：米）：\n    $$\n    \\begin{bmatrix}\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100\n    \\end{bmatrix}\n    $$\n  - 火前NIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55\n    \\end{bmatrix}\n    $$\n  - 火前SWIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20\n    \\end{bmatrix}\n    $$\n  - 火后NIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35\n    \\end{bmatrix}\n    $$\n  - 火后SWIR反射率：\n    $$\n    \\begin{bmatrix}\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33\n    \\end{bmatrix}\n    $$\n\n所需输出及格式：\n\n对于三个案例中的每一个，计算并返回一个三元组值：\n\n- 阴影像素的比例，以 $[0,1]$ 区间内的十进制数表示。\n- 从未经校正的火后反射率计算出的 $\\mathrm{dNBR}$ 的空间平均值，以浮点数表示。\n- 从经过地形校正的火后反射率计算出的 $\\mathrm{dNBR}$ 的空间平均值，以浮点数表示。\n\n您的程序应生成单行输出，其中包含九个结果（每个案例三个，按案例 1、案例 2、案例 3 的顺序排列），形式为一个逗号分隔的列表，并用方括号括起来，例如 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_9]$。",
            "solution": "用户在遥感和地貌分析领域提供了一个定义明确的问题。任务是模拟地形阴影并评估其对一种常用光谱指数——用于量化野火燃烧严重程度的归一化燃烧指数差值（dNBR）——的影响。该问题在科学上是合理的、内部一致的，并包含了所有必要的数据和物理公式，可以着手给出一个唯一且可验证的解。\n\n解决方案将通过实施一系列基于物理的计算步骤来开发：\n1.  **几何设置**：我们将首先建立几何框架。这包括根据给定的太阳方位角和高度角定义太阳方向向量，以及根据数字高程模型（DEM）计算地形表面法向量。\n2.  **阴影建模**：然后，我们将构建一个二进制阴影掩膜。这涉及两种不同的物理机制：\n    *   **自遮蔽阴影**：如果局部表面法线背向太阳，则该表面元素处于自遮蔽阴影中。这通过检查表面法向量与太阳方向向量的点积是否为非正值来确定。\n    *   **投射阴影**：如果朝向太阳的视线被中间的较高地形阻挡，则表面元素处于投射阴影中。这通过从目标像素向太阳方向追踪一条光线，并检查沿该光线遇到的最大地形地平线角是否超过太阳的高度角来确定。\n3.  **光谱指数计算（未校正）**：我们将使用提供的反射率数据计算火前和火后条件下的归一化燃烧指数（NBR）。然后，其变化量 dNBR 被计算为火前 NBR 和火后 NBR 之差。\n4.  **地形校正**：为了减轻阴影对反射率的偏置效应，将对火后反射率数据应用一阶余弦校正。该方法根据局部太阳光照角重新缩放观测到的反射率。\n5.  **光谱指数计算（校正后）**：使用经过地形校正的火后反射率重新计算 NBR 和 dNBR。\n6.  **分析**：最后，对于每个测试用例，我们将报告总阴影像素的比例、校正前的平均 dNBR 和校正后的平均 dNBR。这将展示地形校正的定量影响。\n\n每个步骤的实现细节如下：\n\n**步骤 1：地形和太阳几何**\n\n*   **坐标系**：我们在一个右手笛卡尔坐标系中操作，其中 $x$ 轴指向东，$y$ 轴指向北，$z$ 轴指向上。输入 DEM 矩阵的索引 `(row, col)` 映射到该系统，使得增加的列索引对应于增加的 $x$（东），而增加的行索引对应于减少的 $y$（南）。\n*   **太阳向量 ($\\mathbf{s}$)**：太阳方位角 $\\phi$（从北方顺时针）和高度角 $\\theta_e$ 被转换为一个指向太阳的单位向量 $\\mathbf{s}$。太阳天顶角为 $\\theta_z = 90^\\circ - \\theta_e$。在我们的坐标系中，$\\mathbf{s}$ 的分量是：\n    $$\n    s_x = \\sin(\\theta_z) \\sin(\\phi) \\\\\n    s_y = \\sin(\\theta_z) \\cos(\\phi) \\\\\n    s_z = \\cos(\\theta_z)\n    $$\n*   **表面法向量 ($\\mathbf{n}$)**：高程表面的偏导数 $\\frac{\\partial z}{\\partial x}$ 和 $\\frac{\\partial z}{\\partial y}$ 使用二阶中心有限差分格式近似计算，如 `numpy.gradient` 所实现。考虑到我们的网格方向，其中行索引与 $y$ 方向反平行，我们有 $\\frac{\\partial z}{\\partial y} = -\\frac{\\partial z}{\\partial(\\text{row} \\cdot \\Delta)}$。未归一化的法向量为 $\\mathbf{n}' = (-\\frac{\\partial z}{\\partial x}, -\\frac{\\partial z}{\\partial y}, 1)$，然后对每个像素进行归一化至单位长度。\n\n**步骤 2：阴影掩膜构建**\n\n*   **自遮蔽阴影掩膜**：局部太阳入射角的余弦计算为 $\\cos i = \\mathbf{n} \\cdot \\mathbf{s}$。$\\cos i \\le 0$ 的像素被标记为自遮蔽阴影。\n*   **投射阴影掩膜**：对于每个像素 $(r,c)$，其初始高程为 $z_0$，我们沿逆太阳方向在 DEM 上追踪一条光线。逆太阳的地面投影方向为 $( -s_x, -s_y )$。我们使用双线性插值（`scipy.ndimage.map_coordinates`）沿此光线以距离 $d$ 采样高程 $z(d)$。对于光线上的每一点，计算地平线角 $\\alpha(d) = \\arctan\\left( \\frac{z(d) - z_0}{d} \\right)$。如果找到的最大地平线角 $\\alpha_{\\max}$ 大于太阳高度角 $\\theta_e$，则像素 $(r,c)$ 处于投射阴影中。\n*   **最终阴影掩膜**：最终的阴影掩膜是自遮蔽阴影掩膜和投射阴影掩膜的逻辑或。阴影比例是此布尔掩膜的平均值。\n\n**步骤 3、4：NBR 计算和地形校正**\n\n*   **NBR 和 dNBR**：这些指数使用其标准定义计算：\n    $$ \\mathrm{NBR} = \\frac{\\mathrm{NIR} - \\mathrm{SWIR}}{\\mathrm{NIR} + \\mathrm{SWIR}}, \\quad \\mathrm{dNBR} = \\mathrm{NBR}_{\\text{pre}} - \\mathrm{NBR}_{\\text{post}} $$\n    $\\mathrm{NIR} + \\mathrm{SWIR} = 0$ 的像素会导致未定义的 NBR (`NaN`)，在计算平均值时将被忽略。\n*   **余弦校正**：火后反射率 ($R$) 使用以下公式进行校正：\n    $$ R_{\\text{corr}} = R \\cdot \\frac{\\overline{\\cos i}}{\\cos i} $$\n    这里，$\\overline{\\cos i}$ 是所有光照像素（$\\cos i > 0$）上 $\\cos i$ 的平均值。为防止对阴影像素除以零，将 $\\le 0$ 的 `cos i` 值替换为一个微小正常数（$\\epsilon=10^{-6}$）。得到的校正后反射率被裁剪到物理上有意义的范围 $[0, 1]$ 内。\n\n**步骤 5：校正后的 dNBR 计算**\n然后，使用校正后的火后 NIR 和 SWIR 反射率重新计算 NBR 和 dNBR，并求出新的平均 dNBR。这整个过程将应用于问题中指定的三个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and aggregate results for all test cases.\n    \"\"\"\n\n    def calculate_nbr(nir, swir):\n        \"\"\"Computes the Normalized Burn Ratio (NBR).\"\"\"\n        numerator = nir - swir\n        denominator = nir + swir\n        # Handle division by zero by setting result to NaN\n        nbr = np.divide(numerator, denominator, out=np.full_like(numerator, np.nan, dtype=float), where=denominator != 0)\n        return nbr\n\n    def solve_single_case(dem, pre_nir, pre_swir, post_nir, post_swir, phi_deg, theta_e_deg, delta):\n        \"\"\"\n        Processes a single test case to compute shadow fraction and dNBR values.\n        \"\"\"\n        N_rows, N_cols = dem.shape\n        epsilon = 1e-6\n\n        # Step 1: Compute terrain and solar geometry\n        # Solar vector s (pointing towards the sun)\n        phi_rad = np.deg2rad(phi_deg)\n        theta_e_rad = np.deg2rad(theta_e_deg)\n        theta_z_rad = np.pi / 2.0 - theta_e_rad\n\n        s_x = np.sin(theta_z_rad) * np.sin(phi_rad)\n        s_y = np.sin(theta_z_rad) * np.cos(phi_rad)\n        s_z = np.cos(theta_z_rad)\n        \n        # Surface normal vector n\n        # np.gradient returns gradients along each axis.\n        # axis 0 (rows) corresponds to the -y (South) direction.\n        # axis 1 (cols) corresponds to the +x (East) direction.\n        grad_y_neg, grad_x = np.gradient(dem, delta)\n        dz_dx = grad_x\n        dz_dy = -grad_y_neg\n\n        nx_un = -dz_dx\n        ny_un = -dz_dy\n        nz_un = np.ones_like(dem)\n        \n        norm = np.sqrt(nx_un**2 + ny_un**2 + nz_un**2)\n        nx = nx_un / norm\n        ny = ny_un / norm\n        nz = nz_un / norm\n\n        # Step 2: Construct shadow mask\n        # Self-shadowing\n        cos_i = nx * s_x + ny * s_y + nz * s_z\n        self_shadow_mask = cos_i = 0\n\n        # Cast-shadowing\n        cast_shadow_mask = np.zeros_like(dem, dtype=bool)\n        \n        # Ray-tracing direction in pixel coordinates (col, row)\n        # up-sun direction in world coords is (-sx, -sy)\n        # map to pixel-coord direction: col maps to x, row maps to -y\n        # change in col is proportional to -sx; change in row is proportional to sy\n        ray_dir_pix = np.array([-s_x, s_y])\n        ray_norm = np.linalg.norm(ray_dir_pix)\n\n        if ray_norm > epsilon:\n            ray_dir_norm = ray_dir_pix / ray_norm\n            \n            for r in range(N_rows):\n                for c in range(N_cols):\n                    z0 = dem[r, c]\n                    max_horizon_angle = -np.pi  # rad\n                    \n                    dist_pix = 0.5  # start tracing half a pixel away\n                    while True:\n                        # Position to sample in pixel coordinates\n                        c_trace = c + dist_pix * ray_dir_norm[0]\n                        r_trace = r + dist_pix * ray_dir_norm[1]\n\n                        if not (0 = c_trace  N_cols and 0 = r_trace  N_rows):\n                            break\n                        \n                        # Use bilinear interpolation (order=1)\n                        z_trace = ndimage.map_coordinates(dem, [[r_trace], [c_trace]], order=1, cval=-np.inf)[0]\n\n                        if z_trace == -np.inf:\n                            break\n\n                        dist_world = dist_pix * delta\n                        \n                        # arctan2 handles quadrants, but dist_world is always positive\n                        horizon_angle = np.arctan2(z_trace - z0, dist_world)\n                        if horizon_angle > max_horizon_angle:\n                            max_horizon_angle = horizon_angle\n\n                        dist_pix += 0.5 # step size of half a pixel\n\n                    if np.rad2deg(max_horizon_angle) > theta_e_deg:\n                        cast_shadow_mask[r, c] = True\n        \n        shadow_mask = np.logical_or(self_shadow_mask, cast_shadow_mask)\n        shadow_fraction = np.mean(shadow_mask)\n\n        # Step 3: Compute uncorrected dNBR\n        nbr_pre = calculate_nbr(pre_nir, pre_swir)\n        nbr_post_uncorr = calculate_nbr(post_nir, post_swir)\n        dnbr_uncorr = nbr_pre - nbr_post_uncorr\n        mean_dnbr_uncorr = np.nanmean(dnbr_uncorr)\n\n        # Step 4  5: Apply correction and compute corrected dNBR\n        illuminated_mask = cos_i > 0\n        mean_cos_i = np.mean(cos_i[illuminated_mask]) if np.any(illuminated_mask) else 1.0\n\n        cos_i_corr = np.copy(cos_i)\n        cos_i_corr[cos_i = 0] = epsilon \n\n        correction_factor = mean_cos_i / cos_i_corr\n\n        post_nir_corr = np.clip(post_nir * correction_factor, 0, 1)\n        post_swir_corr = np.clip(post_swir * correction_factor, 0, 1)\n        \n        nbr_post_corr = calculate_nbr(post_nir_corr, post_swir_corr)\n        dnbr_corr = nbr_pre - nbr_post_corr\n        mean_dnbr_corr = np.nanmean(dnbr_corr)\n        \n        return shadow_fraction, mean_dnbr_uncorr, mean_dnbr_corr\n\n    # Define test cases from the problem statement\n    delta = 30.0\n    \n    test_cases = [\n        # Case 1 (moderate slopes, moderate sun)\n        {\n            \"phi_deg\": 135.0, \"theta_e_deg\": 35.0, \"delta\": delta,\n            \"dem\": np.array([\n                [100, 102, 104, 106, 108], [100, 103, 106, 109, 112], [100, 104, 108, 112, 116],\n                [100, 105, 110, 115, 120], [100, 106, 112, 118, 124]], dtype=float),\n            \"pre_nir\": np.array([\n                [0.52, 0.50, 0.48, 0.46, 0.44], [0.53, 0.51, 0.49, 0.47, 0.45], [0.54, 0.52, 0.50, 0.48, 0.46],\n                [0.55, 0.53, 0.51, 0.49, 0.47], [0.56, 0.54, 0.52, 0.50, 0.48]], dtype=float),\n            \"pre_swir\": np.array([\n                [0.22, 0.22, 0.23, 0.24, 0.25], [0.21, 0.21, 0.22, 0.23, 0.24], [0.20, 0.20, 0.21, 0.22, 0.23],\n                [0.19, 0.19, 0.20, 0.21, 0.22], [0.18, 0.18, 0.19, 0.20, 0.21]], dtype=float),\n            \"post_nir\": np.array([\n                [0.36, 0.34, 0.32, 0.30, 0.28], [0.35, 0.33, 0.31, 0.29, 0.27], [0.34, 0.32, 0.30, 0.28, 0.26],\n                [0.33, 0.31, 0.29, 0.27, 0.25], [0.32, 0.30, 0.28, 0.26, 0.24]], dtype=float),\n            \"post_swir\": np.array([\n                [0.30, 0.31, 0.32, 0.33, 0.34], [0.31, 0.32, 0.33, 0.34, 0.35], [0.32, 0.33, 0.34, 0.35, 0.36],\n                [0.33, 0.34, 0.35, 0.36, 0.37], [0.34, 0.35, 0.36, 0.37, 0.38]], dtype=float)\n        },\n        # Case 2 (steep slopes, low sun)\n        {\n            \"phi_deg\": 270.0, \"theta_e_deg\": 5.0, \"delta\": delta,\n            \"dem\": np.array([\n                [120, 118, 116, 114, 112], [122, 120, 118, 116, 114], [124, 122, 120, 118, 116],\n                [126, 124, 122, 120, 118], [128, 126, 124, 122, 120]], dtype=float),\n            \"pre_nir\": np.array([\n                [0.60, 0.58, 0.56, 0.54, 0.52], [0.61, 0.59, 0.57, 0.55, 0.53], [0.62, 0.60, 0.58, 0.56, 0.54],\n                [0.63, 0.61, 0.59, 0.57, 0.55], [0.64, 0.62, 0.60, 0.58, 0.56]], dtype=float),\n            \"pre_swir\": np.array([\n                [0.20, 0.20, 0.21, 0.22, 0.23], [0.20, 0.20, 0.21, 0.22, 0.23], [0.19, 0.19, 0.20, 0.21, 0.22],\n                [0.19, 0.19, 0.20, 0.21, 0.22], [0.18, 0.18, 0.19, 0.20, 0.21]], dtype=float),\n            \"post_nir\": np.array([\n                [0.40, 0.38, 0.36, 0.34, 0.32], [0.41, 0.39, 0.37, 0.35, 0.33], [0.42, 0.40, 0.38, 0.36, 0.34],\n                [0.43, 0.41, 0.39, 0.37, 0.35], [0.44, 0.42, 0.40, 0.38, 0.36]], dtype=float),\n            \"post_swir\": np.array([\n                [0.32, 0.33, 0.34, 0.35, 0.36], [0.33, 0.34, 0.35, 0.36, 0.37], [0.34, 0.35, 0.36, 0.37, 0.38],\n                [0.35, 0.36, 0.37, 0.38, 0.39], [0.36, 0.37, 0.38, 0.39, 0.40]], dtype=float)\n        },\n        # Case 3 (flat terrain, high sun)\n        {\n            \"phi_deg\": 0.0, \"theta_e_deg\": 80.0, \"delta\": delta,\n            \"dem\": np.full((5, 5), 100.0),\n            \"pre_nir\": np.full((5, 5), 0.55),\n            \"pre_swir\": np.full((5, 5), 0.20),\n            \"post_nir\": np.full((5, 5), 0.35),\n            \"post_swir\": np.full((5, 5), 0.33),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack dictionary to function arguments\n        case_results = solve_single_case(**case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}