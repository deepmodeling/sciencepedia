{
    "hands_on_practices": [
        {
            "introduction": "要掌握频域滤波，首先必须建立空间模式与其傅里叶谱之间直观的联系。本练习  将从第一性原理出发，推导一种代表最高空间频率的理想棋盘格模式的离散傅里叶变换（DFT）。通过这个基础性的推导，您将亲身体会一个纯粹的空间频率分量如何在频谱中表现为一个孤立的峰值，这对于识别和滤除遥感影像中的周期性伪影至关重要。",
            "id": "3813540",
            "problem": "在对农业镶嵌区进行航空遥感成像时，平台振动或探测器读出可能会产生周期性伪影，表现为记录的二维反射率场中的交替模式。考虑一个经正射校正的辐射图像的矩形图块，其维度 $M$ (行) 和 $N$ (列) 均为偶数，由空间样本 $m \\in \\{0,1,\\dots,M-1\\}$ 和 $n \\in \\{0,1,\\dots,N-1\\}$ 索引。假设存在一个条纹状棋盘格伪影，其模型为一个叠加在场景上的确定性模式 $x[m,n] = (-1)^{m+n}$，表示在两个方向上以最高可分辨频率进行的空间交替。令 $X[k,\\ell]$ 表示 $x[m,n]$ 的二维离散傅里叶变换 (DFT)，根据信号处理和遥感中的标准定义，\n$$\nX[k,\\ell] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} x[m,n] \\exp\\!\\Big(-\\mathrm{i} 2\\pi \\Big(\\frac{mk}{M} + \\frac{n\\ell}{N}\\Big)\\Big),\n$$\n其中频率指数为 $k \\in \\{0,1,\\dots,M-1\\}$ 和 $\\ell \\in \\{0,1,\\dots,N-1\\}$。从 DFT 的基本定义和关于几何级数的第一性原理出发，推导 DFT 幅值 $\\lvert X[k,\\ell] \\rvert$ 作为 $(k,\\ell)$、$M$ 和 $N$ 的函数的闭式表达式，并确定主导频率分量及其在频谱中的精确指数位置。使用克罗内克 δ 将最终答案表示为单个闭式解析表达式，不要使用任何数值近似或四舍五入。最终答案不需要物理单位。",
            "solution": "该问题要求推导代表棋盘格伪影的特定信号的二维离散傅里叶变换 (DFT) 的幅值。\n\n该信号定义在一个大小为 $M \\times N$ 的矩形网格上，其中 $M$ 和 $N$ 是偶数。空间指数为 $m \\in \\{0,1,\\dots,M-1\\}$ 和 $n \\in \\{0,1,\\dots,N-1\\}$。信号本身由下式给出\n$$\nx[m,n] = (-1)^{m+n}\n$$\n二维 DFT $X[k,\\ell]$ 对频率指数 $k \\in \\{0,1,\\dots,M-1\\}$ 和 $\\ell \\in \\{0,1,\\dots,N-1\\}$ 定义为\n$$\nX[k,\\ell] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} x[m,n] \\exp\\left(-\\mathrm{i} 2\\pi \\left(\\frac{mk}{M} + \\frac{n\\ell}{N}\\right)\\right)\n$$\n为了继续，我们首先使用欧拉恒等式 $e^{\\mathrm{i}\\pi} = -1$ 来表示信号项 $(-1)^{m+n}$。\n$$\nx[m,n] = (-1)^{m+n} = (e^{\\mathrm{i}\\pi})^{m+n} = e^{\\mathrm{i}\\pi(m+n)} = e^{\\mathrm{i}\\pi m} e^{\\mathrm{i}\\pi n}\n$$\n将其代入 DFT 定义中，得到：\n$$\nX[k,\\ell] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} (e^{\\mathrm{i}\\pi m} e^{\\mathrm{i}\\pi n}) \\exp\\left(-\\mathrm{i} 2\\pi \\frac{mk}{M}\\right) \\exp\\left(-\\mathrm{i} 2\\pi \\frac{n\\ell}{N}\\right)\n$$\n这个双重求和对于指数 $m$ 和 $n$ 是可分离的。我们可以将各项分组，并将表达式写成两个独立求和的乘积：\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} e^{\\mathrm{i}\\pi m} \\exp\\left(-\\mathrm{i} 2\\pi \\frac{mk}{M}\\right) \\right) \\left( \\sum_{n=0}^{N-1} e^{\\mathrm{i}\\pi n} \\exp\\left(-\\mathrm{i} 2\\pi \\frac{n\\ell}{N}\\right) \\right)\n$$\n让我们合并每个求和内部的指数：\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} \\exp\\left(\\mathrm{i}m\\left(\\pi - \\frac{2\\pi k}{M}\\right)\\right) \\right) \\left( \\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{i}n\\left(\\pi - \\frac{2\\pi \\ell}{N}\\right)\\right) \\right)\n$$\n从指数中提出因子 $2\\pi$：\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} \\exp\\left(\\mathrm{i} 2\\pi m \\left(\\frac{1}{2} - \\frac{k}{M}\\right)\\right) \\right) \\left( \\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{i} 2\\pi n \\left(\\frac{1}{2} - \\frac{\\ell}{N}\\right)\\right) \\right)\n$$\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} \\exp\\left(\\mathrm{i} 2\\pi m \\frac{M/2 - k}{M}\\right) \\right) \\left( \\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{i} 2\\pi n \\frac{N/2 - \\ell}{N}\\right) \\right)\n$$\n我们把第一个和记为 $S_M(k)$，第二个和記为 $S_N(\\ell)$。每个都是形式为 $\\sum_{j=0}^{P-1} r^j$ 的有限几何级数。如果 $r=1$，该级数的和为 $P$；如果 $r \\neq 1$，则为 $\\frac{1-r^P}{1-r}$。\n\n考虑求和 $S_M(k)$。公比为 $r_M = \\exp\\left(\\mathrm{i} 2\\pi \\frac{M/2 - k}{M}\\right)$。\n公比 $r_M$ 等于 $1$ 当且仅当其指数是 $2\\pi \\mathrm{i}$ 的整数倍。这意味着 $\\frac{M/2 - k}{M}$ 必须是一个整数。设这个整数为 $z$。\n$$\n\\frac{M/2 - k}{M} = z \\implies k = \\frac{M}{2} - zM\n$$\n由于 $k$必须在范围 $\\{0, 1, \\dots, M-1\\}$ 内，我们测试 $z$ 的整数值：\n- 如果 $z=0$, $k=M/2$。因为已知 $M$ 是偶数，所以 $M/2$ 是一个整数。对于 $M>0$，$0 \\le M/2  M$，所以这是一个有效的指数。\n- 如果 $z=1$, $k = M/2 - M = -M/2$，这超出了有效范围。\n- 如果 $z=-1$, $k = M/2 + M = 3M/2$，这超出了有效范围。\n因此，$r_M=1$ 仅在 $k=M/2$ 时出现。\n\n情况 1: $k = M/2$。\n在这种情况下，$r_M=1$，和等于项数：\n$$\nS_M(M/2) = \\sum_{m=0}^{M-1} (1)^m = M\n$$\n\n情况 2: $k \\neq M/2$。\n此时，$r_M \\neq 1$，所以我们使用几何级数求和的标准公式：\n$$\nS_M(k) = \\frac{1 - (r_M)^M}{1 - r_M}\n$$\n我们来计算 $(r_M)^M$ 这一项：\n$$\n(r_M)^M = \\left(\\exp\\left(\\mathrm{i} 2\\pi \\frac{M/2 - k}{M}\\right)\\right)^M = \\exp\\left(\\mathrm{i} 2\\pi (M/2 - k)\\right) = \\exp(\\mathrm{i}\\pi M - \\mathrm{i}2\\pi k)\n$$\n由于 $M$ 是一个偶数，存在某个整数 $p$ 使得 $M=2p$。因此，$\\exp(\\mathrm{i}\\pi M) = \\exp(\\mathrm{i}2\\pi p) = 1$。由于 $k$ 是一个整数，$\\exp(-\\mathrm{i}2\\pi k) = 1$。所以，$(r_M)^M = 1 \\cdot 1 = 1$。\n和的分子是 $1 - (r_M)^M = 1 - 1 = 0$。分母 $1 - r_M$ 不为零，因为 $k \\neq M/2$。\n$$\nS_M(k) = \\frac{0}{1 - r_M} = 0 \\quad \\text{for } k \\neq M/2\n$$\n\n结合两种情况，我们可以使用克罗内克 δ 符号 $\\delta_{ij}$ 来表示 $S_M(k)$，其中当 $i=j$ 时 $\\delta_{ij}=1$，否则为 $0$。\n$$\nS_M(k) = M \\delta_{k, M/2}\n$$\n通过完全类似的推理，由于 $N$ 也是一个偶数，求和 $S_N(\\ell)$ 为：\n$$\nS_N(\\ell) = N \\delta_{\\ell, N/2}\n$$\n现在，我们将两个和的结果相乘，得到完整的二维 DFT：\n$$\nX[k,\\ell] = S_M(k) S_N(\\ell) = (M \\delta_{k, M/2}) (N \\delta_{\\ell, N/2}) = MN \\delta_{k, M/2} \\delta_{\\ell, N/2}\n$$\n此表达式表明，除了单点 $(k, \\ell) = (M/2, N/2)$ 外，对于所有频率指数 $(k, \\ell)$，DFT 均为零。在该点，DFT 的值为 $MN$。\n\n因此，主导频率分量位于指数 $(k_0, \\ell_0) = (M/2, N/2)$ 处。这些指数对应于每个维度上的离散奈奎斯特频率，$f_k = k_0/M = 1/2$ 周期/样本 和 $f_\\ell = \\ell_0/N = 1/2$ 周期/样本，这代表了离散信号中可能出现的最高交替频率。这与输入信号 $x[m,n]=(-1)^{m+n}$ 是一个棋盘格模式相一致。\n\n最后一步是求 DFT 的幅值 $|X[k, \\ell]|$。由于 $M$ 和 $N$ 是正维度，它们的乘积 $MN$ 是一个正实数。克罗内克 δ 也是实数值的。\n$$\n|X[k,\\ell]| = |MN \\delta_{k, M/2} \\delta_{\\ell, N/2}| = MN |\\delta_{k, M/2} \\delta_{\\ell, N/2}| = MN \\delta_{k, M/2} \\delta_{\\ell, N/2}\n$$\n这就是 DFT 幅值的闭式解析表达式。",
            "answer": "$$\n\\boxed{MN \\delta_{k, M/2} \\delta_{\\ell, N/2}}\n$$"
        },
        {
            "introduction": "卷积定理是频域滤波的核心，它将复杂的空间域卷积运算转化为简单的频域乘法。本练习  将引导您动手实现遥感和环境建模中三种最基本的滤波器：用于抑制噪声的高斯低通滤波器、用于消除传感器条带的陷波滤波器以及用于分离特定方向特征的椭圆带通滤波器。完成此练习将使您能够熟练运用卷积定理解决实际的滤波问题。",
            "id": "3813486",
            "problem": "代表遥感场景的二维离散场可以使用离散傅里叶变换 (DFT) 在频域中进行滤波。考虑一个大小为 $N_x \\times N_y$ 的实值数组 $x[n_x,n_y]$，其索引为 $n_x \\in \\{0,1,\\dots,N_x-1\\}$ 和 $n_y \\in \\{0,1,\\dots,N_y-1\\}$。二维离散傅里叶变换 (DFT) 及其逆变换定义如下：\n$$\nX[k_x,k_y] = \\sum_{n_x=0}^{N_x-1}\\sum_{n_y=0}^{N_y-1} x[n_x,n_y] \\exp\\left(-2\\pi i\\left(\\frac{k_x n_x}{N_x}+\\frac{k_y n_y}{N_y}\\right)\\right),\n$$\n$$\nx[n_x,n_y] = \\frac{1}{N_x N_y} \\sum_{k_x=0}^{N_x-1}\\sum_{k_y=0}^{N_y-1} X[k_x,k_y] \\exp\\left(2\\pi i\\left(\\frac{k_x n_x}{N_x}+\\frac{k_y n_y}{N_y}\\right)\\right).\n$$\n令 $\\mathbf{k}=(k_x,k_y)$ 表示离散频率坐标。根据卷积定理，线性移不变空间滤波对应于在频域中乘以一个指定的频率响应 $H(\\mathbf{k})$。在遥感和环境建模中，这被用于抑制扫描条带、衰减高频噪声或增强定向特征。\n\n你的任务是为每个测试用例实现以下步骤：\n- 使用离散频率变量 $f_x \\in \\mathrm{fftfreq}(N_x)$ 和 $f_y \\in \\mathrm{fftfreq}(N_y)$ 构建指定的合成场景 $x[n_x,n_y]$ 和指定的频域滤波器 $H(\\mathbf{k})$。这些变量枚举了沿每个维度的归一化离散频率（单位为每样本周期数）。使用这些 $f_x, f_y$ 来参数化 $H(f_x,f_y)$。\n- 计算 $x[n_x,n_y]$ 的 DFT $X(\\mathbf{k})$。\n- 通过与卷积定理一致的频域乘法形成滤波后的频谱，然后使用逆 DFT 重建空间域滤波结果 $y[n_x,n_y]$。由于 $x$ 是实值的，报告逆 DFT 后 $y$ 的实部。\n- 为每个案例计算指定的标量度量。\n\n定义和约束：\n- 使用标准库 DFT 实现的约定和缩放：正向变换不进行归一化，逆变换通过 $1/(N_x N_y)$ 进行归一化。\n- 所有频域滤波器都是归一化离散频率 $f_x$ 和 $f_y$（单位为每样本周期数）的函数，这些频率由 $\\mathrm{fftfreq}(\\cdot)$ 返回。\n- 不使用角度；不需要角度单位。\n- 不涉及物理单位；所有量都是无单位的实数。\n\n测试套件规范：\n实现以下三个测试用例。在下面的所有公式中，索引 $n$ 和 $m$ 分别表示 $n_x$ 和 $n_y$，而 $\\exp(\\cdot)$ 表示自然指数。\n\n1) 案例 A（在带有棋盘格噪声的多斑点场景上进行各向同性高斯低通滤波）：\n- 网格大小：$N_x=32$， $N_y=32$。\n- 场景：\n$$\nx[n,m] = 0.2 + 0.4\\exp\\left(-\\frac{(n-10)^2+(m-18)^2}{2\\cdot 5^2}\\right) + 0.3\\exp\\left(-\\frac{(n-22)^2+(m-11)^2}{2\\cdot 3^2}\\right) + 0.05(-1)^{n+m}.\n$$\n- 滤波器（频率响应）：\n$$\nH(f_x,f_y) = \\exp\\left(-\\frac{f_x^2+f_y^2}{2\\sigma_k^2}\\right), \\quad \\sigma_k = 0.08.\n$$\n- 要计算的度量：\n$$\nr_1 = \\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} \\left| y[n,m] - x[n,m] \\right|.\n$$\n\n2) 案例 B（对已知频率的条带进行陷波滤波）：\n- 网格大小：$N_x=64$， $N_y=64$。\n- 场景：\n$$\nx[n,m] = 0.1 + 0.25\\exp\\left(-\\frac{(n-30)^2+(m-30)^2}{2\\cdot 6^2}\\right) + 0.15\\sin\\left(2\\pi f_0 m\\right),\n$$\n其中 $f_0=0.25$（沿 $m$ 轴的每样本周期数）。\n- 滤波器（频率响应，$f_y$ 方向上的理想陷波）：\n$$\nH(f_x,f_y) = \n\\begin{cases}\n0,  \\text{如果 } |f_y - f_0|\\le b_w \\text{ 或 } |f_y + f_0|\\le b_w,\\\\\n1,  \\text{否则},\n\\end{cases}\n$$\n其中 $b_w=0.02$。\n- 要计算的度量（残余条带投影幅度）：\n$$\nr_2 = \\left|\\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]\\sin\\left(2\\pi f_0 m\\right)\\right|.\n$$\n\n3) 案例 C（使用椭圆带通滤波器选择一个定向平面波）：\n- 网格大小：$N_x=48$， $N_y=64$。\n- 场景：\n$$\nx[n,m] = 0.2 + 0.1\\exp\\left(-\\frac{(n-20)^2+(m-20)^2}{2\\cdot 7^2}\\right) + 0.25\\cos\\left(2\\pi(f_x^{(1)}n + f_y^{(1)}m)\\right) + 0.08\\cos\\left(2\\pi(0.20\\,n - 0.16\\,m)\\right),\n$$\n其中 $f_x^{(1)}=0.12$ 和 $f_y^{(1)}=0.04$。\n- 滤波器（频率响应：两个以目标频率及其负频率为中心的椭圆高斯波瓣之和，并裁剪至单位1）：\n$$\nH(f_x,f_y) = \\min\\left\\{1,\\ \\exp\\left(-\\frac{(f_x-f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y-f_y^{(1)})^2}{2s_y^2}\\right) + \\exp\\left(-\\frac{(f_x+f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y+f_y^{(1)})^2}{2s_y^2}\\right)\\right\\},\n$$\n其中 $s_x=0.02$ 和 $s_y=0.03$。\n- 要计算的度量（能量比）：\n$$\nr_3 = \\frac{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]^2}{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} x[n,m]^2}.\n$$\n\n程序要求：\n- 使用二维 DFT 和逆 DFT 实现上述三个案例，以完成卷积定理所蕴含的滤波操作。\n- 使用标准约定，即 $f_x=\\mathrm{fftfreq}(N_x)$ 和 $f_y=\\mathrm{fftfreq}(N_y)$ 生成单位为每样本周期数的归一化离散频率数组。\n- 对每个案例，按定义生成标量度量 $r_1$、$r_2$ 和 $r_3$。\n- 最终输出格式：你的程序应生成单行输出，其中包含三个结果，形式为方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，“[0.123456,0.000789,0.456123]”）。",
            "solution": "该问题已经过验证，被确定为是合理的。它具有科学依据、是适定的、客观的，并包含得出唯一解所需的所有信息。其定义和步骤符合数字信号处理和傅里叶分析的既定原则。\n\n解决方案的核心原理是卷积定理。该定理指出，线性移不变滤波操作（在空间域中对应于卷积）等效于在频域中的逐元素乘法。对一个大小为 $N_x \\times N_y$ 的二维离散信号 $x[n_x, n_y]$ 进行滤波的步骤如下：\n\n1.  **正向傅里叶变换**：通过计算二维离散傅里叶变换 (DFT)，将空间域信号 $x[n_x, n_y]$ 变换到频域。\n    $$\n    X[k_x, k_y] = \\mathcal{F}\\{x[n_x, n_y]\\}\n    $$\n    得到的复值数组 $X[k_x, k_y]$ 代表信号的频谱，表示每个离散频率分量 $(k_x, k_y)$ 的幅度和相位。\n\n2.  **频域乘法**：滤波器由其频率响应 $H(f_x, f_y)$ 定义，它是归一化离散频率 $f_x$ 和 $f_y$ 的函数。该函数在与 $X[k_x, k_y]$ 相同的离散频率网格上进行采样，以创建一个滤波器掩模 $H[k_x, k_y]$。通过将信号的频谱与滤波器掩模相乘，得到滤波后的频谱 $Y[k_x, k_y]$。\n    $$\n    Y[k_x, k_y] = X[k_x, k_y] \\cdot H[k_x, k_y]\n    $$\n\n3.  **逆傅里叶变换**：通过对滤波后的频谱 $Y[k_x, k_y]$ 应用二维逆 DFT，可以恢复空间域中的滤波信号 $y[n_x, n_y]$。\n    $$\n    y[n_x, n_y] = \\mathcal{F}^{-1}\\{Y[k_x, k_y]\\}\n    $$\n    逆 DFT 的定义包含一个归一化因子 $1/(N_x N_y)$。由于输入信号 $x[n_x, n_y]$ 是实值的，并且滤波器被构造成具有厄米共轭对称性 ($H[k_x, k_y] = H^*[-k_x, -k_y]$)，因此得到的信号 $y[n_x, n_y]$ 应该是实数。由于有限精度算术，可能会出现微小的虚部，因此取结果的实部作为最终的滤波信号。\n\n归一化离散频率 $f_x$ 和 $f_y$ 以每样本周期数给出，对于定义与分辨率无关的滤波器至关重要。它们是使用等效于 `fftfreq` 的函数为每个维度生成的，该函数将频率分量按与标准快速傅里叶变换 (FFT) 算法兼容的顺序排列。\n\n问题中指定的三个测试用例旨在说明遥感和图像处理中常见的不同滤波目标。\n\n**案例A：各向同性低通滤波**\n该场景定义在一个 $32 \\times 32$ 的网格上，由恒定背景、两个不同大小的高斯形状特征和一个高频棋盘格噪声项 $0.05(-1)^{n+m}$ 组成。这个噪声分量对应于离散网格上可表示的最高频率。滤波器是一个各向同性高斯低通滤波器：\n$$\nH(f_x, f_y) = \\exp\\left(-\\frac{f_x^2+f_y^2}{2\\sigma_k^2}\\right), \\quad \\sigma_k = 0.08\n$$\n该滤波器衰减高频分量，同时保留低频分量。参数 $\\sigma_k$ 控制截止频率；较小的 $\\sigma_k$ 会导致更强的模糊效果。目标是抑制棋盘格噪声，同时对更宽的高斯特征影响最小。度量 $r_1$，即原始信号和滤波后信号之间的平均绝对差，量化了滤波器引入的总修改量。\n$$\nr_1 = \\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} \\left| y[n,m] - x[n,m] \\right|\n$$\n\n**案例B：陷波滤波**\n该场景位于 $64 \\times 64$ 的网格上，包含一个高斯特征和一个周期性条带伪影，由一个正弦波 $0.15\\sin(2\\pi f_0 m)$ 表示，其单一归一化频率为 $f_0 = 0.25$ 每样本周期数（沿 $m$ 轴）。目标是移除这个特定的伪影。这通过一个陷波滤波器实现，该滤波器旨在消除一个窄频带。频率响应为：\n$$\nH(f_x,f_y) = \n\\begin{cases}\n0,  \\text{如果 } |f_y - f_0|\\le b_w \\text{ 或 } |f_y + f_0|\\le b_w,\\\\\n1,  \\text{否则},\n\\end{cases}\n$$\n陷波半宽为 $b_w=0.02$。该滤波器将 $\\pm f_0$ 周围指定频带内的频率分量设置为零。包含 $-f_0$ 周围的频带确保了滤波器具有产生实值输出所需的对称性。度量 $r_2$ 计算滤波后信号在原始条带模式上的投影幅度，有效地测量了残余条带能量。一次成功的滤波操作将产生接近于零的 $r_2$ 值。\n$$\nr_2 = \\left|\\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]\\sin\\left(2\\pi f_0 m\\right)\\right|\n$$\n\n**案例C：椭圆带通滤波**\n此案例涉及一个 $48 \\times 64$ 网格上的场景，其中包含一个高斯特征和两个具有不同频率向量 $(f_x, f_y)$ 的定向平面波（余弦函数）。目标是隔离其中一个波，特别是频率为 $(f_x^{(1)}, f_y^{(1)}) = (0.12, 0.04)$ 的那个。滤波器是一个椭圆带通滤波器：\n$$\nH(f_x,f_y) = \\min\\left\\{1,\\ \\exp\\left(-\\frac{(f_x-f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y-f_y^{(1)})^2}{2s_y^2}\\right) + \\exp\\left(-\\frac{(f_x+f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y+f_y^{(1)})^2}{2s_y^2}\\right)\\right\\}\n$$\n参数为 $s_x=0.02$ 和 $s_y=0.03$。频率向量为 $\\mathbf{f_1} = (f_x^{(1)}, f_y^{(1)})$ 的实值余弦波的能量集中在频域的两个点上：$\\mathbf{f_1}$ 和 $-\\mathbf{f_1}$。因此，滤波器被构造为两个椭圆高斯波瓣之和，一个以 $\\mathbf{f_1}$ 为中心，另一个以 $-\\mathbf{f_1}$ 为中心，以捕获两个分量。度量 $r_3$ 是滤波后信号的能量与原始信号能量之比，表示总信号能量中有多大比例通过了滤波器。\n$$\nr_3 = \\frac{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]^2}{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} x[n,m]^2}\n$$\n对于每个案例，实现将精确遵循这些步骤，并利用数值库进行 FFT 计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three test cases for frequency domain filtering and prints the results.\n    \"\"\"\n\n    def solve_case_a():\n        \"\"\"\n        Case A: Isotropic Gaussian low-pass on a multi-blob scene with checkerboard noise.\n        \"\"\"\n        Nx, Ny = 32, 32\n        sigma_k = 0.08\n\n        # Construct the spatial grid and scene\n        n, m = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n        \n        scene = (\n            0.2\n            + 0.4 * np.exp(-((n - 10)**2 + (m - 18)**2) / (2 * 5**2))\n            + 0.3 * np.exp(-((n - 22)**2 + (m - 11)**2) / (2 * 3**2))\n            + 0.05 * (-1)**(n + m)\n        )\n\n        # Construct the frequency grid and filter\n        fx = np.fft.fftfreq(Nx)\n        fy = np.fft.fftfreq(Ny)\n        Fx, Fy = np.meshgrid(fx, fy, indexing='ij')\n\n        H = np.exp(-(Fx**2 + Fy**2) / (2 * sigma_k**2))\n\n        # Apply filtering\n        X = np.fft.fft2(scene)\n        Y_freq = X * H\n        y_filtered = np.real(np.fft.ifft2(Y_freq))\n\n        # Compute metric\n        r1 = np.mean(np.abs(y_filtered - scene))\n        return r1\n\n    def solve_case_b():\n        \"\"\"\n        Case B: Notch filtering stripes at a known frequency.\n        \"\"\"\n        Nx, Ny = 64, 64\n        f0 = 0.25\n        bw = 0.02\n\n        # Construct the spatial grid and scene\n        n, m = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n        \n        scene = (\n            0.1\n            + 0.25 * np.exp(-((n - 30)**2 + (m - 30)**2) / (2 * 6**2))\n            + 0.15 * np.sin(2 * np.pi * f0 * m)\n        )\n\n        # Construct the frequency grid and filter\n        fx = np.fft.fftfreq(Nx)\n        fy = np.fft.fftfreq(Ny)\n        Fx, Fy = np.meshgrid(fx, fy, indexing='ij')\n\n        H = np.ones((Nx, Ny))\n        notch_condition = (np.abs(Fy - f0) = bw) | (np.abs(Fy + f0) = bw)\n        H[notch_condition] = 0\n\n        # Apply filtering\n        X = np.fft.fft2(scene)\n        Y_freq = X * H\n        y_filtered = np.real(np.fft.ifft2(Y_freq))\n\n        # Compute metric\n        stripe_component = np.sin(2 * np.pi * f0 * m)\n        r2 = np.abs(np.mean(y_filtered * stripe_component))\n        return r2\n\n    def solve_case_c():\n        \"\"\"\n        Case C: Elliptical band-pass to select an oriented plane wave.\n        \"\"\"\n        Nx, Ny = 48, 64\n        fx1, fy1 = 0.12, 0.04\n        sx, sy = 0.02, 0.03\n        \n        # Construct the spatial grid and scene\n        n, m = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n\n        scene = (\n            0.2\n            + 0.1 * np.exp(-((n - 20)**2 + (m - 20)**2) / (2 * 7**2))\n            + 0.25 * np.cos(2 * np.pi * (fx1 * n + fy1 * m))\n            + 0.08 * np.cos(2 * np.pi * (0.20 * n - 0.16 * m))\n        )\n        \n        # Construct the frequency grid and filter\n        fx = np.fft.fftfreq(Nx)\n        fy = np.fft.fftfreq(Ny)\n        Fx, Fy = np.meshgrid(fx, fy, indexing='ij')\n\n        lobe1 = np.exp(-((Fx - fx1)**2 / (2 * sx**2) + (Fy - fy1)**2 / (2 * sy**2)))\n        lobe2 = np.exp(-((Fx + fx1)**2 / (2 * sx**2) + (Fy + fy1)**2 / (2 * sy**2)))\n        \n        H = np.minimum(1.0, lobe1 + lobe2)\n\n        # Apply filtering\n        X = np.fft.fft2(scene)\n        Y_freq = X * H\n        y_filtered = np.real(np.fft.ifft2(Y_freq))\n\n        # Compute metric\n        energy_y = np.sum(y_filtered**2)\n        energy_x = np.sum(scene**2)\n        r3 = energy_y / energy_x\n        return r3\n\n    # Calculate results for all cases\n    r1 = solve_case_a()\n    r2 = solve_case_b()\n    r3 = solve_case_c()\n    results = [r1, r2, r3]\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "直接应用卷积定理会导致循环卷积，从而产生“回绕”伪影，这在处理有限长度的信号时是一个常见的陷阱。本练习  结合了理论推导与编程实践，旨在揭示DFT的周期性假设是如何导致这些伪影的。您将通过量化未加填充（padding）滤波所产生的误差，并验证使用零填充能够精确复现线性卷积，从而掌握在实践中正确执行快速傅里叶变换（FFT）卷积的关键技术。",
            "id": "3813514",
            "problem": "考虑沿飞行航线的一维遥感反射率剖面，表示为一个长度为 $N$ 个样本的有限离散序列，其中 $N$ 是一个正整数。在许多环境建模工作流中，会执行低通滤波来抑制高频噪声。一种常见的方法是使用离散傅里叶变换（DFT），通过在频域中进行乘法来实现快速卷积。目标是从第一性原理出发，证明为什么这种基于DFT的卷积是循环的，并量化在没有足够填充的情况下进行滤波时产生的环绕（wrap-around）失真。\n\n从以下核心定义开始。对于一个长度为 $N$ 的序列 $x[n]$，离散傅里叶变换（DFT）和逆离散傅里叶变换（IDFT）定义如下：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn / N}, \\quad k = 0,1,\\dots,N-1,\n$$\n和\n$$\nx[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kn / N}, \\quad n = 0,1,\\dots,N-1,\n$$\n其中 $i$ 是虚数单位。将 $e^{(\\cdot)}$ 中的所有角度视为以弧度为单位。令 $h[n]$ 为一个长度为 $M$ 的有限长度滤波器核，其中 $M$ 是一个奇数正整数，设计为在整数上采样的离散高斯低通滤波器，标准差为 $\\sigma$ 个样本，并归一化为单位和。当高斯核的中心索引 $c = (M-1)/2$ 对齐以在零延迟处起作用时，它是零相位的。\n\n任务：\n1. 使用上述定义，推导为什么将DFT $X[k]$ 和 $H[k]$ 相乘然后应用IDFT会在样本域中产生周期为 $N$ 的循环卷积。解释DFT基中固有的周期性延拓的作用，以及在不使用填充时它如何导致环绕效应。\n2. 实现一个程序，该程序构建指定的测试信号 $x[n]$（对于任何正弦项，角度以弧度为单位），构建具有给定 $(M,\\sigma)$ 的高斯核 $h[n]$，并计算：\n   - 通过长度为 $N$ 的DFT乘法计算循环卷积 $y_{\\text{circ}}[n]$，并使用零相位对齐（通过在变换前将 $h[n]$ 循环移位 $-c$ 个样本来实现）。\n   - 参考线性卷积 $y_{\\text{lin}}[n]$，使用零填充并提取与核居中对齐的“same”对齐方式相对应的长度为 $N$ 的段。这可以直接在样本域中计算。\n3. 对于下面测试套件中列出的每个测试用例，计算在不进行填充的情况下滤波时环绕失真的两个量化指标：\n   - 循环DFT结果与线性卷积结果在所有 $N$ 个样本上的均方误差（MSE），\n     $$\n     \\text{MSE} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left( y_{\\text{circ}}[n] - y_{\\text{lin}}[n] \\right)^2.\n     $$\n   - 在前 $M-1$ 个样本上的最大绝对差，\n     $$\n     \\Delta_{\\max}^{\\text{head}} = \\max_{0 \\le n \\le M-2} \\left| y_{\\text{circ}}[n] - y_{\\text{lin}}[n] \\right|,\n     $$\n     这可以分离出在循环卷积下由剖面末端影响起始部分所引起的环绕误差。\n4. 此外，对于一个指定的测试用例，执行具有足够零填充（长度为 $L = N + M - 1$）的基于DFT的卷积（在变换前通过移位 $-c$ 使核零相位对齐），计算IDFT，并提取与“same”对齐方式相对应的长度为 $N$ 的段。将此填充后的DFT结果与样本域线性卷积进行比较，以验证在适当填充的情况下，两种方法在数值精度范围内是一致的。报告：\n   - 所有 $N$ 个样本上的均方误差，\n     $$\n     \\text{MSE}_{\\text{pad}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left( y_{\\text{fft,pad}}[n] - y_{\\text{lin}}[n] \\right)^2,\n     $$\n   - 所有 $N$ 个样本上的最大绝对差，\n     $$\n     \\Delta_{\\max}^{\\text{pad}} = \\max_{0 \\le n \\le N-1} \\left| y_{\\text{fft,pad}}[n] - y_{\\text{lin}}[n] \\right|.\n     $$\n\n测试套件：\n所有情况均使用 $N = 64$ 个样本。对于任何正弦构造，角度均使用弧度。\n- 情况 $\\mathbf{1}$ (使用中等大小核的理想情况)：信号\n  $$\n  x_1[n] = 0.4 + 0.3\\sin\\!\\left(\\frac{2\\pi n}{16}\\right) + 0.2\\sin\\!\\left(\\frac{2\\pi n}{9}\\right),\n  $$\n  带有一个末端尖峰 $x_1[N-1] \\leftarrow x_1[N-1] + 0.8$。核：$M = 9$，$\\sigma = 2.0$。\n- 情况 $\\mathbf{2}$ (急剧边界阶跃)：信号\n  $$\n  x_2[n] = \n  \\begin{cases}\n  0.2,  0 \\le n \\le 47, \\\\\n  0.9,  48 \\le n \\le 63,\n  \\end{cases}\n  $$\n  核：$M = 15$，$\\sigma = 3.0$。\n- 情况 $\\mathbf{3}$ (使用宽核的缓慢斜坡)：信号\n  $$\n  x_3[n] = 0.1 + 0.9 \\frac{n}{N-1}, \\quad 0 \\le n \\le 63,\n  $$\n  核：$M = 31$，$\\sigma = 6.0$。\n- 情况 $\\mathbf{4}$ (使用适当填充进行验证)：使用与情况 $\\mathbf{2}$ 相同的信号和核 $M = 15$，$\\sigma = 3.0$，但执行填充长度为 $L = N + M - 1$ 的基于DFT的卷积，并提取长度为 $N$ 的“same”段。\n\n答案规格：\n- 对于情况 $\\mathbf{1}$、$\\mathbf{2}$ 和 $\\mathbf{3}$，按顺序为每个情况输出两个浮点数：整体MSE和头部区间的最大绝对差 $\\Delta_{\\max}^{\\text{head}}$。\n- 对于情况 $\\mathbf{4}$，输出两个浮点数：$\\text{MSE}_{\\text{pad}}$ 和 $\\Delta_{\\max}^{\\text{pad}}$。\n- 你的程序应生成单行输出，其中包含这八个结果，按顺序排列在一个用方括号括起来的逗号分隔列表中，即：\n$[ \\text{MSE}_1, \\Delta_{\\max,1}^{\\text{head}}, \\text{MSE}_2, \\Delta_{\\max,2}^{\\text{head}}, \\text{MSE}_3, \\Delta_{\\max,3}^{\\text{head}}, \\text{MSE}_{\\text{pad}}, \\Delta_{\\max}^{\\text{pad}} ]$。\n所有输出必须是实数（浮点数）。此问题不涉及物理单位。",
            "solution": "该问题要求两部分的回答：离散傅里叶变换（DFT）循环卷积性质的理论推导，以及一个用于量化环绕失真并验证使用填充进行正确滤波的数值实现。\n\n**第一部分：循环卷积定理的理论推导**\n\n这个问题的核心在于DFT的卷积定理。该定理指出，两个信号在频域中的逐元素相乘对应于它们在时域（或样本域）中的循环卷积。我们将根据问题陈述中定义的第一性原理来推导这一点。\n\n设 $x[n]$ 和 $h[n]$ 是两个离散的有限长度序列，长度均为 $N$。它们的DFT由下式给出：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn / N}\n$$\n$$\nH[k] = \\sum_{n=0}^{N-1} h[n]\\, e^{-i 2\\pi kn / N}\n$$\n\n设 $y[n]$ 是通过对其DFT的乘积 $Y[k] = X[k]H[k]$ 进行逆DFT（IDFT）得到的序列。IDFT定义为：\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} Y[k]\\, e^{i 2\\pi kn / N}\n$$\n\n为了推导与此频域乘法相对应的时间域操作，我们将 $Y[k]$ 以及随后的 $H[k]$ 的表达式代入IDFT公式。\n\n步骤1：将 $Y[k] = X[k]H[k]$ 代入 $y[n]$ 的IDFT定义中。\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] H[k]\\, e^{i 2\\pi kn / N}\n$$\n\n步骤2：将 $H[k]$ 的DFT定义代入表达式中。\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\left( \\sum_{m=0}^{N-1} h[m]\\, e^{-i 2\\pi km / N} \\right) e^{i 2\\pi kn / N}\n$$\n\n步骤3：由于求和是有限的，我们可以交换它们的顺序并重新排列各项。\n$$\ny[n] = \\sum_{m=0}^{N-1} h[m] \\left( \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi k(n-m) / N} \\right)\n$$\n\n步骤4：我们识别出括号内的表达式。它具有 $X[k]$ 的IDFT的精确形式，但在索引 $(n-m)$ 处求值，而不是 $n$。\n$$\nx[j] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kj / N}\n$$\n因此，括号中的表达式是 $x[n-m]$。将其代回，我们得到：\n$$\ny[n] = \\sum_{m=0}^{N-1} h[m] x[n-m]\n$$\n\n这个表达式是卷积和的标准形式。然而，DFT的性质带来了一个关键的微妙之处。DFT隐含地假设信号 $x[n]$ 和 $h[n]$ 是周期为 $N$ 的周期信号。这是因为它的基函数，即复指数 $e^{i 2\\pi kn/N}$，本身在时间索引 $n$ 上就是周期为 $N$ 的。\n\n因此，时域中的任何索引都隐含地按模 $N$ 处理。所以，表达式 $x[n-m]$ 必须被解释为 $x[(n-m) \\pmod N]$。这导致了最终结果：\n$$\ny[n] = \\sum_{m=0}^{N-1} h[m] x[(n-m) \\pmod N]\n$$\n\n这就是长度为 $N$ 的**循环卷积**的定义。\n\n**环绕失真的解释：**\n\nDFT的周期性是执行卷积时产生“环绕”失真的根源。作为滤波所需操作的标准**线性卷积**定义为：\n$$\ny_{\\text{lin}}[n] = \\sum_{m=-\\infty}^{\\infty} h[m] x[n-m]\n$$\n对于有限长度信号 $x[n]$（长度 $N$）和 $h[m]$（长度 $M$），此和是有限的。当计算序列开头的输出时，例如 $y_{\\text{lin}}[0] = \\sum_{m=0}^{M-1} h[m]x[-m]$，滤波器需要访问 $x$ 在负索引处的样本。在线性卷积中，这些样本被视为零。\n\n然而，在循环卷积中，索引会环绕。项 $x[-m]$ 被计算为 $x[(-m) \\pmod N] = x[N-m]$。这意味着当滤波器应用于信号 $x[n]$ 的开头时，它会“看到”信号的末尾（$x[N-1]$, $x[N-2]$ 等），就好像它们被前置了一样。这导致序列开头的滤波输出被序列末尾的信号值污染，这种失真被称为环绕效应。该失真影响输出的前 $M-1$ 个样本。在序列的末尾也会发生类似的效果，但从末端到开头的环绕是最常被讨论的失真。\n\n为了使用DFT正确计算线性卷积，两个信号都必须零填充到至少为 $L = N+M-1$ 的长度。这确保了循环卷积有足够大的周期，使得环绕效应只涉及附加的零，而卷积的有效部分（长度为 $N+M-1$）不受影响。从这个结果中，可以提取所需的段（例如，长度为 $N$ 且具有 'same' 对齐方式的段）。\n\n**第二部分：数值实现与验证**\n\n提供的代码将实现上述逻辑。它将：\n1. 为每个测试用例构建输入信号和高斯滤波器核。\n2. 通过不带填充的DFT乘法计算循环卷积。\n3. 使用带有 `mode='same'` 的 `numpy.convolve` 计算参考线性卷积，这将产生一个居中的、零相位对齐的结果。\n4. 计算指定的误差度量（MSE 和 $\\Delta_{\\max}^{\\text{head}}$）以量化环绕失真。\n5. 对于最后一个情况，演示具有足够零填充（$L=N+M-1$）的基于DFT的卷积能正确地再现线性卷积结果，显示误差度量接近机器精度。核的零相位对齐是通过将核循环移位 $-c$ 个样本来实现的，其中 $c=(M-1)/2$ 是中心索引，这将中心抽头置于FFT的索引0处。对于填充情况的'same'对齐，需要从完整的 $L$ 样本线性卷积结果中提取正确的 $N$ 样本段。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by demonstrating and quantifying circular convolution artifacts\n    in DFT-based filtering and verifying the padded DFT method.\n    \"\"\"\n    \n    # --- Problem Constants and Test Suite Definition ---\n    N = 64\n    test_cases_params = [\n        {'case': 1, 'M': 9, 'sigma': 2.0},\n        {'case': 2, 'M': 15, 'sigma': 3.0},\n        {'case': 3, 'M': 31, 'sigma': 6.0},\n        {'case': 4, 'M': 15, 'sigma': 3.0}, # Verification case, uses signal from case 2\n    ]\n    \n    results = []\n\n    for params in test_cases_params:\n        case_id = params['case']\n        M = params['M']\n        sigma = params['sigma']\n        \n        # --- 1. Signal Generation ---\n        x = np.zeros(N, dtype=np.float64)\n        if case_id == 1:\n            n = np.arange(N)\n            x = 0.4 + 0.3 * np.sin(2 * np.pi * n / 16) + 0.2 * np.sin(2 * np.pi * n / 9)\n            x[N - 1] += 0.8\n        elif case_id == 2 or case_id == 4:\n            x[0:48] = 0.2\n            x[48:N] = 0.9\n        elif case_id == 3:\n            n = np.arange(N)\n            x = 0.1 + 0.9 * n / (N - 1)\n\n        # --- 2. Gaussian Kernel Generation ---\n        c = (M - 1) // 2\n        kernel_indices = np.arange(M)\n        h = np.exp(-0.5 * ((kernel_indices - c) / sigma) ** 2)\n        h /= np.sum(h)\n\n        # --- 3. Reference Linear Convolution ---\n        # np.convolve with mode='same' computes the linear convolution and returns\n        # the central part of the output that is the same size as the input signal x.\n        # This corresponds to a zero-phase filtering operation.\n        y_lin = np.convolve(x, h, mode='same')\n\n        if case_id in [1, 2, 3]:\n            # --- Unpadded Circular Convolution (Demonstrating Artifacts) ---\n            \n            # Create an N-point kernel for N-point DFT\n            h_N = np.zeros(N)\n            h_N[:M] = h\n            \n            # Circularly shift for zero-phase alignment. Moves h[c] to index 0.\n            h_shifted = np.roll(h_N, -c)\n            \n            # Compute circular convolution via DFT multiplication\n            X = np.fft.fft(x)\n            H = np.fft.fft(h_shifted)\n            y_circ_fft = np.fft.ifft(X * H).real\n            \n            # --- Calculate Metrics for Unpadded Case ---\n            mse = np.mean((y_circ_fft - y_lin)**2)\n            \n            # Max absolute difference over the first M-1 samples\n            delta_max_head = np.max(np.abs(y_circ_fft[:M-1] - y_lin[:M-1]))\n            \n            results.extend([mse, delta_max_head])\n\n        elif case_id == 4:\n            # --- Padded DFT-based Convolution (Verification) ---\n            \n            L = N + M - 1 # Proper padding length for linear convolution\n            \n            # Pad signal and kernel to length L\n            x_pad = np.zeros(L)\n            x_pad[:N] = x\n            \n            h_L = np.zeros(L)\n            h_L[:M] = h\n            \n            # Circularly shift L-point kernel for zero-phase alignment\n            h_shifted_pad = np.roll(h_L, -c)\n            \n            # Compute convolution using padded DFTs\n            X_pad = np.fft.fft(x_pad)\n            H_pad = np.fft.fft(h_shifted_pad)\n            y_pad_full = np.fft.ifft(X_pad * H_pad).real\n            \n            # Extract the 'same' part, which corresponds to the linear convolution\n            # result aligned with the original signal.\n            y_fft_pad = y_pad_full[c : c + N]\n            \n            # --- Calculate Metrics for Padded Case ---\n            mse_pad = np.mean((y_fft_pad - y_lin)**2)\n            delta_max_pad = np.max(np.abs(y_fft_pad - y_lin))\n            \n            results.extend([mse_pad, delta_max_pad])\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}