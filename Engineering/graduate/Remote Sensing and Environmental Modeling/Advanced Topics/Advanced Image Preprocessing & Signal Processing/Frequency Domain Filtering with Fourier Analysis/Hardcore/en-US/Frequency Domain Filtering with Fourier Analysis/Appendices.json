{
    "hands_on_practices": [
        {
            "introduction": "The first step in frequency-domain analysis is to build a strong intuition for how spatial patterns are represented in the frequency domain. This exercise challenges you to derive the Discrete Fourier Transform (DFT) of a checkerboard pattern, a classic model for high-frequency noise or artifacts in imagery . By working from first principles, you will see how this purely spatial pattern transforms into a signal concentrated at a single point in the frequency spectrum, solidifying the fundamental connection between space and frequency.",
            "id": "3813540",
            "problem": "In airborne imaging for remote sensing of agricultural mosaics, periodic artifacts can arise from platform vibration or detector readout, manifesting as alternating patterns in the recorded bidimensional reflectance field. Consider a rectangular tile of an orthorectified radiance image with even dimensions $M$ (rows) and $N$ (columns), indexed by spatial samples $m \\in \\{0,1,\\dots,M-1\\}$ and $n \\in \\{0,1,\\dots,N-1\\}$. Suppose a stripe-like checkerboard artifact is present, modeled as a deterministic pattern $x[m,n] = (-1)^{m+n}$ superposed on the scene, representing a spatial alternation at the highest resolvable frequency in both directions. Let $X[k,\\ell]$ denote the two-dimensional Discrete Fourier Transform (DFT) of $x[m,n]$ under the standard definition from signal processing and remote sensing, \n$$\nX[k,\\ell] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} x[m,n] \\exp\\!\\Big(-\\mathrm{i} 2\\pi \\Big(\\frac{mk}{M} + \\frac{n\\ell}{N}\\Big)\\Big),\n$$\nfor frequency indices $k \\in \\{0,1,\\dots,M-1\\}$ and $\\ell \\in \\{0,1,\\dots,N-1\\}$. Starting from the fundamental definition of the DFT and first principles about geometric series, derive a closed-form expression for the DFT magnitude $\\lvert X[k,\\ell] \\rvert$ as a function of $(k,\\ell)$, $M$, and $N$, and identify the dominant frequency component(s) and their precise index locations in the spectrum. Express your final answer as a single closed-form analytical expression using the Kronecker delta, and do not use any numerical approximation or rounding. No physical units are required for the final answer.",
            "solution": "The problem requires the derivation of the magnitude of the two-dimensional Discrete Fourier Transform (DFT) for a specific signal representing a checkerboard artifact.\n\nThe signal is defined on a rectangular grid of size $M \\times N$, where $M$ and $N$ are even integers. The spatial indices are $m \\in \\{0,1,\\dots,M-1\\}$ and $n \\in \\{0,1,\\dots,N-1\\}$. The signal itself is given by\n$$\nx[m,n] = (-1)^{m+n}\n$$\nThe two-dimensional DFT, $X[k,\\ell]$, is defined for frequency indices $k \\in \\{0,1,\\dots,M-1\\}$ and $\\ell \\in \\{0,1,\\dots,N-1\\}$ as\n$$\nX[k,\\ell] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} x[m,n] \\exp\\left(-\\mathrm{i} 2\\pi \\left(\\frac{mk}{M} + \\frac{n\\ell}{N}\\right)\\right)\n$$\nTo proceed, we first express the signal term $(-1)^{m+n}$ using Euler's identity, $e^{\\mathrm{i}\\pi} = -1$.\n$$\nx[m,n] = (-1)^{m+n} = (e^{\\mathrm{i}\\pi})^{m+n} = e^{\\mathrm{i}\\pi(m+n)} = e^{\\mathrm{i}\\pi m} e^{\\mathrm{i}\\pi n}\n$$\nSubstituting this into the DFT definition yields:\n$$\nX[k,\\ell] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} (e^{\\mathrm{i}\\pi m} e^{\\mathrm{i}\\pi n}) \\exp\\left(-\\mathrm{i} 2\\pi \\frac{mk}{M}\\right) \\exp\\left(-\\mathrm{i} 2\\pi \\frac{n\\ell}{N}\\right)\n$$\nThe double summation is separable with respect to the indices $m$ and $n$. We can group the terms and write the expression as a product of two independent sums:\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} e^{\\mathrm{i}\\pi m} \\exp\\left(-\\mathrm{i} 2\\pi \\frac{mk}{M}\\right) \\right) \\left( \\sum_{n=0}^{N-1} e^{\\mathrm{i}\\pi n} \\exp\\left(-\\mathrm{i} 2\\pi \\frac{n\\ell}{N}\\right) \\right)\n$$\nLet's combine the exponents inside each summation:\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} \\exp\\left(\\mathrm{i}m\\left(\\pi - \\frac{2\\pi k}{M}\\right)\\right) \\right) \\left( \\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{i}n\\left(\\pi - \\frac{2\\pi \\ell}{N}\\right)\\right) \\right)\n$$\nFactoring out $2\\pi$ from the exponents:\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} \\exp\\left(\\mathrm{i} 2\\pi m \\left(\\frac{1}{2} - \\frac{k}{M}\\right)\\right) \\right) \\left( \\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{i} 2\\pi n \\left(\\frac{1}{2} - \\frac{\\ell}{N}\\right)\\right) \\right)\n$$\n$$\nX[k,\\ell] = \\left( \\sum_{m=0}^{M-1} \\exp\\left(\\mathrm{i} 2\\pi m \\frac{M/2 - k}{M}\\right) \\right) \\left( \\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{i} 2\\pi n \\frac{N/2 - \\ell}{N}\\right) \\right)\n$$\nLet's denote the first sum as $S_M(k)$ and the second as $S_N(\\ell)$. Each is a finite geometric series of the form $\\sum_{j=0}^{P-1} r^j$. The sum of such a series is $P$ if $r=1$, and $\\frac{1-r^P}{1-r}$ if $r \\neq 1$.\n\nConsider the sum $S_M(k)$. The ratio is $r_M = \\exp\\left(\\mathrm{i} 2\\pi \\frac{M/2 - k}{M}\\right)$.\nThe ratio $r_M$ equals $1$ if and only if its exponent is an integer multiple of $2\\pi \\mathrm{i}$. This means $\\frac{M/2 - k}{M}$ must be an integer. Let this integer be $z$.\n$$\n\\frac{M/2 - k}{M} = z \\implies k = \\frac{M}{2} - zM\n$$\nSince $k$ must be in the range $\\{0, 1, \\dots, M-1\\}$, we test integer values for $z$:\n- If $z=0$, $k=M/2$. Since $M$ is given to be even, $M/2$ is an integer. $0 \\le M/2 < M$ for $M>0$, so this is a valid index.\n- If $z=1$, $k = M/2 - M = -M/2$, which is outside the valid range.\n- If $z=-1$, $k = M/2 + M = 3M/2$, which is outside the valid range.\nThus, $r_M=1$ occurs only for $k=M/2$.\n\nCase 1: $k = M/2$.\nIn this case, $r_M=1$, and the sum is the number of terms:\n$$\nS_M(M/2) = \\sum_{m=0}^{M-1} (1)^m = M\n$$\n\nCase 2: $k \\neq M/2$.\nHere, $r_M \\neq 1$, so we use the standard formula for a geometric series sum:\n$$\nS_M(k) = \\frac{1 - (r_M)^M}{1 - r_M}\n$$\nLet's evaluate the term $(r_M)^M$:\n$$\n(r_M)^M = \\left(\\exp\\left(\\mathrm{i} 2\\pi \\frac{M/2 - k}{M}\\right)\\right)^M = \\exp\\left(\\mathrm{i} 2\\pi (M/2 - k)\\right) = \\exp(\\mathrm{i}\\pi M - \\mathrm{i}2\\pi k)\n$$\nSince $M$ is an even integer, $M=2p$ for some integer $p$. Thus, $\\exp(\\mathrm{i}\\pi M) = \\exp(\\mathrm{i}2\\pi p) = 1$. Since $k$ is an integer, $\\exp(-\\mathrm{i}2\\pi k) = 1$. Therefore, $(r_M)^M = 1 \\cdot 1 = 1$.\nThe numerator of the sum is $1 - (r_M)^M = 1 - 1 = 0$. The denominator $1 - r_M$ is non-zero because $k \\neq M/2$.\n$$\nS_M(k) = \\frac{0}{1 - r_M} = 0 \\quad \\text{for } k \\neq M/2\n$$\n\nCombining both cases, we can express $S_M(k)$ using the Kronecker delta symbol, $\\delta_{ij}$, which is $1$ if $i=j$ and $0$ otherwise.\n$$\nS_M(k) = M \\delta_{k, M/2}\n$$\nBy exactly analogous reasoning, since $N$ is also an even integer, the sum $S_N(\\ell)$ is:\n$$\nS_N(\\ell) = N \\delta_{\\ell, N/2}\n$$\nNow, we find the full 2D DFT by multiplying the results for the two sums:\n$$\nX[k,\\ell] = S_M(k) S_N(\\ell) = (M \\delta_{k, M/2}) (N \\delta_{\\ell, N/2}) = MN \\delta_{k, M/2} \\delta_{\\ell, N/2}\n$$\nThis expression shows that the DFT is zero for all frequency indices $(k, \\ell)$ except for the single point $(k, \\ell) = (M/2, N/2)$. At this point, the DFT has the value $MN$.\n\nThe dominant frequency component is thus located at the indices $(k_0, \\ell_0) = (M/2, N/2)$. These indices correspond to the discrete Nyquist frequencies in each dimension, $f_k = k_0/M = 1/2$ cycles/sample and $f_\\ell = \\ell_0/N = 1/2$ cycles/sample, which represents the highest possible frequency of alternation in a discrete signal. This is consistent with the input signal $x[m,n]=(-1)^{m+n}$ being a checkerboard pattern.\n\nThe final step is to find the magnitude of the DFT, $|X[k, \\ell]|$. Since $M$ and $N$ are positive dimensions, their product $MN$ is a positive real number. The Kronecker delta is also real-valued.\n$$\n|X[k,\\ell]| = |MN \\delta_{k, M/2} \\delta_{\\ell, N/2}| = MN |\\delta_{k, M/2} \\delta_{\\ell, N/2}| = MN \\delta_{k, M/2} \\delta_{\\ell, N/2}\n$$\nThis is the closed-form analytical expression for the DFT magnitude.",
            "answer": "$$\n\\boxed{MN \\delta_{k, M/2} \\delta_{\\ell, N/2}}\n$$"
        },
        {
            "introduction": "The convolution theorem is the engine of frequency-domain filtering, offering a highly efficient alternative to spatial convolution by replacing it with element-wise multiplication. However, the Discrete Fourier Transform operates on periodic signals, meaning this efficiency comes with a critical caveat: the result is a *circular* convolution, not a linear one . This hands-on practice guides you through both the theoretical derivation of this property and a coding exercise to observe and quantify the resulting \"wrap-around\" artifacts, cementing your understanding of why proper zero-padding is essential for accurate filtering.",
            "id": "3813514",
            "problem": "Consider a one-dimensional remote sensing reflectance transect along a flight line, represented as a finite discrete sequence $x[n]$ of length $N$ samples, where $N$ is a positive integer. In many environmental modeling workflows, low-pass filtering is performed to suppress high-frequency noise. A common approach is to use the Discrete Fourier Transform (DFT) for fast convolution via multiplication in the frequency domain. The target is to show, from first principles, why such DFT-based convolution is circular, and to quantify the wrap-around artifacts that arise when filtering without sufficient padding.\n\nStart from the following core definitions. For a sequence $x[n]$ of length $N$, the Discrete Fourier Transform (DFT) and the inverse Discrete Fourier Transform (IDFT) are defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn / N}, \\quad k = 0,1,\\dots,N-1,\n$$\nand\n$$\nx[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kn / N}, \\quad n = 0,1,\\dots,N-1,\n$$\nwhere $i$ is the imaginary unit. Treat all angles in $e^{(\\cdot)}$ as measured in radians. Let $h[n]$ be a finite-length filter kernel of length $M$ with $M$ an odd positive integer, designed as a discrete Gaussian low-pass filter sampled on the integers with standard deviation $\\sigma$ samples and normalized to unit sum. The Gaussian kernel is zero-phase when its center index $c = (M-1)/2$ is aligned to act at zero lag.\n\nTasks:\n1. Using the above definitions, derive why multiplying the DFTs $X[k]$ and $H[k]$ and then applying the IDFT yields a circular convolution of period $N$ in the sample domain. Explain the role of the periodic extension inherent in the DFT basis and how it causes wrap-around when no padding is used.\n2. Implement a program that constructs specified test signals $x[n]$, constructs Gaussian kernels $h[n]$ with given $(M,\\sigma)$, and computes:\n   - The circular convolution $y_{\\text{circ}}[n]$ via DFT multiplication at length $N$ using zero-phase alignment (achieved by circularly shifting $h[n]$ by $-c$ samples before transforming).\n   - The reference linear convolution $y_{\\text{lin}}[n]$ using zero-padding and extracting the segment of length $N$ that corresponds to \"same\" alignment with the kernel centered. This may be computed directly in the sample domain.\n3. For each test case listed in the test suite below, compute two quantitative measures of wrap-around artifacts when filtering without padding:\n   - The mean squared error (MSE) across all $N$ samples between the circular DFT-based result and the linear convolution result,\n     $$\n     \\text{MSE} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left( y_{\\text{circ}}[n] - y_{\\text{lin}}[n] \\right)^2.\n     $$\n   - The maximum absolute difference over the first $M-1$ samples,\n     $$\n     \\Delta_{\\max}^{\\text{head}} = \\max_{0 \\le n \\le M-2} \\left| y_{\\text{circ}}[n] - y_{\\text{lin}}[n] \\right|,\n     $$\n     which isolates the wrap-around error caused by the end of the transect influencing the beginning under circular convolution.\n4. Additionally, for one specified test case, perform DFT-based convolution with sufficient zero-padding to length $L = N + M - 1$ (with the kernel zero-phase aligned by shifting $-c$ before transforming), compute the IDFT, and extract the segment of length $N$ corresponding to \"same\" alignment. Compare this padded DFT-based result to the sample-domain linear convolution to verify that, with proper padding, the two methods agree within numerical precision. Report:\n   - The mean squared error across all $N$ samples,\n     $$\n     \\text{MSE}_{\\text{pad}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left( y_{\\text{fft,pad}}[n] - y_{\\text{lin}}[n] \\right)^2,\n     $$\n   - The maximum absolute difference over all $N$ samples,\n     $$\n     \\Delta_{\\max}^{\\text{pad}} = \\max_{0 \\le n \\le N-1} \\left| y_{\\text{fft,pad}}[n] - y_{\\text{lin}}[n] \\right|.\n     $$\n\nTest Suite:\nUse $N = 64$ samples for all cases. For any sinusoidal construction, use angles in radians.\n- Case $\\mathbf{1}$ (happy path with moderate kernel): Signal\n  $x_1[n] = 0.4 + 0.3\\sin\\!\\left(\\frac{2\\pi n}{16}\\right) + 0.2\\sin\\!\\left(\\frac{2\\pi n}{9}\\right)$,\n  with an end spike $x_1[N-1] \\leftarrow x_1[N-1] + 0.8$. Kernel: $M = 9$, $\\sigma = 2.0$.\n- Case $\\mathbf{2}$ (sharp boundary step): Signal\n  $x_2[n] = \n  \\begin{cases}\n  0.2, & 0 \\le n \\le 47, \\\\\n  0.9, & 48 \\le n \\le 63,\n  \\end{cases}$\n  Kernel: $M = 15$, $\\sigma = 3.0$.\n- Case $\\mathbf{3}$ (slow ramp with wide kernel): Signal\n  $x_3[n] = 0.1 + 0.9 \\frac{n}{N-1}, \\quad 0 \\le n \\le 63$,\n  Kernel: $M = 31$, $\\sigma = 6.0$.\n- Case $\\mathbf{4}$ (verification with proper padding): Use the same signal as Case $\\mathbf{2}$ and kernel $M = 15$, $\\sigma = 3.0$, but perform DFT-based convolution with padding length $L = N + M - 1$ and extract the \"same\" segment of length $N$.\n\nAnswer Specification:\n- For Cases $\\mathbf{1}$, $\\mathbf{2}$, and $\\mathbf{3}$, output two floats per case in the order: overall MSE and head-interval maximum absolute difference $\\Delta_{\\max}^{\\text{head}}$.\n- For Case $\\mathbf{4}$, output two floats: $\\text{MSE}_{\\text{pad}}$ and $\\Delta_{\\max}^{\\text{pad}}$.\n- Your program should produce a single line of output containing these eight results in order as a comma-separated list enclosed in square brackets, i.e.,\n$[ \\text{MSE}_1, \\Delta_{\\max,1}^{\\text{head}}, \\text{MSE}_2, \\Delta_{\\max,2}^{\\text{head}}, \\text{MSE}_3, \\Delta_{\\max,3}^{\\text{head}}, \\text{MSE}_{\\text{pad}}, \\Delta_{\\max}^{\\text{pad}} ]$.\nAll outputs must be real numbers (floats). No physical units are involved in this problem.",
            "solution": "The problem requires a two-part response: a theoretical derivation of the circular convolution property of the Discrete Fourier Transform (DFT), and a numerical implementation to quantify wrap-around artifacts and verify proper filtering with padding.\n\n**Part 1: Theoretical Derivation of the Circular Convolution Theorem**\n\nThe core of this problem lies in the Convolution Theorem for the DFT. This theorem states that element-wise multiplication of two signals in the frequency domain corresponds to their circular convolution in the time (or sample) domain. We will derive this from first principles as defined in the problem statement.\n\nLet $x[n]$ and $h[n]$ be two discrete, finite-length sequences, both of length $N$. Their DFTs are given by:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn / N}\n$$\n$$\nH[k] = \\sum_{n=0}^{N-1} h[n]\\, e^{-i 2\\pi kn / N}\n$$\n\nLet $y[n]$ be the sequence obtained by taking the Inverse DFT (IDFT) of the product of their DFTs, $Y[k] = X[k]H[k]$. The IDFT is defined as:\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} Y[k]\\, e^{i 2\\pi kn / N}\n$$\n\nTo derive the time-domain operation corresponding to this frequency-domain multiplication, we substitute the expressions for $Y[k]$ and subsequently $H[k]$ into the IDFT formula.\n\nStep 1: Substitute $Y[k] = X[k]H[k]$ into the IDFT definition for $y[n]$.\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] H[k]\\, e^{i 2\\pi kn / N}\n$$\n\nStep 2: Substitute the DFT definition for $H[k]$ into the expression.\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\left( \\sum_{m=0}^{N-1} h[m]\\, e^{-i 2\\pi km / N} \\right) e^{i 2\\pi kn / N}\n$$\n\nStep 3: Since the summations are finite, we can interchange their order and rearrange the terms.\n$$\ny[n] = \\sum_{m=0}^{N-1} h[m] \\left( \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi k(n-m) / N} \\right)\n$$\n\nStep 4: We recognize the expression inside the parentheses. It has the exact form of the IDFT of $X[k]$, but evaluated at index $(n-m)$ instead of $n$.\n$$\nx[j] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kj / N}\n$$\nThus, the expression in the parentheses is $x[n-m]$. Substituting this back, we get:\n$$\ny[n] = \\sum_{m=0}^{N-1} h[m] x[n-m]\n$$\n\nThis expression is the standard form of a convolution sum. However, a crucial subtlety arises from the nature of the DFT. The DFT implicitly assumes that the signals $x[n]$ and $h[n]$ are periodic with period $N$. This is because its basis functions, the complex exponentials $e^{i 2\\pi kn/N}$, are themselves periodic in the time index $n$ with period $N$.\n\nConsequently, any index in the time domain is implicitly treated modulo $N$. Therefore, the expression $x[n-m]$ must be interpreted as $x[(n-m) \\pmod N]$. This leads to the final result:\n$$\ny[n] = \\sum_{m=0}^{N-1} h[m] x[(n-m) \\pmod N]\n$$\n\nThis is the definition of the **circular convolution** of length $N$.\n\n**Explanation of Wrap-Around Artifacts:**\n\nThe periodic nature of the DFT is the source of \"wrap-around\" artifacts when performing convolution. Standard **linear convolution**, which is the desired operation for filtering, is defined as:\n$$\ny_{\\text{lin}}[n] = \\sum_{m=-\\infty}^{\\infty} h[m] x[n-m]\n$$\nFor finite-length signals $x[n]$ (length $N$) and $h[m]$ (length $M$), this sum is finite. When calculating the output at the beginning of the sequence, for example $y_{\\text{lin}}[0] = \\sum_{m=0}^{M-1} h[m]x[-m]$, the filter requires access to samples of $x$ at negative indices. In linear convolution, these samples are treated as zero.\n\nIn circular convolution, however, the index wraps around. The term $x[-m]$ is evaluated as $x[(-m) \\pmod N] = x[N-m]$. This means that when the filter is applied to the beginning of the signal $x[n]$, it \"sees\" the end of the signal ($x[N-1]$, $x[N-2]$, etc.) as if it were prepended. This causes the filtered output at the start of the sequence to be contaminated by the signal values from the end of the sequence, an artifact known as wrap-around. The artifact affects the first $M-1$ samples of the output. A similar effect occurs at the end of the sequence, but the wrap-around from the end to the beginning is the most commonly discussed artifact.\n\nTo correctly compute linear convolution using the DFT, both signals must be zero-padded to a length of at least $L = N+M-1$. This ensures that the circular convolution has a large enough period so that the wrap-around effects only involve the appended zeros, leaving the valid part of the convolution (of length $N+M-1$) unaffected. From this result, the desired segment (e.g., of length $N$ with 'same' alignment) can be extracted.\n\n**Part 2: Numerical Implementation and Verification**\n\nThe provided code will implement the logic described above. It will:\n1.  Construct the input signals and Gaussian filter kernels for each test case.\n2.  Compute circular convolution via DFT multiplication without padding.\n3.  Compute a reference linear convolution using `numpy.convolve` with `mode='same'`, which yields a centered, zero-phase-aligned result.\n4.  Calculate the specified error metrics (MSE and $\\Delta_{\\max}^{\\text{head}}$) to quantify the wrap-around artifacts.\n5.  For the final case, demonstrate that DFT-based convolution with sufficient zero-padding ($L=N+M-1$) correctly reproduces the linear convolution result, showing that the error metrics approach machine precision. The zero-phase alignment of the kernel is achieved by circularly shifting the kernel by $-c$ samples where $c=(M-1)/2$ is the center index, placing the center tap at index $0$ for the FFT. The 'same' alignment for the padded case requires extracting the correct $N$-sample segment from the full $L$-sample linear convolution result.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by demonstrating and quantifying circular convolution artifacts\n    in DFT-based filtering and verifying the padded DFT method.\n    \"\"\"\n    \n    # --- Problem Constants and Test Suite Definition ---\n    N = 64\n    test_cases_params = [\n        {'case': 1, 'M': 9, 'sigma': 2.0},\n        {'case': 2, 'M': 15, 'sigma': 3.0},\n        {'case': 3, 'M': 31, 'sigma': 6.0},\n        {'case': 4, 'M': 15, 'sigma': 3.0}, # Verification case, uses signal from case 2\n    ]\n    \n    results = []\n\n    for params in test_cases_params:\n        case_id = params['case']\n        M = params['M']\n        sigma = params['sigma']\n        \n        # --- 1. Signal Generation ---\n        x = np.zeros(N, dtype=np.float64)\n        if case_id == 1:\n            n = np.arange(N)\n            x = 0.4 + 0.3 * np.sin(2 * np.pi * n / 16) + 0.2 * np.sin(2 * np.pi * n / 9)\n            x[N - 1] += 0.8\n        elif case_id == 2 or case_id == 4:\n            x[0:48] = 0.2\n            x[48:N] = 0.9\n        elif case_id == 3:\n            n = np.arange(N)\n            x = 0.1 + 0.9 * n / (N - 1)\n\n        # --- 2. Gaussian Kernel Generation ---\n        c = (M - 1) // 2\n        kernel_indices = np.arange(M)\n        h = np.exp(-0.5 * ((kernel_indices - c) / sigma) ** 2)\n        h /= np.sum(h)\n\n        # --- 3. Reference Linear Convolution ---\n        # np.convolve with mode='same' computes the linear convolution and returns\n        # the central part of the output that is the same size as the input signal x.\n        # This corresponds to a zero-phase filtering operation.\n        y_lin = np.convolve(x, h, mode='same')\n\n        if case_id in [1, 2, 3]:\n            # --- Unpadded Circular Convolution (Demonstrating Artifacts) ---\n            \n            # Create an N-point kernel for N-point DFT\n            h_N = np.zeros(N)\n            h_N[:M] = h\n            \n            # Circularly shift for zero-phase alignment. Moves h[c] to index 0.\n            h_shifted = np.roll(h_N, -c)\n            \n            # Compute circular convolution via DFT multiplication\n            X = np.fft.fft(x)\n            H = np.fft.fft(h_shifted)\n            y_circ_fft = np.fft.ifft(X * H).real\n            \n            # --- Calculate Metrics for Unpadded Case ---\n            mse = np.mean((y_circ_fft - y_lin)**2)\n            \n            # Max absolute difference over the first M-1 samples\n            delta_max_head = np.max(np.abs(y_circ_fft[:M-1] - y_lin[:M-1]))\n            \n            results.extend([mse, delta_max_head])\n\n        elif case_id == 4:\n            # --- Padded DFT-based Convolution (Verification) ---\n            \n            L = N + M - 1 # Proper padding length for linear convolution\n            \n            # Pad signal and kernel to length L\n            x_pad = np.zeros(L)\n            x_pad[:N] = x\n            \n            h_L = np.zeros(L)\n            h_L[:M] = h\n            \n            # Circularly shift L-point kernel for zero-phase alignment\n            h_shifted_pad = np.roll(h_L, -c)\n            \n            # Compute convolution using padded DFTs\n            X_pad = np.fft.fft(x_pad)\n            H_pad = np.fft.fft(h_shifted_pad)\n            y_pad_full = np.fft.ifft(X_pad * H_pad).real\n            \n            # Extract the 'same' part, which corresponds to the linear convolution\n            # result aligned with the original signal.\n            y_fft_pad = y_pad_full[c : c + N]\n            \n            # --- Calculate Metrics for Padded Case ---\n            mse_pad = np.mean((y_fft_pad - y_lin)**2)\n            delta_max_pad = np.max(np.abs(y_fft_pad - y_lin))\n            \n            results.extend([mse_pad, delta_max_pad])\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the principles of the convolution theorem and proper padding, we can now design and implement sophisticated filters to address common challenges in remote sensing data. This comprehensive practice guides you through three practical filtering scenarios in two dimensions . You will implement a Gaussian low-pass filter to smooth noise, a notch filter to eliminate periodic sensor striping, and a band-pass filter to isolate an oriented wave, developing your ability to translate a filtering goal into a precise frequency-domain multiplication mask.",
            "id": "3813486",
            "problem": "A two-dimensional discrete field representing a remote sensing scene can be filtered in the frequency domain using the Discrete Fourier Transform (DFT). Consider an $N_x \\times N_y$ real-valued array $x[n_x,n_y]$ for indices $n_x \\in \\{0,1,\\dots,N_x-1\\}$ and $n_y \\in \\{0,1,\\dots,N_y-1\\}$. The two-dimensional DFT (Discrete Fourier Transform) and its inverse are defined by\n$$\nX[k_x,k_y] = \\sum_{n_x=0}^{N_x-1}\\sum_{n_y=0}^{N_y-1} x[n_x,n_y] \\exp\\left(-2\\pi i\\left(\\frac{k_x n_x}{N_x}+\\frac{k_y n_y}{N_y}\\right)\\right),\n$$\n$$\nx[n_x,n_y] = \\frac{1}{N_x N_y} \\sum_{k_x=0}^{N_x-1}\\sum_{k_y=0}^{N_y-1} X[k_x,k_y] \\exp\\left(2\\pi i\\left(\\frac{k_x n_x}{N_x}+\\frac{k_y n_y}{N_y}\\right)\\right).\n$$\nLet $\\mathbf{k}=(k_x,k_y)$ denote discrete frequency coordinates. According to the convolution theorem, linear shift-invariant spatial filtering corresponds to frequency-domain multiplication by a prescribed frequency response $H(\\mathbf{k})$. In remote sensing and environmental modeling, this is used to suppress scanning stripes, attenuate high-frequency noise, or enhance oriented features.\n\nYour task is to implement the following procedure for each test case:\n- Construct the specified synthetic scene $x[n_x,n_y]$ and the specified frequency-domain filter $H(\\mathbf{k})$ using the discrete frequency variables $f_x \\in \\mathrm{fftfreq}(N_x)$ and $f_y \\in \\mathrm{fftfreq}(N_y)$, which enumerate normalized discrete frequencies in cycles per sample along each dimension. Use these $f_x, f_y$ to parametrize $H(f_x,f_y)$.\n- Compute the DFT $X(\\mathbf{k})$ of $x[n_x,n_y]$.\n- Form the filtered spectrum via frequency-domain multiplication consistent with the convolution theorem, then reconstruct the spatial-domain filtered result $y[n_x,n_y]$ using the inverse DFT. Because $x$ is real-valued, report the real part of $y$ after inverse DFT.\n- Compute the specified scalar metric for each case.\n\nDefinitions and constraints:\n- Use the convention and scaling implemented by standard library DFTs: forward transform without normalization and inverse transform normalized by $1/(N_x N_y)$.\n- All frequency-domain filters are functions of the normalized discrete frequencies $f_x$ and $f_y$ in cycles per sample, as returned by $\\mathrm{fftfreq}(\\cdot)$.\n- Angles are not used; no angle units are required.\n- No physical units are involved; all quantities are unitless real numbers.\n\nTest suite specification:\nImplement the following three test cases. In all formulas below, indices $n$ and $m$ denote $n_x$ and $n_y$ respectively, and $\\exp(\\cdot)$ denotes the natural exponential.\n\n1) Case A (isotropic Gaussian low-pass on a multi-blob scene with checkerboard noise):\n- Grid size: $N_x=32$, $N_y=32$.\n- Scene: $x[n,m] = 0.2 + 0.4\\exp\\left(-\\frac{(n-10)^2+(m-18)^2}{2\\cdot 5^2}\\right) + 0.3\\exp\\left(-\\frac{(n-22)^2+(m-11)^2}{2\\cdot 3^2}\\right) + 0.05(-1)^{n+m}$.\n- Filter (frequency response): $H(f_x,f_y) = \\exp\\left(-\\frac{f_x^2+f_y^2}{2\\sigma_k^2}\\right)$, with $\\sigma_k = 0.08$.\n- Metric to compute: $r_1 = \\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} |y[n,m] - x[n,m]|$.\n\n2) Case B (notch filtering stripes at a known frequency):\n- Grid size: $N_x=64$, $N_y=64$.\n- Scene: $x[n,m] = 0.1 + 0.25\\exp\\left(-\\frac{(n-30)^2+(m-30)^2}{2\\cdot 6^2}\\right) + 0.15\\sin\\left(2\\pi f_0 m\\right)$, with $f_0=0.25$ cycles per sample along the $m$-axis.\n- Filter (frequency response, ideal notch in the $f_y$ direction): $H(f_x,f_y) = \n\\begin{cases}\n0, & \\text{if } |f_y - f_0|\\le b_w \\text{ or } |f_y + f_0|\\le b_w,\\\\\n1, & \\text{otherwise},\n\\end{cases}$\nwith $b_w=0.02$.\n- Metric to compute (residual stripe projection magnitude): $r_2 = \\left|\\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]\\sin\\left(2\\pi f_0 m\\right)\\right|$.\n\n3) Case C (elliptical band-pass to select an oriented plane wave):\n- Grid size: $N_x=48$, $N_y=64$.\n- Scene: $x[n,m] = 0.2 + 0.1\\exp\\left(-\\frac{(n-20)^2+(m-20)^2}{2\\cdot 7^2}\\right) + 0.25\\cos\\left(2\\pi(f_x^{(1)}n + f_y^{(1)}m)\\right) + 0.08\\cos\\left(2\\pi(0.20\\,n - 0.16\\,m)\\right)$, with $f_x^{(1)}=0.12$ and $f_y^{(1)}=0.04$.\n- Filter (frequency response: sum of two elliptical Gaussian lobes centered at the target frequency and its negative, clipped to unity): $H(f_x,f_y) = \\min\\left\\{1,\\ \\exp\\left(-\\frac{(f_x-f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y-f_y^{(1)})^2}{2s_y^2}\\right) + \\exp\\left(-\\frac{(f_x+f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y+f_y^{(1)})^2}{2s_y^2}\\right)\\right\\}$, with $s_x=0.02$ and $s_y=0.03$.\n- Metric to compute (energy ratio): $r_3 = \\frac{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]^2}{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} x[n,m]^2}$.\n\nProgram requirements:\n- Implement the above three cases using a two-dimensional DFT and inverse DFT to realize the filtering implied by the convolution theorem.\n- Use the standard convention that $f_x=\\mathrm{fftfreq}(N_x)$ and $f_y=\\mathrm{fftfreq}(N_y)$ produce arrays of normalized discrete frequencies in cycles per sample.\n- For each case, produce the scalar metrics $r_1$, $r_2$, and $r_3$ as defined.\n- Final output format: Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (for example, \"[0.123456,0.000789,0.456123]\").",
            "solution": "The problem has been validated and is determined to be sound. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The definitions and procedures align with established principles of digital signal processing and Fourier analysis.\n\nThe core principle underpinning the solution is the convolution theorem. This theorem states that a linear, shift-invariant filtering operation, which corresponds to convolution in the spatial domain, is equivalent to element-wise multiplication in the frequency domain. The procedure for filtering a two-dimensional discrete signal $x[n_x, n_y]$ of size $N_x \\times N_y$ is as follows:\n\n1.  **Forward Fourier Transform**: The spatial-domain signal $x[n_x, n_y]$ is transformed into the frequency domain by computing its two-dimensional Discrete Fourier Transform (DFT).\n    $$\n    X[k_x, k_y] = \\mathcal{F}\\{x[n_x, n_y]\\}\n    $$\n    The resulting complex-valued array $X[k_x, k_y]$ represents the spectrum of the signal, indicating the amplitude and phase of each discrete frequency component $(k_x, k_y)$.\n\n2.  **Frequency-Domain Multiplication**: A filter is defined by its frequency response, $H(f_x, f_y)$, which is a function of the normalized discrete frequencies $f_x$ and $f_y$. This function is sampled on the same discrete frequency grid as $X[k_x, k_y]$ to create a filter mask $H[k_x, k_y]$. The filtered spectrum $Y[k_x, k_y]$ is obtained by multiplying the signal's spectrum by the filter mask.\n    $$\n    Y[k_x, k_y] = X[k_x, k_y] \\cdot H[k_x, k_y]\n    $$\n\n3.  **Inverse Fourier Transform**: The filtered signal in the spatial domain, $y[n_x, n_y]$, is recovered by applying the inverse two-dimensional DFT to the filtered spectrum $Y[k_x, k_y]$.\n    $$\n    y[n_x, n_y] = \\mathcal{F}^{-1}\\{Y[k_x, k_y]\\}\n    $$\n    The definition of the inverse DFT includes a normalization factor of $1/(N_x N_y)$. Since the input signal $x[n_x, n_y]$ is real-valued and the filters are constructed to have Hermitian symmetry ($H[k_x, k_y] = H^*[-k_x, -k_y]$), the resulting signal $y[n_x, n_y]$ should be real. Due to finite-precision arithmetic, small imaginary components may arise, so the real part of the result is taken as the final filtered signal.\n\nThe normalized discrete frequencies, $f_x$ and $f_y$, are given in cycles per sample and are crucial for defining resolution-independent filters. They are generated for each dimension using a function equivalent to `fftfreq`, which arranges the frequency components in an order compatible with standard Fast Fourier Transform (FFT) algorithms.\n\nThe three test cases specified in the problem serve to illustrate distinct filtering objectives common in remote sensing and image processing.\n\n**Case A: Isotropic Low-Pass Filtering**\nThe scene is defined on a $32 \\times 32$ grid and is composed of a constant background, two Gaussian-shaped features of different sizes, and a high-frequency checkerboard noise term, $0.05(-1)^{n+m}$. This noise component corresponds to the highest frequency representable on the discrete grid. The filter is an isotropic Gaussian low-pass filter:\n$$\nH(f_x, f_y) = \\exp\\left(-\\frac{f_x^2+f_y^2}{2\\sigma_k^2}\\right), \\quad \\sigma_k = 0.08\n$$\nThis filter attenuates high-frequency components while preserving low-frequency ones. The parameter $\\sigma_k$ controls the cutoff frequency; a smaller $\\sigma_k$ results in more aggressive blurring. The objective is to suppress the checkerboard noise while minimally affecting the broader Gaussian features. The metric $r_1$, the mean absolute difference between the original and filtered signals, quantifies the total modification introduced by the filter.\n$$\nr_1 = \\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} \\left| y[n,m] - x[n,m] \\right|\n$$\n\n**Case B: Notch Filtering**\nThe scene, on a $64 \\times 64$ grid, contains a Gaussian feature and a periodic striping artifact, represented by a sine wave $0.15\\sin(2\\pi f_0 m)$ with a single normalized frequency $f_0 = 0.25$ cycles per sample along the $m$-axis. The objective is to remove this specific artifact. This is achieved with a notch filter, which is designed to eliminate a narrow band of frequencies. The frequency response is:\n$$\nH(f_x,f_y) = \n\\begin{cases}\n0, & \\text{if } |f_y - f_0|\\le b_w \\text{ or } |f_y + f_0|\\le b_w,\\\\\n1, & \\text{otherwise},\n\\end{cases}\n$$\nwith a notch half-width of $b_w=0.02$. The filter sets the frequency components within the specified bands around $\\pm f_0$ to zero. The inclusion of the band around $-f_0$ ensures the filter has the required symmetry to produce a real-valued output. The metric $r_2$ computes the magnitude of the projection of the filtered signal onto the original stripe pattern, effectively measuring the residual stripe energy. A successful filtering operation will yield a value of $r_2$ close to zero.\n$$\nr_2 = \\left|\\frac{1}{N_x N_y}\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]\\sin\\left(2\\pi f_0 m\\right)\\right|\n$$\n\n**Case C: Elliptical Band-Pass Filtering**\nThis case involves a scene on a $48 \\times 64$ grid containing a Gaussian feature and two oriented plane waves (cosine functions) with different frequency vectors $(f_x, f_y)$. The objective is to isolate one of these waves, specifically the one with frequency $(f_x^{(1)}, f_y^{(1)}) = (0.12, 0.04)$. The filter is an elliptical band-pass filter:\n$$\nH(f_x,f_y) = \\min\\left\\{1,\\ \\exp\\left(-\\frac{(f_x-f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y-f_y^{(1)})^2}{2s_y^2}\\right) + \\exp\\left(-\\frac{(f_x+f_x^{(1)})^2}{2s_x^2} - \\frac{(f_y+f_y^{(1)})^2}{2s_y^2}\\right)\\right\\}\n$$\nwith parameters $s_x=0.02$ and $s_y=0.03$. A real-valued cosine wave with frequency vector $\\mathbf{f_1} = (f_x^{(1)}, f_y^{(1)})$ has its energy concentrated at two points in the frequency domain: $\\mathbf{f_1}$ and $-\\mathbf{f_1}$. The filter is therefore constructed as the sum of two elliptical Gaussian lobes, one centered at $\\mathbf{f_1}$ and the other at $-\\mathbf{f_1}$, to capture both components. The metric $r_3$ is the ratio of the energy of the filtered signal to the energy of the original signal, indicating what fraction of the total signal energy is passed by the filter.\n$$\nr_3 = \\frac{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} y[n,m]^2}{\\sum_{n=0}^{N_x-1}\\sum_{m=0}^{N_y-1} x[n,m]^2}\n$$\nThe implementation will follow these steps precisely for each case, utilizing numerical libraries for the FFT computations.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three test cases for frequency domain filtering and prints the results.\n    \"\"\"\n\n    def solve_case_a():\n        \"\"\"\n        Case A: Isotropic Gaussian low-pass on a multi-blob scene with checkerboard noise.\n        \"\"\"\n        Nx, Ny = 32, 32\n        sigma_k = 0.08\n\n        # Construct the spatial grid and scene\n        n, m = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n        \n        scene = (\n            0.2\n            + 0.4 * np.exp(-((n - 10)**2 + (m - 18)**2) / (2 * 5**2))\n            + 0.3 * np.exp(-((n - 22)**2 + (m - 11)**2) / (2 * 3**2))\n            + 0.05 * (-1)**(n + m)\n        )\n\n        # Construct the frequency grid and filter\n        fx = np.fft.fftfreq(Nx)\n        fy = np.fft.fftfreq(Ny)\n        Fx, Fy = np.meshgrid(fx, fy, indexing='ij')\n\n        H = np.exp(-(Fx**2 + Fy**2) / (2 * sigma_k**2))\n\n        # Apply filtering\n        X = np.fft.fft2(scene)\n        Y_freq = X * H\n        y_filtered = np.real(np.fft.ifft2(Y_freq))\n\n        # Compute metric\n        r1 = np.mean(np.abs(y_filtered - scene))\n        return r1\n\n    def solve_case_b():\n        \"\"\"\n        Case B: Notch filtering stripes at a known frequency.\n        \"\"\"\n        Nx, Ny = 64, 64\n        f0 = 0.25\n        bw = 0.02\n\n        # Construct the spatial grid and scene\n        n, m = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n        \n        scene = (\n            0.1\n            + 0.25 * np.exp(-((n - 30)**2 + (m - 30)**2) / (2 * 6**2))\n            + 0.15 * np.sin(2 * np.pi * f0 * m)\n        )\n\n        # Construct the frequency grid and filter\n        fx = np.fft.fftfreq(Nx)\n        fy = np.fft.fftfreq(Ny)\n        Fx, Fy = np.meshgrid(fx, fy, indexing='ij')\n\n        H = np.ones((Nx, Ny))\n        notch_condition = (np.abs(Fy - f0) <= bw) | (np.abs(Fy + f0) <= bw)\n        H[notch_condition] = 0\n\n        # Apply filtering\n        X = np.fft.fft2(scene)\n        Y_freq = X * H\n        y_filtered = np.real(np.fft.ifft2(Y_freq))\n\n        # Compute metric\n        stripe_component = np.sin(2 * np.pi * f0 * m)\n        r2 = np.abs(np.mean(y_filtered * stripe_component))\n        return r2\n\n    def solve_case_c():\n        \"\"\"\n        Case C: Elliptical band-pass to select an oriented plane wave.\n        \"\"\"\n        Nx, Ny = 48, 64\n        fx1, fy1 = 0.12, 0.04\n        sx, sy = 0.02, 0.03\n        \n        # Construct the spatial grid and scene\n        n, m = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n\n        scene = (\n            0.2\n            + 0.1 * np.exp(-((n - 20)**2 + (m - 20)**2) / (2 * 7**2))\n            + 0.25 * np.cos(2 * np.pi * (fx1 * n + fy1 * m))\n            + 0.08 * np.cos(2 * np.pi * (0.20 * n - 0.16 * m))\n        )\n        \n        # Construct the frequency grid and filter\n        fx = np.fft.fftfreq(Nx)\n        fy = np.fft.fftfreq(Ny)\n        Fx, Fy = np.meshgrid(fx, fy, indexing='ij')\n\n        lobe1 = np.exp(-((Fx - fx1)**2 / (2 * sx**2) + (Fy - fy1)**2 / (2 * sy**2)))\n        lobe2 = np.exp(-((Fx + fx1)**2 / (2 * sx**2) + (Fy + fy1)**2 / (2 * sy**2)))\n        \n        H = np.minimum(1.0, lobe1 + lobe2)\n\n        # Apply filtering\n        X = np.fft.fft2(scene)\n        Y_freq = X * H\n        y_filtered = np.real(np.fft.ifft2(Y_freq))\n\n        # Compute metric\n        energy_y = np.sum(y_filtered**2)\n        energy_x = np.sum(scene**2)\n        r3 = energy_y / energy_x\n        return r3\n\n    # Calculate results for all cases\n    r1 = solve_case_a()\n    r2 = solve_case_b()\n    r3 = solve_case_c()\n    results = [r1, r2, r3]\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}