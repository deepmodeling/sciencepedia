{
    "hands_on_practices": [
        {
            "introduction": "干涉雷达测量中的相位信息直接源于两次观测的几何路径差异。在深入研究地形或形变等复杂信号之前，我们首先需要理解并处理由卫星或飞行器基线引起的系统性相位变化，即“平地效应”。本练习将引导你从第一性原理出发，推导非零垂直基线如何在距离向引入确定的相位梯度，并揭示当此梯度过大时如何导致相位混叠，从而为干涉测量设定一个根本性的几何限制。",
            "id": "3857775",
            "problem": "一部机载单航过跨航迹干涉合成孔径雷达（InSAR；Interferometric Synthetic Aperture Radar）在高度$H$处对局部平坦的地面进行成像。斜距采样间隔为$\\Delta r$（在斜距方向上）。雷达波长为$\\lambda$，场景中心的入射角为$\\theta$，从局部垂直方向测量。两个由纯跨航迹基线（无沿航迹分量）分隔的相位同步天线形成一幅干涉图。假设地球是局部平坦的，大气是均匀的，并且平台运动误差在合成孔径时间内可以忽略不计。斜距采样是均匀的。\n\n仅从以下基本原理出发：\n- 合成孔径雷达（SAR；Synthetic Aperture Radar）像素的复相位与双程路径长度成正比，因此对于路径长度$r$，相位为$4\\pi r/\\lambda$模$2\\pi$。\n- 对于一个固定目标，由固定基线向量$\\mathbf{B}$分隔的两个天线之间的斜距差，在一阶近似$|\\mathbf{B}|/r$下，是$\\mathbf{B}$在视线单位向量$\\hat{\\mathbf{s}}$上投影的负值，干涉相位与此距离差成正比。\n- 对于高度为$H$的平台，关联斜距$r$和入射角$\\theta$（从垂直方向测量）的平坦地球几何关系是$r=H/\\cos\\theta$。\n\n根据这些基本原理，推导非零跨航迹基线如何在斜距上引起确定性的相位梯度，并解释为什么当以间隔$\\Delta r$采样时，该梯度会导致干涉相位混叠。然后，通过要求相邻斜距像素之间的相位变化幅度不超过$\\pi$弧度，得到最大允许垂直基线$B_{\\perp,\\max}$关于$\\lambda$、$H$、$\\theta$和$\\Delta r$的解析表达式。\n\n最后，对以下机载X波段情景进行数值计算$B_{\\perp,\\max}$：\n- $\\lambda = 0.031\\,\\mathrm{m}$，\n- $H = 12{,}000\\,\\mathrm{m}$，\n- $\\theta = 37^{\\circ}$，\n- $\\Delta r = 0.60\\,\\mathrm{m}$。\n\n以米为单位表示$B_{\\perp,\\max}$的最终答案，并将您的答案四舍五入到三位有效数字。角度以度为单位指定；在对角度求导数时，将$\\theta$视为以弧度为单位。",
            "solution": "问题要求推导干涉相位相对于斜距的梯度，解释其可能导致混叠的原因，并随后推导最大允许垂直基线$B_{\\perp,\\max}$。\n\n让我们从所提供的基本原理开始。\n\n**1. 干涉相位及其梯度**\n\n根据基本原理1，合成孔径雷达（SAR）信号的相位与从天线到目标的往返或“双程”路径长度成正比。对于位于位置$\\mathbf{p}_1$的单个天线和地面上的一个目标，路径长度为$r_1$，相位为$\\phi_1 = \\frac{4\\pi r_1}{\\lambda}$。对于位于位置$\\mathbf{p}_2 = \\mathbf{p}_1 + \\mathbf{B}$的第二个天线，其中$\\mathbf{B}$是基线向量，路径长度为$r_2$，相位为$\\phi_2 = \\frac{4\\pi r_2}{\\lambda}$。干涉相位$\\Delta\\phi$是这两个相位之差：\n$$ \\Delta\\phi = \\phi_2 - \\phi_1 = \\frac{4\\pi}{\\lambda} (r_2 - r_1) = \\frac{4\\pi}{\\lambda} \\Delta r_{geo} $$\n其中$\\Delta r_{geo}$是几何斜距差。\n\n根据基本原理2，这个斜距差在一阶近似下由基线向量$\\mathbf{B}$在视线单位向量$\\hat{\\mathbf{s}}$上投影的负值给出：\n$$ \\Delta r_{geo} \\approx -\\mathbf{B} \\cdot \\hat{\\mathbf{s}} $$\n当基线长度$|\\mathbf{B}|$远小于斜距$r$时，此近似有效。结合这些，得到干涉相位：\n$$ \\Delta\\phi \\approx -\\frac{4\\pi}{\\lambda} (\\mathbf{B} \\cdot \\hat{\\mathbf{s}}) $$\n该相位贡献纯粹由平坦表面的采集几何引起，被称为“平坦地球”相位。\n\n为了求得斜距上的相位梯度，我们必须将此相位表示为斜距$r$的函数。让我们在跨航迹（距离）平面内建立一个二维坐标系。飞机在局部平坦地球上方的高度为$H$，因此其位置是$(0, H)$。地面上的一个目标距离星下点轨迹的水平距离为$x$，位置在$(x, 0)$。斜距为$r = \\sqrt{x^2 + H^2}$。入射角$\\theta$是从垂直方向测量的，因此$\\sin\\theta = x/r$且$\\cos\\theta = H/r$。从传感器到目标的视线单位向量是$\\hat{\\mathbf{s}} = (\\sin\\theta, -\\cos\\theta)$。\n\n对于平坦地球，干涉相位相对于斜距的梯度，也称为“条纹率”，其大小由以下标准公式给出：\n$$ \\left|\\frac{d(\\Delta\\phi)}{dr}\\right| = \\frac{4\\pi |B_{\\perp}|}{\\lambda r \\tan\\theta} $$\n其中 $B_{\\perp}$ 是垂直于视线方向的基线分量。这个表达式表示了在平坦地球上，由非零跨航迹基线引起的、沿斜距的确定性相位梯度。\n\n**2. 干涉相位的混叠**\n\nSAR系统不是连续采集数据，而是在离散的斜距间隔$\\Delta r$上采集。斜距方向上两个相邻像素之间的相位差$\\Delta\\phi_{pixel}$可以用相位梯度来近似：\n$$ \\Delta\\phi_{pixel} \\approx \\frac{d(\\Delta\\phi)}{dr} \\Delta r $$\n奈奎斯特采样定理（Nyquist sampling theorem）应用于空间采样时，规定了要无歧义地测量信号的频率，采样率必须至少是最高频率的两倍。在相位的背景下，这意味着连续样本之间的相位变化幅度不能超过$\\pi$弧度。如果$|\\Delta\\phi_{pixel}| > \\pi$，相位就会发生混叠。例如，一个$1.2\\pi$的真实相位变化将被测量为$1.2\\pi - 2\\pi = -0.8\\pi$，因为干涉相位是模$2\\pi$测量的。真实的、快速的相位变化被误解为较慢的变化，甚至可能符号相反。这种现象就是平坦地球条纹图案的混叠。\n\n**3. 最大允许垂直基线**\n\n问题给出了防止混叠的条件：相邻斜距像素之间的相位变化幅度不得超过$\\pi$弧度。\n$$ |\\Delta\\phi_{pixel}| \\le \\pi $$\n代入$\\Delta\\phi_{pixel}$的表达式：\n$$ \\left| \\frac{4\\pi B_{\\perp}}{\\lambda r \\tan\\theta} \\Delta r \\right| \\le \\pi $$\n假设$B_{\\perp}$表示垂直基线的幅度（因此为非负值），我们可以求解其最大允许值$B_{\\perp,\\max}$：\n$$ \\frac{4\\pi B_{\\perp,\\max}}{\\lambda r \\tan\\theta} \\Delta r = \\pi $$\n$$ B_{\\perp,\\max} = \\frac{\\pi \\lambda r \\tan\\theta}{4\\pi \\Delta r} = \\frac{\\lambda r \\tan\\theta}{4 \\Delta r} $$\n问题要求用$\\lambda$、$H$、$\\theta$和$\\Delta r$表示该表达式。我们代入$r = H/\\cos\\theta$：\n$$ B_{\\perp,\\max} = \\frac{\\lambda (H/\\cos\\theta) \\tan\\theta}{4 \\Delta r} = \\frac{\\lambda H (\\sin\\theta/\\cos\\theta)}{4 \\Delta r \\cos\\theta} $$\n这给出了最终的解析表达式：\n$$ B_{\\perp,\\max} = \\frac{\\lambda H \\sin\\theta}{4 \\Delta r \\cos^2\\theta} $$\n\n**4. 数值计算**\n\n最后，我们针对给定的机载X波段情景计算$B_{\\perp,\\max}$：\n- $\\lambda = 0.031\\,\\mathrm{m}$\n- $H = 12000\\,\\mathrm{m}$\n- $\\theta = 37^{\\circ}$\n- $\\Delta r = 0.60\\,\\mathrm{m}$\n\n将这些值代入表达式：\n$$ B_{\\perp,\\max} = \\frac{(0.031) \\cdot (12000) \\cdot \\sin(37^{\\circ})}{4 \\cdot (0.60) \\cdot \\cos^2(37^{\\circ})} $$\n$$ B_{\\perp,\\max} = \\frac{372 \\cdot \\sin(37^{\\circ})}{2.4 \\cdot \\cos^2(37^{\\circ})} $$\n使用三角函数的值$\\sin(37^{\\circ}) \\approx 0.601815$和$\\cos(37^{\\circ}) \\approx 0.798636$：\n$$ B_{\\perp,\\max} \\approx \\frac{372 \\cdot 0.601815}{2.4 \\cdot (0.798636)^2} \\approx \\frac{223.875}{2.4 \\cdot 0.637819} \\approx \\frac{223.875}{1.530766} \\approx 146.251\\,\\mathrm{m} $$\n按照要求将结果四舍五入到三位有效数字，我们得到$146\\,\\mathrm{m}$。",
            "answer": "$$\\boxed{146}$$"
        },
        {
            "introduction": "相干性是评价干涉相位质量的核心指标，直接影响着我们对地表形变或高程测量结果的信心。然而，从有限数据中估算的样本相干性本身存在统计偏差，这会进一步传递到对相位不确定性的评估中。本练习将带你深入探讨这一统计现象，从克拉默-拉奥下界（Cramér–Rao lower bound）出发，分析相干性估算偏差如何影响相位方差的预测，并最终构建一个偏差校正后的相位方差估算器，以获得更准确的测量质量评估。",
            "id": "3857718",
            "problem": "考虑两幅已配准的复合成孔径雷达（SAR）单视复数（SLC）图像，它们被建模为零均值、单位方差、复相干性为 $\\gamma = \\rho \\exp(j \\phi)$ 的联合圆复高斯随机变量，其中 $\\rho \\in [0,1]$ 是相干性幅度，$\\phi$ 是干涉相位。令 $L \\geq 2$ 表示用于形成多视干涉图的有效独立视数。幅度平方样本相干性定义为 $|\\hat{\\gamma}|^{2}$，以常规方式从 $L$ 个视数计算得出，并且在圆复高斯模型下，其期望已知满足 $\\mathbb{E}\\{|\\hat{\\gamma}|^{2}\\} = \\frac{1}{L} + \\rho^{2}\\left(1 - \\frac{1}{L}\\right)$。\n\n从圆复高斯向量的相位参数的费雪信息和克拉默-拉奥下界出发，推导干涉相位方差 $\\sigma_{\\phi}^{2}$ 对 $L$ 和真实相干性平方 $\\rho^{2}$ 的依赖关系。然后，分析 $|\\hat{\\gamma}|^{2}$ 中的偏差如何传播到将 $|\\hat{\\gamma}|^{2}$ 替换为 $\\rho^{2}$ 的朴素相位方差预测器的偏差中。最后，通过对 $|\\hat{\\gamma}|^{2}$ 的已知期望进行反演以获得 $\\rho^{2}$ 的无偏估计量，并将其代入相位方差表达式中，提出一个相位方差的偏差校正估计量。\n\n您的最终答案必须是偏差校正相位方差估计量 $\\hat{\\sigma}_{\\phi,\\mathrm{bc}}^{2}$ 的单个闭式解析表达式，以 $\\mathrm{rad}^{2}$ 为单位，表示为 $L$ 和 $|\\hat{\\gamma}|^{2}$ 的函数。无需进行数值评估。",
            "solution": "解题过程将按要求分为三部分：首先，推导理论干涉相位方差；其次，分析偏差传播；第三，推导偏差校正的相位方差估计量。\n\n**第一部分：干涉相位方差（$\\sigma_{\\phi}^{2}$）的推导**\n\n克拉默-拉奥下界（CRLB）为任何无偏估计量的方差提供了一个下界。对于一个有效估计量，可以达到这个界限。干涉相位的方差 $\\sigma_{\\phi}^{2}$ 可以作为 CRLB 推导得出，它是相位参数 $\\phi$ 的费雪信息 $I(\\phi)$ 的倒数。\n\n我们考虑一组 $L$ 个独立视数。对于每个视数 $k$，我们有一对复值 SAR 测量值 $s_{1k}$ 和 $s_{2k}$，它们被建模为零均值、联合圆复高斯随机变量。单个视数的观测向量为 $\\mathbf{s}_k = \\begin{pmatrix} s_{1k}  s_{2k} \\end{pmatrix}^T$。协方差矩阵 $\\mathbf{C}$ 由下式给出：\n$$\n\\mathbf{C} = \\mathbb{E}\\{\\mathbf{s}_k \\mathbf{s}_k^H\\} = \\begin{pmatrix} \\mathbb{E}\\{|s_{1k}|^2\\}  \\mathbb{E}\\{s_{1k} s_{2k}^*\\} \\\\ \\mathbb{E}\\{s_{2k} s_{1k}^*\\}  \\mathbb{E}\\{|s_{2k}|^2\\} \\end{pmatrix}\n$$\n给定单位方差，$\\mathbb{E}\\{|s_{1k}|^2\\} = 1$ 且 $\\mathbb{E}\\{|s_{2k}|^2\\} = 1$。复相干性 $\\gamma = \\rho \\exp(j\\phi)$ 定义为 $\\gamma = \\mathbb{E}\\{s_{1k}s_{2k}^*\\}$。因此，协方差矩阵变为：\n$$\n\\mathbf{C} = \\begin{pmatrix} 1  \\gamma \\\\ \\gamma^*  1 \\end{pmatrix} = \\begin{pmatrix} 1  \\rho e^{j\\phi} \\\\ \\rho e^{-j\\phi}  1 \\end{pmatrix}\n$$\n$\\mathbf{C}$ 的行列式是 $\\det(\\mathbf{C}) = 1 - |\\gamma|^2 = 1 - \\rho^2$。单个视数 $\\mathbf{s}_k$ 的概率密度函数（PDF）是：\n$$\np(\\mathbf{s}_k; \\rho, \\phi) = \\frac{1}{\\pi^2 \\det(\\mathbf{C})} \\exp(-\\mathbf{s}_k^H \\mathbf{C}^{-1} \\mathbf{s}_k)\n$$\n$L$ 个独立视数的对数似然函数 $\\ln \\mathcal{L}$ 是各个对数似然的总和：\n$$\n\\ln \\mathcal{L}(\\rho, \\phi; \\{\\mathbf{s}_k\\}) = \\sum_{k=1}^L \\ln p(\\mathbf{s}_k) = -2L\\ln\\pi - L\\ln(1-\\rho^2) - \\sum_{k=1}^L \\mathbf{s}_k^H \\mathbf{C}^{-1} \\mathbf{s}_k\n$$\n其中 $\\mathbf{C}^{-1} = \\frac{1}{1-\\rho^2} \\begin{pmatrix} 1  -\\gamma \\\\ -\\gamma^*  1 \\end{pmatrix}$。与对 $\\phi$ 的导数相关的项是指​​数中包含 $\\gamma$ 的部分：\n$$\n\\ln \\mathcal{L} = \\mathrm{const} - L\\ln(1-\\rho^2) - \\frac{1}{1-\\rho^2} \\sum_{k=1}^L \\left( |s_{1k}|^2 + |s_{2k}|^2 - \\gamma s_{2k}s_{1k}^* - \\gamma^* s_{1k}s_{2k}^* \\right)\n$$\n$\\phi$ 的费雪信息为 $I(\\phi) = -\\mathbb{E}\\left\\{ \\frac{\\partial^2 \\ln \\mathcal{L}}{\\partial \\phi^2} \\right\\}$。我们将 $\\rho$ 视为常数，计算关于 $\\phi$ 的导数。注意 $\\frac{\\partial \\gamma}{\\partial \\phi} = j\\rho e^{j\\phi} = j\\gamma$ 和 $\\frac{\\partial \\gamma^*}{\\partial \\phi} = -j\\rho e^{-j\\phi} = -j\\gamma^*$。\n$$\n\\frac{\\partial \\ln \\mathcal{L}}{\\partial \\phi} = -\\frac{1}{1-\\rho^2} \\sum_{k=1}^L \\left( - (j\\gamma) s_{2k}s_{1k}^* - (-j\\gamma^*) s_{1k}s_{2k}^* \\right) = \\frac{j}{1-\\rho^2} \\sum_{k=1}^L \\left( \\gamma s_{2k}s_{1k}^* - \\gamma^* s_{1k}s_{2k}^* \\right)\n$$\n这可以写成 $\\frac{2}{1-\\rho^2} \\text{Im}\\{\\gamma^* \\sum_{k=1}^L s_{1k}s_{2k}^*\\}$。二阶导数是：\n$$\n\\frac{\\partial^2 \\ln \\mathcal{L}}{\\partial \\phi^2} = \\frac{j}{1-\\rho^2} \\sum_{k=1}^L \\left( (j\\gamma) s_{2k}s_{1k}^* - (-j\\gamma^*) s_{1k}s_{2k}^* \\right) = \\frac{-1}{1-\\rho^2} \\sum_{k=1}^L \\left( \\gamma s_{2k}s_{1k}^* + \\gamma^* s_{1k}s_{2k}^* \\right)\n$$\n这等价于 $\\frac{-2}{1-\\rho^2} \\text{Re}\\{\\gamma^* \\sum_{k=1}^L s_{1k}s_{2k}^*\\}$。现在我们取期望：\n$$\n\\mathbb{E}\\left\\{ \\frac{\\partial^2 \\ln \\mathcal{L}}{\\partial \\phi^2} \\right\\} = \\frac{-2}{1-\\rho^2} \\text{Re}\\left\\{\\gamma^* \\mathbb{E}\\left\\{\\sum_{k=1}^L s_{1k}s_{2k}^*\\right\\}\\right\\}\n$$\n因为 $\\mathbb{E}\\{s_{1k}s_{2k}^*\\} = \\gamma$，所以我们有 $\\mathbb{E}\\{\\sum_{k=1}^L s_{1k}s_{2k}^*\\} = L\\gamma$。\n$$\n\\mathbb{E}\\left\\{ \\frac{\\partial^2 \\ln \\mathcal{L}}{\\partial \\phi^2} \\right\\} = \\frac{-2}{1-\\rho^2} \\text{Re}\\{\\gamma^* (L\\gamma)\\} = \\frac{-2L}{1-\\rho^2} \\text{Re}\\{|\\gamma|^2\\} = \\frac{-2L\\rho^2}{1-\\rho^2}\n$$\n费雪信息是该量的负值：\n$$\nI(\\phi) = - \\left( \\frac{-2L\\rho^2}{1-\\rho^2} \\right) = \\frac{2L\\rho^2}{1-\\rho^2}\n$$\n相位方差的 CRLB 是 $\\sigma_{\\phi}^2 \\geq I(\\phi)^{-1}$。假设有一个有效估计量（对于大的 $L$，最大似然估计量是有效的），我们有：\n$$\n\\sigma_{\\phi}^2 = \\frac{1-\\rho^2}{2L\\rho^2}\n$$\n\n**第二部分：偏差传播分析**\n\n通过在推导出的表达式中用幅度平方样本相干性 $|\\hat{\\gamma}|^2$ 代替真实相干性平方 $\\rho^2$，可以构成一个朴素的相位方差估计量 $\\hat{\\sigma}_{\\phi, \\text{naive}}^2$：\n$$\n\\hat{\\sigma}_{\\phi, \\text{naive}}^2 = \\frac{1-|\\hat{\\gamma}|^2}{2L|\\hat{\\gamma}|^2}\n$$\n问题指出样本相干性估计量的期望是 $\\mathbb{E}\\{|\\hat{\\gamma}|^2\\} = \\frac{1}{L} + \\rho^2(1 - \\frac{1}{L})$。$|\\hat{\\gamma}|^2$ 作为 $\\rho^2$ 的估计量的偏差是：\n$$\n\\text{Bias}(|\\hat{\\gamma}|^2) = \\mathbb{E}\\{|\\hat{\\gamma}|^2\\} - \\rho^2 = \\left( \\frac{1}{L} + \\rho^2 - \\frac{\\rho^2}{L} \\right) - \\rho^2 = \\frac{1-\\rho^2}{L}\n$$\n因为 $\\rho \\in [0,1]$ 且 $L \\geq 2$，所以偏差是非负的。这意味着 $|\\hat{\\gamma}|^2$ 是 $\\rho^2$ 的一个正偏估计量，也就是说，它平均而言会高估真实的相干性幅度平方。\n\n对于 $\\rho^2 > 0$，相位方差 $\\sigma_{\\phi}^2 = \\frac{1}{2L}(\\frac{1}{\\rho^2} - 1)$ 是 $\\rho^2$ 的一个单调递减函数。由于朴素估计量 $\\hat{\\sigma}_{\\phi, \\text{naive}}^2$ 使用的输入 $|\\hat{\\gamma}|^2$ 平均而言会高估 $\\rho^2$，因此得到的相位方差估计值平均而言会低估真实的相位方差。因此，$|\\hat{\\gamma}|^2$ 中的偏差传播为 $\\hat{\\sigma}_{\\phi, \\text{naive}}^2$ 中的负偏差。\n\n**第三部分：偏差校正的相位方差估计量**\n\n为了校正这种偏差，我们首先通过反演 $\\rho^2$ 和 $\\mathbb{E}\\{|\\hat{\\gamma}|^2\\}$ 之间的关系，构造一个 $\\rho^2$ 的无偏估计量，记为 $\\hat{\\rho}_{\\mathrm{ub}}^2$。\n$$\n\\mathbb{E}\\{|\\hat{\\gamma}|^2\\} = \\frac{1}{L} + \\rho^2\\left(\\frac{L-1}{L}\\right)\n$$\n求解 $\\rho^2$：\n$$\n\\rho^2 = \\left(\\mathbb{E}\\{|\\hat{\\gamma}|^2\\} - \\frac{1}{L}\\right) \\frac{L}{L-1} = \\frac{L}{L-1}\\mathbb{E}\\{|\\hat{\\gamma}|^2\\} - \\frac{1}{L-1}\n$$\n根据矩方法，我们将期望 $\\mathbb{E}\\{|\\hat{\\gamma}|^2\\}$ 替换为样本量 $|\\hat{\\gamma}|^2$，以获得 $\\rho^2$ 的无偏估计量：\n$$\n\\hat{\\rho}_{\\mathrm{ub}}^2 = \\frac{L}{L-1}|\\hat{\\gamma}|^2 - \\frac{1}{L-1} = \\frac{L|\\hat{\\gamma}|^2 - 1}{L-1}\n$$\n根据构造，该估计量是无偏的：$\\mathbb{E}\\{\\hat{\\rho}_{\\mathrm{ub}}^2\\} = \\rho^2$。\n\n现在，我们通过将 $\\hat{\\rho}_{\\mathrm{ub}}^2$ 代入 $\\sigma_{\\phi}^2$ 的表达式来定义偏差校正的相位方差估计量 $\\hat{\\sigma}_{\\phi,\\mathrm{bc}}^{2}$：\n$$\n\\hat{\\sigma}_{\\phi,\\mathrm{bc}}^{2} = \\frac{1 - \\hat{\\rho}_{\\mathrm{ub}}^2}{2L\\hat{\\rho}_{\\mathrm{ub}}^2}\n$$\n我们代入 $\\hat{\\rho}_{\\mathrm{ub}}^2$ 的表达式：\n分子是：\n$$\n1 - \\hat{\\rho}_{\\mathrm{ub}}^2 = 1 - \\frac{L|\\hat{\\gamma}|^2 - 1}{L-1} = \\frac{(L-1) - (L|\\hat{\\gamma}|^2 - 1)}{L-1} = \\frac{L - L|\\hat{\\gamma}|^2}{L-1} = \\frac{L(1 - |\\hat{\\gamma}|^2)}{L-1}\n$$\n分母是 $2L$ 乘以 $\\hat{\\rho}_{\\mathrm{ub}}^2$：\n$$\n2L\\hat{\\rho}_{\\mathrm{ub}}^2 = 2L \\left( \\frac{L|\\hat{\\gamma}|^2 - 1}{L-1} \\right)\n$$\n构造 $\\hat{\\sigma}_{\\phi,\\mathrm{bc}}^{2}$ 的分数形式：\n$$\n\\hat{\\sigma}_{\\phi,\\mathrm{bc}}^{2} = \\frac{\\frac{L(1 - |\\hat{\\gamma}|^2)}{L-1}}{2L \\frac{L|\\hat{\\gamma}|^2 - 1}{L-1}} = \\frac{L(1 - |\\hat{\\gamma}|^2)}{2L(L|\\hat{\\gamma}|^2 - 1)}\n$$\n消去公因子 $L$ 得到偏差校正相位方差估计量的最终表达式：\n$$\n\\hat{\\sigma}_{\\phi,\\mathrm{bc}}^{2} = \\frac{1 - |\\hat{\\gamma}|^2}{2(L|\\hat{\\gamma}|^2 - 1)}\n$$\n该表达式提供了一个以弧度平方（$\\mathrm{rad}^2$）为单位的相位方差估计，它校正了样本相干性中的固有偏差。",
            "answer": "$$\n\\boxed{\\frac{1 - |\\hat{\\gamma}|^2}{2(L|\\hat{\\gamma}|^2 - 1)}}\n$$"
        },
        {
            "introduction": "相位解缠是InSAR数据处理流程中最具挑战性的核心环节，其目标是从包裹在$(-\\pi, \\pi]$区间内的相位值中恢复出连续的真实相位。由于噪声和相干性损失，这一过程本质上是一个不适定问题。本练习旨在引导你构建一个基于可靠性加权的最小范数解缠方案，通过将相干性作为权重，在最小二乘框架下求解最可能的连续相位场，从而在低相干区域允许相位跳变，在高相干区域保持平滑。",
            "id": "3857758",
            "problem": "考虑一个代表合成孔径雷达干涉测量（InSAR）干涉图的矩形像素网格。在每个像素位置，都提供了一个测量的缠绕干涉相位（表示为 $\\phi_{\\mathrm{w}}$）和一个空间相干性值（表示为 $\\gamma$），后者量化了相位测量的可靠性。缠绕相位 $\\phi_{\\mathrm{w}}$ 被理解为真实相位 $\\phi$ 对 $2\\pi$ 取模的结果，单位为弧度。角度必须以弧度处理。\n\n从基本定义出发，构建一个可靠性加权的相位解缠方案，该方案通过为不可靠的边分配较低的权重来惩罚在低相干性区域的积分。在网格的最近邻边上建立最小范数目标函数，不要引入任何启发式捷径。推导由此加权目标产生的未知解缠相位场所对应的线性系统，仔细展示权重如何进入法方程并影响解的结构。通过将单个选定像素处的解缠相位约束到指定值，使用一个固定的参考像素来解决全局相位模糊性问题。\n\n你的程序必须在提供的测试套件上实现所推导的可靠性加权最小范数相位解缠，并遵循以下规则：\n- 在网格上仅使用水平和垂直的最近邻边。\n- 两个相邻像素之间的边权重是其相干性值的函数，并且当任一像素的相干性降低时，该权重必须减小。将相干性视为无单位量。\n- 跨越边的缠绕相位差在使用前必须映射到其在区间 $(-\\pi,\\pi]$ 内的主值。\n- 在所有测试用例中，通过将左上角像素的解缠相位固定为 $0$ 弧度来强制执行单个参考约束。\n- 所有解缠相位均以弧度表示，并将每个结果四舍五入到六位小数。\n\n测试套件：\n- 案例 1（$3\\times 3$ 网格）。缠绕相位和相干性矩阵：\n  - $\\phi_{\\mathrm{w}}^{(1)} = \\begin{bmatrix}\n  0.0  0.6  1.2 \\\\\n  0.5  1.1  1.7 \\\\\n  1.0  1.6  2.2\n  \\end{bmatrix}$ （弧度），\n  - $\\gamma^{(1)} = \\begin{bmatrix}\n  0.95  0.90  0.90 \\\\\n  0.90  0.85  0.90 \\\\\n  0.90  0.90  0.95\n  \\end{bmatrix}$。\n- 案例 2（$3\\times 3$ 网格），具有强缠绕和低相干性中心。缠绕相位和相干性矩阵：\n  - $\\phi_{\\mathrm{w}}^{(2)} = \\begin{bmatrix}\n  0.0  1.8  -2.683185307 \\\\\n  1.4  -3.083185307  -1.283185307 \\\\\n  2.8  -1.683185307  0.116814693\n  \\end{bmatrix}$ （弧度），\n  - $\\gamma^{(2)} = \\begin{bmatrix}\n  0.90  0.80  0.70 \\\\\n  0.80  0.20  0.70 \\\\\n  0.90  0.70  0.60\n  \\end{bmatrix}$。\n- 案例 3（$2\\times 2$ 网格），具有一个极低相干性的像素。缠绕相位和相干性矩阵：\n  - $\\phi_{\\mathrm{w}}^{(3)} = \\begin{bmatrix}\n  0.0  -2.883185307 \\\\\n  -3.083185307  0.316814693\n  \\end{bmatrix}$ （弧度），\n  - $\\gamma^{(3)} = \\begin{bmatrix}\n  0.90  0.001 \\\\\n  0.80  0.70\n  \\end{bmatrix}$。\n\n程序要求：\n- 按照推导实现可靠性加权的最小范数解缠，仅使用网格上的最近邻边，边的权重由两个端点像素的相干性构建，以惩罚低相干性。\n- 将左上角像素的解缠相位固定为 $0$ 弧度作为参考。\n- 生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个浮点数列表，表示按行主序排列的解缠相位场，四舍五入到六位小数，并以弧度表示。例如，输出应如下所示：$\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$。\n\n你的推导和实现必须在纯数学意义上普遍适用，仅使用上述规则。测试用例的最终答案必须是数值型的，并且结构必须完全符合规定。",
            "solution": "### 第 1 部分：加权最小范数相位解缠算法的推导\n\n目标是从测量的缠繞相位 $\\phi_{\\mathrm{w}}$ 重建真实的、连续的相位场 $\\phi$，其中每个像素 $i$ 处的关系为 $\\phi_{\\mathrm{w},i} = \\phi_i \\pmod{2\\pi}$。问题要求采用一种可靠性加权的最小范数方法。\n\n**1. 目标函数**\n\n相位解缠的基本假设是，真实的相位场 $\\phi$ 是“平滑”的。这意味着局部的相位差（即梯度）很小。我们可以从缠绕相位值中估计两个相邻像素 $i$ 和 $j$ 之间的局部相位梯度。缠绕相位差为 $\\Delta\\phi_{\\mathrm{w},ij} = \\phi_{\\mathrm{w},i} - \\phi_{\\mathrm{w},j}$。然而，这个差值可能超出 $(-\\pi, \\pi]$ 区间。为了获得最小可能的相位差，我们必须将其映射到其主值。设 $W(\\cdot)$ 是将角度映射到区间 $(-\\pi, \\pi]$ 的缠绕算子。那么，测量的相位梯度为 $g_{ij} = W(\\phi_{\\mathrm{w},i} - \\phi_{\\mathrm{w},j})$。\n\n解缠问题旨在寻找未知的解缠相位场 $\\phi$，使其梯度 $\\phi_i - \\phi_j$ 在最小二乘意义上与测量的梯度 $g_{ij}$ 最佳匹配。问题规定，这种匹配应通过相干性 $\\gamma$ 进行加权，$\\gamma$ 用于衡量每个像素处相位测量的可靠性。连接两个低相干性像素的边不太可靠，其对总误差的贡献应该被降低权重。\n\n设网格上所有最近邻边的集合为 $\\mathcal{E}$。问题在于找到相位场 $\\mathbf{\\phi} = \\{\\phi_k\\}$，以最小化以下加权误差平方和（目标函数 $L$）：\n$$ L(\\mathbf{\\phi}) = \\sum_{(i,j) \\in \\mathcal{E}} w_{ij}^2 \\left( ( \\phi_i - \\phi_j ) - g_{ij} \\right)^2 $$\n这里，$(\\phi_i - \\phi_j)$ 是未知解缠场的梯度，而 $g_{ij} = W(\\phi_{\\mathrm{w},i} - \\phi_{\\mathrm{w},j})$ 是测量的梯度。项 $w_{ij}^2$ 是与边 $(i, j)$ 相关联的权重。问题指出，当任一端点像素的相干性降低时，权重必须减小。满足此条件的一个标准且合适的选择是，将权重平方定义为所连接像素相干性的乘积：\n$$ w_{ij}^2 = \\gamma_i \\gamma_j $$\n这种加权方案确保了跨越低相干性区域的边对总成本的贡献较小，从而允许在这些不可靠区域出现更大的相位不连续（相位跳变）。\n\n**2. 最小化与法方程**\n\n为了找到使 $L(\\mathbf{\\phi})$ 最小化的相位场 $\\mathbf{\\phi}$，我们必须对每个未知相位 $\\phi_k$ 求 $L$ 的偏导数，并将其设为零。\n$$ \\frac{\\partial L}{\\partial \\phi_k} = 0 \\quad \\forall k $$\n设 $\\mathcal{N}(k)$ 表示像素 $k$ 的最近邻集合。关于 $\\phi_k$ 的导数只受和式中包含 $\\phi_k$ 的项的影响。这些项对应于连接像素 $k$ 与其邻居 $j \\in \\mathcal{N}(k)$ 的边。\n$$ \\frac{\\partial L}{\\partial \\phi_k} = \\frac{\\partial}{\\partial \\phi_k} \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 \\left( (\\phi_k - \\phi_j) - g_{kj} \\right)^2 = 0 $$\n应用链式法则：\n$$ \\sum_{j \\in \\mathcal{N}(k)} 2 w_{kj}^2 \\left( (\\phi_k - \\phi_j) - g_{kj} \\right) \\cdot (1) = 0 $$\n我们可以除以 $2$ 并重新整理各项，以分离出未知数 $\\phi$：\n$$ \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 (\\phi_k - \\phi_j) = \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 g_{kj} $$\n$$ \\phi_k \\left( \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 \\right) - \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 \\phi_j = \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 g_{kj} $$\n这就构成了一个线性方程组，网格中的每个像素 $k$ 都对应一个方程。\n\n**3. 线性系统 $A\\mathbf{\\phi} = \\mathbf{b}$**\n\n让我们用一个长度为 $N = M \\times P$ 的向量 $\\mathbf{\\phi}$ 来表示 $M \\times P$ 的像素网格，使用行主序索引。这组方程可以写成矩阵形式 $A\\mathbf{\\phi} = \\mathbf{b}$，其中：\n- $\\mathbf{\\phi}$ 是未知解缠相位的 $N \\times 1$ 向量。\n- $A$ 是一个 $N \\times N$ 矩阵，表示一个加权的离散拉普拉斯算子。其元素为：\n  - 对角元素：$A_{kk} = \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2$\n  - 非对角元素：如果 $j$ 是 $k$ 的邻居，则 $A_{kj} = -w_{kj}^2$，否则 $A_{kj} = 0$。\n- $\\mathbf{b}$ 是一个 $N \\times 1$ 向量，其中每个元素 $b_k$ 是像素 $k$ 处测量相位梯度场的加权散度：\n  - $b_k = \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 g_{kj} = \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 W(\\phi_{\\mathrm{w},k} - \\phi_{\\mathrm{w},j})$\n\n**4. 处理秩亏（相位模糊性）**\n\n这样构造的矩阵 $A$ 是奇异的。每一行的和都为零，因为 $\\sum_{j} A_{kj} = A_{kk} + \\sum_{j \\in \\mathcal{N}(k)} A_{kj} = (\\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2) - \\sum_{j \\in \\mathcal{N}(k)} w_{kj}^2 = 0$。这意味着一个常数向量 $\\mathbf{c} = c \\cdot \\mathbf{1}$ 位于 $A$ 的零空间中，因为 $A\\mathbf{c} = \\mathbf{0}$。在物理上，这意味着如果 $\\mathbf{\\phi}$ 是一个解，那么对于任何常数 $c$，$\\mathbf{\\phi} + c\\mathbf{1}$ 也是一个解。这就是众所周知的全局相位模糊性。\n\n为了获得唯一解，我们必须施加一个约束。问题指定将左上角像素（索引为 $k=0$）的解缠相位固定为一个已知值：$\\phi_0 = 0$。这个约束消除了模糊性。\n\n要实现这个约束，我们可以修改线性系统。关于 $\\phi_0$ 的方程被约束方程 $\\phi_0 = 0$ 所取代。对于所有其他方程（$k>0$），任何涉及 $\\phi_0$ 的项都移到右侧。对于一个与像素 0 相邻的像素 $k$，其方程为：\n$A_{kk}\\phi_k + \\sum_{j \\in \\mathcal{N}(k), j \\neq 0} A_{kj}\\phi_j + A_{k0}\\phi_0 = b_k$\n由于 $\\phi_0=0$，这简化为：\n$A_{kk}\\phi_k + \\sum_{j \\in \\mathcal{N}(k), j \\neq 0} A_{kj}\\phi_j = b_k$。\n\n这等价于为余下的 $N-1$ 个未知相位求解一个简化的线性系统。设 $\\mathbf{\\phi}'$ 是从 $\\phi_1$ 到 $\\phi_{N-1}$ 的未知数向量。设 $A'$ 是从 $A$ 中移除第一行和第一列得到的子矩阵。设 $\\mathbf{b}'$ 是从 $b_1$ 到 $b_{N-1}$ 的 $\\mathbf{b}$ 的子向量。待求解的系统是：\n$$ A' \\mathbf{\\phi}' = \\mathbf{b}' $$\n现在矩阵 $A'$ 是非奇异且可逆的，从而为 $\\mathbf{\\phi}'$ 产生唯一解。然后通过在前面加上参考值来构造完整解：$\\mathbf{\\phi} = [0, \\phi'_0, \\phi'_1, \\dots]^T$。\n\n**5. 实现细节**\n- 将 $x$ 映射到 $(-\\pi, \\pi]$ 的主值算子 $W(x)$ 将使用复数来实现以确保稳健性：$W(x) = \\mathrm{angle}(e^{ix})$。\n- 线性系统 $A'\\mathbf{\\phi}' = \\mathbf{b}'$ 使用标准的线性代数库函数来求解。\n- 所推导的方法是通用的，并且不依赖于任何启发式方法，符合要求。\n\n至此，算法的推导完成。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the phase unwrapping for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"phi_w\": np.array([\n                [0.0, 0.6, 1.2],\n                [0.5, 1.1, 1.7],\n                [1.0, 1.6, 2.2]\n            ]),\n            \"gamma\": np.array([\n                [0.95, 0.90, 0.90],\n                [0.90, 0.85, 0.90],\n                [0.90, 0.90, 0.95]\n            ])\n        },\n        {\n            \"phi_w\": np.array([\n                [0.0, 1.8, -2.683185307],\n                [1.4, -3.083185307, -1.283185307],\n                [2.8, -1.683185307, 0.116814693]\n            ]),\n            \"gamma\": np.array([\n                [0.90, 0.80, 0.70],\n                [0.80, 0.20, 0.70],\n                [0.90, 0.70, 0.60]\n            ])\n        },\n        {\n            \"phi_w\": np.array([\n                [0.0, -2.883185307],\n                [-3.083185307, 0.316814693]\n            ]),\n            \"gamma\": np.array([\n                [0.90, 0.001],\n                [0.80, 0.70]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        phi_unwrapped = perform_phase_unwrapping(case[\"phi_w\"], case[\"gamma\"])\n        \n        # Round to six decimal places and convert to list of floats for output format\n        rounded_result = np.round(phi_unwrapped, 6).tolist()\n        results.append(rounded_result)\n\n    print(results)\n\n\ndef perform_phase_unwrapping(phi_w, gamma):\n    \"\"\"\n    Implements the reliability-weighted minimum-norm phase unwrapping.\n\n    Args:\n        phi_w (np.ndarray): 2D array of wrapped phase values in radians.\n        gamma (np.ndarray): 2D array of coherence values.\n\n    Returns:\n        np.ndarray: 1D array of the unwrapped phase field in row-major order.\n    \"\"\"\n    rows, cols = phi_w.shape\n    n_pixels = rows * cols\n    \n    # Flatten input arrays to 1D using row-major order\n    phi_w_flat = phi_w.flatten()\n    gamma_flat = gamma.flatten()\n\n    # Initialize the matrix A and vector b of the linear system A*phi = b\n    A = np.zeros((n_pixels, n_pixels))\n    b = np.zeros(n_pixels)\n    \n    def wrap_to_pi(x):\n        \"\"\"Wraps angle x to the interval (-pi, pi] using complex numbers.\"\"\"\n        return np.angle(np.exp(1j * x))\n\n    # Construct the A matrix and b vector\n    for k in range(n_pixels):\n        r, c = divmod(k, cols)\n        \n        # Define neighbors (up, down, left, right)\n        neighbors = []\n        if r > 0: neighbors.append(k - cols)  # Up\n        if r  rows - 1: neighbors.append(k + cols)  # Down\n        if c > 0: neighbors.append(k - 1)  # Left\n        if c  cols - 1: neighbors.append(k + 1)  # Right\n\n        for j in neighbors:\n            # Calculate the squared weight for the edge (k, j)\n            w_sq = gamma_flat[k] * gamma_flat[j]\n            \n            # Add to the diagonal element of A\n            A[k, k] += w_sq\n            \n            # Set the off-diagonal element of A\n            A[k, j] = -w_sq\n\n            # Calculate the measured phase gradient\n            g_kj = wrap_to_pi(phi_w_flat[k] - phi_w_flat[j])\n            \n            # Add to the b vector\n            b[k] += w_sq * g_kj\n            \n    # Apply the constraint: phi[0] = 0.\n    # We solve a reduced system for the remaining N-1 variables.\n    # System: A' * phi' = b'\n    \n    # Submatrix A' by removing the first row and column\n    A_prime = A[1:, 1:]\n    \n    # Subvector b' by removing the first element.\n    b_prime = b[1:]\n    \n    # Solve the reduced linear system\n    try:\n        phi_prime = linalg.solve(A_prime, b_prime)\n    except linalg.LinAlgError:\n        # If the matrix is singular/ill-conditioned, use least-squares solver\n        # This can happen if parts of the grid are disconnected by zero-coherence pixels\n        phi_prime, _, _, _ = linalg.lstsq(A_prime, b_prime)\n\n\n    # Combine the reference phase and the solved phases\n    phi_unwrapped = np.concatenate(([0.0], phi_prime))\n    \n    return phi_unwrapped\n\nsolve()\n```"
        }
    ]
}