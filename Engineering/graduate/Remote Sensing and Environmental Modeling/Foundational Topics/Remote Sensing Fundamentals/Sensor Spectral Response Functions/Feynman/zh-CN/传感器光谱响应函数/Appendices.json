{
    "hands_on_practices": [
        {
            "introduction": "传感器光谱响应函数 (SRF) 最基本的作用是对真实的光谱进行卷积平滑。这项练习将引导你通过计算来模拟这一过程，观察传感器有限的光谱分辨率如何使尖锐的光谱特征变宽和混合。通过这项实践，你将对“表观光谱”与“真实光谱”之间的差异建立起直观的理解。",
            "id": "3845856",
            "problem": "考虑一个以纳米为单位的一维波长域 $\\lambda$，以及一个由窄高斯线叠加而成的高分辨率线状光谱。设真实的光谱辐射率表示为 $L(\\lambda)$，单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。假设传感器的特性由一个传感器光谱响应函数 (SRF) $R(\\lambda)$ 描述，该函数被归一化为单位面积。传感器测得的表观光谱是以下卷积：\n$$\n\\tilde{L}(\\lambda) = \\int_{-\\infty}^{\\infty} L(\\lambda')\\,R(\\lambda - \\lambda')\\,\\mathrm{d}\\lambda' .\n$$\n假设高分辨率光谱中的每条谱线 $i$ 都是一个高斯函数，其中心波长为 $\\lambda_i$，标准差为 $\\sigma_i$（远窄于 SRF），积分线强度为 $S_i$，单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$。即：\n$$\nL(\\lambda) = \\sum_{i} S_i\\,\\phi(\\lambda;\\lambda_i,\\sigma_i),\n$$\n其中\n$$\n\\phi(\\lambda;\\lambda_i,\\sigma_i) = \\frac{1}{\\sigma_i\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_i)^2}{2\\sigma_i^2}\\right)\n$$\n是一个单位面积的高斯函数。设 SRF 为高斯函数，\n$$\nR(\\lambda) = \\frac{1}{\\sigma_{\\mathrm{srf}}\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{\\lambda^2}{2\\sigma_{\\mathrm{srf}}^2}\\right),\n$$\n其标准差为 $\\sigma_{\\mathrm{srf}}$（单位为 nm），且单位面积 $\\int R(\\lambda)\\,\\mathrm{d}\\lambda = 1$。\n\n您的任务是：\n- 对每个测试用例，在指定的离散波长网格上计算表观光谱 $\\tilde{L}(\\lambda)$。\n- 计算峰值振幅 $A = \\max_{\\lambda}\\tilde{L}(\\lambda)$，单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n- 使用数值积分在指定域上计算总面积 $\\mathcal{A} = \\int \\tilde{L}(\\lambda)\\,\\mathrm{d}\\lambda$，单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$。\n- 通过比率 $\\rho = A / \\max_{\\lambda} L(\\lambda)$ 来量化对峰值振幅的影响，该比率为无量纲。此处的 $\\max_{\\lambda} L(\\lambda)$ 与表观光谱在相同的离散网格上计算。\n\n所有振幅 $A$ 的答案必须以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 表示，面积 $\\mathcal{A}$ 以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$ 表示，比率 $\\rho$ 以小数表示。不涉及角度量。在提供的有限域上使用梯形法则进行数值积分。\n\n测试套件：\n对于以下每种情况，计算 $\\tilde{L}(\\lambda)$、$A$、$\\mathcal{A}$ 和 $\\rho$。\n\n- 情况 $1$（单谱线，类高光谱 SRF）：\n  - 域：$\\lambda \\in [500, 600]\\,\\mathrm{nm}$，均匀网格步长 $\\Delta\\lambda = 0.01\\,\\mathrm{nm}$。\n  - 谱线：一条谱线位于 $\\lambda_1 = 550\\,\\mathrm{nm}$，$S_1 = 1.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$，$\\sigma_1 = 0.02\\,\\mathrm{nm}$。\n  - SRF：高斯函数，$\\sigma_{\\mathrm{srf}} = 2.0\\,\\mathrm{nm}$。\n\n- 情况 $2$（两条谱线，被 SRF 部分混合）：\n  - 域：$\\lambda \\in [640, 660]\\,\\mathrm{nm}$，均匀网格步长 $\\Delta\\lambda = 0.01\\,\\mathrm{nm}$。\n  - 谱线：两条谱线，一条位于 $\\lambda_1 = 649\\,\\mathrm{nm}$，$S_1 = 0.6\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$，$\\sigma_1 = 0.05\\,\\mathrm{nm}$；另一条位于 $\\lambda_2 = 651\\,\\mathrm{nm}$，$S_2 = 0.4\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$，$\\sigma_2 = 0.05\\,\\mathrm{nm}$。\n  - SRF：高斯函数，$\\sigma_{\\mathrm{srf}} = 1.0\\,\\mathrm{nm}$。\n\n- 情况 $3$（宽 SRF 下的边界截断）：\n  - 域：$\\lambda \\in [380, 420]\\,\\mathrm{nm}$，均匀网格步长 $\\Delta\\lambda = 0.02\\,\\mathrm{nm}$。\n  - 谱线：一条谱线位于 $\\lambda_1 = 400\\,\\mathrm{nm}$，$S_1 = 1.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$，$\\sigma_1 = 0.02\\,\\mathrm{nm}$。\n  - SRF：高斯函数，$\\sigma_{\\mathrm{srf}} = 10.0\\,\\mathrm{nm}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是包含三个值 $[A,\\mathcal{A},\\rho]$ 的列表，并按此顺序排列。例如，三个测试用例的总体输出必须如下所示：\n$$\n[[A_1,\\mathcal{A}_1,\\rho_1],[A_2,\\mathcal{A}_2,\\rho_2],[A_3,\\mathcal{A}_3,\\rho_3]] .\n$$\n所有值都应为数值浮点数。不应打印任何额外文本。",
            "solution": "该问题已经过验证，在科学和数学上是合理、适定且内部一致的。\n\n此问题的核心是确定传感器的光谱响应函数 (SRF) 对测量的高分辨率线状光谱的影响。表观光谱 $\\tilde{L}(\\lambda)$ 是真实光谱辐射率 $L(\\lambda)$ 与传感器 SRF $R(\\lambda)$ 的卷积：\n$$\n\\tilde{L}(\\lambda) = (L * R)(\\lambda) = \\int_{-\\infty}^{\\infty} L(\\lambda')\\,R(\\lambda - \\lambda')\\,\\mathrm{d}\\lambda'\n$$\n\n在网格上的每个点 $\\lambda$ 直接对该卷积积分进行数值计算是可行的，但计算量大，且可能引入数值误差。利用所涉及函数的数学特性可以得到一个更优雅、更高效的解决方案。\n\n真实光谱 $L(\\lambda)$ 是一系列高斯线的总和：\n$$\nL(\\lambda) = \\sum_{i} S_i\\,\\phi(\\lambda;\\lambda_i,\\sigma_i)\n$$\n其中 $\\phi(\\lambda;\\mu,\\sigma)$ 是一个单位面积的高斯概率密度函数 (PDF)，其均值为 $\\mu$，标准差为 $\\sigma$：\n$$\n\\phi(\\lambda;\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\lambda - \\mu)^2}{2\\sigma^2}\\right)\n$$\nSRF, $R(\\lambda)$，也被建模为一个以零为中心、标准差为 $\\sigma_{\\mathrm{srf}}$ 的高斯函数：\n$$\nR(\\lambda) = \\phi(\\lambda; 0, \\sigma_{\\mathrm{srf}})\n$$\n\n概率论和信号处理中的一个基本定理指出，两个高斯函数的卷积是另一个高斯函数。具体来说，如果 $f_1(x) \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2)$ 且 $f_2(x) \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2)$，它们的卷积 $(f_1 * f_2)(x)$ 是一个均值为 $\\mu_1 + \\mu_2$、方差为 $\\sigma_1^2 + \\sigma_2^2$ 的高斯函数。\n\n我们可以应用这个定理。卷积是线性运算，因此我们可以将 $L(\\lambda)$ 中的每个高斯线分别与 SRF 进行卷积，然后将结果相加：\n$$\n\\tilde{L}(\\lambda) = \\left(\\sum_{i} S_i\\,\\phi(\\cdot;\\lambda_i,\\sigma_i)\\right) * \\phi(\\cdot; 0, \\sigma_{\\mathrm{srf}}) = \\sum_{i} S_i \\left( \\phi(\\cdot;\\lambda_i,\\sigma_i) * \\phi(\\cdot; 0, \\sigma_{\\mathrm{srf}}) \\right)\n$$\n对于每条线 $i$，我们将一个中心在 $\\lambda_i$、标准差为 $\\sigma_i$ 的高斯函数与一个中心在 $0$、标准差为 $\\sigma_{\\mathrm{srf}}$ 的高斯函数进行卷积。结果函数是一个中心在 $\\lambda_i + 0 = \\lambda_i$、方差为 $\\sigma_i^2 + \\sigma_{\\mathrm{srf}}^2$ 的高斯函数。新的有效标准差为 $\\sigma_{\\mathrm{eff},i} = \\sqrt{\\sigma_i^2 + \\sigma_{\\mathrm{srf}}^2}$。\n\n因此，表观光谱 $\\tilde{L}(\\lambda)$ 有一个简单的解析形式：\n$$\n\\tilde{L}(\\lambda) = \\sum_{i} S_i\\,\\phi(\\lambda; \\lambda_i, \\sigma_{\\mathrm{eff},i}) = \\sum_{i} S_i\\,\\phi(\\lambda; \\lambda_i, \\sqrt{\\sigma_i^2 + \\sigma_{\\mathrm{srf}}^2})\n$$\n这个 $\\tilde{L}(\\lambda)$ 的解析表达式使其能够在指定的波长网格上直接、准确地计算，完全无需进行数值卷积。\n\n每个测试用例的计算过程如下：\n$1$. 为指定域 $[\\lambda_{\\min}, \\lambda_{\\max}]$ 生成步长为 $\\Delta\\lambda$ 的离散波长网格 $\\lambda_k$。\n$2$. 使用其高斯线之和的定义，在此网格上计算真实光谱 $L(\\lambda_k)$。\n$3$. 使用推导出的解析形式，在同一网格上计算表观光谱 $\\tilde{L}(\\lambda_k)$，其中每条谱线使用其有效标准差 $\\sigma_{\\mathrm{eff},i}$。\n$4$. 通过取网格上 $\\tilde{L}(\\lambda_k)$ 的最大值来找到表观光谱的峰值振幅 $A$：$A = \\max_k \\{ \\tilde{L}(\\lambda_k) \\}$。\n$5$. 使用梯形法则对离散点 $(\\lambda_k, \\tilde{L}(\\lambda_k))$ 进行计算，得出给定域上表观光谱下的总积分面积 $\\mathcal{A}$：\n$$\n\\mathcal{A} = \\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} \\tilde{L}(\\lambda)\\,\\mathrm{d}\\lambda \\approx \\sum_k \\frac{\\tilde{L}(\\lambda_k) + \\tilde{L}(\\lambda_{k+1})}{2} \\Delta\\lambda\n$$\n$6$. 通过取网格上 $L(\\lambda_k)$ 的最大值来找到真实光谱的峰值振幅 $\\max_{\\lambda} L(\\lambda)$。\n$7$. 计算无量纲比率 $\\rho = A / \\max_k \\{ L(\\lambda_k) \\}$。\n\n此过程应用于三个测试用例中的每一个，这些用例旨在说明不同的物理效应：\n- **情况 $1$**：一条非常窄的谱线被一个中等高分辨率的 SRF（$\\sigma_{\\mathrm{srf}} = 2.0\\,\\mathrm{nm}$）展宽（平滑）。峰值振幅预计会显著下降，而由于积分域很宽，面积将保持守恒。\n- **情况 $2$**：两条不同的谱线被一个其宽度（$\\sigma_{\\mathrm{srf}} = 1.0\\,\\mathrm{nm}$）与谱线间距（$2.0\\,\\mathrm{nm}$）相当的 SRF 观测。这说明了光谱特征的混合，其中两个峰在表观光谱中合并成一个更宽的单一特征。\n- **情况 $3$**：一条谱线被一个非常宽的低分辨率 SRF（$\\sigma_{\\mathrm{srf}} = 10.0\\,\\mathrm{nm}$）观测。与卷积后信号的宽度相比，积分域相对较窄，导致显著的截断效应。计算出的面积 $\\mathcal{A}$ 将明显小于总线强度 $S_1$，因为光谱展宽后的一部分谱线落在了积分域之外。\n\n最终值被整理成一个列表的列表 $[[A_1, \\mathcal{A}_1, \\rho_1], [A_2, \\mathcal{A}_2, \\rho_2], [A_3, \\mathcal{A}_3, \\rho_3]]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf # Used for internal verification, not required for the final calculation method.\n\ndef solve():\n    \"\"\"\n    Solves the sensor spectral response problem for three test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"domain\": (500, 600), \"d_lambda\": 0.01,\n            \"lines\": [{\"S\": 1.0, \"lambda_i\": 550, \"sigma_i\": 0.02}],\n            \"srf\": {\"sigma_srf\": 2.0}\n        },\n        {\n            \"name\": \"Case 2\",\n            \"domain\": (640, 660), \"d_lambda\": 0.01,\n            \"lines\": [\n                {\"S\": 0.6, \"lambda_i\": 649, \"sigma_i\": 0.05},\n                {\"S\": 0.4, \"lambda_i\": 651, \"sigma_i\": 0.05}\n            ],\n            \"srf\": {\"sigma_srf\": 1.0}\n        },\n        {\n            \"name\": \"Case 3\",\n            \"domain\": (380, 420), \"d_lambda\": 0.02,\n            \"lines\": [{\"S\": 1.0, \"lambda_i\": 400, \"sigma_i\": 0.02}],\n            \"srf\": {\"sigma_srf\": 10.0}\n        }\n    ]\n\n    results = []\n\n    def gaussian_pdf(x, mu, sigma):\n        \"\"\"\n        Computes a unit-area Gaussian function.\n        f(x) = (1/(sigma*sqrt(2*pi))) * exp(- (x-mu)^2 / (2*sigma^2) )\n        \"\"\"\n        if sigma == 0:\n            # Avoid division by zero, treat as a delta function\n            return np.where(x == mu, np.inf, 0)\n        norm = 1.0 / (sigma * np.sqrt(2 * np.pi))\n        exponent = -((x - mu)**2) / (2 * sigma**2)\n        return norm * np.exp(exponent)\n\n    for case in test_cases:\n        # 1. Generate the wavelength grid\n        lambda_min, lambda_max = case[\"domain\"]\n        d_lambda = case[\"d_lambda\"]\n        # Use np.linspace for robust grid generation\n        num_points = int(round((lambda_max - lambda_min) / d_lambda)) + 1\n        wavelengths = np.linspace(lambda_min, lambda_max, num_points)\n\n        # 2. Compute the true spectrum L(lambda)\n        L_lambda = np.zeros_like(wavelengths)\n        for line in case[\"lines\"]:\n            L_lambda += line[\"S\"] * gaussian_pdf(wavelengths, line[\"lambda_i\"], line[\"sigma_i\"])\n        \n        # 3. Compute the apparent spectrum L_tilde(lambda)\n        sigma_srf = case[\"srf\"][\"sigma_srf\"]\n        L_tilde_lambda = np.zeros_like(wavelengths)\n        for line in case[\"lines\"]:\n            sigma_eff = np.sqrt(line[\"sigma_i\"]**2 + sigma_srf**2)\n            L_tilde_lambda += line[\"S\"] * gaussian_pdf(wavelengths, line[\"lambda_i\"], sigma_eff)\n\n        # 4. Compute peak amplitude A\n        A = np.max(L_tilde_lambda)\n\n        # 5. Compute total area Script-A using the trapezoidal rule\n        script_A = np.trapz(L_tilde_lambda, wavelengths)\n\n        # 6. Compute peak of true spectrum and the ratio rho\n        max_L = np.max(L_lambda)\n        if max_L > 0:\n            rho = A / max_L\n        else: # Should not happen with given inputs, but good practice\n            rho = 0.0 \n        \n        results.append([A, script_A, rho])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    # e.g., [[A1,CalA1,rho1],[A2,CalA2,rho2],...]\n    str_results = []\n    for res in results:\n        # Format each inner list to prevent spaces around commas.\n        str_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了光谱响应函数 (SRF) 的基本效应之后，量化其特性变得至关重要。这项练习将对比两种常见的仪器线型函数，并指导你从第一性原理出发，推导并比较它们的分辨能力。通过这项实践，你将了解到仪器性能指标不仅取决于光谱响应的宽度（例如半峰全宽 $FWHM$），还取决于其具体的函数形状。",
            "id": "3845869",
            "problem": "星载遥感系统中的高光谱成像光谱仪可以设计不同的仪器线型函数（ILS）作为其光谱响应函数。考虑两种候选 ILS 模型，每种模型都在谱线中心 $\\lambda_{0}$ 处归一化至单位峰值，并以零光谱偏移 $x \\equiv \\lambda - \\lambda_{0}$ 为中心：\n- 高斯响应 $g(x) = \\exp\\!\\big(-x^{2}/(2\\sigma^{2})\\big)$，其标准差为 $\\sigma$。\n- 平方 sinc 响应 $s(x) = \\big(\\sin(x/b)/(x/b)\\big)^{2}$，其尺度参数为 $b$，其中正弦函数的参数以弧度为单位。\n\n假设两种 ILS 的实现方式使得它们具有相同的等效宽度（以波长单位计），对于单位峰值响应，其定义为 $W_{\\mathrm{eq}} = \\int_{-\\infty}^{\\infty} R(x)\\,dx$。光谱仪分辨率定义为 $R \\equiv \\lambda_{0}/\\Delta\\lambda_{\\mathrm{FWHM}}$，其中 $\\Delta\\lambda_{\\mathrm{FWHM}}$ 是 ILS 的半峰全宽（FWHM）。\n\n仅从等效宽度、FWHM 的基本定义以及高斯函数和平方 sinc 函数面积的经过验证的积分公式出发，且不使用任何预先制表的 FWHM 结果，推导每种 ILS 的 FWHM（用其形状参数表示），然后施加等效宽度相等的条件以消去形状参数，最后计算分辨率之比 $R_{\\mathrm{sinc}^{2}}/R_{\\mathrm{Gauss}}$。\n\n将最终答案表示为一个无量纲数，四舍五入到四位有效数字。最终答案中不包含任何单位，并对所有三角函数参数使用弧度。",
            "solution": "首先验证问题以确保其自洽、有科学依据且适定。\n\n### 第 1 步：提取已知条件\n- 高斯仪器线型函数 (ILS): $g(x) = \\exp(-x^2/(2\\sigma^2))$，其中 $x \\equiv \\lambda - \\lambda_{0}$，形状参数为 $\\sigma$。\n- 平方 sinc ILS: $s(x) = (\\sin(x/b)/(x/b))^2$，形状参数为 $b$。\n- 两种 ILS 都在 $x=0$ 处归一化至峰值 $1$。\n- 等效宽度定义: $W_{\\mathrm{eq}} = \\int_{-\\infty}^{\\infty} R(x)\\,dx$，其中 $R(x)$ 是 ILS 函数。\n- 两种 ILS 的等效宽度相等: $W_{\\mathrm{eq,Gauss}} = W_{\\mathrm{eq,sinc^2}}$。\n- 分辨率定义: $R \\equiv \\lambda_{0}/\\Delta\\lambda_{\\mathrm{FWHM}}$，其中 $\\Delta\\lambda_{\\mathrm{FWHM}}$ 是 ILS 的半峰全宽。\n- 任务是计算分辨率之比 $R_{\\mathrm{sinc}^{2}}/R_{\\mathrm{Gauss}}$。\n- 推导过程不得使用预先制表的 FWHM 结果，必须从基本定义和经过验证的面积积分公式出发。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题使用标准数学模型（高斯函数和平方 sinc 函数）来描述光谱学中的仪器线型，这是遥感和光学领域的核心概念。FWHM、等效宽度和分辨率的定义都是标准的，并具有明确的物理意义。该问题牢固地建立在已确立的物理学和数学原理之上。\n- **适定性**：该问题提供了推导所求比率所需的所有必要定义、函数和约束条件。存在唯一的、稳定的数值解。\n- **客观性**：该问题以精确的数学语言陈述，没有主观性或模糊性。\n- **结论**：该问题是有效的。这是一个应用光谱学和微积分基本原理的定义明确的练习。\n\n### 第 3 步：结论与行动\n该问题被判定为有效。将提供一个完整的、有理有据的解答。\n\n### 解题推导\n\n目标是求出比率 $R_{\\mathrm{sinc}^{2}}/R_{\\mathrm{Gauss}}$。根据分辨率的定义 $R = \\lambda_0 / \\Delta\\lambda_{\\mathrm{FWHM}}$，该比率可以表示为两种 ILS 函数的半峰全宽（FWHM）的形式：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\frac{\\lambda_0 / \\Delta\\lambda_{\\mathrm{FWHM, sinc^2}}}{\\lambda_0 / \\Delta\\lambda_{\\mathrm{FWHM, Gauss}}} = \\frac{\\Delta\\lambda_{\\mathrm{FWHM, Gauss}}}{\\Delta\\lambda_{\\mathrm{FWHM, sinc^2}}}\n$$\n因此，我们必须推导每种 ILS 的 FWHM，利用等效宽度相等的条件关联它们的形状参数，然后计算最终的比率。\n\n**1. 高斯 ILS $g(x)$ 的分析**\n\n首先，我们确定高斯响应 $g(x) = \\exp(-x^2/(2\\sigma^2))$ 的 FWHM。FWHM，记为 $\\Delta x_{\\mathrm{Gauss}}$，是函数在最大值一半处的宽度。由于最大值为 $1$，我们令 $g(x) = 1/2$：\n$$\n\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) = \\frac{1}{2}\n$$\n对两边取自然对数：\n$$\n-\\frac{x^2}{2\\sigma^2} = \\ln\\left(\\frac{1}{2}\\right) = -\\ln(2)\n$$\n解出 $x^2$：\n$$\nx^2 = 2\\sigma^2 \\ln(2)\n$$\n这给出了函数处于半峰高时的 $x$ 值：$x_{\\mathrm{h}} = \\pm \\sigma \\sqrt{2 \\ln(2)}$。FWHM 是这两点之间的距离：\n$$\n\\Delta\\lambda_{\\mathrm{FWHM, Gauss}} = \\Delta x_{\\mathrm{Gauss}} = (\\sigma \\sqrt{2\\ln(2)}) - (-\\sigma \\sqrt{2\\ln(2)}) = 2\\sigma\\sqrt{2\\ln(2)}\n$$\n接下来，我们使用给定的定义计算等效宽度 $W_{\\mathrm{eq, Gauss}}$：\n$$\nW_{\\mathrm{eq, Gauss}} = \\int_{-\\infty}^{\\infty} g(x)\\,dx = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\,dx\n$$\n这是一个标准的高斯积分，其形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^2)\\,dx = \\sqrt{\\pi/a}$。此处，$a = 1/(2\\sigma^2)$，所以积分的计算结果为：\n$$\nW_{\\mathrm{eq, Gauss}} = \\sqrt{\\frac{\\pi}{1/(2\\sigma^2)}} = \\sqrt{2\\pi\\sigma^2} = \\sigma\\sqrt{2\\pi}\n$$\n\n**2. 平方 Sinc ILS $s(x)$ 的分析**\n\n现在我们对平方 sinc 响应 $s(x) = (\\sin(x/b)/(x/b))^2$ 重复此过程。我们通过令 $s(x) = 1/2$ 来求其 FWHM，$\\Delta x_{\\mathrm{sinc^2}}$：\n$$\n\\left(\\frac{\\sin(x/b)}{x/b}\\right)^2 = \\frac{1}{2}\n$$\n我们定义一个无量纲变量 $u = x/b$。方程变为：\n$$\n\\left(\\frac{\\sin(u)}{u}\\right)^2 = \\frac{1}{2} \\implies \\frac{|\\sin(u)|}{|u|} = \\frac{1}{\\sqrt{2}}\n$$\n我们关心的是离开中心最大值点 $u=0$ 后的第一个交点。对于小的正数 $u$，$\\sin(u)$ 是正的，所以我们求解 $\\sin(u)/u = 1/\\sqrt{2}$，即 $\\sin(u) = u/\\sqrt{2}$。这是一个必须通过数值方法求解的超越方程。设正解为 $u_h$。使用数值方法（例如，牛顿-拉夫逊法）可得：\n$$\nu_h \\approx 1.391559\n$$\n半峰高点位于 $x_h = \\pm b u_h$。FWHM 是它们之间的距离：\n$$\n\\Delta\\lambda_{\\mathrm{FWHM, sinc^2}} = \\Delta x_{\\mathrm{sinc^2}} = (b u_h) - (-b u_h) = 2 b u_h\n$$\n接下来，我们计算等效宽度 $W_{\\mathrm{eq, sinc^2}}$：\n$$\nW_{\\mathrm{eq, sinc^2}} = \\int_{-\\infty}^{\\infty} s(x)\\,dx = \\int_{-\\infty}^{\\infty} \\left(\\frac{\\sin(x/b)}{x/b}\\right)^2 \\,dx\n$$\n使用换元法 $u = x/b$，这意味着 $x = bu$ 和 $dx = b\\,du$：\n$$\nW_{\\mathrm{eq, sinc^2}} = \\int_{-\\infty}^{\\infty} \\left(\\frac{\\sin(u)}{u}\\right)^2 b\\,du = b \\int_{-\\infty}^{\\infty} \\frac{\\sin^2(u)}{u^2} \\,du\n$$\n这是一个经过验证的定积分，其已知值为 $\\int_{-\\infty}^{\\infty} (\\sin^2(u)/u^2)\\,du = \\pi$。因此：\n$$\nW_{\\mathrm{eq, sinc^2}} = b \\pi\n$$\n\n**3. 施加等效宽度相等的条件**\n\n问题陈述了等效宽度相等：$W_{\\mathrm{eq, Gauss}} = W_{\\mathrm{eq, sinc^2}}$。\n$$\n\\sigma\\sqrt{2\\pi} = b\\pi\n$$\n这使我们能够求出形状参数 $\\sigma$ 和 $b$ 的比值：\n$$\n\\frac{\\sigma}{b} = \\frac{\\pi}{\\sqrt{2\\pi}} = \\sqrt{\\frac{\\pi^2}{2\\pi}} = \\sqrt{\\frac{\\pi}{2}}\n$$\n\n**4. 计算分辨率之比**\n\n现在，我们可以将推导出的 FWHM 表达式和形状参数的比率代入分辨率之比的表达式中：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\frac{\\Delta\\lambda_{\\mathrm{FWHM, Gauss}}}{\\Delta\\lambda_{\\mathrm{FWHM, sinc^2}}} = \\frac{2\\sigma\\sqrt{2\\ln(2)}}{2 b u_h} = \\left(\\frac{\\sigma}{b}\\right) \\frac{\\sqrt{2\\ln(2)}}{u_h}\n$$\n代入 $\\sigma/b$ 的表达式：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\left(\\sqrt{\\frac{\\pi}{2}}\\right) \\frac{\\sqrt{2\\ln(2)}}{u_h} = \\frac{\\sqrt{\\pi} \\sqrt{2\\ln(2)}}{\\sqrt{2} u_h} = \\frac{\\sqrt{2\\pi\\ln(2)}}{ \\sqrt{2} u_h} = \\frac{\\sqrt{\\pi\\ln(2)}}{u_h}\n$$\n最后，我们代入常数的数值：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\frac{\\sqrt{\\pi \\ln(2)}}{u_h} \\approx \\frac{\\sqrt{(3.14159...)(0.693147...)}}{1.391559...} \\approx \\frac{\\sqrt{2.177586...}}{1.391559...} \\approx \\frac{1.475698...}{1.391559...} \\approx 1.060470...\n$$\n根据要求四舍五入到四位有效数字，我们得到最终答案。",
            "answer": "$$\n\\boxed{1.060}\n$$"
        },
        {
            "introduction": "真实的传感器除了光谱展宽效应外，还存在其他不完美之处，例如相邻光谱通道之间的串扰。这项高级练习模拟了一个真实的校准场景。在其中，你将使用正则化回归方法从带噪声的数据中估计传感器的串擾矩阵，并应用该校准模型来校正外场测量数据。这项实践将理论上的SRF模型与实际的传感器标定与数据校正任务联系起来。",
            "id": "3845889",
            "problem": "给定一个线性多波段传感器模型，该模型通过一个三对角响应矩阵来捕捉波段间的谱间串扰。假设有 $B$ 个离散的光谱波段。将真实波段辐射亮度向量表示为 $s \\in \\mathbb{R}^B$（单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$），观测到的（带噪声的）传感器输出表示为 $y \\in \\mathbb{R}^B$，波段间响应矩阵表示为 $M \\in \\mathbb{R}^{B \\times B}$。该传感器被建模为一个带加性噪声的线性系统，其关系由下式决定\n$$\ny = M s + \\epsilon,\n$$\n其中 $\\epsilon \\in \\mathbb{R}^B$ 是一个零均值噪声向量。假设矩阵 $M$ 是三对角的，具有对称的相邻波段串扰，由特定波段的对角线增益 $d_i$ 和相邻波段系数 $c_i$ 参数化：\n- 对于 $i = 0, 1, \\dots, B-1$，主对角线元素为 $M_{i,i} = d_i$。\n- 对于 $i = 0, 1, \\dots, B-2$，上、下副对角线元素为 $M_{i,i+1} = c_i$ 和 $M_{i+1,i} = c_i$。\n所有 $d_i$ 和 $c_i$ 均为无量纲。物理辐射亮度的单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n\n您将设计并实现一个定标策略，使用正则化线性回归从定标数据中估计 $d_i$ 和 $c_i$，然后通过反演估计的响应来校正外场测量值。定标激励信号是已知的，定标观测值由一个已知的真实 $M$ 和已知标准差的加性高斯噪声生成。估计过程必须进行正则化，以控制方差并促进波段间的平滑性。\n\n起点和定义：\n- 假设波段响应满足线性叠加原理，并且响应矩阵 $M$ 在定标期间是固定的、时不变的。在遥感领域，当非线性探测器效应和饱和效应可以忽略不计时，这是小信号辐射定标的标准假设。\n- 对于每个定标输入 $s^{(k)} \\in \\mathbb{R}^B$（其中 $k = 1, \\dots, K$），观测输出满足 $y^{(k)} = M s^{(k)} + \\epsilon^{(k)}$，其中 $\\epsilon^{(k)}$ 是零均值高斯噪声。\n- $M$ 的三对角对称性意味着对于给定的邻接索引，对相邻波段的响应在两个方向上的大小是相同的。\n\n定标目标：\n- 通过求解一个正则化最小二乘问题，从定标数据对 $\\{(s^{(k)}, y^{(k)})\\}_{k=1}^K$ 中估计由堆叠 $\\{d_i\\}_{i=0}^{B-1}$ 和 $\\{c_i\\}_{i=0}^{B-2}$ 定义的参数向量 $\\theta \\in \\mathbb{R}^{B+(B-1)}$。构建一个线性设计算子，使得预测的观测值是 $\\theta$ 的线性函数。\n- 将估计问题表述为最小化一个带 Tikhonov 正则化的残差平方和，该正则化项惩罚 $d_i$ 在波段间的一阶差分以及 $c_i$ 在邻接索引间的一阶差分。设正则化强度为 $\\lambda > 0$。\n\n校正目标：\n- 给定一个具有相同噪声特性的外场测量值 $y_{\\mathrm{field}} \\in \\mathbb{R}^B$，通过求解一个带有零阶惩罚项的 Tikhonov 正则化反演问题，恢复真实辐射亮度的估计值 $\\hat{s}$：\n$$\n\\hat{s} = \\arg\\min_{s} \\left\\| \\hat{M} s - y_{\\mathrm{field}} \\right\\|_2^2 + \\alpha \\left\\| s \\right\\|_2^2,\n$$\n其中 $\\hat{M}$ 是 $M$ 的定标估计值，$\\alpha > 0$ 是反演正则化强度。将 $\\hat{s}$ 以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位表示。\n\n测试套件和数据生成：\n为保证可复现性，所有伪随机数必须使用固定的种子（每个测试用例指定）和标准正态分布生成噪声。在每个用例中，使用 $K = B$ 个定标激励信号，包括振幅为 $A = 1.0$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 的单波段激励，即对于 $j = 0, \\dots, B-1$，令 $s^{(j)}$ 为在波段 $j$ 上由 $A$ 缩放的单位基向量。对于每个测试用例，根据指定的 $(d, c)$ 构建 $M$，生成每个分量带有标准差为 $\\sigma$ 的独立高斯噪声的定标输出 $y^{(k)}$，估计 $(\\hat{d}, \\hat{c})$，建立 $\\hat{M}$，生成一个具有相同 $\\sigma$ 的外场测量值 $y_{\\mathrm{field}} = M s_{\\mathrm{field}} + \\epsilon_{\\mathrm{field}}$，并恢复 $\\hat{s}$。使用以下测试用例：\n\n- 用例 $1$ (理想路径): $B = 5$, $d = [1.00, 0.98, 1.02, 1.01, 0.99]$, $c = [0.06, 0.04, 0.05, 0.03]$, $\\sigma = 0.005$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 0.10$, $\\alpha = 0.01$, seed $= 123$, $s_{\\mathrm{field}} = [0.8, 1.2, 0.6, 1.0, 0.7]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n- 用例 $2$ (边界条件：零串扰): $B = 5$, $d = [1.00, 1.00, 1.00, 1.00, 1.00]$, $c = [0.00, 0.00, 0.00, 0.00]$, $\\sigma = 0.010$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 0.05$, $\\alpha = 0.001$, seed $= 7$, $s_{\\mathrm{field}} = [0.5, 1.5, 0.9, 1.1, 0.4]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n- 用例 $3$ (边缘情况：波段少，噪声大，正则化强): $B = 3$, $d = [0.97, 1.03, 1.00]$, $c = [0.08, 0.07]$, $\\sigma = 0.020$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 1.00$, $\\alpha = 0.05$, seed $= 99$, $s_{\\mathrm{field}} = [1.00, 0.50, 1.20]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n\n每个测试用例的必需输出：\n- 计算相邻波段系数的平均绝对误差，定义为\n$$\n\\mathrm{MAE}_c = \\frac{1}{B-1} \\sum_{i=0}^{B-2} \\left| \\hat{c}_i - c_i \\right|,\n$$\n该值为无量纲。\n- 计算校正后外场信号的辐射亮度均方根误差，\n$$\n\\mathrm{RMSE}_s = \\sqrt{\\frac{1}{B} \\sum_{i=0}^{B-1} \\left( \\hat{s}_i - s_{\\mathrm{field}, i} \\right)^2 },\n$$\n以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是一个包含两个元素 $[\\mathrm{MAE}_c, \\mathrm{RMSE}_s]$ 的列表，代表一个测试用例的结果。例如，输出格式必须为\n$$\n\\left[ [x_1, y_1], [x_2, y_2], [x_3, y_3] \\right],\n$$\n使用十进制数值，不含任何额外文本。输出中所有辐射亮度相关的量均以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位。",
            "solution": "用户提供的问题已经过分析，被认为是有效的。它具有科学依据、问题明确、客观，并包含了推导出唯一、可验证解决方案所需的所有信息。该问题要求实现一个两阶段过程：首先，使用正则化线性回归从含噪数据中定标传感器的光谱响应矩阵；其次，使用定标后的矩阵通过正则化反演来校正外场测量值。\n\n解决方案分为三个主要部分：\n1.  构建定标问题以估计传感器响应参数。\n2.  构建信号校正问题以估计真实辐射亮度。\n3.  为所提供的测试用例指定数值实现细节。\n\n### 第1部分：通过正则化线性回归进行定标\n\n定标任务的核心是估计三对角响应矩阵 $M$ 的参数。传感器模型由 $y = M s + \\epsilon$ 给出。矩阵 $M \\in \\mathbb{R}^{B \\times B}$ 由一组 $B$ 个对角线增益 $\\{d_i\\}_{i=0}^{B-1}$ 和 $B-1$ 个相邻波段串扰系数 $\\{c_i\\}_{i=0}^{B-2}$ 定义。我们定义一个单一的参数向量 $\\theta \\in \\mathbb{R}^{2B-1}$，通过拼接这些参数得到：\n$$\n\\theta = [d_0, d_1, \\dots, d_{B-1}, c_0, c_1, \\dots, c_{B-2}]^T\n$$\n我们的目标是将观测向量 $y$ 表示为该参数向量 $\\theta$ 的线性函数。观测信号的第 $i$ 个分量 $y_i$ 可以通过展开矩阵向量积 $Ms$ 来写出：\n$$\ny_i = (Ms)_i = \\sum_{j=0}^{B-1} M_{ij} s_j\n$$\n根据指定的 $M$ 的三对角结构，其中 $M_{i,i} = d_i$，$M_{i,i+1} = c_i$，$M_{i+1,i} = c_i$，这个和可以简化为：\n$$\ny_i = \\begin{cases}\nd_0 s_0 + c_0 s_{1} & \\text{if } i=0 \\\\\nc_{i-1} s_{i-1} + d_i s_i + c_i s_{i+1} & \\text{if } 0 < i < B-1 \\\\\nc_{B-2} s_{B-2} + d_{B-1} s_{B-1} & \\text{if } i=B-1\n\\end{cases}\n$$\n这表明每个分量 $y_i$ 都是 $\\theta$ 中元素的线性组合。因此，我们可以为单个激励-响应对 $(s, y)$ 构建一个设计矩阵，将 $\\theta$ 映射到 $y$。我们称这个单激励设计矩阵为 $X_s \\in \\mathbb{R}^{B \\times (2B-1)}$。$X_s$ 的第 $i$ 行包含 $y_i$ 表达式中 $\\theta$ 的系数。具体来说，$X_s$ 第 $i$ 行的非零项是：\n-   在第 $i$ 列的 $s_i$（对应参数 $d_i$）。\n-   在第 $B+i-1$ 列的 $s_{i-1}$（对应参数 $c_{i-1}$），对于 $i>0$。\n-   在第 $B+i$ 列的 $s_{i+1}$（对应参数 $c_i$），对于 $i<B-1$。\n\n对于 $K$ 个定标对 $\\{(s^{(k)}, y^{(k)})\\}$，我们可以垂直堆叠这些设计矩阵和观测向量，形成一个全局线性系统 $\\mathbf{Y} = \\mathbf{A} \\theta + \\mathbf{E}$，其中 $\\mathbf{A} \\in \\mathbb{R}^{(KB) \\times (2B-1)}$ 且 $\\mathbf{Y} \\in \\mathbb{R}^{KB}$。\n\n要估计 $\\theta$，我们最小化带 Tikhonov 正则化的目标函数：\n$$\nL(\\theta) = \\| \\mathbf{A} \\theta - \\mathbf{Y} \\|_2^2 + \\lambda \\| \\Gamma \\theta \\|_2^2\n$$\n其中正则化矩阵 $\\Gamma$ 旨在惩罚 $d_i$ 和 $c_i$ 向量的一阶差分。$\\Gamma \\in \\mathbb{R}^{(2B-3) \\times (2B-1)}$ 可以构建为：\n-   $B-1$ 行用于惩罚 $(\\dots, d_i - d_{i+1}, \\dots)$。\n-   $B-2$ 行用于惩罚 $(\\dots, c_i - c_{i+1}, \\dots)$。\n\n该最小二乘问题的解析解（正规方程）是：\n$$\n(\\mathbf{A}^T\\mathbf{A} + \\lambda \\Gamma^T\\Gamma)\\hat{\\theta} = \\mathbf{A}^T\\mathbf{Y}\n$$\n这提供了一个线性方程系统，可以求解得到定标参数向量 $\\hat{\\theta}$。\n\n### 第2部分：通过正则化反演进行信号校正\n\n一旦我们从 $\\hat{\\theta}$ 中获得了估计的响应矩阵 $\\hat{M}$，我们就可以用它来校正新的外场测量值 $y_{\\mathrm{field}}$。目标是找到真实信号 $\\hat{s}$，使得 $\\hat{M}\\hat{s} \\approx y_{\\mathrm{field}}$。由于 $\\hat{M}$ 可能接近奇异或条件不佳（尤其是在有串扰的情况下），直接反演（$\\hat{s} = \\hat{M}^{-1} y_{\\mathrm{field}}$）会放大噪声。因此，我们求解一个正则化的反演问题：\n$$\n\\hat{s} = \\arg\\min_{s} \\left\\| \\hat{M} s - y_{\\mathrm{field}} \\right\\|_2^2 + \\alpha \\left\\| s \\right\\|_2^2\n$$\n这里的正则化项 $\\alpha \\|s\\|_2^2$ 惩罚解的范数（能量），有助于在反演过程中稳定解并抑制噪声。该问题的正规方程为：\n$$\n(\\hat{M}^T\\hat{M} + \\alpha I) \\hat{s} = \\hat{M}^T y_{\\mathrm{field}}\n$$\n这是一个 $B \\times B$ 线性系统，可以求解得到校正后的信号向量 $\\hat{s}$。\n\n### 第3部分：数值实现\n\n该算法将按照测试用例中提供的参数进行实现：\n1.  **数据生成**：\n    -   对于给定的 $B$, $d$, $c$，构建真实的响应矩阵 $M$。\n    -   使用固定的随机种子生成高斯噪声向量 $\\epsilon$。\n    -   使用指定的单波段激励信号 $s^{(k)}$ 和噪声 $\\sigma$ 生成 $K=B$ 个定标观测值 $y^{(k)}$。\n    -   使用指定的外场信号 $s_{\\mathrm{field}}$ 和噪声 $\\sigma$ 生成外场观测值 $y_{\\mathrm{field}}$。\n2.  **定标**：\n    -   构建全局设计矩阵 $\\mathbf{A}$ 和观测向量 $\\mathbf{Y}$。\n    -   构建正则化矩阵 $\\Gamma$。\n    -   求解正规方程得到 $\\hat{\\theta} = [\\hat{d}, \\hat{c}]^T$。\n3.  **校正**：\n    -   使用 $\\hat{d}$ 和 $\\hat{c}$ 构建估计的响应矩阵 $\\hat{M}$。\n    -   求解反演正规方程得到校正后的信号 $\\hat{s}$。\n4.  **评估**：\n    -   计算 $\\hat{c}$ 与 $c$ 之间的平均绝对误差（MAE）。\n    -   计算 $\\hat{s}$ 与 $s_{\\mathrm{field}}$ 之间的均方根误差（RMSE）。\n\n所有线性系统都将使用 `numpy.linalg.solve` 求解，这是一种数值稳定的方法。结果将按照指定的格式进行整理和打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sensor calibration and correction problem for a set of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'B': 5, 'd': [1.00, 0.98, 1.02, 1.01, 0.99], 'c': [0.06, 0.04, 0.05, 0.03],\n         'sigma': 0.005, 'lambda_reg': 0.10, 'alpha': 0.01, 'seed': 123,\n         's_field': [0.8, 1.2, 0.6, 1.0, 0.7]},\n        # Case 2\n        {'B': 5, 'd': [1.00, 1.00, 1.00, 1.00, 1.00], 'c': [0.00, 0.00, 0.00, 0.00],\n         'sigma': 0.010, 'lambda_reg': 0.05, 'alpha': 0.001, 'seed': 7,\n         's_field': [0.5, 1.5, 0.9, 1.1, 0.4]},\n        # Case 3\n        {'B': 3, 'd': [0.97, 1.03, 1.00], 'c': [0.08, 0.07],\n         'sigma': 0.020, 'lambda_reg': 1.00, 'alpha': 0.05, 'seed': 99,\n         's_field': [1.00, 0.50, 1.20]},\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        B = case['B']\n        d_true = np.array(case['d'])\n        c_true = np.array(case['c'])\n        sigma = case['sigma']\n        lambda_val = case['lambda_reg']\n        alpha = case['alpha']\n        seed = case['seed']\n        s_field_true = np.array(case['s_field'])\n        \n        rng = np.random.default_rng(seed)\n\n        # 1. Construct the true response matrix M_true\n        M_true = np.zeros((B, B))\n        np.fill_diagonal(M_true, d_true)\n        for i in range(B - 1):\n            M_true[i, i + 1] = c_true[i]\n            M_true[i + 1, i] = c_true[i]\n\n        # 2. Generate calibration data (stimuli and observations)\n        A = 1.0  # Amplitude of calibration stimuli\n        K = B    # Number of calibration stimuli\n        cal_stimuli = [A * np.eye(B)[i] for i in range(K)]\n        cal_observations = []\n        for s_cal in cal_stimuli:\n            y_clean = M_true @ s_cal\n            noise = rng.normal(0, sigma, size=B)\n            y_noisy = y_clean + noise\n            cal_observations.append(y_noisy)\n\n        # 3. Formulate and solve the regularized least squares problem for theta\n        num_params = B + (B - 1)  # B for d_i, B-1 for c_i\n        A_calib = np.zeros((K * B, num_params))\n        Y_calib = np.concatenate(cal_observations)\n\n        # Populate the global design matrix A_calib\n        for k in range(K):  # Index for stimulus\n            s_k = cal_stimuli[k]\n            for i in range(B):  # Index for observed band\n                row_idx = k * B + i\n                # Coefficient for d_i\n                A_calib[row_idx, i] = s_k[i]\n                # Coefficient for c_{i-1}\n                if i > 0:\n                    A_calib[row_idx, B + i - 1] = s_k[i - 1]\n                # Coefficient for c_i\n                if i  B - 1:\n                    A_calib[row_idx, B + i] = s_k[i + 1]\n\n        # 4. Construct the regularization matrix Gamma\n        num_reg_rows = (B - 1) + (B - 2)\n        Gamma = np.zeros((num_reg_rows, num_params))\n        \n        # Regularization for first differences of d_i\n        for i in range(B - 1):\n            Gamma[i, i] = -1\n            Gamma[i, i + 1] = 1\n\n        # Regularization for first differences of c_i\n        offset = B - 1\n        for i in range(B - 2):\n            Gamma[offset + i, B + i] = -1\n            Gamma[offset + i, B + i + 1] = 1\n        \n        # 5. Solve for the estimated parameters theta_hat\n        # (A_calib^T A_calib + lambda * Gamma^T Gamma) theta = A_calib^T Y\n        AtA = A_calib.T @ A_calib\n        GtG = Gamma.T @ Gamma\n        LHS = AtA + lambda_val * GtG\n        RHS = A_calib.T @ Y_calib\n        \n        theta_hat = np.linalg.solve(LHS, RHS)\n        \n        d_hat = theta_hat[:B]\n        c_hat = theta_hat[B:]\n\n        # 6. Construct M_hat and correct the field measurement\n        M_hat = np.zeros((B, B))\n        np.fill_diagonal(M_hat, d_hat)\n        for i in range(B - 1):\n            M_hat[i, i + 1] = c_hat[i]\n            M_hat[i + 1, i] = c_hat[i]\n\n        # Generate the noisy field measurement y_field\n        y_field_clean = M_true @ s_field_true\n        noise_field = rng.normal(0, sigma, size=B)\n        y_field_noisy = y_field_clean + noise_field\n\n        # Solve the regularized inverse problem for s_hat\n        # (M_hat^T M_hat + alpha * I) s = M_hat^T y_field\n        LHS_s = M_hat.T @ M_hat + alpha * np.eye(B)\n        RHS_s = M_hat.T @ y_field_noisy\n        s_hat = np.linalg.solve(LHS_s, RHS_s)\n\n        # 7. Calculate and store the required metrics\n        mae_c = np.mean(np.abs(c_hat - c_true))\n        rmse_s = np.sqrt(np.mean((s_hat - s_field_true)**2))\n        \n        all_results.append(f\"[{mae_c:.8f}, {rmse_s:.8f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}