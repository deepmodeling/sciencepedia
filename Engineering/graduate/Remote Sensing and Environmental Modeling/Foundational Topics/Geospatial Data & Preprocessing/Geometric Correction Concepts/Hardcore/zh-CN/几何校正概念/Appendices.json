{
    "hands_on_practices": [
        {
            "introduction": "在遥感影像中，由地形起伏引起的几何变形是一种基本现象，称为地形位移。本练习将引导你从中心投影的第一性原理出发，推导并计算地形位移的大小 。掌握这一概念对于理解和执行正射校正至关重要，因为它是精确配准影像与地表真实位置的基础。",
            "id": "3815616",
            "problem": "一颗框幅式成像卫星在一块可被局部近似为水平参考平面的地形上获取了一幅垂直照片。将成像过程建模为中心透视（针孔）相机，其焦距 $f$ 以像素为单位。采用一个像方坐标系，其中主点位于原点，且从主点算起的径向距离以像素为单位。设卫星位于参考平面上方 $H$ 的高度处，且位于相机光轴上。考虑一个在参考平面上方高度为 $h$ 的小的、孤立的地物。该地物的底部在像片上的投影点与主点的径向距离为 $r$。\n\n仅使用中心透视投影关系（即一个物方点，其沿光轴方向距相机中心的距离为 $Z$，横向地面偏移为 $R$，投影到像片上的径向坐标为 $r = f\\,R/Z$），从第一性原理出发，推导像片上径向地形位移的精确表达式。该位移定义为地物顶部和底部投影位置之间的径向向外位移，并用 $r$、$f$、$H$ 和 $h$ 表示。然后，当 $h = 50\\,\\mathrm{m}$，$r = 2000\\,\\mathrm{px}$，$H = 600\\,\\mathrm{km}$ 且 $f = 1000\\,\\mathrm{px}$ 时，对此位移进行数值计算。将最终数值结果四舍五入至四位有效数字。答案以像素为单位表示。",
            "solution": "问题要求推导径向地形位移的表达式并进行数值计算。该问题基于中心透视投影原理，在物理和数学上都有明确定义，因此是有效的。\n\n我们从第一性原理开始。成像系统被建模为针孔相机，其几何关系由相似三角形决定。设相机的投影中心（针孔）为原点 $O$。光轴与 $Z$ 轴对齐，像平面平行于 $XY$ 平面，且与原点的距离为 $f$。物方空间中一个坐标为 $(X, Y, Z)$、与光轴的横向偏移为 $R = \\sqrt{X^2 + Y^2}$ 的点被投影到像平面上。问题给出了径向像方坐标 $r$ 的投影关系为 $r = f R/Z$，其中 $Z$ 是从相机中心沿光轴到物方点的距离。这个关系是由物方点、相机中心以及它们在光轴和像平面上的投影所构成的三角形相似性的直接结果。\n\n对于垂直摄影，相机光轴垂直于参考平面。卫星在该平面上方 $H$ 的高度处。我们可以建立一个坐标系，其中相机中心位于高度 $H$ 处，参考平面位于高度 $0$ 处。\n\n让我们在该坐标系中定位地物的底部和顶部。\n\n1.  **地物的底部：**\n    地物的底部位于参考平面上。其在此平面上方的高度为 $0$。因此，从相机中心到包含地物底部的平面的距离为 $Z_{\\text{base}} = H$。\n    设地物底部的横向地面偏移为 $R$。问题陈述其底部在像片上的投影径向距离为 $r$。使用给定的投影公式：\n    $$r = \\frac{f R}{Z_{\\text{base}}} = \\frac{f R}{H}$$\n    该方程将已知的像方坐标 $r$ 与未知的地面偏移 $R$ 联系起来。我们可以重新整理该式，用给定的量来表示 $R$：\n    $$R = \\frac{rH}{f}$$\n\n2.  **地物的顶部：**\n    该地物的高度为 $h$。假设它是一个垂直地物，其顶部直接位于其底部之上，因此它具有相同的横向地面偏移 $R$。顶部在参考平面上方的高度为 $h$。\n    从相机中心到包含地物顶部的平面的距离为 $Z_{\\text{top}} = H - h$。\n    设投影顶部的像方径向距离为 $r_{\\text{top}}$。再次应用投影公式：\n    $$r_{\\text{top}} = \\frac{f R}{Z_{\\text{top}}} = \\frac{f R}{H - h}$$\n\n3.  **地形位移的推导：**\n    地形位移 $\\Delta r$ 定义为从投影的底部到投影的顶部的径向向外位移。\n    $$\\Delta r = r_{\\text{top}} - r$$\n    为了用指定的变量（$r$、$f$、$H$ 和 $h$）来表示它，我们代入 $r_{\\text{top}}$ 和 $R$ 的表达式。\n    首先，将第 1 步中 $R$ 的表达式代入 $r_{\\text{top}}$ 的方程中：\n    $$r_{\\text{top}} = \\frac{f}{H - h} \\left( \\frac{rH}{f} \\right) = \\frac{rH}{H - h}$$\n    注意，焦距 $f$ 已被消掉。现在，我们可以计算位移：\n    $$\\Delta r = \\frac{rH}{H - h} - r$$\n    提取公因子 $r$：\n    $$\\Delta r = r \\left( \\frac{H}{H - h} - 1 \\right)$$\n    为了简化括号中的表达式，我们通分：\n    $$\\Delta r = r \\left( \\frac{H - (H - h)}{H - h} \\right) = r \\left( \\frac{H - H + h}{H - h} \\right)$$\n    这就得到了径向地形位移的最终精确表达式：\n    $$\\Delta r = \\frac{rh}{H - h}$$\n    尽管问题要求用 $r$、$f$、$H$ 和 $h$ 来表示该表达式，但当地形位移表示为像方坐标 $r$ 的函数时，焦距 $f$ 在代数上被消除了。焦距对于关联像方和物方空间是根本必要的，但它没有出现在这个特定的最终关系式中。\n\n4.  **数值计算：**\n    给定以下值：\n    $h = 50\\,\\mathrm{m}$\n    $r = 2000\\,\\mathrm{px}$\n    $H = 600\\,\\mathrm{km}$\n    $f = 1000\\,\\mathrm{px}$（这个值在最终计算中不需要）。\n\n    为了使公式在量纲上保持一致，$h$ 和 $H$ 必须使用相同的单位。我们将 $H$ 转换为米：\n    $$H = 600\\,\\mathrm{km} = 600 \\times 1000\\,\\mathrm{m} = 600000\\,\\mathrm{m}$$\n    现在，将数值代入推导出的 $\\Delta r$ 表达式中：\n    $$\\Delta r = \\frac{(2000\\,\\mathrm{px}) \\times (50\\,\\mathrm{m})}{600000\\,\\mathrm{m} - 50\\,\\mathrm{m}}$$\n    $$\\Delta r = \\frac{100000}{599950}\\,\\mathrm{px}$$\n    进行除法计算：\n    $$\\Delta r \\approx 0.16667222\\,\\mathrm{px}$$\n    问题要求将结果四舍五入到四位有效数字。前四位有效数字是 $1$、$6$、$6$、$6$。后一位数字是 $7$，所以我们将最后一位数字向上取整。\n    $$\\Delta r \\approx 0.1667\\,\\mathrm{px}$$",
            "answer": "$$\\boxed{0.1667}$$"
        },
        {
            "introduction": "一旦理解了畸变的来源，下一步就是建立一个数学模型来校正它们。本练习通过一个实际的编程任务，让你使用地面控制点（GCPs）通过最小二乘法来求解仿射变换参数，这是几何校正中最常用的经验模型之一 。通过分析不同GCP分布下的结果，你将深入理解模型稳健性与控制点几何构型之间的关键关系。",
            "id": "3815685",
            "problem": "给定三个独立的场景，每个场景都包含$12$个地面控制点（GCP），其图像坐标为 $(x_i,y_i)$，观测到的地图坐标为 $(X_i,Y_i)$。假设采用一个仿射几何校正模型，该模型将图像坐标线性映射到地图坐标。您的任务是：\n\n- 为两个坐标轴建立线性观测模型，并在经典Gauss–Markov框架下，从第一性原理推导出$X$轴和$Y$轴映射的仿射参数的最小二乘估计量。\n- 根据估计量的性质，推导出残差方差的无偏估计量，以及每个坐标轴仿射参数的协方差矩阵。\n- 使用误差传播定律，通过将参数协方差传播到所提供的$(x_i,y_i)$处的观测空间，预测给定设计点上残差的均方根误差（RMSE）。\n- 计算拟合模型在GCP处残差的经验RMSE，以进行比较。\n\n对于每个场景，输出一个包含八个浮点数的列表：\n- 前六个值是$X$轴和$Y$轴映射的仿射参数，顺序为 $[a_0,a_1,a_2,b_0,b_1,b_2]$，其中仿射模型为 $X = a_0 + a_1 x + a_2 y$ 和 $Y = b_0 + b_1 x + b_2 y$。\n- 接下来两个值是预测的RMSE（通过在设计点上传播参数协方差得到）和经验RMSE（通过残差计算得到），按此顺序排列。\n\n所有值都应四舍五入到六位小数。不需要物理单位。不出现角度。不出现百分比。\n\n可用于推导的基础理论：\n- 具有独立、等方差误差的线性观测模型。\n- Gauss–Markov假设下的普通最小二乘法。\n- 最小二乘估计量的性质，包括无偏方差估计和参数协方差。\n- 线性函数的误差传播定律。\n\n三个场景的测试套件数据：\n\n- 场景 $1$ （分布良好的GCP，噪声较小）：\n    - 图像坐标 $(x_i,y_i)$：\n        - $(x,y)$ 列表：$[(0,0),(100,0),(0,100),(100,100),(50,0),(0,50),(50,50),(150,50),(50,150),(150,150),(200,100),(100,200)]$\n    - 观测地图坐标 $(X_i,Y_i)$：\n        - $[(500.8,-301.2),(699.5,-279.1),(551.1,-150.4),(749.3,-129.7),(600.3,-290.6),(524.0,-224.3),(625.2,-215.0),(824.6,-196.5),(675.0,-63.6),(875.6,-45.8),(949.1,-109.5),(800.4,18.9)]$\n\n- 场景 $2$ （近乎共线的GCP；病态设计）：\n    - 图像坐标 $(x_i,y_i)$，其中 $y_i \\approx 0.1 x_i$：\n        - $(x,y)$ 列表：$[(0,-0.5),(10,1.2),(20,1.9),(30,3.0),(40,4.3),(50,4.6),(60,6.1),(70,6.8),(80,8.5),(90,8.7),(100,10.2),(110,11.0)]$\n    - 观测地图坐标 $(X_i,Y_i)$：\n        - $[(1000.35,-501.2),(1009.38,-497.0),(1020.21,-495.5),(1029.5,-492.0),(1039.67,-489.5),(1049.24,-488.1),(1059.39,-485.2),(1069.52,-482.9),(1079.05,-478.7),(1089.63,-478.7),(1098.58,-474.2),(1109.2,-472.3)]$\n\n- 场景 $3$ （分布良好的GCP，噪声较大）：\n    - 图像坐标 $(x_i,y_i)$：\n        - $(x,y)$ 列表：$[(0,0),(300,0),(0,300),(300,300),(150,0),(0,150),(150,150),(450,150),(150,450),(450,450),(600,300),(300,600)]$\n    - 观测地图坐标 $(X_i,Y_i)$：\n        - $[(-193.5,792.0),(245.8,1015.7),(-286.7,1063.9),(153.0,1289.4),(33.2,900.4),(-250.1,942.3),(-15.3,1036.7),(426.4,1256.6),(-102.9,1304.8),(337.6,1528.8),(615.5,1482.3),(63.2,1560.5)]$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个场景的结果本身也是一个用方括号括起来的逗号分隔子列表，且不含空格。例如，结构必须是：\n- $[[a_0,a_1,a_2,b_0,b_1,b_2,\\text{predRMSE},\\text{empRMSE}],[\\dots],[\\dots]]$",
            "solution": "用户提供的问题是有效的。这是一个适定的、具有科学依据的、属于地理信息学和遥感领域的问题，基于线性代数和统计估计理论（普通最小二乘法）的基本原理。为所有三个场景提供的数据是完整的，足以获得唯一解，并且所需的推导和计算是该学科的标准程序。第二个场景虽然是病态的，但它是一个有效的案例，用于展示控制点几何分布不良的影响，这是该领域的一个关键概念。\n\n### 1. 理论推导\n\n该问题要求执行仿射变换，将图像坐标 $(x,y)$ 映射到地图坐标 $(X,Y)$。该变换由两个独立的线性方程定义：\n$$\n\\begin{cases}\nX = a_0 + a_1 x + a_2 y \\\\\nY = b_0 + b_1 x + b_2 y\n\\end{cases}\n$$\n这两个方程可以使用普通最小二乘法（OLS）独立求解。下面将展示对$X$坐标模型的推导过程，同样的逻辑也适用于$Y$坐标模型。\n\n**$X$坐标的线性观测模型**\n\n对于$N$个地面控制点（GCP），我们有一个包含$N$个线性观测方程的方程组。对于每个点 $i=1, \\dots, N$：\n$$\nX_i + v_{X,i} = a_0 + a_1 x_i + a_2 y_i\n$$\n其中 $X_i$ 是观测到的地图坐标，$v_{X,i}$ 是未知的随机误差或残差。Gauss-Markov模型假设这些误差不相关且具有恒定方差，即 $E[v_{X,i}] = 0$ 和 $E[v_{X,i}^2] = \\sigma_X^2$，并且对于 $i \\neq j$ 有 $E[v_{X,i}v_{X,j}] = 0$。\n\n该系统可以写成矩阵形式：\n$$\n\\mathbf{L}_X + \\mathbf{v}_X = \\mathbf{A} \\mathbf{p}_a\n$$\n其中：\n- $\\mathbf{L}_X = [X_1, X_2, \\dots, X_N]^T$ 是观测值的 $N \\times 1$ 向量。\n- $\\mathbf{v}_X = [v_{X,1}, v_{X,2}, \\dots, v_{X,N}]^T$ 是残差的 $N \\times 1$ 向量。\n- $\\mathbf{p}_a = [a_0, a_1, a_2]^T$ 是未知仿射参数的 $3 \\times 1$ 向量。\n- $\\mathbf{A}$ 是 $N \\times 3$ 的设计矩阵，其元素是已知的图像坐标：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1  x_1  y_1 \\\\\n1  x_2  y_2 \\\\\n\\vdots  \\vdots  \\vdots \\\\\n1  x_N  y_N\n\\end{pmatrix}\n$$\n观测值的协方差矩阵为 $\\boldsymbol{\\Sigma}_{\\mathbf{L}_X \\mathbf{L}_X} = E[\\mathbf{v}_X \\mathbf{v}_X^T] = \\sigma_X^2 \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $N \\times N$ 的单位矩阵。\n\n**参数的最小二乘估计**\n\nOLS原理旨在找到使残差平方和 $S = \\mathbf{v}_X^T \\mathbf{v}_X$ 最小化的估计值 $\\hat{\\mathbf{p}}_a$。\n$$\nS = (\\mathbf{A} \\mathbf{p}_a - \\mathbf{L}_X)^T (\\mathbf{A} \\mathbf{p}_a - \\mathbf{L}_X)\n$$\n为了找到最小值，我们将 $S$ 对 $\\mathbf{p}_a$求导，并令导数等于零：\n$$\n\\frac{\\partial S}{\\partial \\mathbf{p}_a} = 2 \\mathbf{A}^T (\\mathbf{A} \\hat{\\mathbf{p}}_a - \\mathbf{L}_X) = \\mathbf{0}\n$$\n这导出了**法方程**：\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\hat{\\mathbf{p}}_a = \\mathbf{A}^T \\mathbf{L}_X\n$$\n假设矩阵 $\\mathbf{A}^T \\mathbf{A}$ 是可逆的（这要求GCP不共线，即 $\\mathbf{A}$ 具有满列秩 $p=3$），则参数的最小二乘估计量为：\n$$\n\\hat{\\mathbf{p}}_a = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{L}_X\n$$\n类似地，对于$Y$坐标参数 $\\mathbf{p}_b = [b_0, b_1, b_2]^T$，其估计量为：\n$$\n\\hat{\\mathbf{p}}_b = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{L}_Y\n$$\n其中 $\\mathbf{L}_Y = [Y_1, Y_2, \\dots, Y_N]^T$。\n\n**残差方差与参数协方差**\n\n估计残差的向量为 $\\hat{\\mathbf{v}}_X = \\mathbf{A} \\hat{\\mathbf{p}}_a - \\mathbf{L}_X$。残差平方和（SSR）为 $\\text{SSR}_X = \\hat{\\mathbf{v}}_X^T \\hat{\\mathbf{v}}_X$。\nSSR的期望值为 $E[\\text{SSR}_X] = (N-p)\\sigma_X^2$，其中 $p=3$ 是参数的数量。量 $r = N-p$ 是平差的自由度。\n\n**残差方差** $\\sigma_X^2$ 的**无偏估计量**为：\n$$\n\\hat{\\sigma}_X^2 = \\frac{\\text{SSR}_X}{N-p}\n$$\n估计参数 $\\hat{\\mathbf{p}}_a$ 的**协方差矩阵**是通过在估计量方程 $\\hat{\\mathbf{p}}_a = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{L}_X$ 上使用方差传播定律推导出来的：\n$$\n\\boldsymbol{\\Sigma}_{\\hat{\\mathbf{p}}_a \\hat{\\mathbf{p}}_a} = \\left[(\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T\\right] \\boldsymbol{\\Sigma}_{\\mathbf{L}_X \\mathbf{L}_X} \\left[(\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T\\right]^T = \\sigma_X^2 (\\mathbf{A}^T \\mathbf{A})^{-1}\n$$\n由于 $\\sigma_X^2$ 是未知的，我们使用它的估计值 $\\hat{\\sigma}_X^2$ 来获得估计的协方差矩阵：\n$$\n\\hat{\\boldsymbol{\\Sigma}}_{\\hat{\\mathbf{p}}_a \\hat{\\mathbf{p}}_a} = \\hat{\\sigma}_X^2 (\\mathbf{A}^T \\mathbf{A})^{-1}\n$$\n\n### 2. RMSE 计算\n\n**经验RMSE**\n\n经验均方根误差衡量模型与数据点的实际拟合差异。对于每个点 $i$，残差平方误差为 $e_i^2 = \\hat{v}_{X,i}^2 + \\hat{v}_{Y,i}^2$。经验RMSE是所有$N$个点的这些平方误差均值的平方根：\n$$\n\\text{RMSE}_{\\text{emp}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (\\hat{v}_{X,i}^2 + \\hat{v}_{Y,i}^2)} = \\sqrt{\\frac{\\text{SSR}_X + \\text{SSR}_Y}{N}}\n$$\n\n**预测RMSE**\n\n预测RMSE是通过将参数不确定性传播到观测空间而导出的。单个预测坐标的方差，例如 $\\hat{X}_i = \\mathbf{a}_i^T \\hat{\\mathbf{p}}_a$（其中 $\\mathbf{a}_i^T = [1, x_i, y_i]$ 是 $\\mathbf{A}$ 的第$i$行），由下式给出：\n$$\n\\text{Var}(\\hat{X}_i) = \\mathbf{a}_i^T \\boldsymbol{\\Sigma}_{\\hat{\\mathbf{p}}_a \\hat{\\mathbf{p}}_a} \\mathbf{a}_i = \\sigma_X^2 \\, \\mathbf{a}_i^T (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{a}_i = \\sigma_X^2 h_{ii}\n$$\n其中 $h_{ii}$ 是“帽子”矩阵 $\\mathbf{H} = \\mathbf{A}(\\mathbf{A}^T \\mathbf{A})^{-1}\\mathbf{A}^T$ 的第$i$个对角元素。值 $h_{ii}$ 是第$i$个观测值的杠杆值。\n\n预测RMSE是设计点上拟合值标准误差的均方根。一个点的平均预测方差（对X和Y分量求和）为：\n$$\n\\frac{1}{N} \\sum_{i=1}^N \\left[ \\text{Var}(\\hat{X}_i) + \\text{Var}(\\hat{Y}_i) \\right] = \\frac{1}{N} \\sum_{i=1}^N \\left[ \\sigma_X^2 h_{ii} + \\sigma_Y^2 h_{ii} \\right] = \\frac{\\sigma_X^2 + \\sigma_Y^2}{N} \\sum_{i=1}^N h_{ii}\n$$\n杠杆值之和是帽子矩阵的迹，$\\text{tr}(\\mathbf{H}) = p = 3$。因此，平均预测方差为 $\\frac{p}{N}(\\sigma_X^2 + \\sigma_Y^2)$。\n预测RMSE是这个量的平方根，使用估计值 $\\hat{\\sigma}_X^2$ 和 $\\hat{\\sigma}_Y^2$：\n$$\n\\text{RMSE}_{\\text{pred}} = \\sqrt{\\frac{p}{N}(\\hat{\\sigma}_X^2 + \\hat{\\sigma}_Y^2)} = \\sqrt{\\frac{p}{N} \\left( \\frac{\\text{SSR}_X}{N-p} + \\frac{\\text{SSR}_Y}{N-p} \\right)} = \\sqrt{\\frac{p (\\text{SSR}_X + \\text{SSR}_Y)}{N(N-p)}}\n$$\n\n### 3. 计算步骤\n对于每个场景：\n1. 设置 $N=12$ 和 $p=3$。自由度为 $df = N-p=9$。\n2. 根据图像坐标 $(x_i, y_i)$ 构建 $12 \\times 3$ 的设计矩阵 $\\mathbf{A}$。\n3. 根据地图坐标 $(X_i, Y_i)$ 构建 $12 \\times 1$ 的观测向量 $\\mathbf{L}_X$ 和 $\\mathbf{L}_Y$。\n4. 计算法矩阵 $\\mathbf{N} = \\mathbf{A}^T \\mathbf{A}$ 以及向量 $\\mathbf{c}_X = \\mathbf{A}^T \\mathbf{L}_X$ 和 $\\mathbf{c}_Y = \\mathbf{A}^T \\mathbf{L}_Y$。\n5. 求解线性方程组 $\\mathbf{N} \\hat{\\mathbf{p}}_a = \\mathbf{c}_X$ 和 $\\mathbf{N} \\hat{\\mathbf{p}}_b = \\mathbf{c}_Y$，得到参数向量 $\\hat{\\mathbf{p}}_a = [a_0, a_1, a_2]^T$ 和 $\\hat{\\mathbf{p}}_b = [b_0, b_1, b_2]^T$。\n6. 计算残差向量 $\\hat{\\mathbf{v}}_X = \\mathbf{A} \\hat{\\mathbf{p}}_a - \\mathbf{L}_X$ 和 $\\hat{\\mathbf{v}}_Y = \\mathbf{A} \\hat{\\mathbf{p}}_b - \\mathbf{L}_Y$。\n7. 计算残差平方和 $\\text{SSR}_X = \\hat{\\mathbf{v}}_X^T \\hat{\\mathbf{v}}_X$ 和 $\\text{SSR}_Y = \\hat{\\mathbf{v}}_Y^T \\hat{\\mathbf{v}}_Y$。令 $\\text{SSR}_{\\text{total}} = \\text{SSR}_X + \\text{SSR}_Y$。\n8. 计算 $\\text{RMSE}_{\\text{pred}} = \\sqrt{\\frac{p \\cdot \\text{SSR}_{\\text{total}}}{N \\cdot df}} = \\sqrt{\\frac{3 \\cdot \\text{SSR}_{\\text{total}}}{12 \\cdot 9}} = \\sqrt{\\frac{\\text{SSR}_{\\text{total}}}{36}}$。\n9. 计算 $\\text{RMSE}_{\\text{emp}} = \\sqrt{\\frac{\\text{SSR}_{\\text{total}}}{N}} = \\sqrt{\\frac{\\text{SSR}_{\\text{total}}}{12}}$。\n10. 组合成包含8个浮点数的最终列表，并四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted, as scipy is not needed for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the affine transformation problem for three scenarios using Ordinary Least Squares.\n    \"\"\"\n\n    test_cases = [\n        # Scenario 1 (well-distributed GCPs with small noise)\n        {\n            \"img_coords\": np.array([\n                [0, 0], [100, 0], [0, 100], [100, 100], [50, 0], [0, 50],\n                [50, 50], [150, 50], [50, 150], [150, 150], [200, 100], [100, 200]\n            ]),\n            \"map_coords\": np.array([\n                [500.8, -301.2], [699.5, -279.1], [551.1, -150.4], [749.3, -129.7],\n                [600.3, -290.6], [524.0, -224.3], [625.2, -215.0], [824.6, -196.5],\n                [675.0, -63.6], [875.6, -45.8], [949.1, -109.5], [800.4, 18.9]\n            ])\n        },\n        # Scenario 2 (near-collinear GCPs; ill-conditioned design)\n        {\n            \"img_coords\": np.array([\n                [0, -0.5], [10, 1.2], [20, 1.9], [30, 3.0], [40, 4.3], [50, 4.6],\n                [60, 6.1], [70, 6.8], [80, 8.5], [90, 8.7], [100, 10.2], [110, 11.0]\n            ]),\n            \"map_coords\": np.array([\n                [1000.35, -501.2], [1009.38, -497.0], [1020.21, -495.5], [1029.5, -492.0],\n                [1039.67, -489.5], [1049.24, -488.1], [1059.39, -485.2], [1069.52, -482.9],\n                [1079.05, -478.7], [1089.63, -478.7], [1098.58, -474.2], [1109.2, -472.3]\n            ])\n        },\n        # Scenario 3 (well-distributed GCPs with larger noise)\n        {\n            \"img_coords\": np.array([\n                [0, 0], [300, 0], [0, 300], [300, 300], [150, 0], [0, 150],\n                [150, 150], [450, 150], [150, 450], [450, 450], [600, 300], [300, 600]\n            ]),\n            \"map_coords\": np.array([\n                [-193.5, 792.0], [245.8, 1015.7], [-286.7, 1063.9], [153.0, 1289.4],\n                [33.2, 900.4], [-250.1, 942.3], [-15.3, 1036.7], [426.4, 1256.6],\n                [-102.9, 1304.8], [337.6, 1528.8], [615.5, 1482.3], [63.2, 1560.5]\n            ])\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        img_coords = case[\"img_coords\"]\n        map_coords = case[\"map_coords\"]\n        \n        N = img_coords.shape[0]  # Number of observations (GCPs)\n        p = 3  # Number of parameters (a0, a1, a2)\n        df = N - p # Degrees of freedom\n\n        # Construct the design matrix A\n        A = np.ones((N, p))\n        A[:, 1] = img_coords[:, 0]  # x coordinates\n        A[:, 2] = img_coords[:, 1]  # y coordinates\n\n        # Construct the observation vectors L_X and L_Y\n        L_X = map_coords[:, 0]\n        L_Y = map_coords[:, 1]\n        \n        # Form the normal equations: (A^T A) p = A^T L\n        N_matrix = A.T @ A\n        c_X = A.T @ L_X\n        c_Y = A.T @ L_Y\n        \n        # Solve for the parameter vectors p_a and p_b\n        try:\n            # np.linalg.solve is numerically more stable than using np.linalg.inv\n            p_a = np.linalg.solve(N_matrix, c_X)\n            p_b = np.linalg.solve(N_matrix, c_Y)\n        except np.linalg.LinAlgError:\n            # Fallback for singular matrix, although not expected with test data\n            inv_N = np.linalg.pinv(N_matrix)\n            p_a = inv_N @ c_X\n            p_b = inv_N @ c_Y\n            \n        a0, a1, a2 = p_a\n        b0, b1, b2 = p_b\n        \n        # Calculate residuals\n        v_X = A @ p_a - L_X\n        v_Y = A @ p_b - L_Y\n        \n        # Calculate Sum of Squared Residuals (SSR)\n        ssr_X = v_X.T @ v_X\n        ssr_Y = v_Y.T @ v_Y\n        ssr_total = ssr_X + ssr_Y\n        \n        # Calculate predicted RMSE from parameter covariance propagation\n        # RMSE_pred = sqrt( (p/N) * (sigma_hat_X^2 + sigma_hat_Y^2) )\n        #           = sqrt( (p/N) * (SSR_X/df + SSR_Y/df) )\n        #           = sqrt( p * (SSR_X + SSR_Y) / (N * df) )\n        if df > 0:\n            rmse_pred = np.sqrt(p * ssr_total / (N * df))\n        else:\n            rmse_pred = 0.0\n\n        # Calculate empirical RMSE from residuals\n        # RMSE_emp = sqrt( (1/N) * sum(v_Xi^2 + v_Yi^2) )\n        #          = sqrt( (SSR_X + SSR_Y) / N )\n        rmse_emp = np.sqrt(ssr_total / N)\n        \n        # Format results\n        scenario_result = [a0, a1, a2, b0, b1, b2, rmse_pred, rmse_emp]\n        rounded_result = [round(val, 6) for val in scenario_result]\n        all_results.append(rounded_result)\n\n    # Format the final output string exactly as required\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        output_str += f\"[{','.join(map(str, res))}]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n            \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了从原始影像到地理参考空间的几何变换后，最后一步是生成新的、校正后的影像栅格，这个过程称为重采样。本练习聚焦于一种广泛使用的重采样技术——双线性插值，要求你在非整数像素位置上计算新的像素值 。这个动手计算将帮助你掌握在保持影像信息的同时，如何将离散的像素数据精确地映射到新的几何网格上。",
            "id": "3815691",
            "problem": "一台星载推扫式成像光谱仪获取了一幅经过辐射定标和大气校正的、覆盖非均质农业景观的地表反射率图像。在几何校正过程中，一个田块的大地坐标通过有理多项式系数（RPC）映射到图像网格上。对于一个特定位置，其校正后的像平面坐标为 $(u,v)=(10.3,20.7)$，其中反射率图像在沿两个坐标轴单位间距的整数网格中心 $(i,j)$ 上采样。\n\n假设以下物理上合理的依据：局部重建核可以模型化为沿 $u$ 和 $v$ 轴可分离的，并且场景反射率场在单个像素足迹内足够平滑，因此局部点扩散函数（PSF）的线性特性证明了沿各轴进行线性插值是合理的。在这些假设下，将重采样视为一个沿 $u$ 和 $v$ 的两阶段一维线性插值过程。\n\n在整数坐标处给出了四个最近的像素中心反射率（无量纲分数）：\n- $(10,20)$ 处的反射率为 $0.12$，\n- $(11,20)$ 处的反射率为 $0.18$，\n- $(10,21)$ 处的反射率为 $0.30$，\n- $(11,21)$ 处的反射率为 $0.42$。\n\n使用上述可分离、局部线性的重采样假设，计算 $(u,v)=(10.3,20.7)$ 处的重采样反射率。将您的答案保留四位有效数字。将最终反射率表示为一个分数（无量纲）。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、形式适定、客观，并包含得出唯一且有意义解所需的所有信息。该问题描述了遥感中一个标准的图像处理任务，称为重采样，具体使用的是双线性插值。\n\n任务是计算像平面坐标 $(u, v) = (10.3, 20.7)$ 处的重采样地表反射率。问题指明这可以被视为一个两阶段一维线性插值过程，这等同于双线性插值。反射率值在四个最近的整数网格中心处给出。\n\n设 $R(i, j)$ 表示整数网格坐标 $(i, j)$ 处的反射率。给定的数据是：\n- $R(10, 20) = 0.12$\n- $R(11, 20) = 0.18$\n- $R(10, 21) = 0.30$\n- $R(11, 21) = 0.42$\n\n目标坐标是 $(u, v) = (10.3, 20.7)$。我们可以定义这些坐标的整数部分和小数部分。设 $i = \\lfloor u \\rfloor = 10$ 和 $j = \\lfloor v \\rfloor = 20$。从这个原点 $(i, j)$ 开始的小数距离是：\n- $\\Delta u = u - i = 10.3 - 10 = 0.3$\n- $\\Delta v = v - j = 20.7 - 20 = 0.7$\n\n可分离线性插值可以分两个阶段进行。首先，我们对两个相邻的整数 $v$ 坐标，$j=20$ 和 $j+1=21$，沿 $u$ 轴进行插值。\n\n阶段1：沿 $u$ 轴进行线性插值。\n函数 $f(x)$ 在点 $(x_1, f(x_1))$ 和 $(x_2, f(x_2))$ 之间的线性插值通用公式是 $f(x) = (1-\\alpha)f(x_1) + \\alpha f(x_2)$，其中 $\\alpha = \\frac{x-x_1}{x_2-x_1}$。在我们的情况下，网格间距为1，所以 $x_2-x_1=1$，权重因子 $\\alpha$ 就是小数距离。\n\n首先，我们使用 $(10, 20)$ 和 $(11, 20)$ 处的值计算 $(10.3, 20)$ 处的插值反射率。小数距离为 $\\Delta u = 0.3$。\n$$R_{u1} = R(10.3, 20) = (1 - \\Delta u) R(10, 20) + \\Delta u R(11, 20)$$\n$$R_{u1} = (1 - 0.3) \\times 0.12 + 0.3 \\times 0.18$$\n$$R_{u1} = 0.7 \\times 0.12 + 0.3 \\times 0.18 = 0.084 + 0.054 = 0.138$$\n\n接着，我们使用 $(10, 21)$ 和 $(11, 21)$ 处的值计算 $(10.3, 21)$ 处的插值反射率。\n$$R_{u2} = R(10.3, 21) = (1 - \\Delta u) R(10, 21) + \\Delta u R(11, 21)$$\n$$R_{u2} = (1 - 0.3) \\times 0.30 + 0.3 \\times 0.42$$\n$$R_{u2} = 0.7 \\times 0.30 + 0.3 \\times 0.42 = 0.210 + 0.126 = 0.336$$\n\n阶段2：沿 $v$ 轴进行线性插值。\n现在，我们在 $(10.3, 20)$ 处的中间值 $R_{u1} = 0.138$ 和 $(10.3, 21)$ 处的中间值 $R_{u2} = 0.336$ 之间进行垂直插值，以找到 $(10.3, 20.7)$ 处的最终值。小数距离为 $\\Delta v = 0.7$。\n$$R(u, v) = R(10.3, 20.7) = (1 - \\Delta v) R_{u1} + \\Delta v R_{u2}$$\n$$R(10.3, 20.7) = (1 - 0.7) \\times 0.138 + 0.7 \\times 0.336$$\n$$R(10.3, 20.7) = 0.3 \\times 0.138 + 0.7 \\times 0.336$$\n$$R(10.3, 20.7) = 0.0414 + 0.2352 = 0.2766$$\n\n在 $(u,v)=(10.3, 20.7)$ 处双线性插值得到的反射率为 $0.2766$。该值有四位有效数字，符合题目要求。由于该过程的线性和可分离性，插值的顺序（先沿 $u$ 轴后沿 $v$ 轴，或先沿 $v$ 轴后沿 $u$ 轴）不影响最终结果。计算完成。",
            "answer": "$$\\boxed{0.2766}$$"
        }
    ]
}