{
    "hands_on_practices": [
        {
            "introduction": "理论知识的真正掌握始于实践。本节的第一个练习将引导我们从统计力学的第一性原理出发，推导多组分体系中理想构型熵的核心公式 $S_{\\text{ideal}} = -R \\sum_{i} x_i \\ln x_i$。这个练习  不仅是在重温一个经典的推导，更是为了建立一个基准模型，让我们能够量化比较不同成分（例如等摩尔比与非等摩尔比）的合金的无序程度，这对于理解高熵合金为何能稳定存在至关重要。",
            "id": "3734841",
            "problem": "一种高熵合金 (HEA) 被建模为一种替代型随机固溶体，其中有 $k$ 种不同的化学物种占据 $N$ 个等效晶格点位。其成分由摩尔分数 $\\{x_1, x_2, \\dots, x_k\\}$ 指定，且满足 $\\sum_{i=1}^{k} x_i = 1$。仅从玻尔兹曼熵关系式 $S = k_B \\ln \\Omega$（其中 $\\Omega$ 是与宏观成分一致的微观构型数）和适用于大整数的斯特林近似 $\\ln(n!) \\approx n \\ln n - n$ 出发，推导在固定 $\\{x_i\\}$ 条件下，多组分替代型固溶体的每摩尔理想构型熵 $S_{\\text{ideal}}$。\n\n然后，对于 $k = 8$ 的情况，评估以下两种成分的 $S_{\\text{ideal}}$：\n- 等摩尔比：对于所有 $i = 1, \\dots, 8$，$x_i = \\frac{1}{8}$。\n- 偏斜成分：$x_1 = 0.4$，且对于 $i = 2, \\dots, 8$，$x_i = \\frac{1 - 0.4}{7}$。\n\n使用摩尔气体常数 $R = N_A k_B$，其中 $R = 8.314462618\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。使用自然对数将最终的熵表示为 $\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$，并将您的数值答案四舍五入到四位有效数字。以有序对 $\\left(S_{\\text{ideal}}^{\\text{(equimolar)}},\\; S_{\\text{ideal}}^{\\text{(skewed)}}\\right)$ 的形式提供您的最终答案。",
            "solution": "该问题陈述经评估是有效的，因为它具有科学依据、问题明确、客观且自洽。它提出了一个应用于材料科学的统计热力学标准问题，并为得到唯一且有意义的解提供了所有必要信息。\n\n目标是推导多组分体系的每摩尔理想构型熵，然后将所得公式应用于两种特定的成分。\n\n该系统由 $N$ 个等效晶格点位组成，这些点位被 $k$ 种不同化学物种的原子占据。成分由摩尔分数 $\\{x_1, x_2, \\dots, x_k\\}$ 定义，其中 $\\sum_{i=1}^{k} x_i = 1$。物种 $i$ 的原子数为 $N_i = x_i N$，因此总原子数为 $\\sum_{i=1}^{k} N_i = \\sum_{i=1}^{k} x_i N = N \\sum_{i=1}^{k} x_i = N$。\n\n推导始于玻尔兹曼熵关系式 $S = k_B \\ln \\Omega$，其中 $k_B$ 是玻尔兹曼常数，$\\Omega$ 是对应于宏观状态的不同微观构型（微观态）的数量。对于随机替代型固溶体，$\\Omega$ 是将物种1的 $N_1$ 个原子、物种2的 $N_2$ 个原子、...、物种k的 $N_k$ 个原子排列在 $N$ 个可用晶格点位上的方式数量。这由多项式系数给出：\n$$\n\\Omega = \\frac{N!}{N_1! N_2! \\cdots N_k!} = \\frac{N!}{\\prod_{i=1}^{k} N_i!}\n$$\n将此代入玻尔兹曼关系式可得：\n$$\nS = k_B \\ln \\left( \\frac{N!}{\\prod_{i=1}^{k} N_i!} \\right)\n$$\n利用对数的性质，我们可以写出：\n$$\nS = k_B \\left( \\ln(N!) - \\ln\\left(\\prod_{i=1}^{k} N_i!\\right) \\right) = k_B \\left( \\ln(N!) - \\sum_{i=1}^{k} \\ln(N_i!) \\right)\n$$\n对于宏观系统，$N$ 和所有 $N_i$ 都是非常大的数。因此，我们可以对每个阶乘项应用斯特林近似 $\\ln(n!) \\approx n \\ln n - n$：\n$$\n\\ln(N!) \\approx N \\ln N - N\n$$\n$$\n\\ln(N_i!) \\approx N_i \\ln N_i - N_i\n$$\n将这些近似值代入 $S$ 的表达式中：\n$$\nS \\approx k_B \\left[ (N \\ln N - N) - \\sum_{i=1}^{k} (N_i \\ln N_i - N_i) \\right]\n$$\n$$\nS \\approx k_B \\left[ N \\ln N - N - \\sum_{i=1}^{k} N_i \\ln N_i + \\sum_{i=1}^{k} N_i \\right]\n$$\n由于 $\\sum_{i=1}^{k} N_i = N$，项 $-N$ 和 $+\\sum_{i=1}^{k} N_i$ 相互抵消：\n$$\nS \\approx k_B \\left[ N \\ln N - \\sum_{i=1}^{k} N_i \\ln N_i \\right]\n$$\n现在，我们代入 $N_i = x_i N$：\n$$\nS \\approx k_B \\left[ N \\ln N - \\sum_{i=1}^{k} (x_i N) \\ln(x_i N) \\right]\n$$\n利用对数性质 $\\ln(a b) = \\ln a + \\ln b$：\n$$\nS \\approx k_B \\left[ N \\ln N - \\sum_{i=1}^{k} (x_i N) (\\ln x_i + \\ln N) \\right]\n$$\n$$\nS \\approx k_B \\left[ N \\ln N - \\sum_{i=1}^{k} x_i N \\ln x_i - \\sum_{i=1}^{k} x_i N \\ln N \\right]\n$$\n我们可以从和式中提出因子 $N$ 和 $N \\ln N$：\n$$\nS \\approx k_B \\left[ N \\ln N - N \\sum_{i=1}^{k} x_i \\ln x_i - N \\ln N \\sum_{i=1}^{k} x_i \\right]\n$$\n利用约束条件 $\\sum_{i=1}^{k} x_i = 1$：\n$$\nS \\approx k_B \\left[ N \\ln N - N \\sum_{i=1}^{k} x_i \\ln x_i - N \\ln N \\cdot (1) \\right]\n$$\n项 $N \\ln N$ 和 $-N \\ln N$ 抵消，得到 $N$ 个原子的总构型熵：\n$$\nS = -N k_B \\sum_{i=1}^{k} x_i \\ln x_i\n$$\n为了求得每摩尔理想构型熵 $S_{\\text{ideal}}$，我们考虑一个包含一摩尔原子的系统，因此 $N = N_A$，其中 $N_A$ 是阿伏伽德罗常数。使用摩尔气体常数的定义 $R = N_A k_B$，我们得到最终表达式：\n$$\nS_{\\text{ideal}} = -R \\sum_{i=1}^{k} x_i \\ln x_i\n$$\n这就是所求的每摩尔理想构型熵的公式。\n\n现在，我们对于 $k=8$ 和 $R = 8.314462618\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$ 的两种给定情况计算 $S_{\\text{ideal}}$。\n\n情况1：等摩尔比成分\n成分为对于所有 $i = 1, \\dots, 8$，$x_i = \\frac{1}{8}$。\n$$\nS_{\\text{ideal}}^{\\text{(equimolar)}} = -R \\sum_{i=1}^{8} x_i \\ln x_i = -R \\sum_{i=1}^{8} \\frac{1}{8} \\ln\\left(\\frac{1}{8}\\right)\n$$\n由于求和中的所有项都相同，我们有：\n$$\nS_{\\text{ideal}}^{\\text{(equimolar)}} = -R \\cdot 8 \\cdot \\left(\\frac{1}{8} \\ln\\left(\\frac{1}{8}\\right)\\right) = -R \\ln\\left(\\frac{1}{8}\\right) = R \\ln(8)\n$$\n代入 $R$ 的值：\n$$\nS_{\\text{ideal}}^{\\text{(equimolar)}} = (8.314462618\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}) \\cdot \\ln(8) \\approx 17.29177\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}\n$$\n四舍五入到四位有效数字，我们得到 $S_{\\text{ideal}}^{\\text{(equimolar)}} = 17.29\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。\n\n情况2：偏斜成分\n成分为 $x_1 = 0.4$，且对于 $i = 2, \\dots, 8$，$x_i = \\frac{1 - 0.4}{7} = \\frac{0.6}{7}$。\n和式被分为两部分：一项是关于 $x_1$ 的，七项是关于 $x_2, \\dots, x_8$ 的相同项。\n$$\nS_{\\text{ideal}}^{\\text{(skewed)}} = -R \\left[ x_1 \\ln x_1 + \\sum_{i=2}^{8} x_i \\ln x_i \\right]\n$$\n$$\nS_{\\text{ideal}}^{\\text{(skewed)}} = -R \\left[ 0.4 \\ln(0.4) + 7 \\cdot \\left(\\frac{0.6}{7}\\right) \\ln\\left(\\frac{0.6}{7}\\right) \\right]\n$$\n$$\nS_{\\text{ideal}}^{\\text{(skewed)}} = -R \\left[ 0.4 \\ln(0.4) + 0.6 \\ln\\left(\\frac{0.6}{7}\\right) \\right]\n$$\n代入 $R$ 的值：\n$$\nS_{\\text{ideal}}^{\\text{(skewed)}} = -(8.314462618\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}) \\left[ 0.4 \\ln(0.4) + 0.6 \\ln\\left(\\frac{0.6}{7}\\right) \\right]\n$$\n计算括号内的各项：\n$0.4 \\ln(0.4) \\approx 0.4 \\times (-0.91629) \\approx -0.366516$\n$0.6 \\ln(\\frac{0.6}{7}) \\approx 0.6 \\times \\ln(0.085714) \\approx 0.6 \\times (-2.45666) \\approx -1.473996$\n将它们相加：$-0.366516 - 1.473996 \\approx -1.840512$。\n$$\nS_{\\text{ideal}}^{\\text{(skewed)}} \\approx -(8.314462618\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}) \\times (-1.840512) \\approx 15.30132\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}\n$$\n四舍五入到四位有效数字，我们得到 $S_{\\text{ideal}}^{\\text{(skewed)}} = 15.30\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。\n\n最终答案是有序对 $\\left(S_{\\text{ideal}}^{\\text{(equimolar)}},\\; S_{\\text{ideal}}^{\\text{(skewed)}}\\right)$，其值四舍五入到四位有效数字。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n17.29  15.30\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "经典的熵公式是在热力学极限 ($N \\to \\infty$) 的假设下得出的。然而，在纳米材料或计算机模拟等有限尺寸体系中，这个假设不再完全成立。这个练习  将挑战我们去探索这些边界效应，通过引入对斯特林公式的更高阶修正，推导出考虑了有限尺寸效应的熵密度表达式。通过这个过程，我们将更深刻地理解熵是如何依赖于系统尺寸的，以及简单的热力学公式在何种情况下会产生偏差。",
            "id": "3734844",
            "problem": "一种由$A$和$B$两种组分构成的替位二元合金占据了一个具有$N=10^{5}$个可分辨格点的刚性晶格。其组分固定为$x_{A}=0.01$和$x_{B}=1-x_{A}$。假设为理想随机混合，没有能量相互作用，唯一的约束是固定的组分（没有空位或间隙原子）。从熵的微正则定义$S=k_{B}\\ln\\Omega$出发，其中$k_{B}$是玻尔兹曼常数，$\\Omega$是符合组分约束的不同构型的数量，并使用对于$N_{A}=x_{A}N$个A原子和$N_{B}=x_{B}N$个B原子的构型的精确组合计数，推导出热力学极限下的构型熵密度$s=S/N$，并量化由有限$N$和较小的$x_{A}$引起的主导有限尺寸修正。计算当$N=10^{5}$和$x_{A}=0.01$时，修正后的熵密度$s_{\\text{corr}}/k_{B}$的值。\n\n你的推导必须从上述定义开始，使用适用于大数阶乘的渐近展开，并说明组分是如何影响熵密度的。在你的分析中，简要解释在小$x_{A}$值下，有限尺寸如何影响熵密度以及有限尺寸修正项的符号。将修正后的熵密度$s_{\\text{corr}}/k_{B}$的最终数值以无量纲数的形式报告，并将答案四舍五入到六位有效数字。",
            "solution": "该问题是有效的，因为它是统计力学中一个标准的、适定的问题，具有科学依据、客观且内部一致。\n\n系统是一个替位二元合金，位于具有$N$个格点的晶格上，包含$N_A$个A类原子和$N_B$个B类原子。总格点数为$N = N_A + N_B$。组分由摩尔分数给出：$x_A = N_A/N$和$x_B = N_B/N = 1-x_A$。\n\n将$N_A$个A类原子排列在$N$个格点上的不同构型数$\\Omega$由二项式系数给出：\n$$\n\\Omega = \\binom{N}{N_A} = \\frac{N!}{N_A! N_B!}\n$$\n微正则熵$S$定义为$S = k_B \\ln \\Omega$，其中$k_B$是玻尔兹曼常数。\n$$\nS = k_B \\ln\\left(\\frac{N!}{N_A! N_B!}\\right) = k_B (\\ln N! - \\ln N_A! - \\ln N_B!)\n$$\n为了对大量的原子进行计算，我们使用阶乘的渐近展开，通常称为斯特林近似。为了找到有限尺寸修正项，我们必须使用比领头阶近似更精确的形式。我们使用：\n$$\n\\ln n! \\approx n \\ln n - n + \\frac{1}{2}\\ln(2\\pi n) + O(1/n)\n$$\n将此代入熵的表达式中：\n$$\n\\frac{S}{k_B} \\approx \\left(N \\ln N - N + \\frac{1}{2}\\ln(2\\pi N)\\right) - \\left(N_A \\ln N_A - N_A + \\frac{1}{2}\\ln(2\\pi N_A)\\right) - \\left(N_B \\ln N_B - N_B + \\frac{1}{2}\\ln(2\\pi N_B)\\right)\n$$\n我们对这些项进行分组。关于粒子数呈线性的项是：\n$$\n(N \\ln N - N) - (N_A \\ln N_A - N_A) - (N_B \\ln N_B - N_B)\n$$\n由于$N = N_A + N_B$，线性项$-N$、$-(-N_A)$和$-(-N_B)$相互抵消。我们剩下：\n$$\nN \\ln N - N_A \\ln N_A - N_B \\ln N_B\n$$\n代入$N_A = x_A N$和$N_B = x_B N = (1-x_A)N$：\n$$\nN \\ln N - (x_A N) \\ln(x_A N) - (x_B N) \\ln(x_B N)\n$$\n$$\n= N \\ln N - x_A N (\\ln x_A + \\ln N) - x_B N (\\ln x_B + \\ln N)\n$$\n$$\n= N (\\ln N - x_A \\ln N - x_B \\ln N) - N(x_A \\ln x_A + x_B \\ln x_B)\n$$\n由于$x_A + x_B = 1$，第一个括号中的项变为$\\ln N - (x_A+x_B)\\ln N = \\ln N - \\ln N = 0$。这留下了对熵的主导贡献项：\n$$\nS_{\\text{thermo}} = -k_B N (x_A \\ln x_A + x_B \\ln x_B)\n$$\n在热力学极限下（$N \\to \\infty$），熵密度$s = S/N$为：\n$$\ns = \\frac{S_{\\text{thermo}}}{N} = -k_B (x_A \\ln x_A + x_B \\ln x_B)\n$$\n现在，我们分析来自斯特林展开的修正项，我们将其记为$\\Delta S$：\n$$\n\\frac{\\Delta S}{k_B} = \\frac{1}{2}\\ln(2\\pi N) - \\frac{1}{2}\\ln(2\\pi N_A) - \\frac{1}{2}\\ln(2\\pi N_B)\n$$\n$$\n= \\frac{1}{2} [\\ln(2\\pi N) - \\ln(2\\pi N_A) - \\ln(2\\pi N_B)]\n$$\n$$\n= \\frac{1}{2} \\ln\\left(\\frac{2\\pi N}{(2\\pi N_A)(2\\pi N_B)}\\right) = \\frac{1}{2} \\ln\\left(\\frac{N}{2\\pi N_A N_B}\\right)\n$$\n代入$N_A = x_A N$和$N_B = x_B N$：\n$$\n\\frac{\\Delta S}{k_B} = \\frac{1}{2} \\ln\\left(\\frac{N}{2\\pi (x_A N)(x_B N)}\\right) = \\frac{1}{2} \\ln\\left(\\frac{1}{2\\pi N x_A x_B}\\right) = -\\frac{1}{2} \\ln(2\\pi N x_A x_B)\n$$\n总的修正熵为$S_{\\text{corr}} = S_{\\text{thermo}} + \\Delta S$。修正后的熵密度$s_{\\text{corr}} = S_{\\text{corr}}/N$为：\n$$\ns_{\\text{corr}} = s + \\frac{\\Delta S}{N} = -k_B (x_A \\ln x_A + x_B \\ln x_B) - \\frac{k_B}{2N} \\ln(2\\pi N x_A x_B)\n$$\n无量纲的修正熵密度为：\n$$\n\\frac{s_{\\text{corr}}}{k_B} = -(x_A \\ln x_A + x_B \\ln x_B) - \\frac{1}{2N} \\ln(2\\pi N x_A (1-x_A))\n$$\n有限尺寸修正项为$\\Delta s/k_B = -\\frac{1}{2N}\\ln(2\\pi N x_A(1-x_A))$。其符号由对数的宗量决定。当二项式系数的高斯近似中平方根的宗量很大时，即$2\\pi N x_A(1-x_A) \\gg 1$，使用此修正才是有效的。给定$N=10^5$和$x_A=0.01$，该宗量为$2\\pi(10^5)(0.01)(0.99) = 1980\\pi \\approx 6220$，远大于 1。因此，其对数为正。所以整个修正项$\\Delta s$是负的。这个负号表明，有限系统的熵低于简单的热力学极限公式预测的值，该公式实际上高估了可用构型的数量。$x_A=0.01$的小值使合金处于一个低熵的组分区间，远离$x_A=0.5$时的最大值。有限尺寸修正的大小取决于$x_A(1-x_A)$，也比等摩尔组分时要小。\n\n我们现在为给定的参数计算修正后的熵密度：$N=10^5$和$x_A=0.01$。因此，$x_B = 1 - 0.01 = 0.99$。\n需要计算的表达式是：\n$$\n\\frac{s_{\\text{corr}}}{k_B} = -[0.01 \\ln(0.01) + 0.99 \\ln(0.99)] - \\frac{1}{2 \\times 10^5} \\ln(2\\pi \\times 10^5 \\times 0.01 \\times 0.99)\n$$\n首先，计算热力学项：\n$$\nT_1 = -[0.01 \\ln(0.01) + 0.99 \\ln(0.99)] \\approx -[0.01 \\times (-4.605170) + 0.99 \\times (-0.010050)]\n$$\n$$\nT_1 \\approx -[-0.0460517 - 0.0099495] = 0.0560012\n$$\n接下来，计算修正项：\n$$\nT_2 = -\\frac{1}{2 \\times 10^5} \\ln(1980\\pi) \\approx -\\frac{1}{2 \\times 10^5} \\ln(6220.353) \\approx -\\frac{8.735593}{2 \\times 10^5}\n$$\n$$\nT_2 \\approx -0.000043678\n$$\n以更高的精度将两项相加：\n$$\nT_1 \\approx 0.0560015344\n$$\n$$\nT_2 \\approx -0.0000436780\n$$\n$$\n\\frac{s_{\\text{corr}}}{k_B} = T_1 + T_2 \\approx 0.0560015344 - 0.0000436780 = 0.0559578564\n$$\n四舍五入到六位有效数字，我们得到$0.0559579$。",
            "answer": "$$\\boxed{0.0559579}$$"
        },
        {
            "introduction": "前面的练习都将合金的宏观组分视为固定值。现在，让我们转向一个更动态、也更接近真实物理情景的计算模型。在这个练习  中，我们将采用巨正则系综的视角，其中体系可以与粒子库交换粒子，导致宏观组分本身出现涨落。我们将通过编程来计算这些组分状态的概率分布 $P(\\{n_i\\})$，并进一步计算这个分布本身的信息熵 $S = -k_{\\text{B}} \\sum P \\ln P$。这不仅是一次宝贵的计算物理实践，更将深化我们对熵的理解，从描述单一宏观态的无序度，拓展到描述宏观态分布的广度。",
            "id": "3734828",
            "problem": "考虑一个与高熵合金（HEA）和复杂材料相关的多组分置换固溶体的晶格模型。该晶格有 $M$ 个位置，并且有 $K$ 种化学上不同的物种，标记为 $i \\in \\{1,2,\\dots,K\\}$。每个晶格位置恰好被一种物种占据，$n_i$ 表示被物种 $i$ 占据的位置数量，并满足约束条件 $\\sum_{i=1}^K n_i = M$。该系统与一个由化学势 $\\{\\mu_i\\}$ 和温度 $T$ 表征的热库接触。假设位置能量是等价的，并且除了物种身份之外的相互作用可以忽略不计，因此唯一的能量驱动项是化学势。\n\n从巨正则系综（GCE）和晶格占据的基本组合数学出发，推导允许向量 $\\{n_i\\}$ 上的组分分布 $P(\\{n_i\\})$，并用它来计算构型熵，其定义为 $S = - k_{\\mathrm{B}} \\sum_{\\{n_i\\}} P(\\{n_i\\}) \\ln P(\\{n_i\\})$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。您必须以 $k_{\\mathrm{B}}$ 为单位表示最终结果，即，将 $S/k_{\\mathrm{B}}$ 报告为无量纲实数。此问题不涉及角度。不涉及百分比。\n\n您的程序必须：\n- 枚举所有满足 $n_i \\ge 0$ 且 $\\sum_{i=1}^K n_i = M$ 的整数组合 $\\{n_i\\}$。\n- 使用与基本原理一致的巨正则系综权重，即概率与能量除以 $k_{\\mathrm{B}} T$ 的指数成正比，并结合给定组分的构型组合多重性。\n- 对所有组分精确地（在数值精度范围内）归一化分布 $P(\\{n_i\\})$。\n- 通过求和 $- \\sum_{\\{n_i\\}} P(\\{n_i\\}) \\ln P(\\{n_i\\})$ 来精确计算 $S/k_{\\mathrm{B}}$。\n\n使用单位为电子伏特每开尔文的玻尔兹曼常数，$k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\,\\mathrm{eV/K}$，以及单位为电子伏特（eV）的化学势 $\\mu_i$。温度 $T$ 的单位是开尔文（K）。参数 $M$ 是无量纲的。\n\n测试套件：\n针对以下情况计算 $S/k_{\\mathrm{B}}$。在所有情况中，均提供了 $M$、$K$、$\\{\\mu_i\\}$ 和 $T$，其中 $\\mu_i$ 的单位是电子伏特，T 的单位是开尔文。\n\n- 案例 1：$M = 5$，$K = 3$，$\\{\\mu_i\\} = \\{0.2, 0.0, -0.1\\}$，$T = 1000$。\n- 案例 2：$M = 4$，$K = 3$，$\\{\\mu_i\\} = \\{0.0, 0.0, 0.0\\}$，$T = 1000$。\n- 案例 3：$M = 6$，$K = 3$，$\\{\\mu_i\\} = \\{1.0, -1.0, -1.0\\}$，$T = 300$。\n- 案例 4：$M = 1$，$K = 4$，$\\{\\mu_i\\} = \\{0.0, 0.0, 0.0, 0.0\\}$，$T = 500$。\n- 案例 5：$M = 7$，$K = 5$，$\\{\\mu_i\\} = \\{-0.05, 0.1, 0.0, 0.2, -0.15\\}$，$T = 1200$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述案例的顺序列出。例如，输出应类似于 $[s_1,s_2,s_3,s_4,s_5]$，其中每个 $s_j$ 是为案例 $j$ 计算出的 $S/k_{\\mathrm{B}}$，以浮点数形式表示。",
            "solution": "该问题经评估是有效的。它在科学上基于应用于材料科学的统计力学原理，特别是使用了一个多组分合金的晶格模型。该问题提法恰当，为得到唯一且有意义的解提供了所有必要的参数和定义。方法论清晰明确，且测试案例在计算上是可行的。\n\n任务是计算多组分系统中组分分布的构型熵。该量被明确定义为 $S = - k_{\\mathrm{B}} \\sum_{\\{n_i\\}} P(\\{n_i\\}) \\ln P(\\{n_i\\})$，其中 $P(\\{n_i\\})$ 是发现在具有特定组分向量 $\\{n_i\\} = (n_1, n_2, \\dots, n_K)$ 的状态下系统的概率。该系统由 $M$ 个晶格位置组成，被 $K$ 种物种占据，总位置数固定为 $\\sum_{i=1}^K n_i = M$。系统的能量学由化学势 $\\{\\mu_i\\}$ 和温度 $T$ 决定。\n\n首先，我们推导概率分布 $P(\\{n_i\\})$。问题指导我们使用巨正则系综（GCE）框架。然而，总粒子数（或位置数）$M$ 是固定的。这种构型对应于一个半巨正则系综，其中粒子类型可以与热库交换，但总粒子数是守恒的。\n\n系统的哈密顿量被取为零，因为位置能量是等价的并且没有相互作用。在存在化学势热库的情况下，有效哈密顿量是 $H' = H - \\sum_{i=1}^K \\mu_i N_i = - \\sum_{i=1}^K \\mu_i N_i$，其中 $N_i$ 是物种 $i$ 的粒子数算符。\n\n配分函数 $Z$ 是对晶格所有可能的微观构型的求和。一个微观状态是将一个物种 $s_j \\in \\{1, \\dots, K\\}$ 指派给每个位置 $j \\in \\{1, \\dots, M\\}$ 的特定分配。\n$$ Z = \\sum_{\\text{microstates}} \\exp\\left( - \\frac{H'}{k_{\\mathrm{B}} T} \\right) = \\sum_{s_1=1}^K \\dots \\sum_{s_M=1}^K \\exp\\left( \\frac{\\sum_{j=1}^M \\mu_{s_j}}{k_{\\mathrm{B}} T} \\right) $$\n由于各个位置是独立的，我们可以将求和分开：\n$$ Z = \\prod_{j=1}^M \\left( \\sum_{s_j=1}^K \\exp\\left( \\frac{\\mu_{s_j}}{k_{\\mathrm{B}} T} \\right) \\right) = \\left( \\sum_{i=1}^K \\exp\\left( \\frac{\\mu_i}{k_{\\mathrm{B}} T} \\right) \\right)^M $$\n让我们定义单位置配分函数 $z = \\sum_{i=1}^K \\exp\\left(\\frac{\\mu_i}{k_{\\mathrm{B}} T}\\right)$。那么 $Z = z^M$。\n令 $p_i$ 为一个给定位置被物种 $i$ 占据的概率。这由该物种的玻尔兹曼权重除以单位置配分函数给出：\n$$ p_i = \\frac{\\exp\\left(\\frac{\\mu_i}{k_{\\mathrm{B}} T}\\right)}{z} = \\frac{\\exp\\left(\\frac{\\mu_i}{k_{\\mathrm{B}} T}\\right)}{\\sum_{k=1}^K \\exp\\left(\\frac{\\mu_k}{k_{\\mathrm{B}} T}\\right)} $$\n注意 $\\sum_{i=1}^K p_i = 1$。具有组分 $\\{n_i\\}$（即物种1有 $n_1$ 个粒子，物种2有 $n_2$ 个粒子，等等）的特定微观状态的概率是每个位置概率的乘积，因为这些位置是独立的：$\\prod_{i=1}^K p_i^{n_i}$。\n\n问题要求的是组分 $\\{n_i\\}$ 本身的概率，这是一个宏观状态。为求此概率，我们必须将具有该组分的一个微观状态的概率乘以在晶格上排列粒子以实现该组分的方式数量。这个组合因子是多项式系数，$\\Omega(\\{n_i\\}) = \\frac{M!}{n_1! n_2! \\dots n_K!}$。\n因此，组分的概率分布是多项分布：\n$$ P(\\{n_i\\}) = \\frac{M!}{\\prod_{i=1}^K n_i!} \\prod_{i=1}^K p_i^{n_i} $$\n其中 $\\{n_i\\}$ 是任何满足 $\\sum_{i=1}^K n_i = M$ 的非负整数向量。\n\n最后一步是计算问题中定义的构型熵，$S/k_{\\mathrm{B}} = - \\sum_{\\{n_i\\}} P(\\{n_i\\}) \\ln P(\\{n_i\\})$。求和遍历所有可能的组分向量 $\\{n_i\\}$。\n\n计算的算法如下：\n1.  对于每个测试案例，定义参数 $M$、$K$、$\\{\\mu_i\\}$ 和 $T$，以及 $k_{\\mathrm{B}}$ 的值。\n2.  生成所有满足 $n_i \\ge 0$ 和 $\\sum_{i=1}^K n_i = M$ 的唯一整数组合 $\\{n_i\\}$。递归函数非常适合这种组合枚举。\n3.  计算单位置概率 $\\{p_i\\}$。为确保数值稳定性，我们可以定义一组平移后的化学势 $\\mu'_i = \\mu_i - \\max(\\{\\mu_k\\})$。概率 $p_i$ 在此平移下是不变的：\n    $$ p_i = \\frac{\\exp\\left(\\frac{\\mu'_i}{k_{\\mathrm{B}} T}\\right)}{\\sum_{k=1}^K \\exp\\left(\\frac{\\mu'_k}{k_{\\mathrm{B}} T}\\right)} $$\n    这可以防止在计算指数时发生浮点溢出。\n4.  对于每个组分 $\\{n_i\\}$，计算其概率 $P(\\{n_i\\})$。为避免阶乘的溢出和概率乘积的下溢，最好先计算概率的对数：\n    $$ \\ln P(\\{n_i\\}) = \\ln(M!) - \\sum_{i=1}^K \\ln(n_i!) + \\sum_{i=1}^K n_i \\ln(p_i) $$\n    对数阶乘项 $\\ln(n!)$ 可以使用对数伽马函数 $\\ln(n!) = \\text{gammaln}(n+1)$ 来精确计算。从 $\\ln P(\\{n_i\\})$，我们可以求得 $P(\\{n_i\\}) = \\exp(\\ln P(\\{n_i\\}))$。\n5.  遍历所有组分，对每一个组分计算 $-P(\\{n_i\\}) \\ln(P(\\{n_i\\}))$ 项并将其加到一个累加和中。需要检查 $P(\\{n_i\\}) > 0$，因为在计算上，当 $P \\to 0$ 时，$P \\ln P \\to 0$。\n6.  最终的和即为所求的 $S/k_{\\mathrm{B}}$ 值。\n对于给定的参数范围，此过程是精确且稳健的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    k_B = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    test_cases = [\n        # Case 1: M = 5, K = 3, {mu_i} = {0.2, 0.0, -0.1}, T = 1000\n        {'M': 5, 'K': 3, 'mu': [0.2, 0.0, -0.1], 'T': 1000},\n        # Case 2: M = 4, K = 3, {mu_i} = {0.0, 0.0, 0.0}, T = 1000\n        {'M': 4, 'K': 3, 'mu': [0.0, 0.0, 0.0], 'T': 1000},\n        # Case 3: M = 6, K = 3, {mu_i} = {1.0, -1.0, -1.0}, T = 300\n        {'M': 6, 'K': 3, 'mu': [1.0, -1.0, -1.0], 'T': 300},\n        # Case 4: M = 1, K = 4, {mu_i} = {0.0, 0.0, 0.0, 0.0}, T = 500\n        {'M': 1, 'K': 4, 'mu': [0.0, 0.0, 0.0, 0.0], 'T': 500},\n        # Case 5: M = 7, K = 5, {mu_i} = {-0.05, 0.1, 0.0, 0.2, -0.15}, T = 1200\n        {'M': 7, 'K': 5, 'mu': [-0.05, 0.1, 0.0, 0.2, -0.15], 'T': 1200},\n    ]\n\n    def generate_compositions(m, k):\n        \"\"\"\n        Recursively generates all integer compositions of m into k parts.\n        A composition is a tuple (n_1, n_2, ..., n_k) such that sum(n_i) = m.\n        \"\"\"\n        if k == 1:\n            yield (m,)\n            return\n        for i in range(m + 1):\n            for comp in generate_compositions(m - i, k - 1):\n                yield (i,) + comp\n\n    def calculate_entropy(M, K, mu, T):\n        \"\"\"\n        Calculates the configurational entropy S/k_B for a given set of parameters.\n        \"\"\"\n        beta = 1.0 / (k_B * T)\n        mu_np = np.array(mu, dtype=np.float64)\n\n        # Numerically stable calculation of single-site probabilities p_i\n        mu_max = np.max(mu_np)\n        exp_terms = np.exp(beta * (mu_np - mu_max))\n        Z_site = np.sum(exp_terms)\n        p = exp_terms / Z_site\n        \n        # Handle cases where p_i can be zero to avoid log(0)\n        log_p = np.full_like(p, -np.inf)\n        non_zero_mask = p > 0\n        log_p[non_zero_mask] = np.log(p[non_zero_mask])\n\n        compositions = list(generate_compositions(M, K))\n        \n        total_entropy = 0.0\n        log_M_factorial = gammaln(M + 1)\n\n        for comp in compositions:\n            n = np.array(comp, dtype=np.int64)\n            \n            # Calculate log-probability of the composition\n            log_sum_n_factorial = np.sum(gammaln(n + 1))\n            log_p_terms = np.sum(n * log_p)\n            \n            log_P = log_M_factorial - log_sum_n_factorial + log_p_terms\n            \n            # Check for -inf which results from a_i * log(0) where a_i > 0\n            if log_P == -np.inf:\n                continue\n\n            P = np.exp(log_P)\n\n            # The term P * log(P) = 0 if P = 0.\n            if P > 0:\n                total_entropy -= P * log_P\n        \n        return total_entropy\n\n    results = []\n    for case in test_cases:\n        result = calculate_entropy(case['M'], case['K'], case['mu'], case['T'])\n        results.append(f\"{result:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}