{
    "hands_on_practices": [
        {
            "introduction": "用于材料设计的机器学习模型依赖于具有物理意义的“特征”或“描述符”。本实践聚焦于高熵合金最基本的描述符之一：原子尺寸错配度参数 $\\delta$。通过完成这个练习 ，您将把晶格应变的抽象概念与一个具体的、可计算的度量联系起来，并理解其在预测合金是否能形成稳定固溶体方面的热力学重要性，这对于构建和解释材料科学中的预测模型至关重要。",
            "id": "3747160",
            "problem": "在高熵合金（HEAs）和复杂浓缩合金的逆向设计中，固溶体形成倾向的一个关键机理描述符是成分加权的原子尺寸错配，它量化了替位无序如何扰动主晶格。从适用于小应变的线性弹性理论和成分加权平均半径的定义出发，构建一个无量纲的错配度量，该度量是成分加权相对半径偏差的均方根。以此度量作为一种有物理基础的特征，解释为什么在恒定温度下，增加错配会引入一个不断增大的弹性焓罚，该焓罚与构型熵相竞争，从而在机器学习分类器中，错配与单相固溶体形成的概率之间产生单调关系。\n\n然后，计算等原子比耐火高熵合金候选材料 $\\mathrm{Ti}$–$\\mathrm{Zr}$–$\\mathrm{Hf}$–$\\mathrm{Nb}$–$\\mathrm{Ta}$ 的错配度量。其金属半径（假设为十二配位）分别为 $r_{\\mathrm{Ti}}=147\\ \\text{pm}$，$r_{\\mathrm{Zr}}=160\\ \\text{pm}$，$r_{\\mathrm{Hf}}=159\\ \\text{pm}$，$r_{\\mathrm{Nb}}=146\\ \\text{pm}$ 和 $r_{\\mathrm{Ta}}=146\\ \\text{pm}$，每种元素的摩尔分数 $x_i=0.2$。将成分加权平均半径定义为 $\\bar r=\\sum_i x_i r_i$，物种 $i$ 的相对偏差定义为 $1-\\frac{r_i}{\\bar r}$，错配度量定义为这些偏差的成分加权均方的平方根。将最终值四舍五入到四位有效数字。以无量纲数的形式表示最终答案。",
            "solution": "目标是建立一个基于物理的描述符与固溶体形成之间的联系，然后为一个指定的等原子比合金计算该描述符。\n\n基础原理：\n1. 对于小弹性应变，线性弹性理论适用，弹性应变能密度与应变的平方成正比。对于均匀各向同性固体，弹性应变能密度可以写成应变的二次型，其系数为体积模量和剪切模量等弹性模量。当替位原子的半径与基体的平均半径不同时，它们会在晶格中引起局部的膨胀（体积）和剪切应变。\n2. 成分加权平均原子半径定义为 $\\bar r=\\sum_i x_i r_i$。与该平均值的偏差，经 $\\bar r$ 归一化后，定义了一个无量纲的错配应变，在小错配极限下，$\\epsilon_i\\approx \\frac{r_i-\\bar r}{\\bar r}=1-\\frac{r_i}{\\bar r}$。\n3. 由于弹性焓的贡献与应变呈二次方关系，因此，描述随机替位合金中总错配的一个自然标量描述符是这些归一化偏差的成分加权均方根：\n$$\n\\delta=\\sqrt{\\sum_i x_i\\left(1-\\frac{r_i}{\\bar r}\\right)^{2}}.\n$$\n这个 $\\delta$ 是无量纲的，它衡量了合金中典型的相对尺寸错配程度。\n\n为什么 $\\delta$ 与单相固溶体形成相关：\n- 每个原子的亥姆霍兹自由能可以示意性地看作 $F=H-T S$，其中 $H$ 包含由尺寸错配引起的弹性焓罚以及其他相互作用项，而 $S$ 包括构型熵。对于一个由 $n$ 种组元组成的随机替位合金，其摩尔分数为 $\\{x_i\\}$，每个原子的构型熵为 $S_{\\mathrm{conf}}= -k_{B}\\sum_i x_i \\ln x_i$，并且在固定成分下与原子半径 $\\{r_i\\}$ 无关。\n- 焓的弹性部分随错配应变的平方而增加，在粗粒度水平上，其大小与模量乘以 $\\sum_i x_i \\epsilon_i^{2}$ 成比例；因此，焓罚在 $\\delta^{2}$ 上是单调递增的。对于固定的 $T$ 和 $\\{x_i\\}$，较大的 $\\delta$ 会提高 $H$ 而不增加 $S_{\\mathrm{conf}}$，从而增加 $F$，使得单相随机固溶体相对于相分离或金属间化合物的形成变得不那么有利。\n- 因此，在使用基于物理特征的监督式机器学习分类器或概率模型时，预计 $\\delta$ 与单相固溶体形成概率之间存在单调负相关关系，而其他特征（例如，混合焓、电负性差异、价电子浓度）则提供额外的调制。在逆向设计中，在满足目标性能约束的条件下最小化 $\\delta$，可以减少弹性错配罚，并增加形成单相固溶体的可能性。\n\n计算给定HEA的 $\\delta$：\n- 给定五种元素等原子分数 $x_i=0.2$ 和金属半径\n$\nr_{\\mathrm{Ti}}=147\\ \\text{pm},\\quad\nr_{\\mathrm{Zr}}=160\\ \\text{pm},\\quad\nr_{\\mathrm{Hf}}=159\\ \\text{pm},\\quad\nr_{\\mathrm{Nb}}=146\\ \\text{pm},\\quad\nr_{\\mathrm{Ta}}=146\\ \\text{pm}.\n$\n首先计算平均半径：\n$$\n\\bar r=\\sum_i x_i r_i\n=0.2\\,(147+160+159+146+146)\\ \\text{pm}\n=0.2\\times 758\\ \\text{pm}\n=151.6\\ \\text{pm}.\n$$\n计算每种元素的归一化偏差 $1-\\frac{r_i}{\\bar r}$：\n$$\n1-\\frac{r_{\\mathrm{Ti}}}{\\bar r}=1-\\frac{147}{151.6}\\approx 1-0.9697=0.0303,\n$$\n$$\n1-\\frac{r_{\\mathrm{Zr}}}{\\bar r}=1-\\frac{160}{151.6}\\approx 1-1.0554=-0.0554,\n$$\n$$\n1-\\frac{r_{\\mathrm{Hf}}}{\\bar r}=1-\\frac{159}{151.6}\\approx 1-1.0488=-0.0488,\n$$\n$$\n1-\\frac{r_{\\mathrm{Nb}}}{\\bar r}=1-\\frac{146}{151.6}\\approx 1-0.9630=0.0370,\n$$\n$$\n1-\\frac{r_{\\mathrm{Ta}}}{\\bar r}=1-\\frac{146}{151.6}\\approx 1-0.9630=0.0370.\n$$\n构造成分加权均方并取其平方根：\n$$\n\\delta=\\sqrt{\\sum_i x_i\\left(1-\\frac{r_i}{\\bar r}\\right)^{2}}\n=\\sqrt{0.2\\left(0.0303^{2}+(-0.0554)^{2}+(-0.0488)^{2}+0.0370^{2}+0.0370^{2}\\right)}.\n$$\n计算内部各项：\n$$\n0.0303^{2}\\approx 9.18\\times 10^{-4},\\quad\n(-0.0554)^{2}\\approx 3.07\\times 10^{-3},\\quad\n(-0.0488)^{2}\\approx 2.38\\times 10^{-3},\\quad\n0.0370^{2}\\approx 1.37\\times 10^{-3}.\n$$\n求和：\n$$\n9.18\\times 10^{-4}+3.07\\times 10^{-3}+2.38\\times 10^{-3}+1.37\\times 10^{-3}+1.37\\times 10^{-3}\n\\approx 9.104\\times 10^{-3}.\n$$\n乘以 $0.2$：\n$$\n0.2\\times 9.104\\times 10^{-3}\\approx 1.8208\\times 10^{-3}.\n$$\n取平方根：\n$$\n\\delta\\approx \\sqrt{1.8208\\times 10^{-3}}\\approx 0.04267.\n$$\n四舍五入到四位有效数字并表示为无量纲数，该错配度量为 $0.04267$。根据上述能量论证，当在逆向设计的机器学习模型中与其他热力学和电子描述符一同考虑时，与具有更大错配的合金相比，这个相对较小的值与单相固溶体形成可能性增加是一致的。",
            "answer": "$$\\boxed{0.04267}$$"
        },
        {
            "introduction": "现实世界的材料设计很少只优化单一属性，而通常是在性能、稳定性和成本等相互竞争的目标之间寻求平衡。本实践将介绍一种强大的技术来应对这些权衡。这个练习  模拟了一个真实的逆向设计场景，您必须找到同时具有高强度、高稳定性和低成本的合金，您将实现多目标优化领域的核心算法 NSGA-II 的核心逻辑，以识别一组最优的“帕累托前沿”解。",
            "id": "3747209",
            "problem": "给你一个用于高熵合金（HEAs）的玩具逆向设计任务，该任务在带有代理机器学习模型的多目标优化背景下进行。考虑基于铁（Fe）、钴（Co）、镍（Ni）、铬（Cr）和锰（Mn）元素的等原子五元高熵合金的成分。一个成分是一个原子分数向量 $\\mathbf{x} = (x_1, x_2, x_3, x_4, x_5)$，其中 $x_i \\ge 0$ 且 $\\sum_{i=1}^{5} x_i = 1$。根据广泛使用的混合法则和固溶强化原理，定义三个待最小化的代理目标函数：\n\n- 目标 $g_1(\\mathbf{x}) = -\\sigma_y(\\mathbf{x})$，其中代理屈服强度 $\\sigma_y(\\mathbf{x})$（单位：兆帕）由以下模型计算\n$$\n\\sigma_y(\\mathbf{x}) = \\sigma_0 + k_{\\mathrm{ss}} \\sqrt{\\sum_{i=1}^{5} x_i \\left(\\frac{r_i - \\bar{r}}{\\bar{r}}\\right)^2} + k_E \\bar{E},\n$$\n其中 $\\bar{r} = \\sum_{i=1}^{5} x_i r_i$ 是平均金属半径（单位：埃），$\\bar{E} = \\sum_{i=1}^{5} x_i E_i$ 是混合法则杨氏模量（单位：吉帕），$\\sigma_0$ 是基准强度，$k_{\\mathrm{ss}}$ 是固溶强化系数，$k_E$ 是模量贡献系数。\n\n- 目标 $g_2(\\mathbf{x}) = -S_{\\mathrm{conf}}(\\mathbf{x})$，其中构型混合熵 $S_{\\mathrm{conf}}(\\mathbf{x})$（单位：焦耳/摩尔·开尔文）由经典公式给出\n$$\nS_{\\mathrm{conf}}(\\mathbf{x}) = - R \\sum_{i=1}^{5} x_i \\ln(x_i),\n$$\n其中 $R$ 是理想气体常数。当 $x = 0$ 时，将项 $x \\ln(x)$ 解释为 $0$（即 $x \\to 0^+$ 时的极限）。\n\n- 目标 $g_3(\\mathbf{x}) = \\sum_{i=1}^{5} x_i c_i$，即使用线性混合法则估算的成本（单位：美元/千克）。\n\n使用以下元素属性向量（所有条目均为常数，是常见数据的科学上合理的近似值）：\n$$\n\\mathbf{r} = (1.26, 1.25, 1.24, 1.28, 1.27) \\text{ 埃},\n$$\n$$\n\\mathbf{E} = (211, 210, 200, 279, 198) \\text{ 吉帕},\n$$\n$$\n\\mathbf{c} = (0.5, 40, 18, 10, 2.5) \\text{ 美元/千克},\n$$\n以及系数\n$$\n\\sigma_0 = 150 \\text{ 兆帕}, \\quad k_{\\mathrm{ss}} = 850 \\text{ 兆帕}, \\quad k_E = 0.5 \\text{ 兆帕/吉帕}, \\quad R = 8.314 \\text{ 焦耳/摩尔·开尔文}.\n$$\n\n你的任务是实现非支配排序遗传算法II（NSGA-II）的选择步骤，其中非支配排序遗传算法II（NSGA-II）使用非支配排序来产生帕累托前沿，并使用拥挤度距离来保持多样性。具体而言：\n\n- 在 $\\mathbf{g}(\\mathbf{x}) = (g_1(\\mathbf{x}), g_2(\\mathbf{x}), g_3(\\mathbf{x}))$ 上实现基于最小化的帕累托支配，其中候选解 $\\mathbf{x}^{(a)}$ 支配 $\\mathbf{x}^{(b)}$ 当且仅当对于所有目标 $m \\in \\{1,2,3\\}$ 都有 $g_m(\\mathbf{x}^{(a)}) \\le g_m(\\mathbf{x}^{(b)})$，并且至少存在一个目标 $m$ 使得 $g_m(\\mathbf{x}^{(a)})  g_m(\\mathbf{x}^{(b)})$。\n\n- 执行非支配排序，按等级将种群划分为前沿 $F_1, F_2, \\ldots$。第一个前沿 $F_1$ 包含所有非支配候选解，第二个前沿 $F_2$ 包含仅被 $F_1$ 中候选解支配的候选解，依此类推。\n\n- 在每个前沿内，根据目标值计算 NSGA-II 拥挤度距离，使用逐目标排序和归一化的最近邻差异。\n\n- 通过按等级递增的顺序选取完整的前沿来选择大小为 $K$ 的下一代，直到下一个前沿会超出 $K$。对于最后一个被部分包含的前沿，选择拥挤度距离最高的候选解（距离越大越优先）。通过递增的索引顺序来确定性地解决任何平局情况。\n\n最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔的测试用例结果列表。每个结果必须是所选候选解的从零开始的索引列表，并严格按照选择顺序排列。程序输出中不需要物理单位，角度也不适用。\n\n测试套件。对于每种情况，程序必须根据给定的成分计算目标，并应用 NSGA-II 选择来返回下一代的索引：\n\n- 情况 1：$N = 12$, $K = 6$，成分\n$\n\\begin{aligned}\n[0.2, 0.2, 0.2, 0.2, 0.2], [0.4, 0.1, 0.1, 0.2, 0.2], [0.1, 0.4, 0.2, 0.1, 0.2], [0.05, 0.05, 0.6, 0.15, 0.15],\\\\\n[0.3, 0.3, 0.1, 0.2, 0.1], [0.1, 0.2, 0.3, 0.1, 0.3], [0.25, 0.25, 0.25, 0.15, 0.10], [0.5, 0.2, 0.1, 0.1, 0.1],\\\\\n[0.1, 0.1, 0.1, 0.6, 0.1], [0.05, 0.5, 0.1, 0.15, 0.2], [0.05, 0.05, 0.05, 0.05, 0.8], [0.2, 0.1, 0.5, 0.1, 0.1]\n\\end{aligned}\n$.\n\n- 情况 2：$N = 8$, $K = 4$，成分\n$\n\\begin{aligned}\n[0.2, 0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2, 0.2], [0.1, 0.2, 0.3, 0.2, 0.2], [0.3, 0.2, 0.1, 0.2, 0.2],\\\\\n[0.01, 0.29, 0.3, 0.2, 0.2], [0.4, 0.1, 0.2, 0.1, 0.2], [0.45, 0.1, 0.15, 0.1, 0.2], [0.1, 0.1, 0.4, 0.2, 0.2]\n\\end{aligned}\n$.\n\n- 情况 3：$N = 10$, $K = 9$，成分\n$\n\\begin{aligned}\n[0.22, 0.18, 0.20, 0.20, 0.20], [0.18, 0.22, 0.20, 0.20, 0.20], [0.30, 0.10, 0.25, 0.20, 0.15], [0.10, 0.30, 0.25, 0.20, 0.15],\\\\\n[0.26, 0.24, 0.10, 0.20, 0.20], [0.12, 0.28, 0.20, 0.25, 0.15], [0.28, 0.12, 0.20, 0.25, 0.15], [0.05, 0.35, 0.30, 0.20, 0.10],\\\\\n[0.35, 0.05, 0.30, 0.20, 0.10], [0.20, 0.20, 0.20, 0.20, 0.20]\n\\end{aligned}\n$.\n\n- 情况 4：$N = 5$, $K = 5$，成分\n$\n\\begin{aligned}\n[0.24, 0.19, 0.19, 0.19, 0.19], [0.19, 0.24, 0.19, 0.19, 0.19], [0.19, 0.19, 0.24, 0.19, 0.19], [0.19, 0.19, 0.19, 0.24, 0.19],\\\\\n[0.20, 0.20, 0.20, 0.20, 0.20]\n\\end{aligned}\n$.\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[result_1, result_2, result_3, result_4]$），其中每个 $result_k$ 是案例 $k$ 中按精确的 NSGA-II 选择顺序列出的所选候选解的从零开始的索引列表。",
            "solution": "用户提供了一个关于材料科学中逆向设计任务的问题陈述，具体涉及高熵合金（HEA）。该问题已经过验证，被认为是科学上可靠、适定、客观和完整的。它提出了一个简化但概念上合理的合金属性物理模型，并要求实现一个标准且定义明确的多目标优化算法——非支配排序遗传算法II（NSGA-II）。所提供的数据和常数在物理上是合理的，在数学上是一致的。因此，有必要提供一个完整的解决方案。\n\n解决方案的结构如下：首先，我们将根据所提供的物理模型来形式化目标函数。其次，我们将描述 NSGA-II 选择过程的实现，该过程涉及三个关键步骤：非支配排序、拥挤度距离计算和精英选择。\n\n**1. 目标函数**\n\n问题定义了三个待最小化的目标函数 $g_1$、$g_2$ 和 $g_3$，用于给定的合金成分向量 $\\mathbf{x} = (x_1, x_2, x_3, x_4, x_5)$，其中 $x_i$ 是一个5元素系统中元素 $i$ 的原子分数。这些元素分别为铁（Fe）、钴（Co）、镍（Ni）、铬（Cr）和锰（Mn），索引从1到5。\n\n所需的物理常数是：\n- 原子半径：$\\mathbf{r} = (1.26, 1.25, 1.24, 1.28, 1.27)$ 埃\n- 杨氏模量：$\\mathbf{E} = (211, 210, 200, 279, 198)$ 吉帕\n- 成本向量：$\\mathbf{c} = (0.5, 40, 18, 10, 2.5)$ 美元/千克\n- 模型系数：$\\sigma_0 = 150$ 兆帕, $k_{\\mathrm{ss}} = 850$ 兆帕, $k_E = 0.5$ 兆帕/吉帕, 以及理想气体常数 $R = 8.314$ 焦耳/(摩尔·开尔文)。\n\n- **目标 $g_1(\\mathbf{x})$：屈服强度**\n此目标旨在最大化屈服强度 $\\sigma_y$，这等同于最小化其负值 $g_1(\\mathbf{x}) = -\\sigma_y(\\mathbf{x})$。屈服强度的代理模型由下式给出：\n$$\n\\sigma_y(\\mathbf{x}) = \\sigma_0 + k_{\\mathrm{ss}} \\sqrt{\\sum_{i=1}^{5} x_i \\left(\\frac{r_i - \\bar{r}}{\\bar{r}}\\right)^2} + k_E \\bar{E}\n$$\n该模型包含一个基准强度 $\\sigma_0$，一个与原子尺寸错配成正比的固溶强化项（平方根下的项），以及一个反映平均合金刚度 $\\bar{E}$ 贡献的项。平均属性使用线性混合法则计算：\n- 平均原子半径：$\\bar{r} = \\sum_{i=1}^{5} x_i r_i$\n- 平均杨氏模量：$\\bar{E} = \\sum_{i=1}^{5} x_i E_i$\n\n- **目标 $g_2(\\mathbf{x})$：构型熵**\n此目标旨在最大化构型混合熵 $S_{\\mathrm{conf}}$，这等同于最小化 $g_2(\\mathbf{x}) = -S_{\\mathrm{conf}}(\\mathbf{x})$。高构型熵是高熵合金的一个决定性特征，能促进稳定单相固溶体的形成。熵由理想混合物的玻尔兹曼公式给出：\n$$\nS_{\\mathrm{conf}}(\\mathbf{x}) = - R \\sum_{i=1}^{5} x_i \\ln(x_i)\n$$\n因此，待最小化的目标函数是：\n$$\ng_2(\\mathbf{x}) = - \\left(- R \\sum_{i=1}^{5} x_i \\ln(x_i) \\right) = R \\sum_{i=1}^{5} x_i \\ln(x_i)\n$$\n问题指定，对于任何 $x_i = 0$，项 $x_i \\ln(x_i)$ 被视为 $0$，这与极限 $\\lim_{x \\to 0^+} x \\ln(x) = 0$ 一致。\n\n- **目标 $g_3(\\mathbf{x})$：材料成本**\n此目标旨在最小化材料成本，通过基于原子分数的线性混合法则估算：\n$$\ng_3(\\mathbf{x}) = \\sum_{i=1}^{5} x_i c_i\n$$\n\n**2. NSGA-II 选择算法**\n\n任务的核心是实现 NSGA-II 的选择机制。给定一个包含 $N$ 个候选成分的种群，目标是选择 $K$ 个最有希望的候选解来形成下一代。这个过程是确定性的，并包括以下步骤。\n\n**2.1. 非支配排序**\n首先，整个种群被划分为一组基于帕累托支配的“前沿”（$F_1, F_2, \\dots$）。对于一个最小化问题，如果一个解 $\\mathbf{x}^{(a)}$ 在所有目标上都优于或等于另一个解 $\\mathbf{x}^{(b)}$，并且至少在一个目标上严格优于它，则称解 $\\mathbf{x}^{(a)}$ 支配解 $\\mathbf{x}^{(b)}$。形式上：\n$$\n\\mathbf{x}^{(a)} \\text{ 支配 } \\mathbf{x}^{(b)} \\iff \\forall m \\in \\{1,2,3\\}, g_m(\\mathbf{x}^{(a)}) \\le g_m(\\mathbf{x}^{(b)}) \\land \\exists m' \\in \\{1,2,3\\}, g_m(\\mathbf{x}^{(a)})  g_m(\\mathbf{x}^{(b)})\n$$\n排序算法过程如下：\n1.  对于每个个体 $p$，计算两个值：$n_p$，即支配 $p$ 的个体数量，以及 $S_p$，即 $p$ 所支配的个体集合。\n2.  第一个前沿 $F_1$ 由所有 $n_p = 0$ 的个体组成。这些是整个种群中的非支配解。\n3.  为了找到第二个前沿 $F_2$，我们访问 $F_1$ 中的每个个体 $p$。对于 $S_p$ 中的每个个体 $q$，我们将其被支配计数 $n_q$ 减一。如果 $n_q$ 变为 $0$，则将 $q$ 添加到第二个前沿 $F_2$ 中。\n4.  这个过程迭代重复，生成前沿 $F_3, F_4, \\dots$，直到所有个体都被分配到一个前沿。每个个体被赋予一个等于其所在前沿编号的等级（例如，对于 $p \\in F_1$，等级为 $1$）。\n\n**2.2. 拥挤度距离计算**\n在每个前沿内，为每个个体计算一个拥挤度距离。这个度量标准估计了目标空间中围绕该个体的解的密度。目标是优先选择位于较稀疏区域的个体，以保持种群的多样性。对于给定的前沿 $F$，计算方法是：\n1.  将 $F$ 中所有个体的距离初始化为 $0$。设前沿的大小为 $L = |F|$。\n2.  对于每个目标 $m \\in \\{1,2,3\\}$：\n    a. 根据个体在目标 $g_m$ 上的值对 $F$ 中的个体进行排序。\n    b. 为两个边界个体（即目标值最小和最大的个体）分配无限大的拥挤度距离。这确保了它们总是被保留下来。\n    c. 对于排序列表中的每个内部个体 $j$，更新其距离：\n       $$\n       d_j \\leftarrow d_j + \\frac{g_m(\\text{个体 } j+1) - g_m(\\text{个体 } j-1)}{g_m^{\\text{max}} - g_m^{\\text{min}}}\n       $$\n       其中 $g_m^{\\text{max}}$ 和 $g_m^{\\text{min}}$ 是前沿 $F$ 内目标 $m$ 的最大值和最小值。如果 $g_m^{\\text{max}} = g_m^{\\text{min}}$，则此项的贡献为 $0$。\n个体的总拥挤度距离是所有目标上这些归一化距离的总和。\n\n**2.3. 精英选择**\n最后一步是构建大小为 $K$ 的下一代。\n1.  按等级顺序（$F_1$，然后是 $F_2$ 等）逐个前沿地选择个体。\n2.  将完整的前沿添加到下一代中，直到添加下一个前沿会超过期望的种群大小 $K$。假设前沿 $F_1, \\dots, F_{i-1}$ 已被添加，且当前下一代的大小为 $K_{\\text{current}}  K$。\n3.  如果 $K_{\\text{current}} + |F_i| > K$，则前沿 $F_i$ 必须被部分包含。这个前沿 $F_i$ 内的个体按其拥挤度距离的降序排序。为确保确定性的结果，拥挤度距离的任何平局都通过选择在输入种群中具有较小原始索引的个体来打破。\n4.  从排序后的前沿 $F_i$ 中选取前 $K - K_{\\text{current}}$ 个个体，以补全下一代。\n5.  为满足问题“按精确选择顺序”输出索引的要求，来自完全包含的前沿的个体按其原始索引排序后添加，随后是来自部分包含的前沿的个体，按上述拥挤度距离和索引排序。\n这个过程保证了排名最高的解（精英主义）被传递下去，并且在相同等级的解中，多样性得到了促进。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the NSGA-II selection problem for the given test cases.\n    \"\"\"\n    # Define physical and model constants\n    R_CONST = 8.314  # J/(mol·K)\n    SIGMA_0 = 150.0  # MPa\n    K_SS = 850.0  # MPa\n    K_E = 0.5  # MPa/GPa\n    \n    # Element properties (Fe, Co, Ni, Cr, Mn)\n    r_vec = np.array([1.26, 1.25, 1.24, 1.28, 1.27])  # Angstroms\n    E_vec = np.array([211.0, 210.0, 200.0, 279.0, 198.0])  # GPa\n    c_vec = np.array([0.5, 40.0, 18.0, 10.0, 2.5])  # $/kg\n\n    # Test case definitions\n    test_cases = [\n        {\"K\": 6, \"compositions\": np.array([\n            [0.2, 0.2, 0.2, 0.2, 0.2], [0.4, 0.1, 0.1, 0.2, 0.2], [0.1, 0.4, 0.2, 0.1, 0.2],\n            [0.05, 0.05, 0.6, 0.15, 0.15], [0.3, 0.3, 0.1, 0.2, 0.1], [0.1, 0.2, 0.3, 0.1, 0.3],\n            [0.25, 0.25, 0.25, 0.15, 0.10], [0.5, 0.2, 0.1, 0.1, 0.1], [0.1, 0.1, 0.1, 0.6, 0.1],\n            [0.05, 0.5, 0.1, 0.15, 0.2], [0.05, 0.05, 0.05, 0.05, 0.8], [0.2, 0.1, 0.5, 0.1, 0.1]\n        ])},\n        {\"K\": 4, \"compositions\": np.array([\n            [0.2, 0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2, 0.2], [0.1, 0.2, 0.3, 0.2, 0.2],\n            [0.3, 0.2, 0.1, 0.2, 0.2], [0.01, 0.29, 0.3, 0.2, 0.2], [0.4, 0.1, 0.2, 0.1, 0.2],\n            [0.45, 0.1, 0.15, 0.1, 0.2], [0.1, 0.1, 0.4, 0.2, 0.2]\n        ])},\n        {\"K\": 9, \"compositions\": np.array([\n            [0.22, 0.18, 0.20, 0.20, 0.20], [0.18, 0.22, 0.20, 0.20, 0.20], [0.30, 0.10, 0.25, 0.20, 0.15],\n            [0.10, 0.30, 0.25, 0.20, 0.15], [0.26, 0.24, 0.10, 0.20, 0.20], [0.12, 0.28, 0.20, 0.25, 0.15],\n            [0.28, 0.12, 0.20, 0.25, 0.15], [0.05, 0.35, 0.30, 0.20, 0.10], [0.35, 0.05, 0.30, 0.20, 0.10],\n            [0.20, 0.20, 0.20, 0.20, 0.20]\n        ])},\n        {\"K\": 5, \"compositions\": np.array([\n            [0.24, 0.19, 0.19, 0.19, 0.19], [0.19, 0.24, 0.19, 0.19, 0.19], [0.19, 0.19, 0.24, 0.19, 0.19],\n            [0.19, 0.19, 0.19, 0.24, 0.19], [0.20, 0.20, 0.20, 0.20, 0.20]\n        ])}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        K = case[\"K\"]\n        population = case[\"compositions\"]\n        N = population.shape[0]\n\n        # --- 1. Calculate Objectives for all individuals ---\n        objectives = np.zeros((N, 3))\n        for i, x in enumerate(population):\n            # Objective g1: -Yield Strength\n            r_bar = np.sum(x * r_vec)\n            E_bar = np.sum(x * E_vec)\n            # handle r_bar = 0 case\n            if r_bar == 0:\n                delta_sq_sum = 0\n            else:\n                size_mismatch_sq = ((r_vec - r_bar) / r_bar)**2\n                delta_sq_sum = np.sum(x * size_mismatch_sq)\n            sigma_y = SIGMA_0 + K_SS * np.sqrt(delta_sq_sum) + K_E * E_bar\n            g1 = -sigma_y\n            \n            # Objective g2: -Configurational Entropy\n            # Using np.where to handle x_i = 0 case\n            x_log_x = np.where(x > 0, x * np.log(x), 0)\n            g2 = R_CONST * np.sum(x_log_x)\n            \n            # Objective g3: Cost\n            g3 = np.sum(x * c_vec)\n            \n            objectives[i] = [g1, g2, g3]\n\n        # --- 2. Nondominated Sorting ---\n        dominates = [[] for _ in range(N)]\n        dominated_by_count = np.zeros(N, dtype=int)\n        \n        for p in range(N):\n            for q in range(p + 1, N):\n                obj_p = objectives[p]\n                obj_q = objectives[q]\n                \n                p_dominates_q = np.all(obj_p = obj_q) and np.any(obj_p  obj_q)\n                q_dominates_p = np.all(obj_q = obj_p) and np.any(obj_q  obj_p)\n                \n                if p_dominates_q:\n                    dominates[p].append(q)\n                    dominated_by_count[q] += 1\n                elif q_dominates_p:\n                    dominates[q].append(p)\n                    dominated_by_count[p] += 1\n        \n        fronts = []\n        current_front = list(np.where(dominated_by_count == 0)[0])\n        while current_front:\n            fronts.append(current_front)\n            next_front = []\n            for p in current_front:\n                for q in dominates[p]:\n                    dominated_by_count[q] -= 1\n                    if dominated_by_count[q] == 0:\n                        next_front.append(q)\n            current_front = sorted(next_front) # Sort for determinism\n\n        # --- 3. Crowding Distance Calculation and Selection ---\n        next_gen_indices = []\n        front_num = 0\n        \n        while front_num  len(fronts) and len(next_gen_indices) + len(fronts[front_num]) = K:\n            # Add full front, sorted by original index for deterministic order\n            next_gen_indices.extend(sorted(fronts[front_num]))\n            front_num += 1\n\n        if len(next_gen_indices)  K:\n            last_front_indices = fronts[front_num]\n            num_remaining = K - len(next_gen_indices)\n            \n            # Crowding distance assignment for the last front\n            num_individuals_in_front = len(last_front_indices)\n            crowding_distances = {idx: 0.0 for idx in last_front_indices}\n\n            for m in range(objectives.shape[1]):\n                # Sort by objective m, then index to break ties\n                sorted_front = sorted(last_front_indices, key=lambda idx: (objectives[idx, m], idx))\n                \n                obj_min = objectives[sorted_front[0], m]\n                obj_max = objectives[sorted_front[-1], m]\n                obj_range = obj_max - obj_min\n\n                crowding_distances[sorted_front[0]] = np.inf\n                crowding_distances[sorted_front[-1]] = np.inf\n\n                if obj_range > 0:\n                    for i in range(1, num_individuals_in_front - 1):\n                        prev_idx = sorted_front[i-1]\n                        next_idx = sorted_front[i+1]\n                        numerator = objectives[next_idx, m] - objectives[prev_idx, m]\n                        crowding_distances[sorted_front[i]] += numerator / obj_range\n\n            # Sort the last front by crowding distance (desc) and index (asc)\n            sorted_last_front = sorted(last_front_indices, key=lambda idx: (-crowding_distances[idx], idx))\n            \n            next_gen_indices.extend(sorted_last_front[:num_remaining])\n        \n        all_results.append(next_gen_indices)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "机器学习或优化算法的输出并不总能保证其物理上或实践上有效，例如，模型可能会预测出含有负摩尔分数的成分。这最后一个实践处理了确保我们设计的材料符合现实的关键步骤。在这个问题中 ，您将学习如何形式化地表达真实世界的设计约束（如资源限制或禁用元素），并应用数学投影来修正不可行的候选成分，从而确保逆向设计流程的最终输出是一个可行的材料配方。",
            "id": "3747194",
            "problem": "在使用机器学习（ML）进行高熵合金（HEA）的逆向设计时，模型提出的一个成分向量可能会违反成分可行性和策略约束。考虑一种含有 $N=5$ 种候选元素 $\\{\\text{Fe}, \\text{Ni}, \\text{Cr}, \\text{Mn}, \\text{Pb}\\}$ 的合金，并设 $\\mathbf{x} \\in \\mathbb{R}^{5}$ 表示其摩尔分数向量。其物理上可行的成分空间是 $(N-1)$-单纯形 $\\Delta^{N-1} = \\{\\mathbf{x} \\in \\mathbb{R}^{N} \\mid x_{i} \\geq 0 \\text{ for all } i, \\sum_{i=1}^{N} x_{i} = 1\\}$。除可行性外，假设一个设计任务还必须包含以下线性策略：\n\n- 资源限制：镍和铬的总含量必须满足 $x_{\\text{Ni}} + x_{\\text{Cr}} \\leq 0.60$。\n- 禁用元素：禁止使用铅，即 $x_{\\text{Pb}} = 0$。\n- 法规限制：镍含量必须满足 $x_{\\text{Ni}} \\leq 0.35$。\n\n某次无约束的机器学习预测输出了一个不可行向量 $\\mathbf{y} = (0.60, 0.40, 0.30, 0.20, -0.20)$，其分量对应于 $(x_{\\text{Fe}}, x_{\\text{Ni}}, x_{\\text{Cr}}, x_{\\text{Mn}}, x_{\\text{Pb}})$。\n\n任务：\n\n1. 仅使用线性约束的基本定义，写出完整的线性不等式约束 $A\\mathbf{x} \\leq \\mathbf{b}$ 和等式约束 $E\\mathbf{x} = \\mathbf{d}$，用以编码该5组分体系的非负性、单纯形求和规则、资源限制、禁用元素和法规限制。明确给出矩阵 $A$ 和 $E$ 以及向量 $\\mathbf{b}$ 和 $\\mathbf{d}$。\n\n2. 从欧几里得投影的基本原理出发，推导向量 $\\mathbf{y}$ 在单纯形 $\\Delta^{4}$ 上的欧几里得投影，并以精确有理数的形式给出投影后的成分向量 $\\mathbf{x}^{\\star}$。最终答案必须使用 $\\texttt{pmatrix}$ 环境以单行矩阵的形式给出。无需四舍五入，也无需报告物理单位。",
            "solution": "该问题提出了两项任务。第一项任务是将一个5组分合金成分的一系列物理和策略约束形式化为标准线性代数形式。第二项任务是将一个给定的不可行成分向量投影到标准单纯形上。问题陈述具有科学依据、问题适定，并且所有提供的信息都是自洽和一致的。\n\n设成分向量为 $\\mathbf{x} = \\begin{pmatrix} x_1  x_2  x_3  x_4  x_5 \\end{pmatrix}^T$，其中各分量分别对应于 $\\{\\text{Fe}, \\text{Ni}, \\text{Cr}, \\text{Mn}, \\text{Pb}\\}$ 的摩尔分数。即，$x_1 = x_{\\text{Fe}}$，$x_2 = x_{\\text{Ni}}$，$x_3 = x_{\\text{Cr}}$，$x_4 = x_{\\text{Mn}}$，以及 $x_5 = x_{\\text{Pb}}$。\n\n**任务1：约束的形式化**\n\n我们需要将完整的约束集合表示为 $A\\mathbf{x} \\leq \\mathbf{b}$ 和 $E\\mathbf{x} = \\mathbf{d}$ 的形式。\n\n这些约束是：\n1.  **非负性：** 每种元素的摩尔分数必须为非负。对每个组分 $i \\in \\{1, 2, 3, 4, 5\\}$，我们有 $x_i \\geq 0$。这等价于 $-x_i \\leq 0$。这五个不等式构成了矩阵 $A$ 的前五行。\n2.  **单纯形求和规则：** 摩尔分数之和必须为1：$\\sum_{i=1}^{5} x_i = 1$。这是一个等式约束，将构成矩阵 $E$ 的一行。\n3.  **资源限制：** 镍和铬的总含量不得超过 $0.60$：$x_{\\text{Ni}} + x_{\\text{Cr}} \\leq 0.60$，即 $x_2 + x_3 \\leq 0.60$。这是一个不等式约束。\n4.  **禁用元素：** 铅被禁用，因此其摩尔分数必须为零：$x_{\\text{Pb}} = 0$，即 $x_5 = 0$。这是一个等式约束。\n5.  **法规限制：** 镍含量不得超过 $0.35$：$x_{\\text{Ni}} \\leq 0.35$，即 $x_2 \\leq 0.35$。这是另一个不等式约束。\n\n现在我们可以构建这些矩阵和向量。\n\n对于等式约束 $E\\mathbf{x} = \\mathbf{d}$：\n我们有两个等式约束：\n- $x_1 + x_2 + x_3 + x_4 + x_5 = 1$\n- $x_5 = 0$\n这些可以写成矩阵形式：\n$$\n\\begin{pmatrix}\n1  1  1  1  1 \\\\\n0  0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ x_5 \\end{pmatrix}\n=\n\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\n因此，矩阵 $E$ 和向量 $\\mathbf{d}$ 为：\n$$E = \\begin{pmatrix}\n1  1  1  1  1 \\\\\n0  0  0  0  1\n\\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$$\n\n对于不等式约束 $A\\mathbf{x} \\leq \\mathbf{b}$：\n我们有七个不等式约束：\n- $-x_1 \\leq 0$\n- $-x_2 \\leq 0$\n- $-x_3 \\leq 0$\n- $-x_4 \\leq 0$\n- $-x_5 \\leq 0$\n- $x_2 + x_3 \\leq 0.60$\n- $x_2 \\leq 0.35$\n这些可以写成矩阵形式：\n$$\n\\begin{pmatrix}\n-1  0  0  0  0 \\\\\n0  -1  0  0  0 \\\\\n0  0  -1  0  0 \\\\\n0  0  0  -1  0 \\\\\n0  0  0  0  -1 \\\\\n0  1  1  0  0 \\\\\n0  1  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ x_5 \\end{pmatrix}\n\\leq\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0.60 \\\\ 0.35 \\end{pmatrix}\n$$\n因此，矩阵 $A$ 和向量 $\\mathbf{b}$ 为：\n$$A = \\begin{pmatrix}\n-1  0  0  0  0 \\\\\n0  -1  0  0  0 \\\\\n0  0  -1  0  0 \\\\\n0  0  0  -1  0 \\\\\n0  0  0  0  -1 \\\\\n0  1  1  0  0 \\\\\n0  1  0  0  0\n\\end{pmatrix}, \\quad \\mathbf{b} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0.60 \\\\ 0.35 \\end{pmatrix}$$\n\n**任务2：到单纯形上的欧几里得投影**\n\n我们需要找到向量 $\\mathbf{y} = (0.60, 0.40, 0.30, 0.20, -0.20)$ 到标准 $(N-1)$-单纯形 $\\Delta^{4} = \\{\\mathbf{x} \\in \\mathbb{R}^{5} \\mid x_{i} \\geq 0 \\text{ for all } i, \\sum_{i=1}^{5} x_{i} = 1\\}$ 上的欧几里得投影。这个投影记为 $\\mathbf{x}^{\\star}$，是以下约束优化问题的解：\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  \\frac{1}{2} ||\\mathbf{x} - \\mathbf{y}||_2^2 \\\\\n\\text{subject to} \\quad  \\sum_{i=1}^{5} x_i = 1 \\\\\n x_i \\geq 0 \\quad \\text{for } i=1, \\dots, 5\n\\end{aligned}\n$$\n这是一个凸优化问题，我们可以使用 Karush-Kuhn-Tucker (KKT) 条件来求解。该问题的拉格朗日函数是：\n$$ L(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}) = \\frac{1}{2} \\sum_{i=1}^{5} (x_i - y_i)^2 + \\lambda \\left(\\sum_{i=1}^{5} x_i - 1\\right) - \\sum_{i=1}^{5} \\mu_i x_i $$\n其中 $\\lambda$ 是等式约束的拉格朗日乘子，$\\mu_i$ 是非负性约束 $x_i \\geq 0$ 的乘子。\n\nKKT 条件如下：\n1.  平稳性 (Stationarity)：$\\frac{\\partial L}{\\partial x_i} = x_i - y_i + \\lambda - \\mu_i = 0$，对于 $i=1, \\dots, 5$。\n2.  原始可行性 (Primal feasibility)：$\\sum_{i=1}^{5} x_i = 1$ 且 $x_i \\geq 0$。\n3.  对偶可行性 (Dual feasibility)：$\\mu_i \\geq 0$。\n4.  互补松弛性 (Complementary slackness)：$\\mu_i x_i = 0$。\n\n根据平稳性条件，我们有 $x_i = y_i - \\lambda + \\mu_i$。\n根据互补松弛性，对于每个 $i$：\n- 如果 $x_i > 0$，则 $\\mu_i = 0$。将此代入平稳性方程得到 $x_i = y_i - \\lambda$。为使 $x_i > 0$，必须有 $y_i - \\lambda > 0$，即 $y_i > \\lambda$。\n- 如果 $x_i = 0$，则 $\\mu_i \\geq 0$。平稳性条件给出 $\\mu_i = \\lambda - y_i$。为使 $\\mu_i \\geq 0$，必须有 $\\lambda - y_i \\geq 0$，即 $y_i \\leq \\lambda$。\n\n综合这两种情况，$x_i$ 的解可以简洁地表示为：\n$$ x_i = \\max(0, y_i - \\lambda) = (y_i - \\lambda)_+ $$\n$\\lambda$ 的值可以通过将此表达式代入求和约束来确定：\n$$ \\sum_{i=1}^{5} (y_i - \\lambda)_+ = 1 $$\n该方程对于 $\\lambda$ 有唯一解，因为方程左侧是关于 $\\lambda$ 的一个连续且严格单调递减的函数。一个找到 $\\lambda$ 的高效方法是将 $\\mathbf{y}$ 的分量按降序排序，即 $y_{(1)} \\geq y_{(2)} \\geq \\dots \\geq y_{(5)}$，然后找到一个整数 $\\rho \\in \\{1, \\dots, 5\\}$ 使得\n$$ \\lambda = \\frac{1}{\\rho}\\left(\\sum_{j=1}^{\\rho} y_{(j)} - 1\\right) $$\n并且这个 $\\lambda$ 满足 $y_{(\\rho)} > \\lambda \\geq y_{(\\rho+1)}$（按照惯例，取 $y_{(6)}=-\\infty$）。这意味着排序后向量的前 $\\rho$ 个分量是有效的（$x_i > 0$），而其余分量则不是（$x_i=0$）。\n\n给定的向量是 $\\mathbf{y} = (0.6, 0.4, 0.3, 0.2, -0.2)$。其分量已经按降序排列。\n我们来寻找 $\\rho$：\n- 尝试 $\\rho=5$：我们假设所有的 $x_i > 0$。$\\lambda = \\frac{1}{5}(\\sum_{i=1}^5 y_i - 1) = \\frac{1}{5}(0.6+0.4+0.3+0.2-0.2 - 1) = \\frac{1}{5}(1.3 - 1) = 0.06$。\n条件 $y_5 > \\lambda$ 必须成立。然而，$-0.2 \\ngtr 0.06$。因此 $\\rho  5$。\n\n- 尝试 $\\rho=4$：我们假设投影后的前四个分量为正，且 $x_5=0$。\n$\\lambda = \\frac{1}{4}\\left(\\sum_{i=1}^4 y_i - 1\\right) = \\frac{1}{4}(0.6+0.4+0.3+0.2 - 1) = \\frac{1}{4}(1.5 - 1) = \\frac{0.5}{4} = 0.125$。\n我们检查这个 $\\lambda$ 是否与我们的假设一致。我们需要 $y_4 > \\lambda$ 且 $y_5 \\leq \\lambda$。\n$y_4 = 0.2$，所以 $0.2 > 0.125$，该条件成立。\n$y_5 = -0.2$，所以 $-0.2 \\leq 0.125$，该条件也成立。\n因此，我们选择的 $\\rho=4$ 是正确的，且 $\\lambda = 0.125$。\n\n现在我们使用 $x_i^{\\star} = \\max(0, y_i - \\lambda)$ 来计算投影向量 $\\mathbf{x}^{\\star}$ 的分量。为保证精度，我们使用有理数：$\\lambda = 0.125 = \\frac{1}{8}$。\n输入向量为 $\\mathbf{y} = (\\frac{3}{5}, \\frac{2}{5}, \\frac{3}{10}, \\frac{1}{5}, -\\frac{1}{5})$。\n\n$x_1^{\\star} = x_{\\text{Fe}}^{\\star} = \\frac{3}{5} - \\frac{1}{8} = \\frac{24 - 5}{40} = \\frac{19}{40}$\n$x_2^{\\star} = x_{\\text{Ni}}^{\\star} = \\frac{2}{5} - \\frac{1}{8} = \\frac{16 - 5}{40} = \\frac{11}{40}$\n$x_3^{\\star} = x_{\\text{Cr}}^{\\star} = \\frac{3}{10} - \\frac{1}{8} = \\frac{12 - 5}{40} = \\frac{7}{40}$\n$x_4^{\\star} = x_{\\text{Mn}}^{\\star} = \\frac{1}{5} - \\frac{1}{8} = \\frac{8 - 5}{40} = \\frac{3}{40}$\n$x_5^{\\star} = x_{\\text{Pb}}^{\\star} = \\max(0, -\\frac{1}{5} - \\frac{1}{8}) = \\max(0, -\\frac{13}{40}) = 0$\n\n投影后的成分向量为 $\\mathbf{x}^{\\star} = (\\frac{19}{40}, \\frac{11}{40}, \\frac{7}{40}, \\frac{3}{40}, 0)$。\n作为检验，所有分量均为非负，且它们的和为1：\n$\\frac{19+11+7+3+0}{40} = \\frac{40}{40} = 1$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{19}{40}  \\frac{11}{40}  \\frac{7}{40}  \\frac{3}{40}  0\n\\end{pmatrix}\n}\n$$"
        }
    ]
}