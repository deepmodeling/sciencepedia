{
    "hands_on_practices": [
        {
            "introduction": "加速分子动力学模拟在偏置势能面 $U_{b}(\\mathbf{r}, t)$ 上进行，从而以加速的时钟运行。为了获得具有物理意义的动力学信息，我们必须将这个被扭曲的模拟时间 $t_{\\mathrm{sim}}$ “校正”回真实的物理时间 $t_{\\mathrm{eff}}$。本练习将指导你实现这一时间恢复过程的核心公式 $t_{\\mathrm{eff}} = \\int_{0}^{t_{\\mathrm{sim}}} \\exp(\\beta \\Delta V(t))\\, dt$，即对“增强因子”进行路径积分，这是理解和应用超动力学等方法的首要步骤 ()。",
            "id": "3729122",
            "problem": "考虑一个原子构型的轨迹，该构型在用于稀有事件的加速分子动力学（MD）方案（超动力学）中，在偏置势的作用下演化。设无偏置势表示为 $U(\\mathbf{r})$，偏置为在亚稳态盆地中添加的一个非负、含时函数 $\\Delta V(t)$，因此偏置势为 $U_{b}(\\mathbf{r}, t) = U(\\mathbf{r}) + \\Delta V(t)$。其目标是通过沿模拟路径累积一个增强因子，来恢复由模拟推进的、且与过渡态理论（TST）一致的物理上正确的时钟时间。此映射的理论基础是，在温度为 $T$ 的热系统中，过渡态理论中的逃逸速率与 $\\exp(-\\beta U)$ 成正比，其中 $\\beta = 1/(k_{B} T)$，$k_{B}$ 是玻尔兹曼常数。在加入偏置 $\\Delta V$ 后，微观时间尺度被扭曲。为了获得有效的物理时间，偏置模拟中的无穷小时间增量 $dt$ 必须通过因子 $\\exp(\\beta \\Delta V(t))$ 进行重加权，总有效时间是路径积分\n$$\nt_{\\mathrm{eff}} = \\int_{0}^{t_{\\mathrm{sim}}} \\exp\\!\\big(\\beta \\Delta V(t)\\big)\\, dt,\n$$\n其中 $t_{\\mathrm{sim}}$ 是偏置模拟的时钟时间。量 $t_{\\mathrm{eff}}$ 必须以秒为单位表示。\n\n实现一个完整的程序，该程序：\n- 使用 $k_{B} = 8.617333262145 \\times 10^{-5}$ 电子伏特每开尔文 (eV/K) 计算 $\\beta = \\frac{1}{k_{B} T}$，其中 $T$ 的单位为开尔文，$\\Delta V$ 的单位为电子伏特 (eV)。\n- 给定一个离散轨迹，其时间点 $\\{t_i\\}$（单位为秒）和相应的偏置值 $\\{\\Delta V(t_i)\\}$（单位为电子伏特），在提供的网格上以对非均匀时间步长精确的方式数值计算\n$$\nt_{\\mathrm{eff}} \\approx \\int \\exp\\!\\big(\\beta \\Delta V(t)\\big)\\, dt\n$$\n。\n- 生成包含所有测试用例结果的单行输出，格式为方括号括起来的逗号分隔列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$，其中每个结果都是一个以秒为单位的浮点数。\n\n使用以下测试套件来验证正确性和覆盖率（所有输出都必须以秒为单位）：\n\n- 测试用例 1 (恒定偏置，均匀网格，基准加速时间)：$T = 300$ 开尔文，$t_{\\mathrm{sim}} = 1.0 \\times 10^{-9}$ 秒，$N = 1001$ 个从 $t = 0$ 到 $t = t_{\\mathrm{sim}}$ 的等间距点，并且对于所有 $t$，$\\Delta V(t) = 0.1$ 电子伏特。这测试了 $\\exp(\\beta \\Delta V)$ 不随时间变化的情况。\n\n- 测试用例 2 (含时非负偏置，均匀网格，正弦变化)：$T = 600$ 开尔文，$t_{\\mathrm{sim}} = 2.0 \\times 10^{-8}$ 秒，$N = 20001$ 个等间距点，频率 $f = 5.0 \\times 10^{9}$ 赫兹，振幅 $A = 0.05$ 电子伏特，并且对于所有 $t$，$\\Delta V(t) = A \\big(1 + \\sin(2\\pi f t)\\big)$。这测试了具有非负偏置的非平凡时间依赖性。\n\n- 测试用例 3 (分段偏置，非均匀网格)：$T = 450$ 开尔文，非均匀时间点 $t = [0, 2.0\\times 10^{-12}, 5.0\\times 10^{-12}, 1.1\\times 10^{-11}, 1.5\\times 10^{-11}]$ 秒，以及相应的 $\\Delta V$ 值 $[0.2, 0.2, 0.1, 0.0, 0.0]$ 电子伏特。这测试了非均匀时间采样以及在出口附近偏置趋于零的情况。\n\n- 测试用例 4 (零偏置基准)：$T = 300$ 开尔文，$t_{\\mathrm{sim}} = 1.0 \\times 10^{-9}$ 秒，$N = 1001$ 个等间距点，并且对于所有 $t$，$\\Delta V(t) = 0.0$ 电子伏特。这验证了在没有偏置时，$t_{\\mathrm{eff}}$ 简化为 $t_{\\mathrm{sim}}$。\n\n您的程序必须生成包含四个测试用例结果的单行输出，格式为方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中 $x_i$ 是表示 $t_{\\mathrm{eff}}$（单位为秒）的浮点数。",
            "solution": "该问题是有效的。其科学基础是加速分子动力学的原理，特别是超动力学方法。所给出的物理参数和数学表述是一致且适定的，允许存在唯一的数值解。\n\n该问题背后的基本原理是对偏置分子动力学轨迹中的模拟时间进行重加权，以恢复系统的真实物理时间演化。在统计力学中，热激活稀有事件（如原子扩散或化学反应）的速率由阿伦尼乌斯定律决定。该定律指出，速率 $k$ 与 $\\exp(-\\beta E_a)$ 成正比，其中 $E_a$ 是活化能垒，$\\beta = 1/(k_B T)$ 是逆热能。这里，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n在超动力学方法中，一个非负偏置势 $\\Delta V(\\mathbf{r}) \\ge 0$ 被添加到一个亚稳态内的真实势能面 $U(\\mathbf{r})$ 上。然后，动力学在偏置势能面 $U_b(\\mathbf{r}) = U(\\mathbf{r}) + \\Delta V(\\mathbf{r})$ 上演化。该偏置势有效地降低了活化能垒，从而加速了从势阱中的逃逸。为保证该偏置有效，一个关键要求是它在分隔不同盆地的过渡态表面上必须为零，这样才不会改变不同逃逸路径的相对概率。\n\n动力学的加速是以扭曲时间尺度为代价的。为了恢复真实的物理时间，偏置模拟的每个无穷小步长 $dt$ 都必须通过一个“增强因子”进行重加权。该因子源自偏置系综和无偏置系综中概率（或驻留时间）的比值。在一个由坐标 $\\mathbf{r}$ 表征的状态中，概率密度与 $\\exp(-\\beta U(\\mathbf{r}))$ 成正比。加入偏置后，它变为 $\\exp(-\\beta U_b(\\mathbf{r})) = \\exp(-\\beta U(\\mathbf{r})) \\exp(-\\beta \\Delta V(\\mathbf{r}))$。模拟所花费的时间被一个局部因子 $\\exp(\\beta \\Delta V(\\mathbf{r},t))$ 所增强。为了获得正确的总流逝物理时间 $t_{\\mathrm{eff}}$，我们必须在持续时间为 $t_{\\mathrm{sim}}$ 的偏置模拟轨迹上对这个增强因子进行积分：\n$$\nt_{\\mathrm{eff}} = \\int_{0}^{t_{\\mathrm{sim}}} \\exp\\!\\big(\\beta \\Delta V(t)\\big)\\, dt\n$$\n在这里，$\\Delta V(t)$ 代表系统在模拟时间 $t$ 位于位置 $\\mathbf{r}(t)$ 时的偏置势值。该问题直接提供了偏置势的时间序列。\n\n任务是针对离散时间序列数据 $\\{t_i\\}$ 和相应的偏置势值 $\\{\\Delta V(t_i)\\}$ 数值计算该积分。根据问题陈述的要求，一个对于均匀和非均匀网格都精确的稳健数值积分方法是梯形法则。对于在点 $(t_i, f_i)$ 采样的函数 $f(t)$，其积分可通过对连续点之间形成的梯形面积求和来近似：\n$$\n\\int_{t_0}^{t_{N-1}} f(t) \\, dt \\approx \\sum_{i=0}^{N-2} \\frac{f(t_i) + f(t_{i+1})}{2} (t_{i+1} - t_i)\n$$\n在我们的例子中，被积函数是 $f(t_i) = \\exp(\\beta \\Delta V(t_i))$。\n\n对于每个测试用例，计算实现将按以下步骤进行：\n1.  计算逆热能 $\\beta = \\frac{1}{k_B T}$，确保单位一致。当 $k_B$ 的单位为 $\\mathrm{eV}/\\mathrm{K}$，$T$ 的单位为 $\\mathrm{K}$，$\\Delta V$ 的单位为 $\\mathrm{eV}$ 时，乘积 $\\beta \\Delta V$ 是正确的无量纲量。\n2.  生成时间点 $\\{t_i\\}$ 的离散网格以及相应的偏置势值 $\\{\\Delta V_i = \\Delta V(t_i)\\}$。对于均匀网格，这涉及到使用 `np.linspace`。对于非均匀网格，直接使用所提供的点。对于函数形式的 $\\Delta V(t)$，则在时间网格上对函数进行求值。\n3.  对每个点 $i$ 计算被积函数的值 $y_i = \\exp(\\beta \\Delta V_i)$。\n4.  利用一个实现梯形法则的数值积分例程（如 `numpy.trapz`）来计算定积分。该函数将被积函数值数组 $\\{y_i\\}$ 和时间点数组 $\\{t_i\\}$ 作为输入，能正确处理点 $t_i$ 之间的均匀和非均匀间距。\n\n- **测试用例 1** (恒定偏置)：被积函数 $\\exp(\\beta \\Delta V)$ 是常数。积分简化为 $t_{\\mathrm{eff}} = \\exp(\\beta \\Delta V) \\times t_{\\mathrm{sim}}$。数值方法应能精确地复现此解析结果。\n- **测试用例 2** (正弦偏置)：必须在精细的均匀网格上的每个点计算完整的含时被积函数，然后进行数值积分。\n- **测试用例 3** (分段偏置，非均匀网格)：该用例专门测试积分方法在非均匀采样网格上的稳健性。梯形法则是被明确设计用于处理这种情况的。\n- **测试用例 4** (零偏置)：当 $\\Delta V = 0$ 时，增强因子为 $\\exp(0) = 1$。积分必须返回 $t_{\\mathrm{eff}} = \\int_0^{t_{\\mathrm{sim}}} 1 \\, dt = t_{\\mathrm{sim}}$，这可作为对实现方案基准正确性的关键验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the accelerated molecular dynamics time-recovery problem for four test cases.\n    \"\"\"\n\n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    def compute_teff(T, t_points, delta_V_points):\n        \"\"\"\n        Computes the effective physical time from a biased MD trajectory.\n\n        Args:\n            T (float): Temperature in Kelvin.\n            t_points (np.ndarray): Array of time points in seconds.\n            delta_V_points (np.ndarray): Array of bias potential values in eV.\n\n        Returns:\n            float: The effective time t_eff in seconds.\n        \"\"\"\n        if T == 0:\n            raise ValueError(\"Temperature must be positive.\")\n        \n        # Calculate inverse temperature in 1/eV\n        beta = 1.0 / (k_B * T)\n        \n        # Calculate the integrand, exp(beta * DeltaV(t))\n        integrand = np.exp(beta * delta_V_points)\n        \n        # Numerically integrate using the trapezoidal rule, which is suitable\n        # for both uniform and non-uniform grids.\n        t_eff = np.trapz(integrand, t_points)\n        \n        return t_eff\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: Constant bias, uniform grid\n        {\n            \"T\": 300.0,\n            \"t_sim\": 1.0e-9,\n            \"N\": 1001,\n            \"delta_V_func\": lambda t: 0.1\n        },\n        # Test Case 2: Time-dependent bias, uniform grid\n        {\n            \"T\": 600.0,\n            \"t_sim\": 2.0e-8,\n            \"N\": 20001,\n            \"delta_V_func\": lambda t: 0.05 * (1 + np.sin(2 * np.pi * 5.0e9 * t))\n        },\n        # Test Case 3: Piecewise bias, nonuniform grid\n        {\n            \"T\": 450.0,\n            \"t_points\": np.array([0.0, 2.0e-12, 5.0e-12, 1.1e-11, 1.5e-11]),\n            \"delta_V_points\": np.array([0.2, 0.2, 0.1, 0.0, 0.0])\n        },\n        # Test Case 4: Zero bias baseline\n        {\n            \"T\": 300.0,\n            \"t_sim\": 1.0e-9,\n            \"N\": 1001,\n            \"delta_V_func\": lambda t: 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T = case[\"T\"]\n        \n        if \"t_points\" in case:\n            # Case with explicitly defined non-uniform grid\n            t_points = case[\"t_points\"]\n            delta_V_points = case[\"delta_V_points\"]\n        else:\n            # Cases with uniform grid and functional form of delta_V\n            t_sim = case[\"t_sim\"]\n            N = case[\"N\"]\n            delta_V_func = case[\"delta_V_func\"]\n            \n            t_points = np.linspace(0, t_sim, N)\n            \n            # For constant functions, we can create a full array\n            if np.isscalar(delta_V_func(0)):\n                delta_V_points = np.full(N, delta_V_func(0))\n            else: # For time-dependent functions\n                delta_V_points = delta_V_func(t_points)\n\n        result = compute_teff(T, t_points, delta_V_points)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在通过模拟收集了一系列稀有事件的发生时间 $\\{t_i\\}$ 后，下一步的关键任务是从这些数据中估算出宏观的反应速率常数 $k$。本练习介绍了如何利用强大的最大似然估计（MLE）方法来处理服从指数分布 $f(t|k) = k \\exp(-kt)$ 的事件时间数据，这是分析稀有事件动力学的基石。通过这个练习，你不仅将学会如何计算速率常数，还将学会如何通过构建置信区间来量化估计的不确定性 ()。",
            "id": "3729149",
            "problem": "在应用于难熔高熵合金的加速分子动力学中，考虑在超动力学方法构建的偏置势下，系统从与单空位迁移事件相关的亚稳态微观盆地中逃逸的过程。假设盆地中的无偏驻留时间被建模为一个速率为 $k$ 的独立同分布指数随机变量，这意味着单个无偏驻留时间 $t$ 的概率密度为 $f(t \\mid k) = k \\exp(-k t)$，其中 $t \\ge 0$。在模拟中，每个驻留阶段内保持一个恒定的提升因子，因此第 $i$ 个阶段的无偏驻留时间 $t_i$ 通过 $t_i = s_i \\, \\tau_i^{b}$ 与观测到的有偏驻留时间 $\\tau_i^{b}$ 相关联，其中 $s_i$ 是已知的每个阶段的加速（提升）因子。\n\n你的任务是：\n- 从 $t_i$ 的独立性和指数模型出发，推导逃逸速率 $k$ 的最大似然估计量，用无偏驻留时间 $\\{t_i\\}_{i=1}^{n}$ 表示。\n- 对于大小为 $n$ 的有限样本，使用基于 Fisher 信息的大样本正态近似，构建 $k$ 的双侧置信区间。用估计量、样本大小和对应于双侧 $95\\%$ 水平的标准正态分位数来表示该区间。\n- 使用以下 $n = 4$ 次逃逸事件的观测数据，\n  - 阶段 $1$：$\\tau_1^{b} = 0.50 \\ \\mathrm{ps}$，$s_1 = 20$，\n  - 阶段 $2$：$\\tau_2^{b} = 0.40 \\ \\mathrm{ps}$，$s_2 = 25$，\n  - 阶段 $3$：$\\tau_3^{b} = 1.00 \\ \\mathrm{ps}$，$s_3 = 10$，\n  - 阶段 $4$：$\\tau_4^{b} = 0.25 \\ \\mathrm{ps}$，$s_4 = 40$，\n  计算重加权的无偏驻留时间 $\\{t_i\\}$，并数值计算你的估计量和 $95\\%$ 置信区间。\n\n答案规格：\n- 以 $\\mathrm{ps}^{-1}$ 为单位表示最终速率和两个置信区间界限。\n- 以 $\\big(k_{\\text{MLE}}, k_{\\text{lower}}, k_{\\text{upper}}\\big)$ 的有序三元组形式报告最终结果。\n- 将报告的每个数字四舍五入到四位有效数字。",
            "solution": "该问题是有效的。它在科学上基于统计力学和计算材料科学的原理，特别是加速分子动力学。问题是良定的，提供了所有必要的信息和明确的目标。语言是客观的，设定是内部一致的。\n\n首先，我们推导逃逸速率 $k$ 的最大似然估计量 (MLE)。问题陈述，无偏驻留时间 $\\{t_i\\}_{i=1}^{n}$ 是来自指数分布的独立同分布随机变量，其概率密度函数为 $f(t_i | k) = k \\exp(-k t_i)$。对于大小为 $n$ 的样本，其似然函数 $L(k)$ 是各概率密度的乘积：\n$$L(k; \\{t_i\\}_{i=1}^{n}) = \\prod_{i=1}^{n} f(t_i | k) = \\prod_{i=1}^{n} k \\exp(-k t_i) = k^n \\exp\\left(-k \\sum_{i=1}^{n} t_i\\right)$$\n为了找到 $L(k)$ 的最大值，我们首先取自然对数，得到对数似然函数 $\\ell(k)$：\n$$\\ell(k) = \\ln(L(k)) = \\ln\\left(k^n \\exp\\left(-k \\sum_{i=1}^{n} t_i\\right)\\right) = n \\ln(k) - k \\sum_{i=1}^{n} t_i$$\n然后我们将 $\\ell(k)$ 对 $k$ 求导，并令结果为零，以找到使对数似然最大化的 $k$ 值：\n$$\\frac{d\\ell(k)}{dk} = \\frac{n}{k} - \\sum_{i=1}^{n} t_i = 0$$\n解出 $k$ 即可得到最大似然估计量，记为 $\\hat{k}$：\n$$\\hat{k} = \\frac{n}{\\sum_{i=1}^{n} t_i}$$\n这表明速率 $k$ 的最大似然估计量是无偏驻留时间的样本均值的倒数。\n\n接下来，我们使用大样本正态近似为 $k$ 构建一个双侧 $95\\%$ 置信区间。最大似然估计量的渐近方差由 Fisher 信息的倒数给出。单个观测的 Fisher 信息 $I(k)$ 定义为 $I(k) = -E\\left[\\frac{d^2 \\ln f(t|k)}{dk^2}\\right]$。\n对数概率密度函数的一阶导数是 $\\frac{d \\ln f(t|k)}{dk} = \\frac{1}{k} - t$。二阶导数是：\n$$\\frac{d^2 \\ln f(t|k)}{dk^2} = -\\frac{1}{k^2}$$\n由于二阶导数相对于 $t$ 是一个常数，其期望就是该常数本身。因此，单个观测的 Fisher 信息是：\n$$I(k) = -E\\left[-\\frac{1}{k^2}\\right] = \\frac{1}{k^2}$$\n对于 $n$ 个独立观测的样本，总 Fisher 信息为 $I_n(k) = n I(k) = \\frac{n}{k^2}$。最大似然估计量 $\\hat{k}$ 的渐近方差是 $I_n(k)$ 的倒数：\n$$\\text{Var}(\\hat{k}) \\approx [I_n(k)]^{-1} = \\frac{k^2}{n}$$\n$\\hat{k}$ 的标准误通过用 $\\hat{k}$ 替代 $k$ 来估计：\n$$SE(\\hat{k}) = \\sqrt{\\frac{\\hat{k}^2}{n}} = \\frac{\\hat{k}}{\\sqrt{n}}$$\n对于大的 $n$，$\\hat{k}$ 的分布近似为正态分布，即 $\\hat{k} \\sim N\\left(k, \\frac{k^2}{n}\\right)$。$k$ 的一个双侧 $100(1-\\alpha)\\%$ 置信区间由 $\\hat{k} \\pm z_{1-\\alpha/2} SE(\\hat{k})$ 给出，其中 $z_{1-\\alpha/2}$ 是标准正态分布的上 $(1-\\alpha/2)$ 分位数。对于 $95\\%$ 的置信水平，$\\alpha=0.05$，所以我们使用 $z_{1-0.05/2} = z_{0.975} \\approx 1.96$。置信区间为：\n$$ \\left( \\hat{k} - z_{0.975} \\frac{\\hat{k}}{\\sqrt{n}}, \\hat{k} + z_{0.975} \\frac{\\hat{k}}{\\sqrt{n}} \\right) = \\hat{k} \\left( 1 \\pm \\frac{z_{0.975}}{\\sqrt{n}} \\right) $$\n\n最后，我们使用所提供的数据计算数值。首先，我们计算无偏驻留时间 $t_i = s_i \\tau_i^b$：\n- $t_1 = 20 \\times 0.50 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n- $t_2 = 25 \\times 0.40 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n- $t_3 = 10 \\times 1.00 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n- $t_4 = 40 \\times 0.25 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n\n无偏驻留时间的总和是 $\\sum_{i=1}^{4} t_i = 10.0+10.0+10.0+10.0 = 40.0 \\ \\mathrm{ps}$。\n样本大小为 $n=4$。$k$ 的最大似然估计量是：\n$$\\hat{k}_{\\text{MLE}} = \\frac{4}{40.0 \\ \\mathrm{ps}} = 0.1 \\ \\mathrm{ps}^{-1}$$\n对于置信区间，我们有 $n=4$，因此 $\\sqrt{n}=2$，并且 $z_{0.975} \\approx 1.96$。\n置信区间的下界 $k_{\\text{lower}}$ 是：\n$$k_{\\text{lower}} = 0.1 \\left( 1 - \\frac{1.96}{2} \\right) = 0.1 (1 - 0.98) = 0.1(0.02) = 0.002 \\ \\mathrm{ps}^{-1}$$\n置信区间的上界 $k_{\\text{upper}}$ 是：\n$$k_{\\text{upper}} = 0.1 \\left( 1 + \\frac{1.96}{2} \\right) = 0.1 (1 + 0.98) = 0.1(1.98) = 0.198 \\ \\mathrm{ps}^{-1}$$\n问题要求将结果四舍五入到四位有效数字。\n- $\\hat{k}_{\\text{MLE}} = 0.1 \\ \\mathrm{ps}^{-1}$ 变为 $0.1000 \\ \\mathrm{ps}^{-1}$。\n- $k_{\\text{lower}} = 0.002 \\ \\mathrm{ps}^{-1}$ 变为 $0.002000 \\ \\mathrm{ps}^{-1}$。\n- $k_{\\text{upper}} = 0.198 \\ \\mathrm{ps}^{-1}$ 变为 $0.1980 \\ \\mathrm{ps}^{-1}$。\n最终结果是有序三元组 $(k_{\\text{MLE}}, k_{\\text{lower}}, k_{\\text{upper}})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1000 & 0.002000 & 0.1980\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "加速分子动力学方法的有效性依赖于几个关键假设，其中最核心的是事件的发生是无记忆的（马尔可夫过程），这导致了出口时间的指数分布。本节的高级实践将引导你应用严格的统计检验方法——似然比检验（LRT），来验证模拟数据是否偏离了这一关键假设。掌握这种验证技术对于确保加速分子动力学模拟结果的可靠性与准确性至关重要 ()。",
            "id": "3729086",
            "problem": "您正在使用加速分子动力学（Accelerated Molecular Dynamics, AMD）对高熵合金（High-Entropy Alloy, HEA）中的稀有事件动力学进行建模。在马尔可夫假设下，且当亚稳态盆内存在准稳态分布（Quasi-Stationary Distribution, QSD）时，从该盆地出离的时间是无记忆的，具有恒定的风险率。根据第一性原理，这意味着出离时间分布是具有单个速率参数的指数分布。偏离指数分布的情况表明存在非马尔可夫效应、盆内存在异构微观状态，或违反了 AMD 假设（例如，不正确的增强因子或不充分的去相关），这些情况会使时间加速映射失效并产生有偏差的动力学结果。\n\n从生存函数、风险函数和独立出离时间下的最大似然估计（Maximum Likelihood Estimation, MLE）的定义出发，推导并实现一个统计检验，用于检测出离时间与指数分布的偏差。将此检验构建为一个似然比检验（Likelihood Ratio Test, LRT），它将指数模型（恒定风险）与更通用的 Weibull 模型（时间依赖风险）进行比较。您的程序必须：\n\n- 从第一性原理推导指数模型和 Weibull 模型的对数似然，并计算 LRT 统计量。\n- 使用原假设下 LRT 统计量的渐近分布来计算 $p$ 值。\n- 为每个数据集返回一个布尔决策，指明在显著性水平 $\\alpha = 0.05$ 下，指数出离时间的原假设是否被拒绝。\n\n使用的定义：\n- 生存函数为 $S(t) = \\mathbb{P}(T > t)$，风险函数为 $h(t) = \\frac{f(t)}{S(t)}$，其中 $f(t)$ 是出离时间 $T$ 的概率密度函数。\n- 在恒定风险的原假设下，$T$ 服从指数分布，其尺度参数为 $\\lambda > 0$，因此对于 $t \\ge 0$，有 $f(t) = \\frac{1}{\\lambda} \\exp\\!\\left(-\\frac{t}{\\lambda}\\right)$。\n- 在备择假设下，$T$ 服从 Weibull 分布，其形状参数为 $k > 0$，尺度参数为 $\\lambda > 0$，因此对于 $t \\ge 0$，有 $f(t) = \\frac{k}{\\lambda}\\left(\\frac{t}{\\lambda}\\right)^{k-1} \\exp\\!\\left(-\\left(\\frac{t}{\\lambda}\\right)^{k}\\right)$。\n\n物理单位和数据生成：\n- 出离时间必须以秒为单位处理，并作为以秒为单位的独立样本生成。\n- 为保证可复现性，请使用固定种子 $s = 314159$ 的伪随机数生成器。\n- 构建以下数据集测试套件，每个数据集都是以秒为单位的独立出离时间列表：\n    1. 指数出离时间，尺度 $\\lambda = 2.0$ 秒，样本量 $n = 200$。\n    2. Weibull 出离时间，形状 $k = 0.7$，尺度 $\\lambda = 2.0$ 秒，样本量 $n = 200$。\n    3. 指数分布混合：以 $0.5$ 的概率从 $\\text{Exponential}(\\lambda_1 = 1.0)$ 秒中抽取，以 $0.5$ 的概率从 $\\text{Exponential}(\\lambda_2 = 3.3333333333)$ 秒中抽取，样本量 $n = 200$。\n    4. 指数出离时间，尺度 $\\lambda = 2.0$ 秒，样本量 $n = 20$（边界情况：统计功效低）。\n    5. Weibull 出离时间，形状 $k = 1.5$，尺度 $\\lambda = 2.0$ 秒，样本量 $n = 200$。\n\n算法要求：\n- 根据给定数据，通过 MLE 估计原假设下的指数尺度参数 $\\lambda$。\n- 根据给定数据，通过 MLE 估计备择假设下的 Weibull 形状参数 $k$ 和尺度参数 $\\lambda$。\n- 使用最大化对数似然的差值计算 LRT 统计量，并从自由度为 1 的卡方分布中获得 $p$ 值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的布尔值列表，其顺序与上述数据集相同（例如，“[True,False,True,False,True]”）。每个布尔值必须指明对于该数据集，在 $\\alpha = 0.05$ 的显著性水平下，指数出离时间的原假设是否被拒绝。",
            "solution": "该问题要求推导并实现一个似然比检验（Likelihood Ratio Test, LRT），以验证加速分子动力学（Accelerated Molecular Dynamics, AMD）模拟中指数出离时间假设的有效性。这个假设是基础性的，因为它源于模拟设置中对稀有事件的无记忆马尔可夫过程的近似。偏离具有恒定风险率的指数分布，意味着底层的动力学过程更为复杂（例如，非马尔可夫过程或涉及异构状态），并且从 AMD 获得的时间加速可能存在偏差。我们将比较指数分布的原假设与一个更通用的备择假设——Weibull 分布，后者允许风险率随时间变化。\n\n### 1. 似然比检验的理论构建\n\n设观测到的出离时间为一组 $n$ 个独立同分布（i.i.d.）的正随机变量 $\\mathbf{T} = \\{T_1, T_2, \\ldots, T_n\\}$，其观测值为 $\\mathbf{t} = \\{t_1, t_2, \\ldots, t_n\\}$。似然函数由 $L(\\theta | \\mathbf{t}) = \\prod_{i=1}^n f(t_i | \\theta)$ 给出，其中 $f(t|\\theta)$ 是由参数 $\\theta$ 参数化的概率密度函数（PDF）。我们将使用对数似然函数，即 $\\ell(\\theta | \\mathbf{t}) = \\ln L(\\theta | \\mathbf{t}) = \\sum_{i=1}^n \\ln f(t_i | \\theta)$。\n\n#### 原假设 ($H_0$): 指数出离时间\n\n在原假设下，出离时间服从指数分布，其特征是恒定的风险率。其概率密度函数（PDF）为：\n$$\nf(t|\\lambda) = \\frac{1}{\\lambda} \\exp\\left(-\\frac{t}{\\lambda}\\right), \\quad t \\ge 0, \\lambda > 0\n$$\n其中 $\\lambda$ 是尺度参数，表示平均出离时间。对于样本 $\\mathbf{t}$ 的对数似然函数是：\n$$\n\\ell_0(\\lambda | \\mathbf{t}) = \\sum_{i=1}^n \\ln\\left(\\frac{1}{\\lambda} \\exp\\left(-\\frac{t_i}{\\lambda}\\right)\\right) = \\sum_{i=1}^n \\left(-\\ln\\lambda - \\frac{t_i}{\\lambda}\\right) = -n\\ln\\lambda - \\frac{1}{\\lambda}\\sum_{i=1}^n t_i\n$$\n为了找到 $\\lambda$ 的最大似然估计（MLE），我们将 $\\ell_0$ 对 $\\lambda$ 求导并令其结果为零：\n$$\n\\frac{\\partial \\ell_0}{\\partial \\lambda} = -\\frac{n}{\\lambda} + \\frac{1}{\\lambda^2}\\sum_{i=1}^n t_i = 0\n$$\n解出 $\\lambda$ 得到 MLE，记为 $\\hat{\\lambda}_0$：\n$$\n\\hat{\\lambda}_0 = \\frac{1}{n}\\sum_{i=1}^n t_i = \\bar{t}\n$$\n指数尺度参数的 MLE 是样本均值。在 $H_0$ 下的最大化对数似然，记为 $\\hat{\\ell}_0$，通过将 $\\hat{\\lambda}_0$ 代入 $\\ell_0(\\lambda | \\mathbf{t})$ 得到：\n$$\n\\hat{\\ell}_0 = \\ell_0(\\hat{\\lambda}_0 | \\mathbf{t}) = -n\\ln(\\bar{t}) - \\frac{1}{\\bar{t}}\\sum_{i=1}^n t_i = -n(\\ln(\\bar{t}) + 1)\n$$\n\n#### 备择假设 ($H_1$): Weibull 出离时间\n\n在备择假设下，我们使用双参数 Weibull 分布，它能适应随时间变化的风险函数 $h(t) \\propto t^{k-1}$。其概率密度函数为：\n$$\nf(t|k, \\lambda) = \\frac{k}{\\lambda}\\left(\\frac{t}{\\lambda}\\right)^{k-1} \\exp\\left(-\\left(\\frac{t}{\\lambda}\\right)^k\\right), \\quad t \\ge 0, k > 0, \\lambda > 0\n$$\n这里，$k$ 是形状参数，$\\lambda$ 是尺度参数。指数分布是 Weibull 分布在 $k=1$ 时的特例。对于样本 $\\mathbf{t}$ 的对数似然函数是：\n$$\n\\ell_1(k, \\lambda | \\mathbf{t}) = \\sum_{i=1}^n \\ln\\left[\\frac{k}{\\lambda}\\left(\\frac{t_i}{\\lambda}\\right)^{k-1} \\exp\\left(-\\left(\\frac{t_i}{\\lambda}\\right)^k\\right)\\right] = n\\ln k - nk\\ln\\lambda + (k-1)\\sum_{i=1}^n \\ln t_i - \\sum_{i=1}^n\\left(\\frac{t_i}{\\lambda}\\right)^k\n$$\n$k$ 和 $\\lambda$ 的 MLE，记为 $(\\hat{k}_1, \\hat{\\lambda}_1)$，没有封闭解。它们必须通过数值最大化 $\\ell_1(k, \\lambda | \\mathbf{t})$ 来找到。在 $H_1$ 下的最大化对数似然，记为 $\\hat{\\ell}_1$，即 $\\ell_1(\\hat{k}_1, \\hat{\\lambda}_1 | \\mathbf{t})$。\n\n#### 似然比检验统计量\n\nLRT 用于比较两个嵌套模型。由于指数模型是 Weibull 模型（$k=1$）的特例，因此它们是嵌套的。LRT 统计量 $\\Lambda$ 定义为最大化对数似然差值的两倍：\n$$\n\\Lambda = 2(\\hat{\\ell}_1 - \\hat{\\ell}_0)\n$$\n根据 Wilks' theorem，在原假设 $H_0$ 下，检验统计量 $\\Lambda$ 渐近服从卡方（$\\chi^2$）分布。其自由度（$df$）是备择模型和原模型自由参数数量的差值。在我们的案例中，Weibull 模型有两个参数（$k, \\lambda$），指数模型有一个参数（$\\lambda$），所以 $df = 2 - 1 = 1$。\n$$\n\\Lambda \\sim \\chi^2_1 \\quad (\\text{在 } H_0 \\text{ 下})\n$$\n\n### 2. 算法流程与决策规则\n\n对于每个出离时间数据集，统计检验按以下步骤实施：\n\n1.  **生成数据集：** 为保证可复现性，使用固定种子 $s = 314159$ 的伪随机数生成器构建五个指定的出离时间测试用例。\n\n2.  **在 $H_0$ 下估计：** 计算指数参数的 MLE，即 $\\hat{\\lambda}_0 = \\bar{t}$。然后计算最大化对数似然 $\\hat{\\ell}_0 = -n(\\ln(\\hat{\\lambda}_0) + 1)$。\n\n3.  **在 $H_1$ 下估计：** 数值求解使 Weibull 对数似然函数 $\\ell_1(k, \\lambda | \\mathbf{t})$ 最大化的参数 $(\\hat{k}_1, \\hat{\\lambda}_1)$。这通过最小化负对数似然函数 $-\\ell_1(k, \\lambda | \\mathbf{t})$ 来实现，使用诸如 L-BFGS-B 的数值优化算法，该算法可以处理边界约束（$k>0, \\lambda>0$）。得到的最大化对数似然为 $\\hat{\\ell}_1$。\n\n4.  **计算检验统计量和 $p$ 值：** 计算 LRT 统计量 $\\Lambda = 2(\\hat{\\ell}_1 - \\hat{\\ell}_0)$。$\\Lambda$ 的值必须为非负数。任何因浮点不精确而产生的微小负值都应视为零。然后，$p$ 值计算为从 $\\chi^2_1$ 分布中观测到大于或等于所计算的 $\\Lambda$ 值的概率：\n    $$\n    p = \\mathbb{P}(\\chi^2_1 \\ge \\Lambda) = 1 - F_{\\chi^2_1}(\\Lambda)\n    $$\n    其中 $F_{\\chi^2_1}$ 是 $\\chi^2_1$ 分布的累积分布函数。这等价于生存函数。\n\n5.  **决策：** 将 $p$ 值与预定义的显著性水平 $\\alpha = 0.05$ 进行比较。如果 $p < \\alpha$，我们拒绝原假设 $H_0$。这表明出离时间不服从指数分布，且更简单的恒定风险模型是不充分的。否则，如果 $p \\ge \\alpha$，我们未能拒绝 $H_0$。\n\n这一严谨的流程为评估复杂材料的 AMD 模拟中关键假设的有效性提供了定量诊断工具。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Derives and implements a Likelihood Ratio Test to detect deviations from\n    exponential exit times in simulated molecular dynamics data.\n    \"\"\"\n\n    def generate_datasets(seed):\n        \"\"\"Generates the five test datasets as specified in the problem.\"\"\"\n        rng = np.random.default_rng(seed)\n        datasets = []\n\n        # Dataset 1: Exponential(lambda=2.0), n=200\n        datasets.append(rng.exponential(scale=2.0, size=200))\n\n        # Dataset 2: Weibull(k=0.7, lambda=2.0), n=200\n        # numpy.random.weibull(a) has scale=1, so we multiply by the desired scale.\n        datasets.append(2.0 * rng.weibull(a=0.7, size=200))\n\n        # Dataset 3: Mixture of exponentials, n=200\n        n3 = 200\n        lam1, lam2 = 1.0, 10.0 / 3.0  # Use fraction for precision\n        mixture_draws = rng.uniform(size=n3)\n        data3 = np.array([\n            rng.exponential(scale=lam1) if u  0.5 \n            else rng.exponential(scale=lam2) \n            for u in mixture_draws\n        ])\n        datasets.append(data3)\n\n        # Dataset 4: Exponential(lambda=2.0), n=20 (low power)\n        datasets.append(rng.exponential(scale=2.0, size=20))\n\n        # Dataset 5: Weibull(k=1.5, lambda=2.0), n=200\n        datasets.append(2.0 * rng.weibull(a=1.5, size=200))\n        \n        return datasets\n\n    def perform_lrt(data, alpha):\n        \"\"\"\n        Performs the Likelihood Ratio Test on a single dataset.\n        \n        Args:\n            data (np.ndarray): Array of exit times.\n            alpha (float): Significance level.\n\n        Returns:\n            bool: True if the null hypothesis is rejected, False otherwise.\n        \"\"\"\n        n = len(data)\n        \n        # H0: Exponential distribution\n        # MLE for lambda is the sample mean.\n        lambda_exp_mle = np.mean(data)\n        # Maximized log-likelihood for the exponential model.\n        log_L0 = -n * (np.log(lambda_exp_mle) + 1.0)\n        \n        # H1: Weibull distribution\n        def neg_log_likelihood_weibull(params, t_data):\n            k, lam = params\n            if k = 0 or lam = 0:\n                return np.inf\n            \n            # To avoid log(0) if any data point is zero.\n            if np.any(t_data = 0):\n                return np.inf\n\n            # Log-likelihood expression for Weibull\n            log_t = np.log(t_data)\n            term1 = n * np.log(k)\n            term2 = -n * k * np.log(lam)\n            term3 = (k - 1) * np.sum(log_t)\n            term4 = -np.sum((t_data / lam)**k)\n            \n            log_L = term1 + term2 + term3 + term4\n            return -log_L\n\n        # Initial guess for optimization: k=1 (exponential) and lambda=sample_mean\n        initial_guess = [1.0, lambda_exp_mle]\n        bounds = [(1e-9, None), (1e-9, None)]  # k > 0, lambda > 0\n        \n        opt_result = minimize(\n            neg_log_likelihood_weibull,\n            x0=initial_guess,\n            args=(data,),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        \n        # Maximized log-likelihood for the Weibull model\n        log_L1 = -opt_result.fun\n        \n        # Compute the LRT statistic\n        # Should be non-negative, but can be slightly negative due to precision.\n        lrt_statistic = 2 * (log_L1 - log_L0)\n        if lrt_statistic  0:\n            lrt_statistic = 0.0\n\n        # Compute p-value from chi-squared distribution with 1 degree of freedom\n        p_value = chi2.sf(lrt_statistic, df=1)\n\n        return p_value  alpha\n\n    # --- Main execution logic ---\n    \n    # Define parameters\n    seed = 314159\n    alpha = 0.05\n    \n    # Generate the test suite of datasets\n    test_cases = generate_datasets(seed)\n    \n    results = []\n    for data in test_cases:\n        # Perform the LRT for each dataset and store the boolean result\n        reject_h0 = perform_lrt(data, alpha)\n        results.append(reject_h0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}