{
    "hands_on_practices": [
        {
            "introduction": "在包含大量可能事件的动力学蒙特卡洛（kMC）模拟中，如何高效地选择下一个要发生的事件是一个核心的计算挑战。一个简单的线性搜索算法的计算成本会随着事件数量 $N$ 线性增长（$O(N)$），这在复杂系统中会变得极其缓慢。本练习将指导您实现一种名为分段树（segment tree）的高级数据结构，它可以将事件选择的复杂度降低到对数级别（$O(\\log N)$），从而极大地提升模拟性能。",
            "id": "3747900",
            "problem": "您正在为高熵合金中的扩散与析出动力学建立动力学蒙特卡洛 (kMC) 模拟的事件选择模型，其中有一系列可能的事件（例如，原子跳跃、溶质-空位交换，以及析出物形核或生长事件），每个事件都带有一个非负速率。设有 $N$ 个事件，索引为 $i=0,1,\\dots,N-1$，每个事件的速率为 $r_i \\ge 0$。总速率为 $R=\\sum_{i=0}^{N-1} r_i$。在 kMC 中，为选择下一个事件，需要抽取一个均匀随机数 $u \\in [0,1)$，并以概率 $r_i/R$ 选择事件 $i$（假设 $R0$）。这等同于通过抽取一个阈值 $s=uR$ 来选择 $i$，并找到唯一的 $i$ 使得当事件以任何固定方式排序时，$s$ 位于事件 $i$ 长度为 $r_i$ 的累积区间内。\n\n您的任务是实现一个线段树（存储累积和的二叉树），该树具备以下功能：\n- 将速率 $r_i$ 存储在叶节点中，如有必要，使用零速率填充至下一个二次幂的叶节点数。\n- 在每个内部节点存储其子节点速率之和。\n- 支持使用以下二分搜索遍历进行事件选择操作：计算 $s=uR$；从根节点开始，在一个其左子节点和为 $L$ 的节点处，如果 $s  L$ 则遍历左子节点，否则将 $s$ 更新为 $s-L$ 并遍历右子节点。",
            "solution": "该问题要求推导线段树的性质并实现它，用于动力学蒙特卡洛 (kMC) 模拟中的高效事件选择，然后进行经验性验证。\n\n首先，我们必须验证问题陈述。\n该问题具有科学依据，位于 kMC 模拟的标准框架内，利用了诸如来自过渡态理论的 Arrhenius 速率和线段树等高效数据结构之类的既定概念。所提供的参数和常数（例如，尝试频率、活化能、玻尔兹曼常数）对于模拟材料中的原子过程在物理上是现实的。该问题是良构的，为待实现的算法和用于验证的测试用例提供了完整且无歧义的规范。所有必要的数据，包括用于可复现性的伪随机种子，均已提供。该问题是非平凡的，既需要理论证明也需要仔细的实现，并且与计算材料科学直接相关。因此，该问题被认为是 **有效的**。\n\n我们现在开始解决问题，从所需的推导开始。\n\n### 第1部分：理论推导\n\nkMC 算法从一组包含 $N$ 个可能事件的集合中选择下一个事件 $i$，这些事件的非负速率为 $r_0, r_1, \\dots, r_{N-1}$。总速率为 $R = \\sum_{i=0}^{N-1} r_i$。我们假设 $R  0$。\n\n#### 1. 正确选择概率的证明\n\nkMC 事件选择的基本原理是事件 $i$ 以概率 $p_i = r_i / R$ 被选择。这可以通过将半开区间 $[0, R)$ 划分为 $N$ 个连续的子区间来形象化，其中与事件 $i$ 对应的第 $i$ 个子区间的长度为 $r_i$。构建此划分的标准方法是将事件 $i$ 的区间定义为 $I_i = [\\sum_{j=0}^{i-1} r_j, \\sum_{j=0}^{i} r_j)$。从 $[0, R)$ 中均匀抽取一个随机数 $s$，它落入区间 $I_i$ 的概率为 $|I_i| / R = ((\\sum_{j=0}^{i} r_j) - (\\sum_{j=0}^{i-1} r_j)) / R = r_i / R$。因此，找到满足 $s \\in I_i$ 的索引 $i$ 是一种正确的选择机制。\n\n所述的线段树遍历算法是执行此搜索的一种高效方法。让我们来证明其正确性。\n\n该树是一个具有 $M$ 个叶节点的完全二叉树，其中 $M$ 是满足 $M \\ge N$ 的最小二次幂。最初的 $N$ 个速率被放置在前 $N$ 个叶节点中，剩下的 $M-N$ 个叶节点被赋予速率 $0$。设叶节点从 $0$ 到 $M-1$ 索引。任何内部节点中存储的值是其子树中所有叶节点速率的总和。因此，根节点存储了总速率 $R = \\sum_{i=0}^{M-1} r_i = \\sum_{i=0}^{N-1} r_i$。\n\n选择算法首先抽取一个均匀随机数 $u \\in [0,1)$ 并计算搜索阈值 $s = uR$。此阈值 $s$ 在 $[0, R)$ 上是均匀分布的。然后算法从根节点遍历到一个叶节点。\n\n让我们分析在任意内部节点 $P$ 处的一个步骤。假设此节点覆盖了一个叶节点索引范围，其值为这些叶节点速率的总和 $R_P$。当前的搜索阈值，我们称之为 $s_{curr}$，是 $[0, R_P)$ 中的一个值。$P$ 的左子节点，我们称之为 $L$，存储了 $P$ 之下前半部分叶节点的速率总和。设此总和为 $R_L$。算法将 $s_{curr}$ 与 $R_L$ 进行比较。\n\n1.  如果 $s_{curr}  R_L$：算法遍历到左子节点 $L$。这对应于原始阈值 $s$ 落入由 $L$ 下的叶节点所跨越的累积速率区间内的情况。搜索在此子问题中继续。\n\n2.  如果 $s_{curr} \\ge R_L$：算法遍历到右子节点 $R$ 并将阈值更新为 $s_{new} = s_{curr} - R_L$。这对应于 $s$ 落入由 $R$ 下的叶节点所跨越的累积速率区间内的情况。通过减去 $R_L$，新的阈值 $s_{new}$ 被正确地重新归一化，成为在区间 $[0, R_R)$ 内的搜索值，其中 $R_R = R_P - R_L$ 是右子树中速率的总和。\n\n这个过程是在速率的隐式累积和数组上进行的递归二分搜索。设累积和为 $C_k = \\sum_{j=0}^{k} r_j$。遍历算法找到唯一的叶节点索引 $i$，使得 $C_{i-1} \\le s  C_i$（其中 $C_{-1}=0$）。选择（向左或向右）和减法的序列有效地锁定了这个特定的区间。由于 $s$ 是从 $[0, R)$ 中均匀选择的，它落入事件 $i$ 的区间（其长度为 $r_i$）的概率恰好是 $r_i / R$。这证实了选择概率的正确性。\n\n#### 2. $O(\\log N)$ 时间复杂度的证明\n\n选择和更新操作的时间复杂度由线段树的高度决定。\n\n1.  **树的高度：** 树由 $M$ 个叶节点构建，其中 $M$ 是满足 $M \\ge N$ 的最小二次幂。这意味着 $N \\le M  2N$。该数据结构是一个完全二叉树。具有 $M$ 个叶节点的完全二叉树的高度为 $H = \\log_2(M)$。\n\n2.  **选择的复杂度：** 选择算法涉及从根到其中一个叶节点的单次遍历。此路径的长度等于树的高度 $H$。在此路径上的每个 $H$ 个内部节点处，执行恒定数量的算术运算（一次内存访问以获取左子节点的和，一次比较，以及一次可能的减法）。因此，单次选择的总时间复杂度与树的高度成正比：\n    $$\n    T_{\\text{select}} \\propto H = \\log_2(M)\n    $$\n    由于 $M  2N$，我们有 $\\log_2(M)  \\log_2(2N) = \\log_2(2) + \\log_2(N) = 1 + \\log_2(N)$。因此，复杂度为 $O(\\log N)$。最大内部节点访问次数 $s_{\\max}$ 正是树的高度 $H = \\log_2(M)$。\n\n3.  **更新的复杂度：** 要更新一个速率 $r_j \\mapsto r'_j$，我们首先在树中定位相应的叶节点。然后，我们将变化量 $\\Delta r = r'_j - r_j$ 沿树向上传播至根节点。这涉及更新叶节点的值、其父节点、其父节点的父节点，依此类推，直到到达根节点。这条从叶节点到根节点的路径长度也等于树的高度 $H$。在路径上的每个节点，执行一次加法。因此，更新操作的时间复杂度也为 $O(H) = O(\\log N)$。\n\n至此，理论推导结束。现在将基于这些原理进行实现。",
            "answer": "```python\nimport numpy as np\nimport math\n\nclass SegmentTree:\n    \"\"\"\n    A segment tree for efficient kMC event selection.\n    \n    The tree is stored in a 0-indexed array. For a tree with M leaves (M is a power of two),\n    the array has size 2*M - 1.\n    - Internal nodes are at indices [0, M-2].\n    - Leaf nodes are at indices [M-1, 2*M-2].\n    The parent of node i is (i-1)//2.\n    The children of node i are 2*i+1 (left) and 2*i+2 (right).\n    \"\"\"\n\n    def __init__(self, rates):\n        \"\"\"Initializes the segment tree from a list of rates.\"\"\"\n        self.n_original = len(rates)\n        if self.n_original == 0:\n            self.n_leaves = 0\n            self.tree = np.array([])\n            return\n\n        # Determine the number of leaves (next power of 2)\n        if self.n_original > 1:\n            self.n_leaves = 1  (self.n_original - 1).bit_length()\n        else:\n            self.n_leaves = 1\n\n        self.tree_size = 2 * self.n_leaves - 1\n        self.leaf_start_index = self.n_leaves - 1\n        \n        self.tree = np.zeros(self.tree_size)\n        \n        # Place initial rates in the leaves\n        for i in range(self.n_original):\n            self.tree[self.leaf_start_index + i] = rates[i]\n            \n        # Build the tree by summing up from the leaves\n        self._build()\n\n    def _build(self):\n        \"\"\"Builds the sum hierarchy of the tree.\"\"\"\n        if self.n_original == 0:\n            return\n        # Iterate from the last internal node up to the root\n        for i in range(self.leaf_start_index - 1, -1, -1):\n            left_child = 2 * i + 1\n            right_child = 2 * i + 2\n            self.tree[i] = self.tree[left_child] + self.tree[right_child]\n\n    def update(self, index, new_rate):\n        \"\"\"Updates the rate at a given index and propagates the change to the root.\"\"\"\n        if not (0 = index  self.n_original):\n            raise IndexError(\"Index out of bounds.\")\n            \n        current_node_idx = self.leaf_start_index + index\n        diff = new_rate - self.tree[current_node_idx]\n        \n        # Propagate the difference up the tree\n        while current_node_idx >= 0:\n            self.tree[current_node_idx] += diff\n            if current_node_idx == 0:\n                break\n            current_node_idx = (current_node_idx - 1) // 2\n\n    def select(self, rng):\n        \"\"\"Selects an event based on its rate and returns its index and traversal depth.\"\"\"\n        total_rate = self.tree[0]\n        if total_rate = 0:\n            return None, 0 # No event can be selected\n\n        s = rng.random() * total_rate\n        \n        current_node_idx = 0\n        visits = 0\n        \n        # Traverse until a leaf is reached\n        while current_node_idx  self.leaf_start_index:\n            visits += 1\n            left_child_idx = 2 * current_node_idx + 1\n            left_sum = self.tree[left_child_idx]\n            \n            if s  left_sum:\n                current_node_idx = left_child_idx\n            else:\n                s -= left_sum\n                current_node_idx = left_child_idx + 1\n        \n        event_index = current_node_idx - self.leaf_start_index\n        return event_index, visits\n\n    def get_total_rate(self):\n        \"\"\"Returns the total rate stored at the root.\"\"\"\n        if self.n_original == 0:\n            return 0.0\n        return self.tree[0]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    KB_EV_K = 8.617333262e-5\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"N\": 1,\n            \"rates\": np.array([5.0]),\n            \"trials\": 10000,\n            \"seed\": 42\n        },\n        {\n            \"name\": \"B\",\n            \"N\": 2,\n            \"rates\": np.array([1.0, 3.0]),\n            \"trials\": 200000,\n            \"seed\": 43\n        },\n        {\n            \"name\": \"C\",\n            \"N\": 7,\n            \"setup\": lambda: (\n                np.array([0.78, 0.92, 1.11, 0.65, 0.84, 1.02, 0.73]),\n                5e12,\n                900.0\n            ),\n            \"trials\": 150000,\n            \"seed\": 44\n        },\n        {\n            \"name\": \"D\",\n            \"N\": 64,\n            \"setup\": lambda: np.array([0 if i % 5 == 0 else 1/(1+i) for i in range(64)]),\n            \"trials\": 100000,\n            \"seed\": 45\n        },\n        {\n            \"name\": \"E\",\n            \"N\": 256,\n            \"setup\": lambda: (\n                np.array([0.5 + 0.3 * math.sin(i) + 0.2 * ((i % 13) / 13) for i in range(256)]),\n                1e13,\n                1000.0\n            ),\n            \"trials\": 50000,\n            \"seed\": 46\n        },\n        {\n            \"name\": \"F\",\n            \"N\": 16,\n            \"setup\": lambda: (\n                np.array([0.6 + 0.25 * math.cos(2 * math.pi * i / 16) for i in range(16)]),\n                1e13,\n                950.0\n            ),\n            \"update\": {\"index\": 7, \"new_E\": 0.45},\n            \"trials\": 150000,\n            \"seed\": 47\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        trials = case[\"trials\"]\n        seed = case[\"seed\"]\n        \n        rates = case.get(\"rates\", None)\n        if \"setup\" in case:\n            setup_val = case[\"setup\"]()\n            if isinstance(setup_val, tuple): # Arrhenius rates\n                E_barriers, nu, T = setup_val\n                rates = nu * np.exp(-E_barriers / (KB_EV_K * T))\n            else: # Directly computed rates\n                rates = setup_val\n        \n        rng = np.random.default_rng(seed)\n        \n        tree = SegmentTree(rates)\n        \n        if \"update\" in case:\n            update_info = case[\"update\"]\n            E_barriers, nu, T = case[\"setup\"]()\n            new_E = update_info[\"new_E\"]\n            idx_to_update = update_info[\"index\"]\n            new_rate = nu * np.exp(-new_E / (KB_EV_K * T))\n            rates[idx_to_update] = new_rate\n            tree.update(idx_to_update, new_rate)\n            \n        counts = np.zeros(N, dtype=np.int64)\n        max_visits = 0\n        \n        for _ in range(trials):\n            event_index, visits = tree.select(rng)\n            if event_index is not None and event_index  N:\n                counts[event_index] += 1\n            if visits > max_visits:\n                max_visits = visits\n        \n        total_rate = tree.get_total_rate()\n        \n        if total_rate > 0:\n            p_theoretical = rates / total_rate\n            p_empirical = counts / trials\n            max_abs_error = np.max(np.abs(p_empirical - p_theoretical))\n        else: # Handle case with all zero rates, though not expected in tests\n            max_abs_error = 0.0\n\n        results.extend([max_abs_error, max_visits])\n        \n    # Format the final output string\n    formatted_results = []\n    for i in range(0, len(results), 2):\n        formatted_results.append(f\"{results[i]},{results[i+1]}\")\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "拥有一个高效的kMC引擎后，我们必须确保其在物理上是正确的，能够准确地对系统的热力学平衡态进行抽样。细致平衡原理是这一保证的基石，它确保了模拟在长时间演化后会收敛到正确的玻尔兹曼分布。本练习要求您搭建一个kMC模拟，通过数值实验来检验细致平衡条件是否得到满足，从而验证模拟代码的物理有效性。",
            "id": "3747955",
            "problem": "您需要实现一个数值协议，以验证一组代表高熵合金 (HEAs) 中空位介导扩散和沉淀动力学的小型动力学过程的细致平衡。您的验证必须基于使用连续时间动理学蒙特卡洛 (kMC) 模拟来测量所选状态对的正向和反向跃迁概率。实现必须是自包含的，无需外部输入，并为提供的测试套件生成所要求的结果。\n\n使用的基本原理：\n- 动理学蒙特卡洛 (kMC) 定义了一个在微观态 $i \\in \\{0,1,\\dots\\}$ 上的连续时间马尔可夫过程，其中包含状态能量 $E_i$ 和到相邻状态 $j$ 的跃迁速率 $r_{i \\to j}$。\n- 在温度为 $T$ (单位为开尔文) 的正则系综平衡下，微观态 $i$ 的稳态概率与玻尔兹曼因子成正比，$\\pi_i \\propto \\exp(-\\beta E_i)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，玻尔兹曼常数 $k_{\\mathrm{B}}$ 的单位为电子伏特每开尔文。\n- 过渡态理论 (TST) 为活化跃迁提供了阿伦尼乌斯形式的速率：$r_{i \\to j} = \\nu_{i \\to j} \\exp(-\\beta (E_{ij}^{\\ddagger} - E_i))$，其中 $\\nu_{i \\to j}$ 是尝试频率 (单位为 $\\mathrm{s}^{-1}$)，$E_{ij}^{\\ddagger}$ 是连接 $i$ 和 $j$ 的反应坐标上的过渡态能量 (单位为 $\\mathrm{eV}$)。\n\n待数值验证的细致平衡定义：\n- 当且仅当对于每一对连通的微观态 $(i,j)$，都有 $\\pi_i r_{i \\to j} = \\pi_j r_{j \\to i}$ 时，一个马尔可夫过程满足相对于正则分布的细致平衡。\n\n待实现的协议：\n- 将每个测试案例构建为一个微观态的小型网络，其中包含指定的能量 $E_i$ (单位为 $\\mathrm{eV}$) 和赋予了过渡态能量 $E_{ij}^{\\ddagger}$ (单位为 $\\mathrm{eV}$) 的无向边 $(i,j)$。为每条边定义尝试频率 $\\nu_{i \\to j}$ (单位为 $\\mathrm{s}^{-1}$)。对称物理模型使用 $\\nu_{i \\to j} = \\nu_{j \\to i}$；故意破坏的模型使用 $\\nu_{i \\to j} \\neq \\nu_{j \\to i}$。\n- 使用 Gillespie 算法模拟 kMC：\n  - 在当前状态 $i$，使用上面的阿伦尼乌斯形式计算所有到邻居 $j$ 的出射速率 $r_{i \\to j}$。\n  - 总速率为 $R_i = \\sum_j r_{i \\to j}$。从均值为 $1/R_i$ 的指数分布中抽取一个等待时间 $\\Delta t$，并将其加到状态 $i$ 的驻留时间中。\n  - 以概率 $r_{i \\to j}/R_i$ 选择下一个状态 $j$，前进到 $j$，并记录一次 $i \\to j$ 的跃迁。\n- 使用指定数量的事件进行预烧，让过程接近稳态；然后收集统计数据：\n  - 对于每个选定的对 $(i,j)$，计算预烧后的正向跃迁数 $N_{i \\to j}$ 和反向跃迁数 $N_{j \\to i}$。\n  - 累积预烧后的驻留时间 $\\tau_i$ 和 $\\tau_j$。\n- 对每对 $(i,j)$ 定义两个用于细致平衡的数值检验：\n  1. 通量对称性检验：正向/反向通量相等意味着在稳态下 $N_{i \\to j} \\approx N_{j \\to i}$。量化相对差异 $\\delta_{\\mathrm{flux}} = |N_{i \\to j} - N_{j \\to i}|/(N_{i \\to j}+N_{j \\to i})$。\n  2. 速率比一致性检验：当微观可逆性成立时，阿伦尼乌斯形式和玻尔兹曼形式意味着 $r_{i \\to j}/r_{j \\to i} = \\exp(-\\beta (E_j - E_i))$。通过经验估计速率为 $\\hat{r}_{i \\to j} = N_{i \\to j}/\\tau_i$ 和 $\\hat{r}_{j \\to i} = N_{j \\to i}/\\tau_j$，并通过计算相对偏差 $\\delta_{\\mathrm{rate}} = \\left|\\frac{(\\hat{r}_{i \\to j}/\\hat{r}_{j \\to i})}{\\exp(-\\beta (E_j - E_i))} - 1\\right|$ 来比较 $\\hat{r}_{i \\to j}/\\hat{r}_{j \\to i}$ 和 $\\exp(-\\beta (E_j - E_i))$。\n- 如果一对 $(i,j)$ 的 $\\delta_{\\mathrm{flux}}$ 和 $\\delta_{\\mathrm{rate}}$ 均低于选定的容差，则该对通过检验。\n\n单位：\n- 能量 $E_i$ 和 $E_{ij}^{\\ddagger}$ 必须以电子伏特 ($\\mathrm{eV}$) 为单位。\n- 温度 $T$ 必须以开尔文 ($\\mathrm{K}$) 为单位。\n- 尝试频率 $\\nu_{i \\to j}$ 必须以反秒 ($\\mathrm{s}^{-1}$) 为单位。\n- 将最终程序输出报告为布尔值，它们是无单位的。\n\n待实现和模拟的测试套件：\n- 案例 $1$ (正常路径，对称双态)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.0$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.4$ $\\mathrm{eV}$，$\\nu_{0 \\to 1} = \\nu_{1 \\to 0} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1000$ $\\mathrm{K}$，选定对 $(0,1)$，模拟 $200000$ 次预烧后事件。\n- 案例 $2$ (正常路径，非对称能量双态)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.2$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.5$ $\\mathrm{eV}$，$\\nu_{0 \\to 1} = \\nu_{1 \\to 0} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1000$ $\\mathrm{K}$，选定对 $(0,1)$，模拟 $250000$ 次预烧后事件。\n- 案例 $3$ (边界情况，破坏的微观可逆性)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.2$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.5$ $\\mathrm{eV}$，$\\nu_{0 \\to 1} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$\\nu_{1 \\to 0} = 2.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1000$ $\\mathrm{K}$，选定对 $(0,1)$，模拟 $250000$ 次预烧后事件。\n- 案例 $4$ (多态覆盖)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.1$ $\\mathrm{eV}$，$E_2 = 0.3$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.4$ $\\mathrm{eV}$ 和边 $(1,2)$ 的 $E_{12}^{\\ddagger} = 0.6$ $\\mathrm{eV}$，两者的 $\\nu_{i \\to j} = \\nu_{j \\to i} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1200$ $\\mathrm{K}$，选定对 $(0,1)$ 和 $(1,2)$，模拟 $400000$ 次预烧后事件。\n\n通过/失败的容差：\n- 通量容差 $\\delta_{\\mathrm{flux}}^{\\max} = 0.03$。\n- 速率比容差 $\\delta_{\\mathrm{rate}}^{\\max} = 0.05$。\n\n最终输出规范：\n- 对于每个案例，计算一个布尔值，指示所有选定的对是否都通过了两个检验。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3}]$，其中每个 ${\\text{result}_k}$ 是 $True$ 或 $False$。最终输出必须严格匹配此格式，并按案例 $1$ 到 $4$ 的顺序包含四个条目。",
            "solution": "用户提供了一个问题，要求实现一个动理学蒙特卡洛 (kMC) 模拟，以数值方式验证几个小状态系统的细致平衡原理。该问题具有坚实的科学基础，定义严谨，并且在计算上是可行的。\n\n### **问题验证**\n\n**第 1 步：提取给定条件**\n\n*   **物理模型**：在微观态 $i$ 上的连续时间马尔可夫过程，其能量为 $E_i$。稳态概率 $\\pi_i \\propto \\exp(-\\beta E_i)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。\n*   **跃迁动力学**：过渡态理论 (TST)，其阿伦尼乌斯速率为 $r_{i \\to j} = \\nu_{i \\to j} \\exp(-\\beta (E_{ij}^{\\ddagger} - E_i))$，其中 $E_{ij}^{\\ddagger}$ 是过渡态能量，$\\nu_{i \\to j}$ 是尝试频率。\n*   **基本原理**：细致平衡由 $\\pi_i r_{i \\to j} = \\pi_j r_{j \\to i}$ 定义，适用于所有连通的状态对 $(i,j)$。\n*   **模拟算法**：Gillespie kMC 算法（驻留时间从指数分布中抽取，下一个状态通过速率加权概率选择）。\n*   **数值验证协议**：\n    1.  **通量对称性检验**：使用模拟中的跃迁计数 $N_{i \\to j}$ 计算 $\\delta_{\\mathrm{flux}} = |N_{i \\to j} - N_{j \\to i}|/(N_{i \\to j}+N_{j \\to i})$。\n    2.  **速率比一致性检验**：使用从计数和驻留时间 $\\tau_i$ 导出的经验速率 $\\hat{r}_{i \\to j} = N_{i \\to j}/\\tau_i$ 计算 $\\delta_{\\mathrm{rate}} = \\left|\\frac{(\\hat{r}_{i \\to j}/\\hat{r}_{j \\to i})}{\\exp(-\\beta (E_j - E_i))} - 1\\right|$。\n*   **容差**：$\\delta_{\\mathrm{flux}}^{\\max} = 0.03$，$\\delta_{\\mathrm{rate}}^{\\max} = 0.05$。\n*   **测试套件**：为四个特定案例定义了所有必要的参数：状态能量 $E_i$、过渡态能量 $E_{ij}^{\\ddagger}$、尝试频率 $\\nu_{i \\to j}$、温度 $T$、要检查的对以及预烧后的模拟事件数。\n*   **常数与单位**：能量单位为 $\\mathrm{eV}$，温度单位为 $\\mathrm{K}$，频率单位为 $\\mathrm{s}^{-1}$，玻尔兹曼常数 $k_{\\mathrm{B}}$ 使用的单位为 $\\mathrm{eV/K}$。\n\n**第 2 步：使用提取的给定条件进行验证**\n\n根据验证标准对问题进行审查：\n\n*   **科学基础**：该问题基于统计力学和化学动力学的基本原理。kMC 方法是模拟随机过程的标准、严谨的计算技术。前提和检验在科学上是合理的。\n*   **定义明确**：每个测试案例的所有参数（$E_i, E_{ij}^{\\ddagger}, \\nu_{i \\to j}, T$）、模拟时长和验证标准（容差）都已明确定义。这确保了可以为每个案例确定一个唯一且有意义的布尔结果。\n*   **客观性**：问题以精确、定量的术语陈述，没有任何主观或模棱两可的语言。\n*   **完整性和一致性**：问题是自包含的。提供的数据足以执行模拟和验证。一个次要细节，即预烧事件的数量，未被指定。然而，由于系统很小且混合迅速，任何合理的选择（例如 $10^4$ 个事件）都足以达到稳态，并不构成缺陷。问题在内部是一致的。\n*   **可行性**：所有指定的参数都在物理上实际的范围内。所需的模拟事件数量在标准计算机上是计算上可行的。\n*   **概念深度**：问题并非微不足道。它要求正确实现 Gillespie 算法，并对细致平衡有深刻的理解，特别是稳态（通过通量平衡检验）和热力学一致性（通过速率比测试检验）之间的区别，这一点在案例 $3$ 中得到了强调。\n\n**第 3 步：结论与行动**\n\n问题陈述是**有效的**。这是一个定义明确且科学合理的数值问题。我现在将着手构建完整的解决方案。\n\n### **解决方案实现**\n\n解决方案的核心是一个函数，它为给定的系统执行 kMC 模拟，然后应用两个验证检验。\n\n**1. 系统表示**\n每个测试案例都由其系统拓扑和能量学定义。一个合适的表示是一组字典和数组：状态能量 $E_i$、表示连接的邻接表，以及用于过渡态能量 $E_{ij}^{\\ddagger}$ 和尝试频率 $\\nu_{i \\to j}$ 的字典。\n\n**2. kMC 模拟（Gillespie 算法）**\n模拟以离散事件的方式进行。在每一步，从当前状态 $i$：\n*   使用阿伦尼乌斯公式计算所有可能的到邻居状态 $j$ 的出射跃迁速率 $r_{i \\to j}$：$r_{i \\to j} = \\nu_{i \\to j} \\exp\\left(-\\frac{E_{ij}^{\\ddagger} - E_i}{k_{\\mathrm{B}}T}\\right)$。\n*   离开状态 $i$ 的总速率是所有单个速率的总和，$R_i = \\sum_j r_{i \\to j}$。如果 $R_i = 0$，系统处于汇点状态，模拟终止。\n*   从均值为 $1/R_i$ 的指数分布中抽取一个时间步长 $\\Delta t$。这通过计算 $\\Delta t = -\\ln(u_1) / R_i$ 实现，其中 $u_1$ 是在 $(0, 1]$ 上均匀分布的随机数。\n*   下一个状态 $j$ 以与其速率成正比的概率 $p(j) = r_{i \\to j}/R_i$ 被选择。这使用基于第二个均匀随机数 $u_2 \\in (0, 1]$ 的“轮盘赌”选择来实现。\n*   系统时间前进 $\\Delta t$，当前状态变为 $j$。\n*   为了进行统计分析，我们记录在前一个状态 $i$ 的驻留时间 $\\Delta t$ 并对跃迁 $i \\to j$ 进行计数。\n\n使用 $10,000$ 个事件的预烧期，以确保系统在收集统计数据之前达到其稳态分布。\n\n**3. 验证检验**\n模拟完成后，使用收集到的统计数据——跃迁计数 $N_{i \\to j}$ 和总驻留时间 $\\tau_i$——为每个指定的状态对 $(i, j)$ 执行检验。\n\n*   **通量对称性检验**：计算正向和反向跃迁计数的相对差异 $\\delta_{\\mathrm{flux}} = |N_{i \\to j} - N_{j \\to i}|/(N_{i \\to j}+N_{j \\to i})$。增加了鲁棒性以处理分母为零的（不太可能的）情况。结果与容差 $\\delta_{\\mathrm{flux}}^{\\max} = 0.03$进行比较。\n\n*   **速率比一致性检验**：\n    *   基于玻尔兹曼分布计算理论速率比：$K_{\\text{theory}} = \\exp(-\\beta(E_j - E_i))$。\n    *   从模拟中估计经验速率：$\\hat{r}_{i \\to j} = N_{i \\to j}/\\tau_i$ 和 $\\hat{r}_{j \\to i} = N_{j \\to i}/\\tau_j$。\n    *   经验速率比为 $K_{\\text{empirical}} = \\hat{r}_{i \\to j}/\\hat{r}_{j \\to i}$。\n    *   计算相对偏差：$\\delta_{\\mathrm{rate}} = |K_{\\text{empirical}}/K_{\\text{theory}} - 1|$。\n    *   此检验需要仔细处理潜在的除以零的情况（例如，如果 $\\tau_j=0$ 或 $\\hat{r}_{j \\to i}=0$），这表示未能满足细致平衡条件或采样不足。结果与容差 $\\delta_{\\mathrm{rate}}^{\\max} = 0.05$进行比较。\n\n只有当一个测试案例的**所有**指定对都通过了**两个**检验时，该案例才被视为通过。\n\n**案例分析预测：**\n*   **案例 1 (对称)**：预期通过。$E_0=E_1$ 且 $\\nu_{0 \\to 1}=\\nu_{1 \\to 0}$。系统是完全对称的。\n*   **案例 2 (非对称能量)**：预期通过。能量差异在态布居上造成不对称，但由于微观可逆性成立（$\\nu_{0 \\to 1}=\\nu_{1 \\to 0}$），细致平衡得到满足。\n*   **案例 3 (破坏的微观可逆性)**：预期失败。条件 $\\nu_{0 \\to 1} \\neq \\nu_{1 \\to 0}$ 明确破坏了相对于正则玻尔兹曼分布的细致平衡的基本假设。速率比检验应该能检测到这种差异。通量检验可能仍会通过，因为系统达到了一个具有平衡通量的非平衡稳态。\n*   **案例 4 (多态)**：预期通过。细致平衡是一个局域性质，只要每个连接的微观可逆性得到维持，它就对网络中每一对连通的状态成立，而不管网络中其他状态如何。\n\n最终的实现将把这个逻辑封装到一个脚本中，处理所有四个案例并生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the KMC simulation and verification for all test cases.\n    \"\"\"\n    \n    # Define physical constants and simulation parameters\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n    BURN_IN_EVENTS = 10000\n    FLUX_TOLERANCE = 0.03\n    RATE_RATIO_TOLERANCE = 0.05\n\n    test_cases = [\n        {\n            \"name\": \"Case 1: Symmetric two-state\",\n            \"state_energies\": np.array([0.0, 0.0]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.4, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12}\n            },\n            \"temperature\": 1000.0,\n            \"num_events\": 200000,\n            \"selected_pairs\": [(0, 1)],\n        },\n        {\n            \"name\": \"Case 2: Asymmetric energies two-state\",\n            \"state_energies\": np.array([0.0, 0.2]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.5, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12}\n            },\n            \"temperature\": 1000.0,\n            \"num_events\": 250000,\n            \"selected_pairs\": [(0, 1)],\n        },\n        {\n            \"name\": \"Case 3: Broken microreversibility\",\n            \"state_energies\": np.array([0.0, 0.2]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.5, \"nu_fwd\": 1.0e12, \"nu_bwd\": 2.0e12}\n            },\n            \"temperature\": 1000.0,\n            \"num_events\": 250000,\n            \"selected_pairs\": [(0, 1)],\n        },\n        {\n            \"name\": \"Case 4: Multi-state coverage\",\n            \"state_energies\": np.array([0.0, 0.1, 0.3]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.4, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12},\n                (1, 2): {\"saddle_energy\": 0.6, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12},\n            },\n            \"temperature\": 1200.0,\n            \"num_events\": 400000,\n            \"selected_pairs\": [(0, 1), (1, 2)],\n        },\n    ]\n\n    def run_kmc_case(params):\n        \"\"\"\n        Runs a single KMC simulation and detailed balance check for a given case.\n        \"\"\"\n        state_energies = params[\"state_energies\"]\n        n_states = len(state_energies)\n        T = params[\"temperature\"]\n        beta = 1.0 / (KB_EV_K * T)\n\n        # Build adjacency list and rate info\n        adjacency = [[] for _ in range(n_states)]\n        saddle_energies = {}\n        attempt_freqs = {}\n        for (i, j), edge_data in params[\"edges\"].items():\n            adjacency[i].append(j)\n            adjacency[j].append(i)\n            saddle_energies[(i, j)] = saddle_energies[(j, i)] = edge_data[\"saddle_energy\"]\n            attempt_freqs[(i, j)] = edge_data[\"nu_fwd\"]\n            attempt_freqs[(j, i)] = edge_data[\"nu_bwd\"]\n\n        # KMC simulation state\n        current_state = 0\n        rng = np.random.default_rng(seed=42) # Seed for reproducibility\n\n        # Gillespie step function\n        def gillespie_step(state_idx):\n            neighbors = adjacency[state_idx]\n            if not neighbors:\n                return state_idx, np.inf # Sink state\n\n            rates = []\n            for neighbor_idx in neighbors:\n                E_i = state_energies[state_idx]\n                E_ij_saddle = saddle_energies[(state_idx, neighbor_idx)]\n                barrier = E_ij_saddle - E_i\n                nu = attempt_freqs[(state_idx, neighbor_idx)]\n                rate = nu * np.exp(-beta * barrier)\n                rates.append(rate)\n            \n            total_rate = sum(rates)\n            if total_rate == 0:\n                return state_idx, np.inf\n\n            dt = -np.log(rng.random()) / total_rate\n            \n            # Select next state\n            rand_choice = rng.random() * total_rate\n            cum_rate = 0.0\n            next_state = -1\n            for i, rate in enumerate(rates):\n                cum_rate += rate\n                if rand_choice  cum_rate:\n                    next_state = neighbors[i]\n                    break\n            \n            return next_state, dt\n\n        # --- Simulation Loop ---\n        num_total_events = BURN_IN_EVENTS + params[\"num_events\"]\n        residence_times = np.zeros(n_states)\n        transition_counts = np.zeros((n_states, n_states), dtype=int)\n\n        for event_num in range(num_total_events):\n            next_state, dt = gillespie_step(current_state)\n            \n            # Collect statistics only after burn-in\n            if event_num >= BURN_IN_EVENTS:\n                residence_times[current_state] += dt\n                if next_state != current_state:\n                    transition_counts[current_state, next_state] += 1\n            \n            current_state = next_state\n\n        # --- Verification ---\n        all_pairs_passed = True\n        for i, j in params[\"selected_pairs\"]:\n            # 1. Flux symmetry check\n            N_ij = transition_counts[i, j]\n            N_ji = transition_counts[j, i]\n            \n            flux_check_passed = False\n            total_flux_events = N_ij + N_ji\n            if total_flux_events == 0:\n                # If no transitions occurred, this check is inconclusive but not a failure.\n                flux_check_passed = True\n            else:\n                delta_flux = np.abs(N_ij - N_ji) / total_flux_events\n                if delta_flux = FLUX_TOLERANCE:\n                    flux_check_passed = True\n\n            # 2. Rate-ratio consistency check\n            tau_i = residence_times[i]\n            tau_j = residence_times[j]\n            \n            rate_check_passed = False\n            if tau_i > 0 and tau_j > 0 and N_ji > 0:\n                r_hat_ij = N_ij / tau_i\n                r_hat_ji = N_ji / tau_j\n                \n                if r_hat_ji > 0:\n                    empirical_ratio = r_hat_ij / r_hat_ji\n                    \n                    E_i, E_j = state_energies[i], state_energies[j]\n                    theoretical_ratio = np.exp(-beta * (E_j - E_i))\n                    \n                    if theoretical_ratio > 0:\n                        delta_rate = np.abs(empirical_ratio / theoretical_ratio - 1)\n                        if delta_rate = RATE_RATIO_TOLERANCE:\n                            rate_check_passed = True\n\n            if not (flux_check_passed and rate_check_passed):\n                all_pairs_passed = False\n                break # A single failure is enough for the case\n\n        return all_pairs_passed\n\n    # Run all test cases and collect results\n    results = [run_kmc_case(case) for case in test_cases]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本章的最后一个实践环节将kMC方法应用于实际问题：从模拟输出中提取宏观物理量。在材料科学中，一个常见的目标是计算扩散系数，它量化了原子在晶格中的迁移速率。本练习将引导您分析kMC模拟产生的粒子运动轨迹，利用爱因斯坦关系式和均方位移（MSD）来估算扩散系数，并学习如何评估计算结果的统计不确定性。",
            "id": "3747912",
            "problem": "考虑一个多组分高熵合金（HEA）中各化学物质的各向同性、空位介导的扩散过程，该过程通过动力学蒙特卡洛（kMC）进行建模。kMC的输出是每种物质的粒子位置的时间序列。您的任务分为两部分：首先，从基本原理出发，推导各向同性扩散过程中系综均方位移与时间之间的线性关系，并根据空间维度和扩散系数确定其斜率；其次，设计并实现一个算法，该算法能够根据给定的多物种合成kMC位置轨迹，基于有统计学依据的程序来估计扩散系数，并给出双侧置信区间。\n\n您必须从以下基础出发，并且不得假定任何快捷公式：\n- 在$d$维空间中，各向同性扩散过程的位移$\\mathbf{r}$的概率密度函数$p(\\mathbf{r},t)$满足菲克第二定律 $\\partial_t p(\\mathbf{r},t) = D \\nabla^2 p(\\mathbf{r},t)$，初始条件为$p(\\mathbf{r},0)=\\delta(\\mathbf{r})$，其中$D$是扩散系数，$\\delta$是狄拉克δ函数。\n- 系综均方位移定义为$\\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 p(\\mathbf{r},t) \\,\\mathrm{d}^d \\mathbf{r}$。\n- 对于每种物质，在马尔可夫假设下，于足够粗粒度的时间间隔内，kMC轨迹可被视为具有零均值和有限方差的独立、各向同性增量序列。\n\n程序要求：\n- 为以下测试套件构建合成的kMC输出。在每种情况下，通过在每个坐标上对每个时间间隔$\\Delta t_k$的独立、正态分布的增量求和来模拟粒子位置，对于扩散系数为$D$的物质，其方差为$2 D \\Delta t_k$。位置单位必须为$\\mathrm{m}$，时间单位为$\\mathrm{s}$，扩散系数单位为$\\mathrm{m^2/s}$。请严格使用指定的随机种子以确保可复现性。\n- 对于每种物质，计算系综均方位移时间序列$M(t_k)$，其定义为$M(t_k) = \\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i(t_k) - \\mathbf{r}_i(0)\\|^2$，其中$N$是该物质的粒子数，$\\mathbf{r}_i(t_k)$是粒子$i$在时间$t_k$的位置。\n- 通过对$M(t_k)$与$t_k$进行带截距的普通最小二乘线性回归，然后将斜率映射到$D$，来估计每种物质的扩散系数$D$。使用斜率的标准误差和学生t分布构建$D$的双侧$95\\%$置信区间。所有估计的扩散系数和置信区间边界均以$\\mathrm{m^2/s}$为单位表示。\n- 如果对于某个物质，所有$k$的$M(t_k)$恒为零，则该物质的点估计和置信区间均返回$0$。\n\n测试套件规范：\n- 情况$1$（一般多组分，$d=3$）：三种物质，扩散系数$D = [1.0 \\times 10^{-20},\\, 4.0 \\times 10^{-20},\\, 0.0]\\,\\mathrm{m^2/s}$，粒子数$N = [200,\\, 200,\\, 200]$，维度$d=3$，时间$t_k = k \\Delta t$，其中$k=0,1,\\dots,100$，$\\Delta t = 5.0 \\times 10^{-6}\\,\\mathrm{s}$，随机种子$123$。\n- 情况$2$（平面扩散，$d=2$）：两种物质，扩散系数$D = [1.0 \\times 10^{-18},\\, 3.0 \\times 10^{-19}]\\,\\mathrm{m^2/s}$，粒子数$N = [50,\\, 50]$，维度$d=2$，时间$t_k = k \\Delta t$，其中$k=0,1,\\dots,150$，$\\Delta t = 1.0 \\times 10^{-6}\\,\\mathrm{s}$，随机种子$456$。\n- 情况$3$（边界情况，少粒子，$d=3$）：两种物质，扩散系数$D = [5.0 \\times 10^{-23},\\, 1.0 \\times 10^{-20}]\\,\\mathrm{m^2/s}$，粒子数$N = [5,\\, 5]$，维度$d=3$，时间$t_k = k \\Delta t$，其中$k=0,1,\\dots,40$，$\\Delta t = 2.0 \\times 10^{-5}\\,\\mathrm{s}$，随机种子$789$。\n\n输出规范：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个物种结果列表，每个物种结果必须是包含三个浮点数的列表，顺序为$[\\hat{D},\\, \\mathrm{CI}_{\\mathrm{low}},\\, \\mathrm{CI}_{\\mathrm{high}}]$，单位均为$\\mathrm{m^2/s}$。例如，总输出的形式必须为$[[[d_{11},l_{11},u_{11}],\\dots],[[d_{21},l_{21},u_{21}],\\dots],[[d_{31},l_{31},u_{31}],\\dots]]$，其中$d_{js}$、$l_{js}$和$u_{js}$表示用例$j$中物种$s$的估计值、下界和上界。",
            "solution": "该问题提出了一个双重任务：首先，是对均方位移与扩散系数之间关系的理论推导；其次，是实现一个计算流程，从模拟的粒子轨迹中估计该系数。此问题阐述清晰，具有科学依据，并为完整且可验证的解决方案提供了足够的细节。\n\n### 第一部分：均方位移关系的理论推导\n\n目标是为经历各向同性扩散的物种建立系综均方位移（MSD）$\\langle \\|\\mathbf{r}(t)\\|^2 \\rangle$与时间$t$之间的线性关系。推导从菲克第二定律开始，该定律控制着粒子在时间$t$的位移$\\mathbf{r}$的概率密度函数$p(\\mathbf{r}, t)$的演化。\n\n**1. 基础方程**\n\n给定条件如下：\n-   $d$维空间中的菲克第二定律：\n    $$ \\frac{\\partial p(\\mathbf{r},t)}{\\partial t} = D \\nabla^2 p(\\mathbf{r},t) $$\n    其中$D$是扩散系数，$\\nabla^2$是拉普拉斯算子。\n-   初始条件，表示粒子从原点开始：\n    $$ p(\\mathbf{r}, 0) = \\delta(\\mathbf{r}) $$\n    其中$\\delta(\\mathbf{r})$是$d$维狄拉克δ函数。\n-   系综均方位移的定义：\n    $$ \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} $$\n    其中$\\|\\mathbf{r}\\|^2 = \\sum_{i=1}^{d} r_i^2$是位移向量$\\mathbf{r} = (r_1, r_2, \\dots, r_d)$的欧几里得范数的平方。\n\n**2. MSD的时间导数**\n\n我们通过对其定义式对时间$t$求导来分析MSD的变化率：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} $$\n假设有足够的平滑性，我们可以交换微分和积分算子（莱布尼茨积分法则）：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\frac{\\partial p(\\mathbf{r}, t)}{\\partial t} \\,\\mathrm{d}^d \\mathbf{r} $$\n现在，我们将菲克第二定律代入此表达式：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\left( D \\nabla^2 p(\\mathbf{r}, t) \\right) \\,\\mathrm{d}^d \\mathbf{r} = D \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\nabla^2 p \\,\\mathrm{d}^d \\mathbf{r} $$\n\n**3. 应用格林第二恒等式**\n\n为了计算该积分，我们使用格林第二恒等式，它是多维空间中的一种分部积分。该恒等式表述为：\n$$ \\int_V (f \\nabla^2 g - g \\nabla^2 f) \\,\\mathrm{d}V = \\int_S (f \\nabla g - g \\nabla f) \\cdot \\mathrm{d}\\mathbf{S} $$\n令$f = \\|\\mathbf{r}\\|^2$，$g = p(\\mathbf{r}, t)$，体积$V$为整个空间$\\mathbb{R}^d$。面积分是在无穷远处的边界上进行的。对于扩散过程，概率密度$p(\\mathbf{r}, t)$及其梯度$\\nabla p$必须在$\\|\\mathbf{r}\\| \\to \\infty$时足够快地趋于零。因此，面积分项为零。这样我们得到：\n$$ \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\nabla^2 p \\,\\mathrm{d}^d \\mathbf{r} = \\int_{\\mathbb{R}^d} p \\left(\\nabla^2 \\|\\mathbf{r}\\|^2\\right) \\,\\mathrm{d}^d \\mathbf{r} $$\n现在我们计算$f(\\mathbf{r}) = \\|\\mathbf{r}\\|^2$的拉普拉斯算子：\n$$ \\nabla^2 \\|\\mathbf{r}\\|^2 = \\nabla^2 \\left(\\sum_{i=1}^{d} r_i^2\\right) = \\sum_{i=1}^{d} \\frac{\\partial^2}{\\partial r_i^2} \\left(\\sum_{j=1}^{d} r_j^2\\right) $$\n由于$\\frac{\\partial^2 r_j^2}{\\partial r_i^2} = 2 \\delta_{ij}$（其中$\\delta_{ij}$是克罗内克δ函数），求和变为：\n$$ \\nabla^2 \\|\\mathbf{r}\\|^2 = \\sum_{i=1}^{d} 2 = 2d $$\n位移平方的拉普拉斯算子就是空间维数的两倍。\n\n**4. 最终积分**\n\n将此结果代回MSD时间导数的表达式中：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = D \\int_{\\mathbb{R}^d} p(\\mathbf{r}, t) (2d) \\,\\mathrm{d}^d \\mathbf{r} = 2dD \\int_{\\mathbb{R}^d} p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} $$\n由于$p(\\mathbf{r}, t)$是概率密度函数，根据定义，其在全空间上的积分为1：\n$$ \\int_{\\mathbb{R}^d} p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} = 1 $$\n这使MSD的变化率简化为一个常数：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = 2dD $$\n将这个常微分方程从$0$到$t$对时间进行积分：\n$$ \\int_0^t \\frac{\\mathrm{d}}{\\mathrm{d}\\tau} \\langle \\|\\mathbf{r}(\\tau)\\|^2 \\rangle \\,\\mathrm{d}\\tau = \\int_0^t 2dD \\,\\mathrm{d}\\tau $$\n$$ \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle - \\langle \\|\\mathbf{r}(0)\\|^2 \\rangle = 2dDt $$\n根据初始条件$p(\\mathbf{r}, 0) = \\delta(\\mathbf{r})$，在$t=0$时所有粒子都在原点，所以初始位移及其均方值为零：\n$$ \\langle \\|\\mathbf{r}(0)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\delta(\\mathbf{r}) \\,\\mathrm{d}^d \\mathbf{r} = 0 $$\n因此，我们得到了著名的爱因斯坦扩散关系式：\n$$ \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = 2dDt $$\n这个结果表明均方位移是时间$t$的线性函数。这个线性关系的斜率$m$由$m = 2dD$给出。因此，扩散系数$D$可以从MSD对时间作图的斜率确定：\n$$ D = \\frac{\\text{斜率}}{2d} $$\n\n### 第二部分：扩散系数估计的算法流程\n\n该算法分三个阶段进行：合成数据生成、MSD计算以及扩散系数的统计估计与置信区间。\n\n**1. 合成轨迹生成**\n每个粒子的轨迹被模拟为离散时间的随机游走。粒子$i$在时间步$k+1$的位置由$\\mathbf{r}_i(t_{k+1}) = \\mathbf{r}_i(t_k) + \\Delta\\mathbf{r}_{i,k}$给出，其中$\\Delta\\mathbf{r}_{i,k}$是随机位移向量。对于一个在时间间隔$\\Delta t = t_{k+1}-t_k$内的各向同性扩散过程，$d$个维度上的位移分量是独立同分布的。布朗运动理论的一个基石是，这些增量可以很好地用均值为$0$、方差为$2D\\Delta t$的正态分布来近似。\n因此，对于每个粒子$i$和时间步$k$，我们生成一个位移向量$\\Delta\\mathbf{r}_{i,k}$，其分量$(\\Delta r_1, \\dots, \\Delta r_d)$从$\\mathcal{N}(0, 2D\\Delta t)$中抽取。模拟开始时所有粒子都在原点，即$\\mathbf{r}_i(0) = \\mathbf{0}$。\n\n**2. 均方位移计算**\n对于一个给定的有$N$个粒子的物种，我们首先生成$N$个独立的轨迹$\\{\\mathbf{r}_i(t_k)\\}_{k=0}^{K}$，其中$K$是总时间步数。每个时间$t_k$的系综均方位移通过对所有粒子的位移大小平方取平均来计算：\n$$ M(t_k) = \\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i(t_k) - \\mathbf{r}_i(0)\\|^2 $$\n由于$\\mathbf{r}_i(0) = \\mathbf{0}$，这可以简化为：\n$$ M(t_k) = \\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i(t_k)\\|^2 $$\n这将产生一个MSD值的时间序列$\\{M(t_k)\\}_{k=0}^{K}$。\n\n**3. 参数估计与置信区间**\n根据理论推导，我们期望存在一个线性关系$M(t_k) \\approx b \\cdot t_k + a$，其中理论斜率为$b = 2dD$，理论截距为$a=0$。我们使用普通最小二乘法（OLS）回归从计算出的数据$(t_k, M(t_k))$中估计斜率。\n\n*   **OLS回归**：给定$n=K+1$个数据点$(x_k, y_k) = (t_k, M(t_k))$，斜率估计值$\\hat{b}$由下式给出：\n    $$ \\hat{b} = \\frac{\\sum_{k=0}^{K} (x_k - \\bar{x})(y_k - \\bar{y})}{\\sum_{k=0}^{K} (x_k - \\bar{x})^2} $$\n    其中$\\bar{x}$和$\\bar{y}$是样本均值。扩散系数的估计值$\\hat{D}$则为：\n    $$ \\hat{D} = \\frac{\\hat{b}}{2d} $$\n\n*   **置信区间**：为了量化我们估计的不确定性，我们为$D$构建一个双侧$95\\%$的置信区间。这源于斜率$\\hat{b}$的置信区间。\n    1.  计算拟合的残差：$e_k = y_k - (\\hat{a} + \\hat{b}x_k)$，其中$\\hat{a} = \\bar{y} - \\hat{b}\\bar{x}$。\n    2.  估计残差的方差：$s_e^2 = \\frac{1}{n-2} \\sum_{k=0}^{K} e_k^2$。分母$n-2$表示带截距的简单线性回归的自由度。\n    3.  计算斜率估计的标准误差：\n        $$ SE(\\hat{b}) = \\sqrt{\\frac{s_e^2}{\\sum_{k=0}^{K} (x_k - \\bar{x})^2}} $$\n    4.  真实斜率$b$的置信区间由$\\hat{b} \\pm t_{\\alpha/2, n-2} \\cdot SE(\\hat{b})$给出。对于$95\\%$的置信水平，$\\alpha=0.05$。值$t_{0.025, n-2}$是从具有$n-2$个自由度的学生t分布中得到的临界值。\n    5.  斜率的下界和上界是：\n        $$ \\hat{b}_{\\text{low}} = \\hat{b} - t_{0.025, n-2} \\cdot SE(\\hat{b}) $$\n        $$ \\hat{b}_{\\text{high}} = \\hat{b} + t_{0.025, n-2} \\cdot SE(\\hat{b}) $$\n    6.  最后，将这些界限映射到扩散系数$D$的置信区间：\n        $$ \\mathrm{CI}_{\\mathrm{low}} = \\frac{\\hat{b}_{\\text{low}}}{2d} \\quad \\text{和} \\quad \\mathrm{CI}_{\\mathrm{high}} = \\frac{\\hat{b}_{\\text{high}}}{2d} $$\n    如果一个物种的$D=0$，其轨迹将全为零，导致所有$k$的$M(t_k)=0$。在这种特殊情况下，估计结果为$\\hat{D}=0$，置信区间为$[0, 0]$。这在实现中作为一个特定条件来处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef estimate_diffusion(trajectories: np.ndarray, d: int, times: np.ndarray):\n    \"\"\"\n    Estimates the diffusion coefficient and its 95% CI from particle trajectories.\n\n    Args:\n        trajectories (np.ndarray): Array of particle positions with shape\n                                   (num_timesteps, num_particles, num_dims).\n        d (int): Number of spatial dimensions.\n        times (np.ndarray): Array of time points.\n\n    Returns:\n        list: A list containing [D_est, D_low, D_high].\n    \"\"\"\n    # MSD Calculation: M(t_k) = 1/N * sum_i ||r_i(t_k) - r_i(0)||^2\n    # Since r_i(0) = 0 for all i, this is ||r_i(t_k)||^2\n    squared_displacements = np.sum(trajectories**2, axis=2)\n    msd = np.mean(squared_displacements, axis=1)\n\n    # Handle the case of a non-diffusing species (D=0)\n    if np.all(msd == 0):\n        return [0.0, 0.0, 0.0]\n\n    # Ordinary Least Squares (OLS) regression of msd vs times\n    # Model: msd = intercept + slope * times\n    n = len(times)\n    x = times\n    y = msd\n    \n    # Using OLS formulas for y = a + bx\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    \n    # Calculate slope (b) and intercept (a)\n    ss_xy = np.sum((x - x_mean) * (y - y_mean))\n    ss_xx = np.sum((x - x_mean)**2)\n    \n    if ss_xx == 0: # Should not happen with the given problem constraints\n        return [0.0, 0.0, 0.0]\n\n    slope = ss_xy / ss_xx\n    \n    # Estimate D from the slope: slope = 2*d*D\n    d_est = slope / (2 * d)\n    \n    # Confidence Interval calculation\n    # Degrees of freedom for simple linear regression is n - 2\n    df = n - 2\n    if df = 0: # Not enough data points to compute CI\n        return [d_est, d_est, d_est]\n\n    intercept = y_mean - slope * x_mean\n    y_pred = intercept + slope * x\n    residuals = y - y_pred\n    ssr = np.sum(residuals**2)\n    \n    # Standard error of the slope\n    se_slope = np.sqrt((ssr / df) / ss_xx)\n\n    # Critical t-value for 95% CI\n    alpha = 0.05\n    t_crit = t.ppf(1 - alpha / 2, df)\n\n    # Margin of error for the slope\n    margin_of_error_slope = t_crit * se_slope\n\n    # Confidence interval for the slope\n    slope_low = slope - margin_of_error_slope\n    slope_high = slope + margin_of_error_slope\n    \n    # Map slope CI to D CI\n    d_low = slope_low / (2 * d)\n    d_high = slope_high / (2 * d)\n\n    return [d_est, d_low, d_high]\n\ndef generate_trajectories(D, N, d, times, dt, seed):\n    \"\"\"\n    Generates synthetic particle trajectories for a given species.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    num_timesteps = len(times)\n    \n    if D == 0.0:\n        return np.zeros((num_timesteps, N, d))\n\n    positions = np.zeros((num_timesteps, N, d))\n    std_dev = np.sqrt(2 * D * dt)\n\n    current_pos = np.zeros((N, d))\n    for k in range(1, num_timesteps):\n        increments = rng.normal(loc=0.0, scale=std_dev, size=(N, d))\n        current_pos += increments\n        positions[k, :, :] = current_pos\n        \n    return positions\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"d_coeffs\": [1.0e-20, 4.0e-20, 0.0],\n            \"n_particles\": [200, 200, 200],\n            \"dim\": 3,\n            \"t_steps\": 101,\n            \"dt\": 5.0e-6,\n            \"seed\": 123\n        },\n        {\n            \"d_coeffs\": [1.0e-18, 3.0e-19],\n            \"n_particles\": [50, 50],\n            \"dim\": 2,\n            \"t_steps\": 151,\n            \"dt\": 1.0e-6,\n            \"seed\": 456\n        },\n        {\n            \"d_coeffs\": [5.0e-23, 1.0e-20],\n            \"n_particles\": [5, 5],\n            \"dim\": 3,\n            \"t_steps\": 41,\n            \"dt\": 2.0e-5,\n            \"seed\": 789\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        d_coeffs = case[\"d_coeffs\"]\n        n_particles = case[\"n_particles\"]\n        d = case[\"dim\"]\n        t_steps = case[\"t_steps\"]\n        dt = case[\"dt\"]\n        seed = case[\"seed\"]\n        \n        times = np.arange(t_steps) * dt\n        \n        case_results = []\n        \n        # We need a reproducible source of seeds for each species.\n        # Use the master seed to generate sub-seeds.\n        master_rng = np.random.default_rng(seed)\n        species_seeds = master_rng.integers(low=0, high=2**32, size=len(d_coeffs))\n\n        for i, D in enumerate(d_coeffs):\n            N = n_particles[i]\n            species_seed = species_seeds[i]\n            \n            trajectories = generate_trajectories(D, N, d, times, dt, species_seed)\n            species_result = estimate_diffusion(trajectories, d, times)\n            case_results.append(species_result)\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required.\n    # The str() function in Python adds spaces, which are not desired.\n    # We will build the string manually or use replacement.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}