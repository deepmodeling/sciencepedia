{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导您完成一项基础但核心的热力学积分应用：计算二元合金的混合吉布斯自由能（$G_{\\text{mix}}$）。该实践的核心在于构建一条从简单的、具有解析解的参考态（理想晶格气体）到复杂相互作用目标态（嵌入原子势模型合金）的可逆路径。通过这项练习 ，您将掌握处理参考态以及整合构型熵与相互作用能的关键技能，为后续更复杂的自由能计算打下坚实的基础。",
            "id": "3762471",
            "problem": "您正在使用简化的嵌入原子方法（Embedded Atom Method, EAM）在一维周期性晶格上对二元合金进行建模。设晶格有 $N$ 个格点，具有周期性边界条件和固定的间距 $a$。每个格点 $i \\in \\{0,1,\\dots,N-1\\}$ 被种类为 $\\alpha_i \\in \\{A,B\\}$ 的原子占据，组分由 $N_A$ 和 $N_B$ 固定，且 $N = N_A + N_B$。系统处于恒定温度 $T$ 和体积下，因此相关的热力学势是亥姆霍兹自由能 $A$。对于恒定体积的固体，吉布斯自由能 $G$ 与 $A$ 的差异在于乘积 $pV$；在一个恒定体积的固定晶格模型中，您可以忽略此修正，并用 $A$ 代替 $G$。\n\n您必须基于以下基本定义进行推理：\n- 配分函数为 $Z = \\sum_{\\mathcal{C}} \\exp\\left(-\\beta H(\\mathcal{C})\\right)$，其中求和遍及所有与固定组分一致的微观态 $\\mathcal{C}$，$H(\\mathcal{C})$ 是哈密顿量，$\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数。\n- 亥姆霍兹自由能为 $A = -k_B T \\ln Z$。\n- 对于依赖于耦合参数 $\\lambda \\in [0,1]$ 的哈密顿量 $H_\\lambda$，自由能对 $\\lambda$ 的导数为 $\\frac{\\partial A}{\\partial \\lambda} = \\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda$，其中 $\\langle \\cdot \\rangle_\\lambda$ 表示相对于 $Z_\\lambda = \\sum_{\\mathcal{C}} \\exp\\left(-\\beta H_\\lambda(\\mathcal{C})\\right)$ 的系综平均。\n\n在此问题中，您必须设计并实现一个在无相互作用的晶格气体参考态与由EAM描述的有相互作用的合金之间的热力学积分（Thermodynamic Integration, TI）循环，并用它来计算合金的每个原子的混合吉布斯自由能 $G_{\\text{mix}}/N$，以 $k_B T$ 为单位表示。\n\n两个端点哈密顿量的定义：\n- 无相互作用的晶格气体参考态：对于所有与固定组分一致的构型 $\\mathcal{C}$，$H_{\\text{lg}}(\\mathcal{C}) = 0$。对应的固定组分的参考亥姆霍兹自由能为 $A_{\\text{lg}} = -k_B T \\ln W$，其中 $W$ 是固定组分下不同构型的简并度计数。对于 $N$ 个晶格点上的二元合金，$W = \\frac{N!}{N_A! N_B!}$。\n- 有相互作用的EAM合金：$H_{\\text{eam}}(\\mathcal{C}) = E_{\\text{pair}}(\\mathcal{C}) + E_{\\text{embed}}(\\mathcal{C})$，其中\n  $$E_{\\text{pair}}(\\mathcal{C}) = \\sum_{0 \\le i  j \\le N-1} \\phi_{\\alpha_i \\alpha_j}(r_{ij}), \\quad \\phi_{\\alpha \\beta}(r) = \\varepsilon_{\\alpha \\beta} \\exp\\left(-\\frac{r}{r_0}\\right),$$\n  $$E_{\\text{embed}}(\\mathcal{C}) = \\sum_{i=0}^{N-1} F_{\\alpha_i}\\left(\\rho_i\\right), \\quad F_{\\alpha}(\\rho) = -\\eta_\\alpha \\sqrt{\\rho}, \\quad \\rho_i = \\sum_{\\substack{j=0 \\\\ j \\ne i}}^{N-1} f_{\\alpha_i \\alpha_j}(r_{ij}), \\quad f_{\\alpha \\beta}(r) = c_{\\alpha \\beta} \\exp\\left(-\\frac{r}{r_f}\\right),$$\n其中周期性距离 $r_{ij} = a \\times \\min\\left(|i-j|, N - |i-j|\\right)$。这里 $\\varepsilon_{\\alpha\\beta}$ 是对相互作用参数，$c_{\\alpha\\beta}$ 是电子密度贡献参数，$\\eta_\\alpha$ 是嵌入强度参数，$r_0$、$r_f$ 是衰减长度。\n\n您必须使用线性耦合路径执行TI\n$$H_\\lambda(\\mathcal{C}) = (1 - \\lambda) H_{\\text{lg}}(\\mathcal{C}) + \\lambda H_{\\text{eam}}(\\mathcal{C}), \\quad \\lambda \\in [0,1],$$\n并评估\n$$\\Delta A_{\\text{mix}}^{\\text{TI}} = \\int_0^1 \\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda \\, d\\lambda,$$\n该评估在限制于固定组分 $(N_A, N_B)$ 的混合物构型系综上进行，同样地，也对 $(N_A,N_B) = (N,0)$ 和 $(0,N)$ 的纯系统参考态进行评估。\n\n参考态修正：\n- 组合熵：因为晶格气体参考态的 $H_{\\text{lg}} = 0$，其在固定组分下的亥姆霍兹自由能纯粹是熵性的，$A_{\\text{lg}} = -k_B T \\ln W$。对于混合物和纯参考态，都必须包括此项。\n- 纯元素基线：还必须对纯A和纯B系统执行TI，以正确建立在相同EAM模型和晶格约束下纯参考态的自由能。这些用于计算相对于纯组分的混合自由能。\n- 压强-体积修正：在这个固定体积的晶格模型中，将 $pV$ 贡献设置为零；因此 $G \\approx A$。\n\n最终的目标量是每个原子的混合吉布斯自由能，以 $k_B T$ 为单位：\n$$\\frac{G_{\\text{mix}}}{N k_B T} = \\frac{A_{\\text{lg}}^{\\text{mix}} + \\Delta A_{\\text{mix}}^{\\text{TI}}}{N k_B T} - x_A \\frac{A_{\\text{lg}}^{A} + \\Delta A_{A}^{\\text{TI}}}{N k_B T} - x_B \\frac{A_{\\text{lg}}^{B} + \\Delta A_{B}^{\\text{TI}}}{N k_B T},$$\n其中 $x_A = \\frac{N_A}{N}$，$x_B = \\frac{N_B}{N}$，$A_{\\text{lg}}^{\\text{mix}} = -k_B T \\ln \\frac{N!}{N_A! N_B!}$，$A_{\\text{lg}}^{A} = -k_B T \\ln 1 = 0$，以及 $A_{\\text{lg}}^{B} = -k_B T \\ln 1 = 0$。TI积分通过对固定组分的微观态进行精确枚举以及在 $\\lambda \\in [0,1]$ 上进行数值求积来评估。所有结果应表示为浮点数，代表 $\\frac{G_{\\text{mix}}}{N k_B T}$，并四舍五入到六位小数。\n\n算法要求：\n- 使用A类原子占据的格点索引的组合，为给定的 $(N,N_A)$ 枚举所有不同的微观态 $\\mathcal{C}$；剩余的格点被B类原子占据。\n- 使用提供的EAM定义精确计算 $H_{\\text{eam}}(\\mathcal{C})$。\n- 对于所选求积法则中的每个 $\\lambda$ 节点，使用玻尔兹曼权重 $\\exp(-\\beta H_\\lambda(\\mathcal{C}))$，在受限组分系综上计算系综平均 $\\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda$。\n- 使用足够精确的求积方法（例如，高斯-勒让德求积）在 $\\lambda \\in [0,1]$ 上对系综平均进行积分，以获得混合物和两种纯参考态的 $\\Delta A^{\\text{TI}}$。\n- 使用上述公式组装 $\\frac{G_{\\text{mix}}}{N k_B T}$。\n\n单位规定：\n- 最终结果以每个原子的 $k_B T$ 为单位报告（无量纲），四舍五入到六位小数。不应包含任何物理单位符号。\n\n测试套件：\n实现您的程序，为以下测试用例计算最终量。请完全按照给定的参数集使用。\n1. 中等温度下的正常路径合金：\n   - $N = 4$, $N_A = 2$, $N_B = 2$, $a = 1.0$,\n   - $r_0 = 1.0$, $r_f = 1.0$,\n   - 对相互作用参数: $\\varepsilon_{AA} = -1.0$, $\\varepsilon_{BB} = -0.8$, $\\varepsilon_{AB} = -0.9$,\n   - 密度参数: $c_{AA} = 1.0$, $c_{BB} = 0.9$, $c_{AB} = 0.95$,\n   - 嵌入强度: $\\eta_A = 1.2$, $\\eta_B = 1.0$,\n   - $\\beta = 1.5$.\n2. 用于测试熵主导的高温极限：\n   - 与案例1参数相同，但 $\\beta = 0.01$。\n3. 纯组分边界：\n   - $N = 4$, $N_A = 4$, $N_B = 0$, $a = 1.0$,\n   - $r_0 = 1.0$, $r_f = 1.0$,\n   - 对相互作用参数: $\\varepsilon_{AA} = -1.0$, $\\varepsilon_{BB} = -0.8$, $\\varepsilon_{AB} = -0.9$,\n   - 密度参数: $c_{AA} = 1.0$, $c_{BB} = 0.9$, $c_{AB} = 0.95$,\n   - 嵌入强度: $\\eta_A = 1.2$, $\\eta_B = 1.0$,\n   - $\\beta = 0.5$.\n\n最终输出格式：\n您的程序应生成一行输出，其中包含三个计算结果，每个结果四舍五入到六位小数，以逗号分隔的列表形式包含在方括号内，例如，\"[x1,x2,x3]\"。",
            "solution": "目标是计算一维周期性晶格上二元合金的每个原子的混合吉布斯自由能 $\\frac{G_{\\text{mix}}}{N}$。结果需以 $k_B T$ 为单位表示，因此目标量是无量纲值 $\\frac{G_{\\text{mix}}}{N k_B T}$。计算基于简化的嵌入原子方法（EAM）势，并利用热力学积分（TI）来找出相互作用合金与无相互作用晶格气体参考态之间的自由能差。\n\n混合吉布斯自由能定义为合金的吉布斯自由能与其纯组分吉布斯自由能的加权平均值之间的差。对于固定体积的晶格模型，压强-体积项可以忽略不计，允许使用亥姆霍兹自由能 $A$ 代替吉布斯自由能 $G$。需要实现的公式是：\n$$\n\\frac{G_{\\text{mix}}}{N k_B T} = \\frac{A^{\\text{mix}}}{N k_B T} - x_A \\frac{A^{A}}{N k_B T} - x_B \\frac{A^{B}}{N k_B T}\n$$\n其中 $A^{\\text{mix}}$、$A^{A}$ 和 $A^{B}$ 分别是混合物、纯组分A和纯组分B的亥姆霍兹自由能。摩尔分数为 $x_A = \\frac{N_A}{N}$ 和 $x_B = \\frac{N_B}{N}$。\n\n每个自由能项 $A$ 都由来自无相互作用晶格气体的参考部分 $A_{\\text{lg}}$ 和通过热力学积分获得的开启相互作用的贡献 $\\Delta A^{\\text{TI}}$ 组成。因此，$A = A_{\\text{lg}} + \\Delta A^{\\text{TI}}$。将此代入混合公式得到：\n$$\n\\frac{G_{\\text{mix}}}{N k_B T} = \\frac{A_{\\text{lg}}^{\\text{mix}} + \\Delta A_{\\text{mix}}^{\\text{TI}}}{N k_B T} - x_A \\frac{A_{\\text{lg}}^{A} + \\Delta A_{A}^{\\text{TI}}}{N k_B T} - x_B \\frac{A_{\\text{lg}}^{B} + \\Delta A_{B}^{\\text{TI}}}{N k_B T}\n$$\n\n计算过程是评估此表达式中的每一项。\n\n首先，理想（无相互作用）自由能贡献 $A_{\\text{lg}}$ 来自构型熵。对于一个总共有 $N$ 个格点、其中 $N_A$ 个为A类原子、$N_B$ 个为B类原子的系统，不同构型的数量为 $W = \\frac{N!}{N_A! N_B!}$。对应的自由能为 $A_{\\text{lg}} = -k_B T \\ln W$。\n- 对于混合物，这给出 $A_{\\text{lg}}^{\\text{mix}} = -k_B T \\ln \\frac{N!}{N_A! N_B!}$。\n- 对于纯组分，只有一种构型（$W=1$），所以 $A_{\\text{lg}}^{A} = A_{\\text{lg}}^{B} = -k_B T \\ln 1 = 0$。\n\n因此，每个原子的混合自由能（以 $k_B T$ 为单位）的公式简化为：\n$$\n\\frac{G_{\\text{mix}}}{N k_B T} = -\\frac{1}{N} \\ln\\left(\\frac{N!}{N_A! N_B!}\\right) + \\frac{\\beta}{N} \\left( \\Delta A_{\\text{mix}}^{\\text{TI}} - x_A \\Delta A_{A}^{\\text{TI}} - x_B \\Delta A_{B}^{\\text{TI}} \\right)\n$$\n其中 $\\beta = \\frac{1}{k_B T}$。\n\n其次，项 $\\Delta A^{\\text{TI}}$ 使用热力学积分计算。哈密顿量通过一个参数 $\\lambda \\in [0,1]$ 在无相互作用的晶格气体（$H_{\\text{lg}}=0$）和有相互作用的EAM模型（$H_{\\text{eam}}$）之间进行线性耦合：\n$$\nH_\\lambda(\\mathcal{C}) = (1 - \\lambda) H_{\\text{lg}}(\\mathcal{C}) + \\lambda H_{\\text{eam}}(\\mathcal{C}) = \\lambda H_{\\text{eam}}(\\mathcal{C})\n$$\n自由能的变化由哈密顿量对 $\\lambda$ 的导数的系综平均值的积分给出：\n$$\n\\Delta A^{\\text{TI}} = \\int_0^1 \\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda \\, d\\lambda\n$$\n导数为 $\\frac{\\partial H_\\lambda}{\\partial \\lambda} = H_{\\text{eam}}(\\mathcal{C})$，它与 $\\lambda$ 无关。积分变为：\n$$\n\\Delta A^{\\text{TI}} = \\int_0^1 \\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda \\, d\\lambda\n$$\n其中 $\\langle \\cdot \\rangle_\\lambda$ 表示使用哈密顿量 $H_\\lambda$ 的正则系综平均。\n\n这个积分的数值评估包括两个主要步骤：\n1.  **计算系综平均**：对于给定的 $\\lambda$ 值，被积函数 $\\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda$ 通过对所有与固定组分一致的可能微观态 $\\mathcal{C}$ 进行精确枚举来计算。该平均值是一个玻尔兹曼权重和：\n    $$\n    \\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda = \\frac{\\sum_{\\mathcal{C}} H_{\\text{eam}}(\\mathcal{C}) \\exp(-\\beta H_\\lambda(\\mathcal{C}))}{\\sum_{\\mathcal{C}} \\exp(-\\beta H_\\lambda(\\mathcal{C}))} = \\frac{\\sum_{\\mathcal{C}} H_{\\text{eam}}(\\mathcal{C}) \\exp(-\\beta \\lambda H_{\\text{eam}}(\\mathcal{C}))}{\\sum_{\\mathcal{C}} \\exp(-\\beta \\lambda H_{\\text{eam}}(\\mathcal{C}))}\n    $$\n    对于一个组分为 $(N, N_A)$ 的系统，其微观态集合 $\\{\\mathcal{C}\\}$ 是通过考虑从 $N$ 个格点中选择 $N_A$ 个被A类原子占据的所有组合来生成的。\n\n2.  **数值求积**：在 $\\lambda$ 从 $0$ 到 $1$ 的积分使用高斯-勒让德求积法来近似。这涉及在一组离散的求积节点 $\\lambda_k$ 处评估被积函数 $\\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda$，并用相应的权重 $w_k$ 对结果求和：\n    $$\n    \\Delta A^{\\text{TI}} \\approx \\sum_k w_k' \\left\\langle H_{\\text{eam}} \\right\\rangle_{\\lambda_k'}\n    $$\n    其中 $(\\lambda_k', w_k')$ 是从标准区间 $[-1, 1]$ 转换到 $[0, 1]$ 的节点和权重。\n\n对于每个构型 $\\mathcal{C}$，能量 $H_{\\text{eam}}(\\mathcal{C})$ 根据问题的EAM定义进行计算：\n$$\nH_{\\text{eam}}(\\mathcal{C}) = \\sum_{0 \\le i  j \\le N-1} \\phi_{\\alpha_i \\alpha_j}(r_{ij}) + \\sum_{i=0}^{N-1} F_{\\alpha_i}\\left(\\rho_i\\right)\n$$\n其中对势为 $\\phi_{\\alpha \\beta}(r) = \\varepsilon_{\\alpha \\beta} \\exp(-\\frac{r}{r_0})$，嵌入函数为 $F_{\\alpha}(\\rho) = -\\eta_\\alpha \\sqrt{\\rho}$，电子密度为 $\\rho_i = \\sum_{j \\ne i} f_{\\alpha_i \\alpha_j}(r_{ij})$，其中 $f_{\\alpha \\beta}(r) = c_{\\alpha \\beta} \\exp(-\\frac{r}{r_f})$。距离 $r_{ij}$ 考虑了一维周期性边界条件：$r_{ij} = a \\times \\min(|i-j|, N - |i-j|)$。\n\n总体算法包括：\n1.  对于给定的测试用例 $(N, N_A, \\text{参数}, \\beta)$，确定混合物的组分 $(N, N_A, N_B=N-N_A)$。\n2.  计算理想混合自由能贡献项 $-\\frac{1}{N} \\ln\\left(\\frac{N!}{N_A! N_B!}\\right)$。\n3.  对三个系统执行TI计算以找到 $\\Delta A^{\\text{TI}}$：\n    a. 混合物本身：$(N, N_A)$。\n    b. 纯组分A：$(N, N_A=N)$。\n    c. 纯组分B：$(N, N_A=0)$。\n4.  使用 $\\frac{G_{\\text{mix}}}{N k_B T}$ 的最终表达式组合这些项以获得结果。对于纯组分测试用例（例如，$N_A=N$），混合自由能根据定义为零。\n\n此过程应用于问题陈述中提供的每个测试用例。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln, roots_legendre\nfrom itertools import combinations\nimport math\n\ndef _parse_params(params):\n    \"\"\"\n    Organizes raw parameters into a structured dictionary for easy access.\n    Maps species 'A' and 'B' to indices 0 and 1.\n    \"\"\"\n    p = {\n        'N': params['N'], 'a': params['a'], 'r0': params['r0'], 'rf': params['rf'],\n        'species_map': {'A': 0, 'B': 1},\n        'eps': np.zeros((2, 2)),\n        'c': np.zeros((2, 2)),\n        'eta': np.zeros(2)\n    }\n    p['eps'][0, 0] = params['eps_AA']\n    p['eps'][1, 1] = params['eps_BB']\n    p['eps'][0, 1] = p['eps'][1, 0] = params['eps_AB']\n    p['c'][0, 0] = params['c_AA']\n    p['c'][0, 1] = params['c_AB']\n    p['c'][1, 0] = params['c_AB'] # Assuming c_BA = c_AB from problem context\n    p['c'][1, 1] = params['c_BB']\n    p['eta'][0] = params['eta_A']\n    p['eta'][1] = params['eta_B']\n    return p\n\ndef _calculate_eam_energy(config, params):\n    \"\"\"\n    Calculates the EAM Hamiltonian for a single configuration.\n    config: array of 0s ('A') and 1s ('B').\n    params: structured parameter dictionary.\n    \"\"\"\n    N = params['N']\n    a = params['a']\n    \n    dists = np.zeros((N, N))\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = a * min(j - i, N - (j - i))\n            dists[i, j] = dists[j, i] = dist\n\n    e_pair = 0.0\n    for i in range(N):\n        for j in range(i + 1, N):\n            s_i, s_j = config[i], config[j]\n            phi = params['eps'][s_i, s_j] * np.exp(-dists[i, j] / params['r0'])\n            e_pair += phi\n            \n    rhos = np.zeros(N)\n    for i in range(N):\n        s_i = config[i]\n        for j in range(N):\n            if i == j: continue\n            s_j = config[j]\n            f = params['c'][s_i, s_j] * np.exp(-dists[i, j] / params['rf'])\n            rhos[i] += f\n            \n    e_embed = 0.0\n    for i in range(N):\n        s_i = config[i]\n        rho_i = rhos[i]\n        if rho_i > 0:\n            e_embed -= params['eta'][s_i] * np.sqrt(rho_i)\n            \n    return e_pair + e_embed\n\ndef _perform_ti(N, N_A, p, beta, n_quad=32):\n    \"\"\"\n    Performs thermodynamic integration and returns Delta_A_TI.\n    \"\"\"\n    site_indices = range(N)\n    if 0  N_A  N:\n        a_sites_options = combinations(site_indices, N_A)\n        configurations = [np.array([0 if i in sites else 1 for i in site_indices]) for sites in a_sites_options]\n    elif N_A == N:\n        configurations = [np.zeros(N, dtype=int)]\n    else: # N_A == 0\n        configurations = [np.ones(N, dtype=int)]\n\n    eam_energies = np.array([_calculate_eam_energy(c, p) for c in configurations])\n\n    if np.all(eam_energies == eam_energies[0]):\n        return eam_energies[0]\n\n    nodes, weights = roots_legendre(n_quad)\n    lambda_nodes = 0.5 * (nodes + 1.0)\n    lambda_weights = 0.5 * weights\n    \n    delta_a_ti = 0.0\n    for i in range(n_quad):\n        lam = lambda_nodes[i]\n        w = lambda_weights[i]\n        \n        exponent = -beta * lam * eam_energies\n        max_exponent = np.max(exponent)\n        boltzmann_factors = np.exp(exponent - max_exponent)\n        partition_func = np.sum(boltzmann_factors)\n        \n        if partition_func > 1e-100:\n            avg_eam_energy = np.sum(eam_energies * boltzmann_factors) / partition_func\n        else:\n            avg_eam_energy = eam_energies[np.argmin(lam * eam_energies)]\n            \n        delta_a_ti += w * avg_eam_energy\n    \n    return delta_a_ti\n\ndef _calculate_g_mix(params):\n    \"\"\"\n    Calculates the final mixing Gibbs free energy per atom in units of kT.\n    \"\"\"\n    N = params['N']\n    N_A = params['N_A']\n    N_B = N - N_A\n    beta = params['beta']\n\n    if N_A == 0 or N_A == N:\n        return 0.0\n\n    p = _parse_params(params)\n    \n    log_W = gammaln(N + 1) - gammaln(N_A + 1) - gammaln(N_B + 1)\n    ideal_term = -log_W / N\n\n    delta_a_mix = _perform_ti(N, N_A, p, beta)\n    delta_a_A = _perform_ti(N, N, p, beta)\n    delta_a_B = _perform_ti(N, 0, p, beta)\n\n    x_A = N_A / N\n    x_B = N_B / N\n    \n    ti_term = (beta / N) * (delta_a_mix - x_A * delta_a_A - x_B * delta_a_B)\n\n    return ideal_term + ti_term\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        {\"N\": 4, \"N_A\": 2, \"a\": 1.0, \"r0\": 1.0, \"rf\": 1.0, \"eps_AA\": -1.0, \"eps_BB\": -0.8, \"eps_AB\": -0.9, \"c_AA\": 1.0, \"c_BB\": 0.9, \"c_AB\": 0.95, \"eta_A\": 1.2, \"eta_B\": 1.0, \"beta\": 1.5},\n        {\"N\": 4, \"N_A\": 2, \"a\": 1.0, \"r0\": 1.0, \"rf\": 1.0, \"eps_AA\": -1.0, \"eps_BB\": -0.8, \"eps_AB\": -0.9, \"c_AA\": 1.0, \"c_BB\": 0.9, \"c_AB\": 0.95, \"eta_A\": 1.2, \"eta_B\": 1.0, \"beta\": 0.01},\n        {\"N\": 4, \"N_A\": 4, \"a\": 1.0, \"r0\": 1.0, \"rf\": 1.0, \"eps_AA\": -1.0, \"eps_BB\": -0.8, \"eps_AB\": -0.9, \"c_AA\": 1.0, \"c_BB\": 0.9, \"c_AB\": 0.95, \"eta_A\": 1.2, \"eta_B\": 1.0, \"beta\": 0.5},\n    ]\n\n    results = [f\"{_calculate_g_mix(params):.6f}\" for params in test_cases]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的热力学积分流程后，我们必须面对一个关键挑战：在一级相变点附近进行积分。由于滞后效应和路径的不可逆性，直接跨越相变点的积分是无效的。本练习  通过一个概念模型清晰地揭示了这一失效的机理，并引入了标准的解决方案——利用辅助势场构建一个可替代的可逆热力学循环。这对于培养在积分路径上相稳定性无法保证的复杂体系中解决问题的能力至关重要。",
            "id": "3762510",
            "problem": "您正在使用炼金插值法模拟高熵合金中的自由能差。设 Helmholtz 自由能为 $F(\\lambda)$，其中 $\\lambda \\in [0,1]$ 为炼金耦合参数；设配分函数为 $Z(\\lambda)$。您只能使用以下基本原理：$F(\\lambda) = -k_{\\mathrm{B}} T \\ln Z(\\lambda)$，以及在一个平滑路径上，导数 $\\mathrm{d}F/\\mathrm{d\\lambda}$ 等于在固定 $\\lambda$ 下 $\\partial H/\\partial \\lambda$ 的系综平均值，其中 $H$ 是哈密顿量。您必须基于这些事实和一级相变的标准性质（有限尺寸滞后和共存点处的非解析性）进行推理，不得依赖下文明确提供的模型定义之外的任何预先推导的快捷公式。\n\n考虑一个用于炼金路径的有效一维模型，该模型能够捕捉沿 $\\lambda$ 跨越一级相变时热力学积分法失效的情况。该模型规定了热力学积分的被积函数（系综平均值 $\\langle \\partial H/\\partial \\lambda \\rangle$）沿三个分支的行为：\n- 一个在 $[0,1]$ 上解析的平滑单相稳定分支 $g_{\\mu}(\\lambda) \\equiv g_{\\mathrm{smooth}}(\\lambda)$。\n- 一个在 $\\lambda_{\\uparrow}$ 处有不连续点的滞后 $\\lambda$ 递增分支 $g_{\\uparrow}(\\lambda)$。\n- 一个在 $\\lambda_{\\downarrow}$ 处有不连续点的滞后 $\\lambda$ 递减分支 $g_{\\downarrow}(\\lambda)$。\n\n将平滑分支定义为 $g_{\\mathrm{smooth}}(\\lambda) = c_0 + c_1 \\lambda + c_2 \\lambda^2$。设滞后分支由幅值为 $J  0$ 的阶跃不连续性建模，使用 Heaviside 阶跃函数 $\\Theta(x)$，其中当 $x  0$ 时 $\\Theta(x) = 0$，当 $x \\ge 0$ 时 $\\Theta(x) = 1$：\n- $g_{\\uparrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\uparrow})$,\n- $g_{\\downarrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\downarrow})$.\n\n您必须：\n1. 从 $F(\\lambda) = -k_{\\mathrm{B}} T \\ln Z(\\lambda)$ 和热力学积分的平滑性要求出发，解释为何沿 $\\lambda$ 跨越一级相变会使该方法失效，以及 $g_{\\uparrow}$ 和 $g_{\\downarrow}$ 之间的滞后现象如何量化这种失效。\n2. 设计一个热力学循环，通过引入一个辅助场 $\\mu$ 来规避相变，该辅助场能在所有 $\\lambda \\in [0,1]$ 的范围内稳定单一相。该循环如下：\n   - 在状态 $A$（$\\lambda = 0$ 处）施加场，达到 $\\mu = \\mu_*$，\n   - 在固定 $\\mu = \\mu_*$ 的条件下，沿平滑分支 $g_{\\mu}(\\lambda)$ 将 $\\lambda$ 从 $0$ 积分到 $1$，\n   - 在状态 $B$（$\\lambda = 1$ 处）移除场。\n   假设在端点处的场功贡献是线性的，常数为 $s_A$ 和 $s_B$：在 $A$ 点为 $w_A = s_A \\mu_*$，在 $B$ 点为 $w_B = s_B \\mu_*$。则净循环自由能变为 $F_{\\mathrm{cycle}} = \\int_0^1 g_{\\mu}(\\lambda)\\,\\mathrm{d}\\lambda + w_A - w_B$。在 $s_A = s_B$ 的特殊情况下，净场功相互抵消。\n3. 实现一个程序，为每个测试用例计算：\n   - 沿 $g_{\\uparrow}$ 从 $\\lambda = 0$ 到 $\\lambda = 1$ 的直接热力学积分，即数值积分 $\\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda$，\n   - 沿 $g_{\\downarrow}$ 从 $\\lambda = 0$ 到 $\\lambda = 1$ 的直接热力学积分，即数值积分 $\\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda$，\n   - 使用 $g_{\\mu}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda)$ 和 $w_A - w_B = s_A \\mu_* - s_B \\mu_*$ 计算循环自由能 $F_{\\mathrm{cycle}}$。\n   对所有数值积分，使用 $[0,1]$ 上的一个包含 $N = 10001$ 个点的均匀网格和梯形法则。定义一个布尔类型的失效标志 $\\mathrm{invalid} = \\left|\\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda - \\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda\\right|  \\varepsilon$，容差为 $\\varepsilon = 10^{-6}$。\n4. 所有自由能均以 $k_{\\mathrm{B}} T$ 为单位表示（即无量纲数）。报告浮点数值时，不带任何单位符号。不要进行四舍五入；使用默认的浮点数-字符串格式化。\n5. 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个形如 $[F_{\\uparrow}, F_{\\downarrow}, F_{\\mathrm{cycle}}, \\mathrm{invalid}]$ 的列表。\n\n使用以下参数值测试套件，涵盖一般情况、边界条件和边缘情况。每个元组对应于 $(c_0, c_1, c_2, J, \\lambda_{\\uparrow}, \\lambda_{\\downarrow}, \\mu_*, s_A, s_B)$：\n- 情况 1：$(0.5, -0.2, 0.1, 1.0, 0.65, 0.35, 0.8, 0.3, 0.3)$。\n- 情况 2：$(0.2, 0.0, 0.3, 0.5, 0.95, 0.05, 0.6, 0.1, 0.1)$。\n- 情况 3：$(-0.1, 0.4, -0.2, 0.05, 0.5, 0.5, 0.7, 0.2, 0.2)$。\n- 情况 4：$(1.0, -0.5, 0.25, 2.0, 0.8, 0.2, 1.0, 0.4, 0.4)$。\n\n您的程序必须为每种情况计算上述的三个自由能值和失效标志，并按 $[[F_{\\uparrow}^{(1)}, F_{\\downarrow}^{(1)}, F_{\\mathrm{cycle}}^{(1)}, \\mathrm{invalid}^{(1)}],\\ldots,[F_{\\uparrow}^{(4)}, F_{\\downarrow}^{(4)}, F_{\\mathrm{cycle}}^{(4)}, \\mathrm{invalid}^{(4)}]]$ 的格式打印单行输出。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上植根于统计力学和计算化学的原理，定义了所有必要的参数和方法，问题是良定的，并且其表述是客观的。该问题提供了一个概念上合理但简化的模型，用以探究跨越一级相变进行热力学积分时遇到的挑战以及规避这些挑战的标准技术。\n\n按照要求，解决方案分为三部分：关于方法失效的理论解释、对修正性热力学循环的描述以及数值实现的设计。\n\n### 1. 一级相变处热力学积分的失效\n\n两个由炼金耦合参数 $\\lambda = 0$ 和 $\\lambda = 1$ 表征的状态之间的 Helmholtz 自由能差 $\\Delta F$ 由基本热力学积分公式给出。该公式由 Helmholtz 自由能的定义 $F(\\lambda) = -k_{\\mathrm{B}} T \\ln Z(\\lambda)$ 推导而来，其中 $k_{\\mathrm{B}}$ 是 Boltzmann 常数，$T$ 是温度，$Z(\\lambda)$ 是配分函数。$F(\\lambda)$ 对 $\\lambda$ 的导数为：\n$$\n\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda} = \\frac{\\mathrm{d}}{\\mathrm{d}\\lambda} (-k_{\\mathrm{B}} T \\ln Z(\\lambda)) = -k_{\\mathrm{B}} T \\frac{1}{Z(\\lambda)} \\frac{\\mathrm{d}Z}{\\mathrm{d}\\lambda}\n$$\n配分函数为 $Z(\\lambda) = \\int e^{-H(\\mathbf{x};\\lambda)/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}$，其中 $H(\\mathbf{x};\\lambda)$ 是系统的哈密顿量。其导数为 $\\frac{\\mathrm{d}Z}{\\mathrm{d}\\lambda} = \\int \\left(-\\frac{1}{k_{\\mathrm{B}}T} \\frac{\\partial H}{\\partial \\lambda}\\right) e^{-H(\\mathbf{x};\\lambda)/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}$。将此代入 $\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda}$ 的表达式可得：\n$$\n\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda} = -k_{\\mathrm{B}} T \\frac{1}{Z(\\lambda)} \\int \\left(-\\frac{1}{k_{\\mathrm{B}}T} \\frac{\\partial H}{\\partial \\lambda}\\right) e^{-H/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x} = \\frac{\\int \\frac{\\partial H}{\\partial \\lambda} e^{-H/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}}{\\int e^{-H/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}} = \\left\\langle \\frac{\\partial H}{\\partial \\lambda} \\right\\rangle_{\\lambda}\n$$\n这表明自由能的导数是哈密顿量导数的系综平均。根据微积分基本定理，总自由能差是其导数的积分：\n$$\n\\Delta F = F(\\lambda=1) - F(\\lambda=0) = \\int_0^1 \\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda} \\mathrm{d}\\lambda = \\int_0^1 \\left\\langle \\frac{\\partial H}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\mathrm{d}\\lambda\n$$\n仅当 $\\lambda=0$ 和 $\\lambda=1$ 之间的路径是热力学可逆时，该积分才有效。在某个 $\\lambda_c \\in (0,1)$ 处的一级相变的特征是自由能的一阶导数 $\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda}$ 存在不连续性。这意味着被积函数 $\\left\\langle \\frac{\\partial H}{\\partial \\lambda} \\right\\rangle$ 是不连续的。任何以有限速率跨越这种不连续性的过程本质上都是不可逆的。\n\n在有限尺寸的系统模拟中，这种非解析性表现为滞后现象。当增加 $\\lambda$（正向路径）时，系统越过相变点 $\\lambda_c$ 后会保持在亚稳态，然后在 $\\lambda_{\\uparrow}  \\lambda_c$ 处突然切换到新相。当减小 $\\lambda$（反向路径）时，系统再次保持在亚稳态，然后在 $\\lambda_{\\downarrow}  \\lambda_c$ 处切换回来。这导致根据模拟方向的不同，测量到两个不同的被积函数 $g_{\\uparrow}(\\lambda)$ 和 $g_{\\downarrow}(\\lambda)$。\n\n因此，计算积分会得到两个不同的结果：\n$$\n\\Delta F_{\\uparrow} = \\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda \\neq \\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda = \\Delta F_{\\downarrow}\n$$\n由于自由能是状态函数，其变化量 $\\Delta F$ 必须与所取路径无关。$\\Delta F_{\\uparrow} \\neq \\Delta F_{\\downarrow}$ 这一事实证明了两个计算都是不正确的，并且直接热力学积分过程已经失效。由两条曲线之间的面积 $\\left| \\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda - \\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda \\right|$ 量化的滞后现象，代表了在不可逆循环中耗散的功，是该方法失效的直接度量。\n\n### 2. 修正性热力学循环\n\n为了获得正确的自由能差，必须在初态（$\\lambda=0$）和末态（$\\lambda=1$）之间构建一条替代的可逆路径。问题描述了这样一条使用辅助场 $\\mu$ 的路径。这就构建了一个热力学循环：\n1.  **路径 1 ($A \\to A'$)：** 在恒定 $\\lambda=0$ 时，施加辅助场，使其从 $\\mu=0$ 变为 $\\mu=\\mu_*$。自由能变化是对系统所做的功，这里给出的是一个线性贡献：$\\Delta F_{A \\to A'} = w_A = s_A \\mu_*$。\n2.  **路径 2 ($A' \\to B'$)：** 在恒定场 $\\mu=\\mu_*$ 下，将炼金参数从 $\\lambda=0$ 变为 $\\lambda=1$。选择的场 $\\mu_*$ 足够强以抑制相变，确保系统在所有 $\\lambda \\in [0,1]$ 范围内都保持在单一的稳定相中。这使得路径变为可逆。被积函数变成平滑的解析函数 $g_{\\mu}(\\lambda) \\equiv g_{\\mathrm{smooth}}(\\lambda)$。该路径的自由能变化为 $\\Delta F_{A' \\to B'} = \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda$。\n3.  **路径 3 ($B' \\to B$)：** 在恒定 $\\lambda=1$ 时，移除辅助场，使其从 $\\mu=\\mu_*$ 变为 $\\mu=0$。自由能变化是在该状态下施加场所需做的功的负值：$\\Delta F_{B' \\to B} = -w_B = -s_B \\mu_*$。\n\n由于自由能是状态函数，沿路径 $A \\to B$ 的总变化量等于沿替代路径 $A \\to A' \\to B' \\to B$ 的变化量之和：\n$$\n\\Delta F_{\\mathrm{cycle}} = F(B) - F(A) = \\Delta F_{A \\to A'} + \\Delta F_{A' \\to B'} + \\Delta F_{B' \\to B}\n$$\n代入每个路径的表达式，得到正确的、与路径无关的自由能差：\n$$\n\\Delta F_{\\mathrm{cycle}} = w_A + \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda - w_B = \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda + (s_A - s_B) \\mu_*\n$$\n这个值 $F_{\\mathrm{cycle}}$ 代表了以 $k_{\\mathrm{B}} T$ 为单位的真实自由能差。在施加和移除场的功相同（$s_A = s_B$）的特殊情况下，功项相互抵消，自由能仅由沿平滑路径的积分给出。\n\n### 3. 数值实现\n\n所需的量通过数值计算得出。自由能以 $k_{\\mathrm{B}} T$ 为单位表示，使其成为无量纲的。\n- 自变量为 $\\lambda$，区间为 $[0,1]$。使用一个包含 $N=10001$ 个点的均匀网格，定义为 $\\lambda_i = i/(N-1)$，其中 $i=0, 1, \\ldots, N-1$。\n- 三个被积函数根据问题陈述定义如下：\n    - $g_{\\mathrm{smooth}}(\\lambda) = c_0 + c_1 \\lambda + c_2 \\lambda^2$\n    - $g_{\\uparrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\uparrow})$\n    - $g_{\\downarrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\downarrow})$\n    其中 Heaviside 函数 $\\Theta(x)$ 的实现为：当 $x \\ge 0$ 时返回 $1$，否则返回 $0$。\n- 积分 $\\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda$（得到 $F_{\\uparrow}$）和 $\\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda$（得到 $F_{\\downarrow}$）通过在离散化函数上使用梯形法则计算。\n- 循环自由能计算为 $F_{\\mathrm{cycle}} = \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda + (s_A - s_B) \\mu_*$，其中积分也使用梯形法则进行评估。\n- 失效标志是一个布尔值，由条件 $\\mathrm{invalid} = |\\Delta F_{\\uparrow} - \\Delta F_{\\downarrow}|  \\varepsilon$ 确定，其中容差 $\\varepsilon$ 为 $10^{-6}$。\n\n对测试套件中提供的每组参数重复此过程。最终输出被组装成一个列表的列表，每个内部列表包含给定测试用例的四个计算值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes free energies for different thermodynamic paths based on a model\n    for thermodynamic integration across a first-order phase transition.\n    \"\"\"\n    # Test cases: tuples of (c0, c1, c2, J, lambda_up, lambda_down, mu_star, sA, sB)\n    test_cases = [\n        (0.5, -0.2, 0.1, 1.0, 0.65, 0.35, 0.8, 0.3, 0.3),\n        (0.2, 0.0, 0.3, 0.5, 0.95, 0.05, 0.6, 0.1, 0.1),\n        (-0.1, 0.4, -0.2, 0.05, 0.5, 0.5, 0.7, 0.2, 0.2),\n        (1.0, -0.5, 0.25, 2.0, 0.8, 0.2, 1.0, 0.4, 0.4),\n    ]\n\n    # Numerical integration parameters\n    N = 10001\n    lambdas = np.linspace(0, 1, N)\n    epsilon = 1e-6\n    \n    results = []\n\n    for case in test_cases:\n        c0, c1, c2, J, lambda_up, lambda_down, mu_star, sA, sB = case\n\n        # Define the integrand functions\n        # g_smooth is the polynomial base for the stabilized path\n        g_smooth = c0 + c1 * lambdas + c2 * lambdas**2\n\n        # g_up represents the forward (increasing lambda) hysteretic path\n        # The Heaviside step function is implemented using a boolean comparison\n        g_up = g_smooth + J * (lambdas >= lambda_up)\n\n        # g_down represents the backward (decreasing lambda) hysteretic path\n        g_down = g_smooth + J * (lambdas >= lambda_down)\n\n        # 1. Compute the direct integration along the increasing-lambda path\n        F_up = np.trapz(g_up, lambdas)\n\n        # 2. Compute the direct integration along the decreasing-lambda path\n        F_down = np.trapz(g_down, lambdas)\n\n        # 3. Compute the free energy from the corrective thermodynamic cycle\n        # First, integrate along the smooth, stabilized path\n        integral_smooth = np.trapz(g_smooth, lambdas)\n        # Add the net work done by the auxiliary field\n        F_cycle = integral_smooth + (sA - sB) * mu_star\n\n        # 4. Determine the invalidation flag based on hysteresis\n        is_invalid = abs(F_up - F_down) > epsilon\n        \n        # Collect results for this test case\n        results.append([F_up, F_down, F_cycle, is_invalid])\n\n    # Format the output string precisely as required: [[r1,r2,r3,r4],[...],...]\n    # This involves building the string manually to avoid spaces introduced by str(list).\n    inner_strings = []\n    for res_list in results:\n        # Format each element and join with commas, then wrap in brackets\n        res_str = f\"[{res_list[0]},{res_list[1]},{res_list[2]},{str(res_list[3]).lower()}]\"\n        inner_strings.append(res_str)\n    \n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "任何计算结果的可靠性都取决于其验证过程。最后一个练习强调了计算科学中严谨性和质量控制的重要性。您将为一个具有精确解析解的简谐振子模型实施热力学积分，这使得我们能够直接评估计算的准确性。此练习  的核心要点在于学会将总的数值误差分解为两个主要来源——积分路径离散化引入的求积误差和有限蒙特卡洛采样引入的抽样误差——这是诊断和改进模拟方案的一项关键技能。",
            "id": "3762543",
            "problem": "您需要实现并验证一个热力学积分程序，用于在一个与高熵合金（HEA）相关的、可解析求解的简化模型中计算自由能差。目标是展示一个对照已知解析基准的严格验证周期，并诊断差异是由采样误差还是数值积分误差引起。背景是通过热力学积分（TI）计算自由能，针对代表复杂材料中局部谐振模式的单个构型自由度。\n\n从以下基本原理开始：\n- 正则系综，逆温度 $\\beta = 1/(k_{\\mathrm{B}} T)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，T 是绝对温度。\n- 亥姆霍兹自由能定义为 $F = - k_{\\mathrm{B}} T \\ln Z$，其中 Z 是配分函数。\n- 热力学积分（TI）：定义一个耦合参数 $\\lambda \\in [0,1]$，以及两个状态之间的混合势 $U_{\\lambda}$。端点之间的自由能差 $\\Delta F$ 是通过对广义力的正则系综平均值在 $\\lambda$ 上积分得到的。\n\n模型和路径规范：\n- 考虑一个一维谐振子，其势能为 $U(x) = \\frac{1}{2} k x^2$，其中 $k$ 是刚度参数，单位为 $\\mathrm{N/m}$，$x$ 是位移，单位为 $\\mathrm{m}$。\n- 定义端点刚度 $k_0$ 和 $k_1$，以及一个线性混合路径 $U_{\\lambda}(x) = (1-\\lambda) U_0(x) + \\lambda U_1(x)$，其中 $\\lambda \\in [0,1]$，$U_0(x) = \\frac{1}{2} k_0 x^2$ 且 $U_1(x) = \\frac{1}{2} k_1 x^2$。\n- 根据构造，$U_{\\lambda}(x)$ 是谐波的，其有效刚度为 $k_{\\lambda} = (1-\\lambda) k_0 + \\lambda k_1$。\n\n解析基准要求：\n- 使用正则系综和上述模型，推导出在温度 T 下两个谐振状态之间的解析自由能差 $\\Delta F_{\\mathrm{exact}}$。这需要计算每个端点的配分函数 Z，并基于 $F = -k_{\\mathrm{B}} T \\ln Z$ 构建自由能差。您必须以 $\\mathrm{J}$（焦耳）为单位表示解析的 $\\Delta F_{\\mathrm{exact}}$。\n\n数值 TI 实现要求：\n- 基于 $U_{\\lambda}$ 的定义和广义力的正则系综平均值，实现一个数值 TI 被积函数。使用两种途径：\n  1. 一个从谐振模型和 $U_{\\lambda}(x)$ 的正则平均值推导出的、作为 $\\lambda$ 函数的解析被积函数。\n  2. 在每个 $\\lambda$ 处的蒙特卡洛估计器，它从与 $U_{\\lambda}(x)$ 相关的正则分布中采样 $x$，并通过有限样本均值来近似系综平均值。\n- 使用复合梯形法则和复合辛普森法则对 $\\lambda$ 进行数值积分。使用由 $N_{\\lambda}$ 个点组成的均匀 $\\lambda$ 网格。对于复合辛普森法则，使用奇数个点（偶数个区间）。\n- 量化三种差异（均以 $\\mathrm{J}$ 为单位）：\n  1. 总误差 $E_{\\mathrm{tot}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{exact}}$，其中 $\\Delta F_{\\mathrm{MC}}$ 是使用蒙特卡洛被积函数和所选求积方法得到的 TI 估计值。\n  2. 求积误差 $E_{\\mathrm{quad}} = \\Delta F_{\\mathrm{analytic\\_discrete}} - \\Delta F_{\\mathrm{exact}}$，其中 $\\Delta F_{\\mathrm{analytic\\_discrete}}$ 是通过在离散 $\\lambda$ 网格上使用所选求积方法对解析被积函数进行积分得到的 TI 估计值。\n  3. 采样误差 $E_{\\mathrm{samp}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{analytic\\_discrete}}$，即在相同的求积方法和网格下，蒙特卡洛被积函数与解析被积函数之间的差异。\n- 为每个测试用例提供一个布尔诊断，指示采样误差是否占主导地位：如果 $|E_{\\mathrm{samp}}|  |E_{\\mathrm{quad}}|$，则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n单位和数值细节：\n- 使用 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$。所有自由能和误差均以 $\\mathrm{J}$（焦耳）表示。\n- 如果有角度，使用弧度单位；此处不需要。\n- 蒙特卡洛采样必须从温度 T 下由 $U_{\\lambda}(x)$ 隐含的正则高斯分布中进行；通过固定的伪随机数生成器种子确保可复现性。\n- 数值求积必须以通用方式实现，适用于任何 $N_{\\lambda} \\ge 2$ 的均匀网格；复合辛普森法则要求 $N_{\\lambda}$ 为奇数。\n\n测试套件：\n对于每个测试用例，参数为 $(k_0,\\ k_1,\\ T,\\ N_{\\lambda},\\ N_{\\mathrm{s}},\\ \\text{quadrature})$，其中 $N_{\\mathrm{s}}$ 是每个 $\\lambda$ 点的蒙特卡洛样本数。\n\n- 情况 $1$（一般情况）：$(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 4.0\\ \\mathrm{N/m},\\ T = 300\\ \\mathrm{K},\\ N_{\\lambda} = 21,\\ N_{\\mathrm{s}} = 2000,\\ \\text{quadrature} = \\text{Simpson})$。\n- 情况 $2$（采样受限）：$(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 4.0\\ \\mathrm{N/m},\\ T = 300\\ \\mathrm{K},\\ N_{\\lambda} = 101,\\ N_{\\mathrm{s}} = 50,\\ \\text{quadrature} = \\text{Simpson})$。\n- 情况 $3$（求积受限）：$(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 4.0\\ \\mathrm{N/m},\\ T = 300\\ \\mathrm{K},\\ N_{\\lambda} = 3,\\ N_{\\mathrm{s}} = 20000,\\ \\text{quadrature} = \\text{Trapezoid})$。\n- 情况 $4$（低温下的小刚度对比）：$(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 1.2\\ \\mathrm{N/m},\\ T = 50\\ \\mathrm{K},\\ N_{\\lambda} = 5,\\ N_{\\mathrm{s}} = 5000,\\ \\text{quadrature} = \\text{Trapezoid})$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表形式的结果，并用方括号括起来。每个测试用例的结果本身必须是一个包含四个条目的列表：$[E_{\\mathrm{tot}},\\ |E_{\\mathrm{samp}}|,\\ |E_{\\mathrm{quad}}|,\\ \\text{sampling\\_dominant}]$。例如，包含两个用例的输出将类似于 $[[e_1,\\ s_1,\\ q_1,\\ b_1],[e_2,\\ s_2,\\ q_2,\\ b_2]]$。所有能量值必须以 $\\mathrm{J}$（焦耳）为单位，布尔值必须是 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "问题陈述已经过严格审查，并被认为是有效的。它在科学上基于统计力学原理，问题定义明确，具有客观性和内部一致性。它提出了一个标准的、尽管是简化的场景，用于演示和验证热力学积分（TI）计算，这是计算材料科学中的一项常见任务。因此，我们可以继续进行推导和求解。\n\n解决方案分三个阶段展开：首先，推导自由能差和 TI 被积函数的解析表达式；其次，设计用于 TI 和误差分析的数值程序；第三，用代码实现该程序，以处理特定的测试用例。\n\n### 1. 解析推导\n\n本节通过推导将与数值估计进行比较的精确量，为问题奠定理论基础。\n\n**1.1. 解析自由能差**\n\n模型是一个一维经典谐振子，其势能为 $U(x) = \\frac{1}{2}kx^2$，其中 $x$ 是位移，$k$ 是弹簧常数。系统与温度为 T 的热浴处于热平衡状态。正则配分函数 Z 由下式给出：\n$$ Z = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U(x)) \\, dx $$\n其中 $\\beta = 1/(k_B T)$ 是逆温度，$k_B$ 是玻尔兹曼常数。代入势能，我们得到：\n$$ Z(k, T) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k x^2}{2}\\right) \\, dx $$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\pi/a}$。此处，$a = \\beta k / 2$，所以配分函数为：\n$$ Z(k, T) = \\sqrt{\\frac{2\\pi}{\\beta k}} $$\n亥姆霍兹自由能 F 定义为 $F = -k_B T \\ln Z = -1/\\beta \\ln Z$。\n$$ F(k, T) = -\\frac{1}{\\beta} \\ln\\left(\\sqrt{\\frac{2\\pi}{\\beta k}}\\right) = -\\frac{1}{2\\beta} \\ln\\left(\\frac{2\\pi}{\\beta k}\\right) = \\frac{1}{2\\beta} \\ln\\left(\\frac{\\beta k}{2\\pi}\\right) $$\n代入 $\\beta = 1/(k_B T)$：\n$$ F(k, T) = \\frac{k_B T}{2} \\ln\\left(\\frac{k}{2\\pi k_B T}\\right) $$\n问题要求的是在相同温度 T 下，两个弹簧常数分别为 $k_1$ 和 $k_0$ 的状态之间的自由能差 $\\Delta F = F_1 - F_0$。\n$$ \\Delta F_{\\mathrm{exact}} = F(k_1, T) - F(k_0, T) = \\frac{k_B T}{2} \\ln\\left(\\frac{k_1}{2\\pi k_B T}\\right) - \\frac{k_B T}{2} \\ln\\left(\\frac{k_0}{2\\pi k_B T}\\right) $$\n利用对数的性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$，我们得到精确的解析自由能差：\n$$ \\Delta F_{\\mathrm{exact}} = \\frac{k_B T}{2} \\ln\\left(\\frac{k_1}{k_0}\\right) $$\n该表达式将作为我们进行验证的精确基准。\n\n**1.2. 解析热力学积分被积函数**\n\n热力学积分通过沿耦合参数 $\\lambda$ 定义的路径对广义力的系综平均值进行积分来计算自由能差。依赖于路径的势能由 $U_{\\lambda}(x) = (1-\\lambda)U_0(x) + \\lambda U_1(x)$ 给出，其中 $U_i(x) = \\frac{1}{2}k_i x^2$。\n$$ U_{\\lambda}(x) = \\frac{1}{2} \\left( (1-\\lambda)k_0 + \\lambda k_1 \\right) x^2 = \\frac{1}{2} k_{\\lambda} x^2 $$\n这里，$k_{\\lambda} = (1-\\lambda)k_0 + \\lambda k_1$ 是依赖于 $\\lambda$ 的有效弹簧常数。自由能差为：\n$$ \\Delta F = \\int_0^1 \\left\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\right\\rangle_{\\lambda} d\\lambda $$\n积分内的项就是被积函数。首先，我们计算 $U_{\\lambda}(x)$ 关于 $\\lambda$ 的偏导数：\n$$ \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda} \\left[ \\frac{1}{2} ((1-\\lambda)k_0 + \\lambda k_1) x^2 \\right] = \\frac{1}{2} (-k_0 + k_1) x^2 = \\frac{1}{2} (k_1 - k_0) x^2 $$\n接下来，我们必须找到由势能 $U_{\\lambda}(x)$ 控制的系统的 $x^2$ 的正则系综平均值，记为 $\\langle x^2 \\rangle_{\\lambda}$。根据能量均分定理，一维二次自由度的平均势能为 $\\frac{1}{2}k_B T$。\n$$ \\langle U_{\\lambda}(x) \\rangle_{\\lambda} = \\left\\langle \\frac{1}{2} k_{\\lambda} x^2 \\right\\rangle_{\\lambda} = \\frac{1}{2} k_{\\lambda} \\langle x^2 \\rangle_{\\lambda} = \\frac{1}{2} k_B T $$\n解出 $\\langle x^2 \\rangle_{\\lambda}$ 得：\n$$ \\langle x^2 \\rangle_{\\lambda} = \\frac{k_B T}{k_{\\lambda}} = \\frac{k_B T}{(1-\\lambda)k_0 + \\lambda k_1} $$\n这个结果也可以通过直接积分 $\\langle x^2 \\rangle_{\\lambda} = (\\int x^2 e^{-\\beta U_{\\lambda}(x)} dx) / Z_{\\lambda}$ 得到。\n现在，我们可以写出 TI 被积函数的解析表达式，我们将其表示为 $I(\\lambda)$：\n$$ I(\\lambda) = \\left\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\frac{1}{2} (k_1 - k_0) \\langle x^2 \\rangle_{\\lambda} = \\frac{k_B T (k_1 - k_0)}{2((1-\\lambda)k_0 + \\lambda k_1)} $$\n将这个解析被积函数从 $\\lambda=0$ 积分到 $\\lambda=1$，可以正确地恢复之前推导的 $\\Delta F_{\\mathrm{exact}}$，这证实了我们框架的一致性。\n\n### 2. 数值程序与误差分析\n\n**2.1. 数值求积**\n\n积分 $\\Delta F = \\int_0^1 I(\\lambda) d\\lambda$ 将使用两种方法在一个包含 $N_{\\lambda}$ 个点的均匀网格上进行数值计算，$\\lambda_i = i/(N_{\\lambda}-1)$ for $i = 0, \\ldots, N_{\\lambda}-1$。\n- **复合梯形法则：** 将积分近似为曲线下梯形面积之和。\n- **复合辛普森法则：** 一种更高阶的方法，用二次多项式拟合曲线段，要求点数（$N_{\\lambda}$）为奇数。\n\n**2.2. 蒙特卡洛估计器**\n对于给定的 $\\lambda_i$，系综平均值 $\\langle \\frac{\\partial U_{\\lambda}}{\\partial \\lambda} \\rangle_{\\lambda_i}$ 使用蒙特卡洛（MC）程序进行估计。$x$ 的概率分布是一个高斯分布，$p_{\\lambda_i}(x) \\propto \\exp(-\\beta U_{\\lambda_i}(x))$，其均值为 0，方差为 $\\sigma_{\\lambda_i}^2 = \\langle x^2 \\rangle_{\\lambda_i} = k_B T / k_{\\lambda_i}$。\n我们从这个分布 $x_j \\sim \\mathcal{N}(0, \\sigma_{\\lambda_i}^2)$ 中生成 $N_s$ 个样本 $\\{x_j\\}$。被积函数的 MC 估计器为：\n$$ \\left\\langle \\frac{\\partial U_{\\lambda_i}}{\\partial \\lambda_i} \\right\\rangle^{\\mathrm{MC}}_{\\lambda_i} = \\frac{1}{N_s} \\sum_{j=1}^{N_s} \\frac{1}{2} (k_1 - k_0) x_j^2 = \\frac{1}{2} (k_1 - k_0) \\left( \\frac{1}{N_s} \\sum_{j=1}^{N_s} x_j^2 \\right) $$\n\n**2.3. 误差分解**\n\n我们量化各种估计值与精确结果之间的差异：\n- $\\Delta F_{\\mathrm{exact}}$：真实解析值，$\\frac{k_B T}{2} \\ln(k_1/k_0)$。\n- $\\Delta F_{\\mathrm{analytic\\_discrete}}$：在离散 $\\lambda$ 网格上对解析被积函数 $I(\\lambda)$ 进行数值积分得到的结果。\n- $\\Delta F_{\\mathrm{MC}}$：在相同的离散 $\\lambda$ 网格上对 MC 估计的被积函数进行数值积分得到的结果。\n\n误差定义如下：\n1.  **总误差 ($E_{\\mathrm{tot}}$):** 完整数值模拟与真实值之间的总体偏差。\n    $$ E_{\\mathrm{tot}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{exact}} $$\n2.  **求积误差 ($E_{\\mathrm{quad}}$):** 仅由 $\\lambda$ 积分的离散化引起的误差。它是精确值与将求积法则应用于精确被积函数的结果之间的差。\n    $$ E_{\\mathrm{quad}} = \\Delta F_{\\mathrm{analytic\\_discrete}} - \\Delta F_{\\mathrm{exact}} $$\n3.  **采样误差 ($E_{\\mathrm{samp}}$):** 由于使用有限的蒙特卡洛采样来估计每个 $\\lambda$ 点的系综平均值而产生的误差。\n    $$ E_{\\mathrm{samp}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{analytic\\_discrete}} $$\n\n根据构造，这些误差是可加的：$E_{\\mathrm{tot}} = E_{\\mathrm{quad}} + E_{\\mathrm{samp}}$。判断采样误差是否占主导地位的诊断方法是比较 $|E_{\\mathrm{samp}}| > |E_{\\mathrm{quad}}|$ 的布尔结果。\n\n### 3. 实现\n\n以下 Python 代码实现了所述过程。它定义了一个函数来为单个测试用例执行计算，包括解析基准、基于解析和蒙特卡洛的 TI 被积函数、数值求积以及误差分析。主 `solve` 函数遍历提供的测试套件，调用计算函数，并按规定格式化结果。伪随机数生成器使用固定种子，以确保蒙特卡洛采样的可复现性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import trapezoid, simpson\n\ndef calculate_ti_errors(k0, k1, T, N_lambda, N_s, quadrature_rule, rng):\n    \"\"\"\n    Performs Thermodynamic Integration for a 1D harmonic oscillator model and analyzes errors.\n    \"\"\"\n    K_B = 1.380649e-23\n\n    if k0 = 0 or k1 = 0:\n        raise ValueError(\"Stiffness constants must be positive.\")\n    delta_F_exact = 0.5 * K_B * T * np.log(k1 / k0)\n\n    lambda_grid = np.linspace(0.0, 1.0, N_lambda)\n    integrand_analytic = np.zeros(N_lambda)\n    integrand_mc = np.zeros(N_lambda)\n    k_delta = k1 - k0\n\n    for i, lam in enumerate(lambda_grid):\n        k_lambda = (1 - lam) * k0 + lam * k1\n        \n        if k_lambda > 0:\n            # Analytical Integrand\n            integrand_analytic[i] = 0.5 * k_delta * (K_B * T / k_lambda)\n            \n            # Monte Carlo Integrand\n            sigma = np.sqrt(K_B * T / k_lambda)\n            samples_x = rng.normal(loc=0.0, scale=sigma, size=N_s)\n            x_squared_mean = np.mean(samples_x**2)\n            integrand_mc[i] = 0.5 * k_delta * x_squared_mean\n        else:\n            integrand_analytic[i] = 0.0\n            integrand_mc[i] = 0.0\n\n    if quadrature_rule == 'Simpson':\n        if N_lambda % 2 == 0:\n            raise ValueError(\"Simpson's rule requires an odd number of grid points.\")\n        delta_F_analytic_discrete = simpson(integrand_analytic, lambda_grid)\n        delta_F_mc = simpson(integrand_mc, lambda_grid)\n    elif quadrature_rule == 'Trapezoid':\n        delta_F_analytic_discrete = trapezoid(integrand_analytic, lambda_grid)\n        delta_F_mc = trapezoid(integrand_mc, lambda_grid)\n    else:\n        raise ValueError(f\"Unknown quadrature rule: {quadrature_rule}\")\n\n    E_tot = delta_F_mc - delta_F_exact\n    E_quad = delta_F_analytic_discrete - delta_F_exact\n    E_samp = delta_F_mc - delta_F_analytic_discrete\n    \n    sampling_dominant = abs(E_samp) > abs(E_quad)\n\n    return [E_tot, abs(E_samp), abs(E_quad), sampling_dominant]\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        (1.0, 4.0, 300, 21, 2000, 'Simpson'),\n        (1.0, 4.0, 300, 101, 50, 'Simpson'),\n        (1.0, 4.0, 300, 3, 20000, 'Trapezoid'),\n        (1.0, 1.2, 50, 5, 5000, 'Trapezoid'),\n    ]\n\n    rng = np.random.default_rng(seed=42)\n    \n    all_results = []\n    for case in test_cases:\n        k0, k1, T, N_lambda, N_s, quad_rule = case\n        result = calculate_ti_errors(k0, k1, T, N_lambda, N_s, quad_rule, rng)\n        all_results.append(result)\n    \n    output_str = '[' + ','.join([f\"[{r[0]},{r[1]},{r[2]},{str(r[3]).lower()}]\" for r in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}