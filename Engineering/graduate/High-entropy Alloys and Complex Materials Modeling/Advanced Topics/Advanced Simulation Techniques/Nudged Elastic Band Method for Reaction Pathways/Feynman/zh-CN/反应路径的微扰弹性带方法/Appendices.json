{
    "hands_on_practices": [
        {
            "introduction": "第一个实践练习介绍研究反应路径的一个基本概念。我们首先用连接初始和最终状态的简单直线来近似反应路径，然后在此路径上采样离散点的能量。这个练习将帮助您构建势能面的计算模型，并理解为什么这种线形插值虽然直观，但在高熵合金等复杂体系中通常不足以精确确定活化能垒，从而揭示了为何需要像微动弹性带（NEB）这样更复杂的方法。",
            "id": "3752897",
            "problem": "考虑一个五元高熵合金（HEA）超胞中单个迁移原子的二元扩散事件。目标是通过第一性原理和算法构建，评估沿猜测路径的离散化势能分布估计，并使用端点之间的线性插值来量化激活能垒。您将构建一个程序，用于计算沿线性插值路径的一组离散“像”（image）的能量，并返回几组不同参数下的估计能垒。使用微动弹性带（Nudged Elastic Band, NEB）方法的基本概念，但将计算限制为通过线性插值对猜测路径进行采样，不涉及任何弹簧力或切向投影。问题必须基于以下基本定义和事实进行构建：\n\n- 势能面（PES）为原子坐标构型 $\\mathbf{R}$ 指定一个势能 $V(\\mathbf{R})$。对于一个在二维空间中表示其位置的单个迁移原子，使用 $\\mathbf{r}\\in\\mathbb{R}^2$。\n- 两个端点构型 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 之间的连续路径可以参数化为 $\\mathbf{r}(t)=\\mathbf{r}_0+t(\\mathbf{r}_1-\\mathbf{r}_0)$，其中 $t\\in[0,1]$。一组 $N$ 个离散“像”由 $t_i=\\frac{i}{N-1}$ 定义，从而得到 $\\mathbf{r}_i=\\mathbf{r}(t_i)$，其中 $i=0,1,\\dots,N-1$。\n- 相对于初始状态的激活能垒估计值定义为 $E^\\ddagger=\\max_{i}V(\\mathbf{r}_i)-V(\\mathbf{r}_0)$。\n\n您必须为迁移原子实现以下具有物理动机、受崎岖高熵合金（HEA）启发的势能面（PES）：\n\n$$\nV(\\mathbf{r})=\\sum_{j=1}^{5}A_j\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{c}_j\\|^2}{2\\sigma_j^2}\\right)\n+B\\cos\\!\\left(2\\pi\\,\\mathbf{q}\\cdot\\mathbf{r}\\right)\n+C\\sum_{m=1}^{2}\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{s}_m\\|^2}{2\\lambda^2}\\right),\n$$\n\n其中，五个高斯势阱模拟了五元合金中与局域原子种类相关的吸引作用，余弦项模拟了介观尺度上的应变场，最后的求和项模拟了路径上的两个排斥性障碍物。使用如下固定的参数和端点：\n\n- 高斯势阱中心（原子种类位置，单位：纳米）：$\\mathbf{c}_1=(0.0,\\,0.0)$, $\\mathbf{c}_2=(1.0,\\,0.0)$, $\\mathbf{c}_3=(0.5,\\,0.8)$, $\\mathbf{c}_4=(-0.6,\\,0.4)$, $\\mathbf{c}_5=(1.2,\\,-0.7)$。\n- 势阱深度（单位：电子伏特）：$A_1=-0.20$, $A_2=-0.18$, $A_3=-0.16$, $A_4=-0.14$, $A_5=-0.12$。\n- 高斯宽度（单位：纳米）：$\\sigma_j=\\sigma=0.15$ 对于 $j=1,\\dots,5$。\n- 排斥性障碍物中心（单位：纳米）：$\\mathbf{s}_1=(0.5,\\,0.0)$, $\\mathbf{s}_2=(0.6,\\,0.2)$。\n- 排斥性障碍物宽度（单位：纳米）：$\\lambda=0.10$。\n- 应变场波矢（单位：纳米的倒数）：$\\mathbf{q}=(1.5,\\,0.7)$。\n- 端点（单位：纳米）：$\\mathbf{r}_0=\\mathbf{c}_1$, $\\mathbf{r}_1=\\mathbf{c}_2$。\n\n振幅 $B$（应变场）和 $C$（排斥性障碍物）将随测试用例而变化。程序必须：\n\n- 对于每个测试用例，使用 $\\mathbf{r}_i=\\mathbf{r}_0+\\frac{i}{N-1}(\\mathbf{r}_1-\\mathbf{r}_0)$ 在 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 之间构建 $N$ 个线性插值的“像” $\\mathbf{r}_i$。\n- 对所有 $i$ 计算 $V(\\mathbf{r}_i)$。\n- 计算能垒 $E^\\ddagger=\\max_i V(\\mathbf{r}_i)-V(\\mathbf{r}_0)$。\n\n所有能量均以电子伏特（eV）表示。余弦函数中的角度以弧度为单位。程序无需报告任何其他物理单位。最终的数值结果必须是浮点数。\n\n在您的解决方案中，讨论在崎岖的势能面上使用线性插值的局限性，特别是对于具有强成分无序的高熵合金（HEA）系统。您的讨论必须基于基本定义，并且不应依赖任何快捷公式。\n\n测试套件：\n为以下参数集 $(N,B,C)$ 提供输出：\n\n- 用例 1：$(11,\\,0.05,\\,0.25)$。\n- 用例 2：$(2,\\,0.05,\\,0.25)$。\n- 用例 3：$(51,\\,0.10,\\,0.35)$。\n- 用例 4：$(21,\\,0.00,\\,0.00)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$）。每个 $\\text{result}_k$ 是相应测试用例的激活能垒 $E^\\ddagger$（单位：eV），表示为浮点数。程序必须完全独立，无需外部输入或文件。",
            "solution": "该问题要求计算一个在模拟五元高熵合金（HEA）的模型二维势能面（PES）上扩散的单个原子的估算激活能垒。该过程包括：将初始构型和最终构型之间的线性插值路径离散化，评估每个离散点（“像”）的势能，并确定相对于起始点的最大能量。\n\n首先，我们定义数学和物理框架。迁移原子的位置是一个二维向量 $\\mathbf{r} = (x, y)$。势能面 $V(\\mathbf{r})$ 由以下函数给出：\n$$\nV(\\mathbf{r})=\\sum_{j=1}^{5}A_j\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{c}_j\\|^2}{2\\sigma_j^2}\\right)\n+B\\cos\\!\\left(2\\pi\\,\\mathbf{q}\\cdot\\mathbf{r}\\right)\n+C\\sum_{m=1}^{2}\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{s}_m\\|^2}{2\\lambda^2}\\right)\n$$\n该函数是三项的叠加：\n1. 五个高斯函数的和，代表位于中心 $\\mathbf{c}_j$、深度各不相同的吸引势阱 $A_j$。这些势阱模拟了高熵合金中化学上不同的原子位点。\n2. 一个正弦项，代表一个介观尺度应变场，其振幅为 $B$，波矢为 $\\mathbf{q}$。\n3. 两个高斯函数的和，代表排斥势垒，其振幅为 $C$，中心位于 $\\mathbf{s}_m$。这些势垒模拟了障碍物或能量不利的位点。\n\n扩散路径通过初始构型 $\\mathbf{r}_0$ 和最终构型 $\\mathbf{r}_1$ 之间的一条直线来近似。这条由 $t \\in [0, 1]$ 参数化的连续路径为 $\\mathbf{r}(t) = \\mathbf{r}_0 + t(\\mathbf{r}_1 - \\mathbf{r}_0)$。我们将此路径离散化为一组 $N$ 个“像” $\\mathbf{r}_i$，其中 $i = 0, 1, \\dots, N-1$。第 $i$ 个“像”的位置由下式给出：\n$$\n\\mathbf{r}_i = \\mathbf{r}_0 + \\frac{i}{N-1}(\\mathbf{r}_1 - \\mathbf{r}_0) \\quad \\text{对于 } N \\ge 2\n$$\n问题指定的端点为 $\\mathbf{r}_0 = \\mathbf{c}_1 = (0.0, 0.0)$ 和 $\\mathbf{r}_1 = \\mathbf{c}_2 = (1.0, 0.0)$。这将“像”的位置简化为 $\\mathbf{r}_i = (\\frac{i}{N-1}, 0)$。\n\n估算的激活能垒 $E^\\ddagger$ 定义为离散化路径上找到的最大势能与初始状态势能之差：\n$$\nE^\\ddagger = \\max_{i=0, \\dots, N-1} V(\\mathbf{r}_i) - V(\\mathbf{r}_0)\n$$\n\n每个测试用例 $(N, B, C)$ 的计算过程如下：\n1. 定义固定参数：吸引势阱中心 $\\mathbf{c}_j$、深度 $A_j$ 和宽度 $\\sigma$；排斥性障碍物中心 $\\mathbf{s}_m$ 和宽度 $\\lambda$；以及应变场波矢 $\\mathbf{q}$。端点为 $\\mathbf{r}_0 = (0.0, 0.0)$ 和 $\\mathbf{r}_1 = (1.0, 0.0)$。\n2. 沿连接 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 的直线生成一组 $N$ 个“像”的坐标 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$。\n3. 使用给定的 $B$ 和 $C$ 值，为每个“像” $\\mathbf{r}_i$ 计算势能 $V(\\mathbf{r}_i)$。\n4. 从计算出的能量中确定初始状态的能量 $V_0 = V(\\mathbf{r}_0)$（即第一个“像”的能量，$i=0$ 时的 $V(\\mathbf{r}_i)$）。\n5. 找到这组计算能量中的最大值 $V_{\\text{max}} = \\max_{i} V(\\mathbf{r}_i)$。\n6. 计算激活能垒 $E^\\ddagger = V_{\\text{max}} - V_0$。\n\n该问题的一个关键方面是理解使用简单线性插值作为反应路径的局限性，特别是在像高熵合金这样的复杂系统中。热激活过程的真实扩散路径遵循势能面上的最小能量路径（MEP）。MEP 是连接两个局部最小值（如 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$）的路径，在该路径的鞍点处，能量沿着路径方向为最大值，而在所有垂直于路径的方向上为最小值。MEP 上的最高点定义了真实的鞍点能量，其与初始状态能量的差值即为真实的激活能垒。\n\n线性插值路径仅仅是一个猜测，极不可能是真实的 MEP。在“崎岖”的 PES 上（这是高熵合金由于严重的晶格畸变和化学复杂性而具有的特征），直线路径很可能会穿过比真实 MEP 能量高得多的区域，而真实的 MEP 会自然弯曲以避开这些障碍物。因此，从线性路径计算出的激活能垒 $E^\\ddagger$ 几乎总是对真实物理激活能垒的高估。像微动弹性带（NEB）这样的方法就是为了解决这个问题而设计的。NEB 从一个初始路径（通常是线性插值）开始，并迭代地弛豫这些“像”，使它们在垂直于路径的方向上向 PES 的“下坡”方向移动，直到这组“像”收敛到 MEP 上。本问题中的过程相当于 NEB 计算的第一步（评估初始猜测），而没有任何后续的弛豫。“像”的密度 $N$ 影响了沿固定线性路径的能量分布的分辨率。非常低的 $N$ 值（例如 $N=2$）可能会错过该路径上的能量峰值，从而导致对*该特定路径*能垒的低估。较高的 $N$ 值可以更精确地计算出沿该固定线性路径的能垒，但它并不能纠正路径本身的基本缺陷。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the estimated activation barrier for a single migrating atom\n    in a model quinary high-entropy alloy (HEA) supercell for several\n    parameter sets.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    # Gaussian well centers (species sites, in nanometers)\n    C_CENTERS = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.5, 0.8], [-0.6, 0.4], [1.2, -0.7]\n    ])\n    # Well depths (in electronvolts)\n    A_DEPTHS = np.array([-0.20, -0.18, -0.16, -0.14, -0.12])\n    # Gaussian width (in nanometers)\n    SIGMA = 0.15\n    \n    # Repulsive obstacle centers (in nanometers)\n    S_CENTERS = np.array([[0.5, 0.0], [0.6, 0.2]])\n    # Repulsive obstacle width (in nanometers)\n    LAMBDA = 0.10\n    \n    # Strain field wavevector (in inverse nanometers)\n    Q_VEC = np.array([1.5, 0.7])\n    \n    # Endpoints (in nanometers)\n    R0 = C_CENTERS[0]\n    R1 = C_CENTERS[1]\n\n    def potential_energy(r, B, C):\n        \"\"\"\n        Calculates the potential energy V(r) for a given position r and\n        parameters B and C.\n        \n        Args:\n            r (np.ndarray): 2D position vector [x, y].\n            B (float): Amplitude of the strain field term.\n            C (float): Amplitude of the repulsive obstacle term.\n            \n        Returns:\n            float: The potential energy in eV.\n        \"\"\"\n        # 1. Sum of attractive Gaussian wells\n        term1 = 0.0\n        for j in range(len(C_CENTERS)):\n            norm_sq = np.linalg.norm(r - C_CENTERS[j])**2\n            term1 += A_DEPTHS[j] * np.exp(-norm_sq / (2 * SIGMA**2))\n            \n        # 2. Strain field term\n        term2 = B * np.cos(2 * np.pi * np.dot(Q_VEC, r))\n        \n        # 3. Sum of repulsive Gaussian obstacles\n        term3 = 0.0\n        for m in range(len(S_CENTERS)):\n            norm_sq = np.linalg.norm(r - S_CENTERS[m])**2\n            term3 += C * np.exp(-norm_sq / (2 * LAMBDA**2))\n            \n        return term1 + term2 + term3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, B, C)\n        (11, 0.05, 0.25),\n        (2, 0.05, 0.25),\n        (51, 0.10, 0.35),\n        (21, 0.00, 0.00),\n    ]\n\n    results = []\n    for N, B, C in test_cases:\n        # Generate the N linearly interpolated image positions\n        # The path is from (0,0) to (1,0), so it's along the x-axis.\n        if N  2:\n            # For N=1, the path is just the starting point. Barrier is 0.\n            # This case is not in the test suite but handled for robustness.\n            results.append(0.0)\n            continue\n            \n        x_coords = np.linspace(R0[0], R1[0], N)\n        y_coords = np.linspace(R0[1], R1[1], N)\n        path_images = np.stack((x_coords, y_coords), axis=-1)\n        \n        # Evaluate V(r_i) for all images i\n        energies = np.array([potential_energy(r, B, C) for r in path_images])\n        \n        # Initial energy V(r_0)\n        v0 = energies[0]\n        \n        # Maximum energy along the path\n        v_max = np.max(energies)\n        \n        # Compute the barrier E_dagger = max(V(r_i)) - V(r_0)\n        barrier = v_max - v0\n        results.append(barrier)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了简单固定路径的局限性之后，我们现在深入探讨微动弹性带（NEB）方法本身的核心机制。本实践练习的重点是计算驱动路径上的“镜像点”向最小能量路径（MEP）弛豫的力。您将学习如何计算局部路径切线 $\\hat{\\tau}_i$，并将真实的作用力 $\\mathbf{F}_i^{\\text{true}}$ 分解为平行和垂直于路径的分量，这是NEB方法的基本原理。",
            "id": "3752868",
            "problem": "给定一组离散的像，这些像代表了在一个简化的多主元合金环境中的一条候选反应路径上的原子构型。目标是计算每个内部像的切向单位向量、力的分解以及微动弹性带 (NEB) 力，并验证每个内部像上真实力的垂直分量与切向的正交性。请使用以下基本依据和定义。\n\n设路径为一系列的像，其位置为 $\\mathbf{R}_i \\in \\mathbb{R}^3$，能量为 $E_i = V(\\mathbf{R}_i)$，其中 $i = 0, 1, \\dots, N-1$。势能函数 $V(\\mathbf{R})$ 定义为一个高斯项、一个周期性余弦项和一个四次项之和：\n$$\nV(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right) + A\\left(\\cos(\\beta_x x) + \\cos(\\beta_y y) + \\cos(\\beta_z z)\\right) + B \\left(\\|\\mathbf{R}\\|^2\\right)^2,\n$$\n其中 $\\mathbf{R} = (x,y,z)$，$w_m$ 是高斯权重，$\\sigma_m$ 是高斯宽度，$\\mathbf{C}_m$ 是高斯中心。梯度 $\\nabla V(\\mathbf{R})$ 通过对每一项求导得到：\n$$\n\\nabla V(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right)\\left(-\\frac{2}{\\sigma_m^2}\\right)(\\mathbf{R} - \\mathbf{C}_m) \n- A \\begin{bmatrix} \\beta_x \\sin(\\beta_x x) \\\\ \\beta_y \\sin(\\beta_y y) \\\\ \\beta_z \\sin(\\beta_z z)\\end{bmatrix}\n+ 4 B (\\|\\mathbf{R}\\|^2)\\mathbf{R}.\n$$\n\n对于每个内部像 $i$（$1 \\leq i \\leq N-2$），定义前向位移 $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ 和后向位移 $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$。切向向量 $\\hat{\\tau}_i$ 使用基于能量的选择规则来选取，以避免路径出现扭结。使用以下经过改进但简单的选择方法：\n- 如果 $E_{i+1}  E_i  E_{i-1}$，则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n- 如果 $E_{i+1}  E_i  E_{i-1}$，则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n- 否则，如果 $E_{i+1}  E_{i-1}$，则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n- 否则，如果 $E_{i+1}  E_{i-1}$，则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n- 否则，设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^-$。\n\n然后进行归一化，得到单位切向量 $\\hat{\\tau}_i = \\mathbf{\\tau}_i / \\|\\mathbf{\\tau}_i\\|$。\n\n令真实力为 $\\mathbf{F}_i^{\\text{true}} = -\\nabla V(\\mathbf{R}_i)$。计算其相对于路径切向的垂直分量，\n$$\n\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\text{true}} - \\left(\\mathbf{F}_i^{\\text{true}} \\cdot \\hat{\\tau}_i\\right)\\hat{\\tau}_i,\n$$\n以及沿切向投影的弹性弹簧力，\n$$\n\\mathbf{F}_i^{\\parallel, \\text{spring}} = k\\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right)\\hat{\\tau}_i,\n$$\n其中 $k$ 是一个给定的无量纲弹簧常数。内部像的微动弹性带 (NEB) 力为\n$$\n\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\parallel, \\text{spring}}.\n$$\n\n正交性验证需要检查垂直分量是否与切向正交，即在给定的数值容差范围内，$\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i = 0$ 是否成立。对于每个测试用例，计算所有内部像的 $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i$ 的最大绝对值，并报告是否所有内部像都满足 $|\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i| \\leq \\varepsilon$（其中 $\\varepsilon$ 为指定的容差）。\n\n所有量均为无量纲。以完整精度报告浮点输出，无需四舍五入。三角函数隐式地使用弧度作为角度单位。不涉及任何物理单位。\n\n请针对以下包含三个用例的测试套件实现上述计算。对于每个用例，能量 $E_i$ 必须由给定的势能 $V(\\mathbf{R}_i)$ 计算得出，并用于切向选择规则。\n\n测试用例 1：\n- 像 ($N = 7$)：\n  - $\\mathbf{R}_0 = (-1.0, 0.2, 0.0)$,\n  - $\\mathbf{R}_1 = (-0.6666666667, 0.1333333333, 0.0)$,\n  - $\\mathbf{R}_2 = (-0.3333333333, 0.0666666667, 0.0)$,\n  - $\\mathbf{R}_3 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (0.3333333333, -0.0666666667, 0.0)$,\n  - $\\mathbf{R}_5 = (0.6666666667, -0.1333333333, 0.0)$,\n  - $\\mathbf{R}_6 = (1.0, -0.2, 0.0)$.\n- 势能参数：\n  - 高斯项 ($M = 3$)：\n    - $w_1 = 1.20$, $\\sigma_1 = 0.40$, $\\mathbf{C}_1 = (0.30, 0.00, 0.00)$,\n    - $w_2 = 0.80$, $\\sigma_2 = 0.35$, $\\mathbf{C}_2 = (-0.50, 0.20, 0.00)$,\n    - $w_3 = -0.60$, $\\sigma_3 = 0.45$, $\\mathbf{C}_3 = (0.00, -0.30, 0.00)$.\n  - 周期项：$A = 0.15$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - 四次项：$B = 0.02$.\n- 弹簧常数：$k = 0.50$.\n- 正交性容差：$\\varepsilon = 1\\times 10^{-10}$.\n\n测试用例 2：\n- 像 ($N = 6$)：\n  - $\\mathbf{R}_0 = (-0.8, -0.2, 0.1)$,\n  - $\\mathbf{R}_1 = (-0.5, 0.05, 0.1)$,\n  - $\\mathbf{R}_2 = (-0.2, 0.3, 0.1)$,\n  - $\\mathbf{R}_3 = (0.1, 0.15, 0.1)$,\n  - $\\mathbf{R}_4 = (0.4, -0.05, 0.1)$,\n  - $\\mathbf{R}_5 = (0.7, -0.25, 0.1)$.\n- 势能参数（与用例 1 相同）：\n  - 高斯项 ($M = 3$)：\n    - $w_1 = 1.20$, $\\sigma_1 = 0.40$, $\\mathbf{C}_1 = (0.30, 0.00, 0.00)$,\n    - $w_2 = 0.80$, $\\sigma_2 = 0.35$, $\\mathbf{C}_2 = (-0.50, 0.20, 0.00)$,\n    - $w_3 = -0.60$, $\\sigma_3 = 0.45$, $\\mathbf{C}_3 = (0.00, -0.30, 0.00)$.\n  - 周期项：$A = 0.15$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - 四次项：$B = 0.02$.\n- 弹簧常数：$k = 0.80$.\n- 正交性容差：$\\varepsilon = 1\\times 10^{-10}$.\n\n测试用例 3：\n- 像 ($N = 5$)：\n  - $\\mathbf{R}_0 = (-0.5, 0.0, 0.0)$,\n  - $\\mathbf{R}_1 = (-0.25, 0.0, 0.0)$,\n  - $\\mathbf{R}_2 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_3 = (0.25, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (0.5, 0.0, 0.0)$.\n- 势能参数（平坦的势能面以探测简并性）：\n  - 高斯项 ($M = 3$)：\n    - $w_1 = 0.40$, $\\sigma_1 = 0.90$, $\\mathbf{C}_1 = (0.00, 0.00, 0.00)$,\n    - $w_2 = 0.30$, $\\sigma_2 = 0.90$, $\\mathbf{C}_2 = (0.30, 0.00, 0.00)$,\n    - $w_3 = 0.20$, $\\sigma_3 = 1.00$, $\\mathbf{C}_3 = (-0.30, 0.00, 0.00)$.\n  - 周期项：$A = 0.00$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - 四次项：$B = 0.01$.\n- 弹簧常数：$k = 0.30$.\n- 正交性容差：$\\varepsilon = 1\\times 10^{-12}$.\n\n您的程序应为每个测试用例计算所有内部像的以下三个量：\n- 最大绝对点积 $m = \\max_{i} \\left| \\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i \\right|$。\n- 正交性标志 $b$，如果对于所有内部像 $i$ 都有 $\\left| \\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i \\right| \\leq \\varepsilon$ 成立，则定义为 $b = 1$，否则为 $b = 0$。\n- 最大欧几里得范数 $n = \\max_{i} \\left\\| \\mathbf{F}_i^{\\text{NEB}} \\right\\|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由列表组成的列表，用逗号分隔。每个子列表对应一个测试用例，并按上述顺序排列。每个子列表的形式必须为 $[m,b,n]$，其中 $m$ 和 $n$ 是浮点值，$b$ 是一个整数。例如，输出可能看起来像 $[[0.0,1,0.5],[0.0,1,0.8],[0.0,1,0.3]]$，但应使用给定数据计算出的实际值。",
            "solution": "该问题已经过严格验证，并被确定为是可靠的。它在科学上基于计算材料科学的原理，特别是用于寻找反应路径的微动弹性带 (NEB) 方法。该问题是适定的，为三个不同的测试用例提供了一套完整且一致的定义、方程和数据。所有术语都有正式定义，任务包含一个直接、明确的计算过程。验证 $\\mathbf{F}_i^{\\perp}$ 和 $\\hat{\\tau}_i$ 正交性的要求是一项标准的数值健全性检查，因为根据定义，这两个向量是正交的；任何非零结果都应在机器精度的数量级上，这是由浮点运算的限制所导致的。\n\n该解决方案通过对所提供反应路径的每个内部像执行一系列计算步骤来实现。路径由位于位置 $\\mathbf{R}_0, \\mathbf{R}_1, \\dots, \\mathbf{R}_{N-1}$ 的 $N$ 个像（原子构型）序列定义。计算针对每个内部像 $\\mathbf{R}_i$ 进行，其中索引 $i$ 的范围从 $1$ 到 $N-2$。\n\n**第 1 步：势能面和真实力**\n\n首先，我们定义势能面 (PES) $V(\\mathbf{R})$ 及其对应的力场。位于位置 $\\mathbf{R} = (x,y,z)$ 的构型的势能由下式给出：\n$$\nV(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right) + A\\left(\\cos(\\beta_x x) + \\cos(\\beta_y y) + \\cos(\\beta_z z)\\right) + B \\left(\\|\\mathbf{R}\\|^2\\right)^2\n$$\n系统受到的力，即“真实力”，是该势能的负梯度：$\\mathbf{F}^{\\text{true}} = -\\nabla V(\\mathbf{R})$。梯度由下式给出：\n$$\n\\nabla V(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right)\\left(-\\frac{2}{\\sigma_m^2}\\right)(\\mathbf{R} - \\mathbf{C}_m) \n- A \\begin{bmatrix} \\beta_x \\sin(\\beta_x x) \\\\ \\beta_y \\sin(\\beta_y y) \\\\ \\beta_z \\sin(\\beta_z z)\\end{bmatrix}\n+ 4 B (\\|\\mathbf{R}\\|^2)\\mathbf{R}\n$$\n对于每个像 $\\mathbf{R}_i$，我们计算其能量 $E_i = V(\\mathbf{R}_i)$。对于每个内部像 $\\mathbf{R}_i$（$1 \\le i \\le N-2$），我们计算真实力 $\\mathbf{F}_i^{\\text{true}} = -\\nabla V(\\mathbf{R}_i)$。\n\n**第 2 步：路径切向计算**\n\n内部像 $\\mathbf{R}_i$ 处反应路径的局部方向由切向向量 $\\hat{\\tau}_i$ 定义。为构造此切向，我们首先定义前向和后向位移向量：$\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ 和 $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$。\n\n使用一种基于能量的切换方案来选择未归一化的切向向量 $\\mathbf{\\tau}_i$，以确保它从能量较低的邻近像指向“上坡”方向，并避免路径中出现扭结。指定的选择规则如下：\n1. 如果 $E_{i+1}  E_i  E_{i-1}$（路径是上升的），则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n2. 如果 $E_{i+1}  E_i  E_{i-1}$（路径是下降的），则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n3. 否则（像 $\\mathbf{R}_i$ 位于极值点附近或斜坡上）：\n   a. 如果 $E_{i+1}  E_{i-1}$，则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n   b. 如果 $E_{i+1}  E_{i-1}$，则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n   c. 否则（$E_{i+1} = E_{i-1}$），则设 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^- = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}$。\n\n最终的单位切向向量通过归一化 $\\mathbf{\\tau}_i$ 得到：\n$$\n\\hat{\\tau}_i = \\frac{\\mathbf{\\tau}_i}{\\|\\mathbf{\\tau}_i\\|}\n$$\n\n**第 3 步：NEB 力计算**\n\nNEB 方法的核心思想是将作用在像上的力分解为平行于和垂直于反应路径的分量。总的 NEB 力 $\\mathbf{F}_i^{\\text{NEB}}$ 是两个分量的和：真实力的垂直分量和虚拟弹簧力的平行分量。\n\n真实力的垂直分量 $\\mathbf{F}_i^{\\perp}$ 将像推向最小能量路径。它通过将 $\\mathbf{F}_i^{\\text{true}}$ 投影到切向 $\\hat{\\tau}_i$ 上，并从原始力向量中减去该投影来计算：\n$$\n\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\text{true}} - (\\mathbf{F}_i^{\\text{true}} \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i\n$$\n根据这种构造方法，$\\mathbf{F}_i^{\\perp}$ 在数学上与 $\\hat{\\tau}_i$ 正交，即 $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i = 0$。\n\n弹簧力分量 $\\mathbf{F}_i^{\\parallel, \\text{spring}}$ 仅沿路径切向作用。其目的是确保各个像沿路径均匀分布。它被定义为：\n$$\n\\mathbf{F}_i^{\\parallel, \\text{spring}} = k(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|)\\hat{\\tau}_i\n$$\n这里，$k$ 是弹簧常数。该力与像 $\\mathbf{R}_i$ 前后路径段的长度差成正比。\n\n总的微动弹性带力是这两个分量的和：\n$$\n\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\parallel, \\text{spring}}\n$$\n这种构造确保了真实势能只在垂直于路径的方向上移动像，而弹簧力只在平行于路径的方向上移动它们，从而防止像滑向能量极小点并保持其分布。\n\n**第 4 步：验证和度量聚合**\n\n对于每个测试用例，我们遍历所有内部像 $i \\in \\{1, \\dots, N-2\\}$ 并计算所需的量。每个用例的最终结果被聚合成三个度量指标：\n\n1.  最大绝对点积 $m = \\max_{i} |\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i|$。该度量用于数值上验证正交性。由于浮点精度问题，该值预计会非常接近于零，但不会恰好为零。\n2.  正交性标志 $b$。如果所有内部像都满足条件 $|\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i| \\le \\varepsilon$，则该整数设为 $1$，否则设为 $0$，其中 $\\varepsilon$ 是给定的容差。\n3.  NEB 力的最大欧几里得范数 $n = \\max_{i} \\|\\mathbf{F}_i^{\\text{NEB}}\\|$。这表示作用在弹性带中任何像上的最大力，在完整的 NEB 优化中是一个有用的收敛判据。\n\n该实现将把这些步骤应用于所提供的三个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\n\ndef get_potential_and_gradient(potential_params):\n    \"\"\"\n    Factory function to create potential energy and gradient functions\n    based on the given parameters.\n    \"\"\"\n    gaussians = potential_params['gaussians']\n    A = potential_params['A']\n    betas = np.array(potential_params['betas'])\n    B = potential_params['B']\n\n    def V(R):\n        \"\"\"Computes the potential energy V at a given position R.\"\"\"\n        R = np.array(R)\n        # Gaussian terms\n        gauss_sum = 0.0\n        for w, sigma, C in gaussians:\n            C = np.array(C)\n            norm_sq = np.sum((R - C)**2)\n            gauss_sum += w * np.exp(-norm_sq / (sigma**2))\n        \n        # Periodic term\n        periodic_sum = A * np.sum(np.cos(betas * R))\n        \n        # Quartic term\n        quartic_term = B * (np.sum(R**2))**2\n        \n        return gauss_sum + periodic_sum + quartic_term\n\n    def grad_V(R):\n        \"\"\"Computes the gradient of the potential V at a given position R.\"\"\"\n        R = np.array(R)\n        grad = np.zeros(3, dtype=float)\n        \n        # Gaussian terms\n        for w, sigma, C in gaussians:\n            C = np.array(C)\n            norm_sq = np.sum((R - C)**2)\n            grad += w * np.exp(-norm_sq / (sigma**2)) * (-2.0 / (sigma**2)) * (R - C)\n        \n        # Periodic term\n        grad -= A * betas * np.sin(betas * R)\n        \n        # Quartic term\n        grad += 4.0 * B * np.sum(R**2) * R\n        \n        return grad\n        \n    return V, grad_V\n\ndef solve():\n    \"\"\"\n    Main function to run the NEB calculations for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"images\": [\n                (-1.0, 0.2, 0.0), (-0.6666666667, 0.1333333333, 0.0),\n                (-0.3333333333, 0.0666666667, 0.0), (0.0, 0.0, 0.0),\n                (0.3333333333, -0.0666666667, 0.0), (0.6666666667, -0.1333333333, 0.0),\n                (1.0, -0.2, 0.0)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (1.20, 0.40, (0.30, 0.00, 0.00)),\n                    (0.80, 0.35, (-0.50, 0.20, 0.00)),\n                    (-0.60, 0.45, (0.00, -0.30, 0.00))\n                ],\n                \"A\": 0.15, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.02\n            },\n            \"k\": 0.50,\n            \"epsilon\": 1e-10\n        },\n        # Test Case 2\n        {\n            \"images\": [\n                (-0.8, -0.2, 0.1), (-0.5, 0.05, 0.1), (-0.2, 0.3, 0.1),\n                (0.1, 0.15, 0.1), (0.4, -0.05, 0.1), (0.7, -0.25, 0.1)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (1.20, 0.40, (0.30, 0.00, 0.00)),\n                    (0.80, 0.35, (-0.50, 0.20, 0.00)),\n                    (-0.60, 0.45, (0.00, -0.30, 0.00))\n                ],\n                \"A\": 0.15, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.02\n            },\n            \"k\": 0.80,\n            \"epsilon\": 1e-10\n        },\n        # Test Case 3\n        {\n            \"images\": [\n                (-0.5, 0.0, 0.0), (-0.25, 0.0, 0.0), (0.0, 0.0, 0.0),\n                (0.25, 0.0, 0.0), (0.5, 0.0, 0.0)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (0.40, 0.90, (0.00, 0.00, 0.00)),\n                    (0.30, 0.90, (0.30, 0.00, 0.00)),\n                    (0.20, 1.00, (-0.30, 0.00, 0.00))\n                ],\n                \"A\": 0.00, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.01\n            },\n            \"k\": 0.30,\n            \"epsilon\": 1e-12\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        images_R = [np.array(r) for r in case[\"images\"]]\n        N = len(images_R)\n        V, grad_V = get_potential_and_gradient(case[\"potential_params\"])\n        k = case[\"k\"]\n        epsilon = case[\"epsilon\"]\n        \n        energies_E = [V(R) for R in images_R]\n        \n        max_abs_dot_product = 0.0\n        max_neb_force_norm = 0.0\n        \n        dot_products_below_eps = True\n        \n        for i in range(1, N - 1):\n            R_i = images_R[i]\n            R_i_minus_1 = images_R[i-1]\n            R_i_plus_1 = images_R[i+1]\n            \n            E_i = energies_E[i]\n            E_i_minus_1 = energies_E[i-1]\n            E_i_plus_1 = energies_E[i+1]\n            \n            delta_R_plus = R_i_plus_1 - R_i\n            delta_R_minus = R_i - R_i_minus_1\n            \n            # Tangent selection\n            tau_i = None\n            if E_i_plus_1 > E_i and E_i > E_i_minus_1:\n                tau_i = delta_R_plus\n            elif E_i_plus_1  E_i and E_i  E_i_minus_1:\n                tau_i = delta_R_minus\n            else:\n                if E_i_plus_1 > E_i_minus_1:\n                    tau_i = delta_R_plus\n                elif E_i_plus_1  E_i_minus_1:\n                    tau_i = delta_R_minus\n                else: # E_i_plus_1 == E_i_minus_1\n                    tau_i = delta_R_plus + delta_R_minus\n            \n            # Normalize tangent\n            tau_i_norm = np.linalg.norm(tau_i)\n            tau_hat_i = tau_i / tau_i_norm if tau_i_norm > 1e-15 else np.zeros(3)\n\n            # True force\n            F_i_true = -grad_V(R_i)\n            \n            # Perpendicular component of true force\n            F_i_perp = F_i_true - np.dot(F_i_true, tau_hat_i) * tau_hat_i\n            \n            # Parallel spring force\n            norm_delta_R_plus = np.linalg.norm(delta_R_plus)\n            norm_delta_R_minus = np.linalg.norm(delta_R_minus)\n            F_i_spring_parallel = k * (norm_delta_R_plus - norm_delta_R_minus) * tau_hat_i\n            \n            # NEB force\n            F_i_NEB = F_i_perp + F_i_spring_parallel\n            \n            # Metric 1: Orthogonality check\n            dot_product = np.dot(F_i_perp, tau_hat_i)\n            max_abs_dot_product = max(max_abs_dot_product, abs(dot_product))\n            \n            if abs(dot_product) > epsilon:\n                dot_products_below_eps = False\n                \n            # Metric 3: Max NEB force norm\n            neb_force_norm = np.linalg.norm(F_i_NEB)\n            max_neb_force_norm = max(max_neb_force_norm, neb_force_norm)\n                \n        b = 1 if dot_products_below_eps else 0\n        m = max_abs_dot_product\n        n = max_neb_force_norm\n        \n        all_results.append([m, b, n])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "为了精确确定活化能垒，至关重要的是精确定位最小能量路径上的鞍点。本实践练习将介绍“爬山镜像”（Climbing Image NEB, CI-NEB）方法，这是一种功能强大的改进，可确保能量最高的镜像点精确收敛到过渡态。您将为“爬山”镜像点实现特定的力更新，并验证它能正确地沿路径“爬升”，同时在所有垂直方向上向能量更低处弛豫，从而精确地找到真实的活化能。",
            "id": "3752891",
            "problem": "考虑一个二维势能面，旨在模拟高熵合金（HEA）扩散中常见的无序景观，其中反应路径通过微动弹性带（Nudged Elastic Band, NEB）方法识别，并通过爬山镜像（Climbing Image, CI）修正进行优化。设势能由一个光滑标量场 $V(\\mathbf{r})$ 定义，其中 $\\mathbf{r} = (x,y)$，力场由负梯度 $-\\nabla V(\\mathbf{r})$ 给出。一条离散路径由一系列镜像点 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 表示，其中端点 $i=0$ 和 $i=N-1$ 是固定的。假设所有量均为无量纲（无单位）。\n\n基本原理和定义：\n- 镜像点 $i$ 处的能量为 $E_i = V(\\mathbf{r}_i)$，梯度为 $\\nabla V(\\mathbf{r}_i)$。\n- 内部镜像点 $i$ 处的 NEB 路径切线是单位向量 $\\hat{\\boldsymbol{\\tau}}_i$，与点 $i$ 处的路径方向对齐，由相邻镜像点构造。您必须仅使用相邻镜像点选择一个数学上一致的切线定义，并稳健地处理近简并的相邻差异，避免除以零。\n- 爬山镜像修正旨在使内部镜像点中能量最高的点沿路径切线方向作能量上升移动，并在垂直于路径的子空间中作能量下降移动，且该镜像点上不施加弹簧力。\n\n任务：\n1. 对于下方的每个测试用例，识别具有最大能量的内部镜像点，并应用上述描述一致的爬山镜像修正，计算该镜像点的更新后力：该力应严格驱动镜像点沿路径切线方向作能量上升移动，并垂直于路径作能量下降移动，同时移除该镜像点上的任何弹簧力贡献。\n2. 使用向量投影和内积验证所计算的力是否同时满足以下两点：\n   - 其切向分量使镜像点沿能量上升方向移动（沿路径上 $V$ 增加的方向）。\n   - 其法向分量使镜像点沿能量下降方向移动（与能量梯度的法向分量方向相反）。\n3. 为进行验证，在能量最高的镜像点 $i^\\star$ 处使用以下定量检验：\n   - 令 $\\hat{\\boldsymbol{\\tau}} = \\hat{\\boldsymbol{\\tau}}_{i^\\star}$，$\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$，并定义投影 $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ 和 $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$。令 $\\mathbf{F}$ 表示您计算的爬山镜像力。在绝对容差 $\\epsilon = 10^{-8}$ 内验证以下所有条件：\n     - $\\mathbf{F}$ 的切向分量与能量上升运动匹配：$\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}}$ 等于 $+\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}$。\n     - $\\mathbf{F}$ 的法向分量相对于梯度是能量下降的：$\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ 等于 $-\\mathbf{g}_{\\perp}$。\n     - 能量下降条件在能量上是一致的：$\\left(\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}\\right)\\cdot \\mathbf{g}_{\\perp} \\le 0$。\n   通过逻辑与（仅当所有三项在容差范围内均成立时为真）将这三个检验聚合为单个布尔值。\n4. 重要的算法要求：\n   - 对于内部镜像点 $i$ 处的切线 $\\hat{\\boldsymbol{\\tau}}_i$，使用从 $\\mathbf{r}_{i+1}-\\mathbf{r}_{i-1}$ 推导出的有限差分方向并将其归一化。如果其范数低于一个小阈值，您必须稳健地选择一个备用的非零方向（例如，优先选择范数较大的 $\\mathbf{r}_{i}-\\mathbf{r}_{i-1}$ 或 $\\mathbf{r}_{i+1}-\\mathbf{r}_{i}$，或者作为最后手段，选择一个与 $\\nabla V(\\mathbf{r}_i)$ 相关的方向）并将其归一化。端点不参与爬山过程。\n   - 所有计算均无单位。\n   - 使用下方定义的势能函数及其解析梯度。\n\n势能定义：\n- 令\n$$\nV(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y),\n$$\n其中常数 $a = 0.15$, $b = 0.10$, $c = 0.05$, $d = 0.03$。\n- 其梯度为\n$$\n\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big).\n$$\n\n测试套件：\n对于每个用例，您将获得一个镜像点坐标列表 $\\{(x_i,y_i)\\}_{i=0}^{N-1}$。\n- 用例 1（跨越一个能垒的直线路径）：\n  $\\{(-1.4,\\,0.0),\\; (-1.0,\\,0.0),\\; (-0.6,\\,0.0),\\; (-0.2,\\,0.0),\\; (0.2,\\,0.0),\\; (0.6,\\,0.0),\\; (1.0,\\,0.0)\\}$。\n- 用例 2（对各向异性梯度进行采样的弯曲路径）：\n  $\\{(-1.2,\\,-0.3),\\; (-0.8,\\,-0.15),\\; (-0.4,\\,-0.02),\\; (0.0,\\,0.06),\\; (0.4,\\,0.12),\\; (0.8,\\,0.22),\\; (1.0,\\,0.4)\\}$。\n- 用例 3（最大值点附近的近简并相邻差异）：\n  $\\{(-0.9,\\,0.0),\\; (-0.001,\\,0.02),\\; (0.0,\\,0.02),\\; (0.0000005,\\,0.0200001),\\; (0.9,\\,0.0)\\}$。\n\n程序要求：\n- 完全按照给定的表达式实现解析的 $V(x,y)$ 和 $\\nabla V(x,y)$。\n- 对每个用例，识别具有最大 $V$ 值的内部镜像点，并为该镜像点计算爬山镜像力 $\\mathbf{F}$，其方式需强制实现沿 $\\hat{\\boldsymbol{\\tau}}$ 的能量上升运动和垂直于 $\\hat{\\boldsymbol{\\tau}}$ 的能量下降运动，且该镜像点上无弹簧力。\n- 使用绝对容差 $\\epsilon = 10^{-8}$ 执行上述三个验证检验，并通过逻辑与为每个用例生成单个布尔值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"），每个结果是对应测试用例的布尔值。",
            "solution": "该问题要求在给定的二维势能面 $V(x,y)$ 上，为微动弹性带（NEB）模拟计算并验证爬山镜像力。爬山镜像（CI）修正是将 NEB 路径收敛到最小能量路径（MEP）的标准技术，其中能量最高的镜像点会收敛到一阶鞍点（即过渡态）。\n\n问题的核心在于根据所提供的描述和验证标准，正确地解释爬山镜像力的定义。一个常规的 NEB 镜像点受到两种力：一个平行于路径切线的弹簧力 $\\mathbf{F}_{s, \\parallel}$，用以确保镜像点的均匀间隔；以及真实势能力量的法向分量 $\\mathbf{F}_{\\text{pot}, \\perp}$，用以最小化垂直于路径的能量。势能力是势能的负梯度，即 $\\mathbf{F}_{\\text{pot}} = -\\nabla V$。\n\n爬山镜像点，记为 $\\mathbf{r}_{i^\\star}$（能量最高的内部镜像点），则被区别对待。问题陈述中指出，弹簧力被移除。它被驱动沿路径切线“能量上升”，并垂直于路径“能量下降”。令 $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$ 为爬山镜像点处的势能梯度，并令 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 为该镜像点处的单位路径切向量。“能量上升”和“能量下降”分别指势能增加和减少的方向。最陡峭的上升方向由 $\\mathbf{g}$ 给出。\n\n爬山镜像点上的力 $\\mathbf{F}_{\\text{CI}}$ 由其平行于和垂直于切线 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 的分量定义：\n$\\mathbf{F}_{\\text{CI}} = \\mathbf{F}_{\\parallel} + \\mathbf{F}_{\\perp}$。\n\n问题的验证标准明确了这些分量：\n1.  力的切向分量使镜像点“能量上升”。检验标准指定为 $\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。这意味着力的平行分量等于梯度的平行分量：$\\mathbf{F}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}_{\\parallel}$。该力分量沿切线方向推动镜像点，使其朝该切线上势能增加的方向移动，因此称为“爬山”。\n\n2.  力的法向分量使镜像点“能量下降”。检验标准为 $\\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = -\\mathbf{g}_{\\perp}$。这意味着力的法向分量是梯度的法向分量的负值：$\\mathbf{F}_{\\perp} = -\\mathbf{g}_{\\perp}$。该力分量作用于最小化垂直于路径的超平面内的势能，从而使镜像点弛豫到 MEP 上。\n\n结合这些分量，爬山镜像力为：\n$$\n\\mathbf{F}_{\\text{CI}} = \\mathbf{g}_{\\parallel} - \\mathbf{g}_{\\perp}\n$$\n其中 $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 且 $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$。此公式等同于梯度反转 CI 力的标准定义 $\\mathbf{F}_{\\text{CI}} = -\\mathbf{g} + 2\\mathbf{g}_{\\parallel}$。\n\n解决每个测试用例的算法如下：\n1.  给定路径 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$，识别其内部镜像点，即 $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$。\n2.  为每个内部镜像点计算势能 $E_i = V(\\mathbf{r}_i)$。找到能量最大值对应的镜像点索引 $i^\\star$。\n3.  确定爬山镜像点 $\\mathbf{r}_{i^\\star}$ 处的切向量 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。主要定义是其相邻点之间的归一化向量：$\\mathbf{t} = \\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star-1}$。当 $\\|\\mathbf{t}\\|$ 接近于零时，需要进行稳健性检查。指定的备用方案是使用 $\\mathbf{r}_{i^\\star} - \\mathbf{r}_{i^\\star-1}$ 或 $\\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star}$ 中模长较大的那个向量进行归一化。\n4.  计算梯度向量 $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$。\n5.  计算爬山镜像力 $\\mathbf{F}_{\\text{CI}} = (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} - (\\mathbf{g} - (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star})$。\n6.  使用容差 $\\epsilon=10^{-8}$ 执行三个验证检验：\n    a. 检验 1：$|\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} - \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}| \\le \\epsilon$。\n    b. 检验 2：$\\|\\mathbf{F}_{\\perp} - (-\\mathbf{g}_{\\perp})\\| \\le \\epsilon$，其中 $\\mathbf{F}_{\\perp} = \\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 且 $\\mathbf{g}_{\\perp} = \\mathbf{g} - (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。\n    c. 检验 3：$\\mathbf{F}_{\\perp} \\cdot \\mathbf{g}_{\\perp} \\le 0$。如果前一个检验通过，此项应成立，因为它变为 $-(\\mathbf{g}_{\\perp}\\cdot\\mathbf{g}_{\\perp}) = -\\|\\mathbf{g}_{\\perp}\\|^2 \\le 0$。\n7.  当且仅当所有三个检验都通过时，该测试用例的最终结果为 `True`。\n\n实现将使用提供的势能 $V(x,y)$ 及其梯度 $\\nabla V(x,y)$ 的解析表达式：\n$V(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y)$\n$\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big)$\n其中 $a = 0.15$, $b = 0.10$, $c = 0.05$, $d = 0.03$。计算将使用 `numpy` 库中的数值向量运算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the climbing image force verification problem for three test cases.\n    \"\"\"\n\n    # Constants for the potential energy function\n    a = 0.15\n    b = 0.10\n    c = 0.05\n    d = 0.03\n\n    def potential(r):\n        \"\"\"Calculates the potential energy V(x,y) at a given point r = [x, y].\"\"\"\n        x, y = r\n        term1 = (x**2 - 1)**2\n        term2 = a * y**2\n        term3 = b * np.sin(3 * x) * np.cos(2 * y)\n        term4 = c * x\n        term5 = d * np.sin(5 * y)\n        return term1 + term2 + term3 + term4 + term5\n\n    def gradient(r):\n        \"\"\"Calculates the gradient of the potential energy grad V(x,y) at a point r = [x, y].\"\"\"\n        x, y = r\n        grad_x = 4 * x * (x**2 - 1) + 3 * b * np.cos(3 * x) * np.cos(2 * y) + c\n        grad_y = 2 * a * y - 2 * b * np.sin(3 * x) * np.sin(2 * y) + 5 * d * np.cos(5 * y)\n        return np.array([grad_x, grad_y])\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        # Case 1: straight path across a barrier\n        [(-1.4, 0.0), (-1.0, 0.0), (-0.6, 0.0), (-0.2, 0.0), (0.2, 0.0), (0.6, 0.0), (1.0, 0.0)],\n        # Case 2: bent path sampling anistropic gradients\n        [(-1.2, -0.3), (-0.8, -0.15), (-0.4, -0.02), (0.0, 0.06), (0.4, 0.12), (0.8, 0.22), (1.0, 0.4)],\n        # Case 3: near-degenerate neighbor differences around the maximum\n        [(-0.9, 0.0), (-0.001, 0.02), (0.0, 0.02), (0.0000005, 0.0200001), (0.9, 0.0)],\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        path = np.array(case)\n        num_images = len(path)\n        \n        # Interior images are from index 1 to N-2\n        interior_indices = range(1, num_images - 1)\n        interior_images = path[1:num_images - 1]\n        \n        # 1. Find the interior image with the maximal energy\n        energies = [potential(r) for r in interior_images]\n        # Get the global index of the max energy image\n        i_star = np.argmax(energies) + 1 \n        r_istar = path[i_star]\n\n        # 2. Compute the tangent vector at the climbing image\n        r_prev = path[i_star - 1]\n        r_next = path[i_star + 1]\n        \n        # Primary tangent definition\n        t = r_next - r_prev\n        norm_t = np.linalg.norm(t)\n        \n        tangent_threshold = 1e-9\n        if norm_t  tangent_threshold:\n            # Fallback tangent definition\n            t1 = r_istar - r_prev\n            t2 = r_next - r_istar\n            if np.linalg.norm(t1) > np.linalg.norm(t2):\n                t_alt = t1\n            else:\n                t_alt = t2\n            \n            norm_t_alt = np.linalg.norm(t_alt)\n            # The problem provides no case where second fallback is needed.\n            if norm_t_alt  tangent_threshold:\n                 # This path shouldn't be taken with the given test cases.\n                 # Fallback to gradient if all else fails, normalized.\n                 g_temp = gradient(r_istar)\n                 tau_hat = g_temp / np.linalg.norm(g_temp)\n            else:\n                 tau_hat = t_alt / norm_t_alt\n        else:\n            tau_hat = t / norm_t\n\n        # 3. Compute climbing image force from its components\n        g = gradient(r_istar)\n        g_dot_tau = np.dot(g, tau_hat)\n        \n        g_parallel = g_dot_tau * tau_hat\n        g_perp = g - g_parallel\n        \n        # Force is defined as F_CI = g_parallel - g_perp\n        F = g_parallel - g_perp\n        \n        # 4. Perform verification checks\n        epsilon = 1e-8\n\n        # Check 1: F_parallel component matches g_parallel component\n        F_dot_tau = np.dot(F, tau_hat)\n        check1 = abs(F_dot_tau - g_dot_tau) = epsilon\n        \n        # Check 2: F_perp component equals -g_perp\n        F_perp = F - F_dot_tau * tau_hat\n        check2 = np.linalg.norm(F_perp - (-g_perp)) = epsilon\n\n        # Check 3: F_perp is energetically downhill with respect to g_perp\n        # This will be = 0 if check2 is met, due to F_perp ≈ -g_perp\n        dot_product_perp = np.dot(F_perp, g_perp)\n        check3 = dot_product_perp = 0.0 \n\n        # Aggregate results\n        final_check = check1 and check2 and check3\n        results.append(final_check)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}