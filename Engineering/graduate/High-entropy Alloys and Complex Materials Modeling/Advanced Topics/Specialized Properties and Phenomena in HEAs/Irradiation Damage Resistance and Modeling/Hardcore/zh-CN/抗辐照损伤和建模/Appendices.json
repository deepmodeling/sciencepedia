{
    "hands_on_practices": [
        {
            "introduction": "理解辐照损伤的第一步是量化初始缺陷的产生。当一个高能粒子撞击材料时，会引发一系列原子碰撞，即所谓的“位移级联”。本练习将引导你使用一个标准模型——Norgett–Robinson–Torrens (NRT) 模型——来估算由一次初始撞击（PKA）产生的初始缺陷（弗伦克尔对）的数量。通过这个练习，你将学会如何将入射粒子的能量与材料中产生的空位数量及其初始空间分布特征联系起来 。",
            "id": "3747416",
            "problem": "一种高熵合金 (HEA) 受到由能量为 $E_{\\text{PKA}}=20\\,\\text{keV}$ 的初级撞击原子 (PKA) 引发的位移级联作用。假设在此能量下，转移到原子运动（核阻止）的损伤能量是 PKA 能量的一个恒定比例 $\\kappa=0.8$，这与 Lindhard–Scharff 对几十千电子伏能量范围内的金属的能量分配理论一致。阈位移能为 $E_{d}=35\\,\\text{eV}$。使用一个与 Kinchin–Pease 框架一致并由 Norgett–Robinson–Torrens (NRT) 因子修正的位移产生模型，来估算初始产生的弗伦克尔对的数量。然后，假设初始产生的空位-间隙子对中只有一部分比例 $\\eta=0.3$ 在级联内复合和短时弛豫后，仍然以分离的缺陷（存活空位）形式存在。\n\n另外，基于分子动力学 (MD) 的级联形貌学研究表明，对于 $R\\ge 0$，空位团簇的回旋半径 $R$ 遵循以下分布族：\n$$\np(R)\\propto R^{D_{f}-1}\\exp\\!\\left(-\\frac{R}{R^{\\ast}}\\right),\n$$\n其中 $D_{f}$ 是团簇分形维数，$R^{\\ast}$ 是一个特征截止尺度。对于此高熵合金，在 $E_{\\text{PKA}}=20\\,\\text{keV}$ 时，取 $D_{f}=2.2$ 和 $R^{\\ast}=3.5\\,\\text{nm}$。定义缺陷团簇的空间相关长度 $\\xi$ 为 $R$ 在分布 $p(R)$ 下的平均值。\n\n计算：\n1. 存活空位的期望数量。\n2. 空间相关长度 $\\xi$。\n\n将两个量都四舍五入到四位有效数字。以 $\\text{nm}$ 为单位表示相关长度。最终答案必须按照上述顺序，以单行矩阵的形式给出两个数字。",
            "solution": "经验证，该问题具有科学依据、是良定且客观的。它呈现了一个辐射材料科学领域的标准计算，该计算基于已建立的模型和实际的物理参数。该问题按所述方式是可解的。\n\n按要求，解答分为两部分：计算存活空位的期望数量和空位团簇的空间相关长度。\n\n**第1部分：存活空位的期望数量**\n\n首先，我们确定损伤能量 $E_{\\text{damage}}$，它是初级撞击原子 (PKA) 能量 $E_{\\text{PKA}}$ 中转移到原子运动并有助于产生位移的那一部分。问题给出了 $E_{\\text{PKA}} = 20\\,\\text{keV}$ 和一个恒定比例 $\\kappa = 0.8$。\n能量单位必须一致，所以我们将千电子伏 ($\\text{keV}$) 转换为电子伏 ($\\text{eV}$)：\n$$E_{\\text{PKA}} = 20\\,\\text{keV} = 20 \\times 10^3\\,\\text{eV} = 2.0 \\times 10^4\\,\\text{eV}$$\n于是损伤能量为：\n$$E_{\\text{damage}} = \\kappa E_{\\text{PKA}} = 0.8 \\times (2.0 \\times 10^4\\,\\text{eV}) = 1.6 \\times 10^4\\,\\text{eV}$$\n\n接下来，我们使用 Norgett–Robinson–Torrens (NRT) 模型计算初始弗伦克尔对（空位-间隙子对）的数量 $N_{\\text{NRT}}$。该模型为给定的损伤能量 $E_{\\text{damage}}$ 和阈位移能 $E_d$ 提供了原子位移数量的估算。公式为：\n$$N_{\\text{NRT}} = \\frac{0.8 E_{\\text{damage}}}{2 E_d}$$\n该形式在 $E_{\\text{damage}}$ 远大于 $E_d$ 时有效。给定 $E_{\\text{damage}} = 1.6 \\times 10^4\\,\\text{eV}$ 和 $E_d = 35\\,\\text{eV}$，该条件得到满足。\n代入数值：\n$$N_{\\text{NRT}} = \\frac{0.8 \\times (1.6 \\times 10^4\\,\\text{eV})}{2 \\times 35\\,\\text{eV}} = \\frac{1.28 \\times 10^4}{70} = \\frac{12800}{70} = \\frac{1280}{7}$$\n这个值 $N_{\\text{NRT}} \\approx 182.857$ 代表了在级联中初始产生的位移数量。\n\n最后，我们计算存活空位的期望数量 $N_{\\text{surv}}$。初始产生的一大部分弗伦克尔对在级联冷却阶段会发生复合和湮灭。问题指出，只有一部分比例 $\\eta = 0.3$ 的初始对仍然以稳定的、分离的缺陷形式存在。\n$$N_{\\text{surv}} = \\eta N_{\\text{NRT}}$$\n代入 $\\eta$ 和 $N_{\\text{NRT}}$ 的值：\n$$N_{\\text{surv}} = 0.3 \\times \\frac{1280}{7} = \\frac{384}{7} \\approx 54.85714$$\n按要求将此结果四舍五入到四位有效数字，得到：\n$$N_{\\text{surv}} \\approx 54.86$$\n\n**第2部分：空间相关长度**\n\n空间相关长度 $\\xi$ 定义为空位团簇回旋半径 $R$ 的平均值，该半径遵循概率分布 $p(R)$。对于 $R \\ge 0$，给出的函数形式为：\n$$p(R) \\propto R^{D_{f}-1}\\exp\\left(-\\frac{R}{R^{\\ast}}\\right)$$\n设 $C$ 为归一化常数。概率密度函数 (PDF) 为：\n$$p(R) = C R^{D_{f}-1}\\exp\\left(-\\frac{R}{R^{\\ast}}\\right)$$\n为了求 $C$，我们使用归一化条件 $\\int_0^\\infty p(R) dR = 1$：\n$$C \\int_0^\\infty R^{D_{f}-1}\\exp\\left(-\\frac{R}{R^{\\ast}}\\right) dR = 1$$\n这个积分是与伽马函数 $\\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} dt$ 相关的标准形式。通过代换 $t = R/R^{\\ast}$，我们得到：\n$$\\int_0^\\infty R^{D_{f}-1}\\exp\\left(-\\frac{R}{R^{\\ast}}\\right) dR = (R^{\\ast})^{D_f} \\Gamma(D_f)$$\n因此，归一化常数为 $C = \\frac{1}{(R^{\\ast})^{D_f} \\Gamma(D_f)}$。分布 $p(R)$ 是一个形状参数为 $\\alpha = D_f$、尺度参数为 $\\theta = R^{\\ast}$ 的伽马分布。\n\n空间相关长度 $\\xi$ 是 $R$ 的期望值（平均值）：\n$$\\xi = \\langle R \\rangle = \\int_0^\\infty R \\, p(R) \\, dR = \\int_0^\\infty R \\left( \\frac{1}{(R^{\\ast})^{D_f} \\Gamma(D_f)} R^{D_f-1} \\exp\\left(-\\frac{R}{R^{\\ast}}\\right) \\right) dR$$\n$$\\xi = \\frac{1}{(R^{\\ast})^{D_f} \\Gamma(D_f)} \\int_0^\\infty R^{D_f} \\exp\\left(-\\frac{R}{R^{\\ast}}\\right) dR$$\n分子中的积分是 $\\int_0^\\infty R^{D_f} \\exp(-\\frac{R}{R^{\\ast}}) dR = (R^{\\ast})^{D_f+1} \\Gamma(D_f+1)$。\n将此代回，得到：\n$$\\xi = \\frac{1}{(R^{\\ast})^{D_f} \\Gamma(D_f)} (R^{\\ast})^{D_f+1} \\Gamma(D_f+1)$$\n使用伽马函数的性质 $\\Gamma(z+1)=z\\Gamma(z)$，我们有 $\\Gamma(D_f+1) = D_f\\Gamma(D_f)$。\n$$\\xi = \\frac{(R^{\\ast})^{D_f+1}}{(R^{\\ast})^{D_f}} \\frac{D_f \\Gamma(D_f)}{\\Gamma(D_f)} = D_f R^{\\ast}$$\n这证实了该分布的平均值是其形状参数和尺度参数的乘积。\n\n现在我们代入给定的值：分形维数 $D_f = 2.2$ 和特征尺度 $R^{\\ast} = 3.5\\,\\text{nm}$。\n$$\\xi = 2.2 \\times 3.5\\,\\text{nm} = 7.7\\,\\text{nm}$$\n将此四舍五入到四位有效数字，得到：\n$$\\xi = 7.700\\,\\text{nm}$$\n\n计算出的两个量是存活空位的数量 $54.86$ 和空间相关长度 $7.700\\,\\text{nm}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n54.86 & 7.700\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "缺陷产生后，它们在材料中的浓度并非一成不变，而是会随着时间演化。本练习介绍了一种强大的平均场方法——速率理论，用于模拟缺陷的产生、复合以及被位错或晶界等“缺陷阱”吸收之间的动态竞争过程。通过求解描述空位浓度随时间变化的速率方程，你将能够预测缺陷种群如何演化并最终达到一个动态平衡的稳态，这对于理解材料在长期辐照下的性能变化至关重要 。",
            "id": "3747483",
            "problem": "考虑一种均匀的高熵合金（HEA, High-Entropy Alloy），其在温度 $T=600$ K下经受恒定的辐照通量。空间平均空位数量密度 $n_v(t)$ 的时间演化由以下一阶常微分方程控制：\n$$\n\\frac{d n_v}{d t} = G_v - K_{vi}\\, n_v\\, n_i - k_v^2\\, D_v\\, n_v,\n$$\n其中，$G_v$ 是由辐照引起的空位产生率，$K_{vi}$ 是空位-间隙原子复合系数，$n_i$ 是（假定为常数）间隙原子数量密度，$k_v^2$ 是空位的有效陷阱强度，$D_v$ 是空位扩散系数。所有量均为空间平均值，并且仅通过 $n_v(t)$ 依赖于时间。您必须使用以下第一性原理建模基础求解该方程以得到 $n_v(t)$：辐照下点缺陷的形成与湮灭平衡，其中复合被处理为双分子反应，陷阱吸收被处理为具有有效陷阱强度的扩散捕获。假设在所关心的时间区间内 $n_i$ 保持不变。\n\n定义和单位：\n- $n_v(t)$ 是空位数量密度，单位为 $\\mathrm{m^{-3}}$。\n- $G_v$ 是空位产生率，单位为 $\\mathrm{m^{-3}\\, s^{-1}}$。\n- $K_{vi}$ 是复合系数，单位为 $\\mathrm{m^{3}\\, s^{-1}}$。\n- $n_i$ 是间隙原子数量密度，单位为 $\\mathrm{m^{-3}}$。\n- $k_v^2$ 是陷阱强度，单位为 $\\mathrm{m^{-2}}$。\n- $D_v$ 是空位扩散系数，单位为 $\\mathrm{m^{2}\\, s^{-1}}$。\n- 时间 $t$ 的单位为 $\\mathrm{s}$。\n\n您的程序必须为下面列出的每个测试用例计算在指定时间点的 $n_v(t)$。每个时间点的答案必须表示为一个浮点数，代表以 $\\mathrm{m^{-3}}$ 为单位的值。整个测试套件的输出必须是单行，包含一个用方括号括起来的逗号分隔的列表的列表，其中每个内部列表对应一个测试用例，并按顺序包含在指定时间计算出的 $n_v(t)$ 值。将所有浮点数以科学记数法表示，保留恰好 $6$ 位有效数字，单位默认为 $\\mathrm{m^{-3}}$。\n\n测试套件：\n- 测试用例 1 (典型HEA，稳定辐照，快速陷阱)：\n  - 参数：$G_v = 1.0\\times 10^{23}\\ \\mathrm{m^{-3}\\, s^{-1}}$，$K_{vi} = 5.0\\times 10^{-17}\\ \\mathrm{m^{3}\\, s^{-1}}$，$n_i = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$，$k_v^2 = 2.0\\times 10^{14}\\ \\mathrm{m^{-2}}$，$D_v = 1.0\\times 10^{-18}\\ \\mathrm{m^{2}\\, s^{-1}}$，$n_v(0)=0\\ \\mathrm{m^{-3}}$。\n  - 时间：$t\\in\\{0,\\ 1.0\\times 10^{-4},\\ 1.0\\times 10^{-3},\\ 1.0\\times 10^{-2},\\ 1.0\\times 10^{-1},\\ 1.0\\}\\ \\mathrm{s}$。\n- 测试用例 2 (无产生，从初始布居衰减)：\n  - 参数：$G_v = 0\\ \\mathrm{m^{-3}\\, s^{-1}}$，$K_{vi} = 5.0\\times 10^{-17}\\ \\mathrm{m^{3}\\, s^{-1}}$，$n_i = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$，$k_v^2 = 2.0\\times 10^{14}\\ \\mathrm{m^{-2}}$，$D_v = 1.0\\times 10^{-18}\\ \\mathrm{m^{2}\\, s^{-1}}$，$n_v(0)=1.0\\times 10^{21}\\ \\mathrm{m^{-3}}$。\n  - 时间：$t\\in\\{0,\\ 1.0\\times 10^{-2},\\ 1.0\\times 10^{-1},\\ 1.0,\\ 1.0\\times 10^{1}\\}\\ \\mathrm{s}$。\n- 测试用例 3 (弱陷阱和中等产生率，缓慢达到稳态)：\n  - 参数：$G_v = 1.0\\times 10^{21}\\ \\mathrm{m^{-3}\\, s^{-1}}$，$K_{vi} = 1.0\\times 10^{-18}\\ \\mathrm{m^{3}\\, s^{-1}}$，$n_i = 1.0\\times 10^{16}\\ \\mathrm{m^{-3}}$，$k_v^2 = 1.0\\times 10^{12}\\ \\mathrm{m^{-2}}$，$D_v = 1.0\\times 10^{-20}\\ \\mathrm{m^{2}\\, s^{-1}}$，$n_v(0)=0\\ \\mathrm{m^{-3}}$。\n  - 时间：$t\\in\\{0,\\ 1.0\\times 10^{1},\\ 1.0\\times 10^{2},\\ 1.0\\times 10^{3},\\ 1.0\\times 10^{4}\\}\\ \\mathrm{s}$。\n- 测试用例 4 (复合可忽略，强产生下的陷阱限制稳态)：\n  - 参数：$G_v = 5.0\\times 10^{23}\\ \\mathrm{m^{-3}\\, s^{-1}}$，$K_{vi} = 1.0\\times 10^{-21}\\ \\mathrm{m^{3}\\, s^{-1}}$，$n_i = 1.0\\times 10^{10}\\ \\mathrm{m^{-3}}$，$k_v^2 = 2.0\\times 10^{14}\\ \\mathrm{m^{-2}}$，$D_v = 1.0\\times 10^{-18}\\ \\mathrm{m^{2}\\, s^{-1}}$，$n_v(0)=0\\ \\mathrm{m^{-3}}$。\n  - 时间：$t\\in\\{0,\\ 1.0,\\ 1.0\\times 10^{1},\\ 1.0\\times 10^{2},\\ 1.0\\times 10^{3}\\}\\ \\mathrm{s}$。\n- 测试用例 5 (净消除率接近于零，以累积为主，数值稳定性检查)：\n  - 参数：$G_v = 5.0\\times 10^{17}\\ \\mathrm{m^{-3}\\, s^{-1}}$，$K_{vi} = 1.0\\times 10^{-20}\\ \\mathrm{m^{3}\\, s^{-1}}$，$n_i = 1.0\\times 10^{10}\\ \\mathrm{m^{-3}}$，$k_v^2 = 1.0\\times 10^{8}\\ \\mathrm{m^{-2}}$，$D_v = 1.0\\times 10^{-22}\\ \\mathrm{m^{2}\\, s^{-1}}$，$n_v(0)=1.0\\times 10^{18}\\ \\mathrm{m^{-3}}$。\n  - 时间：$t\\in\\{0,\\ 1.0\\times 10^{1},\\ 1.0\\times 10^{2}\\}\\ \\mathrm{s}$。\n\n算法要求：\n- 将 $n_i$ 视为常数，并对每个时间集求解给定的常微分方程以得到 $n_v(t)$。\n- 在计算 $n_v(t)$ 时，确保对于非常小的净消除率 $\\lambda = K_{vi}\\, n_i + k_v^2\\, D_v$ 具有数值鲁棒性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是一个用方括号括起来的逗号分隔列表，代表一个测试用例的计算值，且不含空格。例如：$[[x_1,x_2], [y_1,y_2,y_3]]$，但无空格，如 $[[x_1,x_2],[y_1,y_2,y_3]]$。\n- 对每个浮点数使用具有恰好 $6$ 位有效数字的科学记数法。所有报告值均代表以 $\\mathrm{m^{-3}}$ 为单位的 $n_v(t)$。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于材料科学的原理，特别是辐射损伤的速率理论。该问题在数学上是适定的，提供了一个带有常数系数的线性一阶常微分方程，并为每个测试用例指定了初始条件。所有参数都明确定义，其单位在量纲上是一致的。提供的数值在合理的物理范围内。问题是客观、无歧义的，并包含足够的信息以获得唯一解。\n\n空间平均空位数量密度 $n_v(t)$ 的时间演化由以下微分方程控制：\n$$\n\\frac{d n_v}{d t} = G_v - K_{vi}\\, n_v\\, n_i - k_v^2\\, D_v\\, n_v\n$$\n该方程形式化了所述的空位产生和湮灭机制之间的平衡。项 $G_v$ 代表由辐照引起的空位产生。项 $-K_{vi}\\, n_v\\, n_i$ 模拟了通过与间隙原子复合（一个双分子过程）而发生的空位湮灭。项 $-k_v^2\\, D_v\\, n_v$ 代表空位通过扩散流失到固定陷阱（例如位错、晶界）。\n\n由于假定间隙原子数量密度 $n_i$ 为常数，该方程是关于 $n_v$ 的线性一阶常微分方程。我们可以通过组合包含 $n_v$ 的项来重新整理它：\n$$\n\\frac{d n_v}{d t} = G_v - (K_{vi}\\, n_i + k_v^2\\, D_v) n_v\n$$\n为了简化表示，我们定义一个复合参数 $\\lambda$，它代表空位消除的总速率常数：\n$$\n\\lambda = K_{vi}\\, n_i + k_v^2\\, D_v\n$$\n$\\lambda$ 的单位是 $\\mathrm{s^{-1}}$。其倒数 $1/\\lambda$ 代表空位在被湮灭前的特征寿命。微分方程现在呈现为具有常数系数的线性一阶ODE的标准形式：\n$$\n\\frac{d n_v}{d t} + \\lambda n_v = G_v\n$$\n该方程可以使用多种方法求解，例如积分因子法。在初始条件 $n_v(t=0) = n_v(0)$ 下，其通解为：\n$$\nn_v(t) = n_{v,ss} + (n_v(0) - n_{v,ss}) e^{-\\lambda t}\n$$\n其中 $n_{v,ss}$ 是在 $t \\to \\infty$ 时达到的稳态空位浓度。这可以通过设置 $\\frac{d n_v}{d t} = 0$ 来求得，结果为：\n$$\nn_{v,ss} = \\frac{G_v}{\\lambda} = \\frac{G_v}{K_{vi}\\, n_i + k_v^2\\, D_v}\n$$\n该稳态解仅在 $\\lambda > 0$ 时有效。\n\n根据 $\\lambda$ 的值，会出现两种不同的物理机制：\n1. 如果 $\\lambda > 0$，系统会指数级地接近稳态浓度 $n_{v,ss}$。与稳态的初始偏差 $(n_v(0) - n_{v,ss})$ 以 $1/\\lambda$ 的特征时间常数衰减。\n2. 如果 $\\lambda = 0$，这意味着复合和陷阱吸收都可以忽略（$K_{vi} n_i = 0$ 且 $k_v^2 D_v = 0$）。消除项消失，ODE简化为 $\\frac{d n_v}{d t} = G_v$。解是空位随时间的线性累积：$n_v(t) = G_v t + n_v(0)$。\n\n对于数值实现，解析解可以重写为：\n$$\nn_v(t) = \\frac{G_v}{\\lambda} (1 - e^{-\\lambda t}) + n_v(0) e^{-\\lambda t}\n$$\n然而，当乘积 $\\lambda t$ 非常接近 $0$ 时，这种形式会带来数值稳定性挑战。在此极限下，$e^{-\\lambda t} \\approx 1 - \\lambda t$，而项 $\\frac{G_v}{\\lambda} (1 - e^{-\\lambda t})$ 接近于不定式 $\\frac{0}{0}$。直接计算可能因灾难性抵消而导致精度损失。\n\n为确保问题陈述所要求的数值鲁棒性，我们必须仔细处理这种情况。第一个项的问题可以通过使用为此目的设计的库函数来规避，例如 `numpy.expm1(x)`，它可以精确计算小 $x$ 值的 $e^x - 1$。我们的项可以表示为：\n$$\n\\frac{G_v}{\\lambda} (1 - e^{-\\lambda t}) = \\frac{G_v}{\\lambda} (-(e^{-\\lambda t} - 1)) = G_v \\frac{-\\text{np.expm1}(-\\lambda t)}{\\lambda}\n$$\n对于小的 $\\lambda t$，我们知道 $\\text{expm1}(-\\lambda t) \\approx -\\lambda t$，因此该表达式能正确且稳定地计算出 $G_v t$。\n\n因此，计算 $n_v(t)$ 的算法如下：\n首先，计算 $\\lambda = K_{vi}\\, n_i + k_v^2\\, D_v$。\n然后，对于每个时间点 $t$：\n- 如果 $\\lambda$ 实际上为零（例如，使用基于容差的比较，如 `numpy.isclose`），则解为 $n_v(t) = G_v t + n_v(0)$。\n- 如果 $\\lambda$ 非零，则使用数值稳定的公式计算解：\n$$\nn_v(t) = G_v \\frac{-\\text{np.expm1}(-\\lambda t)}{\\lambda} + n_v(0) e^{-\\lambda t}\n$$\n该方法能正确处理所有测试用例，包括 $\\lambda$ 被设计得非常小的用例5，从而验证了实现的数值稳定性。$n_v(t=0)$ 的值自然由 $n_v(0)$ 给出，因为指数项和 `expm1` 项分别变为 $1$ 和 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the vacancy number density ODE for given parameters and times.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": {\n                \"Gv\": 1.0e23, \"Kvi\": 5.0e-17, \"ni\": 1.0e19,\n                \"kv2\": 2.0e14, \"Dv\": 1.0e-18, \"nv0\": 0.0\n            },\n            \"times\": [0.0, 1.0e-4, 1.0e-3, 1.0e-2, 1.0e-1, 1.0]\n        },\n        {\n            \"params\": {\n                \"Gv\": 0.0, \"Kvi\": 5.0e-17, \"ni\": 1.0e19,\n                \"kv2\": 2.0e14, \"Dv\": 1.0e-18, \"nv0\": 1.0e21\n            },\n            \"times\": [0.0, 1.0e-2, 1.0e-1, 1.0, 1.0e1]\n        },\n        {\n            \"params\": {\n                \"Gv\": 1.0e21, \"Kvi\": 1.0e-18, \"ni\": 1.0e16,\n                \"kv2\": 1.0e12, \"Dv\": 1.0e-20, \"nv0\": 0.0\n            },\n            \"times\": [0.0, 1.0e1, 1.0e2, 1.0e3, 1.0e4]\n        },\n        {\n            \"params\": {\n                \"Gv\": 5.0e23, \"Kvi\": 1.0e-21, \"ni\": 1.0e10,\n                \"kv2\": 2.0e14, \"Dv\": 1.0e-18, \"nv0\": 0.0\n            },\n            \"times\": [0.0, 1.0, 1.0e1, 1.0e2, 1.0e3]\n        },\n        {\n            \"params\": {\n                \"Gv\": 5.0e17, \"Kvi\": 1.0e-20, \"ni\": 1.0e10,\n                \"kv2\": 1.0e8, \"Dv\": 1.0e-22, \"nv0\": 1.0e18\n            },\n            \"times\": [0.0, 1.0e1, 1.0e2]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        times = case[\"times\"]\n        \n        Gv = params[\"Gv\"]\n        Kvi = params[\"Kvi\"]\n        ni = params[\"ni\"]\n        kv2 = params[\"kv2\"]\n        Dv = params[\"Dv\"]\n        nv0 = params[\"nv0\"]\n\n        case_results = []\n\n        # Calculate the total rate constant for vacancy removal\n        lambda_val = Kvi * ni + kv2 * Dv\n\n        for t in times:\n            if np.isclose(lambda_val, 0.0):\n                # Linear accumulation if removal mechanisms are absent\n                nv_t = Gv * t + nv0\n            else:\n                # Numerically stable solution for the ODE\n                # nv(t) = (Gv/lambda) * (1 - exp(-lambda*t)) + nv0 * exp(-lambda*t)\n                # Rewritten for numerical stability using np.expm1 for (exp(x)-1)\n                \n                lambda_t = lambda_val * t\n                \n                # First term: Gv * (1 - exp(-lambda*t)) / lambda\n                # = Gv * (- (exp(-lambda*t) - 1)) / lambda\n                # = Gv * (-expm1(-lambda*t)) / lambda\n                term1 = Gv * (-np.expm1(-lambda_t)) / lambda_val\n                \n                # Second term: nv0 * exp(-lambda*t)\n                term2 = nv0 * np.exp(-lambda_t)\n                \n                nv_t = term1 + term2\n            \n            case_results.append(nv_t)\n            \n        all_results.append(case_results)\n\n    # Format the final output according to problem specifications.\n    # No spaces, scientific notation with 6 significant digits.\n    inner_strings = [\n        f\"[{','.join(['{:.6e}'.format(v) for v in res])}]\"\n        for res in all_results\n    ]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "像速率理论这样的宏观模型依赖于扩散系数等关键参数，但这些参数本身源于更微观的原子行为。本练习将带你深入原子尺度，通过构建一个动力学蒙特卡罗（KMC）模拟，来追踪单个间隙原子在高熵合金复杂化学环境中的随机游走过程。你将亲手实现一个模型，该模型考虑了局部原子环境对缺陷迁移能垒的影响，并最终利用爱因斯坦关系从原子运动轨迹中计算出宏观扩散系数，从而架起连接原子结构与宏观性能的桥梁 。",
            "id": "3747412",
            "problem": "你的任务是构建一个基于对象的动力学蒙特卡洛（KMC）模拟器，用于模拟单个自间隙原子（SIA）在体心立方（BCC）高熵合金（HEA）晶格中的迁移。目标是针对与成分相关的迁移势垒，计算均方根位移（MSD）作为时间的函数，并使用爱因斯坦关系式提取有效的、与温度相关的SIA扩散系数 $D_{\\text{SIA}}(T)$。模拟必须以纯粹的数学和算法术语来构建，并基于基本原理和经过充分检验的公式。\n\n使用的基本原理和建模假设：\n- SIA 在 BCC 晶格上沿 $\\langle 111 \\rangle$ 方向进行随机跳跃，最近邻集合的基数为 $z = 8$。每次跳跃都跳到 8 个最近邻之一，实在空间位移矢量的大小为 $\\sqrt{3}a/2$，沿每个笛卡尔轴的分量为 $\\pm a/2$，其中 $a$ 是晶格参数（单位：米）。\n- 采用阿伦尼乌斯速率模型来描述热激活跳跃：跳跃到邻居 $i$ 的速率为 $r_i = \\nu_0 \\exp\\left(-E_{m,i}/(k_B T)\\right)$，其中 $\\nu_0$ 是尝试频率（单位：$\\text{s}^{-1}$），$E_{m,i}$ 是到邻近位置 $i$ 的迁移能垒（单位：电子伏特），$k_B$ 是以电子伏特每开尔文表示的玻尔兹曼常数，$T$ 是温度（单位：开尔文）。\n- 必须使用对象动力学蒙特卡洛事件选择方法：在每一步中，如果可能事件集合的速率为 $\\{r_i\\}_{i=1}^z$，则时间增量为 $\\Delta t = -\\ln(u)/\\sum_{i=1}^z r_i$，其中 $u \\in (0,1)$ 是一个均匀分布的随机数，并且通过与 $r_i$ 成比例地选择邻居 $i$ 来选择一个事件。\n- 在 $d=3$ 维中，爱因斯坦关系式将 MSD 与扩散系数联系起来：$D = \\frac{1}{2d}\\frac{d}{dt}\\langle \\Delta \\mathbf{r}(t)^2 \\rangle$，因此 $D = \\frac{1}{6}\\frac{d}{dt}\\langle \\Delta \\mathbf{r}(t)^2 \\rangle$。你必须通过对 KMC 轨迹的 MSD 与时间进行线性拟合来估计斜率 $\\frac{d}{dt}\\langle \\Delta \\mathbf{r}(t)^2 \\rangle$。\n- 必须对晶格索引施加周期性边界条件以避免有限尺寸效应，同时，为了计算 MSD，必须将 SIA 的实在空间位移作为展开坐标进行追踪。\n\n与成分相关的迁移能模型：\n- 考虑一种由组分 $\\{\\text{Mo}, \\text{Nb}, \\text{Ta}, \\text{W}\\}$ 构成的难熔 BCC HEA，其全局成分分数为 $\\{c_{\\text{Mo}}, c_{\\text{Nb}}, c_{\\text{Ta}}, c_{\\text{W}}\\}$（每个分数为无量纲，且总和为 1）。\n- 晶格是一个尺寸为 $L \\times L \\times L$ 的简单立方网格，其中两个互穿的子晶格通过索引空间中的最近邻偏移量 $(\\pm 1, \\pm 1, \\pm 1)$ 来表示 BCC 结构。每个晶格位置根据全局成分被赋予一种物种。将最近邻壳层视为距离给定位置偏移量为 $(\\pm 1, \\pm 1, \\pm 1)$ 的 8 个位置的集合。\n- 将位置 $\\mathbf{x}$ 处的局域成分定义为其最近邻壳层中物种的分数：如果邻居壳层包含 8 个位置，其物种计数为 $\\{n_{\\text{Mo}}, n_{\\text{Nb}}, n_{\\text{Ta}}, n_{\\text{W}}\\}$，则局域成分分数为 $c^{\\text{loc}}_{\\alpha}(\\mathbf{x}) = n_{\\alpha}/8$，其中 $\\alpha \\in \\{\\text{Mo}, \\text{Nb}, \\text{Ta}, \\text{W}\\}$。\n- 位置 $\\mathbf{x}$ 处的迁移能被建模为线性混合 $E_m(\\mathbf{x}) = \\sum_{\\alpha} c^{\\text{loc}}_{\\alpha}(\\mathbf{x}) E_{\\alpha}$，其中 $E_{\\alpha}$ 是对于 $\\alpha \\in \\{\\text{Mo}, \\text{Nb}, \\text{Ta}, \\text{W}\\}$ 的物种特定迁移能贡献（单位：电子伏特）。\n- 对于跳跃速率，使用 $E_{m,i} = E_m(\\mathbf{x}_i)$，即与目标邻居位置 $\\mathbf{x}_i$ 相关的迁移能。\n\n算法要求：\n- 使用带有给定种子的伪随机数生成器，根据指定的全局成分初始化晶格物种分配。\n- 根据所有晶格位置的局域邻居成分，预先计算它们的 $E_m(\\mathbf{x})$。\n- 将 SIA 放置在一个随机的晶格位置，追踪指定事件数 $N_{\\text{events}}$ 的 KMC 轨迹，并累积时间序列 $\\{t_n\\}$ 和平方位移 $\\{|\\Delta \\mathbf{r}(t_n)|^2\\}$。\n- 通过对整个轨迹的 $|\\Delta \\mathbf{r}(t)|^2$ 与 $t$ 进行普通最小二乘拟合来估计斜率，并计算 $D_{\\text{SIA}}(T) = \\frac{\\text{slope}}{6}$。\n- 使用玻尔兹曼常数 $k_B = 8.617333262145 \\times 10^{-5}\\ \\text{eV/K}$。\n\n单位和输出：\n- 将 $D_{\\text{SIA}}(T)$ 以 $\\text{m}^2/\\text{s}$ 为单位表示，使用科学记数法并四舍五入到六位有效数字。角度单位不适用于此任务。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。\n\n测试套件：\n使用以下参数集生成四个结果。对于每种情况，程序必须运行 KMC 模拟，计算 $D_{\\text{SIA}}(T)$，并以指定的单行格式输出所有四个结果。\n- 通用的物种特定迁移能贡献（单位：电子伏特）：$E_{\\text{Mo}} = 0.30$, $E_{\\text{Nb}} = 0.20$, $E_{\\text{Ta}} = 0.35$, $E_{\\text{W}} = 0.40$。\n- 尝试频率：$\\nu_0 = 1.0 \\times 10^{13}\\ \\text{s}^{-1}$。\n- 晶格参数：$a = 3.20 \\times 10^{-10}\\ \\text{m}$。\n- 情况 1（理想情况，室温下的等原子比难熔 HEA）：\n  - $T = 300.0\\ \\text{K}$，\n  - 全局成分 $\\{c_{\\text{Mo}}, c_{\\text{Nb}}, c_{\\text{Ta}}, c_{\\text{W}}\\} = \\{0.25, 0.25, 0.25, 0.25\\}$，\n  - 晶格尺寸 $L = 32$，\n  - KMC 事件数 $N_{\\text{events}} = 50000$，\n  - 随机种子 $= 1$。\n- 情况 2（中等温度下成分偏斜的 HEA）：\n  - $T = 600.0\\ \\text{K}$，\n  - 全局成分 $\\{0.40, 0.20, 0.20, 0.20\\}$，\n  - $L = 32$，\n  - $N_{\\text{events}} = 50000$，\n  - 种子 $= 2$。\n- 情况 3（高温下的等原子比 HEA，减少事件数以保持适度的运行时间）：\n  - $T = 1200.0\\ \\text{K}$，\n  - 全局成分 $\\{0.25, 0.25, 0.25, 0.25\\}$，\n  - $L = 24$，\n  - $N_{\\text{events}} = 20000$，\n  - 种子 $= 3$。\n- 情况 4（边界情况，室温下单物种极限及恒定势垒）：\n  - $T = 300.0\\ \\text{K}$，\n  - 全局成分 $\\{0.0, 0.0, 0.0, 1.0\\}$，\n  - $L = 32$，\n  - $N_{\\text{events}} = 50000$，\n  - 种子 $= 4$。\n\n实现约束：\n- 对晶格索引使用周期性边界条件。\n- 在索引空间中使用最近邻偏移量 $(\\pm 1, \\pm 1, \\pm 1)$ 来定义 BCC 邻居壳层并推进 SIA 位置。\n- 最终输出必须是单行：一个用方括号括起来的逗号分隔列表，包含四个计算出的 $D_{\\text{SIA}}(T)$ 值（单位 $\\text{m}^2/\\text{s}$），使用科学记数法并四舍五入到六位有效数字，无附加文本。",
            "solution": "用户在计算材料科学领域提供了一个科学上和数学上都合理的问题。该问题是良构的，所有必要的参数、模型和算法都已明确定义。它要求实现一个基于对象的动力学蒙特卡洛 (KMC) 模拟，以研究自间隙原子 (SIA) 在多组分体心立方 (BCC) 高熵合金 (HEA) 中的扩散。该问题是有效的，并且可以按规定解决。\n\n解决方案涉及以下步骤，这些步骤基于统计力学和计算模拟的原理：\n\n**1. 理论框架**\n\n模拟的核心是基于对象的动力学蒙特卡洛 (KMC) 算法，该算法对系统在离散状态之间转换的随机时间演化进行建模。系统状态由单个 SIA 在 BCC 晶格上的位置定义。\n\n- **跳跃速率**：位于晶格位置上的 SIA 可以跳到其 $z=8$ 个最近邻之一。向邻居位置 $i$ 跳跃的速率 $r_i$ 由描述热激活过程的阿伦尼乌斯方程决定：\n$$\nr_i = \\nu_0 \\exp\\left(-\\frac{E_{m,i}}{k_B T}\\right)\n$$\n其中 $\\nu_0$ 是尝试频率，$E_{m,i}$ 是迁移能垒，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n- **迁移能模型**：迁移势垒 $E_{m,i}$ 不是恒定的，而是取决于*目标*位置 $\\mathbf{x}_i$ 的局域化学环境。它被计算为物种特定能量贡献 $E_{\\alpha}$ 的线性混合：\n$$\nE_{m,i} = E_m(\\mathbf{x}_i) = \\sum_{\\alpha \\in \\{\\text{Mo, Nb, Ta, W}\\}} c^{\\text{loc}}_{\\alpha}(\\mathbf{x}_i) E_{\\alpha}\n$$\n此处，$c^{\\text{loc}}_{\\alpha}(\\mathbf{x}_i)$ 是目标位置 $\\mathbf{x}_i$ 最近邻壳层中物种 $\\alpha$ 的局域原子分数。其计算方式为 $c^{\\text{loc}}_{\\alpha}(\\mathbf{x}_i) = n_{\\alpha}/z$，其中 $n_{\\alpha}$ 是物种 $\\alpha$ 的邻居数量，$z=8$ 对应 BCC 晶格。\n\n- **KMC 算法**：在每一步，模拟根据可能的跳跃速率集合 $\\{r_i\\}_{i=1}^z$ 向前推进。\n    1.  任何事件发生的总速率是所有单个速率的总和：$R = \\sum_{i=1}^z r_i$。\n    2.  KMC 步骤中经过的时间从均值为 $1/R$ 的指数分布中抽取，计算为 $\\Delta t = -\\frac{\\ln(u_1)}{R}$，其中 $u_1$ 是在 $(0, 1)$ 区间内均匀分布的随机数。总模拟时间被累积：$t_{n+1} = t_n + \\Delta t$。\n    3.  以与其速率 $P_j = r_j / R$ 成正比的概率选择一个特定的跳跃事件 $j$。这通过抽取第二个随机数 $u_2 \\in (0,1)$ 并找到满足条件 $\\sum_{k=1}^{j-1} r_k  u_2 R \\le \\sum_{k=1}^{j} r_k$ 的索引 $j$ 来实现。\n\n- **扩散系数**：SIA 的扩散行为由其扩散系数 $D_{\\text{SIA}}$ 来量化。这是使用三维爱Einstein关系式从原子随时间的均方根位移 (MSD) 中提取的：\n$$\n\\langle |\\Delta \\mathbf{r}(t)|^2 \\rangle = 6 D_{\\text{SIA}} t\n$$\n其中 $\\langle |\\Delta \\mathbf{r}(t)|^2 \\rangle$ 是时间 $t$ 后从原点出发的平均平方位移。在单次模拟运行中，我们追踪平方位移 $|\\Delta \\mathbf{r}(t_n)|^2$ 的时间序列，并假定存在线性关系。然后，从 $|\\Delta \\mathbf{r}(t)|^2$ 与 $t$ 数据的线性拟合斜率来估计扩散系数：\n$$\nD_{\\text{SIA}} = \\frac{1}{6} \\times \\text{slope}\n$$\n\n**2. 算法实现**\n\n模拟将按照问题的规范进行实现。\n\n- **晶格表示与初始化**：\n    - 使用一个尺寸为 $L \\times L \\times L$ 的三维数组来表示晶格位置。\n    - 每个位置 $(i,j,k)$ 被赋予一个整数，代表四种物种 $\\{\\text{Mo}, \\text{Nb}, \\text{Ta}, \\text{W}\\}$ 之一。该分配是随机完成的，根据指定的全局成分分数 $\\{c_{\\alpha}\\}$，使用带种子的伪随机数生成器从物种池中抽取，以确保可复现性。\n    - 对所有晶格索引计算应用周期性边界条件，使用模运算符（例如 `(i + di) % L`）。\n\n- **能量景观预计算**：\n    - 为了优化 KMC 循环，对晶格上每个位置 $\\mathbf{x}$ 的迁移能 $E_m(\\mathbf{x})$ 进行预计算，并存储在一个单独的 $L \\times L \\times L$ 数组中。\n    - 对于每个位置，使用索引偏移量 $(\\pm 1, \\pm 1, \\pm 1)$ 和周期性边界条件来确定其 $z=8$ 个邻居。\n    - 对这些邻居的物种进行计数，以计算局域成分 $c^{\\text{loc}}_{\\alpha}(\\mathbf{x})$，然后通过线性混合规则用它来计算 $E_m(\\mathbf{x})$。\n\n- **动力学蒙特卡洛模拟循环**：\n    1.  将 SIA 放置在一个随机的初始位置 $(i_0, j_0, k_0)$。其实在空间位置 $\\Delta\\mathbf{r}$ 初始化为 $(0,0,0)$。模拟时间 $t$ 初始化为 $0$。\n    2.  模拟进行固定数量的事件，即 $N_{\\text{events}}$。\n    3.  在每个事件步骤中，使用预先计算的能量 $E_{m,i}$ 来计算到 8 个邻近位置的速率 $r_i$。\n    4.  使用上述 KMC 算法确定时间步长 $\\Delta t$ 和选择的跳跃事件。\n    5.  将 SIA 的晶格索引更新为所选邻居的索引。\n    6.  通过加上相应的跳跃矢量来更新实在空间位移矢量，该矢量的分量为 $(\\pm a/2, \\pm a/2, \\pm a/2)$。这个“展开的”坐标对于正确计算总位移至关重要。\n    7.  记录新的模拟时间 $t$ 和总平方位移 $|\\Delta \\mathbf{r}(t)|^2$。\n\n- **数据分析**：\n    - KMC 循环完成后，将收集到的 MSD 和时间的时间序列数据传递给一个普通最小二乘线性回归程序（例如 `numpy.polyfit`）。\n    - 提取最佳拟合线的斜率。\n    - 扩散系数 $D_{\\text{SIA}}$ 计算为 $\\text{slope}/6$。\n    - 最终结果被格式化为具有六位有效数字的科学记数法。\n\n这种结构化的方法确保了模拟能精确地反映问题陈述中描述的物理模型，并确保最终计算出的扩散系数值在该模型的背景下既是可复现的，又是在物理上是有意义的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SiaKmcSimulator:\n    \"\"\"\n    A class to simulate SIA diffusion in a BCC HEA using object-KMC.\n    \"\"\"\n    def __init__(self, T, comp, L, N_events, seed, E_species, nu0, a, kB):\n        \"\"\"\n        Initializes the simulator with all necessary parameters for a single case.\n        \"\"\"\n        self.T = float(T)\n        self.comp = np.array(comp, dtype=float)\n        self.L = int(L)\n        self.N_events = int(N_events)\n        self.seed = int(seed)\n        self.E_species = np.array(E_species, dtype=float)\n        self.nu0 = float(nu0)\n        self.a = float(a)\n        self.kB = float(kB)\n\n        # Set the seed for reproducibility of the entire case run\n        np.random.seed(self.seed)\n\n        self.species_map = {'Mo': 0, 'Nb': 1, 'Ta': 2, 'W': 3}\n        self.num_species = len(self.species_map)\n        \n        # BCC neighbor index offsets and corresponding real-space displacement vectors\n        self.neighbor_idx_offsets = np.array([\n            [i, j, k] for i in [-1, 1] for j in [-1, 1] for k in [-1, 1]\n        ], dtype=int)\n        \n        self.lattice = None\n        self.energy_landscape = None\n\n    def _setup_lattice(self):\n        \"\"\"Initializes the lattice with species according to the global composition.\"\"\"\n        species_indices = np.arange(self.num_species)\n        self.lattice = np.random.choice(\n            species_indices,\n            size=(self.L, self.L, self.L),\n            p=self.comp\n        )\n\n    def _precompute_energies(self):\n        \"\"\"Pre-computes the migration energy for every site on the lattice.\"\"\"\n        self.energy_landscape = np.zeros((self.L, self.L, self.L), dtype=float)\n        \n        for ix in range(self.L):\n            for iy in range(self.L):\n                for iz in range(self.L):\n                    # Find neighbors using periodic boundary conditions\n                    neighbor_coords = (np.array([ix, iy, iz]) + self.neighbor_idx_offsets) % self.L\n                    \n                    # Get species IDs of the neighbors\n                    neighbor_species_ids = self.lattice[neighbor_coords[:, 0], neighbor_coords[:, 1], neighbor_coords[:, 2]]\n                    \n                    # Calculate local composition\n                    species_counts = np.bincount(neighbor_species_ids, minlength=self.num_species)\n                    local_comp = species_counts / 8.0\n                    \n                    # Calculate migration energy based on local composition\n                    migration_energy = np.sum(local_comp * self.E_species)\n                    self.energy_landscape[ix, iy, iz] = migration_energy\n\n    def _run_kmc_loop(self):\n        \"\"\"Executes the KMC simulation loop.\"\"\"\n        # Initial SIA position (lattice index)\n        sia_pos_idx = np.random.randint(0, self.L, size=3)\n        \n        # Unwrapped real-space position, initialized to origin\n        sia_pos_real = np.array([0.0, 0.0, 0.0])\n        \n        current_time = 0.0\n        times = np.zeros(self.N_events, dtype=float)\n        msds = np.zeros(self.N_events, dtype=float)\n        \n        for event in range(self.N_events):\n            # 1. Get neighbors of current SIA site\n            neighbor_indices = (sia_pos_idx + self.neighbor_idx_offsets) % self.L\n            \n            # 2. Get pre-computed migration energies for jumps to these neighbors\n            dest_energies = self.energy_landscape[neighbor_indices[:, 0], neighbor_indices[:, 1], neighbor_indices[:, 2]]\n            \n            # 3. Calculate jump rates using Arrhenius model\n            rates = self.nu0 * np.exp(-dest_energies / (self.kB * self.T))\n            \n            # 4. Calculate total rate\n            total_rate = np.sum(rates)\n            \n            if total_rate == 0:\n                # Trap state, simulation cannot proceed\n                times = times[:event]\n                msds = msds[:event]\n                break\n\n            # 5. Advance time (residence time algorithm)\n            time_step = -np.log(np.random.rand()) / total_rate\n            current_time += time_step\n            \n            # 6. Select a jump event proportional to its rate\n            probabilities = rates / total_rate\n            chosen_offset_idx = np.random.choice(8, p=probabilities)\n            \n            # 7. Update SIA position (lattice index and real-space)\n            sia_pos_idx = neighbor_indices[chosen_offset_idx]\n            \n            real_displacement = self.neighbor_idx_offsets[chosen_offset_idx] * (self.a / 2.0)\n            sia_pos_real += real_displacement\n            \n            # 8. Store time and mean-square displacement\n            times[event] = current_time\n            msds[event] = np.sum(sia_pos_real**2)\n            \n        return times, msds\n\n    def _calculate_diffusion_coefficient(self, times, msds):\n        \"\"\"Calculates D from MSD vs. time data using linear regression.\"\"\"\n        if len(times)  2:\n            return 0.0\n        \n        # Use numpy's polyfit for an ordinary least squares fit of degree 1\n        slope, _ = np.polyfit(times, msds, 1)\n        \n        # Einstein relation in 3D: D = slope / (2*d) = slope / 6\n        D = slope / 6.0\n        return D\n\n    def run(self):\n        \"\"\"Runs the full simulation pipeline for one case and returns the diffusion coefficient.\"\"\"\n        self._setup_lattice()\n        self._precompute_energies()\n        times, msds = self._run_kmc_loop()\n        D = self._calculate_diffusion_coefficient(times, msds)\n        return D\n\ndef solve():\n    # Common parameters defined in the problem\n    E_species = [0.30, 0.20, 0.35, 0.40] # [E_Mo, E_Nb, E_Ta, E_W] in eV\n    nu0 = 1.0e13 # s^-1\n    a = 3.20e-10 # m\n    kB = 8.617333262145e-5 # eV/K\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'T': 300.0, 'comp': [0.25, 0.25, 0.25, 0.25], 'L': 32, 'N_events': 50000, 'seed': 1},\n        {'T': 600.0, 'comp': [0.40, 0.20, 0.20, 0.20], 'L': 32, 'N_events': 50000, 'seed': 2},\n        {'T': 1200.0, 'comp': [0.25, 0.25, 0.25, 0.25], 'L': 24, 'N_events': 20000, 'seed': 3},\n        {'T': 300.0, 'comp': [0.0, 0.0, 0.0, 1.0], 'L': 32, 'N_events': 50000, 'seed': 4},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        simulator = SiaKmcSimulator(\n            T=case_params['T'],\n            comp=case_params['comp'],\n            L=case_params['L'],\n            N_events=case_params['N_events'],\n            seed=case_params['seed'],\n            E_species=E_species,\n            nu0=nu0,\n            a=a,\n            kB=kB\n        )\n        D = simulator.run()\n        # Format to 6 significant figures in scientific notation\n        results.append(f\"{D:.5e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}