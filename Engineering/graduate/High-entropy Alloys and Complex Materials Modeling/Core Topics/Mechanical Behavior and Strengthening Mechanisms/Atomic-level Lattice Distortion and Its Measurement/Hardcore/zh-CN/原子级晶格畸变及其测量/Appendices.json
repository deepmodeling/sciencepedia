{
    "hands_on_practices": [
        {
            "introduction": "在高熵合金等复杂材料中，原子级别的晶格畸变首先宏观地体现在平均晶格常数与理想固溶体行为的偏离上。韦加德定律（Vegard's law）为理想混合提供了一个线性基准，而实验中观察到的系统性偏差——通常用一个“弯曲”参数（bowing parameter）来建模——则直接量化了由原子尺寸、化学和电子相互作用不匹配引起的非理想效应。本练习  将引导您将实验数据拟合到一个包含物理意义的晶格常数模型中，从而掌握从宏观测量中提取原子尺度相互作用信息的关键技能。",
            "id": "3730433",
            "problem": "考虑一种高熵合金 (HEA) 或复杂合金中的置换型单相赝二元固溶体，其中成分变量 $x \\in [0,1]$ 表示 B 物种取代 A 物种的原子分数。在小应变各向同性弹性理论下，静水应变 $\\varepsilon$ 与晶格常数 $a$ 的变化遵循线性关系 $\\Delta a / a \\approx \\varepsilon$。根据经验，晶格常数的成分依赖性通常遵循线性混合法则（Vegard 定律），外加一个可归因于弹性和尺寸错配驱动的原子级晶格畸变的系统性偏差。该偏差必须在端元（$x=0$ 和 $x=1$）处消失，在交换 A 和 B 并对换 $x \\leftrightarrow 1-x$ 时保持对称，并且与混合程度（$x$ 和 $1-x$）成比例。这些约束意味着成分中存在一个与 $x(1-x)$ 成正比的二阶项。\n\n你的任务是，根据以下模型结构和物理约束，确定一组能够最佳拟合多个成分下测得的晶格常数的参数：\n- 晶格常数 $a(x)$ 由三个未知参数表示：端元晶格常数 $a_A$ 和 $a_B$（分别对应 $x=0$ 和 $x=1$ 时）以及一个乘以在两个端元处都为零的二阶成分项的单一畸变系数 $b$。\n- 模型对于未知参数必须是线性的，满足 $a(0)=a_A$ 和 $a(1)=a_B$，并包含一个单一标量 $b$，该标量乘以一个在 $x=0$ 和 $x=1$ 处为零且在 $x \\leftrightarrow 1-x$ 变换下对称的 $x$ 的函数。\n\n请从线弹性力学和混合对称性的基本原理出发，论证这种形式如何捕捉由弹性和尺寸错配引起的原子级晶格畸变。然后，对于提供的测试套件，通过最小化测量晶格常数值与模型预测值之间的残差平方和，计算最佳拟合参数 $(a_A,a_B,b)$，并报告每种情况下的拟合畸变系数 $b$。解释 $b$ 的符号和大小在错配和畸变方面的意义：解释 $b>0$ 或 $b0$ 如何与相对于线性混合的膨胀或收缩相关联，以及为什么曲率与 $x(1-x)$ 成比例。\n\n物理单位要求：所有晶格常数 $a$ 和拟合的畸变系数 $b$ 均以埃为单位表示。在输出中，以浮点值的形式提供 $b$（单位为埃）。不涉及角度。不使用百分号；在论证中讨论的任何比率都应表示为小数。\n\n测试套件（每个案例提供成分值 $x$ 和测量的晶格常数值 $a$，单位为埃）：\n- 案例 1（明确的正曲率，超定，无测量噪声）：\n  - $x$ 值：$[0, 0.25, 0.5, 0.75, 1.0]$\n  - 测量的 $a$ 值：$[3.60, 3.65375, 3.705, 3.75375, 3.80]$\n- 案例 2（近线性混合，超定，有少量测量噪声）：\n  - $x$ 值：$[0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$\n  - 测量的 $a$ 值：$[3.6005, 3.679, 3.7607, 3.8397, 3.9202, 3.9994]$\n- 案例 3（强负曲率，超定，有少量测量噪声）：\n  - $x$ 值：$[0.0, 0.3, 0.5, 0.7, 1.0]$\n  - 测量的 $a$ 值：$[3.60, 3.6752, 3.729, 3.7947, 3.90]$\n- 案例 4（边界情况，由最少数量的点精确确定）：\n  - $x$ 值：$[0.0, 0.5, 1.0]$\n  - 测量的 $a$ 值：$[3.50, 3.6125, 3.70]$\n\n算法规范：\n- 通过使用 $x$ 的基函数，构造一个关于未知参数 $(a_A,a_B,b)$ 的线性设计，该设计与上述约束一致，强制满足 $a(0)=a_A$ 和 $a(1)=a_B$，并包含一个在端元处为零的对称二阶项。\n- 通过最小化每个案例中提供的数据点的残差平方和来求解 $(a_A,a_B,b)$。任何数值稳定的方法都是可接受的，例如使用 Moore–Penrose 伪逆或标准最小二乘求解器。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含所有四个案例的拟合畸变系数 $b$，单位为埃，形式为用方括号括起来的逗号分隔列表。每个值必须四舍五入到六位小数。例如，输出格式为：$[b_1,b_2,b_3,b_4]$，其中 $b_i$ 是四舍五入到六位小数的浮点数，单位为埃。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n已知条件如下：\n- 一个赝二元固溶体，其成分变量 $x \\in [0,1]$ 代表物种 B 取代物种 A 的原子分数。\n- 一个待拟合的晶格常数模型 $a(x)$，由三个未知数参数化：$a_A = a(0)$、$a_B = a(1)$ 和一个畸变系数 $b$。\n- 该模型对于参数 $(a_A, a_B, b)$ 必须是线性的。\n- 该模型必须满足边界条件 $a(0)=a_A$ 和 $a(1)=a_B$。\n- 该模型必须包含一个乘以 $b$ 的项，该项是 $x$ 的函数，在 $x=0$ 和 $x=1$ 处为零，并在变换 $x \\leftrightarrow 1-x$ 下对称。\n- 拟合过程是最小化残差平方和。\n- 提供了四个测试案例，每个案例包含一组成分值 $x$ 和相应的测量晶格常数值 $a$（单位为埃）。\n- 最终输出必须是每个案例的拟合畸变系数 $b$，四舍五入到六位小数，并采用特定的列表格式。\n\n问题被评估为**有效**。它在科学上基于已建立的材料科学原理，包括固溶体理论、Vegard 定律及其偏差。该模型形式是合金中弯曲效应的标准表示。问题是适定的，提供了足够的数据和一个明确的目标（线性最小二乘最小化），可以为每个案例找到唯一的最佳拟合参数集。语言客观、精确，并提供了完整解决方案所需的所有信息。该问题既非微不足道也非不适定，代表了科学背景下的标准数据分析任务。\n\n问题要求从基本原理推导模型形式，然后计算模型参数。\n\n**1. 晶格常数模型的理论构建**\n\n在 A 和 B 物种的二元固溶体中，晶格常数 $a(x)$ 作为 B 物种成分 $x$ 的函数的最简单模型是纯端元晶格常数 $a_A$ 和 $a_B$ 之间的线性插值。这被称为 Vegard 定律：\n$$ a_{veg}(x) = (1-x)a_A + x a_B $$\n该定律假设为理想混合物，其中有效原子体积随成分线性变化。然而，在实际合金中，特别是复杂浓缩合金或高熵合金 (HEA) 中，原子尺寸错配、不同的电子结构和键能变化等因素会导致局部晶格畸变。这些畸变导致平均晶格常数偏离线性行为。\n\n为了解释这种偏差，我们向线性模型引入一个修正项 $\\Delta a_{dist}(x)$。总晶格常数则为 $a(x) = a_{veg}(x) + \\Delta a_{dist}(x)$。问题陈述对该偏差项施加了基于物理的约束：\n1.  对于纯元素，偏差必须为零。在 $x=0$（纯 A）和 $x=1$（纯 B）时，没有由混合引起的畸变，因此 $\\Delta a_{dist}(0) = 0$ 和 $\\Delta a_{dist}(1) = 0$。\n2.  畸变的物理性质应该相对于将物种 A 或 B 标记为溶质是对称的。这意味着交换 A 和 B（对应于变换 $x \\leftrightarrow 1-x$）不应改变偏差的函数形式。\n3.  预计偏差在“无序”或混合程度最大的地方达到最大值，这发生在中间成分处，远离纯端元。\n\n满足这些约束的最简单的 $x$ 的多项式函数是 $f(x) = C \\cdot x(1-x)$，其中 $C$ 是一个常数。这个函数在 $x=0$ 和 $x=1$ 处为零，并且是对称的，因为 $(1-x)(1-(1-x)) = (1-x)x$。这个二次项在半导体物理学中通常被称为“弯曲”参数，并广泛用于模拟金属合金中对 Vegard 定律的偏离。\n\n因此，我们采用晶格常数 $a(x)$ 的模型为：\n$$ a(x) = (1-x)a_A + x a_B + b \\cdot x(1-x) $$\n这里，$b$ 是待确定的单一畸变系数，它量化了偏离线性的程度。该模型对其三个参数 $(a_A, a_B, b)$ 是线性的，正如所要求的。参数的基函数分别为 $(1-x)$、$x$ 和 $x(1-x)$。\n\n**2. 通过线性最小二乘法进行参数估计**\n\n给定一组 $N$ 个实验数据点 $(x_i, a_i)$，其中 $i=1, \\dots, N$，我们寻求“最佳拟合”模型的参数 $(a_A, a_B, b)$。这是通过最小化测量值 $a_i$ 与模型预测值 $a(x_i)$ 之间的残差平方和 (SSR)，即 $S$ 来实现的：\n$$ S(a_A, a_B, b) = \\sum_{i=1}^{N} [a_i - a(x_i)]^2 = \\sum_{i=1}^{N} [a_i - ((1-x_i)a_A + x_i a_B + x_i(1-x_i)b)]^2 $$\n这是一个标准的线性最小二乘问题，可以用矩阵代数表示。令 $\\boldsymbol{\\beta}$ 为参数向量，$\\mathbf{y}$ 为观测晶格常数向量，$\\mathbf{X}$ 为设计矩阵。\n$$ \\boldsymbol{\\beta} = \\begin{pmatrix} a_A \\\\ a_B \\\\ b \\end{pmatrix}, \\quad \\mathbf{y} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_N \\end{pmatrix} $$\n设计矩阵 $\\mathbf{X}$ 的构造方式是，每一行对应一个数据点 $x_i$，每一列对应一个在该 $x_i$ 处求值的基函数：\n$$ \\mathbf{X} = \\begin{pmatrix}\n1-x_1  x_1  x_1(1-x_1) \\\\\n1-x_2  x_2  x_2(1-x_2) \\\\\n\\vdots   \\vdots   \\vdots \\\\\n1-x_N  x_N  x_N(1-x_N)\n\\end{pmatrix} $$\n问题是找到使欧几里得范数的平方 $\\|\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}\\|^2$ 最小化的向量 $\\hat{\\boldsymbol{\\beta}}$。解由正规方程组给出：\n$$ (\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y} $$\n假设 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的（如果 $\\mathbf{X}$ 的列是线性无关的，这个条件就成立，我们的基函数选择和非退化的 $x_i$ 值满足了这一点），则唯一解为：\n$$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y} $$\n矩阵 $(\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T$ 是 $\\mathbf{X}$ 的 Moore-Penrose 伪逆。在数值上，这个系统使用诸如 QR 分解或奇异值分解 (SVD) 等稳健方法求解，以确保稳定性，正如标准科学计算库中所实现的那样。\n\n**3. $b$ 畸变系数的解释**\n\n拟合系数 $b$ 的符号和大小为合金中原子相互作用的性质提供了物理洞察。\n- 如果 $b > 0$，则对于 $x \\in (0,1)$，项 $b \\cdot x(1-x)$ 为正。这意味着实际晶格常数 $a(x)$ 大于线性混合法则（Vegard 定律）所预测的值。这被称为正偏差或正弯曲。它通常表明排斥力占主导地位，或者异类原子间的成键 (A-B) 比同类原子间成键 (A-A 和 B-B) 的平均值弱，导致晶格为适应应变而有效膨胀。\n- 如果 $b  0$，则偏差项为负。晶格常数小于线性平均值，这种现象称为负偏差或负弯曲。这通常表明异类原子 (A-B) 之间存在比组分平均值更强的吸引相互作用。这可能是由于电荷转移或趋向于化学有序化等效应，这些效应将原子拉得更近。\n- 大小 $|b|$ 量化了这种非理想相互作用的强度。较大的 $|b|$ 意味着与理想混合的偏离更显著。与 $x(1-x)$ 的比例关系确保了这种偏差效应在原子非均匀性最大的组分 $x=0.5$ 处最为显著，并在纯端元处正确地消失。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the distortion coefficient 'b' for four test cases\n    of lattice parameter vs. composition data in a pseudo-binary alloy.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Well-defined positive curvature, overdetermined, no noise\n        {\n            \"x\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"a\": [3.60, 3.65375, 3.705, 3.75375, 3.80]\n        },\n        # Case 2: Nearly linear mixing, overdetermined, small noise\n        {\n            \"x\": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"a\": [3.6005, 3.679, 3.7607, 3.8397, 3.9202, 3.9994]\n        },\n        # Case 3: Strong negative curvature, overdetermined, small noise\n        {\n            \"x\": [0.0, 0.3, 0.5, 0.7, 1.0],\n            \"a\": [3.60, 3.6752, 3.729, 3.7947, 3.90]\n        },\n        # Case 4: Exactly determined with minimal points\n        {\n            \"x\": [0.0, 0.5, 1.0],\n            \"a\": [3.50, 3.6125, 3.70]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x_vals = np.array(case[\"x\"])\n        a_vals = np.array(case[\"a\"])\n\n        # The model is a(x) = a_A*(1-x) + a_B*x + b*x*(1-x).\n        # This is a linear system of the form X * beta = y, where:\n        # y is the vector of measured lattice parameters 'a'.\n        # beta is the vector of unknown parameters [a_A, a_B, b].\n        # X is the design matrix with columns corresponding to the basis functions\n        # of the parameters: [(1-x), x, x*(1-x)].\n        \n        # Construct the design matrix X.\n        # The number of rows is the number of data points.\n        # The number of columns is the number of parameters (3).\n        X = np.zeros((len(x_vals), 3))\n        \n        # Column 0: Basis function for a_A is (1-x)\n        X[:, 0] = 1 - x_vals\n        \n        # Column 1: Basis function for a_B is x\n        X[:, 1] = x_vals\n        \n        # Column 2: Basis function for b is x*(1-x)\n        X[:, 2] = x_vals * (1 - x_vals)\n        \n        # Solve the linear least-squares problem X * beta = a_vals for beta.\n        # np.linalg.lstsq is a numerically stable solver.\n        # It returns the solution vector, residuals, rank, and singular values.\n        # We only need the solution vector, which contains [a_A, a_B, b].\n        params = np.linalg.lstsq(X, a_vals, rcond=None)[0]\n        \n        # The distortion coefficient 'b' is the third element of the solution vector.\n        b_fit = params[2]\n        \n        results.append(b_fit)\n\n    # Format the final output string as a comma-separated list of floats\n    # rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n\n```"
        },
        {
            "introduction": "除了晶格常数的平均值（对应于衍射峰位），X射线衍射（XRD）峰的宽度也蕴含着关于晶格无序度的丰富统计信息。Williamson-Hall分析法是一种经典而强大的工具，它能够将由有限晶粒尺寸引起的展宽和由微应变（即晶格畸变分布）引起的展宽分离开来。本练习  将指导您应用此方法，从衍射数据中定量提取微应变和晶粒尺寸，并进一步探索如何利用改进的Williamson-Hall模型处理各向异性应变的情况。",
            "id": "3730439",
            "problem": "您正在对高熵合金的X射线衍射（XRD）图谱中的谱线展宽进行建模，以量化原子级晶格畸变。假设总积分宽度展宽源于两个有物理解释的来源：有限的微晶尺寸和分布式微应变。从以下定义出发：(i) 独立展宽源的卷积产生可加的积分宽度，(ii) 微晶尺寸展宽与受衍射几何约束的特征畴尺寸成反比，以及 (iii) 微小的晶格参数涨落产生与布拉格角的正切成正比的角展宽，推导一个线性回归框架，该框架可从多个布拉格角下测量的峰宽来估算均方根微应变和等效微晶尺寸。然后，提出并实现一种策略，该策略通过使用一个对方向敏感的应变贡献权重因子来引入与衍射峰相关的各向异性，此方法与修正的Williamson–Hall方法一致。\n\n使用以下条件和定义：\n- 使用弧度制表示角度。\n- 使用波长 $\\lambda$ 和形状因子 $K$ 作为常数；在程序内部将 $\\lambda$ 的单位从埃（Angstrom）转换为纳米（nanometer），以保持单位一致性。\n- 估算微应变 $\\epsilon$（无量纲）和微晶尺寸 $D$（单位为纳米）。您的程序必须以纳米为单位输出 $D$。\n- 对于各向异性应变的分离，使用所提供的与衍射峰相关的衬度因子作为无量纲权重。\n\n需要实现的算法任务：\n- 基于基本假设，构建一个 $y_i = b + m x_i$ 形式的线性关系，其中 $y_i$ 是在角度 $\\theta_i$ 处测量的积分宽度 $ \\beta_i $ 的函数，而 $x_i$ 是 $\\theta_i$ 的函数（对于各向异性情况，还与一个衍射峰相关因子有关）。不要使用任何非线性拟合；使用带有显式截距的普通最小二乘法。\n- 从斜率 $ m $ 和截距 $ b $ 中以闭式解的形式求出参数 $ \\epsilon $ 和 $ D $，并确保单位一致性。\n- 对于各向异性情况，使用一个修正的预测变量，该变量引入了每个衍射峰所提供的衬度因子；使用相同的线性回归框架估算各向异性微应变和相应的 $ D $。\n\n所有测试用例中使用的常数：\n- X射线波长 $ \\lambda = 1.5406 $ 埃。\n- 形状因子 $ K = 0.9 $。\n\n测试套件和数据：\n- 测试用例1（一般情况：同时存在尺寸和各向同性微应变）：\n  - 布拉格角 $ \\theta $ (度): $[15,20,25,30,35,40,45,50]$。\n  - 测量的积分宽度 $ \\beta $ (弧度): $[0.005015, 0.005863, 0.006790, 0.007822, 0.008986, 0.010333, 0.011922, 0.013848]$。\n- 测试用例2（边界条件：微应变可忽略，尺寸主导的展宽）：\n  - 布拉格角 $ \\theta $ (度): $[15,20,25,30,35,40,45,50]$。\n  - 测量的积分宽度 $ \\beta $ (弧度): $[0.004786, 0.004919, 0.005099, 0.005339, 0.005643, 0.006037, 0.006536, 0.007190]$。\n- 测试用例3（使用带衬度因子的修正预测变量的各向异性微应变）：\n  - 布拉格角 $ \\theta $ (度): $[15,20,25,30,35,40,45,50]$。\n  - 测量的积分宽度 $ \\beta $ (弧度): $[0.002994, 0.003457, 0.003922, 0.004139, 0.005086, 0.004767, 0.006318, 0.006796]$。\n  - 与衍射峰相关的衬度因子 $ C_{hkl} $ (无量纲): $[0.14, 0.21, 0.24, 0.18, 0.29, 0.12, 0.26, 0.20]$。\n\n输出要求：\n- 您的程序应计算：\n  - 对于测试用例1：各向同性微应变 $ \\epsilon_1 $ 和尺寸 $ D_1 $。\n  - 对于测试用例2：各向同性微应变 $ \\epsilon_2 $ 和尺寸 $ D_2 $。\n  - 对于测试用例3：从各向异性数据集拟合得到的各向同性微应变 $ \\epsilon_{3,\\text{iso}} $，使用修正预测变量得到的各向异性微应变 $ \\epsilon_{3,\\text{aniso}} $，以及从修正拟合得到的相应尺寸 $ D_3 $。\n- 将所有报告的浮点数输出四舍五入到6位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\epsilon_1,D_1,\\epsilon_2,D_2,\\epsilon_{3,\\text{iso}},\\epsilon_{3,\\text{aniso}},D_3]$。\n\n本说明中的所有数值均以指定单位给出。确保在使用前将角度从度转换为弧度；以纳米为单位报告 $D$，微应变以小数形式报告（而非百分比）。",
            "solution": "该建模始于两个经过充分验证的事实。首先，当两个独立的展宽机制对衍射峰形都有贡献时，其积分宽度是相加的：如果 $ \\beta_{\\text{size}} $ 和 $ \\beta_{\\text{strain}} $ 分别是由有限微晶尺寸和微应变引起的积分宽度贡献，那么测量的积分宽度 $ \\beta $ 满足 $ \\beta = \\beta_{\\text{size}} + \\beta_{\\text{strain}} $。其次，运动学衍射几何通过几何反比关系将角宽度与微晶尺寸联系起来，并通过布拉格角的正切将微小的晶格间距涨落与角度依赖性联系起来。这两种关系在谱线轮廓分析中被广泛使用。\n\n对于微晶尺寸的贡献，谢乐（Scherrer）型关系给出 $ \\beta_{\\text{size}} $ 与 $ 1 / (D \\cos \\theta) $ 成正比，比例常数由形状因子和波长给出。因子 $ \\cos \\theta $ 源于相干畴尺寸在散射矢量方向上的投影。对于微应变的贡献，晶格间距的微小分数变化 $ \\Delta d / d $ 会转化为一个与 $ \\tan \\theta $ 成比例的角展宽。当我们使用均方根值 $ \\epsilon $ 对微应变进行统计建模时，由应变引起的积分宽度与 $ \\epsilon \\tan \\theta $ 成正比，其乘法常数由半高宽和积分宽度之间的关系以及特定的谱线轮廓约定导出；标准的 Williamson–Hall 公式对积分宽度使用因子 $ 4 $。\n\n将这些贡献结合起来并乘以 $ \\cos \\theta $，可以得到一个关于 $ \\sin \\theta $ 的线性关系。定义\n$$ y_i \\equiv \\beta_i \\cos \\theta_i, \\quad x_i \\equiv 4 \\sin \\theta_i. $$\n在上述假设下，可得到\n$$ y_i = b + m x_i, $$\n其中截距 $ b $ 等于 $ K \\lambda / D $，斜率 $ m $ 等于 $ \\epsilon $。这种线性化源于 $ \\beta_{\\text{size}} = K \\lambda / (D \\cos \\theta) $ 和 $ \\beta_{\\text{strain}} = 4 \\epsilon \\tan \\theta $，因此\n$$ \\beta_i \\cos \\theta_i = \\frac{K \\lambda}{D} + 4 \\epsilon \\sin \\theta_i. $$\n因此，对带有截距的 $ (x_i, y_i) $ 进行普通最小二乘法可以估算出 $ m $ 和 $ b $，由此我们求出\n$$ \\epsilon = m, \\quad D = \\frac{K \\lambda}{b}. $$\n波长 $ \\lambda $ 必须以纳米为单位表示，才能以纳米为单位获得 $ D $；如果 $ \\lambda $ 以埃为单位提供，我们通过 $ \\lambda_{\\text{nm}} = \\lambda_{\\text{\\AA}} / 10 $ 进行转换。\n\n为了在修正的Williamson–Hall方法中引入各向异性，我们使用一个与衍射峰相关的因子对应变预测变量进行加权，该因子捕捉了应变场的方向敏感性。一种常见的方法是使用位错衬度因子 $ C_{hkl} $（无量纲），它取决于晶向指数和弹性各向异性，并调制给定衍射峰所观察到的有效应变。在此框架中，我们定义修正的预测变量\n$$ x_i^{\\ast} \\equiv 4 \\sqrt{C_{hkl,i}} \\sin \\theta_i, $$\n并保留相同的响应变量 $ y_i = \\beta_i \\cos \\theta_i $。修正的线性关系变为\n$$ y_i = b^{\\ast} + m^{\\ast} x_i^{\\ast}, $$\n其中 $ b^{\\ast} = K \\lambda / D $ 且 $ m^{\\ast} = \\epsilon_{\\text{aniso}} $，即经衬度因子缩放归一化的各向异性微应变。因此，我们使用 $ x_i^{\\ast} $ 进行普通最小二乘法来估算 $ \\epsilon_{\\text{aniso}} $ 和 $ D $。这种策略分离了与方向相关的微应变贡献：具有较大 $ C_{hkl} $ 的衍射峰在应变预测变量中具有更大的权重，而斜率 $ m^{\\ast} $ 在考虑了各向异性之后直接对应于微应变参数。\n\n在代码中实现的算法步骤：\n- 将提供的角度 $ \\theta_i $ 从度转换为弧度：$ \\theta_i^{\\text{rad}} = (\\pi/180) \\times \\theta_i^{\\circ} $。\n- 计算 $ y_i = \\beta_i \\cos \\theta_i^{\\text{rad}} $。\n- 对于各向同性分析，计算 $ x_i = 4 \\sin \\theta_i^{\\text{rad}} $ 并求解 $ y_i = b + m x_i $ 的普通最小二乘问题。使用均值，\n$$ m = \\frac{\\sum_i (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_i (x_i - \\bar{x})^2}, \\quad b = \\bar{y} - m \\bar{x}. $$\n- 求出 $ \\epsilon = m $ 和 $ D = K \\lambda_{\\text{nm}} / b $，并检查 $ b > 0 $。\n- 对于各向异性分析，计算 $ x_i^{\\ast} = 4 \\sqrt{C_{hkl,i}} \\sin \\theta_i^{\\text{rad}} $ 并重复回归以获得 $ m^{\\ast} $ 和 $ b^{\\ast} $，然后得到 $ \\epsilon_{\\text{aniso}} = m^{\\ast} $ 和 $ D = K \\lambda_{\\text{nm}} / b^{\\ast} $。\n- 为完整起见，也对各向异性数据集进行各向同性模型拟合以获得 $ \\epsilon_{3,\\text{iso}} $；这可以量化忽略各向异性时产生的偏差。\n\n所有输出都四舍五入到 $ 6 $ 位小数，并按指定顺序以方括号括起来的单个逗号分隔列表的形式打印。该方法在科学上是现实的：它从可加的积分宽度和成熟的标度律出发，构建了与 Williamson–Hall 方法一致的线性回归，并通过与衍射峰相关的衬度因子对其进行扩展，以在修正的 Williamson–Hall 框架内分离各向异性微应变。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ordinary_least_squares(x, y):\n    \"\"\"\n    Perform ordinary least squares for y = b + m * x.\n    Returns (m, b).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    y = np.asarray(y, dtype=float)\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    # Compute slope and intercept using the covariance/variance method\n    cov = np.sum((x - x_mean) * (y - y_mean))\n    var = np.sum((x - x_mean) ** 2)\n    # Guard against degenerate var (shouldn't occur with diverse theta)\n    if var == 0.0:\n        m = 0.0\n    else:\n        m = cov / var\n    b = y_mean - m * x_mean\n    return m, b\n\ndef radians(degrees):\n    return np.deg2rad(np.asarray(degrees, dtype=float))\n\ndef isotropic_fit(beta, theta_rad, K, lambda_nm):\n    \"\"\"\n    Implements isotropic Williamson-Hall linearization:\n    y = beta * cos(theta), x = 4 * sin(theta)\n    Returns (epsilon, D_nm).\n    \"\"\"\n    theta = np.asarray(theta_rad, dtype=float)\n    beta = np.asarray(beta, dtype=float)\n    y = beta * np.cos(theta)\n    x = 4.0 * np.sin(theta)\n    m, b = ordinary_least_squares(x, y)\n    epsilon = m\n    # Intercept should be positive; if not, set D to np.inf to reflect nonphysical value\n    if b = 0.0:\n        D_nm = float('inf')\n    else:\n        D_nm = K * lambda_nm / b\n    return epsilon, D_nm\n\ndef anisotropic_fit(beta, theta_rad, contrast_factors, K, lambda_nm):\n    \"\"\"\n    Implements modified Williamson-Hall with contrast factor:\n    y = beta * cos(theta), x* = 4 * sqrt(C_hkl) * sin(theta)\n    Returns (epsilon_aniso, D_nm).\n    \"\"\"\n    theta = np.asarray(theta_rad, dtype=float)\n    beta = np.asarray(beta, dtype=float)\n    C = np.asarray(contrast_factors, dtype=float)\n    y = beta * np.cos(theta)\n    x_star = 4.0 * np.sqrt(C) * np.sin(theta)\n    m_star, b_star = ordinary_least_squares(x_star, y)\n    epsilon_aniso = m_star\n    if b_star = 0.0:\n        D_nm = float('inf')\n    else:\n        D_nm = K * lambda_nm / b_star\n    return epsilon_aniso, D_nm\n\ndef solve():\n    # Constants\n    lambda_angstrom = 1.5406  # Angstroms\n    lambda_nm = lambda_angstrom / 10.0  # Convert to nanometers\n    K = 0.9\n\n    # Test Case 1 data\n    theta_deg_1 = [15, 20, 25, 30, 35, 40, 45, 50]\n    beta_1 = [0.005015, 0.005863, 0.006790, 0.007822, 0.008986, 0.010333, 0.011922, 0.013848]\n\n    # Test Case 2 data (size-dominated, negligible microstrain)\n    theta_deg_2 = [15, 20, 25, 30, 35, 40, 45, 50]\n    beta_2 = [0.004786, 0.004919, 0.005099, 0.005339, 0.005643, 0.006037, 0.006536, 0.007190]\n\n    # Test Case 3 data (anisotropic)\n    theta_deg_3 = [15, 20, 25, 30, 35, 40, 45, 50]\n    beta_3 = [0.002994, 0.003457, 0.003922, 0.004139, 0.005086, 0.004767, 0.006318, 0.006796]\n    contrast_C_3 = [0.14, 0.21, 0.24, 0.18, 0.29, 0.12, 0.26, 0.20]\n\n    # Convert angles to radians\n    theta_rad_1 = radians(theta_deg_1)\n    theta_rad_2 = radians(theta_deg_2)\n    theta_rad_3 = radians(theta_deg_3)\n\n    # Perform fits\n    eps1, D1 = isotropic_fit(beta_1, theta_rad_1, K, lambda_nm)\n    eps2, D2 = isotropic_fit(beta_2, theta_rad_2, K, lambda_nm)\n    # Isotropic fit on anisotropic data\n    eps3_iso, D3_iso = isotropic_fit(beta_3, theta_rad_3, K, lambda_nm)\n    # Modified Williamson-Hall anisotropic fit\n    eps3_aniso, D3 = anisotropic_fit(beta_3, theta_rad_3, contrast_C_3, K, lambda_nm)\n\n    # Prepare results, rounded to 6 decimals\n    results = [\n        round(eps1, 6), round(D1, 6),\n        round(eps2, 6), round(D2, 6),\n        round(eps3_iso, 6), round(eps3_aniso, 6), round(D3, 6)\n    ]\n\n    # Final print statement in the exact required format.\n    # Ensure no spaces in the comma-separated list.\n    print(f\"[{','.join(map(lambda v: ('inf' if v == float('inf') else f'{v:.6f}'), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从X射线衍射等提供的统计平均信息更进一步，我们可以利用高分辨率透射电子显微镜（HRTEM）技术直接在实空间中对局部应变场进行成像。几何相位分析（GPA）是实现这一目标的前沿方法，但任何测量的价值都取决于其精度。本练习  旨在挑战您评估GPA技术在特定实验条件下的理论应变探测极限，它要求您将图像分辨率、信噪比和仪器噪声等实际参数联系起来，计算出可测量的最小应变，从而深刻理解先进表征技术的潜力和局限性。",
            "id": "3730451",
            "problem": "通过对一张高分辨率透射电子显微镜图像进行几何相位分析（GPA），研究了一种面心立方高熵合金，以量化其原子级的晶格畸变。GPA 过程通过滤波一个大小为 $|g|$ 的倒易晶格点，恢复出空间变化的相位 $\\phi(\\mathbf{r})$，其梯度编码了晶格位移和应变。使用以下基本关系：\n- 沿倒易晶格矢量方向的投影晶格位移定义为 $u(\\mathbf{r}) = \\phi(\\mathbf{r})/\\left(2\\pi |g|\\right)$。\n- 沿同一实空间方向的相应标量应变分量是空间导数 $\\epsilon(\\mathbf{r}) = \\partial u(\\mathbf{r})/\\partial s$。\n- 在信号振幅为 $A$ 的复值滤波图像上，当存在标准差为 $\\sigma_n$ 的附加、零均值、平稳高斯噪声时，小噪声相位不确定度为 $\\sigma_{\\phi,\\mathrm{SNR}} \\approx \\sigma_n/A$，此即信噪比 $\\rho = A/\\sigma_n$ 的倒数，即 $\\sigma_{\\phi,\\mathrm{SNR}} \\approx 1/\\rho$。\n- 独立的相位噪声源正交相加：$\\sigma_{\\phi} = \\sqrt{\\sigma_{\\phi,\\mathrm{SNR}}^{2} + \\sigma_{\\phi,0}^{2}}$。\n- 在长度为 $L$ 的实空间基线上估算的数值梯度，其不确定度为 $\\sigma_{\\epsilon} \\approx \\sigma_{u}/L$，其中 $\\sigma_{u}$ 是位移不确定度。\n\n假设测得的倒易晶格点对应于实空间晶格间距 $d$，因此 $|g| = 2\\pi/d$。GPA 相位图在规则网格上采样，像素尺寸为 $p$。应变梯度通过中心差分估计器在等于 $N$ 个像素的基线上计算，因此 $L = N p$。仪器限制的相位噪声基底为 $\\sigma_{\\phi,0}$（单位为弧度），滤波条纹的信噪比为 $\\rho$。\n\n给定 $d = 0.20~\\mathrm{nm}$、$p = 0.020~\\mathrm{nm}$、$N = 50$、$\\rho = 50$ 和 $\\sigma_{\\phi,0} = 0.010~\\mathrm{rad}$，计算这些条件所对应的预期 $1\\sigma$ 可探测应变大小 $\\sigma_{\\epsilon}$。将你的答案四舍五入到 $3$ 位有效数字。将最终答案表示为无量纲数。然后，根据你计算出的 $\\sigma_{\\epsilon}$，评估在这些条件下是否可测量数量级为 $10^{-3}$ 的原子级畸变。在你的推理中定性地陈述评估结果，但不要将其包含在最终的数值答案中。",
            "solution": "首先根据所需标准验证问题陈述的有效性。\n\n### 步骤1：提取给定条件\n- 投影晶格位移的定义：$u(\\mathbf{r}) = \\phi(\\mathbf{r})/\\left(2\\pi |g|\\right)$\n- 标量应变分量的定义：$\\epsilon(\\mathbf{r}) = \\partial u(\\mathbf{r})/\\partial s$\n- 由信噪比（SNR）引起的相位不确定度：$\\sigma_{\\phi,\\mathrm{SNR}} \\approx 1/\\rho$，其中 $\\rho = A/\\sigma_n$\n- 独立相位噪声源的正交相加：$\\sigma_{\\phi} = \\sqrt{\\sigma_{\\phi,\\mathrm{SNR}}^{2} + \\sigma_{\\phi,0}^{2}}$\n- 数值梯度的应变不确定度：$\\sigma_{\\epsilon} \\approx \\sigma_{u}/L$\n- 倒易晶格矢量大小与晶格间距之间的关系：$|g| = 2\\pi/d$\n- 用于应变估计的实空间基线：$L = N p$\n- 晶格间距：$d = 0.20~\\mathrm{nm}$\n- 像素尺寸：$p = 0.020~\\mathrm{nm}$\n- 用于基线的像素数：$N = 50$\n- 信噪比：$\\rho = 50$\n- 仪器限制的相位噪声基底：$\\sigma_{\\phi,0} = 0.010~\\mathrm{rad}$\n\n### 步骤2：使用提取的给定条件进行验证\n评估问题的有效性。\n- **科学依据**：该问题描述了透射电子显微镜中几何相位分析（GPA）的原理，这是一种用于绘制晶体材料中应变场的标准且成熟的技术。关于位移、应变的定义，以及实验噪声的传播（来自信噪比的相位不确定度、噪声源的正交相加）都与该方法公认的理论和实践一致。所有提供的参数对于高分辨率显微实验而言在物理上都是现实的。\n- **适定性**：所有计算目标量 $\\sigma_{\\epsilon}$ 所需的常数和关系都已明确给出。该问题是自洽的，并为得出唯一的数值解定义了清晰的路径。\n- **客观性**：问题以精确、定量的术语陈述，没有任何歧义或主观论断。\n\n注意到 $u(\\mathbf{r}) = \\phi(\\mathbf{r})/(2\\pi|g|)$ 和 $|g|=2\\pi/d$ 这组定义。虽然倒易晶格矢量存在不同的惯例，但该问题提供了一套自洽的方程组。推导过程必须严格遵守这些给定的定义。该问题内部一致，不违反数学逻辑。\n\n### 步骤3：结论与行动\n问题有效。将提供一个有理有据的解答。\n\n目标是计算 $1\\sigma$ 可探测应变大小 $\\sigma_{\\epsilon}$。这个量代表了受噪声限制的应变测量的精度。计算过程通过逐步组合给定的定义来进行。\n\n首先，我们建立应变不确定度 $\\sigma_{\\epsilon}$ 的表达式。问题指出，在长度为 $L$ 的基线上进行数值梯度计算，其不确定度为：\n$$\n\\sigma_{\\epsilon} \\approx \\frac{\\sigma_{u}}{L}\n$$\n其中 $\\sigma_{u}$ 是位移不确定度。基线 $L$ 由 $L = Np$ 给出，其中 $N$ 是像素数，$p$ 是像素尺寸。\n\n接下来，我们确定位移不确定度 $\\sigma_{u}$。位移 $u$ 通过给定的定义与相位 $\\phi$ 相关：\n$$\nu(\\mathbf{r}) = \\frac{\\phi(\\mathbf{r})}{2\\pi |g|}\n$$\n位移的不确定度 $\\sigma_u$ 是通过这个线性关系从相位的不确定度 $\\sigma_\\phi$ 传播而来的：\n$$\n\\sigma_u = \\frac{\\sigma_\\phi}{2\\pi |g|}\n$$\n问题还将倒易晶格矢量的大小 $|g|$ 用实空间晶格间距 $d$ 定义为：\n$$\n|g| = \\frac{2\\pi}{d}\n$$\n将此代入 $\\sigma_u$ 的表达式中，得到：\n$$\n\\sigma_u = \\frac{\\sigma_\\phi}{2\\pi \\left(\\frac{2\\pi}{d}\\right)} = \\frac{\\sigma_\\phi d}{4\\pi^2}\n$$\n\n现在，我们必须求出总相位不确定度 $\\sigma_{\\phi}$。它由信噪比引起的不确定度 $\\sigma_{\\phi,\\mathrm{SNR}}$ 和仪器限制的噪声基底 $\\sigma_{\\phi,0}$ 的正交和给出：\n$$\n\\sigma_{\\phi} = \\sqrt{\\sigma_{\\phi,\\mathrm{SNR}}^{2} + \\sigma_{\\phi,0}^{2}}\n$$\n与信噪比相关的项由信噪比 $\\rho$ 的倒数给出：\n$$\n\\sigma_{\\phi,\\mathrm{SNR}} = \\frac{1}{\\rho}\n$$\n因此，总相位不确定度为：\n$$\n\\sigma_{\\phi} = \\sqrt{\\left(\\frac{1}{\\rho}\\right)^2 + \\sigma_{\\phi,0}^2}\n$$\n\n现在我们可以整合出应变不确定度 $\\sigma_{\\epsilon}$ 的完整表达式：\n$$\n\\sigma_{\\epsilon} = \\frac{\\sigma_u}{L} = \\frac{1}{Np} \\left(\\frac{\\sigma_\\phi d}{4\\pi^2}\\right) = \\frac{d}{4\\pi^2 Np} \\sigma_{\\phi}\n$$\n代入 $\\sigma_{\\phi}$ 的表达式：\n$$\n\\sigma_{\\epsilon} = \\frac{d}{4\\pi^2 Np} \\sqrt{\\left(\\frac{1}{\\rho}\\right)^2 + \\sigma_{\\phi,0}^2}\n$$\n这就是可探测应变大小的最终符号表达式。\n\n我们使用给定的数值进行计算：\n- $d = 0.20~\\mathrm{nm}$\n- $p = 0.020~\\mathrm{nm}$\n- $N = 50$\n- $\\rho = 50$\n- $\\sigma_{\\phi,0} = 0.010~\\mathrm{rad}$\n\n首先，我们计算总相位不确定度 $\\sigma_{\\phi}$：\n$$\n\\sigma_{\\phi} = \\sqrt{\\left(\\frac{1}{50}\\right)^2 + (0.010)^2} = \\sqrt{(0.02)^2 + (0.01)^2} = \\sqrt{0.0004 + 0.0001} = \\sqrt{0.0005}~\\mathrm{rad}\n$$\n接下来，我们计算其他项。基线长度为 $L = Np = 50 \\times 0.020~\\mathrm{nm} = 1.0~\\mathrm{nm}$。\n$\\sigma_{\\epsilon}$ 表达式中的前置因子是：\n$$\n\\frac{d}{4\\pi^2 Np} = \\frac{0.20~\\mathrm{nm}}{4\\pi^2 (50) (0.020~\\mathrm{nm})} = \\frac{0.20}{4\\pi^2 (1.0)} = \\frac{0.20}{4\\pi^2} = \\frac{1}{20\\pi^2}\n$$\n注意，这个因子是无量纲的，这符合应变的要求。\n\n现在，我们计算 $\\sigma_{\\epsilon}$ 的最终值：\n$$\n\\sigma_{\\epsilon} = \\frac{1}{20\\pi^2} \\sqrt{0.0005} \\approx \\frac{1}{20 \\times (9.8696)} \\times (0.0223607) \\approx \\frac{1}{197.392} \\times 0.0223607\n$$\n$$\n\\sigma_{\\epsilon} \\approx 0.00506606 \\times 0.0223607 \\approx 0.00011328...\n$$\n用科学记数法表示，这是 $1.1328... \\times 10^{-4}$。\n按要求四舍五入到 3 位有效数字，得到 $1.13 \\times 10^{-4}$。\n\n最后，我们评估数量级为 $10^{-3}$ 的原子级畸变是否可测量。计算出的 $1\\sigma$ 应变精度为 $\\sigma_{\\epsilon} \\approx 1.13 \\times 10^{-4}$。通过计算应变测量的信噪比，可以将一个应变信号 $\\epsilon_{signal} = 10^{-3}$ 与该噪声水平进行比较：\n$$\n\\mathrm{SNR}_{\\epsilon} = \\frac{\\epsilon_{signal}}{\\sigma_{\\epsilon}} \\approx \\frac{10^{-3}}{1.13 \\times 10^{-4}} \\approx 8.85\n$$\n由于该信噪比远大于 1（以及典型的检测阈值 3 或 5），我们可以得出结论，在这些实验条件下，数量级为 $10^{-3}$ 的应变确实是可测量的。",
            "answer": "1.13e-4"
        }
    ]
}