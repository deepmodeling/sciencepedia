{
    "hands_on_practices": [
        {
            "introduction": "在高熵合金和复杂合金中，原子尺度的晶格畸变首先会体现在平均晶格常数上。一个理想固溶体的晶格常数会遵循不同组元晶格常数的线性加权平均，即韦加定律（Vegard's law）。然而，由于原子尺寸失配、化学相互作用和电子效应，实际合金的晶格常数通常会偏离这条线性关系，这种偏离本身就是晶格畸变效应的直接体现。本练习  旨在通过将一个包含“弯曲参数”$b$的物理模型拟合到一系列伪二元合金的实验数据，来量化这种非线性效应。通过确定弯曲参数$b$的符号和大小，我们可以深入理解原子间相互作用如何导致晶格相对于理想混合发生膨胀或收缩，从而掌握一种从宏观实验数据中提取原子尺度畸变信息的关键方法。",
            "id": "3730433",
            "problem": "考虑高熵合金（HEA）或复杂合金中的一种置换型单相赝二元固溶体，其中成分变量 $x \\in [0,1]$ 表示物种 $B$ 替代物种 $A$ 的原子分数。在小应变各向同性弹性理论下，静水应变 $\\varepsilon$ 与晶格参数 $a$ 的变化遵循线性关系 $\\Delta a / a \\approx \\varepsilon$。根据经验，晶格参数对成分的依赖性通常遵循线性混合法则（Vegard定律），并加上一个可归因于弹性和尺寸错配驱动的原子级晶格畸变的系统性偏离。该偏离在端元（$x=0$ 和 $x=1$）处必须为零，在交换 $A$ 和 $B$ 并对调 $x \\leftrightarrow 1-x$ 时必须保持对称，并且与混合程度（$x$ 和 $1-x$）成比例。这些约束意味着成分中存在一个与 $x(1-x)$ 成正比的二次项。\n\n您的任务是确定一组能够最佳拟合在多个成分下测量的晶格参数的参数集，并需遵循以下模型结构和物理约束：\n- 晶格参数 $a(x)$ 由三个未知参数表示：端元晶格参数 $a_A$ 和 $a_B$（分别在 $x=0$ 和 $x=1$ 时）以及一个畸变系数 $b$，该系数乘以一个在两个端元处都为零的成分二次项。\n- 该模型必须是未知参数的线性模型，满足 $a(0)=a_A$ 和 $a(1)=a_B$，并包含一个单一标量 $b$，该标量乘以一个在 $x=0$ 和 $x=1$ 时为零且在 $x \\leftrightarrow 1-x$ 变换下对称的 $x$ 的函数。\n\n从线性弹性和混合对称性的第一性原理出发，论证这种形式如何捕捉由弹性和尺寸错配引起的原子级晶格畸变。然后，对于提供的测试套件，通过最小化测量晶格参数值与模型预测值之间的残差平方和，计算最佳拟合参数 $(a_A,a_B,b)$，并报告每种情况下拟合的畸变系数 $b$。根据错配和畸变解释 $b$ 的符号和大小：说明 $b>0$ 或 $b0$ 如何与相对于线性混合的膨胀或收缩相关联，并解释为什么曲率与 $x(1-x)$ 成比例。\n\n物理单位要求：所有晶格参数 $a$ 和拟合的畸变系数 $b$ 均以埃为单位表示。在输出中，以浮点数形式提供以埃为单位的 $b$。不涉及角度。不要使用百分号；在论证中讨论的任何比率都应表示为小数。\n\n测试套件（每种情况提供成分值 $x$ 和以埃为单位的测量晶格参数值 $a$）：\n- 情况 $1$（明确的正曲率，超定，无测量噪声）：\n  - $x$ 值：$[0, 0.25, 0.5, 0.75, 1.0]$\n  - 测量的 $a$ 值：$[3.60, 3.65375, 3.705, 3.75375, 3.80]$\n- 情况 $2$（近线性混合，超定，有少量测量噪声）：\n  - $x$ 值：$[0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$\n  - 测量的 $a$ 值：$[3.6005, 3.679, 3.7607, 3.8397, 3.9202, 3.9994]$\n- 情况 $3$（强负曲率，超定，有少量测量噪声）：\n  - $x$ 值：$[0.0, 0.3, 0.5, 0.7, 1.0]$\n  - 测量的 $a$ 值：$[3.60, 3.6752, 3.729, 3.7947, 3.90]$\n- 情况 $4$（边界情况，由最少数量的点恰好确定）：\n  - $x$ 值：$[0.0, 0.5, 1.0]$\n  - 测量的 $a$ 值：$[3.50, 3.6125, 3.70]$\n\n算法规范：\n- 使用 $x$ 的基函数为未知参数 $(a_A,a_B,b)$ 构建一个与上述约束一致的线性设计，这些基函数能强制实现 $a(0)=a_A$ 和 $a(1)=a_B$，并包含一个在端元处为零的对称二次项。\n- 在每种情况下，通过最小化所提供数据点的残差平方和来求解 $(a_A,a_B,b)$。任何数值稳定的方法都是可接受的，例如使用 Moore–Penrose 伪逆或标准的最小二乘求解器。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有四种情况下拟合的畸变系数 $b$，以埃为单位，形式为方括号内以逗号分隔的列表。每个值必须四舍五入到六位小数。例如，输出格式为：$[b_1,b_2,b_3,b_4]$，其中 $b_i$ 是以埃表示并四舍五入到六位小数的浮点数。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n已知条件如下：\n- 一个赝二元固溶体，其成分变量 $x \\in [0,1]$ 代表物种 $B$ 替代物种 $A$ 的原子分数。\n- 一个待拟合的晶格参数 $a(x)$ 模型，由三个未知数参数化：$a_A = a(0)$、$a_B = a(1)$ 和一个畸变系数 $b$。\n- 模型必须在参数 $(a_A, a_B, b)$ 上是线性的。\n- 模型必须满足边界条件 $a(0)=a_A$ 和 $a(1)=a_B$。\n- 模型必须包含一个由 $b$ 乘以一个 $x$ 的函数的项，该函数在 $x=0$ 和 $x=1$ 时为零，并且在变换 $x \\leftrightarrow 1-x$ 下是对称的。\n- 拟合过程是最小化残差平方和。\n- 提供了四个测试用例，每个用例包含一组成分值 $x$ 和相应的以埃为单位测量的晶格参数值 $a$。\n- 最终输出必须是每个用例拟合出的畸变系数 $b$，四舍五入到六位小数，并采用特定的列表格式。\n\n该问题被评估为**有效**。它在科学上植根于固溶体理论既定的材料科学原理，包括 Vegard 定律及其偏差。该模型形式是合金中弯曲效应的标准表示。问题是适定的，提供了足够的数据和明确的目标（线性最小二乘最小化），以便为每种情况找到一组唯一的最佳拟合参数。其语言客观、精确，并提供了完整解决方案所需的所有信息。该问题既不简单也非不适定，代表了科学背景下的一个标准数据分析任务。\n\n该问题要求从第一性原理推导模型形式，然后计算模型参数。\n\n**1. 晶格参数模型的理论构建**\n\n在物种 $A$ 和 $B$ 的二元固溶体中，晶格参数 $a(x)$ 作为物种 $B$ 成分 $x$ 的函数的最简单模型是纯端元晶格参数 $a_A$ 和 $a_B$ 之间的线性插值。这被称为 Vegard 定律：\n$$ a_{veg}(x) = (1-x)a_A + x a_B $$\n该定律假设为理想混合物，其中有效原子体积随成分线性变化。然而，在实际合金中，特别是复杂浓缩合金或高熵合金（HEA）中，原子尺寸错配、不同的电子结构以及键能的变化等因素会导致局部晶格畸变。这些畸变导致平均晶格参数偏离线性行为。\n\n为了解释这种偏离，我们向线性模型中引入一个修正项 $\\Delta a_{dist}(x)$。总晶格参数则为 $a(x) = a_{veg}(x) + \\Delta a_{dist}(x)$。问题陈述对该偏离项施加了基于物理的约束：\n1.  对于纯元素，该偏离必须为零。在 $x=0$（纯 $A$）和 $x=1$（纯 $B$）时，不存在由混合引起的畸变，因此 $\\Delta a_{dist}(0) = 0$ 且 $\\Delta a_{dist}(1) = 0$。\n2.  畸变的物理学应相对于将物种 $A$ 或 $B$ 标记为溶质是对称的。这意味着交换 $A$ 和 $B$（对应于变换 $x \\leftrightarrow 1-x$）不应改变偏离的函数形式。\n3.  在“无序度”或混合程度最大的地方，即远离纯端元的中间成分处，偏离预计将达到最大值。\n\n满足这些约束的最简单的 $x$ 的多项式函数是 $f(x) = C \\cdot x(1-x)$，其中 $C$ 是一个常数。该函数在 $x=0$ 和 $x=1$ 时为零，并且由于 $(1-x)(1-(1-x)) = (1-x)x$ 而是对称的。这个二次项在半导体物理学中通常被称为“弯曲”参数，并被广泛用于模拟金属合金中对 Vegard 定律的偏离。\n\n因此，我们采用如下的晶格参数 $a(x)$ 模型：\n$$ a(x) = (1-x)a_A + x a_B + b \\cdot x(1-x) $$\n这里，$b$ 是待确定的单一畸变系数，它量化了偏离线性的程度。正如要求，该模型在其三个参数 $(a_A, a_B, b)$ 上是线性的。这些参数的基函数分别是 $(1-x)$、$x$ 和 $x(1-x)$。\n\n**2. 通过线性最小二乘法进行参数估计**\n\n给定一组 $N$ 个实验数据点 $(x_i, a_i)$，其中 $i=1, \\dots, N$，我们寻求“最佳拟合”模型的参数 $(a_A, a_B, b)$。这通过最小化测量值 $a_i$ 与模型预测值 $a(x_i)$ 之间的残差平方和（SSR）$S$ 来实现：\n$$ S(a_A, a_B, b) = \\sum_{i=1}^{N} [a_i - a(x_i)]^2 = \\sum_{i=1}^{N} [a_i - ((1-x_i)a_A + x_i a_B + x_i(1-x_i)b)]^2 $$\n这是一个标准的线性最小二乘问题，可以用矩阵代数来表述。设 $\\boldsymbol{\\beta}$ 为参数向量，$\\mathbf{y}$ 为观测到的晶格参数向量，$\\mathbf{X}$ 为设计矩阵。\n$$ \\boldsymbol{\\beta} = \\begin{pmatrix} a_A \\\\ a_B \\\\ b \\end{pmatrix}, \\quad \\mathbf{y} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_N \\end{pmatrix} $$\n设计矩阵 $\\mathbf{X}$ 的构建方式是，每一行对应一个数据点 $x_i$，每一列对应一个在 $x_i$ 处求值的基函数：\n$$ \\mathbf{X} = \\begin{pmatrix}\n1-x_1   x_1   x_1(1-x_1) \\\\\n1-x_2   x_2   x_2(1-x_2) \\\\\n\\vdots    \\vdots    \\vdots \\\\\n1-x_N   x_N   x_N(1-x_N)\n\\end{pmatrix} $$\n问题是找到向量 $\\hat{\\boldsymbol{\\beta}}$，以最小化欧几里得范数的平方 $\\|\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}\\|^2$。解由正规方程给出：\n$$ (\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y} $$\n假设 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的（如果 $\\mathbf{X}$ 的列是线性无关的，这个条件就成立，而我们选择的基函数和非退化的 $x_i$ 值满足该条件），则唯一解为：\n$$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y} $$\n矩阵 $(\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T$ 是 $\\mathbf{X}$ 的 Moore-Penrose 伪逆。在数值上，该系统使用鲁棒的方法（如 QR 分解或奇异值分解 (SVD)）来求解以确保稳定性，这些方法在标准科学计算库中均有实现。\n\n**3. 畸变系数 $b$ 的解释**\n\n拟合系数 $b$ 的符号和大小为合金中原子相互作用的性质提供了物理洞见。\n- 如果 $b  0$，对于 $x \\in (0,1)$，项 $b \\cdot x(1-x)$ 为正。这意味着实际晶格参数 $a(x)$ 大于线性混合法则（Vegard 定律）的预测值。这被称为正偏离或正弯曲。它通常表明排斥力占主导地位，或者异类原子（A-B）之间的键合弱于同类原子键（A-A 和 B-B）的平均水平，从而导致晶格有效膨胀以适应应变。\n- 如果 $b  0$，偏离项为负。晶格参数小于线性平均值，这种现象被称为负偏离或负弯曲。这通常表明与组分的平均相互作用相比，异类原子（A-B）之间存在更强的吸引相互作用。这可能是由于电荷转移或趋向化学有序化等效应，这些效应使原子彼此靠得更近。\n- 大小 $|b|$ 量化了这种非理想相互作用的强度。较大的 $|b|$ 意味着与理想混合的偏离更显著。与 $x(1-x)$ 的比例关系确保了这种偏离效应在原子异质性最大的成分（$x=0.5$）处最为显著，并在纯端元处正确地消失。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the distortion coefficient 'b' for four test cases\n    of lattice parameter vs. composition data in a pseudo-binary alloy.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Well-defined positive curvature, overdetermined, no noise\n        {\n            \"x\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"a\": [3.60, 3.65375, 3.705, 3.75375, 3.80]\n        },\n        # Case 2: Nearly linear mixing, overdetermined, small noise\n        {\n            \"x\": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"a\": [3.6005, 3.679, 3.7607, 3.8397, 3.9202, 3.9994]\n        },\n        # Case 3: Strong negative curvature, overdetermined, small noise\n        {\n            \"x\": [0.0, 0.3, 0.5, 0.7, 1.0],\n            \"a\": [3.60, 3.6752, 3.729, 3.7947, 3.90]\n        },\n        # Case 4: Exactly determined with minimal points\n        {\n            \"x\": [0.0, 0.5, 1.0],\n            \"a\": [3.50, 3.6125, 3.70]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x_vals = np.array(case[\"x\"])\n        a_vals = np.array(case[\"a\"])\n\n        # The model is a(x) = a_A*(1-x) + a_B*x + b*x*(1-x).\n        # This is a linear system of the form X * beta = y, where:\n        # y is the vector of measured lattice parameters 'a'.\n        # beta is the vector of unknown parameters [a_A, a_B, b].\n        # X is the design matrix with columns corresponding to the basis functions\n        # of the parameters: [(1-x), x, x*(1-x)].\n        \n        # Construct the design matrix X.\n        # The number of rows is the number of data points.\n        # The number of columns is the number of parameters (3).\n        X = np.zeros((len(x_vals), 3))\n        \n        # Column 0: Basis function for a_A is (1-x)\n        X[:, 0] = 1 - x_vals\n        \n        # Column 1: Basis function for a_B is x\n        X[:, 1] = x_vals\n        \n        # Column 2: Basis function for b is x*(1-x)\n        X[:, 2] = x_vals * (1 - x_vals)\n        \n        # Solve the linear least-squares problem X * beta = a_vals for beta.\n        # np.linalg.lstsq is a numerically stable solver.\n        # It returns the solution vector, residuals, rank, and singular values.\n        # We only need the solution vector, which contains [a_A, a_B, b].\n        params = np.linalg.lstsq(X, a_vals, rcond=None)[0]\n        \n        # The distortion coefficient 'b' is the third element of the solution vector.\n        b_fit = params[2]\n        \n        results.append(b_fit)\n\n    # Format the final output string as a comma-separated list of floats\n    # rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n\n```"
        },
        {
            "introduction": "虽然平均晶格常数的变化揭示了晶格畸变的整体效应，但它并未描述畸变的局部分布。这些局部的、非均匀的应变会导致晶格间距出现统计性分布，这种现象被称为微观应变（microstrain），它会在X射线衍射（XRD）图谱中造成衍射峰的展宽。本练习  将指导你使用经典的威廉姆森-霍尔（Williamson-Hall）方法，这是一种从衍射峰的总展宽中分离出由微观应变和有限晶粒尺寸这两种不同物理机制贡献的强大工具。通过对不同衍射角下的峰宽进行线性回归分析，你将能够定量地提取出材料内部的平均微观应变大小，从而更深入地表征其原子尺度的结构非均匀性。",
            "id": "3730439",
            "problem": "您正在对高熵合金的X射线衍射（XRD）图谱中的谱线增宽进行建模，以量化原子级的晶格畸变。假设总积分宽度增宽源于两个具有物理解释的来源：有限的微晶尺寸和分布的微应变。从以下定义出发：(i) 独立增宽源的卷积产生可加的积分宽度，(ii) 受衍射几何约束，微晶尺寸增宽与特征畴尺寸成反比，(iii) 微小的晶格参数波动产生与布拉格角正切成正比的角度增宽。基于这些定义，推导一个线性回归框架，用于从多个布拉格角下测量的峰宽估算均方根微应变和等效微晶尺寸。然后，提出并实施一种策略，该策略采用一个与应变贡献相关的方向敏感权重因子来考虑反射依赖的各向异性，并与修正的Williamson–Hall方法保持一致。\n\n使用以下条件和定义：\n- 使用弧度制角度。\n- 使用波长 $\\lambda$ 和形状因子 $K$ 作为常数；在程序内部将 $\\lambda$ 的单位从埃（Angstrom）转换为纳米，以保持单位一致性。\n- 估算微应变 $\\epsilon$（无量纲）和微晶尺寸 $D$（单位为纳米）。您的程序必须以纳米为单位输出 $D$。\n- 对于各向异性应变的分离，使用所提供的依赖于反射的衬度因子作为无量纲权重。\n\n需要实现的算法任务：\n- 基于基本假设，构建一个形式为 $y_i = b + m x_i$ 的线性关系，其中 $y_i$ 是在角度 $\\theta_i$ 处测得的积分宽度 $ \\beta_i $ 的函数，$x_i$ 是 $\\theta_i$ 的函数（对于各向异性情况，还与一个依赖于反射的因子有关）。不要使用任何非线性拟合；使用带有显式截距的普通最小二乘法。\n- 从斜率 $ m $ 和截距 $ b $ 以闭合形式恢复参数 $ \\epsilon $ 和 $ D $，确保单位一致性。\n- 对于各向异性，使用一个修正的预测变量，该变量包含每个反射所提供的衬度因子；使用相同的线性回归框架估算各向异性微应变和相应的 $ D $。\n\n所有测试用例中使用的常数：\n- X射线波长 $ \\lambda = 1.5406 $ 埃。\n- 形状因子 $ K = 0.9 $。\n\n测试套件和数据：\n- 测试用例 $1$（一般情况：同时存在尺寸和各向同性微应变）：\n  - 布拉格角 $ \\theta $（度）：$[15,20,25,30,35,40,45,50]$。\n  - 测得的积分宽度 $ \\beta $（弧度）：$[0.005015, 0.005863, 0.006790, 0.007822, 0.008986, 0.010333, 0.011922, 0.013848]$。\n- 测试用例 $2$（边界条件：微应变可忽略，尺寸主导的增宽）：\n  - 布拉格角 $ \\theta $（度）：$[15,20,25,30,35,40,45,50]$。\n  - 测得的积分宽度 $ \\beta $（弧度）：$[0.004786, 0.004919, 0.005099, 0.005339, 0.005643, 0.006037, 0.006536, 0.007190]$。\n- 测试用例 $3$（使用带衬度因子的修正预测变量的各向异性微应变）：\n  - 布拉格角 $ \\theta $（度）：$[15,20,25,30,35,40,45,50]$。\n  - 测得的积分宽度 $ \\beta $（弧度）：$[0.002994, 0.003457, 0.003922, 0.004139, 0.005086, 0.004767, 0.006318, 0.006796]$。\n  - 依赖于反射的衬度因子 $ C_{hkl} $（无量纲）：$[0.14, 0.21, 0.24, 0.18, 0.29, 0.12, 0.26, 0.20]$。\n\n输出要求：\n- 您的程序应计算：\n  - 对于测试用例 $1$：各向同性微应变 $ \\epsilon_1 $ 和尺寸 $ D_1 $。\n  - 对于测试用例 $2$：各向同性微应变 $ \\epsilon_2 $ 和尺寸 $ D_2 $。\n  - 对于测试用例 $3$：从各向异性数据集拟合得到的各向同性微应变 $ \\epsilon_{3,\\text{iso}} $，使用修正预测变量得到的各向异性微应变 $ \\epsilon_{3,\\text{aniso}} $，以及从修正拟合得到的相应尺寸 $ D_3 $。\n- 将所有报告的浮点数输出四舍五入到 $6$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\epsilon_1,D_1,\\epsilon_2,D_2,\\epsilon_{3,\\text{iso}},\\epsilon_{3,\\text{aniso}},D_3]$。\n\n本说明中的所有数值均以指定单位给出。确保在使用前将角度从度转换为弧度；以纳米报告 $D$ 的值，微应变以小数形式报告（而非百分比）。",
            "solution": "建模始于两个经过充分验证的事实。首先，当两个独立的增宽机制对衍射峰形都有贡献时，其积分宽度是相加的：如果 $ \\beta_{\\text{size}} $ 和 $ \\beta_{\\text{strain}} $ 分别是由有限微晶尺寸和微应变引起的积分宽度贡献，则测得的总积分宽度 $ \\beta $ 满足 $ \\beta = \\beta_{\\text{size}} + \\beta_{\\text{strain}} $。其次，运动学衍射几何通过几何反比关系将角度宽度与微晶尺寸联系起来，并通过布拉格角的正切将微小的晶格间距波动与角度依赖性联系起来。这两种关系在谱线轮廓分析中被广泛使用。\n\n对于微晶尺寸的贡献，谢乐型关系（Scherrer-type relation）给出 $ \\beta_{\\text{size}} $ 与 $ 1 / (D \\cos \\theta) $ 成正比，比例常数由形状因子和波长给出。因子 $ \\cos \\theta $ 源于相干衍射域尺寸在散射矢量方向上的投影。对于微应变的贡献，晶格间距的微小相对变化 $ \\Delta d / d $ 会转化为一个与 $ \\tan \\theta $ 成比例的角度增宽。当我们使用均方根值 $ \\epsilon $ 对微应变进行统计建模时，由应变引起的积分宽度与 $ \\epsilon \\tan \\theta $ 成正比，其乘法常数源于半高宽与积分宽度之间的关系以及特定的谱线轮廓约定；标准的Williamson–Hall公式对积分宽度使用因子 $ 4 $。\n\n结合这些贡献并乘以 $ \\cos \\theta $，可得到一个关于 $ \\sin \\theta $ 的线性关系。定义\n$$ y_i \\equiv \\beta_i \\cos \\theta_i, \\quad x_i \\equiv 4 \\sin \\theta_i. $$\n在上述假设下，可以得到\n$$ y_i = b + m x_i, $$\n截距 $ b $ 等于 $ K \\lambda / D $，斜率 $ m $ 等于 $ \\epsilon $。这种线性化源于 $ \\beta_{\\text{size}} = K \\lambda / (D \\cos \\theta) $ 和 $ \\beta_{\\text{strain}} = 4 \\epsilon \\tan \\theta $，因此\n$$ \\beta_i \\cos \\theta_i = \\frac{K \\lambda}{D} + 4 \\epsilon \\sin \\theta_i. $$\n因此，对带有截距的 $ (x_i, y_i) $ 进行普通最小二乘法可以估算出 $ m $ 和 $ b $，然后我们恢复得到\n$$ \\epsilon = m, \\quad D = \\frac{K \\lambda}{b}. $$\n波长 $ \\lambda $ 必须以纳米表示才能得到以纳米为单位的 $ D $；如果 $ \\lambda $ 以埃（Angstrom）为单位提供，我们通过 $ \\lambda_{\\text{nm}} = \\lambda_{\\text{\\AA}} / 10 $ 进行转换。\n\n为了在修正的Williamson–Hall方法中引入各向异性，我们用一个依赖于反射的因子对预测应变的项进行加权，该因子能捕捉应变场的方向敏感性。一种常见的方法是使用位错衬度因子 $ C_{hkl} $（无量纲），它取决于晶向指数和弹性各向异性，并调制给定反射所观察到的有效应变。在这个框架下，我们定义修正的预测变量\n$$ x_i^{\\ast} \\equiv 4 \\sqrt{C_{hkl,i}} \\sin \\theta_i, $$\n并保留相同的响应变量 $ y_i = \\beta_i \\cos \\theta_i $。修正后的线性关系变为\n$$ y_i = b^{\\ast} + m^{\\ast} x_i^{\\ast}, $$\n其中 $ b^{\\ast} = K \\lambda / D $ 且 $ m^{\\ast} = \\epsilon_{\\text{aniso}} $，即通过衬度因子缩放归一化后的各向异性微应变。因此，我们使用 $ x_i^{\\ast} $ 进行普通最小二乘法来估算 $ \\epsilon_{\\text{aniso}} $ 和 $ D $。该策略分离了依赖于方向的微应变贡献：具有较大 $ C_{hkl} $ 的反射在应变预测变量中占有更大的权重，而在考虑了各向异性后，斜率 $ m^{\\ast} $ 直接对应于微应变参数。\n\n在代码中实现的算法步骤：\n- 将给定的角度 $ \\theta_i $ 从度转换为弧度：$ \\theta_i^{\\text{rad}} = (\\pi/180) \\times \\theta_i^{\\circ} $。\n- 计算 $ y_i = \\beta_i \\cos \\theta_i^{\\text{rad}} $。\n- 对于各向同性分析，计算 $ x_i = 4 \\sin \\theta_i^{\\text{rad}} $ 并求解 $ y_i = b + m x_i $ 的普通最小二乘问题。使用均值，\n$$ m = \\frac{\\sum_i (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_i (x_i - \\bar{x})^2}, \\quad b = \\bar{y} - m \\bar{x}. $$\n- 恢复 $ \\epsilon = m $ 和 $ D = K \\lambda_{\\text{nm}} / b $，并检查 $ b  0 $。\n- 对于各向异性分析，计算 $ x_i^{\\ast} = 4 \\sqrt{C_{hkl,i}} \\sin \\theta_i^{\\text{rad}} $ 并重复回归以获得 $ m^{\\ast} $ 和 $ b^{\\ast} $，然后得到 $ \\epsilon_{\\text{aniso}} = m^{\\ast} $ 和 $ D = K \\lambda_{\\text{nm}} / b^{\\ast} $。\n- 为完整起见，也用各向同性模型拟合各向异性数据集以获得 $ \\epsilon_{3,\\text{iso}} $；这可以量化忽略各向异性时产生的偏差。\n\n所有输出均四舍五入到 $ 6 $ 位小数，并按指定顺序以单个逗号分隔的列表形式打印，并用方括号括起来。该方法在科学上是现实的：它从可加的积分宽度和公认的标度律出发，构建了一个与Williamson–Hall方法一致的线性回归模型，并通过依赖于反射的衬度因子对其进行扩展，以便在修正的Williamson–Hall框架内分离各向异性微应变。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ordinary_least_squares(x, y):\n    \"\"\"\n    Perform ordinary least squares for y = b + m * x.\n    Returns (m, b).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    y = np.asarray(y, dtype=float)\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    # Compute slope and intercept using the covariance/variance method\n    cov = np.sum((x - x_mean) * (y - y_mean))\n    var = np.sum((x - x_mean) ** 2)\n    # Guard against degenerate var (shouldn't occur with diverse theta)\n    if var == 0.0:\n        m = 0.0\n    else:\n        m = cov / var\n    b = y_mean - m * x_mean\n    return m, b\n\ndef radians(degrees):\n    return np.deg2rad(np.asarray(degrees, dtype=float))\n\ndef isotropic_fit(beta, theta_rad, K, lambda_nm):\n    \"\"\"\n    Implements isotropic Williamson-Hall linearization:\n    y = beta * cos(theta), x = 4 * sin(theta)\n    Returns (epsilon, D_nm).\n    \"\"\"\n    theta = np.asarray(theta_rad, dtype=float)\n    beta = np.asarray(beta, dtype=float)\n    y = beta * np.cos(theta)\n    x = 4.0 * np.sin(theta)\n    m, b = ordinary_least_squares(x, y)\n    epsilon = m\n    # Intercept should be positive; if not, set D to np.inf to reflect nonphysical value\n    if b = 0.0:\n        D_nm = float('inf')\n    else:\n        D_nm = K * lambda_nm / b\n    return epsilon, D_nm\n\ndef anisotropic_fit(beta, theta_rad, contrast_factors, K, lambda_nm):\n    \"\"\"\n    Implements modified Williamson-Hall with contrast factor:\n    y = beta * cos(theta), x* = 4 * sqrt(C_hkl) * sin(theta)\n    Returns (epsilon_aniso, D_nm).\n    \"\"\"\n    theta = np.asarray(theta_rad, dtype=float)\n    beta = np.asarray(beta, dtype=float)\n    C = np.asarray(contrast_factors, dtype=float)\n    y = beta * np.cos(theta)\n    x_star = 4.0 * np.sqrt(C) * np.sin(theta)\n    m_star, b_star = ordinary_least_squares(x_star, y)\n    epsilon_aniso = m_star\n    if b_star = 0.0:\n        D_nm = float('inf')\n    else:\n        D_nm = K * lambda_nm / b_star\n    return epsilon_aniso, D_nm\n\ndef solve():\n    # Constants\n    lambda_angstrom = 1.5406  # Angstroms\n    lambda_nm = lambda_angstrom / 10.0  # Convert to nanometers\n    K = 0.9\n\n    # Test Case 1 data\n    theta_deg_1 = [15, 20, 25, 30, 35, 40, 45, 50]\n    beta_1 = [0.005015, 0.005863, 0.006790, 0.007822, 0.008986, 0.010333, 0.011922, 0.013848]\n\n    # Test Case 2 data (size-dominated, negligible microstrain)\n    theta_deg_2 = [15, 20, 25, 30, 35, 40, 45, 50]\n    beta_2 = [0.004786, 0.004919, 0.005099, 0.005339, 0.005643, 0.006037, 0.006536, 0.007190]\n\n    # Test Case 3 data (anisotropic)\n    theta_deg_3 = [15, 20, 25, 30, 35, 40, 45, 50]\n    beta_3 = [0.002994, 0.003457, 0.003922, 0.004139, 0.005086, 0.004767, 0.006318, 0.006796]\n    contrast_C_3 = [0.14, 0.21, 0.24, 0.18, 0.29, 0.12, 0.26, 0.20]\n\n    # Convert angles to radians\n    theta_rad_1 = radians(theta_deg_1)\n    theta_rad_2 = radians(theta_deg_2)\n    theta_rad_3 = radians(theta_deg_3)\n\n    # Perform fits\n    eps1, D1 = isotropic_fit(beta_1, theta_rad_1, K, lambda_nm)\n    eps2, D2 = isotropic_fit(beta_2, theta_rad_2, K, lambda_nm)\n    # Isotropic fit on anisotropic data\n    eps3_iso, D3_iso = isotropic_fit(beta_3, theta_rad_3, K, lambda_nm)\n    # Modified Williamson-Hall anisotropic fit\n    eps3_aniso, D3 = anisotropic_fit(beta_3, theta_rad_3, contrast_C_3, K, lambda_nm)\n\n    # Prepare results, rounded to 6 decimals\n    results = [\n        round(eps1, 6), round(D1, 6),\n        round(eps2, 6), round(D2, 6),\n        round(eps3_iso, 6), round(eps3_aniso, 6), round(D3, 6)\n    ]\n\n    # Final print statement in the exact required format.\n    # Ensure no spaces in the comma-separated list.\n    print(f\"[{','.join(map(lambda v: ('inf' if v == float('inf') else f'{v:.6f}'), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "前述练习侧重于从实验数据中“反向”分析晶格畸变，而本练习则将视角转向“正向”的预测建模。一个核心问题是：我们能否基于合金的组分和各元素的基本物理性质（如原子半径）来预测其晶格畸变的程度？本练习  将引导你构建一个简单的统计模型，通过考虑随机占位下不同原子对的键长分布，来估算由原子尺寸失配引起的静态晶格畸变。你将计算出这种静态畸变对对分布函数（Pair Distribution Function, PDF）第一峰展宽的贡献，并将其与热振动和仪器展宽效应相结合，最终将理论预测值与实验测量结果进行比较。这个过程不仅能加深你对畸变物理起源的理解，还能让你体会到理论模型在解释和预测材料结构特性中的价值与局限性。",
            "id": "3730402",
            "problem": "您正在使用局部近邻键长的概率性描述来模拟多组分金属体系中的原子级晶格畸变。目的是量化组分尺寸失配如何导致对分布函数 (PDF) 的第一峰展宽，并将您模拟的展宽与实验测量结果进行比较。您将获得以埃米（ångström）为单位的成分和金属原子半径，以及晶体结构和实验测量的第一峰宽度。您的任务是计算局部键长与平均晶格参数的偏差，通过包含热展宽和仪器展宽将其转换为预测的 PDF 峰宽，然后将这些预测与实验数据进行比较。\n\n使用的基本假设：\n- 对于立方晶格，近邻距离通过几何关系与晶格参数相关联：在面心立方晶格中，近邻间距等于晶格参数除以2的平方根；在体心立方晶格中，它等于晶格参数乘以3的平方根再除以2。使用这些几何关系在平均近邻键长和平均晶格参数之间进行转换。\n- 金属原子半径为无规替换合金中的近邻间距提供了基线估计，而无规位点占据意味着两种元素之间成键的概率与其浓度的乘积成正比，并对无序对进行适当的归一化。\n- 各项独立的各项高斯展宽机制在方差水平上是可加的。利用这一点将组分尺寸失配展宽与热和仪器贡献相结合。\n\n定义与要求步骤：\n- 对分布函数 (PDF) 是原子对相关性的实空间度量。第一峰对应于近邻壳层。您必须通过考虑给定成分中的所有无序物种对来模拟近邻键长的分布，其中每种元素都有一个金属原子半径。对于一个无序对，其键长表示为两种元素半径之和。\n- 计算随机占据下键长分布的概率加权平均值及其标准差。将键长的标准差解释为由组分尺寸失配引起的静态畸变。\n- 使用相应的立方晶格几何结构将平均键长转换为平均晶格参数。这仅用于确定参考的平均晶格参数；需要建模的偏差是相对于此平均值的键长起伏。\n- 将组分尺寸失配贡献与固定的热展宽和仪器展宽值相结合，以获得第一 PDF 峰的预测观测宽度。假设在整个测试套件中，热展宽和仪器分辨率是恒定的，且与成分无关。使用以下常数：热展宽标准差为 $0.040$ 埃，仪器展宽标准差为 $0.010$ 埃。\n- 将每个测试用例的预测观测宽度与提供的实验宽度进行比较，并计算差值（预测值减去实验值）。\n\n物理单位和输出要求：\n- 所有长度和宽度都必须以埃（$\\unicode{x212B}$）为单位处理和报告。您的程序必须以埃为单位输出差值。\n- 您的程序必须输出一行，其中包含一个用方括号括起来的逗号分隔列表，该列表汇总了所有给定测试用例的差值（以十进制浮点数表示）。例如：$[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是测试用例 $i$ 的差值（以埃为单位）。\n- 将数值表示为十进制浮点数；不要使用百分号。\n\n测试套件：\n使用以下金属原子半径（单位：埃）：\n- 铬 (Chromium): $1.28$\n- 锰 (Manganese): $1.27$\n- 铁 (Iron): $1.26$\n- 钴 (Cobalt): $1.25$\n- 镍 (Nickel): $1.24$\n- 铝 (Aluminum): $1.43$\n- 铜 (Copper): $1.28$\n- 钒 (Vanadium): $1.34$\n- 铌 (Niobium): $1.43$\n- 钽 (Tantalum): $1.43$\n- 钨 (Tungsten): $1.37$\n\n使用以下测试用例，每个用例均指定了成分、晶体结构和实验第一峰宽度：\n- 测试用例 $1$ (理想情况，多组分面心立方合金): 成分 $\\{\\text{Cr}:0.20,\\text{Mn}:0.20,\\text{Fe}:0.20,\\text{Co}:0.20,\\text{Ni}:0.20\\}$，结构 fcc，实验宽度 $0.055$ 埃。\n- 测试用例 $2$ (具有大原子尺寸失配的二元面心立方合金): 成分 $\\{\\text{Ni}:0.50,\\text{Al}:0.50\\}$，结构 fcc，实验宽度 $0.130$ 埃。\n- 测试用例 $3$ (边界情况，纯元素): 成分 $\\{\\text{Cu}:1.00\\}$，结构 fcc，实验宽度 $0.045$ 埃。\n- 测试用例 $4$ (多组分体心立方难熔合金): 成分 $\\{\\text{V}:0.25,\\text{Nb}:0.25,\\text{Ta}:0.25,\\text{W}:0.25\\}$，结构 bcc，实验宽度 $0.085$ 埃。\n\n您的程序必须：\n- 根据上述随机占据的概述，为每个测试用例构建近邻键长分布。\n- 计算键长的概率加权平均值和标准差，通过立方几何将平均值转换为晶格参数，并使用标准差作为静态畸变幅度。\n- 通过将静态畸变的方差与固定的热和仪器贡献的方差相加，以产生预测的观测宽度。\n- 计算每个测试用例的预测观测宽度与提供的实验宽度之间的差值，结果为以埃为单位的浮点数。\n- 生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的差值列表，精度为六位小数，并严格按照测试用例 $1$ 到 $4$ 的顺序排列，例如：$[d_1,d_2,d_3,d_4]$。\n\n除了数值计算，您在推理中还应考虑到，密度泛函理论 (DFT) 预测的弛豫后局部键长可能依赖于交换相关 (XC) 泛函的选择，这会改变预期的静态畸变。您的程序不会执行电子结构计算，但您的解决方案应讨论 XC 泛函的选择如何可能导致模型宽度与实验宽度之间的差异，即使在正确计算了组分尺寸失配的情况下也是如此。",
            "solution": "问题陈述已经过严格审查，并被认为是有效的。它具有科学依据，问题定义明确，客观且内部一致，提供了所有必要的数据和清晰的计算步骤。\n\n目标是为几种多组分合金的对分布函数 (PDF) 的第一峰展宽进行建模。这种展宽主要来自三个来源：由原子尺寸失配引起的静态晶格畸变、热振动和仪器分辨率限制。问题要求对总预测展宽与提供的实验测量值进行定量比较。\n\n解决方案首先基于无规固溶体的假设，构建一个近邻键长分布的概率模型。从这个分布中，计算出由组分尺寸失配引起的方差。然后将此方差与给定的热方差和仪器方差相结合，得到总的预测方差，其平方根即为预测的峰宽。\n\n设合金由 $N$ 种元素组成，索引为 $i = 1, \\dots, N$。每种元素 $i$ 由其原子浓度 $c_i$ 和金属原子半径 $r_i$ 来表征。浓度集合必须满足条件 $\\sum_{i=1}^{N} c_i = 1$。\n\n该模型将种类为 $i$ 和 $j$ 的近邻原子对的键长 $d_{ij}$ 定义为其金属半径之和：\n$$d_{ij} = r_i + r_j$$\n这是一个将原子视为硬球的一阶近似。\n\n在无规合金中，在任何给定的晶格位置上找到种类为 $i$ 的原子的概率是 $c_i$。因此，找到一个特定的有序原子对（先是 $i$ 后是 $j$）的概率是 $c_i c_j$。该模型考虑的是无序对，它代表一个单一的物理键。种类为 $i$ 和 $j$ 之间的键的概率 $P_{ij}$ 由下式给出：\n$$\nP_{ij} =\n\\begin{cases}\n    c_i^2       \\text{如果 } i = j \\\\\n    2 c_i c_j   \\text{如果 } i \\neq j\n\\end{cases}\n$$\n这些概率在所有唯一的无序对 $(i, j)$（其中 $i \\le j$）上的总和为 $(\\sum_i c_i)^2 = 1$，这证实了归一化。\n\n平均键长 $\\bar{d}$ 是该分布的期望值 $E[d]$：\n$$ \\bar{d} = E[d] = \\sum_{i} \\sum_{j} c_i c_j d_{ij} = \\sum_{i} \\sum_{j} c_i c_j (r_i + r_j) $$\n此表达式可简化为浓度加权平均原子半径的两倍：\n$$ \\bar{d} = 2 \\sum_{i=1}^{N} c_i r_i $$\n这个平均键长 $\\bar{d}$ 可以使用所提供的立方晶格几何关系与平均晶格参数 $\\bar{a}$ 相关联：对于面心立方 (fcc) 晶格，$\\bar{d} = \\bar{a} / \\sqrt{2}$；对于体心立方 (bcc) 晶格，$\\bar{d} = \\bar{a} \\sqrt{3} / 2$。虽然这确定了平均结构，但对于展宽而言，关键量是方差。\n\n此键长分布的标准差 $\\sigma_{dist}$ 量化了由原子尺寸失配引起的静态晶格畸变。它由方差 $\\sigma_{dist}^2 = E[d^2] - (E[d])^2$ 导出。$E[d^2]$ 项计算如下：\n$$ E[d^2] = \\sum_{i} \\sum_{j} c_i c_j d_{ij}^2 = \\sum_{i} \\sum_{j} c_i c_j (r_i + r_j)^2 $$\n因此，静态畸变引起的方差为：\n$$ \\sigma_{dist}^2 = \\left( \\sum_{i} \\sum_{j} c_i c_j (r_i + r_j)^2 \\right) - \\bar{d}^2 $$\n对于纯元素，所有半径都相同，所以所有 $d_{ij}$ 也都相同。分布只有一个值，因此 $\\sigma_{dist}^2 = 0$，正如预期。\n\n问题陈述指出，独立的高斯展宽贡献是正交相加的。这意味着它们的方差是可加的。PDF 峰的总预测方差 $\\sigma_{pred}^2$ 是静态畸变 ($\\sigma_{dist}^2$)、热效应 ($\\sigma_{therm}^2$) 和仪器分辨率 ($\\sigma_{inst}^2$) 的方差之和：\n$$ \\sigma_{pred}^2 = \\sigma_{dist}^2 + \\sigma_{therm}^2 + \\sigma_{inst}^2 $$\n给定的常数值为 $\\sigma_{therm} = 0.040$ Å 和 $\\sigma_{inst} = 0.010$ Å。\nPDF 峰的预测观测宽度是标准差：\n$$ \\sigma_{pred} = \\sqrt{\\sigma_{dist}^2 + \\sigma_{therm}^2 + \\sigma_{inst}^2} $$\n最后，对于每个测试用例，我们计算预测宽度与实验宽度 $\\sigma_{exp}$ 之间的差值 $\\Delta$：\n$$ \\Delta = \\sigma_{pred} - \\sigma_{exp} $$\n\n该模型的预测与实验现实之间的差异可能很大。该模型假设 $d_{ij} = r_i + r_j$ 忽略了局部的电子和结构弛豫。原子并非表现为刚性球体；它们的键长会进行调整以最小化体系的总能量，这受到局部化学环境和电荷转移效应的影响。更复杂的方法，如密度泛函理论 (DFT)，可以捕捉到这些弛豫。然而，DFT 计算本身也依赖于交换相关 (XC) 泛函（例如，局域密度近似 (LDA) vs. 广义梯度近似 (GGA)）的选择。不同的 XC 泛函会产生不同的平衡键长，从而对静态晶格畸变的幅度 ($\\sigma_{dist}$) 做出不同的预测。因此，理论模型（无论是这里使用的简单模型还是复杂的 DFT 模型）与实验数据之间的任何不一致，都可能源于模型的内在近似和模型中选择的特定参数（如 DFT 中的 XC 泛函）。\n\n现在将该步骤应用于每个测试用例。所有长度单位均为埃（Å）。\n\n**测试用例 1**：$\\{\\text{Cr}:0.20,\\text{Mn}:0.20,\\text{Fe}:0.20,\\text{Co}:0.20,\\text{Ni}:0.20\\}$，结构 fcc，$\\sigma_{exp} = 0.055$ Å。\n半径：$r_{Cr}=1.28$, $r_{Mn}=1.27$, $r_{Fe}=1.26$, $r_{Co}=1.25$, $r_{Ni}=1.24$。\n$\\sigma_{dist}^2 = 0.0004$ Å$^2$。\n$\\sigma_{pred}^2 = 0.0004 + (0.040)^2 + (0.010)^2 = 0.0004 + 0.0016 + 0.0001 = 0.0021$ Å$^2$。\n$\\sigma_{pred} = \\sqrt{0.0021} \\approx 0.045826$ Å。\n$\\Delta_1 = 0.045826 - 0.055 = -0.009174$ Å。\n\n**测试用例 2**：$\\{\\text{Ni}:0.50,\\text{Al}:0.50\\}$，结构 fcc，$\\sigma_{exp} = 0.130$ Å。\n半径：$r_{Ni}=1.24$, $r_{Al}=1.43$。\n$\\sigma_{dist}^2 \\approx 0.01805$ Å$^2$。\n$\\sigma_{pred}^2 = 0.01805 + 0.0016 + 0.0001 = 0.01975$ Å$^2$。\n$\\sigma_{pred} = \\sqrt{0.01975} \\approx 0.140535$ Å。\n$\\Delta_2 = 0.140535 - 0.130 = 0.010535$ Å。\n\n**测试用例 3**：$\\{\\text{Cu}:1.00\\}$，结构 fcc，$\\sigma_{exp} = 0.045$ Å。\n半径：$r_{Cu}=1.28$。\n由于这是纯元素，没有组分尺寸失配，所以 $\\sigma_{dist}^2 = 0$。\n$\\sigma_{pred}^2 = 0 + (0.040)^2 + (0.010)^2 = 0.0016 + 0.0001 = 0.0017$ Å$^2$。\n$\\sigma_{pred} = \\sqrt{0.0017} \\approx 0.041231$ Å。\n$\\Delta_3 = 0.041231 - 0.045 = -0.003769$ Å。\n\n**测试用例 4**：$\\{\\text{V}:0.25,\\text{Nb}:0.25,\\text{Ta}:0.25,\\text{W}:0.25\\}$，结构 bcc，$\\sigma_{exp} = 0.085$ Å。\n半径：$r_{V}=1.34$, $r_{Nb}=1.43$, $r_{Ta}=1.43$, $r_{W}=1.37$。\n$\\sigma_{dist}^2 \\approx 0.0021375$ Å$^2$。\n$\\sigma_{pred}^2 = 0.0021375 + 0.0016 + 0.0001 = 0.0038375$ Å$^2$。\n$\\sigma_{pred} = \\sqrt{0.0038375} \\approx 0.061948$ Å。\n$\\Delta_4 = 0.061948 - 0.085 = -0.023052$ Å。\n\n这些差异将由附带的程序计算并格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the difference between predicted and experimental PDF first-peak widths\n    for several multi-component alloys, based on a model of lattice distortion.\n    \"\"\"\n\n    # Define atomic radii and fixed broadening contributions in ångström.\n    atomic_radii = {\n        'Cr': 1.28, 'Mn': 1.27, 'Fe': 1.26, 'Co': 1.25, 'Ni': 1.24,\n        'Al': 1.43, 'Cu': 1.28, 'V': 1.34, 'Nb': 1.43, 'Ta': 1.43,\n        'W': 1.37\n    }\n    sigma_therm = 0.040  # Thermal broadening standard deviation\n    sigma_inst = 0.010   # Instrument broadening standard deviation\n\n    # Test cases: (composition dictionary, experimental width in ångström)\n    # The crystal structure is for context and not used in the width calculation.\n    test_cases = [\n        ({'Cr': 0.20, 'Mn': 0.20, 'Fe': 0.20, 'Co': 0.20, 'Ni': 0.20}, 0.055),\n        ({'Ni': 0.50, 'Al': 0.50}, 0.130),\n        ({'Cu': 1.00}, 0.045),\n        ({'V': 0.25, 'Nb': 0.25, 'Ta': 0.25, 'W': 0.25}, 0.085)\n    ]\n\n    differences = []\n\n    for composition, sigma_exp in test_cases:\n        elements = list(composition.keys())\n        concentrations = np.array(list(composition.values()))\n        radii = np.array([atomic_radii[el] for el in elements])\n        num_species = len(elements)\n\n        # Step 1: Calculate the mean bond length (d_bar)\n        # d_bar = E[d] = 2 * sum(c_i * r_i)\n        d_bar = 2 * np.dot(concentrations, radii)\n\n        # Step 2: Calculate the variance due to static distortion (sigma_dist^2)\n        # sigma_dist^2 = E[d^2] - (E[d])^2\n        # E[d^2] = sum_i sum_j c_i * c_j * (r_i + r_j)^2\n        e_d_squared = 0.0\n        for i in range(num_species):\n            for j in range(num_species):\n                e_d_squared += concentrations[i] * concentrations[j] * (radii[i] + radii[j])**2\n        \n        sigma_dist_sq = e_d_squared - d_bar**2\n\n        # Step 3: Combine variances to get the predicted total variance\n        # Variances add in quadrature.\n        sigma_pred_sq = sigma_dist_sq + sigma_therm**2 + sigma_inst**2\n\n        # Step 4: Calculate the predicted total width (standard deviation)\n        sigma_pred = np.sqrt(sigma_pred_sq)\n\n        # Step 5: Compute the difference between predicted and experimental widths\n        difference = sigma_pred - sigma_exp\n        differences.append(difference)\n\n    # Final print statement in the exact required format with 6 decimal places.\n    formatted_differences = [f\"{d:.6f}\" for d in differences]\n    print(f\"[{','.join(formatted_differences)}]\")\n\nsolve()\n```"
        }
    ]
}