{
    "hands_on_practices": [
        {
            "introduction": "Molecular dynamics simulations often use Periodic Boundary Conditions (PBCs) to model bulk materials, which causes particles to \"wrap around\" the simulation box. This creates artificial jumps in the recorded trajectory, making direct calculation of displacement incorrect. This first practice  is fundamental: you will implement an \"unwrapping\" algorithm to reconstruct the true, continuous particle path, a critical prerequisite for accurately computing the Mean Squared Displacement.",
            "id": "3465051",
            "problem": "Consider a molecular dynamics style trajectory of a single point particle inside a cubic simulation box of side length $L$ with Periodic Boundary Conditions (PBC). The recorded positions at discrete times are wrapped into the primary simulation cell, and instantaneous displacements are measured under the Minimum Image Convention (MIC). You must explain how these recording rules alter the stored data and design an unwrapping algorithm that reconstructs the continuous trajectory from the wrapped positions such that Mean Squared Displacement (MSD) and the diffusion coefficient are computed accurately.\n\nStart from the following foundational bases:\n- The definition of position as a function of time $x(t)$ and displacement $\\Delta x = x(t+\\Delta t) - x(t)$.\n- The concept of PBC as identifying positions modulo the box length $L$ along each Cartesian coordinate, so that the simulation domain is topologically a three-dimensional torus.\n- The definition of the MSD for a time lag $\\tau$ in $d$ dimensions as the time-origin average of the squared norm of net displacements over $\\tau$, and the relationship between isotropic diffusion and the linear growth in MSD at long times.\n\nYou must not rely on any shortcut formulas beyond these bases. Your implementation must explicitly reconstruct the continuous trajectory by cumulatively adding per-frame displacement increments chosen to be the nearest periodic images under MIC. Then compute a time-averaged MSD curve over available time lags and estimate the diffusion coefficient in the long-time diffusive regime using a statistically sound linear regression approach.\n\nUnits and numerical requirements:\n- All lengths must be in nanometers (nm).\n- All times must be in picoseconds (ps).\n- The diffusion coefficient must be expressed in $\\text{nm}^2/\\text{ps}$.\n- The final reported diffusion coefficients for test cases must be rounded to six decimal places.\n\nYour program must implement the following components:\n- A function that takes an array of wrapped positions in $d$ dimensions and a box length $L$, and returns the unwrapped, continuous positions by cumulatively summing MIC-consistent increments.\n- A function that computes the time-averaged MSD for all integer time lags $k$ from $1$ to a chosen maximum, where the lag time is $\\tau_k = k \\Delta t$ and $\\Delta t$ is the uniform time step between frames.\n- An estimator that, for an isotropic diffusive process in $d$ dimensions, obtains the diffusion coefficient from the slope of the MSD versus $\\tau$ in the long-time regime via linear regression over a specified lag-time interval.\n\nTest suite and parameter specifications:\nImplement and run the following three test cases. In all cases, use a fixed pseudorandom number generator seed $12345$ to ensure reproducibility.\n\n- Test Case $1$ (deterministic drift in one dimension):\n    - Dimension $d = 1$.\n    - Box length $L = 10$ nm.\n    - Time step $\\Delta t = 1$ ps.\n    - Number of frames $N = 12$.\n    - Initial position $x(0) = 0$ nm.\n    - Deterministic velocity $v = 2$ nm/ps, so the true continuous positions are $x(n \\Delta t) = v \\, n \\, \\Delta t$ for integer $n$.\n    - The recorded positions are the wrapped positions into the primary cell under PBC.\n    - Your output for this case is a boolean indicating whether your unwrapping algorithm exactly reconstructs the original continuous positions to within absolute tolerance $10^{-12}$ nm at every frame.\n\n- Test Case $2$ (three-dimensional isotropic Brownian motion with nonzero diffusion):\n    - Dimension $d = 3$.\n    - Box length $L = 8$ nm.\n    - Time step $\\Delta t = 0.5$ ps.\n    - Number of frames $N = 4000$.\n    - True diffusion coefficient $D_{\\text{true}} = 0.05$ $\\text{nm}^2/\\text{ps}$.\n    - Continuous trajectory is generated by independent Gaussian increments per coordinate with zero mean and variance per step consistent with isotropic diffusion in $d$ dimensions over time step $\\Delta t$, starting from the origin.\n    - Positions are recorded as wrapped under PBC.\n    - Unwrap the positions, compute the time-averaged MSD, perform a linear regression of MSD versus lag time $\\tau$ over the interval $\\tau \\in [10, 800]$ ps, and report the estimated diffusion coefficient as a float in $\\text{nm}^2/\\text{ps}$ rounded to six decimal places.\n\n- Test Case $3$ (three-dimensional stationary particle):\n    - Dimension $d = 3$.\n    - Box length $L = 6$ nm.\n    - Time step $\\Delta t = 0.5$ ps.\n    - Number of frames $N = 200$.\n    - True diffusion coefficient $D_{\\text{true}} = 0$ $\\text{nm}^2/\\text{ps}$.\n    - The particle remains at the origin for all times.\n    - Positions are recorded as wrapped under PBC (which leaves all positions unchanged).\n    - Unwrap the positions, compute the time-averaged MSD, perform a linear regression of MSD versus lag time $\\tau$ over the interval $\\tau \\in [1, 50]$ ps, and report the estimated diffusion coefficient as a float in $\\text{nm}^2/\\text{ps}$ rounded to six decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the three test cases: the boolean for Test Case $1$, followed by the diffusion coefficient estimates for Test Case $2$ and Test Case $3$. For example, your output must look like $\\texttt{[True,0.049872,0.000000]}$ with the actual numeric values determined by your implementation and computations.",
            "solution": "The problem requires the development and implementation of a methodology to compute the Mean Squared Displacement (MSD) and estimate the diffusion coefficient from a particle trajectory recorded in a simulation box with Periodic Boundary Conditions (PBC). The core challenge lies in correcting for the artificial coordinate wrapping introduced by PBC before performing the physical analysis.\n\n### Principle-Based Design\n\n#### 1. Periodic Boundary Conditions and Wrapped Coordinates\nIn molecular simulations, PBC are employed to approximate an infinite, bulk system by simulating a finite primary cell that is replicated infinitely in all directions. A particle exiting the primary cell through one face re-enters through the opposite face. This creates a space with the topology of a $d$-dimensional torus.\n\nIf the primary simulation box is a cube of side length $L$, the position of a particle is typically \"wrapped\" into this box. A particle with a continuous, unwrapped position vector $\\mathbf{r}_{\\text{cont}}$ is recorded at its wrapped position $\\mathbf{r}_{\\text{wrap}}$. For each Cartesian coordinate $i \\in \\{x, y, z\\}$, the wrapping is defined by:\n$$\nr_{i, \\text{wrap}} = r_{i, \\text{cont}} \\pmod L\n$$\nMore precisely, this can be written as:\n$$\nr_{i, \\text{wrap}} = r_{i, \\text{cont}} - L \\cdot \\lfloor \\frac{r_{i, \\text{cont}}}{L} \\rfloor\n$$\nThis operation maps any real-valued coordinate into the half-open interval $[0, L)$.\n\n#### 2. The Minimum Image Convention (MIC)\nWhen calculating the displacement between two positions, $\\mathbf{r}_1$ and $\\mathbf{r}_2$, in a periodic system, one must consider not just the displacement vector in the primary cell but the displacement to the closest periodic image. This is the Minimum Image Convention (MIC).\n\nFor a raw displacement component $\\Delta r_i = r_{i,2} - r_{i,1}$, the MIC ensures that the resulting displacement component has a magnitude no larger than $L/2$. The MIC displacement, $\\Delta r_{i, \\text{mic}}$, is calculated as:\n$$\n\\Delta r_{i, \\text{mic}} = \\Delta r_i - L \\cdot \\text{round} \\left( \\frac{\\Delta r_i}{L} \\right)\n$$\nwhere the `round` function rounds its argument to the nearest integer. This formula finds the shortest vector connecting any periodic image of $\\mathbf{r}_2$ to $\\mathbf{r}_1$.\n\n#### 3. Trajectory Unwrapping Algorithm\nIf only wrapped positions $\\mathbf{r}_{\\text{wrap}}(t)$ are stored, naive calculation of displacements, $\\mathbf{r}_{\\text{wrap}}(t_{n+1}) - \\mathbf{r}_{\\text{wrap}}(t_n)$, would produce large, spurious jumps whenever the particle crosses a periodic boundary. This would lead to a grossly overestimated MSD.\n\nTo compute the correct MSD, we must first reconstruct the continuous, unwrapped trajectory $\\mathbf{r}_{\\text{cont}}(t)$. This is achieved by iteratively accumulating displacement increments that are consistent with the MIC. The algorithm proceeds as follows:\n1. Initialize the unwrapped trajectory. The first position is unchanged: $\\mathbf{r}_{\\text{cont}}(t_0) = \\mathbf{r}_{\\text{wrap}}(t_0)$.\n2. For each subsequent time step $n = 1, 2, \\dots, N-1$:\n    a. Calculate the raw displacement between consecutive wrapped positions: $\\Delta \\mathbf{r}_{\\text{raw}} = \\mathbf{r}_{\\text{wrap}}(t_n) - \\mathbf{r}_{\\text{wrap}}(t_{n-1})$.\n    b. Apply the MIC to this raw displacement to find the physically correct displacement increment for that time step: $\\Delta \\mathbf{r}_{\\text{step}} = \\Delta \\mathbf{r}_{\\text{raw}} - L \\cdot \\text{round}(\\Delta \\mathbf{r}_{\\text{raw}} / L)$. This assumes the particle does not move more than $L/2$ in any dimension during a single time step $\\Delta t$, a standard assumption in molecular dynamics.\n    c. Update the continuous position by adding this increment to the previous continuous position: $\\mathbf{r}_{\\text{cont}}(t_n) = \\mathbf{r}_{\\text{cont}}(t_{n-1}) + \\Delta \\mathbf{r}_{\\text{step}}$.\n\nThis procedure reconstructs the true path of the particle in space, without the artificial jumps from PBC.\n\n#### 4. Mean Squared Displacement (MSD) Calculation\nThe MSD measures the average distance a particle travels over a given time interval, or lag time, $\\tau$. For a discrete trajectory of $N$ frames with a uniform time step $\\Delta t$, the lag time is $\\tau_k = k \\Delta t$, where $k$ is the number of frames in the lag. The MSD is computed by averaging the squared displacement over all possible starting times in the trajectory. Using the unwrapped positions, the MSD for a lag time $\\tau_k$ is:\n$$\n\\text{MSD}(\\tau_k) = \\left\\langle \\| \\mathbf{r}_{\\text{cont}}(t + \\tau_k) - \\mathbf{r}_{\\text{cont}}(t) \\|^2 \\right\\rangle_t = \\frac{1}{N-k} \\sum_{n=0}^{N-1-k} \\| \\mathbf{r}_{\\text{cont}}(t_{n+k}) - \\mathbf{r}_{\\text{cont}}(t_n) \\|^2\n$$\nThis calculation is performed for a range of lag indices $k$.\n\n#### 5. Isotropic Diffusion and the Einstein Relation\nFor a particle undergoing isotropic Brownian motion (diffusion) in $d$ dimensions, the MSD is expected to grow linearly with time for sufficiently long lag times. This relationship is given by the Einstein relation:\n$$\n\\lim_{\\tau \\to \\infty} \\text{MSD}(\\tau) = 2dD\\tau\n$$\nwhere $D$ is the diffusion coefficient. In practice, we analyze the \"diffusive regime\" where the MSD curve is approximately linear. By performing a linear regression of the form $\\text{MSD}(\\tau) = m\\tau + c$ on the MSD data over a suitable range of lag times $\\tau$, we can estimate the slope $m$. The diffusion coefficient is then obtained from the slope:\n$$\nD = \\frac{m}{2d}\n$$\nThis procedure forms the basis for estimating the diffusion coefficient from simulation data.\n\nThe implementation will consist of three functions corresponding to these principles: a function to unwrap the trajectory, a function to compute the MSD curve from the unwrapped trajectory, and a function to perform linear regression on the MSD curve to estimate the diffusion coefficient.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results according to the problem specification.\n    \"\"\"\n\n    def generate_wrapped_trajectory_case1(L, dt, N, v):\n        \"\"\"Generates the wrapped trajectory for Test Case 1 (deterministic drift).\"\"\"\n        time = np.arange(N) * dt\n        true_positions = v * time\n        wrapped_positions = true_positions - L * np.floor(true_positions / L)\n        return true_positions.reshape(-1, 1), wrapped_positions.reshape(-1, 1)\n\n    def generate_wrapped_trajectory_case2(L, dt, N, d, D_true, seed):\n        \"\"\"Generates the wrapped trajectory for Test Case 2 (3D Brownian motion).\"\"\"\n        rng = np.random.default_rng(seed)\n        # Variance of displacement per step is 2*D*dt per dimension\n        scale = np.sqrt(2 * D_true * dt)\n        increments = rng.normal(loc=0.0, scale=scale, size=(N - 1, d))\n        # Initial position at origin\n        initial_pos = np.zeros((1, d))\n        true_positions = np.cumsum(np.vstack([initial_pos, increments]), axis=0)\n        wrapped_positions = true_positions - L * np.floor(true_positions / L)\n        return wrapped_positions\n\n    def generate_wrapped_trajectory_case3(N, d):\n        \"\"\"Generates the wrapped trajectory for Test Case 3 (stationary particle).\"\"\"\n        return np.zeros((N, d))\n\n    def unwrap_positions(wrapped_positions, L):\n        \"\"\"\n        Reconstructs the continuous trajectory from wrapped positions.\n\n        Args:\n            wrapped_positions (np.ndarray): Array of shape (N, d) of wrapped positions.\n            L (float): Box length.\n\n        Returns:\n            np.ndarray: Array of shape (N, d) of unwrapped, continuous positions.\n        \"\"\"\n        N, d = wrapped_positions.shape\n        unwrapped_pos = np.zeros_like(wrapped_positions)\n        unwrapped_pos[0] = wrapped_positions[0]\n\n        for i in range(1, N):\n            raw_disp = wrapped_positions[i] - wrapped_positions[i-1]\n            # Apply Minimum Image Convention to find the true displacement increment\n            mic_disp = raw_disp - L * np.round(raw_disp / L)\n            unwrapped_pos[i] = unwrapped_pos[i-1] + mic_disp\n            \n        return unwrapped_pos\n\n    def compute_msd(unwrapped_positions, dt):\n        \"\"\"\n        Computes the time-averaged Mean Squared Displacement (MSD).\n\n        Args:\n            unwrapped_positions (np.ndarray): Array of shape (N, d) of unwrapped positions.\n            dt (float): Time step between frames.\n\n        Returns:\n            tuple: A tuple containing:\n                - msd_values (np.ndarray): 1D array of MSD values for each lag.\n                - lag_times (np.ndarray): 1D array of corresponding lag times (tau).\n        \"\"\"\n        N = unwrapped_positions.shape[0]\n        max_lag_k = N - 1\n        msd_values = np.zeros(max_lag_k)\n\n        for k in range(1, max_lag_k + 1):\n            displacements = unwrapped_positions[k:] - unwrapped_positions[:-k]\n            sq_displacements = np.sum(displacements**2, axis=1)\n            msd_values[k-1] = np.mean(sq_displacements)\n        \n        lag_times = (np.arange(max_lag_k) + 1) * dt\n        return msd_values, lag_times\n\n    def estimate_diffusion(msd_values, lag_times, d, lag_interval):\n        \"\"\"\n        Estimates the diffusion coefficient from an MSD curve via linear regression.\n\n        Args:\n            msd_values (np.ndarray): 1D array of MSD values.\n            lag_times (np.ndarray): 1D array of lag times.\n            d (int): a dimension of the system.\n            lag_interval (tuple): (tau_min, tau_max) for the linear regression.\n\n        Returns:\n            float: The estimated diffusion coefficient.\n        \"\"\"\n        tau_min, tau_max = lag_interval\n        \n        # Find indices corresponding to the lag time interval for regression\n        indices = np.where((lag_times >= tau_min) & (lag_times <= tau_max))\n        \n        if len(indices[0]) < 2:\n            # Not enough points to perform linear regression\n            return 0.0\n\n        taus_fit = lag_times[indices]\n        msds_fit = msd_values[indices]\n\n        # Perform linear regression: MSD = slope * tau + intercept\n        res = linregress(x=taus_fit, y=msds_fit)\n        \n        slope = res.slope\n        \n        # D = slope / (2*d)\n        D_est = slope / (2 * d)\n        \n        return D_est\n\n    # --- Test Cases ---\n    results = []\n    \n    # Test Case 1: Deterministic drift\n    L1, dt1, N1, v1 = 10.0, 1.0, 12, 2.0\n    true_pos1, wrapped_pos1 = generate_wrapped_trajectory_case1(L1, dt1, N1, v1)\n    unwrapped_pos1 = unwrap_positions(wrapped_pos1, L1)\n    is_correct = np.allclose(true_pos1, unwrapped_pos1, atol=1e-12)\n    results.append(is_correct)\n    \n    # Test Case 2: 3D Brownian motion\n    d2, L2, dt2, N2, D_true2, seed = 3, 8.0, 0.5, 4000, 0.05, 12345\n    lag_interval2 = (10.0, 800.0)\n    wrapped_pos2 = generate_wrapped_trajectory_case2(L2, dt2, N2, d2, D_true2, seed)\n    unwrapped_pos2 = unwrap_positions(wrapped_pos2, L2)\n    msd2, lags2 = compute_msd(unwrapped_pos2, dt2)\n    D_est2 = estimate_diffusion(msd2, lags2, d2, lag_interval2)\n    results.append(D_est2)\n    \n    # Test Case 3: 3D stationary particle\n    d3, L3, dt3, N3 = 3, 6.0, 0.5, 200\n    lag_interval3 = (1.0, 50.0)\n    wrapped_pos3 = generate_wrapped_trajectory_case3(N3, d3)\n    unwrapped_pos3 = unwrap_positions(wrapped_pos3, L3)\n    msd3, lags3 = compute_msd(unwrapped_pos3, dt3)\n    D_est3 = estimate_diffusion(msd3, lags3, d3, lag_interval3)\n    results.append(D_est3)\n    \n    # Format and print the final output\n    formatted_results = [\n        str(results[0]),\n        f\"{results[1]:.6f}\",\n        f\"{results[2]:.6f}\"\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a continuous trajectory is obtained, the Mean Squared Displacement (MSD) can be calculated, linking microscopic motion to the macroscopic diffusion coefficient, $D$. This exercise  focuses on the practical application of the Einstein relation, which predicts a linear relationship, $\\mathrm{MSD}(t) = 2dDt$, in the diffusive regime. You will learn to extract $D$ by performing a linear regression on provided MSD data, correctly accounting for the system's dimensionality.",
            "id": "3794095",
            "problem": "You are given time series of Mean Squared Displacement (MSD) data constructed from atomistic trajectories in different spatial dimensionalities. The goal is to extract the scalar diffusion coefficient $D$ from the slope of the MSD versus time $t$ in a regime where normal diffusion holds. Start from a valid base in multiscale materials simulation: the diffusion equation for a conserved scalar density, its Gaussian fundamental solution, and the definition of MSD. Use these foundations to justify a linear relationship between MSD and time in the diffusive regime and to design a computational procedure that estimates $D$ from MSD data.\n\nYour program must implement the following principle-based tasks:\n- Use the definition of Mean Squared Displacement (MSD) for a random process in $d$ spatial dimensions and the governing diffusion equation to justify that, in the normal diffusion regime, the MSD grows linearly with time and the proportionality constant encodes the diffusion coefficient with a dependence on the spatial dimensionality $d$.\n- Perform a statistically sound linear regression on the MSD versus time data restricted to a specified time window $\\left[t_{\\min}, t_{\\max}\\right]$ in which normal diffusion is expected to hold, avoiding early-time ballistic motion and late-time confinement or caging.\n- Convert the estimated MSD slope to the scalar diffusion coefficient $D$ that is consistent with the $d$-dimensional setting, and report $D$ in nanometer squared per nanosecond ($\\mathrm{nm}^2/\\mathrm{ns}$).\n- Round each reported diffusion coefficient to three decimal places.\n\nPhysical units:\n- Time $t$ is given in nanoseconds ($\\mathrm{ns}$).\n- Mean Squared Displacement (MSD) is given in nanometer squared ($\\mathrm{nm}^2$).\n- Diffusion coefficients must be expressed in $\\mathrm{nm}^2/\\mathrm{ns}$.\n\nYour program must use the provided test suite and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$), where each $x_i$ is the diffusion coefficient for the $i$-th test case, rounded to three decimal places.\n\nTest suite:\n- Test case $1$ (happy path, three-dimensional isotropic diffusion):\n  - Spatial dimensionality $d = 3$.\n  - Time array $t = [0.5, 1.0, 1.5, 2.0, 2.5]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [1.47, 3.02, 4.49, 6.04, 7.50]$ in $\\mathrm{nm}^2$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.5, 2.5]$ in $\\mathrm{ns}$.\n\n- Test case $2$ (two-dimensional, early-time ballistic regime excluded via window):\n  - Spatial dimensionality $d = 2$.\n  - Time array $t = [0.0, 0.1, 0.2, 0.3, 0.5, 0.6, 0.8, 1.0]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [0.00, 0.09, 0.36, 0.81, 1.80, 2.23, 3.22, 4.13]$ in $\\mathrm{nm}^2$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.5, 1.0]$ in $\\mathrm{ns}$.\n\n- Test case $3$ (three-dimensional anisotropic principal diffusivities aggregated into scalar MSD):\n  - Spatial dimensionality $d = 3$.\n  - Time array $t = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [0.74, 1.43, 2.19, 2.86, 3.60, 4.33]$ in $\\mathrm{nm}^2$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.2, 1.2]$ in $\\mathrm{ns}$.\n\n- Test case $4$ (one-dimensional, confinement causing long-time plateau; extract from early-time window):\n  - Spatial dimensionality $d = 1$.\n  - Time array $t = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [0.00, 0.34, 0.75, 1.07, 1.46, 1.86, 1.95, 1.99, 2.01]$ in $\\mathrm{ns}$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.2, 0.8]$ in $\\mathrm{ns}$.\n\nAlgorithmic requirements:\n- For each test case, select all data pairs $(t_i, \\mathrm{MSD}_i)$ with $t_{\\min} \\le t_i \\le t_{\\max}$.\n- Fit a straight line $\\mathrm{MSD}(t) \\approx S \\, t + C$ by least squares on the selected window to estimate the slope $S$.\n- Convert the slope to the scalar diffusion coefficient $D$ consistent with the $d$-dimensional setting.\n- Report each $D$ as a floating-point number in $\\mathrm{nm}^2/\\mathrm{ns}$, rounded to three decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$), where each $x_i$ corresponds to the diffusion coefficient for test case $i$, rounded to three decimal places.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard task in computational materials science: the extraction of a transport coefficient from time-series data generated by a simulation. The provided data and parameters are sufficient and physically plausible.\n\nOur procedure is constructed from first principles, beginning with the macroscopic diffusion equation and connecting it to the microscopic statistical definition of mean squared displacement.\n\nA fundamental tenet of statistical mechanics is that macroscopic diffusion, governed by Fick's laws, is the collective result of microscopic random walks of constituent particles. For a conserved quantity with concentration $\\rho(\\mathbf{r}, t)$, its evolution in a homogeneous, isotropic medium is described by the diffusion equation. In $d$ spatial dimensions, this is:\n$$\n\\frac{\\partial \\rho(\\mathbf{r}, t)}{\\partial t} = D \\nabla^2 \\rho(\\mathbf{r}, t)\n$$\nwhere $D$ is the scalar diffusion coefficient, and $\\nabla^2$ is the $d$-dimensional Laplacian operator. For a single particle starting at the origin $\\mathbf{r}(0) = \\mathbf{0}$, the concentration $\\rho$ can be interpreted as the probability density function for the particle's position. The solution to the diffusion equation for an instantaneous point source at the origin (a delta function initial condition $\\rho(\\mathbf{r}, 0) = \\delta(\\mathbf{r})$) is the Gaussian or fundamental solution:\n$$\n\\rho(\\mathbf{r}, t) = \\frac{1}{(4 \\pi D t)^{d/2}} \\exp\\left(-\\frac{|\\mathbf{r}|^2}{4 D t}\\right)\n$$\nThis function describes the probability of finding the particle at position $\\mathbf{r}$ at time $t$.\n\nThe Mean Squared Displacement, $\\mathrm{MSD}(t)$, is defined as the ensemble average of the squared Euclidean distance traveled by a particle from its origin over a time interval $t$. For a particle starting at the origin, this is:\n$$\n\\mathrm{MSD}(t) = \\langle |\\mathbf{r}(t)|^2 \\rangle\n$$\nThis expectation value can be calculated by integrating over all possible positions, weighted by the probability density $\\rho(\\mathbf{r}, t)$:\n$$\n\\mathrm{MSD}(t) = \\int_{\\mathbb{R}^d} |\\mathbf{r}|^2 \\rho(\\mathbf{r}, t) \\, d^d\\mathbf{r}\n$$\nSubstituting the Gaussian solution for $\\rho(\\mathbf{r}, t)$ and recognizing that $|\\mathbf{r}|^2 = \\sum_{i=1}^d x_i^2$, the integral becomes:\n$$\n\\mathrm{MSD}(t) = \\sum_{i=1}^d \\int_{\\mathbb{R}^d} x_i^2 \\frac{1}{(4 \\pi D t)^{d/2}} \\exp\\left(-\\sum_{j=1}^d \\frac{x_j^2}{4 D t}\\right) \\, d x_1 \\dots d x_d\n$$\nThe integral separates into a product of one-dimensional integrals. For each coordinate $x_i$, the term $\\int_{-\\infty}^{\\infty} x_i^2 \\frac{1}{\\sqrt{4 \\pi D t}} \\exp(-\\frac{x_i^2}{4 D t}) \\, dx_i$ is the second moment (variance) of a one-dimensional Gaussian distribution with mean $0$ and variance $\\sigma^2 = 2Dt$. The value of this integral is precisely $2Dt$. Since all other one-dimensional integrals of the form $\\int_{-\\infty}^{\\infty} \\rho(x_j, t) \\, dx_j$ for $j \\neq i$ are equal to $1$, we find that $\\langle x_i^2 \\rangle = 2Dt$ for each dimension $i$. Summing over all $d$ dimensions gives the celebrated Einstein relation for normal diffusion:\n$$\n\\mathrm{MSD}(t) = \\sum_{i=1}^d \\langle x_i(t)^2 \\rangle = \\sum_{i=1}^d 2Dt = 2dDt\n$$\nThis equation establishes a direct linear relationship between the mean squared displacement and time, $\\mathrm{MSD}(t) = S \\cdot t$, where the slope $S$ is given by $S = 2dD$. Consequently, the diffusion coefficient $D$ can be determined from the empirically measured slope of an MSD-versus-time plot via the formula:\n$$\nD = \\frac{S}{2d}\n$$\nThe problem specifies that material simulation data for $\\mathrm{MSD}(t)$ is provided. This data is subject to statistical noise and may exhibit different physical regimes. At very short times (ballistic regime, $t \\to 0$), $\\mathrm{MSD} \\propto t^2$. At very long times, particles might be affected by finite-size effects or confinement (caging), causing the MSD to plateau. The linear, diffusive regime lies between these two extremes. The task is to estimate $D$ by analyzing the data within a specified time window $[t_{\\min}, t_{\\max}]$ where this linear, diffusive behavior is expected to dominate.\n\nThe computational procedure is as follows:\n$1$. For each test case, the provided time array $t$ and $\\mathrm{MSD}$ array are filtered to retain only the data points $(t_i, \\mathrm{MSD}_i)$ that fall within the specified analysis window, i.e., where $t_{\\min} \\le t_i \\le t_{\\max}$. Let the filtered data set be denoted as $\\{(t'_j, y'_j)\\}_{j=1}^N$.\n\n$2$. A linear model, $y'(t') = S t' + C$, is fitted to this filtered data set using the method of ordinary least squares (OLS). The goal is to find the slope $S$ and intercept $C$ that minimize the sum of the squared residuals. The formula for the slope $S$ is:\n$$\nS = \\frac{N \\sum_{j=1}^{N} t'_j y'_j - (\\sum_{j=1}^{N} t'_j)(\\sum_{j=1}^{N} y'_j)}{N \\sum_{j=1}^{N} (t'_j)^2 - (\\sum_{j=1}^{N} t'_j)^2}\n$$\nThis calculation will be performed numerically.\n\n$3$. With the slope $S$ determined from the linear regression, the diffusion coefficient $D$ is calculated using the derived relationship for the appropriate spatial dimensionality $d$:\n$$\nD = \\frac{S}{2d}\n$$\nThe units of $t$ are nanoseconds ($\\mathrm{ns}$) and the units of $\\mathrm{MSD}$ are nanometers squared ($\\mathrm{nm}^2$), so the slope $S$ has units of $\\mathrm{nm}^2/\\mathrm{ns}$. The resulting diffusion coefficient $D$ will also have units of $\\mathrm{nm}^2/\\mathrm{ns}$, as required.\n\n$4$. The final calculated value of $D$ for each test case is rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates diffusion coefficients from Mean Squared Displacement (MSD) data\n    for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path, three-dimensional isotropic diffusion)\n        {\n            \"d\": 3,\n            \"t\": np.array([0.5, 1.0, 1.5, 2.0, 2.5]),\n            \"msd\": np.array([1.47, 3.02, 4.49, 6.04, 7.50]),\n            \"window\": (0.5, 2.5)\n        },\n        # Test case 2 (two-dimensional, early-time ballistic regime excluded via window)\n        {\n            \"d\": 2,\n            \"t\": np.array([0.0, 0.1, 0.2, 0.3, 0.5, 0.6, 0.8, 1.0]),\n            \"msd\": np.array([0.00, 0.09, 0.36, 0.81, 1.80, 2.23, 3.22, 4.13]),\n            \"window\": (0.5, 1.0)\n        },\n        # Test case 3 (three-dimensional anisotropic principal diffusivities aggregated into scalar MSD)\n        {\n            \"d\": 3,\n            \"t\": np.array([0.2, 0.4, 0.6, 0.8, 1.0, 1.2]),\n            \"msd\": np.array([0.74, 1.43, 2.19, 2.86, 3.60, 4.33]),\n            \"window\": (0.2, 1.2)\n        },\n        # Test case 4 (one-dimensional, confinement causing long-time plateau; extract from early-time window)\n        {\n            \"d\": 1,\n            \"t\": np.array([0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]),\n            \"msd\": np.array([0.00, 0.34, 0.75, 1.07, 1.46, 1.86, 1.95, 1.99, 2.01]),\n            \"window\": (0.2, 0.8)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        d = case[\"d\"]\n        t_full = case[\"t\"]\n        msd_full = case[\"msd\"]\n        t_min, t_max = case[\"window\"]\n\n        # Step 1: Select data within the specified time window\n        # Create a boolean mask for times within the window [t_min, t_max]\n        indices = (t_full >= t_min) & (t_full <= t_max)\n        t_window = t_full[indices]\n        msd_window = msd_full[indices]\n        \n        # Step 2: Fit a straight line by least squares to estimate the slope S\n        # np.polyfit with degree 1 performs a linear regression and returns [slope, intercept]\n        if len(t_window) < 2:\n            # Not enough points for a linear fit, though problem guarantees this won't happen.\n            # Handle this case gracefully if it were a general function.\n            slope = np.nan\n        else:\n            # The model is MSD(t) = S*t + C\n            coeffs = np.polyfit(t_window, msd_window, 1)\n            slope = coeffs[0]\n\n        # Step 3: Convert the slope to the scalar diffusion coefficient D\n        # The Einstein relation is MSD(t) = 2*d*D*t, so slope S = 2*d*D\n        # Therefore, D = S / (2*d)\n        diffusion_coefficient = slope / (2 * d)\n\n        # Step 4: Round the diffusion coefficient to three decimal places\n        # The result must be a float, not a string at this stage\n        rounded_d = round(diffusion_coefficient, 3)\n        results.append(rounded_d)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) is used to format each float as a string before joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In complex systems like amorphous alloys, the MSD curve often displays non-linear behavior at short and intermediate times, such as ballistic motion and \"caging\" effects, before the true diffusive regime begins. This final practice  introduces an advanced, data-driven method to automatically identify the correct linear region for fitting, a crucial skill for robust analysis. By analyzing the local scaling exponent of the MSD curve, you will develop an algorithm that avoids the pitfalls of manual and subjective window selection.",
            "id": "3731737",
            "problem": "You are given time series of mean square displacement as a function of time, denoted by $MSD(t)$, for structurally disordered, amorphous high-entropy alloys. The goal is to estimate the long-time self-diffusion coefficient $D$ while rigorously excluding contributions from the early-time ballistic regime and the intermediate-time caging regime. Your program must implement a principled, data-adaptive approach that identifies the asymptotically linear regime of $MSD(t)$ without using any fixed, hard-coded time cutoffs.\n\nStarting point and physical bases that you may rely on:\n- For very short times $t$, particle motion retains inertia, with displacements dominated by velocity persistence, and $MSD(t)$ grows approximately as a quadratic function of time.\n- Structural disorder in amorphous systems generates transient “cages” that impede motion, often leading to a near-plateau or sublinear growth of $MSD(t)$ over an intermediate time window.\n- At sufficiently long times, the central limit theorem and loss of memory of initial conditions imply that $MSD(t)$ grows linearly with $t$ in the diffusive regime for an isotropic, homogeneous material in three spatial dimensions.\n\nYour method must:\n1. Detect and exclude both the early-time ballistic and the intermediate-time caging regimes in a data-driven manner by analyzing the local scaling behavior of $MSD(t)$ with respect to $t$. The method must not assume any prior knowledge of the exact cutoff times separating regimes.\n2. Identify a stable time window in which $MSD(t)$ is asymptotically linear with $t$. Within this window, perform a robust line fit of $MSD$ versus $t$ in ordinary (not logarithmic) coordinates.\n3. From the fitted long-time linear behavior in three dimensions, infer the self-diffusion coefficient $D$ and report it in the required units.\n\nMathematical and algorithmic requirements:\n- Use a sliding-window analysis of the local scaling exponent defined by $ \\alpha = \\dfrac{d \\log(MSD)}{d \\log(t)} $ to detect the diffusive regime, where $ \\alpha $ is close to $ 1 $. You must design a quantitative criterion of “sufficiently close” and “sufficiently stable” and justify it algorithmically.\n- Use a robust linear regression for $MSD$ versus $t$ in the candidate diffusive window to mitigate the effect of noise and outliers.\n- Implement a decision rule to choose the final fitting window when multiple candidate windows satisfy your criteria. The rule must prefer windows that are longer and more linear by an appropriate quantitative score.\n- Avoid any fixed, hand-tuned cutoff times expressed directly in time units; all exclusions must be discovered from the data through your criteria.\n\nUnits and output:\n- The input time $t$ is given in picoseconds ($ps$), and the input mean square displacement $MSD$ is given in square nanometers ($nm^2$).\n- You must report the final $D$ in meters squared per second ($m^2/s$).\n- Express the final results as scientific-notation decimal numbers with three significant figures (for example, $1.23 \\times 10^{-8}$ should be printed as $1.23e-08$). The printed format must be a single line containing a comma-separated list enclosed in square brackets, such as $[d_1,d_2,d_3,d_4]$, with no spaces, where each $d_i$ is the estimated diffusion coefficient for the corresponding test case in $m^2/s$.\n\nSynthetic test suite:\nYou must generate four synthetic $MSD(t)$ datasets, each of which is a noisy, smooth composition of three physically motivated components: an early ballistic contribution that decays, a caging plateau that emerges and then decays, and a long-time diffusive growth that turns on gradually. For each dataset, generate a time grid $t_i$ and then construct\n$$\nMSD(t) \\;=\\; v_2\\, t^2 \\, e^{-\\left(\\frac{t}{t_b}\\right)^2}\n\\;+\\; a \\left(1 - e^{-\\left(\\frac{t}{t_c}\\right)^2}\\right) e^{-\\left(\\frac{t}{t_d}\\right)^2}\n\\;+\\; 6 D \\, t \\left(1 - e^{-\\left(\\frac{t}{t_d}\\right)^2}\\right)\n\\;+\\; \\eta,\n$$\nwhere:\n- $t$ is in $ps$,\n- $MSD$ is in $nm^2$,\n- $v_2$ has units $nm^2/ps^2$,\n- $a$ has units $nm^2$,\n- $t_b, t_c, t_d$ have units $ps$,\n- $D$ has units $nm^2/ps$,\n- $\\eta$ is additive zero-mean Gaussian noise with standard deviation $\\sigma$ in $nm^2$; if $MSD(t)$ becomes non-positive at any point due to noise, clip it to a small positive floor $10^{-12}\\,nm^2$ to keep logarithms well-defined.\n\nFor each test case use a uniformly spaced time grid $t_i$ with $N$ points from $t_{\\min}$ to $t_{\\max}$ inclusive, with $t_{\\min} = 10^{-3}\\,ps$. Use the following parameter sets and random seeds to generate the datasets:\n\n- Case $1$ (happy path, clear long diffusive tail):\n  - $N = 1200$, $t_{\\max} = 100$, $v_2 = 0.50$, $a = 0.20$, $t_b = 0.20$, $t_c = 1.00$, $t_d = 5.00$, $D = 0.020$, $\\sigma = 5.0 \\times 10^{-3}$, seed $= 12345$.\n- Case $2$ (extended caging, late-onset diffusion, slower $D$):\n  - $N = 1600$, $t_{\\max} = 200$, $v_2 = 0.70$, $a = 0.50$, $t_b = 0.50$, $t_c = 5.00$, $t_d = 30.0$, $D = 0.0050$, $\\sigma = 3.0 \\times 10^{-3}$, seed $= 24680$.\n- Case $3$ (short trajectory, minimal diffusive window, faster $D$):\n  - $N = 900$, $t_{\\max} = 20.0$, $v_2 = 0.60$, $a = 0.30$, $t_b = 0.80$, $t_c = 3.00$, $t_d = 8.00$, $D = 0.0300$, $\\sigma = 1.0 \\times 10^{-2}$, seed $= 13579$.\n- Case $4$ (noisier data, moderate $D$):\n  - $N = 1400$, $t_{\\max} = 120.0$, $v_2 = 0.40$, $a = 0.25$, $t_b = 0.30$, $t_c = 2.50$, $t_d = 10.0$, $D = 0.0150$, $\\sigma = 2.0 \\times 10^{-2}$, seed $= 11223$.\n\nAll numerical values above are in $ps$ and $nm^2$-based units as indicated. You must convert the final estimated diffusion coefficients to $m^2/s$ using the exact conversion factor $1\\,nm^2/ps = 10^{-6}\\,m^2/s$.\n\nProgram requirements:\n- Implement the data generation and the estimation method exactly as specified.\n- Your program should produce a single line of output containing the results as a comma-separated list of the four estimated diffusion coefficients in $m^2/s$, enclosed in square brackets, with each value printed in scientific notation with three significant figures (e.g., $[2.00e-08,5.00e-09,3.00e-08,1.50e-08]$). No additional text may be printed.",
            "solution": "The ensuing discourse provides a complete solution to the problem of estimating the self-diffusion coefficient from mean square displacement data. The process begins with a mandatory critical validation of the problem statement.\n\n### Step 1: Extract Givens\n\n- **Objective**: Estimate the long-time self-diffusion coefficient $D$ from time series data of mean square displacement, $MSD(t)$.\n- **Physical System**: Structurally disordered, amorphous high-entropy alloys.\n- **Physical Model**: Particle motion exhibits three regimes:\n    1. Early-time ballistic: $MSD(t) \\propto t^2$.\n    2. Intermediate-time caging: Sublinear growth of $MSD(t)$.\n    3. Long-time diffusive: $MSD(t)$ is linear with $t$. For three dimensions, $MSD(t) = 6Dt$.\n- **Core Methodological Constraint**: The method must be data-adaptive, identifying the linear diffusive regime without using fixed, hard-coded time cutoffs.\n- **Algorithmic Requirements**:\n    1. Use a sliding-window analysis of the local scaling exponent $\\alpha = \\frac{d \\log(MSD)}{d \\log(t)}$ to find where $\\alpha \\approx 1$.\n    2. Implement quantitative criteria for \"sufficiently close\" and \"sufficiently stable\" for $\\alpha$.\n    3. Use a robust linear regression for $MSD$ versus $t$ in the identified diffusive window.\n    4. Implement a decision rule to select the best window if multiple candidates exist, favoring longer and more linear windows.\n- **Units and Conversions**:\n    - Input time $t$ is in picoseconds ($ps$).\n    - Input $MSD$ is in square nanometers ($nm^2$).\n    - The final reported $D$ must be in meters squared per second ($m^2/s$).\n    - The conversion factor is $1\\,nm^2/ps = 10^{-6}\\,m^2/s$.\n- **Synthetic Data Generation**:\n    - Formula: $MSD(t) = v_2 t^2 e^{-(t/t_b)^2} + a (1 - e^{-(t/t_c)^2}) e^{-(t/t_d)^2} + 6 D t (1 - e^{-(t/t_d)^2}) + \\eta$.\n    - $\\eta$ is zero-mean Gaussian noise with standard deviation $\\sigma$.\n    - Non-positive $MSD(t)$ values are clipped to a floor of $10^{-12}\\,nm^2$.\n    - Time grid: $N$ points, uniformly spaced from $t_{\\min} = 10^{-3}\\,ps$ to $t_{\\max}$.\n- **Test Cases**: Four specific parameter sets (Case 1, Case 2, Case 3, Case 4) are provided, each with values for $N, t_{\\max}, v_2, a, t_b, t_c, t_d, D, \\sigma$, and a random seed.\n- **Output Format**: A single line containing a comma-separated list of the four diffusion coefficients in $m^2/s$, enclosed in square brackets (e.g., `[d1,d2,d3,d4]`), with each value in scientific notation with three significant figures.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is subjected to rigorous validation.\n\n1.  **Scientific or Factual Unsoundness**: The problem is scientifically sound. It is based on the canonical model of diffusion in disordered systems, which correctly describes ballistic, caged, and diffusive regimes. The use of the Einstein relation, $MSD(t) = 2dDt$ (where the dimensionality $d=3$), and the analysis of the local logarithmic derivative $\\alpha(t)$ are standard, well-established methods in condensed matter physics and statistical mechanics. The synthetic data model is a physically plausible representation of these combined effects.\n2.  **Non-Formalizable or Irrelevant**: The problem is highly formalizable as a numerical analysis task grounded in physics. It is directly and unambiguously related to the specified topic of calculating diffusion coefficients from mean square displacement.\n3.  **Incomplete or Contradictory Setup**: The problem is complete. It provides all necessary parameters, equations, and explicit random seeds to generate the test data deterministically. The requirements for the analysis method and output format are specified in detail, leaving no room for ambiguity. There are no contradictions in the givens.\n4.  **Unrealistic or Infeasible**: The physical parameters and time scales are representative of those found in molecular dynamics simulations of amorphous materials and complex liquids. The task is challenging but entirely feasible with standard numerical libraries.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed. It requests the estimation of a specific parameter ($D$) using a constrained but sensible methodology. The provision of synthetic data with a known ground-truth $D$ allows for a clear success criterion. The core challenge—designing the data-adaptive windowing logic—is a well-defined algorithmic design task, not an ill-posed problem.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is non-trivial. A simple linear fit across the entire dataset would yield an incorrect result due to the contributions of the ballistic and caging regimes. The problem requires a thoughtful implementation of a filtering and selection algorithm that bypasses these non-diffusive portions of the data, which is a common and substantive challenge in real-world data analysis.\n7.  **Outside Scientific Verifiability**: The problem is perfectly verifiable. Given the fixed seeds and deterministic data generation formula, any correct implementation of the algorithm will produce the same set of input data and should yield highly comparable final results.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is scientifically sound, well-posed, and presents a clear, non-trivial challenge that is representative of real-world scientific data analysis. The solution process may proceed.\n\n### Principled Solution Design\n\nThe core objective is to estimate the diffusion coefficient $D$ from the long-time linear regime of the mean square displacement, $MSD(t)$. The relation in three dimensions is given by the Einstein equation:\n$$MSD(t) = 6Dt + C$$\nwhere $C$ is an intercept term. Our task is to isolate the time window where this linear relationship holds and robustly estimate the slope, which is equal to $6D$. The approach must be data-adaptive, avoiding arbitrary time cutoffs.\n\n**Step 1: Local Scaling Exponent Calculation**\n\nTo distinguish the different dynamical regimes, we analyze the local scaling exponent, $\\alpha(t)$, defined as the logarithmic derivative of $MSD(t)$ with respect to $t$:\n$$\\alpha(t) = \\frac{d \\log(MSD(t))}{d \\log(t)}$$\nThis exponent quantifies the power-law relationship $MSD(t) \\sim t^{\\alpha(t)}$ in the vicinity of time $t$. The expected values are $\\alpha \\approx 2$ for the ballistic regime, $\\alpha < 1$ (often near $0$) for the caging regime, and $\\alpha \\approx 1$ for the diffusive regime.\n\nDirect numerical differentiation of noisy data is unstable as it amplifies noise. A more robust method is to compute $\\alpha(t_i)$ at each point $t_i$ by performing a linear regression on $\\log(MSD)$ versus $\\log(t)$ within a sliding window of points centered at $t_i$. The slope of this local fit provides a smoothed estimate of $\\alpha_i$. We choose a fixed window size of $51$ points for this calculation, which is large enough to average out noise but small enough to resolve changes in dynamical regimes for the given data density.\n\n**Step 2: Identification of Candidate Diffusive Windows**\n\nThe diffusive regime is characterized by $\\alpha(t) \\approx 1$. We define a quantitative criterion for this condition: we identify all time points $t_i$ where the calculated exponent $\\alpha_i$ falls within a tolerance band around $1$. We set this as:\n$$| \\alpha_i - 1.0 | < \\delta_{\\alpha}$$\nA tolerance of $\\delta_{\\alpha} = 0.1$ is chosen, identifying points where the local scaling is between $t^{0.9}$ and $t^{1.1}$.\n\nTo ensure stability and statistical significance, we are not interested in isolated points that satisfy this criterion but rather in contiguous segments of sufficient length. We find all contiguous blocks of indices where the condition holds and discard any block that is shorter than a minimum length. This minimum length is set to $10\\%$ of the total number of data points, $N$, ensuring any subsequent linear fit is performed on a substantial portion of the trajectory.\n\n**Step 3: Robust Regression and Final Window Selection**\n\nFor each candidate window identified, a linear fit of $MSD$ versus $t$ is performed. As the data contains noise, a robust regression method is superior to standard ordinary least squares. We employ the Theil-Sen estimator, a non-parametric method that is highly robust to outliers. It calculates the slope as the median of the slopes of lines connecting all pairs of points in the dataset. This provides a reliable estimate of the slope $m = 6D$.\n\nThe problem requires a rule to select the best window if multiple candidates are found. The chosen rule is: select the **longest** contiguous window that satisfies the $\\alpha$-criterion. This prioritizes the most stable and extended exhibition of diffusive behavior. In the rare event of a tie in length, the window that occurs latest in time is selected, as this best represents the true asymptotic, long-time behavior of the system.\n\n**Step 4: Diffusion Coefficient Calculation and Unit Conversion**\n\nOnce the optimal window is selected and the robust slope $m$ is estimated using `scipy.stats.theilslopes`:\n1.  The diffusion coefficient in simulation units is calculated as:\n    $$D_{\\text{sim}} = \\frac{m}{6}$$\n    The units of $D_{\\text{sim}}$ are $nm^2/ps$.\n2.  This value is converted to the required SI units of $m^2/s$ using the provided conversion factor:\n    $$D_{\\text{SI}} [m^2/s] = D_{\\text{sim}} [nm^2/ps] \\times 10^{-6}$$\n3.  The final result is formatted to scientific notation with three significant figures.\n\nThis self-contained, data-driven procedure robustly extracts the diffusion coefficient by systematically identifying the physically correct time regime for analysis, fully satisfying the problem's constraints.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import theilslopes\n\ndef solve():\n    \"\"\"\n    Main function to generate data, run the analysis for all test cases,\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, clear long diffusive tail)\n        {'N': 1200, 't_max': 100.0, 'v_2': 0.50, 'a': 0.20, 't_b': 0.20,\n         't_c': 1.00, 't_d': 5.00, 'D': 0.020, 'sigma': 5.0e-3, 'seed': 12345},\n\n        # Case 2 (extended caging, late-onset diffusion, slower D)\n        {'N': 1600, 't_max': 200.0, 'v_2': 0.70, 'a': 0.50, 't_b': 0.50,\n         't_c': 5.00, 't_d': 30.0, 'D': 0.0050, 'sigma': 3.0e-3, 'seed': 24680},\n\n        # Case 3 (short trajectory, minimal diffusive window, faster D)\n        {'N': 900, 't_max': 20.0, 'v_2': 0.60, 'a': 0.30, 't_b': 0.80,\n         't_c': 3.00, 't_d': 8.00, 'D': 0.0300, 'sigma': 1.0e-2, 'seed': 13579},\n\n        # Case 4 (noisier data, moderate D)\n        {'N': 1400, 't_max': 120.0, 'v_2': 0.40, 'a': 0.25, 't_b': 0.30,\n         't_c': 2.50, 't_d': 10.0, 'D': 0.0150, 'sigma': 2.0e-2, 'seed': 11223},\n    ]\n\n    results = []\n    for params in test_cases:\n        t, msd = generate_msd_data(**params)\n        D_si = estimate_diffusion_coefficient(t, msd)\n        results.append(D_si)\n\n    # Format and print the final output exactly as required.\n    print(f\"[{','.join(f'{d:.2e}' for d in results)}]\")\n\ndef generate_msd_data(N, t_max, v_2, a, t_b, t_c, t_d, D, sigma, seed, t_min=1e-3):\n    \"\"\"\n    Generates synthetic MSD data based on the provided formula and parameters.\n    \"\"\"\n    np.random.seed(seed)\n    \n    t = np.linspace(t_min, t_max, N)\n    \n    # Ballistic term\n    msd_ballistic = v_2 * t**2 * np.exp(-(t / t_b)**2)\n    \n    # Caging term\n    msd_caging = a * (1 - np.exp(-(t / t_c)**2)) * np.exp(-(t / t_d)**2)\n    \n    # Diffusive term\n    msd_diffusive = 6 * D * t * (1 - np.exp(-(t / t_d)**2))\n    \n    msd_clean = msd_ballistic + msd_caging + msd_diffusive\n    \n    # Add Gaussian noise\n    noise = np.random.normal(0, sigma, N)\n    msd_noisy = msd_clean + noise\n    \n    # Clip non-positive values to prevent log(0) or log(<0) issues\n    msd = np.maximum(msd_noisy, 1e-12)\n    \n    return t, msd\n\ndef estimate_diffusion_coefficient(t, msd):\n    \"\"\"\n    Estimates the diffusion coefficient using a data-adaptive windowing method.\n    \"\"\"\n    N = len(t)\n    \n    # --- Step 1: Calculate local scaling exponent alpha(t) ---\n    # Use a sliding window to perform log-log fits for noise robustness.\n    # The chosen window size must be an odd integer.\n    alpha_window_size = 51 \n    half_window = alpha_window_size // 2\n    \n    alphas = np.full(N, np.nan)\n    \n    log_t = np.log(t)\n    log_msd = np.log(msd)\n    \n    for i in range(half_window, N - half_window):\n        # Define the window for the local fit\n        start, end = i - half_window, i + half_window + 1\n        \n        # polyfit(x, y, 1) returns [slope, intercept]\n        slope, _ = np.polyfit(log_t[start:end], log_msd[start:end], 1)\n        alphas[i] = slope\n\n    # --- Step 2: Identify candidate diffusive windows ---\n    alpha_tolerance = 0.1\n    min_window_frac = 0.1\n    min_len = int(min_window_frac * N)\n\n    # Find indices where alpha is close to 1\n    diffusive_indices = np.where(np.abs(alphas - 1.0) < alpha_tolerance)[0]\n\n    if len(diffusive_indices) == 0:\n        # Fallback if no window is found - this shouldn't happen with the test data\n        return np.nan\n\n    # Group consecutive indices into windows\n    candidate_windows = []\n    if len(diffusive_indices) > 0:\n        # Split a list of indices into sub-lists of consecutive numbers\n        splits = np.where(np.diff(diffusive_indices) != 1)[0] + 1\n        contiguous_blocks = np.split(diffusive_indices, splits)\n        \n        for block in contiguous_blocks:\n            if len(block) >= min_len:\n                candidate_windows.append(block)\n\n    if not candidate_windows:\n        # If no window meets the minimum length, try relaxing criteria (not done here as it's not needed for the given problem)\n        return np.nan # Or handle error appropriately\n\n    # --- Step 3: Select the best window ---\n    # Rule: Choose the longest window. If tied, choose the one latest in time.\n    best_window = max(candidate_windows, key=lambda w: (len(w), w[-1]))\n    \n    t_window = t[best_window]\n    msd_window = msd[best_window]\n\n    # --- Step 4: Perform robust linear regression ---\n    # Use Theil-Sen estimator on the selected window (MSD vs t)\n    # theilslopes returns (slope, intercept, low_slope, high_slope)\n    slope, _, _, _ = theilslopes(y=msd_window, x=t_window)\n    \n    # --- Step 5: Calculate D and convert units ---\n    # D_sim = slope / (2 * dimensions), here dimensions=3\n    D_sim = slope / 6.0  # units: nm^2 / ps\n    \n    # Conversion factor from nm^2/ps to m^2/s\n    # 1 nm^2/ps = (10^-9 m)^2 / (10^-12 s) = 10^-18 m^2 / 10^-12 s = 10^-6 m^2/s\n    conversion_factor = 1e-6\n    D_si = D_sim * conversion_factor # units: m^2 / s\n    \n    return D_si\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}