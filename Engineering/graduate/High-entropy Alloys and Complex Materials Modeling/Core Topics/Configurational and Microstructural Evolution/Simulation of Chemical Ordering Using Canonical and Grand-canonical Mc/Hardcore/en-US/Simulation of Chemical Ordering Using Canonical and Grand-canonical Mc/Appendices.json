{
    "hands_on_practices": [
        {
            "introduction": "Before we can simulate the complex dance of atoms in an alloy, we must first build the stage. This foundational practice  guides you through creating the geometric kernel of a simulation: generating the atomic positions for common crystal structures like body-centered cubic (BCC) and face-centered cubic (FCC). You will implement periodic boundary conditions to mimic an infinite bulk material and construct neighbor lists, which are essential for calculating the configurational energy based on a truncated cluster expansion.",
            "id": "3756504",
            "problem": "You are tasked with constructing a reusable geometric kernel for atomistic Monte Carlo simulation of chemical ordering in high-entropy alloys on face-centered cubic and body-centered cubic lattices. The kernel must generate periodic supercells, implement periodic boundary conditions using the minimum image convention, and build pairwise neighbor lists consistent with a prescribed cluster truncation by a radial cutoff. This kernel is a prerequisite for both canonical ensemble Monte Carlo and grand-canonical ensemble Monte Carlo sampling that use cluster expansions of the energy, where truncated pair clusters must be consistent with the underlying lattice geometry.\n\nStart only from the following fundamental definitions and facts:\n\n- A Bravais lattice is generated by integer linear combinations of three linearly independent vectors. For a cubic lattice with lattice parameter $a$, one may take primitive vectors $\\mathbf{a}_1 = a \\mathbf{e}_x$, $\\mathbf{a}_2 = a \\mathbf{e}_y$, $\\mathbf{a}_3 = a \\mathbf{e}_z$, where $\\mathbf{e}_x$, $\\mathbf{e}_y$, $\\mathbf{e}_z$ are unit vectors.\n- A supercell of linear dimensions $L_x \\times L_y \\times L_z$ repetitions of the conventional cubic unit cell has box lengths $L_x a$, $L_y a$, $L_z a$ along the Cartesian axes.\n- A body-centered cubic (BCC) lattice can be represented as a simple cubic Bravais lattice with a two-point basis at fractional coordinates $(0,0,0)$ and $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$ within the conventional cubic unit cell of edge $a$.\n- A face-centered cubic (FCC) lattice can be represented as a simple cubic Bravais lattice with a four-point basis at fractional coordinates $(0,0,0)$, $(0,\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,\\tfrac{1}{2})$, and $(\\tfrac{1}{2},\\tfrac{1}{2},0)$ within the conventional cubic unit cell of edge $a$.\n- Periodic boundary conditions require that distances are computed using the minimum image convention: for any displacement $\\Delta x$ along an axis with period $L a$, the minimum-image displacement is $\\Delta x' = \\Delta x - (L a) \\,\\mathrm{round}(\\Delta x/(L a))$. The same applies independently to each Cartesian component.\n\nDesign and implement a complete program that:\n\n1. Generates the Cartesian coordinates of all sites in a periodic supercell for either the BCC or FCC lattice. The supercell is defined by $(L_x, L_y, L_z)$ and lattice parameter $a$. The total number of sites is $N = n_b \\, L_x L_y L_z$, where $n_b$ is the number of basis points ($n_b = 2$ for BCC and $n_b = 4$ for FCC).\n2. Implements periodic boundary conditions using the minimum image convention. For any pair of sites $i$ and $j$ with positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$, compute the minimum-image displacement $\\Delta \\mathbf{r}_{ij}$ by applying the minimum image mapping to each Cartesian component using the box lengths $(L_x a, L_y a, L_z a)$. The squared distance is $\\|\\Delta \\mathbf{r}_{ij}\\|^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2$.\n3. Builds a pair neighbor list consistent with a cluster truncation specified by a radial cutoff $r_\\mathrm{cut}$. For each site $i$, include site $j \\neq i$ in $i$’s neighbor list if and only if $0  \\|\\Delta \\mathbf{r}_{ij}\\| \\le r_\\mathrm{cut}$, where $r_\\mathrm{cut}$ is strictly positive. Use a strict inequality for the lower bound to exclude self-pairs and a non-strict inequality for the upper bound (with a small numerical tolerance) to include neighbors up to the cutoff. You must not double-count pairs. Use only distances in units of $a$ (dimensionless).\n4. Computes the coordination number (number of neighbors) per site under the truncation and returns the unique coordination number (which should be the same for all sites for sufficiently large supercells with periodic boundary conditions).\n\nTest Suite and Required Outputs:\n\nUse the following five test cases. In all cases, the lattice parameter is $a = 1$ (dimensionless). For each case, compute the coordination number per site (an integer) under the given truncation, and then output the single integer result per case.\n\n- Case $1$: BCC lattice, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.9$.\n- Case $2$: BCC lattice, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$.\n- Case $3$: FCC lattice, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.72$.\n- Case $4$: FCC lattice, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$.\n- Case $5$: FCC lattice, $(L_x,L_y,L_z) = (2,3,4)$, $r_\\mathrm{cut} = 0.72$.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the five coordination numbers for the test cases above, as a comma-separated list enclosed in square brackets, for example, $\\texttt{[n_1,n_2,n_3,n_4,n_5]}$, where each $n_k$ is an integer.\n\nConstraints and clarifications:\n\n- All computations are purely geometric and dimensionless; no physical units are required.\n- Angles are not required.\n- Ensure numerical robustness by using a small tolerance $\\epsilon$ when comparing $\\|\\Delta \\mathbf{r}_{ij}\\|$ to $r_\\mathrm{cut}$, where $\\epsilon$ is a small positive floating-point number (for example, $\\epsilon = 10^{-12}$). The final counts must not depend sensitively on $\\epsilon$ so long as it is sufficiently small.\n- The implementation must be general for arbitrary positive integers $L_x$, $L_y$, $L_z$, and for both BCC and FCC lattices as defined above.",
            "solution": "### Step 1: Extract Givens\n\n- **Bravais Lattice Definition**: Generated by integer linear combinations of three linearly independent primitive vectors. For a cubic lattice with lattice parameter $a$, primitive vectors can be taken as $\\mathbf{a}_1 = a \\mathbf{e}_x$, $\\mathbf{a}_2 = a \\mathbf{e}_y$, $\\mathbf{a}_3 = a \\mathbf{e}_z$.\n- **Supercell Definition**: A supercell of $L_x \\times L_y \\times L_z$ repetitions of the conventional cubic unit cell has box lengths $L_x a$, $L_y a$, $L_z a$.\n- **Body-Centered Cubic (BCC) Lattice**: A simple cubic Bravais lattice with a two-point basis at fractional coordinates $(0,0,0)$ and $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$ within a conventional cubic unit cell of edge $a$.\n- **Face-Centered Cubic (FCC) Lattice**: A simple cubic Bravais lattice with a four-point basis at fractional coordinates $(0,0,0)$, $(0,\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,\\tfrac{1}{2})$, and $(\\tfrac{1}{2},\\tfrac{1}{2},0)$ within a conventional cubic unit cell of edge $a$.\n- **Periodic Boundary Conditions (PBC)**: Distances are computed using the minimum image convention (MIC). For a displacement $\\Delta x$ along an axis with period $L a$, the minimum-image displacement is $\\Delta x' = \\Delta x - (L a) \\,\\mathrm{round}(\\Delta x/(L a))$. This applies independently to each Cartesian component.\n- **Total Number of Sites, $N$**: $N = n_b \\, L_x L_y L_z$, where $n_b$ is the number of basis points ($n_b=2$ for BCC, $n_b=4$ for FCC).\n- **Squared Distance under MIC**: $\\|\\Delta \\mathbf{r}_{ij}\\|^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2$.\n- **Neighbor List Condition**: Site $j \\neq i$ is a neighbor of site $i$ if and only if $0  \\|\\Delta \\mathbf{r}_{ij}\\| \\le r_\\mathrm{cut}$, where $r_\\mathrm{cut}  0$.\n- **Units and Constants**: All calculations are in units of $a$. The lattice parameter is set to $a = 1$.\n- **Numerical Tolerance**: A small tolerance $\\epsilon$ (e.g., $10^{-12}$) should be used for floating-point comparisons.\n- **Test Suite**:\n    - Case $1$: BCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.9$.\n    - Case $2$: BCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$.\n    - Case $3$: FCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.72$.\n    - Case $4$: FCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$.\n    - Case $5$: FCC, $(L_x,L_y,L_z) = (2,3,4)$, $r_\\mathrm{cut} = 0.72$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientific Grounding**: The problem is fundamentally sound. The definitions provided for BCC and FCC lattices, supercells, periodic boundary conditions, and the minimum image convention are standard and correct within the fields of solid-state physics and computational materials science. The overall task is a standard prerequisite for atomistic simulations.\n- **Well-Posedness**: The problem is well-posed. It provides a complete set of inputs (lattice types, supercell dimensions, cutoff radii) and a deterministic, algorithmic procedure for computing the desired output (coordination numbers). For a given set of parameters, the solution is unique and stable.\n- **Objectivity**: The problem is stated using precise, unambiguous, and objective language common to physics and computer science. There are no subjective or opinion-based components.\n- **Completeness and Consistency**: The problem is self-contained. All necessary definitions, constraints, and data are explicitly provided. The use of dimensionless units by setting $a=1$ is a standard and consistent simplification. There are no internal contradictions.\n- **Feasibility**: The specified computations are not only feasible but are standard exercises in setting up atomistic simulations. The supercell sizes and number of test cases are small, making the computational cost negligible.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-defined, scientifically sound problem in computational physics. A solution can be constructed based on the provided specifications.\n\n---\n\n### Solution\n\nThe task is to construct a geometric kernel for atomistic simulations, capable of generating periodic supercells for BCC and FCC lattices and computing coordination numbers based on a radial cutoff. The solution is developed in three stages: supercell generation, implementation of periodic boundary conditions, and neighbor list construction. For all calculations, the lattice parameter $a$ is taken to be $1$, making all coordinates and distances dimensionless.\n\n#### 1. Supercell Generation\n\nA periodic supercell is constructed by replicating a conventional unit cell $L_x$, $L_y$, and $L_z$ times along the Cartesian axes $\\mathbf{e}_x$, $\\mathbf{e}_y$, and $\\mathbf{e}_z$. The simulation box vectors are $\\mathbf{L}_1 = L_x a \\mathbf{e}_x$, $\\mathbf{L}_2 = L_y a \\mathbf{e}_y$, and $\\mathbf{L}_3 = L_z a \\mathbf{e}_z$.\n\nThe positions of all sites in the supercell are generated by placing the basis atoms of the crystal structure at each point of a simple cubic grid spanning the supercell. A grid point $\\mathbf{R}_{n_x,n_y,n_z}$ is defined by integer indices $(n_x, n_y, n_z)$ where $0 \\le n_x  L_x$, $0 \\le n_y  L_y$, and $0 \\le n_z  L_z$. The Cartesian position of this grid point is:\n$$\n\\mathbf{R}_{n_x,n_y,n_z} = n_x a \\mathbf{e}_x + n_y a \\mathbf{e}_y + n_z a \\mathbf{e}_z\n$$\nFor a given lattice type (BCC or FCC) with a set of $n_b$ basis vectors $\\{\\mathbf{b}_k\\}$ (expressed in Cartesian coordinates), the position of a site is given by adding a basis vector to a grid point position:\n$$\n\\mathbf{r}_{n_x,n_y,n_z,k} = \\mathbf{R}_{n_x,n_y,n_z} + \\mathbf{b}_k\n$$\nWith $a=1$, the basis vectors are:\n- For BCC ($n_b=2$):\n  $$\n  \\mathbf{b}_1 = (0, 0, 0) \\quad , \\quad \\mathbf{b}_2 = (1/2, 1/2, 1/2)\n  $$\n- For FCC ($n_b=4$):\n  $$\n  \\mathbf{b}_1 = (0, 0, 0) \\quad , \\quad \\mathbf{b}_2 = (0, 1/2, 1/2) \\quad , \\quad \\mathbf{b}_3 = (1/2, 0, 1/2) \\quad , \\quad \\mathbf{b}_4 = (1/2, 1/2, 0)\n  $$\nThe total number of sites in the supercell is $N = n_b L_x L_y L_z$. The algorithm generates an array of $N$ position vectors, each being a $3$-dimensional Cartesian coordinate.\n\n#### 2. Minimum Image Convention (MIC)\n\nPeriodic boundary conditions are imposed to model an infinite bulk material. The distance between two sites $\\mathbf{r}_i$ and $\\mathbf{r}_j$ is the shortest distance between $\\mathbf{r}_i$ and any of the infinite periodic images of $\\mathbf{r}_j$. The minimum image convention provides a direct method for calculating the displacement vector corresponding to this shortest distance.\n\nGiven a raw displacement vector $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i = (\\Delta x, \\Delta y, \\Delta z)$ and a simulation box of side lengths $\\mathbf{L} = (L_x a, L_y a, L_z a)$, the minimum image displacement vector $\\Delta\\mathbf{r}' = (\\Delta x', \\Delta y', \\Delta z')$ is computed component-wise. For the $x$-component:\n$$\n\\Delta x' = \\Delta x - (L_x a) \\cdot \\mathrm{round}\\left( \\frac{\\Delta x}{L_x a} \\right)\n$$\nwhere `round()` is the function that rounds to the nearest integer. Analogous expressions apply to $\\Delta y'$ and $\\Delta z'$. This ensures that each component of the resulting displacement vector has a magnitude no larger than half the box length in that direction (i.e., $|\\Delta x'| \\le \\frac{L_x a}{2}$).\n\nThe squared Euclidean distance between the two sites under PBC is then:\n$$\nd_{ij}^2 = \\|\\Delta\\mathbf{r}'\\|^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2\n$$\n\n#### 3. Neighbor List and Coordination Number\n\nA neighbor list for a site $i$ contains all other sites $j$ within a specified cutoff radius $r_\\mathrm{cut}$. Based on the problem statement, site $j$ is a neighbor of site $i$ if its minimum image distance $d_{ij}$ satisfies $0  d_{ij} \\le r_\\mathrm{cut}$. This can be more efficiently checked using squared distances to avoid computationally expensive square root operations: $0  d_{ij}^2 \\le r_\\mathrm{cut}^2$.\n\nThe algorithm proceeds as follows:\n1. Initialize a coordination number array, `coord`, of size $N$ to all zeros.\n2. Iterate through all unique pairs of sites $(i, j)$ where $0 \\le i  j  N$. This avoids double-counting pairs and evaluating self-pairs (where $i=j$ and $d_{ij}=0$).\n3. For each pair $(\\mathbf{r}_i, \\mathbf{r}_j)$, compute the squared minimum image distance $d_{ij}^2$.\n4. Check if $d_{ij}^2 \\le r_\\mathrm{cut}^2$. A small numerical tolerance $\\epsilon$ (e.g., $10^{-9}$) is added to the comparison to handle floating-point inaccuracies, leading to the check $d_{ij}^2 \\le r_\\mathrm{cut}^2 + \\epsilon$.\n5. If the condition is met, increment the coordination counts for both sites: `coord[i]` and `coord[j]` are incremented by $1$.\n\nDue to the translational symmetry of the perfect crystalline lattice, every site is crystallographically equivalent. Therefore, every site must have the same coordination number for a given $r_\\mathrm{cut}$. After iterating through all pairs, the algorithm verifies that all elements in the `coord` array are identical and returns this unique integer value.\n\nFor the provided test cases, the theoretical nearest-neighbor (NN) distances for $a=1$ are:\n- **BCC**: $1^{\\text{st}}$ NN shell at $d = \\sqrt{(1/2)^2 + (1/2)^2 + (1/2)^2} = \\sqrt{3}/2 \\approx 0.866$. $2^{\\text{nd}}$ NN shell at $d = \\sqrt{1^2} = 1.0$.\n- **FCC**: $1^{\\text{st}}$ NN shell at $d = \\sqrt{(1/2)^2 + (1/2)^2} = 1/\\sqrt{2} \\approx 0.707$. $2^{\\text{nd}}$ NN shell at $d = \\sqrt{1^2} = 1.0$.\n\nBased on these distances, the expected outcomes are:\n- Case 1 (BCC, $r_\\mathrm{cut} = 0.9$): Includes only the $1^{\\text{st}}$ NN shell ($8$ neighbors) since $0.866  0.9  1.0$.\n- Case 2 (BCC, $r_\\mathrm{cut} = 1.01$): Includes $1^{\\text{st}}$ and $2^{\\text{nd}}$ NN shells ($8+6=14$ neighbors) since $1.0  1.01$.\n- Case 3 (FCC, $r_\\mathrm{cut} = 0.72$): Includes only the $1^{\\text{st}}$ NN shell ($12$ neighbors) since $0.707  0.72  1.0$.\n- Case 4 (FCC, $r_\\mathrm{cut} = 1.01$): Includes $1^{\\text{st}}$ and $2^{\\text{nd}}$ NN shells ($12+6=18$ neighbors) since $1.0  1.01$.\n- Case 5 (FCC, $r_\\mathrm{cut} = 0.72$): Identical local environment to Case 3, expecting $12$ neighbors, as the supercell is large enough in all dimensions to contain the first neighbor shell.\nThe implementation must reproduce these integer results.",
            "answer": "```python\nimport numpy as np\n\nclass GeometricKernel:\n    \"\"\"\n    A geometric kernel for atomistic Monte Carlo simulation.\n\n    Generates periodic supercells for BCC and FCC lattices, applies\n    periodic boundary conditions using the minimum image convention,\n    and computes coordination numbers based on a radial cutoff.\n    \"\"\"\n    def __init__(self, lattice_type: str, L: tuple, a: float = 1.0):\n        \"\"\"\n        Initializes the geometric kernel.\n\n        Args:\n            lattice_type (str): The crystal lattice type, either \"BCC\" or \"FCC\".\n            L (tuple): A tuple of 3 integers (Lx, Ly, Lz) defining the\n                       supercell dimensions in units of conventional cells.\n            a (float): The lattice parameter.\n        \"\"\"\n        if lattice_type not in [\"BCC\", \"FCC\"]:\n            raise ValueError(\"lattice_type must be either 'BCC' or 'FCC'\")\n        \n        self.lattice_type = lattice_type\n        self.L = np.array(L, dtype=int)\n        self.a = float(a)\n        self.box_dims = self.L * self.a\n        \n        self.sites = self._generate_sites()\n        self.N = self.sites.shape[0]\n        \n    def _generate_sites(self) - np.ndarray:\n        \"\"\"\n        Generates the Cartesian coordinates of all sites in the supercell.\n\n        Returns:\n            np.ndarray: An array of shape (N, 3) containing the site coordinates.\n        \"\"\"\n        if self.lattice_type == \"BCC\":\n            basis = np.array([[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]]) * self.a\n        else:  # FCC\n            basis = np.array([[0.0, 0.0, 0.0],\n                              [0.0, 0.5, 0.5],\n                              [0.5, 0.0, 0.5],\n                              [0.5, 0.5, 0.0]]) * self.a\n\n        # Create a grid of lattice points for the supercell\n        nx, ny, nz = np.mgrid[0:self.L[0], 0:self.L[1], 0:self.L[2]]\n        grid_points = np.vstack([nx.ravel(), ny.ravel(), nz.ravel()]).T * self.a\n        \n        # Combine grid points with basis vectors using broadcasting\n        # grid_points shape: (num_grid_points, 3) - (1, num_grid_points, 3)\n        # basis shape: (num_basis, 3) - (num_basis, 1, 3)\n        # Resulting shape after addition: (num_basis, num_grid_points, 3)\n        all_sites = grid_points[np.newaxis, :, :] + basis[:, np.newaxis, :]\n        \n        # Reshape to a flat list of sites (N, 3)\n        num_sites = self.L[0] * self.L[1] * self.L[2] * basis.shape[0]\n        return all_sites.reshape(num_sites, 3)\n\n    def _minimum_image_disp(self, r_i: np.ndarray, r_j: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the minimum image displacement vector between two sites.\n\n        Args:\n            r_i (np.ndarray): Position vector of site i.\n            r_j (np.ndarray): Position vector of site j.\n\n        Returns:\n            np.ndarray: The minimum image displacement vector from i to j.\n        \"\"\"\n        delta = r_j - r_i\n        # Apply minimum image convention using the provided formula\n        return delta - self.box_dims * np.round(delta / self.box_dims)\n\n    def get_coordination_number(self, r_cut: float, epsilon: float = 1e-9) - int:\n        \"\"\"\n        Computes the coordination number for each site up to a cutoff radius.\n\n        Args:\n            r_cut (float): The radial cutoff for neighbor searching.\n            epsilon (float): Small tolerance for floating point comparisons.\n\n        Returns:\n            int: The unique coordination number for all sites in the lattice.\n        \"\"\"\n        r_cut_sq = r_cut**2\n        coord_numbers = np.zeros(self.N, dtype=int)\n\n        for i in range(self.N):\n            for j in range(i + 1, self.N):\n                # Calculate displacement and squared distance using MIC\n                disp = self._minimum_image_disp(self.sites[i], self.sites[j])\n                dist_sq = np.dot(disp, disp)\n                \n                # Check if the pair is within the cutoff radius.\n                # The condition 0  d_ij is implicitly handled by j  i.\n                # The condition d_ij = r_cut is checked as d_ij^2 = r_cut^2.\n                # A small tolerance epsilon is used for robust floating point comparison.\n                if dist_sq = r_cut_sq + epsilon:\n                    coord_numbers[i] += 1\n                    coord_numbers[j] += 1\n        \n        # In a perfect periodic lattice, all sites are equivalent\n        # and should have the same coordination number.\n        unique_cn = np.unique(coord_numbers)\n        if len(unique_cn) != 1:\n            # This should not happen for a sufficiently large supercell\n            raise RuntimeError(f\"Inconsistent coordination numbers found: {unique_cn}\")\n            \n        return int(unique_cn[0])\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Format: (lattice_type, (Lx, Ly, Lz), r_cut)\n    test_cases = [\n        (\"BCC\", (3, 3, 3), 0.9),\n        (\"BCC\", (3, 3, 3), 1.01),\n        (\"FCC\", (3, 3, 3), 0.72),\n        (\"FCC\", (3, 3, 3), 1.01),\n        (\"FCC\", (2, 3, 4), 0.72),\n    ]\n\n    results = []\n    for lattice_type, L, r_cut in test_cases:\n        # For all cases, the problem specifies a dimensionless lattice parameter a=1.\n        kernel = GeometricKernel(lattice_type=lattice_type, L=L, a=1.0)\n        cn = kernel.get_coordination_number(r_cut=r_cut)\n        results.append(cn)\n\n    # Print the final results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a digital lattice constructed, we can now simulate the atomic processes that drive chemical ordering. This exercise  focuses on the heart of the Monte Carlo method: the trial move. You will calculate the change in energy, $\\Delta E$, resulting from a proposed atomic transmutation and use this to determine the acceptance probability based on the Metropolis criterion, exploring its application in both the canonical and grand-canonical ensembles.",
            "id": "3756606",
            "problem": "Consider a multi-component alloy on a two-dimensional periodic square lattice of size $N \\times N$ whose configurational energy is represented by a cluster expansion. The cluster expansion energy is defined as $E(\\sigma) = \\sum_{\\alpha} J_{\\alpha} \\Phi_{\\alpha}(\\sigma)$, where $\\sigma$ denotes the configuration (species at each lattice site), $J_{\\alpha}$ are Density Functional Theory (DFT)-calibrated Effective Cluster Interactions (ECIs), and $\\Phi_{\\alpha}(\\sigma)$ are cluster functions for a cluster $\\alpha$. Assume only local clusters centered around the site being transmuted contribute to the energy change. In this problem, you will use nearest-neighbor point and pair clusters to compute the energy change for a proposed transmutation at a single site.\n\nFundamental base and assumptions to use:\n- The configurational energy $E(\\sigma)$ is represented by a finite cluster expansion truncated to point and nearest-neighbor pair clusters on a square lattice with periodic boundary conditions.\n- Nearest neighbors are defined by Manhattan distance $1$ (up, down, left, right).\n- The canonical-ensemble Metropolis acceptance probability is $p_{\\text{can}} = \\min\\left(1, \\exp(-\\beta \\Delta E)\\right)$ with $\\beta = 1/(k_{\\mathrm{B}} T)$, where $k_{\\mathrm{B}}$ is Boltzmann's constant and $T$ is temperature.\n- The grand-canonical-ensemble acceptance probability is $p_{\\text{gc}} = \\min\\left(1, \\exp\\left[-\\beta \\left(\\Delta E - \\sum_{s} \\mu_{s} \\Delta N_{s}\\right)\\right]\\right)$, where $\\mu_{s}$ is the chemical potential of species $s$ and $\\Delta N_{s}$ is the change in the number of species $s$ induced by the proposed transmutation. For a single-site transmutation from species $s_{\\text{old}}$ to species $s_{\\text{new}}$, $\\Delta N_{s_{\\text{new}}} = +1$, $\\Delta N_{s_{\\text{old}}} = -1$, and all other $\\Delta N_{s} = 0$, so that $\\Delta E_{\\text{eff}} = \\Delta E - (\\mu_{s_{\\text{new}}} - \\mu_{s_{\\text{old}}})$.\n- Boltzmann constant $k_{\\mathrm{B}}$ must be used in electronvolt per Kelvin units: $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ eV/K.\n\nDefinitions of the cluster functions used:\n- Point cluster contribution at site $i$: an energy assigned per species, with ECI vector $\\mathbf{J}^{\\text{point}}$ such that the contribution equals $J^{\\text{point}}_{\\sigma_{i}}$.\n- Pair cluster contribution for a nearest-neighbor pair $(i,j)$: an energy assigned per ordered pair of species, with ECI matrix $J^{\\text{pair}}_{a,b}$ that is symmetric in $a$ and $b$; the contribution equals $J^{\\text{pair}}_{\\sigma_{i},\\sigma_{j}}$.\n\nTask:\n- For each test case, compute the energy change $\\Delta E$ (in electronvolts) resulting from a proposed transmutation at a single site using only local point and nearest-neighbor pair cluster contributions involving the transmuted site. Use periodic boundary conditions on the lattice edges. Then compute the canonical acceptance probability $p_{\\text{can}}$ and the grand-canonical acceptance probability $p_{\\text{gc}}$ at the specified temperature and chemical potentials.\n\nSpecies mapping:\n- Use three species labeled $A, B, C$ mapped to integers $0, 1, 2$ respectively.\n\nUnits and numerical output requirements:\n- Express $\\Delta E$ in electronvolts (eV).\n- Express acceptance probabilities $p_{\\text{can}}$ and $p_{\\text{gc}}$ as decimals.\n- Round all outputs to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets. Each inner list must be of the form $[\\Delta E, p_{\\text{can}}, p_{\\text{gc}}]$ for one test case, with values rounded to six decimal places. For example, the format is $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],\\ldots]$.\n\nTest suite:\n- All indices below are zero-based $(0 \\leq i,j  N)$.\n\n1) Happy path case (nontrivial neighborhood, mixed species):\n- Lattice size: $N = 4$.\n- Configuration $\\sigma$ (grid of species integers):\n$$\n\\begin{bmatrix}\n0  1  2  0 \\\\\n1  0  1  2 \\\\\n2  1  0  1 \\\\\n0  2  1  0\n\\end{bmatrix}\n$$\n- Transmutation site: $(i,j) = (0,1)$.\n- Proposed transmutation: $B \\to C$ (old species $1$, new species $2$).\n- Point ECIs (in eV): $\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$.\n- Pair ECIs (in eV), symmetric matrix $J^{\\text{pair}}$:\n$$\n\\begin{bmatrix}\n0.00  0.02  -0.01 \\\\\n0.02  0.00  0.015 \\\\\n-0.01  0.015  0.00\n\\end{bmatrix}\n$$\n- Temperature: $T = 1000$ K.\n- Chemical potentials (in eV): $\\boldsymbol{\\mu} = [0.10, \\ 0.00, \\ -0.02]$.\n\n2) Boundary condition (no change move):\n- Lattice size: $N = 3$.\n- Configuration $\\sigma$:\n$$\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n- Transmutation site: $(i,j) = (1,1)$.\n- Proposed transmutation: $A \\to A$ (old species $0$, new species $0$).\n- Point ECIs (in eV): $\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$.\n- Pair ECIs (in eV), symmetric matrix $J^{\\text{pair}}$:\n$$\n\\begin{bmatrix}\n0.00  0.02  -0.01 \\\\\n0.02  0.00  0.015 \\\\\n-0.01  0.015  0.00\n\\end{bmatrix}\n$$\n- Temperature: $T = 500$ K.\n- Chemical potentials (in eV): $\\boldsymbol{\\mu} = [0.0, \\ 0.0, \\ 0.0]$.\n\n3) Edge case (strongly favorable interaction with surrounding species):\n- Lattice size: $N = 4$.\n- Configuration $\\sigma$:\n$$\n\\begin{bmatrix}\n2  2  2  2 \\\\\n2  1  1  2 \\\\\n2  1  0  2 \\\\\n2  2  2  2\n\\end{bmatrix}\n$$\n- Transmutation site: $(i,j) = (1,2)$.\n- Proposed transmutation: $B \\to A$ (old species $1$, new species $0$).\n- Point ECIs (in eV): $\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$.\n- Pair ECIs (in eV), symmetric matrix $J^{\\text{pair}}$:\n$$\n\\begin{bmatrix}\n0.00  0.01  -0.08 \\\\\n0.01  0.00  0.02 \\\\\n-0.08  0.02  0.00\n\\end{bmatrix}\n$$\n- Temperature: $T = 300$ K.\n- Chemical potentials (in eV): $\\boldsymbol{\\mu} = [0.0, \\ 0.0, \\ 0.0]$.\n\n4) Grand-canonical penalty (chemical potential disfavors new species):\n- Lattice size: $N = 4$.\n- Configuration $\\sigma$:\n$$\n\\begin{bmatrix}\n0  1  0  2 \\\\\n1  2  1  0 \\\\\n0  1  2  1 \\\\\n2  0  1  0\n\\end{bmatrix}\n$$\n- Transmutation site: $(i,j) = (0,0)$.\n- Proposed transmutation: $A \\to B$ (old species $0$, new species $1$).\n- Point ECIs (in eV): $\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$.\n- Pair ECIs (in eV), symmetric matrix $J^{\\text{pair}}$:\n$$\n\\begin{bmatrix}\n0.00  0.02  -0.01 \\\\\n0.02  0.00  0.015 \\\\\n-0.01  0.015  0.00\n\\end{bmatrix}\n$$\n- Temperature: $T = 800$ K.\n- Chemical potentials (in eV): $\\boldsymbol{\\mu} = [0.0, \\ -0.30, \\ 0.0]$.\n\nYour program must compute, for each test case, the triplet $[\\Delta E, p_{\\text{can}}, p_{\\text{gc}}]$ and produce a single line of output in the exact format described above. All energies must be in electronvolts (eV), and all probabilities must be decimals. Round every number to six decimal places.",
            "solution": "The problem is assessed to be valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It describes a standard computational task in materials modeling based on fundamental principles of statistical mechanics and solid-state physics.\n\nThe core of the problem is to compute the change in configurational energy, $\\Delta E$, for a single-site transmutation in a multi-component alloy on a two-dimensional square lattice, and subsequently to calculate the Metropolis acceptance probabilities for this move in both the canonical and grand-canonical ensembles. The configurational energy $E(\\sigma)$ of the system for a given configuration $\\sigma$ (an assignment of species to each lattice site) is defined by a cluster expansion model. The problem states that the expansion is truncated to include only point and nearest-neighbor pair interactions.\n\nThe energy of a configuration $\\sigma$ is given by:\n$$ E(\\sigma) = \\sum_{i} E_{i}^{\\text{point}} + \\sum_{\\langle i, j \\rangle} E_{i,j}^{\\text{pair}} $$\nwhere the first sum is over all lattice sites $i$, and the second sum is over all unique nearest-neighbor pairs $\\langle i, j \\rangle$. The point energy at site $i$ depends on the species $\\sigma_i$ at that site, $E_{i}^{\\text{point}} = J^{\\text{point}}_{\\sigma_i}$. The pair energy for the pair of sites $(i,j)$ depends on the species at those sites, $E_{i,j}^{\\text{pair}} = J^{\\text{pair}}_{\\sigma_i, \\sigma_j}$.\n\nWe are tasked with calculating the change in energy, $\\Delta E = E_{\\text{final}} - E_{\\text{initial}}$, when the species at a single site $k$ is transmuted from an old species, $s_{\\text{old}}$, to a new species, $s_{\\text{new}}$. According to the problem statement, we only need to consider the local clusters centered on the transmuted site $k$. This is because only the energy terms involving site $k$ will change. The change consists of two parts:\n$1$. The change in the point energy at site $k$.\n$2$. The change in the pair energies for all pairs involving site $k$.\n\nThe change in the point energy is:\n$$ \\Delta E_{\\text{point}} = J^{\\text{point}}_{s_{\\text{new}}} - J^{\\text{point}}_{s_{\\text{old}}} $$\n\nThe site $k$ has four nearest neighbors on a two-dimensional square lattice. Let the set of nearest-neighbor sites to $k$ be denoted by $\\mathcal{N}(k)$. The change in the pair energy contributions is the sum of changes for each pair $(k, j)$ where $j \\in \\mathcal{N}(k)$:\n$$ \\Delta E_{\\text{pair}} = \\sum_{j \\in \\mathcal{N}(k)} \\left( J^{\\text{pair}}_{s_{\\text{new}}, \\sigma_{j}} - J^{\\text{pair}}_{s_{\\text{old}}, \\sigma_{j}} \\right) $$\nwhere $\\sigma_j$ is the species at the neighboring site $j$.\n\nThe total change in configurational energy is the sum of these two contributions:\n$$ \\Delta E = \\Delta E_{\\text{point}} + \\Delta E_{\\text{pair}} $$\n\nThe lattice is periodic, so for a site at coordinates $(i, j)$ on an $N \\times N$ grid (with $0$-based indexing), its four nearest neighbors are at coordinates:\n- Up: $((i - 1 + N) \\pmod N, j)$\n- Down: $((i + 1) \\pmod N, j)$\n- Left: $(i, (j - 1 + N) \\pmod N)$\n- Right: $(i, (j + 1) \\pmod N)$\n\nOnce $\\Delta E$ is computed, we can determine the acceptance probabilities. The thermal energy is given by $k_{\\mathrm{B}}T$, where $k_{\\mathrm{B}}$ is the Boltzmann constant, given as $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ eV/K. We define the inverse temperature $\\beta = 1 / (k_{\\mathrm{B}}T)$.\n\nThe canonical-ensemble acceptance probability, $p_{\\text{can}}$, is given by the Metropolis criterion:\n$$ p_{\\text{can}} = \\min\\left(1, \\exp(-\\beta \\Delta E)\\right) $$\nIf $\\Delta E \\leq 0$, the move is always accepted ($p_{\\text{can}} = 1$). If $\\Delta E  0$, the move is accepted with a probability less than $1$, penalizing energetically unfavorable changes.\n\nIn the grand-canonical ensemble, the acceptance probability, $p_{\\text{gc}}$, depends on an effective energy change, $\\Delta E_{\\text{eff}}$, which includes the work done to change the particle numbers against the chemical potentials $\\mu_s$. For a transmutation from $s_{\\text{old}}$ to $s_{\\text{new}}$, the number of atoms of species $s_{\\text{new}}$ increases by one ($\\Delta N_{s_{\\text{new}}} = +1$) and the number of atoms of species $s_{\\text{old}}$ decreases by one ($\\Delta N_{s_{\\text{old}}} = -1$). The change in the grand potential is $\\Delta \\Omega = \\Delta E - \\sum_s \\mu_s \\Delta N_s$. This simplifies to:\n$$ \\Delta E_{\\text{eff}} = \\Delta E - (\\mu_{s_{\\text{new}}} - \\mu_{s_{\\text{old}}}) $$\nThe grand-canonical acceptance probability is then:\n$$ p_{\\text{gc}} = \\min\\left(1, \\exp(-\\beta \\Delta E_{\\text{eff}})\\right) $$\n\nThe algorithm to solve each test case\nis as follows:\n$1$. Identify the old species, $s_{\\text{old}}$, and new species, $s_{\\text{new}}$, for the transmutation at site $(i,j)$.\n$2$. Determine the species of the four nearest neighbors of site $(i,j)$, applying periodic boundary conditions.\n$3$. Calculate $\\Delta E_{\\text{point}} = J^{\\text{point}}_{s_{\\text{new}}} - J^{\\text{point}}_{s_{\\text{old}}}$.\n$4$. Calculate $\\Delta E_{\\text{pair}}$ by summing the changes $J^{\\text{pair}}_{s_{\\text{new}}, \\sigma_j} - J^{\\text{pair}}_{s_{\\text{old}}, \\sigma_j}$ over the four neighbors.\n$5$. Compute the total energy change $\\Delta E = \\Delta E_{\\text{point}} + \\Delta E_{\\text{pair}}$.\n$6$. Calculate $\\beta = 1 / (k_{\\mathrm{B}}T)$.\n$7$. Calculate $p_{\\text{can}} = \\min(1, \\exp(-\\beta \\Delta E))$.\n$8$. Calculate $\\Delta E_{\\text{eff}} = \\Delta E - (\\mu_{s_{\\text{new}}} - \\mu_{s_{\\text{old}}})$.\n$9$. Calculate $p_{\\text{gc}} = \\min(1, \\exp(-\\beta \\Delta E_{\\text{eff}}))$.\n$10$. Round the results for $\\Delta E$, $p_{\\text{can}}$, and $p_{\\text{gc}}$ to six decimal places.\n\nThis procedure will be applied to each test case provided in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the energy change and acceptance probabilities for single-site\n    transmutations in a 2D lattice model of a multi-component alloy.\n    \"\"\"\n    k_B = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    test_cases = [\n        {\n            \"N\": 4,\n            \"sigma\": np.array([\n                [0, 1, 2, 0],\n                [1, 0, 1, 2],\n                [2, 1, 0, 1],\n                [0, 2, 1, 0]\n            ]),\n            \"site\": (0, 1),\n            \"transmutation\": (1, 2),  # old - new\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.02, -0.01],\n                [0.02, 0.00, 0.015],\n                [-0.01, 0.015, 0.00]\n            ]),\n            \"T\": 1000.0,\n            \"mu\": np.array([0.10, 0.00, -0.02])\n        },\n        {\n            \"N\": 3,\n            \"sigma\": np.array([\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"site\": (1, 1),\n            \"transmutation\": (0, 0),\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.02, -0.01],\n                [0.02, 0.00, 0.015],\n                [-0.01, 0.015, 0.00]\n            ]),\n            \"T\": 500.0,\n            \"mu\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"N\": 4,\n            \"sigma\": np.array([\n                [2, 2, 2, 2],\n                [2, 1, 1, 2],\n                [2, 1, 0, 2],\n                [2, 2, 2, 2]\n            ]),\n            \"site\": (1, 2),\n            \"transmutation\": (1, 0),\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.01, -0.08],\n                [0.01, 0.00, 0.02],\n                [-0.08, 0.02, 0.00]\n            ]),\n            \"T\": 300.0,\n            \"mu\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"N\": 4,\n            \"sigma\": np.array([\n                [0, 1, 0, 2],\n                [1, 2, 1, 0],\n                [0, 1, 2, 1],\n                [2, 0, 1, 0]\n            ]),\n            \"site\": (0, 0),\n            \"transmutation\": (0, 1),\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.02, -0.01],\n                [0.02, 0.00, 0.015],\n                [-0.01, 0.015, 0.00]\n            ]),\n            \"T\": 800.0,\n            \"mu\": np.array([0.0, -0.30, 0.0])\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        sigma = case[\"sigma\"]\n        i, j = case[\"site\"]\n        s_old, s_new = case[\"transmutation\"]\n        J_point = case[\"J_point\"]\n        J_pair = case[\"J_pair\"]\n        T = case[\"T\"]\n        mu = case[\"mu\"]\n\n        # No change in energy or species count if old == new\n        if s_old == s_new:\n            delta_E = 0.0\n            p_can = 1.0\n            p_gc = 1.0\n            all_results.append(f\"[{delta_E:.6f},{p_can:.6f},{p_gc:.6f}]\")\n            continue\n\n        # 1. Identify nearest neighbors with periodic boundary conditions\n        neighbors_pos = [\n            ((i - 1 + N) % N, j),  # Up\n            ((i + 1) % N, j),      # Down\n            (i, (j - 1 + N) % N),  # Left\n            (i, (j + 1) % N)       # Right\n        ]\n        neighbor_species = [sigma[pos] for pos in neighbors_pos]\n\n        # 2. Calculate energy change delta_E\n        # Point energy change\n        delta_E_point = J_point[s_new] - J_point[s_old]\n\n        # Pair energy change\n        delta_E_pair = 0.0\n        for s_neighbor in neighbor_species:\n            delta_E_pair += J_pair[s_new, s_neighbor] - J_pair[s_old, s_neighbor]\n        \n        delta_E = delta_E_point + delta_E_pair\n\n        # 3. Calculate acceptance probabilities\n        if T == 0:\n            # Handle T=0 case to avoid division by zero, although not in tests\n            beta = float('inf')\n        else:\n            beta = 1.0 / (k_B * T)\n\n        # Canonical acceptance probability\n        p_can = min(1.0, np.exp(-beta * delta_E))\n\n        # Grand-canonical acceptance probability\n        delta_mu = mu[s_new] - mu[s_old]\n        delta_E_eff = delta_E - delta_mu\n        p_gc = min(1.0, np.exp(-beta * delta_E_eff))\n\n        all_results.append(f\"[{delta_E:.6f},{p_can:.6f},{p_gc:.6f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Running a full Monte Carlo simulation to equilibrium can be computationally demanding. To maximize the value of our simulation data, we can use powerful analysis techniques like histogram reweighting . This hands-on practice demonstrates how to use data from a simulation at one temperature to accurately predict thermodynamic properties, such as the degree of order, at nearby temperatures, effectively amplifying the scientific insight gained from a single simulation run.",
            "id": "3756514",
            "problem": "You are given two independent canonical Monte Carlo (MC) datasets representing samples of total energy and a scalar chemical ordering parameter for a multicomponent alloy at two nearby absolute temperatures. The physical setting is the canonical ensemble, where the probability of a microstate with energy $E$ at absolute temperature $T$ is proportional to $\\exp(-\\beta E)$ with $\\beta = 1/(k_{\\mathrm{B}} T)$ and $k_{\\mathrm{B}}$ the Boltzmann constant. The task is to implement single-histogram reweighting to estimate the ensemble average of the ordering parameter at an intermediate temperature, separately from each dataset, and verify mutual consistency.\n\nStart from the following foundational definitions:\n- The canonical ensemble equilibrium probability density is given by $p_{\\beta}(s) \\propto \\exp(-\\beta E(s))$, where $s$ denotes a microstate with energy $E(s)$, and $\\beta = 1/(k_{\\mathrm{B}} T)$.\n- The ensemble average of an observable $A$ at inverse temperature $\\beta$ is defined as $\\langle A \\rangle_{\\beta} = \\sum_{s} A(s) p_{\\beta}(s)$ (or the corresponding integral if the microstate space is continuous).\n- The datasets supplied are independent samples produced by Monte Carlo dynamics that preserve the canonical distribution at their respective temperatures.\n\nUsing only these definitions and the logic of importance sampling, derive a numerically stable expression for reweighting a sample average of a scalar observable from one inverse temperature $\\beta_0$ to another $\\beta^{\\star}$, and then implement an algorithm to compute the reweighted estimate of $\\langle \\eta \\rangle_{\\beta^{\\star}}$ from each dataset separately. Use the same Boltzmann constant for both datasets. Implement the reweighting in a way that is robust to large values of $|\\beta^{\\star} - \\beta_0|$ and large-magnitude energies, avoiding numerical overflow or underflow.\n\nPhysical units:\n- Energies must be taken in electronvolts (eV).\n- Temperatures must be taken in kelvin (K).\n- The Boltzmann constant to be used is $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ eV/K.\n- The ordering parameter $\\eta$ is dimensionless.\n\nAngle units are not applicable. If you compute any fractional differences, express them as decimals (do not use a percentage sign).\n\nNumerical specification and output format:\n- For each test case, compute two independent reweighted estimates of $\\langle \\eta \\rangle$ at the specified intermediate temperature $T^{\\star}$, one using only the dataset sampled at $T_1$, and one using only the dataset sampled at $T_2$. Then compute the absolute difference between these two estimates. Determine whether the two estimates are consistent within a specified absolute tolerance $\\tau$ by checking whether the absolute difference is less than or equal to $\\tau$.\n- For each test case, the program must output a list of four entries in the order: the estimate from the $T_1$ dataset, the estimate from the $T_2$ dataset, the absolute difference, and a boolean indicating whether the difference is within the given tolerance. All floating-point outputs must be rounded to six decimal places.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case’s result is itself a list as described above. For example, a valid output format would be $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\ldots]$ with each $a_i$, $b_i$, $c_i$ floats and each $d_i$ a boolean.\n\nTest suite:\nUse the following four test cases, each with specified temperatures, tolerance, and datasets. The energies and ordering parameters are given as lists; each number in the lists is a scalar value.\n\n- Test case $1$ (moderate temperature separation with good histogram overlap):\n  - $T_1 = 900$ K, $T_2 = 1100$ K, $T^{\\star} = 1000$ K, $\\tau = 0.1$.\n  - Dataset at $T_1$: energies (in eV) $[-3.25,-3.10,-3.05,-2.95,-3.40,-2.80,-3.00,-3.30,-2.90,-3.15]$ and ordering parameters $\\eta$ $[0.83,0.70,0.66,0.58,0.95,0.45,0.62,0.87,0.53,0.74]$.\n  - Dataset at $T_2$: energies (in eV) $[-3.05,-2.95,-2.85,-2.75,-3.10,-2.90,-2.80,-3.00,-2.70,-2.88]$ and ordering parameters $\\eta$ $[0.66,0.58,0.49,0.41,0.70,0.53,0.45,0.62,0.37,0.52]$.\n\n- Test case $2$ (very small temperature separation; near-identity reweighting):\n  - $T_1 = 1000$ K, $T_2 = 1005$ K, $T^{\\star} = 1002.5$ K, $\\tau = 0.01$.\n  - Dataset at $T_1$: energies (in eV) $[-3.02,-3.01,-2.99,-3.00,-3.03,-2.98,-2.97,-3.04]$ and ordering parameters $\\eta$ $[0.63,0.62,0.61,0.62,0.64,0.60,0.59,0.65]$.\n  - Dataset at $T_2$: energies (in eV) $[-3.01,-3.00,-2.99,-2.98,-3.02,-2.97,-3.03,-2.96]$ and ordering parameters $\\eta$ $[0.62,0.62,0.61,0.60,0.63,0.59,0.64,0.58]$.\n\n- Test case $3$ (wider separation but still overlapping):\n  - $T_1 = 600$ K, $T_2 = 800$ K, $T^{\\star} = 700$ K, $\\tau = 0.1$.\n  - Dataset at $T_1$: energies (in eV) $[-3.60,-3.50,-3.40,-3.70,-3.20,-3.30,-3.55,-3.45]$ and ordering parameters $\\eta$ $[0.93,0.88,0.83,0.96,0.73,0.78,0.91,0.86]$.\n  - Dataset at $T_2$: energies (in eV) $[-3.30,-3.20,-3.10,-3.00,-3.40,-3.25,-3.15,-2.95]$ and ordering parameters $\\eta$ $[0.78,0.73,0.68,0.63,0.83,0.75,0.70,0.60]$.\n\n- Test case $4$ (poor histogram overlap; expect inconsistency):\n  - $T_1 = 300$ K, $T_2 = 900$ K, $T^{\\star} = 600$ K, $\\tau = 0.02$.\n  - Dataset at $T_1$: energies (in eV) $[-4.50,-4.40,-4.60,-4.70,-4.30,-4.20,-4.55,-4.35]$ and ordering parameters $\\eta$ $[0.98,0.96,0.99,1.00,0.94,0.92,0.99,0.95]$.\n  - Dataset at $T_2$: energies (in eV) $[-3.10,-3.00,-2.90,-2.80,-3.20,-2.95,-2.85,-2.75]$ and ordering parameters $\\eta$ $[0.68,0.63,0.58,0.53,0.73,0.60,0.55,0.50]$.\n\nYour program must:\n- Implement the single-histogram reweighting using the numerically stable computation of the weights $\\exp(-(\\beta^{\\star}-\\beta_0) E_i)$ via a shift by the maximum exponent to avoid overflow or underflow.\n- For each test case, compute the two estimates of $\\langle \\eta \\rangle$ at $T^{\\star}$, their absolute difference, and whether they are within tolerance.\n- Output a single line containing a list with one entry per test case, where each entry is a list of the four required outputs in the specified order, with all floats rounded to six decimal places, for example $[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],\\ldots]$.",
            "solution": "## **Problem Validation**\n\n### Step 1: Extract Givens\n- **Physical Context**: Canonical ensemble (constant N, V, T).\n- **Probability Density**: $p_{\\beta}(s) \\propto \\exp(-\\beta E(s))$, where $\\beta = 1/(k_{\\mathrm{B}} T)$.\n- **Ensemble Average**: $\\langle A \\rangle_{\\beta} = \\sum_{s} A(s) p_{\\beta}(s)$.\n- **Data**: Two independent canonical Monte Carlo datasets are provided for each test case. Each dataset consists of a series of total energies ($E$) and a scalar chemical ordering parameter ($\\eta$). These datasets are sampled at two nearby absolute temperatures, $T_1$ and $T_2$.\n- **Task**:\n    1. Implement single-histogram reweighting to estimate the ensemble average $\\langle \\eta \\rangle$ at an intermediate temperature $T^{\\star}$.\n    2. Perform this estimation separately from each dataset.\n    3. Verify mutual consistency of the two estimates.\n- **Derivation Requirement**: Derive a numerically stable expression for reweighting from first principles (definitions and importance sampling).\n- **Numerical Stability**: The implementation must be robust against numerical overflow/underflow, especially for large $|\\beta^{\\star} - \\beta_0|$ and large-magnitude energies.\n- **Physical Units**:\n    - Energy ($E$): electronvolts (eV).\n    - Temperature ($T$): kelvin (K).\n- **Physical Constant**: Boltzmann constant, $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ eV/K.\n- **Observable**: Ordering parameter $\\eta$ (dimensionless).\n- **Output Specification**: For each test case, produce a list of four entries:\n    1. $\\langle \\eta \\rangle_{T^{\\star}}$ estimated from the $T_1$ dataset (float, rounded to 6 decimal places).\n    2. $\\langle \\eta \\rangle_{T^{\\star}}$ estimated from the $T_2$ dataset (float, rounded to 6 decimal places).\n    3. Absolute difference between the two estimates (float, rounded to 6 decimal places).\n    4. A boolean indicating if the absolute difference is within a given tolerance $\\tau$ (i.e., difference $\\le \\tau$).\n- **Final Output Format**: A single line containing a list of lists, e.g., `[[res1_1,res1_2,res1_3,res1_4],[res2_1,res2_2,res2_3,res2_4],...]`.\n- **Test Cases**: Four test cases are provided with specific values for $T_1$, $T_2$, $T^{\\star}$, $\\tau$, and the corresponding datasets for energy and ordering parameter.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on fundamental principles of statistical mechanics (canonical ensemble, Boltzmann statistics) and a standard, widely used computational technique (histogram reweighting, a form of importance sampling). The entire setup is scientifically valid and standard in computational materials science.\n2.  **Well-Posed**: The problem is well-posed. It requests the implementation of a specific, well-defined algorithm (single-histogram reweighting) to compute a quantity ($\\langle \\eta \\rangle_{T^{\\star}}$) for which a unique theoretical value exists (within statistical uncertainty). The provision of explicit datasets and parameters makes the solution uniquely determinable.\n3.  **Objective**: The problem is stated in precise, objective language. The definitions, tasks, and required outputs are unambiguous.\n4.  **Completeness and Consistency**: The problem is self-contained. All necessary information—constants, formulas, data, and output formats—is provided. There are no internal contradictions.\n5.  **Relevance**: The problem is directly relevant to the specified topic of simulating chemical ordering in complex materials, a key application area for Monte Carlo methods.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is scientifically sound, well-posed, objective, and complete. I will proceed with the solution.\n\n---\n\n## **Algorithmic and Theoretical Derivation**\n\n### **1. Principle of Single-Histogram Reweighting**\n\nThe objective is to estimate the ensemble average of an observable, $\\eta$, at a target inverse temperature $\\beta^{\\star} = 1/(k_{\\mathrm{B}} T^{\\star})$, using a set of microstates sampled from the canonical ensemble at a different, original inverse temperature $\\beta_0 = 1/(k_{\\mathrm{B}} T_0)$.\n\nThe formal definition of the canonical ensemble average of an observable $A$ (in this case, the ordering parameter $\\eta$) at inverse temperature $\\beta^{\\star}$ is:\n$$\n\\langle A \\rangle_{\\beta^{\\star}} = \\frac{\\int A(s) \\exp(-\\beta^{\\star} E(s)) \\, ds}{\\int \\exp(-\\beta^{\\star} E(s)) \\, ds}\n$$\nwhere the integral is over all possible microstates $s$ of the system.\n\nA Monte Carlo simulation at $\\beta_0$ generates a sequence of $N$ microstates, $\\{s_1, s_2, \\ldots, s_N\\}$, which are sampled according to the Boltzmann probability density $p_{\\beta_0}(s) \\propto \\exp(-\\beta_0 E(s))$. Thus, for any function $f(s)$, the integral can be approximated by a sum over the sampled microstates:\n$$\n\\int f(s) \\exp(-\\beta_0 E(s)) \\, ds \\approx C \\sum_{i=1}^N f(s_i)\n$$\nwhere $C$ is a proportionality constant.\n\nTo evaluate $\\langle A \\rangle_{\\beta^{\\star}}$, we can rewrite the integrals by introducing a factor of $1 = \\frac{\\exp(-\\beta_0 E(s))}{\\exp(-\\beta_0 E(s))}$. This technique is known as importance sampling.\n$$\n\\langle A \\rangle_{\\beta^{\\star}} = \\frac{\\int A(s) \\exp(-(\\beta^{\\star} - \\beta_0) E(s)) \\exp(-\\beta_0 E(s)) \\, ds}{\\int \\exp(-(\\beta^{\\star} - \\beta_0) E(s)) \\exp(-\\beta_0 E(s)) \\, ds}\n$$\nThe terms $\\exp(-\\beta_0 E(s)) \\, ds$ correspond to the probability measure under which the states $\\{s_i\\}$ were sampled. Therefore, we can approximate the integrals using the available Monte Carlo samples $\\{s_i\\}$, with their corresponding energies $\\{E_i\\}$ and observable values $\\{A_i=\\eta_i\\}$. The expression becomes:\n$$\n\\langle A \\rangle_{\\beta^{\\star}} \\approx \\frac{\\sum_{i=1}^N A_i \\exp(-(\\beta^{\\star} - \\beta_0) E_i)}{\\sum_{i=1}^N \\exp(-(\\beta^{\\star} - \\beta_0) E_i)}\n$$\nThis is the fundamental formula for single-histogram reweighting. It allows the estimation of ensemble averages at temperatures other than the one at which the simulation was run, by re-weighting each sample $i$ with a factor of $\\exp(-(\\beta^{\\star} - \\beta_0) E_i)$.\n\n### **2. Numerically Stable Implementation**\n\nA direct computation of the exponential terms in the reweighting formula can lead to numerical instability. If the exponent $-(\\beta^{\\star} - \\beta_0) E_i$ is a large positive number, $\\exp(-(\\beta^{\\star} - \\beta_0) E_i)$ can exceed the maximum representable floating-point value (overflow). If the exponent is a large-magnitude negative number, the result can become zero (underflow), leading to a loss of precision.\n\nTo ensure numerical stability, we can exploit the fact that the final expression is a ratio. Let the unnormalized reweighting term for sample $i$ be $w'_i = \\exp(-(\\beta^{\\star} - \\beta_0) E_i)$. We can multiply both the numerator and the denominator by an arbitrary constant $K$ without changing the result:\n$$\n\\langle A \\rangle_{\\beta^{\\star}} \\approx \\frac{\\sum_{i=1}^N A_i (K w'_i)}{\\sum_{i=1}^N (K w'_i)}\n$$\nA judicious choice for $K$ can prevent numerical issues. Let $x_i = -(\\beta^{\\star} - \\beta_0) E_i$ be the argument of the exponential. We find the maximum value among all exponents, $x_{\\max} = \\max_i\\{x_i\\}$. We then choose $K = \\exp(-x_{\\max})$. The re-scaled weights become:\n$$\nw_i = K w'_i = \\exp(-x_{\\max}) \\exp(x_i) = \\exp(x_i - x_{\\max})\n$$\nBy construction, the argument of this new exponential, $(x_i - x_{\\max})$, is always less than or equal to zero.\n- The maximum value of $w_i$ is $\\exp(0) = 1$, which prevents any possibility of overflow.\n- For exponents $x_i$ that are much smaller than $x_{\\max}$, the weight $w_i$ may underflow to zero. This is acceptable, as these states contribute negligibly to the reweighted sum anyway.\n\nThe numerically stable reweighting formula is thus:\n$$\n\\langle A \\rangle_{\\beta^{\\star}} \\approx \\frac{\\sum_{i=1}^N A_i \\exp(x_i - x_{\\max})}{\\sum_{i=1}^N \\exp(x_i - x_{\\max})} \\quad \\text{where} \\quad x_i = -(\\beta^{\\star} - \\beta_0) E_i \\quad \\text{and} \\quad x_{\\max} = \\max_i\\{x_i\\}\n$$\n\n### **3. Algorithm Outline**\n\nFor each test case, the following procedure is executed:\n1.  Define the Boltzmann constant $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ eV/K.\n2.  Define a function `reweight(T_0, E_data, eta_data, T_star)` that implements the numerically stable calculation described above.\n    a. Inside the function, calculate $\\beta_0 = 1/(k_{\\mathrm{B}} T_0)$ and $\\beta^{\\star} = 1/(k_{\\mathrm{B}} T^{\\star})$.\n    b. Compute the vector of exponents $x_i = -(\\beta^{\\star} - \\beta_0) E_i$.\n    c. Find the maximum exponent, $x_{\\max}$.\n    d. Compute the stable weights $w_i = \\exp(x_i - x_{\\max})$.\n    e. Return the weighted average $\\sum_i (\\eta_i w_i) / \\sum_i w_i$.\n3.  For each test case, call the `reweight` function twice:\n    a. To get estimate 1 ($\\eta^{\\star}_1$): `reweight(T_1, E_1_data, eta_1_data, T_star)`.\n    b. To get estimate 2 ($\\eta^{\\star}_2$): `reweight(T_2, E_2_data, eta_2_data, T_star)`.\n4.  Calculate the absolute difference: $\\Delta\\eta = |\\eta^{\\star}_1 - \\eta^{\\star}_2|$.\n5.  Determine consistency by checking if $\\Delta\\eta \\le \\tau$.\n6.  Store the four results ($\\eta^{\\star}_1$, $\\eta^{\\star}_2$, $\\Delta\\eta$, and the boolean consistency check) for the current test case.\n7.  After processing all test cases, format the collected results into a single string as specified by the problem statement, ensuring all floating-point numbers are rounded to six decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T1\": 900, \"T2\": 1100, \"T_star\": 1000, \"tau\": 0.1,\n            \"E1\": [-3.25, -3.10, -3.05, -2.95, -3.40, -2.80, -3.00, -3.30, -2.90, -3.15],\n            \"eta1\": [0.83, 0.70, 0.66, 0.58, 0.95, 0.45, 0.62, 0.87, 0.53, 0.74],\n            \"E2\": [-3.05, -2.95, -2.85, -2.75, -3.10, -2.90, -2.80, -3.00, -2.70, -2.88],\n            \"eta2\": [0.66, 0.58, 0.49, 0.41, 0.70, 0.53, 0.45, 0.62, 0.37, 0.52]\n        },\n        {\n            \"T1\": 1000, \"T2\": 1005, \"T_star\": 1002.5, \"tau\": 0.01,\n            \"E1\": [-3.02, -3.01, -2.99, -3.00, -3.03, -2.98, -2.97, -3.04],\n            \"eta1\": [0.63, 0.62, 0.61, 0.62, 0.64, 0.60, 0.59, 0.65],\n            \"E2\": [-3.01, -3.00, -2.99, -2.98, -3.02, -2.97, -3.03, -2.96],\n            \"eta2\": [0.62, 0.62, 0.61, 0.60, 0.63, 0.59, 0.64, 0.58]\n        },\n        {\n            \"T1\": 600, \"T2\": 800, \"T_star\": 700, \"tau\": 0.1,\n            \"E1\": [-3.60, -3.50, -3.40, -3.70, -3.20, -3.30, -3.55, -3.45],\n            \"eta1\": [0.93, 0.88, 0.83, 0.96, 0.73, 0.78, 0.91, 0.86],\n            \"E2\": [-3.30, -3.20, -3.10, -3.00, -3.40, -3.25, -3.15, -2.95],\n            \"eta2\": [0.78, 0.73, 0.68, 0.63, 0.83, 0.75, 0.70, 0.60]\n        },\n        {\n            \"T1\": 300, \"T2\": 900, \"T_star\": 600, \"tau\": 0.02,\n            \"E1\": [-4.50, -4.40, -4.60, -4.70, -4.30, -4.20, -4.55, -4.35],\n            \"eta1\": [0.98, 0.96, 0.99, 1.00, 0.94, 0.92, 0.99, 0.95],\n            \"E2\": [-3.10, -3.00, -2.90, -2.80, -3.20, -2.95, -2.85, -2.75],\n            \"eta2\": [0.68, 0.63, 0.58, 0.53, 0.73, 0.60, 0.55, 0.50]\n        }\n    ]\n\n    def reweight(T_0, E_data, eta_data, T_star, k_B_val):\n        \"\"\"\n        Calculates the reweighted average of an observable using a numerically stable method.\n\n        Args:\n            T_0 (float): The temperature at which the data was sampled.\n            E_data (list): List of energy values from the MC simulation.\n            eta_data (list): List of observable values from the MC simulation.\n            T_star (float): The target temperature for reweighting.\n            k_B_val (float): The Boltzmann constant.\n\n        Returns:\n            float: The estimated average of the observable at T_star.\n        \"\"\"\n        E_arr = np.array(E_data)\n        eta_arr = np.array(eta_data)\n\n        beta_0 = 1.0 / (k_B_val * T_0)\n        beta_star = 1.0 / (k_B_val * T_star)\n        delta_beta = beta_star - beta_0\n\n        exponents = -delta_beta * E_arr\n        \n        # Numerical stabilization by shifting exponents\n        max_exponent = np.max(exponents)\n        weights = np.exp(exponents - max_exponent)\n\n        reweighted_avg = np.sum(eta_arr * weights) / np.sum(weights)\n        return reweighted_avg\n\n    all_results = []\n    for case in test_cases:\n        T1, E1, eta1 = case[\"T1\"], case[\"E1\"], case[\"eta1\"]\n        T2, E2, eta2 = case[\"T2\"], case[\"E2\"], case[\"eta2\"]\n        T_star, tau = case[\"T_star\"], case[\"tau\"]\n\n        # Estimate from dataset 1\n        eta_star_1 = reweight(T1, E1, eta1, T_star, k_B)\n\n        # Estimate from dataset 2\n        eta_star_2 = reweight(T2, E2, eta2, T_star, k_B)\n\n        # Compute difference and check consistency\n        diff = abs(eta_star_1 - eta_star_2)\n        is_consistent = diff = tau\n\n        result_list = [eta_star_1, eta_star_2, diff, is_consistent]\n        all_results.append(result_list)\n\n    # Format the final output string\n    formatted_results = []\n    for res in all_results:\n        # Format: float, float, float, boolean\n        # .6f handles rounding for printing.\n        part_str = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{str(res[3]).lower()}]\"\n        formatted_results.append(part_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}