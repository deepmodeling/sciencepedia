{
    "hands_on_practices": [
        {
            "introduction": "在进行任何能量计算或模拟之前，我们必须首先构建晶体格子的数字化表示。本练习将指导你完成这一基础但至关重要的步骤：为体心立方（BCC）和面心立方（FCC）等常见结构生成周期性超胞中的原子坐标，并高效地找出截断半径内的近邻原子。这是计算相互作用能和执行蒙特卡洛模拟的必要前提。",
            "id": "3756504",
            "problem": "您的任务是为面心立方和体心立方晶格上高熵合金的化学有序性原子级蒙特卡罗模拟构建一个可重用的几何内核。该内核必须能够生成周期性超胞，使用最小镜像约定实现周期性边界条件，并构建与径向截断所规定的团簇截断一致的对邻居列表。这个内核是使用能量团簇展开的正则系综蒙特卡罗和巨正则系综蒙特卡罗采样的先决条件，其中截断的对团簇必须与底层晶格几何结构保持一致。\n\n仅从以下基本定义和事实出发：\n\n- 一个布拉维晶格由三个线性无关矢量的整数线性组合生成。对于晶格常数为 $a$ 的立方晶格，可以取原胞矢量 $\\mathbf{a}_1 = a \\mathbf{e}_x$、$\\mathbf{a}_2 = a \\mathbf{e}_y$、$\\mathbf{a}_3 = a \\mathbf{e}_z$，其中 $\\mathbf{e}_x$、$\\mathbf{e}_y$、$\\mathbf{e}_z$ 是单位矢量。\n- 一个由常规立方晶胞沿笛卡尔轴重复 $L_x \\times L_y \\times L_z$ 次构成的超胞，其盒边长分别为 $L_x a$、$L_y a$、$L_z a$。\n- 一个体心立方 (BCC) 晶格可以表示为一个简单立方布拉维晶格，在边长为 $a$ 的常规立方晶胞内，其双点基的分数坐标为 $(0,0,0)$ 和 $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$。\n- 一个面心立方 (FCC) 晶格可以表示为一个简单立方布拉维晶格，在边长为 $a$ 的常规立方晶胞内，其四点基的分数坐标为 $(0,0,0)$、$(0,\\tfrac{1}{2},\\tfrac{1}{2})$、$(\\tfrac{1}{2},0,\\tfrac{1}{2})$ 和 $(\\tfrac{1}{2},\\tfrac{1}{2},0)$。\n- 周期性边界条件要求使用最小镜像约定来计算距离：对于沿周期为 $L a$ 的轴的任意位移 $\\Delta x$，最小镜像位移为 $\\Delta x' = \\Delta x - (L a) \\,\\mathrm{round}(\\Delta x/(L a))$。这同样独立地适用于每个笛卡尔分量。\n\n设计并实现一个完整的程序，该程序能够：\n\n1. 为 BCC 或 FCC 晶格生成周期性超胞中所有格点的笛卡尔坐标。超胞由 $(L_x, L_y, L_z)$ 和晶格常数 $a$ 定义。总格点数为 $N = n_b \\, L_x L_y L_z$，其中 $n_b$ 是基点数（BCC 为 $n_b = 2$，FCC 为 $n_b = 4$）。\n2. 使用最小镜像约定实现周期性边界条件。对于任意一对位置为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的格点 $i$ 和 $j$，通过对每个笛卡尔分量应用最小镜像映射，使用盒边长 $(L_x a, L_y a, L_z a)$ 计算最小镜像位移 $\\Delta \\mathbf{r}_{ij}$。距离的平方为 $\\|\\Delta \\mathbf{r}_{ij}\\|^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2$。\n3. 构建与径向截断半径 $r_\\mathrm{cut}$ 指定的团簇截断一致的对邻居列表。对于每个格点 $i$，当且仅当 $0  \\|\\Delta \\mathbf{r}_{ij}\\| \\le r_\\mathrm{cut}$ 时，将格点 $j \\neq i$ 包含在 $i$ 的邻居列表中，其中 $r_\\mathrm{cut}$ 是严格正值。下界使用严格不等式以排除自配对，上界使用非严格不等式（带有微小的数值容差）以包含截至截断半径的邻居。您必须不能重复计算对。仅使用以 $a$ 为单位的距离（无量纲）。\n4. 计算截断条件下每个格点的配位数（邻居数量），并返回唯一的配位数（对于具有周期性边界条件的足够大的超胞，所有格点的配位数应相同）。\n\n测试套件和要求输出：\n\n使用以下五个测试用例。在所有情况下，晶格常数均为 $a = 1$（无量纲）。对于每个用例，计算在给定截断条件下的每个格点的配位数（一个整数），然后为每个用例输出单个整数结果。\n\n- 用例 1：BCC 晶格, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.9$。\n- 用例 2：BCC 晶格, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$。\n- 用例 3：FCC 晶格, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.72$。\n- 用例 4：FCC 晶格, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$。\n- 用例 5：FCC 晶格, $(L_x,L_y,L_z) = (2,3,4)$, $r_\\mathrm{cut} = 0.72$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含上述测试用例的五个配位数，形式为逗号分隔的列表，并用方括号括起，例如 $\\texttt{[n_1,n_2,n_3,n_4,n_5]}$，其中每个 $n_k$ 是一个整数。\n\n约束和说明：\n\n- 所有计算纯粹是几何的且无量纲的；不需要物理单位。\n- 不需要角度。\n- 通过在比较 $\\|\\Delta \\mathbf{r}_{ij}\\|$ 与 $r_\\mathrm{cut}$ 时使用一个小的容差 $\\epsilon$ 来确保数值鲁棒性，其中 $\\epsilon$ 是一个小的正浮点数（例如，$\\epsilon = 10^{-12}$）。只要 $\\epsilon$ 足够小，最终计数对其不应有敏感依赖。\n- 实现必须对任意正整数 $L_x$、$L_y$、$L_z$ 以及上述定义的 BCC 和 FCC 晶格具有通用性。",
            "solution": "### 步骤 1：提取已知条件\n\n- **布拉维晶格定义**：由三个线性无关原胞矢量的整数线性组合生成。对于晶格常数为 $a$ 的立方晶格，原胞矢量可取为 $\\mathbf{a}_1 = a \\mathbf{e}_x$、$\\mathbf{a}_2 = a \\mathbf{e}_y$、$\\mathbf{a}_3 = a \\mathbf{e}_z$。\n- **超胞定义**：一个由常规立方晶胞重复 $L_x \\times L_y \\times L_z$ 次构成的超胞，其盒边长为 $L_x a$、$L_y a$、$L_z a$。\n- **体心立方 (BCC) 晶格**：一个简单立方布拉维晶格，在边长为 $a$ 的常规立方晶胞内，其双点基的分数坐标为 $(0,0,0)$ 和 $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$。\n- **面心立方 (FCC) 晶格**：一个简单立方布拉维晶格，在边长为 $a$ 的常规立方晶胞内，其四点基的分数坐标为 $(0,0,0)$、$(0,\\tfrac{1}{2},\\tfrac{1}{2})$、$(\\tfrac{1}{2},0,\\tfrac{1}{2})$ 和 $(\\tfrac{1}{2},\\tfrac{1}{2},0)$。\n- **周期性边界条件 (PBC)**：距离使用最小镜像约定 (MIC) 计算。对于沿周期为 $L a$ 的轴的位移 $\\Delta x$，最小镜像位移为 $\\Delta x' = \\Delta x - (L a) \\,\\mathrm{round}(\\Delta x/(L a))$。这独立地适用于每个笛卡尔分量。\n- **总格点数, $N$**：$N = n_b \\, L_x L_y L_z$，其中 $n_b$ 是基点数（BCC 为 $n_b=2$，FCC 为 $n_b=4$）。\n- **MIC 下的距离平方**：$\\|\\Delta \\mathbf{r}_{ij}\\|^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2$。\n- **邻居列表条件**：当且仅当 $0  \\|\\Delta \\mathbf{r}_{ij}\\| \\le r_\\mathrm{cut}$ 时，格点 $j \\neq i$ 是格点 $i$ 的邻居，其中 $r_\\mathrm{cut} > 0$。\n- **单位和常数**：所有计算都以 $a$ 为单位。晶格常数设为 $a = 1$。\n- **数值容差**：应使用一个小的容差 $\\epsilon$（例如，$10^{-12}$）进行浮点比较。\n- **测试套件**：\n    - 用例 1：BCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.9$。\n    - 用例 2：BCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$。\n    - 用例 3：FCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 0.72$。\n    - 用例 4：FCC, $(L_x,L_y,L_z) = (3,3,3)$, $r_\\mathrm{cut} = 1.01$。\n    - 用例 5：FCC, $(L_x,L_y,L_z) = (2,3,4)$, $r_\\mathrm{cut} = 0.72$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题在根本上是合理的。所提供的 BCC 和 FCC 晶格、超胞、周期性边界条件和最小镜像约定的定义，在固态物理和计算材料科学领域是标准且正确的。整个任务是原子级模拟的标准先决条件。\n- **良定性**：该问题是良定的。它提供了一套完整的输入（晶格类型、超胞尺寸、截断半径）和一个用于计算所需输出（配位数）的确定性算法过程。对于给定的参数集，解是唯一且稳定的。\n- **客观性**：该问题使用物理学和计算机科学中常见的精确、无歧义和客观的语言进行陈述。没有主观或基于意见的成分。\n- **完整性与一致性**：该问题是自洽的。所有必要的定义、约束和数据都已明确提供。通过设置 $a=1$ 使用无量纲单位是一种标准且一致的简化方法。没有内部矛盾。\n- **可行性**：指定的计算不仅可行，而且是设置原子级模拟的标准练习。超胞尺寸和测试用例数量较小，使得计算成本可以忽略不计。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。这是一个定义明确、科学合理的计算物理学问题。可以根据所提供的规范构建解决方案。\n\n---\n\n### 解题方案\n\n任务是构建一个用于原子级模拟的几何内核，能够为 BCC 和 FCC 晶格生成周期性超胞，并基于径向截断计算配位数。该解决方案分三个阶段开发：超胞生成、周期性边界条件的实现和邻居列表的构建。对于所有计算，晶格常数 $a$ 均取为 $1$，使得所有坐标和距离都无量纲。\n\n#### 1. 超胞生成\n\n通过沿笛卡尔轴 $\\mathbf{e}_x$、$\\mathbf{e}_y$ 和 $\\mathbf{e}_z$ 将常规晶胞复制 $L_x$、$L_y$ 和 $L_z$ 次来构建周期性超胞。模拟盒矢量为 $\\mathbf{L}_1 = L_x a \\mathbf{e}_x$、$\\mathbf{L}_2 = L_y a \\mathbf{e}_y$ 和 $\\mathbf{L}_3 = L_z a \\mathbf{e}_z$。\n\n超胞中所有格点的位置是通过将晶体结构的基底原子放置在跨越超胞的简单立方网格的每个点上生成的。网格点 $\\mathbf{R}_{n_x,n_y,n_z}$ 由整数索引 $(n_x, n_y, n_z)$ 定义，其中 $0 \\le n_x  L_x$，$0 \\le n_y  L_y$，$0 \\le n_z  L_z$。此网格点的笛卡尔位置为：\n$$\n\\mathbf{R}_{n_x,n_y,n_z} = n_x a \\mathbf{e}_x + n_y a \\mathbf{e}_y + n_z a \\mathbf{e}_z\n$$\n对于具有一组 $n_b$ 个基矢量 $\\{\\mathbf{b}_k\\}$（以笛卡尔坐标表示）的给定晶格类型（BCC 或 FCC），格点的位置由将基矢量添加到网格点位置给出：\n$$\n\\mathbf{r}_{n_x,n_y,n_z,k} = \\mathbf{R}_{n_x,n_y,n_z} + \\mathbf{b}_k\n$$\n当 $a=1$ 时，基矢量为：\n- 对于 BCC ($n_b=2$)：\n  $$\n  \\mathbf{b}_1 = (0, 0, 0) \\quad , \\quad \\mathbf{b}_2 = (1/2, 1/2, 1/2)\n  $$\n- 对于 FCC ($n_b=4$)：\n  $$\n  \\mathbf{b}_1 = (0, 0, 0) \\quad , \\quad \\mathbf{b}_2 = (0, 1/2, 1/2) \\quad , \\quad \\mathbf{b}_3 = (1/2, 0, 1/2) \\quad , \\quad \\mathbf{b}_4 = (1/2, 1/2, 0)\n  $$\n超胞中的总格点数为 $N = n_b L_x L_y L_z$。该算法生成一个包含 $N$ 个位置矢量的数组，每个矢量都是一个三维笛卡尔坐标。\n\n#### 2. 最小镜像约定 (MIC)\n\n施加周期性边界条件以模拟无限大的块状材料。两个格点 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 之间的距离是 $\\mathbf{r}_i$ 与 $\\mathbf{r}_j$ 的所有无限周期性镜像之间的最短距离。最小镜像约定提供了一种直接计算与此最短距离对应的位移矢量的方法。\n\n给定原始位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i = (\\Delta x, \\Delta y, \\Delta z)$ 和一个边长为 $\\mathbf{L} = (L_x a, L_y a, L_z a)$ 的模拟盒，最小镜像位移矢量 $\\Delta\\mathbf{r}' = (\\Delta x', \\Delta y', \\Delta z')$ 按分量计算。对于 $x$ 分量：\n$$\n\\Delta x' = \\Delta x - (L_x a) \\cdot \\mathrm{round}\\left( \\frac{\\Delta x}{L_x a} \\right)\n$$\n其中 `round()` 是四舍五入到最近整数的函数。类似的表达式适用于 $\\Delta y'$ 和 $\\Delta z'$。这确保了所得位移矢量的每个分量的量级都不大于该方向盒长度的一半（即 $|\\Delta x'| \\le \\frac{L_x a}{2}$）。\n\n在 PBC 下，两个格点之间的欧几里得距离平方为：\n$$\nd_{ij}^2 = \\|\\Delta\\mathbf{r}'\\|^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2\n$$\n\n#### 3. 邻居列表与配位数\n\n格点 $i$ 的邻居列表包含在指定截断半径 $r_\\mathrm{cut}$ 内的所有其他格点 $j$。根据问题陈述，如果格点 $j$ 的最小镜像距离 $d_{ij}$ 满足 $0  d_{ij} \\le r_\\mathrm{cut}$，则它是格点 $i$ 的邻居。这可以更有效地使用距离平方来检查，以避免计算成本高昂的平方根运算：$0  d_{ij}^2 \\le r_\\mathrm{cut}^2$。\n\n算法流程如下：\n1. 初始化一个大小为 $N$ 的配位数数组 `coord`，所有元素均为零。\n2. 遍历所有唯一的格点对 $(i, j)$，其中 $0 \\le i  j  N$。这避免了重复计算对和评估自配对（其中 $i=j$ 且 $d_{ij}=0$）。\n3. 对于每对 $(\\mathbf{r}_i, \\mathbf{r}_j)$，计算最小镜像距离的平方 $d_{ij}^2$。\n4. 检查是否 $d_{ij}^2 \\le r_\\mathrm{cut}^2$。为了处理浮点不精确性，在比较中加入一个小的数值容差 $\\epsilon$（例如，$10^{-9}$），从而检查 $d_{ij}^2 \\le r_\\mathrm{cut}^2 + \\epsilon$。\n5. 如果满足条件，则增加两个格点的配位数计数：`coord[i]` 和 `coord[j]` 各加 1。\n\n由于完美晶格的平移对称性，每个格点在晶体学上都是等效的。因此，对于给定的 $r_\\mathrm{cut}$，每个格点必须具有相同的配位数。遍历所有对后，算法验证 `coord` 数组中的所有元素是否相同，并返回这个唯一的整数值。\n\n对于所提供的测试用例，$a=1$ 时理论上的最近邻 (NN) 距离为：\n- **BCC**：第一近邻壳层位于 $d = \\sqrt{(1/2)^2 + (1/2)^2 + (1/2)^2} = \\sqrt{3}/2 \\approx 0.866$。第二近邻壳层位于 $d = \\sqrt{1^2} = 1.0$。\n- **FCC**：第一近邻壳层位于 $d = \\sqrt{(1/2)^2 + (1/2)^2} = 1/\\sqrt{2} \\approx 0.707$。第二近邻壳层位于 $d = \\sqrt{1^2} = 1.0$。\n\n基于这些距离，预期结果是：\n- 用例 1 (BCC, $r_\\mathrm{cut} = 0.9$)：仅包括第一近邻壳层（8 个邻居），因为 $0.866  0.9  1.0$。\n- 用例 2 (BCC, $r_\\mathrm{cut} = 1.01$)：包括第一和第二近邻壳层（$8+6=14$ 个邻居），因为 $1.0  1.01$。\n- 用例 3 (FCC, $r_\\mathrm{cut} = 0.72$)：仅包括第一近邻壳层（12 个邻居），因为 $0.707  0.72  1.0$。\n- 用例 4 (FCC, $r_\\mathrm{cut} = 1.01$)：包括第一和第二近邻壳层（$12+6=18$ 个邻居），因为 $1.0  1.01$。\n- 用例 5 (FCC, $r_\\mathrm{cut} = 0.72$)：与用例 3 的局部环境相同，预期有 12 个邻居，因为超胞在所有维度上都足够大以包含第一邻居壳层。\n实现必须重现这些整数结果。",
            "answer": "```python\nimport numpy as np\n\nclass GeometricKernel:\n    \"\"\"\n    A geometric kernel for atomistic Monte Carlo simulation.\n\n    Generates periodic supercells for BCC and FCC lattices, applies\n    periodic boundary conditions using the minimum image convention,\n    and computes coordination numbers based on a radial cutoff.\n    \"\"\"\n    def __init__(self, lattice_type: str, L: tuple, a: float = 1.0):\n        \"\"\"\n        Initializes the geometric kernel.\n\n        Args:\n            lattice_type (str): The crystal lattice type, either \"BCC\" or \"FCC\".\n            L (tuple): A tuple of 3 integers (Lx, Ly, Lz) defining the\n                       supercell dimensions in units of conventional cells.\n            a (float): The lattice parameter.\n        \"\"\"\n        if lattice_type not in [\"BCC\", \"FCC\"]:\n            raise ValueError(\"lattice_type must be either 'BCC' or 'FCC'\")\n        \n        self.lattice_type = lattice_type\n        self.L = np.array(L, dtype=int)\n        self.a = float(a)\n        self.box_dims = self.L * self.a\n        \n        self.sites = self._generate_sites()\n        self.N = self.sites.shape[0]\n        \n    def _generate_sites(self) - np.ndarray:\n        \"\"\"\n        Generates the Cartesian coordinates of all sites in the supercell.\n\n        Returns:\n            np.ndarray: An array of shape (N, 3) containing the site coordinates.\n        \"\"\"\n        if self.lattice_type == \"BCC\":\n            basis = np.array([[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]]) * self.a\n        else:  # FCC\n            basis = np.array([[0.0, 0.0, 0.0],\n                              [0.0, 0.5, 0.5],\n                              [0.5, 0.0, 0.5],\n                              [0.5, 0.5, 0.0]]) * self.a\n\n        # Create a grid of lattice points for the supercell\n        nx, ny, nz = np.mgrid[0:self.L[0], 0:self.L[1], 0:self.L[2]]\n        grid_points = np.vstack([nx.ravel(), ny.ravel(), nz.ravel()]).T * self.a\n        \n        # Combine grid points with basis vectors using broadcasting\n        # grid_points shape: (num_grid_points, 3) - (1, num_grid_points, 3)\n        # basis shape: (num_basis, 3) - (num_basis, 1, 3)\n        # Resulting shape after addition: (num_basis, num_grid_points, 3)\n        all_sites = grid_points[np.newaxis, :, :] + basis[:, np.newaxis, :]\n        \n        # Reshape to a flat list of sites (N, 3)\n        num_sites = self.L[0] * self.L[1] * self.L[2] * basis.shape[0]\n        return all_sites.reshape(num_sites, 3)\n\n    def _minimum_image_disp(self, r_i: np.ndarray, r_j: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the minimum image displacement vector between two sites.\n\n        Args:\n            r_i (np.ndarray): Position vector of site i.\n            r_j (np.ndarray): Position vector of site j.\n\n        Returns:\n            np.ndarray: The minimum image displacement vector from i to j.\n        \"\"\"\n        delta = r_j - r_i\n        # Apply minimum image convention using the provided formula\n        return delta - self.box_dims * np.round(delta / self.box_dims)\n\n    def get_coordination_number(self, r_cut: float, epsilon: float = 1e-9) - int:\n        \"\"\"\n        Computes the coordination number for each site up to a cutoff radius.\n\n        Args:\n            r_cut (float): The radial cutoff for neighbor searching.\n            epsilon (float): Small tolerance for floating point comparisons.\n\n        Returns:\n            int: The unique coordination number for all sites in the lattice.\n        \"\"\"\n        r_cut_sq = r_cut**2\n        coord_numbers = np.zeros(self.N, dtype=int)\n\n        for i in range(self.N):\n            for j in range(i + 1, self.N):\n                # Calculate displacement and squared distance using MIC\n                disp = self._minimum_image_disp(self.sites[i], self.sites[j])\n                dist_sq = np.dot(disp, disp)\n                \n                # Check if the pair is within the cutoff radius.\n                # The condition 0  d_ij is implicitly handled by j > i.\n                # The condition d_ij = r_cut is checked as d_ij^2 = r_cut^2.\n                # A small tolerance epsilon is used for robust floating point comparison.\n                if dist_sq = r_cut_sq + epsilon:\n                    coord_numbers[i] += 1\n                    coord_numbers[j] += 1\n        \n        # In a perfect periodic lattice, all sites are equivalent\n        # and should have the same coordination number.\n        unique_cn = np.unique(coord_numbers)\n        if len(unique_cn) != 1:\n            # This should not happen for a sufficiently large supercell\n            raise RuntimeError(f\"Inconsistent coordination numbers found: {unique_cn}\")\n            \n        return int(unique_cn[0])\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Format: (lattice_type, (Lx, Ly, Lz), r_cut)\n    test_cases = [\n        (\"BCC\", (3, 3, 3), 0.9),\n        (\"BCC\", (3, 3, 3), 1.01),\n        (\"FCC\", (3, 3, 3), 0.72),\n        (\"FCC\", (3, 3, 3), 1.01),\n        (\"FCC\", (2, 3, 4), 0.72),\n    ]\n\n    results = []\n    for lattice_type, L, r_cut in test_cases:\n        # For all cases, the problem specifies a dimensionless lattice parameter a=1.\n        kernel = GeometricKernel(lattice_type=lattice_type, L=L, a=1.0)\n        cn = kernel.get_coordination_number(r_cut=r_cut)\n        results.append(cn)\n\n    # Print the final results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "搭建好模拟的“舞台”后，我们将聚焦于蒙特卡洛模拟的核心——“尝试移动”。本练习将演示如何使用簇扩展模型计算原子置换所引起的能量变化（$\\Delta E$），并应用Metropolis准则来决定在正则系综和巨正则系综中是否接受这一移动。通过这个实践，你将掌握蒙特卡洛算法的“引擎”部分。",
            "id": "3756606",
            "problem": "考虑一个尺寸为 $N \\times N$ 的二维周期性方格晶格上的多组分合金，其构型能由团簇展开表示。团簇展开能量定义为 $E(\\sigma) = \\sum_{\\alpha} J_{\\alpha} \\Phi_{\\alpha}(\\sigma)$，其中 $\\sigma$ 表示构型（每个晶格点上的原子种类），$J_{\\alpha}$ 是通过密度泛函理论 (DFT) 校准的有效团簇相互作用 (ECI)，$\\Phi_{\\alpha}(\\sigma)$ 是团簇 $\\alpha$ 的团簇函数。假设只有围绕发生嬗变的格点为中心的局域团簇对能量变化有贡献。在本问题中，您将使用最近邻点团簇和对团簇来计算单个格点上提议的嬗变所引起的能量变化。\n\n使用的基本原理和假设：\n- 构型能 $E(\\sigma)$ 由一个在具有周期性边界条件的方格晶格上、截断至点团簇和最近邻对团簇的有限团簇展开表示。\n- 最近邻由曼哈顿距离为 $1$ 定义（上、下、左、右）。\n- 正则系综 Metropolis 接受概率为 $p_{\\text{can}} = \\min\\left(1, \\exp(-\\beta \\Delta E)\\right)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。\n- 巨正则系综接受概率为 $p_{\\text{gc}} = \\min\\left(1, \\exp\\left[-\\beta \\left(\\Delta E - \\sum_{s} \\mu_{s} \\Delta N_{s}\\right)\\right]\\right)$，其中 $\\mu_{s}$ 是原子种类 $s$ 的化学势，$\\Delta N_{s}$ 是由提议的嬗变引起的原子种类 $s$ 的数量变化。对于从原子种类 $s_{\\text{old}}$ 到 $s_{\\text{new}}$ 的单格点嬗变，$\\Delta N_{s_{\\text{new}}} = +1$，$\\Delta N_{s_{\\text{old}}} = -1$，所有其他的 $\\Delta N_{s} = 0$，因此 $\\Delta E_{\\text{eff}} = \\Delta E - (\\mu_{s_{\\text{new}}} - \\mu_{s_{\\text{old}}})$。\n- 玻尔兹曼常数 $k_{\\mathrm{B}}$ 必须使用电子伏特每开尔文单位：$k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\ \\mathrm{eV/K}$。\n\n使用的团簇函数定义：\n- 格点 $i$ 上的点团簇贡献：为每种原子分配的能量，其 ECI 向量为 $\\mathbf{J}^{\\text{point}}$，使得贡献等于 $J^{\\text{point}}_{\\sigma_{i}}$。\n- 最近邻对 $(i,j)$ 的对团簇贡献：为每个有序原子种类对分配的能量，其 ECI 矩阵 $J^{\\text{pair}}_{a,b}$ 在 $a$ 和 $b$ 上是对称的；贡献等于 $J^{\\text{pair}}_{\\sigma_{i},\\sigma_{j}}$。\n\n任务：\n- 对每个测试用例，仅使用涉及嬗变格点的局域点团簇和最近邻对团簇贡献，计算单个格点上提议的嬗变所产生的能量变化 $\\Delta E$（单位为电子伏特）。在晶格边缘使用周期性边界条件。然后，在指定的温度和化学势下，计算正则系综接受概率 $p_{\\text{can}}$ 和巨正则系综接受概率 $p_{\\text{gc}}$。\n\n原子种类映射：\n- 使用三种标记为 $A, B, C$ 的原子种类，分别映射到整数 $0, 1, 2$。\n\n单位和数值输出要求：\n- 以电子伏特 (eV) 表示 $\\Delta E$。\n- 以小数形式表示接受概率 $p_{\\text{can}}$ 和 $p_{\\text{gc}}$。\n- 将所有输出四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的列表组成的列表，并用方括号括起来。每个内部列表的形式必须是 $[\\Delta E, p_{\\text{can}}, p_{\\text{gc}}]$，对应一个测试用例，其中的值需四舍五入到六位小数。例如，格式为 $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],\\ldots]$。\n\n测试套件：\n- 以下所有索引均为零基索引 $(0 \\leq i,j  N)$。\n\n1) 正常情况（非平凡邻域，混合原子种类）：\n- 晶格尺寸：$N = 4$。\n- 构型 $\\sigma$（原子种类整数网格）：\n$$\n\\begin{bmatrix}\n0  1  2  0 \\\\\n1  0  1  2 \\\\\n2  1  0  1 \\\\\n0  2  1  0\n\\end{bmatrix}\n$$\n- 嬗变格点：$(i,j) = (0,1)$。\n- 提议的嬗变：$B \\to C$（旧种类 $1$，新种类 $2$）。\n- 点 ECI（单位 eV）：$\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$。\n- 对 ECI（单位 eV），对称矩阵 $J^{\\text{pair}}$：\n$$\n\\begin{bmatrix}\n0.00  0.02  -0.01 \\\\\n0.02  0.00  0.015 \\\\\n-0.01  0.015  0.00\n\\end{bmatrix}\n$$\n- 温度：$T = 1000$ K。\n- 化学势（单位 eV）：$\\boldsymbol{\\mu} = [0.10, \\ 0.00, \\ -0.02]$。\n\n2) 边界条件（无变化移动）：\n- 晶格尺寸：$N = 3$。\n- 构型 $\\sigma$：\n$$\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n- 嬗变格点：$(i,j) = (1,1)$。\n- 提议的嬗变：$A \\to A$（旧种类 $0$，新种类 $0$）。\n- 点 ECI（单位 eV）：$\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$。\n- 对 ECI（单位 eV），对称矩阵 $J^{\\text{pair}}$：\n$$\n\\begin{bmatrix}\n0.00  0.02  -0.01 \\\\\n0.02  0.00  0.015 \\\\\n-0.01  0.015  0.00\n\\end{bmatrix}\n$$\n- 温度：$T = 500$ K。\n- 化学势（单位 eV）：$\\boldsymbol{\\mu} = [0.0, \\ 0.0, \\ 0.0]$。\n\n3) 边缘情况（与周围原子种类有强烈的有利相互作用）：\n- 晶格尺寸：$N = 4$。\n- 构型 $\\sigma$：\n$$\n\\begin{bmatrix}\n2  2  2  2 \\\\\n2  1  1  2 \\\\\n2  1  0  2 \\\\\n2  2  2  2\n\\end{bmatrix}\n$$\n- 嬗变格点：$(i,j) = (1,2)$。\n- 提议的嬗变：$B \\to A$（旧种类 $1$，新种类 $0$）。\n- 点 ECI（单位 eV）：$\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$。\n- 对 ECI（单位 eV），对称矩阵 $J^{\\text{pair}}$：\n$$\n\\begin{bmatrix}\n0.00  0.01  -0.08 \\\\\n0.01  0.00  0.02 \\\\\n-0.08  0.02  0.00\n\\end{bmatrix}\n$$\n- 温度：$T = 300$ K。\n- 化学势（单位 eV）：$\\boldsymbol{\\mu} = [0.0, \\ 0.0, \\ 0.0]$。\n\n4) 巨正则系综惩罚（化学势不利于新种类）：\n- 晶格尺寸：$N = 4$。\n- 构型 $\\sigma$：\n$$\n\\begin{bmatrix}\n0  1  0  2 \\\\\n1  2  1  0 \\\\\n0  1  2  1 \\\\\n2  0  1  0\n\\end{bmatrix}\n$$\n- 嬗变格点：$(i,j) = (0,0)$。\n- 提议的嬗变：$A \\to B$（旧种类 $0$，新种类 $1$）。\n- 点 ECI（单位 eV）：$\\mathbf{J}^{\\text{point}} = [0.12, \\ 0.00, \\ -0.05]$。\n- 对 ECI（单位 eV），对称矩阵 $J^{\\text{pair}}$：\n$$\n\\begin{bmatrix}\n0.00  0.02  -0.01 \\\\\n0.02  0.00  0.015 \\\\\n-0.01  0.015  0.00\n\\end{bmatrix}\n$$\n- 温度：$T = 800$ K。\n- 化学势（单位 eV）：$\\boldsymbol{\\mu} = [0.0, \\ -0.30, \\ 0.0]$。\n\n您的程序必须为每个测试用例计算三元组 $[\\Delta E, p_{\\text{can}}, p_{\\text{gc}}]$，并按照上述确切格式生成单行输出。所有能量必须以电子伏特 (eV) 为单位，所有概率必须是小数。将每个数字四舍五入到六位小数。",
            "solution": "该问题被评估为有效，因为它具有科学依据、提法恰当、客观，并包含得出唯一解所需的所有信息。它描述了材料建模中的一个标准计算任务，该任务基于统计力学和固体物理学的基本原理。\n\n问题的核心是计算二维方格晶格上多组分合金中单格点嬗变的构型能变化 $\\Delta E$，并随后计算此移动在正则系综和巨正则系综中的 Metropolis 接受概率。对于给定构型 $\\sigma$（将原子种类分配给每个晶格点），系统的构型能 $E(\\sigma)$ 由一个团簇展开模型定义。问题指出，该展开被截断，只包含点相互作用和最近邻对相互作用。\n\n构型 $\\sigma$ 的能量由以下公式给出：\n$$ E(\\sigma) = \\sum_{i} E_{i}^{\\text{point}} + \\sum_{\\langle i, j \\rangle} E_{i,j}^{\\text{pair}} $$\n其中第一个和是对所有晶格点 $i$ 求和，第二个和是对所有唯一的最近邻对 $\\langle i, j \\rangle$ 求和。格点 $i$ 上的点能量取决于该格点上的原子种类 $\\sigma_i$，即 $E_{i}^{\\text{point}} = J^{\\text{point}}_{\\sigma_i}$。格点对 $(i,j)$ 的对能量取决于这些格点上的原子种类，即 $E_{i,j}^{\\text{pair}} = J^{\\text{pair}}_{\\sigma_i, \\sigma_j}$。\n\n我们的任务是计算当单个格点 $k$ 上的原子种类从旧种类 $s_{\\text{old}}$ 嬗变为新种类 $s_{\\text{new}}$ 时的能量变化 $\\Delta E = E_{\\text{final}} - E_{\\text{initial}}$。根据问题陈述，我们只需考虑以嬗变格点 $k$ 为中心的局域团簇。这是因为只有涉及格点 $k$ 的能量项会发生变化。该变化包括两个部分：\n1. 格点 $k$ 上的点能量变化。\n2. 所有涉及格点 $k$ 的对能量的变化。\n\n点能量的变化为：\n$$ \\Delta E_{\\text{point}} = J^{\\text{point}}_{s_{\\text{new}}} - J^{\\text{point}}_{s_{\\text{old}}} $$\n\n在二维方格晶格上，格点 $k$ 有四个最近邻。设 $k$ 的最近邻格点集合表示为 $\\mathcal{N}(k)$。对能量贡献的变化是每个对 $(k, j)$（其中 $j \\in \\mathcal{N}(k)$）的变化之和：\n$$ \\Delta E_{\\text{pair}} = \\sum_{j \\in \\mathcal{N}(k)} \\left( J^{\\text{pair}}_{s_{\\text{new}}, \\sigma_{j}} - J^{\\text{pair}}_{s_{\\text{old}}, \\sigma_{j}} \\right) $$\n其中 $\\sigma_j$ 是相邻格点 $j$ 上的原子种类。\n\n总构型能变化是这两部分贡献之和：\n$$ \\Delta E = \\Delta E_{\\text{point}} + \\Delta E_{\\text{pair}} $$\n\n晶格是周期性的，因此在一个 $N \\times N$ 网格上（使用零基索引），坐标为 $(i, j)$ 的格点的四个最近邻坐标为：\n- 上：$((i - 1 + N) \\pmod N, j)$\n- 下：$((i + 1) \\pmod N, j)$\n- 左：$(i, (j - 1 + N) \\pmod N)$\n- 右：$(i, (j + 1) \\pmod N)$\n\n一旦计算出 $\\Delta E$，我们就可以确定接受概率。热能由 $k_{\\mathrm{B}}T$ 给出，其中玻尔兹曼常数 $k_{\\mathrm{B}}$ 为 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\ \\mathrm{eV/K}$。我们定义逆温度 $\\beta = 1 / (k_{\\mathrm{B}}T)$。\n\n正则系综接受概率 $p_{\\text{can}}$ 由 Metropolis 判据给出：\n$$ p_{\\text{can}} = \\min\\left(1, \\exp(-\\beta \\Delta E)\\right) $$\n如果 $\\Delta E \\leq 0$，则该移动总是被接受（$p_{\\text{can}} = 1$）。如果 $\\Delta E > 0$，则该移动以小于 $1$ 的概率被接受，从而惩罚能量上不利的变化。\n\n在巨正则系综中，接受概率 $p_{\\text{gc}}$ 取决于一个有效能量变化 $\\Delta E_{\\text{eff}}$，该变化包括了抵抗化学势 $\\mu_s$ 改变粒子数所做的功。对于从 $s_{\\text{old}}$ 到 $s_{\\text{new}}$ 的嬗变，原子种类 $s_{\\text{new}}$ 的原子数增加一（$\\Delta N_{s_{\\text{new}}} = +1$），而原子种类 $s_{\\text{old}}$ 的原子数减少一（$\\Delta N_{s_{\\text{old}}} = -1$）。巨势的变化为 $\\Delta \\Omega = \\Delta E - \\sum_s \\mu_s \\Delta N_s$。这可以简化为：\n$$ \\Delta E_{\\text{eff}} = \\Delta E - (\\mu_{s_{\\text{new}}} - \\mu_{s_{\\text{old}}}) $$\n于是，巨正则系综接受概率为：\n$$ p_{\\text{gc}} = \\min\\left(1, \\exp(-\\beta \\Delta E_{\\text{eff}})\\right) $$\n\n解决每个测试用例的算法如下：\n1. 识别格点 $(i,j)$ 处嬗变的旧种类 $s_{\\text{old}}$ 和新种类 $s_{\\text{new}}$。\n2. 应用周期性边界条件，确定格点 $(i,j)$ 的四个最近邻的原子种类。\n3. 计算 $\\Delta E_{\\text{point}} = J^{\\text{point}}_{s_{\\text{new}}} - J^{\\text{point}}_{s_{\\text{old}}}$。\n4. 通过对四个邻居求和变化量 $J^{\\text{pair}}_{s_{\\text{new}}, \\sigma_j} - J^{\\text{pair}}_{s_{\\text{old}}, \\sigma_j}$ 来计算 $\\Delta E_{\\text{pair}}$。\n5. 计算总能量变化 $\\Delta E = \\Delta E_{\\text{point}} + \\Delta E_{\\text{pair}}$。\n6. 计算 $\\beta = 1 / (k_{\\mathrm{B}}T)$。\n7. 计算 $p_{\\text{can}} = \\min(1, \\exp(-\\beta \\Delta E))$。\n8. 计算 $\\Delta E_{\\text{eff}} = \\Delta E - (\\mu_{s_{\\text{new}}} - \\mu_{s_{\\text{old}}})$。\n9. 计算 $p_{\\text{gc}} = \\min(1, \\exp(-\\beta \\Delta E_{\\text{eff}}))$。\n10. 将 $\\Delta E$、$p_{\\text{can}}$ 和 $p_{\\text{gc}}$ 的结果四舍五入到六位小数。\n\n此过程将应用于问题陈述中提供的每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the energy change and acceptance probabilities for single-site\n    transmutations in a 2D lattice model of a multi-component alloy.\n    \"\"\"\n    k_B = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    test_cases = [\n        {\n            \"N\": 4,\n            \"sigma\": np.array([\n                [0, 1, 2, 0],\n                [1, 0, 1, 2],\n                [2, 1, 0, 1],\n                [0, 2, 1, 0]\n            ]),\n            \"site\": (0, 1),\n            \"transmutation\": (1, 2),  # old - new\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.02, -0.01],\n                [0.02, 0.00, 0.015],\n                [-0.01, 0.015, 0.00]\n            ]),\n            \"T\": 1000.0,\n            \"mu\": np.array([0.10, 0.00, -0.02])\n        },\n        {\n            \"N\": 3,\n            \"sigma\": np.array([\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"site\": (1, 1),\n            \"transmutation\": (0, 0),\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.02, -0.01],\n                [0.02, 0.00, 0.015],\n                [-0.01, 0.015, 0.00]\n            ]),\n            \"T\": 500.0,\n            \"mu\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"N\": 4,\n            \"sigma\": np.array([\n                [2, 2, 2, 2],\n                [2, 1, 1, 2],\n                [2, 1, 0, 2],\n                [2, 2, 2, 2]\n            ]),\n            \"site\": (1, 2),\n            \"transmutation\": (1, 0),\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.01, -0.08],\n                [0.01, 0.00, 0.02],\n                [-0.08, 0.02, 0.00]\n            ]),\n            \"T\": 300.0,\n            \"mu\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"N\": 4,\n            \"sigma\": np.array([\n                [0, 1, 0, 2],\n                [1, 2, 1, 0],\n                [0, 1, 2, 1],\n                [2, 0, 1, 0]\n            ]),\n            \"site\": (0, 0),\n            \"transmutation\": (0, 1),\n            \"J_point\": np.array([0.12, 0.00, -0.05]),\n            \"J_pair\": np.array([\n                [0.00, 0.02, -0.01],\n                [0.02, 0.00, 0.015],\n                [-0.01, 0.015, 0.00]\n            ]),\n            \"T\": 800.0,\n            \"mu\": np.array([0.0, -0.30, 0.0])\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        sigma = case[\"sigma\"]\n        i, j = case[\"site\"]\n        s_old, s_new = case[\"transmutation\"]\n        J_point = case[\"J_point\"]\n        J_pair = case[\"J_pair\"]\n        T = case[\"T\"]\n        mu = case[\"mu\"]\n\n        # No change in energy or species count if old == new\n        if s_old == s_new:\n            delta_E = 0.0\n            p_can = 1.0\n            p_gc = 1.0\n            all_results.append(f\"[{delta_E:.6f},{p_can:.6f},{p_gc:.6f}]\")\n            continue\n\n        # 1. Identify nearest neighbors with periodic boundary conditions\n        neighbors_pos = [\n            ((i - 1 + N) % N, j),  # Up\n            ((i + 1) % N, j),      # Down\n            (i, (j - 1 + N) % N),  # Left\n            (i, (j + 1) % N)       # Right\n        ]\n        neighbor_species = [sigma[pos] for pos in neighbors_pos]\n\n        # 2. Calculate energy change delta_E\n        # Point energy change\n        delta_E_point = J_point[s_new] - J_point[s_old]\n\n        # Pair energy change\n        delta_E_pair = 0.0\n        for s_neighbor in neighbor_species:\n            delta_E_pair += J_pair[s_new, s_neighbor] - J_pair[s_old, s_neighbor]\n        \n        delta_E = delta_E_point + delta_E_pair\n\n        # 3. Calculate acceptance probabilities\n        if T == 0:\n            # Handle T=0 case to avoid division by zero, although not in tests\n            beta = float('inf')\n        else:\n            beta = 1.0 / (k_B * T)\n\n        # Canonical acceptance probability\n        p_can = min(1.0, np.exp(-beta * delta_E))\n\n        # Grand-canonical acceptance probability\n        delta_mu = mu[s_new] - mu[s_old]\n        delta_E_eff = delta_E - delta_mu\n        p_gc = min(1.0, np.exp(-beta * delta_E_eff))\n\n        all_results.append(f\"[{delta_E:.6f},{p_can:.6f},{p_gc:.6f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "运行模拟的计算成本可能非常高昂，因此最大化利用已有数据至关重要。本项高级练习将介绍一种强大的数据分析技术——直方图重加权法，它能让我们估算在未进行模拟的温度下的物理性质。你将学习如何实现该方法，从有限的模拟数据中提取最大的科学价值，这是衡量计算科学家效率的关键技能。",
            "id": "3756514",
            "problem": "给定两个独立的多组分合金在两个相近绝对温度下的正则蒙特卡罗（MC）数据集。这些数据集代表了总能量和标量化学有序参数的样本。物理背景是正则系综，其中一个能量为 $E$ 的微观状态在绝对温度 $T$ 下出现的概率正比于 $\\exp(-\\beta E)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。任务是实现单直方图重加权方法，以在某个中间温度下估算有序参数的系综平均值。你需要分别基于每个数据集进行估算，并验证两者之间的一致性。\n\n从以下基本定义出发：\n- 正则系综的平衡概率密度由 $p_{\\beta}(s) \\propto \\exp(-\\beta E(s))$ 给出，其中 $s$ 表示一个能量为 $E(s)$ 的微观状态，$\\beta = 1/(k_{\\mathrm{B}} T)$。\n- 一个可观测量 $A$ 在逆温 $\\beta$ 下的系综平均值定义为 $\\langle A \\rangle_{\\beta} = \\sum_{s} A(s) p_{\\beta}(s)$（如果微观状态空间是连续的，则为相应的积分）。\n- 所提供的数据集是由蒙特卡罗动力学产生的独立样本，这些动力学在其各自的温度下保持了正则分布。\n\n仅使用这些定义和重要性采样的逻辑，推导出一个数值稳定的表达式，用于将一个标量可观测量在某个逆温 $\\beta_0$ 下的样本平均值重加权到另一个逆温 $\\beta^{\\star}$。然后，实现一个算法，以分别从每个数据集中计算 $\\langle \\eta \\rangle_{\\beta^{\\star}}$ 的重加权估计值。对两个数据集使用相同的玻尔兹曼常数。实现重加权时，必须确保方法对于较大的 $|\\beta^{\\star} - \\beta_0|$ 值和大幅值能量是鲁棒的，以避免数值上溢或下溢。\n\n物理单位：\n- 能量必须以电子伏特（eV）为单位。\n- 温度必须以开尔文（K）为单位。\n- 使用的玻尔兹曼常数为 $k_{\\mathrm{B}} = 8.617\\,333\\,262\\,145 \\times 10^{-5}$ eV/K。\n- 有序参数 $\\eta$ 是无量纲的。\n\n角度单位不适用。如果计算任何分数差，请以小数形式表示（不要使用百分号）。\n\n数值规格和输出格式：\n- 对于每个测试用例，计算在指定中间温度 $T^{\\star}$ 下 $\\langle \\eta \\rangle$ 的两个独立重加权估计值，一个仅使用在 $T_1$ 采样的集，另一个仅使用在 $T_2$ 采样的集。然后计算这两个估计值之间的绝对差。通过检查绝对差是否小于或等于指定的绝对容差 $\\tau$，来确定这两个估计值是否在容差范围内一致。\n- 对于每个测试用例，程序必须输出一个包含四个条目的列表，顺序为：来自 $T_1$ 数据集的估计值、来自 $T_2$ 数据集的估计值、绝对差，以及一个布尔值，表示差值是否在给定容差内。所有浮点输出必须四舍五入到六位小数。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个以逗号分隔的列表，并用方括号括起来。每个测试用例的结果本身也是一个如上所述的列表。例如，一个有效的输出格式是 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\ldots]$，其中每个 $a_i$、$b_i$、$c_i$ 是浮点数，每个 $d_i$ 是布尔值。\n\n测试套件：\n使用以下四个测试用例，每个用例都有指定的温度、容差和数据集。能量和有序参数以列表形式给出；列表中的每个数字都是一个标量值。\n\n- 测试用例 $1$（温度间隔适中，直方图重叠良好）：\n  - $T_1 = 900$ K, $T_2 = 1100$ K, $T^{\\star} = 1000$ K, $\\tau = 0.1$。\n  - $T_1$ 下的数据集：能量（单位 eV）$[-3.25,-3.10,-3.05,-2.95,-3.40,-2.80,-3.00,-3.30,-2.90,-3.15]$ 和有序参数 $\\eta$ $[0.83,0.70,0.66,0.58,0.95,0.45,0.62,0.87,0.53,0.74]$。\n  - $T_2$ 下的数据集：能量（单位 eV）$[-3.05,-2.95,-2.85,-2.75,-3.10,-2.90,-2.80,-3.00,-2.70,-2.88]$ 和有序参数 $\\eta$ $[0.66,0.58,0.49,0.41,0.70,0.53,0.45,0.62,0.37,0.52]$。\n\n- 测试用例 $2$（温度间隔非常小；接近恒等重加权）：\n  - $T_1 = 1000$ K, $T_2 = 1005$ K, $T^{\\star} = 1002.5$ K, $\\tau = 0.01$。\n  - $T_1$ 下的数据集：能量（单位 eV）$[-3.02,-3.01,-2.99,-3.00,-3.03,-2.98,-2.97,-3.04]$ 和有序参数 $\\eta$ $[0.63,0.62,0.61,0.62,0.64,0.60,0.59,0.65]$。\n  - $T_2$ 下的数据集：能量（单位 eV）$[-3.01,-3.00,-2.99,-2.98,-3.02,-2.97,-3.03,-2.96]$ 和有序参数 $\\eta$ $[0.62,0.62,0.61,0.60,0.63,0.59,0.64,0.58]$。\n\n- 测试用例 $3$（温度间隔较宽但仍有重叠）：\n  - $T_1 = 600$ K, $T_2 = 800$ K, $T^{\\star} = 700$ K, $\\tau = 0.1$。\n  - $T_1$ 下的数据集：能量（单位 eV）$[-3.60,-3.50,-3.40,-3.70,-3.20,-3.30,-3.55,-3.45]$ 和有序参数 $\\eta$ $[0.93,0.88,0.83,0.96,0.73,0.78,0.91,0.86]$。\n  - $T_2$ 下的数据集：能量（单位 eV）$[-3.30,-3.20,-3.10,-3.00,-3.40,-3.25,-3.15,-2.95]$ 和有序参数 $\\eta$ $[0.78,0.73,0.68,0.63,0.83,0.75,0.70,0.60]$。\n\n- 测试用例 $4$（直方图重叠差；预计不一致）：\n  - $T_1 = 300$ K, $T_2 = 900$ K, $T^{\\star} = 600$ K, $\\tau = 0.02$。\n  - $T_1$ 下的数据集：能量（单位 eV）$[-4.50,-4.40,-4.60,-4.70,-4.30,-4.20,-4.55,-4.35]$ 和有序参数 $\\eta$ $[0.98,0.96,0.99,1.00,0.94,0.92,0.99,0.95]$。\n  - $T_2$ 下的数据集：能量（单位 eV）$[-3.10,-3.00,-2.90,-2.80,-3.20,-2.95,-2.85,-2.75]$ 和有序参数 $\\eta$ $[0.68,0.63,0.58,0.53,0.73,0.60,0.55,0.50]$。\n\n您的程序必须：\n- 使用通过指数平移（减去最大指数）的数值稳定计算方式实现单直方图重加权，以避免上溢或下溢，从而计算权重 $\\exp(-(\\beta^{\\star}-\\beta_0) E_i)$。\n- 对每个测试用例，计算在 $T^{\\star}$ 下 $\\langle \\eta \\rangle$ 的两个估计值、它们的绝对差以及它们是否在容差范围内。\n- 输出一行，其中包含一个列表，每个测试用例对应一个条目，每个条目又是包含四个指定顺序输出的列表，所有浮点数四舍五入到六位小数，例如 $[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],\\ldots]$。",
            "solution": "## **问题验证**\n\n### 步骤1：提取已知信息\n- **物理背景**：正则系综（N, V, T 恒定）。\n- **概率密度**：$p_{\\beta}(s) \\propto \\exp(-\\beta E(s))$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。\n- **系综平均**：$\\langle A \\rangle_{\\beta} = \\sum_{s} A(s) p_{\\beta}(s)$。\n- **数据**：为每个测试用例提供了两个独立的正则蒙特卡罗数据集。每个数据集包含一系列总能量（$E$）和标量化学有序参数（$\\eta$）。这些数据集是在两个相近的绝对温度 $T_1$ 和 $T_2$ 下采样的。\n- **任务**：\n    1. 实现单直方图重加权方法，以估计在中间温度 $T^{\\star}$ 下的系综平均值 $\\langle \\eta \\rangle$。\n    2. 分别从每个数据集进行此估计。\n    3. 验证两个估计值的相互一致性。\n- **推导要求**：从第一性原理（定义和重要性采样）推导出一个数值稳定的重加权表达式。\n- **数值稳定性**：实现必须能抵抗数值上溢/下溢，特别是对于大的 $|\\beta^{\\star} - \\beta_0|$ 和大幅值能量。\n- **物理单位**：\n    - 能量（$E$）：电子伏特（eV）。\n    - 温度（$T$）：开尔文（K）。\n- **物理常数**：玻尔兹曼常数，$k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ eV/K。\n- **可观测量**：有序参数 $\\eta$（无量纲）。\n- **输出规格**：对于每个测试用例，生成一个包含四个条目的列表：\n    1. 从 $T_1$ 数据集估计的 $\\langle \\eta \\rangle_{T^{\\star}}$（浮点数，四舍五入到6位小数）。\n    2. 从 $T_2$ 数据集估计的 $\\langle \\eta \\rangle_{T^{\\star}}$（浮点数，四舍五入到6位小数）。\n    3. 两个估计值之间的绝对差（浮点数，四舍五入到6位小数）。\n    4. 一个布尔值，指示绝对差是否在给定的容差 $\\tau$ 内（即，差值 $\\le \\tau$）。\n- **最终输出格式**：包含一个列表的列表的单行，例如 `[[res1_1,res1_2,res1_3,res1_4],[res2_1,res2_2,res2_3,res2_4],...]`。\n- **测试用例**：提供了四个测试用例，包含 $T_1$、$T_2$、$T^{\\star}$、$\\tau$ 的具体值以及相应的能量和有序参数数据集。\n\n### 步骤2：使用提取的已知信息进行验证\n1.  **科学基础**：该问题基于统计力学的基本原理（正则系综，玻尔兹曼统计）和一种标准的、广泛使用的计算技术（直方图重加权，一种重要性采样形式）。整个设置在计算材料科学中是科学有效且标准的。\n2.  **适定性**：该问题是适定的。它要求实现一个特定的、明确定义的算法（单直方图重加权）来计算一个量（$\\langle \\eta \\rangle_{T^{\\star}}$），该量存在一个唯一的理论值（在统计不确定性范围内）。提供明确的数据集和参数使得解是唯一可确定的。\n3.  **客观性**：问题以精确、客观的语言陈述。定义、任务和所需输出都是明确的。\n4.  **完整性和一致性**：问题是自洽的。所有必要的信息——常数、公式、数据和输出格式——都已提供。没有内部矛盾。\n5.  **相关性**：该问题与模拟复杂材料中化学有序的特定主题直接相关，这是蒙特卡罗方法的一个关键应用领域。\n\n### 步骤3：结论与行动\n问题陈述有效。它在科学上是合理的、适定的、客观的和完整的。我将继续进行解答。\n\n---\n\n## **算法与理论推导**\n\n### **1. 单直方图重加权原理**\n\n目标是使用从一个原始逆温 $\\beta_0 = 1/(k_{\\mathrm{B}} T_0)$ 的正则系综中采样的一组微观状态，来估计一个可观测量 $\\eta$ 在目标逆温 $\\beta^{\\star} = 1/(k_{\\mathrm{B}} T^{\\star})$ 下的系综平均值。\n\n一个可观测量 $A$（在此情况下为有序参数 $\\eta$）在逆温 $\\beta^{\\star}$ 下的正则系综平均值的形式化定义是：\n$$\n\\langle A \\rangle_{\\beta^{\\star}} = \\frac{\\int A(s) \\exp(-\\beta^{\\star} E(s)) \\, ds}{\\int \\exp(-\\beta^{\\star} E(s)) \\, ds}\n$$\n其中积分遍及系统的所有可能微观状态 $s$。\n\n在 $\\beta_0$ 下的蒙特卡罗模拟生成一个包含 $N$ 个微观状态的序列 $\\{s_1, s_2, \\ldots, s_N\\}$，这些状态是根据玻尔兹曼概率密度 $p_{\\beta_0}(s) \\propto \\exp(-\\beta_0 E(s))$ 采样的。因此，对于任何函数 $f(s)$，积分可以近似为对采样微观状态的求和：\n$$\n\\int f(s) \\exp(-\\beta_0 E(s)) \\, ds \\approx C \\sum_{i=1}^N f(s_i)\n$$\n其中 $C$ 是一个比例常数。\n\n为了计算 $\\langle A \\rangle_{\\beta^{\\star}}$，我们可以通过引入一个因子 $1 = \\frac{\\exp(-\\beta_0 E(s))}{\\exp(-\\beta_0 E(s))}$ 来重写积分。这种技术被称为重要性采样。\n$$\n\\langle A \\rangle_{\\beta^{\\star}} = \\frac{\\int A(s) \\exp(-(\\beta^{\\star} - \\beta_0) E(s)) \\exp(-\\beta_0 E(s)) \\, ds}{\\int \\exp(-(\\beta^{\\star} - \\beta_0) E(s)) \\exp(-\\beta_0 E(s)) \\, ds}\n$$\n项 $\\exp(-\\beta_0 E(s)) \\, ds$ 对应于采样状态 $\\{s_i\\}$ 所依据的概率测度。因此，我们可以使用可用的蒙特卡罗样本 $\\{s_i\\}$ 及其对应的能量 $\\{E_i\\}$ 和可观测量值 $\\{A_i=\\eta_i\\}$ 来近似这些积分。表达式变为：\n$$\n\\langle A \\rangle_{\\beta^{\\star}} \\approx \\frac{\\sum_{i=1}^N A_i \\exp(-(\\beta^{\\star} - \\beta_0) E_i)}{\\sum_{i=1}^N \\exp(-(\\beta^{\\star} - \\beta_0) E_i)}\n$$\n这是单直方图重加权的基本公式。它允许通过对每个样本 $i$ 使用因子 $\\exp(-(\\beta^{\\star} - \\beta_0) E_i)$ 进行重加权，来估计在非模拟温度下的系综平均值。\n\n### **2. 数值稳定的实现**\n\n直接计算重加权公式中的指数项可能导致数值不稳定。如果指数 $-(\\beta^{\\star} - \\beta_0) E_i$ 是一个大的正数，$\\exp(-(\\beta^{\\star} - \\beta_0) E_i)$ 可能会超过可表示的最大浮点值（上溢）。如果指数是一个大幅值的负数，结果可能会变成零（下溢），导致精度损失。\n\n为确保数值稳定性，我们可以利用最终表达式是一个比率这一事实。设样本 $i$ 的未归一化重加权项为 $w'_i = \\exp(-(\\beta^{\\star} - \\beta_0) E_i)$。我们可以在分子和分母上同时乘以一个任意常数 $K$ 而不改变结果：\n$$\n\\langle A \\rangle_{\\beta^{\\star}} \\approx \\frac{\\sum_{i=1}^N A_i (K w'_i)}{\\sum_{i=1}^N (K w'_i)}\n$$\n对 $K$ 的明智选择可以防止数值问题。设 $x_i = -(\\beta^{\\star} - \\beta_0) E_i$ 为指数的参数。我们找到所有指数中的最大值，$x_{\\max} = \\max_i\\{x_i\\}$。然后我们选择 $K = \\exp(-x_{\\max})$。重新缩放的权重变为：\n$$\nw_i = K w'_i = \\exp(-x_{\\max}) \\exp(x_i) = \\exp(x_i - x_{\\max})\n$$\n通过这种构造，新指数的参数 $(x_i - x_{\\max})$ 始终小于或等于零。\n- $w_i$ 的最大值是 $\\exp(0) = 1$，这防止了任何上溢的可能性。\n- 对于远小于 $x_{\\max}$ 的指数 $x_i$，权重 $w_i$ 可能会下溢到零。这是可以接受的，因为这些状态对重加权和的贡献本来就微不足道。\n\n因此，数值稳定的重加权公式是：\n$$\n\\langle A \\rangle_{\\beta^{\\star}} \\approx \\frac{\\sum_{i=1}^N A_i \\exp(x_i - x_{\\max})}{\\sum_{i=1}^N \\exp(x_i - x_{\\max})} \\quad \\text{其中} \\quad x_i = -(\\beta^{\\star} - \\beta_0) E_i \\quad \\text{且} \\quad x_{\\max} = \\max_i\\{x_i\\}\n$$\n\n### **3. 算法大纲**\n\n对于每个测试用例，执行以下过程：\n1.  定义玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ eV/K。\n2.  定义一个函数 `reweight(T_0, E_data, eta_data, T_star)`，实现上述的数值稳定计算。\n    a. 在函数内部，计算 $\\beta_0 = 1/(k_{\\mathrm{B}} T_0)$ 和 $\\beta^{\\star} = 1/(k_{\\mathrm{B}} T^{\\star})$。\n    b. 计算指数向量 $x_i = -(\\beta^{\\star} - \\beta_0) E_i$。\n    c. 找到最大指数 $x_{\\max}$。\n    d. 计算稳定权重 $w_i = \\exp(x_i - x_{\\max})$。\n    e. 返回加权平均值 $\\sum_i (\\eta_i w_i) / \\sum_i w_i$。\n3.  对于每个测试用例，调用 `reweight` 函数两次：\n    a. 获取估计值1（$\\eta^{\\star}_1$）：`reweight(T_1, E_1_data, eta_1_data, T_star)`。\n    b. 获取估计值2（$\\eta^{\\star}_2$）：`reweight(T_2, E_2_data, eta_2_data, T_star)`。\n4.  计算绝对差：$\\Delta\\eta = |\\eta^{\\star}_1 - \\eta^{\\star}_2|$。\n5.  通过检查 $\\Delta\\eta \\le \\tau$ 来确定一致性。\n6.  存储当前测试用例的四个结果（$\\eta^{\\star}_1$、$\\eta^{\\star}_2$、$\\Delta\\eta$ 和布尔一致性检查）。\n7.  处理完所有测试用例后，将收集到的结果格式化为问题陈述所指定的单行字符串，确保所有浮点数都四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T1\": 900, \"T2\": 1100, \"T_star\": 1000, \"tau\": 0.1,\n            \"E1\": [-3.25, -3.10, -3.05, -2.95, -3.40, -2.80, -3.00, -3.30, -2.90, -3.15],\n            \"eta1\": [0.83, 0.70, 0.66, 0.58, 0.95, 0.45, 0.62, 0.87, 0.53, 0.74],\n            \"E2\": [-3.05, -2.95, -2.85, -2.75, -3.10, -2.90, -2.80, -3.00, -2.70, -2.88],\n            \"eta2\": [0.66, 0.58, 0.49, 0.41, 0.70, 0.53, 0.45, 0.62, 0.37, 0.52]\n        },\n        {\n            \"T1\": 1000, \"T2\": 1005, \"T_star\": 1002.5, \"tau\": 0.01,\n            \"E1\": [-3.02, -3.01, -2.99, -3.00, -3.03, -2.98, -2.97, -3.04],\n            \"eta1\": [0.63, 0.62, 0.61, 0.62, 0.64, 0.60, 0.59, 0.65],\n            \"E2\": [-3.01, -3.00, -2.99, -2.98, -3.02, -2.97, -3.03, -2.96],\n            \"eta2\": [0.62, 0.62, 0.61, 0.60, 0.63, 0.59, 0.64, 0.58]\n        },\n        {\n            \"T1\": 600, \"T2\": 800, \"T_star\": 700, \"tau\": 0.1,\n            \"E1\": [-3.60, -3.50, -3.40, -3.70, -3.20, -3.30, -3.55, -3.45],\n            \"eta1\": [0.93, 0.88, 0.83, 0.96, 0.73, 0.78, 0.91, 0.86],\n            \"E2\": [-3.30, -3.20, -3.10, -3.00, -3.40, -3.25, -3.15, -2.95],\n            \"eta2\": [0.78, 0.73, 0.68, 0.63, 0.83, 0.75, 0.70, 0.60]\n        },\n        {\n            \"T1\": 300, \"T2\": 900, \"T_star\": 600, \"tau\": 0.02,\n            \"E1\": [-4.50, -4.40, -4.60, -4.70, -4.30, -4.20, -4.55, -4.35],\n            \"eta1\": [0.98, 0.96, 0.99, 1.00, 0.94, 0.92, 0.99, 0.95],\n            \"E2\": [-3.10, -3.00, -2.90, -2.80, -3.20, -2.95, -2.85, -2.75],\n            \"eta2\": [0.68, 0.63, 0.58, 0.53, 0.73, 0.60, 0.55, 0.50]\n        }\n    ]\n\n    def reweight(T_0, E_data, eta_data, T_star, k_B_val):\n        \"\"\"\n        Calculates the reweighted average of an observable using a numerically stable method.\n\n        Args:\n            T_0 (float): The temperature at which the data was sampled.\n            E_data (list): List of energy values from the MC simulation.\n            eta_data (list): List of observable values from the MC simulation.\n            T_star (float): The target temperature for reweighting.\n            k_B_val (float): The Boltzmann constant.\n\n        Returns:\n            float: The estimated average of the observable at T_star.\n        \"\"\"\n        E_arr = np.array(E_data)\n        eta_arr = np.array(eta_data)\n\n        beta_0 = 1.0 / (k_B_val * T_0)\n        beta_star = 1.0 / (k_B_val * T_star)\n        delta_beta = beta_star - beta_0\n\n        exponents = -delta_beta * E_arr\n        \n        # Numerical stabilization by shifting exponents\n        max_exponent = np.max(exponents)\n        weights = np.exp(exponents - max_exponent)\n\n        reweighted_avg = np.sum(eta_arr * weights) / np.sum(weights)\n        return reweighted_avg\n\n    all_results = []\n    for case in test_cases:\n        T1, E1, eta1 = case[\"T1\"], case[\"E1\"], case[\"eta1\"]\n        T2, E2, eta2 = case[\"T2\"], case[\"E2\"], case[\"eta2\"]\n        T_star, tau = case[\"T_star\"], case[\"tau\"]\n\n        # Estimate from dataset 1\n        eta_star_1 = reweight(T1, E1, eta1, T_star, k_B)\n\n        # Estimate from dataset 2\n        eta_star_2 = reweight(T2, E2, eta2, T_star, k_B)\n\n        # Compute difference and check consistency\n        diff = abs(eta_star_1 - eta_star_2)\n        is_consistent = diff = tau\n\n        result_list = [eta_star_1, eta_star_2, diff, is_consistent]\n        all_results.append(result_list)\n\n    # Format the final output string\n    formatted_results = []\n    for res in all_results:\n        # Format: float, float, float, boolean\n        # .6f handles rounding for printing.\n        part_str = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{str(res[3]).lower()}]\"\n        formatted_results.append(part_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}