{
    "hands_on_practices": [
        {
            "introduction": "在晶体材料的密度泛函理论（DFT）计算中，总能等性质是通过在布里渊区进行积分来确定的。本练习模拟了测试$k$点网格收敛性的关键过程，这是确保计算结果数值准确性的强制性步骤。通过分析能量和应力如何随网格密度变化，你将学会如何确定获得可靠预测所需的最小采样密度。",
            "id": "3737416",
            "problem": "您的任务是设计并实现一个收敛性评估程序，该程序用于在密度泛函理论 (DFT) 中，通过 $k$点网格对倒易空间进行采样，以计算无序高熵合金 (HEA) 超胞的基态。计算环境为一个周期性、金属性的无序 HEA 超胞，其中对 Kohn–Sham (KS) 总能量和应力有贡献的布里渊区 (BZ) 积分必须通过一组有限的 $k$点集进行近似。您可以依赖的基本原理包括：用于计算基态性质的密度泛函理论 (DFT) 的 Kohn–Sham 表述、周期性系统需要进行布里渊区 (BZ) 积分的要求，以及此类积分的求积误差随采样密度增加而减小的普适原理。您不得在这些基础之外假定任何专门的简化公式。\n\n出发点是以下原理：KS 基态总能量（每个原子），记为 $E$，是通过对布里渊区 (BZ) 内经占据数加权的能带能量进行积分得到的；柯西应力张量分量 $\\sigma_{ij}$ 是通过基态能量对应变的导数得到的（例如，在适用情况下通过 Hellmann–Feynman 定理和 Pulay 修正得到）。使用有限 $k$点网格对 BZ 积分进行离散化会引入数值误差，该误差通常随着采样密度的增加而减小。对于无序 HEA 超胞，由无序引起的实空间扩大效应会折叠布里渊区并改变采样要求，但收敛逻辑仍然受 $E$ 和应力随 $k$点密度增加而趋于稳定的规律支配。\n\n您的任务是构建一个满足以下条件的程序：\n- 对于给定的无序 HEA 超胞，考虑一系列逐渐密集的 $k$点网格（不一定是立方网格）。\n- 使用以下判据：相邻网格之间的每个原子的总能量变化 $|\\Delta E|$ 必须严格小于 $1\\,\\mathrm{meV}$（即 $|\\Delta E|  0.001\\,\\mathrm{eV}$），并且相邻网格之间的应力大小变化 $|\\Delta \\sigma|$ 必须严格小于 $0.1\\,\\mathrm{GPa}$（即 $|\\Delta \\sigma|  0.1\\,\\mathrm{GPa}$）。\n- 选择满足条件的最小网格（以 $k$点总数 $N_k = k_x \\cdot k_y \\cdot k_z$ 衡量），该网格需满足在从前一个网格过渡到当前网格时，两个判据同时成立。\n- 如果在提供的序列中不存在这样的网格，则对该测试用例输出 $-1$。\n\n假设应力以标量大小的形式提供（例如，应力张量的范数或与收敛性评估相关的适当应力标量描述符）。所有总能量均为每个原子的能量。\n\n您必须实现一个程序来处理以下测试用例集。对于每个用例 $c$，您会得到：\n- 一个 $k$点网格列表 $G^{(c)} = \\{(k_x,k_y,k_z)\\}$，按从粗到细的采样顺序排列。\n- 一个每个原子的总能量列表 $E^{(c)}$，单位为 $\\mathrm{eV}$，与网格对齐。\n- 一个应力大小列表 $\\sigma^{(c)}$，单位为 $\\mathrm{GPa}$，与网格对齐。\n\n您的程序必须在相邻网格之间应用严格的收敛判据 $|\\Delta E|  0.001\\,\\mathrm{eV}$ 和 $|\\Delta \\sigma|  0.1\\,\\mathrm{GPa}$，并返回同时满足这两个条件的最小 $N_k$；如果不存在这样的网格，则返回 $-1$。\n\n使用以下测试集：\n\n- 用例 $1$：\n  网格 $G^{(1)}$: $[(2,2,2),(3,3,3),(4,4,4),(6,6,6),(8,8,8)]$。\n  每个原子的能量 $E^{(1)}$: $[-6.3200,-6.3350,-6.3405,-6.3412,-6.3418]\\,\\mathrm{eV}$。\n  应力大小 $\\sigma^{(1)}$: $[2.05,1.26,0.98,0.92,0.91]\\,\\mathrm{GPa}$。\n\n- 用例 $2$：\n  网格 $G^{(2)}$: $[(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]$。\n  每个原子的能量 $E^{(2)}$: $[-7.1250,-7.1300,-7.1310,-7.1314,-7.1316]\\,\\mathrm{eV}$。\n  应力大小 $\\sigma^{(2)}$: $[0.55,0.46,0.42,0.41,0.405]\\,\\mathrm{GPa}$。\n\n- 用例 $3$：\n  网格 $G^{(3)}$: $[(1,1,1),(2,2,2),(3,3,3),(4,4,4),(6,6,6)]$。\n  每个原子的能量 $E^{(3)}$: $[-5.0000,-5.1200,-5.1550,-5.1600,-5.1622]\\,\\mathrm{eV}$。\n  应力大小 $\\sigma^{(3)}$: $[1.80,1.40,1.30,1.25,1.22]\\,\\mathrm{GPa}$。\n\n- 用例 $4$ (各向异性网格)：\n  网格 $G^{(4)}$: $[(2,2,1),(3,3,1),(3,3,2),(4,4,2),(4,4,3)]$。\n  每个原子的能量 $E^{(4)}$: $[-6.0000,-6.0200,-6.0280,-6.0290,-6.0296]\\,\\mathrm{eV}$。\n  应力大小 $\\sigma^{(4)}$: $[1.10,0.85,0.80,0.78,0.779]\\,\\mathrm{GPa}$。\n\n- 用例 $5$ (非单调小波动)：\n  网格 $G^{(5)}$: $[(2,2,2),(3,3,3),(4,4,4),(6,6,6),(8,8,8)]$。\n  每个原子的能量 $E^{(5)}$: $[-8.0000,-8.0006,-8.0010,-8.0012,-8.0013]\\,\\mathrm{eV}$。\n  应力大小 $\\sigma^{(5)}$: $[0.95,0.90,0.88,0.879,0.8785]\\,\\mathrm{GPa}$。\n\n边界与边缘情况要求：\n- “低于 $1\\,\\mathrm{meV}$” 和 “低于 $0.1\\,\\mathrm{GPa}$” 这两个短语表示严格不等式：$|\\Delta E|  0.001\\,\\mathrm{eV}$ 和 $|\\Delta \\sigma|  0.1\\,\\mathrm{GPa}$。等于的情况不满足判据。\n- 当两个差值同时低于阈值时，所选的网格对应于这一对网格中更精细的那个。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,\\dots]$），其中每个 $result_c$ 是用例 $c$ 选定的 $k$点总数 $N_k$，如果在提供的序列中没有达到收敛，则为 $-1$。不允许外部输入，也不应打印任何额外文本。所有能量必须使用 $\\mathrm{eV}$/原子的单位，所有应力大小必须使用 $\\mathrm{GPa}$ 的单位。",
            "solution": "所述问题已得到形式化验证。\n\n**步骤 1：提取已知条件**\n- **任务**：为高熵合金 (HEA) 超胞在密度泛函理论 (DFT) 中的 $k$点网格采样设计并实现一个收敛性评估程序。\n- **原理**：Kohn-Sham (KS) 总能量（每个原子）$E$ 和柯西应力张量分量 $\\sigma_{ij}$ 是通过布里渊区 (BZ) 积分获得的。使用有限 $k$点网格进行离散化会引入必须收敛的数值误差。\n- **收敛判据**：\n    1. 相邻网格之间的每个原子的总能量变化 $|\\Delta E|$ 必须严格小于 $1\\,\\mathrm{meV}$，即 $|\\Delta E|  0.001\\,\\mathrm{eV}$。\n    2. 相邻网格之间的应力大小变化 $|\\Delta \\sigma|$ 必须严格小于 $0.1\\,\\mathrm{GPa}$，即 $|\\Delta \\sigma|  0.1\\,\\mathrm{GPa}$。\n- **选择规则**：选择满足两个判据同时成立的最小网格（以 $k$点总数 $N_k = k_x \\cdot k_y \\cdot k_z$ 衡量）。所选的网格是被比较的两个网格中更精细的那个。\n- **未收敛情况**：如果在提供的序列中没有网格满足判据，则该用例的输出为 $-1$。\n- **输入数据**：对于每个用例 $c$，提供一个网格列表 $G^{(c)}$、一个能量列表 $E^{(c)}$（单位 $\\mathrm{eV}$）和一个应力大小列表 $\\sigma^{(c)}$（单位 $\\mathrm{GPa}$）。\n- **测试集**：\n    - **用例 $1$**：$G^{(1)} = [(2,2,2),(3,3,3),(4,4,4),(6,6,6),(8,8,8)]$，$E^{(1)} = [-6.3200,-6.3350,-6.3405,-6.3412,-6.3418]\\,\\mathrm{eV}$，$\\sigma^{(1)} = [2.05,1.26,0.98,0.92,0.91]\\,\\mathrm{GPa}$。\n    - **用例 $2$**：$G^{(2)} = [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]$，$E^{(2)} = [-7.1250,-7.1300,-7.1310,-7.1314,-7.1316]\\,\\mathrm{eV}$，$\\sigma^{(2)} = [0.55,0.46,0.42,0.41,0.405]\\,\\mathrm{GPa}$。\n    - **用例 $3$**：$G^{(3)} = [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(6,6,6)]$，$E^{(3)} = [-5.0000,-5.1200,-5.1550,-5.1600,-5.1622]\\,\\mathrm{eV}$，$\\sigma^{(3)} = [1.80,1.40,1.30,1.25,1.22]\\,\\mathrm{GPa}$。\n    - **用例 $4$**：$G^{(4)} = [(2,2,1),(3,3,1),(3,3,2),(4,4,2),(4,4,3)]$，$E^{(4)} = [-6.0000,-6.0200,-6.0280,-6.0290,-6.0296]\\,\\mathrm{eV}$，$\\sigma^{(4)} = [1.10,0.85,0.80,0.78,0.779]\\,\\mathrm{GPa}$。\n    - **用例 $5$**：$G^{(5)} = [(2,2,2),(3,3,3),(4,4,4),(6,6,6),(8,8,8)]$，$E^{(5)} = [-8.0000,-8.0006,-8.0010,-8.0012,-8.0013]\\,\\mathrm{eV}$，$\\sigma^{(5)} = [0.95,0.90,0.88,0.879,0.8785]\\,\\mathrm{GPa}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题准确定位于 DFT 的标准框架内。关于 $k$点采样的布里渊区积分收敛是任何周期性系统电子结构计算中一个基本且强制性的步骤。总能量 ($1\\,\\mathrm{meV/}$原子) 和应力 ($0.1\\,\\mathrm{GPa}$) 的收敛判据是计算材料科学中使用的标准、现实的数值。\n- **适定性**：该问题是适定的。它提供了一系列预先计算好的数据和一个待应用的确定性、无歧义的算法。对于每个输入用例，都存在一个唯一的、稳定的、有意义的解（一个特定的 $N_k$ 值或 $-1$）。\n- **客观性**：语言精确且客观。判据是定量的，并基于严格不等式。不需要主观解释。\n\n**步骤 3：结论与行动**\n该问题有效。它科学合理、适定、客观且自洽。该任务是计算物理学中一个标准工作流程的形式化。将提供一个解决方案。\n\n**基于原理的解决方案设计**\n\n目标是确定在 DFT 计算中，为使总能量和应力达到预定义的数值精度水平所需的最小 $k$点网格密度。这是一个数值求积收敛问题。\n\n在用于周期性固体的 DFT 的 Kohn-Sham 表述中，诸如总能量 $E$ 之类的可观测量是通过对第一布里渊区 (BZ) 上的量进行积分来计算的。例如，基态能量的电子部分涉及对占据带的求和，其中包含对能带能量 $\\varepsilon_{n}(\\mathbf{k})$ 的积分：\n$$ E_{elec} \\propto \\sum_{n} \\int_{\\mathrm{BZ}} w_{n}(\\mathbf{k}) \\varepsilon_{n}(\\mathbf{k}) d\\mathbf{k} $$\n其中 $w_{n}(\\mathbf{k})$ 是与占据数相关的权重。应力张量分量 $\\sigma_{ij}$ 由总能量对无穷小应变的响应导出，这也涉及 BZ 积分。\n\n在数值上，这些积分通过对一个规则的 $k$点网格进行离散求和来近似：\n$$ \\int_{\\mathrm{BZ}} f(\\mathbf{k}) d\\mathbf{k} \\approx \\sum_{i=1}^{N_k} \\omega_i f(\\mathbf{k}_i) $$\n其中 $\\mathbf{k}_i$ 是采样点，$\\omega_i$ 是积分权重，$N_k$ 是网格中的总点数。随着 $N_k$ 的增加，这种近似的精度会提高。\n\n指定的程序是此收敛原理的算法实现。我们给定了一系列在逐渐密集的 $k$点网格上执行的计算。设网格序列为 $\\{G_0, G_1, \\dots, G_{M-1}\\}$，其中每个网格 $G_i$ 由 $(k_x, k_y, k_z)_i$ 定义。对于每个网格 $G_i$，我们有相应的计算出的每个原子的总能量 $E_i$ 和应力大小 $\\sigma_i$。\n\n收敛性评估算法如下：\n1. 该过程从比较前两个网格 $G_0$ 和 $G_1$ 的结果开始，并按顺序继续。对每一对连续的网格 $(G_{i-1}, G_i)$ 进行比较，其中 $i=1, 2, \\dots, M-1$。\n\n2. 对于每个步骤 $i$，我们计算每个原子的能量绝对差 $|\\Delta E_i|$ 和应力大小绝对差 $|\\Delta \\sigma_i|$：\n$$ |\\Delta E_i| = |E_i - E_{i-1}| $$\n$$ |\\Delta \\sigma_i| = |\\sigma_i - \\sigma_{i-1}| $$\n\n3. 我们检查两个差值是否同时满足严格不等式判据：\n$$ |\\Delta E_i|  E_{tol} \\quad \\text{and} \\quad |\\Delta \\sigma_i|  \\sigma_{tol} $$\n其中公差给定为 $E_{tol} = 0.001\\,\\mathrm{eV}$ 和 $\\sigma_{tol} = 0.1\\,\\mathrm{GPa}$。\n\n4. 第一个满足这两个条件的网格 $G_i$ 被认为是收敛的网格。问题要求报告此网格的 $k$点总数 $N_k$，计算方式为 $N_k = (k_x)_i \\cdot (k_y)_i \\cdot (k_z)_i$。\n\n5. 一旦找到第一个这样的网格 $G_i$，搜索就终止，因为这对应于满足收敛标准的“最小网格”（即计算成本最低的网格）。\n\n6. 如果遍历所有从 $1$ 到 $M-1$ 的 $i$ 完成后，仍未找到任何满足两个判据的 $i$，则表示在给定的计算集内未达到收敛。在这种情况下，指定的输出为 $-1$。\n\n此过程独立应用于每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Processes a suite of DFT convergence test cases to find the minimal k-point grid satisfying\n    predefined energy and stress convergence criteria.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"grids\": [(2, 2, 2), (3, 3, 3), (4, 4, 4), (6, 6, 6), (8, 8, 8)],\n            \"energies\": [-6.3200, -6.3350, -6.3405, -6.3412, -6.3418],\n            \"stresses\": [2.05, 1.26, 0.98, 0.92, 0.91],\n        },\n        {\n            \"grids\": [(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5)],\n            \"energies\": [-7.1250, -7.1300, -7.1310, -7.1314, -7.1316],\n            \"stresses\": [0.55, 0.46, 0.42, 0.41, 0.405],\n        },\n        {\n            \"grids\": [(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (6, 6, 6)],\n            \"energies\": [-5.0000, -5.1200, -5.1550, -5.1600, -5.1622],\n            \"stresses\": [1.80, 1.40, 1.30, 1.25, 1.22],\n        },\n        {\n            \"grids\": [(2, 2, 1), (3, 3, 1), (3, 3, 2), (4, 4, 2), (4, 4, 3)],\n            \"energies\": [-6.0000, -6.0200, -6.0280, -6.0290, -6.0296],\n            \"stresses\": [1.10, 0.85, 0.80, 0.78, 0.779],\n        },\n        {\n            \"grids\": [(2, 2, 2), (3, 3, 3), (4, 4, 4), (6, 6, 6), (8, 8, 8)],\n            \"energies\": [-8.0000, -8.0006, -8.0010, -8.0012, -8.0013],\n            \"stresses\": [0.95, 0.90, 0.88, 0.879, 0.8785],\n        },\n    ]\n\n    # Convergence criteria\n    energy_threshold = 0.001  # eV per atom\n    stress_threshold = 0.1     # GPa\n\n    results = []\n\n    for case in test_cases:\n        grids = case[\"grids\"]\n        energies = case[\"energies\"]\n        stresses = case[\"stresses\"]\n        \n        found_convergence = False\n        \n        # Iterate from the second grid onwards to compare with the previous one\n        for i in range(1, len(grids)):\n            # Calculate the absolute difference in energy and stress\n            delta_e = abs(energies[i] - energies[i-1])\n            delta_s = abs(stresses[i] - stresses[i-1])\n            \n            # Check if both criteria are strictly met\n            if delta_e  energy_threshold and delta_s  stress_threshold:\n                # If converged, get the current grid and calculate total k-points\n                converged_grid = grids[i]\n                # Using np.prod is a clean way to multiply tuple elements\n                num_k_points = int(np.prod(converged_grid))\n                results.append(num_k_points)\n                found_convergence = True\n                break  # Stop at the first grid that meets the criteria\n        \n        if not found_convergence:\n            results.append(-1)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "模拟像高熵合金这样的金属体系，由于费米面的存在而带来了独特的挑战。本练习探讨了电子展宽技术的使用，这是一种管理这种复杂性的方法，并阐释了在降低数值噪音和引入非物理热展宽伪影之间的关键权衡。你将通过最小化一个模拟这种权衡的物理模型误差函数来确定最佳展宽宽度，这项技能对于获得稳定且物理上准确的结果至关重要。",
            "id": "3737495",
            "problem": "您的任务是设计一个程序，用于在密度泛函理论 (DFT) 的基态计算中，为金属高熵合金 (HEA) 确定一个最佳的电子展宽宽度。该程序基于一个原则性模型，该模型描述了展宽如何影响数值收敛和热展宽赝象。其基本依据是电子结构的 Kohn-Sham 表述及其由 Mermin 提出的有限温度推广，其中，占据数通过费米-狄拉克分布进行展宽。该程序必须是纯数学的，并对一个通过物理上合理的缩放关系校准的代理模型执行以下优化。在整个问题中，用 $\\sigma$ 表示展宽宽度，单位为电子伏特 (eV)。数值必须以浮点数形式返回，保留小数点后六位。\n\n背景和定义：\n- 在金属体系中，较小的 $\\sigma$ 会导致费米面采样不充分，从而产生含噪声的力和应力。由于化学势附近的占据数变得平滑，这种与收敛相关的噪声会随着 $\\sigma$ 的增加而减小。\n- 相反，较大的 $\\sigma$ 会在基态的力和应力中引入热展宽赝象。在 Kohn-Sham DFT 的 Mermin 推广中，有限的电子温度会使自由能相对于零温基态能量发生偏移。根据 Sommerfeld 展开，领头阶修正与 $(k_B T)^2$ 成比例，将 $k_B T$ 等同于 $\\sigma$（以 eV 为单位）可得一个偏差项，对于较小的 $\\sigma$，该项近似按 $\\sigma^2$ 增长。\n\n待优化的模型：\n- 对于给定的 HEA 和数值设置（固定的 k 点网格和平面波截断能），假设总误差的组合标量度量可以表示为\n$M(\\sigma) \\equiv A\\,\\sigma^{-p} + C\\,\\sigma^2$,\n其中 $A > 0$ 量化了收敛相关噪声的振幅（在固定权重下汇总了力和应力的贡献），$p > 0$ 控制数值噪声随 $\\sigma$ 增加而衰减的强度，而 $C > 0$ 通过与 $\\sigma$ 的二次方关系量化了力和应力中热展宽赝象的强度。该函数形式与费米面积分误差的减小以及 Sommerfeld 展开带来的二次领头阶偏差相一致。\n- 物理上可接受的展宽被限制在闭区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$（单位为 eV）内，最佳展宽宽度是 $M(\\sigma)$ 在此区间上的最小化子。\n\n您的任务：\n- 对于下面套件中的每个测试用例，计算在边界约束 $\\sigma \\in [\\sigma_{\\min}, \\sigma_{\\max}]$ 下使 $M(\\sigma)$ 最小化的最佳 $\\sigma^\\star$。以 eV 为单位返回 $\\sigma^\\star$。如果无约束最小化子落在区间之外，则选择最近的边界（$\\sigma_{\\min}$ 或 $\\sigma_{\\max}$）。将每个结果表示为四舍五入到小数点后六位的浮点数。\n\n测试套件：\n- 使用以下参数集 $(A, p, C, \\sigma_{\\min}, \\sigma_{\\max})$，所有单位均一致，使得 $M(\\sigma)$ 无量纲且 $\\sigma$ 的单位为 eV：\n  - 用例 1：$A = 0.08$，$p = 1.0$，$C = 12.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.25$ eV。\n  - 用例 2：$A = 0.00001$，$p = 1.0$，$C = 20.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.20$ eV。\n  - 用例 3：$A = 2.0$，$p = 1.0$，$C = 1.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.25$ eV。\n  - 用例 4：$A = 0.20$，$p = 1.5$，$C = 8.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.30$ eV。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的结果，结果为逗号分隔的列表，并用方括号括起来，顺序与上面给出的一致，每个值都四舍五入到小数点后六位。例如，格式必须是\n$[x_1,x_2,x_3,x_4]$\n其中每个 $x_i$ 是相应案例的最佳 $\\sigma^\\star$，单位为 eV。",
            "solution": "用户要求设计一个程序，以确定在金属高熵合金 (HEA) 的基态密度泛函理论 (DFT) 计算中，最佳的电子展宽宽度 $\\sigma$。该优化基于总误差组合度量的代理模型 $M(\\sigma)$，该模型是展宽宽度 $\\sigma$ 的函数。\n\n问题陈述中给出的总误差度量函数为：\n$$\nM(\\sigma) = A\\,\\sigma^{-p} + C\\,\\sigma^2\n$$\n其中参数 $A > 0$、$p > 0$ 和 $C > 0$ 是给定的常数。该模型代表了一种物理上合理的权衡：$A\\,\\sigma^{-p}$ 项模拟了与费米面积分相关的数值噪声，该噪声随 $\\sigma$ 的增加而减小；而 $C\\,\\sigma^2$ 项模拟了由热展宽赝象引入的偏差，该偏差随 $\\sigma$ 的增加而增大。参数 $\\sigma$ 以电子伏特 (eV) 为单位。任务是找到使 $M(\\sigma)$ 在指定的闭区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$ 内最小的 $\\sigma$ 值，我们称之为 $\\sigma^\\star$。\n\n这是一个有约束的一维优化问题。函数 $M(\\sigma)$ 对于物理相关的定义域 $\\sigma > 0$ 是连续且可微的。一个连续函数在闭有界区间上的最小值保证存在，并且要么位于区间内部的临界点（一阶导数为零处），要么位于区间的某个边界点。\n\n首先，我们通过寻找 $M(\\sigma)$ 的临界点来定位无约束最小值。这包括计算 $M(\\sigma)$ 关于 $\\sigma$ 的一阶导数并将其设为零。\n一阶导数为：\n$$\n\\frac{dM}{d\\sigma} = \\frac{d}{d\\sigma} (A\\sigma^{-p} + C\\sigma^2) = -pA\\sigma^{-p-1} + 2C\\sigma\n$$\n为评估极值的性质，我们计算二阶导数：\n$$\n\\frac{d^2M}{d\\sigma^2} = \\frac{d}{d\\sigma} (-pA\\sigma^{-p-1} + 2C\\sigma) = (-p)(-p-1)A\\sigma^{-p-2} + 2C = p(p+1)A\\sigma^{-p-2} + 2C\n$$\n考虑到问题约束 $A > 0$、$p > 0$ 和 $C > 0$，二阶导数 $\\frac{d^2M}{d\\sigma^2}$ 对所有 $\\sigma > 0$ 都是严格为正的。这证明了 $M(\\sigma)$ 在其定义域上是一个严格凸函数。因此，任何临界点都对应一个唯一的全局最小值。\n\n我们通过令 $\\frac{dM}{d\\sigma} = 0$ 来找到无约束最小化子，我们将其表示为 $\\sigma_0$：\n$$\n-pA\\sigma_0^{-p-1} + 2C\\sigma_0 = 0\n$$\n假设 $\\sigma_0 > 0$，我们可以重新整理方程：\n$$\n2C\\sigma_0 = pA\\sigma_0^{-p-1}\n$$\n两边同乘以 $\\sigma_0^{p+1}$ 得：\n$$\n2C\\sigma_0^{p+2} = pA\n$$\n最后，解出 $\\sigma_0$：\n$$\n\\sigma_0 = \\left( \\frac{pA}{2C} \\right)^{\\frac{1}{p+2}}\n$$\n这个 $\\sigma_0$ 是在没有任何约束的情况下使误差度量最小化的展宽宽度值。\n\n有约束问题的解 $\\sigma^\\star$ 必须位于区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$ 内。$M(\\sigma)$ 的凸性意味着该函数在 $\\sigma  \\sigma_0$ 时递减，在 $\\sigma > \\sigma_0$ 时递增。因此，区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$ 上的最小化子确定如下：\n1.  如果 $\\sigma_0  \\sigma_{\\min}$，则 $M(\\sigma)$ 在整个区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$ 上是递增的。因此，最小值必定出现在左边界：$\\sigma^\\star = \\sigma_{\\min}$。\n2.  如果 $\\sigma_0 > \\sigma_{\\max}$，则 $M(\\sigma)$ 在整个区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$ 上是递减的。最小值必定出现在右边界：$\\sigma^\\star = \\sigma_{\\max}$。\n3.  如果 $\\sigma_{\\min} \\le \\sigma_0 \\le \\sigma_{\\max}$，无约束最小值先验地位于可行域内，因此它也是有约束的最小值：$\\sigma^\\star = \\sigma_0$。\n\n这个逻辑等同于将 $\\sigma_0$ 的值限制在区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$ 内，这可以表示为 $\\sigma^\\star = \\max(\\sigma_{\\min}, \\min(\\sigma_0, \\sigma_{\\max}))$。\n\n我们现在将此过程应用于给定的测试用例。\n\n**用例 1：** $A = 0.08$，$p = 1.0$，$C = 12.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.25$ eV。\n$$ \\sigma_0 = \\left( \\frac{(1.0)(0.08)}{2(12.0)} \\right)^{\\frac{1}{1.0+2}} = \\left( \\frac{0.08}{24} \\right)^{\\frac{1}{3}} \\approx 0.14938016 \\text{ eV} $$\n由于 $0.01 \\le \\sigma_0 \\le 0.25$，最佳值为 $\\sigma^\\star_1 = \\sigma_0$。四舍五入到小数点后六位，结果是 $0.149380$。\n\n**用例 2：** $A = 0.00001$，$p = 1.0$，$C = 20.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.20$ eV。\n$$ \\sigma_0 = \\left( \\frac{(1.0)(0.00001)}{2(20.0)} \\right)^{\\frac{1}{1.0+2}} = \\left( \\frac{10^{-5}}{40} \\right)^{\\frac{1}{3}} \\approx 0.00629961 \\text{ eV} $$\n由于 $\\sigma_0  0.01$，最佳值被限制在下界：$\\sigma^\\star_2 = \\sigma_{\\min} = 0.01$。作为小数点后六位的浮点数，结果是 $0.010000$。\n\n**用例 3：** $A = 2.0$，$p = 1.0$，$C = 1.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.25$ eV。\n$$ \\sigma_0 = \\left( \\frac{(1.0)(2.0)}{2(1.0)} \\right)^{\\frac{1}{1.0+2}} = (1.0)^{\\frac{1}{3}} = 1.0 \\text{ eV} $$\n由于 $\\sigma_0 > 0.25$，最佳值被限制在上界：$\\sigma^\\star_3 = \\sigma_{\\max} = 0.25$。作为小数点后六位的浮点数，结果是 $0.250000$。\n\n**用例 4：** $A = 0.20$，$p = 1.5$，$C = 8.0$，$\\sigma_{\\min} = 0.01$ eV，$\\sigma_{\\max} = 0.30$ eV。\n$$ \\sigma_0 = \\left( \\frac{(1.5)(0.20)}{2(8.0)} \\right)^{\\frac{1}{1.5+2}} = \\left( \\frac{0.3}{16} \\right)^{\\frac{1}{3.5}} \\approx 0.22279580 \\text{ eV} $$\n由于 $0.01 \\le \\sigma_0 \\le 0.30$，最佳值为 $\\sigma^\\star_4 = \\sigma_0$。四舍五入到小数点后六位，结果是 $0.222796$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the optimal electronic smearing width for a series of test cases\n    based on a surrogate model for total error in DFT calculations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (A, p, C, sigma_min, sigma_max)\n    test_cases = [\n        (0.08, 1.0, 12.0, 0.01, 0.25),\n        (0.00001, 1.0, 20.0, 0.01, 0.20),\n        (2.0, 1.0, 1.0, 0.01, 0.25),\n        (0.20, 1.5, 8.0, 0.01, 0.30),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, p, C, sigma_min, sigma_max = case\n\n        # Calculate the unconstrained minimizer, sigma_0.\n        # The formula is sigma_0 = (p*A / (2*C))**(1 / (p + 2)).\n        # We ensure all constants are floats for the division and exponentiation.\n        # A, p, C are guaranteed to be positive.\n        base = (p * A) / (2.0 * C)\n        exponent = 1.0 / (p + 2.0)\n        sigma_0 = base ** exponent\n\n        # The optimal sigma_star is the unconstrained minimizer clipped to the\n        # allowed interval [sigma_min, sigma_max].\n        # This is due to the convexity of the error function M(sigma).\n        sigma_star = np.clip(sigma_0, sigma_min, sigma_max)\n        \n        results.append(sigma_star)\n\n    # Format the results as strings with six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Self-contained execution\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "密度泛函理论（DFT）的一个主要目标是预测材料的稳定性，这通常通过形成能来量化。最后一个练习聚焦于这一关键的热力学性质，并强调了选择合适元素参考态的至关重要性。你将学会如何将在方便但亚稳的参考态下计算出的形成能进行修正，以获得真实且具有物理意义的数值。",
            "id": "3737564",
            "problem": "给定一个基于密度泛函理论 (DFT) 的计算任务，用于研究高熵合金和复杂材料建模背景下的基态性质。根据第一性原理，基态总能泛函由基态电子密度最小化，而固溶体中每个原子的能量取决于其组分和选作参考的元素化学势。当元素参考态不是真实的基态相（即，使用亚稳结构）时，计算出的生成能会发生系统性偏移。您的任务是将其形式化为数学推导，并实现一个程序来量化这种效应，然后使用稳定的元素参考态来校正生成能。\n\n形式化地定义多组分固溶体的单原子生成能，从 DFT 的基态变分原理出发，根据基态单原子总能、组分分数和元素化学势进行定义。以此为基础，推导表达式，说明使用亚稳元素参考态计算的生成能与使用稳定基态参考态计算的生成能有何不同。明确指出校正项，用组分以及亚稳和稳定元素参考态能量之间的差异来表示。使用该推导设计一个算法，对测试套件中的每个案例计算以下两个量：\n- 使用亚稳元素参考态计算的未校正单原子生成能。\n- 使用稳定元素参考态计算的校正后单原子生成能。\n\n所有能量均以电子伏特/原子 (eV/atom) 表示。组分分数必须视为总和为一的无量纲数。不涉及角度。所有输出必须是数值浮点数。\n\n测试套件（每个案例提供合金的单原子能量、组分分数，以及按元素顺序排列的亚稳和稳定元素参考态能量数组，单位为 eV/atom）：\n\n- 案例 1（理想情况）：等原子比组分的三元合金。\n  - 元素：Ni, Co, Cr\n  - 合金单原子能量：$E_{\\text{alloy}} = -207.7063333333$ eV/atom\n  - 组分：$\\mathbf{x} = [\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}]$\n  - 稳定参考态：$\\boldsymbol{\\mu} = [-204.789, -206.650, -211.590]$ eV/atom\n  - 亚稳参考态：$\\tilde{\\boldsymbol{\\mu}} = [-204.777, -206.625, -211.572]$ eV/atom\n\n- 案例 2（边界情况：纯元素）：单组分固体。\n  - 元素：Co\n  - 合金单原子能量：$E_{\\text{alloy}} = -206.650$ eV/atom\n  - 组分：$\\mathbf{x} = [1.0]$\n  - 稳定参考态：$\\boldsymbol{\\mu} = [-206.650]$ eV/atom\n  - 亚稳参考态：$\\tilde{\\boldsymbol{\\mu}} = [-206.625]$ eV/atom\n\n- 案例 3（边缘情况：一个元素的亚稳参考态与稳定参考态相等，而另一个元素则不相等；同时演示符号翻转）：\n  - 元素：Ni, Co\n  - 合金单原子能量：$E_{\\text{alloy}} = -205.7095$ eV/atom\n  - 组分：$\\mathbf{x} = [0.5, 0.5]$\n  - 稳定参考态：$\\boldsymbol{\\mu} = [-204.789, -206.650]$ eV/atom\n  - 亚稳参考态：$\\tilde{\\boldsymbol{\\mu}} = [-204.789, -206.625]$ eV/atom\n\n- 案例 4（边缘情况：由于所有元素的亚稳参考态与稳定参考态相等，因此无需校正）：\n  - 元素：Fe, Ni, Cr\n  - 合金单原子能量：$E_{\\text{alloy}} = -208.468$ eV/atom\n  - 组分：$\\mathbf{x} = [\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}]$\n  - 稳定参考态：$\\boldsymbol{\\mu} = [-208.980, -204.789, -211.590]$ eV/atom\n  - 亚稳参考态：$\\tilde{\\boldsymbol{\\mu}} = [-208.980, -204.789, -211.590]$ eV/atom\n\n您的程序必须：\n- 对于每个案例，计算使用亚稳参考态的未校正单原子生成能和使用稳定参考态的校正后单原子生成能，单位均为 eV/atom。\n- 将结果汇总为单行输出，包含一个列表的列表，其中每个内部列表的形式为 $[E^{\\text{uncorr}}, E^{\\text{corr}}]$，两者均为浮点数，单位为 eV/atom，并与测试案例的顺序保持一致。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表。列表项是对应于四个案例的四个内部列表，每个内部列表本身是一对逗号分隔的浮点数，例如：`[[e11,e12],[e21,e22],[e31,e32],[e41,e42]]`。",
            "solution": "该问题要求推导并实现一种校正方法，用于处理在使用亚稳而非稳定的元素参考态能量计算多组分合金生成能时的情景。该问题的基础在于密度泛函理论 (DFT) 的变分原理，该原理指出，系统的基态总能是基态电子密度的唯一泛函，并由基态电子密度使其最小化。\n\n首先，我们形式化地定义一个 N 组分固溶体的单原子生成能 $E_f$。设该合金由一组组分分数 $\\mathbf{x} = \\{x_1, x_2, \\dots, x_N\\}$ 描述，其中 $\\sum_{i=1}^N x_i = 1$。通过第一性原理（例如，通过 DFT）计算出的合金单原子总能记为 $E_{\\text{alloy}}$。\n\n生成能表示从其处于标准参考态的组成元素形成合金时的能量变化。元素 $i$ 的标准参考态通常是其在零温零压下的热力学基态晶体结构（例如，Ni 为面心立方，Cr 为体心立方）。元素 $i$ 的化学势 $\\mu_i$ 定义为该稳定参考相的基态单原子总能。\n\n相对于这些稳定元素参考态计算的单原子生成能，我们将其记为校正后的生成能 $E^{\\text{corr}}$，定义如下：\n$$\nE^{\\text{corr}} = E_{\\text{alloy}} - \\sum_{i=1}^{N} x_i \\mu_i\n$$\n此处，$\\boldsymbol{\\mu} = \\{\\mu_1, \\mu_2, \\dots, \\mu_N\\}$ 代表元素在其稳定基态相中的单原子能量向量。\n\n在计算实践中，有时使用非真实基态的元素参考态会很方便或很有必要。例如，为了在 FCC 合金的研究中保持结构一致性，可能会对像 Cr 这样的元素使用 FCC 结构，尽管其基态是 BCC。这样的参考态是亚稳的，意味着其能量高于真实基态。我们将这些亚稳参考态能量的向量记为 $\\tilde{\\boldsymbol{\\mu}} = \\{\\tilde{\\mu}_1, \\tilde{\\mu}_2, \\dots, \\tilde{\\mu}_N\\}$。\n\n使用这些亚稳参考态计算的生成能，我们称之为未校正的生成能 $E^{\\text{uncorr}}$，由一个类似的表达式给出：\n$$\nE^{\\text{uncorr}} = E_{\\text{alloy}} - \\sum_{i=1}^{N} x_i \\tilde{\\mu}_i\n$$\n\n我们的目标是推导 $E^{\\text{corr}}$ 和 $E^{\\text{uncorr}}$ 之间的关系，并确定校正项。我们可以从第二个方程中表达出 $E_{\\text{alloy}}$：\n$$\nE_{\\text{alloy}} = E^{\\text{uncorr}} + \\sum_{i=1}^{N} x_i \\tilde{\\mu}_i\n$$\n现在，我们将这个 $E_{\\text{alloy}}$ 的表达式代入校正后生成能 $E^{\\text{corr}}$ 的方程中：\n$$\nE^{\\text{corr}} = \\left( E^{\\text{uncorr}} + \\sum_{i=1}^{N} x_i \\tilde{\\mu}_i \\right) - \\sum_{i=1}^{N} x_i \\mu_i\n$$\n通过合并求和项，我们得出最终关系式：\n$$\nE^{\\text{corr}} = E^{\\text{uncorr}} + \\sum_{i=1}^{N} x_i (\\tilde{\\mu}_i - \\mu_i)\n$$\n该方程表明，校正后的生成能等于未校正的生成能加上一个校正项 $\\Delta E_{\\text{corr}}$。该校正项是亚稳和稳定元素参考态之间能量差的组分加权平均值。对于每个元素 $i$，项 $(\\tilde{\\mu}_i - \\mu_i)$ 代表了使用亚稳结构而非稳定基态所带来的能量惩罚。根据基态的定义，由于 $\\tilde{\\mu}_i \\ge \\mu_i$，这个差值总是非负的。\n\n解决该问题的算法是这些推导公式的直接实现。对于每个测试案例，我们都给定了 $E_{\\text{alloy}}$、组分向量 $\\mathbf{x}$、稳定参考态能量 $\\boldsymbol{\\mu}$ 和亚稳参考态能量 $\\tilde{\\boldsymbol{\\mu}}$。\n\n对每个案例，算法流程如下：\n1.  计算亚稳参考态能量的组分加权平均值：$\\sum_{i} x_i \\tilde{\\mu}_i$。这可以使用点积 $\\mathbf{x} \\cdot \\tilde{\\boldsymbol{\\mu}}$ 来高效计算。\n2.  计算未校正的生成能：$E^{\\text{uncorr}} = E_{\\text{alloy}} - \\mathbf{x} \\cdot \\tilde{\\boldsymbol{\\mu}}$。\n3.  计算稳定参考态能量的组分加权平均值：$\\sum_{i} x_i \\mu_i$，或 $\\mathbf{x} \\cdot \\boldsymbol{\\mu}$。\n4.  计算校正后的生成能：$E^{\\text{corr}} = E_{\\text{alloy}} - \\mathbf{x} \\cdot \\boldsymbol{\\mu}$。\n5.  返回数对 $[E^{\\text{uncorr}}, E^{\\text{corr}}]$。\n\n此过程适用于所有提供的测试案例。\n\n对于案例 1：\n- $E_{\\text{alloy}} = -207.7063333333$ eV/atom\n- $\\mathbf{x} = [\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3}]$\n- $\\boldsymbol{\\mu} = [-204.789, -206.650, -211.590]$ eV/atom\n- $\\tilde{\\boldsymbol{\\mu}} = [-204.777, -206.625, -211.572]$ eV/atom\n加权的亚稳平均值为 $\\mathbf{x} \\cdot \\tilde{\\boldsymbol{\\mu}} = \\frac{1}{3}(-204.777 - 206.625 - 211.572) = -207.658$。\n$E^{\\text{uncorr}} = -207.7063333333 - (-207.658) \\approx -0.04833333$。\n加权的稳定平均值为 $\\mathbf{x} \\cdot \\boldsymbol{\\mu} = \\frac{1}{3}(-204.789 - 206.650 - 211.590) \\approx -207.67633333$。\n$E^{\\text{corr}} = -207.7063333333 - (-207.6763333333) = -0.03$。\n\n对于案例 2（纯元素）：\n- $E_{\\text{alloy}} = -206.650$ eV/atom (其值等于 $\\mu_1$)\n- $\\mathbf{x} = [1.0]$\n- $\\boldsymbol{\\mu} = [-206.650]$ eV/atom\n- $\\tilde{\\boldsymbol{\\mu}} = [-206.625]$ eV/atom\n$E^{\\text{uncorr}} = -206.650 - (1.0 \\times -206.625) = -0.025$。\n$E^{\\text{corr}} = -206.650 - (1.0 \\times -206.650) = 0.0$。这是符合预期的，因为纯元素由其自身形成的生成能为零。\n\n该方法通用且稳健，能够精确处理多组分体系、纯元素以及部分或全部参考态能量在两组数据中相同的情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates uncorrected and corrected formation energies for a series of alloys.\n\n    The problem defines the formation energy of an alloy as the difference between\n    the alloy's total energy per atom and the composition-weighted average of the\n    elemental chemical potentials (reference energies).\n\n    - Uncorrected formation energy (E_uncorr) uses metastable elemental references.\n    - Corrected formation energy (E_corr) uses stable ground-state elemental references.\n\n    The derivation is as follows:\n    E_uncorr = E_alloy - sum(x_i * mu_metastable_i)\n    E_corr   = E_alloy - sum(x_i * mu_stable_i)\n\n    The code implements these two formulas for each test case.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E_alloy, composition_x, stable_refs_mu, metastable_refs_tilde_mu)\n    # All energies are in eV/atom. Compositions are dimensionless fractions.\n    test_cases = [\n        # Case 1: Ternary alloy\n        (\n            -207.7063333333,\n            [1/3, 1/3, 1/3],\n            [-204.789, -206.650, -211.590],\n            [-204.777, -206.625, -211.572]\n        ),\n        # Case 2: Pure element\n        (\n            -206.650,\n            [1.0],\n            [-206.650],\n            [-206.625]\n        ),\n        # Case 3: Binary alloy with one element's refs being equal\n        (\n            -205.7095,\n            [0.5, 0.5],\n            [-204.789, -206.650],\n            [-204.789, -206.625]\n        ),\n        # Case 4: No correction needed as all refs are equal\n        (\n            -208.468,\n            [1/3, 1/3, 1/3],\n            [-208.980, -204.789, -211.590],\n            [-208.980, -204.789, -211.590]\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        e_alloy, x, mu_stable, mu_metastable = case\n        \n        # Convert lists to numpy arrays for efficient vector operations\n        x_np = np.array(x)\n        mu_stable_np = np.array(mu_stable)\n        mu_metastable_np = np.array(mu_metastable)\n\n        # Calculate the composition-weighted average of reference energies\n        # using the dot product.\n        weighted_mu_stable = np.dot(x_np, mu_stable_np)\n        weighted_mu_metastable = np.dot(x_np, mu_metastable_np)\n\n        # Calculate the uncorrected formation energy using metastable references\n        e_uncorr = e_alloy - weighted_mu_metastable\n\n        # Calculate the corrected formation energy using stable references\n        e_corr = e_alloy - weighted_mu_stable\n        \n        results.append([e_uncorr, e_corr])\n\n    # Format the final output string exactly as required.\n    # The string must be in the format: [[val1,val2],[val3,val4],...]\n    inner_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}