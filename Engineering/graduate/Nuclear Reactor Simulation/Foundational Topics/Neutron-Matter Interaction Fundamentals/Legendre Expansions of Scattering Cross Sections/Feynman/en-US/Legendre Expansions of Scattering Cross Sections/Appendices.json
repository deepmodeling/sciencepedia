{
    "hands_on_practices": [
        {
            "introduction": "Idealized mathematical constructs like the Dirac delta function are invaluable tools for gaining deep physical insights. This first practice challenges you to derive the Legendre moments for a sharply peaked scattering kernel modeled by a delta function, $\\delta(\\mu - \\mu_0)$. The exercise not only demonstrates a fundamental analytical technique using the sifting property but, more importantly, reveals the inherent convergence limitations of polynomial expansions when approximating localized phenomena—a crucial concept for interpreting results from practical transport codes. ",
            "id": "4233070",
            "problem": "Consider one-speed neutron transport in an infinite, homogeneous medium in slab geometry, where the macroscopic differential scattering cross section depends only on the cosine of the scattering angle, denoted by $\\mu \\in [-1,1]$. Let the cross section be sharply forward-peaked and modeled by a Dirac delta distribution, $\\sigma(\\mu) = \\sigma_{s} \\,\\delta(\\mu - \\mu_{0})$, where $\\sigma_{s}  0$ is a constant and $\\mu_{0} \\in [-1,1]$ is fixed. In neutron transport, anisotropic scattering in slab geometry is commonly represented by expanding $\\sigma(\\mu)$ in the basis of Legendre polynomials $\\{P_{l}(\\mu)\\}_{l=0}^{\\infty}$ on $[-1,1]$, which are orthogonal in the sense that\n$$\n\\int_{-1}^{1} P_{l}(\\mu)\\,P_{m}(\\mu)\\,d\\mu = \\frac{2}{2l+1}\\,\\delta_{lm}.\n$$\nStarting from the completeness of the Legendre basis and the orthogonality relation above as fundamental inputs, derive the Legendre expansion coefficients $\\sigma_{l}$ defined by the representation\n$$\n\\sigma(\\mu) = \\sum_{l=0}^{\\infty} (2l+1)\\,\\sigma_{l}\\,P_{l}(\\mu).\n$$\nThen, analyze the large-order behavior of $\\sigma_{l}$ using asymptotic properties of Legendre polynomials for $l \\to \\infty$ to discuss the convergence rate of the truncated Spherical Harmonics of degree $N$ approximation (P$_{N}$) to the delta-like kernel, comparing the regimes $\\mu_{0} \\in (-1,1)$ and $\\mu_{0} = 1$. Assume angles are measured in radians. Express your final answer as a closed-form symbolic expression for $\\sigma_{l}$ in terms of $\\sigma_{s}$, $\\mu_{0}$, and $P_{l}$.",
            "solution": "The objective is to derive the Legendre expansion coefficients, $\\sigma_{l}$, for a scattering cross section modeled by a Dirac delta distribution, and to analyze the convergence properties of the resulting series.\n\nThe scattering cross section is given by $\\sigma(\\mu) = \\sigma_{s} \\,\\delta(\\mu - \\mu_{0})$, where $\\sigma_{s}  0$ is a constant, and $\\mu_{0} \\in [-1,1]$ is the cosine of the scattering angle. The expansion of $\\sigma(\\mu)$ in the basis of Legendre polynomials, $P_{l}(\\mu)$, is given as:\n$$\n\\sigma(\\mu) = \\sum_{m=0}^{\\infty} (2m+1)\\,\\sigma_{m}\\,P_{m}(\\mu)\n$$\nHere, the summation index is denoted by $m$ to distinguish it from the index $l$ of the coefficient we aim to determine. The Legendre polynomials are orthogonal on the interval $[-1,1]$ and satisfy the relation:\n$$\n\\int_{-1}^{1} P_{l}(\\mu)\\,P_{m}(\\mu)\\,d\\mu = \\frac{2}{2l+1}\\,\\delta_{lm}\n$$\nwhere $\\delta_{lm}$ is the Kronecker delta.\n\nTo determine the coefficient $\\sigma_{l}$ for an arbitrary non-negative integer $l$, we exploit the orthogonality property. We multiply both sides of the series representation for $\\sigma(\\mu)$ by $P_{l}(\\mu)$ and integrate over the domain $\\mu \\in [-1, 1]$.\n\nThe left-hand side (LHS) of this operation becomes:\n$$\n\\text{LHS} = \\int_{-1}^{1} \\sigma(\\mu) P_{l}(\\mu) \\,d\\mu\n$$\nSubstituting the expression for $\\sigma(\\mu)$:\n$$\n\\text{LHS} = \\int_{-1}^{1} \\sigma_{s} \\delta(\\mu - \\mu_{0}) P_{l}(\\mu) \\,d\\mu\n$$\nBy applying the sifting property of the Dirac delta function, which states that $\\int f(x) \\delta(x-a) \\,dx = f(a)$ for an integration domain containing the point $a$, we evaluate the integral. Since $\\mu_{0} \\in [-1,1]$, the condition is satisfied, and we get:\n$$\n\\text{LHS} = \\sigma_{s} P_{l}(\\mu_{0})\n$$\nThe right-hand side (RHS) of the operation is:\n$$\n\\text{RHS} = \\int_{-1}^{1} \\left( \\sum_{m=0}^{\\infty} (2m+1)\\,\\sigma_{m}\\,P_{m}(\\mu) \\right) P_{l}(\\mu) \\,d\\mu\n$$\nAssuming the series converges sufficiently well to permit the interchange of summation and integration, we have:\n$$\n\\text{RHS} = \\sum_{m=0}^{\\infty} (2m+1)\\,\\sigma_{m} \\int_{-1}^{1} P_{m}(\\mu) P_{l}(\\mu) \\,d\\mu\n$$\nUsing the orthogonality relation for the Legendre polynomials:\n$$\n\\text{RHS} = \\sum_{m=0}^{\\infty} (2m+1)\\,\\sigma_{m} \\left( \\frac{2}{2l+1}\\,\\delta_{lm} \\right)\n$$\nThe presence of the Kronecker delta, $\\delta_{lm}$, causes all terms in the infinite sum to vanish except for the one where $m=l$. The expression thus simplifies to:\n$$\n\\text{RHS} = (2l+1)\\,\\sigma_{l} \\left( \\frac{2}{2l+1} \\right) = 2\\sigma_{l}\n$$\nBy equating the results for the LHS and RHS, we find the relationship:\n$$\n\\sigma_{s} P_{l}(\\mu_{0}) = 2\\sigma_{l}\n$$\nSolving this equation for $\\sigma_{l}$ yields the closed-form symbolic expression for the Legendre expansion coefficients:\n$$\n\\sigma_{l} = \\frac{\\sigma_{s}}{2} P_{l}(\\mu_{0})\n$$\nThis expression constitutes the required final answer.\n\nFor the analysis of the large-order behavior, we examine the asymptotics of $\\sigma_{l}$ as $l \\to \\infty$. The convergence of the truncated $P_{N}$ approximation, $\\sigma_{N}(\\mu) = \\sum_{l=0}^{N} (2l+1)\\,\\sigma_{l}\\,P_{l}(\\mu)$, hinges on the rate at which $\\sigma_{l}$ decays.\n\nCase 1: $\\mu_{0} \\in (-1,1)$.\nIn this scenario, we can write $\\mu_{0} = \\cos(\\theta_{0})$ for some angle $\\theta_{0} \\in (0, \\pi)$. The asymptotic behavior of Legendre polynomials for large $l$ is given by Hilb's formula:\n$$\nP_{l}(\\cos\\theta_{0}) \\approx \\sqrt{\\frac{2}{\\pi l \\sin\\theta_{0}}} \\cos\\left( \\left(l + \\frac{1}{2}\\right)\\theta_{0} - \\frac{\\pi}{4} \\right) + O(l^{-3/2})\n$$\nThis shows that $P_{l}(\\mu_{0})$ decays as $l^{-1/2}$. Consequently, the coefficients $\\sigma_{l} = \\frac{\\sigma_{s}}{2} P_{l}(\\mu_{0})$ also decay as $O(l^{-1/2})$. This is an extremely slow rate of decay, which implies that the $P_{N}$ series converges very slowly. A large number of terms, i.e., a high-order $N$, is necessary to achieve a reasonable approximation of the delta function, a pathology characteristic of expanding sharp, localized functions in a basis of global polynomials.\n\nCase 2: $\\mu_{0} = 1$ (pure forward scattering).\nFor this limiting case, we use the known identity $P_{l}(1) = 1$ for all $l \\ge 0$. The expansion coefficients become:\n$$\n\\sigma_{l} = \\frac{\\sigma_{s}}{2} P_{l}(1) = \\frac{\\sigma_{s}}{2}\n$$\nThe coefficients are constant and do not approach zero as $l \\to \\infty$. The condition for the convergence of the series is not met. Thus, the Legendre series expansion fails to represent the delta function at an endpoint of the interval. Practically, this severe limitation of the $P_{N}$ method is often managed by using a \"transport correction,\" where the forward-peaked part of the scattering is removed from the expansion and treated as a modification to the total cross section.",
            "answer": "$$\n\\boxed{\\frac{\\sigma_{s}}{2} P_{l}(\\mu_{0})}\n$$"
        },
        {
            "introduction": "While analytical derivations provide foundational understanding, real-world cross sections are typically provided as complex functions or tabulated data, making numerical integration essential. This practice transitions from theory to application by guiding you through the design of a Gauss-Legendre quadrature, the industry-standard method for computing Legendre moments, $\\sigma_l$, with high efficiency and accuracy. By completing this exercise, you will master the practical computation of scattering moments and understand the powerful mathematical principles that underpin the precision of the P$_N$ method. ",
            "id": "4233098",
            "problem": "You are tasked with designing and implementing a Gauss–Legendre quadrature for computing scattering Legendre moments in the context of neutron transport, and justifying the number of points required to exactly integrate polynomials up to a specified degree. Consider the one-dimensional cosine of scattering angle, denoted by $\\mu \\in [-1,1]$, and let $\\{P_l(\\mu)\\}_{l=0}^{\\infty}$ be the Legendre polynomials on $[-1,1]$, which satisfy the orthogonality relation\n$$\n\\int_{-1}^{1} P_l(\\mu) P_{m}(\\mu)\\,d\\mu = \\frac{2}{2l+1}\\,\\delta_{lm},\n$$\nwhere $\\delta_{lm}$ is the Kronecker delta.\n\nIn multigroup neutron transport, the $l$-th scattering Legendre moment of the scattering cross section $\\sigma_s(\\mu)$ is defined by\n$$\n\\sigma_l = \\frac{2l+1}{2}\\int_{-1}^{1} \\sigma_s(\\mu)\\,P_l(\\mu)\\,d\\mu.\n$$\n\nThe Gauss–Legendre quadrature on $[-1,1]$ with $N$ points provides nodes $\\{\\mu_i\\}_{i=1}^{N}$ and positive weights $\\{w_i\\}_{i=1}^{N}$ such that\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\sum_{i=1}^{N} w_i\\,p(\\mu_i)\n$$\nfor any polynomial $p(\\mu)$ of degree at most $2N-1$.\n\nYour tasks are:\n- Construct a Gauss–Legendre quadrature with $N=L+1$ points and use it to approximate $\\sigma_l$ for $l=0,1,\\dots,L$ via\n$$\n\\sigma_l^{(Q)} = \\frac{2l+1}{2}\\sum_{i=1}^{N} w_i\\,\\sigma_s(\\mu_i)\\,P_l(\\mu_i).\n$$\n- Justify, using first principles, why $N=L+1$ points exactly integrate any polynomial of degree at most $2L$ on $[-1,1]$.\n- Validate the quadrature by comparing against analytic integrals when available, or by using a higher-order Gauss–Legendre rule that is provably exact for the integrand class.\n\nAngle units: all angles are represented through their cosine $\\mu$, which is dimensionless. No other physical units are required for this problem.\n\nYour program must implement the following test suite and produce results in the exact final output format described below.\n\nTest Suite:\n1. Let $L=3$ and define $\\sigma_s(\\mu)$ in the Legendre basis by\n   $$\n   \\sigma_s(\\mu) = a_0 P_0(\\mu) + a_1 P_1(\\mu) + a_2 P_2(\\mu) + a_3 P_3(\\mu),\n   $$\n   with coefficients $a_0=1.2$, $a_1=0.5$, $a_2=-0.3$, $a_3=0.25$. Compute and return the list $[\\sigma_0^{(Q)},\\sigma_1^{(Q)},\\sigma_2^{(Q)},\\sigma_3^{(Q)}]$ using $N=L+1$ points.\n\n2. Boundary case: Let $L=0$ and $\\sigma_s(\\mu)=c$ with $c=2.5$. Return $\\sigma_0^{(Q)}$ using $N=L+1$ points.\n\n3. Edge case stressing integrand degree: Let $L=3$ and define $\\sigma_s(\\mu)$ in the monomial basis by\n   $$\n   \\sigma_s(\\mu) = c_0 + c_1 \\mu + c_2 \\mu^2 + c_3 \\mu^3 + c_4 \\mu^4 + c_5 \\mu^5 + c_6 \\mu^6,\n   $$\n   with coefficients $c_0=0.8$, $c_1=-0.4$, $c_2=0.3$, $c_3=0.2$, $c_4=-0.1$, $c_5=0.05$, $c_6=0.02$. For $l=0,1,2,3$, compute $\\sigma_l^{(Q)}$ using $N=L+1$ points. Also compute a reference $\\sigma_l^{(\\mathrm{ref})}$ using a Gauss–Legendre quadrature with $N_{\\mathrm{ref}}$ points chosen minimally so that all products $\\sigma_s(\\mu) P_l(\\mu)$ of degree up to $3L$ are integrated exactly, i.e.,\n$$\n2N_{\\mathrm{ref}}-1 \\ge 3L.\n$$\nReturn the maximum absolute error $\\max_{0\\le l \\le L} |\\sigma_l^{(Q)} - \\sigma_l^{(\\mathrm{ref})}|$.\n\n4. Property check: Let $L=4$ and set $N=L+1=5$. For each monomial $p_n(\\mu)=\\mu^n$ with $n=0,1,\\dots,2L$, use the $N$-point Gauss–Legendre quadrature to evaluate $\\int_{-1}^{1} p_n(\\mu)\\,d\\mu$. Compare each to the exact analytic integral\n$$\n\\int_{-1}^{1} \\mu^n\\,d\\mu = \\begin{cases}\n0,\\text{if $n$ is odd},\\\\\n\\frac{2}{n+1},\\text{if $n$ is even}.\n\\end{cases}\n$$\nReturn a boolean that is $\\mathrm{True}$ if and only if all monomial integrals match the analytic values within an absolute tolerance of $10^{-12}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The elements correspond to the four test cases above, in order:\n- Test 1: a list of $L+1$ floating-point values $[\\sigma_0^{(Q)},\\dots,\\sigma_L^{(Q)}]$,\n- Test 2: a single floating-point value $\\sigma_0^{(Q)}$,\n- Test 3: a single floating-point value equal to the maximum absolute error,\n- Test 4: a single boolean value indicating the property check result.\n\nFor example, the output must have the shape\n$$\n[[\\cdots], \\cdots, \\cdots, True],\n$$\nwith no additional text printed.",
            "solution": "The problem is valid as it is scientifically grounded in numerical methods and nuclear engineering, is well-posed with specific inputs and a clear objective, and is free from any scientific or factual inaccuracies, ambiguities, or contradictions. We may therefore proceed with a solution.\n\nThe core of this problem is the application of Gauss–Legendre quadrature to compute the Legendre moments $\\sigma_l$ of a scattering cross section $\\sigma_s(\\mu)$. We will first provide the theoretical justification for the properties of this quadrature and then outline the algorithmic implementation for each test case.\n\n**Theoretical Justification: Accuracy of Gauss–Legendre Quadrature**\n\nThe problem asks for a justification, from first principles, of why an $N$-point Gauss–Legendre quadrature rule exactly integrates any polynomial of degree up to $2N-1$. We are specifically interested in the case where $N=L+1$, for which the quadrature is exact for polynomials of degree up to $2(L+1)-1 = 2L+1$. This naturally implies exactness for polynomials of degree up to $2L$, as stated in the problem description.\n\nLet the $N$-point Gauss–Legendre quadrature nodes $\\{\\mu_i\\}_{i=1}^N$ be the $N$ distinct roots of the Legendre polynomial $P_N(\\mu)$, which is a polynomial of degree $N$. Let the corresponding weights be $\\{w_i\\}_{i=1}^N$. Let $p(\\mu)$ be an arbitrary polynomial of degree at most $2N-1$.\n\nWe can perform polynomial long division of $p(\\mu)$ by $P_N(\\mu)$ to obtain a quotient $q(\\mu)$ and a remainder $r(\\mu)$:\n$$\np(\\mu) = q(\\mu)P_N(\\mu) + r(\\mu)\n$$\nSince $\\deg(p) \\le 2N-1$ and $\\deg(P_N) = N$, the degree of the quotient must be $\\deg(q) \\le (2N-1) - N = N-1$, and the degree of the remainder must be $\\deg(r) \\le N-1$.\n\nNow, let us integrate $p(\\mu)$ over the interval $[-1, 1]$:\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\int_{-1}^{1} q(\\mu)P_N(\\mu)\\,d\\mu + \\int_{-1}^{1} r(\\mu)\\,d\\mu\n$$\nThe Legendre polynomials $\\{P_k(\\mu)\\}$ form an orthogonal basis on $[-1, 1]$. A key property stemming from this orthogonality is that $\\int_{-1}^{1} P_k(\\mu)P_m(\\mu)\\,d\\mu = 0$ for $k \\ne m$. Consequently, $P_N(\\mu)$ is orthogonal to any polynomial of degree less than $N$. Since $\\deg(q) \\le N-1$, $q(\\mu)$ can be expressed as a linear combination of Legendre polynomials $P_k(\\mu)$ for $k \\in \\{0, 1, \\dots, N-1\\}$. Due to orthogonality, the integral of the product of $q(\\mu)$ and $P_N(\\mu)$ is zero:\n$$\n\\int_{-1}^{1} q(\\mu)P_N(\\mu)\\,d\\mu = 0\n$$\nThis simplifies the integral of $p(\\mu)$ to:\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\int_{-1}^{1} r(\\mu)\\,d\\mu\n$$\nNext, let's evaluate the quadrature sum for $p(\\mu)$:\n$$\n\\sum_{i=1}^{N} w_i\\,p(\\mu_i) = \\sum_{i=1}^{N} w_i \\left( q(\\mu_i)P_N(\\mu_i) + r(\\mu_i) \\right)\n$$\nBy definition, the quadrature nodes $\\mu_i$ are the roots of $P_N(\\mu)$, so $P_N(\\mu_i) = 0$ for all $i=1, \\dots, N$. The sum thus reduces to:\n$$\n\\sum_{i=1}^{N} w_i\\,p(\\mu_i) = \\sum_{i=1}^{N} w_i\\,r(\\mu_i)\n$$\nThe weights $w_i$ are constructed precisely so that the $N$-point quadrature rule is exact for all polynomials of degree up to $N-1$. Since $\\deg(r) \\le N-1$, the quadrature evaluates the integral of $r(\\mu)$ exactly:\n$$\n\\int_{-1}^{1} r(\\mu)\\,d\\mu = \\sum_{i=1}^{N} w_i\\,r(\\mu_i)\n$$\nBy combining these results, we establish the equality:\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\int_{-1}^{1} r(\\mu)\\,d\\mu = \\sum_{i=1}^{N} w_i\\,r(\\mu_i) = \\sum_{i=1}^{N} w_i\\,p(\\mu_i)\n$$\nThis proves that the $N$-point Gauss–Legendre quadrature is exact for any polynomial $p(\\mu)$ of degree at most $2N-1$. For the case $N = L+1$, the rule is exact for polynomials of degree up to $2L+1$.\n\n**Algorithmic Design**\n\nThe main computational task is to evaluate the scattering moments $\\sigma_l$ using the quadrature-based approximation:\n$$\n\\sigma_l^{(Q)} = \\frac{2l+1}{2}\\sum_{i=1}^{N} w_i\\,\\sigma_s(\\mu_i)\\,P_l(\\mu_i)\n$$\nThe implementation will rely on `scipy` for standard numerical routines.\n\n1.  **Gauss-Legendre Quadrature**: For a given number of points $N$, the nodes $\\{\\mu_i\\}$ and weights $\\{w_i\\}$ will be obtained using the `scipy.special.roots_legendre(N)` function.\n2.  **Legendre Polynomials**: The values of $P_l(\\mu_i)$ will be calculated using `scipy.special.eval_legendre(l, mu_array)`.\n3.  **Cross Section**: The scattering cross section $\\sigma_s(\\mu)$ must be evaluated at each node $\\mu_i$. The functional form of $\\sigma_s(\\mu)$ is provided in each test case.\n4.  **Summation**: The sum over $i$ will be performed using `numpy`'s efficient vector operations, typically `numpy.dot(weights, integrand_values)`.\n\nWe now detail the approach for each test case.\n\n**Test Case 1**: We are given $L=3$ and $\\sigma_s(\\mu)$ as a degree-3 polynomial in the Legendre basis. We use an $N=L+1=4$ point quadrature. The integrand for the $l$-th moment is $\\sigma_s(\\mu)P_l(\\mu)$. The maximum degree of this integrand occurs for $l=3$, which is $\\deg(P_3(\\mu)P_3(\\mu)) = 3+3=6$. Our $N=4$ point quadrature is exact for polynomials up to degree $2(4)-1=7$. Since $6 \\le 7$, the quadrature will compute the moments exactly. The exact moments are known to be the coefficients $a_l$ themselves due to the orthogonality relation. The algorithm will compute $\\sigma_l^{(Q)}$ for $l=0,1,2,3$ and the result should match $[1.2, 0.5, -0.3, 0.25]$ to within machine precision.\n\n**Test Case 2**: With $L=0$, we require an $N=L+1=1$ point quadrature. Here $\\sigma_s(\\mu)=2.5$, a constant (degree-0 polynomial). The integrand for $\\sigma_0^{(Q)}$ is $\\sigma_s(\\mu)P_0(\\mu) = 2.5 \\times 1 = 2.5$, which is a degree-0 polynomial. The $N=1$ point rule is exact for polynomials up to degree $2(1)-1=1$. The single node is $\\mu_1=0$ with weight $w_1=2$. The calculation is $\\sigma_0^{(Q)} = \\frac{1}{2} w_1 \\sigma_s(\\mu_1) P_0(\\mu_1) = \\frac{1}{2}(2)(2.5)(1) = 2.5$.\n\n**Test Case 3**: We are given $L=3$ and a degree-6 polynomial $\\sigma_s(\\mu)$ in the monomial basis. We first compute $\\sigma_l^{(Q)}$ with an $N=L+1=4$ point quadrature. The maximum integrand degree is for $l=3$, which is $\\deg(\\sigma_s(\\mu)P_3(\\mu)) = 6+3=9$. The $N=4$ quadrature rule is only exact up to degree $7$, so it will produce an approximate result. To find the error, we compute a reference solution $\\sigma_l^{(\\mathrm{ref})}$ using a quadrature order high enough to be exact. The required order $N_{\\mathrm{ref}}$ must satisfy $2N_{\\mathrm{ref}}-1 \\ge 9$, leading to a minimal $N_{\\mathrm{ref}}=5$. We will compute the moments with both $N=4$ and $N=5$ points and then find the maximum absolute difference between the two sets of results.\n\n**Test Case 4**: This case serves as a direct validation of the fundamental property of Gauss–Legendre quadrature. We use $L=4$, so $N=L+1=5$. The quadrature should be exact for polynomials of degree up to $2(5)-1=9$. We test this by integrating the monomials $\\mu^n$ for $n=0, 1, \\dots, 2L=8$. The highest degree is $8$, which is less than $9$. For each $n$, we compute the integral using the quadrature sum $\\sum_{i=1}^5 w_i\\mu_i^n$ and compare it against the known analytic result, which is $2/(n+1)$ for even $n$ and $0$ for odd $n$. The test passes if all computed integrals are within a tolerance of $10^{-12}$ of their analytic values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef calculate_sigma_l(l_max, n_pts, sigma_s_func):\n    \"\"\"\n    Calculates Legendre moments sigma_l for l=0,...,l_max using an n_pts\n    Gauss-Legendre quadrature.\n\n    Args:\n        l_max (int): Maximum Legendre order to compute.\n        n_pts (int): Number of quadrature points.\n        sigma_s_func (callable): Function that takes an array of mu values and\n                                 returns the cross section sigma_s(mu).\n\n    Returns:\n        list: A list of the computed moments [sigma_0, ..., sigma_l_max].\n    \"\"\"\n    mus, weights = special.roots_legendre(n_pts)\n    sigma_s_vals = sigma_s_func(mus)\n\n    sigmas = []\n    for l in range(l_max + 1):\n        # Evaluate P_l at all quadrature nodes\n        pl_vals = special.eval_legendre(l, mus)\n        \n        # Form the integrand for the moment calculation\n        integrand_vals = sigma_s_vals * pl_vals\n        \n        # Perform the quadrature sum\n        integral = np.dot(weights, integrand_vals)\n        \n        # Apply the normalization factor\n        sigma_l = (2 * l + 1) / 2.0 * integral\n        sigmas.append(sigma_l)\n        \n    return sigmas\n\n\ndef test_case_1():\n    \"\"\"\n    Test Case 1: sigma_s is a polynomial of degree L=3 in Legendre basis.\n    The N=L+1 quadrature is exact.\n    \"\"\"\n    L = 3\n    N = L + 1\n    a_coeffs = np.array([1.2, 0.5, -0.3, 0.25])\n\n    def sigma_s_mu(mu):\n        # Using numpy's broadcasting for evaluation at multiple points\n        L_vals = np.arange(len(a_coeffs))\n        mu_reshaped = mu[:, np.newaxis]\n        pl_matrix = special.eval_legendre(L_vals, mu_reshaped)\n        return pl_matrix @ a_coeffs\n\n    sigmas = calculate_sigma_l(L, N, sigma_s_mu)\n    return sigmas\n\n\ndef test_case_2():\n    \"\"\"\n    Test Case 2: Boundary case with L=0, constant cross section.\n    \"\"\"\n    L = 0\n    N = L + 1\n    c = 2.5\n\n    def sigma_s_mu(mu):\n        return np.full_like(mu, c)\n\n    sigmas = calculate_sigma_l(L, N, sigma_s_mu)\n    return sigmas[0]\n\n\ndef test_case_3():\n    \"\"\"\n    Test Case 3: Stress test where N=L+1 is not sufficient for exactness.\n    \"\"\"\n    L = 3\n    c_coeffs = np.array([0.8, -0.4, 0.3, 0.2, -0.1, 0.05, 0.02])\n\n    def sigma_s_mu(mu):\n        # Note: np.polyval expects coefficients from highest power to lowest\n        return np.polyval(c_coeffs[::-1], mu)\n\n    # Approximate calculation with N = L+1 points\n    N_q = L + 1\n    sigmas_q = calculate_sigma_l(L, N_q, sigma_s_mu)\n\n    # Reference calculation with minimally exact number of points\n    # deg(sigma_s) = 6, max deg(P_l) = 3. Integrand deg = 9.\n    # 2*N_ref - 1  9 ==> N_ref  5.\n    N_ref = 5\n    sigmas_ref = calculate_sigma_l(L, N_ref, sigma_s_mu)\n\n    # Calculate max absolute error\n    error = np.max(np.abs(np.array(sigmas_q) - np.array(sigmas_ref)))\n    return error\n\n\ndef test_case_4():\n    \"\"\"\n    Test Case 4: Property check of the quadrature rule itself.\n    \"\"\"\n    L = 4\n    N = L + 1  # 5 points\n    tol = 1e-12\n\n    mus, weights = special.roots_legendre(N)\n    \n    # The N=5 rule is exact for polynomials up to degree 2*5-1=9\n    # We test for monomials up to degree 2L=8\n    max_n = 2 * L\n    \n    for n in range(max_n + 1):\n        # Quadrature sum for integral of mu^n\n        integrand_vals = mus**n\n        quad_integral = np.dot(weights, integrand_vals)\n        \n        # Analytic result\n        if n % 2 != 0:\n            analytic_integral = 0.0\n        else:\n            analytic_integral = 2.0 / (n + 1)\n        \n        if abs(quad_integral - analytic_integral)  tol:\n            return False\n            \n    return True\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    results = [\n        test_case_1(),\n        test_case_2(),\n        test_case_3(),\n        test_case_4(),\n    ]\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n\n```"
        },
        {
            "introduction": "Having learned to compute scattering moments, we now explore their ultimate purpose: solving the neutron transport equation. This capstone exercise demonstrates how the fidelity of the Legendre expansion, determined by the truncation order $N$, directly impacts the accuracy of a full transport simulation. You will implement a P$_N$ solver to investigate how $N$ affects the computed scalar flux, $\\phi_0(x)$, and current, $\\phi_1(x)$, providing a tangible understanding of the trade-offs between computational cost and physical accuracy in modeling anisotropic scattering. ",
            "id": "4233106",
            "problem": "Consider a steady-state, monoenergetic neutron transport problem in one-dimensional slab geometry. The unknown angular flux is denoted by $\\psi(x,\\mu)$ where $x$ is the spatial coordinate (in $\\mathrm{cm}$) and $\\mu$ is the direction cosine (dimensionless). The total macroscopic cross section is $\\Sigma_t$ (in $\\mathrm{cm^{-1}}$). The scattering kernel is represented by a Legendre expansion with moments $\\Sigma_{s,\\ell}$ such that the scattering source term is consistent with the spherical harmonics method (P$_N$), where the angular flux is expanded as $\\psi(x,\\mu) \\approx \\sum_{\\ell=0}^{N} (2\\ell+1)\\,\\phi_\\ell(x)\\,P_\\ell(\\mu)$ with moments $\\phi_\\ell(x)$ (the scalar flux is $\\phi_0(x)$ and the current is $\\phi_1(x)$). The microscopic physics is parameterized by a forward-peaked kernel where the Legendre moments of the scattering cross section satisfy $\\Sigma_{s,\\ell} = \\Sigma_{s,0}\\,g^\\ell$ with $0 \\le g  1$, $\\Sigma_{s,0} = c\\,\\Sigma_t$, and $0  c  1$. This form is consistent with a Henyey–Greenstein type phase function where Legendre moments decay geometrically with $\\ell$.\n\nAssume an isotropic volumetric source with spatial dependence $Q(x) = Q_0 \\cos(k x)$ where $Q_0$ is the zeroth Legendre moment of the source (in $\\mathrm{n\\;cm^{-3}\\;s^{-1}}$), and $k$ is the wavenumber (in radians per $\\mathrm{cm}$). Using the spherical harmonics method (P$_N$) truncated at order $N$, the moment equations in slab geometry can be obtained by projecting the neutron transport equation onto Legendre polynomials, leading to a coupled system for $\\{\\phi_\\ell(x)\\}_{\\ell=0}^N$ with nearest-neighbor coupling from the streaming term and diagonal terms containing $\\Sigma_t$ and $\\Sigma_{s,\\ell}$. Under harmonic forcing $Q(x) = \\Re\\{Q_0 e^{i k x}\\}$, it is appropriate to seek harmonic responses $\\phi_\\ell(x) = \\Re\\{\\hat{\\phi}_\\ell e^{i k x}\\}$, which transforms spatial derivatives to algebraic factors $i k$.\n\nStarting from the fundamental neutron balance equation and standard orthogonality of Legendre polynomials, derive the algebraic system for the complex amplitudes $\\{\\hat{\\phi}_\\ell\\}_{\\ell=0}^{N}$ under the P$_N$ closure $\\hat{\\phi}_{-1} = 0$ and $\\hat{\\phi}_{N+1} = 0$. Then, design and implement a numerical experiment that computes the P$_1$, P$_3$, and P$_7$ solutions for the scalar flux amplitude $\\hat{\\phi}_0$ and current amplitude $\\hat{\\phi}_1$ for a set of forward-peaked kernels, and quantifies the convergence of these amplitudes with respect to $N$ by comparison to a high-order reference solution at $N = N_{\\mathrm{ref}}$.\n\nThe numerical experiment must adhere to the following requirements:\n\n- Use the coupled moment equations formed by the spherical harmonics method (P$_N$) in slab geometry with harmonic source. You must construct the $(N+1)\\times(N+1)$ linear system for the complex amplitudes $\\{\\hat{\\phi}_\\ell\\}$, with nearest-neighbor couplings proportional to $i k$ from the streaming term and diagonal entries containing $(2\\ell+1)\\left(\\Sigma_t - \\Sigma_{s,\\ell}\\right)$. Take the source moment vector with only the zeroth component nonzero, equal to $Q_0$.\n- For each $N \\in \\{1,3,7\\}$, solve for $\\hat{\\phi}_0$ and $\\hat{\\phi}_1$, and compute the relative errors of these complex amplitudes with respect to a reference P$_{N_{\\mathrm{ref}}}$ solution with $N_{\\mathrm{ref}} = 31$. The relative error for a complex amplitude $\\hat{\\phi}$ must be defined as $|\\hat{\\phi}^{(N)} - \\hat{\\phi}^{(N_{\\mathrm{ref}})}| / |\\hat{\\phi}^{(N_{\\mathrm{ref}})}|$, which is dimensionless.\n- Express all cross sections in $\\mathrm{cm^{-1}}$, the wavenumber $k$ in radians per $\\mathrm{cm}$, the source $Q_0$ in $\\mathrm{n\\;cm^{-3}\\;s^{-1}}$, and report the relative errors (dimensionless). Angles are not directly reported; the direction cosine $\\mu$ is dimensionless, and spatial harmonic wavenumber $k$ uses radians.\n- Provide a test suite of parameter sets $(\\Sigma_t, c, g, k, Q_0)$ that explores different regimes, including a general case, diffusion-like behavior, extreme forward-peaking, isotropic scattering control, and increased absorption. Specifically, use:\n    - Case A (general forward-peaked): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0.9,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case B (diffusion-like $k \\to 0$): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0.9,\\,10^{-3}\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case C (extreme forward-peaked and higher spatial frequency): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.95,\\,0.99,\\,2\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case D (isotropic scattering control): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case E (increased absorption): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.3,\\,0.9,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output the six floats in the order $[\\text{err}(\\hat{\\phi}_0^{\\mathrm{P1}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P1}}), \\text{err}(\\hat{\\phi}_0^{\\mathrm{P3}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P3}}), \\text{err}(\\hat{\\phi}_0^{\\mathrm{P7}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P7}})]$, and concatenate all cases into one flat list. The relative errors are dimensionless floats. The final output is therefore a single bracketed list of $30$ floats.\n\nThe objective is to quantify, from first principles, how the spherical harmonics method (P$_N$) converges for a forward-peaked scattering kernel, and how the scalar flux and current amplitudes depend on $N$ across regimes. No external input is required; all parameters are specified above and must be hard-coded in your program.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically sound, well-posed, objective, and self-contained, presenting a standard problem in nuclear reactor physics. We will now proceed with the derivation and solution.\n\nThe foundation of this problem is the steady-state, monoenergetic neutron transport equation in one-dimensional slab geometry. This equation describes the balance of neutrons at a position $x$ traveling in a direction specified by the direction cosine $\\mu = \\cos(\\theta)$:\n$$\n\\mu \\frac{\\partial \\psi(x,\\mu)}{\\partial x} + \\Sigma_t \\psi(x,\\mu) = \\int_{-1}^{1} \\Sigma_s(\\mu' \\to \\mu) \\psi(x,\\mu') d\\mu' + Q(x,\\mu)\n$$\nHere, $\\psi(x,\\mu)$ is the angular neutron flux, $\\Sigma_t$ is the total macroscopic cross section, $\\Sigma_s(\\mu' \\to \\mu)$ represents the scattering kernel from direction $\\mu'$ to $\\mu$, and $Q(x,\\mu)$ is the external neutron source. It is assumed the scattering process is azimuthally symmetric, hence the kernel only depends on the cosine of the scattering angle.\n\nThe problem specifies a spherical harmonics (P$_N$) method to approximate the solution. This involves expanding the angular dependence of the flux $\\psi(x,\\mu)$ and the scattering kernel in terms of Legendre polynomials, $P_\\ell(\\mu)$. A common convention, which leads to the system described in the problem, is to define the flux moments $\\phi_\\ell(x)$ and then construct the system for these moments. The one-dimensional transport equation in terms of moments $\\{\\phi_\\ell(x)\\}_{\\ell=0}^N$ is given by:\n$$\n\\frac{\\ell}{2\\ell-1}\\frac{{d\\phi}_{\\ell-1}(x)}{dx} + \\frac{\\ell+1}{2\\ell+1}\\frac{d\\phi_{\\ell+1}(x)}{dx} + (\\Sigma_t - \\Sigma_{s,\\ell})\\phi_\\ell(x) = Q_\\ell(x)\n$$\nwhere $\\phi_\\ell(x) = \\int_{-1}^{1} \\psi(x,\\mu) P_\\ell(\\mu) d\\mu$ are the flux moments, $\\Sigma_{s,\\ell}$ are the Legendre moments of the scattering cross section, and $Q_\\ell(x)$ are the moments of the source. The problem statement implies a scaling of these equations. If we multiply the $\\ell$-th equation by $(2\\ell+1)$, we obtain:\n$$\n\\ell \\frac{d\\phi_{\\ell-1}(x)}{dx} + (\\ell+1) \\frac{d\\phi_{\\ell+1}(x)}{dx} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\phi_\\ell(x) = (2\\ell+1)Q_\\ell(x)\n$$\nThis form matches the matrix structure described in the problem statement. The P$_N$ approximation is closed by setting $\\phi_{N+1}(x) = 0$. The condition $\\phi_{-1}=0$ is naturally satisfied for the $\\ell=0$ equation. The source is specified as isotropic with spatial dependence $Q(x) = Q_0 \\cos(kx)$. Its only non-zero moment is for $\\ell=0$: $Q_0(x) = Q_0 \\cos(kx)$. All other moments $Q_\\ell(x)=0$ for $\\ell  0$.\n\nThe problem seeks a solution under harmonic forcing. We represent the source as $Q(x) = \\Re\\{Q_0 e^{ikx}\\}$ and seek harmonic responses for the flux moments: $\\phi_\\ell(x) = \\Re\\{\\hat{\\phi}_\\ell e^{ikx}\\}$. The spatial derivative operator $\\frac{d}{dx}$ transforms into multiplication by $ik$. Substituting these forms into the scaled moment equations yields a system of algebraic equations for the complex amplitudes $\\{\\hat{\\phi}_\\ell\\}_{\\ell=0}^N$:\n$$\nik\\ell\\,\\hat{\\phi}_{\\ell-1} + ik(\\ell+1)\\,\\hat{\\phi}_{\\ell+1} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\hat{\\phi}_\\ell = (2\\ell+1)Q_0\\delta_{\\ell,0}\n$$\nFor $\\ell=0$, this gives:\n$$\nik\\,\\hat{\\phi}_{1} + (\\Sigma_t - \\Sigma_{s,0})\\hat{\\phi}_0 = Q_0\n$$\nFor $1 \\le \\ell \\le N-1$:\n$$\nik\\ell\\,\\hat{\\phi}_{\\ell-1} + ik(\\ell+1)\\,\\hat{\\phi}_{\\ell+1} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\hat{\\phi}_\\ell = 0\n$$\nFor $\\ell=N$, applying the closure condition $\\hat{\\phi}_{N+1}=0$:\n$$\nikN\\,\\hat{\\phi}_{N-1} + (2N+1)(\\Sigma_t - \\Sigma_{s,N})\\hat{\\phi}_N = 0\n$$\nThis system can be written in matrix form as $A \\hat{\\mathbf{\\phi}} = \\hat{\\mathbf{Q}}$, where $\\hat{\\mathbf{\\phi}} = [\\hat{\\phi}_0, \\hat{\\phi}_1, \\dots, \\hat{\\phi}_N]^T$ and $\\hat{\\mathbf{Q}} = [Q_0, 0, \\dots, 0]^T$. The matrix $A$ is an $(N+1) \\times (N+1)$ complex-valued, tridiagonal matrix with the following non-zero entries for $\\ell = 0, \\dots, N$:\n$$\nA_{\\ell,\\ell-1} = ik\\ell \\quad (\\text{for } \\ell  0)\n$$\n$$\nA_{\\ell,\\ell} = (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\n$$\n$$\nA_{\\ell,\\ell+1} = ik(\\ell+1) \\quad (\\text{for } \\ell  N)\n$$\nThe problem specifies the scattering moments as $\\Sigma_{s,\\ell} = \\Sigma_{s,0} g^\\ell$, where $\\Sigma_{s,0} = c \\Sigma_t$.\n\nThe numerical experiment involves constructing and solving this linear system for different expansion orders $N \\in \\{1, 3, 7\\}$ and for several sets of physical parameters. A high-order reference solution with $N_{\\mathrm{ref}}=31$ is computed to serve as a benchmark. The convergence of the P$_N$ approximation is quantified by computing the relative error of the complex amplitudes for the scalar flux ($\\hat{\\phi}_0$) and current ($\\hat{\\phi}_1$) with respect to this reference solution. The relative error for a complex quantity $\\hat{\\phi}$ is defined as $|\\hat{\\phi}^{(N)} - \\hat{\\phi}^{(N_{\\mathrm{ref}})}| / |\\hat{\\phi}^{(N_{\\mathrm{ref}})}|$.\n\nThe algorithm is as follows:\n1. For each parameter set $(\\Sigma_t, c, g, k, Q_0)$:\n2. Compute the reference solution vector $\\hat{\\mathbf{\\phi}}^{(N_{\\mathrm{ref}})}$ by constructing and solving the system $A \\hat{\\mathbf{\\phi}} = \\hat{\\mathbf{Q}}$ for $N = N_{\\mathrm{ref}} = 31$. Extract the reference amplitudes $\\hat{\\phi}_0^{(N_{\\mathrm{ref}})}$ and $\\hat{\\phi}_1^{(N_{\\mathrm{ref}})}$.\n3. For each test order $N \\in \\{1, 3, 7\\}$:\n    a. Compute the solution vector $\\hat{\\mathbf{\\phi}}^{(N)}$ by solving the system for that $N$.\n    b. Extract the amplitudes $\\hat{\\phi}_0^{(N)}$ and $\\hat{\\phi}_1^{(N)}$.\n    c. Calculate the relative errors for $\\hat{\\phi}_0$ and $\\hat{\\phi}_1$ using the specified formula.\n4. Collect all computed relative errors into a single list in the prescribed order for final output.\n\nThis procedure is implemented in the following Python code.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_pn(N, Sigma_t, c, g, k, Q0):\n    \"\"\"\n    Constructs and solves the P_N algebraic system for complex flux moment amplitudes.\n\n    Args:\n        N (int): The order of the P_N approximation.\n        Sigma_t (float): Total macroscopic cross section (cm^-1).\n        c (float): Scattering ratio (Sigma_s0 / Sigma_t).\n        g (float): Anisotropy factor for scattering moments.\n        k (float): Wavenumber of the harmonic source (rad/cm).\n        Q0 (float): Amplitude of the zeroth moment of the source (n cm^-3 s^-1).\n\n    Returns:\n        numpy.ndarray: A complex vector of the flux moment amplitudes [phi_0, ..., phi_N].\n    \"\"\"\n    n_vars = N + 1\n    A = np.zeros((n_vars, n_vars), dtype=np.complex128)\n    b = np.zeros(n_vars, dtype=np.complex128)\n\n    # Set the source term (only the 0-th moment is non-zero)\n    b[0] = Q0\n\n    # Calculate the 0-th scattering moment\n    Sigma_s0 = c * Sigma_t\n\n    # Populate the tridiagonal matrix A\n    for l in range(n_vars):\n        # Scattering moment for order l\n        Sigma_sl = Sigma_s0 * (g**l)\n        \n        # Diagonal element\n        A[l, l] = (2 * l + 1) * (Sigma_t - Sigma_sl)\n\n        # Super-diagonal element (l - l+1 coupling)\n        if l  N:\n            A[l, l + 1] = 1j * k * (l + 1)\n\n        # Sub-diagonal element (l - l-1 coupling)\n        if l  0:\n            A[l, l - 1] = 1j * k * l\n\n    # Solve the linear system A * phi_hat = b\n    phi_hat = np.linalg.solve(A, b)\n    return phi_hat\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment as specified in the problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: general forward-peaked\n        (1.0, 0.9, 0.9, 0.5, 1.0),\n        # Case B: diffusion-like k - 0\n        (1.0, 0.9, 0.9, 1e-3, 1.0),\n        # Case C: extreme forward-peaked and higher spatial frequency\n        (1.0, 0.95, 0.99, 2.0, 1.0),\n        # Case D: isotropic scattering control\n        (1.0, 0.9, 0.0, 0.5, 1.0),\n        # Case E: increased absorption\n        (1.0, 0.3, 0.9, 0.5, 1.0),\n    ]\n\n    N_orders = [1, 3, 7]\n    N_ref = 31\n    \n    all_results = []\n\n    for params in test_cases:\n        Sigma_t, c, g, k, Q0 = params\n\n        # Compute the high-order reference solution\n        phi_hat_ref = solve_pn(N_ref, Sigma_t, c, g, k, Q0)\n        phi0_ref = phi_hat_ref[0]\n        phi1_ref = phi_hat_ref[1]\n\n        # Avoid division by zero if reference value is zero (highly unlikely for these params)\n        phi0_ref_mag = np.abs(phi0_ref)\n        if phi0_ref_mag == 0: phi0_ref_mag = 1.0\n\n        phi1_ref_mag = np.abs(phi1_ref)\n        if phi1_ref_mag == 0: phi1_ref_mag = 1.0\n\n        # Compute solutions for specified N orders and their errors\n        for N in N_orders:\n            phi_hat_N = solve_pn(N, *params)\n            phi0_N = phi_hat_N[0]\n            # Current (phi_1) is only available for N = 1\n            phi1_N = phi_hat_N[1] if N = 1 else 0.0 + 0.0j\n\n            # Calculate relative errors\n            err_phi0 = np.abs(phi0_N - phi0_ref) / phi0_ref_mag\n            err_phi1 = np.abs(phi1_N - phi1_ref) / phi1_ref_mag\n            \n            all_results.append(err_phi0)\n            all_results.append(err_phi1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8e}' for x in all_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}