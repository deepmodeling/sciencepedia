{
    "hands_on_practices": [
        {
            "introduction": "The point kinetics equations (PKEs) are a classic example of a \"stiff\" system of ordinary differential equations, characterized by physical processes occurring on vastly different timescales—from the nanoseconds of prompt neutrons to the seconds or minutes of precursor decay. This practice directly confronts this challenge by tasking you with comparing a standard explicit numerical method against a stiff-implicit solver. By implementing both and evaluating their performance against an exact solution, you will gain a firsthand understanding of why implicit methods are indispensable for accurately and stably simulating reactor transients .",
            "id": "4256385",
            "problem": "A nuclear reactor under the point kinetics approximation can be modeled by the coupled ordinary differential equations for neutron population and delayed neutron precursors. Consider the one delayed neutron group model with a step reactivity insertion. Starting from the fundamental neutron balance and precursor production-decay relations, the one-group point kinetics equations are given by an autonomous linear system for constant reactivity:\n$$\n\\frac{dn}{dt} = \\frac{\\rho - \\beta}{\\Lambda}\\, n + \\lambda\\, C,\\quad\n\\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}\\, n - \\lambda\\, C,\n$$\nwhere $n(t)$ is the neutron population (or normalized power, dimensionless), $C(t)$ is the delayed neutron precursor concentration (dimensionless), $\\rho$ is the (dimensionless) reactivity, $\\beta$ is the (dimensionless) delayed neutron fraction, $\\Lambda$ is the prompt neutron generation time (in $\\mathrm{s}$), and $\\lambda$ is the delayed neutron precursor decay constant (in $\\mathrm{s}^{-1}$). Assume the reactor is initially in steady state at $t0$ with $\\rho=0$, so that $n(0^-)=n_0$ and $C(0^-)=\\frac{\\beta}{\\Lambda \\lambda} n_0$. At $t=0$ a step reactivity $\\rho$ is inserted and remains constant for $t\\ge 0$.\n\nYour task is to implement a program that, for several specified test cases, compares the numerical stability and accuracy of an explicit method versus an implicit Runge–Kutta collocation method when integrating the point kinetics equations over both the prompt jump regime and the delayed tail regime.\n\nThe requirements are:\n\n- Implement the model as the linear system\n$$\n\\frac{d}{dt}\\begin{bmatrix}n\\\\C\\end{bmatrix} = A(\\rho)\\begin{bmatrix}n\\\\C\\end{bmatrix},\\quad\nA(\\rho) = \\begin{bmatrix}\\frac{\\rho - \\beta}{\\Lambda}  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  -\\lambda\\end{bmatrix},\n$$\nwith the initial condition at $t=0$ given by $n(0)=n_0$ and $C(0)=\\dfrac{\\beta}{\\Lambda \\lambda} n_0$.\n\n- Integrate from $t=0$ to a specified final time $T$ using:\n  1. An explicit fixed-step Runge–Kutta method of order $4$ (classical Runge–Kutta), with step size $h$.\n  2. An implicit Runge–Kutta collocation method that is suitable for stiff systems (for example, Radau IIA), using the same maximum step size $h$ for fair comparison.\n\n- Construct a reference (ground truth) by solving the linear system exactly using the matrix exponential:\n$$\n\\begin{bmatrix}n(t)\\\\C(t)\\end{bmatrix} = e^{A(\\rho) t} \\begin{bmatrix}n(0)\\\\C(0)\\end{bmatrix}.\n$$\n\n- For each method and test case, compute:\n  1. The maximum relative error over the full trajectory $t \\in [0,T]$ for the neutron population $n(t)$, defined as\n     $$\\max_{t \\in [0,T]} \\frac{\\left|n_{\\text{num}}(t) - n_{\\text{exact}}(t)\\right|}{\\max\\left(10^{-14},\\, n_{\\text{exact}}(t)\\right)}.$$\n     This is unitless and should be reported as a floating-point number.\n  2. A stability boolean indicating whether the numerical neutron population remained finite and non-negative over $[0,T]$.\n\n- All physical quantities must use the units indicated: time in $\\mathrm{s}$ and decay constants in $\\mathrm{s}^{-1}$. The neutron population and precursor concentration are dimensionless. Errors are dimensionless floats.\n\n- Use the following test suite of parameter values. In all cases, set $n_0 = 1$:\n  1. Subcritical, moderate insertion (happy path): $\\beta = 0.0065$, $\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$, $\\lambda = 0.08\\,\\mathrm{s}^{-1}$, $\\rho = 0.003$, $T = 10\\,\\mathrm{s}$, $h = 0.001\\,\\mathrm{s}$.\n  2. Near prompt-critical boundary (edge case): $\\beta = 0.0065$, $\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$, $\\lambda = 0.08\\,\\mathrm{s}^{-1}$, $\\rho = 0.00649$, $T = 3\\,\\mathrm{s}$, $h = 0.002\\,\\mathrm{s}$.\n  3. Superprompt critical (growth regime): $\\beta = 0.0065$, $\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$, $\\lambda = 0.08\\,\\mathrm{s}^{-1}$, $\\rho = 0.008$, $T = 0.2\\,\\mathrm{s}$, $h = 0.0001\\,\\mathrm{s}$.\n  4. Negative reactivity (shutdown tail): $\\beta = 0.0065$, $\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$, $\\lambda = 0.08\\,\\mathrm{s}^{-1}$, $\\rho = -0.002$, $T = 10\\,\\mathrm{s}$, $h = 0.002\\,\\mathrm{s}$.\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a list of four entries in the order: explicit maximum relative error (float), explicit stability (boolean), implicit maximum relative error (float), implicit stability (boolean). The final output format must therefore be:\n  $$\\texttt{[[e\\_1,s\\_1,E\\_1,S\\_1],[e\\_2,s\\_2,E\\_2,S\\_2],[e\\_3,s\\_3,E\\_3,S\\_3],[e\\_4,s\\_4,E\\_4,S\\_4]]}$$\nwhere $e_i$ and $E_i$ are floats, and $s_i$ and $S_i$ are booleans.",
            "solution": "The point kinetics model starts from the balance between prompt neutron production, delayed neutron production, and neutron losses. In the one delayed group approximation with constant parameters, the governing equations are\n$$\n\\frac{dn}{dt} = \\frac{\\rho - \\beta}{\\Lambda}\\, n + \\lambda\\, C,\\quad\n\\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}\\, n - \\lambda\\, C,\n$$\nwhere $n(t)$ and $C(t)$ are dimensionless scaled quantities, $\\rho$ is dimensionless reactivity, $\\beta$ is the dimensionless delayed fraction, $\\Lambda$ is the prompt neutron generation time in $\\mathrm{s}$, and $\\lambda$ is the precursor decay constant in $\\mathrm{s}^{-1}$. For $t0$ at steady state with $\\rho=0$, the derivatives vanish, yielding\n$$\n0 = -\\frac{\\beta}{\\Lambda} n_0 + \\lambda C_0,\\quad 0 = \\frac{\\beta}{\\Lambda} n_0 - \\lambda C_0,\n$$\nhence $C_0 = \\frac{\\beta}{\\Lambda \\lambda} n_0$, which provides the initial condition at $t=0$ when the reactivity is stepped to a constant $\\rho$.\n\nThe system can be written compactly as a linear time-invariant system:\n$$\n\\frac{d}{dt} \\mathbf{x}(t) = A(\\rho)\\, \\mathbf{x}(t),\\quad \\mathbf{x}(t)=\\begin{bmatrix}n(t)\\\\C(t)\\end{bmatrix},\\quad A(\\rho) = \\begin{bmatrix}\\frac{\\rho - \\beta}{\\Lambda}  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  -\\lambda\\end{bmatrix}.\n$$\nFor such a linear system with constant coefficients, the exact solution is given by the matrix exponential:\n$$\n\\mathbf{x}(t) = e^{A(\\rho) t}\\, \\mathbf{x}(0).\n$$\nThis exact form allows a reference (ground truth) for error assessment. One may also express the solution in terms of eigenpairs of $A(\\rho)$. The characteristic polynomial is\n$$\n\\det\\!\\big(s I - A(\\rho)\\big) = s^2 + s\\!\\left(\\lambda - \\frac{\\rho - \\beta}{\\Lambda}\\right) - \\frac{\\lambda \\rho}{\\Lambda},\n$$\nwith roots (kinetics modes)\n$$\ns_{1,2} = \\frac{1}{2}\\left(\\frac{\\rho - \\beta}{\\Lambda} - \\lambda \\pm \\sqrt{\\left(\\lambda - \\frac{\\rho - \\beta}{\\Lambda}\\right)^2 + \\frac{4 \\lambda \\rho}{\\Lambda}}\\right).\n$$\nThe neutron population $n(t)$ is a linear combination of $e^{s_1 t}$ and $e^{s_2 t}$ weighted by the projections of the initial condition onto the eigenvectors. When $\\rho$ is positive but less than $\\beta$ (subprompt), one mode is fast and decays rapidly (prompt jump), and the other is slow (delayed tail). When $\\rho$ is close to $\\beta$, stiffness intensifies because $\\Lambda$ is small and the fast timescale becomes extremely short. When $\\rho\\beta$, there exists a positive eigenvalue and the neutron population exhibits prompt growth dominated by the fast mode.\n\nNumerical integration strategies must account for stiffness stemming from the disparity between the prompt timescale (on the order of $\\Lambda$) and the delayed timescale (on the order of $1/\\lambda$). An explicit fixed-step Runge–Kutta method of order $4$ (classical Runge–Kutta) evolves the state via stage evaluations:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(t_n, \\mathbf{y}_n),\\\\\n\\mathbf{k}_2 = f\\!\\left(t_n + \\frac{h}{2},\\, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1\\right),\\\\\n\\mathbf{k}_3 = f\\!\\left(t_n + \\frac{h}{2},\\, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2\\right),\\\\\n\\mathbf{k}_4 = f\\!\\left(t_n + h,\\, \\mathbf{y}_n + h\\,\\mathbf{k}_3\\right),\\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}\\big(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\big),\n\\end{aligned}\n$$\nwhere $f(\\cdot)$ denotes the right-hand side $A(\\rho)\\mathbf{y}$. For a stiff linear test equation $y' = a y$ with $a$ large and negative, the explicit method has a stability function $R(z)$, with $z = h a$, that must satisfy $\\lvert R(z)\\rvert \\le 1$ to be stable. The classical Runge–Kutta method’s stability function on the real axis decays poorly for large negative $z$ because it matches the truncated series $1 + z + z^2/2 + z^3/6 + z^4/24$. Consequently, for stiff components with $\\lvert a \\rvert \\gg 1/h$, explicit methods become unstable or yield severe errors unless $h$ is chosen much smaller than the fastest timescale, here $h \\ll \\Lambda$.\n\nImplicit Runge–Kutta collocation methods such as Radau IIA are $A$-stable and often $L$-stable; they control the stiff decaying modes robustly without requiring $h \\ll \\Lambda$. Their internal stages solve linear systems involving the Jacobian $J = \\partial f/\\partial \\mathbf{y} = A(\\rho)$, which, for the present linear model, is constant. With the same maximum step size $h$, the implicit method maintains stability across prompt jumps and integrates the delayed tail accurately, whereas the explicit method may show oscillations, negative values, or blow-up near the prompt regime.\n\nThe algorithmic plan is:\n- Build $A(\\rho)$ from the parameters and set $\\mathbf{x}(0) = [n_0,\\, \\beta n_0/(\\Lambda \\lambda)]^\\top$.\n- Generate a uniform time grid $t_k = k h$ for $k = 0,1,\\dots,\\lfloor T/h \\rfloor$, ensuring coverage of $[0,T]$.\n- Compute the reference solution by evaluating $e^{A(\\rho) t_k}\\mathbf{x}(0)$ at each grid point. For efficiency, exploit the constant $A(\\rho)$: compute an eigendecomposition $A(\\rho) = V D V^{-1}$ and then $e^{A(\\rho) t} = V \\,\\mathrm{diag}(e^{s_1 t}, e^{s_2 t})\\, V^{-1}$ for each $t$.\n- Apply explicit Runge–Kutta of order $4$ with fixed step $h$ across the grid to obtain $\\mathbf{y}^{\\text{exp}}(t_k)$.\n- Apply an implicit Runge–Kutta collocation solver (Radau IIA) constrained by $\\text{max\\_step} = h$ and tight tolerances to obtain $\\mathbf{y}^{\\text{imp}}(t_k)$ sampled at the same $t_k$.\n- Compute the maximum relative error for the neutron population for each method:\n$$\n\\max_k \\frac{\\left|n_{\\text{num}}(t_k) - n_{\\text{exact}}(t_k)\\right|}{\\max\\left(10^{-14},\\, n_{\\text{exact}}(t_k)\\right)}.\n$$\n- Assess stability by checking whether all $n_{\\text{num}}(t_k)$ are finite and $\\ge 0$.\n\nThe test suite exercises:\n- A subcritical case ($\\rho = 0.003$) with moderate $h$ to demonstrate typical behavior (delayed tail dominant after a prompt adjustment).\n- A near prompt-critical case ($\\rho = 0.00649$) highlighting stiffness sensitivity and potential explicit instability as the prompt jump factor $J \\approx \\frac{\\beta}{\\beta - \\rho}$ grows large.\n- A superprompt critical case ($\\rho = 0.008$) where one eigenvalue becomes positive; the neutron population grows rapidly, challenging step-size stability and accuracy.\n- A negative reactivity case ($\\rho = -0.002$) producing a shutdown transient, where stiffness arises from fast decay coupled to slow tail.\n\nWith identical maximum step sizes, the implicit method’s $A$-stability and handling of stiff modes should yield smaller errors and maintain non-negativity and boundedness across all cases, whereas the explicit method may produce larger errors or instabilities near the prompt regime, especially close to $\\rho \\approx \\beta$ or when $h$ is not sufficiently small compared to $\\Lambda$. The program computes and reports the comparison metrics as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import eig\n\ndef A_matrix(rho, beta, Lambda, lam):\n    \"\"\"Construct the system matrix A for given parameters.\"\"\"\n    return np.array([[ (rho - beta) / Lambda, lam ],\n                     [ beta / Lambda,          -lam ]], dtype=float)\n\ndef rk4_fixed_step(f, t_grid, y0):\n    \"\"\"Explicit RK4 with fixed steps over t_grid.\"\"\"\n    y = np.zeros((len(y0), len(t_grid)))\n    y[:, 0] = y0\n    for k in range(len(t_grid) - 1):\n        t = t_grid[k]\n        h = t_grid[k+1] - t\n        yk = y[:, k]\n        k1 = f(t, yk)\n        k2 = f(t + 0.5*h, yk + 0.5*h*k1)\n        k3 = f(t + 0.5*h, yk + 0.5*h*k2)\n        k4 = f(t + h,     yk + h*k3)\n        y[:, k+1] = yk + (h/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n    return y\n\ndef exact_solution_on_grid(A, t_grid, y0):\n    \"\"\"Compute exact solution e^{A t} y0 at grid points using eigendecomposition.\"\"\"\n    # Eigendecomposition A = V D V^{-1}\n    vals, V = eig(A)\n    Vinv = np.linalg.inv(V)\n    # y(t) = V * exp(D t) * V^{-1} * y0\n    y_exact = np.zeros((len(y0), len(t_grid)), dtype=np.complex128)\n    coeff = Vinv @ y0\n    for i, t in enumerate(t_grid):\n        exp_diag = np.exp(vals * t)\n        y_exact[:, i] = V @ (exp_diag * coeff)\n    # Return real part (solution is real by construction)\n    return np.real(y_exact)\n\ndef compute_metrics(n_num, n_exact):\n    \"\"\"Compute max relative error and stability boolean.\"\"\"\n    # Relative error defined element-wise and take max\n    denom = np.maximum(1e-14, n_exact)\n    rel_errors = np.abs(n_num - n_exact) / denom\n    max_rel_error = float(np.max(rel_errors))\n    # Stability: finite and non-negative\n    stable = bool(np.all(np.isfinite(n_num)) and np.all(n_num >= 0.0))\n    return max_rel_error, stable\n\ndef solve():\n    # Define test cases from the problem statement\n    test_cases = [\n        # (beta, Lambda, lam, rho, T, h)\n        (0.0065, 5.0e-5, 0.08, 0.00300, 10.0, 0.0010),\n        (0.0065, 5.0e-5, 0.08, 0.00649,  3.0, 0.0020),\n        (0.0065, 5.0e-5, 0.08, 0.00800,  0.2, 0.0001),\n        (0.0065, 5.0e-5, 0.08, -0.0020, 10.0, 0.0020),\n    ]\n    n0 = 1.0\n\n    results = []\n    for beta, Lambda, lam, rho, T, h in test_cases:\n        # Initial condition at t=0 (steady state at rho=0 prior to step)\n        C0 = beta / (Lambda * lam) * n0\n        y0 = np.array([n0, C0], dtype=float)\n\n        # Build A and time grid\n        A = A_matrix(rho, beta, Lambda, lam)\n        n_steps = int(np.floor(T / h))\n        t_grid = np.linspace(0.0, n_steps * h, n_steps + 1)\n\n        # Right-hand side function f(t, y) = A y\n        def f(t, y):\n            return A @ y\n\n        # Exact solution\n        y_exact = exact_solution_on_grid(A, t_grid, y0)\n        n_exact = y_exact[0, :]\n\n        # Explicit RK4 fixed-step\n        y_exp = rk4_fixed_step(f, t_grid, y0)\n        n_exp = y_exp[0, :]\n        err_exp, stable_exp = compute_metrics(n_exp, n_exact)\n\n        # Implicit Radau collocation via solve_ivp, constrained by max_step=h and sample at t_grid\n        # Use tight tolerances to emphasize method accuracy and stability properties.\n        sol_imp = solve_ivp(\n            fun=lambda t, y: f(t, y),\n            t_span=(t_grid[0], t_grid[-1]),\n            y0=y0,\n            method='Radau',\n            t_eval=t_grid,\n            max_step=h,\n            rtol=1e-10,\n            atol=1e-12\n        )\n        y_imp = sol_imp.y\n        n_imp = y_imp[0, :]\n        err_imp, stable_imp = compute_metrics(n_imp, n_exact)\n\n        results.append([err_exp, stable_exp, err_imp, stable_imp])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A crucial aspect of computational science is the validation of numerical models against established analytical theory. This exercise bridges the gap between numerical simulation and fundamental reactor physics by focusing on the asymptotic reactor period. After implementing a robust implicit solver to model a transient, you will analyze the simulation output to extract the stable reactor period and compare it to the value predicted by the revered inhour equation, providing a powerful demonstration of how simulation complements and confirms theoretical predictions .",
            "id": "4239337",
            "problem": "You are asked to design and implement a complete, runnable program that numerically integrates the reactor point kinetics equations under a step reactivity insertion using a fully implicit method and compares the numerically inferred reactor period to the prediction from the inhour relation. The context is a subprompt-critical step insertion with six delayed neutron groups. The program must adhere to the following scientific, mathematical, and output requirements.\n\nThe fundamental base for this problem is the point kinetics model, which represents the neutron balance and the dynamics of delayed neutron precursors in a well-mixed reactor core. Under the point approximation, the neutron population is denoted by $n(t)$ and the delayed neutron precursor concentrations for six groups are $C_i(t)$ for $i=1,\\dots,6$. The reactivity is $ \\rho(t) $, the total delayed neutron fraction is $ \\beta = \\sum_{i=1}^{6} \\beta_i $, the mean neutron generation time is $ \\Lambda $, and the decay constants are $ \\lambda_i $. A subprompt-critical step insertion means $ \\rho  \\beta $. The initial condition is a steady state at $ t = 0^{-} $ with $ \\rho(0^{-}) = 0 $, normalized neutron population $ n(0^{-}) = 1 $ in arbitrary power units, and precursor concentrations $ C_i(0^{-}) $ consistent with steady state. At $ t = 0^{+} $, a step reactivity $ \\rho(t) = \\rho_{\\text{step}} $ for all $ t \\ge 0 $ is applied.\n\nYour task is to:\n- Implement a fully implicit time discretization for the coupled first-order linear ordinary differential equations of the point kinetics model with six delayed neutron groups (without providing any shortcut formulas in the problem statement).\n- Use appropriate initial conditions consistent with a pre-step steady state and the definition of delayed neutron precursors.\n- Simulate the response for a sufficiently long duration so that the asymptotic exponential behavior is reached. Estimate the asymptotic exponential growth constant $ \\alpha $ from the slope of $ \\ln n(t) $ over a late-time window, and report the reactor period $ T_{\\text{num}} = 1/\\alpha $ in seconds.\n- Compute the asymptotic exponential growth constant $ \\alpha_{\\text{inhour}} $ using the well-tested inhour relation for subprompt-critical transients and obtain $ T_{\\text{inhour}} = 1/\\alpha_{\\text{inhour}} $ in seconds.\n- Compare $ T_{\\text{num}} $ to $ T_{\\text{inhour}} $ by reporting the relative difference defined as $ (T_{\\text{num}} - T_{\\text{inhour}})/T_{\\text{inhour}} $ (a dimensionless decimal). No percentages are permitted; express the answer as a decimal fraction.\n\nPhysical and numerical units:\n- Express all time-related quantities in seconds.\n- The step reactivity is given in pcm (per cent mille), where $ 1 $ pcm $=10^{-5}$ in dimensionless reactivity units. You must convert to a dimensionless $ \\rho $ inside the program.\n\nImplicit method and initialization:\n- Use a fully implicit scheme (for example, backward Euler) to advance $ n(t) $ and $ C_i(t) $ jointly at each time step, solving the resulting linear system for $ n_{k+1} $ and $ C_{i,k+1} $ from $ n_k $ and $ C_{i,k} $.\n- Prior to the step, the reactor is at steady state with $ \\rho(0^{-}) = 0 $. Set $ n(0) = 1 $ and $ C_i(0) $ consistent with the steady-state precursor balance.\n\nTest suite and parameters:\nImplement three test cases that cover typical thermal behavior, fast reactor behavior, and a near-prompt-critical boundary case, all with six delayed groups using the same decay constants $ \\lambda_i $ but different total delayed fractions $ \\beta $ and mean generation times $ \\Lambda $. In all cases use the same base set of six-group decay constants:\n- $ \\lambda = [\\,0.0124,\\;0.0305,\\;0.111,\\;0.301,\\;1.14,\\;3.01\\,] $ in s$^{-1}$.\n\nUse the following base six-group delayed neutron fractions for a typical thermal system (sum $ \\beta \\approx 0.006502 $):\n- $ \\beta^{\\text{base}} = [\\,0.000215,\\;0.001424,\\;0.001274,\\;0.002568,\\;0.000748,\\;0.000273\\,] $.\n\nFor cases that require a different total $ \\beta $, scale $ \\beta^{\\text{base}} $ proportionally so that $ \\sum_i \\beta_i $ equals the specified total.\n\nEach case uses a step reactivity $ \\rho_{\\text{step}} = 200 $ pcm, i.e., $ \\rho = 200 \\times 10^{-5} $ dimensionless. The test suite is:\n\n- Case $A$ (thermal reference):\n  - $ \\beta_i = \\beta^{\\text{base}} $.\n  - $ \\Lambda = 1.0 \\times 10^{-5} $ s.\n  - Time step $ \\Delta t = 5.0 \\times 10^{-3} $ s.\n  - Simulation duration $ T_{\\text{end}} = 60.0 $ s.\n\n- Case $B$ (fast spectrum, reduced delayed fraction):\n  - Scale $ \\beta^{\\text{base}} $ to $ \\sum_i \\beta_i = 0.0030 $.\n  - $ \\Lambda = 5.0 \\times 10^{-7} $ s.\n  - Time step $ \\Delta t = 2.5 \\times 10^{-3} $ s.\n  - Simulation duration $ T_{\\text{end}} = 40.0 $ s.\n\n- Case $C$ (near-prompt-critical boundary, subprompt-critical):\n  - Scale $ \\beta^{\\text{base}} $ to $ \\sum_i \\beta_i = 0.0022 $.\n  - $ \\Lambda = 2.0 \\times 10^{-5} $ s.\n  - Time step $ \\Delta t = 5.0 \\times 10^{-3} $ s.\n  - Simulation duration $ T_{\\text{end}} = 80.0 $ s.\n\nRequired final output format:\n- Your program should produce a single line of output containing the relative differences for the three cases as a comma-separated list enclosed in square brackets, for example $ [r_A,r_B,r_C] $, where each entry is the decimal value of $ (T_{\\text{num}} - T_{\\text{inhour}})/T_{\\text{inhour}} $ for the corresponding case.\n- The values must be printed in the exact required format with no additional text.\n\nScientific realism and constraints:\n- Ensure $ \\rho  \\beta $ for all cases (subprompt-critical).\n- The program must be self-contained, not require any user input or external files, and be runnable in a modern environment.",
            "solution": "The problem has been validated and is determined to be scientifically grounded, well-posed, and objective. It presents a standard task in computational reactor physics, requiring the numerical solution of the point kinetics equations and comparison with an analytical benchmark. All necessary parameters and conditions are provided, and there are no internal contradictions or violations of physical principles.\n\nThe solution proceeds as follows: First, we state the governing equations of the point kinetics model. Second, we derive the initial conditions from the specified steady-state reactor. Third, we develop the fully implicit numerical integration scheme. Fourth, we formulate the inhour relation to find the analytical asymptotic period. Finally, we describe the method for extracting the numerical period from the simulation data to compute the required relative difference.\n\nThe reactor point kinetics equations for neutron population density $n(t)$ and the concentrations of $i=1, \\dots, 6$ delayed neutron precursor groups $C_i(t)$ are a system of $7$ coupled first-order ordinary differential equations:\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{6} \\lambda_i C_i(t)\n$$\n$$\n\\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t)\n$$\nHere, $\\rho(t)$ is the reactivity, $\\Lambda$ is the mean neutron generation time, $\\lambda_i$ are the decay constants of the precursors, $\\beta_i$ are the delayed neutron fractions for each group, and $\\beta = \\sum_{i=1}^{6} \\beta_i$ is the total delayed neutron fraction.\n\nThe problem specifies an initial steady state at time $t=0^{-}$ with $\\rho(0^{-}) = 0$. In steady state, all time derivatives are zero. Setting $\\frac{dn}{dt}=0$ and $\\frac{dC_i}{dt}=0$ in the equations above provides the initial conditions. With the normalization $n(0)=1$, the precursor concentrations are determined from the second equation:\n$$\n0 = \\frac{\\beta_i}{\\Lambda} n(0) - \\lambda_i C_i(0) \\implies C_i(0) = \\frac{\\beta_i n(0)}{\\lambda_i \\Lambda} = \\frac{\\beta_i}{\\lambda_i \\Lambda}\n$$\nThese values for $n(0)$ and $C_i(0)$ are used to start the simulation at $t=0$, at which point a step reactivity $\\rho(t) = \\rho_{\\text{step}}$ for $t \\ge 0$ is introduced.\n\nTo numerically integrate this system, we employ a fully implicit (Backward Euler) scheme. Time is discretized into steps of size $\\Delta t$, such that $t_k = k \\Delta t$. The time derivative of a variable $y(t)$ is approximated as $\\frac{dy}{dt} \\approx \\frac{y_{k+1} - y_k}{\\Delta t}$, where all terms on the right-hand side of the ODE are evaluated at the future time step $t_{k+1}$.\nApplying this to the point kinetics equations yields:\n$$\n\\frac{n_{k+1} - n_k}{\\Delta t} = \\frac{\\rho_{\\text{step}} - \\beta}{\\Lambda} n_{k+1} + \\sum_{i=1}^{6} \\lambda_i C_{i, k+1}\n$$\n$$\n\\frac{C_{i, k+1} - C_{i, k}}{\\Delta t} = \\frac{\\beta_i}{\\Lambda} n_{k+1} - \\lambda_i C_{i, k+1}\n$$\nThis is a system of linear algebraic equations for the unknown state $[n_{k+1}, C_{1,k+1}, \\dots, C_{6,k+1}]^T$. We can solve it efficiently by substitution. From the second equation for each precursor group $i$, we can express $C_{i, k+1}$ in terms of $n_{k+1}$ and known values from step $k$:\n$$\nC_{i, k+1}(1 + \\Delta t \\lambda_i) = C_{i, k} + \\frac{\\Delta t \\beta_i}{\\Lambda} n_{k+1} \\implies C_{i, k+1} = \\frac{C_{i, k} + \\frac{\\Delta t \\beta_i}{\\Lambda} n_{k+1}}{1 + \\Delta t \\lambda_i}\n$$\nSubstituting this expression for $C_{i, k+1}$ into the discretized neutron balance equation allows us to solve for $n_{k+1}$:\n$$\n\\frac{n_{k+1} - n_k}{\\Delta t} = \\frac{\\rho_{\\text{step}} - \\beta}{\\Lambda} n_{k+1} + \\sum_{i=1}^{6} \\lambda_i \\left( \\frac{C_{i, k} + \\frac{\\Delta t \\beta_i}{\\Lambda} n_{k+1}}{1 + \\Delta t \\lambda_i} \\right)\n$$\nRearranging to isolate $n_{k+1}$ on the left-hand side:\n$$\nn_{k+1} \\left[ \\frac{1}{\\Delta t} - \\frac{\\rho_{\\text{step}} - \\beta}{\\Lambda} - \\sum_{i=1}^{6} \\frac{\\lambda_i \\Delta t \\beta_i / \\Lambda}{1 + \\Delta t \\lambda_i} \\right] = \\frac{n_k}{\\Delta t} + \\sum_{i=1}^{6} \\frac{\\lambda_i C_{i, k}}{1 + \\Delta t \\lambda_i}\n$$\nThis equation is of the form $A \\cdot n_{k+1} = B_k$, where the coefficient $A$ is constant throughout the simulation (since all its constituent parameters are constant) and $B_k$ depends on the state at the previous time step $k$. At each step, we calculate $n_{k+1} = B_k / A$ and then use this new value to update each $C_{i, k+1}$.\n\nFor a step reactivity insertion, the neutron population eventually grows exponentially as $n(t) \\sim e^{\\alpha t}$, where $\\alpha$ is a constant. The reactor period is defined as $T = 1/\\alpha$. The analytical value of this growth constant, $\\alpha_{\\text{inhour}}$, is the positive root of the inhour equation:\n$$\n\\rho_{\\text{step}} = \\alpha \\Lambda + \\sum_{i=1}^{6} \\frac{\\alpha \\beta_i}{\\alpha + \\lambda_i}\n$$\nThis is a non-linear algebraic equation for $\\alpha$. It can be solved numerically for $\\alpha_{\\text{inhour}}$ using a standard root-finding algorithm. The corresponding analytical period is $T_{\\text{inhour}} = 1/\\alpha_{\\text{inhour}}$.\n\nThe numerical period, $T_{\\text{num}}$, is estimated from the simulation results. For large $t$, where the solution is dominated by the asymptotic exponential growth, we have $\\ln n(t) \\approx \\ln n_0 + \\alpha t$. This is a linear relationship between $\\ln n(t)$ and $t$, with slope $\\alpha$. We perform a linear regression on the set of points $(t_k, \\ln n_k)$ over a late-time window of the simulation (e.g., the final $25\\%$ of time steps) to find the slope, which serves as our numerical estimate $\\alpha_{\\text{num}}$. The numerical period is then $T_{\\text{num}} = 1/\\alpha_{\\text{num}}$.\n\nFinally, for each test case, we compute the relative difference between the numerically inferred period and the analytical prediction from the inhour relation:\n$$\n\\text{Relative Difference} = \\frac{T_{\\text{num}} - T_{\\text{inhour}}}{T_{\\text{inhour}}}\n$$\nThe implementation will execute this entire procedure for each of the three test cases specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print results.\n    \"\"\"\n\n    def run_simulation_case(params):\n        \"\"\"\n        Solves the point kinetics problem for a single parameter set.\n\n        Args:\n            params (dict): A dictionary containing all parameters for the case.\n\n        Returns:\n            float: The relative difference (T_num - T_inhour) / T_inhour.\n        \"\"\"\n        # 1. Unpack parameters and set up case-specific data\n        Lambda = params['Lambda']\n        betas_base = params['betas_base']\n        beta_total_target = params['beta_total']\n        lambdas = params['lambdas']\n        rho_pcm = params['rho_pcm']\n        dt = params['dt']\n        T_end = params['T_end']\n\n        rho_step = rho_pcm * 1e-5\n\n        if beta_total_target is not None:\n            scaling_factor = beta_total_target / np.sum(betas_base)\n            betas = betas_base * scaling_factor\n        else:\n            betas = betas_base\n        \n        beta = np.sum(betas)\n\n        if rho_step >= beta:\n            raise ValueError(\"Reactivity is not sub-prompt-critical.\")\n\n        # 2. Set initial conditions (steady state at rho=0, n=1)\n        n0 = 1.0\n        C0 = betas * n0 / (lambdas * Lambda)\n        \n        num_steps = int(T_end / dt)\n        time_points = np.linspace(0, T_end, num_steps + 1)\n        \n        n_hist = np.zeros(num_steps + 1)\n        C_hist = np.zeros((6, num_steps + 1))\n        \n        n_hist[0] = n0\n        C_hist[:, 0] = C0\n        \n        # 3. Perform time integration using the fully implicit (Backward Euler) method\n        # Pre-calculate the constant coefficient of n_{k+1} for efficiency.\n        # This coefficient is the 'A' in the linear system A*x = b.\n        A_coeff = (1.0 / dt\n                   - (rho_step - beta) / Lambda\n                   - (dt / Lambda) * np.sum(lambdas * betas / (1.0 + dt * lambdas)))\n\n        for k in range(num_steps):\n            n_k = n_hist[k]\n            C_k = C_hist[:, k]\n            \n            # Calculate the right-hand side 'b' of the linear system, which depends on state at k.\n            B_k = n_k / dt + np.sum(lambdas * C_k / (1.0 + dt * lambdas))\n            \n            # Solve for n_{k+1}\n            n_k_plus_1 = B_k / A_coeff\n            n_hist[k+1] = n_k_plus_1\n            \n            # Update C_{i, k+1} using the newly computed n_{k+1}\n            C_hist[:, k+1] = (C_k + (dt * betas / Lambda) * n_k_plus_1) / (1.0 + dt * lambdas)\n\n        # 4. Estimate the numerical asymptotic period T_num\n        # Use the last 25% of the simulation data for a linear fit on log(n).\n        fit_start_index = int(0.75 * num_steps)\n        t_fit = time_points[fit_start_index:]\n        n_fit = n_hist[fit_start_index:]\n        \n        # Ensure there are at least 2 positive data points for fitting\n        valid_indices = n_fit > 0\n        if np.sum(valid_indices)  2:\n            raise ValueError(\"Insufficient positive data points for period estimation.\")\n\n        log_n_fit = np.log(n_fit[valid_indices])\n        t_fit = t_fit[valid_indices]\n        \n        # np.polyfit returns [slope, intercept]; the slope is the growth constant alpha.\n        alpha_num, _ = np.polyfit(t_fit, log_n_fit, 1)\n        T_num = 1.0 / alpha_num\n    \n        # 5. Calculate the analytical period T_inhour from the inhour relation\n        def inhour_function(alpha):\n            return alpha * Lambda + np.sum(alpha * betas / (alpha + lambdas)) - rho_step\n        \n        # For positive reactivity, the root alpha must be positive.\n        sol = root_scalar(inhour_function, bracket=[1e-9, 1000.0])\n        alpha_inhour = sol.root\n        T_inhour = 1.0 / alpha_inhour\n        \n        # 6. Calculate the final relative difference\n        relative_difference = (T_num - T_inhour) / T_inhour\n        \n        return relative_difference\n\n    # Common parameters for all test cases\n    lambdas_common = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    betas_base_common = np.array([0.000215, 0.001424, 0.001274, 0.002568, 0.000748, 0.000273])\n    rho_pcm_common = 200.0\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (thermal reference)\n        {\n            'Lambda': 1.0e-5, 'beta_total': None, 'dt': 5.0e-3, 'T_end': 60.0,\n            'betas_base': betas_base_common, 'lambdas': lambdas_common, 'rho_pcm': rho_pcm_common\n        },\n        # Case B (fast spectrum, reduced delayed fraction)\n        {\n            'Lambda': 5.0e-7, 'beta_total': 0.0030, 'dt': 2.5e-3, 'T_end': 40.0,\n            'betas_base': betas_base_common, 'lambdas': lambdas_common, 'rho_pcm': rho_pcm_common\n        },\n        # Case C (near-prompt-critical boundary)\n        {\n            'Lambda': 2.0e-5, 'beta_total': 0.0022, 'dt': 5.0e-3, 'T_end': 80.0,\n            'betas_base': betas_base_common, 'lambdas': lambdas_common, 'rho_pcm': rho_pcm_common\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rel_diff = run_simulation_case(case)\n        results.append(rel_diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Reactor dynamics in the real world are profoundly influenced by feedback mechanisms, where changes in reactor state, such as temperature, alter the system's reactivity. This practice elevates our model by incorporating temperature feedback, transforming the linear PKEs into a more realistic non-linear system. By simulating an Anticipated Transient Without Scram (ATWS), you will investigate the critical interplay between an external reactivity insertion and the reactor's inherent self-regulating feedback, allowing you to determine whether the reactor power ultimately stabilizes or diverges .",
            "id": "4256420",
            "problem": "An Anticipated Transient Without Scram (ATWS) scenario is considered in which control rods are stuck and an externally imposed reactivity ramp produces a slow positive increase in reactivity. The objective is to determine, using the point kinetics framework with single delayed neutron group and lumped thermal feedback via the moderator temperature, whether reactor power stabilizes or diverges over a finite time horizon, for several parameter sets. All quantities, when physical units apply, must be expressed in the International System of Units (SI).\n\nStarting from the conservation of neutrons and precursors and a lumped thermal energy balance, derive governing ordinary differential equations for the neutron population $n(t)$, a single delayed neutron precursor concentration $C(t)$, and the moderator temperature $T(t)$ in terms of:\n- reactivity $\\rho(t)$ composed of an externally imposed ramp $\\rho_{\\mathrm{ext}}(t) = r t$ and a temperature feedback term $\\rho_{\\mathrm{fb}}(t) = \\alpha_T \\left(T(t) - T_{\\mathrm{ref}}\\right)$,\n- effective delayed neutron fraction $\\beta$,\n- prompt neutron generation time (mean generation lifetime) $\\Lambda$,\n- single-group precursor decay constant $\\lambda$,\n- thermal power scaling $P(t) = P_0 \\, n(t)$ with $P_0$ in watts and $n(t)$ dimensionless (normalized to $n(0) = 1$),\n- lumped thermal capacity $C_T$ in joules per kelvin,\n- first-order heat removal to an ambient sink with time constant $\\tau$ in seconds and ambient temperature $T_\\infty$ in kelvin.\n\nAssume initial conditions $n(0) = 1$ (dimensionless), $C(0)$ consistent with a steady state at zero reactivity and constant power, and $T(0) = T_{\\mathrm{ref}}$ in kelvin. For each parameter set, integrate the derived coupled ordinary differential equations over a specified time horizon $t \\in [0, t_{\\mathrm{end}}]$ in seconds, and decide whether the power stabilizes or diverges according to the following algorithmic criteria:\n- Define the normalized power as $p(t) = n(t)$ (dimensionless).\n- A case is classified as \"stabilize\" (boolean value $true$) if both of the following hold:\n  1. $\\max_{t \\in [0,t_{\\mathrm{end}}]} p(t) \\le p_{\\mathrm{lim}}$ for a specified dimensionless bound $p_{\\mathrm{lim}}$,\n  2. The maximum relative slope over the final tenth of the simulation window is less than a specified threshold $\\epsilon_{\\mathrm{rel}}$, i.e., $\\max_{t \\in [0.9 t_{\\mathrm{end}}, t_{\\mathrm{end}}]} \\left| \\dfrac{dp/dt}{p(t) + \\delta} \\right|  \\epsilon_{\\mathrm{rel}}$, where $\\delta$ is a small positive constant used only to avoid division by zero.\n- Otherwise, classify the case as \"diverge\" (boolean value $false$).\n\nUse the following test suite of parameter sets. All quantities are in SI units unless explicitly stated otherwise; reactivity coefficients $r$ and $\\alpha_T$ are in $\\Delta k/k$ per second and $\\Delta k/k$ per kelvin, respectively.\n\nTest Case 1 (moderate ramp, strong negative feedback, expected stabilization):\n- $r = 1.0 \\times 10^{-5}$,\n- $\\alpha_T = -6.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nTest Case 2 (strong ramp, weak negative feedback, expected divergence):\n- $r = 1.0 \\times 10^{-4}$,\n- $\\alpha_T = -3.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 60.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nTest Case 3 (zero ramp, baseline negative feedback, expected stabilization):\n- $r = 0.0$,\n- $\\alpha_T = -5.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nTest Case 4 (moderate ramp, very strong negative feedback, expected stabilization):\n- $r = 5.0 \\times 10^{-5}$,\n- $\\alpha_T = -1.5 \\times 10^{-4}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nYour program must:\n- Derive the governing equations from the stated fundamental principles and implement a numerical integrator to solve them for each test case.\n- Use $C(0)$ consistent with an initial steady state at zero reactivity and constant power.\n- Decide stabilization versus divergence using the specified criteria, with $\\delta = 10^{-12}$ in the denominator for numerical robustness.\n- Produce a single line of output containing the boolean results for the four test cases as a comma-separated list enclosed in square brackets, for example: \"[true,false,true,true]\". In Python, the canonical boolean literals \"True\" and \"False\" are acceptable and must be printed exactly as they appear.",
            "solution": "The user has provided a problem in nuclear reactor analysis, specifically focusing on an Anticipated Transient Without Scram (ATWS) scenario. The problem has been validated and found to be scientifically sound, well-posed, objective, and complete. We now proceed with the solution.\n\n### 1. Derivation of the Governing Ordinary Differential Equations\n\nWe are tasked with deriving the governing equations from fundamental principles for three state variables: the dimensionless neutron population $n(t)$, the dimensionless precursor concentration $C(t)$, and the moderator temperature $T(t)$.\n\n**Point Kinetics Equations (PKEs)**\nThe time evolution of the neutron population and a single effective group of delayed neutron precursors is described by the point kinetics equations.\n\nThe rate of change of the neutron population, $\\frac{dn}{dt}$, is the sum of neutrons produced from prompt fission, neutrons lost through absorption and leakage, and neutrons produced from the decay of precursors. This balance is expressed as:\n$$ \\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\lambda C(t) \\quad \\quad (1) $$\nHere, $\\rho(t)$ is the total reactivity, $\\beta$ is the effective delayed neutron fraction, $\\Lambda$ is the prompt neutron generation time, and $\\lambda$ is the single-group precursor decay constant. The term $\\frac{\\rho(t) - \\beta}{\\Lambda} n(t)$ represents the net production from prompt neutrons, and $\\lambda C(t)$ represents the production from delayed neutron precursors.\n\nThe rate of change of the precursor concentration, $\\frac{dC}{dt}$, is the balance between their production from fission and their radioactive decay:\n$$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) \\quad \\quad (2) $$\nThe term $\\frac{\\beta}{\\Lambda} n(t)$ represents the rate of precursor formation, which is proportional to the fission rate (and thus to $n(t)$), and $-\\lambda C(t)$ represents their loss through decay.\n\n**Reactivity Model**\nThe total reactivity $\\rho(t)$ is given as the sum of an externally imposed linear ramp, $\\rho_{\\mathrm{ext}}(t)$, and a temperature-dependent feedback term, $\\rho_{\\mathrm{fb}}(t)$:\n$$ \\rho(t) = \\rho_{\\mathrm{ext}}(t) + \\rho_{\\mathrm{fb}}(t) = r t + \\alpha_T (T(t) - T_{\\mathrm{ref}}) $$\nHere, $r$ is the ramp rate, $\\alpha_T$ is the moderator temperature coefficient of reactivity, and $T_{\\mathrm{ref}}$ is the reference temperature at which the feedback reactivity is zero.\n\n**Thermal-Hydraulic Model**\nA lumped-parameter energy balance for the moderator is considered. The rate of change of the internal energy of the moderator, $C_T T(t)$, is equal to the heat generated by the reactor core minus the heat removed to the ambient sink.\n$$ \\frac{d}{dt}(C_T T(t)) = P(t) - P_{\\mathrm{removed}}(t) $$\nGiven a constant thermal capacity $C_T$, this becomes:\n$$ C_T \\frac{dT}{dt} = P(t) - P_{\\mathrm{removed}}(t) $$\nThe thermal power generated, $P(t)$, is proportional to the neutron population: $P(t) = P_0 n(t)$. The heat removal is modeled as a first-order process to a sink at temperature $T_\\infty$ with a time constant $\\tau$. The rate of heat removal is given by $\\frac{C_T}{\\tau}(T(t) - T_\\infty)$, representing Newtonian cooling.\nSubstituting these expressions into the energy balance yields:\n$$ C_T \\frac{dT}{dt} = P_0 n(t) - \\frac{C_T}{\\tau} (T(t) - T_\\infty) $$\nDividing by $C_T$ gives the final ODE for temperature:\n$$ \\frac{dT}{dt} = \\frac{P_0}{C_T} n(t) - \\frac{1}{\\tau} (T(t) - T_\\infty) \\quad \\quad (3) $$\n\n**Complete System of ODEs**\nThe complete system of coupled, non-linear, first-order ordinary differential equations describing the reactor transient is:\n1.  $$ \\frac{dn}{dt} = \\frac{r t + \\alpha_T (T(t) - T_{\\mathrm{ref}}) - \\beta}{\\Lambda} n(t) + \\lambda C(t) $$\n2.  $$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) $$\n3.  $$ \\frac{dT}{dt} = \\frac{P_0}{C_T} n(t) - \\frac{1}{\\tau} (T(t) - T_\\infty) $$\n\n### 2. Initial Conditions\n\nThe transient starts at $t=0$. The initial conditions are specified as:\n*   $n(0) = 1$\n*   $T(0) = T_{\\mathrm{ref}}$\n*   $C(0)$ is consistent with a steady state at zero reactivity ($\\rho=0$) and constant power.\n\nTo find $C(0)$, we set the time derivatives in the PKEs to zero, with $n(0) = 1$ and $\\rho(0)=0$:\n$$ \\frac{dn}{dt} = 0 \\implies 0 = \\frac{0 - \\beta}{\\Lambda} n(0) + \\lambda C(0) $$\n$$ \\frac{dC}{dt} = 0 \\implies 0 = \\frac{\\beta}{\\Lambda} n(0) - \\lambda C(0) $$\nBoth equations yield the same relationship. From the second equation:\n$$ \\lambda C(0) = \\frac{\\beta}{\\Lambda} n(0) $$\nSubstituting $n(0)=1$:\n$$ C(0) = \\frac{\\beta}{\\lambda \\Lambda} $$\nThe initial state vector for the numerical integration is therefore $\\mathbf{y}(0) = [n(0), C(0), T(0)]^T = \\left[ 1, \\frac{\\beta}{\\lambda \\Lambda}, T_{\\mathrm{ref}} \\right]^T$.\n\n### 3. Numerical Integration and Stabilization Criteria\n\nThe derived system of ODEs does not have a general analytical solution and must be solved numerically. We will use a standard numerical integration routine, `scipy.integrate.solve_ivp`, to solve this initial value problem for each test case over the time interval $[0, t_{\\mathrm{end}}]$.\n\nAfter obtaining the solution for the normalized power, $p(t) = n(t)$, we apply the specified algorithmic criteria to classify the outcome as \"stabilize\" ($true$) or \"diverge\" ($false$).\n\nA case is classified as \"stabilize\" if and only if both conditions are met:\n1.  **Peak Power Limit**: The maximum normalized power over the simulation does not exceed a limit $p_{\\mathrm{lim}}$.\n    $$ \\max_{t \\in [0,t_{\\mathrm{end}}]} p(t) \\le p_{\\mathrm{lim}} $$\n2.  **Relative Slope Limit**: The system is approaching a steady state, indicated by a small maximum relative slope of the power curve in the final $10\\%$ of the simulation time.\n    $$ \\max_{t \\in [0.9 t_{\\mathrm{end}}, t_{\\mathrm{end}}]} \\left| \\dfrac{dp/dt}{p(t) + \\delta} \\right|  \\epsilon_{\\mathrm{rel}} $$\nThe derivative $\\frac{dp}{dt} = \\frac{dn}{dt}$ is evaluated directly from the first ODE using the computed values of $n(t)$, $C(t)$, and $T(t)$. The small constant $\\delta = 10^{-12}$ ensures numerical stability.\n\nIf either of these conditions is not met, the case is classified as \"diverge\". This logic will be implemented for each test case to generate the final boolean results.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the reactor kinetics problem for a series of test cases and\n    determines if the reactor power stabilizes or diverges based on given criteria.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: moderate ramp, strong negative feedback\n        {\n            'r': 1.0e-5, 'alpha_T': -6.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 2: strong ramp, weak negative feedback\n        {\n            'r': 1.0e-4, 'alpha_T': -3.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 60.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 3: zero ramp, baseline negative feedback\n        {\n            'r': 0.0, 'alpha_T': -5.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 4: moderate ramp, very strong negative feedback\n        {\n            'r': 5.0e-5, 'alpha_T': -1.5e-4, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        }\n    ]\n\n    results = []\n\n    def derivatives(t, y, p):\n        \"\"\"\n        Computes the derivatives for the coupled ODE system.\n        y = [n, C, T]\n        p = dictionary of parameters\n        \"\"\"\n        n, C, T = y\n        \n        # Calculate total reactivity\n        rho = p['r'] * t + p['alpha_T'] * (T - p['T_ref'])\n        \n        # ODEs\n        dn_dt = ((rho - p['beta']) / p['Lambda']) * n + p['lambda_'] * C\n        dC_dt = (p['beta'] / p['Lambda']) * n - p['lambda_'] * C\n        dT_dt = (p['P0'] / p['C_T']) * n - (1 / p['tau']) * (T - p['T_inf'])\n        \n        return [dn_dt, dC_dt, dT_dt]\n\n    for case_params in test_cases:\n        # Set initial conditions\n        n0 = 1.0\n        C0 = case_params['beta'] / (case_params['lambda_'] * case_params['Lambda'])\n        T0 = case_params['T_ref']\n        y0 = [n0, C0, T0]\n        \n        t_span = [0, case_params['t_end']]\n        \n        # Use a sufficient number of evaluation points to accurately check criteria\n        t_eval = np.linspace(t_span[0], t_span[1], 2001)\n\n        # Solve the ODE system\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=y0,\n            args=(case_params,),\n            method='RK45',\n            t_eval=t_eval\n        )\n        \n        # Extract normalized power p(t) = n(t)\n        p_t = sol.y[0, :]\n        \n        # --- Apply Stabilization Criteria ---\n        \n        # 1. Peak Power Criterion\n        max_p = np.max(p_t)\n        crit1_met = (max_p = case_params['p_lim'])\n        \n        # 2. Relative Slope Criterion\n        # Find the start index for the final 10% of the simulation time\n        start_index = np.where(sol.t >= 0.9 * case_params['t_end'])[0][0]\n\n        # Get state variables for the final time interval\n        t_final = sol.t[start_index:]\n        y_final = sol.y[:, start_index:]\n        p_final = y_final[0, :]\n        \n        # Calculate the derivative dp/dt over the final interval\n        dp_dt_final = np.array([derivatives(t, y, case_params)[0] for t, y in zip(t_final, y_final.T)])\n        \n        # Calculate the relative slope\n        relative_slope = np.abs(dp_dt_final / (p_final + case_params['delta']))\n        \n        max_relative_slope = np.max(relative_slope)\n        crit2_met = (max_relative_slope  case_params['epsilon_rel'])\n\n        # Final decision\n        is_stable = crit1_met and crit2_met\n        results.append(is_stable)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}