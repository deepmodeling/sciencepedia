{
    "hands_on_practices": [
        {
            "introduction": "理解反应堆对反应性引入的响应是反应堆动力学的基础。本练习的核心是通过推导和求解“反应性-周期”方程（或称“时辰方程”），来计算反应堆功率的渐近增长率，即稳定的反应堆周期。这项经典练习将反应堆的关键物理参数（如反应性 $\\rho$、缓发中子份额 $\\beta$、瞬发中子代时间 $\\Lambda$ 和缓发中子先驱核衰变常数 $\\lambda$）与反应堆的动态行为直接联系起来，是瞬态分析的基石。",
            "id": "4243047",
            "problem": "一个均匀的热中子核反应堆由具有单个有效缓发中子群的点堆动力学模型来模拟。在点堆动力学近似下，总中子布居因瞬发和缓发中子的产生与损失而演变。当在时间 $t=0$ 时引入一个小的阶跃反应性时，中子布居呈现出指数模态，其速率由瞬发中子和缓发中子先驱体之间的耦合平衡决定。\n\n假设反应堆初始时处于临界状态，并在 $t=0$ 时施加一个大小为 $\\rho$ 的恒定正反应性。有效总缓发中子份额为 $\\beta$，瞬发中子代时间为 $\\Lambda$，单个缓发中子群的有效衰变常数为 $\\lambda$。描述中子布居 $n(t)$ 和缓发中子先驱体浓度 $C(t)$ 的控制常微分方程 (ODE) 是基于中子平衡和先驱体衰变定律的标准点堆动力学方程。\n\n给定 $\\beta = 0.0065$，$\\Lambda = 1 \\times 10^{-5}\\,\\mathrm{s}$，$\\lambda = 0.08\\,\\mathrm{s}^{-1}$，以及 $\\rho = 0.004$，请从第一性原理推导指数模态的特征方程，并确定中子布居的渐近指数增长率 $s$，该增长率由长时间下的 $n(t) \\propto \\exp(s t)$ 定义。请以 $\\mathrm{s}^{-1}$ 为单位表示 $s$ 的最终值，并将您的答案四舍五入到四位有效数字。",
            "solution": "该问题经评估是有效的。它在科学上基于成熟的核反应堆动力学点堆模型，在数学上是适定的，并为确定唯一解提供了一套完整且一致的数据。\n\n反应堆动力学由描述中子布居 $n(t)$ 和单个有效缓发中子先驱体群浓度 $C(t)$ 的点堆动力学方程来描述。对于在 $t=0$ 时施加的恒定反应性 $\\rho$，当 $t>0$ 时，控制线性常微分方程为：\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho - \\beta}{\\Lambda} n(t) + \\lambda C(t) \\quad (1)\n$$\n$$\n\\frac{dC(t)}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) \\quad (2)\n$$\n此处，$\\beta$ 是有效缓发中子份额，$\\Lambda$ 是瞬发中子代时间，$\\lambda$ 是有效先驱体衰变常数。\n\n为求系统的指数模态，我们假设解的形式为 $n(t) = n_0 \\exp(st)$ 和 $C(t) = C_0 \\exp(st)$，其中 $s$ 是逆时间常数，或指数增长率，$n_0$ 和 $C_0$ 是振幅。将这些代入方程(1)和(2)得到一个代数方程组：\n$$\ns n_0 \\exp(st) = \\frac{\\rho - \\beta}{\\Lambda} n_0 \\exp(st) + \\lambda C_0 \\exp(st)\n$$\n$$\ns C_0 \\exp(st) = \\frac{\\beta}{\\Lambda} n_0 \\exp(st) - \\lambda C_0 \\exp(st)\n$$\n对于非平凡解，我们可以除以 $\\exp(st)$：\n$$\ns n_0 = \\frac{\\rho - \\beta}{\\Lambda} n_0 + \\lambda C_0 \\quad (3)\n$$\n$$\ns C_0 = \\frac{\\beta}{\\Lambda} n_0 - \\lambda C_0 \\quad (4)\n$$\n从方程(4)，我们可以用 $n_0$ 表示振幅 $C_0$：\n$$\nC_0(s + \\lambda) = \\frac{\\beta}{\\Lambda} n_0\n$$\n$$\nC_0 = \\frac{\\beta}{\\Lambda(s + \\lambda)} n_0\n$$\n将 $C_0$ 的这个表达式代入方程(3)：\n$$\ns n_0 = \\frac{\\rho - \\beta}{\\Lambda} n_0 + \\lambda \\left( \\frac{\\beta}{\\Lambda(s + \\lambda)} n_0 \\right)\n$$\n对于非零中子布居 ($n_0 \\neq 0$)，我们除以 $n_0$ 得到关于 $s$ 的特征方程：\n$$\ns = \\frac{\\rho - \\beta}{\\Lambda} + \\frac{\\lambda \\beta}{\\Lambda(s + \\lambda)}\n$$\n这个方程通常通过解出 $\\rho$ 来重新排列，从而得到“逆时方程”的标准形式：\n$$\ns\\Lambda = \\rho - \\beta + \\frac{\\lambda\\beta}{s+\\lambda}\n$$\n$$\n\\rho = s\\Lambda + \\beta - \\frac{\\lambda\\beta}{s+\\lambda} = s\\Lambda + \\beta\\left(1 - \\frac{\\lambda}{s+\\lambda}\\right) = s\\Lambda + \\beta\\left(\\frac{s+\\lambda-\\lambda}{s+\\lambda}\\right)\n$$\n$$\n\\rho = s\\Lambda + \\frac{s\\beta}{s+\\lambda}\n$$\n渐近增长率是该方程的主导根（最大、最正的根）。为求根，我们将方程重新排列成一个关于 $s$ 的多项式：\n$$\n\\rho(s+\\lambda) = s\\Lambda(s+\\lambda) + s\\beta\n$$\n$$\n\\rho s + \\rho\\lambda = s^2\\Lambda + s\\lambda\\Lambda + s\\beta\n$$\n$$\n\\Lambda s^2 + (\\lambda\\Lambda + \\beta - \\rho)s - \\rho\\lambda = 0\n$$\n这是一个形如 $as^2+bs+c=0$ 的二次方程，其系数为：\n$a = \\Lambda$\n$b = \\lambda\\Lambda + \\beta - \\rho$\n$c = -\\rho\\lambda$\n\n根由二次求根公式给出。渐近增长率对应于较大的根（在分子中使用 `+` 号）：\n$$\ns = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} = \\frac{-(\\lambda\\Lambda + \\beta - \\rho) + \\sqrt{(\\lambda\\Lambda + \\beta - \\rho)^2 + 4\\Lambda\\rho\\lambda}}{2\\Lambda}\n$$\n我们给定以下值：\n$\\beta = 0.0065$\n$\\Lambda = 1 \\times 10^{-5}\\,\\mathrm{s}$\n$\\lambda = 0.08\\,\\mathrm{s}^{-1}$\n$\\rho = 0.004$\n\n首先，我们计算系数 $a$、$b$ 和 $c$：\n$a = \\Lambda = 1 \\times 10^{-5}$\n$b = \\lambda\\Lambda + \\beta - \\rho = (0.08)(1 \\times 10^{-5}) + 0.0065 - 0.004 = 8 \\times 10^{-7} + 0.0025 = 0.0025008$\n$c = -\\rho\\lambda = -(0.004)(0.08) = -0.00032$\n\n接下来，我们计算判别式 $D = b^2 - 4ac$：\n$b^2 = (0.0025008)^2 = 6.25400064 \\times 10^{-6}$\n$-4ac = -4(1 \\times 10^{-5})(-0.00032) = 1.28 \\times 10^{-8} = 0.0128 \\times 10^{-6}$\n$D = 6.25400064 \\times 10^{-6} + 0.0128 \\times 10^{-6} = 6.26680064 \\times 10^{-6}$\n\n现在，我们计算判别式的平方根：\n$\\sqrt{D} = \\sqrt{6.26680064 \\times 10^{-6}} \\approx 0.00250335787$\n\n最后，我们将这些值代入 $s$ 的公式中：\n$$\ns = \\frac{-b + \\sqrt{D}}{2a} = \\frac{-0.0025008 + 0.00250335787}{2 \\times (1 \\times 10^{-5})}\n$$\n$$\ns = \\frac{0.00000255787}{2 \\times 10^{-5}} = \\frac{2.55787 \\times 10^{-6}}{2 \\times 10^{-5}} \\approx 0.1278935 \\, \\mathrm{s}^{-1}\n$$\n按要求将结果四舍五入到四位有效数字，得到：\n$$\ns \\approx 0.1279 \\, \\mathrm{s}^{-1}\n$$\n这个正根对应于稳定的反应堆周期，它控制着超临界反应性引入后中子布居的长期指数增长。",
            "answer": "$$\\boxed{0.1279}$$"
        },
        {
            "introduction": "对于快速的反应性变化，由于瞬发中子代时间 $\\Lambda$ 极短，精确求解点动力学方程组在计算上可能非常苛刻。瞬发跳跃近似是一种强大的简化工具，它将快速的瞬发响应与较慢的缓发中子动态分离开来。本练习要求您通过编程实现并比较精确模型与瞬发跳跃近似模型，从而深入理解这一重要近似的适用范围和局限性。",
            "id": "4243064",
            "problem": "一个反应堆由单区点堆动力学描述，包含一个瞬发中子群体和六组缓发中子先驱核。考虑一个有限持续时间的反应性脉冲，其幅值在时间 $t=0$ 时瞬时施加，并保持恒定，持续时间为 $1\\,\\mathrm{ms}$，之后反应性瞬时恢复为零。目标是比较通过 (i) 直接积分点堆动力学方程和 (ii) 在两个不连续点采用瞬发跳跃近似的模型计算出的在 $t=10\\,\\mathrm{ms}$ 时的中子密度 $n(t)$ 的预测值，并量化其差异。所有时间量在内部必须以秒为单位处理；指定的评估时间为 $t=10\\,\\mathrm{ms}=0.01\\,\\mathrm{s}$。最终的中子密度是无量纲的（相对于初始稳态），差异应以无量纲浮点数的形式报告。\n\n从以下基础出发，这些将作为本问题的基本定律和定义：\n\n- 带缓发中子组的点堆动力学方程：\n$$\\frac{dn(t)}{dt}=\\frac{\\rho(t)-\\beta}{\\Lambda}n(t)+\\sum_{i=1}^{6}\\lambda_i C_i(t),$$\n$$\\frac{dC_i(t)}{dt}=\\frac{\\beta_i}{\\Lambda}n(t)-\\lambda_i C_i(t),\\quad i=1,\\dots,6,$$\n其中 $n(t)$ 是中子密度，$C_i(t)$ 是第 $i$ 组缓发中子先驱核的浓度，$\\rho(t)$ 是反应性（无量纲），$\\beta=\\sum_{i=1}^{6}\\beta_i$ 是总缓发中子份额（无量纲），$\\Lambda$ 是瞬发中子代时间（单位为秒），$\\lambda_i$ 是先驱核组的衰变常数（单位为 $\\mathrm{s}^{-1}$）。这些方程是在点堆动力学假设下，经过充分检验的反应堆动力学模型。\n\n- 在零反应性的初始稳态下，时间导数为零，稳态关系为：\n$$\\rho(0^-)=0,\\quad \\frac{dn}{dt}=0,\\quad \\frac{dC_i}{dt}=0,$$\n这意味着\n$$\\sum_{i=1}^{6}\\lambda_i C_i(0^-)=\\frac{\\beta}{\\Lambda}n(0^-),\\quad C_i(0^-)=\\frac{\\beta_i}{\\lambda_i \\Lambda}n(0^-).$$\n\n将反应性脉冲定义为\n$$\\rho(t)=\\begin{cases}\\Delta \\rho, & 0 \\le t < t_p \\\\ 0, & t \\ge t_p \\end{cases}$$\n脉冲持续时间 $t_p=1\\times 10^{-3}\\,\\mathrm{s}$，$\\Delta \\rho$ 由每个测试用例指定。评估时间固定为 $t_f=10\\times 10^{-3}\\,\\mathrm{s}$。\n\n必须实现两种模型：\n\n1. “精确”模型直接对点堆动力学微分方程进行积分，从 $t=0$ 时的初始稳态 $n(0)=1$ 和 $C_i(0)=\\beta_i/(\\lambda_i \\Lambda)$ 开始，使用上述分段常数 $\\rho(t)$。\n\n2. “瞬发跳跃”近似模型在每个瞬时反应性不连续点强制先驱核浓度 $C_i(t)$ 的连续性，并将中子密度 $n(t)$ 视为在每个不连续点经历瞬时重新标度，以保持先驱核源的一致性。在不连续点之间，使用相应的恒定反应性对点堆动力学方程进行积分。\n\n对于所有计算，请使用以下物理上合理且科学上标准的参数值，这些值适用于铀-235的缓发中子数据（六组）、瞬发中子代时间以及初始条件：\n- 瞬发中子代时间 $\\Lambda=1.0\\times 10^{-4}\\,\\mathrm{s}$。\n- 各组缓发中子份额 $\\beta_i$ (无量纲)：\n  - $\\beta_1=2.15\\times 10^{-4}$,\n  - $\\beta_2=1.424\\times 10^{-3}$,\n  - $\\beta_3=1.274\\times 10^{-3}$,\n  - $\\beta_4=2.568\\times 10^{-3}$,\n  - $\\beta_5=7.48\\times 10^{-4}$,\n  - $\\beta_6=2.73\\times 10^{-4}$,\n  因此总缓发中子份额为 $\\beta=\\sum_{i=1}^{6}\\beta_i=6.502\\times 10^{-3}$。\n- 各组衰变常数 $\\lambda_i$ (单位 $\\mathrm{s}^{-1}$):\n  - $\\lambda_1=1.24\\times 10^{-2}$,\n  - $\\lambda_2=3.05\\times 10^{-2}$,\n  - $\\lambda_3=1.11\\times 10^{-1}$,\n  - $\\lambda_4=3.01\\times 10^{-1}$,\n  - $\\lambda_5=1.14$,\n  - $\\lambda_6=3.01$.\n- $t=0$ 时的初始条件是 $\\rho=0$ 时的稳态值：$n(0)=1$ 以及对每个 $i$ 有 $C_i(0)=\\beta_i/(\\lambda_i \\Lambda)$。\n\n实现这两种模型，并为每个测试用例计算：\n- 来自精确模型的中子密度 $n_{\\mathrm{exact}}(t_f)$ (无量纲)。\n- 来自瞬发跳跃模型的中子密度 $n_{\\mathrm{pj}}(t_f)$ (无量纲)。\n- 绝对差异 $d_{\\mathrm{abs}}=|n_{\\mathrm{exact}}(t_f)-n_{\\mathrm{pj}}(t_f)|$ (无量纲)。\n- 相对差异 $d_{\\mathrm{rel}}=d_{\\mathrm{abs}}/n_{\\mathrm{exact}}(t_f)$ (无量纲)。\n\n测试套件规格：\n- 情况1（一般情况）：$\\Delta \\rho=2.0\\times 10^{-3}$。\n- 情况2（接近瞬发临界边界但次瞬发）：$\\Delta \\rho=6.2\\times 10^{-3}$。\n- 情况3（负脉冲）：$\\Delta \\rho=-1.0\\times 10^{-3}$。\n- 情况4（极小脉冲边缘情况）：$\\Delta \\rho=1.0\\times 10^{-5}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个元素对应一个测试用例，其本身是按顺序 $[n_{\\mathrm{exact}}(t_f),n_{\\mathrm{pj}}(t_f),d_{\\mathrm{abs}},d_{\\mathrm{rel}}]$ 排列的四个浮点数的列表。例如，输出格式必须为：\n$$\\texttt{[[n1\\_exact,n1\\_pj,d1\\_abs,d1\\_rel],[n2\\_exact,n2\\_pj,d2\\_abs,d2\\_rel],[n3\\_exact,n3\\_pj,d3\\_abs,d3\\_rel],[n4\\_exact,n4\\_pj,d4\\_abs,d4\\_rel]]}$$\n不含任何附加文本。所有量均为无量纲，时间单位在内部为秒，指定的评估时间为 $0.01\\,\\mathrm{s}$。",
            "solution": "该问题要求解一个经受有限持续时间反应性脉冲的反应堆的点堆动力学方程，并与瞬发跳跃近似模型进行比较。这个问题有科学依据，是良构的、客观的。它基于核反应堆物理学中的标准模型——点堆动力学方程，并使用了适用于铀-235燃料系统的物理上合理的参数。它构成了一个目标明确、定义良好的初值问题。因此，该问题是有效的，并且可以构建解决方案。\n\n### 1. 数学模型：点堆动力学方程\n\n中子密度 $n(t)$ 和六组缓发中子先驱核浓度 $C_i(t)$ 的时间演化由以下线性常微分方程组 (ODEs) 控制：\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t)-\\beta}{\\Lambda}n(t) + \\sum_{i=1}^{6}\\lambda_i C_i(t)\n$$\n$$\n\\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda}n(t) - \\lambda_i C_i(t), \\quad i=1,\\dots,6\n$$\n其中 $\\rho(t)$ 是反应性，$\\Lambda$ 是瞬发中子代时间，$\\beta_i$ 和 $\\lambda_i$ 分别是第 $i$ 组先驱核的缓发中子份额和衰变常数，$\\beta = \\sum_{i=1}^{6}\\beta_i$ 是总缓发中子份额。\n\n这个包含7个方程的系统可以表示为矩阵形式。设状态向量为 $Y(t) = [n(t), C_1(t), ..., C_6(t)]^T$。那么该系统是：\n$$\n\\frac{dY(t)}{dt} = A(\\rho(t)) Y(t)\n$$\n其中 $A$ 是 $7 \\times 7$ 的动力学矩阵，它依赖于反应性 $\\rho$：\n$$\nA(\\rho) = \\begin{pmatrix}\n\\frac{\\rho - \\beta}{\\Lambda} & \\lambda_1 & \\lambda_2 & \\dots & \\lambda_6 \\\\\n\\frac{\\beta_1}{\\Lambda} & -\\lambda_1 & 0 & \\dots & 0 \\\\\n\\frac{\\beta_2}{\\Lambda} & 0 & -\\lambda_2 & \\dots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\frac{\\beta_6}{\\Lambda} & 0 & 0 & \\dots & -\\lambda_6\n\\end{pmatrix}\n$$\n对于一个分段常数反应性 $\\rho(t) = \\rho_k$（在区间 $[t_{k-1}, t_k)$ 上），矩阵 $A(\\rho_k)$ 是常数。这个常系数线性系统的解由矩阵指数给出：\n$$\nY(t) = e^{A(\\rho_k)(t-t_{k-1})} Y(t_{k-1})\n$$\n\n### 2. “精确”模型解\n\n反应性 $\\rho(t)$ 是由脉冲定义的分段常数函数：\n$$\n\\rho(t) = \\begin{cases}\n\\Delta \\rho, & 0 \\le t < t_p \\\\\n0, & t \\ge t_p\n\\end{cases}\n$$\n其中 $t_p = 1 \\times 10^{-3}\\,\\mathrm{s}$。我们需要找到在 $t_f = 1 \\times 10^{-2}\\,\\mathrm{s}$ 时的状态。\n\n$t=0$ 时的初始条件对应于 $\\rho(0^-)=0$ 的临界稳态。时间导数为零，这给出 $n(0)=1$（通过归一化）和 $C_i(0) = \\frac{\\beta_i}{\\lambda_i \\Lambda}n(0) = \\frac{\\beta_i}{\\lambda_i \\Lambda}$。这定义了初始状态向量 $Y(0)$。\n\n求解过程分两步进行：\n1.  **第一阶段 ($0 \\le t < t_p$)：** 反应性恒定为 $\\rho = \\Delta\\rho$。脉冲结束时 $t_p$ 的状态通过演化初始状态 $Y(0)$ 得到：\n    $$\n    Y(t_p) = e^{A(\\Delta\\rho)t_p} Y(0)\n    $$\n2.  **第二阶段 ($t_p \\le t \\le t_f$)：** 反应性恢复到 $\\rho = 0$。最终时间 $t_f$ 的状态通过在 $t_f - t_p$ 的持续时间内演化从 $t_p$ 开始的状态得到：\n    $$\n    Y(t_f) = e^{A(0)(t_f-t_p)} Y(t_p)\n    $$\n结合这些步骤，精确模型的最终状态是：\n$$\nY_{\\mathrm{exact}}(t_f) = e^{A(0)(t_f-t_p)} e^{A(\\Delta\\rho)t_p} Y(0)\n$$\n中子密度 $n_{\\mathrm{exact}}(t_f)$ 是向量 $Y_{\\mathrm{exact}}(t_f)$ 的第一个分量。\n\n### 3. 瞬发跳跃近似 (PJA) 模型\n\n当反应性变化的时间尺度远快于先驱核衰变常数，但不一定快于瞬发中子代时间时，瞬发跳跃近似是有效的。该模型假设先驱核浓度 $C_i(t)$ 在瞬时反应性变化中是连续的，而中子密度 $n(t)$ 则“跳跃”到一个新值。\n\n跳跃条件是通过假设项 $\\Lambda \\frac{dn}{dt}$ 在远离不连续点时可以忽略不计而导出的，这导致了准静态关系 $n(t) \\approx \\frac{\\Lambda}{\\beta - \\rho(t)} \\sum_{i=1}^{6}\\lambda_i C_i(t)$。在时间 $t_d$ 的不连续点上，由于先驱核浓度 $C_i$（以及它们的和）是连续的，中子密度必须跳跃以维持此关系。这给出了跳跃比：\n$$\n\\frac{n(t_d^+)}{n(t_d^-)} = \\frac{\\beta - \\rho(t_d^-)}{\\beta - \\rho(t_d^+)}\n$$\n\nPJA模型的求解算法如下：\n1.  **初始状态 ($t = 0^-$)：** 系统从与精确模型相同的稳态开始，$Y(0^-) = Y(0)$。\n2.  **在 $t = 0$ 时的跳跃：** 反应性从 $\\rho(0^-) = 0$ 变为 $\\rho(0^+) = \\Delta\\rho$。\n    -   先驱核浓度是连续的：$C_i(0^+) = C_i(0^-)$。\n    -   中子密度发生跳跃：$n(0^+) = n(0^-) \\frac{\\beta - \\rho(0^-)}{\\beta - \\rho(0^+)} = n(0) \\frac{\\beta}{\\beta - \\Delta\\rho}$。\n    -   这为后续的演化定义了一个新的初始状态向量 $Y_{PJ}(0^+)$。\n3.  **从 $t=0^+$ 到 $t=t_p^-$ 的演化：** 系统在持续时间 $t_p$ 内以 $\\rho = \\Delta\\rho$ 演化：\n    $$\n    Y_{PJ}(t_p^-) = e^{A(\\Delta\\rho)t_p} Y_{PJ}(0^+)\n    $$\n4.  **在 $t=t_p$ 时的跳跃：** 反应性从 $\\rho(t_p^-) = \\Delta\\rho$ 变为 $\\rho(t_p^+) = 0$。\n    -   先驱核浓度是连续的：$C_i(t_p^+) = C_i(t_p^-)$。\n    -   中子密度发生跳跃：$n(t_p^+) = n(t_p^-) \\frac{\\beta - \\rho(t_p^-)}{\\beta - \\rho(t_p^+)} = n(t_p^-) \\frac{\\beta - \\Delta\\rho}{\\beta}$。\n    -   这提供了最终演化阶段的状态向量 $Y_{PJ}(t_p^+)$。\n5.  **从 $t=t_p^+$ 到 $t_f$ 的演化：** 系统在持续时间 $t_f - t_p$ 内以 $\\rho = 0$ 演化：\n    $$\n    Y_{PJ}(t_f) = e^{A(0)(t_f-t_p)} Y_{PJ}(t_p^+)\n    $$\n中子密度 $n_{\\mathrm{pj}}(t_f)$ 是向量 $Y_{PJ}(t_f)$ 的第一个分量。\n\n### 4. 差异计算\n\n两种模型之间的绝对和相对差异在最终时间 $t_f$ 计算如下：\n$$\nd_{\\mathrm{abs}} = |n_{\\mathrm{exact}}(t_f) - n_{\\mathrm{pj}}(t_f)|\n$$\n$$\nd_{\\mathrm{rel}} = \\frac{d_{\\mathrm{abs}}}{n_{\\mathrm{exact}}(t_f)}\n$$\n\n### 5. 实现\n\n所描述的算法通过计算实现。对每个反应性值构建动力学矩阵 $A(\\rho)$。矩阵指数 $e^{At}$ 使用 `scipy.linalg.expm` 计算。对于精确模型和PJA模型，状态向量都如上所述在每个阶段进行传播。对每个测试用例的 $\\Delta\\rho$ 值重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the point kinetics equations for a reactivity pulse and compares\n    the result with the prompt jump approximation.\n    \"\"\"\n    \n    # Define physical constants and problem parameters.\n    # Prompt neutron generation time in seconds.\n    Lambda = 1.0e-4\n    \n    # Delayed neutron fractions (dimensionless).\n    beta_i = np.array([\n        2.15e-4, 1.424e-3, 1.274e-3, 2.568e-3, 7.48e-4, 2.73e-4\n    ])\n    \n    # Decay constants in s^-1.\n    lambda_i = np.array([\n        1.24e-2, 3.05e-2, 1.11e-1, 3.01e-1, 1.14, 3.01\n    ])\n    \n    # Total delayed neutron fraction.\n    beta = np.sum(beta_i)\n    \n    # Time parameters in seconds.\n    tp = 1.0e-3  # Pulse duration\n    tf = 10.0e-3 # Final evaluation time\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        2.0e-3,     # Case 1: general\n        6.2e-3,     # Case 2: near prompt-critical\n        -1.0e-3,    # Case 3: negative pulse\n        1.0e-5      # Case 4: very small pulse\n    ]\n\n    def build_A_matrix(rho):\n        \"\"\"Builds the 7x7 point kinetics matrix A for a given reactivity rho.\"\"\"\n        A = np.zeros((7, 7))\n        # Top row for dn/dt\n        A[0, 0] = (rho - beta) / Lambda\n        A[0, 1:] = lambda_i\n        # Subsequent rows for dC_i/dt\n        A[1:, 0] = beta_i / Lambda\n        np.fill_diagonal(A[1:, 1:], -lambda_i)\n        return A\n\n    results = []\n    for delta_rho in test_cases:\n        # Initial conditions: steady state at rho=0, n=1.\n        n0 = 1.0\n        C0 = beta_i / (lambda_i * Lambda) * n0\n        Y0 = np.concatenate(([n0], C0))\n        \n        # --- Model 1: \"Exact\" Integration ---\n        # Construct matrices for the two reactivity intervals.\n        A1 = build_A_matrix(delta_rho)\n        A2 = build_A_matrix(0.0)\n        \n        # Evolve from t=0 to t=tp with rho = delta_rho.\n        Y_tp_exact = expm(A1 * tp) @ Y0\n        \n        # Evolve from t=tp to t=tf with rho = 0.\n        Y_tf_exact = expm(A2 * (tf - tp)) @ Y_tp_exact\n        n_exact = Y_tf_exact[0]\n\n        # --- Model 2: Prompt Jump Approximation ---\n        # State at t=0- is Y0.\n        \n        # Jump at t=0: rho changes from 0 to delta_rho.\n        # Precursors are continuous. Neutron density jumps.\n        n_0_plus = n0 * beta / (beta - delta_rho)\n        Y0_pj = Y0.copy()\n        Y0_pj[0] = n_0_plus\n\n        # Evolve from t=0+ to t=tp- with rho = delta_rho.\n        Y_tp_minus_pj = expm(A1 * tp) @ Y0_pj\n        n_tp_minus_pj = Y_tp_minus_pj[0]\n        \n        # Jump at t=tp: rho changes from delta_rho to 0.\n        # Precursors are continuous. Neutron density jumps.\n        n_tp_plus_pj = n_tp_minus_pj * (beta - delta_rho) / beta\n        Y_tp_plus_pj = Y_tp_minus_pj.copy()\n        Y_tp_plus_pj[0] = n_tp_plus_pj\n        \n        # Evolve from t=tp+ to t=tf with rho = 0.\n        Y_tf_pj = expm(A2 * (tf - tp)) @ Y_tp_plus_pj\n        n_pj = Y_tf_pj[0]\n\n        # --- Discrepancy Calculation ---\n        d_abs = abs(n_exact - n_pj)\n        d_rel = d_abs / n_exact if n_exact != 0 else float('inf')\n        \n        # Append the list of four floats for the current case.\n        results.append([n_exact, n_pj, d_abs, d_rel])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际反应堆中，中子动力学并非孤立存在，而是通过反应性反馈机制与热工水力学紧密耦合。本练习引入了至关重要的温度反馈概念，即反应堆功率的变化影响温度，而温度变化又反过来影响反应性，形成一个闭环系统。通过模拟这一耦合系统并分析其稳定性，我们可以探索更真实的反应堆瞬态过程，并理解功率振荡等现象。",
            "id": "4243049",
            "problem": "考虑一个热核反应堆的点动力学模型，该模型包含一个缓发中子群，通过线性反应性温度系数与单个集总热节点耦合。反应堆在时间 $t=0$ 秒时经历一次阶跃反应性引入。目标是模拟瞬态响应，并对耦合的中子-温度系统是过阻尼还是欠阻尼进行分类。从以下基本要素开始：\n\n- 带有一个缓发中子群的点动力学常微分方程 (ODEs)：\n  - 中子布居动力学 $n(t)$：\n    $$\\frac{dn}{dt} = \\left(\\frac{\\rho(t) - \\beta}{\\Lambda}\\right) n(t) + \\lambda C(t)$$\n  - 缓发中子先驱核浓度 $C(t)$：\n    $$\\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t)$$\n  - 集总热节点温度 $T(t)$：\n    $$\\frac{dT}{dt} = \\frac{\\kappa n(t) - (T(t) - T_c)}{\\tau_T}$$\n- 反应性反馈表示为：\n  $$\\rho(t) = \\rho_{\\text{step}} + \\alpha_T \\left(T(t) - T_0\\right)$$\n- 有效热参数之间的关系如下：\n  $$\\tau_T = \\frac{C_p}{h}, \\quad \\kappa = \\frac{k_h}{h}$$\n  其中，$C_p$ 是有效集总热容，$h$ 是到冷却剂的有效散热系数，$k_h$ 是将归一化反应堆功率转换为热量产生的增益。单位如下：\n  - $t$ 单位为秒，\n  - $T$ 单位为开尔文，\n  - $C_p$ 单位为焦耳/开尔文，\n  - $h$ 单位为瓦特/开尔文，\n  - $k_h$ 单位为瓦特/单位归一化功率，\n  - $\\Lambda$ 单位为秒，\n  - $\\lambda$ 单位为秒的倒数，\n  - $\\beta$ 和 $\\rho$ 是无量纲的反应性分数，\n  - $\\alpha_T$ 单位为反应性/开尔文（无量纲/开尔文）。\n\n假设在 $t=0^{-}$ 时的初始稳态满足临界条件，即净反应性为零且处于热平衡状态。使用一致的初始化：\n- 初始中子布居 $n(0^{-}) = n_0$，\n- 初始先驱核浓度 $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$，\n- 初始燃料温度 $T(0^{-}) = T_0$，\n- 冷却剂参考温度 $T_c = T_0 - \\kappa n_0$ 以确保 $\\frac{dT}{dt}(0^{-}) = 0$。\n\n在 $t=0^{+}$ 时，加入一个阶跃反应性 $\\rho_{\\text{step}}$，系统在耦合动力学下演化。为了进行分类，将系统在阶跃后的新平衡点（由 $\\rho(t)=0$ 和 $\\frac{dn}{dt}=\\frac{dC}{dt}=\\frac{dT}{dt}=0$ 定义）附近进行线性化，并评估雅可比矩阵的特征值。如果雅可比矩阵至少有一对具有负实部的复共轭特征值，则系统被视为欠阻尼；如果所有特征值都是具有负实部的实数，则为过阻尼。如果任何特征值具有正实部，则系统是不稳定的；就本问题而言，所有提供的测试用例都保证是稳定的。\n\n您的程序必须模拟这些常微分方程，并对以下测试套件执行基于特征值的分类。使用指定的单位，并积分到最终时间 $t_{\\text{end}} = 600$ 秒，以生成数值解析的轨迹；然而，分类必须基于阶跃后平衡点的雅可比矩阵。\n\n测试套件参数：\n\n- 案例 1（标称，预期为过阻尼）：\n  - $\\beta = 0.0065$，$\\Lambda = 1.0 \\times 10^{-4}$ 秒，$\\lambda = 0.08$ 秒的倒数，\n  - $\\rho_{\\text{step}} = 0.002$，\n  - $\\alpha_T = -5.0 \\times 10^{-5}$ /开尔文，\n  - $C_p = 1.0 \\times 10^{6}$ 焦耳/开尔文，$h = 2.0 \\times 10^{5}$ 瓦特/开尔文，$k_h = 6.0 \\times 10^{6}$ 瓦特/单位功率，\n  - $n_0 = 1.0$，$T_0 = 600.0$ 开尔文。\n\n- 案例 2（弱反馈和慢热节点，预期为欠阻尼）：\n  - $\\beta = 0.0065$，$\\Lambda = 1.0 \\times 10^{-4}$ 秒，$\\lambda = 0.08$ 秒的倒数，\n  - $\\rho_{\\text{step}} = 0.002$，\n  - $\\alpha_T = -1.0 \\times 10^{-5}$ /开尔文，\n  - $C_p = 5.0 \\times 10^{6}$ 焦耳/开尔文，$h = 2.0 \\times 10^{4}$ 瓦特/开尔文，$k_h = 6.0 \\times 10^{6}$ 瓦特/单位功率，\n  - $n_0 = 1.0$，$T_0 = 600.0$ 开尔文。\n\n- 案例 3（较大阶跃和强反馈，预期为过阻尼）：\n  - $\\beta = 0.0065$，$\\Lambda = 1.0 \\times 10^{-4}$ 秒，$\\lambda = 0.08$ 秒的倒数，\n  - $\\rho_{\\text{step}} = 0.004$，\n  - $\\alpha_T = -1.0 \\times 10^{-4}$ /开尔文，\n  - $C_p = 1.0 \\times 10^{6}$ 焦耳/开尔文，$h = 5.0 \\times 10^{4}$ 瓦特/开尔文，$k_h = 6.0 \\times 10^{6}$ 瓦特/单位功率，\n  - $n_0 = 1.0$，$T_0 = 600.0$ 开尔文。\n\n算法要求：\n- 从 $C_p$、$h$ 和 $k_h$ 计算 $\\tau_T$ 和 $\\kappa$。\n- 初始化 $T_c = T_0 - \\kappa n_0$ 和 $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$，以使阶跃前状态是稳定和临界的。\n- 从 $t=0$ 到 $t_{\\text{end}}$ 秒数值积分耦合的常微分方程以模拟响应（时间单位为秒，温度单位为开尔文）。\n- 根据稳态条件计算阶跃后的平衡值 $(n^{\\star}, C^{\\star}, T^{\\star})$，并构建在该平衡点处右侧函数的雅可比矩阵。\n- 根据雅可比矩阵的特征值对阻尼进行分类：\n  - 过阻尼输出 $0$，\n  - 欠阻尼输出 $1$。\n- 最终的程序输出必须是单行，包含三个案例的三个整数分类的逗号分隔列表，并用方括号括起来，例如 $[0,1,0]$。\n\n您的程序不得读取任何输入，并且必须完全按照指定格式生成其单行输出。所有计算都必须使用上述参数，并必须使用规定的物理单位和数学定义来表示。",
            "solution": "推导始于基本的点动力学方程和集总热能平衡，这在核反应堆动力学中是公认的。我们考虑一个有效的缓发中子群，以保持模型紧凑，同时捕捉必要的缓发中子效应。\n\n中子布居 $n(t)$ 和缓发中子先驱核浓度 $C(t)$ 服从：\n$$\\frac{dn}{dt} = \\left(\\frac{\\rho(t) - \\beta}{\\Lambda}\\right) n(t) + \\lambda C(t), \\quad \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t),$$\n其中 $\\beta$ 是总缓发中子份额，$\\Lambda$ 是中子代时间，$\\lambda$ 是有效缓发中子衰变常数，$\\rho(t)$ 是反应堆反应性。热反馈通过反应性定义引入：\n$$\\rho(t) = \\rho_{\\text{step}} + \\alpha_T (T(t) - T_0),$$\n其中 $\\rho_{\\text{step}}$ 是在 $t=0$ 秒时外部施加的阶跃，$\\alpha_T$ 是反应性温度系数（对于多普勒反馈通常为负）。集总热节点由能量平衡控制：\n$$\\frac{dT}{dt} = \\frac{\\kappa n(t) - (T(t) - T_c)}{\\tau_T},$$\n其中 $\\tau_T = C_p/h$ 是热时间常数，$\\kappa = k_h/h$ 将归一化功率转换为相对于冷却剂的温升，$C_p$ 是有效热容，$h$ 是有效散热系数，$k_h$ 是单位归一化功率的热量产生。冷却剂参考温度 $T_c$ 的设置是为了满足阶跃前的平衡条件：\n$$T_c = T_0 - \\kappa n_0,$$\n使得当 $n(0^{-})=n_0$ 和 $T(0^{-})=T_0$ 时 $\\frac{dT}{dt}(0^{-}) = 0$。\n\n为确保反应堆初始时是临界且处于稳态，缓发先驱核浓度必须满足零反应性下的动力学稳态条件：\n$$\\frac{dn}{dt}(0^{-}) = 0 \\implies -\\frac{\\beta}{\\Lambda} n_0 + \\lambda C(0^{-}) = 0 \\implies C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0.$$\n\n阶跃之后，系统在耦合动力学下演化。新的平衡点 $(n^{\\star}, C^{\\star}, T^{\\star})$ 由零时间导数和零净反应性定义：\n$$\\rho^{\\star} = \\rho_{\\text{step}} + \\alpha_T (T^{\\star} - T_0) = 0,$$\n$$\\frac{dn}{dt} = 0, \\quad \\frac{dC}{dt} = 0, \\quad \\frac{dT}{dt} = 0.$$\n从热稳态，我们有：\n$$T^{\\star} = T_c + \\kappa n^{\\star}.$$\n施加 $\\rho^{\\star} = 0$ 条件可得：\n$$\\rho_{\\text{step}} + \\alpha_T \\left(T_c + \\kappa n^{\\star} - T_0\\right) = 0.$$\n使用 $T_c = T_0 - \\kappa n_0$，这可以简化为：\n$$\\rho_{\\text{step}} + \\alpha_T \\kappa (n^{\\star} - n_0) = 0 \\implies n^{\\star} = n_0 - \\frac{\\rho_{\\text{step}}}{\\alpha_T \\kappa}.$$\n平衡先驱核浓度遵循零反应性下的动力学稳态条件：\n$$C^{\\star} = \\frac{\\beta}{\\lambda \\Lambda} n^{\\star}.$$\n最后，$T^{\\star}$ 通过热平衡获得：$T^{\\star} = T_c + \\kappa n^{\\star}$。\n\n为了对阻尼行为进行分类，我们在 $(n^{\\star}, C^{\\star}, T^{\\star})$ 附近对非线性系统进行线性化，并检查雅可比矩阵（右侧函数的一阶偏导数矩阵）。记状态向量为 $\\mathbf{x} = [n, C, T]^{\\top}$，右侧函数为 $\\mathbf{f}(\\mathbf{x})$：\n$$f_1(n,C,T) = \\left(\\frac{\\rho_{\\text{step}} + \\alpha_T (T - T_0) - \\beta}{\\Lambda}\\right) n + \\lambda C,$$\n$$f_2(n,C,T) = \\frac{\\beta}{\\Lambda} n - \\lambda C,$$\n$$f_3(n,C,T) = \\frac{\\kappa n - (T - T_c)}{\\tau_T}.$$\n平衡点处的雅可比矩阵项为：\n$$\\frac{\\partial f_1}{\\partial n}\\bigg|_{\\star} = \\frac{\\rho^{\\star} - \\beta}{\\Lambda} = -\\frac{\\beta}{\\Lambda}, \\quad \\frac{\\partial f_1}{\\partial C}\\bigg|_{\\star} = \\lambda, \\quad \\frac{\\partial f_1}{\\partial T}\\bigg|_{\\star} = \\frac{\\alpha_T}{\\Lambda} n^{\\star},$$\n$$\\frac{\\partial f_2}{\\partial n}\\bigg|_{\\star} = \\frac{\\beta}{\\Lambda}, \\quad \\frac{\\partial f_2}{\\partial C}\\bigg|_{\\star} = -\\lambda, \\quad \\frac{\\partial f_2}{\\partial T}\\bigg|_{\\star} = 0,$$\n$$\\frac{\\partial f_3}{\\partial n}\\bigg|_{\\star} = \\frac{\\kappa}{\\tau_T}, \\quad \\frac{\\partial f_3}{\\partial C}\\bigg|_{\\star} = 0, \\quad \\frac{\\partial f_3}{\\partial T}\\bigg|_{\\star} = -\\frac{1}{\\tau_T}.$$\n因此，雅可比矩阵为：\n$$\nJ^{\\star} = \\begin{bmatrix}\n-\\beta/\\Lambda & \\lambda & (\\alpha_T/\\Lambda) n^{\\star} \\\\\n\\beta/\\Lambda & -\\lambda & 0 \\\\\n\\kappa/\\tau_T & 0 & -1/\\tau_T\n\\end{bmatrix}.\n$$\n阻尼分类由 $J^{\\star}$ 的特征值 $\\mu$ 决定：\n- 根据此处使用的定义，如果存在一对具有负实部的复共轭特征值（振荡衰减），则系统为欠阻尼。\n- 如果所有特征值都是实数且具有负实部（非振荡衰减），则为过阻尼。\n- 正实部意味着不稳定，但所提供的案例都选择为稳定的。\n\n算法实现：\n1. 对每个测试案例，计算 $\\tau_T = C_p/h$ 和 $\\kappa = k_h/h$。\n2. 设置 $T_c = T_0 - \\kappa n_0$ 和 $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$。\n3. 使用刚性求解器从 $t=0$ 到 $t_{\\text{end}}$ 秒积分常微分方程，以生成轨迹（以秒和开尔文表示）。\n4. 使用上述关系计算平衡值 $(n^{\\star}, C^{\\star}, T^{\\star})$。\n5. 构建 $J^{\\star}$ 并计算其特征值。如果任何特征值具有非零虚部和负实部，则分类为欠阻尼 ($1$)；否则，分类为过阻尼 ($0$)。\n6. 汇总所有测试案例的分类，并以 $[x_1,x_2,x_3]$ 的格式单行打印。\n\n这个过程是基于原理的：它从已建立的点动力学框架和能量平衡出发，为阶跃后条件构建相关的稳态，围绕该稳态进行线性化，并使用雅可比矩阵的特征值来确定定性的阻尼行为。仿真实践确保了瞬态过程的生成与控制物理学一致，尽管分类是由平衡点附近的线性化动力学决定的，后者捕捉了衰减的局部振荡或非振荡性质。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef classify_case(params):\n    # Unpack parameters\n    beta = params[\"beta\"]\n    Lambda = params[\"Lambda\"]\n    lam = params[\"lambda\"]\n    rho_step = params[\"rho_step\"]\n    alpha_T = params[\"alpha_T\"]\n    C_p = params[\"C_p\"]\n    h = params[\"h\"]\n    k_h = params[\"k_h\"]\n    n0 = params[\"n0\"]\n    T0 = params[\"T0\"]\n\n    # Derived thermal parameters\n    tau_T = C_p / h\n    kappa = k_h / h\n\n    # Coolant reference temperature chosen to make pre-step state steady\n    T_c = T0 - kappa * n0\n\n    # Initial precursor concentration for a critical, steady pre-step state\n    C0 = (beta / (lam * Lambda)) * n0\n\n    # Define dynamics\n    def rhs(t, y):\n        n, C, T = y\n        rho = rho_step + alpha_T * (T - T0)\n        dn_dt = ((rho - beta) / Lambda) * n + lam * C\n        dC_dt = (beta / Lambda) * n - lam * C\n        dT_dt = (kappa * n - (T - T_c)) / tau_T\n        return [dn_dt, dC_dt, dT_dt]\n\n    # Simulate transient (not used for classification but required by problem statement)\n    y0 = np.array([n0, C0, T0], dtype=float)\n    t_end = 600.0\n    # Use a stiff solver due to potentially fast prompt dynamics\n    solve_ivp(rhs, (0.0, t_end), y0, method=\"BDF\", rtol=1e-8, atol=1e-10, t_eval=np.linspace(0.0, t_end, 2000))\n\n    # Post-step equilibrium computation\n    # From rho* = 0 and thermal balance T* = T_c + kappa n*\n    # Using T_c relation, solve for n*\n    n_star = n0 - rho_step / (alpha_T * kappa)\n    C_star = (beta / (lam * Lambda)) * n_star\n    T_star = T_c + kappa * n_star\n\n    # Jacobian at equilibrium\n    # df1/dn = (rho* - beta)/Lambda = -beta/Lambda (since rho* = 0)\n    j11 = -beta / Lambda\n    j12 = lam\n    j13 = (alpha_T / Lambda) * n_star\n\n    j21 = beta / Lambda\n    j22 = -lam\n    j23 = 0.0\n\n    j31 = kappa / tau_T\n    j32 = 0.0\n    j33 = -1.0 / tau_T\n\n    J = np.array([[j11, j12, j13],\n                  [j21, j22, j23],\n                  [j31, j32, j33]], dtype=float)\n\n    eigvals = np.linalg.eigvals(J)\n\n    # Classification: underdamped if any eigenvalue has significant imaginary part and negative real part\n    # overdamped if all eigenvalues are real and have negative real parts\n    imag_thresh = 1e-10\n    real_parts = np.real(eigvals)\n    imag_parts = np.imag(eigvals)\n\n    # Stability check (should be stable in provided cases)\n    if np.any(real_parts > 0.0):\n        # If unstable, we still provide a classification;\n        # treat as underdamped if oscillatory, otherwise overdamped (monotonic divergence).\n        if np.any(np.abs(imag_parts) > imag_thresh):\n            return 1\n        else:\n            return 0\n\n    # Oscillatory decay?\n    if np.any(np.abs(imag_parts) > imag_thresh):\n        return 1  # underdamped\n    else:\n        return 0  # overdamped\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: nominal, expected overdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.002,\n            \"alpha_T\": -5.0e-5,\n            \"C_p\": 1.0e6,\n            \"h\": 2.0e5,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n        # Case 2: weak feedback, slow thermal node, expected underdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.002,\n            \"alpha_T\": -1.0e-5,\n            \"C_p\": 5.0e6,\n            \"h\": 2.0e4,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n        # Case 3: larger step, strong feedback, expected overdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.004,\n            \"alpha_T\": -1.0e-4,\n            \"C_p\": 1.0e6,\n            \"h\": 5.0e4,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}