{
    "hands_on_practices": [
        {
            "introduction": "Understanding how a reactor's power level evolves following a change in reactivity is a cornerstone of reactor safety analysis. This exercise guides you through the analytical derivation of the in-hour equation, a fundamental relationship that connects the inserted reactivity to the asymptotic exponential growth rate of the neutron population. By solving this equation for a simplified one-group model, you will gain direct insight into the characteristic time scales, or reactor periods, that govern transient behavior .",
            "id": "4243047",
            "problem": "A homogeneous thermal nuclear reactor is modeled by point kinetics with a single-effective delayed neutron group. Under the point kinetics approximation, the total neutron population evolves due to prompt and delayed neutron production and losses. When a small step reactivity is inserted at time $t=0$, the neutron population exhibits exponential modes whose rates are determined by the coupled balance of prompt neutrons and delayed neutron precursors.\n\nAssume the reactor is initially critical and at $t=0$ a constant positive reactivity insertion of magnitude $\\rho$ is applied. The effective total delayed neutron fraction is $\\beta$, the prompt neutron generation time is $\\Lambda$, and the effective decay constant of the single delayed neutron group is $\\lambda$. The governing ordinary differential equations (ODE) for the neutron population $n(t)$ and the delayed neutron precursor concentration $C(t)$ are the standard point kinetics equations based on neutron balance and precursor decay laws.\n\nGiven $\\beta = 0.0065$, $\\Lambda = 1 \\times 10^{-5}\\,\\mathrm{s}$, $\\lambda = 0.08\\,\\mathrm{s}^{-1}$, and $\\rho = 0.004$, derive from first principles the characteristic equation for the exponential modes and determine the asymptotic exponential growth rate $s$ of the neutron population, defined by $n(t) \\propto \\exp(s t)$ for long times. Express the final value of $s$ in $\\mathrm{s}^{-1}$ and round your answer to four significant figures.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the well-established point kinetics model of nuclear reactor dynamics, is mathematically well-posed, and provides a complete and consistent set of data for determining a unique solution.\n\nThe reactor dynamics are described by the point kinetics equations for the neutron population, $n(t)$, and the concentration of a single effective group of delayed neutron precursors, $C(t)$. For a constant reactivity insertion $\\rho$ applied at $t=0$, the governing linear ordinary differential equations for $t0$ are:\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho - \\beta}{\\Lambda} n(t) + \\lambda C(t) \\quad (1)\n$$\n$$\n\\frac{dC(t)}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) \\quad (2)\n$$\nHere, $\\beta$ is the effective delayed neutron fraction, $\\Lambda$ is the prompt neutron generation time, and $\\lambda$ is the effective precursor decay constant.\n\nTo find the exponential modes of the system, we assume solutions of the form $n(t) = n_0 \\exp(st)$ and $C(t) = C_0 \\exp(st)$, where $s$ is the inverse time constant, or exponential rate, and $n_0$ and $C_0$ are amplitudes. Substituting these into equations (1) and (2) yields a system of algebraic equations:\n$$\ns n_0 \\exp(st) = \\frac{\\rho - \\beta}{\\Lambda} n_0 \\exp(st) + \\lambda C_0 \\exp(st)\n$$\n$$\ns C_0 \\exp(st) = \\frac{\\beta}{\\Lambda} n_0 \\exp(st) - \\lambda C_0 \\exp(st)\n$$\nFor non-trivial solutions, we can divide by $\\exp(st)$:\n$$\ns n_0 = \\frac{\\rho - \\beta}{\\Lambda} n_0 + \\lambda C_0 \\quad (3)\n$$\n$$\ns C_0 = \\frac{\\beta}{\\Lambda} n_0 - \\lambda C_0 \\quad (4)\n$$\nFrom equation (4), we can express the amplitude $C_0$ in terms of $n_0$:\n$$\nC_0(s + \\lambda) = \\frac{\\beta}{\\Lambda} n_0\n$$\n$$\nC_0 = \\frac{\\beta}{\\Lambda(s + \\lambda)} n_0\n$$\nSubstituting this expression for $C_0$ into equation (3):\n$$\ns n_0 = \\frac{\\rho - \\beta}{\\Lambda} n_0 + \\lambda \\left( \\frac{\\beta}{\\Lambda(s + \\lambda)} n_0 \\right)\n$$\nFor a non-zero neutron population ($n_0 \\neq 0$), we divide by $n_0$ to obtain the characteristic equation for $s$:\n$$\ns = \\frac{\\rho - \\beta}{\\Lambda} + \\frac{\\lambda \\beta}{\\Lambda(s + \\lambda)}\n$$\nThis equation is commonly rearranged by solving for $\\rho$, which gives the standard form of the in-hour equation:\n$$\ns\\Lambda = \\rho - \\beta + \\frac{\\lambda\\beta}{s+\\lambda}\n$$\n$$\n\\rho = s\\Lambda + \\beta - \\frac{\\lambda\\beta}{s+\\lambda} = s\\Lambda + \\beta\\left(1 - \\frac{\\lambda}{s+\\lambda}\\right) = s\\Lambda + \\beta\\left(\\frac{s+\\lambda-\\lambda}{s+\\lambda}\\right)\n$$\n$$\n\\rho = s\\Lambda + \\frac{s\\beta}{s+\\lambda}\n$$\nThe asymptotic growth rate is the dominant (largest, most positive) root of this equation. To find the roots, we rearrange the equation into a polynomial in $s$:\n$$\n\\rho(s+\\lambda) = s\\Lambda(s+\\lambda) + s\\beta\n$$\n$$\n\\rho s + \\rho\\lambda = s^2\\Lambda + s\\lambda\\Lambda + s\\beta\n$$\n$$\n\\Lambda s^2 + (\\lambda\\Lambda + \\beta - \\rho)s - \\rho\\lambda = 0\n$$\nThis is a quadratic equation of the form $as^2+bs+c=0$ with coefficients:\n$a = \\Lambda$\n$b = \\lambda\\Lambda + \\beta - \\rho$\n$c = -\\rho\\lambda$\n\nThe roots are given by the quadratic formula. The asymptotic growth rate corresponds to the larger root (using the `+` sign in the numerator):\n$$\ns = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} = \\frac{-(\\lambda\\Lambda + \\beta - \\rho) + \\sqrt{(\\lambda\\Lambda + \\beta - \\rho)^2 + 4\\Lambda\\rho\\lambda}}{2\\Lambda}\n$$\nWe are given the following values:\n$\\beta = 0.0065$\n$\\Lambda = 1 \\times 10^{-5}\\,\\mathrm{s}$\n$\\lambda = 0.08\\,\\mathrm{s}^{-1}$\n$\\rho = 0.004$\n\nFirst, we compute the coefficients $a$, $b$, and $c$:\n$a = \\Lambda = 1 \\times 10^{-5}$\n$b = \\lambda\\Lambda + \\beta - \\rho = (0.08)(1 \\times 10^{-5}) + 0.0065 - 0.004 = 8 \\times 10^{-7} + 0.0025 = 0.0025008$\n$c = -\\rho\\lambda = -(0.004)(0.08) = -0.00032$\n\nNext, we compute the discriminant, $D = b^2 - 4ac$:\n$b^2 = (0.0025008)^2 = 6.25400064 \\times 10^{-6}$\n$-4ac = -4(1 \\times 10^{-5})(-0.00032) = 1.28 \\times 10^{-8} = 0.0128 \\times 10^{-6}$\n$D = 6.25400064 \\times 10^{-6} + 0.0128 \\times 10^{-6} = 6.26680064 \\times 10^{-6}$\n\nNow, we calculate the square root of the discriminant:\n$\\sqrt{D} = \\sqrt{6.26680064 \\times 10^{-6}} \\approx 0.00250335787$\n\nFinally, we substitute these values into the formula for $s$:\n$$\ns = \\frac{-b + \\sqrt{D}}{2a} = \\frac{-0.0025008 + 0.00250335787}{2 \\times (1 \\times 10^{-5})}\n$$\n$$\ns = \\frac{0.00000255787}{2 \\times 10^{-5}} = \\frac{2.55787 \\times 10^{-6}}{2 \\times 10^{-5}} \\approx 0.1278935 \\, \\mathrm{s}^{-1}\n$$\nRounding the result to four significant figures as requested gives:\n$$\ns \\approx 0.1279 \\, \\mathrm{s}^{-1}\n$$\nThis positive root corresponds to the stable reactor period, which governs the long-term exponential growth of the neutron population following a supercritical reactivity insertion.",
            "answer": "$$\\boxed{0.1279}$$"
        },
        {
            "introduction": "While the six-group delayed neutron model provides high fidelity, its complexity can be a bottleneck in large-scale simulations. This practice introduces the essential technique of model order reduction, where we aggregate the six standard groups into a simpler two-group model while aiming to preserve the most important dynamic features. This computational exercise will allow you to quantify the accuracy of such an approximation and understand how the choice of aggregation strategy impacts transient predictions .",
            "id": "4243124",
            "problem": "Consider a spatially lumped neutron population undergoing point kinetics in a nuclear reactor. The neutron population is influenced by prompt neutrons and multiple groups of delayed neutron precursors. The standard neutron balance, aggregated over space, gives rise to point kinetics equations derived from conservation of neutron number, delayed neutron precursor statistics, and linearized reactivity. Let the neutron population be represented by a scalar function $n(t)$, the delayed neutron precursor concentrations by $\\{C_i(t)\\}$, and reactivity by $\\rho(t)$. Assume constant effective prompt neutron generation time $\\Lambda$ and time-independent delayed neutron data for a specified fuel. The reactor is initially in a steady state at zero reactivity and at a normalized power level.\n\nYou must implement a program that, for a step reactivity insertion at $t = 0$, computes the error between the predicted neutron population time histories when using a six-group delayed neutron model versus a two-group model that merges the six groups according to specified partitions. The comparison must isolate the influence of group merging choices.\n\nFundamental basis to use:\n- Neutron number balance and precursor kinetics in point form dictate the coupled system of ordinary differential equations (ODEs) for $m$ precursor groups,\n  $$\n  \\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} \\, n(t) + \\sum_{i=1}^{m} \\lambda_i \\, C_i(t),\n  $$\n  $$\n  \\frac{dC_i}{dt} = \\frac{\\beta_i}{\\Lambda} \\, n(t) - \\lambda_i \\, C_i(t), \\quad i = 1,2,\\dots,m,\n  $$\n  where $\\beta = \\sum_{i=1}^{m} \\beta_i$ is the total delayed neutron fraction, $\\lambda_i$ are decay constants of delayed neutron precursor groups, and $\\beta_i$ are groupwise delayed neutron fractions.\n- The reactor is initially at steady state for $\\rho(t) = 0$, implying\n  $$\n  \\frac{dn}{dt}\\bigg|_{t=0^-} = 0, \\quad \\frac{dC_i}{dt}\\bigg|_{t=0^-} = 0,\n  $$\n  and thus\n  $$\n  n(0^-) = n_0, \\quad C_i(0^-) = \\frac{\\beta_i}{\\Lambda \\lambda_i} \\, n_0.\n  $$\n- At $t=0$, a step reactivity insertion is applied, modeled as $\\rho(t) = \\Delta \\rho$ for $t \\ge 0$ and $\\rho(t) = 0$ for $t  0$.\n\nSix-group data and constants:\n- Use the following six-group delayed neutron data representative of thermal fission of Uranium-235 (scientifically plausible values):\n  $$\n  \\begin{aligned}\n  \\lambda_1 = 0.0124 \\ \\text{s}^{-1},  \\beta_1 = 0.000215, \\\\\n  \\lambda_2 = 0.0305 \\ \\text{s}^{-1},  \\beta_2 = 0.001424, \\\\\n  \\lambda_3 = 0.1110 \\ \\text{s}^{-1},  \\beta_3 = 0.001274, \\\\\n  \\lambda_4 = 0.3010 \\ \\text{s}^{-1},  \\beta_4 = 0.002568, \\\\\n  \\lambda_5 = 1.1400 \\ \\text{s}^{-1},  \\beta_5 = 0.000748, \\\\\n  \\lambda_6 = 3.0100 \\ \\text{s}^{-1},  \\beta_6 = 0.000273.\n  \\end{aligned}\n  $$\n  The total delayed fraction is $\\beta \\approx 0.006502$. Use the effective prompt neutron generation time $\\Lambda = 2.0 \\times 10^{-5} \\ \\text{s}$. Use $n_0 = 1$ as the normalized initial neutron population.\n- All time is in seconds. All outputs must be dimensionless floating-point numbers.\n\nTwo-group aggregation definition:\n- You must build a two-group approximation by partitioning the six original groups into two disjoint merged sets $M_1$ and $M_2$ whose union is the full set $\\{1,2,3,4,5,6\\}$.\n- For each merged set $M_g$, compute\n  $$\n  \\beta_g = \\sum_{i \\in M_g} \\beta_i,\n  $$\n  and choose the effective decay constant $\\lambda_g$ to preserve the steady-state precursor concentration at zero reactivity,\n  $$\n  \\sum_{i \\in M_g} \\frac{\\beta_i}{\\lambda_i} = \\frac{\\beta_g}{\\lambda_g}.\n  $$\n  This implies\n  $$\n  \\lambda_g = \\frac{\\beta_g}{\\sum_{i \\in M_g} \\frac{\\beta_i}{\\lambda_i}}.\n  $$\n\nInitial conditions for all models:\n- For both the six-group and the aggregated two-group models, use the steady-state initial conditions at $t=0$ consistent with $\\rho(0^-)=0$,\n  $$\n  n(0) = n_0, \\quad C_i(0) = \\frac{\\beta_i}{\\Lambda \\lambda_i} \\, n_0,\n  $$\n  and for the two-group model,\n  $$\n  C_g(0) = \\frac{\\beta_g}{\\Lambda \\lambda_g} \\, n_0.\n  $$\n\nSimulation and error metrics:\n- Integrate the ODEs for each model for $t \\in [0, T]$ with $T = 40 \\ \\text{s}$ using a numerically stable method suitable for stiff systems. Evaluate both $n_{6}(t)$ (six-group) and $n_{2}(t)$ (two-group) on a uniform grid of $N = 4000$ points over $[0,40]$.\n- Define the instantaneous relative error as\n  $$\n  e(t) = \\frac{\\left| n_{2}(t) - n_{6}(t) \\right|}{\\max\\left(n_{6}(t), \\varepsilon\\right)},\n  $$\n  with $\\varepsilon = 10^{-12}$ to avoid division by very small denominators.\n- Compute the following metrics:\n  1. Root-mean-square relative error over the grid,\n     $$\n     E_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N} \\sum_{k=1}^{N} e(t_k)^2}.\n     $$\n  2. Maximum relative error over the grid,\n     $$\n     E_{\\max} = \\max_{k} e(t_k).\n     $$\n  3. Final-time relative error,\n     $$\n     E_{\\mathrm{final}} = e(T).\n     $$\n\nTest suite:\n- You must evaluate three test cases to expose the effect of merging choices and different reactivity magnitudes:\n  1. Case A (small positive step, balanced merge): $\\Delta \\rho = 0.002$, $M_1 = \\{1,2,3\\}$ and $M_2 = \\{4,5,6\\}$.\n  2. Case B (near prompt-critical, fast-heavy merge): $\\Delta \\rho = 0.0055$, $M_1 = \\{1,2\\}$ and $M_2 = \\{3,4,5,6\\}$.\n  3. Case C (negative step, shutdown, very slow-heavy merge): $\\Delta \\rho = -0.003$, $M_1 = \\{1,2,3,4\\}$ and $M_2 = \\{5,6\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the nine floating-point results for the three cases in order, flattened as\n  $$\n  [E_{\\mathrm{rms}}^{A}, E_{\\max}^{A}, E_{\\mathrm{final}}^{A}, E_{\\mathrm{rms}}^{B}, E_{\\max}^{B}, E_{\\mathrm{final}}^{B}, E_{\\mathrm{rms}}^{C}, E_{\\max}^{C}, E_{\\mathrm{final}}^{C}],\n  $$\n  printed as a comma-separated list enclosed in square brackets, with no additional text. All numbers are dimensionless. Time is in seconds wherever applicable in computations.",
            "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically grounded in the well-established principles of nuclear reactor kinetics, is mathematically well-posed as an initial value problem, and is specified with objective, unambiguous language and data. All necessary parameters and conditions for a unique solution are provided, and the data are physically realistic. We may therefore proceed with a formal solution.\n\nThe problem requires a comparison between a six-group and a two-group delayed neutron model for a reactor transient simulated using the point kinetics equations. The solution involves numerically integrating a system of coupled ordinary differential equations (ODEs) for each model and then quantifying the discrepancy between their predictions for the neutron population.\n\nThe temporal evolution of the neutron population, $n(t)$, and the concentration of the $i$-th group of delayed neutron precursors, $C_i(t)$, are governed by the point kinetics equations for $m$ precursor groups:\n$$\n\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} \\, n(t) + \\sum_{i=1}^{m} \\lambda_i \\, C_i(t)\n$$\n$$\n\\frac{dC_i}{dt} = \\frac{\\beta_i}{\\Lambda} \\, n(t) - \\lambda_i \\, C_i(t), \\quad i = 1, 2, \\dots, m\n$$\nHere, $\\rho(t)$ is the reactivity, $\\Lambda$ is the effective prompt neutron generation time, $\\lambda_i$ is the decay constant for the $i$-th precursor group, $\\beta_i$ is its delayed neutron fraction, and $\\beta = \\sum_{i=1}^{m} \\beta_i$ is the total delayed neutron fraction.\n\nThis system of $m+1$ coupled first-order ODEs can be written in vector form. Let the state vector be $\\boldsymbol{y}(t) = [n(t), C_1(t), \\dots, C_m(t)]^T$. The system is then an initial value problem of the form $\\frac{d\\boldsymbol{y}}{dt} = f(t, \\boldsymbol{y})$.\n\nThe reactor is initially in a critical steady state, meaning $\\rho(t0) = 0$ and all time derivatives are zero. This provides the initial conditions at $t=0$:\n$$\nn(0) = n_0\n$$\n$$\nC_i(0) = \\frac{\\beta_i}{\\Lambda \\lambda_i} n_0\n$$\nFor this problem, we use the normalized initial population $n_0 = 1$. The transient is initiated by a step reactivity insertion, $\\rho(t) = \\Delta\\rho$ for $t \\ge 0$.\n\nThe wide disparity in the characteristic time scales of the system—from the very short prompt neutron lifetime $\\Lambda$ (on the order of $10^{-5} \\, \\text{s}$) to the long lifetime of the slowest decaying precursor group ($1/\\lambda_1$, on the order of $80 \\, \\text{s}$)—renders the ODE system \"stiff.\" Therefore, a numerical integration method suitable for stiff systems, such as the Backward Differentiation Formula (BDF) method, must be employed to ensure a stable and accurate solution. We will use the `solve_ivp` function from the `scipy.integrate` library, configured with the 'BDF' method.\n\nThe core of the analysis involves creating a reduced two-group model from the reference six-group model. For a partition of the original six groups into two merged sets, $M_1$ and $M_2$, the parameters for each new group $g \\in \\{1,2\\}$ are calculated as follows:\nThe delayed neutron fraction for the merged group, $\\beta_g$, is the sum of the constituent fractions:\n$$\n\\beta_g = \\sum_{i \\in M_g} \\beta_i\n$$\nThis ensures that the total delayed neutron fraction is conserved. The effective decay constant, $\\lambda_g$, is defined as a weighted harmonic mean:\n$$\n\\lambda_g = \\frac{\\beta_g}{\\sum_{i \\in M_g} \\frac{\\beta_i}{\\lambda_i}}\n$$\nThis specific weighting preserves the total precursor concentration for each merged group under steady-state conditions, ensuring that the initial conditions for the reduced model are consistent with the original model's equilibrium state.\n\nThe algorithmic procedure is as follows:\n1.  Define the six-group nuclear data ($\\boldsymbol{\\lambda}_{6G}$, $\\boldsymbol{\\beta}_{6G}$) and physical constants ($\\Lambda$, $n_0$).\n2.  For each of the three test cases specified:\n    a. Solve the six-group point kinetics equations over the time interval $t \\in [0, 40]$ s to obtain the reference neutron population history, $n_{6}(t)$.\n    b. Using the specified partitioning scheme for the test case, compute the two-group parameters ($\\boldsymbol{\\lambda}_{2G}$, $\\boldsymbol{\\beta}_{2G}$) via the aggregation formulae.\n    c. Solve the two-group point kinetics equations over the same time interval to obtain the approximate neutron population history, $n_2(t)$.\n    d. Calculate the instantaneous relative error, $e(t) = |n_{2}(t) - n_{6}(t)| / \\max(n_{6}(t), \\varepsilon)$, where $\\varepsilon=10^{-12}$ is a small regularization constant.\n    e. From the time series of relative error, compute the three specified performance metrics: the root-mean-square relative error ($E_{\\mathrm{rms}}$), the maximum relative error ($E_{\\max}$), and the final-time relative error ($E_{\\mathrm{final}}$).\n3.  Aggregate the nine computed error metrics (three for each of the three cases) and present them in the specified format. This process will systematically evaluate the accuracy of different group-merging strategies under various reactivity scenarios.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the point kinetics equations for 6-group and 2-group models,\n    and computes the error metrics between them for three test cases.\n    \"\"\"\n    # Define global constants and six-group data\n    LAMBDA = 2.0e-5  # s\n    N0 = 1.0  # dimensionless\n    T_FINAL = 40.0  # s\n    N_POINTS = 4000\n    EPSILON = 1e-12\n\n    # Six-group delayed neutron data for U-235\n    # lambdas are in s^-1, betas are dimensionless\n    LAMBDAS_6G = np.array([0.0124, 0.0305, 0.1110, 0.3010, 1.1400, 3.0100])\n    BETAS_6G = np.array([0.000215, 0.001424, 0.001274, 0.002568, 0.000748, 0.000273])\n\n    def point_kinetics_rhs(t, y, rho, Lambda, betas, lambdas):\n        \"\"\"\n        Right-hand side of the point kinetics ODE system.\n        y: state vector [n, C_1, C_2, ..., C_m]\n        \"\"\"\n        n = y[0]\n        C = y[1:]\n        m = len(betas)\n        beta_total = np.sum(betas)\n        \n        dydt = np.zeros_like(y)\n        \n        # Neutron population equation\n        dydt[0] = ((rho - beta_total) / Lambda) * n + np.sum(lambdas * C)\n        \n        # Precursor concentration equations\n        dydt[1:] = (betas / Lambda) * n - lambdas * C\n        \n        return dydt\n\n    def aggregate_groups(base_lambdas, base_betas, partitions):\n        \"\"\"\n        Aggregates delayed neutron data from a base model into a reduced group model.\n        partitions: list of lists of 0-based indices.\n        \"\"\"\n        num_merged_groups = len(partitions)\n        merged_lambdas = np.zeros(num_merged_groups)\n        merged_betas = np.zeros(num_merged_groups)\n\n        for g, group_indices in enumerate(partitions):\n            # Sum betas for the new group\n            beta_g = np.sum(base_betas[group_indices])\n            merged_betas[g] = beta_g\n            \n            # Calculate effective lambda\n            # lambda_g = beta_g / sum(beta_i / lambda_i)\n            sum_beta_over_lambda = np.sum(base_betas[group_indices] / base_lambdas[group_indices])\n            lambda_g = beta_g / sum_beta_over_lambda if sum_beta_over_lambda > 0 else 0.0\n            merged_lambdas[g] = lambda_g\n            \n        return merged_lambdas, merged_betas\n\n    def run_simulation(rho_step, Lambda, betas, lambdas, n0, T, N):\n        \"\"\"\n        Runs a point kinetics simulation for a given model.\n        \"\"\"\n        m = len(betas)\n        \n        # Initial conditions for steady state (rho=0)\n        y0 = np.zeros(m + 1)\n        y0[0] = n0\n        y0[1:] = (betas / (Lambda * lambdas)) * n0\n        \n        t_span = [0, T]\n        t_eval = np.linspace(t_span[0], t_span[1], N)\n        \n        # Solve the stiff ODE system\n        sol = solve_ivp(\n            point_kinetics_rhs,\n            t_span,\n            y0,\n            method='BDF',\n            t_eval=t_eval,\n            args=(rho_step, Lambda, betas, lambdas),\n            rtol=1e-8,\n            atol=1e-10\n        )\n        \n        return sol.y[0, :]\n\n    # Define the test cases\n    # Each case: (delta_rho, list_of_partitions)\n    # Partitions use 0-based indexing for the 6 groups.\n    test_cases = [\n        (0.0020, [[0, 1, 2], [3, 4, 5]]),   # Case A\n        (0.0055, [[0, 1], [2, 3, 4, 5]]),     # Case B\n        (-0.0030, [[0, 1, 2, 3], [4, 5]])   # Case C\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        rho_step, partitions = case\n\n        # 1. Run 6-group reference simulation\n        n6_t = run_simulation(rho_step, LAMBDA, BETAS_6G, LAMBDAS_6G, N0, T_FINAL, N_POINTS)\n        \n        # 2. Create and run 2-group model\n        lambdas_2g, betas_2g = aggregate_groups(LAMBDAS_6G, BETAS_6G, partitions)\n        n2_t = run_simulation(rho_step, LAMBDA, betas_2g, lambdas_2g, N0, T_FINAL, N_POINTS)\n        \n        # 3. Calculate error metrics\n        relative_error = np.abs(n2_t - n6_t) / np.maximum(n6_t, EPSILON)\n        \n        e_rms = np.sqrt(np.mean(relative_error**2))\n        e_max = np.max(relative_error)\n        e_final = relative_error[-1]\n        \n        all_results.extend([e_rms, e_max, e_final])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A reactor's kinetic behavior is intrinsically linked to its thermal state through reactivity feedback mechanisms. This advanced practice moves beyond pure kinetics to explore these coupled dynamics by introducing a temperature feedback model, which is critical for predicting realistic reactor behavior and ensuring stability. Through simulation and linear stability analysis, you will determine whether the system's response to a disturbance is overdamped (monotonic) or underdamped (oscillatory), a key factor in reactor design and control .",
            "id": "4243049",
            "problem": "Consider the point-kinetics model for a thermal nuclear reactor with one delayed neutron group, coupled to a single lumped thermal node via a linear temperature coefficient of reactivity. The reactor undergoes a step reactivity insertion at time $t=0$ seconds. The goal is to simulate the transient response and classify whether the coupled neutron-temperature system is overdamped or underdamped. Start from the following foundational elements:\n\n- The point-kinetics ordinary differential equations (ODEs) with one delayed neutron group:\n  - Neutron population dynamics $n(t)$:\n    $$\\frac{dn}{dt} = \\left(\\frac{\\rho(t) - \\beta}{\\Lambda}\\right) n(t) + \\lambda C(t)$$\n  - Delayed neutron precursor concentration $C(t)$:\n    $$\\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t)$$\n  - Lumped thermal node temperature $T(t)$:\n    $$\\frac{dT}{dt} = \\frac{\\kappa n(t) - (T(t) - T_c)}{\\tau_T}$$\n- Reactivity feedback is represented as:\n  $$\\rho(t) = \\rho_{\\text{step}} + \\alpha_T \\left(T(t) - T_0\\right)$$\n- The effective thermal parameters are related by:\n  $$\\tau_T = \\frac{C_p}{h}, \\quad \\kappa = \\frac{k_h}{h}$$\n  where $C_p$ is the effective lumped heat capacity, $h$ is the effective heat removal coefficient to the coolant, and $k_h$ is the gain converting normalized reactor power to heat generation. Units are:\n  - $t$ in seconds,\n  - $T$ in Kelvin,\n  - $C_p$ in Joule per Kelvin,\n  - $h$ in Watt per Kelvin,\n  - $k_h$ in Watt per unit normalized power,\n  - $\\Lambda$ in seconds,\n  - $\\lambda$ in inverse seconds,\n  - $\\beta$ and $\\rho$ are dimensionless reactivity fractions,\n  - $\\alpha_T$ in reactivity per Kelvin (dimensionless per Kelvin).\n\nAssume the initial steady state at $t=0^{-}$ satisfies criticality with zero net reactivity and thermal equilibrium. Use the consistent initialization:\n- Initial neutron population $n(0^{-}) = n_0$,\n- Initial precursor concentration $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$,\n- Initial fuel temperature $T(0^{-}) = T_0$,\n- Coolant reference temperature $T_c = T_0 - \\kappa n_0$ to ensure $\\frac{dT}{dt}(0^{-}) = 0$.\n\nAt $t=0^{+}$, a step reactivity $\\rho_{\\text{step}}$ is added, and the system evolves under the coupled dynamics. For classification, linearize the system around the new equilibrium after the step, defined by $\\rho(t)=0$ and $\\frac{dn}{dt}=\\frac{dC}{dt}=\\frac{dT}{dt}=0$, and evaluate the Jacobian eigenvalues. A system is considered underdamped if the Jacobian has at least one complex-conjugate pair of eigenvalues with negative real parts, and overdamped if all eigenvalues are real with negative real parts. If any eigenvalue has a positive real part, the system is unstable; for the purposes of this problem, all provided test cases are guaranteed to be stable.\n\nYour program must simulate the ODEs and perform the eigenvalue-based classification for the following test suite. Use the specified units, and integrate for a final time of $t_{\\text{end}} = 600$ seconds to produce a numerically resolved trajectory; however, classification must be based on the Jacobian at the post-step equilibrium.\n\nTest Suite Parameters:\n\n- Case $1$ (nominal, expected overdamped):\n  - $\\beta = 0.0065$, $\\Lambda = 1.0 \\times 10^{-4}$ seconds, $\\lambda = 0.08$ inverse seconds,\n  - $\\rho_{\\text{step}} = 0.002$,\n  - $\\alpha_T = -5.0 \\times 10^{-5}$ per Kelvin,\n  - $C_p = 1.0 \\times 10^{6}$ Joule per Kelvin, $h = 2.0 \\times 10^{5}$ Watt per Kelvin, $k_h = 6.0 \\times 10^{6}$ Watt per unit power,\n  - $n_0 = 1.0$, $T_0 = 600.0$ Kelvin.\n\n- Case $2$ (weak feedback and slow thermal node, expected underdamped):\n  - $\\beta = 0.0065$, $\\Lambda = 1.0 \\times 10^{-4}$ seconds, $\\lambda = 0.08$ inverse seconds,\n  - $\\rho_{\\text{step}} = 0.002$,\n  - $\\alpha_T = -1.0 \\times 10^{-5}$ per Kelvin,\n  - $C_p = 5.0 \\times 10^{6}$ Joule per Kelvin, $h = 2.0 \\times 10^{4}$ Watt per Kelvin, $k_h = 6.0 \\times 10^{6}$ Watt per unit power,\n  - $n_0 = 1.0$, $T_0 = 600.0$ Kelvin.\n\n- Case $3$ (larger step and strong feedback, expected overdamped):\n  - $\\beta = 0.0065$, $\\Lambda = 1.0 \\times 10^{-4}$ seconds, $\\lambda = 0.08$ inverse seconds,\n  - $\\rho_{\\text{step}} = 0.004$,\n  - $\\alpha_T = -1.0 \\times 10^{-4}$ per Kelvin,\n  - $C_p = 1.0 \\times 10^{6}$ Joule per Kelvin, $h = 5.0 \\times 10^{4}$ Watt per Kelvin, $k_h = 6.0 \\times 10^{6}$ Watt per unit power,\n  - $n_0 = 1.0$, $T_0 = 600.0$ Kelvin.\n\nAlgorithmic requirements:\n- Compute $\\tau_T$ and $\\kappa$ from $C_p$, $h$, and $k_h$.\n- Initialize $T_c = T_0 - \\kappa n_0$ and $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$ so the pre-step state is steady and critical.\n- Numerically integrate the coupled ODEs from $t=0$ to $t_{\\text{end}}$ seconds to simulate the response (time in seconds, temperature in Kelvin).\n- Compute the post-step equilibrium values $(n^{\\star}, C^{\\star}, T^{\\star})$ from the steady-state conditions and form the Jacobian matrix of the right-hand side at that equilibrium.\n- Classify the damping based on the Jacobian’s eigenvalues:\n  - Output $0$ for overdamped,\n  - Output $1$ for underdamped.\n- The final program output must be a single line containing a comma-separated list of the three integer classifications for the three cases, enclosed in square brackets, for example $[0,1,0]$.\n\nYour program must not read any input and must produce its single line of output exactly in the specified format. All computations must use the above parameters and must be expressed using the prescribed physical units and mathematical definitions.",
            "solution": "The derivation begins from the fundamental point-kinetics equations and a lumped thermal energy balance, which are well-established in nuclear reactor dynamics. We consider one effective delayed neutron group to keep the model compact while capturing essential delayed neutron effects.\n\nThe neutron population $n(t)$ and delayed neutron precursor concentration $C(t)$ obey:\n$$\\frac{dn}{dt} = \\left(\\frac{\\rho(t) - \\beta}{\\Lambda}\\right) n(t) + \\lambda C(t), \\quad \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t),$$\nwhere $\\beta$ is the total delayed neutron fraction, $\\Lambda$ is the neutron generation time, $\\lambda$ is the effective delayed neutron decay constant, and $\\rho(t)$ is the reactor reactivity. The thermal feedback enters via the reactivity definition:\n$$\\rho(t) = \\rho_{\\text{step}} + \\alpha_T (T(t) - T_0),$$\nwith $\\rho_{\\text{step}}$ the externally imposed step at $t=0$ seconds, and $\\alpha_T$ the temperature coefficient of reactivity (typically negative for Doppler feedback). The lumped thermal node is governed by energy balance:\n$$\\frac{dT}{dt} = \\frac{\\kappa n(t) - (T(t) - T_c)}{\\tau_T},$$\nwhere $\\tau_T = C_p/h$ is the thermal time constant, $\\kappa = k_h/h$ converts normalized power to temperature rise relative to coolant, $C_p$ is the effective heat capacity, $h$ is the effective heat removal coefficient, and $k_h$ is the heat generation per unit normalized power. The coolant reference temperature $T_c$ is set such that the pre-step equilibrium is satisfied:\n$$T_c = T_0 - \\kappa n_0,$$\nmaking $\\frac{dT}{dt}(0^{-}) = 0$ when $n(0^{-})=n_0$ and $T(0^{-})=T_0$.\n\nTo ensure the reactor is initially critical and at steady state, the delayed precursor concentration must satisfy the kinetic steady-state condition with zero reactivity:\n$$\\frac{dn}{dt}(0^{-}) = 0 \\implies -\\frac{\\beta}{\\Lambda} n_0 + \\lambda C(0^{-}) = 0 \\implies C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0.$$\n\nAfter the step, the system evolves under the coupled dynamics. The new equilibrium $(n^{\\star}, C^{\\star}, T^{\\star})$ is defined by zero time derivatives and zero net reactivity:\n$$\\rho^{\\star} = \\rho_{\\text{step}} + \\alpha_T (T^{\\star} - T_0) = 0,$$\n$$\\frac{dn}{dt} = 0, \\quad \\frac{dC}{dt} = 0, \\quad \\frac{dT}{dt} = 0.$$\nFrom the thermal steady-state, we have:\n$$T^{\\star} = T_c + \\kappa n^{\\star}.$$\nImposing $\\rho^{\\star} = 0$ yields:\n$$\\rho_{\\text{step}} + \\alpha_T \\left(T_c + \\kappa n^{\\star} - T_0\\right) = 0.$$\nUsing $T_c = T_0 - \\kappa n_0$, this simplifies to:\n$$\\rho_{\\text{step}} + \\alpha_T \\kappa (n^{\\star} - n_0) = 0 \\implies n^{\\star} = n_0 - \\frac{\\rho_{\\text{step}}}{\\alpha_T \\kappa}.$$\nThe equilibrium precursor concentration follows from the kinetic steady-state condition with zero reactivity:\n$$C^{\\star} = \\frac{\\beta}{\\lambda \\Lambda} n^{\\star}.$$\nFinally, $T^{\\star}$ is obtained by thermal balance: $T^{\\star} = T_c + \\kappa n^{\\star}$.\n\nTo classify the damping behavior, we linearize the nonlinear system around $(n^{\\star}, C^{\\star}, T^{\\star})$ and examine the Jacobian (the matrix of first partial derivatives of the right-hand side). Denote the state vector $\\mathbf{x} = [n, C, T]^{\\top}$ and the right-hand side $\\mathbf{f}(\\mathbf{x})$:\n$$f_1(n,C,T) = \\left(\\frac{\\rho_{\\text{step}} + \\alpha_T (T - T_0) - \\beta}{\\Lambda}\\right) n + \\lambda C,$$\n$$f_2(n,C,T) = \\frac{\\beta}{\\Lambda} n - \\lambda C,$$\n$$f_3(n,C,T) = \\frac{\\kappa n - (T - T_c)}{\\tau_T}.$$\nThe Jacobian entries at equilibrium are:\n$$\\frac{\\partial f_1}{\\partial n}\\bigg|_{\\star} = \\frac{\\rho^{\\star} - \\beta}{\\Lambda} = -\\frac{\\beta}{\\Lambda}, \\quad \\frac{\\partial f_1}{\\partial C}\\bigg|_{\\star} = \\lambda, \\quad \\frac{\\partial f_1}{\\partial T}\\bigg|_{\\star} = \\frac{\\alpha_T}{\\Lambda} n^{\\star},$$\n$$\\frac{\\partial f_2}{\\partial n}\\bigg|_{\\star} = \\frac{\\beta}{\\Lambda}, \\quad \\frac{\\partial f_2}{\\partial C}\\bigg|_{\\star} = -\\lambda, \\quad \\frac{\\partial f_2}{\\partial T}\\bigg|_{\\star} = 0,$$\n$$\\frac{\\partial f_3}{\\partial n}\\bigg|_{\\star} = \\frac{\\kappa}{\\tau_T}, \\quad \\frac{\\partial f_3}{\\partial C}\\bigg|_{\\star} = 0, \\quad \\frac{\\partial f_3}{\\partial T}\\bigg|_{\\star} = -\\frac{1}{\\tau_T}.$$\nHence, the Jacobian matrix is:\n$$\nJ^{\\star} = \\begin{bmatrix}\n-\\beta/\\Lambda  \\lambda  (\\alpha_T/\\Lambda) n^{\\star} \\\\\n\\beta/\\Lambda  -\\lambda  0 \\\\\n\\kappa/\\tau_T  0  -1/\\tau_T\n\\end{bmatrix}.\n$$\nThe damping classification is determined by the eigenvalues $\\mu$ of $J^{\\star}$:\n- Under the definition used here, the system is underdamped if there exists a complex-conjugate pair with negative real parts (oscillatory decay).\n- It is overdamped if all eigenvalues are real and have negative real parts (non-oscillatory decay).\n- Positive real parts would imply instability, but the provided cases are chosen to be stable.\n\nAlgorithmic implementation:\n1. For each test case, compute $\\tau_T = C_p/h$ and $\\kappa = k_h/h$.\n2. Set $T_c = T_0 - \\kappa n_0$ and $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$.\n3. Integrate the ODEs from $t=0$ to $t_{\\text{end}}$ seconds using a stiff solver to produce a trajectory (expressed in seconds and Kelvin).\n4. Compute the equilibrium values $(n^{\\star}, C^{\\star}, T^{\\star})$ using the above relations.\n5. Form $J^{\\star}$ and compute its eigenvalues. If any eigenvalue has a nonzero imaginary part with negative real part, classify as underdamped ($1$); otherwise, classify as overdamped ($0$).\n6. Aggregate the classifications for all test cases and print them as a single line in the format $[x_1,x_2,x_3]$.\n\nThis procedure is principle-based: it begins from the established point-kinetics framework and energy balance, constructs the relevant steady state for the post-step condition, linearizes about that steady state, and uses the eigenvalues of the Jacobian to determine the qualitative damping behavior. The simulation ensures the transient is generated consistently with the governing physics, though the classification is decided by the linearized dynamics near equilibrium, which captures the local oscillatory or non-oscillatory nature of the decay.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef classify_case(params):\n    # Unpack parameters\n    beta = params[\"beta\"]\n    Lambda = params[\"Lambda\"]\n    lam = params[\"lambda\"]\n    rho_step = params[\"rho_step\"]\n    alpha_T = params[\"alpha_T\"]\n    C_p = params[\"C_p\"]\n    h = params[\"h\"]\n    k_h = params[\"k_h\"]\n    n0 = params[\"n0\"]\n    T0 = params[\"T0\"]\n\n    # Derived thermal parameters\n    tau_T = C_p / h\n    kappa = k_h / h\n\n    # Coolant reference temperature chosen to make pre-step state steady\n    T_c = T0 - kappa * n0\n\n    # Initial precursor concentration for a critical, steady pre-step state\n    C0 = (beta / (lam * Lambda)) * n0\n\n    # Define dynamics\n    def rhs(t, y):\n        n, C, T = y\n        rho = rho_step + alpha_T * (T - T0)\n        dn_dt = ((rho - beta) / Lambda) * n + lam * C\n        dC_dt = (beta / Lambda) * n - lam * C\n        dT_dt = (kappa * n - (T - T_c)) / tau_T\n        return [dn_dt, dC_dt, dT_dt]\n\n    # Simulate transient (not used for classification but required by problem statement)\n    y0 = np.array([n0, C0, T0], dtype=float)\n    t_end = 600.0\n    # Use a stiff solver due to potentially fast prompt dynamics\n    solve_ivp(rhs, (0.0, t_end), y0, method=\"BDF\", rtol=1e-8, atol=1e-10, t_eval=np.linspace(0.0, t_end, 2000))\n\n    # Post-step equilibrium computation\n    # From rho* = 0 and thermal balance T* = T_c + kappa n*\n    # Using T_c relation, solve for n*\n    n_star = n0 - rho_step / (alpha_T * kappa)\n    C_star = (beta / (lam * Lambda)) * n_star\n    T_star = T_c + kappa * n_star\n\n    # Jacobian at equilibrium\n    # df1/dn = (rho* - beta)/Lambda = -beta/Lambda (since rho* = 0)\n    j11 = -beta / Lambda\n    j12 = lam\n    j13 = (alpha_T / Lambda) * n_star\n\n    j21 = beta / Lambda\n    j22 = -lam\n    j23 = 0.0\n\n    j31 = kappa / tau_T\n    j32 = 0.0\n    j33 = -1.0 / tau_T\n\n    J = np.array([[j11, j12, j13],\n                  [j21, j22, j23],\n                  [j31, j32, j33]], dtype=float)\n\n    eigvals = np.linalg.eigvals(J)\n\n    # Classification: underdamped if any eigenvalue has significant imaginary part and negative real part\n    # overdamped if all eigenvalues are real and have negative real parts\n    imag_thresh = 1e-10\n    real_parts = np.real(eigvals)\n    imag_parts = np.imag(eigvals)\n\n    # Stability check (should be stable in provided cases)\n    if np.any(real_parts > 0.0):\n        # If unstable, we still provide a classification;\n        # treat as underdamped if oscillatory, otherwise overdamped (monotonic divergence).\n        if np.any(np.abs(imag_parts) > imag_thresh):\n            return 1\n        else:\n            return 0\n\n    # Oscillatory decay?\n    if np.any(np.abs(imag_parts) > imag_thresh):\n        return 1  # underdamped\n    else:\n        return 0  # overdamped\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: nominal, expected overdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.002,\n            \"alpha_T\": -5.0e-5,\n            \"C_p\": 1.0e6,\n            \"h\": 2.0e5,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n        # Case 2: weak feedback, slow thermal node, expected underdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.002,\n            \"alpha_T\": -1.0e-5,\n            \"C_p\": 5.0e6,\n            \"h\": 2.0e4,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n        # Case 3: larger step, strong feedback, expected overdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.004,\n            \"alpha_T\": -1.0e-4,\n            \"C_p\": 1.0e6,\n            \"h\": 5.0e4,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}