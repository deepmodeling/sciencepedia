{
    "hands_on_practices": [
        {
            "introduction": "丹科夫因子是量化共振自屏效应的关键概念，它解释了中子在燃料区之间的流出效应。本基础练习将指导您从第一性原理出发，将随机介质中的弦长统计分布与中子衰减的基本定律相结合，从而推导出微观丹科夫因子。掌握这一推导过程，将为您理解燃料微观结构如何影响中子行为奠定坚实的物理基础。",
            "id": "4254734",
            "problem": "考虑用于高温气冷堆中的双重非均质燃料压块的微观尺度，其中微观燃料颗粒（例如球形核心）嵌入在石墨慢化剂基体中。仅关注微观非均质性：燃料和慢化剂的二元混合物被假设为统计上均匀且各向同性，其单位体积界面比表面积为 $S$，慢化剂体积份额为 $\\phi_{m}$。在稀疏的马尔可夫两相极限下，慢化剂相内的弦长分布被认为是指数形式的，其平均弦长 $\\bar{\\ell}_{m}$ 由 Miles 关系式 $\\bar{\\ell}_{m} = 4 \\phi_{m}/S$ 给出。在慢化能区内的某一固定中子能量下，将慢化剂建模为纯吸收介质，其宏观吸收截面为 $\\Sigma_{m}$，并忽略中子单次穿过慢化剂过程中的散射和能量变化。\n\n一个从燃料颗粒表面进入慢化剂的中子，在重新进入燃料相之前，会沿着长度为 $s$ 的随机慢化剂弦运动。根据在慢化剂中行进距离 $s$ 而不发生碰撞的指数衰减定律 $I(s) = I_{0}\\exp(-\\Sigma_{m} s)$，将微观丹科夫因子 $C_{\\mu}$ 定义为这样一个中子在慢化剂中不发生任何相互作用而到达下一个燃料区的概率。从给定的假设和基本的输运衰减原理出发，建立一个将慢化剂弦长概率密度与指数存活概率进行卷积的积分表达式，并将其计算为一个闭式解析表达式。用 $\\Sigma_{m}$、$S$ 和 $\\phi_{m}$ 表示你的最终答案。最终答案必须是一个单一的闭式表达式。不需要进行数值近似。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、提法恰当且客观。它描述了核反应堆物理中的一个标准问题，具体而言，是使用输运理论和统计几何的成熟模型与原理，计算双重非均质介质中的丹科夫因子。所有必要的信息和定义都已提供，足以推导出一个唯一且有意义的解。\n\n问题要求计算微观丹科夫因子 $C_{\\mu}$，它被定义为一个从中子燃料颗粒出来、穿过慢化剂并在不发生任何相互作用的情况下到达另一个燃料区的概率。这是一个平均概率，其平均过程是针对慢化剂中所有可能的路径长度（弦长）进行的。\n\n设 $s$ 为慢化剂中一根随机弦的长度。问题指出，一个中子穿过此距离 $s$ 而不发生相互作用的概率遵循指数衰减定律。这个存活概率 $P_{\\text{surv}}(s)$ 由下式给出：\n$$ P_{\\text{surv}}(s) = \\exp(-\\Sigma_{m} s) $$\n其中 $\\Sigma_{m}$ 是慢化剂的宏观吸收截面。\n\n问题还指出，慢化剂相内的弦长 $s$ 的分布遵循指数概率分布。对于平均值为 $\\bar{\\lambda}$ 的指数分布，其概率密度函数 (PDF) 为 $p(x) = \\frac{1}{\\bar{\\lambda}} \\exp(-x/\\bar{\\lambda})$。在我们的情况下，随机变量是弦长 $s$，其平均值被给定为 $\\bar{\\ell}_{m}$。因此，弦长 $s$ 的 PDF，记为 $p(s)$，是：\n$$ p(s) = \\frac{1}{\\bar{\\ell}_{m}} \\exp\\left(-\\frac{s}{\\bar{\\ell}_{m}}\\right) $$\n对于 $s \\ge 0$。一根弦的长度在 $s$ 和 $s+ds$ 之间的概率是 $p(s)ds$。\n\n微观丹科夫因子 $C_{\\mu}$ 是总存活概率，通过将特定弦长的存活概率 $P_{\\text{surv}}(s)$ 与该弦长出现的概率 $p(s)ds$ 相乘，然后对所有从 $0$ 到 $\\infty$ 的非负弦长进行积分得到。这构成了题目所要求的两个分布的卷积。因此，$C_{\\mu}$ 的积分表达式为：\n$$ C_{\\mu} = \\int_{0}^{\\infty} P_{\\text{surv}}(s) \\, p(s) \\, ds $$\n\n代入 $P_{\\text{surv}}(s)$ 和 $p(s)$ 的表达式：\n$$ C_{\\mu} = \\int_{0}^{\\infty} \\left[ \\exp(-\\Sigma_{m} s) \\right] \\left[ \\frac{1}{\\bar{\\ell}_{m}} \\exp\\left(-\\frac{s}{\\bar{\\ell}_{m}}\\right) \\right] ds $$\n\n我们可以合并指数项，并将常数 $\\frac{1}{\\bar{\\ell}_{m}}$ 从积分中提出来：\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}} \\int_{0}^{\\infty} \\exp\\left(-\\Sigma_{m} s - \\frac{s}{\\bar{\\ell}_{m}}\\right) ds $$\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}} \\int_{0}^{\\infty} \\exp\\left(-s \\left(\\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}\\right)\\right) ds $$\n\n这是一个标准的指数函数定积分。设指数中的常数为 $k = \\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}$。积分变为：\n$$ \\int_{0}^{\\infty} \\exp(-ks) \\, ds = \\left[ -\\frac{1}{k} \\exp(-ks) \\right]_{0}^{\\infty} $$\n计算极限：\n$$ \\left( \\lim_{s \\to \\infty} -\\frac{1}{k} \\exp(-ks) \\right) - \\left( -\\frac{1}{k} \\exp(-k \\cdot 0) \\right) $$\n由于 $k = \\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}$ 是正的（物理截面和长度是非负的，且对于吸收介质 $\\Sigma_m>0$），当 $s \\to \\infty$ 时，$\\exp(-ks)$ 的极限为 $0$。该表达式简化为：\n$$ (0) - \\left( -\\frac{1}{k} \\exp(0) \\right) = \\frac{1}{k} $$\n\n将此结果代回 $C_{\\mu}$ 的表达式中：\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}} \\cdot \\frac{1}{k} = \\frac{1}{\\bar{\\ell}_{m}} \\cdot \\frac{1}{\\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}} $$\n\n为了简化，我们将分子和分母同乘以 $\\bar{\\ell}_{m}$：\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}\\left(\\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}\\right)} = \\frac{1}{\\bar{\\ell}_{m}\\Sigma_{m} + 1} $$\n这个表达式被称为用于计算从凸体中逃逸概率的 Wigner 有理近似，这里它被推广到了随机介质的情况。\n\n最后一步是用给定的参数 $\\Sigma_{m}$、$S$（界面比表面积）和 $\\phi_{m}$（慢化剂体积份额）来表示结果。问题提供了慢化剂中平均弦长的 Miles 关系式：\n$$ \\bar{\\ell}_{m} = \\frac{4 \\phi_{m}}{S} $$\n\n将 $\\bar{\\ell}_{m}$ 的这个表达式代入我们得到的 $C_{\\mu}$ 结果中：\n$$ C_{\\mu} = \\frac{1}{\\left(\\frac{4 \\phi_{m}}{S}\\right)\\Sigma_{m} + 1} $$\n\n通过对分母进行通分，可以将其改写成一个更紧凑的形式：\n$$ C_{\\mu} = \\frac{1}{\\frac{4 \\phi_{m} \\Sigma_{m} + S}{S}} $$\n$$ C_{\\mu} = \\frac{S}{S + 4 \\phi_{m} \\Sigma_{m}} $$\n\n这就是在给定假设下，微观丹科夫因子 $C_{\\mu}$ 的最终闭式解析表达式。",
            "answer": "$$\\boxed{\\frac{S}{S + 4 \\phi_{m} \\Sigma_{m}}}$$"
        },
        {
            "introduction": "在双非均质系统中，微观尺度（燃料颗粒）和宏观尺度（燃料块）的结构都会影响反应堆的性能，但它们各自的相对重要性随设计而异。本计算实践提供了一个工具，通过在双能群无限介质计算中开关微观和宏观屏效应修正项，来解构这些影响。通过观察由此导致的增殖因子 $k_\\infty$ 和反应率的变化，您将为在不同物理情境下确定模型优化的优先级建立起定量的直觉。",
            "id": "4254731",
            "problem": "考虑一个双重非均质燃料-慢化剂系统的均匀化表示下的无限介质、双能群中子平衡。双重非均质性源于嵌入燃料芯块的微观燃料颗粒（微观尺度）和慢化剂基体中燃料块的空间排列（宏观尺度）。目标是分离并量化微观逃逸与宏观丹科夫耦合对反应率和无限介质增殖因子的贡献。您需要实现一个程序，依次切换每个修正项，并测量反应率和无限介质增殖因子的变化，以确定建模工作的优先级。\n\n基本原理：\n- 无限介质中的中子平衡可以用多群形式表示为一个广义特征值问题。设 $\\phi_1$ 为快中子群通量，$\\phi_2$ 为热/共振中子群通量。定义移出算子矩阵 $A$ 和裂变产生算子矩阵 $F$ 如下：\n$$\nA = \\begin{bmatrix}\n\\Sigma_{r,1}  0 \\\\\n-\\Sigma_{s,1\\to 2}  \\Sigma_{a,2}^{\\text{eff}}\n\\end{bmatrix}, \\quad\nF = \\begin{bmatrix}\n\\chi_1 \\nu \\Sigma_{f,1}  \\chi_1 \\nu \\Sigma_{f,2} \\\\\n\\chi_2 \\nu \\Sigma_{f,1}  \\chi_2 \\nu \\Sigma_{f,2}\n\\end{bmatrix},\n$$\n其中 $\\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1\\to 2}$，$\\Sigma_{a,2}^{\\text{eff}}$ 是群2的有效吸收截面，$\\nu$ 是每次裂变产生的平均中子数，$\\chi_1$ 和 $\\chi_2$ 分别是裂变谱在群1和群2的份额。无限介质增殖因子 $k_\\infty$ 是 $A^{-1} F$ 的主特征值：\n$$\nA^{-1} F \\, \\Phi = k_\\infty \\, \\Phi, \\quad \\Phi = \\begin{bmatrix}\\phi_1 \\\\ \\phi_2\\end{bmatrix}.\n$$\n- 群2的吸收反应率是 $R_{a,2} = \\Sigma_{a,2}^{\\text{eff}} \\, \\phi_2$，通量归一化选择为 $\\phi_1 + \\phi_2 = 1$。\n\n微观逃逸和宏观丹科夫建模假设：\n- 微观逃逸捕捉了由于微观燃料颗粒有限光学厚度导致的有效共振吸收的减少。对于半径为 $r_g$ 的球形颗粒，设光学厚度为 $\\tau_g = \\Sigma_{t,\\text{fuel}} \\, r_g$，其中 $\\Sigma_{t,\\text{fuel}}$ 是群2中燃料的总截面。使用一个线性化的自屏效应修正因子：\n$$\n\\Sigma_{a,2}^{\\text{eff}} = \\frac{\\Sigma_{a,2}^{\\text{base}}}{1 + \\alpha_0 \\, \\tau_g \\, T_{\\text{micro}} + \\beta_0 \\, \\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right) \\, (1 - C) \\, T_{\\text{macro}}},\n$$\n其中 $\\Sigma_{a,2}^{\\text{base}}$ 是群2的基准吸收截面，$\\alpha_0$ 和 $\\beta_0$ 是微观逃逸和宏观耦合的无量纲修正系数，$\\Sigma_{t,\\text{mod}}$ 是群2中慢化剂的总截面，$s$ 是特征燃料块间距，$C \\in [0,1]$ 是宏观丹科夫因子，$T_{\\text{micro}}, T_{\\text{macro}} \\in \\{0,1\\}$ 是启用相应修正的开关。因子 $\\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right)$ 是慢化剂平均自由程相对于燃料块间距的无量纲度量。项 $(1 - C)$ 在燃料块相互遮蔽时减少宏观背景，这与等效理论的解释一致，即更高的 $C$ 会减少共振所看到的慢化剂背景。\n- 这个简化模型在科学上是合理的，可以用于分离趋势：增加 $r_g$ 会增加 $\\tau_g$，从而增加微观逃逸修正的幅度；增加 $C$ 会减小 $(1 - C)$，从而减小宏观修正的幅度；减小 $s$ 会通过增加慢化剂耦合因子来增加宏观修正的幅度。\n\n数值数据：\n- 对所有测试案例使用固定的材料和能谱参数：\n  - $\\nu = 2.43$。\n  - $\\chi_1 = 0.95$, $\\chi_2 = 0.05$。\n  - $\\Sigma_{f,1} = 0.001$ $\\text{cm}^{-1}$，$\\Sigma_{f,2} = 0.06$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{a,1} = 0.005$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{s,1\\to 2} = 0.08$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{a,2}^{\\text{base}} = 0.12$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{t,\\text{fuel}} = 0.6$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{t,\\text{mod}} = 0.2$ $\\text{cm}^{-1}$。\n  - $\\alpha_0 = 0.8$, $\\beta_0 = 0.2$。\n- 为每个测试案例定义切换场景：\n  - 无修正：$T_{\\text{micro}} = 0$, $T_{\\text{macro}} = 0$。\n  - 仅微观修正：$T_{\\text{micro}} = 1$, $T_{\\text{macro}} = 0$。\n  - 仅宏观修正：$T_{\\text{micro}} = 0$, $T_{\\text{macro}} = 1$。\n  - 双重修正：$T_{\\text{micro}} = 1$, $T_{\\text{macro}} = 1$。\n\n测试套件：\n- 每个测试案例指定 $(r_g, C, s)$，其中 $r_g$ 和 $s$ 的单位为厘米。\n  1. 正常路径：$r_g = 0.05$ $\\text{cm}$，$C = 0.5$，$s = 1.0$ $\\text{cm}$。\n  2. 微观效应可忽略：$r_g = 0.001$ $\\text{cm}$，$C = 0.4$，$s = 2.0$ $\\text{cm}$。\n  3. 宏观效应主导：$r_g = 0.05$ $\\text{cm}$，$C = 0.0$，$s = 0.5$ $\\text{cm}$。\n  4. 宏观效应可忽略，微观效应主导：$r_g = 0.2$ $\\text{cm}$，$C = 0.95$，$s = 5.0$ $\\text{cm}$。\n\n您的任务：\n- 对于每个测试案例，计算四种切换场景下的 $k_\\infty$ 和群2吸收反应率 $R_{a,2}$：无修正、仅微观修正、仅宏观修正、双重修正。\n- 在计算 $R_{a,2}$ 之前，将通量矢量 $\\Phi$ 归一化，使得 $\\phi_1 + \\phi_2 = 1$。\n- 每个测试案例产生以下输出：\n  - 四个 $k_\\infty$ 值，顺序为 [无修正, 仅微观修正, 仅宏观修正, 双重修正]。\n  - 群2吸收反应率相对于“无修正”场景的变化量：$\\Delta R_{a,2}^{\\text{micro}} = R_{a,2}^{\\text{micro}} - R_{a,2}^{\\text{none}}$ 和 $\\Delta R_{a,2}^{\\text{macro}} = R_{a,2}^{\\text{macro}} - R_{a,2}^{\\text{none}}$。反应率是以通量归一化单位表示的，由截面乘以归一化通量构成，因此不带物理单位。\n  - 两个整数标志，基于变化幅度指示建模优先级：\n    - $P_k = 0$ 如果 $\\left|k_\\infty^{\\text{macro}} - k_\\infty^{\\text{none}}\\right| > \\left|k_\\infty^{\\text{micro}} - k_\\infty^{\\text{none}}\\right|$，否则 $P_k = 1$。\n    - $P_R = 0$ 如果 $\\left|\\Delta R_{a,2}^{\\text{macro}}\\right| > \\left|\\Delta R_{a,2}^{\\text{micro}}\\right|$，否则 $P_R = 1$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个每个测试案例结果的列表，每个测试案例结果是一个子列表，格式如下：\n$$\n[\\;k_\\infty^{\\text{none}},\\;k_\\infty^{\\text{micro}},\\;k_\\infty^{\\text{macro}},\\;k_\\infty^{\\text{both}},\\;\\Delta R_{a,2}^{\\text{micro}},\\;\\Delta R_{a,2}^{\\text{macro}},\\;P_k,\\;P_R\\;].\n$$\n- 整个输出应精确打印为由方括号括起来的这些子列表的逗号分隔列表，例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n实现约束：\n- 最终答案必须是一个完整、可运行的程序。\n- 语言：Python，版本 $3.12$。\n- 库：NumPy (版本 $1.23.5$) 和 SciPy (版本 $1.11.4$) 可用，但此任务仅使用 Python 标准库和 NumPy。\n- 不允许用户输入或外部文件。",
            "solution": "## 问题验证\n\n### 第1步：提取已知条件\n\n**控制方程：**\n- 双能群中子平衡由广义特征值问题 $A^{-1} F \\, \\Phi = k_\\infty \\, \\Phi$ 表示，其中 $\\Phi = \\begin{bmatrix}\\phi_1 \\\\ \\phi_2\\end{bmatrix}$。\n- 移出算子矩阵 $A$ 为：\n$$\nA = \\begin{bmatrix}\n\\Sigma_{r,1}  0 \\\\\n-\\Sigma_{s,1\\to 2}  \\Sigma_{a,2}^{\\text{eff}}\n\\end{bmatrix}\n$$\n- 裂变产生算子矩阵 $F$ 为：\n$$\nF = \\begin{bmatrix}\n\\chi_1 \\nu \\Sigma_{f,1}  \\chi_1 \\nu \\Sigma_{f,2} \\\\\n\\chi_2 \\nu \\Sigma_{f,1}  \\chi_2 \\nu \\Sigma_{f,2}\n\\end{bmatrix}\n$$\n- 群1的移出截面为 $\\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1\\to 2}$。\n- 群2的吸收反应率为 $R_{a,2} = \\Sigma_{a,2}^{\\text{eff}} \\, \\phi_2$。\n- 通量归一化为 $\\phi_1 + \\phi_2 = 1$。\n\n**$\\Sigma_{a,2}^{\\text{eff}}$ 的自屏模型：**\n- 群2的有效吸收截面由下式给出：\n$$\n\\Sigma_{a,2}^{\\text{eff}} = \\frac{\\Sigma_{a,2}^{\\text{base}}}{1 + \\alpha_0 \\, \\tau_g \\, T_{\\text{micro}} + \\beta_0 \\, \\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right) \\, (1 - C) \\, T_{\\text{macro}}}\n$$\n- 燃料颗粒的光学厚度为 $\\tau_g = \\Sigma_{t,\\text{fuel}} \\, r_g$。\n- 修正的开关为 $T_{\\text{micro}}, T_{\\text{macro}} \\in \\{0,1\\}$。\n\n**数值数据：**\n- $\\nu = 2.43$\n- $\\chi_1 = 0.95$, $\\chi_2 = 0.05$\n- $\\Sigma_{f,1} = 0.001$ $\\text{cm}^{-1}$\n- $\\Sigma_{f,2} = 0.06$ $\\text{cm}^{-1}$\n- $\\Sigma_{a,1} = 0.005$ $\\text{cm}^{-1}$\n- $\\Sigma_{s,1\\to 2} = 0.08$ $\\text{cm}^{-1}$\n- $\\Sigma_{a,2}^{\\text{base}} = 0.12$ $\\text{cm}^{-1}$\n- $\\Sigma_{t,\\text{fuel}} = 0.6$ $\\text{cm}^{-1}$\n- $\\Sigma_{t,\\text{mod}} = 0.2$ $\\text{cm}^{-1}$\n- $\\alpha_0 = 0.8$\n- $\\beta_0 = 0.2$\n\n**切换场景：**\n- 无修正：$T_{\\text{micro}} = 0$, $T_{\\text{macro}} = 0$\n- 仅微观修正：$T_{\\text{micro}} = 1$, $T_{\\text{macro}} = 0$\n- 仅宏观修正：$T_{\\text{micro}} = 0$, $T_{\\text{macro}} = 1$\n- 双重修正：$T_{\\text{micro}} = 1$, $T_{\\text{macro}} = 1$\n\n**测试套件：**\n1.  $r_g = 0.05$ cm, $C = 0.5$, $s = 1.0$ cm.\n2.  $r_g = 0.001$ cm, $C = 0.4$, $s = 2.0$ cm.\n3.  $r_g = 0.05$ cm, $C = 0.0$, $s = 0.5$ cm.\n4.  $r_g = 0.2$ cm, $C = 0.95$, $s = 5.0$ cm.\n\n**每个测试案例所需的输出：**\n- 四个 $k_\\infty$ 值：$[k_\\infty^{\\text{none}}, k_\\infty^{\\text{micro}}, k_\\infty^{\\text{macro}}, k_\\infty^{\\text{both}}]$。\n- 两个反应率变化：$\\Delta R_{a,2}^{\\text{micro}} = R_{a,2}^{\\text{micro}} - R_{a,2}^{\\text{none}}$ 和 $\\Delta R_{a,2}^{\\text{macro}} = R_{a,2}^{\\text{macro}} - R_{a,2}^{\\text{none}}$。\n- 两个优先级标志：\n  - $P_k = 0$ 如果 $|k_\\infty^{\\text{macro}} - k_\\infty^{\\text{none}}| > |k_\\infty^{\\text{micro}} - k_\\infty^{\\text{none}}|$，否则 $P_k = 1$。\n  - $P_R = 0$ 如果 $|\\Delta R_{a,2}^{\\text{macro}}| > |\\Delta R_{a,2}^{\\text{micro}}|$，否则 $P_R = 1$。\n\n### 第2步：使用提取的已知条件进行验证\n\n根据验证标准评估问题。\n\n1.  **科学依据**：该问题在核反应堆物理学中有充分的依据。双群扩散模型是反应堆分析的一种标准（尽管简化）方法。将无限介质增殖因子 $k_\\infty$ 表述为 $A^{-1}F$ 的主特征值是正确的。有效截面 $\\Sigma_{a,2}^{\\text{eff}}$ 的模型是对共振自屏效应的一种唯象但合理的表示，与 Wigner 有理近似和等效理论等已建立的理论一致。对颗粒尺寸（$r_g$）、块间距（$s$）和丹科夫因子（$C$）的依赖性在物理上是合理的。所有数值参数都在核系统的实际范围内。该问题不违反任何科学原理。\n2.  **适定性**：该问题在数学上是适定的。它需要解决一个 $2 \\times 2$ 矩阵的特征值问题。构建矩阵所需的所有参数和常数都已提供。计算所有所需输出的程序有明确定义。通量归一化条件确保了反应率的唯一解。对于这样的物理系统，预计会有一个主导的、正的、实的特征值（$k_\\infty$），从而保证一个有意义的解。\n3.  **客观性**：该问题以完全客观和定量的方式陈述。没有主观断言、观点或模糊术语。所有任务都基于精确的数学定义。\n4.  **完整性和一致性**：该问题是自洽的。提供了所有必要的数据、方程和条件。所提供的信息中没有矛盾。单位自始至终是一致的（例如，截面单位为 $\\text{cm}^{-1}$，长度单位为 $\\text{cm}$）。\n5.  **非平凡性或伪深刻性**：该问题需要一系列涉及矩阵代数和特征值分析的非平凡计算。它正确地分离了反应堆建模中的一个关键概念权衡（微观与宏观非均质效应），并需要定量分析来解决它，因此具有实质性的深度。\n\n### 第3步：结论与行动\n\n该问题是有效的。它是一个在核反应堆模拟领域内适定的、有科学依据的、计算上具体的问题。将提供完整的解决方案。\n\n## 解答\n\n解决方案通过为每个测试案例和四种指定的切换场景实施物理模型来展开。问题的核心是计算无限介质增殖因子 $k_\\infty$ 和相应的中子通量分布 $\\Phi$，所有其他量都由此导出。\n\n**第1步：评估群2的有效吸收截面**\n\n对于由一组几何参数 $(r_g, C, s)$ 定义的每个测试案例，以及由参数对 $(T_{\\text{micro}}, T_{\\text{macro}})$ 定义的每个切换场景，第一步是计算群2的有效吸收截面 $\\Sigma_{a,2}^{\\text{eff}}$。\n\n公式为：\n$$\n\\Sigma_{a,2}^{\\text{eff}} = \\frac{\\Sigma_{a,2}^{\\text{base}}}{1 + \\alpha_0 \\, \\tau_g \\, T_{\\text{micro}} + \\beta_0 \\, \\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right) \\, (1 - C) \\, T_{\\text{macro}}}\n$$\n首先，根据颗粒半径 $r_g$ 确定颗粒光学厚度 $\\tau_g$：\n$$\n\\tau_g = \\Sigma_{t,\\text{fuel}} \\, r_g\n$$\n使用给定的常数（$\\Sigma_{a,2}^{\\text{base}} = 0.12$，$\\alpha_0 = 0.8$，$\\beta_0 = 0.2$，$\\Sigma_{t,\\text{fuel}}=0.6$，$\\Sigma_{t,\\text{mod}}=0.2$），对每种参数组合计算该表达式。\n\n**第2步：构建系统矩阵**\n\n在计算出 $\\Sigma_{a,2}^{\\text{eff}}$ 后，构建移出矩阵 $A$ 和裂变产生矩阵 $F$。矩阵 $F$ 在所有场景和测试案例中都是恒定的，而 $A$ 依赖于 $\\Sigma_{a,2}^{\\text{eff}}$。\n\n群1的移出截面是恒定的：\n$$\n\\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1\\to 2} = 0.005 + 0.08 = 0.085 \\, \\text{cm}^{-1}\n$$\n然后矩阵为：\n$$\nA = \\begin{bmatrix}\n0.085  0 \\\\\n-0.08  \\Sigma_{a,2}^{\\text{eff}}\n\\end{bmatrix}, \\quad\nF = \\begin{bmatrix}\n\\chi_1 \\nu \\Sigma_{f,1}  \\chi_1 \\nu \\Sigma_{f,2} \\\\\n\\chi_2 \\nu \\Sigma_{f,1}  \\chi_2 \\nu \\Sigma_{f,2}\n\\end{bmatrix}\n$$\n将数值代入 $F$：\n$$\nF = \\begin{bmatrix}\n0.95 \\cdot 2.43 \\cdot 0.001  0.95 \\cdot 2.43 \\cdot 0.06 \\\\\n0.05 \\cdot 2.43 \\cdot 0.001  0.05 \\cdot 2.43 \\cdot 0.06\n\\end{bmatrix} = \\begin{bmatrix}\n0.0023085  0.13851 \\\\\n0.0001215  0.00729\n\\end{bmatrix}\n$$\n\n**第3步：求解特征值问题**\n\n无限介质增殖因子 $k_\\infty$ 是迭代矩阵 $M = A^{-1}F$ 的主（最大）特征值。我们求解特征值问题：\n$$\nM \\Phi = \\lambda \\Phi\n$$\n其中 $k_\\infty = \\max(|\\lambda|)$。相应的特征向量 $\\Phi$ 代表相对通量分布 $[\\phi_1, \\phi_2]^T$。这是一个标准的数值过程，可以由像 NumPy 这样的库轻松处理。首先计算矩阵的逆 $A^{-1}$，然后进行矩阵乘积 $M = A^{-1}F$。\n\n**第4步：通量归一化**\n\n从特征值求解器获得的特征向量 $\\Phi_{raw}$ 是在一个乘法常数内定义的。它必须根据问题的约束 $\\phi_1 + \\phi_2 = 1$ 进行归一化。由于物理通量必须是非负的，特征向量的分量取正值。归一化执行如下：\n$$\n\\Phi = \\frac{\\Phi_{raw}}{|\\phi_{1,raw}| + |\\phi_{2,raw}|} = \\begin{bmatrix}\\phi_1 \\\\ \\phi_2\\end{bmatrix}\n$$\n\n**第5步：计算反应率**\n\n群2的吸收反应率 $R_{a,2}$ 是使用归一化热中子通量 $\\phi_2$ 和先前为当前场景确定的有效截面 $\\Sigma_{a,2}^{\\text{eff}}$ 计算的：\n$$\nR_{a,2} = \\Sigma_{a,2}^{\\text{eff}} \\, \\phi_2\n$$\n\n**第6步：计算最终输出量**\n\n在单个测试案例中为所有四种场景（无修正、仅微观修正、仅宏观修正、双重修正）计算完 $k_\\infty$ 和 $R_{a,2}$ 后，组装最终输出量。\n\n- 收集四个 $k_\\infty$ 值：$k_\\infty^{\\text{none}}, k_\\infty^{\\text{micro}}, k_\\infty^{\\text{macro}}, k_\\infty^{\\text{both}}$。\n- 计算相对于“无修正”情况的反应率变化：\n  $$\n  \\Delta R_{a,2}^{\\text{micro}} = R_{a,2}^{\\text{micro}} - R_{a,2}^{\\text{none}}\n  $$\n  $$\n  \\Delta R_{a,2}^{\\text{macro}} = R_{a,2}^{\\text{macro}} - R_{a,2}^{\\text{none}}\n  $$\n- 优先级标志 $P_k$ 和 $P_R$ 是根据微观和宏观修正引起的变化幅度来确定的：\n  - $P_k = 0$ 如果 $|k_\\infty^{\\text{macro}} - k_\\infty^{\\text{none}}| > |k_\\infty^{\\text{micro}} - k_\\infty^{\\text{none}}|$，否则 $P_k = 1$。\n  - $P_R = 0$ 如果 $|\\Delta R_{a,2}^{\\text{macro}}| > |\\Delta R_{a,2}^{\\text{micro}}|$，否则 $P_R = 1$。值为 $0$ 表示宏观主导，而值为 $1$ 表示微观主导或相等。\n\n对问题陈述中提供的四个测试案例中的每一个重复此过程，并将结果汇总到最终的列表格式中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the double heterogeneity problem for the given test cases.\n    \"\"\"\n\n    # Define fixed material and spectrum parameters.\n    nu = 2.43\n    chi1, chi2 = 0.95, 0.05\n    Sigma_f1, Sigma_f2 = 0.001, 0.06\n    Sigma_a1 = 0.005\n    Sigma_s12 = 0.08\n    Sigma_a2_base = 0.12\n    Sigma_t_fuel = 0.6\n    Sigma_t_mod = 0.2\n    alpha0 = 0.8\n    beta0 = 0.2\n\n    # Construct the constant fission production matrix F.\n    F = np.array([\n        [chi1 * nu * Sigma_f1, chi1 * nu * Sigma_f2],\n        [chi2 * nu * Sigma_f1, chi2 * nu * Sigma_f2]\n    ])\n\n    # Define the test cases.\n    test_cases = [\n        (0.05, 0.5, 1.0),   # 1. Normal path\n        (0.001, 0.4, 2.0),  # 2. Micro negligible\n        (0.05, 0.0, 0.5),   # 3. Macro dominant\n        (0.2, 0.95, 5.0)    # 4. Macro negligible, micro dominant\n    ]\n    \n    # Define toggling scenarios: (T_micro, T_macro)\n    scenarios = {\n        \"none\": (0, 0),\n        \"micro\": (1, 0),\n        \"macro\": (0, 1),\n        \"both\": (1, 1)\n    }\n\n    all_results = []\n\n    def calculate_physics(case_params, toggles):\n        \"\"\"\n        Calculates k_inf and R_a2 for a given case and scenario.\n        \"\"\"\n        r_g, C, s = case_params\n        T_micro, T_macro = toggles\n\n        # Step 1: Calculate effective group 2 absorption cross section.\n        tau_g = Sigma_t_fuel * r_g\n        micro_term = alpha0 * tau_g * T_micro\n        macro_term = beta0 * (1 / (Sigma_t_mod * s)) * (1 - C) * T_macro\n        Sigma_a2_eff = Sigma_a2_base / (1 + micro_term + macro_term)\n\n        # Step 2: Construct the removal matrix A.\n        Sigma_r1 = Sigma_a1 + Sigma_s12\n        A = np.array([\n            [Sigma_r1, 0],\n            [-Sigma_s12, Sigma_a2_eff]\n        ])\n\n        # Step 3: Solve the eigenvalue problem.\n        if np.linalg.det(A) == 0:\n            return np.nan, np.nan\n        \n        M = np.linalg.inv(A) @ F\n        eigenvalues, eigenvectors = np.linalg.eig(M)\n\n        dominant_idx = np.argmax(eigenvalues.real)\n        k_inf = eigenvalues[dominant_idx].real\n        flux_vector = eigenvectors[:, dominant_idx].real\n\n        # Step 4: Normalize the flux vector.\n        # Per Perron-Frobenius, the dominant eigenvector can be made all-positive.\n        if np.sum(flux_vector)  0:\n            flux_vector *= -1.0\n        \n        # Normalize to sum to 1 as required by the problem statement.\n        flux_sum = np.sum(flux_vector)\n        if flux_sum > 1e-12: # Avoid division by zero\n            normalized_flux = flux_vector / flux_sum\n        else:\n            normalized_flux = np.zeros_like(flux_vector)\n        \n        phi1, phi2 = normalized_flux\n\n        # Step 5: Calculate the reaction rate.\n        R_a2 = Sigma_a2_eff * phi2\n\n        return k_inf, R_a2\n\n    for case in test_cases:\n        results = {}\n        # Calculate k_inf and R_a2 for each of the four scenarios.\n        for name, toggles in scenarios.items():\n            k_inf, R_a2 = calculate_physics(case, toggles)\n            results[name] = {\"k_inf\": k_inf, \"R_a2\": R_a2}\n        \n        # Step 6: Compute final output quantities.\n        k_none = results[\"none\"][\"k_inf\"]\n        k_micro = results[\"micro\"][\"k_inf\"]\n        k_macro = results[\"macro\"][\"k_inf\"]\n        k_both = results[\"both\"][\"k_inf\"]\n\n        R_none = results[\"none\"][\"R_a2\"]\n        R_micro = results[\"micro\"][\"R_a2\"]\n        R_macro = results[\"macro\"][\"R_a2\"]\n\n        delta_R_micro = R_micro - R_none\n        delta_R_macro = R_macro - R_none\n        \n        # Determine priority flags.\n        # Pk = 0 if macro > micro, else 1\n        # PR = 0 if macro > micro, else 1\n        delta_k_micro_abs = abs(k_micro - k_none)\n        delta_k_macro_abs = abs(k_macro - k_none)\n        P_k = 0 if delta_k_macro_abs > delta_k_micro_abs else 1\n\n        delta_R_micro_abs = abs(delta_R_micro)\n        delta_R_macro_abs = abs(delta_R_macro)\n        P_R = 0 if delta_R_macro_abs > delta_R_micro_abs else 1\n        \n        # Assemble the results for the current test case.\n        case_results = [\n            k_none, k_micro, k_macro, k_both,\n            delta_R_micro, delta_R_macro,\n            P_k, P_R\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "实用的反应堆分析需要将详细的细群能量表示简化为计算上易于处理的粗群模型。这个称为能谱并群的过程必须谨慎执行，以保留其底层的物理原理。这个动手编程练习将挑战您实现并验证一个能谱并群方案，以确保反应率在并群前后保持守恒，这是任何多群模拟保真度的基本要求。",
            "id": "4254705",
            "problem": "考虑一个代表核反应堆模拟中双重非均质燃料系统的微元，其中燃料颗粒嵌入在基体材料中。该微元被划分为 $R$ 个不相交的区域，每个区域由 $r \\in \\{0,1,\\dots,R-1\\}$ 索引。中子能量域被离散化为 $G$ 个精细能群，由 $g \\in \\{0,1,\\dots,G-1\\}$ 索引，一个并群映射将这些精细群划分为 $H$ 个粗群，由 $H_i$ 索引，其中 $i \\in \\{0,1,\\dots,N_H-1\\}$，这些粗群由不相交的集合 $H_i \\subset \\{0,1,\\dots,G-1\\}$ 定义，它们构成了 $\\{0,1,\\dots,G-1\\}$ 的一个划分。每个区域 $r$ 都具有在精细群水平上的区域通量、截面和散射矩阵。任务是推导、实现并验证一个能谱并群方案，该方案使用来自微元输运的各区域通量来产生基体加权和集总加权的群常数，并定义确保反应率保真度的一致性检验。\n\n从多群框架中的基本中子平衡和反应率定义出发，认识到反应率是微观相互作用经中子通量加权后的积分。利用这些基础来推导在从精细能群到粗能群的映射过程中，并群必须如何保持反应率。设计一个基于原理的算法，该算法在给定各区域的精细群通量和截面的情况下，构造出：\n- 每个区域的基体加权粗群常数，在并群过程中保持每个区域内的反应率不变。\n- 微元级别的集总加权粗群常数，在所有区域合并后保持总反应率不变。\n\n您的程序必须实现所推导的方案，并验证吸收、通过每次裂变产生的有效中子数（通常表示为 $\\nu$ 乘以裂变截面）产生的中子以及从源粗群到目标粗群的粗群间散射的反应率一致性。一致性检验必须量化精细群反应率与使用并群后常数计算的相应粗群反应率之间的相对误差，并通过确保所有被检验反应的最大相对误差不超过预设容差来断言保真度。该容差是一个无量纲界限，应设置为 $10^{-10}$。\n\n物理和数值单位：\n- 截面必须以靶（barns）为单位处理。\n- 通量必须以 $\\text{cm}^{-2}\\text{s}^{-1}$ 为单位处理。\n- 体积必须以 $\\text{cm}^3$ 为单位处理。\n- 反应率必须以 $\\text{s}^{-1}$ 为单位处理。\n您的程序将在内部使用上述一致的单位；最终输出将是布尔值，因此无单位。\n\n您必须使用以下测试套件。在所有情况下，粗群划分为两个粗群，定义为 $H_0 = \\{0,1\\}$ 和 $H_1 = \\{2,3\\}$，精细群的数量为 $G=4$。\n\n测试用例 1 (理想情况，两个区域均有散射和裂变):\n- 区域数 $R=2$。\n- 体积:\n$$\\mathbf{V} = [0.3, 0.7] \\text{ cm}^3.$$\n- 各区域通量:\n$$\\boldsymbol{\\phi}^{(0)} = [2.0, 1.5, 0.8, 0.3] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(1)} = [1.0, 1.2, 1.4, 1.6] \\text{ cm}^{-2}\\text{s}^{-1}.$$\n- 吸收截面:\n$$\\boldsymbol{\\sigma}_a^{(0)} = [0.7, 0.4, 0.2, 0.1] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(1)} = [0.2, 0.15, 0.1, 0.05] \\text{ barns}.$$\n- 每次裂变有效中子数乘以裂变截面:\n$$\\boldsymbol{\\nu\\sigma}_f^{(0)} = [1.2, 0.8, 0.1, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(1)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}.$$\n- 散射矩阵 (从源细群 $g$ 到目标细群 $h$):\n$$\\mathbf{S}^{(0)} = \\begin{bmatrix}\n0.1  0.6  0.2  0.0\\\\\n0.0  0.05  0.3  0.1\\\\\n0.0  0.0  0.02  0.2\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(1)} = \\begin{bmatrix}\n0.05  0.1  0.0  0.0\\\\\n0.0  0.05  0.05  0.0\\\\\n0.0  0.0  0.02  0.02\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}.$$\n\n测试用例 2 (边界条件，第二个区域无散射):\n- 区域数 $R=2$。\n- 体积:\n$$\\mathbf{V} = [0.3, 0.7] \\text{ cm}^3.$$\n- 各区域通量:\n$$\\boldsymbol{\\phi}^{(0)} = [1.5, 1.1, 0.7, 0.2] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(1)} = [0.5, 0.6, 0.8, 1.0] \\text{ cm}^{-2}\\text{s}^{-1}.$$\n- 吸收截面:\n$$\\boldsymbol{\\sigma}_a^{(0)} = [0.7, 0.4, 0.2, 0.1] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(1)} = [0.4, 0.3, 0.2, 0.1] \\text{ barns}.$$\n- 每次裂变有效中子数乘以裂变截面:\n$$\\boldsymbol{\\nu\\sigma}_f^{(0)} = [1.1, 0.7, 0.0, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(1)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}.$$\n- 散射矩阵:\n$$\\mathbf{S}^{(0)} = \\begin{bmatrix}\n0.1  0.5  0.2  0.0\\\\\n0.0  0.05  0.25  0.1\\\\\n0.0  0.0  0.02  0.2\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(1)} = \\mathbf{0}_{4\\times4} \\text{ barns}.$$\n\n测试用例 3 (边缘情况，所有区域中一个粗群的通量为零):\n- 区域数 $R=3$。\n- 体积:\n$$\\mathbf{V} = [0.25, 0.5, 0.25] \\text{ cm}^3.$$\n- 各区域通量:\n$$\\boldsymbol{\\phi}^{(0)} = [0.0, 0.0, 0.5, 0.9] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(1)} = [0.0, 0.0, 1.0, 1.1] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(2)} = [0.0, 0.0, 0.4, 0.8] \\text{ cm}^{-2}\\text{s}^{-1}.$$\n- 吸收截面:\n$$\\boldsymbol{\\sigma}_a^{(0)} = [0.5, 0.35, 0.15, 0.07] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(1)} = [0.25, 0.2, 0.12, 0.06] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(2)} = [0.3, 0.25, 0.14, 0.07] \\text{ barns}.$$\n- 每次裂变有效中子数乘以裂变截面:\n$$\\boldsymbol{\\nu\\sigma}_f^{(0)} = [0.8, 0.3, 0.0, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(1)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(2)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}.$$\n- 散射矩阵:\n$$\\mathbf{S}^{(0)} = \\begin{bmatrix}\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.02  0.1\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(1)} = \\begin{bmatrix}\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.02  0.03\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(2)} = \\begin{bmatrix}\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.01  0.08\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}.$$\n\n您的程序必须：\n- 使用各区域通量推导并实现能谱并群方案，以构建用于吸收、每次裂变有效中子数乘以裂变截面以及群间散射的基体加权和集总加权粗群常数。\n- 计算微元级别的精细群反应率，包括吸收、每次裂变有效中子数乘以裂变截面以及从源粗群 $H_i$ 到目标粗群 $H_j$ (对于所有 $i \\neq j$)的粗群间散射。\n- 使用基体加权和集总加权方案下的并群常数计算相应的粗群反应率，并评估所有这些反应的最大相对误差。\n- 通过检查最大相对误差不超过 $10^{-10}$ 来验证保真度。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中每个测试用例对应一个布尔值，表示该用例的所有保真度检查是否都在容差范围内通过（例如，\"[True,False,True]\"）。",
            "solution": "当前任务是为双重非均质系统推导并实现一个能谱并群方案，这是核反应堆分析中的一个常见问题。该方案将从精细群数据生成粗群核截面，同时保持反应率不变。我们将为两种类型的并群常数建立公式：基体加权（按区域）和集总加权（按微元）。最后，我们将实现此方案并验证其保真度，通过确认使用粗群常数计算的反应率与基准精细群反应率在指定的数值容差内匹配。\n\n设系统由 $R$ 个不同区域定义，由 $r \\in \\{0, \\dots, R-1\\}$ 索引，每个区域的体积为 $V^{(r)}$。中子能谱被离散化为 $G$ 个精细群，由 $g \\in \\{0, \\dots, G-1\\}$ 索引。这些精细群被划分为 $N_H$ 个不相交的粗群 $H_i$，其中 $i \\in \\{0, \\dots, N_H-1\\}$。对于每个区域 $r$，我们给定大小为 $G$ 的精细群标量通量矢量 $\\boldsymbol{\\phi}^{(r)}$、精细群吸收截面矢量 $\\boldsymbol{\\sigma}_a^{(r)}$、精细群有效中子产生截面矢量 $\\boldsymbol{\\nu\\sigma}_f^{(r)}$，以及大小为 $G \\times G$ 的精细群到精细群的散射矩阵 $\\mathbf{S}^{(r)}$。\n\n能群并群的基本原则是保持反应率不变。在区域 $r$ 中，对于一组精细群 $G'$，类型为 $x$ (例如，吸收、裂变) 的反应的总反应率由下式给出：\n$$ \\mathcal{R}_{x}^{(r)}(G') = V^{(r)} \\sum_{g \\in G'} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n在区域 $r$ 中，从源群组 $G'_{\\text{src}}$ 到目标群组 $G'_{\\text{dst}}$ 的总散射率是：\n$$ \\mathcal{R}_{s}^{(r)}(G'_{\\text{src}} \\to G'_{\\text{dst}}) = V^{(r)} \\sum_{g \\in G'_{\\text{src}}} \\phi_g^{(r)} \\sum_{h \\in G'_{\\text{dst}}} S_{g \\to h}^{(r)} $$\n\n我们首先将粗群 $H_i$ 和区域 $r$ 中的粗群标量通量定义为组成它的精细群通量之和：\n$$ \\Phi_i^{(r)} = \\sum_{g \\in H_i} \\phi_g^{(r)} $$\n\n**1. 基体加权并群方案**\n\n基体加权方案为每个材料区域单独生成粗群常数，从而保持该区域内的反应率不变。“基体加权”一词指的是使用单一材料（例如，颗粒燃料元件中的基体）的数据进行并群。\n\n为了推导粗群标量截面 $\\Sigma_{x,i}^{(r)}$ (对于反应类型 $x=$ 吸收、裂变产生)，我们令区域 $r$ 和粗群 $H_i$ 内的精细群和粗群反应率相等。\n$$ \\text{精细群反应率:} \\quad \\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n$$ \\text{粗群反应率:} \\quad \\Sigma_{x,i}^{(r)} \\Phi_i^{(r)} = \\Sigma_{x,i}^{(r)} \\left(\\sum_{g \\in H_i} \\phi_g^{(r)}\\right) $$\n令两者相等，得到通量加权的粗群截面公式：\n$$ \\Sigma_{x,i}^{(r)} = \\frac{\\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)}}{\\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n在分母 $\\Phi_i^{(r)}$ 为零的情况下，分子（精细群反应率）也必然为零。粗群反应率 $\\Sigma_{x,i}^{(r)} \\Phi_i^{(r)}$ 也为零。根据约定，我们在此情况下定义 $\\Sigma_{x,i}^{(r)} = 0$。\n\n对于从群 $H_i$ 到群 $H_j$ 的粗群散射截面 $\\Sigma_{s, i \\to j}^{(r)}$，我们保持散射率不变：\n$$ \\text{精细群反应率:} \\quad \\sum_{g \\in H_i} \\phi_g^{(r)} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} $$\n$$ \\text{粗群反应率:} \\quad \\Sigma_{s, i \\to j}^{(r)} \\Phi_i^{(r)} = \\Sigma_{s, i \\to j}^{(r)} \\left(\\sum_{g \\in H_i} \\phi_g^{(r)}\\right) $$\n这给出了基体加权的粗群散射截面：\n$$ \\Sigma_{s, i \\to j}^{(r)} = \\frac{\\sum_{g \\in H_i} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} \\phi_g^{(r)}}{\\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n同样，如果分母为零，则该截面定义为零。\n\n**2. 集总加权并群方案**\n\n集总加权方案为整个微元生成一套唯一的粗群常数，保持所有区域（“集总体”）的总反应率不变。\n\n对于标量截面 $\\Sigma_{x,i}^{\\text{lump}}$，我们保持每个粗群 $H_i$ 在整个微元上的体积积分反应率不变：\n$$ \\text{精细群反应率:} \\quad \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n相应的粗群反应率使用均匀化截面 $\\Sigma_{x,i}^{\\text{lump}}$ 和该粗群的总通量-体积积分 $\\Psi_i = \\sum_{r=0}^{R-1} V^{(r)} \\Phi_i^{(r)}$。\n$$ \\text{粗群反应率:} \\quad \\Sigma_{x,i}^{\\text{lump}} \\Psi_i = \\Sigma_{x,i}^{\\text{lump}} \\left( \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\phi_g^{(r)} \\right) $$\n令两者相等，得到集总加权的粗群截面：\n$$ \\Sigma_{x,i}^{\\text{lump}} = \\frac{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)}}{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n\n类似地，对于集总加权散射截面 $\\Sigma_{s, i \\to j}^{\\text{lump}}$，我们保持从 $H_i$ 到 $H_j$ 的总散射率不变：\n$$ \\Sigma_{s, i \\to j}^{\\text{lump}} = \\frac{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} \\phi_g^{(r)}}{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n同样适用于分母为零的逻辑：如果某个源粗群的总通量-体积积分为零，则相应的集总加权截面定义为零。\n\n**3. 反应率保真度检验**\n\n并群方案的验证包括确认使用并群常数计算的总反应率与来自精细群数据的真实反应率相匹配。该检验针对吸收、裂变产生和粗群间散射的总微元反应率进行。\n\n令 $\\mathcal{R}_x^{\\text{fine}}$ 为整个微元上反应 $x$ 的总精细群反应率：\n$$ \\mathcal{R}_x^{\\text{fine}} = \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g=0}^{G-1} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n使用基体加权常数，粗群反应率为：\n$$ \\mathcal{R}_x^{\\text{coarse, matrix}} = \\sum_{r=0}^{R-1} V^{(r)} \\sum_{i=0}^{N_H-1} \\Sigma_{x,i}^{(r)} \\Phi_i^{(r)} $$\n使用集总加权常数，粗群反应率为：\n$$ \\mathcal{R}_x^{\\text{coarse, lump}} = \\sum_{i=0}^{N_H-1} \\Sigma_{x,i}^{\\text{lump}} \\left( \\sum_{r=0}^{R-1} V^{(r)} \\Phi_i^{(r)} \\right) $$\n根据构造，可以证明 $\\mathcal{R}_x^{\\text{fine}} = \\mathcal{R}_x^{\\text{coarse, matrix}} = \\mathcal{R}_x^{\\text{coarse, lump}}$。\n\n对于从 $H_i$ 到 $H_j$ ($i \\neq j$) 的群间散射率，速率为：\n$$ \\mathcal{R}_{s, i \\to j}^{\\text{fine}} = \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} \\phi_g^{(r)} $$\n$$ \\mathcal{R}_{s, i \\to j}^{\\text{coarse, matrix}} = \\sum_{r=0}^{R-1} V^{(r)} \\Sigma_{s, i \\to j}^{(r)} \\Phi_i^{(r)} $$\n$$ \\mathcal{R}_{s, i \\to j}^{\\text{coarse, lump}} = \\Sigma_{s, i \\to j}^{\\text{lump}} \\left( \\sum_{r=0}^{R-1} V^{(r)} \\Phi_i^{(r)} \\right) $$\n同样，根据定义，这些量是相等的。\n\n保真度检验涉及计算每种反应类型 $y$（吸收、裂变产生、散射 $H_i \\to H_j$）的相对误差：\n$$ \\epsilon_y = \\frac{|\\mathcal{R}_y^{\\text{fine}} - \\mathcal{R}_y^{\\text{coarse}}|}{|\\mathcal{R}_y^{\\text{fine}}|} $$\n如果 $\\mathcal{R}_y^{\\text{fine}} = 0$，则当且仅当 $\\mathcal{R}_y^{\\text{coarse}}$ 也为零时，误差取为 0。如果在所有检验的反应和两种并群方案中，最大相对误差不超过 $10^{-10}$ 的容差（考虑到浮点误差），则该测试用例通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the spectral condensation problem.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        {\n            \"V\": [0.3, 0.7],\n            \"phis\": [[2.0, 1.5, 0.8, 0.3], [1.0, 1.2, 1.4, 1.6]],\n            \"sigma_as\": [[0.7, 0.4, 0.2, 0.1], [0.2, 0.15, 0.1, 0.05]],\n            \"nu_sigma_fs\": [[1.2, 0.8, 0.1, 0.0], [0.0, 0.0, 0.0, 0.0]],\n            \"Ss\": [\n                [[0.1, 0.6, 0.2, 0.0], [0.0, 0.05, 0.3, 0.1], [0.0, 0.0, 0.02, 0.2], [0.0, 0.0, 0.0, 0.01]],\n                [[0.05, 0.1, 0.0, 0.0], [0.0, 0.05, 0.05, 0.0], [0.0, 0.0, 0.02, 0.02], [0.0, 0.0, 0.0, 0.01]]\n            ],\n            \"H_map\": [[0, 1], [2, 3]],\n            \"tolerance\": 1e-10,\n        },\n        # Test case 2\n        {\n            \"V\": [0.3, 0.7],\n            \"phis\": [[1.5, 1.1, 0.7, 0.2], [0.5, 0.6, 0.8, 1.0]],\n            \"sigma_as\": [[0.7, 0.4, 0.2, 0.1], [0.4, 0.3, 0.2, 0.1]],\n            \"nu_sigma_fs\": [[1.1, 0.7, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]],\n            \"Ss\": [\n                [[0.1, 0.5, 0.2, 0.0], [0.0, 0.05, 0.25, 0.1], [0.0, 0.0, 0.02, 0.2], [0.0, 0.0, 0.0, 0.01]],\n                np.zeros((4,4))\n            ],\n            \"H_map\": [[0, 1], [2, 3]],\n            \"tolerance\": 1e-10,\n        },\n        # Test case 3\n        {\n            \"V\": [0.25, 0.5, 0.25],\n            \"phis\": [[0.0, 0.0, 0.5, 0.9], [0.0, 0.0, 1.0, 1.1], [0.0, 0.0, 0.4, 0.8]],\n            \"sigma_as\": [[0.5, 0.35, 0.15, 0.07], [0.25, 0.2, 0.12, 0.06], [0.3, 0.25, 0.14, 0.07]],\n            \"nu_sigma_fs\": [[0.8, 0.3, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]],\n            \"Ss\": [\n                [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.02, 0.1], [0.0, 0.0, 0.0, 0.01]],\n                [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.02, 0.03], [0.0, 0.0, 0.0, 0.01]],\n                [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.01, 0.08], [0.0, 0.0, 0.0, 0.01]],\n           ],\n            \"H_map\": [[0, 1], [2, 3]],\n            \"tolerance\": 1e-10,\n        },\n    ]\n\n    results = [run_fidelity_check(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fidelity_check(params):\n    \"\"\"\n    Performs spectral condensation and fidelity checks for a single test case.\n    \"\"\"\n    # Unpack parameters and convert to numpy arrays for vectorization\n    V = np.array(params['V'])\n    phis = [np.array(p) for p in params['phis']]\n    sigma_as = [np.array(s) for s in params['sigma_as']]\n    nu_sigma_fs = [np.array(n) for n in params['nu_sigma_fs']]\n    Ss = [np.array(s) for s in params['Ss']]\n    H_map = params['H_map']\n    tolerance = params['tolerance']\n    \n    R = len(V)\n    N_H = len(H_map)\n    max_rel_error = 0.0\n\n    def calculate_relative_error(fine_val, coarse_val):\n        if np.isclose(fine_val, 0.0):\n            return 0.0 if np.isclose(coarse_val, 0.0, atol=1e-15, rtol=0) else np.inf\n        return np.abs(fine_val - coarse_val) / np.abs(fine_val)\n\n    # --- Pre-calculate coarse fluxes ---\n    # Per-region coarse fluxes: Phi_r has shape (R, N_H)\n    Phi_r = np.array([[np.sum(phis[r][h_indices]) for h_indices in H_map] for r in range(R)])\n            \n    # Total coarse flux-volume integral: Psi_i has shape (N_H,)\n    Psi_i = np.sum(V[:, np.newaxis] * Phi_r, axis=0)\n\n    # === Check Scalar Reactions (Absorption and Fission Production) ===\n    scalar_rx_data = {'absorption': sigma_as, 'nu_fission': nu_sigma_fs}\n    for rx_name, sigmas_fine in scalar_rx_data.items():\n        # --- Fine Rate ---\n        RR_fine = np.sum([V[r] * np.sum(sigmas_fine[r] * phis[r]) for r in range(R)])\n\n        # --- Coarse Rates ---\n        # --- Matrix-weighted ---\n        RR_coarse_matrix = 0.0\n        for r in range(R):\n            for i, h_indices in enumerate(H_map):\n                num = np.sum(sigmas_fine[r][h_indices] * phis[r][h_indices])\n                den = Phi_r[r, i]\n                Sigma_r_i = num / den if not np.isclose(den, 0.0) else 0.0\n                RR_coarse_matrix += V[r] * Sigma_r_i * Phi_r[r, i]\n        max_rel_error = max(max_rel_error, calculate_relative_error(RR_fine, RR_coarse_matrix))\n\n        # --- Lump-weighted ---\n        RR_coarse_lump = 0.0\n        for i, h_indices in enumerate(H_map):\n            num = np.sum([V[r] * np.sum(sigmas_fine[r][h_indices] * phis[r][h_indices]) for r in range(R)])\n            den = Psi_i[i]\n            Sigma_lump_i = num / den if not np.isclose(den, 0.0) else 0.0\n            RR_coarse_lump += Sigma_lump_i * Psi_i[i]\n        max_rel_error = max(max_rel_error, calculate_relative_error(RR_fine, RR_coarse_lump))\n    \n    # === Check Inter-Group Scattering Reactions ===\n    for i, h_i_indices in enumerate(H_map):\n        for j, h_j_indices in enumerate(H_map):\n            if i == j: \n                continue\n\n            # --- Fine Rate ---\n            RR_s_ij_fine = np.sum([\n                V[r] * np.sum(Ss[r][np.ix_(h_i_indices, h_j_indices)] * phis[r][h_i_indices, np.newaxis])\n                for r in range(R)\n            ])\n\n            # --- Coarse Rates ---\n            # --- Matrix-weighted ---\n            RR_s_ij_coarse_matrix = 0.0\n            for r in range(R):\n                num = np.sum(Ss[r][np.ix_(h_i_indices, h_j_indices)] * phis[r][h_i_indices, np.newaxis])\n                den = Phi_r[r, i]\n                Sigma_s_ij_r = num / den if not np.isclose(den, 0.0) else 0.0\n                RR_s_ij_coarse_matrix += V[r] * Sigma_s_ij_r * Phi_r[r, i]\n            max_rel_error = max(max_rel_error, calculate_relative_error(RR_s_ij_fine, RR_s_ij_coarse_matrix))\n\n            # --- Lump-weighted ---\n            num_lump = np.sum([\n                V[r] * np.sum(Ss[r][np.ix_(h_i_indices, h_j_indices)] * phis[r][h_i_indices, np.newaxis])\n                for r in range(R)\n            ])\n            den_lump = Psi_i[i]\n            Sigma_s_ij_lump = num_lump / den_lump if not np.isclose(den_lump, 0.0) else 0.0\n            RR_s_ij_coarse_lump = Sigma_s_ij_lump * Psi_i[i]\n            max_rel_error = max(max_rel_error, calculate_relative_error(RR_s_ij_fine, RR_s_ij_coarse_lump))\n    \n    return max_rel_error = tolerance\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}