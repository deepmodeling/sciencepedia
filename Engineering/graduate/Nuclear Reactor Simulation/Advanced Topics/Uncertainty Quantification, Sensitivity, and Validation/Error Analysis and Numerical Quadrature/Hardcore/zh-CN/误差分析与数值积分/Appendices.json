{
    "hands_on_practices": [
        {
            "introduction": "本练习提供了应用复合辛普森法则的实践经验，以计算反应堆栅元中的一个一维径向积分。其核心在于利用理论误差界限来反向求解满足特定精度要求所需的最小离散数。这项技能  对于设置可靠的数值模拟至关重要，它确保了计算结果的准确性，是数值积分的基本功。",
            "id": "4224058",
            "problem": "在压水反应堆 (PWR) 的栅格计算中，使用了一个一维径向栅元模型。所关注的量是一个无量纲的归一化反应率积分，定义为\n$$\nI \\;=\\; \\int_{0}^{R_{c}} f(r) \\,\\mathrm{d}r,\n$$\n其中 $f(r)$ 是归一化吸收率密度，由 $f(r) = \\big(2\\pi r\\,\\Sigma_{a}(r)\\,\\phi(r)\\big)/Q_{0}$ 给出。这里，$\\Sigma_{a}(r)$ 是宏观吸收截面，$\\phi(r)$ 是中子通量，$Q_{0}$ 是一个正常数归一化常数，其选取使得 $I$ 为无量纲。栅元半径为 $R_{c} = 0.60\\,\\mathrm{cm}$。通过对栅元中通量形状的扩散理论分析（其中 $\\Sigma_{a}(r)$ 平滑变化），确定了 $f$ 在 $[0,R_{c}]$ 上具有连续四阶导数，并满足一致界\n$$\n\\big|f^{(4)}(r)\\big| \\;\\le\\; M, \\quad \\text{for all } r\\in[0,R_{c}],\n$$\n其中 $M = 1.0\\times 10^{4}\\,\\mathrm{cm}^{-4}$。\n\n你将使用复合辛普森法则在 $[0,R_{c}]$ 上对 $I$ 进行近似，其中包含 $N$ 个等宽的板（子区间），且 $N$ 必须是一个偶数。确定最小的偶数 $N$，使得绝对求积误差满足 $\\big|E\\big| \\le 10^{-6}$。将你的最终答案表示为最小的偶数 $N$。由于答案必须是一个精确的整数，因此不需要舍入说明。",
            "solution": "问题要求确定最小的偶数 $N$，它代表板的数量，用于对积分 $I = \\int_{0}^{R_{c}} f(r) \\,\\mathrm{d}r$ 进行复合辛普森法则近似，使得绝对求积误差 $|E|$ 小于或等于 $10^{-6}$。\n\n用于以 $N$ 个等宽板（其中 $N$ 是偶数）近似积分 $\\int_{a}^{b} f(x) \\,\\mathrm{d}x$ 的复合辛普森法则的绝对误差 $|E|$ 由以下不等式界定：\n$$|E| \\le \\frac{(b-a)^{5}}{180 N^{4}} \\max_{x \\in [a,b]} |f^{(4)}(x)|$$\n该公式在此适用，因为问题陈述了 $f$ 在积分区间上具有连续四阶导数。\n\n对于给定的问题，积分区间为 $[a, b] = [0, R_{c}]$，其中 $R_{c} = 0.60\\,\\mathrm{cm}$。被积函数是 $f(r)$。问题给出了 $f(r)$ 四阶导数的一致界：\n$$|f^{(4)}(r)| \\le M, \\quad \\text{for all } r \\in [0, R_{c}]$$\n其中 $M = 1.0 \\times 10^{4}\\,\\mathrm{cm}^{-4}$。因此，$\\max_{r \\in [0, R_{c}]} |f^{(4)}(r)| \\le M$。\n\n将这些参数代入误差界公式，我们得到：\n$$|E| \\le \\frac{(R_{c} - 0)^{5}}{180 N^{4}} M = \\frac{R_{c}^{5} M}{180 N^{4}}$$\n\n我们需要找到最小的偶数 $N$，以确保绝对误差 $|E|$ 满足条件 $|E| \\le 10^{-6}$。为保证这一点，我们要求误差的上界小于或等于期望的容差 $10^{-6}$：\n$$\\frac{R_{c}^{5} M}{180 N^{4}} \\le 10^{-6}$$\n\n现在我们可以对 $N$ 解这个不等式。整理各项，我们得到：\n$$N^{4} \\ge \\frac{R_{c}^{5} M}{180 \\times 10^{-6}}$$\n对两边取四次方根，得出：\n$$N \\ge \\left(\\frac{R_{c}^{5} M}{180 \\times 10^{-6}}\\right)^{1/4}$$\n\n现在，我们将给定的数值 $R_{c} = 0.60$ 和 $M = 1.0 \\times 10^{4}$ 代入不等式。在本次计算中，我们将这些量视为无量纲的，因为单位已经确定是一致的。\n$$N \\ge \\left(\\frac{(0.60)^{5} (1.0 \\times 10^{4})}{180 \\times 10^{-6}}\\right)^{1/4}$$\n首先，我们计算 $(0.60)^{5}$ 项的值：\n$$(0.60)^{5} = 0.07776$$\n接下来，我们计算括号内的表达式：\n$$\\frac{0.07776 \\times 10^{4}}{180 \\times 10^{-6}} = \\frac{777.6}{1.8 \\times 10^{-4}} = 4.32 \\times 10^{6}$$\n于是，$N$ 的不等式变为：\n$$N \\ge (4.32 \\times 10^{6})^{1/4}$$\n计算右侧的数值：\n$$N \\ge 45.5905\\ldots$$\n问题要求 $N$ 必须是一个整数。满足此条件的最小整数值是 $N = 46$。此外，问题指明 $N$ 必须是一个偶数。由于 46 是一个偶数，它满足所有陈述的要求。\n\n因此，为达到指定的误差容差所要求的最小偶数板数 $N$ 是 $46$。",
            "answer": "$$\\boxed{46}$$"
        },
        {
            "introduction": "这个案例探讨了在计算反应堆元件吸收率时，数值积分精度不足可能导致的严重问题。通过使用一个低阶高斯积分法则来处理一个近似的、存在振荡的中子注量率，我们将看到结果如何变为非物理的负值。这项练习  旨在警示我们，不恰当的数值方法不仅会产生定量误差，更可能导致定性上完全错误的、违背物理直觉的结论，从而强调了为被积函数的行为选择合适求积法则的重要性。",
            "id": "4224064",
            "problem": "考虑一个在反应堆燃料棒栅元模型中的一维板状元件，其长度为 $L_{e} = 10\\,\\mathrm{cm}$，用于进行单群稳态吸收计算。体积吸收反应率密度是宏观吸收截面与标量中子通量的乘积。因此，精确的元件吸收反应率是线积分 $R = \\int_{x_{e}} \\sigma_{a}(x)\\,\\phi(x)\\,dx$，对于物理上可接受的 $\\sigma_{a}(x) \\ge 0$ 和 $\\phi(x) \\ge 0$，该值必须为非负。然而，在高阶节点离散化中，近似标量通量可能会表现出在所有点上不保正的振荡。本问题研究了降阶积分如何在一个元件上产生非物理的负反应率。\n\n考虑在元件上有一个恒定的宏观吸收截面 $\\sigma_{a}(x) \\equiv \\sigma_{a} = 0.5\\,\\mathrm{cm}^{-1}$，以及在参考坐标 $\\xi \\in [-1,1]$ 上给出的标量通量的多项式近似\n$$\n\\phi(\\xi) \\;=\\; \\phi_{0}\\,\\bigl[\\,1 + \\beta\\,(\\xi^{2} - c)\\,\\bigr],\n$$\n其中 $\\phi_{0} = 1.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})$，$\\beta = 4$，且 $c = 0.4$。物理坐标为 $x = x_{c} + \\tfrac{L_{e}}{2}\\,\\xi$，雅可比为 $dx = \\tfrac{L_{e}}{2}\\,d\\xi$。\n\n元件吸收反应率将使用参考区间上的单点高斯-勒让德求积法进行近似，该方法应用于经过标准仿射变换映射的被积函数 $\\sigma_{a}\\,\\phi(\\xi)$。计算此求积法对给定数据所产生的降阶积分元件吸收反应率 $R_{\\text{UI}}$。以 $\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})$ 为单位报告你的答案，并四舍五入到三位有效数字。\n\n在你的推理中，你的推导应基于：(i) 吸收反应率的定义，即 $\\sigma_{a}\\phi$ 在元件上的积分；(ii) 从参考元件到物理元件的仿射映射；以及 (iii) 在 $[-1,1]$ 上的单点高斯-勒让德求积的标准性质。你还应从数值积分的角度阐明，为什么即使 $\\sigma_{a} \\ge 0$ 处处成立，降阶积分仍可能产生负的 $R_{\\text{UI}}$。不要使用任何非基于这些基础推导出的捷径公式。\n\n将最终的 $R_{\\text{UI}}$ 以 $\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})$ 为单位表示，并四舍五入到三位有效数字。",
            "solution": "该问题被认为是有效的，因为它在科学上基于核反应堆物理和数值分析的原理，是良定的，提供了所有必要的数据，并以客观、正式的语言表述。我们可以开始求解。\n\n主要目标是使用单点高斯-勒让德求积法计算降阶积分元件吸收反应率 $R_{\\text{UI}}$。精确的反应率 $R$ 定义为反应率密度 $\\sigma_{a}(x)\\,\\phi(x)$ 在元件长度 $L_{e}$ 上的积分。\n\n(i) 精确元件吸收反应率的定义如下：\n$$\nR = \\int_{x_{e}} \\sigma_{a}(x)\\,\\phi(x)\\,dx\n$$\n该积分是在元件的物理域上进行的，其长度为 $L_e$。\n\n(ii) 为了应用定义在参考区间 $\\xi \\in [-1, 1]$ 上的标准高斯-勒让德求积，我们进行仿射坐标变换。问题给出了映射 $x = x_{c} + \\tfrac{L_{e}}{2}\\,\\xi$，其中 $x_c$ 是元件的中心。微元根据该映射的雅可比进行变换：$dx = \\tfrac{L_{e}}{2}\\,d\\xi$。在 $x_e$ 上的积分限对应于 $\\xi = -1$ 和 $\\xi = 1$。截面 $\\sigma_{a}$ 是常数。因此，$R$ 的积分可以重写为参考坐标 $\\xi$ 的形式：\n$$\nR = \\int_{-1}^{1} \\sigma_{a}\\,\\phi(\\xi)\\,\\left(\\frac{L_{e}}{2}\\right)\\,d\\xi\n$$\n让我们将参考区间上的被积函数定义为 $g(\\xi) = \\sigma_{a}\\,\\phi(\\xi)\\,\\frac{L_{e}}{2}$。\n\n(iii) 元件吸收反应率将使用单点高斯-勒让德求积法则进行近似。对于形式为 $I = \\int_{-1}^{1} f(\\xi)\\,d\\xi$ 的积分，单点法则由下式给出：\n$$\nI_{\\text{GL1}} \\approx w_{1} f(\\xi_{1})\n$$\n标准的单点高斯-勒让德求积点是 $\\xi_{1} = 0$，相应的权重是 $w_{1} = 2$。\n将此法则应用于我们对 $R$ 的积分，我们得到降阶积分近似 $R_{\\text{UI}}$：\n$$\nR_{\\text{UI}} = w_{1}\\,g(\\xi_{1}) = 2 \\cdot g(0)\n$$\n代入 $g(\\xi)$ 的表达式：\n$$\nR_{\\text{UI}} = 2 \\left[ \\sigma_{a}\\,\\phi(0)\\,\\frac{L_{e}}{2} \\right] = \\sigma_{a}\\,L_{e}\\,\\phi(0)\n$$\n现在，我们必须在求积点 $\\xi = 0$ 处计算近似标量通量 $\\phi(\\xi)$。给定的通量表达式为：\n$$\n\\phi(\\xi) = \\phi_{0}\\,\\bigl[\\,1 + \\beta\\,(\\xi^{2} - c)\\,\\bigr]\n$$\n在 $\\xi = 0$ 处，通量为：\n$$\n\\phi(0) = \\phi_{0}\\,\\bigl[\\,1 + \\beta\\,(0^{2} - c)\\,\\bigr] = \\phi_{0}\\,(1 - \\beta c)\n$$\n将此代入我们对 $R_{\\text{UI}}$ 的表达式，得到符号结果：\n$$\nR_{\\text{UI}} = \\sigma_{a}\\,L_{e}\\,\\phi_{0}\\,(1 - \\beta c)\n$$\n我们现在代入给定的数值：\n$\\sigma_{a} = 0.5\\,\\mathrm{cm}^{-1}$\n$L_{e} = 10\\,\\mathrm{cm}$\n$\\phi_{0} = 1.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})$\n$\\beta = 4$\n$c = 0.4$\n\n首先，我们计算因子 $(1 - \\beta c)$：\n$$\n1 - \\beta c = 1 - (4)(0.4) = 1 - 1.6 = -0.6\n$$\n现在我们计算 $R_{\\text{UI}}$：\n$$\nR_{\\text{UI}} = (0.5\\,\\mathrm{cm}^{-1}) \\cdot (10\\,\\mathrm{cm}) \\cdot (1.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})) \\cdot (-0.6)\n$$\n$$\nR_{\\text{UI}} = (5) \\cdot (1.0 \\times 10^{12}) \\cdot (-0.6)\\,\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})\n$$\n$$\nR_{\\text{UI}} = -3.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})\n$$\n问题要求答案四舍五入到三位有效数字。因此，我们将结果表示为 $-3.00 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2} \\cdot \\mathrm{s})$。$R_{\\text{UI}}$ 的单位是 $(\\mathrm{cm}^{-1})(\\mathrm{cm})(\\mathrm{n}/\\mathrm{cm}^{2}\\cdot\\mathrm{s}) = \\mathrm{n}/\\mathrm{cm}^{2}\\cdot\\mathrm{s}$，这对应于单位面积的反应率（柱状率），与问题的要求一致。\n\n从数值积分的角度来看，$R_{\\text{UI}}$ 的负值结果源于降阶积分。被积函数 $g(\\xi)$ 是 $\\xi$ 的二次多项式，因为 $\\phi(\\xi)$ 是二次的。单点高斯-勒让德求积仅对次数最高为 $2n-1 = 2(1)-1=1$ 的多项式是精确的。将其应用于二次函数，我们就是在进行降阶积分。该方法通过仅在单点 $\\xi=0$ 处对函数进行采样，并将此值乘以区间长度来近似积分。在这种特殊情况下，近似通量函数 $\\phi(\\xi)$ 在元件中心附近陷入了一个非物理的负值区域。我们有 $\\phi(0) = -0.6\\,\\phi_0  0$。求积法则对远离元件中心的通量函数的正值“视而不见”。真实的积分 $R = \\int_{-1}^{1} g(\\xi) d\\xi$ 正确地考虑了 $\\phi(\\xi) > 0$ 区域的正贡献，并且实际上是正的 ($R = \\tfrac{11}{15} \\sigma_a L_e \\phi_0 \\approx 3.67 \\times 10^{12}$)。然而，单点求积法仅仅在被积函数为负的一点进行求值，从而为总反应率产生了一个非物理的负结果。这展示了当低阶数值积分应用于具有复杂行为的函数时的一个关键失效模式，例如在输运理论的高阶数值方法中有时遇到的振荡的、非保正的近似。",
            "answer": "$$\n\\boxed{-3.00 \\times 10^{12}}\n$$"
        },
        {
            "introduction": "在真实的反应堆模拟中，我们常常需要处理多维积分，此时“维数灾难”会使简单的张量积求积方法变得不切实际。这项高级实践  要求你动手实现并比较两种多维求积方案：传统的张量积高斯求积和更先进的稀疏网格求积。通过对一个模拟燃料棒内中子注量率分布的函数进行积分，你将亲身体验如何应对高维问题，并深入理解在计算精度与计算成本之间进行权衡的艺术。",
            "id": "4224056",
            "problem": "考虑在估算核反应堆模拟中的反应率泛函时出现的多维数值积分问题。设基准被积函数在单位超立方体上定义如下。对于任意整数维度 $d \\geq 1$，定义一维分量\n$$\ng_{\\alpha,\\beta}(t) = \\exp\\!\\big(-\\alpha\\,(t - \\tfrac{1}{2})^2\\big)\\,\\Big(1 + \\beta\\,(t - \\tfrac{1}{2})^2\\Big), \\quad t \\in [0,1],\n$$\n其中参数 $\\alpha  0$ 且 $\\beta \\ge 0$。令 $d$ 维被积函数为可分离乘积\n$$\n\\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) = \\prod_{j=1}^{d} g_{\\alpha,\\beta}(x_j), \\quad \\boldsymbol{x} = (x_1,\\dots,x_d) \\in [0,1]^d.\n$$\n此函数形式模拟了光滑的燃料棒通量分布，该分布在区域中心附近达到最大值，并向边界衰减，同时带有二次形状修正，这与反应堆物理中经典的扩散驱动光滑性假设相符。\n\n您必须从黎曼积分的定义、$\\phi_{\\alpha,\\beta}^{(d)}$ 的可分离性以及高斯函数的标准性质出发，运用第一性原理分析计算该积分\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\int_{[0,1]^d} \\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x},\n$$\n使用公认的特殊函数来表达所得的精确值，并证明每一步代数推导的合理性。\n\n然后，实现并比较两种用于近似计算同一积分的数值求积方案：\n- 张量积高斯-勒让德 (GL) 求积，每维在 $[0,1]$ 上使用 $n$ 个点，通过将经典的 GL 节点和权重从 $[-1,1]$ 线性映射到 $[0,1]$ 而获得，并形成完整的张量积。计算量定义为被积函数的求值次数 $n^d$。\n- 基于 Smolyak 构造的稀疏网格求积，使用递增级别 $k \\in \\{1,2,\\dots,L\\}$ 的一维 GL 法则 $Q^{(k)}$，其中每个 $Q^{(k)}$ 是具有 $n_k = 2k - 1$ 个点的 GL 法则。使用标准差分算子 $\\Delta^{(1)} = Q^{(1)}$ 和 $\\Delta^{(k)} = Q^{(k)} - Q^{(k-1)}$ (对于 $k \\ge 2$)，并构造 $d$ 维 Smolyak 算子\n$$\n\\mathcal{A}(L,d) = \\sum_{s=d}^{L}\\,\\sum_{\\substack{i_1+\\cdots+i_d=s\\\\ i_j \\ge 1}}\\,\\bigotimes_{j=1}^{d} \\Delta^{(i_j)}.\n$$\n您必须汇总所有张量积差分项的点和权重，通过对权重求和来合并重复的点，并对每个唯一的点只进行一次被积函数求值。将计算量定义为唯一的被积函数点求值次数。\n\n对于每种方法，计算绝对误差\n$$\nE = \\big|I_{\\mathrm{approx}} - I_{\\mathrm{exact}}\\big|\n$$\n以及每功误差比\n$$\n\\rho = \\frac{E}{W},\n$$\n其中 $W$ 是如上定义的计算量。\n\n设计程序运行一个包含多个参数集的测试套件，以涵盖不同维度和平滑度参数的范围。对于每个测试用例，您的程序必须输出一个方括号列表，其中依次包含张量积的每功误差比 $\\rho_{\\mathrm{TP}}$、稀疏网格的每功误差比 $\\rho_{\\mathrm{SG}}$，以及一个布尔值，指示稀疏网格的比率是否严格小于张量积的比率。最终的程序输出必须是单行文本，其中包含一个由逗号分隔的各测试用例列表组成的列表，所有内容都包含在一对方括号内。\n\n使用以下测试套件以确保覆盖典型行为、纯高斯边界条件以及高维边缘场景：\n- 测试用例 1：$(d,n,L,\\alpha,\\beta) = (2,10,3,25,0.2)$。\n- 测试用例 2：$(d,n,L,\\alpha,\\beta) = (3,8,4,40,0)$。\n- 测试用例 3：$(d,n,L,\\alpha,\\beta) = (6,5,8,15,0.05)$。\n- 测试用例 4：$(d,n,L,\\alpha,\\beta) = (3,12,5,5,1)$。\n\n在所有计算中，不涉及角度；因此不需要角度单位。也不存在物理单位；将所有数值量报告为无量纲实数。您的程序应生成单行输出，其中包含一个由逗号分隔的列表，该列表被方括号包围，格式如下\n$$\n[\\,[\\rho_{\\mathrm{TP},1},\\rho_{\\mathrm{SG},1},b_1],\\,[\\rho_{\\mathrm{TP},2},\\rho_{\\mathrm{SG},2},b_2],\\,\\dots\\,],\n$$\n其中 $b_k$ 是测试用例 $k$ 的布尔值，每个 $\\rho$ 是一个实数。",
            "solution": "问题陈述经评估有效。所有给出的定义、参数和条件在科学上均有根据，在数学上是适定的，并且是自洽的。该问题要求解析推导一个明确定义的积分，并使用标准求积技术（张量积和稀疏网格高斯-勒让德求积）对其进行数值逼近，这是数值分析和计算科学中的一个标准课题。所提供的与核反应堆模拟相关的背景是合理的，因为类高斯函数常用于表示通量分布。该问题没有歧义、矛盾和事实错误。\n\n### 第一部分：精确积分的解析推导\n\n目标是计算积分 $I_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\int_{[0,1]^d} \\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$。\n被积函数定义为可分离乘积：\n$$\n\\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) = \\prod_{j=1}^{d} g_{\\alpha,\\beta}(x_j)\n$$\n其中 $\\boldsymbol{x} = (x_1, \\dots, x_d)$，一维分量函数由下式给出：\n$$\ng_{\\alpha,\\beta}(t) = \\exp\\!\\big(-\\alpha\\,(t - \\tfrac{1}{2})^2\\big)\\,\\Big(1 + \\beta\\,(t - \\tfrac{1}{2})^2\\Big)\n$$\n对于 $t \\in [0,1]$，参数 $\\alpha  0$ 且 $\\beta \\ge 0$。\n\n由于被积函数的可分离性以及积分区域为矩形域 $[0,1]^d$，根据 Fubini 定理，该多维积分可以表示为一维积分的乘积：\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\int_{0}^{1} \\cdots \\int_{0}^{1} \\prod_{j=1}^{d} g_{\\alpha,\\beta}(x_j) \\,\\mathrm{d}x_1 \\cdots \\mathrm{d}x_d = \\prod_{j=1}^{d} \\left( \\int_{0}^{1} g_{\\alpha,\\beta}(x_j) \\,\\mathrm{d}x_j \\right)\n$$\n由于每个一维积分都相同，我们可以定义 $I_1(\\alpha, \\beta) = \\int_{0}^{1} g_{\\alpha,\\beta}(t) \\,\\mathrm{d}t$，总积分则变为：\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\left( I_1(\\alpha,\\beta) \\right)^d\n$$\n我们现在求解 $I_1(\\alpha, \\beta)$：\n$$\nI_1(\\alpha,\\beta) = \\int_0^1 \\exp\\!\\big(-\\alpha\\,(t - \\tfrac{1}{2})^2\\big)\\,\\Big(1 + \\beta\\,(t - \\tfrac{1}{2})^2\\Big) \\,\\mathrm{d}t\n$$\n我们进行变量代换，将区间中心移至 $0$。令 $u = t - \\frac{1}{2}$。则 $\\mathrm{d}u = \\mathrm{d}t$。积分上下限从 $t$ 的 $[0,1]$ 变为 $u$ 的 $[-1/2, 1/2]$。\n$$\nI_1(\\alpha,\\beta) = \\int_{-1/2}^{1/2} e^{-\\alpha u^2} (1 + \\beta u^2) \\,\\mathrm{d}u\n$$\n我们可以将其分为两部分：\n$$\nI_1(\\alpha,\\beta) = \\int_{-1/2}^{1/2} e^{-\\alpha u^2} \\,\\mathrm{d}u + \\beta \\int_{-1/2}^{1/2} u^2 e^{-\\alpha u^2} \\,\\mathrm{d}u\n$$\n我们先计算第一项，$I_{1,A} = \\int_{-1/2}^{1/2} e^{-\\alpha u^2} \\,\\mathrm{d}u$。我们引入另一个代换，$v = \\sqrt{\\alpha}u$，这意味着 $\\mathrm{d}u = \\frac{1}{\\sqrt{\\alpha}}\\mathrm{d}v$。$v$ 的积分限变为 $[-\\sqrt{\\alpha}/2, \\sqrt{\\alpha}/2]$。\n$$\nI_{1,A} = \\int_{-\\sqrt{\\alpha}/2}^{\\sqrt{\\alpha}/2} e^{-v^2} \\frac{1}{\\sqrt{\\alpha}} \\,\\mathrm{d}v = \\frac{1}{\\sqrt{\\alpha}} \\int_{-\\sqrt{\\alpha}/2}^{\\sqrt{\\alpha}/2} e^{-v^2} \\,\\mathrm{d}v\n$$\n误差函数 $\\mathrm{erf}(z)$ 定义为 $\\mathrm{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,\\mathrm{d}t$。由于 $e^{-v^2}$ 是偶函数，$\\int_{-a}^a e^{-v^2} \\mathrm{d}v = 2\\int_0^a e^{-v^2} \\mathrm{d}v$。\n因此，$\\int_{-\\sqrt{\\alpha}/2}^{\\sqrt{\\alpha}/2} e^{-v^2} \\,\\mathrm{d}v = 2 \\int_0^{\\sqrt{\\alpha}/2} e^{-v^2} \\,\\mathrm{d}v = \\sqrt{\\pi} \\, \\mathrm{erf}(\\frac{\\sqrt{\\alpha}}{2})$。\n将其代回，我们得到：\n$$\nI_{1,A} = \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right)\n$$\n接下来，我们计算乘以 $\\beta$ 的第二项。令该积分为 $I' = \\int_{-1/2}^{1/2} u^2 e^{-\\alpha u^2} \\,\\mathrm{d}u$。我们使用分部积分法，$\\int f(u) g'(u) \\mathrm{d}u = f(u)g(u) - \\int f'(u)g(u) \\mathrm{d}u$。\n令 $f(u) = u$ 且 $g'(u) = u e^{-\\alpha u^2}$。则 $f'(u) = 1$ 且 $g(u) = -\\frac{1}{2\\alpha}e^{-\\alpha u^2}$。\n$$\nI' = \\left[ u \\left(-\\frac{1}{2\\alpha}e^{-\\alpha u^2}\\right) \\right]_{-1/2}^{1/2} - \\int_{-1/2}^{1/2} 1 \\cdot \\left(-\\frac{1}{2\\alpha}e^{-\\alpha u^2}\\right) \\mathrm{d}u\n$$\n$$\nI' = \\left[ -\\frac{u}{2\\alpha}e^{-\\alpha u^2} \\right]_{-1/2}^{1/2} + \\frac{1}{2\\alpha} \\int_{-1/2}^{1/2} e^{-\\alpha u^2} \\mathrm{d}u\n$$\n第一部分计算结果为：\n$$\n\\left( -\\frac{1/2}{2\\alpha}e^{-\\alpha (1/2)^2} \\right) - \\left( -\\frac{-1/2}{2\\alpha}e^{-\\alpha (-1/2)^2} \\right) = -\\frac{1}{4\\alpha}e^{-\\alpha/4} - \\frac{1}{4\\alpha}e^{-\\alpha/4} = -\\frac{1}{2\\alpha}e^{-\\alpha/4}\n$$\n第二部分就是 $\\frac{1}{2\\alpha}I_{1,A}$。\n$$\nI' = -\\frac{1}{2\\alpha}e^{-\\alpha/4} + \\frac{1}{2\\alpha} \\left( \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) \\right)\n$$\n现在，我们将各项合并得到 $I_1(\\alpha, \\beta) = I_{1,A} + \\beta I'$：\n$$\nI_1(\\alpha,\\beta) = \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) + \\beta \\left( -\\frac{1}{2\\alpha}e^{-\\alpha/4} + \\frac{\\sqrt{\\pi}}{2\\alpha\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) \\right)\n$$\n将含有误差函数的项归类：\n$$\nI_1(\\alpha,\\beta) = \\left( \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} + \\frac{\\beta\\sqrt{\\pi}}{2\\alpha\\sqrt{\\alpha}} \\right) \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) - \\frac{\\beta}{2\\alpha}e^{-\\alpha/4}\n$$\n提取公因式得到一维积分的最终表达式：\n$$\nI_1(\\alpha,\\beta) = \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\left( 1 + \\frac{\\beta}{2\\alpha} \\right) \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) - \\frac{\\beta}{2\\alpha}e^{-\\alpha/4}\n$$\n最后，$d$ 维积分的精确值为：\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\left( \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\left( 1 + \\frac{\\beta}{2\\alpha} \\right) \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) - \\frac{\\beta}{2\\alpha}e^{-\\alpha/4} \\right)^d\n$$\n\n### 第二部分：数值求积方案\n\n我们实现两种数值方法来近似积分 $I_{\\mathrm{exact}}$。\n\n**1. 张量积高斯-勒让德 (TP-GL) 求积**\n该方法通过对一维法则取张量积来构造一个 $d$ 维求积法则。我们使用一个 $n$ 点高斯-勒让德 (GL) 法则在每个维度上。标准的 GL 节点 $x_i$ 和权重 $w_i$ 定义在区间 $[-1,1]$ 上。为了在 $[0,1]$ 上使用它们，我们应用一个线性变换 $t = \\frac{1}{2}(x+1)$，其中 $x \\in [-1,1]$ 且 $t \\in [0,1]$。积分变换为 $\\int_0^1 f(t)\\mathrm{d}t = \\int_{-1}^1 f(\\frac{x+1}{2}) \\frac{1}{2}\\mathrm{d}x$。在 $[0,1]$ 上的新节点 $t_i$ 和新权重 $w'_i$ 为：\n$$\nt_i = \\frac{1}{2}(x_i+1), \\quad w'_i = \\frac{1}{2}w_i\n$$\n一维积分近似为 $I_{1,\\mathrm{approx}} = \\sum_{i=1}^n w'_i g_{\\alpha,\\beta}(t_i)$。由于被积函数的可分离性，$d$ 维张量积近似值仅仅是一维近似值的乘积：\n$$\nI_{\\mathrm{TP}} = \\left( \\sum_{i=1}^n w'_i g_{\\alpha,\\beta}(t_i) \\right)^d\n$$\n计算量 $W_{\\mathrm{TP}}$ 是被积函数求值的总次数，对于一个完整的张量积网格，该值为 $n^d$。\n\n**2. 稀疏网格 (SG) 求积**\n稀疏网格是一种缓解维度灾难的技术，该灾难使得完整的张量积方法在高维情况下难以处理。Smolyak 构造结合了基于不同精度等级的一维求积法则所构建的不同张量积法则的结果。\n\n根据问题要求，我们使用级别为 $k$ 的一维 GL 法则 $Q^{(k)}$，其中 $Q^{(k)}$ 具有 $n_k = 2k-1$ 个点。在 $d$ 维空间中，级别为 $L$ 的稀疏网格算子 $\\mathcal{A}(L,d)$ 是由差分算子 $\\Delta^{(k)} = Q^{(k)} - Q^{(k-1)}$（其中 $Q^{(0)}$ 为零算子）构建的：\n$$\n\\mathcal{A}(L,d) = \\sum_{s=d}^{L}\\,\\sum_{\\substack{i_1+\\cdots+i_d=s\\\\ i_j \\ge 1}}\\,\\bigotimes_{j=1}^{d} \\Delta^{(i_j)}\n$$\n积分近似值为 $I_{\\mathrm{SG}} = \\mathcal{A}(L,d)[\\phi_{\\alpha,\\beta}^{(d)}]$。在数值上，该和是通过构建一个唯一的求积点集及其对应的组合权重来计算的。对于满足求和条件的每个多重索引 $\\boldsymbol{i}=(i_1, \\dots, i_d)$，我们考虑差分法则 $\\Delta^{(i_j)}$ 的张量积。每个 $\\Delta^{(i_j)}$ 代表一组来自 $Q^{(i_j)}$ 的带正权重的点和一组来自 $Q^{(i_j-1)}$ 的带负权重的点。我们形成这些点的所有张量积，并将其权重相乘。然后将得到的点-权重对在所有多重索引 $\\boldsymbol{i}$ 上进行汇总。重复的点通过对其权重求和来合并。\n\n计算量 $W_{\\mathrm{SG}}$ 定义为最终聚合集中的唯一点的总数。然后，通过将被积函数在每个唯一点处的值与其最终组合权重相乘，再将所有这些乘积相加来计算积分近似值：\n$$\nI_{\\mathrm{SG}} = \\sum_{(\\boldsymbol{p}, w) \\in \\text{UniquePoints}} w \\cdot \\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{p})\n$$\n\n### 第三部分：误差分析与比较\n\n对于每种方法（TP 和 SG），我们计算绝对误差 $E = |I_{\\mathrm{approx}} - I_{\\mathrm{exact}}|$ 和每功误差比 $\\rho = E/W$。该比率作为计算效率的度量，平衡了精度与函数求值次数。程序将为每个测试用例计算 $\\rho_{\\mathrm{TP}} = E_{\\mathrm{TP}}/W_{\\mathrm{TP}}$ 和 $\\rho_{\\mathrm{SG}} = E_{\\mathrm{SG}}/W_{\\mathrm{SG}}$，并判断稀疏网格方法是否更高效（即 $\\rho_{\\mathrm{SG}}  \\rho_{\\mathrm{TP}}$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, erf\nfrom math import sqrt, pi, exp\nfrom itertools import product as itertools_product\n\ndef solve():\n    \"\"\"\n    Main solver function that runs test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (d, n, L, alpha, beta)\n        (2, 10, 3, 25, 0.2),\n        (3, 8, 4, 40, 0),\n        (6, 5, 8, 15, 0.05),\n        (3, 12, 5, 5, 1),\n    ]\n\n    results = []\n    # Caching for 1D quadrature rules to avoid recomputation\n    memo_1d_rules = {}\n\n    for d, n, L, alpha, beta in test_cases:\n        # Calculate exact integral\n        I_exact = calculate_I_exact(d, alpha, beta)\n\n        # 1. Tensor-Product Quadrature\n        I_tp, W_tp = calculate_I_tp(d, n, alpha, beta, memo_1d_rules)\n        E_tp = abs(I_tp - I_exact)\n        rho_tp = E_tp / W_tp if W_tp > 0 else float('inf')\n\n        # 2. Sparse-Grid Quadrature\n        I_sg, W_sg = calculate_I_sg(d, L, alpha, beta, memo_1d_rules)\n        E_sg = abs(I_sg - I_exact)\n        rho_sg = E_sg / W_sg if W_sg > 0 else float('inf')\n\n        results.append([rho_tp, rho_sg, str(rho_sg  rho_tp).lower()])\n\n    # Format output as specified: [[r1,r2,bool],[...],...]\n    inner_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_string = f\"[{','.join(inner_results)}]\"\n    print(final_string)\n\ndef g_func(t, alpha, beta):\n    \"\"\"The 1D component of the integrand.\"\"\"\n    term = t - 0.5\n    term_sq = term * term\n    return exp(-alpha * term_sq) * (1.0 + beta * term_sq)\n\ndef phi_func(x_vec, alpha, beta):\n    \"\"\"The d-dimensional integrand.\"\"\"\n    val = 1.0\n    for x_j in x_vec:\n        val *= g_func(x_j, alpha, beta)\n    return val\n\ndef calculate_I_exact(d, alpha, beta):\n    \"\"\"Computes the analytical value of the integral.\"\"\"\n    sqrt_alpha = sqrt(alpha)\n    erf_term = erf(sqrt_alpha / 2.0)\n    \n    # Value for beta = 0\n    if beta == 0:\n        I_1 = (sqrt(pi) / sqrt_alpha) * erf_term\n    else:\n        exp_term = exp(-alpha / 4.0)\n        term1 = (sqrt(pi) / sqrt_alpha) * (1.0 + beta / (2.0 * alpha)) * erf_term\n        term2 = beta / (2.0 * alpha) * exp_term\n        I_1 = term1 - term2\n        \n    return I_1 ** d\n\ndef get_scaled_gl_rule(num_points, memo):\n    \"\"\"\n    Computes or retrieves from cache the scaled Gauss-Legendre rule for [0,1].\n    \"\"\"\n    if num_points in memo:\n        return memo[num_points]\n    \n    if num_points == 0:\n        return np.array([]), np.array([])\n\n    nodes, weights = roots_legendre(num_points)\n    \n    # Scale nodes from [-1, 1] to [0, 1]\n    scaled_nodes = 0.5 * (nodes + 1.0)\n    # Scale weights for the interval transformation\n    scaled_weights = 0.5 * weights\n    \n    memo[num_points] = (scaled_nodes, scaled_weights)\n    return scaled_nodes, scaled_weights\n\ndef calculate_I_tp(d, n, alpha, beta, memo_1d_rules):\n    \"\"\"Computes the integral using tensor-product Gaussian-Legendre quadrature.\"\"\"\n    nodes, weights = get_scaled_gl_rule(n, memo_1d_rules)\n    \n    # 1D integral approximation\n    I_1_approx = sum(w * g_func(x, alpha, beta) for x, w in zip(nodes, weights))\n    \n    # Full integral is the 1D integral to the power of d due to separability\n    I_approx = I_1_approx ** d\n    \n    # Work is the total number of evaluation points\n    work = n ** d\n    \n    return I_approx, work\n\ndef get_partitions(n, k, min_val=1):\n    \"\"\"Generator for ordered integer partitions.\"\"\"\n    if k == 1:\n        if n >= min_val:\n            yield (n,)\n        return\n    \n    for i in range(min_val, n - (k - 1) * min_val + 1):\n        for rest in get_partitions(n - i, k - 1, min_val):\n            yield (i,) + rest\n\ndef calculate_I_sg(d, L, alpha, beta, memo_1d_rules):\n    \"\"\"Computes the integral using Smolyak sparse-grid quadrature.\"\"\"\n    unique_points = {}\n    \n    memo_delta_rules = {}\n\n    def get_delta_rule(k):\n        if k in memo_delta_rules:\n            return memo_delta_rules[k]\n        \n        if k == 1:\n            nodes1, weights1 = get_scaled_gl_rule(1, memo_1d_rules)\n            rule = list(zip(nodes1, weights1))\n            memo_delta_rules[k] = rule\n            return rule\n        \n        # Q^(k)\n        nodes_pos, weights_pos = get_scaled_gl_rule(2 * k - 1, memo_1d_rules)\n        # Q^(k-1)\n        nodes_neg, weights_neg = get_scaled_gl_rule(2 * (k - 1) - 1, memo_1d_rules)\n        \n        rule = list(zip(nodes_pos, weights_pos)) + list(zip(nodes_neg, -weights_neg))\n        memo_delta_rules[k] = rule\n        return rule\n\n    for s in range(d, L + 1):\n        for i_vec in get_partitions(s, d):\n            \n            delta_rules_for_tensor_prod = [get_delta_rule(ik) for ik in i_vec]\n            \n            for combo in itertools_product(*delta_rules_for_tensor_prod):\n                point = tuple(c[0] for c in combo)\n                weight = 1.0\n                for c in combo:\n                    weight *= c[1]\n                \n                unique_points[point] = unique_points.get(point, 0.0) + weight\n\n    # Calculate integral from unique points and summed weights\n    I_approx = 0.0\n    for point, weight in unique_points.items():\n        if abs(weight) > 1e-15: # Ignore points with negligible weights\n            I_approx += weight * phi_func(point, alpha, beta)\n\n    # Work is the number of unique points with non-zero weights\n    work = len([w for w in unique_points.values() if abs(w) > 1e-15])\n    \n    return I_approx, work\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}