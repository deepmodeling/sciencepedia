{
    "hands_on_practices": [
        {
            "introduction": "A fundamental task in computational science is to ensure that numerical approximations meet a required tolerance for accuracy. This exercise provides direct practice in applying a theoretical error bound for the composite Simpson's rule to answer a critical, practical question: how many integration panels are needed to guarantee a desired level of precision for a reaction-rate calculation in a reactor pin-cell? Mastering this type of a priori error estimation () is essential for developing efficient and reliable simulation codes.",
            "id": "4224058",
            "problem": "A one-dimensional radial pin-cell model is used in a Pressurized Water Reactor (PWR) lattice calculation. The quantity of interest is a dimensionless, normalized reaction-rate integral defined by\n$$\nI \\;=\\; \\int_{0}^{R_{c}} f(r) \\,\\mathrm{d}r,\n$$\nwhere $f(r)$ is the normalized absorption-rate density given by $f(r) = \\big(2\\pi r\\,\\Sigma_{a}(r)\\,\\phi(r)\\big)/Q_{0}$, with $\\Sigma_{a}(r)$ the macroscopic absorption cross section, $\\phi(r)$ the neutron flux, and $Q_{0}$ a positive normalization constant chosen so that $I$ is dimensionless. The cell radius is $R_{c} = 0.60\\,\\mathrm{cm}$. From a diffusion-theory analysis of the flux shape in the pin cell with smoothly varying $\\Sigma_{a}(r)$, it is established that $f$ has a continuous fourth derivative on $[0,R_{c}]$ and satisfies the uniform bound\n$$\n\\big|f^{(4)}(r)\\big| \\;\\le\\; M, \\quad \\text{for all } r\\in[0,R_{c}],\n$$\nwith $M = 1.0\\times 10^{4}\\,\\mathrm{cm}^{-4}$.\n\nYou will approximate $I$ using the composite Simpson’s rule on $[0,R_{c}]$ with $N$ equal-width panels (subintervals), where $N$ must be an even integer. Determine the smallest even integer $N$ such that the absolute quadrature error satisfies $\\big|E\\big|  10^{-6}$. Express your final answer as the minimal even integer $N$. No rounding specification is needed because the answer must be an exact integer.",
            "solution": "The problem requires the determination of the smallest even integer $N$, representing the number of panels, for a composite Simpson's rule approximation of the integral $I = \\int_{0}^{R_{c}} f(r) \\,\\mathrm{d}r$, such that the absolute quadrature error $|E|$ is less than $10^{-6}$.\n\nThe absolute error $|E|$ for the composite Simpson's rule used to approximate the integral $\\int_{a}^{b} f(x) \\,\\mathrm{d}x$ with $N$ equal-width panels (where $N$ is an even integer) is bounded by the inequality:\n$$|E| \\le \\frac{(b-a)^{5}}{180 N^{4}} \\max_{x \\in [a,b]} |f^{(4)}(x)|$$\nThis formula is applicable here because the problem states that $f$ has a continuous fourth derivative on the interval of integration.\n\nFor the given problem, the interval of integration is $[a, b] = [0, R_{c}]$, where $R_{c} = 0.60\\,\\mathrm{cm}$. The function to be integrated is $f(r)$. The problem provides a uniform bound for the fourth derivative of $f(r)$:\n$$|f^{(4)}(r)| \\le M, \\quad \\text{for all } r \\in [0, R_{c}]$$\nwhere $M = 1.0 \\times 10^{4}\\,\\mathrm{cm}^{-4}$. Thus, $\\max_{r \\in [0, R_{c}]} |f^{(4)}(r)| \\le M$.\n\nSubstituting these parameters into the error bound formula, we have:\n$$|E| \\le \\frac{(R_{c} - 0)^{5}}{180 N^{4}} M = \\frac{R_{c}^{5} M}{180 N^{4}}$$\n\nWe are required to find the smallest even integer $N$ that ensures the absolute error $|E|$ satisfies the condition $|E|  10^{-6}$. To guarantee this, we enforce that the upper bound of the error is less than or equal to the desired tolerance of $10^{-6}$:\n$$\\frac{R_{c}^{5} M}{180 N^{4}} \\le 10^{-6}$$\n\nWe can now solve this inequality for $N$. Rearranging the terms, we get:\n$$N^{4} \\ge \\frac{R_{c}^{5} M}{180 \\times 10^{-6}}$$\nTaking the fourth root of both sides yields:\n$$N \\ge \\left(\\frac{R_{c}^{5} M}{180 \\times 10^{-6}}\\right)^{1/4}$$\n\nNow, we substitute the given numerical values, $R_{c} = 0.60$ and $M = 1.0 \\times 10^{4}$, into the inequality. We will treat the quantities as dimensionless for the purpose of this calculation, as the units have already been established as consistent.\n$$N \\ge \\left(\\frac{(0.60)^{5} (1.0 \\times 10^{4})}{180 \\times 10^{-6}}\\right)^{1/4}$$\nFirst, we compute the value of the term $(0.60)^{5}$:\n$$(0.60)^{5} = 0.07776$$\nNext, we evaluate the expression inside the parentheses:\n$$\\frac{0.07776 \\times 10^{4}}{180 \\times 10^{-6}} = \\frac{777.6}{1.8 \\times 10^{-4}} = 4.32 \\times 10^{6}$$\nSo, the inequality for $N$ becomes:\n$$N \\ge (4.32 \\times 10^{6})^{1/4}$$\nCalculating the numerical value of the right-hand side:\n$$N \\ge 45.5905\\ldots$$\nThe problem requires that $N$ must be an integer. The smallest integer value for $N$ that satisfies this condition is $N = 46$. Additionally, the problem specifies that $N$ must be an even integer. Since $46$ is an even number, it fulfills all the stated requirements.\n\nTherefore, the smallest even integer number of panels $N$ required to achieve the specified error tolerance is $46$.",
            "answer": "$$\\boxed{46}$$"
        },
        {
            "introduction": "Numerical methods, when misapplied, can produce results that are not just inaccurate but physically meaningless. This exercise explores such a failure mode by demonstrating how underintegration—using a quadrature rule of insufficient order for a given integrand—can lead to a non-physical negative absorption rate. Understanding these potential pitfalls () is as important as knowing the methods themselves, as it fosters the critical judgment needed to validate and debug complex simulations.",
            "id": "4224064",
            "problem": "A one-dimensional slab element in a reactor pin-cell model of length $L_{e} = 10\\,\\mathrm{cm}$ is considered for a one-group steady-state absorption calculation. The volumetric absorption reaction rate density is the product of the macroscopic absorption cross section and the scalar neutron flux. The exact element absorption reaction rate is therefore the line integral $R = \\int_{x_{e}} \\sigma_{a}(x)\\,\\phi(x)\\,dx$, which must be nonnegative for physically admissible $\\sigma_{a}(x) \\ge 0$ and $\\phi(x) \\ge 0$. In a high-order nodal discretization, however, the approximate scalar flux can exhibit oscillations that are not positivity preserving at all points. This problem investigates how an underintegrated quadrature can then produce a nonphysical negative reaction rate on an element.\n\nConsider a constant macroscopic absorption cross section $\\sigma_{a}(x) \\equiv \\sigma_{a} = 0.5\\,\\mathrm{cm}^{-1}$ on the element and a polynomial approximation to the scalar flux given on the reference coordinate $\\xi \\in [-1,1]$ by\n$$\n\\phi(\\xi) \\;=\\; \\phi_{0}\\,\\bigl[\\,1 + \\beta\\,(\\xi^{2} - c)\\,\\bigr],\n$$\nwith $\\phi_{0} = 1.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})$, $\\beta = 4$, and $c = 0.4$. The physical coordinate is $x = x_{c} + \\tfrac{L_{e}}{2}\\,\\xi$ with Jacobian $dx = \\tfrac{L_{e}}{2}\\,d\\xi$.\n\nThe element absorption reaction rate is to be approximated using the one-point Gauss–Legendre quadrature on the reference interval, applied to the mapped integrand $\\sigma_{a}\\,\\phi(\\xi)$ with the standard affine transformation. Compute the underintegrated element absorption reaction rate $R_{\\text{UI}}$ produced by this quadrature for the given data. Report your answer in $\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})$ and round to three significant figures.\n\nIn your reasoning, you should base your derivation on: (i) the definition of the absorption reaction rate as an integral of $\\sigma_{a}\\phi$ over the element, (ii) the affine mapping from the reference to the physical element, and (iii) the standard properties of the one-point Gauss–Legendre quadrature on $[-1,1]$. You should also articulate why, from the numerical quadrature perspective, underintegration can yield a negative $R_{\\text{UI}}$ even though $\\sigma_{a} \\ge 0$ everywhere. Do not use any shortcut formulas not derived from these bases.\n\nExpress the final $R_{\\text{UI}}$ in $\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})$ and round to three significant figures.",
            "solution": "The primary objective is to compute the underintegrated element absorption reaction rate, $R_{\\text{UI}}$, using a one-point Gauss-Legendre quadrature. The exact reaction rate, $R$, is defined by the integral of the reaction rate density, $\\sigma_{a}(x)\\,\\phi(x)$, over the length of the element, $L_{e}$.\n\n(i) The definition of the exact element absorption reaction rate is given as:\n$$\nR = \\int_{x_{e}} \\sigma_{a}(x)\\,\\phi(x)\\,dx\n$$\nThe integral is over the physical domain of the element, which has length $L_e$.\n\n(ii) To apply the standard Gauss-Legendre quadrature, which is defined on the reference interval $\\xi \\in [-1, 1]$, we perform an affine coordinate transformation. The problem provides the mapping $x = x_{c} + \\tfrac{L_{e}}{2}\\,\\xi$, where $x_c$ is the center of the element. The differential element transforms according to the Jacobian of this mapping: $dx = \\tfrac{L_{e}}{2}\\,d\\xi$. The limits of integration over $x_e$ correspond to $\\xi = -1$ and $\\xi = 1$. The cross section $\\sigma_{a}$ is constant. The integral for $R$ can thus be rewritten in terms of the reference coordinate $\\xi$:\n$$\nR = \\int_{-1}^{1} \\sigma_{a}\\,\\phi(\\xi)\\,\\left(\\frac{L_{e}}{2}\\right)\\,d\\xi\n$$\nLet us define the integrand on the reference interval as $g(\\xi) = \\sigma_{a}\\,\\phi(\\xi)\\,\\frac{L_{e}}{2}$.\n\n(iii) The element absorption reaction rate is to be approximated using the one-point Gauss–Legendre quadrature rule. For an integral of the form $I = \\int_{-1}^{1} f(\\xi)\\,d\\xi$, the one-point rule is given by:\n$$\nI_{\\text{GL1}} \\approx w_{1} f(\\xi_{1})\n$$\nThe standard one-point Gauss-Legendre quadrature point is $\\xi_{1} = 0$, and the corresponding weight is $w_{1} = 2$.\nApplying this rule to our integral for $R$, we obtain the underintegrated approximation $R_{\\text{UI}}$:\n$$\nR_{\\text{UI}} = w_{1}\\,g(\\xi_{1}) = 2 \\cdot g(0)\n$$\nSubstituting the expression for $g(\\xi)$:\n$$\nR_{\\text{UI}} = 2 \\left[ \\sigma_{a}\\,\\phi(0)\\,\\frac{L_{e}}{2} \\right] = \\sigma_{a}\\,L_{e}\\,\\phi(0)\n$$\nNow, we must evaluate the approximate scalar flux $\\phi(\\xi)$ at the quadrature point $\\xi = 0$. The given expression for the flux is:\n$$\n\\phi(\\xi) = \\phi_{0}\\,\\bigl[\\,1 + \\beta\\,(\\xi^{2} - c)\\,\\bigr]\n$$\nAt $\\xi = 0$, the flux is:\n$$\n\\phi(0) = \\phi_{0}\\,\\bigl[\\,1 + \\beta\\,(0^{2} - c)\\,\\bigr] = \\phi_{0}\\,(1 - \\beta c)\n$$\nSubstituting this into our expression for $R_{\\text{UI}}$ yields the symbolic result:\n$$\nR_{\\text{UI}} = \\sigma_{a}\\,L_{e}\\,\\phi_{0}\\,(1 - \\beta c)\n$$\nWe now substitute the provided numerical values:\n$\\sigma_{a} = 0.5\\,\\mathrm{cm}^{-1}$\n$L_{e} = 10\\,\\mathrm{cm}$\n$\\phi_{0} = 1.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})$\n$\\beta = 4$\n$c = 0.4$\n\nFirst, we compute the factor $(1 - \\beta c)$:\n$$\n1 - \\beta c = 1 - (4)(0.4) = 1 - 1.6 = -0.6\n$$\nNow we compute $R_{\\text{UI}}$:\n$$\nR_{\\text{UI}} = (0.5\\,\\mathrm{cm}^{-1}) \\cdot (10\\,\\mathrm{cm}) \\cdot (1.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})) \\cdot (-0.6)\n$$\n$$\nR_{\\text{UI}} = (5) \\cdot (1.0 \\times 10^{12}) \\cdot (-0.6)\\,\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})\n$$\n$$\nR_{\\text{UI}} = -3.0 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})\n$$\nThe problem requires the answer to be rounded to three significant figures. Thus, we express the result as $-3.00 \\times 10^{12}\\,\\mathrm{n}/(\\mathrm{cm}^{2}\\,\\mathrm{s})$. The units of $R_{\\text{UI}}$ are $(\\mathrm{cm}^{-1})(\\mathrm{cm})(\\mathrm{n}/(\\mathrm{cm}^{2}\\cdot\\mathrm{s})) = \\mathrm{n}/(\\mathrm{cm}^{2}\\cdot\\mathrm{s})$, which corresponds to a reaction rate per unit area (a columnar rate), consistent with the problem's request.\n\nFrom the numerical quadrature perspective, the negative result for $R_{\\text{UI}}$ arises from underintegration. The integrand, $g(\\xi)$, is a quadratic polynomial in $\\xi$, since $\\phi(\\xi)$ is quadratic. A one-point Gauss-Legendre quadrature is exact only for polynomials of degree up to $2n-1 = 2(1)-1=1$. By applying it to a quadratic function, we are underintegrating. The method approximates the integral by sampling the function only at a single point, $\\xi=0$, and scaling this value by the interval length. In this specific case, the approximate flux function $\\phi(\\xi)$ dips into a non-physical negative region around the center of the element. We have $\\phi(0) = -0.6\\,\\phi_0  0$. The quadrature rule is \"blind\" to the positive values of the flux function away from the center of the element. The true integral, $R = \\int_{-1}^{1} g(\\xi) d\\xi$, correctly accounts for the positive contributions from regions where $\\phi(\\xi) > 0$ and is, in fact, positive ($R = \\tfrac{11}{15} \\sigma_a L_e \\phi_0 \\approx 3.67 \\times 10^{12}$). However, the one-point quadrature, by exclusively evaluating the integrand at a point where it is negative, produces a non-physical negative result for the total reaction rate. This demonstrates a key failure mode of low-order numerical integration when applied to functions with complex behavior, such as the oscillatory, non-positivity-preserving approximations sometimes encountered in high-order numerical methods for transport theory.",
            "answer": "$$\n\\boxed{-3.00 \\times 10^{12}}\n$$"
        },
        {
            "introduction": "While one-dimensional integrals are foundational, many real-world reactor physics problems require integration over multiple dimensions, confronting us with the \"curse of dimensionality.\" This practice moves from pen-and-paper analysis to implementation, challenging you to compare a standard tensor-product quadrature with a more advanced sparse-grid method. By quantifying the trade-off between accuracy and computational work (), you will gain hands-on insight into why sophisticated techniques are indispensable for tackling high-dimensional problems efficiently.",
            "id": "4224056",
            "problem": "Consider multi-dimensional numerical integration that arises when estimating reaction rate functionals in nuclear reactor simulation. Let the benchmark integrand be defined on the unit hypercube as follows. For any integer dimension $d \\geq 1$, define the one-dimensional component\n$$\ng_{\\alpha,\\beta}(t) = \\exp\\!\\big(-\\alpha\\,(t - \\tfrac{1}{2})^2\\big)\\,\\Big(1 + \\beta\\,(t - \\tfrac{1}{2})^2\\Big), \\quad t \\in [0,1],\n$$\nwith parameters $\\alpha  0$ and $\\beta \\ge 0$. Let the $d$-dimensional integrand be the separable product\n$$\n\\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) = \\prod_{j=1}^{d} g_{\\alpha,\\beta}(x_j), \\quad \\boldsymbol{x} = (x_1,\\dots,x_d) \\in [0,1]^d.\n$$\nThis functional form mimics a smooth fuel rod flux distribution that is maximal near the center of the domain and decays toward boundaries with quadratic shape modification, consistent with classical diffusion-driven smoothness assumptions in reactor physics.\n\nYou must compute the integral\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\int_{[0,1]^d} \\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x},\n$$\nanalytically from first principles, starting from the definition of the Riemann integral, the separability of $\\phi_{\\alpha,\\beta}^{(d)}$, and standard properties of the Gaussian. Express the resulting exact value using only well-established special functions, and justify every algebraic step.\n\nThen, implement and compare two numerical quadrature schemes for approximating the same integral:\n- A tensor-product Gaussian-Legendre (GL) quadrature with $n$ points per dimension on $[0,1]$, obtained by linearly mapping the classical GL nodes and weights from $[-1,1]$ to $[0,1]$, and forming the full tensor product. The computational work is defined as $n^d$, the number of integrand evaluations.\n- A sparse-grid quadrature based on the Smolyak construction with one-dimensional GL rules $Q^{(k)}$ of increasing level $k \\in \\{1,2,\\dots,L\\}$, where each $Q^{(k)}$ is the $n_k$-point GL rule with $n_k = 2k - 1$. Use the standard difference operators $\\Delta^{(1)} = Q^{(1)}$ and $\\Delta^{(k)} = Q^{(k)} - Q^{(k-1)}$ for $k \\ge 2$, and construct the $d$-dimensional Smolyak operator\n$$\n\\mathcal{A}(L,d) = \\sum_{s=d}^{L}\\,\\sum_{\\substack{i_1+\\cdots+i_d=s\\\\ i_j \\ge 1}}\\,\\bigotimes_{j=1}^{d} \\Delta^{(i_j)}.\n$$\nYou must aggregate the points and weights across all tensor-product difference terms, combine duplicate points by summing their weights, and evaluate the integrand only once per unique point. Define the computational work as the number of unique integrand point evaluations.\n\nFor each method, compute the absolute error\n$$\nE = \\big|I_{\\mathrm{approx}} - I_{\\mathrm{exact}}\\big|\n$$\nand the error-per-work ratio\n$$\n\\rho = \\frac{E}{W},\n$$\nwhere $W$ is the computational work as defined above.\n\nDesign the program to run a test suite of parameter sets that exercise a range of dimensions and smoothness parameters. For each test case, your program must output a bracketed list containing, in order, the tensor-product error-per-work $\\rho_{\\mathrm{TP}}$, the sparse-grid error-per-work $\\rho_{\\mathrm{SG}}$, and a boolean indicating whether the sparse-grid ratio is strictly smaller than the tensor-product ratio. The final program output must be a single line containing a comma-separated list of these per-test-case lists, all enclosed in a single pair of square brackets.\n\nUse the following test suite to ensure coverage of typical behavior, a pure Gaussian boundary condition, and higher-dimensional edge scenarios:\n- Test case $1$: $(d,n,L,\\alpha,\\beta) = (2,10,3,25,0.2)$.\n- Test case $2$: $(d,n,L,\\alpha,\\beta) = (3,8,4,40,0)$.\n- Test case $3$: $(d,n,L,\\alpha,\\beta) = (6,5,8,15,0.05)$.\n- Test case $4$: $(d,n,L,\\alpha,\\beta) = (3,12,5,5,1)$.\n\nIn all computations, angles do not appear; therefore no angle unit is required. There are no physical units; report all numerical quantities as dimensionless real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example\n$$\n[\\,[\\rho_{\\mathrm{TP},1},\\rho_{\\mathrm{SG},1},b_1],\\,[\\rho_{\\mathrm{TP},2},\\rho_{\\mathrm{SG},2},b_2],\\,\\dots\\,],\n$$\nwhere $b_k$ is a boolean for test case $k$, and each $\\rho$ is a real number.",
            "solution": "### Part I: Analytical Derivation of the Exact Integral\n\nThe objective is to compute the integral $I_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\int_{[0,1]^d} \\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$.\nThe integrand is defined as a separable product:\n$$\n\\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{x}) = \\prod_{j=1}^{d} g_{\\alpha,\\beta}(x_j)\n$$\nwhere $\\boldsymbol{x} = (x_1, \\dots, x_d)$ and the one-dimensional component function is given by:\n$$\ng_{\\alpha,\\beta}(t) = \\exp\\!\\big(-\\alpha\\,(t - \\tfrac{1}{2})^2\\big)\\,\\Big(1 + \\beta\\,(t - \\tfrac{1}{2})^2\\Big)\n$$\nfor $t \\in [0,1]$, with parameters $\\alpha  0$ and $\\beta \\ge 0$.\n\nDue to the separability of the integrand and the rectangular domain of integration $[0,1]^d$, Fubini's theorem allows the multi-dimensional integral to be expressed as a product of one-dimensional integrals:\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\int_{0}^{1} \\cdots \\int_{0}^{1} \\prod_{j=1}^{d} g_{\\alpha,\\beta}(x_j) \\,\\mathrm{d}x_1 \\cdots \\mathrm{d}x_d = \\prod_{j=1}^{d} \\left( \\int_{0}^{1} g_{\\alpha,\\beta}(x_j) \\,\\mathrm{d}x_j \\right)\n$$\nSince each one-dimensional integral is identical, we can define $I_1(\\alpha, \\beta) = \\int_{0}^{1} g_{\\alpha,\\beta}(t) \\,\\mathrm{d}t$, and the total integral becomes:\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\left( I_1(\\alpha,\\beta) \\right)^d\n$$\nWe now solve for $I_1(\\alpha, \\beta)$:\n$$\nI_1(\\alpha,\\beta) = \\int_0^1 \\exp\\!\\big(-\\alpha\\,(t - \\tfrac{1}{2})^2\\big)\\,\\Big(1 + \\beta\\,(t - \\tfrac{1}{2})^2\\Big) \\,\\mathrm{d}t\n$$\nLet's perform a change of variables to center the interval at $0$. Let $u = t - \\frac{1}{2}$. Then $\\mathrm{d}u = \\mathrm{d}t$. The integration limits change from $[0,1]$ for $t$ to $[-1/2, 1/2]$ for $u$.\n$$\nI_1(\\alpha,\\beta) = \\int_{-1/2}^{1/2} e^{-\\alpha u^2} (1 + \\beta u^2) \\,\\mathrm{d}u\n$$\nWe can split this into two parts:\n$$\nI_1(\\alpha,\\beta) = \\int_{-1/2}^{1/2} e^{-\\alpha u^2} \\,\\mathrm{d}u + \\beta \\int_{-1/2}^{1/2} u^2 e^{-\\alpha u^2} \\,\\mathrm{d}u\n$$\nLet's evaluate the first term, $I_{1,A} = \\int_{-1/2}^{1/2} e^{-\\alpha u^2} \\,\\mathrm{d}u$. We introduce another substitution, $v = \\sqrt{\\alpha}u$, which implies $\\mathrm{d}u = \\frac{1}{\\sqrt{\\alpha}}\\mathrm{d}v$. The limits for $v$ become $[-\\sqrt{\\alpha}/2, \\sqrt{\\alpha}/2]$.\n$$\nI_{1,A} = \\int_{-\\sqrt{\\alpha}/2}^{\\sqrt{\\alpha}/2} e^{-v^2} \\frac{1}{\\sqrt{\\alpha}} \\,\\mathrm{d}v = \\frac{1}{\\sqrt{\\alpha}} \\int_{-\\sqrt{\\alpha}/2}^{\\sqrt{\\alpha}/2} e^{-v^2} \\,\\mathrm{d}v\n$$\nThe error function, $\\mathrm{erf}(z)$, is defined as $\\mathrm{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,\\mathrm{d}t$. Since $e^{-v^2}$ is an even function, $\\int_{-a}^a e^{-v^2} \\mathrm{d}v = 2\\int_0^a e^{-v^2} \\mathrm{d}v$.\nThus, $\\int_{-\\sqrt{\\alpha}/2}^{\\sqrt{\\alpha}/2} e^{-v^2} \\,\\mathrm{d}v = 2 \\int_0^{\\sqrt{\\alpha}/2} e^{-v^2} \\,\\mathrm{d}v = \\sqrt{\\pi} \\, \\mathrm{erf}(\\frac{\\sqrt{\\alpha}}{2})$.\nSubstituting this back, we get:\n$$\nI_{1,A} = \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right)\n$$\nNext, we evaluate the second term, which is multiplied by $\\beta$. Let this integral be $I' = \\int_{-1/2}^{1/2} u^2 e^{-\\alpha u^2} \\,\\mathrm{d}u$. We use integration by parts, $\\int f(u) g'(u) \\mathrm{d}u = f(u)g(u) - \\int f'(u)g(u) \\mathrm{d}u$.\nLet $f(u) = u$ and $g'(u) = u e^{-\\alpha u^2}$. Then $f'(u) = 1$ and $g(u) = -\\frac{1}{2\\alpha}e^{-\\alpha u^2}$.\n$$\nI' = \\left[ u \\left(-\\frac{1}{2\\alpha}e^{-\\alpha u^2}\\right) \\right]_{-1/2}^{1/2} - \\int_{-1/2}^{1/2} 1 \\cdot \\left(-\\frac{1}{2\\alpha}e^{-\\alpha u^2}\\right) \\mathrm{d}u\n$$\n$$\nI' = \\left[ -\\frac{u}{2\\alpha}e^{-\\alpha u^2} \\right]_{-1/2}^{1/2} + \\frac{1}{2\\alpha} \\int_{-1/2}^{1/2} e^{-\\alpha u^2} \\mathrm{d}u\n$$\nThe first part evaluates to:\n$$\n\\left( -\\frac{1/2}{2\\alpha}e^{-\\alpha (1/2)^2} \\right) - \\left( -\\frac{-1/2}{2\\alpha}e^{-\\alpha (-1/2)^2} \\right) = -\\frac{1}{4\\alpha}e^{-\\alpha/4} - \\frac{1}{4\\alpha}e^{-\\alpha/4} = -\\frac{1}{2\\alpha}e^{-\\alpha/4}\n$$\nThe second part is simply $\\frac{1}{2\\alpha}I_{1,A}$.\n$$\nI' = -\\frac{1}{2\\alpha}e^{-\\alpha/4} + \\frac{1}{2\\alpha} \\left( \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) \\right)\n$$\nNow, we combine the terms to get $I_1(\\alpha, \\beta) = I_{1,A} + \\beta I'$:\n$$\nI_1(\\alpha,\\beta) = \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) + \\beta \\left( -\\frac{1}{2\\alpha}e^{-\\alpha/4} + \\frac{\\sqrt{\\pi}}{2\\alpha\\sqrt{\\alpha}} \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) \\right)\n$$\nGrouping the terms with the error function:\n$$\nI_1(\\alpha,\\beta) = \\left( \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} + \\frac{\\beta\\sqrt{\\pi}}{2\\alpha\\sqrt{\\alpha}} \\right) \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) - \\frac{\\beta}{2\\alpha}e^{-\\alpha/4}\n$$\nFactoring out common terms yields the final expression for the one-dimensional integral:\n$$\nI_1(\\alpha,\\beta) = \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\left( 1 + \\frac{\\beta}{2\\alpha} \\right) \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) - \\frac{\\beta}{2\\alpha}e^{-\\alpha/4}\n$$\nFinally, the exact value of the $d$-dimensional integral is:\n$$\nI_{\\mathrm{exact}}(d,\\alpha,\\beta) = \\left( \\frac{\\sqrt{\\pi}}{\\sqrt{\\alpha}} \\left( 1 + \\frac{\\beta}{2\\alpha} \\right) \\mathrm{erf}\\left(\\frac{\\sqrt{\\alpha}}{2}\\right) - \\frac{\\beta}{2\\alpha}e^{-\\alpha/4} \\right)^d\n$$\n\n### Part II: Numerical Quadrature Schemes\n\nWe implement two numerical methods to approximate the integral $I_{\\mathrm{exact}}$.\n\n**1. Tensor-Product Gaussian-Legendre (TP-GL) Quadrature**\nThis method constructs a $d$-dimensional quadrature rule by taking the tensor product of a one-dimensional rule. We use an $n$-point Gaussian-Legendre (GL) rule in each dimension. The standard GL nodes $x_i$ and weights $w_i$ are defined on the interval $[-1,1]$. To use them on $[0,1]$, we apply a linear transformation $t = \\frac{1}{2}(x+1)$, where $x \\in [-1,1]$ and $t \\in [0,1]$. An integral transforms as $\\int_0^1 f(t)\\mathrm{d}t = \\int_{-1}^1 f(\\frac{x+1}{2}) \\frac{1}{2}\\mathrm{d}x$. The new nodes $t_i$ and weights $w'_i$ on $[0,1]$ are:\n$$\nt_i = \\frac{1}{2}(x_i+1), \\quad w'_i = \\frac{1}{2}w_i\n$$\nThe one-dimensional integral is approximated as $I_{1,\\mathrm{approx}} = \\sum_{i=1}^n w'_i g_{\\alpha,\\beta}(t_i)$. Due to the separability of the integrand, the $d$-dimensional tensor-product approximation is simply the product of the one-dimensional approximations:\n$$\nI_{\\mathrm{TP}} = \\left( \\sum_{i=1}^n w'_i g_{\\alpha,\\beta}(t_i) \\right)^d\n$$\nThe computational work, $W_{\\mathrm{TP}}$, is the total number of integrand evaluations, which is $n^d$ for a full tensor-product grid.\n\n**2. Sparse-Grid (SG) Quadrature**\nSparse grids are a technique to mitigate the curse of dimensionality, which makes full tensor-product methods intractable in high dimensions. The Smolyak construction combines results from different tensor-product rules built on one-dimensional quadratures of varying accuracy levels.\n\nFollowing the problem, we use one-dimensional GL rules $Q^{(k)}$ at level $k$, where $Q^{(k)}$ has $n_k = 2k-1$ points. The sparse-grid operator $\\mathcal{A}(L,d)$ of level $L$ in $d$ dimensions is built from difference operators $\\Delta^{(k)} = Q^{(k)} - Q^{(k-1)}$ (with $Q^{(0)}$ being the null operator):\n$$\n\\mathcal{A}(L,d) = \\sum_{s=d}^{L}\\,\\sum_{\\substack{i_1+\\cdots+i_d=s\\\\ i_j \\ge 1}}\\,\\bigotimes_{j=1}^{d} \\Delta^{(i_j)}\n$$\nThe integral approximation is $I_{\\mathrm{SG}} = \\mathcal{A}(L,d)[\\phi_{\\alpha,\\beta}^{(d)}]$. Numerically, this sum is evaluated by building a single set of unique quadrature points and corresponding combined weights. For each multi-index $\\boldsymbol{i}=(i_1, \\dots, i_d)$ satisfying the sum condition, we consider the tensor product of the difference rules $\\Delta^{(i_j)}$. Each $\\Delta^{(i_j)}$ represents a set of points from $Q^{(i_j)}$ with positive weights and points from $Q^{(i_j-1)}$ with negative weights. We form all tensor products of these points and multiply their weights. The resulting point-weight pairs are aggregated across all multi-indices $\\boldsymbol{i}$. Duplicate points are merged by summing their weights.\n\nThe computational work, $W_{\\mathrm{SG}}$, is defined as the total number of unique points in the final aggregated set. The integral approximation is then computed by summing the product of the integrand evaluated at each unique point and its final combined weight:\n$$\nI_{\\mathrm{SG}} = \\sum_{(\\boldsymbol{p}, w) \\in \\text{UniquePoints}} w \\cdot \\phi_{\\alpha,\\beta}^{(d)}(\\boldsymbol{p})\n$$\n\n### Part III: Error Analysis and Comparison\n\nFor each method (TP and SG), we calculate the absolute error $E = |I_{\\mathrm{approx}} - I_{\\mathrm{exact}}|$ and the error-per-work ratio $\\rho = E/W$. This ratio serves as a measure of computational efficiency, balancing accuracy against the number of function evaluations. The program will compute $\\rho_{\\mathrm{TP}} = E_{\\mathrm{TP}}/W_{\\mathrm{TP}}$ and $\\rho_{\\mathrm{SG}} = E_{\\mathrm{SG}}/W_{\\mathrm{SG}}$ for each test case and determine if the sparse-grid method is more efficient ($\\rho_{\\mathrm{SG}}  \\rho_{\\mathrm{TP}}$).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, erf\nfrom math import sqrt, pi, exp\nfrom itertools import product as itertools_product\n\ndef solve():\n    \"\"\"\n    Main solver function that runs test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (d, n, L, alpha, beta)\n        (2, 10, 3, 25, 0.2),\n        (3, 8, 4, 40, 0),\n        (6, 5, 8, 15, 0.05),\n        (3, 12, 5, 5, 1),\n    ]\n\n    results = []\n    # Caching for 1D quadrature rules to avoid recomputation\n    memo_1d_rules = {}\n\n    for d, n, L, alpha, beta in test_cases:\n        # Calculate exact integral\n        I_exact = calculate_I_exact(d, alpha, beta)\n\n        # 1. Tensor-Product Quadrature\n        I_tp, W_tp = calculate_I_tp(d, n, alpha, beta, memo_1d_rules)\n        E_tp = abs(I_tp - I_exact)\n        rho_tp = E_tp / W_tp if W_tp > 0 else float('inf')\n\n        # 2. Sparse-Grid Quadrature\n        I_sg, W_sg = calculate_I_sg(d, L, alpha, beta, memo_1d_rules)\n        E_sg = abs(I_sg - I_exact)\n        rho_sg = E_sg / W_sg if W_sg > 0 else float('inf')\n\n        results.append([rho_tp, rho_sg, str(rho_sg  rho_tp).lower()])\n\n    # Format output as specified: [[r1,r2,bool],[...],...]\n    inner_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_string = f\"[{','.join(inner_results)}]\"\n    print(final_string)\n\ndef g_func(t, alpha, beta):\n    \"\"\"The 1D component of the integrand.\"\"\"\n    term = t - 0.5\n    term_sq = term * term\n    return exp(-alpha * term_sq) * (1.0 + beta * term_sq)\n\ndef phi_func(x_vec, alpha, beta):\n    \"\"\"The d-dimensional integrand.\"\"\"\n    val = 1.0\n    for x_j in x_vec:\n        val *= g_func(x_j, alpha, beta)\n    return val\n\ndef calculate_I_exact(d, alpha, beta):\n    \"\"\"Computes the analytical value of the integral.\"\"\"\n    sqrt_alpha = sqrt(alpha)\n    erf_term = erf(sqrt_alpha / 2.0)\n    \n    # Value for beta = 0\n    if beta == 0:\n        I_1 = (sqrt(pi) / sqrt_alpha) * erf_term\n    else:\n        exp_term = exp(-alpha / 4.0)\n        term1 = (sqrt(pi) / sqrt_alpha) * (1.0 + beta / (2.0 * alpha)) * erf_term\n        term2 = beta / (2.0 * alpha) * exp_term\n        I_1 = term1 - term2\n        \n    return I_1 ** d\n\ndef get_scaled_gl_rule(num_points, memo):\n    \"\"\"\n    Computes or retrieves from cache the scaled Gauss-Legendre rule for [0,1].\n    \"\"\"\n    if num_points in memo:\n        return memo[num_points]\n    \n    if num_points == 0:\n        return np.array([]), np.array([])\n\n    nodes, weights = roots_legendre(num_points)\n    \n    # Scale nodes from [-1, 1] to [0, 1]\n    scaled_nodes = 0.5 * (nodes + 1.0)\n    # Scale weights for the interval transformation\n    scaled_weights = 0.5 * weights\n    \n    memo[num_points] = (scaled_nodes, scaled_weights)\n    return scaled_nodes, scaled_weights\n\ndef calculate_I_tp(d, n, alpha, beta, memo_1d_rules):\n    \"\"\"Computes the integral using tensor-product Gaussian-Legendre quadrature.\"\"\"\n    nodes, weights = get_scaled_gl_rule(n, memo_1d_rules)\n    \n    # 1D integral approximation\n    I_1_approx = sum(w * g_func(x, alpha, beta) for x, w in zip(nodes, weights))\n    \n    # Full integral is the 1D integral to the power of d due to separability\n    I_approx = I_1_approx ** d\n    \n    # Work is the total number of evaluation points\n    work = n ** d\n    \n    return I_approx, work\n\ndef get_partitions(n, k, min_val=1):\n    \"\"\"Generator for ordered integer partitions.\"\"\"\n    if k == 1:\n        if n >= min_val:\n            yield (n,)\n        return\n    \n    for i in range(min_val, n - (k - 1) * min_val + 1):\n        for rest in get_partitions(n - i, k - 1, min_val):\n            yield (i,) + rest\n\ndef calculate_I_sg(d, L, alpha, beta, memo_1d_rules):\n    \"\"\"Computes the integral using Smolyak sparse-grid quadrature.\"\"\"\n    unique_points = {}\n    \n    memo_delta_rules = {}\n\n    def get_delta_rule(k):\n        if k in memo_delta_rules:\n            return memo_delta_rules[k]\n        \n        if k == 1:\n            nodes1, weights1 = get_scaled_gl_rule(1, memo_1d_rules)\n            rule = list(zip(nodes1, weights1))\n            memo_delta_rules[k] = rule\n            return rule\n        \n        # Q^(k)\n        nodes_pos, weights_pos = get_scaled_gl_rule(2 * k - 1, memo_1d_rules)\n        # Q^(k-1)\n        nodes_neg, weights_neg = get_scaled_gl_rule(2 * (k - 1) - 1, memo_1d_rules)\n        \n        rule = list(zip(nodes_pos, weights_pos)) + list(zip(nodes_neg, -weights_neg))\n        memo_delta_rules[k] = rule\n        return rule\n\n    for s in range(d, L + 1):\n        for i_vec in get_partitions(s, d):\n            \n            delta_rules_for_tensor_prod = [get_delta_rule(ik) for ik in i_vec]\n            \n            for combo in itertools_product(*delta_rules_for_tensor_prod):\n                point = tuple(c[0] for c in combo)\n                weight = 1.0\n                for c in combo:\n                    weight *= c[1]\n                \n                unique_points[point] = unique_points.get(point, 0.0) + weight\n\n    # Calculate integral from unique points and summed weights\n    I_approx = 0.0\n    for point, weight in unique_points.items():\n        if abs(weight) > 1e-15: # Ignore points with negligible weights\n            I_approx += weight * phi_func(point, alpha, beta)\n\n    # Work is the number of unique points with non-zero weights\n    work = len([w for w in unique_points.values() if abs(w) > 1e-15])\n    \n    return I_approx, work\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}