{
    "hands_on_practices": [
        {
            "introduction": "Understanding complex numerical methods begins with mastering the underlying analytical models. This exercise tasks you with solving the one-speed neutron diffusion equation for a bare homogeneous slab, a classic benchmark in reactor physics. By equating the material buckling, which describes the neutron-multiplying properties of the medium, with the geometric buckling, dictated by the reactor's size and boundary conditions, you will derive the analytical expression for the effective multiplication factor, $k_{\\text{eff}}$ . This practice provides a crucial physical intuition for criticality and serves as the \"ground truth\" for validating numerical solvers.",
            "id": "4232366",
            "problem": "Consider a bare, homogeneous, one-speed reactor described by the steady-state neutron diffusion approximation. The unknown scalar neutron flux is $\\phi(\\mathbf{r})$, the diffusion coefficient is $D$, the macroscopic absorption cross section is $\\Sigma_{a}$, and the average number of neutrons produced per fission times the macroscopic fission cross section is $\\nu \\Sigma_{f}$. In the $k$-eigenvalue formulation, the balance equation for the fundamental mode may be written as\n$$\n- D \\nabla^{2} \\phi(\\mathbf{r}) + \\Sigma_{a} \\phi(\\mathbf{r}) = \\frac{\\nu \\Sigma_{f}}{k} \\, \\phi(\\mathbf{r}) \\, ,\n$$\nwith vacuum boundary conditions imposed via an extrapolated boundary where $\\phi$ is zero. The reactor is a one-dimensional slab of physical thickness $L$ centered at $x=0$, with extrapolated boundary located at $x=\\pm L_{e}/2$, where $L_{e} = L + 2 z_{\\mathrm{ex}}$ and the extrapolation distance is $z_{\\mathrm{ex}} = 2.131 \\, D$.\n\nStarting from the diffusion approximation and the concept of spatial buckling, derive the $k$-eigenvalue condition by relating the material buckling to the geometric buckling of the slab and connect this with the fixed-point character of Fission Source Iteration (FSI), defined as repeated fixed-source solves in which the fission source $S^{(n)}(\\mathbf{r})$ at iteration $n$ is $S^{(n)}(\\mathbf{r}) = \\left(\\nu \\Sigma_{f} / k^{(n)}\\right) \\phi^{(n)}(\\mathbf{r})$. Assume the fundamental geometric mode satisfies the vacuum boundary condition and use this mode to evaluate the implied eigenvalue.\n\nFor a homogeneous bare slab with the following properties:\n- $L = 100\\,\\mathrm{cm}$,\n- $D = 1.2\\,\\mathrm{cm}$,\n- $\\Sigma_{a} = 0.010\\,\\mathrm{cm}^{-1}$,\n- $\\nu \\Sigma_{f} = 0.011\\,\\mathrm{cm}^{-1}$,\n\ncompute the resulting effective multiplication factor $k_{\\mathrm{eff}}$ (define $k_{\\mathrm{eff}}$ as the dominant eigenvalue of the diffusion $k$-eigenvalue problem). Express your final answer as a dimensionless scalar and round your answer to four significant figures.",
            "solution": "The problem is valid. It is a standard, well-posed problem in introductory nuclear reactor physics, based on the one-group neutron diffusion model. All necessary parameters and conditions are provided, and the problem is scientifically sound. We can therefore proceed with the solution.\n\nThe starting point is the steady-state, one-speed neutron diffusion equation in its $k$-eigenvalue form:\n$$\n- D \\nabla^{2} \\phi(\\mathbf{r}) + \\Sigma_{a} \\phi(\\mathbf{r}) = \\frac{1}{k} \\nu \\Sigma_{f} \\phi(\\mathbf{r})\n$$\nwhere $\\phi(\\mathbf{r})$ is the neutron flux, $D$ is the diffusion coefficient, $\\Sigma_{a}$ is the macroscopic absorption cross section, and $\\nu \\Sigma_{f}$ is the neutron production cross section term. The parameter $k$ is the eigenvalue, and for the fundamental mode, it is the effective multiplication factor, $k_{\\mathrm{eff}}$.\n\nWe can rearrange the equation to resemble the Helmholtz equation. For a homogeneous medium, the material properties $D$, $\\Sigma_{a}$, and $\\nu\\Sigma_f$ are constant.\n$$\n- D \\nabla^{2} \\phi(\\mathbf{r}) = \\left(\\frac{\\nu \\Sigma_{f}}{k} - \\Sigma_{a}\\right) \\phi(\\mathbf{r})\n$$\nDividing by $D$ gives:\n$$\n\\nabla^{2} \\phi(\\mathbf{r}) + \\frac{1}{D}\\left(\\frac{\\nu \\Sigma_{f}}{k} - \\Sigma_{a}\\right) \\phi(\\mathbf{r}) = 0\n$$\nThis equation is of the form $\\nabla^{2} \\phi(\\mathbf{r}) + B^2 \\phi(\\mathbf{r}) = 0$, where $B^2$ is the total buckling of the system. For a solution to exist, the buckling must satisfy two independent definitions.\n\nFirst, the **material buckling**, $B_m^2$, is a property of the material composition. It describes the intrinsic balance of neutron production and absorption in an infinite medium. For a system with a multiplication factor $k$, the buckling is given by the term multiplying the flux:\n$$\nB^2 = \\frac{\\nu \\Sigma_{f}/k - \\Sigma_{a}}{D}\n$$\nSecond, the **geometric buckling**, $B_g^2$, is determined by the geometry of the reactor and the boundary conditions. It represents the curvature of the flux profile required to satisfy the boundary conditions and is an eigenvalue of the equation $\\nabla^{2} \\phi + B_g^2 \\phi = 0$.\n\nFor the given one-dimensional slab centered at $x=0$, the operator $\\nabla^2$ becomes $\\frac{d^2}{dx^2}$. The equation for the geometric buckling is:\n$$\n\\frac{d^2\\phi(x)}{dx^2} + B_g^2 \\phi(x) = 0\n$$\nThe general solution is $\\phi(x) = C_1 \\cos(B_g x) + C_2 \\sin(B_g x)$. For the fundamental mode in a symmetric domain, the solution must be symmetric, so we require $C_2 = 0$. This leaves $\\phi(x) = C_1 \\cos(B_g x)$. The vacuum boundary condition is imposed by setting the flux to zero at the extrapolated boundaries, $x = \\pm L_e/2$. Applying this condition:\n$$\n\\phi(\\pm L_e/2) = C_1 \\cos(B_g L_e/2) = 0\n$$\nFor a non-trivial solution ($C_1 \\neq 0$), the argument of the cosine must be an odd integer multiple of $\\pi/2$. The fundamental mode corresponds to the smallest positive value of $B_g$, so we take:\n$$\nB_g \\frac{L_e}{2} = \\frac{\\pi}{2} \\implies B_g = \\frac{\\pi}{L_e}\n$$\nThus, the geometric buckling for the fundamental mode is:\n$$\nB_g^2 = \\left(\\frac{\\pi}{L_e}\\right)^2\n$$\nFor a steady-state critical reactor, the material properties must support the flux shape dictated by the geometry. This requires equating the bucklings, which leads to the critical condition. We set $B^2 = B_g^2$ and solve for the eigenvalue $k$, which we denote as $k_{\\mathrm{eff}}$:\n$$\n\\frac{\\nu \\Sigma_{f}/k_{\\mathrm{eff}} - \\Sigma_{a}}{D} = B_g^2\n$$\nSolving for $k_{\\mathrm{eff}}$:\n$$\n\\frac{\\nu \\Sigma_{f}}{k_{\\mathrm{eff}}} = \\Sigma_{a} + D B_g^2\n$$\n$$\nk_{\\mathrm{eff}} = \\frac{\\nu \\Sigma_{f}}{\\Sigma_{a} + D B_g^2}\n$$\nThis result is physically intuitive: $k_{\\mathrm{eff}}$ is the ratio of the rate of neutron production ($\\nu \\Sigma_f \\phi$) to the rate of neutron loss. The loss term in the denominator consists of absorption ($\\Sigma_a \\phi$) and leakage, which is represented by the term $D B_g^2 \\phi$.\n\nThe Fission Source Iteration (FSI) is a numerical power iteration method used to find the dominant eigenvalue, $k_{\\mathrm{eff}}$, and its corresponding eigenfunction (the fundamental flux mode). The iteration proceeds as $L\\phi^{(n+1)} = \\frac{1}{k^{(n)}} S^{(n)}$, where $L$ is the diffusion-absorption operator and $S^{(n)} = \\nu \\Sigma_f \\phi^{(n)}$ is the fission source. At convergence, the flux shape is stationary ($\\phi^{(n+1)} \\propto \\phi^{(n)}$), which is a fixed point of the iteration operator. The fundamental mode flux, $\\phi(x) = C_1 \\cos(B_g x)$, is an eigenfunction of the diffusion operator. When the fission source is proportional to this mode, the resulting flux from the fixed-source solve will have the same spatial shape. The eigenvalue $k_{\\mathrm{eff}}$ is precisely the factor that ensures this self-consistency, balancing production and loss for this specific spatial mode. Our derived analytical formula for $k_{\\mathrm{eff}}$ is the exact value to which the FSI method converges for this problem.\n\nNow, we compute the numerical value for $k_{\\mathrm{eff}}$ using the provided data:\n- Physical thickness: $L = 100\\,\\mathrm{cm}$\n- Diffusion coefficient: $D = 1.2\\,\\mathrm{cm}$\n- Macroscopic absorption cross section: $\\Sigma_{a} = 0.010\\,\\mathrm{cm}^{-1}$\n- Neutron production term: $\\nu \\Sigma_{f} = 0.011\\,\\mathrm{cm}^{-1}$\n\nFirst, we calculate the extrapolation distance, $z_{\\mathrm{ex}}$:\n$$\nz_{\\mathrm{ex}} = 2.131 \\, D = 2.131 \\times 1.2\\,\\mathrm{cm} = 2.5572\\,\\mathrm{cm}\n$$\nNext, we find the extrapolated thickness, $L_e$:\n$$\nL_e = L + 2 z_{\\mathrm{ex}} = 100\\,\\mathrm{cm} + 2 \\times 2.5572\\,\\mathrm{cm} = 105.1144\\,\\mathrm{cm}\n$$\nWith $L_e$, we can compute the geometric buckling, $B_g^2$:\n$$\nB_g^2 = \\left(\\frac{\\pi}{L_e}\\right)^2 = \\left(\\frac{\\pi}{105.1144\\,\\mathrm{cm}}\\right)^2 \\approx 0.000893316\\,\\mathrm{cm}^{-2}\n$$\nNow, we can compute the total loss term in the denominator of the expression for $k_{\\mathrm{eff}}$:\n$$\n\\Sigma_{a} + D B_g^2 = 0.010\\,\\mathrm{cm}^{-1} + (1.2\\,\\mathrm{cm}) \\times (0.000893316\\,\\mathrm{cm}^{-2})\n$$\n$$\n\\Sigma_{a} + D B_g^2 = 0.010\\,\\mathrm{cm}^{-1} + 0.001071979\\,\\mathrm{cm}^{-1} = 0.011071979\\,\\mathrm{cm}^{-1}\n$$\nFinally, we calculate $k_{\\mathrm{eff}}$:\n$$\nk_{\\mathrm{eff}} = \\frac{\\nu \\Sigma_{f}}{\\Sigma_{a} + D B_g^2} = \\frac{0.011\\,\\mathrm{cm}^{-1}}{0.011071979\\,\\mathrm{cm}^{-1}} \\approx 0.99350005\n$$\nRounding the result to four significant figures as requested gives $0.9935$.",
            "answer": "$$\n\\boxed{0.9935}\n$$"
        },
        {
            "introduction": "After discretization, the continuous neutron transport problem transforms into a matrix eigenvalue problem, which we solve using Fission Source Iteration (FSI). This exercise abstracts the process, allowing you to implement the FSI algorithm—mathematically equivalent to the power method—on a given system matrix . By exploring the effects of different initial source guesses and positivity enforcement schemes, you will gain direct insight into the numerical behavior and robustness of the iterative solver, a fundamental tool in reactor analysis.",
            "id": "4232373",
            "problem": "Consider the steady-state neutron balance problem in a homogeneous reactor that has been discretized into a finite-dimensional linear mapping from a non-negative fission source to its next-generation fission source. Starting from the linear Boltzmann transport equation in the multiplication formulation, the discretization yields a non-negative linear operator that maps a fission source to the next-generation fission source. Define the combined one-generation mapping as a square matrix $\\mathbf{H} \\in \\mathbb{R}^{n \\times n}$ with non-negative entries, representing the composition of neutron transport, scattering, and fission emission processes in a discrete multi-region, multi-energy state vector. The $k$-eigenvalue problem seeks the dominant eigenpair $(k, \\mathbf{s})$ with $k > 0$ and $\\mathbf{s} \\ge 0$ such that $\\mathbf{H} \\mathbf{s} = k \\mathbf{s}$, where $\\mathbf{s}$ is a non-negative fission source vector. The combined operator is assumed irreducible, ensuring the existence of a unique dominant eigenvalue and a strictly positive eigenvector by the Perron–Frobenius theorem.\n\nImplement a fission source iteration that, given $\\mathbf{H}$, an initial guess $\\mathbf{s}^{(0)}$, and a positivity enforcement policy $\\mathcal{P}$, updates the fission source and the estimated multiplication factor. The core iteration is as follows: apply the mapping to obtain a raw propagated vector, optionally enforce positivity with $\\mathcal{P}$, form an updated eigenvalue estimate based on an induced vector norm, and renormalize the fission source to a fixed norm to prevent numerical overflow or underflow. Continue until convergence in the eigenvalue estimate.\n\nYou must construct a complete program that:\n- Uses the given operator $\\mathbf{H}$ with $n = 4$ and entries\n  $\\mathbf{H} = \\begin{bmatrix}\n  0.35 & 0.20 & 0.30 & 0.10 \\\\\n  0.20 & 0.40 & 0.10 & 0.15 \\\\\n  0.25 & 0.15 & 0.45 & 0.20 \\\\\n  0.10 & 0.15 & 0.15 & 0.50\n  \\end{bmatrix}$.\n- Accepts, for each test case, an initial fission source vector $\\mathbf{s}^{(0)} \\in \\mathbb{R}^4$ and a positivity enforcement policy $\\mathcal{P}$ from the following set:\n  1. $\\mathcal{P} = \\text{none}$: no positivity enforcement; the raw propagated vector is used as-is.\n  2. $\\mathcal{P} = \\text{clip\\_zero}$: replace negative components by $0$.\n  3. $\\mathcal{P} = \\text{abs}$: replace the propagated vector by its component-wise absolute value.\n- Uses the $\\ell_1$-norm to estimate the eigenvalue at iteration $m$ by $k^{(m+1)} = \\|\\mathbf{y}^{(m)}\\|_1 / \\|\\mathbf{s}^{(m)}\\|_1$, where $\\mathbf{y}^{(m)}$ is the propagated vector before renormalization, and renormalizes $\\mathbf{s}^{(m+1)} = \\mathbf{y}^{(m)} / \\|\\mathbf{y}^{(m)}\\|_1$.\n- Detects whether any negative entries occur in the raw propagated vector $\\mathbf{y}^{(m)}$ at any iteration prior to applying $\\mathcal{P}$.\n- Stops when the relative change in $k$ satisfies $|k^{(m+1)} - k^{(m)}| / \\max(k^{(m)}, 1) < 10^{-10}$ or when a maximum number of iterations $5000$ is reached.\n- Uses a small strictly positive perturbation $\\varepsilon = 10^{-14}$ only when needed to avoid a zero vector during normalization.\n- Produces the results for each test case as a pair $[k, \\text{flag}]$, where $k$ is the converged multiplication factor rounded to $8$ decimal places, and $\\text{flag}$ is a boolean indicating whether any negative entries appeared in the raw propagated vector at any iteration (before positivity enforcement). The program must output the list of results for all test cases in a single line, as a comma-separated list enclosed in square brackets, with each pair enclosed in square brackets.\n\nYour program must implement the above iteration and run on the following test suite:\n- Test case $1$ (happy path): $\\mathbf{s}^{(0)} = [0.25, 0.25, 0.25, 0.25]$ and $\\mathcal{P} = \\text{none}$.\n- Test case $2$ (sign-deficient initial guess): $\\mathbf{s}^{(0)} = [1.0, -0.5, 0.3, -0.8]$ and $\\mathcal{P} = \\text{none}$.\n- Test case $3$ (positivity enforcement by clipping): $\\mathbf{s}^{(0)} = [1.0, -0.5, 0.3, -0.8]$ and $\\mathcal{P} = \\text{clip\\_zero}$.\n- Test case $4$ (boundary case with zero initial vector): $\\mathbf{s}^{(0)} = [0.0, 0.0, 0.0, 0.0]$ and $\\mathcal{P} = \\text{clip\\_zero}$.\n\nThere are no physical units involved in this computation. Angles are not used. Percentages are not used. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a pair $[k,\\text{flag}]$ obtained as specified (e.g., $[[1.01234567,True],[\\dots]]$).",
            "solution": "The problem presented is valid. It is a well-posed numerical problem grounded in the established principles of nuclear reactor physics and numerical linear algebra. It is self-contained, objective, and provides all necessary data and constraints for a unique solution to be algorithmically determined.\n\nThe problem asks for the implementation of the fission source iteration method, which is mathematically equivalent to the power iteration algorithm, to find the dominant eigenvalue of a given matrix $\\mathbf{H}$. This dominant eigenvalue is denoted by $k$ and represents the effective neutron multiplication factor in a simplified, discretized model of a nuclear reactor.\n\nThe governing equation is the steady-state $k$-eigenvalue problem:\n$$\n\\mathbf{H} \\mathbf{s} = k \\mathbf{s}\n$$\nHere, $\\mathbf{s}$ is the eigenvector representing the spatial and energetic distribution of the fission source, and $k$ is the corresponding eigenvalue. In reactor physics, a critical system is characterized by $k=1$. The matrix $\\mathbf{H} \\in \\mathbb{R}^{n \\times n}$ is a linear operator that maps a fission source distribution from one generation to the next. It is given as:\n$$\n\\mathbf{H} = \\begin{bmatrix}\n0.35 & 0.20 & 0.30 & 0.10 \\\\\n0.20 & 0.40 & 0.10 & 0.15 \\\\\n0.25 & 0.15 & 0.45 & 0.20 \\\\\n0.10 & 0.15 & 0.15 & 0.50\n\\end{bmatrix}\n$$\nThe problem states that $\\mathbf{H}$ is non-negative and irreducible. Indeed, all entries of the given $\\mathbf{H}$ are strictly positive, $H_{ij} > 0$, which is a stronger condition known as primitivity. The Perron-Frobenius theorem for primitive matrices guarantees that there exists a unique eigenvalue $k$ that is real, positive, and strictly greater in magnitude than all other eigenvalues. This is the dominant eigenvalue, or $k$-eigenvalue. The corresponding eigenvector $\\mathbf{s}$ can be chosen to have all strictly positive components, $\\mathbf{s} > 0$.\n\nThe fission source iteration algorithm is a numerical method to find this dominant eigenpair $(k, \\mathbf{s})$. It is an iterative process defined as follows, starting from an initial guess $\\mathbf{s}^{(0)}$ and an initial eigenvalue estimate $k^{(0)}$. For iteration $m = 0, 1, 2, \\dots$:\n\n1.  **Source Propagation**: A raw next-generation source vector, which I will denote $\\mathbf{y'}^{(m)}$, is computed by applying the operator $\\mathbf{H}$ to the current source vector $\\mathbf{s}^{(m)}$:\n    $$\n    \\mathbf{y'}^{(m)} = \\mathbf{H} \\mathbf{s}^{(m)}\n    $$\n\n2.  **Positivity Enforcement**: An optional positivity policy $\\mathcal{P}$ is applied to the raw vector $\\mathbf{y'}^{(m)}$ to produce the processed vector $\\mathbf{y}^{(m)}$. The policies are:\n    -   $\\mathcal{P} = \\text{none}$: $\\mathbf{y}^{(m)} = \\mathbf{y'}^{(m)}$.\n    -   $\\mathcal{P} = \\text{clip\\_zero}$: $y_i^{(m)} = \\max(0, y'_i^{(m)})$.\n    -   $\\mathcal{P} = \\text{abs}$: $y_i^{(m)} = |y'_i^{(m)}|$.\n\n3.  **Eigenvalue Estimation**: The eigenvalue for the next step, $k^{(m+1)}$, is estimated using the ratio of the $\\ell_1$-norms of the resulting source $\\mathbf{y}^{(m)}$ and the previous source $\\mathbf{s}^{(m)}$:\n    $$\n    k^{(m+1)} = \\frac{\\|\\mathbf{y}^{(m)}\\|_1}{\\|\\mathbf{s}^{(m)}\\|_1}\n    $$\n    where $\\|\\mathbf{v}\\|_1 = \\sum_i |v_i|$. Special handling is required if $\\|\\mathbf{s}^{(m)}\\|_1 = 0$, in which case a default value of $k^{(m+1)}=1.0$ is a reasonable choice, as this only occurs for a zero initial vector.\n\n4.  **Source Renormalization**: The source vector is renormalized to have a unit $\\ell_1$-norm for the subsequent iteration. This step is crucial for numerical stability.\n    $$\n    \\mathbf{s}^{(m+1)} = \\frac{\\mathbf{y}^{(m)}}{\\|\\mathbf{y}^{(m)}\\|_1}\n    $$\n    If $\\mathbf{y}^{(m)}$ is a zero vector, its norm is $0$, leading to a division-by-zero error. In this specific scenario, as per the problem, the vector $\\mathbf{y}^{(m)}$ must be replaced by a small perturbation vector before normalization. A vector with all components equal to $\\varepsilon = 10^{-14}$ is used.\n\nThe iteration proceeds until the relative change in the eigenvalue estimate falls below a specified tolerance of $10^{-10}$, i.e., $|k^{(m+1)} - k^{(m)}| / \\max(k^{(m)}, 1) < 10^{-10}$, or until a maximum of $5000$ iterations is reached.\n\nThroughout the process, a boolean flag must track whether any raw propagated vector $\\mathbf{y'}^{(m)}$ contains negative entries at any point. This is important because while the physical fission source must be non-negative, intermediate numerical estimates, particularly with a mixed-sign initial guess $\\mathbf{s}^{(0)}$, may contain negative values.\n\nThe implementation will follow this algorithm for each of the four specified test cases, combining the matrix operations with the logic for positivity policies, convergence checks, and edge-case handling for zero vectors. The final converged eigenvalue $k$ is to be rounded to $8$ decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the fission source iteration to find the k-eigenvalue\n    for a given matrix H and a set of test cases.\n    \"\"\"\n    H = np.array([\n        [0.35, 0.20, 0.30, 0.10],\n        [0.20, 0.40, 0.10, 0.15],\n        [0.25, 0.15, 0.45, 0.20],\n        [0.10, 0.15, 0.15, 0.50]\n    ], dtype=float)\n\n    test_cases = [\n        ([0.25, 0.25, 0.25, 0.25], 'none'),\n        ([1.0, -0.5, 0.3, -0.8], 'none'),\n        ([1.0, -0.5, 0.3, -0.8], 'clip_zero'),\n        ([0.0, 0.0, 0.0, 0.0], 'clip_zero'),\n    ]\n\n    results = []\n    max_iter = 5000\n    tol = 1.0e-10\n    eps = 1.0e-14\n\n    for s0_list, policy in test_cases:\n        s = np.array(s0_list, dtype=float)\n        k_old = 1.0\n        neg_flag = False\n        k_new = 0.0\n\n        for m in range(max_iter):\n            s_norm = np.linalg.norm(s, 1)\n\n            # Step 1: Source Propagation\n            y_raw = H @ s\n\n            # Step 2: Negative Entry Detection\n            if np.any(y_raw < 0):\n                neg_flag = True\n\n            # Step 3: Positivity Enforcement\n            if policy == 'clip_zero':\n                y = np.maximum(0, y_raw)\n            elif policy == 'abs':\n                y = np.abs(y_raw)\n            else:  # 'none'\n                y = y_raw\n\n            y_norm = np.linalg.norm(y, 1)\n\n            # Step 4: Eigenvalue Estimation\n            if s_norm > 0:\n                k_new = y_norm / s_norm\n            else:\n                # This case only happens for a zero initial vector s0.\n                # k is undefined, so we use a default value for the first step.\n                k_new = 1.0\n\n            # Step 5: Convergence Check\n            # We start checking from the second iteration (m > 0).\n            if m > 0:\n                if abs(k_new - k_old) / max(k_old, 1.0) < tol:\n                    break\n            \n            # Step 6: Source Renormalization (prepare for next iteration)\n            if y_norm == 0:\n                # Avoid division by zero by using a perturbation vector.\n                y = np.full(s.shape, eps, dtype=float)\n                y_norm = np.linalg.norm(y, 1)\n            \n            s = y / y_norm\n            k_old = k_new\n        \n        # If loop finished due to max_iter, k_new holds the last value.\n        final_k = k_new\n        results.append(f\"[{round(final_k, 8)},{neg_flag}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This capstone exercise synthesizes your analytical and numerical skills by guiding you through the construction of a complete 1D diffusion solver from first principles. You will discretize the diffusion equation using the finite difference method, assemble the discrete operators, and implement the Fission Source Iteration algorithm you previously practiced to find the fundamental eigenvalue, $k_{\\text{num}}$ . Critically, you will then validate your numerical result against the analytical benchmark, a standard industry practice that builds confidence in the correctness of your computational model.",
            "id": "4232377",
            "problem": "You are tasked with constructing a complete and runnable program that estimates the effective neutron multiplication factor using the k-eigenvalue formulation via fission source iteration and validates the numerical result against an analytical benchmark. The focus is a one-speed, one-dimensional homogeneous slab of length $L$ with vacuum boundary conditions at both ends. Your program must assemble the discrete operators from first principles, iterate to convergence of the fundamental k-eigenvalue, and report validation metrics across a small test suite.\n\nBegin from the steady-state neutron balance in diffusion theory and its constitutive relations: the particle balance equates leakage and absorption to induced fission production scaled by the effective multiplication factor, and the neutron current is proportional to the gradient of scalar flux. In a homogeneous medium with diffusion coefficient $D$, macroscopic absorption cross section $\\Sigma_a$ in units of $\\mathrm{cm}^{-1}$, and macroscopic production cross section $\\nu\\Sigma_f$ in units of $\\mathrm{cm}^{-1}$, the governing one-speed equation in slab geometry is\n$$\n-\\frac{d}{dx}\\left(D\\frac{d\\phi(x)}{dx}\\right)+\\Sigma_a\\,\\phi(x)=\\frac{1}{k}\\,\\nu\\Sigma_f\\,\\phi(x),\n$$\nfor $x\\in(0,L)$, with vacuum boundary conditions $\\,\\phi(0)=0\\,$ and $\\,\\phi(L)=0\\,$. Here, $\\,\\phi(x)\\,$ is the neutron scalar flux in units of $\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$ and $\\,k\\,$ is dimensionless.\n\nDiscretize the spatial domain using a uniform grid with $N$ interior unknowns, grid spacing $h=L/(N+1)$, and second-order central differences for the second derivative. Construct the discrete loss operator $L$ and the discrete fission operator $F$ for the homogeneous medium. Treat the vacuum boundaries as Dirichlet conditions at $x=0$ and $x=L$ embedded in the stencil. Implement the classical fission source iteration to approximate the largest eigenvalue of the operator $L^{-1}F$ and its associated eigenfunction. The iteration conceptually proceeds by alternating two steps: solving the linear system with a normalized fission source to obtain a new flux, and then updating the global multiplication factor and renormalizing the fission source accordingly. Use the integral over the domain of the fission production rate to define the normalization and update the multiplication factor. Use a uniform quadrature consistent with the grid spacing $h$ for estimating integrals.\n\nFor validation, the analytical model for a homogeneous slab with vacuum boundaries has separable eigenfunctions and yields a closed-form benchmark for the fundamental mode (the smallest buckling). The analytical effective multiplication factor for the fundamental mode ($n=1$) is\n$$\nk_{\\text{anal}}=\\frac{\\nu\\Sigma_f}{\\Sigma_a+D\\left(\\frac{\\pi}{L}\\right)^2},\n$$\nwhich you must use to compute the relative validation error of your numerical estimate $k_{\\text{num}}$ as\n$$\n\\varepsilon=\\frac{\\left|k_{\\text{num}}-k_{\\text{anal}}\\right|}{k_{\\text{anal}}}.\n$$\n\nImplement your program to run the following test suite of parameter sets. All cross sections are in $\\mathrm{cm}^{-1}$, diffusion coefficients in $\\mathrm{cm}$, lengths in $\\mathrm{cm}$. The effective multiplication factor $k$ is dimensionless. Use the vacuum boundary conditions as stated and express all relative errors as dimensionless floats.\n\n- Test Case 1 (general supercritical case, fine grid):\n  - $D=1.0\\,\\mathrm{cm}$, $\\Sigma_a=0.1\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_f=0.25\\,\\mathrm{cm}^{-1}$, $L=100.0\\,\\mathrm{cm}$, $N=200$.\n- Test Case 2 (exactly critical by construction, moderate grid):\n  - $D=1.0\\,\\mathrm{cm}$, $\\Sigma_a=0.1\\,\\mathrm{cm}^{-1}$, $L=50.0\\,\\mathrm{cm}$, $\\nu\\Sigma_f=\\Sigma_a+D\\left(\\frac{\\pi}{L}\\right)^2$ (compute this exactly in floating-point in your code), $N=100$.\n- Test Case 3 (strongly subcritical, coarse grid):\n  - $D=1.2\\,\\mathrm{cm}$, $\\Sigma_a=0.2\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_f=0.05\\,\\mathrm{cm}^{-1}$, $L=100.0\\,\\mathrm{cm}$, $N=30$.\n\nAlgorithmic requirements:\n- Initialize the scalar flux $\\,\\phi\\,$ to a positive field and define an initial fission source that is normalized so that its integral over the domain equals $1$.\n- Iteratively solve the linear system associated with the loss operator and the current normalized fission source to obtain the next flux field.\n- Update the effective multiplication factor using the integral of the induced fission production computed from the updated flux.\n- Renormalize the fission source so that its integral equals $1$ and repeat until the change in the multiplication factor between successive iterations is less than a specified tolerance or until a specified maximum iteration count is reached. Use a convergence tolerance of $10^{-12}$ on $|k_{\\text{new}}-k_{\\text{old}}|$ and a maximum of $10000$ iterations for all test cases.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the relative error $\\,\\varepsilon\\,$ rounded to eight decimal places. The final line must therefore be of the form\n$$\n[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3],\n$$\nwith each $\\,\\varepsilon_i\\,$ a dimensionless float rounded to eight decimal places. No additional text or whitespace beyond the comma separators and enclosing brackets is permitted in the final output line.",
            "solution": "The user requires the construction of a numerical program to solve the one-speed, one-dimensional neutron diffusion equation for its fundamental k-eigenvalue and to validate the result against an analytical benchmark. The solution is derived from first principles, beginning with the governing differential equation and proceeding to its discrete matrix form, followed by an explanation of the iterative solution algorithm.\n\nThe governing steady-state, one-speed neutron diffusion equation for a homogeneous slab of length $L$ is given by:\n$$\n-D\\frac{d^2\\phi(x)}{dx^2}+\\Sigma_a\\,\\phi(x)=\\frac{1}{k}\\,\\nu\\Sigma_f\\,\\phi(x), \\quad x \\in (0, L)\n$$\nwhere $D$ is the diffusion coefficient, $\\Sigma_a$ is the macroscopic absorption cross section, $\\nu\\Sigma_f$ is the macroscopic fission production cross section, $\\phi(x)$ is the neutron scalar flux, and $k$ is the effective neutron multiplication factor. The vacuum boundary conditions are $\\phi(0) = 0$ and $\\phi(L) = 0$.\n\nThis equation can be expressed in operator form as $\\mathcal{L}\\phi(x) = \\frac{1}{k}\\mathcal{F}\\phi(x)$, where $\\mathcal{L} = -D\\frac{d^2}{dx^2} + \\Sigma_a$ is the loss operator (leakage plus absorption) and $\\mathcal{F} = \\nu\\Sigma_f$ is the fission production operator.\n\nTo solve this equation numerically, the spatial domain $(0, L)$ is discretized into a uniform grid with $N$ interior points $x_i = i \\cdot h$ for $i = 1, 2, \\dots, N$. The grid spacing is $h = L/(N+1)$. The boundary points are at $x_0=0$ and $x_{N+1}=L$, where the flux is known to be zero. The flux at the interior points is denoted by $\\phi_i = \\phi(x_i)$.\n\nThe second derivative term is approximated using a second-order central difference stencil:\n$$\n\\frac{d^2\\phi}{dx^2}\\bigg|_{x_i} \\approx \\frac{\\phi(x_i-h) - 2\\phi(x_i) + \\phi(x_i+h)}{h^2} = \\frac{\\phi_{i-1} - 2\\phi_i + \\phi_{i+1}}{h^2}\n$$\n\nSubstituting this approximation into the governing equation for each interior grid point $i$ yields a system of $N$ linear algebraic equations:\n$$\n-D\\left(\\frac{\\phi_{i-1} - 2\\phi_i + \\phi_{i+1}}{h^2}\\right) + \\Sigma_a \\phi_i = \\frac{1}{k} \\nu\\Sigma_f \\phi_i\n$$\nThis can be rearranged as:\n$$\n-\\frac{D}{h^2}\\phi_{i-1} + \\left(\\frac{2D}{h^2} + \\Sigma_a\\right)\\phi_i - \\frac{D}{h^2}\\phi_{i+1} = \\frac{1}{k} \\nu\\Sigma_f \\phi_i\n$$\nThe boundary conditions $\\phi_0=0$ and $\\phi_{N+1}=0$ are incorporated into the equations for $i=1$ and $i=N$, respectively.\n\nThis system of equations can be written in matrix form as:\n$$\n\\mathbf{L}\\vec{\\phi} = \\frac{1}{k}\\mathbf{F}\\vec{\\phi}\n$$\nwhere $\\vec{\\phi} = [\\phi_1, \\phi_2, \\dots, \\phi_N]^T$ is the vector of unknown flux values. The matrix $\\mathbf{L}$ is the discrete loss operator, an $N \\times N$ real, symmetric, tridiagonal matrix with elements:\n$$\nL_{ij} =\n\\begin{cases}\n\\frac{2D}{h^2} + \\Sigma_a, & \\text{if } i=j \\\\\n-\\frac{D}{h^2}, & \\text{if } |i-j|=1 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThe matrix $\\mathbf{F}$ is the discrete fission operator, an $N \\times N$ diagonal matrix with elements $F_{ij} = \\nu\\Sigma_f \\delta_{ij}$.\n\nThe problem is now a generalized eigenvalue problem. The largest eigenvalue, $k$, corresponds to the fundamental mode, which is physically the most persistent flux shape. We solve this using the fission source iteration method, which is a particular implementation of the power iteration algorithm.\n\nThe iterative procedure is as follows:\nLet the iteration index be $m$. We define a fission source vector $\\vec{S} = \\nu\\Sigma_f \\vec{\\phi}$.\nThe algorithm iterates between determining the flux distribution that results from a given source distribution and then updating the source distribution and total source strength (related to $k$).\n\n1.  **Initialization ($m=0$):**\n    - Make an initial guess for the flux eigenvector, $\\vec{\\phi}^{(0)}$. A spatially uniform positive vector (e.g., a vector of all ones) is a suitable choice, as it is guaranteed to have a non-zero projection onto the fundamental mode.\n    - Compute the initial fission source: $\\vec{S}^{(0)} = \\nu\\Sigma_f \\vec{\\phi}^{(0)}$.\n    - Compute the initial estimate of the eigenvalue, $k^{(0)}$, by integrating the fission source over the domain. Using a simple rectangular quadrature, this is $k^{(0)} = h \\sum_{i=1}^N S_i^{(0)}$.\n    - Define a normalized fission source distribution for the first iteration: $\\vec{\\psi}^{(0)} = \\vec{S}^{(0)} / k^{(0)}$. By construction, $h \\sum_{i=1}^N \\psi_i^{(0)} = 1$.\n\n2.  **Iteration ($m = 0, 1, 2, \\dots$):**\n    a. **Solve for Flux:** Solve the linear system for the next flux vector $\\vec{\\phi}^{(m+1)}$ using the normalized source from the previous iteration:\n       $$\n       \\mathbf{L}\\vec{\\phi}^{(m+1)} = \\vec{\\psi}^{(m)}\n       $$\n       This corresponds to finding the steady-state flux distribution resulting from one source neutron distributed according to $\\vec{\\psi}^{(m)}$.\n    b. **Update Source and Eigenvalue:**\n       - Compute the new, unnormalized fission source resulting from the updated flux: $\\vec{S}^{(m+1)} = \\nu\\Sigma_f \\vec{\\phi}^{(m+1)}$.\n       - Compute the new eigenvalue estimate $k^{(m+1)}$ by integrating this new source. This value represents the total number of fission neutrons produced in generation $m+1$ per source neutron in generation $m$.\n         $$\n         k^{(m+1)} = h \\sum_{i=1}^N S_i^{(m+1)}\n         $$\n    c. **Check for Convergence:** Compare the new eigenvalue estimate with the previous one. If $|k^{(m+1)} - k^{(m)}| < \\epsilon_{\\text{tol}}$, where $\\epsilon_{\\text{tol}}$ is a small tolerance, the iteration has converged.\n    d. **Normalize Source:** Prepare the normalized source for the next iteration: $\\vec{\\psi}^{(m+1)} = \\vec{S}^{(m+1)} / k^{(m+1)}$.\n    e. Continue to the next iteration if not converged.\n\nUpon convergence, the final value $k^{(m+1)}$ is our numerical estimate, $k_{\\text{num}}$. This is compared against the analytical solution for validation. For a bare homogeneous slab of width $L$, the analytical eigenvalue for the fundamental mode ($n=1$) is:\n$$\nk_{\\text{anal}}=\\frac{\\nu\\Sigma_f}{\\Sigma_a+D B_g^2} = \\frac{\\nu\\Sigma_f}{\\Sigma_a+D\\left(\\frac{\\pi}{L}\\right)^2}\n$$\nThe relative error is calculated as $\\varepsilon = |k_{\\text{num}} - k_{\\text{anal}}|/k_{\\text{anal}}$. The implementation will follow this procedure for the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the 1D neutron diffusion k-eigenvalue problem using fission source iteration\n    and validates the results against an analytical benchmark for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'D': 1.0,           # cm\n            'Sigma_a': 0.1,     # cm^-1\n            'nu_Sigma_f': 0.25, # cm^-1\n            'L': 100.0,         # cm\n            'N': 200,           # number of interior points\n            'label': 'supercritical'\n        },\n        {\n            'D': 1.0,\n            'Sigma_a': 0.1,\n            'nu_Sigma_f': None, # To be computed\n            'L': 50.0,\n            'N': 100,\n            'label': 'critical'\n        },\n        {\n            'D': 1.2,\n            'Sigma_a': 0.2,\n            'nu_Sigma_f': 0.05,\n            'L': 100.0,\n            'N': 30,\n            'label': 'subcritical'\n        }\n    ]\n\n    # Algorithmic parameters\n    CONVERGENCE_TOLERANCE = 1e-12\n    MAX_ITERATIONS = 10000\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        D = case['D']\n        Sigma_a = case['Sigma_a']\n        nu_Sigma_f = case['nu_Sigma_f']\n        L = case['L']\n        N = case['N']\n\n        # Special handling for Test Case 2\n        if case['label'] == 'critical':\n            # This makes k_analytical exactly 1.0\n            nu_Sigma_f = Sigma_a + D * (np.pi / L)**2\n\n        # 1. Discretization and Matrix Assembly\n        h = L / (N + 1)\n\n        # Construct the discrete loss operator L\n        # Diagonal elements: 2D/h^2 + Sigma_a\n        diag = (2.0 * D / h**2 + Sigma_a) * np.ones(N)\n        # Off-diagonal elements: -D/h^2\n        off_diag = (-D / h**2) * np.ones(N - 1)\n        \n        L_matrix = np.diag(diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        \n        # Pre-compute the inverse of L_matrix for efficiency in the loop\n        L_inv = np.linalg.inv(L_matrix)\n\n        # 2. Fission Source Iteration\n        \n        # Initialization\n        phi = np.ones(N)                                    # Initial flux guess\n        source = nu_Sigma_f * phi                           # Initial fission source\n        k_old = h * np.sum(source)                          # Initial k estimate\n        normalized_source = source / k_old                  # Normalized source distribution\n        \n        k_num = 0.0\n        for i in range(MAX_ITERATIONS):\n            # a. Solve for flux: L * phi_new = normalized_source\n            phi = L_inv @ normalized_source\n\n            # b. Update source and eigenvalue\n            source = nu_Sigma_f * phi\n            k_new = h * np.sum(source)\n\n            # c. Check for convergence\n            if np.abs(k_new - k_old) < CONVERGENCE_TOLERANCE:\n                k_num = k_new\n                break\n\n            # d. Normalize source for next iteration\n            normalized_source = source / k_new\n            k_old = k_new\n        else: # This else belongs to the for loop, executes if loop finishes without break\n            k_num = k_old\n\n        # 3. Validation\n        \n        # Analytical solution\n        buckling_sq = (np.pi / L)**2\n        k_anal = nu_Sigma_f / (Sigma_a + D * buckling_sq)\n\n        # Relative error\n        if k_anal == 0:\n            error = np.inf if k_num != 0 else 0.0\n        else:\n            error = np.abs(k_num - k_anal) / k_anal\n        \n        results.append(\"{:.8f}\".format(error))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}