{
    "hands_on_practices": [
        {
            "introduction": "掌握一种数值方法的第一步是亲手实现它，并对照已知解来验证其性能。本练习提供了一个明确的基准问题——一个具有解析解的线性衰变链——来确认您实现的预测-校正积分器的正确性。通过将数值结果与精确的 Bateman 方程解进行比较，您将能够凭经验测量并验证该方法的二阶收敛率。",
            "id": "4241745",
            "problem": "考虑一个在恒定中子通量下的核反应堆模拟中的线性三核素损耗链。该链定义为核素$1$衰变到核素$2$，核素$2$衰变到核素$3$，核素$3$衰变到一个链外汇点。每个核素还会经历中子吸收，这会将其从链中移除，但不会产生其他核素。其控制常微分方程(ODE)为\n$$\n\\frac{d \\mathbf{n}(t)}{dt} = \\mathbf{A} \\, \\mathbf{n}(t),\n$$\n其中$\\mathbf{n}(t) = [n_1(t), n_2(t), n_3(t)]^\\top$是核素数密度（无量纲的核素数量分数），系数矩阵$\\mathbf{A}$为\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n-(\\lambda_1 + \\sigma_1 \\, \\phi)  0  0 \\\\\n\\lambda_1  -(\\lambda_2 + \\sigma_2 \\, \\phi)  0 \\\\\n0  \\lambda_2  -(\\lambda_3 + \\sigma_3 \\, \\phi)\n\\end{bmatrix}.\n$$\n此处，$\\lambda_i$是衰变常数，单位为$\\mathrm{s}^{-1}$；$\\sigma_i$是吸收截面，单位为$\\mathrm{cm}^2$；$\\phi$是标量中子通量，单位为$\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。有效移除常数为$\\alpha_i = \\lambda_i + \\sigma_i \\, \\phi$，单位为$\\mathrm{s}^{-1}$。对于不同的$\\alpha_i$，该链是线性的、时不变的，并且有从Bateman方程导出的已知解析解。\n\n您的任务是：\n- 为带有耦合的ODE实现一个预估-校正积分器（显式梯形法则，也称为二阶Heun方法），该方法使用步长初始系数来预测步长末端的核素数密度，然后使用步长末端的系数进行校正。在这个线性常系数的情况下，该方法简化为求解$\\mathbf{n}' = \\mathbf{A}\\mathbf{n}$的经典显式梯形法。\n- 使用Bateman公式为线性链实现解析解，其中$\\alpha_i$是互不相同的（假设没有简并情况）。\n- 定义一个验证测试，通过计算在最终时间$T$处、对连续加密的步长的数值误差，来测量预估-校正方法的观测收斂阶。通过关系式$E(h) \\approx C h^p$来估计阶数$p$，因此\n$$\np \\approx \\frac{\\log(E(h_1)) - \\log(E(h_2))}{\\log(h_1) - \\log(h_2)},\n$$\n其中$h_2 = h_1 / 2$。使用在时间$T$处的最终核素数密度误差向量的欧几里得范数作为$E(h)$。\n\n所有物理量必须使用以下单位：\n- 时间单位为$\\mathrm{s}$。\n- 衰变常数单位为$\\mathrm{s}^{-1}$。\n- 吸收截面单位为$\\mathrm{cm}^2$。\n- 通量单位为$\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n- 核素数密度为无量纲的核素数量分数。\n\n实现一个程序，对于每个测试用例，该程序使用预估-校正方法，以三个步数$N_1$、$N_2$和$N_3$（其中$N_2 = 2N_1$，$N_3 = 2N_2$）计算在$T$时刻的数值解；计算相应的误差$E(h_1)$、$E(h_2)$、$E(h_3)$；并通过对两个成对估计值取平均来返回测得的收敛阶：\n$$\np_{12} = \\frac{\\log(E(h_1)) - \\log(E(h_2))}{\\log(h_1) - \\log(h_2)}, \\quad\np_{23} = \\frac{\\log(E(h_2)) - \\log(E(h_3))}{\\log(h_2) - \\log(h_3)}, \\quad\np = \\frac{p_{12} + p_{23}}{2}.\n$$\n\n使用以下测试套件：\n\n- 测试用例$1$（纯衰变链，中等速率）：\n  - $\\lambda_1 = 0.1 \\ \\mathrm{s}^{-1}$, $\\lambda_2 = 0.05 \\ \\mathrm{s}^{-1}$, $\\lambda_3 = 0.0 \\ \\mathrm{s}^{-1}$。\n  - $\\sigma_1 = 0.0 \\ \\mathrm{cm}^2$, $\\sigma_2 = 0.0 \\ \\mathrm{cm}^2$, $\\sigma_3 = 0.0 \\ \\mathrm{cm}^2$。\n  - $\\phi = 0.0 \\ \\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 初始条件 $\\mathbf{n}(0) = [1.0, 0.0, 0.0]^\\top$。\n  - 最终时间 $T = 5.0 \\ \\mathrm{s}$。\n  - 步数 $(N_1, N_2, N_3) = (50, 100, 200)$。\n\n- 测试用例$2$（衰变加吸收，不同的初始组成）：\n  - $\\lambda_1 = 0.05 \\ \\mathrm{s}^{-1}$, $\\lambda_2 = 0.02 \\ \\mathrm{s}^{-1}$, $\\lambda_3 = 0.01 \\ \\mathrm{s}^{-1}$。\n  - $\\sigma_1 = 3 \\times 10^{-24} \\ \\mathrm{cm}^2$, $\\sigma_2 = 4 \\times 10^{-24} \\ \\mathrm{cm}^2$, $\\sigma_3 = 2 \\times 10^{-24} \\ \\mathrm{cm}^2$。\n  - $\\phi = 1 \\times 10^{14} \\ \\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 初始条件 $\\mathbf{n}(0) = [0.6, 0.4, 0.0]^\\top$。\n  - 最终时间 $T = 10.0 \\ \\mathrm{s}$。\n  - 步数 $(N_1, N_2, N_3) = (50, 100, 200)$。\n\n- 测试用例$3$（刚性衰变链）：\n  - $\\lambda_1 = 20.0 \\ \\mathrm{s}^{-1}$, $\\lambda_2 = 10.0 \\ \\mathrm{s}^{-1}$, $\\lambda_3 = 5.0 \\ \\mathrm{s}^{-1}$。\n  - $\\sigma_1 = 0.0 \\ \\mathrm{cm}^2$, $\\sigma_2 = 0.0 \\ \\mathrm{cm}^2$, $\\sigma_3 = 0.0 \\ \\mathrm{cm}^2$。\n  - $\\phi = 0.0 \\ \\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 初始条件 $\\mathbf{n}(0) = [1.0, 0.0, 0.0]^\\top$。\n  - 最终时间 $T = 0.5 \\ \\mathrm{s}$。\n  - 步数 $(N_1, N_2, N_3) = (50, 100, 200)$。\n\n您的程序应生成单行输出，其中包含三个测试用例测得的收敛阶，格式为方括号内以逗号分隔的浮点数列表（例如，“[p1,p2,p3]”）。不应产生任何其他输出。最终的收敛阶以无量纲浮点数表示（无单位）。",
            "solution": "该问题要求验证应用于模拟核素损耗的线性常微分方程(ODE)组的预估-校正数值方法的收敛阶。这包括实现数值方法，推导并实现解析解，然后使用这些来计算经验收敛阶。\n\n### 1. 控制方程和系统矩阵\n核素数密度$\\mathbf{n}(t) = [n_1(t), n_2(t), n_3(t)]^\\top$的时间演化由以下线性常系数ODE系统描述：\n$$\n\\frac{d \\mathbf{n}(t)}{dt} = \\mathbf{A} \\, \\mathbf{n}(t)\n$$\n系统矩阵$\\mathbf{A}$是根据衰变常数$\\lambda_i$、吸收截面$\\sigma_i$和中子通量$\\phi$定义的。它是一个下三角矩阵，形式如下：\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n-(\\lambda_1 + \\sigma_1 \\, \\phi)  0  0 \\\\\n\\lambda_1  -(\\lambda_2 + \\sigma_2 \\, \\phi)  0 \\\\\n0  \\lambda_2  -(\\lambda_3 + \\sigma_3 \\, \\phi)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\alpha_1  0  0 \\\\\n\\lambda_1  -\\alpha_2  0 \\\\\n0  \\lambda_2  -\\alpha_3\n\\end{bmatrix}\n$$\n其中$\\alpha_i = \\lambda_i + \\sigma_i \\, \\phi$是核素$i$的总移除常数。\n\n### 2. 通过Bateman方程的解析解\n对于一个具有不同移除常数$\\alpha_i$的线性链，可以使用Bateman方程找到解析解。在时间$t$时，对于一个初始状态$\\mathbf{n}(0)$的解可以通过对每个初始核素浓度的贡献求和得到。对于给定的3核素系统，解为：\n\n$n_1(t) = n_1(0) e^{-\\alpha_1 t}$\n\n$n_2(t) = n_1(0) \\frac{\\lambda_1}{\\alpha_2 - \\alpha_1} (e^{-\\alpha_1 t} - e^{-\\alpha_2 t}) + n_2(0) e^{-\\alpha_2 t}$\n\n$n_3(t) = n_1(0) \\lambda_1 \\lambda_2 \\left( \\frac{e^{-\\alpha_1 t}}{(\\alpha_2 - \\alpha_1)(\\alpha_3 - \\alpha_1)} + \\frac{e^{-\\alpha_2 t}}{(\\alpha_1 - \\alpha_2)(\\alpha_3 - \\alpha_2)} + \\frac{e^{-\\alpha_3 t}}{(\\alpha_1 - \\alpha_3)(\\alpha_2 - \\alpha_3)} \\right) + n_2(0) \\frac{\\lambda_2}{\\alpha_3 - \\alpha_2} (e^{-\\alpha_2 t} - e^{-\\alpha_3 t}) + n_3(0) e^{-\\alpha_3 t}$\n\n这些方程在问题假设所有$\\alpha_i$都互不相同的条件下是有效的。\n\n### 3. 数值方法：显式梯形法则（Heun方法）\n问题指定了一个预估-校正方案。对于一个通用ODE系统$\\mathbf{y}'=\\mathbf{f}(t, \\mathbf{y})$，从$t_k$到$t_{k+1}=t_k+h$的一个步长包括：\n1.  **预估步**：一个显式欧拉步，用于找到区间末端的初步值$\\mathbf{y}^*_{k+1}$。\n    $$\n    \\mathbf{y}^*_{k+1} = \\mathbf{y}_k + h \\mathbf{f}(t_k, \\mathbf{y}_k)\n    $$\n2.  **校正步**：一个隐式梯形步，使用预测值来评估区间末端的函数，从而提高精度。\n    $$\n    \\mathbf{y}_{k+1} = \\mathbf{y}_k + \\frac{h}{2} \\left[ \\mathbf{f}(t_k, \\mathbf{y}_k) + \\mathbf{f}(t_{k+1}, \\mathbf{y}^*_{k+1}) \\right]\n    $$\n对于我们的特定线性系统，$\\mathbf{f}(t, \\mathbf{n}) = \\mathbf{A}\\mathbf{n}$。该方法简化如下：\n1.  **预估**：$\\mathbf{n}^*_{k+1} = \\mathbf{n}_k + h (\\mathbf{A} \\mathbf{n}_k)$\n2.  **校正**：$\\mathbf{n}_{k+1} = \\mathbf{n}_k + \\frac{h}{2} (\\mathbf{A} \\mathbf{n}_k + \\mathbf{A} \\mathbf{n}^*_{k+1})$\n\n问题中关于预测使用“步长初始系数”和校正使用“步长末端系数”的耦合表述，暗示了矩阵$\\mathbf{A}$可能依赖于$\\mathbf{n}$的情景。在本问题中，$\\mathbf{A}$是恒定的，因此“步长末端系数”虽然使用预测的密度进行评估，但结果仍然是相同的常数矩阵$\\mathbf{A}$。因此，该实现对应于用于线性系统的标准二阶Heun方法。\n\n### 4. 收敛阶验证\nHeun方法的理论收敛阶为$p=2$。为了经验性地验证这一点，我们计算一系列递减步长的数值解的误差。在最终时间$T$处，步长为$h$的误差$E(h)$定义为数值解与解析解之差的欧几里得范数：\n$$\nE(h) = \\|\\mathbf{n}_{\\text{numerical}}(T) - \\mathbf{n}_{\\text{analytic}}(T)\\|_2\n$$\n假设误差遵循关系$E(h) \\approx C h^p$，其中$C$是一个常数，我们可以使用两个不同步长$h_1$和$h_2$的结果来估计$p$：\n$$\np \\approx \\frac{\\log(E(h_1)) - \\log(E(h_2))}{\\log(h_1) - \\log(h_2)}\n$$\n给定步数$N_1$、$N_2=2N_1$和$N_3=2N_2$，相应的步长为$h_1=T/N_1$、$h_2=T/N_2=h_1/2$和$h_3=T/N_3=h_2/2$。分母简化为：$\\log(h_1) - \\log(h_2) = \\log(h_1/h_2) = \\log(2)$。我们计算两个$p$的估计值：\n$$\np_{12} = \\frac{\\log(E(h_1)/E(h_2))}{\\log(2)}, \\quad p_{23} = \\frac{\\log(E(h_2)/E(h_3))}{\\log(2)}\n$$\n最终报告的收敛阶是这两个估计值的平均值：$p = (p_{12} + p_{23}) / 2$。一个接近$2.0$的经验值$p$将证实该方法预期的二阶精度。\n\n### 5. 实现策略\n一个Python程序被构建来解决此问题：\n1.  一个函数`bateman_solution`实现了$n_1(t)$、$n_2(t)$和$n_3(t)$的解析公式。它接受物理参数、初始条件和时间$t$作为输入。\n2.  一个函数`heun_solver`实现了预估-校正方案。它迭代给定的步数，在每一步更新密度向量。\n3.  主函数`solve`为每个测试用例协调整个过程。它：\n    a.  设置参数（$\\lambda_i, \\sigma_i, \\phi, \\mathbf{n}(0), T, N_k$）。\n    b.  构建矩阵$\\mathbf{A}$。\n    c.  计算在时间$T$的精确解。\n    d.  遍历指定的步数（$N_1, N_2, N_3$），为每个步数调用`heun_solver`，并计算误差范数$E(h_k)$。\n    e.  使用收集到的误差计算平均收敛阶$p$。\n    f.  收集所有测试用例的收敛阶，并按指定格式打印。\n所有向量和矩阵运算均使用`numpy`库执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bateman_solution(lambdas, alphas, n0, t):\n    \"\"\"\n    Computes the analytic solution for the 3-nuclide chain using Bateman's equations.\n    Assumes distinct alpha values.\n    \n    Args:\n        lambdas (list or np.ndarray): decay constants [lambda_1, lambda_2, lambda_3].\n        alphas (list or np.ndarray): effective removal constants [alpha_1, alpha_2, alpha_3].\n        n0 (np.ndarray): initial number densities [n1(0), n2(0), n3(0)].\n        t (float): time at which to evaluate the solution.\n\n    Returns:\n        np.ndarray: number density vector [n1(t), n2(t), n3(t)].\n    \"\"\"\n    l1, l2, _ = lambdas\n    a1, a2, a3 = alphas\n    n1_0, n2_0, n3_0 = n0\n\n    # These assertions confirm the problem constraint of distinct alphas\n    assert a1 != a2, \"alpha_1 and alpha_2 cannot be equal.\"\n    assert a1 != a3, \"alpha_1 and alpha_3 cannot be equal.\"\n    assert a2 != a3, \"alpha_2 and alpha_3 cannot be equal.\"\n\n    # Exponential terms\n    exp_a1t = np.exp(-a1 * t)\n    exp_a2t = np.exp(-a2 * t)\n    exp_a3t = np.exp(-a3 * t)\n\n    # --- n1(t) ---\n    n1_t = n1_0 * exp_a1t\n\n    # --- n2(t) ---\n    n2_t_from_n1_0 = n1_0 * l1 / (a2 - a1) * (exp_a1t - exp_a2t)\n    n2_t_from_n2_0 = n2_0 * exp_a2t\n    n2_t = n2_t_from_n1_0 + n2_t_from_n2_0\n\n    # --- n3(t) ---\n    # Contribution from n1(0)\n    c1 = 1.0 / ((a2 - a1) * (a3 - a1))\n    c2 = 1.0 / ((a1 - a2) * (a3 - a2))\n    c3 = 1.0 / ((a1 - a3) * (a2 - a3))\n    n3_t_from_n1_0 = n1_0 * l1 * l2 * (c1 * exp_a1t + c2 * exp_a2t + c3 * exp_a3t)\n    \n    # Contribution from n2(0)\n    if l2 > 0:\n        n3_t_from_n2_0 = n2_0 * l2 / (a3 - a2) * (exp_a2t - exp_a3t)\n    else:\n        n3_t_from_n2_0 = 0.0\n\n    # Contribution from n3(0)\n    n3_t_from_n3_0 = n3_0 * exp_a3t\n    \n    n3_t = n3_t_from_n1_0 + n3_t_from_n2_0 + n3_t_from_n3_0\n\n    return np.array([n1_t, n2_t, n3_t])\n\ndef heun_solver(A, n0, h, num_steps):\n    \"\"\"\n    Solves dn/dt = An using the explicit trapezoidal (Heun's) method.\n    \n    Args:\n        A (np.ndarray): The coefficient matrix.\n        n0 (np.ndarray): The initial number density vector.\n        h (float): The time step size.\n        num_steps (int): The number of time steps to take.\n\n    Returns:\n        np.ndarray: The numerical solution vector at the final time.\n    \"\"\"\n    n = np.copy(n0)\n    for _ in range(num_steps):\n        # Predictor step\n        k1 = A @ n\n        n_pred = n + h * k1\n        \n        # Corrector step\n        k2 = A @ n_pred\n        n = n + (h / 2.0) * (k1 + k2)\n    return n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute convergence rates.\n    \"\"\"\n    test_cases = [\n        {\n            \"lambdas\": np.array([0.1, 0.05, 0.0]),\n            \"sigmas\": np.array([0.0, 0.0, 0.0]),\n            \"phi\": 0.0,\n            \"n0\": np.array([1.0, 0.0, 0.0]),\n            \"T\": 5.0,\n            \"Ns\": (50, 100, 200),\n        },\n        {\n            \"lambdas\": np.array([0.05, 0.02, 0.01]),\n            \"sigmas\": np.array([3e-24, 4e-24, 2e-24]),\n            \"phi\": 1e14,\n            \"n0\": np.array([0.6, 0.4, 0.0]),\n            \"T\": 10.0,\n            \"Ns\": (50, 100, 200),\n        },\n        {\n            \"lambdas\": np.array([20.0, 10.0, 5.0]),\n            \"sigmas\": np.array([0.0, 0.0, 0.0]),\n            \"phi\": 0.0,\n            \"n0\": np.array([1.0, 0.0, 0.0]),\n            \"T\": 0.5,\n            \"Ns\": (50, 100, 200),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambdas = case[\"lambdas\"]\n        sigmas = case[\"sigmas\"]\n        phi = case[\"phi\"]\n        n0 = case[\"n0\"]\n        T = case[\"T\"]\n        Ns = case[\"Ns\"]\n\n        # Calculate effective removal constants and build the matrix A\n        alphas = lambdas + sigmas * phi\n        A = np.array([\n            [-alphas[0], 0, 0],\n            [lambdas[0], -alphas[1], 0],\n            [0, lambdas[1], -alphas[2]],\n        ])\n\n        # Get the exact solution at the final time T\n        n_exact = bateman_solution(lambdas, alphas, n0, T)\n        \n        errors = []\n        step_sizes = []\n\n        for N in Ns:\n            h = T / N\n            step_sizes.append(h)\n            \n            # Get the numerical solution\n            n_numerical = heun_solver(A, n0, h, N)\n            \n            # Calculate the Euclidean norm of the error\n            error = np.linalg.norm(n_numerical - n_exact)\n            errors.append(error)\n\n        # Calculate pairwise convergence rates\n        # p = log(E1/E2) / log(h1/h2) where h1/h2 = 2\n        p12 = np.log(errors[0] / errors[1]) / np.log(step_sizes[0] / step_sizes[1])\n        p23 = np.log(errors[1] / errors[2]) / np.log(step_sizes[1] / step_sizes[2])\n\n        # Average the two estimates\n        p_avg = (p12 + p23) / 2.0\n        results.append(p_avg)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "虽然验证和误差分析是必不可少的，但一种方法的最终考验是其在实际问题中的表现。本练习将从线性、常系数系统转向包含反馈的非线性基准问题，这在反应堆模拟中更为常见。您需要将预测-校正方案与更简单的显式方法和更稳健的隐式求解器进行比较，从而权衡在实际模拟中精度、稳定性和计算成本之间的关键利弊。",
            "id": "4241718",
            "problem": "考虑一个在单个时间步长内、恒定中子通量下的线性化燃耗系统，由常微分方程(ODE) $\\dot{\\mathbf{N}}(t) = \\mathbf{A}\\,\\mathbf{N}(t) + \\mathbf{b}$ 表示，其中 $\\mathbf{N}(t)$ 是核素密度向量，$\\mathbf{A}$ 是该步长内的常数矩阵，$\\mathbf{b}$ 是该步长内的常数向量。假设 $\\mathbf{A}$ 是可逆的。令 $t_{n}$ 表示当前时间，$t_{n+1} = t_{n} + h$ 表示下一时刻，且 $\\mathbf{N}_{n} = \\mathbf{N}(t_{n})$。从基本的ODE理论和矩阵指数的定义出发，推导 $\\mathbf{N}_{n+1} = \\mathbf{N}(t_{n+1})$ 的精确单步更新公式，并仅使用 $\\mathbf{A}$、$\\mathbf{b}$ 和矩阵指数以闭合形式表示非齐次项的贡献。\n\n接下来，应用一个二阶显式预测-校正(PC)方法，特别是两步显式梯形法则（也称为Heun方法），其定义为预测步 $\\mathbf{N}^{\\mathrm{p}} = \\mathbf{N}_{n} + h\\,\\mathbf{f}(\\mathbf{N}_{n})$ 和校正步 $\\mathbf{N}_{n+1}^{\\mathrm{PC}} = \\mathbf{N}_{n} + \\frac{h}{2}\\left[\\mathbf{f}(\\mathbf{N}_{n}) + \\mathbf{f}(\\mathbf{N}^{\\mathrm{p}})\\right]$，其中 $\\mathbf{f}(\\mathbf{N}) = \\mathbf{A}\\mathbf{N} + \\mathbf{b}$。使用在 $t_{n}$ 处的泰勒展开，并一致地保留到超过该方法名义阶数的第一个非零阶项，确定局部截断误差中的领头阶系数（即乘以 $h^{3}$ 的向量）。局部截断误差定义为当方法以精确值 $\\mathbf{N}_{n}$ 初始化时的 $\\mathbf{N}(t_{n+1}) - \\mathbf{N}_{n+1}^{\\mathrm{PC}}$。\n\n最终答案需提供此 $h^{3}$ 系数的简化闭合形式表达式，用 $\\mathbf{A}$、$\\mathbf{b}$ 和 $\\mathbf{N}_{n}$ 表示。无需进行数值计算。最终答案必须是单个闭合形式的解析表达式。",
            "solution": "用户提供了一个来自应用于核工程模拟的数值分析领域的有效且适定的问题。该问题分为两部分：首先，推导一个线性常微分方程(ODE)系统的精确单步解；其次，确定一个特定的预测-校正方法应用于此系统时的领头阶局部截断误差。\n\n该系统由以下ODE描述：\n$$ \\dot{\\mathbf{N}}(t) = \\mathbf{A}\\,\\mathbf{N}(t) + \\mathbf{b} $$\n其中 $\\mathbf{N}(t)$ 是核素密度向量，$\\mathbf{A}$ 是一个在长度为 $h$ 的时间步长内为常数的可逆矩阵，$\\mathbf{b}$ 是一个常数向量。在时间 $t_n$ 的初始条件是 $\\mathbf{N}(t_n) = \\mathbf{N}_n$。\n\n**第一部分：精确解的推导**\n\n给定的ODE是一个一阶线性非齐次常系数系统。我们可以使用积分因子来求解它。设积分因子为 $\\exp(-\\mathbf{A}t)$。将重写为 $\\dot{\\mathbf{N}}(t) - \\mathbf{A}\\mathbf{N}(t) = \\mathbf{b}$ 的ODE乘以积分因子，得到：\n$$ \\exp(-\\mathbf{A}t)\\dot{\\mathbf{N}}(t) - \\exp(-\\mathbf{A}t)\\mathbf{A}\\mathbf{N}(t) = \\exp(-\\mathbf{A}t)\\mathbf{b} $$\n左边是微分乘法法则应用于 $\\exp(-\\mathbf{A}t)\\mathbf{N}(t)$ 的结果：\n$$ \\frac{d}{dt}\\left[\\exp(-\\mathbf{A}t)\\mathbf{N}(t)\\right] = \\exp(-\\mathbf{A}t)\\mathbf{b} $$\n我们将此方程在时间区间 $[t_n, t_{n+1}]$ 上积分，其中 $t_{n+1} = t_n + h$：\n$$ \\int_{t_n}^{t_{n+1}} \\frac{d}{d\\tau}\\left[\\exp(-\\mathbf{A}\\tau)\\mathbf{N}(\\tau)\\right] d\\tau = \\int_{t_n}^{t_{n+1}} \\exp(-\\mathbf{A}\\tau)\\mathbf{b} \\, d\\tau $$\n$$ \\left[\\exp(-\\mathbf{A}\\tau)\\mathbf{N}(\\tau)\\right]_{t_n}^{t_{n+1}} = \\left(\\int_{t_n}^{t_{n+1}} \\exp(-\\mathbf{A}\\tau) \\, d\\tau\\right) \\mathbf{b} $$\n$$ \\exp(-\\mathbf{A}t_{n+1})\\mathbf{N}(t_{n+1}) - \\exp(-\\mathbf{A}t_n)\\mathbf{N}_n = \\left(\\int_{t_n}^{t_{n+1}} \\exp(-\\mathbf{A}\\tau) \\, d\\tau\\right) \\mathbf{b} $$\n由于 $\\mathbf{A}$ 是一个常数可逆矩阵，我们可以计算该积分：\n$$ \\int_{t_n}^{t_{n+1}} \\exp(-\\mathbf{A}\\tau) \\, d\\tau = \\left[-\\mathbf{A}^{-1}\\exp(-\\mathbf{A}\\tau)\\right]_{t_n}^{t_{n+1}} = -\\mathbf{A}^{-1}\\left(\\exp(-\\mathbf{A}t_{n+1}) - \\exp(-\\mathbf{A}t_n)\\right) $$\n将此结果代回到积分后的方程中：\n$$ \\exp(-\\mathbf{A}t_{n+1})\\mathbf{N}(t_{n+1}) - \\exp(-\\mathbf{A}t_n)\\mathbf{N}_n = -\\mathbf{A}^{-1}\\left(\\exp(-\\mathbf{A}t_{n+1}) - \\exp(-\\mathbf{A}t_n)\\right)\\mathbf{b} $$\n为了解出 $\\mathbf{N}(t_{n+1})$，我们将整个方程从左侧乘以 $\\exp(\\mathbf{A}t_{n+1})$：\n$$ \\mathbf{N}(t_{n+1}) - \\exp(\\mathbf{A}(t_{n+1}-t_n))\\mathbf{N}_n = -\\exp(\\mathbf{A}t_{n+1})\\mathbf{A}^{-1}\\left(\\exp(-\\mathbf{A}t_{n+1}) - \\exp(-\\mathbf{A}t_n)\\right)\\mathbf{b} $$\n利用矩阵与其逆矩阵及指数函数可交换的性质，并定义 $h = t_{n+1} - t_n$：\n$$ \\mathbf{N}(t_{n+1}) - \\exp(\\mathbf{A}h)\\mathbf{N}_n = -\\mathbf{A}^{-1}\\left(\\exp(\\mathbf{A}t_{n+1})\\exp(-\\mathbf{A}t_{n+1}) - \\exp(\\mathbf{A}t_{n+1})\\exp(-\\mathbf{A}t_n)\\right)\\mathbf{b} $$\n$$ \\mathbf{N}(t_{n+1}) - \\exp(\\mathbf{A}h)\\mathbf{N}_n = -\\mathbf{A}^{-1}\\left(\\mathbf{I} - \\exp(\\mathbf{A}(t_{n+1}-t_n))\\right)\\mathbf{b} $$\n$$ \\mathbf{N}(t_{n+1}) = \\exp(\\mathbf{A}h)\\mathbf{N}_n + \\mathbf{A}^{-1}\\left(\\exp(\\mathbf{A}h) - \\mathbf{I}\\right)\\mathbf{b} $$\n这就是单步更新的精确解。非齐次项的贡献是 $\\mathbf{A}^{-1}(\\exp(\\mathbf{A}h) - \\mathbf{I})\\mathbf{b}$。\n\n**第二部分：局部截断误差分析**\n\n局部截断误差定义为 $\\mathbf{N}(t_{n+1}) - \\mathbf{N}_{n+1}^{\\mathrm{PC}}$，其中我们假设 $\\mathbf{N}(t_n)$ 是精确的。\n\n首先，我们将精确解 $\\mathbf{N}(t_{n+1})$ 在 $t_n$ 处展开为泰勒级数：\n$$ \\mathbf{N}(t_{n+1}) = \\mathbf{N}(t_n+h) = \\mathbf{N}_n + h\\dot{\\mathbf{N}}_n + \\frac{h^2}{2!}\\ddot{\\mathbf{N}}_n + \\frac{h^3}{3!}\\dddot{\\mathbf{N}}_n + O(h^4) $$\n在 $t_n$ 处计算的导数是：\n$$ \\dot{\\mathbf{N}}_n = \\mathbf{A}\\mathbf{N}_n + \\mathbf{b} $$\n$$ \\ddot{\\mathbf{N}}_n = \\frac{d}{dt}\\left(\\mathbf{A}\\mathbf{N}(t) + \\mathbf{b}\\right)\\bigg|_{t=t_n} = \\mathbf{A}\\dot{\\mathbf{N}}_n = \\mathbf{A}(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) = \\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b} $$\n$$ \\dddot{\\mathbf{N}}_n = \\frac{d}{dt}\\left(\\mathbf{A}^2\\mathbf{N}(t) + \\mathbf{A}\\mathbf{b}\\right)\\bigg|_{t=t_n} = \\mathbf{A}^2\\dot{\\mathbf{N}}_n = \\mathbf{A}^2(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) = \\mathbf{A}^3\\mathbf{N}_n + \\mathbf{A}^2\\mathbf{b} $$\n将这些导数代入泰勒级数：\n$$ \\mathbf{N}(t_{n+1}) = \\mathbf{N}_n + h\\left(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}\\right) + \\frac{h^2}{2}\\left(\\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b}\\right) + \\frac{h^3}{6}\\left(\\mathbf{A}^3\\mathbf{N}_n + \\mathbf{A}^2\\mathbf{b}\\right) + O(h^4) $$\n\n接下来，我们根据两步显式梯形法则（Heun方法）确定数值解 $\\mathbf{N}_{n+1}^{\\mathrm{PC}}$ 的表达式。右端函数为 $\\mathbf{f}(\\mathbf{N}) = \\mathbf{A}\\mathbf{N} + \\mathbf{b}$。\n\n预测步：\n$$ \\mathbf{N}^{\\mathrm{p}} = \\mathbf{N}_n + h\\,\\mathbf{f}(\\mathbf{N}_n) = \\mathbf{N}_n + h(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) $$\n校正步：\n$$ \\mathbf{N}_{n+1}^{\\mathrm{PC}} = \\mathbf{N}_n + \\frac{h}{2}\\left[\\mathbf{f}(\\mathbf{N}_n) + \\mathbf{f}(\\mathbf{N}^{\\mathrm{p}})\\right] $$\n我们需要在预测值 $\\mathbf{N}^{\\mathrm{p}}$ 处计算 $\\mathbf{f}$：\n$$ \\mathbf{f}(\\mathbf{N}^{\\mathrm{p}}) = \\mathbf{A}\\mathbf{N}^{\\mathrm{p}} + \\mathbf{b} = \\mathbf{A}\\left[\\mathbf{N}_n + h(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b})\\right] + \\mathbf{b} $$\n$$ \\mathbf{f}(\\mathbf{N}^{\\mathrm{p}}) = \\mathbf{A}\\mathbf{N}_n + h\\mathbf{A}^2\\mathbf{N}_n + h\\mathbf{A}\\mathbf{b} + \\mathbf{b} = (\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) + h(\\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b}) $$\n将 $\\mathbf{f}(\\mathbf{N}_n)$ 和 $\\mathbf{f}(\\mathbf{N}^{\\mathrm{p}})$ 代入校正公式：\n$$ \\mathbf{N}_{n+1}^{\\mathrm{PC}} = \\mathbf{N}_n + \\frac{h}{2}\\left[ (\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) + \\left((\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) + h(\\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b})\\right) \\right] $$\n$$ \\mathbf{N}_{n+1}^{\\mathrm{PC}} = \\mathbf{N}_n + \\frac{h}{2}\\left[ 2(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) + h(\\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b}) \\right] $$\n$$ \\mathbf{N}_{n+1}^{\\mathrm{PC}} = \\mathbf{N}_n + h(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) + \\frac{h^2}{2}(\\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b}) $$\n\n最后，我们通过从精确的泰勒级数展开中减去数值解来求得局部截断误差：\n$$ \\mathbf{N}(t_{n+1}) - \\mathbf{N}_{n+1}^{\\mathrm{PC}} = \\left( \\mathbf{N}_n + h(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) + \\frac{h^2}{2}(\\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b}) + \\frac{h^3}{6}(\\mathbf{A}^3\\mathbf{N}_n + \\mathbf{A}^2\\mathbf{b}) + O(h^4) \\right) $$\n$$ - \\left( \\mathbf{N}_n + h(\\mathbf{A}\\mathbf{N}_n + \\mathbf{b}) + \\frac{h^2}{2}(\\mathbf{A}^2\\mathbf{N}_n + \\mathbf{A}\\mathbf{b}) \\right) $$\n$h^0$, $h^1$ 和 $h^2$ 阶的项相互抵消。剩余的领头阶项是：\n$$ \\mathbf{N}(t_{n+1}) - \\mathbf{N}_{n+1}^{\\mathrm{PC}} = \\frac{h^3}{6}\\left(\\mathbf{A}^3\\mathbf{N}_n + \\mathbf{A}^2\\mathbf{b}\\right) + O(h^4) $$\n问题要求的是局部截断误差中 $h^3$ 项的系数。该系数是向量 $\\frac{1}{6}(\\mathbf{A}^3\\mathbf{N}_n + \\mathbf{A}^2\\mathbf{b})$。",
            "answer": "$$\\boxed{\\frac{1}{6}\\left(\\mathbf{A}^3\\mathbf{N}_n + \\mathbf{A}^2\\mathbf{b}\\right)}$$"
        },
        {
            "introduction": "虽然验证和误差分析是必不可少的，但一种方法的最终考验是其在实际问题中的表现。本练习将从线性、常系数系统转向包含反馈的非线性基准问题，这在反应堆模拟中更为常见。您需要将预测-校正方案与更简单的显式方法和更稳健的隐式求解器进行比较，从而权衡在实际模拟中精度、稳定性和计算成本之间的关键利弊。",
            "id": "4241782",
            "problem": "考虑一个简化的、科学上一致的燃耗基准问题，该问题代表了核反应堆模拟中的典型情况。该系统由三种核素的数密度构成，表示为向量 $N(t) = [N_F(t), N_M(t), N_X(t)]^\\top$，单位为原子数/立方厘米。其控制方程为贝特曼（Bateman）型耦合系统\n$$\n\\frac{dN}{dt} = Q\\big(N(t)\\big)\\,N(t),\n$$\n其中 $Q(N)$ 是一个 $3\\times 3$ 的反应率矩阵，其矩阵元由中子诱发反应和放射性衰变决定。中子通量通过包含成分反馈的模型来描述：\n$$\n\\phi(N) = \\frac{\\phi_0}{1 + \\kappa\\,N_X},\n$$\n其中 $\\phi_0$ 的单位是 中子数/（平方厘米·秒），$\\kappa$ 的单位是 立方厘米/原子。所包含的物理过程有：\n- 易裂变核素 $F$ 的吸收和裂变，其微观截面分别为 $\\sigma_{F,a}$ 和 $\\sigma_{F,f}$，单位为平方厘米。\n- 中间核素 $M$ 的吸收，截面为 $\\sigma_{M,a}$；以及毒物核素 $X$ 的吸收，截面为 $\\sigma_{X,a}$。\n- 放射性衰变，衰变常数分别为 $\\lambda_F$、$\\lambda_M$ 和 $\\lambda_X$，单位为 1/秒。\n- 核素 $M$ 的一部分（比例为 $b_{M\\rightarrow F}$）衰变为 $F$，毒物核素 $X$ 由 $F$ 的裂变产生，独立产额为 $y_X$（无量纲）。\n\n在这些假设下，$Q(N)$ 的矩阵元定义如下：\n$$\n\\begin{aligned}\n\\frac{dN_F}{dt} = -\\big(\\sigma_{F,a}+\\sigma_{F,f}\\big)\\,\\phi(N)\\,N_F - \\lambda_F\\,N_F + b_{M\\rightarrow F}\\,\\lambda_M\\,N_M,\\\\\n\\frac{dN_M}{dt} = +\\sigma_{F,a}\\,\\phi(N)\\,N_F - \\sigma_{M,a}\\,\\phi(N)\\,N_M - \\lambda_M\\,N_M,\\\\\n\\frac{dN_X}{dt} = +y_X\\,\\sigma_{F,f}\\,\\phi(N)\\,N_F - \\sigma_{X,a}\\,\\phi(N)\\,N_X - \\lambda_X\\,N_X.\n\\end{aligned}\n$$\n这通过 $dN/dt = Q(N)\\,N$ 定义了 $Q(N)$。\n\n您的任务是，在给定的初始条件 $N(0)=N_0$ 和固定的时间范围 $T$ 内，实现并比较三种时间积分策略，并量化其精度和计算成本：\n1. 冻结反应率矩阵指数法 (ME)：在一个宏观时间步长 $\\Delta t$ 内，将步初的反应率矩阵 $Q$ 冻结，即 $Q_k = Q(N_k)$，然后计算 $N_{k+1} = \\exp\\!\\big(\\Delta t\\,Q_k\\big)\\,N_k$。\n2. 预测-校正燃耗法 (PC)：在一个宏观时间步长 $\\Delta t$ 内，首先计算预测值 $N^{\\mathrm{pred}} = \\exp\\!\\big(\\Delta t\\,Q(N_k)\\big)\\,N_k$，然后构建平均反应率矩阵 $Q_{\\mathrm{avg}} = \\tfrac{1}{2}\\big(Q(N_k)+Q(N^{\\mathrm{pred}})\\big)$，并计算校正后的状态 $N_{k+1} = \\exp\\!\\big(\\Delta t\\,Q_{\\mathrm{avg}}\\big)\\,N_k$。\n3. 反向微分公式 (BDF)：使用一个隐式变步长求解器来求解 $dN/dt = Q(N)\\,N$。\n\n将精度度量定义为最终时刻的相对2-范数误差，\n$$\n\\varepsilon = \\frac{\\left\\|N_{\\mathrm{method}}(T)-N_{\\mathrm{ref}}(T)\\right\\|_2}{\\left\\|N_{\\mathrm{ref}}(T)\\right\\|_2},\n$$\n其中参考解 $N_{\\mathrm{ref}}(T)$ 定义为：\n- 在线性情况（恒定通量）下，参考解为精确解 $N_{\\mathrm{ref}}(T)=\\exp\\!\\big(T\\,Q_{\\mathrm{const}}\\big)\\,N_0$，其中 $Q_{\\mathrm{const}}=Q(N_0)$ 且 $\\kappa=0$，这使得 $Q$ 不随时间变化。\n- 在非线性反馈情况 ($\\kappa>0$) 下，参考解为采用严格容差的高精度反向微分公式 (BDF) 解。\n\n将计算成本代理指标定义如下：\n- 对于ME：反应率矩阵求值次数 $n_Q$ 和矩阵指数求值次数 $n_{\\exp}$。\n- 对于PC：反应率矩阵求值次数 $n_Q$ 和矩阵指数求值次数 $n_{\\exp}$。\n- 对于BDF：求解器报告的右端项求值次数 $n_{\\mathrm{fev}}$ 和雅可比矩阵求值次数 $n_{\\mathrm{jev}}$。\n\n所有物理单位必须保持一致：数密度单位为原子数/立方厘米，通量单位为中子数/（平方厘米·秒），截面单位为平方厘米，时间单位为秒。所有数值输出均表示为浮点数，其中精度度量如上定义（无量纲），计算成本代理指标为整数计数。\n\n实现您的程序以运行以下测试组，每个测试由 $(N_0,\\phi_0,\\kappa,T,\\Delta t)$ 以及固定的微观截面和衰变参数指定：\n\n所有测试的固定参数：\n- $\\sigma_{F,a} = 6\\times 10^{-24}$，$\\sigma_{F,f} = 5.85\\times 10^{-22}$，$\\sigma_{M,a} = 2\\times 10^{-24}$，$\\sigma_{X,a} = 2\\times 10^{-18}$。\n- $\\lambda_F = 0$，$\\lambda_M = 1\\times 10^{-6}$，$\\lambda_X = 2.1\\times 10^{-5}$。\n- $b_{M\\rightarrow F} = 0.5$，$y_X = 3\\times 10^{-3}$。\n\n测试用例：\n- 用例A（线性，恒定通量基准）：$N_0 = [5\\times 10^{20},\\,2\\times 10^{20},\\,1\\times 10^{16}]^\\top$，$\\phi_0 = 1\\times 10^{14}$，$\\kappa=0$，$T=3.6\\times 10^{3}$，$\\Delta t = 6.0\\times 10^{2}$。\n- 用例B（非线性，弱反馈）：$N_0 = [5\\times 10^{20},\\,2\\times 10^{20},\\,1\\times 10^{16}]^\\top$，$\\phi_0 = 1\\times 10^{14}$，$\\kappa=1\\times 10^{-21}$，$T=3.6\\times 10^{3}$，$\\Delta t = 6.0\\times 10^{2}$。\n- 用例C（非线性，强毒化效应导致的刚性问题）：$N_0 = [5\\times 10^{20},\\,2\\times 10^{20},\\,1\\times 10^{16}]^\\top$，$\\phi_0 = 3\\times 10^{14}$，$\\kappa=5\\times 10^{-21}$，$T=3.6\\times 10^{3}$，$\\Delta t = 6.0\\times 10^{1}$。\n\n对每个用例，计算：\n- ME方法的最终时刻相对误差 $\\varepsilon_{\\mathrm{ME}}$、$n_Q$ 和 $n_{\\exp}$。\n- PC方法的最终时刻相对误差 $\\varepsilon_{\\mathrm{PC}}$、$n_Q$ 和 $n_{\\exp}$。\n- BDF方法的最终时刻相对误差 $\\varepsilon_{\\mathrm{BDF}}$、$n_{\\mathrm{fev}}$ 和 $n_{\\mathrm{jev}}$（使用中等容差）。\n\n在非线性情况下，BDF参考解使用严格容差，相对容差为 $10^{-10}$，绝对容差为每个分量 $10^{-12}$；用于比较的BDF方法使用中等容差，相对容差为 $10^{-8}$，绝对容差为每个分量 $10^{-10}$。线性情况的参考解应使用前述的精确矩阵指数解。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素本身也是一个列表，对应一个测试用例\n$$\n\\big[\\varepsilon_{\\mathrm{ME}},\\,n_{Q,\\mathrm{ME}},\\,n_{\\exp,\\mathrm{ME}},\\,\\varepsilon_{\\mathrm{PC}},\\,n_{Q,\\mathrm{PC}},\\,n_{\\exp,\\mathrm{PC}},\\,\\varepsilon_{\\mathrm{BDF}},\\,n_{\\mathrm{fev,BDF}},\\,n_{\\mathrm{jev,BDF}}\\big].\n$$\n打印的列表不含空格（例如，$[[\\dots],[\\dots],[\\dots]]$）。",
            "solution": "所提出的问题是为一个模拟简化核反应堆环境中核素燃耗的耦合非线性常微分方程 (ODE) 系统，实现并比较三种数值时间积分方案。该问题在科学上是一致的、适定的，并为进行严格的计算分析提供了所有必要的数据和规范。评估标准在精度和计算成本代理指标方面有明确的定义。因此，该问题是有效的，下面给出完整解法。\n\n系统动力学由以下向量方程描述：\n$$\n\\frac{d}{dt} N(t) = Q\\big(N(t)\\big) N(t)\n$$\n其中 $N(t) = [N_F(t), N_M(t), N_X(t)]^\\top$ 是易裂变核素 ($F$)、中间核素 ($M$) 和毒物核素 ($X$) 的数密度向量。演化过程由依赖于状态的反应率矩阵 $Q(N)$ 控制，其元素是物理常数和中子通量 $\\phi(N)$ 的函数，该中子通量表现出对毒物核素浓度 $N_X$ 的反馈：\n$$\n\\phi(N) = \\frac{\\phi_0}{1 + \\kappa N_X}\n$$\n各个ODE方程如下：\n$$\n\\begin{aligned}\n\\frac{dN_F}{dt} = -\\big(\\sigma_{F,a}+\\sigma_{F,f}\\big)\\,\\phi(N)\\,N_F - \\lambda_F\\,N_F + b_{M\\rightarrow F}\\,\\lambda_M\\,N_M \\\\\n\\frac{dN_M}{dt} = +\\sigma_{F,a}\\,\\phi(N)\\,N_F - \\sigma_{M,a}\\,\\phi(N)\\,N_M - \\lambda_M\\,N_M \\\\\n\\frac{dN_X}{dt} = +y_X\\,\\sigma_{F,f}\\,\\phi(N)\\,N_F - \\sigma_{X,a}\\,\\phi(N)\\,N_X - \\lambda_X\\,N_X\n\\end{aligned}\n$$\n由此，可以构建 $3 \\times 3$ 的反应率矩阵 $Q(N)$ 如下：\n$$\nQ(N) =\n\\begin{pmatrix}\n-\\left(\\sigma_{F,a}+\\sigma_{F,f}\\right)\\phi(N) - \\lambda_F  b_{M\\rightarrow F}\\lambda_M  0 \\\\\n\\sigma_{F,a}\\phi(N)  -\\sigma_{M,a}\\phi(N) - \\lambda_M  0 \\\\\ny_X\\sigma_{F,f}\\phi(N)  0  -\\sigma_{X,a}\\phi(N) - \\lambda_X\n\\end{pmatrix}\n$$\n任务涉及使用三种不同的方法求解这个从 $t=0$ 到 $t=T$ 的初值问题（给定 $N(0)=N_0$），并比较它们的性能。\n\n1.  **冻结反应率矩阵指数法 (ME)**：这是一种一阶显式方法。对于从 $t_k$ 到 $t_{k+1}$ 的每个时长为 $\\Delta t$ 的时间步，假设反应率矩阵 $Q$ 在步初是恒定的，即 $Q_k = Q(N_k)$。然后使用矩阵指数推进求解：\n    $$\n    N_{k+1} = \\exp\\left(\\Delta t \\, Q_k\\right) N_k\n    $$\n    一步的计算成本是一次 $Q(N)$ 的求值和一次矩阵指数的计算。\n\n2.  **预测-校正燃耗法 (PC)**：这是一种二阶显式方法，旨在提高 ME 方法的精度。每个时间步包括两个阶段：\n    -   **预测阶段**：使用 ME 方法计算一个中间状态 $N^{\\mathrm{pred}}$：\n        $$\n        N^{\\mathrm{pred}} = \\exp\\left(\\Delta t \\, Q(N_k)\\right) N_k\n        $$\n    -   **校正阶段**：通过对步初和预测的步末的反应率进行平均，形成一个新的、更精确的反应率矩阵 $Q_{\\mathrm{avg}}$：\n        $$\n        Q_{\\mathrm{avg}} = \\frac{1}{2}\\left(Q(N_k) + Q(N^{\\mathrm{pred}})\\right)\n        $$\n        然后使用这个平均矩阵，再次从 $N_k$ 开始计算该时间步的最终状态：\n        $$\n        N_{k+1} = \\exp\\left(\\Delta t \\, Q_{\\mathrm{avg}}\\right) N_k\n        $$\n    一步的成本是两次 $Q(N)$ 的求值和两次矩阵指数的计算。\n\n3.  **反向微分公式 (BDF)**：这代表了一类隐式、变步长、多步法，非常适合求解刚性常微分方程。我们将使用一个高质量的程序库实现 (`scipy.integrate.solve_ivp` 并设置 `method='BDF'`)。该求解器会自动调整其内部步长以满足指定的误差容差，这使其与固定步长的 ME 和 PC 方法有本质上的不同。其成本由求解器报告的右端项函数求值次数（$n_{\\mathrm{fev}}$）和雅可比矩阵求值次数（$n_{\\mathrm{jev}}$）来衡量。\n\n比较基于最终时间 $T$ 的相对 $L_2$-范数误差度量：\n$$\n\\varepsilon = \\frac{\\left\\|N_{\\mathrm{method}}(T)-N_{\\mathrm{ref}}(T)\\right\\|_2}{\\left\\|N_{\\mathrm{ref}}(T)\\right\\|_2}\n$$\n对于每种情况，都会生成一个高保真度的参考解 $N_{\\mathrm{ref}}(T)$。在线性情况（$\\kappa=0$）下，$Q$ 是恒定的，精确解为 $N(T) = \\exp(T Q) N_0$。在非线性情况（$\\kappa>0$）下，使用具有非常严格容差（`rtol=1e-10`, `atol=1e-12`）的 BDF 解作为参考。\n\n实现过程将首先根据问题参数定义一个用于构建 $Q(N)$ 的函数。然后，用独立的函数实现 ME、PC 和 BDF 求解方案。主程序将遍历指定的测试用例，计算参考解，运行这三种方法中的每一种，并计算它们各自的精度和成本指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Implements and compares three time-integration strategies for a simplified\n    nuclear reactor nuclide depletion problem.\n    \"\"\"\n    \n    # Fixed physical parameters for all test cases\n    params = {\n        'sigma_F_a': 6e-24,\n        'sigma_F_f': 5.85e-22,\n        'sigma_M_a': 2e-24,\n        'sigma_X_a': 2e-18,\n        'lambda_F': 0.0,\n        'lambda_M': 1e-6,\n        'lambda_X': 2.1e-5,\n        'b_M_to_F': 0.5,\n        'y_X': 3e-3\n    }\n\n    # Test case definitions: (N0, phi0, kappa, T, dt)\n    test_cases = [\n        # Case A: linear, constant flux baseline\n        {'N0': np.array([5e20, 2e20, 1e16]), 'phi0': 1e14, 'kappa': 0.0,\n         'T': 3.6e3, 'dt': 6.0e2},\n        # Case B: nonlinear, mild feedback\n        {'N0': np.array([5e20, 2e20, 1e16]), 'phi0': 1e14, 'kappa': 1e-21,\n         'T': 3.6e3, 'dt': 6.0e2},\n        # Case C: nonlinear, stiff with strong poisoning\n        {'N0': np.array([5e20, 2e20, 1e16]), 'phi0': 3e14, 'kappa': 5e-21,\n         'T': 3.6e3, 'dt': 6.0e1},\n    ]\n\n    # Helper function to get the rate matrix Q(N)\n    def get_Q(N, phi0, kappa, p):\n        N_X = N[2]\n        flux = phi0 / (1.0 + kappa * N_X)\n        \n        Q = np.zeros((3, 3))\n        \n        # dN_F/dt terms\n        Q[0, 0] = -(p['sigma_F_a'] + p['sigma_F_f']) * flux - p['lambda_F']\n        Q[0, 1] = p['b_M_to_F'] * p['lambda_M']\n        \n        # dN_M/dt terms\n        Q[1, 0] = p['sigma_F_a'] * flux\n        Q[1, 1] = -p['sigma_M_a'] * flux - p['lambda_M']\n        \n        # dN_X/dt terms\n        Q[2, 0] = p['y_X'] * p['sigma_F_f'] * flux\n        Q[2, 2] = -p['sigma_X_a'] * flux - p['lambda_X']\n        \n        return Q\n\n    # Right-hand side function for ODE solver\n    def rhs(t, N, phi0, kappa, p):\n        Q = get_Q(N, phi0, kappa, p)\n        return Q @ N\n\n    # Error calculation function\n    def calculate_relative_error(N_method, N_ref):\n        return np.linalg.norm(N_method - N_ref) / np.linalg.norm(N_ref)\n\n    all_results = []\n    for case in test_cases:\n        N0, phi0, kappa, T, dt = case['N0'], case['phi0'], case['kappa'], case['T'], case['dt']\n\n        # --- Generate Reference Solution ---\n        if kappa == 0:  # Linear case\n            Q_const = get_Q(N0, phi0, kappa, params)\n            N_ref = expm(T * Q_const) @ N0\n        else:  # Nonlinear case\n            sol_ref = solve_ivp(\n                lambda t, y: rhs(t, y, phi0, kappa, params),\n                (0, T), N0, method='BDF', rtol=1e-10, atol=1e-12\n            )\n            N_ref = sol_ref.y[:, -1]\n\n        # --- 1. Matrix Exponential (ME) Method ---\n        N_me = N0.copy()\n        num_steps = int(round(T / dt))\n        n_Q_me, n_exp_me = 0, 0\n        for _ in range(num_steps):\n            Q_k = get_Q(N_me, phi0, kappa, params)\n            n_Q_me += 1\n            N_me = expm(dt * Q_k) @ N_me\n            n_exp_me += 1\n        eps_me = calculate_relative_error(N_me, N_ref)\n\n        # --- 2. Predictor-Corrector (PC) Method ---\n        N_pc = N0.copy()\n        n_Q_pc, n_exp_pc = 0, 0\n        for _ in range(num_steps):\n            Q_k = get_Q(N_pc, phi0, kappa, params)\n            n_Q_pc += 1\n            \n            N_pred = expm(dt * Q_k) @ N_pc\n            n_exp_pc += 1\n            \n            Q_pred = get_Q(N_pred, phi0, kappa, params)\n            n_Q_pc += 1\n            \n            Q_avg = 0.5 * (Q_k + Q_pred)\n            N_pc = expm(dt * Q_avg) @ N_pc\n            n_exp_pc += 1\n        eps_pc = calculate_relative_error(N_pc, N_ref)\n\n        # --- 3. BDF Method ---\n        sol_bdf = solve_ivp(\n            lambda t, y: rhs(t, y, phi0, kappa, params),\n            (0, T), N0, method='BDF', rtol=1e-8, atol=1e-10\n        )\n        N_bdf = sol_bdf.y[:, -1]\n        eps_bdf = calculate_relative_error(N_bdf, N_ref)\n        n_fev_bdf = sol_bdf.nfev\n        n_jev_bdf = sol_bdf.njev\n\n        case_results = [\n            eps_me, n_Q_me, n_exp_me,\n            eps_pc, n_Q_pc, n_exp_pc,\n            eps_bdf, n_fev_bdf, n_jev_bdf,\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    outer_list_str = []\n    for case_res in all_results:\n        inner_list_str = f\"[{','.join(f'{val:.6e}' if isinstance(val, float) else str(val) for val in case_res)}]\"\n        outer_list_str.append(inner_list_str)\n    \n    print(f\"[{','.join(outer_list_str)}]\")\n\nsolve()\n```"
        }
    ]
}