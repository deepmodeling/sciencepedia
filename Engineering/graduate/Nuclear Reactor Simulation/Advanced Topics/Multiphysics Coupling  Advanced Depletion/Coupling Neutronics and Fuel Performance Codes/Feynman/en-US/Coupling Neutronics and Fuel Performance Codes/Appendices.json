{
    "hands_on_practices": [
        {
            "introduction": "A fundamental challenge in multiphysics coupling is deciding the level of detail at which information is exchanged between codes. This practice directly contrasts a high-fidelity, pin-resolved power mapping with a computationally cheaper, assembly-averaged approach. By implementing a simplified thermal model, you will quantify the error introduced by homogenization and understand its critical safety implications, as this exercise demonstrates how averaging can lead to a non-conservative underestimation of peak fuel temperatures .",
            "id": "4219856",
            "problem": "You are tasked with constructing a simplified but scientifically sound coupling between neutronics and fuel performance for a cylindrical fuel pin and comparing two mapping strategies: pin-resolved power mapping versus assembly-homogenized coupling. Starting from first principles, derive and implement the temperature model needed to predict the peak centerline temperature under steady-state conditions, and then quantify the error in peak temperature prediction when assembly-homogenized coupling is used instead of pin-resolved mapping.\n\nUse the following fundamental base:\n\n- Fourier’s law of heat conduction: $q_r = -k \\, \\frac{dT}{dr}$.\n- Steady-state energy conservation with uniform volumetric heat generation in a cylinder of radius $R$: $$\\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{dT}{dr}\\right) + \\frac{q''' }{k} = 0.$$\n- Uniform volumetric heat generation related to linear heat rate: $$q''' = \\frac{q'}{\\pi R^2}, \\quad \\text{with} \\quad q' = \\frac{P}{L},$$ where $P$ is the pin power and $L$ is the active length of the fuel.\n\nUnder steady-state conditions and assuming concentric cylindrical fuel ($r_f$), gas gap ($r_g$), and cladding ($r_{c,\\text{in}}$ to $r_{c,\\text{out}}$), and external convection to coolant at temperature $T_{\\infty}$ with heat transfer coefficient $h$, the centerline temperature $T(0)$ can be expressed via a thermal resistance network:\n- Fuel internal temperature rise due to volumetric generation: $$\\Delta T_{\\text{fuel}} = \\frac{q'}{4 \\pi k_f}.$$\n- Gap conduction linear resistance: $$R_{\\text{gap}} = \\frac{\\ln\\left(\\frac{r_g}{r_f}\\right)}{2 \\pi k_g}.$$\n- Cladding conduction linear resistance: $$R_{\\text{clad}} = \\frac{\\ln\\left(\\frac{r_{c,\\text{out}}}{r_{c,\\text{in}}}\\right)}{2 \\pi k_c}.$$\n- External convection linear resistance: $$R_{\\text{conv}} = \\frac{1}{2 \\pi r_{c,\\text{out}} h}.$$\n\nThe centerline temperature for a given pin with linear heat rate $q'$ is:\n$$T(0) = T_{\\infty} + q' \\left( R_{\\text{conv}} + R_{\\text{clad}} + R_{\\text{gap}} \\right) + \\frac{q'}{4 \\pi k_f}.$$\n\nDefine two coupling strategies:\n1. Pin-resolved mapping: use each pin’s actual power $P_i$ to compute its linear heat rate $q'_i = \\frac{P_i}{L}$ and its centerline temperature $T_i(0)$, then determine the peak temperature $T_{\\text{peak,true}} = \\max_i T_i(0)$.\n2. Assembly-homogenized coupling: compute the assembly-average power $\\bar{P} = \\frac{1}{N}\\sum_{i=1}^{N} P_i$ for $N$ pins, assign $\\bar{P}$ to every pin, compute the corresponding uniform centerline temperature $T_{\\text{avg}}(0)$, and take $T_{\\text{peak,homo}} = T_{\\text{avg}}(0)$.\n\nFor each test case below, quantify the absolute error in peak temperature prediction as:\n$$E = \\left| T_{\\text{peak,homo}} - T_{\\text{peak,true}} \\right|.$$\n\nAll computations must be performed using the specified physical constants and units. Express the final error values in Kelvin ($\\text{K}$), rounded to three decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[E_1,E_2,E_3,E_4]$).\n\nUse the following common geometry and material properties for all cases:\n- Fuel radius: $r_f = 4.10 \\times 10^{-3} \\ \\text{m}$.\n- Gap outer radius: $r_g = 4.185 \\times 10^{-3} \\ \\text{m}$.\n- Cladding inner radius: $r_{c,\\text{in}} = 4.185 \\times 10^{-3} \\ \\text{m}$.\n- Cladding outer radius: $r_{c,\\text{out}} = 4.785 \\times 10^{-3} \\ \\text{m}$.\n- Fuel thermal conductivity: $k_f = 3.0 \\ \\text{W} \\, \\text{m}^{-1} \\, \\text{K}^{-1}$.\n- Gap (helium) thermal conductivity: $k_g = 0.3 \\ \\text{W} \\, \\text{m}^{-1} \\, \\text{K}^{-1}$.\n- Cladding (zirconium alloy) thermal conductivity: $k_c = 16.0 \\ \\text{W} \\, \\text{m}^{-1} \\, \\text{K}^{-1}$.\n- Active fuel length: $L = 3.7 \\ \\text{m}$.\n- Coolant temperature: $T_{\\infty} = 580.0 \\ \\text{K}$.\n\nTest Suite:\n- Case $1$ (happy path): $3 \\times 3$ pin powers in watts,\n$$\\begin{bmatrix}\n12000 & 10000 & 9000 \\\\\n8000 & 15000 & 8000 \\\\\n7000 & 10000 & 9000\n\\end{bmatrix}, \\quad h = 1.20 \\times 10^{4} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n- Case $2$ (uniform boundary case): $3 \\times 3$ pin powers in watts,\n$$\\begin{bmatrix}\n10000 & 10000 & 10000 \\\\\n10000 & 10000 & 10000 \\\\\n10000 & 10000 & 10000\n\\end{bmatrix}, \\quad h = 1.20 \\times 10^{4} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n- Case $3$ (extreme peak edge case): $3 \\times 3$ pin powers in watts,\n$$\\begin{bmatrix}\n5000 & 5000 & 5000 \\\\\n5000 & 25000 & 5000 \\\\\n5000 & 5000 & 5000\n\\end{bmatrix}, \\quad h = 1.20 \\times 10^{4} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n- Case $4$ (low cooling edge case): same pin powers as Case $1$, but\n$$h = 5.00 \\times 10^{3} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n\nRequired final output format:\n- Your program must compute $E$ for each case in the test suite and print a single line containing a list in the format $[E_1,E_2,E_3,E_4]$, where each $E_i$ is rounded to three decimal places and expressed in Kelvin ($\\text{K}$).",
            "solution": "The problem of coupling neutronics and fuel performance codes is central to high-fidelity nuclear reactor simulation. This task requires a critical evaluation of two common coupling strategies by quantifying the error introduced by a computationally cheaper, but less accurate, homogenization approach. The analysis is founded upon first principles of heat transfer.\n\nThe physical model is a cylindrical fuel pin under steady-state conditions. The governing equation for the temperature distribution $T(r)$ within the fuel pellet (from radius $r=0$ to $r=r_f$) is the heat conduction equation with a uniform volumetric heat source $q'''$:\n$$\n\\frac{1}{r}\\frac{d}{dr}\\left(r k_f \\frac{dT}{dr}\\right) + q''' = 0\n$$\nAssuming constant fuel thermal conductivity $k_f$, this can be written as:\n$$\n\\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{dT}{dr}\\right) + \\frac{q'''}{k_f} = 0\n$$\nThe volumetric heat generation $q'''$ is related to the pin's linear heat rate $q'$ (power per unit length, $P/L$) by $q''' = \\frac{q'}{\\pi r_f^2}$. Integrating the heat equation twice with boundary conditions of symmetry at the centerline ($\\frac{dT}{dr}|_{r=0} = 0$) and a known temperature at the fuel surface $T(r_f)$, one obtains the temperature drop across the fuel pellet:\n$$\n\\Delta T_{\\text{fuel}} = T(0) - T(r_f) = \\frac{q''' r_f^2}{4k_f} = \\frac{(q'/\\pi r_f^2) r_f^2}{4k_f} = \\frac{q'}{4 \\pi k_f}\n$$\nThis term represents the internal temperature rise within the heat-generating medium.\n\nThe remainder of the system consists of passive layers through which heat is conducted and convected away. These are modeled using a thermal resistance network. The total heat rate per unit length, $q'$, remains constant through the gap, cladding, and convective boundary layer. The temperature drops across these layers are:\n1.  **Gas Gap**: Modeled as conduction through a cylindrical shell from $r_f$ to $r_g$. The temperature drop is $\\Delta T_{\\text{gap}} = q' R_{\\text{gap}}$, where the linear thermal resistance is $R_{\\text{gap}} = \\frac{\\ln(r_g/r_f)}{2 \\pi k_g}$.\n2.  **Cladding**: Modeled as conduction through a cylindrical shell from $r_{c,\\text{in}}$ to $r_{c,\\text{out}}$. The temperature drop is $\\Delta T_{\\text{clad}} = q' R_{\\text{clad}}$, with resistance $R_{\\text{clad}} = \\frac{\\ln(r_{c,\\text{out}}/r_{c,\\text{in}})}{2 \\pi k_c}$.\n3.  **Coolant Convection**: Modeled by Newton's law of cooling at the outer cladding surface. The temperature drop is $\\Delta T_{\\text{conv}} = q' R_{\\text{conv}}$, with resistance $R_{\\text{conv}} = \\frac{1}{2 \\pi r_{c,\\text{out}} h}$.\n\nThe centerline temperature $T(0)$ is the sum of the bulk coolant temperature $T_{\\infty}$ and all sequential temperature drops:\n$$\nT(0) = T_{\\infty} + \\Delta T_{\\text{conv}} + \\Delta T_{\\text{clad}} + \\Delta T_{\\text{gap}} + \\Delta T_{\\text{fuel}}\n$$\nSubstituting the expressions for each term yields the provided formula:\n$$\nT(0) = T_{\\infty} + q' \\left( R_{\\text{conv}} + R_{\\text{clad}} + R_{\\text{gap}} \\right) + \\frac{q'}{4 \\pi k_f}\n$$\nThis equation can be simplified to a linear relationship between $T(0)$ and $q'$:\n$$\nT(0) = T_{\\infty} + q' \\left( \\frac{1}{2 \\pi r_{c,\\text{out}} h} + \\frac{\\ln(r_{c,\\text{out}}/r_{c,\\text{in}})}{2 \\pi k_c} + \\frac{\\ln(r_g/r_f)}{2 \\pi k_g} + \\frac{1}{4 \\pi k_f} \\right)\n$$\nLet the term in the parenthesis be the total thermal coefficient $A(h)$. Then, $T(0) = T_{\\infty} + A(h) \\cdot q'$. Since temperature is a linear function of the linear heat rate $q'$, the peak temperature will always correspond to the pin with the maximum linear heat rate $q'_{\\text{max}}$.\n\nThe two coupling strategies are evaluated as follows:\n1.  **Pin-resolved mapping**: This is the physically correct approach within this model's assumptions. The power $P_i$ of each pin $i$ is used to calculate its specific linear heat rate $q'_i = P_i/L$. The temperatures $T_i(0)$ are calculated for all pins, and the true peak temperature is the maximum among them: $T_{\\text{peak,true}} = \\max_i(T_i(0))$. This corresponds to the pin with the maximum power, $P_{\\text{max}}$, and thus maximum linear heat rate, $q'_{\\text{max}}$.\n    $$ T_{\\text{peak,true}} = T_{\\infty} + A(h) \\cdot q'_{\\text{max}} = T_{\\infty} + A(h) \\cdot \\frac{P_{\\text{max}}}{L} $$\n2.  **Assembly-homogenized coupling**: This is an approximation where the detailed pin power distribution is ignored. The assembly-average power, $\\bar{P} = \\frac{1}{N}\\sum_{i=1}^{N} P_i$, is calculated and assigned to every pin. This results in a single, uniform linear heat rate $\\bar{q}' = \\bar{P}/L$ and a single temperature value $T_{\\text{avg}}(0)$, which is taken as the peak: $T_{\\text{peak,homo}} = T_{\\text{avg}}(0)$.\n    $$ T_{\\text{peak,homo}} = T_{\\infty} + A(h) \\cdot \\bar{q}' = T_{\\infty} + A(h) \\cdot \\frac{\\bar{P}}{L} $$\n\nThe error, $E = \\left| T_{\\text{peak,homo}} - T_{\\text{peak,true}} \\right|$, quantifies the discrepancy. Substituting the expressions above:\n$$\nE = \\left| \\left(T_{\\infty} + A(h) \\cdot \\frac{\\bar{P}}{L}\\right) - \\left(T_{\\infty} + A(h) \\cdot \\frac{P_{\\text{max}}}{L}\\right) \\right| = \\frac{A(h)}{L} | \\bar{P} - P_{\\text{max}} |\n$$\nSince $\\bar{P} \\le P_{\\text{max}}$, the error simplifies to $E = \\frac{A(h)}{L} (P_{\\text{max}} - \\bar{P})$. This shows that the homogenization scheme always underestimates the peak temperature when power variation exists, which is a non-conservative result for safety analysis. The magnitude of this error is directly proportional to the difference between the peak and average pin powers.\n\nThe computational procedure is to first calculate the components of the coefficient $A(h)$ for each test case. Then, for each case's power distribution, determine $P_{\\text{max}}$ and $\\bar{P}$, and finally compute the error $E$ using the derived formula.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the error in peak fuel centerline temperature prediction\n    when using assembly-homogenized coupling versus pin-resolved mapping.\n    \"\"\"\n\n    # Common physical constants and geometry\n    r_f = 4.10e-3  # Fuel radius, m\n    r_g = 4.185e-3 # Gap outer radius, m\n    r_c_in = 4.185e-3 # Cladding inner radius, m\n    r_c_out = 4.785e-3 # Cladding outer radius, m\n    k_f = 3.0     # Fuel thermal conductivity, W/m-K\n    k_g = 0.3     # Gap thermal conductivity, W/m-K\n    k_c = 16.0    # Cladding thermal conductivity, W/m-K\n    L = 3.7       # Active fuel length, m\n    T_inf = 580.0   # Coolant temperature, K\n\n    # Test cases: (pin_powers in W, h in W/m^2-K)\n    test_cases = [\n        (np.array([\n            [12000, 10000, 9000],\n            [8000, 15000, 8000],\n            [7000, 10000, 9000]\n        ]), 1.20e4),\n        (np.array([\n            [10000, 10000, 10000],\n            [10000, 10000, 10000],\n            [10000, 10000, 10000]\n        ]), 1.20e4),\n        (np.array([\n            [5000, 5000, 5000],\n            [5000, 25000, 5000],\n            [5000, 5000, 5000]\n        ]), 1.20e4),\n        (np.array([\n            [12000, 10000, 9000],\n            [8000, 15000, 8000],\n            [7000, 10000, 9000]\n        ]), 5.00e3)\n    ]\n\n    results = []\n\n    # Pre-calculate constant thermal resistance terms\n    R_gap = np.log(r_g / r_f) / (2 * np.pi * k_g)\n    R_clad = np.log(r_c_out / r_c_in) / (2 * np.pi * k_c)\n    fuel_term = 1 / (4 * np.pi * k_f)\n    \n    def calculate_centerline_temp(q_prime, h):\n        \"\"\"\n        Calculates centerline temperature for a given linear heat rate and h.\n        \n        Args:\n            q_prime (float): Linear heat rate (W/m).\n            h (float): Convective heat transfer coefficient (W/m^2-K).\n\n        Returns:\n            float: Centerline temperature (K).\n        \"\"\"\n        R_conv = 1 / (2 * np.pi * r_c_out * h)\n        temp_rise = q_prime * (R_conv + R_clad + R_gap + fuel_term)\n        return T_inf + temp_rise\n\n    for pin_powers, h in test_cases:\n        # 1. Pin-resolved mapping (true peak temperature)\n        P_max = pin_powers.max()\n        q_prime_max = P_max / L\n        T_peak_true = calculate_centerline_temp(q_prime_max, h)\n\n        # 2. Assembly-homogenized coupling\n        P_avg = pin_powers.mean()\n        q_prime_avg = P_avg / L\n        T_peak_homo = calculate_centerline_temp(q_prime_avg, h)\n\n        # 3. Quantify the error\n        error = abs(T_peak_homo - T_peak_true)\n        results.append(error)\n\n    # Format results for final output\n    formatted_results = [f'{res:.3f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once data is exchanged between codes, achieving a converged, self-consistent solution is a major numerical challenge, especially with strong feedback effects. This practice delves into the stability of the iterative process by analyzing a linearized model of power-temperature feedback. You will derive the optimal under-relaxation factor that ensures the fastest convergence, providing a key insight into how coupled systems are numerically stabilized in practice .",
            "id": "4219855",
            "problem": "A coupled neutronics–fuel performance iteration updates the core-average power based on temperature-dependent reactivity feedback and temperature based on power-dependent heat generation. Consider a quasi-static linearization about a fixed point, with the following relations between deviations from the fixed point values $\\Delta P = P - P^{\\infty}$ and $\\Delta T = T - T^{\\infty}$:\n- The fuel performance code returns temperature from power according to $\\Delta T = c\\,\\Delta P$, where $c > 0$ is the steady-state temperature rise per unit deviation in power, and $P^{\\infty}$, $T^{\\infty}$ denote the fixed point power and temperature.\n- The neutronics code returns power from temperature according to $\\Delta P_{*} = b\\,\\Delta T$, where $b < 0$ is the linear sensitivity of power to temperature due to the negative effective temperature coefficient of reactivity.\n\nThe two codes are coupled using an under-relaxed fixed-point update for power,\n$$\nP^{k+1} \\;=\\; P^{k} \\;+\\; \\omega\\big(P_{*}^{k+1} - P^{k}\\big),\n$$\nwhere $P_{*}^{k+1}$ is the neutronics-computed power from $T^{k+1}$, and $\\omega \\in (0,1]$ is the under-relaxation factor. Assume the temperature update is computed explicitly from the current power, $T^{k+1} = T^{\\infty} + c\\,(P^{k} - P^{\\infty})$, and the neutronics-computed power is $P_{*}^{k+1} = P^{\\infty} + b\\,(T^{k+1} - T^{\\infty})$.\n\nStarting from these assumptions and the definition of fixed-point iteration, derive the scalar error propagation for $\\Delta P^{k} = P^{k} - P^{\\infty}$, quantify the linear convergence rate as a function of $b$, $c$, and $\\omega$, and then determine the value of $\\omega$ in the interval $(0,1]$ that minimizes the magnitude of the convergence factor under the physically realistic sign constraints $b<0$ and $c>0$. Express your final answer as a single closed-form, dimensionless analytic expression for the optimal under-relaxation factor $\\omega$ in terms of $b$ and $c$. No numerical values are required.",
            "solution": "The problem requires the derivation of the optimal under-relaxation factor for a coupled neutronics–fuel performance fixed-point iteration. The solution will proceed by first deriving the error amplification equation, identifying the convergence factor, and then minimizing the magnitude of this factor with respect to the under-relaxation parameter $\\omega$.\n\nThe variables representing deviations from the fixed-point values $(P^{\\infty}, T^{\\infty})$ are defined as:\n$$\n\\Delta P^{k} = P^{k} - P^{\\infty}\n$$\n$$\n\\Delta T^{k} = T^{k} - T^{\\infty}\n$$\nThe iterative update for power is given by:\n$$\nP^{k+1} = P^{k} + \\omega(P_{*}^{k+1} - P^{k})\n$$\nwhere $\\omega \\in (0,1]$ is the under-relaxation factor.\n\nTo derive the error propagation equation, we subtract the fixed-point power $P^{\\infty}$ from both sides of the update equation:\n$$\nP^{k+1} - P^{\\infty} = P^{k} - P^{\\infty} + \\omega(P_{*}^{k+1} - P^{k})\n$$\nUsing the definition of the deviation $\\Delta P$, this becomes:\n$$\n\\Delta P^{k+1} = \\Delta P^{k} + \\omega(P_{*}^{k+1} - P^{k})\n$$\nWe can rewrite the term in the parentheses as:\n$$\nP_{*}^{k+1} - P^{k} = (P_{*}^{k+1} - P^{\\infty}) - (P^{k} - P^{\\infty}) = \\Delta P_{*}^{k+1} - \\Delta P^{k}\n$$\nSubstituting this back into the equation for $\\Delta P^{k+1}$ gives:\n$$\n\\Delta P^{k+1} = \\Delta P^{k} + \\omega(\\Delta P_{*}^{k+1} - \\Delta P^{k})\n$$\n$$\n\\Delta P^{k+1} = (1 - \\omega)\\Delta P^{k} + \\omega \\Delta P_{*}^{k+1}\n$$\nThis equation relates the error at iteration $k+1$ to the error at iteration $k$ and the neutronics-computed power deviation $\\Delta P_{*}^{k+1}$.\n\nNext, we must express $\\Delta P_{*}^{k+1}$ in terms of $\\Delta P^{k}$ using the given coupling relations. The problem states that the temperature and neutronics-computed power are updated as follows:\n$$\nT^{k+1} = T^{\\infty} + c(P^{k} - P^{\\infty})\n$$\n$$\nP_{*}^{k+1} = P^{\\infty} + b(T^{k+1} - T^{\\infty})\n$$\nFrom these, we can write the deviations:\n$$\n\\Delta T^{k+1} = T^{k+1} - T^{\\infty} = c(P^{k} - P^{\\infty}) = c\\,\\Delta P^{k}\n$$\n$$\n\\Delta P_{*}^{k+1} = P_{*}^{k+1} - P^{\\infty} = b(T^{k+1} - T^{\\infty}) = b\\,\\Delta T^{k+1}\n$$\nSubstituting the expression for $\\Delta T^{k+1}$ into the equation for $\\Delta P_{*}^{k+1}$ yields:\n$$\n\\Delta P_{*}^{k+1} = b(c\\,\\Delta P^{k}) = bc\\,\\Delta P^{k}\n$$\nNow, we substitute this result back into the error propagation equation for $\\Delta P^{k+1}$:\n$$\n\\Delta P^{k+1} = (1 - \\omega)\\Delta P^{k} + \\omega(bc\\,\\Delta P^{k})\n$$\n$$\n\\Delta P^{k+1} = (1 - \\omega + \\omega bc)\\Delta P^{k}\n$$\nThis is the scalar error propagation equation. The convergence of the iteration is determined by the amplification factor, or convergence factor, $\\lambda$, which is the coefficient of $\\Delta P^{k}$:\n$$\n\\lambda(\\omega) = 1 - \\omega + \\omega bc = 1 - \\omega(1 - bc)\n$$\nFor the iteration to converge, the magnitude of this factor must be less than $1$, i.e., $|\\lambda| < 1$. The linear convergence rate is given by $|\\lambda|$. To find the optimal convergence, we need to find the value of $\\omega$ in the interval $(0, 1]$ that minimizes $|\\lambda(\\omega)|$.\n\nLet $K = 1 - bc$. The problem specifies the physically realistic constraints $b < 0$ and $c > 0$. From these, the product $bc$ must be negative:\n$$\nbc < 0\n$$\nConsequently, $-bc > 0$, and the term $K$ must be greater than $1$:\n$$\nK = 1 - bc > 1\n$$\nWe seek to minimize the function $f(\\omega) = |\\lambda(\\omega)| = |1 - \\omega K|$ for $\\omega \\in (0, 1]$ and a constant $K > 1$.\n\nThe function $g(\\omega) = 1 - \\omega K$ is a linear function of $\\omega$ with a negative slope $-K$. The absolute value function $f(\\omega) = |g(\\omega)|$ is a V-shaped function with its vertex (minimum) where $g(\\omega) = 0$.\n$$\n1 - \\omega K = 0 \\implies \\omega = \\frac{1}{K}\n$$\nSince $K > 1$, the value of $\\omega$ that minimizes $|\\lambda(\\omega)|$ is:\n$$\n\\omega_{opt} = \\frac{1}{K} = \\frac{1}{1 - bc}\n$$\nWe must verify that this optimal value lies within the allowed interval $\\omega \\in (0, 1]$. Since $K > 1$, it follows that $0 < 1/K < 1$. Therefore, $\\omega_{opt} \\in (0, 1)$, which is a subset of the specified interval $(0, 1]$.\nAt this optimal value, the convergence factor is $\\lambda(\\omega_{opt}) = 1 - \\omega_{opt}K = 1 - (1/K)K = 0$, which provides the fastest possible convergence (in one step, for this linearized system).\n\nThe optimal under-relaxation factor is thus given by the derived expression in terms of $b$ and $c$.",
            "answer": "$$\\boxed{\\frac{1}{1 - bc}}$$"
        },
        {
            "introduction": "Moving from steady-state to transient analysis introduces new challenges related to time integration, stability, and the preservation of physical laws. This exercise investigates how the choice of a discrete time-stepping scheme can introduce spurious oscillations and violate fundamental principles like the conservation of energy. By implementing and comparing different explicit and implicit coupling strategies, you will understand why stabilized, energy-preserving methods are crucial for obtaining physically meaningful results in transient simulations .",
            "id": "4219907",
            "problem": "Consider a simplified, physically consistent, two-field coupling that captures the essence of neutronics–fuel performance interaction in a nuclear reactor transient. Let the neutronics be represented by point kinetics with Doppler feedback, and let the fuel performance be represented by a lumped thermal energy balance. Denote the dimensionless power perturbation by $x(t) = \\delta P(t) / P^\\star$, where $P^\\star$ is the nominal steady-state power, and the fuel temperature perturbation by $y(t) = T_f(t) - T_f^\\star$, where $T_f^\\star$ is the steady-state fuel temperature. The nominal power $P^\\star$ is assumed constant and strictly positive. The continuous-time model linearized about the steady state is given by\n$$\n\\frac{dx}{dt} = \\frac{\\alpha_D}{\\Lambda} \\, y,\n\\qquad\nC_f \\, \\frac{dy}{dt} = P^\\star \\, x - H \\, y,\n$$\nwhere $C_f$ is the effective fuel heat capacity, $H$ is the lumped heat removal coefficient, $\\Lambda$ is the neutron generation time, and $\\alpha_D$ is the Doppler reactivity coefficient (negative). The energy balance over an interval $[t_n, t_{n+1}]$ is\n$$\nC_f \\, \\big( y(t_{n+1}) - y(t_n) \\big)\n= \\int_{t_n}^{t_{n+1}} P^\\star \\, x(t) \\, dt \\;-\\; \\int_{t_n}^{t_{n+1}} H \\, y(t) \\, dt.\n$$\n\nWe investigate spurious oscillations arising from loose coupling and propose a stabilization that preserves the energy balance. Consider a fixed time step $\\Delta t = t_{n+1} - t_n$ and three discrete coupling schemes:\n\n- Loosely coupled Jacobi explicit scheme: both fields are advanced using lagged coupling values from $t_n$.\n- Loosely coupled Gauss–Seidel sequential explicit scheme: advance $x$ using $y(t_n)$, then advance $y$ using the updated $x$.\n- An energy-preserving averaged-coupling stabilization: enforce the trapezoidal-rule energy balance while averaging the coupling terms in the updates over $t_n$ and $t_{n+1}$.\n\nStarting from the fundamental laws and definitions given above, derive mathematically consistent discrete-time updates for $x_{n+1}$ and $y_{n+1}$ under each scheme, where $x_n = x(t_n)$ and $y_n = y(t_n)$. Using the trapezoidal approximation to the energy balance over one step, define the discrete energy residual for any scheme as\n$$\nR \\;=\\; C_f \\, (y_{n+1} - y_n) \\;-\\; \\Delta t \\, P^\\star \\, \\frac{x_n + x_{n+1}}{2} \\;+\\; \\Delta t \\, H \\, \\frac{y_n + y_{n+1}}{2},\n$$\nwhich has units of Joules. The absolute value $|R|$ quantifies violation of the energy balance due to discretization. A scheme is energy-preserving in this sense if $|R|$ is numerically equal to zero up to rounding.\n\nImplement a complete, runnable program that, for the parameter sets in the test suite below, computes the absolute discrete energy residual $|R|$ for each of the three schemes after a single time step, starting from specified initial conditions $(x_0,y_0)$, and aggregates the results into a single output line as a comma-separated list enclosed in square brackets in the order specified. No external input is allowed.\n\nUse the following test suite with scientifically plausible parameters and units:\n\n- Case A (happy path where loose coupling exhibits noticeable energy imbalance and stabilization corrects it):\n  - $P^\\star = 100 \\times 10^6 \\, \\text{W}$,\n  - $C_f = 2 \\times 10^6 \\, \\text{J/K}$,\n  - $H = 1 \\times 10^6 \\, \\text{W/K}$,\n  - $\\Lambda = 1 \\times 10^{-5} \\, \\text{s}$,\n  - $\\alpha_D = -5 \\times 10^{-5} \\, \\text{K}^{-1}$,\n  - $\\Delta t = 0.05 \\, \\text{s}$,\n  - $x_0 = 0.1$ (dimensionless),\n  - $y_0 = 0.1 \\, \\text{K}$.\n- Case B (boundary condition with small time step where explicit schemes should show smaller energy imbalance):\n  - $P^\\star = 100 \\times 10^6 \\, \\text{W}$,\n  - $C_f = 2 \\times 10^6 \\, \\text{J/K}$,\n  - $H = 1 \\times 10^6 \\, \\text{W/K}$,\n  - $\\Lambda = 1 \\times 10^{-5} \\, \\text{s}$,\n  - $\\alpha_D = -5 \\times 10^{-5} \\, \\text{K}^{-1}$,\n  - $\\Delta t = 0.001 \\, \\text{s}$,\n  - $x_0 = 0.1$,\n  - $y_0 = 0.1 \\, \\text{K}$.\n- Case C (edge case with weak Doppler feedback, testing coupling sensitivity):\n  - $P^\\star = 100 \\times 10^6 \\, \\text{W}$,\n  - $C_f = 2 \\times 10^6 \\, \\text{J/K}$,\n  - $H = 1 \\times 10^6 \\, \\text{W/K}$,\n  - $\\Lambda = 1 \\times 10^{-5} \\, \\text{s}$,\n  - $\\alpha_D = -1 \\times 10^{-6} \\, \\text{K}^{-1}$,\n  - $\\Delta t = 0.05 \\, \\text{s}$,\n  - $x_0 = 0.1$,\n  - $y_0 = 0.1 \\, \\text{K}$.\n\nFor each case, compute three floats representing $|R|$ in Joules for the schemes in this strict order: (Jacobi loose coupling, Gauss–Seidel loose coupling, energy-preserving averaged coupling). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered case-by-case and scheme-by-scheme:\n$$\n\\big[ |R|_\\text{Jacobi,A}, \\; |R|_\\text{Gauss–Seidel,A}, \\; |R|_\\text{EPAC,A}, \\; |R|_\\text{Jacobi,B}, \\; |R|_\\text{Gauss–Seidel,B}, \\; |R|_\\text{EPAC,B}, \\; |R|_\\text{Jacobi,C}, \\; |R|_\\text{Gauss–Seidel,C}, \\; |R|_\\text{EPAC,C} \\big].\n$$\nAll reported values must be expressed in Joules. The final output line must match the specified format exactly.",
            "solution": "The user-provided problem is evaluated and found to be valid. It is scientifically grounded in the principles of nuclear reactor kinetics and heat transfer, mathematically well-posed, and objectively stated. We may therefore proceed with the derivation and solution.\n\nThe problem requires the derivation and comparison of three numerical coupling schemes for a system of two coupled linear ordinary differential equations (ODEs) representing simplified reactor dynamics. The system is:\n$$\n\\frac{dx}{dt} = \\frac{\\alpha_D}{\\Lambda} y \\quad (1)\n$$\n$$\n\\frac{dy}{dt} = \\frac{P^\\star}{C_f} x - \\frac{H}{C_f} y \\quad (2)\n$$\nwhere $x(t)$ is the dimensionless power perturbation and $y(t)$ is the fuel temperature perturbation. Let $x_n = x(t_n)$ and $y_n = y(t_n)$. We seek to find expressions for $x_{n+1}$ and $y_{n+1}$ for a time step $\\Delta t = t_{n+1} - t_n$.\n\n### Scheme 1: Loosely Coupled Jacobi Explicit Scheme\n\nThis scheme uses the forward Euler method to advance each equation, where the coupling terms on the right-hand side are evaluated using values from the beginning of the time step, $t_n$.\n\nFor equation (1), the time derivative is approximated as $(x_{n+1} - x_n)/\\Delta t$, and the right-hand side is evaluated at $t_n$:\n$$\n\\frac{x_{n+1} - x_n}{\\Delta t} = \\frac{\\alpha_D}{\\Lambda} y_n\n$$\nSolving for $x_{n+1}$:\n$$\nx_{n+1} = x_n + \\Delta t \\frac{\\alpha_D}{\\Lambda} y_n\n$$\n\nSimilarly, for equation (2), the coupling term $x$ is evaluated at $t_n$:\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\frac{P^\\star}{C_f} x_n - \\frac{H}{C_f} y_n\n$$\nSolving for $y_{n+1}$:\n$$\ny_{n+1} = y_n + \\Delta t \\left( \\frac{P^\\star}{C_f} x_n - \\frac{H}{C_f} y_n \\right)\n$$\nThese two equations provide the explicit update for the Jacobi scheme.\n\n### Scheme 2: Loosely Coupled Gauss–Seidel Sequential Explicit Scheme\n\nThis scheme also uses the forward Euler method but updates the variables in a specified sequence. First, $x$ is advanced to $t_{n+1}$. Then, this newly computed value $x_{n+1}$ is used to advance $y$.\n\nStep 1: Advance $x$ using $y_n$. This is identical to the Jacobi scheme's update for $x$:\n$$\nx_{n+1} = x_n + \\Delta t \\frac{\\alpha_D}{\\Lambda} y_n\n$$\n\nStep 2: Advance $y$ using the updated value $x_{n+1}$ and the old value $y_n$:\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\frac{P^\\star}{C_f} x_{n+1} - \\frac{H}{C_f} y_n\n$$\nSolving for $y_{n+1}$:\n$$\ny_{n+1} = y_n + \\Delta t \\left( \\frac{P^\\star}{C_f} x_{n+1} - \\frac{H}{C_f} y_n \\right)\n$$\nThis scheme remains explicit as $x_{n+1}$ is computed first, then $y_{n+1}$ is computed using the result.\n\n### Scheme 3: Energy-Preserving Averaged-Coupling (EPAC) Stabilization\n\nThis scheme is based on the trapezoidal rule (or Crank-Nicolson method), which averages the right-hand side of the ODEs over the interval $[t_n, t_{n+1}]$.\n\nApplying the trapezoidal rule to equation (1):\n$$\n\\frac{x_{n+1} - x_n}{\\Delta t} = \\frac{1}{2} \\left( \\left. \\frac{dx}{dt} \\right|_n + \\left. \\frac{dx}{dt} \\right|_{n+1} \\right) = \\frac{1}{2} \\left( \\frac{\\alpha_D}{\\Lambda} y_n + \\frac{\\alpha_D}{\\Lambda} y_{n+1} \\right)\n$$\n$$\nx_{n+1} - x_n = \\frac{\\Delta t \\, \\alpha_D}{2\\Lambda} (y_n + y_{n+1}) \\quad (3)\n$$\n\nApplying the trapezoidal rule to equation (2):\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\frac{1}{2} \\left( \\left( \\frac{P^\\star}{C_f} x_n - \\frac{H}{C_f} y_n \\right) + \\left( \\frac{P^\\star}{C_f} x_{n+1} - \\frac{H}{C_f} y_{n+1} \\right) \\right)\n$$\nMultiplying by $C_f \\, \\Delta t$:\n$$\nC_f(y_{n+1} - y_n) = \\frac{\\Delta t}{2} \\left( P^\\star x_n - H y_n + P^\\star x_{n+1} - H y_{n+1} \\right)\n$$\nRearranging terms:\n$$\nC_f(y_{n+1} - y_n) - \\frac{\\Delta t \\, P^\\star}{2} (x_n + x_{n+1}) + \\frac{\\Delta t \\, H}{2} (y_n + y_{n+1}) = 0 \\quad (4)\n$$\nThis equation is identical to stating that the discrete energy residual $R$ is zero by construction. Thus, the scheme is \"energy-preserving\" in the sense defined by the problem.\n\nTo find $x_{n+1}$ and $y_{n+1}$, we must solve the coupled linear system formed by equations (3) and (4). Rearranging (3) and another form of (4) into a matrix system for the unknowns $(x_{n+1}, y_{n+1})$:\nFrom (3):\n$$\n1 \\cdot x_{n+1} - \\left(\\frac{\\Delta t \\, \\alpha_D}{2\\Lambda}\\right) y_{n+1} = x_n + \\left(\\frac{\\Delta t \\, \\alpha_D}{2\\Lambda}\\right) y_n\n$$\nFrom the trapezoidal version of (2):\n$$\n-\\left(\\frac{\\Delta t \\, P^\\star}{2C_f}\\right) x_{n+1} + \\left(1 + \\frac{\\Delta t \\, H}{2C_f}\\right) y_{n+1} = y_n - \\left(\\frac{\\Delta t \\, H}{2C_f}\\right) y_n + \\left(\\frac{\\Delta t \\, P^\\star}{2C_f}\\right) x_n\n$$\nThis forms a $2 \\times 2$ linear system $A \\mathbf{z}_{n+1} = \\mathbf{b}$, where $\\mathbf{z}_{n+1} = [x_{n+1}, y_{n+1}]^T$:\n$$\nA = \\begin{pmatrix} 1 & -\\frac{\\Delta t \\, \\alpha_D}{2\\Lambda} \\\\ -\\frac{\\Delta t \\, P^\\star}{2C_f} & 1 + \\frac{\\Delta t \\, H}{2C_f} \\end{pmatrix}\n$$\n$$\n\\mathbf{b} = \\begin{pmatrix} x_n + \\frac{\\Delta t \\, \\alpha_D}{2\\Lambda} y_n \\\\ (1 - \\frac{\\Delta t \\, H}{2C_f})y_n + \\frac{\\Delta t \\, P^\\star}{2C_f} x_n \\end{pmatrix}\n$$\nThis system can be solved for $x_{n+1}$ and $y_{n+1}$ at each time step.\n\n### Discrete Energy Residual Calculation\n\nFor any of the three schemes, once the state $(x_{n+1}, y_{n+1})$ is computed from $(x_n, y_n)$, the discrete energy residual $R$ is calculated using the provided formula:\n$$\nR = C_f (y_{n+1} - y_n) - \\Delta t P^\\star \\frac{x_n + x_{n+1}}{2} + \\Delta t H \\frac{y_n + y_{n+1}}{2}\n$$\nThe problem asks for $|R|$. For the EPAC scheme, $|R|$ is expected to be numerically zero, subject to floating-point precision limitations.\n\nThe algorithm is to apply each of the test cases to the three derived schemes. For each scheme, we perform one time step from $(x_0, y_0)$ to get $(x_1, y_1)$, and then compute the corresponding $|R|$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating discrete energy residuals for three different\n    coupling schemes in a simplified reactor dynamics model.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Happy path\n        {\n            \"P_star\": 100e6,   # W\n            \"C_f\": 2e6,        # J/K\n            \"H\": 1e6,          # W/K\n            \"Lambda\": 1e-5,    # s\n            \"alpha_D\": -5e-5,  # K^-1\n            \"dt\": 0.05,        # s\n            \"x0\": 0.1,         # dimensionless\n            \"y0\": 0.1,         # K\n        },\n        # Case B: Small time step\n        {\n            \"P_star\": 100e6,\n            \"C_f\": 2e6,\n            \"H\": 1e6,\n            \"Lambda\": 1e-5,\n            \"alpha_D\": -5e-5,\n            \"dt\": 0.001,\n            \"x0\": 0.1,\n            \"y0\": 0.1,\n        },\n        # Case C: Weak Doppler feedback\n        {\n            \"P_star\": 100e6,\n            \"C_f\": 2e6,\n            \"H\": 1e6,\n            \"Lambda\": 1e-5,\n            \"alpha_D\": -1e-6,  # K^-1\n            \"dt\": 0.05,\n            \"x0\": 0.1,\n            \"y0\": 0.1,\n        }\n    ]\n\n    results = []\n\n    def calculate_residual(params, x1, y1):\n        \"\"\"Calculates the absolute discrete energy residual |R|.\"\"\"\n        C_f, P_star, H, dt = params[\"C_f\"], params[\"P_star\"], params[\"H\"], params[\"dt\"]\n        x0, y0 = params[\"x0\"], params[\"y0\"]\n        \n        R = C_f * (y1 - y0) - dt * P_star * (x0 + x1) / 2.0 + dt * H * (y0 + y1) / 2.0\n        return abs(R)\n\n    for case in test_cases:\n        # Unpack parameters\n        P_star = case[\"P_star\"]\n        C_f = case[\"C_f\"]\n        H = case[\"H\"]\n        Lambda = case[\"Lambda\"]\n        alpha_D = case[\"alpha_D\"]\n        dt = case[\"dt\"]\n        x0 = case[\"x0\"]\n        y0 = case[\"y0\"]\n\n        # --- Scheme 1: Loosely coupled Jacobi explicit ---\n        x1_jac = x0 + dt * (alpha_D / Lambda) * y0\n        y1_jac = y0 + dt * ((P_star / C_f) * x0 - (H / C_f) * y0)\n        R_jac = calculate_residual(case, x1_jac, y1_jac)\n        results.append(R_jac)\n\n        # --- Scheme 2: Loosely coupled Gauss-Seidel sequential explicit ---\n        x1_gs = x0 + dt * (alpha_D / Lambda) * y0\n        y1_gs = y0 + dt * ((P_star / C_f) * x1_gs - (H / C_f) * y0)\n        R_gs = calculate_residual(case, x1_gs, y1_gs)\n        results.append(R_gs)\n\n        # --- Scheme 3: Energy-preserving averaged-coupling (EPAC) ---\n        # Set up the linear system A * z1 = b, where z1 = [x1, y1]^T\n        A = np.zeros((2, 2))\n        b = np.zeros(2)\n\n        A[0, 0] = 1.0\n        A[0, 1] = -0.5 * dt * alpha_D / Lambda\n        A[1, 0] = -0.5 * dt * P_star / C_f\n        A[1, 1] = 1.0 + 0.5 * dt * H / C_f\n\n        b[0] = x0 + 0.5 * dt * alpha_D / Lambda * y0\n        b[1] = (1.0 - 0.5 * dt * H / C_f) * y0 + (0.5 * dt * P_star / C_f) * x0\n\n        # Solve for x1_epac, y1_epac\n        try:\n            z1 = np.linalg.solve(A, b)\n            x1_epac = z1[0]\n            y1_epac = z1[1]\n            R_epac = calculate_residual(case, x1_epac, y1_epac)\n        except np.linalg.LinAlgError:\n            # Should not happen for these parameters\n            x1_epac, y1_epac, R_epac = np.nan, np.nan, np.nan\n        \n        results.append(R_epac)\n\n    # Format the final output line\n    print(f\"[{','.join(f'{r:.12g}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}