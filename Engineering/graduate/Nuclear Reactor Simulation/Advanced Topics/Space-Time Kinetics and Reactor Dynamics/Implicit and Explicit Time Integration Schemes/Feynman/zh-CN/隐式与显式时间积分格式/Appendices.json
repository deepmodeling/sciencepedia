{
    "hands_on_practices": [
        {
            "introduction": "核反应堆系统常涉及跨越多个数量级的时间尺度，这导致了数值计算中的“刚性”问题。本练习通过一个简化的双时间尺度模型，探索经典的隐式方法——Crank-Nicolson格式——在处理刚性问题时的表现。通过分析其稳定性函数，你将亲身体会到一个数值方法如何能够在保持稳定性的同时，对快速衰减的（刚性）模态引入非物理的数值振荡，这对于评估数值解的质量至关重要。",
            "id": "4231279",
            "problem": "在核反应堆的耦合中子-热工水力瞬态分析中，围绕稳态进行的线性化和模态分解通常会产生独立的标量模态，每个模态都满足形式为 $y'(t) = \\lambda y(t)$ 的线性常微分方程(ODE)，其中 $\\lambda \\in \\mathbb{C}$ 是一个模态特征值。考虑一个代表性的双时间尺度情况，其中一个模态是刚性模态，其特征值为 $\\lambda_{1} = -10^{5}\\,\\text{s}^{-1}$，另一个是慢模态，其特征值为 $\\lambda_{2} = -10\\,\\text{s}^{-1}$。您将使用 Crank–Nicolson (CN) 格式来分析这些模态的时间离散化。\n\n从应用于标量线性常微分方程 $y'(t) = \\lambda y(t)$ 且时间步长 $\\Delta t$ 均匀的 Crank–Nicolson (CN) 方法的定义更新式出发，推导标量稳定性（放大）函数 $R(z)$，并用无量纲量 $z = \\lambda \\Delta t$ 表示。然后，对于时间步长 $\\Delta t = 10^{-3}\\,\\text{s}$，计算 $z_{1} = \\lambda_{1}\\Delta t$ 和 $z_{2} = \\lambda_{2}\\Delta t$ 对应的 $R(z)$ 值，并根据每个放大因子的符号和大小，推断每个模态的离散时间响应是否在步间振荡。\n\n最终答案只报告刚性模态的放大因子，即 $R(z_{1})$ 的数值。结果以纯数（无量纲）形式表示，并四舍五入到8位有效数字。",
            "solution": "用户指定了一个关于核反应堆中代表模态动力学的常微分方程(ODE)的数值稳定性分析问题。第一步是验证问题陈述。该问题提供了一个定义明确的物理背景（耦合中子学和热工水力学）、一个标准的数学模型（$y'(t) = \\lambda y(t)$）、具体的参数（$\\lambda_1 = -10^5\\,\\text{s}^{-1}$、$\\lambda_2 = -10\\,\\text{s}^{-1}$、$\\Delta t = 10^{-3}\\,\\text{s}$）、一个指定的数值方法（Crank-Nicolson）以及一组明确的任务。该问题具有科学依据、客观、自洽且适定。不存在不一致、矛盾或违反物理原理之处。因此，该问题被认为是有效的，可以构建一个完整的解。\n\n该问题围绕标量线性常微分方程：\n$$\ny'(t) = \\lambda y(t)\n$$\nCrank-Nicolson (CN) 格式用于对该方程进行时间离散化。对于均匀的时间步长 $\\Delta t$，第 $n+1$ 步的解值（记为 $y_{n+1}$）与第 $n$ 步的解值（记为 $y_n$）通过对导数应用中心差分近似并对右侧项取平均值而关联起来：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\frac{1}{2} \\left( \\lambda y_n + \\lambda y_{n+1} \\right)\n$$\n问题要求推导标量稳定性（或放大）函数 $R(z)$，它由关系式 $y_{n+1} = R(z) y_n$ 定义，其中 $z = \\lambda \\Delta t$。为了推导 $R(z)$，我们重排离散化的 CN 方程。\n\n首先，两边同乘以 $\\Delta t$：\n$$\ny_{n+1} - y_n = \\frac{\\lambda \\Delta t}{2} (y_n + y_{n+1})\n$$\n代入无量纲量 $z = \\lambda \\Delta t$：\n$$\ny_{n+1} - y_n = \\frac{z}{2} (y_n + y_{n+1})\n$$\n为了解出 $y_{n+1}$，我们将所有含 $y_{n+1}$ 的项移到左边，所有含 $y_n$ 的项移到右边：\n$$\ny_{n+1} - \\frac{z}{2} y_{n+1} = y_n + \\frac{z}{2} y_n\n$$\n提取公因式 $y_{n+1}$ 和 $y_n$：\n$$\ny_{n+1} \\left( 1 - \\frac{z}{2} \\right) = y_n \\left( 1 + \\frac{z}{2} \\right)\n$$\n除以左侧的因子，得到 $y_{n+1}$ 的显式更新规则：\n$$\ny_{n+1} = \\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}} y_n\n$$\n从这个表达式中，我们将乘以 $y_n$ 的系数确定为稳定性函数 $R(z)$：\n$$\nR(z) = \\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}}\n$$\n接下来，我们使用时间步长 $\\Delta t = 10^{-3}\\,\\text{s}$ 计算两个指定模态的 $R(z)$。\n\n对于刚性模态，特征值为 $\\lambda_1 = -10^5\\,\\text{s}^{-1}$。对应的 $z$ 值为：\n$$\nz_1 = \\lambda_1 \\Delta t = (-10^5\\,\\text{s}^{-1}) (10^{-3}\\,\\text{s}) = -100\n$$\n刚性模态的放大因子为：\n$$\nR(z_1) = R(-100) = \\frac{1 + \\frac{-100}{2}}{1 - \\frac{-100}{2}} = \\frac{1 - 50}{1 + 50} = \\frac{-49}{51}\n$$\n\n对于慢模态，特征值为 $\\lambda_2 = -10\\,\\text{s}^{-1}$。对应的 $z$ 值为：\n$$\nz_2 = \\lambda_2 \\Delta t = (-10\\,\\text{s}^{-1}) (10^{-3}\\,\\text{s}) = -0.01\n$$\n慢模态的放大因子为：\n$$\nR(z_2) = R(-0.01) = \\frac{1 + \\frac{-0.01}{2}}{1 - \\frac{-0.01}{2}} = \\frac{1 - 0.005}{1 + 0.005} = \\frac{0.995}{1.005}\n$$\n如果放大因子为负，离散时间响应就是振荡的，因为这会导致解的符号在每个时间步都发生翻转。\n对于刚性模态，$R(z_1) = -49/51  0$。这表明该模态的数值解将是振荡的。其大小为 $|R(z_1)| = 49/51  1$，因此振荡是数值稳定的（即其振幅不增长），但阻尼很差。这是一种虚假的数值效应，因为精确解是单调衰减的。\n对于慢模态，$R(z_2) \\approx 0.99 > 0$。响应是非振荡且稳定的，精确地捕捉了物理模态的单调衰减特性。\n\n最后的任务是报告刚性模态的放大因子 $R(z_1)$ 的数值，并四舍五入到8位有效数字。\n$$\nR(z_1) = -\\frac{49}{51} \\approx -0.960784313725...\n$$\n四舍五入到8位有效数字，我们得到 $-0.96078431$。",
            "answer": "$$\n\\boxed{-0.96078431}\n$$"
        },
        {
            "introduction": "隐式-显式（IMEX）方法的核心思想是将控制方程分裂为刚性部分（隐式处理）和非刚性部分（显式处理）。然而，保证数值稳定性并非唯一目标，离散格式还必须遵守诸如质量守恒等基本物理定律。本练习模拟了核素燃耗计算中的一个典型情景：一个简单的IMEX格式可能破坏守恒律。你将分析一种修正方案（通量限制器），它能够恢复物理守恒性，并思考这种修正对计算精度的影响。",
            "id": "4231352",
            "problem": "在耦合燃耗的核反应堆模拟中，考虑一个单一反应通道，在一个宏观时间步长内，在恒定中子通量下，将核素存量从给予体核素 $A$ 转移到接受体核素 $B$。核素 $A$ 和 $B$ 的控制存量平衡可以写作\n$$\n\\frac{d C_A}{dt} \\;=\\; - \\lambda C_A, \n\\qquad\n\\frac{d C_B}{dt} \\;=\\; + \\lambda C_A,\n$$\n其中 $C_A \\ge 0$，$C_B \\ge 0$，且 $\\lambda \\ge 0$ 是一个有效移除/产生率，它可以表示中子诱发的嬗变和放射性衰变的组合。该连续模型使总存量 $C_A + C_B$ 守恒，并保持非负性。\n\n一种常见的隐式-显式 (IMEX) 时间积分方法将 $A$ 的刚性损耗作隐式处理，而将 $B$ 的源项作显式处理。在大小为 $\\Delta t$ 的一个步长上，假设执行给予体优先更新（因此在更新 $C_B^{n+1}$ 时 $C_A^{n+1}$ 是可用的）。在一个基准一阶 IMEX-欧拉变体中，可得\n$$\nC_A^{n+1} \\;=\\; \\frac{C_A^{n}}{1 + \\lambda \\Delta t},\n\\qquad\nC_B^{n+1} \\;=\\; C_B^{n} + \\Delta t \\,\\lambda\\, C_A^{n}.\n$$\n对于大的 $\\Delta t$，$B$ 的显式源项更新可能会过冲在同一步骤中从 $A$ 实际移除的量，从而破坏离散守恒，并且在更一般的反应网络中，可能通过耦合破坏非负性。\n\n你的任务是：当一个通用接受体分量 $C_i$ 的显式源项形式为 $S_i^{\\mathrm{exp}} = \\lambda C_{\\mathrm{donor}}$（源于以损耗形式进行隐式更新的单个给予体 $C_{\\mathrm{donor}}$）时，为其 IMEX 源项更新提出一个保正性且守恒一致的修正。并且，当此修正方法在一个原本为高阶 ($p \\ge 2$) 的 IMEX 龙格-库塔方法中被激活时，从第一性原理论证其对形式精度阶的后果。你的修正必须用可计算的步末给予体变化量来定义。\n\n哪个选项正确地指明了这种修正及其对精度的影响？\n\nA. 将 $S_i^{\\mathrm{exp}}$ 替换为一个截断源项 $\\theta\\, S_i^{\\mathrm{exp}}$，其中\n$$\n\\theta \\;=\\; \\min\\!\\left\\{\\,1,\\; \\frac{C_{\\mathrm{donor}}^{n} - C_{\\mathrm{donor}}^{n+1}}{\\Delta t \\,\\lambda\\, C_{\\mathrm{donor}}^{n} + \\varepsilon}\\,\\right\\},\n$$\n其中 $\\varepsilon > 0$ 是一个机器安全的正则化项。这强制使在该步长内接受体中产生的量等于实际移除的给予体存量，从而在给予体-接受体对之间保持非负性和离散守恒。当 $\\theta  1$（限制器被激活）时，该局部修正是一个非光滑投影，引入了 $\\mathcal{O}(\\Delta t)$ 的微扰，即使底层 IMEX 格式的阶数 $p \\ge 2$，在这些步长上也会将有效阶降至 1。\n\nB. 反而截断隐式损耗项，即将对 $C_{\\mathrm{donor}}$ 的隐式更新替换为 $C_{\\mathrm{donor}}^{n+1} = C_{\\mathrm{donor}}^{n} - \\theta \\Delta t \\,\\lambda\\, C_{\\mathrm{donor}}^{n+1}$，其中 $\\theta$ 与选项 A 中的相同。这能保持 A-稳定性，维持 p 阶精度，并保证非负性和守恒性，而无需影响接受体。\n\nC. 对 $S_i^{\\mathrm{exp}}$ 使用一个放大因子 $\\theta = \\max\\!\\left\\{\\,1,\\; \\frac{C_{\\mathrm{donor}}^{n} - C_{\\mathrm{donor}}^{n+1}}{\\Delta t \\,\\lambda\\, C_{\\mathrm{donor}}^{n}}\\,\\right\\}$，这样小步长保持不变，而大步长则增加产量以补偿隐式阻尼；因为 $\\theta \\ge 1$，这能保持正性并提高精度而不会降阶。\n\nD. 依赖于 $p \\ge 2$ 阶的强稳定性保持 (SSP) IMEX 龙格-库塔系数；这类格式能对任何 $\\Delta t$ 保证正性和精确离散守恒，因此不需要截断，并且在任何情况下都不会发生降阶。",
            "solution": "问题陈述经过严格验证，确认有效。它在核工程和数值分析领域具有科学依据，是适定的，并以客观、精确的语言表达。它提出了在对反应网络产生的刚性系统进行时间积分时的一个标准挑战：需要在离散层面强制执行物理守恒律，而不过度牺牲数值精度。\n\n我们将从第一性原理出发推导解答。\n\n该连续系统由以下常微分方程 (ODE) 给出：\n$$\n\\frac{d C_A}{dt} \\;=\\; - \\lambda C_A\n$$\n$$\n\\frac{d C_B}{dt} \\;=\\; + \\lambda C_A\n$$\n该系统使总存量 $C_A + C_B$ 守恒，这可以通过将两个方程相加看出：\n$$\n\\frac{d}{dt} (C_A + C_B) = \\frac{d C_A}{dt} + \\frac{d C_B}{dt} = -\\lambda C_A + \\lambda C_A = 0\n$$\n这意味着对于所有时间 $t$，$C_A(t) + C_B(t) = \\text{常数}$。任何有效的数值格式都应尽力在离散层面保持此性质，即 $C_A^{n+1} + C_B^{n+1} = C_A^n + C_B^n$。\n\n问题提出了一个在时间步长 $\\Delta t$ 上的基准一阶 IMEX-欧拉格式：\n$$\nC_A^{n+1} \\;=\\; \\frac{C_A^{n}}{1 + \\lambda \\Delta t} \\quad (\\text{用于损耗的隐式欧拉})\n$$\n$$\nC_B^{n+1} \\;=\\; C_B^{n} + \\Delta t \\,\\lambda\\, C_A^{n} \\quad (\\text{用于源项的显式欧拉})\n$$\n让我们检查该格式是否守恒。在第 $n+1$ 步的总存量为：\n$$\nC_A^{n+1} + C_B^{n+1} = \\frac{C_A^{n}}{1 + \\lambda \\Delta t} + C_B^{n} + \\Delta t \\,\\lambda\\, C_A^{n}\n$$\n为使此式等于 $C_A^n + C_B^n$，我们需要 $\\frac{C_A^{n}}{1 + \\lambda \\Delta t} + \\Delta t \\,\\lambda\\, C_A^{n} = C_A^n$。这可简化为 $C_A^n + \\Delta t \\lambda C_A^n (1 + \\lambda \\Delta t) = C_A^n(1 + \\lambda \\Delta t)$，意味着 $(\\lambda \\Delta t)^2 C_A^n = 0$。这仅在 $\\lambda=0$，$\\Delta t=0$ 或 $C_A^n=0$ 时才成立。通常情况下，该格式不守恒。\n\n在该步长内实际移除的给予体核素 $A$ 的量为：\n$$\n\\Delta C_{A, \\text{removed}} = C_A^n - C_A^{n+1} = C_A^n - \\frac{C_A^n}{1 + \\lambda \\Delta t} = C_A^n \\left( \\frac{1+\\lambda \\Delta t - 1}{1 + \\lambda \\Delta t} \\right) = \\frac{\\lambda \\Delta t}{1 + \\lambda \\Delta t} C_A^n\n$$\n在该步长内产生的接受体核素 $B$ 的量为：\n$$\n\\Delta C_{B, \\text{produced}} = C_B^{n+1} - C_B^n = \\Delta t \\lambda C_A^n\n$$\n守恒误差的产生是因为 $\\Delta C_{A, \\text{removed}} \\neq \\Delta C_{B, \\text{produced}}$。显式源项相对于隐式阻尼的移除量，高估了产物的生成。\n\n为强制守恒，我们必须修改核素 $B$ 的源项，使得产生的量恰好等于从核素 $A$ 移除的量。也就是说，我们必须强制 $\\Delta C_{B, \\text{produced}}^{\\text{mod}} = \\Delta C_{A, \\text{removed}}$。\n对 $B$ 的修正后更新变为：\n$$\nC_B^{n+1} = C_B^n + \\Delta C_{A, \\text{removed}} = C_B^n + (C_A^n - C_A^{n+1})\n$$\n通过此修正，$C_A^{n+1} + C_B^{n+1} = C_A^{n+1} + C_B^n + C_A^n - C_A^{n+1} = C_A^n + C_B^n$，因此该格式现在是完全守恒的。由于对 $C_A$ 的隐式更新是无条件保正的（如果 $C_A^n > 0$ 则 $C_A^{n+1} > 0$），我们有 $C_A^n - C_A^{n+1} \\geq 0$。因此，如果 $C_B^n \\ge 0$，该更新能确保 $C_B^{n+1} \\ge 0$。\n\n问题要求将此修正表示为对原始显式源项 $S_i^{\\mathrm{exp}} = \\lambda C_{\\mathrm{donor}}$ 的一个截断因子 $\\theta$。这里，给予体是 $A$。对 $B$ 的修正后源项更新形式为 $C_B^{n+1} = C_B^n + \\Delta t \\, (\\theta S_B^{\\mathrm{exp}})$，其中 $S_B^{\\mathrm{exp}} = \\lambda C_A^n$。\n将我们的守恒更新与此形式等同：\n$$\nC_B^n + \\Delta t \\, \\theta (\\lambda C_A^n) = C_B^n + (C_A^n - C_A^{n+1})\n$$\n$$\n\\theta = \\frac{C_A^n - C_A^{n+1}}{\\Delta t \\lambda C_A^n}\n$$\n这就用给予体更新结束时的可计算量定义了所需的缩放因子 $\\theta$。代入 $C_A^n - C_A^{n+1}$ 的表达式：\n$$\n\\theta = \\frac{\\frac{\\lambda \\Delta t}{1 + \\lambda \\Delta t} C_A^n}{\\Delta t \\lambda C_A^n} = \\frac{1}{1 + \\lambda \\Delta t}\n$$\n由于 $\\lambda \\ge 0$ 且 $\\Delta t \\ge 0$，我们有 $0  \\theta \\le 1$。对于非常小的 $\\lambda \\Delta t$，因子 $\\theta$ 接近 1；对于大的 $\\lambda \\Delta t$，$\\theta$ 趋近于 0。这表明它起到了限制器或阻尼因子的作用。\n\n现在，我们分析其对一个阶数为 $p \\ge 2$ 的基础格式的精度阶的影响。当限制器被激活时，$\\theta  1$。对更新的修正引入了一个微扰。我们来分析局部截断误差 (LTE)。在 $\\Delta t$ 时间内 $C_B$ 的真实变化量是 $\\Delta C_{B, \\text{true}} = \\int_0^{\\Delta t} \\lambda C_A(0) e^{-\\lambda \\tau} d\\tau = C_A(0)(1 - e^{-\\lambda \\Delta t})$。\n对小 $\\Delta t$ 展开：$\\Delta C_{B, \\text{true}} = C_A(0) (\\lambda \\Delta t - \\frac{(\\lambda\\Delta t)^2}{2} + \\frac{(\\lambda\\Delta t)^3}{6} - \\dots)$。\n修正后的数值更新给出的变化量为 $\\Delta C_{B, \\text{mod}} = \\frac{\\lambda \\Delta t}{1+\\lambda \\Delta t}C_A^n$。\n对该式就小 $\\Delta t$ 展开：$\\Delta C_{B, \\text{mod}} = (\\lambda \\Delta t - (\\lambda\\Delta t)^2 + (\\lambda\\Delta t)^3 - \\dots)C_A^n$。\n修正后更新的误差为 $\\Delta C_{B, \\text{mod}} - \\Delta C_{B, \\text{true}} = C_A^n (-\\frac{1}{2}(\\lambda\\Delta t)^2 + O(\\Delta t^3))$。\n这是一个 $\\mathcal{O}(\\Delta t^2)$ 的局部截断误差。$\\mathcal{O}(\\Delta t^k)$ 的 LTE 会导致 $k-1$ 阶的全局误差。因此，$\\mathcal{O}(\\Delta t^2)$ 的 LTE 意味着该方法是全局一阶精度的。如果基础 IMEX 格式的阶数 $p \\ge 2$（意味着 LTE 为 $\\mathcal{O}(\\Delta t^3)$ 或更高），这个修正在被激活时，会将精度降低到一阶。`min` 函数的使用使得有效右端项非光滑，这是导致龙格-库塔方法降阶的一个已知原因。由限制器 $(\\theta-1)$ 引入的微扰是 $\\mathcal{O}(\\Delta t)$，这导致了降阶。\n\n现在我们来评估给出的选项。\n\n**选项 A：** 这个 $\\theta$ 的公式与我们的推导相符。`min{1, ...}` 的形式是一个稳健的实现，因为我们的推导表明，对于这个单通道问题，该比率内在地 $\\le 1$，但这对于一般情况是一种好的做法。$\\varepsilon$ 项是防止除零的标准数值安全措施。该选项正确地指出，这强制了离散守恒并保持了非负性。它接着正确地得出结论，当限制器被激活时（$\\theta  1$），该修正引入了一个微扰，将有效精度阶降至 1，即使基础格式是更高阶的（$p \\ge 2$）。这与我们的分析完全吻合。\n**结论：正确**\n\n**选项 B：** 这个选项建议修改给予体核素的隐式更新。这未能解决核心问题，即接受体核素源项的不一致性。所提出的修正也是循环定义的，因为截断因子 $\\theta$ 依赖于正在计算的量 $C_{\\mathrm{donor}}^{n+1}$。此外，不修改接受体的源项意味着守恒误差没有被修正。关于维持 p 阶精度和保证守恒性的说法是不正确的。\n**结论：不正确**\n\n**选项 C：** 这个选项提出了一个放大因子 $\\theta = \\max\\{1, ...\\}$。根据推导，表达式内的比值为 $\\frac{1}{1+\\lambda\\Delta t}$，它总是小于或等于 1。因此，这个 $\\theta$ 的计算结果将永远是 1。该修正没有任何作用。其陈述的基本原理，“增加产量以补偿隐式阻尼”，与实际需求相反；显式源项会 *过冲*，需要被抑制，而不是放大。\n**结论：不正确**\n\n**选项 D：** 这个选项表明，使用强稳定性保持 (SSP) IMEX 格式可以无需修正地解决问题。SSP 方法旨在在 CFL 条件下保持前向欧拉法的性质（如正性）。它们本身并不能在隐式和显式求解器之间分区的系统分量间强制实现守恒。隐式计算的移除量与显式计算的产生量之间的根本性不匹配依然存在。此外，声称这类格式“对任何 $\\Delta t$”都有效是错误的；SSP 格式对显式部分有时间步长限制。\n**结论：不正确**\n\n因此，选项 A 是唯一一个正确指明了有效的、守恒的、保正的修正，并准确描述了其对精度阶的后果的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "从概念分析到动手实践，本练习要求你为一个点堆动力学模型完整地实现一个预测-校正IMEX求解器。该模型可以很自然地分裂为刚性的线性动力学项和非刚性的非线性/源项。练习的重点在于一个关键的实用技术：自适应控制。通过监测显式部分的计算误差，并据此动态调整求解策略（如改进预测或减小步长），你将体验构建稳健数值模拟工具的真实过程。",
            "id": "4231316",
            "problem": "考虑一个具有单组缓发中子的点堆动力学半离散模型，其中中子密度和缓发中子先驱核浓度是集总变量。设状态向量为 $y = [n, c]^{\\top}$，其中 $n$ 是中子密度，$c$ 是先驱核浓度，单位均为 $\\text{cm}^{-3}$。控制方程以质量矩阵形式写为\n$$\nM \\frac{d y}{d t} = f_I(y) + g(y, t),\n$$\n其中 $M \\in \\mathbb{R}^{2 \\times 2}$ 是一个对角质量矩阵，捕捉了变量的集总效应；刚性项 $f_I(y)$ 代表瞬发中子和缓发中子的线性动力学；非刚性项 $g(y,t)$ 代表外源和弱非线性反馈。对于净反应性为零的单组缓发中子，定义\n$$\nf_I(y) = A y, \\quad A = \\begin{bmatrix}\n-\\beta/\\Lambda  \\lambda \\\\\n\\beta/\\Lambda  -\\lambda\n\\end{bmatrix},\n$$\n其中 $\\beta$ 是缓发中子份额（无量纲），$\\Lambda$ 是平均中子代时间（单位为秒），$\\lambda$ 是先驱核衰变常数（单位为 $\\text{s}^{-1}$）。定义非刚性项为\n$$\ng(y,t) = \\begin{bmatrix}\nS_0 e^{-\\sigma t} + \\mu n^2 \\\\\n0\n\\end{bmatrix},\n$$\n其中 $S_0$ 是外源幅度（单位为 $\\text{cm}^{-3}\\text{s}^{-1}$），$\\sigma$ 是源衰变率（单位为 $\\text{s}^{-1}$），$\\mu$ 是一个小的非线性系数（单位为 $\\text{cm}^{3}\\text{s}^{-1}$）。\n\n实现一个隐式-显式 (IMEX) 预估-校正方法，将时间从 $t_n$ 推进到 $t_{n+1}=t_n+\\Delta t$，步骤如下：\n\n1. 对非刚性项的显式预估：\n$$\nM \\hat{y}^{n+1} = M y^n + \\Delta t\\, g(y^n, t_n).\n$$\n\n2. 对刚性项使用预估的显式贡献进行隐式校正：\n$$\nM y^{n+1} = M y^n + \\Delta t\\, f_I(y^{n+1}) + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1}).\n$$\n\n基于在 $y^{n+1}$ 和 $\\hat{y}^{n+1}$ 处计算显式项时的差异，推导并实现一个针对显式预估的残差范数接受准则。定义残差向量\n$$\nr^{n+1} = M y^{n+1} - M y^n - \\Delta t\\, f_I(y^{n+1}) - \\Delta t\\, g(y^{n+1}, t_{n+1}),\n$$\n对于上述格式，在精确计算中该向量满足 $r^{n+1} = \\Delta t \\left( g(\\hat{y}^{n+1}, t_{n+1}) - g(y^{n+1}, t_{n+1}) \\right)$。如果满足以下条件，则接受该预估：\n$$\n\\lVert r^{n+1} \\rVert_2 \\le \\tau_{\\text{abs}} + \\tau_{\\text{rel}} \\lVert M y^{n+1} \\rVert_2,\n$$\n其中 $\\tau_{\\text{abs}}$ 是绝对容差，$\\tau_{\\text{rel}}$ 是相对容差。\n\n如果预估被拒绝，则使用仅应用于显式项的二阶显式梯形法则（Heun 方法）重新计算一个改进的显式预估：\n$$\n\\tilde{y}^{n+1} = y^n + \\Delta t\\, M^{-1} g(y^n, t_n), \\quad \\hat{y}^{n+1}_{\\text{Heun}} = y^n + \\frac{\\Delta t}{2}\\, M^{-1} \\left( g(y^n, t_n) + g(\\tilde{y}^{n+1}, t_{n+1}) \\right),\n$$\n并使用 $g(\\hat{y}^{n+1}_{\\text{Heun}}, t_{n+1})$ 重新求解隐式校正。如果改进后的预估仍被拒绝，则将时间步长划分为相等的子步，并在每个子步上重复此过程，直到满足接受准则。通过划分为持续时间总和为 $\\Delta t$ 的子步，确保在一个基本时间步长 $\\Delta t$ 内推进的总时间恰好为 $\\Delta t$；例如，两个 $\\Delta t/2$ 的子步，或四个 $\\Delta t/4$ 的子步，依此类推。每当当前使用的显式预估（初始的显式欧拉预估或改进的 Heun 预估）被拒绝时，计为一次拒绝事件。\n\n您的实现必须：\n- 由于 $f_I(y)$ 是线性的，校正步骤需通过求解线性系统来完成。\n- 使用所述的接受准则和自适应子步策略。\n- 跟踪并报告预估被拒绝的次数。\n\n物理单位和输出：\n- 时间 $t$ 的单位必须是秒。\n- 中子密度 $n$ 和先驱核浓度 $c$ 的单位必须是 $\\text{cm}^{-3}$。\n- 源幅度 $S_0$ 的单位必须是 $\\text{cm}^{-3}\\text{s}^{-1}$。\n\n为每个测试用例提供最终输出，$n$ 和 $c$ 为 $\\text{cm}^{-3}$ 单位的浮点数，拒绝次数为整数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[[n1,c1,r1],[n2,c2,r2],[n3,c3,r3]]\"）。\n\n测试套件：\n为以下三个测试用例实现 IMEX 格式，每个用例的结果作为最终输出中的一个列表元素返回。所有用例均使用相同的容差 $\\tau_{\\text{abs}} = 10^{-6}$ 和 $\\tau_{\\text{rel}} = 10^{-4}$。\n\n- 用例 1（理想路径，小的显式非线性且时间步长小）：\n    - 参数：$\\beta = 0.0065$，$\\Lambda = 1.0\\times 10^{-5}\\ \\text{s}$，$\\lambda = 0.08\\ \\text{s}^{-1}$，$\\mu = 1.0\\times 10^{-11}\\ \\text{cm}^{3}\\text{s}^{-1}$，$S_0 = 1.0\\times 10^{4}\\ \\text{cm}^{-3}\\text{s}^{-1}$，$\\sigma = 1.0\\ \\text{s}^{-1}$。\n    - 质量矩阵：$M = \\operatorname{diag}(1.0, 1.0)$。\n    - 初始条件：$n(0) = 1.0\\times 10^{4}\\ \\text{cm}^{-3}$，$c(0) = 0.0\\ \\text{cm}^{-3}$。\n    - 时间步长：$\\Delta t = 1.0\\times 10^{-4}\\ \\text{s}$，基本步数 $N = 1000$。\n\n- 用例 2（中等显式非线性、中等时间步长，预计会出现一些预估拒绝，非平凡质量矩阵）：\n    - 参数：$\\beta = 0.0065$，$\\Lambda = 1.0\\times 10^{-5}\\ \\text{s}$，$\\lambda = 0.08\\ \\text{s}^{-1}$，$\\mu = 1.0\\times 10^{-7}\\ \\text{cm}^{3}\\text{s}^{-1}$，$S_0 = 1.0\\times 10^{4}\\ \\text{cm}^{-3}\\text{s}^{-1}$，$\\sigma = 1.0\\ \\text{s}^{-1}$。\n    - 质量矩阵：$M = \\operatorname{diag}(1.0, 0.5)$。\n    - 初始条件：$n(0) = 1.0\\times 10^{4}\\ \\text{cm}^{-3}$，$c(0) = 0.0\\ \\text{cm}^{-3}$。\n    - 时间步长：$\\Delta t = 5.0\\times 10^{-3}\\ \\text{s}$，基本步数 $N = 200$。\n\n- 用例 3（强显式非线性、大时间步长，预计会出现大量的预估拒绝和子步划分）：\n    - 参数：$\\beta = 0.0065$，$\\Lambda = 1.0\\times 10^{-5}\\ \\text{s}$，$\\lambda = 0.08\\ \\text{s}^{-1}$，$\\mu = 1.0\\times 10^{-6}\\ \\text{cm}^{3}\\text{s}^{-1}$，$S_0 = 1.0\\times 10^{4}\\ \\text{cm}^{-3}\\text{s}^{-1}$，$\\sigma = 1.0\\ \\text{s}^{-1}$。\n    - 质量矩阵：$M = \\operatorname{diag}(1.0, 1.0)$。\n    - 初始条件：$n(0) = 1.0\\times 10^{4}\\ \\text{cm}^{-3}$，$c(0) = 0.0\\ \\text{cm}^{-3}$。\n    - 时间步长：$\\Delta t = 5.0\\times 10^{-2}\\ \\text{s}$，基本步数 $N = 20$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，格式如下\n$$\n\\text{[ [}n_1,c_1,r_1\\text{], [}n_2,c_2,r_2\\text{], [}n_3,c_3,r_3\\text{] ]}\n$$\n其中对于 $i=1,2,3$，$n_i$ 和 $c_i$ 是单位为 $\\text{cm}^{-3}$ 的浮点数，$r_i$ 是整数。",
            "solution": "用户提供了一个问题，要求为一个模拟点堆动力学的常微分方程组 (ODE) 实现一个隐式-显式 (IMEX) 预估-校正格式。该问题包含一个基于残差误差估计的特定自适应步长策略。这需要对数值方法进行细致的推导和实现。\n\n### 问题描述\n\n该常微分方程组以质量矩阵形式给出：\n$$\nM \\frac{d y}{d t} = f_I(y) + g(y, t)\n$$\n其中 $y = [n, c]^{\\top}$ 是状态向量，$M$ 是质量矩阵，$f_I(y)$ 是刚性线性项，$g(y, t)$ 是非刚性非线性项。\n\n各个分量定义如下：\n- 质量矩阵：$M = \\operatorname{diag}(m_n, m_c)$\n- 刚性项：$f_I(y) = A y$，其中动力学矩阵 $A = \\begin{bmatrix} -\\beta/\\Lambda  \\lambda \\\\ \\beta/\\Lambda  -\\lambda \\end{bmatrix}$\n- 非刚性项：$g(y,t) = \\begin{bmatrix} S_0 e^{-\\sigma t} + \\mu n^2 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} S_0 e^{-\\sigma t} + \\mu (y_0)^2 \\\\ 0 \\end{bmatrix}$\n\n### IMEX 预估-校正格式\n\n该数值格式将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$。它包含两个主要阶段：一个对非刚性部分的预估和一个对刚性部分进行隐式处理的校正。\n\n**1. 预估阶段（显式）**\n\n该格式首先预估由非刚性项 $g$ 引起的状态演化。最简单的预估方法是一阶显式（前向）欧拉法：\n$$\nM \\hat{y}^{n+1} = M y^n + \\Delta t\\, g(y^n, t_n)\n$$\n这可以重排以求解预估状态 $\\hat{y}^{n+1}$：\n$$\n\\hat{y}^{n+1} = y^n + \\Delta t\\, M^{-1} g(y^n, t_n)\n$$\n由于 $M$ 是对角矩阵，其逆矩阵 $M^{-1}$ 就是由各元素倒数构成的对角矩阵。\n\n**2. 校正阶段（隐式）**\n\n校正阶段隐式地（使用后向欧拉法）包含刚性项 $f_I$，并使用预估状态来计算在时间步末端 $t_{n+1}$ 处的非刚性项 $g$：\n$$\nM y^{n+1} = M y^n + \\Delta t\\, f_I(y^{n+1}) + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})\n$$\n由于 $f_I(y) = A y$ 是线性的，我们可以将此方程重排为关于未知状态 $y^{n+1}$ 的线性系统：\n$$\nM y^{n+1} - \\Delta t\\, A y^{n+1} = M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})\n$$\n$$\n(M - \\Delta t A) y^{n+1} = M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})\n$$\n这是一个形如 $C_{sys} x = b$ 的 $2 \\times 2$ 线性系统，其中系统矩阵为 $C_{sys} = (M - \\Delta t A)$，未知向量为 $x = y^{n+1}$，右端项为 $b = M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})$。对于每个持续时间为 $\\Delta t$ 的时间步，矩阵 $C_{sys}$ 是常数，可以通过求逆来解出 $y^{n+1}$：\n$$\ny^{n+1} = (M - \\Delta t A)^{-1} \\left( M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1}) \\right)\n$$\n\n### 自适应控制：误差估计和步长拒绝\n\n该格式的精度在很大程度上取决于显式预估 $\\hat{y}^{n+1}$ 对最终解 $y^{n+1}$ 的近似程度。较大的差异表明时间步长 $\\Delta t$ 可能过大。我们可以使用残差来量化这种差异。\n\n**残差定义和接受准则：**\n残差 $r^{n+1}$ 是基于校正方程定义的。如问题陈述所示，它可以简化为在预估状态和校正状态下计算的非刚性项之差：\n$$\nr^{n+1} = \\Delta t \\left( g(\\hat{y}^{n+1}, t_{n+1}) - g(y^{n+1}, t_{n+1}) \\right)\n$$\n如果该残差的 L2 范数在混合绝对-相对容差范围内，则接受该步：\n$$\n\\lVert r^{n+1} \\rVert_2 \\le \\tau_{\\text{abs}} + \\tau_{\\text{rel}} \\lVert M y^{n+1} \\rVert_2\n$$\n\n**拒绝策略：**\n\n如果不满足接受准则，该步将被拒绝。拒绝会触发一系列操作：\n1.  **计数拒绝**：欧拉预估的失败被计为一次拒绝事件。\n2.  **改进预估**：对非刚性项使用一个更精确的、基于 Heun 方法（显式梯形法则）的二阶预估：\n    - 第一阶段（欧拉步）：$\\tilde{y}^{n+1} = y^n + \\Delta t\\, M^{-1} g(y^n, t_n)$\n    - 第二阶段（梯形平均）：$\\hat{y}^{n+1}_{\\text{Heun}} = y^n + \\frac{\\Delta t}{2}\\, M^{-1} \\left( g(y^n, t_n) + g(\\tilde{y}^{n+1}, t_{n+1}) \\right)$\n    然后使用这个改进的预估重新求解校正步骤：\n    $$\n    y^{n+1} = (M - \\Delta t A)^{-1} \\left( M y^n + \\Delta t\\, g(\\hat{y}^{n+1}_{\\text{Heun}}, t_{n+1}) \\right)\n    $$\n    使用这个新的 $y^{n+1}$ 再次检查接受准则。如果通过，则接受该步，此步的总拒绝次数为 1。\n\n3.  **子步划分**：如果 Heun 预估也未能通过接受测试，这次失败将被计为当前时间步尝试的第二次拒绝事件。时间步长 $\\Delta t$ 被认为过大，并被划分为两个持续时间为 $\\Delta t/2$ 的相等子步。整个过程，从初始的欧拉预估开始，递归地应用于每个子步。对于大小为 $\\Delta t$ 的原始步，总拒绝次数将是失败的完整步长尝试所产生的两次拒绝，加上后续子步中累积的任何拒绝。\n\n### 实现逻辑\n\n自适应策略最好使用一个递归函数来实现，例如 `adaptive_step(y_n, t_n, dt)`。此函数尝试在时间间隔 `dt` 内推进解。\n\n- 它首先尝试欧拉预估。如果成功，它返回新状态和 0 次拒绝。\n- 如果失败，它将拒绝计数器增加到 1，并尝试 Heun 预估。如果成功，它返回新状态和 1 次拒绝。\n- 如果 Heun 也失败了，它将拒绝计数器增加到 2。然后它调用自身两次来处理两个大小为 `dt/2` 的子步：\n    - `y_mid, rej1 = adaptive_step(y_n, t_n, dt/2)`\n    - `y_final, rej2 = adaptive_step(y_mid, t_n + dt/2, dt/2)`\n    它返回最终状态 `y_final` 和总拒绝次数：$2 + \\text{rej}_1 + \\text{rej}_2$。\n\n主模拟循环遍历 $N$ 个基本时间步，为每个基本时间步 $\\Delta t$ 调用此递归函数，并累积总拒绝次数。为每个测试用例报告最终的状态向量 $[n, c]^{\\top}$ 和总拒绝次数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the IMEX simulation for all test cases.\n    \"\"\"\n\n    def run_case(params):\n        \"\"\"\n        Runs a single test case simulation.\n        \"\"\"\n        # Unpack parameters\n        beta = params['beta']\n        Lambda = params['Lambda']\n        lmbda = params['lambda']\n        mu = params['mu']\n        S0 = params['S0']\n        sigma = params['sigma']\n        M = params['M']\n        y0 = params['y0']\n        dt_base = params['dt']\n        N = params['N']\n        tau_abs = params['tau_abs']\n        tau_rel = params['tau_rel']\n\n        # Construct matrices\n        A = np.array([\n            [-beta / Lambda, lmbda],\n            [beta / Lambda, -lmbda]\n        ])\n        M_inv = np.linalg.inv(M)\n\n        # Non-stiff function g(y, t)\n        def g(y_vec, t):\n            n = y_vec[0]\n            g_vec = np.zeros(2)\n            g_vec[0] = S0 * np.exp(-sigma * t) + mu * n**2\n            return g_vec\n\n        memo_C_inv = {}\n        def get_C_inv(dt):\n            \"\"\"Memoized calculation of the corrector matrix inverse.\"\"\"\n            if dt not in memo_C_inv:\n                C_sys = M - dt * A\n                memo_C_inv[dt] = np.linalg.inv(C_sys)\n            return memo_C_inv[dt]\n\n        def _adaptive_step(y_n, t_n, dt):\n            \"\"\"\n            Performs one adaptive time step from t_n to t_n + dt.\n            Returns (y_next, rejections).\n            \"\"\"\n            t_next = t_n + dt\n            C_sys_inv = get_C_inv(dt)\n\n            # --- Attempt 1: Euler Predictor ---\n            g_n = g(y_n, t_n)\n            y_hat_euler = y_n + dt * M_inv @ g_n\n            g_hat_euler = g(y_hat_euler, t_next)\n            \n            rhs_euler = M @ y_n + dt * g_hat_euler\n            y_next_euler = C_sys_inv @ rhs_euler\n            \n            g_next_euler = g(y_next_euler, t_next)\n            residual = dt * (g_hat_euler - g_next_euler)\n            err_norm = np.linalg.norm(residual)\n            tol = tau_abs + tau_rel * np.linalg.norm(M @ y_next_euler)\n\n            if err_norm = tol:\n                return y_next_euler, 0\n\n            # --- Euler predictor rejected ---\n            rejections = 1\n\n            # --- Attempt 2: Heun Predictor ---\n            y_tilde = y_n + dt * M_inv @ g_n  # Same as y_hat_euler\n            g_tilde = g(y_tilde, t_next)\n            y_hat_heun = y_n + (dt / 2.0) * M_inv @ (g_n + g_tilde)\n            g_hat_heun = g(y_hat_heun, t_next)\n\n            rhs_heun = M @ y_n + dt * g_hat_heun\n            y_next_heun = C_sys_inv @ rhs_heun\n\n            g_next_heun = g(y_next_heun, t_next)\n            residual = dt * (g_hat_heun - g_next_heun)\n            err_norm = np.linalg.norm(residual)\n            tol = tau_abs + tau_rel * np.linalg.norm(M @ y_next_heun)\n\n            if err_norm = tol:\n                return y_next_heun, rejections\n\n            # --- Heun predictor also rejected ---\n            rejections += 1\n\n            # --- Attempt 3: Sub-stepping ---\n            y_mid, rej1 = _adaptive_step(y_n, t_n, dt / 2.0)\n            y_final, rej2 = _adaptive_step(y_mid, t_n + dt / 2.0, dt / 2.0)\n\n            return y_final, rejections + rej1 + rej2\n\n        # Main time-stepping loop\n        y = np.copy(y0)\n        t = 0.0\n        total_rejections = 0\n        for _ in range(N):\n            y_new, rejs = _adaptive_step(y, t, dt_base)\n            y = y_new\n            t += dt_base\n            total_rejections += rejs\n        \n        return [y[0], y[1], total_rejections]\n\n    # Shared parameters for all test cases\n    shared_params = {\n        'beta': 0.0065,\n        'Lambda': 1.0e-5,\n        'lambda': 0.08,\n        'S0': 1.0e4,\n        'sigma': 1.0,\n        'y0': np.array([1.0e4, 0.0]),\n        'tau_abs': 1.0e-6,\n        'tau_rel': 1.0e-4,\n    }\n\n    # Test cases\n    test_cases = [\n        {  # Case 1\n            'mu': 1.0e-11,\n            'M': np.diag([1.0, 1.0]),\n            'dt': 1.0e-4,\n            'N': 1000,\n        },\n        {  # Case 2\n            'mu': 1.0e-7,\n            'M': np.diag([1.0, 0.5]),\n            'dt': 5.0e-3,\n            'N': 200,\n        },\n        {  # Case 3\n            'mu': 1.0e-6,\n            'M': np.diag([1.0, 1.0]),\n            'dt': 5.0e-2,\n            'N': 20,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        params = {**shared_params, **case_params}\n        result = run_case(params)\n        results.append(result)\n\n    # Format the final output string exactly as requested\n    def format_list(lst):\n        return f\"[{lst[0]},{lst[1]},{lst[2]}]\"\n\n    print(f\"[{','.join(map(format_list, results))}]\")\n\nsolve()\n```"
        }
    ]
}