{
    "hands_on_practices": [
        {
            "introduction": "这第一个实践将 PCQS 方法植根于反应堆物理学的基本原理。在我们求解振幅的点动力学方程之前，我们需要确定有效参数 $\\beta_{\\text{eff}}$ 和 $\\Lambda$。本练习将演示如何直接从通量形状函数出发，推导并数值计算这些关键参数，而无需借助伴随通量加权，这有助于我们深入理解：这些参数并非基本常数，而是依赖于形状并随时间变化的量。",
            "id": "4242130",
            "problem": "给定一个与核反应堆模拟中的预估-校正准静态 (PCQS) 方法相关的一维平板几何多群设置，其中中子通量被分解为一个幅值和一个形状函数。您需要从基本的多群平衡概念（中子密度、裂变源率）出发，仅使用所提供的形状函数和截面，推导有效缓发中子份额和瞬发中子代时间的有效数值估算量。将推导出的估算量实现为均匀网格上的中点法则求积，并评估估算量对形状函数离散化的敏感性。\n\n使用以下基本依据：\n\n-   能群 $g$ 中的中子密度与中子通量之间的关系为 $n_g(\\mathbf{r},t) = \\phi_g(\\mathbf{r},t)/v_g$，其中 $v_g$ 是能群 $g$ 中的中子速度。\n-   总裂变产生率为 $F(t) = \\sum_{g} \\int \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$，其中 $\\nu_g$ 是由群 $g$ 中的中子引起的每次裂变产生的平均中子数，$\\Sigma_{f,g}$ 是群 $g$ 的宏观裂变截面。\n-   产生点的缓发中子份额由分群缓发份额 $\\beta_g$ 表征，本问题中假设其在空间上为常数。缓发裂变产生率为 $F_d(t) = \\sum_{g} \\int \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$。\n-   在准静态分解中，通量表示为 $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r},t)$，其中 $A(t)$ 是一个幅值，$\\psi_g$ 是一个捕捉空间和能量依赖性的形状函数。\n\n任务：\n\n$1.$ 仅使用上述基本依据，推导有效缓发中子份额 $\\beta_{\\text{eff}}(t)$ 和瞬发中子代时间 $\\Lambda(t)$ 的表达式，用形状函数 $\\psi_g(\\mathbf{r},t)$ 的空间积分、群速度 $v_g$、宏观裂变截面 $\\Sigma_{f,g}(\\mathbf{r})$ 和分群缓发份额 $\\beta_g$ 来表示，不使用任何伴随权重或输运-特征值快捷方法。明确说明您为消除对幅值 $A(t)$ 的依赖而依赖的任何准静态假设。\n\n$2.$ 在长度为 $L$ 的一维平板几何中，将体积积分替换为在 $x \\in [0,L]$ 上的线积分，并使用中点法则在具有 $N$ 个网格单元的均匀网格上进行数值计算，网格宽度为 $\\Delta x = L/N$，中点为 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。\n\n$3.$ 实现一个程序，对下面指定的每个测试用例，计算：\n-   有效缓发中子份额 $\\beta_{\\text{eff}}$（无量纲）。\n-   瞬发中子代时间 $\\Lambda$（单位：秒）。\n-   每个量的相对离散化敏感性，定义为 $E_{\\beta} = \\left|\\beta_{\\text{eff}}^{(N)} - \\beta_{\\text{eff}}^{(\\text{ref})}\\right| / \\left|\\beta_{\\text{eff}}^{(\\text{ref})}\\right|$ 和 $E_{\\Lambda} = \\left|\\Lambda^{(N)} - \\Lambda^{(\\text{ref})}\\right| / \\left|\\Lambda^{(\\text{ref})}\\right|$，其中参考值是在具有 $N_{\\text{ref}}$ 个单元的非常精细的网格上计算的。\n\n假设与单位：\n\n-   考虑两个能群，索引为 $g \\in \\{1,2\\}$。\n-   使用一维平板几何，其中 $x \\in [0,L]$，$L$ 的单位为厘米，宏观截面的单位为 $\\text{cm}^{-1}$，速度的单位为 $\\text{cm}/\\text{s}$，并以秒为单位计算 $\\Lambda$。有效缓发中子份额 $\\beta_{\\text{eff}}$ 是无量纲的。\n-   形状函数直接作为 $x$ 和能群 $g$ 的函数给出；无需解任何输运或扩散方程。\n-   中子产额 $\\nu_g$ 和缓发份额 $\\beta_g$ 是常数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身应该是一个包含四个浮点数的列表，顺序为 $[\\beta_{\\text{eff}}, \\Lambda, E_{\\beta}, E_{\\Lambda}]$，每个浮点数四舍五入到八位小数。因此，整体输出应类似于 $[[b_1,\\lambda_1,e_{b,1},e_{\\lambda,1}],[b_2,\\lambda_2,e_{b,2},e_{\\lambda,2}],\\dots]$。\n\n测试套件：\n\n对于所有用例，使用具有 $N_{\\text{ref}} = 50000$ 的精细参考离散化。\n\n用例 A（平滑形状函数，均匀材料）：\n\n-   区域长度 $L = 100.0$。\n-   群速度：$v_1 = 2.2\\times 10^{5}$，$v_2 = 1.0\\times 10^{7}$。\n-   中子产额：$\\nu_1 = 2.43$，$\\nu_2 = 2.43$。\n-   宏观裂变截面：$\\Sigma_{f,1}(x) = 5.0\\times 10^{-3}$，$\\Sigma_{f,2}(x) = 1.0\\times 10^{-3}$。\n-   缓发份额：$\\beta_1 = 4.0\\times 10^{-3}$，$\\beta_2 = 2.5\\times 10^{-3}$。\n-   形状函数：$\\psi_1(x) = \\sin\\left(\\pi x/L\\right)$，$\\psi_2(x) = 0.6\\,\\sin\\left(\\pi x/L\\right)$。\n-   用于评估的粗网格离散化：$N = 20$。\n\n用例 B（材料不连续，平滑形状函数）：\n\n-   区域长度 $L = 100.0$。\n-   群速度：$v_1 = 2.2\\times 10^{5}$，$v_2 = 1.0\\times 10^{7}$。\n-   中子产额：$\\nu_1 = 2.43$，$\\nu_2 = 2.43$。\n-   宏观裂变截面：\n    -   当 $x  L/2$ 时，$\\Sigma_{f,1}(x) = 3.0\\times 10^{-3}$；当 $x \\ge L/2$ 时，$\\Sigma_{f,1}(x) = 7.0\\times 10^{-3}$。\n    -   当 $x  L/2$ 时，$\\Sigma_{f,2}(x) = 8.0\\times 10^{-4}$；当 $x \\ge L/2$ 时，$\\Sigma_{f,2}(x) = 1.2\\times 10^{-3}$。\n-   缓发份额：$\\beta_1 = 4.0\\times 10^{-3}$，$\\beta_2 = 2.5\\times 10^{-3}$。\n-   形状函数：$\\psi_1(x) = \\sin\\left(\\pi x/L\\right)$，$\\psi_2(x) = 0.6\\,\\sin\\left(\\pi x/L\\right)$。\n-   用于评估的粗网格离散化：$N = 40$。\n\n用例 C（更陡峭的形状函数，均匀材料）：\n\n-   区域长度 $L = 100.0$。\n-   群速度：$v_1 = 2.2\\times 10^{5}$，$v_2 = 1.0\\times 10^{7}$。\n-   中子产额：$\\nu_1 = 2.43$，$\\nu_2 = 2.43$。\n-   宏观裂变截面：$\\Sigma_{f,1}(x) = 4.0\\times 10^{-3}$，$\\Sigma_{f,2}(x) = 1.5\\times 10^{-3}$。\n-   缓发份额：$\\beta_1 = 4.0\\times 10^{-3}$，$\\beta_2 = 2.5\\times 10^{-3}$。\n-   形状函数：$\\psi_1(x) = \\sin\\left(\\pi x/L\\right) + 0.2\\,\\sin\\left(3\\pi x/L\\right)$，$\\psi_2(x) = 0.5\\,\\sin\\left(\\pi x/L\\right) + 0.1\\,\\sin\\left(3\\pi x/L\\right)$。\n-   用于评估的粗网格离散化：$N = 30$。\n\n实现细节与输出：\n\n-   在每种情况下，对粗略估算使用指定的 $N$ 个网格单元的中点法则求积，对参考估算使用 $N_{\\text{ref}}$。\n-   将形状函数 $\\psi_g(x)$ 视为无量纲函数。您不需要进行任何幅值归一化，但您的推导必须证明为什么在所求的比率中幅值会相消。\n-   您的程序应恰好产生一行输出：一个包含三个内部列表的方括号列表，每个内部列表对应一个用例，包含四个浮点数 $[\\beta_{\\text{eff}}, \\Lambda, E_{\\beta}, E_{\\Lambda}]$，四舍五入到八位小数，且无附加文本。",
            "solution": "该问题是有效的，因为它在科学上基于核反应堆物理学的既定原理，是适定的、客观的，并且包含获得唯一解所需的所有信息。任务要求推导和数值实现反应堆动力学参数，这是一个标准且可验证的程序。\n\n### 第1部分：估算量的推导\n\n目标是使用所提供的基本定义和准静态通量分解，推导有效缓发中子份额 $\\beta_{\\text{eff}}$ 和瞬发中子代时间 $\\Lambda$ 的表达式。推导过程不得使用伴随权重。\n\n**1.1. 有效缓发中子份额 ($\\beta_{\\text{eff}}$)**\n\n有效缓发中子份额 $\\beta_{\\text{eff}}$ 定义为总缓发裂变中子产生率与总（瞬发加缓发）裂变中子产生率之比。\n\n总裂变产生率 $F(t)$ 由下式给出：\n$$F(t) = \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$$\n其中 $\\nu_g$ 是由能群 $g$ 中的中子诱发的每次裂变产生的中子数，$\\Sigma_{f,g}(\\mathbf{r})$ 是宏观裂变截面，$\\phi_g(\\mathbf{r},t)$ 是中子通量。积分遍及反应堆体积 $V$。\n\n缓发裂变产生率 $F_d(t)$ 由下式给出：\n$$F_d(t) = \\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$$\n其中 $\\beta_g$ 是由群 $g$ 中的中子诱发的裂变中子中缓发中子所占的份额。\n\n根据定义，$\\beta_{\\text{eff}}(t)$ 是这两个率的比值：\n$$\\beta_{\\text{eff}}(t) = \\frac{F_d(t)}{F(t)} = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}$$\n\n我们引入准静态通量分解 $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r},t)$，其中 $A(t)$ 是一个随时间变化的幅值，$\\psi_g(\\mathbf{r},t)$ 是一个随时间变化的形状函数。准静态方法的一个关键假设是形状函数 $\\psi_g$ 随时间变化缓慢，这使我们可以在计算特定时刻的积分参数时将其视为常数。本问题提供了不随时间变化的形状函数 $\\psi_g(\\mathbf{r})$，这与该假设一致。\n\n将分解式代入 $\\beta_{\\text{eff}}$ 的表达式中：\n$$\\beta_{\\text{eff}}(t) = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) A(t)\\,\\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) A(t)\\,\\psi_g(\\mathbf{r}) \\, dV}$$\n由于幅值 $A(t)$ 与空间（$\\mathbf{r}$）和能群（$g$）无关，它可以从分子和分母的积分和求和中提出来：\n$$\\beta_{\\text{eff}}(t) = \\frac{A(t) \\left( \\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}{A(t) \\left( \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}$$\n只要 $A(t) \\ne 0$ 且总裂变率不为零，幅值 $A(t)$ 就会相消。这种相消证明了为什么结果与通量幅值和形状函数 $\\psi_g$ 的任何任意归一化无关。最终的表达式仅依赖于形状函数和材料属性：\n$$\\beta_{\\text{eff}} = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}$$\n\n**1.2. 瞬发中子代时间 ($\\Lambda$)**\n\n瞬发中子代时间 $\\Lambda$ 定义为反应堆中的总中子布居与总裂变中子产生率之比。\n\n总中子布居 $N_{\\text{total}}(t)$ 是总中子密度的体积积分。群 $g$ 中的中子密度为 $n_g(\\mathbf{r},t) = \\phi_g(\\mathbf{r},t)/v_g$，其中 $v_g$ 是群 $g$ 的平均中子速度。\n$$N_{\\text{total}}(t) = \\sum_{g} \\int_V n_g(\\mathbf{r},t) \\, dV = \\sum_{g} \\int_V \\frac{\\phi_g(\\mathbf{r},t)}{v_g} \\, dV$$\n总裂变产生率 $F(t)$ 与前面定义的相同。\n\n根据定义，$\\Lambda(t)$ 为：\n$$\\Lambda(t) = \\frac{N_{\\text{total}}(t)}{F(t)} = \\frac{\\sum_{g} \\int_V \\frac{\\phi_g(\\mathbf{r},t)}{v_g} \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}$$\n代入分解式 $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r})$ 并再次提出幅值 $A(t)$：\n$$\\Lambda(t) = \\frac{A(t) \\left( \\sum_{g} \\frac{1}{v_g} \\int_V \\psi_g(\\mathbf{r}) \\, dV \\right)}{A(t) \\left( \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}$$\n幅值 $A(t)$ 相消，得到瞬发中子代时间的最终表达式：\n$$\\Lambda = \\frac{\\sum_{g} \\frac{1}{v_g} \\int_V \\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}$$\n\n### 第2部分：一维平板几何中的数值实现\n\n对于长度为 $L$ 的一维平板，假设单位横截面积，体积微分 $dV$ 被线微分 $dx$ 替代。积分在区域 $x \\in [0, L]$ 上进行。\n\n表达式变为：\n$$\\beta_{\\text{eff}} = \\frac{\\sum_{g} \\int_0^L \\beta_g \\, \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}{\\sum_{g} \\int_0^L \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}$$\n$$\\Lambda = \\frac{\\sum_{g} \\frac{1}{v_g} \\int_0^L \\psi_g(x) \\, dx}{\\sum_{g} \\int_0^L \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}$$\n\n我们使用中点法则求积在一个包含 $N$ 个单元的均匀网格上近似这些积分。单元宽度为 $\\Delta x = L/N$，单元中点为 $x_i = (i + 1/2)\\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。积分 $\\int_0^L f(x) \\, dx$ 可近似为：\n$$\\int_0^L f(x) \\, dx \\approx \\sum_{i=0}^{N-1} f(x_i) \\Delta x$$\n\n让我们定义以下在网格点上的求和：\n$$S_{f,g} = \\sum_{i=0}^{N-1} \\Sigma_{f,g}(x_i) \\psi_g(x_i)$$\n$$S_{\\psi,g} = \\sum_{i=0}^{N-1} \\psi_g(x_i)$$\n\n积分于是近似为：\n$$\\int_0^L \\Sigma_{f,g}(x) \\psi_g(x) \\, dx \\approx S_{f,g} \\Delta x$$\n$$\\int_0^L \\psi_g(x) \\, dx \\approx S_{\\psi,g} \\Delta x$$\n\n将这些近似代入 $\\beta_{\\text{eff}}$ 和 $\\Lambda$ 的表达式中：\n$$\\beta_{\\text{eff}}^{(N)} = \\frac{\\sum_{g} \\beta_g \\, \\nu_g (S_{f,g} \\Delta x)}{\\sum_{g} \\nu_g (S_{f,g} \\Delta x)} = \\frac{\\Delta x \\sum_{g} \\beta_g \\nu_g S_{f,g}}{\\Delta x \\sum_{g} \\nu_g S_{f,g}} = \\frac{\\sum_{g} \\beta_g \\nu_g S_{f,g}}{\\sum_{g} \\nu_g S_{f,g}}$$\n$$\\Lambda^{(N)} = \\frac{\\sum_{g} \\frac{1}{v_g} (S_{\\psi,g} \\Delta x)}{\\sum_{g} \\nu_g (S_{f,g} \\Delta x)} = \\frac{\\Delta x \\sum_{g} \\frac{1}{v_g} S_{\\psi,g}}{\\Delta x \\sum_{g} \\nu_g S_{f,g}} = \\frac{\\sum_{g} \\frac{1}{v_g} S_{\\psi,g}}{\\sum_{g} \\nu_g S_{f,g}}$$\n公共因子 $\\Delta x = L/N$ 在两个表达式中都相消了。因此，数值估算量可通过在单元中点评估被积函数并求和来计算，无需乘以单元宽度。\n\n### 第3部分：离散化敏感性\n\n对于一个量 $Q$（$\\beta_{\\text{eff}}$ 或 $\\Lambda$），其相对离散化敏感性计算如下：\n$$E_Q = \\frac{\\left|Q^{(N)} - Q^{(\\text{ref})}\\right|}{\\left|Q^{(\\text{ref})}\\right|}$$\n其中 $Q^{(N)}$ 是在包含 $N$ 个单元的粗网格上计算的值，而 $Q^{(\\text{ref})}$ 是在包含 $N_{\\text{ref}}$ 个单元的非常精细的网格上计算的参考值，它作为真实连续值的近似。\n\n程序将为每个测试用例实现这些公式，计算粗网格（$N$）和参考网格（$N_{\\text{ref}}$）下的量，然后计算敏感性，最后打印格式化的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_kinetics(L, v, nu, beta, sigma_f_funcs, psi_funcs, N):\n    \"\"\"\n    Computes effective delayed neutron fraction and prompt neutron generation time.\n\n    Args:\n        L (float): Domain length in cm.\n        v (tuple): Group speeds (v1, v2) in cm/s.\n        nu (tuple): Neutrons per fission (nu1, nu2).\n        beta (tuple): Delayed neutron fractions (beta1, beta2).\n        sigma_f_funcs (tuple): Functions for macroscopic fission cross sections.\n        psi_funcs (tuple): Functions for shape functions.\n        N (int): Number of discretization cells.\n\n    Returns:\n        tuple: (beta_eff, Lambda)\n    \"\"\"\n    v1, v2 = v\n    nu1, nu2 = nu\n    beta1, beta2 = beta\n    sigma_f1_func, sigma_f2_func = sigma_f_funcs\n    psi1_func, psi2_func = psi_funcs\n\n    # Create grid of cell midpoints\n    dx = L / N\n    x_midpoints = (np.arange(N) + 0.5) * dx\n\n    # Evaluate shapes and cross sections at midpoints\n    psi1_vals = psi1_func(x_midpoints)\n    psi2_vals = psi2_func(x_midpoints)\n    sigma_f1_vals = sigma_f1_func(x_midpoints)\n    sigma_f2_vals = sigma_f2_func(x_midpoints)\n\n    # Calculate sums S_f,g and S_psi,g\n    S_f1 = np.sum(sigma_f1_vals * psi1_vals)\n    S_f2 = np.sum(sigma_f2_vals * psi2_vals)\n    S_psi1 = np.sum(psi1_vals)\n    S_psi2 = np.sum(psi2_vals)\n\n    # Calculate numerators and the common denominator for beta_eff and Lambda\n    # Denominator: total fission source rate integral (without amplitude)\n    I_den = nu1 * S_f1 + nu2 * S_f2\n    \n    # Numerator for beta_eff: delayed fission source rate integral\n    I_beta_num = beta1 * nu1 * S_f1 + beta2 * nu2 * S_f2\n    \n    # Numerator for Lambda: total neutron population integral (flux/v)\n    I_Lambda_num = (1.0 / v1) * S_psi1 + (1.0 / v2) * S_psi2\n    \n    if I_den == 0:\n        return (np.nan, np.nan)\n\n    # Compute beta_eff and Lambda\n    beta_eff = I_beta_num / I_den\n    Lambda = I_Lambda_num / I_den\n\n    return beta_eff, Lambda\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    N_ref = 50000\n\n    test_cases = [\n        # Case A: Smooth shape, uniform material\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: 5.0e-3,\n                lambda x: 1.0e-3\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0),\n                lambda x: 0.6 * np.sin(np.pi * x / 100.0)\n            ),\n            \"N\": 20\n        },\n        # Case B: Material discontinuity, smooth shape\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: np.where(x  50.0, 3.0e-3, 7.0e-3),\n                lambda x: np.where(x  50.0, 8.0e-4, 1.2e-3)\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0),\n                lambda x: 0.6 * np.sin(np.pi * x / 100.0)\n            ),\n            \"N\": 40\n        },\n        # Case C: Steeper shape, uniform material\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: 4.0e-3,\n                lambda x: 1.5e-3\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0) + 0.2 * np.sin(3 * np.pi * x / 100.0),\n                lambda x: 0.5 * np.sin(np.pi * x / 100.0) + 0.1 * np.sin(3 * np.pi * x / 100.0)\n            ),\n            \"N\": 30\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Reference calculation with a very fine grid\n        beta_ref, Lambda_ref = compute_kinetics(\n            case[\"L\"], case[\"v\"], case[\"nu\"], case[\"beta\"],\n            case[\"sigma_f_funcs\"], case[\"psi_funcs\"], N_ref\n        )\n\n        # Coarse calculation with the specified grid size N\n        beta_n, Lambda_n = compute_kinetics(\n            case[\"L\"], case[\"v\"], case[\"nu\"], case[\"beta\"],\n            case[\"sigma_f_funcs\"], case[\"psi_funcs\"], case[\"N\"]\n        )\n\n        # Calculate relative discretization sensitivities\n        E_beta = np.abs(beta_n - beta_ref) / np.abs(beta_ref)\n        E_Lambda = np.abs(Lambda_n - Lambda_ref) / np.abs(Lambda_ref)\n\n        case_results = [\n            round(beta_n, 8),\n            round(Lambda_n, 8),\n            round(E_beta, 8),\n            round(E_Lambda, 8)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists\n    results_str_list = []\n    for res_list in all_results:\n        results_str_list.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "PCQS 方法的核心是在一个粗略的时间步内对解进行迭代优化。本练习将隔离单个预测-校正步骤，以聚焦于缓发中子先驱核的动力学行为。通过计算总先驱核浓度的变化，您将直接观察到通量形状从预测值更新为校正值时，裂变源项是如何被修正的，从而更精确地描绘出时间步末的反应堆状态。",
            "id": "4242155",
            "problem": "考虑一个均匀热中子反应堆，它由两个空间均匀的区域（区域 $A$ 和区域 $B$）表示，每个区域的体积相等，即 $V_A = V_B = 1$（任意体积单位）。裂变产生系数是空间依赖的，由 $\\nu \\Sigma_{f,A} = 2$ 和 $\\nu \\Sigma_{f,B} = 1$ 给出（任意一致单位）。假设采用预测-校正准静态 (PCQS) 方法：中子通量被分解为 $\\phi(\\mathbf{r}, t) = P(t) S(\\mathbf{r}, t)$，其中 $P(t)$ 是全局幅度，$S(\\mathbf{r}, t)$ 是形状函数。形状函数被归一化，使得 $\\int_{V} S(\\mathbf{r}, t) \\, dV = 1$。\n\n对于单个族 $i$，总的缓发中子先驱核浓度表示为 $N_i(t) = \\int_{V} C_i(\\mathbf{r}, t) \\, dV$，它遵循由缓发中子源和衰变推导出的空间积分先驱核平衡方程：\n$$\n\\frac{d N_i(t)}{d t} = \\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV - \\lambda_i N_i(t),\n$$\n其中 $\\beta_i$ 是族 $i$ 的（无量纲）缓发中子份额，$\\lambda_i$ 是其衰变常数。\n\n在一个持续时间为 $\\Delta T = 0.5 \\ \\mathrm{s}$ 的单个 PCQS 粗时间步内，全局幅度从 $P(t) = P_0 = 1.0$ 增加到 $P(t + \\Delta T) = P_1 = 1.2$。形状从时间步开始时的预测形状，\n$$\nS(\\mathbf{r}, t): \\quad s_A^{p,0} = 0.55, \\quad s_B^{p,0} = 0.45,\n$$\n更新到时间步结束时的校正形状，\n$$\nS(\\mathbf{r}, t+\\Delta T): \\quad s_A^{c,1} = 0.60, \\quad s_B^{c,1} = 0.40,\n$$\n在每个时刻，形状归一化为 $\\int_{V} S(\\mathbf{r}, t) \\, dV = s_A + s_B = 1$。\n\n设初始先驱核浓度为 $N_i(t) = N_0 = 2.000 \\times 10^{-2}$（归一化浓度单位），缓发中子份额为 $\\beta_i = 1.00 \\times 10^{-3}$，衰变常数为 $\\lambda_i = 8.0 \\times 10^{-2} \\ \\mathrm{s}^{-1}$。\n\n使用 PCQS 预测-校正更新，将源项 $\\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV$ 近似为在粗时间步内，在其位于 $t$ 的预测值和位于 $t+\\Delta T$ 的校正值之间线性变化，并使用先驱核常微分方程的精确积分因子解来计算 $N_i(t+\\Delta T)$。显式地计算时间步开始和结束时，使用给定的 $s_A$ 和 $s_B$ 的形状加权裂变产生积分。\n\n将您对 $N_i(t+\\Delta T)$ 的最终答案四舍五入到五位有效数字。以与 $N_i(t)$ 相同的归一化浓度单位表示最终浓度。",
            "solution": "该问题被验证为具有科学依据、问题明确且客观。这是一个使用预测-校正准静态 (PCQS) 方法的核反应堆动力学标准问题。所有提供的数据都是一致的，并且足以得到唯一解。\n\n该问题要求计算在持续时间为 $\\Delta T$ 的时间步结束时，单个族 $i$ 的总缓发中子先驱核浓度 $N_i(t+\\Delta T)$。$N_i(t)$ 的演化由以下常微分方程 (ODE) 控制：\n$$\n\\frac{d N_i(t)}{d t} = Q_i(t) - \\lambda_i N_i(t)\n$$\n其中 $Q_i(t)$ 是源项，由下式给出：\n$$\nQ_i(t) = \\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV\n$$\n该问题定义在时间区间 $[t_0, t_0+\\Delta T]$ 上。为简单起见，我们设置 $t_0=0$，所以区间为 $[0, \\Delta T]$。\n\n首先，我们必须计算时间步开始 ($t=0$) 和结束 ($t=\\Delta T$) 时的源项 $Q_i(t)$。该积分表示形状加权的裂变产生率，我们将其表示为 $F(t) = \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV$。由于反应堆由两个均匀区域 A 和 B 组成，该积分变为：\n$$\nF(t) = \\int_{V_A} \\nu \\Sigma_{f,A} S(\\mathbf{r}, t) \\, dV + \\int_{V_B} \\nu \\Sigma_{f,B} S(\\mathbf{r}, t) \\, dV\n$$\n问题陈述，形状函数 $S(\\mathbf{r},t)$ 在每个区域内是空间均匀的，其值分别为 $s_A(t)$ 和 $s_B(t)$。给定 $V_A = V_B = 1$（任意体积单位），积分简化为：\n$$\nF(t) = (\\nu \\Sigma_{f,A}) s_A(t) V_A + (\\nu \\Sigma_{f,B}) s_B(t) V_B = (\\nu \\Sigma_{f,A}) s_A(t) + (\\nu \\Sigma_{f,B}) s_B(t)\n$$\n\n在时间步开始时 ($t=0$)，我们使用预测形状和初始幅度：\n- $\\nu \\Sigma_{f,A} = 2$, $\\nu \\Sigma_{f,B} = 1$\n- $s_A(0) = s_A^{p,0} = 0.55$, $s_B(0) = s_B^{p,0} = 0.45$\n- $P(0) = P_0 = 1.0$\n- $\\beta_i = 1.00 \\times 10^{-3} = 0.001$\n\n在 $t=0$ 时的形状加权裂变产生率为：\n$$\nF_0 = F(0) = (2)(0.55) + (1)(0.45) = 1.10 + 0.45 = 1.55\n$$\n在 $t=0$ 时的源项为：\n$$\nQ_{i,0} = \\beta_i P_0 F_0 = (0.001)(1.0)(1.55) = 0.00155\n$$\n\n在时间步结束时 ($t=\\Delta T$)，我们使用校正形状和最终幅度：\n- $s_A(\\Delta T) = s_A^{c,1} = 0.60$, $s_B(\\Delta T) = s_B^{c,1} = 0.40$\n- $P(\\Delta T) = P_1 = 1.2$\n\n在 $t=\\Delta T$ 时的形状加权裂变产生率为：\n$$\nF_1 = F(\\Delta T) = (2)(0.60) + (1)(0.40) = 1.20 + 0.40 = 1.60\n$$\n在 $t=\\Delta T$ 时的源项为：\n$$\nQ_{i,1} = \\beta_i P_1 F_1 = (0.001)(1.2)(1.60) = 0.00192\n$$\n\n问题指定将源项 $Q_i(t')$ 近似为在时间步 $t' \\in [0, \\Delta T]$ 上线性变化：\n$$\nQ_i(t') = Q_{i,0} + \\frac{Q_{i,1} - Q_{i,0}}{\\Delta T} t'\n$$\n该 ODE 为 $\\frac{d N_i}{dt'} + \\lambda_i N_i = Q_i(t')$。使用积分因子 $\\exp(\\lambda_i t')$，$N_i(\\Delta T)$ 的精确解为：\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + \\exp(-\\lambda_i \\Delta T) \\int_{0}^{\\Delta T} Q_i(t') \\exp(\\lambda_i t') dt'\n$$\n积分部分表示源项的贡献。让我们用 $Q_i(t')$ 的线性近似来计算这个积分。一个方便的积分变量代换是 $u = \\Delta T - t'$，这会导出解的形式：\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + \\int_{0}^{\\Delta T} Q_i(\\Delta T - u) \\exp(-\\lambda_i u) du\n$$\n以 $u$ 表示的线性源项为 $Q_i(\\Delta T - u) = Q_{i,1} - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T}u$。\n源项的贡献是：\n$$\n\\int_0^{\\Delta T} \\left( Q_{i,1} - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T} u \\right) \\exp(-\\lambda_i u) du = Q_{i,1} \\int_0^{\\Delta T} \\exp(-\\lambda_i u) du - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T} \\int_0^{\\Delta T} u \\exp(-\\lambda_i u) du\n$$\n计算这两个积分得到：\n$$\n\\int_0^{\\Delta T} \\exp(-\\lambda_i u) du = \\frac{1 - \\exp(-\\lambda_i \\Delta T)}{\\lambda_i}\n$$\n$$\n\\int_0^{\\Delta T} u \\exp(-\\lambda_i u) du = \\frac{1}{\\lambda_i^2} - \\frac{\\Delta T \\exp(-\\lambda_i \\Delta T)}{\\lambda_i} - \\frac{\\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2}\n$$\n结合这些结果并按 $Q_{i,0}$ 和 $Q_{i,1}$ 分组项，我们得到解析解：\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + Q_{i,0} \\left( \\frac{1 - \\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2 \\Delta T} - \\frac{\\exp(-\\lambda_i \\Delta T)}{\\lambda_i} \\right) + Q_{i,1} \\left( \\frac{\\lambda_i \\Delta T - 1 + \\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2 \\Delta T} \\right)\n$$\n现在我们代入数值：\n- 初始浓度: $N_i(0) = N_0 = 2.000 \\times 10^{-2} = 0.02$\n- 衰变常数: $\\lambda_i = 8.0 \\times 10^{-2} \\ \\mathrm{s}^{-1} = 0.08 \\ \\mathrm{s}^{-1}$\n- 时间步: $\\Delta T = 0.5 \\ \\mathrm{s}$\n- $Q_{i,0} = 0.00155$\n- $Q_{i,1} = 0.00192$\n\n我们计算解中的各项：\n- $\\lambda_i \\Delta T = (0.08)(0.5) = 0.04$\n- $\\exp(-\\lambda_i \\Delta T) = \\exp(-0.04) \\approx 0.960789439$\n- $\\lambda_i^2 \\Delta T = (0.08)^2 (0.5) = (0.0064)(0.5) = 0.0032$\n\n$Q_{i,0}$ 的系数是：\n$$\n\\frac{1 - \\exp(-0.04)}{(0.0032)} - \\frac{\\exp(-0.04)}{0.08} = \\frac{1 - 0.960789439}{0.0032} - \\frac{0.960789439}{0.08} \\approx 12.253300 - 12.009868 = 0.243432\n$$\n$Q_{i,1}$ 的系数是：\n$$\n\\frac{0.04 - 1 + \\exp(-0.04)}{0.0032} = \\frac{0.04 - 1 + 0.960789439}{0.0032} = \\frac{0.000789439}{0.0032} \\approx 0.2466998\n$$\n现在，我们计算 $N_i(\\Delta T)$：\n$$\nN_i(\\Delta T) = (0.02) \\exp(-0.04) + (0.00155)(0.243432) + (0.00192)(0.2466998)\n$$\n$$\nN_i(\\Delta T) \\approx (0.02)(0.960789439) + 0.0003773196 + 0.0004736636\n$$\n$$\nN_i(\\Delta T) \\approx 0.0192157888 + 0.0003773196 + 0.0004736636\n$$\n$$\nN_i(\\Delta T) \\approx 0.020066772\n$$\n按要求四舍五入到五位有效数字：\n$$\nN_i(t+\\Delta T) \\approx 0.020067\n$$",
            "answer": "$$\\boxed{0.020067}$$"
        },
        {
            "introduction": "既然存在更简单的点动力学模型，我们为何还需要准静态方法这样的复杂模型呢？最后一个实践将通过构建和比较这两种模型来回答这个问题。通过模拟一个具有非均匀反应性引入的瞬态过程，您将量化 PCQS 方法的预测结果与纯点动力学结果之间的偏差，从而揭示通量形状变化在精确捕捉反应堆行为方面所起的关键作用。",
            "id": "4242119",
            "problem": "考虑一个一维、均匀的热中子核反应堆，其表示为长度为 $L$ 的平板，在 $x=0$ 和 $x=L$ 处采用真空边界条件。该反应堆使用单能中子平衡与单组缓发中子进行建模，中子布居通过幅值-形状因子分解法表示，其中中子通量写作 $\\phi(x,t) = A(t) S(x,t)$，其中 $S(x,t)$ 被归一化以始终满足 $\\int_0^L S(x,t)\\,dx = 1$。该反应堆是均匀的，意味着材料属性不随空间变化，但允许引入空间非均匀和时间相关的外部反应性。物理时间单位必须是秒，空间距离单位必须是厘米。\n\n动力学的基础应为：\n- 反应堆幅值的点堆动力学模型，包含单组缓发中子，用幅值 $A(t)$ 和缓发中子先驱核幅值 $C(t)$ 表示：\n  - $A(t)$ 因净有效反应性和缓发中子源而演化。\n  - $C(t)$ 因 $A(t)$ 产生并通过常数 $\\lambda_d$ 衰变而演化。\n- 在非均匀反应性作用下，形状的演化会导致偏离基波空间模式，该偏离由模态展开中的一阶谐波系数 $b_1(t)$ 捕捉。\n\n您将实现两个模型：\n- 一种预估-校正准静态方法 (PCQS)，其中幅值 $A(t)$ 使用包含形状修正的时间相关有效反应性的点堆动力学模型进行推进，而形状偏离系数 $b_1(t)$ 通过一个受驱、阻尼常微分方程进行推进，该方程表示一阶谐波形状在非均匀反应性下的一阶响应。\n- 一种纯点堆动力学模型 (PK)，其中幅值 $A_{\\mathrm{PK}}(t)$ 使用相同的点堆动力学方程进行推进，但通量形状被假定为始终固定且等于基波模式，并忽略形状修正项。\n\n使用的定义和核心构造：\n- 令基波模式为 $S_0(x) = \\sin\\left(\\frac{\\pi x}{L}\\right)$，一阶谐波为 $S_1(x) = \\sin\\left(\\frac{2\\pi x}{L}\\right)$，两者均满足真空边界条件。\n- 令形状近似为 $S(x,t) = \\tilde{S}(x,t)/\\int_0^L \\tilde{S}(x,t)\\,dx$，其中 $\\tilde{S}(x,t) = S_0(x) + b_1(t) S_1(x)$，强制满足 $\\int_0^L S(x,t)\\,dx = 1$。\n- 外部反应性由空间和时间变化的反应性密度 $r_{\\mathrm{ext}}(x,t)$（无量纲）表示，通过形状加权积分产生平均有效反应性：\n  - 对于 PCQS：$\\rho_{\\mathrm{avg}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S(x,t)\\,dx$。\n  - 对于 PK：$\\rho_{\\mathrm{avg,PK}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_0(x)\\,dx$。\n- PCQS 模型使用一种对反应性的形状修正，该修正惩罚由形状畸变引起的泄漏增加，近似为一阶谐波幅值的二次函数：\n  - $\\rho_{\\mathrm{shape}}(t) = -\\eta\\, b_1(t)^2$，其中 $\\eta0$ 是一个常数灵敏度参数。\n- 则 PCQS 幅值中使用的总有效反应性为 $\\rho_{\\mathrm{eff}}(t) = \\rho_{\\mathrm{avg}}(t) + \\rho_{\\mathrm{shape}}(t)$。\n- PCQS 幅值-先驱核系统为：\n  - $\\dfrac{dA}{dt} = \\left(\\dfrac{\\rho_{\\mathrm{eff}}(t) - \\beta}{\\Lambda}\\right) A(t) + \\lambda_d\\, C(t)$,\n  - $\\dfrac{dC}{dt} = \\left(\\dfrac{\\beta}{\\Lambda}\\right) A(t) - \\lambda_d\\, C(t)$,\n  其中 $\\beta$ 是总缓发中子份额，$\\Lambda$ 是瞬发中子代时间。\n- PK 幅值-先驱核系统是相同的，但使用 $\\rho_{\\mathrm{avg,PK}}(t)$ 代替 $\\rho_{\\mathrm{eff}}(t)$，并假定 $b_1(t)\\equiv 0$。\n- 在 PCQS 中，一阶谐波系数 $b_1(t)$ 服从一个受驱、阻尼动力学，该动力学捕捉了由非均匀反应性引起的激励和由模态衰变引起的弛豫：\n  - $\\dfrac{db_1}{dt} = -\\gamma\\, b_1(t) + \\chi\\, \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_1(x)\\,dx$,\n  其中 $\\gamma0$ 是一阶谐波的弛豫率，$\\chi0$ 是从非均匀反应性到一阶谐波的耦合增益。\n\n数值积分方法要求：\n- 对 $A(t)$, $C(t)$ 和 $b_1(t)$ 的 PCQS 系统使用预估-校正（梯形）时间步进法。\n- 对 $A_{\\mathrm{PK}}(t)$ 和 $C_{\\mathrm{PK}}(t)$ 的 PK 系统使用匹配的时间步进方案。\n- 使用均匀空间网格通过数值求积（例如，梯形法则）来计算空间积分。\n- 在 $t=0$ 时进行初始化，设 $A(0)=1$, $b_1(0)=0$ 和 $C(0) = \\dfrac{\\beta}{\\Lambda\\, \\lambda_d} A(0)$，以与净反应性为零的稳态保持一致。\n\n使用的物理参数：\n- $L = 100\\,\\mathrm{cm}$,\n- $\\beta = 0.0065$,\n- $\\Lambda = 1.0\\times 10^{-4}\\,\\mathrm{s}$,\n- $\\lambda_d = 0.08\\,\\mathrm{s}^{-1}$,\n- $\\gamma = 20.0\\,\\mathrm{s}^{-1}$,\n- $\\chi = 1.0$,\n- $\\eta = 0.2$.\n\n测试套件规范：\n- 空间网格：使用在 $[0,L]$ 上均匀分布的 $N_x = 200$ 个点。\n- 时间步长：使用 $\\Delta t = 0.001\\,\\mathrm{s}$。\n- 三个瞬态案例覆盖了不同的激励机制：\n  1. 案例1（常规路径，非均匀斜坡）：$r_{\\mathrm{ext}}(x,t) = r_{\\max} \\, \\mathrm{ramp}(t) \\, \\dfrac{\\exp(-x/\\ell)}{\\max_{x\\in[0,L]} \\exp(-x/\\ell)}$，其中 $r_{\\max} = 0.003$，$\\ell = L/5$，以及 $\\mathrm{ramp}(t) = \\min(t/T_r,1)$ 且 $T_r = 1.0\\,\\mathrm{s}$。模拟至最终时间 $T=3.0\\,\\mathrm{s}$。\n  2. 案例2（边界条件检查，均匀阶跃）：$r_{\\mathrm{ext}}(x,t) = r_0$，其中 $r_0 = 0.003$ 在空间和时间上为常数，适用于 $0\\le t\\le 3.0\\,\\mathrm{s}$，且 $T=3.0\\,\\mathrm{s}$。\n  3. 案例3（边缘情况，近边界短脉冲）：$r_{\\mathrm{ext}}(x,t) = r_p\\, \\mathbf{1}_{[0,T_p]}(t)\\, \\dfrac{\\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}{\\max_{x\\in[0,L]} \\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}$，其中 $r_p = 0.01$，$T_p = 0.2\\,\\mathrm{s}$，$\\sigma = L/20$，以及 $T=1.0\\,\\mathrm{s}$。\n\n对于每个案例，计算：\n- 在模拟时间窗口内幅值轨迹的最大绝对差，$\\max_{t\\in[0,T]} |A(t) - A_{\\mathrm{PK}}(t)|$，以无量纲浮点数形式报告。\n- 绝对形状修正反应性的时间积分，$\\int_0^T |\\rho_{\\mathrm{shape}}(t)|\\,dt$，以 $\\mathrm{s}$ 为单位报告，其中反应性为无量纲。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含结果，格式为以逗号分隔的列表的列表，每个子列表对应一个案例，并按 $[\\text{max\\_abs\\_diff}, \\text{shape\\_corr\\_integral}]$ 的顺序列出。例如，输出格式必须与 $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$ 完全一样，其中所有的 $a_i$ 和 $b_i$ 都是浮点数。",
            "solution": "用户要求实现并比较两种反应堆动力学模型：一种预估-校正准静态 (PCQS) 模型和一种纯点堆动力学 (PK) 模型。该问题需要在三种不同的瞬态情景下求解。\n\n### 步骤 1：提取已知条件\n\n**反应堆模型：**\n- 一维、均匀的平板反应堆，长度为 $L$。\n- 在 $x=0$ 和 $x=L$ 处为真空边界条件。\n- 单能中子平衡与单组缓发中子。\n- 通量因子分解：$\\phi(x,t) = A(t) S(x,t)$。\n- 形状归一化：对于所有 $t$，$\\int_0^L S(x,t)\\,dx = 1$。\n\n**数学公式：**\n- **形状展开：**\n    - 基波模式：$S_0(x) = \\sin\\left(\\frac{\\pi x}{L}\\right)$。\n    - 一阶谐波：$S_1(x) = \\sin\\left(\\frac{2\\pi x}{L}\\right)$。\n    - 形状近似：$S(x,t) = \\tilde{S}(x,t)/\\int_0^L \\tilde{S}(x,t)\\,dx$，其中 $\\tilde{S}(x,t) = S_0(x) + b_1(t) S_1(x)$。\n- **反应性：**\n    - 外部反应性密度：$r_{\\mathrm{ext}}(x,t)$。\n    - PCQS 平均反应性：$\\rho_{\\mathrm{avg}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S(x,t)\\,dx$。\n    - PK 平均反应性：$\\rho_{\\mathrm{avg,PK}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_0(x)\\,dx$。\n    - PCQS 形状反应性修正：$\\rho_{\\mathrm{shape}}(t) = -\\eta\\, b_1(t)^2$。\n    - PCQS 总有效反应性：$\\rho_{\\mathrm{eff}}(t) = \\rho_{\\mathrm{avg}}(t) + \\rho_{\\mathrm{shape}}(t)$。\n- **PCQS 动力学：**\n    - $\\dfrac{dA}{dt} = \\left(\\dfrac{\\rho_{\\mathrm{eff}}(t) - \\beta}{\\Lambda}\\right) A(t) + \\lambda_d\\, C(t)$\n    - $\\dfrac{dC}{dt} = \\left(\\dfrac{\\beta}{\\Lambda}\\right) A(t) - \\lambda_d\\, C(t)$\n    - $\\dfrac{db_1}{dt} = -\\gamma\\, b_1(t) + \\chi\\, \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_1(x)\\,dx$\n- **PK 动力学：**\n    - 使用与 PCQS 相同的幅值-先驱核方程，但用 $\\rho_{\\mathrm{avg,PK}}(t)$ 代替 $\\rho_{\\mathrm{eff}}(t)$。\n    - 假定 $b_1(t) \\equiv 0$。\n- **初始条件 ($t=0$):**\n    - $A(0) = 1$\n    - $b_1(0) = 0$\n    - $C(0) = \\dfrac{\\beta}{\\Lambda\\, \\lambda_d} A(0)$\n\n**物理与数值参数：**\n- $L = 100\\,\\mathrm{cm}$\n- $\\beta = 0.0065$\n- $\\Lambda = 1.0\\times 10^{-4}\\,\\mathrm{s}$\n- $\\lambda_d = 0.08\\,\\mathrm{s}^{-1}$\n- $\\gamma = 20.0\\,\\mathrm{s}^{-1}$\n- $\\chi = 1.0$\n- $\\eta = 0.2$\n- 空间网格点数：$N_x = 200$\n- 时间步长：$\\Delta t = 0.001\\,\\mathrm{s}$\n\n**$r_{\\mathrm{ext}}(x,t)$ 的测试案例：**\n1.  **案例1（非均匀斜坡）：** $r_{\\mathrm{ext}}(x,t) = r_{\\max} \\, \\mathrm{ramp}(t) \\, \\dfrac{\\exp(-x/\\ell)}{\\max_{x\\in[0,L]} \\exp(-x/\\ell)}$\n    - $r_{\\max} = 0.003$\n    - $\\ell = L/5 = 20\\,\\mathrm{cm}$\n    - $\\mathrm{ramp}(t) = \\min(t/T_r,1)$，其中 $T_r = 1.0\\,\\mathrm{s}$\n    - 最终时间：$T = 3.0\\,\\mathrm{s}$\n2.  **案例2（均匀阶跃）：** $r_{\\mathrm{ext}}(x,t) = r_0 = 0.003$\n    - 最终时间：$T = 3.0\\,\\mathrm{s}$\n3.  **案例3（边界脉冲）：** $r_{\\mathrm{ext}}(x,t) = r_p\\, \\mathbf{1}_{[0,T_p]}(t)\\, \\dfrac{\\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}{\\max_{x\\in[0,L]} \\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}$\n    - $r_p = 0.01$\n    - $T_p = 0.2\\,\\mathrm{s}$\n    - $\\sigma = L/20 = 5\\,\\mathrm{cm}$\n    - 最终时间：$T = 1.0\\,\\mathrm{s}$\n\n**要求的输出：**\n对于每个案例，计算并报告：\n1.  $\\max_{t\\in[0,T]} |A(t) - A_{\\mathrm{PK}}(t)|$\n2.  $\\int_0^T |\\rho_{\\mathrm{shape}}(t)|\\,dt$\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学基础：** 该问题使用了反应堆动力学的一个标准且成熟的简化模型，即基于中子通量因子分解的准静态方法。点堆动力学方程是反应堆物理学的基础。所有方程都代表了物理上合理的现象（反应性反馈、模态激励、先驱核衰变）。该问题在科学上是合理的。\n- **适定性：** 所有必需的物理参数、初始条件、边界条件和强迫函数都已明确给出。常微分方程组 (ODE) 定义良好。数值方法（预估-校正）已指定。对于给定的参数和时间尺度，预期会有一个唯一、稳定的解。在 $\\rho_{\\mathrm{avg,PK}}(t)$ 的定义中存在一个模糊之处：它指定了使用 $S_0(x)$进行加权，而 $S_0(x)$ 未被归一化，然而通量加权的一般原则意味着应使用归一化的加权函数。一个一致的解释，即假设 PK 模型使用归一化的基波形状，解决了这个问题并且在科学上是合理的。这种解释是，PK 的固定形状是归一化的基波模式，与归一化约束 $\\int_0^L S(x,t)\\, dx = 1$ 一致。\n- **客观性：** 该问题使用精确的数学和物理术语陈述，没有主观性语言。任务是定量的且可验证的。\n\n该问题没有所列的无效性缺陷。关于归一化的微小模糊之处可以通过与问题整体框架一致的标准逻辑解释来解决。\n\n### 步骤 3：结论与行动\n\n问题被判定为有效。将提供一个解决方案。\n\n### 基于原理的求解设计\n\n该求解方案需要对两个耦合常微分方程组进行时域上的数值积分：一个用于 PCQS 模型，另一个用于 PK 模型。将采用指定的预估-校正（梯形）方法进行时间积分，并采用梯形法则进行空间求积。\n\n**1. 系统公式化**\n两个模型的状态向量为：\n- PCQS: $\\mathbf{y}(t) = [A(t), C(t), b_1(t)]^T$\n- PK: $\\mathbf{y}_{\\mathrm{PK}}(t) = [A_{\\mathrm{PK}}(t), C_{\\mathrm{PK}}(t)]^T$\n\n常微分方程组可以写成标准形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}, t)$。\n\n**2. 空间离散化与归一化**\n使用均匀空间网格 $x_i = i \\cdot \\Delta x$（其中 $i=0, 1, \\dots, N_x-1$ 且 $\\Delta x = L/(N_x-1)$）。形式为 $\\int_0^L g(x) dx$ 的空间积分使用数值梯形法则计算。\n\n基函数为 $S_0(x) = \\sin(\\pi x/L)$ 和 $S_1(x) = \\sin(2\\pi x/L)$。一个关键的解析简化来自于它们在区间 $[0,L]$ 上的正交性。\n- 形状的归一化积分为 $I_S = \\int_0^L \\tilde{S}(x,t) dx = \\int_0^L (S_0(x) + b_1(t)S_1(x)) dx$。\n- 由于 $\\int_0^L S_1(x) dx = \\int_0^L \\sin(2\\pi x/L) dx = 0$，该积分简化为 $I_S = \\int_0^L S_0(x) dx = \\int_0^L \\sin(\\pi x/L) dx = [-\\frac{L}{\\pi}\\cos(\\frac{\\pi x}{L})]^L_0 = \\frac{2L}{\\pi}$。\n- PCQS 模型的归一化形状为 $S(x,t) = \\frac{\\tilde{S}(x,t)}{I_S} = \\frac{\\pi}{2L}(S_0(x) + b_1(t)S_1(x))$。\n- PK 模型的固定、归一化形状为 $S_{0,\\mathrm{norm}}(x) = \\frac{S_0(x)}{I_S} = \\frac{\\pi}{2L}S_0(x)$。这通过确保一致的归一化解决了问题陈述中关于 $\\rho_{\\mathrm{avg,PK}}$ 的模糊之处。\n\n**3. 时间积分：预估-校正方法**\n对于一个通用常微分方程 $\\frac{dy}{dt} = f(y, t)$，从时间 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的更新是一个两步过程：\n- **预估步骤（前向欧拉法）：** 计算一个显式估计值 $y^*_{n+1}$。\n  $y^*_{n+1} = y_n + \\Delta t \\cdot f(y_n, t_n)$\n- **校正步骤（梯形法则）：** 使用区间起点和终点的斜率平均值计算最终值 $y_{n+1}$，其中终点斜率使用预估值进行评估。\n  $y_{n+1} = y_n + \\frac{\\Delta t}{2} [f(y_n, t_n) + f(y^*_{n+1}, t_{n+1})]$\n\n该方案将应用于状态向量 $\\mathbf{y}$ 和 $\\mathbf{y}_{\\mathrm{PK}}$。\n\n**4. 单个时间步的算法**\n令时间 $t_n$ 时的状态对于 PCQS 为 $(A_n, C_n, b_{1,n})$，对于 PK 为 $(A_{\\mathrm{PK},n}, C_{\\mathrm{PK},n})$。\n\n- **A 部分：计算 $t_n$ 时的导数**\n  1. 在空间网格上计算外部反应性 $r_{\\mathrm{ext}}(x, t_n)$。\n  2. 对于 PCQS：\n     - 使用 $b_{1,n}$ 计算当前归一化形状 $S_n(x)$。\n     - 计算反应性 $\\rho_{\\mathrm{avg},n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n)S_n(x)dx$ 和 $\\rho_{\\mathrm{shape},n} = -\\eta b_{1,n}^2$。\n     - 计算总反应性 $\\rho_{\\mathrm{eff},n} = \\rho_{\\mathrm{avg},n} + \\rho_{\\mathrm{shape},n}$。\n     - 计算一阶谐波强迫项 $G_{1,n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n)S_1(x)dx$。\n     - 计算导数 $\\frac{dA}{dt}|_n$, $\\frac{dC}{dt}|_n$, $\\frac{db_1}{dt}|_n$。\n  3. 对于 PK：\n     - 计算反应性 $\\rho_{\\mathrm{avg,PK},n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n) S_{0,\\mathrm{norm}}(x)dx$。\n     - 计算导数 $\\frac{dA_{\\mathrm{PK}}}{dt}|_n$, $\\frac{dC_{\\mathrm{PK}}}{dt}|_n$。\n\n- **B 部分：预估步骤**\n  1. 使用 A 部分的导数和前向欧拉步长，计算 $t_{n+1}$ 时的预估状态 $(A^*_{n+1}, C^*_{n+1}, b^*_{1,n+1})$ 和 $(A^*_{\\mathrm{PK},n+1}, C^*_{\\mathrm{PK},n+1})$。\n\n- **C 部分：使用预估状态计算 $t_{n+1}$ 时的导数**\n  1. 在空间网格上计算外部反应性 $r_{\\mathrm{ext}}(x, t_{n+1})$。\n  2. 对于 PCQS：\n     - 使用 $b^*_{1,n+1}$ 定义预估形状 $S^*_{n+1}(x)$。\n     - 使用 $r_{\\mathrm{ext}}(x, t_{n+1})$ 和预估状态计算预估反应性 $\\rho^*_{\\mathrm{avg},n+1}$、$\\rho^*_{\\mathrm{shape},n+1}$、$\\rho^*_{\\mathrm{eff},n+1}$ 和强迫项 $G^*_{1,n+1}$。\n     - 使用预估状态和反应性计算预估导数 $(\\frac{d\\mathbf{y}}{dt})^*_{n+1}$。\n  3. 对于 PK：\n     - 使用 $r_{\\mathrm{ext}}(x,t_{n+1})$ 计算预估反应性 $\\rho^*_{\\mathrm{avg,PK},n+1}$。\n     - 使用预估状态和反应性计算预估导数 $(\\frac{d\\mathbf{y}_{\\mathrm{PK}}}{dt})^*_{n+1}$。\n\n- **D 部分：校正步骤**\n  1. 对于两个模型，使用梯形法则，通过平均 A 部分和 C 部分的导数来计算 $t_{n+1}$ 时的最终状态。\n\n对从 $t=0$ 到最终时间 $T$ 的所有时间步重复此过程。在模拟期间，每一步的 $A(t)$、$A_{\\mathrm{PK}}(t)$ 和 $\\rho_{\\mathrm{shape}}(t)$ 的值都会被存储，以便在模拟完成后计算所需的输出指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reactor dynamics problem for three cases using PCQS and PK models.\n    \"\"\"\n    \n    # Physical and numerical parameters\n    L = 100.0  # cm\n    beta = 0.0065\n    Lambda = 1.0e-4  # s\n    lambda_d = 0.08  # s^-1\n    gamma = 20.0  # s^-1\n    chi = 1.0\n    eta = 0.2\n    \n    Nx = 200\n    dt = 0.001  # s\n\n    # Spatial grid and basis functions\n    x_grid = np.linspace(0, L, Nx)\n    S0 = np.sin(np.pi * x_grid / L)\n    S1 = np.sin(2 * np.pi * x_grid / L)\n    \n    # Normalization integral (analytically 2*L/pi)\n    norm_S0 = np.trapz(S0, x_grid) \n    S0_norm = S0 / norm_S0\n    \n    # Test cases defined as dictionaries\n    test_cases = [\n        {\n            \"T_final\": 3.0,\n            \"r_ext_func\": lambda x, t: 0.003 * min(t / 1.0, 1.0) * (np.exp(-x / 20.0) / np.exp(0)),\n        },\n        {\n            \"T_final\": 3.0,\n            \"r_ext_func\": lambda x, t: 0.003 * np.ones_like(x),\n        },\n        {\n            \"T_final\": 1.0,\n            \"r_ext_func\": lambda x, t: 0.01 * (1.0 if t = 0.2 else 0.0) * (np.exp(-x**2 / (2 * 5.0**2)) / np.exp(0)),\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        T_final = case[\"T_final\"]\n        r_ext_func = case[\"r_ext_func\"]\n        \n        # Time steps\n        t_steps = np.arange(0, T_final + dt, dt)\n        num_steps = len(t_steps)\n\n        # Initial conditions\n        A0 = 1.0\n        C0 = (beta / (Lambda * lambda_d)) * A0\n        b1_0 = 0.0\n\n        # PCQS history arrays\n        A_hist = np.zeros(num_steps)\n        C_hist = np.zeros(num_steps)\n        b1_hist = np.zeros(num_steps)\n        rho_shape_hist = np.zeros(num_steps)\n        \n        # PK history arrays\n        A_pk_hist = np.zeros(num_steps)\n        C_pk_hist = np.zeros(num_steps)\n        \n        # Set initial values\n        A_hist[0], C_hist[0], b1_hist[0] = A0, C0, b1_0\n        A_pk_hist[0], C_pk_hist[0] = A0, C0\n        rho_shape_hist[0] = -eta * b1_0**2\n\n        # Main time loop\n        for i in range(num_steps - 1):\n            t_n = t_steps[i]\n            t_n1 = t_steps[i+1]\n            \n            # --- Current step (n) derivatives ---\n            A_n, C_n, b1_n = A_hist[i], C_hist[i], b1_hist[i]\n            A_pk_n, C_pk_n = A_pk_hist[i], C_pk_hist[i]\n\n            r_ext_n = r_ext_func(x_grid, t_n)\n\n            # PCQS derivatives at n\n            S_n = (S0 + b1_n * S1) / norm_S0\n            rho_avg_n = np.trapz(r_ext_n * S_n, x_grid)\n            rho_shape_n = -eta * b1_n**2\n            rho_eff_n = rho_avg_n + rho_shape_n\n            G1_n = np.trapz(r_ext_n * S1, x_grid)\n\n            f_A_n = ((rho_eff_n - beta) / Lambda) * A_n + lambda_d * C_n\n            f_C_n = (beta / Lambda) * A_n - lambda_d * C_n\n            f_b1_n = -gamma * b1_n + chi * G1_n\n\n            # PK derivatives at n\n            rho_avg_pk_n = np.trapz(r_ext_n * S0_norm, x_grid)\n            f_A_pk_n = ((rho_avg_pk_n - beta) / Lambda) * A_pk_n + lambda_d * C_pk_n\n            f_C_pk_n = (beta / Lambda) * A_pk_n - lambda_d * C_pk_n\n\n            # --- Predictor step ---\n            A_star = A_n + dt * f_A_n\n            C_star = C_n + dt * f_C_n\n            b1_star = b1_n + dt * f_b1_n\n            \n            A_pk_star = A_pk_n + dt * f_A_pk_n\n            C_pk_star = C_pk_n + dt * f_C_pk_n\n\n            # --- Predicted step (n+1) derivatives ---\n            r_ext_n1 = r_ext_func(x_grid, t_n1)\n\n            # PCQS derivatives at n+1\n            S_star = (S0 + b1_star * S1) / norm_S0\n            rho_avg_star = np.trapz(r_ext_n1 * S_star, x_grid)\n            rho_shape_star = -eta * b1_star**2\n            rho_eff_star = rho_avg_star + rho_shape_star\n            G1_star = np.trapz(r_ext_n1 * S1, x_grid)\n\n            f_A_star = ((rho_eff_star - beta) / Lambda) * A_star + lambda_d * C_star\n            f_C_star = (beta / Lambda) * A_star - lambda_d * C_star\n            f_b1_star = -gamma * b1_star + chi * G1_star\n            \n            # PK derivatives at n+1\n            rho_avg_pk_star = np.trapz(r_ext_n1 * S0_norm, x_grid)\n            f_A_pk_star = ((rho_avg_pk_star - beta) / Lambda) * A_pk_star + lambda_d * C_pk_star\n            f_C_pk_star = (beta / Lambda) * A_pk_star - lambda_d * C_pk_star\n            \n            # --- Corrector step ---\n            A_hist[i+1] = A_n + 0.5 * dt * (f_A_n + f_A_star)\n            C_hist[i+1] = C_n + 0.5 * dt * (f_C_n + f_C_star)\n            b1_hist[i+1] = b1_n + 0.5 * dt * (f_b1_n + f_b1_star)\n            \n            A_pk_hist[i+1] = A_pk_n + 0.5 * dt * (f_A_pk_n + f_A_pk_star)\n            C_pk_hist[i+1] = C_pk_n + 0.5 * dt * (f_C_pk_n + f_C_pk_star)\n\n            # Store shape reactivity for output calculation\n            rho_shape_hist[i+1] = -eta * b1_hist[i+1]**2\n        \n        # Calculate final metrics for the case\n        max_abs_diff = np.max(np.abs(A_hist - A_pk_hist))\n        shape_corr_integral = np.trapz(np.abs(rho_shape_hist), t_steps)\n        \n        all_results.append([max_abs_diff, shape_corr_integral])\n\n    # Format output\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}