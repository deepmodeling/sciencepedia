{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的数值求解器之前，理解反应堆对反应性引入的瞬时物理响应至关重要。本练习提供了一个用于计算功率变化初始速率的精确解析解，揭示了瞬发中子在反应初始阶段的主导作用。这个结果不仅能加深对物理过程的理解，也为任何数值模拟提供了一个关键的基准测试点。",
            "id": "4239358",
            "problem": "一个均匀热中子反应堆由具有$G=6$个缓发中子群的点动力学方程建模。总缓发中子份额为$\\beta = 0.0065$，瞬发中子代时间为$\\Lambda = 1.0 \\times 10^{-5}\\ \\mathrm{s}$，六个缓发中子群的数据由份额产额 $\\{\\beta_i\\}_{i=1}^{6}$ 和衰变常数 $\\{\\lambda_i\\}_{i=1}^{6}$ 给出：\n- $\\beta_1 = 2.15 \\times 10^{-4}$, $\\lambda_1 = 1.24 \\times 10^{-2}\\ \\mathrm{s}^{-1}$\n- $\\beta_2 = 1.424 \\times 10^{-3}$, $\\lambda_2 = 3.05 \\times 10^{-2}\\ \\mathrm{s}^{-1}$\n- $\\beta_3 = 1.274 \\times 10^{-3}$, $\\lambda_3 = 1.11 \\times 10^{-1}\\ \\mathrm{s}^{-1}$\n- $\\beta_4 = 2.568 \\times 10^{-3}$, $\\lambda_4 = 3.01 \\times 10^{-1}\\ \\mathrm{s}^{-1}$\n- $\\beta_5 = 7.48 \\times 10^{-4}$, $\\lambda_5 = 1.14\\ \\mathrm{s}^{-1}$\n- $\\beta_6 = 2.73 \\times 10^{-4}$, $\\lambda_6 = 3.01\\ \\mathrm{s}^{-1}$\n\n假设没有外部中子源。在$t0$时，反应堆初始处于稳定临界状态，反应性为$\\rho^{-}=0$，归一化中子密度为$n(0^{-}) = 1$，且每个先驱核群的浓度$C_i(0^{-})$等于与$\\rho^{-}=0$一致的稳态值。在$t=0$时，瞬间引入一个值为$\\rho = 2000\\ \\mathrm{pcm}$的正阶跃反应性，其中$\\mathrm{pcm}$表示千分之一个百分点，即$1\\ \\mathrm{pcm} = 10^{-5}$。\n\n从包含缓发中子先驱核的中子平衡方程和阶跃前稳定临界条件的定义出发，推导中子密度初始时间导数$\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$的精确表达式，并用给定数据进行数值计算。将最终数值以$\\mathrm{s}^{-1}$为单位表示，并四舍五入到四位有效数字。\n\n此外，简要用文字解释在点动力学框架内$\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$符号的物理意义（此解释部分不计入数值准确性评分）。",
            "solution": "首先根据指定标准对问题进行验证。\n- **科学基础性**：该问题基于标准的点动力学方程，这是核反应堆动力学的一个基石。所有提供的参数，如瞬发中子代时间（$\\Lambda$）、总缓发中子份额（$\\beta$）以及各群份额（$\\beta_i$）和衰变常数（$\\lambda_i$），对于一个热中子反应堆来说都是物理上现实的。所提供的$\\beta_i$值之和为$2.15 \\times 10^{-4} + 1.424 \\times 10^{-3} + 1.274 \\times 10^{-3} + 2.568 \\times 10^{-3} + 7.48 \\times 10^{-4} + 2.73 \\times 10^{-4} = 6.502 \\times 10^{-3}$，这与给定的总$\\beta = 0.0065$相符。阶跃反应性引入的情景是反应堆瞬态分析中的一个标准问题。该问题是科学合理的。\n- **适定性**：该问题是适定的。它提供了一套完整的初始条件、系统参数，以及在$t=0$时明确定义的改变。目标是求出中子密度的初始变化率，对此存在唯一解。\n- **客观性**：该问题以精确、客观和定量的术语陈述，没有任何主观或模棱两可的语言。\n\n结论是该问题有效。我们开始求解。\n\n对于$i=1, \\dots, G$个群，没有外部源的中子密度$n(t)$和先驱核浓度$C_i(t)$的点动力学方程为：\n$$ \\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{G} \\lambda_i C_i(t) \\quad \\quad (1) $$\n$$ \\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t) \\quad \\quad (2) $$\n其中$\\rho(t)$是反应性，$\\Lambda$是瞬发中子代时间，$\\beta = \\sum_{i=1}^{G} \\beta_i$是总缓发中子份额，$\\beta_i$是各群份额，$\\lambda_i$是各群衰变常数。\n\n首先，我们确定$t  0$时的初始条件。反应堆处于稳定临界状态。\n- 稳态意味着所有时间导数均为零：$\\frac{dn}{dt} = 0$ 且 $\\frac{dC_i}{dt} = 0$。\n- 临界条件意味着反应性为零：$\\rho(t0) = \\rho^{-} = 0$。\n- 中子密度被归一化为1：$n(0^{-}) = 1$。\n\n根据稳态下的方程（2）：\n$$ 0 = \\frac{\\beta_i}{\\Lambda} n(0^{-}) - \\lambda_i C_i(0^{-}) $$\n求解初始先驱核浓度 $C_i(0^{-})$：\n$$ C_i(0^{-}) = \\frac{\\beta_i}{\\lambda_i \\Lambda} n(0^{-}) $$\n由于 $n(0^{-}) = 1$，我们有：\n$$ C_i(0^{-}) = \\frac{\\beta_i}{\\lambda_i \\Lambda} $$\n这些初始条件满足稳态下的方程（1），因为 $\\frac{\\rho^{-} - \\beta}{\\Lambda}n(0^{-}) + \\sum_{i=1}^{G} \\lambda_i C_i(0^{-}) = \\frac{0 - \\beta}{\\Lambda}(1) + \\sum_{i=1}^{G} \\lambda_i \\left(\\frac{\\beta_i}{\\lambda_i \\Lambda}\\right) = -\\frac{\\beta}{\\Lambda} + \\frac{1}{\\Lambda}\\sum_{i=1}^{G} \\beta_i = -\\frac{\\beta}{\\Lambda} + \\frac{\\beta}{\\Lambda} = 0$。\n\n在$t=0$时，发生一次瞬时阶跃反应性引入。对于$t \\ge 0$，反应性为 $\\rho(t \\ge 0) = \\rho^{+} = 2000\\ \\mathrm{pcm} = 2000 \\times 10^{-5} = 0.02$。\n\n诸如中子密度和先驱核浓度等物理状态变量不能不连续地改变。因此，它们在阶跃变化之后瞬间（$t=0^{+}$）的值必须与阶跃变化之前瞬间（$t=0^{-}$）的值相同。\n$$ n(0^{+}) = n(0^{-}) = 1 $$\n$$ C_i(0^{+}) = C_i(0^{-}) = \\frac{\\beta_i}{\\lambda_i \\Lambda} $$\n\n我们要求解在$t=0^{+}$时的中子密度时间导数，即$\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$。我们使用$t=0^{+}$时的条件来计算方程（1）：\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho(0^{+}) - \\beta}{\\Lambda} n(0^{+}) + \\sum_{i=1}^{G} \\lambda_i C_i(0^{+}) $$\n代入$\\rho(0^{+})$, $n(0^{+})$ 和 $C_i(0^{+})$ 的值：\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+} - \\beta}{\\Lambda} (1) + \\sum_{i=1}^{G} \\lambda_i \\left( \\frac{\\beta_i}{\\lambda_i \\Lambda} \\right) $$\n求和项中的$\\lambda_i$项相互抵消：\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+} - \\beta}{\\Lambda} + \\frac{1}{\\Lambda} \\sum_{i=1}^{G} \\beta_i $$\n根据定义，$\\beta = \\sum_{i=1}^{G} \\beta_i$。将此代入方程：\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+} - \\beta}{\\Lambda} + \\frac{\\beta}{\\Lambda} = \\frac{\\rho^{+} - \\beta + \\beta}{\\Lambda} $$\n这可以简化为中子密度初始时间导数的精确表达式：\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+}}{\\Lambda} $$\n\n现在，我们使用给定数据对该表达式进行数值计算：\n- 反应性引入：$\\rho^{+} = 0.02$。\n- 瞬发中子代时间：$\\Lambda = 1.0 \\times 10^{-5}\\ \\mathrm{s}$。\n\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{0.02}{1.0 \\times 10^{-5}\\ \\mathrm{s}} = 2000\\ \\mathrm{s}^{-1} $$\n四舍五入到四位有效数字，值为 $2.000 \\times 10^3\\ \\mathrm{s}^{-1}$。\n\n$\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$ 符号的物理意义：\n导数的符号为正。这表明在反应性引入后，中子密度以及因此的反应堆功率立即开始增加。正反应性引入（$\\rho^{+} > 0$）使反应堆处于超临界状态，意味着由裂变产生中子的速率超过了因吸收和泄漏而损失中子的速率。这种不平衡导致中子数量的增长。导数的大小由引入的反应性与瞬发中子代时间的比值决定，它表示一个非常迅速的初始功率增长，这是瞬发超临界瞬态的特征，因为$\\rho^{+} = 0.02$大于$\\beta = 0.0065$。本质上，正号证实了链式反应是发散的。",
            "answer": "$$ \\boxed{2.000 \\times 10^{3}} $$"
        },
        {
            "introduction": "点动力学方程因瞬发中子和缓发中子先驱核之间巨大的时间尺度差异而具有“刚性”特征，这使得简单的显式数值方法在不使用极小时间步长的情况下会变得不稳定。本练习将指导您实现一种半隐式格式，通过对快速瞬发项进行隐式处理来确保稳定性，这是开发实用反应堆动力学程序的核心技能。",
            "id": "4239418",
            "problem": "考虑一个具有 $M$ 组缓发中子先驱核的均匀核反应堆模型的点动力学方程 (PKE)。中子密度 $n(t)$ 和先驱核浓度 $C_i(t)$（其中 $i \\in \\{1,\\dots,M\\}$）根据以下方程组演化：\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i C_i(t),\n$$\n$$\n\\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t),\n$$\n其中所有量均为时间 $t$ 的函数，单位明确规定如下：$t$ 的单位为秒，$\\Lambda$ 的单位为秒，每个 $\\lambda_i$ 的单位为倒数秒，$n(t)$ 和 $C_i(t)$ 为无量纲。总缓发中子份额为 $\\beta = \\sum_{i=1}^{M} \\beta_i$。反应性 $\\rho(t)$ 是无量纲的，并且是一个给定的时间函数。\n\n从这些控制方程出发，从第一性原理推导一个时间步长为 $\\Delta t$ 的单步时间积分格式，该格式对瞬发中子产生项 $\\left( \\left(\\rho(t) - \\beta\\right)/\\Lambda \\right) n(t)$ 进行隐式处理，并对所有缓发中子项 $\\lambda_i C_i(t)$ 和 $\\left( \\beta_i/\\Lambda \\right) n(t)$ 进行显式处理。您的推导必须从上述微分方程开始，并且对于隐式项仅使用后向欧拉法的定义，对于显式项仅使用前向欧拉法的定义，不得使用任何未直接从这些定义推导出来的快捷公式。您必须通过量化瞬发中子代时间与缓发中子先驱核衰变时间之间的时间尺度分离，来证明选择半隐式格式的合理性。\n\n在一个程序中实现所推导的半隐式格式，并将其应用于以下测试套件。在每种情况下，使用 $M = 6$ 组缓发中子，其科学上典型的参数如下：\n- 缓发中子衰变常数 (单位 $\\text{s}^{-1}$): $\\lambda_1 = 0.0124$, $\\lambda_2 = 0.0305$, $\\lambda_3 = 0.111$, $\\lambda_4 = 0.301$, $\\lambda_5 = 1.14$, $\\lambda_6 = 3.01$。\n- 缓发中子份额 (无量纲): $\\beta_1 = 0.000246$, $\\beta_2 = 0.001238$, $\\beta_3 = 0.001274$, $\\beta_4 = 0.002568$, $\\beta_5 = 0.000748$, $\\beta_6 = 0.000273$。\n设初始条件表示反应堆在任何反应性变化之前处于稳定临界状态：$n(0) = 1.0$ 且 $C_i(0) = \\left(\\beta_i/(\\lambda_i \\Lambda)\\right) n(0)$。在所有情况下，将外部源设置为零。\n\n定义以下四组参数集以测试不同的工况和边缘情况。对于每种情况，计算最终时间 $T$ 时的最终归一化中子密度 $n(T)$。\n\n- 情况 A (缓发超临界阶跃，典型热中子反应堆):\n  - 中子代时间: $\\Lambda = 0.0001$ $\\text{s}$。\n  - 反应性: 对于所有 $t \\ge 0$，$\\rho(t) = 0.002$。\n  - 总模拟时间: $T = 5.0$ $\\text{s}$。\n  - 时间步长: $\\Delta t = 0.001$ $\\text{s}$。\n\n- 情况 B (瞬发超临界阶跃，快速瞬态，细时间步长):\n  - 中子代时间: $\\Lambda = 0.00001$ $\\text{s}$。\n  - 反应性: 对于所有 $t \\ge 0$，$\\rho(t) = 0.007$。\n  - 总模拟时间: $T = 0.02$ $\\text{s}$。\n  - 时间步长: $\\Delta t = 0.000002$ $\\text{s}$。\n\n- 情况 C (瞬发超临界阶跃，接近瞬发周期的粗时间步长):\n  - 中子代时间: $\\Lambda = 0.00001$ $\\text{s}$。\n  - 反应性: 对于所有 $t \\ge 0$，$\\rho(t) = 0.007$。\n  - 总模拟时间: $T = 0.02$ $\\text{s}$。\n  - 时间步长: $\\Delta t = 0.01$ $\\text{s}$。\n\n- 情况 D (线性斜坡缓发超临界反应性):\n  - 中子代时间: $\\Lambda = 0.0001$ $\\text{s}$。\n  - 反应性: $\\rho(t)$ 从 $t = 0$ 时的 $0$ 线性增加到 $t = 2.0$ $\\text{s}$ 时的 $0.005$，即对于 $0 \\le t \\le 2.0$ $\\text{s}$，$\\rho(t) = (0.005/2.0)\\, t$。\n  - 总模拟时间: $T = 2.0$ $\\text{s}$。\n  - 时间步长: $\\Delta t = 0.0005$ $\\text{s}$。\n\n您的程序必须计算每种情况下的 $n(T)$，并生成单行输出，其中包含四个结果，形式为方括号括起来的逗号分隔列表。报告的每个数字都是无量纲的，并且必须是浮点值。例如，输出格式应类似于 $[x_1,x_2,x_3,x_4]$，其中每个 $x_j$ 对应于指定情况下计算出的 $n(T)$，并表示为无单位的浮点数。最终输出必须表示为浮点数，而不是百分比或带注释的字符串。",
            "solution": "首先根据所需标准验证问题陈述。\n\n### 步骤 1：提取已知条件\n\n问题陈述中逐字给出的已知条件如下：\n\n**控制方程：**\n具有 $M$ 组缓发中子先驱核的点动力学方程 (PKE)，其中中子密度为 $n(t)$，先驱核浓度为 $C_i(t)$（$i \\in \\{1, \\dots, M\\}$）：\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i C_i(t)\n$$\n$$\n\\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t)\n$$\n-   总缓发中子份额： $\\beta = \\sum_{i=1}^{M} \\beta_i$。\n-   单位： $t$ 的单位为秒 ($\\text{s}$)，$\\Lambda$ 的单位为 $\\text{s}$，$\\lambda_i$ 的单位为 $\\text{s}^{-1}$。$n(t)$、 $C_i(t)$、 $\\rho(t)$、 $\\beta_i$、 $\\beta$ 均为无量纲。\n-   外部源项为零。\n\n**标准参数 ($M=6$)：**\n-   缓发中子衰变常数 ($\\text{s}^{-1}$): $\\lambda = [0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01]$。\n-   缓发中子份额: $\\beta_i = [0.000246, 0.001238, 0.001274, 0.002568, 0.000748, 0.000273]$。\n\n**初始条件：**\n-   $n(0) = 1.0$。\n-   $C_i(0) = \\left(\\beta_i/(\\lambda_i \\Lambda)\\right) n(0)$。这表示反应堆处于稳定临界状态 ($\\rho(0) = 0$)。\n\n**任务要求：**\n-   推导一个单步时间积分格式，其中瞬发中子项 $\\left( \\left(\\rho(t) - \\beta\\right)/\\Lambda \\right) n(t)$ 被隐式处理（后向欧拉法），所有缓发中子项（$\\lambda_i C_i(t)$ 和 $\\left( \\beta_i/\\Lambda \\right) n(t)$）被显式处理（前向欧拉法）。\n-   证明半隐式选择的合理性。\n-   实现该格式并计算四个测试案例的最终归一化中子密度 $n(T)$。\n\n**测试案例：**\n-   **情况 A**: $\\Lambda = 0.0001\n\\text{ s}$，$\\rho(t) = 0.002$，$T = 5.0\n\\text{ s}$，$\\Delta t = 0.001\n\\text{ s}$。\n-   **情况 B**: $\\Lambda = 0.00001\n\\text{ s}$，$\\rho(t) = 0.007$，$T = 0.02\n\\text{ s}$，$\\Delta t = 0.000002\n\\text{ s}$。\n-   **情况 C**: $\\Lambda = 0.00001\n\\text{ s}$，$\\rho(t) = 0.007$，$T = 0.02\n\\text{ s}$，$\\Delta t = 0.01\n\\text{ s}$。\n-   **情况 D**: $\\Lambda = 0.0001\n\\text{ s}$，对于 $0 \\le t \\le 2.0\n\\text{ s}$，$\\rho(t) = (0.005/2.0)\\, t$，$T = 2.0\n\\text{ s}$，$\\Delta t = 0.0005\n\\text{ s}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学基础**：该问题建立在点动力学方程之上，这是反应堆动力学分析的基石。所提供的缓发中子组参数是使用铀燃料的反应堆的标准经验导出值。初始条件描述了一个物理上有意义的临界稳态，测试案例代表了标准的瞬态情景（阶跃和斜坡反应性引入）。该问题在根本上是合理的。\n-   **适定性**：该问题提供了一组耦合的、非线性的、一阶常微分方程，具有明确定义的初始条件和指定的强迫函数 $\\rho(t)$。这在数学上构成了一个适定的初值问题。推导和应用特定数值方法的说明是明确的，并且对每种情况都能得出唯一的计算结果。该问题是自洽和完整的。\n-   **客观性**：该问题使用精确、客观的数学和科学语言陈述。它不含主观论断、推测或歧义。\n\n### 步骤 3：结论与行动\n\n该问题被确定为**有效**。它是计算核工程中一个标准且表述良好的问题。可以进行求解过程。\n\n### 推导与求解\n\n核心任务是推导和实现点动力学方程 (PKE) 的半隐式数值格式。\n\n**半隐式方法的合理性证明**\n\nPKE 方程组是众所周知得数值“刚性”系统。刚性源于控制系统动力学的、差异巨大的时间尺度的存在。在 PKE 中，两个主要的时间尺度是瞬发中子代时间 $\\Lambda$ 和与 $1/\\lambda_i$ 相关的缓发中子先驱核的衰变半衰期。\n对于典型的热中子反应堆（情况 A），$\\Lambda \\approx 10^{-4} \\, \\text{s}$。对于快中子反应堆（情况 B、C），$\\Lambda \\approx 10^{-5} \\, \\text{s}$。\n先驱核衰变常数 $\\lambda_i$ 的范围大约从 $0.0124 \\, \\text{s}^{-1}$ 到 $3.01 \\, \\text{s}^{-1}$。相应的特征衰变时间 $1/\\lambda_i$ 跨度从大约 $0.33 \\, \\text{s}$ 到 $80 \\, \\text{s}$。\n最慢的先驱核时间尺度与瞬发中子时间尺度的比值可能非常巨大 ($80 \\, \\text{s} / 10^{-5} \\, \\text{s} \\approx 8 \\times 10^6$)。当使用完全显式的积分方法（如前向欧拉法）时，数值格式的稳定性由系统中最快的时间尺度决定。显式方法的稳定性准则要求时间步长 $\\Delta t$ 在 $\\Lambda/|\\rho-\\beta|$ 的数量级，这会变得小得令人望而却步，尤其是在瞬发超临界瞬态（$\\rho > \\beta$）期间。\n半隐式方法解决了这个问题。通过对快速变化的瞬发项 $\\left(\\frac{\\rho - \\beta}{\\Lambda}\\right)n$ 进行隐式处理（使用无条件稳定的后向欧拉法），我们消除了与 $\\Lambda$ 相关的稳定性约束。慢速变化的缓发中子项可以被显式处理（使用前向欧拉法）而不会影响稳定性，因为它们的时间尺度要长得多。这种方法在提供出色稳定性的同时保持了计算效率，因为它避免了在每个时间步求解一个完全耦合的系统。\n\n**数值格式的推导**\n\n我们用均匀步长 $\\Delta t$ 对时间进行离散化，使得 $t_k = k \\Delta t$。我们将变量 $y(t)$ 在时间 $t_k$ 的数值近似表示为 $y^k$。时间导数通过一阶有限差分来近似：$\\frac{dy}{dt} \\approx \\frac{y^{k+1} - y^k}{\\Delta t}$。\n\n1.  **中子密度方程：**\n    控制方程为：\n    $$\n    \\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i C_i(t)\n    $$\n    我们应用指定的格式：瞬发项（右侧第一项）在新的时间步 $t_{k+1}$ 进行计算（隐式），而缓发源项在当前时间步 $t_k$ 进行计算（显式）。\n    $$\n    \\frac{n^{k+1} - n^k}{\\Delta t} = \\frac{\\rho(t_{k+1}) - \\beta}{\\Lambda} n^{k+1} + \\sum_{i=1}^{M} \\lambda_i C_i^k\n    $$\n    为了找到 $n^{k+1}$ 的更新规则，我们重新整理方程以求解 $n^{k+1}$：\n    $$\n    n^{k+1} - n^k = \\Delta t \\left( \\frac{\\rho^{k+1} - \\beta}{\\Lambda} \\right) n^{k+1} + \\Delta t \\sum_{i=1}^{M} \\lambda_i C_i^k\n    $$\n    其中 $\\rho^{k+1} = \\rho(t_{k+1})$。\n    $$\n    n^{k+1} \\left( 1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda} \\right) = n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i C_i^k\n    $$\n    这得到了中子密度的显式更新公式：\n    $$\n    n^{k+1} = \\frac{n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i C_i^k}{1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda}}\n    $$\n\n2.  **先驱核浓度方程：**\n    控制方程为：\n    $$\n    \\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t), \\quad i=1, \\dots, M\n    $$\n    问题陈述要求所有缓发中子项都进行显式处理。这意味着整个右侧在当前时间步 $t_k$ 进行计算（前向欧拉法）。\n    $$\n    \\frac{C_i^{k+1} - C_i^k}{\\Delta t} = \\frac{\\beta_i}{\\Lambda} n^k - \\lambda_i C_i^k\n    $$\n    求解 $C_i^{k+1}$ 得到先驱核浓度的更新规则：\n    $$\n    C_i^{k+1} = C_i^k + \\Delta t \\left( \\frac{\\beta_i}{\\Lambda} n^k - \\lambda_i C_i^k \\right)\n    $$\n    这可以重写为：\n    $$\n    C_i^{k+1} = (1 - \\Delta t \\lambda_i) C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^k\n    $$\n\n**算法摘要**\n\n时间演化是迭代计算的。给定系统在时间 $t_k$ 的状态 $(n^k, C_1^k, \\dots, C_M^k)$，在 $t_{k+1} = t_k + \\Delta t$ 的状态按如下方式求得：\n\n1.  确定下一个时间步的反应性，$\\rho^{k+1} = \\rho(t_{k+1})$。\n2.  使用时间 $t_k$ 的状态计算下一个中子密度 $n^{k+1}$：\n    $$ n^{k+1} = \\frac{n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i C_i^k}{1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda}} $$\n3.  使用时间 $t_k$ 的状态计算下一个先驱核浓度 $C_i^{k+1}$：\n    $$ C_i^{k+1} = (1 - \\Delta t \\lambda_i) C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^k $$\n4.  更新状态变量：令 $n^k \\leftarrow n^{k+1}$ 和 $C_i^k \\leftarrow C_i^{k+1}$。\n5.  重复所需的时间步数，即 $N = T / \\Delta t$。\n\n在 $t=0$ 时的初始条件是 $n^0 = 1.0$ 和 $C_i^0 = (\\beta_i / (\\lambda_i \\Lambda)) n^0$。注意 $C_i^0$ 依赖于 $\\Lambda$，必须针对每种情况进行计算。\n总缓发中子份额计算为 $\\beta = \\sum_{i=1}^M \\beta_i = 0.006347$。\n实现将针对四个指定的测试案例遵循此算法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Point Kinetics Equations for four test cases using a\n    semi-implicit numerical scheme and prints the results.\n    \"\"\"\n\n    # Define standard delayed neutron group parameters for M=6\n    # Decay constants (lambda_i) in s^-1\n    lambdas = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    # Delayed neutron fractions (beta_i)\n    betas = np.array([0.000246, 0.001238, 0.001274, 0.002568, 0.000748, 0.000273])\n    # Total delayed neutron fraction\n    beta_total = np.sum(betas)\n\n    def run_simulation(Lambda, rho_func, T, dt):\n        \"\"\"\n        Runs a single PKE simulation for a given set of parameters.\n\n        Args:\n            Lambda (float): Neutron generation time in seconds.\n            rho_func (callable): Function of time t that returns reactivity rho.\n            T (float): Total simulation time in seconds.\n            dt (float): Time step size in seconds.\n\n        Returns:\n            float: The final neutron density n(T).\n        \"\"\"\n        # Initial conditions for a critical reactor (rho=0 at t=0)\n        n = 1.0\n        # This must be calculated with the case-specific Lambda\n        c = (betas / (lambdas * Lambda)) * n\n\n        # Time stepping\n        num_steps = int(round(T / dt))\n        t = 0.0\n\n        for k in range(num_steps):\n            # State at the beginning of the step (k)\n            n_k = n\n            c_k = c\n            \n            # Time at the end of the step (k+1)\n            t_next = t + dt\n            rho_next = rho_func(t_next)\n\n            # --- Calculate the state at t_next ---\n            \n            # 1. Update neutron density (n) using the semi-implicit formula\n            # Delayed source term is explicit (evaluated at k)\n            delayed_source = np.sum(lambdas * c_k)\n            \n            numerator = n_k + dt * delayed_source\n            denominator = 1.0 - (dt / Lambda) * (rho_next - beta_total)\n            \n            n_next = numerator / denominator\n\n            # 2. Update precursor concentrations (c) using the explicit formula\n            # All terms are evaluated at k\n            c_next = (1.0 - dt * lambdas) * c_k + (dt * betas / Lambda) * n_k\n\n            # --- Update state for the next iteration ---\n            n = n_next\n            c = c_next\n            t = t_next\n\n        return n\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"Lambda\": 0.0001,\n            \"rho_func\": lambda t: 0.002,\n            \"T\": 5.0,\n            \"dt\": 0.001\n        },\n        {\n            \"name\": \"Case B\",\n            \"Lambda\": 0.00001,\n            \"rho_func\": lambda t: 0.007,\n            \"T\": 0.02,\n            \"dt\": 0.000002\n        },\n        {\n            \"name\": \"Case C\",\n            \"Lambda\": 0.00001,\n            \"rho_func\": lambda t: 0.007,\n            \"T\": 0.02,\n            \"dt\": 0.01\n        },\n        {\n            \"name\": \"Case D\",\n            \"Lambda\": 0.0001,\n            \"rho_func\": lambda t: (0.005 / 2.0) * t if t = 2.0 else 0.005,\n            \"T\": 2.0,\n            \"dt\": 0.0005\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        final_n = run_simulation(\n            Lambda=case[\"Lambda\"],\n            rho_func=case[\"rho_func\"],\n            T=case[\"T\"],\n            dt=case[\"dt\"]\n        )\n        results.append(final_n)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何数值解本质上都是一种近似，其误差可能不仅仅是数值上的偏差，还可能歪曲系统的动态行为。本练习超越了简单的误差计算，通过频域分析深入探讨数值方法如何引入伪影，例如数值阻尼和相位误差。通过量化这些影响，您将学会识别这些伪影如何可能在反应堆控制和稳定性研究中被误解为真实的物理效应。",
            "id": "4239394",
            "problem": "考虑在临界稳态附近，小型反应性微扰下的单群核反应堆点动力学。从中子平衡和缓发中子先驱核平衡方程出发，获得一个适用于频域分析的最小线性模型。其基本依据是标准的单群点动力学模型，在连续时间下，该模型表示为两个耦合的常微分方程，关联了中子布居和缓发中子先驱核浓度。假设归一化的基线中子布居为1，并施加微小的正弦反应性强迫。\n\n起点与建模假设：\n- 设归一化的中子布居为 $n(t)$，缓发中子先驱核浓度为 $C(t)$，其中 $n(t)$ 是无量纲的，$C(t)$ 采用一致的归一化方式，以确保耦合项在量纲上是合理的。\n- 设有效缓发中子份额为 $\\beta$（无量纲），瞬发中子代时间为 $\\Lambda$（单位：秒），有效单群衰变常数为 $\\lambda$（单位：秒的倒数）。\n- 设反应性微扰为标量输入 $u(t) = \\delta \\rho(t)$（无量纲），并假设其在角频率 $\\omega$（单位：弧度/秒）下是微小的正弦波。\n- 在临界稳态（$n_0 = 1$（无量纲），$\\rho_0 = 0$（无量纲））附近进行精确线性化。\n\n任务：\n1. 从单群点动力学方程\n   $$\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda}\\,n(t) + \\lambda\\,C(t), \\qquad \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}\\,n(t) - \\lambda\\,C(t),$$\n   出发，推导一个针对状态向量 $x(t) = \\begin{bmatrix}\\delta n(t) \\\\ \\delta C(t)\\end{bmatrix}$ 和输入 $u(t) = \\delta \\rho(t)$ 的线性时不变（LTI）微扰模型，其形式为\n   $$\\frac{dx}{dt} = A\\,x(t) + B\\,u(t), \\qquad y(t) = H\\,x(t),$$\n   其中 $y(t) = \\delta n(t)$ 是我们关心的输出。在 $n_0 = 1$ 的归一化条件下，用 $\\beta$、$\\Lambda$ 和 $\\lambda$ 显式地确定 $A$、$B$ 和 $H$。\n\n2. 将从 $u(t)$ 到 $y(t)$ 的连续时间频率响应（传递函数）定义为\n   $$G(s) = H\\,(sI - A)^{-1}B,$$\n   并将角频率 $\\omega$（单位：弧度/秒）下的稳态正弦响应定义为 $G(i\\omega)$。\n\n3. 对于应用于该LTI状态空间模型的三个时间步进格式，推导相应的离散时间状态更新和在单位圆上求值的离散时间传递函数。这些格式是：\n   - 前向（显式）Euler法：推导 $M_{\\mathrm{FE}}$ 和 $N_{\\mathrm{FE}}$，使得\n     $$x_{k+1} = M_{\\mathrm{FE}}\\,x_k + N_{\\mathrm{FE}}\\,u_k.$$\n   - 后向（隐式）Euler法：推导 $M_{\\mathrm{BE}}$ 以及与在步末求值相一致的输入映射，\n     $$x_{k+1} = M_{\\mathrm{BE}}\\,x_k + \\tilde{N}_{\\mathrm{BE}}\\,u_{k+1}.$$\n   - 梯形（Crank-Nicolson, CN）法：推导 $M_{\\mathrm{CN}}$ 以及用于步初和步末的输入映射，\n     $$x_{k+1} = M_{\\mathrm{CN}}\\,x_k + N_{\\mathrm{CN},0}\\,u_k + N_{\\mathrm{CN},1}\\,u_{k+1}.$$\n   对于每种格式，使用后向Euler法和Crank-Nicolson法输入项中的 $u_{k+1}$ 所引入的适当 $z$ 因子，定义离散时间传递函数 $G_d(z)$ 在 $z=e^{i\\Omega}$ 处的值，其中 $\\Omega = \\omega h$（无量纲），$h$ 是时间步长（单位：秒）。\n\n4. 量化相对于连续时间响应的数值伪影。定义：\n   - 数值增益比为 $\\gamma = \\frac{|G_d(e^{i\\Omega})|}{|G(i\\omega)|}$（无量纲）。\n   - 附加数值相位误差为 $\\phi_{\\mathrm{err}} = \\operatorname{Arg}\\big(G_d(e^{i\\Omega})\\big) - \\operatorname{Arg}\\big(G(i\\omega)\\big)$（单位：弧度），并将其包裹到主区间 $\\left[-\\pi,\\pi\\right]$ 内。\n\n5. 使用以下物理上合理的参数值：\n   - 有效缓发中子份额 $\\beta = 0.0065$（无量纲）。\n   - 瞬发中子代时间 $\\Lambda = 1.0\\times 10^{-4}$（单位：秒）。\n   - 有效单群衰变常数 $\\lambda = 0.08$（单位：秒的倒数）。\n   - 基线归一化功率 $n_0 = 1$（无量纲）。\n\n6. 针对指定的测试套件（方法、时间步长和强迫频率的组合），评估数值伪影。每个测试用例是一个三元组 $(\\text{方法}, h, \\omega):$\n   - 测试用例 1：前向 Euler法，$h = 0.001$（单位：秒），$\\omega = 2\\pi \\cdot 1$（单位：弧度/秒）。\n   - 测试用例 2：前向 Euler法，$h = 0.02$（单位：秒），$\\omega = 2\\pi \\cdot 1$（单位：弧度/秒）。\n   - 测试用例 3：后向 Euler法，$h = 0.02$（单位：秒），$\\omega = 2\\pi \\cdot 10$（单位：弧度/秒）。\n   - 测试用例 4：Crank-Nicolson法，$h = 0.02$（单位：秒），$\\omega = 2\\pi \\cdot 10$（单位：弧度/秒）。\n   - 测试用例 5：前向 Euler法，$h = 0.005$（单位：秒），$\\omega = 600.0$（单位：弧度/秒）。\n\n7. 科学解释要求：在量化 $\\gamma$ 和 $\\phi_{\\mathrm{err}}$ 之后，阐述数值阻尼（即 $\\gamma  1$）或放大（即 $\\gamma > 1$）以及数值相位滞后（即 $\\phi_{\\mathrm{err}}  0$）在反应堆控制研究中可能如何被误读。例如，讨论过度数值阻尼如何可能被误解为更强的固有负反应性反馈，或者相位滞后如何可能被误解为影响稳定性裕度的传感器延迟或执行器延迟。这种解释性映射应从计算出的伪影中得出，而不引入非物理假设。\n\n所需输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 每个测试用例的结果必须是 $[\\gamma, \\phi_{\\mathrm{err}}]$ 顺序的双元素列表，两个值均为浮点数，并四舍五入到六位小数。\n- 因此，总输出必须是一个嵌套列表，格式类似于\n  $$\\big[[\\gamma_1,\\phi_{\\mathrm{err},1}],[\\gamma_2,\\phi_{\\mathrm{err},2}],\\dots\\big],$$\n  并以\n  $$\\texttt{[[g1,p1],[g2,p2],...]}$$\n  的形式精确打印为单行。\n\n角度单位规范：\n- 以弧度表示 $\\phi_{\\mathrm{err}}$（不要用度）。",
            "solution": "用户提供了一个关于核反应堆动力学的明确问题，重点是通过频域分析线性化的点动力学方程，以及常见时间步进格式引入的数值伪影。该问题在科学上是合理的、自洽的，并且在算法上是可处理的。\n\n解决方案系统地遵循问题陈述中概述的任务进行。\n\n\\textbf{任务1：线性时不变（LTI）模型的推导}\n\n起点是单群点动力学方程：\n$$ \\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda}n(t) + \\lambda C(t) $$\n$$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}n(t) - \\lambda C(t) $$\n我们在临界稳态 $(\\rho_0, n_0, C_0)$ 附近对这些方程进行线性化，其中 $\\rho_0=0$，归一化中子布居为 $n_0=1$。在稳态下，时间导数为零：\n$$ 0 = \\frac{0 - \\beta}{\\Lambda}n_0 + \\lambda C_0 \\implies \\lambda C_0 = \\frac{\\beta}{\\Lambda}n_0 $$\n$$ 0 = \\frac{\\beta}{\\Lambda}n_0 - \\lambda C_0 $$\n当 $n_0=1$ 时，稳态先驱核浓度为 $C_0 = \\frac{\\beta}{\\lambda \\Lambda}$。\n\n设变量由其稳态值加上小的微扰表示：\n$n(t) = n_0 + \\delta n(t) = 1 + \\delta n(t)$\n$C(t) = C_0 + \\delta C(t)$\n$\\rho(t) = \\rho_0 + \\delta \\rho(t) = \\delta \\rho(t)$\n\n将这些代入原方程，并只保留微扰项（$\\delta n, \\delta C, \\delta \\rho$）的一阶项：\n对于中子布居方程：\n$$ \\frac{d(1 + \\delta n)}{dt} = \\frac{\\delta\\rho(t) - \\beta}{\\Lambda}(1 + \\delta n(t)) + \\lambda(C_0 + \\delta C(t)) $$\n$$ \\frac{d\\delta n}{dt} \\approx \\left(\\frac{\\delta\\rho(t)}{\\Lambda} - \\frac{\\beta}{\\Lambda}\\right)(1) + \\left(\\frac{-\\beta}{\\Lambda}\\right)\\delta n(t) + \\lambda C_0 + \\lambda \\delta C(t) $$\n$$ \\frac{d\\delta n}{dt} = \\frac{\\delta\\rho}{\\Lambda}n_0 - \\frac{\\beta}{\\Lambda}n_0 - \\frac{\\beta}{\\Lambda}\\delta n + \\lambda C_0 + \\lambda \\delta C $$\n根据稳态条件，$-\\frac{\\beta}{\\Lambda}n_0 + \\lambda C_0$ 项之和为零。回顾 $n_0=1$：\n$$ \\frac{d\\delta n}{dt} = -\\frac{\\beta}{\\Lambda}\\delta n(t) + \\lambda \\delta C(t) + \\frac{1}{\\Lambda}\\delta \\rho(t) $$\n对于先驱核浓度方程：\n$$ \\frac{d(C_0 + \\delta C)}{dt} = \\frac{\\beta}{\\Lambda}(1 + \\delta n(t)) - \\lambda(C_0 + \\delta C(t)) $$\n$$ \\frac{d\\delta C}{dt} = \\frac{\\beta}{\\Lambda}n_0 + \\frac{\\beta}{\\Lambda}\\delta n(t) - \\lambda C_0 - \\lambda \\delta C(t)$$\n同样，稳态项 $\\frac{\\beta}{\\Lambda}n_0 - \\lambda C_0$ 相互抵消。\n$$ \\frac{d\\delta C}{dt} = \\frac{\\beta}{\\Lambda}\\delta n(t) - \\lambda \\delta C(t) $$\n现在我们可以将其写成状态空间形式 $\\frac{dx}{dt} = Ax(t) + Bu(t)$，其中 $x(t) = \\begin{bmatrix}\\delta n(t) \\\\ \\delta C(t)\\end{bmatrix}$ 且 $u(t) = \\delta \\rho(t)$。\n\n状态矩阵 $A$、输入矩阵 $B$ 和输出矩阵 $H$（对于输出 $y(t) = \\delta n(t)$）为：\n$$ A = \\begin{bmatrix} -\\frac{\\beta}{\\Lambda}  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  -\\lambda \\end{bmatrix}, \\quad B = \\begin{bmatrix} \\frac{1}{\\Lambda} \\\\ 0 \\end{bmatrix}, \\quad H = \\begin{bmatrix} 1  0 \\end{bmatrix} $$\n\n\\textbf{任务2：连续时间频率响应}\n\n从输入 $u(t)=\\delta\\rho(t)$ 到输出 $y(t)=\\delta n(t)$ 的传递函数 $G(s)$ 由 $G(s) = H(sI - A)^{-1}B$ 给出。\n首先，我们求 $(sI - A)^{-1}$：\n$$ sI - A = \\begin{bmatrix} s + \\frac{\\beta}{\\Lambda}  -\\lambda \\\\ -\\frac{\\beta}{\\Lambda}  s + \\lambda \\end{bmatrix} $$\n$$ \\det(sI - A) = \\left(s + \\frac{\\beta}{\\Lambda}\\right)(s + \\lambda) - \\lambda\\frac{\\beta}{\\Lambda} = s^2 + s\\lambda + s\\frac{\\beta}{\\Lambda} = s\\left(s + \\lambda + \\frac{\\beta}{\\Lambda}\\right) $$\n$$ (sI - A)^{-1} = \\frac{1}{\\det(sI-A)} \\begin{bmatrix} s + \\lambda  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  s + \\frac{\\beta}{\\Lambda} \\end{bmatrix} $$\n现在，我们计算 $G(s)$：\n$$ G(s) = \\begin{bmatrix} 1  0 \\end{bmatrix} \\frac{1}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} \\begin{bmatrix} s + \\lambda  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  s + \\frac{\\beta}{\\Lambda} \\end{bmatrix} \\begin{bmatrix} \\frac{1}{\\Lambda} \\\\ 0 \\end{bmatrix} $$\n$$ G(s) = \\frac{1}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} \\begin{bmatrix} 1  0 \\end{bmatrix} \\begin{bmatrix} \\frac{s+\\lambda}{\\Lambda} \\\\ \\frac{\\beta}{\\Lambda^2} \\end{bmatrix} = \\frac{\\frac{s+\\lambda}{\\Lambda}}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} $$\n这是标准的零功率反应堆传递函数。频率为 $\\omega$ 时的稳态正弦响应通过将 $G(s)$ 在 $s = i\\omega$ 处求值得到，其中 $i=\\sqrt{-1}$。\n\n\\textbf{任务3：离散时间模型与传递函数}\n\n我们用时间步长 $h$ 对 LTI 系统 $\\frac{dx}{dt} = Ax + Bu$ 进行离散化。\n\n\\textit{前向Euler法 (FE):} 更新公式为 $x_{k+1} = x_k + h(Ax_k + Bu_k)$。\n$$ x_{k+1} = (I + hA)x_k + (hB)u_k $$\n这得到 $M_{\\mathrm{FE}} = I + hA$ 和 $N_{\\mathrm{FE}} = hB$。\n根据z变换 $z x(z) = M_{\\mathrm{FE}}x(z) + N_{\\mathrm{FE}}u(z)$，离散传递函数为：\n$$ G_{d, \\mathrm{FE}}(z) = H(zI - M_{\\mathrm{FE}})^{-1}N_{\\mathrm{FE}} $$\n\n\\textit{后向Euler法 (BE):} 更新公式为 $x_{k+1} = x_k + h(Ax_{k+1} + Bu_{k+1})$。\n$$ (I - hA)x_{k+1} = x_k + hBu_{k+1} \\implies x_{k+1} = (I - hA)^{-1}x_k + h(I - hA)^{-1}Bu_{k+1} $$\n这得到 $M_{\\mathrm{BE}} = (I-hA)^{-1}$ 和 $\\tilde{N}_{\\mathrm{BE}} = h(I - hA)^{-1}B$。\n由于存在 $u_{k+1}$ 项，z变换为 $z x(z) = M_{\\mathrm{BE}}x(z) + z\\tilde{N}_{\\mathrm{BE}}u(z)$。传递函数为：\n$$ G_{d, \\mathrm{BE}}(z) = H(zI - M_{\\mathrm{BE}})^{-1}z\\tilde{N}_{\\mathrm{BE}} $$\n\n\\textit{Crank-Nicolson (CN) 法:} 更新公式对导数求平均值：$x_{k+1} = x_k + \\frac{h}{2}[(Ax_k+Bu_k) + (Ax_{k+1}+Bu_{k+1})]$。\n$$ \\left(I - \\frac{h}{2}A\\right)x_{k+1} = \\left(I + \\frac{h}{2}A\\right)x_k + \\frac{h}{2}B u_k + \\frac{h}{2}B u_{k+1} $$\n$$ x_{k+1} = \\left(I - \\frac{h}{2}A\\right)^{-1}\\left(I + \\frac{h}{2}A\\right)x_k + \\left(I - \\frac{h}{2}A\\right)^{-1}\\frac{h}{2}B u_k + \\left(I - \\frac{h}{2}A\\right)^{-1}\\frac{h}{2}B u_{k+1} $$\n这得到 $M_{\\mathrm{CN}} = (I - \\frac{h}{2}A)^{-1}(I + \\frac{h}{2}A)$，$N_{\\mathrm{CN},0} = (I - \\frac{h}{2}A)^{-1}\\frac{h}{2}B$，以及 $N_{\\mathrm{CN},1} = (I - \\frac{h}{2}A)^{-1}\\frac{h}{2}B$。 \nz变换为 $z x(z) = M_{\\mathrm{CN}}x(z) + (N_{\\mathrm{CN},0} + zN_{\\mathrm{CN},1})u(z)$。传递函数为：\n$$ G_{d, \\mathrm{CN}}(z) = H(zI - M_{\\mathrm{CN}})^{-1}(N_{\\mathrm{CN},0} + zN_{\\mathrm{CN},1}) $$\n对于所有格式，频率响应通过设置 $z = e^{i\\Omega}$ 来找到，其中 $\\Omega = \\omega h$。\n\n\\textbf{任务4-6：数值伪影、参数和评估}\n\n数值增益比 $\\gamma$ 和相位误差 $\\phi_{\\mathrm{err}}$ 是针对指定的参数和测试用例计算的。参数为 $\\beta = 0.0065$，$\\Lambda = 1.0 \\times 10^{-4}\\,\\mathrm{s}$，以及 $\\lambda = 0.08\\,\\mathrm{s}^{-1}$。这些值被代入矩阵 $A$、$B$ 和 $H$ 中。每个测试用例的计算涉及复杂的矩阵代数，由随附的Python代码执行。相位误差被包裹到区间 $[-\\pi, \\pi]$ 内。\n\n\\textbf{任务7：科学解释}\n\n数值伪影 $\\gamma$ 和 $\\phi_{\\mathrm{err}}$ 量化了数值解在频域中与真实解析解的偏差。将这些伪影误解为物理现象可能导致在反应堆安全和控制分析中得出错误的结论。\n\n数值增益比 $\\gamma  1$ 表示\\textit{数值阻尼}。仿真预测的响应振幅小于实际的物理响应。在反应堆控制的背景下，这可能被误认为更强的固有负反馈（如多普勒效应），使得反应堆看起来比实际更稳定、自调节能力更强。这可能导致在运行瞬态期间对功率峰值的不安全低估。\n\n相反，$\\gamma > 1$ 代表\\textit{数值放大}。这可能导致对不稳定性的错误预测或对瞬态严重性的严重高估。分析师可能得出系统不如实际稳定的结论，从而可能施加不必要的限制性操作限值。\n\n数值相位误差 $\\phi_{\\mathrm{err}} \\neq 0$ 表明仿真引入了时间平移误差。负误差 $\\phi_{\\mathrm{err}}  0$ 是\\textit{数值相位滞后}。仿真的中子布居响应将滞后于对反应性变化的真实物理响应。这尤其有害，因为它模仿了现实世界中的延迟，如传感器延迟或执行器延迟。由于相位滞后会侵蚀相位裕度（反馈稳定性的一个关键指标），显著的数值相位滞后可能导致对系统稳定性的不正确评估，可能掩盖潜在的不稳定性或误诊其原因。正误差 $\\phi_{\\mathrm{err}} > 0$（相位超前）对于简单方法不太常见，但会人为地增加相位裕度，描绘出系统稳定性的过于乐观的景象。\n\n总之，这些数值伪影不仅仅是数学上的奇特现象；它们可以直接影响核反应堆安全分析的保真度和控制系统的设计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear reactor kinetics numerical analysis problem.\n\n    This function performs the following steps:\n    1. Defines the physical parameters for the point kinetics model.\n    2. Defines the LTI state-space matrices (A, B, H).\n    3. Defines a list of test cases, each specifying a numerical method,\n       time step (h), and forcing frequency (omega).\n    4. For each test case:\n       a. Calculates the exact continuous-time frequency response G(i*omega).\n       b. Calculates the discrete-time frequency response G_d(exp(i*omega*h))\n          for the specified numerical method.\n       c. Computes the numerical gain ratio (gamma) and phase error (phi_err).\n    5. Formats and prints the results as required.\n    \"\"\"\n    \n    # 5. Use the following physically plausible parameter values:\n    beta = 0.0065  # Effective delayed neutron fraction\n    Lambda = 1.0e-4  # Prompt neutron generation time [s]\n    lmbda = 0.08  # Effective single-group decay constant [1/s]\n\n    # 1. Derive a Linear Time-Invariant (LTI) perturbation model\n    # A matrix\n    A = np.array([\n        [-beta / Lambda, lmbda],\n        [beta / Lambda, -lmbda]\n    ], dtype=float)\n\n    # B matrix\n    B = np.array([\n        [1.0 / Lambda],\n        [0.0]\n    ], dtype=float)\n\n    # H matrix\n    H = np.array([[1.0, 0.0]], dtype=float)\n    \n    # 6. Evaluate the numerical artifacts for the specified test suite\n    test_cases = [\n        # (method, h, omega)\n        (\"FE\", 0.001, 2.0 * np.pi * 1.0),\n        (\"FE\", 0.02, 2.0 * np.pi * 1.0),\n        (\"BE\", 0.02, 2.0 * np.pi * 10.0),\n        (\"CN\", 0.02, 2.0 * np.pi * 10.0),\n        (\"FE\", 0.005, 600.0)\n    ]\n\n    results = []\n    I = np.identity(2, dtype=float)\n\n    for method, h, omega in test_cases:\n        s = 1j * omega\n        \n        # 2. Define the continuous-time frequency response G(i*omega)\n        # G(s) = H * (sI - A)^-1 * B\n        G_continuous = H @ np.linalg.inv(s * I - A) @ B\n        G_cont_val = G_continuous[0, 0]\n\n        # 3. For three time-stepping schemes, derive discrete-time transfer function\n        Omega = omega * h\n        z = np.exp(1j * Omega)\n        \n        G_d_val = 0.0 + 0.0j\n\n        if method == \"FE\":\n            # Forward Euler\n            # x_{k+1} = (I + hA)x_k + (hB)u_k\n            # M_FE = I + hA, N_FE = hB\n            # G_d(z) = H * (zI - M_FE)^-1 * N_FE\n            M_fe = I + h * A\n            N_fe = h * B\n            G_discrete = H @ np.linalg.inv(z * I - M_fe) @ N_fe\n            G_d_val = G_discrete[0, 0]\n            \n        elif method == \"BE\":\n            # Backward Euler\n            # x_{k+1} = (I - hA)^-1 * x_k + h*(I-hA)^-1*B * u_{k+1}\n            # M_BE = (I-hA)^-1, N_tilde_BE = h*(I-hA)^-1*B\n            # G_d(z) = H * (zI - M_BE)^-1 * z*N_tilde_BE\n            inv_term_be = np.linalg.inv(I - h * A)\n            M_be = inv_term_be\n            N_tilde_be = h * inv_term_be @ B\n            G_discrete = H @ np.linalg.inv(z * I - M_be) @ (z * N_tilde_be)\n            G_d_val = G_discrete[0, 0]\n\n        elif method == \"CN\":\n            # Crank-Nicolson\n            # x_k+1 = M_CN*x_k + N_CN0*u_k + N_CN1*u_{k+1}\n            # M_CN = (I-h/2 A)^-1 * (I+h/2 A)\n            # N_CN0 = N_CN1 = (I-h/2 A)^-1 * h/2 * B\n            # G_d(z) = H * (zI - M_CN)^-1 * (N_CN0 + z*N_CN1)\n            inv_term_cn = np.linalg.inv(I - 0.5 * h * A)\n            M_cn = inv_term_cn @ (I + 0.5 * h * A)\n            N_cn0 = inv_term_cn @ (0.5 * h * B)\n            N_cn1 = N_cn0 # N_CN0 and N_CN1 are identical\n            G_discrete = H @ np.linalg.inv(z * I - M_cn) @ (N_cn0 + z * N_cn1)\n            G_d_val = G_discrete[0, 0]\n            \n        # 4. Quantify numerical artifacts\n        # Numerical gain ratio\n        gamma = np.abs(G_d_val) / np.abs(G_cont_val)\n        \n        # Additional numerical phase error\n        phi_d = np.angle(G_d_val)\n        phi_cont = np.angle(G_cont_val)\n        phi_err = phi_d - phi_cont\n        \n        # Wrap phase error to the principal interval [-pi, pi]\n        phi_err_wrapped = (phi_err + np.pi) % (2 * np.pi) - np.pi\n        \n        results.append([round(gamma, 6), round(phi_err_wrapped, 6)])\n\n    # Required output format: [[g1,p1],[g2,p2],...]\n    result_str = \",\".join([f\"[{g},{p}]\" for g, p in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}