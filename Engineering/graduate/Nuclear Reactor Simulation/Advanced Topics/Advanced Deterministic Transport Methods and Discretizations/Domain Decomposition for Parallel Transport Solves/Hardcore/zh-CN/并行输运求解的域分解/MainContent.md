## 引言
对中子输运过程进行高保真度仿真是现代[核反应堆设计](@entry_id:1128940)、安全分析与优化的基石。然而，中子输运方程的复杂性——涉及空间、能量和角度等多个维度——导致其数值求解需要巨大的计算资源，常常超出单台计算机的处理能力。为了克服这一瓶颈，[并行计算](@entry_id:139241)成为不可或缺的工具，而[区域分解](@entry_id:165934)（Domain Decomposition）方法正是实现高效并行求解的核心策略。它通过“[分而治之](@entry_id:273215)”的思想，将庞大的计算任务分解为可在数千个处理器上协同处理的子任务，从而开启了全堆芯精细模拟的可能性。

本文旨在系统性地介绍用于并行输运求解的区域分解方法。我们首先在“原理与机制”一章中，深入探讨该方法的基础，解释如何划分计算空间，如何设计[子域](@entry_id:155812)间的通信以保证物理守恒，以及不同的分解与迭代策略如何影响[并行效率](@entry_id:637464)与[收敛速度](@entry_id:636873)。接着，在“应用与跨学科联系”一章中，我们将展示这些原理在核反应堆物理前沿问题中的具体应用，并进一步揭示其在[计算流体力学](@entry_id:747620)、天体物理等其他科学计算领域的普适性。最后，通过“动手实践”部分提供的一系列精心设计的问题，读者将有机会将理论知识付诸实践，加深对并行数据交换、性能评估与调度优化等核心概念的理解。

## 原理与机制

在[并行计算](@entry_id:139241)环境中求解[中子输运方程](@entry_id:1128709)，核心在于将庞大的计算任务分解为可在多个处理器上协同执行的较小部分。这种分解通常通过**[区域分解](@entry_id:165934) (Domain Decomposition, DD)** 实现，即将计算域的几何空间划分为若干[子域](@entry_id:155812)。本章将深入探讨并行输运求解背后的基本原理与核心机制，阐述如何定义子域、如何在子域间传递信息以确保解的正确性与物理守恒性，以及不同的分解与迭代策略如何影响[并行性能](@entry_id:636399)与[收敛速度](@entry_id:636873)。

### 空间划分的基本概念

对[输运方程](@entry_id:174281)进行并行求解的第一步是对其离散后的网格进行划分。最基本的区分在于[子域](@entry_id:155812)之间是否存在重叠。

**非重叠与重叠分解**

一个[计算网格](@entry_id:168560) $\mathcal{T}$ 可以被划分为 $P$ 个子网格（或称子域）$\{\mathcal{T}_i\}_{i=1}^{P}$。

在**非重叠[区域分解](@entry_id:165934) (non-overlapping domain decomposition)** 中，子域的划分满足 $\mathcal{T}=\bigcup_{i=1}^{P}\mathcal{T}_i$，且任意两个不同[子域](@entry_id:155812) $\mathcal{T}_i$ 和 $\mathcal{T}_j$ 的内部不相交。它们仅在公共的边界上接触，这些边界被称为**界面 (interface)**。两个相邻[子域](@entry_id:155812) $\mathcal{T}_i$ 和 $\mathcal{T}_j$ 之间的内部界面 $\Gamma_{ij}$ 可以被精确地定义为它们[闭集](@entry_id:136446)的交集，并排除整个计算域的外部边界 $\partial\mathcal{D}$，即 $\Gamma_{ij} = (\overline{\mathcal{T}_i} \cap \overline{\mathcal{T}_j}) \setminus \partial\mathcal{D}$ 。在这些界面上，从一个子域流出的粒子将成为相邻子域的入流边界条件。这种信息交换通过所谓的**传输条件 (transmission conditions)** 来实现，这是非重叠方法的核心。

为了在数值上实现这一点，通常会引入**“幽灵”单元 (ghost cells)**。对于一个[子域](@entry_id:155812) $\mathcal{T}_i$ 而言，其边界附近的计算单元在执行计算时（例如，使用[有限体积法](@entry_id:141374)），其计算模板可能需要邻近单元的信息。如果邻近单元属于另一个[子域](@entry_id:155812) $\mathcal{T}_j$，那么所需的信息就必须通过处理器间通信获得。幽灵单元是分配在[子域](@entry_id:155812) $\mathcal{T}_i$ 内存中的[数据缓冲](@entry_id:173397)区，用于存储从邻域 $\mathcal{T}_j$ 接收到的数据副本。重要的是，这些幽灵单元中的值对于子域 $\mathcal{T}_i$ 来说是已知的边界数据，而不是其内部需要求解的独立未知数 。

相比之下，**重叠型 Schwarz 分解 (overlapping Schwarz decomposition)** 采用不同的策略。每个子域 $\mathcal{T}_i$ 被扩展为一个包含其邻近[子域](@entry_id:155812)一层或多层单元的重叠区域 $\tilde{\mathcal{T}}_i$。每个处理器在各自的扩展[子域](@entry_id:155812) $\tilde{\mathcal{T}}_i$ 上独立求解输运问题，并在扩展区域的人工边界上施加适当的边界条件。由于计算模板所需的邻近单元已经被包含在重叠区域内部，因此通常不需要幽灵单元这种数据结构。在每个子域的局部求解完成后，通过[限制算子](@entry_id:754316)将重叠区域的解更新到原始的非重叠区域 $\mathcal{T}_i$ 上，并重复此过程直至收敛 。

尽管重叠方法在某些[椭圆问题](@entry_id:146817)中表现优越，但对于具有明确方向性的双曲型输运问题，基于非重叠分解的“[输运扫描](@entry_id:1133407)”方法更为自然和普遍。因此，本章的后续讨论将主要集中于非重叠分解。

### 分解域上的[输运扫描](@entry_id:1133407)机制

中子输运方程的流项 $\boldsymbol{\Omega}\cdot\nabla \psi$ 决定了其中子沿特定方向 $\boldsymbol{\Omega}$ 的[直线传播](@entry_id:175237)特性。这赋予了方程强烈的方向性和因果性，即某点处的角通量值取决于其上游（upwind）方向的通量值。这一物理特性是并行[输运扫描](@entry_id:1133407)算法的基石。

**上风耦合与界面数据**

在一个非重叠分解的域上，为了保证[全局解](@entry_id:180992)的连续性和物理守恒性，必须在子域界面上正确地传递信息。对于给定的离散方向 $\boldsymbol{\Omega}_m$，当粒子从[子域](@entry_id:155812) $\mathcal{T}_i$ 穿过界面 $\Gamma_{ij}$ 进入子域 $\mathcal{T}_j$ 时，$\mathcal{T}_i$ 中计算得到的[出射角](@entry_id:264341)通量 (outgoing angular flux) 必须作为 $\mathcal{T}_j$ 的入射角通量 (incoming angular flux) 边界条件。

设 $\mathbf{n}_i$ 为子域 $\mathcal{T}_i$ 在界面上的外法向[单位向量](@entry_id:165907)，那么方向 $\boldsymbol{\Omega}_m$ 对于 $\mathcal{T}_i$ 是出射方向的条件是 $\boldsymbol{\Omega}_m \cdot \mathbf{n}_i > 0$。对于邻居 $\mathcal{T}_j$，其在同一界面的外法向为 $\mathbf{n}_j = -\mathbf{n}_i$，因此同一方向对于 $\mathcal{T}_j$ 必然是入射方向，因为 $\boldsymbol{\Omega}_m \cdot \mathbf{n}_j  0$。

因此，为了使下游[子域](@entry_id:155812)能够进行计算，上游子域必须提供其边界上的[出射角](@entry_id:264341)通量值。在一次迭代计算中，[子域](@entry_id:155812) $\mathcal{T}_i$ 需要向其所有下游邻居传递的**最小数据集**是：在其所有出射界面上，对于所有能量群 $g$ 和所有满足 $\boldsymbol{\Omega}_m \cdot \mathbf{n}_i  0$ 的离散方向 $\boldsymbol{\Omega}_m$，角通量 $\psi_g(\mathbf{r}, \boldsymbol{\Omega}_m)$ 的迹（即在界面上的值）。这被称为**半程角通量 (half-range angular flux)** 。

**守恒性与分流**

从一个更宏观的角度看，界面的连续性要求保证了粒子数的守恒。我们可以定义穿过界面的**分流 (partial currents)**。对于[子域](@entry_id:155812) $\mathcal{T}_i$ 一侧的界面，出射分流 $J_i^+$ 和入射分流 $J_i^-$ 分别定义为：
$$
\begin{gathered}
J_i^{+}(\mathbf{x}) \equiv \int_{\boldsymbol{\Omega}\cdot \mathbf{n}_i > 0} (\boldsymbol{\Omega}\cdot \mathbf{n}_i)\,\psi_i(\mathbf{x},\boldsymbol{\Omega})\,d\Omega \\
J_i^{-}(\mathbf{x}) \equiv \int_{\boldsymbol{\Omega}\cdot \mathbf{n}_i  0} (\boldsymbol{\Omega}\cdot \mathbf{n}_i)\,\psi_i(\mathbf{x},\boldsymbol{\Omega})\,d\Omega
\end{gathered}
$$
$J_i^+$ 代表单位时间、单位面积上离开[子域](@entry_id:155812) $\mathcal{T}_i$ 的粒子数率，而 $J_i^-$ 代表进入的粒子数率（其值为负）。根据散度定理，子域内的[粒子平衡](@entry_id:753197)由内部的源、吸收以及边界上的净流出（$J_i^+ + J_i^-$）决定。为了使两个相邻[子域](@entry_id:155812) $\mathcal{T}_i$ 和 $\mathcal{T}_j$ 拼合后全局守恒，它们在界面上的[粒子交换](@entry_id:154910)必须抵消。考虑到法向相反（$\mathbf{n}_j = -\mathbf{n}_i$），这要求从 $\mathcal{T}_i$ 流出的粒子恰好等于流入 $\mathcal{T}_j$ 的粒子，反之亦然。用分流表示，即 $J_i^{+} = -J_j^{-}$ 和 $J_j^{+} = -J_i^{-}$。这本质上是角通量连续性在角度空间积分后的体现 。

**依赖关系图与并行扫描算法**

对于一个固定的方向 $\boldsymbol{\Omega}_m$，由于信息严格地从上游向下游传播，网格单元之间的计算依赖关系构成了一个**有向无环图 (Directed Acyclic Graph, DAG)**，记为 $G_{\boldsymbol{\Omega}_m}$ 。图中的节点是网格单元，若单元 $j$ 的计算需要单元 $i$ 的结果（即 $i$ 在 $j$ 的上游），则存在一条从 $i$ 到 $j$ 的有向边。该图之所以是无环的，是因为在任何非周期性边界的域中，沿着 $\boldsymbol{\Omega}_m$ 方向的投影坐标 $\boldsymbol{\Omega}_m \cdot \mathbf{x}$ 在图的任何路径上都是严格单调增加的，不可能回到起点。

在分解的域上执行并行[输运扫描](@entry_id:1133407)，本质上是对这个DAG进行一次**并行[拓扑排序](@entry_id:156507)**。在输运计算领域，实现这一过程的经典算法被称为 **KBA 算法**（以其提出者 Koch, Baker, 和 Alcouffe 的名字命名）。KBA算法是一种分布式、[波前](@entry_id:197956)推进的算法，其工作方式如下 ：
1.  **初始化**: 每个处理器计算其拥有的所有单元的“入度”，即每个单元有多少个上游邻居尚未完成计算。
2.  **[波前](@entry_id:197956)计算**: 算法按“波”或“层”同步进行。在每一波中，所有处理器并行地识别并计算那些入度为零的本地单元（即所有上游依赖都已满足的单元），这构成了当前的“就绪集”。
3.  **信息传递与依赖更新**: 当一个单元被计算完毕，其出射通量就确定了。处理器将这些通量值发送给对应的下游邻居。如果下游邻居在另一个处理器上，这个过程就涉及一次[消息传递](@entry_id:751915)（MPI通信）。接收消息的处理器会更新其相应单元的入度计数。
4.  **同步**: 当所有处理器都完成了当前波次的计算和发送任务后，进行一次全局同步（例如 `MPI_Barrier`），以确保所有处理器都收到了当前波次产生的所有边界数据。之后，算法进入下一波，处理新的就绪集。
5.  **终止**: 当所有单元都被计算完毕，[算法终止](@entry_id:143996)。

### 划分策略及其影响

如何划分计算域对并行求解的性能至关重要。一个好的划分策略应旨在最小化[通信开销](@entry_id:636355)、最大化计算效率，并确保算法的可执行性。

**[分区方法](@entry_id:170629)：几何 vs. 代数**

创建分区的策略主要分为两类 ：

*   **几何区域分解 (Geometric Domain Decomposition, GDD)**: 这类方法仅根据网格的几何坐标信息进行划分。常见的算法包括递归坐标[二分法](@entry_id:140816) (Recursive Coordinate Bisection, RCB)、递归惯性二分法 (RIB) 或基于[空间填充曲线](@entry_id:149207) (Space-Filling Curve) 的排序。GDD的目标是生成形状规整、紧凑的[子域](@entry_id:155812)，从而[启发式](@entry_id:261307)地最小化[子域](@entry_id:155812)的[表面积与体积之比](@entry_id:140511)，以期减少通信量。它不直接利用[输运方程](@entry_id:174281)本身的信息。

*   **代数[区域分解](@entry_id:165934) (Algebraic Domain Decomposition, ADD)**: 这类方法直接作用于离散系统所诱导的图（通常是[邻接矩阵](@entry_id:151010)的图表示）。利用像 METIS 或 ParMETIS 这样的[图划分](@entry_id:152532)工具，ADD旨在直接最小化跨越处理器边界的“[割边](@entry_id:266750)”数量（代表通信量），同时平衡每个处理器上的节点数量（代表计算负载）。这种方法是“代数的”，因为它依赖于问题的连通性结构，而非其几何嵌入。

无论采用何种策略，一个健壮的并行实现都必须建立一套明确的**处理器所有权 (processor ownership)** 规则。通常，每个单元由一个处理器唯一拥有。对于处在两个或多个子域边界上的共享实体（如面、边、顶点），也必须通过一个静态的、确定性的规则（例如，由拥有最小全局ID邻近单元的处理器拥有）来指定唯一的所有者，以避免数据竞争和不一致性 。

**可扫描性约束**

并非所有分区都是有效的。一个分区方案必须保证对于**每一个**离散方向 $\boldsymbol{\Omega}_m$，并行扫描都是可能执行的。这意味着由该分区导出的**[子域](@entry_id:155812)级依赖图** $\mathcal{Q}_{m,g}$ 必须是一个[有向无环图](@entry_id:164045)（DAG）。如果对于某个方向，$\mathcal{Q}_{m,g}$ 中存在环路（例如，$P_1 \to P_2 \to P_1$），那么就会出现计算[死锁](@entry_id:748237)：$P_1$ 的计算等待 $P_2$ 的结果，而 $P_2$ 又在等待 $P_1$ 的结果。

一个典型的导致环路的例子是“棋盘式”分区。在一个 $2 \times 2$ 的网格上，如果将左下 ($C_{11}$) 和右上 ($C_{22}$) 单元划分为[子域](@entry_id:155812) $P_1$，将左上 ($C_{12}$) 和右下 ($C_{21}$) 单元划分为子域 $P_2$，那么对于方向 $\boldsymbol{\Omega}=(1,1)/\sqrt{2}$，信息流向是$P_1 \to P_2$（因为 $C_{12}$ 和 $C_{21}$ 依赖于 $C_{11}$）和 $P_2 \to P_1$（因为 $C_{22}$ 依赖于 $C_{12}$ 和 $C_{21}$），从而形成环路，使得该分区对于此方向是“不可扫描的” 。

**评价分区的质量指标**

一个“好”的分区方案应该在多个方面进行优化，这些方面可以通过以下几个关键指标来量化 ：

*   **[割边](@entry_id:266750) (Edge-cut)**: 这是一个图论指标，衡量的是被分区切割的边的数量（或其权重之和）。在我们的情境下，它直接对应于需要进行处理器间通信的单元邻接关系的总量。最小化[割边](@entry_id:266750)旨在**减少总的通信数据量**。

*   **[表面积与体积比](@entry_id:896139) (Surface-to-Volume Ratio, SVR)**: 这是一个几何指标，衡量[子域](@entry_id:155812)的“紧凑性”。计算工作量大致与[子域](@entry_id:155812)的体积（单元数）成正比，而通信量则与[子域](@entry_id:155812)的界面面积成正比。一个低SVR意味着每个[子域](@entry_id:155812)“计算/通信”比更高，即花在计算上的时间相对于花在通信上的时间更多。因此，最小化SVR旨在**提高[并行效率](@entry_id:637464)**。

*   **界面角度对齐 (Interface Angle Alignment)**: 这是一个输运问题特有的指标。它衡量的是子域界面的法向量与所有[输运扫描](@entry_id:1133407)方向的平均对齐程度。如果界面与大量扫描方向近乎垂直，那么这些界面就会成为许多扫描的“强”依赖边界，导致长的处理器依赖链和大量的处理器等待时间。反之，如果界面与扫描方向平均来说更“平行”，则依赖链更短、更宽，并行度更高。因此，最小化此指标旨在**增加扫描的并发性，减少处理器空闲时间**。

### 并行环境下的迭代方案与收敛性

在实际应用中，输运求解通常是一个迭代过程，其中最经典的是**源迭代 (Source Iteration, SI)**。[并行化策略](@entry_id:753105)对这些迭代过程的收敛性有着深刻的影响。

**并行环境中的[源迭代](@entry_id:1131994)**

[输运方程](@entry_id:174281)可以抽象地写为 $L \psi = S \psi + Q$，其中 $L$ 是包含流和移出项的可逆算子，$S$ 是散射（和裂变）源算子。[源迭代](@entry_id:1131994)法通过以下方式求解：
$$
\psi^{(k+1)} = L^{-1} (S \psi^{(k)} + Q)
$$
其中 $k$ 是迭代次数。在并行环境中，这个过程分为两步 ：
1.  **源项计算**: 计算 $S \psi^{(k)}$。散射过程在物理上是局域的，即一点处的散射源仅依赖于该点处的角通量。因此，这一步是**空间局域**的，每个处理器可以独立计算其子域内的源项，**无需通信**。
2.  **输运扫描**: 计算 $L^{-1}(\dots)$。这一步对应于一次全域的输运扫描，是**非局域**的。如前所述，它要求在子域边界上进行通信，以传递入射角通量。

**并行策略对收敛速度的影响**

[迭代算法](@entry_id:160288)的收敛速度由其[误差传播](@entry_id:147381)[算子的谱半径](@entry_id:261858) $\rho$ 决定，$\rho$ 越小，收敛越快。不同的并行策略会导致不同的误差传播算子。

对于[源迭代](@entry_id:1131994)，其误差传播算子为 $M = L^{-1}S$。在并行实现中，对 $L^{-1}$ 的近似方式直接影响了 $M$。

*   **类高斯-赛德尔 (Gauss-Seidel-like) 策略**: KBA扫描算法本质上是一种类高斯-赛德尔方法。因为它严格按照上游到下游的顺序处理单元，并立即使用最新计算出的边界通量，其“组装”起来的全局作用等价于理想的、单处理器上的 $L^{-1}$ 算子。因此，这种策略下的迭代算子与单处理器（或称“整体式”）情况完全相同，其谱半径也相同。这种方法的代价是其内在的顺序性限制了可用的并行度 。

*   **类雅可比 (Jacobi-like) 策略**: 另一种策略是所有子域完全并行地进行计算，但用于边界条件的入射通量全部取自上一次全局迭代（$k$ 次迭代）的结果。这种“延迟更新”的策略类似于[雅可比迭代](@entry_id:139235)。它打破了KBA的顺序依赖，实现了更高的并行度，但改变了[误差传播](@entry_id:147381)算子。由于误差的修正信息在子域间的传播被延迟了一个迭代步，全局性、长波长的误差模式的衰减会变得非常缓慢。这通常会导致迭代算子的**[谱半径](@entry_id:138984)增大**，从而**减慢[收敛速度](@entry_id:636873)** 。这种并行度与收敛速度之间的权衡，是并行迭代方法设计中的一个核心主题。

这一区别也可以用加性与[乘性](@entry_id:187940)Schwarz迭代的框架来理解。类[雅可比方法](@entry_id:270947)对应于**加性Schwarz (Additive Schwarz)**，所有子域的修正量并行计算然后相加；而类高斯-赛德尔方法对应于**乘性Schwarz (Multiplicative Schwarz)**，[子域](@entry_id:155812)的修正按序进行并立即应用 。

**[扩散极限](@entry_id:168181)的挑战与双层方法**

在反应堆物理中常见的**[扩散极限](@entry_id:168181)**（即问题在光学上很厚，且散射远大于吸收）下，[源迭代](@entry_id:1131994)的收敛性会急剧恶化，其[谱半径](@entry_id:138984)会趋近于1。在这样的问题中，采用类雅可比的并行策略会使情况雪上加霜 。

这种收敛停滞的根本原因在于，上述“单层”的[区域分解](@entry_id:165934)方法（无论是加性还是[乘性](@entry_id:187940)）都是一种**局域[平滑器](@entry_id:636528)**：它们能有效地消除高频、局域的误差，但对于贯穿多个[子域](@entry_id:155812)的、平滑的、长波长的[全局误差](@entry_id:147874)分量却[无能](@entry_id:201612)为力。这些[全局误差](@entry_id:147874)模式正是导致收敛停滞的罪魁祸首 。

为了克服这一瓶颈，需要引入**双层 (two-level)** 方法。双层方法在局域平滑（第一层）的基础上，增加了一个**全局粗空间校正 (global coarse-space correction)**（第二层）。这个粗校正步骤旨在一次性地消除那些单层方法难以处理的[全局误差](@entry_id:147874)。

选择什么样的粗空间至关重要。根据渐进分析，输运问题中难以收敛的[全局误差](@entry_id:147874)模式在行为上非常接近于一个**扩散问题**的解。因此，一个物理上合理的、有效的粗空间校[正问题](@entry_id:749532)就是一个在全局尺度上求解的、形式如下的[扩散方程](@entry_id:170713)：
$$
-\nabla \cdot ( D(\mathbf{x}) \nabla \phi(\mathbf{x}) ) + \Sigma_a(\mathbf{x}) \phi(\mathbf{x}) = Q(\mathbf{x})
$$
其中 $\phi$ 是标通量，而 $D$ 和 $\Sigma_a$ 分别是根据[输运截面](@entry_id:1133392)导出的扩散系数和[吸收截面](@entry_id:172609)。通过求解这个更简单、但能捕捉正确全局物理的粗问题，可以有效地加速整体输运迭代的收敛。这构成了诸如**[扩散综合加速](@entry_id:1123717) (Diffusion Synthetic Acceleration, DSA)** 等先进加速技术的基础，也是现代可扩展并行输运求解器不可或缺的一部分 。